#
ifndef
mozilla_a11y_DocAccessible_h__
#
define
mozilla_a11y_DocAccessible_h__
#
include
"
HyperTextAccessible
.
h
"
#
include
"
AccEvent
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsIDocumentObserver
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
"
nsWeakReference
.
h
"
const
uint32_t
kDefaultCacheLength
=
128
;
namespace
mozilla
{
class
EditorBase
;
class
PresShell
;
namespace
dom
{
class
Document
;
}
namespace
a11y
{
class
DocManager
;
class
NotificationController
;
class
DocAccessibleChild
;
class
RelatedAccIterator
;
template
<
class
Class
class
.
.
.
Args
>
class
TNotification
;
class
DocAccessible
:
public
HyperTextAccessible
public
nsIDocumentObserver
public
nsSupportsWeakReference
{
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
DocAccessible
LocalAccessible
)
protected
:
typedef
mozilla
:
:
dom
:
:
Document
Document
;
public
:
DocAccessible
(
Document
*
aDocument
PresShell
*
aPresShell
)
;
NS_DECL_NSIDOCUMENTOBSERVER
virtual
void
Init
(
)
;
virtual
void
Shutdown
(
)
override
;
virtual
nsIFrame
*
GetFrame
(
)
const
override
;
virtual
nsINode
*
GetNode
(
)
const
override
;
Document
*
DocumentNode
(
)
const
{
return
mDocumentNode
;
}
virtual
mozilla
:
:
a11y
:
:
ENameValueFlag
Name
(
nsString
&
aName
)
const
override
;
virtual
void
Description
(
nsString
&
aDescription
)
const
override
;
virtual
Accessible
*
FocusedChild
(
)
override
;
virtual
mozilla
:
:
a11y
:
:
role
NativeRole
(
)
const
override
;
virtual
uint64_t
NativeState
(
)
const
override
;
virtual
uint64_t
NativeInteractiveState
(
)
const
override
;
virtual
bool
NativelyUnavailable
(
)
const
override
;
virtual
void
ApplyARIAState
(
uint64_t
*
aState
)
const
override
;
virtual
void
TakeFocus
(
)
const
override
;
#
ifdef
A11Y_LOG
virtual
nsresult
HandleAccEvent
(
AccEvent
*
aEvent
)
override
;
#
endif
virtual
nsRect
RelativeBounds
(
nsIFrame
*
*
aRelativeFrame
)
const
override
;
virtual
bool
HasPrimaryAction
(
)
const
override
;
virtual
void
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
override
;
virtual
already_AddRefed
<
EditorBase
>
GetEditor
(
)
const
override
;
void
URL
(
nsAString
&
aURL
)
const
;
void
Title
(
nsString
&
aTitle
)
const
;
void
MimeType
(
nsAString
&
aType
)
const
;
void
DocType
(
nsAString
&
aType
)
const
;
void
QueueCacheUpdate
(
LocalAccessible
*
aAcc
uint64_t
aNewDomain
bool
aBypassActiveDomains
=
false
)
;
void
QueueCacheUpdateForDependentRelations
(
LocalAccessible
*
aAcc
)
;
bool
HasShutdown
(
)
const
{
return
!
mPresShell
;
}
PresShell
*
PresShellPtr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
!
HasShutdown
(
)
)
;
return
mPresShell
;
}
nsPresContext
*
PresContext
(
)
const
;
bool
IsContentLoaded
(
)
const
;
bool
IsHidden
(
)
const
;
void
SetViewportCacheDirty
(
bool
aDirty
)
{
mViewportCacheDirty
=
aDirty
;
}
enum
LoadState
{
eTreeConstructionPending
=
0
eTreeConstructed
=
1
eDOMLoaded
=
1
<
<
1
eReady
=
eTreeConstructed
|
eDOMLoaded
eCompletelyLoaded
=
eReady
|
1
<
<
2
}
;
bool
HasLoadState
(
LoadState
aState
)
const
{
return
(
mLoadState
&
static_cast
<
uint32_t
>
(
aState
)
)
=
=
static_cast
<
uint32_t
>
(
aState
)
;
}
virtual
void
*
GetNativeWindow
(
)
const
;
DocAccessible
*
ParentDocument
(
)
const
{
return
mParent
?
mParent
-
>
Document
(
)
:
nullptr
;
}
uint32_t
ChildDocumentCount
(
)
const
{
return
mChildDocuments
.
Length
(
)
;
}
DocAccessible
*
GetChildDocumentAt
(
uint32_t
aIndex
)
const
{
return
mChildDocuments
.
SafeElementAt
(
aIndex
nullptr
)
;
}
void
FireDelayedEvent
(
AccEvent
*
aEvent
)
;
void
FireDelayedEvent
(
uint32_t
aEventType
LocalAccessible
*
aTarget
)
;
void
FireEventsOnInsertion
(
LocalAccessible
*
aContainer
)
;
void
MaybeNotifyOfValueChange
(
LocalAccessible
*
aAccessible
)
;
LocalAccessible
*
AnchorJump
(
)
{
return
GetAccessibleOrContainer
(
mAnchorJumpElm
)
;
}
void
SetAnchorJump
(
nsIContent
*
aTargetNode
)
{
mAnchorJumpElm
=
aTargetNode
;
}
void
BindChildDocument
(
DocAccessible
*
aDocument
)
;
template
<
class
Class
class
.
.
.
Args
>
void
HandleNotification
(
Class
*
aInstance
typename
TNotification
<
Class
Args
.
.
.
>
:
:
Callback
aMethod
Args
*
.
.
.
aArgs
)
;
LocalAccessible
*
GetAccessible
(
nsINode
*
aNode
)
const
;
LocalAccessible
*
GetAccessibleEvenIfNotInMap
(
nsINode
*
aNode
)
const
;
LocalAccessible
*
GetAccessibleEvenIfNotInMapOrContainer
(
nsINode
*
aNode
)
const
;
bool
HasAccessible
(
nsINode
*
aNode
)
const
{
return
GetAccessible
(
aNode
)
;
}
LocalAccessible
*
GetAccessibleByUniqueID
(
void
*
aUniqueID
)
{
return
UniqueID
(
)
=
=
aUniqueID
?
this
:
mAccessibleCache
.
GetWeak
(
aUniqueID
)
;
}
LocalAccessible
*
GetAccessibleByUniqueIDInSubtree
(
void
*
aUniqueID
)
;
LocalAccessible
*
GetAccessibleOrContainer
(
nsINode
*
aNode
bool
aNoContainerIfPruned
=
false
)
const
;
LocalAccessible
*
GetContainerAccessible
(
nsINode
*
aNode
)
const
;
LocalAccessible
*
AccessibleOrTrueContainer
(
nsINode
*
aNode
bool
aNoContainerIfPruned
=
false
)
const
;
LocalAccessible
*
GetAccessibleOrDescendant
(
nsINode
*
aNode
)
const
;
LocalAccessible
*
ARIAOwnedAt
(
LocalAccessible
*
aParent
uint32_t
aIndex
)
const
{
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
children
=
mARIAOwnsHash
.
Get
(
aParent
)
;
if
(
children
)
{
return
children
-
>
SafeElementAt
(
aIndex
)
;
}
return
nullptr
;
}
uint32_t
ARIAOwnedCount
(
LocalAccessible
*
aParent
)
const
{
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
children
=
mARIAOwnsHash
.
Get
(
aParent
)
;
return
children
?
children
-
>
Length
(
)
:
0
;
}
bool
IsDependentID
(
dom
:
:
Element
*
aElement
const
nsAString
&
aID
)
const
{
return
GetRelProviders
(
aElement
aID
)
;
}
void
BindToDocument
(
LocalAccessible
*
aAccessible
const
nsRoleMapEntry
*
aRoleMapEntry
)
;
void
UnbindFromDocument
(
LocalAccessible
*
aAccessible
)
;
void
ContentInserted
(
nsIContent
*
aStartChildNode
nsIContent
*
aEndChildNode
)
;
void
ScheduleTreeUpdate
(
nsIContent
*
aContent
)
;
void
ContentRemoved
(
LocalAccessible
*
aAccessible
)
;
void
ContentRemoved
(
nsIContent
*
aContentNode
)
;
void
UpdateText
(
nsIContent
*
aTextNode
)
;
void
RecreateAccessible
(
nsIContent
*
aContent
)
;
bool
RelocateARIAOwnedIfNeeded
(
nsIContent
*
aEl
)
;
NotificationController
*
Controller
(
)
const
{
return
mNotificationController
;
}
DocAccessibleChild
*
IPCDoc
(
)
const
{
return
mIPCDoc
;
}
void
HandleScroll
(
nsINode
*
aTarget
)
;
std
:
:
pair
<
nsPoint
nsRect
>
ComputeScrollData
(
LocalAccessible
*
aAcc
)
;
bool
IsAccessibleBeingMoved
(
LocalAccessible
*
aAcc
)
{
return
mMovedAccessibles
.
Contains
(
aAcc
)
;
}
void
AttrElementWillChange
(
dom
:
:
Element
*
aElement
nsAtom
*
aAttr
)
;
void
AttrElementChanged
(
dom
:
:
Element
*
aElement
nsAtom
*
aAttr
)
;
protected
:
virtual
~
DocAccessible
(
)
;
void
LastRelease
(
)
;
virtual
nsresult
AddEventListeners
(
)
;
virtual
nsresult
RemoveEventListeners
(
)
;
void
NotifyOfLoad
(
uint32_t
aLoadEventType
)
;
void
NotifyOfLoading
(
bool
aIsReloading
)
;
friend
class
DocManager
;
virtual
void
DoInitialUpdate
(
)
;
void
UpdateRootElIfNeeded
(
)
;
void
ProcessLoad
(
)
;
bool
AppendChildDocument
(
DocAccessible
*
aChildDocument
)
{
mChildDocuments
.
AppendElement
(
aChildDocument
)
;
return
true
;
}
void
RemoveChildDocument
(
DocAccessible
*
aChildDocument
)
{
mChildDocuments
.
RemoveElement
(
aChildDocument
)
;
}
void
AddDependentIDsFor
(
LocalAccessible
*
aRelProvider
nsAtom
*
aRelAttr
=
nullptr
)
;
void
RemoveDependentIDsFor
(
LocalAccessible
*
aRelProvider
nsAtom
*
aRelAttr
=
nullptr
)
;
void
AddDependentElementsFor
(
LocalAccessible
*
aRelProvider
nsAtom
*
aRelAttr
=
nullptr
)
;
void
RemoveDependentElementsFor
(
LocalAccessible
*
aRelProvider
nsAtom
*
aRelAttr
=
nullptr
)
;
bool
UpdateAccessibleOnAttrChange
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsAtom
*
aAttribute
)
;
void
ARIAActiveDescendantChanged
(
LocalAccessible
*
aAccessible
)
;
void
ProcessContentInserted
(
LocalAccessible
*
aContainer
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
aInsertedContent
)
;
void
ProcessContentInserted
(
LocalAccessible
*
aContainer
nsIContent
*
aInsertedContent
)
;
void
ProcessInvalidationList
(
)
;
void
ProcessPendingUpdates
(
)
;
void
ProcessQueuedCacheUpdates
(
uint64_t
aInitialDomains
=
0
)
;
void
SendAccessiblesWillMove
(
)
;
void
ClearMutationData
(
)
{
mMovedAccessibles
.
Clear
(
)
;
mInsertedAccessibles
.
Clear
(
)
;
mRemovedNodes
.
Clear
(
)
;
}
void
DoARIAOwnsRelocation
(
LocalAccessible
*
aOwner
)
;
void
PutChildrenBack
(
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
aChildren
uint32_t
aStartIdx
)
;
bool
MoveChild
(
LocalAccessible
*
aChild
LocalAccessible
*
aNewParent
int32_t
aIdxInParent
)
;
void
CacheChildrenInSubtree
(
LocalAccessible
*
aRoot
LocalAccessible
*
*
aFocusedAcc
=
nullptr
)
;
void
CreateSubtree
(
LocalAccessible
*
aRoot
)
;
void
UncacheChildrenInSubtree
(
LocalAccessible
*
aRoot
)
;
void
ShutdownChildrenInSubtree
(
LocalAccessible
*
aAccessible
)
;
bool
IsLoadEventTarget
(
)
const
;
void
SetIPCDoc
(
DocAccessibleChild
*
aIPCDoc
)
;
friend
class
DocAccessibleChild
;
static
void
ScrollTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
DispatchScrollingEvent
(
nsINode
*
aTarget
uint32_t
aEventType
)
;
void
ARIAActiveDescendantIDMaybeMoved
(
LocalAccessible
*
aAccessible
)
;
bool
PruneOrInsertSubtree
(
nsIContent
*
aRoot
)
;
protected
:
enum
{
eTopLevelContentDocInProcess
=
1
<
<
0
}
;
AccessibleHashtable
mAccessibleCache
;
nsTHashMap
<
nsPtrHashKey
<
const
nsINode
>
LocalAccessible
*
>
mNodeToAccessibleMap
;
Document
*
mDocumentNode
;
nsCOMPtr
<
nsITimer
>
mScrollWatchTimer
;
nsTHashMap
<
nsPtrHashKey
<
nsINode
>
TimeStamp
>
mLastScrollingDispatch
;
uint32_t
mLoadState
:
3
;
uint32_t
mDocFlags
:
27
;
bool
mViewportCacheDirty
:
1
;
uint32_t
mLoadEventType
;
nsCOMPtr
<
nsIContent
>
mAnchorJumpElm
;
uint64_t
mPrevStateBits
;
nsTArray
<
RefPtr
<
DocAccessible
>
>
mChildDocuments
;
class
AttrRelProvider
{
public
:
AttrRelProvider
(
nsAtom
*
aRelAttr
nsIContent
*
aContent
)
:
mRelAttr
(
aRelAttr
)
mContent
(
aContent
)
{
}
nsAtom
*
mRelAttr
;
nsCOMPtr
<
nsIContent
>
mContent
;
private
:
AttrRelProvider
(
)
;
AttrRelProvider
(
const
AttrRelProvider
&
)
;
AttrRelProvider
&
operator
=
(
const
AttrRelProvider
&
)
;
}
;
typedef
nsTArray
<
mozilla
:
:
UniquePtr
<
AttrRelProvider
>
>
AttrRelProviders
;
typedef
nsClassHashtable
<
nsStringHashKey
AttrRelProviders
>
DependentIDsHashtable
;
AttrRelProviders
*
GetRelProviders
(
dom
:
:
Element
*
aElement
const
nsAString
&
aID
)
const
;
AttrRelProviders
*
GetOrCreateRelProviders
(
dom
:
:
Element
*
aElement
const
nsAString
&
aID
)
;
void
RemoveRelProvidersIfEmpty
(
dom
:
:
Element
*
aElement
const
nsAString
&
aID
)
;
nsClassHashtable
<
nsPtrHashKey
<
dom
:
:
DocumentOrShadowRoot
>
DependentIDsHashtable
>
mDependentIDsHashes
;
nsTHashMap
<
nsIContent
*
AttrRelProviders
>
mDependentElementsMap
;
friend
class
RelatedAccIterator
;
nsTArray
<
RefPtr
<
nsIContent
>
>
mInvalidationList
;
nsClassHashtable
<
nsPtrHashKey
<
LocalAccessible
>
nsTArray
<
RefPtr
<
LocalAccessible
>
>
>
mARIAOwnsHash
;
nsTArray
<
RefPtr
<
nsIContent
>
>
mPendingUpdates
;
RefPtr
<
NotificationController
>
mNotificationController
;
friend
class
EventTree
;
friend
class
NotificationController
;
friend
class
:
:
nsAccessibilityService
;
private
:
void
SetRoleMapEntryForDoc
(
dom
:
:
Element
*
aElement
)
;
void
TrackMovedAccessible
(
LocalAccessible
*
aAcc
)
;
void
MaybeHandleChangeToHiddenNameOrDescription
(
nsIContent
*
aChild
)
;
void
MaybeFireEventsForChangedPopover
(
LocalAccessible
*
aAcc
)
;
PresShell
*
mPresShell
;
DocAccessibleChild
*
mIPCDoc
;
nsTArray
<
std
:
:
pair
<
RefPtr
<
LocalAccessible
>
uint64_t
>
>
mQueuedCacheUpdatesArray
;
nsTHashMap
<
LocalAccessible
*
size_t
>
mQueuedCacheUpdatesHash
;
nsTHashSet
<
RefPtr
<
LocalAccessible
>
>
mMovedAccessibles
;
nsTHashSet
<
RefPtr
<
LocalAccessible
>
>
mInsertedAccessibles
;
nsTHashSet
<
nsIContent
*
>
mRemovedNodes
;
}
;
inline
DocAccessible
*
LocalAccessible
:
:
AsDoc
(
)
{
return
IsDoc
(
)
?
static_cast
<
DocAccessible
*
>
(
this
)
:
nullptr
;
}
}
}
#
endif
