#
ifndef
mozilla_a11y_DocAccessible_h__
#
define
mozilla_a11y_DocAccessible_h__
#
include
"
nsIAccessiblePivot
.
h
"
#
include
"
HyperTextAccessibleWrap
.
h
"
#
include
"
AccEvent
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDocumentObserver
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIScrollPositionListener
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIWeakReference
.
h
"
class
nsAccessiblePivot
;
const
uint32_t
kDefaultCacheLength
=
128
;
namespace
mozilla
{
class
TextEditor
;
namespace
a11y
{
class
DocManager
;
class
NotificationController
;
class
DocAccessibleChild
;
class
RelatedAccIterator
;
template
<
class
Class
class
.
.
.
Args
>
class
TNotification
;
class
DocAccessible
:
public
HyperTextAccessibleWrap
public
nsIDocumentObserver
public
nsIObserver
public
nsIScrollPositionListener
public
nsSupportsWeakReference
public
nsIAccessiblePivotObserver
{
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
DocAccessible
Accessible
)
NS_DECL_NSIOBSERVER
NS_DECL_NSIACCESSIBLEPIVOTOBSERVER
public
:
DocAccessible
(
nsIDocument
*
aDocument
nsIPresShell
*
aPresShell
)
;
virtual
void
ScrollPositionWillChange
(
nscoord
aX
nscoord
aY
)
override
{
}
virtual
void
ScrollPositionDidChange
(
nscoord
aX
nscoord
aY
)
override
;
NS_DECL_NSIDOCUMENTOBSERVER
virtual
void
Init
(
)
;
virtual
void
Shutdown
(
)
override
;
virtual
nsIFrame
*
GetFrame
(
)
const
override
;
virtual
nsINode
*
GetNode
(
)
const
override
{
return
mDocumentNode
;
}
nsIDocument
*
DocumentNode
(
)
const
{
return
mDocumentNode
;
}
virtual
mozilla
:
:
a11y
:
:
ENameValueFlag
Name
(
nsString
&
aName
)
const
override
;
virtual
void
Description
(
nsString
&
aDescription
)
override
;
virtual
Accessible
*
FocusedChild
(
)
override
;
virtual
mozilla
:
:
a11y
:
:
role
NativeRole
(
)
const
override
;
virtual
uint64_t
NativeState
(
)
const
override
;
virtual
uint64_t
NativeInteractiveState
(
)
const
override
;
virtual
bool
NativelyUnavailable
(
)
const
override
;
virtual
void
ApplyARIAState
(
uint64_t
*
aState
)
const
override
;
virtual
already_AddRefed
<
nsIPersistentProperties
>
Attributes
(
)
override
;
virtual
void
TakeFocus
(
)
const
override
;
#
ifdef
A11Y_LOG
virtual
nsresult
HandleAccEvent
(
AccEvent
*
aEvent
)
override
;
#
endif
virtual
nsRect
RelativeBounds
(
nsIFrame
*
*
aRelativeFrame
)
const
override
;
virtual
already_AddRefed
<
TextEditor
>
GetEditor
(
)
const
override
;
void
URL
(
nsAString
&
aURL
)
const
;
void
Title
(
nsString
&
aTitle
)
const
{
mDocumentNode
-
>
GetTitle
(
aTitle
)
;
}
void
MimeType
(
nsAString
&
aType
)
const
{
mDocumentNode
-
>
GetContentType
(
aType
)
;
}
void
DocType
(
nsAString
&
aType
)
const
;
nsIAccessiblePivot
*
VirtualCursor
(
)
;
nsIPresShell
*
PresShell
(
)
const
{
return
mPresShell
;
}
nsPresContext
*
PresContext
(
)
const
{
return
mPresShell
-
>
GetPresContext
(
)
;
}
bool
IsContentLoaded
(
)
const
{
return
mDocumentNode
&
&
mDocumentNode
-
>
IsVisible
(
)
&
&
(
mDocumentNode
-
>
IsShowing
(
)
|
|
HasLoadState
(
eDOMLoaded
)
)
;
}
bool
IsHidden
(
)
const
{
return
mDocumentNode
-
>
Hidden
(
)
;
}
enum
LoadState
{
eTreeConstructionPending
=
0
eTreeConstructed
=
1
eDOMLoaded
=
1
<
<
1
eReady
=
eTreeConstructed
|
eDOMLoaded
eCompletelyLoaded
=
eReady
|
1
<
<
2
}
;
bool
HasLoadState
(
LoadState
aState
)
const
{
return
(
mLoadState
&
static_cast
<
uint32_t
>
(
aState
)
)
=
=
static_cast
<
uint32_t
>
(
aState
)
;
}
virtual
void
*
GetNativeWindow
(
)
const
;
DocAccessible
*
ParentDocument
(
)
const
{
return
mParent
?
mParent
-
>
Document
(
)
:
nullptr
;
}
uint32_t
ChildDocumentCount
(
)
const
{
return
mChildDocuments
.
Length
(
)
;
}
DocAccessible
*
GetChildDocumentAt
(
uint32_t
aIndex
)
const
{
return
mChildDocuments
.
SafeElementAt
(
aIndex
nullptr
)
;
}
void
FireDelayedEvent
(
AccEvent
*
aEvent
)
;
void
FireDelayedEvent
(
uint32_t
aEventType
Accessible
*
aTarget
)
;
void
FireEventsOnInsertion
(
Accessible
*
aContainer
)
;
void
MaybeNotifyOfValueChange
(
Accessible
*
aAccessible
)
;
Accessible
*
AnchorJump
(
)
{
return
GetAccessibleOrContainer
(
mAnchorJumpElm
)
;
}
void
SetAnchorJump
(
nsIContent
*
aTargetNode
)
{
mAnchorJumpElm
=
aTargetNode
;
}
void
BindChildDocument
(
DocAccessible
*
aDocument
)
;
template
<
class
Class
class
Arg
>
void
HandleNotification
(
Class
*
aInstance
typename
TNotification
<
Class
Arg
>
:
:
Callback
aMethod
Arg
*
aArg
)
;
Accessible
*
GetAccessible
(
nsINode
*
aNode
)
const
{
return
aNode
=
=
mDocumentNode
?
const_cast
<
DocAccessible
*
>
(
this
)
:
mNodeToAccessibleMap
.
Get
(
aNode
)
;
}
Accessible
*
GetAccessibleEvenIfNotInMap
(
nsINode
*
aNode
)
const
;
Accessible
*
GetAccessibleEvenIfNotInMapOrContainer
(
nsINode
*
aNode
)
const
;
bool
HasAccessible
(
nsINode
*
aNode
)
const
{
return
GetAccessible
(
aNode
)
;
}
Accessible
*
GetAccessibleByUniqueID
(
void
*
aUniqueID
)
{
return
UniqueID
(
)
=
=
aUniqueID
?
this
:
mAccessibleCache
.
GetWeak
(
aUniqueID
)
;
}
Accessible
*
GetAccessibleByUniqueIDInSubtree
(
void
*
aUniqueID
)
;
enum
{
eIgnoreARIAHidden
=
0
eNoContainerIfARIAHidden
=
1
}
;
Accessible
*
GetAccessibleOrContainer
(
nsINode
*
aNode
int
aARIAHiddenFlag
=
eIgnoreARIAHidden
)
const
;
Accessible
*
GetContainerAccessible
(
nsINode
*
aNode
)
const
{
return
aNode
?
GetAccessibleOrContainer
(
aNode
-
>
GetParentNode
(
)
)
:
nullptr
;
}
Accessible
*
AccessibleOrTrueContainer
(
nsINode
*
aNode
int
aARIAHiddenFlag
=
eIgnoreARIAHidden
)
const
;
Accessible
*
GetAccessibleOrDescendant
(
nsINode
*
aNode
)
const
;
Accessible
*
ARIAOwnedAt
(
Accessible
*
aParent
uint32_t
aIndex
)
const
{
nsTArray
<
RefPtr
<
Accessible
>
>
*
children
=
mARIAOwnsHash
.
Get
(
aParent
)
;
if
(
children
)
{
return
children
-
>
SafeElementAt
(
aIndex
)
;
}
return
nullptr
;
}
uint32_t
ARIAOwnedCount
(
Accessible
*
aParent
)
const
{
nsTArray
<
RefPtr
<
Accessible
>
>
*
children
=
mARIAOwnsHash
.
Get
(
aParent
)
;
return
children
?
children
-
>
Length
(
)
:
0
;
}
bool
IsDependentID
(
const
nsAString
&
aID
)
const
{
return
mDependentIDsHash
.
Get
(
aID
nullptr
)
;
}
void
BindToDocument
(
Accessible
*
aAccessible
const
nsRoleMapEntry
*
aRoleMapEntry
)
;
void
UnbindFromDocument
(
Accessible
*
aAccessible
)
;
void
ContentInserted
(
nsIContent
*
aContainerNode
nsIContent
*
aStartChildNode
nsIContent
*
aEndChildNode
)
;
void
ContentRemoved
(
Accessible
*
aAccessible
)
;
void
ContentRemoved
(
nsIContent
*
aContentNode
)
;
void
UpdateText
(
nsIContent
*
aTextNode
)
;
void
RecreateAccessible
(
nsIContent
*
aContent
)
;
bool
RelocateARIAOwnedIfNeeded
(
nsIContent
*
aEl
)
;
NotificationController
*
Controller
(
)
const
{
return
mNotificationController
;
}
DocAccessibleChild
*
IPCDoc
(
)
const
{
return
mIPCDoc
;
}
protected
:
virtual
~
DocAccessible
(
)
;
void
LastRelease
(
)
;
virtual
nsresult
AddEventListeners
(
)
;
virtual
nsresult
RemoveEventListeners
(
)
;
void
NotifyOfLoad
(
uint32_t
aLoadEventType
)
;
void
NotifyOfLoading
(
bool
aIsReloading
)
;
friend
class
DocManager
;
virtual
void
DoInitialUpdate
(
)
;
void
UpdateRootElIfNeeded
(
)
;
void
ProcessLoad
(
)
;
void
AddScrollListener
(
)
;
void
RemoveScrollListener
(
)
;
bool
AppendChildDocument
(
DocAccessible
*
aChildDocument
)
{
return
mChildDocuments
.
AppendElement
(
aChildDocument
)
;
}
void
RemoveChildDocument
(
DocAccessible
*
aChildDocument
)
{
mChildDocuments
.
RemoveElement
(
aChildDocument
)
;
}
void
AddDependentIDsFor
(
Accessible
*
aRelProvider
nsAtom
*
aRelAttr
=
nullptr
)
;
void
RemoveDependentIDsFor
(
Accessible
*
aRelProvider
nsAtom
*
aRelAttr
=
nullptr
)
;
bool
UpdateAccessibleOnAttrChange
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsAtom
*
aAttribute
)
;
void
AttributeChangedImpl
(
Accessible
*
aAccessible
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
;
void
ARIAAttributeChanged
(
Accessible
*
aAccessible
nsAtom
*
aAttribute
)
;
void
ARIAActiveDescendantChanged
(
Accessible
*
aAccessible
)
;
void
ProcessContentInserted
(
Accessible
*
aContainer
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
aInsertedContent
)
;
void
ProcessContentInserted
(
Accessible
*
aContainer
nsIContent
*
aInsertedContent
)
;
void
ProcessInvalidationList
(
)
;
void
DoARIAOwnsRelocation
(
Accessible
*
aOwner
)
;
void
PutChildrenBack
(
nsTArray
<
RefPtr
<
Accessible
>
>
*
aChildren
uint32_t
aStartIdx
)
;
bool
MoveChild
(
Accessible
*
aChild
Accessible
*
aNewParent
int32_t
aIdxInParent
)
;
void
CacheChildrenInSubtree
(
Accessible
*
aRoot
Accessible
*
*
aFocusedAcc
=
nullptr
)
;
void
CreateSubtree
(
Accessible
*
aRoot
)
;
void
UncacheChildrenInSubtree
(
Accessible
*
aRoot
)
;
void
ShutdownChildrenInSubtree
(
Accessible
*
aAccessible
)
;
bool
IsLoadEventTarget
(
)
const
;
void
SetIPCDoc
(
DocAccessibleChild
*
aIPCDoc
)
{
mIPCDoc
=
aIPCDoc
;
}
friend
class
DocAccessibleChildBase
;
static
void
ScrollTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
protected
:
enum
{
eScrollInitialized
=
1
<
<
0
eTabDocument
=
1
<
<
1
}
;
AccessibleHashtable
mAccessibleCache
;
nsDataHashtable
<
nsPtrHashKey
<
const
nsINode
>
Accessible
*
>
mNodeToAccessibleMap
;
nsIDocument
*
mDocumentNode
;
nsCOMPtr
<
nsITimer
>
mScrollWatchTimer
;
uint16_t
mScrollPositionChangedTicks
;
uint32_t
mLoadState
:
3
;
uint32_t
mDocFlags
:
28
;
uint32_t
mLoadEventType
;
nsCOMPtr
<
nsIContent
>
mAnchorJumpElm
;
union
{
nsAtom
*
mARIAAttrOldValue
;
bool
mStateBitWasOn
;
}
;
nsTArray
<
RefPtr
<
DocAccessible
>
>
mChildDocuments
;
RefPtr
<
nsAccessiblePivot
>
mVirtualCursor
;
class
AttrRelProvider
{
public
:
AttrRelProvider
(
nsAtom
*
aRelAttr
nsIContent
*
aContent
)
:
mRelAttr
(
aRelAttr
)
mContent
(
aContent
)
{
}
nsAtom
*
mRelAttr
;
nsCOMPtr
<
nsIContent
>
mContent
;
private
:
AttrRelProvider
(
)
;
AttrRelProvider
(
const
AttrRelProvider
&
)
;
AttrRelProvider
&
operator
=
(
const
AttrRelProvider
&
)
;
}
;
typedef
nsTArray
<
nsAutoPtr
<
AttrRelProvider
>
>
AttrRelProviderArray
;
nsClassHashtable
<
nsStringHashKey
AttrRelProviderArray
>
mDependentIDsHash
;
friend
class
RelatedAccIterator
;
nsTArray
<
RefPtr
<
nsIContent
>
>
mInvalidationList
;
nsClassHashtable
<
nsPtrHashKey
<
Accessible
>
nsTArray
<
RefPtr
<
Accessible
>
>
>
mARIAOwnsHash
;
RefPtr
<
NotificationController
>
mNotificationController
;
friend
class
EventTree
;
friend
class
NotificationController
;
private
:
nsIPresShell
*
mPresShell
;
DocAccessibleChild
*
mIPCDoc
;
}
;
inline
DocAccessible
*
Accessible
:
:
AsDoc
(
)
{
return
IsDoc
(
)
?
static_cast
<
DocAccessible
*
>
(
this
)
:
nullptr
;
}
}
}
#
endif
