#
ifndef
mozilla_a11y_HyperTextAccessible_h__
#
define
mozilla_a11y_HyperTextAccessible_h__
#
include
"
AccessibleWrap
.
h
"
#
include
"
nsIAccessibleText
.
h
"
#
include
"
nsIAccessibleTypes
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsDirection
.
h
"
#
include
"
WordMovementType
.
h
"
class
nsFrameSelection
;
class
nsIFrame
;
class
nsRange
;
class
nsIWidget
;
namespace
mozilla
{
class
EditorBase
;
namespace
dom
{
class
Selection
;
}
namespace
a11y
{
class
TextLeafPoint
;
class
TextRange
;
struct
DOMPoint
{
DOMPoint
(
)
:
node
(
nullptr
)
idx
(
0
)
{
}
DOMPoint
(
nsINode
*
aNode
int32_t
aIdx
)
:
node
(
aNode
)
idx
(
aIdx
)
{
}
nsINode
*
node
;
int32_t
idx
;
}
;
const
char16_t
kEmbeddedObjectChar
=
0xfffc
;
const
char16_t
kImaginaryEmbeddedObjectChar
=
'
'
;
const
char16_t
kForcedNewLineChar
=
'
\
n
'
;
class
HyperTextAccessible
:
public
AccessibleWrap
{
public
:
HyperTextAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
;
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
HyperTextAccessible
AccessibleWrap
)
virtual
nsAtom
*
LandmarkRole
(
)
const
override
;
virtual
int32_t
GetLevelInternal
(
)
override
;
virtual
already_AddRefed
<
AccAttributes
>
NativeAttributes
(
)
override
;
virtual
mozilla
:
:
a11y
:
:
role
NativeRole
(
)
const
override
;
virtual
uint64_t
NativeState
(
)
const
override
;
virtual
void
Shutdown
(
)
override
;
virtual
bool
RemoveChild
(
LocalAccessible
*
aAccessible
)
override
;
virtual
bool
InsertChildAt
(
uint32_t
aIndex
LocalAccessible
*
aChild
)
override
;
virtual
Relation
RelationByType
(
RelationType
aType
)
const
override
;
nsresult
ContentToRenderedOffset
(
nsIFrame
*
aFrame
int32_t
aContentOffset
uint32_t
*
aRenderedOffset
)
const
;
nsresult
RenderedToContentOffset
(
nsIFrame
*
aFrame
uint32_t
aRenderedOffset
int32_t
*
aContentOffset
)
const
;
uint32_t
LinkCount
(
)
{
return
EmbeddedChildCount
(
)
;
}
LocalAccessible
*
LinkAt
(
uint32_t
aIndex
)
{
return
GetEmbeddedChildAt
(
aIndex
)
;
}
int32_t
LinkIndexOf
(
LocalAccessible
*
aLink
)
{
return
GetIndexOfEmbeddedChild
(
aLink
)
;
}
int32_t
LinkIndexAtOffset
(
uint32_t
aOffset
)
{
LocalAccessible
*
child
=
GetChildAtOffset
(
aOffset
)
;
return
child
?
LinkIndexOf
(
child
)
:
-
1
;
}
uint32_t
DOMPointToOffset
(
nsINode
*
aNode
int32_t
aNodeOffset
bool
aIsEndOffset
=
false
)
const
;
uint32_t
TransformOffset
(
LocalAccessible
*
aDescendant
uint32_t
aOffset
bool
aIsEndOffset
)
const
;
DOMPoint
OffsetToDOMPoint
(
int32_t
aOffset
)
const
;
uint32_t
CharacterCount
(
)
const
{
return
GetChildOffset
(
ChildCount
(
)
)
;
}
bool
CharAt
(
int32_t
aOffset
nsAString
&
aChar
int32_t
*
aStartOffset
=
nullptr
int32_t
*
aEndOffset
=
nullptr
)
{
NS_ASSERTION
(
!
aStartOffset
=
=
!
aEndOffset
"
Offsets
should
be
both
defined
or
both
undefined
!
"
)
;
int32_t
childIdx
=
GetChildIndexAtOffset
(
aOffset
)
;
if
(
childIdx
=
=
-
1
)
return
false
;
LocalAccessible
*
child
=
LocalChildAt
(
childIdx
)
;
child
-
>
AppendTextTo
(
aChar
aOffset
-
GetChildOffset
(
childIdx
)
1
)
;
if
(
aStartOffset
&
&
aEndOffset
)
{
*
aStartOffset
=
aOffset
;
*
aEndOffset
=
aOffset
+
aChar
.
Length
(
)
;
}
return
true
;
}
char16_t
CharAt
(
int32_t
aOffset
)
{
nsAutoString
charAtOffset
;
CharAt
(
aOffset
charAtOffset
)
;
return
charAtOffset
.
CharAt
(
0
)
;
}
bool
IsCharAt
(
int32_t
aOffset
char16_t
aChar
)
{
return
CharAt
(
aOffset
)
=
=
aChar
;
}
bool
IsLineEndCharAt
(
int32_t
aOffset
)
{
return
IsCharAt
(
aOffset
'
\
n
'
)
;
}
void
TextSubstring
(
int32_t
aStartOffset
int32_t
aEndOffset
nsAString
&
aText
)
;
void
TextBeforeOffset
(
int32_t
aOffset
AccessibleTextBoundary
aBoundaryType
int32_t
*
aStartOffset
int32_t
*
aEndOffset
nsAString
&
aText
)
;
void
TextAtOffset
(
int32_t
aOffset
AccessibleTextBoundary
aBoundaryType
int32_t
*
aStartOffset
int32_t
*
aEndOffset
nsAString
&
aText
)
;
void
TextAfterOffset
(
int32_t
aOffset
AccessibleTextBoundary
aBoundaryType
int32_t
*
aStartOffset
int32_t
*
aEndOffset
nsAString
&
aText
)
;
already_AddRefed
<
AccAttributes
>
TextAttributes
(
bool
aIncludeDefAttrs
int32_t
aOffset
int32_t
*
aStartOffset
int32_t
*
aEndOffset
)
;
already_AddRefed
<
AccAttributes
>
DefaultTextAttributes
(
)
;
int32_t
GetChildOffset
(
const
LocalAccessible
*
aChild
bool
aInvalidateAfter
=
false
)
const
{
int32_t
index
=
GetIndexOf
(
aChild
)
;
return
index
=
=
-
1
?
-
1
:
GetChildOffset
(
index
aInvalidateAfter
)
;
}
int32_t
GetChildOffset
(
uint32_t
aChildIndex
bool
aInvalidateAfter
=
false
)
const
;
int32_t
GetChildIndexAtOffset
(
uint32_t
aOffset
)
const
;
LocalAccessible
*
GetChildAtOffset
(
uint32_t
aOffset
)
const
{
return
LocalChildAt
(
GetChildIndexAtOffset
(
aOffset
)
)
;
}
bool
IsValidOffset
(
int32_t
aOffset
)
;
bool
IsValidRange
(
int32_t
aStartOffset
int32_t
aEndOffset
)
;
int32_t
OffsetAtPoint
(
int32_t
aX
int32_t
aY
uint32_t
aCoordType
)
;
nsIntRect
TextBounds
(
int32_t
aStartOffset
int32_t
aEndOffset
uint32_t
aCoordType
=
nsIAccessibleCoordinateType
:
:
COORDTYPE_SCREEN_RELATIVE
)
;
nsIntRect
CharBounds
(
int32_t
aOffset
uint32_t
aCoordType
)
{
int32_t
endOffset
=
aOffset
=
=
static_cast
<
int32_t
>
(
CharacterCount
(
)
)
?
aOffset
:
aOffset
+
1
;
return
TextBounds
(
aOffset
endOffset
aCoordType
)
;
}
int32_t
CaretOffset
(
)
const
;
void
SetCaretOffset
(
int32_t
aOffset
)
;
int32_t
CaretLineNumber
(
)
;
mozilla
:
:
LayoutDeviceIntRect
GetCaretRect
(
nsIWidget
*
*
aWidget
)
;
int32_t
SelectionCount
(
)
;
bool
SelectionBoundsAt
(
int32_t
aSelectionNum
int32_t
*
aStartOffset
int32_t
*
aEndOffset
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
bool
SetSelectionBoundsAt
(
int32_t
aSelectionNum
int32_t
aStartOffset
int32_t
aEndOffset
)
;
bool
AddToSelection
(
int32_t
aStartOffset
int32_t
aEndOffset
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
bool
RemoveFromSelection
(
int32_t
aSelectionNum
)
;
void
ScrollSubstringTo
(
int32_t
aStartOffset
int32_t
aEndOffset
uint32_t
aScrollType
)
;
void
ScrollSubstringToPoint
(
int32_t
aStartOffset
int32_t
aEndOffset
uint32_t
aCoordinateType
int32_t
aX
int32_t
aY
)
;
void
EnclosingRange
(
TextRange
&
aRange
)
const
;
void
SelectionRanges
(
nsTArray
<
TextRange
>
*
aRanges
)
const
;
void
VisibleRanges
(
nsTArray
<
TextRange
>
*
aRanges
)
const
;
void
RangeByChild
(
LocalAccessible
*
aChild
TextRange
&
aRange
)
const
;
void
RangeAtPoint
(
int32_t
aX
int32_t
aY
TextRange
&
aRange
)
const
;
TextLeafPoint
ToTextLeafPoint
(
int32_t
aOffset
bool
aDescendToEnd
=
false
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
ReplaceText
(
const
nsAString
&
aText
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
InsertText
(
const
nsAString
&
aText
int32_t
aPosition
)
;
void
CopyText
(
int32_t
aStartPos
int32_t
aEndPos
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
CutText
(
int32_t
aStartPos
int32_t
aEndPos
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
DeleteText
(
int32_t
aStartPos
int32_t
aEndPos
)
;
MOZ_CAN_RUN_SCRIPT
void
PasteText
(
int32_t
aPosition
)
;
virtual
already_AddRefed
<
EditorBase
>
GetEditor
(
)
const
;
dom
:
:
Selection
*
DOMSelection
(
)
const
;
protected
:
virtual
~
HyperTextAccessible
(
)
{
}
virtual
ENameValueFlag
NativeName
(
nsString
&
aName
)
const
override
;
index_t
ConvertMagicOffset
(
int32_t
aOffset
)
const
;
uint32_t
AdjustCaretOffset
(
uint32_t
aOffset
)
const
;
bool
IsCaretAtEndOfLine
(
)
const
;
bool
IsEmptyLastLineOffset
(
int32_t
aOffset
)
{
return
aOffset
=
=
static_cast
<
int32_t
>
(
CharacterCount
(
)
)
&
&
IsLineEndCharAt
(
aOffset
-
1
)
;
}
uint32_t
FindWordBoundary
(
uint32_t
aOffset
nsDirection
aDirection
EWordMovementType
aWordMovementType
)
;
enum
EWhichLineBoundary
{
ePrevLineBegin
ePrevLineEnd
eThisLineBegin
eThisLineEnd
eNextLineBegin
eNextLineEnd
}
;
uint32_t
FindLineBoundary
(
uint32_t
aOffset
EWhichLineBoundary
aWhichLineBoundary
)
;
int32_t
FindParagraphStartOffset
(
uint32_t
aOffset
)
;
int32_t
FindParagraphEndOffset
(
uint32_t
aOffset
)
;
uint32_t
FindOffset
(
uint32_t
aOffset
nsDirection
aDirection
nsSelectionAmount
aAmount
EWordMovementType
aWordMovementType
=
eDefaultBehavior
)
;
nsIntRect
GetBoundsInFrame
(
nsIFrame
*
aFrame
uint32_t
aStartRenderedOffset
uint32_t
aEndRenderedOffset
)
;
already_AddRefed
<
nsFrameSelection
>
FrameSelection
(
)
const
;
void
GetSelectionDOMRanges
(
SelectionType
aSelectionType
nsTArray
<
nsRange
*
>
*
aRanges
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
SetSelectionRange
(
int32_t
aStartPos
int32_t
aEndPos
)
;
nsresult
GetDOMPointByFrameOffset
(
nsIFrame
*
aFrame
int32_t
aOffset
LocalAccessible
*
aAccessible
mozilla
:
:
a11y
:
:
DOMPoint
*
aPoint
)
;
void
GetSpellTextAttr
(
nsINode
*
aNode
int32_t
aNodeOffset
uint32_t
*
aStartOffset
uint32_t
*
aEndOffset
AccAttributes
*
aAttributes
)
;
void
SetMathMLXMLRoles
(
AccAttributes
*
aAttributes
)
;
private
:
mutable
nsTArray
<
uint32_t
>
mOffsets
;
}
;
inline
HyperTextAccessible
*
LocalAccessible
:
:
AsHyperText
(
)
{
return
IsHyperText
(
)
?
static_cast
<
HyperTextAccessible
*
>
(
this
)
:
nullptr
;
}
}
}
#
endif
