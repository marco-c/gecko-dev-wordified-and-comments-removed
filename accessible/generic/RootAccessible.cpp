#
include
"
RootAccessible
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
define
CreateEvent
CreateEventA
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessibleParent
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsCoreUtils
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
Relation
.
h
"
#
include
"
Role
.
h
"
#
include
"
States
.
h
"
#
include
"
XULTreeAccessible
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
CustomEvent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
BrowserHost
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
nsIDOMXULMultSelectCntrlEl
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIPropertyBag2
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIWebBrowserChrome
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIAppWindow
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
using
namespace
mozilla
:
:
dom
;
NS_IMPL_ISUPPORTS_INHERITED
(
RootAccessible
DocAccessible
nsIDOMEventListener
)
RootAccessible
:
:
RootAccessible
(
Document
*
aDocument
PresShell
*
aPresShell
)
:
DocAccessibleWrap
(
aDocument
aPresShell
)
{
mType
=
eRootType
;
}
RootAccessible
:
:
~
RootAccessible
(
)
{
}
ENameValueFlag
RootAccessible
:
:
Name
(
nsString
&
aName
)
const
{
aName
.
Truncate
(
)
;
if
(
ARIARoleMap
(
)
)
{
LocalAccessible
:
:
Name
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
eNameOK
;
}
mDocumentNode
-
>
GetTitle
(
aName
)
;
return
eNameOK
;
}
uint32_t
RootAccessible
:
:
GetChromeFlags
(
)
const
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
nsCoreUtils
:
:
GetDocShellFor
(
mDocumentNode
)
;
NS_ENSURE_TRUE
(
docShell
0
)
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
docShell
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
NS_ENSURE_TRUE
(
treeOwner
0
)
;
nsCOMPtr
<
nsIAppWindow
>
appWin
(
do_GetInterface
(
treeOwner
)
)
;
if
(
!
appWin
)
{
return
0
;
}
uint32_t
chromeFlags
;
appWin
-
>
GetChromeFlags
(
&
chromeFlags
)
;
return
chromeFlags
;
}
uint64_t
RootAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
DocAccessibleWrap
:
:
NativeState
(
)
;
if
(
state
&
states
:
:
DEFUNCT
)
return
state
;
uint32_t
chromeFlags
=
GetChromeFlags
(
)
;
if
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RESIZE
)
{
state
|
=
states
:
:
SIZEABLE
;
}
if
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_TITLEBAR
)
{
state
|
=
states
:
:
MOVEABLE
;
}
if
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_MODAL
)
state
|
=
states
:
:
MODAL
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
&
&
fm
-
>
GetActiveWindow
(
)
=
=
mDocumentNode
-
>
GetWindow
(
)
)
{
state
|
=
states
:
:
ACTIVE
;
}
return
state
;
}
const
char
*
const
kEventTypes
[
]
=
{
#
ifdef
DEBUG_DRAGDROPSTART
"
mouseover
"
#
endif
"
select
"
"
ValueChange
"
"
AlertActive
"
"
TreeRowCountChanged
"
"
TreeInvalidated
"
"
OpenStateChange
"
"
CheckboxStateChange
"
"
RadioStateChange
"
"
popupshown
"
"
popuphiding
"
"
DOMMenuInactive
"
"
DOMMenuItemActive
"
"
DOMMenuItemInactive
"
"
DOMMenuBarActive
"
"
DOMMenuBarInactive
"
"
scroll
"
"
DOMTitleChanged
"
}
;
nsresult
RootAccessible
:
:
AddEventListeners
(
)
{
nsPIDOMWindowOuter
*
window
=
mDocumentNode
-
>
GetWindow
(
)
;
nsCOMPtr
<
EventTarget
>
nstarget
=
window
?
window
-
>
GetParentTarget
(
)
:
nullptr
;
if
(
nstarget
)
{
for
(
const
char
*
const
*
e
=
kEventTypes
*
const
*
e_end
=
ArrayEnd
(
kEventTypes
)
;
e
<
e_end
;
+
+
e
)
{
nsresult
rv
=
nstarget
-
>
AddEventListener
(
NS_ConvertASCIItoUTF16
(
*
e
)
this
true
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
DocAccessible
:
:
AddEventListeners
(
)
;
}
nsresult
RootAccessible
:
:
RemoveEventListeners
(
)
{
nsPIDOMWindowOuter
*
window
=
mDocumentNode
-
>
GetWindow
(
)
;
nsCOMPtr
<
EventTarget
>
target
=
window
?
window
-
>
GetParentTarget
(
)
:
nullptr
;
if
(
target
)
{
for
(
const
char
*
const
*
e
=
kEventTypes
*
const
*
e_end
=
ArrayEnd
(
kEventTypes
)
;
e
<
e_end
;
+
+
e
)
{
target
-
>
RemoveEventListener
(
NS_ConvertASCIItoUTF16
(
*
e
)
this
true
)
;
}
}
DocAccessible
:
:
RemoveEventListeners
(
)
;
return
NS_OK
;
}
void
RootAccessible
:
:
DocumentActivated
(
DocAccessible
*
aDocument
)
{
}
NS_IMETHODIMP
RootAccessible
:
:
HandleEvent
(
Event
*
aDOMEvent
)
{
MOZ_ASSERT
(
aDOMEvent
)
;
if
(
IsDefunct
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
origTargetNode
=
do_QueryInterface
(
aDOMEvent
-
>
GetOriginalTarget
(
)
)
;
if
(
!
origTargetNode
)
return
NS_OK
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDOMEvents
)
)
{
nsAutoString
eventType
;
aDOMEvent
-
>
GetType
(
eventType
)
;
logging
:
:
DOMEvent
(
"
handled
"
origTargetNode
eventType
)
;
}
#
endif
DocAccessible
*
document
=
GetAccService
(
)
-
>
GetDocAccessible
(
origTargetNode
-
>
OwnerDoc
(
)
)
;
if
(
document
)
{
nsAutoString
eventType
;
aDOMEvent
-
>
GetType
(
eventType
)
;
if
(
eventType
.
EqualsLiteral
(
"
scroll
"
)
)
{
document
-
>
HandleScroll
(
origTargetNode
)
;
}
else
{
document
-
>
HandleNotification
<
RootAccessible
Event
nsINode
>
(
this
&
RootAccessible
:
:
ProcessDOMEvent
aDOMEvent
origTargetNode
)
;
}
}
return
NS_OK
;
}
void
RootAccessible
:
:
ProcessDOMEvent
(
Event
*
aDOMEvent
nsINode
*
aTarget
)
{
MOZ_ASSERT
(
aDOMEvent
)
;
MOZ_ASSERT
(
aTarget
)
;
nsAutoString
eventType
;
aDOMEvent
-
>
GetType
(
eventType
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDOMEvents
)
)
{
logging
:
:
DOMEvent
(
"
processed
"
aTarget
eventType
)
;
}
#
endif
if
(
eventType
.
EqualsLiteral
(
"
popuphiding
"
)
)
{
HandlePopupHidingEvent
(
aTarget
)
;
return
;
}
DocAccessible
*
targetDocument
=
GetAccService
(
)
-
>
GetDocAccessible
(
aTarget
-
>
OwnerDoc
(
)
)
;
if
(
!
targetDocument
)
{
return
;
}
if
(
eventType
.
EqualsLiteral
(
"
popupshown
"
)
&
&
(
aTarget
-
>
IsXULElement
(
nsGkAtoms
:
:
tooltip
)
|
|
aTarget
-
>
IsXULElement
(
nsGkAtoms
:
:
panel
)
)
)
{
targetDocument
-
>
ContentInserted
(
aTarget
-
>
AsContent
(
)
aTarget
-
>
GetNextSibling
(
)
)
;
return
;
}
LocalAccessible
*
accessible
=
targetDocument
-
>
GetAccessibleOrContainer
(
aTarget
)
;
if
(
!
accessible
)
return
;
if
(
accessible
-
>
IsDoc
(
)
&
&
eventType
.
EqualsLiteral
(
"
DOMTitleChanged
"
)
)
{
targetDocument
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
accessible
)
;
return
;
}
XULTreeAccessible
*
treeAcc
=
accessible
-
>
AsXULTree
(
)
;
if
(
treeAcc
)
{
if
(
eventType
.
EqualsLiteral
(
"
TreeRowCountChanged
"
)
)
{
HandleTreeRowCountChangedEvent
(
aDOMEvent
treeAcc
)
;
return
;
}
if
(
eventType
.
EqualsLiteral
(
"
TreeInvalidated
"
)
)
{
HandleTreeInvalidatedEvent
(
aDOMEvent
treeAcc
)
;
return
;
}
}
if
(
eventType
.
EqualsLiteral
(
"
RadioStateChange
"
)
)
{
uint64_t
state
=
accessible
-
>
State
(
)
;
bool
isEnabled
=
(
state
&
(
states
:
:
CHECKED
|
states
:
:
SELECTED
)
)
!
=
0
;
if
(
accessible
-
>
NeedsDOMUIEvent
(
)
)
{
RefPtr
<
AccEvent
>
accEvent
=
new
AccStateChangeEvent
(
accessible
states
:
:
CHECKED
isEnabled
)
;
nsEventShell
:
:
FireEvent
(
accEvent
)
;
}
if
(
isEnabled
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
accessible
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
RadioStateChange
"
accessible
)
;
}
#
endif
}
return
;
}
if
(
eventType
.
EqualsLiteral
(
"
CheckboxStateChange
"
)
)
{
if
(
accessible
-
>
NeedsDOMUIEvent
(
)
)
{
uint64_t
state
=
accessible
-
>
State
(
)
;
bool
isEnabled
=
!
!
(
state
&
states
:
:
CHECKED
)
;
RefPtr
<
AccEvent
>
accEvent
=
new
AccStateChangeEvent
(
accessible
states
:
:
CHECKED
isEnabled
)
;
nsEventShell
:
:
FireEvent
(
accEvent
)
;
}
return
;
}
LocalAccessible
*
treeItemAcc
=
nullptr
;
if
(
treeAcc
)
{
treeItemAcc
=
accessible
-
>
CurrentItem
(
)
;
if
(
treeItemAcc
)
accessible
=
treeItemAcc
;
}
if
(
treeItemAcc
&
&
eventType
.
EqualsLiteral
(
"
OpenStateChange
"
)
)
{
uint64_t
state
=
accessible
-
>
State
(
)
;
bool
isEnabled
=
(
state
&
states
:
:
EXPANDED
)
!
=
0
;
RefPtr
<
AccEvent
>
accEvent
=
new
AccStateChangeEvent
(
accessible
states
:
:
EXPANDED
isEnabled
)
;
nsEventShell
:
:
FireEvent
(
accEvent
)
;
return
;
}
nsINode
*
targetNode
=
accessible
-
>
GetNode
(
)
;
if
(
treeItemAcc
&
&
eventType
.
EqualsLiteral
(
"
select
"
)
)
{
if
(
FocusMgr
(
)
-
>
HasDOMFocus
(
targetNode
)
)
{
nsCOMPtr
<
nsIDOMXULMultiSelectControlElement
>
multiSel
=
targetNode
-
>
AsElement
(
)
-
>
AsXULMultiSelectControl
(
)
;
if
(
!
multiSel
)
{
MOZ_ASSERT_UNREACHABLE
(
"
XUL
tree
doesn
'
t
have
nsIDOMXULMultiSelectControlElement
"
)
;
return
;
}
nsAutoString
selType
;
multiSel
-
>
GetSelType
(
selType
)
;
if
(
selType
.
IsEmpty
(
)
|
|
!
selType
.
EqualsLiteral
(
"
single
"
)
)
{
nsEventShell
:
:
FireEvent
(
nsIAccessibleEvent
:
:
EVENT_SELECTION_WITHIN
accessible
)
;
return
;
}
RefPtr
<
AccSelChangeEvent
>
selChangeEvent
=
new
AccSelChangeEvent
(
treeAcc
treeItemAcc
AccSelChangeEvent
:
:
eSelectionAdd
)
;
nsEventShell
:
:
FireEvent
(
selChangeEvent
)
;
return
;
}
}
else
if
(
eventType
.
EqualsLiteral
(
"
AlertActive
"
)
)
{
nsEventShell
:
:
FireEvent
(
nsIAccessibleEvent
:
:
EVENT_ALERT
accessible
)
;
}
else
if
(
eventType
.
EqualsLiteral
(
"
popupshown
"
)
)
{
HandlePopupShownEvent
(
accessible
)
;
}
else
if
(
eventType
.
EqualsLiteral
(
"
DOMMenuInactive
"
)
)
{
if
(
accessible
-
>
Role
(
)
=
=
roles
:
:
MENUPOPUP
)
{
nsEventShell
:
:
FireEvent
(
nsIAccessibleEvent
:
:
EVENT_MENUPOPUP_END
accessible
)
;
}
}
else
if
(
eventType
.
EqualsLiteral
(
"
DOMMenuItemActive
"
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
ACTIVE
true
)
;
nsEventShell
:
:
FireEvent
(
event
)
;
FocusMgr
(
)
-
>
ActiveItemChanged
(
accessible
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
DOMMenuItemActive
"
accessible
)
;
}
#
endif
}
else
if
(
eventType
.
EqualsLiteral
(
"
DOMMenuItemInactive
"
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
ACTIVE
false
)
;
nsEventShell
:
:
FireEvent
(
event
)
;
LocalAccessible
*
widget
=
accessible
-
>
IsWidget
(
)
?
accessible
:
accessible
-
>
ContainerWidget
(
)
;
if
(
widget
&
&
widget
-
>
IsAutoCompletePopup
(
)
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
nullptr
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
DOMMenuItemInactive
"
accessible
)
;
}
#
endif
}
}
else
if
(
eventType
.
EqualsLiteral
(
"
DOMMenuBarActive
"
)
)
{
nsEventShell
:
:
FireEvent
(
nsIAccessibleEvent
:
:
EVENT_MENU_START
accessible
eFromUserInput
)
;
LocalAccessible
*
activeItem
=
accessible
-
>
CurrentItem
(
)
;
if
(
activeItem
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
activeItem
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
DOMMenuBarActive
"
accessible
)
;
}
#
endif
}
}
else
if
(
eventType
.
EqualsLiteral
(
"
DOMMenuBarInactive
"
)
)
{
nsEventShell
:
:
FireEvent
(
nsIAccessibleEvent
:
:
EVENT_MENU_END
accessible
eFromUserInput
)
;
FocusMgr
(
)
-
>
ActiveItemChanged
(
nullptr
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
DOMMenuBarInactive
"
accessible
)
;
}
#
endif
}
else
if
(
accessible
-
>
NeedsDOMUIEvent
(
)
&
&
eventType
.
EqualsLiteral
(
"
ValueChange
"
)
)
{
uint32_t
event
=
accessible
-
>
HasNumericValue
(
)
?
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
:
nsIAccessibleEvent
:
:
EVENT_TEXT_VALUE_CHANGE
;
targetDocument
-
>
FireDelayedEvent
(
event
accessible
)
;
}
#
ifdef
DEBUG_DRAGDROPSTART
else
if
(
eventType
.
EqualsLiteral
(
"
mouseover
"
)
)
{
nsEventShell
:
:
FireEvent
(
nsIAccessibleEvent
:
:
EVENT_DRAGDROP_START
accessible
)
;
}
#
endif
}
void
RootAccessible
:
:
Shutdown
(
)
{
if
(
HasShutdown
(
)
)
{
return
;
}
DocAccessibleWrap
:
:
Shutdown
(
)
;
}
Relation
RootAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
if
(
!
mDocumentNode
|
|
aType
!
=
RelationType
:
:
EMBEDS
)
{
return
DocAccessibleWrap
:
:
RelationByType
(
aType
)
;
}
if
(
RemoteAccessible
*
remoteDoc
=
GetPrimaryRemoteTopLevelContentDoc
(
)
)
{
return
Relation
(
remoteDoc
)
;
}
if
(
nsIDocShell
*
docShell
=
mDocumentNode
-
>
GetDocShell
(
)
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
owner
;
docShell
-
>
GetTreeOwner
(
getter_AddRefs
(
owner
)
)
;
if
(
owner
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
contentShell
;
owner
-
>
GetPrimaryContentShell
(
getter_AddRefs
(
contentShell
)
)
;
if
(
contentShell
)
{
return
Relation
(
nsAccUtils
:
:
GetDocAccessibleFor
(
contentShell
)
)
;
}
}
}
return
Relation
(
)
;
}
void
RootAccessible
:
:
HandlePopupShownEvent
(
LocalAccessible
*
aAccessible
)
{
roles
:
:
Role
role
=
aAccessible
-
>
Role
(
)
;
if
(
role
=
=
roles
:
:
MENUPOPUP
)
{
nsEventShell
:
:
FireEvent
(
nsIAccessibleEvent
:
:
EVENT_MENUPOPUP_START
aAccessible
)
;
return
;
}
if
(
role
=
=
roles
:
:
COMBOBOX_LIST
)
{
LocalAccessible
*
combobox
=
aAccessible
-
>
LocalParent
(
)
;
if
(
!
combobox
)
return
;
if
(
combobox
-
>
IsCombobox
(
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
combobox
states
:
:
EXPANDED
true
)
;
nsEventShell
:
:
FireEvent
(
event
)
;
}
MOZ_ASSERT
(
aAccessible
-
>
Elm
(
)
)
;
if
(
aAccessible
-
>
Elm
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_activedescendant
)
)
{
LocalAccessible
*
activeDescendant
=
aAccessible
-
>
CurrentItem
(
)
;
if
(
activeDescendant
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
activeDescendant
false
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
ARIA
activedescendant
on
popup
"
activeDescendant
)
;
}
#
endif
}
}
}
}
void
RootAccessible
:
:
HandlePopupHidingEvent
(
nsINode
*
aPopupNode
)
{
DocAccessible
*
document
=
nsAccUtils
:
:
GetDocAccessibleFor
(
aPopupNode
)
;
if
(
!
document
)
return
;
if
(
aPopupNode
-
>
IsXULElement
(
nsGkAtoms
:
:
tooltip
)
|
|
aPopupNode
-
>
IsXULElement
(
nsGkAtoms
:
:
panel
)
)
{
document
-
>
ContentRemoved
(
aPopupNode
-
>
AsContent
(
)
)
;
return
;
}
LocalAccessible
*
popup
=
document
-
>
GetAccessible
(
aPopupNode
)
;
if
(
!
popup
)
{
LocalAccessible
*
popupContainer
=
document
-
>
GetContainerAccessible
(
aPopupNode
)
;
if
(
!
popupContainer
)
return
;
uint32_t
childCount
=
popupContainer
-
>
ChildCount
(
)
;
for
(
uint32_t
idx
=
0
;
idx
<
childCount
;
idx
+
+
)
{
LocalAccessible
*
child
=
popupContainer
-
>
LocalChildAt
(
idx
)
;
if
(
child
-
>
IsAutoCompletePopup
(
)
)
{
popup
=
child
;
break
;
}
}
if
(
!
popup
)
return
;
}
static
const
uint32_t
kNotifyOfFocus
=
1
;
static
const
uint32_t
kNotifyOfState
=
2
;
uint32_t
notifyOf
=
0
;
LocalAccessible
*
widget
=
nullptr
;
if
(
popup
-
>
IsCombobox
(
)
)
{
widget
=
popup
;
}
else
{
widget
=
popup
-
>
ContainerWidget
(
)
;
if
(
!
widget
)
{
if
(
!
popup
-
>
IsMenuPopup
(
)
)
return
;
widget
=
popup
;
}
}
if
(
widget
-
>
IsCombobox
(
)
)
{
if
(
widget
-
>
IsActiveWidget
(
)
)
notifyOf
=
kNotifyOfFocus
;
notifyOf
|
=
kNotifyOfState
;
}
else
if
(
widget
-
>
IsMenuButton
(
)
)
{
notifyOf
|
=
kNotifyOfFocus
;
}
else
if
(
widget
=
=
popup
)
{
notifyOf
=
kNotifyOfFocus
;
}
if
(
notifyOf
&
kNotifyOfFocus
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
nullptr
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
popuphiding
"
popup
)
;
}
#
endif
}
if
(
notifyOf
&
kNotifyOfState
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
widget
states
:
:
EXPANDED
false
)
;
document
-
>
FireDelayedEvent
(
event
)
;
}
}
static
void
GetPropertyBagFromEvent
(
Event
*
aEvent
nsIPropertyBag2
*
*
aPropertyBag
)
{
*
aPropertyBag
=
nullptr
;
CustomEvent
*
customEvent
=
aEvent
-
>
AsCustomEvent
(
)
;
if
(
!
customEvent
)
return
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
customEvent
-
>
GetParentObject
(
)
)
)
return
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
detail
(
cx
)
;
customEvent
-
>
GetDetail
(
cx
&
detail
)
;
if
(
!
detail
.
isObject
(
)
)
return
;
JS
:
:
Rooted
<
JSObject
*
>
detailObj
(
cx
&
detail
.
toObject
(
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIPropertyBag2
>
propBag
;
rv
=
UnwrapArg
<
nsIPropertyBag2
>
(
cx
detailObj
getter_AddRefs
(
propBag
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
propBag
.
forget
(
aPropertyBag
)
;
}
void
RootAccessible
:
:
HandleTreeRowCountChangedEvent
(
Event
*
aEvent
XULTreeAccessible
*
aAccessible
)
{
nsCOMPtr
<
nsIPropertyBag2
>
propBag
;
GetPropertyBagFromEvent
(
aEvent
getter_AddRefs
(
propBag
)
)
;
if
(
!
propBag
)
return
;
nsresult
rv
;
int32_t
index
count
;
rv
=
propBag
-
>
GetPropertyAsInt32
(
u
"
index
"
_ns
&
index
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
rv
=
propBag
-
>
GetPropertyAsInt32
(
u
"
count
"
_ns
&
count
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
aAccessible
-
>
InvalidateCache
(
index
count
)
;
}
void
RootAccessible
:
:
HandleTreeInvalidatedEvent
(
Event
*
aEvent
XULTreeAccessible
*
aAccessible
)
{
nsCOMPtr
<
nsIPropertyBag2
>
propBag
;
GetPropertyBagFromEvent
(
aEvent
getter_AddRefs
(
propBag
)
)
;
if
(
!
propBag
)
return
;
int32_t
startRow
=
0
endRow
=
-
1
startCol
=
0
endCol
=
-
1
;
propBag
-
>
GetPropertyAsInt32
(
u
"
startrow
"
_ns
&
startRow
)
;
propBag
-
>
GetPropertyAsInt32
(
u
"
endrow
"
_ns
&
endRow
)
;
propBag
-
>
GetPropertyAsInt32
(
u
"
startcolumn
"
_ns
&
startCol
)
;
propBag
-
>
GetPropertyAsInt32
(
u
"
endcolumn
"
_ns
&
endCol
)
;
aAccessible
-
>
TreeViewInvalidated
(
startRow
endRow
startCol
endCol
)
;
}
RemoteAccessible
*
RootAccessible
:
:
GetPrimaryRemoteTopLevelContentDoc
(
)
const
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
owner
;
mDocumentNode
-
>
GetDocShell
(
)
-
>
GetTreeOwner
(
getter_AddRefs
(
owner
)
)
;
NS_ENSURE_TRUE
(
owner
nullptr
)
;
nsCOMPtr
<
nsIRemoteTab
>
remoteTab
;
owner
-
>
GetPrimaryRemoteTab
(
getter_AddRefs
(
remoteTab
)
)
;
if
(
!
remoteTab
)
{
return
nullptr
;
}
auto
tab
=
static_cast
<
dom
:
:
BrowserHost
*
>
(
remoteTab
.
get
(
)
)
;
return
tab
-
>
GetTopLevelDocAccessible
(
)
;
}
