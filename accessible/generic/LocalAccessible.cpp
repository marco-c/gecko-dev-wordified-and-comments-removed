#
include
"
AccEvent
.
h
"
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
EmbeddedObjCollector
.
h
"
#
include
"
AccGroupInfo
.
h
"
#
include
"
AccIterator
.
h
"
#
include
"
CachedTableAccessible
.
h
"
#
include
"
CssAltContent
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
mozilla
/
a11y
/
AccAttributes
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessibleChild
.
h
"
#
include
"
mozilla
/
a11y
/
Platform
.
h
"
#
include
"
mozilla
/
FocusModel
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
ApplicationAccessible
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
NotificationController
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
nsTextEquivUtils
.
h
"
#
include
"
EventTree
.
h
"
#
include
"
OuterDocAccessible
.
h
"
#
include
"
Pivot
.
h
"
#
include
"
Relation
.
h
"
#
include
"
mozilla
/
a11y
/
Role
.
h
"
#
include
"
RootAccessible
.
h
"
#
include
"
States
.
h
"
#
include
"
TextLeafRange
.
h
"
#
include
"
TextRange
.
h
"
#
include
"
HTMLElementAccessibles
.
h
"
#
include
"
HTMLSelectAccessible
.
h
"
#
include
"
HTMLTableAccessible
.
h
"
#
include
"
ImageAccessible
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIDOMXULButtonElement
.
h
"
#
include
"
nsIDOMXULSelectCntrlEl
.
h
"
#
include
"
nsIDOMXULSelectCntrlItemEl
.
h
"
#
include
"
nsINodeList
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAnchorElement
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
ScrollContainerFrame
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLLabelElement
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
TreeWalker
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
LocalAccessible
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
LocalAccessible
)
tmp
-
>
Shutdown
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
LocalAccessible
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mContent
mDoc
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
LocalAccessible
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
LocalAccessible
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
LocalAccessible
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
LocalAccessible
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_DESTROY
(
LocalAccessible
LastRelease
(
)
)
LocalAccessible
:
:
LocalAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
mContent
(
aContent
)
mDoc
(
aDoc
)
mParent
(
nullptr
)
mIndexInParent
(
-
1
)
mFirstLineStart
(
-
1
)
mStateFlags
(
0
)
mContextFlags
(
0
)
mReorderEventTarget
(
false
)
mShowEventTarget
(
false
)
mHideEventTarget
(
false
)
mIndexOfEmbeddedChild
(
-
1
)
mGroupInfo
(
nullptr
)
{
}
LocalAccessible
:
:
~
LocalAccessible
(
)
{
NS_ASSERTION
(
!
mDoc
"
LastRelease
was
never
called
!
?
!
"
)
;
}
ENameValueFlag
LocalAccessible
:
:
Name
(
nsString
&
aName
)
const
{
aName
.
Truncate
(
)
;
if
(
!
HasOwnContent
(
)
)
return
eNameOK
;
ARIAName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
eNameOK
;
ENameValueFlag
nameFlag
=
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
if
(
mContent
-
>
IsHTMLElement
(
)
)
{
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
title
aName
)
)
{
aName
.
CompressWhitespace
(
)
;
return
eNameFromTooltip
;
}
}
else
if
(
mContent
-
>
IsXULElement
(
)
)
{
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
tooltiptext
aName
)
)
{
aName
.
CompressWhitespace
(
)
;
return
eNameFromTooltip
;
}
}
else
if
(
mContent
-
>
IsSVGElement
(
)
)
{
for
(
nsIContent
*
childElm
=
mContent
-
>
GetFirstChild
(
)
;
childElm
;
childElm
=
childElm
-
>
GetNextSibling
(
)
)
{
if
(
childElm
-
>
IsSVGElement
(
nsGkAtoms
:
:
desc
)
)
{
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
this
childElm
&
aName
)
;
return
eNameFromTooltip
;
}
}
}
if
(
auto
cssAlt
=
CssAltContent
(
mContent
)
)
{
cssAlt
.
AppendToString
(
aName
)
;
return
eNameOK
;
}
aName
.
SetIsVoid
(
true
)
;
return
nameFlag
;
}
void
LocalAccessible
:
:
Description
(
nsString
&
aDescription
)
const
{
if
(
!
HasOwnContent
(
)
|
|
mContent
-
>
IsText
(
)
)
return
;
ARIADescription
(
aDescription
)
;
if
(
aDescription
.
IsEmpty
(
)
)
{
NativeDescription
(
aDescription
)
;
if
(
aDescription
.
IsEmpty
(
)
)
{
if
(
mContent
-
>
IsHTMLElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
title
aDescription
)
;
}
else
if
(
mContent
-
>
IsXULElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
tooltiptext
aDescription
)
;
}
else
if
(
mContent
-
>
IsSVGElement
(
)
)
{
for
(
nsIContent
*
childElm
=
mContent
-
>
GetFirstChild
(
)
;
childElm
;
childElm
=
childElm
-
>
GetNextSibling
(
)
)
{
if
(
childElm
-
>
IsSVGElement
(
nsGkAtoms
:
:
desc
)
)
{
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
this
childElm
&
aDescription
)
;
break
;
}
}
}
}
}
if
(
!
aDescription
.
IsEmpty
(
)
)
{
aDescription
.
CompressWhitespace
(
)
;
nsAutoString
name
;
Name
(
name
)
;
if
(
aDescription
.
Equals
(
name
)
)
aDescription
.
Truncate
(
)
;
}
}
KeyBinding
LocalAccessible
:
:
AccessKey
(
)
const
{
if
(
!
HasOwnContent
(
)
)
return
KeyBinding
(
)
;
uint32_t
key
=
nsCoreUtils
:
:
GetAccessKeyFor
(
mContent
)
;
if
(
!
key
&
&
mContent
-
>
IsElement
(
)
)
{
LocalAccessible
*
label
=
nullptr
;
if
(
mContent
-
>
IsHTMLElement
(
)
)
{
HTMLLabelIterator
iter
(
Document
(
)
this
HTMLLabelIterator
:
:
eSkipAncestorLabel
)
;
label
=
iter
.
Next
(
)
;
}
if
(
!
label
)
{
XULLabelIterator
iter
(
Document
(
)
mContent
)
;
label
=
iter
.
Next
(
)
;
}
if
(
label
)
key
=
nsCoreUtils
:
:
GetAccessKeyFor
(
label
-
>
GetContent
(
)
)
;
}
if
(
!
key
)
return
KeyBinding
(
)
;
switch
(
StaticPrefs
:
:
ui_key_generalAccessKey
(
)
)
{
case
-
1
:
break
;
case
dom
:
:
KeyboardEvent_Binding
:
:
DOM_VK_SHIFT
:
return
KeyBinding
(
key
KeyBinding
:
:
kShift
)
;
case
dom
:
:
KeyboardEvent_Binding
:
:
DOM_VK_CONTROL
:
return
KeyBinding
(
key
KeyBinding
:
:
kControl
)
;
case
dom
:
:
KeyboardEvent_Binding
:
:
DOM_VK_ALT
:
return
KeyBinding
(
key
KeyBinding
:
:
kAlt
)
;
case
dom
:
:
KeyboardEvent_Binding
:
:
DOM_VK_META
:
return
KeyBinding
(
key
KeyBinding
:
:
kMeta
)
;
default
:
return
KeyBinding
(
)
;
}
dom
:
:
Document
*
document
=
mContent
-
>
GetComposedDoc
(
)
;
if
(
!
document
)
return
KeyBinding
(
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
(
document
-
>
GetDocShell
(
)
)
;
if
(
!
treeItem
)
return
KeyBinding
(
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
int32_t
modifierMask
=
0
;
switch
(
treeItem
-
>
ItemType
(
)
)
{
case
nsIDocShellTreeItem
:
:
typeChrome
:
modifierMask
=
StaticPrefs
:
:
ui_key_chromeAccess
(
)
;
rv
=
NS_OK
;
break
;
case
nsIDocShellTreeItem
:
:
typeContent
:
modifierMask
=
StaticPrefs
:
:
ui_key_contentAccess
(
)
;
rv
=
NS_OK
;
break
;
}
return
NS_SUCCEEDED
(
rv
)
?
KeyBinding
(
key
modifierMask
)
:
KeyBinding
(
)
;
}
KeyBinding
LocalAccessible
:
:
KeyboardShortcut
(
)
const
{
return
KeyBinding
(
)
;
}
uint64_t
LocalAccessible
:
:
VisibilityState
(
)
const
{
if
(
IPCAccessibilityActive
(
)
)
{
return
0
;
}
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
!
frame
)
{
if
(
nsCoreUtils
:
:
IsDisplayContents
(
mContent
)
)
{
return
states
:
:
OFFSCREEN
;
}
return
states
:
:
INVISIBLE
;
}
if
(
!
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
return
states
:
:
INVISIBLE
;
if
(
frame
-
>
PresShell
(
)
-
>
IsUnderHiddenEmbedderElement
(
)
)
{
return
states
:
:
INVISIBLE
;
}
if
(
Document
(
)
-
>
IsHidden
(
)
)
return
states
:
:
OFFSCREEN
;
nsIFrame
*
curFrame
=
frame
;
do
{
nsView
*
view
=
curFrame
-
>
GetView
(
)
;
if
(
view
&
&
view
-
>
GetVisibility
(
)
=
=
ViewVisibility
:
:
Hide
)
{
return
states
:
:
INVISIBLE
;
}
if
(
nsLayoutUtils
:
:
IsPopup
(
curFrame
)
)
{
return
0
;
}
if
(
curFrame
-
>
StyleUIReset
(
)
-
>
mMozSubtreeHiddenOnlyVisually
)
{
return
states
:
:
OFFSCREEN
;
}
nsIFrame
*
parentFrame
=
curFrame
-
>
GetParent
(
)
;
const
nscoord
kMinPixels
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
12
)
;
if
(
ScrollContainerFrame
*
scrollContainerFrame
=
do_QueryFrame
(
parentFrame
)
)
{
nsRect
scrollPortRect
=
scrollContainerFrame
-
>
GetScrollPortRect
(
)
;
nsRect
frameRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
frame
frame
-
>
GetRectRelativeToSelf
(
)
parentFrame
)
;
if
(
!
scrollPortRect
.
Contains
(
frameRect
)
)
{
scrollPortRect
.
Deflate
(
kMinPixels
kMinPixels
)
;
if
(
!
scrollPortRect
.
Intersects
(
frameRect
)
)
return
states
:
:
OFFSCREEN
;
}
}
if
(
!
parentFrame
)
{
parentFrame
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
curFrame
)
;
if
(
!
parentFrame
&
&
nsLayoutUtils
:
:
FrameIsMostlyScrolledOutOfViewInCrossProcess
(
frame
kMinPixels
)
)
{
return
states
:
:
OFFSCREEN
;
}
}
curFrame
=
parentFrame
;
}
while
(
curFrame
)
;
if
(
frame
-
>
IsTextFrame
(
)
&
&
!
frame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
&
&
frame
-
>
GetRect
(
)
.
IsEmpty
(
)
)
{
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
0
UINT32_MAX
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInContentText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
if
(
text
.
mString
.
IsEmpty
(
)
)
{
return
states
:
:
INVISIBLE
;
}
}
return
0
;
}
uint64_t
LocalAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
0
;
if
(
!
IsInDocument
(
)
)
state
|
=
states
:
:
STALE
;
if
(
HasOwnContent
(
)
&
&
mContent
-
>
IsElement
(
)
)
{
dom
:
:
ElementState
elementState
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
elementState
.
HasState
(
dom
:
:
ElementState
:
:
INVALID
)
)
{
state
|
=
states
:
:
INVALID
;
}
if
(
elementState
.
HasState
(
dom
:
:
ElementState
:
:
REQUIRED
)
)
{
state
|
=
states
:
:
REQUIRED
;
}
state
|
=
NativeInteractiveState
(
)
;
}
state
|
=
VisibilityState
(
)
;
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
frame
&
&
frame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
state
|
=
states
:
:
FLOATING
;
}
if
(
HasOwnContent
(
)
&
&
mContent
-
>
IsXULElement
(
)
&
&
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
popup
)
)
{
state
|
=
states
:
:
HASPOPUP
;
}
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
if
(
!
roleMapEntry
|
|
roleMapEntry
-
>
roleRule
=
=
kUseNativeRole
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
LINK
)
{
state
|
=
NativeLinkState
(
)
;
}
return
state
;
}
uint64_t
LocalAccessible
:
:
NativeInteractiveState
(
)
const
{
if
(
!
mContent
-
>
IsElement
(
)
)
return
0
;
if
(
NativelyUnavailable
(
)
)
return
states
:
:
UNAVAILABLE
;
nsIFrame
*
frame
=
GetFrame
(
)
;
auto
flags
=
IsFocusableFlags
(
0
)
;
if
(
mDoc
-
>
IPCDoc
(
)
)
{
flags
|
=
IsFocusableFlags
:
:
IgnoreVisibility
;
}
if
(
frame
&
&
frame
-
>
IsFocusable
(
flags
)
)
{
return
states
:
:
FOCUSABLE
;
}
return
0
;
}
uint64_t
LocalAccessible
:
:
NativeLinkState
(
)
const
{
return
0
;
}
bool
LocalAccessible
:
:
NativelyUnavailable
(
)
const
{
if
(
mContent
-
>
IsHTMLElement
(
)
)
return
mContent
-
>
AsElement
(
)
-
>
IsDisabled
(
)
;
return
mContent
-
>
IsElement
(
)
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
Accessible
*
LocalAccessible
:
:
ChildAtPoint
(
int32_t
aX
int32_t
aY
EWhichChildAtPoint
aWhichChild
)
{
Accessible
*
child
=
LocalChildAtPoint
(
aX
aY
aWhichChild
)
;
if
(
aWhichChild
!
=
EWhichChildAtPoint
:
:
DirectChild
&
&
child
&
&
child
-
>
IsOuterDoc
(
)
)
{
child
=
child
-
>
ChildAtPoint
(
aX
aY
aWhichChild
)
;
}
return
child
;
}
LocalAccessible
*
LocalAccessible
:
:
LocalChildAtPoint
(
int32_t
aX
int32_t
aY
EWhichChildAtPoint
aWhichChild
)
{
LocalAccessible
*
fallbackAnswer
=
nullptr
;
LayoutDeviceIntRect
rect
=
Bounds
(
)
;
if
(
rect
.
Contains
(
aX
aY
)
)
fallbackAnswer
=
this
;
if
(
nsAccUtils
:
:
MustPrune
(
this
)
)
{
return
fallbackAnswer
;
}
DocAccessible
*
accDocument
=
Document
(
)
;
NS_ENSURE_TRUE
(
accDocument
nullptr
)
;
nsIFrame
*
rootFrame
=
accDocument
-
>
GetFrame
(
)
;
NS_ENSURE_TRUE
(
rootFrame
nullptr
)
;
nsIFrame
*
startFrame
=
rootFrame
;
nsIWidget
*
rootWidget
=
rootFrame
-
>
GetView
(
)
-
>
GetNearestWidget
(
nullptr
)
;
NS_ENSURE_TRUE
(
rootWidget
nullptr
)
;
LayoutDeviceIntRect
rootRect
=
rootWidget
-
>
GetScreenBounds
(
)
;
auto
point
=
LayoutDeviceIntPoint
(
aX
-
rootRect
.
X
(
)
aY
-
rootRect
.
Y
(
)
)
;
nsIFrame
*
popupFrame
=
nsLayoutUtils
:
:
GetPopupFrameForPoint
(
accDocument
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
rootWidget
point
)
;
if
(
popupFrame
)
{
DocAccessible
*
popupDoc
=
GetAccService
(
)
-
>
GetDocAccessible
(
popupFrame
-
>
GetContent
(
)
-
>
OwnerDoc
(
)
)
;
LocalAccessible
*
popupAcc
=
popupDoc
-
>
GetAccessibleOrContainer
(
popupFrame
-
>
GetContent
(
)
)
;
LocalAccessible
*
popupChild
=
this
;
while
(
popupChild
&
&
!
popupChild
-
>
IsDoc
(
)
&
&
popupChild
!
=
popupAcc
)
{
popupChild
=
popupChild
-
>
LocalParent
(
)
;
}
if
(
popupChild
=
=
popupAcc
)
startFrame
=
popupFrame
;
}
nsPresContext
*
presContext
=
startFrame
-
>
PresContext
(
)
;
nsRect
screenRect
=
startFrame
-
>
GetScreenRectInAppUnits
(
)
;
nsPoint
offset
(
presContext
-
>
DevPixelsToAppUnits
(
aX
)
-
screenRect
.
X
(
)
presContext
-
>
DevPixelsToAppUnits
(
aY
)
-
screenRect
.
Y
(
)
)
;
nsIFrame
*
foundFrame
=
nsLayoutUtils
:
:
GetFrameForPoint
(
RelativeTo
{
startFrame
ViewportType
:
:
Visual
}
offset
)
;
nsIContent
*
content
=
nullptr
;
if
(
!
foundFrame
|
|
!
(
content
=
foundFrame
-
>
GetContent
(
)
)
)
{
return
fallbackAnswer
;
}
DocAccessible
*
contentDocAcc
=
GetAccService
(
)
-
>
GetDocAccessible
(
content
-
>
OwnerDoc
(
)
)
;
NS_ASSERTION
(
contentDocAcc
"
could
not
get
the
document
accessible
"
)
;
if
(
!
contentDocAcc
)
return
fallbackAnswer
;
LocalAccessible
*
accessible
=
contentDocAcc
-
>
GetAccessibleOrContainer
(
content
)
;
if
(
!
accessible
)
return
fallbackAnswer
;
LocalAccessible
*
child
=
accessible
;
while
(
child
!
=
this
)
{
LocalAccessible
*
parent
=
child
-
>
LocalParent
(
)
;
if
(
!
parent
)
{
return
fallbackAnswer
;
}
if
(
parent
=
=
this
&
&
aWhichChild
=
=
EWhichChildAtPoint
:
:
DirectChild
)
{
return
child
;
}
child
=
parent
;
}
uint32_t
childCount
=
accessible
-
>
ChildCount
(
)
;
if
(
childCount
=
=
1
&
&
accessible
-
>
IsOuterDoc
(
)
&
&
accessible
-
>
FirstChild
(
)
-
>
IsRemote
(
)
)
{
return
accessible
;
}
for
(
uint32_t
childIdx
=
0
;
childIdx
<
childCount
;
childIdx
+
+
)
{
LocalAccessible
*
child
=
accessible
-
>
LocalChildAt
(
childIdx
)
;
LayoutDeviceIntRect
childRect
=
child
-
>
Bounds
(
)
;
if
(
childRect
.
Contains
(
aX
aY
)
&
&
(
child
-
>
State
(
)
&
states
:
:
INVISIBLE
)
=
=
0
)
{
if
(
aWhichChild
=
=
EWhichChildAtPoint
:
:
DeepestChild
)
{
return
child
-
>
LocalChildAtPoint
(
aX
aY
EWhichChildAtPoint
:
:
DeepestChild
)
;
}
return
child
;
}
}
return
accessible
;
}
nsIFrame
*
LocalAccessible
:
:
FindNearestAccessibleAncestorFrame
(
)
{
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
frame
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Fixed
&
&
nsLayoutUtils
:
:
IsReallyFixedPos
(
frame
)
)
{
return
mDoc
-
>
PresShellPtr
(
)
-
>
GetRootFrame
(
)
;
}
if
(
IsDoc
(
)
)
{
MOZ_ASSERT
(
frame
"
DocAccessibles
should
always
have
a
frame
"
)
;
return
frame
;
}
LocalAccessible
*
ancestor
=
mParent
;
while
(
ancestor
)
{
if
(
nsIFrame
*
boundingFrame
=
ancestor
-
>
GetFrame
(
)
)
{
return
boundingFrame
;
}
ancestor
=
ancestor
-
>
LocalParent
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
No
ancestor
with
frame
?
"
)
;
return
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
frame
)
;
}
nsRect
LocalAccessible
:
:
ParentRelativeBounds
(
)
{
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
frame
&
&
mContent
)
{
nsIFrame
*
boundingFrame
=
FindNearestAccessibleAncestorFrame
(
)
;
nsRect
result
=
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
frame
boundingFrame
)
;
if
(
result
.
IsEmpty
(
)
)
{
result
=
frame
-
>
InkOverflowRectRelativeToSelf
(
)
;
result
.
MoveBy
(
frame
-
>
GetOffsetTo
(
boundingFrame
)
)
;
}
if
(
boundingFrame
-
>
GetRect
(
)
.
IsEmpty
(
)
|
|
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
boundingFrame
)
)
{
nsRect
boundingUnion
=
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
boundingFrame
boundingFrame
)
;
if
(
!
boundingUnion
.
IsEmpty
(
)
)
{
result
.
MoveBy
(
-
boundingUnion
.
TopLeft
(
)
)
;
}
else
{
nsRect
boundingOverflow
=
boundingFrame
-
>
InkOverflowRectRelativeToSelf
(
)
;
result
.
MoveBy
(
-
boundingOverflow
.
TopLeft
(
)
)
;
}
}
if
(
frame
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Fixed
&
&
nsLayoutUtils
:
:
IsReallyFixedPos
(
frame
)
)
{
return
result
;
}
if
(
ScrollContainerFrame
*
sf
=
mParent
=
=
mDoc
?
mDoc
-
>
PresShellPtr
(
)
-
>
GetRootScrollContainerFrame
(
)
:
boundingFrame
-
>
GetScrollTargetFrame
(
)
)
{
nsPoint
scrollPos
=
sf
-
>
GetScrollPosition
(
)
.
ApplyResolution
(
mDoc
-
>
PresShellPtr
(
)
-
>
GetResolution
(
)
)
;
result
.
MoveBy
(
scrollPos
.
x
scrollPos
.
y
)
;
}
return
result
;
}
return
nsRect
(
)
;
}
nsRect
LocalAccessible
:
:
RelativeBounds
(
nsIFrame
*
*
aBoundingFrame
)
const
{
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
frame
&
&
mContent
)
{
*
aBoundingFrame
=
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
frame
)
;
nsRect
unionRect
=
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
frame
*
aBoundingFrame
nsLayoutUtils
:
:
GetAllInFlowRectsFlag
:
:
AccountForTransforms
)
;
if
(
unionRect
.
IsEmpty
(
)
)
{
nsRect
overflow
=
frame
-
>
InkOverflowRectRelativeToSelf
(
)
;
nsLayoutUtils
:
:
TransformRect
(
frame
*
aBoundingFrame
overflow
)
;
return
overflow
;
}
return
unionRect
;
}
return
nsRect
(
)
;
}
nsRect
LocalAccessible
:
:
BoundsInAppUnits
(
)
const
{
nsIFrame
*
boundingFrame
=
nullptr
;
nsRect
unionRectTwips
=
RelativeBounds
(
&
boundingFrame
)
;
if
(
!
boundingFrame
)
{
return
nsRect
(
)
;
}
PresShell
*
presShell
=
mDoc
-
>
PresContext
(
)
-
>
PresShell
(
)
;
nsPoint
viewportOffset
=
presShell
-
>
GetVisualViewportOffset
(
)
-
presShell
-
>
GetLayoutViewportOffset
(
)
;
unionRectTwips
.
MoveBy
(
-
viewportOffset
)
;
unionRectTwips
.
ScaleRoundOut
(
presShell
-
>
GetResolution
(
)
)
;
nsRect
orgRectPixels
=
boundingFrame
-
>
GetScreenRectInAppUnits
(
)
;
unionRectTwips
.
MoveBy
(
orgRectPixels
.
X
(
)
orgRectPixels
.
Y
(
)
)
;
return
unionRectTwips
;
}
LayoutDeviceIntRect
LocalAccessible
:
:
Bounds
(
)
const
{
return
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
BoundsInAppUnits
(
)
mDoc
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
void
LocalAccessible
:
:
SetSelected
(
bool
aSelect
)
{
if
(
!
HasOwnContent
(
)
)
return
;
if
(
nsAccUtils
:
:
GetSelectableContainer
(
this
State
(
)
)
&
&
aSelect
)
{
TakeFocus
(
)
;
}
}
void
LocalAccessible
:
:
TakeSelection
(
)
{
LocalAccessible
*
select
=
nsAccUtils
:
:
GetSelectableContainer
(
this
State
(
)
)
;
if
(
select
)
{
if
(
select
-
>
State
(
)
&
states
:
:
MULTISELECTABLE
)
select
-
>
UnselectAll
(
)
;
SetSelected
(
true
)
;
}
}
void
LocalAccessible
:
:
TakeFocus
(
)
const
{
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
!
frame
)
return
;
nsIContent
*
focusContent
=
mContent
;
if
(
!
frame
-
>
IsFocusable
(
)
)
{
LocalAccessible
*
widget
=
ContainerWidget
(
)
;
if
(
widget
&
&
widget
-
>
AreItemsOperable
(
)
)
{
nsIContent
*
widgetElm
=
widget
-
>
GetContent
(
)
;
nsIFrame
*
widgetFrame
=
widgetElm
-
>
GetPrimaryFrame
(
)
;
if
(
widgetFrame
&
&
widgetFrame
-
>
IsFocusable
(
)
)
{
focusContent
=
widgetElm
;
widget
-
>
SetCurrentItem
(
this
)
;
}
}
}
if
(
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
dom
:
:
AutoHandlingUserInputStatePusher
inputStatePusher
(
true
)
;
RefPtr
<
dom
:
:
Element
>
element
=
dom
:
:
Element
:
:
FromNodeOrNull
(
focusContent
)
;
fm
-
>
SetFocus
(
element
0
)
;
}
}
void
LocalAccessible
:
:
NameFromAssociatedXULLabel
(
DocAccessible
*
aDocument
nsIContent
*
aElm
nsString
&
aName
)
{
LocalAccessible
*
label
=
nullptr
;
XULLabelIterator
iter
(
aDocument
aElm
)
;
while
(
(
label
=
iter
.
Next
(
)
)
)
{
label
-
>
Elm
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
value
aName
)
;
if
(
aName
.
IsEmpty
(
)
)
{
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
label
label
-
>
Elm
(
)
&
aName
)
;
}
}
aName
.
CompressWhitespace
(
)
;
}
void
LocalAccessible
:
:
XULElmName
(
DocAccessible
*
aDocument
nsIContent
*
aElm
nsString
&
aName
)
{
nsCOMPtr
<
nsIDOMXULSelectControlElement
>
select
=
aElm
-
>
AsElement
(
)
-
>
AsXULSelectControl
(
)
;
if
(
!
select
)
{
aElm
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
label
aName
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
NameFromAssociatedXULLabel
(
aDocument
aElm
aName
)
;
}
aName
.
CompressWhitespace
(
)
;
}
nsresult
LocalAccessible
:
:
HandleAccEvent
(
AccEvent
*
aEvent
)
{
NS_ENSURE_ARG_POINTER
(
aEvent
)
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
nsAutoCString
strEventType
;
GetAccService
(
)
-
>
GetStringEventType
(
aEvent
-
>
GetEventType
(
)
strEventType
)
;
nsAutoCString
strMarker
;
strMarker
.
AppendLiteral
(
"
A11y
Event
-
"
)
;
strMarker
.
Append
(
strEventType
)
;
PROFILER_MARKER_UNTYPED
(
strMarker
A11Y
)
;
}
if
(
IPCAccessibilityActive
(
)
&
&
Document
(
)
)
{
DocAccessibleChild
*
ipcDoc
=
mDoc
-
>
IPCDoc
(
)
;
MOZ_ASSERT
(
ipcDoc
)
;
if
(
ipcDoc
)
{
uint64_t
id
=
aEvent
-
>
GetAccessible
(
)
-
>
ID
(
)
;
switch
(
aEvent
-
>
GetEventType
(
)
)
{
case
nsIAccessibleEvent
:
:
EVENT_SHOW
:
ipcDoc
-
>
ShowEvent
(
downcast_accEvent
(
aEvent
)
)
;
break
;
case
nsIAccessibleEvent
:
:
EVENT_HIDE
:
ipcDoc
-
>
SendHideEvent
(
id
aEvent
-
>
IsFromUserInput
(
)
)
;
break
;
case
nsIAccessibleEvent
:
:
EVENT_INNER_REORDER
:
case
nsIAccessibleEvent
:
:
EVENT_REORDER
:
if
(
IsTable
(
)
)
{
SendCache
(
CacheDomain
:
:
Table
CacheUpdateType
:
:
Update
)
;
}
#
if
defined
(
XP_WIN
)
if
(
HasOwnContent
(
)
&
&
mContent
-
>
IsMathMLElement
(
)
)
{
for
(
LocalAccessible
*
acc
=
this
;
acc
;
acc
=
acc
-
>
LocalParent
(
)
)
{
if
(
acc
-
>
HasOwnContent
(
)
&
&
acc
-
>
mContent
-
>
IsMathMLElement
(
nsGkAtoms
:
:
math
)
)
{
mDoc
-
>
QueueCacheUpdate
(
acc
CacheDomain
:
:
InnerHTML
)
;
}
}
}
#
endif
if
(
!
aEvent
-
>
GetAccessible
(
)
-
>
IsApplication
(
)
)
{
ipcDoc
-
>
SendEvent
(
id
aEvent
-
>
GetEventType
(
)
)
;
}
break
;
case
nsIAccessibleEvent
:
:
EVENT_STATE_CHANGE
:
{
AccStateChangeEvent
*
event
=
downcast_accEvent
(
aEvent
)
;
ipcDoc
-
>
SendStateChangeEvent
(
id
event
-
>
GetState
(
)
event
-
>
IsStateEnabled
(
)
)
;
break
;
}
case
nsIAccessibleEvent
:
:
EVENT_TEXT_CARET_MOVED
:
{
AccCaretMoveEvent
*
event
=
downcast_accEvent
(
aEvent
)
;
ipcDoc
-
>
SendCaretMoveEvent
(
id
event
-
>
GetCaretOffset
(
)
event
-
>
IsSelectionCollapsed
(
)
event
-
>
IsAtEndOfLine
(
)
event
-
>
GetGranularity
(
)
event
-
>
IsFromUserInput
(
)
)
;
break
;
}
case
nsIAccessibleEvent
:
:
EVENT_TEXT_INSERTED
:
case
nsIAccessibleEvent
:
:
EVENT_TEXT_REMOVED
:
{
AccTextChangeEvent
*
event
=
downcast_accEvent
(
aEvent
)
;
const
nsString
&
text
=
event
-
>
ModifiedText
(
)
;
ipcDoc
-
>
SendTextChangeEvent
(
id
text
event
-
>
GetStartOffset
(
)
event
-
>
GetLength
(
)
event
-
>
IsTextInserted
(
)
event
-
>
IsFromUserInput
(
)
)
;
break
;
}
case
nsIAccessibleEvent
:
:
EVENT_SELECTION
:
case
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
:
case
nsIAccessibleEvent
:
:
EVENT_SELECTION_REMOVE
:
{
AccSelChangeEvent
*
selEvent
=
downcast_accEvent
(
aEvent
)
;
ipcDoc
-
>
SendSelectionEvent
(
id
selEvent
-
>
Widget
(
)
-
>
ID
(
)
aEvent
-
>
GetEventType
(
)
)
;
break
;
}
case
nsIAccessibleEvent
:
:
EVENT_FOCUS
:
ipcDoc
-
>
SendFocusEvent
(
id
)
;
break
;
case
nsIAccessibleEvent
:
:
EVENT_SCROLLING_END
:
case
nsIAccessibleEvent
:
:
EVENT_SCROLLING
:
{
AccScrollingEvent
*
scrollingEvent
=
downcast_accEvent
(
aEvent
)
;
ipcDoc
-
>
SendScrollingEvent
(
id
aEvent
-
>
GetEventType
(
)
scrollingEvent
-
>
ScrollX
(
)
scrollingEvent
-
>
ScrollY
(
)
scrollingEvent
-
>
MaxScrollX
(
)
scrollingEvent
-
>
MaxScrollY
(
)
)
;
break
;
}
#
if
!
defined
(
XP_WIN
)
case
nsIAccessibleEvent
:
:
EVENT_ANNOUNCEMENT
:
{
AccAnnouncementEvent
*
announcementEvent
=
downcast_accEvent
(
aEvent
)
;
ipcDoc
-
>
SendAnnouncementEvent
(
id
announcementEvent
-
>
Announcement
(
)
announcementEvent
-
>
Priority
(
)
)
;
break
;
}
#
endif
case
nsIAccessibleEvent
:
:
EVENT_TEXT_SELECTION_CHANGED
:
{
AccTextSelChangeEvent
*
textSelChangeEvent
=
downcast_accEvent
(
aEvent
)
;
AutoTArray
<
TextRange
1
>
ranges
;
textSelChangeEvent
-
>
SelectionRanges
(
&
ranges
)
;
nsTArray
<
TextRangeData
>
textRangeData
(
ranges
.
Length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
ranges
.
Length
(
)
;
i
+
+
)
{
const
TextRange
&
range
=
ranges
.
ElementAt
(
i
)
;
LocalAccessible
*
start
=
range
.
StartContainer
(
)
-
>
AsLocal
(
)
;
LocalAccessible
*
end
=
range
.
EndContainer
(
)
-
>
AsLocal
(
)
;
textRangeData
.
AppendElement
(
TextRangeData
(
start
-
>
ID
(
)
end
-
>
ID
(
)
range
.
StartOffset
(
)
range
.
EndOffset
(
)
)
)
;
}
ipcDoc
-
>
SendTextSelectionChangeEvent
(
id
textRangeData
)
;
break
;
}
case
nsIAccessibleEvent
:
:
EVENT_DESCRIPTION_CHANGE
:
case
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
:
{
SendCache
(
CacheDomain
:
:
NameAndDescription
CacheUpdateType
:
:
Update
)
;
ipcDoc
-
>
SendEvent
(
id
aEvent
-
>
GetEventType
(
)
)
;
break
;
}
case
nsIAccessibleEvent
:
:
EVENT_TEXT_VALUE_CHANGE
:
case
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
:
{
SendCache
(
CacheDomain
:
:
Value
CacheUpdateType
:
:
Update
)
;
ipcDoc
-
>
SendEvent
(
id
aEvent
-
>
GetEventType
(
)
)
;
break
;
}
default
:
ipcDoc
-
>
SendEvent
(
id
aEvent
-
>
GetEventType
(
)
)
;
}
}
}
if
(
nsCoreUtils
:
:
AccEventObserversExist
(
)
)
{
nsCoreUtils
:
:
DispatchAccEvent
(
MakeXPCEvent
(
aEvent
)
)
;
}
if
(
IPCAccessibilityActive
(
)
)
{
return
NS_OK
;
}
if
(
IsDefunct
(
)
)
{
return
NS_OK
;
}
LocalAccessible
*
target
=
aEvent
-
>
GetAccessible
(
)
;
switch
(
aEvent
-
>
GetEventType
(
)
)
{
case
nsIAccessibleEvent
:
:
EVENT_SHOW
:
PlatformShowHideEvent
(
target
target
-
>
LocalParent
(
)
true
aEvent
-
>
IsFromUserInput
(
)
)
;
break
;
case
nsIAccessibleEvent
:
:
EVENT_HIDE
:
PlatformShowHideEvent
(
target
target
-
>
LocalParent
(
)
false
aEvent
-
>
IsFromUserInput
(
)
)
;
break
;
case
nsIAccessibleEvent
:
:
EVENT_STATE_CHANGE
:
{
AccStateChangeEvent
*
event
=
downcast_accEvent
(
aEvent
)
;
PlatformStateChangeEvent
(
target
event
-
>
GetState
(
)
event
-
>
IsStateEnabled
(
)
)
;
break
;
}
case
nsIAccessibleEvent
:
:
EVENT_TEXT_CARET_MOVED
:
{
AccCaretMoveEvent
*
event
=
downcast_accEvent
(
aEvent
)
;
LayoutDeviceIntRect
rect
;
PlatformCaretMoveEvent
(
target
event
-
>
GetCaretOffset
(
)
event
-
>
IsSelectionCollapsed
(
)
event
-
>
GetGranularity
(
)
rect
event
-
>
IsFromUserInput
(
)
)
;
break
;
}
case
nsIAccessibleEvent
:
:
EVENT_TEXT_INSERTED
:
case
nsIAccessibleEvent
:
:
EVENT_TEXT_REMOVED
:
{
AccTextChangeEvent
*
event
=
downcast_accEvent
(
aEvent
)
;
const
nsString
&
text
=
event
-
>
ModifiedText
(
)
;
PlatformTextChangeEvent
(
target
text
event
-
>
GetStartOffset
(
)
event
-
>
GetLength
(
)
event
-
>
IsTextInserted
(
)
event
-
>
IsFromUserInput
(
)
)
;
break
;
}
case
nsIAccessibleEvent
:
:
EVENT_SELECTION
:
case
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
:
case
nsIAccessibleEvent
:
:
EVENT_SELECTION_REMOVE
:
{
AccSelChangeEvent
*
selEvent
=
downcast_accEvent
(
aEvent
)
;
PlatformSelectionEvent
(
target
selEvent
-
>
Widget
(
)
aEvent
-
>
GetEventType
(
)
)
;
break
;
}
case
nsIAccessibleEvent
:
:
EVENT_FOCUS
:
{
LayoutDeviceIntRect
rect
;
#
ifdef
XP_WIN
if
(
HyperTextAccessible
*
text
=
target
-
>
AsHyperText
(
)
)
{
nsIWidget
*
widget
=
nullptr
;
rect
=
text
-
>
GetCaretRect
(
&
widget
)
;
}
#
endif
PlatformFocusEvent
(
target
rect
)
;
break
;
}
#
if
defined
(
ANDROID
)
case
nsIAccessibleEvent
:
:
EVENT_SCROLLING_END
:
case
nsIAccessibleEvent
:
:
EVENT_SCROLLING
:
{
AccScrollingEvent
*
scrollingEvent
=
downcast_accEvent
(
aEvent
)
;
PlatformScrollingEvent
(
target
aEvent
-
>
GetEventType
(
)
scrollingEvent
-
>
ScrollX
(
)
scrollingEvent
-
>
ScrollY
(
)
scrollingEvent
-
>
MaxScrollX
(
)
scrollingEvent
-
>
MaxScrollY
(
)
)
;
break
;
}
case
nsIAccessibleEvent
:
:
EVENT_ANNOUNCEMENT
:
{
AccAnnouncementEvent
*
announcementEvent
=
downcast_accEvent
(
aEvent
)
;
PlatformAnnouncementEvent
(
target
announcementEvent
-
>
Announcement
(
)
announcementEvent
-
>
Priority
(
)
)
;
break
;
}
#
endif
#
if
defined
(
MOZ_WIDGET_COCOA
)
case
nsIAccessibleEvent
:
:
EVENT_TEXT_SELECTION_CHANGED
:
{
AccTextSelChangeEvent
*
textSelChangeEvent
=
downcast_accEvent
(
aEvent
)
;
AutoTArray
<
TextRange
1
>
ranges
;
textSelChangeEvent
-
>
SelectionRanges
(
&
ranges
)
;
PlatformTextSelectionChangeEvent
(
target
ranges
)
;
break
;
}
#
endif
default
:
PlatformEvent
(
target
aEvent
-
>
GetEventType
(
)
)
;
}
return
NS_OK
;
}
already_AddRefed
<
AccAttributes
>
LocalAccessible
:
:
Attributes
(
)
{
RefPtr
<
AccAttributes
>
attributes
=
NativeAttributes
(
)
;
if
(
!
HasOwnContent
(
)
|
|
!
mContent
-
>
IsElement
(
)
)
return
attributes
.
forget
(
)
;
nsString
xmlRoles
;
if
(
nsAccUtils
:
:
GetARIAAttr
(
mContent
-
>
AsElement
(
)
nsGkAtoms
:
:
role
xmlRoles
)
&
&
!
xmlRoles
.
IsEmpty
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
std
:
:
move
(
xmlRoles
)
)
;
}
else
if
(
nsAtom
*
landmark
=
LandmarkRole
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
landmark
)
;
}
aria
:
:
AttrIterator
attribIter
(
mContent
)
;
while
(
attribIter
.
Next
(
)
)
{
if
(
attribIter
.
AttrName
(
)
=
=
nsGkAtoms
:
:
aria_placeholder
&
&
attributes
-
>
HasAttribute
(
nsGkAtoms
:
:
placeholder
)
)
{
continue
;
}
attribIter
.
ExposeAttr
(
attributes
)
;
}
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
if
(
roleMapEntry
)
{
if
(
roleMapEntry
-
>
Is
(
nsGkAtoms
:
:
searchbox
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
textInputType
nsGkAtoms
:
:
search
)
;
}
if
(
!
attributes
-
>
HasAttribute
(
nsGkAtoms
:
:
aria_live
)
)
{
nsString
live
;
if
(
nsAccUtils
:
:
GetLiveAttrValue
(
roleMapEntry
-
>
liveAttRule
live
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
aria_live
std
:
:
move
(
live
)
)
;
}
}
}
return
attributes
.
forget
(
)
;
}
already_AddRefed
<
AccAttributes
>
LocalAccessible
:
:
NativeAttributes
(
)
{
RefPtr
<
AccAttributes
>
attributes
=
new
AccAttributes
(
)
;
if
(
HasNumericValue
(
)
)
{
nsString
valuetext
;
Value
(
valuetext
)
;
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
aria_valuetext
std
:
:
move
(
valuetext
)
)
;
}
if
(
State
(
)
&
states
:
:
CHECKABLE
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
checkable
true
)
;
}
nsAutoString
name
;
if
(
Name
(
name
)
!
=
eNameFromSubtree
&
&
!
name
.
IsVoid
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
explicit_name
true
)
;
}
GroupPos
groupPos
=
GroupPosition
(
)
;
nsAccUtils
:
:
SetAccGroupAttrs
(
attributes
groupPos
.
level
groupPos
.
setSize
groupPos
.
posInSet
)
;
bool
hierarchical
=
false
;
uint32_t
itemCount
=
AccGroupInfo
:
:
TotalItemCount
(
this
&
hierarchical
)
;
if
(
itemCount
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
child_item_count
static_cast
<
int32_t
>
(
itemCount
)
)
;
}
if
(
hierarchical
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
tree
true
)
;
}
if
(
!
HasOwnContent
(
)
)
return
attributes
.
forget
(
)
;
nsAccUtils
:
:
SetLiveContainerAttributes
(
attributes
this
)
;
if
(
!
mContent
-
>
IsElement
(
)
)
return
attributes
.
forget
(
)
;
nsString
id
;
if
(
nsCoreUtils
:
:
GetID
(
mContent
id
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
id
std
:
:
move
(
id
)
)
;
}
nsString
_class
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
_class
_class
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
_class
std
:
:
move
(
_class
)
)
;
}
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
tag
mContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
if
(
auto
htmlElement
=
nsGenericHTMLElement
:
:
FromNode
(
mContent
)
)
{
if
(
htmlElement
-
>
Draggable
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
draggable
true
)
;
}
nsString
popover
;
htmlElement
-
>
GetPopover
(
popover
)
;
if
(
!
popover
.
IsEmpty
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
ispopup
std
:
:
move
(
popover
)
)
;
}
}
nsIFrame
*
f
=
mContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
f
|
|
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
{
return
attributes
.
forget
(
)
;
}
if
(
RefPtr
<
nsAtom
>
display
=
DisplayStyle
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
display
display
)
;
}
const
ComputedStyle
&
style
=
*
f
-
>
Style
(
)
;
auto
Atomize
=
[
&
]
(
nsCSSPropertyID
aId
)
-
>
RefPtr
<
nsAtom
>
{
nsAutoCString
value
;
style
.
GetComputedPropertyValue
(
aId
value
)
;
return
NS_Atomize
(
value
)
;
}
;
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
textAlign
Atomize
(
eCSSProperty_text_align
)
)
;
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
textIndent
Atomize
(
eCSSProperty_text_indent
)
)
;
auto
GetMargin
=
[
&
]
(
mozilla
:
:
Side
aSide
)
-
>
CSSCoord
{
const
auto
&
margin
=
f
-
>
StyleMargin
(
)
-
>
GetMargin
(
aSide
)
;
if
(
margin
.
ConvertsToLength
(
)
)
{
return
margin
.
AsLengthPercentage
(
)
.
ToLengthInCSSPixels
(
)
;
}
nscoord
coordVal
=
f
-
>
GetUsedMargin
(
)
.
Side
(
aSide
)
;
return
CSSPixel
:
:
FromAppUnits
(
coordVal
)
;
}
;
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
marginLeft
GetMargin
(
eSideLeft
)
)
;
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
marginRight
GetMargin
(
eSideRight
)
)
;
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
marginTop
GetMargin
(
eSideTop
)
)
;
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
marginBottom
GetMargin
(
eSideBottom
)
)
;
nsString
atShortcutKeys
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
dataAtShortcutkeys
atShortcutKeys
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
dataAtShortcutkeys
std
:
:
move
(
atShortcutKeys
)
)
;
}
return
attributes
.
forget
(
)
;
}
bool
LocalAccessible
:
:
AttributeChangesState
(
nsAtom
*
aAttribute
)
{
return
aAttribute
=
=
nsGkAtoms
:
:
aria_disabled
|
|
(
aAttribute
=
=
nsGkAtoms
:
:
disabled
&
&
!
mContent
-
>
IsHTMLElement
(
)
)
|
|
aAttribute
=
=
nsGkAtoms
:
:
tabindex
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_required
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_invalid
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_expanded
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_checked
|
|
(
aAttribute
=
=
nsGkAtoms
:
:
aria_pressed
&
&
IsButton
(
)
)
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_readonly
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_current
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_haspopup
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_busy
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_multiline
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_multiselectable
|
|
aAttribute
=
=
nsGkAtoms
:
:
contenteditable
|
|
aAttribute
=
=
nsGkAtoms
:
:
popovertarget
;
}
void
LocalAccessible
:
:
DOMAttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
uint64_t
aOldState
)
{
CssAltContent
:
:
HandleAttributeChange
(
mContent
aNameSpaceID
aAttribute
)
;
if
(
AttributeChangesState
(
aAttribute
)
)
{
uint64_t
currState
=
State
(
)
;
uint64_t
diffState
=
currState
^
aOldState
;
if
(
diffState
)
{
for
(
uint64_t
state
=
1
;
state
<
=
states
:
:
LAST_ENTRY
;
state
<
<
=
1
)
{
if
(
diffState
&
state
)
{
RefPtr
<
AccEvent
>
stateChangeEvent
=
new
AccStateChangeEvent
(
this
state
(
currState
&
state
)
)
;
mDoc
-
>
FireDelayedEvent
(
stateChangeEvent
)
;
}
}
}
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
_class
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
DOMNodeIDAndClass
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
open
)
{
if
(
HTMLSummaryAccessible
*
summaryAccessible
=
HTMLSummaryAccessible
:
:
FromDetails
(
this
)
)
{
RefPtr
<
AccEvent
>
expandedChangeEvent
=
new
AccStateChangeEvent
(
summaryAccessible
states
:
:
EXPANDED
)
;
mDoc
-
>
FireDelayedEvent
(
expandedChangeEvent
)
;
return
;
}
}
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
StringBeginsWith
(
nsDependentAtomString
(
aAttribute
)
u
"
aria
-
"
_ns
)
)
{
uint8_t
attrFlags
=
aria
:
:
AttrCharacteristicsFor
(
aAttribute
)
;
if
(
!
(
attrFlags
&
ATTR_BYPASSOBJ
)
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
ARIA
)
;
RefPtr
<
AccEvent
>
event
=
new
AccObjectAttrChangedEvent
(
this
aAttribute
)
;
mDoc
-
>
FireDelayedEvent
(
event
)
;
}
}
}
dom
:
:
Element
*
elm
=
Elm
(
)
;
if
(
HasNumericValue
(
)
&
&
(
aAttribute
=
=
nsGkAtoms
:
:
aria_valuemax
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_valuemin
|
|
aAttribute
=
=
nsGkAtoms
:
:
min
|
|
aAttribute
=
=
nsGkAtoms
:
:
max
|
|
aAttribute
=
=
nsGkAtoms
:
:
step
)
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Value
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_valuetext
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_TEXT_VALUE_CHANGE
this
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_valuenow
)
{
if
(
!
nsAccUtils
:
:
HasARIAAttr
(
elm
nsGkAtoms
:
:
aria_valuetext
)
|
|
nsAccUtils
:
:
ARIAAttrValueIs
(
elm
nsGkAtoms
:
:
aria_valuetext
nsGkAtoms
:
:
_empty
eCaseMatters
)
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
this
)
;
}
else
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Value
)
;
}
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_owns
)
{
mDoc
-
>
Controller
(
)
-
>
ScheduleRelocation
(
this
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_label
)
{
AssociatedElementsIterator
iter
(
mDoc
elm
nsGkAtoms
:
:
aria_labelledby
)
;
if
(
!
iter
.
NextElem
(
)
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
this
)
;
}
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_description
)
{
AssociatedElementsIterator
iter
(
mDoc
elm
nsGkAtoms
:
:
aria_describedby
)
;
if
(
!
iter
.
NextElem
(
)
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_DESCRIPTION_CHANGE
this
)
;
}
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_describedby
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Relations
)
;
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_DESCRIPTION_CHANGE
this
)
;
if
(
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
MODIFICATION
|
|
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
ADDITION
)
{
AssociatedElementsIterator
iter
(
mDoc
elm
nsGkAtoms
:
:
aria_describedby
)
;
while
(
LocalAccessible
*
target
=
iter
.
Next
(
)
)
{
target
-
>
ModifySubtreeContextFlags
(
eHasDescriptionDependent
true
)
;
}
}
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_labelledby
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Relations
)
;
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
this
)
;
if
(
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
MODIFICATION
|
|
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
ADDITION
)
{
AssociatedElementsIterator
iter
(
mDoc
elm
nsGkAtoms
:
:
aria_labelledby
)
;
while
(
LocalAccessible
*
target
=
iter
.
Next
(
)
)
{
target
-
>
ModifySubtreeContextFlags
(
eHasNameDependent
true
)
;
}
}
return
;
}
if
(
(
aAttribute
=
=
nsGkAtoms
:
:
aria_expanded
|
|
aAttribute
=
=
nsGkAtoms
:
:
href
)
&
&
(
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
ADDITION
|
|
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
REMOVAL
)
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Actions
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
href
|
|
aAttribute
=
=
nsGkAtoms
:
:
src
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Value
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_controls
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_flowto
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_details
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_errormessage
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Relations
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
popovertarget
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Relations
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
alt
&
&
!
nsAccUtils
:
:
HasARIAAttr
(
elm
nsGkAtoms
:
:
aria_label
)
&
&
!
elm
-
>
HasAttr
(
nsGkAtoms
:
:
aria_labelledby
)
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
this
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
title
)
{
nsAutoString
name
;
ARIAName
(
name
)
;
if
(
name
.
IsEmpty
(
)
)
{
NativeName
(
name
)
;
if
(
name
.
IsEmpty
(
)
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
this
)
;
return
;
}
}
if
(
!
elm
-
>
HasAttr
(
nsGkAtoms
:
:
aria_describedby
)
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_DESCRIPTION_CHANGE
this
)
;
}
return
;
}
if
(
(
mContent
-
>
IsXULElement
(
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
selected
)
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_selected
)
{
LocalAccessible
*
widget
=
nsAccUtils
:
:
GetSelectableContainer
(
this
State
(
)
)
;
if
(
widget
)
{
AccSelChangeEvent
:
:
SelChangeType
selChangeType
;
if
(
aNameSpaceID
!
=
kNameSpaceID_None
)
{
selChangeType
=
elm
-
>
AttrValueIs
(
aNameSpaceID
aAttribute
nsGkAtoms
:
:
_true
eCaseMatters
)
?
AccSelChangeEvent
:
:
eSelectionAdd
:
AccSelChangeEvent
:
:
eSelectionRemove
;
}
else
{
selChangeType
=
nsAccUtils
:
:
ARIAAttrValueIs
(
elm
aAttribute
nsGkAtoms
:
:
_true
eCaseMatters
)
?
AccSelChangeEvent
:
:
eSelectionAdd
:
AccSelChangeEvent
:
:
eSelectionRemove
;
}
RefPtr
<
AccEvent
>
event
=
new
AccSelChangeEvent
(
widget
this
selChangeType
)
;
mDoc
-
>
FireDelayedEvent
(
event
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_selected
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
State
)
;
}
}
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_level
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_setsize
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_posinset
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
GroupInfo
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
accesskey
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Actions
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
name
&
&
(
mContent
&
&
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
)
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Relations
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
slot
&
&
!
mContent
-
>
GetFlattenedTreeParentNode
(
)
&
&
this
!
=
mDoc
)
{
mDoc
-
>
ContentRemoved
(
this
)
;
}
}
void
LocalAccessible
:
:
ARIAGroupPosition
(
int32_t
*
aLevel
int32_t
*
aSetSize
int32_t
*
aPosInSet
)
const
{
if
(
!
mContent
)
{
return
;
}
if
(
aLevel
)
{
nsCoreUtils
:
:
GetUIntAttr
(
mContent
nsGkAtoms
:
:
aria_level
aLevel
)
;
}
if
(
aSetSize
)
{
nsCoreUtils
:
:
GetUIntAttr
(
mContent
nsGkAtoms
:
:
aria_setsize
aSetSize
)
;
}
if
(
aPosInSet
)
{
nsCoreUtils
:
:
GetUIntAttr
(
mContent
nsGkAtoms
:
:
aria_posinset
aPosInSet
)
;
}
}
uint64_t
LocalAccessible
:
:
State
(
)
{
if
(
IsDefunct
(
)
)
return
states
:
:
DEFUNCT
;
uint64_t
state
=
NativeState
(
)
;
ApplyARIAState
(
&
state
)
;
const
uint32_t
kExpandCollapseStates
=
states
:
:
COLLAPSED
|
states
:
:
EXPANDED
;
if
(
(
state
&
kExpandCollapseStates
)
=
=
kExpandCollapseStates
)
{
state
&
=
~
states
:
:
COLLAPSED
;
}
if
(
!
(
state
&
states
:
:
UNAVAILABLE
)
)
{
state
|
=
states
:
:
ENABLED
|
states
:
:
SENSITIVE
;
LocalAccessible
*
widget
=
ContainerWidget
(
)
;
if
(
widget
&
&
widget
-
>
CurrentItem
(
)
=
=
this
)
state
|
=
states
:
:
ACTIVE
;
}
if
(
(
state
&
states
:
:
COLLAPSED
)
|
|
(
state
&
states
:
:
EXPANDED
)
)
{
state
|
=
states
:
:
EXPANDABLE
;
}
ApplyImplicitState
(
state
)
;
return
state
;
}
void
LocalAccessible
:
:
ApplyARIAState
(
uint64_t
*
aState
)
const
{
if
(
!
mContent
-
>
IsElement
(
)
)
return
;
dom
:
:
Element
*
element
=
mContent
-
>
AsElement
(
)
;
*
aState
|
=
aria
:
:
UniversalStatesFor
(
element
)
;
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
if
(
!
roleMapEntry
&
&
IsHTMLTableCell
(
)
&
&
Role
(
)
=
=
roles
:
:
GRID_CELL
)
{
roleMapEntry
=
aria
:
:
GetRoleMap
(
nsGkAtoms
:
:
gridcell
)
;
MOZ_ASSERT
(
roleMapEntry
"
Should
have
role
map
entry
for
gridcell
"
)
;
}
if
(
roleMapEntry
)
{
if
(
roleMapEntry
-
>
role
!
=
roles
:
:
NOTHING
)
*
aState
&
=
~
states
:
:
READONLY
;
if
(
mContent
-
>
HasID
(
)
)
{
const
LocalAccessible
*
ancestor
=
this
;
while
(
(
ancestor
=
ancestor
-
>
LocalParent
(
)
)
&
&
!
ancestor
-
>
IsDoc
(
)
)
{
dom
:
:
Element
*
el
=
ancestor
-
>
Elm
(
)
;
if
(
el
&
&
el
-
>
HasAttr
(
nsGkAtoms
:
:
aria_activedescendant
)
)
{
*
aState
|
=
states
:
:
FOCUSABLE
;
break
;
}
}
}
}
if
(
*
aState
&
states
:
:
FOCUSABLE
)
{
const
LocalAccessible
*
ancestor
=
this
;
while
(
(
ancestor
=
ancestor
-
>
LocalParent
(
)
)
&
&
!
ancestor
-
>
IsDoc
(
)
)
{
dom
:
:
Element
*
el
=
ancestor
-
>
Elm
(
)
;
if
(
el
&
&
nsAccUtils
:
:
ARIAAttrValueIs
(
el
nsGkAtoms
:
:
aria_disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
*
aState
|
=
states
:
:
UNAVAILABLE
;
break
;
}
}
}
else
{
if
(
FocusMgr
(
)
-
>
IsActiveItem
(
this
)
)
{
*
aState
|
=
states
:
:
FOCUSABLE
;
}
}
if
(
IsButton
(
)
|
|
IsMenuButton
(
)
)
{
aria
:
:
MapToState
(
aria
:
:
eARIAPressed
element
aState
)
;
}
if
(
!
roleMapEntry
)
return
;
*
aState
|
=
roleMapEntry
-
>
state
;
if
(
aria
:
:
MapToState
(
roleMapEntry
-
>
attributeMap1
element
aState
)
&
&
aria
:
:
MapToState
(
roleMapEntry
-
>
attributeMap2
element
aState
)
&
&
aria
:
:
MapToState
(
roleMapEntry
-
>
attributeMap3
element
aState
)
)
{
aria
:
:
MapToState
(
roleMapEntry
-
>
attributeMap4
element
aState
)
;
}
if
(
(
roleMapEntry
-
>
Is
(
nsGkAtoms
:
:
gridcell
)
|
|
roleMapEntry
-
>
Is
(
nsGkAtoms
:
:
columnheader
)
|
|
roleMapEntry
-
>
Is
(
nsGkAtoms
:
:
rowheader
)
)
&
&
!
IsTable
(
)
&
&
!
nsAccUtils
:
:
HasDefinedARIAToken
(
mContent
nsGkAtoms
:
:
aria_readonly
)
)
{
if
(
const
LocalAccessible
*
grid
=
nsAccUtils
:
:
TableFor
(
this
)
)
{
uint64_t
gridState
=
0
;
grid
-
>
ApplyARIAState
(
&
gridState
)
;
*
aState
|
=
gridState
&
states
:
:
READONLY
;
}
}
}
void
LocalAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
if
(
HasNumericValue
(
)
)
{
if
(
!
mContent
-
>
IsElement
(
)
)
{
return
;
}
if
(
!
nsAccUtils
:
:
GetARIAAttr
(
mContent
-
>
AsElement
(
)
nsGkAtoms
:
:
aria_valuetext
aValue
)
)
{
if
(
!
NativeHasNumericValue
(
)
)
{
double
checkValue
=
CurValue
(
)
;
if
(
!
std
:
:
isnan
(
checkValue
)
)
{
aValue
.
AppendFloat
(
checkValue
)
;
}
}
}
return
;
}
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
if
(
!
roleMapEntry
)
{
return
;
}
if
(
roleMapEntry
-
>
Is
(
nsGkAtoms
:
:
textbox
)
)
{
nsTextEquivUtils
:
:
GetTextEquivFromSubtree
(
this
aValue
)
;
return
;
}
if
(
roleMapEntry
-
>
Is
(
nsGkAtoms
:
:
combobox
)
)
{
LocalAccessible
*
option
=
CurrentItem
(
)
;
if
(
!
option
)
{
uint32_t
childCount
=
ChildCount
(
)
;
for
(
uint32_t
idx
=
0
;
idx
<
childCount
;
idx
+
+
)
{
LocalAccessible
*
child
=
mChildren
.
ElementAt
(
idx
)
;
if
(
child
-
>
IsListControl
(
)
)
{
Accessible
*
acc
=
child
-
>
GetSelectedItem
(
0
)
;
option
=
acc
?
acc
-
>
AsLocal
(
)
:
nullptr
;
break
;
}
}
}
nsTextEquivUtils
:
:
GetTextEquivFromSubtree
(
option
?
option
:
this
aValue
)
;
}
}
double
LocalAccessible
:
:
MaxValue
(
)
const
{
double
checkValue
=
AttrNumericValue
(
nsGkAtoms
:
:
aria_valuemax
)
;
if
(
std
:
:
isnan
(
checkValue
)
&
&
!
NativeHasNumericValue
(
)
)
{
const
nsRoleMapEntry
*
roleMap
=
ARIARoleMap
(
)
;
if
(
roleMap
&
&
roleMap
-
>
role
=
=
roles
:
:
SPINBUTTON
)
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
return
100
;
}
return
checkValue
;
}
double
LocalAccessible
:
:
MinValue
(
)
const
{
double
checkValue
=
AttrNumericValue
(
nsGkAtoms
:
:
aria_valuemin
)
;
if
(
std
:
:
isnan
(
checkValue
)
&
&
!
NativeHasNumericValue
(
)
)
{
const
nsRoleMapEntry
*
roleMap
=
ARIARoleMap
(
)
;
if
(
roleMap
&
&
roleMap
-
>
role
=
=
roles
:
:
SPINBUTTON
)
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
return
0
;
}
return
checkValue
;
}
double
LocalAccessible
:
:
Step
(
)
const
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
double
LocalAccessible
:
:
CurValue
(
)
const
{
double
checkValue
=
AttrNumericValue
(
nsGkAtoms
:
:
aria_valuenow
)
;
if
(
std
:
:
isnan
(
checkValue
)
&
&
!
NativeHasNumericValue
(
)
)
{
const
nsRoleMapEntry
*
roleMap
=
ARIARoleMap
(
)
;
if
(
roleMap
&
&
roleMap
-
>
role
=
=
roles
:
:
SPINBUTTON
)
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
double
minValue
=
MinValue
(
)
;
return
minValue
+
(
(
MaxValue
(
)
-
minValue
)
/
2
)
;
}
return
checkValue
;
}
bool
LocalAccessible
:
:
SetCurValue
(
double
aValue
)
{
return
false
;
}
role
LocalAccessible
:
:
FindNextValidARIARole
(
std
:
:
initializer_list
<
nsStaticAtom
*
>
aRolesToSkip
)
const
{
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
if
(
roleMapEntry
&
&
mContent
&
&
mContent
-
>
IsElement
(
)
)
{
dom
:
:
Element
*
elem
=
mContent
-
>
AsElement
(
)
;
if
(
!
nsAccUtils
:
:
ARIAAttrValueIs
(
elem
nsGkAtoms
:
:
role
roleMapEntry
-
>
roleAtom
eIgnoreCase
)
)
{
uint8_t
roleMapIndex
=
aria
:
:
GetFirstValidRoleMapIndexExcluding
(
elem
aRolesToSkip
)
;
if
(
roleMapIndex
=
=
aria
:
:
NO_ROLE_MAP_ENTRY_INDEX
|
|
roleMapIndex
=
=
aria
:
:
LANDMARK_ROLE_MAP_ENTRY_INDEX
)
{
return
NativeRole
(
)
;
}
const
nsRoleMapEntry
*
fallbackRoleMapEntry
=
aria
:
:
GetRoleMapFromIndex
(
roleMapIndex
)
;
if
(
!
fallbackRoleMapEntry
)
{
return
NativeRole
(
)
;
}
return
ARIATransformRole
(
fallbackRoleMapEntry
-
>
role
)
;
}
}
return
NativeRole
(
)
;
}
role
LocalAccessible
:
:
ARIATransformRole
(
role
aRole
)
const
{
if
(
aRole
=
=
roles
:
:
REGION
|
|
aRole
=
=
roles
:
:
FORM
)
{
if
(
NameIsEmpty
(
)
)
{
return
FindNextValidARIARole
(
{
nsGkAtoms
:
:
region
nsGkAtoms
:
:
form
}
)
;
}
return
aRole
;
}
if
(
aRole
=
=
roles
:
:
PUSHBUTTON
)
{
if
(
nsAccUtils
:
:
HasDefinedARIAToken
(
mContent
nsGkAtoms
:
:
aria_pressed
)
)
{
return
roles
:
:
TOGGLE_BUTTON
;
}
if
(
mContent
-
>
IsElement
(
)
&
&
nsAccUtils
:
:
ARIAAttrValueIs
(
mContent
-
>
AsElement
(
)
nsGkAtoms
:
:
aria_haspopup
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
return
roles
:
:
BUTTONMENU
;
}
}
else
if
(
aRole
=
=
roles
:
:
LISTBOX
)
{
if
(
mParent
&
&
mParent
-
>
IsCombobox
(
)
)
{
return
roles
:
:
COMBOBOX_LIST
;
}
}
else
if
(
aRole
=
=
roles
:
:
OPTION
)
{
if
(
mParent
&
&
mParent
-
>
Role
(
)
=
=
roles
:
:
COMBOBOX_LIST
)
{
return
roles
:
:
COMBOBOX_OPTION
;
}
const
Accessible
*
listbox
=
FindAncestorIf
(
[
]
(
const
Accessible
&
aAcc
)
{
const
role
accRole
=
aAcc
.
Role
(
)
;
return
accRole
=
=
roles
:
:
LISTBOX
?
AncestorSearchOption
:
:
Found
:
accRole
=
=
roles
:
:
GROUPING
?
AncestorSearchOption
:
:
Continue
:
AncestorSearchOption
:
:
NotFound
;
}
)
;
if
(
!
listbox
)
{
return
NativeRole
(
)
;
}
}
else
if
(
aRole
=
=
roles
:
:
MENUITEM
)
{
if
(
mContent
-
>
IsElement
(
)
&
&
nsAccUtils
:
:
ARIAAttrValueIs
(
mContent
-
>
AsElement
(
)
nsGkAtoms
:
:
aria_haspopup
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
return
roles
:
:
PARENT_MENUITEM
;
}
const
Accessible
*
menu
=
FindAncestorIf
(
[
]
(
const
Accessible
&
aAcc
)
{
const
role
accRole
=
aAcc
.
Role
(
)
;
return
(
accRole
=
=
roles
:
:
MENUBAR
|
|
accRole
=
=
roles
:
:
MENUPOPUP
)
?
AncestorSearchOption
:
:
Found
:
accRole
=
=
roles
:
:
GROUPING
?
AncestorSearchOption
:
:
Continue
:
AncestorSearchOption
:
:
NotFound
;
}
)
;
if
(
!
menu
)
{
return
NativeRole
(
)
;
}
}
else
if
(
aRole
=
=
roles
:
:
RADIO_MENU_ITEM
|
|
aRole
=
=
roles
:
:
CHECK_MENU_ITEM
)
{
const
Accessible
*
menu
=
FindAncestorIf
(
[
]
(
const
Accessible
&
aAcc
)
{
const
role
accRole
=
aAcc
.
Role
(
)
;
return
(
accRole
=
=
roles
:
:
MENUBAR
|
|
accRole
=
=
roles
:
:
MENUPOPUP
)
?
AncestorSearchOption
:
:
Found
:
accRole
=
=
roles
:
:
GROUPING
?
AncestorSearchOption
:
:
Continue
:
AncestorSearchOption
:
:
NotFound
;
}
)
;
if
(
!
menu
)
{
return
NativeRole
(
)
;
}
}
else
if
(
aRole
=
=
roles
:
:
CELL
)
{
const
LocalAccessible
*
table
=
nsAccUtils
:
:
TableFor
(
this
)
;
if
(
table
&
&
table
-
>
IsARIARole
(
nsGkAtoms
:
:
grid
)
)
{
return
roles
:
:
GRID_CELL
;
}
}
else
if
(
aRole
=
=
roles
:
:
ROW
)
{
const
LocalAccessible
*
table
=
nsAccUtils
:
:
TableFor
(
this
)
;
if
(
!
table
)
{
return
NativeRole
(
)
;
}
}
else
if
(
aRole
=
=
roles
:
:
ROWGROUP
)
{
const
Accessible
*
table
=
FindAncestorIf
(
[
]
(
const
Accessible
&
aAcc
)
{
return
aAcc
.
IsTable
(
)
?
AncestorSearchOption
:
:
Found
:
AncestorSearchOption
:
:
NotFound
;
}
)
;
if
(
!
table
)
{
return
NativeRole
(
)
;
}
}
else
if
(
aRole
=
=
roles
:
:
GRID_CELL
|
|
aRole
=
=
roles
:
:
ROWHEADER
|
|
aRole
=
=
roles
:
:
COLUMNHEADER
)
{
const
Accessible
*
row
=
FindAncestorIf
(
[
]
(
const
Accessible
&
aAcc
)
{
return
aAcc
.
IsTableRow
(
)
?
AncestorSearchOption
:
:
Found
:
AncestorSearchOption
:
:
NotFound
;
}
)
;
if
(
!
row
)
{
return
NativeRole
(
)
;
}
}
else
if
(
aRole
=
=
roles
:
:
LISTITEM
)
{
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
if
(
!
roleMapEntry
|
|
(
roleMapEntry
-
>
roleAtom
!
=
nsGkAtoms
:
:
docBiblioentry
&
&
roleMapEntry
-
>
roleAtom
!
=
nsGkAtoms
:
:
docEndnote
)
)
{
const
Accessible
*
list
=
FindAncestorIf
(
[
]
(
const
Accessible
&
aAcc
)
{
return
aAcc
.
IsList
(
)
?
AncestorSearchOption
:
:
Found
:
AncestorSearchOption
:
:
Continue
;
}
)
;
if
(
!
list
)
{
return
NativeRole
(
)
;
}
}
}
else
if
(
aRole
=
=
roles
:
:
PAGETAB
)
{
const
Accessible
*
tablist
=
FindAncestorIf
(
[
]
(
const
Accessible
&
aAcc
)
{
return
aAcc
.
Role
(
)
=
=
roles
:
:
PAGETABLIST
?
AncestorSearchOption
:
:
Found
:
AncestorSearchOption
:
:
NotFound
;
}
)
;
if
(
!
tablist
)
{
return
NativeRole
(
)
;
}
}
else
if
(
aRole
=
=
roles
:
:
OUTLINEITEM
)
{
const
Accessible
*
tree
=
FindAncestorIf
(
[
]
(
const
Accessible
&
aAcc
)
{
return
aAcc
.
Role
(
)
=
=
roles
:
:
OUTLINE
?
AncestorSearchOption
:
:
Found
:
AncestorSearchOption
:
:
Continue
;
}
)
;
if
(
!
tree
)
{
return
NativeRole
(
)
;
}
}
return
aRole
;
}
role
LocalAccessible
:
:
GetMinimumRole
(
role
aRole
)
const
{
if
(
aRole
!
=
roles
:
:
TEXT
&
&
aRole
!
=
roles
:
:
TEXT_CONTAINER
&
&
aRole
!
=
roles
:
:
SECTION
)
{
return
aRole
;
}
dom
:
:
Element
*
el
=
Elm
(
)
;
if
(
el
&
&
el
-
>
IsHTMLElement
(
)
&
&
el
-
>
HasAttr
(
nsGkAtoms
:
:
popover
)
)
{
return
roles
:
:
GROUPING
;
}
return
aRole
;
}
role
LocalAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
NOTHING
;
}
uint8_t
LocalAccessible
:
:
ActionCount
(
)
const
{
return
HasPrimaryAction
(
)
|
|
ActionAncestor
(
)
?
1
:
0
;
}
void
LocalAccessible
:
:
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
{
aName
.
Truncate
(
)
;
if
(
aIndex
!
=
0
)
return
;
uint32_t
actionRule
=
GetActionRule
(
)
;
switch
(
actionRule
)
{
case
eActivateAction
:
aName
.
AssignLiteral
(
"
activate
"
)
;
return
;
case
eClickAction
:
aName
.
AssignLiteral
(
"
click
"
)
;
return
;
case
ePressAction
:
aName
.
AssignLiteral
(
"
press
"
)
;
return
;
case
eCheckUncheckAction
:
{
uint64_t
state
=
State
(
)
;
if
(
state
&
states
:
:
CHECKED
)
{
aName
.
AssignLiteral
(
"
uncheck
"
)
;
}
else
if
(
state
&
states
:
:
MIXED
)
{
aName
.
AssignLiteral
(
"
cycle
"
)
;
}
else
{
aName
.
AssignLiteral
(
"
check
"
)
;
}
return
;
}
case
eJumpAction
:
aName
.
AssignLiteral
(
"
jump
"
)
;
return
;
case
eOpenCloseAction
:
if
(
State
(
)
&
states
:
:
COLLAPSED
)
{
aName
.
AssignLiteral
(
"
open
"
)
;
}
else
{
aName
.
AssignLiteral
(
"
close
"
)
;
}
return
;
case
eSelectAction
:
aName
.
AssignLiteral
(
"
select
"
)
;
return
;
case
eSwitchAction
:
aName
.
AssignLiteral
(
"
switch
"
)
;
return
;
case
eSortAction
:
aName
.
AssignLiteral
(
"
sort
"
)
;
return
;
case
eExpandAction
:
if
(
State
(
)
&
states
:
:
COLLAPSED
)
{
aName
.
AssignLiteral
(
"
expand
"
)
;
}
else
{
aName
.
AssignLiteral
(
"
collapse
"
)
;
}
return
;
}
if
(
ActionAncestor
(
)
)
{
aName
.
AssignLiteral
(
"
clickAncestor
"
)
;
return
;
}
}
bool
LocalAccessible
:
:
DoAction
(
uint8_t
aIndex
)
const
{
if
(
aIndex
!
=
0
)
return
false
;
if
(
HasPrimaryAction
(
)
|
|
ActionAncestor
(
)
)
{
DoCommand
(
)
;
return
true
;
}
return
false
;
}
bool
LocalAccessible
:
:
HasPrimaryAction
(
)
const
{
return
GetActionRule
(
)
!
=
eNoAction
;
}
nsIContent
*
LocalAccessible
:
:
GetAtomicRegion
(
)
const
{
nsIContent
*
loopContent
=
mContent
;
nsAutoString
atomic
;
while
(
loopContent
&
&
(
!
loopContent
-
>
IsElement
(
)
|
|
!
nsAccUtils
:
:
GetARIAAttr
(
loopContent
-
>
AsElement
(
)
nsGkAtoms
:
:
aria_atomic
atomic
)
)
)
{
loopContent
=
loopContent
-
>
GetParent
(
)
;
}
return
atomic
.
EqualsLiteral
(
"
true
"
)
?
loopContent
:
nullptr
;
}
LocalAccessible
*
LocalAccessible
:
:
GetPopoverTargetDetailsRelation
(
)
const
{
dom
:
:
Element
*
targetEl
=
mContent
-
>
GetEffectivePopoverTargetElement
(
)
;
if
(
!
targetEl
)
{
return
nullptr
;
}
LocalAccessible
*
targetAcc
=
mDoc
-
>
GetAccessible
(
targetEl
)
;
if
(
!
targetAcc
)
{
return
nullptr
;
}
if
(
const
nsAttrValue
*
actionVal
=
Elm
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
popovertargetaction
)
)
{
if
(
static_cast
<
PopoverTargetAction
>
(
actionVal
-
>
GetEnumValue
(
)
)
=
=
PopoverTargetAction
:
:
Hide
)
{
return
nullptr
;
}
}
if
(
targetAcc
-
>
NextSibling
(
)
=
=
this
|
|
targetAcc
-
>
PrevSibling
(
)
=
=
this
)
{
return
nullptr
;
}
return
targetAcc
;
}
Relation
LocalAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
if
(
!
HasOwnContent
(
)
)
return
Relation
(
)
;
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
switch
(
aType
)
{
case
RelationType
:
:
LABELLED_BY
:
{
Relation
rel
(
new
AssociatedElementsIterator
(
mDoc
mContent
nsGkAtoms
:
:
aria_labelledby
)
)
;
if
(
mContent
-
>
IsHTMLElement
(
)
)
{
rel
.
AppendIter
(
new
HTMLLabelIterator
(
Document
(
)
this
)
)
;
}
rel
.
AppendIter
(
new
XULLabelIterator
(
Document
(
)
mContent
)
)
;
return
rel
;
}
case
RelationType
:
:
LABEL_FOR
:
{
Relation
rel
(
new
RelatedAccIterator
(
Document
(
)
mContent
nsGkAtoms
:
:
aria_labelledby
)
)
;
if
(
mContent
-
>
IsXULElement
(
nsGkAtoms
:
:
label
)
)
{
rel
.
AppendIter
(
new
AssociatedElementsIterator
(
mDoc
mContent
nsGkAtoms
:
:
control
)
)
;
}
return
rel
;
}
case
RelationType
:
:
DESCRIBED_BY
:
{
Relation
rel
(
new
AssociatedElementsIterator
(
mDoc
mContent
nsGkAtoms
:
:
aria_describedby
)
)
;
if
(
mContent
-
>
IsXULElement
(
)
)
{
rel
.
AppendIter
(
new
XULDescriptionIterator
(
Document
(
)
mContent
)
)
;
}
return
rel
;
}
case
RelationType
:
:
DESCRIPTION_FOR
:
{
Relation
rel
(
new
RelatedAccIterator
(
Document
(
)
mContent
nsGkAtoms
:
:
aria_describedby
)
)
;
if
(
mContent
-
>
IsXULElement
(
nsGkAtoms
:
:
description
)
)
{
rel
.
AppendIter
(
new
AssociatedElementsIterator
(
mDoc
mContent
nsGkAtoms
:
:
control
)
)
;
}
return
rel
;
}
case
RelationType
:
:
NODE_CHILD_OF
:
{
Relation
rel
;
if
(
roleMapEntry
&
&
(
roleMapEntry
-
>
role
=
=
roles
:
:
OUTLINEITEM
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
LISTITEM
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
ROW
)
)
{
AccGroupInfo
*
groupInfo
=
const_cast
<
LocalAccessible
*
>
(
this
)
-
>
GetOrCreateGroupInfo
(
)
;
if
(
groupInfo
)
{
Accessible
*
parent
=
groupInfo
-
>
ConceptualParent
(
)
;
if
(
parent
)
{
MOZ_ASSERT
(
parent
-
>
IsLocal
(
)
)
;
rel
.
AppendTarget
(
parent
-
>
AsLocal
(
)
)
;
}
}
}
if
(
XRE_IsContentProcess
(
)
&
&
IsRoot
(
)
)
{
dom
:
:
Document
*
doc
=
const_cast
<
LocalAccessible
*
>
(
this
)
-
>
AsDoc
(
)
-
>
DocumentNode
(
)
;
dom
:
:
BrowsingContext
*
bc
=
doc
-
>
GetBrowsingContext
(
)
;
MOZ_ASSERT
(
bc
)
;
if
(
!
bc
-
>
Top
(
)
-
>
IsInProcess
(
)
)
{
return
rel
;
}
}
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
frame
)
{
nsView
*
view
=
frame
-
>
GetView
(
)
;
if
(
view
)
{
ScrollContainerFrame
*
scrollContainerFrame
=
do_QueryFrame
(
frame
)
;
if
(
scrollContainerFrame
|
|
view
-
>
GetWidget
(
)
|
|
!
frame
-
>
GetParent
(
)
)
{
rel
.
AppendTarget
(
LocalParent
(
)
)
;
}
}
}
return
rel
;
}
case
RelationType
:
:
NODE_PARENT_OF
:
{
if
(
roleMapEntry
&
&
(
roleMapEntry
-
>
role
=
=
roles
:
:
OUTLINEITEM
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
LISTITEM
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
ROW
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
OUTLINE
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
LIST
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
TREE_TABLE
)
)
{
return
Relation
(
new
ItemIterator
(
this
)
)
;
}
return
Relation
(
)
;
}
case
RelationType
:
:
CONTROLLED_BY
:
return
Relation
(
new
RelatedAccIterator
(
Document
(
)
mContent
nsGkAtoms
:
:
aria_controls
)
)
;
case
RelationType
:
:
CONTROLLER_FOR
:
{
Relation
rel
(
new
AssociatedElementsIterator
(
mDoc
mContent
nsGkAtoms
:
:
aria_controls
)
)
;
rel
.
AppendIter
(
new
HTMLOutputIterator
(
Document
(
)
mContent
)
)
;
return
rel
;
}
case
RelationType
:
:
FLOWS_TO
:
return
Relation
(
new
AssociatedElementsIterator
(
mDoc
mContent
nsGkAtoms
:
:
aria_flowto
)
)
;
case
RelationType
:
:
FLOWS_FROM
:
return
Relation
(
new
RelatedAccIterator
(
Document
(
)
mContent
nsGkAtoms
:
:
aria_flowto
)
)
;
case
RelationType
:
:
MEMBER_OF
:
{
if
(
Role
(
)
=
=
roles
:
:
RADIOBUTTON
)
{
Relation
rel
=
Relation
(
)
;
LocalAccessible
*
currParent
=
LocalParent
(
)
;
while
(
currParent
&
&
currParent
-
>
Role
(
)
!
=
roles
:
:
RADIO_GROUP
)
{
currParent
=
currParent
-
>
LocalParent
(
)
;
}
if
(
currParent
&
&
currParent
-
>
Role
(
)
=
=
roles
:
:
RADIO_GROUP
)
{
Pivot
p
=
Pivot
(
currParent
)
;
PivotRoleRule
rule
(
roles
:
:
RADIOBUTTON
)
;
Accessible
*
match
=
p
.
Next
(
currParent
rule
)
;
while
(
match
)
{
MOZ_ASSERT
(
match
-
>
IsLocal
(
)
"
We
shouldn
'
t
find
any
remote
accs
while
building
our
"
"
relation
!
"
)
;
rel
.
AppendTarget
(
match
-
>
AsLocal
(
)
)
;
match
=
p
.
Next
(
match
rule
)
;
}
}
return
rel
;
}
return
Relation
(
mDoc
GetAtomicRegion
(
)
)
;
}
case
RelationType
:
:
LINKS_TO
:
{
Relation
rel
=
Relation
(
)
;
if
(
Role
(
)
=
=
roles
:
:
LINK
)
{
dom
:
:
HTMLAnchorElement
*
anchor
=
dom
:
:
HTMLAnchorElement
:
:
FromNode
(
mContent
)
;
if
(
!
anchor
)
{
return
rel
;
}
nsAutoCString
hash
;
anchor
-
>
GetHash
(
hash
)
;
if
(
hash
.
IsEmpty
(
)
)
{
return
rel
;
}
NS_ConvertUTF8toUTF16
hash16
(
Substring
(
hash
1
)
)
;
if
(
dom
:
:
Element
*
elm
=
mContent
-
>
OwnerDoc
(
)
-
>
GetElementById
(
hash16
)
)
{
rel
.
AppendTarget
(
mDoc
-
>
GetAccessibleOrContainer
(
elm
)
)
;
}
else
if
(
nsCOMPtr
<
nsINodeList
>
list
=
mContent
-
>
OwnerDoc
(
)
-
>
GetElementsByName
(
hash16
)
)
{
uint32_t
length
=
list
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
nsIContent
*
node
=
list
-
>
Item
(
i
)
;
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
)
{
rel
.
AppendTarget
(
mDoc
-
>
GetAccessibleOrContainer
(
node
)
)
;
break
;
}
}
}
}
return
rel
;
}
case
RelationType
:
:
SUBWINDOW_OF
:
case
RelationType
:
:
EMBEDS
:
case
RelationType
:
:
EMBEDDED_BY
:
case
RelationType
:
:
POPUP_FOR
:
case
RelationType
:
:
PARENT_WINDOW_OF
:
return
Relation
(
)
;
case
RelationType
:
:
DEFAULT_BUTTON
:
{
if
(
mContent
-
>
IsHTMLElement
(
)
)
{
if
(
auto
*
control
=
nsIFormControl
:
:
FromNode
(
mContent
)
)
{
if
(
dom
:
:
HTMLFormElement
*
form
=
control
-
>
GetForm
(
)
)
{
return
Relation
(
mDoc
form
-
>
GetDefaultSubmitElement
(
)
)
;
}
}
}
else
{
dom
:
:
Document
*
doc
=
mContent
-
>
OwnerDoc
(
)
;
nsIContent
*
buttonEl
=
nullptr
;
if
(
doc
-
>
AllowXULXBL
(
)
)
{
nsCOMPtr
<
nsIHTMLCollection
>
possibleDefaultButtons
=
doc
-
>
GetElementsByAttribute
(
u
"
default
"
_ns
u
"
true
"
_ns
)
;
if
(
possibleDefaultButtons
)
{
uint32_t
length
=
possibleDefaultButtons
-
>
Length
(
)
;
for
(
uint32_t
count
=
0
;
count
<
length
&
&
!
buttonEl
;
count
+
+
)
{
nsIContent
*
item
=
possibleDefaultButtons
-
>
Item
(
count
)
;
RefPtr
<
nsIDOMXULButtonElement
>
button
=
item
-
>
IsElement
(
)
?
item
-
>
AsElement
(
)
-
>
AsXULButton
(
)
:
nullptr
;
if
(
button
)
{
buttonEl
=
item
;
}
}
}
return
Relation
(
mDoc
buttonEl
)
;
}
}
return
Relation
(
)
;
}
case
RelationType
:
:
CONTAINING_DOCUMENT
:
return
Relation
(
mDoc
)
;
case
RelationType
:
:
CONTAINING_TAB_PANE
:
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
nsCoreUtils
:
:
GetDocShellFor
(
GetNode
(
)
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
docShell
-
>
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
root
)
)
;
if
(
root
)
{
if
(
root
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
return
Relation
(
nsAccUtils
:
:
GetDocAccessibleFor
(
root
)
)
;
}
}
}
return
Relation
(
)
;
}
case
RelationType
:
:
CONTAINING_APPLICATION
:
return
Relation
(
ApplicationAcc
(
)
)
;
case
RelationType
:
:
DETAILS
:
{
if
(
mContent
-
>
IsElement
(
)
&
&
nsAccUtils
:
:
HasARIAAttr
(
mContent
-
>
AsElement
(
)
nsGkAtoms
:
:
aria_details
)
)
{
return
Relation
(
new
AssociatedElementsIterator
(
mDoc
mContent
nsGkAtoms
:
:
aria_details
)
)
;
}
if
(
LocalAccessible
*
target
=
GetPopoverTargetDetailsRelation
(
)
)
{
return
Relation
(
target
)
;
}
return
Relation
(
)
;
}
case
RelationType
:
:
DETAILS_FOR
:
{
Relation
rel
(
new
RelatedAccIterator
(
mDoc
mContent
nsGkAtoms
:
:
aria_details
)
)
;
RelatedAccIterator
invokers
(
mDoc
mContent
nsGkAtoms
:
:
popovertarget
)
;
while
(
Accessible
*
invoker
=
invokers
.
Next
(
)
)
{
LocalAccessible
*
popoverTarget
=
invoker
-
>
AsLocal
(
)
-
>
GetPopoverTargetDetailsRelation
(
)
;
if
(
popoverTarget
)
{
MOZ_ASSERT
(
popoverTarget
=
=
this
)
;
rel
.
AppendTarget
(
invoker
)
;
}
}
return
rel
;
}
case
RelationType
:
:
ERRORMSG
:
return
Relation
(
new
AssociatedElementsIterator
(
mDoc
mContent
nsGkAtoms
:
:
aria_errormessage
)
)
;
case
RelationType
:
:
ERRORMSG_FOR
:
return
Relation
(
new
RelatedAccIterator
(
mDoc
mContent
nsGkAtoms
:
:
aria_errormessage
)
)
;
default
:
return
Relation
(
)
;
}
}
void
LocalAccessible
:
:
GetNativeInterface
(
void
*
*
aNativeAccessible
)
{
}
void
LocalAccessible
:
:
DoCommand
(
nsIContent
*
aContent
uint32_t
aActionIndex
)
const
{
class
Runnable
final
:
public
mozilla
:
:
Runnable
{
public
:
Runnable
(
const
LocalAccessible
*
aAcc
nsIContent
*
aContent
uint32_t
aIdx
)
:
mozilla
:
:
Runnable
(
"
Runnable
"
)
mAcc
(
aAcc
)
mContent
(
aContent
)
mIdx
(
aIdx
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
if
(
mAcc
)
{
MOZ_KnownLive
(
mAcc
)
-
>
DispatchClickEvent
(
MOZ_KnownLive
(
mContent
)
mIdx
)
;
}
return
NS_OK
;
}
void
Revoke
(
)
{
mAcc
=
nullptr
;
mContent
=
nullptr
;
}
private
:
RefPtr
<
const
LocalAccessible
>
mAcc
;
nsCOMPtr
<
nsIContent
>
mContent
;
uint32_t
mIdx
;
}
;
nsIContent
*
content
=
aContent
?
aContent
:
mContent
.
get
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
Runnable
(
this
content
aActionIndex
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
void
LocalAccessible
:
:
DispatchClickEvent
(
nsIContent
*
aContent
uint32_t
aActionIndex
)
const
{
if
(
IsDefunct
(
)
)
return
;
RefPtr
<
PresShell
>
presShell
=
mDoc
-
>
PresShellPtr
(
)
;
presShell
-
>
ScrollContentIntoView
(
aContent
ScrollAxis
(
)
ScrollAxis
(
)
ScrollFlags
:
:
ScrollOverflowHidden
)
;
AutoWeakFrame
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
return
;
nsPoint
point
;
nsCOMPtr
<
nsIWidget
>
widget
=
frame
-
>
GetNearestWidget
(
point
)
;
if
(
!
widget
)
return
;
nsSize
size
=
frame
-
>
GetSize
(
)
;
RefPtr
<
nsPresContext
>
presContext
=
presShell
-
>
GetPresContext
(
)
;
int32_t
x
=
presContext
-
>
AppUnitsToDevPixels
(
point
.
x
+
size
.
width
/
2
)
;
int32_t
y
=
presContext
-
>
AppUnitsToDevPixels
(
point
.
y
+
size
.
height
/
2
)
;
nsCoreUtils
:
:
DispatchTouchEvent
(
eTouchStart
x
y
aContent
frame
presShell
widget
)
;
nsCoreUtils
:
:
DispatchMouseEvent
(
eMouseDown
x
y
aContent
frame
presShell
widget
)
;
nsCoreUtils
:
:
DispatchTouchEvent
(
eTouchEnd
x
y
aContent
frame
presShell
widget
)
;
nsCoreUtils
:
:
DispatchMouseEvent
(
eMouseUp
x
y
aContent
frame
presShell
widget
)
;
}
void
LocalAccessible
:
:
ScrollToPoint
(
uint32_t
aCoordinateType
int32_t
aX
int32_t
aY
)
{
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
!
frame
)
return
;
LayoutDeviceIntPoint
coords
=
nsAccUtils
:
:
ConvertToScreenCoords
(
aX
aY
aCoordinateType
this
)
;
nsIFrame
*
parentFrame
=
frame
;
while
(
(
parentFrame
=
parentFrame
-
>
GetParent
(
)
)
)
{
nsCoreUtils
:
:
ScrollFrameToPoint
(
parentFrame
frame
coords
)
;
}
}
void
LocalAccessible
:
:
AppendTextTo
(
nsAString
&
aText
uint32_t
aStartOffset
uint32_t
aLength
)
{
if
(
aStartOffset
!
=
0
|
|
aLength
=
=
0
)
return
;
MOZ_ASSERT
(
mParent
"
Called
on
accessible
unbound
from
tree
.
Result
can
be
wrong
.
"
)
;
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
IsHTMLBr
(
)
|
|
(
frame
&
&
frame
-
>
IsBrFrame
(
)
)
)
{
aText
+
=
kForcedNewLineChar
;
}
else
if
(
mParent
&
&
nsAccUtils
:
:
MustPrune
(
mParent
)
)
{
aText
+
=
kImaginaryEmbeddedObjectChar
;
}
else
{
aText
+
=
kEmbeddedObjectChar
;
}
}
void
LocalAccessible
:
:
Shutdown
(
)
{
mStateFlags
|
=
eIsDefunct
;
int32_t
childCount
=
mChildren
.
Length
(
)
;
for
(
int32_t
childIdx
=
0
;
childIdx
<
childCount
;
childIdx
+
+
)
{
mChildren
.
ElementAt
(
childIdx
)
-
>
UnbindFromParent
(
)
;
}
mChildren
.
Clear
(
)
;
mEmbeddedObjCollector
=
nullptr
;
if
(
mParent
)
mParent
-
>
RemoveChild
(
this
)
;
mContent
=
nullptr
;
mDoc
=
nullptr
;
if
(
SelectionMgr
(
)
&
&
SelectionMgr
(
)
-
>
AccessibleWithCaret
(
nullptr
)
=
=
this
)
{
SelectionMgr
(
)
-
>
ResetCaretOffset
(
)
;
}
}
void
LocalAccessible
:
:
ARIAName
(
nsString
&
aName
)
const
{
if
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
slot
)
)
{
return
;
}
nsresult
rv
=
nsTextEquivUtils
:
:
GetTextEquivFromIDRefs
(
this
nsGkAtoms
:
:
aria_labelledby
aName
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aName
.
CompressWhitespace
(
)
;
}
if
(
aName
.
IsEmpty
(
)
&
&
mContent
-
>
IsElement
(
)
&
&
nsAccUtils
:
:
GetARIAAttr
(
mContent
-
>
AsElement
(
)
nsGkAtoms
:
:
aria_label
aName
)
)
{
aName
.
CompressWhitespace
(
)
;
}
}
void
LocalAccessible
:
:
ARIADescription
(
nsString
&
aDescription
)
const
{
nsresult
rv
=
nsTextEquivUtils
:
:
GetTextEquivFromIDRefs
(
this
nsGkAtoms
:
:
aria_describedby
aDescription
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aDescription
.
CompressWhitespace
(
)
;
}
if
(
aDescription
.
IsEmpty
(
)
&
&
mContent
-
>
IsElement
(
)
&
&
nsAccUtils
:
:
GetARIAAttr
(
mContent
-
>
AsElement
(
)
nsGkAtoms
:
:
aria_description
aDescription
)
)
{
aDescription
.
CompressWhitespace
(
)
;
}
}
ENameValueFlag
LocalAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
if
(
mContent
-
>
IsHTMLElement
(
)
)
{
LocalAccessible
*
label
=
nullptr
;
HTMLLabelIterator
iter
(
Document
(
)
this
)
;
while
(
(
label
=
iter
.
Next
(
)
)
)
{
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
this
label
-
>
GetContent
(
)
&
aName
)
;
aName
.
CompressWhitespace
(
)
;
}
if
(
!
aName
.
IsEmpty
(
)
)
return
eNameOK
;
NameFromAssociatedXULLabel
(
mDoc
mContent
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
{
return
eNameOK
;
}
nsTextEquivUtils
:
:
GetNameFromSubtree
(
this
aName
)
;
return
aName
.
IsEmpty
(
)
?
eNameOK
:
eNameFromSubtree
;
}
if
(
mContent
-
>
IsXULElement
(
)
)
{
XULElmName
(
mDoc
mContent
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
eNameOK
;
nsTextEquivUtils
:
:
GetNameFromSubtree
(
this
aName
)
;
return
aName
.
IsEmpty
(
)
?
eNameOK
:
eNameFromSubtree
;
}
if
(
mContent
-
>
IsSVGElement
(
)
)
{
for
(
nsIContent
*
childElm
=
mContent
-
>
GetFirstChild
(
)
;
childElm
;
childElm
=
childElm
-
>
GetNextSibling
(
)
)
{
if
(
childElm
-
>
IsSVGElement
(
nsGkAtoms
:
:
title
)
)
{
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
this
childElm
&
aName
)
;
return
eNameOK
;
}
}
}
return
eNameOK
;
}
void
LocalAccessible
:
:
NativeDescription
(
nsString
&
aDescription
)
const
{
bool
isXUL
=
mContent
-
>
IsXULElement
(
)
;
if
(
isXUL
)
{
XULDescriptionIterator
iter
(
Document
(
)
mContent
)
;
LocalAccessible
*
descr
=
nullptr
;
while
(
(
descr
=
iter
.
Next
(
)
)
)
{
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
this
descr
-
>
GetContent
(
)
&
aDescription
)
;
}
}
}
void
LocalAccessible
:
:
BindToParent
(
LocalAccessible
*
aParent
uint32_t
aIndexInParent
)
{
MOZ_ASSERT
(
aParent
"
This
method
isn
'
t
used
to
set
null
parent
"
)
;
MOZ_ASSERT
(
!
mParent
"
The
child
was
expected
to
be
moved
"
)
;
#
ifdef
A11Y_LOG
if
(
mParent
)
{
logging
:
:
TreeInfo
(
"
BindToParent
:
stealing
accessible
"
0
"
old
parent
"
mParent
"
new
parent
"
aParent
"
child
"
this
nullptr
)
;
}
#
endif
mParent
=
aParent
;
mIndexInParent
=
aIndexInParent
;
if
(
mParent
-
>
HasNameDependent
(
)
|
|
mParent
-
>
IsXULListItem
(
)
|
|
RelationByType
(
RelationType
:
:
LABEL_FOR
)
.
Next
(
)
|
|
nsTextEquivUtils
:
:
HasNameRule
(
mParent
eNameFromSubtreeRule
)
)
{
mContextFlags
|
=
eHasNameDependent
;
}
else
{
mContextFlags
&
=
~
eHasNameDependent
;
}
if
(
mParent
-
>
HasDescriptionDependent
(
)
|
|
RelationByType
(
RelationType
:
:
DESCRIPTION_FOR
)
.
Next
(
)
)
{
mContextFlags
|
=
eHasDescriptionDependent
;
}
else
{
mContextFlags
&
=
~
eHasDescriptionDependent
;
}
Relation
rel
=
RelationByType
(
RelationType
:
:
LABELLED_BY
)
;
LocalAccessible
*
relTarget
=
nullptr
;
while
(
(
relTarget
=
rel
.
LocalNext
(
)
)
)
{
if
(
!
relTarget
-
>
HasNameDependent
(
)
)
{
relTarget
-
>
ModifySubtreeContextFlags
(
eHasNameDependent
true
)
;
}
}
rel
=
RelationByType
(
RelationType
:
:
DESCRIBED_BY
)
;
while
(
(
relTarget
=
rel
.
LocalNext
(
)
)
)
{
if
(
!
relTarget
-
>
HasDescriptionDependent
(
)
)
{
relTarget
-
>
ModifySubtreeContextFlags
(
eHasDescriptionDependent
true
)
;
}
}
mContextFlags
|
=
static_cast
<
uint32_t
>
(
(
mParent
-
>
IsAlert
(
)
|
|
mParent
-
>
IsInsideAlert
(
)
)
)
&
eInsideAlert
;
if
(
IsTableCell
(
)
)
{
CachedTableAccessible
:
:
Invalidate
(
this
)
;
}
}
void
LocalAccessible
:
:
UnbindFromParent
(
)
{
if
(
IsTable
(
)
|
|
IsTableCell
(
)
)
{
CachedTableAccessible
:
:
Invalidate
(
this
)
;
}
mParent
=
nullptr
;
mIndexInParent
=
-
1
;
mIndexOfEmbeddedChild
=
-
1
;
delete
mGroupInfo
;
mGroupInfo
=
nullptr
;
mContextFlags
&
=
~
eHasNameDependent
&
~
eInsideAlert
;
}
RootAccessible
*
LocalAccessible
:
:
RootAccessible
(
)
const
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
nsCoreUtils
:
:
GetDocShellFor
(
GetNode
(
)
)
;
NS_ASSERTION
(
docShell
"
No
docshell
for
mContent
"
)
;
if
(
!
docShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
docShell
-
>
GetInProcessRootTreeItem
(
getter_AddRefs
(
root
)
)
;
NS_ASSERTION
(
root
"
No
root
content
tree
item
"
)
;
if
(
!
root
)
{
return
nullptr
;
}
DocAccessible
*
docAcc
=
nsAccUtils
:
:
GetDocAccessibleFor
(
root
)
;
return
docAcc
?
docAcc
-
>
AsRoot
(
)
:
nullptr
;
}
nsIFrame
*
LocalAccessible
:
:
GetFrame
(
)
const
{
return
mContent
?
mContent
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
nsINode
*
LocalAccessible
:
:
GetNode
(
)
const
{
return
mContent
;
}
dom
:
:
Element
*
LocalAccessible
:
:
Elm
(
)
const
{
return
dom
:
:
Element
:
:
FromNodeOrNull
(
mContent
)
;
}
void
LocalAccessible
:
:
Language
(
nsAString
&
aLanguage
)
{
aLanguage
.
Truncate
(
)
;
if
(
!
mDoc
)
return
;
nsCoreUtils
:
:
GetLanguageFor
(
mContent
nullptr
aLanguage
)
;
if
(
aLanguage
.
IsEmpty
(
)
)
{
mDoc
-
>
DocumentNode
(
)
-
>
GetHeaderData
(
nsGkAtoms
:
:
headerContentLanguage
aLanguage
)
;
}
}
bool
LocalAccessible
:
:
InsertChildAt
(
uint32_t
aIndex
LocalAccessible
*
aChild
)
{
if
(
!
aChild
)
return
false
;
if
(
aIndex
=
=
mChildren
.
Length
(
)
)
{
mChildren
.
AppendElement
(
aChild
)
;
}
else
{
mChildren
.
InsertElementAt
(
aIndex
aChild
)
;
MOZ_ASSERT
(
mStateFlags
&
eKidsMutating
"
Illicit
children
change
"
)
;
for
(
uint32_t
idx
=
aIndex
+
1
;
idx
<
mChildren
.
Length
(
)
;
idx
+
+
)
{
mChildren
[
idx
]
-
>
mIndexInParent
=
idx
;
}
}
if
(
aChild
-
>
IsText
(
)
)
{
mStateFlags
|
=
eHasTextKids
;
}
aChild
-
>
BindToParent
(
this
aIndex
)
;
return
true
;
}
bool
LocalAccessible
:
:
RemoveChild
(
LocalAccessible
*
aChild
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aChild
"
No
child
was
given
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aChild
-
>
mParent
"
No
parent
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aChild
-
>
mParent
=
=
this
"
Wrong
parent
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aChild
-
>
mIndexInParent
!
=
-
1
"
Unbound
child
was
given
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
(
mStateFlags
&
eKidsMutating
)
|
|
aChild
-
>
IsDefunct
(
)
|
|
aChild
-
>
IsDoc
(
)
|
|
IsApplication
(
)
"
Illicit
children
change
"
)
;
int32_t
index
=
static_cast
<
uint32_t
>
(
aChild
-
>
mIndexInParent
)
;
if
(
mChildren
.
SafeElementAt
(
index
)
!
=
aChild
)
{
MOZ_ASSERT_UNREACHABLE
(
"
A
wrong
child
index
"
)
;
index
=
mChildren
.
IndexOf
(
aChild
)
;
if
(
index
=
=
-
1
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
child
was
found
"
)
;
return
false
;
}
}
aChild
-
>
UnbindFromParent
(
)
;
mChildren
.
RemoveElementAt
(
index
)
;
for
(
uint32_t
idx
=
index
;
idx
<
mChildren
.
Length
(
)
;
idx
+
+
)
{
mChildren
[
idx
]
-
>
mIndexInParent
=
idx
;
}
return
true
;
}
void
LocalAccessible
:
:
RelocateChild
(
uint32_t
aNewIndex
LocalAccessible
*
aChild
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aChild
"
No
child
was
given
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aChild
-
>
mParent
=
=
this
"
A
child
from
different
subtree
was
given
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aChild
-
>
mIndexInParent
!
=
-
1
"
Unbound
child
was
given
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aChild
-
>
mParent
-
>
LocalChildAt
(
aChild
-
>
mIndexInParent
)
=
=
aChild
"
Wrong
index
in
parent
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
static_cast
<
uint32_t
>
(
aChild
-
>
mIndexInParent
)
!
=
aNewIndex
"
No
move
same
index
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aNewIndex
<
=
mChildren
.
Length
(
)
"
Wrong
new
index
was
given
"
)
;
RefPtr
<
AccHideEvent
>
hideEvent
=
new
AccHideEvent
(
aChild
false
)
;
if
(
mDoc
-
>
Controller
(
)
-
>
QueueMutationEvent
(
hideEvent
)
)
{
aChild
-
>
SetHideEventTarget
(
true
)
;
}
mEmbeddedObjCollector
=
nullptr
;
mChildren
.
RemoveElementAt
(
aChild
-
>
mIndexInParent
)
;
uint32_t
startIdx
=
aNewIndex
endIdx
=
aChild
-
>
mIndexInParent
;
if
(
static_cast
<
uint32_t
>
(
aChild
-
>
mIndexInParent
)
<
aNewIndex
)
{
startIdx
=
aChild
-
>
mIndexInParent
;
if
(
aNewIndex
=
=
mChildren
.
Length
(
)
+
1
)
{
mChildren
.
AppendElement
(
aChild
)
;
endIdx
=
mChildren
.
Length
(
)
-
1
;
}
else
{
mChildren
.
InsertElementAt
(
aNewIndex
-
1
aChild
)
;
endIdx
=
aNewIndex
;
}
}
else
{
mChildren
.
InsertElementAt
(
aNewIndex
aChild
)
;
}
for
(
uint32_t
idx
=
startIdx
;
idx
<
=
endIdx
;
idx
+
+
)
{
mChildren
[
idx
]
-
>
mIndexInParent
=
idx
;
mChildren
[
idx
]
-
>
mIndexOfEmbeddedChild
=
-
1
;
}
for
(
uint32_t
idx
=
0
;
idx
<
mChildren
.
Length
(
)
;
idx
+
+
)
{
mChildren
[
idx
]
-
>
mStateFlags
|
=
eGroupInfoDirty
;
}
RefPtr
<
AccShowEvent
>
showEvent
=
new
AccShowEvent
(
aChild
)
;
DebugOnly
<
bool
>
added
=
mDoc
-
>
Controller
(
)
-
>
QueueMutationEvent
(
showEvent
)
;
MOZ_ASSERT
(
added
)
;
aChild
-
>
SetShowEventTarget
(
true
)
;
}
LocalAccessible
*
LocalAccessible
:
:
LocalChildAt
(
uint32_t
aIndex
)
const
{
LocalAccessible
*
child
=
mChildren
.
SafeElementAt
(
aIndex
nullptr
)
;
if
(
!
child
)
return
nullptr
;
#
ifdef
DEBUG
LocalAccessible
*
realParent
=
child
-
>
mParent
;
NS_ASSERTION
(
!
realParent
|
|
realParent
=
=
this
"
Two
accessibles
have
the
same
first
child
accessible
!
"
)
;
#
endif
return
child
;
}
uint32_t
LocalAccessible
:
:
ChildCount
(
)
const
{
return
mChildren
.
Length
(
)
;
}
int32_t
LocalAccessible
:
:
IndexInParent
(
)
const
{
return
mIndexInParent
;
}
uint32_t
LocalAccessible
:
:
EmbeddedChildCount
(
)
{
if
(
mStateFlags
&
eHasTextKids
)
{
if
(
!
mEmbeddedObjCollector
)
{
mEmbeddedObjCollector
.
reset
(
new
EmbeddedObjCollector
(
this
)
)
;
}
return
mEmbeddedObjCollector
-
>
Count
(
)
;
}
return
ChildCount
(
)
;
}
Accessible
*
LocalAccessible
:
:
EmbeddedChildAt
(
uint32_t
aIndex
)
{
if
(
mStateFlags
&
eHasTextKids
)
{
if
(
!
mEmbeddedObjCollector
)
{
mEmbeddedObjCollector
.
reset
(
new
EmbeddedObjCollector
(
this
)
)
;
}
return
mEmbeddedObjCollector
.
get
(
)
?
mEmbeddedObjCollector
-
>
GetAccessibleAt
(
aIndex
)
:
nullptr
;
}
return
ChildAt
(
aIndex
)
;
}
int32_t
LocalAccessible
:
:
IndexOfEmbeddedChild
(
Accessible
*
aChild
)
{
MOZ_ASSERT
(
aChild
-
>
IsLocal
(
)
)
;
if
(
mStateFlags
&
eHasTextKids
)
{
if
(
!
mEmbeddedObjCollector
)
{
mEmbeddedObjCollector
.
reset
(
new
EmbeddedObjCollector
(
this
)
)
;
}
return
mEmbeddedObjCollector
.
get
(
)
?
mEmbeddedObjCollector
-
>
GetIndexAt
(
aChild
-
>
AsLocal
(
)
)
:
-
1
;
}
return
GetIndexOf
(
aChild
-
>
AsLocal
(
)
)
;
}
bool
LocalAccessible
:
:
IsLink
(
)
const
{
return
mParent
&
&
mParent
-
>
IsHyperText
(
)
&
&
!
IsText
(
)
;
}
void
LocalAccessible
:
:
SelectedItems
(
nsTArray
<
Accessible
*
>
*
aItems
)
{
AccIterator
iter
(
this
filters
:
:
GetSelected
)
;
LocalAccessible
*
selected
=
nullptr
;
while
(
(
selected
=
iter
.
Next
(
)
)
)
aItems
-
>
AppendElement
(
selected
)
;
}
uint32_t
LocalAccessible
:
:
SelectedItemCount
(
)
{
uint32_t
count
=
0
;
AccIterator
iter
(
this
filters
:
:
GetSelected
)
;
LocalAccessible
*
selected
=
nullptr
;
while
(
(
selected
=
iter
.
Next
(
)
)
)
+
+
count
;
return
count
;
}
Accessible
*
LocalAccessible
:
:
GetSelectedItem
(
uint32_t
aIndex
)
{
AccIterator
iter
(
this
filters
:
:
GetSelected
)
;
LocalAccessible
*
selected
=
nullptr
;
uint32_t
index
=
0
;
while
(
(
selected
=
iter
.
Next
(
)
)
&
&
index
<
aIndex
)
index
+
+
;
return
selected
;
}
bool
LocalAccessible
:
:
IsItemSelected
(
uint32_t
aIndex
)
{
uint32_t
index
=
0
;
AccIterator
iter
(
this
filters
:
:
GetSelectable
)
;
LocalAccessible
*
selected
=
nullptr
;
while
(
(
selected
=
iter
.
Next
(
)
)
&
&
index
<
aIndex
)
index
+
+
;
return
selected
&
&
selected
-
>
State
(
)
&
states
:
:
SELECTED
;
}
bool
LocalAccessible
:
:
AddItemToSelection
(
uint32_t
aIndex
)
{
uint32_t
index
=
0
;
AccIterator
iter
(
this
filters
:
:
GetSelectable
)
;
LocalAccessible
*
selected
=
nullptr
;
while
(
(
selected
=
iter
.
Next
(
)
)
&
&
index
<
aIndex
)
index
+
+
;
if
(
selected
)
selected
-
>
SetSelected
(
true
)
;
return
static_cast
<
bool
>
(
selected
)
;
}
bool
LocalAccessible
:
:
RemoveItemFromSelection
(
uint32_t
aIndex
)
{
uint32_t
index
=
0
;
AccIterator
iter
(
this
filters
:
:
GetSelectable
)
;
LocalAccessible
*
selected
=
nullptr
;
while
(
(
selected
=
iter
.
Next
(
)
)
&
&
index
<
aIndex
)
index
+
+
;
if
(
selected
)
selected
-
>
SetSelected
(
false
)
;
return
static_cast
<
bool
>
(
selected
)
;
}
bool
LocalAccessible
:
:
SelectAll
(
)
{
bool
success
=
false
;
LocalAccessible
*
selectable
=
nullptr
;
AccIterator
iter
(
this
filters
:
:
GetSelectable
)
;
while
(
(
selectable
=
iter
.
Next
(
)
)
)
{
success
=
true
;
selectable
-
>
SetSelected
(
true
)
;
}
return
success
;
}
bool
LocalAccessible
:
:
UnselectAll
(
)
{
bool
success
=
false
;
LocalAccessible
*
selected
=
nullptr
;
AccIterator
iter
(
this
filters
:
:
GetSelected
)
;
while
(
(
selected
=
iter
.
Next
(
)
)
)
{
success
=
true
;
selected
-
>
SetSelected
(
false
)
;
}
return
success
;
}
bool
LocalAccessible
:
:
IsWidget
(
)
const
{
return
false
;
}
bool
LocalAccessible
:
:
IsActiveWidget
(
)
const
{
if
(
FocusMgr
(
)
-
>
HasDOMFocus
(
mContent
)
)
return
true
;
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
if
(
roleMapEntry
&
&
roleMapEntry
-
>
Is
(
nsGkAtoms
:
:
combobox
)
)
{
uint32_t
childCount
=
ChildCount
(
)
;
for
(
uint32_t
idx
=
0
;
idx
<
childCount
;
idx
+
+
)
{
LocalAccessible
*
child
=
mChildren
.
ElementAt
(
idx
)
;
if
(
child
-
>
Role
(
)
=
=
roles
:
:
ENTRY
)
{
return
FocusMgr
(
)
-
>
HasDOMFocus
(
child
-
>
GetContent
(
)
)
;
}
}
}
return
false
;
}
bool
LocalAccessible
:
:
AreItemsOperable
(
)
const
{
return
HasOwnContent
(
)
&
&
mContent
-
>
IsElement
(
)
&
&
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
aria_activedescendant
)
;
}
LocalAccessible
*
LocalAccessible
:
:
CurrentItem
(
)
const
{
if
(
HasOwnContent
(
)
&
&
mContent
-
>
IsElement
(
)
)
{
if
(
dom
:
:
Element
*
activeDescendantElm
=
nsCoreUtils
:
:
GetAriaActiveDescendantElement
(
mContent
-
>
AsElement
(
)
)
)
{
if
(
mContent
-
>
IsInclusiveDescendantOf
(
activeDescendantElm
)
)
{
return
nullptr
;
}
DocAccessible
*
document
=
Document
(
)
;
if
(
document
)
return
document
-
>
GetAccessible
(
activeDescendantElm
)
;
}
}
return
nullptr
;
}
void
LocalAccessible
:
:
SetCurrentItem
(
const
LocalAccessible
*
aItem
)
{
}
LocalAccessible
*
LocalAccessible
:
:
ContainerWidget
(
)
const
{
if
(
HasARIARole
(
)
&
&
mContent
-
>
HasID
(
)
)
{
for
(
LocalAccessible
*
parent
=
LocalParent
(
)
;
parent
;
parent
=
parent
-
>
LocalParent
(
)
)
{
nsIContent
*
parentContent
=
parent
-
>
GetContent
(
)
;
if
(
parentContent
&
&
parentContent
-
>
IsElement
(
)
&
&
nsCoreUtils
:
:
GetAriaActiveDescendantElement
(
parentContent
-
>
AsElement
(
)
)
)
{
return
parent
;
}
if
(
parent
-
>
IsDoc
(
)
)
break
;
}
}
return
nullptr
;
}
bool
LocalAccessible
:
:
IsActiveDescendantId
(
LocalAccessible
*
*
aWidget
)
const
{
if
(
!
HasOwnContent
(
)
|
|
!
mContent
-
>
HasID
(
)
)
{
return
false
;
}
dom
:
:
DocumentOrShadowRoot
*
docOrShadowRoot
=
mContent
-
>
GetUncomposedDocOrConnectedShadowRoot
(
)
;
if
(
!
docOrShadowRoot
)
{
return
false
;
}
nsAutoCString
selector
;
selector
.
AppendPrintf
(
"
[
aria
-
activedescendant
=
\
"
%
s
\
"
]
"
NS_ConvertUTF16toUTF8
(
mContent
-
>
GetID
(
)
-
>
GetUTF16String
(
)
)
.
get
(
)
)
;
IgnoredErrorResult
er
;
dom
:
:
Element
*
widgetElm
=
docOrShadowRoot
-
>
AsNode
(
)
.
QuerySelector
(
selector
er
)
;
if
(
!
widgetElm
|
|
er
.
Failed
(
)
)
{
return
false
;
}
if
(
widgetElm
-
>
IsInclusiveDescendantOf
(
mContent
)
)
{
return
false
;
}
LocalAccessible
*
widget
=
mDoc
-
>
GetAccessible
(
widgetElm
)
;
if
(
aWidget
)
{
*
aWidget
=
widget
;
}
return
!
!
widget
;
}
void
LocalAccessible
:
:
Announce
(
const
nsAString
&
aAnnouncement
uint16_t
aPriority
)
{
RefPtr
<
AccAnnouncementEvent
>
event
=
new
AccAnnouncementEvent
(
this
aAnnouncement
aPriority
)
;
nsEventShell
:
:
FireEvent
(
event
)
;
}
void
LocalAccessible
:
:
LastRelease
(
)
{
if
(
mDoc
)
{
Shutdown
(
)
;
NS_ASSERTION
(
!
mDoc
"
A
Shutdown
(
)
impl
forgot
to
call
its
parent
'
s
Shutdown
?
"
)
;
}
delete
this
;
}
LocalAccessible
*
LocalAccessible
:
:
GetSiblingAtOffset
(
int32_t
aOffset
nsresult
*
aError
)
const
{
if
(
!
mParent
|
|
mIndexInParent
=
=
-
1
)
{
if
(
aError
)
*
aError
=
NS_ERROR_UNEXPECTED
;
return
nullptr
;
}
if
(
aError
&
&
mIndexInParent
+
aOffset
>
=
static_cast
<
int32_t
>
(
mParent
-
>
ChildCount
(
)
)
)
{
*
aError
=
NS_OK
;
return
nullptr
;
}
LocalAccessible
*
child
=
mParent
-
>
LocalChildAt
(
mIndexInParent
+
aOffset
)
;
if
(
aError
&
&
!
child
)
*
aError
=
NS_ERROR_UNEXPECTED
;
return
child
;
}
void
LocalAccessible
:
:
ModifySubtreeContextFlags
(
uint32_t
aContextFlags
bool
aAdd
)
{
Pivot
pivot
(
this
)
;
LocalAccInSameDocRule
rule
;
for
(
Accessible
*
anchor
=
this
;
anchor
;
anchor
=
pivot
.
Next
(
anchor
rule
)
)
{
MOZ_ASSERT
(
anchor
-
>
IsLocal
(
)
)
;
LocalAccessible
*
acc
=
anchor
-
>
AsLocal
(
)
;
if
(
aAdd
)
{
acc
-
>
mContextFlags
|
=
aContextFlags
;
}
else
{
acc
-
>
mContextFlags
&
=
~
aContextFlags
;
}
}
}
double
LocalAccessible
:
:
AttrNumericValue
(
nsAtom
*
aAttr
)
const
{
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
if
(
!
roleMapEntry
|
|
roleMapEntry
-
>
valueRule
=
=
eNoValue
)
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
nsAutoString
attrValue
;
if
(
!
mContent
-
>
IsElement
(
)
|
|
!
nsAccUtils
:
:
GetARIAAttr
(
mContent
-
>
AsElement
(
)
aAttr
attrValue
)
)
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
nsresult
error
=
NS_OK
;
double
value
=
attrValue
.
ToDouble
(
&
error
)
;
return
NS_FAILED
(
error
)
?
UnspecifiedNaN
<
double
>
(
)
:
value
;
}
uint32_t
LocalAccessible
:
:
GetActionRule
(
)
const
{
if
(
!
HasOwnContent
(
)
|
|
(
InteractiveState
(
)
&
states
:
:
UNAVAILABLE
)
)
{
return
eNoAction
;
}
if
(
mContent
-
>
IsXULElement
(
)
)
{
if
(
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
popup
)
)
{
return
eClickAction
;
}
}
bool
isOnclick
=
nsCoreUtils
:
:
HasClickListener
(
mContent
)
;
if
(
isOnclick
)
return
eClickAction
;
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
if
(
roleMapEntry
&
&
roleMapEntry
-
>
actionRule
!
=
eNoAction
)
{
return
roleMapEntry
-
>
actionRule
;
}
if
(
nsAccUtils
:
:
HasDefinedARIAToken
(
mContent
nsGkAtoms
:
:
aria_expanded
)
)
{
return
eExpandAction
;
}
return
eNoAction
;
}
AccGroupInfo
*
LocalAccessible
:
:
GetGroupInfo
(
)
const
{
if
(
mGroupInfo
&
&
!
(
mStateFlags
&
eGroupInfoDirty
)
)
{
return
mGroupInfo
;
}
return
nullptr
;
}
AccGroupInfo
*
LocalAccessible
:
:
GetOrCreateGroupInfo
(
)
{
if
(
mGroupInfo
)
{
if
(
mStateFlags
&
eGroupInfoDirty
)
{
mGroupInfo
-
>
Update
(
)
;
mStateFlags
&
=
~
eGroupInfoDirty
;
}
return
mGroupInfo
;
}
mGroupInfo
=
AccGroupInfo
:
:
CreateGroupInfo
(
this
)
;
mStateFlags
&
=
~
eGroupInfoDirty
;
return
mGroupInfo
;
}
void
LocalAccessible
:
:
SendCache
(
uint64_t
aCacheDomain
CacheUpdateType
aUpdateType
)
{
if
(
!
IPCAccessibilityActive
(
)
|
|
!
Document
(
)
)
{
return
;
}
const
uint64_t
domainsToSend
=
nsAccessibilityService
:
:
GetActiveCacheDomains
(
)
&
aCacheDomain
;
if
(
domainsToSend
=
=
CacheDomain
:
:
None
)
{
return
;
}
DocAccessibleChild
*
ipcDoc
=
mDoc
-
>
IPCDoc
(
)
;
if
(
!
ipcDoc
)
{
MOZ_ASSERT
(
IsDoc
(
)
"
Called
on
a
non
-
DocAccessible
but
IPCDoc
is
null
"
)
;
return
;
}
RefPtr
<
AccAttributes
>
fields
=
BundleFieldsForCache
(
domainsToSend
aUpdateType
)
;
if
(
!
fields
-
>
Count
(
)
)
{
return
;
}
nsTArray
<
CacheData
>
data
;
data
.
AppendElement
(
CacheData
(
ID
(
)
fields
)
)
;
ipcDoc
-
>
SendCache
(
aUpdateType
data
)
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
nsAutoCString
updateTypeStr
;
if
(
aUpdateType
=
=
CacheUpdateType
:
:
Initial
)
{
updateTypeStr
=
"
Initial
"
;
}
else
if
(
aUpdateType
=
=
CacheUpdateType
:
:
Update
)
{
updateTypeStr
=
"
Update
"
;
}
else
{
updateTypeStr
=
"
Other
"
;
}
PROFILER_MARKER_TEXT
(
"
LocalAccessible
:
:
SendCache
"
A11Y
{
}
updateTypeStr
)
;
}
}
already_AddRefed
<
AccAttributes
>
LocalAccessible
:
:
BundleFieldsForCache
(
uint64_t
aCacheDomain
CacheUpdateType
aUpdateType
uint64_t
aInitialDomains
)
{
MOZ_ASSERT
(
(
~
aCacheDomain
&
aInitialDomains
)
=
=
CacheDomain
:
:
None
"
Initial
domain
pushes
without
domains
requested
!
"
)
;
RefPtr
<
AccAttributes
>
fields
=
new
AccAttributes
(
)
;
if
(
aUpdateType
=
=
CacheUpdateType
:
:
Initial
)
{
aInitialDomains
=
CacheDomain
:
:
All
;
}
auto
IsInitialPush
=
[
aInitialDomains
]
(
uint64_t
aCacheDomain
)
{
return
(
aCacheDomain
&
aInitialDomains
)
=
=
aCacheDomain
;
}
;
auto
IsUpdatePush
=
[
aInitialDomains
]
(
uint64_t
aCacheDomain
)
{
return
(
aCacheDomain
&
aInitialDomains
)
=
=
CacheDomain
:
:
None
;
}
;
if
(
aCacheDomain
&
CacheDomain
:
:
NameAndDescription
&
&
!
IsText
(
)
)
{
nsString
name
;
int32_t
nameFlag
=
Name
(
name
)
;
if
(
nameFlag
!
=
eNameOK
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
NameValueFlag
nameFlag
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
NameAndDescription
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
NameValueFlag
DeleteEntry
(
)
)
;
}
if
(
IsTextField
(
)
)
{
MOZ_ASSERT
(
mContent
)
;
nsString
placeholder
;
if
(
Elm
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
placeholder
placeholder
)
&
&
name
!
=
placeholder
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
HTMLPlaceholder
std
:
:
move
(
placeholder
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
NameAndDescription
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
HTMLPlaceholder
DeleteEntry
(
)
)
;
}
}
if
(
!
name
.
IsEmpty
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
Name
std
:
:
move
(
name
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
NameAndDescription
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
Name
DeleteEntry
(
)
)
;
}
nsString
description
;
Description
(
description
)
;
if
(
!
description
.
IsEmpty
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
Description
std
:
:
move
(
description
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
NameAndDescription
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
Description
DeleteEntry
(
)
)
;
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
Value
)
{
bool
cacheValueText
=
false
;
if
(
HasNumericValue
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
NumericValue
CurValue
(
)
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
MaxValue
MaxValue
(
)
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
MinValue
MinValue
(
)
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
Step
Step
(
)
)
;
cacheValueText
=
NativeHasNumericValue
(
)
|
|
(
mContent
-
>
IsElement
(
)
&
&
nsAccUtils
:
:
HasARIAAttr
(
mContent
-
>
AsElement
(
)
nsGkAtoms
:
:
aria_valuetext
)
)
;
}
else
{
cacheValueText
=
IsTextField
(
)
|
|
IsHTMLLink
(
)
;
}
if
(
cacheValueText
)
{
nsString
value
;
Value
(
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
TextValue
std
:
:
move
(
value
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Value
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
TextValue
DeleteEntry
(
)
)
;
}
}
if
(
IsImage
(
)
)
{
MOZ_ASSERT
(
mContent
"
Image
must
have
mContent
"
)
;
nsString
src
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
src
src
)
;
if
(
!
src
.
IsEmpty
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
SrcURL
std
:
:
move
(
src
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Value
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
SrcURL
DeleteEntry
(
)
)
;
}
}
if
(
TagName
(
)
=
=
nsGkAtoms
:
:
meter
)
{
HTMLMeterAccessible
*
meter
=
static_cast
<
HTMLMeterAccessible
*
>
(
this
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
ValueRegion
meter
-
>
ValueRegion
(
)
)
;
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
Viewport
&
&
IsDoc
(
)
)
{
DocAccessible
*
doc
=
AsDoc
(
)
;
PresShell
*
presShell
=
doc
-
>
PresShellPtr
(
)
;
if
(
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
)
{
nsTArray
<
nsIFrame
*
>
frames
;
ScrollContainerFrame
*
sf
=
presShell
-
>
GetRootScrollContainerFrame
(
)
;
nsRect
scrollPort
=
sf
?
sf
-
>
GetScrollPortRect
(
)
:
rootFrame
-
>
GetRect
(
)
;
nsLayoutUtils
:
:
GetFramesForArea
(
RelativeTo
{
rootFrame
}
scrollPort
frames
{
{
nsLayoutUtils
:
:
FrameForPointOption
:
:
IgnorePaintSuppression
nsLayoutUtils
:
:
FrameForPointOption
:
:
IgnoreCrossDoc
}
}
)
;
nsTHashSet
<
LocalAccessible
*
>
inViewAccs
;
nsTArray
<
uint64_t
>
viewportCache
(
frames
.
Length
(
)
)
;
LocalAccessible
*
prevParentRow
=
nullptr
;
for
(
nsIFrame
*
frame
:
frames
)
{
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
if
(
!
content
)
{
continue
;
}
LocalAccessible
*
acc
=
doc
-
>
GetAccessible
(
content
)
;
if
(
!
acc
|
|
acc
=
=
mDoc
)
{
continue
;
}
if
(
acc
-
>
IsTextLeaf
(
)
&
&
nsAccUtils
:
:
MustPrune
(
acc
-
>
LocalParent
(
)
)
)
{
acc
=
acc
-
>
LocalParent
(
)
;
}
if
(
acc
-
>
IsTableCell
(
)
)
{
LocalAccessible
*
parent
=
acc
-
>
LocalParent
(
)
;
if
(
parent
&
&
parent
-
>
IsTableRow
(
)
&
&
parent
!
=
prevParentRow
)
{
if
(
prevParentRow
&
&
inViewAccs
.
EnsureInserted
(
prevParentRow
)
)
{
viewportCache
.
AppendElement
(
prevParentRow
-
>
ID
(
)
)
;
}
prevParentRow
=
parent
;
}
}
else
if
(
acc
-
>
IsTable
(
)
)
{
if
(
prevParentRow
&
&
inViewAccs
.
EnsureInserted
(
prevParentRow
)
)
{
viewportCache
.
AppendElement
(
prevParentRow
-
>
ID
(
)
)
;
}
prevParentRow
=
nullptr
;
}
else
if
(
acc
-
>
IsImageMap
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
acc
-
>
ChildCount
(
)
;
i
+
+
)
{
LocalAccessible
*
child
=
acc
-
>
LocalChildAt
(
i
)
;
MOZ_ASSERT
(
child
)
;
if
(
inViewAccs
.
EnsureInserted
(
child
)
)
{
MOZ_ASSERT
(
!
child
-
>
IsDoc
(
)
)
;
viewportCache
.
AppendElement
(
child
-
>
ID
(
)
)
;
}
}
}
else
if
(
acc
-
>
IsHTMLCombobox
(
)
)
{
HTMLComboboxAccessible
*
combobox
=
static_cast
<
HTMLComboboxAccessible
*
>
(
acc
)
;
HTMLComboboxListAccessible
*
list
=
combobox
-
>
List
(
)
;
LocalAccessible
*
currItem
=
combobox
-
>
SelectedOption
(
)
;
if
(
currItem
&
&
inViewAccs
.
EnsureInserted
(
currItem
)
)
{
viewportCache
.
AppendElement
(
currItem
-
>
ID
(
)
)
;
}
if
(
list
&
&
inViewAccs
.
EnsureInserted
(
list
)
)
{
viewportCache
.
AppendElement
(
list
-
>
ID
(
)
)
;
}
}
if
(
inViewAccs
.
EnsureInserted
(
acc
)
)
{
MOZ_ASSERT
(
!
acc
-
>
IsDoc
(
)
)
;
viewportCache
.
AppendElement
(
acc
-
>
ID
(
)
)
;
}
}
if
(
viewportCache
.
Length
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
Viewport
std
:
:
move
(
viewportCache
)
)
;
}
}
}
bool
boundsChanged
=
false
;
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
aCacheDomain
&
CacheDomain
:
:
Bounds
)
{
nsRect
newBoundsRect
=
ParentRelativeBounds
(
)
;
MOZ_ASSERT
(
IsInitialPush
(
CacheDomain
:
:
Bounds
)
|
|
mBounds
.
isSome
(
)
"
Incremental
cache
push
but
mBounds
is
not
set
!
"
)
;
if
(
OuterDocAccessible
*
doc
=
AsOuterDoc
(
)
)
{
if
(
nsIFrame
*
docFrame
=
doc
-
>
GetFrame
(
)
)
{
const
nsMargin
&
newOffset
=
docFrame
-
>
GetUsedBorderAndPadding
(
)
;
Maybe
<
nsMargin
>
currOffset
=
doc
-
>
GetCrossDocOffset
(
)
;
if
(
!
currOffset
|
|
*
currOffset
!
=
newOffset
)
{
doc
-
>
SetCrossDocOffset
(
newOffset
)
;
nsTArray
<
int32_t
>
offsetArray
(
2
)
;
offsetArray
.
AppendElement
(
newOffset
.
Side
(
eSideLeft
)
)
;
offsetArray
.
AppendElement
(
newOffset
.
Side
(
eSideTop
)
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
CrossDocOffset
std
:
:
move
(
offsetArray
)
)
;
}
}
}
boundsChanged
=
IsInitialPush
(
CacheDomain
:
:
Bounds
)
|
|
!
newBoundsRect
.
IsEqualEdges
(
mBounds
.
value
(
)
)
;
if
(
boundsChanged
)
{
mBounds
=
Some
(
newBoundsRect
)
;
nsTArray
<
int32_t
>
boundsArray
(
4
)
;
boundsArray
.
AppendElement
(
newBoundsRect
.
x
)
;
boundsArray
.
AppendElement
(
newBoundsRect
.
y
)
;
boundsArray
.
AppendElement
(
newBoundsRect
.
width
)
;
boundsArray
.
AppendElement
(
newBoundsRect
.
height
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
ParentRelativeBounds
std
:
:
move
(
boundsArray
)
)
;
}
if
(
frame
&
&
frame
-
>
ScrollableOverflowRect
(
)
.
IsEmpty
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
IsClipped
true
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Bounds
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
IsClipped
DeleteEntry
(
)
)
;
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
Text
)
{
if
(
!
HasChildren
(
)
)
{
if
(
IsText
(
)
)
{
nsString
text
;
AppendTextTo
(
text
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
Text
std
:
:
move
(
text
)
)
;
TextLeafPoint
point
(
this
0
)
;
RefPtr
<
AccAttributes
>
attrs
=
point
.
GetTextAttributesLocalAcc
(
false
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
TextAttributes
std
:
:
move
(
attrs
)
)
;
}
}
if
(
HyperTextAccessible
*
ht
=
AsHyperText
(
)
)
{
RefPtr
<
AccAttributes
>
attrs
=
ht
-
>
DefaultTextAttributes
(
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
TextAttributes
std
:
:
move
(
attrs
)
)
;
}
else
if
(
!
IsText
(
)
)
{
nsString
language
;
Language
(
language
)
;
if
(
!
language
.
IsEmpty
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
Language
std
:
:
move
(
language
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Text
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
Language
DeleteEntry
(
)
)
;
}
}
}
if
(
aCacheDomain
&
(
CacheDomain
:
:
TextOffsetAttributes
|
CacheDomain
:
:
Text
)
&
&
IsTextLeaf
(
)
)
{
auto
offsetAttrs
=
TextLeafPoint
:
:
GetTextOffsetAttributes
(
this
)
;
if
(
!
offsetAttrs
.
IsEmpty
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
TextOffsetAttributes
std
:
:
move
(
offsetAttrs
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
TextOffsetAttributes
)
|
|
IsUpdatePush
(
CacheDomain
:
:
Text
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
TextOffsetAttributes
DeleteEntry
(
)
)
;
}
}
if
(
aCacheDomain
&
(
CacheDomain
:
:
TextBounds
)
&
&
!
HasChildren
(
)
)
{
TextLeafPoint
lineStart
=
TextLeafPoint
(
this
0
)
.
FindNextLineStartSameLocalAcc
(
true
)
;
int32_t
lineStartOffset
=
lineStart
?
lineStart
.
mOffset
:
-
1
;
if
(
IsInitialPush
(
CacheDomain
:
:
TextBounds
)
|
|
aCacheDomain
&
CacheDomain
:
:
Text
|
|
boundsChanged
|
|
mFirstLineStart
!
=
lineStartOffset
)
{
mFirstLineStart
=
lineStartOffset
;
nsTArray
<
int32_t
>
lineStarts
;
for
(
;
lineStart
;
lineStart
=
lineStart
.
FindNextLineStartSameLocalAcc
(
false
)
)
{
lineStarts
.
AppendElement
(
lineStart
.
mOffset
)
;
}
if
(
!
lineStarts
.
IsEmpty
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
TextLineStarts
std
:
:
move
(
lineStarts
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
TextBounds
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
TextLineStarts
DeleteEntry
(
)
)
;
}
if
(
frame
&
&
frame
-
>
IsTextFrame
(
)
)
{
if
(
nsTextFrame
*
currTextFrame
=
do_QueryFrame
(
frame
)
)
{
nsTArray
<
int32_t
>
charData
(
nsAccUtils
:
:
TextLength
(
this
)
*
kNumbersInRect
)
;
nsRect
accOffset
=
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
frame
frame
)
;
while
(
currTextFrame
)
{
nsPoint
contOffset
=
currTextFrame
-
>
GetOffsetTo
(
frame
)
;
contOffset
-
=
accOffset
.
TopLeft
(
)
;
int32_t
length
=
currTextFrame
-
>
GetContentLength
(
)
;
nsTArray
<
nsRect
>
charBounds
(
length
)
;
currTextFrame
-
>
GetCharacterRectsInRange
(
currTextFrame
-
>
GetContentOffset
(
)
length
charBounds
)
;
for
(
nsRect
&
charRect
:
charBounds
)
{
if
(
charRect
.
width
=
=
0
&
&
!
currTextFrame
-
>
StyleText
(
)
-
>
WhiteSpaceIsSignificant
(
)
)
{
const
char16_t
contentChar
=
mContent
-
>
GetText
(
)
-
>
CharAt
(
charData
.
Length
(
)
/
kNumbersInRect
)
;
if
(
contentChar
=
=
u
'
'
|
|
contentChar
=
=
u
'
\
t
'
|
|
contentChar
=
=
u
'
\
n
'
)
{
continue
;
}
}
charRect
.
MoveBy
(
contOffset
)
;
charData
.
AppendElement
(
charRect
.
x
)
;
charData
.
AppendElement
(
charRect
.
y
)
;
charData
.
AppendElement
(
charRect
.
width
)
;
charData
.
AppendElement
(
charRect
.
height
)
;
}
currTextFrame
=
currTextFrame
-
>
GetNextContinuation
(
)
;
}
if
(
charData
.
Length
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
TextBounds
std
:
:
move
(
charData
)
)
;
}
}
}
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
TransformMatrix
)
{
bool
transformed
=
false
;
if
(
frame
&
&
frame
-
>
IsTransformed
(
)
)
{
gfx
:
:
Matrix4x4
mtx
=
nsDisplayTransform
:
:
GetResultingTransformMatrix
(
frame
nsPoint
(
0
0
)
AppUnitsPerCSSPixel
(
)
nsDisplayTransform
:
:
INCLUDE_PERSPECTIVE
|
nsDisplayTransform
:
:
OFFSET_BY_ORIGIN
)
;
transformed
=
!
mtx
.
IsIdentity
(
)
;
if
(
transformed
)
{
UniquePtr
<
gfx
:
:
Matrix4x4
>
ptr
=
MakeUnique
<
gfx
:
:
Matrix4x4
>
(
mtx
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
TransformMatrix
std
:
:
move
(
ptr
)
)
;
}
}
if
(
!
transformed
&
&
IsUpdatePush
(
CacheDomain
:
:
TransformMatrix
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
TransformMatrix
DeleteEntry
(
)
)
;
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
ScrollPosition
&
&
frame
)
{
const
auto
[
scrollPosition
scrollRange
]
=
mDoc
-
>
ComputeScrollData
(
this
)
;
if
(
scrollRange
.
width
|
|
scrollRange
.
height
)
{
nsTArray
<
int32_t
>
positionArr
(
2
)
;
positionArr
.
AppendElement
(
scrollPosition
.
x
)
;
positionArr
.
AppendElement
(
scrollPosition
.
y
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
ScrollPosition
std
:
:
move
(
positionArr
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
ScrollPosition
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
ScrollPosition
DeleteEntry
(
)
)
;
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
DOMNodeIDAndClass
&
&
mContent
)
{
nsAtom
*
id
=
mContent
-
>
GetID
(
)
;
if
(
id
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
DOMNodeID
id
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
DOMNodeIDAndClass
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
DOMNodeID
DeleteEntry
(
)
)
;
}
nsString
className
;
DOMNodeClass
(
className
)
;
if
(
!
className
.
IsEmpty
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
DOMNodeClass
std
:
:
move
(
className
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
DOMNodeIDAndClass
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
DOMNodeClass
DeleteEntry
(
)
)
;
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
State
)
{
if
(
IsInitialPush
(
CacheDomain
:
:
State
)
)
{
uint64_t
state
=
State
(
)
;
state
&
=
~
kRemoteCalculatedStates
;
fields
-
>
SetAttribute
(
CacheKey
:
:
State
state
)
;
}
if
(
auto
ariaSelected
=
ARIASelected
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
ARIASelected
*
ariaSelected
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
State
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
ARIASelected
DeleteEntry
(
)
)
;
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
GroupInfo
&
&
mContent
)
{
for
(
nsAtom
*
attr
:
{
nsGkAtoms
:
:
aria_level
nsGkAtoms
:
:
aria_setsize
nsGkAtoms
:
:
aria_posinset
}
)
{
int32_t
value
=
0
;
if
(
nsCoreUtils
:
:
GetUIntAttr
(
mContent
attr
&
value
)
)
{
fields
-
>
SetAttribute
(
attr
value
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
GroupInfo
)
)
{
fields
-
>
SetAttribute
(
attr
DeleteEntry
(
)
)
;
}
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
Actions
)
{
if
(
HasPrimaryAction
(
)
)
{
nsAutoString
actionName
;
ActionNameAt
(
0
actionName
)
;
RefPtr
<
nsAtom
>
actionAtom
=
NS_Atomize
(
actionName
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
PrimaryAction
actionAtom
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Actions
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
PrimaryAction
DeleteEntry
(
)
)
;
}
if
(
ImageAccessible
*
imgAcc
=
AsImage
(
)
)
{
if
(
imgAcc
-
>
HasLongDesc
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
HasLongdesc
true
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Actions
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
HasLongdesc
DeleteEntry
(
)
)
;
}
}
KeyBinding
accessKey
=
AccessKey
(
)
;
if
(
!
accessKey
.
IsEmpty
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
AccessKey
accessKey
.
Serialize
(
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Actions
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
AccessKey
DeleteEntry
(
)
)
;
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
Style
)
{
if
(
RefPtr
<
nsAtom
>
display
=
DisplayStyle
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
CSSDisplay
display
)
;
}
float
opacity
=
Opacity
(
)
;
if
(
opacity
!
=
1
.
0f
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
Opacity
opacity
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Style
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
Opacity
DeleteEntry
(
)
)
;
}
if
(
frame
&
&
frame
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Fixed
&
&
nsLayoutUtils
:
:
IsReallyFixedPos
(
frame
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
CssPosition
nsGkAtoms
:
:
fixed
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Style
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
CssPosition
DeleteEntry
(
)
)
;
}
if
(
frame
)
{
nsAutoCString
overflow
;
frame
-
>
Style
(
)
-
>
GetComputedPropertyValue
(
eCSSProperty_overflow
overflow
)
;
RefPtr
<
nsAtom
>
overflowAtom
=
NS_Atomize
(
overflow
)
;
if
(
overflowAtom
=
=
nsGkAtoms
:
:
hidden
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
CSSOverflow
nsGkAtoms
:
:
hidden
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Style
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
CSSOverflow
DeleteEntry
(
)
)
;
}
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
Table
)
{
if
(
auto
*
table
=
HTMLTableAccessible
:
:
GetFrom
(
this
)
)
{
if
(
table
-
>
IsProbablyLayoutTable
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
TableLayoutGuess
true
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Table
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
TableLayoutGuess
DeleteEntry
(
)
)
;
}
}
else
if
(
auto
*
cell
=
HTMLTableCellAccessible
:
:
GetFrom
(
this
)
)
{
int32_t
value
=
static_cast
<
int32_t
>
(
cell
-
>
RowExtent
(
)
)
;
MOZ_ASSERT
(
value
>
0
)
;
if
(
value
>
1
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
RowSpan
value
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Table
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
RowSpan
DeleteEntry
(
)
)
;
}
value
=
static_cast
<
int32_t
>
(
cell
-
>
ColExtent
(
)
)
;
MOZ_ASSERT
(
value
>
0
)
;
if
(
value
>
1
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
ColSpan
value
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Table
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
ColSpan
DeleteEntry
(
)
)
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
headers
)
)
{
nsTArray
<
uint64_t
>
headers
;
AssociatedElementsIterator
iter
(
mDoc
mContent
nsGkAtoms
:
:
headers
)
;
while
(
LocalAccessible
*
cell
=
iter
.
Next
(
)
)
{
if
(
cell
-
>
IsTableCell
(
)
)
{
headers
.
AppendElement
(
cell
-
>
ID
(
)
)
;
}
}
fields
-
>
SetAttribute
(
CacheKey
:
:
CellHeaders
std
:
:
move
(
headers
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Table
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
CellHeaders
DeleteEntry
(
)
)
;
}
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
ARIA
&
&
mContent
&
&
mContent
-
>
IsElement
(
)
)
{
RefPtr
<
AccAttributes
>
ariaAttrs
;
aria
:
:
AttrIterator
attrIt
(
mContent
)
;
while
(
attrIt
.
Next
(
)
)
{
if
(
!
ariaAttrs
)
{
ariaAttrs
=
new
AccAttributes
(
)
;
}
attrIt
.
ExposeAttr
(
ariaAttrs
)
;
}
if
(
ariaAttrs
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
ARIAAttributes
std
:
:
move
(
ariaAttrs
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
ARIA
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
ARIAAttributes
DeleteEntry
(
)
)
;
}
}
if
(
aCacheDomain
&
CacheDomain
:
:
Relations
&
&
mContent
)
{
if
(
IsHTMLRadioButton
(
)
|
|
(
mContent
-
>
IsElement
(
)
&
&
mContent
-
>
AsElement
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
)
)
{
nsString
name
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
name
name
)
;
if
(
!
name
.
IsEmpty
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
DOMName
std
:
:
move
(
name
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Relations
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
DOMName
DeleteEntry
(
)
)
;
}
}
for
(
auto
const
&
data
:
kRelationTypeAtoms
)
{
nsTArray
<
uint64_t
>
ids
;
nsStaticAtom
*
const
relAtom
=
data
.
mAtom
;
Relation
rel
;
if
(
data
.
mType
=
=
RelationType
:
:
LABEL_FOR
)
{
if
(
dom
:
:
HTMLLabelElement
*
labelEl
=
dom
:
:
HTMLLabelElement
:
:
FromNode
(
mContent
)
)
{
rel
.
AppendTarget
(
mDoc
labelEl
-
>
GetControl
(
)
)
;
}
}
else
if
(
data
.
mType
=
=
RelationType
:
:
DETAILS
)
{
rel
=
RelationByType
(
RelationType
:
:
DETAILS
)
;
}
else
{
rel
.
AppendIter
(
new
AssociatedElementsIterator
(
mDoc
mContent
relAtom
)
)
;
}
while
(
LocalAccessible
*
acc
=
rel
.
LocalNext
(
)
)
{
ids
.
AppendElement
(
acc
-
>
ID
(
)
)
;
}
if
(
ids
.
Length
(
)
)
{
fields
-
>
SetAttribute
(
relAtom
std
:
:
move
(
ids
)
)
;
}
else
if
(
IsUpdatePush
(
CacheDomain
:
:
Relations
)
)
{
fields
-
>
SetAttribute
(
relAtom
DeleteEntry
(
)
)
;
}
}
}
#
if
defined
(
XP_WIN
)
if
(
aCacheDomain
&
CacheDomain
:
:
InnerHTML
&
&
HasOwnContent
(
)
&
&
mContent
-
>
IsMathMLElement
(
nsGkAtoms
:
:
math
)
)
{
nsString
innerHTML
;
mContent
-
>
AsElement
(
)
-
>
GetInnerHTML
(
innerHTML
IgnoreErrors
(
)
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
InnerHTML
std
:
:
move
(
innerHTML
)
)
;
}
#
endif
if
(
aUpdateType
=
=
CacheUpdateType
:
:
Initial
)
{
if
(
mContent
&
&
mContent
-
>
IsElement
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
TagName
mContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
dom
:
:
Element
*
el
=
mContent
-
>
AsElement
(
)
;
if
(
IsTextField
(
)
|
|
IsDateTimeField
(
)
)
{
if
(
const
nsAttrValue
*
attr
=
el
-
>
GetParsedAttr
(
nsGkAtoms
:
:
type
)
)
{
RefPtr
<
nsAtom
>
inputType
=
attr
-
>
GetAsAtom
(
)
;
if
(
inputType
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
InputType
inputType
)
;
}
}
}
if
(
const
nsRoleMapEntry
*
roleMap
=
ARIARoleMap
(
)
)
{
if
(
!
nsAccUtils
:
:
ARIAAttrValueIs
(
el
nsGkAtoms
:
:
role
roleMap
-
>
roleAtom
eIgnoreCase
)
)
{
nsAutoString
role
;
nsAccUtils
:
:
GetARIAAttr
(
el
nsGkAtoms
:
:
role
role
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
ARIARole
std
:
:
move
(
role
)
)
;
}
}
if
(
auto
*
htmlEl
=
nsGenericHTMLElement
:
:
FromNode
(
mContent
)
)
{
nsAutoString
popover
;
htmlEl
-
>
GetPopover
(
popover
)
;
if
(
!
popover
.
IsEmpty
(
)
)
{
fields
-
>
SetAttribute
(
CacheKey
:
:
PopupType
RefPtr
{
NS_Atomize
(
popover
)
}
)
;
}
}
}
if
(
frame
)
{
mOldComputedStyle
=
frame
-
>
Style
(
)
;
if
(
frame
-
>
IsTransformed
(
)
)
{
mStateFlags
|
=
eOldFrameHasValidTransformStyle
;
}
else
{
mStateFlags
&
=
~
eOldFrameHasValidTransformStyle
;
}
}
if
(
IsDoc
(
)
)
{
if
(
PresShell
*
presShell
=
AsDoc
(
)
-
>
PresShellPtr
(
)
)
{
float
resolution
=
presShell
-
>
GetResolution
(
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
Resolution
resolution
)
;
int32_t
appUnitsPerDevPixel
=
presShell
-
>
GetPresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
AppUnitsPerDevPixel
appUnitsPerDevPixel
)
;
}
nsString
mimeType
;
AsDoc
(
)
-
>
MimeType
(
mimeType
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
MimeType
std
:
:
move
(
mimeType
)
)
;
}
}
if
(
(
aCacheDomain
&
(
CacheDomain
:
:
Text
|
CacheDomain
:
:
ScrollPosition
)
|
|
boundsChanged
)
&
&
mDoc
)
{
mDoc
-
>
SetViewportCacheDirty
(
true
)
;
}
return
fields
.
forget
(
)
;
}
void
LocalAccessible
:
:
MaybeQueueCacheUpdateForStyleChanges
(
)
{
if
(
!
IPCAccessibilityActive
(
)
|
|
!
mOldComputedStyle
)
{
return
;
}
if
(
nsIFrame
*
frame
=
GetFrame
(
)
)
{
const
ComputedStyle
*
newStyle
=
frame
-
>
Style
(
)
;
nsAutoCString
oldOverflow
newOverflow
;
mOldComputedStyle
-
>
GetComputedPropertyValue
(
eCSSProperty_overflow
oldOverflow
)
;
newStyle
-
>
GetComputedPropertyValue
(
eCSSProperty_overflow
newOverflow
)
;
if
(
oldOverflow
!
=
newOverflow
)
{
if
(
oldOverflow
.
Equals
(
"
hidden
"
_ns
)
|
|
newOverflow
.
Equals
(
"
hidden
"
_ns
)
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Style
)
;
}
if
(
oldOverflow
.
Equals
(
"
auto
"
_ns
)
|
|
newOverflow
.
Equals
(
"
auto
"
_ns
)
|
|
oldOverflow
.
Equals
(
"
scroll
"
_ns
)
|
|
newOverflow
.
Equals
(
"
scroll
"
_ns
)
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
ScrollPosition
)
;
}
}
nsAutoCString
oldDisplay
newDisplay
;
mOldComputedStyle
-
>
GetComputedPropertyValue
(
eCSSProperty_display
oldDisplay
)
;
newStyle
-
>
GetComputedPropertyValue
(
eCSSProperty_display
newDisplay
)
;
nsAutoCString
oldOpacity
newOpacity
;
mOldComputedStyle
-
>
GetComputedPropertyValue
(
eCSSProperty_opacity
oldOpacity
)
;
newStyle
-
>
GetComputedPropertyValue
(
eCSSProperty_opacity
newOpacity
)
;
if
(
oldDisplay
!
=
newDisplay
|
|
oldOpacity
!
=
newOpacity
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Style
)
;
}
nsAutoCString
oldPosition
newPosition
;
mOldComputedStyle
-
>
GetComputedPropertyValue
(
eCSSProperty_position
oldPosition
)
;
newStyle
-
>
GetComputedPropertyValue
(
eCSSProperty_position
newPosition
)
;
if
(
oldPosition
!
=
newPosition
)
{
RefPtr
<
nsAtom
>
oldAtom
=
NS_Atomize
(
oldPosition
)
;
RefPtr
<
nsAtom
>
newAtom
=
NS_Atomize
(
newPosition
)
;
if
(
oldAtom
=
=
nsGkAtoms
:
:
fixed
|
|
newAtom
=
=
nsGkAtoms
:
:
fixed
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Style
)
;
}
}
bool
newHasValidTransformStyle
=
newStyle
-
>
StyleDisplay
(
)
-
>
HasTransform
(
frame
)
;
bool
oldHasValidTransformStyle
=
(
mStateFlags
&
eOldFrameHasValidTransformStyle
)
!
=
0
;
bool
sendTransformUpdate
=
newHasValidTransformStyle
|
|
oldHasValidTransformStyle
;
if
(
newHasValidTransformStyle
&
&
oldHasValidTransformStyle
)
{
nsChangeHint
transformHint
=
newStyle
-
>
StyleDisplay
(
)
-
>
CalcTransformPropertyDifference
(
*
mOldComputedStyle
-
>
StyleDisplay
(
)
)
;
sendTransformUpdate
=
!
!
transformHint
;
}
if
(
sendTransformUpdate
)
{
mDoc
-
>
SetViewportCacheDirty
(
true
)
;
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
TransformMatrix
)
;
}
mOldComputedStyle
=
newStyle
;
if
(
newHasValidTransformStyle
)
{
mStateFlags
|
=
eOldFrameHasValidTransformStyle
;
}
else
{
mStateFlags
&
=
~
eOldFrameHasValidTransformStyle
;
}
}
}
nsAtom
*
LocalAccessible
:
:
TagName
(
)
const
{
return
mContent
&
&
mContent
-
>
IsElement
(
)
?
mContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
:
nullptr
;
}
already_AddRefed
<
nsAtom
>
LocalAccessible
:
:
InputType
(
)
const
{
if
(
!
IsTextField
(
)
&
&
!
IsDateTimeField
(
)
)
{
return
nullptr
;
}
dom
:
:
Element
*
el
=
mContent
-
>
AsElement
(
)
;
if
(
const
nsAttrValue
*
attr
=
el
-
>
GetParsedAttr
(
nsGkAtoms
:
:
type
)
)
{
RefPtr
<
nsAtom
>
inputType
=
attr
-
>
GetAsAtom
(
)
;
return
inputType
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsAtom
>
LocalAccessible
:
:
DisplayStyle
(
)
const
{
dom
:
:
Element
*
elm
=
Elm
(
)
;
if
(
!
elm
)
{
return
nullptr
;
}
if
(
elm
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
{
return
nullptr
;
}
static
const
dom
:
:
Element
:
:
AttrValuesArray
presentationRoles
[
]
=
{
nsGkAtoms
:
:
none
nsGkAtoms
:
:
presentation
nullptr
}
;
if
(
nsAccUtils
:
:
FindARIAAttrValueIn
(
elm
nsGkAtoms
:
:
role
presentationRoles
eIgnoreCase
)
!
=
AttrArray
:
:
ATTR_MISSING
&
&
IsGeneric
(
)
)
{
return
nullptr
;
}
RefPtr
<
const
ComputedStyle
>
style
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
elm
)
;
if
(
!
style
)
{
return
nullptr
;
}
nsAutoCString
value
;
style
-
>
GetComputedPropertyValue
(
eCSSProperty_display
value
)
;
return
NS_Atomize
(
value
)
;
}
float
LocalAccessible
:
:
Opacity
(
)
const
{
if
(
nsIFrame
*
frame
=
GetFrame
(
)
)
{
return
frame
-
>
StyleEffects
(
)
-
>
mOpacity
;
}
return
1
.
0f
;
}
void
LocalAccessible
:
:
DOMNodeID
(
nsString
&
aID
)
const
{
aID
.
Truncate
(
)
;
if
(
mContent
)
{
if
(
nsAtom
*
id
=
mContent
-
>
GetID
(
)
)
{
id
-
>
ToString
(
aID
)
;
}
}
}
void
LocalAccessible
:
:
DOMNodeClass
(
nsString
&
aClass
)
const
{
aClass
.
Truncate
(
)
;
if
(
auto
*
el
=
dom
:
:
Element
:
:
FromNodeOrNull
(
mContent
)
)
{
el
-
>
GetClassName
(
aClass
)
;
}
}
void
LocalAccessible
:
:
LiveRegionAttributes
(
nsAString
*
aLive
nsAString
*
aRelevant
Maybe
<
bool
>
*
aAtomic
nsAString
*
aBusy
)
const
{
dom
:
:
Element
*
el
=
Elm
(
)
;
if
(
!
el
)
{
return
;
}
if
(
aLive
)
{
nsAccUtils
:
:
GetARIAAttr
(
el
nsGkAtoms
:
:
aria_live
*
aLive
)
;
}
if
(
aRelevant
)
{
nsAccUtils
:
:
GetARIAAttr
(
el
nsGkAtoms
:
:
aria_relevant
*
aRelevant
)
;
}
if
(
aAtomic
)
{
if
(
nsAccUtils
:
:
ARIAAttrValueIs
(
el
nsGkAtoms
:
:
aria_atomic
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
*
aAtomic
=
Some
(
true
)
;
}
}
if
(
aBusy
)
{
nsAccUtils
:
:
GetARIAAttr
(
el
nsGkAtoms
:
:
aria_busy
*
aBusy
)
;
}
}
Maybe
<
bool
>
LocalAccessible
:
:
ARIASelected
(
)
const
{
if
(
dom
:
:
Element
*
el
=
Elm
(
)
)
{
nsStaticAtom
*
atom
=
nsAccUtils
:
:
NormalizeARIAToken
(
el
nsGkAtoms
:
:
aria_selected
)
;
if
(
atom
=
=
nsGkAtoms
:
:
_true
)
{
return
Some
(
true
)
;
}
if
(
atom
=
=
nsGkAtoms
:
:
_false
)
{
return
Some
(
false
)
;
}
}
return
Nothing
(
)
;
}
void
LocalAccessible
:
:
StaticAsserts
(
)
const
{
static_assert
(
eLastStateFlag
<
=
(
1
<
<
kStateFlagsBits
)
-
1
"
LocalAccessible
:
:
mStateFlags
was
oversized
by
eLastStateFlag
!
"
)
;
static_assert
(
eLastContextFlag
<
=
(
1
<
<
kContextFlagsBits
)
-
1
"
LocalAccessible
:
:
mContextFlags
was
oversized
by
eLastContextFlag
!
"
)
;
}
TableAccessible
*
LocalAccessible
:
:
AsTable
(
)
{
if
(
IsTable
(
)
&
&
!
mContent
-
>
IsXULElement
(
)
)
{
return
CachedTableAccessible
:
:
GetFrom
(
this
)
;
}
return
nullptr
;
}
TableCellAccessible
*
LocalAccessible
:
:
AsTableCell
(
)
{
if
(
IsTableCell
(
)
&
&
!
mContent
-
>
IsXULElement
(
)
)
{
return
CachedTableCellAccessible
:
:
GetFrom
(
this
)
;
}
return
nullptr
;
}
Maybe
<
int32_t
>
LocalAccessible
:
:
GetIntARIAAttr
(
nsAtom
*
aAttrName
)
const
{
if
(
mContent
)
{
int32_t
val
;
if
(
nsCoreUtils
:
:
GetUIntAttr
(
mContent
aAttrName
&
val
)
)
{
return
Some
(
val
)
;
}
}
return
Nothing
(
)
;
}
