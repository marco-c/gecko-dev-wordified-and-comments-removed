#
ifndef
mozilla_a11y_DocAccessible_inl_h_
#
define
mozilla_a11y_DocAccessible_inl_h_
#
include
"
DocAccessible
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
nsAccessiblePivot
.
h
"
#
include
"
NotificationController
.
h
"
#
include
"
States
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
ifdef
A11Y_LOG
#
include
"
Logging
.
h
"
#
endif
namespace
mozilla
{
namespace
a11y
{
inline
Accessible
*
DocAccessible
:
:
AccessibleOrTrueContainer
(
nsINode
*
aNode
int
aIgnoreARIAHidden
)
const
{
Accessible
*
container
=
GetAccessibleOrContainer
(
aNode
aIgnoreARIAHidden
)
;
if
(
container
&
&
container
-
>
IsHTMLCombobox
(
)
)
{
return
container
-
>
FirstChild
(
)
;
}
return
container
;
}
inline
nsIAccessiblePivot
*
DocAccessible
:
:
VirtualCursor
(
)
{
if
(
!
mVirtualCursor
)
{
mVirtualCursor
=
new
nsAccessiblePivot
(
this
)
;
mVirtualCursor
-
>
AddObserver
(
this
)
;
}
return
mVirtualCursor
;
}
inline
void
DocAccessible
:
:
FireDelayedEvent
(
AccEvent
*
aEvent
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocLoad
)
)
logging
:
:
DocLoadEventFired
(
aEvent
)
;
#
endif
mNotificationController
-
>
QueueEvent
(
aEvent
)
;
}
inline
void
DocAccessible
:
:
FireDelayedEvent
(
uint32_t
aEventType
Accessible
*
aTarget
)
{
RefPtr
<
AccEvent
>
event
=
new
AccEvent
(
aEventType
aTarget
)
;
FireDelayedEvent
(
event
)
;
}
inline
void
DocAccessible
:
:
BindChildDocument
(
DocAccessible
*
aDocument
)
{
mNotificationController
-
>
ScheduleChildDocBinding
(
aDocument
)
;
}
template
<
class
Class
class
Arg
>
inline
void
DocAccessible
:
:
HandleNotification
(
Class
*
aInstance
typename
TNotification
<
Class
Arg
>
:
:
Callback
aMethod
Arg
*
aArg
)
{
if
(
mNotificationController
)
{
mNotificationController
-
>
HandleNotification
<
Class
Arg
>
(
aInstance
aMethod
aArg
)
;
}
}
inline
void
DocAccessible
:
:
UpdateText
(
nsIContent
*
aTextNode
)
{
NS_ASSERTION
(
mNotificationController
"
The
document
was
shut
down
!
"
)
;
if
(
mNotificationController
&
&
HasLoadState
(
eTreeConstructed
)
)
mNotificationController
-
>
ScheduleTextUpdate
(
aTextNode
)
;
}
inline
void
DocAccessible
:
:
AddScrollListener
(
)
{
if
(
!
mPresShell
-
>
GetRootFrame
(
)
)
return
;
mDocFlags
|
=
eScrollInitialized
;
nsIScrollableFrame
*
sf
=
mPresShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
sf
)
{
sf
-
>
AddScrollPositionListener
(
this
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocCreate
)
)
logging
:
:
Text
(
"
add
scroll
listener
"
)
;
#
endif
}
}
inline
void
DocAccessible
:
:
RemoveScrollListener
(
)
{
nsIScrollableFrame
*
sf
=
mPresShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
sf
)
sf
-
>
RemoveScrollPositionListener
(
this
)
;
}
inline
void
DocAccessible
:
:
NotifyOfLoad
(
uint32_t
aLoadEventType
)
{
mLoadState
|
=
eDOMLoaded
;
mLoadEventType
=
aLoadEventType
;
if
(
HasLoadState
(
eCompletelyLoaded
)
&
&
IsLoadEventTarget
(
)
)
{
RefPtr
<
AccEvent
>
stateEvent
=
new
AccStateChangeEvent
(
this
states
:
:
BUSY
false
)
;
FireDelayedEvent
(
stateEvent
)
;
}
}
inline
void
DocAccessible
:
:
MaybeNotifyOfValueChange
(
Accessible
*
aAccessible
)
{
if
(
aAccessible
-
>
IsCombobox
(
)
|
|
aAccessible
-
>
Role
(
)
=
=
roles
:
:
ENTRY
)
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_TEXT_VALUE_CHANGE
aAccessible
)
;
}
inline
Accessible
*
DocAccessible
:
:
GetAccessibleEvenIfNotInMapOrContainer
(
nsINode
*
aNode
)
const
{
Accessible
*
acc
=
GetAccessibleEvenIfNotInMap
(
aNode
)
;
return
acc
?
acc
:
GetContainerAccessible
(
aNode
)
;
}
inline
void
DocAccessible
:
:
CreateSubtree
(
Accessible
*
aChild
)
{
Accessible
*
focusedAcc
=
nullptr
;
CacheChildrenInSubtree
(
aChild
&
focusedAcc
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eVerbose
)
)
{
logging
:
:
Tree
(
"
TREE
"
"
Created
subtree
"
aChild
)
;
}
#
endif
if
(
aChild
-
>
HasARIARole
(
)
)
{
roles
:
:
Role
role
=
aChild
-
>
ARIARole
(
)
;
if
(
role
=
=
roles
:
:
MENUPOPUP
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_MENUPOPUP_START
aChild
)
;
}
else
if
(
role
=
=
roles
:
:
ALERT
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_ALERT
aChild
)
;
}
}
if
(
focusedAcc
)
{
FocusMgr
(
)
-
>
DispatchFocusEvent
(
this
focusedAcc
)
;
SelectionMgr
(
)
-
>
SetControlSelectionListener
(
focusedAcc
-
>
GetNode
(
)
-
>
AsElement
(
)
)
;
}
}
inline
DocAccessible
:
:
AttrRelProviders
*
DocAccessible
:
:
GetRelProviders
(
dom
:
:
Element
*
aElement
const
nsAString
&
aID
)
const
{
DependentIDsHashtable
*
hash
=
mDependentIDsHashes
.
Get
(
aElement
-
>
GetUncomposedDocOrConnectedShadowRoot
(
)
)
;
if
(
hash
)
{
return
hash
-
>
Get
(
aID
)
;
}
return
nullptr
;
}
inline
DocAccessible
:
:
AttrRelProviders
*
DocAccessible
:
:
GetOrCreateRelProviders
(
dom
:
:
Element
*
aElement
const
nsAString
&
aID
)
{
dom
:
:
DocumentOrShadowRoot
*
docOrShadowRoot
=
aElement
-
>
GetUncomposedDocOrConnectedShadowRoot
(
)
;
DependentIDsHashtable
*
hash
=
mDependentIDsHashes
.
Get
(
docOrShadowRoot
)
;
if
(
!
hash
)
{
hash
=
new
DependentIDsHashtable
(
)
;
mDependentIDsHashes
.
Put
(
docOrShadowRoot
hash
)
;
}
AttrRelProviders
*
providers
=
hash
-
>
Get
(
aID
)
;
if
(
!
providers
)
{
providers
=
new
AttrRelProviders
(
)
;
hash
-
>
Put
(
aID
providers
)
;
}
return
providers
;
}
inline
void
DocAccessible
:
:
RemoveRelProvidersIfEmpty
(
dom
:
:
Element
*
aElement
const
nsAString
&
aID
)
{
dom
:
:
DocumentOrShadowRoot
*
docOrShadowRoot
=
aElement
-
>
GetUncomposedDocOrConnectedShadowRoot
(
)
;
DependentIDsHashtable
*
hash
=
mDependentIDsHashes
.
Get
(
docOrShadowRoot
)
;
if
(
hash
)
{
AttrRelProviders
*
providers
=
hash
-
>
Get
(
aID
)
;
if
(
providers
&
&
providers
-
>
Length
(
)
=
=
0
)
{
hash
-
>
Remove
(
aID
)
;
if
(
mDependentIDsHashes
.
IsEmpty
(
)
)
{
mDependentIDsHashes
.
Remove
(
docOrShadowRoot
)
;
}
}
}
}
}
}
#
endif
