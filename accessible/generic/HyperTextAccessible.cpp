#
include
"
HyperTextAccessible
-
inl
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
nsAccessiblePivot
.
h
"
#
include
"
nsIAccessibleTypes
.
h
"
#
include
"
AccAttributes
.
h
"
#
include
"
DocAccessible
.
h
"
#
include
"
HTMLListAccessible
.
h
"
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
Pivot
.
h
"
#
include
"
Relation
.
h
"
#
include
"
Role
.
h
"
#
include
"
States
.
h
"
#
include
"
TextAttrs
.
h
"
#
include
"
TextLeafRange
.
h
"
#
include
"
TextRange
.
h
"
#
include
"
TreeWalker
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIEditingSession
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsILineIterator
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIMathMLFrame
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_accessibility
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLHeadingElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
gfxSkipChars
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
class
ParagraphBoundaryRule
:
public
PivotRule
{
public
:
explicit
ParagraphBoundaryRule
(
LocalAccessible
*
aAnchor
uint32_t
aAnchorTextoffset
nsDirection
aDirection
bool
aSkipAnchorSubtree
=
false
)
:
mAnchor
(
aAnchor
)
mAnchorTextOffset
(
aAnchorTextoffset
)
mDirection
(
aDirection
)
mSkipAnchorSubtree
(
aSkipAnchorSubtree
)
mLastMatchTextOffset
(
0
)
{
}
virtual
uint16_t
Match
(
Accessible
*
aAcc
)
override
{
MOZ_ASSERT
(
aAcc
&
&
aAcc
-
>
IsLocal
(
)
)
;
LocalAccessible
*
acc
=
aAcc
-
>
AsLocal
(
)
;
if
(
acc
-
>
IsOuterDoc
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
uint16_t
result
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
if
(
mSkipAnchorSubtree
&
&
acc
=
=
mAnchor
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
acc
-
>
Role
(
)
=
=
roles
:
:
WHITESPACE
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
return
result
;
}
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsBlockFrame
(
)
&
&
acc
-
>
Role
(
)
!
=
roles
:
:
LISTITEM_MARKER
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
return
result
;
}
if
(
acc
-
>
IsTextLeaf
(
)
)
{
nsAutoString
name
;
acc
-
>
Name
(
name
)
;
int32_t
offset
;
if
(
mDirection
=
=
eDirPrevious
)
{
if
(
acc
=
=
mAnchor
&
&
mAnchorTextOffset
=
=
0
)
{
return
result
;
}
offset
=
name
.
RFindChar
(
'
\
n
'
acc
=
=
mAnchor
?
mAnchorTextOffset
-
1
:
-
1
)
;
}
else
{
offset
=
name
.
FindChar
(
'
\
n
'
acc
=
=
mAnchor
?
mAnchorTextOffset
:
0
)
;
}
if
(
offset
!
=
-
1
)
{
mLastMatchTextOffset
=
offset
;
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
}
return
result
;
}
uint32_t
GetLastMatchTextOffset
(
)
{
return
mLastMatchTextOffset
;
}
private
:
LocalAccessible
*
mAnchor
;
uint32_t
mAnchorTextOffset
;
nsDirection
mDirection
;
bool
mSkipAnchorSubtree
;
uint32_t
mLastMatchTextOffset
;
}
;
class
SkipParagraphBoundaryRule
:
public
PivotRule
{
public
:
explicit
SkipParagraphBoundaryRule
(
Accessible
*
aBoundary
)
:
mBoundary
(
aBoundary
)
{
}
virtual
uint16_t
Match
(
Accessible
*
aAcc
)
override
{
MOZ_ASSERT
(
aAcc
&
&
aAcc
-
>
IsLocal
(
)
)
;
if
(
aAcc
=
=
mBoundary
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
private
:
Accessible
*
mBoundary
;
}
;
HyperTextAccessible
:
:
HyperTextAccessible
(
nsIContent
*
aNode
DocAccessible
*
aDoc
)
:
AccessibleWrap
(
aNode
aDoc
)
{
mType
=
eHyperTextType
;
mGenericTypes
|
=
eHyperText
;
}
role
HyperTextAccessible
:
:
NativeRole
(
)
const
{
a11y
:
:
role
r
=
GetAccService
(
)
-
>
MarkupRole
(
mContent
)
;
if
(
r
!
=
roles
:
:
NOTHING
)
return
r
;
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsInlineFrame
(
)
)
return
roles
:
:
TEXT
;
return
roles
:
:
TEXT_CONTAINER
;
}
uint64_t
HyperTextAccessible
:
:
NativeState
(
)
const
{
uint64_t
states
=
AccessibleWrap
:
:
NativeState
(
)
;
if
(
mContent
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
dom
:
:
ElementState
:
:
READWRITE
)
)
{
states
|
=
states
:
:
EDITABLE
;
}
else
if
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
article
)
)
{
states
|
=
states
:
:
READONLY
;
}
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
(
states
&
states
:
:
EDITABLE
)
|
|
(
frame
&
&
frame
-
>
IsSelectable
(
nullptr
)
)
)
{
states
|
=
states
:
:
SELECTABLE_TEXT
;
}
return
states
;
}
LayoutDeviceIntRect
HyperTextAccessible
:
:
GetBoundsInFrame
(
nsIFrame
*
aFrame
uint32_t
aStartRenderedOffset
uint32_t
aEndRenderedOffset
)
{
nsPresContext
*
presContext
=
mDoc
-
>
PresContext
(
)
;
if
(
!
aFrame
-
>
IsTextFrame
(
)
)
{
return
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
aFrame
-
>
GetScreenRectInAppUnits
(
)
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
}
int32_t
startContentOffset
endContentOffset
;
nsresult
rv
=
RenderedToContentOffset
(
aFrame
aStartRenderedOffset
&
startContentOffset
)
;
NS_ENSURE_SUCCESS
(
rv
LayoutDeviceIntRect
(
)
)
;
rv
=
RenderedToContentOffset
(
aFrame
aEndRenderedOffset
&
endContentOffset
)
;
NS_ENSURE_SUCCESS
(
rv
LayoutDeviceIntRect
(
)
)
;
nsIFrame
*
frame
;
int32_t
startContentOffsetInFrame
;
rv
=
aFrame
-
>
GetChildFrameContainingOffset
(
startContentOffset
false
&
startContentOffsetInFrame
&
frame
)
;
NS_ENSURE_SUCCESS
(
rv
LayoutDeviceIntRect
(
)
)
;
nsRect
screenRect
;
while
(
frame
&
&
startContentOffset
<
endContentOffset
)
{
nsRect
frameScreenRect
=
frame
-
>
GetScreenRectInAppUnits
(
)
;
auto
[
startFrameTextOffset
endFrameTextOffset
]
=
frame
-
>
GetOffsets
(
)
;
int32_t
frameTotalTextLength
=
endFrameTextOffset
-
startFrameTextOffset
;
int32_t
seekLength
=
endContentOffset
-
startContentOffset
;
int32_t
frameSubStringLength
=
std
:
:
min
(
frameTotalTextLength
-
startContentOffsetInFrame
seekLength
)
;
nsPoint
frameTextStartPoint
;
rv
=
frame
-
>
GetPointFromOffset
(
startContentOffset
&
frameTextStartPoint
)
;
NS_ENSURE_SUCCESS
(
rv
LayoutDeviceIntRect
(
)
)
;
nsPoint
frameTextEndPoint
;
rv
=
frame
-
>
GetPointFromOffset
(
startContentOffset
+
frameSubStringLength
&
frameTextEndPoint
)
;
NS_ENSURE_SUCCESS
(
rv
LayoutDeviceIntRect
(
)
)
;
frameScreenRect
.
SetRectX
(
frameScreenRect
.
X
(
)
+
std
:
:
min
(
frameTextStartPoint
.
x
frameTextEndPoint
.
x
)
mozilla
:
:
Abs
(
frameTextStartPoint
.
x
-
frameTextEndPoint
.
x
)
)
;
screenRect
.
UnionRect
(
frameScreenRect
screenRect
)
;
startContentOffset
+
=
frameSubStringLength
;
startContentOffsetInFrame
=
0
;
frame
=
frame
-
>
GetNextContinuation
(
)
;
}
return
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
screenRect
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
}
uint32_t
HyperTextAccessible
:
:
DOMPointToOffset
(
nsINode
*
aNode
int32_t
aNodeOffset
bool
aIsEndOffset
)
const
{
if
(
!
aNode
)
return
0
;
uint32_t
offset
=
0
;
nsINode
*
findNode
=
nullptr
;
if
(
aNodeOffset
=
=
-
1
)
{
findNode
=
aNode
;
}
else
if
(
aNode
-
>
IsText
(
)
)
{
nsIFrame
*
frame
=
aNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
frame
0
)
;
nsresult
rv
=
ContentToRenderedOffset
(
frame
aNodeOffset
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
0
)
;
findNode
=
aNode
;
}
else
{
findNode
=
aNode
-
>
GetChildAt_Deprecated
(
aNodeOffset
)
;
if
(
!
findNode
)
{
if
(
aNodeOffset
=
=
0
)
{
if
(
aNode
=
=
GetNode
(
)
)
{
return
0
;
}
findNode
=
aNode
;
}
else
if
(
aNodeOffset
=
=
static_cast
<
int32_t
>
(
aNode
-
>
GetChildCount
(
)
)
)
{
for
(
nsINode
*
tmpNode
=
aNode
;
!
findNode
&
&
tmpNode
&
&
tmpNode
!
=
mContent
;
tmpNode
=
tmpNode
-
>
GetParent
(
)
)
{
findNode
=
tmpNode
-
>
GetNextSibling
(
)
;
}
}
}
}
LocalAccessible
*
descendant
=
nullptr
;
if
(
findNode
)
{
dom
:
:
HTMLBRElement
*
brElement
=
dom
:
:
HTMLBRElement
:
:
FromNode
(
findNode
)
;
if
(
brElement
&
&
brElement
-
>
IsPaddingForEmptyEditor
(
)
)
{
return
0
;
}
descendant
=
mDoc
-
>
GetAccessible
(
findNode
)
;
if
(
!
descendant
&
&
findNode
-
>
IsContent
(
)
)
{
LocalAccessible
*
container
=
mDoc
-
>
GetContainerAccessible
(
findNode
)
;
if
(
container
)
{
TreeWalker
walker
(
container
findNode
-
>
AsContent
(
)
TreeWalker
:
:
eWalkContextTree
)
;
descendant
=
walker
.
Next
(
)
;
if
(
!
descendant
)
descendant
=
container
;
}
}
}
return
TransformOffset
(
descendant
offset
aIsEndOffset
)
;
}
uint32_t
HyperTextAccessible
:
:
TransformOffset
(
LocalAccessible
*
aDescendant
uint32_t
aOffset
bool
aIsEndOffset
)
const
{
uint32_t
offset
=
aOffset
;
LocalAccessible
*
descendant
=
aDescendant
;
while
(
descendant
)
{
LocalAccessible
*
parent
=
descendant
-
>
LocalParent
(
)
;
if
(
parent
=
=
this
)
return
GetChildOffset
(
descendant
)
+
offset
;
if
(
aIsEndOffset
)
{
if
(
offset
=
=
0
&
&
parent
&
&
parent
-
>
IsHTMLListItem
(
)
&
&
descendant
-
>
LocalPrevSibling
(
)
&
&
descendant
-
>
LocalPrevSibling
(
)
=
=
parent
-
>
AsHTMLListItem
(
)
-
>
Bullet
(
)
)
{
offset
=
0
;
}
else
{
offset
=
(
offset
>
0
|
|
descendant
-
>
IndexInParent
(
)
>
0
)
?
1
:
0
;
}
}
else
{
offset
=
0
;
}
descendant
=
parent
;
}
return
CharacterCount
(
)
;
}
DOMPoint
HyperTextAccessible
:
:
OffsetToDOMPoint
(
int32_t
aOffset
)
const
{
if
(
aOffset
=
=
0
)
{
RefPtr
<
EditorBase
>
editorBase
=
GetEditor
(
)
;
if
(
editorBase
)
{
if
(
editorBase
-
>
IsEmpty
(
)
)
{
return
DOMPoint
(
editorBase
-
>
GetRoot
(
)
0
)
;
}
}
}
int32_t
childIdx
=
GetChildIndexAtOffset
(
aOffset
)
;
if
(
childIdx
=
=
-
1
)
return
DOMPoint
(
)
;
LocalAccessible
*
child
=
LocalChildAt
(
childIdx
)
;
int32_t
innerOffset
=
aOffset
-
GetChildOffset
(
childIdx
)
;
if
(
child
-
>
IsTextLeaf
(
)
)
{
if
(
aOffset
<
GetChildOffset
(
childIdx
+
1
)
)
{
nsIContent
*
content
=
child
-
>
GetContent
(
)
;
int32_t
idx
=
0
;
if
(
NS_FAILED
(
RenderedToContentOffset
(
content
-
>
GetPrimaryFrame
(
)
innerOffset
&
idx
)
)
)
{
return
DOMPoint
(
)
;
}
return
DOMPoint
(
content
idx
)
;
}
MOZ_ASSERT
(
static_cast
<
uint32_t
>
(
aOffset
)
=
=
CharacterCount
(
)
)
;
innerOffset
=
1
;
}
NS_ASSERTION
(
innerOffset
=
=
0
|
|
innerOffset
=
=
1
"
A
wrong
inner
offset
!
"
)
;
nsINode
*
node
=
child
-
>
GetNode
(
)
;
nsINode
*
parentNode
=
node
-
>
GetParentNode
(
)
;
return
parentNode
?
DOMPoint
(
parentNode
parentNode
-
>
ComputeIndexOf_Deprecated
(
node
)
+
innerOffset
)
:
DOMPoint
(
)
;
}
uint32_t
HyperTextAccessible
:
:
FindOffset
(
uint32_t
aOffset
nsDirection
aDirection
nsSelectionAmount
aAmount
EWordMovementType
aWordMovementType
)
{
NS_ASSERTION
(
aDirection
=
=
eDirPrevious
|
|
aAmount
!
=
eSelectBeginLine
"
eSelectBeginLine
should
only
be
used
with
eDirPrevious
"
)
;
HyperTextAccessible
*
text
=
this
;
LocalAccessible
*
child
=
nullptr
;
int32_t
innerOffset
=
aOffset
;
do
{
int32_t
childIdx
=
text
-
>
GetChildIndexAtOffset
(
innerOffset
)
;
if
(
childIdx
=
=
-
1
)
{
NS_ASSERTION
(
innerOffset
=
=
0
&
&
!
text
-
>
ChildCount
(
)
"
No
childIdx
?
"
)
;
return
DOMPointToOffset
(
text
-
>
GetNode
(
)
0
aDirection
=
=
eDirNext
)
;
}
child
=
text
-
>
LocalChildAt
(
childIdx
)
;
if
(
text
-
>
IsHTMLListItem
(
)
)
{
HTMLLIAccessible
*
li
=
text
-
>
AsHTMLListItem
(
)
;
if
(
child
=
=
li
-
>
Bullet
(
)
)
{
if
(
text
!
=
this
)
{
return
aDirection
=
=
eDirPrevious
?
TransformOffset
(
text
0
false
)
:
TransformOffset
(
text
1
true
)
;
}
if
(
aDirection
=
=
eDirPrevious
)
return
0
;
uint32_t
nextOffset
=
GetChildOffset
(
1
)
;
if
(
nextOffset
=
=
0
)
return
0
;
switch
(
aAmount
)
{
case
eSelectLine
:
case
eSelectEndLine
:
return
nextOffset
<
CharacterCount
(
)
?
FindOffset
(
nextOffset
aDirection
aAmount
aWordMovementType
)
:
nextOffset
;
default
:
return
nextOffset
;
}
}
}
innerOffset
-
=
text
-
>
GetChildOffset
(
childIdx
)
;
text
=
child
-
>
AsHyperText
(
)
;
}
while
(
text
)
;
nsIFrame
*
childFrame
=
child
-
>
GetFrame
(
)
;
if
(
!
childFrame
)
{
NS_ERROR
(
"
No
child
frame
"
)
;
return
0
;
}
int32_t
innerContentOffset
=
innerOffset
;
if
(
child
-
>
IsTextLeaf
(
)
)
{
NS_ASSERTION
(
childFrame
-
>
IsTextFrame
(
)
"
Wrong
frame
!
"
)
;
RenderedToContentOffset
(
childFrame
innerOffset
&
innerContentOffset
)
;
}
nsIFrame
*
frameAtOffset
=
childFrame
;
int32_t
unusedOffsetInFrame
=
0
;
childFrame
-
>
GetChildFrameContainingOffset
(
innerContentOffset
true
&
unusedOffsetInFrame
&
frameAtOffset
)
;
const
bool
kIsJumpLinesOk
=
true
;
const
bool
kIsScrollViewAStop
=
false
;
const
bool
kIsKeyboardSelect
=
true
;
const
bool
kIsVisualBidi
=
false
;
nsPeekOffsetStruct
pos
(
aAmount
aDirection
innerContentOffset
nsPoint
(
0
0
)
kIsJumpLinesOk
kIsScrollViewAStop
kIsKeyboardSelect
kIsVisualBidi
false
nsPeekOffsetStruct
:
:
ForceEditableRegion
:
:
No
aWordMovementType
false
)
;
nsresult
rv
=
frameAtOffset
-
>
PeekOffset
(
&
pos
)
;
bool
fallBackToSelectEndLine
=
false
;
if
(
NS_FAILED
(
rv
)
&
&
aAmount
=
=
eSelectLine
)
{
fallBackToSelectEndLine
=
aDirection
=
=
eDirNext
;
pos
.
mAmount
=
fallBackToSelectEndLine
?
eSelectEndLine
:
eSelectBeginLine
;
frameAtOffset
-
>
PeekOffset
(
&
pos
)
;
}
if
(
!
pos
.
mResultContent
)
{
NS_ERROR
(
"
No
result
content
!
"
)
;
return
0
;
}
uint32_t
hyperTextOffset
=
DOMPointToOffset
(
pos
.
mResultContent
pos
.
mContentOffset
aDirection
=
=
eDirNext
)
;
if
(
fallBackToSelectEndLine
&
&
IsLineEndCharAt
(
hyperTextOffset
)
)
{
+
+
hyperTextOffset
;
}
if
(
aDirection
=
=
eDirPrevious
)
{
if
(
hyperTextOffset
=
=
CharacterCount
(
)
)
return
0
;
if
(
IsHTMLListItem
(
)
&
&
aAmount
=
=
eSelectBeginLine
&
&
hyperTextOffset
>
0
)
{
LocalAccessible
*
prevOffsetChild
=
GetChildAtOffset
(
hyperTextOffset
-
1
)
;
if
(
prevOffsetChild
=
=
AsHTMLListItem
(
)
-
>
Bullet
(
)
)
return
0
;
}
}
return
hyperTextOffset
;
}
uint32_t
HyperTextAccessible
:
:
FindWordBoundary
(
uint32_t
aOffset
nsDirection
aDirection
EWordMovementType
aWordMovementType
)
{
uint32_t
orig
=
FindOffset
(
aOffset
aDirection
eSelectWord
aWordMovementType
)
;
if
(
aWordMovementType
!
=
eStartWord
)
{
return
orig
;
}
if
(
aDirection
=
=
eDirPrevious
)
{
if
(
!
StaticPrefs
:
:
layout_word_select_stop_at_punctuation
(
)
)
{
return
orig
;
}
LocalAccessible
*
child
=
GetChildAtOffset
(
orig
)
;
if
(
child
&
&
child
-
>
IsHyperText
(
)
)
{
return
orig
;
}
uint32_t
next
=
FindOffset
(
orig
eDirNext
eSelectWord
eStartWord
)
;
if
(
next
<
aOffset
)
{
return
next
;
}
if
(
orig
=
=
0
)
{
return
orig
;
}
for
(
uint32_t
o
=
orig
-
1
;
o
<
orig
;
-
-
o
)
{
next
=
FindOffset
(
o
eDirNext
eSelectWord
eStartWord
)
;
if
(
next
=
=
orig
)
{
break
;
}
if
(
next
<
orig
)
{
return
next
;
}
}
}
else
{
if
(
aOffset
=
=
0
)
{
return
orig
;
}
uint32_t
prev
=
FindOffset
(
orig
eDirPrevious
eSelectWord
eStartWord
)
;
if
(
prev
<
=
aOffset
)
{
return
orig
;
}
for
(
uint32_t
o
=
aOffset
-
1
;
o
<
aOffset
;
-
-
o
)
{
uint32_t
next
=
FindOffset
(
o
eDirNext
eSelectWord
eStartWord
)
;
if
(
next
>
aOffset
&
&
next
<
orig
)
{
return
next
;
}
if
(
next
<
=
aOffset
)
{
break
;
}
}
}
return
orig
;
}
uint32_t
HyperTextAccessible
:
:
FindLineBoundary
(
uint32_t
aOffset
EWhichLineBoundary
aWhichLineBoundary
)
{
switch
(
aWhichLineBoundary
)
{
case
ePrevLineBegin
:
{
if
(
IsEmptyLastLineOffset
(
aOffset
)
)
{
return
FindOffset
(
aOffset
eDirPrevious
eSelectBeginLine
)
;
}
uint32_t
tmpOffset
=
FindOffset
(
aOffset
eDirPrevious
eSelectLine
)
;
return
FindOffset
(
tmpOffset
eDirPrevious
eSelectBeginLine
)
;
}
case
ePrevLineEnd
:
{
if
(
IsEmptyLastLineOffset
(
aOffset
)
)
return
aOffset
-
1
;
uint32_t
tmpOffset
=
FindOffset
(
aOffset
eDirPrevious
eSelectBeginLine
)
;
if
(
tmpOffset
=
=
0
)
return
0
;
tmpOffset
=
FindOffset
(
aOffset
eDirPrevious
eSelectLine
)
;
return
FindOffset
(
tmpOffset
eDirNext
eSelectEndLine
)
;
}
case
eThisLineBegin
:
{
if
(
IsEmptyLastLineOffset
(
aOffset
)
)
return
aOffset
;
uint32_t
thisLineBeginOffset
=
FindOffset
(
aOffset
eDirPrevious
eSelectBeginLine
)
;
if
(
IsCharAt
(
thisLineBeginOffset
kEmbeddedObjectChar
)
)
{
return
thisLineBeginOffset
;
}
uint32_t
tmpOffset
=
FindOffset
(
aOffset
eDirPrevious
eSelectLine
)
;
tmpOffset
=
FindOffset
(
tmpOffset
eDirNext
eSelectEndLine
)
;
if
(
tmpOffset
>
thisLineBeginOffset
&
&
tmpOffset
<
aOffset
)
{
return
IsLineEndCharAt
(
tmpOffset
)
?
tmpOffset
+
1
:
tmpOffset
;
}
return
thisLineBeginOffset
;
}
case
eThisLineEnd
:
if
(
IsEmptyLastLineOffset
(
aOffset
)
)
return
aOffset
;
return
FindOffset
(
aOffset
eDirNext
eSelectEndLine
)
;
case
eNextLineBegin
:
{
if
(
IsEmptyLastLineOffset
(
aOffset
)
)
return
aOffset
;
uint32_t
tmpOffset
=
FindOffset
(
aOffset
eDirNext
eSelectLine
)
;
uint32_t
characterCount
=
CharacterCount
(
)
;
if
(
tmpOffset
=
=
characterCount
)
{
return
tmpOffset
;
}
uint32_t
nextLineBeginOffset
=
FindOffset
(
tmpOffset
eDirPrevious
eSelectBeginLine
)
;
if
(
IsCharAt
(
nextLineBeginOffset
kEmbeddedObjectChar
)
)
{
uint32_t
thisLineEndOffset
=
FindOffset
(
aOffset
eDirNext
eSelectEndLine
)
;
if
(
thisLineEndOffset
=
=
nextLineBeginOffset
+
1
)
{
if
(
nextLineBeginOffset
=
=
aOffset
)
{
uint32_t
thisLineEndOffset2
=
FindOffset
(
thisLineEndOffset
eDirNext
eSelectEndLine
)
;
return
(
thisLineEndOffset2
=
=
characterCount
|
|
(
IsCharAt
(
thisLineEndOffset
kEmbeddedObjectChar
)
&
&
thisLineEndOffset2
=
=
thisLineEndOffset
+
1
)
|
|
IsCharAt
(
thisLineEndOffset2
kEmbeddedObjectChar
)
)
?
thisLineEndOffset2
:
thisLineEndOffset2
+
1
;
}
return
thisLineEndOffset
;
}
return
nextLineBeginOffset
;
}
if
(
nextLineBeginOffset
<
=
aOffset
)
{
nextLineBeginOffset
=
aOffset
;
while
(
nextLineBeginOffset
<
tmpOffset
)
{
if
(
IsLineEndCharAt
(
nextLineBeginOffset
)
)
{
return
nextLineBeginOffset
+
1
;
}
nextLineBeginOffset
+
+
;
}
}
return
nextLineBeginOffset
;
}
case
eNextLineEnd
:
{
if
(
IsEmptyLastLineOffset
(
aOffset
)
)
return
aOffset
;
uint32_t
tmpOffset
=
FindOffset
(
aOffset
eDirNext
eSelectLine
)
;
if
(
tmpOffset
=
=
CharacterCount
(
)
)
return
tmpOffset
;
return
FindOffset
(
tmpOffset
eDirNext
eSelectEndLine
)
;
}
}
return
0
;
}
int32_t
HyperTextAccessible
:
:
FindParagraphStartOffset
(
uint32_t
aOffset
)
{
LocalAccessible
*
child
=
GetChildAtOffset
(
aOffset
)
;
if
(
!
child
)
{
return
-
1
;
}
Pivot
p
=
Pivot
(
this
)
;
ParagraphBoundaryRule
boundaryRule
=
ParagraphBoundaryRule
(
child
child
-
>
IsTextLeaf
(
)
?
aOffset
-
GetChildOffset
(
child
)
:
0
eDirPrevious
)
;
Accessible
*
match
=
p
.
Prev
(
child
boundaryRule
true
)
;
if
(
!
match
|
|
match
-
>
AsLocal
(
)
=
=
this
)
{
return
0
;
}
if
(
match
=
=
child
)
{
if
(
match
-
>
Role
(
)
=
=
roles
:
:
WHITESPACE
)
{
match
=
p
.
Prev
(
match
boundaryRule
)
;
if
(
!
match
|
|
match
-
>
AsLocal
(
)
=
=
this
)
{
return
0
;
}
}
else
if
(
!
match
-
>
AsLocal
(
)
-
>
IsTextLeaf
(
)
)
{
return
TransformOffset
(
match
-
>
AsLocal
(
)
0
false
)
;
}
}
if
(
match
-
>
AsLocal
(
)
-
>
IsTextLeaf
(
)
)
{
return
TransformOffset
(
match
-
>
AsLocal
(
)
boundaryRule
.
GetLastMatchTextOffset
(
)
+
1
false
)
;
}
SkipParagraphBoundaryRule
goForwardOneRule
=
SkipParagraphBoundaryRule
(
match
)
;
match
=
p
.
Next
(
match
goForwardOneRule
)
;
MOZ_ASSERT
(
match
)
;
return
TransformOffset
(
match
-
>
AsLocal
(
)
0
false
)
;
}
int32_t
HyperTextAccessible
:
:
FindParagraphEndOffset
(
uint32_t
aOffset
)
{
LocalAccessible
*
child
=
GetChildAtOffset
(
aOffset
)
;
if
(
!
child
)
{
return
-
1
;
}
Pivot
p
=
Pivot
(
this
)
;
ParagraphBoundaryRule
boundaryRule
=
ParagraphBoundaryRule
(
child
child
-
>
IsTextLeaf
(
)
?
aOffset
-
GetChildOffset
(
child
)
:
0
eDirNext
true
)
;
Accessible
*
match
=
p
.
Next
(
child
boundaryRule
true
)
;
if
(
match
)
{
LocalAccessible
*
matchAcc
=
match
-
>
AsLocal
(
)
;
uint32_t
matchOffset
;
if
(
matchAcc
-
>
IsTextLeaf
(
)
)
{
matchOffset
=
boundaryRule
.
GetLastMatchTextOffset
(
)
+
1
;
}
else
if
(
matchAcc
-
>
Role
(
)
!
=
roles
:
:
WHITESPACE
&
&
matchAcc
!
=
child
)
{
matchOffset
=
0
;
}
else
{
matchOffset
=
nsAccUtils
:
:
TextLength
(
matchAcc
)
;
}
return
TransformOffset
(
matchAcc
matchOffset
true
)
;
}
return
CharacterCount
(
)
;
}
void
HyperTextAccessible
:
:
TextBeforeOffset
(
int32_t
aOffset
AccessibleTextBoundary
aBoundaryType
int32_t
*
aStartOffset
int32_t
*
aEndOffset
nsAString
&
aText
)
{
if
(
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
{
return
HyperTextAccessibleBase
:
:
TextBeforeOffset
(
aOffset
aBoundaryType
aStartOffset
aEndOffset
aText
)
;
}
*
aStartOffset
=
*
aEndOffset
=
0
;
aText
.
Truncate
(
)
;
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_PARAGRAPH
)
{
return
;
}
index_t
convertedOffset
=
ConvertMagicOffset
(
aOffset
)
;
if
(
!
convertedOffset
.
IsValid
(
)
|
|
convertedOffset
>
CharacterCount
(
)
)
{
NS_ERROR
(
"
Wrong
in
offset
!
"
)
;
return
;
}
uint32_t
adjustedOffset
=
convertedOffset
;
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
{
adjustedOffset
=
AdjustCaretOffset
(
adjustedOffset
)
;
}
switch
(
aBoundaryType
)
{
case
nsIAccessibleText
:
:
BOUNDARY_CHAR
:
if
(
convertedOffset
!
=
0
)
{
CharAt
(
convertedOffset
-
1
aText
aStartOffset
aEndOffset
)
;
}
break
;
case
nsIAccessibleText
:
:
BOUNDARY_WORD_START
:
{
if
(
adjustedOffset
=
=
CharacterCount
(
)
)
{
*
aEndOffset
=
FindWordBoundary
(
adjustedOffset
eDirPrevious
eStartWord
)
;
*
aStartOffset
=
FindWordBoundary
(
*
aEndOffset
eDirPrevious
eStartWord
)
;
}
else
{
*
aStartOffset
=
FindWordBoundary
(
adjustedOffset
eDirPrevious
eStartWord
)
;
*
aEndOffset
=
FindWordBoundary
(
*
aStartOffset
eDirNext
eStartWord
)
;
if
(
*
aEndOffset
!
=
static_cast
<
int32_t
>
(
adjustedOffset
)
)
{
*
aEndOffset
=
*
aStartOffset
;
*
aStartOffset
=
FindWordBoundary
(
*
aEndOffset
eDirPrevious
eStartWord
)
;
}
}
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
}
case
nsIAccessibleText
:
:
BOUNDARY_WORD_END
:
{
*
aEndOffset
=
FindWordBoundary
(
convertedOffset
eDirPrevious
eEndWord
)
;
*
aStartOffset
=
FindWordBoundary
(
*
aEndOffset
eDirPrevious
eEndWord
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
}
case
nsIAccessibleText
:
:
BOUNDARY_LINE_START
:
*
aStartOffset
=
FindLineBoundary
(
adjustedOffset
ePrevLineBegin
)
;
*
aEndOffset
=
FindLineBoundary
(
adjustedOffset
eThisLineBegin
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
case
nsIAccessibleText
:
:
BOUNDARY_LINE_END
:
{
*
aEndOffset
=
FindLineBoundary
(
adjustedOffset
ePrevLineEnd
)
;
int32_t
tmpOffset
=
*
aEndOffset
;
if
(
*
aEndOffset
!
=
0
&
&
!
IsLineEndCharAt
(
*
aEndOffset
)
)
tmpOffset
-
-
;
*
aStartOffset
=
FindLineBoundary
(
tmpOffset
ePrevLineEnd
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
}
}
}
void
HyperTextAccessible
:
:
TextAtOffset
(
int32_t
aOffset
AccessibleTextBoundary
aBoundaryType
int32_t
*
aStartOffset
int32_t
*
aEndOffset
nsAString
&
aText
)
{
if
(
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
{
return
HyperTextAccessibleBase
:
:
TextAtOffset
(
aOffset
aBoundaryType
aStartOffset
aEndOffset
aText
)
;
}
*
aStartOffset
=
*
aEndOffset
=
0
;
aText
.
Truncate
(
)
;
uint32_t
adjustedOffset
=
ConvertMagicOffset
(
aOffset
)
;
if
(
adjustedOffset
=
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
{
NS_ERROR
(
"
Wrong
given
offset
!
"
)
;
return
;
}
switch
(
aBoundaryType
)
{
case
nsIAccessibleText
:
:
BOUNDARY_CHAR
:
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
&
&
IsCaretAtEndOfLine
(
)
)
{
*
aStartOffset
=
*
aEndOffset
=
adjustedOffset
;
}
else
{
CharAt
(
adjustedOffset
aText
aStartOffset
aEndOffset
)
;
}
break
;
case
nsIAccessibleText
:
:
BOUNDARY_WORD_START
:
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
{
adjustedOffset
=
AdjustCaretOffset
(
adjustedOffset
)
;
}
*
aEndOffset
=
FindWordBoundary
(
adjustedOffset
eDirNext
eStartWord
)
;
*
aStartOffset
=
FindWordBoundary
(
*
aEndOffset
eDirPrevious
eStartWord
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
case
nsIAccessibleText
:
:
BOUNDARY_WORD_END
:
*
aEndOffset
=
FindWordBoundary
(
adjustedOffset
eDirNext
eEndWord
)
;
*
aStartOffset
=
FindWordBoundary
(
*
aEndOffset
eDirPrevious
eEndWord
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
case
nsIAccessibleText
:
:
BOUNDARY_LINE_START
:
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
{
adjustedOffset
=
AdjustCaretOffset
(
adjustedOffset
)
;
}
*
aStartOffset
=
FindLineBoundary
(
adjustedOffset
eThisLineBegin
)
;
*
aEndOffset
=
FindLineBoundary
(
adjustedOffset
eNextLineBegin
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
case
nsIAccessibleText
:
:
BOUNDARY_LINE_END
:
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
{
adjustedOffset
=
AdjustCaretOffset
(
adjustedOffset
)
;
}
*
aStartOffset
=
FindLineBoundary
(
adjustedOffset
ePrevLineEnd
)
;
*
aEndOffset
=
FindLineBoundary
(
adjustedOffset
eThisLineEnd
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
case
nsIAccessibleText
:
:
BOUNDARY_PARAGRAPH
:
{
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
{
adjustedOffset
=
AdjustCaretOffset
(
adjustedOffset
)
;
}
if
(
IsEmptyLastLineOffset
(
adjustedOffset
)
)
{
*
aStartOffset
=
*
aEndOffset
=
adjustedOffset
;
break
;
}
*
aStartOffset
=
FindParagraphStartOffset
(
adjustedOffset
)
;
*
aEndOffset
=
FindParagraphEndOffset
(
adjustedOffset
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
}
}
}
void
HyperTextAccessible
:
:
TextAfterOffset
(
int32_t
aOffset
AccessibleTextBoundary
aBoundaryType
int32_t
*
aStartOffset
int32_t
*
aEndOffset
nsAString
&
aText
)
{
if
(
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
{
return
HyperTextAccessibleBase
:
:
TextAfterOffset
(
aOffset
aBoundaryType
aStartOffset
aEndOffset
aText
)
;
}
*
aStartOffset
=
*
aEndOffset
=
0
;
aText
.
Truncate
(
)
;
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_PARAGRAPH
)
{
return
;
}
index_t
convertedOffset
=
ConvertMagicOffset
(
aOffset
)
;
if
(
!
convertedOffset
.
IsValid
(
)
|
|
convertedOffset
>
CharacterCount
(
)
)
{
NS_ERROR
(
"
Wrong
in
offset
!
"
)
;
return
;
}
uint32_t
adjustedOffset
=
convertedOffset
;
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
{
adjustedOffset
=
AdjustCaretOffset
(
adjustedOffset
)
;
}
switch
(
aBoundaryType
)
{
case
nsIAccessibleText
:
:
BOUNDARY_CHAR
:
if
(
adjustedOffset
>
=
CharacterCount
(
)
)
{
*
aStartOffset
=
*
aEndOffset
=
CharacterCount
(
)
;
}
else
{
CharAt
(
adjustedOffset
+
1
aText
aStartOffset
aEndOffset
)
;
}
break
;
case
nsIAccessibleText
:
:
BOUNDARY_WORD_START
:
*
aStartOffset
=
FindWordBoundary
(
adjustedOffset
eDirNext
eStartWord
)
;
*
aEndOffset
=
FindWordBoundary
(
*
aStartOffset
eDirNext
eStartWord
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
case
nsIAccessibleText
:
:
BOUNDARY_WORD_END
:
if
(
convertedOffset
=
=
0
)
{
*
aStartOffset
=
FindWordBoundary
(
convertedOffset
eDirNext
eEndWord
)
;
*
aEndOffset
=
FindWordBoundary
(
*
aStartOffset
eDirNext
eEndWord
)
;
}
else
{
*
aEndOffset
=
FindWordBoundary
(
convertedOffset
eDirNext
eEndWord
)
;
*
aStartOffset
=
FindWordBoundary
(
*
aEndOffset
eDirPrevious
eEndWord
)
;
if
(
*
aStartOffset
!
=
static_cast
<
int32_t
>
(
convertedOffset
)
)
{
*
aStartOffset
=
*
aEndOffset
;
*
aEndOffset
=
FindWordBoundary
(
*
aStartOffset
eDirNext
eEndWord
)
;
}
}
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
case
nsIAccessibleText
:
:
BOUNDARY_LINE_START
:
*
aStartOffset
=
FindLineBoundary
(
adjustedOffset
eNextLineBegin
)
;
*
aEndOffset
=
FindLineBoundary
(
*
aStartOffset
eNextLineBegin
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
case
nsIAccessibleText
:
:
BOUNDARY_LINE_END
:
*
aStartOffset
=
FindLineBoundary
(
adjustedOffset
eThisLineEnd
)
;
*
aEndOffset
=
FindLineBoundary
(
adjustedOffset
eNextLineEnd
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
break
;
}
}
already_AddRefed
<
AccAttributes
>
HyperTextAccessible
:
:
TextAttributes
(
bool
aIncludeDefAttrs
int32_t
aOffset
int32_t
*
aStartOffset
int32_t
*
aEndOffset
)
{
if
(
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
{
return
HyperTextAccessibleBase
:
:
TextAttributes
(
aIncludeDefAttrs
aOffset
aStartOffset
aEndOffset
)
;
}
RefPtr
<
AccAttributes
>
attributes
=
new
AccAttributes
(
)
;
*
aStartOffset
=
*
aEndOffset
=
0
;
index_t
offset
=
ConvertMagicOffset
(
aOffset
)
;
if
(
!
offset
.
IsValid
(
)
|
|
offset
>
CharacterCount
(
)
)
{
NS_ERROR
(
"
Wrong
in
offset
!
"
)
;
return
attributes
.
forget
(
)
;
}
LocalAccessible
*
accAtOffset
=
GetChildAtOffset
(
offset
)
;
if
(
!
accAtOffset
)
{
if
(
offset
=
=
0
)
{
if
(
aIncludeDefAttrs
)
{
TextAttrsMgr
textAttrsMgr
(
this
)
;
textAttrsMgr
.
GetAttributes
(
attributes
)
;
}
}
return
attributes
.
forget
(
)
;
}
int32_t
accAtOffsetIdx
=
accAtOffset
-
>
IndexInParent
(
)
;
uint32_t
startOffset
=
GetChildOffset
(
accAtOffsetIdx
)
;
uint32_t
endOffset
=
GetChildOffset
(
accAtOffsetIdx
+
1
)
;
int32_t
offsetInAcc
=
offset
-
startOffset
;
TextAttrsMgr
textAttrsMgr
(
this
aIncludeDefAttrs
accAtOffset
accAtOffsetIdx
)
;
textAttrsMgr
.
GetAttributes
(
attributes
&
startOffset
&
endOffset
)
;
nsIFrame
*
offsetFrame
=
accAtOffset
-
>
GetFrame
(
)
;
if
(
offsetFrame
&
&
offsetFrame
-
>
IsTextFrame
(
)
)
{
int32_t
nodeOffset
=
0
;
RenderedToContentOffset
(
offsetFrame
offsetInAcc
&
nodeOffset
)
;
MOZ_DIAGNOSTIC_ASSERT
(
accAtOffset
-
>
GetNode
(
)
-
>
IsText
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
nodeOffset
>
=
0
)
;
GetSpellTextAttr
(
accAtOffset
-
>
GetNode
(
)
static_cast
<
uint32_t
>
(
nodeOffset
)
&
startOffset
&
endOffset
attributes
)
;
}
*
aStartOffset
=
startOffset
;
*
aEndOffset
=
endOffset
;
return
attributes
.
forget
(
)
;
}
already_AddRefed
<
AccAttributes
>
HyperTextAccessible
:
:
DefaultTextAttributes
(
)
{
RefPtr
<
AccAttributes
>
attributes
=
new
AccAttributes
(
)
;
TextAttrsMgr
textAttrsMgr
(
this
)
;
textAttrsMgr
.
GetAttributes
(
attributes
)
;
return
attributes
.
forget
(
)
;
}
void
HyperTextAccessible
:
:
SetMathMLXMLRoles
(
AccAttributes
*
aAttributes
)
{
LocalAccessible
*
parent
=
LocalParent
(
)
;
if
(
parent
)
{
switch
(
parent
-
>
Role
(
)
)
{
case
roles
:
:
MATHML_CELL
:
case
roles
:
:
MATHML_ENCLOSED
:
case
roles
:
:
MATHML_ERROR
:
case
roles
:
:
MATHML_MATH
:
case
roles
:
:
MATHML_ROW
:
case
roles
:
:
MATHML_SQUARE_ROOT
:
case
roles
:
:
MATHML_STYLE
:
if
(
Role
(
)
=
=
roles
:
:
MATHML_OPERATOR
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
GetFrame
(
)
)
;
if
(
mathMLFrame
)
{
nsEmbellishData
embellishData
;
mathMLFrame
-
>
GetEmbellishData
(
embellishData
)
;
if
(
NS_MATHML_EMBELLISH_IS_FENCE
(
embellishData
.
flags
)
)
{
if
(
!
LocalPrevSibling
(
)
)
{
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
nsGkAtoms
:
:
open_fence
)
;
}
else
if
(
!
LocalNextSibling
(
)
)
{
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
nsGkAtoms
:
:
close_fence
)
;
}
}
if
(
NS_MATHML_EMBELLISH_IS_SEPARATOR
(
embellishData
.
flags
)
)
{
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
nsGkAtoms
:
:
separator_
)
;
}
}
}
break
;
case
roles
:
:
MATHML_FRACTION
:
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
IndexInParent
(
)
=
=
0
?
nsGkAtoms
:
:
numerator
:
nsGkAtoms
:
:
denominator
)
;
break
;
case
roles
:
:
MATHML_ROOT
:
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
IndexInParent
(
)
=
=
0
?
nsGkAtoms
:
:
base
:
nsGkAtoms
:
:
root_index
)
;
break
;
case
roles
:
:
MATHML_SUB
:
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
IndexInParent
(
)
=
=
0
?
nsGkAtoms
:
:
base
:
nsGkAtoms
:
:
subscript
)
;
break
;
case
roles
:
:
MATHML_SUP
:
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
IndexInParent
(
)
=
=
0
?
nsGkAtoms
:
:
base
:
nsGkAtoms
:
:
superscript
)
;
break
;
case
roles
:
:
MATHML_SUB_SUP
:
{
int32_t
index
=
IndexInParent
(
)
;
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
index
=
=
0
?
nsGkAtoms
:
:
base
:
(
index
=
=
1
?
nsGkAtoms
:
:
subscript
:
nsGkAtoms
:
:
superscript
)
)
;
}
break
;
case
roles
:
:
MATHML_UNDER
:
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
IndexInParent
(
)
=
=
0
?
nsGkAtoms
:
:
base
:
nsGkAtoms
:
:
underscript
)
;
break
;
case
roles
:
:
MATHML_OVER
:
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
IndexInParent
(
)
=
=
0
?
nsGkAtoms
:
:
base
:
nsGkAtoms
:
:
overscript
)
;
break
;
case
roles
:
:
MATHML_UNDER_OVER
:
{
int32_t
index
=
IndexInParent
(
)
;
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
index
=
=
0
?
nsGkAtoms
:
:
base
:
(
index
=
=
1
?
nsGkAtoms
:
:
underscript
:
nsGkAtoms
:
:
overscript
)
)
;
}
break
;
case
roles
:
:
MATHML_MULTISCRIPTS
:
{
nsIContent
*
child
;
bool
baseFound
=
false
;
for
(
child
=
parent
-
>
GetContent
(
)
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsMathMLElement
(
)
)
{
baseFound
=
true
;
break
;
}
}
if
(
baseFound
)
{
nsIContent
*
content
=
GetContent
(
)
;
if
(
child
=
=
content
)
{
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
nsGkAtoms
:
:
base
)
;
}
else
{
bool
postscript
=
true
;
bool
subscript
=
true
;
for
(
child
=
child
-
>
GetNextSibling
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
!
child
-
>
IsMathMLElement
(
)
)
continue
;
if
(
child
-
>
IsMathMLElement
(
nsGkAtoms
:
:
mprescripts_
)
)
{
postscript
=
false
;
subscript
=
true
;
continue
;
}
if
(
child
=
=
content
)
{
if
(
postscript
)
{
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
subscript
?
nsGkAtoms
:
:
subscript
:
nsGkAtoms
:
:
superscript
)
;
}
else
{
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
subscript
?
nsGkAtoms
:
:
presubscript
:
nsGkAtoms
:
:
presuperscript
)
;
}
break
;
}
subscript
=
!
subscript
;
}
}
}
}
break
;
default
:
break
;
}
}
}
already_AddRefed
<
AccAttributes
>
HyperTextAccessible
:
:
NativeAttributes
(
)
{
RefPtr
<
AccAttributes
>
attributes
=
AccessibleWrap
:
:
NativeAttributes
(
)
;
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsBlockFrame
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
formatting
nsGkAtoms
:
:
block
)
;
}
if
(
FocusMgr
(
)
-
>
IsFocused
(
this
)
)
{
int32_t
lineNumber
=
CaretLineNumber
(
)
;
if
(
lineNumber
>
=
1
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
lineNumber
lineNumber
)
;
}
}
if
(
HasOwnContent
(
)
)
{
GetAccService
(
)
-
>
MarkupAttributes
(
this
attributes
)
;
if
(
mContent
-
>
IsMathMLElement
(
)
)
SetMathMLXMLRoles
(
attributes
)
;
}
return
attributes
.
forget
(
)
;
}
int32_t
HyperTextAccessible
:
:
OffsetAtPoint
(
int32_t
aX
int32_t
aY
uint32_t
aCoordType
)
{
nsIFrame
*
hyperFrame
=
GetFrame
(
)
;
if
(
!
hyperFrame
)
return
-
1
;
LayoutDeviceIntPoint
coords
=
nsAccUtils
:
:
ConvertToScreenCoords
(
aX
aY
aCoordType
this
)
;
nsPresContext
*
presContext
=
mDoc
-
>
PresContext
(
)
;
nsPoint
coordsInAppUnits
=
LayoutDeviceIntPoint
:
:
ToAppUnits
(
coords
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
nsRect
frameScreenRect
=
hyperFrame
-
>
GetScreenRectInAppUnits
(
)
;
if
(
!
frameScreenRect
.
Contains
(
coordsInAppUnits
.
x
coordsInAppUnits
.
y
)
)
{
return
-
1
;
}
nsPoint
pointInHyperText
(
coordsInAppUnits
.
x
-
frameScreenRect
.
X
(
)
coordsInAppUnits
.
y
-
frameScreenRect
.
Y
(
)
)
;
int32_t
offset
=
0
;
uint32_t
childCount
=
ChildCount
(
)
;
for
(
uint32_t
childIdx
=
0
;
childIdx
<
childCount
;
childIdx
+
+
)
{
LocalAccessible
*
childAcc
=
mChildren
[
childIdx
]
;
nsIFrame
*
primaryFrame
=
childAcc
-
>
GetFrame
(
)
;
NS_ENSURE_TRUE
(
primaryFrame
-
1
)
;
nsIFrame
*
frame
=
primaryFrame
;
while
(
frame
)
{
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
NS_ENSURE_TRUE
(
content
-
1
)
;
nsPoint
pointInFrame
=
pointInHyperText
-
frame
-
>
GetOffsetTo
(
hyperFrame
)
;
nsSize
frameSize
=
frame
-
>
GetSize
(
)
;
if
(
pointInFrame
.
x
<
frameSize
.
width
&
&
pointInFrame
.
y
<
frameSize
.
height
)
{
if
(
frame
-
>
IsTextFrame
(
)
)
{
nsIFrame
:
:
ContentOffsets
contentOffsets
=
frame
-
>
GetContentOffsetsFromPointExternal
(
pointInFrame
nsIFrame
:
:
IGNORE_SELECTION_STYLE
)
;
if
(
contentOffsets
.
IsNull
(
)
|
|
contentOffsets
.
content
!
=
content
)
{
return
-
1
;
}
uint32_t
addToOffset
;
nsresult
rv
=
ContentToRenderedOffset
(
primaryFrame
contentOffsets
.
offset
&
addToOffset
)
;
NS_ENSURE_SUCCESS
(
rv
-
1
)
;
offset
+
=
addToOffset
;
}
return
offset
;
}
frame
=
frame
-
>
GetNextContinuation
(
)
;
}
offset
+
=
nsAccUtils
:
:
TextLength
(
childAcc
)
;
}
return
-
1
;
}
LayoutDeviceIntRect
HyperTextAccessible
:
:
TextBounds
(
int32_t
aStartOffset
int32_t
aEndOffset
uint32_t
aCoordType
)
{
index_t
startOffset
=
ConvertMagicOffset
(
aStartOffset
)
;
index_t
endOffset
=
ConvertMagicOffset
(
aEndOffset
)
;
if
(
!
startOffset
.
IsValid
(
)
|
|
!
endOffset
.
IsValid
(
)
|
|
startOffset
>
endOffset
|
|
endOffset
>
CharacterCount
(
)
)
{
NS_ERROR
(
"
Wrong
in
offset
"
)
;
return
LayoutDeviceIntRect
(
)
;
}
if
(
CharacterCount
(
)
=
=
0
)
{
nsPresContext
*
presContext
=
mDoc
-
>
PresContext
(
)
;
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
!
frame
)
{
return
LayoutDeviceIntRect
(
)
;
}
return
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
frame
-
>
GetScreenRectInAppUnits
(
)
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
}
int32_t
childIdx
=
GetChildIndexAtOffset
(
startOffset
)
;
if
(
childIdx
=
=
-
1
)
return
LayoutDeviceIntRect
(
)
;
LayoutDeviceIntRect
bounds
;
int32_t
prevOffset
=
GetChildOffset
(
childIdx
)
;
int32_t
offset1
=
startOffset
-
prevOffset
;
while
(
childIdx
<
static_cast
<
int32_t
>
(
ChildCount
(
)
)
)
{
nsIFrame
*
frame
=
LocalChildAt
(
childIdx
+
+
)
-
>
GetFrame
(
)
;
if
(
!
frame
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
frame
for
a
child
!
"
)
;
continue
;
}
int32_t
nextOffset
=
GetChildOffset
(
childIdx
)
;
if
(
nextOffset
>
=
static_cast
<
int32_t
>
(
endOffset
)
)
{
bounds
.
UnionRect
(
bounds
GetBoundsInFrame
(
frame
offset1
endOffset
-
prevOffset
)
)
;
break
;
}
bounds
.
UnionRect
(
bounds
GetBoundsInFrame
(
frame
offset1
nextOffset
-
prevOffset
)
)
;
prevOffset
=
nextOffset
;
offset1
=
0
;
}
nsPresContext
*
presContext
=
mDoc
-
>
PresContext
(
)
;
nsIFrame
*
rootFrame
=
presContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
LayoutDeviceIntRect
orgRectPixels
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
rootFrame
-
>
GetScreenRectInAppUnits
(
)
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
bounds
.
MoveBy
(
-
orgRectPixels
.
X
(
)
-
orgRectPixels
.
Y
(
)
)
;
bounds
.
ScaleRoundOut
(
presContext
-
>
PresShell
(
)
-
>
GetResolution
(
)
)
;
bounds
.
MoveBy
(
orgRectPixels
.
X
(
)
orgRectPixels
.
Y
(
)
)
;
auto
boundsX
=
bounds
.
X
(
)
;
auto
boundsY
=
bounds
.
Y
(
)
;
nsAccUtils
:
:
ConvertScreenCoordsTo
(
&
boundsX
&
boundsY
aCoordType
this
)
;
bounds
.
MoveTo
(
boundsX
boundsY
)
;
return
bounds
;
}
already_AddRefed
<
EditorBase
>
HyperTextAccessible
:
:
GetEditor
(
)
const
{
if
(
!
mContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
LocalAccessible
*
ancestor
=
LocalParent
(
)
;
while
(
ancestor
)
{
HyperTextAccessible
*
hyperText
=
ancestor
-
>
AsHyperText
(
)
;
if
(
hyperText
)
{
return
hyperText
-
>
GetEditor
(
)
;
}
ancestor
=
ancestor
-
>
LocalParent
(
)
;
}
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
nsCoreUtils
:
:
GetDocShellFor
(
mContent
)
;
nsCOMPtr
<
nsIEditingSession
>
editingSession
;
docShell
-
>
GetEditingSession
(
getter_AddRefs
(
editingSession
)
)
;
if
(
!
editingSession
)
return
nullptr
;
dom
:
:
Document
*
docNode
=
mDoc
-
>
DocumentNode
(
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
editingSession
-
>
GetHTMLEditorForWindow
(
docNode
-
>
GetWindow
(
)
)
;
return
htmlEditor
.
forget
(
)
;
}
nsresult
HyperTextAccessible
:
:
SetSelectionRange
(
int32_t
aStartPos
int32_t
aEndPos
)
{
RefPtr
<
EditorBase
>
editorBase
=
GetEditor
(
)
;
bool
isFocusable
=
InteractiveState
(
)
&
states
:
:
FOCUSABLE
;
if
(
isFocusable
)
TakeFocus
(
)
;
RefPtr
<
dom
:
:
Selection
>
domSel
=
DOMSelection
(
)
;
NS_ENSURE_STATE
(
domSel
)
;
for
(
const
uint32_t
idx
:
Reversed
(
IntegerRange
(
1u
domSel
-
>
RangeCount
(
)
)
)
)
{
MOZ_ASSERT
(
domSel
-
>
RangeCount
(
)
=
=
idx
+
1
)
;
RefPtr
<
nsRange
>
range
{
domSel
-
>
GetRangeAt
(
idx
)
}
;
if
(
!
range
)
{
break
;
}
domSel
-
>
RemoveRangeAndUnselectFramesAndNotifyListeners
(
*
range
IgnoreErrors
(
)
)
;
}
SetSelectionBoundsAt
(
0
aStartPos
aEndPos
)
;
domSel
-
>
ScrollIntoView
(
nsISelectionController
:
:
SELECTION_FOCUS_REGION
ScrollAxis
(
)
ScrollAxis
(
)
dom
:
:
Selection
:
:
SCROLL_FOR_CARET_MOVE
|
dom
:
:
Selection
:
:
SCROLL_OVERFLOW_HIDDEN
)
;
if
(
isFocusable
)
return
NS_OK
;
nsFocusManager
*
DOMFocusManager
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
DOMFocusManager
)
{
NS_ENSURE_TRUE
(
mDoc
NS_ERROR_FAILURE
)
;
dom
:
:
Document
*
docNode
=
mDoc
-
>
DocumentNode
(
)
;
NS_ENSURE_TRUE
(
docNode
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
docNode
-
>
GetWindow
(
)
;
RefPtr
<
dom
:
:
Element
>
result
;
DOMFocusManager
-
>
MoveFocus
(
window
nullptr
nsIFocusManager
:
:
MOVEFOCUS_CARET
nsIFocusManager
:
:
FLAG_BYMOVEFOCUS
getter_AddRefs
(
result
)
)
;
}
return
NS_OK
;
}
int32_t
HyperTextAccessible
:
:
CaretOffset
(
)
const
{
if
(
!
IsDoc
(
)
&
&
!
FocusMgr
(
)
-
>
IsFocused
(
this
)
&
&
(
InteractiveState
(
)
&
states
:
:
FOCUSABLE
)
)
{
return
-
1
;
}
int32_t
caretOffset
=
-
1
;
HyperTextAccessible
*
text
=
SelectionMgr
(
)
-
>
AccessibleWithCaret
(
&
caretOffset
)
;
if
(
caretOffset
!
=
-
1
)
{
if
(
text
=
=
this
)
return
caretOffset
;
nsINode
*
textNode
=
text
-
>
GetNode
(
)
;
if
(
nsCoreUtils
:
:
IsAncestorOf
(
GetNode
(
)
textNode
)
)
{
return
TransformOffset
(
text
textNode
-
>
IsText
(
)
?
caretOffset
:
0
false
)
;
}
}
FocusManager
:
:
FocusDisposition
focusDisp
=
FocusMgr
(
)
-
>
IsInOrContainsFocus
(
this
)
;
if
(
focusDisp
=
=
FocusManager
:
:
eNone
)
return
-
1
;
dom
:
:
Selection
*
domSel
=
DOMSelection
(
)
;
NS_ENSURE_TRUE
(
domSel
-
1
)
;
nsINode
*
focusNode
=
domSel
-
>
GetFocusNode
(
)
;
uint32_t
focusOffset
=
domSel
-
>
FocusOffset
(
)
;
if
(
focusDisp
=
=
FocusManager
:
:
eContainedByFocus
)
{
nsINode
*
resultNode
=
nsCoreUtils
:
:
GetDOMNodeFromDOMPoint
(
focusNode
focusOffset
)
;
nsINode
*
thisNode
=
GetNode
(
)
;
if
(
resultNode
!
=
thisNode
&
&
!
nsCoreUtils
:
:
IsAncestorOf
(
thisNode
resultNode
)
)
{
return
-
1
;
}
}
return
DOMPointToOffset
(
focusNode
focusOffset
)
;
}
int32_t
HyperTextAccessible
:
:
CaretLineNumber
(
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
FrameSelection
(
)
;
if
(
!
frameSelection
)
return
-
1
;
dom
:
:
Selection
*
domSel
=
frameSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
!
domSel
)
return
-
1
;
nsINode
*
caretNode
=
domSel
-
>
GetFocusNode
(
)
;
if
(
!
caretNode
|
|
!
caretNode
-
>
IsContent
(
)
)
return
-
1
;
nsIContent
*
caretContent
=
caretNode
-
>
AsContent
(
)
;
if
(
!
nsCoreUtils
:
:
IsAncestorOf
(
GetNode
(
)
caretContent
)
)
return
-
1
;
int32_t
returnOffsetUnused
;
uint32_t
caretOffset
=
domSel
-
>
FocusOffset
(
)
;
CaretAssociationHint
hint
=
frameSelection
-
>
GetHint
(
)
;
nsIFrame
*
caretFrame
=
frameSelection
-
>
GetFrameForNodeOffset
(
caretContent
caretOffset
hint
&
returnOffsetUnused
)
;
NS_ENSURE_TRUE
(
caretFrame
-
1
)
;
AutoAssertNoDomMutations
guard
;
int32_t
lineNumber
=
1
;
nsILineIterator
*
lineIterForCaret
=
nullptr
;
nsIContent
*
hyperTextContent
=
IsContent
(
)
?
mContent
.
get
(
)
:
nullptr
;
while
(
caretFrame
)
{
if
(
hyperTextContent
=
=
caretFrame
-
>
GetContent
(
)
)
{
return
lineNumber
;
}
nsContainerFrame
*
parentFrame
=
caretFrame
-
>
GetParent
(
)
;
if
(
!
parentFrame
)
break
;
nsIFrame
*
sibling
=
parentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
while
(
sibling
&
&
sibling
!
=
caretFrame
)
{
nsILineIterator
*
lineIterForSibling
=
sibling
-
>
GetLineIterator
(
)
;
if
(
lineIterForSibling
)
{
int32_t
addLines
=
lineIterForSibling
-
>
GetNumLines
(
)
;
lineNumber
+
=
addLines
;
}
sibling
=
sibling
-
>
GetNextSibling
(
)
;
}
if
(
!
lineIterForCaret
)
{
lineIterForCaret
=
parentFrame
-
>
GetLineIterator
(
)
;
if
(
lineIterForCaret
)
{
int32_t
addLines
=
lineIterForCaret
-
>
FindLineContaining
(
caretFrame
)
;
lineNumber
+
=
addLines
;
}
}
caretFrame
=
parentFrame
;
}
MOZ_ASSERT_UNREACHABLE
(
"
DOM
ancestry
had
this
hypertext
but
frame
ancestry
didn
'
t
"
)
;
return
lineNumber
;
}
LayoutDeviceIntRect
HyperTextAccessible
:
:
GetCaretRect
(
nsIWidget
*
*
aWidget
)
{
*
aWidget
=
nullptr
;
RefPtr
<
nsCaret
>
caret
=
mDoc
-
>
PresShellPtr
(
)
-
>
GetCaret
(
)
;
NS_ENSURE_TRUE
(
caret
LayoutDeviceIntRect
(
)
)
;
bool
isVisible
=
caret
-
>
IsVisible
(
)
;
if
(
!
isVisible
)
return
LayoutDeviceIntRect
(
)
;
nsRect
rect
;
nsIFrame
*
frame
=
caret
-
>
GetGeometry
(
&
rect
)
;
if
(
!
frame
|
|
rect
.
IsEmpty
(
)
)
return
LayoutDeviceIntRect
(
)
;
nsPoint
offset
;
*
aWidget
=
frame
-
>
GetNearestWidget
(
offset
)
;
NS_ENSURE_TRUE
(
*
aWidget
LayoutDeviceIntRect
(
)
)
;
rect
.
MoveBy
(
offset
)
;
LayoutDeviceIntRect
caretRect
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
rect
.
ToOutsidePixels
(
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
)
;
caretRect
.
MoveBy
(
(
*
aWidget
)
-
>
WidgetToScreenOffset
(
)
-
(
*
aWidget
)
-
>
GetClientOffset
(
)
)
;
int32_t
caretOffset
=
CaretOffset
(
)
;
if
(
NS_WARN_IF
(
caretOffset
=
=
-
1
)
)
{
return
LayoutDeviceIntRect
(
)
;
}
LayoutDeviceIntRect
charRect
=
CharBounds
(
caretOffset
nsIAccessibleCoordinateType
:
:
COORDTYPE_SCREEN_RELATIVE
)
;
if
(
!
charRect
.
IsEmpty
(
)
)
{
caretRect
.
SetTopEdge
(
charRect
.
Y
(
)
)
;
}
return
caretRect
;
}
void
HyperTextAccessible
:
:
GetSelectionDOMRanges
(
SelectionType
aSelectionType
nsTArray
<
nsRange
*
>
*
aRanges
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
FrameSelection
(
)
;
if
(
!
frameSelection
|
|
frameSelection
-
>
GetDisplaySelection
(
)
<
=
nsISelectionController
:
:
SELECTION_HIDDEN
)
{
return
;
}
dom
:
:
Selection
*
domSel
=
frameSelection
-
>
GetSelection
(
aSelectionType
)
;
if
(
!
domSel
)
return
;
nsINode
*
startNode
=
GetNode
(
)
;
RefPtr
<
EditorBase
>
editorBase
=
GetEditor
(
)
;
if
(
editorBase
)
{
startNode
=
editorBase
-
>
GetRoot
(
)
;
}
if
(
!
startNode
)
return
;
uint32_t
childCount
=
startNode
-
>
GetChildCount
(
)
;
nsresult
rv
=
domSel
-
>
GetRangesForIntervalArray
(
startNode
0
startNode
childCount
true
aRanges
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
aRanges
-
>
RemoveElementsBy
(
[
]
(
const
auto
&
range
)
{
return
range
-
>
Collapsed
(
)
;
}
)
;
}
int32_t
HyperTextAccessible
:
:
SelectionCount
(
)
{
nsTArray
<
nsRange
*
>
ranges
;
GetSelectionDOMRanges
(
SelectionType
:
:
eNormal
&
ranges
)
;
return
ranges
.
Length
(
)
;
}
bool
HyperTextAccessible
:
:
SelectionBoundsAt
(
int32_t
aSelectionNum
int32_t
*
aStartOffset
int32_t
*
aEndOffset
)
{
*
aStartOffset
=
*
aEndOffset
=
0
;
nsTArray
<
nsRange
*
>
ranges
;
GetSelectionDOMRanges
(
SelectionType
:
:
eNormal
&
ranges
)
;
uint32_t
rangeCount
=
ranges
.
Length
(
)
;
if
(
aSelectionNum
<
0
|
|
aSelectionNum
>
=
static_cast
<
int32_t
>
(
rangeCount
)
)
{
return
false
;
}
nsRange
*
range
=
ranges
[
aSelectionNum
]
;
nsINode
*
startNode
=
range
-
>
GetStartContainer
(
)
;
nsINode
*
endNode
=
range
-
>
GetEndContainer
(
)
;
uint32_t
startOffset
=
range
-
>
StartOffset
(
)
;
uint32_t
endOffset
=
range
-
>
EndOffset
(
)
;
const
Maybe
<
int32_t
>
order
=
nsContentUtils
:
:
ComparePoints
(
endNode
endOffset
startNode
startOffset
)
;
if
(
!
order
)
{
MOZ_ASSERT_UNREACHABLE
(
)
;
return
false
;
}
if
(
*
order
<
0
)
{
std
:
:
swap
(
startNode
endNode
)
;
std
:
:
swap
(
startOffset
endOffset
)
;
}
if
(
!
startNode
-
>
IsInclusiveDescendantOf
(
mContent
)
)
{
*
aStartOffset
=
0
;
}
else
{
*
aStartOffset
=
DOMPointToOffset
(
startNode
AssertedCast
<
int32_t
>
(
startOffset
)
)
;
}
if
(
!
endNode
-
>
IsInclusiveDescendantOf
(
mContent
)
)
{
*
aEndOffset
=
CharacterCount
(
)
;
}
else
{
*
aEndOffset
=
DOMPointToOffset
(
endNode
AssertedCast
<
int32_t
>
(
endOffset
)
true
)
;
}
return
true
;
}
bool
HyperTextAccessible
:
:
SetSelectionBoundsAt
(
int32_t
aSelectionNum
int32_t
aStartOffset
int32_t
aEndOffset
)
{
index_t
startOffset
=
ConvertMagicOffset
(
aStartOffset
)
;
index_t
endOffset
=
ConvertMagicOffset
(
aEndOffset
)
;
if
(
!
startOffset
.
IsValid
(
)
|
|
!
endOffset
.
IsValid
(
)
|
|
std
:
:
max
(
startOffset
endOffset
)
>
CharacterCount
(
)
)
{
NS_ERROR
(
"
Wrong
in
offset
"
)
;
return
false
;
}
TextRange
range
(
this
this
startOffset
this
endOffset
)
;
return
range
.
SetSelectionAt
(
aSelectionNum
)
;
}
bool
HyperTextAccessible
:
:
RemoveFromSelection
(
int32_t
aSelectionNum
)
{
RefPtr
<
dom
:
:
Selection
>
domSel
=
DOMSelection
(
)
;
if
(
!
domSel
)
return
false
;
if
(
aSelectionNum
<
0
|
|
aSelectionNum
>
=
static_cast
<
int32_t
>
(
domSel
-
>
RangeCount
(
)
)
)
{
return
false
;
}
const
RefPtr
<
nsRange
>
range
{
domSel
-
>
GetRangeAt
(
static_cast
<
uint32_t
>
(
aSelectionNum
)
)
}
;
domSel
-
>
RemoveRangeAndUnselectFramesAndNotifyListeners
(
*
range
IgnoreErrors
(
)
)
;
return
true
;
}
void
HyperTextAccessible
:
:
ScrollSubstringTo
(
int32_t
aStartOffset
int32_t
aEndOffset
uint32_t
aScrollType
)
{
TextRange
range
(
this
this
aStartOffset
this
aEndOffset
)
;
range
.
ScrollIntoView
(
aScrollType
)
;
}
void
HyperTextAccessible
:
:
ScrollSubstringToPoint
(
int32_t
aStartOffset
int32_t
aEndOffset
uint32_t
aCoordinateType
int32_t
aX
int32_t
aY
)
{
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
!
frame
)
return
;
LayoutDeviceIntPoint
coords
=
nsAccUtils
:
:
ConvertToScreenCoords
(
aX
aY
aCoordinateType
this
)
;
RefPtr
<
nsRange
>
domRange
=
nsRange
:
:
Create
(
mContent
)
;
TextRange
range
(
this
this
aStartOffset
this
aEndOffset
)
;
if
(
!
range
.
AssignDOMRange
(
domRange
)
)
{
return
;
}
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
nsPoint
coordsInAppUnits
=
LayoutDeviceIntPoint
:
:
ToAppUnits
(
coords
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
bool
initialScrolled
=
false
;
nsIFrame
*
parentFrame
=
frame
;
while
(
(
parentFrame
=
parentFrame
-
>
GetParent
(
)
)
)
{
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
parentFrame
)
;
if
(
scrollableFrame
)
{
if
(
!
initialScrolled
)
{
nsRect
frameRect
=
parentFrame
-
>
GetScreenRectInAppUnits
(
)
;
nscoord
offsetPointX
=
coordsInAppUnits
.
x
-
frameRect
.
X
(
)
;
nscoord
offsetPointY
=
coordsInAppUnits
.
y
-
frameRect
.
Y
(
)
;
nsSize
size
(
parentFrame
-
>
GetSize
(
)
)
;
size
.
width
=
size
.
width
?
size
.
width
:
1
;
size
.
height
=
size
.
height
?
size
.
height
:
1
;
int16_t
hPercent
=
offsetPointX
*
100
/
size
.
width
;
int16_t
vPercent
=
offsetPointY
*
100
/
size
.
height
;
nsresult
rv
=
nsCoreUtils
:
:
ScrollSubstringTo
(
frame
domRange
ScrollAxis
(
vPercent
WhenToScroll
:
:
Always
)
ScrollAxis
(
hPercent
WhenToScroll
:
:
Always
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
initialScrolled
=
true
;
}
else
{
nsCoreUtils
:
:
ScrollFrameToPoint
(
parentFrame
frame
coords
)
;
}
}
frame
=
parentFrame
;
}
}
void
HyperTextAccessible
:
:
EnclosingRange
(
a11y
:
:
TextRange
&
aRange
)
const
{
if
(
IsTextField
(
)
)
{
aRange
.
Set
(
mDoc
const_cast
<
HyperTextAccessible
*
>
(
this
)
0
const_cast
<
HyperTextAccessible
*
>
(
this
)
CharacterCount
(
)
)
;
}
else
{
aRange
.
Set
(
mDoc
mDoc
0
mDoc
mDoc
-
>
CharacterCount
(
)
)
;
}
}
void
HyperTextAccessible
:
:
SelectionRanges
(
nsTArray
<
a11y
:
:
TextRange
>
*
aRanges
)
const
{
dom
:
:
Selection
*
sel
=
DOMSelection
(
)
;
if
(
!
sel
)
{
return
;
}
TextRange
:
:
TextRangesFromSelection
(
sel
aRanges
)
;
}
void
HyperTextAccessible
:
:
VisibleRanges
(
nsTArray
<
a11y
:
:
TextRange
>
*
aRanges
)
const
{
}
void
HyperTextAccessible
:
:
RangeByChild
(
LocalAccessible
*
aChild
a11y
:
:
TextRange
&
aRange
)
const
{
HyperTextAccessible
*
ht
=
aChild
-
>
AsHyperText
(
)
;
if
(
ht
)
{
aRange
.
Set
(
mDoc
ht
0
ht
ht
-
>
CharacterCount
(
)
)
;
return
;
}
LocalAccessible
*
child
=
aChild
;
LocalAccessible
*
parent
=
nullptr
;
while
(
(
parent
=
child
-
>
LocalParent
(
)
)
&
&
!
(
ht
=
parent
-
>
AsHyperText
(
)
)
)
{
child
=
parent
;
}
if
(
ht
)
{
int32_t
childIdx
=
child
-
>
IndexInParent
(
)
;
int32_t
startOffset
=
ht
-
>
GetChildOffset
(
childIdx
)
;
int32_t
endOffset
=
child
-
>
IsTextLeaf
(
)
?
ht
-
>
GetChildOffset
(
childIdx
+
1
)
:
startOffset
;
aRange
.
Set
(
mDoc
ht
startOffset
ht
endOffset
)
;
}
}
void
HyperTextAccessible
:
:
RangeAtPoint
(
int32_t
aX
int32_t
aY
a11y
:
:
TextRange
&
aRange
)
const
{
LocalAccessible
*
child
=
mDoc
-
>
LocalChildAtPoint
(
aX
aY
EWhichChildAtPoint
:
:
DeepestChild
)
;
if
(
!
child
)
return
;
LocalAccessible
*
parent
=
nullptr
;
while
(
(
parent
=
child
-
>
LocalParent
(
)
)
&
&
!
parent
-
>
IsHyperText
(
)
)
{
child
=
parent
;
}
if
(
parent
)
{
HyperTextAccessible
*
ht
=
parent
-
>
AsHyperText
(
)
;
int32_t
offset
=
ht
-
>
GetChildOffset
(
child
)
;
aRange
.
Set
(
mDoc
ht
offset
ht
offset
)
;
}
}
ENameValueFlag
HyperTextAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
bool
hasImgAlt
=
false
;
if
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
)
{
hasImgAlt
=
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
alt
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
eNameOK
;
}
ENameValueFlag
nameFlag
=
AccessibleWrap
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
if
(
IsAbbreviation
(
)
&
&
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
title
aName
)
)
{
aName
.
CompressWhitespace
(
)
;
}
return
hasImgAlt
?
eNoNameOnPurpose
:
eNameOK
;
}
void
HyperTextAccessible
:
:
Shutdown
(
)
{
mOffsets
.
Clear
(
)
;
AccessibleWrap
:
:
Shutdown
(
)
;
}
bool
HyperTextAccessible
:
:
RemoveChild
(
LocalAccessible
*
aAccessible
)
{
InvalidateCachedHyperTextOffsets
(
)
;
return
AccessibleWrap
:
:
RemoveChild
(
aAccessible
)
;
}
bool
HyperTextAccessible
:
:
InsertChildAt
(
uint32_t
aIndex
LocalAccessible
*
aChild
)
{
InvalidateCachedHyperTextOffsets
(
)
;
return
AccessibleWrap
:
:
InsertChildAt
(
aIndex
aChild
)
;
}
Relation
HyperTextAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
LocalAccessible
:
:
RelationByType
(
aType
)
;
switch
(
aType
)
{
case
RelationType
:
:
NODE_CHILD_OF
:
if
(
HasOwnContent
(
)
&
&
mContent
-
>
IsMathMLElement
(
)
)
{
LocalAccessible
*
parent
=
LocalParent
(
)
;
if
(
parent
)
{
nsIContent
*
parentContent
=
parent
-
>
GetContent
(
)
;
if
(
parentContent
&
&
parentContent
-
>
IsMathMLElement
(
nsGkAtoms
:
:
mroot_
)
)
{
rel
.
AppendTarget
(
parent
)
;
}
}
}
break
;
case
RelationType
:
:
NODE_PARENT_OF
:
if
(
HasOwnContent
(
)
&
&
mContent
-
>
IsMathMLElement
(
nsGkAtoms
:
:
mroot_
)
)
{
LocalAccessible
*
base
=
LocalChildAt
(
0
)
;
LocalAccessible
*
index
=
LocalChildAt
(
1
)
;
if
(
base
&
&
index
)
{
rel
.
AppendTarget
(
index
)
;
rel
.
AppendTarget
(
base
)
;
}
}
break
;
default
:
break
;
}
return
rel
;
}
nsresult
HyperTextAccessible
:
:
ContentToRenderedOffset
(
nsIFrame
*
aFrame
int32_t
aContentOffset
uint32_t
*
aRenderedOffset
)
const
{
if
(
!
aFrame
)
{
*
aRenderedOffset
=
0
;
return
NS_OK
;
}
if
(
IsTextField
(
)
)
{
*
aRenderedOffset
=
aContentOffset
;
return
NS_OK
;
}
NS_ASSERTION
(
aFrame
-
>
IsTextFrame
(
)
"
Need
text
frame
for
offset
conversion
"
)
;
NS_ASSERTION
(
aFrame
-
>
GetPrevContinuation
(
)
=
=
nullptr
"
Call
on
primary
frame
only
"
)
;
nsIFrame
:
:
RenderedText
text
=
aFrame
-
>
GetRenderedText
(
aContentOffset
aContentOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInContentText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
*
aRenderedOffset
=
text
.
mOffsetWithinNodeRenderedText
;
return
NS_OK
;
}
nsresult
HyperTextAccessible
:
:
RenderedToContentOffset
(
nsIFrame
*
aFrame
uint32_t
aRenderedOffset
int32_t
*
aContentOffset
)
const
{
if
(
IsTextField
(
)
)
{
*
aContentOffset
=
aRenderedOffset
;
return
NS_OK
;
}
*
aContentOffset
=
0
;
NS_ENSURE_TRUE
(
aFrame
NS_ERROR_FAILURE
)
;
NS_ASSERTION
(
aFrame
-
>
IsTextFrame
(
)
"
Need
text
frame
for
offset
conversion
"
)
;
NS_ASSERTION
(
aFrame
-
>
GetPrevContinuation
(
)
=
=
nullptr
"
Call
on
primary
frame
only
"
)
;
nsIFrame
:
:
RenderedText
text
=
aFrame
-
>
GetRenderedText
(
aRenderedOffset
aRenderedOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInRenderedText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
*
aContentOffset
=
text
.
mOffsetWithinNodeText
;
return
NS_OK
;
}
nsresult
HyperTextAccessible
:
:
GetDOMPointByFrameOffset
(
nsIFrame
*
aFrame
int32_t
aOffset
LocalAccessible
*
aAccessible
DOMPoint
*
aPoint
)
{
NS_ENSURE_ARG
(
aAccessible
)
;
if
(
!
aFrame
)
{
NS_ASSERTION
(
!
aAccessible
-
>
IsDoc
(
)
"
Shouldn
'
t
be
called
on
document
accessible
!
"
)
;
nsIContent
*
content
=
aAccessible
-
>
GetContent
(
)
;
NS_ASSERTION
(
content
"
Shouldn
'
t
operate
on
defunct
accessible
!
"
)
;
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
aPoint
-
>
idx
=
parent
-
>
ComputeIndexOf_Deprecated
(
content
)
+
1
;
aPoint
-
>
node
=
parent
;
}
else
if
(
aFrame
-
>
IsTextFrame
(
)
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
NS_ENSURE_STATE
(
content
)
;
nsIFrame
*
primaryFrame
=
content
-
>
GetPrimaryFrame
(
)
;
nsresult
rv
=
RenderedToContentOffset
(
primaryFrame
aOffset
&
(
aPoint
-
>
idx
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aPoint
-
>
node
=
content
;
}
else
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
NS_ENSURE_STATE
(
content
)
;
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
NS_ENSURE_STATE
(
parent
)
;
aPoint
-
>
idx
=
parent
-
>
ComputeIndexOf_Deprecated
(
content
)
;
aPoint
-
>
node
=
parent
;
}
return
NS_OK
;
}
void
HyperTextAccessible
:
:
GetSpellTextAttr
(
nsINode
*
aNode
uint32_t
aNodeOffset
uint32_t
*
aStartOffset
uint32_t
*
aEndOffset
AccAttributes
*
aAttributes
)
{
RefPtr
<
nsFrameSelection
>
fs
=
FrameSelection
(
)
;
if
(
!
fs
)
return
;
dom
:
:
Selection
*
domSel
=
fs
-
>
GetSelection
(
SelectionType
:
:
eSpellCheck
)
;
if
(
!
domSel
)
return
;
const
uint32_t
rangeCount
=
domSel
-
>
RangeCount
(
)
;
if
(
!
rangeCount
)
{
return
;
}
uint32_t
startOffset
=
0
endOffset
=
0
;
for
(
const
uint32_t
idx
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
domSel
-
>
RangeCount
(
)
=
=
rangeCount
)
;
const
nsRange
*
range
=
domSel
-
>
GetRangeAt
(
idx
)
;
MOZ_ASSERT
(
range
)
;
if
(
range
-
>
Collapsed
(
)
)
continue
;
nsINode
*
endNode
=
range
-
>
GetEndContainer
(
)
;
uint32_t
endNodeOffset
=
range
-
>
EndOffset
(
)
;
Maybe
<
int32_t
>
order
=
nsContentUtils
:
:
ComparePoints
(
aNode
aNodeOffset
endNode
endNodeOffset
)
;
if
(
NS_WARN_IF
(
!
order
)
)
{
continue
;
}
if
(
*
order
>
=
0
)
{
continue
;
}
nsINode
*
startNode
=
range
-
>
GetStartContainer
(
)
;
int32_t
startNodeOffset
=
range
-
>
StartOffset
(
)
;
order
=
nsContentUtils
:
:
ComparePoints
(
startNode
startNodeOffset
aNode
aNodeOffset
)
;
if
(
!
order
)
{
MOZ_ASSERT_UNREACHABLE
(
)
;
return
;
}
if
(
*
order
<
=
0
)
{
startOffset
=
DOMPointToOffset
(
startNode
startNodeOffset
)
;
endOffset
=
DOMPointToOffset
(
endNode
endNodeOffset
)
;
if
(
startOffset
>
*
aStartOffset
)
*
aStartOffset
=
startOffset
;
if
(
endOffset
<
*
aEndOffset
)
*
aEndOffset
=
endOffset
;
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
invalid
nsGkAtoms
:
:
spelling
)
;
return
;
}
endOffset
=
DOMPointToOffset
(
startNode
startNodeOffset
)
;
if
(
idx
>
0
)
{
const
nsRange
*
prevRange
=
domSel
-
>
GetRangeAt
(
idx
-
1
)
;
startOffset
=
DOMPointToOffset
(
prevRange
-
>
GetEndContainer
(
)
prevRange
-
>
EndOffset
(
)
)
;
}
if
(
startOffset
>
*
aStartOffset
&
&
startOffset
<
*
aEndOffset
)
{
*
aStartOffset
=
startOffset
;
}
if
(
endOffset
<
*
aEndOffset
)
*
aEndOffset
=
endOffset
;
return
;
}
const
nsRange
*
prevRange
=
domSel
-
>
GetRangeAt
(
rangeCount
-
1
)
;
startOffset
=
DOMPointToOffset
(
prevRange
-
>
GetEndContainer
(
)
prevRange
-
>
EndOffset
(
)
)
;
if
(
startOffset
>
*
aStartOffset
&
&
startOffset
<
*
aEndOffset
)
{
*
aStartOffset
=
startOffset
;
}
}
