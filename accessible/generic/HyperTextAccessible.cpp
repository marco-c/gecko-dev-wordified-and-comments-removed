#
include
"
HyperTextAccessible
-
inl
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
nsIAccessibleTypes
.
h
"
#
include
"
AccAttributes
.
h
"
#
include
"
HTMLListAccessible
.
h
"
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
Relation
.
h
"
#
include
"
mozilla
/
a11y
/
Role
.
h
"
#
include
"
States
.
h
"
#
include
"
TextAttrs
.
h
"
#
include
"
TextLeafRange
.
h
"
#
include
"
TextRange
.
h
"
#
include
"
TreeWalker
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIEditingSession
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsILineIterator
.
h
"
#
include
"
nsIMathMLFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ScrollContainerFrame
.
h
"
#
include
"
mozilla
/
SelectionMovementUtils
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
gfxSkipChars
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
HyperTextAccessible
:
:
HyperTextAccessible
(
nsIContent
*
aNode
DocAccessible
*
aDoc
)
:
AccessibleWrap
(
aNode
aDoc
)
{
mType
=
eHyperTextType
;
mGenericTypes
|
=
eHyperText
;
}
role
HyperTextAccessible
:
:
NativeRole
(
)
const
{
a11y
:
:
role
r
=
GetAccService
(
)
-
>
MarkupRole
(
mContent
)
;
if
(
r
!
=
roles
:
:
NOTHING
)
return
r
;
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsInlineFrame
(
)
)
return
roles
:
:
TEXT
;
return
roles
:
:
TEXT_CONTAINER
;
}
uint64_t
HyperTextAccessible
:
:
NativeState
(
)
const
{
uint64_t
states
=
AccessibleWrap
:
:
NativeState
(
)
;
if
(
IsEditable
(
)
)
{
states
|
=
states
:
:
EDITABLE
;
}
else
if
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
article
)
)
{
states
|
=
states
:
:
READONLY
;
}
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
(
states
&
states
:
:
EDITABLE
)
|
|
(
frame
&
&
frame
-
>
IsSelectable
(
nullptr
)
)
)
{
states
|
=
states
:
:
SELECTABLE_TEXT
;
}
return
states
;
}
bool
HyperTextAccessible
:
:
IsEditable
(
)
const
{
if
(
!
mContent
)
{
return
false
;
}
return
mContent
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
dom
:
:
ElementState
:
:
READWRITE
)
;
}
uint32_t
HyperTextAccessible
:
:
DOMPointToOffset
(
nsINode
*
aNode
int32_t
aNodeOffset
bool
aIsEndOffset
)
const
{
if
(
!
aNode
)
return
0
;
uint32_t
offset
=
0
;
nsINode
*
findNode
=
nullptr
;
if
(
aNodeOffset
=
=
-
1
)
{
findNode
=
aNode
;
}
else
if
(
aNode
-
>
IsText
(
)
)
{
nsIFrame
*
frame
=
aNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
frame
0
)
;
nsresult
rv
=
ContentToRenderedOffset
(
frame
aNodeOffset
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
0
)
;
findNode
=
aNode
;
}
else
{
findNode
=
aNode
-
>
GetChildAt_Deprecated
(
aNodeOffset
)
;
if
(
!
findNode
)
{
if
(
aNodeOffset
=
=
0
)
{
if
(
aNode
=
=
GetNode
(
)
)
{
return
0
;
}
findNode
=
aNode
;
}
else
if
(
aNodeOffset
=
=
static_cast
<
int32_t
>
(
aNode
-
>
GetChildCount
(
)
)
)
{
for
(
nsINode
*
tmpNode
=
aNode
;
!
findNode
&
&
tmpNode
&
&
tmpNode
!
=
mContent
;
tmpNode
=
tmpNode
-
>
GetParent
(
)
)
{
findNode
=
tmpNode
-
>
GetNextSibling
(
)
;
}
}
}
}
LocalAccessible
*
descendant
=
nullptr
;
if
(
findNode
)
{
dom
:
:
HTMLBRElement
*
brElement
=
dom
:
:
HTMLBRElement
:
:
FromNode
(
findNode
)
;
if
(
brElement
&
&
brElement
-
>
IsPaddingForEmptyEditor
(
)
)
{
return
0
;
}
descendant
=
mDoc
-
>
GetAccessible
(
findNode
)
;
if
(
!
descendant
&
&
findNode
-
>
IsContent
(
)
)
{
LocalAccessible
*
container
=
mDoc
-
>
GetContainerAccessible
(
findNode
)
;
if
(
container
)
{
TreeWalker
walker
(
container
findNode
-
>
AsContent
(
)
TreeWalker
:
:
eWalkContextTree
)
;
descendant
=
walker
.
Next
(
)
;
if
(
!
descendant
)
descendant
=
container
;
}
}
}
if
(
!
descendant
)
{
return
CharacterCount
(
)
;
}
if
(
aNode
-
>
IsText
(
)
&
&
descendant
-
>
GetContent
(
)
!
=
aNode
)
{
NS_WARNING
(
"
No
Accessible
for
DOM
text
node
"
)
;
offset
=
0
;
}
else
if
(
descendant
-
>
IsTextLeaf
(
)
)
{
uint32_t
length
=
nsAccUtils
:
:
TextLength
(
descendant
)
;
if
(
offset
>
length
)
{
NS_WARNING
(
"
Offset
too
large
for
text
leaf
"
)
;
offset
=
length
;
}
}
return
TransformOffset
(
descendant
offset
aIsEndOffset
)
;
}
uint32_t
HyperTextAccessible
:
:
TransformOffset
(
LocalAccessible
*
aDescendant
uint32_t
aOffset
bool
aIsEndOffset
)
const
{
uint32_t
offset
=
aOffset
;
LocalAccessible
*
descendant
=
aDescendant
;
while
(
descendant
)
{
LocalAccessible
*
parent
=
descendant
-
>
LocalParent
(
)
;
if
(
parent
=
=
this
)
return
GetChildOffset
(
descendant
)
+
offset
;
if
(
aIsEndOffset
)
{
if
(
offset
=
=
0
&
&
parent
&
&
parent
-
>
IsHTMLListItem
(
)
&
&
descendant
-
>
LocalPrevSibling
(
)
&
&
descendant
-
>
LocalPrevSibling
(
)
=
=
parent
-
>
AsHTMLListItem
(
)
-
>
Bullet
(
)
)
{
offset
=
0
;
}
else
{
offset
=
(
offset
>
0
|
|
descendant
-
>
IndexInParent
(
)
>
0
)
?
1
:
0
;
}
}
else
{
offset
=
0
;
}
descendant
=
parent
;
}
return
CharacterCount
(
)
;
}
DOMPoint
HyperTextAccessible
:
:
OffsetToDOMPoint
(
int32_t
aOffset
)
const
{
if
(
aOffset
=
=
0
)
{
RefPtr
<
EditorBase
>
editorBase
=
GetEditor
(
)
;
if
(
editorBase
)
{
if
(
editorBase
-
>
IsEmpty
(
)
)
{
return
DOMPoint
(
editorBase
-
>
GetRoot
(
)
0
)
;
}
}
}
int32_t
childIdx
=
GetChildIndexAtOffset
(
aOffset
)
;
if
(
childIdx
=
=
-
1
)
return
DOMPoint
(
)
;
LocalAccessible
*
child
=
LocalChildAt
(
childIdx
)
;
int32_t
innerOffset
=
aOffset
-
GetChildOffset
(
childIdx
)
;
if
(
child
-
>
IsTextLeaf
(
)
)
{
if
(
aOffset
<
GetChildOffset
(
childIdx
+
1
)
)
{
nsIContent
*
content
=
child
-
>
GetContent
(
)
;
int32_t
idx
=
0
;
if
(
NS_FAILED
(
RenderedToContentOffset
(
content
-
>
GetPrimaryFrame
(
)
innerOffset
&
idx
)
)
)
{
return
DOMPoint
(
)
;
}
return
DOMPoint
(
content
idx
)
;
}
MOZ_ASSERT
(
static_cast
<
uint32_t
>
(
aOffset
)
=
=
CharacterCount
(
)
)
;
innerOffset
=
1
;
}
NS_ASSERTION
(
innerOffset
=
=
0
|
|
innerOffset
=
=
1
"
A
wrong
inner
offset
!
"
)
;
nsINode
*
node
=
child
-
>
GetNode
(
)
;
nsINode
*
parentNode
=
node
-
>
GetParentNode
(
)
;
return
parentNode
?
DOMPoint
(
parentNode
parentNode
-
>
ComputeIndexOf_Deprecated
(
node
)
+
innerOffset
)
:
DOMPoint
(
)
;
}
already_AddRefed
<
AccAttributes
>
HyperTextAccessible
:
:
DefaultTextAttributes
(
)
{
RefPtr
<
AccAttributes
>
attributes
=
new
AccAttributes
(
)
;
TextAttrsMgr
textAttrsMgr
(
this
)
;
textAttrsMgr
.
GetAttributes
(
attributes
)
;
return
attributes
.
forget
(
)
;
}
void
HyperTextAccessible
:
:
SetMathMLXMLRoles
(
AccAttributes
*
aAttributes
)
{
LocalAccessible
*
parent
=
LocalParent
(
)
;
if
(
parent
)
{
switch
(
parent
-
>
Role
(
)
)
{
case
roles
:
:
MATHML_CELL
:
case
roles
:
:
MATHML_ENCLOSED
:
case
roles
:
:
MATHML_ERROR
:
case
roles
:
:
MATHML_MATH
:
case
roles
:
:
MATHML_ROW
:
case
roles
:
:
MATHML_SQUARE_ROOT
:
case
roles
:
:
MATHML_STYLE
:
if
(
Role
(
)
=
=
roles
:
:
MATHML_OPERATOR
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
GetFrame
(
)
)
;
if
(
mathMLFrame
)
{
nsEmbellishData
embellishData
;
mathMLFrame
-
>
GetEmbellishData
(
embellishData
)
;
if
(
NS_MATHML_EMBELLISH_IS_FENCE
(
embellishData
.
flags
)
)
{
if
(
!
LocalPrevSibling
(
)
)
{
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
nsGkAtoms
:
:
open_fence
)
;
}
else
if
(
!
LocalNextSibling
(
)
)
{
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
nsGkAtoms
:
:
close_fence
)
;
}
}
if
(
NS_MATHML_EMBELLISH_IS_SEPARATOR
(
embellishData
.
flags
)
)
{
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
nsGkAtoms
:
:
separator
)
;
}
}
}
break
;
case
roles
:
:
MATHML_FRACTION
:
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
IndexInParent
(
)
=
=
0
?
nsGkAtoms
:
:
numerator
:
nsGkAtoms
:
:
denominator
)
;
break
;
case
roles
:
:
MATHML_ROOT
:
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
IndexInParent
(
)
=
=
0
?
nsGkAtoms
:
:
base
:
nsGkAtoms
:
:
root_index
)
;
break
;
case
roles
:
:
MATHML_SUB
:
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
IndexInParent
(
)
=
=
0
?
nsGkAtoms
:
:
base
:
nsGkAtoms
:
:
subscript
)
;
break
;
case
roles
:
:
MATHML_SUP
:
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
IndexInParent
(
)
=
=
0
?
nsGkAtoms
:
:
base
:
nsGkAtoms
:
:
superscript
)
;
break
;
case
roles
:
:
MATHML_SUB_SUP
:
{
int32_t
index
=
IndexInParent
(
)
;
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
index
=
=
0
?
nsGkAtoms
:
:
base
:
(
index
=
=
1
?
nsGkAtoms
:
:
subscript
:
nsGkAtoms
:
:
superscript
)
)
;
}
break
;
case
roles
:
:
MATHML_UNDER
:
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
IndexInParent
(
)
=
=
0
?
nsGkAtoms
:
:
base
:
nsGkAtoms
:
:
underscript
)
;
break
;
case
roles
:
:
MATHML_OVER
:
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
IndexInParent
(
)
=
=
0
?
nsGkAtoms
:
:
base
:
nsGkAtoms
:
:
overscript
)
;
break
;
case
roles
:
:
MATHML_UNDER_OVER
:
{
int32_t
index
=
IndexInParent
(
)
;
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
index
=
=
0
?
nsGkAtoms
:
:
base
:
(
index
=
=
1
?
nsGkAtoms
:
:
underscript
:
nsGkAtoms
:
:
overscript
)
)
;
}
break
;
case
roles
:
:
MATHML_MULTISCRIPTS
:
{
nsIContent
*
child
;
bool
baseFound
=
false
;
for
(
child
=
parent
-
>
GetContent
(
)
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsMathMLElement
(
)
)
{
baseFound
=
true
;
break
;
}
}
if
(
baseFound
)
{
nsIContent
*
content
=
GetContent
(
)
;
if
(
child
=
=
content
)
{
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
nsGkAtoms
:
:
base
)
;
}
else
{
bool
postscript
=
true
;
bool
subscript
=
true
;
for
(
child
=
child
-
>
GetNextSibling
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
!
child
-
>
IsMathMLElement
(
)
)
continue
;
if
(
child
-
>
IsMathMLElement
(
nsGkAtoms
:
:
mprescripts
)
)
{
postscript
=
false
;
subscript
=
true
;
continue
;
}
if
(
child
=
=
content
)
{
if
(
postscript
)
{
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
subscript
?
nsGkAtoms
:
:
subscript
:
nsGkAtoms
:
:
superscript
)
;
}
else
{
aAttributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
subscript
?
nsGkAtoms
:
:
presubscript
:
nsGkAtoms
:
:
presuperscript
)
;
}
break
;
}
subscript
=
!
subscript
;
}
}
}
}
break
;
default
:
break
;
}
}
}
already_AddRefed
<
AccAttributes
>
HyperTextAccessible
:
:
NativeAttributes
(
)
{
RefPtr
<
AccAttributes
>
attributes
=
AccessibleWrap
:
:
NativeAttributes
(
)
;
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsBlockFrame
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
formatting
nsGkAtoms
:
:
block
)
;
}
if
(
FocusMgr
(
)
-
>
IsFocused
(
this
)
)
{
int32_t
lineNumber
=
CaretLineNumber
(
)
;
if
(
lineNumber
>
=
1
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
lineNumber
lineNumber
)
;
}
}
if
(
HasOwnContent
(
)
)
{
GetAccService
(
)
-
>
MarkupAttributes
(
this
attributes
)
;
if
(
mContent
-
>
IsMathMLElement
(
)
)
SetMathMLXMLRoles
(
attributes
)
;
}
return
attributes
.
forget
(
)
;
}
int32_t
HyperTextAccessible
:
:
OffsetAtPoint
(
int32_t
aX
int32_t
aY
uint32_t
aCoordType
)
{
nsIFrame
*
hyperFrame
=
GetFrame
(
)
;
if
(
!
hyperFrame
)
return
-
1
;
LayoutDeviceIntPoint
coords
=
nsAccUtils
:
:
ConvertToScreenCoords
(
aX
aY
aCoordType
this
)
;
nsPresContext
*
presContext
=
mDoc
-
>
PresContext
(
)
;
nsPoint
coordsInAppUnits
=
LayoutDeviceIntPoint
:
:
ToAppUnits
(
coords
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
nsRect
frameScreenRect
=
hyperFrame
-
>
GetScreenRectInAppUnits
(
)
;
if
(
!
frameScreenRect
.
Contains
(
coordsInAppUnits
.
x
coordsInAppUnits
.
y
)
)
{
return
-
1
;
}
nsPoint
pointInHyperText
(
coordsInAppUnits
.
x
-
frameScreenRect
.
X
(
)
coordsInAppUnits
.
y
-
frameScreenRect
.
Y
(
)
)
;
int32_t
offset
=
0
;
uint32_t
childCount
=
ChildCount
(
)
;
for
(
uint32_t
childIdx
=
0
;
childIdx
<
childCount
;
childIdx
+
+
)
{
LocalAccessible
*
childAcc
=
mChildren
[
childIdx
]
;
nsIFrame
*
primaryFrame
=
childAcc
-
>
GetFrame
(
)
;
NS_ENSURE_TRUE
(
primaryFrame
-
1
)
;
nsIFrame
*
frame
=
primaryFrame
;
while
(
frame
)
{
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
NS_ENSURE_TRUE
(
content
-
1
)
;
nsPoint
pointInFrame
=
pointInHyperText
-
frame
-
>
GetOffsetTo
(
hyperFrame
)
;
nsSize
frameSize
=
frame
-
>
GetSize
(
)
;
if
(
pointInFrame
.
x
<
frameSize
.
width
&
&
pointInFrame
.
y
<
frameSize
.
height
)
{
if
(
frame
-
>
IsTextFrame
(
)
)
{
nsIFrame
:
:
ContentOffsets
contentOffsets
=
frame
-
>
GetContentOffsetsFromPointExternal
(
pointInFrame
nsIFrame
:
:
IGNORE_SELECTION_STYLE
)
;
if
(
contentOffsets
.
IsNull
(
)
|
|
contentOffsets
.
content
!
=
content
)
{
return
-
1
;
}
uint32_t
addToOffset
;
nsresult
rv
=
ContentToRenderedOffset
(
primaryFrame
contentOffsets
.
offset
&
addToOffset
)
;
NS_ENSURE_SUCCESS
(
rv
-
1
)
;
offset
+
=
addToOffset
;
}
return
offset
;
}
frame
=
frame
-
>
GetNextContinuation
(
)
;
}
offset
+
=
nsAccUtils
:
:
TextLength
(
childAcc
)
;
}
return
-
1
;
}
already_AddRefed
<
EditorBase
>
HyperTextAccessible
:
:
GetEditor
(
)
const
{
if
(
!
mContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
LocalAccessible
*
ancestor
=
LocalParent
(
)
;
while
(
ancestor
)
{
HyperTextAccessible
*
hyperText
=
ancestor
-
>
AsHyperText
(
)
;
if
(
hyperText
)
{
return
hyperText
-
>
GetEditor
(
)
;
}
ancestor
=
ancestor
-
>
LocalParent
(
)
;
}
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
nsCoreUtils
:
:
GetDocShellFor
(
mContent
)
;
nsCOMPtr
<
nsIEditingSession
>
editingSession
;
docShell
-
>
GetEditingSession
(
getter_AddRefs
(
editingSession
)
)
;
if
(
!
editingSession
)
return
nullptr
;
dom
:
:
Document
*
docNode
=
mDoc
-
>
DocumentNode
(
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
editingSession
-
>
GetHTMLEditorForWindow
(
docNode
-
>
GetWindow
(
)
)
;
return
htmlEditor
.
forget
(
)
;
}
int32_t
HyperTextAccessible
:
:
CaretOffset
(
)
const
{
if
(
!
IsDoc
(
)
&
&
!
FocusMgr
(
)
-
>
IsFocused
(
this
)
&
&
(
InteractiveState
(
)
&
states
:
:
FOCUSABLE
)
)
{
return
-
1
;
}
int32_t
caretOffset
=
-
1
;
HyperTextAccessible
*
text
=
SelectionMgr
(
)
-
>
AccessibleWithCaret
(
&
caretOffset
)
;
if
(
caretOffset
!
=
-
1
)
{
if
(
text
=
=
this
)
return
caretOffset
;
nsINode
*
textNode
=
text
-
>
GetNode
(
)
;
if
(
nsCoreUtils
:
:
IsAncestorOf
(
GetNode
(
)
textNode
)
)
{
return
TransformOffset
(
text
textNode
-
>
IsText
(
)
?
caretOffset
:
0
false
)
;
}
}
FocusManager
:
:
FocusDisposition
focusDisp
=
FocusMgr
(
)
-
>
IsInOrContainsFocus
(
this
)
;
if
(
focusDisp
=
=
FocusManager
:
:
eNone
)
return
-
1
;
dom
:
:
Selection
*
domSel
=
DOMSelection
(
)
;
NS_ENSURE_TRUE
(
domSel
-
1
)
;
nsINode
*
focusNode
=
domSel
-
>
GetFocusNode
(
)
;
uint32_t
focusOffset
=
domSel
-
>
FocusOffset
(
)
;
if
(
focusDisp
=
=
FocusManager
:
:
eContainedByFocus
)
{
nsINode
*
resultNode
=
nsCoreUtils
:
:
GetDOMNodeFromDOMPoint
(
focusNode
focusOffset
)
;
nsINode
*
thisNode
=
GetNode
(
)
;
if
(
resultNode
!
=
thisNode
&
&
!
nsCoreUtils
:
:
IsAncestorOf
(
thisNode
resultNode
)
)
{
return
-
1
;
}
}
return
DOMPointToOffset
(
focusNode
focusOffset
)
;
}
LayoutDeviceIntRect
HyperTextAccessible
:
:
GetCaretRect
(
nsIWidget
*
*
aWidget
)
{
*
aWidget
=
nullptr
;
RefPtr
<
nsCaret
>
caret
=
mDoc
-
>
PresShellPtr
(
)
-
>
GetCaret
(
)
;
NS_ENSURE_TRUE
(
caret
LayoutDeviceIntRect
(
)
)
;
bool
isVisible
=
caret
-
>
IsVisible
(
)
;
if
(
!
isVisible
)
return
LayoutDeviceIntRect
(
)
;
nsRect
rect
;
nsIFrame
*
frame
=
caret
-
>
GetGeometry
(
&
rect
)
;
if
(
!
frame
|
|
rect
.
IsEmpty
(
)
)
return
LayoutDeviceIntRect
(
)
;
PresShell
*
presShell
=
mDoc
-
>
PresShellPtr
(
)
;
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
rect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
frame
rect
rootFrame
)
;
nsPoint
viewportOffset
=
presShell
-
>
GetVisualViewportOffset
(
)
-
presShell
-
>
GetLayoutViewportOffset
(
)
;
rect
.
MoveBy
(
-
viewportOffset
)
;
rect
.
ScaleRoundOut
(
presShell
-
>
GetResolution
(
)
)
;
nsRect
rootScreenRect
=
rootFrame
-
>
GetScreenRectInAppUnits
(
)
;
rect
.
MoveBy
(
rootScreenRect
.
TopLeft
(
)
)
;
auto
caretRect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
rect
presShell
-
>
GetPresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
int32_t
caretOffset
=
CaretOffset
(
)
;
if
(
NS_WARN_IF
(
caretOffset
=
=
-
1
)
)
{
return
LayoutDeviceIntRect
(
)
;
}
LayoutDeviceIntRect
charRect
=
CharBounds
(
caretOffset
nsIAccessibleCoordinateType
:
:
COORDTYPE_SCREEN_RELATIVE
)
;
if
(
!
charRect
.
IsEmpty
(
)
)
{
caretRect
.
SetTopEdge
(
charRect
.
Y
(
)
)
;
}
*
aWidget
=
frame
-
>
GetNearestWidget
(
)
;
return
caretRect
;
}
bool
HyperTextAccessible
:
:
RemoveFromSelection
(
int32_t
aSelectionNum
)
{
RefPtr
<
dom
:
:
Selection
>
domSel
=
DOMSelection
(
)
;
if
(
!
domSel
)
return
false
;
if
(
aSelectionNum
=
=
TextLeafRange
:
:
kRemoveAllExistingSelectedRanges
)
{
domSel
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
return
true
;
}
if
(
aSelectionNum
<
0
|
|
aSelectionNum
>
=
static_cast
<
int32_t
>
(
domSel
-
>
RangeCount
(
)
)
)
{
return
false
;
}
const
RefPtr
<
nsRange
>
range
{
domSel
-
>
GetRangeAt
(
static_cast
<
uint32_t
>
(
aSelectionNum
)
)
}
;
domSel
-
>
RemoveRangeAndUnselectFramesAndNotifyListeners
(
*
range
IgnoreErrors
(
)
)
;
return
true
;
}
void
HyperTextAccessible
:
:
ScrollSubstringToPoint
(
int32_t
aStartOffset
int32_t
aEndOffset
uint32_t
aCoordinateType
int32_t
aX
int32_t
aY
)
{
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
!
frame
)
return
;
LayoutDeviceIntPoint
coords
=
nsAccUtils
:
:
ConvertToScreenCoords
(
aX
aY
aCoordinateType
this
)
;
RefPtr
<
nsRange
>
domRange
=
nsRange
:
:
Create
(
mContent
)
;
TextRange
range
(
this
this
aStartOffset
this
aEndOffset
)
;
if
(
!
range
.
AssignDOMRange
(
domRange
)
)
{
return
;
}
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
nsPoint
coordsInAppUnits
=
LayoutDeviceIntPoint
:
:
ToAppUnits
(
coords
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
bool
initialScrolled
=
false
;
nsIFrame
*
parentFrame
=
frame
;
while
(
(
parentFrame
=
parentFrame
-
>
GetParent
(
)
)
)
{
if
(
parentFrame
-
>
IsScrollContainerOrSubclass
(
)
)
{
if
(
!
initialScrolled
)
{
nsRect
frameRect
=
parentFrame
-
>
GetScreenRectInAppUnits
(
)
;
nscoord
offsetPointX
=
coordsInAppUnits
.
x
-
frameRect
.
X
(
)
;
nscoord
offsetPointY
=
coordsInAppUnits
.
y
-
frameRect
.
Y
(
)
;
nsSize
size
(
parentFrame
-
>
GetSize
(
)
)
;
size
.
width
=
size
.
width
?
size
.
width
:
1
;
size
.
height
=
size
.
height
?
size
.
height
:
1
;
int16_t
hPercent
=
offsetPointX
*
100
/
size
.
width
;
int16_t
vPercent
=
offsetPointY
*
100
/
size
.
height
;
nsresult
rv
=
nsCoreUtils
:
:
ScrollSubstringTo
(
frame
domRange
ScrollAxis
(
WhereToScroll
(
vPercent
)
WhenToScroll
:
:
Always
)
ScrollAxis
(
WhereToScroll
(
hPercent
)
WhenToScroll
:
:
Always
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
initialScrolled
=
true
;
}
else
{
nsCoreUtils
:
:
ScrollFrameToPoint
(
parentFrame
frame
coords
)
;
}
}
frame
=
parentFrame
;
}
}
void
HyperTextAccessible
:
:
SelectionRanges
(
nsTArray
<
a11y
:
:
TextRange
>
*
aRanges
)
const
{
if
(
IsDoc
(
)
&
&
!
AsDoc
(
)
-
>
HasLoadState
(
DocAccessible
:
:
eTreeConstructed
)
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Query
before
DoInitialUpdate
"
)
;
return
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
FrameSelection
(
)
;
if
(
!
frameSelection
|
|
frameSelection
-
>
GetDisplaySelection
(
)
<
=
nsISelectionController
:
:
SELECTION_HIDDEN
)
{
return
;
}
dom
:
:
Selection
*
sel
=
&
frameSelection
-
>
NormalSelection
(
)
;
TextRange
:
:
TextRangesFromSelection
(
sel
aRanges
)
;
}
void
HyperTextAccessible
:
:
ReplaceText
(
const
nsAString
&
aText
)
{
if
(
aText
.
Length
(
)
=
=
0
)
{
DeleteText
(
0
CharacterCount
(
)
)
;
return
;
}
SetSelectionBoundsAt
(
TextLeafRange
:
:
kRemoveAllExistingSelectedRanges
0
CharacterCount
(
)
)
;
RefPtr
<
EditorBase
>
editorBase
=
GetEditor
(
)
;
if
(
!
editorBase
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
editorBase
-
>
InsertTextAsAction
(
aText
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
the
new
text
"
)
;
}
void
HyperTextAccessible
:
:
InsertText
(
const
nsAString
&
aText
int32_t
aPosition
)
{
RefPtr
<
EditorBase
>
editorBase
=
GetEditor
(
)
;
if
(
editorBase
)
{
SetSelectionBoundsAt
(
TextLeafRange
:
:
kRemoveAllExistingSelectedRanges
aPosition
aPosition
)
;
DebugOnly
<
nsresult
>
rv
=
editorBase
-
>
InsertTextAsAction
(
aText
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
the
text
"
)
;
}
}
void
HyperTextAccessible
:
:
CopyText
(
int32_t
aStartPos
int32_t
aEndPos
)
{
RefPtr
<
EditorBase
>
editorBase
=
GetEditor
(
)
;
if
(
editorBase
)
{
SetSelectionBoundsAt
(
TextLeafRange
:
:
kRemoveAllExistingSelectedRanges
aStartPos
aEndPos
)
;
editorBase
-
>
Copy
(
)
;
}
}
void
HyperTextAccessible
:
:
CutText
(
int32_t
aStartPos
int32_t
aEndPos
)
{
RefPtr
<
EditorBase
>
editorBase
=
GetEditor
(
)
;
if
(
editorBase
)
{
SetSelectionBoundsAt
(
TextLeafRange
:
:
kRemoveAllExistingSelectedRanges
aStartPos
aEndPos
)
;
editorBase
-
>
Cut
(
)
;
}
}
void
HyperTextAccessible
:
:
DeleteText
(
int32_t
aStartPos
int32_t
aEndPos
)
{
RefPtr
<
EditorBase
>
editorBase
=
GetEditor
(
)
;
if
(
!
editorBase
)
{
return
;
}
SetSelectionBoundsAt
(
TextLeafRange
:
:
kRemoveAllExistingSelectedRanges
aStartPos
aEndPos
)
;
DebugOnly
<
nsresult
>
rv
=
editorBase
-
>
DeleteSelectionAsAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
delete
text
"
)
;
}
void
HyperTextAccessible
:
:
PasteText
(
int32_t
aPosition
)
{
RefPtr
<
EditorBase
>
editorBase
=
GetEditor
(
)
;
if
(
editorBase
)
{
if
(
aPosition
!
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
{
SetSelectionBoundsAt
(
TextLeafRange
:
:
kRemoveAllExistingSelectedRanges
aPosition
aPosition
)
;
}
editorBase
-
>
PasteAsAction
(
nsIClipboard
:
:
kGlobalClipboard
EditorBase
:
:
DispatchPasteEvent
:
:
Yes
)
;
}
}
ENameValueFlag
HyperTextAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
if
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
alt
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
eNameOK
;
}
ENameValueFlag
nameFlag
=
AccessibleWrap
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
if
(
IsAbbreviation
(
)
&
&
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
title
aName
)
)
{
aName
.
CompressWhitespace
(
)
;
}
return
eNameOK
;
}
void
HyperTextAccessible
:
:
Shutdown
(
)
{
mOffsets
.
Clear
(
)
;
AccessibleWrap
:
:
Shutdown
(
)
;
}
bool
HyperTextAccessible
:
:
RemoveChild
(
LocalAccessible
*
aAccessible
)
{
const
int32_t
childIndex
=
aAccessible
-
>
IndexInParent
(
)
;
if
(
childIndex
<
static_cast
<
int32_t
>
(
mOffsets
.
Length
(
)
)
)
{
mOffsets
.
RemoveLastElements
(
mOffsets
.
Length
(
)
-
childIndex
)
;
}
return
AccessibleWrap
:
:
RemoveChild
(
aAccessible
)
;
}
bool
HyperTextAccessible
:
:
InsertChildAt
(
uint32_t
aIndex
LocalAccessible
*
aChild
)
{
if
(
aIndex
<
mOffsets
.
Length
(
)
)
{
mOffsets
.
RemoveLastElements
(
mOffsets
.
Length
(
)
-
aIndex
)
;
}
return
AccessibleWrap
:
:
InsertChildAt
(
aIndex
aChild
)
;
}
Relation
HyperTextAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
LocalAccessible
:
:
RelationByType
(
aType
)
;
switch
(
aType
)
{
case
RelationType
:
:
NODE_CHILD_OF
:
if
(
HasOwnContent
(
)
&
&
mContent
-
>
IsMathMLElement
(
)
)
{
LocalAccessible
*
parent
=
LocalParent
(
)
;
if
(
parent
)
{
nsIContent
*
parentContent
=
parent
-
>
GetContent
(
)
;
if
(
parentContent
&
&
parentContent
-
>
IsMathMLElement
(
nsGkAtoms
:
:
mroot
)
)
{
rel
.
AppendTarget
(
parent
)
;
}
}
}
break
;
case
RelationType
:
:
NODE_PARENT_OF
:
if
(
HasOwnContent
(
)
&
&
mContent
-
>
IsMathMLElement
(
nsGkAtoms
:
:
mroot
)
)
{
LocalAccessible
*
base
=
LocalChildAt
(
0
)
;
LocalAccessible
*
index
=
LocalChildAt
(
1
)
;
if
(
base
&
&
index
)
{
rel
.
AppendTarget
(
index
)
;
rel
.
AppendTarget
(
base
)
;
}
}
break
;
default
:
break
;
}
return
rel
;
}
nsresult
HyperTextAccessible
:
:
ContentToRenderedOffset
(
nsIFrame
*
aFrame
int32_t
aContentOffset
uint32_t
*
aRenderedOffset
)
const
{
if
(
!
aFrame
)
{
*
aRenderedOffset
=
0
;
return
NS_OK
;
}
if
(
IsTextField
(
)
)
{
*
aRenderedOffset
=
aContentOffset
;
return
NS_OK
;
}
NS_ASSERTION
(
aFrame
-
>
IsTextFrame
(
)
"
Need
text
frame
for
offset
conversion
"
)
;
NS_ASSERTION
(
aFrame
-
>
GetPrevContinuation
(
)
=
=
nullptr
"
Call
on
primary
frame
only
"
)
;
nsIFrame
:
:
RenderedText
text
=
aFrame
-
>
GetRenderedText
(
aContentOffset
aContentOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInContentText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
*
aRenderedOffset
=
text
.
mOffsetWithinNodeRenderedText
;
return
NS_OK
;
}
nsresult
HyperTextAccessible
:
:
RenderedToContentOffset
(
nsIFrame
*
aFrame
uint32_t
aRenderedOffset
int32_t
*
aContentOffset
)
const
{
if
(
IsTextField
(
)
)
{
*
aContentOffset
=
aRenderedOffset
;
return
NS_OK
;
}
*
aContentOffset
=
0
;
NS_ENSURE_TRUE
(
aFrame
NS_ERROR_FAILURE
)
;
NS_ASSERTION
(
aFrame
-
>
IsTextFrame
(
)
"
Need
text
frame
for
offset
conversion
"
)
;
NS_ASSERTION
(
aFrame
-
>
GetPrevContinuation
(
)
=
=
nullptr
"
Call
on
primary
frame
only
"
)
;
nsIFrame
:
:
RenderedText
text
=
aFrame
-
>
GetRenderedText
(
aRenderedOffset
aRenderedOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInRenderedText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
*
aContentOffset
=
text
.
mOffsetWithinNodeText
;
return
NS_OK
;
}
