#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
AccIterator
.
h
"
#
include
"
AccAttributes
.
h
"
#
include
"
ARIAMap
.
h
"
#
include
"
CachedTableAccessible
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
EventTree
.
h
"
#
include
"
HTMLImageMapAccessible
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsTextEquivUtils
.
h
"
#
include
"
mozilla
/
a11y
/
Role
.
h
"
#
include
"
TreeWalker
.
h
"
#
include
"
xpcAccessibleDocument
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIEditingSession
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
ipc
/
ProcessChild
.
h
"
#
include
"
mozilla
/
PerfStats
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ScrollContainerFrame
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessibleChild
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
DocumentType
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSelectElement
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
static
nsStaticAtom
*
const
kRelationAttrs
[
]
=
{
nsGkAtoms
:
:
aria_labelledby
nsGkAtoms
:
:
aria_describedby
nsGkAtoms
:
:
aria_details
nsGkAtoms
:
:
aria_owns
nsGkAtoms
:
:
aria_controls
nsGkAtoms
:
:
aria_flowto
nsGkAtoms
:
:
aria_errormessage
nsGkAtoms
:
:
_for
nsGkAtoms
:
:
control
nsGkAtoms
:
:
popovertarget
}
;
static
const
uint32_t
kRelationAttrsLen
=
ArrayLength
(
kRelationAttrs
)
;
static
nsStaticAtom
*
const
kSingleElementRelationIdlAttrs
[
]
=
{
nsGkAtoms
:
:
popovertarget
}
;
DocAccessible
:
:
DocAccessible
(
dom
:
:
Document
*
aDocument
PresShell
*
aPresShell
)
:
HyperTextAccessible
(
nullptr
nullptr
)
mAccessibleCache
(
kDefaultCacheLength
)
mNodeToAccessibleMap
(
kDefaultCacheLength
)
mDocumentNode
(
aDocument
)
mLoadState
(
eTreeConstructionPending
)
mDocFlags
(
0
)
mViewportCacheDirty
(
false
)
mLoadEventType
(
0
)
mPrevStateBits
(
0
)
mPresShell
(
aPresShell
)
mIPCDoc
(
nullptr
)
{
mGenericTypes
|
=
eDocument
;
mStateFlags
|
=
eNotNodeMapEntry
;
mDoc
=
this
;
MOZ_ASSERT
(
mPresShell
"
should
have
been
given
a
pres
shell
"
)
;
mPresShell
-
>
SetDocAccessible
(
this
)
;
}
DocAccessible
:
:
~
DocAccessible
(
)
{
NS_ASSERTION
(
!
mPresShell
"
LastRelease
was
never
called
!
?
!
"
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
DocAccessible
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
DocAccessible
LocalAccessible
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mNotificationController
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChildDocuments
)
for
(
const
auto
&
hashEntry
:
tmp
-
>
mDependentIDsHashes
.
Values
(
)
)
{
for
(
const
auto
&
providers
:
hashEntry
-
>
Values
(
)
)
{
for
(
int32_t
provIdx
=
providers
-
>
Length
(
)
-
1
;
provIdx
>
=
0
;
provIdx
-
-
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
content
of
dependent
ids
hash
entry
of
document
accessible
"
)
;
const
auto
&
provider
=
(
*
providers
)
[
provIdx
]
;
cb
.
NoteXPCOMChild
(
provider
-
>
mContent
)
;
}
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAccessibleCache
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAnchorJumpElm
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mInvalidationList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPendingUpdates
)
for
(
const
auto
&
ar
:
tmp
-
>
mARIAOwnsHash
.
Values
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
ar
-
>
Length
(
)
;
i
+
+
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mARIAOwnsHash
entry
item
"
)
;
cb
.
NoteXPCOMChild
(
ar
-
>
ElementAt
(
i
)
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
DocAccessible
LocalAccessible
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mNotificationController
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChildDocuments
)
tmp
-
>
mDependentIDsHashes
.
Clear
(
)
;
tmp
-
>
mNodeToAccessibleMap
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAccessibleCache
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAnchorJumpElm
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mInvalidationList
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPendingUpdates
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_WEAK_REFERENCE
tmp
-
>
mARIAOwnsHash
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DocAccessible
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END_INHERITING
(
HyperTextAccessible
)
NS_IMPL_ADDREF_INHERITED
(
DocAccessible
HyperTextAccessible
)
NS_IMPL_RELEASE_INHERITED
(
DocAccessible
HyperTextAccessible
)
ENameValueFlag
DocAccessible
:
:
Name
(
nsString
&
aName
)
const
{
aName
.
Truncate
(
)
;
if
(
mParent
)
{
mParent
-
>
Name
(
aName
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
LocalAccessible
:
:
Name
(
aName
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
Title
(
aName
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
URL
(
aName
)
;
}
return
eNameOK
;
}
role
DocAccessible
:
:
NativeRole
(
)
const
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
nsCoreUtils
:
:
GetDocShellFor
(
mDocumentNode
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
sameTypeRoot
;
docShell
-
>
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
sameTypeRoot
)
)
;
int32_t
itemType
=
docShell
-
>
ItemType
(
)
;
if
(
sameTypeRoot
=
=
docShell
)
{
if
(
itemType
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
return
roles
:
:
CHROME_WINDOW
;
}
if
(
itemType
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
return
roles
:
:
DOCUMENT
;
}
}
else
if
(
itemType
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
return
roles
:
:
DOCUMENT
;
}
}
return
roles
:
:
PANE
;
}
void
DocAccessible
:
:
Description
(
nsString
&
aDescription
)
const
{
if
(
mParent
)
mParent
-
>
Description
(
aDescription
)
;
if
(
HasOwnContent
(
)
&
&
aDescription
.
IsEmpty
(
)
)
{
nsTextEquivUtils
:
:
GetTextEquivFromIDRefs
(
this
nsGkAtoms
:
:
aria_describedby
aDescription
)
;
}
}
uint64_t
DocAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
states
:
:
FOCUSABLE
;
if
(
FocusMgr
(
)
-
>
IsFocused
(
this
)
)
state
|
=
states
:
:
FOCUSED
;
if
(
!
HasLoadState
(
eReady
)
)
state
|
=
states
:
:
STALE
;
if
(
!
HasLoadState
(
eCompletelyLoaded
)
)
state
|
=
states
:
:
BUSY
;
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
!
frame
|
|
!
frame
-
>
IsVisibleConsideringAncestors
(
nsIFrame
:
:
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
)
{
state
|
=
states
:
:
INVISIBLE
|
states
:
:
OFFSCREEN
;
}
RefPtr
<
EditorBase
>
editorBase
=
GetEditor
(
)
;
state
|
=
editorBase
?
states
:
:
EDITABLE
:
states
:
:
READONLY
;
return
state
;
}
uint64_t
DocAccessible
:
:
NativeInteractiveState
(
)
const
{
return
states
:
:
FOCUSABLE
;
}
bool
DocAccessible
:
:
NativelyUnavailable
(
)
const
{
return
false
;
}
void
DocAccessible
:
:
ApplyARIAState
(
uint64_t
*
aState
)
const
{
if
(
mContent
)
LocalAccessible
:
:
ApplyARIAState
(
aState
)
;
if
(
mParent
)
mParent
-
>
ApplyARIAState
(
aState
)
;
}
Accessible
*
DocAccessible
:
:
FocusedChild
(
)
{
return
FocusMgr
(
)
-
>
FocusedAccessible
(
)
;
}
void
DocAccessible
:
:
TakeFocus
(
)
const
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
RefPtr
<
dom
:
:
Element
>
newFocus
;
dom
:
:
AutoHandlingUserInputStatePusher
inputStatePusher
(
true
)
;
fm
-
>
MoveFocus
(
mDocumentNode
-
>
GetWindow
(
)
nullptr
nsFocusManager
:
:
MOVEFOCUS_ROOT
0
getter_AddRefs
(
newFocus
)
)
;
}
already_AddRefed
<
EditorBase
>
DocAccessible
:
:
GetEditor
(
)
const
{
if
(
!
mDocumentNode
-
>
IsInDesignMode
(
)
&
&
(
!
mContent
|
|
!
mContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
mDocumentNode
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIEditingSession
>
editingSession
;
docShell
-
>
GetEditingSession
(
getter_AddRefs
(
editingSession
)
)
;
if
(
!
editingSession
)
return
nullptr
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
editingSession
-
>
GetHTMLEditorForWindow
(
mDocumentNode
-
>
GetWindow
(
)
)
;
if
(
!
htmlEditor
)
{
return
nullptr
;
}
bool
isEditable
=
false
;
htmlEditor
-
>
GetIsDocumentEditable
(
&
isEditable
)
;
if
(
isEditable
)
{
return
htmlEditor
.
forget
(
)
;
}
return
nullptr
;
}
void
DocAccessible
:
:
URL
(
nsAString
&
aURL
)
const
{
aURL
.
Truncate
(
)
;
nsCOMPtr
<
nsISupports
>
container
=
mDocumentNode
-
>
GetContainer
(
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_GetInterface
(
container
)
)
;
if
(
MOZ_UNLIKELY
(
!
webNav
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uri
;
webNav
-
>
GetCurrentURI
(
getter_AddRefs
(
uri
)
)
;
if
(
MOZ_UNLIKELY
(
!
uri
)
)
{
return
;
}
if
(
uri
-
>
SchemeIs
(
"
data
"
)
|
|
uri
-
>
SchemeIs
(
"
blob
"
)
)
{
return
;
}
nsCOMPtr
<
nsIIOService
>
io
=
mozilla
:
:
components
:
:
IO
:
:
Service
(
)
;
if
(
NS_WARN_IF
(
!
io
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
exposableURI
;
if
(
NS_FAILED
(
io
-
>
CreateExposableURI
(
uri
getter_AddRefs
(
exposableURI
)
)
)
|
|
MOZ_UNLIKELY
(
!
exposableURI
)
)
{
return
;
}
nsAutoCString
theURL
;
if
(
NS_SUCCEEDED
(
exposableURI
-
>
GetSpec
(
theURL
)
)
)
{
CopyUTF8toUTF16
(
theURL
aURL
)
;
}
}
void
DocAccessible
:
:
Title
(
nsString
&
aTitle
)
const
{
mDocumentNode
-
>
GetTitle
(
aTitle
)
;
}
void
DocAccessible
:
:
MimeType
(
nsAString
&
aType
)
const
{
mDocumentNode
-
>
GetContentType
(
aType
)
;
}
void
DocAccessible
:
:
DocType
(
nsAString
&
aType
)
const
{
dom
:
:
DocumentType
*
docType
=
mDocumentNode
-
>
GetDoctype
(
)
;
if
(
docType
)
docType
-
>
GetPublicId
(
aType
)
;
}
static
uint64_t
GetCacheDomainsQueueUpdateSuperset
(
uint64_t
aCacheDomains
)
{
if
(
aCacheDomains
&
CacheDomain
:
:
Text
)
{
aCacheDomains
|
=
CacheDomain
:
:
TextOffsetAttributes
;
aCacheDomains
|
=
CacheDomain
:
:
TextBounds
;
}
if
(
aCacheDomains
&
CacheDomain
:
:
Bounds
)
{
aCacheDomains
|
=
CacheDomain
:
:
TextBounds
;
}
return
aCacheDomains
;
}
void
DocAccessible
:
:
QueueCacheUpdate
(
LocalAccessible
*
aAcc
uint64_t
aNewDomain
bool
aBypassActiveDomains
)
{
if
(
!
mIPCDoc
)
{
return
;
}
RefPtr
<
DocAccessible
>
self
=
this
;
RefPtr
<
LocalAccessible
>
acc
=
aAcc
;
size_t
arrayIndex
=
mQueuedCacheUpdatesHash
.
WithEntryHandle
(
aAcc
[
self
acc
]
(
auto
&
&
entry
)
{
if
(
entry
.
HasEntry
(
)
)
{
return
entry
.
Data
(
)
;
}
size_t
index
=
self
-
>
mQueuedCacheUpdatesArray
.
Length
(
)
;
self
-
>
mQueuedCacheUpdatesArray
.
EmplaceBack
(
std
:
:
make_pair
(
acc
0
)
)
;
return
entry
.
Insert
(
index
)
;
}
)
;
if
(
aBypassActiveDomains
)
{
auto
&
[
arrayAcc
domain
]
=
mQueuedCacheUpdatesArray
[
arrayIndex
]
;
MOZ_ASSERT
(
arrayAcc
=
=
aAcc
)
;
domain
|
=
aNewDomain
;
Controller
(
)
-
>
ScheduleProcessing
(
)
;
return
;
}
const
uint64_t
newDomains
=
GetCacheDomainsQueueUpdateSuperset
(
aNewDomain
)
;
const
uint64_t
domainsToUpdate
=
nsAccessibilityService
:
:
GetActiveCacheDomains
(
)
&
newDomains
;
if
(
domainsToUpdate
=
=
CacheDomain
:
:
None
)
{
return
;
}
auto
&
[
arrayAcc
domain
]
=
mQueuedCacheUpdatesArray
[
arrayIndex
]
;
MOZ_ASSERT
(
arrayAcc
=
=
aAcc
)
;
domain
|
=
domainsToUpdate
;
Controller
(
)
-
>
ScheduleProcessing
(
)
;
}
void
DocAccessible
:
:
QueueCacheUpdateForDependentRelations
(
LocalAccessible
*
aAcc
)
{
if
(
!
mIPCDoc
|
|
!
aAcc
|
|
!
aAcc
-
>
IsInDocument
(
)
|
|
aAcc
-
>
IsDefunct
(
)
)
{
return
;
}
dom
:
:
Element
*
el
=
aAcc
-
>
Elm
(
)
;
if
(
!
el
)
{
return
;
}
RelatedAccIterator
iter
(
this
el
nullptr
)
;
while
(
LocalAccessible
*
relatedAcc
=
iter
.
Next
(
)
)
{
if
(
relatedAcc
-
>
IsDefunct
(
)
|
|
!
relatedAcc
-
>
IsInDocument
(
)
|
|
mInsertedAccessibles
.
Contains
(
relatedAcc
)
)
{
continue
;
}
QueueCacheUpdate
(
relatedAcc
CacheDomain
:
:
Relations
)
;
}
}
void
DocAccessible
:
:
Init
(
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocCreate
)
)
{
logging
:
:
DocCreate
(
"
document
initialize
"
mDocumentNode
this
)
;
}
#
endif
mNotificationController
=
new
NotificationController
(
this
mPresShell
)
;
if
(
mDocumentNode
-
>
GetReadyStateEnum
(
)
=
=
dom
:
:
Document
:
:
READYSTATE_COMPLETE
)
{
mLoadState
|
=
eDOMLoaded
;
mLoadEventType
=
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_LOAD_COMPLETE
;
}
else
if
(
mDocumentNode
-
>
IsInitialDocument
(
)
)
{
mLoadState
|
=
eDOMLoaded
;
}
AddEventListeners
(
)
;
}
void
DocAccessible
:
:
Shutdown
(
)
{
if
(
!
mPresShell
)
{
return
;
}
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocDestroy
)
)
{
logging
:
:
DocDestroy
(
"
document
shutdown
"
mDocumentNode
this
)
;
}
#
endif
mStateFlags
|
=
eIsDefunct
;
if
(
mNotificationController
)
{
mNotificationController
-
>
Shutdown
(
)
;
mNotificationController
=
nullptr
;
}
RemoveEventListeners
(
)
;
const
bool
isChild
=
!
!
mParent
;
if
(
mParent
)
{
DocAccessible
*
parentDocument
=
mParent
-
>
Document
(
)
;
if
(
parentDocument
)
parentDocument
-
>
RemoveChildDocument
(
this
)
;
mParent
-
>
RemoveChild
(
this
)
;
MOZ_ASSERT
(
!
mParent
"
Parent
has
to
be
null
!
"
)
;
}
mPresShell
-
>
SetDocAccessible
(
nullptr
)
;
mPresShell
=
nullptr
;
int32_t
childDocCount
=
mChildDocuments
.
Length
(
)
;
for
(
int32_t
idx
=
childDocCount
-
1
;
idx
>
=
0
;
idx
-
-
)
{
mChildDocuments
[
idx
]
-
>
Shutdown
(
)
;
}
mChildDocuments
.
Clear
(
)
;
mQueuedCacheUpdatesArray
.
Clear
(
)
;
mQueuedCacheUpdatesHash
.
Clear
(
)
;
if
(
mIPCDoc
)
{
MOZ_ASSERT
(
IPCAccessibilityActive
(
)
)
;
mIPCDoc
-
>
Shutdown
(
)
;
MOZ_ASSERT
(
!
mIPCDoc
)
;
}
mDependentIDsHashes
.
Clear
(
)
;
mDependentElementsMap
.
Clear
(
)
;
mNodeToAccessibleMap
.
Clear
(
)
;
mAnchorJumpElm
=
nullptr
;
mInvalidationList
.
Clear
(
)
;
mPendingUpdates
.
Clear
(
)
;
for
(
auto
iter
=
mAccessibleCache
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
LocalAccessible
*
accessible
=
iter
.
Data
(
)
;
MOZ_ASSERT
(
accessible
)
;
if
(
accessible
)
{
if
(
FocusMgr
(
)
-
>
WasLastFocused
(
accessible
)
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
nullptr
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
doc
shutdown
"
accessible
)
;
}
#
endif
}
if
(
!
accessible
-
>
IsDefunct
(
)
)
{
accessible
-
>
mParent
=
nullptr
;
accessible
-
>
Shutdown
(
)
;
}
}
iter
.
Remove
(
)
;
}
HyperTextAccessible
:
:
Shutdown
(
)
;
MOZ_ASSERT
(
GetAccService
(
)
)
;
GetAccService
(
)
-
>
NotifyOfDocumentShutdown
(
this
mDocumentNode
!
isChild
)
;
mDocumentNode
=
nullptr
;
}
nsIFrame
*
DocAccessible
:
:
GetFrame
(
)
const
{
nsIFrame
*
root
=
nullptr
;
if
(
mPresShell
)
{
root
=
mPresShell
-
>
GetRootFrame
(
)
;
}
return
root
;
}
nsINode
*
DocAccessible
:
:
GetNode
(
)
const
{
return
mDocumentNode
;
}
nsRect
DocAccessible
:
:
RelativeBounds
(
nsIFrame
*
*
aRelativeFrame
)
const
{
*
aRelativeFrame
=
GetFrame
(
)
;
dom
:
:
Document
*
document
=
mDocumentNode
;
dom
:
:
Document
*
parentDoc
=
nullptr
;
nsRect
bounds
;
while
(
document
)
{
PresShell
*
presShell
=
document
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nsRect
(
)
;
}
nsRect
scrollPort
;
ScrollContainerFrame
*
sf
=
presShell
-
>
GetRootScrollContainerFrame
(
)
;
if
(
sf
)
{
scrollPort
=
sf
-
>
GetScrollPortRect
(
)
;
}
else
{
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
return
nsRect
(
)
;
scrollPort
=
rootFrame
-
>
GetRect
(
)
;
}
if
(
parentDoc
)
{
bounds
.
IntersectRect
(
scrollPort
bounds
)
;
}
else
{
bounds
=
scrollPort
;
}
document
=
parentDoc
=
document
-
>
GetInProcessParentDocument
(
)
;
}
return
bounds
;
}
nsresult
DocAccessible
:
:
AddEventListeners
(
)
{
SelectionMgr
(
)
-
>
AddDocSelectionListener
(
mPresShell
)
;
mDocumentNode
-
>
AddObserver
(
this
)
;
return
NS_OK
;
}
nsresult
DocAccessible
:
:
RemoveEventListeners
(
)
{
NS_ASSERTION
(
mDocumentNode
"
No
document
during
removal
of
listeners
.
"
)
;
if
(
mDocumentNode
)
{
mDocumentNode
-
>
RemoveObserver
(
this
)
;
}
if
(
mScrollWatchTimer
)
{
mScrollWatchTimer
-
>
Cancel
(
)
;
mScrollWatchTimer
=
nullptr
;
NS_RELEASE_THIS
(
)
;
}
SelectionMgr
(
)
-
>
RemoveDocSelectionListener
(
mPresShell
)
;
return
NS_OK
;
}
void
DocAccessible
:
:
ScrollTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
DocAccessible
*
docAcc
=
reinterpret_cast
<
DocAccessible
*
>
(
aClosure
)
;
if
(
docAcc
)
{
for
(
auto
iter
=
docAcc
-
>
mLastScrollingDispatch
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
docAcc
-
>
DispatchScrollingEvent
(
iter
.
Key
(
)
nsIAccessibleEvent
:
:
EVENT_SCROLLING_END
)
;
iter
.
Remove
(
)
;
}
if
(
docAcc
-
>
mScrollWatchTimer
)
{
docAcc
-
>
mScrollWatchTimer
=
nullptr
;
NS_RELEASE
(
docAcc
)
;
}
}
}
void
DocAccessible
:
:
HandleScroll
(
nsINode
*
aTarget
)
{
nsINode
*
target
=
aTarget
;
LocalAccessible
*
targetAcc
=
GetAccessible
(
target
)
;
if
(
!
targetAcc
&
&
target
-
>
IsInNativeAnonymousSubtree
(
)
)
{
target
=
target
-
>
GetClosestNativeAnonymousSubtreeRootParentOrHost
(
)
;
targetAcc
=
GetAccessible
(
target
)
;
}
if
(
targetAcc
)
{
QueueCacheUpdate
(
targetAcc
CacheDomain
:
:
ScrollPosition
)
;
}
const
uint32_t
kScrollEventInterval
=
100
;
mLastScrollingDispatch
.
WithEntryHandle
(
target
[
&
]
(
auto
&
&
lastDispatch
)
{
const
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
lastDispatch
|
|
(
now
-
lastDispatch
.
Data
(
)
)
.
ToMilliseconds
(
)
>
=
kScrollEventInterval
)
{
if
(
HasLoadState
(
eTreeConstructed
)
)
{
DispatchScrollingEvent
(
target
nsIAccessibleEvent
:
:
EVENT_SCROLLING
)
;
}
lastDispatch
.
InsertOrUpdate
(
now
)
;
}
}
)
;
if
(
mScrollWatchTimer
)
{
mScrollWatchTimer
-
>
SetDelay
(
kScrollEventInterval
)
;
}
else
{
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mScrollWatchTimer
)
ScrollTimerCallback
this
kScrollEventInterval
nsITimer
:
:
TYPE_ONE_SHOT
"
a11y
:
:
DocAccessible
:
:
ScrollPositionDidChange
"
)
;
if
(
mScrollWatchTimer
)
{
NS_ADDREF_THIS
(
)
;
}
}
}
std
:
:
pair
<
nsPoint
nsRect
>
DocAccessible
:
:
ComputeScrollData
(
LocalAccessible
*
aAcc
)
{
nsPoint
scrollPoint
;
nsRect
scrollRange
;
if
(
nsIFrame
*
frame
=
aAcc
-
>
GetFrame
(
)
)
{
ScrollContainerFrame
*
sf
=
aAcc
=
=
this
?
mPresShell
-
>
GetRootScrollContainerFrame
(
)
:
frame
-
>
GetScrollTargetFrame
(
)
;
if
(
sf
)
{
scrollPoint
=
sf
-
>
GetScrollPosition
(
)
*
mPresShell
-
>
GetResolution
(
)
;
scrollRange
=
sf
-
>
GetScrollRange
(
)
;
scrollRange
.
ScaleRoundOut
(
mPresShell
-
>
GetResolution
(
)
)
;
}
}
return
{
scrollPoint
scrollRange
}
;
}
NS_IMPL_NSIDOCUMENTOBSERVER_CORE_STUB
(
DocAccessible
)
NS_IMPL_NSIDOCUMENTOBSERVER_LOAD_STUB
(
DocAccessible
)
static
bool
sIsAttrElementChanging
=
false
;
void
DocAccessible
:
:
AttributeWillChange
(
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
sIsAttrElementChanging
)
{
return
;
}
LocalAccessible
*
accessible
=
GetAccessible
(
aElement
)
;
if
(
!
accessible
)
{
if
(
aElement
!
=
mContent
)
return
;
accessible
=
this
;
}
RemoveDependentIDsFor
(
accessible
aAttribute
)
;
RemoveDependentElementsFor
(
accessible
aAttribute
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
id
)
{
if
(
accessible
-
>
IsActiveDescendantId
(
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
ACTIVE
false
)
;
FireDelayedEvent
(
event
)
;
}
RelocateARIAOwnedIfNeeded
(
aElement
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_activedescendant
)
{
if
(
LocalAccessible
*
activeDescendant
=
accessible
-
>
CurrentItem
(
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
activeDescendant
states
:
:
ACTIVE
false
)
;
FireDelayedEvent
(
event
)
;
}
}
if
(
accessible
-
>
AttributeChangesState
(
aAttribute
)
)
{
mPrevStateBits
=
accessible
-
>
State
(
)
;
}
else
{
mPrevStateBits
=
0
;
}
}
void
DocAccessible
:
:
AttributeChanged
(
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
if
(
sIsAttrElementChanging
)
{
return
;
}
NS_ASSERTION
(
!
IsDefunct
(
)
"
Attribute
changed
called
on
defunct
document
accessible
!
"
)
;
if
(
UpdateAccessibleOnAttrChange
(
aElement
aAttribute
)
)
return
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_hidden
)
{
if
(
aria
:
:
HasDefinedARIAHidden
(
aElement
)
)
{
ContentRemoved
(
aElement
)
;
}
else
{
ContentInserted
(
aElement
aElement
-
>
GetNextSibling
(
)
)
;
}
return
;
}
LocalAccessible
*
accessible
=
GetAccessible
(
aElement
)
;
if
(
!
accessible
)
{
if
(
mContent
=
=
aElement
)
{
accessible
=
this
;
}
else
{
if
(
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
ADDITION
&
&
aria
:
:
AttrCharacteristicsFor
(
aAttribute
)
&
ATTR_GLOBAL
)
{
ContentInserted
(
aElement
aElement
-
>
GetNextSibling
(
)
)
;
return
;
}
return
;
}
}
MOZ_ASSERT
(
accessible
-
>
IsBoundToParent
(
)
|
|
accessible
-
>
IsDoc
(
)
"
DOM
attribute
change
on
an
accessible
detached
from
the
tree
"
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
id
)
{
dom
:
:
Element
*
elm
=
accessible
-
>
Elm
(
)
;
RelocateARIAOwnedIfNeeded
(
elm
)
;
ARIAActiveDescendantIDMaybeMoved
(
accessible
)
;
QueueCacheUpdate
(
accessible
CacheDomain
:
:
DOMNodeIDAndClass
)
;
QueueCacheUpdateForDependentRelations
(
accessible
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_activedescendant
)
{
mNotificationController
-
>
ScheduleNotification
<
DocAccessible
LocalAccessible
>
(
this
&
DocAccessible
:
:
ARIAActiveDescendantChanged
accessible
)
;
return
;
}
accessible
-
>
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
mPrevStateBits
)
;
if
(
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
MODIFICATION
|
|
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
ADDITION
)
{
AddDependentIDsFor
(
accessible
aAttribute
)
;
AddDependentElementsFor
(
accessible
aAttribute
)
;
}
}
void
DocAccessible
:
:
ARIAAttributeDefaultWillChange
(
dom
:
:
Element
*
aElement
nsAtom
*
aAttribute
int32_t
aModType
)
{
NS_ASSERTION
(
!
IsDefunct
(
)
"
Attribute
changed
called
on
defunct
document
accessible
!
"
)
;
if
(
aElement
-
>
HasAttr
(
aAttribute
)
)
{
return
;
}
AttributeWillChange
(
aElement
kNameSpaceID_None
aAttribute
aModType
)
;
}
void
DocAccessible
:
:
ARIAAttributeDefaultChanged
(
dom
:
:
Element
*
aElement
nsAtom
*
aAttribute
int32_t
aModType
)
{
NS_ASSERTION
(
!
IsDefunct
(
)
"
Attribute
changed
called
on
defunct
document
accessible
!
"
)
;
if
(
aElement
-
>
HasAttr
(
aAttribute
)
)
{
return
;
}
AttributeChanged
(
aElement
kNameSpaceID_None
aAttribute
aModType
nullptr
)
;
}
void
DocAccessible
:
:
ARIAActiveDescendantChanged
(
LocalAccessible
*
aAccessible
)
{
if
(
dom
:
:
Element
*
elm
=
aAccessible
-
>
Elm
(
)
)
{
nsAutoString
id
;
if
(
dom
:
:
Element
*
activeDescendantElm
=
nsCoreUtils
:
:
GetAriaActiveDescendantElement
(
elm
)
)
{
LocalAccessible
*
activeDescendant
=
GetAccessible
(
activeDescendantElm
)
;
if
(
activeDescendant
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
activeDescendant
states
:
:
ACTIVE
true
)
;
FireDelayedEvent
(
event
)
;
if
(
aAccessible
-
>
IsActiveWidget
(
)
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
activeDescendant
false
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
ARIA
activedescedant
changed
"
activeDescendant
)
;
}
#
endif
}
return
;
}
}
if
(
aAccessible
-
>
IsActiveWidget
(
)
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
aAccessible
false
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
ARIA
activedescedant
cleared
"
aAccessible
)
;
}
#
endif
}
}
}
void
DocAccessible
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
MaybeHandleChangeToHiddenNameOrDescription
(
aFirstNewContent
)
;
}
void
DocAccessible
:
:
ElementStateChanged
(
dom
:
:
Document
*
aDocument
dom
:
:
Element
*
aElement
dom
:
:
ElementState
aStateMask
)
{
if
(
aStateMask
.
HasState
(
dom
:
:
ElementState
:
:
READWRITE
)
&
&
aElement
=
=
mDocumentNode
-
>
GetRootElement
(
)
)
{
const
bool
isEditable
=
aElement
-
>
State
(
)
.
HasState
(
dom
:
:
ElementState
:
:
READWRITE
)
;
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
this
states
:
:
EDITABLE
isEditable
)
;
FireDelayedEvent
(
event
)
;
event
=
new
AccStateChangeEvent
(
this
states
:
:
READONLY
!
isEditable
)
;
FireDelayedEvent
(
event
)
;
}
LocalAccessible
*
accessible
=
GetAccessible
(
aElement
)
;
if
(
!
accessible
)
return
;
if
(
aStateMask
.
HasState
(
dom
:
:
ElementState
:
:
CHECKED
)
)
{
LocalAccessible
*
widget
=
accessible
-
>
ContainerWidget
(
)
;
if
(
widget
&
&
widget
-
>
IsSelect
(
)
)
{
SetViewportCacheDirty
(
true
)
;
AccSelChangeEvent
:
:
SelChangeType
selChangeType
=
aElement
-
>
State
(
)
.
HasState
(
dom
:
:
ElementState
:
:
CHECKED
)
?
AccSelChangeEvent
:
:
eSelectionAdd
:
AccSelChangeEvent
:
:
eSelectionRemove
;
RefPtr
<
AccEvent
>
event
=
new
AccSelChangeEvent
(
widget
accessible
selChangeType
)
;
FireDelayedEvent
(
event
)
;
return
;
}
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
CHECKED
aElement
-
>
State
(
)
.
HasState
(
dom
:
:
ElementState
:
:
CHECKED
)
)
;
FireDelayedEvent
(
event
)
;
}
if
(
aStateMask
.
HasState
(
dom
:
:
ElementState
:
:
INVALID
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
INVALID
)
;
FireDelayedEvent
(
event
)
;
}
if
(
aStateMask
.
HasState
(
dom
:
:
ElementState
:
:
REQUIRED
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
REQUIRED
)
;
FireDelayedEvent
(
event
)
;
}
if
(
aStateMask
.
HasState
(
dom
:
:
ElementState
:
:
VISITED
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
TRAVERSED
true
)
;
FireDelayedEvent
(
event
)
;
}
if
(
aStateMask
.
HasState
(
dom
:
:
ElementState
:
:
DEFAULT
)
&
&
accessible
-
>
IsButton
(
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
DEFAULT
)
;
FireDelayedEvent
(
event
)
;
}
if
(
aStateMask
.
HasState
(
dom
:
:
ElementState
:
:
INDETERMINATE
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
MIXED
)
;
FireDelayedEvent
(
event
)
;
}
if
(
aStateMask
.
HasState
(
dom
:
:
ElementState
:
:
DISABLED
)
&
&
!
nsAccUtils
:
:
ARIAAttrValueIs
(
aElement
nsGkAtoms
:
:
aria_disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
UNAVAILABLE
)
;
FireDelayedEvent
(
event
)
;
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
ENABLED
)
;
FireDelayedEvent
(
event
)
;
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
FOCUSABLE
)
;
FireDelayedEvent
(
event
)
;
}
}
void
DocAccessible
:
:
CharacterDataWillChange
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
}
void
DocAccessible
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
}
void
DocAccessible
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
MaybeHandleChangeToHiddenNameOrDescription
(
aChild
)
;
}
void
DocAccessible
:
:
ContentRemoved
(
nsIContent
*
aChildNode
nsIContent
*
aPreviousSiblingNode
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
DOM
content
removed
;
doc
:
%
p
"
this
)
;
logging
:
:
Node
(
"
container
node
"
aChildNode
-
>
GetParent
(
)
)
;
logging
:
:
Node
(
"
content
node
"
aChildNode
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
ContentRemoved
(
aChildNode
)
;
}
void
DocAccessible
:
:
ParentChainChanged
(
nsIContent
*
aContent
)
{
}
#
ifdef
A11Y_LOG
nsresult
DocAccessible
:
:
HandleAccEvent
(
AccEvent
*
aEvent
)
{
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocLoad
)
)
{
logging
:
:
DocLoadEventHandled
(
aEvent
)
;
}
return
HyperTextAccessible
:
:
HandleAccEvent
(
aEvent
)
;
}
#
endif
nsPresContext
*
DocAccessible
:
:
PresContext
(
)
const
{
return
mPresShell
-
>
GetPresContext
(
)
;
}
void
*
DocAccessible
:
:
GetNativeWindow
(
)
const
{
if
(
!
mPresShell
)
{
return
nullptr
;
}
nsViewManager
*
vm
=
mPresShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
return
nullptr
;
nsCOMPtr
<
nsIWidget
>
widget
=
vm
-
>
GetRootWidget
(
)
;
if
(
widget
)
return
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
return
nullptr
;
}
LocalAccessible
*
DocAccessible
:
:
GetAccessibleByUniqueIDInSubtree
(
void
*
aUniqueID
)
{
LocalAccessible
*
child
=
GetAccessibleByUniqueID
(
aUniqueID
)
;
if
(
child
)
return
child
;
uint32_t
childDocCount
=
mChildDocuments
.
Length
(
)
;
for
(
uint32_t
childDocIdx
=
0
;
childDocIdx
<
childDocCount
;
childDocIdx
+
+
)
{
DocAccessible
*
childDocument
=
mChildDocuments
.
ElementAt
(
childDocIdx
)
;
child
=
childDocument
-
>
GetAccessibleByUniqueIDInSubtree
(
aUniqueID
)
;
if
(
child
)
return
child
;
}
return
nullptr
;
}
LocalAccessible
*
DocAccessible
:
:
GetAccessibleOrContainer
(
nsINode
*
aNode
bool
aNoContainerIfPruned
)
const
{
if
(
!
aNode
|
|
!
aNode
-
>
GetComposedDoc
(
)
)
{
return
nullptr
;
}
nsINode
*
start
=
aNode
;
if
(
auto
*
shadowRoot
=
dom
:
:
ShadowRoot
:
:
FromNode
(
aNode
)
)
{
start
=
shadowRoot
-
>
GetHost
(
)
;
if
(
!
start
)
{
return
nullptr
;
}
}
for
(
nsINode
*
currNode
:
dom
:
:
InclusiveFlatTreeAncestors
(
*
start
)
)
{
if
(
aNoContainerIfPruned
&
&
currNode
-
>
IsElement
(
)
&
&
aria
:
:
HasDefinedARIAHidden
(
currNode
-
>
AsElement
(
)
)
)
{
return
nullptr
;
}
if
(
aNoContainerIfPruned
&
&
currNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
map
)
)
{
if
(
nsIFrame
*
frame
=
currNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
)
{
if
(
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
frame
frame
-
>
GetParent
(
)
)
.
IsEmpty
(
)
)
{
return
nullptr
;
}
}
}
if
(
LocalAccessible
*
accessible
=
GetAccessible
(
currNode
)
)
{
return
accessible
;
}
}
return
nullptr
;
}
LocalAccessible
*
DocAccessible
:
:
GetContainerAccessible
(
nsINode
*
aNode
)
const
{
return
aNode
?
GetAccessibleOrContainer
(
aNode
-
>
GetFlattenedTreeParentNode
(
)
)
:
nullptr
;
}
LocalAccessible
*
DocAccessible
:
:
GetAccessibleOrDescendant
(
nsINode
*
aNode
)
const
{
LocalAccessible
*
acc
=
GetAccessible
(
aNode
)
;
if
(
acc
)
return
acc
;
if
(
aNode
=
=
mContent
|
|
aNode
=
=
mDocumentNode
-
>
GetRootElement
(
)
)
{
return
const_cast
<
DocAccessible
*
>
(
this
)
;
}
acc
=
GetContainerAccessible
(
aNode
)
;
if
(
acc
)
{
TreeWalker
walker
(
acc
aNode
-
>
AsContent
(
)
TreeWalker
:
:
eWalkCache
|
TreeWalker
:
:
eScoped
)
;
return
walker
.
Next
(
)
;
}
return
nullptr
;
}
void
DocAccessible
:
:
BindToDocument
(
LocalAccessible
*
aAccessible
const
nsRoleMapEntry
*
aRoleMapEntry
)
{
if
(
aAccessible
-
>
IsNodeMapEntry
(
)
)
{
mNodeToAccessibleMap
.
InsertOrUpdate
(
aAccessible
-
>
GetNode
(
)
aAccessible
)
;
}
mAccessibleCache
.
InsertOrUpdate
(
aAccessible
-
>
UniqueID
(
)
RefPtr
{
aAccessible
}
)
;
aAccessible
-
>
SetRoleMapEntry
(
aRoleMapEntry
)
;
if
(
aAccessible
-
>
HasOwnContent
(
)
)
{
AddDependentIDsFor
(
aAccessible
)
;
AddDependentElementsFor
(
aAccessible
)
;
nsIContent
*
content
=
aAccessible
-
>
GetContent
(
)
;
if
(
content
-
>
IsElement
(
)
&
&
nsAccUtils
:
:
HasARIAAttr
(
content
-
>
AsElement
(
)
nsGkAtoms
:
:
aria_owns
)
)
{
mNotificationController
-
>
ScheduleRelocation
(
aAccessible
)
;
}
}
if
(
mIPCDoc
)
{
mInsertedAccessibles
.
EnsureInserted
(
aAccessible
)
;
}
QueueCacheUpdateForDependentRelations
(
aAccessible
)
;
}
void
DocAccessible
:
:
UnbindFromDocument
(
LocalAccessible
*
aAccessible
)
{
NS_ASSERTION
(
mAccessibleCache
.
GetWeak
(
aAccessible
-
>
UniqueID
(
)
)
"
Unbinding
the
unbound
accessible
!
"
)
;
if
(
FocusMgr
(
)
-
>
WasLastFocused
(
aAccessible
)
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
nullptr
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
tree
shutdown
"
aAccessible
)
;
}
#
endif
}
if
(
aAccessible
-
>
IsNodeMapEntry
(
)
&
&
mNodeToAccessibleMap
.
Get
(
aAccessible
-
>
GetNode
(
)
)
=
=
aAccessible
)
{
mNodeToAccessibleMap
.
Remove
(
aAccessible
-
>
GetNode
(
)
)
;
}
aAccessible
-
>
mStateFlags
|
=
eIsNotInDocument
;
xpcAccessibleDocument
*
xpcDoc
=
GetAccService
(
)
-
>
GetCachedXPCDocument
(
this
)
;
if
(
xpcDoc
)
xpcDoc
-
>
NotifyOfShutdown
(
aAccessible
)
;
void
*
uniqueID
=
aAccessible
-
>
UniqueID
(
)
;
NS_ASSERTION
(
!
aAccessible
-
>
IsDefunct
(
)
"
Shutdown
the
shutdown
accessible
!
"
)
;
aAccessible
-
>
Shutdown
(
)
;
mAccessibleCache
.
Remove
(
uniqueID
)
;
}
void
DocAccessible
:
:
ContentInserted
(
nsIContent
*
aStartChildNode
nsIContent
*
aEndChildNode
)
{
if
(
!
mNotificationController
|
|
!
HasLoadState
(
eTreeConstructed
)
)
{
return
;
}
nsINode
*
parent
=
aStartChildNode
-
>
GetFlattenedTreeParentNode
(
)
;
if
(
!
parent
)
{
return
;
}
LocalAccessible
*
container
=
AccessibleOrTrueContainer
(
parent
)
;
if
(
!
container
)
{
return
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
list
;
for
(
nsIContent
*
node
=
aStartChildNode
;
node
!
=
aEndChildNode
;
node
=
node
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
parent
=
=
node
-
>
GetFlattenedTreeParentNode
(
)
)
;
if
(
PruneOrInsertSubtree
(
node
)
)
{
list
.
AppendElement
(
node
)
;
}
}
mNotificationController
-
>
ScheduleContentInsertion
(
container
list
)
;
}
void
DocAccessible
:
:
ScheduleTreeUpdate
(
nsIContent
*
aContent
)
{
if
(
mPendingUpdates
.
Contains
(
aContent
)
)
{
return
;
}
mPendingUpdates
.
AppendElement
(
aContent
)
;
mNotificationController
-
>
ScheduleProcessing
(
)
;
}
void
DocAccessible
:
:
ProcessPendingUpdates
(
)
{
auto
updates
=
std
:
:
move
(
mPendingUpdates
)
;
for
(
auto
update
:
updates
)
{
if
(
update
-
>
GetComposedDoc
(
)
!
=
mDocumentNode
)
{
continue
;
}
ContentInserted
(
update
update
-
>
GetNextSibling
(
)
)
;
}
}
bool
DocAccessible
:
:
PruneOrInsertSubtree
(
nsIContent
*
aRoot
)
{
bool
insert
=
false
;
nsIContent
*
shadowHost
=
aRoot
-
>
GetShadowRoot
(
)
?
aRoot
:
aRoot
-
>
GetContainingShadowHost
(
)
;
if
(
shadowHost
)
{
for
(
nsIContent
*
childNode
=
shadowHost
-
>
GetFirstChild
(
)
;
childNode
;
childNode
=
childNode
-
>
GetNextSibling
(
)
)
{
if
(
!
childNode
-
>
GetPrimaryFrame
(
)
&
&
!
nsCoreUtils
:
:
CanCreateAccessibleWithoutFrame
(
childNode
)
)
{
ContentRemoved
(
childNode
)
;
}
}
if
(
aRoot
-
>
IsHTMLElement
(
nsGkAtoms
:
:
slot
)
)
{
for
(
nsIContent
*
childNode
=
aRoot
-
>
GetFirstChild
(
)
;
childNode
;
childNode
=
childNode
-
>
GetNextSibling
(
)
)
{
if
(
!
childNode
-
>
GetPrimaryFrame
(
)
&
&
!
nsCoreUtils
:
:
CanCreateAccessibleWithoutFrame
(
childNode
)
)
{
ContentRemoved
(
childNode
)
;
}
}
}
}
LocalAccessible
*
acc
=
GetAccessible
(
aRoot
)
;
if
(
acc
)
{
MOZ_ASSERT
(
aRoot
=
=
acc
-
>
GetContent
(
)
"
LocalAccessible
has
differing
content
!
"
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
inserted
content
already
has
accessible
;
doc
:
%
p
"
this
)
;
logging
:
:
Node
(
"
content
node
"
aRoot
)
;
logging
:
:
AccessibleInfo
(
"
accessible
node
"
acc
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
frame
)
{
acc
-
>
MaybeQueueCacheUpdateForStyleChanges
(
)
;
}
if
(
!
frame
&
&
!
nsCoreUtils
:
:
CanCreateAccessibleWithoutFrame
(
aRoot
)
)
{
ContentRemoved
(
aRoot
)
;
return
false
;
}
if
(
frame
&
&
frame
-
>
IsHiddenByContentVisibilityOnAnyAncestor
(
nsIFrame
:
:
IncludeContentVisibility
:
:
Hidden
)
)
{
ContentRemoved
(
aRoot
)
;
return
false
;
}
if
(
acc
-
>
IsXULLabel
(
)
)
{
ContentRemoved
(
acc
)
;
return
true
;
}
if
(
frame
&
&
frame
-
>
IsReplaced
(
)
&
&
frame
-
>
AccessibleType
(
)
=
=
eImageType
&
&
!
aRoot
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
acc
)
;
return
false
;
}
if
(
frame
&
&
(
acc
-
>
IsImage
(
)
!
=
(
frame
-
>
AccessibleType
(
)
=
=
eImageType
)
)
)
{
ContentRemoved
(
aRoot
)
;
return
true
;
}
if
(
frame
&
&
!
acc
-
>
IsOuterDoc
(
)
&
&
frame
-
>
AccessibleType
(
)
=
=
eOuterDocType
)
{
ContentRemoved
(
aRoot
)
;
return
true
;
}
if
(
aRoot
-
>
IsElement
(
)
&
&
FocusMgr
(
)
-
>
HasDOMFocus
(
aRoot
)
)
{
SelectionMgr
(
)
-
>
SetControlSelectionListener
(
aRoot
-
>
AsElement
(
)
)
;
}
if
(
acc
-
>
IsTable
(
)
|
|
acc
-
>
IsTableRow
(
)
|
|
acc
-
>
IsTableCell
(
)
)
{
LocalAccessible
*
table
=
nsAccUtils
:
:
TableFor
(
acc
)
;
if
(
table
&
&
table
-
>
IsTable
(
)
)
{
QueueCacheUpdate
(
table
CacheDomain
:
:
Table
)
;
}
}
insert
=
true
;
if
(
frame
&
&
!
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
ContentRemoved
(
aRoot
)
;
insert
=
false
;
}
}
else
{
if
(
aRoot
-
>
GetPrimaryFrame
(
)
|
|
nsCoreUtils
:
:
CanCreateAccessibleWithoutFrame
(
aRoot
)
)
{
if
(
!
GetAccessibleOrDescendant
(
aRoot
)
)
{
return
true
;
}
insert
=
true
;
}
}
if
(
LocalAccessible
*
container
=
AccessibleOrTrueContainer
(
aRoot
)
)
{
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
list
;
dom
:
:
AllChildrenIterator
iter
=
dom
:
:
AllChildrenIterator
(
aRoot
nsIContent
:
:
eAllChildren
true
)
;
while
(
nsIContent
*
childNode
=
iter
.
GetNextChild
(
)
)
{
if
(
PruneOrInsertSubtree
(
childNode
)
)
{
list
.
AppendElement
(
childNode
)
;
}
}
if
(
!
list
.
IsEmpty
(
)
)
{
mNotificationController
-
>
ScheduleContentInsertion
(
container
list
)
;
}
}
return
insert
;
}
void
DocAccessible
:
:
RecreateAccessible
(
nsIContent
*
aContent
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
accessible
recreated
"
)
;
logging
:
:
Node
(
"
content
"
aContent
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
ContentRemoved
(
aContent
)
;
ContentInserted
(
aContent
aContent
-
>
GetNextSibling
(
)
)
;
}
void
DocAccessible
:
:
ProcessInvalidationList
(
)
{
for
(
uint32_t
idx
=
0
;
idx
<
mInvalidationList
.
Length
(
)
;
idx
+
+
)
{
nsIContent
*
content
=
mInvalidationList
[
idx
]
;
if
(
!
HasAccessible
(
content
)
&
&
content
-
>
HasID
(
)
)
{
LocalAccessible
*
container
=
GetContainerAccessible
(
content
)
;
if
(
container
)
{
AttrRelProviders
*
list
=
GetRelProviders
(
content
-
>
AsElement
(
)
nsDependentAtomString
(
content
-
>
GetID
(
)
)
)
;
bool
shouldProcess
=
!
!
list
;
if
(
shouldProcess
)
{
for
(
uint32_t
idx
=
0
;
idx
<
list
-
>
Length
(
)
;
idx
+
+
)
{
if
(
list
-
>
ElementAt
(
idx
)
-
>
mRelAttr
=
=
nsGkAtoms
:
:
aria_owns
)
{
shouldProcess
=
false
;
break
;
}
}
if
(
shouldProcess
)
{
ProcessContentInserted
(
container
content
)
;
}
}
}
}
}
mInvalidationList
.
Clear
(
)
;
}
void
DocAccessible
:
:
ProcessQueuedCacheUpdates
(
uint64_t
aInitialDomains
)
{
AUTO_PROFILER_MARKER_TEXT
(
"
DocAccessible
:
:
ProcessQueuedCacheUpdates
"
A11Y
{
}
"
"
_ns
)
;
PerfStats
:
:
AutoMetricRecording
<
PerfStats
:
:
Metric
:
:
A11Y_ProcessQueuedCacheUpdate
>
autoRecording
;
nsTArray
<
CacheData
>
data
;
for
(
auto
[
acc
domain
]
:
mQueuedCacheUpdatesArray
)
{
if
(
acc
&
&
acc
-
>
IsInDocument
(
)
&
&
!
acc
-
>
IsDefunct
(
)
)
{
RefPtr
<
AccAttributes
>
fields
=
acc
-
>
BundleFieldsForCache
(
domain
CacheUpdateType
:
:
Update
aInitialDomains
)
;
if
(
fields
-
>
Count
(
)
)
{
data
.
AppendElement
(
CacheData
(
acc
-
>
IsDoc
(
)
?
0
:
reinterpret_cast
<
uint64_t
>
(
acc
-
>
UniqueID
(
)
)
fields
)
)
;
}
}
}
mQueuedCacheUpdatesArray
.
Clear
(
)
;
mQueuedCacheUpdatesHash
.
Clear
(
)
;
if
(
mViewportCacheDirty
)
{
RefPtr
<
AccAttributes
>
fields
=
BundleFieldsForCache
(
CacheDomain
:
:
Viewport
CacheUpdateType
:
:
Update
)
;
if
(
fields
-
>
Count
(
)
)
{
data
.
AppendElement
(
CacheData
(
0
fields
)
)
;
}
mViewportCacheDirty
=
false
;
}
if
(
data
.
Length
(
)
)
{
IPCDoc
(
)
-
>
SendCache
(
CacheUpdateType
:
:
Update
data
)
;
}
}
void
DocAccessible
:
:
SendAccessiblesWillMove
(
)
{
if
(
!
mIPCDoc
)
{
return
;
}
nsTArray
<
uint64_t
>
ids
;
for
(
LocalAccessible
*
acc
:
mMovedAccessibles
)
{
if
(
!
acc
-
>
IsDefunct
(
)
&
&
acc
-
>
IsInDocument
(
)
)
{
ids
.
AppendElement
(
reinterpret_cast
<
uintptr_t
>
(
acc
-
>
UniqueID
(
)
)
)
;
QueueCacheUpdate
(
acc
CacheDomain
:
:
Bounds
)
;
}
}
if
(
!
ids
.
IsEmpty
(
)
)
{
mIPCDoc
-
>
SendAccessiblesWillMove
(
ids
)
;
}
}
LocalAccessible
*
DocAccessible
:
:
GetAccessibleEvenIfNotInMap
(
nsINode
*
aNode
)
const
{
if
(
!
aNode
-
>
IsContent
(
)
|
|
!
aNode
-
>
AsContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
{
return
GetAccessible
(
aNode
)
;
}
nsIFrame
*
frame
=
aNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
nsImageFrame
*
imageFrame
=
do_QueryFrame
(
frame
)
;
if
(
imageFrame
)
{
LocalAccessible
*
parent
=
GetAccessible
(
imageFrame
-
>
GetContent
(
)
)
;
if
(
parent
)
{
if
(
HTMLImageMapAccessible
*
imageMap
=
parent
-
>
AsImageMap
(
)
)
{
return
imageMap
-
>
GetChildAccessibleFor
(
aNode
)
;
}
return
nullptr
;
}
}
return
GetAccessible
(
aNode
)
;
}
void
DocAccessible
:
:
NotifyOfLoading
(
bool
aIsReloading
)
{
mLoadState
&
=
~
eDOMLoaded
;
if
(
!
IsLoadEventTarget
(
)
)
return
;
if
(
aIsReloading
&
&
!
mLoadEventType
&
&
HasLoadState
(
eTreeConstructed
)
)
{
RefPtr
<
AccEvent
>
reloadEvent
=
new
AccEvent
(
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_RELOAD
this
)
;
nsEventShell
:
:
FireEvent
(
reloadEvent
)
;
}
RefPtr
<
AccEvent
>
stateEvent
=
new
AccStateChangeEvent
(
this
states
:
:
BUSY
true
)
;
FireDelayedEvent
(
stateEvent
)
;
}
void
DocAccessible
:
:
DoInitialUpdate
(
)
{
AUTO_PROFILER_MARKER_TEXT
(
"
DocAccessible
:
:
DoInitialUpdate
"
A11Y
{
}
"
"
_ns
)
;
PerfStats
:
:
AutoMetricRecording
<
PerfStats
:
:
Metric
:
:
A11Y_DoInitialUpdate
>
autoRecording
;
if
(
nsCoreUtils
:
:
IsTopLevelContentDocInProcess
(
mDocumentNode
)
)
{
mDocFlags
|
=
eTopLevelContentDocInProcess
;
if
(
IPCAccessibilityActive
(
)
)
{
nsIDocShell
*
docShell
=
mDocumentNode
-
>
GetDocShell
(
)
;
if
(
RefPtr
<
dom
:
:
BrowserChild
>
browserChild
=
dom
:
:
BrowserChild
:
:
GetFrom
(
docShell
)
)
{
MOZ_ASSERT
(
IsRoot
(
)
)
;
DocAccessibleChild
*
ipcDoc
=
IPCDoc
(
)
;
if
(
!
ipcDoc
)
{
ipcDoc
=
new
DocAccessibleChild
(
this
browserChild
)
;
MOZ_RELEASE_ASSERT
(
browserChild
-
>
SendPDocAccessibleConstructor
(
ipcDoc
nullptr
0
mDocumentNode
-
>
GetBrowsingContext
(
)
)
)
;
SetIPCDoc
(
ipcDoc
)
;
}
}
}
}
mLoadState
|
=
eTreeConstructed
;
UpdateRootElIfNeeded
(
)
;
CacheChildrenInSubtree
(
this
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eVerbose
)
)
{
logging
:
:
Tree
(
"
TREE
"
"
Initial
subtree
"
this
)
;
}
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTreeSize
)
)
{
logging
:
:
TreeSize
(
"
TREE
SIZE
"
"
Initial
subtree
"
this
)
;
}
#
endif
if
(
!
IsRoot
(
)
)
{
RefPtr
<
AccReorderEvent
>
reorderEvent
=
new
AccReorderEvent
(
LocalParent
(
)
)
;
ParentDocument
(
)
-
>
FireDelayedEvent
(
reorderEvent
)
;
}
if
(
ipc
:
:
ProcessChild
:
:
ExpectingShutdown
(
)
)
{
return
;
}
if
(
IPCAccessibilityActive
(
)
)
{
DocAccessibleChild
*
ipcDoc
=
IPCDoc
(
)
;
MOZ_ASSERT
(
ipcDoc
)
;
if
(
ipcDoc
)
{
SendCache
(
nsAccessibilityService
:
:
GetActiveCacheDomains
(
)
CacheUpdateType
:
:
Initial
)
;
for
(
auto
idx
=
0U
;
idx
<
mChildren
.
Length
(
)
;
idx
+
+
)
{
ipcDoc
-
>
InsertIntoIpcTree
(
mChildren
.
ElementAt
(
idx
)
true
)
;
}
}
}
}
void
DocAccessible
:
:
ProcessLoad
(
)
{
mLoadState
|
=
eCompletelyLoaded
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocLoad
)
)
{
logging
:
:
DocCompleteLoad
(
this
IsLoadEventTarget
(
)
)
;
}
#
endif
if
(
!
IsLoadEventTarget
(
)
)
return
;
if
(
mLoadEventType
)
{
RefPtr
<
AccEvent
>
loadEvent
=
new
AccEvent
(
mLoadEventType
this
)
;
FireDelayedEvent
(
loadEvent
)
;
mLoadEventType
=
0
;
}
RefPtr
<
AccEvent
>
stateEvent
=
new
AccStateChangeEvent
(
this
states
:
:
BUSY
false
)
;
FireDelayedEvent
(
stateEvent
)
;
}
void
DocAccessible
:
:
AddDependentIDsFor
(
LocalAccessible
*
aRelProvider
nsAtom
*
aRelAttr
)
{
dom
:
:
Element
*
relProviderEl
=
aRelProvider
-
>
Elm
(
)
;
if
(
!
relProviderEl
)
return
;
for
(
uint32_t
idx
=
0
;
idx
<
kRelationAttrsLen
;
idx
+
+
)
{
nsStaticAtom
*
relAttr
=
kRelationAttrs
[
idx
]
;
if
(
aRelAttr
&
&
aRelAttr
!
=
relAttr
)
continue
;
if
(
relAttr
=
=
nsGkAtoms
:
:
_for
)
{
if
(
!
relProviderEl
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
label
nsGkAtoms
:
:
output
)
)
{
continue
;
}
}
else
if
(
relAttr
=
=
nsGkAtoms
:
:
control
)
{
if
(
!
relProviderEl
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
label
nsGkAtoms
:
:
description
)
)
{
continue
;
}
}
IDRefsIterator
iter
(
this
relProviderEl
relAttr
)
;
while
(
true
)
{
const
nsDependentSubstring
id
=
iter
.
NextID
(
)
;
if
(
id
.
IsEmpty
(
)
)
break
;
AttrRelProviders
*
providers
=
GetOrCreateRelProviders
(
relProviderEl
id
)
;
if
(
providers
)
{
AttrRelProvider
*
provider
=
new
AttrRelProvider
(
relAttr
relProviderEl
)
;
if
(
provider
)
{
providers
-
>
AppendElement
(
provider
)
;
nsIContent
*
dependentContent
=
iter
.
GetElem
(
id
)
;
if
(
dependentContent
)
{
if
(
!
HasAccessible
(
dependentContent
)
)
{
mInvalidationList
.
AppendElement
(
dependentContent
)
;
}
}
}
}
}
if
(
aRelAttr
)
break
;
}
mNotificationController
-
>
ScheduleProcessing
(
)
;
}
void
DocAccessible
:
:
RemoveDependentIDsFor
(
LocalAccessible
*
aRelProvider
nsAtom
*
aRelAttr
)
{
dom
:
:
Element
*
relProviderElm
=
aRelProvider
-
>
Elm
(
)
;
if
(
!
relProviderElm
)
return
;
for
(
uint32_t
idx
=
0
;
idx
<
kRelationAttrsLen
;
idx
+
+
)
{
nsStaticAtom
*
relAttr
=
kRelationAttrs
[
idx
]
;
if
(
aRelAttr
&
&
aRelAttr
!
=
kRelationAttrs
[
idx
]
)
continue
;
IDRefsIterator
iter
(
this
relProviderElm
relAttr
)
;
while
(
true
)
{
const
nsDependentSubstring
id
=
iter
.
NextID
(
)
;
if
(
id
.
IsEmpty
(
)
)
break
;
AttrRelProviders
*
providers
=
GetRelProviders
(
relProviderElm
id
)
;
if
(
providers
)
{
providers
-
>
RemoveElementsBy
(
[
relAttr
relProviderElm
]
(
const
auto
&
provider
)
{
return
provider
-
>
mRelAttr
=
=
relAttr
&
&
provider
-
>
mContent
=
=
relProviderElm
;
}
)
;
RemoveRelProvidersIfEmpty
(
relProviderElm
id
)
;
}
}
if
(
aRelAttr
)
break
;
}
}
void
DocAccessible
:
:
AddDependentElementsFor
(
LocalAccessible
*
aRelProvider
nsAtom
*
aRelAttr
)
{
dom
:
:
Element
*
providerEl
=
aRelProvider
-
>
Elm
(
)
;
if
(
!
providerEl
)
{
return
;
}
for
(
nsStaticAtom
*
attr
:
kSingleElementRelationIdlAttrs
)
{
if
(
aRelAttr
&
&
aRelAttr
!
=
attr
)
{
continue
;
}
if
(
dom
:
:
Element
*
targetEl
=
providerEl
-
>
GetExplicitlySetAttrElement
(
attr
)
)
{
AttrRelProviders
&
providers
=
mDependentElementsMap
.
LookupOrInsert
(
targetEl
)
;
AttrRelProvider
*
provider
=
new
AttrRelProvider
(
attr
providerEl
)
;
providers
.
AppendElement
(
provider
)
;
}
if
(
aRelAttr
)
{
break
;
}
}
aria
:
:
AttrWithCharacteristicsIterator
multipleElementsRelationIter
(
ATTR_REFLECT_ELEMENTS
)
;
while
(
multipleElementsRelationIter
.
Next
(
)
)
{
nsStaticAtom
*
attr
=
multipleElementsRelationIter
.
AttrName
(
)
;
if
(
aRelAttr
&
&
aRelAttr
!
=
attr
)
{
continue
;
}
nsTArray
<
dom
:
:
Element
*
>
elements
;
nsAccUtils
:
:
GetARIAElementsAttr
(
providerEl
attr
elements
)
;
for
(
dom
:
:
Element
*
targetEl
:
elements
)
{
AttrRelProviders
&
providers
=
mDependentElementsMap
.
LookupOrInsert
(
targetEl
)
;
AttrRelProvider
*
provider
=
new
AttrRelProvider
(
attr
providerEl
)
;
providers
.
AppendElement
(
provider
)
;
}
if
(
aRelAttr
)
{
break
;
}
}
}
void
DocAccessible
:
:
RemoveDependentElementsFor
(
LocalAccessible
*
aRelProvider
nsAtom
*
aRelAttr
)
{
dom
:
:
Element
*
providerEl
=
aRelProvider
-
>
Elm
(
)
;
if
(
!
providerEl
)
{
return
;
}
for
(
nsStaticAtom
*
attr
:
kSingleElementRelationIdlAttrs
)
{
if
(
aRelAttr
&
&
aRelAttr
!
=
attr
)
{
continue
;
}
if
(
dom
:
:
Element
*
targetEl
=
providerEl
-
>
GetExplicitlySetAttrElement
(
attr
)
)
{
if
(
auto
providers
=
mDependentElementsMap
.
Lookup
(
targetEl
)
)
{
providers
.
Data
(
)
.
RemoveElementsBy
(
[
attr
providerEl
]
(
const
auto
&
provider
)
{
return
provider
-
>
mRelAttr
=
=
attr
&
&
provider
-
>
mContent
=
=
providerEl
;
}
)
;
if
(
providers
.
Data
(
)
.
IsEmpty
(
)
)
{
providers
.
Remove
(
)
;
}
}
}
if
(
aRelAttr
)
{
break
;
}
}
aria
:
:
AttrWithCharacteristicsIterator
multipleElementsRelationIter
(
ATTR_REFLECT_ELEMENTS
)
;
while
(
multipleElementsRelationIter
.
Next
(
)
)
{
nsStaticAtom
*
attr
=
multipleElementsRelationIter
.
AttrName
(
)
;
if
(
aRelAttr
&
&
aRelAttr
!
=
attr
)
{
continue
;
}
nsTArray
<
dom
:
:
Element
*
>
elements
;
nsAccUtils
:
:
GetARIAElementsAttr
(
providerEl
attr
elements
)
;
for
(
dom
:
:
Element
*
targetEl
:
elements
)
{
if
(
auto
providers
=
mDependentElementsMap
.
Lookup
(
targetEl
)
)
{
providers
.
Data
(
)
.
RemoveElementsBy
(
[
attr
providerEl
]
(
const
auto
&
provider
)
{
return
provider
-
>
mRelAttr
=
=
attr
&
&
provider
-
>
mContent
=
=
providerEl
;
}
)
;
if
(
providers
.
Data
(
)
.
IsEmpty
(
)
)
{
providers
.
Remove
(
)
;
}
}
}
if
(
aRelAttr
)
{
break
;
}
}
}
bool
DocAccessible
:
:
UpdateAccessibleOnAttrChange
(
dom
:
:
Element
*
aElement
nsAtom
*
aAttribute
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
role
)
{
if
(
mContent
=
=
aElement
)
{
SetRoleMapEntryForDoc
(
aElement
)
;
if
(
mIPCDoc
)
{
mIPCDoc
-
>
SendRoleChangedEvent
(
Role
(
)
mRoleMapEntryIndex
)
;
}
return
true
;
}
RecreateAccessible
(
aElement
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
multiple
)
{
if
(
dom
:
:
HTMLSelectElement
*
select
=
dom
:
:
HTMLSelectElement
:
:
FromNode
(
aElement
)
)
{
if
(
select
-
>
Size
(
)
<
=
1
)
{
RecreateAccessible
(
aElement
)
;
return
true
;
}
}
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
size
&
&
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
select
)
)
{
RecreateAccessible
(
aElement
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
type
)
{
RecreateAccessible
(
aElement
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
href
&
&
!
nsCoreUtils
:
:
HasClickListener
(
aElement
)
)
{
if
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
)
{
LocalAccessible
*
acc
=
GetAccessible
(
aElement
)
;
if
(
!
acc
)
{
return
false
;
}
if
(
acc
-
>
IsHTMLLink
(
)
!
=
aElement
-
>
HasAttr
(
nsGkAtoms
:
:
href
)
)
{
RecreateAccessible
(
aElement
)
;
return
true
;
}
}
else
if
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
{
LocalAccessible
*
areaAcc
=
GetAccessibleEvenIfNotInMap
(
aElement
)
;
if
(
!
areaAcc
|
|
!
areaAcc
-
>
LocalParent
(
)
)
{
return
false
;
}
RecreateAccessible
(
areaAcc
-
>
LocalParent
(
)
-
>
GetContent
(
)
)
;
return
true
;
}
}
if
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
alt
)
{
if
(
nsAccessibilityService
:
:
ShouldCreateImgAccessible
(
aElement
this
)
)
{
if
(
GetAccessible
(
aElement
)
)
{
return
false
;
}
ContentInserted
(
aElement
aElement
-
>
GetNextSibling
(
)
)
;
}
else
{
ContentRemoved
(
aElement
)
;
}
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
popover
&
&
aElement
-
>
IsHTMLElement
(
)
)
{
RecreateAccessible
(
aElement
)
;
return
true
;
}
return
false
;
}
void
DocAccessible
:
:
UpdateRootElIfNeeded
(
)
{
dom
:
:
Element
*
rootEl
=
mDocumentNode
-
>
GetBodyElement
(
)
;
if
(
!
rootEl
)
{
rootEl
=
mDocumentNode
-
>
GetRootElement
(
)
;
}
if
(
rootEl
!
=
mContent
)
{
mContent
=
rootEl
;
SetRoleMapEntryForDoc
(
rootEl
)
;
if
(
mIPCDoc
)
{
mIPCDoc
-
>
SendRoleChangedEvent
(
Role
(
)
mRoleMapEntryIndex
)
;
}
}
}
class
InsertIterator
final
{
public
:
InsertIterator
(
LocalAccessible
*
aContext
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
aNodes
)
:
mChild
(
nullptr
)
mChildBefore
(
nullptr
)
mWalker
(
aContext
)
mNodes
(
aNodes
)
mNodesIdx
(
0
)
{
MOZ_ASSERT
(
aContext
"
No
context
"
)
;
MOZ_ASSERT
(
aNodes
"
No
nodes
to
search
for
accessible
elements
"
)
;
MOZ_COUNT_CTOR
(
InsertIterator
)
;
}
MOZ_COUNTED_DTOR
(
InsertIterator
)
LocalAccessible
*
Context
(
)
const
{
return
mWalker
.
Context
(
)
;
}
LocalAccessible
*
Child
(
)
const
{
return
mChild
;
}
LocalAccessible
*
ChildBefore
(
)
const
{
return
mChildBefore
;
}
DocAccessible
*
Document
(
)
const
{
return
mWalker
.
Document
(
)
;
}
bool
Next
(
)
;
void
Rejected
(
)
{
mChild
=
nullptr
;
mChildBefore
=
nullptr
;
}
private
:
LocalAccessible
*
mChild
;
LocalAccessible
*
mChildBefore
;
TreeWalker
mWalker
;
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
mNodes
;
nsTHashSet
<
nsPtrHashKey
<
const
nsIContent
>
>
mProcessedNodes
;
uint32_t
mNodesIdx
;
}
;
bool
InsertIterator
:
:
Next
(
)
{
if
(
mNodesIdx
>
0
)
{
LocalAccessible
*
nextChild
=
mWalker
.
Next
(
)
;
if
(
nextChild
)
{
mChildBefore
=
mChild
;
mChild
=
nextChild
;
return
true
;
}
}
while
(
mNodesIdx
<
mNodes
-
>
Length
(
)
)
{
nsIContent
*
node
=
mNodes
-
>
ElementAt
(
mNodesIdx
+
+
)
;
if
(
!
mProcessedNodes
.
EnsureInserted
(
node
)
)
{
continue
;
}
LocalAccessible
*
container
=
Document
(
)
-
>
AccessibleOrTrueContainer
(
node
-
>
GetFlattenedTreeParentNode
(
)
true
)
;
if
(
container
!
=
Context
(
)
)
{
continue
;
}
if
(
container
-
>
IsHTMLCombobox
(
)
)
{
container
=
container
-
>
LocalFirstChild
(
)
;
}
if
(
!
container
-
>
IsAcceptableChild
(
node
)
)
{
continue
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
traversing
an
inserted
node
"
logging
:
:
eVerbose
"
container
"
container
"
node
"
node
)
;
#
endif
nsIContent
*
prevNode
=
mChild
?
mChild
-
>
GetContent
(
)
:
nullptr
;
if
(
prevNode
&
&
prevNode
-
>
GetNextSibling
(
)
=
=
node
)
{
LocalAccessible
*
nextChild
=
mWalker
.
Scope
(
node
)
;
if
(
nextChild
)
{
mChildBefore
=
mChild
;
mChild
=
nextChild
;
return
true
;
}
}
else
{
TreeWalker
finder
(
container
)
;
if
(
finder
.
Seek
(
node
)
)
{
mChild
=
mWalker
.
Scope
(
node
)
;
if
(
mChild
)
{
MOZ_ASSERT
(
!
mChild
-
>
IsRelocated
(
)
"
child
cannot
be
aria
owned
"
)
;
mChildBefore
=
finder
.
Prev
(
)
;
return
true
;
}
}
}
}
return
false
;
}
void
DocAccessible
:
:
MaybeFireEventsForChangedPopover
(
LocalAccessible
*
aAcc
)
{
dom
:
:
Element
*
el
=
aAcc
-
>
Elm
(
)
;
if
(
!
el
|
|
!
el
-
>
IsHTMLElement
(
)
|
|
!
el
-
>
HasAttr
(
nsGkAtoms
:
:
popover
)
)
{
return
;
}
RelatedAccIterator
invokers
(
mDoc
el
nsGkAtoms
:
:
popovertarget
)
;
while
(
Accessible
*
invoker
=
invokers
.
Next
(
)
)
{
RefPtr
<
AccEvent
>
expandedChangeEvent
=
new
AccStateChangeEvent
(
invoker
-
>
AsLocal
(
)
states
:
:
EXPANDED
)
;
FireDelayedEvent
(
expandedChangeEvent
)
;
}
}
void
DocAccessible
:
:
ProcessContentInserted
(
LocalAccessible
*
aContainer
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
aNodes
)
{
if
(
!
aContainer
-
>
IsInDocument
(
)
)
{
return
;
}
if
(
aContainer
=
=
this
)
{
UpdateRootElIfNeeded
(
)
;
}
InsertIterator
iter
(
aContainer
aNodes
)
;
if
(
!
iter
.
Next
(
)
)
{
return
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
children
before
insertion
"
logging
:
:
eVerbose
aContainer
)
;
#
endif
TreeMutation
mt
(
aContainer
)
;
bool
inserted
=
false
;
do
{
LocalAccessible
*
parent
=
iter
.
Child
(
)
-
>
LocalParent
(
)
;
if
(
parent
)
{
LocalAccessible
*
previousSibling
=
iter
.
ChildBefore
(
)
;
if
(
parent
!
=
aContainer
|
|
iter
.
Child
(
)
-
>
LocalPrevSibling
(
)
!
=
previousSibling
)
{
if
(
previousSibling
&
&
previousSibling
-
>
LocalParent
(
)
!
=
aContainer
)
{
MOZ_DIAGNOSTIC_ASSERT
(
parent
=
=
aContainer
"
Child
moving
to
new
parent
but
previous
"
"
sibling
in
wrong
parent
"
)
;
continue
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
relocating
accessible
"
0
"
old
parent
"
parent
"
new
parent
"
aContainer
"
child
"
iter
.
Child
(
)
nullptr
)
;
#
endif
MoveChild
(
iter
.
Child
(
)
aContainer
previousSibling
?
previousSibling
-
>
IndexInParent
(
)
+
1
:
0
)
;
inserted
=
true
;
}
continue
;
}
if
(
aContainer
-
>
InsertAfter
(
iter
.
Child
(
)
iter
.
ChildBefore
(
)
)
)
{
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
accessible
was
inserted
"
0
"
container
"
aContainer
"
child
"
iter
.
Child
(
)
nullptr
)
;
#
endif
CreateSubtree
(
iter
.
Child
(
)
)
;
mt
.
AfterInsertion
(
iter
.
Child
(
)
)
;
inserted
=
true
;
MaybeFireEventsForChangedPopover
(
iter
.
Child
(
)
)
;
continue
;
}
MOZ_ASSERT_UNREACHABLE
(
"
accessible
was
rejected
"
)
;
iter
.
Rejected
(
)
;
}
while
(
iter
.
Next
(
)
)
;
mt
.
Done
(
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
children
after
insertion
"
logging
:
:
eVerbose
aContainer
)
;
#
endif
if
(
inserted
)
{
FireEventsOnInsertion
(
aContainer
)
;
}
}
void
DocAccessible
:
:
ProcessContentInserted
(
LocalAccessible
*
aContainer
nsIContent
*
aNode
)
{
if
(
!
aContainer
-
>
IsInDocument
(
)
)
{
return
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
children
before
insertion
"
logging
:
:
eVerbose
aContainer
)
;
#
endif
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
traversing
an
inserted
node
"
logging
:
:
eVerbose
"
container
"
aContainer
"
node
"
aNode
)
;
#
endif
TreeWalker
walker
(
aContainer
)
;
if
(
aContainer
-
>
IsAcceptableChild
(
aNode
)
&
&
walker
.
Seek
(
aNode
)
)
{
LocalAccessible
*
child
=
GetAccessible
(
aNode
)
;
if
(
!
child
)
{
child
=
GetAccService
(
)
-
>
CreateAccessible
(
aNode
aContainer
)
;
}
if
(
child
)
{
TreeMutation
mt
(
aContainer
)
;
if
(
!
aContainer
-
>
InsertAfter
(
child
walker
.
Prev
(
)
)
)
{
return
;
}
CreateSubtree
(
child
)
;
mt
.
AfterInsertion
(
child
)
;
mt
.
Done
(
)
;
FireEventsOnInsertion
(
aContainer
)
;
}
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
children
after
insertion
"
logging
:
:
eVerbose
aContainer
)
;
#
endif
}
void
DocAccessible
:
:
FireEventsOnInsertion
(
LocalAccessible
*
aContainer
)
{
if
(
aContainer
-
>
IsAlert
(
)
|
|
aContainer
-
>
IsInsideAlert
(
)
)
{
LocalAccessible
*
ancestor
=
aContainer
;
do
{
if
(
ancestor
-
>
IsAlert
(
)
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_ALERT
ancestor
)
;
break
;
}
}
while
(
(
ancestor
=
ancestor
-
>
LocalParent
(
)
)
)
;
}
}
void
DocAccessible
:
:
ContentRemoved
(
LocalAccessible
*
aChild
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aChild
!
=
this
"
Should
never
be
called
for
the
doc
"
)
;
LocalAccessible
*
parent
=
aChild
-
>
LocalParent
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
parent
"
Unattached
accessible
from
tree
"
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
process
content
removal
"
0
"
container
"
parent
"
child
"
aChild
nullptr
)
;
#
endif
RefPtr
<
LocalAccessible
>
kungFuDeathGripChild
(
aChild
)
;
TreeMutation
mt
(
parent
)
;
mt
.
BeforeRemoval
(
aChild
)
;
if
(
aChild
-
>
IsDefunct
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Event
coalescence
killed
the
accessible
"
)
;
mt
.
Done
(
)
;
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aChild
-
>
LocalParent
(
)
"
Alive
but
unparented
#
1
"
)
;
if
(
aChild
-
>
IsRelocated
(
)
)
{
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
owned
=
mARIAOwnsHash
.
Get
(
parent
)
;
MOZ_ASSERT
(
owned
"
IsRelocated
flag
is
out
of
sync
with
mARIAOwnsHash
"
)
;
owned
-
>
RemoveElement
(
aChild
)
;
if
(
owned
-
>
Length
(
)
=
=
0
)
{
mARIAOwnsHash
.
Remove
(
parent
)
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
aChild
-
>
LocalParent
(
)
"
Unparented
#
2
"
)
;
UncacheChildrenInSubtree
(
aChild
)
;
parent
-
>
RemoveChild
(
aChild
)
;
mt
.
Done
(
)
;
}
void
DocAccessible
:
:
ContentRemoved
(
nsIContent
*
aContentNode
)
{
if
(
!
mRemovedNodes
.
EnsureInserted
(
aContentNode
)
)
{
return
;
}
LocalAccessible
*
acc
=
GetAccessible
(
aContentNode
)
;
if
(
acc
)
{
ContentRemoved
(
acc
)
;
}
dom
:
:
AllChildrenIterator
iter
=
dom
:
:
AllChildrenIterator
(
aContentNode
nsIContent
:
:
eAllChildren
true
)
;
while
(
nsIContent
*
childNode
=
iter
.
GetNextChild
(
)
)
{
ContentRemoved
(
childNode
)
;
}
if
(
aContentNode
-
>
GetShadowRoot
(
)
)
{
for
(
nsIContent
*
childNode
=
aContentNode
-
>
GetFirstChild
(
)
;
childNode
;
childNode
=
childNode
-
>
GetNextSibling
(
)
)
{
ContentRemoved
(
childNode
)
;
}
}
}
bool
DocAccessible
:
:
RelocateARIAOwnedIfNeeded
(
nsIContent
*
aElement
)
{
if
(
!
aElement
-
>
HasID
(
)
)
return
false
;
AttrRelProviders
*
list
=
GetRelProviders
(
aElement
-
>
AsElement
(
)
nsDependentAtomString
(
aElement
-
>
GetID
(
)
)
)
;
if
(
list
)
{
for
(
uint32_t
idx
=
0
;
idx
<
list
-
>
Length
(
)
;
idx
+
+
)
{
if
(
list
-
>
ElementAt
(
idx
)
-
>
mRelAttr
=
=
nsGkAtoms
:
:
aria_owns
)
{
LocalAccessible
*
owner
=
GetAccessible
(
list
-
>
ElementAt
(
idx
)
-
>
mContent
)
;
if
(
owner
)
{
mNotificationController
-
>
ScheduleRelocation
(
owner
)
;
return
true
;
}
}
}
}
return
false
;
}
void
DocAccessible
:
:
DoARIAOwnsRelocation
(
LocalAccessible
*
aOwner
)
{
MOZ_ASSERT
(
aOwner
"
aOwner
must
be
a
valid
pointer
"
)
;
MOZ_ASSERT
(
aOwner
-
>
Elm
(
)
"
aOwner
-
>
Elm
(
)
must
be
a
valid
pointer
"
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
aria
owns
relocation
"
logging
:
:
eVerbose
aOwner
)
;
#
endif
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
owned
=
mARIAOwnsHash
.
GetOrInsertNew
(
aOwner
)
;
IDRefsIterator
iter
(
this
aOwner
-
>
Elm
(
)
nsGkAtoms
:
:
aria_owns
)
;
uint32_t
idx
=
0
;
while
(
nsIContent
*
childEl
=
iter
.
NextElem
(
)
)
{
LocalAccessible
*
child
=
GetAccessible
(
childEl
)
;
auto
insertIdx
=
aOwner
-
>
ChildCount
(
)
-
owned
-
>
Length
(
)
+
idx
;
if
(
!
child
)
{
bool
ok
=
true
;
bool
check
=
true
;
for
(
LocalAccessible
*
parent
=
aOwner
;
parent
&
&
!
parent
-
>
IsDoc
(
)
;
parent
=
parent
-
>
LocalParent
(
)
)
{
if
(
check
)
{
if
(
parent
-
>
Elm
(
)
-
>
IsInclusiveDescendantOf
(
childEl
)
)
{
ok
=
false
;
break
;
}
}
check
=
parent
-
>
IsRelocated
(
)
;
}
if
(
!
ok
)
{
continue
;
}
if
(
aOwner
-
>
IsAcceptableChild
(
childEl
)
)
{
child
=
GetAccService
(
)
-
>
CreateAccessible
(
childEl
aOwner
)
;
if
(
child
)
{
TreeMutation
imut
(
aOwner
)
;
aOwner
-
>
InsertChildAt
(
insertIdx
child
)
;
imut
.
AfterInsertion
(
child
)
;
imut
.
Done
(
)
;
child
-
>
SetRelocated
(
true
)
;
owned
-
>
InsertElementAt
(
idx
child
)
;
idx
+
+
;
CreateSubtree
(
child
)
;
FireEventsOnInsertion
(
aOwner
)
;
}
}
continue
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
aria
owns
traversal
"
logging
:
:
eVerbose
"
candidate
"
child
nullptr
)
;
#
endif
if
(
owned
-
>
IndexOf
(
child
)
<
idx
)
{
continue
;
}
if
(
child
-
>
LocalParent
(
)
=
=
aOwner
)
{
int32_t
indexInParent
=
child
-
>
IndexInParent
(
)
;
if
(
indexInParent
=
=
static_cast
<
int32_t
>
(
insertIdx
)
)
{
MOZ_ASSERT
(
child
-
>
IsRelocated
(
)
"
A
child
having
an
index
in
parent
from
aria
ownded
"
"
indices
range
has
to
be
aria
owned
"
)
;
MOZ_ASSERT
(
owned
-
>
ElementAt
(
idx
)
=
=
child
"
Unexpected
child
in
ARIA
owned
array
"
)
;
idx
+
+
;
continue
;
}
if
(
indexInParent
=
=
static_cast
<
int32_t
>
(
insertIdx
)
-
1
)
{
MOZ_ASSERT
(
!
child
-
>
IsRelocated
(
)
"
Child
should
be
in
its
ordinal
position
"
)
;
child
-
>
SetRelocated
(
true
)
;
owned
-
>
InsertElementAt
(
idx
child
)
;
idx
+
+
;
continue
;
}
}
MOZ_ASSERT
(
owned
-
>
SafeElementAt
(
idx
)
!
=
child
"
Already
in
place
!
"
)
;
if
(
child
-
>
LocalParent
(
)
!
=
aOwner
)
{
if
(
child
-
>
IsRelocated
(
)
)
{
continue
;
}
LocalAccessible
*
parent
=
aOwner
;
while
(
parent
&
&
parent
!
=
child
&
&
!
parent
-
>
IsDoc
(
)
)
{
parent
=
parent
-
>
LocalParent
(
)
;
}
if
(
parent
=
=
child
)
{
continue
;
}
}
if
(
MoveChild
(
child
aOwner
insertIdx
)
)
{
child
-
>
SetRelocated
(
true
)
;
MOZ_ASSERT
(
owned
=
=
mARIAOwnsHash
.
Get
(
aOwner
)
)
;
owned
=
mARIAOwnsHash
.
GetOrInsertNew
(
aOwner
)
;
owned
-
>
InsertElementAt
(
idx
child
)
;
idx
+
+
;
}
}
PutChildrenBack
(
owned
idx
)
;
if
(
owned
-
>
Length
(
)
=
=
0
)
{
mARIAOwnsHash
.
Remove
(
aOwner
)
;
}
}
void
DocAccessible
:
:
PutChildrenBack
(
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
aChildren
uint32_t
aStartIdx
)
{
MOZ_ASSERT
(
aStartIdx
<
=
aChildren
-
>
Length
(
)
"
Wrong
removal
index
"
)
;
for
(
auto
idx
=
aStartIdx
;
idx
<
aChildren
-
>
Length
(
)
;
idx
+
+
)
{
LocalAccessible
*
child
=
aChildren
-
>
ElementAt
(
idx
)
;
if
(
!
child
-
>
IsInDocument
(
)
)
{
continue
;
}
LocalAccessible
*
owner
=
child
-
>
LocalParent
(
)
;
if
(
!
owner
)
{
NS_ERROR
(
"
Cannot
put
the
child
back
.
No
parent
a
broken
tree
.
"
)
;
continue
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
aria
owns
put
child
back
"
0
"
old
parent
"
owner
"
child
"
child
nullptr
)
;
#
endif
child
-
>
SetRelocated
(
false
)
;
nsIContent
*
content
=
child
-
>
GetContent
(
)
;
int32_t
idxInParent
=
-
1
;
LocalAccessible
*
origContainer
=
AccessibleOrTrueContainer
(
content
-
>
GetFlattenedTreeParentNode
(
)
)
;
if
(
!
origContainer
)
{
continue
;
}
bool
origContainerHasOutOfDocAncestor
=
false
;
LocalAccessible
*
ancestor
=
origContainer
;
while
(
ancestor
)
{
if
(
ancestor
-
>
IsDoc
(
)
)
{
break
;
}
if
(
!
ancestor
-
>
IsInDocument
(
)
)
{
origContainerHasOutOfDocAncestor
=
true
;
break
;
}
ancestor
=
ancestor
-
>
LocalParent
(
)
;
}
if
(
origContainerHasOutOfDocAncestor
)
{
continue
;
}
TreeWalker
walker
(
origContainer
)
;
if
(
!
walker
.
Seek
(
content
)
)
{
continue
;
}
LocalAccessible
*
prevChild
=
walker
.
Prev
(
)
;
if
(
prevChild
)
{
idxInParent
=
prevChild
-
>
IndexInParent
(
)
+
1
;
MOZ_DIAGNOSTIC_ASSERT
(
origContainer
=
=
prevChild
-
>
LocalParent
(
)
"
Broken
tree
"
)
;
origContainer
=
prevChild
-
>
LocalParent
(
)
;
}
else
{
idxInParent
=
0
;
}
if
(
origContainer
!
=
owner
|
|
child
-
>
IndexInParent
(
)
!
=
idxInParent
)
{
if
(
origContainer
-
>
IsAcceptableChild
(
child
-
>
GetContent
(
)
)
)
{
DebugOnly
<
bool
>
moved
=
MoveChild
(
child
origContainer
idxInParent
)
;
MOZ_ASSERT
(
moved
"
Failed
to
put
child
back
.
"
)
;
}
}
else
{
MOZ_ASSERT
(
!
child
-
>
LocalPrevSibling
(
)
|
|
!
child
-
>
LocalPrevSibling
(
)
-
>
IsRelocated
(
)
"
No
relocated
child
should
appear
before
this
one
"
)
;
MOZ_ASSERT
(
!
child
-
>
LocalNextSibling
(
)
|
|
child
-
>
LocalNextSibling
(
)
-
>
IsRelocated
(
)
"
No
ordinal
child
should
appear
after
this
one
"
)
;
}
}
aChildren
-
>
RemoveLastElements
(
aChildren
-
>
Length
(
)
-
aStartIdx
)
;
}
void
DocAccessible
:
:
TrackMovedAccessible
(
LocalAccessible
*
aAcc
)
{
MOZ_ASSERT
(
aAcc
-
>
mDoc
=
=
this
)
;
if
(
!
mInsertedAccessibles
.
Contains
(
aAcc
)
)
{
mMovedAccessibles
.
EnsureInserted
(
aAcc
)
;
}
if
(
aAcc
-
>
IsOuterDoc
(
)
)
{
return
;
}
for
(
uint32_t
c
=
0
count
=
aAcc
-
>
ContentChildCount
(
)
;
c
<
count
;
+
+
c
)
{
TrackMovedAccessible
(
aAcc
-
>
ContentChildAt
(
c
)
)
;
}
}
bool
DocAccessible
:
:
MoveChild
(
LocalAccessible
*
aChild
LocalAccessible
*
aNewParent
int32_t
aIdxInParent
)
{
MOZ_ASSERT
(
aChild
"
No
child
"
)
;
MOZ_ASSERT
(
aChild
-
>
LocalParent
(
)
"
No
parent
"
)
;
MOZ_ASSERT
(
aIdxInParent
<
=
static_cast
<
int32_t
>
(
aNewParent
-
>
mChildren
.
Length
(
)
)
"
Wrong
insertion
point
for
a
moving
child
"
)
;
LocalAccessible
*
curParent
=
aChild
-
>
LocalParent
(
)
;
if
(
!
aNewParent
-
>
IsAcceptableChild
(
aChild
-
>
GetContent
(
)
)
)
{
return
false
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
move
child
"
0
"
old
parent
"
curParent
"
new
parent
"
aNewParent
"
child
"
aChild
nullptr
)
;
#
endif
if
(
aChild
-
>
IsRelocated
(
)
)
{
aChild
-
>
SetRelocated
(
false
)
;
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
owned
=
mARIAOwnsHash
.
Get
(
curParent
)
;
MOZ_ASSERT
(
owned
"
IsRelocated
flag
is
out
of
sync
with
mARIAOwnsHash
"
)
;
owned
-
>
RemoveElement
(
aChild
)
;
if
(
owned
-
>
Length
(
)
=
=
0
)
{
mARIAOwnsHash
.
Remove
(
curParent
)
;
}
}
if
(
curParent
=
=
aNewParent
)
{
MOZ_ASSERT
(
aChild
-
>
IndexInParent
(
)
!
=
aIdxInParent
"
No
move
case
"
)
;
curParent
-
>
RelocateChild
(
aIdxInParent
aChild
)
;
if
(
mIPCDoc
)
{
TrackMovedAccessible
(
aChild
)
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
move
child
:
parent
tree
after
"
logging
:
:
eVerbose
curParent
)
;
#
endif
return
true
;
}
bool
hasInsertionPoint
=
(
aIdxInParent
>
=
0
)
&
&
(
aIdxInParent
<
=
static_cast
<
int32_t
>
(
aNewParent
-
>
mChildren
.
Length
(
)
)
)
;
TreeMutation
rmut
(
curParent
)
;
rmut
.
BeforeRemoval
(
aChild
hasInsertionPoint
&
&
TreeMutation
:
:
kNoShutdown
)
;
curParent
-
>
RemoveChild
(
aChild
)
;
rmut
.
Done
(
)
;
if
(
!
hasInsertionPoint
)
{
return
true
;
}
TreeMutation
imut
(
aNewParent
)
;
aNewParent
-
>
InsertChildAt
(
aIdxInParent
aChild
)
;
if
(
mIPCDoc
)
{
TrackMovedAccessible
(
aChild
)
;
}
imut
.
AfterInsertion
(
aChild
)
;
imut
.
Done
(
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
move
child
:
old
parent
tree
after
"
logging
:
:
eVerbose
curParent
)
;
logging
:
:
TreeInfo
(
"
move
child
:
new
parent
tree
after
"
logging
:
:
eVerbose
aNewParent
)
;
#
endif
return
true
;
}
void
DocAccessible
:
:
CacheChildrenInSubtree
(
LocalAccessible
*
aRoot
LocalAccessible
*
*
aFocusedAcc
)
{
if
(
aFocusedAcc
&
&
!
*
aFocusedAcc
&
&
FocusMgr
(
)
-
>
HasDOMFocus
(
aRoot
-
>
GetContent
(
)
)
)
{
*
aFocusedAcc
=
aRoot
;
}
LocalAccessible
*
root
=
aRoot
-
>
IsHTMLCombobox
(
)
?
aRoot
-
>
LocalFirstChild
(
)
:
aRoot
;
if
(
root
-
>
KidsFromDOM
(
)
)
{
TreeMutation
mt
(
root
TreeMutation
:
:
kNoEvents
)
;
TreeWalker
walker
(
root
)
;
while
(
LocalAccessible
*
child
=
walker
.
Next
(
)
)
{
if
(
child
-
>
IsBoundToParent
(
)
)
{
MoveChild
(
child
root
root
-
>
mChildren
.
Length
(
)
)
;
continue
;
}
root
-
>
AppendChild
(
child
)
;
mt
.
AfterInsertion
(
child
)
;
CacheChildrenInSubtree
(
child
aFocusedAcc
)
;
}
mt
.
Done
(
)
;
}
if
(
!
aRoot
-
>
HasARIARole
(
)
)
{
return
;
}
roles
:
:
Role
role
=
aRoot
-
>
ARIARole
(
)
;
if
(
!
aRoot
-
>
IsDoc
(
)
&
&
(
role
=
=
roles
:
:
DIALOG
|
|
role
=
=
roles
:
:
NON_NATIVE_DOCUMENT
)
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_LOAD_COMPLETE
aRoot
)
;
}
}
void
DocAccessible
:
:
UncacheChildrenInSubtree
(
LocalAccessible
*
aRoot
)
{
MaybeFireEventsForChangedPopover
(
aRoot
)
;
aRoot
-
>
mStateFlags
|
=
eIsNotInDocument
;
RemoveDependentIDsFor
(
aRoot
)
;
RemoveDependentElementsFor
(
aRoot
)
;
if
(
aRoot
-
>
IsTable
(
)
|
|
aRoot
-
>
IsTableCell
(
)
)
{
CachedTableAccessible
:
:
Invalidate
(
aRoot
)
;
}
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
owned
=
mARIAOwnsHash
.
Get
(
aRoot
)
;
if
(
owned
)
{
PutChildrenBack
(
owned
0
)
;
MOZ_ASSERT
(
owned
-
>
IsEmpty
(
)
"
Owned
Accessibles
should
be
cleared
after
PutChildrenBack
.
"
)
;
mARIAOwnsHash
.
Remove
(
aRoot
)
;
owned
=
nullptr
;
}
const
uint32_t
count
=
aRoot
-
>
ContentChildCount
(
)
;
for
(
uint32_t
idx
=
0
;
idx
<
count
;
+
+
idx
)
{
LocalAccessible
*
child
=
aRoot
-
>
ContentChildAt
(
idx
)
;
MOZ_ASSERT
(
!
child
-
>
IsRelocated
(
)
"
No
children
should
be
relocated
here
.
They
should
all
have
"
"
been
relocated
by
PutChildrenBack
.
"
)
;
if
(
!
child
-
>
IsDoc
(
)
)
{
UncacheChildrenInSubtree
(
child
)
;
}
}
if
(
aRoot
-
>
IsNodeMapEntry
(
)
&
&
mNodeToAccessibleMap
.
Get
(
aRoot
-
>
GetNode
(
)
)
=
=
aRoot
)
{
mNodeToAccessibleMap
.
Remove
(
aRoot
-
>
GetNode
(
)
)
;
}
}
void
DocAccessible
:
:
ShutdownChildrenInSubtree
(
LocalAccessible
*
aAccessible
)
{
MOZ_ASSERT
(
!
nsAccessibilityService
:
:
IsShutdown
(
)
)
;
uint32_t
count
=
aAccessible
-
>
ContentChildCount
(
)
;
for
(
uint32_t
idx
=
0
jdx
=
0
;
idx
<
count
;
idx
+
+
)
{
LocalAccessible
*
child
=
aAccessible
-
>
ContentChildAt
(
jdx
)
;
if
(
!
child
-
>
IsBoundToParent
(
)
)
{
NS_ERROR
(
"
Parent
refers
to
a
child
child
doesn
'
t
refer
to
parent
!
"
)
;
jdx
+
+
;
}
if
(
!
child
-
>
IsDoc
(
)
)
{
ShutdownChildrenInSubtree
(
child
)
;
if
(
nsAccessibilityService
:
:
IsShutdown
(
)
)
{
return
;
}
}
}
UnbindFromDocument
(
aAccessible
)
;
}
bool
DocAccessible
:
:
IsLoadEventTarget
(
)
const
{
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
=
mDocumentNode
-
>
GetDocShell
(
)
;
if
(
!
treeItem
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parentTreeItem
;
treeItem
-
>
GetInProcessParent
(
getter_AddRefs
(
parentTreeItem
)
)
;
if
(
parentTreeItem
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
rootTreeItem
;
treeItem
-
>
GetInProcessRootTreeItem
(
getter_AddRefs
(
rootTreeItem
)
)
;
if
(
parentTreeItem
=
=
rootTreeItem
)
return
true
;
DocAccessible
*
parentDoc
=
ParentDocument
(
)
;
return
parentDoc
&
&
parentDoc
-
>
HasLoadState
(
eCompletelyLoaded
)
;
}
return
(
treeItem
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeContent
)
;
}
void
DocAccessible
:
:
SetIPCDoc
(
DocAccessibleChild
*
aIPCDoc
)
{
MOZ_ASSERT
(
!
mIPCDoc
|
|
!
aIPCDoc
"
Clobbering
an
attached
IPCDoc
!
"
)
;
mIPCDoc
=
aIPCDoc
;
}
void
DocAccessible
:
:
DispatchScrollingEvent
(
nsINode
*
aTarget
uint32_t
aEventType
)
{
LocalAccessible
*
acc
=
GetAccessible
(
aTarget
)
;
if
(
!
acc
)
{
return
;
}
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
!
frame
)
{
return
;
}
auto
[
scrollPoint
scrollRange
]
=
ComputeScrollData
(
acc
)
;
int32_t
appUnitsPerDevPixel
=
mPresShell
-
>
GetPresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceIntPoint
scrollPointDP
=
LayoutDevicePoint
:
:
FromAppUnitsToNearest
(
scrollPoint
appUnitsPerDevPixel
)
;
LayoutDeviceIntRect
scrollRangeDP
=
LayoutDeviceRect
:
:
FromAppUnitsToNearest
(
scrollRange
appUnitsPerDevPixel
)
;
RefPtr
<
AccEvent
>
event
=
new
AccScrollingEvent
(
aEventType
acc
scrollPointDP
.
x
scrollPointDP
.
y
scrollRangeDP
.
width
scrollRangeDP
.
height
)
;
nsEventShell
:
:
FireEvent
(
event
)
;
}
void
DocAccessible
:
:
ARIAActiveDescendantIDMaybeMoved
(
LocalAccessible
*
aAccessible
)
{
LocalAccessible
*
widget
=
nullptr
;
if
(
aAccessible
-
>
IsActiveDescendantId
(
&
widget
)
&
&
widget
)
{
mNotificationController
-
>
ScheduleNotification
<
DocAccessible
LocalAccessible
>
(
this
&
DocAccessible
:
:
ARIAActiveDescendantChanged
widget
)
;
}
}
void
DocAccessible
:
:
SetRoleMapEntryForDoc
(
dom
:
:
Element
*
aElement
)
{
const
nsRoleMapEntry
*
entry
=
aria
:
:
GetRoleMap
(
aElement
)
;
if
(
!
entry
|
|
entry
-
>
role
=
=
roles
:
:
APPLICATION
|
|
entry
-
>
role
=
=
roles
:
:
DIALOG
|
|
(
entry
-
>
role
=
=
roles
:
:
ALERT
&
&
!
mDocumentNode
-
>
IsContentDocument
(
)
)
)
{
SetRoleMapEntry
(
entry
)
;
return
;
}
SetRoleMapEntry
(
nullptr
)
;
}
LocalAccessible
*
DocAccessible
:
:
GetAccessible
(
nsINode
*
aNode
)
const
{
return
aNode
=
=
mDocumentNode
?
const_cast
<
DocAccessible
*
>
(
this
)
:
mNodeToAccessibleMap
.
Get
(
aNode
)
;
}
bool
DocAccessible
:
:
HasPrimaryAction
(
)
const
{
if
(
HyperTextAccessible
:
:
HasPrimaryAction
(
)
)
{
return
true
;
}
dom
:
:
Element
*
root
=
mDocumentNode
-
>
GetRootElement
(
)
;
if
(
mContent
!
=
root
)
{
return
nsCoreUtils
:
:
HasClickListener
(
root
)
;
}
return
false
;
}
void
DocAccessible
:
:
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
{
aName
.
Truncate
(
)
;
if
(
aIndex
!
=
0
)
{
return
;
}
if
(
HasPrimaryAction
(
)
)
{
aName
.
AssignLiteral
(
"
click
"
)
;
}
}
void
DocAccessible
:
:
MaybeHandleChangeToHiddenNameOrDescription
(
nsIContent
*
aChild
)
{
if
(
!
HasLoadState
(
eTreeConstructed
)
)
{
return
;
}
for
(
nsIContent
*
content
=
aChild
;
content
;
content
=
content
-
>
GetParent
(
)
)
{
if
(
HasAccessible
(
content
)
)
{
break
;
}
nsAtom
*
id
=
content
-
>
GetID
(
)
;
if
(
!
id
)
{
continue
;
}
auto
*
providers
=
GetRelProviders
(
content
-
>
AsElement
(
)
nsDependentAtomString
(
id
)
)
;
if
(
!
providers
)
{
continue
;
}
for
(
auto
&
provider
:
*
providers
)
{
if
(
provider
-
>
mRelAttr
!
=
nsGkAtoms
:
:
aria_labelledby
&
&
provider
-
>
mRelAttr
!
=
nsGkAtoms
:
:
aria_describedby
)
{
continue
;
}
LocalAccessible
*
dependentAcc
=
GetAccessible
(
provider
-
>
mContent
)
;
if
(
!
dependentAcc
)
{
continue
;
}
FireDelayedEvent
(
provider
-
>
mRelAttr
=
=
nsGkAtoms
:
:
aria_labelledby
?
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
:
nsIAccessibleEvent
:
:
EVENT_DESCRIPTION_CHANGE
dependentAcc
)
;
}
}
}
void
DocAccessible
:
:
AttrElementWillChange
(
dom
:
:
Element
*
aElement
nsAtom
*
aAttr
)
{
MOZ_ASSERT
(
!
sIsAttrElementChanging
)
;
AttributeWillChange
(
aElement
kNameSpaceID_None
aAttr
dom
:
:
MutationEvent_Binding
:
:
MODIFICATION
)
;
sIsAttrElementChanging
=
true
;
}
void
DocAccessible
:
:
AttrElementChanged
(
dom
:
:
Element
*
aElement
nsAtom
*
aAttr
)
{
MOZ_ASSERT
(
sIsAttrElementChanging
)
;
sIsAttrElementChanging
=
false
;
AttributeChanged
(
aElement
kNameSpaceID_None
aAttr
dom
:
:
MutationEvent_Binding
:
:
MODIFICATION
nullptr
)
;
}
