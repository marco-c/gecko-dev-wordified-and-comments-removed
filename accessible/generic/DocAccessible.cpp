#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
AccIterator
.
h
"
#
include
"
AccAttributes
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
DocAccessibleChild
.
h
"
#
include
"
HTMLImageMapAccessible
.
h
"
#
include
"
nsAccCache
.
h
"
#
include
"
nsAccessiblePivot
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsDeckFrame
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsTextEquivUtils
.
h
"
#
include
"
Pivot
.
h
"
#
include
"
Role
.
h
"
#
include
"
RootAccessible
.
h
"
#
include
"
TreeWalker
.
h
"
#
include
"
xpcAccessibleDocument
.
h
"
#
include
"
nsCommandManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIEditingSession
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_accessibility
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
DocumentType
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
static
nsStaticAtom
*
const
kRelationAttrs
[
]
=
{
nsGkAtoms
:
:
aria_labelledby
nsGkAtoms
:
:
aria_describedby
nsGkAtoms
:
:
aria_details
nsGkAtoms
:
:
aria_owns
nsGkAtoms
:
:
aria_controls
nsGkAtoms
:
:
aria_flowto
nsGkAtoms
:
:
aria_errormessage
nsGkAtoms
:
:
_for
nsGkAtoms
:
:
control
}
;
static
const
uint32_t
kRelationAttrsLen
=
ArrayLength
(
kRelationAttrs
)
;
DocAccessible
:
:
DocAccessible
(
dom
:
:
Document
*
aDocument
PresShell
*
aPresShell
)
:
HyperTextAccessibleWrap
(
nullptr
nullptr
)
mAccessibleCache
(
kDefaultCacheLength
)
mNodeToAccessibleMap
(
kDefaultCacheLength
)
mDocumentNode
(
aDocument
)
mLoadState
(
eTreeConstructionPending
)
mDocFlags
(
0
)
mLoadEventType
(
0
)
mPrevStateBits
(
0
)
mVirtualCursor
(
nullptr
)
mPresShell
(
aPresShell
)
mIPCDoc
(
nullptr
)
{
mGenericTypes
|
=
eDocument
;
mStateFlags
|
=
eNotNodeMapEntry
;
mDoc
=
this
;
MOZ_ASSERT
(
mPresShell
"
should
have
been
given
a
pres
shell
"
)
;
mPresShell
-
>
SetDocAccessible
(
this
)
;
}
DocAccessible
:
:
~
DocAccessible
(
)
{
NS_ASSERTION
(
!
mPresShell
"
LastRelease
was
never
called
!
?
!
"
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
DocAccessible
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
DocAccessible
LocalAccessible
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mNotificationController
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mVirtualCursor
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChildDocuments
)
for
(
const
auto
&
hashEntry
:
tmp
-
>
mDependentIDsHashes
.
Values
(
)
)
{
for
(
const
auto
&
providers
:
hashEntry
-
>
Values
(
)
)
{
for
(
int32_t
provIdx
=
providers
-
>
Length
(
)
-
1
;
provIdx
>
=
0
;
provIdx
-
-
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
content
of
dependent
ids
hash
entry
of
document
accessible
"
)
;
const
auto
&
provider
=
(
*
providers
)
[
provIdx
]
;
cb
.
NoteXPCOMChild
(
provider
-
>
mContent
)
;
}
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAccessibleCache
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAnchorJumpElm
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mInvalidationList
)
for
(
const
auto
&
ar
:
tmp
-
>
mARIAOwnsHash
.
Values
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
ar
-
>
Length
(
)
;
i
+
+
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mARIAOwnsHash
entry
item
"
)
;
cb
.
NoteXPCOMChild
(
ar
-
>
ElementAt
(
i
)
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
DocAccessible
LocalAccessible
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mNotificationController
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mVirtualCursor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChildDocuments
)
tmp
-
>
mDependentIDsHashes
.
Clear
(
)
;
tmp
-
>
mNodeToAccessibleMap
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAccessibleCache
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAnchorJumpElm
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mInvalidationList
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_WEAK_REFERENCE
tmp
-
>
mARIAOwnsHash
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DocAccessible
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIAccessiblePivotObserver
)
NS_INTERFACE_MAP_END_INHERITING
(
HyperTextAccessible
)
NS_IMPL_ADDREF_INHERITED
(
DocAccessible
HyperTextAccessible
)
NS_IMPL_RELEASE_INHERITED
(
DocAccessible
HyperTextAccessible
)
ENameValueFlag
DocAccessible
:
:
Name
(
nsString
&
aName
)
const
{
aName
.
Truncate
(
)
;
if
(
mParent
)
{
mParent
-
>
Name
(
aName
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
LocalAccessible
:
:
Name
(
aName
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
Title
(
aName
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
URL
(
aName
)
;
}
return
eNameOK
;
}
role
DocAccessible
:
:
NativeRole
(
)
const
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
nsCoreUtils
:
:
GetDocShellFor
(
mDocumentNode
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
sameTypeRoot
;
docShell
-
>
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
sameTypeRoot
)
)
;
int32_t
itemType
=
docShell
-
>
ItemType
(
)
;
if
(
sameTypeRoot
=
=
docShell
)
{
if
(
itemType
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
return
roles
:
:
CHROME_WINDOW
;
}
if
(
itemType
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
return
roles
:
:
DOCUMENT
;
}
}
else
if
(
itemType
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
return
roles
:
:
DOCUMENT
;
}
}
return
roles
:
:
PANE
;
}
void
DocAccessible
:
:
Description
(
nsString
&
aDescription
)
const
{
if
(
mParent
)
mParent
-
>
Description
(
aDescription
)
;
if
(
HasOwnContent
(
)
&
&
aDescription
.
IsEmpty
(
)
)
{
nsTextEquivUtils
:
:
GetTextEquivFromIDRefs
(
this
nsGkAtoms
:
:
aria_describedby
aDescription
)
;
}
}
uint64_t
DocAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
states
:
:
FOCUSABLE
;
if
(
FocusMgr
(
)
-
>
IsFocused
(
this
)
)
state
|
=
states
:
:
FOCUSED
;
if
(
!
HasLoadState
(
eReady
)
)
state
|
=
states
:
:
STALE
;
if
(
!
HasLoadState
(
eCompletelyLoaded
)
)
state
|
=
states
:
:
BUSY
;
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
!
frame
|
|
!
frame
-
>
IsVisibleConsideringAncestors
(
nsIFrame
:
:
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
)
{
state
|
=
states
:
:
INVISIBLE
|
states
:
:
OFFSCREEN
;
}
RefPtr
<
EditorBase
>
editorBase
=
GetEditor
(
)
;
state
|
=
editorBase
?
states
:
:
EDITABLE
:
states
:
:
READONLY
;
return
state
;
}
uint64_t
DocAccessible
:
:
NativeInteractiveState
(
)
const
{
return
states
:
:
FOCUSABLE
;
}
bool
DocAccessible
:
:
NativelyUnavailable
(
)
const
{
return
false
;
}
void
DocAccessible
:
:
ApplyARIAState
(
uint64_t
*
aState
)
const
{
if
(
mContent
)
LocalAccessible
:
:
ApplyARIAState
(
aState
)
;
if
(
mParent
)
mParent
-
>
ApplyARIAState
(
aState
)
;
}
already_AddRefed
<
AccAttributes
>
DocAccessible
:
:
Attributes
(
)
{
RefPtr
<
AccAttributes
>
attributes
=
HyperTextAccessibleWrap
:
:
Attributes
(
)
;
if
(
!
mParent
|
|
IsRoot
(
)
)
return
attributes
.
forget
(
)
;
aria
:
:
AttrIterator
attribIter
(
mParent
-
>
GetContent
(
)
)
;
while
(
attribIter
.
Next
(
)
)
{
nsString
value
;
attribIter
.
AttrValue
(
value
)
;
attributes
-
>
SetAttribute
(
attribIter
.
AttrName
(
)
std
:
:
move
(
value
)
)
;
}
return
attributes
.
forget
(
)
;
}
LocalAccessible
*
DocAccessible
:
:
FocusedChild
(
)
{
return
FocusMgr
(
)
-
>
FocusedAccessible
(
)
;
}
void
DocAccessible
:
:
TakeFocus
(
)
const
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
RefPtr
<
dom
:
:
Element
>
newFocus
;
dom
:
:
AutoHandlingUserInputStatePusher
inputStatePusher
(
true
)
;
fm
-
>
MoveFocus
(
mDocumentNode
-
>
GetWindow
(
)
nullptr
nsFocusManager
:
:
MOVEFOCUS_ROOT
0
getter_AddRefs
(
newFocus
)
)
;
}
already_AddRefed
<
EditorBase
>
DocAccessible
:
:
GetEditor
(
)
const
{
if
(
!
mDocumentNode
-
>
HasFlag
(
NODE_IS_EDITABLE
)
&
&
(
!
mContent
|
|
!
mContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
mDocumentNode
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIEditingSession
>
editingSession
;
docShell
-
>
GetEditingSession
(
getter_AddRefs
(
editingSession
)
)
;
if
(
!
editingSession
)
return
nullptr
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
editingSession
-
>
GetHTMLEditorForWindow
(
mDocumentNode
-
>
GetWindow
(
)
)
;
if
(
!
htmlEditor
)
{
return
nullptr
;
}
bool
isEditable
=
false
;
htmlEditor
-
>
GetIsDocumentEditable
(
&
isEditable
)
;
if
(
isEditable
)
{
return
htmlEditor
.
forget
(
)
;
}
return
nullptr
;
}
void
DocAccessible
:
:
URL
(
nsAString
&
aURL
)
const
{
nsCOMPtr
<
nsISupports
>
container
=
mDocumentNode
-
>
GetContainer
(
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_GetInterface
(
container
)
)
;
nsAutoCString
theURL
;
if
(
webNav
)
{
nsCOMPtr
<
nsIURI
>
pURI
;
webNav
-
>
GetCurrentURI
(
getter_AddRefs
(
pURI
)
)
;
if
(
pURI
)
pURI
-
>
GetSpec
(
theURL
)
;
}
CopyUTF8toUTF16
(
theURL
aURL
)
;
}
void
DocAccessible
:
:
Title
(
nsString
&
aTitle
)
const
{
mDocumentNode
-
>
GetTitle
(
aTitle
)
;
}
void
DocAccessible
:
:
MimeType
(
nsAString
&
aType
)
const
{
mDocumentNode
-
>
GetContentType
(
aType
)
;
}
void
DocAccessible
:
:
DocType
(
nsAString
&
aType
)
const
{
dom
:
:
DocumentType
*
docType
=
mDocumentNode
-
>
GetDoctype
(
)
;
if
(
docType
)
docType
-
>
GetPublicId
(
aType
)
;
}
void
DocAccessible
:
:
Init
(
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocCreate
)
)
{
logging
:
:
DocCreate
(
"
document
initialize
"
mDocumentNode
this
)
;
}
#
endif
mNotificationController
=
new
NotificationController
(
this
mPresShell
)
;
if
(
mDocumentNode
-
>
GetReadyStateEnum
(
)
=
=
dom
:
:
Document
:
:
READYSTATE_COMPLETE
)
{
mLoadState
|
=
eDOMLoaded
;
mLoadEventType
=
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_LOAD_COMPLETE
;
}
AddEventListeners
(
)
;
}
void
DocAccessible
:
:
Shutdown
(
)
{
if
(
!
mPresShell
)
{
return
;
}
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocDestroy
)
)
{
logging
:
:
DocDestroy
(
"
document
shutdown
"
mDocumentNode
this
)
;
}
#
endif
mStateFlags
|
=
eIsDefunct
;
if
(
mNotificationController
)
{
mNotificationController
-
>
Shutdown
(
)
;
mNotificationController
=
nullptr
;
}
RemoveEventListeners
(
)
;
const
bool
isChild
=
!
!
mParent
;
if
(
mParent
)
{
DocAccessible
*
parentDocument
=
mParent
-
>
Document
(
)
;
if
(
parentDocument
)
parentDocument
-
>
RemoveChildDocument
(
this
)
;
mParent
-
>
RemoveChild
(
this
)
;
MOZ_ASSERT
(
!
mParent
"
Parent
has
to
be
null
!
"
)
;
}
mPresShell
-
>
SetDocAccessible
(
nullptr
)
;
mPresShell
=
nullptr
;
int32_t
childDocCount
=
mChildDocuments
.
Length
(
)
;
for
(
int32_t
idx
=
childDocCount
-
1
;
idx
>
=
0
;
idx
-
-
)
{
mChildDocuments
[
idx
]
-
>
Shutdown
(
)
;
}
mChildDocuments
.
Clear
(
)
;
if
(
mIPCDoc
)
{
MOZ_ASSERT
(
IPCAccessibilityActive
(
)
)
;
mIPCDoc
-
>
Shutdown
(
)
;
MOZ_ASSERT
(
!
mIPCDoc
)
;
}
if
(
mVirtualCursor
)
{
mVirtualCursor
-
>
RemoveObserver
(
this
)
;
mVirtualCursor
=
nullptr
;
}
mDependentIDsHashes
.
Clear
(
)
;
mNodeToAccessibleMap
.
Clear
(
)
;
mAnchorJumpElm
=
nullptr
;
mInvalidationList
.
Clear
(
)
;
for
(
auto
iter
=
mAccessibleCache
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
LocalAccessible
*
accessible
=
iter
.
Data
(
)
;
MOZ_ASSERT
(
accessible
)
;
if
(
accessible
&
&
!
accessible
-
>
IsDefunct
(
)
)
{
accessible
-
>
mParent
=
nullptr
;
accessible
-
>
Shutdown
(
)
;
}
iter
.
Remove
(
)
;
}
HyperTextAccessibleWrap
:
:
Shutdown
(
)
;
MOZ_ASSERT
(
GetAccService
(
)
)
;
GetAccService
(
)
-
>
NotifyOfDocumentShutdown
(
this
mDocumentNode
!
isChild
)
;
mDocumentNode
=
nullptr
;
}
nsIFrame
*
DocAccessible
:
:
GetFrame
(
)
const
{
nsIFrame
*
root
=
nullptr
;
if
(
mPresShell
)
{
root
=
mPresShell
-
>
GetRootFrame
(
)
;
}
return
root
;
}
nsINode
*
DocAccessible
:
:
GetNode
(
)
const
{
return
mDocumentNode
;
}
nsRect
DocAccessible
:
:
RelativeBounds
(
nsIFrame
*
*
aRelativeFrame
)
const
{
*
aRelativeFrame
=
GetFrame
(
)
;
dom
:
:
Document
*
document
=
mDocumentNode
;
dom
:
:
Document
*
parentDoc
=
nullptr
;
nsRect
bounds
;
while
(
document
)
{
PresShell
*
presShell
=
document
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nsRect
(
)
;
}
nsRect
scrollPort
;
nsIScrollableFrame
*
sf
=
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
sf
)
{
scrollPort
=
sf
-
>
GetScrollPortRect
(
)
;
}
else
{
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
return
nsRect
(
)
;
scrollPort
=
rootFrame
-
>
GetRect
(
)
;
}
if
(
parentDoc
)
{
bounds
.
IntersectRect
(
scrollPort
bounds
)
;
}
else
{
bounds
=
scrollPort
;
}
document
=
parentDoc
=
document
-
>
GetInProcessParentDocument
(
)
;
}
return
bounds
;
}
nsresult
DocAccessible
:
:
AddEventListeners
(
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentNode
-
>
GetDocShell
(
)
)
;
if
(
docShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
RefPtr
<
nsCommandManager
>
commandManager
=
docShell
-
>
GetCommandManager
(
)
;
if
(
commandManager
)
{
commandManager
-
>
AddCommandObserver
(
this
"
obs_documentCreated
"
)
;
}
}
SelectionMgr
(
)
-
>
AddDocSelectionListener
(
mPresShell
)
;
mDocumentNode
-
>
AddObserver
(
this
)
;
return
NS_OK
;
}
nsresult
DocAccessible
:
:
RemoveEventListeners
(
)
{
NS_ASSERTION
(
mDocumentNode
"
No
document
during
removal
of
listeners
.
"
)
;
if
(
mDocumentNode
)
{
mDocumentNode
-
>
RemoveObserver
(
this
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentNode
-
>
GetDocShell
(
)
)
;
NS_ASSERTION
(
docShell
"
doc
should
support
nsIDocShellTreeItem
.
"
)
;
if
(
docShell
)
{
if
(
docShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
RefPtr
<
nsCommandManager
>
commandManager
=
docShell
-
>
GetCommandManager
(
)
;
if
(
commandManager
)
{
commandManager
-
>
RemoveCommandObserver
(
this
"
obs_documentCreated
"
)
;
}
}
}
}
if
(
mScrollWatchTimer
)
{
mScrollWatchTimer
-
>
Cancel
(
)
;
mScrollWatchTimer
=
nullptr
;
NS_RELEASE_THIS
(
)
;
}
SelectionMgr
(
)
-
>
RemoveDocSelectionListener
(
mPresShell
)
;
return
NS_OK
;
}
void
DocAccessible
:
:
ScrollTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
DocAccessible
*
docAcc
=
reinterpret_cast
<
DocAccessible
*
>
(
aClosure
)
;
if
(
docAcc
)
{
for
(
auto
iter
=
docAcc
-
>
mLastScrollingDispatch
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
docAcc
-
>
DispatchScrollingEvent
(
iter
.
Key
(
)
nsIAccessibleEvent
:
:
EVENT_SCROLLING_END
)
;
iter
.
Remove
(
)
;
}
if
(
docAcc
-
>
mScrollWatchTimer
)
{
docAcc
-
>
mScrollWatchTimer
=
nullptr
;
NS_RELEASE
(
docAcc
)
;
}
}
}
void
DocAccessible
:
:
HandleScroll
(
nsINode
*
aTarget
)
{
const
uint32_t
kScrollEventInterval
=
100
;
mLastScrollingDispatch
.
WithEntryHandle
(
aTarget
[
&
]
(
auto
&
&
lastDispatch
)
{
const
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
lastDispatch
|
|
(
now
-
lastDispatch
.
Data
(
)
)
.
ToMilliseconds
(
)
>
=
kScrollEventInterval
)
{
if
(
HasLoadState
(
eTreeConstructed
)
)
{
DispatchScrollingEvent
(
aTarget
nsIAccessibleEvent
:
:
EVENT_SCROLLING
)
;
}
lastDispatch
.
InsertOrUpdate
(
now
)
;
}
}
)
;
if
(
mScrollWatchTimer
)
{
mScrollWatchTimer
-
>
SetDelay
(
kScrollEventInterval
)
;
}
else
{
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mScrollWatchTimer
)
ScrollTimerCallback
this
kScrollEventInterval
nsITimer
:
:
TYPE_ONE_SHOT
"
a11y
:
:
DocAccessible
:
:
ScrollPositionDidChange
"
)
;
if
(
mScrollWatchTimer
)
{
NS_ADDREF_THIS
(
)
;
}
}
}
NS_IMETHODIMP
DocAccessible
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
obs_documentCreated
"
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
this
states
:
:
EDITABLE
true
)
;
FireDelayedEvent
(
event
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DocAccessible
:
:
OnPivotChanged
(
nsIAccessiblePivot
*
aPivot
nsIAccessible
*
aOldAccessible
int32_t
aOldStart
int32_t
aOldEnd
nsIAccessible
*
aNewAccessible
int32_t
aNewStart
int32_t
aNewEnd
PivotMoveReason
aReason
TextBoundaryType
aBoundaryType
bool
aIsFromUserInput
)
{
RefPtr
<
AccEvent
>
event
=
new
AccVCChangeEvent
(
this
(
aOldAccessible
?
aOldAccessible
-
>
ToInternalAccessible
(
)
:
nullptr
)
aOldStart
aOldEnd
(
aNewAccessible
?
aNewAccessible
-
>
ToInternalAccessible
(
)
:
nullptr
)
aNewStart
aNewEnd
aReason
aBoundaryType
aIsFromUserInput
?
eFromUserInput
:
eNoUserInput
)
;
nsEventShell
:
:
FireEvent
(
event
)
;
return
NS_OK
;
}
NS_IMPL_NSIDOCUMENTOBSERVER_CORE_STUB
(
DocAccessible
)
NS_IMPL_NSIDOCUMENTOBSERVER_LOAD_STUB
(
DocAccessible
)
void
DocAccessible
:
:
AttributeWillChange
(
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
LocalAccessible
*
accessible
=
GetAccessible
(
aElement
)
;
if
(
!
accessible
)
{
if
(
aElement
!
=
mContent
)
return
;
accessible
=
this
;
}
if
(
aModType
!
=
dom
:
:
MutationEvent_Binding
:
:
ADDITION
)
{
RemoveDependentIDsFor
(
accessible
aAttribute
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
id
)
{
RelocateARIAOwnedIfNeeded
(
aElement
)
;
}
if
(
accessible
-
>
AttributeChangesState
(
aAttribute
)
)
{
mPrevStateBits
=
accessible
-
>
State
(
)
;
}
else
{
mPrevStateBits
=
0
;
}
}
void
DocAccessible
:
:
NativeAnonymousChildListChange
(
nsIContent
*
aContent
bool
aIsRemove
)
{
if
(
aIsRemove
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
Anonymous
content
removed
;
doc
:
%
p
"
this
)
;
logging
:
:
Node
(
"
node
"
aContent
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
ContentRemoved
(
aContent
)
;
}
}
void
DocAccessible
:
:
AttributeChanged
(
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
NS_ASSERTION
(
!
IsDefunct
(
)
"
Attribute
changed
called
on
defunct
document
accessible
!
"
)
;
if
(
UpdateAccessibleOnAttrChange
(
aElement
aAttribute
)
)
return
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_hidden
)
{
if
(
aria
:
:
HasDefinedARIAHidden
(
aElement
)
)
{
ContentRemoved
(
aElement
)
;
}
else
{
ContentInserted
(
aElement
aElement
-
>
GetNextSibling
(
)
)
;
}
return
;
}
LocalAccessible
*
accessible
=
GetAccessible
(
aElement
)
;
if
(
!
accessible
)
{
if
(
mContent
!
=
aElement
)
return
;
accessible
=
this
;
}
MOZ_ASSERT
(
accessible
-
>
IsBoundToParent
(
)
|
|
accessible
-
>
IsDoc
(
)
"
DOM
attribute
change
on
an
accessible
detached
from
the
tree
"
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
id
)
{
dom
:
:
Element
*
elm
=
accessible
-
>
Elm
(
)
;
RelocateARIAOwnedIfNeeded
(
elm
)
;
ARIAActiveDescendantIDMaybeMoved
(
elm
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_activedescendant
)
{
mNotificationController
-
>
ScheduleNotification
<
DocAccessible
LocalAccessible
>
(
this
&
DocAccessible
:
:
ARIAActiveDescendantChanged
accessible
)
;
return
;
}
accessible
-
>
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
mPrevStateBits
)
;
if
(
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
MODIFICATION
|
|
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
ADDITION
)
{
AddDependentIDsFor
(
accessible
aAttribute
)
;
}
}
void
DocAccessible
:
:
ARIAActiveDescendantChanged
(
LocalAccessible
*
aAccessible
)
{
nsIContent
*
elm
=
aAccessible
-
>
GetContent
(
)
;
if
(
elm
&
&
elm
-
>
IsElement
(
)
&
&
aAccessible
-
>
IsActiveWidget
(
)
)
{
nsAutoString
id
;
if
(
elm
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_activedescendant
id
)
)
{
dom
:
:
Element
*
activeDescendantElm
=
IDRefsIterator
:
:
GetElem
(
elm
id
)
;
if
(
activeDescendantElm
)
{
LocalAccessible
*
activeDescendant
=
GetAccessible
(
activeDescendantElm
)
;
if
(
activeDescendant
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
activeDescendant
false
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
ARIA
activedescedant
changed
"
activeDescendant
)
;
}
#
endif
return
;
}
}
}
FocusMgr
(
)
-
>
ActiveItemChanged
(
aAccessible
false
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
ARIA
activedescedant
cleared
"
aAccessible
)
;
}
#
endif
}
}
void
DocAccessible
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
}
void
DocAccessible
:
:
ContentStateChanged
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContent
EventStates
aStateMask
)
{
LocalAccessible
*
accessible
=
GetAccessible
(
aContent
)
;
if
(
!
accessible
)
return
;
if
(
aStateMask
.
HasState
(
NS_EVENT_STATE_CHECKED
)
)
{
LocalAccessible
*
widget
=
accessible
-
>
ContainerWidget
(
)
;
if
(
widget
&
&
widget
-
>
IsSelect
(
)
)
{
AccSelChangeEvent
:
:
SelChangeType
selChangeType
=
aContent
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_CHECKED
)
?
AccSelChangeEvent
:
:
eSelectionAdd
:
AccSelChangeEvent
:
:
eSelectionRemove
;
RefPtr
<
AccEvent
>
event
=
new
AccSelChangeEvent
(
widget
accessible
selChangeType
)
;
FireDelayedEvent
(
event
)
;
return
;
}
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
CHECKED
aContent
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_CHECKED
)
)
;
FireDelayedEvent
(
event
)
;
}
if
(
aStateMask
.
HasState
(
NS_EVENT_STATE_INVALID
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
INVALID
true
)
;
FireDelayedEvent
(
event
)
;
}
if
(
aStateMask
.
HasState
(
NS_EVENT_STATE_REQUIRED
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
REQUIRED
)
;
FireDelayedEvent
(
event
)
;
}
if
(
aStateMask
.
HasState
(
NS_EVENT_STATE_VISITED
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
TRAVERSED
true
)
;
FireDelayedEvent
(
event
)
;
}
if
(
aStateMask
.
HasState
(
NS_EVENT_STATE_DEFAULT
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
DEFAULT
)
;
FireDelayedEvent
(
event
)
;
}
}
void
DocAccessible
:
:
CharacterDataWillChange
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
}
void
DocAccessible
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
}
void
DocAccessible
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
}
void
DocAccessible
:
:
ContentRemoved
(
nsIContent
*
aChildNode
nsIContent
*
aPreviousSiblingNode
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
DOM
content
removed
;
doc
:
%
p
"
this
)
;
logging
:
:
Node
(
"
container
node
"
aChildNode
-
>
GetParent
(
)
)
;
logging
:
:
Node
(
"
content
node
"
aChildNode
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
ContentRemoved
(
aChildNode
)
;
}
void
DocAccessible
:
:
MarkForBoundsProcessing
(
LocalAccessible
*
aAcc
)
{
mMaybeBoundsChanged
.
EnsureInserted
(
aAcc
)
;
}
void
DocAccessible
:
:
ParentChainChanged
(
nsIContent
*
aContent
)
{
}
#
ifdef
A11Y_LOG
nsresult
DocAccessible
:
:
HandleAccEvent
(
AccEvent
*
aEvent
)
{
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocLoad
)
)
{
logging
:
:
DocLoadEventHandled
(
aEvent
)
;
}
return
HyperTextAccessible
:
:
HandleAccEvent
(
aEvent
)
;
}
#
endif
nsPresContext
*
DocAccessible
:
:
PresContext
(
)
const
{
return
mPresShell
-
>
GetPresContext
(
)
;
}
void
*
DocAccessible
:
:
GetNativeWindow
(
)
const
{
if
(
!
mPresShell
)
{
return
nullptr
;
}
nsViewManager
*
vm
=
mPresShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
return
nullptr
;
nsCOMPtr
<
nsIWidget
>
widget
=
vm
-
>
GetRootWidget
(
)
;
if
(
widget
)
return
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
return
nullptr
;
}
LocalAccessible
*
DocAccessible
:
:
GetAccessibleByUniqueIDInSubtree
(
void
*
aUniqueID
)
{
LocalAccessible
*
child
=
GetAccessibleByUniqueID
(
aUniqueID
)
;
if
(
child
)
return
child
;
uint32_t
childDocCount
=
mChildDocuments
.
Length
(
)
;
for
(
uint32_t
childDocIdx
=
0
;
childDocIdx
<
childDocCount
;
childDocIdx
+
+
)
{
DocAccessible
*
childDocument
=
mChildDocuments
.
ElementAt
(
childDocIdx
)
;
child
=
childDocument
-
>
GetAccessibleByUniqueIDInSubtree
(
aUniqueID
)
;
if
(
child
)
return
child
;
}
return
nullptr
;
}
LocalAccessible
*
DocAccessible
:
:
GetAccessibleOrContainer
(
nsINode
*
aNode
bool
aNoContainerIfPruned
)
const
{
if
(
!
aNode
|
|
!
aNode
-
>
GetComposedDoc
(
)
)
{
return
nullptr
;
}
nsINode
*
start
=
aNode
;
if
(
auto
*
shadowRoot
=
dom
:
:
ShadowRoot
:
:
FromNode
(
aNode
)
)
{
start
=
shadowRoot
-
>
GetHost
(
)
;
if
(
!
start
)
{
return
nullptr
;
}
}
for
(
nsINode
*
currNode
:
dom
:
:
InclusiveFlatTreeAncestors
(
*
start
)
)
{
if
(
aNoContainerIfPruned
&
&
currNode
-
>
IsElement
(
)
&
&
aria
:
:
HasDefinedARIAHidden
(
currNode
-
>
AsElement
(
)
)
)
{
return
nullptr
;
}
if
(
aNoContainerIfPruned
&
&
currNode
-
>
IsXULElement
(
)
)
{
if
(
nsIFrame
*
frame
=
currNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
)
{
nsDeckFrame
*
deckFrame
=
do_QueryFrame
(
frame
-
>
GetParent
(
)
)
;
if
(
deckFrame
&
&
deckFrame
-
>
GetSelectedBox
(
)
!
=
frame
)
{
nsIContent
*
parentFrameContent
=
deckFrame
-
>
GetContent
(
)
;
if
(
!
parentFrameContent
|
|
!
parentFrameContent
-
>
IsXULElement
(
nsGkAtoms
:
:
tabpanels
)
)
{
return
nullptr
;
}
}
}
}
if
(
aNoContainerIfPruned
&
&
currNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
map
)
)
{
if
(
nsIFrame
*
frame
=
currNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
)
{
if
(
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
frame
frame
-
>
GetParent
(
)
)
.
IsEmpty
(
)
)
{
return
nullptr
;
}
}
}
if
(
LocalAccessible
*
accessible
=
GetAccessible
(
currNode
)
)
{
return
accessible
;
}
}
return
nullptr
;
}
LocalAccessible
*
DocAccessible
:
:
GetContainerAccessible
(
nsINode
*
aNode
)
const
{
return
aNode
?
GetAccessibleOrContainer
(
aNode
-
>
GetFlattenedTreeParentNode
(
)
)
:
nullptr
;
}
LocalAccessible
*
DocAccessible
:
:
GetAccessibleOrDescendant
(
nsINode
*
aNode
)
const
{
LocalAccessible
*
acc
=
GetAccessible
(
aNode
)
;
if
(
acc
)
return
acc
;
if
(
aNode
=
=
mContent
|
|
aNode
=
=
mDocumentNode
-
>
GetRootElement
(
)
)
{
return
const_cast
<
DocAccessible
*
>
(
this
)
;
}
acc
=
GetContainerAccessible
(
aNode
)
;
if
(
acc
)
{
TreeWalker
walker
(
acc
aNode
-
>
AsContent
(
)
TreeWalker
:
:
eWalkCache
|
TreeWalker
:
:
eScoped
)
;
return
walker
.
Next
(
)
;
}
return
nullptr
;
}
void
DocAccessible
:
:
BindToDocument
(
LocalAccessible
*
aAccessible
const
nsRoleMapEntry
*
aRoleMapEntry
)
{
if
(
aAccessible
-
>
IsNodeMapEntry
(
)
)
{
mNodeToAccessibleMap
.
InsertOrUpdate
(
aAccessible
-
>
GetNode
(
)
aAccessible
)
;
}
mAccessibleCache
.
InsertOrUpdate
(
aAccessible
-
>
UniqueID
(
)
RefPtr
{
aAccessible
}
)
;
aAccessible
-
>
SetRoleMapEntry
(
aRoleMapEntry
)
;
if
(
aAccessible
-
>
HasOwnContent
(
)
)
{
AddDependentIDsFor
(
aAccessible
)
;
nsIContent
*
content
=
aAccessible
-
>
GetContent
(
)
;
if
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_owns
)
)
{
mNotificationController
-
>
ScheduleRelocation
(
aAccessible
)
;
}
}
}
void
DocAccessible
:
:
UnbindFromDocument
(
LocalAccessible
*
aAccessible
)
{
NS_ASSERTION
(
mAccessibleCache
.
GetWeak
(
aAccessible
-
>
UniqueID
(
)
)
"
Unbinding
the
unbound
accessible
!
"
)
;
if
(
FocusMgr
(
)
-
>
WasLastFocused
(
aAccessible
)
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
nullptr
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
tree
shutdown
"
aAccessible
)
;
}
#
endif
}
if
(
aAccessible
-
>
IsNodeMapEntry
(
)
&
&
mNodeToAccessibleMap
.
Get
(
aAccessible
-
>
GetNode
(
)
)
=
=
aAccessible
)
{
mNodeToAccessibleMap
.
Remove
(
aAccessible
-
>
GetNode
(
)
)
;
}
aAccessible
-
>
mStateFlags
|
=
eIsNotInDocument
;
xpcAccessibleDocument
*
xpcDoc
=
GetAccService
(
)
-
>
GetCachedXPCDocument
(
this
)
;
if
(
xpcDoc
)
xpcDoc
-
>
NotifyOfShutdown
(
aAccessible
)
;
void
*
uniqueID
=
aAccessible
-
>
UniqueID
(
)
;
NS_ASSERTION
(
!
aAccessible
-
>
IsDefunct
(
)
"
Shutdown
the
shutdown
accessible
!
"
)
;
aAccessible
-
>
Shutdown
(
)
;
mAccessibleCache
.
Remove
(
uniqueID
)
;
}
void
DocAccessible
:
:
ContentInserted
(
nsIContent
*
aStartChildNode
nsIContent
*
aEndChildNode
)
{
if
(
!
mNotificationController
|
|
!
HasLoadState
(
eTreeConstructed
)
)
{
return
;
}
nsINode
*
parent
=
aStartChildNode
-
>
GetFlattenedTreeParentNode
(
)
;
if
(
!
parent
)
{
return
;
}
LocalAccessible
*
container
=
AccessibleOrTrueContainer
(
parent
)
;
if
(
!
container
)
{
return
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
list
;
for
(
nsIContent
*
node
=
aStartChildNode
;
node
!
=
aEndChildNode
;
node
=
node
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
parent
=
=
node
-
>
GetFlattenedTreeParentNode
(
)
)
;
if
(
PruneOrInsertSubtree
(
node
)
)
{
list
.
AppendElement
(
node
)
;
}
}
mNotificationController
-
>
ScheduleContentInsertion
(
container
list
)
;
}
bool
DocAccessible
:
:
PruneOrInsertSubtree
(
nsIContent
*
aRoot
)
{
bool
insert
=
false
;
nsIContent
*
shadowHost
=
aRoot
-
>
GetShadowRoot
(
)
?
aRoot
:
aRoot
-
>
GetContainingShadowHost
(
)
;
if
(
shadowHost
)
{
dom
:
:
ExplicitChildIterator
iter
(
shadowHost
)
;
while
(
nsIContent
*
childNode
=
iter
.
GetNextChild
(
)
)
{
if
(
!
childNode
-
>
GetPrimaryFrame
(
)
&
&
!
nsCoreUtils
:
:
IsDisplayContents
(
childNode
)
)
{
ContentRemoved
(
childNode
)
;
}
}
if
(
aRoot
-
>
IsHTMLElement
(
nsGkAtoms
:
:
slot
)
)
{
for
(
nsIContent
*
childNode
=
aRoot
-
>
GetFirstChild
(
)
;
childNode
;
childNode
=
childNode
-
>
GetNextSibling
(
)
)
{
if
(
!
childNode
-
>
GetPrimaryFrame
(
)
&
&
!
nsCoreUtils
:
:
IsDisplayContents
(
childNode
)
)
{
ContentRemoved
(
childNode
)
;
}
}
}
}
LocalAccessible
*
acc
=
GetAccessible
(
aRoot
)
;
if
(
acc
)
{
MOZ_ASSERT
(
aRoot
=
=
acc
-
>
GetContent
(
)
"
LocalAccessible
has
differing
content
!
"
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
inserted
content
already
has
accessible
;
doc
:
%
p
"
this
)
;
logging
:
:
Node
(
"
content
node
"
aRoot
)
;
logging
:
:
AccessibleInfo
(
"
accessible
node
"
acc
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
!
frame
&
&
!
nsCoreUtils
:
:
IsDisplayContents
(
aRoot
)
)
{
ContentRemoved
(
aRoot
)
;
return
false
;
}
if
(
acc
-
>
IsXULLabel
(
)
)
{
ContentRemoved
(
acc
)
;
return
true
;
}
if
(
frame
&
&
(
acc
-
>
IsImage
(
)
!
=
(
frame
-
>
AccessibleType
(
)
=
=
eImageType
)
)
)
{
ContentRemoved
(
aRoot
)
;
return
true
;
}
if
(
frame
&
&
!
acc
-
>
IsOuterDoc
(
)
&
&
frame
-
>
AccessibleType
(
)
=
=
eOuterDocType
)
{
ContentRemoved
(
aRoot
)
;
return
true
;
}
if
(
aRoot
-
>
IsElement
(
)
&
&
FocusMgr
(
)
-
>
HasDOMFocus
(
aRoot
)
)
{
SelectionMgr
(
)
-
>
SetControlSelectionListener
(
aRoot
-
>
AsElement
(
)
)
;
}
if
(
acc
-
>
IsTable
(
)
|
|
acc
-
>
IsTableRow
(
)
|
|
acc
-
>
IsTableCell
(
)
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_TABLE_STYLING_CHANGED
acc
)
;
}
insert
=
true
;
if
(
frame
&
&
!
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
ContentRemoved
(
aRoot
)
;
insert
=
false
;
}
}
else
{
if
(
aRoot
-
>
GetPrimaryFrame
(
)
|
|
nsCoreUtils
:
:
IsDisplayContents
(
aRoot
)
)
{
if
(
!
GetAccessibleOrDescendant
(
aRoot
)
)
{
return
true
;
}
insert
=
true
;
}
}
if
(
LocalAccessible
*
container
=
AccessibleOrTrueContainer
(
aRoot
)
)
{
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
list
;
dom
:
:
AllChildrenIterator
iter
=
dom
:
:
AllChildrenIterator
(
aRoot
nsIContent
:
:
eAllChildren
true
)
;
while
(
nsIContent
*
childNode
=
iter
.
GetNextChild
(
)
)
{
if
(
PruneOrInsertSubtree
(
childNode
)
)
{
list
.
AppendElement
(
childNode
)
;
}
}
if
(
!
list
.
IsEmpty
(
)
)
{
mNotificationController
-
>
ScheduleContentInsertion
(
container
list
)
;
}
}
return
insert
;
}
void
DocAccessible
:
:
RecreateAccessible
(
nsIContent
*
aContent
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
accessible
recreated
"
)
;
logging
:
:
Node
(
"
content
"
aContent
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
ContentRemoved
(
aContent
)
;
ContentInserted
(
aContent
aContent
-
>
GetNextSibling
(
)
)
;
}
void
DocAccessible
:
:
ProcessInvalidationList
(
)
{
for
(
uint32_t
idx
=
0
;
idx
<
mInvalidationList
.
Length
(
)
;
idx
+
+
)
{
nsIContent
*
content
=
mInvalidationList
[
idx
]
;
if
(
!
HasAccessible
(
content
)
&
&
content
-
>
HasID
(
)
)
{
LocalAccessible
*
container
=
GetContainerAccessible
(
content
)
;
if
(
container
)
{
AttrRelProviders
*
list
=
GetRelProviders
(
content
-
>
AsElement
(
)
nsDependentAtomString
(
content
-
>
GetID
(
)
)
)
;
bool
shouldProcess
=
!
!
list
;
if
(
shouldProcess
)
{
for
(
uint32_t
idx
=
0
;
idx
<
list
-
>
Length
(
)
;
idx
+
+
)
{
if
(
list
-
>
ElementAt
(
idx
)
-
>
mRelAttr
=
=
nsGkAtoms
:
:
aria_owns
)
{
shouldProcess
=
false
;
break
;
}
}
if
(
shouldProcess
)
{
ProcessContentInserted
(
container
content
)
;
}
}
}
}
}
mInvalidationList
.
Clear
(
)
;
}
void
DocAccessible
:
:
ProcessBoundsChanged
(
)
{
if
(
!
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
{
return
;
}
nsTArray
<
CacheData
>
data
;
for
(
auto
*
acc
:
mMaybeBoundsChanged
)
{
if
(
!
acc
-
>
IsDefunct
(
)
)
{
RefPtr
<
AccAttributes
>
fields
=
acc
-
>
BundleFieldsForCache
(
CacheDomain
:
:
Bounds
CacheUpdateType
:
:
Update
)
;
if
(
fields
-
>
Count
(
)
)
{
data
.
AppendElement
(
CacheData
(
acc
-
>
IsDoc
(
)
?
0
:
reinterpret_cast
<
uint64_t
>
(
acc
-
>
UniqueID
(
)
)
fields
)
)
;
}
}
}
mMaybeBoundsChanged
.
Clear
(
)
;
if
(
data
.
Length
(
)
)
{
IPCDoc
(
)
-
>
SendCache
(
CacheUpdateType
:
:
Update
data
true
)
;
}
}
LocalAccessible
*
DocAccessible
:
:
GetAccessibleEvenIfNotInMap
(
nsINode
*
aNode
)
const
{
if
(
!
aNode
-
>
IsContent
(
)
|
|
!
aNode
-
>
AsContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
{
return
GetAccessible
(
aNode
)
;
}
nsIFrame
*
frame
=
aNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
nsImageFrame
*
imageFrame
=
do_QueryFrame
(
frame
)
;
if
(
imageFrame
)
{
LocalAccessible
*
parent
=
GetAccessible
(
imageFrame
-
>
GetContent
(
)
)
;
if
(
parent
)
{
LocalAccessible
*
area
=
parent
-
>
AsImageMap
(
)
-
>
GetChildAccessibleFor
(
aNode
)
;
if
(
area
)
return
area
;
return
nullptr
;
}
}
return
GetAccessible
(
aNode
)
;
}
void
DocAccessible
:
:
NotifyOfLoading
(
bool
aIsReloading
)
{
mLoadState
&
=
~
eDOMLoaded
;
if
(
!
IsLoadEventTarget
(
)
)
return
;
if
(
aIsReloading
&
&
!
mLoadEventType
&
&
HasLoadState
(
eTreeConstructed
)
)
{
RefPtr
<
AccEvent
>
reloadEvent
=
new
AccEvent
(
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_RELOAD
this
)
;
nsEventShell
:
:
FireEvent
(
reloadEvent
)
;
}
RefPtr
<
AccEvent
>
stateEvent
=
new
AccStateChangeEvent
(
this
states
:
:
BUSY
true
)
;
FireDelayedEvent
(
stateEvent
)
;
}
void
DocAccessible
:
:
DoInitialUpdate
(
)
{
if
(
nsCoreUtils
:
:
IsTopLevelContentDocInProcess
(
mDocumentNode
)
)
{
mDocFlags
|
=
eTopLevelContentDocInProcess
;
if
(
IPCAccessibilityActive
(
)
)
{
nsIDocShell
*
docShell
=
mDocumentNode
-
>
GetDocShell
(
)
;
if
(
RefPtr
<
dom
:
:
BrowserChild
>
browserChild
=
dom
:
:
BrowserChild
:
:
GetFrom
(
docShell
)
)
{
MOZ_ASSERT
(
IsRoot
(
)
)
;
DocAccessibleChild
*
ipcDoc
=
IPCDoc
(
)
;
if
(
ipcDoc
)
{
browserChild
-
>
SetTopLevelDocAccessibleChild
(
ipcDoc
)
;
}
else
{
ipcDoc
=
new
DocAccessibleChild
(
this
browserChild
)
;
SetIPCDoc
(
ipcDoc
)
;
browserChild
-
>
SetTopLevelDocAccessibleChild
(
ipcDoc
)
;
#
if
defined
(
XP_WIN
)
IAccessibleHolder
holder
;
int32_t
childID
;
if
(
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
{
childID
=
0
;
}
else
{
holder
=
CreateHolderFromAccessible
(
WrapNotNull
(
this
)
)
;
MOZ_ASSERT
(
!
holder
.
IsNull
(
)
)
;
childID
=
MsaaAccessible
:
:
GetChildIDFor
(
this
)
;
}
#
else
int32_t
holder
=
0
childID
=
0
;
#
endif
browserChild
-
>
SendPDocAccessibleConstructor
(
ipcDoc
nullptr
0
childID
holder
)
;
#
if
!
defined
(
XP_WIN
)
ipcDoc
-
>
SendPDocAccessiblePlatformExtConstructor
(
)
;
#
endif
}
#
if
!
defined
(
XP_WIN
)
ipcDoc
-
>
SetConstructedInParentProcess
(
)
;
#
endif
}
}
}
mLoadState
|
=
eTreeConstructed
;
UpdateRootElIfNeeded
(
)
;
CacheChildrenInSubtree
(
this
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eVerbose
)
)
{
logging
:
:
Tree
(
"
TREE
"
"
Initial
subtree
"
this
)
;
}
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTreeSize
)
)
{
logging
:
:
TreeSize
(
"
TREE
SIZE
"
"
Initial
subtree
"
this
)
;
}
#
endif
if
(
!
IsRoot
(
)
)
{
RefPtr
<
AccReorderEvent
>
reorderEvent
=
new
AccReorderEvent
(
LocalParent
(
)
)
;
ParentDocument
(
)
-
>
FireDelayedEvent
(
reorderEvent
)
;
}
if
(
IPCAccessibilityActive
(
)
)
{
DocAccessibleChild
*
ipcDoc
=
IPCDoc
(
)
;
MOZ_ASSERT
(
ipcDoc
)
;
if
(
ipcDoc
)
{
if
(
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
{
SendCache
(
CacheDomain
:
:
All
CacheUpdateType
:
:
Initial
)
;
}
for
(
auto
idx
=
0U
;
idx
<
mChildren
.
Length
(
)
;
idx
+
+
)
{
ipcDoc
-
>
InsertIntoIpcTree
(
this
mChildren
.
ElementAt
(
idx
)
idx
true
)
;
}
}
}
}
void
DocAccessible
:
:
ProcessLoad
(
)
{
mLoadState
|
=
eCompletelyLoaded
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocLoad
)
)
{
logging
:
:
DocCompleteLoad
(
this
IsLoadEventTarget
(
)
)
;
}
#
endif
if
(
!
IsLoadEventTarget
(
)
)
return
;
if
(
mLoadEventType
)
{
RefPtr
<
AccEvent
>
loadEvent
=
new
AccEvent
(
mLoadEventType
this
)
;
FireDelayedEvent
(
loadEvent
)
;
mLoadEventType
=
0
;
}
RefPtr
<
AccEvent
>
stateEvent
=
new
AccStateChangeEvent
(
this
states
:
:
BUSY
false
)
;
FireDelayedEvent
(
stateEvent
)
;
}
void
DocAccessible
:
:
AddDependentIDsFor
(
LocalAccessible
*
aRelProvider
nsAtom
*
aRelAttr
)
{
dom
:
:
Element
*
relProviderEl
=
aRelProvider
-
>
Elm
(
)
;
if
(
!
relProviderEl
)
return
;
for
(
uint32_t
idx
=
0
;
idx
<
kRelationAttrsLen
;
idx
+
+
)
{
nsStaticAtom
*
relAttr
=
kRelationAttrs
[
idx
]
;
if
(
aRelAttr
&
&
aRelAttr
!
=
relAttr
)
continue
;
if
(
relAttr
=
=
nsGkAtoms
:
:
_for
)
{
if
(
!
relProviderEl
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
label
nsGkAtoms
:
:
output
)
)
{
continue
;
}
}
else
if
(
relAttr
=
=
nsGkAtoms
:
:
control
)
{
if
(
!
relProviderEl
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
label
nsGkAtoms
:
:
description
)
)
{
continue
;
}
}
IDRefsIterator
iter
(
this
relProviderEl
relAttr
)
;
while
(
true
)
{
const
nsDependentSubstring
id
=
iter
.
NextID
(
)
;
if
(
id
.
IsEmpty
(
)
)
break
;
AttrRelProviders
*
providers
=
GetOrCreateRelProviders
(
relProviderEl
id
)
;
if
(
providers
)
{
AttrRelProvider
*
provider
=
new
AttrRelProvider
(
relAttr
relProviderEl
)
;
if
(
provider
)
{
providers
-
>
AppendElement
(
provider
)
;
nsIContent
*
dependentContent
=
iter
.
GetElem
(
id
)
;
if
(
dependentContent
)
{
if
(
!
HasAccessible
(
dependentContent
)
)
{
mInvalidationList
.
AppendElement
(
dependentContent
)
;
}
}
}
}
}
if
(
aRelAttr
)
break
;
}
mNotificationController
-
>
ScheduleProcessing
(
)
;
}
void
DocAccessible
:
:
RemoveDependentIDsFor
(
LocalAccessible
*
aRelProvider
nsAtom
*
aRelAttr
)
{
dom
:
:
Element
*
relProviderElm
=
aRelProvider
-
>
Elm
(
)
;
if
(
!
relProviderElm
)
return
;
for
(
uint32_t
idx
=
0
;
idx
<
kRelationAttrsLen
;
idx
+
+
)
{
nsStaticAtom
*
relAttr
=
kRelationAttrs
[
idx
]
;
if
(
aRelAttr
&
&
aRelAttr
!
=
kRelationAttrs
[
idx
]
)
continue
;
IDRefsIterator
iter
(
this
relProviderElm
relAttr
)
;
while
(
true
)
{
const
nsDependentSubstring
id
=
iter
.
NextID
(
)
;
if
(
id
.
IsEmpty
(
)
)
break
;
AttrRelProviders
*
providers
=
GetRelProviders
(
relProviderElm
id
)
;
if
(
providers
)
{
providers
-
>
RemoveElementsBy
(
[
relAttr
relProviderElm
]
(
const
auto
&
provider
)
{
return
provider
-
>
mRelAttr
=
=
relAttr
&
&
provider
-
>
mContent
=
=
relProviderElm
;
}
)
;
RemoveRelProvidersIfEmpty
(
relProviderElm
id
)
;
}
}
if
(
aRelAttr
)
break
;
}
}
bool
DocAccessible
:
:
UpdateAccessibleOnAttrChange
(
dom
:
:
Element
*
aElement
nsAtom
*
aAttribute
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
role
)
{
if
(
mContent
=
=
aElement
)
{
SetRoleMapEntryForDoc
(
aElement
)
;
if
(
mIPCDoc
)
{
mIPCDoc
-
>
SendRoleChangedEvent
(
Role
(
)
)
;
}
return
true
;
}
RecreateAccessible
(
aElement
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_multiselectable
&
&
aElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
role
)
)
{
RecreateAccessible
(
aElement
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
type
)
{
RecreateAccessible
(
aElement
)
;
return
true
;
}
return
false
;
}
void
DocAccessible
:
:
UpdateRootElIfNeeded
(
)
{
dom
:
:
Element
*
rootEl
=
mDocumentNode
-
>
GetBodyElement
(
)
;
if
(
!
rootEl
)
{
rootEl
=
mDocumentNode
-
>
GetRootElement
(
)
;
}
if
(
rootEl
!
=
mContent
)
{
mContent
=
rootEl
;
SetRoleMapEntryForDoc
(
rootEl
)
;
if
(
mIPCDoc
)
{
mIPCDoc
-
>
SendRoleChangedEvent
(
Role
(
)
)
;
}
}
}
class
InsertIterator
final
{
public
:
InsertIterator
(
LocalAccessible
*
aContext
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
aNodes
)
:
mChild
(
nullptr
)
mChildBefore
(
nullptr
)
mWalker
(
aContext
)
mNodes
(
aNodes
)
mNodesIdx
(
0
)
{
MOZ_ASSERT
(
aContext
"
No
context
"
)
;
MOZ_ASSERT
(
aNodes
"
No
nodes
to
search
for
accessible
elements
"
)
;
MOZ_COUNT_CTOR
(
InsertIterator
)
;
}
MOZ_COUNTED_DTOR
(
InsertIterator
)
LocalAccessible
*
Context
(
)
const
{
return
mWalker
.
Context
(
)
;
}
LocalAccessible
*
Child
(
)
const
{
return
mChild
;
}
LocalAccessible
*
ChildBefore
(
)
const
{
return
mChildBefore
;
}
DocAccessible
*
Document
(
)
const
{
return
mWalker
.
Document
(
)
;
}
bool
Next
(
)
;
void
Rejected
(
)
{
mChild
=
nullptr
;
mChildBefore
=
nullptr
;
}
private
:
LocalAccessible
*
mChild
;
LocalAccessible
*
mChildBefore
;
TreeWalker
mWalker
;
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
mNodes
;
nsTHashSet
<
nsPtrHashKey
<
const
nsIContent
>
>
mProcessedNodes
;
uint32_t
mNodesIdx
;
}
;
bool
InsertIterator
:
:
Next
(
)
{
if
(
mNodesIdx
>
0
)
{
LocalAccessible
*
nextChild
=
mWalker
.
Next
(
)
;
if
(
nextChild
)
{
mChildBefore
=
mChild
;
mChild
=
nextChild
;
return
true
;
}
}
while
(
mNodesIdx
<
mNodes
-
>
Length
(
)
)
{
nsIContent
*
node
=
mNodes
-
>
ElementAt
(
mNodesIdx
+
+
)
;
if
(
!
mProcessedNodes
.
EnsureInserted
(
node
)
)
{
continue
;
}
LocalAccessible
*
container
=
Document
(
)
-
>
AccessibleOrTrueContainer
(
node
-
>
GetFlattenedTreeParentNode
(
)
true
)
;
if
(
container
!
=
Context
(
)
)
{
continue
;
}
if
(
container
-
>
IsHTMLCombobox
(
)
)
{
container
=
container
-
>
LocalFirstChild
(
)
;
}
if
(
!
container
-
>
IsAcceptableChild
(
node
)
)
{
continue
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
traversing
an
inserted
node
"
logging
:
:
eVerbose
"
container
"
container
"
node
"
node
)
;
#
endif
nsIContent
*
prevNode
=
mChild
?
mChild
-
>
GetContent
(
)
:
nullptr
;
if
(
prevNode
&
&
prevNode
-
>
GetNextSibling
(
)
=
=
node
)
{
LocalAccessible
*
nextChild
=
mWalker
.
Scope
(
node
)
;
if
(
nextChild
)
{
mChildBefore
=
mChild
;
mChild
=
nextChild
;
return
true
;
}
}
else
{
TreeWalker
finder
(
container
)
;
if
(
finder
.
Seek
(
node
)
)
{
mChild
=
mWalker
.
Scope
(
node
)
;
if
(
mChild
)
{
MOZ_ASSERT
(
!
mChild
-
>
IsRelocated
(
)
"
child
cannot
be
aria
owned
"
)
;
mChildBefore
=
finder
.
Prev
(
)
;
return
true
;
}
}
}
}
return
false
;
}
void
DocAccessible
:
:
ProcessContentInserted
(
LocalAccessible
*
aContainer
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
aNodes
)
{
if
(
!
aContainer
-
>
IsInDocument
(
)
)
{
return
;
}
if
(
aContainer
=
=
this
)
{
UpdateRootElIfNeeded
(
)
;
}
InsertIterator
iter
(
aContainer
aNodes
)
;
if
(
!
iter
.
Next
(
)
)
{
return
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
children
before
insertion
"
logging
:
:
eVerbose
aContainer
)
;
#
endif
TreeMutation
mt
(
aContainer
)
;
do
{
LocalAccessible
*
parent
=
iter
.
Child
(
)
-
>
LocalParent
(
)
;
if
(
parent
)
{
LocalAccessible
*
previousSibling
=
iter
.
ChildBefore
(
)
;
if
(
parent
!
=
aContainer
|
|
iter
.
Child
(
)
-
>
LocalPrevSibling
(
)
!
=
previousSibling
)
{
if
(
previousSibling
&
&
previousSibling
-
>
LocalParent
(
)
!
=
aContainer
)
{
MOZ_DIAGNOSTIC_ASSERT
(
parent
=
=
aContainer
"
Child
moving
to
new
parent
but
previous
"
"
sibling
in
wrong
parent
"
)
;
continue
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
relocating
accessible
"
0
"
old
parent
"
parent
"
new
parent
"
aContainer
"
child
"
iter
.
Child
(
)
nullptr
)
;
#
endif
MoveChild
(
iter
.
Child
(
)
aContainer
previousSibling
?
previousSibling
-
>
IndexInParent
(
)
+
1
:
0
)
;
}
continue
;
}
if
(
aContainer
-
>
InsertAfter
(
iter
.
Child
(
)
iter
.
ChildBefore
(
)
)
)
{
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
accessible
was
inserted
"
0
"
container
"
aContainer
"
child
"
iter
.
Child
(
)
nullptr
)
;
#
endif
CreateSubtree
(
iter
.
Child
(
)
)
;
mt
.
AfterInsertion
(
iter
.
Child
(
)
)
;
continue
;
}
MOZ_ASSERT_UNREACHABLE
(
"
accessible
was
rejected
"
)
;
iter
.
Rejected
(
)
;
}
while
(
iter
.
Next
(
)
)
;
mt
.
Done
(
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
children
after
insertion
"
logging
:
:
eVerbose
aContainer
)
;
#
endif
FireEventsOnInsertion
(
aContainer
)
;
}
void
DocAccessible
:
:
ProcessContentInserted
(
LocalAccessible
*
aContainer
nsIContent
*
aNode
)
{
if
(
!
aContainer
-
>
IsInDocument
(
)
)
{
return
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
children
before
insertion
"
logging
:
:
eVerbose
aContainer
)
;
#
endif
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
traversing
an
inserted
node
"
logging
:
:
eVerbose
"
container
"
aContainer
"
node
"
aNode
)
;
#
endif
TreeWalker
walker
(
aContainer
)
;
if
(
aContainer
-
>
IsAcceptableChild
(
aNode
)
&
&
walker
.
Seek
(
aNode
)
)
{
LocalAccessible
*
child
=
GetAccessible
(
aNode
)
;
if
(
!
child
)
{
child
=
GetAccService
(
)
-
>
CreateAccessible
(
aNode
aContainer
)
;
}
if
(
child
)
{
TreeMutation
mt
(
aContainer
)
;
if
(
!
aContainer
-
>
InsertAfter
(
child
walker
.
Prev
(
)
)
)
{
return
;
}
CreateSubtree
(
child
)
;
mt
.
AfterInsertion
(
child
)
;
mt
.
Done
(
)
;
FireEventsOnInsertion
(
aContainer
)
;
}
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
children
after
insertion
"
logging
:
:
eVerbose
aContainer
)
;
#
endif
}
void
DocAccessible
:
:
FireEventsOnInsertion
(
LocalAccessible
*
aContainer
)
{
if
(
aContainer
-
>
IsAlert
(
)
|
|
aContainer
-
>
IsInsideAlert
(
)
)
{
LocalAccessible
*
ancestor
=
aContainer
;
do
{
if
(
ancestor
-
>
IsAlert
(
)
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_ALERT
ancestor
)
;
break
;
}
}
while
(
(
ancestor
=
ancestor
-
>
LocalParent
(
)
)
)
;
}
}
void
DocAccessible
:
:
ContentRemoved
(
LocalAccessible
*
aChild
)
{
LocalAccessible
*
parent
=
aChild
-
>
LocalParent
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
parent
"
Unattached
accessible
from
tree
"
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
process
content
removal
"
0
"
container
"
parent
"
child
"
aChild
nullptr
)
;
#
endif
RefPtr
<
LocalAccessible
>
kungFuDeathGripChild
(
aChild
)
;
TreeMutation
mt
(
parent
)
;
mt
.
BeforeRemoval
(
aChild
)
;
if
(
aChild
-
>
IsDefunct
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Event
coalescence
killed
the
accessible
"
)
;
mt
.
Done
(
)
;
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aChild
-
>
LocalParent
(
)
"
Alive
but
unparented
#
1
"
)
;
if
(
aChild
-
>
IsRelocated
(
)
)
{
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
owned
=
mARIAOwnsHash
.
Get
(
parent
)
;
MOZ_ASSERT
(
owned
"
IsRelocated
flag
is
out
of
sync
with
mARIAOwnsHash
"
)
;
owned
-
>
RemoveElement
(
aChild
)
;
if
(
owned
-
>
Length
(
)
=
=
0
)
{
mARIAOwnsHash
.
Remove
(
parent
)
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
aChild
-
>
LocalParent
(
)
"
Unparented
#
2
"
)
;
parent
-
>
RemoveChild
(
aChild
)
;
UncacheChildrenInSubtree
(
aChild
)
;
mt
.
Done
(
)
;
}
void
DocAccessible
:
:
ContentRemoved
(
nsIContent
*
aContentNode
)
{
LocalAccessible
*
acc
=
GetAccessible
(
aContentNode
)
;
if
(
acc
)
{
ContentRemoved
(
acc
)
;
}
dom
:
:
AllChildrenIterator
iter
=
dom
:
:
AllChildrenIterator
(
aContentNode
nsIContent
:
:
eAllChildren
true
)
;
while
(
nsIContent
*
childNode
=
iter
.
GetNextChild
(
)
)
{
ContentRemoved
(
childNode
)
;
}
if
(
aContentNode
-
>
GetShadowRoot
(
)
)
{
dom
:
:
ExplicitChildIterator
iter
=
dom
:
:
ExplicitChildIterator
(
aContentNode
)
;
while
(
nsIContent
*
childNode
=
iter
.
GetNextChild
(
)
)
{
ContentRemoved
(
childNode
)
;
}
}
}
bool
DocAccessible
:
:
RelocateARIAOwnedIfNeeded
(
nsIContent
*
aElement
)
{
if
(
!
aElement
-
>
HasID
(
)
)
return
false
;
AttrRelProviders
*
list
=
GetRelProviders
(
aElement
-
>
AsElement
(
)
nsDependentAtomString
(
aElement
-
>
GetID
(
)
)
)
;
if
(
list
)
{
for
(
uint32_t
idx
=
0
;
idx
<
list
-
>
Length
(
)
;
idx
+
+
)
{
if
(
list
-
>
ElementAt
(
idx
)
-
>
mRelAttr
=
=
nsGkAtoms
:
:
aria_owns
)
{
LocalAccessible
*
owner
=
GetAccessible
(
list
-
>
ElementAt
(
idx
)
-
>
mContent
)
;
if
(
owner
)
{
mNotificationController
-
>
ScheduleRelocation
(
owner
)
;
return
true
;
}
}
}
}
return
false
;
}
void
DocAccessible
:
:
DoARIAOwnsRelocation
(
LocalAccessible
*
aOwner
)
{
MOZ_ASSERT
(
aOwner
"
aOwner
must
be
a
valid
pointer
"
)
;
MOZ_ASSERT
(
aOwner
-
>
Elm
(
)
"
aOwner
-
>
Elm
(
)
must
be
a
valid
pointer
"
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
aria
owns
relocation
"
logging
:
:
eVerbose
aOwner
)
;
#
endif
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
owned
=
mARIAOwnsHash
.
GetOrInsertNew
(
aOwner
)
;
IDRefsIterator
iter
(
this
aOwner
-
>
Elm
(
)
nsGkAtoms
:
:
aria_owns
)
;
uint32_t
idx
=
0
;
while
(
nsIContent
*
childEl
=
iter
.
NextElem
(
)
)
{
LocalAccessible
*
child
=
GetAccessible
(
childEl
)
;
auto
insertIdx
=
aOwner
-
>
ChildCount
(
)
-
owned
-
>
Length
(
)
+
idx
;
if
(
!
child
)
{
bool
ok
=
true
;
bool
check
=
true
;
for
(
LocalAccessible
*
parent
=
aOwner
;
parent
&
&
!
parent
-
>
IsDoc
(
)
;
parent
=
parent
-
>
LocalParent
(
)
)
{
if
(
check
)
{
if
(
parent
-
>
Elm
(
)
-
>
IsInclusiveDescendantOf
(
childEl
)
)
{
ok
=
false
;
break
;
}
}
check
=
parent
-
>
IsRelocated
(
)
;
}
if
(
!
ok
)
{
continue
;
}
if
(
aOwner
-
>
IsAcceptableChild
(
childEl
)
)
{
child
=
GetAccService
(
)
-
>
CreateAccessible
(
childEl
aOwner
)
;
if
(
child
)
{
TreeMutation
imut
(
aOwner
)
;
aOwner
-
>
InsertChildAt
(
insertIdx
child
)
;
imut
.
AfterInsertion
(
child
)
;
imut
.
Done
(
)
;
child
-
>
SetRelocated
(
true
)
;
owned
-
>
InsertElementAt
(
idx
child
)
;
idx
+
+
;
CreateSubtree
(
child
)
;
FireEventsOnInsertion
(
aOwner
)
;
}
}
continue
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
aria
owns
traversal
"
logging
:
:
eVerbose
"
candidate
"
child
nullptr
)
;
#
endif
if
(
owned
-
>
IndexOf
(
child
)
<
idx
)
{
continue
;
}
if
(
child
-
>
LocalParent
(
)
=
=
aOwner
)
{
int32_t
indexInParent
=
child
-
>
IndexInParent
(
)
;
if
(
indexInParent
=
=
static_cast
<
int32_t
>
(
insertIdx
)
)
{
MOZ_ASSERT
(
child
-
>
IsRelocated
(
)
"
A
child
having
an
index
in
parent
from
aria
ownded
"
"
indices
range
has
to
be
aria
owned
"
)
;
MOZ_ASSERT
(
owned
-
>
ElementAt
(
idx
)
=
=
child
"
Unexpected
child
in
ARIA
owned
array
"
)
;
idx
+
+
;
continue
;
}
if
(
indexInParent
=
=
static_cast
<
int32_t
>
(
insertIdx
)
-
1
)
{
MOZ_ASSERT
(
!
child
-
>
IsRelocated
(
)
"
Child
should
be
in
its
ordinal
position
"
)
;
child
-
>
SetRelocated
(
true
)
;
owned
-
>
InsertElementAt
(
idx
child
)
;
idx
+
+
;
continue
;
}
}
MOZ_ASSERT
(
owned
-
>
SafeElementAt
(
idx
)
!
=
child
"
Already
in
place
!
"
)
;
if
(
child
-
>
LocalParent
(
)
!
=
aOwner
)
{
if
(
child
-
>
IsRelocated
(
)
)
{
continue
;
}
LocalAccessible
*
parent
=
aOwner
;
while
(
parent
&
&
parent
!
=
child
&
&
!
parent
-
>
IsDoc
(
)
)
{
parent
=
parent
-
>
LocalParent
(
)
;
}
if
(
parent
=
=
child
)
{
continue
;
}
}
if
(
MoveChild
(
child
aOwner
insertIdx
)
)
{
child
-
>
SetRelocated
(
true
)
;
MOZ_ASSERT
(
owned
=
=
mARIAOwnsHash
.
Get
(
aOwner
)
)
;
owned
=
mARIAOwnsHash
.
GetOrInsertNew
(
aOwner
)
;
owned
-
>
InsertElementAt
(
idx
child
)
;
idx
+
+
;
}
}
PutChildrenBack
(
owned
idx
)
;
if
(
owned
-
>
Length
(
)
=
=
0
)
{
mARIAOwnsHash
.
Remove
(
aOwner
)
;
}
}
void
DocAccessible
:
:
PutChildrenBack
(
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
aChildren
uint32_t
aStartIdx
)
{
MOZ_ASSERT
(
aStartIdx
<
=
aChildren
-
>
Length
(
)
"
Wrong
removal
index
"
)
;
for
(
auto
idx
=
aStartIdx
;
idx
<
aChildren
-
>
Length
(
)
;
idx
+
+
)
{
LocalAccessible
*
child
=
aChildren
-
>
ElementAt
(
idx
)
;
if
(
!
child
-
>
IsInDocument
(
)
)
{
continue
;
}
LocalAccessible
*
owner
=
child
-
>
LocalParent
(
)
;
if
(
!
owner
)
{
NS_ERROR
(
"
Cannot
put
the
child
back
.
No
parent
a
broken
tree
.
"
)
;
continue
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
aria
owns
put
child
back
"
0
"
old
parent
"
owner
"
child
"
child
nullptr
)
;
#
endif
child
-
>
SetRelocated
(
false
)
;
nsIContent
*
content
=
child
-
>
GetContent
(
)
;
int32_t
idxInParent
=
-
1
;
LocalAccessible
*
origContainer
=
AccessibleOrTrueContainer
(
content
-
>
GetFlattenedTreeParentNode
(
)
)
;
if
(
origContainer
)
{
TreeWalker
walker
(
origContainer
)
;
if
(
walker
.
Seek
(
content
)
)
{
LocalAccessible
*
prevChild
=
walker
.
Prev
(
)
;
if
(
prevChild
)
{
idxInParent
=
prevChild
-
>
IndexInParent
(
)
+
1
;
MOZ_DIAGNOSTIC_ASSERT
(
origContainer
=
=
prevChild
-
>
LocalParent
(
)
"
Broken
tree
"
)
;
origContainer
=
prevChild
-
>
LocalParent
(
)
;
}
else
{
idxInParent
=
0
;
}
}
}
if
(
origContainer
!
=
owner
|
|
child
-
>
IndexInParent
(
)
!
=
idxInParent
)
{
DebugOnly
<
bool
>
moved
=
MoveChild
(
child
origContainer
idxInParent
)
;
MOZ_ASSERT
(
moved
"
Failed
to
put
child
back
.
"
)
;
}
else
{
MOZ_ASSERT
(
!
child
-
>
LocalPrevSibling
(
)
|
|
!
child
-
>
LocalPrevSibling
(
)
-
>
IsRelocated
(
)
"
No
relocated
child
should
appear
before
this
one
"
)
;
MOZ_ASSERT
(
!
child
-
>
LocalNextSibling
(
)
|
|
child
-
>
LocalNextSibling
(
)
-
>
IsRelocated
(
)
"
No
ordinal
child
should
appear
after
this
one
"
)
;
}
}
aChildren
-
>
RemoveLastElements
(
aChildren
-
>
Length
(
)
-
aStartIdx
)
;
}
bool
DocAccessible
:
:
MoveChild
(
LocalAccessible
*
aChild
LocalAccessible
*
aNewParent
int32_t
aIdxInParent
)
{
MOZ_ASSERT
(
aChild
"
No
child
"
)
;
MOZ_ASSERT
(
aChild
-
>
LocalParent
(
)
"
No
parent
"
)
;
MOZ_ASSERT
(
aIdxInParent
<
=
static_cast
<
int32_t
>
(
aNewParent
-
>
mChildren
.
Length
(
)
)
"
Wrong
insertion
point
for
a
moving
child
"
)
;
LocalAccessible
*
curParent
=
aChild
-
>
LocalParent
(
)
;
if
(
!
aNewParent
-
>
IsAcceptableChild
(
aChild
-
>
GetContent
(
)
)
)
{
return
false
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
move
child
"
0
"
old
parent
"
curParent
"
new
parent
"
aNewParent
"
child
"
aChild
nullptr
)
;
#
endif
if
(
aChild
-
>
IsRelocated
(
)
)
{
aChild
-
>
SetRelocated
(
false
)
;
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
owned
=
mARIAOwnsHash
.
Get
(
curParent
)
;
MOZ_ASSERT
(
owned
"
IsRelocated
flag
is
out
of
sync
with
mARIAOwnsHash
"
)
;
owned
-
>
RemoveElement
(
aChild
)
;
if
(
owned
-
>
Length
(
)
=
=
0
)
{
mARIAOwnsHash
.
Remove
(
curParent
)
;
}
}
NotificationController
:
:
MoveGuard
mguard
(
mNotificationController
)
;
if
(
curParent
=
=
aNewParent
)
{
MOZ_ASSERT
(
aChild
-
>
IndexInParent
(
)
!
=
aIdxInParent
"
No
move
case
"
)
;
curParent
-
>
RelocateChild
(
aIdxInParent
aChild
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
move
child
:
parent
tree
after
"
logging
:
:
eVerbose
curParent
)
;
#
endif
return
true
;
}
bool
hasInsertionPoint
=
(
aIdxInParent
>
=
0
)
&
&
(
aIdxInParent
<
=
static_cast
<
int32_t
>
(
aNewParent
-
>
mChildren
.
Length
(
)
)
)
;
TreeMutation
rmut
(
curParent
)
;
rmut
.
BeforeRemoval
(
aChild
hasInsertionPoint
&
&
TreeMutation
:
:
kNoShutdown
)
;
curParent
-
>
RemoveChild
(
aChild
)
;
rmut
.
Done
(
)
;
if
(
!
hasInsertionPoint
)
{
return
true
;
}
TreeMutation
imut
(
aNewParent
)
;
aNewParent
-
>
InsertChildAt
(
aIdxInParent
aChild
)
;
imut
.
AfterInsertion
(
aChild
)
;
imut
.
Done
(
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
move
child
:
old
parent
tree
after
"
logging
:
:
eVerbose
curParent
)
;
logging
:
:
TreeInfo
(
"
move
child
:
new
parent
tree
after
"
logging
:
:
eVerbose
aNewParent
)
;
#
endif
return
true
;
}
void
DocAccessible
:
:
CacheChildrenInSubtree
(
LocalAccessible
*
aRoot
LocalAccessible
*
*
aFocusedAcc
)
{
if
(
aFocusedAcc
&
&
!
*
aFocusedAcc
&
&
FocusMgr
(
)
-
>
HasDOMFocus
(
aRoot
-
>
GetContent
(
)
)
)
{
*
aFocusedAcc
=
aRoot
;
}
LocalAccessible
*
root
=
aRoot
-
>
IsHTMLCombobox
(
)
?
aRoot
-
>
LocalFirstChild
(
)
:
aRoot
;
if
(
root
-
>
KidsFromDOM
(
)
)
{
TreeMutation
mt
(
root
TreeMutation
:
:
kNoEvents
)
;
TreeWalker
walker
(
root
)
;
while
(
LocalAccessible
*
child
=
walker
.
Next
(
)
)
{
if
(
child
-
>
IsBoundToParent
(
)
)
{
MoveChild
(
child
root
root
-
>
mChildren
.
Length
(
)
)
;
continue
;
}
root
-
>
AppendChild
(
child
)
;
mt
.
AfterInsertion
(
child
)
;
CacheChildrenInSubtree
(
child
aFocusedAcc
)
;
}
mt
.
Done
(
)
;
}
if
(
!
aRoot
-
>
HasARIARole
(
)
)
{
return
;
}
roles
:
:
Role
role
=
aRoot
-
>
ARIARole
(
)
;
if
(
!
aRoot
-
>
IsDoc
(
)
&
&
(
role
=
=
roles
:
:
DIALOG
|
|
role
=
=
roles
:
:
NON_NATIVE_DOCUMENT
)
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_LOAD_COMPLETE
aRoot
)
;
}
}
void
DocAccessible
:
:
UncacheChildrenInSubtree
(
LocalAccessible
*
aRoot
)
{
aRoot
-
>
mStateFlags
|
=
eIsNotInDocument
;
RemoveDependentIDsFor
(
aRoot
)
;
nsTArray
<
RefPtr
<
LocalAccessible
>
>
*
owned
=
mARIAOwnsHash
.
Get
(
aRoot
)
;
uint32_t
count
=
aRoot
-
>
ContentChildCount
(
)
;
for
(
uint32_t
idx
=
0
;
idx
<
count
;
idx
+
+
)
{
LocalAccessible
*
child
=
aRoot
-
>
ContentChildAt
(
idx
)
;
if
(
child
-
>
IsRelocated
(
)
)
{
MOZ_ASSERT
(
owned
"
IsRelocated
flag
is
out
of
sync
with
mARIAOwnsHash
"
)
;
owned
-
>
RemoveElement
(
child
)
;
if
(
owned
-
>
Length
(
)
=
=
0
)
{
mARIAOwnsHash
.
Remove
(
aRoot
)
;
owned
=
nullptr
;
}
}
if
(
!
child
-
>
IsDoc
(
)
)
{
UncacheChildrenInSubtree
(
child
)
;
}
}
if
(
aRoot
-
>
IsNodeMapEntry
(
)
&
&
mNodeToAccessibleMap
.
Get
(
aRoot
-
>
GetNode
(
)
)
=
=
aRoot
)
{
mNodeToAccessibleMap
.
Remove
(
aRoot
-
>
GetNode
(
)
)
;
}
}
void
DocAccessible
:
:
ShutdownChildrenInSubtree
(
LocalAccessible
*
aAccessible
)
{
uint32_t
count
=
aAccessible
-
>
ContentChildCount
(
)
;
for
(
uint32_t
idx
=
0
jdx
=
0
;
idx
<
count
;
idx
+
+
)
{
LocalAccessible
*
child
=
aAccessible
-
>
ContentChildAt
(
jdx
)
;
if
(
!
child
-
>
IsBoundToParent
(
)
)
{
NS_ERROR
(
"
Parent
refers
to
a
child
child
doesn
'
t
refer
to
parent
!
"
)
;
jdx
+
+
;
}
if
(
!
child
-
>
IsDoc
(
)
)
ShutdownChildrenInSubtree
(
child
)
;
}
UnbindFromDocument
(
aAccessible
)
;
}
bool
DocAccessible
:
:
IsLoadEventTarget
(
)
const
{
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
=
mDocumentNode
-
>
GetDocShell
(
)
;
if
(
!
treeItem
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parentTreeItem
;
treeItem
-
>
GetInProcessParent
(
getter_AddRefs
(
parentTreeItem
)
)
;
if
(
parentTreeItem
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
rootTreeItem
;
treeItem
-
>
GetInProcessRootTreeItem
(
getter_AddRefs
(
rootTreeItem
)
)
;
if
(
parentTreeItem
=
=
rootTreeItem
)
return
true
;
DocAccessible
*
parentDoc
=
ParentDocument
(
)
;
return
parentDoc
&
&
parentDoc
-
>
HasLoadState
(
eCompletelyLoaded
)
;
}
return
(
treeItem
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeContent
)
;
}
void
DocAccessible
:
:
SetIPCDoc
(
DocAccessibleChild
*
aIPCDoc
)
{
MOZ_ASSERT
(
!
mIPCDoc
|
|
!
aIPCDoc
"
Clobbering
an
attached
IPCDoc
!
"
)
;
mIPCDoc
=
aIPCDoc
;
}
void
DocAccessible
:
:
DispatchScrollingEvent
(
nsINode
*
aTarget
uint32_t
aEventType
)
{
LocalAccessible
*
acc
=
GetAccessible
(
aTarget
)
;
if
(
!
acc
)
{
return
;
}
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
!
frame
)
{
return
;
}
LayoutDevicePoint
scrollPoint
;
LayoutDeviceRect
scrollRange
;
nsIScrollableFrame
*
sf
=
acc
=
=
this
?
mPresShell
-
>
GetRootScrollFrameAsScrollable
(
)
:
frame
-
>
GetScrollTargetFrame
(
)
;
if
(
sf
)
{
int32_t
appUnitsPerDevPixel
=
mPresShell
-
>
GetPresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
scrollPoint
=
LayoutDevicePoint
:
:
FromAppUnits
(
sf
-
>
GetScrollPosition
(
)
appUnitsPerDevPixel
)
*
mPresShell
-
>
GetResolution
(
)
;
scrollRange
=
LayoutDeviceRect
:
:
FromAppUnits
(
sf
-
>
GetScrollRange
(
)
appUnitsPerDevPixel
)
;
scrollRange
.
ScaleRoundOut
(
mPresShell
-
>
GetResolution
(
)
)
;
}
RefPtr
<
AccEvent
>
event
=
new
AccScrollingEvent
(
aEventType
acc
scrollPoint
.
x
scrollPoint
.
y
scrollRange
.
width
scrollRange
.
height
)
;
nsEventShell
:
:
FireEvent
(
event
)
;
}
void
DocAccessible
:
:
ARIAActiveDescendantIDMaybeMoved
(
dom
:
:
Element
*
aElm
)
{
nsINode
*
focusNode
=
FocusMgr
(
)
-
>
FocusedDOMNode
(
)
;
if
(
!
focusNode
|
|
focusNode
-
>
OwnerDoc
(
)
!
=
mDocumentNode
)
{
return
;
}
dom
:
:
Element
*
focusElm
=
nullptr
;
if
(
focusNode
=
=
mDocumentNode
)
{
focusElm
=
Elm
(
)
;
if
(
!
focusElm
)
{
return
;
}
}
else
{
MOZ_ASSERT
(
focusNode
-
>
IsElement
(
)
)
;
focusElm
=
focusNode
-
>
AsElement
(
)
;
}
nsAutoString
id
;
aElm
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
id
)
;
if
(
!
focusElm
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_activedescendant
id
eCaseMatters
)
)
{
return
;
}
LocalAccessible
*
acc
=
GetAccessibleEvenIfNotInMapOrContainer
(
focusNode
)
;
if
(
!
acc
)
{
return
;
}
mNotificationController
-
>
ScheduleNotification
<
DocAccessible
LocalAccessible
>
(
this
&
DocAccessible
:
:
ARIAActiveDescendantChanged
acc
)
;
}
void
DocAccessible
:
:
SetRoleMapEntryForDoc
(
dom
:
:
Element
*
aElement
)
{
const
nsRoleMapEntry
*
entry
=
aria
:
:
GetRoleMap
(
aElement
)
;
if
(
!
entry
|
|
entry
-
>
role
=
=
roles
:
:
APPLICATION
|
|
entry
-
>
role
=
=
roles
:
:
DIALOG
|
|
(
entry
-
>
role
=
=
roles
:
:
ALERT
&
&
!
mDocumentNode
-
>
IsContentDocument
(
)
)
)
{
SetRoleMapEntry
(
entry
)
;
return
;
}
SetRoleMapEntry
(
nullptr
)
;
}
LocalAccessible
*
DocAccessible
:
:
GetAccessible
(
nsINode
*
aNode
)
const
{
return
aNode
=
=
mDocumentNode
?
const_cast
<
DocAccessible
*
>
(
this
)
:
mNodeToAccessibleMap
.
Get
(
aNode
)
;
}
