#
include
"
Accessible
-
inl
.
h
"
#
include
"
AccIterator
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
DocAccessibleChild
.
h
"
#
include
"
HTMLImageMapAccessible
.
h
"
#
include
"
nsAccCache
.
h
"
#
include
"
nsAccessiblePivot
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
nsTextEquivUtils
.
h
"
#
include
"
Role
.
h
"
#
include
"
RootAccessible
.
h
"
#
include
"
TreeWalker
.
h
"
#
include
"
xpcAccessibleDocument
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsICommandManager
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIEditingSession
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsIPersistentProperties2
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
DocumentType
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
static
nsStaticAtom
*
const
kRelationAttrs
[
]
=
{
nsGkAtoms
:
:
aria_labelledby
nsGkAtoms
:
:
aria_describedby
nsGkAtoms
:
:
aria_details
nsGkAtoms
:
:
aria_owns
nsGkAtoms
:
:
aria_controls
nsGkAtoms
:
:
aria_flowto
nsGkAtoms
:
:
aria_errormessage
nsGkAtoms
:
:
_for
nsGkAtoms
:
:
control
}
;
static
const
uint32_t
kRelationAttrsLen
=
ArrayLength
(
kRelationAttrs
)
;
DocAccessible
:
:
DocAccessible
(
dom
:
:
Document
*
aDocument
nsIPresShell
*
aPresShell
)
:
HyperTextAccessibleWrap
(
nullptr
nullptr
)
mAccessibleCache
(
kDefaultCacheLength
)
mNodeToAccessibleMap
(
kDefaultCacheLength
)
mDocumentNode
(
aDocument
)
mScrollPositionChangedTicks
(
0
)
mLoadState
(
eTreeConstructionPending
)
mDocFlags
(
0
)
mLoadEventType
(
0
)
mARIAAttrOldValue
{
nullptr
}
mVirtualCursor
(
nullptr
)
mPresShell
(
aPresShell
)
mIPCDoc
(
nullptr
)
{
mGenericTypes
|
=
eDocument
;
mStateFlags
|
=
eNotNodeMapEntry
;
mDoc
=
this
;
MOZ_ASSERT
(
mPresShell
"
should
have
been
given
a
pres
shell
"
)
;
mPresShell
-
>
SetDocAccessible
(
this
)
;
if
(
mDocumentNode
&
&
mDocumentNode
-
>
IsXULDocument
(
)
)
mGenericTypes
&
=
~
eHyperText
;
}
DocAccessible
:
:
~
DocAccessible
(
)
{
NS_ASSERTION
(
!
mPresShell
"
LastRelease
was
never
called
!
?
!
"
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
DocAccessible
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
DocAccessible
Accessible
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mNotificationController
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mVirtualCursor
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChildDocuments
)
for
(
auto
hashesIter
=
tmp
-
>
mDependentIDsHashes
.
Iter
(
)
;
!
hashesIter
.
Done
(
)
;
hashesIter
.
Next
(
)
)
{
auto
dependentIDsHash
=
hashesIter
.
UserData
(
)
;
for
(
auto
providersIter
=
dependentIDsHash
-
>
Iter
(
)
;
!
providersIter
.
Done
(
)
;
providersIter
.
Next
(
)
)
{
AttrRelProviders
*
providers
=
providersIter
.
UserData
(
)
;
for
(
int32_t
provIdx
=
providers
-
>
Length
(
)
-
1
;
provIdx
>
=
0
;
provIdx
-
-
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
content
of
dependent
ids
hash
entry
of
document
accessible
"
)
;
AttrRelProvider
*
provider
=
(
*
providers
)
[
provIdx
]
;
cb
.
NoteXPCOMChild
(
provider
-
>
mContent
)
;
}
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAccessibleCache
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAnchorJumpElm
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mInvalidationList
)
for
(
auto
it
=
tmp
-
>
mARIAOwnsHash
.
ConstIter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
nsTArray
<
RefPtr
<
Accessible
>
>
*
ar
=
it
.
UserData
(
)
;
for
(
uint32_t
i
=
0
;
i
<
ar
-
>
Length
(
)
;
i
+
+
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mARIAOwnsHash
entry
item
"
)
;
cb
.
NoteXPCOMChild
(
ar
-
>
ElementAt
(
i
)
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
DocAccessible
Accessible
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mNotificationController
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mVirtualCursor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChildDocuments
)
tmp
-
>
mDependentIDsHashes
.
Clear
(
)
;
tmp
-
>
mNodeToAccessibleMap
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAccessibleCache
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAnchorJumpElm
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mInvalidationList
)
tmp
-
>
mARIAOwnsHash
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DocAccessible
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIAccessiblePivotObserver
)
NS_INTERFACE_MAP_END_INHERITING
(
HyperTextAccessible
)
NS_IMPL_ADDREF_INHERITED
(
DocAccessible
HyperTextAccessible
)
NS_IMPL_RELEASE_INHERITED
(
DocAccessible
HyperTextAccessible
)
ENameValueFlag
DocAccessible
:
:
Name
(
nsString
&
aName
)
const
{
aName
.
Truncate
(
)
;
if
(
mParent
)
{
mParent
-
>
Name
(
aName
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
Accessible
:
:
Name
(
aName
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
Title
(
aName
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
URL
(
aName
)
;
}
return
eNameOK
;
}
role
DocAccessible
:
:
NativeRole
(
)
const
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
nsCoreUtils
:
:
GetDocShellFor
(
mDocumentNode
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
sameTypeRoot
;
docShell
-
>
GetSameTypeRootTreeItem
(
getter_AddRefs
(
sameTypeRoot
)
)
;
int32_t
itemType
=
docShell
-
>
ItemType
(
)
;
if
(
sameTypeRoot
=
=
docShell
)
{
if
(
itemType
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
return
roles
:
:
CHROME_WINDOW
;
if
(
itemType
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
#
ifdef
MOZ_XUL
if
(
mDocumentNode
&
&
mDocumentNode
-
>
IsXULDocument
(
)
)
return
roles
:
:
APPLICATION
;
#
endif
return
roles
:
:
DOCUMENT
;
}
}
else
if
(
itemType
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
return
roles
:
:
DOCUMENT
;
}
}
return
roles
:
:
PANE
;
}
void
DocAccessible
:
:
Description
(
nsString
&
aDescription
)
{
if
(
mParent
)
mParent
-
>
Description
(
aDescription
)
;
if
(
HasOwnContent
(
)
&
&
aDescription
.
IsEmpty
(
)
)
{
nsTextEquivUtils
:
:
GetTextEquivFromIDRefs
(
this
nsGkAtoms
:
:
aria_describedby
aDescription
)
;
}
}
uint64_t
DocAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
states
:
:
FOCUSABLE
;
if
(
FocusMgr
(
)
-
>
IsFocused
(
this
)
)
state
|
=
states
:
:
FOCUSED
;
if
(
!
HasLoadState
(
eReady
)
)
state
|
=
states
:
:
STALE
;
if
(
!
HasLoadState
(
eCompletelyLoaded
)
)
state
|
=
states
:
:
BUSY
;
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
!
frame
|
|
!
frame
-
>
IsVisibleConsideringAncestors
(
nsIFrame
:
:
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
)
{
state
|
=
states
:
:
INVISIBLE
|
states
:
:
OFFSCREEN
;
}
RefPtr
<
TextEditor
>
textEditor
=
GetEditor
(
)
;
state
|
=
textEditor
?
states
:
:
EDITABLE
:
states
:
:
READONLY
;
return
state
;
}
uint64_t
DocAccessible
:
:
NativeInteractiveState
(
)
const
{
return
states
:
:
FOCUSABLE
;
}
bool
DocAccessible
:
:
NativelyUnavailable
(
)
const
{
return
false
;
}
void
DocAccessible
:
:
ApplyARIAState
(
uint64_t
*
aState
)
const
{
if
(
mContent
)
Accessible
:
:
ApplyARIAState
(
aState
)
;
if
(
mParent
)
mParent
-
>
ApplyARIAState
(
aState
)
;
}
already_AddRefed
<
nsIPersistentProperties
>
DocAccessible
:
:
Attributes
(
)
{
nsCOMPtr
<
nsIPersistentProperties
>
attributes
=
HyperTextAccessibleWrap
:
:
Attributes
(
)
;
if
(
!
mParent
|
|
IsRoot
(
)
)
return
attributes
.
forget
(
)
;
aria
:
:
AttrIterator
attribIter
(
mParent
-
>
GetContent
(
)
)
;
nsAutoString
name
value
unused
;
while
(
attribIter
.
Next
(
name
value
)
)
attributes
-
>
SetStringProperty
(
NS_ConvertUTF16toUTF8
(
name
)
value
unused
)
;
return
attributes
.
forget
(
)
;
}
Accessible
*
DocAccessible
:
:
FocusedChild
(
)
{
return
FocusMgr
(
)
-
>
FocusedAccessible
(
)
;
}
void
DocAccessible
:
:
TakeFocus
(
)
const
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
RefPtr
<
dom
:
:
Element
>
newFocus
;
AutoHandlingUserInputStatePusher
inputStatePusher
(
true
nullptr
mDocumentNode
)
;
fm
-
>
MoveFocus
(
mDocumentNode
-
>
GetWindow
(
)
nullptr
nsFocusManager
:
:
MOVEFOCUS_ROOT
0
getter_AddRefs
(
newFocus
)
)
;
}
already_AddRefed
<
TextEditor
>
DocAccessible
:
:
GetEditor
(
)
const
{
if
(
!
mDocumentNode
-
>
HasFlag
(
NODE_IS_EDITABLE
)
&
&
(
!
mContent
|
|
!
mContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
)
return
nullptr
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
mDocumentNode
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIEditingSession
>
editingSession
;
docShell
-
>
GetEditingSession
(
getter_AddRefs
(
editingSession
)
)
;
if
(
!
editingSession
)
return
nullptr
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
editingSession
-
>
GetHTMLEditorForWindow
(
mDocumentNode
-
>
GetWindow
(
)
)
;
if
(
!
htmlEditor
)
{
return
nullptr
;
}
bool
isEditable
=
false
;
htmlEditor
-
>
GetIsDocumentEditable
(
&
isEditable
)
;
if
(
isEditable
)
{
return
htmlEditor
.
forget
(
)
;
}
return
nullptr
;
}
void
DocAccessible
:
:
URL
(
nsAString
&
aURL
)
const
{
nsCOMPtr
<
nsISupports
>
container
=
mDocumentNode
-
>
GetContainer
(
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_GetInterface
(
container
)
)
;
nsAutoCString
theURL
;
if
(
webNav
)
{
nsCOMPtr
<
nsIURI
>
pURI
;
webNav
-
>
GetCurrentURI
(
getter_AddRefs
(
pURI
)
)
;
if
(
pURI
)
pURI
-
>
GetSpec
(
theURL
)
;
}
CopyUTF8toUTF16
(
theURL
aURL
)
;
}
void
DocAccessible
:
:
DocType
(
nsAString
&
aType
)
const
{
#
ifdef
MOZ_XUL
if
(
mDocumentNode
-
>
IsXULDocument
(
)
)
{
aType
.
AssignLiteral
(
"
window
"
)
;
return
;
}
#
endif
dom
:
:
DocumentType
*
docType
=
mDocumentNode
-
>
GetDoctype
(
)
;
if
(
docType
)
docType
-
>
GetPublicId
(
aType
)
;
}
void
DocAccessible
:
:
Init
(
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocCreate
)
)
logging
:
:
DocCreate
(
"
document
initialize
"
mDocumentNode
this
)
;
#
endif
mNotificationController
=
new
NotificationController
(
this
mPresShell
)
;
if
(
mDocumentNode
-
>
GetReadyStateEnum
(
)
=
=
dom
:
:
Document
:
:
READYSTATE_COMPLETE
)
mLoadState
|
=
eDOMLoaded
;
AddEventListeners
(
)
;
}
void
DocAccessible
:
:
Shutdown
(
)
{
if
(
!
mPresShell
)
return
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocDestroy
)
)
logging
:
:
DocDestroy
(
"
document
shutdown
"
mDocumentNode
this
)
;
#
endif
mStateFlags
|
=
eIsDefunct
;
if
(
mNotificationController
)
{
mNotificationController
-
>
Shutdown
(
)
;
mNotificationController
=
nullptr
;
}
RemoveEventListeners
(
)
;
if
(
mParent
)
{
DocAccessible
*
parentDocument
=
mParent
-
>
Document
(
)
;
if
(
parentDocument
)
parentDocument
-
>
RemoveChildDocument
(
this
)
;
mParent
-
>
RemoveChild
(
this
)
;
MOZ_ASSERT
(
!
mParent
"
Parent
has
to
be
null
!
"
)
;
}
int32_t
childDocCount
=
mChildDocuments
.
Length
(
)
;
for
(
int32_t
idx
=
childDocCount
-
1
;
idx
>
=
0
;
idx
-
-
)
mChildDocuments
[
idx
]
-
>
Shutdown
(
)
;
mChildDocuments
.
Clear
(
)
;
if
(
mIPCDoc
)
{
MOZ_ASSERT
(
IPCAccessibilityActive
(
)
)
;
mIPCDoc
-
>
Shutdown
(
)
;
MOZ_ASSERT
(
!
mIPCDoc
)
;
}
if
(
mVirtualCursor
)
{
mVirtualCursor
-
>
RemoveObserver
(
this
)
;
mVirtualCursor
=
nullptr
;
}
mPresShell
-
>
SetDocAccessible
(
nullptr
)
;
mPresShell
=
nullptr
;
mDependentIDsHashes
.
Clear
(
)
;
mNodeToAccessibleMap
.
Clear
(
)
;
for
(
auto
iter
=
mAccessibleCache
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Accessible
*
accessible
=
iter
.
Data
(
)
;
MOZ_ASSERT
(
accessible
)
;
if
(
accessible
&
&
!
accessible
-
>
IsDefunct
(
)
)
{
accessible
-
>
mParent
=
nullptr
;
accessible
-
>
Shutdown
(
)
;
}
iter
.
Remove
(
)
;
}
HyperTextAccessibleWrap
:
:
Shutdown
(
)
;
GetAccService
(
)
-
>
NotifyOfDocumentShutdown
(
this
mDocumentNode
)
;
mDocumentNode
=
nullptr
;
}
nsIFrame
*
DocAccessible
:
:
GetFrame
(
)
const
{
nsIFrame
*
root
=
nullptr
;
if
(
mPresShell
)
root
=
mPresShell
-
>
GetRootFrame
(
)
;
return
root
;
}
nsRect
DocAccessible
:
:
RelativeBounds
(
nsIFrame
*
*
aRelativeFrame
)
const
{
*
aRelativeFrame
=
GetFrame
(
)
;
dom
:
:
Document
*
document
=
mDocumentNode
;
dom
:
:
Document
*
parentDoc
=
nullptr
;
nsRect
bounds
;
while
(
document
)
{
mozilla
:
:
PresShell
*
presShell
=
document
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nsRect
(
)
;
}
nsRect
scrollPort
;
nsIScrollableFrame
*
sf
=
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
sf
)
{
scrollPort
=
sf
-
>
GetScrollPortRect
(
)
;
}
else
{
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
return
nsRect
(
)
;
scrollPort
=
rootFrame
-
>
GetRect
(
)
;
}
if
(
parentDoc
)
{
bounds
.
IntersectRect
(
scrollPort
bounds
)
;
}
else
{
bounds
=
scrollPort
;
}
document
=
parentDoc
=
document
-
>
GetParentDocument
(
)
;
}
return
bounds
;
}
nsresult
DocAccessible
:
:
AddEventListeners
(
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentNode
-
>
GetDocShell
(
)
)
;
if
(
docShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
nsCOMPtr
<
nsICommandManager
>
commandManager
=
docShell
-
>
GetCommandManager
(
)
;
if
(
commandManager
)
commandManager
-
>
AddCommandObserver
(
this
"
obs_documentCreated
"
)
;
}
SelectionMgr
(
)
-
>
AddDocSelectionListener
(
mPresShell
)
;
mDocumentNode
-
>
AddObserver
(
this
)
;
return
NS_OK
;
}
nsresult
DocAccessible
:
:
RemoveEventListeners
(
)
{
RemoveScrollListener
(
)
;
NS_ASSERTION
(
mDocumentNode
"
No
document
during
removal
of
listeners
.
"
)
;
if
(
mDocumentNode
)
{
mDocumentNode
-
>
RemoveObserver
(
this
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentNode
-
>
GetDocShell
(
)
)
;
NS_ASSERTION
(
docShell
"
doc
should
support
nsIDocShellTreeItem
.
"
)
;
if
(
docShell
)
{
if
(
docShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
nsCOMPtr
<
nsICommandManager
>
commandManager
=
docShell
-
>
GetCommandManager
(
)
;
if
(
commandManager
)
{
commandManager
-
>
RemoveCommandObserver
(
this
"
obs_documentCreated
"
)
;
}
}
}
}
if
(
mScrollWatchTimer
)
{
mScrollWatchTimer
-
>
Cancel
(
)
;
mScrollWatchTimer
=
nullptr
;
NS_RELEASE_THIS
(
)
;
}
SelectionMgr
(
)
-
>
RemoveDocSelectionListener
(
mPresShell
)
;
return
NS_OK
;
}
void
DocAccessible
:
:
ScrollTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
DocAccessible
*
docAcc
=
reinterpret_cast
<
DocAccessible
*
>
(
aClosure
)
;
if
(
docAcc
)
{
docAcc
-
>
DispatchScrollingEvent
(
nsIAccessibleEvent
:
:
EVENT_SCROLLING_END
)
;
if
(
docAcc
-
>
mScrollWatchTimer
)
{
docAcc
-
>
mScrollWatchTimer
=
nullptr
;
NS_RELEASE
(
docAcc
)
;
}
}
}
void
DocAccessible
:
:
ScrollPositionDidChange
(
nscoord
aX
nscoord
aY
)
{
const
uint32_t
kScrollEventInterval
=
100
;
TimeStamp
timestamp
=
TimeStamp
:
:
Now
(
)
;
if
(
mLastScrollingDispatch
.
IsNull
(
)
|
|
(
timestamp
-
mLastScrollingDispatch
)
.
ToMilliseconds
(
)
>
=
kScrollEventInterval
)
{
DispatchScrollingEvent
(
nsIAccessibleEvent
:
:
EVENT_SCROLLING
)
;
mLastScrollingDispatch
=
timestamp
;
}
if
(
mScrollWatchTimer
)
{
mScrollWatchTimer
-
>
SetDelay
(
kScrollEventInterval
)
;
}
else
{
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mScrollWatchTimer
)
ScrollTimerCallback
this
kScrollEventInterval
nsITimer
:
:
TYPE_ONE_SHOT
"
a11y
:
:
DocAccessible
:
:
ScrollPositionDidChange
"
)
;
if
(
mScrollWatchTimer
)
{
NS_ADDREF_THIS
(
)
;
}
}
}
NS_IMETHODIMP
DocAccessible
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
obs_documentCreated
"
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
this
states
:
:
EDITABLE
true
)
;
FireDelayedEvent
(
event
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DocAccessible
:
:
OnPivotChanged
(
nsIAccessiblePivot
*
aPivot
nsIAccessible
*
aOldAccessible
int32_t
aOldStart
int32_t
aOldEnd
nsIAccessible
*
aNewAccessible
int32_t
aNewStart
int32_t
aNewEnd
PivotMoveReason
aReason
TextBoundaryType
aBoundaryType
bool
aIsFromUserInput
)
{
RefPtr
<
AccEvent
>
event
=
new
AccVCChangeEvent
(
this
(
aOldAccessible
?
aOldAccessible
-
>
ToInternalAccessible
(
)
:
nullptr
)
aOldStart
aOldEnd
(
aNewAccessible
?
aNewAccessible
-
>
ToInternalAccessible
(
)
:
nullptr
)
aNewStart
aNewEnd
aReason
aBoundaryType
aIsFromUserInput
?
eFromUserInput
:
eNoUserInput
)
;
nsEventShell
:
:
FireEvent
(
event
)
;
return
NS_OK
;
}
NS_IMPL_NSIDOCUMENTOBSERVER_CORE_STUB
(
DocAccessible
)
NS_IMPL_NSIDOCUMENTOBSERVER_LOAD_STUB
(
DocAccessible
)
void
DocAccessible
:
:
AttributeWillChange
(
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
Accessible
*
accessible
=
GetAccessible
(
aElement
)
;
if
(
!
accessible
)
{
if
(
aElement
!
=
mContent
)
return
;
accessible
=
this
;
}
if
(
aModType
!
=
dom
:
:
MutationEvent_Binding
:
:
ADDITION
)
RemoveDependentIDsFor
(
accessible
aAttribute
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
id
)
{
RelocateARIAOwnedIfNeeded
(
aElement
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_checked
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_pressed
)
{
mARIAAttrOldValue
=
(
aModType
!
=
dom
:
:
MutationEvent_Binding
:
:
ADDITION
)
?
nsAccUtils
:
:
GetARIAToken
(
aElement
aAttribute
)
:
nullptr
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_disabled
|
|
aAttribute
=
=
nsGkAtoms
:
:
disabled
)
mStateBitWasOn
=
accessible
-
>
Unavailable
(
)
;
}
void
DocAccessible
:
:
NativeAnonymousChildListChange
(
nsIContent
*
aContent
bool
aIsRemove
)
{
}
void
DocAccessible
:
:
AttributeChanged
(
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
NS_ASSERTION
(
!
IsDefunct
(
)
"
Attribute
changed
called
on
defunct
document
accessible
!
"
)
;
if
(
UpdateAccessibleOnAttrChange
(
aElement
aAttribute
)
)
return
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_hidden
)
{
if
(
aria
:
:
HasDefinedARIAHidden
(
aElement
)
)
{
ContentRemoved
(
aElement
)
;
}
else
{
ContentInserted
(
aElement
aElement
-
>
GetNextSibling
(
)
)
;
}
return
;
}
Accessible
*
accessible
=
GetAccessible
(
aElement
)
;
if
(
!
accessible
)
{
if
(
mContent
!
=
aElement
)
return
;
accessible
=
this
;
}
MOZ_ASSERT
(
accessible
-
>
IsBoundToParent
(
)
|
|
accessible
-
>
IsDoc
(
)
"
DOM
attribute
change
on
an
accessible
detached
from
the
tree
"
)
;
AttributeChangedImpl
(
accessible
aNameSpaceID
aAttribute
)
;
if
(
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
MODIFICATION
|
|
aModType
=
=
dom
:
:
MutationEvent_Binding
:
:
ADDITION
)
{
AddDependentIDsFor
(
accessible
aAttribute
)
;
}
}
void
DocAccessible
:
:
AttributeChangedImpl
(
Accessible
*
aAccessible
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
disabled
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_disabled
)
{
if
(
aAccessible
-
>
Unavailable
(
)
=
=
mStateBitWasOn
)
return
;
RefPtr
<
AccEvent
>
enabledChangeEvent
=
new
AccStateChangeEvent
(
aAccessible
states
:
:
ENABLED
mStateBitWasOn
)
;
FireDelayedEvent
(
enabledChangeEvent
)
;
RefPtr
<
AccEvent
>
sensitiveChangeEvent
=
new
AccStateChangeEvent
(
aAccessible
states
:
:
SENSITIVE
mStateBitWasOn
)
;
FireDelayedEvent
(
sensitiveChangeEvent
)
;
return
;
}
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
StringBeginsWith
(
nsDependentAtomString
(
aAttribute
)
NS_LITERAL_STRING
(
"
aria
-
"
)
)
)
{
ARIAAttributeChanged
(
aAccessible
aAttribute
)
;
}
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_label
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
aAccessible
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_describedby
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_DESCRIPTION_CHANGE
aAccessible
)
;
return
;
}
dom
:
:
Element
*
elm
=
aAccessible
-
>
GetContent
(
)
-
>
AsElement
(
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_labelledby
&
&
!
elm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_label
)
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
aAccessible
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
alt
&
&
!
elm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_label
)
&
&
!
elm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_labelledby
)
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
aAccessible
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
title
)
{
if
(
!
elm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_label
)
&
&
!
elm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_labelledby
)
&
&
!
elm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
alt
)
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
aAccessible
)
;
return
;
}
if
(
!
elm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_describedby
)
)
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_DESCRIPTION_CHANGE
aAccessible
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_busy
)
{
bool
isOn
=
elm
-
>
AttrValueIs
(
aNameSpaceID
aAttribute
nsGkAtoms
:
:
_true
eCaseMatters
)
;
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
aAccessible
states
:
:
BUSY
isOn
)
;
FireDelayedEvent
(
event
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
id
)
{
RelocateARIAOwnedIfNeeded
(
elm
)
;
ARIAActiveDescendantIDMaybeMoved
(
elm
)
;
}
if
(
(
aAccessible
-
>
GetContent
(
)
-
>
IsXULElement
(
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
selected
)
|
|
aAttribute
=
=
nsGkAtoms
:
:
aria_selected
)
{
Accessible
*
widget
=
nsAccUtils
:
:
GetSelectableContainer
(
aAccessible
aAccessible
-
>
State
(
)
)
;
if
(
widget
)
{
AccSelChangeEvent
:
:
SelChangeType
selChangeType
=
elm
-
>
AttrValueIs
(
aNameSpaceID
aAttribute
nsGkAtoms
:
:
_true
eCaseMatters
)
?
AccSelChangeEvent
:
:
eSelectionAdd
:
AccSelChangeEvent
:
:
eSelectionRemove
;
RefPtr
<
AccEvent
>
event
=
new
AccSelChangeEvent
(
widget
aAccessible
selChangeType
)
;
FireDelayedEvent
(
event
)
;
}
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
contenteditable
)
{
RefPtr
<
AccEvent
>
editableChangeEvent
=
new
AccStateChangeEvent
(
aAccessible
states
:
:
EDITABLE
)
;
FireDelayedEvent
(
editableChangeEvent
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
value
)
{
if
(
aAccessible
-
>
IsProgress
(
)
)
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
aAccessible
)
;
}
}
void
DocAccessible
:
:
ARIAAttributeChanged
(
Accessible
*
aAccessible
nsAtom
*
aAttribute
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_required
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
aAccessible
states
:
:
REQUIRED
)
;
FireDelayedEvent
(
event
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_invalid
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
aAccessible
states
:
:
INVALID
)
;
FireDelayedEvent
(
event
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_activedescendant
)
{
mNotificationController
-
>
ScheduleNotification
<
DocAccessible
Accessible
>
(
this
&
DocAccessible
:
:
ARIAActiveDescendantChanged
aAccessible
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_expanded
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
aAccessible
states
:
:
EXPANDED
)
;
FireDelayedEvent
(
event
)
;
return
;
}
uint8_t
attrFlags
=
aria
:
:
AttrCharacteristicsFor
(
aAttribute
)
;
if
(
!
(
attrFlags
&
ATTR_BYPASSOBJ
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccObjectAttrChangedEvent
(
aAccessible
aAttribute
)
;
FireDelayedEvent
(
event
)
;
}
dom
:
:
Element
*
elm
=
aAccessible
-
>
GetContent
(
)
-
>
AsElement
(
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_checked
|
|
(
aAccessible
-
>
IsButton
(
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
aria_pressed
)
)
{
const
uint64_t
kState
=
(
aAttribute
=
=
nsGkAtoms
:
:
aria_checked
)
?
states
:
:
CHECKED
:
states
:
:
PRESSED
;
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
aAccessible
kState
)
;
FireDelayedEvent
(
event
)
;
bool
wasMixed
=
(
mARIAAttrOldValue
=
=
nsGkAtoms
:
:
mixed
)
;
bool
isMixed
=
elm
-
>
AttrValueIs
(
kNameSpaceID_None
aAttribute
nsGkAtoms
:
:
mixed
eCaseMatters
)
;
if
(
isMixed
!
=
wasMixed
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
aAccessible
states
:
:
MIXED
isMixed
)
;
FireDelayedEvent
(
event
)
;
}
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_readonly
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
aAccessible
states
:
:
READONLY
)
;
FireDelayedEvent
(
event
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_valuetext
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_TEXT_VALUE_CHANGE
aAccessible
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_valuenow
&
&
(
!
elm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_valuetext
)
|
|
elm
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_valuetext
nsGkAtoms
:
:
_empty
eCaseMatters
)
)
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
aAccessible
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_current
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
aAccessible
states
:
:
CURRENT
)
;
FireDelayedEvent
(
event
)
;
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_owns
)
{
mNotificationController
-
>
ScheduleRelocation
(
aAccessible
)
;
}
}
void
DocAccessible
:
:
ARIAActiveDescendantChanged
(
Accessible
*
aAccessible
)
{
nsIContent
*
elm
=
aAccessible
-
>
GetContent
(
)
;
if
(
elm
&
&
elm
-
>
IsElement
(
)
&
&
aAccessible
-
>
IsActiveWidget
(
)
)
{
nsAutoString
id
;
if
(
elm
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_activedescendant
id
)
)
{
dom
:
:
Element
*
activeDescendantElm
=
elm
-
>
OwnerDoc
(
)
-
>
GetElementById
(
id
)
;
if
(
activeDescendantElm
)
{
Accessible
*
activeDescendant
=
GetAccessible
(
activeDescendantElm
)
;
if
(
activeDescendant
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
activeDescendant
false
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
logging
:
:
ActiveItemChangeCausedBy
(
"
ARIA
activedescedant
changed
"
activeDescendant
)
;
#
endif
return
;
}
}
}
FocusMgr
(
)
-
>
ActiveItemChanged
(
aAccessible
false
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
{
logging
:
:
ActiveItemChangeCausedBy
(
"
ARIA
activedescedant
cleared
"
aAccessible
)
;
}
#
endif
}
}
void
DocAccessible
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
}
void
DocAccessible
:
:
ContentStateChanged
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContent
EventStates
aStateMask
)
{
Accessible
*
accessible
=
GetAccessible
(
aContent
)
;
if
(
!
accessible
)
return
;
if
(
aStateMask
.
HasState
(
NS_EVENT_STATE_CHECKED
)
)
{
Accessible
*
widget
=
accessible
-
>
ContainerWidget
(
)
;
if
(
widget
&
&
widget
-
>
IsSelect
(
)
)
{
AccSelChangeEvent
:
:
SelChangeType
selChangeType
=
aContent
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_CHECKED
)
?
AccSelChangeEvent
:
:
eSelectionAdd
:
AccSelChangeEvent
:
:
eSelectionRemove
;
RefPtr
<
AccEvent
>
event
=
new
AccSelChangeEvent
(
widget
accessible
selChangeType
)
;
FireDelayedEvent
(
event
)
;
return
;
}
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
CHECKED
aContent
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_CHECKED
)
)
;
FireDelayedEvent
(
event
)
;
}
if
(
aStateMask
.
HasState
(
NS_EVENT_STATE_INVALID
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
INVALID
true
)
;
FireDelayedEvent
(
event
)
;
}
if
(
aStateMask
.
HasState
(
NS_EVENT_STATE_VISITED
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
accessible
states
:
:
TRAVERSED
true
)
;
FireDelayedEvent
(
event
)
;
}
}
void
DocAccessible
:
:
DocumentStatesChanged
(
dom
:
:
Document
*
aDocument
EventStates
aStateMask
)
{
}
void
DocAccessible
:
:
CharacterDataWillChange
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
}
void
DocAccessible
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
}
void
DocAccessible
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
}
void
DocAccessible
:
:
ContentRemoved
(
nsIContent
*
aChildNode
nsIContent
*
aPreviousSiblingNode
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
DOM
content
removed
;
doc
:
%
p
"
this
)
;
logging
:
:
Node
(
"
container
node
"
aChildNode
-
>
GetParent
(
)
)
;
logging
:
:
Node
(
"
content
node
"
aChildNode
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
ContentRemoved
(
aChildNode
)
;
}
void
DocAccessible
:
:
ParentChainChanged
(
nsIContent
*
aContent
)
{
}
#
ifdef
A11Y_LOG
nsresult
DocAccessible
:
:
HandleAccEvent
(
AccEvent
*
aEvent
)
{
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocLoad
)
)
logging
:
:
DocLoadEventHandled
(
aEvent
)
;
return
HyperTextAccessible
:
:
HandleAccEvent
(
aEvent
)
;
}
#
endif
void
*
DocAccessible
:
:
GetNativeWindow
(
)
const
{
if
(
!
mPresShell
)
return
nullptr
;
nsViewManager
*
vm
=
mPresShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
return
nullptr
;
nsCOMPtr
<
nsIWidget
>
widget
;
vm
-
>
GetRootWidget
(
getter_AddRefs
(
widget
)
)
;
if
(
widget
)
return
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
return
nullptr
;
}
Accessible
*
DocAccessible
:
:
GetAccessibleByUniqueIDInSubtree
(
void
*
aUniqueID
)
{
Accessible
*
child
=
GetAccessibleByUniqueID
(
aUniqueID
)
;
if
(
child
)
return
child
;
uint32_t
childDocCount
=
mChildDocuments
.
Length
(
)
;
for
(
uint32_t
childDocIdx
=
0
;
childDocIdx
<
childDocCount
;
childDocIdx
+
+
)
{
DocAccessible
*
childDocument
=
mChildDocuments
.
ElementAt
(
childDocIdx
)
;
child
=
childDocument
-
>
GetAccessibleByUniqueIDInSubtree
(
aUniqueID
)
;
if
(
child
)
return
child
;
}
return
nullptr
;
}
Accessible
*
DocAccessible
:
:
GetAccessibleOrContainer
(
nsINode
*
aNode
int
aARIAHiddenFlag
)
const
{
if
(
!
aNode
|
|
!
aNode
-
>
GetComposedDoc
(
)
)
{
return
nullptr
;
}
nsINode
*
currNode
=
nullptr
;
if
(
aNode
-
>
IsShadowRoot
(
)
)
{
const
dom
:
:
ShadowRoot
*
shadowRoot
=
dom
:
:
ShadowRoot
:
:
FromNode
(
aNode
)
;
currNode
=
shadowRoot
-
>
GetHost
(
)
;
if
(
!
currNode
)
{
return
nullptr
;
}
}
else
{
currNode
=
aNode
;
}
MOZ_ASSERT
(
currNode
)
;
for
(
;
currNode
;
currNode
=
currNode
-
>
GetFlattenedTreeParentNode
(
)
)
{
if
(
aARIAHiddenFlag
=
=
eNoContainerIfARIAHidden
&
&
currNode
-
>
IsElement
(
)
&
&
aria
:
:
HasDefinedARIAHidden
(
currNode
-
>
AsElement
(
)
)
)
{
return
nullptr
;
}
if
(
Accessible
*
accessible
=
GetAccessible
(
currNode
)
)
{
return
accessible
;
}
}
return
nullptr
;
}
Accessible
*
DocAccessible
:
:
GetAccessibleOrDescendant
(
nsINode
*
aNode
)
const
{
Accessible
*
acc
=
GetAccessible
(
aNode
)
;
if
(
acc
)
return
acc
;
acc
=
GetContainerAccessible
(
aNode
)
;
if
(
acc
)
{
uint32_t
childCnt
=
acc
-
>
ChildCount
(
)
;
for
(
uint32_t
idx
=
0
;
idx
<
childCnt
;
idx
+
+
)
{
Accessible
*
child
=
acc
-
>
GetChildAt
(
idx
)
;
for
(
nsIContent
*
elm
=
child
-
>
GetContent
(
)
;
elm
&
&
elm
!
=
acc
-
>
GetContent
(
)
;
elm
=
elm
-
>
GetFlattenedTreeParent
(
)
)
{
if
(
elm
=
=
aNode
)
return
child
;
}
}
}
return
nullptr
;
}
void
DocAccessible
:
:
BindToDocument
(
Accessible
*
aAccessible
const
nsRoleMapEntry
*
aRoleMapEntry
)
{
if
(
aAccessible
-
>
IsNodeMapEntry
(
)
)
mNodeToAccessibleMap
.
Put
(
aAccessible
-
>
GetNode
(
)
aAccessible
)
;
mAccessibleCache
.
Put
(
aAccessible
-
>
UniqueID
(
)
aAccessible
)
;
aAccessible
-
>
SetRoleMapEntry
(
aRoleMapEntry
)
;
if
(
aAccessible
-
>
HasOwnContent
(
)
)
{
AddDependentIDsFor
(
aAccessible
)
;
nsIContent
*
content
=
aAccessible
-
>
GetContent
(
)
;
if
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_owns
)
)
{
mNotificationController
-
>
ScheduleRelocation
(
aAccessible
)
;
}
}
}
void
DocAccessible
:
:
UnbindFromDocument
(
Accessible
*
aAccessible
)
{
NS_ASSERTION
(
mAccessibleCache
.
GetWeak
(
aAccessible
-
>
UniqueID
(
)
)
"
Unbinding
the
unbound
accessible
!
"
)
;
if
(
FocusMgr
(
)
-
>
IsActiveItem
(
aAccessible
)
)
{
FocusMgr
(
)
-
>
ActiveItemChanged
(
nullptr
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eFocus
)
)
logging
:
:
ActiveItemChangeCausedBy
(
"
tree
shutdown
"
aAccessible
)
;
#
endif
}
if
(
aAccessible
-
>
IsNodeMapEntry
(
)
&
&
mNodeToAccessibleMap
.
Get
(
aAccessible
-
>
GetNode
(
)
)
=
=
aAccessible
)
mNodeToAccessibleMap
.
Remove
(
aAccessible
-
>
GetNode
(
)
)
;
aAccessible
-
>
mStateFlags
|
=
eIsNotInDocument
;
xpcAccessibleDocument
*
xpcDoc
=
GetAccService
(
)
-
>
GetCachedXPCDocument
(
this
)
;
if
(
xpcDoc
)
xpcDoc
-
>
NotifyOfShutdown
(
aAccessible
)
;
void
*
uniqueID
=
aAccessible
-
>
UniqueID
(
)
;
NS_ASSERTION
(
!
aAccessible
-
>
IsDefunct
(
)
"
Shutdown
the
shutdown
accessible
!
"
)
;
aAccessible
-
>
Shutdown
(
)
;
mAccessibleCache
.
Remove
(
uniqueID
)
;
}
void
DocAccessible
:
:
ContentInserted
(
nsIContent
*
aStartChildNode
nsIContent
*
aEndChildNode
)
{
if
(
mNotificationController
&
&
HasLoadState
(
eTreeConstructed
)
)
{
mNotificationController
-
>
ScheduleContentInsertion
(
aStartChildNode
aEndChildNode
)
;
}
}
void
DocAccessible
:
:
RecreateAccessible
(
nsIContent
*
aContent
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
accessible
recreated
"
)
;
logging
:
:
Node
(
"
content
"
aContent
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
ContentRemoved
(
aContent
)
;
ContentInserted
(
aContent
aContent
-
>
GetNextSibling
(
)
)
;
}
void
DocAccessible
:
:
ProcessInvalidationList
(
)
{
for
(
uint32_t
idx
=
0
;
idx
<
mInvalidationList
.
Length
(
)
;
idx
+
+
)
{
nsIContent
*
content
=
mInvalidationList
[
idx
]
;
if
(
!
HasAccessible
(
content
)
&
&
content
-
>
HasID
(
)
)
{
Accessible
*
container
=
GetContainerAccessible
(
content
)
;
if
(
container
)
{
AttrRelProviders
*
list
=
GetRelProviders
(
content
-
>
AsElement
(
)
nsDependentAtomString
(
content
-
>
GetID
(
)
)
)
;
bool
shouldProcess
=
!
!
list
;
if
(
shouldProcess
)
{
for
(
uint32_t
idx
=
0
;
idx
<
list
-
>
Length
(
)
;
idx
+
+
)
{
if
(
list
-
>
ElementAt
(
idx
)
-
>
mRelAttr
=
=
nsGkAtoms
:
:
aria_owns
)
{
shouldProcess
=
false
;
break
;
}
}
if
(
shouldProcess
)
{
ProcessContentInserted
(
container
content
)
;
}
}
}
}
}
mInvalidationList
.
Clear
(
)
;
}
Accessible
*
DocAccessible
:
:
GetAccessibleEvenIfNotInMap
(
nsINode
*
aNode
)
const
{
if
(
!
aNode
-
>
IsContent
(
)
|
|
!
aNode
-
>
AsContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
return
GetAccessible
(
aNode
)
;
nsIFrame
*
frame
=
aNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
nsImageFrame
*
imageFrame
=
do_QueryFrame
(
frame
)
;
if
(
imageFrame
)
{
Accessible
*
parent
=
GetAccessible
(
imageFrame
-
>
GetContent
(
)
)
;
if
(
parent
)
{
Accessible
*
area
=
parent
-
>
AsImageMap
(
)
-
>
GetChildAccessibleFor
(
aNode
)
;
if
(
area
)
return
area
;
return
nullptr
;
}
}
return
GetAccessible
(
aNode
)
;
}
void
DocAccessible
:
:
NotifyOfLoading
(
bool
aIsReloading
)
{
mLoadState
&
=
~
eDOMLoaded
;
if
(
!
IsLoadEventTarget
(
)
)
return
;
if
(
aIsReloading
&
&
!
mLoadEventType
)
{
RefPtr
<
AccEvent
>
reloadEvent
=
new
AccEvent
(
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_RELOAD
this
)
;
nsEventShell
:
:
FireEvent
(
reloadEvent
)
;
}
RefPtr
<
AccEvent
>
stateEvent
=
new
AccStateChangeEvent
(
this
states
:
:
BUSY
true
)
;
FireDelayedEvent
(
stateEvent
)
;
}
void
DocAccessible
:
:
DoInitialUpdate
(
)
{
if
(
nsCoreUtils
:
:
IsTabDocument
(
mDocumentNode
)
)
{
mDocFlags
|
=
eTabDocument
;
if
(
IPCAccessibilityActive
(
)
)
{
nsIDocShell
*
docShell
=
mDocumentNode
-
>
GetDocShell
(
)
;
if
(
RefPtr
<
dom
:
:
TabChild
>
tabChild
=
dom
:
:
TabChild
:
:
GetFrom
(
docShell
)
)
{
DocAccessibleChild
*
ipcDoc
=
IPCDoc
(
)
;
if
(
!
ipcDoc
)
{
ipcDoc
=
new
DocAccessibleChild
(
this
tabChild
)
;
SetIPCDoc
(
ipcDoc
)
;
#
if
defined
(
XP_WIN
)
IAccessibleHolder
holder
(
CreateHolderFromAccessible
(
WrapNotNull
(
this
)
)
)
;
MOZ_ASSERT
(
!
holder
.
IsNull
(
)
)
;
int32_t
childID
=
AccessibleWrap
:
:
GetChildIDFor
(
this
)
;
#
else
int32_t
holder
=
0
childID
=
0
;
#
endif
tabChild
-
>
SendPDocAccessibleConstructor
(
ipcDoc
nullptr
0
childID
holder
)
;
}
if
(
IsRoot
(
)
)
{
tabChild
-
>
SetTopLevelDocAccessibleChild
(
ipcDoc
)
;
}
}
}
}
mLoadState
|
=
eTreeConstructed
;
UpdateRootElIfNeeded
(
)
;
CacheChildrenInSubtree
(
this
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eVerbose
)
)
{
logging
:
:
Tree
(
"
TREE
"
"
Initial
subtree
"
this
)
;
}
#
endif
if
(
!
IsRoot
(
)
)
{
RefPtr
<
AccReorderEvent
>
reorderEvent
=
new
AccReorderEvent
(
Parent
(
)
)
;
ParentDocument
(
)
-
>
FireDelayedEvent
(
reorderEvent
)
;
}
if
(
IPCAccessibilityActive
(
)
)
{
DocAccessibleChild
*
ipcDoc
=
IPCDoc
(
)
;
MOZ_ASSERT
(
ipcDoc
)
;
if
(
ipcDoc
)
{
for
(
auto
idx
=
0U
;
idx
<
mChildren
.
Length
(
)
;
idx
+
+
)
{
ipcDoc
-
>
InsertIntoIpcTree
(
this
mChildren
.
ElementAt
(
idx
)
idx
)
;
}
}
}
}
void
DocAccessible
:
:
ProcessLoad
(
)
{
mLoadState
|
=
eCompletelyLoaded
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocLoad
)
)
logging
:
:
DocCompleteLoad
(
this
IsLoadEventTarget
(
)
)
;
#
endif
if
(
!
IsLoadEventTarget
(
)
)
return
;
if
(
mLoadEventType
)
{
RefPtr
<
AccEvent
>
loadEvent
=
new
AccEvent
(
mLoadEventType
this
)
;
FireDelayedEvent
(
loadEvent
)
;
mLoadEventType
=
0
;
}
RefPtr
<
AccEvent
>
stateEvent
=
new
AccStateChangeEvent
(
this
states
:
:
BUSY
false
)
;
FireDelayedEvent
(
stateEvent
)
;
}
void
DocAccessible
:
:
AddDependentIDsFor
(
Accessible
*
aRelProvider
nsAtom
*
aRelAttr
)
{
dom
:
:
Element
*
relProviderEl
=
aRelProvider
-
>
Elm
(
)
;
if
(
!
relProviderEl
)
return
;
for
(
uint32_t
idx
=
0
;
idx
<
kRelationAttrsLen
;
idx
+
+
)
{
nsStaticAtom
*
relAttr
=
kRelationAttrs
[
idx
]
;
if
(
aRelAttr
&
&
aRelAttr
!
=
relAttr
)
continue
;
if
(
relAttr
=
=
nsGkAtoms
:
:
_for
)
{
if
(
!
relProviderEl
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
label
nsGkAtoms
:
:
output
)
)
continue
;
}
else
if
(
relAttr
=
=
nsGkAtoms
:
:
control
)
{
if
(
!
relProviderEl
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
label
nsGkAtoms
:
:
description
)
)
continue
;
}
IDRefsIterator
iter
(
this
relProviderEl
relAttr
)
;
while
(
true
)
{
const
nsDependentSubstring
id
=
iter
.
NextID
(
)
;
if
(
id
.
IsEmpty
(
)
)
break
;
nsIContent
*
dependentContent
=
iter
.
GetElem
(
id
)
;
if
(
!
dependentContent
|
|
(
relAttr
=
=
nsGkAtoms
:
:
aria_owns
&
&
!
aRelProvider
-
>
IsAcceptableChild
(
dependentContent
)
)
)
continue
;
AttrRelProviders
*
providers
=
GetOrCreateRelProviders
(
dependentContent
-
>
AsElement
(
)
id
)
;
if
(
providers
)
{
AttrRelProvider
*
provider
=
new
AttrRelProvider
(
relAttr
relProviderEl
)
;
if
(
provider
)
{
providers
-
>
AppendElement
(
provider
)
;
if
(
dependentContent
)
{
if
(
!
HasAccessible
(
dependentContent
)
)
{
mInvalidationList
.
AppendElement
(
dependentContent
)
;
}
}
}
}
}
if
(
aRelAttr
)
break
;
}
mNotificationController
-
>
ScheduleProcessing
(
)
;
}
void
DocAccessible
:
:
RemoveDependentIDsFor
(
Accessible
*
aRelProvider
nsAtom
*
aRelAttr
)
{
dom
:
:
Element
*
relProviderElm
=
aRelProvider
-
>
Elm
(
)
;
if
(
!
relProviderElm
)
return
;
for
(
uint32_t
idx
=
0
;
idx
<
kRelationAttrsLen
;
idx
+
+
)
{
nsStaticAtom
*
relAttr
=
kRelationAttrs
[
idx
]
;
if
(
aRelAttr
&
&
aRelAttr
!
=
kRelationAttrs
[
idx
]
)
continue
;
IDRefsIterator
iter
(
this
relProviderElm
relAttr
)
;
while
(
true
)
{
const
nsDependentSubstring
id
=
iter
.
NextID
(
)
;
if
(
id
.
IsEmpty
(
)
)
break
;
AttrRelProviders
*
providers
=
GetRelProviders
(
relProviderElm
id
)
;
if
(
providers
)
{
for
(
uint32_t
jdx
=
0
;
jdx
<
providers
-
>
Length
(
)
;
)
{
AttrRelProvider
*
provider
=
(
*
providers
)
[
jdx
]
;
if
(
provider
-
>
mRelAttr
=
=
relAttr
&
&
provider
-
>
mContent
=
=
relProviderElm
)
providers
-
>
RemoveElement
(
provider
)
;
else
jdx
+
+
;
}
RemoveRelProvidersIfEmpty
(
relProviderElm
id
)
;
}
}
if
(
aRelAttr
)
break
;
}
}
bool
DocAccessible
:
:
UpdateAccessibleOnAttrChange
(
dom
:
:
Element
*
aElement
nsAtom
*
aAttribute
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
role
)
{
if
(
mContent
=
=
aElement
)
{
SetRoleMapEntry
(
aria
:
:
GetRoleMap
(
aElement
)
)
;
if
(
mIPCDoc
)
{
mIPCDoc
-
>
SendRoleChangedEvent
(
Role
(
)
)
;
}
return
true
;
}
RecreateAccessible
(
aElement
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
href
)
{
RecreateAccessible
(
aElement
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
aria_multiselectable
&
&
aElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
role
)
)
{
RecreateAccessible
(
aElement
)
;
return
true
;
}
return
false
;
}
void
DocAccessible
:
:
UpdateRootElIfNeeded
(
)
{
dom
:
:
Element
*
rootEl
=
mDocumentNode
-
>
GetBodyElement
(
)
;
if
(
!
rootEl
)
{
rootEl
=
mDocumentNode
-
>
GetRootElement
(
)
;
}
if
(
rootEl
!
=
mContent
)
{
mContent
=
rootEl
;
SetRoleMapEntry
(
aria
:
:
GetRoleMap
(
rootEl
)
)
;
if
(
mIPCDoc
)
{
mIPCDoc
-
>
SendRoleChangedEvent
(
Role
(
)
)
;
}
}
}
class
InsertIterator
final
{
public
:
InsertIterator
(
Accessible
*
aContext
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
aNodes
)
:
mChild
(
nullptr
)
mChildBefore
(
nullptr
)
mWalker
(
aContext
)
mNodes
(
aNodes
)
mNodesIdx
(
0
)
{
MOZ_ASSERT
(
aContext
"
No
context
"
)
;
MOZ_ASSERT
(
aNodes
"
No
nodes
to
search
for
accessible
elements
"
)
;
MOZ_COUNT_CTOR
(
InsertIterator
)
;
}
~
InsertIterator
(
)
{
MOZ_COUNT_DTOR
(
InsertIterator
)
;
}
Accessible
*
Context
(
)
const
{
return
mWalker
.
Context
(
)
;
}
Accessible
*
Child
(
)
const
{
return
mChild
;
}
Accessible
*
ChildBefore
(
)
const
{
return
mChildBefore
;
}
DocAccessible
*
Document
(
)
const
{
return
mWalker
.
Document
(
)
;
}
bool
Next
(
)
;
void
Rejected
(
)
{
mChild
=
nullptr
;
mChildBefore
=
nullptr
;
}
private
:
Accessible
*
mChild
;
Accessible
*
mChildBefore
;
TreeWalker
mWalker
;
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
mNodes
;
uint32_t
mNodesIdx
;
}
;
bool
InsertIterator
:
:
Next
(
)
{
if
(
mNodesIdx
>
0
)
{
Accessible
*
nextChild
=
mWalker
.
Next
(
)
;
if
(
nextChild
)
{
mChildBefore
=
mChild
;
mChild
=
nextChild
;
return
true
;
}
}
while
(
mNodesIdx
<
mNodes
-
>
Length
(
)
)
{
nsIContent
*
prevNode
=
mNodes
-
>
SafeElementAt
(
mNodesIdx
-
1
)
;
nsIContent
*
node
=
mNodes
-
>
ElementAt
(
mNodesIdx
+
+
)
;
Accessible
*
container
=
Document
(
)
-
>
AccessibleOrTrueContainer
(
node
DocAccessible
:
:
eNoContainerIfARIAHidden
)
;
if
(
container
!
=
Context
(
)
)
{
continue
;
}
if
(
container
-
>
IsHTMLCombobox
(
)
)
{
container
=
container
-
>
FirstChild
(
)
;
}
if
(
!
container
-
>
IsAcceptableChild
(
node
)
)
{
continue
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
traversing
an
inserted
node
"
logging
:
:
eVerbose
"
container
"
container
"
node
"
node
)
;
#
endif
if
(
mChild
&
&
prevNode
&
&
prevNode
-
>
GetNextSibling
(
)
=
=
node
)
{
Accessible
*
nextChild
=
mWalker
.
Scope
(
node
)
;
if
(
nextChild
)
{
mChildBefore
=
mChild
;
mChild
=
nextChild
;
return
true
;
}
}
else
{
TreeWalker
finder
(
container
)
;
if
(
finder
.
Seek
(
node
)
)
{
mChild
=
mWalker
.
Scope
(
node
)
;
if
(
mChild
)
{
MOZ_ASSERT
(
!
mChild
-
>
IsRelocated
(
)
"
child
cannot
be
aria
owned
"
)
;
mChildBefore
=
finder
.
Prev
(
)
;
return
true
;
}
}
}
}
return
false
;
}
void
DocAccessible
:
:
ProcessContentInserted
(
Accessible
*
aContainer
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
aNodes
)
{
if
(
!
aContainer
-
>
IsInDocument
(
)
)
{
return
;
}
if
(
aContainer
=
=
this
)
{
UpdateRootElIfNeeded
(
)
;
}
InsertIterator
iter
(
aContainer
aNodes
)
;
if
(
!
iter
.
Next
(
)
)
{
return
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
children
before
insertion
"
logging
:
:
eVerbose
aContainer
)
;
#
endif
TreeMutation
mt
(
aContainer
)
;
do
{
Accessible
*
parent
=
iter
.
Child
(
)
-
>
Parent
(
)
;
if
(
parent
)
{
if
(
parent
!
=
aContainer
)
{
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
stealing
accessible
"
0
"
old
parent
"
parent
"
new
parent
"
aContainer
"
child
"
iter
.
Child
(
)
nullptr
)
;
#
endif
MOZ_ASSERT_UNREACHABLE
(
"
stealing
accessible
"
)
;
continue
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
binding
to
same
parent
"
logging
:
:
eVerbose
"
parent
"
aContainer
"
child
"
iter
.
Child
(
)
nullptr
)
;
#
endif
continue
;
}
if
(
aContainer
-
>
InsertAfter
(
iter
.
Child
(
)
iter
.
ChildBefore
(
)
)
)
{
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
accessible
was
inserted
"
0
"
container
"
aContainer
"
child
"
iter
.
Child
(
)
nullptr
)
;
#
endif
CreateSubtree
(
iter
.
Child
(
)
)
;
mt
.
AfterInsertion
(
iter
.
Child
(
)
)
;
continue
;
}
MOZ_ASSERT_UNREACHABLE
(
"
accessible
was
rejected
"
)
;
iter
.
Rejected
(
)
;
}
while
(
iter
.
Next
(
)
)
;
mt
.
Done
(
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
children
after
insertion
"
logging
:
:
eVerbose
aContainer
)
;
#
endif
FireEventsOnInsertion
(
aContainer
)
;
}
void
DocAccessible
:
:
ProcessContentInserted
(
Accessible
*
aContainer
nsIContent
*
aNode
)
{
if
(
!
aContainer
-
>
IsInDocument
(
)
)
{
return
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
children
before
insertion
"
logging
:
:
eVerbose
aContainer
)
;
#
endif
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
traversing
an
inserted
node
"
logging
:
:
eVerbose
"
container
"
aContainer
"
node
"
aNode
)
;
#
endif
TreeWalker
walker
(
aContainer
)
;
if
(
aContainer
-
>
IsAcceptableChild
(
aNode
)
&
&
walker
.
Seek
(
aNode
)
)
{
Accessible
*
child
=
GetAccessible
(
aNode
)
;
if
(
!
child
)
{
child
=
GetAccService
(
)
-
>
CreateAccessible
(
aNode
aContainer
)
;
}
if
(
child
)
{
TreeMutation
mt
(
aContainer
)
;
if
(
!
aContainer
-
>
InsertAfter
(
child
walker
.
Prev
(
)
)
)
{
return
;
}
CreateSubtree
(
child
)
;
mt
.
AfterInsertion
(
child
)
;
mt
.
Done
(
)
;
FireEventsOnInsertion
(
aContainer
)
;
}
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
children
after
insertion
"
logging
:
:
eVerbose
aContainer
)
;
#
endif
}
void
DocAccessible
:
:
FireEventsOnInsertion
(
Accessible
*
aContainer
)
{
if
(
aContainer
-
>
IsAlert
(
)
|
|
aContainer
-
>
IsInsideAlert
(
)
)
{
Accessible
*
ancestor
=
aContainer
;
do
{
if
(
ancestor
-
>
IsAlert
(
)
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_ALERT
ancestor
)
;
break
;
}
}
while
(
(
ancestor
=
ancestor
-
>
Parent
(
)
)
)
;
}
}
void
DocAccessible
:
:
ContentRemoved
(
Accessible
*
aChild
)
{
Accessible
*
parent
=
aChild
-
>
Parent
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
parent
"
Unattached
accessible
from
tree
"
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
process
content
removal
"
0
"
container
"
parent
"
child
"
aChild
nullptr
)
;
#
endif
RefPtr
<
Accessible
>
kungFuDeathGripChild
(
aChild
)
;
TreeMutation
mt
(
parent
)
;
mt
.
BeforeRemoval
(
aChild
)
;
if
(
aChild
-
>
IsDefunct
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Event
coalescence
killed
the
accessible
"
)
;
mt
.
Done
(
)
;
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aChild
-
>
Parent
(
)
"
Alive
but
unparented
#
1
"
)
;
if
(
aChild
-
>
IsRelocated
(
)
)
{
nsTArray
<
RefPtr
<
Accessible
>
>
*
owned
=
mARIAOwnsHash
.
Get
(
parent
)
;
MOZ_ASSERT
(
owned
"
IsRelocated
flag
is
out
of
sync
with
mARIAOwnsHash
"
)
;
owned
-
>
RemoveElement
(
aChild
)
;
if
(
owned
-
>
Length
(
)
=
=
0
)
{
mARIAOwnsHash
.
Remove
(
parent
)
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
aChild
-
>
Parent
(
)
"
Unparented
#
2
"
)
;
parent
-
>
RemoveChild
(
aChild
)
;
UncacheChildrenInSubtree
(
aChild
)
;
mt
.
Done
(
)
;
}
void
DocAccessible
:
:
ContentRemoved
(
nsIContent
*
aContentNode
)
{
Accessible
*
acc
=
GetAccessible
(
aContentNode
)
;
if
(
acc
)
{
ContentRemoved
(
acc
)
;
}
dom
:
:
AllChildrenIterator
iter
=
dom
:
:
AllChildrenIterator
(
aContentNode
nsIContent
:
:
eAllChildren
true
)
;
while
(
nsIContent
*
childNode
=
iter
.
GetNextChild
(
)
)
{
ContentRemoved
(
childNode
)
;
}
}
bool
DocAccessible
:
:
RelocateARIAOwnedIfNeeded
(
nsIContent
*
aElement
)
{
if
(
!
aElement
-
>
HasID
(
)
)
return
false
;
AttrRelProviders
*
list
=
GetRelProviders
(
aElement
-
>
AsElement
(
)
nsDependentAtomString
(
aElement
-
>
GetID
(
)
)
)
;
if
(
list
)
{
for
(
uint32_t
idx
=
0
;
idx
<
list
-
>
Length
(
)
;
idx
+
+
)
{
if
(
list
-
>
ElementAt
(
idx
)
-
>
mRelAttr
=
=
nsGkAtoms
:
:
aria_owns
)
{
Accessible
*
owner
=
GetAccessible
(
list
-
>
ElementAt
(
idx
)
-
>
mContent
)
;
if
(
owner
)
{
mNotificationController
-
>
ScheduleRelocation
(
owner
)
;
return
true
;
}
}
}
}
return
false
;
}
void
DocAccessible
:
:
DoARIAOwnsRelocation
(
Accessible
*
aOwner
)
{
MOZ_ASSERT
(
aOwner
"
aOwner
must
be
a
valid
pointer
"
)
;
MOZ_ASSERT
(
aOwner
-
>
Elm
(
)
"
aOwner
-
>
Elm
(
)
must
be
a
valid
pointer
"
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
aria
owns
relocation
"
logging
:
:
eVerbose
aOwner
)
;
#
endif
nsTArray
<
RefPtr
<
Accessible
>
>
*
owned
=
mARIAOwnsHash
.
LookupOrAdd
(
aOwner
)
;
IDRefsIterator
iter
(
this
aOwner
-
>
Elm
(
)
nsGkAtoms
:
:
aria_owns
)
;
uint32_t
idx
=
0
;
while
(
nsIContent
*
childEl
=
iter
.
NextElem
(
)
)
{
Accessible
*
child
=
GetAccessible
(
childEl
)
;
auto
insertIdx
=
aOwner
-
>
ChildCount
(
)
-
owned
-
>
Length
(
)
+
idx
;
if
(
!
child
)
{
if
(
nsContentUtils
:
:
ContentIsDescendantOf
(
aOwner
-
>
Elm
(
)
childEl
)
)
{
continue
;
}
if
(
aOwner
-
>
IsAcceptableChild
(
childEl
)
)
{
child
=
GetAccService
(
)
-
>
CreateAccessible
(
childEl
aOwner
)
;
if
(
child
)
{
TreeMutation
imut
(
aOwner
)
;
aOwner
-
>
InsertChildAt
(
insertIdx
child
)
;
imut
.
AfterInsertion
(
child
)
;
imut
.
Done
(
)
;
child
-
>
SetRelocated
(
true
)
;
owned
-
>
InsertElementAt
(
idx
child
)
;
idx
+
+
;
CreateSubtree
(
child
)
;
FireEventsOnInsertion
(
aOwner
)
;
}
}
continue
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
aria
owns
traversal
"
logging
:
:
eVerbose
"
candidate
"
child
nullptr
)
;
#
endif
if
(
owned
-
>
IndexOf
(
child
)
<
idx
)
{
continue
;
}
if
(
child
-
>
Parent
(
)
=
=
aOwner
)
{
int32_t
indexInParent
=
child
-
>
IndexInParent
(
)
;
if
(
indexInParent
=
=
static_cast
<
int32_t
>
(
insertIdx
)
)
{
MOZ_ASSERT
(
child
-
>
IsRelocated
(
)
"
A
child
having
an
index
in
parent
from
aria
ownded
"
"
indices
range
has
to
be
aria
owned
"
)
;
MOZ_ASSERT
(
owned
-
>
ElementAt
(
idx
)
=
=
child
"
Unexpected
child
in
ARIA
owned
array
"
)
;
idx
+
+
;
continue
;
}
if
(
indexInParent
=
=
static_cast
<
int32_t
>
(
insertIdx
)
-
1
)
{
MOZ_ASSERT
(
!
child
-
>
IsRelocated
(
)
"
Child
should
be
in
its
ordinal
position
"
)
;
child
-
>
SetRelocated
(
true
)
;
owned
-
>
InsertElementAt
(
idx
child
)
;
idx
+
+
;
continue
;
}
}
MOZ_ASSERT
(
owned
-
>
SafeElementAt
(
idx
)
!
=
child
"
Already
in
place
!
"
)
;
if
(
child
-
>
Parent
(
)
!
=
aOwner
)
{
if
(
child
-
>
IsRelocated
(
)
)
{
continue
;
}
Accessible
*
parent
=
aOwner
;
while
(
parent
&
&
parent
!
=
child
&
&
!
parent
-
>
IsDoc
(
)
)
{
parent
=
parent
-
>
Parent
(
)
;
}
if
(
parent
=
=
child
)
{
continue
;
}
}
if
(
MoveChild
(
child
aOwner
insertIdx
)
)
{
child
-
>
SetRelocated
(
true
)
;
MOZ_ASSERT
(
owned
=
=
mARIAOwnsHash
.
Get
(
aOwner
)
)
;
owned
=
mARIAOwnsHash
.
LookupOrAdd
(
aOwner
)
;
owned
-
>
InsertElementAt
(
idx
child
)
;
idx
+
+
;
}
}
PutChildrenBack
(
owned
idx
)
;
if
(
owned
-
>
Length
(
)
=
=
0
)
{
mARIAOwnsHash
.
Remove
(
aOwner
)
;
}
}
void
DocAccessible
:
:
PutChildrenBack
(
nsTArray
<
RefPtr
<
Accessible
>
>
*
aChildren
uint32_t
aStartIdx
)
{
MOZ_ASSERT
(
aStartIdx
<
=
aChildren
-
>
Length
(
)
"
Wrong
removal
index
"
)
;
for
(
auto
idx
=
aStartIdx
;
idx
<
aChildren
-
>
Length
(
)
;
idx
+
+
)
{
Accessible
*
child
=
aChildren
-
>
ElementAt
(
idx
)
;
if
(
!
child
-
>
IsInDocument
(
)
)
{
continue
;
}
Accessible
*
owner
=
child
-
>
Parent
(
)
;
if
(
!
owner
)
{
NS_ERROR
(
"
Cannot
put
the
child
back
.
No
parent
a
broken
tree
.
"
)
;
continue
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
aria
owns
put
child
back
"
0
"
old
parent
"
owner
"
child
"
child
nullptr
)
;
#
endif
child
-
>
SetRelocated
(
false
)
;
nsIContent
*
content
=
child
-
>
GetContent
(
)
;
int32_t
idxInParent
=
-
1
;
Accessible
*
origContainer
=
AccessibleOrTrueContainer
(
content
-
>
GetFlattenedTreeParentNode
(
)
)
;
if
(
origContainer
)
{
TreeWalker
walker
(
origContainer
)
;
if
(
walker
.
Seek
(
content
)
)
{
Accessible
*
prevChild
=
walker
.
Prev
(
)
;
if
(
prevChild
)
{
idxInParent
=
prevChild
-
>
IndexInParent
(
)
+
1
;
MOZ_DIAGNOSTIC_ASSERT
(
origContainer
=
=
prevChild
-
>
Parent
(
)
"
Broken
tree
"
)
;
origContainer
=
prevChild
-
>
Parent
(
)
;
}
else
{
idxInParent
=
0
;
}
}
}
if
(
origContainer
!
=
owner
|
|
child
-
>
IndexInParent
(
)
!
=
idxInParent
)
{
DebugOnly
<
bool
>
moved
=
MoveChild
(
child
origContainer
idxInParent
)
;
MOZ_ASSERT
(
moved
"
Failed
to
put
child
back
.
"
)
;
}
else
{
MOZ_ASSERT
(
!
child
-
>
PrevSibling
(
)
|
|
!
child
-
>
PrevSibling
(
)
-
>
IsRelocated
(
)
"
No
relocated
child
should
appear
before
this
one
"
)
;
MOZ_ASSERT
(
!
child
-
>
NextSibling
(
)
|
|
child
-
>
NextSibling
(
)
-
>
IsRelocated
(
)
"
No
ordinal
child
should
appear
after
this
one
"
)
;
}
}
aChildren
-
>
RemoveElementsAt
(
aStartIdx
aChildren
-
>
Length
(
)
-
aStartIdx
)
;
}
bool
DocAccessible
:
:
MoveChild
(
Accessible
*
aChild
Accessible
*
aNewParent
int32_t
aIdxInParent
)
{
MOZ_ASSERT
(
aChild
"
No
child
"
)
;
MOZ_ASSERT
(
aChild
-
>
Parent
(
)
"
No
parent
"
)
;
MOZ_ASSERT
(
aIdxInParent
<
=
static_cast
<
int32_t
>
(
aNewParent
-
>
ChildCount
(
)
)
"
Wrong
insertion
point
for
a
moving
child
"
)
;
Accessible
*
curParent
=
aChild
-
>
Parent
(
)
;
if
(
!
aNewParent
-
>
IsAcceptableChild
(
aChild
-
>
GetContent
(
)
)
)
{
return
false
;
}
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
move
child
"
0
"
old
parent
"
curParent
"
new
parent
"
aNewParent
"
child
"
aChild
nullptr
)
;
#
endif
if
(
aChild
-
>
IsRelocated
(
)
)
{
aChild
-
>
SetRelocated
(
false
)
;
nsTArray
<
RefPtr
<
Accessible
>
>
*
owned
=
mARIAOwnsHash
.
Get
(
curParent
)
;
MOZ_ASSERT
(
owned
"
IsRelocated
flag
is
out
of
sync
with
mARIAOwnsHash
"
)
;
owned
-
>
RemoveElement
(
aChild
)
;
if
(
owned
-
>
Length
(
)
=
=
0
)
{
mARIAOwnsHash
.
Remove
(
curParent
)
;
}
}
NotificationController
:
:
MoveGuard
mguard
(
mNotificationController
)
;
if
(
curParent
=
=
aNewParent
)
{
MOZ_ASSERT
(
aChild
-
>
IndexInParent
(
)
!
=
aIdxInParent
"
No
move
case
"
)
;
curParent
-
>
MoveChild
(
aIdxInParent
aChild
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
move
child
:
parent
tree
after
"
logging
:
:
eVerbose
curParent
)
;
#
endif
return
true
;
}
MOZ_ASSERT
(
aIdxInParent
<
=
static_cast
<
int32_t
>
(
aNewParent
-
>
ChildCount
(
)
)
"
Wrong
insertion
point
for
a
moving
child
"
)
;
bool
hasInsertionPoint
=
(
aIdxInParent
!
=
-
1
)
|
|
(
aIdxInParent
<
=
static_cast
<
int32_t
>
(
aNewParent
-
>
ChildCount
(
)
)
)
;
TreeMutation
rmut
(
curParent
)
;
rmut
.
BeforeRemoval
(
aChild
hasInsertionPoint
&
&
TreeMutation
:
:
kNoShutdown
)
;
curParent
-
>
RemoveChild
(
aChild
)
;
rmut
.
Done
(
)
;
if
(
!
hasInsertionPoint
)
{
return
true
;
}
TreeMutation
imut
(
aNewParent
)
;
aNewParent
-
>
InsertChildAt
(
aIdxInParent
aChild
)
;
imut
.
AfterInsertion
(
aChild
)
;
imut
.
Done
(
)
;
#
ifdef
A11Y_LOG
logging
:
:
TreeInfo
(
"
move
child
:
old
parent
tree
after
"
logging
:
:
eVerbose
curParent
)
;
logging
:
:
TreeInfo
(
"
move
child
:
new
parent
tree
after
"
logging
:
:
eVerbose
aNewParent
)
;
#
endif
return
true
;
}
void
DocAccessible
:
:
CacheChildrenInSubtree
(
Accessible
*
aRoot
Accessible
*
*
aFocusedAcc
)
{
if
(
aFocusedAcc
&
&
!
*
aFocusedAcc
&
&
FocusMgr
(
)
-
>
HasDOMFocus
(
aRoot
-
>
GetContent
(
)
)
)
*
aFocusedAcc
=
aRoot
;
Accessible
*
root
=
aRoot
-
>
IsHTMLCombobox
(
)
?
aRoot
-
>
FirstChild
(
)
:
aRoot
;
if
(
root
-
>
KidsFromDOM
(
)
)
{
TreeMutation
mt
(
root
TreeMutation
:
:
kNoEvents
)
;
TreeWalker
walker
(
root
)
;
while
(
Accessible
*
child
=
walker
.
Next
(
)
)
{
if
(
child
-
>
IsBoundToParent
(
)
)
{
MoveChild
(
child
root
root
-
>
ChildCount
(
)
)
;
continue
;
}
root
-
>
AppendChild
(
child
)
;
mt
.
AfterInsertion
(
child
)
;
CacheChildrenInSubtree
(
child
aFocusedAcc
)
;
}
mt
.
Done
(
)
;
}
if
(
!
aRoot
-
>
HasARIARole
(
)
)
{
return
;
}
roles
:
:
Role
role
=
aRoot
-
>
ARIARole
(
)
;
if
(
!
aRoot
-
>
IsDoc
(
)
&
&
(
role
=
=
roles
:
:
DIALOG
|
|
role
=
=
roles
:
:
NON_NATIVE_DOCUMENT
)
)
{
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_LOAD_COMPLETE
aRoot
)
;
}
}
void
DocAccessible
:
:
UncacheChildrenInSubtree
(
Accessible
*
aRoot
)
{
aRoot
-
>
mStateFlags
|
=
eIsNotInDocument
;
RemoveDependentIDsFor
(
aRoot
)
;
nsTArray
<
RefPtr
<
Accessible
>
>
*
owned
=
mARIAOwnsHash
.
Get
(
aRoot
)
;
uint32_t
count
=
aRoot
-
>
ContentChildCount
(
)
;
for
(
uint32_t
idx
=
0
;
idx
<
count
;
idx
+
+
)
{
Accessible
*
child
=
aRoot
-
>
ContentChildAt
(
idx
)
;
if
(
child
-
>
IsRelocated
(
)
)
{
MOZ_ASSERT
(
owned
"
IsRelocated
flag
is
out
of
sync
with
mARIAOwnsHash
"
)
;
owned
-
>
RemoveElement
(
child
)
;
if
(
owned
-
>
Length
(
)
=
=
0
)
{
mARIAOwnsHash
.
Remove
(
aRoot
)
;
owned
=
nullptr
;
}
}
if
(
!
child
-
>
IsDoc
(
)
)
{
UncacheChildrenInSubtree
(
child
)
;
}
}
if
(
aRoot
-
>
IsNodeMapEntry
(
)
&
&
mNodeToAccessibleMap
.
Get
(
aRoot
-
>
GetNode
(
)
)
=
=
aRoot
)
mNodeToAccessibleMap
.
Remove
(
aRoot
-
>
GetNode
(
)
)
;
}
void
DocAccessible
:
:
ShutdownChildrenInSubtree
(
Accessible
*
aAccessible
)
{
uint32_t
count
=
aAccessible
-
>
ContentChildCount
(
)
;
for
(
uint32_t
idx
=
0
jdx
=
0
;
idx
<
count
;
idx
+
+
)
{
Accessible
*
child
=
aAccessible
-
>
ContentChildAt
(
jdx
)
;
if
(
!
child
-
>
IsBoundToParent
(
)
)
{
NS_ERROR
(
"
Parent
refers
to
a
child
child
doesn
'
t
refer
to
parent
!
"
)
;
jdx
+
+
;
}
if
(
!
child
-
>
IsDoc
(
)
)
ShutdownChildrenInSubtree
(
child
)
;
}
UnbindFromDocument
(
aAccessible
)
;
}
bool
DocAccessible
:
:
IsLoadEventTarget
(
)
const
{
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
=
mDocumentNode
-
>
GetDocShell
(
)
;
NS_ASSERTION
(
treeItem
"
No
document
shell
for
document
!
"
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentTreeItem
;
treeItem
-
>
GetParent
(
getter_AddRefs
(
parentTreeItem
)
)
;
if
(
parentTreeItem
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
rootTreeItem
;
treeItem
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootTreeItem
)
)
;
if
(
parentTreeItem
=
=
rootTreeItem
)
return
true
;
DocAccessible
*
parentDoc
=
ParentDocument
(
)
;
return
parentDoc
&
&
parentDoc
-
>
HasLoadState
(
eCompletelyLoaded
)
;
}
return
(
treeItem
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeContent
)
;
}
void
DocAccessible
:
:
SetIPCDoc
(
DocAccessibleChild
*
aIPCDoc
)
{
MOZ_ASSERT
(
!
mIPCDoc
|
|
!
aIPCDoc
"
Clobbering
an
attached
IPCDoc
!
"
)
;
mIPCDoc
=
aIPCDoc
;
}
void
DocAccessible
:
:
DispatchScrollingEvent
(
uint32_t
aEventType
)
{
nsIScrollableFrame
*
sf
=
mPresShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
!
sf
)
{
return
;
}
int32_t
appUnitsPerDevPixel
=
mPresShell
-
>
GetPresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDevicePoint
scrollPoint
=
LayoutDevicePoint
:
:
FromAppUnits
(
sf
-
>
GetScrollPosition
(
)
appUnitsPerDevPixel
)
*
mPresShell
-
>
GetResolution
(
)
;
LayoutDeviceRect
scrollRange
=
LayoutDeviceRect
:
:
FromAppUnits
(
sf
-
>
GetScrollRange
(
)
appUnitsPerDevPixel
)
;
scrollRange
.
ScaleRoundOut
(
mPresShell
-
>
GetResolution
(
)
)
;
RefPtr
<
AccEvent
>
event
=
new
AccScrollingEvent
(
aEventType
this
scrollPoint
.
x
scrollPoint
.
y
scrollRange
.
width
scrollRange
.
height
)
;
nsEventShell
:
:
FireEvent
(
event
)
;
}
void
DocAccessible
:
:
ARIAActiveDescendantIDMaybeMoved
(
dom
:
:
Element
*
aElm
)
{
nsINode
*
focusNode
=
FocusMgr
(
)
-
>
FocusedDOMNode
(
)
;
if
(
!
focusNode
|
|
focusNode
-
>
OwnerDoc
(
)
!
=
mDocumentNode
)
{
return
;
}
dom
:
:
Element
*
focusElm
=
nullptr
;
if
(
focusNode
=
=
mDocumentNode
)
{
focusElm
=
Elm
(
)
;
if
(
!
focusElm
)
{
return
;
}
}
else
{
MOZ_ASSERT
(
focusNode
-
>
IsElement
(
)
)
;
focusElm
=
focusNode
-
>
AsElement
(
)
;
}
nsAutoString
id
;
aElm
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
id
)
;
if
(
!
focusElm
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_activedescendant
id
eCaseMatters
)
)
{
return
;
}
Accessible
*
acc
=
GetAccessibleEvenIfNotInMapOrContainer
(
focusNode
)
;
if
(
!
acc
)
{
return
;
}
mNotificationController
-
>
ScheduleNotification
<
DocAccessible
Accessible
>
(
this
&
DocAccessible
:
:
ARIAActiveDescendantChanged
acc
)
;
}
