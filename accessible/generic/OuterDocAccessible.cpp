#
include
"
OuterDocAccessible
.
h
"
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessibleChild
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessibleParent
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
a11y
/
ProxyWrappers
.
h
"
#
endif
#
include
"
mozilla
/
dom
/
BrowserBridgeChild
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
Role
.
h
"
#
include
"
States
.
h
"
#
ifdef
A11Y_LOG
#
include
"
Logging
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
OuterDocAccessible
:
:
OuterDocAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
AccessibleWrap
(
aContent
aDoc
)
{
mType
=
eOuterDocType
;
#
ifdef
XP_WIN
if
(
DocAccessibleParent
*
remoteDoc
=
RemoteChildDoc
(
)
)
{
remoteDoc
-
>
SendParentCOMProxy
(
this
)
;
}
#
endif
if
(
IPCAccessibilityActive
(
)
)
{
auto
bridge
=
dom
:
:
BrowserBridgeChild
:
:
GetFrom
(
aContent
)
;
if
(
bridge
)
{
SendEmbedderAccessible
(
bridge
)
;
}
}
dom
:
:
Document
*
outerDoc
=
mContent
-
>
GetUncomposedDoc
(
)
;
if
(
outerDoc
)
{
dom
:
:
Document
*
innerDoc
=
outerDoc
-
>
GetSubDocumentFor
(
mContent
)
;
if
(
innerDoc
)
GetAccService
(
)
-
>
GetDocAccessible
(
innerDoc
)
;
}
}
OuterDocAccessible
:
:
~
OuterDocAccessible
(
)
{
}
void
OuterDocAccessible
:
:
SendEmbedderAccessible
(
dom
:
:
BrowserBridgeChild
*
aBridge
)
{
MOZ_ASSERT
(
mDoc
)
;
DocAccessibleChild
*
ipcDoc
=
mDoc
-
>
IPCDoc
(
)
;
if
(
ipcDoc
)
{
uint64_t
id
=
reinterpret_cast
<
uintptr_t
>
(
UniqueID
(
)
)
;
#
if
defined
(
XP_WIN
)
ipcDoc
-
>
SetEmbedderOnBridge
(
aBridge
id
)
;
#
else
aBridge
-
>
SendSetEmbedderAccessible
(
ipcDoc
id
)
;
#
endif
}
}
role
OuterDocAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
INTERNAL_FRAME
;
}
LocalAccessible
*
OuterDocAccessible
:
:
LocalChildAtPoint
(
int32_t
aX
int32_t
aY
EWhichChildAtPoint
aWhichChild
)
{
nsIntRect
docRect
=
Bounds
(
)
;
if
(
!
docRect
.
Contains
(
aX
aY
)
)
return
nullptr
;
LocalAccessible
*
child
=
LocalChildAt
(
0
)
;
NS_ENSURE_TRUE
(
child
nullptr
)
;
if
(
aWhichChild
=
=
Accessible
:
:
EWhichChildAtPoint
:
:
DeepestChild
)
{
#
if
defined
(
XP_WIN
)
return
nullptr
;
#
else
return
child
-
>
LocalChildAtPoint
(
aX
aY
Accessible
:
:
EWhichChildAtPoint
:
:
DeepestChild
)
;
#
endif
}
return
child
;
}
void
OuterDocAccessible
:
:
Shutdown
(
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocDestroy
)
)
logging
:
:
OuterDocDestroy
(
this
)
;
#
endif
LocalAccessible
*
child
=
mChildren
.
SafeElementAt
(
0
nullptr
)
;
if
(
child
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocDestroy
)
)
{
logging
:
:
DocDestroy
(
"
outerdoc
'
s
child
document
rebind
is
scheduled
"
child
-
>
AsDoc
(
)
-
>
DocumentNode
(
)
)
;
}
#
endif
RemoveChild
(
child
)
;
if
(
!
mDoc
-
>
IsDefunct
(
)
)
{
MOZ_ASSERT
(
!
child
-
>
IsDefunct
(
)
"
Attempt
to
reattach
shutdown
document
accessible
"
)
;
if
(
!
child
-
>
IsDefunct
(
)
)
{
mDoc
-
>
BindChildDocument
(
child
-
>
AsDoc
(
)
)
;
}
}
}
AccessibleWrap
:
:
Shutdown
(
)
;
}
bool
OuterDocAccessible
:
:
InsertChildAt
(
uint32_t
aIdx
LocalAccessible
*
aAccessible
)
{
MOZ_RELEASE_ASSERT
(
aAccessible
-
>
IsDoc
(
)
"
OuterDocAccessible
can
have
a
document
child
only
!
"
)
;
if
(
mChildren
.
Length
(
)
)
mChildren
[
0
]
-
>
Shutdown
(
)
;
if
(
!
AccessibleWrap
:
:
InsertChildAt
(
0
aAccessible
)
)
return
false
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocCreate
)
)
{
logging
:
:
DocCreate
(
"
append
document
to
outerdoc
"
aAccessible
-
>
AsDoc
(
)
-
>
DocumentNode
(
)
)
;
logging
:
:
Address
(
"
outerdoc
"
this
)
;
}
#
endif
return
true
;
}
bool
OuterDocAccessible
:
:
RemoveChild
(
LocalAccessible
*
aAccessible
)
{
LocalAccessible
*
child
=
mChildren
.
SafeElementAt
(
0
nullptr
)
;
MOZ_ASSERT
(
child
=
=
aAccessible
"
Wrong
child
to
remove
!
"
)
;
if
(
child
!
=
aAccessible
)
{
return
false
;
}
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocDestroy
)
)
{
logging
:
:
DocDestroy
(
"
remove
document
from
outerdoc
"
child
-
>
AsDoc
(
)
-
>
DocumentNode
(
)
child
-
>
AsDoc
(
)
)
;
logging
:
:
Address
(
"
outerdoc
"
this
)
;
}
#
endif
bool
wasRemoved
=
AccessibleWrap
:
:
RemoveChild
(
child
)
;
NS_ASSERTION
(
!
mChildren
.
Length
(
)
"
This
child
document
of
outerdoc
accessible
wasn
'
t
removed
!
"
)
;
return
wasRemoved
;
}
bool
OuterDocAccessible
:
:
IsAcceptableChild
(
nsIContent
*
aEl
)
const
{
return
false
;
}
#
if
defined
(
XP_WIN
)
LocalAccessible
*
OuterDocAccessible
:
:
RemoteChildDocAccessible
(
)
const
{
RemoteAccessible
*
docProxy
=
RemoteChildDoc
(
)
;
if
(
docProxy
)
{
return
WrapperFor
(
docProxy
)
;
}
if
(
IPCAccessibilityActive
(
)
)
{
auto
bridge
=
dom
:
:
BrowserBridgeChild
:
:
GetFrom
(
mContent
)
;
if
(
bridge
)
{
return
bridge
-
>
GetEmbeddedDocAccessible
(
)
;
}
}
return
nullptr
;
}
LocalAccessible
*
OuterDocAccessible
:
:
LocalChildAt
(
uint32_t
aIndex
)
const
{
LocalAccessible
*
result
=
AccessibleWrap
:
:
LocalChildAt
(
aIndex
)
;
if
(
result
|
|
aIndex
)
{
return
result
;
}
return
RemoteChildDocAccessible
(
)
;
}
#
endif
uint32_t
OuterDocAccessible
:
:
ChildCount
(
)
const
{
uint32_t
result
=
mChildren
.
Length
(
)
;
if
(
!
result
&
&
#
if
defined
(
XP_WIN
)
(
(
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
&
&
RemoteChildDoc
(
)
)
|
|
RemoteChildDocAccessible
(
)
)
#
else
RemoteChildDoc
(
)
#
endif
)
{
result
=
1
;
}
return
result
;
}
Accessible
*
OuterDocAccessible
:
:
ChildAt
(
uint32_t
aIndex
)
const
{
LocalAccessible
*
result
=
AccessibleWrap
:
:
LocalChildAt
(
aIndex
)
;
if
(
result
|
|
aIndex
)
{
return
result
;
}
return
RemoteChildDoc
(
)
;
}
Accessible
*
OuterDocAccessible
:
:
ChildAtPoint
(
int32_t
aX
int32_t
aY
EWhichChildAtPoint
aWhichChild
)
{
nsIntRect
docRect
=
Bounds
(
)
;
if
(
!
docRect
.
Contains
(
aX
aY
)
)
return
nullptr
;
Accessible
*
child
=
ChildAt
(
0
)
;
NS_ENSURE_TRUE
(
child
nullptr
)
;
if
(
aWhichChild
=
=
EWhichChildAtPoint
:
:
DeepestChild
)
{
return
child
-
>
ChildAtPoint
(
aX
aY
EWhichChildAtPoint
:
:
DeepestChild
)
;
}
return
child
;
}
DocAccessibleParent
*
OuterDocAccessible
:
:
RemoteChildDoc
(
)
const
{
dom
:
:
BrowserParent
*
tab
=
dom
:
:
BrowserParent
:
:
GetFrom
(
GetContent
(
)
)
;
if
(
!
tab
)
{
return
nullptr
;
}
return
tab
-
>
GetTopLevelDocAccessible
(
)
;
}
