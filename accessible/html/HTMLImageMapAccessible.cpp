#
include
"
HTMLImageMapAccessible
.
h
"
#
include
"
ARIAMap
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
Role
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsImageMap
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAreaElement
.
h
"
using
namespace
mozilla
:
:
a11y
;
HTMLImageMapAccessible
:
:
HTMLImageMapAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
ImageAccessibleWrap
(
aContent
aDoc
)
{
mType
=
eImageMapType
;
UpdateChildAreas
(
false
)
;
}
role
HTMLImageMapAccessible
:
:
NativeRole
(
)
{
return
roles
:
:
IMAGE_MAP
;
}
uint32_t
HTMLImageMapAccessible
:
:
AnchorCount
(
)
{
return
ChildCount
(
)
;
}
Accessible
*
HTMLImageMapAccessible
:
:
AnchorAt
(
uint32_t
aAnchorIndex
)
{
return
GetChildAt
(
aAnchorIndex
)
;
}
already_AddRefed
<
nsIURI
>
HTMLImageMapAccessible
:
:
AnchorURIAt
(
uint32_t
aAnchorIndex
)
{
Accessible
*
area
=
GetChildAt
(
aAnchorIndex
)
;
if
(
!
area
)
return
nullptr
;
nsIContent
*
linkContent
=
area
-
>
GetContent
(
)
;
return
linkContent
?
linkContent
-
>
GetHrefURI
(
)
:
nullptr
;
}
void
HTMLImageMapAccessible
:
:
UpdateChildAreas
(
bool
aDoFireEvents
)
{
nsImageFrame
*
imageFrame
=
do_QueryFrame
(
mContent
-
>
GetPrimaryFrame
(
)
)
;
nsImageMap
*
imageMapObj
=
imageFrame
-
>
GetExistingImageMap
(
)
;
if
(
!
imageMapObj
)
return
;
TreeMutation
mt
(
this
TreeMutation
:
:
kNoEvents
&
!
aDoFireEvents
)
;
for
(
int32_t
childIdx
=
mChildren
.
Length
(
)
-
1
;
childIdx
>
=
0
;
childIdx
-
-
)
{
Accessible
*
area
=
mChildren
.
ElementAt
(
childIdx
)
;
if
(
area
-
>
GetContent
(
)
-
>
GetPrimaryFrame
(
)
)
continue
;
mt
.
BeforeRemoval
(
area
)
;
RemoveChild
(
area
)
;
}
uint32_t
areaElmCount
=
imageMapObj
-
>
AreaCount
(
)
;
for
(
uint32_t
idx
=
0
;
idx
<
areaElmCount
;
idx
+
+
)
{
nsIContent
*
areaContent
=
imageMapObj
-
>
GetAreaAt
(
idx
)
;
Accessible
*
area
=
mChildren
.
SafeElementAt
(
idx
)
;
if
(
!
area
|
|
area
-
>
GetContent
(
)
!
=
areaContent
)
{
RefPtr
<
Accessible
>
area
=
new
HTMLAreaAccessible
(
areaContent
mDoc
)
;
mDoc
-
>
BindToDocument
(
area
aria
:
:
GetRoleMap
(
areaContent
-
>
AsElement
(
)
)
)
;
if
(
!
InsertChildAt
(
idx
area
)
)
{
mDoc
-
>
UnbindFromDocument
(
area
)
;
break
;
}
mt
.
AfterInsertion
(
area
)
;
}
}
mt
.
Done
(
)
;
}
Accessible
*
HTMLImageMapAccessible
:
:
GetChildAccessibleFor
(
const
nsINode
*
aNode
)
const
{
uint32_t
length
=
mChildren
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
Accessible
*
area
=
mChildren
[
i
]
;
if
(
area
-
>
GetContent
(
)
=
=
aNode
)
return
area
;
}
return
nullptr
;
}
HTMLAreaAccessible
:
:
HTMLAreaAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HTMLLinkAccessible
(
aContent
aDoc
)
{
mStateFlags
|
=
eNotNodeMapEntry
;
}
ENameValueFlag
HTMLAreaAccessible
:
:
NativeName
(
nsString
&
aName
)
{
ENameValueFlag
nameFlag
=
Accessible
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
if
(
!
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
alt
aName
)
)
Value
(
aName
)
;
return
eNameOK
;
}
void
HTMLAreaAccessible
:
:
Description
(
nsString
&
aDescription
)
{
aDescription
.
Truncate
(
)
;
RefPtr
<
dom
:
:
HTMLAreaElement
>
area
=
dom
:
:
HTMLAreaElement
:
:
FromContentOrNull
(
mContent
)
;
if
(
area
)
area
-
>
GetShape
(
aDescription
)
;
}
Accessible
*
HTMLAreaAccessible
:
:
ChildAtPoint
(
int32_t
aX
int32_t
aY
EWhichChildAtPoint
aWhichChild
)
{
return
this
;
}
uint32_t
HTMLAreaAccessible
:
:
StartOffset
(
)
{
return
IndexInParent
(
)
;
}
uint32_t
HTMLAreaAccessible
:
:
EndOffset
(
)
{
return
IndexInParent
(
)
+
1
;
}
nsRect
HTMLAreaAccessible
:
:
RelativeBounds
(
nsIFrame
*
*
aBoundingFrame
)
const
{
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
!
frame
)
return
nsRect
(
)
;
nsImageFrame
*
imageFrame
=
do_QueryFrame
(
frame
)
;
nsImageMap
*
map
=
imageFrame
-
>
GetImageMap
(
)
;
nsRect
bounds
;
nsresult
rv
=
map
-
>
GetBoundsForAreaContent
(
mContent
bounds
)
;
if
(
NS_FAILED
(
rv
)
)
return
nsRect
(
)
;
*
aBoundingFrame
=
frame
;
bounds
.
SizeTo
(
bounds
.
Width
(
)
-
bounds
.
X
(
)
bounds
.
Height
(
)
-
bounds
.
Y
(
)
)
;
return
bounds
;
}
