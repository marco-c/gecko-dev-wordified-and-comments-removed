#
ifndef
mozilla_a11y_HTMLImageMapAccessible_h__
#
define
mozilla_a11y_HTMLImageMapAccessible_h__
#
include
"
HTMLLinkAccessible
.
h
"
#
include
"
ImageAccessible
.
h
"
namespace
mozilla
{
namespace
a11y
{
class
HTMLImageMapAccessible
final
:
public
ImageAccessible
{
public
:
HTMLImageMapAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
;
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
HTMLImageMapAccessible
ImageAccessible
)
virtual
a11y
:
:
role
NativeRole
(
)
const
override
;
virtual
LocalAccessible
*
AnchorAt
(
uint32_t
aAnchorIndex
)
override
;
virtual
already_AddRefed
<
nsIURI
>
AnchorURIAt
(
uint32_t
aAnchorIndex
)
const
override
;
void
UpdateChildAreas
(
bool
aDoFireEvents
=
true
)
;
LocalAccessible
*
GetChildAccessibleFor
(
const
nsINode
*
aNode
)
const
;
protected
:
virtual
~
HTMLImageMapAccessible
(
)
{
}
}
;
class
HTMLAreaAccessible
final
:
public
HTMLLinkAccessible
{
public
:
HTMLAreaAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
;
virtual
void
Description
(
nsString
&
aDescription
)
const
override
;
virtual
LocalAccessible
*
LocalChildAtPoint
(
int32_t
aX
int32_t
aY
EWhichChildAtPoint
aWhichChild
)
override
;
virtual
nsRect
RelativeBounds
(
nsIFrame
*
*
aBoundingFrame
)
const
override
;
virtual
nsRect
ParentRelativeBounds
(
)
override
;
virtual
uint32_t
StartOffset
(
)
override
;
virtual
uint32_t
EndOffset
(
)
override
;
virtual
bool
IsAcceptableChild
(
nsIContent
*
aEl
)
const
override
{
return
false
;
}
protected
:
virtual
ENameValueFlag
NativeName
(
nsString
&
aName
)
const
override
;
}
;
inline
HTMLImageMapAccessible
*
LocalAccessible
:
:
AsImageMap
(
)
{
return
IsImageMap
(
)
?
static_cast
<
HTMLImageMapAccessible
*
>
(
this
)
:
nullptr
;
}
}
}
#
endif
