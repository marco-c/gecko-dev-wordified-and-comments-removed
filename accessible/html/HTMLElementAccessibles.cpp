#
include
"
HTMLElementAccessibles
.
h
"
#
include
"
CacheConstants
.
h
"
#
include
"
nsCoreUtils
.
h
"
#
include
"
nsTextEquivUtils
.
h
"
#
include
"
Relation
.
h
"
#
include
"
mozilla
/
a11y
/
Role
.
h
"
#
include
"
States
.
h
"
#
include
"
mozilla
/
dom
/
HTMLLabelElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLDetailsElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSummaryElement
.
h
"
using
namespace
mozilla
:
:
a11y
;
role
HTMLHRAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
SEPARATOR
;
}
role
HTMLBRAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
WHITESPACE
;
}
uint64_t
HTMLBRAccessible
:
:
NativeState
(
)
const
{
return
states
:
:
READONLY
;
}
ENameValueFlag
HTMLBRAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
aName
=
static_cast
<
char16_t
>
(
'
\
n
'
)
;
return
eNameOK
;
}
ENameValueFlag
HTMLLabelAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
nsTextEquivUtils
:
:
GetNameFromSubtree
(
this
aName
)
;
return
aName
.
IsEmpty
(
)
?
eNameOK
:
eNameFromSubtree
;
}
Relation
HTMLLabelAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
AccessibleWrap
:
:
RelationByType
(
aType
)
;
if
(
aType
=
=
RelationType
:
:
LABEL_FOR
)
{
dom
:
:
HTMLLabelElement
*
label
=
dom
:
:
HTMLLabelElement
:
:
FromNode
(
mContent
)
;
rel
.
AppendTarget
(
mDoc
label
-
>
GetControl
(
)
)
;
}
return
rel
;
}
void
HTMLLabelAccessible
:
:
DOMAttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
AttrModType
aModType
const
nsAttrValue
*
aOldValue
uint64_t
aOldState
)
{
HyperTextAccessible
:
:
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
aOldState
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
_for
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Relations
|
CacheDomain
:
:
Actions
)
;
}
}
bool
HTMLLabelAccessible
:
:
HasPrimaryAction
(
)
const
{
return
nsCoreUtils
:
:
IsLabelWithControl
(
mContent
)
;
}
void
HTMLLabelAccessible
:
:
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
{
if
(
aIndex
=
=
0
)
{
if
(
HasPrimaryAction
(
)
)
{
aName
.
AssignLiteral
(
"
click
"
)
;
}
}
}
Relation
HTMLOutputAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
AccessibleWrap
:
:
RelationByType
(
aType
)
;
if
(
aType
=
=
RelationType
:
:
CONTROLLED_BY
)
{
rel
.
AppendIter
(
new
AssociatedElementsIterator
(
mDoc
mContent
nsGkAtoms
:
:
_for
)
)
;
}
return
rel
;
}
void
HTMLOutputAccessible
:
:
DOMAttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
AttrModType
aModType
const
nsAttrValue
*
aOldValue
uint64_t
aOldState
)
{
HyperTextAccessible
:
:
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
aOldState
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
_for
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Relations
)
;
}
}
HTMLSummaryAccessible
:
:
HTMLSummaryAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessible
(
aContent
aDoc
)
{
mGenericTypes
|
=
eButton
;
}
bool
HTMLSummaryAccessible
:
:
HasPrimaryAction
(
)
const
{
return
true
;
}
void
HTMLSummaryAccessible
:
:
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
{
if
(
aIndex
!
=
eAction_Click
)
{
return
;
}
dom
:
:
HTMLSummaryElement
*
summary
=
dom
:
:
HTMLSummaryElement
:
:
FromNode
(
mContent
)
;
if
(
!
summary
)
{
return
;
}
dom
:
:
HTMLDetailsElement
*
details
=
summary
-
>
GetDetails
(
)
;
if
(
!
details
)
{
return
;
}
if
(
details
-
>
Open
(
)
)
{
aName
.
AssignLiteral
(
"
collapse
"
)
;
}
else
{
aName
.
AssignLiteral
(
"
expand
"
)
;
}
}
uint64_t
HTMLSummaryAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
HyperTextAccessible
:
:
NativeState
(
)
;
dom
:
:
HTMLSummaryElement
*
summary
=
dom
:
:
HTMLSummaryElement
:
:
FromNode
(
mContent
)
;
if
(
!
summary
)
{
return
state
;
}
dom
:
:
HTMLDetailsElement
*
details
=
summary
-
>
GetDetails
(
)
;
if
(
!
details
)
{
return
state
;
}
state
|
=
states
:
:
EXPANDABLE
;
if
(
details
-
>
Open
(
)
)
{
state
|
=
states
:
:
EXPANDED
;
}
return
state
;
}
HTMLSummaryAccessible
*
HTMLSummaryAccessible
:
:
FromDetails
(
LocalAccessible
*
details
)
{
if
(
!
dom
:
:
HTMLDetailsElement
:
:
FromNodeOrNull
(
details
-
>
GetContent
(
)
)
)
{
return
nullptr
;
}
HTMLSummaryAccessible
*
summaryAccessible
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
details
-
>
ChildCount
(
)
;
i
+
+
)
{
LocalAccessible
*
child
=
details
-
>
LocalChildAt
(
i
)
;
auto
*
summary
=
mozilla
:
:
dom
:
:
HTMLSummaryElement
:
:
FromNodeOrNull
(
child
-
>
GetContent
(
)
)
;
if
(
summary
&
&
summary
-
>
IsMainSummary
(
)
)
{
summaryAccessible
=
static_cast
<
HTMLSummaryAccessible
*
>
(
child
)
;
break
;
}
}
return
summaryAccessible
;
}
bool
HTMLSummaryAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
role
HTMLHeaderOrFooterAccessible
:
:
NativeRole
(
)
const
{
nsIContent
*
parent
=
mContent
-
>
GetParent
(
)
;
while
(
parent
)
{
if
(
parent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
article
nsGkAtoms
:
:
aside
nsGkAtoms
:
:
nav
nsGkAtoms
:
:
section
nsGkAtoms
:
:
main
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
details
nsGkAtoms
:
:
dialog
nsGkAtoms
:
:
fieldset
nsGkAtoms
:
:
figure
nsGkAtoms
:
:
td
)
)
{
break
;
}
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
!
parent
)
{
return
roles
:
:
LANDMARK
;
}
return
roles
:
:
SECTION
;
}
role
HTMLAsideAccessible
:
:
NativeRole
(
)
const
{
nsIContent
*
parent
=
mContent
-
>
GetParent
(
)
;
while
(
parent
)
{
if
(
parent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
article
nsGkAtoms
:
:
aside
nsGkAtoms
:
:
nav
nsGkAtoms
:
:
section
)
)
{
return
!
NameIsEmpty
(
)
?
roles
:
:
LANDMARK
:
roles
:
:
SECTION
;
}
if
(
parent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
main
nsGkAtoms
:
:
body
)
)
{
return
roles
:
:
LANDMARK
;
}
parent
=
parent
-
>
GetParent
(
)
;
}
return
roles
:
:
LANDMARK
;
}
role
HTMLSectionAccessible
:
:
NativeRole
(
)
const
{
return
NameIsEmpty
(
)
?
roles
:
:
SECTION
:
roles
:
:
REGION
;
}
