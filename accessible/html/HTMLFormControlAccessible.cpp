#
include
"
HTMLFormControlAccessible
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
nsTextEquivUtils
.
h
"
#
include
"
Relation
.
h
"
#
include
"
Role
.
h
"
#
include
"
States
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
a11y
;
role
HTMLFormAccessible
:
:
NativeRole
(
)
const
{
nsAutoString
name
;
const_cast
<
HTMLFormAccessible
*
>
(
this
)
-
>
Name
(
name
)
;
return
name
.
IsEmpty
(
)
?
roles
:
:
FORM
:
roles
:
:
FORM_LANDMARK
;
}
nsAtom
*
HTMLFormAccessible
:
:
LandmarkRole
(
)
const
{
if
(
!
HasOwnContent
(
)
)
{
return
nullptr
;
}
nsAutoString
name
;
const_cast
<
HTMLFormAccessible
*
>
(
this
)
-
>
Name
(
name
)
;
return
name
.
IsEmpty
(
)
?
HyperTextAccessibleWrap
:
:
LandmarkRole
(
)
:
nsGkAtoms
:
:
form
;
}
uint64_t
HTMLRadioButtonAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
AccessibleWrap
:
:
NativeState
(
)
;
state
|
=
states
:
:
CHECKABLE
;
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
if
(
input
&
&
input
-
>
Checked
(
)
)
state
|
=
states
:
:
CHECKED
;
return
state
;
}
void
HTMLRadioButtonAccessible
:
:
GetPositionAndSizeInternal
(
int32_t
*
aPosInSet
int32_t
*
aSetSize
)
{
Unused
<
<
ComputeGroupAttributes
(
aPosInSet
aSetSize
)
;
}
Relation
HTMLRadioButtonAccessible
:
:
ComputeGroupAttributes
(
int32_t
*
aPosInSet
int32_t
*
aSetSize
)
const
{
Relation
rel
=
Relation
(
)
;
int32_t
namespaceId
=
mContent
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
;
nsAutoString
tagName
;
mContent
-
>
NodeInfo
(
)
-
>
GetName
(
tagName
)
;
nsAutoString
type
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
)
;
nsAutoString
name
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
RefPtr
<
nsContentList
>
inputElms
;
nsCOMPtr
<
nsIFormControl
>
formControlNode
(
do_QueryInterface
(
mContent
)
)
;
if
(
dom
:
:
Element
*
formElm
=
formControlNode
-
>
GetForm
(
)
)
{
inputElms
=
NS_GetContentList
(
formElm
namespaceId
tagName
)
;
}
else
{
inputElms
=
NS_GetContentList
(
mContent
-
>
OwnerDoc
(
)
namespaceId
tagName
)
;
}
NS_ENSURE_TRUE
(
inputElms
rel
)
;
uint32_t
inputCount
=
inputElms
-
>
Length
(
false
)
;
int32_t
indexOf
=
0
;
int32_t
count
=
0
;
for
(
uint32_t
index
=
0
;
index
<
inputCount
;
index
+
+
)
{
nsIContent
*
inputElm
=
inputElms
-
>
Item
(
index
false
)
;
if
(
inputElm
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
eCaseMatters
)
&
&
inputElm
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
eCaseMatters
)
&
&
mDoc
-
>
HasAccessible
(
inputElm
)
)
{
count
+
+
;
rel
.
AppendTarget
(
mDoc
-
>
GetAccessible
(
inputElm
)
)
;
if
(
inputElm
=
=
mContent
)
indexOf
=
count
;
}
}
*
aPosInSet
=
indexOf
;
*
aSetSize
=
count
;
return
rel
;
}
Relation
HTMLRadioButtonAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
if
(
aType
=
=
RelationType
:
:
MEMBER_OF
)
{
int32_t
unusedPos
unusedSetSize
;
return
ComputeGroupAttributes
(
&
unusedPos
&
unusedSetSize
)
;
}
return
LocalAccessible
:
:
RelationByType
(
aType
)
;
}
HTMLButtonAccessible
:
:
HTMLButtonAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
mGenericTypes
|
=
eButton
;
}
uint8_t
HTMLButtonAccessible
:
:
ActionCount
(
)
const
{
return
1
;
}
void
HTMLButtonAccessible
:
:
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
{
if
(
aIndex
=
=
eAction_Click
)
aName
.
AssignLiteral
(
"
press
"
)
;
}
bool
HTMLButtonAccessible
:
:
DoAction
(
uint8_t
aIndex
)
const
{
if
(
aIndex
!
=
eAction_Click
)
return
false
;
DoCommand
(
)
;
return
true
;
}
uint64_t
HTMLButtonAccessible
:
:
State
(
)
{
uint64_t
state
=
HyperTextAccessibleWrap
:
:
State
(
)
;
if
(
state
=
=
states
:
:
DEFUNCT
)
return
state
;
if
(
mParent
&
&
mParent
-
>
IsHTMLFileInput
(
)
)
{
uint64_t
parentState
=
mParent
-
>
State
(
)
;
state
|
=
parentState
&
(
states
:
:
BUSY
|
states
:
:
REQUIRED
|
states
:
:
HASPOPUP
|
states
:
:
INVALID
)
;
}
return
state
;
}
uint64_t
HTMLButtonAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
HyperTextAccessibleWrap
:
:
NativeState
(
)
;
EventStates
elmState
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
elmState
.
HasState
(
NS_EVENT_STATE_DEFAULT
)
)
state
|
=
states
:
:
DEFAULT
;
return
state
;
}
role
HTMLButtonAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
PUSHBUTTON
;
}
ENameValueFlag
HTMLButtonAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
ENameValueFlag
nameFlag
=
LocalAccessible
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
|
|
!
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
|
|
!
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
image
eCaseMatters
)
)
{
return
nameFlag
;
}
if
(
!
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
alt
aName
)
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
aName
)
;
}
aName
.
CompressWhitespace
(
)
;
return
eNameOK
;
}
void
HTMLButtonAccessible
:
:
DOMAttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
uint64_t
aOldState
)
{
HyperTextAccessibleWrap
:
:
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
aOldState
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
value
)
{
dom
:
:
Element
*
elm
=
Elm
(
)
;
if
(
elm
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
|
|
(
elm
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
image
eCaseMatters
)
&
&
!
elm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
alt
)
)
)
{
if
(
!
elm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_labelledby
)
&
&
!
elm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_label
)
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
this
)
;
}
}
}
}
bool
HTMLButtonAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
HTMLTextFieldAccessible
:
:
HTMLTextFieldAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
mType
=
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
password
eIgnoreCase
)
?
eHTMLTextPasswordFieldType
:
eHTMLTextFieldType
;
}
role
HTMLTextFieldAccessible
:
:
NativeRole
(
)
const
{
if
(
mType
=
=
eHTMLTextPasswordFieldType
)
{
return
roles
:
:
PASSWORD_TEXT
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
list_
)
)
{
return
roles
:
:
EDITCOMBOBOX
;
}
return
roles
:
:
ENTRY
;
}
already_AddRefed
<
AccAttributes
>
HTMLTextFieldAccessible
:
:
NativeAttributes
(
)
{
RefPtr
<
AccAttributes
>
attributes
=
HyperTextAccessibleWrap
:
:
NativeAttributes
(
)
;
nsString
type
;
nsIContent
*
widgetElm
=
BindingOrWidgetParent
(
)
;
if
(
(
widgetElm
&
&
widgetElm
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
)
)
|
|
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
)
)
{
if
(
!
ARIARoleMap
(
)
&
&
type
.
EqualsLiteral
(
"
search
"
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
nsGkAtoms
:
:
searchbox
)
;
}
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
textInputType
std
:
:
move
(
type
)
)
;
}
nsString
placeholderText
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
placeholder
placeholderText
)
)
{
nsAutoString
name
;
const_cast
<
HTMLTextFieldAccessible
*
>
(
this
)
-
>
Name
(
name
)
;
if
(
!
name
.
Equals
(
placeholderText
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
placeholder
std
:
:
move
(
placeholderText
)
)
;
}
}
return
attributes
.
forget
(
)
;
}
ENameValueFlag
HTMLTextFieldAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
ENameValueFlag
nameFlag
=
LocalAccessible
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
nsIContent
*
widgetElm
=
BindingOrWidgetParent
(
)
;
if
(
widgetElm
)
XULElmName
(
mDoc
widgetElm
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
eNameOK
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
placeholder
aName
)
;
return
eNameOK
;
}
void
HTMLTextFieldAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
aValue
.
Truncate
(
)
;
if
(
NativeState
(
)
&
states
:
:
PROTECTED
)
{
return
;
}
HTMLTextAreaElement
*
textArea
=
HTMLTextAreaElement
:
:
FromNode
(
mContent
)
;
if
(
textArea
)
{
textArea
-
>
GetValue
(
aValue
)
;
return
;
}
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
if
(
input
)
{
input
-
>
GetValue
(
aValue
CallerType
:
:
NonSystem
)
;
}
}
void
HTMLTextFieldAccessible
:
:
ApplyARIAState
(
uint64_t
*
aState
)
const
{
HyperTextAccessibleWrap
:
:
ApplyARIAState
(
aState
)
;
aria
:
:
MapToState
(
aria
:
:
eARIAAutoComplete
mContent
-
>
AsElement
(
)
aState
)
;
nsIContent
*
widgetElm
=
BindingOrWidgetParent
(
)
;
if
(
widgetElm
)
{
aria
:
:
MapToState
(
aria
:
:
eARIAAutoComplete
widgetElm
-
>
AsElement
(
)
aState
)
;
}
}
uint64_t
HTMLTextFieldAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
HyperTextAccessibleWrap
:
:
NativeState
(
)
;
state
|
=
states
:
:
EDITABLE
;
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
password
eIgnoreCase
)
)
{
state
|
=
states
:
:
PROTECTED
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
readonly
)
)
{
state
|
=
states
:
:
READONLY
;
}
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
state
|
=
input
&
&
input
-
>
IsSingleLineTextControl
(
)
?
states
:
:
SINGLE_LINE
:
states
:
:
MULTI_LINE
;
if
(
state
&
(
states
:
:
PROTECTED
|
states
:
:
MULTI_LINE
|
states
:
:
READONLY
|
states
:
:
UNAVAILABLE
)
)
{
return
state
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
list_
)
)
{
return
state
|
states
:
:
SUPPORTS_AUTOCOMPLETION
|
states
:
:
HASPOPUP
;
}
if
(
!
BindingOrWidgetParent
(
)
&
&
Preferences
:
:
GetBool
(
"
browser
.
formfill
.
enable
"
)
)
{
nsAutoString
autocomplete
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autocomplete
autocomplete
)
;
if
(
!
autocomplete
.
LowerCaseEqualsLiteral
(
"
off
"
)
)
{
Element
*
formElement
=
input
-
>
GetForm
(
)
;
if
(
formElement
)
{
formElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autocomplete
autocomplete
)
;
}
if
(
!
formElement
|
|
!
autocomplete
.
LowerCaseEqualsLiteral
(
"
off
"
)
)
{
state
|
=
states
:
:
SUPPORTS_AUTOCOMPLETION
;
}
}
}
return
state
;
}
uint8_t
HTMLTextFieldAccessible
:
:
ActionCount
(
)
const
{
return
1
;
}
void
HTMLTextFieldAccessible
:
:
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
{
if
(
aIndex
=
=
eAction_Click
)
aName
.
AssignLiteral
(
"
activate
"
)
;
}
bool
HTMLTextFieldAccessible
:
:
DoAction
(
uint8_t
aIndex
)
const
{
if
(
aIndex
!
=
0
)
return
false
;
if
(
FocusMgr
(
)
-
>
IsFocused
(
this
)
)
{
DoCommand
(
)
;
}
else
{
TakeFocus
(
)
;
}
return
true
;
}
already_AddRefed
<
EditorBase
>
HTMLTextFieldAccessible
:
:
GetEditor
(
)
const
{
RefPtr
<
TextControlElement
>
textControlElement
=
TextControlElement
:
:
FromNodeOrNull
(
mContent
)
;
if
(
!
textControlElement
)
{
return
nullptr
;
}
RefPtr
<
TextEditor
>
textEditor
=
textControlElement
-
>
GetTextEditor
(
)
;
return
textEditor
.
forget
(
)
;
}
bool
HTMLTextFieldAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
LocalAccessible
*
HTMLTextFieldAccessible
:
:
ContainerWidget
(
)
const
{
if
(
!
mParent
|
|
mParent
-
>
Role
(
)
!
=
roles
:
:
AUTOCOMPLETE
)
{
return
nullptr
;
}
return
mParent
;
}
HTMLFileInputAccessible
:
:
HTMLFileInputAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
mType
=
eHTMLFileInputType
;
}
role
HTMLFileInputAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
GROUPING
;
}
nsresult
HTMLFileInputAccessible
:
:
HandleAccEvent
(
AccEvent
*
aEvent
)
{
nsresult
rv
=
HyperTextAccessibleWrap
:
:
HandleAccEvent
(
aEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AccStateChangeEvent
*
event
=
downcast_accEvent
(
aEvent
)
;
if
(
event
&
&
(
event
-
>
GetState
(
)
=
=
states
:
:
BUSY
|
|
event
-
>
GetState
(
)
=
=
states
:
:
REQUIRED
|
|
event
-
>
GetState
(
)
=
=
states
:
:
HASPOPUP
|
|
event
-
>
GetState
(
)
=
=
states
:
:
INVALID
)
)
{
LocalAccessible
*
button
=
LocalChildAt
(
0
)
;
if
(
button
&
&
button
-
>
Role
(
)
=
=
roles
:
:
PUSHBUTTON
)
{
RefPtr
<
AccStateChangeEvent
>
childEvent
=
new
AccStateChangeEvent
(
button
event
-
>
GetState
(
)
event
-
>
IsStateEnabled
(
)
event
-
>
FromUserInput
(
)
)
;
nsEventShell
:
:
FireEvent
(
childEvent
)
;
}
}
return
NS_OK
;
}
LocalAccessible
*
HTMLFileInputAccessible
:
:
CurrentItem
(
)
const
{
if
(
LocalAccessible
*
item
=
HyperTextAccessibleWrap
:
:
CurrentItem
(
)
)
{
return
item
;
}
LocalAccessible
*
button
=
LocalFirstChild
(
)
;
if
(
!
button
)
{
MOZ_ASSERT_UNREACHABLE
(
"
File
input
doesn
'
t
contain
a
button
"
)
;
return
nullptr
;
}
MOZ_ASSERT
(
button
-
>
IsButton
(
)
)
;
return
button
;
}
role
HTMLSpinnerAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
SPINBUTTON
;
}
void
HTMLSpinnerAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
HTMLTextFieldAccessible
:
:
Value
(
aValue
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
return
;
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetValue
(
aValue
CallerType
:
:
NonSystem
)
;
}
double
HTMLSpinnerAccessible
:
:
MaxValue
(
)
const
{
double
value
=
HTMLTextFieldAccessible
:
:
MaxValue
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetMaximum
(
)
.
toDouble
(
)
;
}
double
HTMLSpinnerAccessible
:
:
MinValue
(
)
const
{
double
value
=
HTMLTextFieldAccessible
:
:
MinValue
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetMinimum
(
)
.
toDouble
(
)
;
}
double
HTMLSpinnerAccessible
:
:
Step
(
)
const
{
double
value
=
HTMLTextFieldAccessible
:
:
Step
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetStep
(
)
.
toDouble
(
)
;
}
double
HTMLSpinnerAccessible
:
:
CurValue
(
)
const
{
double
value
=
HTMLTextFieldAccessible
:
:
CurValue
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetValueAsDecimal
(
)
.
toDouble
(
)
;
}
bool
HTMLSpinnerAccessible
:
:
SetCurValue
(
double
aValue
)
{
ErrorResult
er
;
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
SetValueAsNumber
(
aValue
er
)
;
return
!
er
.
Failed
(
)
;
}
role
HTMLRangeAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
SLIDER
;
}
bool
HTMLRangeAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
void
HTMLRangeAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
LeafAccessible
:
:
Value
(
aValue
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
return
;
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetValue
(
aValue
CallerType
:
:
NonSystem
)
;
}
double
HTMLRangeAccessible
:
:
MaxValue
(
)
const
{
double
value
=
LeafAccessible
:
:
MaxValue
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetMaximum
(
)
.
toDouble
(
)
;
}
double
HTMLRangeAccessible
:
:
MinValue
(
)
const
{
double
value
=
LeafAccessible
:
:
MinValue
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetMinimum
(
)
.
toDouble
(
)
;
}
double
HTMLRangeAccessible
:
:
Step
(
)
const
{
double
value
=
LeafAccessible
:
:
Step
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetStep
(
)
.
toDouble
(
)
;
}
double
HTMLRangeAccessible
:
:
CurValue
(
)
const
{
double
value
=
LeafAccessible
:
:
CurValue
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetValueAsDecimal
(
)
.
toDouble
(
)
;
}
bool
HTMLRangeAccessible
:
:
SetCurValue
(
double
aValue
)
{
ErrorResult
er
;
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
SetValueAsNumber
(
aValue
er
)
;
return
!
er
.
Failed
(
)
;
}
HTMLGroupboxAccessible
:
:
HTMLGroupboxAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
}
role
HTMLGroupboxAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
GROUPING
;
}
nsIContent
*
HTMLGroupboxAccessible
:
:
GetLegend
(
)
const
{
for
(
nsIContent
*
legendContent
=
mContent
-
>
GetFirstChild
(
)
;
legendContent
;
legendContent
=
legendContent
-
>
GetNextSibling
(
)
)
{
if
(
legendContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
legend
mContent
-
>
GetNameSpaceID
(
)
)
)
{
return
legendContent
;
}
}
return
nullptr
;
}
ENameValueFlag
HTMLGroupboxAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
ENameValueFlag
nameFlag
=
LocalAccessible
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
nsIContent
*
legendContent
=
GetLegend
(
)
;
if
(
legendContent
)
{
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
this
legendContent
&
aName
)
;
}
aName
.
CompressWhitespace
(
)
;
return
eNameOK
;
}
Relation
HTMLGroupboxAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
HyperTextAccessibleWrap
:
:
RelationByType
(
aType
)
;
if
(
aType
=
=
RelationType
:
:
LABELLED_BY
)
rel
.
AppendTarget
(
mDoc
GetLegend
(
)
)
;
return
rel
;
}
HTMLLegendAccessible
:
:
HTMLLegendAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
}
Relation
HTMLLegendAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
HyperTextAccessibleWrap
:
:
RelationByType
(
aType
)
;
if
(
aType
!
=
RelationType
:
:
LABEL_FOR
)
return
rel
;
LocalAccessible
*
groupbox
=
LocalParent
(
)
;
if
(
groupbox
&
&
groupbox
-
>
Role
(
)
=
=
roles
:
:
GROUPING
)
{
rel
.
AppendTarget
(
groupbox
)
;
}
return
rel
;
}
HTMLFigureAccessible
:
:
HTMLFigureAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
}
ENameValueFlag
HTMLFigureAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
ENameValueFlag
nameFlag
=
HyperTextAccessibleWrap
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
nsIContent
*
captionContent
=
Caption
(
)
;
if
(
captionContent
)
{
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
this
captionContent
&
aName
)
;
}
aName
.
CompressWhitespace
(
)
;
return
eNameOK
;
}
Relation
HTMLFigureAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
HyperTextAccessibleWrap
:
:
RelationByType
(
aType
)
;
if
(
aType
=
=
RelationType
:
:
LABELLED_BY
)
rel
.
AppendTarget
(
mDoc
Caption
(
)
)
;
return
rel
;
}
nsIContent
*
HTMLFigureAccessible
:
:
Caption
(
)
const
{
for
(
nsIContent
*
childContent
=
mContent
-
>
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
if
(
childContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
figcaption
mContent
-
>
GetNameSpaceID
(
)
)
)
{
return
childContent
;
}
}
return
nullptr
;
}
HTMLFigcaptionAccessible
:
:
HTMLFigcaptionAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
}
Relation
HTMLFigcaptionAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
HyperTextAccessibleWrap
:
:
RelationByType
(
aType
)
;
if
(
aType
!
=
RelationType
:
:
LABEL_FOR
)
return
rel
;
LocalAccessible
*
figure
=
LocalParent
(
)
;
if
(
figure
&
&
figure
-
>
GetContent
(
)
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
figure
mContent
-
>
GetNameSpaceID
(
)
)
)
{
rel
.
AppendTarget
(
figure
)
;
}
return
rel
;
}
role
HTMLProgressAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
PROGRESSBAR
;
}
uint64_t
HTMLProgressAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
LeafAccessible
:
:
NativeState
(
)
;
nsAutoString
attrValue
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
attrValue
)
;
if
(
attrValue
.
IsEmpty
(
)
)
{
state
|
=
states
:
:
MIXED
;
}
return
state
;
}
bool
HTMLProgressAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
void
HTMLProgressAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
LeafAccessible
:
:
Value
(
aValue
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
{
return
;
}
double
maxValue
=
MaxValue
(
)
;
if
(
IsNaN
(
maxValue
)
|
|
maxValue
=
=
0
)
{
return
;
}
double
curValue
=
CurValue
(
)
;
if
(
IsNaN
(
curValue
)
)
{
return
;
}
double
percentValue
=
(
curValue
<
maxValue
)
?
(
curValue
/
maxValue
)
*
100
:
100
;
aValue
.
AppendFloat
(
percentValue
)
;
aValue
.
Append
(
'
%
'
)
;
}
double
HTMLProgressAccessible
:
:
MaxValue
(
)
const
{
double
value
=
LeafAccessible
:
:
MaxValue
(
)
;
if
(
!
IsNaN
(
value
)
)
{
return
value
;
}
nsAutoString
strValue
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
max
strValue
)
)
{
nsresult
result
=
NS_OK
;
value
=
strValue
.
ToDouble
(
&
result
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
return
value
;
}
}
return
1
;
}
double
HTMLProgressAccessible
:
:
MinValue
(
)
const
{
double
value
=
LeafAccessible
:
:
MinValue
(
)
;
return
IsNaN
(
value
)
?
0
:
value
;
}
double
HTMLProgressAccessible
:
:
Step
(
)
const
{
double
value
=
LeafAccessible
:
:
Step
(
)
;
return
IsNaN
(
value
)
?
0
:
value
;
}
double
HTMLProgressAccessible
:
:
CurValue
(
)
const
{
double
value
=
LeafAccessible
:
:
CurValue
(
)
;
if
(
!
IsNaN
(
value
)
)
{
return
value
;
}
nsAutoString
attrValue
;
if
(
!
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
attrValue
)
)
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
nsresult
error
=
NS_OK
;
value
=
attrValue
.
ToDouble
(
&
error
)
;
return
NS_FAILED
(
error
)
?
UnspecifiedNaN
<
double
>
(
)
:
value
;
}
bool
HTMLProgressAccessible
:
:
SetCurValue
(
double
aValue
)
{
return
false
;
}
void
HTMLProgressAccessible
:
:
DOMAttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
uint64_t
aOldState
)
{
LeafAccessible
:
:
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
aOldState
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
value
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
this
)
;
uint64_t
currState
=
NativeState
(
)
;
if
(
(
aOldState
^
currState
)
&
states
:
:
MIXED
)
{
RefPtr
<
AccEvent
>
stateChangeEvent
=
new
AccStateChangeEvent
(
this
states
:
:
MIXED
(
currState
&
states
:
:
MIXED
)
)
;
mDoc
-
>
FireDelayedEvent
(
stateChangeEvent
)
;
}
}
}
role
HTMLMeterAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
METER
;
}
bool
HTMLMeterAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
void
HTMLMeterAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
LeafAccessible
:
:
Value
(
aValue
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
{
return
;
}
nsTextEquivUtils
:
:
AppendFromDOMChildren
(
mContent
&
aValue
)
;
aValue
.
CompressWhitespace
(
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
{
return
;
}
double
curValue
=
CurValue
(
)
;
if
(
IsNaN
(
curValue
)
)
{
return
;
}
aValue
.
AppendFloat
(
curValue
)
;
}
double
HTMLMeterAccessible
:
:
MaxValue
(
)
const
{
double
max
=
LeafAccessible
:
:
MaxValue
(
)
;
double
min
=
MinValue
(
)
;
if
(
!
IsNaN
(
max
)
)
{
return
max
>
min
?
max
:
min
;
}
nsAutoString
strValue
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
max
strValue
)
)
{
nsresult
result
=
NS_OK
;
max
=
strValue
.
ToDouble
(
&
result
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
return
max
>
min
?
max
:
min
;
}
}
return
1
>
min
?
1
:
min
;
}
double
HTMLMeterAccessible
:
:
MinValue
(
)
const
{
double
min
=
LeafAccessible
:
:
MinValue
(
)
;
if
(
!
IsNaN
(
min
)
)
{
return
min
;
}
nsAutoString
strValue
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
min
strValue
)
)
{
nsresult
result
=
NS_OK
;
min
=
strValue
.
ToDouble
(
&
result
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
return
min
;
}
}
return
0
;
}
double
HTMLMeterAccessible
:
:
CurValue
(
)
const
{
double
value
=
LeafAccessible
:
:
CurValue
(
)
;
double
minValue
=
MinValue
(
)
;
if
(
IsNaN
(
value
)
)
{
nsAutoString
attrValue
;
if
(
!
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
attrValue
)
)
{
return
minValue
;
}
nsresult
error
=
NS_OK
;
value
=
attrValue
.
ToDouble
(
&
error
)
;
if
(
NS_FAILED
(
error
)
)
{
return
minValue
;
}
}
double
maxValue
=
MaxValue
(
)
;
if
(
value
>
maxValue
)
{
value
=
maxValue
;
}
else
if
(
value
<
minValue
)
{
value
=
minValue
;
}
return
value
;
}
bool
HTMLMeterAccessible
:
:
SetCurValue
(
double
aValue
)
{
return
false
;
}
void
HTMLMeterAccessible
:
:
DOMAttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
uint64_t
aOldState
)
{
LeafAccessible
:
:
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
aOldState
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
value
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
this
)
;
}
}
