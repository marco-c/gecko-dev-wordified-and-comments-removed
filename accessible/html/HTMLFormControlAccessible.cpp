#
include
"
HTMLFormControlAccessible
.
h
"
#
include
"
CacheConstants
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
nsTextEquivUtils
.
h
"
#
include
"
Relation
.
h
"
#
include
"
mozilla
/
a11y
/
Role
.
h
"
#
include
"
States
.
h
"
#
include
"
TextLeafAccessible
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMeterElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormControlsCollection
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
a11y
;
role
HTMLFormAccessible
:
:
NativeRole
(
)
const
{
return
NameIsEmpty
(
)
?
roles
:
:
FORM
:
roles
:
:
FORM_LANDMARK
;
}
void
HTMLFormAccessible
:
:
DOMAttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
AttrModType
aModType
const
nsAttrValue
*
aOldValue
uint64_t
aOldState
)
{
HyperTextAccessible
:
:
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
aOldState
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
autocomplete
)
{
dom
:
:
HTMLFormElement
*
formEl
=
dom
:
:
HTMLFormElement
:
:
FromNode
(
mContent
)
;
HTMLFormControlsCollection
*
controls
=
formEl
-
>
Elements
(
)
;
uint32_t
length
=
controls
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
LocalAccessible
*
acc
=
mDoc
-
>
GetAccessible
(
controls
-
>
Item
(
i
)
)
)
{
if
(
acc
-
>
IsTextField
(
)
&
&
!
acc
-
>
IsPassword
(
)
)
{
if
(
!
acc
-
>
Elm
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
list
)
&
&
!
acc
-
>
Elm
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
autocomplete
nsGkAtoms
:
:
OFF
eIgnoreCase
)
)
{
RefPtr
<
AccEvent
>
stateChangeEvent
=
new
AccStateChangeEvent
(
acc
states
:
:
SUPPORTS_AUTOCOMPLETION
)
;
mDoc
-
>
FireDelayedEvent
(
stateChangeEvent
)
;
}
}
}
}
}
}
uint64_t
HTMLRadioButtonAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
AccessibleWrap
:
:
NativeState
(
)
;
state
|
=
states
:
:
CHECKABLE
;
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
if
(
input
&
&
input
-
>
Checked
(
)
)
state
|
=
states
:
:
CHECKED
;
return
state
;
}
void
HTMLRadioButtonAccessible
:
:
GetPositionAndSetSize
(
int32_t
*
aPosInSet
int32_t
*
aSetSize
)
{
(
void
)
ComputeGroupAttributes
(
aPosInSet
aSetSize
)
;
}
void
HTMLRadioButtonAccessible
:
:
DOMAttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
AttrModType
aModType
const
nsAttrValue
*
aOldValue
uint64_t
aOldState
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
name
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Relations
)
;
}
else
{
RadioButtonAccessible
:
:
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
aOldState
)
;
}
}
Relation
HTMLRadioButtonAccessible
:
:
ComputeGroupAttributes
(
int32_t
*
aPosInSet
int32_t
*
aSetSize
)
const
{
Relation
rel
=
Relation
(
)
;
int32_t
namespaceId
=
mContent
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
;
nsAutoString
tagName
;
mContent
-
>
NodeInfo
(
)
-
>
GetName
(
tagName
)
;
nsAutoString
type
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
type
type
)
;
nsAutoString
name
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
name
name
)
;
RefPtr
<
nsContentList
>
inputElms
;
if
(
dom
:
:
Element
*
formElm
=
nsIFormControl
:
:
FromNode
(
mContent
)
-
>
GetForm
(
)
)
{
inputElms
=
NS_GetContentList
(
formElm
namespaceId
tagName
)
;
}
else
{
inputElms
=
NS_GetContentList
(
mContent
-
>
OwnerDoc
(
)
namespaceId
tagName
)
;
}
NS_ENSURE_TRUE
(
inputElms
rel
)
;
uint32_t
inputCount
=
inputElms
-
>
Length
(
false
)
;
int32_t
indexOf
=
0
;
int32_t
count
=
0
;
for
(
uint32_t
index
=
0
;
index
<
inputCount
;
index
+
+
)
{
nsIContent
*
inputElm
=
inputElms
-
>
Item
(
index
false
)
;
if
(
inputElm
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
eCaseMatters
)
&
&
inputElm
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
eCaseMatters
)
&
&
mDoc
-
>
HasAccessible
(
inputElm
)
)
{
count
+
+
;
rel
.
AppendTarget
(
mDoc
-
>
GetAccessible
(
inputElm
)
)
;
if
(
inputElm
=
=
mContent
)
indexOf
=
count
;
}
}
*
aPosInSet
=
indexOf
;
*
aSetSize
=
count
;
return
rel
;
}
Relation
HTMLRadioButtonAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
if
(
aType
=
=
RelationType
:
:
MEMBER_OF
)
{
int32_t
unusedPos
unusedSetSize
;
return
ComputeGroupAttributes
(
&
unusedPos
&
unusedSetSize
)
;
}
return
LocalAccessible
:
:
RelationByType
(
aType
)
;
}
HTMLButtonAccessible
:
:
HTMLButtonAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessible
(
aContent
aDoc
)
{
mGenericTypes
|
=
eButton
;
}
bool
HTMLButtonAccessible
:
:
HasPrimaryAction
(
)
const
{
return
true
;
}
void
HTMLButtonAccessible
:
:
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
{
if
(
aIndex
=
=
eAction_Click
)
aName
.
AssignLiteral
(
"
press
"
)
;
}
void
HTMLButtonAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
if
(
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
mContent
)
)
{
if
(
input
-
>
IsInputColor
(
)
)
{
nsAutoString
value
;
input
-
>
GetValue
(
value
CallerType
:
:
NonSystem
)
;
Maybe
<
nscolor
>
maybeColor
=
HTMLInputElement
:
:
ParseSimpleColor
(
value
)
;
if
(
maybeColor
)
{
const
nscolor
&
color
=
maybeColor
.
ref
(
)
;
Decimal
r
(
static_cast
<
int
>
(
NS_GET_R
(
color
)
/
2
.
55f
)
)
g
(
static_cast
<
int
>
(
NS_GET_G
(
color
)
/
2
.
55f
)
)
b
(
static_cast
<
int
>
(
NS_GET_B
(
color
)
/
2
.
55f
)
)
;
nsAutoString
rs
(
NS_ConvertUTF8toUTF16
(
r
.
toString
(
)
)
)
;
nsAutoString
gs
(
NS_ConvertUTF8toUTF16
(
g
.
toString
(
)
)
)
;
nsAutoString
bs
(
NS_ConvertUTF8toUTF16
(
b
.
toString
(
)
)
)
;
Accessible
:
:
TranslateString
(
u
"
inputColorValue
"
_ns
aValue
{
rs
gs
bs
}
)
;
return
;
}
}
}
HyperTextAccessible
:
:
Value
(
aValue
)
;
}
uint64_t
HTMLButtonAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
HyperTextAccessible
:
:
NativeState
(
)
;
dom
:
:
Element
*
elm
=
Elm
(
)
;
if
(
auto
*
popover
=
elm
-
>
GetEffectivePopoverTargetElement
(
)
)
{
LocalAccessible
*
popoverAcc
=
mDoc
-
>
GetAccessible
(
popover
)
;
if
(
!
popoverAcc
|
|
!
popoverAcc
-
>
IsAncestorOf
(
this
)
)
{
if
(
popover
-
>
IsPopoverOpen
(
)
)
{
state
|
=
states
:
:
EXPANDED
;
}
state
|
=
states
:
:
EXPANDABLE
;
}
}
ElementState
elmState
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
elmState
.
HasState
(
ElementState
:
:
DEFAULT
)
)
state
|
=
states
:
:
DEFAULT
;
return
state
;
}
role
HTMLButtonAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
PUSHBUTTON
;
}
ENameValueFlag
HTMLButtonAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
ENameValueFlag
nameFlag
=
LocalAccessible
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
|
|
!
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
|
|
!
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
image
eCaseMatters
)
)
{
return
nameFlag
;
}
if
(
!
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
alt
aName
)
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
value
aName
)
;
}
aName
.
CompressWhitespace
(
)
;
return
eNameOK
;
}
void
HTMLButtonAccessible
:
:
DOMAttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
AttrModType
aModType
const
nsAttrValue
*
aOldValue
uint64_t
aOldState
)
{
HyperTextAccessible
:
:
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
aOldState
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
value
)
{
dom
:
:
Element
*
elm
=
Elm
(
)
;
if
(
elm
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
|
|
(
elm
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
image
eCaseMatters
)
&
&
!
elm
-
>
HasAttr
(
nsGkAtoms
:
:
alt
)
)
)
{
if
(
!
nsAccUtils
:
:
HasARIAAttr
(
elm
nsGkAtoms
:
:
aria_labelledby
)
&
&
!
nsAccUtils
:
:
HasARIAAttr
(
elm
nsGkAtoms
:
:
aria_label
)
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
this
)
;
}
}
}
}
bool
HTMLButtonAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
HTMLTextFieldAccessible
:
:
HTMLTextFieldAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessible
(
aContent
aDoc
)
{
mType
=
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
password
eIgnoreCase
)
?
eHTMLTextPasswordFieldType
:
eHTMLTextFieldType
;
}
role
HTMLTextFieldAccessible
:
:
NativeRole
(
)
const
{
if
(
mType
=
=
eHTMLTextPasswordFieldType
)
{
return
roles
:
:
PASSWORD_TEXT
;
}
dom
:
:
Element
*
el
=
mContent
-
>
AsElement
(
)
;
if
(
el
-
>
HasAttr
(
nsGkAtoms
:
:
list
)
)
{
return
roles
:
:
EDITCOMBOBOX
;
}
if
(
const
nsAttrValue
*
attr
=
el
-
>
GetParsedAttr
(
nsGkAtoms
:
:
type
)
)
{
RefPtr
<
nsAtom
>
inputType
=
attr
-
>
GetAsAtom
(
)
;
if
(
inputType
=
=
nsGkAtoms
:
:
search
)
{
return
roles
:
:
SEARCHBOX
;
}
}
return
roles
:
:
ENTRY
;
}
already_AddRefed
<
AccAttributes
>
HTMLTextFieldAccessible
:
:
NativeAttributes
(
)
{
RefPtr
<
AccAttributes
>
attributes
=
HyperTextAccessible
:
:
NativeAttributes
(
)
;
if
(
const
nsAttrValue
*
attr
=
mContent
-
>
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
type
)
)
{
RefPtr
<
nsAtom
>
inputType
=
attr
-
>
GetAsAtom
(
)
;
if
(
inputType
)
{
if
(
!
ARIARoleMap
(
)
&
&
inputType
=
=
nsGkAtoms
:
:
search
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
nsGkAtoms
:
:
searchbox
)
;
}
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
textInputType
inputType
)
;
}
}
nsString
placeholderText
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
placeholder
placeholderText
)
)
{
nsAutoString
name
;
Name
(
name
)
;
if
(
!
name
.
Equals
(
placeholderText
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
placeholder
std
:
:
move
(
placeholderText
)
)
;
}
}
return
attributes
.
forget
(
)
;
}
ENameValueFlag
HTMLTextFieldAccessible
:
:
DirectName
(
nsString
&
aName
)
const
{
ENameValueFlag
nameFlag
=
LocalAccessible
:
:
DirectName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
title
aName
)
;
aName
.
CompressWhitespace
(
)
;
if
(
aName
.
IsEmpty
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
placeholder
aName
)
;
}
return
eNameOK
;
}
void
HTMLTextFieldAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
aValue
.
Truncate
(
)
;
HTMLTextAreaElement
*
textArea
=
HTMLTextAreaElement
:
:
FromNode
(
mContent
)
;
if
(
textArea
)
{
MOZ_ASSERT
(
!
(
NativeState
(
)
&
states
:
:
PROTECTED
)
)
;
textArea
-
>
GetValue
(
aValue
)
;
return
;
}
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
if
(
input
)
{
input
-
>
GetValue
(
aValue
CallerType
:
:
NonSystem
)
;
if
(
NativeState
(
)
&
states
:
:
PROTECTED
)
{
const
char16_t
mask
=
TextEditor
:
:
PasswordMask
(
)
;
for
(
size_t
i
=
0
;
i
<
aValue
.
Length
(
)
;
i
+
+
)
{
aValue
.
SetCharAt
(
mask
i
)
;
}
}
}
}
bool
HTMLTextFieldAccessible
:
:
AttributeChangesState
(
nsAtom
*
aAttribute
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
readonly
|
|
aAttribute
=
=
nsGkAtoms
:
:
list
|
|
aAttribute
=
=
nsGkAtoms
:
:
autocomplete
)
{
return
true
;
}
return
LocalAccessible
:
:
AttributeChangesState
(
aAttribute
)
;
}
void
HTMLTextFieldAccessible
:
:
ApplyARIAState
(
uint64_t
*
aState
)
const
{
HyperTextAccessible
:
:
ApplyARIAState
(
aState
)
;
aria
:
:
MapToState
(
aria
:
:
eARIAAutoComplete
mContent
-
>
AsElement
(
)
aState
)
;
}
uint64_t
HTMLTextFieldAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
HyperTextAccessible
:
:
NativeState
(
)
;
state
|
=
states
:
:
EDITABLE
;
if
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
password
eIgnoreCase
)
)
{
state
|
=
states
:
:
PROTECTED
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
readonly
)
)
{
state
|
=
states
:
:
READONLY
;
}
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
state
|
=
input
&
&
input
-
>
IsSingleLineTextControl
(
)
?
states
:
:
SINGLE_LINE
:
states
:
:
MULTI_LINE
;
if
(
state
&
(
states
:
:
PROTECTED
|
states
:
:
MULTI_LINE
|
states
:
:
READONLY
|
states
:
:
UNAVAILABLE
)
)
{
return
state
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
list
)
)
{
return
state
|
states
:
:
SUPPORTS_AUTOCOMPLETION
|
states
:
:
HASPOPUP
;
}
if
(
Preferences
:
:
GetBool
(
"
browser
.
formfill
.
enable
"
)
)
{
nsAutoString
autocomplete
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
autocomplete
autocomplete
)
;
if
(
!
autocomplete
.
LowerCaseEqualsLiteral
(
"
off
"
)
)
{
Element
*
formElement
=
input
-
>
GetForm
(
)
;
if
(
formElement
)
{
formElement
-
>
GetAttr
(
nsGkAtoms
:
:
autocomplete
autocomplete
)
;
}
if
(
!
formElement
|
|
!
autocomplete
.
LowerCaseEqualsLiteral
(
"
off
"
)
)
{
state
|
=
states
:
:
SUPPORTS_AUTOCOMPLETION
;
}
}
}
return
state
;
}
bool
HTMLTextFieldAccessible
:
:
HasPrimaryAction
(
)
const
{
return
true
;
}
void
HTMLTextFieldAccessible
:
:
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
{
if
(
aIndex
=
=
eAction_Click
)
aName
.
AssignLiteral
(
"
activate
"
)
;
}
bool
HTMLTextFieldAccessible
:
:
DoAction
(
uint8_t
aIndex
)
const
{
if
(
aIndex
!
=
0
)
return
false
;
if
(
FocusMgr
(
)
-
>
IsFocused
(
this
)
)
{
DoCommand
(
)
;
}
else
{
TakeFocus
(
)
;
}
return
true
;
}
already_AddRefed
<
EditorBase
>
HTMLTextFieldAccessible
:
:
GetEditor
(
)
const
{
RefPtr
<
TextControlElement
>
textControlElement
=
TextControlElement
:
:
FromNodeOrNull
(
mContent
)
;
if
(
!
textControlElement
)
{
return
nullptr
;
}
RefPtr
<
TextEditor
>
textEditor
=
textControlElement
-
>
GetTextEditor
(
)
;
return
textEditor
.
forget
(
)
;
}
void
HTMLTextFieldAccessible
:
:
DOMAttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
AttrModType
aModType
const
nsAttrValue
*
aOldValue
uint64_t
aOldState
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
placeholder
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
NameAndDescription
)
;
return
;
}
HyperTextAccessible
:
:
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
aOldState
)
;
}
bool
HTMLTextFieldAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
LocalAccessible
*
HTMLTextFieldAccessible
:
:
ContainerWidget
(
)
const
{
return
nullptr
;
}
HTMLFileInputAccessible
:
:
HTMLFileInputAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessible
(
aContent
aDoc
)
{
mType
=
eHTMLFileInputType
;
mGenericTypes
|
=
eButton
;
}
role
HTMLFileInputAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
PUSHBUTTON
;
}
bool
HTMLFileInputAccessible
:
:
IsAcceptableChild
(
nsIContent
*
aEl
)
const
{
return
aEl
-
>
IsText
(
)
;
}
ENameValueFlag
HTMLFileInputAccessible
:
:
DirectName
(
nsString
&
aName
)
const
{
ENameValueFlag
flag
=
HyperTextAccessible
:
:
DirectName
(
aName
)
;
if
(
flag
=
=
eNameFromSubtree
)
{
aName
.
Truncate
(
)
;
}
else
{
if
(
aName
.
IsEmpty
(
)
)
{
aName
+
=
'
'
;
return
flag
;
}
}
uint32_t
count
=
ChildCount
(
)
;
for
(
uint32_t
c
=
0
;
c
<
count
;
+
+
c
)
{
TextLeafAccessible
*
leaf
=
LocalChildAt
(
c
)
-
>
AsTextLeaf
(
)
;
MOZ_ASSERT
(
leaf
)
;
if
(
!
aName
.
IsEmpty
(
)
)
{
aName
+
=
'
'
;
}
aName
+
=
leaf
-
>
Text
(
)
;
}
return
eNameOK
;
}
bool
HTMLFileInputAccessible
:
:
HasPrimaryAction
(
)
const
{
return
true
;
}
void
HTMLFileInputAccessible
:
:
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
{
if
(
aIndex
=
=
0
)
{
aName
.
AssignLiteral
(
"
press
"
)
;
}
}
bool
HTMLFileInputAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
role
HTMLSpinnerAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
SPINBUTTON
;
}
void
HTMLSpinnerAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
HTMLTextFieldAccessible
:
:
Value
(
aValue
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
return
;
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetValue
(
aValue
CallerType
:
:
NonSystem
)
;
}
double
HTMLSpinnerAccessible
:
:
MaxValue
(
)
const
{
double
value
=
HTMLTextFieldAccessible
:
:
MaxValue
(
)
;
if
(
!
std
:
:
isnan
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetMaximum
(
)
.
toDouble
(
)
;
}
double
HTMLSpinnerAccessible
:
:
MinValue
(
)
const
{
double
value
=
HTMLTextFieldAccessible
:
:
MinValue
(
)
;
if
(
!
std
:
:
isnan
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetMinimum
(
)
.
toDouble
(
)
;
}
double
HTMLSpinnerAccessible
:
:
Step
(
)
const
{
double
value
=
HTMLTextFieldAccessible
:
:
Step
(
)
;
if
(
!
std
:
:
isnan
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetStep
(
)
.
toDouble
(
)
;
}
double
HTMLSpinnerAccessible
:
:
CurValue
(
)
const
{
double
value
=
HTMLTextFieldAccessible
:
:
CurValue
(
)
;
if
(
!
std
:
:
isnan
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetValueAsDecimal
(
)
.
toDouble
(
)
;
}
bool
HTMLSpinnerAccessible
:
:
SetCurValue
(
double
aValue
)
{
ErrorResult
er
;
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
SetValueAsNumber
(
aValue
er
)
;
return
!
er
.
Failed
(
)
;
}
role
HTMLRangeAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
SLIDER
;
}
bool
HTMLRangeAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
void
HTMLRangeAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
LeafAccessible
:
:
Value
(
aValue
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
return
;
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetValue
(
aValue
CallerType
:
:
NonSystem
)
;
}
double
HTMLRangeAccessible
:
:
MaxValue
(
)
const
{
double
value
=
LeafAccessible
:
:
MaxValue
(
)
;
if
(
!
std
:
:
isnan
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetMaximum
(
)
.
toDouble
(
)
;
}
double
HTMLRangeAccessible
:
:
MinValue
(
)
const
{
double
value
=
LeafAccessible
:
:
MinValue
(
)
;
if
(
!
std
:
:
isnan
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetMinimum
(
)
.
toDouble
(
)
;
}
double
HTMLRangeAccessible
:
:
Step
(
)
const
{
double
value
=
LeafAccessible
:
:
Step
(
)
;
if
(
!
std
:
:
isnan
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetStep
(
)
.
toDouble
(
)
;
}
double
HTMLRangeAccessible
:
:
CurValue
(
)
const
{
double
value
=
LeafAccessible
:
:
CurValue
(
)
;
if
(
!
std
:
:
isnan
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetValueAsDecimal
(
)
.
toDouble
(
)
;
}
bool
HTMLRangeAccessible
:
:
SetCurValue
(
double
aValue
)
{
nsAutoString
strValue
;
strValue
.
AppendFloat
(
aValue
)
;
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
SetUserInput
(
strValue
*
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
return
true
;
}
HTMLGroupboxAccessible
:
:
HTMLGroupboxAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessible
(
aContent
aDoc
)
{
}
role
HTMLGroupboxAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
GROUPING
;
}
nsIContent
*
HTMLGroupboxAccessible
:
:
GetLegend
(
)
const
{
for
(
nsIContent
*
legendContent
=
mContent
-
>
GetFirstChild
(
)
;
legendContent
;
legendContent
=
legendContent
-
>
GetNextSibling
(
)
)
{
if
(
legendContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
legend
mContent
-
>
GetNameSpaceID
(
)
)
)
{
return
legendContent
;
}
}
return
nullptr
;
}
ENameValueFlag
HTMLGroupboxAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
ENameValueFlag
nameFlag
=
LocalAccessible
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
nsIContent
*
legendContent
=
GetLegend
(
)
;
if
(
legendContent
)
{
bool
usedHiddenContent
=
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
this
legendContent
&
aName
)
;
aName
.
CompressWhitespace
(
)
;
if
(
!
usedHiddenContent
&
&
!
aName
.
IsEmpty
(
)
)
{
return
eNameFromRelations
;
}
}
return
eNameOK
;
}
Relation
HTMLGroupboxAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
HyperTextAccessible
:
:
RelationByType
(
aType
)
;
if
(
aType
=
=
RelationType
:
:
LABELLED_BY
)
rel
.
AppendTarget
(
mDoc
GetLegend
(
)
)
;
return
rel
;
}
HTMLLegendAccessible
:
:
HTMLLegendAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessible
(
aContent
aDoc
)
{
}
Relation
HTMLLegendAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
HyperTextAccessible
:
:
RelationByType
(
aType
)
;
if
(
aType
!
=
RelationType
:
:
LABEL_FOR
)
return
rel
;
LocalAccessible
*
groupbox
=
LocalParent
(
)
;
if
(
groupbox
&
&
groupbox
-
>
Role
(
)
=
=
roles
:
:
GROUPING
)
{
rel
.
AppendTarget
(
groupbox
)
;
}
return
rel
;
}
HTMLFigureAccessible
:
:
HTMLFigureAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessible
(
aContent
aDoc
)
{
}
ENameValueFlag
HTMLFigureAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
ENameValueFlag
nameFlag
=
HyperTextAccessible
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
nsIContent
*
captionContent
=
Caption
(
)
;
if
(
captionContent
)
{
bool
usedHiddenContent
=
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
this
captionContent
&
aName
)
;
aName
.
CompressWhitespace
(
)
;
if
(
!
usedHiddenContent
&
&
!
aName
.
IsEmpty
(
)
)
{
return
eNameFromRelations
;
}
}
return
eNameOK
;
}
Relation
HTMLFigureAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
HyperTextAccessible
:
:
RelationByType
(
aType
)
;
if
(
aType
=
=
RelationType
:
:
LABELLED_BY
)
rel
.
AppendTarget
(
mDoc
Caption
(
)
)
;
return
rel
;
}
nsIContent
*
HTMLFigureAccessible
:
:
Caption
(
)
const
{
for
(
nsIContent
*
childContent
=
mContent
-
>
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
if
(
childContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
figcaption
mContent
-
>
GetNameSpaceID
(
)
)
)
{
return
childContent
;
}
}
return
nullptr
;
}
HTMLFigcaptionAccessible
:
:
HTMLFigcaptionAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessible
(
aContent
aDoc
)
{
}
Relation
HTMLFigcaptionAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
HyperTextAccessible
:
:
RelationByType
(
aType
)
;
if
(
aType
!
=
RelationType
:
:
LABEL_FOR
)
return
rel
;
LocalAccessible
*
figure
=
LocalParent
(
)
;
if
(
figure
&
&
figure
-
>
GetContent
(
)
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
figure
mContent
-
>
GetNameSpaceID
(
)
)
)
{
rel
.
AppendTarget
(
figure
)
;
}
return
rel
;
}
role
HTMLProgressAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
PROGRESSBAR
;
}
uint64_t
HTMLProgressAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
LeafAccessible
:
:
NativeState
(
)
;
state
|
=
states
:
:
READONLY
;
nsAutoString
attrValue
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
value
attrValue
)
;
if
(
attrValue
.
IsEmpty
(
)
)
{
state
|
=
states
:
:
MIXED
;
}
return
state
;
}
bool
HTMLProgressAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
void
HTMLProgressAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
LeafAccessible
:
:
Value
(
aValue
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
{
return
;
}
double
maxValue
=
MaxValue
(
)
;
if
(
std
:
:
isnan
(
maxValue
)
|
|
maxValue
=
=
0
)
{
return
;
}
double
curValue
=
CurValue
(
)
;
if
(
std
:
:
isnan
(
curValue
)
)
{
return
;
}
double
percentValue
=
(
curValue
<
maxValue
)
?
(
curValue
/
maxValue
)
*
100
:
100
;
aValue
.
AppendFloat
(
percentValue
)
;
aValue
.
Append
(
'
%
'
)
;
}
double
HTMLProgressAccessible
:
:
MaxValue
(
)
const
{
double
value
=
LeafAccessible
:
:
MaxValue
(
)
;
if
(
!
std
:
:
isnan
(
value
)
)
{
return
value
;
}
nsAutoString
strValue
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
max
strValue
)
)
{
nsresult
result
=
NS_OK
;
value
=
strValue
.
ToDouble
(
&
result
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
return
value
;
}
}
return
1
;
}
double
HTMLProgressAccessible
:
:
MinValue
(
)
const
{
double
value
=
LeafAccessible
:
:
MinValue
(
)
;
return
std
:
:
isnan
(
value
)
?
0
:
value
;
}
double
HTMLProgressAccessible
:
:
Step
(
)
const
{
double
value
=
LeafAccessible
:
:
Step
(
)
;
return
std
:
:
isnan
(
value
)
?
0
:
value
;
}
double
HTMLProgressAccessible
:
:
CurValue
(
)
const
{
double
value
=
LeafAccessible
:
:
CurValue
(
)
;
if
(
!
std
:
:
isnan
(
value
)
)
{
return
value
;
}
nsAutoString
attrValue
;
if
(
!
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
value
attrValue
)
)
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
nsresult
error
=
NS_OK
;
value
=
attrValue
.
ToDouble
(
&
error
)
;
return
NS_FAILED
(
error
)
?
UnspecifiedNaN
<
double
>
(
)
:
value
;
}
bool
HTMLProgressAccessible
:
:
SetCurValue
(
double
aValue
)
{
return
false
;
}
void
HTMLProgressAccessible
:
:
DOMAttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
AttrModType
aModType
const
nsAttrValue
*
aOldValue
uint64_t
aOldState
)
{
LeafAccessible
:
:
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
aOldState
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
value
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
this
)
;
uint64_t
currState
=
NativeState
(
)
;
if
(
(
aOldState
^
currState
)
&
states
:
:
MIXED
)
{
RefPtr
<
AccEvent
>
stateChangeEvent
=
new
AccStateChangeEvent
(
this
states
:
:
MIXED
(
currState
&
states
:
:
MIXED
)
)
;
mDoc
-
>
FireDelayedEvent
(
stateChangeEvent
)
;
}
}
}
role
HTMLMeterAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
METER
;
}
bool
HTMLMeterAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
void
HTMLMeterAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
LeafAccessible
:
:
Value
(
aValue
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
{
return
;
}
nsTextEquivUtils
:
:
AppendFromDOMChildren
(
mContent
&
aValue
)
;
aValue
.
CompressWhitespace
(
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
{
return
;
}
double
curValue
=
CurValue
(
)
;
if
(
std
:
:
isnan
(
curValue
)
)
{
return
;
}
aValue
.
AppendFloat
(
curValue
)
;
}
double
HTMLMeterAccessible
:
:
MaxValue
(
)
const
{
double
max
=
LeafAccessible
:
:
MaxValue
(
)
;
double
min
=
MinValue
(
)
;
if
(
!
std
:
:
isnan
(
max
)
)
{
return
max
>
min
?
max
:
min
;
}
nsAutoString
strValue
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
max
strValue
)
)
{
nsresult
result
=
NS_OK
;
max
=
strValue
.
ToDouble
(
&
result
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
return
max
>
min
?
max
:
min
;
}
}
return
1
>
min
?
1
:
min
;
}
double
HTMLMeterAccessible
:
:
MinValue
(
)
const
{
double
min
=
LeafAccessible
:
:
MinValue
(
)
;
if
(
!
std
:
:
isnan
(
min
)
)
{
return
min
;
}
nsAutoString
strValue
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
min
strValue
)
)
{
nsresult
result
=
NS_OK
;
min
=
strValue
.
ToDouble
(
&
result
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
return
min
;
}
}
return
0
;
}
double
HTMLMeterAccessible
:
:
CurValue
(
)
const
{
double
value
=
LeafAccessible
:
:
CurValue
(
)
;
double
minValue
=
MinValue
(
)
;
if
(
std
:
:
isnan
(
value
)
)
{
nsAutoString
attrValue
;
if
(
!
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
value
attrValue
)
)
{
return
minValue
;
}
nsresult
error
=
NS_OK
;
value
=
attrValue
.
ToDouble
(
&
error
)
;
if
(
NS_FAILED
(
error
)
)
{
return
minValue
;
}
}
double
maxValue
=
MaxValue
(
)
;
if
(
value
>
maxValue
)
{
value
=
maxValue
;
}
else
if
(
value
<
minValue
)
{
value
=
minValue
;
}
return
value
;
}
bool
HTMLMeterAccessible
:
:
SetCurValue
(
double
aValue
)
{
return
false
;
}
int32_t
HTMLMeterAccessible
:
:
ValueRegion
(
)
const
{
dom
:
:
HTMLMeterElement
*
elm
=
dom
:
:
HTMLMeterElement
:
:
FromNode
(
mContent
)
;
if
(
!
elm
)
{
return
-
1
;
}
double
high
=
elm
-
>
High
(
)
;
double
low
=
elm
-
>
Low
(
)
;
double
optimum
=
elm
-
>
Optimum
(
)
;
double
value
=
elm
-
>
Value
(
)
;
if
(
optimum
>
high
)
{
if
(
value
>
high
)
{
return
1
;
}
return
value
>
low
?
0
:
-
1
;
}
if
(
optimum
<
low
)
{
if
(
value
<
low
)
{
return
1
;
}
return
value
<
high
?
0
:
-
1
;
}
if
(
value
>
=
low
&
&
value
<
=
high
)
{
return
1
;
}
return
0
;
}
void
HTMLMeterAccessible
:
:
DOMAttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
AttrModType
aModType
const
nsAttrValue
*
aOldValue
uint64_t
aOldState
)
{
LeafAccessible
:
:
DOMAttributeChanged
(
aNameSpaceID
aAttribute
aModType
aOldValue
aOldState
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
value
)
{
mDoc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
this
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
high
|
|
aAttribute
=
=
nsGkAtoms
:
:
low
|
|
aAttribute
=
=
nsGkAtoms
:
:
optimum
)
{
mDoc
-
>
QueueCacheUpdate
(
this
CacheDomain
:
:
Value
)
;
return
;
}
}
