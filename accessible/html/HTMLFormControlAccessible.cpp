#
include
"
HTMLFormControlAccessible
.
h
"
#
include
"
Accessible
-
inl
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
nsTextEquivUtils
.
h
"
#
include
"
Relation
.
h
"
#
include
"
Role
.
h
"
#
include
"
States
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsIPersistentProperties2
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsITextControlElement
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
a11y
;
role
HTMLFormAccessible
:
:
NativeRole
(
)
const
{
nsAutoString
name
;
const_cast
<
HTMLFormAccessible
*
>
(
this
)
-
>
Name
(
name
)
;
return
name
.
IsEmpty
(
)
?
roles
:
:
FORM
:
roles
:
:
FORM_LANDMARK
;
}
nsAtom
*
HTMLFormAccessible
:
:
LandmarkRole
(
)
const
{
if
(
!
HasOwnContent
(
)
)
{
return
nullptr
;
}
nsAutoString
name
;
const_cast
<
HTMLFormAccessible
*
>
(
this
)
-
>
Name
(
name
)
;
return
name
.
IsEmpty
(
)
?
nullptr
:
nsGkAtoms
:
:
form
;
}
uint64_t
HTMLRadioButtonAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
AccessibleWrap
:
:
NativeState
(
)
;
state
|
=
states
:
:
CHECKABLE
;
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
if
(
input
&
&
input
-
>
Checked
(
)
)
state
|
=
states
:
:
CHECKED
;
return
state
;
}
void
HTMLRadioButtonAccessible
:
:
GetPositionAndSizeInternal
(
int32_t
*
aPosInSet
int32_t
*
aSetSize
)
{
int32_t
namespaceId
=
mContent
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
;
nsAutoString
tagName
;
mContent
-
>
NodeInfo
(
)
-
>
GetName
(
tagName
)
;
nsAutoString
type
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
)
;
nsAutoString
name
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
RefPtr
<
nsContentList
>
inputElms
;
nsCOMPtr
<
nsIFormControl
>
formControlNode
(
do_QueryInterface
(
mContent
)
)
;
dom
:
:
Element
*
formElm
=
formControlNode
-
>
GetFormElement
(
)
;
if
(
formElm
)
inputElms
=
NS_GetContentList
(
formElm
namespaceId
tagName
)
;
else
inputElms
=
NS_GetContentList
(
mContent
-
>
OwnerDoc
(
)
namespaceId
tagName
)
;
NS_ENSURE_TRUE_VOID
(
inputElms
)
;
uint32_t
inputCount
=
inputElms
-
>
Length
(
false
)
;
int32_t
indexOf
=
0
;
int32_t
count
=
0
;
for
(
uint32_t
index
=
0
;
index
<
inputCount
;
index
+
+
)
{
nsIContent
*
inputElm
=
inputElms
-
>
Item
(
index
false
)
;
if
(
inputElm
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
eCaseMatters
)
&
&
inputElm
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
eCaseMatters
)
&
&
mDoc
-
>
HasAccessible
(
inputElm
)
)
{
count
+
+
;
if
(
inputElm
=
=
mContent
)
indexOf
=
count
;
}
}
*
aPosInSet
=
indexOf
;
*
aSetSize
=
count
;
}
HTMLButtonAccessible
:
:
HTMLButtonAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
mGenericTypes
|
=
eButton
;
}
uint8_t
HTMLButtonAccessible
:
:
ActionCount
(
)
const
{
return
1
;
}
void
HTMLButtonAccessible
:
:
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
{
if
(
aIndex
=
=
eAction_Click
)
aName
.
AssignLiteral
(
"
press
"
)
;
}
bool
HTMLButtonAccessible
:
:
DoAction
(
uint8_t
aIndex
)
const
{
if
(
aIndex
!
=
eAction_Click
)
return
false
;
DoCommand
(
)
;
return
true
;
}
uint64_t
HTMLButtonAccessible
:
:
State
(
)
{
uint64_t
state
=
HyperTextAccessibleWrap
:
:
State
(
)
;
if
(
state
=
=
states
:
:
DEFUNCT
)
return
state
;
if
(
mParent
&
&
mParent
-
>
IsHTMLFileInput
(
)
)
{
uint64_t
parentState
=
mParent
-
>
State
(
)
;
state
|
=
parentState
&
(
states
:
:
BUSY
|
states
:
:
REQUIRED
|
states
:
:
HASPOPUP
|
states
:
:
INVALID
)
;
}
return
state
;
}
uint64_t
HTMLButtonAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
HyperTextAccessibleWrap
:
:
NativeState
(
)
;
EventStates
elmState
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
elmState
.
HasState
(
NS_EVENT_STATE_DEFAULT
)
)
state
|
=
states
:
:
DEFAULT
;
return
state
;
}
role
HTMLButtonAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
PUSHBUTTON
;
}
ENameValueFlag
HTMLButtonAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
ENameValueFlag
nameFlag
=
Accessible
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
|
|
!
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
|
|
!
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
image
eCaseMatters
)
)
return
nameFlag
;
if
(
!
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
alt
aName
)
)
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
aName
)
;
aName
.
CompressWhitespace
(
)
;
return
eNameOK
;
}
bool
HTMLButtonAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
HTMLTextFieldAccessible
:
:
HTMLTextFieldAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
mType
=
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
password
eIgnoreCase
)
?
eHTMLTextPasswordFieldType
:
eHTMLTextFieldType
;
}
role
HTMLTextFieldAccessible
:
:
NativeRole
(
)
const
{
if
(
mType
=
=
eHTMLTextPasswordFieldType
)
{
return
roles
:
:
PASSWORD_TEXT
;
}
return
roles
:
:
ENTRY
;
}
already_AddRefed
<
nsIPersistentProperties
>
HTMLTextFieldAccessible
:
:
NativeAttributes
(
)
{
nsCOMPtr
<
nsIPersistentProperties
>
attributes
=
HyperTextAccessibleWrap
:
:
NativeAttributes
(
)
;
nsAutoString
type
;
nsIContent
*
widgetElm
=
BindingOrWidgetParent
(
)
;
if
(
(
widgetElm
&
&
widgetElm
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
)
)
|
|
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
)
)
{
nsAccUtils
:
:
SetAccAttr
(
attributes
nsGkAtoms
:
:
textInputType
type
)
;
if
(
!
ARIARoleMap
(
)
&
&
type
.
EqualsLiteral
(
"
search
"
)
)
{
nsAccUtils
:
:
SetAccAttr
(
attributes
nsGkAtoms
:
:
xmlroles
NS_LITERAL_STRING
(
"
searchbox
"
)
)
;
}
}
nsAutoString
placeholderText
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
placeholder
placeholderText
)
)
{
nsAutoString
name
;
const_cast
<
HTMLTextFieldAccessible
*
>
(
this
)
-
>
Name
(
name
)
;
if
(
!
name
.
Equals
(
placeholderText
)
)
{
nsAccUtils
:
:
SetAccAttr
(
attributes
nsGkAtoms
:
:
placeholder
placeholderText
)
;
}
}
return
attributes
.
forget
(
)
;
}
ENameValueFlag
HTMLTextFieldAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
ENameValueFlag
nameFlag
=
Accessible
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
nsIContent
*
widgetElm
=
BindingOrWidgetParent
(
)
;
if
(
widgetElm
)
XULElmName
(
mDoc
widgetElm
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
eNameOK
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
placeholder
aName
)
;
return
eNameOK
;
}
void
HTMLTextFieldAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
aValue
.
Truncate
(
)
;
if
(
NativeState
(
)
&
states
:
:
PROTECTED
)
return
;
HTMLTextAreaElement
*
textArea
=
HTMLTextAreaElement
:
:
FromNode
(
mContent
)
;
if
(
textArea
)
{
textArea
-
>
GetValue
(
aValue
)
;
return
;
}
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
if
(
input
)
{
input
-
>
GetValue
(
aValue
CallerType
:
:
NonSystem
)
;
}
}
void
HTMLTextFieldAccessible
:
:
ApplyARIAState
(
uint64_t
*
aState
)
const
{
HyperTextAccessibleWrap
:
:
ApplyARIAState
(
aState
)
;
aria
:
:
MapToState
(
aria
:
:
eARIAAutoComplete
mContent
-
>
AsElement
(
)
aState
)
;
nsIContent
*
widgetElm
=
BindingOrWidgetParent
(
)
;
if
(
widgetElm
)
aria
:
:
MapToState
(
aria
:
:
eARIAAutoComplete
widgetElm
-
>
AsElement
(
)
aState
)
;
}
uint64_t
HTMLTextFieldAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
HyperTextAccessibleWrap
:
:
NativeState
(
)
;
state
|
=
states
:
:
EDITABLE
;
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
password
eIgnoreCase
)
)
{
state
|
=
states
:
:
PROTECTED
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
readonly
)
)
{
state
|
=
states
:
:
READONLY
;
}
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
state
|
=
input
&
&
input
-
>
IsSingleLineTextControl
(
)
?
states
:
:
SINGLE_LINE
:
states
:
:
MULTI_LINE
;
if
(
state
&
(
states
:
:
PROTECTED
|
states
:
:
MULTI_LINE
|
states
:
:
READONLY
|
states
:
:
UNAVAILABLE
)
)
return
state
;
Accessible
*
widget
=
ContainerWidget
(
)
;
if
(
widget
&
&
widget
-
IsAutoComplete
(
)
)
{
state
|
=
states
:
:
HASPOPUP
|
states
:
:
SUPPORTS_AUTOCOMPLETION
;
return
state
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
list_
)
)
return
state
|
states
:
:
SUPPORTS_AUTOCOMPLETION
|
states
:
:
HASPOPUP
;
if
(
!
BindingOrWidgetParent
(
)
&
&
Preferences
:
:
GetBool
(
"
browser
.
formfill
.
enable
"
)
)
{
nsAutoString
autocomplete
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autocomplete
autocomplete
)
;
if
(
!
autocomplete
.
LowerCaseEqualsLiteral
(
"
off
"
)
)
{
Element
*
formElement
=
input
-
>
GetFormElement
(
)
;
if
(
formElement
)
{
formElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autocomplete
autocomplete
)
;
}
if
(
!
formElement
|
|
!
autocomplete
.
LowerCaseEqualsLiteral
(
"
off
"
)
)
state
|
=
states
:
:
SUPPORTS_AUTOCOMPLETION
;
}
}
return
state
;
}
uint8_t
HTMLTextFieldAccessible
:
:
ActionCount
(
)
const
{
return
1
;
}
void
HTMLTextFieldAccessible
:
:
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
{
if
(
aIndex
=
=
eAction_Click
)
aName
.
AssignLiteral
(
"
activate
"
)
;
}
bool
HTMLTextFieldAccessible
:
:
DoAction
(
uint8_t
aIndex
)
const
{
if
(
aIndex
!
=
0
)
return
false
;
TakeFocus
(
)
;
return
true
;
}
already_AddRefed
<
TextEditor
>
HTMLTextFieldAccessible
:
:
GetEditor
(
)
const
{
nsCOMPtr
<
nsITextControlElement
>
textControlElement
=
do_QueryInterface
(
mContent
)
;
if
(
!
textControlElement
)
{
return
nullptr
;
}
RefPtr
<
TextEditor
>
textEditor
=
textControlElement
-
>
GetTextEditor
(
)
;
return
textEditor
.
forget
(
)
;
}
bool
HTMLTextFieldAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
Accessible
*
HTMLTextFieldAccessible
:
:
ContainerWidget
(
)
const
{
if
(
!
mParent
|
|
mParent
-
>
Role
(
)
!
=
roles
:
:
AUTOCOMPLETE
)
{
return
nullptr
;
}
return
mParent
;
}
HTMLFileInputAccessible
:
:
HTMLFileInputAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
mType
=
eHTMLFileInputType
;
}
role
HTMLFileInputAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
TEXT_CONTAINER
;
}
nsresult
HTMLFileInputAccessible
:
:
HandleAccEvent
(
AccEvent
*
aEvent
)
{
nsresult
rv
=
HyperTextAccessibleWrap
:
:
HandleAccEvent
(
aEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AccStateChangeEvent
*
event
=
downcast_accEvent
(
aEvent
)
;
if
(
event
&
&
(
event
-
>
GetState
(
)
=
=
states
:
:
BUSY
|
|
event
-
>
GetState
(
)
=
=
states
:
:
REQUIRED
|
|
event
-
>
GetState
(
)
=
=
states
:
:
HASPOPUP
|
|
event
-
>
GetState
(
)
=
=
states
:
:
INVALID
)
)
{
Accessible
*
button
=
GetChildAt
(
0
)
;
if
(
button
&
&
button
-
>
Role
(
)
=
=
roles
:
:
PUSHBUTTON
)
{
RefPtr
<
AccStateChangeEvent
>
childEvent
=
new
AccStateChangeEvent
(
button
event
-
>
GetState
(
)
event
-
>
IsStateEnabled
(
)
event
-
>
FromUserInput
(
)
)
;
nsEventShell
:
:
FireEvent
(
childEvent
)
;
}
}
return
NS_OK
;
}
Accessible
*
HTMLFileInputAccessible
:
:
CurrentItem
(
)
const
{
if
(
Accessible
*
item
=
HyperTextAccessibleWrap
:
:
CurrentItem
(
)
)
{
return
item
;
}
Accessible
*
button
=
FirstChild
(
)
;
if
(
!
button
)
{
MOZ_ASSERT_UNREACHABLE
(
"
File
input
doesn
'
t
contain
a
button
"
)
;
return
nullptr
;
}
MOZ_ASSERT
(
button
-
>
IsButton
(
)
)
;
return
button
;
}
role
HTMLSpinnerAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
SPINBUTTON
;
}
void
HTMLSpinnerAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
AccessibleWrap
:
:
Value
(
aValue
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
return
;
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetValue
(
aValue
CallerType
:
:
NonSystem
)
;
}
double
HTMLSpinnerAccessible
:
:
MaxValue
(
)
const
{
double
value
=
AccessibleWrap
:
:
MaxValue
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetMaximum
(
)
.
toDouble
(
)
;
}
double
HTMLSpinnerAccessible
:
:
MinValue
(
)
const
{
double
value
=
AccessibleWrap
:
:
MinValue
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetMinimum
(
)
.
toDouble
(
)
;
}
double
HTMLSpinnerAccessible
:
:
Step
(
)
const
{
double
value
=
AccessibleWrap
:
:
Step
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetStep
(
)
.
toDouble
(
)
;
}
double
HTMLSpinnerAccessible
:
:
CurValue
(
)
const
{
double
value
=
AccessibleWrap
:
:
CurValue
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetValueAsDecimal
(
)
.
toDouble
(
)
;
}
bool
HTMLSpinnerAccessible
:
:
SetCurValue
(
double
aValue
)
{
ErrorResult
er
;
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
SetValueAsNumber
(
aValue
er
)
;
return
!
er
.
Failed
(
)
;
}
role
HTMLRangeAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
SLIDER
;
}
bool
HTMLRangeAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
void
HTMLRangeAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
LeafAccessible
:
:
Value
(
aValue
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
return
;
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetValue
(
aValue
CallerType
:
:
NonSystem
)
;
}
double
HTMLRangeAccessible
:
:
MaxValue
(
)
const
{
double
value
=
LeafAccessible
:
:
MaxValue
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetMaximum
(
)
.
toDouble
(
)
;
}
double
HTMLRangeAccessible
:
:
MinValue
(
)
const
{
double
value
=
LeafAccessible
:
:
MinValue
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetMinimum
(
)
.
toDouble
(
)
;
}
double
HTMLRangeAccessible
:
:
Step
(
)
const
{
double
value
=
LeafAccessible
:
:
Step
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetStep
(
)
.
toDouble
(
)
;
}
double
HTMLRangeAccessible
:
:
CurValue
(
)
const
{
double
value
=
LeafAccessible
:
:
CurValue
(
)
;
if
(
!
IsNaN
(
value
)
)
return
value
;
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
GetValueAsDecimal
(
)
.
toDouble
(
)
;
}
bool
HTMLRangeAccessible
:
:
SetCurValue
(
double
aValue
)
{
ErrorResult
er
;
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
SetValueAsNumber
(
aValue
er
)
;
return
!
er
.
Failed
(
)
;
}
HTMLGroupboxAccessible
:
:
HTMLGroupboxAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
}
role
HTMLGroupboxAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
GROUPING
;
}
nsIContent
*
HTMLGroupboxAccessible
:
:
GetLegend
(
)
const
{
for
(
nsIContent
*
legendContent
=
mContent
-
>
GetFirstChild
(
)
;
legendContent
;
legendContent
=
legendContent
-
>
GetNextSibling
(
)
)
{
if
(
legendContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
legend
mContent
-
>
GetNameSpaceID
(
)
)
)
{
return
legendContent
;
}
}
return
nullptr
;
}
ENameValueFlag
HTMLGroupboxAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
ENameValueFlag
nameFlag
=
Accessible
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
nsIContent
*
legendContent
=
GetLegend
(
)
;
if
(
legendContent
)
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
this
legendContent
&
aName
)
;
return
eNameOK
;
}
Relation
HTMLGroupboxAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
HyperTextAccessibleWrap
:
:
RelationByType
(
aType
)
;
if
(
aType
=
=
RelationType
:
:
LABELLED_BY
)
rel
.
AppendTarget
(
mDoc
GetLegend
(
)
)
;
return
rel
;
}
HTMLLegendAccessible
:
:
HTMLLegendAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
}
Relation
HTMLLegendAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
HyperTextAccessibleWrap
:
:
RelationByType
(
aType
)
;
if
(
aType
!
=
RelationType
:
:
LABEL_FOR
)
return
rel
;
Accessible
*
groupbox
=
Parent
(
)
;
if
(
groupbox
&
&
groupbox
-
>
Role
(
)
=
=
roles
:
:
GROUPING
)
rel
.
AppendTarget
(
groupbox
)
;
return
rel
;
}
HTMLFigureAccessible
:
:
HTMLFigureAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
}
ENameValueFlag
HTMLFigureAccessible
:
:
NativeName
(
nsString
&
aName
)
const
{
ENameValueFlag
nameFlag
=
HyperTextAccessibleWrap
:
:
NativeName
(
aName
)
;
if
(
!
aName
.
IsEmpty
(
)
)
return
nameFlag
;
nsIContent
*
captionContent
=
Caption
(
)
;
if
(
captionContent
)
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
this
captionContent
&
aName
)
;
return
eNameOK
;
}
Relation
HTMLFigureAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
HyperTextAccessibleWrap
:
:
RelationByType
(
aType
)
;
if
(
aType
=
=
RelationType
:
:
LABELLED_BY
)
rel
.
AppendTarget
(
mDoc
Caption
(
)
)
;
return
rel
;
}
nsIContent
*
HTMLFigureAccessible
:
:
Caption
(
)
const
{
for
(
nsIContent
*
childContent
=
mContent
-
>
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
if
(
childContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
figcaption
mContent
-
>
GetNameSpaceID
(
)
)
)
{
return
childContent
;
}
}
return
nullptr
;
}
HTMLFigcaptionAccessible
:
:
HTMLFigcaptionAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
:
HyperTextAccessibleWrap
(
aContent
aDoc
)
{
}
Relation
HTMLFigcaptionAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
Relation
rel
=
HyperTextAccessibleWrap
:
:
RelationByType
(
aType
)
;
if
(
aType
!
=
RelationType
:
:
LABEL_FOR
)
return
rel
;
Accessible
*
figure
=
Parent
(
)
;
if
(
figure
&
&
figure
-
>
GetContent
(
)
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
figure
mContent
-
>
GetNameSpaceID
(
)
)
)
{
rel
.
AppendTarget
(
figure
)
;
}
return
rel
;
}
role
HTMLProgressAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
PROGRESSBAR
;
}
uint64_t
HTMLProgressAccessible
:
:
NativeState
(
)
const
{
uint64_t
state
=
LeafAccessible
:
:
NativeState
(
)
;
nsAutoString
attrValue
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
attrValue
)
;
if
(
attrValue
.
IsEmpty
(
)
)
{
state
|
=
states
:
:
MIXED
;
}
return
state
;
}
bool
HTMLProgressAccessible
:
:
IsWidget
(
)
const
{
return
true
;
}
void
HTMLProgressAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
LeafAccessible
:
:
Value
(
aValue
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
{
return
;
}
double
maxValue
=
MaxValue
(
)
;
if
(
IsNaN
(
maxValue
)
|
|
maxValue
=
=
0
)
{
return
;
}
double
curValue
=
CurValue
(
)
;
if
(
IsNaN
(
curValue
)
)
{
return
;
}
double
percentValue
=
(
curValue
<
maxValue
)
?
(
curValue
/
maxValue
)
*
100
:
100
;
aValue
.
AppendFloat
(
percentValue
)
;
aValue
.
Append
(
'
%
'
)
;
}
double
HTMLProgressAccessible
:
:
MaxValue
(
)
const
{
double
value
=
LeafAccessible
:
:
MaxValue
(
)
;
if
(
!
IsNaN
(
value
)
)
{
return
value
;
}
nsAutoString
strValue
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
max
strValue
)
)
{
nsresult
result
=
NS_OK
;
value
=
strValue
.
ToDouble
(
&
result
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
return
value
;
}
}
return
1
;
}
double
HTMLProgressAccessible
:
:
MinValue
(
)
const
{
double
value
=
LeafAccessible
:
:
MinValue
(
)
;
return
IsNaN
(
value
)
?
0
:
value
;
}
double
HTMLProgressAccessible
:
:
Step
(
)
const
{
double
value
=
LeafAccessible
:
:
Step
(
)
;
return
IsNaN
(
value
)
?
0
:
value
;
}
double
HTMLProgressAccessible
:
:
CurValue
(
)
const
{
double
value
=
LeafAccessible
:
:
CurValue
(
)
;
if
(
!
IsNaN
(
value
)
)
{
return
value
;
}
nsAutoString
attrValue
;
if
(
!
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
attrValue
)
)
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
nsresult
error
=
NS_OK
;
value
=
attrValue
.
ToDouble
(
&
error
)
;
return
NS_FAILED
(
error
)
?
UnspecifiedNaN
<
double
>
(
)
:
value
;
}
bool
HTMLProgressAccessible
:
:
SetCurValue
(
double
aValue
)
{
return
false
;
}
