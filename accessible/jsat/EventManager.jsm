"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Utils
"
"
resource
:
/
/
gre
/
modules
/
accessibility
/
Utils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Logger
"
"
resource
:
/
/
gre
/
modules
/
accessibility
/
Utils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Roles
"
"
resource
:
/
/
gre
/
modules
/
accessibility
/
Constants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Events
"
"
resource
:
/
/
gre
/
modules
/
accessibility
/
Constants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
States
"
"
resource
:
/
/
gre
/
modules
/
accessibility
/
Constants
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
EventManager
"
]
;
function
EventManager
(
aContentScope
)
{
this
.
contentScope
=
aContentScope
;
this
.
addEventListener
=
this
.
contentScope
.
addEventListener
.
bind
(
this
.
contentScope
)
;
this
.
removeEventListener
=
this
.
contentScope
.
removeEventListener
.
bind
(
this
.
contentScope
)
;
this
.
sendMsgFunc
=
this
.
contentScope
.
sendAsyncMessage
.
bind
(
this
.
contentScope
)
;
}
this
.
EventManager
.
prototype
=
{
start
:
function
start
(
)
{
try
{
if
(
!
this
.
_started
)
{
Logger
.
debug
(
"
EventManager
.
start
"
)
;
this
.
_started
=
true
;
AccessibilityEventObserver
.
addListener
(
this
)
;
this
.
_preDialogPosition
=
new
WeakMap
(
)
;
}
}
catch
(
x
)
{
Logger
.
logException
(
x
"
Failed
to
start
EventManager
"
)
;
}
}
stop
:
function
stop
(
)
{
if
(
!
this
.
_started
)
{
return
;
}
Logger
.
debug
(
"
EventManager
.
stop
"
)
;
AccessibilityEventObserver
.
removeListener
(
this
)
;
try
{
this
.
_preDialogPosition
=
new
WeakMap
(
)
;
}
catch
(
x
)
{
}
finally
{
this
.
_started
=
false
;
}
}
get
contentControl
(
)
{
return
this
.
contentScope
.
_jsat_contentControl
;
}
handleAccEvent
:
function
handleAccEvent
(
aEvent
)
{
Logger
.
debug
(
(
)
=
>
{
return
[
"
A11yEvent
"
Logger
.
eventToString
(
aEvent
)
Logger
.
accessibleToString
(
aEvent
.
accessible
)
]
;
}
)
;
if
(
Utils
.
MozBuildApp
=
=
"
browser
"
&
&
aEvent
.
eventType
!
=
Events
.
VIRTUALCURSOR_CHANGED
&
&
(
aEvent
.
accessibleDocument
.
DOMDocument
.
doctype
&
&
aEvent
.
accessibleDocument
.
DOMDocument
.
doctype
.
name
=
=
=
"
window
"
)
)
{
return
;
}
switch
(
aEvent
.
eventType
)
{
case
Events
.
VIRTUALCURSOR_CHANGED
:
{
if
(
!
aEvent
.
isFromUserInput
)
{
break
;
}
const
event
=
aEvent
.
QueryInterface
(
Ci
.
nsIAccessibleVirtualCursorChangeEvent
)
;
const
position
=
event
.
newAccessible
;
if
(
position
&
&
position
.
role
=
=
Roles
.
INTERNAL_FRAME
)
{
break
;
}
if
(
!
position
|
|
!
Utils
.
getState
(
position
)
.
contains
(
States
.
FOCUSED
)
)
{
aEvent
.
accessibleDocument
.
takeFocus
(
)
;
}
break
;
}
case
Events
.
NAME_CHANGE
:
{
break
;
}
case
Events
.
SCROLLING_START
:
{
this
.
contentControl
.
autoMove
(
aEvent
.
accessible
)
;
break
;
}
case
Events
.
SHOW
:
{
break
;
}
case
Events
.
HIDE
:
{
break
;
}
case
Events
.
VALUE_CHANGE
:
{
break
;
}
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsISupportsWeakReference
Ci
.
nsIObserver
]
)
}
;
const
AccessibilityEventObserver
=
{
eventManagers
:
new
WeakMap
(
)
listenerCount
:
0
started
:
false
start
:
function
start
(
)
{
if
(
this
.
started
|
|
this
.
listenerCount
=
=
=
0
)
{
return
;
}
Services
.
obs
.
addObserver
(
this
"
accessible
-
event
"
)
;
this
.
started
=
true
;
}
stop
:
function
stop
(
)
{
if
(
!
this
.
started
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
"
accessible
-
event
"
)
;
this
.
eventManagers
=
new
WeakMap
(
)
;
this
.
listenerCount
=
0
;
this
.
started
=
false
;
}
addListener
:
function
addListener
(
aEventManager
)
{
let
content
=
aEventManager
.
contentScope
.
content
;
if
(
!
this
.
eventManagers
.
has
(
content
)
)
{
this
.
listenerCount
+
+
;
}
this
.
eventManagers
.
set
(
content
aEventManager
)
;
Logger
.
debug
(
"
AccessibilityEventObserver
.
addListener
.
Total
:
"
this
.
listenerCount
)
;
this
.
start
(
)
;
}
removeListener
:
function
removeListener
(
aEventManager
)
{
let
content
=
aEventManager
.
contentScope
.
content
;
if
(
!
this
.
eventManagers
.
delete
(
content
)
)
{
return
;
}
this
.
listenerCount
-
-
;
Logger
.
debug
(
"
AccessibilityEventObserver
.
removeListener
.
Total
:
"
this
.
listenerCount
)
;
if
(
this
.
listenerCount
=
=
=
0
)
{
this
.
stop
(
)
;
}
}
getListener
:
function
getListener
(
content
)
{
let
eventManager
=
this
.
eventManagers
.
get
(
content
)
;
if
(
eventManager
)
{
return
eventManager
;
}
let
parent
=
content
.
parent
;
if
(
parent
=
=
=
content
)
{
return
null
;
}
return
this
.
getListener
(
parent
)
;
}
observe
:
function
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
!
=
=
"
accessible
-
event
"
)
{
return
;
}
let
event
=
aSubject
.
QueryInterface
(
Ci
.
nsIAccessibleEvent
)
;
if
(
!
event
.
accessibleDocument
)
{
Logger
.
warning
(
"
AccessibilityEventObserver
.
observe
:
no
accessible
document
:
"
Logger
.
eventToString
(
event
)
"
accessible
:
"
Logger
.
accessibleToString
(
event
.
accessible
)
)
;
return
;
}
let
content
;
try
{
content
=
event
.
accessibleDocument
.
window
;
}
catch
(
e
)
{
Logger
.
warning
(
"
AccessibilityEventObserver
.
observe
:
no
window
for
accessible
document
:
"
Logger
.
eventToString
(
event
)
"
accessible
:
"
Logger
.
accessibleToString
(
event
.
accessible
)
)
;
return
;
}
let
eventManager
=
this
.
getListener
(
content
)
;
if
(
!
eventManager
|
|
!
eventManager
.
_started
)
{
if
(
Utils
.
MozBuildApp
=
=
=
"
browser
"
&
&
!
content
.
isChromeWindow
)
{
Logger
.
warning
(
"
AccessibilityEventObserver
.
observe
:
ignored
event
:
"
Logger
.
eventToString
(
event
)
"
accessible
:
"
Logger
.
accessibleToString
(
event
.
accessible
)
"
document
:
"
Logger
.
accessibleToString
(
event
.
accessibleDocument
)
)
;
}
return
;
}
try
{
eventManager
.
handleAccEvent
(
event
)
;
}
catch
(
x
)
{
Logger
.
logException
(
x
"
Error
handing
accessible
event
"
)
;
}
finally
{
return
;
}
}
}
;
