"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
accessibility
/
Utils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PivotContext
"
"
resource
:
/
/
gre
/
modules
/
accessibility
/
Utils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UtteranceGenerator
"
"
resource
:
/
/
gre
/
modules
/
accessibility
/
OutputGenerator
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
States
"
"
resource
:
/
/
gre
/
modules
/
accessibility
/
Constants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Roles
"
"
resource
:
/
/
gre
/
modules
/
accessibility
/
Constants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AndroidEvents
"
"
resource
:
/
/
gre
/
modules
/
accessibility
/
Constants
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
Presentation
"
]
;
const
EDIT_TEXT_ROLES
=
new
Set
(
[
Roles
.
SPINBUTTON
Roles
.
PASSWORD_TEXT
Roles
.
AUTOCOMPLETE
Roles
.
ENTRY
Roles
.
EDITCOMBOBOX
]
)
;
class
AndroidPresentor
{
constructor
(
)
{
this
.
type
=
"
Android
"
;
this
.
displayedAccessibles
=
new
WeakMap
(
)
;
}
pivotChanged
(
aPosition
aOldPosition
aStartOffset
aEndOffset
aReason
aBoundaryType
)
{
let
context
=
new
PivotContext
(
aPosition
aOldPosition
aStartOffset
aEndOffset
)
;
if
(
!
context
.
accessible
)
{
return
null
;
}
let
androidEvents
=
[
]
;
const
isExploreByTouch
=
aReason
=
=
Ci
.
nsIAccessiblePivot
.
REASON_POINT
;
if
(
isExploreByTouch
)
{
androidEvents
.
push
(
{
eventType
:
AndroidEvents
.
VIEW_HOVER_EXIT
text
:
[
]
}
)
;
}
if
(
aPosition
!
=
aOldPosition
)
{
let
info
=
this
.
_infoFromContext
(
context
)
;
let
eventType
=
isExploreByTouch
?
AndroidEvents
.
VIEW_HOVER_ENTER
:
AndroidEvents
.
VIEW_ACCESSIBILITY_FOCUSED
;
androidEvents
.
push
(
{
.
.
.
info
eventType
}
)
;
try
{
context
.
accessibleForBounds
.
scrollTo
(
Ci
.
nsIAccessibleScrollType
.
SCROLL_TYPE_ANYWHERE
)
;
}
catch
(
e
)
{
}
}
if
(
aBoundaryType
!
=
Ci
.
nsIAccessiblePivot
.
NO_BOUNDARY
)
{
const
adjustedText
=
context
.
textAndAdjustedOffsets
;
androidEvents
.
push
(
{
eventType
:
AndroidEvents
.
VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY
text
:
[
adjustedText
.
text
]
fromIndex
:
adjustedText
.
startOffset
toIndex
:
adjustedText
.
endOffset
}
)
;
aPosition
.
QueryInterface
(
Ci
.
nsIAccessibleText
)
.
scrollSubstringTo
(
aStartOffset
aEndOffset
Ci
.
nsIAccessibleScrollType
.
SCROLL_TYPE_ANYWHERE
)
;
}
if
(
context
.
accessible
)
{
this
.
displayedAccessibles
.
set
(
context
.
accessible
.
document
.
window
context
)
;
}
return
androidEvents
;
}
focused
(
aObject
)
{
let
info
=
this
.
_infoFromContext
(
new
PivotContext
(
aObject
null
-
1
-
1
true
false
)
)
;
return
[
{
eventType
:
AndroidEvents
.
VIEW_FOCUSED
.
.
.
info
}
]
;
}
checked
(
aAccessible
)
{
return
[
{
eventType
:
AndroidEvents
.
VIEW_CLICKED
checked
:
Utils
.
getState
(
aAccessible
)
.
contains
(
States
.
CHECKED
)
}
]
;
}
selected
(
aAccessible
aActionName
)
{
return
[
{
eventType
:
AndroidEvents
.
VIEW_CLICKED
selected
:
Utils
.
getState
(
aAccessible
)
.
contains
(
States
.
SELECTED
)
}
]
;
}
actionInvoked
(
aAccessible
aActionName
)
{
return
[
{
eventType
:
AndroidEvents
.
VIEW_CLICKED
text
:
Utils
.
localize
(
UtteranceGenerator
.
genForAction
(
aAccessible
aActionName
)
)
}
]
;
}
textChanged
(
aAccessible
aIsInserted
aStart
aLength
aText
aModifiedText
)
{
let
androidEvent
=
{
eventType
:
AndroidEvents
.
VIEW_TEXT_CHANGED
text
:
[
aText
]
fromIndex
:
aStart
removedCount
:
0
addedCount
:
0
}
;
if
(
aIsInserted
)
{
androidEvent
.
addedCount
=
aLength
;
androidEvent
.
beforeText
=
aText
.
substring
(
0
aStart
)
+
aText
.
substring
(
aStart
+
aLength
)
;
}
else
{
androidEvent
.
removedCount
=
aLength
;
androidEvent
.
beforeText
=
aText
.
substring
(
0
aStart
)
+
aModifiedText
+
aText
.
substring
(
aStart
)
;
}
return
[
androidEvent
]
;
}
textSelectionChanged
(
aText
aStart
aEnd
aOldStart
aOldEnd
aIsFromUserInput
)
{
let
androidEvents
=
[
]
;
if
(
aIsFromUserInput
)
{
let
[
from
to
]
=
aOldStart
<
aStart
?
[
aOldStart
aStart
]
:
[
aStart
aOldStart
]
;
androidEvents
.
push
(
{
eventType
:
AndroidEvents
.
VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY
text
:
[
aText
]
fromIndex
:
from
toIndex
:
to
}
)
;
}
else
{
androidEvents
.
push
(
{
eventType
:
AndroidEvents
.
VIEW_TEXT_SELECTION_CHANGED
text
:
[
aText
]
fromIndex
:
aStart
toIndex
:
aEnd
itemCount
:
aText
.
length
}
)
;
}
return
androidEvents
;
}
selectionChanged
(
aObject
)
{
return
[
"
todo
.
selection
-
changed
"
]
;
}
nameChanged
(
aAccessible
)
{
return
[
"
todo
.
name
-
changed
"
]
;
}
valueChanged
(
aAccessible
)
{
return
[
"
todo
.
value
-
changed
"
]
;
}
tabStateChanged
(
aDocObj
aPageState
)
{
return
this
.
announce
(
UtteranceGenerator
.
genForTabStateChange
(
aDocObj
aPageState
)
)
;
}
viewportChanged
(
aWindow
)
{
let
currentContext
=
this
.
displayedAccessibles
.
get
(
aWindow
)
;
let
events
=
[
{
eventType
:
AndroidEvents
.
VIEW_SCROLLED
scrollX
:
aWindow
.
scrollX
scrollY
:
aWindow
.
scrollY
maxScrollX
:
aWindow
.
scrollMaxX
maxScrollY
:
aWindow
.
scrollMaxY
}
]
;
if
(
currentContext
)
{
let
currentAcc
=
currentContext
.
accessibleForBounds
;
if
(
Utils
.
isAliveAndVisible
(
currentAcc
)
)
{
events
.
push
(
{
eventType
:
AndroidEvents
.
WINDOW_CONTENT_CHANGED
bounds
:
Utils
.
getBounds
(
currentAcc
)
}
)
;
}
}
return
events
;
}
announce
(
aAnnouncement
)
{
let
localizedAnnouncement
=
Utils
.
localize
(
aAnnouncement
)
.
join
(
"
"
)
;
return
[
{
eventType
:
AndroidEvents
.
ANNOUNCEMENT
text
:
[
localizedAnnouncement
]
addedCount
:
localizedAnnouncement
.
length
removedCount
:
0
fromIndex
:
0
}
]
;
}
noMove
(
aMoveMethod
)
{
return
[
{
eventType
:
AndroidEvents
.
VIEW_ACCESSIBILITY_FOCUSED
exitView
:
aMoveMethod
text
:
[
"
"
]
}
]
;
}
liveRegion
(
aAccessible
aIsPolite
aIsHide
aModifiedText
)
{
let
context
=
!
aModifiedText
?
new
PivotContext
(
aAccessible
null
-
1
-
1
true
!
!
aIsHide
)
:
null
;
return
this
.
announce
(
UtteranceGenerator
.
genForLiveRegion
(
context
aIsHide
aModifiedText
)
)
;
}
_infoFromContext
(
aContext
)
{
const
state
=
Utils
.
getState
(
aContext
.
accessible
)
;
const
info
=
{
bounds
:
aContext
.
bounds
focusable
:
state
.
contains
(
States
.
FOCUSABLE
)
focused
:
state
.
contains
(
States
.
FOCUSED
)
clickable
:
aContext
.
accessible
.
actionCount
>
0
checkable
:
state
.
contains
(
States
.
CHECKABLE
)
checked
:
state
.
contains
(
States
.
CHECKED
)
editable
:
state
.
contains
(
States
.
EDITABLE
)
selected
:
state
.
contains
(
States
.
SELECTED
)
}
;
if
(
EDIT_TEXT_ROLES
.
has
(
aContext
.
accessible
.
role
)
)
{
let
textAcc
=
aContext
.
accessible
.
QueryInterface
(
Ci
.
nsIAccessibleText
)
;
return
{
.
.
.
info
className
:
"
android
.
widget
.
EditText
"
hint
:
aContext
.
accessible
.
name
text
:
[
textAcc
.
getText
(
0
-
1
)
]
}
;
}
return
{
.
.
.
info
className
:
"
android
.
view
.
View
"
text
:
Utils
.
localize
(
UtteranceGenerator
.
genForContext
(
aContext
)
)
}
;
}
}
const
Presentation
=
new
AndroidPresentor
(
)
;
