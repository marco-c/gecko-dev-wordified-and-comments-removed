#
import
"
mozSelectableElements
.
h
"
#
import
"
MOXWebAreaAccessible
.
h
"
#
import
"
MacUtils
.
h
"
#
include
"
Accessible
-
inl
.
h
"
#
include
"
nsCocoaUtils
.
h
"
using
namespace
mozilla
:
:
a11y
;
implementation
mozSelectableAccessible
-
(
NSArray
*
)
selectableChildren
{
NSArray
*
toFilter
;
if
(
[
self
isKindOfClass
:
[
mozMenuAccessible
class
]
]
)
{
toFilter
=
[
static_cast
<
mozMenuAccessible
*
>
(
self
)
moxVisibleChildren
]
;
}
else
{
toFilter
=
[
self
moxUnignoredChildren
]
;
}
return
[
toFilter
filteredArrayUsingPredicate
:
[
NSPredicate
predicateWithBlock
:
^
BOOL
(
mozAccessible
*
child
NSDictionary
*
bindings
)
{
return
[
child
isKindOfClass
:
[
mozSelectableChildAccessible
class
]
]
;
}
]
]
;
}
-
(
void
)
moxSetSelectedChildren
:
(
NSArray
*
)
selectedChildren
{
for
(
id
child
in
[
self
selectableChildren
]
)
{
BOOL
selected
=
[
selectedChildren
indexOfObjectIdenticalTo
:
child
]
!
=
NSNotFound
;
[
child
moxSetSelected
:
(
selected
)
]
;
}
}
-
(
NSArray
*
)
moxSelectedChildren
{
return
[
[
self
selectableChildren
]
filteredArrayUsingPredicate
:
[
NSPredicate
predicateWithBlock
:
^
BOOL
(
mozAccessible
*
child
NSDictionary
*
bindings
)
{
return
[
[
(
mozSelectableChildAccessible
*
)
child
moxSelected
]
boolValue
]
;
}
]
]
;
}
end
implementation
mozSelectableChildAccessible
-
(
NSNumber
*
)
moxSelected
{
return
(
[
self
stateWithMask
:
states
:
:
SELECTED
]
!
=
0
)
;
}
-
(
void
)
moxSetSelected
:
(
NSNumber
*
)
selected
{
uint64_t
state
=
[
self
stateWithMask
:
(
states
:
:
SELECTABLE
|
states
:
:
UNAVAILABLE
)
]
;
if
(
(
state
&
states
:
:
SELECTABLE
)
=
=
0
|
|
(
state
&
states
:
:
UNAVAILABLE
)
!
=
0
)
{
return
;
}
if
(
Accessible
*
acc
=
mGeckoAccessible
.
AsAccessible
(
)
)
{
acc
-
>
SetSelected
(
[
selected
boolValue
]
)
;
}
else
{
mGeckoAccessible
.
AsProxy
(
)
-
>
SetSelected
(
[
selected
boolValue
]
)
;
}
[
self
invalidateState
]
;
}
end
implementation
mozTabGroupAccessible
-
(
NSArray
*
)
moxTabs
{
return
[
self
selectableChildren
]
;
}
-
(
NSArray
*
)
moxContents
{
return
[
self
moxUnignoredChildren
]
;
}
-
(
id
)
moxValue
{
return
[
[
self
moxSelectedChildren
]
firstObject
]
;
}
end
implementation
mozTabAccessible
-
(
NSString
*
)
moxRoleDescription
{
return
utils
:
:
LocalizedString
(
u
"
tab
"
_ns
)
;
}
-
(
id
)
moxValue
{
return
[
self
moxSelected
]
;
}
end
implementation
mozListboxAccessible
-
(
BOOL
)
moxIgnoreChild
:
(
mozAccessible
*
)
child
{
if
(
!
child
|
|
child
-
>
mRole
=
=
roles
:
:
GROUPING
)
{
return
YES
;
}
return
[
super
moxIgnoreChild
:
child
]
;
}
-
(
BOOL
)
disableChild
:
(
mozAccessible
*
)
child
{
return
!
[
child
isKindOfClass
:
[
mozSelectableChildAccessible
class
]
]
;
}
-
(
NSString
*
)
moxOrientation
{
return
NSAccessibilityUnknownOrientationValue
;
}
end
implementation
mozOptionAccessible
-
(
NSString
*
)
moxTitle
{
return
"
"
;
}
-
(
id
)
moxValue
{
return
[
super
moxTitle
]
;
}
end
implementation
mozMenuAccessible
-
(
NSString
*
)
moxTitle
{
return
"
"
;
}
-
(
NSString
*
)
moxLabel
{
return
"
"
;
}
-
(
BOOL
)
moxIgnoreWithParent
:
(
mozAccessible
*
)
parent
{
if
(
[
parent
isKindOfClass
:
[
MOXWebAreaAccessible
class
]
]
|
|
[
parent
isKindOfClass
:
[
MOXRootGroup
class
]
]
)
{
return
[
super
moxIgnoreWithParent
:
parent
]
;
}
if
(
[
parent
isKindOfClass
:
[
mozMenuItemAccessible
class
]
]
&
&
[
parent
geckoAccessible
]
.
Role
(
)
=
=
roles
:
:
PARENT_MENUITEM
)
{
id
grandparent
=
[
parent
moxUnignoredParent
]
;
if
(
[
grandparent
isKindOfClass
:
[
mozMenuAccessible
class
]
]
)
{
mozMenuAccessible
*
parentMenu
=
static_cast
<
mozMenuAccessible
*
>
(
grandparent
)
;
return
!
[
parentMenu
isOpened
]
;
}
}
return
[
super
moxIgnoreWithParent
:
parent
]
;
}
-
(
NSArray
*
)
moxVisibleChildren
{
return
[
[
self
moxChildren
]
filteredArrayUsingPredicate
:
[
NSPredicate
predicateWithBlock
:
^
BOOL
(
mozAccessible
*
child
NSDictionary
*
bindings
)
{
if
(
Accessible
*
acc
=
[
child
geckoAccessible
]
.
AsAccessible
(
)
)
{
if
(
acc
-
>
IsContent
(
)
&
&
acc
-
>
GetContent
(
)
-
>
IsXULElement
(
)
)
{
return
(
(
acc
-
>
VisibilityState
(
)
&
states
:
:
INVISIBLE
)
=
=
0
)
;
}
}
return
true
;
}
]
]
;
}
-
(
id
)
moxTitleUIElement
{
id
parent
=
[
self
moxUnignoredParent
]
;
if
(
parent
&
&
[
parent
isKindOfClass
:
[
mozAccessible
class
]
]
)
{
return
parent
;
}
return
nil
;
}
-
(
void
)
moxPostNotification
:
(
NSString
*
)
notification
{
[
super
moxPostNotification
:
notification
]
;
if
(
[
notification
isEqualToString
:
"
AXMenuOpened
"
]
)
{
mIsOpened
=
YES
;
}
else
if
(
[
notification
isEqualToString
:
"
AXMenuClosed
"
]
)
{
mIsOpened
=
NO
;
}
}
-
(
void
)
expire
{
if
(
mIsOpened
)
{
[
self
moxPostNotification
:
"
AXMenuClosed
"
]
;
}
[
super
expire
]
;
}
-
(
BOOL
)
isOpened
{
return
mIsOpened
;
}
end
implementation
mozMenuItemAccessible
-
(
NSString
*
)
moxLabel
{
return
"
"
;
}
-
(
BOOL
)
moxIgnoreWithParent
:
(
mozAccessible
*
)
parent
{
mozAccessible
*
grandparent
=
GetNativeFromGeckoAccessible
(
[
parent
geckoAccessible
]
.
Parent
(
)
)
;
if
(
[
grandparent
isKindOfClass
:
[
MOXWebAreaAccessible
class
]
]
)
{
return
[
parent
moxIgnoreWithParent
:
grandparent
]
;
}
grandparent
=
[
parent
moxUnignoredParent
]
;
if
(
[
grandparent
isKindOfClass
:
[
mozMenuItemAccessible
class
]
]
)
{
mozMenuItemAccessible
*
acc
=
static_cast
<
mozMenuItemAccessible
*
>
(
grandparent
)
;
if
(
[
acc
geckoAccessible
]
.
Role
(
)
=
=
roles
:
:
PARENT_MENUITEM
)
{
mozMenuAccessible
*
parentMenu
=
static_cast
<
mozMenuAccessible
*
>
(
parent
)
;
return
!
[
parentMenu
isOpened
]
;
}
}
return
[
super
moxIgnoreWithParent
:
parent
]
;
}
-
(
NSString
*
)
moxMenuItemMarkChar
{
Accessible
*
acc
=
mGeckoAccessible
.
AsAccessible
(
)
;
if
(
acc
&
&
acc
-
>
IsContent
(
)
&
&
acc
-
>
GetContent
(
)
-
>
IsXULElement
(
nsGkAtoms
:
:
menuitem
)
)
{
if
(
acc
-
>
ChildCount
(
)
=
=
1
&
&
acc
-
>
FirstChild
(
)
-
>
Role
(
)
=
=
roles
:
:
STATICTEXT
)
{
nsAutoString
marker
;
acc
-
>
FirstChild
(
)
-
>
Name
(
marker
)
;
if
(
marker
.
Length
(
)
=
=
1
)
{
return
nsCocoaUtils
:
:
ToNSString
(
marker
)
;
}
}
}
return
nil
;
}
-
(
NSNumber
*
)
moxSelected
{
return
(
[
self
stateWithMask
:
states
:
:
FOCUSED
]
!
=
0
)
;
}
-
(
void
)
handleAccessibleEvent
:
(
uint32_t
)
eventType
{
switch
(
eventType
)
{
case
nsIAccessibleEvent
:
:
EVENT_FOCUS
:
mozAccessible
*
parent
=
(
mozAccessible
*
)
[
self
moxUnignoredParent
]
;
[
parent
moxPostNotification
:
NSAccessibilitySelectedChildrenChangedNotification
]
;
break
;
}
[
super
handleAccessibleEvent
:
eventType
]
;
}
end
