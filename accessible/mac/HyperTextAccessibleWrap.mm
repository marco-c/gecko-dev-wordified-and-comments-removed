#
include
"
HyperTextAccessibleWrap
.
h
"
#
include
"
Accessible
-
inl
.
h
"
#
include
"
HTMLListAccessible
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
TextRange
.
h
"
#
include
"
TreeWalker
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
class
HyperTextIterator
{
public
:
HyperTextIterator
(
HyperTextAccessible
*
aStartContainer
int32_t
aStartOffset
HyperTextAccessible
*
aEndContainer
int32_t
aEndOffset
bool
aSkipBullet
=
false
)
:
mCurrentContainer
(
aStartContainer
)
mCurrentStartOffset
(
aStartOffset
)
mCurrentEndOffset
(
aStartOffset
)
mEndContainer
(
aEndContainer
)
mEndOffset
(
aEndOffset
)
mSkipBullet
(
aSkipBullet
)
{
}
bool
Next
(
)
;
int32_t
SegmentLength
(
)
;
bool
NormalizeForward
(
)
;
bool
NormalizeBackward
(
)
;
HyperTextAccessible
*
mCurrentContainer
;
int32_t
mCurrentStartOffset
;
int32_t
mCurrentEndOffset
;
private
:
int32_t
NextLinkOffset
(
)
;
HyperTextAccessible
*
mEndContainer
;
int32_t
mEndOffset
;
bool
mSkipBullet
;
}
;
bool
HyperTextIterator
:
:
NormalizeForward
(
)
{
if
(
mCurrentStartOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
|
|
mCurrentStartOffset
>
=
static_cast
<
int32_t
>
(
mCurrentContainer
-
>
CharacterCount
(
)
)
)
{
if
(
!
mCurrentContainer
-
>
IsLink
(
)
)
{
return
false
;
}
uint32_t
endOffset
=
mCurrentContainer
-
>
EndOffset
(
)
;
if
(
endOffset
!
=
0
)
{
mCurrentContainer
=
mCurrentContainer
-
>
Parent
(
)
-
>
AsHyperText
(
)
;
mCurrentStartOffset
=
endOffset
;
NormalizeForward
(
)
;
return
true
;
}
}
else
{
Accessible
*
link
=
mCurrentContainer
-
>
LinkAt
(
mCurrentContainer
-
>
LinkIndexAtOffset
(
mCurrentStartOffset
)
)
;
if
(
link
&
&
link
-
>
IsHyperText
(
)
)
{
mCurrentContainer
=
link
-
>
AsHyperText
(
)
;
if
(
mSkipBullet
&
&
link
-
>
IsHTMLListItem
(
)
)
{
Accessible
*
bullet
=
link
-
>
AsHTMLListItem
(
)
-
>
Bullet
(
)
;
mCurrentStartOffset
=
bullet
?
nsAccUtils
:
:
TextLength
(
bullet
)
:
0
;
}
else
{
mCurrentStartOffset
=
0
;
}
NormalizeForward
(
)
;
return
true
;
}
}
return
false
;
}
bool
HyperTextIterator
:
:
NormalizeBackward
(
)
{
if
(
mCurrentStartOffset
=
=
0
)
{
if
(
!
mCurrentContainer
-
>
IsLink
(
)
)
{
return
false
;
}
uint32_t
startOffset
=
mCurrentContainer
-
>
StartOffset
(
)
;
mCurrentContainer
=
mCurrentContainer
-
>
Parent
(
)
-
>
AsHyperText
(
)
;
mCurrentStartOffset
=
startOffset
;
NormalizeBackward
(
)
;
return
true
;
}
else
{
Accessible
*
link
=
mCurrentContainer
-
>
GetChildAtOffset
(
mCurrentStartOffset
-
1
)
;
if
(
link
&
&
link
-
>
IsHyperText
(
)
)
{
mCurrentContainer
=
link
-
>
AsHyperText
(
)
;
mCurrentStartOffset
=
mCurrentContainer
-
>
CharacterCount
(
)
;
NormalizeBackward
(
)
;
return
true
;
}
if
(
mSkipBullet
&
&
mCurrentContainer
-
>
IsHTMLListItem
(
)
&
&
mCurrentContainer
-
>
AsHTMLListItem
(
)
-
>
Bullet
(
)
=
=
link
)
{
mCurrentStartOffset
=
0
;
NormalizeBackward
(
)
;
return
true
;
}
}
return
false
;
}
int32_t
HyperTextIterator
:
:
SegmentLength
(
)
{
int32_t
endOffset
=
mCurrentEndOffset
<
0
?
mCurrentContainer
-
>
CharacterCount
(
)
:
mCurrentEndOffset
;
return
endOffset
-
mCurrentStartOffset
;
}
int32_t
HyperTextIterator
:
:
NextLinkOffset
(
)
{
int32_t
linkCount
=
mCurrentContainer
-
>
LinkCount
(
)
;
for
(
int32_t
i
=
0
;
i
<
linkCount
;
i
+
+
)
{
Accessible
*
link
=
mCurrentContainer
-
>
LinkAt
(
i
)
;
MOZ_ASSERT
(
link
)
;
int32_t
linkStartOffset
=
link
-
>
StartOffset
(
)
;
if
(
mCurrentStartOffset
<
linkStartOffset
)
{
return
linkStartOffset
;
}
}
return
-
1
;
}
bool
HyperTextIterator
:
:
Next
(
)
{
if
(
mCurrentContainer
=
=
mEndContainer
&
&
(
mCurrentEndOffset
=
=
-
1
|
|
mEndOffset
<
=
mCurrentEndOffset
)
)
{
return
false
;
}
else
{
mCurrentStartOffset
=
mCurrentEndOffset
;
NormalizeForward
(
)
;
}
int32_t
nextLinkOffset
=
NextLinkOffset
(
)
;
if
(
mCurrentContainer
=
=
mEndContainer
&
&
(
nextLinkOffset
=
=
-
1
|
|
nextLinkOffset
>
mEndOffset
)
)
{
mCurrentEndOffset
=
mEndOffset
<
0
?
mEndContainer
-
>
CharacterCount
(
)
:
mEndOffset
;
}
else
{
mCurrentEndOffset
=
nextLinkOffset
<
0
?
mCurrentContainer
-
>
CharacterCount
(
)
:
nextLinkOffset
;
}
return
mCurrentStartOffset
!
=
mCurrentEndOffset
;
}
void
HyperTextAccessibleWrap
:
:
TextForRange
(
nsAString
&
aText
int32_t
aStartOffset
HyperTextAccessible
*
aEndContainer
int32_t
aEndOffset
)
{
HyperTextIterator
iter
(
this
aStartOffset
aEndContainer
aEndOffset
)
;
while
(
iter
.
Next
(
)
)
{
nsAutoString
text
;
iter
.
mCurrentContainer
-
>
TextSubstring
(
iter
.
mCurrentStartOffset
iter
.
mCurrentEndOffset
text
)
;
aText
.
Append
(
text
)
;
}
}
nsIntRect
HyperTextAccessibleWrap
:
:
BoundsForRange
(
int32_t
aStartOffset
HyperTextAccessible
*
aEndContainer
int32_t
aEndOffset
)
{
nsIntRect
rect
;
HyperTextIterator
iter
(
this
aStartOffset
aEndContainer
aEndOffset
)
;
while
(
iter
.
Next
(
)
)
{
nsIntRect
stringRect
=
iter
.
mCurrentContainer
-
>
TextBounds
(
iter
.
mCurrentStartOffset
iter
.
mCurrentEndOffset
)
;
rect
.
UnionRect
(
rect
stringRect
)
;
}
return
rect
;
}
int32_t
HyperTextAccessibleWrap
:
:
LengthForRange
(
int32_t
aStartOffset
HyperTextAccessible
*
aEndContainer
int32_t
aEndOffset
)
{
int32_t
length
=
0
;
HyperTextIterator
iter
(
this
aStartOffset
aEndContainer
aEndOffset
true
)
;
while
(
iter
.
Next
(
)
)
{
length
+
=
iter
.
SegmentLength
(
)
;
}
return
length
;
}
void
HyperTextAccessibleWrap
:
:
OffsetAtIndex
(
int32_t
aIndex
HyperTextAccessible
*
*
aContainer
int32_t
*
aOffset
)
{
int32_t
index
=
aIndex
;
HyperTextIterator
iter
(
this
0
this
CharacterCount
(
)
true
)
;
while
(
iter
.
Next
(
)
)
{
int32_t
segmentLength
=
iter
.
SegmentLength
(
)
;
if
(
index
<
=
segmentLength
)
{
*
aContainer
=
iter
.
mCurrentContainer
;
*
aOffset
=
iter
.
mCurrentStartOffset
+
index
;
break
;
}
index
-
=
segmentLength
;
}
}
void
HyperTextAccessibleWrap
:
:
RangeAt
(
int32_t
aOffset
EWhichRange
aRangeType
HyperTextAccessible
*
*
aStartContainer
int32_t
*
aStartOffset
HyperTextAccessible
*
*
aEndContainer
int32_t
*
aEndOffset
)
{
switch
(
aRangeType
)
{
case
EWhichRange
:
:
eLeftWord
:
LeftWordAt
(
aOffset
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
;
break
;
case
EWhichRange
:
:
eRightWord
:
RightWordAt
(
aOffset
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
;
break
;
default
:
break
;
}
}
void
HyperTextAccessibleWrap
:
:
LeftWordAt
(
int32_t
aOffset
HyperTextAccessible
*
*
aStartContainer
int32_t
*
aStartOffset
HyperTextAccessible
*
*
aEndContainer
int32_t
*
aEndOffset
)
{
TextPoint
here
(
this
aOffset
)
;
TextPoint
start
=
FindTextPoint
(
aOffset
eDirPrevious
eSelectWord
eStartWord
)
;
if
(
!
start
.
mContainer
)
{
return
;
}
if
(
(
NativeState
(
)
&
states
:
:
EDITABLE
)
&
&
!
(
start
.
mContainer
-
>
NativeState
(
)
&
states
:
:
EDITABLE
)
)
{
return
EditableRoot
(
)
-
>
RightWordAt
(
0
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
;
}
TextPoint
end
=
static_cast
<
HyperTextAccessibleWrap
*
>
(
start
.
mContainer
)
-
>
FindTextPoint
(
start
.
mOffset
eDirNext
eSelectWord
eEndWord
)
;
if
(
end
<
here
)
{
*
aStartContainer
=
end
.
mContainer
;
*
aEndContainer
=
here
.
mContainer
;
*
aStartOffset
=
end
.
mOffset
;
*
aEndOffset
=
here
.
mOffset
;
}
else
{
*
aStartContainer
=
start
.
mContainer
;
*
aEndContainer
=
end
.
mContainer
;
*
aStartOffset
=
start
.
mOffset
;
*
aEndOffset
=
end
.
mOffset
;
}
}
void
HyperTextAccessibleWrap
:
:
RightWordAt
(
int32_t
aOffset
HyperTextAccessible
*
*
aStartContainer
int32_t
*
aStartOffset
HyperTextAccessible
*
*
aEndContainer
int32_t
*
aEndOffset
)
{
TextPoint
here
(
this
aOffset
)
;
TextPoint
end
=
FindTextPoint
(
aOffset
eDirNext
eSelectWord
eEndWord
)
;
if
(
!
end
.
mContainer
|
|
end
<
here
)
{
return
;
}
if
(
(
NativeState
(
)
&
states
:
:
EDITABLE
)
&
&
!
(
end
.
mContainer
-
>
NativeState
(
)
&
states
:
:
EDITABLE
)
)
{
return
EditableRoot
(
)
-
>
LeftWordAt
(
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
;
}
TextPoint
start
=
static_cast
<
HyperTextAccessibleWrap
*
>
(
end
.
mContainer
)
-
>
FindTextPoint
(
end
.
mOffset
eDirPrevious
eSelectWord
eStartWord
)
;
if
(
here
<
start
)
{
*
aStartContainer
=
here
.
mContainer
;
*
aEndContainer
=
start
.
mContainer
;
*
aStartOffset
=
here
.
mOffset
;
*
aEndOffset
=
start
.
mOffset
;
}
else
{
*
aStartContainer
=
start
.
mContainer
;
*
aEndContainer
=
end
.
mContainer
;
*
aStartOffset
=
start
.
mOffset
;
*
aEndOffset
=
end
.
mOffset
;
}
}
void
HyperTextAccessibleWrap
:
:
NextClusterAt
(
int32_t
aOffset
HyperTextAccessible
*
*
aNextContainer
int32_t
*
aNextOffset
)
{
TextPoint
here
(
this
aOffset
)
;
TextPoint
next
=
FindTextPoint
(
aOffset
eDirNext
eSelectCluster
eDefaultBehavior
)
;
if
(
(
next
.
mOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
&
&
next
.
mContainer
=
=
Document
(
)
)
|
|
(
next
<
here
)
)
{
*
aNextContainer
=
this
;
*
aNextOffset
=
aOffset
;
}
else
{
*
aNextContainer
=
next
.
mContainer
;
*
aNextOffset
=
next
.
mOffset
;
}
}
void
HyperTextAccessibleWrap
:
:
PreviousClusterAt
(
int32_t
aOffset
HyperTextAccessible
*
*
aPrevContainer
int32_t
*
aPrevOffset
)
{
TextPoint
prev
=
FindTextPoint
(
aOffset
eDirPrevious
eSelectCluster
eDefaultBehavior
)
;
*
aPrevContainer
=
prev
.
mContainer
;
*
aPrevOffset
=
prev
.
mOffset
;
}
void
HyperTextAccessibleWrap
:
:
RangeOfChild
(
Accessible
*
aChild
int32_t
*
aStartOffset
int32_t
*
aEndOffset
)
{
MOZ_ASSERT
(
aChild
-
>
Parent
(
)
=
=
this
)
;
*
aStartOffset
=
*
aEndOffset
=
-
1
;
int32_t
index
=
GetIndexOf
(
aChild
)
;
if
(
index
!
=
-
1
)
{
*
aStartOffset
=
GetChildOffset
(
index
)
;
*
aEndOffset
=
GetChildOffset
(
index
+
1
)
;
}
}
Accessible
*
HyperTextAccessibleWrap
:
:
LeafAtOffset
(
int32_t
aOffset
)
{
HyperTextAccessible
*
text
=
this
;
Accessible
*
child
=
nullptr
;
int32_t
innerOffset
=
aOffset
;
do
{
int32_t
childIdx
=
text
-
>
GetChildIndexAtOffset
(
innerOffset
)
;
if
(
childIdx
=
=
-
1
)
{
return
text
;
}
child
=
text
-
>
GetChildAt
(
childIdx
)
;
if
(
!
child
|
|
nsAccUtils
:
:
MustPrune
(
child
)
)
{
return
text
;
}
innerOffset
-
=
text
-
>
GetChildOffset
(
childIdx
)
;
text
=
child
-
>
AsHyperText
(
)
;
}
while
(
text
)
;
return
child
;
}
void
HyperTextAccessibleWrap
:
:
SelectRange
(
int32_t
aStartOffset
HyperTextAccessible
*
aEndContainer
int32_t
aEndOffset
)
{
TextRange
range
(
this
this
aStartOffset
aEndContainer
aEndOffset
)
;
range
.
SetSelectionAt
(
0
)
;
}
TextPoint
HyperTextAccessibleWrap
:
:
FindTextPoint
(
int32_t
aOffset
nsDirection
aDirection
nsSelectionAmount
aAmount
EWordMovementType
aWordMovementType
)
{
HyperTextIterator
iter
(
this
aOffset
this
CharacterCount
(
)
true
)
;
if
(
aDirection
=
=
eDirNext
)
{
iter
.
NormalizeForward
(
)
;
}
else
{
iter
.
NormalizeBackward
(
)
;
}
HyperTextAccessible
*
text
=
iter
.
mCurrentContainer
;
Accessible
*
child
=
nullptr
;
int32_t
innerOffset
=
iter
.
mCurrentStartOffset
;
do
{
int32_t
childIdx
=
text
-
>
GetChildIndexAtOffset
(
innerOffset
)
;
if
(
childIdx
=
=
-
1
)
{
NS_ASSERTION
(
innerOffset
=
=
0
&
&
!
text
-
>
ChildCount
(
)
"
No
childIdx
?
"
)
;
return
TextPoint
(
text
0
)
;
}
child
=
text
-
>
GetChildAt
(
childIdx
)
;
if
(
child
-
>
IsHyperText
(
)
&
&
!
child
-
>
ChildCount
(
)
)
{
if
(
aDirection
=
=
eDirPrevious
&
&
childIdx
>
0
)
{
child
=
text
-
>
GetChildAt
(
-
-
childIdx
)
;
}
else
if
(
aDirection
=
=
eDirNext
&
&
childIdx
+
1
<
static_cast
<
int32_t
>
(
text
-
>
ChildCount
(
)
)
)
{
child
=
text
-
>
GetChildAt
(
+
+
childIdx
)
;
}
}
innerOffset
-
=
text
-
>
GetChildOffset
(
childIdx
)
;
text
=
child
-
>
AsHyperText
(
)
;
}
while
(
text
)
;
nsIFrame
*
childFrame
=
child
-
>
GetFrame
(
)
;
if
(
!
childFrame
)
{
NS_ERROR
(
"
No
child
frame
"
)
;
return
TextPoint
(
this
aOffset
)
;
}
int32_t
innerContentOffset
=
innerOffset
;
if
(
child
-
>
IsTextLeaf
(
)
)
{
NS_ASSERTION
(
childFrame
-
>
IsTextFrame
(
)
"
Wrong
frame
!
"
)
;
RenderedToContentOffset
(
childFrame
innerOffset
&
innerContentOffset
)
;
}
nsIFrame
*
frameAtOffset
=
childFrame
;
int32_t
offsetInFrame
=
0
;
childFrame
-
>
GetChildFrameContainingOffset
(
innerContentOffset
true
&
offsetInFrame
&
frameAtOffset
)
;
if
(
aDirection
=
=
eDirPrevious
&
&
offsetInFrame
=
=
0
)
{
if
(
nsIFrame
*
prevInContinuation
=
frameAtOffset
-
>
GetPrevContinuation
(
)
)
{
frameAtOffset
=
prevInContinuation
;
}
}
const
bool
kIsJumpLinesOk
=
true
;
const
bool
kIsScrollViewAStop
=
false
;
const
bool
kIsKeyboardSelect
=
true
;
const
bool
kIsVisualBidi
=
false
;
nsPeekOffsetStruct
pos
(
aAmount
aDirection
innerContentOffset
nsPoint
(
0
0
)
kIsJumpLinesOk
kIsScrollViewAStop
kIsKeyboardSelect
kIsVisualBidi
false
nsPeekOffsetStruct
:
:
ForceEditableRegion
:
:
No
aWordMovementType
false
)
;
nsresult
rv
=
frameAtOffset
-
>
PeekOffset
(
&
pos
)
;
if
(
NS_FAILED
(
rv
)
&
&
aAmount
=
=
eSelectLine
)
{
pos
.
mAmount
=
aDirection
=
=
eDirNext
?
eSelectEndLine
:
eSelectBeginLine
;
frameAtOffset
-
>
PeekOffset
(
&
pos
)
;
}
if
(
!
pos
.
mResultContent
)
{
NS_ERROR
(
"
No
result
content
!
"
)
;
return
TextPoint
(
this
aOffset
)
;
}
if
(
aDirection
=
=
eDirNext
&
&
nsContentUtils
:
:
PositionIsBefore
(
pos
.
mResultContent
mContent
nullptr
nullptr
)
)
{
return
TextPoint
(
Document
(
)
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
)
;
}
HyperTextAccessible
*
container
=
nsAccUtils
:
:
GetTextContainer
(
pos
.
mResultContent
)
;
int32_t
offset
=
container
?
container
-
>
DOMPointToOffset
(
pos
.
mResultContent
pos
.
mContentOffset
aDirection
=
=
eDirNext
)
:
0
;
return
TextPoint
(
container
offset
)
;
}
HyperTextAccessibleWrap
*
HyperTextAccessibleWrap
:
:
EditableRoot
(
)
{
Accessible
*
editable
=
nullptr
;
for
(
Accessible
*
acc
=
this
;
acc
&
&
acc
!
=
Document
(
)
;
acc
=
acc
-
>
Parent
(
)
)
{
if
(
acc
-
>
NativeState
(
)
&
states
:
:
EDITABLE
)
{
editable
=
acc
;
}
else
{
break
;
}
}
return
static_cast
<
HyperTextAccessibleWrap
*
>
(
editable
-
>
AsHyperText
(
)
)
;
}
