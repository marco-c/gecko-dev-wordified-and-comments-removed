#
import
<
Cocoa
/
Cocoa
.
h
>
#
import
"
MOXTextMarkerDelegate
.
h
"
#
include
"
Platform
.
h
"
#
include
"
RemoteAccessible
.
h
"
#
include
"
DocAccessibleParent
.
h
"
#
include
"
mozTableAccessible
.
h
"
#
include
"
MOXWebAreaAccessible
.
h
"
#
include
"
nsAppShell
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
interface
NSWorkspace
(
AvailableSinceHighSierra
)
property
(
readonly
)
BOOL
isVoiceOverEnabled
;
property
(
readonly
)
BOOL
isSwitchControlEnabled
;
end
namespace
mozilla
{
namespace
a11y
{
static
bool
sA11yShouldBeEnabled
=
false
;
bool
ShouldA11yBeEnabled
(
)
{
EPlatformDisabledState
disabledState
=
PlatformDisabledState
(
)
;
return
(
disabledState
=
=
ePlatformIsForceEnabled
)
|
|
(
(
disabledState
=
=
ePlatformIsEnabled
)
&
&
sA11yShouldBeEnabled
)
;
}
void
PlatformInit
(
)
{
}
void
PlatformShutdown
(
)
{
}
void
ProxyCreated
(
RemoteAccessible
*
aProxy
)
{
if
(
aProxy
-
>
Role
(
)
=
=
roles
:
:
WHITESPACE
)
{
return
;
}
Class
type
;
if
(
aProxy
-
>
IsTable
(
)
)
{
type
=
[
mozTableAccessible
class
]
;
}
else
if
(
aProxy
-
>
IsTableRow
(
)
)
{
type
=
[
mozTableRowAccessible
class
]
;
}
else
if
(
aProxy
-
>
IsTableCell
(
)
)
{
type
=
[
mozTableCellAccessible
class
]
;
}
else
if
(
aProxy
-
>
IsDoc
(
)
)
{
type
=
[
MOXWebAreaAccessible
class
]
;
}
else
{
type
=
GetTypeFromRole
(
aProxy
-
>
Role
(
)
)
;
}
mozAccessible
*
mozWrapper
=
[
[
type
alloc
]
initWithAccessible
:
aProxy
]
;
aProxy
-
>
SetWrapper
(
reinterpret_cast
<
uintptr_t
>
(
mozWrapper
)
)
;
}
void
ProxyDestroyed
(
RemoteAccessible
*
aProxy
)
{
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aProxy
)
;
[
wrapper
expire
]
;
[
wrapper
release
]
;
aProxy
-
>
SetWrapper
(
0
)
;
if
(
aProxy
-
>
IsDoc
(
)
)
{
[
MOXTextMarkerDelegate
destroyForDoc
:
aProxy
]
;
}
}
void
ProxyEvent
(
RemoteAccessible
*
aProxy
uint32_t
aEventType
)
{
if
(
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_ALERT
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_FOCUS
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_TEXT_VALUE_CHANGE
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_TEXT_CARET_MOVED
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_LOAD_COMPLETE
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_REORDER
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_LIVE_REGION_ADDED
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_LIVE_REGION_REMOVED
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_OBJECT_ATTRIBUTE_CHANGED
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_TABLE_STYLING_CHANGED
)
return
;
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aProxy
)
;
if
(
wrapper
)
{
[
wrapper
handleAccessibleEvent
:
aEventType
]
;
}
}
void
ProxyStateChangeEvent
(
RemoteAccessible
*
aProxy
uint64_t
aState
bool
aEnabled
)
{
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aProxy
)
;
if
(
wrapper
)
{
[
wrapper
stateChanged
:
aState
isEnabled
:
aEnabled
]
;
}
}
void
ProxyCaretMoveEvent
(
RemoteAccessible
*
aTarget
int32_t
aOffset
bool
aIsSelectionCollapsed
)
{
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aTarget
)
;
MOXTextMarkerDelegate
*
delegate
=
[
MOXTextMarkerDelegate
getOrCreateForDoc
:
aTarget
-
>
Document
(
)
]
;
[
delegate
setCaretOffset
:
aTarget
at
:
aOffset
]
;
if
(
aIsSelectionCollapsed
)
{
[
delegate
setSelectionFrom
:
aTarget
at
:
aOffset
to
:
aTarget
at
:
aOffset
]
;
}
if
(
wrapper
)
{
if
(
mozTextAccessible
*
textAcc
=
static_cast
<
mozTextAccessible
*
>
(
[
wrapper
moxEditableAncestor
]
)
)
{
[
textAcc
handleAccessibleEvent
:
nsIAccessibleEvent
:
:
EVENT_TEXT_CARET_MOVED
]
;
}
else
{
[
wrapper
handleAccessibleEvent
:
nsIAccessibleEvent
:
:
EVENT_TEXT_CARET_MOVED
]
;
}
}
}
void
ProxyTextChangeEvent
(
RemoteAccessible
*
aTarget
const
nsString
&
aStr
int32_t
aStart
uint32_t
aLen
bool
aIsInsert
bool
aFromUser
)
{
RemoteAccessible
*
acc
=
aTarget
;
while
(
acc
&
&
GetTypeFromRole
(
acc
-
>
Role
(
)
)
!
=
[
mozTextAccessible
class
]
)
{
acc
=
acc
-
>
RemoteParent
(
)
;
}
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
acc
?
acc
:
aTarget
)
;
[
wrapper
handleAccessibleTextChangeEvent
:
nsCocoaUtils
:
:
ToNSString
(
aStr
)
inserted
:
aIsInsert
inContainer
:
aTarget
at
:
aStart
]
;
}
void
ProxyShowHideEvent
(
RemoteAccessible
*
RemoteAccessible
*
bool
bool
)
{
}
void
ProxySelectionEvent
(
RemoteAccessible
*
aTarget
RemoteAccessible
*
aWidget
uint32_t
aEventType
)
{
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aWidget
)
;
if
(
wrapper
)
{
[
wrapper
handleAccessibleEvent
:
aEventType
]
;
}
}
void
ProxyTextSelectionChangeEvent
(
RemoteAccessible
*
aTarget
const
nsTArray
<
TextRangeData
>
&
aSelection
)
{
if
(
aSelection
.
Length
(
)
)
{
MOXTextMarkerDelegate
*
delegate
=
[
MOXTextMarkerDelegate
getOrCreateForDoc
:
aTarget
-
>
Document
(
)
]
;
DocAccessibleParent
*
doc
=
aTarget
-
>
Document
(
)
;
RemoteAccessible
*
startContainer
=
doc
-
>
GetAccessible
(
aSelection
[
0
]
.
StartID
(
)
)
;
RemoteAccessible
*
endContainer
=
doc
-
>
GetAccessible
(
aSelection
[
0
]
.
EndID
(
)
)
;
[
delegate
setSelectionFrom
:
startContainer
at
:
aSelection
[
0
]
.
StartOffset
(
)
to
:
endContainer
at
:
aSelection
[
0
]
.
EndOffset
(
)
]
;
}
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aTarget
)
;
if
(
wrapper
)
{
[
wrapper
handleAccessibleEvent
:
nsIAccessibleEvent
:
:
EVENT_TEXT_SELECTION_CHANGED
]
;
}
}
void
ProxyRoleChangedEvent
(
RemoteAccessible
*
aTarget
const
a11y
:
:
role
&
aRole
)
{
if
(
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aTarget
)
)
{
[
wrapper
handleRoleChanged
:
aRole
]
;
}
}
}
}
interface
GeckoNSApplication
(
a11y
)
-
(
void
)
accessibilitySetValue
:
(
id
)
value
forAttribute
:
(
NSString
*
)
attribute
;
end
implementation
GeckoNSApplication
(
a11y
)
-
(
void
)
accessibilitySetValue
:
(
id
)
value
forAttribute
:
(
NSString
*
)
attribute
{
if
(
[
attribute
isEqualToString
:
"
AXEnhancedUserInterface
"
]
)
{
mozilla
:
:
a11y
:
:
sA11yShouldBeEnabled
=
(
[
value
intValue
]
=
=
1
)
;
if
(
sA11yShouldBeEnabled
)
{
nsAutoString
client
;
if
(
[
[
NSWorkspace
sharedWorkspace
]
respondsToSelector
:
selector
(
isVoiceOverEnabled
)
]
&
&
[
[
NSWorkspace
sharedWorkspace
]
isVoiceOverEnabled
]
)
{
client
.
Assign
(
u
"
VoiceOver
"
_ns
)
;
}
else
if
(
[
[
NSWorkspace
sharedWorkspace
]
respondsToSelector
:
selector
(
isSwitchControlEnabled
)
]
&
&
[
[
NSWorkspace
sharedWorkspace
]
isSwitchControlEnabled
]
)
{
client
.
Assign
(
u
"
SwitchControl
"
_ns
)
;
}
else
{
client
.
Assign
(
u
"
Unknown
"
_ns
)
;
}
#
if
defined
(
MOZ_TELEMETRY_REPORTING
)
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
A11Y_INSTANTIATORS
client
)
;
#
endif
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
AccessibilityClient
NS_ConvertUTF16toUTF8
(
client
)
)
;
}
}
return
[
super
accessibilitySetValue
:
value
forAttribute
:
attribute
]
;
}
end
