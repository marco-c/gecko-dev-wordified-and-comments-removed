#
import
<
Cocoa
/
Cocoa
.
h
>
#
import
"
MOXTextMarkerDelegate
.
h
"
#
include
"
Platform
.
h
"
#
include
"
RemoteAccessible
.
h
"
#
include
"
DocAccessibleParent
.
h
"
#
include
"
mozTableAccessible
.
h
"
#
include
"
mozTextAccessible
.
h
"
#
include
"
MOXOuterDoc
.
h
"
#
include
"
MOXWebAreaAccessible
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
TextRange
.
h
"
#
include
"
nsAppShell
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
glean
/
AccessibleMetrics
.
h
"
interface
NSWorkspace
(
AvailableSinceHighSierra
)
property
(
readonly
)
BOOL
isVoiceOverEnabled
;
property
(
readonly
)
BOOL
isSwitchControlEnabled
;
end
namespace
mozilla
{
namespace
a11y
{
static
bool
sA11yShouldBeEnabled
=
false
;
bool
ShouldA11yBeEnabled
(
)
{
EPlatformDisabledState
disabledState
=
PlatformDisabledState
(
)
;
return
(
disabledState
=
=
ePlatformIsForceEnabled
)
|
|
(
(
disabledState
=
=
ePlatformIsEnabled
)
&
&
sA11yShouldBeEnabled
)
;
}
void
PlatformInit
(
)
{
}
void
PlatformShutdown
(
)
{
}
void
ProxyCreated
(
RemoteAccessible
*
aProxy
)
{
if
(
aProxy
-
>
Role
(
)
=
=
roles
:
:
WHITESPACE
)
{
return
;
}
Class
type
;
if
(
aProxy
-
>
IsTable
(
)
)
{
type
=
[
mozTableAccessible
class
]
;
}
else
if
(
aProxy
-
>
IsTableRow
(
)
)
{
type
=
[
mozTableRowAccessible
class
]
;
}
else
if
(
aProxy
-
>
IsTableCell
(
)
)
{
type
=
[
mozTableCellAccessible
class
]
;
}
else
if
(
aProxy
-
>
IsDoc
(
)
)
{
type
=
[
MOXWebAreaAccessible
class
]
;
}
else
if
(
aProxy
-
>
IsOuterDoc
(
)
)
{
type
=
[
MOXOuterDoc
class
]
;
}
else
if
(
aProxy
-
>
IsTextField
(
)
&
&
!
aProxy
-
>
HasNumericValue
(
)
)
{
type
=
[
mozTextAccessible
class
]
;
}
else
{
type
=
GetTypeFromRole
(
aProxy
-
>
Role
(
)
)
;
}
mozAccessible
*
mozWrapper
=
[
[
type
alloc
]
initWithAccessible
:
aProxy
]
;
aProxy
-
>
SetWrapper
(
reinterpret_cast
<
uintptr_t
>
(
mozWrapper
)
)
;
}
void
ProxyDestroyed
(
RemoteAccessible
*
aProxy
)
{
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aProxy
)
;
[
wrapper
expire
]
;
[
wrapper
release
]
;
aProxy
-
>
SetWrapper
(
0
)
;
if
(
aProxy
-
>
IsDoc
(
)
)
{
[
MOXTextMarkerDelegate
destroyForDoc
:
aProxy
]
;
}
}
void
PlatformEvent
(
Accessible
*
aTarget
uint32_t
aEventType
)
{
if
(
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_ALERT
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_TEXT_VALUE_CHANGE
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_LOAD_COMPLETE
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_REORDER
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_LIVE_REGION_ADDED
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_LIVE_REGION_REMOVED
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_LIVE_REGION_CHANGED
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_OBJECT_ATTRIBUTE_CHANGED
&
&
aEventType
!
=
nsIAccessibleEvent
:
:
EVENT_ERRORMESSAGE_CHANGED
)
{
return
;
}
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aTarget
)
;
if
(
wrapper
)
{
[
wrapper
handleAccessibleEvent
:
aEventType
]
;
}
}
void
PlatformStateChangeEvent
(
Accessible
*
aTarget
uint64_t
aState
bool
aEnabled
)
{
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aTarget
)
;
if
(
wrapper
)
{
[
wrapper
stateChanged
:
aState
isEnabled
:
aEnabled
]
;
}
}
void
PlatformFocusEvent
(
Accessible
*
aTarget
)
{
if
(
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aTarget
)
)
{
[
wrapper
handleAccessibleEvent
:
nsIAccessibleEvent
:
:
EVENT_FOCUS
]
;
}
}
void
PlatformCaretMoveEvent
(
Accessible
*
aTarget
int32_t
aOffset
bool
aIsSelectionCollapsed
int32_t
aGranularity
bool
aFromUser
)
{
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aTarget
)
;
MOXTextMarkerDelegate
*
delegate
=
[
MOXTextMarkerDelegate
getOrCreateForDoc
:
nsAccUtils
:
:
DocumentFor
(
aTarget
)
]
;
[
delegate
setCaretOffset
:
aTarget
at
:
aOffset
moveGranularity
:
aGranularity
]
;
if
(
aIsSelectionCollapsed
)
{
[
delegate
setSelectionFrom
:
aTarget
at
:
aOffset
to
:
aTarget
at
:
aOffset
]
;
}
if
(
wrapper
)
{
if
(
mozTextAccessible
*
textAcc
=
static_cast
<
mozTextAccessible
*
>
(
[
wrapper
moxEditableAncestor
]
)
)
{
[
textAcc
handleAccessibleEvent
:
nsIAccessibleEvent
:
:
EVENT_TEXT_CARET_MOVED
]
;
}
else
{
[
wrapper
handleAccessibleEvent
:
nsIAccessibleEvent
:
:
EVENT_TEXT_CARET_MOVED
]
;
}
}
}
void
PlatformTextChangeEvent
(
Accessible
*
aTarget
const
nsAString
&
aStr
int32_t
aStart
uint32_t
aLen
bool
aIsInsert
bool
aFromUser
)
{
Accessible
*
acc
=
aTarget
;
while
(
acc
&
&
GetTypeFromRole
(
acc
-
>
Role
(
)
)
!
=
[
mozTextAccessible
class
]
)
{
acc
=
acc
-
>
Parent
(
)
;
}
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
acc
?
acc
:
aTarget
)
;
[
wrapper
handleAccessibleTextChangeEvent
:
nsCocoaUtils
:
:
ToNSString
(
aStr
)
inserted
:
aIsInsert
inContainer
:
aTarget
at
:
aStart
]
;
}
void
PlatformShowHideEvent
(
Accessible
*
Accessible
*
bool
bool
)
{
}
void
PlatformSelectionEvent
(
Accessible
*
aTarget
Accessible
*
aWidget
uint32_t
aEventType
)
{
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aWidget
)
;
if
(
wrapper
)
{
[
wrapper
handleAccessibleEvent
:
aEventType
]
;
}
}
void
PlatformTextSelectionChangeEvent
(
Accessible
*
aTarget
const
nsTArray
<
TextRange
>
&
aSelection
)
{
if
(
aSelection
.
Length
(
)
)
{
MOXTextMarkerDelegate
*
delegate
=
[
MOXTextMarkerDelegate
getOrCreateForDoc
:
nsAccUtils
:
:
DocumentFor
(
aTarget
)
]
;
[
delegate
setSelectionFrom
:
aSelection
[
0
]
.
StartContainer
(
)
at
:
aSelection
[
0
]
.
StartOffset
(
)
to
:
aSelection
[
0
]
.
EndContainer
(
)
at
:
aSelection
[
0
]
.
EndOffset
(
)
]
;
}
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aTarget
)
;
if
(
wrapper
)
{
[
wrapper
handleAccessibleEvent
:
nsIAccessibleEvent
:
:
EVENT_TEXT_SELECTION_CHANGED
]
;
}
}
void
PlatformRoleChangedEvent
(
Accessible
*
aTarget
const
a11y
:
:
role
&
aRole
uint8_t
aRoleMapEntryIndex
)
{
if
(
mozAccessible
*
wrapper
=
GetNativeFromGeckoAccessible
(
aTarget
)
)
{
[
wrapper
handleRoleChanged
:
aRole
]
;
}
}
enum
class
Client
:
uint64_t
{
Unknown
VoiceOver
SwitchControl
FullKeyboardAccess
VoiceControl
SpeakSelection
SpeakItemUnderMouse
SpeakTypingFeedback
HoverText
}
;
std
:
:
pair
<
EnumSet
<
Client
>
Client
>
GetClients
(
)
{
EnumSet
<
Client
>
clients
;
std
:
:
optional
<
Client
>
clientToLog
;
auto
AddClient
=
[
&
clients
&
clientToLog
]
(
Client
client
)
{
clients
+
=
client
;
if
(
!
clientToLog
.
has_value
(
)
)
{
clientToLog
=
client
;
}
}
;
if
(
[
[
NSWorkspace
sharedWorkspace
]
respondsToSelector
:
selector
(
isVoiceOverEnabled
)
]
&
&
[
[
NSWorkspace
sharedWorkspace
]
isVoiceOverEnabled
]
)
{
AddClient
(
Client
:
:
VoiceOver
)
;
}
else
if
(
[
[
NSWorkspace
sharedWorkspace
]
respondsToSelector
:
selector
(
isSwitchControlEnabled
)
]
&
&
[
[
NSWorkspace
sharedWorkspace
]
isSwitchControlEnabled
]
)
{
AddClient
(
Client
:
:
SwitchControl
)
;
}
else
{
Boolean
foundSpecificClient
=
false
;
Boolean
exists
;
long
val
=
CFPreferencesGetAppIntegerValue
(
CFSTR
(
"
FullKeyboardAccessEnabled
"
)
CFSTR
(
"
com
.
apple
.
Accessibility
"
)
&
exists
)
;
if
(
exists
&
&
val
=
=
1
)
{
foundSpecificClient
=
true
;
AddClient
(
Client
:
:
FullKeyboardAccess
)
;
}
val
=
CFPreferencesGetAppIntegerValue
(
CFSTR
(
"
CommandAndControlEnabled
"
)
CFSTR
(
"
com
.
apple
.
Accessibility
"
)
&
exists
)
;
if
(
exists
&
&
val
=
=
1
)
{
foundSpecificClient
=
true
;
AddClient
(
Client
:
:
VoiceControl
)
;
}
val
=
CFPreferencesGetAppIntegerValue
(
CFSTR
(
"
SpeakThisEnabled
"
)
CFSTR
(
"
com
.
apple
.
universalaccess
"
)
&
exists
)
;
if
(
exists
&
&
val
=
=
1
)
{
foundSpecificClient
=
true
;
AddClient
(
Client
:
:
SpeakSelection
)
;
}
val
=
CFPreferencesGetAppIntegerValue
(
CFSTR
(
"
speakItemUnderMouseEnabled
"
)
CFSTR
(
"
com
.
apple
.
universalaccess
"
)
&
exists
)
;
if
(
exists
&
&
val
=
=
1
)
{
foundSpecificClient
=
true
;
AddClient
(
Client
:
:
SpeakItemUnderMouse
)
;
}
val
=
CFPreferencesGetAppIntegerValue
(
CFSTR
(
"
typingEchoEnabled
"
)
CFSTR
(
"
com
.
apple
.
universalaccess
"
)
&
exists
)
;
if
(
exists
&
&
val
=
=
1
)
{
foundSpecificClient
=
true
;
AddClient
(
Client
:
:
SpeakTypingFeedback
)
;
}
val
=
CFPreferencesGetAppIntegerValue
(
CFSTR
(
"
hoverTextEnabled
"
)
CFSTR
(
"
com
.
apple
.
universalaccess
"
)
&
exists
)
;
if
(
exists
&
&
val
=
=
1
)
{
foundSpecificClient
=
true
;
AddClient
(
Client
:
:
HoverText
)
;
}
if
(
!
foundSpecificClient
)
{
AddClient
(
Client
:
:
Unknown
)
;
}
}
return
std
:
:
make_pair
(
clients
clientToLog
.
value
(
)
)
;
}
constexpr
const
char
*
GetStringForClient
(
Client
aClient
)
{
switch
(
aClient
)
{
case
Client
:
:
Unknown
:
return
"
Unknown
"
;
case
Client
:
:
VoiceOver
:
return
"
VoiceOver
"
;
case
Client
:
:
SwitchControl
:
return
"
SwitchControl
"
;
case
Client
:
:
FullKeyboardAccess
:
return
"
FullKeyboardAccess
"
;
case
Client
:
:
VoiceControl
:
return
"
VoiceControl
"
;
case
Client
:
:
SpeakSelection
:
return
"
SpeakSelection
"
;
case
Client
:
:
SpeakItemUnderMouse
:
return
"
SpeakItemUnderMouse
"
;
case
Client
:
:
SpeakTypingFeedback
:
return
"
SpeakTypingFeedback
"
;
case
Client
:
:
HoverText
:
return
"
HoverText
"
;
default
:
break
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
Client
enum
value
!
"
)
;
return
"
"
;
}
uint64_t
GetCacheDomainsForKnownClients
(
uint64_t
aCacheDomains
)
{
auto
[
clients
_
]
=
GetClients
(
)
;
if
(
clients
.
contains
(
Client
:
:
VoiceOver
)
)
{
return
CacheDomain
:
:
All
;
}
if
(
clients
.
contains
(
Client
:
:
FullKeyboardAccess
)
)
{
aCacheDomains
|
=
CacheDomain
:
:
Bounds
;
}
if
(
clients
.
contains
(
Client
:
:
SwitchControl
)
)
{
return
CacheDomain
:
:
All
;
}
if
(
clients
.
contains
(
Client
:
:
VoiceControl
)
)
{
return
CacheDomain
:
:
All
;
}
return
aCacheDomains
;
}
}
}
interface
GeckoNSApplication
(
a11y
)
-
(
void
)
accessibilitySetValue
:
(
id
)
value
forAttribute
:
(
NSString
*
)
attribute
;
end
implementation
GeckoNSApplication
(
a11y
)
-
(
NSAccessibilityRole
)
accessibilityRole
{
if
(
!
mozilla
:
:
a11y
:
:
sA11yShouldBeEnabled
)
{
[
self
accessibilitySetValue
:
YES
forAttribute
:
"
AXEnhancedUserInterface
"
]
;
}
return
[
super
accessibilityRole
]
;
}
-
(
void
)
accessibilitySetValue
:
(
id
)
value
forAttribute
:
(
NSString
*
)
attribute
{
if
(
[
attribute
isEqualToString
:
"
AXEnhancedUserInterface
"
]
)
{
mozilla
:
:
a11y
:
:
sA11yShouldBeEnabled
=
(
[
value
intValue
]
=
=
1
)
;
if
(
sA11yShouldBeEnabled
)
{
auto
[
_
clientToLog
]
=
GetClients
(
)
;
const
char
*
client
=
GetStringForClient
(
clientToLog
)
;
#
if
defined
(
MOZ_TELEMETRY_REPORTING
)
mozilla
:
:
glean
:
:
a11y
:
:
instantiators
.
Set
(
nsDependentCString
(
client
)
)
;
#
endif
CrashReporter
:
:
RecordAnnotationCString
(
CrashReporter
:
:
Annotation
:
:
AccessibilityClient
client
)
;
}
}
return
[
super
accessibilitySetValue
:
value
forAttribute
:
attribute
]
;
}
end
