#
import
"
MOXWebAreaAccessible
.
h
"
#
import
"
MOXSearchInfo
.
h
"
#
import
"
MacUtils
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
DocAccessible
.
h
"
#
include
"
DocAccessibleParent
.
h
"
using
namespace
mozilla
:
:
a11y
;
implementation
MOXRootGroup
-
(
id
)
initWithParent
:
(
MOXWebAreaAccessible
*
)
parent
{
mParent
=
parent
;
return
[
super
init
]
;
}
-
(
NSString
*
)
moxRole
{
return
NSAccessibilityGroupRole
;
}
-
(
NSString
*
)
moxRoleDescription
{
if
(
[
[
self
moxSubrole
]
isEqualToString
:
"
AXLandmarkApplication
"
]
)
{
return
utils
:
:
LocalizedString
(
u
"
application
"
_ns
)
;
}
return
NSAccessibilityRoleDescription
(
NSAccessibilityGroupRole
nil
)
;
}
-
(
id
<
mozAccessible
>
)
moxParent
{
return
mParent
;
}
-
(
NSArray
*
)
moxChildren
{
return
[
mParent
rootGroupChildren
]
;
}
-
(
NSString
*
)
moxIdentifier
{
return
"
root
-
group
"
;
}
-
(
NSString
*
)
moxSubrole
{
return
[
mParent
moxSubrole
]
;
}
-
(
id
)
moxHitTest
:
(
NSPoint
)
point
{
return
[
mParent
moxHitTest
:
point
]
;
}
-
(
NSValue
*
)
moxPosition
{
return
[
mParent
moxPosition
]
;
}
-
(
NSValue
*
)
moxSize
{
return
[
mParent
moxSize
]
;
}
-
(
NSArray
*
)
moxUIElementsForSearchPredicate
:
(
NSDictionary
*
)
searchPredicate
{
MOXSearchInfo
*
search
=
[
[
[
MOXSearchInfo
alloc
]
initWithParameters
:
searchPredicate
andRoot
:
self
]
autorelease
]
;
return
[
search
performSearch
]
;
}
-
(
NSNumber
*
)
moxUIElementCountForSearchPredicate
:
(
NSDictionary
*
)
searchPredicate
{
return
[
NSNumber
numberWithDouble
:
[
[
self
moxUIElementsForSearchPredicate
:
searchPredicate
]
count
]
]
;
}
-
(
BOOL
)
disableChild
:
(
id
)
child
{
return
NO
;
}
-
(
void
)
expire
{
mParent
=
nil
;
[
super
expire
]
;
}
-
(
BOOL
)
isExpired
{
MOZ_ASSERT
(
(
mParent
=
=
nil
)
=
=
mIsExpired
)
;
return
[
super
isExpired
]
;
}
end
implementation
MOXWebAreaAccessible
-
(
NSString
*
)
moxRole
{
return
"
AXWebArea
"
;
}
-
(
NSString
*
)
moxRoleDescription
{
return
utils
:
:
LocalizedString
(
u
"
htmlContent
"
_ns
)
;
}
-
(
NSURL
*
)
moxURL
{
if
(
[
self
isExpired
]
)
{
return
nil
;
}
nsAutoString
url
;
MOZ_ASSERT
(
mGeckoAccessible
-
>
IsDoc
(
)
)
;
nsAccUtils
:
:
DocumentURL
(
mGeckoAccessible
url
)
;
if
(
url
.
IsEmpty
(
)
)
{
return
nil
;
}
return
[
NSURL
URLWithString
:
nsCocoaUtils
:
:
ToNSString
(
url
)
]
;
}
-
(
NSNumber
*
)
moxLoaded
{
if
(
[
self
isExpired
]
)
{
return
nil
;
}
return
(
[
self
stateWithMask
:
(
states
:
:
BUSY
&
states
:
:
STALE
)
]
=
=
0
)
;
}
-
(
NSNumber
*
)
moxLoadingProgress
{
if
(
[
self
isExpired
]
)
{
return
nil
;
}
if
(
[
self
stateWithMask
:
states
:
:
STALE
]
!
=
0
)
{
return
0
.
0
;
}
if
(
[
self
stateWithMask
:
states
:
:
BUSY
]
!
=
0
)
{
return
0
.
5
;
}
return
1
.
0
;
}
-
(
NSArray
*
)
moxLinkUIElements
{
NSDictionary
*
searchPredicate
=
{
"
AXSearchKey
"
:
"
AXLinkSearchKey
"
"
AXImmediateDescendantsOnly
"
:
NO
"
AXResultsLimit
"
:
(
-
1
)
"
AXDirection
"
:
"
AXDirectionNext
"
}
;
return
[
self
moxUIElementsForSearchPredicate
:
searchPredicate
]
;
}
-
(
void
)
handleAccessibleEvent
:
(
uint32_t
)
eventType
{
switch
(
eventType
)
{
case
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_LOAD_COMPLETE
:
[
self
moxPostNotification
:
NSAccessibilityFocusedUIElementChangedNotification
]
;
MOZ_ASSERT
(
mGeckoAccessible
-
>
IsRemote
(
)
|
|
mGeckoAccessible
-
>
AsLocal
(
)
-
>
IsRoot
(
)
|
|
mGeckoAccessible
-
>
AsLocal
(
)
-
>
AsDoc
(
)
-
>
ParentDocument
(
)
"
Non
-
root
doc
without
a
parent
!
"
)
;
if
(
(
mGeckoAccessible
-
>
IsRemote
(
)
&
&
mGeckoAccessible
-
>
AsRemote
(
)
-
>
IsDoc
(
)
&
&
mGeckoAccessible
-
>
AsRemote
(
)
-
>
AsDoc
(
)
-
>
IsTopLevel
(
)
)
|
|
(
mGeckoAccessible
-
>
IsLocal
(
)
&
&
!
mGeckoAccessible
-
>
AsLocal
(
)
-
>
IsRoot
(
)
&
&
mGeckoAccessible
-
>
AsLocal
(
)
-
>
AsDoc
(
)
-
>
ParentDocument
(
)
&
&
mGeckoAccessible
-
>
AsLocal
(
)
-
>
AsDoc
(
)
-
>
ParentDocument
(
)
-
>
IsRoot
(
)
)
)
{
[
self
moxPostNotification
:
"
AXLoadComplete
"
]
;
}
else
{
[
self
moxPostNotification
:
"
AXLayoutComplete
"
]
;
}
break
;
}
[
super
handleAccessibleEvent
:
eventType
]
;
}
-
(
NSArray
*
)
rootGroupChildren
{
return
[
super
moxChildren
]
;
}
-
(
NSArray
*
)
moxUnignoredChildren
{
if
(
id
rootGroup
=
[
self
rootGroup
]
)
{
return
[
[
self
rootGroup
]
]
;
}
return
[
super
moxUnignoredChildren
]
;
}
-
(
BOOL
)
moxBlockSelector
:
(
SEL
)
selector
{
if
(
selector
=
=
selector
(
moxSubrole
)
)
{
return
YES
;
}
if
(
selector
=
=
selector
(
moxElementBusy
)
)
{
return
YES
;
}
return
[
super
moxBlockSelector
:
selector
]
;
}
-
(
void
)
moxPostNotification
:
(
NSString
*
)
notification
{
if
(
!
[
notification
isEqualToString
:
"
AXElementBusyChanged
"
]
)
{
[
super
moxPostNotification
:
notification
]
;
}
}
-
(
id
)
rootGroup
{
NSArray
*
children
=
[
super
moxUnignoredChildren
]
;
if
(
mRole
=
=
roles
:
:
DOCUMENT
&
&
[
children
count
]
=
=
1
&
&
[
[
[
children
firstObject
]
moxUnignoredChildren
]
count
]
!
=
0
)
{
return
nil
;
}
if
(
!
mRootGroup
)
{
mRootGroup
=
[
[
MOXRootGroup
alloc
]
initWithParent
:
self
]
;
}
return
mRootGroup
;
}
-
(
void
)
expire
{
[
mRootGroup
expire
]
;
[
super
expire
]
;
}
-
(
void
)
dealloc
{
MOZ_ASSERT
(
[
self
isExpired
]
)
;
[
mRootGroup
release
]
;
[
super
dealloc
]
;
}
end
