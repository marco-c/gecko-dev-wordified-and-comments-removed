#
import
"
mozTableAccessible
.
h
"
#
import
"
nsCocoaUtils
.
h
"
#
import
"
MacUtils
.
h
"
#
include
"
AccIterator
.
h
"
#
include
"
LocalAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
TableAccessibleBase
.
h
"
#
include
"
mozilla
/
a11y
/
TableCellAccessibleBase
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
XULTreeAccessible
.
h
"
#
include
"
Pivot
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
Relation
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
implementation
mozColumnContainer
-
(
id
)
initWithIndex
:
(
uint32_t
)
aIndex
andParent
:
(
mozAccessible
*
)
aParent
{
self
=
[
super
init
]
;
mIndex
=
aIndex
;
mParent
=
aParent
;
return
self
;
}
-
(
NSString
*
)
moxRole
{
return
NSAccessibilityColumnRole
;
}
-
(
NSString
*
)
moxRoleDescription
{
return
NSAccessibilityRoleDescription
(
NSAccessibilityColumnRole
nil
)
;
}
-
(
mozAccessible
*
)
moxParent
{
return
mParent
;
}
-
(
NSArray
*
)
moxUnignoredChildren
{
if
(
mChildren
)
return
mChildren
;
mChildren
=
[
[
NSMutableArray
alloc
]
init
]
;
TableAccessibleBase
*
table
=
[
mParent
geckoAccessible
]
-
>
AsTableBase
(
)
;
MOZ_ASSERT
(
table
"
Got
null
table
when
fetching
column
children
!
"
)
;
uint32_t
numRows
=
table
-
>
RowCount
(
)
;
for
(
uint32_t
j
=
0
;
j
<
numRows
;
j
+
+
)
{
Accessible
*
cell
=
table
-
>
CellAt
(
j
mIndex
)
;
mozAccessible
*
nativeCell
=
cell
?
GetNativeFromGeckoAccessible
(
cell
)
:
nil
;
if
(
[
nativeCell
isAccessibilityElement
]
)
{
[
mChildren
addObject
:
nativeCell
]
;
}
}
return
mChildren
;
}
-
(
void
)
dealloc
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
self
invalidateChildren
]
;
[
super
dealloc
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
expire
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
self
invalidateChildren
]
;
mParent
=
nil
;
[
super
expire
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
BOOL
)
isExpired
{
MOZ_ASSERT
(
(
mChildren
=
=
nil
&
&
mParent
=
=
nil
)
=
=
mIsExpired
)
;
return
[
super
isExpired
]
;
}
-
(
void
)
invalidateChildren
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mChildren
)
{
[
mChildren
release
]
;
mChildren
=
nil
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
end
implementation
mozTablePartAccessible
-
(
NSString
*
)
moxTitle
{
return
"
"
;
}
-
(
NSString
*
)
moxRole
{
return
[
self
isLayoutTablePart
]
?
NSAccessibilityGroupRole
:
[
super
moxRole
]
;
}
-
(
BOOL
)
isLayoutTablePart
{
mozAccessible
*
parent
=
(
mozAccessible
*
)
[
self
moxUnignoredParent
]
;
if
(
[
parent
isKindOfClass
:
[
mozTablePartAccessible
class
]
]
)
{
return
[
(
mozTablePartAccessible
*
)
parent
isLayoutTablePart
]
;
}
else
if
(
[
parent
isKindOfClass
:
[
mozOutlineAccessible
class
]
]
)
{
return
[
(
mozOutlineAccessible
*
)
parent
isLayoutTablePart
]
;
}
return
NO
;
}
end
implementation
mozTableAccessible
-
(
BOOL
)
isLayoutTablePart
{
if
(
mGeckoAccessible
-
>
Role
(
)
=
=
roles
:
:
TREE_TABLE
)
{
return
false
;
}
if
(
LocalAccessible
*
acc
=
mGeckoAccessible
-
>
AsLocal
(
)
)
{
return
acc
-
>
AsTable
(
)
-
>
IsProbablyLayoutTable
(
)
;
}
RemoteAccessible
*
proxy
=
mGeckoAccessible
-
>
AsRemote
(
)
;
return
proxy
-
>
TableIsProbablyForLayout
(
)
;
}
-
(
void
)
handleAccessibleEvent
:
(
uint32_t
)
eventType
{
if
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_REORDER
|
|
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_OBJECT_ATTRIBUTE_CHANGED
)
{
[
self
invalidateColumns
]
;
}
[
super
handleAccessibleEvent
:
eventType
]
;
}
-
(
void
)
dealloc
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
self
invalidateColumns
]
;
[
super
dealloc
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
expire
{
[
self
invalidateColumns
]
;
[
super
expire
]
;
}
-
(
NSNumber
*
)
moxRowCount
{
MOZ_ASSERT
(
mGeckoAccessible
)
;
return
(
mGeckoAccessible
-
>
AsTableBase
(
)
-
>
RowCount
(
)
)
;
}
-
(
NSNumber
*
)
moxColumnCount
{
MOZ_ASSERT
(
mGeckoAccessible
)
;
return
(
mGeckoAccessible
-
>
AsTableBase
(
)
-
>
ColCount
(
)
)
;
}
-
(
NSArray
*
)
moxRows
{
NSArray
*
children
=
[
self
moxChildren
]
;
NSMutableArray
*
rows
=
[
[
[
NSMutableArray
alloc
]
init
]
autorelease
]
;
for
(
mozAccessible
*
curr
:
children
)
{
if
(
[
curr
isKindOfClass
:
[
mozTableRowAccessible
class
]
]
)
{
[
rows
addObject
:
curr
]
;
}
else
if
(
[
[
curr
moxRole
]
isEqualToString
:
"
AXGroup
"
]
)
{
[
rows
addObjectsFromArray
:
[
[
curr
moxChildren
]
filteredArrayUsingPredicate
:
[
NSPredicate
predicateWithBlock
:
^
BOOL
(
mozAccessible
*
child
NSDictionary
*
bindings
)
{
return
[
child
isKindOfClass
:
[
mozTableRowAccessible
class
]
]
;
}
]
]
]
;
}
}
return
rows
;
}
-
(
NSArray
*
)
moxColumns
{
MOZ_ASSERT
(
mGeckoAccessible
)
;
if
(
mColContainers
)
{
return
mColContainers
;
}
mColContainers
=
[
[
NSMutableArray
alloc
]
init
]
;
uint32_t
numCols
=
0
;
numCols
=
mGeckoAccessible
-
>
AsTableBase
(
)
-
>
ColCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numCols
;
i
+
+
)
{
mozColumnContainer
*
container
=
[
[
mozColumnContainer
alloc
]
initWithIndex
:
i
andParent
:
self
]
;
[
mColContainers
addObject
:
container
]
;
}
return
mColContainers
;
}
-
(
NSArray
*
)
moxUnignoredChildren
{
if
(
!
[
self
isLayoutTablePart
]
)
{
return
[
[
super
moxUnignoredChildren
]
arrayByAddingObjectsFromArray
:
[
self
moxColumns
]
]
;
}
return
[
super
moxUnignoredChildren
]
;
}
-
(
NSArray
*
)
moxColumnHeaderUIElements
{
MOZ_ASSERT
(
mGeckoAccessible
)
;
uint32_t
numCols
=
0
;
TableAccessibleBase
*
table
=
nullptr
;
table
=
mGeckoAccessible
-
>
AsTableBase
(
)
;
numCols
=
table
-
>
ColCount
(
)
;
NSMutableArray
*
colHeaders
=
[
[
[
NSMutableArray
alloc
]
initWithCapacity
:
numCols
]
autorelease
]
;
for
(
uint32_t
i
=
0
;
i
<
numCols
;
i
+
+
)
{
Accessible
*
cell
=
table
-
>
CellAt
(
0
i
)
;
if
(
cell
&
&
cell
-
>
Role
(
)
=
=
roles
:
:
COLUMNHEADER
)
{
mozAccessible
*
colHeader
=
GetNativeFromGeckoAccessible
(
cell
)
;
[
colHeaders
addObject
:
colHeader
]
;
}
}
return
colHeaders
;
}
-
(
id
)
moxCellForColumnAndRow
:
(
NSArray
*
)
columnAndRow
{
if
(
columnAndRow
=
=
nil
|
|
[
columnAndRow
count
]
!
=
2
)
{
return
nil
;
}
uint32_t
col
=
[
[
columnAndRow
objectAtIndex
:
0
]
unsignedIntValue
]
;
uint32_t
row
=
[
[
columnAndRow
objectAtIndex
:
1
]
unsignedIntValue
]
;
MOZ_ASSERT
(
mGeckoAccessible
)
;
Accessible
*
cell
=
mGeckoAccessible
-
>
AsTableBase
(
)
-
>
CellAt
(
row
col
)
;
if
(
!
cell
)
{
return
nil
;
}
return
GetNativeFromGeckoAccessible
(
cell
)
;
}
-
(
void
)
invalidateColumns
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mColContainers
)
{
for
(
mozColumnContainer
*
col
in
mColContainers
)
{
[
col
expire
]
;
}
[
mColContainers
release
]
;
mColContainers
=
nil
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
end
interface
mozTableRowAccessible
(
)
-
(
mozTableAccessible
*
)
getTableParent
;
end
implementation
mozTableRowAccessible
-
(
mozTableAccessible
*
)
getTableParent
{
id
tableParent
=
static_cast
<
mozTableAccessible
*
>
(
[
self
moxFindAncestor
:
^
BOOL
(
id
curr
BOOL
*
stop
)
{
if
(
[
curr
isKindOfClass
:
[
mozOutlineAccessible
class
]
]
)
{
*
stop
=
YES
;
}
return
[
curr
isKindOfClass
:
[
mozTableAccessible
class
]
]
;
}
]
)
;
return
[
tableParent
isKindOfClass
:
[
mozTableAccessible
class
]
]
?
tableParent
:
nil
;
}
-
(
void
)
handleAccessibleEvent
:
(
uint32_t
)
eventType
{
if
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_REORDER
)
{
[
[
self
getTableParent
]
invalidateColumns
]
;
}
[
super
handleAccessibleEvent
:
eventType
]
;
}
-
(
NSNumber
*
)
moxIndex
{
return
(
[
[
[
self
getTableParent
]
moxRows
]
indexOfObjectIdenticalTo
:
self
]
)
;
}
end
implementation
mozTableCellAccessible
-
(
NSValue
*
)
moxRowIndexRange
{
MOZ_ASSERT
(
mGeckoAccessible
)
;
TableCellAccessibleBase
*
cell
=
mGeckoAccessible
-
>
AsTableCellBase
(
)
;
return
[
NSValue
valueWithRange
:
NSMakeRange
(
cell
-
>
RowIdx
(
)
cell
-
>
RowExtent
(
)
)
]
;
}
-
(
NSValue
*
)
moxColumnIndexRange
{
MOZ_ASSERT
(
mGeckoAccessible
)
;
TableCellAccessibleBase
*
cell
=
mGeckoAccessible
-
>
AsTableCellBase
(
)
;
return
[
NSValue
valueWithRange
:
NSMakeRange
(
cell
-
>
ColIdx
(
)
cell
-
>
ColExtent
(
)
)
]
;
}
-
(
NSArray
*
)
moxRowHeaderUIElements
{
MOZ_ASSERT
(
mGeckoAccessible
)
;
TableCellAccessibleBase
*
cell
=
mGeckoAccessible
-
>
AsTableCellBase
(
)
;
AutoTArray
<
Accessible
*
10
>
headerCells
;
cell
-
>
RowHeaderCells
(
&
headerCells
)
;
return
utils
:
:
ConvertToNSArray
(
headerCells
)
;
}
-
(
NSArray
*
)
moxColumnHeaderUIElements
{
MOZ_ASSERT
(
mGeckoAccessible
)
;
TableCellAccessibleBase
*
cell
=
mGeckoAccessible
-
>
AsTableCellBase
(
)
;
AutoTArray
<
Accessible
*
10
>
headerCells
;
cell
-
>
ColHeaderCells
(
&
headerCells
)
;
return
utils
:
:
ConvertToNSArray
(
headerCells
)
;
}
end
class
OutlineRule
:
public
PivotRule
{
public
:
uint16_t
Match
(
Accessible
*
aAcc
)
override
{
uint16_t
result
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
if
(
nsAccUtils
:
:
MustPrune
(
aAcc
)
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
!
[
GetNativeFromGeckoAccessible
(
aAcc
)
isAccessibilityElement
]
)
{
return
result
;
}
if
(
aAcc
-
>
Role
(
)
=
=
roles
:
:
OUTLINE
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
else
if
(
aAcc
-
>
Role
(
)
=
=
roles
:
:
OUTLINEITEM
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
return
result
;
}
}
;
implementation
mozOutlineAccessible
-
(
BOOL
)
isLayoutTablePart
{
return
NO
;
}
-
(
NSArray
*
)
moxRows
{
NSMutableArray
*
allRows
=
[
[
[
NSMutableArray
alloc
]
init
]
autorelease
]
;
Pivot
p
=
Pivot
(
mGeckoAccessible
)
;
OutlineRule
rule
=
OutlineRule
(
)
;
Accessible
*
firstChild
=
mGeckoAccessible
-
>
FirstChild
(
)
;
Accessible
*
match
=
p
.
Next
(
firstChild
rule
true
)
;
while
(
match
)
{
[
allRows
addObject
:
GetNativeFromGeckoAccessible
(
match
)
]
;
match
=
p
.
Next
(
match
rule
)
;
}
return
allRows
;
}
-
(
NSArray
*
)
moxColumns
{
if
(
LocalAccessible
*
acc
=
mGeckoAccessible
-
>
AsLocal
(
)
)
{
if
(
acc
-
>
IsContent
(
)
&
&
acc
-
>
GetContent
(
)
-
>
IsXULElement
(
nsGkAtoms
:
:
tree
)
)
{
XULTreeAccessible
*
treeAcc
=
(
XULTreeAccessible
*
)
acc
;
NSMutableArray
*
cols
=
[
[
[
NSMutableArray
alloc
]
init
]
autorelease
]
;
LocalAccessible
*
treeColumns
=
treeAcc
-
>
LocalChildAt
(
0
)
;
if
(
treeColumns
)
{
uint32_t
colCount
=
treeColumns
-
>
ChildCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
colCount
;
i
+
+
)
{
LocalAccessible
*
treeColumnItem
=
treeColumns
-
>
LocalChildAt
(
i
)
;
[
cols
addObject
:
GetNativeFromGeckoAccessible
(
treeColumnItem
)
]
;
}
return
cols
;
}
}
}
return
[
]
;
}
-
(
NSArray
*
)
moxSelectedRows
{
NSMutableArray
*
selectedRows
=
[
[
[
NSMutableArray
alloc
]
init
]
autorelease
]
;
NSArray
*
allRows
=
[
self
moxRows
]
;
for
(
mozAccessible
*
row
in
allRows
)
{
if
(
[
row
stateWithMask
:
states
:
:
SELECTED
]
!
=
0
)
{
[
selectedRows
addObject
:
row
]
;
}
}
return
selectedRows
;
}
-
(
NSString
*
)
moxOrientation
{
return
NSAccessibilityVerticalOrientationValue
;
}
end
implementation
mozOutlineRowAccessible
-
(
BOOL
)
isLayoutTablePart
{
return
NO
;
}
-
(
NSNumber
*
)
moxDisclosing
{
return
(
[
self
stateWithMask
:
states
:
:
EXPANDED
]
!
=
0
)
;
}
-
(
void
)
moxSetDisclosing
:
(
NSNumber
*
)
disclosing
{
return
;
}
-
(
NSNumber
*
)
moxExpanded
{
return
(
[
self
stateWithMask
:
states
:
:
EXPANDED
]
!
=
0
)
;
}
-
(
id
)
moxDisclosedByRow
{
NSArray
<
mozAccessible
*
>
*
disclosingRows
=
[
self
getRelationsByType
:
RelationType
:
:
NODE_CHILD_OF
]
;
mozAccessible
*
disclosingRow
=
[
disclosingRows
firstObject
]
;
if
(
disclosingRow
)
{
if
(
[
[
disclosingRow
moxRole
]
isEqualToString
:
"
AXOutline
"
]
)
{
return
nil
;
}
return
disclosingRow
;
}
mozAccessible
*
parent
=
(
mozAccessible
*
)
[
self
moxUnignoredParent
]
;
if
(
[
[
parent
moxRole
]
isEqualToString
:
"
AXOutline
"
]
)
{
return
nil
;
}
if
(
[
[
parent
moxSubrole
]
isEqualToString
:
"
AXOutlineRow
"
]
)
{
disclosingRow
=
parent
;
}
return
nil
;
}
-
(
NSNumber
*
)
moxDisclosureLevel
{
GroupPos
groupPos
=
mGeckoAccessible
-
>
GroupPosition
(
)
;
return
groupPos
.
level
>
0
?
(
groupPos
.
level
-
1
)
:
(
groupPos
.
level
)
;
}
-
(
NSArray
*
)
moxDisclosedRows
{
if
(
NSArray
*
disclosedRows
=
[
self
getRelationsByType
:
RelationType
:
:
NODE_PARENT_OF
]
)
{
return
disclosedRows
;
}
return
[
[
self
moxChildren
]
filteredArrayUsingPredicate
:
[
NSPredicate
predicateWithBlock
:
^
BOOL
(
mozAccessible
*
child
NSDictionary
*
bindings
)
{
return
[
child
isKindOfClass
:
[
mozOutlineRowAccessible
class
]
]
;
}
]
]
;
}
-
(
NSNumber
*
)
moxIndex
{
id
<
MOXAccessible
>
outline
=
[
self
moxFindAncestor
:
^
BOOL
(
id
<
MOXAccessible
>
moxAcc
BOOL
*
stop
)
{
return
[
[
moxAcc
moxRole
]
isEqualToString
:
"
AXOutline
"
]
;
}
]
;
NSUInteger
index
=
[
[
outline
moxRows
]
indexOfObjectIdenticalTo
:
self
]
;
return
index
=
=
NSNotFound
?
nil
:
(
index
)
;
}
-
(
NSString
*
)
moxLabel
{
nsAutoString
title
;
mGeckoAccessible
-
>
Name
(
title
)
;
return
nsCocoaUtils
:
:
ToNSString
(
title
)
;
}
-
(
int
)
checkedValue
{
uint64_t
state
=
[
self
stateWithMask
:
(
states
:
:
CHECKABLE
|
states
:
:
CHECKED
|
states
:
:
MIXED
)
]
;
if
(
state
&
states
:
:
CHECKABLE
)
{
if
(
state
&
states
:
:
CHECKED
)
{
return
kChecked
;
}
if
(
state
&
states
:
:
MIXED
)
{
return
kMixed
;
}
return
kUnchecked
;
}
return
kUncheckable
;
}
-
(
id
)
moxValue
{
int
checkedValue
=
[
self
checkedValue
]
;
return
checkedValue
>
=
0
?
(
checkedValue
)
:
nil
;
}
-
(
void
)
stateChanged
:
(
uint64_t
)
state
isEnabled
:
(
BOOL
)
enabled
{
[
super
stateChanged
:
state
isEnabled
:
enabled
]
;
if
(
state
&
states
:
:
EXPANDED
)
{
[
self
moxPostNotification
:
(
enabled
?
NSAccessibilityRowExpandedNotification
:
NSAccessibilityRowCollapsedNotification
)
]
;
}
if
(
state
&
(
states
:
:
CHECKED
|
states
:
:
CHECKABLE
|
states
:
:
MIXED
)
)
{
[
self
moxPostNotification
:
NSAccessibilityValueChangedNotification
]
;
}
}
end
