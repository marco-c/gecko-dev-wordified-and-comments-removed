#
import
"
MOXAccessibleBase
.
h
"
#
import
"
MacSelectorMap
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
xpcAccessibleMacInterface
.
h
"
using
namespace
mozilla
:
:
a11y
;
interface
NSObject
(
MOXAccessible
)
-
(
BOOL
)
isMozAccessible
;
-
(
BOOL
)
hasMozAccessibles
;
end
implementation
NSObject
(
MOXAccessible
)
-
(
BOOL
)
isMozAccessible
{
return
[
self
conformsToProtocol
:
protocol
(
mozAccessible
)
]
;
}
-
(
BOOL
)
hasMozAccessibles
{
return
[
self
isKindOfClass
:
[
NSArray
class
]
]
&
&
[
[
(
NSArray
*
)
self
firstObject
]
isMozAccessible
]
;
}
end
interface
MOXAccessibleBase
(
)
-
(
BOOL
)
isSelectorSupported
:
(
SEL
)
selector
;
end
implementation
MOXAccessibleBase
#
pragma
mark
-
mozAccessible
/
widget
-
(
BOOL
)
hasRepresentedView
{
return
NO
;
}
-
(
id
)
representedView
{
return
nil
;
}
-
(
BOOL
)
isRoot
{
return
NO
;
}
#
pragma
mark
-
mozAccessible
/
NSAccessibility
-
(
NSArray
*
)
accessibilityAttributeNames
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
if
(
[
self
isExpired
]
)
{
return
nil
;
}
static
NSMutableDictionary
*
attributesForEachClass
=
nil
;
if
(
!
attributesForEachClass
)
{
attributesForEachClass
=
[
[
NSMutableDictionary
alloc
]
init
]
;
}
NSMutableArray
*
attributes
=
attributesForEachClass
[
[
self
class
]
]
?
:
[
[
NSMutableArray
alloc
]
init
]
;
NSDictionary
*
getters
=
mac
:
:
AttributeGetters
(
)
;
if
(
!
[
attributes
count
]
)
{
for
(
NSString
*
attribute
in
getters
)
{
SEL
selector
=
NSSelectorFromString
(
getters
[
attribute
]
)
;
if
(
[
self
isSelectorSupported
:
selector
]
)
{
[
attributes
addObject
:
attribute
]
;
}
}
if
(
[
self
moxTextMarkerDelegate
]
)
{
[
attributes
addObjectsFromArray
:
[
mac
:
:
TextAttributeGetters
(
)
allKeys
]
]
;
}
}
return
attributes
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
id
)
accessibilityAttributeValue
:
(
NSString
*
)
attribute
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
if
(
[
self
isExpired
]
)
{
return
nil
;
}
id
value
=
nil
;
NSDictionary
*
getters
=
mac
:
:
AttributeGetters
(
)
;
if
(
getters
[
attribute
]
)
{
SEL
selector
=
NSSelectorFromString
(
getters
[
attribute
]
)
;
if
(
[
self
isSelectorSupported
:
selector
]
)
{
value
=
[
self
performSelector
:
selector
]
;
}
}
else
if
(
id
textMarkerDelegate
=
[
self
moxTextMarkerDelegate
]
)
{
NSDictionary
*
textMarkerGetters
=
mac
:
:
TextAttributeGetters
(
)
;
if
(
textMarkerGetters
[
attribute
]
)
{
SEL
selector
=
NSSelectorFromString
(
textMarkerGetters
[
attribute
]
)
;
if
(
[
textMarkerDelegate
respondsToSelector
:
selector
]
)
{
value
=
[
textMarkerDelegate
performSelector
:
selector
]
;
}
}
}
if
(
[
value
isMozAccessible
]
)
{
value
=
GetObjectOrRepresentedView
(
value
)
;
return
[
value
isAccessibilityElement
]
?
value
:
nil
;
}
if
(
[
value
hasMozAccessibles
]
)
{
NSUInteger
arrSize
=
[
value
count
]
;
NSMutableArray
*
arr
=
[
[
NSMutableArray
alloc
]
initWithCapacity
:
arrSize
]
;
for
(
NSUInteger
i
=
0
;
i
<
arrSize
;
i
+
+
)
{
id
<
mozAccessible
>
mozAcc
=
GetObjectOrRepresentedView
(
value
[
i
]
)
;
if
(
[
mozAcc
isAccessibilityElement
]
)
{
[
arr
addObject
:
mozAcc
]
;
}
}
return
arr
;
}
return
value
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
BOOL
)
accessibilityIsAttributeSettable
:
(
NSString
*
)
attribute
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
if
(
[
self
isExpired
]
)
{
return
NO
;
}
NSDictionary
*
setters
=
mac
:
:
AttributeSetters
(
)
;
if
(
setters
[
attribute
]
)
{
SEL
selector
=
NSSelectorFromString
(
setters
[
attribute
]
)
;
return
(
[
self
isSelectorSupported
:
selector
]
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
NO
)
;
}
-
(
void
)
accessibilitySetValue
:
(
id
)
value
forAttribute
:
(
NSString
*
)
attribute
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
[
self
isExpired
]
)
{
return
;
}
NSDictionary
*
setters
=
mac
:
:
AttributeSetters
(
)
;
if
(
setters
[
attribute
]
)
{
SEL
selector
=
NSSelectorFromString
(
setters
[
attribute
]
)
;
if
(
[
self
isSelectorSupported
:
selector
]
)
{
[
self
performSelector
:
selector
withObject
:
value
]
;
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
NSArray
*
)
accessibilityActionNames
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
if
(
[
self
isExpired
]
)
{
return
nil
;
}
NSMutableArray
*
actionNames
=
[
[
NSMutableArray
alloc
]
init
]
;
NSDictionary
*
actions
=
mac
:
:
Actions
(
)
;
for
(
NSString
*
action
in
actions
)
{
SEL
selector
=
NSSelectorFromString
(
actions
[
action
]
)
;
if
(
[
self
isSelectorSupported
:
selector
]
)
{
[
actionNames
addObject
:
action
]
;
}
}
return
actionNames
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
void
)
accessibilityPerformAction
:
(
NSString
*
)
action
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
[
self
isExpired
]
)
{
return
;
}
NSDictionary
*
actions
=
mac
:
:
Actions
(
)
;
if
(
actions
[
action
]
)
{
SEL
selector
=
NSSelectorFromString
(
actions
[
action
]
)
;
if
(
[
self
isSelectorSupported
:
selector
]
)
{
[
self
performSelector
:
selector
]
;
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
NSString
*
)
accessibilityActionDescription
:
(
NSString
*
)
action
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
return
NSAccessibilityActionDescription
(
action
)
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
NSArray
*
)
accessibilityParameterizedAttributeNames
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
if
(
[
self
isExpired
]
)
{
return
nil
;
}
NSMutableArray
*
attributeNames
=
[
[
NSMutableArray
alloc
]
init
]
;
NSDictionary
*
attributes
=
mac
:
:
ParameterizedAttributeGetters
(
)
;
for
(
NSString
*
attribute
in
attributes
)
{
SEL
selector
=
NSSelectorFromString
(
attributes
[
attribute
]
)
;
if
(
[
self
isSelectorSupported
:
selector
]
)
{
[
attributeNames
addObject
:
attribute
]
;
}
}
if
(
[
self
moxTextMarkerDelegate
]
)
{
[
attributeNames
addObjectsFromArray
:
[
mac
:
:
ParameterizedTextAttributeGetters
(
)
allKeys
]
]
;
}
return
attributeNames
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
id
)
accessibilityAttributeValue
:
(
NSString
*
)
attribute
forParameter
:
(
id
)
parameter
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
if
(
[
self
isExpired
]
)
{
return
nil
;
}
NSDictionary
*
getters
=
mac
:
:
ParameterizedAttributeGetters
(
)
;
if
(
getters
[
attribute
]
)
{
SEL
selector
=
NSSelectorFromString
(
getters
[
attribute
]
)
;
if
(
[
self
isSelectorSupported
:
selector
]
)
{
return
[
self
performSelector
:
selector
withObject
:
parameter
]
;
}
}
else
if
(
id
textMarkerDelegate
=
[
self
moxTextMarkerDelegate
]
)
{
NSDictionary
*
textMarkerGetters
=
mac
:
:
ParameterizedTextAttributeGetters
(
)
;
if
(
textMarkerGetters
[
attribute
]
)
{
SEL
selector
=
NSSelectorFromString
(
textMarkerGetters
[
attribute
]
)
;
if
(
[
textMarkerDelegate
respondsToSelector
:
selector
]
)
{
return
[
textMarkerDelegate
performSelector
:
selector
withObject
:
parameter
]
;
}
}
}
return
nil
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
id
)
accessibilityHitTest
:
(
NSPoint
)
point
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
return
[
self
moxHitTest
:
point
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
id
)
accessibilityFocusedUIElement
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
return
[
self
moxFocusedUIElement
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
BOOL
)
isAccessibilityElement
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
if
(
[
self
isExpired
]
)
{
return
YES
;
}
id
parent
=
[
self
moxParent
]
;
return
!
[
self
moxIgnoreWithParent
:
parent
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
NO
)
;
}
-
(
BOOL
)
accessibilityNotifiesWhenDestroyed
{
return
YES
;
}
#
pragma
mark
-
MOXAccessible
protocol
-
(
id
)
moxHitTest
:
(
NSPoint
)
point
{
return
GetObjectOrRepresentedView
(
self
)
;
}
-
(
id
)
moxFocusedUIElement
{
return
GetObjectOrRepresentedView
(
self
)
;
}
-
(
void
)
moxPostNotification
:
(
NSString
*
)
notification
{
xpcAccessibleMacInterface
:
:
FireEvent
(
self
notification
)
;
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
return
;
}
if
(
!
[
self
isAccessibilityElement
]
)
{
return
;
}
NSAccessibilityPostNotification
(
GetObjectOrRepresentedView
(
self
)
notification
)
;
}
-
(
BOOL
)
moxBlockSelector
:
(
SEL
)
selector
{
return
NO
;
}
-
(
id
<
MOXTextMarkerSupport
>
)
moxTextMarkerDelegate
{
return
nil
;
}
-
(
NSArray
*
)
moxChildren
{
return
[
]
;
}
-
(
NSArray
*
)
moxUnignoredChildren
{
NSMutableArray
*
unignoredChildren
=
[
[
NSMutableArray
alloc
]
init
]
;
NSArray
*
allChildren
=
[
self
moxChildren
]
;
for
(
MOXAccessibleBase
*
nativeChild
in
allChildren
)
{
if
(
[
nativeChild
moxIgnoreWithParent
:
self
]
)
{
[
unignoredChildren
addObjectsFromArray
:
[
nativeChild
moxUnignoredChildren
]
]
;
}
else
{
[
unignoredChildren
addObject
:
nativeChild
]
;
}
}
return
unignoredChildren
;
}
-
(
id
<
mozAccessible
>
)
moxParent
{
return
nil
;
}
-
(
id
<
mozAccessible
>
)
moxUnignoredParent
{
id
nativeParent
=
[
self
moxParent
]
;
if
(
!
[
nativeParent
isAccessibilityElement
]
)
{
return
[
nativeParent
moxUnignoredParent
]
;
}
return
GetObjectOrRepresentedView
(
nativeParent
)
;
}
-
(
BOOL
)
moxIgnoreWithParent
:
(
MOXAccessibleBase
*
)
parent
{
return
[
parent
moxIgnoreChild
:
self
]
;
}
-
(
BOOL
)
moxIgnoreChild
:
(
MOXAccessibleBase
*
)
child
{
return
NO
;
}
#
pragma
mark
-
-
(
BOOL
)
isExpired
{
return
mIsExpired
;
}
-
(
void
)
expire
{
MOZ_ASSERT
(
!
mIsExpired
"
expire
called
an
expired
mozAccessible
!
"
)
;
mIsExpired
=
YES
;
[
self
moxPostNotification
:
NSAccessibilityUIElementDestroyedNotification
]
;
}
#
pragma
mark
-
Private
-
(
BOOL
)
isSelectorSupported
:
(
SEL
)
selector
{
return
[
self
respondsToSelector
:
selector
]
&
&
!
[
self
moxBlockSelector
:
selector
]
;
}
end
