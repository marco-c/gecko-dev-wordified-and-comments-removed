#
import
"
mozActionElements
.
h
"
#
import
"
MacUtils
.
h
"
#
include
"
Accessible
-
inl
.
h
"
#
include
"
DocAccessible
.
h
"
#
include
"
XULTabAccessible
.
h
"
#
include
"
nsDeckFrame
.
h
"
#
include
"
nsObjCExceptions
.
h
"
using
namespace
mozilla
:
:
a11y
;
enum
CheckboxValue
{
kUnchecked
=
0
kChecked
=
1
kMixed
=
2
}
;
implementation
mozButtonAccessible
-
(
NSArray
*
)
accessibilityAttributeNames
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
static
NSArray
*
attributes
=
nil
;
if
(
!
attributes
)
{
attributes
=
[
[
NSArray
alloc
]
initWithObjects
:
NSAccessibilityParentAttribute
NSAccessibilityRoleAttribute
NSAccessibilityRoleDescriptionAttribute
NSAccessibilityPositionAttribute
NSAccessibilitySizeAttribute
NSAccessibilityWindowAttribute
NSAccessibilityPositionAttribute
NSAccessibilityTopLevelUIElementAttribute
NSAccessibilityHelpAttribute
NSAccessibilityEnabledAttribute
NSAccessibilityFocusedAttribute
NSAccessibilityTitleAttribute
NSAccessibilityChildrenAttribute
NSAccessibilityDescriptionAttribute
NSAccessibilityRequiredAttribute
NSAccessibilityHasPopupAttribute
NSAccessibilityPopupValueAttribute
#
if
DEBUG
"
AXMozDescription
"
#
endif
nil
]
;
}
return
attributes
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
id
)
accessibilityAttributeValue
:
(
NSString
*
)
attribute
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
if
(
[
attribute
isEqualToString
:
NSAccessibilityHasPopupAttribute
]
)
{
return
[
NSNumber
numberWithBool
:
[
self
hasPopup
]
]
;
}
if
(
[
attribute
isEqualToString
:
NSAccessibilityPopupValueAttribute
]
)
{
if
(
[
self
hasPopup
]
)
{
return
utils
:
:
GetAccAttr
(
self
"
haspopup
"
)
;
}
else
{
return
nil
;
}
}
return
[
super
accessibilityAttributeValue
:
attribute
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
BOOL
)
hasPopup
{
return
(
[
self
stateWithMask
:
states
:
:
HASPOPUP
]
!
=
0
)
;
}
end
implementation
mozPopupButtonAccessible
-
(
NSString
*
)
title
{
return
"
"
;
}
-
(
NSArray
*
)
accessibilityAttributeNames
{
static
NSMutableArray
*
supportedAttributes
=
nil
;
if
(
!
supportedAttributes
)
{
supportedAttributes
=
[
[
super
accessibilityAttributeNames
]
mutableCopy
]
;
[
supportedAttributes
removeObject
:
NSAccessibilityHasPopupAttribute
]
;
[
supportedAttributes
addObject
:
NSAccessibilityValueAttribute
]
;
}
return
supportedAttributes
;
}
-
(
id
)
accessibilityAttributeValue
:
(
NSString
*
)
attribute
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
if
(
[
attribute
isEqualToString
:
NSAccessibilityHasPopupAttribute
]
)
{
return
nil
;
}
return
[
super
accessibilityAttributeValue
:
attribute
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
NSArray
*
)
children
{
if
(
[
self
stateWithMask
:
states
:
:
EXPANDED
]
=
=
0
)
{
return
[
]
;
}
return
[
super
children
]
;
}
-
(
void
)
stateChanged
:
(
uint64_t
)
state
isEnabled
:
(
BOOL
)
enabled
{
[
super
stateChanged
:
state
isEnabled
:
enabled
]
;
if
(
state
=
=
states
:
:
EXPANDED
)
{
if
(
mozAccessible
*
popup
=
(
mozAccessible
*
)
[
self
childAt
:
0
]
)
{
[
popup
postNotification
:
(
enabled
?
"
AXMenuOpened
"
:
"
AXMenuClosed
"
)
]
;
}
}
}
-
(
BOOL
)
ignoreWithParent
:
(
mozAccessible
*
)
parent
{
if
(
Accessible
*
acc
=
mGeckoAccessible
.
AsAccessible
(
)
)
{
if
(
acc
-
>
IsContent
(
)
&
&
acc
-
>
GetContent
(
)
-
>
IsXULElement
(
nsGkAtoms
:
:
menulist
)
)
{
return
YES
;
}
}
return
[
super
ignoreWithParent
:
parent
]
;
}
end
implementation
mozCheckboxAccessible
-
(
int
)
isChecked
{
uint64_t
state
=
[
self
stateWithMask
:
(
states
:
:
CHECKED
|
states
:
:
PRESSED
|
states
:
:
MIXED
)
]
;
if
(
state
&
(
states
:
:
CHECKED
|
states
:
:
PRESSED
)
)
{
return
kChecked
;
}
if
(
state
&
states
:
:
MIXED
)
{
return
kMixed
;
}
return
kUnchecked
;
}
-
(
id
)
value
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
return
[
NSNumber
numberWithInt
:
[
self
isChecked
]
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
end
implementation
mozPaneAccessible
-
(
NSUInteger
)
accessibilityArrayAttributeCount
:
(
NSString
*
)
attribute
{
if
(
[
self
isExpired
]
)
{
return
0
;
}
if
(
[
attribute
isEqualToString
:
NSAccessibilityChildrenAttribute
]
)
{
return
mGeckoAccessible
.
ChildCount
(
)
?
1
:
0
;
}
return
[
super
accessibilityArrayAttributeCount
:
attribute
]
;
}
-
(
NSArray
*
)
children
{
if
(
!
mGeckoAccessible
.
AsAccessible
(
)
)
return
nil
;
nsDeckFrame
*
deckFrame
=
do_QueryFrame
(
mGeckoAccessible
.
AsAccessible
(
)
-
>
GetFrame
(
)
)
;
nsIFrame
*
selectedFrame
=
deckFrame
?
deckFrame
-
>
GetSelectedBox
(
)
:
nullptr
;
Accessible
*
selectedAcc
=
nullptr
;
if
(
selectedFrame
)
{
nsINode
*
node
=
selectedFrame
-
>
GetContent
(
)
;
selectedAcc
=
mGeckoAccessible
.
AsAccessible
(
)
-
>
Document
(
)
-
>
GetAccessible
(
node
)
;
}
if
(
selectedAcc
)
{
mozAccessible
*
curNative
=
GetNativeFromGeckoAccessible
(
selectedAcc
)
;
if
(
curNative
)
return
[
NSArray
arrayWithObjects
:
GetObjectOrRepresentedView
(
curNative
)
nil
]
;
}
return
nil
;
}
end
implementation
mozIncrementableAccessible
-
(
NSArray
*
)
accessibilityActionNames
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
NSArray
*
actions
=
[
super
accessibilityActionNames
]
;
static
NSArray
*
sliderAttrs
=
nil
;
if
(
!
sliderAttrs
)
{
NSMutableArray
*
tempArray
=
[
NSMutableArray
new
]
;
[
tempArray
addObject
:
NSAccessibilityIncrementAction
]
;
[
tempArray
addObject
:
NSAccessibilityDecrementAction
]
;
sliderAttrs
=
[
[
NSArray
alloc
]
initWithArray
:
tempArray
]
;
[
tempArray
release
]
;
}
return
[
actions
arrayByAddingObjectsFromArray
:
sliderAttrs
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
void
)
accessibilityPerformAction
:
(
NSString
*
)
action
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
[
action
isEqualToString
:
NSAccessibilityIncrementAction
]
)
{
[
self
changeValueBySteps
:
1
]
;
}
else
if
(
[
action
isEqualToString
:
NSAccessibilityDecrementAction
]
)
{
[
self
changeValueBySteps
:
-
1
]
;
}
else
{
[
super
accessibilityPerformAction
:
action
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
changeValueBySteps
:
(
int
)
factor
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
Accessible
*
acc
=
mGeckoAccessible
.
AsAccessible
(
)
)
{
double
newVal
=
acc
-
>
CurValue
(
)
+
(
acc
-
>
Step
(
)
*
factor
)
;
double
min
=
acc
-
>
MinValue
(
)
;
double
max
=
acc
-
>
MaxValue
(
)
;
if
(
(
IsNaN
(
min
)
|
|
newVal
>
=
min
)
&
&
(
IsNaN
(
max
)
|
|
newVal
<
=
max
)
)
{
acc
-
>
SetCurValue
(
newVal
)
;
}
}
else
if
(
ProxyAccessible
*
proxy
=
mGeckoAccessible
.
AsProxy
(
)
)
{
double
newVal
=
proxy
-
>
CurValue
(
)
+
(
proxy
-
>
Step
(
)
*
factor
)
;
double
min
=
proxy
-
>
MinValue
(
)
;
double
max
=
proxy
-
>
MaxValue
(
)
;
if
(
(
IsNaN
(
min
)
|
|
newVal
>
=
min
)
&
&
(
IsNaN
(
max
)
|
|
newVal
<
=
max
)
)
{
proxy
-
>
SetCurValue
(
newVal
)
;
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
handleAccessibleEvent
:
(
uint32_t
)
eventType
{
switch
(
eventType
)
{
case
nsIAccessibleEvent
:
:
EVENT_TEXT_VALUE_CHANGE
:
case
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
:
[
self
postNotification
:
NSAccessibilityValueChangedNotification
]
;
break
;
default
:
[
super
handleAccessibleEvent
:
eventType
]
;
break
;
}
}
end
