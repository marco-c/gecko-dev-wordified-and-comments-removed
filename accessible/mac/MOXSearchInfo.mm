#
import
"
MOXSearchInfo
.
h
"
#
import
"
MOXWebAreaAccessible
.
h
"
#
import
"
RotorRules
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
DocAccessibleParent
.
h
"
using
namespace
mozilla
:
:
a11y
;
interface
MOXSearchInfo
(
)
-
(
NSMutableArray
*
)
getMatchesForRule
:
(
PivotRule
&
)
rule
;
-
(
AccessibleOrProxy
)
rootGeckoAccessible
;
-
(
AccessibleOrProxy
)
startGeckoAccessible
;
end
implementation
MOXSearchInfo
-
(
id
)
initWithParameters
:
(
NSDictionary
*
)
params
andRoot
:
(
MOXAccessibleBase
*
)
root
{
if
(
id
searchKeyParam
=
[
params
objectForKey
:
"
AXSearchKey
"
]
)
{
mSearchKeys
=
[
searchKeyParam
isKindOfClass
:
[
NSString
class
]
]
?
[
searchKeyParam
]
:
searchKeyParam
;
}
if
(
id
startElemParam
=
[
params
objectForKey
:
"
AXStartElement
"
]
)
{
mStartElem
=
startElemParam
;
}
else
{
mStartElem
=
root
;
}
mRoot
=
root
;
mResultLimit
=
[
[
params
objectForKey
:
"
AXResultsLimit
"
]
intValue
]
;
mSearchForward
=
[
[
params
objectForKey
:
"
AXDirection
"
]
isEqualToString
:
"
AXDirectionNext
"
]
;
mImmediateDescendantsOnly
=
[
[
params
objectForKey
:
"
AXImmediateDescendantsOnly
"
]
boolValue
]
;
return
[
super
init
]
;
}
-
(
AccessibleOrProxy
)
rootGeckoAccessible
{
id
root
=
[
mRoot
isKindOfClass
:
[
mozAccessible
class
]
]
?
mRoot
:
[
mRoot
moxParent
]
;
MOZ_ASSERT
(
[
mRoot
isKindOfClass
:
[
mozAccessible
class
]
]
)
;
return
[
static_cast
<
mozAccessible
*
>
(
root
)
geckoAccessible
]
;
}
-
(
AccessibleOrProxy
)
startGeckoAccessible
{
if
(
[
mStartElem
isKindOfClass
:
[
mozAccessible
class
]
]
)
{
return
[
static_cast
<
mozAccessible
*
>
(
mStartElem
)
geckoAccessible
]
;
}
return
[
self
rootGeckoAccessible
]
;
}
-
(
NSMutableArray
*
)
getMatchesForRule
:
(
PivotRule
&
)
rule
{
int
resultLimit
=
mResultLimit
;
NSMutableArray
*
matches
=
[
[
NSMutableArray
alloc
]
init
]
;
AccessibleOrProxy
geckoRootAcc
=
[
self
rootGeckoAccessible
]
;
AccessibleOrProxy
geckoStartAcc
=
[
self
startGeckoAccessible
]
;
Pivot
p
=
Pivot
(
geckoRootAcc
)
;
AccessibleOrProxy
match
;
if
(
mSearchForward
)
{
match
=
p
.
Next
(
geckoStartAcc
rule
)
;
}
else
{
if
(
geckoRootAcc
=
=
geckoStartAcc
)
{
match
=
p
.
Last
(
rule
)
;
}
else
{
match
=
p
.
Prev
(
geckoStartAcc
rule
)
;
}
}
while
(
!
match
.
IsNull
(
)
&
&
resultLimit
!
=
0
)
{
if
(
!
mSearchForward
&
&
match
=
=
geckoRootAcc
)
{
break
;
}
mozAccessible
*
nativeMatch
=
GetNativeFromGeckoAccessible
(
match
)
;
if
(
nativeMatch
)
{
[
matches
addObject
:
nativeMatch
]
;
resultLimit
-
=
1
;
}
match
=
mSearchForward
?
p
.
Next
(
match
rule
)
:
p
.
Prev
(
match
rule
)
;
}
return
matches
;
}
-
(
NSArray
*
)
performSearch
{
AccessibleOrProxy
geckoRootAcc
=
[
self
rootGeckoAccessible
]
;
NSMutableArray
*
matches
=
[
[
NSMutableArray
alloc
]
init
]
;
for
(
id
key
in
mSearchKeys
)
{
if
(
[
key
isEqualToString
:
"
AXAnyTypeSearchKey
"
]
)
{
RotorRule
rule
=
mImmediateDescendantsOnly
?
RotorRule
(
geckoRootAcc
)
:
RotorRule
(
)
;
if
(
mSearchForward
)
{
if
(
[
mStartElem
isKindOfClass
:
[
MOXWebAreaAccessible
class
]
]
)
{
if
(
id
rootGroup
=
[
static_cast
<
MOXWebAreaAccessible
*
>
(
mStartElem
)
rootGroup
]
)
{
[
matches
addObject
:
rootGroup
]
;
if
(
mResultLimit
=
=
1
)
{
continue
;
}
}
}
else
if
(
mImmediateDescendantsOnly
&
&
[
mStartElem
isKindOfClass
:
[
MOXRootGroup
class
]
]
)
{
continue
;
}
}
else
if
(
!
mSearchForward
&
&
[
mStartElem
isKindOfClass
:
[
MOXRootGroup
class
]
]
)
{
[
matches
addObject
:
[
mStartElem
moxParent
]
]
;
if
(
mResultLimit
=
=
1
)
{
continue
;
}
}
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXHeadingSearchKey
"
]
)
{
RotorRoleRule
rule
=
mImmediateDescendantsOnly
?
RotorRoleRule
(
roles
:
:
HEADING
geckoRootAcc
)
:
RotorRoleRule
(
roles
:
:
HEADING
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXArticleSearchKey
"
]
)
{
RotorRoleRule
rule
=
mImmediateDescendantsOnly
?
RotorRoleRule
(
roles
:
:
ARTICLE
geckoRootAcc
)
:
RotorRoleRule
(
roles
:
:
ARTICLE
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXTableSearchKey
"
]
)
{
RotorRoleRule
rule
=
mImmediateDescendantsOnly
?
RotorRoleRule
(
roles
:
:
TABLE
geckoRootAcc
)
:
RotorRoleRule
(
roles
:
:
TABLE
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXLandmarkSearchKey
"
]
)
{
RotorRoleRule
rule
=
mImmediateDescendantsOnly
?
RotorRoleRule
(
roles
:
:
LANDMARK
geckoRootAcc
)
:
RotorRoleRule
(
roles
:
:
LANDMARK
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXListSearchKey
"
]
)
{
RotorRoleRule
rule
=
mImmediateDescendantsOnly
?
RotorRoleRule
(
roles
:
:
LIST
geckoRootAcc
)
:
RotorRoleRule
(
roles
:
:
LIST
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXLinkSearchKey
"
]
)
{
RotorLinkRule
rule
=
mImmediateDescendantsOnly
?
RotorLinkRule
(
geckoRootAcc
)
:
RotorLinkRule
(
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXVisitedLinkSearchKey
"
]
)
{
RotorVisitedLinkRule
rule
=
mImmediateDescendantsOnly
?
RotorVisitedLinkRule
(
geckoRootAcc
)
:
RotorVisitedLinkRule
(
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXUnvisitedLinkSearchKey
"
]
)
{
RotorUnvisitedLinkRule
rule
=
mImmediateDescendantsOnly
?
RotorUnvisitedLinkRule
(
geckoRootAcc
)
:
RotorUnvisitedLinkRule
(
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXButtonSearchKey
"
]
)
{
RotorRoleRule
rule
=
mImmediateDescendantsOnly
?
RotorRoleRule
(
roles
:
:
PUSHBUTTON
geckoRootAcc
)
:
RotorRoleRule
(
roles
:
:
PUSHBUTTON
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXControlSearchKey
"
]
)
{
RotorControlRule
rule
=
mImmediateDescendantsOnly
?
RotorControlRule
(
geckoRootAcc
)
:
RotorControlRule
(
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXRadioGroupSearchKey
"
]
)
{
RotorRoleRule
rule
=
mImmediateDescendantsOnly
?
RotorRoleRule
(
roles
:
:
RADIO_GROUP
geckoRootAcc
)
:
RotorRoleRule
(
roles
:
:
RADIO_GROUP
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXFrameSearchKey
"
]
)
{
RotorRoleRule
rule
=
mImmediateDescendantsOnly
?
RotorRoleRule
(
roles
:
:
DOCUMENT
geckoRootAcc
)
:
RotorRoleRule
(
roles
:
:
DOCUMENT
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXImageSearchKey
"
]
)
{
RotorRoleRule
rule
=
mImmediateDescendantsOnly
?
RotorRoleRule
(
roles
:
:
GRAPHIC
geckoRootAcc
)
:
RotorRoleRule
(
roles
:
:
GRAPHIC
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXCheckboxSearchKey
"
]
)
{
RotorRoleRule
rule
=
mImmediateDescendantsOnly
?
RotorRoleRule
(
roles
:
:
CHECKBUTTON
geckoRootAcc
)
:
RotorRoleRule
(
roles
:
:
CHECKBUTTON
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
if
(
[
key
isEqualToString
:
"
AXStaticTextSearchKey
"
]
)
{
RotorStaticTextRule
rule
=
mImmediateDescendantsOnly
?
RotorStaticTextRule
(
geckoRootAcc
)
:
RotorStaticTextRule
(
)
;
[
matches
addObjectsFromArray
:
[
self
getMatchesForRule
:
rule
]
]
;
}
}
return
matches
;
}
-
(
void
)
dealloc
{
[
mSearchKeys
release
]
;
[
super
dealloc
]
;
}
end
