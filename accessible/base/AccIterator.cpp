#
include
"
AccIterator
.
h
"
#
include
"
AccGroupInfo
.
h
"
#
include
"
ARIAMap
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
XULTreeAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessibleParent
.
h
"
#
include
"
mozilla
/
dom
/
DocumentOrShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLLabelElement
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
AccIterator
:
:
AccIterator
(
const
LocalAccessible
*
aAccessible
filters
:
:
FilterFuncPtr
aFilterFunc
)
:
mFilterFunc
(
aFilterFunc
)
{
mState
=
new
IteratorState
(
aAccessible
)
;
}
AccIterator
:
:
~
AccIterator
(
)
{
while
(
mState
)
{
IteratorState
*
tmp
=
mState
;
mState
=
tmp
-
>
mParentState
;
delete
tmp
;
}
}
LocalAccessible
*
AccIterator
:
:
Next
(
)
{
while
(
mState
)
{
LocalAccessible
*
child
=
mState
-
>
mParent
-
>
LocalChildAt
(
mState
-
>
mIndex
+
+
)
;
if
(
!
child
)
{
IteratorState
*
tmp
=
mState
;
mState
=
mState
-
>
mParentState
;
delete
tmp
;
continue
;
}
uint32_t
result
=
mFilterFunc
(
child
)
;
if
(
result
&
filters
:
:
eMatch
)
return
child
;
if
(
!
(
result
&
filters
:
:
eSkipSubtree
)
)
{
IteratorState
*
childState
=
new
IteratorState
(
child
mState
)
;
mState
=
childState
;
}
}
return
nullptr
;
}
AccIterator
:
:
IteratorState
:
:
IteratorState
(
const
LocalAccessible
*
aParent
IteratorState
*
mParentState
)
:
mParent
(
aParent
)
mIndex
(
0
)
mParentState
(
mParentState
)
{
}
RelatedAccIterator
:
:
RelatedAccIterator
(
DocAccessible
*
aDocument
nsIContent
*
aDependentContent
nsAtom
*
aRelAttr
)
:
mDocument
(
aDocument
)
mDependentContent
(
aDependentContent
)
mRelAttr
(
aRelAttr
)
mProviders
(
nullptr
)
mIndex
(
0
)
mIsWalkingDependentElements
(
false
)
{
nsAutoString
id
;
if
(
aDependentContent
-
>
IsElement
(
)
&
&
aDependentContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
id
id
)
)
{
mProviders
=
mDocument
-
>
GetRelProviders
(
aDependentContent
-
>
AsElement
(
)
id
)
;
}
}
LocalAccessible
*
RelatedAccIterator
:
:
Next
(
)
{
if
(
!
mProviders
|
|
mIndex
=
=
mProviders
-
>
Length
(
)
)
{
if
(
mIsWalkingDependentElements
)
{
return
nullptr
;
}
mIsWalkingDependentElements
=
true
;
mIndex
=
0
;
if
(
auto
providers
=
mDocument
-
>
mDependentElementsMap
.
Lookup
(
mDependentContent
)
)
{
mProviders
=
&
providers
.
Data
(
)
;
}
else
{
mProviders
=
nullptr
;
return
nullptr
;
}
}
while
(
mIndex
<
mProviders
-
>
Length
(
)
)
{
const
auto
&
provider
=
(
*
mProviders
)
[
mIndex
+
+
]
;
if
(
mRelAttr
&
&
provider
-
>
mRelAttr
!
=
mRelAttr
)
{
continue
;
}
if
(
mIsWalkingDependentElements
&
&
!
nsCoreUtils
:
:
IsDescendantOfAnyShadowIncludingAncestor
(
mDependentContent
provider
-
>
mContent
)
)
{
continue
;
}
LocalAccessible
*
related
=
mDocument
-
>
GetAccessible
(
provider
-
>
mContent
)
;
if
(
related
)
{
return
related
;
}
if
(
provider
-
>
mContent
=
=
mDocument
-
>
GetContent
(
)
)
{
return
mDocument
;
}
}
if
(
!
mIsWalkingDependentElements
)
{
return
Next
(
)
;
}
return
nullptr
;
}
HTMLLabelIterator
:
:
HTMLLabelIterator
(
DocAccessible
*
aDocument
const
LocalAccessible
*
aAccessible
LabelFilter
aFilter
)
:
mRelIter
(
aDocument
aAccessible
-
>
GetContent
(
)
nsGkAtoms
:
:
_for
)
mAcc
(
aAccessible
)
mLabelFilter
(
aFilter
)
{
}
bool
HTMLLabelIterator
:
:
IsLabel
(
LocalAccessible
*
aLabel
)
{
dom
:
:
HTMLLabelElement
*
labelEl
=
dom
:
:
HTMLLabelElement
:
:
FromNode
(
aLabel
-
>
GetContent
(
)
)
;
return
labelEl
&
&
labelEl
-
>
GetControl
(
)
=
=
mAcc
-
>
GetContent
(
)
;
}
LocalAccessible
*
HTMLLabelIterator
:
:
Next
(
)
{
LocalAccessible
*
label
=
nullptr
;
while
(
(
label
=
mRelIter
.
Next
(
)
)
)
{
if
(
IsLabel
(
label
)
)
{
return
label
;
}
}
if
(
mLabelFilter
=
=
eSkipAncestorLabel
|
|
!
mAcc
-
>
IsWidget
(
)
)
return
nullptr
;
LocalAccessible
*
walkUp
=
mAcc
-
>
LocalParent
(
)
;
while
(
walkUp
&
&
!
walkUp
-
>
IsDoc
(
)
)
{
nsIContent
*
walkUpEl
=
walkUp
-
>
GetContent
(
)
;
if
(
IsLabel
(
walkUp
)
&
&
!
walkUpEl
-
>
AsElement
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
_for
)
)
{
mLabelFilter
=
eSkipAncestorLabel
;
return
walkUp
;
}
if
(
walkUpEl
-
>
IsHTMLElement
(
nsGkAtoms
:
:
form
)
)
break
;
walkUp
=
walkUp
-
>
LocalParent
(
)
;
}
return
nullptr
;
}
HTMLOutputIterator
:
:
HTMLOutputIterator
(
DocAccessible
*
aDocument
nsIContent
*
aElement
)
:
mRelIter
(
aDocument
aElement
nsGkAtoms
:
:
_for
)
{
}
LocalAccessible
*
HTMLOutputIterator
:
:
Next
(
)
{
LocalAccessible
*
output
=
nullptr
;
while
(
(
output
=
mRelIter
.
Next
(
)
)
)
{
if
(
output
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
output
)
)
return
output
;
}
return
nullptr
;
}
XULLabelIterator
:
:
XULLabelIterator
(
DocAccessible
*
aDocument
nsIContent
*
aElement
)
:
mRelIter
(
aDocument
aElement
nsGkAtoms
:
:
control
)
{
}
LocalAccessible
*
XULLabelIterator
:
:
Next
(
)
{
LocalAccessible
*
label
=
nullptr
;
while
(
(
label
=
mRelIter
.
Next
(
)
)
)
{
if
(
label
-
>
GetContent
(
)
-
>
IsXULElement
(
nsGkAtoms
:
:
label
)
)
return
label
;
}
return
nullptr
;
}
XULDescriptionIterator
:
:
XULDescriptionIterator
(
DocAccessible
*
aDocument
nsIContent
*
aElement
)
:
mRelIter
(
aDocument
aElement
nsGkAtoms
:
:
control
)
{
}
LocalAccessible
*
XULDescriptionIterator
:
:
Next
(
)
{
LocalAccessible
*
descr
=
nullptr
;
while
(
(
descr
=
mRelIter
.
Next
(
)
)
)
{
if
(
descr
-
>
GetContent
(
)
-
>
IsXULElement
(
nsGkAtoms
:
:
description
)
)
return
descr
;
}
return
nullptr
;
}
AssociatedElementsIterator
:
:
AssociatedElementsIterator
(
DocAccessible
*
aDoc
nsIContent
*
aContent
nsAtom
*
aIDRefsAttr
)
:
mContent
(
aContent
)
mDoc
(
aDoc
)
mCurrIdx
(
0
)
mElemIdx
(
0
)
{
if
(
mContent
-
>
IsElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
aIDRefsAttr
mIDs
)
;
if
(
mIDs
.
IsEmpty
(
)
&
&
(
aria
:
:
AttrCharacteristicsFor
(
aIDRefsAttr
)
&
ATTR_REFLECT_ELEMENTS
)
)
{
nsAccUtils
:
:
GetARIAElementsAttr
(
mContent
-
>
AsElement
(
)
aIDRefsAttr
mElements
)
;
}
}
}
const
nsDependentSubstring
AssociatedElementsIterator
:
:
NextID
(
)
{
for
(
;
mCurrIdx
<
mIDs
.
Length
(
)
;
mCurrIdx
+
+
)
{
if
(
!
NS_IsAsciiWhitespace
(
mIDs
[
mCurrIdx
]
)
)
break
;
}
if
(
mCurrIdx
>
=
mIDs
.
Length
(
)
)
return
nsDependentSubstring
(
)
;
nsAString
:
:
index_type
idStartIdx
=
mCurrIdx
;
while
(
+
+
mCurrIdx
<
mIDs
.
Length
(
)
)
{
if
(
NS_IsAsciiWhitespace
(
mIDs
[
mCurrIdx
]
)
)
break
;
}
return
Substring
(
mIDs
idStartIdx
mCurrIdx
+
+
-
idStartIdx
)
;
}
nsIContent
*
AssociatedElementsIterator
:
:
NextElem
(
)
{
while
(
true
)
{
const
nsDependentSubstring
id
=
NextID
(
)
;
if
(
id
.
IsEmpty
(
)
)
break
;
nsIContent
*
refContent
=
GetElem
(
id
)
;
if
(
refContent
)
return
refContent
;
}
while
(
nsIContent
*
element
=
mElements
.
SafeElementAt
(
mElemIdx
+
+
)
)
{
if
(
nsCoreUtils
:
:
IsDescendantOfAnyShadowIncludingAncestor
(
element
mContent
)
)
{
return
element
;
}
}
return
nullptr
;
}
dom
:
:
Element
*
AssociatedElementsIterator
:
:
GetElem
(
nsIContent
*
aContent
const
nsAString
&
aID
)
{
if
(
!
aContent
-
>
IsInNativeAnonymousSubtree
(
)
)
{
dom
:
:
DocumentOrShadowRoot
*
docOrShadowRoot
=
aContent
-
>
GetUncomposedDocOrConnectedShadowRoot
(
)
;
if
(
docOrShadowRoot
)
{
dom
:
:
Element
*
refElm
=
docOrShadowRoot
-
>
GetElementById
(
aID
)
;
if
(
refElm
)
{
return
refElm
;
}
}
}
return
nullptr
;
}
dom
:
:
Element
*
AssociatedElementsIterator
:
:
GetElem
(
const
nsDependentSubstring
&
aID
)
{
return
GetElem
(
mContent
aID
)
;
}
LocalAccessible
*
AssociatedElementsIterator
:
:
Next
(
)
{
nsIContent
*
nextEl
=
nullptr
;
while
(
(
nextEl
=
NextElem
(
)
)
)
{
LocalAccessible
*
acc
=
mDoc
-
>
GetAccessible
(
nextEl
)
;
if
(
acc
)
{
return
acc
;
}
}
return
nullptr
;
}
Accessible
*
SingleAccIterator
:
:
Next
(
)
{
Accessible
*
nextAcc
=
mAcc
;
mAcc
=
nullptr
;
if
(
!
nextAcc
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
nextAcc
-
>
IsLocal
(
)
|
|
!
nextAcc
-
>
AsLocal
(
)
-
>
IsDefunct
(
)
"
Iterator
references
defunct
accessible
?
"
)
;
return
nextAcc
;
}
Accessible
*
ItemIterator
:
:
Next
(
)
{
if
(
mContainer
)
{
mAnchor
=
AccGroupInfo
:
:
FirstItemOf
(
mContainer
)
;
mContainer
=
nullptr
;
return
mAnchor
;
}
if
(
mAnchor
)
{
mAnchor
=
AccGroupInfo
:
:
NextItemTo
(
mAnchor
)
;
}
return
mAnchor
;
}
XULTreeItemIterator
:
:
XULTreeItemIterator
(
const
XULTreeAccessible
*
aXULTree
nsITreeView
*
aTreeView
int32_t
aRowIdx
)
:
mXULTree
(
aXULTree
)
mTreeView
(
aTreeView
)
mRowCount
(
-
1
)
mContainerLevel
(
-
1
)
mCurrRowIdx
(
aRowIdx
+
1
)
{
mTreeView
-
>
GetRowCount
(
&
mRowCount
)
;
if
(
aRowIdx
!
=
-
1
)
mTreeView
-
>
GetLevel
(
aRowIdx
&
mContainerLevel
)
;
}
LocalAccessible
*
XULTreeItemIterator
:
:
Next
(
)
{
while
(
mCurrRowIdx
<
mRowCount
)
{
int32_t
level
=
0
;
mTreeView
-
>
GetLevel
(
mCurrRowIdx
&
level
)
;
if
(
level
=
=
mContainerLevel
+
1
)
{
return
mXULTree
-
>
GetTreeItemAccessible
(
mCurrRowIdx
+
+
)
;
}
if
(
level
<
=
mContainerLevel
)
{
mCurrRowIdx
=
mRowCount
;
break
;
}
mCurrRowIdx
+
+
;
}
return
nullptr
;
}
Accessible
*
RemoteAccIterator
:
:
Next
(
)
{
while
(
mIndex
<
mIds
.
Length
(
)
)
{
uint64_t
id
=
mIds
[
mIndex
+
+
]
;
Accessible
*
acc
=
mDoc
-
>
GetAccessible
(
id
)
;
if
(
acc
)
{
return
acc
;
}
}
return
nullptr
;
}
