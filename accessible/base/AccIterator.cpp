#
include
"
AccIterator
.
h
"
#
include
"
AccGroupInfo
.
h
"
#
ifdef
MOZ_XUL
#
include
"
XULTreeAccessible
.
h
"
#
endif
#
include
"
mozilla
/
dom
/
HTMLLabelElement
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
AccIterator
:
:
AccIterator
(
const
Accessible
*
aAccessible
filters
:
:
FilterFuncPtr
aFilterFunc
)
:
mFilterFunc
(
aFilterFunc
)
{
mState
=
new
IteratorState
(
aAccessible
)
;
}
AccIterator
:
:
~
AccIterator
(
)
{
while
(
mState
)
{
IteratorState
*
tmp
=
mState
;
mState
=
tmp
-
>
mParentState
;
delete
tmp
;
}
}
Accessible
*
AccIterator
:
:
Next
(
)
{
while
(
mState
)
{
Accessible
*
child
=
mState
-
>
mParent
-
>
GetChildAt
(
mState
-
>
mIndex
+
+
)
;
if
(
!
child
)
{
IteratorState
*
tmp
=
mState
;
mState
=
mState
-
>
mParentState
;
delete
tmp
;
continue
;
}
uint32_t
result
=
mFilterFunc
(
child
)
;
if
(
result
&
filters
:
:
eMatch
)
return
child
;
if
(
!
(
result
&
filters
:
:
eSkipSubtree
)
)
{
IteratorState
*
childState
=
new
IteratorState
(
child
mState
)
;
mState
=
childState
;
}
}
return
nullptr
;
}
AccIterator
:
:
IteratorState
:
:
IteratorState
(
const
Accessible
*
aParent
IteratorState
*
mParentState
)
:
mParent
(
aParent
)
mIndex
(
0
)
mParentState
(
mParentState
)
{
}
RelatedAccIterator
:
:
RelatedAccIterator
(
DocAccessible
*
aDocument
nsIContent
*
aDependentContent
nsAtom
*
aRelAttr
)
:
mDocument
(
aDocument
)
mRelAttr
(
aRelAttr
)
mProviders
(
nullptr
)
mBindingParent
(
nullptr
)
mIndex
(
0
)
{
mBindingParent
=
aDependentContent
-
>
IsInAnonymousSubtree
(
)
?
aDependentContent
-
>
GetBindingParent
(
)
:
nullptr
;
nsAtom
*
IDAttr
=
mBindingParent
?
nsGkAtoms
:
:
anonid
:
nsGkAtoms
:
:
id
;
nsAutoString
id
;
if
(
aDependentContent
-
>
IsElement
(
)
&
&
aDependentContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
IDAttr
id
)
)
{
mProviders
=
mDocument
-
>
GetRelProviders
(
aDependentContent
-
>
AsElement
(
)
id
)
;
}
}
Accessible
*
RelatedAccIterator
:
:
Next
(
)
{
if
(
!
mProviders
)
return
nullptr
;
while
(
mIndex
<
mProviders
-
>
Length
(
)
)
{
DocAccessible
:
:
AttrRelProvider
*
provider
=
(
*
mProviders
)
[
mIndex
+
+
]
;
if
(
provider
-
>
mRelAttr
=
=
mRelAttr
)
{
nsIContent
*
bindingParent
=
provider
-
>
mContent
-
>
IsInAnonymousSubtree
(
)
?
provider
-
>
mContent
-
>
GetBindingParent
(
)
:
nullptr
;
bool
inScope
=
mBindingParent
=
=
bindingParent
|
|
mBindingParent
=
=
provider
-
>
mContent
;
if
(
inScope
)
{
Accessible
*
related
=
mDocument
-
>
GetAccessible
(
provider
-
>
mContent
)
;
if
(
related
)
return
related
;
if
(
provider
-
>
mContent
=
=
mDocument
-
>
GetContent
(
)
)
return
mDocument
;
}
}
}
return
nullptr
;
}
HTMLLabelIterator
:
:
HTMLLabelIterator
(
DocAccessible
*
aDocument
const
Accessible
*
aAccessible
LabelFilter
aFilter
)
:
mRelIter
(
aDocument
aAccessible
-
>
GetContent
(
)
nsGkAtoms
:
:
_for
)
mAcc
(
aAccessible
)
mLabelFilter
(
aFilter
)
{
}
bool
HTMLLabelIterator
:
:
IsLabel
(
Accessible
*
aLabel
)
{
dom
:
:
HTMLLabelElement
*
labelEl
=
dom
:
:
HTMLLabelElement
:
:
FromNode
(
aLabel
-
>
GetContent
(
)
)
;
return
labelEl
&
&
labelEl
-
>
GetControl
(
)
=
=
mAcc
-
>
GetContent
(
)
;
}
Accessible
*
HTMLLabelIterator
:
:
Next
(
)
{
Accessible
*
label
=
nullptr
;
while
(
(
label
=
mRelIter
.
Next
(
)
)
)
{
if
(
IsLabel
(
label
)
)
{
return
label
;
}
}
if
(
mLabelFilter
=
=
eSkipAncestorLabel
|
|
!
mAcc
-
>
IsWidget
(
)
)
return
nullptr
;
Accessible
*
walkUp
=
mAcc
-
>
Parent
(
)
;
while
(
walkUp
&
&
!
walkUp
-
>
IsDoc
(
)
)
{
nsIContent
*
walkUpEl
=
walkUp
-
>
GetContent
(
)
;
if
(
IsLabel
(
walkUp
)
&
&
!
walkUpEl
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_for
)
)
{
mLabelFilter
=
eSkipAncestorLabel
;
return
walkUp
;
}
if
(
walkUpEl
-
>
IsHTMLElement
(
nsGkAtoms
:
:
form
)
)
break
;
walkUp
=
walkUp
-
>
Parent
(
)
;
}
return
nullptr
;
}
HTMLOutputIterator
:
:
HTMLOutputIterator
(
DocAccessible
*
aDocument
nsIContent
*
aElement
)
:
mRelIter
(
aDocument
aElement
nsGkAtoms
:
:
_for
)
{
}
Accessible
*
HTMLOutputIterator
:
:
Next
(
)
{
Accessible
*
output
=
nullptr
;
while
(
(
output
=
mRelIter
.
Next
(
)
)
)
{
if
(
output
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
output
)
)
return
output
;
}
return
nullptr
;
}
XULLabelIterator
:
:
XULLabelIterator
(
DocAccessible
*
aDocument
nsIContent
*
aElement
)
:
mRelIter
(
aDocument
aElement
nsGkAtoms
:
:
control
)
{
}
Accessible
*
XULLabelIterator
:
:
Next
(
)
{
Accessible
*
label
=
nullptr
;
while
(
(
label
=
mRelIter
.
Next
(
)
)
)
{
if
(
label
-
>
GetContent
(
)
-
>
IsXULElement
(
nsGkAtoms
:
:
label
)
)
return
label
;
}
return
nullptr
;
}
XULDescriptionIterator
:
:
XULDescriptionIterator
(
DocAccessible
*
aDocument
nsIContent
*
aElement
)
:
mRelIter
(
aDocument
aElement
nsGkAtoms
:
:
control
)
{
}
Accessible
*
XULDescriptionIterator
:
:
Next
(
)
{
Accessible
*
descr
=
nullptr
;
while
(
(
descr
=
mRelIter
.
Next
(
)
)
)
{
if
(
descr
-
>
GetContent
(
)
-
>
IsXULElement
(
nsGkAtoms
:
:
description
)
)
return
descr
;
}
return
nullptr
;
}
IDRefsIterator
:
:
IDRefsIterator
(
DocAccessible
*
aDoc
nsIContent
*
aContent
nsAtom
*
aIDRefsAttr
)
:
mContent
(
aContent
)
mDoc
(
aDoc
)
mCurrIdx
(
0
)
{
if
(
mContent
-
>
IsElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
aIDRefsAttr
mIDs
)
;
}
}
const
nsDependentSubstring
IDRefsIterator
:
:
NextID
(
)
{
for
(
;
mCurrIdx
<
mIDs
.
Length
(
)
;
mCurrIdx
+
+
)
{
if
(
!
NS_IsAsciiWhitespace
(
mIDs
[
mCurrIdx
]
)
)
break
;
}
if
(
mCurrIdx
>
=
mIDs
.
Length
(
)
)
return
nsDependentSubstring
(
)
;
nsAString
:
:
index_type
idStartIdx
=
mCurrIdx
;
while
(
+
+
mCurrIdx
<
mIDs
.
Length
(
)
)
{
if
(
NS_IsAsciiWhitespace
(
mIDs
[
mCurrIdx
]
)
)
break
;
}
return
Substring
(
mIDs
idStartIdx
mCurrIdx
+
+
-
idStartIdx
)
;
}
nsIContent
*
IDRefsIterator
:
:
NextElem
(
)
{
while
(
true
)
{
const
nsDependentSubstring
id
=
NextID
(
)
;
if
(
id
.
IsEmpty
(
)
)
break
;
nsIContent
*
refContent
=
GetElem
(
id
)
;
if
(
refContent
)
return
refContent
;
}
return
nullptr
;
}
dom
:
:
Element
*
IDRefsIterator
:
:
GetElem
(
nsIContent
*
aContent
const
nsAString
&
aID
)
{
if
(
!
aContent
-
>
IsInAnonymousSubtree
(
)
)
{
dom
:
:
DocumentOrShadowRoot
*
docOrShadowRoot
=
aContent
-
>
GetUncomposedDocOrConnectedShadowRoot
(
)
;
if
(
docOrShadowRoot
)
{
dom
:
:
Element
*
refElm
=
docOrShadowRoot
-
>
GetElementById
(
aID
)
;
if
(
refElm
|
|
!
aContent
-
>
GetXBLBinding
(
)
)
{
return
refElm
;
}
}
}
nsIContent
*
bindingParent
=
aContent
-
>
GetBindingParent
(
)
;
if
(
bindingParent
)
{
dom
:
:
Element
*
refElm
=
bindingParent
-
>
OwnerDoc
(
)
-
>
GetAnonymousElementByAttribute
(
bindingParent
nsGkAtoms
:
:
anonid
aID
)
;
if
(
refElm
)
return
refElm
;
}
if
(
aContent
-
>
GetXBLBinding
(
)
)
{
return
aContent
-
>
OwnerDoc
(
)
-
>
GetAnonymousElementByAttribute
(
aContent
nsGkAtoms
:
:
anonid
aID
)
;
}
return
nullptr
;
}
dom
:
:
Element
*
IDRefsIterator
:
:
GetElem
(
const
nsDependentSubstring
&
aID
)
{
return
GetElem
(
mContent
aID
)
;
}
Accessible
*
IDRefsIterator
:
:
Next
(
)
{
nsIContent
*
nextEl
=
nullptr
;
while
(
(
nextEl
=
NextElem
(
)
)
)
{
Accessible
*
acc
=
mDoc
-
>
GetAccessible
(
nextEl
)
;
if
(
acc
)
{
return
acc
;
}
}
return
nullptr
;
}
Accessible
*
SingleAccIterator
:
:
Next
(
)
{
RefPtr
<
Accessible
>
nextAcc
;
mAcc
.
swap
(
nextAcc
)
;
if
(
!
nextAcc
|
|
nextAcc
-
>
IsDefunct
(
)
)
{
return
nullptr
;
}
return
nextAcc
;
}
Accessible
*
ItemIterator
:
:
Next
(
)
{
if
(
mContainer
)
{
mAnchor
=
AccGroupInfo
:
:
FirstItemOf
(
mContainer
)
;
mContainer
=
nullptr
;
return
mAnchor
;
}
return
mAnchor
?
(
mAnchor
=
AccGroupInfo
:
:
NextItemTo
(
mAnchor
)
)
:
nullptr
;
}
XULTreeItemIterator
:
:
XULTreeItemIterator
(
const
XULTreeAccessible
*
aXULTree
nsITreeView
*
aTreeView
int32_t
aRowIdx
)
:
mXULTree
(
aXULTree
)
mTreeView
(
aTreeView
)
mRowCount
(
-
1
)
mContainerLevel
(
-
1
)
mCurrRowIdx
(
aRowIdx
+
1
)
{
mTreeView
-
>
GetRowCount
(
&
mRowCount
)
;
if
(
aRowIdx
!
=
-
1
)
mTreeView
-
>
GetLevel
(
aRowIdx
&
mContainerLevel
)
;
}
Accessible
*
XULTreeItemIterator
:
:
Next
(
)
{
while
(
mCurrRowIdx
<
mRowCount
)
{
int32_t
level
=
0
;
mTreeView
-
>
GetLevel
(
mCurrRowIdx
&
level
)
;
if
(
level
=
=
mContainerLevel
+
1
)
return
mXULTree
-
>
GetTreeItemAccessible
(
mCurrRowIdx
+
+
)
;
if
(
level
<
=
mContainerLevel
)
{
mCurrRowIdx
=
mRowCount
;
break
;
}
mCurrRowIdx
+
+
;
}
return
nullptr
;
}
