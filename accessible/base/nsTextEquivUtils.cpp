#
include
"
nsTextEquivUtils
.
h
"
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
AccIterator
.
h
"
#
include
"
CssAltContent
.
h
"
#
include
"
nsCoreUtils
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
static
const
Accessible
*
sInitiatorAcc
=
nullptr
;
static
bool
sInAriaRelationTraversal
=
false
;
static
nsTHashSet
<
const
Accessible
*
>
&
GetReferencedAccs
(
)
{
static
nsTHashSet
<
const
Accessible
*
>
sReferencedAccs
;
return
sReferencedAccs
;
}
nsresult
nsTextEquivUtils
:
:
GetNameFromSubtree
(
const
LocalAccessible
*
aAccessible
nsAString
&
aName
)
{
aName
.
Truncate
(
)
;
if
(
GetReferencedAccs
(
)
.
Contains
(
aAccessible
)
)
{
return
NS_OK
;
}
if
(
GetReferencedAccs
(
)
.
IsEmpty
(
)
)
{
sInitiatorAcc
=
aAccessible
;
}
GetReferencedAccs
(
)
.
Insert
(
aAccessible
)
;
if
(
GetRoleRule
(
aAccessible
-
>
Role
(
)
)
=
=
eNameFromSubtreeRule
)
{
if
(
aAccessible
-
>
IsContent
(
)
)
{
nsAutoString
name
;
AppendFromAccessibleChildren
(
aAccessible
&
name
)
;
name
.
CompressWhitespace
(
)
;
if
(
!
nsCoreUtils
:
:
IsWhitespaceString
(
name
)
)
aName
=
name
;
}
}
if
(
aAccessible
=
=
sInitiatorAcc
)
{
GetReferencedAccs
(
)
.
Clear
(
)
;
sInitiatorAcc
=
nullptr
;
}
return
NS_OK
;
}
nsresult
nsTextEquivUtils
:
:
GetTextEquivFromIDRefs
(
const
LocalAccessible
*
aAccessible
nsAtom
*
aIDRefsAttr
nsAString
&
aTextEquiv
)
{
const
bool
isAriaTraversal
=
aIDRefsAttr
=
=
nsGkAtoms
:
:
aria_labelledby
|
|
aIDRefsAttr
=
=
nsGkAtoms
:
:
aria_describedby
;
if
(
(
sInAriaRelationTraversal
&
&
isAriaTraversal
)
|
|
GetReferencedAccs
(
)
.
Contains
(
aAccessible
)
)
{
return
NS_OK
;
}
aTextEquiv
.
Truncate
(
)
;
nsIContent
*
content
=
aAccessible
-
>
GetContent
(
)
;
if
(
!
content
)
return
NS_OK
;
nsIContent
*
refContent
=
nullptr
;
AssociatedElementsIterator
iter
(
aAccessible
-
>
Document
(
)
content
aIDRefsAttr
)
;
while
(
(
refContent
=
iter
.
NextElem
(
)
)
)
{
if
(
!
aTextEquiv
.
IsEmpty
(
)
)
aTextEquiv
+
=
'
'
;
if
(
isAriaTraversal
)
{
sInAriaRelationTraversal
=
true
;
}
auto
onExit
=
MakeScopeExit
(
[
isAriaTraversal
]
(
)
{
if
(
isAriaTraversal
)
{
sInAriaRelationTraversal
=
false
;
}
}
)
;
nsresult
rv
=
AppendTextEquivFromContent
(
aAccessible
refContent
&
aTextEquiv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
nsTextEquivUtils
:
:
AppendTextEquivFromContent
(
const
LocalAccessible
*
aInitiatorAcc
nsIContent
*
aContent
nsAString
*
aString
)
{
LocalAccessible
*
accessible
=
aInitiatorAcc
-
>
Document
(
)
-
>
GetAccessible
(
aContent
)
;
if
(
GetReferencedAccs
(
)
.
Contains
(
aInitiatorAcc
)
|
|
GetReferencedAccs
(
)
.
Contains
(
accessible
)
)
{
return
NS_OK
;
}
if
(
GetReferencedAccs
(
)
.
IsEmpty
(
)
)
{
sInitiatorAcc
=
aInitiatorAcc
;
}
GetReferencedAccs
(
)
.
Insert
(
aInitiatorAcc
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
if
(
accessible
)
{
rv
=
AppendFromAccessible
(
accessible
aString
)
;
GetReferencedAccs
(
)
.
Insert
(
accessible
)
;
}
else
{
rv
=
AppendFromDOMNode
(
aContent
aString
)
;
}
if
(
aInitiatorAcc
=
=
sInitiatorAcc
)
{
GetReferencedAccs
(
)
.
Clear
(
)
;
sInitiatorAcc
=
nullptr
;
}
return
rv
;
}
nsresult
nsTextEquivUtils
:
:
AppendTextEquivFromTextContent
(
nsIContent
*
aContent
nsAString
*
aString
)
{
if
(
aContent
-
>
IsText
(
)
)
{
if
(
aContent
-
>
TextLength
(
)
>
0
)
{
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
if
(
auto
cssAlt
=
CssAltContent
(
aContent
)
)
{
cssAlt
.
AppendToString
(
*
aString
)
;
}
else
{
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
0
UINT32_MAX
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInContentText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
aString
-
>
Append
(
text
.
mString
)
;
}
}
else
{
aContent
-
>
GetAsText
(
)
-
>
AppendTextTo
(
*
aString
)
;
}
}
return
NS_OK
;
}
if
(
aContent
-
>
IsHTMLElement
(
)
&
&
aContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
br
)
)
{
aString
-
>
AppendLiteral
(
"
\
r
\
n
"
)
;
return
NS_OK
;
}
return
NS_OK_NO_NAME_CLAUSE_HANDLED
;
}
nsresult
nsTextEquivUtils
:
:
AppendFromDOMChildren
(
nsIContent
*
aContent
nsAString
*
aString
)
{
auto
iter
=
dom
:
:
AllChildrenIterator
(
aContent
nsIContent
:
:
eAllChildren
true
)
;
while
(
nsIContent
*
childContent
=
iter
.
GetNextChild
(
)
)
{
nsresult
rv
=
AppendFromDOMNode
(
childContent
aString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
nsTextEquivUtils
:
:
AppendFromAccessibleChildren
(
const
Accessible
*
aAccessible
nsAString
*
aString
)
{
nsresult
rv
=
NS_OK_NO_NAME_CLAUSE_HANDLED
;
uint32_t
childCount
=
aAccessible
-
>
ChildCount
(
)
;
for
(
uint32_t
childIdx
=
0
;
childIdx
<
childCount
;
childIdx
+
+
)
{
Accessible
*
child
=
aAccessible
-
>
ChildAt
(
childIdx
)
;
if
(
GetReferencedAccs
(
)
.
Contains
(
child
)
)
{
continue
;
}
rv
=
AppendFromAccessible
(
child
aString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
rv
;
}
nsresult
nsTextEquivUtils
:
:
AppendFromAccessible
(
Accessible
*
aAccessible
nsAString
*
aString
)
{
bool
isHTMLBlock
=
false
;
if
(
aAccessible
-
>
IsLocal
(
)
&
&
aAccessible
-
>
AsLocal
(
)
-
>
IsContent
(
)
)
{
nsIContent
*
content
=
aAccessible
-
>
AsLocal
(
)
-
>
GetContent
(
)
;
nsresult
rv
=
AppendTextEquivFromTextContent
(
content
aString
)
;
if
(
rv
!
=
NS_OK_NO_NAME_CLAUSE_HANDLED
)
return
rv
;
if
(
!
content
-
>
IsText
(
)
)
{
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
const
nsStyleDisplay
*
display
=
frame
-
>
StyleDisplay
(
)
;
if
(
display
-
>
IsBlockOutsideStyle
(
)
|
|
display
-
>
mDisplay
=
=
StyleDisplay
:
:
InlineBlock
|
|
display
-
>
mDisplay
=
=
StyleDisplay
:
:
TableCell
)
{
isHTMLBlock
=
true
;
if
(
!
aString
-
>
IsEmpty
(
)
)
{
aString
-
>
Append
(
char16_t
(
'
'
)
)
;
}
}
}
}
}
bool
isEmptyTextEquiv
=
true
;
nsAutoString
val
;
nsresult
rv
=
AppendFromValue
(
aAccessible
&
val
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
rv
=
=
NS_OK
)
{
AppendString
(
aString
val
)
;
return
NS_OK
;
}
nsAutoString
text
;
if
(
aAccessible
-
>
Name
(
text
)
!
=
eNameFromTooltip
)
{
isEmptyTextEquiv
=
!
AppendString
(
aString
text
)
;
}
if
(
isEmptyTextEquiv
)
{
if
(
ShouldIncludeInSubtreeCalculation
(
aAccessible
)
)
{
rv
=
AppendFromAccessibleChildren
(
aAccessible
aString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
rv
!
=
NS_OK_NO_NAME_CLAUSE_HANDLED
)
isEmptyTextEquiv
=
false
;
}
}
if
(
isEmptyTextEquiv
&
&
!
text
.
IsEmpty
(
)
)
{
AppendString
(
aString
text
)
;
if
(
isHTMLBlock
)
{
aString
-
>
Append
(
char16_t
(
'
'
)
)
;
}
return
NS_OK
;
}
if
(
!
isEmptyTextEquiv
&
&
isHTMLBlock
)
{
aString
-
>
Append
(
char16_t
(
'
'
)
)
;
}
return
rv
;
}
nsresult
nsTextEquivUtils
:
:
AppendFromValue
(
Accessible
*
aAccessible
nsAString
*
aString
)
{
if
(
GetRoleRule
(
aAccessible
-
>
Role
(
)
)
!
=
eNameFromValueRule
)
{
return
NS_OK_NO_NAME_CLAUSE_HANDLED
;
}
if
(
aAccessible
=
=
sInitiatorAcc
)
{
return
NS_OK_NO_NAME_CLAUSE_HANDLED
;
}
nsAutoString
text
;
if
(
aAccessible
-
>
IsListControl
(
)
)
{
Accessible
*
selected
=
aAccessible
-
>
GetSelectedItem
(
0
)
;
if
(
selected
)
{
nsresult
rv
=
AppendFromAccessible
(
selected
&
text
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
AppendString
(
aString
text
)
?
NS_OK
:
NS_OK_NO_NAME_CLAUSE_HANDLED
;
}
return
NS_ERROR_FAILURE
;
}
aAccessible
-
>
Value
(
text
)
;
return
AppendString
(
aString
text
)
?
NS_OK
:
NS_OK_NO_NAME_CLAUSE_HANDLED
;
}
nsresult
nsTextEquivUtils
:
:
AppendFromDOMNode
(
nsIContent
*
aContent
nsAString
*
aString
)
{
nsresult
rv
=
AppendTextEquivFromTextContent
(
aContent
aString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
rv
!
=
NS_OK_NO_NAME_CLAUSE_HANDLED
)
return
NS_OK
;
if
(
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
script
nsGkAtoms
:
:
style
)
)
{
return
NS_OK
;
}
if
(
aContent
-
>
IsXULElement
(
)
)
{
nsAutoString
textEquivalent
;
if
(
aContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
label
kNameSpaceID_XUL
)
)
{
aContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
value
textEquivalent
)
;
}
else
{
aContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
label
textEquivalent
)
;
}
if
(
textEquivalent
.
IsEmpty
(
)
)
{
aContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
tooltiptext
textEquivalent
)
;
}
AppendString
(
aString
textEquivalent
)
;
}
return
AppendFromDOMChildren
(
aContent
aString
)
;
}
bool
nsTextEquivUtils
:
:
AppendString
(
nsAString
*
aString
const
nsAString
&
aTextEquivalent
)
{
if
(
aTextEquivalent
.
IsEmpty
(
)
)
return
false
;
if
(
!
aString
-
>
IsEmpty
(
)
&
&
!
nsCoreUtils
:
:
IsWhitespace
(
aString
-
>
Last
(
)
)
)
{
aString
-
>
Append
(
char16_t
(
'
'
)
)
;
}
aString
-
>
Append
(
aTextEquivalent
)
;
if
(
!
nsCoreUtils
:
:
IsWhitespace
(
aString
-
>
Last
(
)
)
)
{
aString
-
>
Append
(
char16_t
(
'
'
)
)
;
}
return
true
;
}
uint32_t
nsTextEquivUtils
:
:
GetRoleRule
(
role
aRole
)
{
#
define
ROLE
(
geckoRole
stringRole
ariaRole
atkRole
macRole
macSubrole
\
msaaRole
ia2Role
androidClass
iosIsElement
uiaControlType
\
nameRule
)
\
case
roles
:
:
geckoRole
:
\
return
nameRule
;
switch
(
aRole
)
{
#
include
"
RoleMap
.
h
"
default
:
MOZ_CRASH
(
"
Unknown
role
.
"
)
;
}
#
undef
ROLE
}
bool
nsTextEquivUtils
:
:
ShouldIncludeInSubtreeCalculation
(
Accessible
*
aAccessible
)
{
uint32_t
nameRule
=
GetRoleRule
(
aAccessible
-
>
Role
(
)
)
;
if
(
nameRule
=
=
eNameFromSubtreeRule
)
{
return
true
;
}
if
(
!
(
nameRule
&
eNameFromSubtreeIfReqRule
)
)
{
return
false
;
}
if
(
aAccessible
=
=
sInitiatorAcc
)
{
return
false
;
}
role
initiatorRole
=
sInitiatorAcc
?
sInitiatorAcc
-
>
Role
(
)
:
roles
:
:
NOTHING
;
if
(
initiatorRole
=
=
roles
:
:
OUTLINEITEM
&
&
aAccessible
-
>
Role
(
)
=
=
roles
:
:
GROUPING
)
{
return
false
;
}
return
true
;
}
bool
nsTextEquivUtils
:
:
IsWhitespaceLeaf
(
Accessible
*
aAccessible
)
{
if
(
!
aAccessible
|
|
!
aAccessible
-
>
IsTextLeaf
(
)
)
{
return
false
;
}
nsAutoString
name
;
aAccessible
-
>
Name
(
name
)
;
return
nsCoreUtils
:
:
IsWhitespaceString
(
name
)
;
}
