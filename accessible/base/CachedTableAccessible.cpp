#
include
"
CachedTableAccessible
.
h
"
#
include
"
AccIterator
.
h
"
#
include
"
DocAccessibleParent
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsIAccessiblePivot
.
h
"
#
include
"
Pivot
.
h
"
#
include
"
RemoteAccessible
.
h
"
#
include
"
TableCellAccessible
.
h
"
namespace
mozilla
:
:
a11y
{
class
TablePartRule
:
public
PivotRule
{
public
:
virtual
uint16_t
Match
(
Accessible
*
aAcc
)
override
{
role
accRole
=
aAcc
-
>
Role
(
)
;
if
(
accRole
=
=
roles
:
:
CAPTION
|
|
aAcc
-
>
IsTableCell
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
|
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
aAcc
-
>
IsTableRow
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
if
(
aAcc
-
>
IsTable
(
)
|
|
accRole
=
=
roles
:
:
TEXT
|
|
accRole
=
=
roles
:
:
TEXT_CONTAINER
|
|
accRole
=
=
roles
:
:
SECTION
|
|
accRole
=
=
roles
:
:
GROUPING
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
}
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
|
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
}
;
class
RemoteExplicitHeadersIterator
:
public
AccIterable
{
public
:
RemoteExplicitHeadersIterator
(
const
nsTArray
<
uint64_t
>
&
aHeaders
Accessible
*
aDoc
)
:
mHeaders
(
aHeaders
)
mDoc
(
aDoc
)
mIndex
(
0
)
{
}
virtual
Accessible
*
Next
(
)
override
{
while
(
mIndex
<
mHeaders
.
Length
(
)
)
{
uint64_t
id
=
mHeaders
[
mIndex
+
+
]
;
Accessible
*
acc
=
nsAccUtils
:
:
GetAccessibleByID
(
mDoc
id
)
;
if
(
acc
)
{
return
acc
;
}
}
return
nullptr
;
}
private
:
const
nsTArray
<
uint64_t
>
&
mHeaders
;
Accessible
*
mDoc
;
uint32_t
mIndex
;
}
;
using
CachedTablesMap
=
nsTHashMap
<
Accessible
*
CachedTableAccessible
>
;
static
StaticAutoPtr
<
CachedTablesMap
>
sCachedTables
;
CachedTableAccessible
*
CachedTableAccessible
:
:
GetFrom
(
Accessible
*
aAcc
)
{
if
(
!
sCachedTables
)
{
sCachedTables
=
new
CachedTablesMap
(
)
;
ClearOnShutdown
(
&
sCachedTables
)
;
}
return
&
sCachedTables
-
>
LookupOrInsertWith
(
aAcc
[
&
]
{
return
CachedTableAccessible
(
aAcc
)
;
}
)
;
}
void
CachedTableAccessible
:
:
Invalidate
(
Accessible
*
aAcc
)
{
if
(
!
sCachedTables
)
{
return
;
}
Accessible
*
table
=
nullptr
;
if
(
aAcc
-
>
IsTable
(
)
)
{
table
=
aAcc
;
}
else
if
(
aAcc
-
>
IsTableCell
(
)
)
{
for
(
table
=
aAcc
-
>
Parent
(
)
;
table
;
table
=
table
-
>
Parent
(
)
)
{
if
(
table
-
>
IsTable
(
)
)
{
break
;
}
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
only
be
called
on
a
table
or
a
cell
"
)
;
}
if
(
table
)
{
sCachedTables
-
>
Remove
(
table
)
;
}
}
CachedTableAccessible
:
:
CachedTableAccessible
(
Accessible
*
aAcc
)
:
mAcc
(
aAcc
)
{
MOZ_ASSERT
(
mAcc
)
;
int32_t
rowIdx
=
-
1
;
uint32_t
colIdx
=
0
;
nsTHashMap
<
uint32_t
uint32_t
>
prevColHeaders
;
Pivot
pivot
(
mAcc
)
;
TablePartRule
rule
;
for
(
Accessible
*
part
=
pivot
.
Next
(
mAcc
rule
)
;
part
;
part
=
pivot
.
Next
(
part
rule
)
)
{
role
partRole
=
part
-
>
Role
(
)
;
if
(
partRole
=
=
roles
:
:
CAPTION
)
{
if
(
!
mCaptionAccID
)
{
mCaptionAccID
=
part
-
>
ID
(
)
;
}
continue
;
}
if
(
part
-
>
IsTableRow
(
)
)
{
+
+
rowIdx
;
colIdx
=
0
;
EnsureRow
(
rowIdx
)
;
continue
;
}
MOZ_ASSERT
(
part
-
>
IsTableCell
(
)
)
;
if
(
rowIdx
=
=
-
1
)
{
continue
;
}
for
(
;
;
)
{
EnsureRowCol
(
rowIdx
colIdx
)
;
if
(
mRowColToCellIdx
[
rowIdx
]
[
colIdx
]
=
=
kNoCellIdx
)
{
break
;
}
+
+
colIdx
;
}
uint32_t
cellIdx
=
mCells
.
Length
(
)
;
auto
prevColHeader
=
prevColHeaders
.
MaybeGet
(
colIdx
)
;
auto
cell
=
mCells
.
AppendElement
(
CachedTableCellAccessible
(
part
-
>
ID
(
)
part
rowIdx
colIdx
prevColHeader
?
*
prevColHeader
:
kNoCellIdx
)
)
;
mAccToCellIdx
.
InsertOrUpdate
(
part
cellIdx
)
;
uint32_t
lastRowForCell
=
static_cast
<
uint32_t
>
(
rowIdx
)
+
cell
-
>
RowExtent
(
)
-
1
;
MOZ_ASSERT
(
lastRowForCell
>
=
static_cast
<
uint32_t
>
(
rowIdx
)
)
;
uint32_t
lastColForCell
=
colIdx
+
cell
-
>
ColExtent
(
)
-
1
;
MOZ_ASSERT
(
lastColForCell
>
=
colIdx
)
;
for
(
uint32_t
spannedRow
=
static_cast
<
uint32_t
>
(
rowIdx
)
;
spannedRow
<
=
lastRowForCell
;
+
+
spannedRow
)
{
for
(
uint32_t
spannedCol
=
colIdx
;
spannedCol
<
=
lastColForCell
;
+
+
spannedCol
)
{
EnsureRowCol
(
spannedRow
spannedCol
)
;
MOZ_ASSERT
(
mRowColToCellIdx
[
spannedRow
]
[
spannedCol
]
=
=
kNoCellIdx
)
;
auto
&
rowCol
=
mRowColToCellIdx
[
spannedRow
]
[
spannedCol
]
;
if
(
rowCol
=
=
kNoCellIdx
)
{
rowCol
=
cellIdx
;
}
}
}
if
(
partRole
=
=
roles
:
:
COLUMNHEADER
)
{
for
(
uint32_t
spannedCol
=
colIdx
;
spannedCol
<
=
lastColForCell
;
+
+
spannedCol
)
{
prevColHeaders
.
InsertOrUpdate
(
spannedCol
cellIdx
)
;
}
}
colIdx
=
lastColForCell
+
1
;
}
}
void
CachedTableAccessible
:
:
EnsureRow
(
uint32_t
aRowIdx
)
{
for
(
uint32_t
newRow
=
mRowColToCellIdx
.
Length
(
)
;
newRow
<
=
aRowIdx
;
+
+
newRow
)
{
mRowColToCellIdx
.
AppendElement
(
)
;
}
MOZ_ASSERT
(
mRowColToCellIdx
.
Length
(
)
>
aRowIdx
)
;
}
void
CachedTableAccessible
:
:
EnsureRowCol
(
uint32_t
aRowIdx
uint32_t
aColIdx
)
{
EnsureRow
(
aRowIdx
)
;
auto
&
row
=
mRowColToCellIdx
[
aRowIdx
]
;
for
(
uint32_t
newCol
=
row
.
Length
(
)
;
newCol
<
=
aColIdx
;
+
+
newCol
)
{
row
.
AppendElement
(
kNoCellIdx
)
;
}
MOZ_ASSERT
(
row
.
Length
(
)
>
aColIdx
)
;
if
(
mColCount
<
=
aColIdx
)
{
+
+
mColCount
;
}
}
Accessible
*
CachedTableAccessible
:
:
Caption
(
)
const
{
if
(
mCaptionAccID
)
{
Accessible
*
caption
=
nsAccUtils
:
:
GetAccessibleByID
(
nsAccUtils
:
:
DocumentFor
(
mAcc
)
mCaptionAccID
)
;
MOZ_ASSERT
(
caption
"
Dead
caption
Accessible
!
"
)
;
MOZ_ASSERT
(
caption
-
>
Role
(
)
!
=
roles
:
:
CAPTION
"
Caption
has
wrong
role
"
)
;
return
caption
;
}
return
nullptr
;
}
void
CachedTableAccessible
:
:
Summary
(
nsString
&
aSummary
)
{
if
(
Caption
(
)
)
{
mAcc
-
>
Description
(
aSummary
)
;
}
else
{
mAcc
-
>
Name
(
aSummary
)
;
}
}
Accessible
*
CachedTableAccessible
:
:
CellAt
(
uint32_t
aRowIdx
uint32_t
aColIdx
)
{
int32_t
cellIdx
=
CellIndexAt
(
aRowIdx
aColIdx
)
;
if
(
cellIdx
=
=
-
1
)
{
return
nullptr
;
}
return
mCells
[
cellIdx
]
.
Acc
(
mAcc
)
;
}
CachedTableCellAccessible
*
CachedTableCellAccessible
:
:
GetFrom
(
Accessible
*
aAcc
)
{
MOZ_ASSERT
(
aAcc
-
>
IsTableCell
(
)
)
;
for
(
Accessible
*
parent
=
aAcc
;
parent
;
parent
=
parent
-
>
Parent
(
)
)
{
if
(
auto
*
table
=
static_cast
<
CachedTableAccessible
*
>
(
parent
-
>
AsTableBase
(
)
)
)
{
if
(
auto
cellIdx
=
table
-
>
mAccToCellIdx
.
Lookup
(
aAcc
)
)
{
return
&
table
-
>
mCells
[
*
cellIdx
]
;
}
}
}
return
nullptr
;
}
Accessible
*
CachedTableCellAccessible
:
:
Acc
(
Accessible
*
aTableAcc
)
const
{
Accessible
*
acc
=
nsAccUtils
:
:
GetAccessibleByID
(
nsAccUtils
:
:
DocumentFor
(
aTableAcc
)
mAccID
)
;
MOZ_DIAGNOSTIC_ASSERT
(
acc
=
=
mAcc
"
Cell
'
s
cached
mAcc
is
dead
!
"
)
;
return
acc
;
}
TableAccessibleBase
*
CachedTableCellAccessible
:
:
Table
(
)
const
{
for
(
const
Accessible
*
acc
=
mAcc
;
acc
;
acc
=
acc
-
>
Parent
(
)
)
{
if
(
TableAccessibleBase
*
table
=
const_cast
<
Accessible
*
>
(
acc
)
-
>
AsTableBase
(
)
)
{
return
table
;
}
}
return
nullptr
;
}
uint32_t
CachedTableCellAccessible
:
:
ColExtent
(
)
const
{
if
(
RemoteAccessible
*
remoteAcc
=
mAcc
-
>
AsRemote
(
)
)
{
if
(
remoteAcc
-
>
mCachedFields
)
{
if
(
auto
colSpan
=
remoteAcc
-
>
mCachedFields
-
>
GetAttribute
<
int32_t
>
(
nsGkAtoms
:
:
colspan
)
)
{
return
*
colSpan
;
}
}
}
else
if
(
LocalAccessible
*
localAcc
=
mAcc
-
>
AsLocal
(
)
)
{
TableCellAccessible
*
cell
=
localAcc
-
>
AsTableCell
(
)
;
MOZ_ASSERT
(
cell
)
;
return
cell
-
>
ColExtent
(
)
;
}
return
1
;
}
uint32_t
CachedTableCellAccessible
:
:
RowExtent
(
)
const
{
if
(
RemoteAccessible
*
remoteAcc
=
mAcc
-
>
AsRemote
(
)
)
{
if
(
remoteAcc
-
>
mCachedFields
)
{
if
(
auto
rowSpan
=
remoteAcc
-
>
mCachedFields
-
>
GetAttribute
<
int32_t
>
(
nsGkAtoms
:
:
rowspan
)
)
{
return
*
rowSpan
;
}
}
}
else
if
(
LocalAccessible
*
localAcc
=
mAcc
-
>
AsLocal
(
)
)
{
TableCellAccessible
*
cell
=
localAcc
-
>
AsTableCell
(
)
;
MOZ_ASSERT
(
cell
)
;
return
cell
-
>
RowExtent
(
)
;
}
return
1
;
}
UniquePtr
<
AccIterable
>
CachedTableCellAccessible
:
:
GetExplicitHeadersIterator
(
)
{
if
(
RemoteAccessible
*
remoteAcc
=
mAcc
-
>
AsRemote
(
)
)
{
if
(
remoteAcc
-
>
mCachedFields
)
{
if
(
auto
headers
=
remoteAcc
-
>
mCachedFields
-
>
GetAttribute
<
nsTArray
<
uint64_t
>
>
(
nsGkAtoms
:
:
headers
)
)
{
return
MakeUnique
<
RemoteExplicitHeadersIterator
>
(
*
headers
remoteAcc
-
>
Document
(
)
)
;
}
}
}
else
if
(
LocalAccessible
*
localAcc
=
mAcc
-
>
AsLocal
(
)
)
{
return
MakeUnique
<
IDRefsIterator
>
(
localAcc
-
>
Document
(
)
localAcc
-
>
GetContent
(
)
nsGkAtoms
:
:
headers
)
;
}
return
nullptr
;
}
void
CachedTableCellAccessible
:
:
ColHeaderCells
(
nsTArray
<
Accessible
*
>
*
aCells
)
{
auto
*
table
=
static_cast
<
CachedTableAccessible
*
>
(
Table
(
)
)
;
if
(
!
table
)
{
return
;
}
if
(
auto
iter
=
GetExplicitHeadersIterator
(
)
)
{
while
(
Accessible
*
header
=
iter
-
>
Next
(
)
)
{
role
headerRole
=
header
-
>
Role
(
)
;
if
(
headerRole
=
=
roles
:
:
COLUMNHEADER
)
{
aCells
-
>
AppendElement
(
header
)
;
}
else
if
(
headerRole
!
=
roles
:
:
ROWHEADER
)
{
if
(
auto
cellIdx
=
table
-
>
mAccToCellIdx
.
Lookup
(
header
)
)
{
CachedTableCellAccessible
&
cell
=
table
-
>
mCells
[
*
cellIdx
]
;
if
(
cell
.
ColIdx
(
)
=
=
ColIdx
(
)
)
{
aCells
-
>
AppendElement
(
header
)
;
}
}
}
}
if
(
!
aCells
-
>
IsEmpty
(
)
)
{
return
;
}
}
Accessible
*
doc
=
nsAccUtils
:
:
DocumentFor
(
table
-
>
AsAccessible
(
)
)
;
CachedTableCellAccessible
*
cell
=
this
;
for
(
;
;
)
{
if
(
cell
-
>
mPrevColHeaderCellIdx
=
=
kNoCellIdx
)
{
break
;
}
cell
=
&
table
-
>
mCells
[
cell
-
>
mPrevColHeaderCellIdx
]
;
Accessible
*
cellAcc
=
nsAccUtils
:
:
GetAccessibleByID
(
doc
cell
-
>
mAccID
)
;
aCells
-
>
AppendElement
(
cellAcc
)
;
}
}
void
CachedTableCellAccessible
:
:
RowHeaderCells
(
nsTArray
<
Accessible
*
>
*
aCells
)
{
auto
*
table
=
static_cast
<
CachedTableAccessible
*
>
(
Table
(
)
)
;
if
(
!
table
)
{
return
;
}
if
(
auto
iter
=
GetExplicitHeadersIterator
(
)
)
{
while
(
Accessible
*
header
=
iter
-
>
Next
(
)
)
{
role
headerRole
=
header
-
>
Role
(
)
;
if
(
headerRole
=
=
roles
:
:
ROWHEADER
)
{
aCells
-
>
AppendElement
(
header
)
;
}
else
if
(
headerRole
!
=
roles
:
:
COLUMNHEADER
)
{
if
(
auto
cellIdx
=
table
-
>
mAccToCellIdx
.
Lookup
(
header
)
)
{
CachedTableCellAccessible
&
cell
=
table
-
>
mCells
[
*
cellIdx
]
;
if
(
cell
.
RowIdx
(
)
=
=
RowIdx
(
)
)
{
aCells
-
>
AppendElement
(
header
)
;
}
}
}
}
if
(
!
aCells
-
>
IsEmpty
(
)
)
{
return
;
}
}
uint32_t
row
=
RowIdx
(
)
;
uint32_t
thisCol
=
ColIdx
(
)
;
for
(
uint32_t
col
=
thisCol
-
1
;
col
<
thisCol
;
-
-
col
)
{
Accessible
*
cellAcc
=
table
-
>
CellAt
(
row
col
)
;
if
(
!
cellAcc
)
{
continue
;
}
TableCellAccessibleBase
*
cell
=
cellAcc
-
>
AsTableCellBase
(
)
;
MOZ_ASSERT
(
cell
)
;
col
=
cell
-
>
ColIdx
(
)
;
if
(
cellAcc
-
>
Role
(
)
!
=
roles
:
:
ROWHEADER
)
{
continue
;
}
aCells
-
>
AppendElement
(
cellAcc
)
;
}
}
bool
CachedTableCellAccessible
:
:
Selected
(
)
{
return
mAcc
-
>
State
(
)
&
states
:
:
SELECTED
;
}
}
