#
include
"
NotificationController
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
DocAccessibleChild
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
TextLeafAccessible
.
h
"
#
include
"
TextUpdater
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
ipc
/
ProcessChild
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
using
namespace
mozilla
:
:
dom
;
NotificationController
:
:
NotificationController
(
DocAccessible
*
aDocument
PresShell
*
aPresShell
)
:
EventQueue
(
aDocument
)
mObservingState
(
eNotObservingRefresh
)
mPresShell
(
aPresShell
)
mEventGeneration
(
0
)
{
ScheduleProcessing
(
)
;
}
NotificationController
:
:
~
NotificationController
(
)
{
NS_ASSERTION
(
!
mDocument
"
Controller
wasn
'
t
shutdown
properly
!
"
)
;
if
(
mDocument
)
Shutdown
(
)
;
}
NS_IMPL_CYCLE_COLLECTING_NATIVE_ADDREF
(
NotificationController
)
NS_IMPL_CYCLE_COLLECTING_NATIVE_RELEASE
(
NotificationController
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
NotificationController
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
NotificationController
)
if
(
tmp
-
>
mDocument
)
tmp
-
>
Shutdown
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
NotificationController
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mHangingChildDocuments
)
for
(
const
auto
&
entry
:
tmp
-
>
mContentInsertions
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mContentInsertions
key
"
)
;
cb
.
NoteXPCOMChild
(
entry
.
GetKey
(
)
)
;
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
list
=
entry
.
GetData
(
)
.
get
(
)
;
for
(
uint32_t
i
=
0
;
i
<
list
-
>
Length
(
)
;
i
+
+
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mContentInsertions
value
item
"
)
;
cb
.
NoteXPCOMChild
(
list
-
>
ElementAt
(
i
)
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFocusEvent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEvents
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRelocations
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
void
NotificationController
:
:
Shutdown
(
)
{
if
(
mObservingState
!
=
eNotObservingRefresh
&
&
mPresShell
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Display
)
)
{
mObservingState
=
eNotObservingRefresh
;
}
int32_t
childDocCount
=
mHangingChildDocuments
.
Length
(
)
;
for
(
int32_t
idx
=
childDocCount
-
1
;
idx
>
=
0
;
idx
-
-
)
{
if
(
!
mHangingChildDocuments
[
idx
]
-
>
IsDefunct
(
)
)
{
mHangingChildDocuments
[
idx
]
-
>
Shutdown
(
)
;
}
}
mHangingChildDocuments
.
Clear
(
)
;
mDocument
=
nullptr
;
mPresShell
=
nullptr
;
mTextHash
.
Clear
(
)
;
mContentInsertions
.
Clear
(
)
;
mNotifications
.
Clear
(
)
;
mFocusEvent
=
nullptr
;
mEvents
.
Clear
(
)
;
mRelocations
.
Clear
(
)
;
}
void
NotificationController
:
:
CoalesceHideEvent
(
AccHideEvent
*
aHideEvent
)
{
LocalAccessible
*
parent
=
aHideEvent
-
>
LocalParent
(
)
;
while
(
parent
)
{
if
(
parent
-
>
IsDoc
(
)
)
{
break
;
}
if
(
parent
-
>
HideEventTarget
(
)
)
{
DropMutationEvent
(
aHideEvent
)
;
break
;
}
if
(
parent
-
>
ShowEventTarget
(
)
)
{
AccShowEvent
*
showEvent
=
downcast_accEvent
(
mMutationMap
.
GetEvent
(
parent
EventMap
:
:
ShowEvent
)
)
;
if
(
showEvent
-
>
EventGeneration
(
)
<
aHideEvent
-
>
EventGeneration
(
)
)
{
DropMutationEvent
(
aHideEvent
)
;
break
;
}
}
parent
=
parent
-
>
LocalParent
(
)
;
}
}
bool
NotificationController
:
:
QueueMutationEvent
(
AccTreeMutationEvent
*
aEvent
)
{
if
(
aEvent
-
>
GetEventType
(
)
=
=
nsIAccessibleEvent
:
:
EVENT_HIDE
)
{
if
(
aEvent
-
>
GetAccessible
(
)
-
>
ShowEventTarget
(
)
)
{
AccTreeMutationEvent
*
showEvent
=
mMutationMap
.
GetEvent
(
aEvent
-
>
GetAccessible
(
)
EventMap
:
:
ShowEvent
)
;
DropMutationEvent
(
showEvent
)
;
return
false
;
}
if
(
aEvent
-
>
GetAccessible
(
)
-
>
HideEventTarget
(
)
)
{
return
false
;
}
}
AccMutationEvent
*
mutEvent
=
downcast_accEvent
(
aEvent
)
;
mEventGeneration
+
+
;
mutEvent
-
>
SetEventGeneration
(
mEventGeneration
)
;
if
(
!
mFirstMutationEvent
)
{
mFirstMutationEvent
=
aEvent
;
ScheduleProcessing
(
)
;
}
if
(
mLastMutationEvent
)
{
NS_ASSERTION
(
!
mLastMutationEvent
-
>
NextEvent
(
)
"
why
isn
'
t
the
last
event
the
end
?
"
)
;
mLastMutationEvent
-
>
SetNextEvent
(
aEvent
)
;
}
aEvent
-
>
SetPrevEvent
(
mLastMutationEvent
)
;
mLastMutationEvent
=
aEvent
;
mMutationMap
.
PutEvent
(
aEvent
)
;
if
(
aEvent
-
>
GetEventType
(
)
=
=
nsIAccessibleEvent
:
:
EVENT_HIDE
)
{
CoalesceHideEvent
(
downcast_accEvent
(
aEvent
)
)
;
if
(
mLastMutationEvent
!
=
aEvent
)
{
return
false
;
}
}
LocalAccessible
*
container
=
aEvent
-
>
GetAccessible
(
)
-
>
LocalParent
(
)
;
RefPtr
<
AccReorderEvent
>
reorder
;
if
(
!
container
-
>
ReorderEventTarget
(
)
)
{
reorder
=
new
AccReorderEvent
(
container
)
;
container
-
>
SetReorderEventTarget
(
true
)
;
mMutationMap
.
PutEvent
(
reorder
)
;
if
(
PushNameOrDescriptionChange
(
aEvent
)
)
{
ScheduleProcessing
(
)
;
}
}
else
{
AccReorderEvent
*
event
=
downcast_accEvent
(
mMutationMap
.
GetEvent
(
container
EventMap
:
:
ReorderEvent
)
)
;
reorder
=
event
;
if
(
mFirstMutationEvent
=
=
event
)
{
mFirstMutationEvent
=
event
-
>
NextEvent
(
)
;
}
else
{
event
-
>
PrevEvent
(
)
-
>
SetNextEvent
(
event
-
>
NextEvent
(
)
)
;
}
event
-
>
NextEvent
(
)
-
>
SetPrevEvent
(
event
-
>
PrevEvent
(
)
)
;
event
-
>
SetNextEvent
(
nullptr
)
;
}
reorder
-
>
SetEventGeneration
(
mEventGeneration
)
;
reorder
-
>
SetPrevEvent
(
mLastMutationEvent
)
;
mLastMutationEvent
-
>
SetNextEvent
(
reorder
)
;
mLastMutationEvent
=
reorder
;
if
(
!
container
-
>
IsHyperText
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
mutEvent
)
;
nsString
text
;
aEvent
-
>
GetAccessible
(
)
-
>
AppendTextTo
(
text
)
;
if
(
text
.
IsEmpty
(
)
)
{
return
true
;
}
LocalAccessible
*
target
=
aEvent
-
>
GetAccessible
(
)
;
int32_t
offset
=
container
-
>
AsHyperText
(
)
-
>
GetChildOffset
(
target
)
;
AccTreeMutationEvent
*
prevEvent
=
aEvent
-
>
PrevEvent
(
)
;
while
(
prevEvent
&
&
prevEvent
-
>
GetEventType
(
)
=
=
nsIAccessibleEvent
:
:
EVENT_REORDER
)
{
prevEvent
=
prevEvent
-
>
PrevEvent
(
)
;
}
if
(
prevEvent
&
&
prevEvent
-
>
GetEventType
(
)
=
=
nsIAccessibleEvent
:
:
EVENT_HIDE
&
&
mutEvent
-
>
IsHide
(
)
)
{
AccHideEvent
*
prevHide
=
downcast_accEvent
(
prevEvent
)
;
AccTextChangeEvent
*
prevTextChange
=
prevHide
-
>
mTextChangeEvent
;
if
(
prevTextChange
&
&
prevHide
-
>
LocalParent
(
)
=
=
mutEvent
-
>
LocalParent
(
)
)
{
if
(
prevHide
-
>
mNextSibling
=
=
target
)
{
target
-
>
AppendTextTo
(
prevTextChange
-
>
mModifiedText
)
;
prevHide
-
>
mTextChangeEvent
.
swap
(
mutEvent
-
>
mTextChangeEvent
)
;
}
else
if
(
prevHide
-
>
mPrevSibling
=
=
target
)
{
nsString
temp
;
target
-
>
AppendTextTo
(
temp
)
;
uint32_t
extraLen
=
temp
.
Length
(
)
;
temp
+
=
prevTextChange
-
>
mModifiedText
;
;
prevTextChange
-
>
mModifiedText
=
temp
;
prevTextChange
-
>
mStart
-
=
extraLen
;
prevHide
-
>
mTextChangeEvent
.
swap
(
mutEvent
-
>
mTextChangeEvent
)
;
}
}
}
else
if
(
prevEvent
&
&
mutEvent
-
>
IsShow
(
)
&
&
prevEvent
-
>
GetEventType
(
)
=
=
nsIAccessibleEvent
:
:
EVENT_SHOW
)
{
AccShowEvent
*
prevShow
=
downcast_accEvent
(
prevEvent
)
;
AccTextChangeEvent
*
prevTextChange
=
prevShow
-
>
mTextChangeEvent
;
if
(
prevTextChange
&
&
prevShow
-
>
LocalParent
(
)
=
=
target
-
>
LocalParent
(
)
)
{
int32_t
index
=
target
-
>
IndexInParent
(
)
;
int32_t
prevIndex
=
prevShow
-
>
GetAccessible
(
)
-
>
IndexInParent
(
)
;
if
(
prevIndex
+
1
=
=
index
)
{
target
-
>
AppendTextTo
(
prevTextChange
-
>
mModifiedText
)
;
prevShow
-
>
mTextChangeEvent
.
swap
(
mutEvent
-
>
mTextChangeEvent
)
;
}
else
if
(
index
+
1
=
=
prevIndex
)
{
nsString
temp
;
target
-
>
AppendTextTo
(
temp
)
;
prevTextChange
-
>
mStart
-
=
temp
.
Length
(
)
;
temp
+
=
prevTextChange
-
>
mModifiedText
;
prevTextChange
-
>
mModifiedText
=
temp
;
prevShow
-
>
mTextChangeEvent
.
swap
(
mutEvent
-
>
mTextChangeEvent
)
;
}
}
}
if
(
!
mutEvent
-
>
mTextChangeEvent
)
{
mutEvent
-
>
mTextChangeEvent
=
new
AccTextChangeEvent
(
container
offset
text
mutEvent
-
>
IsShow
(
)
aEvent
-
>
mIsFromUserInput
?
eFromUserInput
:
eNoUserInput
)
;
}
return
true
;
}
void
NotificationController
:
:
DropMutationEvent
(
AccTreeMutationEvent
*
aEvent
)
{
if
(
aEvent
-
>
GetEventType
(
)
=
=
nsIAccessibleEvent
:
:
EVENT_REORDER
)
{
AccReorderEvent
*
reorderEvent
=
downcast_accEvent
(
aEvent
)
;
MOZ_ASSERT
(
reorderEvent
)
;
reorderEvent
-
>
SetInner
(
)
;
return
;
}
else
if
(
aEvent
-
>
GetEventType
(
)
=
=
nsIAccessibleEvent
:
:
EVENT_SHOW
)
{
aEvent
-
>
GetAccessible
(
)
-
>
SetShowEventTarget
(
false
)
;
}
else
{
aEvent
-
>
GetAccessible
(
)
-
>
SetHideEventTarget
(
false
)
;
AccHideEvent
*
hideEvent
=
downcast_accEvent
(
aEvent
)
;
MOZ_ASSERT
(
hideEvent
)
;
if
(
hideEvent
-
>
NeedsShutdown
(
)
)
{
mDocument
-
>
ShutdownChildrenInSubtree
(
aEvent
-
>
GetAccessible
(
)
)
;
}
}
if
(
mFirstMutationEvent
=
=
aEvent
)
{
mFirstMutationEvent
=
aEvent
-
>
NextEvent
(
)
;
}
else
{
aEvent
-
>
PrevEvent
(
)
-
>
SetNextEvent
(
aEvent
-
>
NextEvent
(
)
)
;
}
if
(
mLastMutationEvent
=
=
aEvent
)
{
mLastMutationEvent
=
aEvent
-
>
PrevEvent
(
)
;
}
else
{
aEvent
-
>
NextEvent
(
)
-
>
SetPrevEvent
(
aEvent
-
>
PrevEvent
(
)
)
;
}
aEvent
-
>
SetPrevEvent
(
nullptr
)
;
aEvent
-
>
SetNextEvent
(
nullptr
)
;
mMutationMap
.
RemoveEvent
(
aEvent
)
;
}
void
NotificationController
:
:
CoalesceMutationEvents
(
)
{
AccTreeMutationEvent
*
event
=
mFirstMutationEvent
;
while
(
event
)
{
AccTreeMutationEvent
*
nextEvent
=
event
-
>
NextEvent
(
)
;
uint32_t
eventType
=
event
-
>
GetEventType
(
)
;
if
(
event
-
>
GetEventType
(
)
=
=
nsIAccessibleEvent
:
:
EVENT_REORDER
)
{
LocalAccessible
*
acc
=
event
-
>
GetAccessible
(
)
;
while
(
acc
)
{
if
(
acc
-
>
IsDoc
(
)
)
{
break
;
}
if
(
acc
-
>
HideEventTarget
(
)
)
{
DropMutationEvent
(
event
)
;
break
;
}
LocalAccessible
*
parent
=
acc
-
>
LocalParent
(
)
;
if
(
parent
&
&
parent
-
>
ReorderEventTarget
(
)
)
{
AccReorderEvent
*
reorder
=
downcast_accEvent
(
mMutationMap
.
GetEvent
(
parent
EventMap
:
:
ReorderEvent
)
)
;
if
(
reorder
&
&
reorder
-
>
EventGeneration
(
)
<
event
-
>
EventGeneration
(
)
)
{
reorder
-
>
SetEventGeneration
(
event
-
>
EventGeneration
(
)
)
;
if
(
event
!
=
reorder
-
>
NextEvent
(
)
)
{
if
(
reorder
-
>
PrevEvent
(
)
)
{
reorder
-
>
PrevEvent
(
)
-
>
SetNextEvent
(
reorder
-
>
NextEvent
(
)
)
;
}
else
{
mFirstMutationEvent
=
reorder
-
>
NextEvent
(
)
;
}
reorder
-
>
NextEvent
(
)
-
>
SetPrevEvent
(
reorder
-
>
PrevEvent
(
)
)
;
event
-
>
PrevEvent
(
)
-
>
SetNextEvent
(
reorder
)
;
reorder
-
>
SetPrevEvent
(
event
-
>
PrevEvent
(
)
)
;
event
-
>
SetPrevEvent
(
reorder
)
;
reorder
-
>
SetNextEvent
(
event
)
;
}
}
DropMutationEvent
(
event
)
;
break
;
}
acc
=
parent
;
}
}
else
if
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SHOW
)
{
LocalAccessible
*
parent
=
event
-
>
GetAccessible
(
)
-
>
LocalParent
(
)
;
while
(
parent
)
{
if
(
parent
-
>
IsDoc
(
)
)
{
break
;
}
if
(
parent
-
>
ShowEventTarget
(
)
|
|
parent
-
>
HideEventTarget
(
)
)
{
DropMutationEvent
(
event
)
;
break
;
}
parent
=
parent
-
>
LocalParent
(
)
;
}
}
else
if
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_HIDE
)
{
MOZ_ASSERT
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_HIDE
"
mutation
event
list
has
an
invalid
event
"
)
;
AccHideEvent
*
hideEvent
=
downcast_accEvent
(
event
)
;
CoalesceHideEvent
(
hideEvent
)
;
}
event
=
nextEvent
;
}
}
void
NotificationController
:
:
ScheduleChildDocBinding
(
DocAccessible
*
aDocument
)
{
mHangingChildDocuments
.
AppendElement
(
aDocument
)
;
ScheduleProcessing
(
)
;
}
void
NotificationController
:
:
ScheduleContentInsertion
(
LocalAccessible
*
aContainer
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
&
aInsertions
)
{
if
(
!
aInsertions
.
IsEmpty
(
)
)
{
mContentInsertions
.
GetOrInsertNew
(
aContainer
)
-
>
AppendElements
(
aInsertions
)
;
ScheduleProcessing
(
)
;
}
}
void
NotificationController
:
:
ScheduleProcessing
(
)
{
if
(
mObservingState
=
=
eNotObservingRefresh
)
{
if
(
mPresShell
-
>
AddRefreshObserver
(
this
FlushType
:
:
Display
"
Accessibility
notifications
"
)
)
{
mObservingState
=
eRefreshObserving
;
}
}
}
bool
NotificationController
:
:
IsUpdatePending
(
)
{
return
mPresShell
-
>
IsLayoutFlushObserver
(
)
|
|
mObservingState
=
=
eRefreshProcessingForUpdate
|
|
WaitingForParent
(
)
|
|
mContentInsertions
.
Count
(
)
!
=
0
|
|
mNotifications
.
Length
(
)
!
=
0
|
|
mTextHash
.
Count
(
)
!
=
0
|
|
!
mDocument
-
>
HasLoadState
(
DocAccessible
:
:
eTreeConstructed
)
;
}
bool
NotificationController
:
:
WaitingForParent
(
)
{
DocAccessible
*
parentdoc
=
mDocument
-
>
ParentDocument
(
)
;
if
(
!
parentdoc
)
{
return
false
;
}
NotificationController
*
parent
=
parentdoc
-
>
mNotificationController
;
if
(
!
parent
|
|
parent
=
=
this
)
{
return
false
;
}
return
parent
-
>
mContentInsertions
.
Count
(
)
!
=
0
|
|
parent
-
>
mNotifications
.
Length
(
)
!
=
0
;
}
void
NotificationController
:
:
ProcessMutationEvents
(
)
{
for
(
AccTreeMutationEvent
*
event
=
mFirstMutationEvent
;
event
;
event
=
event
-
>
NextEvent
(
)
)
{
LocalAccessible
*
acc
=
event
-
>
GetAccessible
(
)
;
acc
-
>
SetShowEventTarget
(
false
)
;
acc
-
>
SetHideEventTarget
(
false
)
;
acc
-
>
SetReorderEventTarget
(
false
)
;
}
RefPtr
<
AccTreeMutationEvent
>
firstEvent
=
mFirstMutationEvent
;
mFirstMutationEvent
=
mLastMutationEvent
=
nullptr
;
mMutationMap
.
Clear
(
)
;
mEventGeneration
=
0
;
nsTHashMap
<
nsPtrHashKey
<
LocalAccessible
>
nsTArray
<
AccTreeMutationEvent
*
>
>
showEvents
;
for
(
AccTreeMutationEvent
*
event
=
firstEvent
;
event
;
event
=
event
-
>
NextEvent
(
)
)
{
if
(
event
-
>
GetEventType
(
)
!
=
nsIAccessibleEvent
:
:
EVENT_SHOW
)
{
continue
;
}
LocalAccessible
*
parent
=
event
-
>
GetAccessible
(
)
-
>
LocalParent
(
)
;
showEvents
.
LookupOrInsert
(
parent
)
.
AppendElement
(
event
)
;
}
for
(
auto
iter
=
showEvents
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
struct
AccIdxComparator
{
bool
LessThan
(
const
AccTreeMutationEvent
*
a
const
AccTreeMutationEvent
*
b
)
const
{
int32_t
aIdx
=
a
-
>
GetAccessible
(
)
-
>
IndexInParent
(
)
;
int32_t
bIdx
=
b
-
>
GetAccessible
(
)
-
>
IndexInParent
(
)
;
MOZ_ASSERT
(
aIdx
>
=
0
&
&
bIdx
>
=
0
&
&
aIdx
!
=
bIdx
)
;
return
aIdx
<
bIdx
;
}
bool
Equals
(
const
AccTreeMutationEvent
*
a
const
AccTreeMutationEvent
*
b
)
const
{
DebugOnly
<
int32_t
>
aIdx
=
a
-
>
GetAccessible
(
)
-
>
IndexInParent
(
)
;
DebugOnly
<
int32_t
>
bIdx
=
b
-
>
GetAccessible
(
)
-
>
IndexInParent
(
)
;
MOZ_ASSERT
(
aIdx
>
=
0
&
&
bIdx
>
=
0
&
&
aIdx
!
=
bIdx
)
;
return
false
;
}
}
;
nsTArray
<
AccTreeMutationEvent
*
>
&
events
=
iter
.
Data
(
)
;
events
.
Sort
(
AccIdxComparator
(
)
)
;
}
for
(
AccTreeMutationEvent
*
event
=
firstEvent
;
event
;
event
=
event
-
>
NextEvent
(
)
)
{
if
(
event
-
>
GetEventType
(
)
!
=
nsIAccessibleEvent
:
:
EVENT_HIDE
)
{
continue
;
}
nsEventShell
:
:
FireEvent
(
event
)
;
if
(
!
mDocument
)
{
return
;
}
AccMutationEvent
*
mutEvent
=
downcast_accEvent
(
event
)
;
if
(
mutEvent
-
>
mTextChangeEvent
)
{
nsEventShell
:
:
FireEvent
(
mutEvent
-
>
mTextChangeEvent
)
;
if
(
!
mDocument
)
{
return
;
}
}
if
(
event
-
>
mAccessible
-
>
ARIARole
(
)
=
=
roles
:
:
MENUPOPUP
)
{
nsEventShell
:
:
FireEvent
(
nsIAccessibleEvent
:
:
EVENT_MENUPOPUP_END
event
-
>
mAccessible
)
;
if
(
!
mDocument
)
{
return
;
}
}
AccHideEvent
*
hideEvent
=
downcast_accEvent
(
event
)
;
if
(
hideEvent
-
>
NeedsShutdown
(
)
)
{
mDocument
-
>
ShutdownChildrenInSubtree
(
event
-
>
mAccessible
)
;
}
}
for
(
auto
iter
=
showEvents
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsTArray
<
AccTreeMutationEvent
*
>
&
events
=
iter
.
Data
(
)
;
for
(
AccTreeMutationEvent
*
event
:
events
)
{
nsEventShell
:
:
FireEvent
(
event
)
;
if
(
!
mDocument
)
{
return
;
}
AccMutationEvent
*
mutEvent
=
downcast_accEvent
(
event
)
;
if
(
mutEvent
-
>
mTextChangeEvent
)
{
nsEventShell
:
:
FireEvent
(
mutEvent
-
>
mTextChangeEvent
)
;
if
(
!
mDocument
)
{
return
;
}
}
}
}
for
(
const
uint32_t
reorderType
:
{
nsIAccessibleEvent
:
:
EVENT_INNER_REORDER
nsIAccessibleEvent
:
:
EVENT_REORDER
}
)
{
for
(
AccTreeMutationEvent
*
event
=
firstEvent
;
event
;
event
=
event
-
>
NextEvent
(
)
)
{
if
(
event
-
>
GetEventType
(
)
!
=
reorderType
)
{
continue
;
}
if
(
event
-
>
GetAccessible
(
)
-
>
IsDefunct
(
)
)
{
MOZ_ASSERT
(
reorderType
=
=
nsIAccessibleEvent
:
:
EVENT_INNER_REORDER
"
An
'
outer
'
reorder
target
should
not
be
defunct
"
)
;
continue
;
}
nsEventShell
:
:
FireEvent
(
event
)
;
if
(
!
mDocument
)
{
return
;
}
LocalAccessible
*
target
=
event
-
>
GetAccessible
(
)
;
target
-
>
Document
(
)
-
>
MaybeNotifyOfValueChange
(
target
)
;
if
(
!
mDocument
)
{
return
;
}
}
}
RefPtr
<
AccTreeMutationEvent
>
event
=
firstEvent
;
while
(
event
)
{
RefPtr
<
AccTreeMutationEvent
>
next
=
event
-
>
NextEvent
(
)
;
event
-
>
SetNextEvent
(
nullptr
)
;
event
-
>
SetPrevEvent
(
nullptr
)
;
event
=
next
;
}
}
void
NotificationController
:
:
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
{
AUTO_PROFILER_MARKER_TEXT
(
"
NotificationController
:
:
WillRefresh
"
A11Y
{
}
"
"
_ns
)
;
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
A11Y_TREE_UPDATE_TIMING_MS
>
timer
;
AUTO_PROFILER_LABEL
(
"
NotificationController
:
:
WillRefresh
"
A11Y
)
;
NS_ASSERTION
(
mDocument
"
The
document
was
shut
down
while
refresh
observer
is
attached
!
"
)
;
if
(
!
mDocument
|
|
ipc
:
:
ProcessChild
:
:
ExpectingShutdown
(
)
)
{
return
;
}
nsPresContext
*
pc
=
mPresShell
-
>
GetPresContext
(
)
;
if
(
mObservingState
=
=
eRefreshProcessing
|
|
mObservingState
=
=
eRefreshProcessingForUpdate
|
|
mPresShell
-
>
IsReflowInterrupted
(
)
|
|
!
pc
|
|
!
pc
-
>
GetRootPresContext
(
)
)
{
return
;
}
if
(
WaitingForParent
(
)
)
{
mDocument
-
>
ParentDocument
(
)
-
>
mNotificationController
-
>
WillRefresh
(
aTime
)
;
if
(
!
mDocument
|
|
ipc
:
:
ProcessChild
:
:
ExpectingShutdown
(
)
)
{
return
;
}
}
mObservingState
=
eRefreshProcessingForUpdate
;
if
(
!
mDocument
-
>
HasLoadState
(
DocAccessible
:
:
eTreeConstructed
)
)
{
if
(
!
mDocument
-
>
IsBoundToParent
(
)
|
|
(
!
mPresShell
-
>
DidInitialize
(
)
&
&
!
mDocument
-
>
DocumentNode
(
)
-
>
IsInitialDocument
(
)
)
)
{
mObservingState
=
eRefreshObserving
;
return
;
}
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
initial
tree
created
"
)
;
logging
:
:
Address
(
"
document
"
mDocument
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
mDocument
-
>
DoInitialUpdate
(
)
;
if
(
ipc
:
:
ProcessChild
:
:
ExpectingShutdown
(
)
)
{
return
;
}
NS_ASSERTION
(
mContentInsertions
.
Count
(
)
=
=
0
"
Pending
content
insertions
while
initial
accessible
tree
"
"
isn
'
t
created
!
"
)
;
}
mDocument
-
>
ProcessPendingUpdates
(
)
;
for
(
nsIContent
*
textNode
:
mTextHash
)
{
LocalAccessible
*
textAcc
=
mDocument
-
>
GetAccessible
(
textNode
)
;
nsINode
*
containerNode
=
textNode
-
>
GetFlattenedTreeParentNode
(
)
;
if
(
!
containerNode
|
|
textNode
-
>
OwnerDoc
(
)
!
=
mDocument
-
>
DocumentNode
(
)
)
{
MOZ_ASSERT
(
!
textAcc
"
Text
node
was
removed
but
accessible
is
kept
alive
!
"
)
;
continue
;
}
nsIFrame
*
textFrame
=
textNode
-
>
GetPrimaryFrame
(
)
;
if
(
!
textFrame
)
{
MOZ_ASSERT
(
!
textAcc
"
Text
node
isn
'
t
rendered
but
accessible
is
kept
alive
!
"
)
;
continue
;
}
#
ifdef
A11Y_LOG
nsIContent
*
containerElm
=
containerNode
-
>
IsElement
(
)
?
containerNode
-
>
AsElement
(
)
:
nullptr
;
#
endif
nsIFrame
:
:
RenderedText
text
=
textFrame
-
>
GetRenderedText
(
0
UINT32_MAX
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInContentText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
if
(
textAcc
)
{
if
(
text
.
mString
.
IsEmpty
(
)
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
|
logging
:
:
eText
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
text
node
lost
its
content
;
doc
:
%
p
"
mDocument
)
;
logging
:
:
Node
(
"
container
"
containerElm
)
;
logging
:
:
Node
(
"
content
"
textNode
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
mDocument
-
>
ContentRemoved
(
textAcc
)
;
continue
;
}
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eText
)
)
{
logging
:
:
MsgBegin
(
"
TEXT
"
"
text
may
be
changed
;
doc
:
%
p
"
mDocument
)
;
logging
:
:
Node
(
"
container
"
containerElm
)
;
logging
:
:
Node
(
"
content
"
textNode
)
;
logging
:
:
MsgEntry
(
"
old
text
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
textAcc
-
>
AsTextLeaf
(
)
-
>
Text
(
)
)
.
get
(
)
)
;
logging
:
:
MsgEntry
(
"
new
text
:
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
text
.
mString
)
.
get
(
)
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
TextUpdater
:
:
Run
(
mDocument
textAcc
-
>
AsTextLeaf
(
)
text
.
mString
)
;
continue
;
}
if
(
!
text
.
mString
.
IsEmpty
(
)
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
|
logging
:
:
eText
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
text
node
gains
new
content
;
doc
:
%
p
"
mDocument
)
;
logging
:
:
Node
(
"
container
"
containerElm
)
;
logging
:
:
Node
(
"
content
"
textNode
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
MOZ_ASSERT
(
mDocument
-
>
AccessibleOrTrueContainer
(
containerNode
)
"
Text
node
having
rendered
text
hasn
'
t
accessible
document
!
"
)
;
LocalAccessible
*
container
=
mDocument
-
>
AccessibleOrTrueContainer
(
containerNode
true
)
;
if
(
container
)
{
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
*
list
=
mContentInsertions
.
GetOrInsertNew
(
container
)
;
list
-
>
AppendElement
(
textNode
)
;
}
}
}
mTextHash
.
Clear
(
)
;
const
auto
contentInsertions
=
std
:
:
move
(
mContentInsertions
)
;
for
(
const
auto
&
entry
:
contentInsertions
)
{
mDocument
-
>
ProcessContentInserted
(
entry
.
GetKey
(
)
entry
.
GetData
(
)
.
get
(
)
)
;
if
(
!
mDocument
)
{
return
;
}
}
uint32_t
hangingDocCnt
=
mHangingChildDocuments
.
Length
(
)
;
nsTArray
<
RefPtr
<
DocAccessible
>
>
newChildDocs
;
for
(
uint32_t
idx
=
0
;
idx
<
hangingDocCnt
;
idx
+
+
)
{
DocAccessible
*
childDoc
=
mHangingChildDocuments
[
idx
]
;
if
(
childDoc
-
>
IsDefunct
(
)
)
continue
;
if
(
IPCAccessibilityActive
(
)
&
&
!
mDocument
-
>
IPCDoc
(
)
)
{
childDoc
-
>
Shutdown
(
)
;
continue
;
}
nsIContent
*
ownerContent
=
childDoc
-
>
DocumentNode
(
)
-
>
GetEmbedderElement
(
)
;
if
(
ownerContent
)
{
LocalAccessible
*
outerDocAcc
=
mDocument
-
>
GetAccessible
(
ownerContent
)
;
if
(
outerDocAcc
&
&
outerDocAcc
-
>
AppendChild
(
childDoc
)
)
{
if
(
mDocument
-
>
AppendChildDocument
(
childDoc
)
)
{
newChildDocs
.
AppendElement
(
std
:
:
move
(
mHangingChildDocuments
[
idx
]
)
)
;
continue
;
}
outerDocAcc
-
>
RemoveChild
(
childDoc
)
;
}
childDoc
-
>
Shutdown
(
)
;
}
}
mHangingChildDocuments
.
Clear
(
)
;
MOZ_ASSERT
(
mDocument
"
Illicit
document
shutdown
"
)
;
if
(
!
mDocument
)
{
return
;
}
if
(
mDocument
-
>
HasLoadState
(
DocAccessible
:
:
eReady
)
&
&
!
mDocument
-
>
HasLoadState
(
DocAccessible
:
:
eCompletelyLoaded
)
&
&
hangingDocCnt
=
=
0
)
{
uint32_t
childDocCnt
=
mDocument
-
>
ChildDocumentCount
(
)
childDocIdx
=
0
;
for
(
;
childDocIdx
<
childDocCnt
;
childDocIdx
+
+
)
{
DocAccessible
*
childDoc
=
mDocument
-
>
GetChildDocumentAt
(
childDocIdx
)
;
if
(
!
childDoc
-
>
HasLoadState
(
DocAccessible
:
:
eCompletelyLoaded
)
)
break
;
}
if
(
childDocIdx
=
=
childDocCnt
)
{
mDocument
-
>
ProcessLoad
(
)
;
if
(
!
mDocument
)
return
;
}
}
mDocument
-
>
ProcessInvalidationList
(
)
;
for
(
uint32_t
idx
=
0
;
idx
<
mRelocations
.
Length
(
)
;
idx
+
+
)
{
if
(
mRelocations
[
idx
]
-
>
IsInDocument
(
)
&
&
mRelocations
[
idx
]
-
>
HasOwnContent
(
)
)
{
mDocument
-
>
DoARIAOwnsRelocation
(
mRelocations
[
idx
]
)
;
}
}
mRelocations
.
Clear
(
)
;
const
nsTArray
<
RefPtr
<
Notification
>
>
notifications
=
std
:
:
move
(
mNotifications
)
;
uint32_t
notificationCount
=
notifications
.
Length
(
)
;
for
(
uint32_t
idx
=
0
;
idx
<
notificationCount
;
idx
+
+
)
{
notifications
[
idx
]
-
>
Process
(
)
;
if
(
!
mDocument
)
return
;
}
if
(
ipc
:
:
ProcessChild
:
:
ExpectingShutdown
(
)
)
{
return
;
}
mObservingState
=
eRefreshProcessing
;
mDocument
-
>
SendAccessiblesWillMove
(
)
;
if
(
IPCAccessibilityActive
(
)
&
&
mDocument
)
{
mDocument
-
>
ProcessQueuedCacheUpdates
(
)
;
}
CoalesceMutationEvents
(
)
;
ProcessMutationEvents
(
)
;
if
(
IPCAccessibilityActive
(
)
&
&
mDocument
)
{
mDocument
-
>
ProcessQueuedCacheUpdates
(
)
;
}
if
(
mDocument
)
{
mDocument
-
>
ClearMovedAccessibles
(
)
;
}
if
(
ipc
:
:
ProcessChild
:
:
ExpectingShutdown
(
)
)
{
return
;
}
ProcessEventQueue
(
)
;
if
(
IPCAccessibilityActive
(
)
)
{
size_t
newDocCount
=
newChildDocs
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
newDocCount
;
i
+
+
)
{
DocAccessible
*
childDoc
=
newChildDocs
[
i
]
;
if
(
childDoc
-
>
IsDefunct
(
)
)
{
continue
;
}
LocalAccessible
*
parent
=
childDoc
-
>
LocalParent
(
)
;
DocAccessibleChild
*
parentIPCDoc
=
mDocument
-
>
IPCDoc
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
parentIPCDoc
)
;
uint64_t
id
=
reinterpret_cast
<
uintptr_t
>
(
parent
-
>
UniqueID
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
id
)
;
DocAccessibleChild
*
ipcDoc
=
childDoc
-
>
IPCDoc
(
)
;
if
(
ipcDoc
)
{
parentIPCDoc
-
>
SendBindChildDoc
(
WrapNotNull
(
ipcDoc
)
id
)
;
continue
;
}
ipcDoc
=
new
DocAccessibleChild
(
childDoc
parentIPCDoc
-
>
Manager
(
)
)
;
childDoc
-
>
SetIPCDoc
(
ipcDoc
)
;
nsCOMPtr
<
nsIBrowserChild
>
browserChild
=
do_GetInterface
(
mDocument
-
>
DocumentNode
(
)
-
>
GetDocShell
(
)
)
;
if
(
browserChild
)
{
static_cast
<
BrowserChild
*
>
(
browserChild
.
get
(
)
)
-
>
SendPDocAccessibleConstructor
(
ipcDoc
parentIPCDoc
id
childDoc
-
>
DocumentNode
(
)
-
>
GetBrowsingContext
(
)
)
;
#
ifndef
XP_WIN
ipcDoc
-
>
SendPDocAccessiblePlatformExtConstructor
(
)
;
#
endif
}
}
}
mObservingState
=
eRefreshObserving
;
if
(
!
mDocument
)
return
;
if
(
mContentInsertions
.
Count
(
)
=
=
0
&
&
mNotifications
.
IsEmpty
(
)
&
&
!
mFocusEvent
&
&
mEvents
.
IsEmpty
(
)
&
&
mTextHash
.
Count
(
)
=
=
0
&
&
mHangingChildDocuments
.
IsEmpty
(
)
&
&
mDocument
-
>
HasLoadState
(
DocAccessible
:
:
eCompletelyLoaded
)
&
&
mPresShell
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Display
)
)
{
mObservingState
=
eNotObservingRefresh
;
}
}
void
NotificationController
:
:
EventMap
:
:
PutEvent
(
AccTreeMutationEvent
*
aEvent
)
{
EventType
type
=
GetEventType
(
aEvent
)
;
uint64_t
addr
=
reinterpret_cast
<
uintptr_t
>
(
aEvent
-
>
GetAccessible
(
)
)
;
MOZ_ASSERT
(
(
addr
&
0x3
)
=
=
0
"
accessible
is
not
4
byte
aligned
"
)
;
addr
|
=
type
;
mTable
.
InsertOrUpdate
(
addr
RefPtr
{
aEvent
}
)
;
}
AccTreeMutationEvent
*
NotificationController
:
:
EventMap
:
:
GetEvent
(
LocalAccessible
*
aTarget
EventType
aType
)
{
uint64_t
addr
=
reinterpret_cast
<
uintptr_t
>
(
aTarget
)
;
MOZ_ASSERT
(
(
addr
&
0x3
)
=
=
0
"
target
is
not
4
byte
aligned
"
)
;
addr
|
=
aType
;
return
mTable
.
GetWeak
(
addr
)
;
}
void
NotificationController
:
:
EventMap
:
:
RemoveEvent
(
AccTreeMutationEvent
*
aEvent
)
{
EventType
type
=
GetEventType
(
aEvent
)
;
uint64_t
addr
=
reinterpret_cast
<
uintptr_t
>
(
aEvent
-
>
GetAccessible
(
)
)
;
MOZ_ASSERT
(
(
addr
&
0x3
)
=
=
0
"
accessible
is
not
4
byte
aligned
"
)
;
addr
|
=
type
;
MOZ_ASSERT
(
mTable
.
GetWeak
(
addr
)
=
=
aEvent
"
mTable
has
the
wrong
event
"
)
;
mTable
.
Remove
(
addr
)
;
}
NotificationController
:
:
EventMap
:
:
EventType
NotificationController
:
:
EventMap
:
:
GetEventType
(
AccTreeMutationEvent
*
aEvent
)
{
switch
(
aEvent
-
>
GetEventType
(
)
)
{
case
nsIAccessibleEvent
:
:
EVENT_SHOW
:
return
ShowEvent
;
case
nsIAccessibleEvent
:
:
EVENT_HIDE
:
return
HideEvent
;
case
nsIAccessibleEvent
:
:
EVENT_REORDER
:
case
nsIAccessibleEvent
:
:
EVENT_INNER_REORDER
:
return
ReorderEvent
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
event
has
invalid
type
"
)
;
return
ShowEvent
;
}
}
