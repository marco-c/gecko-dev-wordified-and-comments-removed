#
include
"
nsAccUtils
.
h
"
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
ARIAMap
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
nsCoreUtils
.
h
"
#
include
"
DocAccessible
.
h
"
#
include
"
HyperTextAccessible
.
h
"
#
include
"
nsIAccessibleTypes
.
h
"
#
include
"
Role
.
h
"
#
include
"
States
.
h
"
#
include
"
TextLeafAccessible
.
h
"
#
include
"
nsIDOMXULContainerElement
.
h
"
#
include
"
nsIPersistentProperties2
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
mozilla
/
a11y
/
PDocAccessibleChild
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsAccessibilityService
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
void
nsAccUtils
:
:
GetAccAttr
(
nsIPersistentProperties
*
aAttributes
nsAtom
*
aAttrName
nsAString
&
aAttrValue
)
{
aAttrValue
.
Truncate
(
)
;
aAttributes
-
>
GetStringProperty
(
nsAtomCString
(
aAttrName
)
aAttrValue
)
;
}
void
nsAccUtils
:
:
SetAccAttr
(
nsIPersistentProperties
*
aAttributes
nsAtom
*
aAttrName
const
nsAString
&
aAttrValue
)
{
nsAutoString
oldValue
;
aAttributes
-
>
SetStringProperty
(
nsAtomCString
(
aAttrName
)
aAttrValue
oldValue
)
;
}
void
nsAccUtils
:
:
SetAccAttr
(
nsIPersistentProperties
*
aAttributes
nsAtom
*
aAttrName
nsAtom
*
aAttrValue
)
{
nsAutoString
oldValue
;
aAttributes
-
>
SetStringProperty
(
nsAtomCString
(
aAttrName
)
nsAtomString
(
aAttrValue
)
oldValue
)
;
}
void
nsAccUtils
:
:
SetAccGroupAttrs
(
nsIPersistentProperties
*
aAttributes
int32_t
aLevel
int32_t
aSetSize
int32_t
aPosInSet
)
{
nsAutoString
value
;
if
(
aLevel
)
{
value
.
AppendInt
(
aLevel
)
;
SetAccAttr
(
aAttributes
nsGkAtoms
:
:
level
value
)
;
}
if
(
aSetSize
&
&
aPosInSet
)
{
value
.
Truncate
(
)
;
value
.
AppendInt
(
aPosInSet
)
;
SetAccAttr
(
aAttributes
nsGkAtoms
:
:
posinset
value
)
;
value
.
Truncate
(
)
;
value
.
AppendInt
(
aSetSize
)
;
SetAccAttr
(
aAttributes
nsGkAtoms
:
:
setsize
value
)
;
}
}
int32_t
nsAccUtils
:
:
GetDefaultLevel
(
const
LocalAccessible
*
aAccessible
)
{
roles
:
:
Role
role
=
aAccessible
-
>
Role
(
)
;
if
(
role
=
=
roles
:
:
OUTLINEITEM
)
return
1
;
if
(
role
=
=
roles
:
:
ROW
)
{
LocalAccessible
*
parent
=
aAccessible
-
>
LocalParent
(
)
;
if
(
parent
&
&
parent
-
>
Role
(
)
=
=
roles
:
:
TREE_TABLE
)
return
1
;
}
return
0
;
}
int32_t
nsAccUtils
:
:
GetARIAOrDefaultLevel
(
const
LocalAccessible
*
aAccessible
)
{
int32_t
level
=
0
;
nsCoreUtils
:
:
GetUIntAttr
(
aAccessible
-
>
GetContent
(
)
nsGkAtoms
:
:
aria_level
&
level
)
;
if
(
level
!
=
0
)
return
level
;
return
GetDefaultLevel
(
aAccessible
)
;
}
int32_t
nsAccUtils
:
:
GetLevelForXULContainerItem
(
nsIContent
*
aContent
)
{
nsCOMPtr
<
nsIDOMXULContainerItemElement
>
item
=
aContent
-
>
AsElement
(
)
-
>
AsXULContainerItem
(
)
;
if
(
!
item
)
return
0
;
nsCOMPtr
<
dom
:
:
Element
>
containerElement
;
item
-
>
GetParentContainer
(
getter_AddRefs
(
containerElement
)
)
;
nsCOMPtr
<
nsIDOMXULContainerElement
>
container
=
containerElement
?
containerElement
-
>
AsXULContainer
(
)
:
nullptr
;
if
(
!
container
)
return
0
;
int32_t
level
=
-
1
;
while
(
container
)
{
level
+
+
;
container
-
>
GetParentContainer
(
getter_AddRefs
(
containerElement
)
)
;
container
=
containerElement
?
containerElement
-
>
AsXULContainer
(
)
:
nullptr
;
}
return
level
;
}
void
nsAccUtils
:
:
SetLiveContainerAttributes
(
nsIPersistentProperties
*
aAttributes
nsIContent
*
aStartContent
)
{
nsAutoString
live
relevant
busy
;
dom
:
:
Document
*
doc
=
aStartContent
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
;
}
dom
:
:
Element
*
topEl
=
doc
-
>
GetRootElement
(
)
;
nsIContent
*
ancestor
=
aStartContent
;
while
(
ancestor
)
{
if
(
relevant
.
IsEmpty
(
)
&
&
HasDefinedARIAToken
(
ancestor
nsGkAtoms
:
:
aria_relevant
)
&
&
ancestor
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_relevant
relevant
)
)
{
SetAccAttr
(
aAttributes
nsGkAtoms
:
:
containerRelevant
relevant
)
;
}
if
(
live
.
IsEmpty
(
)
)
{
const
nsRoleMapEntry
*
role
=
nullptr
;
if
(
ancestor
-
>
IsElement
(
)
)
{
role
=
aria
:
:
GetRoleMap
(
ancestor
-
>
AsElement
(
)
)
;
}
if
(
HasDefinedARIAToken
(
ancestor
nsGkAtoms
:
:
aria_live
)
)
{
ancestor
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_live
live
)
;
}
else
if
(
role
)
{
GetLiveAttrValue
(
role
-
>
liveAttRule
live
)
;
}
else
if
(
nsStaticAtom
*
value
=
GetAccService
(
)
-
>
MarkupAttribute
(
ancestor
nsGkAtoms
:
:
live
)
)
{
value
-
>
ToString
(
live
)
;
}
if
(
!
live
.
IsEmpty
(
)
)
{
SetAccAttr
(
aAttributes
nsGkAtoms
:
:
containerLive
live
)
;
if
(
role
)
{
SetAccAttr
(
aAttributes
nsGkAtoms
:
:
containerLiveRole
role
-
>
ARIARoleString
(
)
)
;
}
}
}
if
(
ancestor
-
>
IsElement
(
)
&
&
ancestor
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_atomic
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
SetAccAttr
(
aAttributes
nsGkAtoms
:
:
containerAtomic
u
"
true
"
_ns
)
;
}
if
(
busy
.
IsEmpty
(
)
&
&
HasDefinedARIAToken
(
ancestor
nsGkAtoms
:
:
aria_busy
)
&
&
ancestor
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_busy
busy
)
)
{
SetAccAttr
(
aAttributes
nsGkAtoms
:
:
containerBusy
busy
)
;
}
if
(
ancestor
=
=
topEl
)
{
break
;
}
ancestor
=
ancestor
-
>
GetParent
(
)
;
if
(
!
ancestor
)
{
ancestor
=
topEl
;
}
}
}
bool
nsAccUtils
:
:
HasDefinedARIAToken
(
nsIContent
*
aContent
nsAtom
*
aAtom
)
{
NS_ASSERTION
(
aContent
"
aContent
is
null
in
call
to
HasDefinedARIAToken
!
"
)
;
if
(
!
aContent
-
>
IsElement
(
)
)
return
false
;
dom
:
:
Element
*
element
=
aContent
-
>
AsElement
(
)
;
if
(
!
element
-
>
HasAttr
(
kNameSpaceID_None
aAtom
)
|
|
element
-
>
AttrValueIs
(
kNameSpaceID_None
aAtom
nsGkAtoms
:
:
_empty
eCaseMatters
)
|
|
element
-
>
AttrValueIs
(
kNameSpaceID_None
aAtom
nsGkAtoms
:
:
_undefined
eCaseMatters
)
)
{
return
false
;
}
return
true
;
}
nsStaticAtom
*
nsAccUtils
:
:
GetARIAToken
(
dom
:
:
Element
*
aElement
nsAtom
*
aAttr
)
{
if
(
!
HasDefinedARIAToken
(
aElement
aAttr
)
)
return
nsGkAtoms
:
:
_empty
;
static
dom
:
:
Element
:
:
AttrValuesArray
tokens
[
]
=
{
nsGkAtoms
:
:
_false
nsGkAtoms
:
:
_true
nsGkAtoms
:
:
mixed
nullptr
}
;
int32_t
idx
=
aElement
-
>
FindAttrValueIn
(
kNameSpaceID_None
aAttr
tokens
eCaseMatters
)
;
if
(
idx
>
=
0
)
return
tokens
[
idx
]
;
return
nullptr
;
}
nsStaticAtom
*
nsAccUtils
:
:
NormalizeARIAToken
(
dom
:
:
Element
*
aElement
nsAtom
*
aAttr
)
{
if
(
!
HasDefinedARIAToken
(
aElement
aAttr
)
)
{
return
nsGkAtoms
:
:
_empty
;
}
if
(
aAttr
=
=
nsGkAtoms
:
:
aria_current
)
{
static
dom
:
:
Element
:
:
AttrValuesArray
tokens
[
]
=
{
nsGkAtoms
:
:
page
nsGkAtoms
:
:
step
nsGkAtoms
:
:
location_
nsGkAtoms
:
:
date
nsGkAtoms
:
:
time
nsGkAtoms
:
:
_true
nullptr
}
;
int32_t
idx
=
aElement
-
>
FindAttrValueIn
(
kNameSpaceID_None
aAttr
tokens
eCaseMatters
)
;
return
(
idx
>
=
0
)
?
tokens
[
idx
]
:
nsGkAtoms
:
:
_true
;
}
return
nullptr
;
}
LocalAccessible
*
nsAccUtils
:
:
GetSelectableContainer
(
LocalAccessible
*
aAccessible
uint64_t
aState
)
{
if
(
!
aAccessible
)
return
nullptr
;
if
(
!
(
aState
&
states
:
:
SELECTABLE
)
)
return
nullptr
;
LocalAccessible
*
parent
=
aAccessible
;
while
(
(
parent
=
parent
-
>
LocalParent
(
)
)
&
&
!
parent
-
>
IsSelect
(
)
)
{
if
(
parent
-
>
Role
(
)
=
=
roles
:
:
PANE
)
return
nullptr
;
}
return
parent
;
}
bool
nsAccUtils
:
:
IsDOMAttrTrue
(
const
LocalAccessible
*
aAccessible
nsAtom
*
aAttr
)
{
dom
:
:
Element
*
el
=
aAccessible
-
>
Elm
(
)
;
return
el
&
&
el
-
>
AttrValueIs
(
kNameSpaceID_None
aAttr
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
LocalAccessible
*
nsAccUtils
:
:
TableFor
(
LocalAccessible
*
aRow
)
{
if
(
aRow
)
{
LocalAccessible
*
table
=
aRow
-
>
LocalParent
(
)
;
if
(
table
)
{
roles
:
:
Role
tableRole
=
table
-
>
Role
(
)
;
const
nsRoleMapEntry
*
roleMapEntry
=
table
-
>
ARIARoleMap
(
)
;
if
(
tableRole
=
=
roles
:
:
GROUPING
|
|
(
table
-
>
IsGenericHyperText
(
)
&
&
!
roleMapEntry
&
&
!
table
-
>
IsTable
(
)
)
)
{
table
=
table
-
>
LocalParent
(
)
;
if
(
table
)
tableRole
=
table
-
>
Role
(
)
;
}
return
(
tableRole
=
=
roles
:
:
TABLE
|
|
tableRole
=
=
roles
:
:
TREE_TABLE
|
|
tableRole
=
=
roles
:
:
MATHML_TABLE
)
?
table
:
nullptr
;
}
}
return
nullptr
;
}
HyperTextAccessible
*
nsAccUtils
:
:
GetTextContainer
(
nsINode
*
aNode
)
{
DocAccessible
*
doc
=
GetAccService
(
)
-
>
GetDocAccessible
(
aNode
-
>
OwnerDoc
(
)
)
;
LocalAccessible
*
accessible
=
doc
?
doc
-
>
GetAccessibleOrContainer
(
aNode
)
:
nullptr
;
if
(
!
accessible
)
return
nullptr
;
do
{
HyperTextAccessible
*
textAcc
=
accessible
-
>
AsHyperText
(
)
;
if
(
textAcc
)
return
textAcc
;
accessible
=
accessible
-
>
LocalParent
(
)
;
}
while
(
accessible
)
;
return
nullptr
;
}
nsIntPoint
nsAccUtils
:
:
ConvertToScreenCoords
(
int32_t
aX
int32_t
aY
uint32_t
aCoordinateType
LocalAccessible
*
aAccessible
)
{
nsIntPoint
coords
(
aX
aY
)
;
switch
(
aCoordinateType
)
{
case
nsIAccessibleCoordinateType
:
:
COORDTYPE_SCREEN_RELATIVE
:
break
;
case
nsIAccessibleCoordinateType
:
:
COORDTYPE_WINDOW_RELATIVE
:
{
coords
+
=
nsCoreUtils
:
:
GetScreenCoordsForWindow
(
aAccessible
-
>
GetNode
(
)
)
;
break
;
}
case
nsIAccessibleCoordinateType
:
:
COORDTYPE_PARENT_RELATIVE
:
{
coords
+
=
GetScreenCoordsForParent
(
aAccessible
)
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
coord
type
!
"
)
;
}
return
coords
;
}
void
nsAccUtils
:
:
ConvertScreenCoordsTo
(
int32_t
*
aX
int32_t
*
aY
uint32_t
aCoordinateType
LocalAccessible
*
aAccessible
)
{
switch
(
aCoordinateType
)
{
case
nsIAccessibleCoordinateType
:
:
COORDTYPE_SCREEN_RELATIVE
:
break
;
case
nsIAccessibleCoordinateType
:
:
COORDTYPE_WINDOW_RELATIVE
:
{
nsIntPoint
coords
=
nsCoreUtils
:
:
GetScreenCoordsForWindow
(
aAccessible
-
>
GetNode
(
)
)
;
*
aX
-
=
coords
.
x
;
*
aY
-
=
coords
.
y
;
break
;
}
case
nsIAccessibleCoordinateType
:
:
COORDTYPE_PARENT_RELATIVE
:
{
nsIntPoint
coords
=
GetScreenCoordsForParent
(
aAccessible
)
;
*
aX
-
=
coords
.
x
;
*
aY
-
=
coords
.
y
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
coord
type
!
"
)
;
}
}
nsIntPoint
nsAccUtils
:
:
GetScreenCoordsForParent
(
LocalAccessible
*
aAccessible
)
{
LocalAccessible
*
parent
=
aAccessible
-
>
LocalParent
(
)
;
if
(
!
parent
)
return
nsIntPoint
(
0
0
)
;
nsIFrame
*
parentFrame
=
parent
-
>
GetFrame
(
)
;
if
(
!
parentFrame
)
return
nsIntPoint
(
0
0
)
;
nsRect
rect
=
parentFrame
-
>
GetScreenRectInAppUnits
(
)
;
return
nsPoint
(
rect
.
X
(
)
rect
.
Y
(
)
)
.
ToNearestPixels
(
parentFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
bool
nsAccUtils
:
:
GetLiveAttrValue
(
uint32_t
aRule
nsAString
&
aValue
)
{
switch
(
aRule
)
{
case
eOffLiveAttr
:
aValue
=
u
"
off
"
_ns
;
return
true
;
case
ePoliteLiveAttr
:
aValue
=
u
"
polite
"
_ns
;
return
true
;
case
eAssertiveLiveAttr
:
aValue
=
u
"
assertive
"
_ns
;
return
true
;
}
return
false
;
}
#
ifdef
DEBUG
bool
nsAccUtils
:
:
IsTextInterfaceSupportCorrect
(
LocalAccessible
*
aAccessible
)
{
if
(
aAccessible
-
>
IsDoc
(
)
)
return
true
;
bool
foundText
=
false
;
uint32_t
childCount
=
aAccessible
-
>
ChildCount
(
)
;
for
(
uint32_t
childIdx
=
0
;
childIdx
<
childCount
;
childIdx
+
+
)
{
LocalAccessible
*
child
=
aAccessible
-
>
LocalChildAt
(
childIdx
)
;
if
(
child
-
>
IsText
(
)
)
{
foundText
=
true
;
break
;
}
}
return
!
foundText
|
|
aAccessible
-
>
IsHyperText
(
)
;
}
#
endif
uint32_t
nsAccUtils
:
:
TextLength
(
LocalAccessible
*
aAccessible
)
{
if
(
!
aAccessible
-
>
IsText
(
)
)
{
return
1
;
}
TextLeafAccessible
*
textLeaf
=
aAccessible
-
>
AsTextLeaf
(
)
;
if
(
textLeaf
)
return
textLeaf
-
>
Text
(
)
.
Length
(
)
;
nsAutoString
text
;
aAccessible
-
>
AppendTextTo
(
text
)
;
return
text
.
Length
(
)
;
}
bool
nsAccUtils
:
:
MustPrune
(
AccessibleOrProxy
aAccessible
)
{
MOZ_ASSERT
(
!
aAccessible
.
IsNull
(
)
)
;
roles
:
:
Role
role
=
aAccessible
.
Role
(
)
;
if
(
role
=
=
roles
:
:
SLIDER
)
{
return
true
;
}
if
(
role
!
=
roles
:
:
MENUITEM
&
&
role
!
=
roles
:
:
COMBOBOX_OPTION
&
&
role
!
=
roles
:
:
OPTION
&
&
role
!
=
roles
:
:
ENTRY
&
&
role
!
=
roles
:
:
FLAT_EQUATION
&
&
role
!
=
roles
:
:
PASSWORD_TEXT
&
&
role
!
=
roles
:
:
PUSHBUTTON
&
&
role
!
=
roles
:
:
TOGGLE_BUTTON
&
&
role
!
=
roles
:
:
GRAPHIC
&
&
role
!
=
roles
:
:
PROGRESSBAR
&
&
role
!
=
roles
:
:
SEPARATOR
)
{
return
false
;
}
if
(
aAccessible
.
ChildCount
(
)
!
=
1
)
{
return
false
;
}
roles
:
:
Role
childRole
=
aAccessible
.
FirstChild
(
)
.
Role
(
)
;
return
childRole
=
=
roles
:
:
TEXT_LEAF
|
|
childRole
=
=
roles
:
:
STATICTEXT
;
}
bool
nsAccUtils
:
:
PersistentPropertiesToArray
(
nsIPersistentProperties
*
aProps
nsTArray
<
Attribute
>
*
aAttributes
)
{
if
(
!
aProps
)
{
return
true
;
}
nsCOMPtr
<
nsISimpleEnumerator
>
propEnum
;
nsresult
rv
=
aProps
-
>
Enumerate
(
getter_AddRefs
(
propEnum
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
bool
hasMore
;
while
(
NS_SUCCEEDED
(
propEnum
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
sup
;
rv
=
propEnum
-
>
GetNext
(
getter_AddRefs
(
sup
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsCOMPtr
<
nsIPropertyElement
>
propElem
(
do_QueryInterface
(
sup
)
)
;
NS_ENSURE_TRUE
(
propElem
false
)
;
nsAutoCString
name
;
rv
=
propElem
-
>
GetKey
(
name
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsAutoString
value
;
rv
=
propElem
-
>
GetValue
(
value
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
aAttributes
-
>
AppendElement
(
Attribute
(
name
value
)
)
;
}
return
true
;
}
bool
nsAccUtils
:
:
IsARIALive
(
const
LocalAccessible
*
aAccessible
)
{
nsIContent
*
ancestor
=
aAccessible
-
>
GetContent
(
)
;
if
(
!
ancestor
)
{
return
false
;
}
dom
:
:
Document
*
doc
=
ancestor
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
false
;
}
dom
:
:
Element
*
topEl
=
doc
-
>
GetRootElement
(
)
;
while
(
ancestor
)
{
const
nsRoleMapEntry
*
role
=
nullptr
;
if
(
ancestor
-
>
IsElement
(
)
)
{
role
=
aria
:
:
GetRoleMap
(
ancestor
-
>
AsElement
(
)
)
;
}
nsAutoString
live
;
if
(
HasDefinedARIAToken
(
ancestor
nsGkAtoms
:
:
aria_live
)
)
{
ancestor
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_live
live
)
;
}
else
if
(
role
)
{
GetLiveAttrValue
(
role
-
>
liveAttRule
live
)
;
}
else
if
(
nsStaticAtom
*
value
=
GetAccService
(
)
-
>
MarkupAttribute
(
ancestor
nsGkAtoms
:
:
live
)
)
{
value
-
>
ToString
(
live
)
;
}
if
(
!
live
.
IsEmpty
(
)
&
&
!
live
.
EqualsLiteral
(
"
off
"
)
)
{
return
true
;
}
if
(
ancestor
=
=
topEl
)
{
break
;
}
ancestor
=
ancestor
-
>
GetParent
(
)
;
if
(
!
ancestor
)
{
ancestor
=
topEl
;
}
}
return
false
;
}
