#
include
"
DocManager
.
h
"
#
include
"
ApplicationAccessible
.
h
"
#
include
"
ARIAMap
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
DocAccessibleChild
.
h
"
#
include
"
DocAccessibleParent
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
Platform
.
h
"
#
include
"
RootAccessibleWrap
.
h
"
#
include
"
xpcAccessibleDocument
.
h
"
#
ifdef
A11Y_LOG
#
include
"
Logging
.
h
"
#
endif
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDocShellLoadTypes
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIWebProgress
.
h
"
#
include
"
nsCoreUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
using
namespace
mozilla
:
:
dom
;
StaticAutoPtr
<
nsTArray
<
DocAccessibleParent
*
>
>
DocManager
:
:
sRemoteDocuments
;
nsRefPtrHashtable
<
nsPtrHashKey
<
const
DocAccessibleParent
>
xpcAccessibleDocument
>
*
DocManager
:
:
sRemoteXPCDocumentCache
=
nullptr
;
DocManager
:
:
DocManager
(
)
:
mDocAccessibleCache
(
2
)
mXPCDocumentCache
(
0
)
{
}
DocAccessible
*
DocManager
:
:
GetDocAccessible
(
Document
*
aDocument
)
{
if
(
!
aDocument
)
return
nullptr
;
DocAccessible
*
docAcc
=
GetExistingDocAccessible
(
aDocument
)
;
if
(
docAcc
)
return
docAcc
;
return
CreateDocOrRootAccessible
(
aDocument
)
;
}
Accessible
*
DocManager
:
:
FindAccessibleInCache
(
nsINode
*
aNode
)
const
{
for
(
auto
iter
=
mDocAccessibleCache
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
DocAccessible
*
docAccessible
=
iter
.
UserData
(
)
;
NS_ASSERTION
(
docAccessible
"
No
doc
accessible
for
the
object
in
doc
accessible
cache
!
"
)
;
if
(
docAccessible
)
{
Accessible
*
accessible
=
docAccessible
-
>
GetAccessible
(
aNode
)
;
if
(
accessible
)
{
return
accessible
;
}
}
}
return
nullptr
;
}
void
DocManager
:
:
RemoveFromXPCDocumentCache
(
DocAccessible
*
aDocument
)
{
xpcAccessibleDocument
*
xpcDoc
=
mXPCDocumentCache
.
GetWeak
(
aDocument
)
;
if
(
xpcDoc
)
{
xpcDoc
-
>
Shutdown
(
)
;
mXPCDocumentCache
.
Remove
(
aDocument
)
;
if
(
!
HasXPCDocuments
(
)
)
{
MaybeShutdownAccService
(
nsAccessibilityService
:
:
eXPCOM
)
;
}
}
}
void
DocManager
:
:
NotifyOfDocumentShutdown
(
DocAccessible
*
aDocument
Document
*
aDOMDocument
)
{
RemoveListeners
(
aDOMDocument
)
;
if
(
nsAccessibilityService
:
:
IsShutdown
(
)
)
{
return
;
}
RemoveFromXPCDocumentCache
(
aDocument
)
;
mDocAccessibleCache
.
Remove
(
aDOMDocument
)
;
}
void
DocManager
:
:
RemoveFromRemoteXPCDocumentCache
(
DocAccessibleParent
*
aDoc
)
{
xpcAccessibleDocument
*
doc
=
GetCachedXPCDocument
(
aDoc
)
;
if
(
doc
)
{
doc
-
>
Shutdown
(
)
;
sRemoteXPCDocumentCache
-
>
Remove
(
aDoc
)
;
}
if
(
sRemoteXPCDocumentCache
&
&
sRemoteXPCDocumentCache
-
>
Count
(
)
=
=
0
)
{
MaybeShutdownAccService
(
nsAccessibilityService
:
:
eXPCOM
)
;
}
}
void
DocManager
:
:
NotifyOfRemoteDocShutdown
(
DocAccessibleParent
*
aDoc
)
{
RemoveFromRemoteXPCDocumentCache
(
aDoc
)
;
}
xpcAccessibleDocument
*
DocManager
:
:
GetXPCDocument
(
DocAccessible
*
aDocument
)
{
if
(
!
aDocument
)
return
nullptr
;
xpcAccessibleDocument
*
xpcDoc
=
mXPCDocumentCache
.
GetWeak
(
aDocument
)
;
if
(
!
xpcDoc
)
{
xpcDoc
=
new
xpcAccessibleDocument
(
aDocument
)
;
mXPCDocumentCache
.
Put
(
aDocument
xpcDoc
)
;
}
return
xpcDoc
;
}
xpcAccessibleDocument
*
DocManager
:
:
GetXPCDocument
(
DocAccessibleParent
*
aDoc
)
{
xpcAccessibleDocument
*
doc
=
GetCachedXPCDocument
(
aDoc
)
;
if
(
doc
)
{
return
doc
;
}
if
(
!
sRemoteXPCDocumentCache
)
{
sRemoteXPCDocumentCache
=
new
nsRefPtrHashtable
<
nsPtrHashKey
<
const
DocAccessibleParent
>
xpcAccessibleDocument
>
;
}
doc
=
new
xpcAccessibleDocument
(
aDoc
Interfaces
:
:
DOCUMENT
|
Interfaces
:
:
HYPERTEXT
)
;
sRemoteXPCDocumentCache
-
>
Put
(
aDoc
doc
)
;
return
doc
;
}
#
ifdef
DEBUG
bool
DocManager
:
:
IsProcessingRefreshDriverNotification
(
)
const
{
for
(
auto
iter
=
mDocAccessibleCache
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
DocAccessible
*
docAccessible
=
iter
.
UserData
(
)
;
NS_ASSERTION
(
docAccessible
"
No
doc
accessible
for
the
object
in
doc
accessible
cache
!
"
)
;
if
(
docAccessible
&
&
docAccessible
-
>
mNotificationController
&
&
docAccessible
-
>
mNotificationController
-
>
IsUpdating
(
)
)
{
return
true
;
}
}
return
false
;
}
#
endif
bool
DocManager
:
:
Init
(
)
{
nsCOMPtr
<
nsIWebProgress
>
progress
=
components
:
:
DocLoader
:
:
Service
(
)
;
if
(
!
progress
)
return
false
;
progress
-
>
AddProgressListener
(
static_cast
<
nsIWebProgressListener
*
>
(
this
)
nsIWebProgress
:
:
NOTIFY_STATE_DOCUMENT
)
;
return
true
;
}
void
DocManager
:
:
Shutdown
(
)
{
nsCOMPtr
<
nsIWebProgress
>
progress
=
components
:
:
DocLoader
:
:
Service
(
)
;
if
(
progress
)
progress
-
>
RemoveProgressListener
(
static_cast
<
nsIWebProgressListener
*
>
(
this
)
)
;
ClearDocCache
(
)
;
}
NS_IMPL_ISUPPORTS
(
DocManager
nsIWebProgressListener
nsIDOMEventListener
nsISupportsWeakReference
)
NS_IMETHODIMP
DocManager
:
:
OnStateChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aStateFlags
nsresult
aStatus
)
{
NS_ASSERTION
(
aStateFlags
&
STATE_IS_DOCUMENT
"
Other
notifications
excluded
"
)
;
if
(
nsAccessibilityService
:
:
IsShutdown
(
)
|
|
!
aWebProgress
|
|
(
aStateFlags
&
(
STATE_START
|
STATE_STOP
)
)
=
=
0
)
return
NS_OK
;
nsCOMPtr
<
mozIDOMWindowProxy
>
DOMWindow
;
aWebProgress
-
>
GetDOMWindow
(
getter_AddRefs
(
DOMWindow
)
)
;
NS_ENSURE_STATE
(
DOMWindow
)
;
nsPIDOMWindowOuter
*
piWindow
=
nsPIDOMWindowOuter
:
:
From
(
DOMWindow
)
;
MOZ_ASSERT
(
piWindow
)
;
nsCOMPtr
<
Document
>
document
=
piWindow
-
>
GetDoc
(
)
;
NS_ENSURE_STATE
(
document
)
;
if
(
aStateFlags
&
STATE_STOP
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocLoad
)
)
logging
:
:
DocLoad
(
"
document
loaded
"
aWebProgress
aRequest
aStateFlags
)
;
#
endif
uint32_t
eventType
=
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_LOAD_STOPPED
;
if
(
NS_SUCCEEDED
(
aStatus
)
|
|
!
nsCoreUtils
:
:
IsContentDocument
(
document
)
)
eventType
=
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_LOAD_COMPLETE
;
if
(
aRequest
)
{
uint32_t
loadFlags
=
0
;
aRequest
-
>
GetLoadFlags
(
&
loadFlags
)
;
if
(
loadFlags
&
nsIChannel
:
:
LOAD_RETARGETED_DOCUMENT_URI
)
eventType
=
0
;
}
HandleDOMDocumentLoad
(
document
eventType
)
;
return
NS_OK
;
}
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocLoad
)
)
logging
:
:
DocLoad
(
"
start
document
loading
"
aWebProgress
aRequest
aStateFlags
)
;
#
endif
DocAccessible
*
docAcc
=
GetExistingDocAccessible
(
document
)
;
if
(
!
docAcc
)
return
NS_OK
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_GetInterface
(
DOMWindow
)
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
do_QueryInterface
(
webNav
)
)
;
NS_ENSURE_STATE
(
docShell
)
;
bool
isReloading
=
false
;
uint32_t
loadType
;
docShell
-
>
GetLoadType
(
&
loadType
)
;
if
(
loadType
=
=
LOAD_RELOAD_NORMAL
|
|
loadType
=
=
LOAD_RELOAD_BYPASS_CACHE
|
|
loadType
=
=
LOAD_RELOAD_BYPASS_PROXY
|
|
loadType
=
=
LOAD_RELOAD_BYPASS_PROXY_AND_CACHE
|
|
loadType
=
=
LOAD_RELOAD_ALLOW_MIXED_CONTENT
)
{
isReloading
=
true
;
}
docAcc
-
>
NotifyOfLoading
(
isReloading
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocManager
:
:
OnProgressChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
int32_t
aCurSelfProgress
int32_t
aMaxSelfProgress
int32_t
aCurTotalProgress
int32_t
aMaxTotalProgress
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocManager
:
:
OnLocationChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsIURI
*
aLocation
uint32_t
aFlags
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocManager
:
:
OnStatusChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsresult
aStatus
const
char16_t
*
aMessage
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocManager
:
:
OnSecurityChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aState
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocManager
:
:
OnContentBlockingEvent
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aEvent
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DocManager
:
:
HandleEvent
(
Event
*
aEvent
)
{
nsAutoString
type
;
aEvent
-
>
GetType
(
type
)
;
nsCOMPtr
<
Document
>
document
=
do_QueryInterface
(
aEvent
-
>
GetTarget
(
)
)
;
NS_ASSERTION
(
document
"
pagehide
or
DOMContentLoaded
for
non
document
!
"
)
;
if
(
!
document
)
return
NS_OK
;
if
(
type
.
EqualsLiteral
(
"
pagehide
"
)
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocDestroy
)
)
logging
:
:
DocDestroy
(
"
received
'
pagehide
'
event
"
document
)
;
#
endif
DocAccessible
*
docAccessible
=
GetExistingDocAccessible
(
document
)
;
if
(
docAccessible
)
docAccessible
-
>
Shutdown
(
)
;
return
NS_OK
;
}
if
(
type
.
EqualsLiteral
(
"
DOMContentLoaded
"
)
&
&
nsCoreUtils
:
:
IsErrorPage
(
document
)
)
{
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocLoad
)
)
logging
:
:
DocLoad
(
"
handled
'
DOMContentLoaded
'
event
"
document
)
;
#
endif
HandleDOMDocumentLoad
(
document
nsIAccessibleEvent
:
:
EVENT_DOCUMENT_LOAD_COMPLETE
)
;
}
return
NS_OK
;
}
void
DocManager
:
:
HandleDOMDocumentLoad
(
Document
*
aDocument
uint32_t
aLoadEventType
)
{
DocAccessible
*
docAcc
=
GetExistingDocAccessible
(
aDocument
)
;
if
(
!
docAcc
)
{
docAcc
=
CreateDocOrRootAccessible
(
aDocument
)
;
if
(
!
docAcc
)
return
;
}
docAcc
-
>
NotifyOfLoad
(
aLoadEventType
)
;
}
void
DocManager
:
:
AddListeners
(
Document
*
aDocument
bool
aAddDOMContentLoadedListener
)
{
nsPIDOMWindowOuter
*
window
=
aDocument
-
>
GetWindow
(
)
;
EventTarget
*
target
=
window
-
>
GetChromeEventHandler
(
)
;
EventListenerManager
*
elm
=
target
-
>
GetOrCreateListenerManager
(
)
;
elm
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
pagehide
"
)
TrustedEventsAtCapture
(
)
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocCreate
)
)
logging
:
:
Text
(
"
added
'
pagehide
'
listener
"
)
;
#
endif
if
(
aAddDOMContentLoadedListener
)
{
elm
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
DOMContentLoaded
"
)
TrustedEventsAtCapture
(
)
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocCreate
)
)
logging
:
:
Text
(
"
added
'
DOMContentLoaded
'
listener
"
)
;
#
endif
}
}
void
DocManager
:
:
RemoveListeners
(
Document
*
aDocument
)
{
nsPIDOMWindowOuter
*
window
=
aDocument
-
>
GetWindow
(
)
;
if
(
!
window
)
return
;
EventTarget
*
target
=
window
-
>
GetChromeEventHandler
(
)
;
if
(
!
target
)
return
;
EventListenerManager
*
elm
=
target
-
>
GetOrCreateListenerManager
(
)
;
elm
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
pagehide
"
)
TrustedEventsAtCapture
(
)
)
;
elm
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
DOMContentLoaded
"
)
TrustedEventsAtCapture
(
)
)
;
}
DocAccessible
*
DocManager
:
:
CreateDocOrRootAccessible
(
Document
*
aDocument
)
{
if
(
!
aDocument
-
>
IsVisibleConsideringAncestors
(
)
|
|
aDocument
-
>
IsResourceDoc
(
)
|
|
aDocument
-
>
IsStaticDocument
(
)
|
|
!
aDocument
-
>
IsActive
(
)
)
{
return
nullptr
;
}
nsIDocShell
*
docShell
=
aDocument
-
>
GetDocShell
(
)
;
if
(
!
docShell
|
|
docShell
-
>
IsInvisible
(
)
)
{
return
nullptr
;
}
nsIWidget
*
widget
=
nsContentUtils
:
:
WidgetForDocument
(
aDocument
)
;
if
(
!
widget
|
|
widget
-
>
WindowType
(
)
=
=
eWindowType_invisible
)
{
return
nullptr
;
}
nsIPresShell
*
presShell
=
aDocument
-
>
GetShell
(
)
;
if
(
!
presShell
|
|
presShell
-
>
IsDestroying
(
)
)
return
nullptr
;
bool
isRootDoc
=
nsCoreUtils
:
:
IsRootDocument
(
aDocument
)
;
DocAccessible
*
parentDocAcc
=
nullptr
;
if
(
!
isRootDoc
)
{
parentDocAcc
=
GetDocAccessible
(
aDocument
-
>
GetParentDocument
(
)
)
;
NS_ASSERTION
(
parentDocAcc
"
Can
'
t
create
an
accessible
for
the
document
!
"
)
;
if
(
!
parentDocAcc
)
return
nullptr
;
}
RefPtr
<
DocAccessible
>
docAcc
=
isRootDoc
?
new
RootAccessibleWrap
(
aDocument
presShell
)
:
new
DocAccessibleWrap
(
aDocument
presShell
)
;
mDocAccessibleCache
.
Put
(
aDocument
docAcc
)
;
docAcc
-
>
Init
(
)
;
if
(
isRootDoc
)
{
if
(
!
ApplicationAcc
(
)
-
>
AppendChild
(
docAcc
)
)
{
docAcc
-
>
Shutdown
(
)
;
return
nullptr
;
}
docAcc
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_REORDER
ApplicationAcc
(
)
)
;
}
else
{
parentDocAcc
-
>
BindChildDocument
(
docAcc
)
;
}
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eDocCreate
)
)
{
logging
:
:
DocCreate
(
"
document
creation
finished
"
aDocument
)
;
logging
:
:
Stack
(
)
;
}
#
endif
AddListeners
(
aDocument
isRootDoc
)
;
return
docAcc
;
}
void
DocManager
:
:
ClearDocCache
(
)
{
while
(
mDocAccessibleCache
.
Count
(
)
>
0
)
{
auto
iter
=
mDocAccessibleCache
.
Iter
(
)
;
MOZ_ASSERT
(
!
iter
.
Done
(
)
)
;
DocAccessible
*
docAcc
=
iter
.
UserData
(
)
;
NS_ASSERTION
(
docAcc
"
No
doc
accessible
for
the
object
in
doc
accessible
cache
!
"
)
;
if
(
docAcc
)
{
docAcc
-
>
Shutdown
(
)
;
}
iter
.
Remove
(
)
;
}
while
(
mXPCDocumentCache
.
Count
(
)
>
0
)
{
auto
iter
=
mXPCDocumentCache
.
Iter
(
)
;
MOZ_ASSERT
(
!
iter
.
Done
(
)
)
;
xpcAccessibleDocument
*
xpcDoc
=
iter
.
UserData
(
)
;
NS_ASSERTION
(
xpcDoc
"
No
xpc
doc
for
the
object
in
xpc
doc
cache
!
"
)
;
if
(
xpcDoc
)
{
xpcDoc
-
>
Shutdown
(
)
;
}
iter
.
Remove
(
)
;
}
}
void
DocManager
:
:
RemoteDocAdded
(
DocAccessibleParent
*
aDoc
)
{
if
(
!
sRemoteDocuments
)
{
sRemoteDocuments
=
new
nsTArray
<
DocAccessibleParent
*
>
;
ClearOnShutdown
(
&
sRemoteDocuments
)
;
}
MOZ_ASSERT
(
!
sRemoteDocuments
-
>
Contains
(
aDoc
)
"
How
did
we
already
have
the
doc
!
"
)
;
sRemoteDocuments
-
>
AppendElement
(
aDoc
)
;
ProxyCreated
(
aDoc
Interfaces
:
:
DOCUMENT
|
Interfaces
:
:
HYPERTEXT
)
;
}
