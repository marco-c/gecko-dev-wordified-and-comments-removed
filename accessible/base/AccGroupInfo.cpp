#
include
"
AccGroupInfo
.
h
"
#
include
"
mozilla
/
a11y
/
Accessible
.
h
"
#
include
"
mozilla
/
a11y
/
TableAccessible
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsIAccessiblePivot
.
h
"
#
include
"
Pivot
.
h
"
#
include
"
States
.
h
"
using
namespace
mozilla
:
:
a11y
;
static
role
BaseRole
(
role
aRole
)
;
class
CompoundWidgetSiblingRule
:
public
PivotRule
{
public
:
CompoundWidgetSiblingRule
(
)
=
delete
;
explicit
CompoundWidgetSiblingRule
(
role
aRole
)
:
mRole
(
aRole
)
{
}
uint16_t
Match
(
Accessible
*
aAcc
)
override
{
const
role
accRole
=
aAcc
-
>
Role
(
)
;
if
(
BaseRole
(
accRole
)
=
=
mRole
|
|
accRole
=
=
role
:
:
SEPARATOR
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
|
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
aAcc
-
>
IsGeneric
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
}
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
private
:
role
mRole
=
role
:
:
NOTHING
;
}
;
AccGroupInfo
:
:
AccGroupInfo
(
const
Accessible
*
aItem
role
aRole
)
:
mPosInSet
(
0
)
mSetSize
(
0
)
mParentId
(
0
)
mItem
(
aItem
)
mRole
(
aRole
)
{
MOZ_COUNT_CTOR
(
AccGroupInfo
)
;
Update
(
)
;
}
void
AccGroupInfo
:
:
Update
(
)
{
mParentId
=
0
;
Accessible
*
parent
=
mItem
-
>
GetNonGenericParent
(
)
;
if
(
!
parent
)
{
return
;
}
const
int32_t
level
=
GetARIAOrDefaultLevel
(
mItem
)
;
mPosInSet
=
1
;
Accessible
*
candidateSibling
=
const_cast
<
Accessible
*
>
(
mItem
)
;
Pivot
pivot
{
parent
}
;
CompoundWidgetSiblingRule
widgetSiblingRule
{
mRole
}
;
while
(
(
candidateSibling
=
pivot
.
Prev
(
candidateSibling
widgetSiblingRule
)
)
&
&
candidateSibling
!
=
parent
)
{
if
(
candidateSibling
-
>
Role
(
)
=
=
roles
:
:
SEPARATOR
)
{
break
;
}
const
AccGroupInfo
*
siblingGroupInfo
=
candidateSibling
-
>
GetGroupInfo
(
)
;
if
(
!
siblingGroupInfo
&
&
candidateSibling
-
>
State
(
)
&
states
:
:
INVISIBLE
)
{
continue
;
}
const
int32_t
siblingLevel
=
GetARIAOrDefaultLevel
(
candidateSibling
)
;
if
(
siblingLevel
<
level
)
{
mParentId
=
candidateSibling
-
>
ID
(
)
;
break
;
}
if
(
siblingLevel
>
level
)
{
continue
;
}
if
(
siblingGroupInfo
)
{
mPosInSet
+
=
siblingGroupInfo
-
>
mPosInSet
;
mParentId
=
siblingGroupInfo
-
>
mParentId
;
mSetSize
=
siblingGroupInfo
-
>
mSetSize
;
return
;
}
mPosInSet
+
+
;
}
mSetSize
=
mPosInSet
;
candidateSibling
=
const_cast
<
Accessible
*
>
(
mItem
)
;
while
(
(
candidateSibling
=
pivot
.
Next
(
candidateSibling
widgetSiblingRule
)
)
&
&
candidateSibling
!
=
parent
)
{
if
(
candidateSibling
-
>
Role
(
)
=
=
roles
:
:
SEPARATOR
)
{
break
;
}
const
AccGroupInfo
*
siblingGroupInfo
=
candidateSibling
-
>
GetGroupInfo
(
)
;
if
(
!
siblingGroupInfo
&
&
candidateSibling
-
>
State
(
)
&
states
:
:
INVISIBLE
)
{
continue
;
}
const
int32_t
siblingLevel
=
GetARIAOrDefaultLevel
(
candidateSibling
)
;
if
(
siblingLevel
<
level
)
{
break
;
}
if
(
siblingLevel
>
level
)
{
continue
;
}
if
(
siblingGroupInfo
)
{
mParentId
=
siblingGroupInfo
-
>
mParentId
;
mSetSize
=
siblingGroupInfo
-
>
mSetSize
;
return
;
}
mSetSize
+
+
;
}
if
(
mParentId
)
{
return
;
}
roles
:
:
Role
parentRole
=
parent
-
>
Role
(
)
;
if
(
ShouldReportRelations
(
mRole
parentRole
)
)
{
mParentId
=
parent
-
>
ID
(
)
;
}
if
(
parentRole
!
=
roles
:
:
GROUPING
)
{
return
;
}
if
(
mRole
=
=
roles
:
:
OUTLINEITEM
)
{
Accessible
*
grandParent
=
parent
-
>
GetNonGenericParent
(
)
;
MOZ_ASSERT
(
grandParent
)
;
Pivot
pivot
{
grandParent
}
;
CompoundWidgetSiblingRule
parentSiblingRule
{
mRole
}
;
Accessible
*
parentPrevSibling
=
pivot
.
Prev
(
parent
widgetSiblingRule
)
;
if
(
parentPrevSibling
&
&
parentPrevSibling
-
>
Role
(
)
=
=
mRole
)
{
mParentId
=
parentPrevSibling
-
>
ID
(
)
;
return
;
}
}
if
(
mRole
=
=
roles
:
:
LISTITEM
|
|
mRole
=
=
roles
:
:
OUTLINEITEM
)
{
Accessible
*
grandParent
=
parent
-
>
GetNonGenericParent
(
)
;
if
(
grandParent
&
&
grandParent
-
>
Role
(
)
=
=
mRole
)
{
mParentId
=
grandParent
-
>
ID
(
)
;
}
}
}
AccGroupInfo
*
AccGroupInfo
:
:
CreateGroupInfo
(
const
Accessible
*
aAccessible
)
{
mozilla
:
:
a11y
:
:
role
role
=
aAccessible
-
>
Role
(
)
;
if
(
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
ROW
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
OUTLINEITEM
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
OPTION
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
LISTITEM
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
MENUITEM
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
COMBOBOX_OPTION
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
RICH_OPTION
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
CHECK_RICH_OPTION
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
PARENT_MENUITEM
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
CHECK_MENU_ITEM
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
RADIO_MENU_ITEM
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
RADIOBUTTON
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
PAGETAB
&
&
role
!
=
mozilla
:
:
a11y
:
:
roles
:
:
COMMENT
)
{
return
nullptr
;
}
AccGroupInfo
*
info
=
new
AccGroupInfo
(
aAccessible
BaseRole
(
role
)
)
;
return
info
;
}
Accessible
*
AccGroupInfo
:
:
FirstItemOf
(
const
Accessible
*
aContainer
)
{
a11y
:
:
role
containerRole
=
aContainer
-
>
Role
(
)
;
Accessible
*
item
=
aContainer
-
>
NextSibling
(
)
;
if
(
item
)
{
if
(
containerRole
=
=
roles
:
:
OUTLINEITEM
&
&
item
-
>
Role
(
)
=
=
roles
:
:
GROUPING
)
{
item
=
item
-
>
FirstChild
(
)
;
}
if
(
item
)
{
AccGroupInfo
*
itemGroupInfo
=
item
-
>
GetOrCreateGroupInfo
(
)
;
if
(
itemGroupInfo
&
&
itemGroupInfo
-
>
ConceptualParent
(
)
=
=
aContainer
)
{
return
item
;
}
}
}
item
=
aContainer
-
>
LastChild
(
)
;
if
(
!
item
)
return
nullptr
;
if
(
item
-
>
Role
(
)
=
=
roles
:
:
GROUPING
&
&
(
containerRole
=
=
roles
:
:
LISTITEM
|
|
containerRole
=
=
roles
:
:
OUTLINEITEM
)
)
{
item
=
item
-
>
FirstChild
(
)
;
if
(
item
)
{
AccGroupInfo
*
itemGroupInfo
=
item
-
>
GetOrCreateGroupInfo
(
)
;
if
(
itemGroupInfo
&
&
itemGroupInfo
-
>
ConceptualParent
(
)
=
=
aContainer
)
{
return
item
;
}
}
}
item
=
aContainer
-
>
FirstChild
(
)
;
if
(
ShouldReportRelations
(
item
-
>
Role
(
)
containerRole
)
)
return
item
;
return
nullptr
;
}
uint32_t
AccGroupInfo
:
:
TotalItemCount
(
Accessible
*
aContainer
bool
*
aIsHierarchical
)
{
uint32_t
itemCount
=
0
;
switch
(
aContainer
-
>
Role
(
)
)
{
case
roles
:
:
GRID
:
case
roles
:
:
TABLE
:
if
(
auto
val
=
aContainer
-
>
GetIntARIAAttr
(
nsGkAtoms
:
:
aria_rowcount
)
)
{
if
(
*
val
>
=
0
)
{
return
*
val
;
}
}
if
(
TableAccessible
*
tableAcc
=
aContainer
-
>
AsTable
(
)
)
{
return
tableAcc
-
>
RowCount
(
)
;
}
break
;
case
roles
:
:
ROW
:
if
(
Accessible
*
table
=
nsAccUtils
:
:
TableFor
(
aContainer
)
)
{
if
(
auto
val
=
table
-
>
GetIntARIAAttr
(
nsGkAtoms
:
:
aria_colcount
)
)
{
if
(
*
val
>
=
0
)
{
return
*
val
;
}
}
if
(
TableAccessible
*
tableAcc
=
table
-
>
AsTable
(
)
)
{
return
tableAcc
-
>
ColCount
(
)
;
}
}
break
;
case
roles
:
:
OUTLINE
:
case
roles
:
:
LIST
:
case
roles
:
:
MENUBAR
:
case
roles
:
:
MENUPOPUP
:
case
roles
:
:
COMBOBOX
:
case
roles
:
:
GROUPING
:
case
roles
:
:
ROWGROUP
:
case
roles
:
:
TREE_TABLE
:
case
roles
:
:
COMBOBOX_LIST
:
case
roles
:
:
LISTBOX
:
case
roles
:
:
DEFINITION_LIST
:
case
roles
:
:
EDITCOMBOBOX
:
case
roles
:
:
RADIO_GROUP
:
case
roles
:
:
PAGETABLIST
:
{
Accessible
*
childItem
=
AccGroupInfo
:
:
FirstItemOf
(
aContainer
)
;
if
(
!
childItem
)
{
childItem
=
aContainer
-
>
FirstChild
(
)
;
if
(
childItem
&
&
childItem
-
>
IsTextLeaf
(
)
)
{
childItem
=
childItem
-
>
NextSibling
(
)
;
}
}
if
(
childItem
)
{
GroupPos
groupPos
=
childItem
-
>
GroupPosition
(
)
;
itemCount
=
groupPos
.
setSize
;
if
(
groupPos
.
level
&
&
aIsHierarchical
)
{
*
aIsHierarchical
=
true
;
}
}
break
;
}
default
:
break
;
}
return
itemCount
;
}
Accessible
*
AccGroupInfo
:
:
NextItemTo
(
Accessible
*
aItem
)
{
AccGroupInfo
*
groupInfo
=
aItem
-
>
GetOrCreateGroupInfo
(
)
;
if
(
!
groupInfo
)
return
nullptr
;
if
(
groupInfo
-
>
PosInSet
(
)
>
=
groupInfo
-
>
SetSize
(
)
)
return
nullptr
;
Accessible
*
parent
=
aItem
-
>
Parent
(
)
;
uint32_t
childCount
=
parent
-
>
ChildCount
(
)
;
for
(
uint32_t
idx
=
aItem
-
>
IndexInParent
(
)
+
1
;
idx
<
childCount
;
idx
+
+
)
{
Accessible
*
nextItem
=
parent
-
>
ChildAt
(
idx
)
;
AccGroupInfo
*
nextGroupInfo
=
nextItem
-
>
GetOrCreateGroupInfo
(
)
;
if
(
nextGroupInfo
&
&
nextGroupInfo
-
>
ConceptualParent
(
)
=
=
groupInfo
-
>
ConceptualParent
(
)
)
{
return
nextItem
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
Item
in
the
middle
of
the
group
but
there
'
s
no
next
item
!
"
)
;
return
nullptr
;
}
size_t
AccGroupInfo
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
return
aMallocSizeOf
(
this
)
;
}
bool
AccGroupInfo
:
:
ShouldReportRelations
(
role
aRole
role
aParentRole
)
{
if
(
aParentRole
=
=
roles
:
:
OUTLINE
&
&
aRole
=
=
roles
:
:
OUTLINEITEM
)
return
true
;
if
(
aParentRole
=
=
roles
:
:
TREE_TABLE
&
&
aRole
=
=
roles
:
:
ROW
)
return
true
;
if
(
aParentRole
=
=
roles
:
:
LIST
&
&
aRole
=
=
roles
:
:
LISTITEM
)
return
true
;
return
false
;
}
int32_t
AccGroupInfo
:
:
GetARIAOrDefaultLevel
(
const
Accessible
*
aAccessible
)
{
int32_t
level
=
0
;
aAccessible
-
>
ARIAGroupPosition
(
&
level
nullptr
nullptr
)
;
if
(
level
!
=
0
)
return
level
;
return
aAccessible
-
>
GetLevel
(
true
)
;
}
Accessible
*
AccGroupInfo
:
:
ConceptualParent
(
)
const
{
if
(
!
mParentId
)
{
return
nullptr
;
}
if
(
Accessible
*
doc
=
nsAccUtils
:
:
DocumentFor
(
const_cast
<
Accessible
*
>
(
mItem
)
)
)
{
return
nsAccUtils
:
:
GetAccessibleByID
(
doc
mParentId
)
;
}
return
nullptr
;
}
static
role
BaseRole
(
role
aRole
)
{
if
(
aRole
=
=
roles
:
:
CHECK_MENU_ITEM
|
|
aRole
=
=
roles
:
:
PARENT_MENUITEM
|
|
aRole
=
=
roles
:
:
RADIO_MENU_ITEM
)
{
return
roles
:
:
MENUITEM
;
}
if
(
aRole
=
=
roles
:
:
CHECK_RICH_OPTION
)
{
return
roles
:
:
RICH_OPTION
;
}
return
aRole
;
}
