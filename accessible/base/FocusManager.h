#
ifndef
mozilla_a11y_FocusManager_h_
#
define
mozilla_a11y_FocusManager_h_
#
include
"
mozilla
/
a11y
/
Accessible
.
h
"
#
include
"
nsAutoPtr
.
h
"
class
nsINode
;
class
nsIDocument
;
class
nsISupports
;
namespace
mozilla
{
namespace
a11y
{
class
AccEvent
;
class
ProxyAccessible
;
class
DocAccessible
;
class
FocusManager
{
public
:
virtual
~
FocusManager
(
)
;
Accessible
*
FocusedAccessible
(
)
const
{
return
mFocusedAcc
;
}
ProxyAccessible
*
FocusedRemoteAccessible
(
)
const
{
return
mFocusedProxy
;
}
void
ResetFocusedAccessible
(
)
{
mFocusedAcc
=
nullptr
;
mFocusedProxy
=
nullptr
;
}
bool
IsFocused
(
const
Accessible
*
aAccessible
)
const
{
return
aAccessible
=
=
mFocusedAcc
;
}
inline
bool
IsActiveItem
(
const
Accessible
*
aAccessible
)
{
return
aAccessible
=
=
mActiveItem
;
}
inline
bool
HasDOMFocus
(
const
nsINode
*
aNode
)
const
{
return
aNode
=
=
FocusedDOMNode
(
)
;
}
bool
IsFocusWithin
(
const
Accessible
*
aContainer
)
const
;
enum
FocusDisposition
{
eNone
eFocused
eContainsFocus
eContainedByFocus
}
;
FocusDisposition
IsInOrContainsFocus
(
const
Accessible
*
aAccessible
)
const
;
void
NotifyOfDOMFocus
(
nsISupports
*
aTarget
)
;
void
NotifyOfDOMBlur
(
nsISupports
*
aTarget
)
;
void
ActiveItemChanged
(
Accessible
*
aItem
bool
aCheckIfActive
=
true
)
;
void
RemoteFocusChanged
(
ProxyAccessible
*
aProxy
)
{
mFocusedProxy
=
aProxy
;
}
void
ForceFocusEvent
(
)
;
void
DispatchFocusEvent
(
DocAccessible
*
aDocument
Accessible
*
aTarget
)
;
void
ProcessDOMFocus
(
nsINode
*
aTarget
)
;
void
ProcessFocusEvent
(
AccEvent
*
aEvent
)
;
protected
:
FocusManager
(
)
;
private
:
FocusManager
(
const
FocusManager
&
)
;
FocusManager
&
operator
=
(
const
FocusManager
&
)
;
nsINode
*
FocusedDOMNode
(
)
const
;
nsIDocument
*
FocusedDOMDocument
(
)
const
;
private
:
RefPtr
<
Accessible
>
mFocusedAcc
;
ProxyAccessible
*
mFocusedProxy
;
RefPtr
<
Accessible
>
mActiveItem
;
RefPtr
<
Accessible
>
mActiveARIAMenubar
;
}
;
}
}
#
endif
