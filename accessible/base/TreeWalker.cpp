#
include
"
TreeWalker
.
h
"
#
include
"
Accessible
.
h
"
#
include
"
AccIterator
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
DocAccessible
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
TreeWalker
:
:
TreeWalker
(
Accessible
*
aContext
)
:
mDoc
(
aContext
-
>
Document
(
)
)
mContext
(
aContext
)
mAnchorNode
(
nullptr
)
mARIAOwnsIdx
(
0
)
mChildFilter
(
nsIContent
:
:
eSkipPlaceholderContent
)
mFlags
(
0
)
mPhase
(
eAtStart
)
{
mChildFilter
|
=
mContext
-
>
NoXBLKids
(
)
?
nsIContent
:
:
eAllButXBL
:
nsIContent
:
:
eAllChildren
;
mAnchorNode
=
mContext
-
>
IsDoc
(
)
?
mDoc
-
>
DocumentNode
(
)
-
>
GetRootElement
(
)
:
mContext
-
>
GetContent
(
)
;
MOZ_COUNT_CTOR
(
TreeWalker
)
;
}
TreeWalker
:
:
TreeWalker
(
Accessible
*
aContext
nsIContent
*
aAnchorNode
uint32_t
aFlags
)
:
mDoc
(
aContext
-
>
Document
(
)
)
mContext
(
aContext
)
mAnchorNode
(
aAnchorNode
)
mARIAOwnsIdx
(
0
)
mChildFilter
(
nsIContent
:
:
eSkipPlaceholderContent
)
mFlags
(
aFlags
)
mPhase
(
eAtStart
)
{
MOZ_ASSERT
(
aAnchorNode
"
No
anchor
node
for
the
accessible
tree
walker
"
)
;
MOZ_ASSERT
(
mDoc
-
>
GetAccessibleOrContainer
(
aAnchorNode
)
=
=
mContext
"
Unexpected
anchor
node
was
given
"
)
;
mChildFilter
|
=
mContext
-
>
NoXBLKids
(
)
?
nsIContent
:
:
eAllButXBL
:
nsIContent
:
:
eAllChildren
;
MOZ_COUNT_CTOR
(
TreeWalker
)
;
}
TreeWalker
:
:
~
TreeWalker
(
)
{
MOZ_COUNT_DTOR
(
TreeWalker
)
;
}
Accessible
*
TreeWalker
:
:
Next
(
)
{
if
(
mStateStack
.
IsEmpty
(
)
)
{
if
(
mPhase
=
=
eAtEnd
)
{
return
nullptr
;
}
if
(
mPhase
=
=
eAtDOM
|
|
mPhase
=
=
eAtARIAOwns
)
{
mPhase
=
eAtARIAOwns
;
Accessible
*
child
=
mDoc
-
>
ARIAOwnedAt
(
mContext
mARIAOwnsIdx
)
;
if
(
child
)
{
mARIAOwnsIdx
+
+
;
return
child
;
}
mPhase
=
eAtEnd
;
return
nullptr
;
}
if
(
!
mAnchorNode
)
{
mPhase
=
eAtEnd
;
return
nullptr
;
}
mPhase
=
eAtDOM
;
PushState
(
mAnchorNode
true
)
;
}
dom
:
:
AllChildrenIterator
*
top
=
&
mStateStack
[
mStateStack
.
Length
(
)
-
1
]
;
while
(
top
)
{
while
(
nsIContent
*
childNode
=
top
-
>
GetNextChild
(
)
)
{
bool
skipSubtree
=
false
;
Accessible
*
child
=
nullptr
;
if
(
mFlags
&
eWalkCache
)
{
child
=
mDoc
-
>
GetAccessible
(
childNode
)
;
}
else
if
(
mContext
-
>
IsAcceptableChild
(
childNode
)
)
{
child
=
GetAccService
(
)
-
>
GetOrCreateAccessible
(
childNode
mContext
&
skipSubtree
)
;
}
if
(
child
)
{
if
(
child
-
>
IsRelocated
(
)
)
{
continue
;
}
return
child
;
}
if
(
!
skipSubtree
&
&
childNode
-
>
IsElement
(
)
)
{
top
=
PushState
(
childNode
true
)
;
}
}
top
=
PopState
(
)
;
}
if
(
mFlags
!
=
eWalkContextTree
)
return
Next
(
)
;
nsINode
*
contextNode
=
mContext
-
>
GetNode
(
)
;
while
(
mAnchorNode
!
=
contextNode
)
{
nsINode
*
parentNode
=
mAnchorNode
-
>
GetFlattenedTreeParent
(
)
;
if
(
!
parentNode
|
|
!
parentNode
-
>
IsElement
(
)
)
return
nullptr
;
nsIContent
*
parent
=
parentNode
-
>
AsElement
(
)
;
top
=
PushState
(
parent
true
)
;
if
(
top
-
>
Seek
(
mAnchorNode
)
)
{
mAnchorNode
=
parent
;
return
Next
(
)
;
}
mAnchorNode
=
parent
;
}
return
Next
(
)
;
}
Accessible
*
TreeWalker
:
:
Prev
(
)
{
if
(
mStateStack
.
IsEmpty
(
)
)
{
if
(
mPhase
=
=
eAtStart
|
|
mPhase
=
=
eAtDOM
)
{
mPhase
=
eAtStart
;
return
nullptr
;
}
if
(
mPhase
=
=
eAtEnd
)
{
mARIAOwnsIdx
=
mDoc
-
>
ARIAOwnedCount
(
mContext
)
;
mPhase
=
eAtARIAOwns
;
}
if
(
mPhase
=
=
eAtARIAOwns
)
{
if
(
mARIAOwnsIdx
>
0
)
{
return
mDoc
-
>
ARIAOwnedAt
(
mContext
-
-
mARIAOwnsIdx
)
;
}
if
(
!
mAnchorNode
)
{
mPhase
=
eAtStart
;
return
nullptr
;
}
mPhase
=
eAtDOM
;
PushState
(
mAnchorNode
false
)
;
}
}
dom
:
:
AllChildrenIterator
*
top
=
&
mStateStack
[
mStateStack
.
Length
(
)
-
1
]
;
while
(
top
)
{
while
(
nsIContent
*
childNode
=
top
-
>
GetPreviousChild
(
)
)
{
bool
skipSubtree
=
false
;
Accessible
*
child
=
mDoc
-
>
GetAccessible
(
childNode
)
;
if
(
child
)
{
if
(
child
-
>
IsRelocated
(
)
)
{
continue
;
}
return
child
;
}
if
(
!
skipSubtree
&
&
childNode
-
>
IsElement
(
)
)
{
top
=
PushState
(
childNode
true
)
;
}
}
top
=
PopState
(
)
;
}
if
(
mFlags
!
=
eWalkContextTree
)
{
mPhase
=
eAtStart
;
return
nullptr
;
}
nsINode
*
contextNode
=
mContext
-
>
GetNode
(
)
;
while
(
mAnchorNode
!
=
contextNode
)
{
nsINode
*
parentNode
=
mAnchorNode
-
>
GetFlattenedTreeParent
(
)
;
if
(
!
parentNode
|
|
!
parentNode
-
>
IsElement
(
)
)
{
return
nullptr
;
}
nsIContent
*
parent
=
parentNode
-
>
AsElement
(
)
;
top
=
PushState
(
parent
true
)
;
if
(
top
-
>
Seek
(
mAnchorNode
)
)
{
mAnchorNode
=
parent
;
return
Prev
(
)
;
}
mAnchorNode
=
parent
;
}
mPhase
=
eAtStart
;
return
nullptr
;
}
dom
:
:
AllChildrenIterator
*
TreeWalker
:
:
PopState
(
)
{
size_t
length
=
mStateStack
.
Length
(
)
;
mStateStack
.
RemoveElementAt
(
length
-
1
)
;
return
mStateStack
.
IsEmpty
(
)
?
nullptr
:
&
mStateStack
[
mStateStack
.
Length
(
)
-
1
]
;
}
