#
include
"
TreeWalker
.
h
"
#
include
"
ARIAMap
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
DocAccessible
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
namespace
mozilla
:
:
a11y
{
TreeWalker
:
:
TreeWalker
(
LocalAccessible
*
aContext
)
:
mDoc
(
aContext
-
>
Document
(
)
)
mContext
(
aContext
)
mAnchorNode
(
nullptr
)
mARIAOwnsIdx
(
0
)
mChildFilter
(
nsIContent
:
:
eSkipPlaceholderContent
)
mFlags
(
0
)
mPhase
(
eAtStart
)
{
mChildFilter
|
=
nsIContent
:
:
eAllChildren
;
mAnchorNode
=
mContext
-
>
IsDoc
(
)
?
mDoc
-
>
DocumentNode
(
)
-
>
GetRootElement
(
)
:
mContext
-
>
GetContent
(
)
;
MOZ_COUNT_CTOR
(
TreeWalker
)
;
}
TreeWalker
:
:
TreeWalker
(
LocalAccessible
*
aContext
nsIContent
*
aAnchorNode
uint32_t
aFlags
)
:
mDoc
(
aContext
-
>
Document
(
)
)
mContext
(
aContext
)
mAnchorNode
(
aAnchorNode
)
mARIAOwnsIdx
(
0
)
mChildFilter
(
nsIContent
:
:
eSkipPlaceholderContent
)
mFlags
(
aFlags
)
mPhase
(
eAtStart
)
{
MOZ_ASSERT
(
mFlags
&
eWalkCache
"
This
constructor
cannot
be
used
for
tree
creation
"
)
;
MOZ_ASSERT
(
aAnchorNode
"
No
anchor
node
for
the
accessible
tree
walker
"
)
;
mChildFilter
|
=
nsIContent
:
:
eAllChildren
;
MOZ_COUNT_CTOR
(
TreeWalker
)
;
}
TreeWalker
:
:
TreeWalker
(
DocAccessible
*
aDocument
nsIContent
*
aAnchorNode
)
:
mDoc
(
aDocument
)
mContext
(
nullptr
)
mAnchorNode
(
aAnchorNode
)
mARIAOwnsIdx
(
0
)
mChildFilter
(
nsIContent
:
:
eSkipPlaceholderContent
|
nsIContent
:
:
eAllChildren
)
mFlags
(
eWalkCache
)
mPhase
(
eAtStart
)
{
MOZ_ASSERT
(
aAnchorNode
"
No
anchor
node
for
the
accessible
tree
walker
"
)
;
MOZ_COUNT_CTOR
(
TreeWalker
)
;
}
TreeWalker
:
:
~
TreeWalker
(
)
{
MOZ_COUNT_DTOR
(
TreeWalker
)
;
}
LocalAccessible
*
TreeWalker
:
:
Scope
(
nsIContent
*
aAnchorNode
)
{
Reset
(
)
;
mAnchorNode
=
aAnchorNode
;
mFlags
|
=
eScoped
;
bool
skipSubtree
=
false
;
LocalAccessible
*
acc
=
AccessibleFor
(
aAnchorNode
0
&
skipSubtree
)
;
if
(
acc
)
{
mPhase
=
eAtEnd
;
return
acc
;
}
return
skipSubtree
?
nullptr
:
Next
(
)
;
}
bool
TreeWalker
:
:
Seek
(
nsIContent
*
aChildNode
)
{
MOZ_ASSERT
(
aChildNode
"
Child
cannot
be
null
"
)
;
Reset
(
)
;
if
(
mAnchorNode
=
=
aChildNode
)
{
return
true
;
}
nsIContent
*
childNode
=
nullptr
;
nsINode
*
parentNode
=
aChildNode
;
do
{
childNode
=
parentNode
-
>
AsContent
(
)
;
parentNode
=
childNode
-
>
GetFlattenedTreeParent
(
)
;
if
(
parentNode
&
&
parentNode
-
>
IsShadowRoot
(
)
)
{
parentNode
=
childNode
-
>
GetFlattenedTreeParent
(
)
;
if
(
parentNode
=
=
mAnchorNode
)
{
return
true
;
}
continue
;
}
if
(
!
parentNode
|
|
!
parentNode
-
>
IsElement
(
)
)
{
return
false
;
}
LocalAccessible
*
child
=
mDoc
-
>
GetAccessible
(
childNode
)
;
if
(
child
&
&
child
-
>
IsRelocated
(
)
)
{
MOZ_ASSERT
(
!
(
mFlags
&
eScoped
)
"
Walker
should
not
be
scoped
when
seeking
into
relocated
children
"
)
;
if
(
child
-
>
LocalParent
(
)
!
=
mContext
)
{
return
false
;
}
LocalAccessible
*
ownedChild
=
nullptr
;
while
(
(
ownedChild
=
mDoc
-
>
ARIAOwnedAt
(
mContext
mARIAOwnsIdx
+
+
)
)
&
&
ownedChild
!
=
child
)
{
;
}
MOZ_ASSERT
(
ownedChild
"
A
child
has
to
be
in
ARIA
owned
elements
"
)
;
mPhase
=
eAtARIAOwns
;
return
true
;
}
dom
:
:
AllChildrenIterator
*
iter
=
PrependState
(
parentNode
-
>
AsElement
(
)
true
)
;
if
(
!
iter
-
>
Seek
(
childNode
)
)
{
return
false
;
}
if
(
parentNode
=
=
mAnchorNode
)
{
mPhase
=
eAtDOM
;
return
true
;
}
}
while
(
true
)
;
MOZ_ASSERT_UNREACHABLE
(
"
because
the
do
-
while
loop
never
breaks
"
)
;
}
LocalAccessible
*
TreeWalker
:
:
Next
(
)
{
if
(
mStateStack
.
IsEmpty
(
)
)
{
if
(
mPhase
=
=
eAtEnd
)
{
return
nullptr
;
}
if
(
mPhase
=
=
eAtDOM
|
|
mPhase
=
=
eAtARIAOwns
)
{
if
(
!
(
mFlags
&
eScoped
)
)
{
mPhase
=
eAtARIAOwns
;
LocalAccessible
*
child
=
mDoc
-
>
ARIAOwnedAt
(
mContext
mARIAOwnsIdx
)
;
if
(
child
)
{
mARIAOwnsIdx
+
+
;
return
child
;
}
}
MOZ_ASSERT
(
!
(
mFlags
&
eScoped
)
|
|
mPhase
!
=
eAtARIAOwns
"
Don
'
t
walk
relocated
children
in
scoped
mode
"
)
;
mPhase
=
eAtEnd
;
return
nullptr
;
}
if
(
!
mAnchorNode
)
{
mPhase
=
eAtEnd
;
return
nullptr
;
}
mPhase
=
eAtDOM
;
PushState
(
mAnchorNode
true
)
;
}
dom
:
:
AllChildrenIterator
*
top
=
&
mStateStack
[
mStateStack
.
Length
(
)
-
1
]
;
while
(
top
)
{
while
(
nsIContent
*
childNode
=
top
-
>
GetNextChild
(
)
)
{
bool
skipSubtree
=
false
;
LocalAccessible
*
child
=
AccessibleFor
(
childNode
mFlags
&
skipSubtree
)
;
if
(
child
)
{
return
child
;
}
if
(
!
skipSubtree
&
&
childNode
-
>
IsElement
(
)
)
{
top
=
PushState
(
childNode
true
)
;
}
}
top
=
PopState
(
)
;
}
if
(
mFlags
!
=
eWalkContextTree
)
{
if
(
mFlags
&
eWalkCache
)
{
mPhase
=
eAtEnd
;
return
nullptr
;
}
return
Next
(
)
;
}
nsINode
*
contextNode
=
mContext
-
>
GetNode
(
)
;
while
(
mAnchorNode
!
=
contextNode
)
{
nsINode
*
parentNode
=
mAnchorNode
-
>
GetFlattenedTreeParent
(
)
;
if
(
!
parentNode
|
|
!
parentNode
-
>
IsElement
(
)
)
return
nullptr
;
nsIContent
*
parent
=
parentNode
-
>
AsElement
(
)
;
top
=
PushState
(
parent
true
)
;
if
(
top
-
>
Seek
(
mAnchorNode
)
)
{
mAnchorNode
=
parent
;
return
Next
(
)
;
}
mAnchorNode
=
parent
;
}
return
Next
(
)
;
}
LocalAccessible
*
TreeWalker
:
:
Prev
(
)
{
if
(
mStateStack
.
IsEmpty
(
)
)
{
if
(
mPhase
=
=
eAtStart
|
|
mPhase
=
=
eAtDOM
)
{
mPhase
=
eAtStart
;
return
nullptr
;
}
if
(
mPhase
=
=
eAtEnd
)
{
if
(
mFlags
&
eScoped
)
{
mPhase
=
eAtDOM
;
}
else
{
mPhase
=
eAtARIAOwns
;
mARIAOwnsIdx
=
mDoc
-
>
ARIAOwnedCount
(
mContext
)
;
}
}
if
(
mPhase
=
=
eAtARIAOwns
)
{
MOZ_ASSERT
(
!
(
mFlags
&
eScoped
)
"
Should
not
walk
relocated
children
in
scoped
mode
"
)
;
if
(
mARIAOwnsIdx
>
0
)
{
return
mDoc
-
>
ARIAOwnedAt
(
mContext
-
-
mARIAOwnsIdx
)
;
}
if
(
!
mAnchorNode
)
{
mPhase
=
eAtStart
;
return
nullptr
;
}
mPhase
=
eAtDOM
;
PushState
(
mAnchorNode
false
)
;
}
}
dom
:
:
AllChildrenIterator
*
top
=
&
mStateStack
[
mStateStack
.
Length
(
)
-
1
]
;
while
(
top
)
{
while
(
nsIContent
*
childNode
=
top
-
>
GetPreviousChild
(
)
)
{
bool
skipSubtree
=
false
;
LocalAccessible
*
child
=
AccessibleFor
(
childNode
eWalkCache
&
skipSubtree
)
;
if
(
child
)
{
return
child
;
}
if
(
!
skipSubtree
&
&
childNode
-
>
IsElement
(
)
)
{
top
=
PushState
(
childNode
false
)
;
}
}
top
=
PopState
(
)
;
}
if
(
mFlags
!
=
eWalkContextTree
)
{
mPhase
=
eAtStart
;
return
nullptr
;
}
nsINode
*
contextNode
=
mContext
-
>
GetNode
(
)
;
while
(
mAnchorNode
!
=
contextNode
)
{
nsINode
*
parentNode
=
mAnchorNode
-
>
GetFlattenedTreeParent
(
)
;
if
(
!
parentNode
|
|
!
parentNode
-
>
IsElement
(
)
)
{
return
nullptr
;
}
nsIContent
*
parent
=
parentNode
-
>
AsElement
(
)
;
top
=
PushState
(
parent
true
)
;
if
(
top
-
>
Seek
(
mAnchorNode
)
)
{
mAnchorNode
=
parent
;
return
Prev
(
)
;
}
mAnchorNode
=
parent
;
}
mPhase
=
eAtStart
;
return
nullptr
;
}
LocalAccessible
*
TreeWalker
:
:
AccessibleFor
(
nsIContent
*
aNode
uint32_t
aFlags
bool
*
aSkipSubtree
)
{
LocalAccessible
*
child
=
mDoc
-
>
GetAccessible
(
aNode
)
;
if
(
child
)
{
if
(
child
-
>
IsRelocated
(
)
)
{
*
aSkipSubtree
=
true
;
return
nullptr
;
}
return
child
;
}
if
(
!
(
aFlags
&
eWalkCache
)
&
&
mContext
-
>
IsAcceptableChild
(
aNode
)
&
&
!
aria
:
:
IsValidARIAHidden
(
mDoc
)
)
{
mDoc
-
>
RelocateARIAOwnedIfNeeded
(
aNode
)
;
return
GetAccService
(
)
-
>
CreateAccessible
(
aNode
mContext
aSkipSubtree
)
;
}
return
nullptr
;
}
dom
:
:
AllChildrenIterator
*
TreeWalker
:
:
PopState
(
)
{
mStateStack
.
RemoveLastElement
(
)
;
return
mStateStack
.
IsEmpty
(
)
?
nullptr
:
&
mStateStack
.
LastElement
(
)
;
}
}
