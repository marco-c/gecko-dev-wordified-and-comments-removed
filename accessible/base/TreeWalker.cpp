#
include
"
TreeWalker
.
h
"
#
include
"
Accessible
.
h
"
#
include
"
AccIterator
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
DocAccessible
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
TreeWalker
:
:
TreeWalker
(
Accessible
*
aContext
)
:
mDoc
(
aContext
-
>
Document
(
)
)
mContext
(
aContext
)
mAnchorNode
(
nullptr
)
mChildFilter
(
nsIContent
:
:
eSkipPlaceholderContent
)
mFlags
(
0
)
{
mChildFilter
|
=
mContext
-
>
NoXBLKids
(
)
?
nsIContent
:
:
eAllButXBL
:
nsIContent
:
:
eAllChildren
;
mAnchorNode
=
mContext
-
>
IsDoc
(
)
?
mDoc
-
>
DocumentNode
(
)
-
>
GetRootElement
(
)
:
mContext
-
>
GetContent
(
)
;
if
(
mAnchorNode
)
{
PushState
(
mAnchorNode
)
;
}
MOZ_COUNT_CTOR
(
TreeWalker
)
;
}
TreeWalker
:
:
TreeWalker
(
Accessible
*
aContext
nsIContent
*
aAnchorNode
uint32_t
aFlags
)
:
mDoc
(
aContext
-
>
Document
(
)
)
mContext
(
aContext
)
mAnchorNode
(
aAnchorNode
)
mChildFilter
(
nsIContent
:
:
eSkipPlaceholderContent
)
mFlags
(
aFlags
)
{
MOZ_ASSERT
(
aAnchorNode
"
No
anchor
node
for
the
accessible
tree
walker
"
)
;
mChildFilter
|
=
mContext
-
>
NoXBLKids
(
)
?
nsIContent
:
:
eAllButXBL
:
nsIContent
:
:
eAllChildren
;
PushState
(
aAnchorNode
)
;
MOZ_COUNT_CTOR
(
TreeWalker
)
;
}
TreeWalker
:
:
~
TreeWalker
(
)
{
MOZ_COUNT_DTOR
(
TreeWalker
)
;
}
Accessible
*
TreeWalker
:
:
Next
(
)
{
if
(
mStateStack
.
IsEmpty
(
)
)
return
nullptr
;
ChildrenIterator
*
top
=
&
mStateStack
[
mStateStack
.
Length
(
)
-
1
]
;
while
(
top
)
{
Accessible
*
child
=
nullptr
;
bool
skipSubtree
=
false
;
while
(
nsIContent
*
childNode
=
Next
(
top
&
child
&
skipSubtree
)
)
{
if
(
child
)
return
child
;
if
(
!
skipSubtree
&
&
childNode
-
>
IsElement
(
)
)
top
=
PushState
(
childNode
)
;
}
top
=
PopState
(
)
;
}
if
(
mFlags
!
=
eWalkContextTree
)
return
nullptr
;
nsINode
*
contextNode
=
mContext
-
>
GetNode
(
)
;
while
(
mAnchorNode
!
=
contextNode
)
{
nsINode
*
parentNode
=
mAnchorNode
-
>
GetFlattenedTreeParent
(
)
;
if
(
!
parentNode
|
|
!
parentNode
-
>
IsElement
(
)
)
return
nullptr
;
nsIContent
*
parent
=
parentNode
-
>
AsElement
(
)
;
top
=
PushState
(
parent
)
;
if
(
top
-
>
mDOMIter
.
Seek
(
mAnchorNode
)
)
{
mAnchorNode
=
parent
;
return
Next
(
)
;
}
mAnchorNode
=
parent
;
}
return
nullptr
;
}
nsIContent
*
TreeWalker
:
:
Next
(
ChildrenIterator
*
aIter
Accessible
*
*
aAccesible
bool
*
aSkipSubtree
)
{
nsIContent
*
childEl
=
aIter
-
>
mDOMIter
.
GetNextChild
(
)
;
if
(
!
aAccesible
)
return
childEl
;
*
aAccesible
=
nullptr
;
*
aSkipSubtree
=
false
;
if
(
childEl
)
{
Accessible
*
accessible
=
nullptr
;
if
(
mFlags
&
eWalkCache
)
{
accessible
=
mDoc
-
>
GetAccessible
(
childEl
)
;
}
else
if
(
mContext
-
>
IsAcceptableChild
(
childEl
)
)
{
accessible
=
GetAccService
(
)
-
>
GetOrCreateAccessible
(
childEl
mContext
aSkipSubtree
)
;
}
if
(
accessible
)
{
if
(
accessible
-
>
IsRelocated
(
)
)
{
*
aSkipSubtree
=
true
;
}
else
{
*
aAccesible
=
accessible
;
}
}
return
childEl
;
}
Accessible
*
parent
=
mDoc
-
>
GetAccessible
(
aIter
-
>
mDOMIter
.
Parent
(
)
)
;
if
(
parent
)
{
Accessible
*
child
=
mDoc
-
>
ARIAOwnedAt
(
parent
aIter
-
>
mARIAOwnsIdx
+
+
)
;
if
(
child
)
{
*
aAccesible
=
child
;
return
child
-
>
GetContent
(
)
;
}
}
return
nullptr
;
}
TreeWalker
:
:
ChildrenIterator
*
TreeWalker
:
:
PopState
(
)
{
size_t
length
=
mStateStack
.
Length
(
)
;
mStateStack
.
RemoveElementAt
(
length
-
1
)
;
return
mStateStack
.
IsEmpty
(
)
?
nullptr
:
&
mStateStack
[
mStateStack
.
Length
(
)
-
1
]
;
}
