#
include
"
EventQueue
.
h
"
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
DocAccessibleChild
.
h
"
#
include
"
nsTextEquivUtils
.
h
"
#
ifdef
A11Y_LOG
#
include
"
Logging
.
h
"
#
endif
#
include
"
Relation
.
h
"
namespace
mozilla
{
namespace
a11y
{
const
unsigned
int
kSelChangeCountToPack
=
5
;
bool
EventQueue
:
:
PushEvent
(
AccEvent
*
aEvent
)
{
NS_ASSERTION
(
(
aEvent
-
>
mAccessible
&
&
aEvent
-
>
mAccessible
-
>
IsApplication
(
)
)
|
|
aEvent
-
>
Document
(
)
=
=
mDocument
"
Queued
event
belongs
to
another
document
!
"
)
;
if
(
aEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_FOCUS
)
{
mFocusEvent
=
aEvent
;
return
true
;
}
mEvents
.
AppendElement
(
aEvent
)
;
CoalesceEvents
(
)
;
if
(
aEvent
-
>
mEventRule
!
=
AccEvent
:
:
eDoNotEmit
&
&
(
aEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
|
|
aEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_TEXT_REMOVED
|
|
aEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_TEXT_INSERTED
)
)
{
PushNameOrDescriptionChange
(
aEvent
)
;
}
return
true
;
}
bool
EventQueue
:
:
PushNameOrDescriptionChangeToRelations
(
LocalAccessible
*
aAccessible
RelationType
aType
)
{
MOZ_ASSERT
(
aType
=
=
RelationType
:
:
LABEL_FOR
|
|
RelationType
:
:
DESCRIPTION_FOR
)
;
bool
pushed
=
false
;
uint32_t
eventType
=
aType
=
=
RelationType
:
:
LABEL_FOR
?
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
:
nsIAccessibleEvent
:
:
EVENT_DESCRIPTION_CHANGE
;
Relation
rel
=
aAccessible
-
>
RelationByType
(
aType
)
;
while
(
LocalAccessible
*
relTarget
=
rel
.
LocalNext
(
)
)
{
RefPtr
<
AccEvent
>
nameChangeEvent
=
new
AccEvent
(
eventType
relTarget
)
;
pushed
|
=
PushEvent
(
nameChangeEvent
)
;
}
return
pushed
;
}
bool
EventQueue
:
:
PushNameOrDescriptionChange
(
AccEvent
*
aOrigEvent
)
{
LocalAccessible
*
target
=
aOrigEvent
-
>
mAccessible
;
const
bool
maybeTargetNameChanged
=
(
aOrigEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_TEXT_REMOVED
|
|
aOrigEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_TEXT_INSERTED
|
|
aOrigEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_REORDER
|
|
aOrigEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_INNER_REORDER
)
&
&
nsTextEquivUtils
:
:
HasNameRule
(
target
eNameFromSubtreeRule
)
;
const
bool
doName
=
target
-
>
HasNameDependent
(
)
|
|
maybeTargetNameChanged
;
const
bool
doDesc
=
target
-
>
HasDescriptionDependent
(
)
;
if
(
!
doName
&
&
!
doDesc
)
{
return
false
;
}
bool
pushed
=
false
;
bool
nameCheckAncestor
=
true
;
LocalAccessible
*
parent
=
target
;
do
{
if
(
doName
)
{
if
(
nameCheckAncestor
&
&
(
maybeTargetNameChanged
|
|
parent
!
=
target
)
&
&
nsTextEquivUtils
:
:
HasNameRule
(
parent
eNameFromSubtreeRule
)
)
{
bool
fireNameChange
=
parent
-
>
IsHTMLFileInput
(
)
;
if
(
!
fireNameChange
)
{
nsAutoString
name
;
ENameValueFlag
nameFlag
=
parent
-
>
Name
(
name
)
;
switch
(
nameFlag
)
{
case
eNameOK
:
fireNameChange
=
name
.
IsVoid
(
)
;
break
;
case
eNameFromSubtree
:
fireNameChange
=
true
;
break
;
case
eNameFromTooltip
:
fireNameChange
=
true
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
All
name
flags
not
covered
!
"
)
;
}
}
if
(
fireNameChange
)
{
RefPtr
<
AccEvent
>
nameChangeEvent
=
new
AccEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
parent
)
;
pushed
|
=
PushEvent
(
nameChangeEvent
)
;
}
nameCheckAncestor
=
false
;
}
pushed
|
=
PushNameOrDescriptionChangeToRelations
(
parent
RelationType
:
:
LABEL_FOR
)
;
}
if
(
doDesc
)
{
pushed
|
=
PushNameOrDescriptionChangeToRelations
(
parent
RelationType
:
:
DESCRIPTION_FOR
)
;
}
if
(
parent
-
>
IsDoc
(
)
)
{
break
;
}
parent
=
parent
-
>
LocalParent
(
)
;
}
while
(
parent
&
&
nsTextEquivUtils
:
:
HasNameRule
(
parent
eNameFromSubtreeIfReqRule
)
)
;
return
pushed
;
}
void
EventQueue
:
:
CoalesceEvents
(
)
{
NS_ASSERTION
(
mEvents
.
Length
(
)
"
There
should
be
at
least
one
pending
event
!
"
)
;
uint32_t
tail
=
mEvents
.
Length
(
)
-
1
;
AccEvent
*
tailEvent
=
mEvents
[
tail
]
;
switch
(
tailEvent
-
>
mEventRule
)
{
case
AccEvent
:
:
eCoalesceReorder
:
{
DebugOnly
<
LocalAccessible
*
>
target
=
tailEvent
-
>
mAccessible
.
get
(
)
;
MOZ_ASSERT
(
target
-
>
IsApplication
(
)
|
|
target
-
>
IsOuterDoc
(
)
|
|
target
-
>
IsXULTree
(
)
"
Only
app
or
outerdoc
accessible
reorder
events
are
in
the
queue
"
)
;
MOZ_ASSERT
(
tailEvent
-
>
GetEventType
(
)
=
=
nsIAccessibleEvent
:
:
EVENT_REORDER
"
only
reorder
events
should
be
queued
"
)
;
break
;
}
case
AccEvent
:
:
eCoalesceOfSameType
:
{
for
(
uint32_t
index
=
tail
-
1
;
index
<
tail
;
index
-
-
)
{
AccEvent
*
accEvent
=
mEvents
[
index
]
;
if
(
accEvent
-
>
mEventType
=
=
tailEvent
-
>
mEventType
&
&
accEvent
-
>
mEventRule
=
=
tailEvent
-
>
mEventRule
)
{
accEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
return
;
}
}
break
;
}
case
AccEvent
:
:
eCoalesceSelectionChange
:
{
AccSelChangeEvent
*
tailSelChangeEvent
=
downcast_accEvent
(
tailEvent
)
;
for
(
uint32_t
index
=
tail
-
1
;
index
<
tail
;
index
-
-
)
{
AccEvent
*
thisEvent
=
mEvents
[
index
]
;
if
(
thisEvent
-
>
mEventRule
=
=
tailEvent
-
>
mEventRule
)
{
AccSelChangeEvent
*
thisSelChangeEvent
=
downcast_accEvent
(
thisEvent
)
;
if
(
tailSelChangeEvent
-
>
mWidget
=
=
thisSelChangeEvent
-
>
mWidget
)
{
CoalesceSelChangeEvents
(
tailSelChangeEvent
thisSelChangeEvent
index
)
;
return
;
}
}
}
break
;
}
case
AccEvent
:
:
eCoalesceStateChange
:
{
for
(
uint32_t
index
=
tail
-
1
;
index
<
tail
;
index
-
-
)
{
AccEvent
*
thisEvent
=
mEvents
[
index
]
;
if
(
thisEvent
-
>
mEventRule
!
=
AccEvent
:
:
eDoNotEmit
&
&
thisEvent
-
>
mEventType
=
=
tailEvent
-
>
mEventType
&
&
thisEvent
-
>
mAccessible
=
=
tailEvent
-
>
mAccessible
)
{
AccStateChangeEvent
*
thisSCEvent
=
downcast_accEvent
(
thisEvent
)
;
AccStateChangeEvent
*
tailSCEvent
=
downcast_accEvent
(
tailEvent
)
;
if
(
thisSCEvent
-
>
mState
=
=
tailSCEvent
-
>
mState
)
{
thisEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
if
(
thisSCEvent
-
>
mIsEnabled
!
=
tailSCEvent
-
>
mIsEnabled
)
{
tailEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
}
}
}
}
break
;
}
case
AccEvent
:
:
eCoalesceTextSelChange
:
{
for
(
uint32_t
index
=
tail
-
1
;
index
<
tail
;
index
-
-
)
{
AccEvent
*
thisEvent
=
mEvents
[
index
]
;
if
(
thisEvent
-
>
mEventRule
!
=
AccEvent
:
:
eDoNotEmit
&
&
thisEvent
-
>
mEventType
=
=
tailEvent
-
>
mEventType
)
{
AccTextSelChangeEvent
*
thisTSCEvent
=
downcast_accEvent
(
thisEvent
)
;
AccTextSelChangeEvent
*
tailTSCEvent
=
downcast_accEvent
(
tailEvent
)
;
if
(
thisTSCEvent
-
>
mSel
=
=
tailTSCEvent
-
>
mSel
|
|
thisEvent
-
>
mAccessible
=
=
tailEvent
-
>
mAccessible
)
{
thisEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
}
}
}
break
;
}
case
AccEvent
:
:
eRemoveDupes
:
{
for
(
uint32_t
index
=
tail
-
1
;
index
<
tail
;
index
-
-
)
{
AccEvent
*
accEvent
=
mEvents
[
index
]
;
if
(
accEvent
-
>
mEventType
=
=
tailEvent
-
>
mEventType
&
&
accEvent
-
>
mEventRule
=
=
tailEvent
-
>
mEventRule
&
&
accEvent
-
>
mAccessible
=
=
tailEvent
-
>
mAccessible
)
{
tailEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
return
;
}
}
break
;
}
default
:
break
;
}
}
void
EventQueue
:
:
CoalesceSelChangeEvents
(
AccSelChangeEvent
*
aTailEvent
AccSelChangeEvent
*
aThisEvent
uint32_t
aThisIndex
)
{
aTailEvent
-
>
mPreceedingCount
=
aThisEvent
-
>
mPreceedingCount
+
1
;
if
(
aTailEvent
-
>
mPreceedingCount
>
=
kSelChangeCountToPack
)
{
aTailEvent
-
>
mEventType
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_WITHIN
;
aTailEvent
-
>
mAccessible
=
aTailEvent
-
>
mWidget
;
aThisEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
if
(
aThisEvent
-
>
mEventType
!
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_WITHIN
)
{
for
(
uint32_t
jdx
=
aThisIndex
-
1
;
jdx
<
aThisIndex
;
jdx
-
-
)
{
AccEvent
*
prevEvent
=
mEvents
[
jdx
]
;
if
(
prevEvent
-
>
mEventRule
=
=
aTailEvent
-
>
mEventRule
)
{
AccSelChangeEvent
*
prevSelChangeEvent
=
downcast_accEvent
(
prevEvent
)
;
if
(
prevSelChangeEvent
-
>
mWidget
=
=
aTailEvent
-
>
mWidget
)
{
prevSelChangeEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
}
}
}
}
return
;
}
if
(
aTailEvent
-
>
mPreceedingCount
=
=
1
&
&
aTailEvent
-
>
mItem
!
=
aThisEvent
-
>
mItem
)
{
if
(
aTailEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
&
&
aThisEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionRemove
)
{
aThisEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
aTailEvent
-
>
mEventType
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
;
aTailEvent
-
>
mPackedEvent
=
aThisEvent
;
return
;
}
if
(
aThisEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
&
&
aTailEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionRemove
)
{
aTailEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
aThisEvent
-
>
mEventType
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
;
aThisEvent
-
>
mPackedEvent
=
aTailEvent
;
return
;
}
}
if
(
aThisEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
)
{
if
(
aThisEvent
-
>
mPackedEvent
)
{
aThisEvent
-
>
mPackedEvent
-
>
mEventType
=
aThisEvent
-
>
mPackedEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
?
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
:
nsIAccessibleEvent
:
:
EVENT_SELECTION_REMOVE
;
aThisEvent
-
>
mPackedEvent
-
>
mEventRule
=
AccEvent
:
:
eCoalesceSelectionChange
;
aThisEvent
-
>
mPackedEvent
=
nullptr
;
}
aThisEvent
-
>
mEventType
=
aThisEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
?
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
:
nsIAccessibleEvent
:
:
EVENT_SELECTION_REMOVE
;
return
;
}
if
(
aTailEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
)
{
aTailEvent
-
>
mEventType
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
;
}
}
void
EventQueue
:
:
ProcessEventQueue
(
)
{
const
nsTArray
<
RefPtr
<
AccEvent
>
>
events
=
std
:
:
move
(
mEvents
)
;
nsTArray
<
uint64_t
>
selectedIDs
;
nsTArray
<
uint64_t
>
unselectedIDs
;
uint32_t
eventCount
=
events
.
Length
(
)
;
#
ifdef
A11Y_LOG
if
(
(
eventCount
>
0
|
|
mFocusEvent
)
&
&
logging
:
:
IsEnabled
(
logging
:
:
eEvents
)
)
{
logging
:
:
MsgBegin
(
"
EVENTS
"
"
events
processing
"
)
;
logging
:
:
Address
(
"
document
"
mDocument
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
if
(
mFocusEvent
)
{
RefPtr
<
AccEvent
>
event
=
std
:
:
move
(
mFocusEvent
)
;
if
(
!
event
-
>
mAccessible
-
>
IsDefunct
(
)
)
{
FocusMgr
(
)
-
>
ProcessFocusEvent
(
event
)
;
}
}
for
(
uint32_t
idx
=
0
;
idx
<
eventCount
;
idx
+
+
)
{
AccEvent
*
event
=
events
[
idx
]
;
uint32_t
eventType
=
event
-
>
mEventType
;
LocalAccessible
*
target
=
event
-
>
GetAccessible
(
)
;
if
(
!
target
|
|
target
-
>
IsDefunct
(
)
)
{
continue
;
}
if
(
IPCAccessibilityActive
(
)
)
{
if
(
(
event
-
>
mEventRule
=
=
AccEvent
:
:
eDoNotEmit
&
&
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
|
|
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_REMOVE
|
|
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
)
)
|
|
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_WITHIN
)
{
AccSelChangeEvent
*
selChangeEvent
=
downcast_accEvent
(
event
)
;
LocalAccessible
*
item
=
selChangeEvent
-
>
mItem
;
if
(
!
item
-
>
IsDefunct
(
)
)
{
uint64_t
itemID
=
item
-
>
IsDoc
(
)
?
0
:
reinterpret_cast
<
uint64_t
>
(
item
-
>
UniqueID
(
)
)
;
bool
selected
=
selChangeEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
;
if
(
selected
)
{
selectedIDs
.
AppendElement
(
itemID
)
;
}
else
{
unselectedIDs
.
AppendElement
(
itemID
)
;
}
}
}
}
if
(
event
-
>
mEventRule
=
=
AccEvent
:
:
eDoNotEmit
)
{
continue
;
}
if
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_TEXT_SELECTION_CHANGED
)
{
SelectionMgr
(
)
-
>
ProcessTextSelChangeEvent
(
event
)
;
continue
;
}
if
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
)
{
nsEventShell
:
:
FireEvent
(
event
-
>
mAccessible
states
:
:
SELECTED
true
event
-
>
mIsFromUserInput
)
;
}
else
if
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_REMOVE
)
{
nsEventShell
:
:
FireEvent
(
event
-
>
mAccessible
states
:
:
SELECTED
false
event
-
>
mIsFromUserInput
)
;
}
else
if
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
)
{
AccSelChangeEvent
*
selChangeEvent
=
downcast_accEvent
(
event
)
;
nsEventShell
:
:
FireEvent
(
event
-
>
mAccessible
states
:
:
SELECTED
(
selChangeEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
)
event
-
>
mIsFromUserInput
)
;
if
(
selChangeEvent
-
>
mPackedEvent
)
{
nsEventShell
:
:
FireEvent
(
selChangeEvent
-
>
mPackedEvent
-
>
mAccessible
states
:
:
SELECTED
(
selChangeEvent
-
>
mPackedEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
)
selChangeEvent
-
>
mPackedEvent
-
>
mIsFromUserInput
)
;
}
}
nsEventShell
:
:
FireEvent
(
event
)
;
if
(
!
mDocument
)
{
return
;
}
}
if
(
mDocument
&
&
IPCAccessibilityActive
(
)
&
&
(
!
selectedIDs
.
IsEmpty
(
)
|
|
!
unselectedIDs
.
IsEmpty
(
)
)
)
{
DocAccessibleChild
*
ipcDoc
=
mDocument
-
>
IPCDoc
(
)
;
ipcDoc
-
>
SendSelectedAccessiblesChanged
(
selectedIDs
unselectedIDs
)
;
}
}
}
}
