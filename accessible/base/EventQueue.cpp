#
include
"
EventQueue
.
h
"
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
DocAccessible
.
h
"
#
include
"
DocAccessibleChild
.
h
"
#
include
"
mozilla
/
StaticPrefs_accessibility
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
nsTextEquivUtils
.
h
"
#
ifdef
A11Y_LOG
#
include
"
Logging
.
h
"
#
endif
#
include
"
Relation
.
h
"
namespace
mozilla
{
namespace
a11y
{
const
unsigned
int
kSelChangeCountToPack
=
5
;
bool
EventQueue
:
:
PushEvent
(
AccEvent
*
aEvent
)
{
NS_ASSERTION
(
(
aEvent
-
>
mAccessible
&
&
aEvent
-
>
mAccessible
-
>
IsApplication
(
)
)
|
|
aEvent
-
>
Document
(
)
=
=
mDocument
"
Queued
event
belongs
to
another
document
!
"
)
;
if
(
aEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_FOCUS
)
{
mFocusEvent
=
aEvent
;
return
true
;
}
mEvents
.
AppendElement
(
aEvent
)
;
CoalesceEvents
(
)
;
if
(
aEvent
-
>
mEventRule
!
=
AccEvent
:
:
eDoNotEmit
&
&
(
aEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
|
|
aEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_TEXT_REMOVED
|
|
aEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_TEXT_INSERTED
)
)
{
PushNameOrDescriptionChange
(
aEvent
-
>
mAccessible
)
;
}
return
true
;
}
bool
EventQueue
:
:
PushNameOrDescriptionChange
(
LocalAccessible
*
aTarget
)
{
const
bool
doName
=
aTarget
-
>
HasNameDependent
(
)
;
const
bool
doDesc
=
aTarget
-
>
HasDescriptionDependent
(
)
;
if
(
!
doName
&
&
!
doDesc
)
{
return
false
;
}
bool
pushed
=
false
;
bool
nameCheckAncestor
=
true
;
LocalAccessible
*
parent
=
aTarget
;
do
{
if
(
doName
)
{
if
(
nameCheckAncestor
&
&
parent
!
=
aTarget
&
&
nsTextEquivUtils
:
:
HasNameRule
(
parent
eNameFromSubtreeRule
)
)
{
nsAutoString
name
;
ENameValueFlag
nameFlag
=
parent
-
>
Name
(
name
)
;
if
(
nameFlag
=
=
eNameFromSubtree
)
{
RefPtr
<
AccEvent
>
nameChangeEvent
=
new
AccEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
parent
)
;
pushed
|
=
PushEvent
(
nameChangeEvent
)
;
}
nameCheckAncestor
=
false
;
}
Relation
rel
=
parent
-
>
RelationByType
(
RelationType
:
:
LABEL_FOR
)
;
while
(
LocalAccessible
*
relTarget
=
rel
.
LocalNext
(
)
)
{
RefPtr
<
AccEvent
>
nameChangeEvent
=
new
AccEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
relTarget
)
;
pushed
|
=
PushEvent
(
nameChangeEvent
)
;
}
}
if
(
doDesc
)
{
Relation
rel
=
parent
-
>
RelationByType
(
RelationType
:
:
DESCRIPTION_FOR
)
;
while
(
LocalAccessible
*
relTarget
=
rel
.
LocalNext
(
)
)
{
RefPtr
<
AccEvent
>
descChangeEvent
=
new
AccEvent
(
nsIAccessibleEvent
:
:
EVENT_DESCRIPTION_CHANGE
relTarget
)
;
pushed
|
=
PushEvent
(
descChangeEvent
)
;
}
}
parent
=
parent
-
>
LocalParent
(
)
;
}
while
(
parent
&
&
nsTextEquivUtils
:
:
HasNameRule
(
parent
eNameFromSubtreeIfReqRule
)
)
;
return
pushed
;
}
void
EventQueue
:
:
CoalesceEvents
(
)
{
NS_ASSERTION
(
mEvents
.
Length
(
)
"
There
should
be
at
least
one
pending
event
!
"
)
;
uint32_t
tail
=
mEvents
.
Length
(
)
-
1
;
AccEvent
*
tailEvent
=
mEvents
[
tail
]
;
switch
(
tailEvent
-
>
mEventRule
)
{
case
AccEvent
:
:
eCoalesceReorder
:
{
DebugOnly
<
LocalAccessible
*
>
target
=
tailEvent
-
>
mAccessible
.
get
(
)
;
MOZ_ASSERT
(
target
-
>
IsApplication
(
)
|
|
target
-
>
IsOuterDoc
(
)
|
|
target
-
>
IsXULTree
(
)
"
Only
app
or
outerdoc
accessible
reorder
events
are
in
the
queue
"
)
;
MOZ_ASSERT
(
tailEvent
-
>
GetEventType
(
)
=
=
nsIAccessibleEvent
:
:
EVENT_REORDER
"
only
reorder
events
should
be
queued
"
)
;
break
;
}
case
AccEvent
:
:
eCoalesceOfSameType
:
{
for
(
uint32_t
index
=
tail
-
1
;
index
<
tail
;
index
-
-
)
{
AccEvent
*
accEvent
=
mEvents
[
index
]
;
if
(
accEvent
-
>
mEventType
=
=
tailEvent
-
>
mEventType
&
&
accEvent
-
>
mEventRule
=
=
tailEvent
-
>
mEventRule
)
{
accEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
return
;
}
}
break
;
}
case
AccEvent
:
:
eCoalesceSelectionChange
:
{
AccSelChangeEvent
*
tailSelChangeEvent
=
downcast_accEvent
(
tailEvent
)
;
for
(
uint32_t
index
=
tail
-
1
;
index
<
tail
;
index
-
-
)
{
AccEvent
*
thisEvent
=
mEvents
[
index
]
;
if
(
thisEvent
-
>
mEventRule
=
=
tailEvent
-
>
mEventRule
)
{
AccSelChangeEvent
*
thisSelChangeEvent
=
downcast_accEvent
(
thisEvent
)
;
if
(
tailSelChangeEvent
-
>
mWidget
=
=
thisSelChangeEvent
-
>
mWidget
)
{
CoalesceSelChangeEvents
(
tailSelChangeEvent
thisSelChangeEvent
index
)
;
return
;
}
}
}
break
;
}
case
AccEvent
:
:
eCoalesceStateChange
:
{
for
(
uint32_t
index
=
tail
-
1
;
index
<
tail
;
index
-
-
)
{
AccEvent
*
thisEvent
=
mEvents
[
index
]
;
if
(
thisEvent
-
>
mEventRule
!
=
AccEvent
:
:
eDoNotEmit
&
&
thisEvent
-
>
mEventType
=
=
tailEvent
-
>
mEventType
&
&
thisEvent
-
>
mAccessible
=
=
tailEvent
-
>
mAccessible
)
{
AccStateChangeEvent
*
thisSCEvent
=
downcast_accEvent
(
thisEvent
)
;
AccStateChangeEvent
*
tailSCEvent
=
downcast_accEvent
(
tailEvent
)
;
if
(
thisSCEvent
-
>
mState
=
=
tailSCEvent
-
>
mState
)
{
thisEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
if
(
thisSCEvent
-
>
mIsEnabled
!
=
tailSCEvent
-
>
mIsEnabled
)
{
tailEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
}
}
}
}
break
;
}
case
AccEvent
:
:
eCoalesceTextSelChange
:
{
for
(
uint32_t
index
=
tail
-
1
;
index
<
tail
;
index
-
-
)
{
AccEvent
*
thisEvent
=
mEvents
[
index
]
;
if
(
thisEvent
-
>
mEventRule
!
=
AccEvent
:
:
eDoNotEmit
&
&
thisEvent
-
>
mEventType
=
=
tailEvent
-
>
mEventType
)
{
AccTextSelChangeEvent
*
thisTSCEvent
=
downcast_accEvent
(
thisEvent
)
;
AccTextSelChangeEvent
*
tailTSCEvent
=
downcast_accEvent
(
tailEvent
)
;
if
(
thisTSCEvent
-
>
mSel
=
=
tailTSCEvent
-
>
mSel
|
|
thisEvent
-
>
mAccessible
=
=
tailEvent
-
>
mAccessible
)
{
thisEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
}
}
}
break
;
}
case
AccEvent
:
:
eRemoveDupes
:
{
for
(
uint32_t
index
=
tail
-
1
;
index
<
tail
;
index
-
-
)
{
AccEvent
*
accEvent
=
mEvents
[
index
]
;
if
(
accEvent
-
>
mEventType
=
=
tailEvent
-
>
mEventType
&
&
accEvent
-
>
mEventRule
=
=
tailEvent
-
>
mEventRule
&
&
accEvent
-
>
mAccessible
=
=
tailEvent
-
>
mAccessible
)
{
tailEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
return
;
}
}
break
;
}
default
:
break
;
}
}
void
EventQueue
:
:
CoalesceSelChangeEvents
(
AccSelChangeEvent
*
aTailEvent
AccSelChangeEvent
*
aThisEvent
uint32_t
aThisIndex
)
{
aTailEvent
-
>
mPreceedingCount
=
aThisEvent
-
>
mPreceedingCount
+
1
;
if
(
aTailEvent
-
>
mPreceedingCount
>
=
kSelChangeCountToPack
)
{
aTailEvent
-
>
mEventType
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_WITHIN
;
aTailEvent
-
>
mAccessible
=
aTailEvent
-
>
mWidget
;
aThisEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
if
(
aThisEvent
-
>
mEventType
!
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_WITHIN
)
{
for
(
uint32_t
jdx
=
aThisIndex
-
1
;
jdx
<
aThisIndex
;
jdx
-
-
)
{
AccEvent
*
prevEvent
=
mEvents
[
jdx
]
;
if
(
prevEvent
-
>
mEventRule
=
=
aTailEvent
-
>
mEventRule
)
{
AccSelChangeEvent
*
prevSelChangeEvent
=
downcast_accEvent
(
prevEvent
)
;
if
(
prevSelChangeEvent
-
>
mWidget
=
=
aTailEvent
-
>
mWidget
)
{
prevSelChangeEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
}
}
}
}
return
;
}
if
(
aTailEvent
-
>
mPreceedingCount
=
=
1
&
&
aTailEvent
-
>
mItem
!
=
aThisEvent
-
>
mItem
)
{
if
(
aTailEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
&
&
aThisEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionRemove
)
{
aThisEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
aTailEvent
-
>
mEventType
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
;
aTailEvent
-
>
mPackedEvent
=
aThisEvent
;
return
;
}
if
(
aThisEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
&
&
aTailEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionRemove
)
{
aTailEvent
-
>
mEventRule
=
AccEvent
:
:
eDoNotEmit
;
aThisEvent
-
>
mEventType
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
;
aThisEvent
-
>
mPackedEvent
=
aTailEvent
;
return
;
}
}
if
(
aThisEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
)
{
if
(
aThisEvent
-
>
mPackedEvent
)
{
aThisEvent
-
>
mPackedEvent
-
>
mEventType
=
aThisEvent
-
>
mPackedEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
?
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
:
nsIAccessibleEvent
:
:
EVENT_SELECTION_REMOVE
;
aThisEvent
-
>
mPackedEvent
-
>
mEventRule
=
AccEvent
:
:
eCoalesceSelectionChange
;
aThisEvent
-
>
mPackedEvent
=
nullptr
;
}
aThisEvent
-
>
mEventType
=
aThisEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
?
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
:
nsIAccessibleEvent
:
:
EVENT_SELECTION_REMOVE
;
return
;
}
if
(
aTailEvent
-
>
mEventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
)
{
aTailEvent
-
>
mEventType
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
;
}
}
void
EventQueue
:
:
ProcessEventQueue
(
)
{
const
nsTArray
<
RefPtr
<
AccEvent
>
>
events
=
std
:
:
move
(
mEvents
)
;
nsTArray
<
uint64_t
>
selectedIDs
;
nsTArray
<
uint64_t
>
unselectedIDs
;
uint32_t
eventCount
=
events
.
Length
(
)
;
#
ifdef
A11Y_LOG
if
(
(
eventCount
>
0
|
|
mFocusEvent
)
&
&
logging
:
:
IsEnabled
(
logging
:
:
eEvents
)
)
{
logging
:
:
MsgBegin
(
"
EVENTS
"
"
events
processing
"
)
;
logging
:
:
Address
(
"
document
"
mDocument
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
if
(
mFocusEvent
)
{
RefPtr
<
AccEvent
>
event
=
std
:
:
move
(
mFocusEvent
)
;
if
(
!
event
-
>
mAccessible
-
>
IsDefunct
(
)
)
{
FocusMgr
(
)
-
>
ProcessFocusEvent
(
event
)
;
}
}
for
(
uint32_t
idx
=
0
;
idx
<
eventCount
;
idx
+
+
)
{
AccEvent
*
event
=
events
[
idx
]
;
uint32_t
eventType
=
event
-
>
mEventType
;
LocalAccessible
*
target
=
event
-
>
GetAccessible
(
)
;
if
(
!
target
|
|
target
-
>
IsDefunct
(
)
)
continue
;
if
(
IPCAccessibilityActive
(
)
&
&
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
{
if
(
(
event
-
>
mEventRule
=
=
AccEvent
:
:
eDoNotEmit
&
&
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
|
|
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_REMOVE
|
|
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
)
)
|
|
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_WITHIN
)
{
AccSelChangeEvent
*
selChangeEvent
=
downcast_accEvent
(
event
)
;
LocalAccessible
*
item
=
selChangeEvent
-
>
mItem
;
uint64_t
itemID
=
item
-
>
IsDoc
(
)
?
0
:
reinterpret_cast
<
uint64_t
>
(
item
-
>
UniqueID
(
)
)
;
bool
selected
=
selChangeEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
;
if
(
selected
)
{
selectedIDs
.
AppendElement
(
itemID
)
;
}
else
{
unselectedIDs
.
AppendElement
(
itemID
)
;
}
}
}
if
(
event
-
>
mEventRule
=
=
AccEvent
:
:
eDoNotEmit
)
{
continue
;
}
if
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_TEXT_SELECTION_CHANGED
)
{
SelectionMgr
(
)
-
>
ProcessTextSelChangeEvent
(
event
)
;
continue
;
}
if
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
)
{
nsEventShell
:
:
FireEvent
(
event
-
>
mAccessible
states
:
:
SELECTED
true
event
-
>
mIsFromUserInput
)
;
}
else
if
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_REMOVE
)
{
nsEventShell
:
:
FireEvent
(
event
-
>
mAccessible
states
:
:
SELECTED
false
event
-
>
mIsFromUserInput
)
;
}
else
if
(
eventType
=
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
)
{
AccSelChangeEvent
*
selChangeEvent
=
downcast_accEvent
(
event
)
;
nsEventShell
:
:
FireEvent
(
event
-
>
mAccessible
states
:
:
SELECTED
(
selChangeEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
)
event
-
>
mIsFromUserInput
)
;
if
(
selChangeEvent
-
>
mPackedEvent
)
{
nsEventShell
:
:
FireEvent
(
selChangeEvent
-
>
mPackedEvent
-
>
mAccessible
states
:
:
SELECTED
(
selChangeEvent
-
>
mPackedEvent
-
>
mSelChangeType
=
=
AccSelChangeEvent
:
:
eSelectionAdd
)
selChangeEvent
-
>
mPackedEvent
-
>
mIsFromUserInput
)
;
}
}
nsEventShell
:
:
FireEvent
(
event
)
;
if
(
!
mDocument
)
return
;
}
if
(
mDocument
&
&
IPCAccessibilityActive
(
)
&
&
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
&
&
(
!
selectedIDs
.
IsEmpty
(
)
|
|
!
unselectedIDs
.
IsEmpty
(
)
)
)
{
DocAccessibleChild
*
ipcDoc
=
mDocument
-
>
IPCDoc
(
)
;
ipcDoc
-
>
SendSelectedAccessiblesChanged
(
selectedIDs
unselectedIDs
)
;
}
}
}
}
