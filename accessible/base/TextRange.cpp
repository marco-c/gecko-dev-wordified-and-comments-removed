#
include
"
TextRange
-
inl
.
h
"
#
include
"
LocalAccessible
-
inl
.
h
"
#
include
"
HyperTextAccessible
-
inl
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAccUtils
.
h
"
namespace
mozilla
{
namespace
a11y
{
static
void
ToTextPoint
(
Accessible
*
aAcc
Accessible
*
*
aContainer
int32_t
*
aOffset
bool
aIsBefore
=
true
)
{
if
(
aAcc
-
>
IsHyperText
(
)
)
{
*
aContainer
=
aAcc
;
*
aOffset
=
aIsBefore
?
0
:
static_cast
<
int32_t
>
(
aAcc
-
>
AsHyperTextBase
(
)
-
>
CharacterCount
(
)
)
;
return
;
}
Accessible
*
child
=
nullptr
;
Accessible
*
parent
=
aAcc
;
do
{
child
=
parent
;
parent
=
parent
-
>
Parent
(
)
;
}
while
(
parent
&
&
!
parent
-
>
IsHyperText
(
)
)
;
if
(
parent
)
{
*
aContainer
=
parent
;
*
aOffset
=
parent
-
>
AsHyperTextBase
(
)
-
>
GetChildOffset
(
child
-
>
IndexInParent
(
)
+
static_cast
<
int32_t
>
(
!
aIsBefore
)
)
;
}
}
bool
TextPoint
:
:
operator
<
(
const
TextPoint
&
aPoint
)
const
{
if
(
mContainer
=
=
aPoint
.
mContainer
)
return
mOffset
<
aPoint
.
mOffset
;
Accessible
*
p1
=
mContainer
;
Accessible
*
p2
=
aPoint
.
mContainer
;
AutoTArray
<
Accessible
*
30
>
parents1
parents2
;
do
{
parents1
.
AppendElement
(
p1
)
;
p1
=
p1
-
>
Parent
(
)
;
}
while
(
p1
)
;
do
{
parents2
.
AppendElement
(
p2
)
;
p2
=
p2
-
>
Parent
(
)
;
}
while
(
p2
)
;
uint32_t
pos1
=
parents1
.
Length
(
)
pos2
=
parents2
.
Length
(
)
;
for
(
uint32_t
len
=
std
:
:
min
(
pos1
pos2
)
;
len
>
0
;
-
-
len
)
{
Accessible
*
child1
=
parents1
.
ElementAt
(
-
-
pos1
)
;
Accessible
*
child2
=
parents2
.
ElementAt
(
-
-
pos2
)
;
if
(
child1
!
=
child2
)
{
return
child1
-
>
IndexInParent
(
)
<
child2
-
>
IndexInParent
(
)
;
}
}
if
(
pos1
!
=
0
)
{
Accessible
*
child
=
parents1
.
ElementAt
(
pos1
-
1
)
;
MOZ_ASSERT
(
child
-
>
Parent
(
)
=
=
aPoint
.
mContainer
)
;
return
child
-
>
EndOffset
(
)
<
=
static_cast
<
uint32_t
>
(
aPoint
.
mOffset
)
;
}
if
(
pos2
!
=
0
)
{
Accessible
*
child
=
parents2
.
ElementAt
(
pos2
-
1
)
;
MOZ_ASSERT
(
child
-
>
Parent
(
)
=
=
mContainer
)
;
return
static_cast
<
uint32_t
>
(
mOffset
)
<
=
child
-
>
StartOffset
(
)
;
}
NS_ERROR
(
"
Broken
tree
?
!
"
)
;
return
false
;
}
TextRange
:
:
TextRange
(
Accessible
*
aRoot
Accessible
*
aStartContainer
int32_t
aStartOffset
Accessible
*
aEndContainer
int32_t
aEndOffset
)
:
mRoot
(
aRoot
)
mStartContainer
(
aStartContainer
)
mEndContainer
(
aEndContainer
)
mStartOffset
(
aStartOffset
)
mEndOffset
(
aEndOffset
)
{
}
bool
TextRange
:
:
Crop
(
Accessible
*
aContainer
)
{
uint32_t
boundaryPos
=
0
containerPos
=
0
;
AutoTArray
<
Accessible
*
30
>
boundaryParents
containerParents
;
Accessible
*
container
=
nullptr
;
HyperTextAccessibleBase
*
startHyper
=
mStartContainer
-
>
AsHyperTextBase
(
)
;
Accessible
*
boundary
=
startHyper
-
>
GetChildAtOffset
(
mStartOffset
)
;
if
(
boundary
!
=
aContainer
)
{
CommonParent
(
boundary
aContainer
&
boundaryParents
&
boundaryPos
&
containerParents
&
containerPos
)
;
if
(
boundaryPos
=
=
0
)
{
if
(
containerPos
!
=
0
)
{
ToTextPoint
(
aContainer
&
mStartContainer
&
mStartOffset
)
;
}
else
{
container
=
aContainer
;
}
}
else
{
boundary
=
boundaryParents
[
boundaryPos
]
;
container
=
containerParents
[
containerPos
]
;
}
if
(
container
)
{
if
(
boundary
-
>
IndexInParent
(
)
>
container
-
>
IndexInParent
(
)
)
{
return
!
!
(
mRoot
=
nullptr
)
;
}
if
(
boundary
-
>
IndexInParent
(
)
<
container
-
>
IndexInParent
(
)
)
{
ToTextPoint
(
container
&
mStartContainer
&
mStartOffset
)
;
}
}
boundaryParents
.
SetLengthAndRetainStorage
(
0
)
;
containerParents
.
SetLengthAndRetainStorage
(
0
)
;
}
HyperTextAccessibleBase
*
endHyper
=
mEndContainer
-
>
AsHyperTextBase
(
)
;
boundary
=
endHyper
-
>
GetChildAtOffset
(
mEndOffset
)
;
if
(
boundary
=
=
aContainer
)
{
return
true
;
}
container
=
nullptr
;
CommonParent
(
boundary
aContainer
&
boundaryParents
&
boundaryPos
&
containerParents
&
containerPos
)
;
if
(
boundaryPos
=
=
0
)
{
if
(
containerPos
!
=
0
)
{
ToTextPoint
(
aContainer
&
mEndContainer
&
mEndOffset
false
)
;
}
else
{
container
=
aContainer
;
}
}
else
{
boundary
=
boundaryParents
[
boundaryPos
]
;
container
=
containerParents
[
containerPos
]
;
}
if
(
!
container
)
{
return
true
;
}
if
(
boundary
-
>
IndexInParent
(
)
<
container
-
>
IndexInParent
(
)
)
{
return
!
!
(
mRoot
=
nullptr
)
;
}
if
(
boundary
-
>
IndexInParent
(
)
>
container
-
>
IndexInParent
(
)
)
{
ToTextPoint
(
container
&
mEndContainer
&
mEndOffset
false
)
;
}
return
true
;
}
static
DOMPoint
ClosestNotGeneratedDOMPoint
(
const
DOMPoint
&
aDOMPoint
nsIContent
*
aElementContent
)
{
MOZ_ASSERT
(
aDOMPoint
.
node
"
The
node
must
not
be
null
"
)
;
if
(
aElementContent
&
&
aElementContent
-
>
IsGeneratedContentContainerForBefore
(
)
)
{
MOZ_ASSERT
(
aElementContent
-
>
GetParent
(
)
"
:
:
before
must
have
parent
element
"
)
;
return
DOMPoint
(
aElementContent
-
>
GetParent
(
)
0
)
;
}
if
(
aElementContent
&
&
aElementContent
-
>
IsGeneratedContentContainerForAfter
(
)
)
{
MOZ_ASSERT
(
aElementContent
-
>
GetParent
(
)
"
:
:
after
must
have
parent
element
"
)
;
return
DOMPoint
(
aElementContent
-
>
GetParent
(
)
aElementContent
-
>
GetParent
(
)
-
>
GetChildCount
(
)
)
;
}
return
aDOMPoint
;
}
static
nsIContent
*
GetElementAsContentOf
(
nsINode
*
aNode
)
{
if
(
auto
*
element
=
dom
:
:
Element
:
:
FromNode
(
aNode
)
)
{
return
element
;
}
return
aNode
-
>
GetParentElement
(
)
;
}
bool
TextRange
:
:
AssignDOMRange
(
nsRange
*
aRange
bool
*
aReversed
)
const
{
MOZ_ASSERT
(
mRoot
-
>
IsLocal
(
)
"
Not
supported
for
RemoteAccessible
"
)
;
bool
reversed
=
EndPoint
(
)
<
StartPoint
(
)
;
if
(
aReversed
)
{
*
aReversed
=
reversed
;
}
HyperTextAccessible
*
startHyper
=
mStartContainer
-
>
AsLocal
(
)
-
>
AsHyperText
(
)
;
HyperTextAccessible
*
endHyper
=
mEndContainer
-
>
AsLocal
(
)
-
>
AsHyperText
(
)
;
DOMPoint
startPoint
=
reversed
?
endHyper
-
>
OffsetToDOMPoint
(
mEndOffset
)
:
startHyper
-
>
OffsetToDOMPoint
(
mStartOffset
)
;
if
(
!
startPoint
.
node
)
{
return
false
;
}
nsIContent
*
container
=
GetElementAsContentOf
(
startPoint
.
node
)
;
DOMPoint
startPointForDOMRange
=
ClosestNotGeneratedDOMPoint
(
startPoint
container
)
;
aRange
-
>
SetStart
(
startPointForDOMRange
.
node
startPointForDOMRange
.
idx
)
;
if
(
mEndContainer
=
=
mStartContainer
&
&
mEndOffset
=
=
mStartOffset
)
{
aRange
-
>
Collapse
(
true
)
;
return
true
;
}
DOMPoint
endPoint
=
reversed
?
startHyper
-
>
OffsetToDOMPoint
(
mStartOffset
)
:
endHyper
-
>
OffsetToDOMPoint
(
mEndOffset
)
;
if
(
!
endPoint
.
node
)
{
return
false
;
}
if
(
startPoint
.
node
!
=
endPoint
.
node
)
{
container
=
GetElementAsContentOf
(
endPoint
.
node
)
;
}
DOMPoint
endPointForDOMRange
=
ClosestNotGeneratedDOMPoint
(
endPoint
container
)
;
aRange
-
>
SetEnd
(
endPointForDOMRange
.
node
endPointForDOMRange
.
idx
)
;
return
true
;
}
void
TextRange
:
:
TextRangesFromSelection
(
dom
:
:
Selection
*
aSelection
nsTArray
<
TextRange
>
*
aRanges
)
{
MOZ_ASSERT
(
aRanges
-
>
Length
(
)
=
=
0
"
TextRange
array
supposed
to
be
empty
"
)
;
aRanges
-
>
SetCapacity
(
aSelection
-
>
RangeCount
(
)
)
;
const
uint32_t
rangeCount
=
aSelection
-
>
RangeCount
(
)
;
for
(
const
uint32_t
idx
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
aSelection
-
>
RangeCount
(
)
=
=
rangeCount
)
;
const
nsRange
*
DOMRange
=
aSelection
-
>
GetRangeAt
(
idx
)
;
MOZ_ASSERT
(
DOMRange
)
;
HyperTextAccessible
*
startContainer
=
nsAccUtils
:
:
GetTextContainer
(
DOMRange
-
>
GetStartContainer
(
)
)
;
HyperTextAccessible
*
endContainer
=
nsAccUtils
:
:
GetTextContainer
(
DOMRange
-
>
GetEndContainer
(
)
)
;
HyperTextAccessible
*
commonAncestor
=
nsAccUtils
:
:
GetTextContainer
(
DOMRange
-
>
GetClosestCommonInclusiveAncestor
(
)
)
;
if
(
!
startContainer
|
|
!
endContainer
)
{
continue
;
}
int32_t
startOffset
=
startContainer
-
>
DOMPointToOffset
(
DOMRange
-
>
GetStartContainer
(
)
DOMRange
-
>
StartOffset
(
)
false
)
;
int32_t
endOffset
=
endContainer
-
>
DOMPointToOffset
(
DOMRange
-
>
GetEndContainer
(
)
DOMRange
-
>
EndOffset
(
)
true
)
;
TextRange
tr
(
commonAncestor
&
&
commonAncestor
-
>
IsTextField
(
)
?
commonAncestor
:
startContainer
-
>
Document
(
)
startContainer
startOffset
endContainer
endOffset
)
;
*
(
aRanges
-
>
AppendElement
(
)
)
=
std
:
:
move
(
tr
)
;
}
}
void
TextRange
:
:
Set
(
Accessible
*
aRoot
Accessible
*
aStartContainer
int32_t
aStartOffset
Accessible
*
aEndContainer
int32_t
aEndOffset
)
{
mRoot
=
aRoot
;
mStartContainer
=
aStartContainer
;
mEndContainer
=
aEndContainer
;
mStartOffset
=
aStartOffset
;
mEndOffset
=
aEndOffset
;
}
Accessible
*
TextRange
:
:
CommonParent
(
Accessible
*
aAcc1
Accessible
*
aAcc2
nsTArray
<
Accessible
*
>
*
aParents1
uint32_t
*
aPos1
nsTArray
<
Accessible
*
>
*
aParents2
uint32_t
*
aPos2
)
const
{
if
(
aAcc1
=
=
aAcc2
)
{
return
aAcc1
;
}
MOZ_ASSERT
(
aParents1
-
>
Length
(
)
=
=
0
|
|
aParents2
-
>
Length
(
)
=
=
0
"
Wrong
arguments
"
)
;
Accessible
*
p1
=
aAcc1
;
Accessible
*
p2
=
aAcc2
;
do
{
aParents1
-
>
AppendElement
(
p1
)
;
p1
=
p1
-
>
Parent
(
)
;
}
while
(
p1
)
;
do
{
aParents2
-
>
AppendElement
(
p2
)
;
p2
=
p2
-
>
Parent
(
)
;
}
while
(
p2
)
;
*
aPos1
=
aParents1
-
>
Length
(
)
;
*
aPos2
=
aParents2
-
>
Length
(
)
;
Accessible
*
parent
=
nullptr
;
uint32_t
len
=
0
;
for
(
len
=
std
:
:
min
(
*
aPos1
*
aPos2
)
;
len
>
0
;
-
-
len
)
{
Accessible
*
child1
=
aParents1
-
>
ElementAt
(
-
-
(
*
aPos1
)
)
;
Accessible
*
child2
=
aParents2
-
>
ElementAt
(
-
-
(
*
aPos2
)
)
;
if
(
child1
!
=
child2
)
break
;
parent
=
child1
;
}
return
parent
;
}
}
}
