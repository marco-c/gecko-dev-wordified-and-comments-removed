#
ifndef
mozilla_a11y_NotificationController_h_
#
define
mozilla_a11y_NotificationController_h_
#
include
"
EventQueue
.
h
"
#
include
"
EventTree
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsRefreshObservers
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
<
utility
>
#
ifdef
A11Y_LOG
#
include
"
Logging
.
h
"
#
endif
namespace
mozilla
{
class
PresShell
;
namespace
a11y
{
class
DocAccessible
;
class
Notification
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
mozilla
:
:
a11y
:
:
Notification
)
virtual
void
Process
(
)
=
0
;
protected
:
Notification
(
)
{
}
virtual
~
Notification
(
)
{
}
private
:
Notification
(
const
Notification
&
)
;
Notification
&
operator
=
(
const
Notification
&
)
;
}
;
template
<
class
Class
class
.
.
.
Args
>
class
TNotification
:
public
Notification
{
public
:
typedef
void
(
Class
:
:
*
Callback
)
(
Args
*
.
.
.
)
;
TNotification
(
Class
*
aInstance
Callback
aCallback
Args
*
.
.
.
aArgs
)
:
mInstance
(
aInstance
)
mCallback
(
aCallback
)
mArgs
(
aArgs
.
.
.
)
{
}
virtual
~
TNotification
(
)
{
mInstance
=
nullptr
;
}
virtual
void
Process
(
)
override
{
ProcessHelper
(
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
}
private
:
TNotification
(
const
TNotification
&
)
;
TNotification
&
operator
=
(
const
TNotification
&
)
;
template
<
size_t
.
.
.
Indices
>
void
ProcessHelper
(
std
:
:
index_sequence
<
Indices
.
.
.
>
)
{
(
mInstance
-
>
*
mCallback
)
(
Get
<
Indices
>
(
mArgs
)
.
.
.
)
;
}
Class
*
mInstance
;
Callback
mCallback
;
Tuple
<
RefPtr
<
Args
>
.
.
.
>
mArgs
;
}
;
class
NotificationController
final
:
public
EventQueue
public
nsARefreshObserver
{
public
:
NotificationController
(
DocAccessible
*
aDocument
PresShell
*
aPresShell
)
;
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
void
)
override
;
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
void
)
override
;
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
NotificationController
)
void
Shutdown
(
)
;
void
QueueEvent
(
AccEvent
*
aEvent
)
{
if
(
PushEvent
(
aEvent
)
)
{
ScheduleProcessing
(
)
;
}
}
EventTree
*
QueueMutation
(
LocalAccessible
*
aContainer
)
;
class
MoveGuard
final
{
public
:
explicit
MoveGuard
(
NotificationController
*
aController
)
:
mController
(
aController
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mController
-
>
mMoveGuardOnStack
"
Move
guard
is
on
stack
already
!
"
)
;
mController
-
>
mMoveGuardOnStack
=
true
;
#
endif
}
~
MoveGuard
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
mController
-
>
mMoveGuardOnStack
"
No
move
guard
on
stack
!
"
)
;
mController
-
>
mMoveGuardOnStack
=
false
;
#
endif
mController
-
>
mPrecedingEvents
.
Clear
(
)
;
}
private
:
NotificationController
*
mController
;
}
;
#
ifdef
A11Y_LOG
const
EventTree
&
RootEventTree
(
)
const
{
return
mEventTree
;
}
;
#
endif
bool
QueueMutationEvent
(
AccTreeMutationEvent
*
aEvent
)
;
void
CoalesceMutationEvents
(
)
;
void
ScheduleChildDocBinding
(
DocAccessible
*
aDocument
)
;
inline
void
ScheduleTextUpdate
(
nsIContent
*
aTextNode
)
{
MOZ_ASSERT
(
aTextNode
-
>
GetParentNode
(
)
"
A
text
node
is
not
in
DOM
"
)
;
MOZ_ASSERT
(
aTextNode
-
>
GetPrimaryFrame
(
)
"
A
text
node
doesn
'
t
have
a
frame
"
)
;
MOZ_ASSERT
(
aTextNode
-
>
GetPrimaryFrame
(
)
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
"
A
text
node
is
not
visible
"
)
;
mTextHash
.
Insert
(
aTextNode
)
;
ScheduleProcessing
(
)
;
}
void
ScheduleContentInsertion
(
LocalAccessible
*
aContainer
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
&
aInsertions
)
;
void
ScheduleRelocation
(
LocalAccessible
*
aOwner
)
{
if
(
!
mRelocations
.
Contains
(
aOwner
)
)
{
mRelocations
.
AppendElement
(
aOwner
)
;
ScheduleProcessing
(
)
;
}
}
void
ScheduleProcessing
(
)
;
template
<
class
Class
class
.
.
.
Args
>
inline
void
HandleNotification
(
Class
*
aInstance
typename
TNotification
<
Class
Args
.
.
.
>
:
:
Callback
aMethod
Args
*
.
.
.
aArgs
)
{
if
(
!
IsUpdatePending
(
)
)
{
#
ifdef
A11Y_LOG
if
(
mozilla
:
:
a11y
:
:
logging
:
:
IsEnabled
(
mozilla
:
:
a11y
:
:
logging
:
:
eNotifications
)
)
{
mozilla
:
:
a11y
:
:
logging
:
:
Text
(
"
sync
notification
processing
"
)
;
}
#
endif
(
aInstance
-
>
*
aMethod
)
(
aArgs
.
.
.
)
;
return
;
}
RefPtr
<
Notification
>
notification
=
new
TNotification
<
Class
Args
.
.
.
>
(
aInstance
aMethod
aArgs
.
.
.
)
;
if
(
notification
)
{
mNotifications
.
AppendElement
(
notification
)
;
ScheduleProcessing
(
)
;
}
}
template
<
class
Class
>
inline
void
ScheduleNotification
(
Class
*
aInstance
typename
TNotification
<
Class
>
:
:
Callback
aMethod
)
{
RefPtr
<
Notification
>
notification
=
new
TNotification
<
Class
>
(
aInstance
aMethod
)
;
if
(
notification
)
{
mNotifications
.
AppendElement
(
notification
)
;
ScheduleProcessing
(
)
;
}
}
template
<
class
Class
class
Arg
>
inline
void
ScheduleNotification
(
Class
*
aInstance
typename
TNotification
<
Class
Arg
>
:
:
Callback
aMethod
Arg
*
aArg
)
{
RefPtr
<
Notification
>
notification
=
new
TNotification
<
Class
Arg
>
(
aInstance
aMethod
aArg
)
;
if
(
notification
)
{
mNotifications
.
AppendElement
(
notification
)
;
ScheduleProcessing
(
)
;
}
}
#
ifdef
DEBUG
bool
IsUpdating
(
)
const
{
return
mObservingState
=
=
eRefreshProcessingForUpdate
;
}
#
endif
protected
:
virtual
~
NotificationController
(
)
;
nsCycleCollectingAutoRefCnt
mRefCnt
;
NS_DECL_OWNINGTHREAD
bool
IsUpdatePending
(
)
;
bool
WaitingForParent
(
)
;
private
:
NotificationController
(
const
NotificationController
&
)
;
NotificationController
&
operator
=
(
const
NotificationController
&
)
;
virtual
void
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
override
;
void
WithdrawPrecedingEvents
(
nsTArray
<
RefPtr
<
AccHideEvent
>
>
*
aEvs
)
{
if
(
mPrecedingEvents
.
Length
(
)
>
0
)
{
aEvs
-
>
AppendElements
(
std
:
:
move
(
mPrecedingEvents
)
)
;
}
}
void
StorePrecedingEvent
(
AccHideEvent
*
aEv
)
{
MOZ_ASSERT
(
mMoveGuardOnStack
"
No
move
guard
on
stack
!
"
)
;
mPrecedingEvents
.
AppendElement
(
aEv
)
;
}
void
StorePrecedingEvents
(
nsTArray
<
RefPtr
<
AccHideEvent
>
>
&
&
aEvs
)
{
MOZ_ASSERT
(
mMoveGuardOnStack
"
No
move
guard
on
stack
!
"
)
;
mPrecedingEvents
.
InsertElementsAt
(
0
aEvs
)
;
}
private
:
void
DropMutationEvent
(
AccTreeMutationEvent
*
aEvent
)
;
void
ProcessMutationEvents
(
)
;
enum
eObservingState
{
eNotObservingRefresh
eRefreshObserving
eRefreshProcessing
eRefreshProcessingForUpdate
}
;
eObservingState
mObservingState
;
PresShell
*
mPresShell
;
nsTArray
<
RefPtr
<
DocAccessible
>
>
mHangingChildDocuments
;
nsClassHashtable
<
nsRefPtrHashKey
<
LocalAccessible
>
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
>
mContentInsertions
;
template
<
class
T
>
class
nsCOMPtrHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
T
*
KeyType
;
typedef
const
T
*
KeyTypePointer
;
explicit
nsCOMPtrHashKey
(
const
T
*
aKey
)
:
mKey
(
const_cast
<
T
*
>
(
aKey
)
)
{
}
nsCOMPtrHashKey
(
nsCOMPtrHashKey
<
T
>
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mKey
(
std
:
:
move
(
aOther
.
mKey
)
)
{
}
~
nsCOMPtrHashKey
(
)
{
}
KeyType
GetKey
(
)
const
{
return
mKey
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
aKey
=
=
mKey
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
NS_PTR_TO_INT32
(
aKey
)
>
>
2
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
protected
:
nsCOMPtr
<
T
>
mKey
;
}
;
nsTHashSet
<
nsCOMPtrHashKey
<
nsIContent
>
>
mTextHash
;
nsTArray
<
RefPtr
<
Notification
>
>
mNotifications
;
nsTArray
<
RefPtr
<
LocalAccessible
>
>
mRelocations
;
EventTree
mEventTree
;
nsTArray
<
RefPtr
<
AccHideEvent
>
>
mPrecedingEvents
;
#
ifdef
DEBUG
bool
mMoveGuardOnStack
;
#
endif
friend
class
MoveGuard
;
friend
class
EventTree
;
RefPtr
<
AccTreeMutationEvent
>
mFirstMutationEvent
;
RefPtr
<
AccTreeMutationEvent
>
mLastMutationEvent
;
class
EventMap
{
public
:
enum
EventType
{
ShowEvent
=
0x0
HideEvent
=
0x1
ReorderEvent
=
0x2
}
;
void
PutEvent
(
AccTreeMutationEvent
*
aEvent
)
;
AccTreeMutationEvent
*
GetEvent
(
LocalAccessible
*
aTarget
EventType
aType
)
;
void
RemoveEvent
(
AccTreeMutationEvent
*
aEvent
)
;
void
Clear
(
)
{
mTable
.
Clear
(
)
;
}
private
:
EventType
GetEventType
(
AccTreeMutationEvent
*
aEvent
)
;
nsRefPtrHashtable
<
nsUint64HashKey
AccTreeMutationEvent
>
mTable
;
}
;
EventMap
mMutationMap
;
uint32_t
mEventGeneration
;
}
;
}
}
#
endif
