#
ifndef
mozilla_a11y_TextLeafRange_h__
#
define
mozilla_a11y_TextLeafRange_h__
#
include
<
stdint
.
h
>
#
include
"
AccAttributes
.
h
"
#
include
"
nsDirection
.
h
"
#
include
"
nsIAccessibleText
.
h
"
class
nsRange
;
namespace
mozilla
{
namespace
dom
{
class
Document
;
}
namespace
a11y
{
class
Accessible
;
class
LocalAccessible
;
class
TextLeafPoint
final
{
public
:
TextLeafPoint
(
Accessible
*
aAcc
int32_t
aOffset
)
;
TextLeafPoint
(
)
:
mAcc
(
nullptr
)
mOffset
(
0
)
{
}
static
TextLeafPoint
GetCaret
(
Accessible
*
aAcc
)
{
return
TextLeafPoint
(
aAcc
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
;
}
Accessible
*
mAcc
;
int32_t
mOffset
;
bool
operator
=
=
(
const
TextLeafPoint
&
aPoint
)
const
{
return
mAcc
=
=
aPoint
.
mAcc
&
&
mOffset
=
=
aPoint
.
mOffset
;
}
bool
operator
!
=
(
const
TextLeafPoint
&
aPoint
)
const
{
return
!
(
*
this
=
=
aPoint
)
;
}
bool
operator
<
(
const
TextLeafPoint
&
aPoint
)
const
;
bool
operator
<
=
(
const
TextLeafPoint
&
aPoint
)
const
;
explicit
operator
bool
(
)
const
{
return
!
!
mAcc
;
}
bool
IsCaret
(
)
const
{
return
mOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
;
}
bool
IsCaretAtEndOfLine
(
)
const
;
TextLeafPoint
ActualizeCaret
(
bool
aAdjustAtEndOfLine
=
true
)
const
;
TextLeafPoint
FindBoundary
(
AccessibleTextBoundary
aBoundaryType
nsDirection
aDirection
bool
aIncludeOrigin
=
false
bool
aStopInEditable
=
false
)
const
;
TextLeafPoint
FindPrevLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindNextLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindPrevWordStartSameAcc
(
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindNextWordStartSameAcc
(
bool
aIncludeOrigin
)
const
;
already_AddRefed
<
AccAttributes
>
GetTextAttributes
(
bool
aIncludeDefaults
=
true
)
const
;
already_AddRefed
<
AccAttributes
>
GetTextAttributesLocalAcc
(
bool
aIncludeDefaults
=
true
)
const
;
static
nsTArray
<
int32_t
>
GetSpellingErrorOffsets
(
LocalAccessible
*
aAcc
)
;
static
void
UpdateCachedSpellingError
(
dom
:
:
Document
*
aDocument
const
nsRange
&
aRange
)
;
TextLeafPoint
FindTextAttrsStart
(
nsDirection
aDirection
bool
aIncludeOrigin
=
false
)
const
;
LayoutDeviceIntRect
CharBounds
(
)
;
bool
ContainsPoint
(
int32_t
aX
int32_t
aY
)
;
bool
IsLineFeedChar
(
)
const
{
return
GetChar
(
)
=
=
'
\
n
'
;
}
bool
IsSpace
(
)
const
;
bool
IsParagraphStart
(
)
const
{
return
mOffset
=
=
0
&
&
FindParagraphSameAcc
(
eDirPrevious
true
)
;
}
private
:
bool
IsEmptyLastLine
(
)
const
;
char16_t
GetChar
(
)
const
;
TextLeafPoint
FindLineStartSameRemoteAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindLineStartSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindLineEnd
(
nsDirection
aDirection
bool
aIncludeOrigin
bool
aStopInEditable
)
const
;
TextLeafPoint
FindWordEnd
(
nsDirection
aDirection
bool
aIncludeOrigin
bool
aStopInEditable
)
const
;
TextLeafPoint
FindParagraphSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
;
bool
IsInSpellingError
(
)
const
;
TextLeafPoint
FindSpellingErrorSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
;
}
;
class
TextLeafRange
final
{
public
:
TextLeafRange
(
const
TextLeafPoint
&
aStart
const
TextLeafPoint
&
aEnd
)
:
mStart
(
aStart
)
mEnd
(
aEnd
)
{
}
explicit
TextLeafRange
(
const
TextLeafPoint
&
aStart
)
:
mStart
(
aStart
)
mEnd
(
aStart
)
{
}
explicit
TextLeafRange
(
)
{
}
explicit
operator
bool
(
)
const
{
return
!
!
mStart
&
&
!
!
mEnd
;
}
bool
operator
!
=
(
const
TextLeafRange
&
aOther
)
const
{
return
mEnd
!
=
aOther
.
mEnd
|
|
mStart
!
=
aOther
.
mStart
;
}
TextLeafPoint
Start
(
)
const
{
return
mStart
;
}
void
SetStart
(
const
TextLeafPoint
&
aStart
)
{
mStart
=
aStart
;
}
TextLeafPoint
End
(
)
const
{
return
mEnd
;
}
void
SetEnd
(
const
TextLeafPoint
&
aEnd
)
{
mEnd
=
aEnd
;
}
private
:
TextLeafPoint
mStart
;
TextLeafPoint
mEnd
;
public
:
class
Iterator
{
public
:
Iterator
(
Iterator
&
&
aOther
)
:
mRange
(
aOther
.
mRange
)
mSegmentStart
(
aOther
.
mSegmentStart
)
mSegmentEnd
(
aOther
.
mSegmentEnd
)
{
}
static
Iterator
BeginIterator
(
const
TextLeafRange
&
aRange
)
;
static
Iterator
EndIterator
(
const
TextLeafRange
&
aRange
)
;
Iterator
&
operator
+
+
(
)
;
bool
operator
!
=
(
const
Iterator
&
aOther
)
const
{
return
mRange
!
=
aOther
.
mRange
|
|
mSegmentStart
!
=
aOther
.
mSegmentStart
|
|
mSegmentEnd
!
=
aOther
.
mSegmentEnd
;
}
TextLeafRange
operator
*
(
)
{
return
TextLeafRange
(
mSegmentStart
mSegmentEnd
)
;
}
private
:
explicit
Iterator
(
const
TextLeafRange
&
aRange
)
:
mRange
(
aRange
)
{
}
Iterator
(
)
=
delete
;
Iterator
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
&
)
=
delete
;
const
TextLeafRange
&
mRange
;
TextLeafPoint
mSegmentStart
;
TextLeafPoint
mSegmentEnd
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
:
:
BeginIterator
(
*
this
)
;
}
Iterator
end
(
)
const
{
return
Iterator
:
:
EndIterator
(
*
this
)
;
}
}
;
}
}
#
endif
