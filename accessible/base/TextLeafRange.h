#
ifndef
mozilla_a11y_TextLeafRange_h__
#
define
mozilla_a11y_TextLeafRange_h__
#
include
<
stdint
.
h
>
#
include
"
AccAttributes
.
h
"
#
include
"
nsDirection
.
h
"
#
include
"
nsIAccessibleText
.
h
"
class
nsRange
;
namespace
mozilla
{
namespace
dom
{
class
Document
;
}
namespace
a11y
{
class
Accessible
;
class
LocalAccessible
;
class
TextLeafPoint
final
{
public
:
TextLeafPoint
(
Accessible
*
aAcc
int32_t
aOffset
)
;
TextLeafPoint
(
)
:
mAcc
(
nullptr
)
mOffset
(
0
)
{
}
static
TextLeafPoint
GetCaret
(
Accessible
*
aAcc
)
{
return
TextLeafPoint
(
aAcc
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
;
}
Accessible
*
mAcc
;
int32_t
mOffset
;
bool
operator
=
=
(
const
TextLeafPoint
&
aPoint
)
const
{
return
mAcc
=
=
aPoint
.
mAcc
&
&
mOffset
=
=
aPoint
.
mOffset
;
}
bool
operator
!
=
(
const
TextLeafPoint
&
aPoint
)
const
{
return
!
(
*
this
=
=
aPoint
)
;
}
bool
operator
<
(
const
TextLeafPoint
&
aPoint
)
const
;
bool
operator
<
=
(
const
TextLeafPoint
&
aPoint
)
const
;
explicit
operator
bool
(
)
const
{
return
!
!
mAcc
;
}
bool
IsCaret
(
)
const
{
return
mOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
;
}
bool
IsCaretAtEndOfLine
(
)
const
;
TextLeafPoint
ActualizeCaret
(
bool
aAdjustAtEndOfLine
=
true
)
const
;
TextLeafPoint
FindBoundary
(
AccessibleTextBoundary
aBoundaryType
nsDirection
aDirection
bool
aIncludeOrigin
=
false
bool
aStopInEditable
=
false
)
const
;
TextLeafPoint
FindPrevLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindNextLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindPrevWordStartSameAcc
(
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindNextWordStartSameAcc
(
bool
aIncludeOrigin
)
const
;
already_AddRefed
<
AccAttributes
>
GetTextAttributes
(
bool
aIncludeDefaults
=
true
)
const
;
already_AddRefed
<
AccAttributes
>
GetTextAttributesLocalAcc
(
bool
aIncludeDefaults
=
true
)
const
;
static
nsTArray
<
int32_t
>
GetSpellingErrorOffsets
(
LocalAccessible
*
aAcc
)
;
static
void
UpdateCachedSpellingError
(
dom
:
:
Document
*
aDocument
const
nsRange
&
aRange
)
;
TextLeafPoint
FindTextAttrsStart
(
nsDirection
aDirection
bool
aIncludeOrigin
=
false
)
const
;
LayoutDeviceIntRect
CharBounds
(
)
;
bool
ContainsPoint
(
int32_t
aX
int32_t
aY
)
;
bool
IsLineFeedChar
(
)
const
{
return
GetChar
(
)
=
=
'
\
n
'
;
}
bool
IsSpace
(
)
const
;
private
:
bool
IsEmptyLastLine
(
)
const
;
char16_t
GetChar
(
)
const
;
TextLeafPoint
FindLineStartSameRemoteAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindLineStartSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindLineEnd
(
nsDirection
aDirection
bool
aIncludeOrigin
bool
aStopInEditable
)
const
;
TextLeafPoint
FindWordEnd
(
nsDirection
aDirection
bool
aIncludeOrigin
bool
aStopInEditable
)
const
;
TextLeafPoint
FindParagraphSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
;
bool
IsInSpellingError
(
)
const
;
TextLeafPoint
FindSpellingErrorSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
;
}
;
class
TextLeafRange
final
{
public
:
TextLeafRange
(
const
TextLeafPoint
&
aStart
const
TextLeafPoint
&
aEnd
)
:
mStart
(
aStart
)
mEnd
(
aEnd
)
{
}
explicit
TextLeafRange
(
const
TextLeafPoint
&
aStart
)
:
mStart
(
aStart
)
mEnd
(
aStart
)
{
}
TextLeafPoint
Start
(
)
{
return
mStart
;
}
void
SetStart
(
const
TextLeafPoint
&
aStart
)
{
mStart
=
aStart
;
}
TextLeafPoint
End
(
)
{
return
mEnd
;
}
void
SetEnd
(
const
TextLeafPoint
&
aEnd
)
{
mEnd
=
aEnd
;
}
private
:
TextLeafPoint
mStart
;
TextLeafPoint
mEnd
;
}
;
}
}
#
endif
