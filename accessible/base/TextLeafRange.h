#
ifndef
mozilla_a11y_TextLeafRange_h__
#
define
mozilla_a11y_TextLeafRange_h__
#
include
<
stdint
.
h
>
#
include
"
AccAttributes
.
h
"
#
include
"
nsDirection
.
h
"
#
include
"
nsIAccessibleText
.
h
"
#
include
"
mozilla
/
FunctionRef
.
h
"
namespace
mozilla
{
namespace
dom
{
class
AbstractRange
;
class
Document
;
}
namespace
a11y
{
class
Accessible
;
class
LocalAccessible
;
class
TextLeafPoint
final
{
public
:
TextLeafPoint
(
Accessible
*
aAcc
int32_t
aOffset
)
;
TextLeafPoint
(
)
:
mAcc
(
nullptr
)
mOffset
(
0
)
{
}
static
TextLeafPoint
GetCaret
(
Accessible
*
aAcc
)
;
Accessible
*
mAcc
;
int32_t
mOffset
;
bool
mIsEndOfLineInsertionPoint
=
false
;
bool
operator
=
=
(
const
TextLeafPoint
&
aPoint
)
const
{
return
mAcc
=
=
aPoint
.
mAcc
&
&
mOffset
=
=
aPoint
.
mOffset
;
}
bool
operator
!
=
(
const
TextLeafPoint
&
aPoint
)
const
{
return
!
(
*
this
=
=
aPoint
)
;
}
bool
operator
<
(
const
TextLeafPoint
&
aPoint
)
const
;
bool
operator
<
=
(
const
TextLeafPoint
&
aPoint
)
const
;
explicit
operator
bool
(
)
const
{
return
!
!
mAcc
;
}
enum
class
BoundaryFlags
:
uint32_t
{
eDefaultBoundaryFlags
=
0
eIncludeOrigin
=
1
<
<
0
eStopInEditable
=
1
<
<
1
eIgnoreListItemMarker
=
1
<
<
2
}
;
TextLeafPoint
FindBoundary
(
AccessibleTextBoundary
aBoundaryType
nsDirection
aDirection
BoundaryFlags
aFlags
=
BoundaryFlags
:
:
eDefaultBoundaryFlags
)
const
;
TextLeafPoint
FindPrevLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindNextLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindPrevWordStartSameAcc
(
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindNextWordStartSameAcc
(
bool
aIncludeOrigin
)
const
;
already_AddRefed
<
AccAttributes
>
GetTextAttributes
(
bool
aIncludeDefaults
=
true
)
const
;
already_AddRefed
<
AccAttributes
>
GetTextAttributesLocalAcc
(
bool
aIncludeDefaults
=
true
)
const
;
static
nsTArray
<
TextOffsetAttribute
>
GetTextOffsetAttributes
(
LocalAccessible
*
aAcc
)
;
static
void
UpdateCachedTextOffsetAttributes
(
dom
:
:
Document
*
aDocument
const
dom
:
:
AbstractRange
&
aRange
)
;
TextLeafPoint
FindTextAttrsStart
(
nsDirection
aDirection
bool
aIncludeOrigin
=
false
)
const
;
LayoutDeviceIntRect
CharBounds
(
)
;
bool
ContainsPoint
(
int32_t
aX
int32_t
aY
)
;
bool
IsLineFeedChar
(
)
const
{
return
GetChar
(
)
=
=
'
\
n
'
;
}
bool
IsSpace
(
)
const
;
bool
IsParagraphStart
(
bool
aIgnoreListItemMarker
=
false
)
const
{
return
mOffset
=
=
0
&
&
FindParagraphSameAcc
(
eDirPrevious
true
aIgnoreListItemMarker
)
;
}
MOZ_CAN_RUN_SCRIPT
std
:
:
pair
<
nsIContent
*
int32_t
>
ToDOMPoint
(
bool
aIncludeGenerated
=
true
)
const
;
private
:
TextLeafPoint
AdjustEndOfLine
(
)
const
;
bool
IsEmptyLastLine
(
)
const
;
bool
IsDocEdge
(
nsDirection
aDirection
)
const
;
bool
IsLeafAfterListItemMarker
(
)
const
;
char16_t
GetChar
(
)
const
;
TextLeafPoint
FindLineStartSameRemoteAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
;
TextLeafPoint
FindLineStartSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
bool
aIgnoreListItemMarker
=
false
)
const
;
TextLeafPoint
FindLineEnd
(
nsDirection
aDirection
BoundaryFlags
aFlags
)
const
;
TextLeafPoint
FindWordEnd
(
nsDirection
aDirection
BoundaryFlags
aFlags
)
const
;
TextLeafPoint
FindParagraphSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
bool
aIgnoreListItemMarker
=
false
)
const
;
TextLeafPoint
FindClusterSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
;
void
AddTextOffsetAttributes
(
AccAttributes
*
aAttrs
)
const
;
TextLeafPoint
FindTextOffsetAttributeSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
;
TextLeafPoint
NeighborLeafPoint
(
nsDirection
aDirection
bool
aIsEditable
bool
aIgnoreListItemMarker
)
const
;
LayoutDeviceIntRect
ComputeBoundsFromFrame
(
)
const
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
TextLeafPoint
:
:
BoundaryFlags
)
class
TextLeafRange
final
{
public
:
TextLeafRange
(
const
TextLeafPoint
&
aStart
const
TextLeafPoint
&
aEnd
)
:
mStart
(
aStart
)
mEnd
(
aEnd
)
{
}
explicit
TextLeafRange
(
const
TextLeafPoint
&
aStart
)
:
mStart
(
aStart
)
mEnd
(
aStart
)
{
}
explicit
TextLeafRange
(
)
{
}
static
TextLeafRange
FromAccessible
(
Accessible
*
aAcc
)
{
return
{
{
aAcc
0
}
{
aAcc
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
}
}
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mStart
&
&
!
!
mEnd
;
}
bool
operator
!
=
(
const
TextLeafRange
&
aOther
)
const
{
return
mEnd
!
=
aOther
.
mEnd
|
|
mStart
!
=
aOther
.
mStart
;
}
bool
operator
=
=
(
const
TextLeafRange
&
aOther
)
const
{
return
mEnd
=
=
aOther
.
mEnd
&
&
mStart
=
=
aOther
.
mStart
;
}
TextLeafPoint
Start
(
)
const
{
return
mStart
;
}
void
SetStart
(
const
TextLeafPoint
&
aStart
)
{
mStart
=
aStart
;
}
TextLeafPoint
End
(
)
const
{
return
mEnd
;
}
void
SetEnd
(
const
TextLeafPoint
&
aEnd
)
{
mEnd
=
aEnd
;
}
bool
Crop
(
Accessible
*
aContainer
)
;
LayoutDeviceIntRect
Bounds
(
)
const
;
nsTArray
<
LayoutDeviceIntRect
>
LineRects
(
)
const
;
TextLeafPoint
TextLeafPointAtScreenPoint
(
int32_t
aX
int32_t
aY
)
const
;
static
void
GetSelection
(
Accessible
*
aAcc
nsTArray
<
TextLeafRange
>
&
aRanges
)
;
MOZ_CAN_RUN_SCRIPT
bool
SetSelection
(
int32_t
aSelectionNum
)
const
;
MOZ_CAN_RUN_SCRIPT
void
ScrollIntoView
(
uint32_t
aScrollType
)
const
;
private
:
TextLeafPoint
mStart
;
TextLeafPoint
mEnd
;
using
LineRectCallback
=
FunctionRef
<
void
(
LayoutDeviceIntRect
)
>
;
bool
WalkLineRects
(
LineRectCallback
aCallback
)
const
;
public
:
class
Iterator
{
public
:
Iterator
(
Iterator
&
&
aOther
)
:
mRange
(
aOther
.
mRange
)
mSegmentStart
(
aOther
.
mSegmentStart
)
mSegmentEnd
(
aOther
.
mSegmentEnd
)
{
}
static
Iterator
BeginIterator
(
const
TextLeafRange
&
aRange
)
;
static
Iterator
EndIterator
(
const
TextLeafRange
&
aRange
)
;
Iterator
&
operator
+
+
(
)
;
bool
operator
!
=
(
const
Iterator
&
aOther
)
const
{
return
mRange
!
=
aOther
.
mRange
|
|
mSegmentStart
!
=
aOther
.
mSegmentStart
|
|
mSegmentEnd
!
=
aOther
.
mSegmentEnd
;
}
TextLeafRange
operator
*
(
)
{
return
TextLeafRange
(
mSegmentStart
mSegmentEnd
)
;
}
private
:
explicit
Iterator
(
const
TextLeafRange
&
aRange
)
:
mRange
(
aRange
)
{
}
Iterator
(
)
=
delete
;
Iterator
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
&
)
=
delete
;
const
TextLeafRange
&
mRange
;
TextLeafPoint
mSegmentStart
;
TextLeafPoint
mSegmentEnd
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
:
:
BeginIterator
(
*
this
)
;
}
Iterator
end
(
)
const
{
return
Iterator
:
:
EndIterator
(
*
this
)
;
}
}
;
}
}
#
endif
