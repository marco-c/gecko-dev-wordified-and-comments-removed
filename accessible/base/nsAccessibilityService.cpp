#
include
"
nsAccessibilityService
.
h
"
#
include
"
ApplicationAccessibleWrap
.
h
"
#
include
"
ARIAGridAccessible
.
h
"
#
include
"
ARIAMap
.
h
"
#
include
"
CssAltContent
.
h
"
#
include
"
DocAccessible
-
inl
.
h
"
#
include
"
DocAccessibleChild
.
h
"
#
include
"
FocusManager
.
h
"
#
include
"
mozilla
/
FocusModel
.
h
"
#
include
"
HTMLCanvasAccessible
.
h
"
#
include
"
HTMLElementAccessibles
.
h
"
#
include
"
HTMLImageMapAccessible
.
h
"
#
include
"
HTMLLinkAccessible
.
h
"
#
include
"
HTMLListAccessible
.
h
"
#
include
"
HTMLSelectAccessible
.
h
"
#
include
"
HTMLTableAccessible
.
h
"
#
include
"
HyperTextAccessible
.
h
"
#
include
"
RootAccessible
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsDOMTokenList
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsTextFormatter
.
h
"
#
include
"
OuterDocAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
Role
.
h
"
#
ifdef
MOZ_ACCESSIBILITY_ATK
#
include
"
RootAccessibleWrap
.
h
"
#
endif
#
include
"
States
.
h
"
#
include
"
Statistics
.
h
"
#
include
"
TextLeafAccessible
.
h
"
#
include
"
xpcAccessibleApplication
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
a11y
/
Compatibility
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
endif
#
ifdef
A11Y_LOG
#
include
"
Logging
.
h
"
#
endif
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsTreeBodyFrame
.
h
"
#
include
"
nsTreeUtils
.
h
"
#
include
"
mozilla
/
a11y
/
AccTypes
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTableElement
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
XULAlertAccessible
.
h
"
#
include
"
XULComboboxAccessible
.
h
"
#
include
"
XULElementAccessibles
.
h
"
#
include
"
XULFormControlAccessible
.
h
"
#
include
"
XULListboxAccessible
.
h
"
#
include
"
XULMenuAccessible
.
h
"
#
include
"
XULTabAccessible
.
h
"
#
include
"
XULTreeGridAccessible
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
using
namespace
mozilla
:
:
dom
;
#
define
PREF_ACCESSIBILITY_FORCE_DISABLED
"
accessibility
.
force_disabled
"
static
LocalAccessible
*
MaybeCreateSpecificARIAAccessible
(
const
nsRoleMapEntry
*
aRoleMapEntry
const
LocalAccessible
*
aContext
nsIContent
*
aContent
DocAccessible
*
aDocument
)
{
if
(
aRoleMapEntry
&
&
aRoleMapEntry
-
>
accTypes
&
eTableCell
)
{
if
(
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
)
&
&
aContext
-
>
IsHTMLTableRow
(
)
)
{
return
nullptr
;
}
const
Accessible
*
parent
=
aContext
;
if
(
parent
-
>
IsGeneric
(
)
)
{
parent
=
parent
-
>
GetNonGenericParent
(
)
;
}
if
(
!
parent
|
|
parent
-
>
Role
(
)
!
=
roles
:
:
ROW
)
{
return
nullptr
;
}
parent
=
parent
-
>
GetNonGenericParent
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
if
(
!
parent
-
>
IsTable
(
)
&
&
parent
-
>
Role
(
)
=
=
roles
:
:
ROWGROUP
)
{
parent
=
parent
-
>
GetNonGenericParent
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
}
if
(
parent
-
>
IsTable
(
)
)
{
return
new
ARIAGridCellAccessible
(
aContent
aDocument
)
;
}
}
return
nullptr
;
}
static
bool
MustBeGenericAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDocument
)
{
if
(
aContent
-
>
IsInNativeAnonymousSubtree
(
)
|
|
aContent
-
>
IsSVGElement
(
)
)
{
return
false
;
}
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
MOZ_ASSERT
(
frame
)
;
nsAutoCString
overflow
;
frame
-
>
Style
(
)
-
>
GetComputedPropertyValue
(
eCSSProperty_overflow
overflow
)
;
return
!
aContent
-
>
IsXULElement
(
)
&
&
(
(
aContent
-
>
HasChildren
(
)
&
&
frame
-
>
IsTransformed
(
)
)
|
|
frame
-
>
IsStickyPositioned
(
)
|
|
(
frame
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Fixed
&
&
nsLayoutUtils
:
:
IsReallyFixedPos
(
frame
)
)
|
|
overflow
.
Equals
(
"
auto
"
_ns
)
|
|
overflow
.
Equals
(
"
scroll
"
_ns
)
|
|
overflow
.
Equals
(
"
hidden
"
_ns
)
)
;
}
static
bool
MustBeAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDocument
)
{
if
(
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
)
{
if
(
frame
-
>
IsFocusable
(
IsFocusableFlags
:
:
IgnoreVisibility
)
)
{
return
true
;
}
}
if
(
aContent
-
>
IsElement
(
)
)
{
uint32_t
attrCount
=
aContent
-
>
AsElement
(
)
-
>
GetAttrCount
(
)
;
for
(
uint32_t
attrIdx
=
0
;
attrIdx
<
attrCount
;
attrIdx
+
+
)
{
const
nsAttrName
*
attr
=
aContent
-
>
AsElement
(
)
-
>
GetAttrNameAt
(
attrIdx
)
;
if
(
attr
-
>
NamespaceEquals
(
kNameSpaceID_None
)
)
{
nsAtom
*
attrAtom
=
attr
-
>
Atom
(
)
;
if
(
attrAtom
=
=
nsGkAtoms
:
:
title
&
&
aContent
-
>
IsHTMLElement
(
)
)
{
return
true
;
}
nsDependentAtomString
attrStr
(
attrAtom
)
;
if
(
!
StringBeginsWith
(
attrStr
u
"
aria
-
"
_ns
)
)
continue
;
uint8_t
attrFlags
=
aria
:
:
AttrCharacteristicsFor
(
attrAtom
)
;
if
(
(
attrFlags
&
ATTR_GLOBAL
)
&
&
(
!
(
attrFlags
&
ATTR_VALTOKEN
)
|
|
nsAccUtils
:
:
HasDefinedARIAToken
(
aContent
attrAtom
)
)
)
{
return
true
;
}
}
}
nsAutoString
id
;
if
(
nsCoreUtils
:
:
GetID
(
aContent
id
)
&
&
!
id
.
IsEmpty
(
)
)
{
return
aDocument
-
>
IsDependentID
(
aContent
-
>
AsElement
(
)
id
)
;
}
}
return
false
;
}
bool
nsAccessibilityService
:
:
ShouldCreateImgAccessible
(
mozilla
:
:
dom
:
:
Element
*
aElement
DocAccessible
*
aDocument
)
{
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
false
;
}
if
(
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
&
&
(
(
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
embed
)
&
&
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
)
|
|
frame
-
>
AccessibleType
(
)
!
=
AccType
:
:
eImageType
)
&
&
!
CssAltContent
(
aElement
)
)
{
return
false
;
}
nsAutoString
newAltText
;
const
bool
hasAlt
=
aElement
-
>
GetAttr
(
nsGkAtoms
:
:
alt
newAltText
)
;
if
(
!
hasAlt
|
|
!
newAltText
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
newAltText
.
IsEmpty
(
)
&
&
(
nsCoreUtils
:
:
HasClickListener
(
aElement
)
|
|
MustBeAccessible
(
aElement
aDocument
)
)
)
{
return
true
;
}
return
false
;
}
static
bool
MustSVGElementBeAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDocument
)
{
for
(
nsIContent
*
childElm
=
aContent
-
>
GetFirstChild
(
)
;
childElm
;
childElm
=
childElm
-
>
GetNextSibling
(
)
)
{
if
(
childElm
-
>
IsAnyOfSVGElements
(
nsGkAtoms
:
:
title
nsGkAtoms
:
:
desc
)
)
{
return
true
;
}
}
return
MustBeAccessible
(
aContent
aDocument
)
;
}
static
RefPtr
<
LocalAccessible
>
MaybeCreateSVGAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDocument
)
{
if
(
aContent
-
>
IsSVGGeometryElement
(
)
|
|
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
image
)
)
{
if
(
MustSVGElementBeAccessible
(
aContent
aDocument
)
)
{
return
new
EnumRoleAccessible
<
roles
:
:
GRAPHIC
>
(
aContent
aDocument
)
;
}
}
else
if
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
text
)
)
{
return
new
HyperTextAccessible
(
aContent
-
>
AsElement
(
)
aDocument
)
;
}
else
if
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
return
new
EnumRoleHyperTextAccessible
<
roles
:
:
DIAGRAM
>
(
aContent
aDocument
)
;
}
else
if
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
g
)
&
&
MustSVGElementBeAccessible
(
aContent
aDocument
)
)
{
return
new
EnumRoleHyperTextAccessible
<
roles
:
:
GROUPING
>
(
aContent
aDocument
)
;
}
else
if
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
a
)
)
{
return
new
HTMLLinkAccessible
(
aContent
aDocument
)
;
}
return
nullptr
;
}
LocalAccessible
*
CreateMenupopupAccessible
(
Element
*
aElement
LocalAccessible
*
aContext
)
{
#
ifdef
MOZ_ACCESSIBILITY_ATK
nsIContent
*
parent
=
aElement
-
>
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsXULElement
(
nsGkAtoms
:
:
menu
)
)
return
nullptr
;
#
endif
return
new
XULMenupopupAccessible
(
aElement
aContext
-
>
Document
(
)
)
;
}
static
uint64_t
GetCacheDomainsForKnownClients
(
uint64_t
aCacheDomains
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
aCacheDomains
;
}
return
a11y
:
:
GetCacheDomainsForKnownClients
(
aCacheDomains
)
;
}
static
LocalAccessible
*
New_HyperText
(
Element
*
aElement
LocalAccessible
*
aContext
)
{
return
new
HyperTextAccessible
(
aElement
aContext
-
>
Document
(
)
)
;
}
template
<
typename
AccClass
>
static
LocalAccessible
*
New_HTMLDtOrDd
(
Element
*
aElement
LocalAccessible
*
aContext
)
{
nsIContent
*
parent
=
aContext
-
>
GetContent
(
)
;
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
parent
&
&
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
{
return
new
AccClass
(
aElement
aContext
-
>
Document
(
)
)
;
}
return
nullptr
;
}
static
int32_t
sPlatformDisabledState
=
0
;
#
define
Attr
(
name
value
)
{
nsGkAtoms
:
:
name
nsGkAtoms
:
:
value
}
#
define
AttrFromDOM
(
name
DOMAttrName
)
\
{
nsGkAtoms
:
:
name
nullptr
nsGkAtoms
:
:
DOMAttrName
}
#
define
AttrFromDOMIf
(
name
DOMAttrName
DOMAttrValue
)
\
{
nsGkAtoms
:
:
name
nullptr
nsGkAtoms
:
:
DOMAttrName
nsGkAtoms
:
:
DOMAttrValue
}
#
define
MARKUPMAP
(
atom
new_func
r
.
.
.
)
\
{
nsGkAtoms
:
:
atom
new_func
static_cast
<
a11y
:
:
role
>
(
r
)
{
__VA_ARGS__
}
}
static
const
MarkupMapInfo
sHTMLMarkupMapList
[
]
=
{
#
include
"
HTMLMarkupMap
.
h
"
}
;
static
const
MarkupMapInfo
sMathMLMarkupMapList
[
]
=
{
#
include
"
MathMLMarkupMap
.
h
"
}
;
#
undef
MARKUPMAP
#
define
XULMAP
(
atom
.
.
.
)
{
nsGkAtoms
:
:
atom
__VA_ARGS__
}
#
define
XULMAP_TYPE
(
atom
new_type
)
\
XULMAP
(
\
atom
\
[
]
(
Element
*
aElement
LocalAccessible
*
aContext
)
-
>
LocalAccessible
*
{
\
return
new
new_type
(
aElement
aContext
-
>
Document
(
)
)
;
\
}
)
static
const
XULMarkupMapInfo
sXULMarkupMapList
[
]
=
{
#
include
"
XULMap
.
h
"
}
;
#
undef
XULMAP_TYPE
#
undef
XULMAP
#
undef
Attr
#
undef
AttrFromDOM
#
undef
AttrFromDOMIf
nsAccessibilityService
*
nsAccessibilityService
:
:
gAccessibilityService
=
nullptr
;
ApplicationAccessible
*
nsAccessibilityService
:
:
gApplicationAccessible
=
nullptr
;
xpcAccessibleApplication
*
nsAccessibilityService
:
:
gXPCApplicationAccessible
=
nullptr
;
uint32_t
nsAccessibilityService
:
:
gConsumers
=
0
;
nsAccessibilityService
:
:
nsAccessibilityService
(
)
:
mHTMLMarkupMap
(
ArrayLength
(
sHTMLMarkupMapList
)
)
mMathMLMarkupMap
(
ArrayLength
(
sMathMLMarkupMapList
)
)
mXULMarkupMap
(
ArrayLength
(
sXULMarkupMapList
)
)
{
}
nsAccessibilityService
:
:
~
nsAccessibilityService
(
)
{
NS_ASSERTION
(
IsShutdown
(
)
"
Accessibility
wasn
'
t
shutdown
!
"
)
;
gAccessibilityService
=
nullptr
;
}
NS_IMETHODIMP
nsAccessibilityService
:
:
ListenersChanged
(
nsIArray
*
aEventChanges
)
{
uint32_t
targetCount
;
nsresult
rv
=
aEventChanges
-
>
GetLength
(
&
targetCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
targetCount
;
i
+
+
)
{
nsCOMPtr
<
nsIEventListenerChange
>
change
=
do_QueryElementAt
(
aEventChanges
i
)
;
RefPtr
<
EventTarget
>
target
;
change
-
>
GetTarget
(
getter_AddRefs
(
target
)
)
;
nsIContent
*
content
(
nsIContent
:
:
FromEventTargetOrNull
(
target
)
)
;
if
(
!
content
|
|
!
content
-
>
IsHTMLElement
(
)
)
{
continue
;
}
uint32_t
changeCount
;
change
-
>
GetCountOfEventListenerChangesAffectingAccessibility
(
&
changeCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
changeCount
)
{
Document
*
ownerDoc
=
content
-
>
OwnerDoc
(
)
;
DocAccessible
*
document
=
GetExistingDocAccessible
(
ownerDoc
)
;
if
(
document
)
{
LocalAccessible
*
acc
=
document
-
>
GetAccessible
(
content
)
;
if
(
!
acc
&
&
(
content
=
=
document
-
>
GetContent
(
)
|
|
content
=
=
document
-
>
DocumentNode
(
)
-
>
GetRootElement
(
)
)
)
{
acc
=
document
;
}
if
(
!
acc
&
&
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
{
LocalAccessible
*
areaAcc
=
document
-
>
GetAccessibleEvenIfNotInMap
(
content
)
;
if
(
areaAcc
&
&
areaAcc
-
>
LocalParent
(
)
)
{
document
-
>
RecreateAccessible
(
areaAcc
-
>
LocalParent
(
)
-
>
GetContent
(
)
)
;
}
}
if
(
!
acc
&
&
nsCoreUtils
:
:
HasClickListener
(
content
)
)
{
document
-
>
ContentInserted
(
content
content
-
>
GetNextSibling
(
)
)
;
}
else
if
(
acc
)
{
if
(
(
acc
-
>
IsHTMLLink
(
)
&
&
!
acc
-
>
AsHTMLLink
(
)
-
>
IsLinked
(
)
)
|
|
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
&
&
!
acc
-
>
IsHTMLLink
(
)
)
)
{
document
-
>
RecreateAccessible
(
content
)
;
}
document
-
>
QueueCacheUpdate
(
acc
CacheDomain
:
:
Actions
)
;
}
}
}
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsAccessibilityService
DocManager
nsIObserver
nsIListenerChangeListener
nsISelectionListener
)
NS_IMETHODIMP
nsAccessibilityService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
Shutdown
(
)
;
}
return
NS_OK
;
}
void
nsAccessibilityService
:
:
NotifyOfAnchorJumpTo
(
nsIContent
*
aTargetNode
)
{
Document
*
documentNode
=
aTargetNode
-
>
GetUncomposedDoc
(
)
;
if
(
!
documentNode
)
{
return
;
}
DocAccessible
*
document
=
GetDocAccessible
(
documentNode
)
;
if
(
!
document
)
{
return
;
}
const
Accessible
*
focusedAcc
=
FocusedAccessible
(
)
;
if
(
focusedAcc
&
&
(
focusedAcc
=
=
document
|
|
focusedAcc
-
>
IsNonInteractive
(
)
)
)
{
LocalAccessible
*
targetAcc
=
document
-
>
GetAccessible
(
aTargetNode
)
;
if
(
targetAcc
)
{
nsEventShell
:
:
FireEvent
(
nsIAccessibleEvent
:
:
EVENT_SCROLLING_START
targetAcc
)
;
document
-
>
SetAnchorJump
(
nullptr
)
;
}
else
{
document
-
>
SetAnchorJump
(
aTargetNode
)
;
}
}
else
{
document
-
>
SetAnchorJump
(
aTargetNode
)
;
}
}
void
nsAccessibilityService
:
:
FireAccessibleEvent
(
uint32_t
aEvent
LocalAccessible
*
aTarget
)
{
nsEventShell
:
:
FireEvent
(
aEvent
aTarget
)
;
}
void
nsAccessibilityService
:
:
NotifyOfPossibleBoundsChange
(
mozilla
:
:
PresShell
*
aPresShell
nsIContent
*
aContent
)
{
if
(
IPCAccessibilityActive
(
)
)
{
DocAccessible
*
document
=
aPresShell
-
>
GetDocAccessible
(
)
;
if
(
document
)
{
LocalAccessible
*
accessible
=
aContent
=
=
document
-
>
GetContent
(
)
?
document
:
document
-
>
GetAccessible
(
aContent
)
;
if
(
accessible
)
{
document
-
>
QueueCacheUpdate
(
accessible
CacheDomain
:
:
Bounds
)
;
}
}
}
}
void
nsAccessibilityService
:
:
NotifyOfComputedStyleChange
(
mozilla
:
:
PresShell
*
aPresShell
nsIContent
*
aContent
)
{
DocAccessible
*
document
=
aPresShell
-
>
GetDocAccessible
(
)
;
if
(
!
document
)
{
return
;
}
LocalAccessible
*
accessible
=
aContent
=
=
document
-
>
GetContent
(
)
?
document
:
document
-
>
GetAccessible
(
aContent
)
;
if
(
!
accessible
&
&
aContent
&
&
aContent
-
>
HasChildren
(
)
&
&
!
aContent
-
>
IsInNativeAnonymousSubtree
(
)
)
{
if
(
const
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
)
{
const
auto
&
disp
=
*
frame
-
>
StyleDisplay
(
)
;
if
(
disp
.
HasTransform
(
frame
)
|
|
disp
.
mPosition
=
=
StylePositionProperty
:
:
Fixed
|
|
disp
.
mPosition
=
=
StylePositionProperty
:
:
Sticky
|
|
disp
.
IsScrollableOverflow
(
)
)
{
document
-
>
ContentInserted
(
aContent
aContent
-
>
GetNextSibling
(
)
)
;
}
}
}
else
if
(
accessible
&
&
IPCAccessibilityActive
(
)
)
{
accessible
-
>
MaybeQueueCacheUpdateForStyleChanges
(
)
;
}
}
void
nsAccessibilityService
:
:
NotifyOfResolutionChange
(
mozilla
:
:
PresShell
*
aPresShell
float
aResolution
)
{
DocAccessible
*
document
=
aPresShell
-
>
GetDocAccessible
(
)
;
if
(
document
&
&
document
-
>
IPCDoc
(
)
)
{
AutoTArray
<
mozilla
:
:
a11y
:
:
CacheData
1
>
data
;
RefPtr
<
AccAttributes
>
fields
=
new
AccAttributes
(
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
Resolution
aResolution
)
;
data
.
AppendElement
(
mozilla
:
:
a11y
:
:
CacheData
(
0
fields
)
)
;
document
-
>
IPCDoc
(
)
-
>
SendCache
(
CacheUpdateType
:
:
Update
data
)
;
}
}
void
nsAccessibilityService
:
:
NotifyOfDevPixelRatioChange
(
mozilla
:
:
PresShell
*
aPresShell
int32_t
aAppUnitsPerDevPixel
)
{
DocAccessible
*
document
=
aPresShell
-
>
GetDocAccessible
(
)
;
if
(
document
&
&
document
-
>
IPCDoc
(
)
)
{
AutoTArray
<
mozilla
:
:
a11y
:
:
CacheData
1
>
data
;
RefPtr
<
AccAttributes
>
fields
=
new
AccAttributes
(
)
;
fields
-
>
SetAttribute
(
CacheKey
:
:
AppUnitsPerDevPixel
aAppUnitsPerDevPixel
)
;
data
.
AppendElement
(
mozilla
:
:
a11y
:
:
CacheData
(
0
fields
)
)
;
document
-
>
IPCDoc
(
)
-
>
SendCache
(
CacheUpdateType
:
:
Update
data
)
;
}
}
void
nsAccessibilityService
:
:
NotifyAttrElementWillChange
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsAtom
*
aAttr
)
{
mozilla
:
:
dom
:
:
Document
*
doc
=
aElement
-
>
OwnerDoc
(
)
;
MOZ_ASSERT
(
doc
)
;
if
(
DocAccessible
*
docAcc
=
GetDocAccessible
(
doc
)
)
{
docAcc
-
>
AttrElementWillChange
(
aElement
aAttr
)
;
}
}
void
nsAccessibilityService
:
:
NotifyAttrElementChanged
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsAtom
*
aAttr
)
{
mozilla
:
:
dom
:
:
Document
*
doc
=
aElement
-
>
OwnerDoc
(
)
;
MOZ_ASSERT
(
doc
)
;
if
(
DocAccessible
*
docAcc
=
GetDocAccessible
(
doc
)
)
{
docAcc
-
>
AttrElementChanged
(
aElement
aAttr
)
;
}
}
LocalAccessible
*
nsAccessibilityService
:
:
GetRootDocumentAccessible
(
PresShell
*
aPresShell
bool
aCanCreate
)
{
PresShell
*
presShell
=
aPresShell
;
Document
*
documentNode
=
aPresShell
-
>
GetDocument
(
)
;
if
(
documentNode
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
(
documentNode
-
>
GetDocShell
(
)
)
;
if
(
treeItem
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
rootTreeItem
;
treeItem
-
>
GetInProcessRootTreeItem
(
getter_AddRefs
(
rootTreeItem
)
)
;
if
(
treeItem
!
=
rootTreeItem
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
do_QueryInterface
(
rootTreeItem
)
)
;
presShell
=
docShell
-
>
GetPresShell
(
)
;
}
return
aCanCreate
?
GetDocAccessible
(
presShell
)
:
presShell
-
>
GetDocAccessible
(
)
;
}
}
return
nullptr
;
}
void
nsAccessibilityService
:
:
NotifyOfTabPanelVisibilityChange
(
PresShell
*
aPresShell
Element
*
aPanel
bool
aNowVisible
)
{
MOZ_ASSERT
(
aPanel
-
>
GetParent
(
)
-
>
IsXULElement
(
nsGkAtoms
:
:
tabpanels
)
)
;
DocAccessible
*
document
=
GetDocAccessible
(
aPresShell
)
;
if
(
!
document
)
{
return
;
}
if
(
LocalAccessible
*
acc
=
document
-
>
GetAccessible
(
aPanel
)
)
{
RefPtr
<
AccEvent
>
event
=
new
AccStateChangeEvent
(
acc
states
:
:
OFFSCREEN
aNowVisible
)
;
document
-
>
FireDelayedEvent
(
event
)
;
}
}
void
nsAccessibilityService
:
:
ContentRangeInserted
(
PresShell
*
aPresShell
nsIContent
*
aStartChild
nsIContent
*
aEndChild
)
{
DocAccessible
*
document
=
GetDocAccessible
(
aPresShell
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
content
inserted
;
doc
:
%
p
"
document
)
;
logging
:
:
Node
(
"
container
"
aStartChild
-
>
GetParentNode
(
)
)
;
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
logging
:
:
Node
(
"
content
"
child
)
;
}
logging
:
:
MsgEnd
(
)
;
logging
:
:
Stack
(
)
;
}
#
endif
if
(
document
)
{
document
-
>
ContentInserted
(
aStartChild
aEndChild
)
;
}
}
void
nsAccessibilityService
:
:
ScheduleAccessibilitySubtreeUpdate
(
PresShell
*
aPresShell
nsIContent
*
aContent
)
{
DocAccessible
*
document
=
GetDocAccessible
(
aPresShell
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
schedule
update
;
doc
:
%
p
"
document
)
;
logging
:
:
Node
(
"
content
node
"
aContent
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
if
(
document
)
{
document
-
>
ScheduleTreeUpdate
(
aContent
)
;
}
}
void
nsAccessibilityService
:
:
ContentRemoved
(
PresShell
*
aPresShell
nsIContent
*
aChildNode
)
{
DocAccessible
*
document
=
GetDocAccessible
(
aPresShell
)
;
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgBegin
(
"
TREE
"
"
content
removed
;
doc
:
%
p
"
document
)
;
logging
:
:
Node
(
"
container
node
"
aChildNode
-
>
GetFlattenedTreeParent
(
)
)
;
logging
:
:
Node
(
"
content
node
"
aChildNode
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
if
(
document
)
{
document
-
>
ContentRemoved
(
aChildNode
)
;
}
#
ifdef
A11Y_LOG
if
(
logging
:
:
IsEnabled
(
logging
:
:
eTree
)
)
{
logging
:
:
MsgEnd
(
)
;
logging
:
:
Stack
(
)
;
}
#
endif
}
void
nsAccessibilityService
:
:
TableLayoutGuessMaybeChanged
(
PresShell
*
aPresShell
nsIContent
*
aContent
)
{
if
(
DocAccessible
*
document
=
GetDocAccessible
(
aPresShell
)
)
{
if
(
LocalAccessible
*
acc
=
document
-
>
GetAccessible
(
aContent
)
)
{
if
(
LocalAccessible
*
table
=
nsAccUtils
:
:
TableFor
(
acc
)
)
{
document
-
>
QueueCacheUpdate
(
table
CacheDomain
:
:
Table
)
;
}
}
}
}
void
nsAccessibilityService
:
:
ComboboxOptionMaybeChanged
(
PresShell
*
aPresShell
nsIContent
*
aMutatingNode
)
{
DocAccessible
*
document
=
GetDocAccessible
(
aPresShell
)
;
if
(
!
document
)
{
return
;
}
for
(
nsIContent
*
cur
=
aMutatingNode
;
cur
;
cur
=
cur
-
>
GetParent
(
)
)
{
if
(
cur
-
>
IsHTMLElement
(
nsGkAtoms
:
:
option
)
)
{
if
(
LocalAccessible
*
accessible
=
document
-
>
GetAccessible
(
cur
)
)
{
document
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_NAME_CHANGE
accessible
)
;
break
;
}
if
(
cur
-
>
IsHTMLElement
(
nsGkAtoms
:
:
select
)
)
{
break
;
}
}
}
}
void
nsAccessibilityService
:
:
UpdateText
(
PresShell
*
aPresShell
nsIContent
*
aContent
)
{
DocAccessible
*
document
=
GetDocAccessible
(
aPresShell
)
;
if
(
document
)
document
-
>
UpdateText
(
aContent
)
;
}
void
nsAccessibilityService
:
:
TreeViewChanged
(
PresShell
*
aPresShell
nsIContent
*
aContent
nsITreeView
*
aView
)
{
DocAccessible
*
document
=
GetDocAccessible
(
aPresShell
)
;
if
(
document
)
{
LocalAccessible
*
accessible
=
document
-
>
GetAccessible
(
aContent
)
;
if
(
accessible
)
{
XULTreeAccessible
*
treeAcc
=
accessible
-
>
AsXULTree
(
)
;
if
(
treeAcc
)
treeAcc
-
>
TreeViewChanged
(
aView
)
;
}
}
}
void
nsAccessibilityService
:
:
RangeValueChanged
(
PresShell
*
aPresShell
nsIContent
*
aContent
)
{
DocAccessible
*
document
=
GetDocAccessible
(
aPresShell
)
;
if
(
document
)
{
LocalAccessible
*
accessible
=
document
-
>
GetAccessible
(
aContent
)
;
if
(
accessible
)
{
document
-
>
FireDelayedEvent
(
nsIAccessibleEvent
:
:
EVENT_VALUE_CHANGE
accessible
)
;
}
}
}
void
nsAccessibilityService
:
:
UpdateImageMap
(
nsImageFrame
*
aImageFrame
)
{
PresShell
*
presShell
=
aImageFrame
-
>
PresShell
(
)
;
DocAccessible
*
document
=
GetDocAccessible
(
presShell
)
;
if
(
document
)
{
LocalAccessible
*
accessible
=
document
-
>
GetAccessible
(
aImageFrame
-
>
GetContent
(
)
)
;
if
(
accessible
)
{
HTMLImageMapAccessible
*
imageMap
=
accessible
-
>
AsImageMap
(
)
;
if
(
imageMap
)
{
imageMap
-
>
UpdateChildAreas
(
)
;
return
;
}
RecreateAccessible
(
presShell
aImageFrame
-
>
GetContent
(
)
)
;
}
}
}
void
nsAccessibilityService
:
:
UpdateLabelValue
(
PresShell
*
aPresShell
nsIContent
*
aLabelElm
const
nsString
&
aNewValue
)
{
DocAccessible
*
document
=
GetDocAccessible
(
aPresShell
)
;
if
(
document
)
{
LocalAccessible
*
accessible
=
document
-
>
GetAccessible
(
aLabelElm
)
;
if
(
accessible
)
{
XULLabelAccessible
*
xulLabel
=
accessible
-
>
AsXULLabel
(
)
;
NS_ASSERTION
(
xulLabel
"
UpdateLabelValue
was
called
for
wrong
accessible
!
"
)
;
if
(
xulLabel
)
xulLabel
-
>
UpdateLabelValue
(
aNewValue
)
;
}
}
}
void
nsAccessibilityService
:
:
PresShellActivated
(
PresShell
*
aPresShell
)
{
DocAccessible
*
document
=
aPresShell
-
>
GetDocAccessible
(
)
;
if
(
document
)
{
RootAccessible
*
rootDocument
=
document
-
>
RootAccessible
(
)
;
NS_ASSERTION
(
rootDocument
"
Entirely
broken
tree
:
no
root
document
!
"
)
;
if
(
rootDocument
)
rootDocument
-
>
DocumentActivated
(
document
)
;
}
}
void
nsAccessibilityService
:
:
RecreateAccessible
(
PresShell
*
aPresShell
nsIContent
*
aContent
)
{
DocAccessible
*
document
=
GetDocAccessible
(
aPresShell
)
;
if
(
document
)
document
-
>
RecreateAccessible
(
aContent
)
;
}
void
nsAccessibilityService
:
:
GetStringRole
(
uint32_t
aRole
nsAString
&
aString
)
{
#
define
ROLE
(
geckoRole
stringRole
ariaRole
atkRole
macRole
macSubrole
\
msaaRole
ia2Role
androidClass
iosIsElement
uiaControlType
\
nameRule
)
\
case
roles
:
:
geckoRole
:
\
aString
.
AssignLiteral
(
stringRole
)
;
\
return
;
switch
(
aRole
)
{
#
include
"
RoleMap
.
h
"
default
:
aString
.
AssignLiteral
(
"
unknown
"
)
;
return
;
}
#
undef
ROLE
}
void
nsAccessibilityService
:
:
GetStringStates
(
uint32_t
aState
uint32_t
aExtraState
nsISupports
*
*
aStringStates
)
{
RefPtr
<
DOMStringList
>
stringStates
=
GetStringStates
(
nsAccUtils
:
:
To64State
(
aState
aExtraState
)
)
;
if
(
!
stringStates
-
>
Length
(
)
)
{
stringStates
-
>
Add
(
u
"
unknown
"
_ns
)
;
}
stringStates
.
forget
(
aStringStates
)
;
}
already_AddRefed
<
DOMStringList
>
nsAccessibilityService
:
:
GetStringStates
(
uint64_t
aStates
)
const
{
RefPtr
<
DOMStringList
>
stringStates
=
new
DOMStringList
(
)
;
if
(
aStates
&
states
:
:
UNAVAILABLE
)
{
stringStates
-
>
Add
(
u
"
unavailable
"
_ns
)
;
}
if
(
aStates
&
states
:
:
SELECTED
)
{
stringStates
-
>
Add
(
u
"
selected
"
_ns
)
;
}
if
(
aStates
&
states
:
:
FOCUSED
)
{
stringStates
-
>
Add
(
u
"
focused
"
_ns
)
;
}
if
(
aStates
&
states
:
:
PRESSED
)
{
stringStates
-
>
Add
(
u
"
pressed
"
_ns
)
;
}
if
(
aStates
&
states
:
:
CHECKED
)
{
stringStates
-
>
Add
(
u
"
checked
"
_ns
)
;
}
if
(
aStates
&
states
:
:
MIXED
)
{
stringStates
-
>
Add
(
u
"
mixed
"
_ns
)
;
}
if
(
aStates
&
states
:
:
READONLY
)
{
stringStates
-
>
Add
(
u
"
readonly
"
_ns
)
;
}
if
(
aStates
&
states
:
:
HOTTRACKED
)
{
stringStates
-
>
Add
(
u
"
hottracked
"
_ns
)
;
}
if
(
aStates
&
states
:
:
DEFAULT
)
{
stringStates
-
>
Add
(
u
"
default
"
_ns
)
;
}
if
(
aStates
&
states
:
:
EXPANDED
)
{
stringStates
-
>
Add
(
u
"
expanded
"
_ns
)
;
}
if
(
aStates
&
states
:
:
COLLAPSED
)
{
stringStates
-
>
Add
(
u
"
collapsed
"
_ns
)
;
}
if
(
aStates
&
states
:
:
BUSY
)
{
stringStates
-
>
Add
(
u
"
busy
"
_ns
)
;
}
if
(
aStates
&
states
:
:
FLOATING
)
{
stringStates
-
>
Add
(
u
"
floating
"
_ns
)
;
}
if
(
aStates
&
states
:
:
ANIMATED
)
{
stringStates
-
>
Add
(
u
"
animated
"
_ns
)
;
}
if
(
aStates
&
states
:
:
INVISIBLE
)
{
stringStates
-
>
Add
(
u
"
invisible
"
_ns
)
;
}
if
(
aStates
&
states
:
:
OFFSCREEN
)
{
stringStates
-
>
Add
(
u
"
offscreen
"
_ns
)
;
}
if
(
aStates
&
states
:
:
SIZEABLE
)
{
stringStates
-
>
Add
(
u
"
sizeable
"
_ns
)
;
}
if
(
aStates
&
states
:
:
MOVEABLE
)
{
stringStates
-
>
Add
(
u
"
moveable
"
_ns
)
;
}
if
(
aStates
&
states
:
:
SELFVOICING
)
{
stringStates
-
>
Add
(
u
"
selfvoicing
"
_ns
)
;
}
if
(
aStates
&
states
:
:
FOCUSABLE
)
{
stringStates
-
>
Add
(
u
"
focusable
"
_ns
)
;
}
if
(
aStates
&
states
:
:
SELECTABLE
)
{
stringStates
-
>
Add
(
u
"
selectable
"
_ns
)
;
}
if
(
aStates
&
states
:
:
LINKED
)
{
stringStates
-
>
Add
(
u
"
linked
"
_ns
)
;
}
if
(
aStates
&
states
:
:
TRAVERSED
)
{
stringStates
-
>
Add
(
u
"
traversed
"
_ns
)
;
}
if
(
aStates
&
states
:
:
MULTISELECTABLE
)
{
stringStates
-
>
Add
(
u
"
multiselectable
"
_ns
)
;
}
if
(
aStates
&
states
:
:
EXTSELECTABLE
)
{
stringStates
-
>
Add
(
u
"
extselectable
"
_ns
)
;
}
if
(
aStates
&
states
:
:
PROTECTED
)
{
stringStates
-
>
Add
(
u
"
protected
"
_ns
)
;
}
if
(
aStates
&
states
:
:
HASPOPUP
)
{
stringStates
-
>
Add
(
u
"
haspopup
"
_ns
)
;
}
if
(
aStates
&
states
:
:
REQUIRED
)
{
stringStates
-
>
Add
(
u
"
required
"
_ns
)
;
}
if
(
aStates
&
states
:
:
ALERT
)
{
stringStates
-
>
Add
(
u
"
alert
"
_ns
)
;
}
if
(
aStates
&
states
:
:
INVALID
)
{
stringStates
-
>
Add
(
u
"
invalid
"
_ns
)
;
}
if
(
aStates
&
states
:
:
CHECKABLE
)
{
stringStates
-
>
Add
(
u
"
checkable
"
_ns
)
;
}
if
(
aStates
&
states
:
:
SUPPORTS_AUTOCOMPLETION
)
{
stringStates
-
>
Add
(
u
"
autocompletion
"
_ns
)
;
}
if
(
aStates
&
states
:
:
DEFUNCT
)
{
stringStates
-
>
Add
(
u
"
defunct
"
_ns
)
;
}
if
(
aStates
&
states
:
:
SELECTABLE_TEXT
)
{
stringStates
-
>
Add
(
u
"
selectable
text
"
_ns
)
;
}
if
(
aStates
&
states
:
:
EDITABLE
)
{
stringStates
-
>
Add
(
u
"
editable
"
_ns
)
;
}
if
(
aStates
&
states
:
:
ACTIVE
)
{
stringStates
-
>
Add
(
u
"
active
"
_ns
)
;
}
if
(
aStates
&
states
:
:
MODAL
)
{
stringStates
-
>
Add
(
u
"
modal
"
_ns
)
;
}
if
(
aStates
&
states
:
:
MULTI_LINE
)
{
stringStates
-
>
Add
(
u
"
multi
line
"
_ns
)
;
}
if
(
aStates
&
states
:
:
HORIZONTAL
)
{
stringStates
-
>
Add
(
u
"
horizontal
"
_ns
)
;
}
if
(
aStates
&
states
:
:
OPAQUE1
)
{
stringStates
-
>
Add
(
u
"
opaque
"
_ns
)
;
}
if
(
aStates
&
states
:
:
SINGLE_LINE
)
{
stringStates
-
>
Add
(
u
"
single
line
"
_ns
)
;
}
if
(
aStates
&
states
:
:
TRANSIENT
)
{
stringStates
-
>
Add
(
u
"
transient
"
_ns
)
;
}
if
(
aStates
&
states
:
:
VERTICAL
)
{
stringStates
-
>
Add
(
u
"
vertical
"
_ns
)
;
}
if
(
aStates
&
states
:
:
STALE
)
{
stringStates
-
>
Add
(
u
"
stale
"
_ns
)
;
}
if
(
aStates
&
states
:
:
ENABLED
)
{
stringStates
-
>
Add
(
u
"
enabled
"
_ns
)
;
}
if
(
aStates
&
states
:
:
SENSITIVE
)
{
stringStates
-
>
Add
(
u
"
sensitive
"
_ns
)
;
}
if
(
aStates
&
states
:
:
EXPANDABLE
)
{
stringStates
-
>
Add
(
u
"
expandable
"
_ns
)
;
}
if
(
aStates
&
states
:
:
PINNED
)
{
stringStates
-
>
Add
(
u
"
pinned
"
_ns
)
;
}
if
(
aStates
&
states
:
:
CURRENT
)
{
stringStates
-
>
Add
(
u
"
current
"
_ns
)
;
}
return
stringStates
.
forget
(
)
;
}
void
nsAccessibilityService
:
:
GetStringEventType
(
uint32_t
aEventType
nsAString
&
aString
)
{
static_assert
(
nsIAccessibleEvent
:
:
EVENT_LAST_ENTRY
=
=
ArrayLength
(
kEventTypeNames
)
"
nsIAccessibleEvent
constants
are
out
of
sync
to
kEventTypeNames
"
)
;
if
(
aEventType
>
=
ArrayLength
(
kEventTypeNames
)
)
{
aString
.
AssignLiteral
(
"
unknown
"
)
;
return
;
}
aString
.
AssignASCII
(
kEventTypeNames
[
aEventType
]
)
;
}
void
nsAccessibilityService
:
:
GetStringEventType
(
uint32_t
aEventType
nsACString
&
aString
)
{
MOZ_ASSERT
(
nsIAccessibleEvent
:
:
EVENT_LAST_ENTRY
=
=
ArrayLength
(
kEventTypeNames
)
"
nsIAccessibleEvent
constants
are
out
of
sync
to
kEventTypeNames
"
)
;
if
(
aEventType
>
=
ArrayLength
(
kEventTypeNames
)
)
{
aString
.
AssignLiteral
(
"
unknown
"
)
;
return
;
}
aString
=
nsDependentCString
(
kEventTypeNames
[
aEventType
]
)
;
}
void
nsAccessibilityService
:
:
GetStringRelationType
(
uint32_t
aRelationType
nsAString
&
aString
)
{
NS_ENSURE_TRUE_VOID
(
aRelationType
<
=
static_cast
<
uint32_t
>
(
RelationType
:
:
LAST
)
)
;
#
define
RELATIONTYPE
(
geckoType
geckoTypeName
atkType
msaaType
ia2Type
)
\
case
RelationType
:
:
geckoType
:
\
aString
.
AssignLiteral
(
geckoTypeName
)
;
\
return
;
RelationType
relationType
=
static_cast
<
RelationType
>
(
aRelationType
)
;
switch
(
relationType
)
{
#
include
"
RelationTypeMap
.
h
"
default
:
aString
.
AssignLiteral
(
"
unknown
"
)
;
return
;
}
#
undef
RELATIONTYPE
}
LocalAccessible
*
nsAccessibilityService
:
:
CreateAccessible
(
nsINode
*
aNode
LocalAccessible
*
aContext
bool
*
aIsSubtreeHidden
)
{
MOZ_ASSERT
(
aContext
"
No
context
provided
"
)
;
MOZ_ASSERT
(
aNode
"
No
node
to
create
an
accessible
for
"
)
;
MOZ_ASSERT
(
gConsumers
"
No
creation
after
shutdown
"
)
;
if
(
aIsSubtreeHidden
)
*
aIsSubtreeHidden
=
false
;
DocAccessible
*
document
=
aContext
-
>
Document
(
)
;
MOZ_ASSERT
(
!
document
-
>
GetAccessible
(
aNode
)
"
We
already
have
an
accessible
for
this
node
.
"
)
;
if
(
aNode
-
>
IsDocument
(
)
)
{
return
GetDocAccessible
(
aNode
-
>
AsDocument
(
)
)
;
}
if
(
!
aNode
-
>
GetComposedDoc
(
)
)
{
NS_WARNING
(
"
Creating
accessible
for
node
with
no
document
"
)
;
return
nullptr
;
}
if
(
aNode
-
>
OwnerDoc
(
)
!
=
document
-
>
DocumentNode
(
)
)
{
NS_ERROR
(
"
Creating
accessible
for
wrong
document
"
)
;
return
nullptr
;
}
if
(
!
aNode
-
>
IsContent
(
)
)
return
nullptr
;
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
if
(
aria
:
:
HasDefinedARIAHidden
(
content
)
)
{
if
(
aIsSubtreeHidden
)
{
*
aIsSubtreeHidden
=
true
;
}
return
nullptr
;
}
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
if
(
!
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
|
|
frame
-
>
StyleUI
(
)
-
>
IsInert
(
)
)
{
return
nullptr
;
}
}
else
if
(
nsCoreUtils
:
:
CanCreateAccessibleWithoutFrame
(
content
)
)
{
const
nsRoleMapEntry
*
roleMapEntry
=
aria
:
:
GetRoleMap
(
content
-
>
AsElement
(
)
)
;
RefPtr
<
LocalAccessible
>
newAcc
=
MaybeCreateSpecificARIAAccessible
(
roleMapEntry
aContext
content
document
)
;
const
MarkupMapInfo
*
markupMap
=
nullptr
;
if
(
!
newAcc
)
{
markupMap
=
GetMarkupMapInfoFor
(
content
)
;
if
(
markupMap
&
&
markupMap
-
>
new_func
)
{
newAcc
=
markupMap
-
>
new_func
(
content
-
>
AsElement
(
)
aContext
)
;
}
}
if
(
!
newAcc
&
&
content
-
>
IsSVGElement
(
)
)
{
newAcc
=
MaybeCreateSVGAccessible
(
content
document
)
;
}
const
bool
hasNonPresentationalARIARole
=
roleMapEntry
&
&
!
roleMapEntry
-
>
Is
(
nsGkAtoms
:
:
presentation
)
&
&
!
roleMapEntry
-
>
Is
(
nsGkAtoms
:
:
none
)
;
if
(
!
newAcc
&
&
(
hasNonPresentationalARIARole
|
|
MustBeAccessible
(
content
document
)
)
)
{
newAcc
=
new
HyperTextAccessible
(
content
document
)
;
}
if
(
!
newAcc
&
&
markupMap
&
&
(
!
roleMapEntry
|
|
hasNonPresentationalARIARole
)
)
{
newAcc
=
new
HyperTextAccessible
(
content
document
)
;
}
if
(
newAcc
)
{
document
-
>
BindToDocument
(
newAcc
roleMapEntry
)
;
}
return
newAcc
;
}
else
{
if
(
aIsSubtreeHidden
)
{
*
aIsSubtreeHidden
=
true
;
}
return
nullptr
;
}
if
(
frame
-
>
IsHiddenByContentVisibilityOnAnyAncestor
(
nsIFrame
:
:
IncludeContentVisibility
:
:
Hidden
)
)
{
if
(
aIsSubtreeHidden
)
{
*
aIsSubtreeHidden
=
true
;
}
return
nullptr
;
}
if
(
nsMenuPopupFrame
*
popupFrame
=
do_QueryFrame
(
frame
)
)
{
if
(
content
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
tooltip
nsGkAtoms
:
:
panel
)
)
{
nsPopupState
popupState
=
popupFrame
-
>
PopupState
(
)
;
if
(
popupState
=
=
ePopupHiding
|
|
popupState
=
=
ePopupInvisible
|
|
popupState
=
=
ePopupClosed
)
{
if
(
aIsSubtreeHidden
)
{
*
aIsSubtreeHidden
=
true
;
}
return
nullptr
;
}
}
}
if
(
frame
-
>
GetContent
(
)
!
=
content
)
{
#
ifdef
DEBUG
nsImageFrame
*
imageFrame
=
do_QueryFrame
(
frame
)
;
NS_ASSERTION
(
imageFrame
&
&
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
"
Unknown
case
of
not
main
content
for
the
frame
!
"
)
;
#
endif
return
nullptr
;
}
#
ifdef
DEBUG
nsImageFrame
*
imageFrame
=
do_QueryFrame
(
frame
)
;
NS_ASSERTION
(
!
imageFrame
|
|
!
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
"
Image
map
manages
the
area
accessible
creation
!
"
)
;
#
endif
RefPtr
<
LocalAccessible
>
newAcc
;
if
(
content
-
>
IsText
(
)
)
{
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
0
UINT32_MAX
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInContentText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
if
(
text
.
mString
.
IsEmpty
(
)
|
|
(
aContext
-
>
IsTableRow
(
)
&
&
nsCoreUtils
:
:
IsWhitespaceString
(
text
.
mString
)
)
)
{
if
(
aIsSubtreeHidden
)
*
aIsSubtreeHidden
=
true
;
return
nullptr
;
}
newAcc
=
CreateAccessibleByFrameType
(
frame
content
aContext
)
;
MOZ_ASSERT
(
newAcc
"
Accessible
not
created
for
text
node
!
"
)
;
document
-
>
BindToDocument
(
newAcc
nullptr
)
;
if
(
auto
cssAlt
=
CssAltContent
(
content
)
)
{
nsAutoString
text
;
cssAlt
.
AppendToString
(
text
)
;
newAcc
-
>
AsTextLeaf
(
)
-
>
SetText
(
text
)
;
}
else
{
newAcc
-
>
AsTextLeaf
(
)
-
>
SetText
(
text
.
mString
)
;
}
return
newAcc
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
map
)
)
{
if
(
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
frame
frame
-
>
GetParent
(
)
)
.
IsEmpty
(
)
)
{
if
(
aIsSubtreeHidden
)
*
aIsSubtreeHidden
=
true
;
return
nullptr
;
}
newAcc
=
new
HyperTextAccessible
(
content
document
)
;
document
-
>
BindToDocument
(
newAcc
aria
:
:
GetRoleMap
(
content
-
>
AsElement
(
)
)
)
;
return
newAcc
;
}
const
nsRoleMapEntry
*
roleMapEntry
=
aria
:
:
GetRoleMap
(
content
-
>
AsElement
(
)
)
;
if
(
roleMapEntry
&
&
(
roleMapEntry
-
>
Is
(
nsGkAtoms
:
:
presentation
)
|
|
roleMapEntry
-
>
Is
(
nsGkAtoms
:
:
none
)
)
)
{
if
(
MustBeAccessible
(
content
document
)
)
{
roleMapEntry
=
nullptr
;
}
else
if
(
MustBeGenericAccessible
(
content
document
)
)
{
roleMapEntry
=
nullptr
;
newAcc
=
new
EnumRoleHyperTextAccessible
<
roles
:
:
TEXT_CONTAINER
>
(
content
document
)
;
}
else
{
return
nullptr
;
}
}
if
(
!
newAcc
&
&
frame
-
>
AccessibleType
(
)
!
=
eOuterDocType
)
{
newAcc
=
MaybeCreateSpecificARIAAccessible
(
roleMapEntry
aContext
content
document
)
;
}
if
(
!
newAcc
&
&
content
-
>
IsHTMLElement
(
)
)
{
const
MarkupMapInfo
*
markupMap
=
mHTMLMarkupMap
.
Get
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
if
(
markupMap
&
&
markupMap
-
>
new_func
)
{
newAcc
=
markupMap
-
>
new_func
(
content
-
>
AsElement
(
)
aContext
)
;
}
if
(
!
newAcc
)
{
newAcc
=
CreateAccessibleByFrameType
(
frame
content
aContext
)
;
}
if
(
!
roleMapEntry
&
&
newAcc
&
&
aContext
-
>
HasStrongARIARole
(
)
)
{
if
(
frame
-
>
AccessibleType
(
)
=
=
eHTMLTableRowType
)
{
const
nsRoleMapEntry
*
contextRoleMap
=
aContext
-
>
ARIARoleMap
(
)
;
if
(
!
contextRoleMap
-
>
IsOfType
(
eTable
)
)
{
roleMapEntry
=
&
aria
:
:
gEmptyRoleMap
;
}
}
else
if
(
frame
-
>
AccessibleType
(
)
=
=
eHTMLTableCellType
&
&
aContext
-
>
ARIARoleMap
(
)
=
=
&
aria
:
:
gEmptyRoleMap
)
{
roleMapEntry
=
&
aria
:
:
gEmptyRoleMap
;
}
else
if
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
li
nsGkAtoms
:
:
dd
)
|
|
frame
-
>
AccessibleType
(
)
=
=
eHTMLLiType
)
{
const
nsRoleMapEntry
*
contextRoleMap
=
aContext
-
>
ARIARoleMap
(
)
;
if
(
!
contextRoleMap
-
>
IsOfType
(
eList
)
)
{
roleMapEntry
=
&
aria
:
:
gEmptyRoleMap
;
}
}
}
}
if
(
!
newAcc
&
&
content
-
>
IsXULElement
(
)
)
{
if
(
content
-
>
IsXULElement
(
nsGkAtoms
:
:
panel
)
)
{
nsMenuPopupFrame
*
popupFrame
=
do_QueryFrame
(
frame
)
;
if
(
!
popupFrame
)
{
return
nullptr
;
}
nsPopupState
popupState
=
popupFrame
-
>
PopupState
(
)
;
if
(
popupState
=
=
ePopupHiding
|
|
popupState
=
=
ePopupInvisible
|
|
popupState
=
=
ePopupClosed
)
{
return
nullptr
;
}
}
const
XULMarkupMapInfo
*
xulMap
=
mXULMarkupMap
.
Get
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
if
(
xulMap
&
&
xulMap
-
>
new_func
)
{
newAcc
=
xulMap
-
>
new_func
(
content
-
>
AsElement
(
)
aContext
)
;
}
if
(
!
newAcc
&
&
aContext
-
>
IsXULTabpanels
(
)
&
&
content
-
>
GetParent
(
)
=
=
aContext
-
>
GetContent
(
)
)
{
LayoutFrameType
frameType
=
frame
-
>
Type
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
FlexContainer
|
|
frameType
=
=
LayoutFrameType
:
:
ScrollContainer
)
{
newAcc
=
new
XULTabpanelAccessible
(
content
document
)
;
}
}
}
if
(
!
newAcc
)
{
if
(
content
-
>
IsSVGElement
(
)
)
{
newAcc
=
MaybeCreateSVGAccessible
(
content
document
)
;
}
else
if
(
content
-
>
IsMathMLElement
(
)
)
{
const
MarkupMapInfo
*
markupMap
=
mMathMLMarkupMap
.
Get
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
if
(
markupMap
&
&
markupMap
-
>
new_func
)
{
newAcc
=
markupMap
-
>
new_func
(
content
-
>
AsElement
(
)
aContext
)
;
}
if
(
!
newAcc
&
&
!
content
-
>
IsAnyOfMathMLElements
(
nsGkAtoms
:
:
annotation_
nsGkAtoms
:
:
annotation_xml_
nsGkAtoms
:
:
mpadded_
nsGkAtoms
:
:
mphantom_
nsGkAtoms
:
:
maligngroup_
nsGkAtoms
:
:
malignmark_
nsGkAtoms
:
:
mspace_
nsGkAtoms
:
:
semantics_
)
)
{
newAcc
=
new
HyperTextAccessible
(
content
document
)
;
}
}
else
if
(
content
-
>
IsGeneratedContentContainerForMarker
(
)
)
{
if
(
aContext
-
>
IsHTMLListItem
(
)
)
{
newAcc
=
new
HTMLListBulletAccessible
(
content
document
)
;
}
if
(
aIsSubtreeHidden
)
{
*
aIsSubtreeHidden
=
true
;
}
}
}
if
(
!
newAcc
&
&
!
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
content
-
>
GetParent
(
)
&
&
(
roleMapEntry
|
|
MustBeAccessible
(
content
document
)
|
|
(
content
-
>
IsHTMLElement
(
)
&
&
nsCoreUtils
:
:
HasClickListener
(
content
)
)
)
)
{
if
(
content
-
>
IsHTMLElement
(
)
|
|
content
-
>
IsMathMLElement
(
)
|
|
content
-
>
IsSVGElement
(
nsGkAtoms
:
:
foreignObject
)
)
{
newAcc
=
new
HyperTextAccessible
(
content
document
)
;
}
else
{
newAcc
=
new
AccessibleWrap
(
content
document
)
;
}
}
else
if
(
!
newAcc
&
&
MustBeGenericAccessible
(
content
document
)
)
{
newAcc
=
new
EnumRoleHyperTextAccessible
<
roles
:
:
TEXT_CONTAINER
>
(
content
document
)
;
}
if
(
newAcc
)
{
document
-
>
BindToDocument
(
newAcc
roleMapEntry
)
;
}
return
newAcc
;
}
#
if
defined
(
ANDROID
)
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
static
Maybe
<
Monitor
>
sAndroidMonitor
;
mozilla
:
:
Monitor
&
nsAccessibilityService
:
:
GetAndroidMonitor
(
)
{
if
(
!
sAndroidMonitor
.
isSome
(
)
)
{
sAndroidMonitor
.
emplace
(
"
nsAccessibility
:
:
sAndroidMonitor
"
)
;
}
return
*
sAndroidMonitor
;
}
#
endif
bool
nsAccessibilityService
:
:
Init
(
)
{
AUTO_PROFILER_MARKER_TEXT
(
"
nsAccessibilityService
:
:
Init
"
A11Y
{
}
"
"
_ns
)
;
if
(
!
DocManager
:
:
Init
(
)
)
return
false
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
return
false
;
observerService
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
#
if
defined
(
XP_WIN
)
if
(
XRE_IsParentProcess
(
)
)
{
Compatibility
:
:
Init
(
)
;
}
#
endif
nsCOMPtr
<
nsIEventListenerService
>
eventListenerService
=
do_GetService
(
"
mozilla
.
org
/
eventlistenerservice
;
1
"
)
;
if
(
!
eventListenerService
)
return
false
;
eventListenerService
-
>
AddListenerChangeListener
(
this
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sHTMLMarkupMapList
)
;
i
+
+
)
{
mHTMLMarkupMap
.
InsertOrUpdate
(
sHTMLMarkupMapList
[
i
]
.
tag
&
sHTMLMarkupMapList
[
i
]
)
;
}
for
(
const
auto
&
info
:
sMathMLMarkupMapList
)
{
mMathMLMarkupMap
.
InsertOrUpdate
(
info
.
tag
&
info
)
;
}
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sXULMarkupMapList
)
;
i
+
+
)
{
mXULMarkupMap
.
InsertOrUpdate
(
sXULMarkupMapList
[
i
]
.
tag
&
sXULMarkupMapList
[
i
]
)
;
}
#
ifdef
A11Y_LOG
logging
:
:
CheckEnv
(
)
;
#
endif
gAccessibilityService
=
this
;
NS_ADDREF
(
gAccessibilityService
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gApplicationAccessible
=
new
ApplicationAccessibleWrap
(
)
;
}
else
{
gApplicationAccessible
=
new
ApplicationAccessible
(
)
;
}
NS_ADDREF
(
gApplicationAccessible
)
;
gApplicationAccessible
-
>
Init
(
)
;
CrashReporter
:
:
RecordAnnotationCString
(
CrashReporter
:
:
Annotation
:
:
Accessibility
"
Active
"
)
;
if
(
XRE_IsParentProcess
(
)
)
PlatformInit
(
)
;
statistics
:
:
A11yInitialized
(
)
;
static
const
char16_t
kInitIndicator
[
]
=
{
'
1
'
0
}
;
observerService
-
>
NotifyObservers
(
nullptr
"
a11y
-
init
-
or
-
shutdown
"
kInitIndicator
)
;
return
true
;
}
void
nsAccessibilityService
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
gConsumers
"
Accessibility
was
shutdown
already
"
)
;
UnsetConsumers
(
eXPCOM
|
eMainProcess
|
ePlatformAPI
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
}
DocManager
:
:
Shutdown
(
)
;
SelectionManager
:
:
Shutdown
(
)
;
if
(
XRE_IsParentProcess
(
)
)
PlatformShutdown
(
)
;
gApplicationAccessible
-
>
Shutdown
(
)
;
NS_RELEASE
(
gApplicationAccessible
)
;
gApplicationAccessible
=
nullptr
;
NS_IF_RELEASE
(
gXPCApplicationAccessible
)
;
gXPCApplicationAccessible
=
nullptr
;
#
if
defined
(
ANDROID
)
MonitorAutoLock
mal
(
GetAndroidMonitor
(
)
)
;
#
endif
NS_RELEASE
(
gAccessibilityService
)
;
gAccessibilityService
=
nullptr
;
if
(
observerService
)
{
static
const
char16_t
kShutdownIndicator
[
]
=
{
'
0
'
0
}
;
observerService
-
>
NotifyObservers
(
nullptr
"
a11y
-
init
-
or
-
shutdown
"
kShutdownIndicator
)
;
}
}
already_AddRefed
<
LocalAccessible
>
nsAccessibilityService
:
:
CreateAccessibleByFrameType
(
nsIFrame
*
aFrame
nsIContent
*
aContent
LocalAccessible
*
aContext
)
{
DocAccessible
*
document
=
aContext
-
>
Document
(
)
;
RefPtr
<
LocalAccessible
>
newAcc
;
switch
(
aFrame
-
>
AccessibleType
(
)
)
{
case
eNoType
:
return
nullptr
;
case
eHTMLBRType
:
newAcc
=
new
HTMLBRAccessible
(
aContent
document
)
;
break
;
case
eHTMLButtonType
:
newAcc
=
new
HTMLButtonAccessible
(
aContent
document
)
;
break
;
case
eHTMLCanvasType
:
newAcc
=
new
HTMLCanvasAccessible
(
aContent
document
)
;
break
;
case
eHTMLCaptionType
:
if
(
aContext
-
>
IsTable
(
)
&
&
aContext
-
>
GetContent
(
)
=
=
aContent
-
>
GetParent
(
)
)
{
newAcc
=
new
HTMLCaptionAccessible
(
aContent
document
)
;
}
break
;
case
eHTMLCheckboxType
:
newAcc
=
new
CheckboxAccessible
(
aContent
document
)
;
break
;
case
eHTMLComboboxType
:
newAcc
=
new
HTMLComboboxAccessible
(
aContent
document
)
;
break
;
case
eHTMLFileInputType
:
newAcc
=
new
HTMLFileInputAccessible
(
aContent
document
)
;
break
;
case
eHTMLGroupboxType
:
newAcc
=
new
HTMLGroupboxAccessible
(
aContent
document
)
;
break
;
case
eHTMLHRType
:
newAcc
=
new
HTMLHRAccessible
(
aContent
document
)
;
break
;
case
eHTMLImageMapType
:
newAcc
=
new
HTMLImageMapAccessible
(
aContent
document
)
;
break
;
case
eHTMLLiType
:
if
(
aContext
-
>
IsList
(
)
&
&
aContext
-
>
GetContent
(
)
=
=
aContent
-
>
GetParent
(
)
)
{
newAcc
=
new
HTMLLIAccessible
(
aContent
document
)
;
}
else
{
newAcc
=
new
HyperTextAccessible
(
aContent
document
)
;
}
break
;
case
eHTMLSelectListType
:
newAcc
=
new
HTMLSelectListAccessible
(
aContent
document
)
;
break
;
case
eHTMLMediaType
:
newAcc
=
new
EnumRoleAccessible
<
roles
:
:
GROUPING
>
(
aContent
document
)
;
break
;
case
eHTMLRadioButtonType
:
newAcc
=
new
HTMLRadioButtonAccessible
(
aContent
document
)
;
break
;
case
eHTMLRangeType
:
newAcc
=
new
HTMLRangeAccessible
(
aContent
document
)
;
break
;
case
eHTMLSpinnerType
:
newAcc
=
new
HTMLSpinnerAccessible
(
aContent
document
)
;
break
;
case
eHTMLTableType
:
case
eHTMLTableCellType
:
newAcc
=
new
HyperTextAccessible
(
aContent
document
)
;
break
;
case
eHTMLTableRowType
:
break
;
case
eHTMLTextFieldType
:
newAcc
=
new
HTMLTextFieldAccessible
(
aContent
document
)
;
break
;
case
eHyperTextType
:
{
if
(
aContext
-
>
IsTable
(
)
|
|
aContext
-
>
IsTableRow
(
)
)
{
return
nullptr
;
}
if
(
!
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
nsGkAtoms
:
:
div
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tbody
)
)
{
newAcc
=
new
HyperTextAccessible
(
aContent
document
)
;
}
break
;
}
case
eImageType
:
if
(
aContent
-
>
IsElement
(
)
&
&
ShouldCreateImgAccessible
(
aContent
-
>
AsElement
(
)
document
)
)
{
newAcc
=
new
ImageAccessible
(
aContent
document
)
;
}
break
;
case
eOuterDocType
:
newAcc
=
new
OuterDocAccessible
(
aContent
document
)
;
break
;
case
eTextLeafType
:
newAcc
=
new
TextLeafAccessible
(
aContent
document
)
;
break
;
default
:
MOZ_ASSERT
(
false
)
;
break
;
}
return
newAcc
.
forget
(
)
;
}
void
nsAccessibilityService
:
:
MarkupAttributes
(
Accessible
*
aAcc
AccAttributes
*
aAttributes
)
const
{
const
mozilla
:
:
a11y
:
:
MarkupMapInfo
*
markupMap
=
GetMarkupMapInfoFor
(
aAcc
)
;
if
(
!
markupMap
)
return
;
dom
:
:
Element
*
el
=
aAcc
-
>
IsLocal
(
)
?
aAcc
-
>
AsLocal
(
)
-
>
Elm
(
)
:
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
markupMap
-
>
attrs
)
;
i
+
+
)
{
const
MarkupAttrInfo
*
info
=
markupMap
-
>
attrs
+
i
;
if
(
!
info
-
>
name
)
break
;
if
(
info
-
>
DOMAttrName
)
{
if
(
!
el
)
{
continue
;
}
if
(
info
-
>
DOMAttrValue
)
{
if
(
el
-
>
AttrValueIs
(
kNameSpaceID_None
info
-
>
DOMAttrName
info
-
>
DOMAttrValue
eCaseMatters
)
)
{
aAttributes
-
>
SetAttribute
(
info
-
>
name
info
-
>
DOMAttrValue
)
;
}
continue
;
}
nsString
value
;
el
-
>
GetAttr
(
info
-
>
DOMAttrName
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
aAttributes
-
>
SetAttribute
(
info
-
>
name
std
:
:
move
(
value
)
)
;
}
continue
;
}
aAttributes
-
>
SetAttribute
(
info
-
>
name
info
-
>
value
)
;
}
}
LocalAccessible
*
nsAccessibilityService
:
:
AddNativeRootAccessible
(
void
*
aAtkAccessible
)
{
#
ifdef
MOZ_ACCESSIBILITY_ATK
ApplicationAccessible
*
applicationAcc
=
ApplicationAcc
(
)
;
if
(
!
applicationAcc
)
return
nullptr
;
GtkWindowAccessible
*
nativeWnd
=
new
GtkWindowAccessible
(
static_cast
<
AtkObject
*
>
(
aAtkAccessible
)
)
;
if
(
applicationAcc
-
>
AppendChild
(
nativeWnd
)
)
return
nativeWnd
;
#
endif
return
nullptr
;
}
void
nsAccessibilityService
:
:
RemoveNativeRootAccessible
(
LocalAccessible
*
aAccessible
)
{
#
ifdef
MOZ_ACCESSIBILITY_ATK
ApplicationAccessible
*
applicationAcc
=
ApplicationAcc
(
)
;
if
(
applicationAcc
)
applicationAcc
-
>
RemoveChild
(
aAccessible
)
;
#
endif
}
bool
nsAccessibilityService
:
:
HasAccessible
(
nsINode
*
aDOMNode
)
{
if
(
!
aDOMNode
)
return
false
;
Document
*
document
=
aDOMNode
-
>
OwnerDoc
(
)
;
if
(
!
document
)
return
false
;
DocAccessible
*
docAcc
=
GetExistingDocAccessible
(
aDOMNode
-
>
OwnerDoc
(
)
)
;
if
(
!
docAcc
)
return
false
;
return
docAcc
-
>
HasAccessible
(
aDOMNode
)
;
}
void
nsAccessibilityService
:
:
SetConsumers
(
uint32_t
aConsumers
bool
aNotify
)
{
if
(
gConsumers
&
aConsumers
)
{
return
;
}
gConsumers
|
=
aConsumers
;
if
(
aNotify
)
{
NotifyOfConsumersChange
(
)
;
}
}
void
nsAccessibilityService
:
:
UnsetConsumers
(
uint32_t
aConsumers
)
{
if
(
!
(
gConsumers
&
aConsumers
)
)
{
return
;
}
gConsumers
&
=
~
aConsumers
;
NotifyOfConsumersChange
(
)
;
}
void
nsAccessibilityService
:
:
GetConsumers
(
nsAString
&
aString
)
{
const
char16_t
*
kJSONFmt
=
u
"
{
\
"
XPCOM
\
"
:
%
s
\
"
MainProcess
\
"
:
%
s
\
"
PlatformAPI
\
"
:
%
s
}
"
;
nsString
json
;
nsTextFormatter
:
:
ssprintf
(
json
kJSONFmt
gConsumers
&
eXPCOM
?
"
true
"
:
"
false
"
gConsumers
&
eMainProcess
?
"
true
"
:
"
false
"
gConsumers
&
ePlatformAPI
?
"
true
"
:
"
false
"
)
;
aString
.
Assign
(
json
)
;
}
void
nsAccessibilityService
:
:
NotifyOfConsumersChange
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
{
return
;
}
nsAutoString
consumers
;
GetConsumers
(
consumers
)
;
observerService
-
>
NotifyObservers
(
nullptr
"
a11y
-
consumers
-
changed
"
consumers
.
get
(
)
)
;
}
const
mozilla
:
:
a11y
:
:
MarkupMapInfo
*
nsAccessibilityService
:
:
GetMarkupMapInfoFor
(
Accessible
*
aAcc
)
const
{
if
(
LocalAccessible
*
localAcc
=
aAcc
-
>
AsLocal
(
)
)
{
return
localAcc
-
>
HasOwnContent
(
)
?
GetMarkupMapInfoFor
(
localAcc
-
>
GetContent
(
)
)
:
nullptr
;
}
return
mHTMLMarkupMap
.
Get
(
aAcc
-
>
TagName
(
)
)
;
}
nsAccessibilityService
*
GetOrCreateAccService
(
uint32_t
aNewConsumer
)
{
if
(
PlatformDisabledState
(
)
=
=
ePlatformIsDisabled
)
{
return
nullptr
;
}
if
(
!
nsAccessibilityService
:
:
gAccessibilityService
)
{
RefPtr
<
nsAccessibilityService
>
service
=
new
nsAccessibilityService
(
)
;
if
(
!
service
-
>
Init
(
)
)
{
service
-
>
Shutdown
(
)
;
return
nullptr
;
}
}
MOZ_ASSERT
(
nsAccessibilityService
:
:
gAccessibilityService
"
LocalAccessible
service
is
not
initialized
.
"
)
;
nsAccessibilityService
:
:
gAccessibilityService
-
>
SetConsumers
(
aNewConsumer
)
;
return
nsAccessibilityService
:
:
gAccessibilityService
;
}
void
MaybeShutdownAccService
(
uint32_t
aFormerConsumer
)
{
nsAccessibilityService
*
accService
=
nsAccessibilityService
:
:
gAccessibilityService
;
if
(
!
accService
|
|
nsAccessibilityService
:
:
IsShutdown
(
)
)
{
return
;
}
if
(
nsCoreUtils
:
:
AccEventObserversExist
(
)
|
|
xpcAccessibilityService
:
:
IsInUse
(
)
|
|
accService
-
>
HasXPCDocuments
(
)
)
{
accService
-
>
SetConsumers
(
nsAccessibilityService
:
:
eXPCOM
false
)
;
if
(
aFormerConsumer
!
=
nsAccessibilityService
:
:
eXPCOM
)
{
accService
-
>
UnsetConsumers
(
aFormerConsumer
)
;
}
return
;
}
if
(
nsAccessibilityService
:
:
gConsumers
&
~
aFormerConsumer
)
{
accService
-
>
UnsetConsumers
(
aFormerConsumer
)
;
}
else
{
accService
-
>
Shutdown
(
)
;
}
}
namespace
mozilla
{
namespace
a11y
{
FocusManager
*
FocusMgr
(
)
{
return
nsAccessibilityService
:
:
gAccessibilityService
;
}
SelectionManager
*
SelectionMgr
(
)
{
return
nsAccessibilityService
:
:
gAccessibilityService
;
}
ApplicationAccessible
*
ApplicationAcc
(
)
{
return
nsAccessibilityService
:
:
gApplicationAccessible
;
}
xpcAccessibleApplication
*
XPCApplicationAcc
(
)
{
if
(
!
nsAccessibilityService
:
:
gXPCApplicationAccessible
&
&
nsAccessibilityService
:
:
gApplicationAccessible
)
{
nsAccessibilityService
:
:
gXPCApplicationAccessible
=
new
xpcAccessibleApplication
(
nsAccessibilityService
:
:
gApplicationAccessible
)
;
NS_ADDREF
(
nsAccessibilityService
:
:
gXPCApplicationAccessible
)
;
}
return
nsAccessibilityService
:
:
gXPCApplicationAccessible
;
}
EPlatformDisabledState
PlatformDisabledState
(
)
{
static
bool
platformDisabledStateCached
=
false
;
if
(
platformDisabledStateCached
)
{
return
static_cast
<
EPlatformDisabledState
>
(
sPlatformDisabledState
)
;
}
platformDisabledStateCached
=
true
;
Preferences
:
:
RegisterCallback
(
PrefChanged
PREF_ACCESSIBILITY_FORCE_DISABLED
)
;
return
ReadPlatformDisabledState
(
)
;
}
EPlatformDisabledState
ReadPlatformDisabledState
(
)
{
sPlatformDisabledState
=
Preferences
:
:
GetInt
(
PREF_ACCESSIBILITY_FORCE_DISABLED
0
)
;
if
(
sPlatformDisabledState
<
ePlatformIsForceEnabled
)
{
sPlatformDisabledState
=
ePlatformIsForceEnabled
;
}
else
if
(
sPlatformDisabledState
>
ePlatformIsDisabled
)
{
sPlatformDisabledState
=
ePlatformIsDisabled
;
}
return
static_cast
<
EPlatformDisabledState
>
(
sPlatformDisabledState
)
;
}
void
PrefChanged
(
const
char
*
aPref
void
*
aClosure
)
{
if
(
ReadPlatformDisabledState
(
)
=
=
ePlatformIsDisabled
)
{
nsAccessibilityService
*
accService
=
nsAccessibilityService
:
:
gAccessibilityService
;
if
(
accService
&
&
!
nsAccessibilityService
:
:
IsShutdown
(
)
)
{
accService
-
>
Shutdown
(
)
;
}
}
}
}
}
