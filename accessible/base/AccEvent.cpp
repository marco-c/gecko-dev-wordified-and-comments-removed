#
include
"
AccEvent
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
DocAccessible
.
h
"
#
include
"
xpcAccEvents
.
h
"
#
include
"
States
.
h
"
#
include
"
TextRange
.
h
"
#
include
"
xpcAccessibleDocument
.
h
"
#
include
"
xpcAccessibleTextRange
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIMutableArray
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
static_assert
(
static_cast
<
bool
>
(
eNoUserInput
)
=
=
false
&
&
static_cast
<
bool
>
(
eFromUserInput
)
=
=
true
"
EIsFromUserInput
cannot
be
casted
to
bool
"
)
;
AccEvent
:
:
AccEvent
(
uint32_t
aEventType
LocalAccessible
*
aAccessible
EIsFromUserInput
aIsFromUserInput
EEventRule
aEventRule
)
:
mEventType
(
aEventType
)
mEventRule
(
aEventRule
)
mAccessible
(
aAccessible
)
{
if
(
aIsFromUserInput
=
=
eAutoDetect
)
{
mIsFromUserInput
=
dom
:
:
UserActivation
:
:
IsHandlingUserInput
(
)
;
}
else
{
mIsFromUserInput
=
aIsFromUserInput
=
=
eFromUserInput
?
true
:
false
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
AccEvent
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
AccEvent
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAccessible
)
if
(
AccTreeMutationEvent
*
tmEvent
=
downcast_accEvent
(
tmp
)
)
{
tmEvent
-
>
SetNextEvent
(
nullptr
)
;
tmEvent
-
>
SetPrevEvent
(
nullptr
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
AccEvent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAccessible
)
if
(
AccTreeMutationEvent
*
tmEvent
=
downcast_accEvent
(
tmp
)
)
{
CycleCollectionNoteChild
(
cb
tmEvent
-
>
NextEvent
(
)
"
mNext
"
)
;
CycleCollectionNoteChild
(
cb
tmEvent
-
>
PrevEvent
(
)
"
mPrevEvent
"
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
AccEvent
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
AccEvent
Release
)
AccTextChangeEvent
:
:
AccTextChangeEvent
(
LocalAccessible
*
aAccessible
int32_t
aStart
const
nsAString
&
aModifiedText
bool
aIsInserted
EIsFromUserInput
aIsFromUserInput
)
:
AccEvent
(
aIsInserted
?
static_cast
<
uint32_t
>
(
nsIAccessibleEvent
:
:
EVENT_TEXT_INSERTED
)
:
static_cast
<
uint32_t
>
(
nsIAccessibleEvent
:
:
EVENT_TEXT_REMOVED
)
aAccessible
aIsFromUserInput
eAllowDupes
)
mStart
(
aStart
)
mIsInserted
(
aIsInserted
)
mModifiedText
(
aModifiedText
)
{
mIsFromUserInput
=
mAccessible
-
>
State
(
)
&
(
states
:
:
FOCUSED
|
states
:
:
EDITABLE
)
;
}
AccHideEvent
:
:
AccHideEvent
(
LocalAccessible
*
aTarget
bool
aNeedsShutdown
)
:
AccMutationEvent
(
:
:
nsIAccessibleEvent
:
:
EVENT_HIDE
aTarget
)
mNeedsShutdown
(
aNeedsShutdown
)
{
mNextSibling
=
mAccessible
-
>
LocalNextSibling
(
)
;
mPrevSibling
=
mAccessible
-
>
LocalPrevSibling
(
)
;
}
AccShowEvent
:
:
AccShowEvent
(
LocalAccessible
*
aTarget
)
:
AccMutationEvent
(
:
:
nsIAccessibleEvent
:
:
EVENT_SHOW
aTarget
)
{
int32_t
idx
=
aTarget
-
>
IndexInParent
(
)
;
MOZ_ASSERT
(
idx
>
=
0
)
;
mInsertionIndex
=
idx
;
}
AccTextSelChangeEvent
:
:
AccTextSelChangeEvent
(
HyperTextAccessible
*
aTarget
dom
:
:
Selection
*
aSelection
int32_t
aReason
)
:
AccEvent
(
nsIAccessibleEvent
:
:
EVENT_TEXT_SELECTION_CHANGED
aTarget
eAutoDetect
eCoalesceTextSelChange
)
mSel
(
aSelection
)
mReason
(
aReason
)
{
}
AccTextSelChangeEvent
:
:
~
AccTextSelChangeEvent
(
)
{
}
bool
AccTextSelChangeEvent
:
:
IsCaretMoveOnly
(
)
const
{
return
mSel
-
>
RangeCount
(
)
=
=
1
&
&
mSel
-
>
IsCollapsed
(
)
&
&
(
(
mReason
&
(
nsISelectionListener
:
:
COLLAPSETOSTART_REASON
|
nsISelectionListener
:
:
COLLAPSETOEND_REASON
)
)
=
=
0
)
;
}
void
AccTextSelChangeEvent
:
:
SelectionRanges
(
nsTArray
<
TextRange
>
*
aRanges
)
const
{
TextRange
:
:
TextRangesFromSelection
(
mSel
aRanges
)
;
}
AccSelChangeEvent
:
:
AccSelChangeEvent
(
LocalAccessible
*
aWidget
LocalAccessible
*
aItem
SelChangeType
aSelChangeType
)
:
AccEvent
(
0
aItem
eAutoDetect
eCoalesceSelectionChange
)
mWidget
(
aWidget
)
mItem
(
aItem
)
mSelChangeType
(
aSelChangeType
)
mPreceedingCount
(
0
)
mPackedEvent
(
nullptr
)
{
if
(
aSelChangeType
=
=
eSelectionAdd
)
{
if
(
mWidget
-
>
GetSelectedItem
(
1
)
)
{
mEventType
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_ADD
;
}
else
{
mEventType
=
nsIAccessibleEvent
:
:
EVENT_SELECTION
;
}
}
else
{
mEventType
=
nsIAccessibleEvent
:
:
EVENT_SELECTION_REMOVE
;
}
}
AccTableChangeEvent
:
:
AccTableChangeEvent
(
LocalAccessible
*
aAccessible
uint32_t
aEventType
int32_t
aRowOrColIndex
int32_t
aNumRowsOrCols
)
:
AccEvent
(
aEventType
aAccessible
)
mRowOrColIndex
(
aRowOrColIndex
)
mNumRowsOrCols
(
aNumRowsOrCols
)
{
}
AccVCChangeEvent
:
:
AccVCChangeEvent
(
LocalAccessible
*
aAccessible
LocalAccessible
*
aOldAccessible
int32_t
aOldStart
int32_t
aOldEnd
LocalAccessible
*
aNewAccessible
int32_t
aNewStart
int32_t
aNewEnd
int16_t
aReason
int16_t
aBoundaryType
EIsFromUserInput
aIsFromUserInput
)
:
AccEvent
(
:
:
nsIAccessibleEvent
:
:
EVENT_VIRTUALCURSOR_CHANGED
aAccessible
aIsFromUserInput
)
mOldAccessible
(
aOldAccessible
)
mNewAccessible
(
aNewAccessible
)
mOldStart
(
aOldStart
)
mNewStart
(
aNewStart
)
mOldEnd
(
aOldEnd
)
mNewEnd
(
aNewEnd
)
mReason
(
aReason
)
mBoundaryType
(
aBoundaryType
)
{
}
already_AddRefed
<
nsIAccessibleEvent
>
a11y
:
:
MakeXPCEvent
(
AccEvent
*
aEvent
)
{
DocAccessible
*
doc
=
aEvent
-
>
Document
(
)
;
LocalAccessible
*
acc
=
aEvent
-
>
GetAccessible
(
)
;
nsINode
*
node
=
acc
-
>
GetNode
(
)
;
bool
fromUser
=
aEvent
-
>
IsFromUserInput
(
)
;
uint32_t
type
=
aEvent
-
>
GetEventType
(
)
;
uint32_t
eventGroup
=
aEvent
-
>
GetEventGroups
(
)
;
nsCOMPtr
<
nsIAccessibleEvent
>
xpEvent
;
if
(
eventGroup
&
(
1
<
<
AccEvent
:
:
eStateChangeEvent
)
)
{
AccStateChangeEvent
*
sc
=
downcast_accEvent
(
aEvent
)
;
bool
extra
=
false
;
uint32_t
state
=
nsAccUtils
:
:
To32States
(
sc
-
>
GetState
(
)
&
extra
)
;
xpEvent
=
new
xpcAccStateChangeEvent
(
type
ToXPC
(
acc
)
ToXPCDocument
(
doc
)
node
fromUser
state
extra
sc
-
>
IsStateEnabled
(
)
)
;
return
xpEvent
.
forget
(
)
;
}
if
(
eventGroup
&
(
1
<
<
AccEvent
:
:
eTextChangeEvent
)
)
{
AccTextChangeEvent
*
tc
=
downcast_accEvent
(
aEvent
)
;
nsString
text
;
tc
-
>
GetModifiedText
(
text
)
;
xpEvent
=
new
xpcAccTextChangeEvent
(
type
ToXPC
(
acc
)
ToXPCDocument
(
doc
)
node
fromUser
tc
-
>
GetStartOffset
(
)
tc
-
>
GetLength
(
)
tc
-
>
IsTextInserted
(
)
text
)
;
return
xpEvent
.
forget
(
)
;
}
if
(
eventGroup
&
(
1
<
<
AccEvent
:
:
eHideEvent
)
)
{
AccHideEvent
*
hideEvent
=
downcast_accEvent
(
aEvent
)
;
xpEvent
=
new
xpcAccHideEvent
(
type
ToXPC
(
acc
)
ToXPCDocument
(
doc
)
node
fromUser
ToXPC
(
hideEvent
-
>
TargetParent
(
)
)
ToXPC
(
hideEvent
-
>
TargetNextSibling
(
)
)
ToXPC
(
hideEvent
-
>
TargetPrevSibling
(
)
)
)
;
return
xpEvent
.
forget
(
)
;
}
if
(
eventGroup
&
(
1
<
<
AccEvent
:
:
eCaretMoveEvent
)
)
{
AccCaretMoveEvent
*
cm
=
downcast_accEvent
(
aEvent
)
;
xpEvent
=
new
xpcAccCaretMoveEvent
(
type
ToXPC
(
acc
)
ToXPCDocument
(
doc
)
node
fromUser
cm
-
>
GetCaretOffset
(
)
cm
-
>
IsSelectionCollapsed
(
)
)
;
return
xpEvent
.
forget
(
)
;
}
if
(
eventGroup
&
(
1
<
<
AccEvent
:
:
eTextSelChangeEvent
)
)
{
AccTextSelChangeEvent
*
tsc
=
downcast_accEvent
(
aEvent
)
;
AutoTArray
<
TextRange
1
>
ranges
;
tsc
-
>
SelectionRanges
(
&
ranges
)
;
nsCOMPtr
<
nsIMutableArray
>
xpcRanges
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
uint32_t
len
=
ranges
.
Length
(
)
;
for
(
uint32_t
idx
=
0
;
idx
<
len
;
idx
+
+
)
{
xpcRanges
-
>
AppendElement
(
new
xpcAccessibleTextRange
(
std
:
:
move
(
ranges
[
idx
]
)
)
)
;
}
xpEvent
=
new
xpcAccTextSelectionChangeEvent
(
type
ToXPC
(
acc
)
ToXPCDocument
(
doc
)
node
fromUser
xpcRanges
)
;
return
xpEvent
.
forget
(
)
;
}
if
(
eventGroup
&
(
1
<
<
AccEvent
:
:
eVirtualCursorChangeEvent
)
)
{
AccVCChangeEvent
*
vcc
=
downcast_accEvent
(
aEvent
)
;
xpEvent
=
new
xpcAccVirtualCursorChangeEvent
(
type
ToXPC
(
acc
)
ToXPCDocument
(
doc
)
node
fromUser
ToXPC
(
vcc
-
>
OldAccessible
(
)
)
vcc
-
>
OldStartOffset
(
)
vcc
-
>
OldEndOffset
(
)
ToXPC
(
vcc
-
>
NewAccessible
(
)
)
vcc
-
>
NewStartOffset
(
)
vcc
-
>
NewEndOffset
(
)
vcc
-
>
Reason
(
)
vcc
-
>
BoundaryType
(
)
)
;
return
xpEvent
.
forget
(
)
;
}
if
(
eventGroup
&
(
1
<
<
AccEvent
:
:
eObjectAttrChangedEvent
)
)
{
AccObjectAttrChangedEvent
*
oac
=
downcast_accEvent
(
aEvent
)
;
nsString
attribute
;
oac
-
>
GetAttribute
(
)
-
>
ToString
(
attribute
)
;
xpEvent
=
new
xpcAccObjectAttributeChangedEvent
(
type
ToXPC
(
acc
)
ToXPCDocument
(
doc
)
node
fromUser
attribute
)
;
return
xpEvent
.
forget
(
)
;
}
if
(
eventGroup
&
(
1
<
<
AccEvent
:
:
eScrollingEvent
)
)
{
AccScrollingEvent
*
sa
=
downcast_accEvent
(
aEvent
)
;
xpEvent
=
new
xpcAccScrollingEvent
(
type
ToXPC
(
acc
)
ToXPCDocument
(
doc
)
node
fromUser
sa
-
>
ScrollX
(
)
sa
-
>
ScrollY
(
)
sa
-
>
MaxScrollX
(
)
sa
-
>
MaxScrollY
(
)
)
;
return
xpEvent
.
forget
(
)
;
}
if
(
eventGroup
&
(
1
<
<
AccEvent
:
:
eAnnouncementEvent
)
)
{
AccAnnouncementEvent
*
aa
=
downcast_accEvent
(
aEvent
)
;
xpEvent
=
new
xpcAccAnnouncementEvent
(
type
ToXPC
(
acc
)
ToXPCDocument
(
doc
)
node
fromUser
aa
-
>
Announcement
(
)
aa
-
>
Priority
(
)
)
;
return
xpEvent
.
forget
(
)
;
}
xpEvent
=
new
xpcAccEvent
(
type
ToXPC
(
acc
)
ToXPCDocument
(
doc
)
node
fromUser
)
;
return
xpEvent
.
forget
(
)
;
}
