#
include
"
EventTree
.
h
"
#
include
"
Accessible
-
inl
.
h
"
#
include
"
nsEventShell
.
h
"
#
include
"
DocAccessible
.
h
"
#
ifdef
A11Y_LOG
#
include
"
Logging
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
EventTree
*
const
TreeMutation
:
:
kNoEventTree
=
reinterpret_cast
<
EventTree
*
>
(
-
1
)
;
TreeMutation
:
:
TreeMutation
(
Accessible
*
aParent
bool
aNoEvents
)
:
mParent
(
aParent
)
mStartIdx
(
UINT32_MAX
)
mStateFlagsCopy
(
mParent
-
>
mStateFlags
)
mEventTree
(
aNoEvents
?
kNoEventTree
:
nullptr
)
{
#
ifdef
DEBUG
mIsDone
=
false
;
#
endif
#
ifdef
A11Y_LOG
if
(
mEventTree
!
=
kNoEventTree
&
&
logging
:
:
IsEnabled
(
logging
:
:
eEventTree
)
)
{
logging
:
:
MsgBegin
(
"
EVENTS_TREE
"
"
reordering
tree
before
"
)
;
logging
:
:
AccessibleInfo
(
"
reordering
for
"
mParent
)
;
Controller
(
)
-
>
RootEventTree
(
)
.
Log
(
)
;
logging
:
:
MsgEnd
(
)
;
logging
:
:
MsgBegin
(
"
EVENTS_TREE
"
"
Container
tree
"
)
;
if
(
logging
:
:
IsEnabled
(
logging
:
:
eVerbose
)
)
{
nsAutoString
level
;
Accessible
*
root
=
mParent
-
>
Document
(
)
;
do
{
const
char
*
prefix
=
"
"
;
if
(
mParent
=
=
root
)
{
prefix
=
"
_X_
"
;
}
else
{
const
EventTree
&
ret
=
Controller
(
)
-
>
RootEventTree
(
)
;
if
(
ret
.
Find
(
root
)
)
{
prefix
=
"
_
_
"
;
}
}
printf
(
"
%
s
"
NS_ConvertUTF16toUTF8
(
level
)
.
get
(
)
)
;
logging
:
:
AccessibleInfo
(
prefix
root
)
;
if
(
root
-
>
FirstChild
(
)
&
&
!
root
-
>
FirstChild
(
)
-
>
IsDoc
(
)
)
{
level
.
Append
(
NS_LITERAL_STRING
(
"
"
)
)
;
root
=
root
-
>
FirstChild
(
)
;
continue
;
}
int32_t
idxInParent
=
root
-
>
mParent
?
root
-
>
mParent
-
>
mChildren
.
IndexOf
(
root
)
:
-
1
;
if
(
idxInParent
!
=
-
1
&
&
idxInParent
<
static_cast
<
int32_t
>
(
root
-
>
mParent
-
>
mChildren
.
Length
(
)
-
1
)
)
{
root
=
root
-
>
mParent
-
>
mChildren
.
ElementAt
(
idxInParent
+
1
)
;
continue
;
}
while
(
(
root
=
root
-
>
Parent
(
)
)
&
&
!
root
-
>
IsDoc
(
)
)
{
level
.
Cut
(
0
2
)
;
int32_t
idxInParent
=
root
-
>
mParent
?
root
-
>
mParent
-
>
mChildren
.
IndexOf
(
root
)
:
-
1
;
if
(
idxInParent
!
=
-
1
&
&
idxInParent
<
static_cast
<
int32_t
>
(
root
-
>
mParent
-
>
mChildren
.
Length
(
)
-
1
)
)
{
root
=
root
-
>
mParent
-
>
mChildren
.
ElementAt
(
idxInParent
+
1
)
;
break
;
}
}
}
while
(
root
&
&
!
root
-
>
IsDoc
(
)
)
;
}
logging
:
:
MsgEnd
(
)
;
}
#
endif
mParent
-
>
mStateFlags
|
=
Accessible
:
:
eKidsMutating
;
}
TreeMutation
:
:
~
TreeMutation
(
)
{
MOZ_ASSERT
(
mIsDone
"
Done
(
)
must
be
called
explicitly
"
)
;
}
void
TreeMutation
:
:
AfterInsertion
(
Accessible
*
aChild
)
{
MOZ_ASSERT
(
aChild
-
>
Parent
(
)
=
=
mParent
)
;
if
(
static_cast
<
uint32_t
>
(
aChild
-
>
mIndexInParent
)
<
mStartIdx
)
{
mStartIdx
=
aChild
-
>
mIndexInParent
+
1
;
}
if
(
!
mEventTree
)
{
mEventTree
=
Controller
(
)
-
>
QueueMutation
(
mParent
)
;
if
(
!
mEventTree
)
{
mEventTree
=
kNoEventTree
;
}
}
if
(
mEventTree
!
=
kNoEventTree
)
{
mEventTree
-
>
Shown
(
aChild
)
;
Controller
(
)
-
>
QueueNameChange
(
aChild
)
;
}
}
void
TreeMutation
:
:
BeforeRemoval
(
Accessible
*
aChild
bool
aNoShutdown
)
{
MOZ_ASSERT
(
aChild
-
>
Parent
(
)
=
=
mParent
)
;
if
(
static_cast
<
uint32_t
>
(
aChild
-
>
mIndexInParent
)
<
mStartIdx
)
{
mStartIdx
=
aChild
-
>
mIndexInParent
;
}
if
(
!
mEventTree
)
{
mEventTree
=
Controller
(
)
-
>
QueueMutation
(
mParent
)
;
if
(
!
mEventTree
)
{
mEventTree
=
kNoEventTree
;
}
}
if
(
mEventTree
!
=
kNoEventTree
)
{
mEventTree
-
>
Hidden
(
aChild
!
aNoShutdown
)
;
Controller
(
)
-
>
QueueNameChange
(
aChild
)
;
}
}
void
TreeMutation
:
:
Done
(
)
{
MOZ_ASSERT
(
mParent
-
>
mStateFlags
&
Accessible
:
:
eKidsMutating
)
;
mParent
-
>
mStateFlags
&
=
~
Accessible
:
:
eKidsMutating
;
uint32_t
length
=
mParent
-
>
mChildren
.
Length
(
)
;
#
ifdef
DEBUG
for
(
uint32_t
idx
=
0
;
idx
<
mStartIdx
&
&
idx
<
length
;
idx
+
+
)
{
MOZ_ASSERT
(
mParent
-
>
mChildren
[
idx
]
-
>
mIndexInParent
=
=
static_cast
<
int32_t
>
(
idx
)
"
Wrong
index
detected
"
)
;
}
#
endif
for
(
uint32_t
idx
=
mStartIdx
;
idx
<
length
;
idx
+
+
)
{
mParent
-
>
mChildren
[
idx
]
-
>
mInt
.
mIndexOfEmbeddedChild
=
-
1
;
mParent
-
>
mChildren
[
idx
]
-
>
mStateFlags
|
=
Accessible
:
:
eGroupInfoDirty
;
}
if
(
mStartIdx
<
mParent
-
>
mChildren
.
Length
(
)
-
1
)
{
mParent
-
>
mEmbeddedObjCollector
=
nullptr
;
}
mParent
-
>
mStateFlags
|
=
mStateFlagsCopy
&
Accessible
:
:
eKidsMutating
;
#
ifdef
DEBUG
mIsDone
=
true
;
#
endif
#
ifdef
A11Y_LOG
if
(
mEventTree
!
=
kNoEventTree
&
&
logging
:
:
IsEnabled
(
logging
:
:
eEventTree
)
)
{
logging
:
:
MsgBegin
(
"
EVENTS_TREE
"
"
reordering
tree
after
"
)
;
logging
:
:
AccessibleInfo
(
"
reordering
for
"
mParent
)
;
Controller
(
)
-
>
RootEventTree
(
)
.
Log
(
)
;
logging
:
:
MsgEnd
(
)
;
}
#
endif
}
void
EventTree
:
:
Process
(
)
{
while
(
mFirst
)
{
if
(
mFirst
-
>
mContainer
-
>
IsInDocument
(
)
)
{
mFirst
-
>
Process
(
)
;
}
mFirst
=
mFirst
-
>
mNext
.
forget
(
)
;
}
MOZ_ASSERT
(
mContainer
|
|
mDependentEvents
.
IsEmpty
(
)
"
No
container
no
events
"
)
;
MOZ_ASSERT
(
!
mContainer
|
|
!
mContainer
-
>
IsDefunct
(
)
"
Processing
events
for
defunct
container
"
)
;
uint32_t
eventsCount
=
mDependentEvents
.
Length
(
)
;
for
(
uint32_t
jdx
=
0
;
jdx
<
eventsCount
;
jdx
+
+
)
{
AccMutationEvent
*
mtEvent
=
mDependentEvents
[
jdx
]
;
MOZ_ASSERT
(
mtEvent
-
>
mEventRule
!
=
AccEvent
:
:
eDoNotEmit
"
The
event
shouldn
'
t
be
presented
in
the
tree
"
)
;
nsEventShell
:
:
FireEvent
(
mtEvent
)
;
if
(
mtEvent
-
>
mTextChangeEvent
)
{
nsEventShell
:
:
FireEvent
(
mtEvent
-
>
mTextChangeEvent
)
;
}
if
(
mtEvent
-
>
IsHide
(
)
)
{
if
(
mtEvent
-
>
mAccessible
-
>
ARIARole
(
)
=
=
roles
:
:
MENUPOPUP
)
{
nsEventShell
:
:
FireEvent
(
nsIAccessibleEvent
:
:
EVENT_MENUPOPUP_END
mtEvent
-
>
mAccessible
)
;
}
AccHideEvent
*
hideEvent
=
downcast_accEvent
(
mtEvent
)
;
if
(
hideEvent
-
>
NeedsShutdown
(
)
)
{
mtEvent
-
>
Document
(
)
-
>
ShutdownChildrenInSubtree
(
mtEvent
-
>
mAccessible
)
;
}
}
}
if
(
mFireReorder
)
{
MOZ_ASSERT
(
mContainer
)
;
nsEventShell
:
:
FireEvent
(
nsIAccessibleEvent
:
:
EVENT_REORDER
mContainer
)
;
mContainer
-
>
Document
(
)
-
>
MaybeNotifyOfValueChange
(
mContainer
)
;
}
mDependentEvents
.
Clear
(
)
;
}
EventTree
*
EventTree
:
:
FindOrInsert
(
Accessible
*
aContainer
)
{
if
(
!
mFirst
)
{
return
mFirst
=
new
EventTree
(
aContainer
true
)
;
}
EventTree
*
prevNode
=
nullptr
;
EventTree
*
node
=
mFirst
;
do
{
MOZ_ASSERT
(
!
node
-
>
mContainer
-
>
IsApplication
(
)
"
No
event
for
application
accessible
is
expected
here
"
)
;
MOZ_ASSERT
(
!
node
-
>
mContainer
-
>
IsDefunct
(
)
"
An
event
target
has
to
be
alive
"
)
;
if
(
node
-
>
mContainer
=
=
aContainer
)
{
return
node
;
}
Accessible
*
top
=
mContainer
?
mContainer
:
aContainer
-
>
Document
(
)
;
Accessible
*
parent
=
aContainer
;
while
(
parent
)
{
if
(
parent
=
=
top
)
{
break
;
}
if
(
parent
-
>
Parent
(
)
=
=
node
-
>
mContainer
)
{
return
node
-
>
FindOrInsert
(
aContainer
)
;
}
parent
=
parent
-
>
Parent
(
)
;
MOZ_ASSERT
(
parent
"
Wrong
tree
"
)
;
}
Accessible
*
curParent
=
node
-
>
mContainer
;
while
(
curParent
&
&
!
curParent
-
>
IsDoc
(
)
)
{
if
(
curParent
-
>
Parent
(
)
!
=
aContainer
)
{
curParent
=
curParent
-
>
Parent
(
)
;
continue
;
}
node
-
>
mFireReorder
=
false
;
nsAutoPtr
<
EventTree
>
&
nodeOwnerRef
=
prevNode
?
prevNode
-
>
mNext
:
mFirst
;
nsAutoPtr
<
EventTree
>
newNode
(
new
EventTree
(
aContainer
mDependentEvents
.
IsEmpty
(
)
)
)
;
newNode
-
>
mFirst
=
Move
(
nodeOwnerRef
)
;
nodeOwnerRef
=
Move
(
newNode
)
;
nodeOwnerRef
-
>
mNext
=
Move
(
node
-
>
mNext
)
;
prevNode
=
nodeOwnerRef
;
node
=
nodeOwnerRef
-
>
mNext
;
nsAutoPtr
<
EventTree
>
*
nodeRef
=
&
nodeOwnerRef
-
>
mNext
;
EventTree
*
insNode
=
nodeOwnerRef
-
>
mFirst
;
while
(
node
)
{
Accessible
*
curParent
=
node
-
>
mContainer
;
while
(
curParent
&
&
!
curParent
-
>
IsDoc
(
)
)
{
if
(
curParent
-
>
Parent
(
)
!
=
aContainer
)
{
curParent
=
curParent
-
>
Parent
(
)
;
continue
;
}
MOZ_ASSERT
(
!
insNode
-
>
mNext
)
;
node
-
>
mFireReorder
=
false
;
insNode
-
>
mNext
=
Move
(
*
nodeRef
)
;
insNode
=
insNode
-
>
mNext
;
prevNode
-
>
mNext
=
Move
(
node
-
>
mNext
)
;
node
=
prevNode
;
break
;
}
prevNode
=
node
;
nodeRef
=
&
node
-
>
mNext
;
node
=
node
-
>
mNext
;
}
return
nodeOwnerRef
;
}
prevNode
=
node
;
}
while
(
(
node
=
node
-
>
mNext
)
)
;
MOZ_ASSERT
(
prevNode
"
Nowhere
to
insert
"
)
;
MOZ_ASSERT
(
!
prevNode
-
>
mNext
"
Taken
by
another
node
"
)
;
return
prevNode
-
>
mNext
=
new
EventTree
(
aContainer
mDependentEvents
.
IsEmpty
(
)
)
;
}
void
EventTree
:
:
Clear
(
)
{
mFirst
=
nullptr
;
mNext
=
nullptr
;
mContainer
=
nullptr
;
uint32_t
eventsCount
=
mDependentEvents
.
Length
(
)
;
for
(
uint32_t
jdx
=
0
;
jdx
<
eventsCount
;
jdx
+
+
)
{
AccHideEvent
*
ev
=
downcast_accEvent
(
mDependentEvents
[
jdx
]
)
;
if
(
ev
&
&
ev
-
>
NeedsShutdown
(
)
)
{
ev
-
>
Document
(
)
-
>
ShutdownChildrenInSubtree
(
ev
-
>
mAccessible
)
;
}
}
mDependentEvents
.
Clear
(
)
;
}
const
EventTree
*
EventTree
:
:
Find
(
const
Accessible
*
aContainer
)
const
{
const
EventTree
*
et
=
this
;
while
(
et
)
{
if
(
et
-
>
mContainer
=
=
aContainer
)
{
return
et
;
}
if
(
et
-
>
mFirst
)
{
et
=
et
-
>
mFirst
;
const
EventTree
*
cet
=
et
-
>
Find
(
aContainer
)
;
if
(
cet
)
{
return
cet
;
}
}
et
=
et
-
>
mNext
;
const
EventTree
*
cet
=
et
-
>
Find
(
aContainer
)
;
if
(
cet
)
{
return
cet
;
}
}
return
nullptr
;
}
#
ifdef
A11Y_LOG
void
EventTree
:
:
Log
(
uint32_t
aLevel
)
const
{
if
(
aLevel
=
=
UINT32_MAX
)
{
if
(
mFirst
)
{
mFirst
-
>
Log
(
0
)
;
}
return
;
}
for
(
uint32_t
i
=
0
;
i
<
aLevel
;
i
+
+
)
{
printf
(
"
"
)
;
}
logging
:
:
AccessibleInfo
(
"
container
"
mContainer
)
;
for
(
uint32_t
i
=
0
;
i
<
mDependentEvents
.
Length
(
)
;
i
+
+
)
{
AccMutationEvent
*
ev
=
mDependentEvents
[
i
]
;
if
(
ev
-
>
IsShow
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
aLevel
;
i
+
+
)
{
printf
(
"
"
)
;
}
logging
:
:
AccessibleInfo
(
"
shown
"
ev
-
>
mAccessible
)
;
}
else
{
for
(
uint32_t
i
=
0
;
i
<
aLevel
;
i
+
+
)
{
printf
(
"
"
)
;
}
logging
:
:
AccessibleInfo
(
"
hidden
"
ev
-
>
mAccessible
)
;
}
}
if
(
mFirst
)
{
mFirst
-
>
Log
(
aLevel
+
1
)
;
}
if
(
mNext
)
{
mNext
-
>
Log
(
aLevel
)
;
}
}
#
endif
void
EventTree
:
:
Mutated
(
AccMutationEvent
*
aEv
)
{
nsAutoPtr
<
EventTree
>
*
node
=
&
mFirst
;
while
(
*
node
)
{
if
(
(
*
node
)
-
>
mContainer
=
=
aEv
-
>
mAccessible
)
{
*
node
=
Move
(
(
*
node
)
-
>
mNext
)
;
break
;
}
node
=
&
(
*
node
)
-
>
mNext
;
}
AccMutationEvent
*
prevEvent
=
mDependentEvents
.
SafeLastElement
(
nullptr
)
;
mDependentEvents
.
AppendElement
(
aEv
)
;
if
(
prevEvent
&
&
aEv
-
>
mEventType
=
=
prevEvent
-
>
mEventType
)
{
if
(
aEv
-
>
IsHide
(
)
)
{
AccTextChangeEvent
*
prevTextEvent
=
prevEvent
-
>
mTextChangeEvent
;
if
(
prevTextEvent
)
{
AccHideEvent
*
hideEvent
=
downcast_accEvent
(
aEv
)
;
AccHideEvent
*
prevHideEvent
=
downcast_accEvent
(
prevEvent
)
;
if
(
prevHideEvent
-
>
mNextSibling
=
=
hideEvent
-
>
mAccessible
)
{
hideEvent
-
>
mAccessible
-
>
AppendTextTo
(
prevTextEvent
-
>
mModifiedText
)
;
}
else
if
(
prevHideEvent
-
>
mPrevSibling
=
=
hideEvent
-
>
mAccessible
)
{
uint32_t
oldLen
=
prevTextEvent
-
>
GetLength
(
)
;
hideEvent
-
>
mAccessible
-
>
AppendTextTo
(
prevTextEvent
-
>
mModifiedText
)
;
prevTextEvent
-
>
mStart
-
=
prevTextEvent
-
>
GetLength
(
)
-
oldLen
;
}
hideEvent
-
>
mTextChangeEvent
.
swap
(
prevEvent
-
>
mTextChangeEvent
)
;
}
}
else
{
AccTextChangeEvent
*
prevTextEvent
=
prevEvent
-
>
mTextChangeEvent
;
if
(
prevTextEvent
)
{
if
(
aEv
-
>
mAccessible
-
>
IndexInParent
(
)
=
=
prevEvent
-
>
mAccessible
-
>
IndexInParent
(
)
+
1
)
{
aEv
-
>
mAccessible
-
>
AppendTextTo
(
prevTextEvent
-
>
mModifiedText
)
;
}
else
if
(
aEv
-
>
mAccessible
-
>
IndexInParent
(
)
=
=
prevEvent
-
>
mAccessible
-
>
IndexInParent
(
)
-
1
)
{
nsAutoString
startText
;
aEv
-
>
mAccessible
-
>
AppendTextTo
(
startText
)
;
prevTextEvent
-
>
mModifiedText
=
startText
+
prevTextEvent
-
>
mModifiedText
;
prevTextEvent
-
>
mStart
-
=
startText
.
Length
(
)
;
}
aEv
-
>
mTextChangeEvent
.
swap
(
prevEvent
-
>
mTextChangeEvent
)
;
}
}
}
if
(
aEv
-
>
mTextChangeEvent
|
|
!
mContainer
-
>
IsHyperText
(
)
)
{
return
;
}
nsAutoString
text
;
aEv
-
>
mAccessible
-
>
AppendTextTo
(
text
)
;
if
(
text
.
IsEmpty
(
)
)
{
return
;
}
int32_t
offset
=
mContainer
-
>
AsHyperText
(
)
-
>
GetChildOffset
(
aEv
-
>
mAccessible
)
;
aEv
-
>
mTextChangeEvent
=
new
AccTextChangeEvent
(
mContainer
offset
text
aEv
-
>
IsShow
(
)
aEv
-
>
mIsFromUserInput
?
eFromUserInput
:
eNoUserInput
)
;
}
