#
ifndef
mozilla_a11y_aria_ARIAMap_h_
#
define
mozilla_a11y_aria_ARIAMap_h_
#
include
"
ARIAStateMap
.
h
"
#
include
"
mozilla
/
a11y
/
AccTypes
.
h
"
#
include
"
mozilla
/
a11y
/
Role
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
class
nsINode
;
enum
EValueRule
{
eNoValue
eHasValueMinMax
eHasValueMinMaxIfFocusable
}
;
enum
EActionRule
{
eNoAction
eActivateAction
eClickAction
ePressAction
eCheckUncheckAction
eExpandAction
eJumpAction
eOpenCloseAction
eSelectAction
eSortAction
eSwitchAction
}
;
enum
ELiveAttrRule
{
eNoLiveAttr
eOffLiveAttr
ePoliteLiveAttr
}
;
const
bool
kUseMapRole
=
true
;
const
bool
kUseNativeRole
=
false
;
const
uint8_t
ATTR_BYPASSOBJ
=
0x1
<
<
0
;
const
uint8_t
ATTR_BYPASSOBJ_IF_FALSE
=
0x1
<
<
1
;
const
uint8_t
ATTR_VALTOKEN
=
0x1
<
<
2
;
const
uint8_t
ATTR_GLOBAL
=
0x1
<
<
3
;
#
define
kNoReqStates
0
struct
nsRoleMapEntry
{
bool
Is
(
nsAtom
*
aARIARole
)
const
{
return
roleAtom
=
=
aARIARole
;
}
bool
IsOfType
(
mozilla
:
:
a11y
:
:
AccGenericType
aType
)
const
{
return
accTypes
&
aType
;
}
const
nsDependentAtomString
ARIARoleString
(
)
const
{
return
nsDependentAtomString
(
roleAtom
)
;
}
nsStaticAtom
*
const
roleAtom
;
mozilla
:
:
a11y
:
:
role
role
;
bool
roleRule
;
EValueRule
valueRule
;
EActionRule
actionRule
;
ELiveAttrRule
liveAttRule
;
uint32_t
accTypes
;
uint64_t
state
;
mozilla
:
:
a11y
:
:
aria
:
:
EStateRule
attributeMap1
;
mozilla
:
:
a11y
:
:
aria
:
:
EStateRule
attributeMap2
;
mozilla
:
:
a11y
:
:
aria
:
:
EStateRule
attributeMap3
;
mozilla
:
:
a11y
:
:
aria
:
:
EStateRule
attributeMap4
;
}
;
namespace
mozilla
{
namespace
a11y
{
namespace
aria
{
extern
nsRoleMapEntry
gEmptyRoleMap
;
const
uint8_t
NO_ROLE_MAP_ENTRY_INDEX
=
UINT8_MAX
-
2
;
const
uint8_t
EMPTY_ROLE_MAP_ENTRY_INDEX
=
UINT8_MAX
-
1
;
const
uint8_t
LANDMARK_ROLE_MAP_ENTRY_INDEX
=
UINT8_MAX
;
const
nsRoleMapEntry
*
GetRoleMap
(
dom
:
:
Element
*
aEl
)
;
uint8_t
GetRoleMapIndex
(
dom
:
:
Element
*
aEl
)
;
const
nsRoleMapEntry
*
GetRoleMapFromIndex
(
uint8_t
aRoleMapIndex
)
;
uint8_t
GetIndexFromRoleMap
(
const
nsRoleMapEntry
*
aRoleMap
)
;
uint64_t
UniversalStatesFor
(
dom
:
:
Element
*
aElement
)
;
uint8_t
AttrCharacteristicsFor
(
nsAtom
*
aAtom
)
;
bool
HasDefinedARIAHidden
(
nsIContent
*
aContent
)
;
class
AttrIterator
{
public
:
explicit
AttrIterator
(
nsIContent
*
aContent
)
:
mElement
(
dom
:
:
Element
:
:
FromNode
(
aContent
)
)
mAttrIdx
(
0
)
{
mAttrCount
=
mElement
?
mElement
-
>
GetAttrCount
(
)
:
0
;
}
bool
Next
(
nsAString
&
aAttrName
nsAString
&
aAttrValue
)
;
private
:
AttrIterator
(
)
=
delete
;
AttrIterator
(
const
AttrIterator
&
)
=
delete
;
AttrIterator
&
operator
=
(
const
AttrIterator
&
)
=
delete
;
dom
:
:
Element
*
mElement
;
uint32_t
mAttrIdx
;
uint32_t
mAttrCount
;
}
;
}
}
}
#
endif
