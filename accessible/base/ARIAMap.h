#
ifndef
mozilla_a11y_aria_ARIAMap_h_
#
define
mozilla_a11y_aria_ARIAMap_h_
#
include
"
ARIAStateMap
.
h
"
#
include
"
mozilla
/
a11y
/
AccTypes
.
h
"
#
include
"
mozilla
/
a11y
/
Role
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsTHashSet
.
h
"
class
nsINode
;
namespace
mozilla
:
:
dom
{
class
Element
;
}
enum
EValueRule
{
eNoValue
eHasValueMinMax
eHasValueMinMaxIfFocusable
}
;
enum
EActionRule
{
eNoAction
eActivateAction
eClickAction
ePressAction
eCheckUncheckAction
eExpandAction
eJumpAction
eOpenCloseAction
eSelectAction
eSortAction
eSwitchAction
}
;
enum
ELiveAttrRule
{
eNoLiveAttr
eOffLiveAttr
ePoliteLiveAttr
eAssertiveLiveAttr
}
;
const
bool
kUseMapRole
=
true
;
const
bool
kUseNativeRole
=
false
;
const
uint8_t
ATTR_BYPASSOBJ
=
0x1
<
<
0
;
const
uint8_t
ATTR_BYPASSOBJ_IF_FALSE
=
0x1
<
<
1
;
const
uint8_t
ATTR_VALTOKEN
=
0x1
<
<
2
;
const
uint8_t
ATTR_GLOBAL
=
0x1
<
<
3
;
const
uint8_t
ATTR_VALINT
=
0x1
<
<
4
;
const
uint8_t
ATTR_REFLECT_ELEMENTS
=
0x1
<
<
5
;
#
define
kNoReqStates
0
struct
nsRoleMapEntry
{
bool
Is
(
nsAtom
*
aARIARole
)
const
{
return
roleAtom
=
=
aARIARole
;
}
bool
IsOfType
(
mozilla
:
:
a11y
:
:
AccGenericType
aType
)
const
{
return
accTypes
&
aType
;
}
const
nsDependentAtomString
ARIARoleString
(
)
const
{
return
nsDependentAtomString
(
roleAtom
)
;
}
nsStaticAtom
*
const
roleAtom
;
mozilla
:
:
a11y
:
:
role
role
;
bool
roleRule
;
EValueRule
valueRule
;
EActionRule
actionRule
;
ELiveAttrRule
liveAttRule
;
uint32_t
accTypes
;
uint64_t
state
;
mozilla
:
:
a11y
:
:
aria
:
:
EStateRule
attributeMap1
;
mozilla
:
:
a11y
:
:
aria
:
:
EStateRule
attributeMap2
;
mozilla
:
:
a11y
:
:
aria
:
:
EStateRule
attributeMap3
;
mozilla
:
:
a11y
:
:
aria
:
:
EStateRule
attributeMap4
;
}
;
namespace
mozilla
{
namespace
a11y
{
class
AccAttributes
;
namespace
aria
{
extern
nsRoleMapEntry
gEmptyRoleMap
;
const
uint8_t
NO_ROLE_MAP_ENTRY_INDEX
=
UINT8_MAX
-
2
;
const
uint8_t
EMPTY_ROLE_MAP_ENTRY_INDEX
=
UINT8_MAX
-
1
;
const
uint8_t
LANDMARK_ROLE_MAP_ENTRY_INDEX
=
UINT8_MAX
;
const
nsRoleMapEntry
*
GetRoleMap
(
dom
:
:
Element
*
aEl
)
;
uint8_t
GetFirstValidRoleMapIndexExcluding
(
dom
:
:
Element
*
aEl
std
:
:
initializer_list
<
nsStaticAtom
*
>
aRolesToSkip
)
;
uint8_t
GetRoleMapIndex
(
dom
:
:
Element
*
aEl
)
;
const
nsRoleMapEntry
*
GetRoleMapFromIndex
(
uint8_t
aRoleMapIndex
)
;
uint8_t
GetIndexFromRoleMap
(
const
nsRoleMapEntry
*
aRoleMap
)
;
bool
IsRoleMapIndexValid
(
uint8_t
aRoleMapIndex
)
;
uint64_t
UniversalStatesFor
(
dom
:
:
Element
*
aElement
)
;
uint8_t
AttrCharacteristicsFor
(
nsAtom
*
aAtom
)
;
bool
HasDefinedARIAHidden
(
nsIContent
*
aContent
)
;
const
nsRoleMapEntry
*
GetRoleMap
(
const
nsStaticAtom
*
aAriaRole
)
;
class
AttrIterator
{
public
:
explicit
AttrIterator
(
nsIContent
*
aContent
)
;
bool
Next
(
)
;
nsAtom
*
AttrName
(
)
const
;
void
AttrValue
(
nsAString
&
aAttrValue
)
const
;
bool
ExposeAttr
(
AccAttributes
*
aTargetAttrs
)
const
;
private
:
AttrIterator
(
)
=
delete
;
AttrIterator
(
const
AttrIterator
&
)
=
delete
;
AttrIterator
&
operator
=
(
const
AttrIterator
&
)
=
delete
;
dom
:
:
Element
*
mElement
;
bool
mIteratingDefaults
;
nsTHashSet
<
RefPtr
<
nsAtom
>
>
mOverriddenAttrs
;
const
AttrArray
*
mAttrs
;
uint32_t
mAttrIdx
;
uint32_t
mAttrCount
;
RefPtr
<
nsAtom
>
mAttrAtom
;
uint8_t
mAttrCharacteristics
;
}
;
class
AttrWithCharacteristicsIterator
{
public
:
explicit
AttrWithCharacteristicsIterator
(
uint8_t
aCharacteristics
)
:
mIdx
(
-
1
)
mCharacteristics
(
aCharacteristics
)
{
}
bool
Next
(
)
;
nsStaticAtom
*
AttrName
(
)
const
;
private
:
AttrWithCharacteristicsIterator
(
)
=
delete
;
AttrWithCharacteristicsIterator
(
const
AttrWithCharacteristicsIterator
&
)
=
delete
;
AttrWithCharacteristicsIterator
&
operator
=
(
const
AttrWithCharacteristicsIterator
&
)
=
delete
;
int32_t
mIdx
;
uint8_t
mCharacteristics
;
}
;
}
}
}
#
endif
