#
include
"
TextLeafRange
.
h
"
#
include
"
mozilla
/
a11y
/
Accessible
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
LocalAccessible
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIAccessiblePivot
.
h
"
#
include
"
nsILineIterator
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
Pivot
.
h
"
namespace
mozilla
:
:
a11y
{
static
int32_t
RenderedToContentOffset
(
LocalAccessible
*
aAcc
uint32_t
aRenderedOffset
)
{
if
(
aAcc
-
>
LocalParent
(
)
&
&
aAcc
-
>
LocalParent
(
)
-
>
IsTextField
(
)
)
{
return
static_cast
<
int32_t
>
(
aRenderedOffset
)
;
}
nsIFrame
*
frame
=
aAcc
-
>
GetFrame
(
)
;
MOZ_ASSERT
(
frame
&
&
frame
-
>
IsTextFrame
(
)
)
;
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
aRenderedOffset
aRenderedOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInRenderedText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
return
text
.
mOffsetWithinNodeText
;
}
static
uint32_t
ContentToRenderedOffset
(
LocalAccessible
*
aAcc
int32_t
aContentOffset
)
{
if
(
aAcc
-
>
LocalParent
(
)
&
&
aAcc
-
>
LocalParent
(
)
-
>
IsTextField
(
)
)
{
return
aContentOffset
;
}
nsIFrame
*
frame
=
aAcc
-
>
GetFrame
(
)
;
MOZ_ASSERT
(
frame
&
&
frame
-
>
IsTextFrame
(
)
)
;
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
aContentOffset
aContentOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInContentText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
return
text
.
mOffsetWithinNodeRenderedText
;
}
class
LeafRule
:
public
PivotRule
{
public
:
virtual
uint16_t
Match
(
Accessible
*
aAcc
)
override
{
if
(
aAcc
-
>
IsOuterDoc
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
!
aAcc
-
>
HasChildren
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
}
}
;
static
Accessible
*
NextLeaf
(
Accessible
*
aOrigin
)
{
DocAccessible
*
doc
=
aOrigin
-
>
AsLocal
(
)
-
>
Document
(
)
;
Pivot
pivot
(
doc
)
;
auto
rule
=
LeafRule
(
)
;
return
pivot
.
Next
(
aOrigin
rule
)
;
}
static
Accessible
*
PrevLeaf
(
Accessible
*
aOrigin
)
{
DocAccessible
*
doc
=
aOrigin
-
>
AsLocal
(
)
-
>
Document
(
)
;
Pivot
pivot
(
doc
)
;
auto
rule
=
LeafRule
(
)
;
return
pivot
.
Prev
(
aOrigin
rule
)
;
}
static
bool
IsLocalAccAtLineStart
(
LocalAccessible
*
aAcc
)
{
if
(
aAcc
-
>
NativeRole
(
)
=
=
roles
:
:
LISTITEM_MARKER
)
{
return
true
;
}
Accessible
*
prev
=
PrevLeaf
(
aAcc
)
;
LocalAccessible
*
prevLocal
=
prev
?
prev
-
>
AsLocal
(
)
:
nullptr
;
if
(
!
prevLocal
)
{
return
true
;
}
if
(
prevLocal
-
>
NativeRole
(
)
=
=
roles
:
:
LISTITEM_MARKER
)
{
LocalAccessible
*
listItem
=
prevLocal
-
>
LocalParent
(
)
;
MOZ_ASSERT
(
listItem
)
;
LocalAccessible
*
doc
=
listItem
-
>
Document
(
)
;
MOZ_ASSERT
(
doc
)
;
for
(
LocalAccessible
*
parent
=
aAcc
-
>
LocalParent
(
)
;
parent
&
&
parent
!
=
doc
;
parent
=
parent
-
>
LocalParent
(
)
)
{
if
(
parent
=
=
listItem
)
{
return
false
;
}
}
}
nsIFrame
*
thisFrame
=
aAcc
-
>
GetFrame
(
)
;
if
(
!
thisFrame
)
{
return
false
;
}
nsIFrame
:
:
GetFirstLeaf
(
&
thisFrame
)
;
nsIFrame
*
prevFrame
=
prevLocal
-
>
GetFrame
(
)
;
if
(
!
prevFrame
)
{
return
false
;
}
nsIFrame
:
:
GetLastLeaf
(
&
prevFrame
)
;
nsIFrame
*
thisLineFrame
=
nullptr
;
nsIFrame
*
thisBlock
=
thisFrame
-
>
GetContainingBlockForLine
(
false
thisLineFrame
)
;
if
(
!
thisBlock
)
{
return
true
;
}
nsIFrame
*
prevLineFrame
=
nullptr
;
nsIFrame
*
prevBlock
=
prevFrame
-
>
GetContainingBlockForLine
(
false
prevLineFrame
)
;
if
(
thisBlock
!
=
prevBlock
)
{
return
true
;
}
nsAutoLineIterator
it
=
thisBlock
-
>
GetLineIterator
(
)
;
if
(
!
it
)
{
return
true
;
}
int32_t
thisLineNum
=
it
-
>
FindLineContaining
(
thisLineFrame
)
;
if
(
thisLineNum
<
0
)
{
return
true
;
}
int32_t
prevLineNum
=
it
-
>
FindLineContaining
(
prevLineFrame
)
;
return
thisLineNum
!
=
prevLineNum
;
}
TextLeafPoint
:
:
TextLeafPoint
(
Accessible
*
aAcc
int32_t
aOffset
)
{
if
(
aAcc
-
>
HasChildren
(
)
)
{
for
(
Accessible
*
acc
=
aAcc
-
>
FirstChild
(
)
;
acc
;
acc
=
acc
-
>
FirstChild
(
)
)
{
mAcc
=
acc
;
}
mOffset
=
0
;
return
;
}
mAcc
=
aAcc
;
mOffset
=
aOffset
;
}
bool
TextLeafPoint
:
:
operator
<
(
const
TextLeafPoint
&
aPoint
)
const
{
if
(
mAcc
=
=
aPoint
.
mAcc
)
{
return
mOffset
<
aPoint
.
mOffset
;
}
Accessible
*
thisP
=
mAcc
;
Accessible
*
otherP
=
aPoint
.
mAcc
;
AutoTArray
<
Accessible
*
30
>
thisParents
otherParents
;
do
{
thisParents
.
AppendElement
(
thisP
)
;
thisP
=
thisP
-
>
Parent
(
)
;
}
while
(
thisP
)
;
do
{
otherParents
.
AppendElement
(
otherP
)
;
otherP
=
otherP
-
>
Parent
(
)
;
}
while
(
otherP
)
;
uint32_t
thisPos
=
thisParents
.
Length
(
)
otherPos
=
otherParents
.
Length
(
)
;
for
(
uint32_t
len
=
std
:
:
min
(
thisPos
otherPos
)
;
len
>
0
;
-
-
len
)
{
Accessible
*
thisChild
=
thisParents
.
ElementAt
(
-
-
thisPos
)
;
Accessible
*
otherChild
=
otherParents
.
ElementAt
(
-
-
otherPos
)
;
if
(
thisChild
!
=
otherChild
)
{
return
thisChild
-
>
IndexInParent
(
)
<
otherChild
-
>
IndexInParent
(
)
;
}
}
MOZ_ASSERT
(
thisPos
!
=
0
|
|
otherPos
!
=
0
)
;
MOZ_ASSERT
(
thisPos
!
=
otherPos
)
;
return
otherPos
>
0
;
}
bool
TextLeafPoint
:
:
IsEmptyLastLine
(
)
const
{
if
(
mAcc
-
>
IsHTMLBr
(
)
&
&
mOffset
=
=
1
)
{
return
true
;
}
if
(
!
mAcc
-
>
IsTextLeaf
(
)
)
{
return
false
;
}
LocalAccessible
*
localAcc
=
mAcc
-
>
AsLocal
(
)
;
MOZ_ASSERT
(
localAcc
)
;
if
(
mOffset
<
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
localAcc
)
)
)
{
return
false
;
}
nsAutoString
text
;
mAcc
-
>
AsLocal
(
)
-
>
AppendTextTo
(
text
mOffset
-
1
1
)
;
return
text
.
CharAt
(
0
)
=
=
'
\
n
'
;
}
TextLeafPoint
TextLeafPoint
:
:
FindPrevLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
{
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
;
MOZ_ASSERT
(
acc
)
;
if
(
mOffset
=
=
0
)
{
if
(
aIncludeOrigin
&
&
IsLocalAccAtLineStart
(
acc
)
)
{
return
*
this
;
}
return
TextLeafPoint
(
)
;
}
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
!
frame
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
frame
"
)
;
return
TextLeafPoint
(
)
;
}
if
(
!
frame
-
>
IsTextFrame
(
)
)
{
if
(
IsLocalAccAtLineStart
(
acc
)
)
{
return
TextLeafPoint
(
acc
0
)
;
}
return
TextLeafPoint
(
)
;
}
int32_t
origOffset
=
mOffset
;
origOffset
=
RenderedToContentOffset
(
acc
origOffset
)
;
nsTextFrame
*
continuation
=
nullptr
;
int32_t
unusedOffsetInContinuation
=
0
;
frame
-
>
GetChildFrameContainingOffset
(
origOffset
true
&
unusedOffsetInContinuation
(
nsIFrame
*
*
)
&
continuation
)
;
MOZ_ASSERT
(
continuation
)
;
int32_t
lineStart
=
continuation
-
>
GetContentOffset
(
)
;
if
(
!
aIncludeOrigin
&
&
lineStart
>
0
&
&
lineStart
=
=
origOffset
)
{
continuation
=
continuation
-
>
GetPrevContinuation
(
)
;
MOZ_ASSERT
(
continuation
)
;
lineStart
=
continuation
-
>
GetContentOffset
(
)
;
}
MOZ_ASSERT
(
lineStart
>
=
0
)
;
if
(
lineStart
=
=
0
&
&
!
IsLocalAccAtLineStart
(
acc
)
)
{
return
TextLeafPoint
(
)
;
}
lineStart
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
acc
lineStart
)
)
;
return
TextLeafPoint
(
acc
lineStart
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindNextLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
{
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
;
MOZ_ASSERT
(
acc
)
;
if
(
aIncludeOrigin
&
&
mOffset
=
=
0
&
&
IsLocalAccAtLineStart
(
acc
)
)
{
return
*
this
;
}
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
!
frame
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
frame
"
)
;
return
TextLeafPoint
(
)
;
}
if
(
!
frame
-
>
IsTextFrame
(
)
)
{
return
TextLeafPoint
(
)
;
}
int32_t
origOffset
=
mOffset
;
origOffset
=
RenderedToContentOffset
(
acc
origOffset
)
;
nsTextFrame
*
continuation
=
nullptr
;
int32_t
unusedOffsetInContinuation
=
0
;
frame
-
>
GetChildFrameContainingOffset
(
origOffset
true
&
unusedOffsetInContinuation
(
nsIFrame
*
*
)
&
continuation
)
;
MOZ_ASSERT
(
continuation
)
;
if
(
aIncludeOrigin
&
&
continuation
-
>
GetContentOffset
(
)
=
=
origOffset
&
&
!
(
origOffset
=
=
0
&
&
!
IsLocalAccAtLineStart
(
acc
)
)
)
{
return
*
this
;
}
continuation
=
continuation
-
>
GetNextContinuation
(
)
;
if
(
!
continuation
)
{
return
TextLeafPoint
(
)
;
}
int32_t
lineStart
=
continuation
-
>
GetContentOffset
(
)
;
lineStart
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
acc
lineStart
)
)
;
return
TextLeafPoint
(
acc
lineStart
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindBoundary
(
AccessibleTextBoundary
aBoundaryType
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_LINE_START
&
&
aIncludeOrigin
&
&
aDirection
=
=
eDirPrevious
&
&
IsEmptyLastLine
(
)
)
{
return
*
this
;
}
TextLeafPoint
searchFrom
=
*
this
;
bool
includeOrigin
=
aIncludeOrigin
;
for
(
;
;
)
{
TextLeafPoint
boundary
;
switch
(
aBoundaryType
)
{
case
nsIAccessibleText
:
:
BOUNDARY_LINE_START
:
if
(
aDirection
=
=
eDirPrevious
)
{
boundary
=
searchFrom
.
FindPrevLineStartSameLocalAcc
(
includeOrigin
)
;
}
else
{
boundary
=
searchFrom
.
FindNextLineStartSameLocalAcc
(
includeOrigin
)
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
)
;
break
;
}
if
(
boundary
)
{
return
boundary
;
}
Accessible
*
acc
=
aDirection
=
=
eDirPrevious
?
PrevLeaf
(
searchFrom
.
mAcc
)
:
NextLeaf
(
searchFrom
.
mAcc
)
;
if
(
!
acc
)
{
return
TextLeafPoint
(
searchFrom
.
mAcc
aDirection
=
=
eDirPrevious
?
0
:
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
searchFrom
.
mAcc
-
>
AsLocal
(
)
)
)
)
;
}
searchFrom
.
mAcc
=
acc
;
searchFrom
.
mOffset
=
aDirection
=
=
eDirPrevious
?
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
acc
-
>
AsLocal
(
)
)
)
:
0
;
includeOrigin
=
true
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
TextLeafPoint
(
)
;
}
}
