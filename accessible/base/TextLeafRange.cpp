#
include
"
TextLeafRange
.
h
"
#
include
"
HyperTextAccessible
-
inl
.
h
"
#
include
"
mozilla
/
a11y
/
Accessible
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessibleParent
.
h
"
#
include
"
mozilla
/
a11y
/
LocalAccessible
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
intl
/
Segmenter
.
h
"
#
include
"
mozilla
/
intl
/
WordBreaker
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIAccessiblePivot
.
h
"
#
include
"
nsILineIterator
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
Pivot
.
h
"
#
include
"
TextAttrs
.
h
"
using
mozilla
:
:
intl
:
:
WordBreaker
;
namespace
mozilla
:
:
a11y
{
static
int32_t
RenderedToContentOffset
(
LocalAccessible
*
aAcc
uint32_t
aRenderedOffset
)
{
if
(
aAcc
-
>
LocalParent
(
)
&
&
aAcc
-
>
LocalParent
(
)
-
>
IsTextField
(
)
)
{
return
static_cast
<
int32_t
>
(
aRenderedOffset
)
;
}
nsIFrame
*
frame
=
aAcc
-
>
GetFrame
(
)
;
MOZ_ASSERT
(
frame
&
&
frame
-
>
IsTextFrame
(
)
)
;
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
aRenderedOffset
aRenderedOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInRenderedText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
return
text
.
mOffsetWithinNodeText
;
}
static
uint32_t
ContentToRenderedOffset
(
LocalAccessible
*
aAcc
int32_t
aContentOffset
)
{
if
(
aAcc
-
>
LocalParent
(
)
&
&
aAcc
-
>
LocalParent
(
)
-
>
IsTextField
(
)
)
{
return
aContentOffset
;
}
nsIFrame
*
frame
=
aAcc
-
>
GetFrame
(
)
;
MOZ_ASSERT
(
frame
&
&
frame
-
>
IsTextFrame
(
)
)
;
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
aContentOffset
aContentOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInContentText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
return
text
.
mOffsetWithinNodeRenderedText
;
}
class
LeafRule
:
public
PivotRule
{
public
:
virtual
uint16_t
Match
(
Accessible
*
aAcc
)
override
{
if
(
aAcc
-
>
IsOuterDoc
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
!
aAcc
-
>
HasChildren
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
}
}
;
static
Accessible
*
DocumentFor
(
Accessible
*
aAcc
)
{
if
(
LocalAccessible
*
localAcc
=
aAcc
-
>
AsLocal
(
)
)
{
return
localAcc
-
>
Document
(
)
;
}
return
aAcc
-
>
AsRemote
(
)
-
>
Document
(
)
;
}
static
HyperTextAccessible
*
HyperTextFor
(
LocalAccessible
*
aAcc
)
{
for
(
LocalAccessible
*
acc
=
aAcc
;
acc
;
acc
=
acc
-
>
LocalParent
(
)
)
{
if
(
HyperTextAccessible
*
ht
=
acc
-
>
AsHyperText
(
)
)
{
return
ht
;
}
}
return
nullptr
;
}
static
Accessible
*
NextLeaf
(
Accessible
*
aOrigin
)
{
Accessible
*
doc
=
DocumentFor
(
aOrigin
)
;
Pivot
pivot
(
doc
)
;
auto
rule
=
LeafRule
(
)
;
return
pivot
.
Next
(
aOrigin
rule
)
;
}
static
Accessible
*
PrevLeaf
(
Accessible
*
aOrigin
)
{
Accessible
*
doc
=
DocumentFor
(
aOrigin
)
;
Pivot
pivot
(
doc
)
;
auto
rule
=
LeafRule
(
)
;
return
pivot
.
Prev
(
aOrigin
rule
)
;
}
static
bool
IsLocalAccAtLineStart
(
LocalAccessible
*
aAcc
)
{
if
(
aAcc
-
>
NativeRole
(
)
=
=
roles
:
:
LISTITEM_MARKER
)
{
return
true
;
}
Accessible
*
prev
=
PrevLeaf
(
aAcc
)
;
LocalAccessible
*
prevLocal
=
prev
?
prev
-
>
AsLocal
(
)
:
nullptr
;
if
(
!
prevLocal
)
{
return
true
;
}
if
(
prevLocal
-
>
NativeRole
(
)
=
=
roles
:
:
LISTITEM_MARKER
)
{
LocalAccessible
*
listItem
=
prevLocal
-
>
LocalParent
(
)
;
MOZ_ASSERT
(
listItem
)
;
LocalAccessible
*
doc
=
listItem
-
>
Document
(
)
;
MOZ_ASSERT
(
doc
)
;
for
(
LocalAccessible
*
parent
=
aAcc
-
>
LocalParent
(
)
;
parent
&
&
parent
!
=
doc
;
parent
=
parent
-
>
LocalParent
(
)
)
{
if
(
parent
=
=
listItem
)
{
return
false
;
}
}
}
nsIFrame
*
thisFrame
=
aAcc
-
>
GetFrame
(
)
;
if
(
!
thisFrame
)
{
return
false
;
}
nsIFrame
:
:
GetFirstLeaf
(
&
thisFrame
)
;
nsIFrame
*
prevFrame
=
prevLocal
-
>
GetFrame
(
)
;
if
(
!
prevFrame
)
{
return
false
;
}
nsIFrame
:
:
GetLastLeaf
(
&
prevFrame
)
;
auto
[
thisBlock
thisLineFrame
]
=
thisFrame
-
>
GetContainingBlockForLine
(
false
)
;
if
(
!
thisBlock
)
{
return
true
;
}
auto
[
prevBlock
prevLineFrame
]
=
prevFrame
-
>
GetContainingBlockForLine
(
false
)
;
if
(
thisBlock
!
=
prevBlock
)
{
return
true
;
}
nsAutoLineIterator
it
=
prevBlock
-
>
GetLineIterator
(
)
;
MOZ_ASSERT
(
it
"
GetLineIterator
impl
in
line
-
container
blocks
is
infallible
"
)
;
int32_t
prevLineNum
=
it
-
>
FindLineContaining
(
prevLineFrame
)
;
if
(
prevLineNum
<
0
)
{
return
true
;
}
int32_t
thisLineNum
=
it
-
>
FindLineContaining
(
thisLineFrame
prevLineNum
)
;
return
thisLineNum
!
=
prevLineNum
;
}
enum
WordBreakClass
{
eWbcSpace
=
0
eWbcPunct
eWbcOther
}
;
static
WordBreakClass
GetWordBreakClass
(
char16_t
aChar
)
{
const
char16_t
kCharNbsp
=
0xA0
;
switch
(
aChar
)
{
case
'
'
:
case
kCharNbsp
:
case
'
\
t
'
:
case
'
\
f
'
:
case
'
\
n
'
:
case
'
\
r
'
:
return
eWbcSpace
;
default
:
break
;
}
uint8_t
cat
=
unicode
:
:
GetGeneralCategory
(
aChar
)
;
switch
(
cat
)
{
case
HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION
:
if
(
aChar
=
=
'
_
'
&
&
!
StaticPrefs
:
:
layout_word_select_stop_at_underscore
(
)
)
{
return
eWbcOther
;
}
[
[
fallthrough
]
]
;
case
HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL
:
case
HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL
:
case
HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL
:
return
eWbcPunct
;
default
:
break
;
}
return
eWbcOther
;
}
class
PrevWordBreakClassWalker
{
public
:
PrevWordBreakClassWalker
(
Accessible
*
aAcc
const
nsAString
&
aText
int32_t
aOffset
)
:
mAcc
(
aAcc
)
mText
(
aText
)
mOffset
(
aOffset
)
{
mClass
=
GetWordBreakClass
(
mText
.
CharAt
(
mOffset
)
)
;
}
WordBreakClass
CurClass
(
)
{
return
mClass
;
}
Maybe
<
WordBreakClass
>
PrevClass
(
)
{
for
(
;
;
)
{
if
(
!
PrevChar
(
)
)
{
return
Nothing
(
)
;
}
WordBreakClass
curClass
=
GetWordBreakClass
(
mText
.
CharAt
(
mOffset
)
)
;
if
(
curClass
!
=
mClass
)
{
mClass
=
curClass
;
return
Some
(
curClass
)
;
}
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
Nothing
(
)
;
}
bool
IsStartOfGroup
(
)
{
if
(
!
PrevChar
(
)
)
{
return
true
;
}
WordBreakClass
curClass
=
GetWordBreakClass
(
mText
.
CharAt
(
mOffset
)
)
;
+
+
mOffset
;
return
curClass
!
=
mClass
;
}
private
:
bool
PrevChar
(
)
{
if
(
mOffset
>
0
)
{
-
-
mOffset
;
return
true
;
}
if
(
!
mAcc
)
{
return
false
;
}
mAcc
=
PrevLeaf
(
mAcc
)
;
if
(
!
mAcc
)
{
return
false
;
}
mText
.
Truncate
(
)
;
mAcc
-
>
AppendTextTo
(
mText
)
;
mOffset
=
static_cast
<
int32_t
>
(
mText
.
Length
(
)
)
-
1
;
return
true
;
}
Accessible
*
mAcc
;
nsAutoString
mText
;
int32_t
mOffset
;
WordBreakClass
mClass
;
}
;
static
bool
IsAcceptableWordStart
(
Accessible
*
aAcc
const
nsAutoString
&
aText
int32_t
aOffset
)
{
PrevWordBreakClassWalker
walker
(
aAcc
aText
aOffset
)
;
if
(
!
walker
.
IsStartOfGroup
(
)
)
{
return
false
;
}
WordBreakClass
curClass
=
walker
.
CurClass
(
)
;
if
(
curClass
=
=
eWbcSpace
)
{
return
false
;
}
Maybe
<
WordBreakClass
>
prevClass
=
walker
.
PrevClass
(
)
;
if
(
curClass
=
=
eWbcPunct
&
&
(
!
prevClass
|
|
prevClass
.
value
(
)
!
=
eWbcSpace
)
)
{
return
false
;
}
if
(
!
prevClass
|
|
prevClass
.
value
(
)
!
=
eWbcPunct
)
{
return
true
;
}
if
(
!
StaticPrefs
:
:
layout_word_select_stop_at_punctuation
(
)
)
{
return
false
;
}
Maybe
<
WordBreakClass
>
prevPrevClass
=
walker
.
PrevClass
(
)
;
if
(
!
prevPrevClass
|
|
prevPrevClass
.
value
(
)
=
=
eWbcSpace
)
{
return
false
;
}
return
true
;
}
class
BlockRule
:
public
PivotRule
{
public
:
virtual
uint16_t
Match
(
Accessible
*
aAcc
)
override
{
if
(
RefPtr
<
nsAtom
>
(
aAcc
-
>
DisplayStyle
(
)
)
=
=
nsGkAtoms
:
:
block
|
|
aAcc
-
>
IsHTMLListItem
(
)
|
|
(
aAcc
-
>
IsText
(
)
&
&
aAcc
-
>
Role
(
)
=
=
roles
:
:
LISTITEM_MARKER
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
}
}
;
TextLeafPoint
:
:
TextLeafPoint
(
Accessible
*
aAcc
int32_t
aOffset
)
{
if
(
aOffset
!
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
&
&
aAcc
-
>
HasChildren
(
)
)
{
for
(
Accessible
*
acc
=
aAcc
-
>
FirstChild
(
)
;
acc
;
acc
=
acc
-
>
FirstChild
(
)
)
{
mAcc
=
acc
;
}
mOffset
=
0
;
return
;
}
mAcc
=
aAcc
;
mOffset
=
aOffset
;
}
bool
TextLeafPoint
:
:
operator
<
(
const
TextLeafPoint
&
aPoint
)
const
{
if
(
mAcc
=
=
aPoint
.
mAcc
)
{
return
mOffset
<
aPoint
.
mOffset
;
}
return
mAcc
-
>
IsBefore
(
aPoint
.
mAcc
)
;
}
bool
TextLeafPoint
:
:
IsEmptyLastLine
(
)
const
{
if
(
mAcc
-
>
IsHTMLBr
(
)
&
&
mOffset
=
=
1
)
{
return
true
;
}
if
(
!
mAcc
-
>
IsTextLeaf
(
)
)
{
return
false
;
}
if
(
mOffset
<
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
mAcc
)
)
)
{
return
false
;
}
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
mOffset
-
1
1
)
;
return
text
.
CharAt
(
0
)
=
=
'
\
n
'
;
}
char16_t
TextLeafPoint
:
:
GetChar
(
)
const
{
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
mOffset
1
)
;
return
text
.
CharAt
(
0
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindPrevLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
{
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
;
MOZ_ASSERT
(
acc
)
;
if
(
mOffset
=
=
0
)
{
if
(
aIncludeOrigin
&
&
IsLocalAccAtLineStart
(
acc
)
)
{
return
*
this
;
}
return
TextLeafPoint
(
)
;
}
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
!
frame
)
{
return
TextLeafPoint
(
)
;
}
if
(
!
frame
-
>
IsTextFrame
(
)
)
{
if
(
IsLocalAccAtLineStart
(
acc
)
)
{
return
TextLeafPoint
(
acc
0
)
;
}
return
TextLeafPoint
(
)
;
}
int32_t
origOffset
=
mOffset
;
origOffset
=
RenderedToContentOffset
(
acc
origOffset
)
;
nsTextFrame
*
continuation
=
nullptr
;
int32_t
unusedOffsetInContinuation
=
0
;
frame
-
>
GetChildFrameContainingOffset
(
origOffset
true
&
unusedOffsetInContinuation
(
nsIFrame
*
*
)
&
continuation
)
;
MOZ_ASSERT
(
continuation
)
;
int32_t
lineStart
=
continuation
-
>
GetContentOffset
(
)
;
if
(
!
aIncludeOrigin
&
&
lineStart
>
0
&
&
lineStart
=
=
origOffset
)
{
continuation
=
continuation
-
>
GetPrevContinuation
(
)
;
MOZ_ASSERT
(
continuation
)
;
lineStart
=
continuation
-
>
GetContentOffset
(
)
;
}
MOZ_ASSERT
(
lineStart
>
=
0
)
;
if
(
lineStart
=
=
0
&
&
!
IsLocalAccAtLineStart
(
acc
)
)
{
return
TextLeafPoint
(
)
;
}
lineStart
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
acc
lineStart
)
)
;
return
TextLeafPoint
(
acc
lineStart
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindNextLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
{
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
;
MOZ_ASSERT
(
acc
)
;
if
(
aIncludeOrigin
&
&
mOffset
=
=
0
&
&
IsLocalAccAtLineStart
(
acc
)
)
{
return
*
this
;
}
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
!
frame
)
{
return
TextLeafPoint
(
)
;
}
if
(
!
frame
-
>
IsTextFrame
(
)
)
{
return
TextLeafPoint
(
)
;
}
int32_t
origOffset
=
mOffset
;
origOffset
=
RenderedToContentOffset
(
acc
origOffset
)
;
nsTextFrame
*
continuation
=
nullptr
;
int32_t
unusedOffsetInContinuation
=
0
;
frame
-
>
GetChildFrameContainingOffset
(
origOffset
true
&
unusedOffsetInContinuation
(
nsIFrame
*
*
)
&
continuation
)
;
MOZ_ASSERT
(
continuation
)
;
if
(
aIncludeOrigin
&
&
continuation
-
>
GetContentOffset
(
)
=
=
origOffset
&
&
!
(
origOffset
=
=
0
&
&
!
IsLocalAccAtLineStart
(
acc
)
)
)
{
return
*
this
;
}
continuation
=
continuation
-
>
GetNextContinuation
(
)
;
if
(
!
continuation
)
{
return
TextLeafPoint
(
)
;
}
int32_t
lineStart
=
continuation
-
>
GetContentOffset
(
)
;
lineStart
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
acc
lineStart
)
)
;
return
TextLeafPoint
(
acc
lineStart
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindLineStartSameRemoteAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
RemoteAccessible
*
acc
=
mAcc
-
>
AsRemote
(
)
;
MOZ_ASSERT
(
acc
)
;
auto
lines
=
acc
-
>
GetCachedTextLines
(
)
;
if
(
!
lines
)
{
return
TextLeafPoint
(
)
;
}
size_t
index
;
if
(
BinarySearch
(
*
lines
0
lines
-
>
Length
(
)
mOffset
&
index
)
)
{
if
(
aIncludeOrigin
)
{
return
*
this
;
}
if
(
aDirection
=
=
eDirNext
)
{
+
+
index
;
}
}
MOZ_ASSERT
(
index
<
=
lines
-
>
Length
(
)
)
;
if
(
(
aDirection
=
=
eDirNext
&
&
index
=
=
lines
-
>
Length
(
)
)
|
|
index
=
=
0
)
{
return
TextLeafPoint
(
)
;
}
if
(
aDirection
=
=
eDirPrevious
)
{
-
-
index
;
}
return
TextLeafPoint
(
mAcc
lines
-
>
ElementAt
(
index
)
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindLineStartSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
if
(
mAcc
-
>
IsLocal
(
)
)
{
return
aDirection
=
=
eDirNext
?
FindNextLineStartSameLocalAcc
(
aIncludeOrigin
)
:
FindPrevLineStartSameLocalAcc
(
aIncludeOrigin
)
;
}
return
FindLineStartSameRemoteAcc
(
aDirection
aIncludeOrigin
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindPrevWordStartSameAcc
(
bool
aIncludeOrigin
)
const
{
if
(
mOffset
=
=
0
&
&
!
aIncludeOrigin
)
{
return
TextLeafPoint
(
)
;
}
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
)
;
TextLeafPoint
lineStart
=
*
this
;
if
(
!
aIncludeOrigin
|
|
(
lineStart
.
mOffset
=
=
1
&
&
text
.
Length
(
)
=
=
1
&
&
text
.
CharAt
(
0
)
=
=
'
\
n
'
)
)
{
-
-
lineStart
.
mOffset
;
}
for
(
;
lineStart
.
mOffset
>
=
0
&
&
text
.
CharAt
(
lineStart
.
mOffset
)
=
=
'
\
n
'
;
-
-
lineStart
.
mOffset
)
{
}
if
(
lineStart
.
mOffset
<
0
)
{
lineStart
=
TextLeafPoint
(
)
;
}
else
{
lineStart
=
lineStart
.
FindLineStartSameAcc
(
eDirPrevious
true
)
;
}
intl
:
:
WordRange
word
;
if
(
mOffset
=
=
0
)
{
word
.
mBegin
=
0
;
}
else
if
(
mOffset
=
=
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
)
{
word
=
WordBreaker
:
:
FindWord
(
text
.
get
(
)
text
.
Length
(
)
mOffset
-
1
)
;
}
else
{
word
=
WordBreaker
:
:
FindWord
(
text
.
get
(
)
text
.
Length
(
)
mOffset
)
;
}
for
(
;
;
word
=
WordBreaker
:
:
FindWord
(
text
.
get
(
)
text
.
Length
(
)
word
.
mBegin
-
1
)
)
{
if
(
!
aIncludeOrigin
&
&
static_cast
<
int32_t
>
(
word
.
mBegin
)
=
=
mOffset
)
{
MOZ_ASSERT
(
word
.
mBegin
!
=
0
)
;
continue
;
}
if
(
lineStart
&
&
static_cast
<
int32_t
>
(
word
.
mBegin
)
<
lineStart
.
mOffset
)
{
return
lineStart
;
}
if
(
IsAcceptableWordStart
(
mAcc
text
static_cast
<
int32_t
>
(
word
.
mBegin
)
)
)
{
break
;
}
if
(
word
.
mBegin
=
=
0
)
{
if
(
lineStart
)
{
return
lineStart
;
}
return
TextLeafPoint
(
)
;
}
}
return
TextLeafPoint
(
mAcc
static_cast
<
int32_t
>
(
word
.
mBegin
)
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindNextWordStartSameAcc
(
bool
aIncludeOrigin
)
const
{
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
)
;
int32_t
wordStart
=
mOffset
;
if
(
aIncludeOrigin
)
{
if
(
wordStart
=
=
0
)
{
if
(
IsAcceptableWordStart
(
mAcc
text
0
)
)
{
return
*
this
;
}
}
else
{
-
-
wordStart
;
}
}
TextLeafPoint
lineStart
=
FindLineStartSameAcc
(
eDirNext
aIncludeOrigin
)
;
if
(
lineStart
)
{
for
(
;
lineStart
.
mOffset
<
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
&
&
text
.
CharAt
(
lineStart
.
mOffset
)
=
=
'
\
n
'
;
+
+
lineStart
.
mOffset
)
{
}
if
(
lineStart
.
mOffset
=
=
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
)
{
lineStart
=
TextLeafPoint
(
)
;
}
}
intl
:
:
WordBreakIteratorUtf16
wordBreakIter
(
text
)
;
Maybe
<
uint32_t
>
nextBreak
=
wordBreakIter
.
Seek
(
wordStart
)
;
for
(
;
;
)
{
if
(
!
nextBreak
|
|
*
nextBreak
=
=
text
.
Length
(
)
)
{
if
(
lineStart
)
{
return
lineStart
;
}
return
TextLeafPoint
(
)
;
}
wordStart
=
AssertedCast
<
int32_t
>
(
*
nextBreak
)
;
if
(
lineStart
&
&
wordStart
>
lineStart
.
mOffset
)
{
return
lineStart
;
}
if
(
IsAcceptableWordStart
(
mAcc
text
wordStart
)
)
{
break
;
}
nextBreak
=
wordBreakIter
.
Next
(
)
;
}
return
TextLeafPoint
(
mAcc
wordStart
)
;
}
bool
TextLeafPoint
:
:
IsCaretAtEndOfLine
(
)
const
{
MOZ_ASSERT
(
IsCaret
(
)
)
;
if
(
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
)
{
HyperTextAccessible
*
ht
=
HyperTextFor
(
acc
)
;
if
(
!
ht
)
{
return
false
;
}
return
ht
-
>
IsCaretAtEndOfLine
(
)
;
}
return
mAcc
-
>
AsRemote
(
)
-
>
Document
(
)
-
>
IsCaretAtEndOfLine
(
)
;
}
TextLeafPoint
TextLeafPoint
:
:
ActualizeCaret
(
bool
aAdjustAtEndOfLine
)
const
{
MOZ_ASSERT
(
IsCaret
(
)
)
;
HyperTextAccessibleBase
*
ht
;
int32_t
htOffset
;
if
(
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
)
{
ht
=
HyperTextFor
(
acc
)
;
if
(
!
ht
)
{
return
TextLeafPoint
(
)
;
}
htOffset
=
ht
-
>
CaretOffset
(
)
;
if
(
htOffset
=
=
-
1
)
{
return
TextLeafPoint
(
)
;
}
}
else
{
std
:
:
tie
(
ht
htOffset
)
=
mAcc
-
>
AsRemote
(
)
-
>
Document
(
)
-
>
GetCaret
(
)
;
if
(
!
ht
)
{
return
TextLeafPoint
(
)
;
}
}
if
(
aAdjustAtEndOfLine
&
&
htOffset
>
0
&
&
IsCaretAtEndOfLine
(
)
)
{
-
-
htOffset
;
}
return
ht
-
>
ToTextLeafPoint
(
htOffset
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindBoundary
(
AccessibleTextBoundary
aBoundaryType
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
if
(
IsCaret
(
)
)
{
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
)
{
if
(
IsCaretAtEndOfLine
(
)
)
{
return
ActualizeCaret
(
false
)
;
}
}
return
ActualizeCaret
(
)
.
FindBoundary
(
aBoundaryType
aDirection
aIncludeOrigin
)
;
}
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_LINE_END
)
{
return
FindLineEnd
(
aDirection
aIncludeOrigin
)
;
}
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_WORD_END
)
{
return
FindWordEnd
(
aDirection
aIncludeOrigin
)
;
}
if
(
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_LINE_START
|
|
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_PARAGRAPH
)
&
&
aIncludeOrigin
&
&
aDirection
=
=
eDirPrevious
&
&
IsEmptyLastLine
(
)
)
{
return
*
this
;
}
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
&
&
aIncludeOrigin
)
{
return
*
this
;
}
TextLeafPoint
searchFrom
=
*
this
;
bool
includeOrigin
=
aIncludeOrigin
;
for
(
;
;
)
{
TextLeafPoint
boundary
;
switch
(
aBoundaryType
)
{
case
nsIAccessibleText
:
:
BOUNDARY_CHAR
:
if
(
aDirection
=
=
eDirPrevious
&
&
searchFrom
.
mOffset
>
0
)
{
boundary
.
mAcc
=
searchFrom
.
mAcc
;
boundary
.
mOffset
=
searchFrom
.
mOffset
-
1
;
}
else
if
(
aDirection
=
=
eDirNext
)
{
if
(
includeOrigin
)
{
boundary
=
searchFrom
;
}
else
if
(
searchFrom
.
mOffset
+
1
<
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
searchFrom
.
mAcc
)
)
)
{
boundary
.
mAcc
=
searchFrom
.
mAcc
;
boundary
.
mOffset
=
searchFrom
.
mOffset
+
1
;
}
}
break
;
case
nsIAccessibleText
:
:
BOUNDARY_WORD_START
:
if
(
aDirection
=
=
eDirPrevious
)
{
boundary
=
searchFrom
.
FindPrevWordStartSameAcc
(
includeOrigin
)
;
}
else
{
boundary
=
searchFrom
.
FindNextWordStartSameAcc
(
includeOrigin
)
;
}
break
;
case
nsIAccessibleText
:
:
BOUNDARY_LINE_START
:
boundary
=
searchFrom
.
FindLineStartSameAcc
(
aDirection
includeOrigin
)
;
break
;
case
nsIAccessibleText
:
:
BOUNDARY_PARAGRAPH
:
boundary
=
searchFrom
.
FindParagraphSameAcc
(
aDirection
includeOrigin
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
)
;
break
;
}
if
(
boundary
)
{
return
boundary
;
}
Accessible
*
acc
=
aDirection
=
=
eDirPrevious
?
PrevLeaf
(
searchFrom
.
mAcc
)
:
NextLeaf
(
searchFrom
.
mAcc
)
;
if
(
!
acc
)
{
return
TextLeafPoint
(
searchFrom
.
mAcc
aDirection
=
=
eDirPrevious
?
0
:
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
searchFrom
.
mAcc
)
)
)
;
}
searchFrom
.
mAcc
=
acc
;
searchFrom
.
mOffset
=
aDirection
=
=
eDirPrevious
?
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
acc
)
)
:
0
;
includeOrigin
=
true
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
TextLeafPoint
(
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindLineEnd
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
if
(
aDirection
=
=
eDirPrevious
&
&
IsEmptyLastLine
(
)
)
{
return
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
)
;
}
if
(
aIncludeOrigin
&
&
IsLineFeedChar
(
)
)
{
return
*
this
;
}
if
(
aDirection
=
=
eDirPrevious
&
&
!
aIncludeOrigin
)
{
TextLeafPoint
prevChar
=
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
)
;
if
(
prevChar
.
IsLineFeedChar
(
)
)
{
return
prevChar
;
}
}
TextLeafPoint
searchFrom
=
*
this
;
if
(
aDirection
=
=
eDirNext
&
&
(
IsLineFeedChar
(
)
|
|
IsEmptyLastLine
(
)
)
)
{
searchFrom
=
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirNext
)
;
}
TextLeafPoint
lineStart
=
searchFrom
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_LINE_START
aDirection
aIncludeOrigin
)
;
TextLeafPoint
prevChar
=
lineStart
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
false
)
;
if
(
prevChar
&
&
prevChar
.
IsLineFeedChar
(
)
)
{
return
prevChar
;
}
return
lineStart
;
}
bool
TextLeafPoint
:
:
IsSpace
(
)
const
{
return
GetWordBreakClass
(
GetChar
(
)
)
=
=
eWbcSpace
;
}
TextLeafPoint
TextLeafPoint
:
:
FindWordEnd
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
char16_t
origChar
=
GetChar
(
)
;
const
bool
origIsSpace
=
GetWordBreakClass
(
origChar
)
=
=
eWbcSpace
;
bool
prevIsSpace
=
false
;
if
(
aDirection
=
=
eDirPrevious
|
|
(
aIncludeOrigin
&
&
origIsSpace
)
|
|
!
origChar
)
{
TextLeafPoint
prev
=
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
false
)
;
if
(
aDirection
=
=
eDirPrevious
&
&
prev
=
=
*
this
)
{
return
*
this
;
}
prevIsSpace
=
prev
.
IsSpace
(
)
;
if
(
aIncludeOrigin
&
&
origIsSpace
&
&
!
prevIsSpace
)
{
return
*
this
;
}
}
TextLeafPoint
boundary
=
*
this
;
if
(
aDirection
=
=
eDirPrevious
&
&
!
prevIsSpace
)
{
boundary
=
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_WORD_START
eDirPrevious
aIncludeOrigin
)
;
}
else
if
(
aDirection
=
=
eDirNext
&
&
(
origIsSpace
|
|
(
!
origChar
&
&
prevIsSpace
)
)
)
{
boundary
=
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_WORD_START
eDirNext
false
)
;
if
(
boundary
.
IsSpace
(
)
)
{
return
boundary
;
}
}
if
(
aDirection
=
=
eDirNext
)
{
boundary
=
boundary
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_WORD_START
eDirNext
aIncludeOrigin
)
;
}
TextLeafPoint
prev
=
boundary
;
for
(
;
;
)
{
prev
=
prev
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
)
;
if
(
prev
=
=
boundary
)
{
break
;
}
if
(
!
prev
.
IsSpace
(
)
)
{
break
;
}
boundary
=
prev
;
}
return
boundary
;
}
TextLeafPoint
TextLeafPoint
:
:
FindParagraphSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
if
(
mAcc
-
>
IsTextLeaf
(
)
&
&
(
(
aIncludeOrigin
&
&
mOffset
>
0
)
|
|
aDirection
=
=
eDirNext
|
|
mOffset
>
=
2
)
)
{
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
)
;
if
(
aIncludeOrigin
&
&
mOffset
>
0
&
&
text
.
CharAt
(
mOffset
-
1
)
=
=
'
\
n
'
)
{
return
TextLeafPoint
(
mAcc
mOffset
)
;
}
int32_t
lfOffset
=
-
1
;
if
(
aDirection
=
=
eDirNext
)
{
lfOffset
=
text
.
FindChar
(
'
\
n
'
mOffset
)
;
}
else
if
(
mOffset
>
=
2
)
{
lfOffset
=
text
.
RFindChar
(
'
\
n
'
mOffset
-
2
)
;
}
if
(
lfOffset
!
=
-
1
&
&
lfOffset
+
1
<
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
)
{
return
TextLeafPoint
(
mAcc
lfOffset
+
1
)
;
}
}
if
(
(
!
aIncludeOrigin
&
&
mOffset
=
=
0
)
|
|
(
aDirection
=
=
eDirNext
&
&
mOffset
>
0
)
)
{
return
TextLeafPoint
(
)
;
}
Accessible
*
prevLeaf
=
PrevLeaf
(
mAcc
)
;
BlockRule
blockRule
;
Pivot
pivot
(
DocumentFor
(
mAcc
)
)
;
Accessible
*
prevBlock
=
pivot
.
Prev
(
mAcc
blockRule
)
;
if
(
prevBlock
&
&
(
!
prevLeaf
|
|
prevBlock
=
=
prevLeaf
|
|
!
prevBlock
-
>
IsAncestorOf
(
mAcc
)
|
|
!
prevBlock
-
>
IsAncestorOf
(
prevLeaf
)
)
)
{
return
TextLeafPoint
(
mAcc
0
)
;
}
if
(
!
prevLeaf
|
|
prevLeaf
-
>
IsHTMLBr
(
)
)
{
return
TextLeafPoint
(
mAcc
0
)
;
}
if
(
prevLeaf
-
>
IsTextLeaf
(
)
)
{
nsAutoString
text
;
prevLeaf
-
>
AppendTextTo
(
text
nsAccUtils
:
:
TextLength
(
prevLeaf
)
-
1
1
)
;
if
(
text
.
CharAt
(
0
)
=
=
'
\
n
'
)
{
return
TextLeafPoint
(
mAcc
0
)
;
}
}
return
TextLeafPoint
(
)
;
}
already_AddRefed
<
AccAttributes
>
TextLeafPoint
:
:
GetTextAttributesLocalAcc
(
bool
aIncludeDefaults
)
const
{
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
;
MOZ_ASSERT
(
acc
)
;
MOZ_ASSERT
(
acc
-
>
IsText
(
)
)
;
LocalAccessible
*
parent
=
acc
-
>
LocalParent
(
)
;
HyperTextAccessible
*
hyperAcc
=
parent
-
>
AsHyperText
(
)
;
MOZ_ASSERT
(
hyperAcc
)
;
RefPtr
<
AccAttributes
>
attributes
=
new
AccAttributes
(
)
;
TextAttrsMgr
mgr
(
hyperAcc
aIncludeDefaults
acc
acc
?
acc
-
>
IndexInParent
(
)
:
-
1
)
;
mgr
.
GetAttributes
(
attributes
nullptr
nullptr
)
;
return
attributes
.
forget
(
)
;
}
already_AddRefed
<
AccAttributes
>
TextLeafPoint
:
:
GetTextAttributes
(
bool
aIncludeDefaults
)
const
{
if
(
!
mAcc
-
>
IsText
(
)
)
{
return
nullptr
;
}
if
(
mAcc
-
>
IsLocal
(
)
)
{
return
GetTextAttributesLocalAcc
(
aIncludeDefaults
)
;
}
RefPtr
<
AccAttributes
>
attrs
=
new
AccAttributes
(
)
;
if
(
aIncludeDefaults
)
{
Accessible
*
parent
=
mAcc
-
>
Parent
(
)
;
if
(
parent
&
&
parent
-
>
IsRemote
(
)
&
&
parent
-
>
IsHyperText
(
)
)
{
if
(
auto
defAttrs
=
parent
-
>
AsRemote
(
)
-
>
GetCachedTextAttributes
(
)
)
{
defAttrs
-
>
CopyTo
(
attrs
)
;
}
}
}
if
(
auto
thisAttrs
=
mAcc
-
>
AsRemote
(
)
-
>
GetCachedTextAttributes
(
)
)
{
thisAttrs
-
>
CopyTo
(
attrs
)
;
}
return
attrs
.
forget
(
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindTextAttrsStart
(
nsDirection
aDirection
bool
aIncludeOrigin
const
AccAttributes
*
aOriginAttrs
bool
aIncludeDefaults
)
const
{
if
(
IsCaret
(
)
)
{
return
ActualizeCaret
(
)
.
FindTextAttrsStart
(
aDirection
aIncludeOrigin
aOriginAttrs
aIncludeDefaults
)
;
}
RefPtr
<
const
AccAttributes
>
lastAttrs
;
const
bool
isRemote
=
mAcc
-
>
IsRemote
(
)
;
if
(
isRemote
)
{
lastAttrs
=
mAcc
-
>
AsRemote
(
)
-
>
GetCachedTextAttributes
(
)
;
}
else
{
if
(
aOriginAttrs
)
{
lastAttrs
=
aOriginAttrs
;
}
else
{
lastAttrs
=
GetTextAttributesLocalAcc
(
aIncludeDefaults
)
;
}
}
if
(
aIncludeOrigin
&
&
aDirection
=
=
eDirNext
&
&
mOffset
=
=
0
)
{
TextLeafPoint
point
;
point
.
mAcc
=
mAcc
-
>
PrevSibling
(
)
;
if
(
!
point
.
mAcc
|
|
!
point
.
mAcc
-
>
IsText
(
)
)
{
return
*
this
;
}
RefPtr
<
const
AccAttributes
>
attrs
=
isRemote
?
point
.
mAcc
-
>
AsRemote
(
)
-
>
GetCachedTextAttributes
(
)
:
point
.
GetTextAttributesLocalAcc
(
aIncludeDefaults
)
;
if
(
attrs
&
&
lastAttrs
&
&
!
attrs
-
>
Equal
(
lastAttrs
)
)
{
return
*
this
;
}
}
TextLeafPoint
lastPoint
(
mAcc
0
)
;
for
(
;
;
)
{
TextLeafPoint
point
;
point
.
mAcc
=
aDirection
=
=
eDirNext
?
lastPoint
.
mAcc
-
>
NextSibling
(
)
:
lastPoint
.
mAcc
-
>
PrevSibling
(
)
;
if
(
!
point
.
mAcc
|
|
!
point
.
mAcc
-
>
IsText
(
)
)
{
break
;
}
RefPtr
<
const
AccAttributes
>
attrs
=
isRemote
?
point
.
mAcc
-
>
AsRemote
(
)
-
>
GetCachedTextAttributes
(
)
:
point
.
GetTextAttributesLocalAcc
(
aIncludeDefaults
)
;
if
(
attrs
&
&
lastAttrs
&
&
!
attrs
-
>
Equal
(
lastAttrs
)
)
{
if
(
aDirection
=
=
eDirPrevious
)
{
point
=
lastPoint
;
}
if
(
!
aIncludeOrigin
&
&
point
=
=
*
this
)
{
MOZ_ASSERT
(
aDirection
=
=
eDirPrevious
)
;
continue
;
}
return
point
;
}
lastPoint
=
point
;
lastAttrs
=
attrs
;
}
return
TextLeafPoint
(
lastPoint
.
mAcc
aDirection
=
=
eDirPrevious
?
0
:
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
lastPoint
.
mAcc
)
)
)
;
}
}
