#
include
"
TextLeafRange
.
h
"
#
include
"
mozilla
/
a11y
/
Accessible
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessibleParent
.
h
"
#
include
"
mozilla
/
a11y
/
LocalAccessible
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
intl
/
WordBreaker
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIAccessiblePivot
.
h
"
#
include
"
nsILineIterator
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
Pivot
.
h
"
namespace
mozilla
:
:
a11y
{
static
int32_t
RenderedToContentOffset
(
LocalAccessible
*
aAcc
uint32_t
aRenderedOffset
)
{
if
(
aAcc
-
>
LocalParent
(
)
&
&
aAcc
-
>
LocalParent
(
)
-
>
IsTextField
(
)
)
{
return
static_cast
<
int32_t
>
(
aRenderedOffset
)
;
}
nsIFrame
*
frame
=
aAcc
-
>
GetFrame
(
)
;
MOZ_ASSERT
(
frame
&
&
frame
-
>
IsTextFrame
(
)
)
;
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
aRenderedOffset
aRenderedOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInRenderedText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
return
text
.
mOffsetWithinNodeText
;
}
static
uint32_t
ContentToRenderedOffset
(
LocalAccessible
*
aAcc
int32_t
aContentOffset
)
{
if
(
aAcc
-
>
LocalParent
(
)
&
&
aAcc
-
>
LocalParent
(
)
-
>
IsTextField
(
)
)
{
return
aContentOffset
;
}
nsIFrame
*
frame
=
aAcc
-
>
GetFrame
(
)
;
MOZ_ASSERT
(
frame
&
&
frame
-
>
IsTextFrame
(
)
)
;
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
aContentOffset
aContentOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInContentText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
return
text
.
mOffsetWithinNodeRenderedText
;
}
class
LeafRule
:
public
PivotRule
{
public
:
virtual
uint16_t
Match
(
Accessible
*
aAcc
)
override
{
if
(
aAcc
-
>
IsOuterDoc
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
!
aAcc
-
>
HasChildren
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
}
}
;
static
Accessible
*
DocumentFor
(
Accessible
*
aAcc
)
{
if
(
LocalAccessible
*
localAcc
=
aAcc
-
>
AsLocal
(
)
)
{
return
localAcc
-
>
Document
(
)
;
}
return
aAcc
-
>
AsRemote
(
)
-
>
Document
(
)
;
}
static
Accessible
*
NextLeaf
(
Accessible
*
aOrigin
)
{
Accessible
*
doc
=
DocumentFor
(
aOrigin
)
;
Pivot
pivot
(
doc
)
;
auto
rule
=
LeafRule
(
)
;
return
pivot
.
Next
(
aOrigin
rule
)
;
}
static
Accessible
*
PrevLeaf
(
Accessible
*
aOrigin
)
{
Accessible
*
doc
=
DocumentFor
(
aOrigin
)
;
Pivot
pivot
(
doc
)
;
auto
rule
=
LeafRule
(
)
;
return
pivot
.
Prev
(
aOrigin
rule
)
;
}
static
bool
IsLocalAccAtLineStart
(
LocalAccessible
*
aAcc
)
{
if
(
aAcc
-
>
NativeRole
(
)
=
=
roles
:
:
LISTITEM_MARKER
)
{
return
true
;
}
Accessible
*
prev
=
PrevLeaf
(
aAcc
)
;
LocalAccessible
*
prevLocal
=
prev
?
prev
-
>
AsLocal
(
)
:
nullptr
;
if
(
!
prevLocal
)
{
return
true
;
}
if
(
prevLocal
-
>
NativeRole
(
)
=
=
roles
:
:
LISTITEM_MARKER
)
{
LocalAccessible
*
listItem
=
prevLocal
-
>
LocalParent
(
)
;
MOZ_ASSERT
(
listItem
)
;
LocalAccessible
*
doc
=
listItem
-
>
Document
(
)
;
MOZ_ASSERT
(
doc
)
;
for
(
LocalAccessible
*
parent
=
aAcc
-
>
LocalParent
(
)
;
parent
&
&
parent
!
=
doc
;
parent
=
parent
-
>
LocalParent
(
)
)
{
if
(
parent
=
=
listItem
)
{
return
false
;
}
}
}
nsIFrame
*
thisFrame
=
aAcc
-
>
GetFrame
(
)
;
if
(
!
thisFrame
)
{
return
false
;
}
nsIFrame
:
:
GetFirstLeaf
(
&
thisFrame
)
;
nsIFrame
*
prevFrame
=
prevLocal
-
>
GetFrame
(
)
;
if
(
!
prevFrame
)
{
return
false
;
}
nsIFrame
:
:
GetLastLeaf
(
&
prevFrame
)
;
auto
[
thisBlock
thisLineFrame
]
=
thisFrame
-
>
GetContainingBlockForLine
(
false
)
;
if
(
!
thisBlock
)
{
return
true
;
}
auto
[
prevBlock
prevLineFrame
]
=
prevFrame
-
>
GetContainingBlockForLine
(
false
)
;
if
(
thisBlock
!
=
prevBlock
)
{
return
true
;
}
nsAutoLineIterator
it
=
prevBlock
-
>
GetLineIterator
(
)
;
MOZ_ASSERT
(
it
"
GetLineIterator
impl
in
line
-
container
blocks
is
infallible
"
)
;
int32_t
prevLineNum
=
it
-
>
FindLineContaining
(
prevLineFrame
)
;
if
(
prevLineNum
<
0
)
{
return
true
;
}
int32_t
thisLineNum
=
it
-
>
FindLineContaining
(
thisLineFrame
prevLineNum
)
;
return
thisLineNum
!
=
prevLineNum
;
}
enum
WordBreakClass
{
eWbcSpace
=
0
eWbcPunct
eWbcOther
}
;
class
PrevWordBreakClassWalker
{
public
:
PrevWordBreakClassWalker
(
Accessible
*
aAcc
const
nsAString
&
aText
int32_t
aOffset
)
:
mAcc
(
aAcc
)
mText
(
aText
)
mOffset
(
aOffset
)
{
mClass
=
GetClass
(
mText
.
CharAt
(
mOffset
)
)
;
}
WordBreakClass
CurClass
(
)
{
return
mClass
;
}
Maybe
<
WordBreakClass
>
PrevClass
(
)
{
for
(
;
;
)
{
if
(
!
PrevChar
(
)
)
{
return
Nothing
(
)
;
}
WordBreakClass
curClass
=
GetClass
(
mText
.
CharAt
(
mOffset
)
)
;
if
(
curClass
!
=
mClass
)
{
mClass
=
curClass
;
return
Some
(
curClass
)
;
}
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
Nothing
(
)
;
}
bool
IsStartOfGroup
(
)
{
PrevChar
(
)
;
WordBreakClass
curClass
=
GetClass
(
mText
.
CharAt
(
mOffset
)
)
;
+
+
mOffset
;
return
curClass
!
=
mClass
;
}
private
:
bool
PrevChar
(
)
{
if
(
mOffset
>
0
)
{
-
-
mOffset
;
return
true
;
}
mAcc
=
PrevLeaf
(
mAcc
)
;
if
(
!
mAcc
)
{
return
false
;
}
mText
.
Truncate
(
)
;
mAcc
-
>
AppendTextTo
(
mText
)
;
mOffset
=
static_cast
<
int32_t
>
(
mText
.
Length
(
)
)
-
1
;
return
true
;
}
WordBreakClass
GetClass
(
char16_t
aChar
)
{
const
char16_t
kCharNbsp
=
0xA0
;
switch
(
aChar
)
{
case
'
'
:
case
kCharNbsp
:
case
'
\
t
'
:
case
'
\
f
'
:
case
'
\
n
'
:
case
'
\
r
'
:
return
eWbcSpace
;
default
:
break
;
}
uint8_t
cat
=
unicode
:
:
GetGeneralCategory
(
aChar
)
;
switch
(
cat
)
{
case
HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION
:
if
(
aChar
=
=
'
_
'
&
&
!
StaticPrefs
:
:
layout_word_select_stop_at_underscore
(
)
)
{
return
eWbcOther
;
}
[
[
fallthrough
]
]
;
case
HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL
:
case
HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL
:
case
HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL
:
return
eWbcPunct
;
default
:
break
;
}
return
eWbcOther
;
}
Accessible
*
mAcc
;
nsAutoString
mText
;
int32_t
mOffset
;
WordBreakClass
mClass
;
}
;
static
bool
IsAcceptableWordStart
(
intl
:
:
WordBreaker
*
aBreaker
Accessible
*
aAcc
const
nsAutoString
&
aText
int32_t
aOffset
)
{
PrevWordBreakClassWalker
walker
(
aAcc
aText
aOffset
)
;
if
(
!
walker
.
IsStartOfGroup
(
)
)
{
return
false
;
}
WordBreakClass
curClass
=
walker
.
CurClass
(
)
;
if
(
curClass
=
=
eWbcSpace
)
{
return
false
;
}
Maybe
<
WordBreakClass
>
prevClass
=
walker
.
PrevClass
(
)
;
if
(
curClass
=
=
eWbcPunct
&
&
(
!
prevClass
|
|
prevClass
.
value
(
)
!
=
eWbcSpace
)
)
{
return
false
;
}
if
(
!
prevClass
|
|
prevClass
.
value
(
)
!
=
eWbcPunct
)
{
return
true
;
}
if
(
!
StaticPrefs
:
:
layout_word_select_stop_at_punctuation
(
)
)
{
return
false
;
}
Maybe
<
WordBreakClass
>
prevPrevClass
=
walker
.
PrevClass
(
)
;
if
(
!
prevPrevClass
|
|
prevPrevClass
.
value
(
)
=
=
eWbcSpace
)
{
return
false
;
}
return
true
;
}
TextLeafPoint
:
:
TextLeafPoint
(
Accessible
*
aAcc
int32_t
aOffset
)
{
if
(
aAcc
-
>
HasChildren
(
)
)
{
for
(
Accessible
*
acc
=
aAcc
-
>
FirstChild
(
)
;
acc
;
acc
=
acc
-
>
FirstChild
(
)
)
{
mAcc
=
acc
;
}
mOffset
=
0
;
return
;
}
mAcc
=
aAcc
;
mOffset
=
aOffset
;
}
bool
TextLeafPoint
:
:
operator
<
(
const
TextLeafPoint
&
aPoint
)
const
{
if
(
mAcc
=
=
aPoint
.
mAcc
)
{
return
mOffset
<
aPoint
.
mOffset
;
}
Accessible
*
thisP
=
mAcc
;
Accessible
*
otherP
=
aPoint
.
mAcc
;
AutoTArray
<
Accessible
*
30
>
thisParents
otherParents
;
do
{
thisParents
.
AppendElement
(
thisP
)
;
thisP
=
thisP
-
>
Parent
(
)
;
}
while
(
thisP
)
;
do
{
otherParents
.
AppendElement
(
otherP
)
;
otherP
=
otherP
-
>
Parent
(
)
;
}
while
(
otherP
)
;
uint32_t
thisPos
=
thisParents
.
Length
(
)
otherPos
=
otherParents
.
Length
(
)
;
for
(
uint32_t
len
=
std
:
:
min
(
thisPos
otherPos
)
;
len
>
0
;
-
-
len
)
{
Accessible
*
thisChild
=
thisParents
.
ElementAt
(
-
-
thisPos
)
;
Accessible
*
otherChild
=
otherParents
.
ElementAt
(
-
-
otherPos
)
;
if
(
thisChild
!
=
otherChild
)
{
return
thisChild
-
>
IndexInParent
(
)
<
otherChild
-
>
IndexInParent
(
)
;
}
}
MOZ_ASSERT
(
thisPos
!
=
0
|
|
otherPos
!
=
0
)
;
MOZ_ASSERT
(
thisPos
!
=
otherPos
)
;
return
otherPos
>
0
;
}
bool
TextLeafPoint
:
:
IsEmptyLastLine
(
)
const
{
if
(
mAcc
-
>
IsHTMLBr
(
)
&
&
mOffset
=
=
1
)
{
return
true
;
}
if
(
!
mAcc
-
>
IsTextLeaf
(
)
)
{
return
false
;
}
if
(
mOffset
<
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
mAcc
)
)
)
{
return
false
;
}
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
mOffset
-
1
1
)
;
return
text
.
CharAt
(
0
)
=
=
'
\
n
'
;
}
TextLeafPoint
TextLeafPoint
:
:
FindPrevLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
{
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
;
MOZ_ASSERT
(
acc
)
;
if
(
mOffset
=
=
0
)
{
if
(
aIncludeOrigin
&
&
IsLocalAccAtLineStart
(
acc
)
)
{
return
*
this
;
}
return
TextLeafPoint
(
)
;
}
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
!
frame
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
frame
"
)
;
return
TextLeafPoint
(
)
;
}
if
(
!
frame
-
>
IsTextFrame
(
)
)
{
if
(
IsLocalAccAtLineStart
(
acc
)
)
{
return
TextLeafPoint
(
acc
0
)
;
}
return
TextLeafPoint
(
)
;
}
int32_t
origOffset
=
mOffset
;
origOffset
=
RenderedToContentOffset
(
acc
origOffset
)
;
nsTextFrame
*
continuation
=
nullptr
;
int32_t
unusedOffsetInContinuation
=
0
;
frame
-
>
GetChildFrameContainingOffset
(
origOffset
true
&
unusedOffsetInContinuation
(
nsIFrame
*
*
)
&
continuation
)
;
MOZ_ASSERT
(
continuation
)
;
int32_t
lineStart
=
continuation
-
>
GetContentOffset
(
)
;
if
(
!
aIncludeOrigin
&
&
lineStart
>
0
&
&
lineStart
=
=
origOffset
)
{
continuation
=
continuation
-
>
GetPrevContinuation
(
)
;
MOZ_ASSERT
(
continuation
)
;
lineStart
=
continuation
-
>
GetContentOffset
(
)
;
}
MOZ_ASSERT
(
lineStart
>
=
0
)
;
if
(
lineStart
=
=
0
&
&
!
IsLocalAccAtLineStart
(
acc
)
)
{
return
TextLeafPoint
(
)
;
}
lineStart
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
acc
lineStart
)
)
;
return
TextLeafPoint
(
acc
lineStart
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindNextLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
{
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
;
MOZ_ASSERT
(
acc
)
;
if
(
aIncludeOrigin
&
&
mOffset
=
=
0
&
&
IsLocalAccAtLineStart
(
acc
)
)
{
return
*
this
;
}
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
!
frame
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
frame
"
)
;
return
TextLeafPoint
(
)
;
}
if
(
!
frame
-
>
IsTextFrame
(
)
)
{
return
TextLeafPoint
(
)
;
}
int32_t
origOffset
=
mOffset
;
origOffset
=
RenderedToContentOffset
(
acc
origOffset
)
;
nsTextFrame
*
continuation
=
nullptr
;
int32_t
unusedOffsetInContinuation
=
0
;
frame
-
>
GetChildFrameContainingOffset
(
origOffset
true
&
unusedOffsetInContinuation
(
nsIFrame
*
*
)
&
continuation
)
;
MOZ_ASSERT
(
continuation
)
;
if
(
aIncludeOrigin
&
&
continuation
-
>
GetContentOffset
(
)
=
=
origOffset
&
&
!
(
origOffset
=
=
0
&
&
!
IsLocalAccAtLineStart
(
acc
)
)
)
{
return
*
this
;
}
continuation
=
continuation
-
>
GetNextContinuation
(
)
;
if
(
!
continuation
)
{
return
TextLeafPoint
(
)
;
}
int32_t
lineStart
=
continuation
-
>
GetContentOffset
(
)
;
lineStart
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
acc
lineStart
)
)
;
return
TextLeafPoint
(
acc
lineStart
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindLineStartSameRemoteAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
RemoteAccessible
*
acc
=
mAcc
-
>
AsRemote
(
)
;
MOZ_ASSERT
(
acc
)
;
auto
lines
=
acc
-
>
GetCachedTextLines
(
)
;
if
(
!
lines
)
{
return
TextLeafPoint
(
)
;
}
size_t
index
;
if
(
BinarySearch
(
*
lines
0
lines
-
>
Length
(
)
mOffset
&
index
)
)
{
if
(
aIncludeOrigin
)
{
return
*
this
;
}
if
(
aDirection
=
=
eDirNext
)
{
+
+
index
;
}
}
MOZ_ASSERT
(
index
<
=
lines
-
>
Length
(
)
)
;
if
(
(
aDirection
=
=
eDirNext
&
&
index
=
=
lines
-
>
Length
(
)
)
|
|
index
=
=
0
)
{
return
TextLeafPoint
(
)
;
}
if
(
aDirection
=
=
eDirPrevious
)
{
-
-
index
;
}
return
TextLeafPoint
(
mAcc
lines
-
>
ElementAt
(
index
)
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindLineStartSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
if
(
mAcc
-
>
IsLocal
(
)
)
{
return
aDirection
=
=
eDirNext
?
FindNextLineStartSameLocalAcc
(
aIncludeOrigin
)
:
FindPrevLineStartSameLocalAcc
(
aIncludeOrigin
)
;
}
return
FindLineStartSameRemoteAcc
(
aDirection
aIncludeOrigin
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindPrevWordStartSameAcc
(
bool
aIncludeOrigin
)
const
{
if
(
mOffset
=
=
0
&
&
!
aIncludeOrigin
)
{
return
TextLeafPoint
(
)
;
}
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
)
;
intl
:
:
WordBreaker
*
breaker
=
nsContentUtils
:
:
WordBreaker
(
)
;
TextLeafPoint
lineStart
=
*
this
;
for
(
;
lineStart
.
mOffset
>
=
0
&
&
text
.
CharAt
(
lineStart
.
mOffset
)
=
=
'
\
n
'
;
-
-
lineStart
.
mOffset
)
{
}
if
(
lineStart
.
mOffset
<
0
)
{
lineStart
=
TextLeafPoint
(
)
;
}
else
{
lineStart
=
lineStart
.
FindLineStartSameAcc
(
eDirPrevious
aIncludeOrigin
)
;
}
intl
:
:
WordRange
word
;
if
(
mOffset
=
=
0
)
{
word
.
mBegin
=
0
;
}
else
if
(
mOffset
=
=
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
)
{
word
=
breaker
-
>
FindWord
(
text
.
get
(
)
text
.
Length
(
)
mOffset
-
1
)
;
}
else
{
word
=
breaker
-
>
FindWord
(
text
.
get
(
)
text
.
Length
(
)
mOffset
)
;
}
for
(
;
;
word
=
breaker
-
>
FindWord
(
text
.
get
(
)
text
.
Length
(
)
word
.
mBegin
-
1
)
)
{
if
(
!
aIncludeOrigin
&
&
static_cast
<
int32_t
>
(
word
.
mBegin
)
=
=
mOffset
)
{
MOZ_ASSERT
(
word
.
mBegin
!
=
0
)
;
continue
;
}
if
(
lineStart
&
&
static_cast
<
int32_t
>
(
word
.
mBegin
)
<
lineStart
.
mOffset
)
{
return
lineStart
;
}
if
(
IsAcceptableWordStart
(
breaker
mAcc
text
static_cast
<
int32_t
>
(
word
.
mBegin
)
)
)
{
break
;
}
if
(
word
.
mBegin
=
=
0
)
{
if
(
lineStart
)
{
return
lineStart
;
}
return
TextLeafPoint
(
)
;
}
}
return
TextLeafPoint
(
mAcc
static_cast
<
int32_t
>
(
word
.
mBegin
)
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindNextWordStartSameAcc
(
bool
aIncludeOrigin
)
const
{
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
)
;
int32_t
wordStart
=
mOffset
;
intl
:
:
WordBreaker
*
breaker
=
nsContentUtils
:
:
WordBreaker
(
)
;
if
(
aIncludeOrigin
)
{
if
(
wordStart
=
=
0
)
{
if
(
IsAcceptableWordStart
(
breaker
mAcc
text
0
)
)
{
return
*
this
;
}
}
else
{
-
-
wordStart
;
}
}
TextLeafPoint
lineStart
=
FindLineStartSameAcc
(
eDirNext
aIncludeOrigin
)
;
if
(
lineStart
)
{
for
(
;
lineStart
.
mOffset
<
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
&
&
text
.
CharAt
(
lineStart
.
mOffset
)
=
=
'
\
n
'
;
+
+
lineStart
.
mOffset
)
{
}
if
(
lineStart
.
mOffset
=
=
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
)
{
lineStart
=
TextLeafPoint
(
)
;
}
}
for
(
;
;
)
{
wordStart
=
breaker
-
>
Next
(
text
.
get
(
)
text
.
Length
(
)
wordStart
)
;
if
(
wordStart
=
=
NS_WORDBREAKER_NEED_MORE_TEXT
|
|
wordStart
=
=
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
)
{
if
(
lineStart
)
{
return
lineStart
;
}
return
TextLeafPoint
(
)
;
}
if
(
lineStart
&
&
wordStart
>
lineStart
.
mOffset
)
{
return
lineStart
;
}
if
(
IsAcceptableWordStart
(
breaker
mAcc
text
wordStart
)
)
{
break
;
}
}
return
TextLeafPoint
(
mAcc
wordStart
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindBoundary
(
AccessibleTextBoundary
aBoundaryType
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_LINE_START
&
&
aIncludeOrigin
&
&
aDirection
=
=
eDirPrevious
&
&
IsEmptyLastLine
(
)
)
{
return
*
this
;
}
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
&
&
aIncludeOrigin
)
{
return
*
this
;
}
TextLeafPoint
searchFrom
=
*
this
;
bool
includeOrigin
=
aIncludeOrigin
;
for
(
;
;
)
{
TextLeafPoint
boundary
;
switch
(
aBoundaryType
)
{
case
nsIAccessibleText
:
:
BOUNDARY_CHAR
:
if
(
aDirection
=
=
eDirPrevious
&
&
searchFrom
.
mOffset
>
0
)
{
boundary
.
mAcc
=
searchFrom
.
mAcc
;
boundary
.
mOffset
=
searchFrom
.
mOffset
-
1
;
}
else
if
(
aDirection
=
=
eDirNext
)
{
if
(
includeOrigin
)
{
boundary
=
searchFrom
;
}
else
if
(
searchFrom
.
mOffset
<
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
searchFrom
.
mAcc
)
)
)
{
boundary
.
mAcc
=
searchFrom
.
mAcc
;
boundary
.
mOffset
=
searchFrom
.
mOffset
+
1
;
}
}
break
;
case
nsIAccessibleText
:
:
BOUNDARY_WORD_START
:
if
(
aDirection
=
=
eDirPrevious
)
{
boundary
=
searchFrom
.
FindPrevWordStartSameAcc
(
includeOrigin
)
;
}
else
{
boundary
=
searchFrom
.
FindNextWordStartSameAcc
(
includeOrigin
)
;
}
break
;
case
nsIAccessibleText
:
:
BOUNDARY_LINE_START
:
boundary
=
searchFrom
.
FindLineStartSameAcc
(
aDirection
includeOrigin
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
)
;
break
;
}
if
(
boundary
)
{
return
boundary
;
}
Accessible
*
acc
=
aDirection
=
=
eDirPrevious
?
PrevLeaf
(
searchFrom
.
mAcc
)
:
NextLeaf
(
searchFrom
.
mAcc
)
;
if
(
!
acc
)
{
return
TextLeafPoint
(
searchFrom
.
mAcc
aDirection
=
=
eDirPrevious
?
0
:
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
searchFrom
.
mAcc
)
)
)
;
}
searchFrom
.
mAcc
=
acc
;
searchFrom
.
mOffset
=
aDirection
=
=
eDirPrevious
?
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
acc
)
)
:
0
;
includeOrigin
=
true
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
TextLeafPoint
(
)
;
}
}
