#
include
"
TextLeafRange
.
h
"
#
include
"
HyperTextAccessible
-
inl
.
h
"
#
include
"
mozilla
/
a11y
/
Accessible
.
h
"
#
include
"
mozilla
/
a11y
/
CacheConstants
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessibleParent
.
h
"
#
include
"
mozilla
/
a11y
/
LocalAccessible
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
dom
/
AbstractRange
.
h
"
#
include
"
mozilla
/
dom
/
CharacterData
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
intl
/
Segmenter
.
h
"
#
include
"
mozilla
/
intl
/
WordBreaker
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsIAccessiblePivot
.
h
"
#
include
"
nsILineIterator
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
Pivot
.
h
"
#
include
"
TextAttrs
.
h
"
#
include
"
TextRange
.
h
"
using
mozilla
:
:
intl
:
:
WordBreaker
;
using
FindWordOptions
=
mozilla
:
:
intl
:
:
WordBreaker
:
:
FindWordOptions
;
namespace
mozilla
:
:
a11y
{
static
int32_t
RenderedToContentOffset
(
LocalAccessible
*
aAcc
uint32_t
aRenderedOffset
)
{
nsTextFrame
*
frame
=
do_QueryFrame
(
aAcc
-
>
GetFrame
(
)
)
;
if
(
!
frame
)
{
MOZ_ASSERT
(
!
aAcc
-
>
HasOwnContent
(
)
|
|
aAcc
-
>
IsHTMLBr
(
)
"
No
text
frame
because
this
is
a
XUL
label
[
value
]
text
leaf
or
"
"
a
BR
element
.
"
)
;
return
static_cast
<
int32_t
>
(
aRenderedOffset
)
;
}
if
(
frame
-
>
StyleText
(
)
-
>
WhiteSpaceIsSignificant
(
)
&
&
frame
-
>
StyleText
(
)
-
>
NewlineIsSignificant
(
frame
)
)
{
return
static_cast
<
int32_t
>
(
aRenderedOffset
)
;
}
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
aRenderedOffset
aRenderedOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInRenderedText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
return
text
.
mOffsetWithinNodeText
;
}
static
uint32_t
ContentToRenderedOffset
(
LocalAccessible
*
aAcc
int32_t
aContentOffset
)
{
nsTextFrame
*
frame
=
do_QueryFrame
(
aAcc
-
>
GetFrame
(
)
)
;
if
(
!
frame
)
{
MOZ_ASSERT
(
!
aAcc
-
>
HasOwnContent
(
)
"
No
text
frame
because
this
is
a
XUL
label
[
value
]
text
leaf
.
"
)
;
return
aContentOffset
;
}
if
(
frame
-
>
StyleText
(
)
-
>
WhiteSpaceIsSignificant
(
)
&
&
frame
-
>
StyleText
(
)
-
>
NewlineIsSignificant
(
frame
)
)
{
return
aContentOffset
;
}
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
aContentOffset
aContentOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInContentText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
return
text
.
mOffsetWithinNodeRenderedText
;
}
class
LeafRule
:
public
PivotRule
{
public
:
explicit
LeafRule
(
bool
aIgnoreListItemMarker
)
:
mIgnoreListItemMarker
(
aIgnoreListItemMarker
)
{
}
virtual
uint16_t
Match
(
Accessible
*
aAcc
)
override
{
if
(
aAcc
-
>
IsOuterDoc
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
|
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
mIgnoreListItemMarker
&
&
aAcc
-
>
Role
(
)
=
=
roles
:
:
LISTITEM_MARKER
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
}
if
(
!
aAcc
-
>
HasChildren
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
}
private
:
bool
mIgnoreListItemMarker
;
}
;
static
HyperTextAccessible
*
HyperTextFor
(
LocalAccessible
*
aAcc
)
{
for
(
LocalAccessible
*
acc
=
aAcc
;
acc
;
acc
=
acc
-
>
LocalParent
(
)
)
{
if
(
HyperTextAccessible
*
ht
=
acc
-
>
AsHyperText
(
)
)
{
return
ht
;
}
}
return
nullptr
;
}
static
Accessible
*
NextLeaf
(
Accessible
*
aOrigin
bool
aIsEditable
=
false
bool
aIgnoreListItemMarker
=
false
)
{
MOZ_ASSERT
(
aOrigin
)
;
Accessible
*
doc
=
nsAccUtils
:
:
DocumentFor
(
aOrigin
)
;
Pivot
pivot
(
doc
)
;
auto
rule
=
LeafRule
(
aIgnoreListItemMarker
)
;
Accessible
*
leaf
=
pivot
.
Next
(
aOrigin
rule
)
;
if
(
aIsEditable
&
&
leaf
)
{
return
leaf
-
>
Parent
(
)
&
&
(
leaf
-
>
Parent
(
)
-
>
State
(
)
&
states
:
:
EDITABLE
)
?
leaf
:
nullptr
;
}
return
leaf
;
}
static
Accessible
*
PrevLeaf
(
Accessible
*
aOrigin
bool
aIsEditable
=
false
bool
aIgnoreListItemMarker
=
false
)
{
MOZ_ASSERT
(
aOrigin
)
;
Accessible
*
doc
=
nsAccUtils
:
:
DocumentFor
(
aOrigin
)
;
Pivot
pivot
(
doc
)
;
auto
rule
=
LeafRule
(
aIgnoreListItemMarker
)
;
Accessible
*
leaf
=
pivot
.
Prev
(
aOrigin
rule
)
;
if
(
aIsEditable
&
&
leaf
)
{
return
leaf
-
>
Parent
(
)
&
&
(
leaf
-
>
Parent
(
)
-
>
State
(
)
&
states
:
:
EDITABLE
)
?
leaf
:
nullptr
;
}
return
leaf
;
}
static
nsIFrame
*
GetFrameInBlock
(
const
LocalAccessible
*
aAcc
)
{
dom
:
:
HTMLInputElement
*
input
=
dom
:
:
HTMLInputElement
:
:
FromNodeOrNull
(
aAcc
-
>
GetContent
(
)
)
;
if
(
!
input
)
{
if
(
LocalAccessible
*
parent
=
aAcc
-
>
LocalParent
(
)
)
{
input
=
dom
:
:
HTMLInputElement
:
:
FromNodeOrNull
(
parent
-
>
GetContent
(
)
)
;
}
}
if
(
input
)
{
return
input
-
>
GetPrimaryFrame
(
)
;
}
return
aAcc
-
>
GetFrame
(
)
;
}
static
bool
AreFramesOnDifferentLines
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
)
{
MOZ_ASSERT
(
aFrame1
&
&
aFrame2
)
;
if
(
aFrame1
=
=
aFrame2
)
{
return
false
;
}
auto
[
block1
lineFrame1
]
=
aFrame1
-
>
GetContainingBlockForLine
(
false
)
;
if
(
!
block1
)
{
return
true
;
}
auto
[
block2
lineFrame2
]
=
aFrame2
-
>
GetContainingBlockForLine
(
false
)
;
if
(
lineFrame1
=
=
lineFrame2
)
{
return
false
;
}
if
(
block1
!
=
block2
)
{
return
true
;
}
if
(
nsBlockFrame
*
block
=
do_QueryFrame
(
block1
)
)
{
bool
found
=
false
;
block
-
>
SetupLineCursorForQuery
(
)
;
nsBlockInFlowLineIterator
it1
(
block
lineFrame1
&
found
)
;
if
(
!
found
)
{
return
true
;
}
found
=
false
;
nsBlockInFlowLineIterator
it2
(
block
lineFrame2
&
found
)
;
return
!
found
|
|
it1
.
GetLineList
(
)
!
=
it2
.
GetLineList
(
)
|
|
it1
.
GetLine
(
)
!
=
it2
.
GetLine
(
)
;
}
AutoAssertNoDomMutations
guard
;
nsILineIterator
*
it
=
block1
-
>
GetLineIterator
(
)
;
MOZ_ASSERT
(
it
"
GetLineIterator
impl
in
line
-
container
blocks
is
infallible
"
)
;
int32_t
line1
=
it
-
>
FindLineContaining
(
lineFrame1
)
;
if
(
line1
<
0
)
{
return
true
;
}
int32_t
line2
=
it
-
>
FindLineContaining
(
lineFrame2
line1
)
;
return
line1
!
=
line2
;
}
static
bool
IsLocalAccAtLineStart
(
LocalAccessible
*
aAcc
)
{
if
(
aAcc
-
>
NativeRole
(
)
=
=
roles
:
:
LISTITEM_MARKER
)
{
return
true
;
}
Accessible
*
prev
=
PrevLeaf
(
aAcc
)
;
LocalAccessible
*
prevLocal
=
prev
?
prev
-
>
AsLocal
(
)
:
nullptr
;
if
(
!
prevLocal
)
{
return
true
;
}
if
(
prevLocal
-
>
NativeRole
(
)
=
=
roles
:
:
LISTITEM_MARKER
)
{
LocalAccessible
*
listItem
=
prevLocal
-
>
LocalParent
(
)
;
MOZ_ASSERT
(
listItem
)
;
LocalAccessible
*
doc
=
listItem
-
>
Document
(
)
;
MOZ_ASSERT
(
doc
)
;
for
(
LocalAccessible
*
parent
=
aAcc
-
>
LocalParent
(
)
;
parent
&
&
parent
!
=
doc
;
parent
=
parent
-
>
LocalParent
(
)
)
{
if
(
parent
=
=
listItem
)
{
return
false
;
}
}
}
nsIFrame
*
thisFrame
=
GetFrameInBlock
(
aAcc
)
;
if
(
!
thisFrame
)
{
return
false
;
}
nsIFrame
*
prevFrame
=
GetFrameInBlock
(
prevLocal
)
;
if
(
!
prevFrame
)
{
return
false
;
}
prevFrame
=
prevFrame
-
>
LastContinuation
(
)
;
return
AreFramesOnDifferentLines
(
thisFrame
prevFrame
)
;
}
enum
WordBreakClass
{
eWbcSpace
=
0
eWbcPunct
eWbcOther
}
;
static
WordBreakClass
GetWordBreakClass
(
char16_t
aChar
)
{
const
char16_t
kCharNbsp
=
0xA0
;
switch
(
aChar
)
{
case
'
'
:
case
kCharNbsp
:
case
'
\
t
'
:
case
'
\
f
'
:
case
'
\
n
'
:
case
'
\
r
'
:
return
eWbcSpace
;
default
:
break
;
}
return
mozilla
:
:
IsPunctuationForWordSelect
(
aChar
)
?
eWbcPunct
:
eWbcOther
;
}
class
PrevWordBreakClassWalker
{
public
:
PrevWordBreakClassWalker
(
Accessible
*
aAcc
const
nsAString
&
aText
int32_t
aOffset
)
:
mAcc
(
aAcc
)
mText
(
aText
)
mOffset
(
aOffset
)
{
mClass
=
GetWordBreakClass
(
mText
.
CharAt
(
mOffset
)
)
;
}
WordBreakClass
CurClass
(
)
{
return
mClass
;
}
Maybe
<
WordBreakClass
>
PrevClass
(
)
{
for
(
;
;
)
{
if
(
!
PrevChar
(
)
)
{
return
Nothing
(
)
;
}
WordBreakClass
curClass
=
GetWordBreakClass
(
mText
.
CharAt
(
mOffset
)
)
;
if
(
curClass
!
=
mClass
)
{
mClass
=
curClass
;
return
Some
(
curClass
)
;
}
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
Nothing
(
)
;
}
bool
IsStartOfGroup
(
)
{
if
(
!
PrevChar
(
)
)
{
return
true
;
}
WordBreakClass
curClass
=
GetWordBreakClass
(
mText
.
CharAt
(
mOffset
)
)
;
+
+
mOffset
;
return
curClass
!
=
mClass
;
}
private
:
bool
PrevChar
(
)
{
if
(
mOffset
>
0
)
{
-
-
mOffset
;
return
true
;
}
if
(
!
mAcc
)
{
return
false
;
}
mAcc
=
PrevLeaf
(
mAcc
)
;
if
(
!
mAcc
)
{
return
false
;
}
mText
.
Truncate
(
)
;
mAcc
-
>
AppendTextTo
(
mText
)
;
mOffset
=
static_cast
<
int32_t
>
(
mText
.
Length
(
)
)
-
1
;
return
true
;
}
Accessible
*
mAcc
;
nsAutoString
mText
;
int32_t
mOffset
;
WordBreakClass
mClass
;
}
;
static
bool
IsAcceptableWordStart
(
Accessible
*
aAcc
const
nsAutoString
&
aText
int32_t
aOffset
)
{
PrevWordBreakClassWalker
walker
(
aAcc
aText
aOffset
)
;
if
(
!
walker
.
IsStartOfGroup
(
)
)
{
return
false
;
}
WordBreakClass
curClass
=
walker
.
CurClass
(
)
;
if
(
curClass
=
=
eWbcSpace
)
{
return
false
;
}
Maybe
<
WordBreakClass
>
prevClass
=
walker
.
PrevClass
(
)
;
if
(
curClass
=
=
eWbcPunct
&
&
(
!
prevClass
|
|
prevClass
.
value
(
)
!
=
eWbcSpace
)
)
{
return
false
;
}
if
(
!
prevClass
|
|
prevClass
.
value
(
)
!
=
eWbcPunct
)
{
return
true
;
}
if
(
!
StaticPrefs
:
:
layout_word_select_stop_at_punctuation
(
)
)
{
return
false
;
}
Maybe
<
WordBreakClass
>
prevPrevClass
=
walker
.
PrevClass
(
)
;
if
(
!
prevPrevClass
|
|
prevPrevClass
.
value
(
)
=
=
eWbcSpace
)
{
return
false
;
}
return
true
;
}
class
BlockRule
:
public
PivotRule
{
public
:
virtual
uint16_t
Match
(
Accessible
*
aAcc
)
override
{
if
(
RefPtr
<
nsAtom
>
(
aAcc
-
>
DisplayStyle
(
)
)
=
=
nsGkAtoms
:
:
block
|
|
aAcc
-
>
IsHTMLListItem
(
)
|
|
aAcc
-
>
IsTableRow
(
)
|
|
aAcc
-
>
IsTableCell
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
}
}
;
static
nsTArray
<
std
:
:
pair
<
nsTArray
<
dom
:
:
AbstractRange
*
>
nsStaticAtom
*
>
>
FindDOMTextOffsetAttributes
(
LocalAccessible
*
aAcc
int32_t
aRenderedStart
int32_t
aRenderedEnd
bool
aAllowAdjacent
=
false
)
{
nsTArray
<
std
:
:
pair
<
nsTArray
<
dom
:
:
AbstractRange
*
>
nsStaticAtom
*
>
>
result
;
if
(
!
aAcc
-
>
IsTextLeaf
(
)
|
|
!
aAcc
-
>
HasOwnContent
(
)
)
{
return
result
;
}
nsIFrame
*
frame
=
aAcc
-
>
GetFrame
(
)
;
RefPtr
<
nsFrameSelection
>
frameSel
=
frame
?
frame
-
>
GetFrameSelection
(
)
:
nullptr
;
if
(
!
frameSel
)
{
return
result
;
}
nsINode
*
node
=
aAcc
-
>
GetNode
(
)
;
uint32_t
contentStart
=
RenderedToContentOffset
(
aAcc
aRenderedStart
)
;
uint32_t
contentEnd
=
aRenderedEnd
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
?
dom
:
:
CharacterData
:
:
FromNode
(
node
)
-
>
TextLength
(
)
:
RenderedToContentOffset
(
aAcc
aRenderedEnd
)
;
const
std
:
:
pair
<
mozilla
:
:
SelectionType
nsStaticAtom
*
>
kSelectionTypesToAttributes
[
]
=
{
{
SelectionType
:
:
eSpellCheck
nsGkAtoms
:
:
spelling
}
{
SelectionType
:
:
eTargetText
nsGkAtoms
:
:
mark
}
}
;
result
.
SetCapacity
(
ArrayLength
(
kSelectionTypesToAttributes
)
)
;
for
(
auto
[
selType
attr
]
:
kSelectionTypesToAttributes
)
{
dom
:
:
Selection
*
domSel
=
frameSel
-
>
GetSelection
(
selType
)
;
if
(
!
domSel
)
{
continue
;
}
nsTArray
<
dom
:
:
AbstractRange
*
>
domRanges
;
domSel
-
>
GetAbstractRangesForIntervalArray
(
node
contentStart
node
contentEnd
aAllowAdjacent
&
domRanges
)
;
if
(
!
domRanges
.
IsEmpty
(
)
)
{
result
.
AppendElement
(
std
:
:
make_pair
(
std
:
:
move
(
domRanges
)
attr
)
)
;
}
}
return
result
;
}
static
dom
:
:
Selection
*
GetDOMSelection
(
const
nsIContent
*
aStartContent
const
nsIContent
*
aEndContent
)
{
nsIFrame
*
startFrame
=
aStartContent
-
>
GetPrimaryFrame
(
)
;
const
nsFrameSelection
*
startFrameSel
=
startFrame
?
startFrame
-
>
GetConstFrameSelection
(
)
:
nullptr
;
nsIFrame
*
endFrame
=
aEndContent
-
>
GetPrimaryFrame
(
)
;
const
nsFrameSelection
*
endFrameSel
=
endFrame
?
endFrame
-
>
GetConstFrameSelection
(
)
:
nullptr
;
if
(
startFrameSel
!
=
endFrameSel
)
{
return
nullptr
;
}
return
startFrameSel
?
startFrameSel
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
:
nullptr
;
}
std
:
:
pair
<
nsIContent
*
int32_t
>
TextLeafPoint
:
:
ToDOMPoint
(
bool
aIncludeGenerated
)
const
{
if
(
!
(
*
this
)
|
|
!
mAcc
-
>
IsLocal
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
point
"
)
;
return
{
nullptr
0
}
;
}
nsIContent
*
content
=
mAcc
-
>
AsLocal
(
)
-
>
GetContent
(
)
;
nsIFrame
*
frame
=
content
?
content
-
>
GetPrimaryFrame
(
)
:
nullptr
;
MOZ_ASSERT
(
frame
)
;
if
(
!
aIncludeGenerated
&
&
frame
&
&
frame
-
>
IsGeneratedContentFrame
(
)
)
{
auto
generatedElement
=
content
-
>
IsGeneratedContentContainerForMarker
(
)
?
content
:
content
-
>
GetParentElement
(
)
;
auto
parent
=
generatedElement
?
generatedElement
-
>
GetParent
(
)
:
nullptr
;
MOZ_ASSERT
(
parent
)
;
if
(
parent
)
{
if
(
generatedElement
-
>
IsGeneratedContentContainerForAfter
(
)
)
{
return
{
parent
parent
-
>
GetChildCount
(
)
}
;
}
if
(
generatedElement
-
>
IsGeneratedContentContainerForBefore
(
)
|
|
generatedElement
-
>
IsGeneratedContentContainerForMarker
(
)
)
{
return
{
parent
0
}
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
generated
content
type
!
"
)
;
}
}
if
(
!
mAcc
-
>
IsTextLeaf
(
)
&
&
!
mAcc
-
>
IsHTMLBr
(
)
&
&
!
mAcc
-
>
HasChildren
(
)
)
{
MOZ_ASSERT
(
mOffset
=
=
0
)
;
if
(
RefPtr
<
TextControlElement
>
textControlElement
=
TextControlElement
:
:
FromNodeOrNull
(
content
)
)
{
if
(
RefPtr
<
TextEditor
>
textEditor
=
textControlElement
-
>
GetTextEditor
(
)
)
{
if
(
textEditor
-
>
IsEmpty
(
)
)
{
MOZ_ASSERT
(
mOffset
=
=
0
)
;
return
{
textEditor
-
>
GetRoot
(
)
0
}
;
}
}
}
return
{
content
0
}
;
}
return
{
content
RenderedToContentOffset
(
mAcc
-
>
AsLocal
(
)
mOffset
)
}
;
}
static
bool
IsLineBreakContinuation
(
nsTextFrame
*
aContinuation
)
{
if
(
aContinuation
-
>
HasAnyStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
)
{
return
true
;
}
if
(
!
aContinuation
-
>
HasAnyStateBits
(
NS_FRAME_IS_BIDI
)
)
{
return
true
;
}
nsTextFrame
*
prev
=
aContinuation
-
>
GetPrevContinuation
(
)
;
if
(
!
prev
)
{
return
false
;
}
if
(
!
prev
-
>
HasAnyStateBits
(
NS_FRAME_IS_BIDI
)
)
{
return
true
;
}
return
AreFramesOnDifferentLines
(
aContinuation
prev
)
;
}
TextLeafPoint
:
:
TextLeafPoint
(
Accessible
*
aAcc
int32_t
aOffset
)
{
if
(
!
aAcc
)
{
mAcc
=
nullptr
;
mOffset
=
0
;
return
;
}
if
(
aOffset
!
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
&
&
!
aAcc
-
>
IsOuterDoc
(
)
&
&
aAcc
-
>
HasChildren
(
)
)
{
auto
GetChild
=
[
&
aOffset
]
(
Accessible
*
acc
)
-
>
Accessible
*
{
if
(
acc
-
>
IsOuterDoc
(
)
)
{
return
nullptr
;
}
return
aOffset
!
=
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
?
acc
-
>
FirstChild
(
)
:
acc
-
>
LastChild
(
)
;
}
;
for
(
Accessible
*
acc
=
GetChild
(
aAcc
)
;
acc
;
acc
=
GetChild
(
acc
)
)
{
mAcc
=
acc
;
}
mOffset
=
aOffset
!
=
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
?
0
:
nsAccUtils
:
:
TextLength
(
mAcc
)
;
return
;
}
mAcc
=
aAcc
;
mOffset
=
aOffset
!
=
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
?
aOffset
:
nsAccUtils
:
:
TextLength
(
mAcc
)
;
}
bool
TextLeafPoint
:
:
operator
<
(
const
TextLeafPoint
&
aPoint
)
const
{
if
(
mAcc
=
=
aPoint
.
mAcc
)
{
return
mOffset
<
aPoint
.
mOffset
;
}
return
mAcc
-
>
IsBefore
(
aPoint
.
mAcc
)
;
}
bool
TextLeafPoint
:
:
operator
<
=
(
const
TextLeafPoint
&
aPoint
)
const
{
return
*
this
=
=
aPoint
|
|
*
this
<
aPoint
;
}
bool
TextLeafPoint
:
:
IsDocEdge
(
nsDirection
aDirection
)
const
{
if
(
aDirection
=
=
eDirPrevious
)
{
return
mOffset
=
=
0
&
&
!
PrevLeaf
(
mAcc
)
;
}
return
mOffset
=
=
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
mAcc
)
)
&
&
!
NextLeaf
(
mAcc
)
;
}
bool
TextLeafPoint
:
:
IsLeafAfterListItemMarker
(
)
const
{
Accessible
*
prev
=
PrevLeaf
(
mAcc
)
;
return
prev
&
&
prev
-
>
Role
(
)
=
=
roles
:
:
LISTITEM_MARKER
&
&
prev
-
>
Parent
(
)
-
>
IsAncestorOf
(
mAcc
)
;
}
bool
TextLeafPoint
:
:
IsEmptyLastLine
(
)
const
{
if
(
mAcc
-
>
IsHTMLBr
(
)
&
&
mOffset
=
=
1
)
{
return
true
;
}
if
(
!
mAcc
-
>
IsTextLeaf
(
)
)
{
return
false
;
}
if
(
mOffset
<
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
mAcc
)
)
)
{
return
false
;
}
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
mOffset
-
1
1
)
;
return
text
.
CharAt
(
0
)
=
=
'
\
n
'
;
}
char16_t
TextLeafPoint
:
:
GetChar
(
)
const
{
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
mOffset
1
)
;
return
text
.
CharAt
(
0
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindPrevLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
{
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
;
MOZ_ASSERT
(
acc
)
;
if
(
mOffset
=
=
0
)
{
if
(
aIncludeOrigin
&
&
IsLocalAccAtLineStart
(
acc
)
)
{
return
*
this
;
}
return
TextLeafPoint
(
)
;
}
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
!
frame
)
{
return
TextLeafPoint
(
)
;
}
if
(
!
frame
-
>
IsTextFrame
(
)
)
{
if
(
IsLocalAccAtLineStart
(
acc
)
)
{
return
TextLeafPoint
(
acc
0
)
;
}
return
TextLeafPoint
(
)
;
}
int32_t
origOffset
=
mOffset
;
origOffset
=
RenderedToContentOffset
(
acc
origOffset
)
;
nsTextFrame
*
continuation
=
nullptr
;
int32_t
unusedOffsetInContinuation
=
0
;
frame
-
>
GetChildFrameContainingOffset
(
origOffset
true
&
unusedOffsetInContinuation
(
nsIFrame
*
*
)
&
continuation
)
;
MOZ_ASSERT
(
continuation
)
;
int32_t
lineStart
=
continuation
-
>
GetContentOffset
(
)
;
if
(
lineStart
>
0
&
&
(
(
!
aIncludeOrigin
&
&
lineStart
=
=
origOffset
)
|
|
!
IsLineBreakContinuation
(
continuation
)
)
)
{
for
(
nsTextFrame
*
prev
=
continuation
-
>
GetPrevContinuation
(
)
;
prev
;
prev
=
prev
-
>
GetPrevContinuation
(
)
)
{
continuation
=
prev
;
if
(
IsLineBreakContinuation
(
continuation
)
)
{
break
;
}
}
MOZ_ASSERT
(
continuation
)
;
lineStart
=
continuation
-
>
GetContentOffset
(
)
;
}
MOZ_ASSERT
(
lineStart
>
=
0
)
;
MOZ_ASSERT
(
lineStart
=
=
0
|
|
IsLineBreakContinuation
(
continuation
)
)
;
if
(
lineStart
=
=
0
&
&
!
IsLocalAccAtLineStart
(
acc
)
)
{
return
TextLeafPoint
(
)
;
}
lineStart
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
acc
lineStart
)
)
;
return
TextLeafPoint
(
acc
lineStart
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindNextLineStartSameLocalAcc
(
bool
aIncludeOrigin
)
const
{
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
;
MOZ_ASSERT
(
acc
)
;
if
(
aIncludeOrigin
&
&
mOffset
=
=
0
&
&
IsLocalAccAtLineStart
(
acc
)
)
{
return
*
this
;
}
nsIFrame
*
frame
=
acc
-
>
GetFrame
(
)
;
if
(
!
frame
)
{
return
TextLeafPoint
(
)
;
}
if
(
!
frame
-
>
IsTextFrame
(
)
)
{
return
TextLeafPoint
(
)
;
}
int32_t
origOffset
=
mOffset
;
origOffset
=
RenderedToContentOffset
(
acc
origOffset
)
;
nsTextFrame
*
continuation
=
nullptr
;
int32_t
unusedOffsetInContinuation
=
0
;
frame
-
>
GetChildFrameContainingOffset
(
origOffset
true
&
unusedOffsetInContinuation
(
nsIFrame
*
*
)
&
continuation
)
;
MOZ_ASSERT
(
continuation
)
;
if
(
aIncludeOrigin
&
&
continuation
-
>
GetContentOffset
(
)
=
=
origOffset
&
&
IsLineBreakContinuation
(
continuation
)
&
&
!
(
origOffset
=
=
0
&
&
!
IsLocalAccAtLineStart
(
acc
)
)
)
{
return
*
this
;
}
while
(
(
continuation
=
continuation
-
>
GetNextContinuation
(
)
)
)
{
if
(
IsLineBreakContinuation
(
continuation
)
)
{
break
;
}
}
if
(
!
continuation
)
{
return
TextLeafPoint
(
)
;
}
int32_t
lineStart
=
continuation
-
>
GetContentOffset
(
)
;
lineStart
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
acc
lineStart
)
)
;
return
TextLeafPoint
(
acc
lineStart
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindLineStartSameRemoteAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
RemoteAccessible
*
acc
=
mAcc
-
>
AsRemote
(
)
;
MOZ_ASSERT
(
acc
)
;
auto
lines
=
acc
-
>
GetCachedTextLines
(
)
;
if
(
!
lines
)
{
return
TextLeafPoint
(
)
;
}
size_t
index
;
if
(
BinarySearch
(
*
lines
0
lines
-
>
Length
(
)
mOffset
&
index
)
)
{
if
(
aIncludeOrigin
)
{
return
*
this
;
}
if
(
aDirection
=
=
eDirNext
)
{
+
+
index
;
}
}
MOZ_ASSERT
(
index
<
=
lines
-
>
Length
(
)
)
;
if
(
(
aDirection
=
=
eDirNext
&
&
index
=
=
lines
-
>
Length
(
)
)
|
|
(
aDirection
=
=
eDirPrevious
&
&
index
=
=
0
)
)
{
return
TextLeafPoint
(
)
;
}
if
(
aDirection
=
=
eDirPrevious
)
{
-
-
index
;
}
return
TextLeafPoint
(
mAcc
lines
-
>
ElementAt
(
index
)
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindLineStartSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
bool
aIgnoreListItemMarker
)
const
{
TextLeafPoint
boundary
;
if
(
aIgnoreListItemMarker
&
&
aIncludeOrigin
&
&
mOffset
=
=
0
&
&
IsLeafAfterListItemMarker
(
)
)
{
return
*
this
;
}
if
(
mAcc
-
>
IsLocal
(
)
)
{
boundary
=
aDirection
=
=
eDirNext
?
FindNextLineStartSameLocalAcc
(
aIncludeOrigin
)
:
FindPrevLineStartSameLocalAcc
(
aIncludeOrigin
)
;
}
else
{
boundary
=
FindLineStartSameRemoteAcc
(
aDirection
aIncludeOrigin
)
;
}
if
(
aIgnoreListItemMarker
&
&
aDirection
=
=
eDirPrevious
&
&
!
boundary
&
&
mOffset
!
=
0
&
&
IsLeafAfterListItemMarker
(
)
)
{
boundary
=
TextLeafPoint
(
mAcc
0
)
;
}
return
boundary
;
}
TextLeafPoint
TextLeafPoint
:
:
FindPrevWordStartSameAcc
(
bool
aIncludeOrigin
)
const
{
if
(
mOffset
=
=
0
&
&
!
aIncludeOrigin
)
{
return
TextLeafPoint
(
)
;
}
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
)
;
TextLeafPoint
lineStart
=
*
this
;
if
(
!
aIncludeOrigin
|
|
(
lineStart
.
mOffset
=
=
1
&
&
text
.
Length
(
)
=
=
1
&
&
text
.
CharAt
(
0
)
=
=
'
\
n
'
)
)
{
-
-
lineStart
.
mOffset
;
}
for
(
;
lineStart
.
mOffset
>
=
0
&
&
text
.
CharAt
(
lineStart
.
mOffset
)
=
=
'
\
n
'
;
-
-
lineStart
.
mOffset
)
{
}
if
(
lineStart
.
mOffset
<
0
)
{
lineStart
=
TextLeafPoint
(
)
;
}
else
{
lineStart
=
lineStart
.
FindLineStartSameAcc
(
eDirPrevious
true
)
;
}
intl
:
:
WordRange
word
;
if
(
mOffset
=
=
0
)
{
word
.
mBegin
=
0
;
}
else
if
(
mOffset
=
=
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
)
{
word
=
WordBreaker
:
:
FindWord
(
text
mOffset
-
1
StaticPrefs
:
:
layout_word_select_stop_at_punctuation
(
)
?
FindWordOptions
:
:
StopAtPunctuation
:
FindWordOptions
:
:
None
)
;
}
else
{
word
=
WordBreaker
:
:
FindWord
(
text
mOffset
StaticPrefs
:
:
layout_word_select_stop_at_punctuation
(
)
?
FindWordOptions
:
:
StopAtPunctuation
:
FindWordOptions
:
:
None
)
;
}
for
(
;
;
word
=
WordBreaker
:
:
FindWord
(
text
word
.
mBegin
-
1
StaticPrefs
:
:
layout_word_select_stop_at_punctuation
(
)
?
FindWordOptions
:
:
StopAtPunctuation
:
FindWordOptions
:
:
None
)
)
{
if
(
!
aIncludeOrigin
&
&
static_cast
<
int32_t
>
(
word
.
mBegin
)
=
=
mOffset
)
{
MOZ_ASSERT
(
word
.
mBegin
!
=
0
)
;
continue
;
}
if
(
lineStart
&
&
static_cast
<
int32_t
>
(
word
.
mBegin
)
<
lineStart
.
mOffset
)
{
return
lineStart
;
}
if
(
IsAcceptableWordStart
(
mAcc
text
static_cast
<
int32_t
>
(
word
.
mBegin
)
)
)
{
break
;
}
if
(
word
.
mBegin
=
=
0
)
{
if
(
lineStart
)
{
return
lineStart
;
}
return
TextLeafPoint
(
)
;
}
}
return
TextLeafPoint
(
mAcc
static_cast
<
int32_t
>
(
word
.
mBegin
)
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindNextWordStartSameAcc
(
bool
aIncludeOrigin
)
const
{
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
)
;
int32_t
wordStart
=
mOffset
;
if
(
aIncludeOrigin
)
{
if
(
wordStart
=
=
0
)
{
if
(
IsAcceptableWordStart
(
mAcc
text
0
)
)
{
return
*
this
;
}
}
else
{
-
-
wordStart
;
}
}
TextLeafPoint
lineStart
=
FindLineStartSameAcc
(
eDirNext
aIncludeOrigin
)
;
if
(
lineStart
)
{
for
(
;
lineStart
.
mOffset
<
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
&
&
text
.
CharAt
(
lineStart
.
mOffset
)
=
=
'
\
n
'
;
+
+
lineStart
.
mOffset
)
{
}
if
(
lineStart
.
mOffset
=
=
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
)
{
lineStart
=
TextLeafPoint
(
)
;
}
}
intl
:
:
WordBreakIteratorUtf16
wordBreakIter
(
text
)
;
int32_t
previousPos
=
wordStart
;
Maybe
<
uint32_t
>
nextBreak
=
wordBreakIter
.
Seek
(
wordStart
)
;
for
(
;
;
)
{
if
(
!
nextBreak
|
|
*
nextBreak
=
=
text
.
Length
(
)
)
{
if
(
lineStart
)
{
return
lineStart
;
}
if
(
StaticPrefs
:
:
layout_word_select_stop_at_punctuation
(
)
)
{
for
(
int32_t
i
=
previousPos
+
1
;
i
<
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
;
i
+
+
)
{
if
(
IsAcceptableWordStart
(
mAcc
text
i
)
)
{
return
TextLeafPoint
(
mAcc
i
)
;
}
}
}
return
TextLeafPoint
(
)
;
}
wordStart
=
AssertedCast
<
int32_t
>
(
*
nextBreak
)
;
if
(
lineStart
&
&
wordStart
>
lineStart
.
mOffset
)
{
return
lineStart
;
}
if
(
IsAcceptableWordStart
(
mAcc
text
wordStart
)
)
{
break
;
}
if
(
StaticPrefs
:
:
layout_word_select_stop_at_punctuation
(
)
)
{
for
(
int32_t
i
=
previousPos
+
1
;
i
<
wordStart
;
i
+
+
)
{
if
(
IsAcceptableWordStart
(
mAcc
text
i
)
)
{
return
TextLeafPoint
(
mAcc
i
)
;
}
}
}
previousPos
=
wordStart
;
nextBreak
=
wordBreakIter
.
Next
(
)
;
}
return
TextLeafPoint
(
mAcc
wordStart
)
;
}
TextLeafPoint
TextLeafPoint
:
:
GetCaret
(
Accessible
*
aAcc
)
{
if
(
LocalAccessible
*
localAcc
=
aAcc
-
>
AsLocal
(
)
)
{
HyperTextAccessible
*
ht
=
HyperTextFor
(
localAcc
)
;
if
(
!
ht
)
{
return
TextLeafPoint
(
)
;
}
int32_t
htOffset
=
ht
-
>
CaretOffset
(
)
;
if
(
htOffset
=
=
-
1
)
{
return
TextLeafPoint
(
)
;
}
TextLeafPoint
point
=
ht
-
>
ToTextLeafPoint
(
htOffset
)
;
if
(
!
point
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Got
HyperText
CaretOffset
but
ToTextLeafPoint
failed
"
)
;
return
point
;
}
nsIFrame
*
frame
=
ht
-
>
GetFrame
(
)
;
RefPtr
<
nsFrameSelection
>
sel
=
frame
?
frame
-
>
GetFrameSelection
(
)
:
nullptr
;
if
(
sel
&
&
sel
-
>
GetHint
(
)
=
=
CaretAssociationHint
:
:
Before
)
{
if
(
point
.
mOffset
=
=
0
)
{
point
.
mIsEndOfLineInsertionPoint
=
IsLocalAccAtLineStart
(
point
.
mAcc
-
>
AsLocal
(
)
)
&
&
!
point
.
IsParagraphStart
(
)
;
}
else
{
point
.
mIsEndOfLineInsertionPoint
=
true
;
}
}
return
point
;
}
DocAccessibleParent
*
remoteDoc
=
aAcc
-
>
AsRemote
(
)
-
>
Document
(
)
;
auto
[
ht
htOffset
]
=
remoteDoc
-
>
GetCaret
(
)
;
if
(
!
ht
)
{
return
TextLeafPoint
(
)
;
}
TextLeafPoint
point
=
ht
-
>
ToTextLeafPoint
(
htOffset
)
;
point
.
mIsEndOfLineInsertionPoint
=
remoteDoc
-
>
IsCaretAtEndOfLine
(
)
;
return
point
;
}
TextLeafPoint
TextLeafPoint
:
:
AdjustEndOfLine
(
)
const
{
MOZ_ASSERT
(
mIsEndOfLineInsertionPoint
)
;
return
TextLeafPoint
(
mAcc
mOffset
)
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindBoundary
(
AccessibleTextBoundary
aBoundaryType
nsDirection
aDirection
BoundaryFlags
aFlags
)
const
{
if
(
mIsEndOfLineInsertionPoint
)
{
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
|
|
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_CLUSTER
)
{
if
(
aDirection
=
=
eDirNext
|
|
(
aDirection
=
=
eDirPrevious
&
&
aFlags
&
BoundaryFlags
:
:
eIncludeOrigin
)
)
{
return
TextLeafPoint
(
mAcc
mOffset
)
;
}
return
TextLeafPoint
(
mAcc
mOffset
)
.
FindBoundary
(
aBoundaryType
aDirection
aFlags
)
;
}
return
AdjustEndOfLine
(
)
.
FindBoundary
(
aBoundaryType
aDirection
aFlags
)
;
}
bool
inEditableAndStopInIt
=
(
aFlags
&
BoundaryFlags
:
:
eStopInEditable
)
&
&
mAcc
-
>
Parent
(
)
&
&
(
mAcc
-
>
Parent
(
)
-
>
State
(
)
&
states
:
:
EDITABLE
)
;
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_LINE_END
)
{
return
FindLineEnd
(
aDirection
inEditableAndStopInIt
?
aFlags
:
(
aFlags
&
~
BoundaryFlags
:
:
eStopInEditable
)
)
;
}
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_WORD_END
)
{
return
FindWordEnd
(
aDirection
inEditableAndStopInIt
?
aFlags
:
(
aFlags
&
~
BoundaryFlags
:
:
eStopInEditable
)
)
;
}
if
(
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_LINE_START
|
|
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_PARAGRAPH
)
&
&
(
aFlags
&
BoundaryFlags
:
:
eIncludeOrigin
)
&
&
aDirection
=
=
eDirPrevious
&
&
IsEmptyLastLine
(
)
)
{
return
*
this
;
}
bool
includeOrigin
=
!
!
(
aFlags
&
BoundaryFlags
:
:
eIncludeOrigin
)
;
bool
ignoreListItemMarker
=
!
!
(
aFlags
&
BoundaryFlags
:
:
eIgnoreListItemMarker
)
;
Accessible
*
lastAcc
=
nullptr
;
for
(
TextLeafPoint
searchFrom
=
*
this
;
searchFrom
;
searchFrom
=
searchFrom
.
NeighborLeafPoint
(
aDirection
inEditableAndStopInIt
ignoreListItemMarker
)
)
{
lastAcc
=
searchFrom
.
mAcc
;
if
(
ignoreListItemMarker
&
&
searchFrom
=
=
*
this
&
&
searchFrom
.
mAcc
-
>
Role
(
)
=
=
roles
:
:
LISTITEM_MARKER
)
{
continue
;
}
TextLeafPoint
boundary
;
switch
(
aBoundaryType
)
{
case
nsIAccessibleText
:
:
BOUNDARY_CHAR
:
if
(
includeOrigin
)
{
boundary
=
searchFrom
;
}
else
if
(
aDirection
=
=
eDirPrevious
&
&
searchFrom
.
mOffset
>
0
)
{
boundary
.
mAcc
=
searchFrom
.
mAcc
;
boundary
.
mOffset
=
searchFrom
.
mOffset
-
1
;
}
else
if
(
aDirection
=
=
eDirNext
&
&
searchFrom
.
mOffset
+
1
<
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
searchFrom
.
mAcc
)
)
)
{
boundary
.
mAcc
=
searchFrom
.
mAcc
;
boundary
.
mOffset
=
searchFrom
.
mOffset
+
1
;
}
break
;
case
nsIAccessibleText
:
:
BOUNDARY_WORD_START
:
if
(
aDirection
=
=
eDirPrevious
)
{
boundary
=
searchFrom
.
FindPrevWordStartSameAcc
(
includeOrigin
)
;
}
else
{
boundary
=
searchFrom
.
FindNextWordStartSameAcc
(
includeOrigin
)
;
}
break
;
case
nsIAccessibleText
:
:
BOUNDARY_LINE_START
:
boundary
=
searchFrom
.
FindLineStartSameAcc
(
aDirection
includeOrigin
ignoreListItemMarker
)
;
break
;
case
nsIAccessibleText
:
:
BOUNDARY_PARAGRAPH
:
boundary
=
searchFrom
.
FindParagraphSameAcc
(
aDirection
includeOrigin
ignoreListItemMarker
)
;
break
;
case
nsIAccessibleText
:
:
BOUNDARY_CLUSTER
:
boundary
=
searchFrom
.
FindClusterSameAcc
(
aDirection
includeOrigin
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
)
;
break
;
}
if
(
boundary
)
{
return
boundary
;
}
includeOrigin
=
true
;
}
MOZ_ASSERT
(
lastAcc
)
;
return
TextLeafPoint
(
lastAcc
aDirection
=
=
eDirPrevious
?
0
:
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
lastAcc
)
)
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindLineEnd
(
nsDirection
aDirection
BoundaryFlags
aFlags
)
const
{
if
(
aDirection
=
=
eDirPrevious
&
&
IsEmptyLastLine
(
)
)
{
return
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
aFlags
&
~
BoundaryFlags
:
:
eIncludeOrigin
)
;
}
if
(
(
aFlags
&
BoundaryFlags
:
:
eIncludeOrigin
)
&
&
IsLineFeedChar
(
)
)
{
return
*
this
;
}
if
(
aDirection
=
=
eDirPrevious
&
&
!
(
aFlags
&
BoundaryFlags
:
:
eIncludeOrigin
)
)
{
TextLeafPoint
prevChar
=
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
aFlags
&
~
BoundaryFlags
:
:
eIncludeOrigin
)
;
if
(
prevChar
.
IsLineFeedChar
(
)
)
{
return
prevChar
;
}
}
TextLeafPoint
searchFrom
=
*
this
;
if
(
aDirection
=
=
eDirNext
&
&
IsLineFeedChar
(
)
)
{
searchFrom
=
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirNext
aFlags
&
~
BoundaryFlags
:
:
eIncludeOrigin
)
;
}
TextLeafPoint
lineStart
=
searchFrom
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_LINE_START
aDirection
aFlags
)
;
if
(
aDirection
=
=
eDirNext
&
&
IsEmptyLastLine
(
)
)
{
return
lineStart
;
}
TextLeafPoint
prevChar
=
lineStart
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
aFlags
&
~
BoundaryFlags
:
:
eIncludeOrigin
)
;
if
(
prevChar
&
&
prevChar
.
IsLineFeedChar
(
)
)
{
return
prevChar
;
}
return
lineStart
;
}
bool
TextLeafPoint
:
:
IsSpace
(
)
const
{
return
GetWordBreakClass
(
GetChar
(
)
)
=
=
eWbcSpace
;
}
TextLeafPoint
TextLeafPoint
:
:
FindWordEnd
(
nsDirection
aDirection
BoundaryFlags
aFlags
)
const
{
char16_t
origChar
=
GetChar
(
)
;
const
bool
origIsSpace
=
GetWordBreakClass
(
origChar
)
=
=
eWbcSpace
;
bool
prevIsSpace
=
false
;
if
(
aDirection
=
=
eDirPrevious
|
|
(
(
aFlags
&
BoundaryFlags
:
:
eIncludeOrigin
)
&
&
origIsSpace
)
|
|
!
origChar
)
{
TextLeafPoint
prev
=
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
aFlags
&
~
BoundaryFlags
:
:
eIncludeOrigin
)
;
if
(
aDirection
=
=
eDirPrevious
&
&
prev
=
=
*
this
)
{
return
*
this
;
}
prevIsSpace
=
prev
.
IsSpace
(
)
;
if
(
(
aFlags
&
BoundaryFlags
:
:
eIncludeOrigin
)
&
&
(
origIsSpace
|
|
IsDocEdge
(
eDirNext
)
)
&
&
!
prevIsSpace
)
{
return
*
this
;
}
}
TextLeafPoint
boundary
=
*
this
;
if
(
aDirection
=
=
eDirPrevious
&
&
!
prevIsSpace
)
{
boundary
=
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_WORD_START
eDirPrevious
aFlags
)
;
}
else
if
(
aDirection
=
=
eDirNext
&
&
(
origIsSpace
|
|
(
!
origChar
&
&
prevIsSpace
)
)
)
{
boundary
=
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_WORD_START
eDirNext
aFlags
&
~
BoundaryFlags
:
:
eIncludeOrigin
)
;
if
(
boundary
.
IsSpace
(
)
)
{
return
boundary
;
}
}
if
(
aDirection
=
=
eDirNext
)
{
BoundaryFlags
flags
=
aFlags
;
if
(
IsDocEdge
(
eDirPrevious
)
)
{
flags
&
=
~
BoundaryFlags
:
:
eIncludeOrigin
;
}
boundary
=
boundary
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_WORD_START
eDirNext
flags
)
;
}
TextLeafPoint
prev
=
boundary
;
for
(
;
;
)
{
prev
=
prev
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
aFlags
&
~
BoundaryFlags
:
:
eIncludeOrigin
)
;
if
(
prev
=
=
boundary
)
{
break
;
}
if
(
!
prev
.
IsSpace
(
)
)
{
break
;
}
boundary
=
prev
;
}
return
boundary
;
}
TextLeafPoint
TextLeafPoint
:
:
FindParagraphSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
bool
aIgnoreListItemMarker
)
const
{
if
(
aIncludeOrigin
&
&
IsDocEdge
(
eDirPrevious
)
)
{
return
*
this
;
}
if
(
aIgnoreListItemMarker
&
&
aIncludeOrigin
&
&
mOffset
=
=
0
&
&
IsLeafAfterListItemMarker
(
)
)
{
return
*
this
;
}
if
(
mAcc
-
>
IsTextLeaf
(
)
&
&
(
(
aIncludeOrigin
&
&
mOffset
>
0
)
|
|
aDirection
=
=
eDirNext
|
|
mOffset
>
=
2
)
)
{
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
)
;
if
(
aIncludeOrigin
&
&
mOffset
>
0
&
&
text
.
CharAt
(
mOffset
-
1
)
=
=
'
\
n
'
)
{
return
TextLeafPoint
(
mAcc
mOffset
)
;
}
int32_t
lfOffset
=
-
1
;
if
(
aDirection
=
=
eDirNext
)
{
lfOffset
=
text
.
FindChar
(
'
\
n
'
mOffset
)
;
}
else
if
(
mOffset
>
=
2
)
{
lfOffset
=
text
.
RFindChar
(
'
\
n
'
mOffset
-
2
)
;
}
if
(
lfOffset
!
=
-
1
&
&
lfOffset
+
1
<
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
)
{
return
TextLeafPoint
(
mAcc
lfOffset
+
1
)
;
}
}
if
(
aIgnoreListItemMarker
&
&
mOffset
>
0
&
&
aDirection
=
=
eDirPrevious
&
&
IsLeafAfterListItemMarker
(
)
)
{
return
TextLeafPoint
(
mAcc
0
)
;
}
if
(
(
!
aIncludeOrigin
&
&
mOffset
=
=
0
)
|
|
(
aDirection
=
=
eDirNext
&
&
mOffset
>
0
)
)
{
return
TextLeafPoint
(
)
;
}
Accessible
*
prevLeaf
=
PrevLeaf
(
mAcc
)
;
BlockRule
blockRule
;
Pivot
pivot
(
nsAccUtils
:
:
DocumentFor
(
mAcc
)
)
;
Accessible
*
prevBlock
=
pivot
.
Prev
(
mAcc
blockRule
)
;
if
(
prevBlock
)
{
if
(
!
prevLeaf
|
|
prevBlock
=
=
prevLeaf
)
{
return
TextLeafPoint
(
mAcc
0
)
;
}
if
(
prevBlock
-
>
IsAncestorOf
(
mAcc
)
)
{
if
(
!
prevBlock
-
>
IsAncestorOf
(
prevLeaf
)
)
{
return
TextLeafPoint
(
mAcc
0
)
;
}
}
else
{
if
(
prevBlock
-
>
IsAncestorOf
(
prevLeaf
)
)
{
return
TextLeafPoint
(
mAcc
0
)
;
}
}
}
if
(
!
prevLeaf
|
|
prevLeaf
-
>
IsHTMLBr
(
)
)
{
return
TextLeafPoint
(
mAcc
0
)
;
}
if
(
prevLeaf
-
>
IsTextLeaf
(
)
)
{
nsAutoString
text
;
prevLeaf
-
>
AppendTextTo
(
text
nsAccUtils
:
:
TextLength
(
prevLeaf
)
-
1
1
)
;
if
(
text
.
CharAt
(
0
)
=
=
'
\
n
'
)
{
return
TextLeafPoint
(
mAcc
0
)
;
}
}
return
TextLeafPoint
(
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindClusterSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
if
(
aIncludeOrigin
&
&
mOffset
=
=
0
)
{
return
*
this
;
}
if
(
aDirection
=
=
eDirPrevious
)
{
if
(
mOffset
=
=
0
)
{
return
TextLeafPoint
(
)
;
}
if
(
!
aIncludeOrigin
&
&
mOffset
=
=
1
)
{
return
TextLeafPoint
(
mAcc
0
)
;
}
}
nsAutoString
text
;
mAcc
-
>
AppendTextTo
(
text
)
;
if
(
text
.
IsEmpty
(
)
)
{
return
TextLeafPoint
(
)
;
}
if
(
aDirection
=
=
eDirNext
&
&
mOffset
=
=
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
)
{
return
TextLeafPoint
(
)
;
}
intl
:
:
GraphemeClusterBreakIteratorUtf16
iter
(
text
)
;
int32_t
prevCluster
=
0
;
while
(
Maybe
<
uint32_t
>
next
=
iter
.
Next
(
)
)
{
int32_t
cluster
=
static_cast
<
int32_t
>
(
*
next
)
;
if
(
aIncludeOrigin
&
&
cluster
=
=
mOffset
)
{
return
*
this
;
}
if
(
aDirection
=
=
eDirPrevious
)
{
if
(
cluster
>
=
mOffset
)
{
return
TextLeafPoint
(
mAcc
prevCluster
)
;
}
prevCluster
=
cluster
;
}
else
if
(
cluster
>
mOffset
)
{
MOZ_ASSERT
(
aDirection
=
=
eDirNext
)
;
return
TextLeafPoint
(
mAcc
cluster
)
;
}
}
return
TextLeafPoint
(
)
;
}
void
TextLeafPoint
:
:
AddTextOffsetAttributes
(
AccAttributes
*
aAttrs
)
const
{
auto
expose
=
[
aAttrs
]
(
nsAtom
*
aAttr
)
{
if
(
aAttr
=
=
nsGkAtoms
:
:
spelling
)
{
aAttrs
-
>
SetAttribute
(
nsGkAtoms
:
:
invalid
aAttr
)
;
}
else
if
(
aAttr
=
=
nsGkAtoms
:
:
mark
)
{
aAttrs
-
>
SetAttribute
(
aAttr
true
)
;
}
}
;
if
(
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
)
{
auto
ranges
=
FindDOMTextOffsetAttributes
(
acc
mOffset
mOffset
+
1
)
;
for
(
auto
&
[
domRanges
attr
]
:
ranges
)
{
MOZ_ASSERT
(
domRanges
.
Length
(
)
>
=
1
)
;
expose
(
attr
)
;
}
return
;
}
RemoteAccessible
*
acc
=
mAcc
-
>
AsRemote
(
)
;
MOZ_ASSERT
(
acc
)
;
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
TextOffsetAttributes
)
)
{
return
;
}
if
(
!
acc
-
>
mCachedFields
)
{
return
;
}
auto
offsetAttrs
=
acc
-
>
mCachedFields
-
>
GetAttribute
<
nsTArray
<
TextOffsetAttribute
>
>
(
CacheKey
:
:
TextOffsetAttributes
)
;
if
(
!
offsetAttrs
)
{
return
;
}
auto
compare
=
[
this
]
(
const
TextOffsetAttribute
&
aItem
)
{
if
(
aItem
.
mStartOffset
<
=
mOffset
&
&
(
mOffset
<
aItem
.
mEndOffset
|
|
aItem
.
mEndOffset
=
=
-
1
)
)
{
return
0
;
}
if
(
aItem
.
mStartOffset
>
mOffset
)
{
return
-
1
;
}
return
1
;
}
;
auto
[
lower
upper
]
=
EqualRange
(
*
offsetAttrs
0
offsetAttrs
-
>
Length
(
)
compare
)
;
for
(
auto
i
=
lower
;
i
<
upper
;
+
+
i
)
{
expose
(
(
*
offsetAttrs
)
[
i
]
.
mAttribute
)
;
}
}
TextLeafPoint
TextLeafPoint
:
:
FindTextOffsetAttributeSameAcc
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
if
(
!
aIncludeOrigin
&
&
mOffset
=
=
0
&
&
aDirection
=
=
eDirPrevious
)
{
return
TextLeafPoint
(
)
;
}
if
(
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
)
{
auto
ranges
=
aDirection
=
=
eDirNext
?
FindDOMTextOffsetAttributes
(
acc
mOffset
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
true
)
:
FindDOMTextOffsetAttributes
(
acc
0
mOffset
true
)
;
nsINode
*
node
=
acc
-
>
GetNode
(
)
;
int32_t
dest
=
-
1
;
if
(
aDirection
=
=
eDirNext
)
{
for
(
auto
&
[
domRanges
attr
]
:
ranges
)
{
for
(
dom
:
:
AbstractRange
*
domRange
:
domRanges
)
{
if
(
domRange
-
>
GetStartContainer
(
)
=
=
node
)
{
int32_t
matchOffset
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
acc
static_cast
<
int32_t
>
(
domRange
-
>
StartOffset
(
)
)
)
)
;
if
(
aIncludeOrigin
&
&
matchOffset
=
=
mOffset
)
{
return
*
this
;
}
if
(
matchOffset
>
mOffset
&
&
(
dest
=
=
-
1
|
|
matchOffset
<
=
dest
)
)
{
dest
=
matchOffset
;
break
;
}
}
if
(
domRange
-
>
GetEndContainer
(
)
=
=
node
)
{
int32_t
matchOffset
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
acc
static_cast
<
int32_t
>
(
domRange
-
>
EndOffset
(
)
)
)
)
;
if
(
aIncludeOrigin
&
&
matchOffset
=
=
mOffset
)
{
return
*
this
;
}
if
(
matchOffset
>
mOffset
&
&
(
dest
=
=
-
1
|
|
matchOffset
<
=
dest
)
)
{
dest
=
matchOffset
;
break
;
}
}
}
}
}
else
{
for
(
auto
&
[
domRanges
attr
]
:
ranges
)
{
for
(
dom
:
:
AbstractRange
*
domRange
:
Reversed
(
domRanges
)
)
{
if
(
domRange
-
>
GetEndContainer
(
)
=
=
node
)
{
int32_t
matchOffset
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
acc
static_cast
<
int32_t
>
(
domRange
-
>
EndOffset
(
)
)
)
)
;
if
(
aIncludeOrigin
&
&
matchOffset
=
=
mOffset
)
{
return
*
this
;
}
if
(
matchOffset
<
mOffset
&
&
(
dest
=
=
-
1
|
|
matchOffset
>
=
dest
)
)
{
dest
=
matchOffset
;
break
;
}
}
if
(
domRange
-
>
GetStartContainer
(
)
=
=
node
)
{
int32_t
matchOffset
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
acc
static_cast
<
int32_t
>
(
domRange
-
>
StartOffset
(
)
)
)
)
;
if
(
aIncludeOrigin
&
&
matchOffset
=
=
mOffset
)
{
return
*
this
;
}
if
(
matchOffset
<
mOffset
&
&
(
dest
=
=
-
1
|
|
matchOffset
>
=
dest
)
)
{
dest
=
matchOffset
;
break
;
}
}
}
}
}
if
(
dest
=
=
-
1
)
{
return
TextLeafPoint
(
)
;
}
return
TextLeafPoint
(
mAcc
dest
)
;
}
RemoteAccessible
*
acc
=
mAcc
-
>
AsRemote
(
)
;
MOZ_ASSERT
(
acc
)
;
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
TextOffsetAttributes
)
)
{
return
TextLeafPoint
(
)
;
}
if
(
!
acc
-
>
mCachedFields
)
{
return
TextLeafPoint
(
)
;
}
auto
offsetAttrs
=
acc
-
>
mCachedFields
-
>
GetAttribute
<
nsTArray
<
TextOffsetAttribute
>
>
(
CacheKey
:
:
TextOffsetAttributes
)
;
if
(
!
offsetAttrs
)
{
return
TextLeafPoint
(
)
;
}
auto
compare
=
[
this
]
(
const
TextOffsetAttribute
&
aItem
)
{
if
(
aItem
.
mStartOffset
<
=
mOffset
&
&
(
mOffset
<
=
aItem
.
mEndOffset
|
|
aItem
.
mEndOffset
=
=
-
1
)
)
{
return
0
;
}
if
(
aItem
.
mStartOffset
>
mOffset
)
{
return
-
1
;
}
return
1
;
}
;
size_t
index
;
if
(
BinarySearchIf
(
*
offsetAttrs
0
offsetAttrs
-
>
Length
(
)
compare
&
index
)
)
{
if
(
aIncludeOrigin
&
&
(
(
*
offsetAttrs
)
[
index
]
.
mStartOffset
=
=
mOffset
|
|
(
*
offsetAttrs
)
[
index
]
.
mEndOffset
=
=
mOffset
)
)
{
return
*
this
;
}
if
(
aDirection
=
=
eDirNext
)
{
if
(
(
*
offsetAttrs
)
[
index
]
.
mEndOffset
>
mOffset
)
{
MOZ_ASSERT
(
(
*
offsetAttrs
)
[
index
]
.
mEndOffset
!
=
-
1
)
;
return
TextLeafPoint
(
mAcc
(
*
offsetAttrs
)
[
index
]
.
mEndOffset
)
;
}
+
+
index
;
}
else
if
(
(
*
offsetAttrs
)
[
index
]
.
mStartOffset
<
mOffset
&
&
(
*
offsetAttrs
)
[
index
]
.
mStartOffset
!
=
-
1
)
{
return
TextLeafPoint
(
mAcc
(
*
offsetAttrs
)
[
index
]
.
mStartOffset
)
;
}
}
if
(
aDirection
=
=
eDirNext
)
{
if
(
offsetAttrs
-
>
Length
(
)
=
=
index
)
{
return
TextLeafPoint
(
)
;
}
return
TextLeafPoint
(
mAcc
(
*
offsetAttrs
)
[
index
]
.
mStartOffset
)
;
}
if
(
index
=
=
0
)
{
return
TextLeafPoint
(
)
;
}
-
-
index
;
return
TextLeafPoint
(
mAcc
(
*
offsetAttrs
)
[
index
]
.
mEndOffset
)
;
}
TextLeafPoint
TextLeafPoint
:
:
NeighborLeafPoint
(
nsDirection
aDirection
bool
aIsEditable
bool
aIgnoreListItemMarker
)
const
{
Accessible
*
acc
=
aDirection
=
=
eDirPrevious
?
PrevLeaf
(
mAcc
aIsEditable
aIgnoreListItemMarker
)
:
NextLeaf
(
mAcc
aIsEditable
aIgnoreListItemMarker
)
;
if
(
!
acc
)
{
return
TextLeafPoint
(
)
;
}
return
TextLeafPoint
(
acc
aDirection
=
=
eDirPrevious
?
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
acc
)
)
-
1
:
0
)
;
}
LayoutDeviceIntRect
TextLeafPoint
:
:
ComputeBoundsFromFrame
(
)
const
{
LocalAccessible
*
local
=
mAcc
-
>
AsLocal
(
)
;
MOZ_ASSERT
(
local
"
Can
'
t
compute
bounds
in
frame
from
non
-
local
acc
"
)
;
nsIFrame
*
frame
=
local
-
>
GetFrame
(
)
;
MOZ_ASSERT
(
frame
"
No
frame
found
for
acc
!
"
)
;
if
(
!
frame
|
|
!
frame
-
>
IsTextFrame
(
)
)
{
return
local
-
>
Bounds
(
)
;
}
MOZ_ASSERT
(
frame
-
>
IsPrimaryFrame
(
)
"
Cannot
compute
content
offset
on
non
-
primary
frame
"
)
;
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
mOffset
mOffset
+
1
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInRenderedText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
int32_t
contentOffset
=
text
.
mOffsetWithinNodeText
;
int32_t
contentOffsetInFrame
;
nsresult
rv
=
frame
-
>
GetChildFrameContainingOffset
(
contentOffset
true
&
contentOffsetInFrame
&
frame
)
;
NS_ENSURE_SUCCESS
(
rv
LayoutDeviceIntRect
(
)
)
;
nsRect
frameScreenRect
=
frame
-
>
GetScreenRectInAppUnits
(
)
;
nsPoint
frameTextStartPoint
;
rv
=
frame
-
>
GetPointFromOffset
(
contentOffset
&
frameTextStartPoint
)
;
NS_ENSURE_SUCCESS
(
rv
LayoutDeviceIntRect
(
)
)
;
nsPoint
frameTextEndPoint
;
rv
=
frame
-
>
GetPointFromOffset
(
contentOffset
+
1
&
frameTextEndPoint
)
;
NS_ENSURE_SUCCESS
(
rv
LayoutDeviceIntRect
(
)
)
;
frameScreenRect
.
SetRectX
(
frameScreenRect
.
X
(
)
+
std
:
:
min
(
frameTextStartPoint
.
x
frameTextEndPoint
.
x
)
mozilla
:
:
Abs
(
frameTextStartPoint
.
x
-
frameTextEndPoint
.
x
)
)
;
nsPresContext
*
presContext
=
local
-
>
Document
(
)
-
>
PresContext
(
)
;
return
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
frameScreenRect
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
}
nsTArray
<
TextOffsetAttribute
>
TextLeafPoint
:
:
GetTextOffsetAttributes
(
LocalAccessible
*
aAcc
)
{
nsINode
*
node
=
aAcc
-
>
GetNode
(
)
;
auto
ranges
=
FindDOMTextOffsetAttributes
(
aAcc
0
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
)
;
size_t
capacity
=
0
;
for
(
auto
&
[
domRanges
attr
]
:
ranges
)
{
capacity
+
=
domRanges
.
Length
(
)
;
}
nsTArray
<
TextOffsetAttribute
>
offsets
(
capacity
)
;
for
(
auto
&
[
domRanges
attr
]
:
ranges
)
{
for
(
dom
:
:
AbstractRange
*
domRange
:
domRanges
)
{
TextOffsetAttribute
&
data
=
*
offsets
.
AppendElement
(
)
;
data
.
mAttribute
=
attr
;
if
(
domRange
-
>
GetStartContainer
(
)
=
=
node
)
{
data
.
mStartOffset
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
aAcc
static_cast
<
int32_t
>
(
domRange
-
>
StartOffset
(
)
)
)
)
;
}
else
{
MOZ_ASSERT
(
domRange
=
=
*
domRanges
.
begin
(
)
)
;
data
.
mStartOffset
=
-
1
;
}
if
(
domRange
-
>
GetEndContainer
(
)
=
=
node
)
{
data
.
mEndOffset
=
static_cast
<
int32_t
>
(
ContentToRenderedOffset
(
aAcc
static_cast
<
int32_t
>
(
domRange
-
>
EndOffset
(
)
)
)
)
;
}
else
{
MOZ_ASSERT
(
domRange
=
=
*
domRanges
.
rbegin
(
)
)
;
data
.
mEndOffset
=
-
1
;
}
}
}
offsets
.
Sort
(
)
;
return
offsets
;
}
void
TextLeafPoint
:
:
UpdateCachedTextOffsetAttributes
(
dom
:
:
Document
*
aDocument
const
dom
:
:
AbstractRange
&
aRange
)
{
DocAccessible
*
docAcc
=
GetExistingDocAccessible
(
aDocument
)
;
if
(
!
docAcc
)
{
return
;
}
LocalAccessible
*
startAcc
=
docAcc
-
>
GetAccessible
(
aRange
.
GetStartContainer
(
)
)
;
LocalAccessible
*
endAcc
=
docAcc
-
>
GetAccessible
(
aRange
.
GetEndContainer
(
)
)
;
if
(
!
startAcc
|
|
!
endAcc
)
{
return
;
}
for
(
Accessible
*
acc
=
startAcc
;
acc
;
acc
=
NextLeaf
(
acc
)
)
{
if
(
acc
-
>
IsTextLeaf
(
)
)
{
docAcc
-
>
QueueCacheUpdate
(
acc
-
>
AsLocal
(
)
CacheDomain
:
:
TextOffsetAttributes
)
;
}
if
(
acc
=
=
endAcc
)
{
break
;
}
}
}
already_AddRefed
<
AccAttributes
>
TextLeafPoint
:
:
GetTextAttributesLocalAcc
(
bool
aIncludeDefaults
)
const
{
LocalAccessible
*
acc
=
mAcc
-
>
AsLocal
(
)
;
MOZ_ASSERT
(
acc
)
;
MOZ_ASSERT
(
acc
-
>
IsText
(
)
)
;
LocalAccessible
*
parent
=
acc
-
>
LocalParent
(
)
;
HyperTextAccessible
*
hyperAcc
=
parent
-
>
AsHyperText
(
)
;
MOZ_ASSERT
(
hyperAcc
)
;
RefPtr
<
AccAttributes
>
attributes
=
new
AccAttributes
(
)
;
if
(
hyperAcc
)
{
TextAttrsMgr
mgr
(
hyperAcc
aIncludeDefaults
acc
acc
?
acc
-
>
IndexInParent
(
)
:
-
1
)
;
mgr
.
GetAttributes
(
attributes
nullptr
nullptr
)
;
}
return
attributes
.
forget
(
)
;
}
already_AddRefed
<
AccAttributes
>
TextLeafPoint
:
:
GetTextAttributes
(
bool
aIncludeDefaults
)
const
{
if
(
!
mAcc
-
>
IsText
(
)
)
{
return
nullptr
;
}
RefPtr
<
AccAttributes
>
attrs
;
if
(
mAcc
-
>
IsLocal
(
)
)
{
attrs
=
GetTextAttributesLocalAcc
(
aIncludeDefaults
)
;
}
else
{
attrs
=
new
AccAttributes
(
)
;
if
(
aIncludeDefaults
)
{
Accessible
*
parent
=
mAcc
-
>
Parent
(
)
;
if
(
parent
&
&
parent
-
>
IsRemote
(
)
&
&
parent
-
>
IsHyperText
(
)
)
{
if
(
auto
defAttrs
=
parent
-
>
AsRemote
(
)
-
>
GetCachedTextAttributes
(
)
)
{
defAttrs
-
>
CopyTo
(
attrs
)
;
}
}
}
if
(
auto
thisAttrs
=
mAcc
-
>
AsRemote
(
)
-
>
GetCachedTextAttributes
(
)
)
{
thisAttrs
-
>
CopyTo
(
attrs
)
;
}
}
AddTextOffsetAttributes
(
attrs
)
;
return
attrs
.
forget
(
)
;
}
TextLeafPoint
TextLeafPoint
:
:
FindTextAttrsStart
(
nsDirection
aDirection
bool
aIncludeOrigin
)
const
{
if
(
mIsEndOfLineInsertionPoint
)
{
return
AdjustEndOfLine
(
)
.
FindTextAttrsStart
(
aDirection
aIncludeOrigin
)
;
}
const
bool
isRemote
=
mAcc
-
>
IsRemote
(
)
;
RefPtr
<
const
AccAttributes
>
lastAttrs
=
isRemote
?
mAcc
-
>
AsRemote
(
)
-
>
GetCachedTextAttributes
(
)
:
GetTextAttributesLocalAcc
(
)
;
if
(
aIncludeOrigin
&
&
aDirection
=
=
eDirNext
&
&
mOffset
=
=
0
)
{
TextLeafPoint
point
;
point
.
mAcc
=
mAcc
-
>
PrevSibling
(
)
;
if
(
!
point
.
mAcc
|
|
!
point
.
mAcc
-
>
IsText
(
)
)
{
return
*
this
;
}
RefPtr
<
const
AccAttributes
>
attrs
=
isRemote
?
point
.
mAcc
-
>
AsRemote
(
)
-
>
GetCachedTextAttributes
(
)
:
point
.
GetTextAttributesLocalAcc
(
)
;
if
(
attrs
&
&
lastAttrs
&
&
!
attrs
-
>
Equal
(
lastAttrs
)
)
{
return
*
this
;
}
}
TextLeafPoint
lastPoint
=
*
this
;
for
(
;
;
)
{
if
(
TextLeafPoint
offsetAttr
=
lastPoint
.
FindTextOffsetAttributeSameAcc
(
aDirection
aIncludeOrigin
&
&
lastPoint
.
mAcc
=
=
mAcc
)
)
{
return
offsetAttr
;
}
TextLeafPoint
point
;
point
.
mAcc
=
aDirection
=
=
eDirNext
?
lastPoint
.
mAcc
-
>
NextSibling
(
)
:
lastPoint
.
mAcc
-
>
PrevSibling
(
)
;
if
(
!
point
.
mAcc
|
|
!
point
.
mAcc
-
>
IsText
(
)
)
{
break
;
}
RefPtr
<
const
AccAttributes
>
attrs
=
isRemote
?
point
.
mAcc
-
>
AsRemote
(
)
-
>
GetCachedTextAttributes
(
)
:
point
.
GetTextAttributesLocalAcc
(
)
;
if
(
attrs
&
&
lastAttrs
&
&
!
attrs
-
>
Equal
(
lastAttrs
)
)
{
if
(
aDirection
=
=
eDirPrevious
)
{
point
=
lastPoint
;
point
.
mOffset
=
0
;
}
if
(
!
aIncludeOrigin
&
&
point
=
=
*
this
)
{
MOZ_ASSERT
(
aDirection
=
=
eDirPrevious
)
;
continue
;
}
return
point
;
}
lastPoint
=
point
;
if
(
aDirection
=
=
eDirPrevious
)
{
lastPoint
.
mOffset
=
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
point
.
mAcc
)
)
;
}
lastAttrs
=
attrs
;
}
return
TextLeafPoint
(
lastPoint
.
mAcc
aDirection
=
=
eDirPrevious
?
0
:
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
lastPoint
.
mAcc
)
)
)
;
}
LayoutDeviceIntRect
TextLeafPoint
:
:
CharBounds
(
)
{
if
(
mAcc
&
&
!
mAcc
-
>
IsText
(
)
)
{
return
mAcc
-
>
Bounds
(
)
;
}
if
(
!
mAcc
|
|
(
mAcc
-
>
IsRemote
(
)
&
&
!
mAcc
-
>
AsRemote
(
)
-
>
mCachedFields
)
)
{
return
LayoutDeviceIntRect
(
)
;
}
if
(
LocalAccessible
*
local
=
mAcc
-
>
AsLocal
(
)
)
{
if
(
!
local
-
>
IsTextLeaf
(
)
|
|
nsAccUtils
:
:
TextLength
(
local
)
=
=
0
)
{
return
local
-
>
Bounds
(
)
;
}
if
(
mOffset
>
=
0
&
&
static_cast
<
uint32_t
>
(
mOffset
)
>
=
nsAccUtils
:
:
TextLength
(
local
)
)
{
NS_ASSERTION
(
static_cast
<
uint32_t
>
(
mOffset
)
<
=
nsAccUtils
:
:
TextLength
(
local
)
"
Wrong
in
offset
"
)
;
return
LayoutDeviceIntRect
(
)
;
}
LayoutDeviceIntRect
bounds
=
ComputeBoundsFromFrame
(
)
;
nsPresContext
*
presContext
=
local
-
>
Document
(
)
-
>
PresContext
(
)
;
nsIFrame
*
rootFrame
=
presContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
LayoutDeviceIntRect
orgRectPixels
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
rootFrame
-
>
GetScreenRectInAppUnits
(
)
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
bounds
.
MoveBy
(
-
orgRectPixels
.
X
(
)
-
orgRectPixels
.
Y
(
)
)
;
bounds
.
ScaleRoundOut
(
presContext
-
>
PresShell
(
)
-
>
GetResolution
(
)
)
;
bounds
.
MoveBy
(
orgRectPixels
.
X
(
)
orgRectPixels
.
Y
(
)
)
;
return
bounds
;
}
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
TextBounds
)
)
{
return
LayoutDeviceIntRect
(
)
;
}
RemoteAccessible
*
remote
=
mAcc
-
>
AsRemote
(
)
;
nsRect
charBounds
=
remote
-
>
GetCachedCharRect
(
mOffset
)
;
if
(
!
charBounds
.
IsEmpty
(
)
)
{
return
remote
-
>
BoundsWithOffset
(
Some
(
charBounds
)
)
;
}
return
LayoutDeviceIntRect
(
)
;
}
bool
TextLeafPoint
:
:
ContainsPoint
(
int32_t
aX
int32_t
aY
)
{
if
(
mAcc
&
&
!
mAcc
-
>
IsText
(
)
)
{
return
mAcc
-
>
Bounds
(
)
.
Contains
(
aX
aY
)
;
}
return
CharBounds
(
)
.
Contains
(
aX
aY
)
;
}
bool
TextLeafRange
:
:
Crop
(
Accessible
*
aContainer
)
{
TextLeafPoint
containerStart
(
aContainer
0
)
;
TextLeafPoint
containerEnd
(
aContainer
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
)
;
if
(
mEnd
<
containerStart
|
|
containerEnd
<
mStart
)
{
return
false
;
}
if
(
mStart
<
containerStart
)
{
mStart
=
containerStart
;
}
if
(
containerEnd
<
mEnd
)
{
mEnd
=
containerEnd
;
}
return
true
;
}
LayoutDeviceIntRect
TextLeafRange
:
:
Bounds
(
)
const
{
LayoutDeviceIntRect
result
=
TextLeafPoint
{
mStart
}
.
CharBounds
(
)
;
const
bool
succeeded
=
WalkLineRects
(
[
&
result
]
(
LayoutDeviceIntRect
aLineRect
)
{
result
.
UnionRect
(
result
aLineRect
)
;
}
)
;
if
(
!
succeeded
)
{
return
{
}
;
}
return
result
;
}
nsTArray
<
LayoutDeviceIntRect
>
TextLeafRange
:
:
LineRects
(
)
const
{
Maybe
<
LayoutDeviceIntRect
>
contentBounds
;
if
(
Accessible
*
doc
=
nsAccUtils
:
:
DocumentFor
(
mStart
.
mAcc
)
)
{
contentBounds
.
emplace
(
doc
-
>
Bounds
(
)
)
;
}
nsTArray
<
LayoutDeviceIntRect
>
lineRects
;
WalkLineRects
(
[
&
lineRects
&
contentBounds
]
(
LayoutDeviceIntRect
aLineRect
)
{
bool
boundsVisible
=
true
;
if
(
contentBounds
.
isSome
(
)
)
{
boundsVisible
=
aLineRect
.
IntersectRect
(
aLineRect
*
contentBounds
)
;
}
if
(
boundsVisible
)
{
lineRects
.
AppendElement
(
aLineRect
)
;
}
}
)
;
return
lineRects
;
}
TextLeafPoint
TextLeafRange
:
:
TextLeafPointAtScreenPoint
(
int32_t
aX
int32_t
aY
)
const
{
const
TextLeafPoint
endPoint
=
mEnd
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
)
;
TextLeafPoint
point
=
mStart
;
if
(
mStart
<
=
endPoint
)
{
for
(
;
!
point
.
ContainsPoint
(
aX
aY
)
&
&
point
!
=
endPoint
;
point
=
point
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirNext
)
)
{
}
}
return
point
;
}
bool
TextLeafRange
:
:
SetSelection
(
int32_t
aSelectionNum
)
const
{
if
(
!
mStart
|
|
!
mEnd
|
|
mStart
.
mAcc
-
>
IsLocal
(
)
!
=
mEnd
.
mAcc
-
>
IsLocal
(
)
)
{
return
false
;
}
if
(
mStart
.
mAcc
-
>
IsRemote
(
)
)
{
DocAccessibleParent
*
doc
=
mStart
.
mAcc
-
>
AsRemote
(
)
-
>
Document
(
)
;
if
(
doc
!
=
mEnd
.
mAcc
-
>
AsRemote
(
)
-
>
Document
(
)
)
{
return
false
;
}
Unused
<
<
doc
-
>
SendSetTextSelection
(
mStart
.
mAcc
-
>
ID
(
)
mStart
.
mOffset
mEnd
.
mAcc
-
>
ID
(
)
mEnd
.
mOffset
aSelectionNum
)
;
return
true
;
}
bool
reversed
=
mEnd
<
mStart
;
auto
[
startContent
startContentOffset
]
=
!
reversed
?
mStart
.
ToDOMPoint
(
false
)
:
mEnd
.
ToDOMPoint
(
false
)
;
auto
[
endContent
endContentOffset
]
=
!
reversed
?
mEnd
.
ToDOMPoint
(
false
)
:
mStart
.
ToDOMPoint
(
false
)
;
if
(
!
startContent
|
|
!
endContent
)
{
return
false
;
}
RefPtr
<
dom
:
:
Selection
>
domSel
=
GetDOMSelection
(
startContent
endContent
)
;
if
(
!
domSel
)
{
return
false
;
}
uint32_t
rangeCount
=
domSel
-
>
RangeCount
(
)
;
RefPtr
<
nsRange
>
domRange
=
nullptr
;
if
(
aSelectionNum
=
=
static_cast
<
int32_t
>
(
rangeCount
)
|
|
aSelectionNum
<
0
)
{
domRange
=
nsRange
:
:
Create
(
startContent
)
;
}
else
{
domRange
=
domSel
-
>
GetRangeAt
(
AssertedCast
<
uint32_t
>
(
aSelectionNum
)
)
;
}
if
(
!
domRange
)
{
return
false
;
}
domRange
-
>
SetStart
(
startContent
startContentOffset
)
;
domRange
-
>
SetEnd
(
endContent
endContentOffset
)
;
if
(
aSelectionNum
!
=
static_cast
<
int32_t
>
(
rangeCount
)
)
{
domSel
-
>
RemoveRangeAndUnselectFramesAndNotifyListeners
(
*
domRange
IgnoreErrors
(
)
)
;
}
IgnoredErrorResult
err
;
domSel
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
domRange
err
)
;
if
(
!
err
.
Failed
(
)
)
{
domSel
-
>
SetDirection
(
reversed
?
eDirPrevious
:
eDirNext
)
;
return
true
;
}
return
false
;
}
void
TextLeafRange
:
:
GetSelection
(
Accessible
*
aAcc
nsTArray
<
TextLeafRange
>
&
aRanges
)
{
HyperTextAccessibleBase
*
hyp
=
aAcc
-
>
AsHyperTextBase
(
)
;
if
(
!
hyp
)
{
return
;
}
AutoTArray
<
TextRange
1
>
hypRanges
;
hyp
-
>
CroppedSelectionRanges
(
hypRanges
)
;
aRanges
.
SetCapacity
(
hypRanges
.
Length
(
)
)
;
for
(
TextRange
&
hypRange
:
hypRanges
)
{
TextLeafPoint
start
=
hypRange
.
StartContainer
(
)
-
>
AsHyperTextBase
(
)
-
>
ToTextLeafPoint
(
hypRange
.
StartOffset
(
)
)
;
TextLeafPoint
end
=
hypRange
.
EndContainer
(
)
-
>
AsHyperTextBase
(
)
-
>
ToTextLeafPoint
(
hypRange
.
EndOffset
(
)
)
;
aRanges
.
EmplaceBack
(
start
end
)
;
}
}
void
TextLeafRange
:
:
ScrollIntoView
(
uint32_t
aScrollType
)
const
{
if
(
!
mStart
|
|
!
mEnd
|
|
mStart
.
mAcc
-
>
IsLocal
(
)
!
=
mEnd
.
mAcc
-
>
IsLocal
(
)
)
{
return
;
}
if
(
mStart
.
mAcc
-
>
IsRemote
(
)
)
{
DocAccessibleParent
*
doc
=
mStart
.
mAcc
-
>
AsRemote
(
)
-
>
Document
(
)
;
if
(
doc
!
=
mEnd
.
mAcc
-
>
AsRemote
(
)
-
>
Document
(
)
)
{
return
;
}
Unused
<
<
doc
-
>
SendScrollTextLeafRangeIntoView
(
mStart
.
mAcc
-
>
ID
(
)
mStart
.
mOffset
mEnd
.
mAcc
-
>
ID
(
)
mEnd
.
mOffset
aScrollType
)
;
return
;
}
auto
[
startContent
startContentOffset
]
=
mStart
.
ToDOMPoint
(
)
;
auto
[
endContent
endContentOffset
]
=
mEnd
.
ToDOMPoint
(
)
;
if
(
!
startContent
|
|
!
endContent
)
{
return
;
}
ErrorResult
er
;
RefPtr
<
nsRange
>
domRange
=
nsRange
:
:
Create
(
startContent
startContentOffset
endContent
endContentOffset
er
)
;
if
(
er
.
Failed
(
)
)
{
return
;
}
nsCoreUtils
:
:
ScrollSubstringTo
(
mStart
.
mAcc
-
>
AsLocal
(
)
-
>
GetFrame
(
)
domRange
aScrollType
)
;
}
bool
TextLeafRange
:
:
WalkLineRects
(
LineRectCallback
aCallback
)
const
{
if
(
mEnd
<
=
mStart
)
{
return
false
;
}
bool
locatedFinalLine
=
false
;
TextLeafPoint
currPoint
=
mStart
;
while
(
!
locatedFinalLine
)
{
TextLeafPoint
lineStartPoint
=
currPoint
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_LINE_START
eDirNext
)
;
TextLeafPoint
lastPointInLine
=
lineStartPoint
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
)
;
if
(
lineStartPoint
=
=
currPoint
|
|
mEnd
<
=
lastPointInLine
)
{
lastPointInLine
=
mEnd
;
locatedFinalLine
=
true
;
}
LayoutDeviceIntRect
currLine
=
currPoint
.
CharBounds
(
)
;
currLine
.
UnionRect
(
currLine
lastPointInLine
.
CharBounds
(
)
)
;
aCallback
(
currLine
)
;
currPoint
=
lineStartPoint
;
}
return
true
;
}
TextLeafRange
:
:
Iterator
TextLeafRange
:
:
Iterator
:
:
BeginIterator
(
const
TextLeafRange
&
aRange
)
{
Iterator
result
(
aRange
)
;
result
.
mSegmentStart
=
aRange
.
mStart
;
if
(
aRange
.
mStart
.
mAcc
=
=
aRange
.
mEnd
.
mAcc
)
{
result
.
mSegmentEnd
=
aRange
.
mEnd
;
}
else
{
result
.
mSegmentEnd
=
TextLeafPoint
(
aRange
.
mStart
.
mAcc
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
)
;
}
return
result
;
}
TextLeafRange
:
:
Iterator
TextLeafRange
:
:
Iterator
:
:
EndIterator
(
const
TextLeafRange
&
aRange
)
{
Iterator
result
(
aRange
)
;
result
.
mSegmentEnd
=
TextLeafPoint
(
)
;
result
.
mSegmentStart
=
TextLeafPoint
(
)
;
return
result
;
}
TextLeafRange
:
:
Iterator
&
TextLeafRange
:
:
Iterator
:
:
operator
+
+
(
)
{
if
(
mSegmentEnd
.
mAcc
=
=
mRange
.
mEnd
.
mAcc
)
{
mSegmentEnd
=
TextLeafPoint
(
)
;
mSegmentStart
=
TextLeafPoint
(
)
;
return
*
this
;
}
if
(
Accessible
*
nextLeaf
=
NextLeaf
(
mSegmentEnd
.
mAcc
)
)
{
mSegmentStart
=
TextLeafPoint
(
nextLeaf
0
)
;
if
(
nextLeaf
=
=
mRange
.
mEnd
.
mAcc
)
{
mSegmentEnd
=
TextLeafPoint
(
nextLeaf
mRange
.
mEnd
.
mOffset
)
;
}
else
{
mSegmentEnd
=
TextLeafPoint
(
nextLeaf
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
)
;
}
}
else
{
mSegmentEnd
=
TextLeafPoint
(
)
;
mSegmentStart
=
TextLeafPoint
(
)
;
}
return
*
this
;
}
}
