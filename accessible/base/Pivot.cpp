#
include
"
Pivot
.
h
"
#
include
"
AccIterator
.
h
"
#
include
"
Accessible
.
h
"
#
include
"
DocAccessible
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
Pivot
:
:
Pivot
(
Accessible
*
aRoot
)
:
mRoot
(
aRoot
)
{
MOZ_COUNT_CTOR
(
Pivot
)
;
}
Pivot
:
:
~
Pivot
(
)
{
MOZ_COUNT_DTOR
(
Pivot
)
;
}
Accessible
*
Pivot
:
:
AdjustStartPosition
(
Accessible
*
aAnchor
PivotRule
&
aRule
uint16_t
*
aFilterResult
)
{
Accessible
*
matched
=
aAnchor
;
*
aFilterResult
=
aRule
.
Match
(
aAnchor
)
;
if
(
aAnchor
!
=
mRoot
)
{
for
(
Accessible
*
temp
=
aAnchor
-
>
Parent
(
)
;
temp
&
&
temp
!
=
mRoot
;
temp
=
temp
-
>
Parent
(
)
)
{
uint16_t
filtered
=
aRule
.
Match
(
temp
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
)
{
*
aFilterResult
=
filtered
;
matched
=
temp
;
}
}
}
return
matched
;
}
Accessible
*
Pivot
:
:
SearchBackward
(
Accessible
*
aAnchor
PivotRule
&
aRule
bool
aSearchCurrent
)
{
if
(
!
aAnchor
)
{
return
nullptr
;
}
uint16_t
filtered
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
Accessible
*
accessible
=
AdjustStartPosition
(
aAnchor
aRule
&
filtered
)
;
if
(
aSearchCurrent
&
&
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
)
{
return
accessible
;
}
while
(
accessible
!
=
mRoot
)
{
Accessible
*
parent
=
accessible
-
>
Parent
(
)
;
int32_t
idxInParent
=
accessible
-
>
IndexInParent
(
)
;
while
(
idxInParent
>
0
)
{
if
(
!
(
accessible
=
parent
-
>
GetChildAt
(
-
-
idxInParent
)
)
)
{
continue
;
}
filtered
=
aRule
.
Match
(
accessible
)
;
Accessible
*
lastChild
=
nullptr
;
while
(
!
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
)
&
&
(
lastChild
=
accessible
-
>
LastChild
(
)
)
)
{
parent
=
accessible
;
accessible
=
lastChild
;
idxInParent
=
accessible
-
>
IndexInParent
(
)
;
filtered
=
aRule
.
Match
(
accessible
)
;
}
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
{
return
accessible
;
}
}
if
(
!
(
accessible
=
parent
)
)
{
break
;
}
filtered
=
aRule
.
Match
(
accessible
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
{
return
accessible
;
}
}
return
nullptr
;
}
Accessible
*
Pivot
:
:
SearchForward
(
Accessible
*
aAnchor
PivotRule
&
aRule
bool
aSearchCurrent
)
{
Accessible
*
accessible
=
aAnchor
?
aAnchor
:
mRoot
;
uint16_t
filtered
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
accessible
=
AdjustStartPosition
(
accessible
aRule
&
filtered
)
;
if
(
aSearchCurrent
&
&
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
)
{
return
accessible
;
}
while
(
true
)
{
Accessible
*
firstChild
=
nullptr
;
while
(
!
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
)
&
&
(
firstChild
=
accessible
-
>
FirstChild
(
)
)
)
{
accessible
=
firstChild
;
filtered
=
aRule
.
Match
(
accessible
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
{
return
accessible
;
}
}
Accessible
*
sibling
=
nullptr
;
Accessible
*
temp
=
accessible
;
do
{
if
(
temp
=
=
mRoot
)
{
break
;
}
sibling
=
temp
-
>
NextSibling
(
)
;
if
(
sibling
)
{
break
;
}
}
while
(
(
temp
=
temp
-
>
Parent
(
)
)
)
;
if
(
!
sibling
)
{
break
;
}
accessible
=
sibling
;
filtered
=
aRule
.
Match
(
accessible
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
{
return
accessible
;
}
}
return
nullptr
;
}
HyperTextAccessible
*
Pivot
:
:
SearchForText
(
Accessible
*
aAnchor
bool
aBackward
)
{
Accessible
*
accessible
=
aAnchor
;
while
(
true
)
{
Accessible
*
child
=
nullptr
;
while
(
(
child
=
(
aBackward
?
accessible
-
>
LastChild
(
)
:
accessible
-
>
FirstChild
(
)
)
)
)
{
accessible
=
child
;
if
(
child
-
>
IsHyperText
(
)
)
{
return
child
-
>
AsHyperText
(
)
;
}
}
Accessible
*
sibling
=
nullptr
;
Accessible
*
temp
=
accessible
;
do
{
if
(
temp
=
=
mRoot
)
{
break
;
}
if
(
temp
!
=
aAnchor
&
&
temp
-
>
IsHyperText
(
)
)
{
return
temp
-
>
AsHyperText
(
)
;
}
if
(
sibling
)
{
break
;
}
sibling
=
aBackward
?
temp
-
>
PrevSibling
(
)
:
temp
-
>
NextSibling
(
)
;
}
while
(
(
temp
=
temp
-
>
Parent
(
)
)
)
;
if
(
!
sibling
)
{
break
;
}
accessible
=
sibling
;
if
(
accessible
-
>
IsHyperText
(
)
)
{
return
accessible
-
>
AsHyperText
(
)
;
}
}
return
nullptr
;
}
Accessible
*
Pivot
:
:
Next
(
Accessible
*
aAnchor
PivotRule
&
aRule
bool
aIncludeStart
)
{
return
SearchForward
(
aAnchor
aRule
aIncludeStart
)
;
}
Accessible
*
Pivot
:
:
Prev
(
Accessible
*
aAnchor
PivotRule
&
aRule
bool
aIncludeStart
)
{
return
SearchBackward
(
aAnchor
aRule
aIncludeStart
)
;
}
Accessible
*
Pivot
:
:
First
(
PivotRule
&
aRule
)
{
return
SearchForward
(
mRoot
aRule
true
)
;
}
Accessible
*
Pivot
:
:
Last
(
PivotRule
&
aRule
)
{
Accessible
*
lastAccessible
=
mRoot
;
while
(
lastAccessible
-
>
HasChildren
(
)
)
{
lastAccessible
=
lastAccessible
-
>
LastChild
(
)
;
}
return
SearchBackward
(
lastAccessible
aRule
true
)
;
}
Accessible
*
Pivot
:
:
NextText
(
Accessible
*
aAnchor
int32_t
*
aStartOffset
int32_t
*
aEndOffset
int32_t
aBoundaryType
)
{
int32_t
tempStart
=
*
aStartOffset
tempEnd
=
*
aEndOffset
;
Accessible
*
tempPosition
=
aAnchor
;
if
(
aAnchor
-
>
IsTextLeaf
(
)
&
&
aAnchor
-
>
Parent
(
)
&
&
aAnchor
-
>
Parent
(
)
-
>
IsHyperText
(
)
)
{
HyperTextAccessible
*
text
=
aAnchor
-
>
Parent
(
)
-
>
AsHyperText
(
)
;
tempPosition
=
text
;
int32_t
childOffset
=
text
-
>
GetChildOffset
(
aAnchor
)
;
if
(
tempEnd
=
=
-
1
)
{
tempStart
=
0
;
tempEnd
=
0
;
}
tempStart
+
=
childOffset
;
tempEnd
+
=
childOffset
;
}
while
(
true
)
{
MOZ_ASSERT
(
tempPosition
)
;
Accessible
*
curPosition
=
tempPosition
;
HyperTextAccessible
*
text
=
nullptr
;
if
(
!
(
text
=
tempPosition
-
>
AsHyperText
(
)
)
)
{
text
=
SearchForText
(
tempPosition
false
)
;
if
(
!
text
)
{
return
nullptr
;
}
if
(
text
!
=
curPosition
)
{
tempStart
=
tempEnd
=
-
1
;
}
tempPosition
=
text
;
}
if
(
tempEnd
=
=
-
1
)
{
tempEnd
=
text
=
=
curPosition
-
>
Parent
(
)
?
text
-
>
GetChildOffset
(
curPosition
)
:
0
;
}
if
(
tempEnd
=
=
static_cast
<
int32_t
>
(
text
-
>
CharacterCount
(
)
)
)
{
if
(
tempPosition
=
=
mRoot
)
{
return
nullptr
;
}
Accessible
*
sibling
=
tempPosition
-
>
NextSibling
(
)
;
if
(
tempPosition
-
>
IsLink
(
)
)
{
if
(
sibling
&
&
sibling
-
>
IsLink
(
)
)
{
tempStart
=
tempEnd
=
-
1
;
tempPosition
=
sibling
;
}
else
{
tempStart
=
tempPosition
-
>
StartOffset
(
)
;
tempEnd
=
tempPosition
-
>
EndOffset
(
)
;
tempPosition
=
tempPosition
-
>
Parent
(
)
;
}
}
else
{
tempPosition
=
SearchForText
(
tempPosition
false
)
;
if
(
!
tempPosition
)
{
return
nullptr
;
}
tempStart
=
tempEnd
=
-
1
;
}
continue
;
}
AccessibleTextBoundary
startBoundary
endBoundary
;
switch
(
aBoundaryType
)
{
case
nsIAccessiblePivot
:
:
CHAR_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
;
break
;
case
nsIAccessiblePivot
:
:
WORD_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_START
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_END
;
break
;
case
nsIAccessiblePivot
:
:
LINE_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_START
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_END
;
break
;
default
:
return
nullptr
;
}
nsAutoString
unusedText
;
int32_t
newStart
=
0
newEnd
=
0
currentEnd
=
tempEnd
;
text
-
>
TextAtOffset
(
tempEnd
endBoundary
&
newStart
&
tempEnd
unusedText
)
;
text
-
>
TextBeforeOffset
(
tempEnd
startBoundary
&
newStart
&
newEnd
unusedText
)
;
int32_t
potentialStart
=
newEnd
=
=
tempEnd
?
newStart
:
newEnd
;
tempStart
=
potentialStart
>
tempStart
?
potentialStart
:
currentEnd
;
Accessible
*
childAtOffset
=
nullptr
;
for
(
int32_t
i
=
tempStart
;
i
<
tempEnd
;
i
+
+
)
{
childAtOffset
=
text
-
>
GetChildAtOffset
(
i
)
;
if
(
childAtOffset
&
&
childAtOffset
-
>
IsHyperText
(
)
)
{
tempEnd
=
i
;
break
;
}
}
if
(
childAtOffset
&
&
childAtOffset
-
>
IsHyperText
(
)
&
&
tempStart
=
=
static_cast
<
int32_t
>
(
childAtOffset
-
>
StartOffset
(
)
)
)
{
tempPosition
=
childAtOffset
;
tempStart
=
tempEnd
=
-
1
;
continue
;
}
*
aStartOffset
=
tempStart
;
*
aEndOffset
=
tempEnd
;
MOZ_ASSERT
(
tempPosition
)
;
return
tempPosition
;
}
}
Accessible
*
Pivot
:
:
PrevText
(
Accessible
*
aAnchor
int32_t
*
aStartOffset
int32_t
*
aEndOffset
int32_t
aBoundaryType
)
{
int32_t
tempStart
=
*
aStartOffset
tempEnd
=
*
aEndOffset
;
Accessible
*
tempPosition
=
aAnchor
;
if
(
aAnchor
-
>
IsTextLeaf
(
)
&
&
aAnchor
-
>
Parent
(
)
&
&
aAnchor
-
>
Parent
(
)
-
>
IsHyperText
(
)
)
{
HyperTextAccessible
*
text
=
aAnchor
-
>
Parent
(
)
-
>
AsHyperText
(
)
;
tempPosition
=
text
;
int32_t
childOffset
=
text
-
>
GetChildOffset
(
aAnchor
)
;
if
(
tempStart
=
=
-
1
)
{
tempStart
=
nsAccUtils
:
:
TextLength
(
aAnchor
)
;
tempEnd
=
tempStart
;
}
tempStart
+
=
childOffset
;
tempEnd
+
=
childOffset
;
}
while
(
true
)
{
MOZ_ASSERT
(
tempPosition
)
;
Accessible
*
curPosition
=
tempPosition
;
HyperTextAccessible
*
text
;
if
(
!
(
text
=
tempPosition
-
>
AsHyperText
(
)
)
)
{
text
=
SearchForText
(
tempPosition
true
)
;
if
(
!
text
)
{
return
nullptr
;
}
if
(
text
!
=
curPosition
)
{
tempStart
=
tempEnd
=
-
1
;
}
tempPosition
=
text
;
}
if
(
tempStart
=
=
-
1
)
{
if
(
tempPosition
!
=
curPosition
&
&
text
=
=
curPosition
-
>
Parent
(
)
)
{
tempStart
=
text
-
>
GetChildOffset
(
curPosition
)
+
nsAccUtils
:
:
TextLength
(
curPosition
)
;
}
else
{
tempStart
=
text
-
>
CharacterCount
(
)
;
}
}
if
(
tempStart
=
=
0
)
{
if
(
tempPosition
=
=
mRoot
)
{
return
nullptr
;
}
Accessible
*
sibling
=
tempPosition
-
>
PrevSibling
(
)
;
if
(
tempPosition
-
>
IsLink
(
)
)
{
if
(
sibling
&
&
sibling
-
>
IsLink
(
)
)
{
HyperTextAccessible
*
siblingText
=
sibling
-
>
AsHyperText
(
)
;
tempStart
=
tempEnd
=
siblingText
?
siblingText
-
>
CharacterCount
(
)
:
-
1
;
tempPosition
=
sibling
;
}
else
{
tempStart
=
tempPosition
-
>
StartOffset
(
)
;
tempEnd
=
tempPosition
-
>
EndOffset
(
)
;
tempPosition
=
tempPosition
-
>
Parent
(
)
;
}
}
else
{
HyperTextAccessible
*
tempText
=
SearchForText
(
tempPosition
true
)
;
if
(
!
tempText
)
{
return
nullptr
;
}
tempPosition
=
tempText
;
tempStart
=
tempEnd
=
tempText
-
>
CharacterCount
(
)
;
}
continue
;
}
AccessibleTextBoundary
startBoundary
endBoundary
;
switch
(
aBoundaryType
)
{
case
nsIAccessiblePivot
:
:
CHAR_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
;
break
;
case
nsIAccessiblePivot
:
:
WORD_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_START
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_END
;
break
;
case
nsIAccessiblePivot
:
:
LINE_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_START
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_END
;
break
;
default
:
return
nullptr
;
}
nsAutoString
unusedText
;
int32_t
newStart
=
0
newEnd
=
0
currentStart
=
tempStart
potentialEnd
=
0
;
text
-
>
TextBeforeOffset
(
tempStart
startBoundary
&
newStart
&
newEnd
unusedText
)
;
if
(
newStart
<
tempStart
)
{
tempStart
=
newEnd
>
=
currentStart
?
newStart
:
newEnd
;
}
else
{
text
-
>
TextBeforeOffset
(
tempStart
-
1
startBoundary
&
newStart
&
tempStart
unusedText
)
;
}
text
-
>
TextAtOffset
(
tempStart
endBoundary
&
newStart
&
potentialEnd
unusedText
)
;
tempEnd
=
potentialEnd
<
tempEnd
?
potentialEnd
:
currentStart
;
Accessible
*
childAtOffset
=
nullptr
;
for
(
int32_t
i
=
tempEnd
-
1
;
i
>
=
tempStart
;
i
-
-
)
{
childAtOffset
=
text
-
>
GetChildAtOffset
(
i
)
;
if
(
childAtOffset
&
&
!
childAtOffset
-
>
IsText
(
)
)
{
tempStart
=
childAtOffset
-
>
EndOffset
(
)
;
break
;
}
}
if
(
childAtOffset
&
&
!
childAtOffset
-
>
IsText
(
)
&
&
tempEnd
=
=
static_cast
<
int32_t
>
(
childAtOffset
-
>
EndOffset
(
)
)
)
{
tempPosition
=
childAtOffset
;
tempStart
=
tempEnd
=
childAtOffset
-
>
AsHyperText
(
)
-
>
CharacterCount
(
)
;
continue
;
}
*
aStartOffset
=
tempStart
;
*
aEndOffset
=
tempEnd
;
MOZ_ASSERT
(
tempPosition
)
;
return
tempPosition
;
}
}
Accessible
*
Pivot
:
:
AtPoint
(
int32_t
aX
int32_t
aY
PivotRule
&
aRule
)
{
Accessible
*
match
=
nullptr
;
Accessible
*
child
=
mRoot
-
>
ChildAtPoint
(
aX
aY
Accessible
:
:
eDeepestChild
)
;
while
(
child
&
&
mRoot
!
=
child
)
{
uint16_t
filtered
=
aRule
.
Match
(
child
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
)
{
match
=
nullptr
;
}
if
(
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
&
&
!
match
)
{
nsIntRect
childRect
=
child
-
>
Bounds
(
)
;
if
(
childRect
.
Contains
(
aX
aY
)
)
{
match
=
child
;
}
}
child
=
child
-
>
Parent
(
)
;
}
return
match
;
}
PivotRoleRule
:
:
PivotRoleRule
(
mozilla
:
:
a11y
:
:
role
aRole
)
:
mRole
(
aRole
)
{
}
uint16_t
PivotRoleRule
:
:
Match
(
Accessible
*
aAccessible
)
{
uint16_t
result
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
if
(
nsAccUtils
:
:
MustPrune
(
aAccessible
)
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
aAccessible
-
>
Role
(
)
=
=
mRole
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
return
result
;
}
