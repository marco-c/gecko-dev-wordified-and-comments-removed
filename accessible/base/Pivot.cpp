#
include
"
Pivot
.
h
"
#
include
"
AccIterator
.
h
"
#
include
"
LocalAccessible
.
h
"
#
include
"
DocAccessible
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
Pivot
:
:
Pivot
(
const
AccessibleOrProxy
&
aRoot
)
:
mRoot
(
aRoot
)
{
MOZ_COUNT_CTOR
(
Pivot
)
;
}
Pivot
:
:
~
Pivot
(
)
{
MOZ_COUNT_DTOR
(
Pivot
)
;
}
AccessibleOrProxy
Pivot
:
:
AdjustStartPosition
(
AccessibleOrProxy
&
aAnchor
PivotRule
&
aRule
uint16_t
*
aFilterResult
)
{
AccessibleOrProxy
matched
=
aAnchor
;
*
aFilterResult
=
aRule
.
Match
(
aAnchor
)
;
if
(
aAnchor
!
=
mRoot
)
{
for
(
AccessibleOrProxy
temp
=
aAnchor
.
Parent
(
)
;
!
temp
.
IsNull
(
)
&
&
temp
!
=
mRoot
;
temp
=
temp
.
Parent
(
)
)
{
uint16_t
filtered
=
aRule
.
Match
(
temp
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
)
{
*
aFilterResult
=
filtered
;
matched
=
temp
;
}
}
}
return
matched
;
}
AccessibleOrProxy
Pivot
:
:
SearchBackward
(
AccessibleOrProxy
&
aAnchor
PivotRule
&
aRule
bool
aSearchCurrent
)
{
if
(
aAnchor
.
IsNull
(
)
)
{
return
aAnchor
;
}
uint16_t
filtered
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
AccessibleOrProxy
accOrProxy
=
AdjustStartPosition
(
aAnchor
aRule
&
filtered
)
;
if
(
aSearchCurrent
&
&
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
)
{
return
accOrProxy
;
}
while
(
accOrProxy
!
=
mRoot
)
{
AccessibleOrProxy
parent
=
accOrProxy
.
Parent
(
)
;
int32_t
idxInParent
=
accOrProxy
.
IndexInParent
(
)
;
while
(
idxInParent
>
0
)
{
accOrProxy
=
parent
.
ChildAt
(
-
-
idxInParent
)
;
if
(
accOrProxy
.
IsNull
(
)
)
{
continue
;
}
filtered
=
aRule
.
Match
(
accOrProxy
)
;
AccessibleOrProxy
lastChild
=
accOrProxy
.
LastChild
(
)
;
while
(
!
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
)
&
&
!
lastChild
.
IsNull
(
)
)
{
parent
=
accOrProxy
;
accOrProxy
=
lastChild
;
idxInParent
=
accOrProxy
.
IndexInParent
(
)
;
filtered
=
aRule
.
Match
(
accOrProxy
)
;
lastChild
=
accOrProxy
.
LastChild
(
)
;
}
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
{
return
accOrProxy
;
}
}
accOrProxy
=
parent
;
if
(
accOrProxy
.
IsNull
(
)
)
{
break
;
}
filtered
=
aRule
.
Match
(
accOrProxy
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
{
return
accOrProxy
;
}
}
return
AccessibleOrProxy
(
)
;
}
AccessibleOrProxy
Pivot
:
:
SearchForward
(
AccessibleOrProxy
&
aAnchor
PivotRule
&
aRule
bool
aSearchCurrent
)
{
AccessibleOrProxy
accOrProxy
=
!
aAnchor
.
IsNull
(
)
?
aAnchor
:
mRoot
;
uint16_t
filtered
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
accOrProxy
=
AdjustStartPosition
(
accOrProxy
aRule
&
filtered
)
;
if
(
aSearchCurrent
&
&
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
)
{
return
accOrProxy
;
}
while
(
true
)
{
AccessibleOrProxy
firstChild
=
accOrProxy
.
FirstChild
(
)
;
while
(
!
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
)
&
&
!
firstChild
.
IsNull
(
)
)
{
accOrProxy
=
firstChild
;
filtered
=
aRule
.
Match
(
accOrProxy
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
{
return
accOrProxy
;
}
firstChild
=
accOrProxy
.
FirstChild
(
)
;
}
AccessibleOrProxy
sibling
=
AccessibleOrProxy
(
)
;
AccessibleOrProxy
temp
=
accOrProxy
;
do
{
if
(
temp
=
=
mRoot
)
{
break
;
}
sibling
=
temp
.
NextSibling
(
)
;
if
(
!
sibling
.
IsNull
(
)
)
{
break
;
}
temp
=
temp
.
Parent
(
)
;
}
while
(
!
temp
.
IsNull
(
)
)
;
if
(
sibling
.
IsNull
(
)
)
{
break
;
}
accOrProxy
=
sibling
;
filtered
=
aRule
.
Match
(
accOrProxy
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
{
return
accOrProxy
;
}
}
return
AccessibleOrProxy
(
)
;
}
HyperTextAccessible
*
Pivot
:
:
SearchForText
(
LocalAccessible
*
aAnchor
bool
aBackward
)
{
if
(
!
mRoot
.
IsAccessible
(
)
)
{
return
nullptr
;
}
LocalAccessible
*
accessible
=
aAnchor
;
while
(
true
)
{
LocalAccessible
*
child
=
nullptr
;
while
(
(
child
=
(
aBackward
?
accessible
-
>
LocalLastChild
(
)
:
accessible
-
>
LocalFirstChild
(
)
)
)
)
{
accessible
=
child
;
if
(
child
-
>
IsHyperText
(
)
)
{
return
child
-
>
AsHyperText
(
)
;
}
}
LocalAccessible
*
sibling
=
nullptr
;
LocalAccessible
*
temp
=
accessible
;
do
{
if
(
temp
=
=
mRoot
.
AsAccessible
(
)
)
{
break
;
}
if
(
temp
!
=
aAnchor
&
&
temp
-
>
IsHyperText
(
)
)
{
return
temp
-
>
AsHyperText
(
)
;
}
if
(
sibling
)
{
break
;
}
sibling
=
aBackward
?
temp
-
>
LocalPrevSibling
(
)
:
temp
-
>
LocalNextSibling
(
)
;
}
while
(
(
temp
=
temp
-
>
LocalParent
(
)
)
)
;
if
(
!
sibling
)
{
break
;
}
accessible
=
sibling
;
if
(
accessible
-
>
IsHyperText
(
)
)
{
return
accessible
-
>
AsHyperText
(
)
;
}
}
return
nullptr
;
}
AccessibleOrProxy
Pivot
:
:
Next
(
AccessibleOrProxy
&
aAnchor
PivotRule
&
aRule
bool
aIncludeStart
)
{
return
SearchForward
(
aAnchor
aRule
aIncludeStart
)
;
}
AccessibleOrProxy
Pivot
:
:
Prev
(
AccessibleOrProxy
&
aAnchor
PivotRule
&
aRule
bool
aIncludeStart
)
{
return
SearchBackward
(
aAnchor
aRule
aIncludeStart
)
;
}
AccessibleOrProxy
Pivot
:
:
First
(
PivotRule
&
aRule
)
{
return
SearchForward
(
mRoot
aRule
true
)
;
}
AccessibleOrProxy
Pivot
:
:
Last
(
PivotRule
&
aRule
)
{
AccessibleOrProxy
lastAccOrProxy
=
mRoot
;
while
(
lastAccOrProxy
.
HasChildren
(
)
)
{
lastAccOrProxy
=
lastAccOrProxy
.
LastChild
(
)
;
}
return
SearchBackward
(
lastAccOrProxy
aRule
true
)
;
}
LocalAccessible
*
Pivot
:
:
NextText
(
LocalAccessible
*
aAnchor
int32_t
*
aStartOffset
int32_t
*
aEndOffset
int32_t
aBoundaryType
)
{
if
(
!
mRoot
.
IsAccessible
(
)
)
{
return
nullptr
;
}
int32_t
tempStart
=
*
aStartOffset
tempEnd
=
*
aEndOffset
;
LocalAccessible
*
tempPosition
=
aAnchor
;
if
(
aAnchor
-
>
IsTextLeaf
(
)
&
&
aAnchor
-
>
LocalParent
(
)
&
&
aAnchor
-
>
LocalParent
(
)
-
>
IsHyperText
(
)
)
{
HyperTextAccessible
*
text
=
aAnchor
-
>
LocalParent
(
)
-
>
AsHyperText
(
)
;
tempPosition
=
text
;
int32_t
childOffset
=
text
-
>
GetChildOffset
(
aAnchor
)
;
if
(
tempEnd
=
=
-
1
)
{
tempStart
=
0
;
tempEnd
=
0
;
}
tempStart
+
=
childOffset
;
tempEnd
+
=
childOffset
;
}
while
(
true
)
{
MOZ_ASSERT
(
tempPosition
)
;
LocalAccessible
*
curPosition
=
tempPosition
;
HyperTextAccessible
*
text
=
nullptr
;
if
(
!
(
text
=
tempPosition
-
>
AsHyperText
(
)
)
)
{
text
=
SearchForText
(
tempPosition
false
)
;
if
(
!
text
)
{
return
nullptr
;
}
if
(
text
!
=
curPosition
)
{
tempStart
=
tempEnd
=
-
1
;
}
tempPosition
=
text
;
}
if
(
tempEnd
=
=
-
1
)
{
tempEnd
=
text
=
=
curPosition
-
>
LocalParent
(
)
?
text
-
>
GetChildOffset
(
curPosition
)
:
0
;
}
if
(
tempEnd
=
=
static_cast
<
int32_t
>
(
text
-
>
CharacterCount
(
)
)
)
{
if
(
tempPosition
=
=
mRoot
.
AsAccessible
(
)
)
{
return
nullptr
;
}
LocalAccessible
*
sibling
=
tempPosition
-
>
LocalNextSibling
(
)
;
if
(
tempPosition
-
>
IsLink
(
)
)
{
if
(
sibling
&
&
sibling
-
>
IsLink
(
)
)
{
tempStart
=
tempEnd
=
-
1
;
tempPosition
=
sibling
;
}
else
{
tempStart
=
tempPosition
-
>
StartOffset
(
)
;
tempEnd
=
tempPosition
-
>
EndOffset
(
)
;
tempPosition
=
tempPosition
-
>
LocalParent
(
)
;
}
}
else
{
tempPosition
=
SearchForText
(
tempPosition
false
)
;
if
(
!
tempPosition
)
{
return
nullptr
;
}
tempStart
=
tempEnd
=
-
1
;
}
continue
;
}
AccessibleTextBoundary
startBoundary
endBoundary
;
switch
(
aBoundaryType
)
{
case
nsIAccessiblePivot
:
:
CHAR_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
;
break
;
case
nsIAccessiblePivot
:
:
WORD_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_START
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_END
;
break
;
case
nsIAccessiblePivot
:
:
LINE_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_START
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_END
;
break
;
default
:
return
nullptr
;
}
nsAutoString
unusedText
;
int32_t
newStart
=
0
newEnd
=
0
currentEnd
=
tempEnd
;
text
-
>
TextAtOffset
(
tempEnd
endBoundary
&
newStart
&
tempEnd
unusedText
)
;
text
-
>
TextBeforeOffset
(
tempEnd
startBoundary
&
newStart
&
newEnd
unusedText
)
;
int32_t
potentialStart
=
newEnd
=
=
tempEnd
?
newStart
:
newEnd
;
tempStart
=
potentialStart
>
tempStart
?
potentialStart
:
currentEnd
;
LocalAccessible
*
childAtOffset
=
nullptr
;
for
(
int32_t
i
=
tempStart
;
i
<
tempEnd
;
i
+
+
)
{
childAtOffset
=
text
-
>
GetChildAtOffset
(
i
)
;
if
(
childAtOffset
&
&
childAtOffset
-
>
IsHyperText
(
)
)
{
tempEnd
=
i
;
break
;
}
}
if
(
childAtOffset
&
&
childAtOffset
-
>
IsHyperText
(
)
&
&
tempStart
=
=
static_cast
<
int32_t
>
(
childAtOffset
-
>
StartOffset
(
)
)
)
{
tempPosition
=
childAtOffset
;
tempStart
=
tempEnd
=
-
1
;
continue
;
}
*
aStartOffset
=
tempStart
;
*
aEndOffset
=
tempEnd
;
MOZ_ASSERT
(
tempPosition
)
;
return
tempPosition
;
}
}
LocalAccessible
*
Pivot
:
:
PrevText
(
LocalAccessible
*
aAnchor
int32_t
*
aStartOffset
int32_t
*
aEndOffset
int32_t
aBoundaryType
)
{
if
(
!
mRoot
.
IsAccessible
(
)
)
{
return
nullptr
;
}
int32_t
tempStart
=
*
aStartOffset
tempEnd
=
*
aEndOffset
;
LocalAccessible
*
tempPosition
=
aAnchor
;
if
(
aAnchor
-
>
IsTextLeaf
(
)
&
&
aAnchor
-
>
LocalParent
(
)
&
&
aAnchor
-
>
LocalParent
(
)
-
>
IsHyperText
(
)
)
{
HyperTextAccessible
*
text
=
aAnchor
-
>
LocalParent
(
)
-
>
AsHyperText
(
)
;
tempPosition
=
text
;
int32_t
childOffset
=
text
-
>
GetChildOffset
(
aAnchor
)
;
if
(
tempStart
=
=
-
1
)
{
tempStart
=
nsAccUtils
:
:
TextLength
(
aAnchor
)
;
tempEnd
=
tempStart
;
}
tempStart
+
=
childOffset
;
tempEnd
+
=
childOffset
;
}
while
(
true
)
{
MOZ_ASSERT
(
tempPosition
)
;
LocalAccessible
*
curPosition
=
tempPosition
;
HyperTextAccessible
*
text
;
if
(
!
(
text
=
tempPosition
-
>
AsHyperText
(
)
)
)
{
text
=
SearchForText
(
tempPosition
true
)
;
if
(
!
text
)
{
return
nullptr
;
}
if
(
text
!
=
curPosition
)
{
tempStart
=
tempEnd
=
-
1
;
}
tempPosition
=
text
;
}
if
(
tempStart
=
=
-
1
)
{
if
(
tempPosition
!
=
curPosition
&
&
text
=
=
curPosition
-
>
LocalParent
(
)
)
{
tempStart
=
text
-
>
GetChildOffset
(
curPosition
)
+
nsAccUtils
:
:
TextLength
(
curPosition
)
;
}
else
{
tempStart
=
text
-
>
CharacterCount
(
)
;
}
}
if
(
tempStart
=
=
0
)
{
if
(
tempPosition
=
=
mRoot
.
AsAccessible
(
)
)
{
return
nullptr
;
}
LocalAccessible
*
sibling
=
tempPosition
-
>
LocalPrevSibling
(
)
;
if
(
tempPosition
-
>
IsLink
(
)
)
{
if
(
sibling
&
&
sibling
-
>
IsLink
(
)
)
{
HyperTextAccessible
*
siblingText
=
sibling
-
>
AsHyperText
(
)
;
tempStart
=
tempEnd
=
siblingText
?
siblingText
-
>
CharacterCount
(
)
:
-
1
;
tempPosition
=
sibling
;
}
else
{
tempStart
=
tempPosition
-
>
StartOffset
(
)
;
tempEnd
=
tempPosition
-
>
EndOffset
(
)
;
tempPosition
=
tempPosition
-
>
LocalParent
(
)
;
}
}
else
{
HyperTextAccessible
*
tempText
=
SearchForText
(
tempPosition
true
)
;
if
(
!
tempText
)
{
return
nullptr
;
}
tempPosition
=
tempText
;
tempStart
=
tempEnd
=
tempText
-
>
CharacterCount
(
)
;
}
continue
;
}
AccessibleTextBoundary
startBoundary
endBoundary
;
switch
(
aBoundaryType
)
{
case
nsIAccessiblePivot
:
:
CHAR_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
;
break
;
case
nsIAccessiblePivot
:
:
WORD_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_START
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_END
;
break
;
case
nsIAccessiblePivot
:
:
LINE_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_START
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_END
;
break
;
default
:
return
nullptr
;
}
nsAutoString
unusedText
;
int32_t
newStart
=
0
newEnd
=
0
currentStart
=
tempStart
potentialEnd
=
0
;
text
-
>
TextBeforeOffset
(
tempStart
startBoundary
&
newStart
&
newEnd
unusedText
)
;
if
(
newStart
<
tempStart
)
{
tempStart
=
newEnd
>
=
currentStart
?
newStart
:
newEnd
;
}
else
{
text
-
>
TextBeforeOffset
(
tempStart
-
1
startBoundary
&
newStart
&
tempStart
unusedText
)
;
}
text
-
>
TextAtOffset
(
tempStart
endBoundary
&
newStart
&
potentialEnd
unusedText
)
;
tempEnd
=
potentialEnd
<
tempEnd
?
potentialEnd
:
currentStart
;
LocalAccessible
*
childAtOffset
=
nullptr
;
for
(
int32_t
i
=
tempEnd
-
1
;
i
>
=
tempStart
;
i
-
-
)
{
childAtOffset
=
text
-
>
GetChildAtOffset
(
i
)
;
if
(
childAtOffset
&
&
!
childAtOffset
-
>
IsText
(
)
)
{
tempStart
=
childAtOffset
-
>
EndOffset
(
)
;
break
;
}
}
if
(
childAtOffset
&
&
!
childAtOffset
-
>
IsText
(
)
&
&
tempEnd
=
=
static_cast
<
int32_t
>
(
childAtOffset
-
>
EndOffset
(
)
)
)
{
tempPosition
=
childAtOffset
;
tempStart
=
tempEnd
=
childAtOffset
-
>
AsHyperText
(
)
-
>
CharacterCount
(
)
;
continue
;
}
*
aStartOffset
=
tempStart
;
*
aEndOffset
=
tempEnd
;
MOZ_ASSERT
(
tempPosition
)
;
return
tempPosition
;
}
}
AccessibleOrProxy
Pivot
:
:
AtPoint
(
int32_t
aX
int32_t
aY
PivotRule
&
aRule
)
{
AccessibleOrProxy
match
=
AccessibleOrProxy
(
)
;
AccessibleOrProxy
child
=
mRoot
.
ChildAtPoint
(
aX
aY
Accessible
:
:
EWhichChildAtPoint
:
:
DeepestChild
)
;
while
(
!
child
.
IsNull
(
)
&
&
(
mRoot
!
=
child
)
)
{
uint16_t
filtered
=
aRule
.
Match
(
child
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
)
{
match
=
AccessibleOrProxy
(
)
;
}
if
(
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
&
&
match
.
IsNull
(
)
)
{
nsIntRect
childRect
=
child
.
IsAccessible
(
)
?
child
.
AsAccessible
(
)
-
>
Bounds
(
)
:
child
.
AsProxy
(
)
-
>
Bounds
(
)
;
if
(
childRect
.
Contains
(
aX
aY
)
)
{
match
=
child
;
}
}
child
=
child
.
Parent
(
)
;
}
return
match
;
}
PivotRoleRule
:
:
PivotRoleRule
(
mozilla
:
:
a11y
:
:
role
aRole
)
:
mRole
(
aRole
)
mDirectDescendantsFrom
(
nullptr
)
{
}
PivotRoleRule
:
:
PivotRoleRule
(
mozilla
:
:
a11y
:
:
role
aRole
AccessibleOrProxy
&
aDirectDescendantsFrom
)
:
mRole
(
aRole
)
mDirectDescendantsFrom
(
aDirectDescendantsFrom
)
{
}
uint16_t
PivotRoleRule
:
:
Match
(
const
AccessibleOrProxy
&
aAccOrProxy
)
{
uint16_t
result
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
if
(
nsAccUtils
:
:
MustPrune
(
aAccOrProxy
)
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
!
mDirectDescendantsFrom
.
IsNull
(
)
&
&
(
aAccOrProxy
!
=
mDirectDescendantsFrom
)
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
aAccOrProxy
.
Role
(
)
=
=
mRole
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
return
result
;
}
uint16_t
LocalAccInSameDocRule
:
:
Match
(
const
AccessibleOrProxy
&
aAccOrProxy
)
{
LocalAccessible
*
acc
=
aAccOrProxy
.
AsAccessible
(
)
;
if
(
!
acc
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
acc
-
>
IsOuterDoc
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
|
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
