#
include
"
Pivot
.
h
"
#
include
"
AccIterator
.
h
"
#
include
"
LocalAccessible
.
h
"
#
include
"
RemoteAccessible
.
h
"
#
include
"
DocAccessible
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
mozilla
/
a11y
/
Accessible
.
h
"
#
include
"
mozilla
/
a11y
/
HyperTextAccessibleBase
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
StaticPrefs_accessibility
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
Pivot
:
:
Pivot
(
Accessible
*
aRoot
)
:
mRoot
(
aRoot
)
{
MOZ_COUNT_CTOR
(
Pivot
)
;
}
Pivot
:
:
~
Pivot
(
)
{
MOZ_COUNT_DTOR
(
Pivot
)
;
}
Accessible
*
Pivot
:
:
AdjustStartPosition
(
Accessible
*
aAnchor
PivotRule
&
aRule
uint16_t
*
aFilterResult
)
{
Accessible
*
matched
=
aAnchor
;
*
aFilterResult
=
aRule
.
Match
(
aAnchor
)
;
if
(
aAnchor
&
&
aAnchor
!
=
mRoot
)
{
for
(
Accessible
*
temp
=
aAnchor
-
>
Parent
(
)
;
temp
&
&
temp
!
=
mRoot
;
temp
=
temp
-
>
Parent
(
)
)
{
uint16_t
filtered
=
aRule
.
Match
(
temp
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
)
{
*
aFilterResult
=
filtered
;
matched
=
temp
;
}
}
}
return
matched
;
}
Accessible
*
Pivot
:
:
SearchBackward
(
Accessible
*
aAnchor
PivotRule
&
aRule
bool
aSearchCurrent
)
{
if
(
!
aAnchor
)
{
return
nullptr
;
}
uint16_t
filtered
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
Accessible
*
acc
=
AdjustStartPosition
(
aAnchor
aRule
&
filtered
)
;
if
(
aSearchCurrent
&
&
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
)
{
return
acc
;
}
while
(
acc
&
&
acc
!
=
mRoot
)
{
Accessible
*
parent
=
acc
-
>
Parent
(
)
;
int32_t
idxInParent
=
acc
-
>
IndexInParent
(
)
;
while
(
idxInParent
>
0
&
&
parent
)
{
acc
=
parent
-
>
ChildAt
(
-
-
idxInParent
)
;
if
(
!
acc
)
{
continue
;
}
filtered
=
aRule
.
Match
(
acc
)
;
Accessible
*
lastChild
=
acc
-
>
LastChild
(
)
;
while
(
!
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
)
&
&
lastChild
)
{
parent
=
acc
;
acc
=
lastChild
;
idxInParent
=
acc
-
>
IndexInParent
(
)
;
filtered
=
aRule
.
Match
(
acc
)
;
lastChild
=
acc
-
>
LastChild
(
)
;
}
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
{
return
acc
;
}
}
acc
=
parent
;
if
(
!
acc
)
{
break
;
}
filtered
=
aRule
.
Match
(
acc
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
{
return
acc
;
}
}
return
nullptr
;
}
Accessible
*
Pivot
:
:
SearchForward
(
Accessible
*
aAnchor
PivotRule
&
aRule
bool
aSearchCurrent
)
{
Accessible
*
acc
=
aAnchor
?
aAnchor
:
mRoot
;
uint16_t
filtered
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
acc
=
AdjustStartPosition
(
acc
aRule
&
filtered
)
;
if
(
aSearchCurrent
&
&
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
)
{
return
acc
;
}
while
(
acc
)
{
Accessible
*
firstChild
=
acc
-
>
FirstChild
(
)
;
while
(
!
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
)
&
&
firstChild
)
{
acc
=
firstChild
;
filtered
=
aRule
.
Match
(
acc
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
{
return
acc
;
}
firstChild
=
acc
-
>
FirstChild
(
)
;
}
Accessible
*
sibling
=
nullptr
;
Accessible
*
temp
=
acc
;
do
{
if
(
temp
=
=
mRoot
)
{
break
;
}
sibling
=
temp
-
>
NextSibling
(
)
;
if
(
sibling
)
{
break
;
}
temp
=
temp
-
>
Parent
(
)
;
}
while
(
temp
)
;
if
(
!
sibling
)
{
break
;
}
acc
=
sibling
;
filtered
=
aRule
.
Match
(
acc
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
{
return
acc
;
}
}
return
nullptr
;
}
Accessible
*
Pivot
:
:
SearchForText
(
Accessible
*
aAnchor
bool
aBackward
)
{
if
(
mRoot
-
>
IsRemote
(
)
&
&
!
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
{
return
nullptr
;
}
Accessible
*
accessible
=
aAnchor
;
while
(
true
)
{
Accessible
*
child
=
nullptr
;
while
(
(
child
=
(
aBackward
?
accessible
-
>
LastChild
(
)
:
accessible
-
>
FirstChild
(
)
)
)
)
{
accessible
=
child
;
if
(
child
-
>
IsHyperText
(
)
)
{
return
child
;
}
}
Accessible
*
sibling
=
nullptr
;
Accessible
*
temp
=
accessible
;
do
{
if
(
temp
=
=
mRoot
)
{
break
;
}
if
(
temp
!
=
aAnchor
&
&
temp
-
>
IsHyperText
(
)
)
{
return
temp
;
}
if
(
sibling
)
{
break
;
}
sibling
=
aBackward
?
temp
-
>
PrevSibling
(
)
:
temp
-
>
NextSibling
(
)
;
}
while
(
(
temp
=
temp
-
>
Parent
(
)
)
)
;
if
(
!
sibling
)
{
break
;
}
accessible
=
sibling
;
if
(
accessible
-
>
IsHyperText
(
)
)
{
return
accessible
;
}
}
return
nullptr
;
}
Accessible
*
Pivot
:
:
Next
(
Accessible
*
aAnchor
PivotRule
&
aRule
bool
aIncludeStart
)
{
return
SearchForward
(
aAnchor
aRule
aIncludeStart
)
;
}
Accessible
*
Pivot
:
:
Prev
(
Accessible
*
aAnchor
PivotRule
&
aRule
bool
aIncludeStart
)
{
return
SearchBackward
(
aAnchor
aRule
aIncludeStart
)
;
}
Accessible
*
Pivot
:
:
First
(
PivotRule
&
aRule
)
{
return
SearchForward
(
mRoot
aRule
true
)
;
}
Accessible
*
Pivot
:
:
Last
(
PivotRule
&
aRule
)
{
Accessible
*
lastAcc
=
mRoot
;
while
(
lastAcc
&
&
lastAcc
-
>
HasChildren
(
)
)
{
lastAcc
=
lastAcc
-
>
LastChild
(
)
;
}
return
SearchBackward
(
lastAcc
aRule
true
)
;
}
Accessible
*
Pivot
:
:
NextText
(
Accessible
*
aAnchor
int32_t
*
aStartOffset
int32_t
*
aEndOffset
int32_t
aBoundaryType
)
{
if
(
mRoot
-
>
IsRemote
(
)
&
&
!
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
{
return
nullptr
;
}
int32_t
tempStart
=
*
aStartOffset
tempEnd
=
*
aEndOffset
;
Accessible
*
tempPosition
=
aAnchor
;
if
(
aAnchor
-
>
IsTextLeaf
(
)
&
&
aAnchor
-
>
Parent
(
)
&
&
aAnchor
-
>
Parent
(
)
-
>
IsHyperText
(
)
)
{
tempPosition
=
aAnchor
-
>
Parent
(
)
;
HyperTextAccessibleBase
*
text
=
tempPosition
-
>
AsHyperTextBase
(
)
;
int32_t
childOffset
=
text
-
>
GetChildOffset
(
aAnchor
)
;
if
(
tempEnd
=
=
-
1
)
{
tempStart
=
0
;
tempEnd
=
0
;
}
tempStart
+
=
childOffset
;
tempEnd
+
=
childOffset
;
}
while
(
true
)
{
MOZ_ASSERT
(
tempPosition
)
;
Accessible
*
curPosition
=
tempPosition
;
HyperTextAccessibleBase
*
text
=
nullptr
;
if
(
!
(
text
=
tempPosition
-
>
AsHyperTextBase
(
)
)
)
{
tempPosition
=
SearchForText
(
tempPosition
false
)
;
if
(
!
tempPosition
)
{
return
nullptr
;
}
if
(
tempPosition
!
=
curPosition
)
{
tempStart
=
tempEnd
=
-
1
;
}
text
=
tempPosition
-
>
AsHyperTextBase
(
)
;
}
if
(
tempEnd
=
=
-
1
)
{
tempEnd
=
tempPosition
=
=
curPosition
-
>
Parent
(
)
?
text
-
>
GetChildOffset
(
curPosition
)
:
0
;
}
if
(
tempEnd
=
=
static_cast
<
int32_t
>
(
text
-
>
CharacterCount
(
)
)
)
{
if
(
tempPosition
=
=
mRoot
)
{
return
nullptr
;
}
Accessible
*
sibling
=
tempPosition
-
>
NextSibling
(
)
;
if
(
tempPosition
-
>
IsLink
(
)
)
{
if
(
sibling
&
&
sibling
-
>
IsLink
(
)
)
{
tempStart
=
tempEnd
=
-
1
;
tempPosition
=
sibling
;
}
else
{
tempStart
=
tempPosition
-
>
StartOffset
(
)
;
tempEnd
=
tempPosition
-
>
EndOffset
(
)
;
tempPosition
=
tempPosition
-
>
Parent
(
)
;
}
}
else
{
tempPosition
=
SearchForText
(
tempPosition
false
)
;
if
(
!
tempPosition
)
{
return
nullptr
;
}
tempStart
=
tempEnd
=
-
1
;
}
continue
;
}
AccessibleTextBoundary
startBoundary
endBoundary
;
switch
(
aBoundaryType
)
{
case
nsIAccessiblePivot
:
:
CHAR_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
;
break
;
case
nsIAccessiblePivot
:
:
WORD_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_START
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_END
;
break
;
case
nsIAccessiblePivot
:
:
LINE_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_START
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_END
;
break
;
default
:
return
nullptr
;
}
nsAutoString
unusedText
;
int32_t
newStart
=
0
newEnd
=
0
currentEnd
=
tempEnd
;
text
-
>
TextAtOffset
(
tempEnd
endBoundary
&
newStart
&
tempEnd
unusedText
)
;
text
-
>
TextBeforeOffset
(
tempEnd
startBoundary
&
newStart
&
newEnd
unusedText
)
;
int32_t
potentialStart
=
newEnd
=
=
tempEnd
?
newStart
:
newEnd
;
tempStart
=
potentialStart
>
tempStart
?
potentialStart
:
currentEnd
;
Accessible
*
childAtOffset
=
nullptr
;
for
(
int32_t
i
=
tempStart
;
i
<
tempEnd
;
i
+
+
)
{
childAtOffset
=
text
-
>
GetChildAtOffset
(
i
)
;
if
(
childAtOffset
&
&
childAtOffset
-
>
IsHyperText
(
)
)
{
tempEnd
=
i
;
break
;
}
}
if
(
childAtOffset
&
&
childAtOffset
-
>
IsHyperText
(
)
&
&
tempStart
=
=
static_cast
<
int32_t
>
(
childAtOffset
-
>
StartOffset
(
)
)
)
{
tempPosition
=
childAtOffset
;
tempStart
=
tempEnd
=
-
1
;
continue
;
}
*
aStartOffset
=
tempStart
;
*
aEndOffset
=
tempEnd
;
MOZ_ASSERT
(
tempPosition
)
;
return
tempPosition
;
}
}
Accessible
*
Pivot
:
:
PrevText
(
Accessible
*
aAnchor
int32_t
*
aStartOffset
int32_t
*
aEndOffset
int32_t
aBoundaryType
)
{
if
(
mRoot
-
>
IsRemote
(
)
&
&
!
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
{
return
nullptr
;
}
int32_t
tempStart
=
*
aStartOffset
tempEnd
=
*
aEndOffset
;
Accessible
*
tempPosition
=
aAnchor
;
if
(
aAnchor
-
>
IsTextLeaf
(
)
&
&
aAnchor
-
>
Parent
(
)
&
&
aAnchor
-
>
Parent
(
)
-
>
IsHyperText
(
)
)
{
tempPosition
=
aAnchor
-
>
Parent
(
)
;
HyperTextAccessibleBase
*
text
=
tempPosition
-
>
AsHyperTextBase
(
)
;
int32_t
childOffset
=
text
-
>
GetChildOffset
(
aAnchor
)
;
if
(
tempStart
=
=
-
1
)
{
tempStart
=
nsAccUtils
:
:
TextLength
(
aAnchor
)
;
tempEnd
=
tempStart
;
}
tempStart
+
=
childOffset
;
tempEnd
+
=
childOffset
;
}
while
(
true
)
{
MOZ_ASSERT
(
tempPosition
)
;
Accessible
*
curPosition
=
tempPosition
;
HyperTextAccessibleBase
*
text
;
if
(
!
(
text
=
tempPosition
-
>
AsHyperTextBase
(
)
)
)
{
tempPosition
=
SearchForText
(
tempPosition
true
)
;
if
(
!
tempPosition
)
{
return
nullptr
;
}
if
(
tempPosition
!
=
curPosition
)
{
tempStart
=
tempEnd
=
-
1
;
}
text
=
tempPosition
-
>
AsHyperTextBase
(
)
;
}
if
(
tempStart
=
=
-
1
)
{
if
(
tempPosition
!
=
curPosition
&
&
tempPosition
=
=
curPosition
-
>
Parent
(
)
)
{
tempStart
=
text
-
>
GetChildOffset
(
curPosition
)
+
nsAccUtils
:
:
TextLength
(
curPosition
)
;
}
else
{
tempStart
=
text
-
>
CharacterCount
(
)
;
}
}
if
(
tempStart
=
=
0
)
{
if
(
tempPosition
=
=
mRoot
)
{
return
nullptr
;
}
Accessible
*
sibling
=
tempPosition
-
>
PrevSibling
(
)
;
if
(
tempPosition
-
>
IsLink
(
)
)
{
if
(
sibling
&
&
sibling
-
>
IsLink
(
)
)
{
HyperTextAccessibleBase
*
siblingText
=
sibling
-
>
AsHyperTextBase
(
)
;
tempStart
=
tempEnd
=
siblingText
?
siblingText
-
>
CharacterCount
(
)
:
-
1
;
tempPosition
=
sibling
;
}
else
{
tempStart
=
tempPosition
-
>
StartOffset
(
)
;
tempEnd
=
tempPosition
-
>
EndOffset
(
)
;
tempPosition
=
tempPosition
-
>
Parent
(
)
;
}
}
else
{
tempPosition
=
SearchForText
(
tempPosition
true
)
;
if
(
!
tempPosition
)
{
return
nullptr
;
}
HyperTextAccessibleBase
*
tempText
=
tempPosition
-
>
AsHyperTextBase
(
)
;
tempStart
=
tempEnd
=
tempText
-
>
CharacterCount
(
)
;
}
continue
;
}
AccessibleTextBoundary
startBoundary
endBoundary
;
switch
(
aBoundaryType
)
{
case
nsIAccessiblePivot
:
:
CHAR_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
;
break
;
case
nsIAccessiblePivot
:
:
WORD_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_START
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_END
;
break
;
case
nsIAccessiblePivot
:
:
LINE_BOUNDARY
:
startBoundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_START
;
endBoundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_END
;
break
;
default
:
return
nullptr
;
}
nsAutoString
unusedText
;
int32_t
newStart
=
0
newEnd
=
0
currentStart
=
tempStart
potentialEnd
=
0
;
text
-
>
TextBeforeOffset
(
tempStart
startBoundary
&
newStart
&
newEnd
unusedText
)
;
if
(
newStart
<
tempStart
)
{
tempStart
=
newEnd
>
=
currentStart
?
newStart
:
newEnd
;
}
else
{
text
-
>
TextBeforeOffset
(
tempStart
-
1
startBoundary
&
newStart
&
tempStart
unusedText
)
;
}
text
-
>
TextAtOffset
(
tempStart
endBoundary
&
newStart
&
potentialEnd
unusedText
)
;
tempEnd
=
potentialEnd
<
tempEnd
?
potentialEnd
:
currentStart
;
Accessible
*
childAtOffset
=
nullptr
;
for
(
int32_t
i
=
tempEnd
-
1
;
i
>
=
tempStart
;
i
-
-
)
{
childAtOffset
=
text
-
>
GetChildAtOffset
(
i
)
;
if
(
childAtOffset
&
&
!
childAtOffset
-
>
IsText
(
)
)
{
tempStart
=
childAtOffset
-
>
EndOffset
(
)
;
break
;
}
}
if
(
childAtOffset
&
&
!
childAtOffset
-
>
IsText
(
)
&
&
tempEnd
=
=
static_cast
<
int32_t
>
(
childAtOffset
-
>
EndOffset
(
)
)
)
{
tempPosition
=
childAtOffset
;
tempStart
=
tempEnd
=
static_cast
<
int32_t
>
(
childAtOffset
-
>
AsHyperTextBase
(
)
-
>
CharacterCount
(
)
)
;
continue
;
}
*
aStartOffset
=
tempStart
;
*
aEndOffset
=
tempEnd
;
MOZ_ASSERT
(
tempPosition
)
;
return
tempPosition
;
}
}
Accessible
*
Pivot
:
:
AtPoint
(
int32_t
aX
int32_t
aY
PivotRule
&
aRule
)
{
Accessible
*
match
=
nullptr
;
Accessible
*
child
=
mRoot
?
mRoot
-
>
ChildAtPoint
(
aX
aY
Accessible
:
:
EWhichChildAtPoint
:
:
DeepestChild
)
:
nullptr
;
while
(
child
&
&
(
mRoot
!
=
child
)
)
{
uint16_t
filtered
=
aRule
.
Match
(
child
)
;
if
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
)
{
match
=
nullptr
;
}
if
(
(
filtered
&
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
)
&
&
!
match
)
{
LayoutDeviceIntRect
childRect
=
child
-
>
IsLocal
(
)
?
child
-
>
AsLocal
(
)
-
>
Bounds
(
)
:
child
-
>
AsRemote
(
)
-
>
Bounds
(
)
;
if
(
childRect
.
Contains
(
aX
aY
)
)
{
match
=
child
;
}
}
child
=
child
-
>
Parent
(
)
;
}
return
match
;
}
PivotRoleRule
:
:
PivotRoleRule
(
mozilla
:
:
a11y
:
:
role
aRole
)
:
mRole
(
aRole
)
mDirectDescendantsFrom
(
nullptr
)
{
}
PivotRoleRule
:
:
PivotRoleRule
(
mozilla
:
:
a11y
:
:
role
aRole
Accessible
*
aDirectDescendantsFrom
)
:
mRole
(
aRole
)
mDirectDescendantsFrom
(
aDirectDescendantsFrom
)
{
}
uint16_t
PivotRoleRule
:
:
Match
(
Accessible
*
aAcc
)
{
uint16_t
result
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
if
(
nsAccUtils
:
:
MustPrune
(
aAcc
)
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
mDirectDescendantsFrom
&
&
(
aAcc
!
=
mDirectDescendantsFrom
)
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
aAcc
&
&
aAcc
-
>
Role
(
)
=
=
mRole
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
return
result
;
}
PivotStateRule
:
:
PivotStateRule
(
uint64_t
aState
)
:
mState
(
aState
)
{
}
uint16_t
PivotStateRule
:
:
Match
(
Accessible
*
aAcc
)
{
uint16_t
result
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE
;
if
(
nsAccUtils
:
:
MustPrune
(
aAcc
)
)
{
result
|
=
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
aAcc
&
&
(
aAcc
-
>
State
(
)
&
mState
)
)
{
result
=
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
|
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
return
result
;
}
uint16_t
LocalAccInSameDocRule
:
:
Match
(
Accessible
*
aAcc
)
{
LocalAccessible
*
acc
=
aAcc
?
aAcc
-
>
AsLocal
(
)
:
nullptr
;
if
(
!
acc
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
if
(
acc
-
>
IsOuterDoc
(
)
)
{
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
|
nsIAccessibleTraversalRule
:
:
FILTER_IGNORE_SUBTREE
;
}
return
nsIAccessibleTraversalRule
:
:
FILTER_MATCH
;
}
