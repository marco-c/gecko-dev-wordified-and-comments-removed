#
ifndef
mozilla_a11y_TextRange_h__
#
define
mozilla_a11y_TextRange_h__
#
include
<
utility
>
#
include
"
nsTArray
.
h
"
class
nsRange
;
namespace
mozilla
{
namespace
dom
{
class
Selection
;
}
namespace
a11y
{
class
Accessible
;
class
LocalAccessible
;
struct
TextPoint
final
{
TextPoint
(
Accessible
*
aContainer
int32_t
aOffset
)
:
mContainer
(
aContainer
)
mOffset
(
aOffset
)
{
}
TextPoint
(
const
TextPoint
&
aPoint
)
:
mContainer
(
aPoint
.
mContainer
)
mOffset
(
aPoint
.
mOffset
)
{
}
Accessible
*
mContainer
;
int32_t
mOffset
;
bool
operator
=
=
(
const
TextPoint
&
aPoint
)
const
{
return
mContainer
=
=
aPoint
.
mContainer
&
&
mOffset
=
=
aPoint
.
mOffset
;
}
bool
operator
<
(
const
TextPoint
&
aPoint
)
const
;
int
Compare
(
const
TextPoint
&
aOther
)
const
{
if
(
*
this
=
=
aOther
)
{
return
0
;
}
if
(
*
this
<
aOther
)
{
return
-
1
;
}
return
1
;
}
}
;
class
TextRange
final
{
public
:
TextRange
(
Accessible
*
aRoot
Accessible
*
aStartContainer
int32_t
aStartOffset
Accessible
*
aEndContainer
int32_t
aEndOffset
)
;
TextRange
(
)
:
mStartOffset
{
0
}
mEndOffset
{
0
}
{
}
TextRange
(
TextRange
&
&
aRange
)
:
mRoot
(
std
:
:
move
(
aRange
.
mRoot
)
)
mStartContainer
(
std
:
:
move
(
aRange
.
mStartContainer
)
)
mEndContainer
(
std
:
:
move
(
aRange
.
mEndContainer
)
)
mStartOffset
(
aRange
.
mStartOffset
)
mEndOffset
(
aRange
.
mEndOffset
)
{
}
TextRange
&
operator
=
(
TextRange
&
&
aRange
)
{
mRoot
=
std
:
:
move
(
aRange
.
mRoot
)
;
mStartContainer
=
std
:
:
move
(
aRange
.
mStartContainer
)
;
mEndContainer
=
std
:
:
move
(
aRange
.
mEndContainer
)
;
mStartOffset
=
aRange
.
mStartOffset
;
mEndOffset
=
aRange
.
mEndOffset
;
return
*
this
;
}
Accessible
*
Root
(
)
{
return
mRoot
;
}
Accessible
*
StartContainer
(
)
const
{
return
mStartContainer
;
}
int32_t
StartOffset
(
)
const
{
return
mStartOffset
;
}
Accessible
*
EndContainer
(
)
const
{
return
mEndContainer
;
}
int32_t
EndOffset
(
)
const
{
return
mEndOffset
;
}
bool
operator
=
=
(
const
TextRange
&
aRange
)
const
{
return
mStartContainer
=
=
aRange
.
mStartContainer
&
&
mStartOffset
=
=
aRange
.
mStartOffset
&
&
mEndContainer
=
=
aRange
.
mEndContainer
&
&
mEndOffset
=
=
aRange
.
mEndOffset
;
}
TextPoint
StartPoint
(
)
const
{
return
TextPoint
(
mStartContainer
mStartOffset
)
;
}
TextPoint
EndPoint
(
)
const
{
return
TextPoint
(
mEndContainer
mEndOffset
)
;
}
Accessible
*
Container
(
)
const
;
bool
Crop
(
Accessible
*
aContainer
)
;
bool
AssignDOMRange
(
nsRange
*
aRange
bool
*
aReversed
=
nullptr
)
const
;
bool
IsValid
(
)
const
{
return
mRoot
;
}
void
SetStartPoint
(
Accessible
*
aContainer
int32_t
aOffset
)
{
mStartContainer
=
aContainer
;
mStartOffset
=
aOffset
;
}
void
SetEndPoint
(
Accessible
*
aContainer
int32_t
aOffset
)
{
mStartContainer
=
aContainer
;
mStartOffset
=
aOffset
;
}
static
void
TextRangesFromSelection
(
dom
:
:
Selection
*
aSelection
nsTArray
<
TextRange
>
*
aRanges
)
;
private
:
TextRange
(
const
TextRange
&
aRange
)
=
delete
;
TextRange
&
operator
=
(
const
TextRange
&
aRange
)
=
delete
;
friend
class
HyperTextAccessible
;
friend
class
xpcAccessibleTextRange
;
void
Set
(
Accessible
*
aRoot
Accessible
*
aStartContainer
int32_t
aStartOffset
Accessible
*
aEndContainer
int32_t
aEndOffset
)
;
Accessible
*
CommonParent
(
Accessible
*
aAcc1
Accessible
*
aAcc2
nsTArray
<
Accessible
*
>
*
aParents1
uint32_t
*
aPos1
nsTArray
<
Accessible
*
>
*
aParents2
uint32_t
*
aPos2
)
const
;
Accessible
*
mRoot
;
Accessible
*
mStartContainer
;
Accessible
*
mEndContainer
;
int32_t
mStartOffset
;
int32_t
mEndOffset
;
}
;
}
}
#
endif
