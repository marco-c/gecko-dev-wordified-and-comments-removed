#
ifndef
mozilla_a11y_TextRange_h__
#
define
mozilla_a11y_TextRange_h__
#
include
<
utility
>
#
include
"
nsTArray
.
h
"
class
nsRange
;
namespace
mozilla
{
namespace
dom
{
class
Selection
;
}
namespace
a11y
{
class
LocalAccessible
;
class
HyperTextAccessible
;
struct
TextPoint
final
{
TextPoint
(
HyperTextAccessible
*
aContainer
int32_t
aOffset
)
:
mContainer
(
aContainer
)
mOffset
(
aOffset
)
{
}
TextPoint
(
const
TextPoint
&
aPoint
)
:
mContainer
(
aPoint
.
mContainer
)
mOffset
(
aPoint
.
mOffset
)
{
}
HyperTextAccessible
*
mContainer
;
int32_t
mOffset
;
bool
operator
=
=
(
const
TextPoint
&
aPoint
)
const
{
return
mContainer
=
=
aPoint
.
mContainer
&
&
mOffset
=
=
aPoint
.
mOffset
;
}
bool
operator
<
(
const
TextPoint
&
aPoint
)
const
;
}
;
class
TextRange
final
{
public
:
TextRange
(
HyperTextAccessible
*
aRoot
HyperTextAccessible
*
aStartContainer
int32_t
aStartOffset
HyperTextAccessible
*
aEndContainer
int32_t
aEndOffset
)
;
TextRange
(
)
:
mStartOffset
{
0
}
mEndOffset
{
0
}
{
}
TextRange
(
TextRange
&
&
aRange
)
:
mRoot
(
std
:
:
move
(
aRange
.
mRoot
)
)
mStartContainer
(
std
:
:
move
(
aRange
.
mStartContainer
)
)
mEndContainer
(
std
:
:
move
(
aRange
.
mEndContainer
)
)
mStartOffset
(
aRange
.
mStartOffset
)
mEndOffset
(
aRange
.
mEndOffset
)
{
}
TextRange
&
operator
=
(
TextRange
&
&
aRange
)
{
mRoot
=
std
:
:
move
(
aRange
.
mRoot
)
;
mStartContainer
=
std
:
:
move
(
aRange
.
mStartContainer
)
;
mEndContainer
=
std
:
:
move
(
aRange
.
mEndContainer
)
;
mStartOffset
=
aRange
.
mStartOffset
;
mEndOffset
=
aRange
.
mEndOffset
;
return
*
this
;
}
HyperTextAccessible
*
StartContainer
(
)
const
{
return
mStartContainer
;
}
int32_t
StartOffset
(
)
const
{
return
mStartOffset
;
}
HyperTextAccessible
*
EndContainer
(
)
const
{
return
mEndContainer
;
}
int32_t
EndOffset
(
)
const
{
return
mEndOffset
;
}
bool
operator
=
=
(
const
TextRange
&
aRange
)
const
{
return
mStartContainer
=
=
aRange
.
mStartContainer
&
&
mStartOffset
=
=
aRange
.
mStartOffset
&
&
mEndContainer
=
=
aRange
.
mEndContainer
&
&
mEndOffset
=
=
aRange
.
mEndOffset
;
}
TextPoint
StartPoint
(
)
const
{
return
TextPoint
(
mStartContainer
mStartOffset
)
;
}
TextPoint
EndPoint
(
)
const
{
return
TextPoint
(
mEndContainer
mEndOffset
)
;
}
LocalAccessible
*
Container
(
)
const
;
void
EmbeddedChildren
(
nsTArray
<
LocalAccessible
*
>
*
aChildren
)
const
;
void
Text
(
nsAString
&
aText
)
const
;
bool
Crop
(
LocalAccessible
*
aContainer
)
;
MOZ_CAN_RUN_SCRIPT
bool
SetSelectionAt
(
int32_t
aSelectionNum
)
const
;
void
ScrollIntoView
(
uint32_t
aScrollType
)
const
;
bool
AssignDOMRange
(
nsRange
*
aRange
bool
*
aReversed
=
nullptr
)
const
;
bool
IsValid
(
)
const
{
return
mRoot
;
}
void
SetStartPoint
(
HyperTextAccessible
*
aContainer
int32_t
aOffset
)
{
mStartContainer
=
aContainer
;
mStartOffset
=
aOffset
;
}
void
SetEndPoint
(
HyperTextAccessible
*
aContainer
int32_t
aOffset
)
{
mStartContainer
=
aContainer
;
mStartOffset
=
aOffset
;
}
static
void
TextRangesFromSelection
(
dom
:
:
Selection
*
aSelection
nsTArray
<
TextRange
>
*
aRanges
)
;
private
:
TextRange
(
const
TextRange
&
aRange
)
=
delete
;
TextRange
&
operator
=
(
const
TextRange
&
aRange
)
=
delete
;
friend
class
HyperTextAccessible
;
friend
class
xpcAccessibleTextRange
;
void
Set
(
HyperTextAccessible
*
aRoot
HyperTextAccessible
*
aStartContainer
int32_t
aStartOffset
HyperTextAccessible
*
aEndContainer
int32_t
aEndOffset
)
;
bool
TextInternal
(
nsAString
&
aText
LocalAccessible
*
aCurrent
uint32_t
aStartIntlOffset
)
const
;
LocalAccessible
*
CommonParent
(
LocalAccessible
*
aAcc1
LocalAccessible
*
aAcc2
nsTArray
<
LocalAccessible
*
>
*
aParents1
uint32_t
*
aPos1
nsTArray
<
LocalAccessible
*
>
*
aParents2
uint32_t
*
aPos2
)
const
;
RefPtr
<
HyperTextAccessible
>
mRoot
;
RefPtr
<
HyperTextAccessible
>
mStartContainer
;
RefPtr
<
HyperTextAccessible
>
mEndContainer
;
int32_t
mStartOffset
;
int32_t
mEndOffset
;
}
;
}
}
#
endif
