#
ifndef
mozilla_a11y_relation_h_
#
define
mozilla_a11y_relation_h_
#
include
"
AccIterator
.
h
"
#
include
<
memory
>
namespace
mozilla
{
namespace
a11y
{
class
Relation
{
public
:
Relation
(
)
:
mFirstIter
(
nullptr
)
mLastIter
(
nullptr
)
{
}
explicit
Relation
(
AccIterable
*
aIter
)
:
mFirstIter
(
aIter
)
mLastIter
(
aIter
)
{
}
explicit
Relation
(
Accessible
*
aAcc
)
:
mFirstIter
(
nullptr
)
mLastIter
(
nullptr
)
{
AppendTarget
(
aAcc
)
;
}
Relation
(
DocAccessible
*
aDocument
nsIContent
*
aContent
)
:
mFirstIter
(
nullptr
)
mLastIter
(
nullptr
)
{
AppendTarget
(
aDocument
aContent
)
;
}
Relation
(
Relation
&
&
aOther
)
:
mFirstIter
(
std
:
:
move
(
aOther
.
mFirstIter
)
)
mLastIter
(
aOther
.
mLastIter
)
{
aOther
.
mLastIter
=
nullptr
;
}
Relation
&
operator
=
(
Relation
&
&
aRH
)
{
mFirstIter
=
std
:
:
move
(
aRH
.
mFirstIter
)
;
mLastIter
=
aRH
.
mLastIter
;
aRH
.
mLastIter
=
nullptr
;
return
*
this
;
}
inline
void
AppendIter
(
AccIterable
*
aIter
)
{
if
(
mLastIter
)
{
mLastIter
-
>
mNextIter
.
reset
(
aIter
)
;
}
else
{
mFirstIter
.
reset
(
aIter
)
;
}
mLastIter
=
aIter
;
}
inline
void
AppendTarget
(
Accessible
*
aAcc
)
{
if
(
aAcc
)
AppendIter
(
new
SingleAccIterator
(
aAcc
)
)
;
}
void
AppendTarget
(
DocAccessible
*
aDocument
nsIContent
*
aContent
)
{
if
(
aContent
)
AppendTarget
(
aDocument
-
>
GetAccessible
(
aContent
)
)
;
}
inline
Accessible
*
Next
(
)
{
Accessible
*
target
=
nullptr
;
while
(
mFirstIter
&
&
!
(
target
=
mFirstIter
-
>
Next
(
)
)
)
{
mFirstIter
=
std
:
:
move
(
mFirstIter
-
>
mNextIter
)
;
}
if
(
!
mFirstIter
)
mLastIter
=
nullptr
;
return
target
;
}
inline
LocalAccessible
*
LocalNext
(
)
{
Accessible
*
next
=
Next
(
)
;
return
next
?
next
-
>
AsLocal
(
)
:
nullptr
;
}
private
:
Relation
&
operator
=
(
const
Relation
&
)
=
delete
;
Relation
(
const
Relation
&
)
=
delete
;
std
:
:
unique_ptr
<
AccIterable
>
mFirstIter
;
AccIterable
*
mLastIter
;
}
;
}
}
#
endif
