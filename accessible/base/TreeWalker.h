#
ifndef
mozilla_a11y_TreeWalker_h_
#
define
mozilla_a11y_TreeWalker_h_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
nsCOMPtr
.
h
"
class
nsIContent
;
namespace
mozilla
{
namespace
a11y
{
class
LocalAccessible
;
class
DocAccessible
;
class
TreeWalker
final
{
public
:
enum
{
eWalkCache
=
1
eWalkContextTree
=
2
|
eWalkCache
eScoped
=
4
}
;
explicit
TreeWalker
(
LocalAccessible
*
aContext
)
;
TreeWalker
(
LocalAccessible
*
aContext
nsIContent
*
aAnchorNode
uint32_t
aFlags
=
eWalkCache
)
;
TreeWalker
(
DocAccessible
*
aDocument
nsIContent
*
aAnchorNode
)
;
~
TreeWalker
(
)
;
LocalAccessible
*
Scope
(
nsIContent
*
aAnchorNode
)
;
void
Reset
(
)
{
mPhase
=
eAtStart
;
mStateStack
.
Clear
(
)
;
mARIAOwnsIdx
=
0
;
}
bool
Seek
(
nsIContent
*
aChildNode
)
;
LocalAccessible
*
Next
(
)
;
LocalAccessible
*
Prev
(
)
;
LocalAccessible
*
Context
(
)
const
{
return
mContext
;
}
DocAccessible
*
Document
(
)
const
{
return
mDoc
;
}
private
:
TreeWalker
(
)
;
TreeWalker
(
const
TreeWalker
&
)
;
TreeWalker
&
operator
=
(
const
TreeWalker
&
)
;
LocalAccessible
*
AccessibleFor
(
nsIContent
*
aNode
uint32_t
aFlags
bool
*
aSkipSubtree
)
;
dom
:
:
AllChildrenIterator
*
PushState
(
nsIContent
*
aContent
bool
aStartAtBeginning
)
{
return
mStateStack
.
AppendElement
(
dom
:
:
AllChildrenIterator
(
aContent
mChildFilter
aStartAtBeginning
)
)
;
}
dom
:
:
AllChildrenIterator
*
PrependState
(
nsIContent
*
aContent
bool
aStartAtBeginning
)
{
return
mStateStack
.
InsertElementAt
(
0
dom
:
:
AllChildrenIterator
(
aContent
mChildFilter
aStartAtBeginning
)
)
;
}
dom
:
:
AllChildrenIterator
*
PopState
(
)
;
DocAccessible
*
mDoc
;
LocalAccessible
*
mContext
;
nsIContent
*
mAnchorNode
;
AutoTArray
<
dom
:
:
AllChildrenIterator
20
>
mStateStack
;
uint32_t
mARIAOwnsIdx
;
int32_t
mChildFilter
;
uint32_t
mFlags
;
enum
Phase
{
eAtStart
eAtDOM
eAtARIAOwns
eAtEnd
}
;
Phase
mPhase
;
}
;
}
}
#
endif
