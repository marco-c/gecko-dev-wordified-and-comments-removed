#
ifndef
MOZILLA_A11Y_ProxyWrappers_h
#
define
MOZILLA_A11Y_ProxyWrappers_h
#
include
"
HyperTextAccessible
.
h
"
namespace
mozilla
{
namespace
a11y
{
class
ProxyAccessibleWrap
:
public
AccessibleWrap
{
public
:
ProxyAccessibleWrap
(
ProxyAccessible
*
aProxy
)
:
AccessibleWrap
(
nullptr
nullptr
)
{
mType
=
eProxyType
;
mBits
.
proxy
=
aProxy
;
}
virtual
void
Shutdown
(
)
override
{
mBits
.
proxy
=
nullptr
;
mStateFlags
|
=
eIsDefunct
;
}
}
;
class
HyperTextProxyAccessibleWrap
:
public
HyperTextAccessibleWrap
{
public
:
HyperTextProxyAccessibleWrap
(
ProxyAccessible
*
aProxy
)
:
HyperTextAccessibleWrap
(
nullptr
nullptr
)
{
mType
=
eProxyType
;
mBits
.
proxy
=
aProxy
;
}
virtual
void
Shutdown
(
)
override
{
mBits
.
proxy
=
nullptr
;
mStateFlags
|
=
eIsDefunct
;
}
}
;
class
DocProxyAccessibleWrap
:
public
HyperTextProxyAccessibleWrap
{
public
:
DocProxyAccessibleWrap
(
ProxyAccessible
*
aProxy
)
:
HyperTextProxyAccessibleWrap
(
aProxy
)
{
mGenericTypes
|
=
eDocument
;
}
void
AddID
(
uint32_t
aID
AccessibleWrap
*
aAcc
)
{
mIDToAccessibleMap
.
Put
(
aID
aAcc
)
;
}
void
RemoveID
(
uint32_t
aID
)
{
mIDToAccessibleMap
.
Remove
(
aID
)
;
}
AccessibleWrap
*
GetAccessibleByID
(
uint32_t
aID
)
const
{
return
mIDToAccessibleMap
.
Get
(
aID
)
;
}
private
:
nsDataHashtable
<
nsUint32HashKey
AccessibleWrap
*
>
mIDToAccessibleMap
;
}
;
template
<
typename
T
>
inline
ProxyAccessible
*
HyperTextProxyFor
(
T
*
aWrapper
)
{
static_assert
(
mozilla
:
:
IsBaseOf
<
IUnknown
T
>
:
:
value
"
only
IAccessible
*
should
be
passed
in
"
)
;
auto
wrapper
=
static_cast
<
HyperTextProxyAccessibleWrap
*
>
(
aWrapper
)
;
return
wrapper
-
>
IsProxy
(
)
?
wrapper
-
>
Proxy
(
)
:
nullptr
;
}
}
}
#
endif
