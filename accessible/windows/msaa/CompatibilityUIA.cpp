#
include
"
Compatibility
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsWinUtils
.
h
"
#
include
"
NtUndoc
.
h
"
#
if
defined
(
UIA_LOGGING
)
#
define
LOG_ERROR
(
FuncName
)
\
{
\
DWORD
err
=
:
:
GetLastError
(
)
;
\
nsPrintfCString
msg
(
#
FuncName
"
failed
with
code
%
u
\
n
"
err
)
;
\
:
:
OutputDebugStringA
(
msg
.
get
(
)
)
;
\
}
#
else
#
define
LOG_ERROR
(
FuncName
)
#
endif
static
bool
GetLocalObjectHandle
(
DWORD
aSrcPid
HANDLE
aSrcHandle
nsAutoHandle
&
aProcess
nsAutoHandle
&
aLocal
)
{
aLocal
.
reset
(
)
;
if
(
!
aProcess
)
{
HANDLE
rawProcess
=
:
:
OpenProcess
(
PROCESS_DUP_HANDLE
FALSE
aSrcPid
)
;
if
(
!
rawProcess
)
{
LOG_ERROR
(
OpenProcess
)
;
return
false
;
}
aProcess
.
own
(
rawProcess
)
;
}
HANDLE
rawDuped
;
if
(
!
:
:
DuplicateHandle
(
aProcess
.
get
(
)
aSrcHandle
:
:
GetCurrentProcess
(
)
&
rawDuped
GENERIC_READ
FALSE
0
)
)
{
LOG_ERROR
(
DuplicateHandle
)
;
return
false
;
}
aLocal
.
own
(
rawDuped
)
;
return
true
;
}
namespace
mozilla
{
namespace
a11y
{
Maybe
<
DWORD
>
Compatibility
:
:
sUiaRemotePid
;
Maybe
<
bool
>
Compatibility
:
:
OnUIAMessage
(
WPARAM
aWParam
LPARAM
aLParam
)
{
Maybe
<
DWORD
>
&
remotePid
=
sUiaRemotePid
;
auto
clearUiaRemotePid
=
MakeScopeExit
(
[
&
remotePid
]
(
)
{
remotePid
=
Nothing
(
)
;
}
)
;
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
A11Y_UIA_DETECTION_TIMING_MS
>
timer
;
static
auto
pNtQuerySystemInformation
=
reinterpret_cast
<
decltype
(
&
:
:
NtQuerySystemInformation
)
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandleW
(
L
"
ntdll
.
dll
"
)
"
NtQuerySystemInformation
"
)
)
;
static
auto
pNtQueryObject
=
reinterpret_cast
<
decltype
(
&
:
:
NtQueryObject
)
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandleW
(
L
"
ntdll
.
dll
"
)
"
NtQueryObject
"
)
)
;
NS_NAMED_LITERAL_STRING
(
kStrHookShmem
"
HOOK_SHMEM_
"
)
;
nsAutoString
partialSectionSuffix
;
partialSectionSuffix
.
AppendPrintf
(
"
_
%
08x_
%
08x_
%
08x
"
:
:
GetCurrentThreadId
(
)
aLParam
aWParam
)
;
NTSTATUS
ntStatus
;
UniquePtr
<
char
[
]
>
handleInfoBuf
;
ULONG
handleInfoBufLen
=
sizeof
(
SYSTEM_HANDLE_INFORMATION_EX
)
+
1024
*
sizeof
(
SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
)
;
while
(
true
)
{
handleInfoBuf
=
MakeUnique
<
char
[
]
>
(
handleInfoBufLen
)
;
ntStatus
=
pNtQuerySystemInformation
(
(
SYSTEM_INFORMATION_CLASS
)
SystemExtendedHandleInformation
handleInfoBuf
.
get
(
)
handleInfoBufLen
&
handleInfoBufLen
)
;
if
(
ntStatus
=
=
STATUS_INFO_LENGTH_MISMATCH
)
{
continue
;
}
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
return
Nothing
(
)
;
}
break
;
}
static
Maybe
<
USHORT
>
sSectionObjTypeIndex
;
const
DWORD
ourPid
=
:
:
GetCurrentProcessId
(
)
;
Maybe
<
PVOID
>
kernelObject
;
ULONG
lastPid
=
0
;
nsAutoHandle
process
;
auto
handleInfo
=
reinterpret_cast
<
SYSTEM_HANDLE_INFORMATION_EX
*
>
(
handleInfoBuf
.
get
(
)
)
;
for
(
ULONG
index
=
0
;
index
<
handleInfo
-
>
mHandleCount
;
+
+
index
)
{
SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
&
curHandle
=
handleInfo
-
>
mHandles
[
index
]
;
if
(
lastPid
&
&
lastPid
=
=
curHandle
.
mPid
&
&
!
process
)
{
continue
;
}
if
(
lastPid
!
=
curHandle
.
mPid
)
{
process
.
reset
(
)
;
}
nsAutoHandle
handle
;
if
(
kernelObject
.
isSome
(
)
&
&
kernelObject
.
value
(
)
=
=
curHandle
.
mObject
)
{
remotePid
=
Some
(
static_cast
<
DWORD
>
(
curHandle
.
mPid
)
)
;
break
;
}
else
if
(
sSectionObjTypeIndex
.
isSome
(
)
)
{
if
(
curHandle
.
mObjectTypeIndex
!
=
sSectionObjTypeIndex
.
value
(
)
)
{
continue
;
}
}
else
{
lastPid
=
curHandle
.
mPid
;
if
(
!
GetLocalObjectHandle
(
(
DWORD
)
curHandle
.
mPid
(
HANDLE
)
curHandle
.
mHandle
process
handle
)
)
{
continue
;
}
ULONG
objTypeBufLen
;
ntStatus
=
pNtQueryObject
(
handle
ObjectTypeInformation
nullptr
0
&
objTypeBufLen
)
;
if
(
ntStatus
!
=
STATUS_INFO_LENGTH_MISMATCH
)
{
continue
;
}
auto
objTypeBuf
=
MakeUnique
<
char
[
]
>
(
objTypeBufLen
)
;
ntStatus
=
pNtQueryObject
(
handle
ObjectTypeInformation
objTypeBuf
.
get
(
)
objTypeBufLen
&
objTypeBufLen
)
;
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
continue
;
}
auto
objType
=
reinterpret_cast
<
PUBLIC_OBJECT_TYPE_INFORMATION
*
>
(
objTypeBuf
.
get
(
)
)
;
nsDependentString
objTypeName
(
objType
-
>
TypeName
.
Buffer
objType
-
>
TypeName
.
Length
/
sizeof
(
wchar_t
)
)
;
if
(
!
objTypeName
.
Equals
(
NS_LITERAL_STRING
(
"
Section
"
)
)
)
{
continue
;
}
sSectionObjTypeIndex
=
Some
(
curHandle
.
mObjectTypeIndex
)
;
}
lastPid
=
curHandle
.
mPid
;
if
(
(
!
process
|
|
!
handle
)
&
&
!
GetLocalObjectHandle
(
(
DWORD
)
curHandle
.
mPid
(
HANDLE
)
curHandle
.
mHandle
process
handle
)
)
{
continue
;
}
ULONG
objNameBufLen
;
ntStatus
=
pNtQueryObject
(
handle
(
OBJECT_INFORMATION_CLASS
)
ObjectNameInformation
nullptr
0
&
objNameBufLen
)
;
if
(
ntStatus
!
=
STATUS_INFO_LENGTH_MISMATCH
)
{
continue
;
}
auto
objNameBuf
=
MakeUnique
<
char
[
]
>
(
objNameBufLen
)
;
ntStatus
=
pNtQueryObject
(
handle
(
OBJECT_INFORMATION_CLASS
)
ObjectNameInformation
objNameBuf
.
get
(
)
objNameBufLen
&
objNameBufLen
)
;
if
(
!
NT_SUCCESS
(
ntStatus
)
)
{
continue
;
}
auto
objNameInfo
=
reinterpret_cast
<
OBJECT_NAME_INFORMATION
*
>
(
objNameBuf
.
get
(
)
)
;
if
(
!
objNameInfo
-
>
mName
.
Length
)
{
continue
;
}
nsDependentString
objName
(
objNameInfo
-
>
mName
.
Buffer
objNameInfo
-
>
mName
.
Length
/
sizeof
(
wchar_t
)
)
;
if
(
!
FindInReadable
(
kStrHookShmem
objName
)
|
|
!
StringEndsWith
(
objName
partialSectionSuffix
)
)
{
continue
;
}
if
(
curHandle
.
mPid
=
=
ourPid
)
{
kernelObject
=
Some
(
curHandle
.
mObject
)
;
continue
;
}
remotePid
=
Some
(
static_cast
<
DWORD
>
(
curHandle
.
mPid
)
)
;
break
;
}
if
(
!
remotePid
)
{
return
Nothing
(
)
;
}
a11y
:
:
SetInstantiator
(
remotePid
.
value
(
)
)
;
return
Some
(
true
)
;
}
}
}
