#
include
"
EnumVariant
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
IMPL_IUNKNOWN_QUERY_HEAD
(
ChildrenEnumVariant
)
IMPL_IUNKNOWN_QUERY_IFACE
(
IEnumVARIANT
)
IMPL_IUNKNOWN_QUERY_TAIL_AGGREGATED
(
mAnchorAcc
)
STDMETHODIMP
ChildrenEnumVariant
:
:
Next
(
ULONG
aCount
VARIANT
FAR
*
aItems
ULONG
FAR
*
aCountFetched
)
{
if
(
!
aItems
|
|
!
aCountFetched
)
return
E_INVALIDARG
;
*
aCountFetched
=
0
;
if
(
mAnchorAcc
-
>
IsDefunct
(
)
|
|
mAnchorAcc
-
>
LocalChildAt
(
mCurIndex
)
!
=
mCurAcc
)
return
CO_E_OBJNOTCONNECTED
;
ULONG
countFetched
=
0
;
while
(
mCurAcc
&
&
countFetched
<
aCount
)
{
VariantInit
(
aItems
+
countFetched
)
;
IDispatch
*
accNative
=
AccessibleWrap
:
:
NativeAccessible
(
mCurAcc
)
;
+
+
mCurIndex
;
mCurAcc
=
mAnchorAcc
-
>
LocalChildAt
(
mCurIndex
)
;
MOZ_ASSERT
(
accNative
)
;
if
(
!
accNative
)
{
continue
;
}
aItems
[
countFetched
]
.
pdispVal
=
accNative
;
aItems
[
countFetched
]
.
vt
=
VT_DISPATCH
;
+
+
countFetched
;
}
(
*
aCountFetched
)
=
countFetched
;
return
countFetched
<
aCount
?
S_FALSE
:
S_OK
;
}
STDMETHODIMP
ChildrenEnumVariant
:
:
Skip
(
ULONG
aCount
)
{
if
(
mAnchorAcc
-
>
IsDefunct
(
)
|
|
mAnchorAcc
-
>
LocalChildAt
(
mCurIndex
)
!
=
mCurAcc
)
return
CO_E_OBJNOTCONNECTED
;
mCurIndex
+
=
aCount
;
mCurAcc
=
mAnchorAcc
-
>
LocalChildAt
(
mCurIndex
)
;
return
mCurAcc
?
S_OK
:
S_FALSE
;
}
STDMETHODIMP
ChildrenEnumVariant
:
:
Reset
(
)
{
if
(
mAnchorAcc
-
>
IsDefunct
(
)
)
return
CO_E_OBJNOTCONNECTED
;
mCurIndex
=
0
;
mCurAcc
=
mAnchorAcc
-
>
LocalChildAt
(
0
)
;
return
S_OK
;
}
STDMETHODIMP
ChildrenEnumVariant
:
:
Clone
(
IEnumVARIANT
*
*
aEnumVariant
)
{
if
(
!
aEnumVariant
)
return
E_INVALIDARG
;
*
aEnumVariant
=
new
ChildrenEnumVariant
(
*
this
)
;
(
*
aEnumVariant
)
-
>
AddRef
(
)
;
return
S_OK
;
}
