#
include
"
EnumVariant
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
IMPL_IUNKNOWN_QUERY_HEAD
(
ChildrenEnumVariant
)
IMPL_IUNKNOWN_QUERY_IFACE
(
IEnumVARIANT
)
IMPL_IUNKNOWN_QUERY_TAIL_AGGREGATED
(
mAnchorMsaa
)
STDMETHODIMP
ChildrenEnumVariant
:
:
Next
(
ULONG
aCount
VARIANT
FAR
*
aItems
ULONG
FAR
*
aCountFetched
)
{
if
(
!
aItems
|
|
!
aCountFetched
)
return
E_INVALIDARG
;
*
aCountFetched
=
0
;
Accessible
*
anchor
=
mAnchorMsaa
-
>
Acc
(
)
;
if
(
!
anchor
|
|
anchor
-
>
ChildAt
(
mCurIndex
)
!
=
mCurAcc
)
{
return
CO_E_OBJNOTCONNECTED
;
}
ULONG
countFetched
=
0
;
while
(
mCurAcc
&
&
countFetched
<
aCount
)
{
VariantInit
(
aItems
+
countFetched
)
;
IDispatch
*
accNative
=
MsaaAccessible
:
:
NativeAccessible
(
mCurAcc
)
;
+
+
mCurIndex
;
mCurAcc
=
anchor
-
>
ChildAt
(
mCurIndex
)
;
MOZ_ASSERT
(
accNative
)
;
if
(
!
accNative
)
{
continue
;
}
aItems
[
countFetched
]
.
pdispVal
=
accNative
;
aItems
[
countFetched
]
.
vt
=
VT_DISPATCH
;
+
+
countFetched
;
}
(
*
aCountFetched
)
=
countFetched
;
return
countFetched
<
aCount
?
S_FALSE
:
S_OK
;
}
STDMETHODIMP
ChildrenEnumVariant
:
:
Skip
(
ULONG
aCount
)
{
Accessible
*
anchor
=
mAnchorMsaa
-
>
Acc
(
)
;
if
(
!
anchor
|
|
anchor
-
>
ChildAt
(
mCurIndex
)
!
=
mCurAcc
)
{
return
CO_E_OBJNOTCONNECTED
;
}
mCurIndex
+
=
aCount
;
mCurAcc
=
anchor
-
>
ChildAt
(
mCurIndex
)
;
return
mCurAcc
?
S_OK
:
S_FALSE
;
}
STDMETHODIMP
ChildrenEnumVariant
:
:
Reset
(
)
{
Accessible
*
anchor
=
mAnchorMsaa
-
>
Acc
(
)
;
if
(
!
anchor
)
return
CO_E_OBJNOTCONNECTED
;
mCurIndex
=
0
;
mCurAcc
=
anchor
-
>
ChildAt
(
0
)
;
return
S_OK
;
}
STDMETHODIMP
ChildrenEnumVariant
:
:
Clone
(
IEnumVARIANT
*
*
aEnumVariant
)
{
if
(
!
aEnumVariant
)
return
E_INVALIDARG
;
*
aEnumVariant
=
new
ChildrenEnumVariant
(
*
this
)
;
(
*
aEnumVariant
)
-
>
AddRef
(
)
;
return
S_OK
;
}
