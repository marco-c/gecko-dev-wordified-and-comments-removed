#
include
"
HTMLWin32ObjectAccessible
.
h
"
#
include
"
Role
.
h
"
#
include
"
States
.
h
"
using
namespace
mozilla
:
:
a11y
;
HTMLWin32ObjectOwnerAccessible
:
:
HTMLWin32ObjectOwnerAccessible
(
nsIContent
*
aContent
DocAccessible
*
aDoc
void
*
aHwnd
)
:
AccessibleWrap
(
aContent
aDoc
)
mHwnd
(
aHwnd
)
{
mStateFlags
|
=
eNoKidsFromDOM
;
if
(
mHwnd
)
{
mNativeAccessible
=
new
HTMLWin32ObjectAccessible
(
mHwnd
aDoc
)
;
AppendChild
(
mNativeAccessible
)
;
}
}
void
HTMLWin32ObjectOwnerAccessible
:
:
Shutdown
(
)
{
AccessibleWrap
:
:
Shutdown
(
)
;
mNativeAccessible
=
nullptr
;
}
role
HTMLWin32ObjectOwnerAccessible
:
:
NativeRole
(
)
const
{
return
roles
:
:
EMBEDDED_OBJECT
;
}
bool
HTMLWin32ObjectOwnerAccessible
:
:
NativelyUnavailable
(
)
const
{
return
!
mHwnd
;
}
HTMLWin32ObjectAccessible
:
:
HTMLWin32ObjectAccessible
(
void
*
aHwnd
DocAccessible
*
aDoc
)
:
DummyAccessible
(
aDoc
)
{
mHwnd
=
aHwnd
;
if
(
mHwnd
)
{
#
if
defined
(
MOZ_CONTENT_SANDBOX
)
if
(
XRE_IsContentProcess
(
)
)
{
DocAccessibleChild
*
ipcDoc
=
aDoc
-
>
IPCDoc
(
)
;
MOZ_ASSERT
(
ipcDoc
)
;
if
(
!
ipcDoc
)
{
return
;
}
IAccessibleHolder
proxyHolder
;
if
(
!
ipcDoc
-
>
SendGetWindowedPluginIAccessible
(
reinterpret_cast
<
uintptr_t
>
(
mHwnd
)
&
proxyHolder
)
)
{
return
;
}
mCOMProxy
.
reset
(
proxyHolder
.
Release
(
)
)
;
return
;
}
#
endif
mHwnd
=
:
:
GetWindow
(
(
HWND
)
aHwnd
GW_CHILD
)
;
}
}
void
HTMLWin32ObjectAccessible
:
:
GetNativeInterface
(
void
*
*
aNativeAccessible
)
{
#
if
defined
(
MOZ_CONTENT_SANDBOX
)
if
(
XRE_IsContentProcess
(
)
)
{
RefPtr
<
IAccessible
>
addRefed
=
mCOMProxy
.
get
(
)
;
addRefed
.
forget
(
aNativeAccessible
)
;
return
;
}
#
endif
if
(
mHwnd
)
{
:
:
AccessibleObjectFromWindow
(
static_cast
<
HWND
>
(
mHwnd
)
OBJID_WINDOW
IID_IAccessible
aNativeAccessible
)
;
}
}
