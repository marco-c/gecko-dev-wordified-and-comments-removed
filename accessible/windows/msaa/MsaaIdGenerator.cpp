#
include
"
MsaaIdGenerator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
MsaaAccessible
.
h
"
#
include
"
nsAccessibilityService
.
h
"
namespace
mozilla
{
namespace
a11y
{
uint32_t
MsaaIdGenerator
:
:
GetID
(
)
{
if
(
!
mGetIDCalled
)
{
mGetIDCalled
=
true
;
RunOnShutdown
(
[
this
]
{
if
(
mReleaseIDTimer
)
{
mReleaseIDTimer
-
>
Cancel
(
)
;
ReleasePendingIDs
(
)
;
}
}
)
;
}
uint32_t
id
=
mIDSet
.
GetID
(
)
;
MOZ_ASSERT
(
id
<
=
(
(
1UL
<
<
kNumFullIDBits
)
-
1UL
)
)
;
return
~
id
;
}
void
MsaaIdGenerator
:
:
ReleasePendingIDs
(
)
{
for
(
auto
id
:
mIDsToRelease
)
{
mIDSet
.
ReleaseID
(
~
id
)
;
}
mIDsToRelease
.
Clear
(
)
;
mReleaseIDTimer
=
nullptr
;
}
void
MsaaIdGenerator
:
:
ReleasePendingIdsCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
MsaaIdGenerator
*
gen
=
(
MsaaIdGenerator
*
)
aClosure
;
gen
-
>
ReleasePendingIDs
(
)
;
}
bool
MsaaIdGenerator
:
:
ReleaseID
(
uint32_t
aID
)
{
MOZ_ASSERT
(
aID
!
=
MsaaAccessible
:
:
kNoID
)
;
if
(
nsAccessibilityService
:
:
IsShutdown
(
)
)
{
mIDSet
.
ReleaseID
(
~
aID
)
;
return
true
;
}
const
uint32_t
kReleaseDelay
=
1000
;
mIDsToRelease
.
AppendElement
(
aID
)
;
if
(
!
mReleaseIDTimer
)
{
mReleaseIDTimer
=
NS_NewTimer
(
)
;
}
mReleaseIDTimer
-
>
InitWithNamedFuncCallback
(
ReleasePendingIdsCallback
this
kReleaseDelay
nsITimer
:
:
TYPE_ONE_SHOT
"
a11y
:
:
MsaaIdGenerator
:
:
ReleaseIDDelayed
"
)
;
return
true
;
}
void
MsaaIdGenerator
:
:
ReleaseID
(
NotNull
<
MsaaAccessible
*
>
aMsaaAcc
)
{
ReleaseID
(
aMsaaAcc
-
>
GetExistingID
(
)
)
;
}
}
}
