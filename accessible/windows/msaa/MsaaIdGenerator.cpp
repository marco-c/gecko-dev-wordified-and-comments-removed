#
include
"
MsaaIdGenerator
.
h
"
#
include
"
mozilla
/
a11y
/
MsaaAccessible
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
sdnAccessible
.
h
"
namespace
mozilla
{
namespace
a11y
{
uint32_t
MsaaIdGenerator
:
:
GetID
(
)
{
if
(
!
mGetIDCalled
)
{
mGetIDCalled
=
true
;
RunOnShutdown
(
[
this
]
{
if
(
mReleaseIDTimer
)
{
mReleaseIDTimer
-
>
Cancel
(
)
;
ReleasePendingIDs
(
)
;
}
}
)
;
}
uint32_t
id
=
mIDSet
.
GetID
(
)
;
MOZ_ASSERT
(
id
<
=
(
(
1UL
<
<
kNumFullIDBits
)
-
1UL
)
)
;
return
~
id
;
}
void
MsaaIdGenerator
:
:
ReleasePendingIDs
(
)
{
for
(
auto
id
:
mIDsToRelease
)
{
mIDSet
.
ReleaseID
(
~
id
)
;
}
mIDsToRelease
.
Clear
(
)
;
mReleaseIDTimer
=
nullptr
;
}
bool
MsaaIdGenerator
:
:
ReleaseID
(
uint32_t
aID
)
{
MOZ_ASSERT
(
aID
!
=
MsaaAccessible
:
:
kNoID
)
;
if
(
nsAccessibilityService
:
:
IsShutdown
(
)
)
{
mIDSet
.
ReleaseID
(
~
aID
)
;
return
true
;
}
const
uint32_t
kReleaseDelay
=
1000
;
mIDsToRelease
.
AppendElement
(
aID
)
;
if
(
mReleaseIDTimer
)
{
mReleaseIDTimer
-
>
SetDelay
(
kReleaseDelay
)
;
}
else
{
NS_NewTimerWithCallback
(
getter_AddRefs
(
mReleaseIDTimer
)
[
this
]
(
nsITimer
*
aTimer
)
{
ReleasePendingIDs
(
)
;
}
kReleaseDelay
nsITimer
:
:
TYPE_ONE_SHOT
"
a11y
:
:
MsaaIdGenerator
:
:
ReleaseIDDelayed
"
)
;
}
return
true
;
}
void
MsaaIdGenerator
:
:
ReleaseID
(
NotNull
<
MsaaAccessible
*
>
aMsaaAcc
)
{
ReleaseID
(
aMsaaAcc
-
>
GetExistingID
(
)
)
;
}
void
MsaaIdGenerator
:
:
ReleaseID
(
NotNull
<
sdnAccessible
*
>
aSdnAcc
)
{
Maybe
<
uint32_t
>
id
=
aSdnAcc
-
>
ReleaseUniqueID
(
)
;
if
(
id
.
isSome
(
)
)
{
DebugOnly
<
bool
>
released
=
ReleaseID
(
id
.
value
(
)
)
;
MOZ_ASSERT
(
released
)
;
}
}
}
}
