#
include
"
Platform
.
h
"
#
include
"
AccEvent
.
h
"
#
include
"
Compatibility
.
h
"
#
include
"
MsaaAccessible
.
h
"
#
include
"
nsWinUtils
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessibleParent
.
h
"
#
include
"
mozilla
/
a11y
/
HyperTextAccessibleBase
.
h
"
#
include
"
mozilla
/
a11y
/
RemoteAccessible
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
ia2AccessibleText
.
h
"
#
include
<
tuple
>
#
if
defined
(
MOZ_TELEMETRY_REPORTING
)
#
include
"
mozilla
/
glean
/
AccessibleMetrics
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
using
namespace
mozilla
:
:
mscom
;
static
StaticRefPtr
<
nsIFile
>
gInstantiator
;
static
void
UpdateSystemCaretFor
(
Accessible
*
aAccessible
)
{
:
:
DestroyCaret
(
)
;
HyperTextAccessibleBase
*
text
=
aAccessible
-
>
AsHyperTextBase
(
)
;
if
(
!
text
)
{
return
;
}
auto
[
caretRect
widget
]
=
text
-
>
GetCaretRect
(
)
;
if
(
caretRect
.
IsEmpty
(
)
|
|
!
widget
)
{
return
;
}
HWND
caretWnd
=
reinterpret_cast
<
HWND
>
(
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
)
;
if
(
!
caretWnd
)
{
return
;
}
nsAutoBitmap
caretBitMap
(
CreateBitmap
(
1
caretRect
.
Height
(
)
1
1
nullptr
)
)
;
if
(
:
:
CreateCaret
(
caretWnd
caretBitMap
1
caretRect
.
Height
(
)
)
)
{
:
:
ShowCaret
(
caretWnd
)
;
POINT
clientPoint
{
caretRect
.
X
(
)
caretRect
.
Y
(
)
}
;
:
:
ScreenToClient
(
caretWnd
&
clientPoint
)
;
:
:
SetCaretPos
(
clientPoint
.
x
clientPoint
.
y
)
;
}
}
void
a11y
:
:
PlatformInit
(
)
{
nsWinUtils
:
:
MaybeStartWindowEmulation
(
)
;
ia2AccessibleText
:
:
InitTextChangeData
(
)
;
}
void
a11y
:
:
PlatformShutdown
(
)
{
:
:
DestroyCaret
(
)
;
nsWinUtils
:
:
ShutdownWindowEmulation
(
)
;
if
(
gInstantiator
)
{
gInstantiator
=
nullptr
;
}
}
void
a11y
:
:
ProxyCreated
(
RemoteAccessible
*
aProxy
)
{
MsaaAccessible
*
msaa
=
MsaaAccessible
:
:
Create
(
aProxy
)
;
msaa
-
>
AddRef
(
)
;
aProxy
-
>
SetWrapper
(
reinterpret_cast
<
uintptr_t
>
(
msaa
)
)
;
}
void
a11y
:
:
ProxyDestroyed
(
RemoteAccessible
*
aProxy
)
{
MsaaAccessible
*
msaa
=
reinterpret_cast
<
MsaaAccessible
*
>
(
aProxy
-
>
GetWrapper
(
)
)
;
if
(
!
msaa
)
{
return
;
}
msaa
-
>
MsaaShutdown
(
)
;
aProxy
-
>
SetWrapper
(
0
)
;
msaa
-
>
Release
(
)
;
if
(
aProxy
-
>
IsDoc
(
)
&
&
nsWinUtils
:
:
IsWindowEmulationStarted
(
)
)
{
aProxy
-
>
AsDoc
(
)
-
>
SetEmulatedWindowHandle
(
nullptr
)
;
}
}
void
a11y
:
:
PlatformEvent
(
Accessible
*
aTarget
uint32_t
aEventType
)
{
Accessible
*
msaaTarget
=
aTarget
;
if
(
aEventType
=
=
nsIAccessibleEvent
:
:
EVENT_SCROLLING_START
&
&
aTarget
-
>
IsTextLeaf
(
)
)
{
msaaTarget
=
aTarget
-
>
Parent
(
)
;
}
if
(
msaaTarget
)
{
MsaaAccessible
:
:
FireWinEvent
(
msaaTarget
aEventType
)
;
}
uiaRawElmProvider
:
:
RaiseUiaEventForGeckoEvent
(
aTarget
aEventType
)
;
}
void
a11y
:
:
PlatformStateChangeEvent
(
Accessible
*
aTarget
uint64_t
aState
bool
aEnabled
)
{
MsaaAccessible
:
:
FireWinEvent
(
aTarget
nsIAccessibleEvent
:
:
EVENT_STATE_CHANGE
)
;
uiaRawElmProvider
:
:
RaiseUiaEventForStateChange
(
aTarget
aState
aEnabled
)
;
}
void
a11y
:
:
PlatformFocusEvent
(
Accessible
*
aTarget
)
{
if
(
aTarget
-
>
IsRemote
(
)
&
&
FocusMgr
(
)
&
&
FocusMgr
(
)
-
>
FocusedLocalAccessible
(
)
)
{
return
;
}
UpdateSystemCaretFor
(
aTarget
)
;
MsaaAccessible
:
:
FireWinEvent
(
aTarget
nsIAccessibleEvent
:
:
EVENT_FOCUS
)
;
uiaRawElmProvider
:
:
RaiseUiaEventForGeckoEvent
(
aTarget
nsIAccessibleEvent
:
:
EVENT_FOCUS
)
;
}
void
a11y
:
:
PlatformCaretMoveEvent
(
Accessible
*
aTarget
int32_t
aOffset
bool
aIsSelectionCollapsed
int32_t
aGranularity
bool
aFromUser
)
{
UpdateSystemCaretFor
(
aTarget
)
;
MsaaAccessible
:
:
FireWinEvent
(
aTarget
nsIAccessibleEvent
:
:
EVENT_TEXT_CARET_MOVED
)
;
uiaRawElmProvider
:
:
RaiseUiaEventForGeckoEvent
(
aTarget
nsIAccessibleEvent
:
:
EVENT_TEXT_CARET_MOVED
)
;
}
void
a11y
:
:
PlatformTextChangeEvent
(
Accessible
*
aText
const
nsAString
&
aStr
int32_t
aStart
uint32_t
aLen
bool
aInsert
bool
)
{
uint32_t
eventType
=
aInsert
?
nsIAccessibleEvent
:
:
EVENT_TEXT_INSERTED
:
nsIAccessibleEvent
:
:
EVENT_TEXT_REMOVED
;
MOZ_ASSERT
(
aText
-
>
IsHyperText
(
)
)
;
ia2AccessibleText
:
:
UpdateTextChangeData
(
aText
-
>
AsHyperTextBase
(
)
aInsert
aStr
aStart
aLen
)
;
MsaaAccessible
:
:
FireWinEvent
(
aText
eventType
)
;
uiaRawElmProvider
:
:
RaiseUiaEventForGeckoEvent
(
aText
eventType
)
;
}
void
a11y
:
:
PlatformShowHideEvent
(
Accessible
*
aTarget
Accessible
*
bool
aInsert
bool
)
{
uint32_t
event
=
aInsert
?
nsIAccessibleEvent
:
:
EVENT_SHOW
:
nsIAccessibleEvent
:
:
EVENT_HIDE
;
MsaaAccessible
:
:
FireWinEvent
(
aTarget
event
)
;
}
void
a11y
:
:
PlatformSelectionEvent
(
Accessible
*
aTarget
Accessible
*
uint32_t
aType
)
{
MsaaAccessible
:
:
FireWinEvent
(
aTarget
aType
)
;
uiaRawElmProvider
:
:
RaiseUiaEventForGeckoEvent
(
aTarget
aType
)
;
}
static
bool
GetInstantiatorExecutable
(
const
DWORD
aPid
nsIFile
*
*
aOutClientExe
)
{
nsAutoHandle
callingProcess
(
:
:
OpenProcess
(
PROCESS_QUERY_LIMITED_INFORMATION
FALSE
aPid
)
)
;
if
(
!
callingProcess
)
{
return
false
;
}
DWORD
bufLen
=
MAX_PATH
;
UniquePtr
<
wchar_t
[
]
>
buf
;
while
(
true
)
{
buf
=
MakeUnique
<
wchar_t
[
]
>
(
bufLen
)
;
if
(
:
:
QueryFullProcessImageName
(
callingProcess
0
buf
.
get
(
)
&
bufLen
)
)
{
break
;
}
DWORD
lastError
=
:
:
GetLastError
(
)
;
MOZ_ASSERT
(
lastError
=
=
ERROR_INSUFFICIENT_BUFFER
)
;
if
(
lastError
!
=
ERROR_INSUFFICIENT_BUFFER
)
{
return
false
;
}
bufLen
*
=
2
;
}
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_NewLocalFile
(
nsDependentString
(
buf
.
get
(
)
bufLen
)
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
file
.
forget
(
aOutClientExe
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
static
void
AppendVersionInfo
(
nsIFile
*
aClientExe
nsAString
&
aStrToAppend
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
LauncherResult
<
ModuleVersion
>
version
=
GetModuleVersion
(
aClientExe
)
;
if
(
version
.
isErr
(
)
)
{
return
;
}
auto
[
major
minor
patch
build
]
=
version
.
unwrap
(
)
.
AsTuple
(
)
;
aStrToAppend
.
AppendLiteral
(
u
"
|
"
)
;
constexpr
auto
dot
=
u
"
.
"
_ns
;
aStrToAppend
.
AppendInt
(
major
)
;
aStrToAppend
.
Append
(
dot
)
;
aStrToAppend
.
AppendInt
(
minor
)
;
aStrToAppend
.
Append
(
dot
)
;
aStrToAppend
.
AppendInt
(
patch
)
;
aStrToAppend
.
Append
(
dot
)
;
aStrToAppend
.
AppendInt
(
build
)
;
}
static
void
AccumulateInstantiatorTelemetry
(
const
nsAString
&
aValue
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
aValue
.
IsEmpty
(
)
)
{
#
if
defined
(
MOZ_TELEMETRY_REPORTING
)
glean
:
:
a11y
:
:
instantiators
.
Set
(
NS_ConvertUTF16toUTF8
(
aValue
)
)
;
#
endif
CrashReporter
:
:
RecordAnnotationNSString
(
CrashReporter
:
:
Annotation
:
:
AccessibilityClient
aValue
)
;
}
}
static
void
GatherInstantiatorTelemetry
(
nsIFile
*
aClientExe
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsString
value
;
nsresult
rv
=
aClientExe
-
>
GetLeafName
(
value
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
AppendVersionInfo
(
aClientExe
value
)
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
a11y
:
:
AccumulateInstantiatorTelemetry
"
[
value
=
std
:
:
move
(
value
)
]
(
)
-
>
void
{
AccumulateInstantiatorTelemetry
(
value
)
;
}
)
)
;
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
void
a11y
:
:
SetInstantiator
(
const
uint32_t
aPid
)
{
nsCOMPtr
<
nsIFile
>
clientExe
;
if
(
!
GetInstantiatorExecutable
(
aPid
getter_AddRefs
(
clientExe
)
)
)
{
AccumulateInstantiatorTelemetry
(
u
"
(
Failed
to
retrieve
client
image
name
)
"
_ns
)
;
return
;
}
if
(
gInstantiator
)
{
bool
equal
;
nsresult
rv
=
gInstantiator
-
>
Equals
(
clientExe
&
equal
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
equal
)
{
return
;
}
}
gInstantiator
=
clientExe
;
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
a11y
:
:
GatherInstantiatorTelemetry
"
[
clientExe
=
std
:
:
move
(
clientExe
)
]
(
)
-
>
void
{
GatherInstantiatorTelemetry
(
clientExe
)
;
}
)
)
;
DebugOnly
<
nsresult
>
rv
=
NS_DispatchBackgroundTask
(
runnable
.
forget
(
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
bool
a11y
:
:
GetInstantiator
(
nsIFile
*
*
aOutInstantiator
)
{
if
(
!
gInstantiator
)
{
return
false
;
}
return
NS_SUCCEEDED
(
gInstantiator
-
>
Clone
(
aOutInstantiator
)
)
;
}
uint64_t
a11y
:
:
GetCacheDomainsForKnownClients
(
uint64_t
aCacheDomains
)
{
if
(
Compatibility
:
:
IsKnownScreenReader
(
)
)
{
return
CacheDomain
:
:
All
;
}
return
aCacheDomains
;
}
