#
ifndef
mozilla_a11y_AccessibleWrap_h_
#
define
mozilla_a11y_AccessibleWrap_h_
#
include
"
nsCOMPtr
.
h
"
#
include
"
LocalAccessible
.
h
"
#
include
"
MsaaAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
AccessibleHandler
.
h
"
#
include
"
mozilla
/
a11y
/
RemoteAccessible
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
mscom
/
Utils
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
Units
.
h
"
#
if
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
#
pragma
GCC
diagnostic
ignored
"
-
Woverloaded
-
virtual
"
#
endif
namespace
mozilla
{
namespace
a11y
{
class
DocRemoteAccessibleWrap
;
class
AccessibleWrap
:
public
LocalAccessible
public
MsaaAccessible
{
public
:
AccessibleWrap
(
nsIContent
*
aContent
DocAccessible
*
aDoc
)
;
NS_DECL_ISUPPORTS_INHERITED
public
:
STDMETHODIMP
QueryInterface
(
REFIID
void
*
*
)
override
;
virtual
nsresult
HandleAccEvent
(
AccEvent
*
aEvent
)
override
;
virtual
void
Shutdown
(
)
override
;
void
UpdateSystemCaretFor
(
LocalAccessible
*
aAccessible
)
;
static
void
UpdateSystemCaretFor
(
RemoteAccessible
*
aProxy
const
LayoutDeviceIntRect
&
aCaretRect
)
;
private
:
static
void
UpdateSystemCaretFor
(
HWND
aCaretWnd
const
LayoutDeviceIntRect
&
aCaretRect
)
;
public
:
bool
IsRootForHWND
(
)
;
MsaaAccessible
*
GetMsaa
(
)
{
return
this
;
}
virtual
void
GetNativeInterface
(
void
*
*
aOutAccessible
)
override
;
static
void
SetHandlerControl
(
DWORD
aPid
RefPtr
<
IHandlerControl
>
aCtrl
)
;
static
void
InvalidateHandlers
(
)
;
bool
DispatchTextChangeToHandler
(
bool
aIsInsert
const
nsString
&
aText
int32_t
aStart
uint32_t
aLen
)
;
protected
:
virtual
~
AccessibleWrap
(
)
=
default
;
struct
HandlerControllerData
final
{
HandlerControllerData
(
DWORD
aPid
RefPtr
<
IHandlerControl
>
&
&
aCtrl
)
:
mPid
(
aPid
)
mCtrl
(
std
:
:
move
(
aCtrl
)
)
{
mIsProxy
=
mozilla
:
:
mscom
:
:
IsProxy
(
mCtrl
)
;
}
HandlerControllerData
(
HandlerControllerData
&
&
aOther
)
:
mPid
(
aOther
.
mPid
)
mIsProxy
(
aOther
.
mIsProxy
)
mCtrl
(
std
:
:
move
(
aOther
.
mCtrl
)
)
{
}
bool
operator
=
=
(
const
HandlerControllerData
&
aOther
)
const
{
return
mPid
=
=
aOther
.
mPid
;
}
bool
operator
=
=
(
const
DWORD
&
aPid
)
const
{
return
mPid
=
=
aPid
;
}
DWORD
mPid
;
bool
mIsProxy
;
RefPtr
<
IHandlerControl
>
mCtrl
;
}
;
static
StaticAutoPtr
<
nsTArray
<
HandlerControllerData
>
>
sHandlerControllers
;
}
;
static
inline
AccessibleWrap
*
WrapperFor
(
const
RemoteAccessible
*
aProxy
)
{
return
reinterpret_cast
<
AccessibleWrap
*
>
(
aProxy
-
>
GetWrapper
(
)
)
;
}
}
}
#
endif
