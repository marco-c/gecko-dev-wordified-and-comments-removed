#
include
"
Compatibility
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsWindowsDllInterceptor
.
h
"
#
include
"
nsWinUtils
.
h
"
#
include
"
Statistics
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
<
shlobj
.
h
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
static
const
wchar_t
*
ConsumerStringMap
[
CONSUMERS_ENUM_LEN
+
1
]
=
{
L
"
NVDA
"
L
"
JAWS
"
L
"
OLDJAWS
"
L
"
WE
"
L
"
DOLPHIN
"
L
"
SEROTEK
"
L
"
COBRA
"
L
"
ZOOMTEXT
"
L
"
KAZAGURU
"
L
"
YOUDAO
"
L
"
UNKNOWN
"
L
"
UIAUTOMATION
"
L
"
\
0
"
}
;
bool
Compatibility
:
:
IsModuleVersionLessThan
(
HMODULE
aModuleHandle
unsigned
long
long
aVersion
)
{
LauncherResult
<
ModuleVersion
>
version
=
GetModuleVersion
(
aModuleHandle
)
;
if
(
version
.
isErr
(
)
)
{
return
true
;
}
return
version
.
unwrap
(
)
<
aVersion
;
}
static
WindowsDllInterceptor
sUser32Interceptor
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
decltype
(
&
InSendMessageEx
)
>
sInSendMessageExStub
;
static
bool
sInSendMessageExHackEnabled
=
false
;
static
PVOID
sVectoredExceptionHandler
=
nullptr
;
#
if
defined
(
_MSC_VER
)
#
include
<
intrin
.
h
>
#
pragma
intrinsic
(
_ReturnAddress
)
#
define
RETURN_ADDRESS
(
)
_ReturnAddress
(
)
#
elif
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
#
define
RETURN_ADDRESS
(
)
\
__builtin_extract_return_addr
(
__builtin_return_address
(
0
)
)
#
endif
static
inline
bool
IsCurrentThreadInBlockingMessageSend
(
const
DWORD
aStateBits
)
{
return
(
aStateBits
&
(
ISMEX_REPLIED
|
ISMEX_SEND
)
)
=
=
ISMEX_SEND
;
}
static
DWORD
WINAPI
InSendMessageExHook
(
LPVOID
lpReserved
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
DWORD
result
=
sInSendMessageExStub
(
lpReserved
)
;
if
(
NS_IsMainThread
(
)
&
&
sInSendMessageExHackEnabled
&
&
IsCurrentThreadInBlockingMessageSend
(
result
)
)
{
static
const
HMODULE
comModule
=
[
]
(
)
-
>
HMODULE
{
HMODULE
module
=
LoadLibraryW
(
L
"
combase
.
dll
"
)
;
if
(
!
module
)
{
module
=
LoadLibraryW
(
L
"
ole32
.
dll
"
)
;
}
return
module
;
}
(
)
;
MOZ_ASSERT
(
comModule
)
;
if
(
!
comModule
)
{
return
result
;
}
HMODULE
callingModule
;
if
(
GetModuleHandleEx
(
GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
|
GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
reinterpret_cast
<
LPCWSTR
>
(
RETURN_ADDRESS
(
)
)
&
callingModule
)
&
&
callingModule
=
=
comModule
)
{
result
=
ISMEX_NOTIFY
;
}
}
return
result
;
}
static
LONG
CALLBACK
DetectInSendMessageExCompat
(
PEXCEPTION_POINTERS
aExceptionInfo
)
{
DWORD
exceptionCode
=
aExceptionInfo
-
>
ExceptionRecord
-
>
ExceptionCode
;
if
(
exceptionCode
=
=
RPC_E_CANTCALLOUT_ININPUTSYNCCALL
&
&
NS_IsMainThread
(
)
)
{
sInSendMessageExHackEnabled
=
true
;
if
(
RemoveVectoredExceptionHandler
(
sVectoredExceptionHandler
)
)
{
sVectoredExceptionHandler
=
nullptr
;
}
}
return
EXCEPTION_CONTINUE_SEARCH
;
}
uint32_t
Compatibility
:
:
sConsumers
=
Compatibility
:
:
UNKNOWN
;
void
Compatibility
:
:
InitConsumers
(
)
{
HMODULE
jawsHandle
=
:
:
GetModuleHandleW
(
L
"
jhook
"
)
;
if
(
jawsHandle
)
{
sConsumers
|
=
IsModuleVersionLessThan
(
jawsHandle
MAKE_FILE_VERSION
(
19
0
0
0
)
)
?
OLDJAWS
:
JAWS
;
}
if
(
:
:
GetModuleHandleW
(
L
"
gwm32inc
"
)
)
sConsumers
|
=
WE
;
if
(
:
:
GetModuleHandleW
(
L
"
dolwinhk
"
)
)
sConsumers
|
=
DOLPHIN
;
if
(
:
:
GetModuleHandleW
(
L
"
STSA32
"
)
)
sConsumers
|
=
SEROTEK
;
if
(
:
:
GetModuleHandleW
(
L
"
nvdaHelperRemote
"
)
)
sConsumers
|
=
NVDA
;
if
(
:
:
GetModuleHandleW
(
L
"
OsmHooks
"
)
|
|
:
:
GetModuleHandleW
(
L
"
OsmHks64
"
)
)
sConsumers
|
=
COBRA
;
if
(
:
:
GetModuleHandleW
(
L
"
WebFinderRemote
"
)
)
sConsumers
|
=
ZOOMTEXT
;
if
(
:
:
GetModuleHandleW
(
L
"
Kazahook
"
)
)
sConsumers
|
=
KAZAGURU
;
if
(
:
:
GetModuleHandleW
(
L
"
TextExtractorImpl32
"
)
|
|
:
:
GetModuleHandleW
(
L
"
TextExtractorImpl64
"
)
)
sConsumers
|
=
YOUDAO
;
if
(
:
:
GetModuleHandleW
(
L
"
uiautomation
"
)
|
|
:
:
GetModuleHandleW
(
L
"
uiautomationcore
"
)
)
sConsumers
|
=
UIAUTOMATION
;
if
(
sConsumers
!
=
Compatibility
:
:
UNKNOWN
)
sConsumers
&
=
~
Compatibility
:
:
UNKNOWN
;
}
bool
Compatibility
:
:
HasKnownNonUiaConsumer
(
)
{
InitConsumers
(
)
;
return
sConsumers
&
~
(
Compatibility
:
:
UNKNOWN
|
UIAUTOMATION
)
;
}
void
Compatibility
:
:
Init
(
)
{
InitConsumers
(
)
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
AccessibilityInProcClient
nsPrintfCString
(
"
0x
%
X
"
sConsumers
)
)
;
uint32_t
temp
=
sConsumers
;
for
(
int
i
=
0
;
temp
;
i
+
+
)
{
if
(
temp
&
0x1
)
statistics
:
:
A11yConsumers
(
i
)
;
temp
>
>
=
1
;
}
if
(
sConsumers
&
(
JAWS
|
OLDJAWS
|
WE
)
)
{
if
(
!
Preferences
:
:
HasUserValue
(
"
browser
.
ctrlTab
.
disallowForScreenReaders
"
)
)
Preferences
:
:
SetBool
(
"
browser
.
ctrlTab
.
disallowForScreenReaders
"
true
)
;
}
if
(
(
sConsumers
&
(
~
(
UIAUTOMATION
|
NVDA
)
)
)
&
&
BrowserTabsRemoteAutostart
(
)
)
{
sUser32Interceptor
.
Init
(
"
user32
.
dll
"
)
;
sInSendMessageExStub
.
Set
(
sUser32Interceptor
"
InSendMessageEx
"
&
InSendMessageExHook
)
;
if
(
!
sVectoredExceptionHandler
)
{
const
ULONG
firstHandler
=
FALSE
;
sVectoredExceptionHandler
=
AddVectoredExceptionHandler
(
firstHandler
&
DetectInSendMessageExCompat
)
;
}
}
}
#
if
!
defined
(
HAVE_64BIT_BUILD
)
static
bool
ReadCOMRegDefaultString
(
const
nsString
&
aRegPath
nsAString
&
aOutBuf
)
{
aOutBuf
.
Truncate
(
)
;
nsAutoString
fullyQualifiedRegPath
;
fullyQualifiedRegPath
.
AppendLiteral
(
u
"
SOFTWARE
\
\
Classes
\
\
"
)
;
fullyQualifiedRegPath
.
Append
(
aRegPath
)
;
DWORD
type
;
DWORD
bufLen
=
0
;
LONG
result
=
:
:
RegGetValue
(
HKEY_LOCAL_MACHINE
fullyQualifiedRegPath
.
get
(
)
nullptr
RRF_RT_ANY
&
type
nullptr
&
bufLen
)
;
if
(
result
!
=
ERROR_SUCCESS
|
|
(
type
!
=
REG_SZ
&
&
type
!
=
REG_EXPAND_SZ
)
)
{
return
false
;
}
DWORD
flags
=
type
=
=
REG_SZ
?
RRF_RT_REG_SZ
:
RRF_RT_REG_EXPAND_SZ
;
aOutBuf
.
SetLength
(
(
bufLen
+
1
)
/
sizeof
(
char16_t
)
)
;
result
=
:
:
RegGetValue
(
HKEY_LOCAL_MACHINE
fullyQualifiedRegPath
.
get
(
)
nullptr
flags
nullptr
aOutBuf
.
BeginWriting
(
)
&
bufLen
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
aOutBuf
.
Truncate
(
)
;
return
false
;
}
aOutBuf
.
Truncate
(
(
bufLen
+
1
)
/
sizeof
(
char16_t
)
-
1
)
;
return
true
;
}
static
bool
IsSystemOleAcc
(
nsCOMPtr
<
nsIFile
>
&
aFile
)
{
PWSTR
systemPath
=
nullptr
;
HRESULT
hr
=
:
:
SHGetKnownFolderPath
(
FOLDERID_SystemX86
0
nullptr
&
systemPath
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
nsCOMPtr
<
nsIFile
>
oleAcc
;
nsresult
rv
=
NS_NewLocalFile
(
nsDependentString
(
systemPath
)
false
getter_AddRefs
(
oleAcc
)
)
;
:
:
CoTaskMemFree
(
systemPath
)
;
systemPath
=
nullptr
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
rv
=
oleAcc
-
>
Append
(
NS_LITERAL_STRING
(
"
oleacc
.
dll
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
bool
isEqual
;
rv
=
oleAcc
-
>
Equals
(
aFile
&
isEqual
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
isEqual
;
}
static
bool
IsTypelibPreferred
(
)
{
NS_NAMED_LITERAL_STRING
(
kUniversalMarshalerClsid
"
{
00020424
-
0000
-
0000
-
C000
-
000000000046
}
"
)
;
NS_NAMED_LITERAL_STRING
(
kIAccessiblePSClsidPath
"
Interface
\
\
{
618736E0
-
3C3D
-
11CF
-
810C
-
00AA00389B71
}
\
\
ProxyStubClsid32
"
)
;
nsAutoString
psClsid
;
if
(
!
ReadCOMRegDefaultString
(
kIAccessiblePSClsidPath
psClsid
)
)
{
return
false
;
}
return
psClsid
.
Equals
(
kUniversalMarshalerClsid
nsCaseInsensitiveStringComparator
)
;
}
static
bool
IsIAccessibleTypelibRegistered
(
)
{
NS_NAMED_LITERAL_STRING
(
kIAccessibleTypelibRegPath
"
TypeLib
\
\
{
1EA4DBF0
-
3C3B
-
11CF
-
810C
-
00AA00389B71
}
\
\
1
.
1
\
\
0
\
\
win32
"
)
;
nsAutoString
typelibPath
;
if
(
!
ReadCOMRegDefaultString
(
kIAccessibleTypelibRegPath
typelibPath
)
)
{
return
false
;
}
nsCOMPtr
<
nsIFile
>
libTestFile
;
nsresult
rv
=
NS_NewLocalFile
(
typelibPath
false
getter_AddRefs
(
libTestFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
return
IsSystemOleAcc
(
libTestFile
)
;
}
static
bool
IsIAccessiblePSRegistered
(
)
{
NS_NAMED_LITERAL_STRING
(
kIAccessiblePSRegPath
"
CLSID
\
\
{
03022430
-
ABC4
-
11D0
-
BDE2
-
00AA001A1953
}
\
\
InProcServer32
"
)
;
nsAutoString
proxyStubPath
;
if
(
!
ReadCOMRegDefaultString
(
kIAccessiblePSRegPath
proxyStubPath
)
)
{
return
false
;
}
nsCOMPtr
<
nsIFile
>
libTestFile
;
nsresult
rv
=
NS_NewLocalFile
(
proxyStubPath
false
getter_AddRefs
(
libTestFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
return
IsSystemOleAcc
(
libTestFile
)
;
}
static
bool
UseIAccessibleProxyStub
(
)
{
if
(
IsTypelibPreferred
(
)
&
&
IsIAccessibleTypelibRegistered
(
)
)
{
return
false
;
}
if
(
IsIAccessiblePSRegistered
(
)
)
{
return
true
;
}
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
IAccessibleConfig
NS_LITERAL_CSTRING
(
"
NoSystemTypeLibOrPS
"
)
)
;
return
false
;
}
#
endif
uint16_t
Compatibility
:
:
GetActCtxResourceId
(
)
{
#
if
defined
(
HAVE_64BIT_BUILD
)
return
64
;
#
else
if
(
mozilla
:
:
IsWin10CreatorsUpdateOrLater
(
)
|
|
UseIAccessibleProxyStub
(
)
)
{
return
64
;
}
return
32
;
#
endif
}
void
Compatibility
:
:
GetHumanReadableConsumersStr
(
nsAString
&
aResult
)
{
bool
appened
=
false
;
uint32_t
index
=
0
;
for
(
uint32_t
consumers
=
sConsumers
;
consumers
;
consumers
=
consumers
>
>
1
)
{
if
(
consumers
&
0x1
)
{
if
(
appened
)
{
aResult
.
AppendLiteral
(
"
"
)
;
}
aResult
.
Append
(
ConsumerStringMap
[
index
]
)
;
appened
=
true
;
}
if
(
+
+
index
>
CONSUMERS_ENUM_LEN
)
{
break
;
}
}
}
