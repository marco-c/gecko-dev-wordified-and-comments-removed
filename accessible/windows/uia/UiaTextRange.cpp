#
include
"
UiaTextRange
.
h
"
#
include
"
mozilla
/
a11y
/
HyperTextAccessibleBase
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsIAccessibleTypes
.
h
"
#
include
"
TextLeafRange
.
h
"
#
include
<
comdef
.
h
>
#
include
<
propvarutil
.
h
>
#
include
<
unordered_set
>
namespace
mozilla
:
:
a11y
{
template
<
typename
T
>
HRESULT
GetAttribute
(
TEXTATTRIBUTEID
aAttributeId
T
const
&
aRangeOrPoint
VARIANT
&
aRetVal
)
;
static
int
CompareVariants
(
const
VARIANT
&
aFirst
const
VARIANT
&
aSecond
)
{
#
if
defined
(
__MINGW32__
)
|
|
defined
(
__MINGW64__
)
|
|
defined
(
__MINGW__
)
PROPVARIANT
firstPropVar
;
PROPVARIANT
secondPropVar
;
VariantToPropVariant
(
&
aFirst
&
firstPropVar
)
;
VariantToPropVariant
(
&
aSecond
&
secondPropVar
)
;
return
PropVariantCompareEx
(
firstPropVar
secondPropVar
PVCU_DEFAULT
PVCHF_DEFAULT
)
;
#
else
return
VariantCompare
(
aFirst
aSecond
)
;
#
endif
}
static
const
GUID
IID_UiaTextRange
=
{
0x74b8e664
0x4578
0x4b52
{
0x9c
0xbc
0x30
0xa7
0xa8
0x27
0x1a
0xe8
}
}
;
static
TextLeafPoint
GetEndpoint
(
TextLeafRange
&
aRange
enum
TextPatternRangeEndpoint
aEndpoint
)
{
if
(
aEndpoint
=
=
TextPatternRangeEndpoint_Start
)
{
return
aRange
.
Start
(
)
;
}
return
aRange
.
End
(
)
;
}
static
void
RemoveExcludedAccessiblesFromRange
(
TextLeafRange
&
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
TextLeafPoint
start
=
aRange
.
Start
(
)
;
TextLeafPoint
end
=
aRange
.
End
(
)
;
if
(
start
=
=
end
)
{
return
;
}
if
(
end
.
mOffset
!
=
0
)
{
return
;
}
end
=
end
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
)
;
+
+
end
.
mOffset
;
if
(
start
<
=
end
)
{
aRange
.
SetEnd
(
end
)
;
}
}
static
bool
IsUiaEmbeddedObject
(
const
Accessible
*
aAcc
)
{
if
(
aAcc
-
>
IsText
(
)
)
{
return
false
;
}
switch
(
aAcc
-
>
Role
(
)
)
{
case
roles
:
:
CONTENT_DELETION
:
case
roles
:
:
CONTENT_INSERTION
:
case
roles
:
:
EMPHASIS
:
case
roles
:
:
LANDMARK
:
case
roles
:
:
MARK
:
case
roles
:
:
NAVIGATION
:
case
roles
:
:
NOTE
:
case
roles
:
:
PARAGRAPH
:
case
roles
:
:
REGION
:
case
roles
:
:
SECTION
:
case
roles
:
:
STRONG
:
case
roles
:
:
SUBSCRIPT
:
case
roles
:
:
SUPERSCRIPT
:
case
roles
:
:
TEXT
:
case
roles
:
:
TEXT_CONTAINER
:
return
false
;
default
:
break
;
}
return
true
;
}
static
NotNull
<
Accessible
*
>
GetSelectionContainer
(
TextLeafRange
&
aRange
)
{
Accessible
*
acc
=
aRange
.
Start
(
)
.
mAcc
;
MOZ_ASSERT
(
acc
)
;
if
(
acc
-
>
IsTextLeaf
(
)
)
{
if
(
Accessible
*
parent
=
acc
-
>
Parent
(
)
)
{
acc
=
parent
;
}
}
if
(
acc
-
>
IsTextField
(
)
)
{
return
WrapNotNull
(
acc
)
;
}
return
WrapNotNull
(
nsAccUtils
:
:
DocumentFor
(
acc
)
)
;
}
static
TextLeafPoint
NormalizePoint
(
Accessible
*
aAcc
int32_t
aOffset
)
{
if
(
!
aAcc
)
{
return
TextLeafPoint
(
aAcc
aOffset
)
;
}
int32_t
length
=
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
aAcc
)
)
;
if
(
aOffset
>
length
)
{
aOffset
=
length
;
}
return
TextLeafPoint
(
aAcc
aOffset
)
;
}
UiaTextRange
:
:
UiaTextRange
(
const
TextLeafRange
&
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
SetRange
(
aRange
)
;
}
void
UiaTextRange
:
:
SetRange
(
const
TextLeafRange
&
aRange
)
{
TextLeafPoint
start
=
aRange
.
Start
(
)
;
mStartAcc
=
MsaaAccessible
:
:
GetFrom
(
start
.
mAcc
)
;
MOZ_ASSERT
(
mStartAcc
)
;
mStartOffset
=
start
.
mOffset
;
TextLeafPoint
end
=
aRange
.
End
(
)
;
mEndAcc
=
MsaaAccessible
:
:
GetFrom
(
end
.
mAcc
)
;
MOZ_ASSERT
(
mEndAcc
)
;
mEndOffset
=
end
.
mOffset
;
mIsEndOfLineInsertionPoint
=
start
=
=
end
&
&
start
.
mIsEndOfLineInsertionPoint
;
}
TextLeafRange
UiaTextRange
:
:
GetRange
(
)
const
{
if
(
mIsEndOfLineInsertionPoint
)
{
MOZ_ASSERT
(
mStartAcc
=
=
mEndAcc
&
&
mStartOffset
=
=
mEndOffset
)
;
TextLeafPoint
point
=
NormalizePoint
(
mStartAcc
-
>
Acc
(
)
mStartOffset
)
;
point
.
mIsEndOfLineInsertionPoint
=
true
;
return
TextLeafRange
(
point
point
)
;
}
return
TextLeafRange
(
NormalizePoint
(
mStartAcc
-
>
Acc
(
)
mStartOffset
)
NormalizePoint
(
mEndAcc
-
>
Acc
(
)
mEndOffset
)
)
;
}
TextLeafRange
UiaTextRange
:
:
GetRangeFrom
(
ITextRangeProvider
*
aProvider
)
{
if
(
aProvider
)
{
RefPtr
<
UiaTextRange
>
uiaRange
;
aProvider
-
>
QueryInterface
(
IID_UiaTextRange
getter_AddRefs
(
uiaRange
)
)
;
if
(
uiaRange
)
{
return
uiaRange
-
>
GetRange
(
)
;
}
}
return
TextLeafRange
(
)
;
}
TextLeafPoint
UiaTextRange
:
:
FindBoundary
(
const
TextLeafPoint
&
aOrigin
enum
TextUnit
aUnit
nsDirection
aDirection
bool
aIncludeOrigin
)
{
if
(
aUnit
=
=
TextUnit_Page
|
|
aUnit
=
=
TextUnit_Document
)
{
Accessible
*
doc
=
nsAccUtils
:
:
DocumentFor
(
aOrigin
.
mAcc
)
;
if
(
aDirection
=
=
eDirPrevious
)
{
return
TextLeafPoint
(
doc
0
)
;
}
return
TextLeafPoint
(
doc
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
)
;
}
if
(
aUnit
=
=
TextUnit_Format
)
{
return
aOrigin
.
FindTextAttrsStart
(
aDirection
aIncludeOrigin
)
;
}
AccessibleTextBoundary
boundary
;
switch
(
aUnit
)
{
case
TextUnit_Character
:
boundary
=
nsIAccessibleText
:
:
BOUNDARY_CLUSTER
;
break
;
case
TextUnit_Word
:
boundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_START
;
break
;
case
TextUnit_Line
:
boundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_START
;
break
;
case
TextUnit_Paragraph
:
boundary
=
nsIAccessibleText
:
:
BOUNDARY_PARAGRAPH
;
break
;
default
:
return
TextLeafPoint
(
)
;
}
return
aOrigin
.
FindBoundary
(
boundary
aDirection
aIncludeOrigin
?
TextLeafPoint
:
:
BoundaryFlags
:
:
eIncludeOrigin
:
TextLeafPoint
:
:
BoundaryFlags
:
:
eDefaultBoundaryFlags
)
;
}
bool
UiaTextRange
:
:
MovePoint
(
TextLeafPoint
&
aPoint
enum
TextUnit
aUnit
const
int
aRequestedCount
int
&
aActualCount
)
{
aActualCount
=
0
;
const
nsDirection
direction
=
aRequestedCount
<
0
?
eDirPrevious
:
eDirNext
;
while
(
aActualCount
!
=
aRequestedCount
)
{
TextLeafPoint
oldPoint
=
aPoint
;
aPoint
=
FindBoundary
(
aPoint
aUnit
direction
)
;
if
(
!
aPoint
)
{
return
false
;
}
if
(
aPoint
=
=
oldPoint
)
{
break
;
}
direction
=
=
eDirPrevious
?
-
-
aActualCount
:
+
+
aActualCount
;
}
return
true
;
}
void
UiaTextRange
:
:
SetEndpoint
(
enum
TextPatternRangeEndpoint
aEndpoint
const
TextLeafPoint
&
aDest
)
{
TextLeafRange
origRange
=
GetRange
(
)
;
MOZ_ASSERT
(
origRange
)
;
if
(
aEndpoint
=
=
TextPatternRangeEndpoint_Start
)
{
TextLeafPoint
end
=
origRange
.
End
(
)
;
if
(
end
<
aDest
)
{
end
=
aDest
;
}
SetRange
(
{
aDest
end
}
)
;
}
else
{
TextLeafPoint
start
=
origRange
.
Start
(
)
;
if
(
aDest
<
start
)
{
start
=
aDest
;
}
SetRange
(
{
start
aDest
}
)
;
}
}
IMPL_IUNKNOWN2
(
UiaTextRange
ITextRangeProvider
UiaTextRange
)
STDMETHODIMP
UiaTextRange
:
:
Clone
(
__RPC__deref_out_opt
ITextRangeProvider
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
RefPtr
uiaRange
=
new
UiaTextRange
(
range
)
;
uiaRange
.
forget
(
aRetVal
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
Compare
(
__RPC__in_opt
ITextRangeProvider
*
aRange
__RPC__out
BOOL
*
aRetVal
)
{
if
(
!
aRange
|
|
!
aRetVal
)
{
return
E_INVALIDARG
;
}
*
aRetVal
=
GetRange
(
)
=
=
GetRangeFrom
(
aRange
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
CompareEndpoints
(
enum
TextPatternRangeEndpoint
aEndpoint
__RPC__in_opt
ITextRangeProvider
*
aTargetRange
enum
TextPatternRangeEndpoint
aTargetEndpoint
__RPC__out
int
*
aRetVal
)
{
if
(
!
aTargetRange
|
|
!
aRetVal
)
{
return
E_INVALIDARG
;
}
TextLeafRange
origRange
=
GetRange
(
)
;
if
(
!
origRange
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafPoint
origPoint
=
GetEndpoint
(
origRange
aEndpoint
)
;
TextLeafRange
targetRange
=
GetRangeFrom
(
aTargetRange
)
;
if
(
!
targetRange
)
{
return
E_INVALIDARG
;
}
TextLeafPoint
targetPoint
=
GetEndpoint
(
targetRange
aTargetEndpoint
)
;
if
(
origPoint
=
=
targetPoint
)
{
*
aRetVal
=
0
;
}
else
if
(
origPoint
<
targetPoint
)
{
*
aRetVal
=
-
1
;
}
else
{
*
aRetVal
=
1
;
}
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
ExpandToEnclosingUnit
(
enum
TextUnit
aUnit
)
{
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafPoint
origin
=
range
.
Start
(
)
;
TextLeafPoint
start
=
FindBoundary
(
origin
aUnit
eDirPrevious
true
)
;
if
(
!
start
)
{
return
E_FAIL
;
}
TextLeafPoint
end
=
FindBoundary
(
origin
aUnit
eDirNext
)
;
SetRange
(
{
start
end
}
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
FindAttribute
(
TEXTATTRIBUTEID
aAttributeId
VARIANT
aVal
BOOL
aBackward
__RPC__deref_out_opt
ITextRangeProvider
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
*
aRetVal
=
nullptr
;
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
MOZ_ASSERT
(
range
.
Start
(
)
<
=
range
.
End
(
)
"
Range
must
be
valid
to
proceed
.
"
)
;
VARIANT
value
{
}
;
if
(
!
aBackward
)
{
Maybe
<
TextLeafPoint
>
matchingRangeStart
{
}
;
TextLeafPoint
startPoint
=
range
.
Start
(
)
;
TextLeafPoint
endPoint
=
startPoint
;
endPoint
=
endPoint
.
FindTextAttrsStart
(
eDirNext
)
;
do
{
GetAttribute
(
aAttributeId
startPoint
value
)
;
if
(
aVal
.
vt
=
=
value
.
vt
&
&
CompareVariants
(
aVal
value
)
=
=
0
)
{
if
(
!
matchingRangeStart
)
{
matchingRangeStart
=
Some
(
startPoint
)
;
}
}
else
if
(
matchingRangeStart
)
{
RefPtr
uiaRange
=
new
UiaTextRange
(
TextLeafRange
{
matchingRangeStart
.
value
(
)
startPoint
}
)
;
uiaRange
.
forget
(
aRetVal
)
;
return
S_OK
;
}
startPoint
=
endPoint
;
}
while
(
(
endPoint
=
endPoint
.
FindTextAttrsStart
(
eDirNext
)
)
&
&
endPoint
<
=
range
.
End
(
)
&
&
startPoint
!
=
endPoint
)
;
if
(
matchingRangeStart
)
{
RefPtr
uiaRange
=
new
UiaTextRange
(
TextLeafRange
{
matchingRangeStart
.
value
(
)
range
.
End
(
)
}
)
;
uiaRange
.
forget
(
aRetVal
)
;
return
S_OK
;
}
}
else
{
Maybe
<
TextLeafPoint
>
matchingRangeEnd
{
}
;
TextLeafPoint
endPoint
=
range
.
End
(
)
;
TextLeafPoint
startPoint
=
endPoint
;
startPoint
=
startPoint
.
FindTextAttrsStart
(
eDirPrevious
)
;
do
{
GetAttribute
(
aAttributeId
startPoint
value
)
;
if
(
aVal
.
vt
=
=
value
.
vt
&
&
CompareVariants
(
aVal
value
)
=
=
0
)
{
if
(
!
matchingRangeEnd
)
{
matchingRangeEnd
=
Some
(
endPoint
)
;
}
}
else
if
(
matchingRangeEnd
)
{
RefPtr
uiaRange
=
new
UiaTextRange
(
TextLeafRange
{
endPoint
matchingRangeEnd
.
value
(
)
}
)
;
uiaRange
.
forget
(
aRetVal
)
;
return
S_OK
;
}
endPoint
=
startPoint
;
}
while
(
(
startPoint
=
startPoint
.
FindTextAttrsStart
(
eDirPrevious
)
)
&
&
range
.
Start
(
)
<
=
startPoint
&
&
startPoint
!
=
endPoint
)
;
if
(
matchingRangeEnd
)
{
RefPtr
uiaRange
=
new
UiaTextRange
(
TextLeafRange
{
range
.
Start
(
)
matchingRangeEnd
.
value
(
)
}
)
;
uiaRange
.
forget
(
aRetVal
)
;
return
S_OK
;
}
}
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
FindText
(
__RPC__in
BSTR
aText
BOOL
aBackward
BOOL
aIgnoreCase
__RPC__deref_out_opt
ITextRangeProvider
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
*
aRetVal
=
nullptr
;
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
MOZ_ASSERT
(
range
.
Start
(
)
<
=
range
.
End
(
)
"
Range
must
be
valid
to
proceed
.
"
)
;
if
(
range
.
Start
(
)
=
=
range
.
End
(
)
)
{
return
S_OK
;
}
nsTArray
<
std
:
:
pair
<
int32_t
Accessible
*
>
>
indexToAcc
;
nsAutoString
rangeText
;
for
(
const
TextLeafRange
leafSegment
:
range
)
{
Accessible
*
startAcc
=
leafSegment
.
Start
(
)
.
mAcc
;
MOZ_ASSERT
(
startAcc
"
Start
acc
of
leaf
segment
was
unexpectedly
null
.
"
)
;
indexToAcc
.
EmplaceBack
(
rangeText
.
Length
(
)
startAcc
)
;
startAcc
-
>
AppendTextTo
(
rangeText
)
;
}
const
nsDependentString
searchStr
{
aText
}
;
const
int32_t
startIndex
=
[
&
]
(
)
{
if
(
aIgnoreCase
)
{
ToLowerCase
(
rangeText
)
;
nsAutoString
searchStrLower
;
ToLowerCase
(
searchStr
searchStrLower
)
;
return
aBackward
?
rangeText
.
RFind
(
searchStrLower
)
:
rangeText
.
Find
(
searchStrLower
)
;
}
else
{
return
aBackward
?
rangeText
.
RFind
(
searchStr
)
:
rangeText
.
Find
(
searchStr
)
;
}
}
(
)
;
if
(
startIndex
=
=
kNotFound
)
{
return
S_OK
;
}
const
int32_t
endIndex
=
startIndex
+
searchStr
.
Length
(
)
;
auto
GetNearestAccLessThanIndex
=
[
&
indexToAcc
]
(
int32_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
>
=
0
"
Search
index
is
less
than
0
.
"
)
;
auto
itr
=
std
:
:
lower_bound
(
indexToAcc
.
begin
(
)
indexToAcc
.
end
(
)
aIndex
[
]
(
const
std
:
:
pair
<
int32_t
Accessible
*
>
&
aPair
int32_t
aIndex
)
{
return
aPair
.
first
<
=
aIndex
;
}
)
;
MOZ_ASSERT
(
itr
!
=
indexToAcc
.
begin
(
)
"
Iterator
is
unexpectedly
at
the
beginning
.
"
)
;
-
-
itr
;
return
itr
;
}
;
auto
itr
=
GetNearestAccLessThanIndex
(
startIndex
)
;
Accessible
*
foundTextStart
=
itr
-
>
second
;
const
int32_t
offsetFromStart
=
startIndex
-
itr
-
>
first
;
const
TextLeafPoint
rangeStart
{
foundTextStart
offsetFromStart
}
;
itr
=
GetNearestAccLessThanIndex
(
endIndex
)
;
Accessible
*
foundTextEnd
=
itr
-
>
second
;
const
int32_t
offsetFromEndAccStart
=
endIndex
-
itr
-
>
first
;
const
TextLeafPoint
rangeEnd
{
foundTextEnd
offsetFromEndAccStart
}
;
TextLeafRange
resultRange
{
rangeStart
rangeEnd
}
;
RefPtr
uiaRange
=
new
UiaTextRange
(
resultRange
)
;
uiaRange
.
forget
(
aRetVal
)
;
return
S_OK
;
}
template
<
TEXTATTRIBUTEID
Attr
>
struct
AttributeTraits
{
}
;
template
<
TEXTATTRIBUTEID
Attr
>
HRESULT
GetAttribute
(
const
TextLeafRange
&
aRange
VARIANT
&
aVariant
)
{
using
Traits
=
AttributeTraits
<
Attr
>
;
using
AttrType
=
typename
Traits
:
:
AttrType
;
const
TextLeafPoint
end
=
aRange
.
End
(
)
;
TextLeafPoint
current
=
aRange
.
Start
(
)
;
Maybe
<
AttrType
>
val
=
Traits
:
:
GetValue
(
current
)
;
if
(
!
val
)
{
val
=
Some
(
Traits
:
:
DefaultValue
(
)
)
;
}
while
(
(
current
=
current
.
FindTextAttrsStart
(
eDirNext
)
)
&
&
current
<
end
)
{
Maybe
<
AttrType
>
currentVal
=
Traits
:
:
GetValue
(
current
)
;
if
(
!
currentVal
)
{
currentVal
=
Some
(
Traits
:
:
DefaultValue
(
)
)
;
}
if
(
*
currentVal
!
=
*
val
)
{
aVariant
.
vt
=
VT_UNKNOWN
;
return
UiaGetReservedMixedAttributeValue
(
&
aVariant
.
punkVal
)
;
}
}
return
Traits
:
:
WriteToVariant
(
aVariant
*
val
)
;
}
template
<
TEXTATTRIBUTEID
Attr
>
HRESULT
GetAttribute
(
TextLeafPoint
const
&
aPoint
VARIANT
&
aVariant
)
{
using
Traits
=
AttributeTraits
<
Attr
>
;
using
AttrType
=
typename
Traits
:
:
AttrType
;
Maybe
<
AttrType
>
val
=
Traits
:
:
GetValue
(
aPoint
)
;
if
(
!
val
)
{
val
=
Some
(
Traits
:
:
DefaultValue
(
)
)
;
}
return
Traits
:
:
WriteToVariant
(
aVariant
*
val
)
;
}
template
<
typename
T
>
HRESULT
GetAttribute
(
TEXTATTRIBUTEID
aAttributeId
T
const
&
aRangeOrPoint
VARIANT
&
aRetVal
)
{
switch
(
aAttributeId
)
{
case
UIA_AnnotationTypesAttributeId
:
return
GetAttribute
<
UIA_AnnotationTypesAttributeId
>
(
aRangeOrPoint
aRetVal
)
;
case
UIA_FontNameAttributeId
:
return
GetAttribute
<
UIA_FontNameAttributeId
>
(
aRangeOrPoint
aRetVal
)
;
case
UIA_FontSizeAttributeId
:
return
GetAttribute
<
UIA_FontSizeAttributeId
>
(
aRangeOrPoint
aRetVal
)
;
case
UIA_FontWeightAttributeId
:
return
GetAttribute
<
UIA_FontWeightAttributeId
>
(
aRangeOrPoint
aRetVal
)
;
case
UIA_IsHiddenAttributeId
:
return
GetAttribute
<
UIA_IsHiddenAttributeId
>
(
aRangeOrPoint
aRetVal
)
;
case
UIA_IsItalicAttributeId
:
return
GetAttribute
<
UIA_IsItalicAttributeId
>
(
aRangeOrPoint
aRetVal
)
;
case
UIA_IsReadOnlyAttributeId
:
return
GetAttribute
<
UIA_IsReadOnlyAttributeId
>
(
aRangeOrPoint
aRetVal
)
;
case
UIA_StyleIdAttributeId
:
return
GetAttribute
<
UIA_StyleIdAttributeId
>
(
aRangeOrPoint
aRetVal
)
;
case
UIA_IsSubscriptAttributeId
:
return
GetAttribute
<
UIA_IsSubscriptAttributeId
>
(
aRangeOrPoint
aRetVal
)
;
case
UIA_IsSuperscriptAttributeId
:
return
GetAttribute
<
UIA_IsSuperscriptAttributeId
>
(
aRangeOrPoint
aRetVal
)
;
default
:
aRetVal
.
vt
=
VT_UNKNOWN
;
return
UiaGetReservedNotSupportedValue
(
&
aRetVal
.
punkVal
)
;
break
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
UIA
Attribute
ID
"
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
GetAttributeValue
(
TEXTATTRIBUTEID
aAttributeId
__RPC__out
VARIANT
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
VariantInit
(
aRetVal
)
;
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
MOZ_ASSERT
(
range
.
Start
(
)
<
=
range
.
End
(
)
"
Range
must
be
valid
to
proceed
.
"
)
;
return
GetAttribute
(
aAttributeId
range
*
aRetVal
)
;
}
STDMETHODIMP
UiaTextRange
:
:
GetBoundingRectangles
(
__RPC__deref_out_opt
SAFEARRAY
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
*
aRetVal
=
nullptr
;
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
nsTArray
<
LayoutDeviceIntRect
>
lineRects
=
range
.
LineRects
(
)
;
TextLeafPoint
start
=
range
.
Start
(
)
;
if
(
lineRects
.
IsEmpty
(
)
&
&
start
=
=
range
.
End
(
)
)
{
LayoutDeviceIntRect
charBounds
;
bool
maybeUseCaretRect
;
if
(
mIsEndOfLineInsertionPoint
)
{
maybeUseCaretRect
=
true
;
}
else
{
charBounds
=
start
.
CharBounds
(
)
;
maybeUseCaretRect
=
charBounds
.
IsEmpty
(
)
;
}
if
(
maybeUseCaretRect
&
&
start
=
=
TextLeafPoint
:
:
GetCaret
(
start
.
mAcc
)
)
{
HyperTextAccessibleBase
*
ht
=
start
.
mAcc
-
>
AsHyperTextBase
(
)
;
if
(
!
ht
)
{
Accessible
*
parent
=
start
.
mAcc
-
>
Parent
(
)
;
if
(
parent
)
{
ht
=
parent
-
>
AsHyperTextBase
(
)
;
}
}
if
(
ht
)
{
charBounds
=
ht
-
>
GetCaretRect
(
)
.
first
;
}
}
lineRects
.
AppendElement
(
charBounds
)
;
}
SAFEARRAY
*
rectsVec
=
SafeArrayCreateVector
(
VT_R8
0
lineRects
.
Length
(
)
*
4
)
;
if
(
!
rectsVec
)
{
return
E_OUTOFMEMORY
;
}
if
(
lineRects
.
IsEmpty
(
)
)
{
*
aRetVal
=
rectsVec
;
return
S_OK
;
}
double
*
safeArrayData
=
nullptr
;
HRESULT
hr
=
SafeArrayAccessData
(
rectsVec
reinterpret_cast
<
void
*
*
>
(
&
safeArrayData
)
)
;
if
(
FAILED
(
hr
)
|
|
!
safeArrayData
)
{
SafeArrayDestroy
(
rectsVec
)
;
return
E_FAIL
;
}
for
(
size_t
index
=
0
;
index
<
lineRects
.
Length
(
)
;
+
+
index
)
{
const
LayoutDeviceIntRect
&
lineRect
=
lineRects
[
index
]
;
safeArrayData
[
index
*
4
+
0
]
=
static_cast
<
double
>
(
lineRect
.
x
)
;
safeArrayData
[
index
*
4
+
1
]
=
static_cast
<
double
>
(
lineRect
.
y
)
;
safeArrayData
[
index
*
4
+
2
]
=
static_cast
<
double
>
(
lineRect
.
width
)
;
safeArrayData
[
index
*
4
+
3
]
=
static_cast
<
double
>
(
lineRect
.
height
)
;
}
hr
=
SafeArrayUnaccessData
(
rectsVec
)
;
if
(
FAILED
(
hr
)
)
{
SafeArrayDestroy
(
rectsVec
)
;
return
E_FAIL
;
}
*
aRetVal
=
rectsVec
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
GetEnclosingElement
(
__RPC__deref_out_opt
IRawElementProviderSimple
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
*
aRetVal
=
nullptr
;
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
RemoveExcludedAccessiblesFromRange
(
range
)
;
Accessible
*
enclosing
=
range
.
Start
(
)
.
mAcc
-
>
GetClosestCommonInclusiveAncestor
(
range
.
End
(
)
.
mAcc
)
;
if
(
!
enclosing
)
{
return
S_OK
;
}
for
(
Accessible
*
acc
=
enclosing
;
acc
&
&
!
acc
-
>
IsDoc
(
)
;
acc
=
acc
-
>
Parent
(
)
)
{
if
(
nsAccUtils
:
:
MustPrune
(
acc
)
|
|
(
acc
-
>
Role
(
)
=
=
roles
:
:
LINK
&
&
acc
-
>
ChildCount
(
)
=
=
1
&
&
acc
-
>
FirstChild
(
)
-
>
IsText
(
)
)
)
{
enclosing
=
acc
;
break
;
}
}
RefPtr
<
IRawElementProviderSimple
>
uia
=
MsaaAccessible
:
:
GetFrom
(
enclosing
)
;
uia
.
forget
(
aRetVal
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
GetText
(
int
aMaxLength
__RPC__deref_out_opt
BSTR
*
aRetVal
)
{
if
(
!
aRetVal
|
|
aMaxLength
<
-
1
)
{
return
E_INVALIDARG
;
}
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
nsAutoString
text
;
for
(
TextLeafRange
segment
:
range
)
{
TextLeafPoint
start
=
segment
.
Start
(
)
;
int
segmentLength
=
segment
.
End
(
)
.
mOffset
-
start
.
mOffset
;
if
(
aMaxLength
>
=
0
)
{
const
int
remaining
=
aMaxLength
-
text
.
Length
(
)
;
if
(
segmentLength
>
remaining
)
{
segmentLength
=
remaining
;
}
}
start
.
mAcc
-
>
AppendTextTo
(
text
start
.
mOffset
segmentLength
)
;
if
(
aMaxLength
>
=
0
&
&
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
>
=
aMaxLength
)
{
break
;
}
}
*
aRetVal
=
:
:
SysAllocString
(
text
.
get
(
)
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
Move
(
enum
TextUnit
aUnit
int
aCount
__RPC__out
int
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafPoint
start
=
range
.
Start
(
)
;
const
bool
wasCollapsed
=
start
=
=
range
.
End
(
)
;
if
(
!
wasCollapsed
)
{
start
=
FindBoundary
(
start
aUnit
eDirPrevious
true
)
;
}
if
(
!
MovePoint
(
start
aUnit
aCount
*
aRetVal
)
)
{
return
E_FAIL
;
}
if
(
wasCollapsed
)
{
SetRange
(
{
start
start
}
)
;
}
else
{
TextLeafPoint
end
=
FindBoundary
(
start
aUnit
eDirNext
)
;
if
(
end
=
=
start
)
{
start
=
FindBoundary
(
start
aUnit
eDirPrevious
)
;
-
-
*
aRetVal
;
}
SetRange
(
{
start
end
}
)
;
}
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
MoveEndpointByUnit
(
enum
TextPatternRangeEndpoint
aEndpoint
enum
TextUnit
aUnit
int
aCount
__RPC__out
int
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafPoint
point
=
GetEndpoint
(
range
aEndpoint
)
;
if
(
!
MovePoint
(
point
aUnit
aCount
*
aRetVal
)
)
{
return
E_FAIL
;
}
SetEndpoint
(
aEndpoint
point
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
MoveEndpointByRange
(
enum
TextPatternRangeEndpoint
aEndpoint
__RPC__in_opt
ITextRangeProvider
*
aTargetRange
enum
TextPatternRangeEndpoint
aTargetEndpoint
)
{
if
(
!
aTargetRange
)
{
return
E_INVALIDARG
;
}
TextLeafRange
origRange
=
GetRange
(
)
;
if
(
!
origRange
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafRange
targetRange
=
GetRangeFrom
(
aTargetRange
)
;
if
(
!
targetRange
)
{
return
E_INVALIDARG
;
}
TextLeafPoint
dest
=
GetEndpoint
(
targetRange
aTargetEndpoint
)
;
SetEndpoint
(
aEndpoint
dest
)
;
return
S_OK
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
STDMETHODIMP
UiaTextRange
:
:
Select
(
)
{
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
if
(
!
range
.
SetSelection
(
TextLeafRange
:
:
kRemoveAllExistingSelectedRanges
false
)
)
{
return
UIA_E_INVALIDOPERATION
;
}
return
S_OK
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
STDMETHODIMP
UiaTextRange
:
:
AddToSelection
(
)
{
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
if
(
!
range
.
SetSelection
(
-
1
false
)
)
{
return
UIA_E_INVALIDOPERATION
;
}
return
S_OK
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
STDMETHODIMP
UiaTextRange
:
:
RemoveFromSelection
(
)
{
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
NotNull
<
Accessible
*
>
container
=
GetSelectionContainer
(
range
)
;
nsTArray
<
TextLeafRange
>
ranges
;
TextLeafRange
:
:
GetSelection
(
container
ranges
)
;
auto
index
=
ranges
.
IndexOf
(
range
)
;
if
(
index
!
=
ranges
.
NoIndex
)
{
HyperTextAccessibleBase
*
conHyp
=
container
-
>
AsHyperTextBase
(
)
;
MOZ_ASSERT
(
conHyp
)
;
conHyp
-
>
RemoveFromSelection
(
index
)
;
return
S_OK
;
}
return
UIA_E_INVALIDOPERATION
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
STDMETHODIMP
UiaTextRange
:
:
ScrollIntoView
(
BOOL
aAlignToTop
)
{
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
range
.
ScrollIntoView
(
aAlignToTop
?
nsIAccessibleScrollType
:
:
SCROLL_TYPE_TOP_LEFT
:
nsIAccessibleScrollType
:
:
SCROLL_TYPE_BOTTOM_RIGHT
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
GetChildren
(
__RPC__deref_out_opt
SAFEARRAY
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
*
aRetVal
=
nullptr
;
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
RemoveExcludedAccessiblesFromRange
(
range
)
;
Accessible
*
startAcc
=
range
.
Start
(
)
.
mAcc
;
Accessible
*
endAcc
=
range
.
End
(
)
.
mAcc
;
Accessible
*
common
=
startAcc
-
>
GetClosestCommonInclusiveAncestor
(
endAcc
)
;
if
(
!
common
)
{
return
S_OK
;
}
int32_t
startIndex
=
-
1
;
if
(
startAcc
=
=
common
)
{
startIndex
=
0
;
}
else
{
Accessible
*
child
=
startAcc
;
for
(
;
;
)
{
Accessible
*
parent
=
child
-
>
Parent
(
)
;
if
(
parent
=
=
common
)
{
startIndex
=
child
-
>
IndexInParent
(
)
;
break
;
}
child
=
parent
;
}
MOZ_ASSERT
(
startIndex
>
=
0
)
;
}
int32_t
endIndex
=
-
1
;
if
(
endAcc
=
=
common
)
{
endIndex
=
static_cast
<
int32_t
>
(
common
-
>
ChildCount
(
)
)
-
1
;
}
else
{
Accessible
*
child
=
endAcc
;
for
(
;
;
)
{
Accessible
*
parent
=
child
-
>
Parent
(
)
;
if
(
parent
=
=
common
)
{
endIndex
=
child
-
>
IndexInParent
(
)
;
break
;
}
child
=
parent
;
}
MOZ_ASSERT
(
endIndex
>
=
0
)
;
}
AutoTArray
<
Accessible
*
30
>
children
;
for
(
int32_t
i
=
startIndex
;
i
<
=
endIndex
;
+
+
i
)
{
Accessible
*
child
=
common
-
>
ChildAt
(
static_cast
<
uint32_t
>
(
i
)
)
;
if
(
IsUiaEmbeddedObject
(
child
)
)
{
children
.
AppendElement
(
child
)
;
}
}
*
aRetVal
=
AccessibleArrayToUiaArray
(
children
)
;
return
S_OK
;
}
template
<
>
struct
AttributeTraits
<
UIA_AnnotationTypesAttributeId
>
{
using
AttrType
=
std
:
:
unordered_set
<
int32_t
>
;
static
Maybe
<
AttrType
>
GetValue
(
TextLeafPoint
aPoint
)
{
RefPtr
<
AccAttributes
>
attrs
=
aPoint
.
GetTextAttributes
(
)
;
if
(
!
attrs
)
{
return
{
}
;
}
AttrType
annotationsAtPoint
{
}
;
if
(
auto
invalid
=
attrs
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
nsGkAtoms
:
:
invalid
)
)
{
const
nsAtom
*
invalidAtom
=
invalid
-
>
get
(
)
;
if
(
invalidAtom
=
=
nsGkAtoms
:
:
spelling
)
{
annotationsAtPoint
.
insert
(
AnnotationType_SpellingError
)
;
}
else
if
(
invalidAtom
=
=
nsGkAtoms
:
:
grammar
)
{
annotationsAtPoint
.
insert
(
AnnotationType_GrammarError
)
;
}
else
if
(
invalidAtom
=
=
nsGkAtoms
:
:
_true
)
{
annotationsAtPoint
.
insert
(
AnnotationType_DataValidationError
)
;
}
}
if
(
attrs
-
>
GetAttribute
<
bool
>
(
nsGkAtoms
:
:
mark
)
)
{
annotationsAtPoint
.
insert
(
AnnotationType_Highlighted
)
;
}
return
Some
(
annotationsAtPoint
)
;
}
static
AttrType
DefaultValue
(
)
{
return
{
}
;
}
static
HRESULT
WriteToVariant
(
VARIANT
&
aVariant
const
AttrType
&
aValue
)
{
SAFEARRAY
*
outputArr
=
SafeArrayCreateVector
(
VT_I4
0
static_cast
<
ULONG
>
(
aValue
.
size
(
)
)
)
;
if
(
!
outputArr
)
{
return
E_OUTOFMEMORY
;
}
LONG
index
=
0
;
for
(
auto
value
:
aValue
)
{
const
HRESULT
hr
=
SafeArrayPutElement
(
outputArr
&
index
&
value
)
;
if
(
FAILED
(
hr
)
)
{
SafeArrayDestroy
(
outputArr
)
;
return
hr
;
}
+
+
index
;
}
aVariant
.
vt
=
VT_ARRAY
|
VT_I4
;
aVariant
.
parray
=
outputArr
;
return
S_OK
;
}
}
;
template
<
>
struct
AttributeTraits
<
UIA_FontWeightAttributeId
>
{
using
AttrType
=
int32_t
;
static
Maybe
<
AttrType
>
GetValue
(
TextLeafPoint
aPoint
)
{
RefPtr
<
AccAttributes
>
attrs
=
aPoint
.
GetTextAttributes
(
)
;
if
(
!
attrs
)
{
return
{
}
;
}
return
attrs
-
>
GetAttribute
<
AttrType
>
(
nsGkAtoms
:
:
font_weight
)
;
}
static
AttrType
DefaultValue
(
)
{
return
FW_DONTCARE
;
}
static
HRESULT
WriteToVariant
(
VARIANT
&
aVariant
const
AttrType
&
aValue
)
{
aVariant
.
vt
=
VT_I4
;
aVariant
.
lVal
=
aValue
;
return
S_OK
;
}
}
;
template
<
>
struct
AttributeTraits
<
UIA_FontSizeAttributeId
>
{
using
AttrType
=
FontSize
;
static
Maybe
<
AttrType
>
GetValue
(
TextLeafPoint
aPoint
)
{
RefPtr
<
AccAttributes
>
attrs
=
aPoint
.
GetTextAttributes
(
)
;
if
(
!
attrs
)
{
return
{
}
;
}
return
attrs
-
>
GetAttribute
<
AttrType
>
(
nsGkAtoms
:
:
font_size
)
;
}
static
AttrType
DefaultValue
(
)
{
return
FontSize
{
0
}
;
}
static
HRESULT
WriteToVariant
(
VARIANT
&
aVariant
const
AttrType
&
aValue
)
{
aVariant
.
vt
=
VT_I4
;
aVariant
.
lVal
=
aValue
.
mValue
;
return
S_OK
;
}
}
;
template
<
>
struct
AttributeTraits
<
UIA_FontNameAttributeId
>
{
using
AttrType
=
RefPtr
<
nsAtom
>
;
static
Maybe
<
AttrType
>
GetValue
(
TextLeafPoint
aPoint
)
{
RefPtr
<
AccAttributes
>
attrs
=
aPoint
.
GetTextAttributes
(
)
;
if
(
!
attrs
)
{
return
{
}
;
}
return
attrs
-
>
GetAttribute
<
AttrType
>
(
nsGkAtoms
:
:
font_family
)
;
}
static
AttrType
DefaultValue
(
)
{
return
RefPtr
<
nsAtom
>
(
nsGkAtoms
:
:
_empty
)
;
}
static
HRESULT
WriteToVariant
(
VARIANT
&
aVariant
const
AttrType
&
aValue
)
{
if
(
!
aValue
)
{
return
E_INVALIDARG
;
}
BSTR
valueBStr
=
:
:
SysAllocString
(
aValue
-
>
GetUTF16String
(
)
)
;
if
(
!
valueBStr
)
{
return
E_OUTOFMEMORY
;
}
aVariant
.
vt
=
VT_BSTR
;
aVariant
.
bstrVal
=
valueBStr
;
return
S_OK
;
}
}
;
template
<
>
struct
AttributeTraits
<
UIA_IsItalicAttributeId
>
{
using
AttrType
=
bool
;
static
Maybe
<
AttrType
>
GetValue
(
TextLeafPoint
aPoint
)
{
RefPtr
<
AccAttributes
>
attrs
=
aPoint
.
GetTextAttributes
(
)
;
if
(
!
attrs
)
{
return
{
}
;
}
auto
atomResult
=
attrs
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
nsGkAtoms
:
:
font_style
)
;
if
(
atomResult
)
{
MOZ_ASSERT
(
*
atomResult
"
Atom
must
be
non
-
null
"
)
;
return
Some
(
(
*
atomResult
)
-
>
Equals
(
u
"
italic
"
_ns
)
)
;
}
return
{
}
;
}
static
AttrType
DefaultValue
(
)
{
return
false
;
}
static
HRESULT
WriteToVariant
(
VARIANT
&
aVariant
const
AttrType
&
aValue
)
{
aVariant
=
_variant_t
(
aValue
)
;
return
S_OK
;
}
}
;
template
<
>
struct
AttributeTraits
<
UIA_StyleIdAttributeId
>
{
using
AttrType
=
int32_t
;
static
Maybe
<
AttrType
>
GetValue
(
TextLeafPoint
aPoint
)
{
Accessible
*
acc
=
aPoint
.
mAcc
;
if
(
!
acc
|
|
!
acc
-
>
Parent
(
)
)
{
return
{
}
;
}
acc
=
acc
-
>
Parent
(
)
;
const
role
role
=
acc
-
>
Role
(
)
;
if
(
role
=
=
roles
:
:
HEADING
)
{
switch
(
acc
-
>
GetLevel
(
true
)
)
{
case
1
:
return
Some
(
StyleId_Heading1
)
;
case
2
:
return
Some
(
StyleId_Heading2
)
;
case
3
:
return
Some
(
StyleId_Heading3
)
;
case
4
:
return
Some
(
StyleId_Heading4
)
;
case
5
:
return
Some
(
StyleId_Heading5
)
;
case
6
:
return
Some
(
StyleId_Heading6
)
;
default
:
return
{
}
;
}
}
if
(
role
=
=
roles
:
:
BLOCKQUOTE
)
{
return
Some
(
StyleId_Quote
)
;
}
if
(
role
=
=
roles
:
:
EMPHASIS
)
{
return
Some
(
StyleId_Emphasis
)
;
}
return
{
}
;
}
static
AttrType
DefaultValue
(
)
{
return
0
;
}
static
HRESULT
WriteToVariant
(
VARIANT
&
aVariant
const
AttrType
&
aValue
)
{
aVariant
.
vt
=
VT_I4
;
aVariant
.
lVal
=
aValue
;
return
S_OK
;
}
}
;
template
<
>
struct
AttributeTraits
<
UIA_IsSubscriptAttributeId
>
{
using
AttrType
=
bool
;
static
Maybe
<
AttrType
>
GetValue
(
TextLeafPoint
aPoint
)
{
RefPtr
<
AccAttributes
>
attrs
=
aPoint
.
GetTextAttributes
(
)
;
if
(
!
attrs
)
{
return
{
}
;
}
auto
atomResult
=
attrs
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
nsGkAtoms
:
:
textPosition
)
;
if
(
atomResult
)
{
MOZ_ASSERT
(
*
atomResult
"
Atom
must
be
non
-
null
"
)
;
return
Some
(
*
atomResult
=
=
nsGkAtoms
:
:
sub
)
;
}
return
{
}
;
}
static
AttrType
DefaultValue
(
)
{
return
false
;
}
static
HRESULT
WriteToVariant
(
VARIANT
&
aVariant
const
AttrType
&
aValue
)
{
aVariant
=
_variant_t
(
aValue
)
;
return
S_OK
;
}
}
;
template
<
>
struct
AttributeTraits
<
UIA_IsSuperscriptAttributeId
>
{
using
AttrType
=
bool
;
static
Maybe
<
AttrType
>
GetValue
(
TextLeafPoint
aPoint
)
{
RefPtr
<
AccAttributes
>
attrs
=
aPoint
.
GetTextAttributes
(
)
;
if
(
!
attrs
)
{
return
{
}
;
}
auto
atomResult
=
attrs
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
nsGkAtoms
:
:
textPosition
)
;
if
(
atomResult
)
{
MOZ_ASSERT
(
*
atomResult
"
Atom
must
be
non
-
null
"
)
;
return
Some
(
(
*
atomResult
)
-
>
Equals
(
NS_ConvertASCIItoUTF16
(
"
super
"
)
)
)
;
}
return
{
}
;
}
static
AttrType
DefaultValue
(
)
{
return
false
;
}
static
HRESULT
WriteToVariant
(
VARIANT
&
aVariant
const
AttrType
&
aValue
)
{
aVariant
=
_variant_t
(
aValue
)
;
return
S_OK
;
}
}
;
template
<
>
struct
AttributeTraits
<
UIA_IsHiddenAttributeId
>
{
using
AttrType
=
bool
;
static
Maybe
<
AttrType
>
GetValue
(
TextLeafPoint
aPoint
)
{
if
(
!
aPoint
.
mAcc
)
{
return
{
}
;
}
const
uint64_t
state
=
aPoint
.
mAcc
-
>
State
(
)
;
return
Some
(
!
!
(
state
&
states
:
:
INVISIBLE
)
)
;
}
static
AttrType
DefaultValue
(
)
{
return
false
;
}
static
HRESULT
WriteToVariant
(
VARIANT
&
aVariant
const
AttrType
&
aValue
)
{
aVariant
=
_variant_t
(
aValue
)
;
return
S_OK
;
}
}
;
template
<
>
struct
AttributeTraits
<
UIA_IsReadOnlyAttributeId
>
{
using
AttrType
=
bool
;
static
Maybe
<
AttrType
>
GetValue
(
TextLeafPoint
aPoint
)
{
if
(
!
aPoint
.
mAcc
)
{
return
{
}
;
}
Accessible
*
acc
=
aPoint
.
mAcc
;
if
(
!
acc
-
>
IsHyperText
(
)
)
{
Accessible
*
parent
=
acc
-
>
Parent
(
)
;
if
(
parent
&
&
parent
-
>
IsHyperText
(
)
)
{
acc
=
parent
;
}
else
{
return
Some
(
true
)
;
}
}
const
uint64_t
state
=
acc
-
>
State
(
)
;
if
(
state
&
states
:
:
READONLY
)
{
return
Some
(
true
)
;
}
if
(
state
&
states
:
:
EDITABLE
)
{
return
Some
(
false
)
;
}
return
Some
(
true
)
;
}
static
AttrType
DefaultValue
(
)
{
return
false
;
}
static
HRESULT
WriteToVariant
(
VARIANT
&
aVariant
const
AttrType
&
aValue
)
{
aVariant
=
_variant_t
(
aValue
)
;
return
S_OK
;
}
}
;
}
