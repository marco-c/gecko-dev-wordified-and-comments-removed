#
include
"
UiaTextRange
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
TextLeafRange
.
h
"
namespace
mozilla
:
:
a11y
{
static
const
GUID
IID_UiaTextRange
=
{
0x74b8e664
0x4578
0x4b52
{
0x9c
0xbc
0x30
0xa7
0xa8
0x27
0x1a
0xe8
}
}
;
static
TextLeafPoint
GetEndpoint
(
TextLeafRange
&
aRange
enum
TextPatternRangeEndpoint
aEndpoint
)
{
if
(
aEndpoint
=
=
TextPatternRangeEndpoint_Start
)
{
return
aRange
.
Start
(
)
;
}
return
aRange
.
End
(
)
;
}
static
void
RemoveExcludedAccessiblesFromRange
(
TextLeafRange
&
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
TextLeafPoint
start
=
aRange
.
Start
(
)
;
TextLeafPoint
end
=
aRange
.
End
(
)
;
if
(
start
=
=
end
)
{
return
;
}
if
(
end
.
mOffset
!
=
0
)
{
return
;
}
end
=
end
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
)
;
+
+
end
.
mOffset
;
if
(
start
<
=
end
)
{
aRange
.
SetEnd
(
end
)
;
}
}
static
bool
IsUiaEmbeddedObject
(
const
Accessible
*
aAcc
)
{
if
(
aAcc
-
>
IsText
(
)
)
{
return
false
;
}
switch
(
aAcc
-
>
Role
(
)
)
{
case
roles
:
:
CONTENT_DELETION
:
case
roles
:
:
CONTENT_INSERTION
:
case
roles
:
:
EMPHASIS
:
case
roles
:
:
LANDMARK
:
case
roles
:
:
MARK
:
case
roles
:
:
NAVIGATION
:
case
roles
:
:
NOTE
:
case
roles
:
:
PARAGRAPH
:
case
roles
:
:
REGION
:
case
roles
:
:
SECTION
:
case
roles
:
:
STRONG
:
case
roles
:
:
SUBSCRIPT
:
case
roles
:
:
SUPERSCRIPT
:
case
roles
:
:
TEXT
:
case
roles
:
:
TEXT_CONTAINER
:
return
false
;
default
:
break
;
}
return
true
;
}
UiaTextRange
:
:
UiaTextRange
(
TextLeafRange
&
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
SetRange
(
aRange
)
;
}
void
UiaTextRange
:
:
SetRange
(
const
TextLeafRange
&
aRange
)
{
TextLeafPoint
start
=
aRange
.
Start
(
)
;
mStartAcc
=
MsaaAccessible
:
:
GetFrom
(
start
.
mAcc
)
;
MOZ_ASSERT
(
mStartAcc
)
;
mStartOffset
=
start
.
mOffset
;
TextLeafPoint
end
=
aRange
.
End
(
)
;
mEndAcc
=
MsaaAccessible
:
:
GetFrom
(
end
.
mAcc
)
;
MOZ_ASSERT
(
mEndAcc
)
;
mEndOffset
=
end
.
mOffset
;
mIsEndOfLineInsertionPoint
=
start
=
=
end
&
&
start
.
mIsEndOfLineInsertionPoint
;
}
TextLeafRange
UiaTextRange
:
:
GetRange
(
)
const
{
if
(
mIsEndOfLineInsertionPoint
)
{
MOZ_ASSERT
(
mStartAcc
=
=
mEndAcc
&
&
mStartOffset
=
=
mEndOffset
)
;
TextLeafPoint
point
(
mStartAcc
-
>
Acc
(
)
mStartOffset
)
;
point
.
mIsEndOfLineInsertionPoint
=
true
;
return
TextLeafRange
(
point
point
)
;
}
return
TextLeafRange
(
{
mStartAcc
-
>
Acc
(
)
mStartOffset
}
{
mEndAcc
-
>
Acc
(
)
mEndOffset
}
)
;
}
TextLeafRange
UiaTextRange
:
:
GetRangeFrom
(
ITextRangeProvider
*
aProvider
)
{
if
(
aProvider
)
{
RefPtr
<
UiaTextRange
>
uiaRange
;
aProvider
-
>
QueryInterface
(
IID_UiaTextRange
getter_AddRefs
(
uiaRange
)
)
;
if
(
uiaRange
)
{
return
uiaRange
-
>
GetRange
(
)
;
}
}
return
TextLeafRange
(
)
;
}
TextLeafPoint
UiaTextRange
:
:
FindBoundary
(
const
TextLeafPoint
&
aOrigin
enum
TextUnit
aUnit
nsDirection
aDirection
bool
aIncludeOrigin
)
{
if
(
aUnit
=
=
TextUnit_Page
|
|
aUnit
=
=
TextUnit_Document
)
{
Accessible
*
doc
=
nsAccUtils
:
:
DocumentFor
(
aOrigin
.
mAcc
)
;
if
(
aDirection
=
=
eDirPrevious
)
{
return
TextLeafPoint
(
doc
0
)
;
}
return
TextLeafPoint
(
doc
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
)
;
}
AccessibleTextBoundary
boundary
;
switch
(
aUnit
)
{
case
TextUnit_Character
:
boundary
=
nsIAccessibleText
:
:
BOUNDARY_CLUSTER
;
break
;
case
TextUnit_Word
:
boundary
=
nsIAccessibleText
:
:
BOUNDARY_WORD_START
;
break
;
case
TextUnit_Line
:
boundary
=
nsIAccessibleText
:
:
BOUNDARY_LINE_START
;
break
;
case
TextUnit_Paragraph
:
boundary
=
nsIAccessibleText
:
:
BOUNDARY_PARAGRAPH
;
break
;
default
:
return
TextLeafPoint
(
)
;
}
return
aOrigin
.
FindBoundary
(
boundary
aDirection
aIncludeOrigin
?
TextLeafPoint
:
:
BoundaryFlags
:
:
eIncludeOrigin
:
TextLeafPoint
:
:
BoundaryFlags
:
:
eDefaultBoundaryFlags
)
;
}
bool
UiaTextRange
:
:
MovePoint
(
TextLeafPoint
&
aPoint
enum
TextUnit
aUnit
const
int
aRequestedCount
int
&
aActualCount
)
{
aActualCount
=
0
;
const
nsDirection
direction
=
aRequestedCount
<
0
?
eDirPrevious
:
eDirNext
;
while
(
aActualCount
!
=
aRequestedCount
)
{
TextLeafPoint
oldPoint
=
aPoint
;
aPoint
=
FindBoundary
(
aPoint
aUnit
direction
)
;
if
(
!
aPoint
)
{
return
false
;
}
if
(
aPoint
=
=
oldPoint
)
{
break
;
}
direction
=
=
eDirPrevious
?
-
-
aActualCount
:
+
+
aActualCount
;
}
return
true
;
}
void
UiaTextRange
:
:
SetEndpoint
(
enum
TextPatternRangeEndpoint
aEndpoint
const
TextLeafPoint
&
aDest
)
{
TextLeafRange
origRange
=
GetRange
(
)
;
MOZ_ASSERT
(
origRange
)
;
if
(
aEndpoint
=
=
TextPatternRangeEndpoint_Start
)
{
TextLeafPoint
end
=
origRange
.
End
(
)
;
if
(
end
<
aDest
)
{
end
=
aDest
;
}
SetRange
(
{
aDest
end
}
)
;
}
else
{
TextLeafPoint
start
=
origRange
.
Start
(
)
;
if
(
aDest
<
start
)
{
start
=
aDest
;
}
SetRange
(
{
start
aDest
}
)
;
}
}
IMPL_IUNKNOWN2
(
UiaTextRange
ITextRangeProvider
UiaTextRange
)
STDMETHODIMP
UiaTextRange
:
:
Clone
(
__RPC__deref_out_opt
ITextRangeProvider
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
RefPtr
uiaRange
=
new
UiaTextRange
(
range
)
;
uiaRange
.
forget
(
aRetVal
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
Compare
(
__RPC__in_opt
ITextRangeProvider
*
aRange
__RPC__out
BOOL
*
aRetVal
)
{
if
(
!
aRange
|
|
!
aRetVal
)
{
return
E_INVALIDARG
;
}
*
aRetVal
=
GetRange
(
)
=
=
GetRangeFrom
(
aRange
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
CompareEndpoints
(
enum
TextPatternRangeEndpoint
aEndpoint
__RPC__in_opt
ITextRangeProvider
*
aTargetRange
enum
TextPatternRangeEndpoint
aTargetEndpoint
__RPC__out
int
*
aRetVal
)
{
if
(
!
aTargetRange
|
|
!
aRetVal
)
{
return
E_INVALIDARG
;
}
TextLeafRange
origRange
=
GetRange
(
)
;
if
(
!
origRange
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafPoint
origPoint
=
GetEndpoint
(
origRange
aEndpoint
)
;
TextLeafRange
targetRange
=
GetRangeFrom
(
aTargetRange
)
;
if
(
!
targetRange
)
{
return
E_INVALIDARG
;
}
TextLeafPoint
targetPoint
=
GetEndpoint
(
targetRange
aTargetEndpoint
)
;
if
(
origPoint
=
=
targetPoint
)
{
*
aRetVal
=
0
;
}
else
if
(
origPoint
<
targetPoint
)
{
*
aRetVal
=
-
1
;
}
else
{
*
aRetVal
=
1
;
}
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
ExpandToEnclosingUnit
(
enum
TextUnit
aUnit
)
{
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafPoint
origin
=
range
.
Start
(
)
;
TextLeafPoint
start
=
FindBoundary
(
origin
aUnit
eDirPrevious
true
)
;
if
(
!
start
)
{
return
E_FAIL
;
}
TextLeafPoint
end
=
FindBoundary
(
origin
aUnit
eDirNext
)
;
SetRange
(
{
start
end
}
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
FindAttribute
(
TEXTATTRIBUTEID
aAttributeId
VARIANT
aVal
BOOL
aBackward
__RPC__deref_out_opt
ITextRangeProvider
*
*
aRetVal
)
{
return
E_NOTIMPL
;
}
STDMETHODIMP
UiaTextRange
:
:
FindText
(
__RPC__in
BSTR
aText
BOOL
aBackward
BOOL
aIgnoreCase
__RPC__deref_out_opt
ITextRangeProvider
*
*
aRetVal
)
{
return
E_NOTIMPL
;
}
STDMETHODIMP
UiaTextRange
:
:
GetAttributeValue
(
TEXTATTRIBUTEID
aAttributeId
__RPC__out
VARIANT
*
aRetVal
)
{
return
E_NOTIMPL
;
}
STDMETHODIMP
UiaTextRange
:
:
GetBoundingRectangles
(
__RPC__deref_out_opt
SAFEARRAY
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
*
aRetVal
=
nullptr
;
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
const
nsTArray
<
LayoutDeviceIntRect
>
lineRects
=
range
.
LineRects
(
)
;
SAFEARRAY
*
rectsVec
=
SafeArrayCreateVector
(
VT_R8
0
lineRects
.
Length
(
)
*
4
)
;
if
(
!
rectsVec
)
{
return
E_OUTOFMEMORY
;
}
if
(
lineRects
.
IsEmpty
(
)
)
{
*
aRetVal
=
rectsVec
;
return
S_OK
;
}
double
*
safeArrayData
=
nullptr
;
HRESULT
hr
=
SafeArrayAccessData
(
rectsVec
reinterpret_cast
<
void
*
*
>
(
&
safeArrayData
)
)
;
if
(
FAILED
(
hr
)
|
|
!
safeArrayData
)
{
SafeArrayDestroy
(
rectsVec
)
;
return
E_FAIL
;
}
for
(
size_t
index
=
0
;
index
<
lineRects
.
Length
(
)
;
+
+
index
)
{
const
LayoutDeviceIntRect
&
lineRect
=
lineRects
[
index
]
;
safeArrayData
[
index
*
4
+
0
]
=
static_cast
<
double
>
(
lineRect
.
x
)
;
safeArrayData
[
index
*
4
+
1
]
=
static_cast
<
double
>
(
lineRect
.
y
)
;
safeArrayData
[
index
*
4
+
2
]
=
static_cast
<
double
>
(
lineRect
.
width
)
;
safeArrayData
[
index
*
4
+
3
]
=
static_cast
<
double
>
(
lineRect
.
height
)
;
}
hr
=
SafeArrayUnaccessData
(
rectsVec
)
;
if
(
FAILED
(
hr
)
)
{
SafeArrayDestroy
(
rectsVec
)
;
return
E_FAIL
;
}
*
aRetVal
=
rectsVec
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
GetEnclosingElement
(
__RPC__deref_out_opt
IRawElementProviderSimple
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
*
aRetVal
=
nullptr
;
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
RemoveExcludedAccessiblesFromRange
(
range
)
;
if
(
Accessible
*
enclosing
=
range
.
Start
(
)
.
mAcc
-
>
GetClosestCommonInclusiveAncestor
(
range
.
End
(
)
.
mAcc
)
)
{
RefPtr
<
IRawElementProviderSimple
>
uia
=
MsaaAccessible
:
:
GetFrom
(
enclosing
)
;
uia
.
forget
(
aRetVal
)
;
}
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
GetText
(
int
aMaxLength
__RPC__deref_out_opt
BSTR
*
aRetVal
)
{
if
(
!
aRetVal
|
|
aMaxLength
<
-
1
)
{
return
E_INVALIDARG
;
}
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
nsAutoString
text
;
for
(
TextLeafRange
segment
:
range
)
{
TextLeafPoint
start
=
segment
.
Start
(
)
;
int
segmentLength
=
segment
.
End
(
)
.
mOffset
-
start
.
mOffset
;
if
(
aMaxLength
>
=
0
)
{
const
int
remaining
=
aMaxLength
-
text
.
Length
(
)
;
if
(
segmentLength
>
remaining
)
{
segmentLength
=
remaining
;
}
}
start
.
mAcc
-
>
AppendTextTo
(
text
start
.
mOffset
segmentLength
)
;
if
(
aMaxLength
>
=
0
&
&
static_cast
<
int32_t
>
(
text
.
Length
(
)
)
>
=
aMaxLength
)
{
break
;
}
}
*
aRetVal
=
:
:
SysAllocString
(
text
.
get
(
)
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
Move
(
enum
TextUnit
aUnit
int
aCount
__RPC__out
int
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafPoint
start
=
range
.
Start
(
)
;
const
bool
wasCollapsed
=
start
=
=
range
.
End
(
)
;
if
(
!
wasCollapsed
)
{
start
=
FindBoundary
(
start
aUnit
eDirPrevious
true
)
;
}
if
(
!
MovePoint
(
start
aUnit
aCount
*
aRetVal
)
)
{
return
E_FAIL
;
}
if
(
wasCollapsed
)
{
SetRange
(
{
start
start
}
)
;
}
else
{
TextLeafPoint
end
=
FindBoundary
(
start
aUnit
eDirNext
)
;
if
(
end
=
=
start
)
{
start
=
FindBoundary
(
start
aUnit
eDirPrevious
)
;
-
-
*
aRetVal
;
}
SetRange
(
{
start
end
}
)
;
}
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
MoveEndpointByUnit
(
enum
TextPatternRangeEndpoint
aEndpoint
enum
TextUnit
aUnit
int
aCount
__RPC__out
int
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafPoint
point
=
GetEndpoint
(
range
aEndpoint
)
;
if
(
!
MovePoint
(
point
aUnit
aCount
*
aRetVal
)
)
{
return
E_FAIL
;
}
SetEndpoint
(
aEndpoint
point
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
MoveEndpointByRange
(
enum
TextPatternRangeEndpoint
aEndpoint
__RPC__in_opt
ITextRangeProvider
*
aTargetRange
enum
TextPatternRangeEndpoint
aTargetEndpoint
)
{
if
(
!
aTargetRange
)
{
return
E_INVALIDARG
;
}
TextLeafRange
origRange
=
GetRange
(
)
;
if
(
!
origRange
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafRange
targetRange
=
GetRangeFrom
(
aTargetRange
)
;
if
(
!
targetRange
)
{
return
E_INVALIDARG
;
}
TextLeafPoint
dest
=
GetEndpoint
(
targetRange
aTargetEndpoint
)
;
SetEndpoint
(
aEndpoint
dest
)
;
return
S_OK
;
}
STDMETHODIMP
UiaTextRange
:
:
Select
(
)
{
return
E_NOTIMPL
;
}
STDMETHODIMP
UiaTextRange
:
:
AddToSelection
(
)
{
return
E_NOTIMPL
;
}
STDMETHODIMP
UiaTextRange
:
:
RemoveFromSelection
(
)
{
return
E_NOTIMPL
;
}
STDMETHODIMP
UiaTextRange
:
:
ScrollIntoView
(
BOOL
aAlignToTop
)
{
return
E_NOTIMPL
;
}
STDMETHODIMP
UiaTextRange
:
:
GetChildren
(
__RPC__deref_out_opt
SAFEARRAY
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
*
aRetVal
=
nullptr
;
TextLeafRange
range
=
GetRange
(
)
;
if
(
!
range
)
{
return
CO_E_OBJNOTCONNECTED
;
}
RemoveExcludedAccessiblesFromRange
(
range
)
;
Accessible
*
startAcc
=
range
.
Start
(
)
.
mAcc
;
Accessible
*
endAcc
=
range
.
End
(
)
.
mAcc
;
Accessible
*
common
=
startAcc
-
>
GetClosestCommonInclusiveAncestor
(
endAcc
)
;
if
(
!
common
)
{
return
S_OK
;
}
int32_t
startIndex
=
-
1
;
if
(
startAcc
=
=
common
)
{
startIndex
=
0
;
}
else
{
Accessible
*
child
=
startAcc
;
for
(
;
;
)
{
Accessible
*
parent
=
child
-
>
Parent
(
)
;
if
(
parent
=
=
common
)
{
startIndex
=
child
-
>
IndexInParent
(
)
;
break
;
}
child
=
parent
;
}
MOZ_ASSERT
(
startIndex
>
=
0
)
;
}
int32_t
endIndex
=
-
1
;
if
(
endAcc
=
=
common
)
{
endIndex
=
static_cast
<
int32_t
>
(
common
-
>
ChildCount
(
)
)
-
1
;
}
else
{
Accessible
*
child
=
endAcc
;
for
(
;
;
)
{
Accessible
*
parent
=
child
-
>
Parent
(
)
;
if
(
parent
=
=
common
)
{
endIndex
=
child
-
>
IndexInParent
(
)
;
break
;
}
child
=
parent
;
}
MOZ_ASSERT
(
endIndex
>
=
0
)
;
}
AutoTArray
<
Accessible
*
30
>
children
;
for
(
int32_t
i
=
startIndex
;
i
<
=
endIndex
;
+
+
i
)
{
Accessible
*
child
=
common
-
>
ChildAt
(
static_cast
<
uint32_t
>
(
i
)
)
;
if
(
IsUiaEmbeddedObject
(
child
)
)
{
children
.
AppendElement
(
child
)
;
}
}
*
aRetVal
=
AccessibleArrayToUiaArray
(
children
)
;
return
S_OK
;
}
}
