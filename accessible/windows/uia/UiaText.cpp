#
include
"
UiaText
.
h
"
#
include
"
MsaaAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
States
.
h
"
#
include
"
TextLeafRange
.
h
"
#
include
"
UiaTextRange
.
h
"
namespace
mozilla
:
:
a11y
{
static
SAFEARRAY
*
TextLeafRangesToUiaRanges
(
const
nsTArray
<
TextLeafRange
>
&
aRanges
)
{
SAFEARRAY
*
uiaRanges
=
SafeArrayCreateVector
(
VT_UNKNOWN
0
aRanges
.
Length
(
)
)
;
LONG
indices
[
1
]
=
{
0
}
;
for
(
const
TextLeafRange
&
range
:
aRanges
)
{
UiaTextRange
*
uiaRange
=
new
UiaTextRange
(
range
)
;
SafeArrayPutElement
(
uiaRanges
indices
uiaRange
)
;
+
+
indices
[
0
]
;
}
return
uiaRanges
;
}
IMPL_IUNKNOWN1
(
UiaText
ITextProvider
)
UiaText
:
:
UiaText
(
MsaaAccessible
*
aMsaa
)
:
mMsaa
(
aMsaa
)
{
}
Accessible
*
UiaText
:
:
Acc
(
)
const
{
return
mMsaa
-
>
Acc
(
)
;
}
STDMETHODIMP
UiaText
:
:
GetSelection
(
__RPC__deref_out_opt
SAFEARRAY
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
Accessible
*
acc
=
Acc
(
)
;
if
(
!
acc
)
{
return
CO_E_OBJNOTCONNECTED
;
}
AutoTArray
<
TextLeafRange
1
>
ranges
;
TextLeafRange
:
:
GetSelection
(
acc
ranges
)
;
if
(
ranges
.
IsEmpty
(
)
)
{
if
(
TextLeafPoint
caret
=
TextLeafPoint
:
:
GetCaret
(
acc
)
)
{
ranges
.
EmplaceBack
(
caret
caret
)
;
}
}
*
aRetVal
=
TextLeafRangesToUiaRanges
(
ranges
)
;
return
S_OK
;
}
STDMETHODIMP
UiaText
:
:
GetVisibleRanges
(
__RPC__deref_out_opt
SAFEARRAY
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
Accessible
*
acc
=
Acc
(
)
;
if
(
!
acc
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafRange
fullRange
=
TextLeafRange
:
:
FromAccessible
(
acc
)
;
nsTArray
<
TextLeafRange
>
ranges
=
fullRange
.
VisibleLines
(
acc
)
;
*
aRetVal
=
TextLeafRangesToUiaRanges
(
ranges
)
;
return
S_OK
;
}
STDMETHODIMP
UiaText
:
:
RangeFromChild
(
__RPC__in_opt
IRawElementProviderSimple
*
aChildElement
__RPC__deref_out_opt
ITextRangeProvider
*
*
aRetVal
)
{
if
(
!
aChildElement
|
|
!
aRetVal
)
{
return
E_INVALIDARG
;
}
*
aRetVal
=
nullptr
;
Accessible
*
acc
=
Acc
(
)
;
if
(
!
acc
)
{
return
CO_E_OBJNOTCONNECTED
;
}
Accessible
*
child
=
MsaaAccessible
:
:
GetAccessibleFrom
(
aChildElement
)
;
if
(
!
child
|
|
!
acc
-
>
IsAncestorOf
(
child
)
)
{
return
E_INVALIDARG
;
}
TextLeafRange
range
=
TextLeafRange
:
:
FromAccessible
(
child
)
;
RefPtr
uiaRange
=
new
UiaTextRange
(
range
)
;
uiaRange
.
forget
(
aRetVal
)
;
return
S_OK
;
}
STDMETHODIMP
UiaText
:
:
RangeFromPoint
(
struct
UiaPoint
aPoint
__RPC__deref_out_opt
ITextRangeProvider
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
*
aRetVal
=
nullptr
;
Accessible
*
acc
=
Acc
(
)
;
if
(
!
acc
)
{
return
CO_E_OBJNOTCONNECTED
;
}
Accessible
*
child
=
acc
-
>
ChildAtPoint
(
aPoint
.
x
aPoint
.
y
Accessible
:
:
EWhichChildAtPoint
:
:
DeepestChild
)
;
if
(
!
child
)
{
return
E_INVALIDARG
;
}
TextLeafRange
leafRange
=
TextLeafRange
:
:
FromAccessible
(
child
)
;
TextLeafPoint
closestPoint
=
leafRange
.
TextLeafPointAtScreenPoint
(
aPoint
.
x
aPoint
.
y
)
;
TextLeafRange
range
{
closestPoint
closestPoint
}
;
RefPtr
uiaRange
=
new
UiaTextRange
(
range
)
;
uiaRange
.
forget
(
aRetVal
)
;
return
S_OK
;
}
STDMETHODIMP
UiaText
:
:
get_DocumentRange
(
__RPC__deref_out_opt
ITextRangeProvider
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
Accessible
*
acc
=
Acc
(
)
;
if
(
!
acc
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafRange
range
=
TextLeafRange
:
:
FromAccessible
(
acc
)
;
RefPtr
uiaRange
=
new
UiaTextRange
(
range
)
;
uiaRange
.
forget
(
aRetVal
)
;
return
S_OK
;
}
STDMETHODIMP
UiaText
:
:
get_SupportedTextSelection
(
__RPC__out
enum
SupportedTextSelection
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
Accessible
*
acc
=
Acc
(
)
;
if
(
!
acc
)
{
return
CO_E_OBJNOTCONNECTED
;
}
if
(
acc
-
>
State
(
)
&
states
:
:
SELECTABLE_TEXT
)
{
*
aRetVal
=
SupportedTextSelection_Multiple
;
}
else
{
*
aRetVal
=
SupportedTextSelection_None
;
}
return
S_OK
;
}
}
