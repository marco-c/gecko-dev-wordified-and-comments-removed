#
include
"
UiaText
.
h
"
#
include
"
ia2AccessibleHypertext
.
h
"
#
include
"
mozilla
/
a11y
/
States
.
h
"
#
include
"
TextLeafRange
.
h
"
#
include
"
UiaTextRange
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
a11y
;
Accessible
*
UiaText
:
:
Acc
(
)
const
{
auto
*
hyp
=
static_cast
<
const
ia2AccessibleHypertext
*
>
(
this
)
;
return
hyp
-
>
Acc
(
)
;
}
STDMETHODIMP
UiaText
:
:
GetSelection
(
__RPC__deref_out_opt
SAFEARRAY
*
*
aRetVal
)
{
return
E_NOTIMPL
;
}
STDMETHODIMP
UiaText
:
:
GetVisibleRanges
(
__RPC__deref_out_opt
SAFEARRAY
*
*
aRetVal
)
{
return
E_NOTIMPL
;
}
STDMETHODIMP
UiaText
:
:
RangeFromChild
(
__RPC__in_opt
IRawElementProviderSimple
*
childElement
__RPC__deref_out_opt
ITextRangeProvider
*
*
aRetVal
)
{
return
E_NOTIMPL
;
}
STDMETHODIMP
UiaText
:
:
RangeFromPoint
(
struct
UiaPoint
point
__RPC__deref_out_opt
ITextRangeProvider
*
*
aRetVal
)
{
return
E_NOTIMPL
;
}
STDMETHODIMP
UiaText
:
:
get_DocumentRange
(
__RPC__deref_out_opt
ITextRangeProvider
*
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
Accessible
*
acc
=
Acc
(
)
;
if
(
!
acc
)
{
return
CO_E_OBJNOTCONNECTED
;
}
TextLeafRange
range
(
{
acc
0
}
{
acc
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
}
)
;
RefPtr
uiaRange
=
new
UiaTextRange
(
range
)
;
uiaRange
.
forget
(
aRetVal
)
;
return
S_OK
;
}
STDMETHODIMP
UiaText
:
:
get_SupportedTextSelection
(
__RPC__out
enum
SupportedTextSelection
*
aRetVal
)
{
if
(
!
aRetVal
)
{
return
E_INVALIDARG
;
}
Accessible
*
acc
=
Acc
(
)
;
if
(
!
acc
)
{
return
CO_E_OBJNOTCONNECTED
;
}
if
(
acc
-
>
State
(
)
&
states
:
:
SELECTABLE_TEXT
)
{
*
aRetVal
=
SupportedTextSelection_Multiple
;
}
else
{
*
aRetVal
=
SupportedTextSelection_None
;
}
return
S_OK
;
}
