"
use
strict
"
;
const
CURRENT_FILE_DIR
=
"
/
browser
/
accessible
/
tests
/
browser
/
"
;
const
CURRENT_DIR
=
chrome
:
/
/
mochitests
/
content
{
CURRENT_FILE_DIR
}
;
const
MOCHITESTS_DIR
=
"
chrome
:
/
/
mochitests
/
content
/
a11y
/
accessible
/
tests
/
mochitest
/
"
;
const
CURRENT_CONTENT_DIR
=
http
:
/
/
example
.
com
{
CURRENT_FILE_DIR
}
;
const
LOADED_CONTENT_SCRIPTS
=
new
Map
(
)
;
const
DEFAULT_CONTENT_DOC_BODY_ID
=
"
body
"
;
const
DEFAULT_IFRAME_ID
=
"
default
-
iframe
-
id
"
;
const
DEFAULT_IFRAME_DOC_BODY_ID
=
"
default
-
iframe
-
body
-
id
"
;
const
HTML_MIME_TYPE
=
"
text
/
html
"
;
const
XHTML_MIME_TYPE
=
"
application
/
xhtml
+
xml
"
;
function
loadHTMLFromFile
(
path
)
{
const
testHTMLFile
=
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
;
const
dirs
=
path
.
split
(
"
/
"
)
;
for
(
let
i
=
0
;
i
<
dirs
.
length
;
i
+
+
)
{
testHTMLFile
.
append
(
dirs
[
i
]
)
;
}
const
testHTMLFileStream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
testHTMLFileStream
.
init
(
testHTMLFile
-
1
0
0
)
;
const
testHTML
=
NetUtil
.
readInputStreamToString
(
testHTMLFileStream
testHTMLFileStream
.
available
(
)
)
;
return
testHTML
;
}
let
gIsIframe
=
false
;
let
gIsRemoteIframe
=
false
;
function
currentContentDoc
(
)
{
return
gIsIframe
?
DEFAULT_IFRAME_DOC_BODY_ID
:
DEFAULT_CONTENT_DOC_BODY_ID
;
}
function
matchContentDoc
(
event
)
{
return
getAccessibleDOMNodeID
(
event
.
accessible
)
=
=
=
currentContentDoc
(
)
;
}
let
Logger
=
{
dumpToConsole
:
false
dumpToAppConsole
:
false
get
enabled
(
)
{
return
this
.
dumpToConsole
|
|
this
.
dumpToAppConsole
;
}
log
(
msg
)
{
if
(
this
.
enabled
)
{
this
.
logToConsole
(
msg
)
;
this
.
logToAppConsole
(
msg
)
;
}
}
logToConsole
(
msg
)
{
if
(
this
.
dumpToConsole
)
{
dump
(
\
n
{
msg
}
\
n
)
;
}
}
logToAppConsole
(
msg
)
{
if
(
this
.
dumpToAppConsole
)
{
Services
.
console
.
logStringMessage
(
{
msg
}
)
;
}
}
}
;
function
invokeSetAttribute
(
browser
id
attr
value
)
{
if
(
value
)
{
Logger
.
log
(
Setting
{
attr
}
attribute
to
{
value
}
for
node
with
id
:
{
id
}
)
;
}
else
{
Logger
.
log
(
Removing
{
attr
}
attribute
from
node
with
id
:
{
id
}
)
;
}
return
invokeContentTask
(
browser
[
id
attr
value
]
(
contentId
contentAttr
contentValue
)
=
>
{
let
elm
=
content
.
document
.
getElementById
(
contentId
)
;
if
(
contentValue
)
{
elm
.
setAttribute
(
contentAttr
contentValue
)
;
}
else
{
elm
.
removeAttribute
(
contentAttr
)
;
}
}
)
;
}
function
invokeSetStyle
(
browser
id
style
value
)
{
if
(
value
)
{
Logger
.
log
(
Setting
{
style
}
style
to
{
value
}
for
node
with
id
:
{
id
}
)
;
}
else
{
Logger
.
log
(
Removing
{
style
}
style
from
node
with
id
:
{
id
}
)
;
}
return
invokeContentTask
(
browser
[
id
style
value
]
(
contentId
contentStyle
contentValue
)
=
>
{
const
elm
=
content
.
document
.
getElementById
(
contentId
)
;
if
(
contentValue
)
{
elm
.
style
[
contentStyle
]
=
contentValue
;
}
else
{
delete
elm
.
style
[
contentStyle
]
;
}
}
)
;
}
function
invokeFocus
(
browser
id
)
{
Logger
.
log
(
Setting
focus
on
a
node
with
id
:
{
id
}
)
;
return
invokeContentTask
(
browser
[
id
]
contentId
=
>
{
const
elm
=
content
.
document
.
getElementById
(
contentId
)
;
if
(
elm
.
editor
)
{
elm
.
selectionStart
=
elm
.
selectionEnd
=
elm
.
value
.
length
;
}
elm
.
focus
(
)
;
}
)
;
}
function
getContentDPR
(
browser
)
{
return
invokeContentTask
(
browser
[
]
(
)
=
>
content
.
window
.
devicePixelRatio
)
;
}
function
invokeContentTask
(
browser
args
task
)
{
return
SpecialPowers
.
spawn
(
browser
[
DEFAULT_IFRAME_ID
task
.
toString
(
)
.
.
.
args
]
(
iframeId
contentTask
.
.
.
contentArgs
)
=
>
{
const
runnableTask
=
eval
(
(
(
)
=
>
{
return
(
{
contentTask
}
)
;
}
)
(
)
;
)
;
const
frame
=
content
.
document
.
getElementById
(
iframeId
)
;
return
frame
?
SpecialPowers
.
spawn
(
frame
contentArgs
runnableTask
)
:
runnableTask
.
call
(
this
.
.
.
contentArgs
)
;
}
)
;
}
async
function
comparePIDs
(
browser
isRemote
)
{
function
getProcessID
(
)
{
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
return
Services
.
appinfo
.
processID
;
}
const
contentPID
=
await
SpecialPowers
.
spawn
(
browser
[
]
getProcessID
)
;
const
iframePID
=
await
invokeContentTask
(
browser
[
]
getProcessID
)
;
is
(
isRemote
contentPID
!
=
=
iframePID
isRemote
?
"
Remote
IFRAME
is
in
a
different
process
.
"
:
"
IFRAME
is
in
the
same
process
.
"
)
;
}
function
loadScripts
(
.
.
.
scripts
)
{
for
(
let
script
of
scripts
)
{
let
path
=
typeof
script
=
=
=
"
string
"
?
{
CURRENT_DIR
}
{
script
}
:
{
script
.
dir
}
{
script
.
name
}
;
Services
.
scriptloader
.
loadSubScript
(
path
this
)
;
}
}
async
function
loadContentScripts
(
target
.
.
.
scripts
)
{
for
(
let
script
of
scripts
)
{
let
contentScript
;
if
(
typeof
script
=
=
=
"
string
"
)
{
contentScript
=
{
CURRENT_DIR
}
{
script
}
;
}
else
{
contentScript
=
{
script
.
dir
}
{
script
.
name
}
;
}
let
loadedScriptSet
=
LOADED_CONTENT_SCRIPTS
.
get
(
contentScript
)
;
if
(
!
loadedScriptSet
)
{
loadedScriptSet
=
new
WeakSet
(
)
;
LOADED_CONTENT_SCRIPTS
.
set
(
contentScript
loadedScriptSet
)
;
}
else
if
(
loadedScriptSet
.
has
(
target
)
)
{
continue
;
}
await
SpecialPowers
.
spawn
(
target
[
contentScript
]
async
_contentScript
=
>
{
ChromeUtils
.
import
(
_contentScript
content
.
window
)
;
}
)
;
loadedScriptSet
.
add
(
target
)
;
}
}
function
attrsToString
(
attrs
)
{
return
Object
.
entries
(
attrs
)
.
map
(
(
[
attr
value
]
)
=
>
{
attr
}
=
{
JSON
.
stringify
(
value
)
}
)
.
join
(
"
"
)
;
}
function
wrapWithIFrame
(
doc
options
=
{
}
)
{
let
src
;
let
{
iframeAttrs
=
{
}
iframeDocBodyAttrs
=
{
}
}
=
options
;
iframeDocBodyAttrs
=
{
id
:
DEFAULT_IFRAME_DOC_BODY_ID
.
.
.
iframeDocBodyAttrs
}
;
if
(
options
.
remoteIframe
)
{
const
srcURL
=
new
URL
(
http
:
/
/
example
.
net
/
document
-
builder
.
sjs
)
;
if
(
doc
.
endsWith
(
"
html
"
)
)
{
srcURL
.
searchParams
.
append
(
"
file
"
{
CURRENT_FILE_DIR
}
{
doc
}
)
;
}
else
{
srcURL
.
searchParams
.
append
(
"
html
"
<
html
>
<
head
>
<
meta
charset
=
"
utf
-
8
"
/
>
<
title
>
Accessibility
Fission
Test
<
/
title
>
<
/
head
>
<
body
{
attrsToString
(
iframeDocBodyAttrs
)
}
>
{
doc
}
<
/
body
>
<
/
html
>
)
;
}
src
=
srcURL
.
href
;
}
else
{
const
mimeType
=
doc
.
endsWith
(
"
xhtml
"
)
?
XHTML_MIME_TYPE
:
HTML_MIME_TYPE
;
if
(
doc
.
endsWith
(
"
html
"
)
)
{
doc
=
loadHTMLFromFile
(
{
CURRENT_FILE_DIR
}
{
doc
}
)
;
doc
=
doc
.
replace
(
/
<
body
[
.
\
s
\
S
]
*
?
>
/
<
body
{
attrsToString
(
iframeDocBodyAttrs
)
}
>
)
;
}
else
{
doc
=
<
body
{
attrsToString
(
iframeDocBodyAttrs
)
}
>
{
doc
}
<
/
body
>
;
}
src
=
data
:
{
mimeType
}
;
charset
=
utf
-
8
{
encodeURIComponent
(
doc
)
}
;
}
iframeAttrs
=
{
id
:
DEFAULT_IFRAME_ID
src
.
.
.
iframeAttrs
}
;
return
<
iframe
{
attrsToString
(
iframeAttrs
)
}
/
>
;
}
function
snippetToURL
(
doc
options
=
{
}
)
{
const
{
contentDocBodyAttrs
=
{
}
}
=
options
;
const
attrs
=
{
id
:
DEFAULT_CONTENT_DOC_BODY_ID
.
.
.
contentDocBodyAttrs
}
;
if
(
gIsIframe
)
{
doc
=
wrapWithIFrame
(
doc
options
)
;
}
const
fullDoc
=
<
html
>
<
head
>
<
meta
charset
=
"
utf
-
8
"
/
>
<
title
>
Accessibility
Test
<
/
title
>
<
/
head
>
<
body
{
attrsToString
(
attrs
)
}
>
{
doc
}
<
/
body
>
<
/
html
>
;
if
(
options
.
chrome
)
{
const
url
=
new
URL
(
{
CURRENT_DIR
}
chrome
-
document
-
builder
.
html
)
;
url
.
searchParams
.
append
(
"
html
"
fullDoc
)
;
return
url
.
href
;
}
const
encodedDoc
=
encodeURIComponent
(
fullDoc
)
;
return
data
:
text
/
html
;
charset
=
utf
-
8
{
encodedDoc
}
;
}
function
accessibleTask
(
doc
task
options
=
{
}
)
{
return
async
function
(
)
{
gIsRemoteIframe
=
options
.
remoteIframe
;
gIsIframe
=
options
.
iframe
|
|
gIsRemoteIframe
;
let
url
;
if
(
options
.
chrome
&
&
doc
.
endsWith
(
"
html
"
)
)
{
url
=
{
CURRENT_DIR
}
{
doc
}
;
}
else
if
(
!
options
.
chrome
&
&
doc
.
endsWith
(
"
html
"
)
&
&
!
gIsIframe
)
{
url
=
{
CURRENT_CONTENT_DIR
}
{
doc
}
;
}
else
{
url
=
snippetToURL
(
doc
options
)
;
}
registerCleanupFunction
(
(
)
=
>
{
for
(
let
observer
of
Services
.
obs
.
enumerateObservers
(
"
accessible
-
event
"
)
)
{
Services
.
obs
.
removeObserver
(
observer
"
accessible
-
event
"
)
;
}
}
)
;
let
onContentDocLoad
;
if
(
!
options
.
chrome
)
{
onContentDocLoad
=
waitForEvent
(
EVENT_DOCUMENT_LOAD_COMPLETE
DEFAULT_CONTENT_DOC_BODY_ID
)
;
}
let
onIframeDocLoad
;
if
(
options
.
remoteIframe
&
&
!
options
.
skipFissionDocLoad
)
{
onIframeDocLoad
=
waitForEvent
(
EVENT_DOCUMENT_LOAD_COMPLETE
DEFAULT_IFRAME_DOC_BODY_ID
)
;
}
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
}
async
function
(
browser
)
{
registerCleanupFunction
(
(
)
=
>
{
if
(
browser
)
{
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
tab
&
&
!
tab
.
closing
&
&
tab
.
linkedBrowser
)
{
gBrowser
.
removeTab
(
tab
)
;
}
}
}
)
;
await
SimpleTest
.
promiseFocus
(
browser
)
;
await
loadContentScripts
(
browser
"
Common
.
jsm
"
)
;
if
(
options
.
chrome
)
{
ok
(
!
browser
.
isRemoteBrowser
"
Not
remote
browser
"
)
;
}
else
if
(
Services
.
appinfo
.
browserTabsRemoteAutostart
)
{
ok
(
browser
.
isRemoteBrowser
"
Actually
remote
browser
"
)
;
}
let
docAccessible
;
if
(
options
.
chrome
)
{
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
docAccessible
=
getAccessible
(
browser
.
contentWindow
.
document
)
;
if
(
!
docAccessible
)
{
return
false
;
}
const
state
=
{
}
;
docAccessible
.
getState
(
state
{
}
)
;
return
!
(
state
.
value
&
STATE_BUSY
)
;
}
)
;
}
else
{
(
{
accessible
:
docAccessible
}
=
await
onContentDocLoad
)
;
}
let
iframeDocAccessible
;
if
(
gIsIframe
)
{
if
(
!
options
.
skipFissionDocLoad
)
{
await
comparePIDs
(
browser
options
.
remoteIframe
)
;
iframeDocAccessible
=
onIframeDocLoad
?
(
await
onIframeDocLoad
)
.
accessible
:
findAccessibleChildByID
(
docAccessible
DEFAULT_IFRAME_ID
)
.
firstChild
;
}
}
await
task
(
browser
iframeDocAccessible
|
|
docAccessible
iframeDocAccessible
&
&
docAccessible
)
;
}
)
;
}
;
}
function
addAccessibleTask
(
doc
task
options
=
{
}
)
{
const
{
topLevel
=
true
chrome
=
false
iframe
=
false
remoteIframe
=
false
}
=
options
;
if
(
topLevel
)
{
add_task
(
accessibleTask
(
doc
task
{
.
.
.
options
chrome
:
false
iframe
:
false
remoteIframe
:
false
}
)
)
;
}
if
(
chrome
)
{
add_task
(
accessibleTask
(
doc
task
{
.
.
.
options
topLevel
:
false
iframe
:
false
remoteIframe
:
false
}
)
)
;
}
if
(
iframe
)
{
add_task
(
accessibleTask
(
doc
task
{
.
.
.
options
topLevel
:
false
chrome
:
false
remoteIframe
:
false
}
)
)
;
}
if
(
gFissionBrowser
&
&
remoteIframe
)
{
add_task
(
accessibleTask
(
doc
task
{
.
.
.
options
topLevel
:
false
chrome
:
false
iframe
:
false
}
)
)
;
}
}
function
isDefunct
(
accessible
)
{
let
defunct
=
false
;
try
{
let
extState
=
{
}
;
accessible
.
getState
(
{
}
extState
)
;
defunct
=
extState
.
value
&
Ci
.
nsIAccessibleStates
.
EXT_STATE_DEFUNCT
;
}
catch
(
x
)
{
defunct
=
true
;
}
finally
{
if
(
defunct
)
{
Logger
.
log
(
Defunct
accessible
:
{
prettyName
(
accessible
)
}
)
;
}
}
return
defunct
;
}
function
getAccessibleTagName
(
acc
)
{
try
{
return
acc
.
attributes
.
getStringProperty
(
"
tag
"
)
;
}
catch
(
e
)
{
return
null
;
}
}
function
findAccessibleChildByID
(
accessible
id
interfaces
)
{
if
(
getAccessibleDOMNodeID
(
accessible
)
=
=
=
id
)
{
return
queryInterfaces
(
accessible
interfaces
)
;
}
for
(
let
i
=
0
;
i
<
accessible
.
children
.
length
;
+
+
i
)
{
let
found
=
findAccessibleChildByID
(
accessible
.
getChildAt
(
i
)
id
)
;
if
(
found
)
{
return
queryInterfaces
(
found
interfaces
)
;
}
}
return
null
;
}
function
queryInterfaces
(
accessible
interfaces
)
{
if
(
!
interfaces
)
{
return
accessible
;
}
for
(
let
iface
of
interfaces
.
filter
(
i
=
>
!
(
accessible
instanceof
i
)
)
)
{
try
{
accessible
.
QueryInterface
(
iface
)
;
}
catch
(
e
)
{
ok
(
false
"
Can
'
t
query
"
+
iface
)
;
}
}
return
accessible
;
}
function
arrayFromChildren
(
accessible
)
{
return
Array
.
from
(
{
length
:
accessible
.
childCount
}
(
c
i
)
=
>
accessible
.
getChildAt
(
i
)
)
;
}
function
forceGC
(
)
{
SpecialPowers
.
gc
(
)
;
SpecialPowers
.
forceShrinkingGC
(
)
;
SpecialPowers
.
forceCC
(
)
;
SpecialPowers
.
gc
(
)
;
SpecialPowers
.
forceShrinkingGC
(
)
;
SpecialPowers
.
forceCC
(
)
;
}
async
function
contentSpawnMutation
(
browser
waitFor
func
args
=
[
]
)
{
let
onReorders
=
waitForEvents
(
{
expected
:
waitFor
.
expected
|
|
[
]
}
)
;
let
unexpectedListener
=
new
UnexpectedEvents
(
waitFor
.
unexpected
|
|
[
]
)
;
function
tick
(
)
{
content
.
windowUtils
.
advanceTimeAndRefresh
(
100
)
;
}
await
invokeContentTask
(
browser
[
]
tick
)
;
await
invokeContentTask
(
browser
args
func
)
;
await
invokeContentTask
(
browser
[
]
tick
)
;
let
events
=
await
onReorders
;
unexpectedListener
.
stop
(
)
;
await
invokeContentTask
(
browser
[
]
function
(
)
{
content
.
windowUtils
.
restoreNormalRefresh
(
)
;
}
)
;
return
events
;
}
async
function
waitForImageMap
(
browser
accDoc
id
=
"
imgmap
"
)
{
const
acc
=
findAccessibleChildByID
(
accDoc
id
)
;
if
(
acc
.
firstChild
)
{
return
;
}
const
onReorder
=
waitForEvent
(
EVENT_REORDER
id
)
;
await
invokeContentTask
(
browser
[
id
]
contentId
=
>
{
const
{
ContentTaskUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTaskUtils
.
jsm
"
)
;
const
EventUtils
=
ContentTaskUtils
.
getEventUtils
(
content
)
;
EventUtils
.
synthesizeMouse
(
content
.
document
.
getElementById
(
contentId
)
10
10
{
type
:
"
mousemove
"
}
content
)
;
}
)
;
await
onReorder
;
}
async
function
getContentBoundsForDOMElm
(
browser
id
)
{
return
invokeContentTask
(
browser
[
id
]
contentId
=
>
{
const
{
Layout
:
LayoutUtils
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
accessible
/
tests
/
browser
/
Layout
.
jsm
"
)
;
return
LayoutUtils
.
getBoundsForDOMElm
(
contentId
content
.
document
)
;
}
)
;
}
const
CACHE_WAIT_TIMEOUT_MS
=
5000
;
function
untilCacheCondition
(
conditionFunc
argsFunc
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
args
=
argsFunc
(
)
;
if
(
conditionFunc
(
.
.
.
args
)
)
{
resolve
(
args
)
;
return
;
}
let
cacheObserver
=
{
observe
(
subject
)
{
args
=
argsFunc
(
)
;
if
(
conditionFunc
(
.
.
.
args
)
)
{
clearTimeout
(
this
.
timer
)
;
Services
.
obs
.
removeObserver
(
this
"
accessible
-
cache
"
)
;
resolve
(
args
)
;
}
}
timeout
(
)
{
Services
.
obs
.
removeObserver
(
this
"
accessible
-
cache
"
)
;
args
=
argsFunc
(
)
;
resolve
(
args
)
;
}
}
;
cacheObserver
.
timer
=
setTimeout
(
cacheObserver
.
timeout
.
bind
(
cacheObserver
)
CACHE_WAIT_TIMEOUT_MS
)
;
Services
.
obs
.
addObserver
(
cacheObserver
"
accessible
-
cache
"
)
;
}
)
;
}
function
untilCacheOk
(
conditionFunc
message
)
{
return
untilCacheCondition
(
(
v
_unusedMessage
)
=
>
v
(
)
=
>
[
conditionFunc
(
)
message
]
)
.
then
(
(
[
v
msg
]
)
=
>
ok
(
v
msg
)
)
;
}
function
untilCacheIs
(
retrievalFunc
expected
message
)
{
return
untilCacheCondition
(
(
a
b
_unusedMessage
)
=
>
Object
.
is
(
a
b
)
(
)
=
>
[
retrievalFunc
(
)
expected
message
]
)
.
then
(
(
[
got
exp
msg
]
)
=
>
is
(
got
exp
msg
)
)
;
}
