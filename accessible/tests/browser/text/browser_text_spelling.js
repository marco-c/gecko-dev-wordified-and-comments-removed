"
use
strict
"
;
loadScripts
(
{
name
:
"
text
.
js
"
dir
:
MOCHITESTS_DIR
}
{
name
:
"
attributes
.
js
"
dir
:
MOCHITESTS_DIR
}
)
;
const
boldAttrs
=
{
"
font
-
weight
"
:
"
700
"
}
;
function
misspelledRangesMatch
(
acc
ranges
)
{
let
offset
=
0
;
let
expectedRanges
=
[
.
.
.
ranges
]
;
let
charCount
=
acc
.
characterCount
;
while
(
offset
<
charCount
)
{
let
start
=
{
}
;
let
end
=
{
}
;
let
attributes
=
acc
.
getTextAttributes
(
false
offset
start
end
)
;
offset
=
end
.
value
;
try
{
if
(
attributes
.
getStringProperty
(
"
invalid
"
)
=
=
"
spelling
"
)
{
let
expected
=
expectedRanges
.
shift
(
)
;
if
(
!
expected
|
|
expected
[
0
]
!
=
start
.
value
|
|
expected
[
1
]
!
=
end
.
value
)
{
return
false
;
}
}
}
catch
(
err
)
{
}
}
return
!
expectedRanges
.
length
;
}
async
function
waitForMisspelledRanges
(
acc
ranges
)
{
await
waitForEvent
(
EVENT_TEXT_ATTRIBUTE_CHANGED
)
;
await
untilCacheOk
(
(
)
=
>
misspelledRangesMatch
(
acc
ranges
)
Misspelled
ranges
match
:
{
JSON
.
stringify
(
ranges
)
}
)
;
}
addAccessibleTask
(
<
textarea
id
=
"
textarea
"
spellcheck
=
"
true
"
>
test
tset
tset
test
<
/
textarea
>
<
div
contenteditable
id
=
"
editable
"
spellcheck
=
"
true
"
>
plain
<
span
>
ts
<
/
span
>
et
<
b
>
bold
<
/
b
>
<
/
div
>
async
function
(
browser
docAcc
)
{
const
textarea
=
findAccessibleChildByID
(
docAcc
"
textarea
"
[
nsIAccessibleText
]
)
;
info
(
"
Focusing
textarea
"
)
;
let
spellingChanged
=
waitForMisspelledRanges
(
textarea
[
[
5
9
]
[
10
14
]
]
)
;
textarea
.
takeFocus
(
)
;
await
spellingChanged
;
info
(
'
textarea
:
Changing
first
"
tset
"
to
"
test
"
'
)
;
spellingChanged
=
waitForMisspelledRanges
(
textarea
[
[
10
14
]
]
)
;
await
invokeContentTask
(
browser
[
]
(
)
=
>
{
content
.
document
.
getElementById
(
"
textarea
"
)
.
setSelectionRange
(
5
9
)
;
}
)
;
EventUtils
.
sendString
(
"
test
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowRight
"
)
;
await
spellingChanged
;
info
(
'
textarea
:
Changing
it
back
to
"
tset
"
'
)
;
spellingChanged
=
waitForMisspelledRanges
(
textarea
[
[
5
9
]
[
10
14
]
]
)
;
await
invokeContentTask
(
browser
[
]
(
)
=
>
{
content
.
document
.
getElementById
(
"
textarea
"
)
.
setSelectionRange
(
5
9
)
;
}
)
;
EventUtils
.
sendString
(
"
tset
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowRight
"
)
;
await
spellingChanged
;
info
(
'
textarea
:
Changing
first
"
test
"
to
"
the
"
'
)
;
let
inserted
=
waitForEvent
(
EVENT_TEXT_INSERTED
textarea
)
;
await
invokeContentTask
(
browser
[
]
(
)
=
>
{
content
.
document
.
getElementById
(
"
textarea
"
)
.
setSelectionRange
(
0
4
)
;
}
)
;
EventUtils
.
sendString
(
"
the
"
)
;
await
inserted
;
let
selected
=
waitForEvent
(
EVENT_TEXT_SELECTION_CHANGED
textarea
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowRight
"
{
shiftKey
:
true
}
)
;
await
selected
;
const
expectedRanges
=
[
[
4
8
]
[
9
13
]
]
;
await
untilCacheOk
(
(
)
=
>
misspelledRangesMatch
(
textarea
expectedRanges
)
Misspelled
ranges
match
:
{
JSON
.
stringify
(
expectedRanges
)
}
)
;
const
editable
=
findAccessibleChildByID
(
docAcc
"
editable
"
[
nsIAccessibleText
]
)
;
info
(
"
Focusing
editable
"
)
;
spellingChanged
=
waitForMisspelledRanges
(
editable
[
[
6
10
]
]
)
;
editable
.
takeFocus
(
)
;
await
spellingChanged
;
testTextAttrs
(
editable
0
{
}
{
}
0
6
true
)
;
testTextAttrs
(
editable
6
{
invalid
:
"
spelling
"
}
{
}
6
10
true
)
;
testTextAttrs
(
editable
10
{
}
{
}
10
11
true
)
;
testTextAttrs
(
editable
11
boldAttrs
{
}
11
15
true
)
;
}
{
chrome
:
true
topLevel
:
true
iframe
:
true
remoteIframe
:
true
}
)
;
