"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
accessible
/
tests
/
browser
/
shared
-
head
.
js
"
this
)
;
loadScripts
(
{
name
:
"
common
.
js
"
dir
:
MOCHITESTS_DIR
}
{
name
:
"
text
.
js
"
dir
:
MOCHITESTS_DIR
}
{
name
:
"
promisified
-
events
.
js
"
dir
:
MOCHITESTS_DIR
}
)
;
const
DIRECTION_NEXT
=
Ci
.
nsIAccessibleTextLeafPoint
.
DIRECTION_NEXT
;
const
DIRECTION_PREVIOUS
=
Ci
.
nsIAccessibleTextLeafPoint
.
DIRECTION_PREVIOUS
;
const
BOUNDARY_FLAG_DEFAULT
=
Ci
.
nsIAccessibleTextLeafPoint
.
BOUNDARY_FLAG_DEFAULT
;
const
BOUNDARY_FLAG_INCLUDE_ORIGIN
=
Ci
.
nsIAccessibleTextLeafPoint
.
BOUNDARY_FLAG_INCLUDE_ORIGIN
;
const
BOUNDARY_FLAG_STOP_IN_EDITABLE
=
Ci
.
nsIAccessibleTextLeafPoint
.
BOUNDARY_FLAG_STOP_IN_EDITABLE
;
const
BOUNDARY_FLAG_SKIP_LIST_ITEM_MARKER
=
Ci
.
nsIAccessibleTextLeafPoint
.
BOUNDARY_FLAG_SKIP_LIST_ITEM_MARKER
;
function
createTextLeafPoint
(
acc
offset
)
{
let
accService
=
Cc
[
"
mozilla
.
org
/
accessibilityService
;
1
"
]
.
getService
(
nsIAccessibilityService
)
;
return
accService
.
createTextLeafPoint
(
acc
offset
)
;
}
function
readablePoint
(
point
)
{
const
readableLeaf
=
acc
=
>
{
let
tagName
=
getAccessibleTagName
(
acc
)
;
if
(
tagName
&
&
!
tagName
.
startsWith
(
"
_moz_generated
"
)
)
{
let
domNodeID
=
getAccessibleDOMNodeID
(
acc
)
;
if
(
domNodeID
)
{
return
{
tagName
}
#
{
domNodeID
}
;
}
return
tagName
;
}
return
acc
.
name
;
}
;
return
[
readableLeaf
(
point
.
accessible
)
point
.
offset
]
;
}
function
sequenceEqual
(
val
expected
msg
)
{
Assert
.
deepEqual
(
val
expected
msg
)
;
}
function
sequenceEqualTodo
(
val
expected
msg
)
{
todo_is
(
JSON
.
stringify
(
val
)
JSON
.
stringify
(
expected
)
msg
)
;
}
function
pointsEqual
(
pointA
pointB
)
{
return
(
pointA
.
offset
=
=
pointB
.
offset
&
&
pointA
.
accessible
=
=
pointB
.
accessible
)
;
}
function
testPointEqual
(
pointA
pointB
msg
)
{
is
(
pointA
.
offset
pointB
.
offset
Offset
mismatch
-
{
msg
}
)
;
is
(
pointA
.
accessible
pointB
.
accessible
Accessible
mismatch
-
{
msg
}
)
;
}
function
*
textBoundaryGenerator
(
firstPoint
boundaryType
direction
flags
=
BOUNDARY_FLAG_DEFAULT
)
{
let
nextLeafPoint
=
firstPoint
.
findBoundary
(
boundaryType
direction
flags
|
BOUNDARY_FLAG_INCLUDE_ORIGIN
)
;
let
textLeafPoint
=
null
;
do
{
textLeafPoint
=
nextLeafPoint
;
yield
textLeafPoint
;
nextLeafPoint
=
textLeafPoint
.
findBoundary
(
boundaryType
direction
flags
)
;
}
while
(
!
pointsEqual
(
textLeafPoint
nextLeafPoint
)
)
;
}
function
testBoundarySequence
(
startPoint
boundaryType
direction
expectedSequence
msg
options
=
{
}
)
{
let
sequence
=
[
.
.
.
textBoundaryGenerator
(
startPoint
boundaryType
direction
options
.
flags
?
options
.
flags
:
BOUNDARY_FLAG_DEFAULT
)
]
;
(
options
.
todo
?
sequenceEqualTodo
:
sequenceEqual
)
(
sequence
.
map
(
readablePoint
)
expectedSequence
msg
)
;
}
