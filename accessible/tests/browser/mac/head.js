"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
accessible
/
tests
/
browser
/
shared
-
head
.
js
"
this
)
;
loadScripts
(
{
name
:
"
common
.
js
"
dir
:
MOCHITESTS_DIR
}
{
name
:
"
promisified
-
events
.
js
"
dir
:
MOCHITESTS_DIR
}
)
;
const
AXTextStateChangeTypeEdit
=
1
;
const
AXTextStateChangeTypeSelectionMove
=
2
;
const
AXTextStateChangeTypeSelectionExtend
=
3
;
const
AXTextEditTypeDelete
=
1
;
const
AXTextEditTypeTyping
=
3
;
const
AXTextSelectionDirectionUnknown
=
0
;
const
AXTextSelectionDirectionBeginning
=
1
;
const
AXTextSelectionDirectionEnd
=
2
;
const
AXTextSelectionDirectionPrevious
=
3
;
const
AXTextSelectionDirectionNext
=
4
;
const
AXTextSelectionDirectionDiscontiguous
=
5
;
const
AXTextSelectionGranularityUnknown
=
0
;
const
AXTextSelectionGranularityCharacter
=
1
;
const
AXTextSelectionGranularityWord
=
2
;
const
AXTextSelectionGranularityLine
=
3
;
function
getNativeInterface
(
accDoc
id
)
{
return
findAccessibleChildByID
(
accDoc
id
)
.
nativeInterface
.
QueryInterface
(
Ci
.
nsIAccessibleMacInterface
)
;
}
function
waitForMacEventWithInfo
(
notificationType
filter
)
{
let
filterFunc
=
(
macIface
data
)
=
>
{
if
(
!
filter
)
{
return
true
;
}
if
(
typeof
filter
=
=
"
function
"
)
{
return
filter
(
macIface
data
)
;
}
return
macIface
.
getAttributeValue
(
"
AXDOMIdentifier
"
)
=
=
filter
;
}
;
return
new
Promise
(
resolve
=
>
{
let
eventObserver
=
{
observe
(
subject
topic
data
)
{
let
macEvent
=
subject
.
QueryInterface
(
Ci
.
nsIAccessibleMacEvent
)
;
if
(
data
=
=
=
notificationType
&
&
filterFunc
(
macEvent
.
macIface
macEvent
.
data
)
)
{
Services
.
obs
.
removeObserver
(
this
"
accessible
-
mac
-
event
"
)
;
resolve
(
macEvent
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
eventObserver
"
accessible
-
mac
-
event
"
)
;
}
)
;
}
function
waitForMacEvent
(
notificationType
filter
)
{
return
waitForMacEventWithInfo
(
notificationType
filter
)
.
then
(
e
=
>
e
.
macIface
)
;
}
function
NSRange
(
location
length
)
{
return
{
valueType
:
"
NSRange
"
value
:
[
location
length
]
}
;
}
function
NSDictionary
(
dict
)
{
return
{
objectType
:
"
NSDictionary
"
object
:
dict
}
;
}
function
stringForRange
(
macDoc
range
)
{
if
(
!
range
)
{
return
"
"
;
}
let
str
=
macDoc
.
getParameterizedAttributeValue
(
"
AXStringForTextMarkerRange
"
range
)
;
let
attrStr
=
macDoc
.
getParameterizedAttributeValue
(
"
AXAttributedStringForTextMarkerRange
"
range
)
;
is
(
attrStr
.
map
(
(
{
string
}
)
=
>
string
)
.
join
(
"
"
)
str
"
attributed
text
matches
non
-
attributed
text
"
)
;
return
str
;
}
