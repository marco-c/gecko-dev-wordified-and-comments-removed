"
use
strict
"
;
const
EVENT_ANNOUNCEMENT
=
nsIAccessibleEvent
.
EVENT_ANNOUNCEMENT
;
const
EVENT_DOCUMENT_LOAD_COMPLETE
=
nsIAccessibleEvent
.
EVENT_DOCUMENT_LOAD_COMPLETE
;
const
EVENT_HIDE
=
nsIAccessibleEvent
.
EVENT_HIDE
;
const
EVENT_REORDER
=
nsIAccessibleEvent
.
EVENT_REORDER
;
const
EVENT_SCROLLING
=
nsIAccessibleEvent
.
EVENT_SCROLLING
;
const
EVENT_SCROLLING_END
=
nsIAccessibleEvent
.
EVENT_SCROLLING_END
;
const
EVENT_SHOW
=
nsIAccessibleEvent
.
EVENT_SHOW
;
const
EVENT_STATE_CHANGE
=
nsIAccessibleEvent
.
EVENT_STATE_CHANGE
;
const
EVENT_TEXT_CARET_MOVED
=
nsIAccessibleEvent
.
EVENT_TEXT_CARET_MOVED
;
const
EVENT_TEXT_INSERTED
=
nsIAccessibleEvent
.
EVENT_TEXT_INSERTED
;
const
EVENT_TEXT_REMOVED
=
nsIAccessibleEvent
.
EVENT_TEXT_REMOVED
;
const
EVENT_DESCRIPTION_CHANGE
=
nsIAccessibleEvent
.
EVENT_DESCRIPTION_CHANGE
;
const
EVENT_NAME_CHANGE
=
nsIAccessibleEvent
.
EVENT_NAME_CHANGE
;
const
EVENT_VALUE_CHANGE
=
nsIAccessibleEvent
.
EVENT_VALUE_CHANGE
;
const
EVENT_TEXT_VALUE_CHANGE
=
nsIAccessibleEvent
.
EVENT_TEXT_VALUE_CHANGE
;
const
EVENT_FOCUS
=
nsIAccessibleEvent
.
EVENT_FOCUS
;
const
EVENT_DOCUMENT_RELOAD
=
nsIAccessibleEvent
.
EVENT_DOCUMENT_RELOAD
;
const
EVENT_VIRTUALCURSOR_CHANGED
=
nsIAccessibleEvent
.
EVENT_VIRTUALCURSOR_CHANGED
;
function
eventToString
(
event
)
{
let
type
=
eventTypeToString
(
event
.
eventType
)
;
let
info
=
Event
type
:
{
type
}
;
if
(
event
instanceof
nsIAccessibleStateChangeEvent
)
{
let
stateStr
=
statesToString
(
event
.
isExtraState
?
0
:
event
.
state
event
.
isExtraState
?
event
.
state
:
0
)
;
info
+
=
state
:
{
stateStr
}
is
enabled
:
{
event
.
isEnabled
}
;
}
else
if
(
event
instanceof
nsIAccessibleTextChangeEvent
)
{
let
tcType
=
event
.
isInserted
?
"
inserted
"
:
"
removed
"
;
info
+
=
start
:
{
event
.
start
}
length
:
{
event
.
length
}
{
tcType
}
text
:
{
event
.
modifiedText
}
;
}
info
+
=
.
Target
:
{
prettyName
(
event
.
accessible
)
}
;
return
info
;
}
function
matchEvent
(
event
matchCriteria
)
{
let
acc
=
event
.
accessible
;
switch
(
typeof
matchCriteria
)
{
case
"
string
"
:
let
id
=
getAccessibleDOMNodeID
(
acc
)
;
if
(
id
=
=
=
matchCriteria
)
{
Logger
.
log
(
Event
matches
DOMNode
id
:
{
id
}
)
;
return
true
;
}
break
;
case
"
function
"
:
if
(
matchCriteria
(
event
)
)
{
Logger
.
log
(
Lambda
function
matches
event
:
{
eventToString
(
event
)
}
)
;
return
true
;
}
break
;
default
:
if
(
acc
=
=
=
matchCriteria
)
{
Logger
.
log
(
Event
matches
accessible
:
{
prettyName
(
acc
)
}
)
;
return
true
;
}
}
return
false
;
}
function
waitForEvent
(
eventType
matchCriteria
)
{
return
new
Promise
(
resolve
=
>
{
let
eventObserver
=
{
observe
(
subject
topic
data
)
{
if
(
topic
!
=
=
"
accessible
-
event
"
)
{
return
;
}
let
event
=
subject
.
QueryInterface
(
nsIAccessibleEvent
)
;
if
(
Logger
.
enabled
)
{
Logger
.
log
(
eventToString
(
event
)
)
;
}
if
(
event
.
eventType
!
=
=
eventType
)
{
return
;
}
if
(
matchEvent
(
event
matchCriteria
)
)
{
Logger
.
log
(
Correct
event
type
:
{
eventTypeToString
(
eventType
)
}
)
;
Services
.
obs
.
removeObserver
(
this
"
accessible
-
event
"
)
;
resolve
(
event
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
eventObserver
"
accessible
-
event
"
)
;
}
)
;
}
class
UnexpectedEvents
{
constructor
(
unexpected
)
{
if
(
unexpected
.
length
)
{
this
.
unexpected
=
unexpected
;
Services
.
obs
.
addObserver
(
this
"
accessible
-
event
"
)
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
!
=
=
"
accessible
-
event
"
)
{
return
;
}
let
event
=
subject
.
QueryInterface
(
nsIAccessibleEvent
)
;
let
unexpectedEvent
=
this
.
unexpected
.
find
(
(
[
etype
criteria
]
)
=
>
etype
=
=
=
event
.
eventType
&
&
matchEvent
(
event
criteria
)
)
;
if
(
unexpectedEvent
)
{
ok
(
false
Got
unexpected
event
:
{
eventToString
(
event
)
}
)
;
}
}
stop
(
)
{
if
(
this
.
unexpected
)
{
Services
.
obs
.
removeObserver
(
this
"
accessible
-
event
"
)
;
}
}
}
function
waitForEvents
(
events
ordered
=
false
)
{
let
expected
=
events
.
expected
|
|
events
;
let
unexpected
=
events
.
unexpected
|
|
[
]
;
let
currentIdx
=
0
;
let
unexpectedListener
=
new
UnexpectedEvents
(
unexpected
)
;
return
Promise
.
all
(
expected
.
map
(
(
evt
idx
)
=
>
{
let
promise
=
evt
instanceof
Array
?
waitForEvent
(
.
.
.
evt
)
:
evt
;
return
promise
.
then
(
result
=
>
{
if
(
ordered
)
{
is
(
idx
currentIdx
+
+
Unexpected
event
order
:
{
result
}
)
;
}
return
result
;
}
)
;
}
)
)
.
then
(
results
=
>
{
unexpectedListener
.
stop
(
)
;
return
results
;
}
)
;
}
function
waitForOrderedEvents
(
events
)
{
return
waitForEvents
(
events
true
)
;
}
async
function
contentSpawnMutation
(
browser
waitFor
func
args
=
null
)
{
let
onReorders
=
waitForEvents
(
{
expected
:
waitFor
.
expected
|
|
[
]
}
)
;
let
unexpectedListener
=
new
UnexpectedEvents
(
waitFor
.
unexpected
|
|
[
]
)
;
function
tick
(
)
{
content
.
windowUtils
.
advanceTimeAndRefresh
(
100
)
;
}
await
ContentTask
.
spawn
(
browser
null
tick
)
;
await
ContentTask
.
spawn
(
browser
args
func
)
;
await
ContentTask
.
spawn
(
browser
null
tick
)
;
let
events
=
await
onReorders
;
unexpectedListener
.
stop
(
)
;
await
ContentTask
.
spawn
(
browser
null
function
(
)
{
content
.
windowUtils
.
restoreNormalRefresh
(
)
;
}
)
;
return
events
;
}
