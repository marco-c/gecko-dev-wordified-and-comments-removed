"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
Layout
"
]
;
const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
accessible
/
tests
/
browser
/
Common
.
jsm
"
)
;
function
CSSToDevicePixels
(
win
x
y
width
height
)
{
const
winUtil
=
win
.
windowUtils
;
const
ratio
=
winUtil
.
screenPixelsPerCSSPixel
;
return
[
Math
.
round
(
x
*
ratio
)
Math
.
round
(
y
*
ratio
)
Math
.
round
(
width
*
ratio
)
Math
.
round
(
height
*
ratio
)
]
;
}
const
Layout
=
{
zoomDocument
(
doc
zoom
)
{
const
docShell
=
doc
.
defaultView
.
docShell
;
const
docViewer
=
docShell
.
contentViewer
;
docViewer
.
fullZoom
=
zoom
;
}
setResolution
(
doc
zoom
)
{
const
windowUtils
=
doc
.
defaultView
.
windowUtils
;
windowUtils
.
setResolutionAndScaleTo
(
zoom
)
;
}
testTextPos
(
id
offset
point
coordOrigin
)
{
const
[
expectedX
expectedY
]
=
point
;
const
xObj
=
{
}
;
const
yObj
=
{
}
;
const
hyperText
=
CommonUtils
.
getAccessible
(
id
[
Ci
.
nsIAccessibleText
]
)
;
hyperText
.
getCharacterExtents
(
offset
xObj
yObj
{
}
{
}
coordOrigin
)
;
is
(
xObj
.
value
expectedX
Wrong
x
coordinate
at
offset
{
offset
}
for
{
CommonUtils
.
prettyName
(
id
)
}
)
;
ok
(
yObj
.
value
-
expectedY
<
2
&
&
expectedY
-
yObj
.
value
<
2
Wrong
y
coordinate
at
offset
{
offset
}
for
{
CommonUtils
.
prettyName
(
id
)
}
-
got
{
yObj
.
value
}
expected
{
expectedY
}
.
The
difference
doesn
'
t
exceed
1
.
)
;
}
isWithin
(
expected
got
within
msg
)
{
if
(
Math
.
abs
(
got
-
expected
)
<
=
within
)
{
ok
(
true
{
msg
}
-
Got
{
got
}
)
;
}
else
{
ok
(
false
{
msg
}
-
Got
{
got
}
expected
{
expected
}
with
error
of
{
within
}
)
;
}
}
testTextBounds
(
id
startOffset
endOffset
rect
coordOrigin
)
{
const
[
expectedX
expectedY
expectedWidth
expectedHeight
]
=
rect
;
const
xObj
=
{
}
;
const
yObj
=
{
}
;
const
widthObj
=
{
}
;
const
heightObj
=
{
}
;
const
hyperText
=
CommonUtils
.
getAccessible
(
id
[
Ci
.
nsIAccessibleText
]
)
;
hyperText
.
getRangeExtents
(
startOffset
endOffset
xObj
yObj
widthObj
heightObj
coordOrigin
)
;
is
(
xObj
.
value
expectedX
Wrong
x
coordinate
of
text
between
offsets
(
{
startOffset
}
{
endOffset
}
)
for
{
CommonUtils
.
prettyName
(
id
)
}
)
;
this
.
isWithin
(
yObj
.
value
expectedY
1
y
coord
of
text
between
offsets
(
{
startOffset
}
{
endOffset
}
)
for
{
CommonUtils
.
prettyName
(
id
)
}
)
;
const
msg
=
Wrong
width
of
text
between
offsets
(
{
startOffset
}
{
endOffset
}
)
for
{
CommonUtils
.
prettyName
(
id
)
}
;
if
(
widthObj
.
value
=
=
expectedWidth
)
{
ok
(
true
msg
)
;
}
else
{
todo
(
false
msg
)
;
}
this
.
isWithin
(
heightObj
.
value
expectedHeight
1
height
of
text
between
offsets
(
{
startOffset
}
{
endOffset
}
)
for
{
CommonUtils
.
prettyName
(
id
)
}
)
;
}
getPos
(
id
)
{
const
accessible
=
CommonUtils
.
getAccessible
(
id
)
;
const
x
=
{
}
;
const
y
=
{
}
;
accessible
.
getBounds
(
x
y
{
}
{
}
)
;
return
[
x
.
value
y
.
value
]
;
}
getBounds
(
id
dpr
)
{
const
accessible
=
CommonUtils
.
getAccessible
(
id
)
;
const
x
=
{
}
;
const
y
=
{
}
;
const
width
=
{
}
;
const
height
=
{
}
;
const
xInCSS
=
{
}
;
const
yInCSS
=
{
}
;
const
widthInCSS
=
{
}
;
const
heightInCSS
=
{
}
;
accessible
.
getBounds
(
x
y
width
height
)
;
accessible
.
getBoundsInCSSPixels
(
xInCSS
yInCSS
widthInCSS
heightInCSS
)
;
this
.
isWithin
(
x
.
value
/
dpr
xInCSS
.
value
1
"
Heights
in
CSS
pixels
is
calculated
correctly
"
)
;
this
.
isWithin
(
y
.
value
/
dpr
yInCSS
.
value
1
"
Heights
in
CSS
pixels
is
calculated
correctly
"
)
;
this
.
isWithin
(
width
.
value
/
dpr
widthInCSS
.
value
1
"
Heights
in
CSS
pixels
is
calculated
correctly
"
)
;
this
.
isWithin
(
height
.
value
/
dpr
heightInCSS
.
value
1
"
Heights
in
CSS
pixels
is
calculated
correctly
"
)
;
return
[
x
.
value
y
.
value
width
.
value
height
.
value
]
;
}
getRangeExtents
(
id
startOffset
endOffset
coordOrigin
)
{
const
hyperText
=
CommonUtils
.
getAccessible
(
id
[
Ci
.
nsIAccessibleText
]
)
;
const
x
=
{
}
;
const
y
=
{
}
;
const
width
=
{
}
;
const
height
=
{
}
;
hyperText
.
getRangeExtents
(
startOffset
endOffset
x
y
width
height
coordOrigin
)
;
return
[
x
.
value
y
.
value
width
.
value
height
.
value
]
;
}
getBoundsForDOMElm
(
id
doc
)
{
let
x
=
0
;
let
y
=
0
;
let
width
=
0
;
let
height
=
0
;
const
elm
=
CommonUtils
.
getNode
(
id
doc
)
;
const
elmWindow
=
elm
.
ownerGlobal
;
if
(
elm
.
localName
=
=
"
area
"
)
{
const
mapName
=
elm
.
parentNode
.
getAttribute
(
"
name
"
)
;
const
selector
=
[
usemap
=
"
#
{
mapName
}
"
]
;
const
img
=
elm
.
ownerDocument
.
querySelector
(
selector
)
;
const
areaCoords
=
elm
.
coords
.
split
(
"
"
)
;
const
areaX
=
parseInt
(
areaCoords
[
0
]
10
)
;
const
areaY
=
parseInt
(
areaCoords
[
1
]
10
)
;
const
areaWidth
=
parseInt
(
areaCoords
[
2
]
10
)
-
areaX
;
const
areaHeight
=
parseInt
(
areaCoords
[
3
]
10
)
-
areaY
;
const
rect
=
img
.
getBoundingClientRect
(
)
;
x
=
rect
.
left
+
areaX
;
y
=
rect
.
top
+
areaY
;
width
=
areaWidth
;
height
=
areaHeight
;
}
else
{
const
rect
=
elm
.
getBoundingClientRect
(
)
;
x
=
rect
.
left
;
y
=
rect
.
top
;
width
=
rect
.
width
;
height
=
rect
.
height
;
}
return
CSSToDevicePixels
(
elmWindow
x
+
elmWindow
.
mozInnerScreenX
y
+
elmWindow
.
mozInnerScreenY
width
height
)
;
}
}
;
