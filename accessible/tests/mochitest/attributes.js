function
testAttrs
(
aAccOrElmOrID
aAttrs
aSkipUnexpectedAttrs
aTodo
)
{
testAttrsInternal
(
aAccOrElmOrID
aAttrs
aSkipUnexpectedAttrs
null
aTodo
)
;
}
function
testAbsentAttrs
(
aAccOrElmOrID
aAbsentAttrs
aTodo
)
{
testAttrsInternal
(
aAccOrElmOrID
{
}
true
aAbsentAttrs
aTodo
)
;
}
function
todoAttr
(
aAccOrElmOrID
aKey
aExpectedValue
)
{
testAttrs
(
aAccOrElmOrID
Object
.
fromEntries
(
[
[
aKey
aExpectedValue
]
]
)
true
true
)
;
}
function
testCSSAttrs
(
aID
)
{
var
node
=
document
.
getElementById
(
aID
)
;
var
computedStyle
=
document
.
defaultView
.
getComputedStyle
(
node
)
;
var
attrs
=
{
display
:
computedStyle
.
display
"
text
-
align
"
:
computedStyle
.
textAlign
"
text
-
indent
"
:
computedStyle
.
textIndent
"
margin
-
left
"
:
computedStyle
.
marginLeft
"
margin
-
right
"
:
computedStyle
.
marginRight
"
margin
-
top
"
:
computedStyle
.
marginTop
"
margin
-
bottom
"
:
computedStyle
.
marginBottom
}
;
testAttrs
(
aID
attrs
true
)
;
}
function
testAbsentCSSAttrs
(
aID
)
{
var
attrs
=
{
display
:
"
"
"
text
-
align
"
:
"
"
"
text
-
indent
"
:
"
"
"
margin
-
left
"
:
"
"
"
margin
-
right
"
:
"
"
"
margin
-
top
"
:
"
"
"
margin
-
bottom
"
:
"
"
}
;
testAbsentAttrs
(
aID
attrs
)
;
}
function
testGroupAttrs
(
aAccOrElmOrID
aPosInSet
aSetSize
aLevel
aTodo
)
{
var
acc
=
getAccessible
(
aAccOrElmOrID
)
;
var
levelObj
=
{
}
posInSetObj
=
{
}
setSizeObj
=
{
}
;
acc
.
groupPosition
(
levelObj
setSizeObj
posInSetObj
)
;
let
groupPos
=
{
}
expectedGroupPos
=
{
}
;
if
(
aPosInSet
&
&
aSetSize
)
{
groupPos
.
setsize
=
String
(
setSizeObj
.
value
)
;
groupPos
.
posinset
=
String
(
posInSetObj
.
value
)
;
expectedGroupPos
.
setsize
=
String
(
aSetSize
)
;
expectedGroupPos
.
posinset
=
String
(
aPosInSet
)
;
}
if
(
aLevel
)
{
groupPos
.
level
=
String
(
levelObj
.
value
)
;
expectedGroupPos
.
level
=
String
(
aLevel
)
;
}
compareSimpleObjects
(
groupPos
expectedGroupPos
false
"
wrong
groupPos
"
aTodo
)
;
testAttrs
(
aAccOrElmOrID
expectedGroupPos
true
aTodo
)
;
}
function
testGroupParentAttrs
(
aAccOrElmOrID
aChildItemCount
aIsHierarchical
aTodo
)
{
testAttrs
(
aAccOrElmOrID
{
"
child
-
item
-
count
"
:
String
(
aChildItemCount
)
}
true
aTodo
)
;
if
(
aIsHierarchical
)
{
testAttrs
(
aAccOrElmOrID
{
tree
:
"
true
"
}
true
aTodo
)
;
}
else
{
testAbsentAttrs
(
aAccOrElmOrID
{
tree
:
"
true
"
}
)
;
}
}
function
testTextAttrs
(
aID
aOffset
aAttrs
aDefAttrs
aStartOffset
aEndOffset
aSkipUnexpectedAttrs
)
{
var
accessible
=
getAccessible
(
aID
[
nsIAccessibleText
]
)
;
if
(
!
accessible
)
{
return
;
}
var
startOffset
=
{
value
:
-
1
}
;
var
endOffset
=
{
value
:
-
1
}
;
var
attrs
=
getTextAttributes
(
aID
accessible
false
aOffset
startOffset
endOffset
)
;
if
(
!
attrs
)
{
return
;
}
var
errorMsg
=
"
for
"
+
aID
+
"
at
offset
"
+
aOffset
;
is
(
startOffset
.
value
aStartOffset
"
Wrong
start
offset
"
+
errorMsg
)
;
is
(
endOffset
.
value
aEndOffset
"
Wrong
end
offset
"
+
errorMsg
)
;
compareAttrs
(
errorMsg
attrs
aAttrs
aSkipUnexpectedAttrs
)
;
var
expectedAttrs
=
{
}
;
for
(
let
name
in
aAttrs
)
{
expectedAttrs
[
name
]
=
aAttrs
[
name
]
;
}
for
(
let
name
in
aDefAttrs
)
{
if
(
!
(
name
in
expectedAttrs
)
)
{
expectedAttrs
[
name
]
=
aDefAttrs
[
name
]
;
}
}
attrs
=
getTextAttributes
(
aID
accessible
true
aOffset
startOffset
endOffset
)
;
if
(
!
attrs
)
{
return
;
}
compareAttrs
(
errorMsg
attrs
expectedAttrs
aSkipUnexpectedAttrs
)
;
}
function
testDefaultTextAttrs
(
aID
aDefAttrs
aSkipUnexpectedAttrs
)
{
var
accessible
=
getAccessible
(
aID
[
nsIAccessibleText
]
)
;
if
(
!
accessible
)
{
return
;
}
var
defAttrs
=
null
;
try
{
defAttrs
=
accessible
.
defaultTextAttributes
;
}
catch
(
e
)
{
}
if
(
!
defAttrs
)
{
ok
(
false
"
Can
'
t
get
default
text
attributes
for
"
+
aID
)
;
return
;
}
var
errorMsg
=
"
.
Getting
default
text
attributes
for
"
+
aID
;
compareAttrs
(
errorMsg
defAttrs
aDefAttrs
aSkipUnexpectedAttrs
)
;
}
function
testTextAttrsWrongOffset
(
aID
aOffset
)
{
var
res
=
false
;
try
{
var
s
=
{
}
e
=
{
}
;
var
acc
=
getAccessible
(
ID
[
nsIAccessibleText
]
)
;
acc
.
getTextAttributes
(
false
157
s
e
)
;
}
catch
(
ex
)
{
res
=
true
;
}
ok
(
res
"
text
attributes
are
calculated
successfully
at
wrong
offset
"
+
aOffset
+
"
for
"
+
prettyName
(
aID
)
)
;
}
const
kNormalFontWeight
=
function
equalsToNormal
(
aWeight
)
{
return
aWeight
<
=
400
;
}
;
const
kBoldFontWeight
=
function
equalsToBold
(
aWeight
)
{
return
aWeight
>
400
;
}
;
const
kInputFontSize
=
WIN
|
|
MAC
?
"
10pt
"
:
function
(
)
{
return
true
;
}
;
const
kAbsentFontFamily
=
function
(
aFontFamily
)
{
return
aFontFamily
!
=
"
sans
-
serif
"
;
}
;
const
kInputFontFamily
=
function
(
aFontFamily
)
{
return
aFontFamily
!
=
"
sans
-
serif
"
;
}
;
const
kMonospaceFontFamily
=
function
(
aFontFamily
)
{
return
aFontFamily
!
=
"
monospace
"
;
}
;
const
kSansSerifFontFamily
=
function
(
aFontFamily
)
{
return
aFontFamily
!
=
"
sans
-
serif
"
;
}
;
const
kSerifFontFamily
=
function
(
aFontFamily
)
{
return
aFontFamily
!
=
"
serif
"
;
}
;
const
kCursiveFontFamily
=
LINUX
?
"
DejaVu
Serif
"
:
"
Comic
Sans
MS
"
;
function
fontFamily
(
aComputedStyle
)
{
var
name
=
aComputedStyle
.
fontFamily
;
switch
(
name
)
{
case
"
monospace
"
:
return
kMonospaceFontFamily
;
case
"
sans
-
serif
"
:
return
kSansSerifFontFamily
;
case
"
serif
"
:
return
kSerifFontFamily
;
default
:
return
name
;
}
}
function
getSystemColor
(
aColor
)
{
let
{
r
g
b
a
}
=
InspectorUtils
.
colorToRGBA
(
aColor
)
;
return
a
=
=
1
?
rgb
(
{
r
}
{
g
}
{
b
}
)
:
rgba
(
{
r
}
{
g
}
{
b
}
{
a
}
)
;
}
function
buildDefaultTextAttrs
(
aID
aFontSize
aFontWeight
aFontFamily
)
{
var
elm
=
getNode
(
aID
)
;
var
computedStyle
=
document
.
defaultView
.
getComputedStyle
(
elm
)
;
var
bgColor
=
computedStyle
.
backgroundColor
=
=
"
rgba
(
0
0
0
0
)
"
?
getSystemColor
(
"
Canvas
"
)
:
computedStyle
.
backgroundColor
;
var
defAttrs
=
{
"
font
-
style
"
:
computedStyle
.
fontStyle
"
font
-
size
"
:
aFontSize
"
background
-
color
"
:
bgColor
"
font
-
weight
"
:
aFontWeight
?
aFontWeight
:
kNormalFontWeight
color
:
computedStyle
.
color
"
font
-
family
"
:
aFontFamily
?
aFontFamily
:
fontFamily
(
computedStyle
)
"
text
-
position
"
:
computedStyle
.
verticalAlign
}
;
return
defAttrs
;
}
function
getTextAttributes
(
aID
aAccessible
aIncludeDefAttrs
aOffset
aStartOffset
aEndOffset
)
{
var
attrs
=
null
;
try
{
attrs
=
aAccessible
.
getTextAttributes
(
aIncludeDefAttrs
aOffset
aStartOffset
aEndOffset
)
;
}
catch
(
e
)
{
}
if
(
attrs
)
{
return
attrs
;
}
ok
(
false
"
Can
'
t
get
text
attributes
for
"
+
aID
)
;
return
null
;
}
function
testAttrsInternal
(
aAccOrElmOrID
aAttrs
aSkipUnexpectedAttrs
aAbsentAttrs
aTodo
)
{
var
accessible
=
getAccessible
(
aAccOrElmOrID
)
;
if
(
!
accessible
)
{
return
;
}
var
attrs
=
null
;
try
{
attrs
=
accessible
.
attributes
;
}
catch
(
e
)
{
}
if
(
!
attrs
)
{
ok
(
false
"
Can
'
t
get
object
attributes
for
"
+
prettyName
(
aAccOrElmOrID
)
)
;
return
;
}
var
errorMsg
=
"
for
"
+
prettyName
(
aAccOrElmOrID
)
;
compareAttrs
(
errorMsg
attrs
aAttrs
aSkipUnexpectedAttrs
aAbsentAttrs
aTodo
)
;
}
function
compareAttrs
(
aErrorMsg
aAttrs
aExpectedAttrs
aSkipUnexpectedAttrs
aAbsentAttrs
aTodo
)
{
let
attrObject
=
{
}
;
for
(
let
prop
of
aAttrs
.
enumerate
(
)
)
{
attrObject
[
prop
.
key
]
=
prop
.
value
;
}
let
expectedObj
=
Object
.
fromEntries
(
Object
.
entries
(
aExpectedAttrs
)
.
map
(
(
[
k
v
]
)
=
>
{
if
(
v
instanceof
Function
)
{
let
value
=
v
(
attrObject
[
k
]
)
?
attrObject
[
k
]
:
v
.
toString
(
)
;
return
[
k
value
]
;
}
return
[
k
v
]
;
}
)
)
;
compareSimpleObjects
(
attrObject
expectedObj
aSkipUnexpectedAttrs
aErrorMsg
aTodo
)
;
if
(
aAbsentAttrs
)
{
let
presentAttrs
=
Object
.
keys
(
attrObject
)
.
filter
(
k
=
>
aAbsentAttrs
[
k
]
!
=
=
undefined
)
;
if
(
presentAttrs
.
length
)
{
(
aTodo
?
todo
:
ok
)
(
false
There
were
unexpected
attributes
:
{
presentAttrs
}
)
;
}
}
}
function
compareSimpleObjects
(
aObj
aExpectedObj
aSkipUnexpectedAttrs
aMessage
aTodo
)
{
let
keys
=
aSkipUnexpectedAttrs
?
Object
.
keys
(
aExpectedObj
)
.
sort
(
)
:
Object
.
keys
(
aObj
)
.
sort
(
)
;
let
o1
=
JSON
.
stringify
(
aObj
keys
)
;
let
o2
=
JSON
.
stringify
(
aExpectedObj
keys
)
;
if
(
aTodo
)
{
todo_is
(
o1
o2
{
aMessage
}
-
Got
{
o1
}
expected
{
o2
}
)
;
}
else
{
is
(
o1
o2
aMessage
)
;
}
}
