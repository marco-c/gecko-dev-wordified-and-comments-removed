#
include
"
DOMtoATK
.
h
"
#
include
"
nsUTF8Utils
.
h
"
namespace
mozilla
{
namespace
a11y
{
namespace
DOMtoATK
{
void
AddBOMs
(
nsACString
&
aDest
const
nsACString
&
aSource
)
{
uint32_t
destlength
=
0
;
for
(
uint32_t
srci
=
0
;
srci
<
aSource
.
Length
(
)
;
)
{
int
bytes
=
UTF8traits
:
:
bytes
(
aSource
[
srci
]
)
;
if
(
bytes
>
=
4
)
{
destlength
+
=
3
;
}
srci
+
=
bytes
;
destlength
+
=
bytes
;
}
uint32_t
desti
=
0
;
aDest
.
SetLength
(
destlength
)
;
for
(
uint32_t
srci
=
0
;
srci
<
aSource
.
Length
(
)
;
)
{
uint32_t
bytes
=
UTF8traits
:
:
bytes
(
aSource
[
srci
]
)
;
MOZ_ASSERT
(
bytes
<
=
aSource
.
Length
(
)
-
srci
"
We
should
have
the
whole
sequence
"
)
;
aDest
.
Replace
(
desti
bytes
Substring
(
aSource
srci
bytes
)
)
;
desti
+
=
bytes
;
srci
+
=
bytes
;
if
(
bytes
>
=
4
)
{
aDest
.
Replace
(
desti
3
"
\
xEF
\
xBB
\
xBF
"
)
;
desti
+
=
3
;
}
}
MOZ_ASSERT
(
desti
=
=
destlength
"
Incoherency
between
computed
length
"
"
and
actually
translated
length
"
)
;
}
void
ATKStringConverterHelper
:
:
AdjustOffsets
(
gint
*
aStartOffset
gint
*
aEndOffset
gint
count
)
{
MOZ_ASSERT
(
!
mAdjusted
"
DOMtoATK
:
:
ATKStringConverterHelper
:
:
AdjustOffsets
needs
to
be
"
"
called
only
once
"
)
;
if
(
*
aStartOffset
>
0
)
{
(
*
aStartOffset
)
-
-
;
mStartShifted
=
true
;
}
if
(
*
aEndOffset
>
=
0
&
&
*
aEndOffset
<
count
)
{
(
*
aEndOffset
)
+
+
;
mEndShifted
=
true
;
}
#
ifdef
DEBUG
mAdjusted
=
true
;
#
endif
}
gchar
*
ATKStringConverterHelper
:
:
FinishUTF16toUTF8
(
nsCString
&
aStr
)
{
int
skip
=
0
;
if
(
mStartShifted
)
{
MOZ_ASSERT
(
aStr
.
Length
(
)
>
0
"
There
should
be
a
leading
character
"
)
;
MOZ_ASSERT
(
static_cast
<
int
>
(
aStr
.
Length
(
)
)
>
=
UTF8traits
:
:
bytes
(
aStr
.
CharAt
(
0
)
)
"
The
leading
character
should
be
complete
"
)
;
skip
=
UTF8traits
:
:
bytes
(
aStr
.
CharAt
(
0
)
)
;
}
if
(
mEndShifted
)
{
MOZ_ASSERT
(
aStr
.
Length
(
)
>
0
"
There
should
be
a
trailing
character
"
)
;
int
trail
=
-
1
;
for
(
trail
=
aStr
.
Length
(
)
-
1
;
trail
>
=
0
;
trail
-
-
)
{
if
(
!
UTF8traits
:
:
isInSeq
(
aStr
.
CharAt
(
trail
)
)
)
{
break
;
}
}
MOZ_ASSERT
(
trail
>
=
0
"
There
should
be
at
least
a
whole
trailing
character
"
)
;
MOZ_ASSERT
(
trail
+
UTF8traits
:
:
bytes
(
aStr
.
CharAt
(
trail
)
)
=
=
static_cast
<
int
>
(
aStr
.
Length
(
)
)
"
The
trailing
character
should
be
complete
"
)
;
aStr
.
Truncate
(
trail
)
;
}
return
g_strdup
(
aStr
.
get
(
)
+
skip
)
;
}
gchar
*
ATKStringConverterHelper
:
:
ConvertAdjusted
(
const
nsAString
&
aStr
)
{
MOZ_ASSERT
(
mAdjusted
"
DOMtoATK
:
:
ATKStringConverterHelper
:
:
AdjustOffsets
needs
to
be
"
"
called
before
ATKStringConverterHelper
:
:
ConvertAdjusted
"
)
;
NS_ConvertUTF16toUTF8
cautoStr
(
aStr
)
;
if
(
!
cautoStr
.
get
(
)
)
{
return
nullptr
;
}
nsAutoCString
cautoStrBOMs
;
AddBOMs
(
cautoStrBOMs
cautoStr
)
;
return
FinishUTF16toUTF8
(
cautoStrBOMs
)
;
}
gchar
*
Convert
(
const
nsAString
&
aStr
)
{
NS_ConvertUTF16toUTF8
cautoStr
(
aStr
)
;
if
(
!
cautoStr
.
get
(
)
)
{
return
nullptr
;
}
nsAutoCString
cautoStrBOMs
;
AddBOMs
(
cautoStrBOMs
cautoStr
)
;
return
g_strdup
(
cautoStrBOMs
.
get
(
)
)
;
}
}
}
}
