#
include
"
HyperTextAccessibleBase
.
h
"
#
include
"
AccAttributes
.
h
"
#
include
"
mozilla
/
a11y
/
Accessible
.
h
"
#
include
"
mozilla
/
StaticPrefs_accessibility
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
mozilla
/
a11y
/
RemoteAccessible
.
h
"
#
include
"
TextLeafRange
.
h
"
#
include
"
TextRange
.
h
"
namespace
mozilla
:
:
a11y
{
void
HyperTextAccessibleBase
:
:
BuildCachedHyperTextOffsets
(
nsTArray
<
int32_t
>
&
aOffsets
)
const
{
const
Accessible
*
thisAcc
=
Acc
(
)
;
uint32_t
childCount
=
thisAcc
-
>
ChildCount
(
)
;
int32_t
lastTextOffset
=
0
;
while
(
aOffsets
.
Length
(
)
<
childCount
)
{
Accessible
*
child
=
thisAcc
-
>
ChildAt
(
aOffsets
.
Length
(
)
)
;
lastTextOffset
+
=
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
child
)
)
;
aOffsets
.
AppendElement
(
lastTextOffset
)
;
}
}
int32_t
HyperTextAccessibleBase
:
:
GetChildIndexAtOffset
(
uint32_t
aOffset
)
const
{
const
auto
&
offsets
=
GetCachedHyperTextOffsets
(
)
;
auto
childCount
=
offsets
.
Length
(
)
;
size_t
index
;
if
(
BinarySearch
(
offsets
0
childCount
static_cast
<
int32_t
>
(
aOffset
)
&
index
)
)
{
return
static_cast
<
int32_t
>
(
index
<
childCount
-
1
?
index
+
1
:
index
)
;
}
if
(
index
=
=
childCount
)
{
return
-
1
;
}
return
static_cast
<
int32_t
>
(
index
)
;
}
Accessible
*
HyperTextAccessibleBase
:
:
GetChildAtOffset
(
uint32_t
aOffset
)
const
{
const
Accessible
*
thisAcc
=
Acc
(
)
;
return
thisAcc
-
>
ChildAt
(
GetChildIndexAtOffset
(
aOffset
)
)
;
}
int32_t
HyperTextAccessibleBase
:
:
GetChildOffset
(
const
Accessible
*
aChild
)
const
{
const
Accessible
*
thisAcc
=
Acc
(
)
;
if
(
aChild
-
>
Parent
(
)
!
=
thisAcc
)
{
return
-
1
;
}
int32_t
index
=
aChild
-
>
IndexInParent
(
)
;
if
(
index
=
=
-
1
)
{
return
-
1
;
}
return
GetChildOffset
(
index
)
;
}
int32_t
HyperTextAccessibleBase
:
:
GetChildOffset
(
uint32_t
aChildIndex
)
const
{
if
(
aChildIndex
=
=
0
)
{
return
0
;
}
MOZ_ASSERT
(
aChildIndex
<
=
Acc
(
)
-
>
ChildCount
(
)
)
;
const
auto
&
offsets
=
GetCachedHyperTextOffsets
(
)
;
return
offsets
[
aChildIndex
-
1
]
;
}
uint32_t
HyperTextAccessibleBase
:
:
CharacterCount
(
)
const
{
return
GetChildOffset
(
Acc
(
)
-
>
ChildCount
(
)
)
;
}
index_t
HyperTextAccessibleBase
:
:
ConvertMagicOffset
(
int32_t
aOffset
)
const
{
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_END_OF_TEXT
)
{
return
CharacterCount
(
)
;
}
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
{
return
CaretOffset
(
)
;
}
return
aOffset
;
}
void
HyperTextAccessibleBase
:
:
TextSubstring
(
int32_t
aStartOffset
int32_t
aEndOffset
nsAString
&
aText
)
const
{
aText
.
Truncate
(
)
;
index_t
startOffset
=
ConvertMagicOffset
(
aStartOffset
)
;
index_t
endOffset
=
ConvertMagicOffset
(
aEndOffset
)
;
if
(
!
startOffset
.
IsValid
(
)
|
|
!
endOffset
.
IsValid
(
)
|
|
startOffset
>
endOffset
|
|
endOffset
>
CharacterCount
(
)
)
{
NS_ERROR
(
"
Wrong
in
offset
"
)
;
return
;
}
int32_t
startChildIdx
=
GetChildIndexAtOffset
(
startOffset
)
;
if
(
startChildIdx
=
=
-
1
)
{
return
;
}
int32_t
endChildIdx
=
GetChildIndexAtOffset
(
endOffset
)
;
if
(
endChildIdx
=
=
-
1
)
{
return
;
}
const
Accessible
*
thisAcc
=
Acc
(
)
;
if
(
startChildIdx
=
=
endChildIdx
)
{
int32_t
childOffset
=
GetChildOffset
(
startChildIdx
)
;
if
(
childOffset
=
=
-
1
)
{
return
;
}
Accessible
*
child
=
thisAcc
-
>
ChildAt
(
startChildIdx
)
;
child
-
>
AppendTextTo
(
aText
startOffset
-
childOffset
endOffset
-
startOffset
)
;
return
;
}
int32_t
startChildOffset
=
GetChildOffset
(
startChildIdx
)
;
if
(
startChildOffset
=
=
-
1
)
{
return
;
}
Accessible
*
startChild
=
thisAcc
-
>
ChildAt
(
startChildIdx
)
;
startChild
-
>
AppendTextTo
(
aText
startOffset
-
startChildOffset
)
;
for
(
int32_t
childIdx
=
startChildIdx
+
1
;
childIdx
<
endChildIdx
;
childIdx
+
+
)
{
Accessible
*
child
=
thisAcc
-
>
ChildAt
(
childIdx
)
;
child
-
>
AppendTextTo
(
aText
)
;
}
int32_t
endChildOffset
=
GetChildOffset
(
endChildIdx
)
;
if
(
endChildOffset
=
=
-
1
)
{
return
;
}
Accessible
*
endChild
=
thisAcc
-
>
ChildAt
(
endChildIdx
)
;
endChild
-
>
AppendTextTo
(
aText
0
endOffset
-
endChildOffset
)
;
}
bool
HyperTextAccessibleBase
:
:
CharAt
(
int32_t
aOffset
nsAString
&
aChar
int32_t
*
aStartOffset
int32_t
*
aEndOffset
)
{
MOZ_ASSERT
(
!
aStartOffset
=
=
!
aEndOffset
"
Offsets
should
be
both
defined
or
both
undefined
!
"
)
;
int32_t
childIdx
=
GetChildIndexAtOffset
(
aOffset
)
;
if
(
childIdx
=
=
-
1
)
{
return
false
;
}
Accessible
*
child
=
Acc
(
)
-
>
ChildAt
(
childIdx
)
;
child
-
>
AppendTextTo
(
aChar
aOffset
-
GetChildOffset
(
childIdx
)
1
)
;
if
(
aStartOffset
&
&
aEndOffset
)
{
*
aStartOffset
=
aOffset
;
*
aEndOffset
=
aOffset
+
aChar
.
Length
(
)
;
}
return
true
;
}
LayoutDeviceIntRect
HyperTextAccessibleBase
:
:
CharBounds
(
int32_t
aOffset
uint32_t
aCoordType
)
{
TextLeafPoint
point
=
ToTextLeafPoint
(
aOffset
false
)
;
if
(
!
point
.
mAcc
|
|
!
point
.
mAcc
-
>
IsRemote
(
)
|
|
!
point
.
mAcc
-
>
AsRemote
(
)
-
>
mCachedFields
)
{
return
LayoutDeviceIntRect
(
)
;
}
LayoutDeviceIntRect
bounds
=
point
.
CharBounds
(
)
;
nsAccUtils
:
:
ConvertScreenCoordsTo
(
&
bounds
.
x
&
bounds
.
y
aCoordType
Acc
(
)
)
;
return
bounds
;
}
LayoutDeviceIntRect
HyperTextAccessibleBase
:
:
TextBounds
(
int32_t
aStartOffset
int32_t
aEndOffset
uint32_t
aCoordType
)
{
LayoutDeviceIntRect
result
;
if
(
CharacterCount
(
)
=
=
0
)
{
result
=
Acc
(
)
-
>
Bounds
(
)
;
nsAccUtils
:
:
ConvertScreenCoordsTo
(
&
result
.
x
&
result
.
y
aCoordType
Acc
(
)
)
;
return
result
;
}
if
(
aEndOffset
>
-
1
&
&
aStartOffset
>
=
aEndOffset
)
{
return
LayoutDeviceIntRect
(
)
;
}
TextLeafPoint
currPoint
=
ToTextLeafPoint
(
aStartOffset
false
)
;
TextLeafPoint
endPoint
=
ToTextLeafPoint
(
ConvertMagicOffset
(
aEndOffset
)
true
)
;
if
(
!
endPoint
)
{
return
LayoutDeviceIntRect
(
)
;
}
endPoint
=
endPoint
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
false
)
;
if
(
endPoint
=
=
currPoint
)
{
result
=
currPoint
.
CharBounds
(
)
;
nsAccUtils
:
:
ConvertScreenCoordsTo
(
&
result
.
x
&
result
.
y
aCoordType
Acc
(
)
)
;
return
result
;
}
else
if
(
endPoint
<
currPoint
)
{
return
result
;
}
bool
locatedFinalLine
=
false
;
result
=
currPoint
.
CharBounds
(
)
;
while
(
!
locatedFinalLine
)
{
TextLeafPoint
lineStartPoint
=
currPoint
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_LINE_START
eDirNext
false
)
;
TextLeafPoint
lastPointInLine
=
lineStartPoint
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
false
)
;
if
(
endPoint
<
=
lastPointInLine
)
{
lastPointInLine
=
endPoint
;
locatedFinalLine
=
true
;
}
LayoutDeviceIntRect
currLine
=
currPoint
.
CharBounds
(
)
;
currLine
.
UnionRect
(
currLine
lastPointInLine
.
CharBounds
(
)
)
;
result
.
UnionRect
(
result
currLine
)
;
currPoint
=
lineStartPoint
;
}
nsAccUtils
:
:
ConvertScreenCoordsTo
(
&
result
.
x
&
result
.
y
aCoordType
Acc
(
)
)
;
return
result
;
}
int32_t
HyperTextAccessibleBase
:
:
OffsetAtPoint
(
int32_t
aX
int32_t
aY
uint32_t
aCoordType
)
{
Accessible
*
thisAcc
=
Acc
(
)
;
LayoutDeviceIntPoint
coords
=
nsAccUtils
:
:
ConvertToScreenCoords
(
aX
aY
aCoordType
thisAcc
)
;
if
(
!
thisAcc
-
>
Bounds
(
)
.
Contains
(
coords
.
x
coords
.
y
)
)
{
return
-
1
;
}
TextLeafPoint
point
=
ToTextLeafPoint
(
0
false
)
;
TextLeafPoint
endPoint
=
ToTextLeafPoint
(
static_cast
<
int32_t
>
(
CharacterCount
(
)
)
true
)
;
endPoint
=
endPoint
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
false
)
;
if
(
point
<
=
endPoint
)
{
for
(
;
!
point
.
ContainsPoint
(
coords
.
x
coords
.
y
)
&
&
point
!
=
endPoint
;
point
=
point
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirNext
false
)
)
{
}
}
if
(
!
point
.
ContainsPoint
(
coords
.
x
coords
.
y
)
)
{
return
-
1
;
}
DebugOnly
<
bool
>
ok
=
false
;
int32_t
htOffset
;
std
:
:
tie
(
ok
htOffset
)
=
TransformOffset
(
point
.
mAcc
point
.
mOffset
false
)
;
MOZ_ASSERT
(
ok
"
point
should
be
a
descendant
of
this
"
)
;
return
htOffset
;
}
TextLeafPoint
HyperTextAccessibleBase
:
:
ToTextLeafPoint
(
int32_t
aOffset
bool
aDescendToEnd
)
{
Accessible
*
thisAcc
=
Acc
(
)
;
if
(
!
thisAcc
-
>
HasChildren
(
)
)
{
return
TextLeafPoint
(
thisAcc
0
)
;
}
Accessible
*
child
=
GetChildAtOffset
(
aOffset
)
;
if
(
!
child
)
{
return
TextLeafPoint
(
)
;
}
if
(
HyperTextAccessibleBase
*
childHt
=
child
-
>
AsHyperTextBase
(
)
)
{
return
childHt
-
>
ToTextLeafPoint
(
aDescendToEnd
?
static_cast
<
int32_t
>
(
childHt
-
>
CharacterCount
(
)
)
:
0
aDescendToEnd
)
;
}
int32_t
offset
=
aOffset
-
GetChildOffset
(
child
)
;
return
TextLeafPoint
(
child
offset
)
;
}
std
:
:
pair
<
bool
int32_t
>
HyperTextAccessibleBase
:
:
TransformOffset
(
Accessible
*
aDescendant
int32_t
aOffset
bool
aIsEndOffset
)
const
{
const
Accessible
*
thisAcc
=
Acc
(
)
;
int32_t
offset
=
aOffset
;
Accessible
*
descendant
=
aDescendant
;
while
(
descendant
)
{
Accessible
*
parent
=
descendant
-
>
Parent
(
)
;
if
(
parent
=
=
thisAcc
)
{
return
{
true
GetChildOffset
(
descendant
)
+
offset
}
;
}
if
(
aIsEndOffset
)
{
offset
=
(
offset
>
0
|
|
descendant
-
>
IndexInParent
(
)
>
0
)
?
1
:
0
;
}
else
{
offset
=
0
;
}
descendant
=
parent
;
}
return
{
false
aIsEndOffset
?
static_cast
<
int32_t
>
(
CharacterCount
(
)
)
:
0
}
;
}
void
HyperTextAccessibleBase
:
:
AdjustOriginIfEndBoundary
(
TextLeafPoint
&
aOrigin
AccessibleTextBoundary
aBoundaryType
bool
aAtOffset
)
const
{
if
(
aBoundaryType
!
=
nsIAccessibleText
:
:
BOUNDARY_LINE_END
&
&
aBoundaryType
!
=
nsIAccessibleText
:
:
BOUNDARY_WORD_END
)
{
return
;
}
TextLeafPoint
actualOrig
=
aOrigin
.
IsCaret
(
)
?
aOrigin
.
ActualizeCaret
(
false
)
:
aOrigin
;
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_LINE_END
)
{
if
(
!
actualOrig
.
IsLineFeedChar
(
)
)
{
return
;
}
aOrigin
=
actualOrig
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
)
;
}
else
{
if
(
aAtOffset
)
{
aOrigin
=
actualOrig
;
return
;
}
if
(
!
actualOrig
.
IsSpace
(
)
)
{
return
;
}
TextLeafPoint
prevChar
=
actualOrig
.
FindBoundary
(
nsIAccessibleText
:
:
BOUNDARY_CHAR
eDirPrevious
)
;
if
(
prevChar
!
=
actualOrig
&
&
!
prevChar
.
IsSpace
(
)
)
{
aOrigin
=
prevChar
;
}
}
}
void
HyperTextAccessibleBase
:
:
TextBeforeOffset
(
int32_t
aOffset
AccessibleTextBoundary
aBoundaryType
int32_t
*
aStartOffset
int32_t
*
aEndOffset
nsAString
&
aText
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
;
*
aStartOffset
=
*
aEndOffset
=
0
;
aText
.
Truncate
(
)
;
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_SENTENCE_START
|
|
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_SENTENCE_END
)
{
return
;
}
uint32_t
adjustedOffset
=
ConvertMagicOffset
(
aOffset
)
;
if
(
adjustedOffset
=
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
{
NS_ERROR
(
"
Wrong
given
offset
!
"
)
;
return
;
}
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
)
{
if
(
adjustedOffset
>
0
)
{
CharAt
(
static_cast
<
int32_t
>
(
adjustedOffset
)
-
1
aText
aStartOffset
aEndOffset
)
;
}
return
;
}
TextLeafPoint
orig
;
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
{
orig
=
TextLeafPoint
:
:
GetCaret
(
Acc
(
)
)
;
}
else
{
orig
=
ToTextLeafPoint
(
static_cast
<
int32_t
>
(
adjustedOffset
)
)
;
}
AdjustOriginIfEndBoundary
(
orig
aBoundaryType
)
;
TextLeafPoint
end
=
orig
.
FindBoundary
(
aBoundaryType
eDirPrevious
true
)
;
bool
ok
;
std
:
:
tie
(
ok
*
aEndOffset
)
=
TransformOffset
(
end
.
mAcc
end
.
mOffset
true
)
;
if
(
!
ok
)
{
*
aStartOffset
=
*
aEndOffset
=
0
;
return
;
}
TextLeafPoint
start
=
end
.
FindBoundary
(
aBoundaryType
eDirPrevious
)
;
std
:
:
tie
(
ok
*
aStartOffset
)
=
TransformOffset
(
start
.
mAcc
start
.
mOffset
false
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
}
void
HyperTextAccessibleBase
:
:
TextAtOffset
(
int32_t
aOffset
AccessibleTextBoundary
aBoundaryType
int32_t
*
aStartOffset
int32_t
*
aEndOffset
nsAString
&
aText
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
;
*
aStartOffset
=
*
aEndOffset
=
0
;
aText
.
Truncate
(
)
;
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_SENTENCE_START
|
|
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_SENTENCE_END
)
{
return
;
}
uint32_t
adjustedOffset
=
ConvertMagicOffset
(
aOffset
)
;
if
(
adjustedOffset
=
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
{
NS_ERROR
(
"
Wrong
given
offset
!
"
)
;
return
;
}
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
)
{
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
{
TextLeafPoint
caret
=
TextLeafPoint
:
:
GetCaret
(
Acc
(
)
)
;
if
(
caret
.
IsCaretAtEndOfLine
(
)
)
{
*
aStartOffset
=
*
aEndOffset
=
static_cast
<
int32_t
>
(
adjustedOffset
)
;
return
;
}
}
CharAt
(
adjustedOffset
aText
aStartOffset
aEndOffset
)
;
return
;
}
TextLeafPoint
start
end
;
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
{
start
=
TextLeafPoint
:
:
GetCaret
(
Acc
(
)
)
;
AdjustOriginIfEndBoundary
(
start
aBoundaryType
true
)
;
end
=
start
;
}
else
{
start
=
ToTextLeafPoint
(
static_cast
<
int32_t
>
(
adjustedOffset
)
)
;
Accessible
*
childAcc
=
GetChildAtOffset
(
adjustedOffset
)
;
if
(
childAcc
&
&
childAcc
-
>
IsHyperText
(
)
)
{
end
=
ToTextLeafPoint
(
static_cast
<
int32_t
>
(
adjustedOffset
)
true
)
;
}
else
{
AdjustOriginIfEndBoundary
(
start
aBoundaryType
true
)
;
end
=
start
;
}
}
start
=
start
.
FindBoundary
(
aBoundaryType
eDirPrevious
true
)
;
bool
ok
;
std
:
:
tie
(
ok
*
aStartOffset
)
=
TransformOffset
(
start
.
mAcc
start
.
mOffset
false
)
;
end
=
end
.
FindBoundary
(
aBoundaryType
eDirNext
)
;
std
:
:
tie
(
ok
*
aEndOffset
)
=
TransformOffset
(
end
.
mAcc
end
.
mOffset
true
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
}
void
HyperTextAccessibleBase
:
:
TextAfterOffset
(
int32_t
aOffset
AccessibleTextBoundary
aBoundaryType
int32_t
*
aStartOffset
int32_t
*
aEndOffset
nsAString
&
aText
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
;
*
aStartOffset
=
*
aEndOffset
=
0
;
aText
.
Truncate
(
)
;
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_SENTENCE_START
|
|
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_SENTENCE_END
)
{
return
;
}
uint32_t
adjustedOffset
=
ConvertMagicOffset
(
aOffset
)
;
if
(
adjustedOffset
=
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
{
NS_ERROR
(
"
Wrong
given
offset
!
"
)
;
return
;
}
if
(
aBoundaryType
=
=
nsIAccessibleText
:
:
BOUNDARY_CHAR
)
{
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
&
&
adjustedOffset
>
0
&
&
TextLeafPoint
:
:
GetCaret
(
Acc
(
)
)
.
IsCaretAtEndOfLine
(
)
)
{
-
-
adjustedOffset
;
}
uint32_t
count
=
CharacterCount
(
)
;
if
(
adjustedOffset
>
=
count
)
{
*
aStartOffset
=
*
aEndOffset
=
static_cast
<
int32_t
>
(
count
)
;
}
else
{
CharAt
(
static_cast
<
int32_t
>
(
adjustedOffset
)
+
1
aText
aStartOffset
aEndOffset
)
;
}
return
;
}
TextLeafPoint
orig
;
if
(
aOffset
=
=
nsIAccessibleText
:
:
TEXT_OFFSET_CARET
)
{
orig
=
TextLeafPoint
:
:
GetCaret
(
Acc
(
)
)
;
}
else
{
orig
=
ToTextLeafPoint
(
static_cast
<
int32_t
>
(
adjustedOffset
)
true
)
;
}
AdjustOriginIfEndBoundary
(
orig
aBoundaryType
)
;
TextLeafPoint
start
=
orig
.
FindBoundary
(
aBoundaryType
eDirNext
)
;
bool
ok
;
std
:
:
tie
(
ok
*
aStartOffset
)
=
TransformOffset
(
start
.
mAcc
start
.
mOffset
false
)
;
if
(
!
ok
)
{
*
aStartOffset
=
*
aEndOffset
=
static_cast
<
int32_t
>
(
CharacterCount
(
)
)
;
return
;
}
TextLeafPoint
end
=
start
.
FindBoundary
(
aBoundaryType
eDirNext
)
;
std
:
:
tie
(
ok
*
aEndOffset
)
=
TransformOffset
(
end
.
mAcc
end
.
mOffset
true
)
;
TextSubstring
(
*
aStartOffset
*
aEndOffset
aText
)
;
}
int32_t
HyperTextAccessibleBase
:
:
CaretOffset
(
)
const
{
TextLeafPoint
point
=
TextLeafPoint
:
:
GetCaret
(
const_cast
<
Accessible
*
>
(
Acc
(
)
)
)
.
ActualizeCaret
(
false
)
;
if
(
point
.
mOffset
=
=
0
&
&
point
.
mAcc
=
=
Acc
(
)
)
{
return
0
;
}
auto
[
ok
htOffset
]
=
TransformOffset
(
point
.
mAcc
point
.
mOffset
false
)
;
if
(
!
ok
)
{
return
-
1
;
}
return
htOffset
;
}
bool
HyperTextAccessibleBase
:
:
IsValidOffset
(
int32_t
aOffset
)
{
index_t
offset
=
ConvertMagicOffset
(
aOffset
)
;
return
offset
.
IsValid
(
)
&
&
offset
<
=
CharacterCount
(
)
;
}
bool
HyperTextAccessibleBase
:
:
IsValidRange
(
int32_t
aStartOffset
int32_t
aEndOffset
)
{
index_t
startOffset
=
ConvertMagicOffset
(
aStartOffset
)
;
index_t
endOffset
=
ConvertMagicOffset
(
aEndOffset
)
;
return
startOffset
.
IsValid
(
)
&
&
endOffset
.
IsValid
(
)
&
&
startOffset
<
=
endOffset
&
&
endOffset
<
=
CharacterCount
(
)
;
}
uint32_t
HyperTextAccessibleBase
:
:
LinkCount
(
)
{
return
Acc
(
)
-
>
EmbeddedChildCount
(
)
;
}
Accessible
*
HyperTextAccessibleBase
:
:
LinkAt
(
uint32_t
aIndex
)
{
return
Acc
(
)
-
>
EmbeddedChildAt
(
aIndex
)
;
}
int32_t
HyperTextAccessibleBase
:
:
LinkIndexOf
(
Accessible
*
aLink
)
{
return
Acc
(
)
-
>
IndexOfEmbeddedChild
(
aLink
)
;
}
already_AddRefed
<
AccAttributes
>
HyperTextAccessibleBase
:
:
TextAttributes
(
bool
aIncludeDefAttrs
int32_t
aOffset
int32_t
*
aStartOffset
int32_t
*
aEndOffset
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
accessibility_cache_enabled_AtStartup
(
)
)
;
*
aStartOffset
=
*
aEndOffset
=
0
;
index_t
offset
=
ConvertMagicOffset
(
aOffset
)
;
if
(
!
offset
.
IsValid
(
)
|
|
offset
>
CharacterCount
(
)
)
{
NS_ERROR
(
"
Wrong
in
offset
!
"
)
;
return
RefPtr
{
new
AccAttributes
(
)
}
.
forget
(
)
;
}
Accessible
*
originAcc
=
GetChildAtOffset
(
offset
)
;
if
(
!
originAcc
)
{
if
(
offset
=
=
0
)
{
if
(
aIncludeDefAttrs
)
{
return
DefaultTextAttributes
(
)
;
}
}
return
RefPtr
{
new
AccAttributes
(
)
}
.
forget
(
)
;
}
if
(
!
originAcc
-
>
IsText
(
)
)
{
*
aStartOffset
=
aOffset
;
*
aEndOffset
=
aOffset
+
1
;
Accessible
*
parent
=
originAcc
-
>
Parent
(
)
;
if
(
!
parent
)
{
return
RefPtr
{
new
AccAttributes
(
)
}
.
forget
(
)
;
}
int32_t
originIdx
=
originAcc
-
>
IndexInParent
(
)
;
if
(
originIdx
>
0
)
{
for
(
uint32_t
idx
=
originIdx
-
1
;
;
-
-
idx
)
{
Accessible
*
sibling
=
parent
-
>
ChildAt
(
idx
)
;
if
(
sibling
-
>
IsText
(
)
)
{
break
;
}
-
-
*
aStartOffset
;
if
(
idx
=
=
0
)
{
break
;
}
}
}
for
(
uint32_t
idx
=
originIdx
+
1
;
;
+
+
idx
)
{
Accessible
*
sibling
=
parent
-
>
ChildAt
(
idx
)
;
if
(
!
sibling
|
|
sibling
-
>
IsText
(
)
)
{
break
;
}
+
+
*
aEndOffset
;
}
return
RefPtr
{
new
AccAttributes
(
)
}
.
forget
(
)
;
}
TextLeafPoint
origin
=
ToTextLeafPoint
(
static_cast
<
int32_t
>
(
offset
)
)
;
TextLeafPoint
start
=
origin
.
FindTextAttrsStart
(
eDirPrevious
true
)
;
bool
ok
;
std
:
:
tie
(
ok
*
aStartOffset
)
=
TransformOffset
(
start
.
mAcc
start
.
mOffset
false
)
;
TextLeafPoint
end
=
origin
.
FindTextAttrsStart
(
eDirNext
false
)
;
std
:
:
tie
(
ok
*
aEndOffset
)
=
TransformOffset
(
end
.
mAcc
end
.
mOffset
true
)
;
return
origin
.
GetTextAttributes
(
aIncludeDefAttrs
)
;
}
void
HyperTextAccessibleBase
:
:
CroppedSelectionRanges
(
nsTArray
<
TextRange
>
&
aRanges
)
const
{
SelectionRanges
(
&
aRanges
)
;
const
Accessible
*
acc
=
Acc
(
)
;
aRanges
.
RemoveElementsBy
(
[
acc
]
(
auto
&
range
)
{
if
(
range
.
StartPoint
(
)
=
=
range
.
EndPoint
(
)
)
{
return
true
;
}
if
(
!
acc
-
>
IsDoc
(
)
)
{
return
!
range
.
Crop
(
const_cast
<
Accessible
*
>
(
acc
)
)
;
}
return
false
;
}
)
;
}
int32_t
HyperTextAccessibleBase
:
:
SelectionCount
(
)
{
nsTArray
<
TextRange
>
ranges
;
CroppedSelectionRanges
(
ranges
)
;
return
static_cast
<
int32_t
>
(
ranges
.
Length
(
)
)
;
}
bool
HyperTextAccessibleBase
:
:
SelectionBoundsAt
(
int32_t
aSelectionNum
int32_t
*
aStartOffset
int32_t
*
aEndOffset
)
{
nsTArray
<
TextRange
>
ranges
;
CroppedSelectionRanges
(
ranges
)
;
if
(
aSelectionNum
>
=
static_cast
<
int32_t
>
(
ranges
.
Length
(
)
)
)
{
return
false
;
}
TextRange
&
range
=
ranges
[
aSelectionNum
]
;
Accessible
*
thisAcc
=
Acc
(
)
;
if
(
range
.
StartContainer
(
)
=
=
thisAcc
)
{
*
aStartOffset
=
range
.
StartOffset
(
)
;
}
else
{
bool
ok
;
std
:
:
tie
(
ok
*
aStartOffset
)
=
TransformOffset
(
range
.
StartContainer
(
)
0
false
)
;
}
if
(
range
.
EndContainer
(
)
=
=
thisAcc
)
{
*
aEndOffset
=
range
.
EndOffset
(
)
;
}
else
{
bool
ok
;
std
:
:
tie
(
ok
*
aEndOffset
)
=
TransformOffset
(
range
.
EndContainer
(
)
range
.
EndOffset
(
)
=
=
0
?
0
:
1
true
)
;
}
return
true
;
}
}
