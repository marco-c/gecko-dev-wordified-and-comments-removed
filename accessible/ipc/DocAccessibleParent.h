#
ifndef
mozilla_a11y_DocAccessibleParent_h
#
define
mozilla_a11y_DocAccessibleParent_h
#
include
"
nsAccessibilityService
.
h
"
#
include
"
mozilla
/
a11y
/
PDocAccessibleParent
.
h
"
#
include
"
mozilla
/
a11y
/
RemoteAccessible
.
h
"
#
include
"
mozilla
/
dom
/
BrowserBridgeParent
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
{
namespace
dom
{
class
CanonicalBrowsingContext
;
}
namespace
a11y
{
class
TextRange
;
class
xpcAccessibleGeneric
;
#
if
!
defined
(
XP_WIN
)
class
DocAccessiblePlatformExtParent
;
#
endif
class
DocAccessibleParent
:
public
RemoteAccessible
public
PDocAccessibleParent
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
DocAccessibleParent
)
;
DocAccessibleParent
(
)
;
void
SetTopLevel
(
)
{
mTopLevel
=
true
;
mTopLevelInContentProcess
=
true
;
}
bool
IsTopLevel
(
)
const
{
return
mTopLevel
;
}
void
SetTopLevelInContentProcess
(
)
{
mTopLevelInContentProcess
=
true
;
}
bool
IsTopLevelInContentProcess
(
)
const
{
return
mTopLevelInContentProcess
;
}
bool
IsShutdown
(
)
const
{
return
mShutdown
;
}
void
MarkAsShutdown
(
)
{
MOZ_ASSERT
(
mChildDocs
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mAccessibles
.
Count
(
)
=
=
0
)
;
mShutdown
=
true
;
}
void
SetBrowsingContext
(
dom
:
:
CanonicalBrowsingContext
*
aBrowsingContext
)
;
dom
:
:
CanonicalBrowsingContext
*
GetBrowsingContext
(
)
const
{
return
mBrowsingContext
;
}
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvEvent
(
const
uint64_t
&
aID
const
uint32_t
&
aType
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvShowEvent
(
const
ShowEventData
&
aData
const
bool
&
aFromUser
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvHideEvent
(
const
uint64_t
&
aRootID
const
bool
&
aFromUser
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvStateChangeEvent
(
const
uint64_t
&
aID
const
uint64_t
&
aState
const
bool
&
aEnabled
)
final
;
mozilla
:
:
ipc
:
:
IPCResult
RecvCaretMoveEvent
(
const
uint64_t
&
aID
#
if
defined
(
XP_WIN
)
const
LayoutDeviceIntRect
&
aCaretRect
#
endif
const
int32_t
&
aOffset
const
bool
&
aIsSelectionCollapsed
const
bool
&
aIsAtEndOfLine
const
int32_t
&
aGranularity
)
final
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvTextChangeEvent
(
const
uint64_t
&
aID
const
nsAString
&
aStr
const
int32_t
&
aStart
const
uint32_t
&
aLen
const
bool
&
aIsInsert
const
bool
&
aFromUser
)
override
;
#
if
defined
(
XP_WIN
)
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvSyncTextChangeEvent
(
const
uint64_t
&
aID
const
nsAString
&
aStr
const
int32_t
&
aStart
const
uint32_t
&
aLen
const
bool
&
aIsInsert
const
bool
&
aFromUser
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvFocusEvent
(
const
uint64_t
&
aID
const
LayoutDeviceIntRect
&
aCaretRect
)
override
;
#
endif
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvSelectionEvent
(
const
uint64_t
&
aID
const
uint64_t
&
aWidgetID
const
uint32_t
&
aType
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvVirtualCursorChangeEvent
(
const
uint64_t
&
aID
const
uint64_t
&
aOldPositionID
const
int32_t
&
aOldStartOffset
const
int32_t
&
aOldEndOffset
const
uint64_t
&
aNewPositionID
const
int32_t
&
aNewStartOffset
const
int32_t
&
aNewEndOffset
const
int16_t
&
aReason
const
int16_t
&
aBoundaryType
const
bool
&
aFromUser
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvScrollingEvent
(
const
uint64_t
&
aID
const
uint64_t
&
aType
const
uint32_t
&
aScrollX
const
uint32_t
&
aScrollY
const
uint32_t
&
aMaxScrollX
const
uint32_t
&
aMaxScrollY
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvCache
(
const
mozilla
:
:
a11y
:
:
CacheUpdateType
&
aUpdateType
nsTArray
<
CacheData
>
&
&
aData
const
bool
&
aFinal
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvSelectedAccessiblesChanged
(
nsTArray
<
uint64_t
>
&
&
aSelectedIDs
nsTArray
<
uint64_t
>
&
&
aUnselectedIDs
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvAccessiblesWillMove
(
nsTArray
<
uint64_t
>
&
&
aIDs
)
override
;
#
if
!
defined
(
XP_WIN
)
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvAnnouncementEvent
(
const
uint64_t
&
aID
const
nsAString
&
aAnnouncement
const
uint16_t
&
aPriority
)
override
;
#
endif
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvTextSelectionChangeEvent
(
const
uint64_t
&
aID
nsTArray
<
TextRangeData
>
&
&
aSelection
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvRoleChangedEvent
(
const
a11y
:
:
role
&
aRole
)
final
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvBindChildDoc
(
PDocAccessibleParent
*
aChildDoc
const
uint64_t
&
aID
)
override
;
void
Unbind
(
)
{
if
(
DocAccessibleParent
*
parent
=
ParentDoc
(
)
)
{
parent
-
>
RemoveChildDoc
(
this
)
;
}
SetParent
(
nullptr
)
;
}
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvShutdown
(
)
override
;
void
Destroy
(
)
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
DocAccessibleParent
*
ParentDoc
(
)
const
;
static
const
uint64_t
kNoParentDoc
=
UINT64_MAX
;
ipc
:
:
IPCResult
AddChildDoc
(
DocAccessibleParent
*
aChildDoc
uint64_t
aParentID
bool
aCreating
=
true
)
;
ipc
:
:
IPCResult
AddChildDoc
(
dom
:
:
BrowserBridgeParent
*
aBridge
)
;
void
RemovePendingOOPChildDoc
(
dom
:
:
BrowserBridgeParent
*
aBridge
)
{
mPendingOOPChildDocs
.
Remove
(
aBridge
)
;
}
void
RemoveChildDoc
(
DocAccessibleParent
*
aChildDoc
)
{
RemoteAccessible
*
parent
=
aChildDoc
-
>
RemoteParent
(
)
;
MOZ_ASSERT
(
parent
)
;
if
(
parent
)
{
aChildDoc
-
>
RemoteParent
(
)
-
>
ClearChildDoc
(
aChildDoc
)
;
}
DebugOnly
<
bool
>
result
=
mChildDocs
.
RemoveElement
(
aChildDoc
-
>
mActorID
)
;
aChildDoc
-
>
mParentDoc
=
kNoParentDoc
;
MOZ_ASSERT
(
result
)
;
}
void
RemoveAccessible
(
RemoteAccessible
*
aAccessible
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mAccessibles
.
GetEntry
(
aAccessible
-
>
ID
(
)
)
)
;
mAccessibles
.
RemoveEntry
(
aAccessible
-
>
ID
(
)
)
;
}
RemoteAccessible
*
GetAccessible
(
uintptr_t
aID
)
{
if
(
!
aID
)
return
this
;
ProxyEntry
*
e
=
mAccessibles
.
GetEntry
(
aID
)
;
return
e
?
e
-
>
mProxy
:
nullptr
;
}
const
RemoteAccessible
*
GetAccessible
(
uintptr_t
aID
)
const
{
return
const_cast
<
DocAccessibleParent
*
>
(
this
)
-
>
GetAccessible
(
aID
)
;
}
size_t
ChildDocCount
(
)
const
{
return
mChildDocs
.
Length
(
)
;
}
const
DocAccessibleParent
*
ChildDocAt
(
size_t
aIdx
)
const
{
return
const_cast
<
DocAccessibleParent
*
>
(
this
)
-
>
ChildDocAt
(
aIdx
)
;
}
DocAccessibleParent
*
ChildDocAt
(
size_t
aIdx
)
{
return
LiveDocs
(
)
.
Get
(
mChildDocs
[
aIdx
]
)
;
}
#
if
defined
(
XP_WIN
)
void
MaybeInitWindowEmulation
(
)
;
void
SendParentCOMProxy
(
Accessible
*
aOuterDoc
)
;
void
SetEmulatedWindowHandle
(
HWND
aWindowHandle
)
;
HWND
GetEmulatedWindowHandle
(
)
const
{
return
mEmulatedWindowHandle
;
}
#
endif
#
if
!
defined
(
XP_WIN
)
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvBatch
(
const
uint64_t
&
aBatchType
nsTArray
<
BatchData
>
&
&
aData
)
override
;
virtual
bool
DeallocPDocAccessiblePlatformExtParent
(
PDocAccessiblePlatformExtParent
*
aActor
)
override
;
virtual
PDocAccessiblePlatformExtParent
*
AllocPDocAccessiblePlatformExtParent
(
)
override
;
DocAccessiblePlatformExtParent
*
GetPlatformExtension
(
)
;
#
endif
virtual
Accessible
*
Parent
(
)
const
override
{
if
(
IsTopLevel
(
)
)
{
return
OuterDocOfRemoteBrowser
(
)
;
}
return
RemoteParent
(
)
;
}
virtual
int32_t
IndexInParent
(
)
const
override
{
if
(
IsTopLevel
(
)
&
&
OuterDocOfRemoteBrowser
(
)
)
{
return
0
;
}
return
RemoteAccessible
:
:
IndexInParent
(
)
;
}
RemoteAccessible
*
GetFocusedAcc
(
)
const
{
return
const_cast
<
DocAccessibleParent
*
>
(
this
)
-
>
GetAccessible
(
mFocus
)
;
}
std
:
:
pair
<
RemoteAccessible
*
int32_t
>
GetCaret
(
)
const
{
if
(
mCaretOffset
=
=
-
1
)
{
return
{
nullptr
-
1
}
;
}
RemoteAccessible
*
acc
=
const_cast
<
DocAccessibleParent
*
>
(
this
)
-
>
GetAccessible
(
mCaretId
)
;
if
(
!
acc
)
{
return
{
nullptr
-
1
}
;
}
return
{
acc
mCaretOffset
}
;
}
bool
IsCaretAtEndOfLine
(
)
const
{
return
mIsCaretAtEndOfLine
;
}
virtual
void
SelectionRanges
(
nsTArray
<
TextRange
>
*
aRanges
)
const
override
;
void
URL
(
nsAString
&
aURL
)
const
;
nsTHashMap
<
uint64_t
nsTHashMap
<
uint64_t
nsTArray
<
uint64_t
>
>
>
mReverseRelations
;
private
:
~
DocAccessibleParent
(
)
;
class
ProxyEntry
:
public
PLDHashEntryHdr
{
public
:
explicit
ProxyEntry
(
const
void
*
)
:
mProxy
(
nullptr
)
{
}
ProxyEntry
(
ProxyEntry
&
&
aOther
)
:
mProxy
(
aOther
.
mProxy
)
{
aOther
.
mProxy
=
nullptr
;
}
~
ProxyEntry
(
)
{
delete
mProxy
;
}
typedef
uint64_t
KeyType
;
typedef
const
void
*
KeyTypePointer
;
bool
KeyEquals
(
const
void
*
aKey
)
const
{
return
mProxy
-
>
ID
(
)
=
=
(
uint64_t
)
aKey
;
}
static
const
void
*
KeyToPointer
(
uint64_t
aKey
)
{
return
(
void
*
)
aKey
;
}
static
PLDHashNumber
HashKey
(
const
void
*
aKey
)
{
return
(
uint64_t
)
aKey
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
RemoteAccessible
*
mProxy
;
}
;
uint32_t
AddSubtree
(
RemoteAccessible
*
aParent
const
nsTArray
<
AccessibleData
>
&
aNewTree
uint32_t
aIdx
uint32_t
aIdxInParent
)
;
[
[
nodiscard
]
]
bool
CheckDocTree
(
)
const
;
xpcAccessibleGeneric
*
GetXPCAccessible
(
RemoteAccessible
*
aProxy
)
;
void
FireEvent
(
RemoteAccessible
*
aAcc
const
uint32_t
&
aType
)
;
void
ShutdownOrPrepareForMove
(
RemoteAccessible
*
aAcc
)
;
nsTArray
<
uint64_t
>
mChildDocs
;
uint64_t
mParentDoc
;
#
if
defined
(
XP_WIN
)
HWND
mEmulatedWindowHandle
;
#
if
defined
(
MOZ_SANDBOX
)
mscom
:
:
PreservedStreamPtr
mParentProxyStream
;
mscom
:
:
PreservedStreamPtr
mDocProxyStream
;
mscom
:
:
PreservedStreamPtr
mTopLevelDocProxyStream
;
#
endif
#
endif
nsTHashtable
<
ProxyEntry
>
mAccessibles
;
nsTHashSet
<
uint64_t
>
mMovingIDs
;
uint64_t
mActorID
;
bool
mTopLevel
;
bool
mTopLevelInContentProcess
;
bool
mShutdown
;
RefPtr
<
dom
:
:
CanonicalBrowsingContext
>
mBrowsingContext
;
nsTHashSet
<
RefPtr
<
dom
:
:
BrowserBridgeParent
>
>
mPendingOOPChildDocs
;
uint64_t
mFocus
;
uint64_t
mCaretId
;
int32_t
mCaretOffset
;
bool
mIsCaretAtEndOfLine
;
nsTArray
<
TextRangeData
>
mTextSelections
;
static
uint64_t
sMaxDocID
;
static
nsTHashMap
<
nsUint64HashKey
DocAccessibleParent
*
>
&
LiveDocs
(
)
{
static
nsTHashMap
<
nsUint64HashKey
DocAccessibleParent
*
>
sLiveDocs
;
return
sLiveDocs
;
}
}
;
}
}
#
endif
