#
ifndef
mozilla_a11y_DocAccessibleParent_h
#
define
mozilla_a11y_DocAccessibleParent_h
#
include
"
nsAccessibilityService
.
h
"
#
include
"
mozilla
/
a11y
/
PDocAccessibleParent
.
h
"
#
include
"
mozilla
/
a11y
/
RemoteAccessible
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
{
namespace
a11y
{
class
xpcAccessibleGeneric
;
#
if
!
defined
(
XP_WIN
)
class
DocAccessiblePlatformExtParent
;
#
endif
class
DocAccessibleParent
:
public
RemoteAccessible
public
PDocAccessibleParent
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
DocAccessibleParent
)
;
DocAccessibleParent
(
)
:
RemoteAccessible
(
this
)
mParentDoc
(
kNoParentDoc
)
#
if
defined
(
XP_WIN
)
mEmulatedWindowHandle
(
nullptr
)
#
endif
mTopLevel
(
false
)
mTopLevelInContentProcess
(
false
)
mShutdown
(
false
)
{
sMaxDocID
+
+
;
mActorID
=
sMaxDocID
;
MOZ_ASSERT
(
!
LiveDocs
(
)
.
Get
(
mActorID
)
)
;
LiveDocs
(
)
.
InsertOrUpdate
(
mActorID
this
)
;
}
void
SetTopLevel
(
)
{
mTopLevel
=
true
;
mTopLevelInContentProcess
=
true
;
}
bool
IsTopLevel
(
)
const
{
return
mTopLevel
;
}
void
SetTopLevelInContentProcess
(
)
{
mTopLevelInContentProcess
=
true
;
}
bool
IsTopLevelInContentProcess
(
)
const
{
return
mTopLevelInContentProcess
;
}
bool
IsShutdown
(
)
const
{
return
mShutdown
;
}
void
MarkAsShutdown
(
)
{
MOZ_ASSERT
(
mChildDocs
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mAccessibles
.
Count
(
)
=
=
0
)
;
mShutdown
=
true
;
}
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvEvent
(
const
uint64_t
&
aID
const
uint32_t
&
aType
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvShowEvent
(
const
ShowEventData
&
aData
const
bool
&
aFromUser
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvHideEvent
(
const
uint64_t
&
aRootID
const
bool
&
aFromUser
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvStateChangeEvent
(
const
uint64_t
&
aID
const
uint64_t
&
aState
const
bool
&
aEnabled
)
final
;
mozilla
:
:
ipc
:
:
IPCResult
RecvCaretMoveEvent
(
const
uint64_t
&
aID
#
if
defined
(
XP_WIN
)
const
LayoutDeviceIntRect
&
aCaretRect
#
endif
const
int32_t
&
aOffset
const
bool
&
aIsSelectionCollapsed
)
final
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvTextChangeEvent
(
const
uint64_t
&
aID
const
nsString
&
aStr
const
int32_t
&
aStart
const
uint32_t
&
aLen
const
bool
&
aIsInsert
const
bool
&
aFromUser
)
override
;
#
if
defined
(
XP_WIN
)
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvSyncTextChangeEvent
(
const
uint64_t
&
aID
const
nsString
&
aStr
const
int32_t
&
aStart
const
uint32_t
&
aLen
const
bool
&
aIsInsert
const
bool
&
aFromUser
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvFocusEvent
(
const
uint64_t
&
aID
const
LayoutDeviceIntRect
&
aCaretRect
)
override
;
#
endif
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvSelectionEvent
(
const
uint64_t
&
aID
const
uint64_t
&
aWidgetID
const
uint32_t
&
aType
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvVirtualCursorChangeEvent
(
const
uint64_t
&
aID
const
uint64_t
&
aOldPositionID
const
int32_t
&
aOldStartOffset
const
int32_t
&
aOldEndOffset
const
uint64_t
&
aNewPositionID
const
int32_t
&
aNewStartOffset
const
int32_t
&
aNewEndOffset
const
int16_t
&
aReason
const
int16_t
&
aBoundaryType
const
bool
&
aFromUser
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvScrollingEvent
(
const
uint64_t
&
aID
const
uint64_t
&
aType
const
uint32_t
&
aScrollX
const
uint32_t
&
aScrollY
const
uint32_t
&
aMaxScrollX
const
uint32_t
&
aMaxScrollY
)
override
;
#
if
!
defined
(
XP_WIN
)
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvAnnouncementEvent
(
const
uint64_t
&
aID
const
nsString
&
aAnnouncement
const
uint16_t
&
aPriority
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvTextSelectionChangeEvent
(
const
uint64_t
&
aID
nsTArray
<
TextRangeData
>
&
&
aSelection
)
override
;
#
endif
mozilla
:
:
ipc
:
:
IPCResult
RecvRoleChangedEvent
(
const
a11y
:
:
role
&
aRole
)
final
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvBindChildDoc
(
PDocAccessibleParent
*
aChildDoc
const
uint64_t
&
aID
)
override
;
void
Unbind
(
)
{
if
(
DocAccessibleParent
*
parent
=
ParentDoc
(
)
)
{
parent
-
>
RemoveChildDoc
(
this
)
;
}
SetParent
(
nullptr
)
;
}
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvShutdown
(
)
override
;
void
Destroy
(
)
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
{
MOZ_ASSERT
(
CheckDocTree
(
)
)
;
if
(
!
mShutdown
)
Destroy
(
)
;
}
DocAccessibleParent
*
ParentDoc
(
)
const
;
static
const
uint64_t
kNoParentDoc
=
UINT64_MAX
;
ipc
:
:
IPCResult
AddChildDoc
(
DocAccessibleParent
*
aChildDoc
uint64_t
aParentID
bool
aCreating
=
true
)
;
void
RemoveChildDoc
(
DocAccessibleParent
*
aChildDoc
)
{
RemoteAccessible
*
parent
=
aChildDoc
-
>
RemoteParent
(
)
;
MOZ_ASSERT
(
parent
)
;
if
(
parent
)
{
aChildDoc
-
>
RemoteParent
(
)
-
>
ClearChildDoc
(
aChildDoc
)
;
}
DebugOnly
<
bool
>
result
=
mChildDocs
.
RemoveElement
(
aChildDoc
-
>
mActorID
)
;
aChildDoc
-
>
mParentDoc
=
kNoParentDoc
;
MOZ_ASSERT
(
result
)
;
}
void
RemoveAccessible
(
RemoteAccessible
*
aAccessible
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mAccessibles
.
GetEntry
(
aAccessible
-
>
ID
(
)
)
)
;
mAccessibles
.
RemoveEntry
(
aAccessible
-
>
ID
(
)
)
;
}
RemoteAccessible
*
GetAccessible
(
uintptr_t
aID
)
{
if
(
!
aID
)
return
this
;
ProxyEntry
*
e
=
mAccessibles
.
GetEntry
(
aID
)
;
return
e
?
e
-
>
mProxy
:
nullptr
;
}
const
RemoteAccessible
*
GetAccessible
(
uintptr_t
aID
)
const
{
return
const_cast
<
DocAccessibleParent
*
>
(
this
)
-
>
GetAccessible
(
aID
)
;
}
size_t
ChildDocCount
(
)
const
{
return
mChildDocs
.
Length
(
)
;
}
const
DocAccessibleParent
*
ChildDocAt
(
size_t
aIdx
)
const
{
return
const_cast
<
DocAccessibleParent
*
>
(
this
)
-
>
ChildDocAt
(
aIdx
)
;
}
DocAccessibleParent
*
ChildDocAt
(
size_t
aIdx
)
{
return
LiveDocs
(
)
.
Get
(
mChildDocs
[
aIdx
]
)
;
}
#
if
defined
(
XP_WIN
)
void
MaybeInitWindowEmulation
(
)
;
void
SendParentCOMProxy
(
LocalAccessible
*
aOuterDoc
)
;
void
SetEmulatedWindowHandle
(
HWND
aWindowHandle
)
;
HWND
GetEmulatedWindowHandle
(
)
const
{
return
mEmulatedWindowHandle
;
}
#
endif
#
if
!
defined
(
XP_WIN
)
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvBatch
(
const
uint64_t
&
aBatchType
nsTArray
<
BatchData
>
&
&
aData
)
override
;
virtual
bool
DeallocPDocAccessiblePlatformExtParent
(
PDocAccessiblePlatformExtParent
*
aActor
)
override
;
virtual
PDocAccessiblePlatformExtParent
*
AllocPDocAccessiblePlatformExtParent
(
)
override
;
DocAccessiblePlatformExtParent
*
GetPlatformExtension
(
)
;
#
endif
Tuple
<
DocAccessibleParent
*
uint64_t
>
GetRemoteEmbedder
(
)
;
private
:
~
DocAccessibleParent
(
)
{
LiveDocs
(
)
.
Remove
(
mActorID
)
;
MOZ_ASSERT
(
mChildDocs
.
Length
(
)
=
=
0
)
;
MOZ_ASSERT
(
!
ParentDoc
(
)
)
;
}
class
ProxyEntry
:
public
PLDHashEntryHdr
{
public
:
explicit
ProxyEntry
(
const
void
*
)
:
mProxy
(
nullptr
)
{
}
ProxyEntry
(
ProxyEntry
&
&
aOther
)
:
mProxy
(
aOther
.
mProxy
)
{
aOther
.
mProxy
=
nullptr
;
}
~
ProxyEntry
(
)
{
delete
mProxy
;
}
typedef
uint64_t
KeyType
;
typedef
const
void
*
KeyTypePointer
;
bool
KeyEquals
(
const
void
*
aKey
)
const
{
return
mProxy
-
>
ID
(
)
=
=
(
uint64_t
)
aKey
;
}
static
const
void
*
KeyToPointer
(
uint64_t
aKey
)
{
return
(
void
*
)
aKey
;
}
static
PLDHashNumber
HashKey
(
const
void
*
aKey
)
{
return
(
uint64_t
)
aKey
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
RemoteAccessible
*
mProxy
;
}
;
uint32_t
AddSubtree
(
RemoteAccessible
*
aParent
const
nsTArray
<
AccessibleData
>
&
aNewTree
uint32_t
aIdx
uint32_t
aIdxInParent
)
;
[
[
nodiscard
]
]
bool
CheckDocTree
(
)
const
;
xpcAccessibleGeneric
*
GetXPCAccessible
(
RemoteAccessible
*
aProxy
)
;
nsTArray
<
uint64_t
>
mChildDocs
;
uint64_t
mParentDoc
;
#
if
defined
(
XP_WIN
)
HWND
mEmulatedWindowHandle
;
#
if
defined
(
MOZ_SANDBOX
)
mscom
:
:
PreservedStreamPtr
mParentProxyStream
;
mscom
:
:
PreservedStreamPtr
mDocProxyStream
;
mscom
:
:
PreservedStreamPtr
mTopLevelDocProxyStream
;
#
endif
#
endif
nsTHashtable
<
ProxyEntry
>
mAccessibles
;
uint64_t
mActorID
;
bool
mTopLevel
;
bool
mTopLevelInContentProcess
;
bool
mShutdown
;
struct
PendingChildDoc
{
PendingChildDoc
(
DocAccessibleParent
*
aChildDoc
uint64_t
aParentID
)
:
mChildDoc
(
aChildDoc
)
mParentID
(
aParentID
)
{
}
RefPtr
<
DocAccessibleParent
>
mChildDoc
;
uint64_t
mParentID
;
}
;
nsTArray
<
PendingChildDoc
>
mPendingChildDocs
;
static
uint64_t
sMaxDocID
;
static
nsTHashMap
<
nsUint64HashKey
DocAccessibleParent
*
>
&
LiveDocs
(
)
{
static
nsTHashMap
<
nsUint64HashKey
DocAccessibleParent
*
>
sLiveDocs
;
return
sLiveDocs
;
}
}
;
}
}
#
endif
