#
ifndef
mozilla_a11y_DocAccessibleParent_h
#
define
mozilla_a11y_DocAccessibleParent_h
#
include
"
nsAccessibilityService
.
h
"
#
include
"
mozilla
/
a11y
/
PDocAccessibleParent
.
h
"
#
include
"
mozilla
/
a11y
/
ProxyAccessible
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
{
namespace
a11y
{
class
xpcAccessibleGeneric
;
class
DocAccessibleParent
:
public
ProxyAccessible
public
PDocAccessibleParent
{
public
:
DocAccessibleParent
(
)
:
ProxyAccessible
(
this
)
mParentDoc
(
kNoParentDoc
)
#
if
defined
(
XP_WIN
)
mEmulatedWindowHandle
(
nullptr
)
#
endif
mTopLevel
(
false
)
mShutdown
(
false
)
{
MOZ_COUNT_CTOR_INHERITED
(
DocAccessibleParent
ProxyAccessible
)
;
sMaxDocID
+
+
;
mActorID
=
sMaxDocID
;
MOZ_ASSERT
(
!
LiveDocs
(
)
.
Get
(
mActorID
)
)
;
LiveDocs
(
)
.
Put
(
mActorID
this
)
;
}
~
DocAccessibleParent
(
)
{
LiveDocs
(
)
.
Remove
(
mActorID
)
;
MOZ_COUNT_DTOR_INHERITED
(
DocAccessibleParent
ProxyAccessible
)
;
MOZ_ASSERT
(
mChildDocs
.
Length
(
)
=
=
0
)
;
MOZ_ASSERT
(
!
ParentDoc
(
)
)
;
}
void
SetTopLevel
(
)
{
mTopLevel
=
true
;
}
bool
IsTopLevel
(
)
const
{
return
mTopLevel
;
}
bool
IsShutdown
(
)
const
{
return
mShutdown
;
}
void
MarkAsShutdown
(
)
{
MOZ_ASSERT
(
mChildDocs
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mAccessibles
.
Count
(
)
=
=
0
)
;
mShutdown
=
true
;
}
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvEvent
(
const
uint64_t
&
aID
const
uint32_t
&
aType
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvShowEvent
(
const
ShowEventData
&
aData
const
bool
&
aFromUser
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvHideEvent
(
const
uint64_t
&
aRootID
const
bool
&
aFromUser
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvStateChangeEvent
(
const
uint64_t
&
aID
const
uint64_t
&
aState
const
bool
&
aEnabled
)
final
;
mozilla
:
:
ipc
:
:
IPCResult
RecvCaretMoveEvent
(
const
uint64_t
&
aID
#
if
defined
(
XP_WIN
)
const
LayoutDeviceIntRect
&
aCaretRect
#
endif
const
int32_t
&
aOffset
)
final
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvTextChangeEvent
(
const
uint64_t
&
aID
const
nsString
&
aStr
const
int32_t
&
aStart
const
uint32_t
&
aLen
const
bool
&
aIsInsert
const
bool
&
aFromUser
)
override
;
#
if
defined
(
XP_WIN
)
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvSyncTextChangeEvent
(
const
uint64_t
&
aID
const
nsString
&
aStr
const
int32_t
&
aStart
const
uint32_t
&
aLen
const
bool
&
aIsInsert
const
bool
&
aFromUser
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvFocusEvent
(
const
uint64_t
&
aID
const
LayoutDeviceIntRect
&
aCaretRect
)
override
;
#
endif
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvSelectionEvent
(
const
uint64_t
&
aID
const
uint64_t
&
aWidgetID
const
uint32_t
&
aType
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvVirtualCursorChangeEvent
(
const
uint64_t
&
aID
const
uint64_t
&
aOldPositionID
const
int32_t
&
aOldStartOffset
const
int32_t
&
aOldEndOffset
const
uint64_t
&
aNewPositionID
const
int32_t
&
aNewStartOffset
const
int32_t
&
aNewEndOffset
const
int16_t
&
aReason
const
bool
&
aFromUser
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvRoleChangedEvent
(
const
a11y
:
:
role
&
aRole
)
final
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvBindChildDoc
(
PDocAccessibleParent
*
aChildDoc
const
uint64_t
&
aID
)
override
;
void
Unbind
(
)
{
if
(
DocAccessibleParent
*
parent
=
ParentDoc
(
)
)
{
parent
-
>
RemoveChildDoc
(
this
)
;
}
SetParent
(
nullptr
)
;
}
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvShutdown
(
)
override
;
void
Destroy
(
)
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
{
MOZ_ASSERT
(
CheckDocTree
(
)
)
;
if
(
!
mShutdown
)
Destroy
(
)
;
}
DocAccessibleParent
*
ParentDoc
(
)
const
;
static
const
uint64_t
kNoParentDoc
=
UINT64_MAX
;
ipc
:
:
IPCResult
AddChildDoc
(
DocAccessibleParent
*
aChildDoc
uint64_t
aParentID
bool
aCreating
=
true
)
;
void
RemoveChildDoc
(
DocAccessibleParent
*
aChildDoc
)
{
ProxyAccessible
*
parent
=
aChildDoc
-
>
Parent
(
)
;
MOZ_ASSERT
(
parent
)
;
if
(
parent
)
{
aChildDoc
-
>
Parent
(
)
-
>
ClearChildDoc
(
aChildDoc
)
;
}
DebugOnly
<
bool
>
result
=
mChildDocs
.
RemoveElement
(
aChildDoc
-
>
mActorID
)
;
aChildDoc
-
>
mParentDoc
=
kNoParentDoc
;
MOZ_ASSERT
(
result
)
;
}
void
RemoveAccessible
(
ProxyAccessible
*
aAccessible
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mAccessibles
.
GetEntry
(
aAccessible
-
>
ID
(
)
)
)
;
mAccessibles
.
RemoveEntry
(
aAccessible
-
>
ID
(
)
)
;
}
ProxyAccessible
*
GetAccessible
(
uintptr_t
aID
)
{
if
(
!
aID
)
return
this
;
ProxyEntry
*
e
=
mAccessibles
.
GetEntry
(
aID
)
;
return
e
?
e
-
>
mProxy
:
nullptr
;
}
const
ProxyAccessible
*
GetAccessible
(
uintptr_t
aID
)
const
{
return
const_cast
<
DocAccessibleParent
*
>
(
this
)
-
>
GetAccessible
(
aID
)
;
}
size_t
ChildDocCount
(
)
const
{
return
mChildDocs
.
Length
(
)
;
}
const
DocAccessibleParent
*
ChildDocAt
(
size_t
aIdx
)
const
{
return
const_cast
<
DocAccessibleParent
*
>
(
this
)
-
>
ChildDocAt
(
aIdx
)
;
}
DocAccessibleParent
*
ChildDocAt
(
size_t
aIdx
)
{
return
LiveDocs
(
)
.
Get
(
mChildDocs
[
aIdx
]
)
;
}
#
if
defined
(
XP_WIN
)
void
MaybeInitWindowEmulation
(
)
;
void
SendParentCOMProxy
(
)
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvGetWindowedPluginIAccessible
(
const
WindowsHandle
&
aHwnd
IAccessibleHolder
*
aPluginCOMProxy
)
override
;
void
SetEmulatedWindowHandle
(
HWND
aWindowHandle
)
;
HWND
GetEmulatedWindowHandle
(
)
const
{
return
mEmulatedWindowHandle
;
}
#
endif
private
:
class
ProxyEntry
:
public
PLDHashEntryHdr
{
public
:
explicit
ProxyEntry
(
const
void
*
)
:
mProxy
(
nullptr
)
{
}
ProxyEntry
(
ProxyEntry
&
&
aOther
)
:
mProxy
(
aOther
.
mProxy
)
{
aOther
.
mProxy
=
nullptr
;
}
~
ProxyEntry
(
)
{
delete
mProxy
;
}
typedef
uint64_t
KeyType
;
typedef
const
void
*
KeyTypePointer
;
bool
KeyEquals
(
const
void
*
aKey
)
const
{
return
mProxy
-
>
ID
(
)
=
=
(
uint64_t
)
aKey
;
}
static
const
void
*
KeyToPointer
(
uint64_t
aKey
)
{
return
(
void
*
)
aKey
;
}
static
PLDHashNumber
HashKey
(
const
void
*
aKey
)
{
return
(
uint64_t
)
aKey
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
ProxyAccessible
*
mProxy
;
}
;
uint32_t
AddSubtree
(
ProxyAccessible
*
aParent
const
nsTArray
<
AccessibleData
>
&
aNewTree
uint32_t
aIdx
uint32_t
aIdxInParent
)
;
MOZ_MUST_USE
bool
CheckDocTree
(
)
const
;
xpcAccessibleGeneric
*
GetXPCAccessible
(
ProxyAccessible
*
aProxy
)
;
nsTArray
<
uint64_t
>
mChildDocs
;
uint64_t
mParentDoc
;
#
if
defined
(
XP_WIN
)
HWND
mEmulatedWindowHandle
;
#
if
defined
(
MOZ_CONTENT_SANDBOX
)
mscom
:
:
PreservedStreamPtr
mParentProxyStream
;
#
endif
#
endif
nsTHashtable
<
ProxyEntry
>
mAccessibles
;
uint64_t
mActorID
;
bool
mTopLevel
;
bool
mShutdown
;
static
uint64_t
sMaxDocID
;
static
nsDataHashtable
<
nsUint64HashKey
DocAccessibleParent
*
>
&
LiveDocs
(
)
{
static
nsDataHashtable
<
nsUint64HashKey
DocAccessibleParent
*
>
sLiveDocs
;
return
sLiveDocs
;
}
}
;
}
}
#
endif
