#
define
INITGUID
#
include
"
mozilla
/
a11y
/
HandlerProvider
.
h
"
#
include
"
Accessible2_3
.
h
"
#
include
"
HandlerData
.
h
"
#
include
"
HandlerData_i
.
c
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
a11y
/
AccessibleWrap
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
mscom
/
AgileReference
.
h
"
#
include
"
mozilla
/
mscom
/
FastMarshaler
.
h
"
#
include
"
mozilla
/
mscom
/
MainThreadInvoker
.
h
"
#
include
"
mozilla
/
mscom
/
Ptr
.
h
"
#
include
"
mozilla
/
mscom
/
StructStream
.
h
"
#
include
"
mozilla
/
mscom
/
Utils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
<
memory
.
h
>
namespace
mozilla
{
namespace
a11y
{
HandlerProvider
:
:
HandlerProvider
(
REFIID
aIid
mscom
:
:
InterceptorTargetPtr
<
IUnknown
>
aTarget
)
:
mRefCnt
(
0
)
mMutex
(
"
mozilla
:
:
a11y
:
:
HandlerProvider
:
:
mMutex
"
)
mTargetUnkIid
(
aIid
)
mTargetUnk
(
Move
(
aTarget
)
)
{
}
HRESULT
HandlerProvider
:
:
QueryInterface
(
REFIID
riid
void
*
*
ppv
)
{
if
(
!
ppv
)
{
return
E_INVALIDARG
;
}
if
(
riid
=
=
IID_IUnknown
|
|
riid
=
=
IID_IGeckoBackChannel
)
{
RefPtr
<
IUnknown
>
punk
(
static_cast
<
IGeckoBackChannel
*
>
(
this
)
)
;
punk
.
forget
(
ppv
)
;
return
S_OK
;
}
if
(
riid
=
=
IID_IMarshal
)
{
if
(
!
mFastMarshalUnk
)
{
HRESULT
hr
=
mscom
:
:
FastMarshaler
:
:
Create
(
static_cast
<
IGeckoBackChannel
*
>
(
this
)
getter_AddRefs
(
mFastMarshalUnk
)
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
}
return
mFastMarshalUnk
-
>
QueryInterface
(
riid
ppv
)
;
}
return
E_NOINTERFACE
;
}
ULONG
HandlerProvider
:
:
AddRef
(
)
{
return
+
+
mRefCnt
;
}
ULONG
HandlerProvider
:
:
Release
(
)
{
ULONG
result
=
-
-
mRefCnt
;
if
(
!
result
)
{
delete
this
;
}
return
result
;
}
HRESULT
HandlerProvider
:
:
GetHandler
(
NotNull
<
CLSID
*
>
aHandlerClsid
)
{
if
(
!
IsTargetInterfaceCacheable
(
)
)
{
return
E_NOINTERFACE
;
}
*
aHandlerClsid
=
CLSID_AccessibleHandler
;
return
S_OK
;
}
void
HandlerProvider
:
:
GetAndSerializePayload
(
const
MutexAutoLock
&
)
{
MOZ_ASSERT
(
mscom
:
:
IsCurrentThreadMTA
(
)
)
;
if
(
mSerializer
)
{
return
;
}
IA2Payload
payload
{
}
;
if
(
!
mscom
:
:
InvokeOnMainThread
(
"
HandlerProvider
:
:
BuildIA2Data
"
this
&
HandlerProvider
:
:
BuildIA2Data
&
payload
.
mData
)
|
|
!
payload
.
mData
.
mUniqueId
)
{
return
;
}
RefPtr
<
IGeckoBackChannel
>
payloadRef
(
this
)
;
payload
.
mGeckoBackChannel
=
this
;
mSerializer
=
MakeUnique
<
mscom
:
:
StructToStream
>
(
payload
&
IA2Payload_Encode
)
;
ClearIA2Data
(
payload
.
mData
)
;
}
HRESULT
HandlerProvider
:
:
GetHandlerPayloadSize
(
NotNull
<
DWORD
*
>
aOutPayloadSize
)
{
MOZ_ASSERT
(
mscom
:
:
IsCurrentThreadMTA
(
)
)
;
if
(
!
IsTargetInterfaceCacheable
(
)
)
{
*
aOutPayloadSize
=
mscom
:
:
StructToStream
:
:
GetEmptySize
(
)
;
return
S_OK
;
}
MutexAutoLock
lock
(
mMutex
)
;
GetAndSerializePayload
(
lock
)
;
if
(
!
mSerializer
|
|
!
(
*
mSerializer
)
)
{
*
aOutPayloadSize
=
mscom
:
:
StructToStream
:
:
GetEmptySize
(
)
;
return
S_OK
;
}
*
aOutPayloadSize
=
mSerializer
-
>
GetSize
(
)
;
return
S_OK
;
}
void
HandlerProvider
:
:
BuildIA2Data
(
IA2Data
*
aOutIA2Data
)
{
MOZ_ASSERT
(
aOutIA2Data
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mTargetUnk
)
;
MOZ_ASSERT
(
IsTargetInterfaceCacheable
(
)
)
;
RefPtr
<
NEWEST_IA2_INTERFACE
>
target
(
static_cast
<
NEWEST_IA2_INTERFACE
*
>
(
mTargetUnk
.
get
(
)
)
)
;
HRESULT
hr
=
target
-
>
get_uniqueID
(
&
aOutIA2Data
-
>
mUniqueId
)
;
if
(
FAILED
(
hr
)
)
{
ClearIA2Data
(
*
aOutIA2Data
)
;
}
}
void
HandlerProvider
:
:
ClearIA2Data
(
IA2Data
&
aData
)
{
ZeroMemory
(
&
aData
sizeof
(
IA2Data
)
)
;
}
bool
HandlerProvider
:
:
IsTargetInterfaceCacheable
(
)
{
return
MarshalAs
(
mTargetUnkIid
)
=
=
NEWEST_IA2_IID
;
}
HRESULT
HandlerProvider
:
:
WriteHandlerPayload
(
NotNull
<
IStream
*
>
aStream
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mSerializer
|
|
!
(
*
mSerializer
)
)
{
mscom
:
:
StructToStream
emptyStruct
;
return
emptyStruct
.
Write
(
aStream
)
;
}
HRESULT
hr
=
mSerializer
-
>
Write
(
aStream
)
;
mSerializer
.
reset
(
)
;
return
hr
;
}
REFIID
HandlerProvider
:
:
MarshalAs
(
REFIID
aIid
)
{
static_assert
(
&
NEWEST_IA2_IID
=
=
&
IID_IAccessible2_3
"
You
have
modified
NEWEST_IA2_IID
.
This
code
needs
updating
.
"
)
;
if
(
aIid
=
=
IID_IDispatch
|
|
aIid
=
=
IID_IAccessible
|
|
aIid
=
=
IID_IAccessible2
|
|
aIid
=
=
IID_IAccessible2_2
|
|
aIid
=
=
IID_IAccessible2_3
)
{
return
NEWEST_IA2_IID
;
}
return
aIid
;
}
HRESULT
HandlerProvider
:
:
NewInstance
(
REFIID
aIid
mscom
:
:
InterceptorTargetPtr
<
IUnknown
>
aTarget
NotNull
<
mscom
:
:
IHandlerProvider
*
*
>
aOutNewPayload
)
{
RefPtr
<
IHandlerProvider
>
newPayload
(
new
HandlerProvider
(
aIid
Move
(
aTarget
)
)
)
;
newPayload
.
forget
(
aOutNewPayload
.
get
(
)
)
;
return
S_OK
;
}
void
HandlerProvider
:
:
SetHandlerControlOnMainThread
(
DWORD
aPid
mscom
:
:
ProxyUniquePtr
<
IHandlerControl
>
aCtrl
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
content
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
content
)
;
IHandlerControlHolder
holder
(
CreateHolderFromHandlerControl
(
Move
(
aCtrl
)
)
)
;
Unused
<
<
content
-
>
SendA11yHandlerControl
(
aPid
holder
)
;
}
HRESULT
HandlerProvider
:
:
put_HandlerControl
(
long
aPid
IHandlerControl
*
aCtrl
)
{
MOZ_ASSERT
(
mscom
:
:
IsCurrentThreadMTA
(
)
)
;
if
(
!
aCtrl
)
{
return
E_INVALIDARG
;
}
auto
ptrProxy
=
mscom
:
:
ToProxyUniquePtr
(
aCtrl
)
;
if
(
!
mscom
:
:
InvokeOnMainThread
(
"
HandlerProvider
:
:
SetHandlerControlOnMainThread
"
this
&
HandlerProvider
:
:
SetHandlerControlOnMainThread
static_cast
<
DWORD
>
(
aPid
)
Move
(
ptrProxy
)
)
)
{
return
E_FAIL
;
}
return
S_OK
;
}
HRESULT
HandlerProvider
:
:
Refresh
(
IA2Data
*
aOutData
)
{
MOZ_ASSERT
(
mscom
:
:
IsCurrentThreadMTA
(
)
)
;
if
(
!
mscom
:
:
InvokeOnMainThread
(
"
HandlerProvider
:
:
BuildIA2Data
"
this
&
HandlerProvider
:
:
BuildIA2Data
aOutData
)
)
{
return
E_FAIL
;
}
return
S_OK
;
}
}
}
