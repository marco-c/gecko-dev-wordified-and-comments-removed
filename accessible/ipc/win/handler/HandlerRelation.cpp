#
if
defined
(
MOZILLA_INTERNAL_API
)
#
error
This
code
is
NOT
for
internal
Gecko
use
!
#
endif
#
include
"
HandlerRelation
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
AccessibleRelation_i
.
c
"
namespace
mozilla
{
namespace
a11y
{
HandlerRelation
:
:
HandlerRelation
(
AccessibleHandler
*
aHandler
IARelationData
&
aData
)
:
mHandler
(
aHandler
)
mData
(
aData
)
mTargets
(
nullptr
)
{
aData
.
mType
=
nullptr
;
}
HandlerRelation
:
:
~
HandlerRelation
(
)
{
if
(
mData
.
mType
)
{
:
:
SysFreeString
(
mData
.
mType
)
;
}
if
(
mTargets
)
{
for
(
long
index
=
0
;
index
<
mData
.
mNTargets
;
+
+
index
)
{
mTargets
[
index
]
-
>
Release
(
)
;
}
:
:
CoTaskMemFree
(
mTargets
)
;
mTargets
=
nullptr
;
}
}
HRESULT
HandlerRelation
:
:
GetTargets
(
)
{
if
(
mTargets
)
{
return
S_OK
;
}
return
mHandler
-
>
get_relationTargetsOfType
(
mData
.
mType
0
&
mTargets
&
mData
.
mNTargets
)
;
}
IMPL_IUNKNOWN1
(
HandlerRelation
IAccessibleRelation
)
HRESULT
HandlerRelation
:
:
get_relationType
(
BSTR
*
aType
)
{
if
(
!
aType
)
{
return
E_INVALIDARG
;
}
if
(
!
mData
.
mType
)
{
return
E_FAIL
;
}
*
aType
=
CopyBSTR
(
mData
.
mType
)
;
return
S_OK
;
}
HRESULT
HandlerRelation
:
:
get_localizedRelationType
(
BSTR
*
aLocalizedType
)
{
return
E_NOTIMPL
;
}
HRESULT
HandlerRelation
:
:
get_nTargets
(
long
*
aNTargets
)
{
if
(
!
aNTargets
)
{
return
E_INVALIDARG
;
}
if
(
mData
.
mNTargets
=
=
-
1
)
{
return
E_FAIL
;
}
*
aNTargets
=
mData
.
mNTargets
;
return
S_OK
;
}
HRESULT
HandlerRelation
:
:
get_target
(
long
aIndex
IUnknown
*
*
aTarget
)
{
if
(
!
aTarget
)
{
return
E_INVALIDARG
;
}
HRESULT
hr
=
GetTargets
(
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
if
(
aIndex
>
=
mData
.
mNTargets
)
{
return
E_INVALIDARG
;
}
*
aTarget
=
mTargets
[
aIndex
]
;
(
*
aTarget
)
-
>
AddRef
(
)
;
return
S_OK
;
}
HRESULT
HandlerRelation
:
:
get_targets
(
long
aMaxTargets
IUnknown
*
*
aTargets
long
*
aNTargets
)
{
if
(
aMaxTargets
=
=
0
|
|
!
aTargets
|
|
!
aNTargets
)
{
return
E_INVALIDARG
;
}
HRESULT
hr
=
GetTargets
(
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
if
(
mData
.
mNTargets
>
aMaxTargets
)
{
*
aNTargets
=
aMaxTargets
;
}
else
{
*
aNTargets
=
mData
.
mNTargets
;
}
for
(
long
index
=
0
;
index
<
*
aNTargets
;
+
+
index
)
{
aTargets
[
index
]
=
mTargets
[
index
]
;
aTargets
[
index
]
-
>
AddRef
(
)
;
}
return
S_OK
;
}
}
}
