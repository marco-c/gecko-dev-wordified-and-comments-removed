#
ifndef
mozilla_a11y_RemoteAccessible_h
#
define
mozilla_a11y_RemoteAccessible_h
#
include
"
mozilla
/
a11y
/
Accessible
.
h
"
#
include
"
mozilla
/
a11y
/
CacheConstants
.
h
"
#
include
"
mozilla
/
a11y
/
HyperTextAccessibleBase
.
h
"
#
include
"
mozilla
/
a11y
/
Role
.
h
"
#
include
"
AccAttributes
.
h
"
#
include
"
nsIAccessibleText
.
h
"
#
include
"
nsIAccessibleTypes
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
LocalAccessible
.
h
"
namespace
mozilla
{
namespace
a11y
{
class
Attribute
;
class
DocAccessibleParent
;
class
RemoteAccessible
;
enum
class
RelationType
;
class
RemoteAccessible
:
public
Accessible
public
HyperTextAccessibleBase
{
public
:
virtual
~
RemoteAccessible
(
)
{
MOZ_ASSERT
(
!
mWrapper
)
;
MOZ_COUNT_DTOR
(
RemoteAccessible
)
;
}
virtual
bool
IsRemote
(
)
const
override
{
return
true
;
}
void
AddChildAt
(
uint32_t
aIdx
RemoteAccessible
*
aChild
)
{
mChildren
.
InsertElementAt
(
aIdx
aChild
)
;
UpdateChildIndexCache
(
static_cast
<
int32_t
>
(
aIdx
)
)
;
if
(
IsHyperText
(
)
)
{
InvalidateCachedHyperTextOffsets
(
)
;
}
}
virtual
uint32_t
ChildCount
(
)
const
override
{
return
mChildren
.
Length
(
)
;
}
RemoteAccessible
*
RemoteChildAt
(
uint32_t
aIdx
)
const
{
RemoteAccessible
*
child
=
mChildren
.
SafeElementAt
(
aIdx
)
;
MOZ_ASSERT
(
!
child
|
|
child
-
>
mParent
=
=
this
"
Child
'
s
parent
should
be
this
"
)
;
return
child
;
}
RemoteAccessible
*
RemoteFirstChild
(
)
const
{
return
mChildren
.
Length
(
)
?
mChildren
[
0
]
:
nullptr
;
}
RemoteAccessible
*
RemoteLastChild
(
)
const
{
return
mChildren
.
Length
(
)
?
mChildren
[
mChildren
.
Length
(
)
-
1
]
:
nullptr
;
}
RemoteAccessible
*
RemotePrevSibling
(
)
const
{
if
(
IsDoc
(
)
)
{
return
nullptr
;
}
int32_t
idx
=
IndexInParent
(
)
;
if
(
idx
=
=
-
1
)
{
return
nullptr
;
}
MOZ_ASSERT
(
RemoteParent
(
)
)
;
return
idx
>
0
?
RemoteParent
(
)
-
>
mChildren
[
idx
-
1
]
:
nullptr
;
}
RemoteAccessible
*
RemoteNextSibling
(
)
const
{
if
(
IsDoc
(
)
)
{
return
nullptr
;
}
int32_t
idx
=
IndexInParent
(
)
;
if
(
idx
=
=
-
1
)
{
return
nullptr
;
}
MOZ_ASSERT
(
idx
>
=
0
)
;
size_t
newIdx
=
idx
+
1
;
MOZ_ASSERT
(
RemoteParent
(
)
)
;
return
newIdx
<
RemoteParent
(
)
-
>
mChildren
.
Length
(
)
?
RemoteParent
(
)
-
>
mChildren
[
newIdx
]
:
nullptr
;
}
virtual
Accessible
*
Parent
(
)
const
override
{
return
RemoteParent
(
)
;
}
virtual
Accessible
*
ChildAt
(
uint32_t
aIndex
)
const
override
{
return
RemoteChildAt
(
aIndex
)
;
}
virtual
Accessible
*
NextSibling
(
)
const
override
{
return
RemoteNextSibling
(
)
;
}
virtual
Accessible
*
PrevSibling
(
)
const
override
{
return
RemotePrevSibling
(
)
;
}
virtual
int32_t
IndexInParent
(
)
const
override
{
MOZ_ASSERT
(
mParent
|
|
mIndexInParent
=
=
-
1
"
IndexInParent
should
be
-
1
if
no
parent
"
)
;
return
mIndexInParent
;
}
virtual
uint32_t
EmbeddedChildCount
(
)
override
;
virtual
int32_t
IndexOfEmbeddedChild
(
Accessible
*
aChild
)
override
;
virtual
Accessible
*
EmbeddedChildAt
(
uint32_t
aChildIdx
)
override
;
void
Shutdown
(
)
;
void
SetChildDoc
(
DocAccessibleParent
*
aChildDoc
)
;
void
ClearChildDoc
(
DocAccessibleParent
*
aChildDoc
)
;
void
RemoveChild
(
RemoteAccessible
*
aChild
)
{
mChildren
.
RemoveElement
(
aChild
)
;
MOZ_ASSERT
(
aChild
-
>
mIndexInParent
!
=
-
1
)
;
UpdateChildIndexCache
(
aChild
-
>
mIndexInParent
)
;
aChild
-
>
mIndexInParent
=
-
1
;
if
(
IsHyperText
(
)
)
{
InvalidateCachedHyperTextOffsets
(
)
;
}
}
RemoteAccessible
*
RemoteParent
(
)
const
;
LocalAccessible
*
OuterDocOfRemoteBrowser
(
)
const
;
virtual
role
Role
(
)
const
override
{
return
mRole
;
}
bool
IsEmbeddedObject
(
)
const
{
return
!
IsText
(
)
;
}
virtual
bool
IsLink
(
)
const
override
{
if
(
IsHTMLLink
(
)
)
{
return
true
;
}
if
(
IsText
(
)
)
{
return
false
;
}
if
(
Accessible
*
parent
=
Parent
(
)
)
{
return
parent
-
>
IsHyperText
(
)
;
}
return
false
;
}
virtual
bool
HasNumericValue
(
)
const
override
{
return
HasGenericType
(
eNumericValue
)
;
}
virtual
ENameValueFlag
Name
(
nsString
&
aName
)
const
override
;
virtual
void
Description
(
nsString
&
aDescription
)
const
override
;
virtual
void
Value
(
nsString
&
aValue
)
const
override
;
virtual
double
CurValue
(
)
const
override
;
virtual
double
MinValue
(
)
const
override
;
virtual
double
MaxValue
(
)
const
override
;
virtual
double
Step
(
)
const
override
;
virtual
bool
SetCurValue
(
double
aValue
)
override
;
virtual
Accessible
*
ChildAtPoint
(
int32_t
aX
int32_t
aY
LocalAccessible
:
:
EWhichChildAtPoint
aWhichChild
)
override
;
virtual
LayoutDeviceIntRect
Bounds
(
)
const
override
;
virtual
nsRect
BoundsInAppUnits
(
)
const
override
;
virtual
Relation
RelationByType
(
RelationType
aType
)
const
override
;
virtual
uint64_t
State
(
)
override
;
virtual
already_AddRefed
<
AccAttributes
>
Attributes
(
)
override
;
virtual
nsAtom
*
TagName
(
)
const
override
;
virtual
already_AddRefed
<
nsAtom
>
DisplayStyle
(
)
const
override
;
virtual
float
Opacity
(
)
const
override
;
virtual
void
LiveRegionAttributes
(
nsAString
*
aLive
nsAString
*
aRelevant
Maybe
<
bool
>
*
aAtomic
nsAString
*
aBusy
)
const
override
;
virtual
Maybe
<
bool
>
ARIASelected
(
)
const
override
;
virtual
uint8_t
ActionCount
(
)
const
override
;
virtual
void
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
override
;
virtual
bool
DoAction
(
uint8_t
aIndex
)
const
override
;
virtual
KeyBinding
AccessKey
(
)
const
override
;
virtual
void
SelectionRanges
(
nsTArray
<
TextRange
>
*
aRanges
)
const
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
bool
RemoveFromSelection
(
int32_t
aSelectionNum
)
override
;
virtual
Maybe
<
int32_t
>
GetIntARIAAttr
(
nsAtom
*
aAttrName
)
const
override
;
virtual
bool
GetStringARIAAttr
(
nsAtom
*
aAttrName
nsAString
&
aAttrValue
)
const
override
;
virtual
void
Language
(
nsAString
&
aLocale
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
void
ReplaceText
(
const
nsAString
&
aText
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
void
InsertText
(
const
nsAString
&
aText
int32_t
aPosition
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
void
CopyText
(
int32_t
aStartPos
int32_t
aEndPos
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
void
CutText
(
int32_t
aStartPos
int32_t
aEndPos
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
void
DeleteText
(
int32_t
aStartPos
int32_t
aEndPos
)
override
;
MOZ_CAN_RUN_SCRIPT
virtual
void
PasteText
(
int32_t
aPosition
)
override
;
virtual
void
SelectedItems
(
nsTArray
<
Accessible
*
>
*
aItems
)
override
;
virtual
uint32_t
SelectedItemCount
(
)
override
;
virtual
Accessible
*
GetSelectedItem
(
uint32_t
aIndex
)
override
;
virtual
bool
IsItemSelected
(
uint32_t
aIndex
)
override
;
virtual
bool
AddItemToSelection
(
uint32_t
aIndex
)
override
;
virtual
bool
RemoveItemFromSelection
(
uint32_t
aIndex
)
override
;
virtual
bool
SelectAll
(
)
override
;
virtual
bool
UnselectAll
(
)
override
;
virtual
void
TakeSelection
(
)
override
;
virtual
void
SetSelected
(
bool
aSelect
)
override
;
virtual
void
TakeFocus
(
)
const
override
;
virtual
void
ScrollTo
(
uint32_t
aHow
)
const
override
;
uintptr_t
GetWrapper
(
)
const
{
return
mWrapper
;
}
void
SetWrapper
(
uintptr_t
aWrapper
)
{
mWrapper
=
aWrapper
;
}
virtual
uint64_t
ID
(
)
const
override
{
return
mID
;
}
DocAccessibleParent
*
Document
(
)
const
{
return
mDoc
;
}
DocAccessibleParent
*
AsDoc
(
)
const
{
return
IsDoc
(
)
?
mDoc
:
nullptr
;
}
void
ApplyCache
(
CacheUpdateType
aUpdateType
AccAttributes
*
aFields
)
;
void
UpdateStateCache
(
uint64_t
aState
bool
aEnabled
)
{
if
(
aState
&
kRemoteCalculatedStates
)
{
return
;
}
uint64_t
state
=
0
;
if
(
mCachedFields
)
{
if
(
auto
oldState
=
mCachedFields
-
>
GetAttribute
<
uint64_t
>
(
CacheKey
:
:
State
)
)
{
state
=
*
oldState
;
}
}
else
{
mCachedFields
=
new
AccAttributes
(
)
;
}
if
(
aEnabled
)
{
state
|
=
aState
;
}
else
{
state
&
=
~
aState
;
}
mCachedFields
-
>
SetAttribute
(
CacheKey
:
:
State
state
)
;
}
void
InvalidateGroupInfo
(
)
;
virtual
void
AppendTextTo
(
nsAString
&
aText
uint32_t
aStartOffset
=
0
uint32_t
aLength
=
UINT32_MAX
)
override
;
virtual
bool
TableIsProbablyForLayout
(
)
;
nsTArray
<
bool
>
PreProcessRelations
(
AccAttributes
*
aFields
)
;
void
PostProcessRelations
(
const
nsTArray
<
bool
>
&
aToUpdate
)
;
void
PruneRelationsOnShutdown
(
)
;
uint32_t
GetCachedTextLength
(
)
;
Maybe
<
const
nsTArray
<
int32_t
>
&
>
GetCachedTextLines
(
)
;
nsRect
GetCachedCharRect
(
int32_t
aOffset
)
;
RefPtr
<
const
AccAttributes
>
GetCachedTextAttributes
(
)
;
const
AccAttributes
*
GetCachedARIAAttributes
(
)
const
;
nsString
GetCachedHTMLNameAttribute
(
)
const
;
virtual
HyperTextAccessibleBase
*
AsHyperTextBase
(
)
override
{
return
IsHyperText
(
)
?
static_cast
<
HyperTextAccessibleBase
*
>
(
this
)
:
nullptr
;
}
virtual
TableAccessible
*
AsTable
(
)
override
;
virtual
TableCellAccessible
*
AsTableCell
(
)
override
;
virtual
void
DOMNodeID
(
nsString
&
aID
)
const
override
;
virtual
void
DOMNodeClass
(
nsString
&
aClass
)
const
override
;
virtual
void
ScrollToPoint
(
uint32_t
aScrollType
int32_t
aX
int32_t
aY
)
override
;
#
if
!
defined
(
XP_WIN
)
void
Announce
(
const
nsString
&
aAnnouncement
uint16_t
aPriority
)
;
#
endif
int32_t
ValueRegion
(
)
const
;
virtual
already_AddRefed
<
AccAttributes
>
DefaultTextAttributes
(
)
override
;
virtual
void
ScrollSubstringToPoint
(
int32_t
aStartOffset
int32_t
aEndOffset
uint32_t
aCoordinateType
int32_t
aX
int32_t
aY
)
override
;
virtual
std
:
:
pair
<
mozilla
:
:
LayoutDeviceIntRect
nsIWidget
*
>
GetCaretRect
(
)
override
;
void
InvalidateCachedHyperTextOffsets
(
)
{
if
(
mCachedFields
)
{
mCachedFields
-
>
Remove
(
CacheKey
:
:
HyperTextOffsets
)
;
}
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
;
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
;
protected
:
RemoteAccessible
(
uint64_t
aID
DocAccessibleParent
*
aDoc
role
aRole
AccType
aType
AccGenericType
aGenericTypes
uint8_t
aRoleMapEntryIndex
)
:
Accessible
(
aType
aGenericTypes
aRoleMapEntryIndex
)
mParent
(
nullptr
)
mDoc
(
aDoc
)
mWrapper
(
0
)
mID
(
aID
)
mCachedFields
(
nullptr
)
mRole
(
aRole
)
{
MOZ_COUNT_CTOR
(
RemoteAccessible
)
;
}
explicit
RemoteAccessible
(
DocAccessibleParent
*
aThisAsDoc
)
:
mParent
(
nullptr
)
mDoc
(
aThisAsDoc
)
mWrapper
(
0
)
mID
(
0
)
mCachedFields
(
nullptr
)
mRole
(
roles
:
:
DOCUMENT
)
{
mGenericTypes
=
eDocument
|
eHyperText
;
MOZ_COUNT_CTOR
(
RemoteAccessible
)
;
}
protected
:
void
SetParent
(
RemoteAccessible
*
aParent
)
;
Maybe
<
nsRect
>
RetrieveCachedBounds
(
)
const
;
bool
ApplyTransform
(
nsRect
&
aCumulativeBounds
)
const
;
bool
ApplyScrollOffset
(
nsRect
&
aBounds
)
const
;
void
ApplyCrossDocOffset
(
nsRect
&
aBounds
)
const
;
void
ApplyVisualViewportOffset
(
nsRect
&
aBounds
)
const
;
LayoutDeviceIntRect
BoundsWithOffset
(
Maybe
<
nsRect
>
aOffset
bool
aBoundsAreForHittesting
=
false
)
const
;
bool
IsFixedPos
(
)
const
;
bool
IsOverflowHidden
(
)
const
;
bool
IsClipped
(
)
const
;
RemoteAccessible
*
DoFuzzyHittesting
(
)
;
bool
ContainsPoint
(
int32_t
aX
int32_t
aY
)
;
virtual
void
ARIAGroupPosition
(
int32_t
*
aLevel
int32_t
*
aSetSize
int32_t
*
aPosInSet
)
const
override
;
virtual
AccGroupInfo
*
GetGroupInfo
(
)
const
override
;
virtual
AccGroupInfo
*
GetOrCreateGroupInfo
(
)
override
;
virtual
void
GetPositionAndSetSize
(
int32_t
*
aPosInSet
int32_t
*
aSetSize
)
override
;
virtual
bool
HasPrimaryAction
(
)
const
override
;
nsAtom
*
GetPrimaryAction
(
)
const
;
virtual
nsTArray
<
int32_t
>
&
GetCachedHyperTextOffsets
(
)
override
;
private
:
void
UpdateChildIndexCache
(
int32_t
aStartIdx
)
{
int32_t
count
=
static_cast
<
int32_t
>
(
mChildren
.
Length
(
)
)
;
for
(
int32_t
idx
=
aStartIdx
;
idx
<
count
;
+
+
idx
)
{
mChildren
[
idx
]
-
>
mIndexInParent
=
idx
;
}
}
RemoteAccessible
*
mParent
;
friend
DocAccessibleParent
;
friend
TextLeafPoint
;
friend
HyperTextAccessibleBase
;
friend
class
xpcAccessible
;
friend
class
CachedTableCellAccessible
;
#
ifdef
XP_WIN
friend
class
sdnAccessible
;
#
endif
nsTArray
<
RemoteAccessible
*
>
mChildren
;
DocAccessibleParent
*
mDoc
;
uintptr_t
mWrapper
;
uint64_t
mID
;
int32_t
mIndexInParent
=
-
1
;
protected
:
virtual
const
Accessible
*
Acc
(
)
const
override
{
return
this
;
}
RefPtr
<
AccAttributes
>
mCachedFields
;
role
mRole
:
27
;
}
;
inline
RemoteAccessible
*
Accessible
:
:
AsRemote
(
)
{
return
IsRemote
(
)
?
static_cast
<
RemoteAccessible
*
>
(
this
)
:
nullptr
;
}
}
}
#
endif
