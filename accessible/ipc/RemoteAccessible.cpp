#
include
"
ARIAMap
.
h
"
#
include
"
CachedTableAccessible
.
h
"
#
include
"
RemoteAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
CacheConstants
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessibleParent
.
h
"
#
include
"
mozilla
/
a11y
/
DocManager
.
h
"
#
include
"
mozilla
/
a11y
/
Platform
.
h
"
#
include
"
mozilla
/
a11y
/
TableAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
TableCellAccessible
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsAccUtils
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsTextEquivUtils
.
h
"
#
include
"
Pivot
.
h
"
#
include
"
Relation
.
h
"
#
include
"
mozilla
/
a11y
/
RelationType
.
h
"
#
include
"
xpcAccessibleDocument
.
h
"
#
ifdef
A11Y_LOG
#
include
"
Logging
.
h
"
#
define
VERIFY_CACHE
(
domain
)
\
if
(
logging
:
:
IsEnabled
(
logging
:
:
eCache
)
)
{
\
Unused
<
<
mDoc
-
>
SendVerifyCache
(
mID
domain
mCachedFields
)
;
\
}
#
else
#
define
VERIFY_CACHE
(
domain
)
\
do
{
\
}
while
(
0
)
#
endif
namespace
mozilla
{
namespace
a11y
{
static
constexpr
uint64_t
kNecessaryBoundsDomains
=
CacheDomain
:
:
Bounds
|
CacheDomain
:
:
TransformMatrix
|
CacheDomain
:
:
Style
|
CacheDomain
:
:
ScrollPosition
;
static
constexpr
uint64_t
kNecessaryStateDomains
=
CacheDomain
:
:
State
|
CacheDomain
:
:
Viewport
;
void
RemoteAccessible
:
:
Shutdown
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsDoc
(
)
)
;
xpcAccessibleDocument
*
xpcDoc
=
GetAccService
(
)
-
>
GetCachedXPCDocument
(
Document
(
)
)
;
if
(
xpcDoc
)
{
xpcDoc
-
>
NotifyOfShutdown
(
static_cast
<
RemoteAccessible
*
>
(
this
)
)
;
}
if
(
IsTable
(
)
|
|
IsTableCell
(
)
)
{
CachedTableAccessible
:
:
Invalidate
(
this
)
;
}
PruneRelationsOnShutdown
(
)
;
uint32_t
childCount
=
mChildren
.
Length
(
)
;
if
(
!
IsOuterDoc
(
)
)
{
for
(
uint32_t
idx
=
0
;
idx
<
childCount
;
idx
+
+
)
mChildren
[
idx
]
-
>
Shutdown
(
)
;
}
else
{
if
(
childCount
>
1
)
{
MOZ_CRASH
(
"
outer
doc
has
too
many
documents
!
"
)
;
}
else
if
(
childCount
=
=
1
)
{
mChildren
[
0
]
-
>
AsDoc
(
)
-
>
Unbind
(
)
;
}
}
mChildren
.
Clear
(
)
;
ProxyDestroyed
(
static_cast
<
RemoteAccessible
*
>
(
this
)
)
;
mDoc
-
>
RemoveAccessible
(
static_cast
<
RemoteAccessible
*
>
(
this
)
)
;
}
void
RemoteAccessible
:
:
SetChildDoc
(
DocAccessibleParent
*
aChildDoc
)
{
MOZ_ASSERT
(
aChildDoc
)
;
MOZ_ASSERT
(
mChildren
.
Length
(
)
=
=
0
)
;
mChildren
.
AppendElement
(
aChildDoc
)
;
aChildDoc
-
>
mIndexInParent
=
0
;
}
void
RemoteAccessible
:
:
ClearChildDoc
(
DocAccessibleParent
*
aChildDoc
)
{
MOZ_ASSERT
(
aChildDoc
)
;
MOZ_ASSERT
(
mChildren
.
Length
(
)
<
=
1
)
;
mChildren
.
RemoveElement
(
aChildDoc
)
;
}
uint32_t
RemoteAccessible
:
:
EmbeddedChildCount
(
)
{
size_t
count
=
0
kids
=
mChildren
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
kids
;
i
+
+
)
{
if
(
mChildren
[
i
]
-
>
IsEmbeddedObject
(
)
)
{
count
+
+
;
}
}
return
count
;
}
int32_t
RemoteAccessible
:
:
IndexOfEmbeddedChild
(
Accessible
*
aChild
)
{
size_t
index
=
0
kids
=
mChildren
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
kids
;
i
+
+
)
{
if
(
mChildren
[
i
]
-
>
IsEmbeddedObject
(
)
)
{
if
(
mChildren
[
i
]
=
=
aChild
)
{
return
index
;
}
index
+
+
;
}
}
return
-
1
;
}
Accessible
*
RemoteAccessible
:
:
EmbeddedChildAt
(
uint32_t
aChildIdx
)
{
size_t
index
=
0
kids
=
mChildren
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
kids
;
i
+
+
)
{
if
(
!
mChildren
[
i
]
-
>
IsEmbeddedObject
(
)
)
{
continue
;
}
if
(
index
=
=
aChildIdx
)
{
return
mChildren
[
i
]
;
}
index
+
+
;
}
return
nullptr
;
}
LocalAccessible
*
RemoteAccessible
:
:
OuterDocOfRemoteBrowser
(
)
const
{
auto
tab
=
static_cast
<
dom
:
:
BrowserParent
*
>
(
mDoc
-
>
Manager
(
)
)
;
dom
:
:
Element
*
frame
=
tab
-
>
GetOwnerElement
(
)
;
NS_ASSERTION
(
frame
"
why
isn
'
t
the
tab
in
a
frame
!
"
)
;
if
(
!
frame
)
return
nullptr
;
DocAccessible
*
chromeDoc
=
GetExistingDocAccessible
(
frame
-
>
OwnerDoc
(
)
)
;
return
chromeDoc
?
chromeDoc
-
>
GetAccessible
(
frame
)
:
nullptr
;
}
void
RemoteAccessible
:
:
SetParent
(
RemoteAccessible
*
aParent
)
{
MOZ_ASSERT
(
!
IsDoc
(
)
|
|
!
AsDoc
(
)
-
>
IsTopLevel
(
)
"
Top
level
doc
should
not
have
remote
parent
"
)
;
MOZ_ASSERT
(
!
IsDoc
(
)
|
|
!
aParent
|
|
!
aParent
-
>
IsDoc
(
)
"
Doc
can
'
t
be
direct
parent
of
another
doc
"
)
;
MOZ_ASSERT
(
!
IsDoc
(
)
|
|
!
aParent
|
|
aParent
-
>
IsOuterDoc
(
)
"
Doc
'
s
parent
must
be
OuterDoc
"
)
;
mParent
=
aParent
;
if
(
!
aParent
)
{
mIndexInParent
=
-
1
;
}
}
RemoteAccessible
*
RemoteAccessible
:
:
RemoteParent
(
)
const
{
MOZ_ASSERT
(
!
IsDoc
(
)
|
|
!
AsDoc
(
)
-
>
IsTopLevel
(
)
|
|
!
mParent
"
Top
level
doc
should
not
have
RemoteParent
"
)
;
MOZ_ASSERT
(
!
IsDoc
(
)
|
|
!
mParent
|
|
mParent
-
>
mDoc
!
=
mDoc
"
Doc
'
s
parent
should
be
in
another
doc
"
)
;
MOZ_ASSERT
(
!
IsDoc
(
)
|
|
!
mParent
|
|
mParent
-
>
IsOuterDoc
(
)
"
Doc
'
s
parent
should
be
in
another
doc
"
)
;
return
mParent
;
}
void
RemoteAccessible
:
:
ApplyCache
(
CacheUpdateType
aUpdateType
AccAttributes
*
aFields
)
{
if
(
!
aFields
)
{
MOZ_ASSERT_UNREACHABLE
(
"
ApplyCache
called
with
aFields
=
=
null
"
)
;
return
;
}
const
nsTArray
<
bool
>
relUpdatesNeeded
=
PreProcessRelations
(
aFields
)
;
if
(
auto
maybeViewportCache
=
aFields
-
>
GetAttribute
<
nsTArray
<
uint64_t
>
>
(
CacheKey
:
:
Viewport
)
)
{
MOZ_ASSERT
(
IsDoc
(
)
"
Fetched
the
viewport
cache
from
a
non
-
doc
accessible
?
"
)
;
AsDoc
(
)
-
>
mOnScreenAccessibles
.
Clear
(
)
;
for
(
auto
id
:
*
maybeViewportCache
)
{
AsDoc
(
)
-
>
mOnScreenAccessibles
.
Insert
(
id
)
;
}
}
if
(
aUpdateType
=
=
CacheUpdateType
:
:
Initial
)
{
mCachedFields
=
aFields
;
}
else
{
if
(
!
mCachedFields
)
{
mCachedFields
=
new
AccAttributes
(
)
;
}
mCachedFields
-
>
Update
(
aFields
)
;
}
if
(
IsTextLeaf
(
)
)
{
RemoteAccessible
*
parent
=
RemoteParent
(
)
;
if
(
parent
&
&
parent
-
>
IsHyperText
(
)
)
{
parent
-
>
InvalidateCachedHyperTextOffsets
(
)
;
}
}
PostProcessRelations
(
relUpdatesNeeded
)
;
}
ENameValueFlag
RemoteAccessible
:
:
Name
(
nsString
&
aName
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
NameAndDescription
|
CacheDomain
:
:
Text
)
)
{
aName
.
SetIsVoid
(
true
)
;
return
eNameOK
;
}
ENameValueFlag
nameFlag
=
eNameOK
;
if
(
mCachedFields
)
{
if
(
IsText
(
)
)
{
mCachedFields
-
>
GetAttribute
(
CacheKey
:
:
Text
aName
)
;
return
eNameOK
;
}
auto
cachedNameFlag
=
mCachedFields
-
>
GetAttribute
<
int32_t
>
(
CacheKey
:
:
NameValueFlag
)
;
if
(
cachedNameFlag
)
{
nameFlag
=
static_cast
<
ENameValueFlag
>
(
*
cachedNameFlag
)
;
}
if
(
mCachedFields
-
>
GetAttribute
(
CacheKey
:
:
Name
aName
)
)
{
VERIFY_CACHE
(
CacheDomain
:
:
NameAndDescription
)
;
return
nameFlag
;
}
}
MOZ_ASSERT
(
aName
.
IsEmpty
(
)
)
;
aName
.
SetIsVoid
(
true
)
;
return
nameFlag
;
}
void
RemoteAccessible
:
:
Description
(
nsString
&
aDescription
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
NameAndDescription
)
)
{
return
;
}
if
(
mCachedFields
)
{
mCachedFields
-
>
GetAttribute
(
CacheKey
:
:
Description
aDescription
)
;
VERIFY_CACHE
(
CacheDomain
:
:
NameAndDescription
)
;
}
}
void
RemoteAccessible
:
:
Value
(
nsString
&
aValue
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Value
|
CacheDomain
:
:
Actions
|
CacheDomain
:
:
State
|
CacheDomain
:
:
Viewport
)
)
{
return
;
}
if
(
mCachedFields
)
{
if
(
mCachedFields
-
>
HasAttribute
(
CacheKey
:
:
TextValue
)
)
{
mCachedFields
-
>
GetAttribute
(
CacheKey
:
:
TextValue
aValue
)
;
VERIFY_CACHE
(
CacheDomain
:
:
Value
)
;
return
;
}
if
(
HasNumericValue
(
)
)
{
double
checkValue
=
CurValue
(
)
;
if
(
!
std
:
:
isnan
(
checkValue
)
)
{
aValue
.
AppendFloat
(
checkValue
)
;
}
return
;
}
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
if
(
roleMapEntry
&
&
roleMapEntry
-
>
Is
(
nsGkAtoms
:
:
textbox
)
)
{
nsTextEquivUtils
:
:
GetTextEquivFromSubtree
(
this
aValue
)
;
return
;
}
if
(
IsCombobox
(
)
)
{
const
Accessible
*
option
=
const_cast
<
RemoteAccessible
*
>
(
this
)
-
>
GetSelectedItem
(
0
)
;
if
(
option
)
{
option
-
>
Name
(
aValue
)
;
}
else
{
nsTextEquivUtils
:
:
GetTextEquivFromSubtree
(
this
aValue
)
;
}
return
;
}
if
(
IsTextLeaf
(
)
|
|
IsImage
(
)
)
{
if
(
const
Accessible
*
actionAcc
=
ActionAncestor
(
)
)
{
if
(
const_cast
<
Accessible
*
>
(
actionAcc
)
-
>
State
(
)
&
states
:
:
LINKED
)
{
return
actionAcc
-
>
Value
(
aValue
)
;
}
}
}
}
}
double
RemoteAccessible
:
:
CurValue
(
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Value
)
)
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
if
(
mCachedFields
)
{
if
(
auto
value
=
mCachedFields
-
>
GetAttribute
<
double
>
(
CacheKey
:
:
NumericValue
)
)
{
VERIFY_CACHE
(
CacheDomain
:
:
Value
)
;
return
*
value
;
}
}
return
UnspecifiedNaN
<
double
>
(
)
;
}
double
RemoteAccessible
:
:
MinValue
(
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Value
)
)
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
if
(
mCachedFields
)
{
if
(
auto
min
=
mCachedFields
-
>
GetAttribute
<
double
>
(
CacheKey
:
:
MinValue
)
)
{
VERIFY_CACHE
(
CacheDomain
:
:
Value
)
;
return
*
min
;
}
}
return
UnspecifiedNaN
<
double
>
(
)
;
}
double
RemoteAccessible
:
:
MaxValue
(
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Value
)
)
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
if
(
mCachedFields
)
{
if
(
auto
max
=
mCachedFields
-
>
GetAttribute
<
double
>
(
CacheKey
:
:
MaxValue
)
)
{
VERIFY_CACHE
(
CacheDomain
:
:
Value
)
;
return
*
max
;
}
}
return
UnspecifiedNaN
<
double
>
(
)
;
}
double
RemoteAccessible
:
:
Step
(
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Value
)
)
{
return
UnspecifiedNaN
<
double
>
(
)
;
}
if
(
mCachedFields
)
{
if
(
auto
step
=
mCachedFields
-
>
GetAttribute
<
double
>
(
CacheKey
:
:
Step
)
)
{
VERIFY_CACHE
(
CacheDomain
:
:
Value
)
;
return
*
step
;
}
}
return
UnspecifiedNaN
<
double
>
(
)
;
}
bool
RemoteAccessible
:
:
SetCurValue
(
double
aValue
)
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Value
|
CacheDomain
:
:
State
|
CacheDomain
:
:
Viewport
)
)
{
return
false
;
}
if
(
!
HasNumericValue
(
)
|
|
IsProgress
(
)
)
{
return
false
;
}
const
uint32_t
kValueCannotChange
=
states
:
:
READONLY
|
states
:
:
UNAVAILABLE
;
if
(
State
(
)
&
kValueCannotChange
)
{
return
false
;
}
double
checkValue
=
MinValue
(
)
;
if
(
!
std
:
:
isnan
(
checkValue
)
&
&
aValue
<
checkValue
)
{
return
false
;
}
checkValue
=
MaxValue
(
)
;
if
(
!
std
:
:
isnan
(
checkValue
)
&
&
aValue
>
checkValue
)
{
return
false
;
}
Unused
<
<
mDoc
-
>
SendSetCurValue
(
mID
aValue
)
;
return
true
;
}
bool
RemoteAccessible
:
:
ContainsPoint
(
int32_t
aX
int32_t
aY
)
{
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
TextBounds
|
kNecessaryBoundsDomains
)
;
if
(
!
BoundsWithOffset
(
Nothing
(
)
true
)
.
Contains
(
aX
aY
)
)
{
return
false
;
}
if
(
!
IsTextLeaf
(
)
)
{
if
(
IsImage
(
)
|
|
IsImageMap
(
)
|
|
!
HasChildren
(
)
|
|
RefPtr
{
DisplayStyle
(
)
}
!
=
nsGkAtoms
:
:
inlinevalue
)
{
return
true
;
}
uint32_t
count
=
ChildCount
(
)
;
for
(
uint32_t
c
=
0
;
c
<
count
;
+
+
c
)
{
RemoteAccessible
*
child
=
RemoteChildAt
(
c
)
;
if
(
child
-
>
Role
(
)
=
=
roles
:
:
TEXT_CONTAINER
&
&
child
-
>
IsClipped
(
)
)
{
return
true
;
}
if
(
child
-
>
ContainsPoint
(
aX
aY
)
)
{
return
true
;
}
}
return
false
;
}
auto
lines
=
GetCachedTextLines
(
)
;
if
(
!
lines
)
{
return
true
;
}
uint32_t
length
=
lines
-
>
Length
(
)
;
MOZ_ASSERT
(
length
>
0
"
Line
starts
shouldn
'
t
be
in
cache
if
there
aren
'
t
any
"
)
;
if
(
length
=
=
0
|
|
(
length
=
=
1
&
&
(
*
lines
)
[
0
]
=
=
0
)
)
{
return
true
;
}
int32_t
lineStart
=
0
;
for
(
uint32_t
index
=
0
;
index
<
=
length
;
+
+
index
)
{
int32_t
lineEnd
;
if
(
index
<
length
)
{
int32_t
nextLineStart
=
(
*
lines
)
[
index
]
;
if
(
nextLineStart
=
=
0
)
{
MOZ_ASSERT
(
index
=
=
0
)
;
continue
;
}
lineEnd
=
nextLineStart
-
1
;
}
else
{
lineEnd
=
static_cast
<
int32_t
>
(
nsAccUtils
:
:
TextLength
(
this
)
)
-
1
;
}
MOZ_ASSERT
(
lineEnd
>
=
lineStart
)
;
nsRect
lineRect
=
GetCachedCharRect
(
lineStart
)
;
if
(
lineEnd
>
lineStart
)
{
lineRect
.
UnionRect
(
lineRect
GetCachedCharRect
(
lineEnd
)
)
;
}
if
(
BoundsWithOffset
(
Some
(
lineRect
)
true
)
.
Contains
(
aX
aY
)
)
{
return
true
;
}
lineStart
=
lineEnd
+
1
;
}
return
false
;
}
RemoteAccessible
*
RemoteAccessible
:
:
DoFuzzyHittesting
(
)
{
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
Bounds
)
;
uint32_t
childCount
=
ChildCount
(
)
;
if
(
!
childCount
)
{
return
nullptr
;
}
RemoteAccessible
*
clippedContainer
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
childCount
;
i
+
+
)
{
RemoteAccessible
*
child
=
RemoteChildAt
(
i
)
;
if
(
child
-
>
Role
(
)
=
=
roles
:
:
TEXT_CONTAINER
)
{
if
(
child
-
>
IsClipped
(
)
)
{
clippedContainer
=
child
;
break
;
}
}
}
RemoteAccessible
*
container
=
clippedContainer
;
while
(
container
)
{
RemoteAccessible
*
textLeaf
=
nullptr
;
bool
continueSearch
=
false
;
childCount
=
container
-
>
ChildCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
childCount
;
i
+
+
)
{
RemoteAccessible
*
child
=
container
-
>
RemoteChildAt
(
i
)
;
if
(
child
-
>
Role
(
)
=
=
roles
:
:
TEXT_CONTAINER
)
{
container
=
child
;
continueSearch
=
true
;
break
;
}
if
(
child
-
>
IsTextLeaf
(
)
)
{
textLeaf
=
child
;
}
}
if
(
textLeaf
)
{
return
textLeaf
;
}
if
(
!
continueSearch
)
{
break
;
}
}
return
nullptr
;
}
Accessible
*
RemoteAccessible
:
:
ChildAtPoint
(
int32_t
aX
int32_t
aY
LocalAccessible
:
:
EWhichChildAtPoint
aWhichChild
)
{
if
(
RequestDomainsIfInactive
(
kNecessaryBoundsDomains
|
CacheDomain
:
:
TextBounds
)
)
{
return
nullptr
;
}
const
bool
hitTesting
=
true
;
if
(
IsOuterDoc
(
)
&
&
aWhichChild
=
=
EWhichChildAtPoint
:
:
DirectChild
)
{
if
(
BoundsWithOffset
(
Nothing
(
)
hitTesting
)
.
Contains
(
aX
aY
)
)
{
return
RemoteFirstChild
(
)
;
}
return
nullptr
;
}
RemoteAccessible
*
lastMatch
=
nullptr
;
if
(
DocAccessibleParent
*
doc
=
IsDoc
(
)
?
AsDoc
(
)
:
mDoc
)
{
if
(
!
doc
-
>
mCachedFields
)
{
return
nullptr
;
}
if
(
auto
maybeViewportCache
=
doc
-
>
mCachedFields
-
>
GetAttribute
<
nsTArray
<
uint64_t
>
>
(
CacheKey
:
:
Viewport
)
)
{
const
nsTArray
<
uint64_t
>
&
viewportCache
=
*
maybeViewportCache
;
for
(
auto
id
:
viewportCache
)
{
RemoteAccessible
*
acc
=
doc
-
>
GetAccessible
(
id
)
;
if
(
!
acc
)
{
continue
;
}
if
(
acc
-
>
IsOuterDoc
(
)
&
&
aWhichChild
=
=
EWhichChildAtPoint
:
:
DeepestChild
&
&
acc
-
>
BoundsWithOffset
(
Nothing
(
)
hitTesting
)
.
Contains
(
aX
aY
)
)
{
RemoteAccessible
*
innerDoc
=
acc
-
>
RemoteFirstChild
(
)
;
if
(
innerDoc
)
{
MOZ_ASSERT
(
innerDoc
-
>
IsDoc
(
)
)
;
Accessible
*
deepestAcc
=
innerDoc
-
>
ChildAtPoint
(
aX
aY
EWhichChildAtPoint
:
:
DeepestChild
)
;
MOZ_ASSERT
(
!
deepestAcc
|
|
deepestAcc
-
>
IsRemote
(
)
)
;
lastMatch
=
deepestAcc
?
deepestAcc
-
>
AsRemote
(
)
:
nullptr
;
break
;
}
lastMatch
=
acc
;
break
;
}
if
(
acc
=
=
this
)
{
MOZ_ASSERT
(
!
acc
-
>
IsOuterDoc
(
)
)
;
if
(
!
lastMatch
&
&
BoundsWithOffset
(
Nothing
(
)
hitTesting
)
.
Contains
(
aX
aY
)
)
{
lastMatch
=
acc
;
}
break
;
}
if
(
acc
-
>
ContainsPoint
(
aX
aY
)
)
{
lastMatch
=
acc
;
break
;
}
}
if
(
lastMatch
)
{
RemoteAccessible
*
fuzzyMatch
=
lastMatch
-
>
DoFuzzyHittesting
(
)
;
lastMatch
=
fuzzyMatch
?
fuzzyMatch
:
lastMatch
;
}
}
}
if
(
aWhichChild
=
=
EWhichChildAtPoint
:
:
DirectChild
&
&
lastMatch
)
{
RemoteAccessible
*
parent
=
lastMatch
-
>
RemoteParent
(
)
;
for
(
;
;
)
{
if
(
parent
=
=
this
)
{
break
;
}
if
(
!
parent
|
|
parent
-
>
IsDoc
(
)
)
{
lastMatch
=
nullptr
;
break
;
}
lastMatch
=
parent
;
parent
=
parent
-
>
RemoteParent
(
)
;
}
}
else
if
(
aWhichChild
=
=
EWhichChildAtPoint
:
:
DeepestChild
&
&
lastMatch
&
&
!
IsDoc
(
)
&
&
!
IsAncestorOf
(
lastMatch
)
)
{
lastMatch
=
nullptr
;
}
if
(
!
lastMatch
&
&
BoundsWithOffset
(
Nothing
(
)
hitTesting
)
.
Contains
(
aX
aY
)
)
{
return
this
;
}
return
lastMatch
;
}
Maybe
<
nsRect
>
RemoteAccessible
:
:
RetrieveCachedBounds
(
)
const
{
if
(
!
mCachedFields
)
{
return
Nothing
(
)
;
}
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
Bounds
)
;
Maybe
<
const
nsTArray
<
int32_t
>
&
>
maybeArray
=
mCachedFields
-
>
GetAttribute
<
nsTArray
<
int32_t
>
>
(
CacheKey
:
:
ParentRelativeBounds
)
;
if
(
maybeArray
)
{
const
nsTArray
<
int32_t
>
&
relativeBoundsArr
=
*
maybeArray
;
MOZ_ASSERT
(
relativeBoundsArr
.
Length
(
)
=
=
4
"
Incorrectly
sized
bounds
array
"
)
;
nsRect
relativeBoundsRect
(
relativeBoundsArr
[
0
]
relativeBoundsArr
[
1
]
relativeBoundsArr
[
2
]
relativeBoundsArr
[
3
]
)
;
return
Some
(
relativeBoundsRect
)
;
}
return
Nothing
(
)
;
}
void
RemoteAccessible
:
:
ApplyCrossDocOffset
(
nsRect
&
aBounds
)
const
{
if
(
!
IsDoc
(
)
)
{
return
;
}
RemoteAccessible
*
parentAcc
=
RemoteParent
(
)
;
if
(
!
parentAcc
|
|
!
parentAcc
-
>
IsOuterDoc
(
)
)
{
return
;
}
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
Bounds
)
;
Maybe
<
const
nsTArray
<
int32_t
>
&
>
maybeOffset
=
parentAcc
-
>
mCachedFields
-
>
GetAttribute
<
nsTArray
<
int32_t
>
>
(
CacheKey
:
:
CrossDocOffset
)
;
if
(
!
maybeOffset
)
{
return
;
}
MOZ_ASSERT
(
maybeOffset
-
>
Length
(
)
=
=
2
)
;
const
nsTArray
<
int32_t
>
&
offset
=
*
maybeOffset
;
aBounds
.
MoveBy
(
offset
[
0
]
offset
[
1
]
)
;
}
bool
RemoteAccessible
:
:
ApplyTransform
(
nsRect
&
aCumulativeBounds
)
const
{
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
TransformMatrix
)
;
Maybe
<
const
UniquePtr
<
gfx
:
:
Matrix4x4
>
&
>
maybeTransform
=
mCachedFields
-
>
GetAttribute
<
UniquePtr
<
gfx
:
:
Matrix4x4
>
>
(
CacheKey
:
:
TransformMatrix
)
;
if
(
!
maybeTransform
)
{
return
false
;
}
auto
mtxInPixels
=
gfx
:
:
Matrix4x4Typed
<
CSSPixel
CSSPixel
>
:
:
FromUnknownMatrix
(
*
(
*
maybeTransform
)
)
;
auto
boundsInPixels
=
CSSRect
:
:
FromAppUnits
(
aCumulativeBounds
)
;
boundsInPixels
=
mtxInPixels
.
TransformBounds
(
boundsInPixels
)
;
aCumulativeBounds
=
CSSRect
:
:
ToAppUnits
(
boundsInPixels
)
;
return
true
;
}
bool
RemoteAccessible
:
:
ApplyScrollOffset
(
nsRect
&
aBounds
)
const
{
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
ScrollPosition
)
;
Maybe
<
const
nsTArray
<
int32_t
>
&
>
maybeScrollPosition
=
mCachedFields
-
>
GetAttribute
<
nsTArray
<
int32_t
>
>
(
CacheKey
:
:
ScrollPosition
)
;
if
(
!
maybeScrollPosition
|
|
maybeScrollPosition
-
>
Length
(
)
!
=
2
)
{
return
false
;
}
const
nsTArray
<
int32_t
>
&
scrollPosition
=
*
maybeScrollPosition
;
nsPoint
scrollOffset
(
-
scrollPosition
[
0
]
-
scrollPosition
[
1
]
)
;
aBounds
.
MoveBy
(
scrollOffset
.
x
scrollOffset
.
y
)
;
return
true
;
}
nsRect
RemoteAccessible
:
:
BoundsInAppUnits
(
)
const
{
if
(
RequestDomainsIfInactive
(
kNecessaryBoundsDomains
)
)
{
return
{
}
;
}
if
(
dom
:
:
CanonicalBrowsingContext
*
cbc
=
mDoc
-
>
GetBrowsingContext
(
)
-
>
Top
(
)
)
{
if
(
dom
:
:
BrowserParent
*
bp
=
cbc
-
>
GetBrowserParent
(
)
)
{
DocAccessibleParent
*
topDoc
=
bp
-
>
GetTopLevelDocAccessible
(
)
;
if
(
topDoc
&
&
topDoc
-
>
mCachedFields
)
{
auto
appUnitsPerDevPixel
=
topDoc
-
>
mCachedFields
-
>
GetAttribute
<
int32_t
>
(
CacheKey
:
:
AppUnitsPerDevPixel
)
;
MOZ_ASSERT
(
appUnitsPerDevPixel
)
;
return
LayoutDeviceIntRect
:
:
ToAppUnits
(
Bounds
(
)
*
appUnitsPerDevPixel
)
;
}
}
}
return
LayoutDeviceIntRect
:
:
ToAppUnits
(
Bounds
(
)
AppUnitsPerCSSPixel
(
)
)
;
}
bool
RemoteAccessible
:
:
IsFixedPos
(
)
const
{
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
Style
)
;
MOZ_ASSERT
(
mCachedFields
)
;
if
(
auto
maybePosition
=
mCachedFields
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
CacheKey
:
:
CssPosition
)
)
{
return
*
maybePosition
=
=
nsGkAtoms
:
:
fixed
;
}
return
false
;
}
bool
RemoteAccessible
:
:
IsOverflowHidden
(
)
const
{
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
Style
)
;
MOZ_ASSERT
(
mCachedFields
)
;
if
(
auto
maybeOverflow
=
mCachedFields
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
CacheKey
:
:
CSSOverflow
)
)
{
return
*
maybeOverflow
=
=
nsGkAtoms
:
:
hidden
;
}
return
false
;
}
bool
RemoteAccessible
:
:
IsClipped
(
)
const
{
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
Bounds
)
;
MOZ_ASSERT
(
mCachedFields
)
;
if
(
mCachedFields
-
>
GetAttribute
<
bool
>
(
CacheKey
:
:
IsClipped
)
)
{
return
true
;
}
return
false
;
}
LayoutDeviceIntRect
RemoteAccessible
:
:
BoundsWithOffset
(
Maybe
<
nsRect
>
aOffset
bool
aBoundsAreForHittesting
)
const
{
if
(
RequestDomainsIfInactive
(
kNecessaryBoundsDomains
)
)
{
return
LayoutDeviceIntRect
{
}
;
}
Maybe
<
nsRect
>
maybeBounds
=
RetrieveCachedBounds
(
)
;
if
(
maybeBounds
)
{
nsRect
bounds
=
*
maybeBounds
;
bounds
.
MoveTo
(
0
0
)
;
const
DocAccessibleParent
*
topDoc
=
IsDoc
(
)
?
AsDoc
(
)
:
nullptr
;
if
(
aOffset
.
isSome
(
)
)
{
nsRect
internalRect
=
*
aOffset
;
bounds
.
SetRectX
(
bounds
.
x
+
internalRect
.
x
internalRect
.
width
)
;
bounds
.
SetRectY
(
bounds
.
y
+
internalRect
.
y
internalRect
.
height
)
;
}
Unused
<
<
ApplyTransform
(
bounds
)
;
bounds
.
MoveBy
(
maybeBounds
-
>
TopLeft
(
)
)
;
ApplyCrossDocOffset
(
bounds
)
;
LayoutDeviceIntRect
devPxBounds
;
const
Accessible
*
acc
=
Parent
(
)
;
bool
encounteredFixedContainer
=
IsFixedPos
(
)
;
while
(
acc
&
&
acc
-
>
IsRemote
(
)
)
{
if
(
aBoundsAreForHittesting
&
&
bounds
.
IsEmpty
(
)
)
{
return
LayoutDeviceIntRect
{
}
;
}
RemoteAccessible
*
remoteAcc
=
const_cast
<
Accessible
*
>
(
acc
)
-
>
AsRemote
(
)
;
if
(
Maybe
<
nsRect
>
maybeRemoteBounds
=
remoteAcc
-
>
RetrieveCachedBounds
(
)
)
{
nsRect
remoteBounds
=
*
maybeRemoteBounds
;
if
(
remoteAcc
-
>
IsDoc
(
)
)
{
Maybe
<
float
>
res
=
remoteAcc
-
>
AsDoc
(
)
-
>
mCachedFields
-
>
GetAttribute
<
float
>
(
CacheKey
:
:
Resolution
)
;
MOZ_ASSERT
(
res
"
No
cached
document
resolution
found
.
"
)
;
bounds
.
ScaleRoundOut
(
res
.
valueOr
(
1
.
0f
)
)
;
topDoc
=
remoteAcc
-
>
AsDoc
(
)
;
}
remoteAcc
-
>
ApplyCrossDocOffset
(
remoteBounds
)
;
if
(
!
encounteredFixedContainer
)
{
const
bool
hasScrollArea
=
remoteAcc
-
>
ApplyScrollOffset
(
bounds
)
;
if
(
aBoundsAreForHittesting
&
&
(
hasScrollArea
|
|
remoteAcc
-
>
IsOverflowHidden
(
)
)
)
{
nsRect
selfRelativeVisibleBounds
(
0
0
remoteBounds
.
width
remoteBounds
.
height
)
;
bounds
=
bounds
.
SafeIntersect
(
selfRelativeVisibleBounds
)
;
}
}
if
(
remoteAcc
-
>
IsDoc
(
)
)
{
encounteredFixedContainer
=
false
;
}
if
(
!
encounteredFixedContainer
)
{
Unused
<
<
remoteAcc
-
>
ApplyTransform
(
bounds
)
;
bounds
.
MoveBy
(
remoteBounds
.
X
(
)
remoteBounds
.
Y
(
)
)
;
}
if
(
remoteAcc
-
>
IsFixedPos
(
)
)
{
encounteredFixedContainer
=
true
;
}
}
acc
=
acc
-
>
Parent
(
)
;
}
MOZ_ASSERT
(
topDoc
)
;
if
(
topDoc
)
{
auto
appUnitsPerDevPixel
=
topDoc
-
>
mCachedFields
-
>
GetAttribute
<
int32_t
>
(
CacheKey
:
:
AppUnitsPerDevPixel
)
;
MOZ_ASSERT
(
appUnitsPerDevPixel
)
;
if
(
appUnitsPerDevPixel
)
{
devPxBounds
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
bounds
*
appUnitsPerDevPixel
)
;
}
}
#
if
!
defined
(
ANDROID
)
if
(
LocalAccessible
*
localAcc
=
acc
?
const_cast
<
Accessible
*
>
(
acc
)
-
>
AsLocal
(
)
:
nullptr
)
{
LayoutDeviceIntRect
localBounds
=
localAcc
-
>
Bounds
(
)
;
devPxBounds
.
MoveBy
(
localBounds
.
X
(
)
localBounds
.
Y
(
)
)
;
}
#
endif
return
devPxBounds
;
}
return
LayoutDeviceIntRect
(
)
;
}
LayoutDeviceIntRect
RemoteAccessible
:
:
Bounds
(
)
const
{
if
(
RequestDomainsIfInactive
(
kNecessaryBoundsDomains
)
)
{
return
{
}
;
}
return
BoundsWithOffset
(
Nothing
(
)
)
;
}
Relation
RemoteAccessible
:
:
RelationByType
(
RelationType
aType
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Relations
|
CacheDomain
:
:
Value
|
CacheDomain
:
:
DOMNodeIDAndClass
|
CacheDomain
:
:
GroupInfo
)
)
{
return
Relation
(
)
;
}
if
(
aType
=
=
RelationType
:
:
CONTAINING_TAB_PANE
)
{
if
(
dom
:
:
CanonicalBrowsingContext
*
cbc
=
mDoc
-
>
GetBrowsingContext
(
)
)
{
if
(
dom
:
:
CanonicalBrowsingContext
*
topCbc
=
cbc
-
>
Top
(
)
)
{
if
(
dom
:
:
BrowserParent
*
bp
=
topCbc
-
>
GetBrowserParent
(
)
)
{
return
Relation
(
bp
-
>
GetTopLevelDocAccessible
(
)
)
;
}
}
}
return
Relation
(
)
;
}
if
(
aType
=
=
RelationType
:
:
LINKS_TO
&
&
Role
(
)
=
=
roles
:
:
LINK
)
{
Pivot
p
=
Pivot
(
mDoc
)
;
nsString
href
;
Value
(
href
)
;
int32_t
i
=
href
.
FindChar
(
'
#
'
)
;
int32_t
len
=
static_cast
<
int32_t
>
(
href
.
Length
(
)
)
;
if
(
i
!
=
-
1
&
&
i
<
(
len
-
1
)
)
{
nsDependentSubstring
anchorName
=
Substring
(
href
i
+
1
len
)
;
MustPruneSameDocRule
rule
;
Accessible
*
nameMatch
=
nullptr
;
for
(
Accessible
*
match
=
p
.
Next
(
mDoc
rule
)
;
match
;
match
=
p
.
Next
(
match
rule
)
)
{
nsString
currID
;
match
-
>
DOMNodeID
(
currID
)
;
MOZ_ASSERT
(
match
-
>
IsRemote
(
)
)
;
if
(
anchorName
.
Equals
(
currID
)
)
{
return
Relation
(
match
-
>
AsRemote
(
)
)
;
}
if
(
!
nameMatch
)
{
nsString
currName
=
match
-
>
AsRemote
(
)
-
>
GetCachedHTMLNameAttribute
(
)
;
if
(
match
-
>
TagName
(
)
=
=
nsGkAtoms
:
:
a
&
&
anchorName
.
Equals
(
currName
)
)
{
nameMatch
=
match
;
}
}
}
return
nameMatch
?
Relation
(
nameMatch
-
>
AsRemote
(
)
)
:
Relation
(
)
;
}
return
Relation
(
)
;
}
if
(
aType
=
=
RelationType
:
:
NODE_CHILD_OF
)
{
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
if
(
roleMapEntry
&
&
(
roleMapEntry
-
>
role
=
=
roles
:
:
OUTLINEITEM
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
LISTITEM
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
ROW
)
)
{
if
(
const
AccGroupInfo
*
groupInfo
=
const_cast
<
RemoteAccessible
*
>
(
this
)
-
>
GetOrCreateGroupInfo
(
)
)
{
return
Relation
(
groupInfo
-
>
ConceptualParent
(
)
)
;
}
}
return
Relation
(
)
;
}
if
(
aType
=
=
RelationType
:
:
NODE_PARENT_OF
)
{
const
nsRoleMapEntry
*
roleMapEntry
=
ARIARoleMap
(
)
;
if
(
roleMapEntry
&
&
(
roleMapEntry
-
>
role
=
=
roles
:
:
OUTLINEITEM
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
LISTITEM
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
ROW
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
OUTLINE
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
LIST
|
|
roleMapEntry
-
>
role
=
=
roles
:
:
TREE_TABLE
)
)
{
return
Relation
(
new
ItemIterator
(
this
)
)
;
}
return
Relation
(
)
;
}
if
(
aType
=
=
RelationType
:
:
MEMBER_OF
)
{
Relation
rel
=
Relation
(
)
;
if
(
IsHTMLRadioButton
(
)
)
{
nsString
name
=
GetCachedHTMLNameAttribute
(
)
;
if
(
name
.
IsEmpty
(
)
)
{
return
rel
;
}
RemoteAccessible
*
ancestor
=
RemoteParent
(
)
;
while
(
ancestor
&
&
ancestor
-
>
Role
(
)
!
=
roles
:
:
FORM
&
&
ancestor
!
=
mDoc
)
{
ancestor
=
ancestor
-
>
RemoteParent
(
)
;
}
if
(
ancestor
)
{
Pivot
p
=
Pivot
(
ancestor
)
;
PivotRadioNameRule
rule
(
name
)
;
Accessible
*
match
=
p
.
Next
(
ancestor
rule
)
;
while
(
match
)
{
rel
.
AppendTarget
(
match
-
>
AsRemote
(
)
)
;
match
=
p
.
Next
(
match
rule
)
;
}
}
return
rel
;
}
if
(
IsARIARole
(
nsGkAtoms
:
:
radio
)
)
{
RemoteAccessible
*
currParent
=
RemoteParent
(
)
;
while
(
currParent
&
&
currParent
-
>
Role
(
)
!
=
roles
:
:
RADIO_GROUP
)
{
currParent
=
currParent
-
>
RemoteParent
(
)
;
}
if
(
currParent
&
&
currParent
-
>
Role
(
)
=
=
roles
:
:
RADIO_GROUP
)
{
Pivot
p
=
Pivot
(
currParent
)
;
PivotRoleRule
rule
(
roles
:
:
RADIOBUTTON
)
;
Accessible
*
match
=
p
.
Next
(
currParent
rule
)
;
while
(
match
)
{
MOZ_ASSERT
(
match
-
>
IsRemote
(
)
"
We
should
only
be
traversing
the
remote
tree
.
"
)
;
rel
.
AppendTarget
(
match
-
>
AsRemote
(
)
)
;
match
=
p
.
Next
(
match
rule
)
;
}
}
}
return
rel
;
}
Relation
rel
;
if
(
!
mCachedFields
)
{
return
rel
;
}
for
(
const
auto
&
data
:
kRelationTypeAtoms
)
{
if
(
data
.
mType
!
=
aType
|
|
(
data
.
mValidTag
&
&
TagName
(
)
!
=
data
.
mValidTag
)
)
{
continue
;
}
if
(
auto
maybeIds
=
mCachedFields
-
>
GetAttribute
<
nsTArray
<
uint64_t
>
>
(
data
.
mAtom
)
)
{
rel
.
AppendIter
(
new
RemoteAccIterator
(
*
maybeIds
Document
(
)
)
)
;
}
break
;
}
if
(
auto
accRelMapEntry
=
mDoc
-
>
mReverseRelations
.
Lookup
(
ID
(
)
)
)
{
if
(
auto
reverseIdsEntry
=
accRelMapEntry
.
Data
(
)
.
Lookup
(
aType
)
)
{
rel
.
AppendIter
(
new
RemoteAccIterator
(
reverseIdsEntry
.
Data
(
)
Document
(
)
)
)
;
}
}
if
(
aType
=
=
RelationType
:
:
LABELLED_BY
&
&
TagName
(
)
=
=
nsGkAtoms
:
:
figure
)
{
uint32_t
count
=
ChildCount
(
)
;
for
(
uint32_t
c
=
0
;
c
<
count
;
+
+
c
)
{
RemoteAccessible
*
child
=
RemoteChildAt
(
c
)
;
MOZ_ASSERT
(
child
)
;
if
(
child
-
>
TagName
(
)
=
=
nsGkAtoms
:
:
figcaption
)
{
rel
.
AppendTarget
(
child
)
;
}
}
}
else
if
(
aType
=
=
RelationType
:
:
LABEL_FOR
&
&
TagName
(
)
=
=
nsGkAtoms
:
:
figcaption
)
{
if
(
RemoteAccessible
*
parent
=
RemoteParent
(
)
)
{
if
(
parent
-
>
TagName
(
)
=
=
nsGkAtoms
:
:
figure
)
{
rel
.
AppendTarget
(
parent
)
;
}
}
}
return
rel
;
}
void
RemoteAccessible
:
:
AppendTextTo
(
nsAString
&
aText
uint32_t
aStartOffset
uint32_t
aLength
)
{
if
(
IsText
(
)
)
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Text
)
)
{
return
;
}
if
(
mCachedFields
)
{
if
(
auto
text
=
mCachedFields
-
>
GetAttribute
<
nsString
>
(
CacheKey
:
:
Text
)
)
{
aText
.
Append
(
Substring
(
*
text
aStartOffset
aLength
)
)
;
}
VERIFY_CACHE
(
CacheDomain
:
:
Text
)
;
}
return
;
}
if
(
aStartOffset
!
=
0
|
|
aLength
=
=
0
)
{
return
;
}
if
(
IsHTMLBr
(
)
)
{
aText
+
=
kForcedNewLineChar
;
}
else
if
(
RemoteParent
(
)
&
&
nsAccUtils
:
:
MustPrune
(
RemoteParent
(
)
)
)
{
aText
+
=
kImaginaryEmbeddedObjectChar
;
}
else
{
aText
+
=
kEmbeddedObjectChar
;
}
}
nsTArray
<
bool
>
RemoteAccessible
:
:
PreProcessRelations
(
AccAttributes
*
aFields
)
{
if
(
!
DomainsAreActive
(
CacheDomain
:
:
Relations
)
)
{
return
{
}
;
}
nsTArray
<
bool
>
updateTracker
(
ArrayLength
(
kRelationTypeAtoms
)
)
;
for
(
auto
const
&
data
:
kRelationTypeAtoms
)
{
if
(
data
.
mValidTag
)
{
nsAtom
*
tag
=
TagName
(
)
;
if
(
!
tag
)
{
if
(
auto
maybeTag
=
aFields
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
CacheKey
:
:
TagName
)
)
{
tag
=
*
maybeTag
;
}
}
MOZ_ASSERT
(
tag
|
|
IsTextLeaf
(
)
|
|
IsDoc
(
)
"
Could
not
fetch
tag
via
TagName
(
)
or
from
initial
cache
push
!
"
)
;
if
(
tag
!
=
data
.
mValidTag
)
{
updateTracker
.
AppendElement
(
false
)
;
continue
;
}
}
nsStaticAtom
*
const
relAtom
=
data
.
mAtom
;
auto
newRelationTargets
=
aFields
-
>
GetAttribute
<
nsTArray
<
uint64_t
>
>
(
relAtom
)
;
bool
shouldAddNewImplicitRels
=
newRelationTargets
&
&
newRelationTargets
-
>
Length
(
)
;
if
(
(
shouldAddNewImplicitRels
|
|
aFields
-
>
GetAttribute
<
DeleteEntry
>
(
relAtom
)
)
&
&
mCachedFields
)
{
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
Relations
)
;
if
(
auto
maybeOldIDs
=
mCachedFields
-
>
GetAttribute
<
nsTArray
<
uint64_t
>
>
(
relAtom
)
)
{
for
(
uint64_t
id
:
*
maybeOldIDs
)
{
if
(
auto
reverseRels
=
Document
(
)
-
>
mReverseRelations
.
Lookup
(
id
)
)
{
nsTArray
<
uint64_t
>
&
reverseRelIDs
=
reverseRels
-
>
LookupOrInsert
(
data
.
mReverseType
)
;
DebugOnly
<
bool
>
removed
=
reverseRelIDs
.
RemoveElement
(
ID
(
)
)
;
MOZ_ASSERT
(
removed
"
Can
'
t
find
old
reverse
relation
"
)
;
}
}
}
}
updateTracker
.
AppendElement
(
shouldAddNewImplicitRels
)
;
}
return
updateTracker
;
}
void
RemoteAccessible
:
:
PostProcessRelations
(
const
nsTArray
<
bool
>
&
aToUpdate
)
{
if
(
!
DomainsAreActive
(
CacheDomain
:
:
Relations
)
)
{
return
;
}
size_t
updateCount
=
aToUpdate
.
Length
(
)
;
MOZ_ASSERT
(
updateCount
=
=
ArrayLength
(
kRelationTypeAtoms
)
"
Did
not
note
update
status
for
every
relation
type
!
"
)
;
for
(
size_t
i
=
0
;
i
<
updateCount
;
i
+
+
)
{
if
(
aToUpdate
.
ElementAt
(
i
)
)
{
auto
const
&
data
=
kRelationTypeAtoms
[
i
]
;
const
nsTArray
<
uint64_t
>
&
newIDs
=
*
mCachedFields
-
>
GetAttribute
<
nsTArray
<
uint64_t
>
>
(
data
.
mAtom
)
;
for
(
uint64_t
id
:
newIDs
)
{
nsTHashMap
<
RelationType
nsTArray
<
uint64_t
>
>
&
relations
=
Document
(
)
-
>
mReverseRelations
.
LookupOrInsert
(
id
)
;
nsTArray
<
uint64_t
>
&
ids
=
relations
.
LookupOrInsert
(
data
.
mReverseType
)
;
ids
.
AppendElement
(
ID
(
)
)
;
}
}
}
}
void
RemoteAccessible
:
:
PruneRelationsOnShutdown
(
)
{
auto
reverseRels
=
mDoc
-
>
mReverseRelations
.
Lookup
(
ID
(
)
)
;
if
(
!
reverseRels
)
{
return
;
}
for
(
auto
const
&
data
:
kRelationTypeAtoms
)
{
auto
reverseTargetList
=
reverseRels
-
>
Lookup
(
data
.
mReverseType
)
;
if
(
!
reverseTargetList
)
{
continue
;
}
for
(
uint64_t
id
:
*
reverseTargetList
)
{
RemoteAccessible
*
affectedAcc
=
mDoc
-
>
GetAccessible
(
id
)
;
if
(
!
affectedAcc
)
{
continue
;
}
if
(
auto
forwardTargetList
=
affectedAcc
-
>
mCachedFields
-
>
GetMutableAttribute
<
nsTArray
<
uint64_t
>
>
(
data
.
mAtom
)
)
{
forwardTargetList
-
>
RemoveElement
(
ID
(
)
)
;
if
(
!
forwardTargetList
-
>
Length
(
)
)
{
affectedAcc
-
>
mCachedFields
-
>
Remove
(
data
.
mAtom
)
;
}
}
}
}
reverseRels
.
Remove
(
)
;
}
uint32_t
RemoteAccessible
:
:
GetCachedTextLength
(
)
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Text
)
)
{
return
0
;
}
MOZ_ASSERT
(
!
HasChildren
(
)
)
;
if
(
!
mCachedFields
)
{
return
0
;
}
VERIFY_CACHE
(
CacheDomain
:
:
Text
)
;
auto
text
=
mCachedFields
-
>
GetAttribute
<
nsString
>
(
CacheKey
:
:
Text
)
;
if
(
!
text
)
{
return
0
;
}
return
text
-
>
Length
(
)
;
}
Maybe
<
const
nsTArray
<
int32_t
>
&
>
RemoteAccessible
:
:
GetCachedTextLines
(
)
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
TextBounds
)
)
{
return
Nothing
(
)
;
}
MOZ_ASSERT
(
!
HasChildren
(
)
)
;
if
(
!
mCachedFields
)
{
return
Nothing
(
)
;
}
VERIFY_CACHE
(
CacheDomain
:
:
TextBounds
)
;
return
mCachedFields
-
>
GetAttribute
<
nsTArray
<
int32_t
>
>
(
CacheKey
:
:
TextLineStarts
)
;
}
nsRect
RemoteAccessible
:
:
GetCachedCharRect
(
int32_t
aOffset
)
{
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
TextBounds
)
;
MOZ_ASSERT
(
IsText
(
)
)
;
if
(
!
mCachedFields
)
{
return
nsRect
(
)
;
}
if
(
Maybe
<
const
nsTArray
<
int32_t
>
&
>
maybeCharData
=
mCachedFields
-
>
GetAttribute
<
nsTArray
<
int32_t
>
>
(
CacheKey
:
:
TextBounds
)
)
{
const
nsTArray
<
int32_t
>
&
charData
=
*
maybeCharData
;
const
int32_t
index
=
aOffset
*
kNumbersInRect
;
if
(
index
<
static_cast
<
int32_t
>
(
charData
.
Length
(
)
)
)
{
return
nsRect
(
charData
[
index
]
charData
[
index
+
1
]
charData
[
index
+
2
]
charData
[
index
+
3
]
)
;
}
MOZ_ASSERT
(
index
=
=
static_cast
<
int32_t
>
(
charData
.
Length
(
)
)
)
;
}
return
nsRect
(
)
;
}
void
RemoteAccessible
:
:
DOMNodeID
(
nsString
&
aID
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
DOMNodeIDAndClass
)
)
{
return
;
}
if
(
mCachedFields
)
{
mCachedFields
-
>
GetAttribute
(
CacheKey
:
:
DOMNodeID
aID
)
;
VERIFY_CACHE
(
CacheDomain
:
:
DOMNodeIDAndClass
)
;
}
}
void
RemoteAccessible
:
:
DOMNodeClass
(
nsString
&
aClass
)
const
{
if
(
mCachedFields
)
{
mCachedFields
-
>
GetAttribute
(
CacheKey
:
:
DOMNodeClass
aClass
)
;
VERIFY_CACHE
(
CacheDomain
:
:
DOMNodeIDAndClass
)
;
}
}
void
RemoteAccessible
:
:
ScrollToPoint
(
uint32_t
aScrollType
int32_t
aX
int32_t
aY
)
{
Unused
<
<
mDoc
-
>
SendScrollToPoint
(
mID
aScrollType
aX
aY
)
;
}
#
if
!
defined
(
XP_WIN
)
void
RemoteAccessible
:
:
Announce
(
const
nsString
&
aAnnouncement
uint16_t
aPriority
)
{
Unused
<
<
mDoc
-
>
SendAnnounce
(
mID
aAnnouncement
aPriority
)
;
}
#
endif
int32_t
RemoteAccessible
:
:
ValueRegion
(
)
const
{
MOZ_ASSERT
(
TagName
(
)
=
=
nsGkAtoms
:
:
meter
"
Accessing
value
region
on
non
-
meter
element
?
"
)
;
if
(
mCachedFields
)
{
if
(
auto
region
=
mCachedFields
-
>
GetAttribute
<
int32_t
>
(
CacheKey
:
:
ValueRegion
)
)
{
return
*
region
;
}
}
return
0
;
}
void
RemoteAccessible
:
:
ScrollSubstringToPoint
(
int32_t
aStartOffset
int32_t
aEndOffset
uint32_t
aCoordinateType
int32_t
aX
int32_t
aY
)
{
Unused
<
<
mDoc
-
>
SendScrollSubstringToPoint
(
mID
aStartOffset
aEndOffset
aCoordinateType
aX
aY
)
;
}
RefPtr
<
const
AccAttributes
>
RemoteAccessible
:
:
GetCachedTextAttributes
(
)
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Text
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
IsText
(
)
|
|
IsHyperText
(
)
)
;
if
(
mCachedFields
)
{
auto
attrs
=
mCachedFields
-
>
GetAttributeRefPtr
<
AccAttributes
>
(
CacheKey
:
:
TextAttributes
)
;
VERIFY_CACHE
(
CacheDomain
:
:
Text
)
;
return
attrs
;
}
return
nullptr
;
}
already_AddRefed
<
AccAttributes
>
RemoteAccessible
:
:
DefaultTextAttributes
(
)
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Text
)
)
{
return
nullptr
;
}
RefPtr
<
const
AccAttributes
>
attrs
=
GetCachedTextAttributes
(
)
;
RefPtr
<
AccAttributes
>
result
=
new
AccAttributes
(
)
;
if
(
attrs
)
{
attrs
-
>
CopyTo
(
result
)
;
}
return
result
.
forget
(
)
;
}
RefPtr
<
const
AccAttributes
>
RemoteAccessible
:
:
GetCachedARIAAttributes
(
)
const
{
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
ARIA
)
;
if
(
mCachedFields
)
{
auto
attrs
=
mCachedFields
-
>
GetAttributeRefPtr
<
AccAttributes
>
(
CacheKey
:
:
ARIAAttributes
)
;
VERIFY_CACHE
(
CacheDomain
:
:
ARIA
)
;
return
attrs
;
}
return
nullptr
;
}
nsString
RemoteAccessible
:
:
GetCachedHTMLNameAttribute
(
)
const
{
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
Relations
)
;
if
(
mCachedFields
)
{
if
(
auto
maybeName
=
mCachedFields
-
>
GetAttribute
<
nsString
>
(
CacheKey
:
:
DOMName
)
)
{
return
*
maybeName
;
}
}
return
nsString
(
)
;
}
uint64_t
RemoteAccessible
:
:
State
(
)
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
State
|
CacheDomain
:
:
Style
|
CacheDomain
:
:
Viewport
)
)
{
return
0
;
}
uint64_t
state
=
0
;
if
(
mCachedFields
)
{
if
(
auto
rawState
=
mCachedFields
-
>
GetAttribute
<
uint64_t
>
(
CacheKey
:
:
State
)
)
{
VERIFY_CACHE
(
CacheDomain
:
:
State
)
;
state
=
*
rawState
;
if
(
!
(
state
&
states
:
:
UNAVAILABLE
)
)
{
state
|
=
states
:
:
ENABLED
|
states
:
:
SENSITIVE
;
}
if
(
state
&
states
:
:
EXPANDABLE
&
&
!
(
state
&
states
:
:
EXPANDED
)
)
{
state
|
=
states
:
:
COLLAPSED
;
}
}
ApplyImplicitState
(
state
)
;
auto
*
cbc
=
mDoc
-
>
GetBrowsingContext
(
)
;
if
(
cbc
&
&
!
cbc
-
>
IsActive
(
)
)
{
state
|
=
states
:
:
OFFSCREEN
;
}
else
{
if
(
!
mDoc
-
>
IsTopLevel
(
)
)
{
Accessible
*
docParent
=
mDoc
-
>
Parent
(
)
;
if
(
NS_WARN_IF
(
!
docParent
|
|
!
docParent
-
>
IsRemote
(
)
)
)
{
return
state
;
}
RemoteAccessible
*
outerDoc
=
docParent
-
>
AsRemote
(
)
;
DocAccessibleParent
*
embeddingDocument
=
outerDoc
-
>
Document
(
)
;
if
(
embeddingDocument
&
&
!
embeddingDocument
-
>
mOnScreenAccessibles
.
Contains
(
outerDoc
-
>
ID
(
)
)
)
{
state
|
=
states
:
:
OFFSCREEN
;
}
else
if
(
this
!
=
mDoc
&
&
!
mDoc
-
>
mOnScreenAccessibles
.
Contains
(
ID
(
)
)
)
{
state
|
=
states
:
:
OFFSCREEN
;
}
}
else
if
(
this
!
=
mDoc
&
&
!
mDoc
-
>
mOnScreenAccessibles
.
Contains
(
ID
(
)
)
)
{
state
|
=
states
:
:
OFFSCREEN
;
}
}
}
return
state
;
}
already_AddRefed
<
AccAttributes
>
RemoteAccessible
:
:
Attributes
(
)
{
RefPtr
<
AccAttributes
>
attributes
=
new
AccAttributes
(
)
;
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
ARIA
|
CacheDomain
:
:
NameAndDescription
|
CacheDomain
:
:
Text
|
CacheDomain
:
:
Value
|
CacheDomain
:
:
Actions
|
CacheDomain
:
:
Style
|
CacheDomain
:
:
GroupInfo
|
CacheDomain
:
:
State
|
CacheDomain
:
:
Viewport
|
CacheDomain
:
:
Table
|
CacheDomain
:
:
DOMNodeIDAndClass
)
)
{
return
attributes
.
forget
(
)
;
}
nsAccessibilityService
*
accService
=
GetAccService
(
)
;
if
(
!
accService
)
{
return
attributes
.
forget
(
)
;
}
if
(
mCachedFields
)
{
if
(
auto
tag
=
mCachedFields
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
CacheKey
:
:
TagName
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
tag
*
tag
)
;
}
GroupPos
groupPos
=
GroupPosition
(
)
;
nsAccUtils
:
:
SetAccGroupAttrs
(
attributes
groupPos
.
level
groupPos
.
setSize
groupPos
.
posInSet
)
;
bool
hierarchical
=
false
;
uint32_t
itemCount
=
AccGroupInfo
:
:
TotalItemCount
(
this
&
hierarchical
)
;
if
(
itemCount
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
child_item_count
static_cast
<
int32_t
>
(
itemCount
)
)
;
}
if
(
hierarchical
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
tree
true
)
;
}
if
(
auto
inputType
=
mCachedFields
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
CacheKey
:
:
InputType
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
textInputType
*
inputType
)
;
}
if
(
RefPtr
<
nsAtom
>
display
=
DisplayStyle
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
display
display
)
;
}
if
(
TableCellAccessible
*
cell
=
AsTableCell
(
)
)
{
TableAccessible
*
table
=
cell
-
>
Table
(
)
;
uint32_t
row
=
cell
-
>
RowIdx
(
)
;
uint32_t
col
=
cell
-
>
ColIdx
(
)
;
int32_t
cellIdx
=
table
-
>
CellIndexAt
(
row
col
)
;
if
(
cellIdx
!
=
-
1
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
tableCellIndex
cellIdx
)
;
}
}
if
(
bool
layoutGuess
=
TableIsProbablyForLayout
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
layout_guess
layoutGuess
)
;
}
accService
-
>
MarkupAttributes
(
this
attributes
)
;
const
nsRoleMapEntry
*
roleMap
=
ARIARoleMap
(
)
;
nsAutoString
role
;
mCachedFields
-
>
GetAttribute
(
CacheKey
:
:
ARIARole
role
)
;
if
(
role
.
IsEmpty
(
)
)
{
if
(
roleMap
&
&
roleMap
-
>
roleAtom
!
=
nsGkAtoms
:
:
_empty
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
roleMap
-
>
roleAtom
)
;
}
else
if
(
nsAtom
*
landmark
=
LandmarkRole
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
landmark
)
;
}
}
else
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
xmlroles
std
:
:
move
(
role
)
)
;
}
if
(
roleMap
)
{
nsAutoString
live
;
if
(
nsAccUtils
:
:
GetLiveAttrValue
(
roleMap
-
>
liveAttRule
live
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
aria_live
std
:
:
move
(
live
)
)
;
}
}
if
(
auto
ariaAttrs
=
GetCachedARIAAttributes
(
)
)
{
ariaAttrs
-
>
CopyTo
(
attributes
)
;
}
nsAccUtils
:
:
SetLiveContainerAttributes
(
attributes
this
)
;
nsString
id
;
DOMNodeID
(
id
)
;
if
(
!
id
.
IsEmpty
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
id
std
:
:
move
(
id
)
)
;
}
nsString
className
;
DOMNodeClass
(
className
)
;
if
(
!
className
.
IsEmpty
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
_class
std
:
:
move
(
className
)
)
;
}
if
(
IsImage
(
)
)
{
nsString
src
;
mCachedFields
-
>
GetAttribute
(
CacheKey
:
:
SrcURL
src
)
;
if
(
!
src
.
IsEmpty
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
src
std
:
:
move
(
src
)
)
;
}
}
if
(
IsTextField
(
)
)
{
nsString
placeholder
;
mCachedFields
-
>
GetAttribute
(
CacheKey
:
:
HTMLPlaceholder
placeholder
)
;
if
(
!
placeholder
.
IsEmpty
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
placeholder
std
:
:
move
(
placeholder
)
)
;
attributes
-
>
Remove
(
nsGkAtoms
:
:
aria_placeholder
)
;
}
}
nsString
popupType
;
mCachedFields
-
>
GetAttribute
(
CacheKey
:
:
PopupType
popupType
)
;
if
(
!
popupType
.
IsEmpty
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
ispopup
std
:
:
move
(
popupType
)
)
;
}
}
nsAutoString
name
;
if
(
Name
(
name
)
!
=
eNameFromSubtree
&
&
!
name
.
IsVoid
(
)
)
{
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
explicit_name
true
)
;
}
if
(
HasNumericValue
(
)
)
{
nsString
valuetext
;
Value
(
valuetext
)
;
attributes
-
>
SetAttribute
(
nsGkAtoms
:
:
aria_valuetext
std
:
:
move
(
valuetext
)
)
;
}
return
attributes
.
forget
(
)
;
}
nsAtom
*
RemoteAccessible
:
:
TagName
(
)
const
{
if
(
mCachedFields
)
{
if
(
auto
tag
=
mCachedFields
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
CacheKey
:
:
TagName
)
)
{
return
*
tag
;
}
}
return
nullptr
;
}
already_AddRefed
<
nsAtom
>
RemoteAccessible
:
:
InputType
(
)
const
{
if
(
mCachedFields
)
{
if
(
auto
inputType
=
mCachedFields
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
CacheKey
:
:
InputType
)
)
{
RefPtr
<
nsAtom
>
result
=
*
inputType
;
return
result
.
forget
(
)
;
}
}
return
nullptr
;
}
already_AddRefed
<
nsAtom
>
RemoteAccessible
:
:
DisplayStyle
(
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Style
)
)
{
return
nullptr
;
}
if
(
mCachedFields
)
{
if
(
auto
display
=
mCachedFields
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
CacheKey
:
:
CSSDisplay
)
)
{
RefPtr
<
nsAtom
>
result
=
*
display
;
return
result
.
forget
(
)
;
}
}
return
nullptr
;
}
float
RemoteAccessible
:
:
Opacity
(
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Style
)
)
{
return
1
.
0f
;
}
if
(
mCachedFields
)
{
if
(
auto
opacity
=
mCachedFields
-
>
GetAttribute
<
float
>
(
CacheKey
:
:
Opacity
)
)
{
return
*
opacity
;
}
}
return
1
.
0f
;
}
void
RemoteAccessible
:
:
LiveRegionAttributes
(
nsAString
*
aLive
nsAString
*
aRelevant
Maybe
<
bool
>
*
aAtomic
nsAString
*
aBusy
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
ARIA
)
)
{
return
;
}
if
(
!
mCachedFields
)
{
return
;
}
RefPtr
<
const
AccAttributes
>
attrs
=
GetCachedARIAAttributes
(
)
;
if
(
!
attrs
)
{
return
;
}
if
(
aLive
)
{
attrs
-
>
GetAttribute
(
nsGkAtoms
:
:
aria_live
*
aLive
)
;
}
if
(
aRelevant
)
{
attrs
-
>
GetAttribute
(
nsGkAtoms
:
:
aria_relevant
*
aRelevant
)
;
}
if
(
aAtomic
)
{
if
(
auto
value
=
attrs
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
nsGkAtoms
:
:
aria_atomic
)
)
{
*
aAtomic
=
Some
(
*
value
=
=
nsGkAtoms
:
:
_true
)
;
}
}
if
(
aBusy
)
{
attrs
-
>
GetAttribute
(
nsGkAtoms
:
:
aria_busy
*
aBusy
)
;
}
}
Maybe
<
bool
>
RemoteAccessible
:
:
ARIASelected
(
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
State
)
)
{
return
Nothing
(
)
;
}
if
(
mCachedFields
)
{
return
mCachedFields
-
>
GetAttribute
<
bool
>
(
CacheKey
:
:
ARIASelected
)
;
}
return
Nothing
(
)
;
}
nsAtom
*
RemoteAccessible
:
:
GetPrimaryAction
(
)
const
{
if
(
mCachedFields
)
{
ASSERT_DOMAINS_ACTIVE
(
CacheDomain
:
:
Actions
)
;
if
(
auto
action
=
mCachedFields
-
>
GetAttribute
<
RefPtr
<
nsAtom
>
>
(
CacheKey
:
:
PrimaryAction
)
)
{
return
*
action
;
}
}
return
nullptr
;
}
uint8_t
RemoteAccessible
:
:
ActionCount
(
)
const
{
uint8_t
actionCount
=
0
;
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Actions
)
)
{
return
actionCount
;
}
if
(
mCachedFields
)
{
if
(
HasPrimaryAction
(
)
|
|
ActionAncestor
(
)
)
{
actionCount
+
+
;
}
if
(
mCachedFields
-
>
HasAttribute
(
CacheKey
:
:
HasLongdesc
)
)
{
actionCount
+
+
;
}
VERIFY_CACHE
(
CacheDomain
:
:
Actions
)
;
}
return
actionCount
;
}
void
RemoteAccessible
:
:
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Actions
)
)
{
return
;
}
if
(
mCachedFields
)
{
aName
.
Truncate
(
)
;
nsAtom
*
action
=
GetPrimaryAction
(
)
;
bool
hasActionAncestor
=
!
action
&
&
ActionAncestor
(
)
;
switch
(
aIndex
)
{
case
0
:
if
(
action
)
{
action
-
>
ToString
(
aName
)
;
}
else
if
(
hasActionAncestor
)
{
aName
.
AssignLiteral
(
"
clickAncestor
"
)
;
}
else
if
(
mCachedFields
-
>
HasAttribute
(
CacheKey
:
:
HasLongdesc
)
)
{
aName
.
AssignLiteral
(
"
showlongdesc
"
)
;
}
break
;
case
1
:
if
(
(
action
|
|
hasActionAncestor
)
&
&
mCachedFields
-
>
HasAttribute
(
CacheKey
:
:
HasLongdesc
)
)
{
aName
.
AssignLiteral
(
"
showlongdesc
"
)
;
}
break
;
default
:
break
;
}
}
VERIFY_CACHE
(
CacheDomain
:
:
Actions
)
;
}
bool
RemoteAccessible
:
:
DoAction
(
uint8_t
aIndex
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Actions
)
)
{
return
false
;
}
if
(
ActionCount
(
)
<
aIndex
+
1
)
{
return
false
;
}
Unused
<
<
mDoc
-
>
SendDoActionAsync
(
mID
aIndex
)
;
return
true
;
}
KeyBinding
RemoteAccessible
:
:
AccessKey
(
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Actions
)
)
{
return
{
}
;
}
if
(
mCachedFields
)
{
if
(
auto
value
=
mCachedFields
-
>
GetAttribute
<
uint64_t
>
(
CacheKey
:
:
AccessKey
)
)
{
return
KeyBinding
(
*
value
)
;
}
}
return
KeyBinding
(
)
;
}
void
RemoteAccessible
:
:
SelectionRanges
(
nsTArray
<
TextRange
>
*
aRanges
)
const
{
Document
(
)
-
>
SelectionRanges
(
aRanges
)
;
}
bool
RemoteAccessible
:
:
RemoveFromSelection
(
int32_t
aSelectionNum
)
{
MOZ_ASSERT
(
IsHyperText
(
)
)
;
if
(
SelectionCount
(
)
<
=
aSelectionNum
)
{
return
false
;
}
Unused
<
<
mDoc
-
>
SendRemoveTextSelection
(
mID
aSelectionNum
)
;
return
true
;
}
void
RemoteAccessible
:
:
ARIAGroupPosition
(
int32_t
*
aLevel
int32_t
*
aSetSize
int32_t
*
aPosInSet
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
GroupInfo
)
)
{
return
;
}
if
(
!
mCachedFields
)
{
return
;
}
if
(
aLevel
)
{
if
(
auto
level
=
mCachedFields
-
>
GetAttribute
<
int32_t
>
(
nsGkAtoms
:
:
aria_level
)
)
{
*
aLevel
=
*
level
;
}
}
if
(
aSetSize
)
{
if
(
auto
setsize
=
mCachedFields
-
>
GetAttribute
<
int32_t
>
(
nsGkAtoms
:
:
aria_setsize
)
)
{
*
aSetSize
=
*
setsize
;
}
}
if
(
aPosInSet
)
{
if
(
auto
posinset
=
mCachedFields
-
>
GetAttribute
<
int32_t
>
(
nsGkAtoms
:
:
aria_posinset
)
)
{
*
aPosInSet
=
*
posinset
;
}
}
}
AccGroupInfo
*
RemoteAccessible
:
:
GetGroupInfo
(
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
GroupInfo
)
)
{
return
nullptr
;
}
if
(
!
mCachedFields
)
{
return
nullptr
;
}
if
(
auto
groupInfo
=
mCachedFields
-
>
GetAttribute
<
UniquePtr
<
AccGroupInfo
>
>
(
CacheKey
:
:
GroupInfo
)
)
{
return
groupInfo
-
>
get
(
)
;
}
return
nullptr
;
}
AccGroupInfo
*
RemoteAccessible
:
:
GetOrCreateGroupInfo
(
)
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
GroupInfo
)
)
{
return
nullptr
;
}
AccGroupInfo
*
groupInfo
=
GetGroupInfo
(
)
;
if
(
groupInfo
)
{
return
groupInfo
;
}
groupInfo
=
AccGroupInfo
:
:
CreateGroupInfo
(
this
)
;
if
(
groupInfo
)
{
if
(
!
mCachedFields
)
{
mCachedFields
=
new
AccAttributes
(
)
;
}
mCachedFields
-
>
SetAttribute
(
CacheKey
:
:
GroupInfo
groupInfo
)
;
}
return
groupInfo
;
}
void
RemoteAccessible
:
:
InvalidateGroupInfo
(
)
{
if
(
mCachedFields
)
{
mCachedFields
-
>
Remove
(
CacheKey
:
:
GroupInfo
)
;
}
}
void
RemoteAccessible
:
:
GetPositionAndSetSize
(
int32_t
*
aPosInSet
int32_t
*
aSetSize
)
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Relations
|
CacheDomain
:
:
Value
|
CacheDomain
:
:
DOMNodeIDAndClass
|
CacheDomain
:
:
GroupInfo
)
)
{
return
;
}
if
(
IsHTMLRadioButton
(
)
)
{
*
aSetSize
=
0
;
Relation
rel
=
RelationByType
(
RelationType
:
:
MEMBER_OF
)
;
while
(
Accessible
*
radio
=
rel
.
Next
(
)
)
{
+
+
*
aSetSize
;
if
(
radio
=
=
this
)
{
*
aPosInSet
=
*
aSetSize
;
}
}
return
;
}
Accessible
:
:
GetPositionAndSetSize
(
aPosInSet
aSetSize
)
;
}
bool
RemoteAccessible
:
:
HasPrimaryAction
(
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Actions
)
)
{
return
false
;
}
return
mCachedFields
&
&
mCachedFields
-
>
HasAttribute
(
CacheKey
:
:
PrimaryAction
)
;
}
void
RemoteAccessible
:
:
TakeFocus
(
)
const
{
Unused
<
<
mDoc
-
>
SendTakeFocus
(
mID
)
;
auto
*
bp
=
static_cast
<
dom
:
:
BrowserParent
*
>
(
mDoc
-
>
Manager
(
)
)
;
MOZ_ASSERT
(
bp
)
;
if
(
nsFocusManager
:
:
GetFocusedElementStatic
(
)
=
=
bp
-
>
GetOwnerElement
(
)
)
{
return
;
}
DocAccessibleParent
*
embeddedDoc
=
mDoc
;
Accessible
*
embedder
=
mDoc
-
>
Parent
(
)
;
while
(
embedder
)
{
MOZ_ASSERT
(
embedder
-
>
IsOuterDoc
(
)
)
;
RemoteAccessible
*
embedderRemote
=
embedder
-
>
AsRemote
(
)
;
if
(
!
embedderRemote
)
{
embedder
-
>
TakeFocus
(
)
;
break
;
}
if
(
embeddedDoc
-
>
IsTopLevelInContentProcess
(
)
)
{
Unused
<
<
embedderRemote
-
>
mDoc
-
>
SendTakeFocus
(
embedderRemote
-
>
mID
)
;
}
embeddedDoc
=
embedderRemote
-
>
mDoc
;
embedder
=
embeddedDoc
-
>
Parent
(
)
;
}
}
void
RemoteAccessible
:
:
ScrollTo
(
uint32_t
aHow
)
const
{
Unused
<
<
mDoc
-
>
SendScrollTo
(
mID
aHow
)
;
}
void
RemoteAccessible
:
:
SelectedItems
(
nsTArray
<
Accessible
*
>
*
aItems
)
{
if
(
RequestDomainsIfInactive
(
kNecessaryStateDomains
)
)
{
return
;
}
Pivot
p
=
Pivot
(
this
)
;
PivotStateRule
rule
(
states
:
:
SELECTED
)
;
for
(
Accessible
*
selected
=
p
.
First
(
rule
)
;
selected
;
selected
=
p
.
Next
(
selected
rule
)
)
{
aItems
-
>
AppendElement
(
selected
)
;
}
}
uint32_t
RemoteAccessible
:
:
SelectedItemCount
(
)
{
if
(
RequestDomainsIfInactive
(
kNecessaryStateDomains
)
)
{
return
0
;
}
uint32_t
count
=
0
;
Pivot
p
=
Pivot
(
this
)
;
PivotStateRule
rule
(
states
:
:
SELECTED
)
;
for
(
Accessible
*
selected
=
p
.
First
(
rule
)
;
selected
;
selected
=
p
.
Next
(
selected
rule
)
)
{
count
+
+
;
}
return
count
;
}
Accessible
*
RemoteAccessible
:
:
GetSelectedItem
(
uint32_t
aIndex
)
{
if
(
RequestDomainsIfInactive
(
kNecessaryStateDomains
)
)
{
return
nullptr
;
}
uint32_t
index
=
0
;
Accessible
*
selected
=
nullptr
;
Pivot
p
=
Pivot
(
this
)
;
PivotStateRule
rule
(
states
:
:
SELECTED
)
;
for
(
selected
=
p
.
First
(
rule
)
;
selected
&
&
index
<
aIndex
;
selected
=
p
.
Next
(
selected
rule
)
)
{
index
+
+
;
}
return
selected
;
}
bool
RemoteAccessible
:
:
IsItemSelected
(
uint32_t
aIndex
)
{
if
(
RequestDomainsIfInactive
(
kNecessaryStateDomains
)
)
{
return
false
;
}
uint32_t
index
=
0
;
Accessible
*
selectable
=
nullptr
;
Pivot
p
=
Pivot
(
this
)
;
PivotStateRule
rule
(
states
:
:
SELECTABLE
)
;
for
(
selectable
=
p
.
First
(
rule
)
;
selectable
&
&
index
<
aIndex
;
selectable
=
p
.
Next
(
selectable
rule
)
)
{
index
+
+
;
}
return
selectable
&
&
selectable
-
>
State
(
)
&
states
:
:
SELECTED
;
}
bool
RemoteAccessible
:
:
AddItemToSelection
(
uint32_t
aIndex
)
{
if
(
RequestDomainsIfInactive
(
kNecessaryStateDomains
)
)
{
return
false
;
}
uint32_t
index
=
0
;
Accessible
*
selectable
=
nullptr
;
Pivot
p
=
Pivot
(
this
)
;
PivotStateRule
rule
(
states
:
:
SELECTABLE
)
;
for
(
selectable
=
p
.
First
(
rule
)
;
selectable
&
&
index
<
aIndex
;
selectable
=
p
.
Next
(
selectable
rule
)
)
{
index
+
+
;
}
if
(
selectable
)
selectable
-
>
SetSelected
(
true
)
;
return
static_cast
<
bool
>
(
selectable
)
;
}
bool
RemoteAccessible
:
:
RemoveItemFromSelection
(
uint32_t
aIndex
)
{
if
(
RequestDomainsIfInactive
(
kNecessaryStateDomains
)
)
{
return
false
;
}
uint32_t
index
=
0
;
Accessible
*
selectable
=
nullptr
;
Pivot
p
=
Pivot
(
this
)
;
PivotStateRule
rule
(
states
:
:
SELECTABLE
)
;
for
(
selectable
=
p
.
First
(
rule
)
;
selectable
&
&
index
<
aIndex
;
selectable
=
p
.
Next
(
selectable
rule
)
)
{
index
+
+
;
}
if
(
selectable
)
selectable
-
>
SetSelected
(
false
)
;
return
static_cast
<
bool
>
(
selectable
)
;
}
bool
RemoteAccessible
:
:
SelectAll
(
)
{
if
(
RequestDomainsIfInactive
(
kNecessaryStateDomains
)
)
{
return
false
;
}
if
(
(
State
(
)
&
states
:
:
MULTISELECTABLE
)
=
=
0
)
{
return
false
;
}
bool
success
=
false
;
Accessible
*
selectable
=
nullptr
;
Pivot
p
=
Pivot
(
this
)
;
PivotStateRule
rule
(
states
:
:
SELECTABLE
)
;
for
(
selectable
=
p
.
First
(
rule
)
;
selectable
;
selectable
=
p
.
Next
(
selectable
rule
)
)
{
success
=
true
;
selectable
-
>
SetSelected
(
true
)
;
}
return
success
;
}
bool
RemoteAccessible
:
:
UnselectAll
(
)
{
if
(
RequestDomainsIfInactive
(
kNecessaryStateDomains
)
)
{
return
false
;
}
if
(
(
State
(
)
&
states
:
:
MULTISELECTABLE
)
=
=
0
)
{
return
false
;
}
bool
success
=
false
;
Accessible
*
selectable
=
nullptr
;
Pivot
p
=
Pivot
(
this
)
;
PivotStateRule
rule
(
states
:
:
SELECTABLE
)
;
for
(
selectable
=
p
.
First
(
rule
)
;
selectable
;
selectable
=
p
.
Next
(
selectable
rule
)
)
{
success
=
true
;
selectable
-
>
SetSelected
(
false
)
;
}
return
success
;
}
void
RemoteAccessible
:
:
TakeSelection
(
)
{
Unused
<
<
mDoc
-
>
SendTakeSelection
(
mID
)
;
}
void
RemoteAccessible
:
:
SetSelected
(
bool
aSelect
)
{
Unused
<
<
mDoc
-
>
SendSetSelected
(
mID
aSelect
)
;
}
TableAccessible
*
RemoteAccessible
:
:
AsTable
(
)
{
if
(
IsTable
(
)
)
{
return
CachedTableAccessible
:
:
GetFrom
(
this
)
;
}
return
nullptr
;
}
TableCellAccessible
*
RemoteAccessible
:
:
AsTableCell
(
)
{
if
(
IsTableCell
(
)
)
{
return
CachedTableCellAccessible
:
:
GetFrom
(
this
)
;
}
return
nullptr
;
}
bool
RemoteAccessible
:
:
TableIsProbablyForLayout
(
)
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Table
)
)
{
return
false
;
}
if
(
mCachedFields
)
{
if
(
auto
layoutGuess
=
mCachedFields
-
>
GetAttribute
<
bool
>
(
CacheKey
:
:
TableLayoutGuess
)
)
{
return
*
layoutGuess
;
}
}
return
false
;
}
nsTArray
<
int32_t
>
&
RemoteAccessible
:
:
GetCachedHyperTextOffsets
(
)
{
if
(
mCachedFields
)
{
if
(
auto
offsets
=
mCachedFields
-
>
GetMutableAttribute
<
nsTArray
<
int32_t
>
>
(
CacheKey
:
:
HyperTextOffsets
)
)
{
return
*
offsets
;
}
}
nsTArray
<
int32_t
>
newOffsets
;
if
(
!
mCachedFields
)
{
mCachedFields
=
new
AccAttributes
(
)
;
}
mCachedFields
-
>
SetAttribute
(
CacheKey
:
:
HyperTextOffsets
std
:
:
move
(
newOffsets
)
)
;
return
*
mCachedFields
-
>
GetMutableAttribute
<
nsTArray
<
int32_t
>
>
(
CacheKey
:
:
HyperTextOffsets
)
;
}
void
RemoteAccessible
:
:
SetCaretOffset
(
int32_t
aOffset
)
{
Unused
<
<
mDoc
-
>
SendSetCaretOffset
(
mID
aOffset
)
;
}
Maybe
<
int32_t
>
RemoteAccessible
:
:
GetIntARIAAttr
(
nsAtom
*
aAttrName
)
const
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
ARIA
)
)
{
return
Nothing
(
)
;
}
if
(
RefPtr
<
const
AccAttributes
>
attrs
=
GetCachedARIAAttributes
(
)
)
{
if
(
auto
val
=
attrs
-
>
GetAttribute
<
int32_t
>
(
aAttrName
)
)
{
return
val
;
}
}
return
Nothing
(
)
;
}
void
RemoteAccessible
:
:
Language
(
nsAString
&
aLocale
)
{
if
(
RequestDomainsIfInactive
(
CacheDomain
:
:
Text
)
)
{
return
;
}
if
(
IsHyperText
(
)
|
|
IsText
(
)
)
{
if
(
auto
attrs
=
GetCachedTextAttributes
(
)
)
{
attrs
-
>
GetAttribute
(
nsGkAtoms
:
:
language
aLocale
)
;
}
if
(
IsText
(
)
&
&
aLocale
.
IsEmpty
(
)
)
{
if
(
RemoteAccessible
*
parent
=
RemoteParent
(
)
)
{
if
(
auto
attrs
=
parent
-
>
GetCachedTextAttributes
(
)
)
{
attrs
-
>
GetAttribute
(
nsGkAtoms
:
:
language
aLocale
)
;
}
}
}
}
else
if
(
mCachedFields
)
{
mCachedFields
-
>
GetAttribute
(
CacheKey
:
:
Language
aLocale
)
;
}
}
void
RemoteAccessible
:
:
ReplaceText
(
const
nsAString
&
aText
)
{
Unused
<
<
mDoc
-
>
SendReplaceText
(
mID
aText
)
;
}
void
RemoteAccessible
:
:
InsertText
(
const
nsAString
&
aText
int32_t
aPosition
)
{
Unused
<
<
mDoc
-
>
SendInsertText
(
mID
aText
aPosition
)
;
}
void
RemoteAccessible
:
:
CopyText
(
int32_t
aStartPos
int32_t
aEndPos
)
{
Unused
<
<
mDoc
-
>
SendCopyText
(
mID
aStartPos
aEndPos
)
;
}
void
RemoteAccessible
:
:
CutText
(
int32_t
aStartPos
int32_t
aEndPos
)
{
Unused
<
<
mDoc
-
>
SendCutText
(
mID
aStartPos
aEndPos
)
;
}
void
RemoteAccessible
:
:
DeleteText
(
int32_t
aStartPos
int32_t
aEndPos
)
{
Unused
<
<
mDoc
-
>
SendDeleteText
(
mID
aStartPos
aEndPos
)
;
}
void
RemoteAccessible
:
:
PasteText
(
int32_t
aPosition
)
{
Unused
<
<
mDoc
-
>
SendPasteText
(
mID
aPosition
)
;
}
size_t
RemoteAccessible
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
RemoteAccessible
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
size_t
size
=
0
;
if
(
mCachedFields
)
{
size
+
=
mCachedFields
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
size
+
=
mChildren
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
size
;
}
}
}
