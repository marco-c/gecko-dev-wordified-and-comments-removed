#
ifndef
mozilla_a11y_RemoteAccessibleBase_h
#
define
mozilla_a11y_RemoteAccessibleBase_h
#
include
"
mozilla
/
a11y
/
Accessible
.
h
"
#
include
"
mozilla
/
a11y
/
CacheConstants
.
h
"
#
include
"
mozilla
/
a11y
/
HyperTextAccessibleBase
.
h
"
#
include
"
mozilla
/
a11y
/
Role
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
AccAttributes
.
h
"
#
include
"
nsIAccessibleText
.
h
"
#
include
"
nsIAccessibleTypes
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
LocalAccessible
.
h
"
namespace
mozilla
{
namespace
a11y
{
class
Attribute
;
class
DocAccessibleParent
;
class
RemoteAccessible
;
enum
class
RelationType
;
template
<
class
Derived
>
#
ifdef
XP_WIN
class
RemoteAccessibleBase
:
public
Accessible
public
HyperTextAccessibleBase
public
SupportsWeakPtr
{
#
else
class
RemoteAccessibleBase
:
public
Accessible
public
HyperTextAccessibleBase
{
#
endif
public
:
virtual
~
RemoteAccessibleBase
(
)
{
MOZ_ASSERT
(
!
mWrapper
)
;
}
virtual
bool
IsRemote
(
)
const
override
{
return
true
;
}
void
AddChildAt
(
uint32_t
aIdx
Derived
*
aChild
)
{
mChildren
.
InsertElementAt
(
aIdx
aChild
)
;
if
(
IsHyperText
(
)
)
{
InvalidateCachedHyperTextOffsets
(
)
;
}
}
virtual
uint32_t
ChildCount
(
)
const
override
{
return
mChildren
.
Length
(
)
;
}
Derived
*
RemoteChildAt
(
uint32_t
aIdx
)
const
{
return
mChildren
.
SafeElementAt
(
aIdx
)
;
}
Derived
*
RemoteFirstChild
(
)
const
{
return
mChildren
.
Length
(
)
?
mChildren
[
0
]
:
nullptr
;
}
Derived
*
RemoteLastChild
(
)
const
{
return
mChildren
.
Length
(
)
?
mChildren
[
mChildren
.
Length
(
)
-
1
]
:
nullptr
;
}
Derived
*
RemotePrevSibling
(
)
const
{
if
(
IsDoc
(
)
)
{
return
nullptr
;
}
int32_t
idx
=
IndexInParent
(
)
;
if
(
idx
=
=
-
1
)
{
return
nullptr
;
}
return
idx
>
0
?
RemoteParent
(
)
-
>
mChildren
[
idx
-
1
]
:
nullptr
;
}
Derived
*
RemoteNextSibling
(
)
const
{
if
(
IsDoc
(
)
)
{
return
nullptr
;
}
int32_t
idx
=
IndexInParent
(
)
;
if
(
idx
=
=
-
1
)
{
return
nullptr
;
}
MOZ_ASSERT
(
idx
>
=
0
)
;
size_t
newIdx
=
idx
+
1
;
return
newIdx
<
RemoteParent
(
)
-
>
mChildren
.
Length
(
)
?
RemoteParent
(
)
-
>
mChildren
[
newIdx
]
:
nullptr
;
}
virtual
Accessible
*
Parent
(
)
const
override
{
return
RemoteParent
(
)
;
}
virtual
Accessible
*
ChildAt
(
uint32_t
aIndex
)
const
override
{
return
RemoteChildAt
(
aIndex
)
;
}
virtual
Accessible
*
NextSibling
(
)
const
override
{
return
RemoteNextSibling
(
)
;
}
virtual
Accessible
*
PrevSibling
(
)
const
override
{
return
RemotePrevSibling
(
)
;
}
virtual
int32_t
IndexInParent
(
)
const
override
{
Derived
*
parent
=
RemoteParent
(
)
;
if
(
!
parent
)
{
return
-
1
;
}
return
parent
-
>
mChildren
.
IndexOf
(
static_cast
<
const
Derived
*
>
(
this
)
)
;
}
virtual
uint32_t
EmbeddedChildCount
(
)
override
;
virtual
int32_t
IndexOfEmbeddedChild
(
Accessible
*
aChild
)
override
;
virtual
Accessible
*
EmbeddedChildAt
(
uint32_t
aChildIdx
)
override
;
void
Shutdown
(
)
;
void
SetChildDoc
(
DocAccessibleParent
*
aChildDoc
)
;
void
ClearChildDoc
(
DocAccessibleParent
*
aChildDoc
)
;
void
RemoveChild
(
Derived
*
aChild
)
{
mChildren
.
RemoveElement
(
aChild
)
;
if
(
IsHyperText
(
)
)
{
InvalidateCachedHyperTextOffsets
(
)
;
}
}
Derived
*
RemoteParent
(
)
const
;
LocalAccessible
*
OuterDocOfRemoteBrowser
(
)
const
;
virtual
role
Role
(
)
const
override
{
return
mRole
;
}
bool
IsEmbeddedObject
(
)
const
{
return
!
IsText
(
)
;
}
virtual
bool
IsLink
(
)
const
override
{
if
(
IsHTMLLink
(
)
)
{
return
true
;
}
if
(
IsText
(
)
)
{
return
false
;
}
if
(
Accessible
*
parent
=
Parent
(
)
)
{
return
parent
-
>
IsHyperText
(
)
;
}
return
false
;
}
virtual
bool
HasNumericValue
(
)
const
override
{
return
HasGenericType
(
eNumericValue
)
;
}
virtual
ENameValueFlag
Name
(
nsString
&
aName
)
const
override
;
virtual
void
Description
(
nsString
&
aDescription
)
const
override
;
virtual
void
Value
(
nsString
&
aValue
)
const
override
;
virtual
double
CurValue
(
)
const
override
;
virtual
double
MinValue
(
)
const
override
;
virtual
double
MaxValue
(
)
const
override
;
virtual
double
Step
(
)
const
override
;
virtual
Accessible
*
ChildAtPoint
(
int32_t
aX
int32_t
aY
LocalAccessible
:
:
EWhichChildAtPoint
aWhichChild
)
override
;
virtual
LayoutDeviceIntRect
Bounds
(
)
const
override
;
virtual
nsRect
BoundsInAppUnits
(
)
const
override
;
virtual
Relation
RelationByType
(
RelationType
aType
)
const
override
;
virtual
uint64_t
State
(
)
override
;
virtual
already_AddRefed
<
AccAttributes
>
Attributes
(
)
override
;
virtual
nsAtom
*
TagName
(
)
const
override
;
virtual
nsAtom
*
InputType
(
)
const
override
;
virtual
already_AddRefed
<
nsAtom
>
DisplayStyle
(
)
const
override
;
virtual
float
Opacity
(
)
const
override
;
virtual
void
LiveRegionAttributes
(
nsAString
*
aLive
nsAString
*
aRelevant
Maybe
<
bool
>
*
aAtomic
nsAString
*
aBusy
)
const
override
;
virtual
Maybe
<
bool
>
ARIASelected
(
)
const
override
;
virtual
uint8_t
ActionCount
(
)
const
override
;
virtual
void
ActionNameAt
(
uint8_t
aIndex
nsAString
&
aName
)
override
;
virtual
bool
DoAction
(
uint8_t
aIndex
)
const
override
;
virtual
KeyBinding
AccessKey
(
)
const
override
;
virtual
void
SelectionRanges
(
nsTArray
<
TextRange
>
*
aRanges
)
const
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
bool
RemoveFromSelection
(
int32_t
aSelectionNum
)
override
;
virtual
Maybe
<
int32_t
>
GetIntARIAAttr
(
nsAtom
*
aAttrName
)
const
override
;
virtual
void
Language
(
nsAString
&
aLocale
)
override
;
virtual
void
SelectedItems
(
nsTArray
<
Accessible
*
>
*
aItems
)
override
;
virtual
uint32_t
SelectedItemCount
(
)
override
;
virtual
Accessible
*
GetSelectedItem
(
uint32_t
aIndex
)
override
;
virtual
bool
IsItemSelected
(
uint32_t
aIndex
)
override
;
virtual
bool
AddItemToSelection
(
uint32_t
aIndex
)
override
;
virtual
bool
RemoveItemFromSelection
(
uint32_t
aIndex
)
override
;
virtual
bool
SelectAll
(
)
override
;
virtual
bool
UnselectAll
(
)
override
;
virtual
void
TakeSelection
(
)
override
;
virtual
void
SetSelected
(
bool
aSelect
)
override
;
virtual
void
TakeFocus
(
)
const
override
;
virtual
void
ScrollTo
(
uint32_t
aHow
)
const
override
;
virtual
void
SetCaretOffset
(
int32_t
aOffset
)
override
;
uintptr_t
GetWrapper
(
)
const
{
return
mWrapper
;
}
void
SetWrapper
(
uintptr_t
aWrapper
)
{
mWrapper
=
aWrapper
;
}
virtual
uint64_t
ID
(
)
const
override
{
return
mID
;
}
DocAccessibleParent
*
Document
(
)
const
{
return
mDoc
;
}
DocAccessibleParent
*
AsDoc
(
)
const
{
return
IsDoc
(
)
?
mDoc
:
nullptr
;
}
void
ApplyCache
(
CacheUpdateType
aUpdateType
AccAttributes
*
aFields
)
{
const
nsTArray
<
bool
>
relUpdatesNeeded
=
PreProcessRelations
(
aFields
)
;
if
(
auto
maybeViewportCache
=
aFields
-
>
GetAttribute
<
nsTArray
<
uint64_t
>
>
(
nsGkAtoms
:
:
viewport
)
)
{
MOZ_ASSERT
(
IsDoc
(
)
"
Fetched
the
viewport
cache
from
a
non
-
doc
accessible
?
"
)
;
AsDoc
(
)
-
>
mOnScreenAccessibles
.
Clear
(
)
;
for
(
auto
id
:
*
maybeViewportCache
)
{
AsDoc
(
)
-
>
mOnScreenAccessibles
.
Insert
(
id
)
;
}
}
if
(
aUpdateType
=
=
CacheUpdateType
:
:
Initial
)
{
mCachedFields
=
aFields
;
}
else
{
if
(
!
mCachedFields
)
{
mCachedFields
=
new
AccAttributes
(
)
;
}
mCachedFields
-
>
Update
(
aFields
)
;
}
if
(
IsTextLeaf
(
)
)
{
Derived
*
parent
=
RemoteParent
(
)
;
if
(
parent
&
&
parent
-
>
IsHyperText
(
)
)
{
parent
-
>
InvalidateCachedHyperTextOffsets
(
)
;
}
}
PostProcessRelations
(
relUpdatesNeeded
)
;
}
void
UpdateStateCache
(
uint64_t
aState
bool
aEnabled
)
{
if
(
aState
&
kRemoteCalculatedStates
)
{
return
;
}
uint64_t
state
=
0
;
if
(
mCachedFields
)
{
if
(
auto
oldState
=
mCachedFields
-
>
GetAttribute
<
uint64_t
>
(
nsGkAtoms
:
:
state
)
)
{
state
=
*
oldState
;
}
}
else
{
mCachedFields
=
new
AccAttributes
(
)
;
}
if
(
aEnabled
)
{
state
|
=
aState
;
}
else
{
state
&
=
~
aState
;
}
mCachedFields
-
>
SetAttribute
(
nsGkAtoms
:
:
state
state
)
;
}
void
InvalidateGroupInfo
(
)
;
virtual
void
AppendTextTo
(
nsAString
&
aText
uint32_t
aStartOffset
=
0
uint32_t
aLength
=
UINT32_MAX
)
override
;
virtual
bool
TableIsProbablyForLayout
(
)
;
nsTArray
<
bool
>
PreProcessRelations
(
AccAttributes
*
aFields
)
;
void
PostProcessRelations
(
const
nsTArray
<
bool
>
&
aToUpdate
)
;
void
PruneRelationsOnShutdown
(
)
;
uint32_t
GetCachedTextLength
(
)
;
Maybe
<
const
nsTArray
<
int32_t
>
&
>
GetCachedTextLines
(
)
;
nsRect
GetCachedCharRect
(
int32_t
aOffset
)
;
RefPtr
<
const
AccAttributes
>
GetCachedTextAttributes
(
)
;
RefPtr
<
const
AccAttributes
>
GetCachedARIAAttributes
(
)
const
;
nsString
GetCachedHTMLNameAttribute
(
)
const
;
virtual
HyperTextAccessibleBase
*
AsHyperTextBase
(
)
override
{
return
IsHyperText
(
)
?
static_cast
<
HyperTextAccessibleBase
*
>
(
this
)
:
nullptr
;
}
virtual
TableAccessibleBase
*
AsTableBase
(
)
override
;
virtual
TableCellAccessibleBase
*
AsTableCellBase
(
)
override
;
virtual
void
DOMNodeID
(
nsString
&
aID
)
const
override
;
virtual
already_AddRefed
<
AccAttributes
>
DefaultTextAttributes
(
)
override
;
void
InvalidateCachedHyperTextOffsets
(
)
{
if
(
mCachedFields
)
{
mCachedFields
-
>
Remove
(
nsGkAtoms
:
:
offset
)
;
}
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
;
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
;
protected
:
RemoteAccessibleBase
(
uint64_t
aID
Derived
*
aParent
DocAccessibleParent
*
aDoc
role
aRole
AccType
aType
AccGenericType
aGenericTypes
uint8_t
aRoleMapEntryIndex
)
:
Accessible
(
aType
aGenericTypes
aRoleMapEntryIndex
)
mParent
(
aParent
-
>
ID
(
)
)
mDoc
(
aDoc
)
mWrapper
(
0
)
mID
(
aID
)
mCachedFields
(
nullptr
)
mRole
(
aRole
)
{
}
explicit
RemoteAccessibleBase
(
DocAccessibleParent
*
aThisAsDoc
)
:
Accessible
(
)
mParent
(
kNoParent
)
mDoc
(
aThisAsDoc
)
mWrapper
(
0
)
mID
(
0
)
mCachedFields
(
nullptr
)
mRole
(
roles
:
:
DOCUMENT
)
{
mGenericTypes
=
eDocument
|
eHyperText
;
}
protected
:
void
SetParent
(
Derived
*
aParent
)
;
Maybe
<
nsRect
>
RetrieveCachedBounds
(
)
const
;
bool
ApplyTransform
(
nsRect
&
aCumulativeBounds
)
const
;
bool
ApplyScrollOffset
(
nsRect
&
aBounds
)
const
;
void
ApplyCrossDocOffset
(
nsRect
&
aBounds
)
const
;
LayoutDeviceIntRect
BoundsWithOffset
(
Maybe
<
nsRect
>
aOffset
bool
aBoundsAreForHittesting
=
false
)
const
;
bool
IsFixedPos
(
)
const
;
bool
ContainsPoint
(
int32_t
aX
int32_t
aY
)
;
virtual
void
ARIAGroupPosition
(
int32_t
*
aLevel
int32_t
*
aSetSize
int32_t
*
aPosInSet
)
const
override
;
virtual
AccGroupInfo
*
GetGroupInfo
(
)
const
override
;
virtual
AccGroupInfo
*
GetOrCreateGroupInfo
(
)
override
;
virtual
void
GetPositionAndSetSize
(
int32_t
*
aPosInSet
int32_t
*
aSetSize
)
override
;
virtual
bool
HasPrimaryAction
(
)
const
override
;
nsAtom
*
GetPrimaryAction
(
)
const
;
virtual
nsTArray
<
int32_t
>
&
GetCachedHyperTextOffsets
(
)
override
;
private
:
uintptr_t
mParent
;
static
const
uintptr_t
kNoParent
=
UINTPTR_MAX
;
friend
Derived
;
friend
DocAccessibleParent
;
friend
TextLeafPoint
;
friend
HyperTextAccessibleBase
;
friend
class
xpcAccessible
;
friend
class
CachedTableCellAccessible
;
#
ifdef
XP_WIN
friend
class
sdnAccessible
;
#
endif
nsTArray
<
Derived
*
>
mChildren
;
DocAccessibleParent
*
mDoc
;
uintptr_t
mWrapper
;
uint64_t
mID
;
protected
:
virtual
const
Accessible
*
Acc
(
)
const
override
{
return
this
;
}
RefPtr
<
AccAttributes
>
mCachedFields
;
role
mRole
:
27
;
}
;
extern
template
class
RemoteAccessibleBase
<
RemoteAccessible
>
;
}
}
#
endif
