#
ifndef
mozilla_a11y_RemoteAccessibleBase_h
#
define
mozilla_a11y_RemoteAccessibleBase_h
#
include
"
mozilla
/
a11y
/
Accessible
.
h
"
#
include
"
mozilla
/
a11y
/
CacheConstants
.
h
"
#
include
"
mozilla
/
a11y
/
HyperTextAccessibleBase
.
h
"
#
include
"
mozilla
/
a11y
/
Role
.
h
"
#
include
"
AccAttributes
.
h
"
#
include
"
nsIAccessibleText
.
h
"
#
include
"
nsIAccessibleTypes
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
LocalAccessible
.
h
"
namespace
mozilla
{
namespace
a11y
{
class
Attribute
;
class
DocAccessibleParent
;
class
RemoteAccessible
;
enum
class
RelationType
;
template
<
class
Derived
>
class
RemoteAccessibleBase
:
public
Accessible
public
HyperTextAccessibleBase
{
public
:
virtual
~
RemoteAccessibleBase
(
)
{
MOZ_ASSERT
(
!
mWrapper
)
;
}
virtual
bool
IsRemote
(
)
const
override
{
return
true
;
}
void
AddChildAt
(
uint32_t
aIdx
Derived
*
aChild
)
{
mChildren
.
InsertElementAt
(
aIdx
aChild
)
;
}
virtual
uint32_t
ChildCount
(
)
const
override
{
return
mChildren
.
Length
(
)
;
}
Derived
*
RemoteChildAt
(
uint32_t
aIdx
)
const
{
return
mChildren
.
SafeElementAt
(
aIdx
)
;
}
Derived
*
RemoteFirstChild
(
)
const
{
return
mChildren
.
Length
(
)
?
mChildren
[
0
]
:
nullptr
;
}
Derived
*
RemoteLastChild
(
)
const
{
return
mChildren
.
Length
(
)
?
mChildren
[
mChildren
.
Length
(
)
-
1
]
:
nullptr
;
}
Derived
*
RemotePrevSibling
(
)
const
{
if
(
IsDoc
(
)
)
{
return
nullptr
;
}
int32_t
idx
=
IndexInParent
(
)
;
if
(
idx
=
=
-
1
)
{
return
nullptr
;
}
return
idx
>
0
?
RemoteParent
(
)
-
>
mChildren
[
idx
-
1
]
:
nullptr
;
}
Derived
*
RemoteNextSibling
(
)
const
{
if
(
IsDoc
(
)
)
{
return
nullptr
;
}
int32_t
idx
=
IndexInParent
(
)
;
if
(
idx
=
=
-
1
)
{
return
nullptr
;
}
MOZ_ASSERT
(
idx
>
=
0
)
;
size_t
newIdx
=
idx
+
1
;
return
newIdx
<
RemoteParent
(
)
-
>
mChildren
.
Length
(
)
?
RemoteParent
(
)
-
>
mChildren
[
newIdx
]
:
nullptr
;
}
virtual
Accessible
*
Parent
(
)
const
override
{
if
(
Derived
*
parent
=
RemoteParent
(
)
)
{
return
parent
;
}
return
OuterDocOfRemoteBrowser
(
)
;
}
virtual
Accessible
*
ChildAt
(
uint32_t
aIndex
)
const
override
{
return
RemoteChildAt
(
aIndex
)
;
}
virtual
Accessible
*
NextSibling
(
)
const
override
{
return
RemoteNextSibling
(
)
;
}
virtual
Accessible
*
PrevSibling
(
)
const
override
{
return
RemotePrevSibling
(
)
;
}
virtual
int32_t
IndexInParent
(
)
const
override
{
Derived
*
parent
=
RemoteParent
(
)
;
if
(
!
parent
)
{
return
-
1
;
}
return
parent
-
>
mChildren
.
IndexOf
(
static_cast
<
const
Derived
*
>
(
this
)
)
;
}
uint32_t
EmbeddedChildCount
(
)
const
;
int32_t
IndexOfEmbeddedChild
(
const
Derived
*
aChild
)
;
Derived
*
EmbeddedChildAt
(
size_t
aChildIdx
)
;
void
Shutdown
(
)
;
void
SetChildDoc
(
DocAccessibleParent
*
aChildDoc
)
;
void
ClearChildDoc
(
DocAccessibleParent
*
aChildDoc
)
;
void
RemoveChild
(
Derived
*
aChild
)
{
mChildren
.
RemoveElement
(
aChild
)
;
}
Derived
*
RemoteParent
(
)
const
;
LocalAccessible
*
OuterDocOfRemoteBrowser
(
)
const
;
virtual
role
Role
(
)
const
override
{
return
mRole
;
}
bool
IsEmbeddedObject
(
)
const
{
role
role
=
Role
(
)
;
return
role
!
=
roles
:
:
TEXT_LEAF
&
&
role
!
=
roles
:
:
WHITESPACE
&
&
role
!
=
roles
:
:
STATICTEXT
;
}
virtual
bool
IsLink
(
)
const
override
{
if
(
IsHTMLLink
(
)
)
{
return
true
;
}
if
(
IsText
(
)
)
{
return
false
;
}
if
(
Accessible
*
parent
=
Parent
(
)
)
{
return
parent
-
>
IsHyperText
(
)
;
}
return
false
;
}
virtual
bool
HasNumericValue
(
)
const
override
{
return
HasGenericType
(
eNumericValue
)
;
}
virtual
ENameValueFlag
Name
(
nsString
&
aName
)
const
override
;
virtual
void
Description
(
nsString
&
aDescription
)
const
override
;
virtual
double
CurValue
(
)
const
override
;
virtual
double
MinValue
(
)
const
override
;
virtual
double
MaxValue
(
)
const
override
;
virtual
double
Step
(
)
const
override
;
virtual
nsIntRect
Bounds
(
)
const
override
;
uintptr_t
GetWrapper
(
)
const
{
return
mWrapper
;
}
void
SetWrapper
(
uintptr_t
aWrapper
)
{
mWrapper
=
aWrapper
;
}
uint64_t
ID
(
)
const
{
return
mID
;
}
DocAccessibleParent
*
Document
(
)
const
{
return
mDoc
;
}
DocAccessibleParent
*
AsDoc
(
)
const
{
return
IsDoc
(
)
?
mDoc
:
nullptr
;
}
void
ApplyCache
(
CacheUpdateType
aUpdateType
AccAttributes
*
aFields
)
{
if
(
aUpdateType
=
=
CacheUpdateType
:
:
Initial
)
{
mCachedFields
=
aFields
;
}
else
{
if
(
!
mCachedFields
)
{
mCachedFields
=
new
AccAttributes
(
)
;
}
mCachedFields
-
>
Update
(
aFields
)
;
}
}
virtual
void
AppendTextTo
(
nsAString
&
aText
uint32_t
aStartOffset
=
0
uint32_t
aLength
=
UINT32_MAX
)
override
;
uint32_t
GetCachedTextLength
(
)
;
Maybe
<
const
nsTArray
<
int32_t
>
&
>
GetCachedTextLines
(
)
;
virtual
HyperTextAccessibleBase
*
AsHyperTextBase
(
)
override
{
return
IsHyperText
(
)
?
static_cast
<
HyperTextAccessibleBase
*
>
(
this
)
:
nullptr
;
}
protected
:
RemoteAccessibleBase
(
uint64_t
aID
Derived
*
aParent
DocAccessibleParent
*
aDoc
role
aRole
AccType
aType
AccGenericType
aGenericTypes
uint8_t
aRoleMapEntryIndex
)
:
Accessible
(
aType
aGenericTypes
aRoleMapEntryIndex
)
mParent
(
aParent
-
>
ID
(
)
)
mDoc
(
aDoc
)
mWrapper
(
0
)
mID
(
aID
)
mCachedFields
(
nullptr
)
mRole
(
aRole
)
{
}
explicit
RemoteAccessibleBase
(
DocAccessibleParent
*
aThisAsDoc
)
:
Accessible
(
)
mParent
(
kNoParent
)
mDoc
(
aThisAsDoc
)
mWrapper
(
0
)
mID
(
0
)
mCachedFields
(
nullptr
)
mRole
(
roles
:
:
DOCUMENT
)
{
mGenericTypes
=
eDocument
|
eHyperText
;
}
protected
:
void
SetParent
(
Derived
*
aParent
)
;
Maybe
<
nsRect
>
RetrieveCachedBounds
(
)
const
;
private
:
uintptr_t
mParent
;
static
const
uintptr_t
kNoParent
=
UINTPTR_MAX
;
friend
Derived
;
nsTArray
<
Derived
*
>
mChildren
;
DocAccessibleParent
*
mDoc
;
uintptr_t
mWrapper
;
uint64_t
mID
;
protected
:
virtual
const
Accessible
*
Acc
(
)
const
override
{
return
this
;
}
RefPtr
<
AccAttributes
>
mCachedFields
;
role
mRole
:
27
;
}
;
extern
template
class
RemoteAccessibleBase
<
RemoteAccessible
>
;
}
}
#
endif
