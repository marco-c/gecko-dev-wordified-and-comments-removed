#
ifndef
mozilla_a11y_ProxyAccessibleBase_h
#
define
mozilla_a11y_ProxyAccessibleBase_h
#
include
"
mozilla
/
a11y
/
Role
.
h
"
#
include
"
nsIAccessibleText
.
h
"
#
include
"
nsIAccessibleTypes
.
h
"
#
include
"
LocalAccessible
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
LocalAccessible
.
h
"
namespace
mozilla
{
namespace
a11y
{
class
LocalAccessible
;
class
Attribute
;
class
DocAccessibleParent
;
class
ProxyAccessible
;
enum
class
RelationType
;
enum
Interfaces
{
HYPERTEXT
=
1
HYPERLINK
=
1
<
<
1
IMAGE
=
1
<
<
2
VALUE
=
1
<
<
3
TABLE
=
1
<
<
4
TABLECELL
=
1
<
<
5
DOCUMENT
=
1
<
<
6
SELECTION
=
1
<
<
7
ACTION
=
1
<
<
8
}
;
template
<
class
Derived
>
class
ProxyAccessibleBase
{
public
:
~
ProxyAccessibleBase
(
)
{
MOZ_ASSERT
(
!
mWrapper
)
;
}
void
AddChildAt
(
uint32_t
aIdx
Derived
*
aChild
)
{
mChildren
.
InsertElementAt
(
aIdx
aChild
)
;
}
uint32_t
ChildrenCount
(
)
const
{
return
mChildren
.
Length
(
)
;
}
Derived
*
RemoteChildAt
(
uint32_t
aIdx
)
const
{
return
mChildren
[
aIdx
]
;
}
Derived
*
RemoteFirstChild
(
)
const
{
return
mChildren
.
Length
(
)
?
mChildren
[
0
]
:
nullptr
;
}
Derived
*
RemoteLastChild
(
)
const
{
return
mChildren
.
Length
(
)
?
mChildren
[
mChildren
.
Length
(
)
-
1
]
:
nullptr
;
}
Derived
*
RemotePrevSibling
(
)
const
{
int32_t
idx
=
IndexInParent
(
)
;
if
(
idx
=
=
-
1
)
{
return
nullptr
;
}
return
idx
>
0
?
RemoteParent
(
)
-
>
mChildren
[
idx
-
1
]
:
nullptr
;
}
Derived
*
RemoteNextSibling
(
)
const
{
int32_t
idx
=
IndexInParent
(
)
;
if
(
idx
=
=
-
1
)
{
return
nullptr
;
}
MOZ_ASSERT
(
idx
>
=
0
)
;
size_t
newIdx
=
idx
+
1
;
return
newIdx
<
RemoteParent
(
)
-
>
mChildren
.
Length
(
)
?
RemoteParent
(
)
-
>
mChildren
[
newIdx
]
:
nullptr
;
}
int32_t
IndexInParent
(
)
const
{
Derived
*
parent
=
RemoteParent
(
)
;
if
(
!
parent
)
{
return
-
1
;
}
return
parent
-
>
mChildren
.
IndexOf
(
static_cast
<
const
Derived
*
>
(
this
)
)
;
}
uint32_t
EmbeddedChildCount
(
)
const
;
int32_t
IndexOfEmbeddedChild
(
const
Derived
*
aChild
)
;
Derived
*
EmbeddedChildAt
(
size_t
aChildIdx
)
;
void
Shutdown
(
)
;
void
SetChildDoc
(
DocAccessibleParent
*
aChildDoc
)
;
void
ClearChildDoc
(
DocAccessibleParent
*
aChildDoc
)
;
void
RemoveChild
(
Derived
*
aChild
)
{
mChildren
.
RemoveElement
(
aChild
)
;
}
Derived
*
RemoteParent
(
)
const
;
LocalAccessible
*
OuterDocOfRemoteBrowser
(
)
const
;
role
Role
(
)
const
{
return
mRole
;
}
bool
IsEmbeddedObject
(
)
const
{
role
role
=
Role
(
)
;
return
role
!
=
roles
:
:
TEXT_LEAF
&
&
role
!
=
roles
:
:
WHITESPACE
&
&
role
!
=
roles
:
:
STATICTEXT
;
}
uintptr_t
GetWrapper
(
)
const
{
return
mWrapper
;
}
void
SetWrapper
(
uintptr_t
aWrapper
)
{
mWrapper
=
aWrapper
;
}
uint64_t
ID
(
)
const
{
return
mID
;
}
DocAccessibleParent
*
Document
(
)
const
{
return
mDoc
;
}
bool
IsDoc
(
)
const
{
return
mIsDoc
;
}
DocAccessibleParent
*
AsDoc
(
)
const
{
return
IsDoc
(
)
?
mDoc
:
nullptr
;
}
inline
bool
IsTable
(
)
const
{
return
mRole
=
=
roles
:
:
TABLE
|
|
mRole
=
=
roles
:
:
MATHML_TABLE
;
}
inline
bool
IsTableRow
(
)
const
{
return
(
mRole
=
=
roles
:
:
ROW
|
|
mRole
=
=
roles
:
:
MATHML_TABLE_ROW
|
|
mRole
=
=
roles
:
:
MATHML_LABELED_ROW
)
;
}
inline
bool
IsTableCell
(
)
const
{
return
(
mRole
=
=
roles
:
:
CELL
|
|
mRole
=
=
roles
:
:
COLUMNHEADER
|
|
mRole
=
=
roles
:
:
ROWHEADER
|
|
mRole
=
=
roles
:
:
GRID_CELL
|
|
mRole
=
=
roles
:
:
MATHML_CELL
)
;
}
protected
:
ProxyAccessibleBase
(
uint64_t
aID
Derived
*
aParent
DocAccessibleParent
*
aDoc
role
aRole
uint32_t
aInterfaces
)
:
mParent
(
aParent
-
>
ID
(
)
)
mDoc
(
aDoc
)
mWrapper
(
0
)
mID
(
aID
)
mRole
(
aRole
)
mOuterDoc
(
false
)
mIsDoc
(
false
)
mHasValue
(
aInterfaces
&
Interfaces
:
:
VALUE
)
mIsHyperLink
(
aInterfaces
&
Interfaces
:
:
HYPERLINK
)
mIsHyperText
(
aInterfaces
&
Interfaces
:
:
HYPERTEXT
)
mIsSelection
(
aInterfaces
&
Interfaces
:
:
SELECTION
)
{
}
explicit
ProxyAccessibleBase
(
DocAccessibleParent
*
aThisAsDoc
)
:
mParent
(
kNoParent
)
mDoc
(
aThisAsDoc
)
mWrapper
(
0
)
mID
(
0
)
mRole
(
roles
:
:
DOCUMENT
)
mOuterDoc
(
false
)
mIsDoc
(
true
)
mHasValue
(
false
)
mIsHyperLink
(
false
)
mIsHyperText
(
false
)
mIsSelection
(
false
)
{
}
protected
:
void
SetParent
(
Derived
*
aParent
)
;
private
:
uintptr_t
mParent
;
static
const
uintptr_t
kNoParent
=
UINTPTR_MAX
;
friend
Derived
;
nsTArray
<
Derived
*
>
mChildren
;
DocAccessibleParent
*
mDoc
;
uintptr_t
mWrapper
;
uint64_t
mID
;
protected
:
role
mRole
:
27
;
private
:
bool
mOuterDoc
:
1
;
public
:
const
bool
mIsDoc
:
1
;
const
bool
mHasValue
:
1
;
const
bool
mIsHyperLink
:
1
;
const
bool
mIsHyperText
:
1
;
const
bool
mIsSelection
:
1
;
}
;
extern
template
class
ProxyAccessibleBase
<
ProxyAccessible
>
;
}
}
#
endif
