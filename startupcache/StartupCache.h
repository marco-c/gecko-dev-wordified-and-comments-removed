#
ifndef
StartupCache_h_
#
define
StartupCache_h_
#
include
<
utility
>
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsZipArchive
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AutoMemMap
.
h
"
#
include
"
mozilla
/
Compression
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Omnijar
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
namespace
mozilla
{
namespace
dom
{
class
ContentParent
;
}
namespace
ipc
{
class
GeckoChildProcessHost
;
}
namespace
scache
{
class
StartupCacheChild
;
#
ifdef
XP_UNIX
static
const
int
kStartupCacheFd
=
11
;
#
endif
static
const
int
kStartupCacheEntryNotRequested
=
INT_MAX
;
static
const
int
kStartupcacheEntryNotInSharedData
=
-
1
;
static
const
int
kStartupCacheKeyLengthCap
=
1024
;
class
MaybeOwnedCharPtr
{
private
:
char
*
mPtr
;
bool
mOwned
;
public
:
~
MaybeOwnedCharPtr
(
)
{
if
(
mOwned
)
{
delete
[
]
mPtr
;
}
}
MaybeOwnedCharPtr
(
MaybeOwnedCharPtr
&
&
other
)
:
mPtr
(
std
:
:
exchange
(
other
.
mPtr
nullptr
)
)
mOwned
(
std
:
:
exchange
(
other
.
mOwned
false
)
)
{
}
MaybeOwnedCharPtr
&
operator
=
(
MaybeOwnedCharPtr
&
&
other
)
{
std
:
:
swap
(
mPtr
other
.
mPtr
)
;
std
:
:
swap
(
mOwned
other
.
mOwned
)
;
return
*
this
;
}
MaybeOwnedCharPtr
&
operator
=
(
decltype
(
nullptr
)
)
{
if
(
mOwned
)
{
delete
[
]
mPtr
;
}
mPtr
=
nullptr
;
mOwned
=
false
;
return
*
this
;
}
operator
char
*
(
)
const
{
return
mPtr
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mPtr
;
}
char
*
get
(
)
const
{
return
mPtr
;
}
bool
IsOwned
(
)
const
{
return
mOwned
;
}
explicit
MaybeOwnedCharPtr
(
char
*
aBytes
)
:
mPtr
(
aBytes
)
mOwned
(
false
)
{
}
explicit
MaybeOwnedCharPtr
(
UniquePtr
<
char
[
]
>
&
&
aBytes
)
:
mPtr
(
aBytes
.
release
(
)
)
mOwned
(
true
)
{
}
explicit
MaybeOwnedCharPtr
(
size_t
size
)
:
mPtr
(
new
char
[
size
]
)
mOwned
(
true
)
{
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
if
(
!
mOwned
)
{
return
0
;
}
return
mallocSizeOf
(
mPtr
)
;
}
}
;
struct
StartupCacheKeyHasher
{
using
Key
=
MaybeOwnedCharPtr
;
using
Lookup
=
const
char
*
;
static
HashNumber
hash
(
const
Lookup
&
aLookup
)
{
return
HashString
(
aLookup
)
;
}
static
bool
match
(
const
Key
&
aKey
const
Lookup
&
aLookup
)
{
return
strcmp
(
aKey
.
get
(
)
aLookup
)
=
=
0
;
}
}
;
enum
class
StartupCacheEntryFlags
{
Shared
RequestedByChild
AddedThisSession
DoNotFree
}
;
struct
StartupCacheEntry
{
MaybeOwnedCharPtr
mData
;
uint32_t
mOffset
;
uint32_t
mCompressedSize
;
uint32_t
mUncompressedSize
;
int32_t
mSharedDataOffset
;
int32_t
mHeaderOffsetInFile
;
int32_t
mRequestedOrder
;
EnumSet
<
StartupCacheEntryFlags
>
mFlags
;
MOZ_IMPLICIT
StartupCacheEntry
(
uint32_t
aOffset
uint32_t
aCompressedSize
uint32_t
aUncompressedSize
EnumSet
<
StartupCacheEntryFlags
>
aFlags
)
:
mData
(
nullptr
)
mOffset
(
aOffset
)
mCompressedSize
(
aCompressedSize
)
mUncompressedSize
(
aUncompressedSize
)
mSharedDataOffset
(
kStartupcacheEntryNotInSharedData
)
mHeaderOffsetInFile
(
0
)
mRequestedOrder
(
kStartupCacheEntryNotRequested
)
mFlags
(
aFlags
)
{
}
StartupCacheEntry
(
UniquePtr
<
char
[
]
>
aData
size_t
aLength
int32_t
aRequestedOrder
EnumSet
<
StartupCacheEntryFlags
>
aFlags
)
:
mData
(
std
:
:
move
(
aData
)
)
mOffset
(
0
)
mCompressedSize
(
0
)
mUncompressedSize
(
aLength
)
mSharedDataOffset
(
kStartupcacheEntryNotInSharedData
)
mHeaderOffsetInFile
(
0
)
mRequestedOrder
(
aRequestedOrder
)
mFlags
(
aFlags
)
{
}
struct
Comparator
{
using
Value
=
std
:
:
pair
<
const
MaybeOwnedCharPtr
*
StartupCacheEntry
*
>
;
bool
Equals
(
const
Value
&
a
const
Value
&
b
)
const
{
return
a
.
second
-
>
mFlags
.
contains
(
StartupCacheEntryFlags
:
:
RequestedByChild
)
=
=
b
.
second
-
>
mFlags
.
contains
(
StartupCacheEntryFlags
:
:
RequestedByChild
)
&
&
a
.
second
-
>
mRequestedOrder
=
=
b
.
second
-
>
mRequestedOrder
;
}
bool
LessThan
(
const
Value
&
a
const
Value
&
b
)
const
{
bool
requestedByChildA
=
a
.
second
-
>
mFlags
.
contains
(
StartupCacheEntryFlags
:
:
RequestedByChild
)
;
bool
requestedByChildB
=
b
.
second
-
>
mFlags
.
contains
(
StartupCacheEntryFlags
:
:
RequestedByChild
)
;
if
(
requestedByChildA
=
=
requestedByChildB
)
{
return
a
.
second
-
>
mRequestedOrder
<
b
.
second
-
>
mRequestedOrder
;
}
else
{
return
requestedByChildA
;
}
}
}
;
}
;
class
StartupCacheListener
final
:
public
nsIObserver
{
~
StartupCacheListener
(
)
=
default
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
enum
class
ProcessType
:
uint8_t
{
Uninitialized
Parent
Web
Extension
PrivilegedAbout
}
;
class
StartupCache
:
public
nsIMemoryReporter
{
friend
class
StartupCacheListener
;
friend
class
StartupCacheChild
;
public
:
using
Table
=
HashMap
<
MaybeOwnedCharPtr
StartupCacheEntry
StartupCacheKeyHasher
>
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
bool
HasEntry
(
const
char
*
id
)
;
nsresult
GetBuffer
(
const
char
*
id
const
char
*
*
outbuf
uint32_t
*
length
)
;
nsresult
PutBuffer
(
const
char
*
id
UniquePtr
<
char
[
]
>
&
&
inbuf
uint32_t
length
bool
isFromChildProcess
=
false
)
;
void
InvalidateCache
(
)
;
void
MaybeInitShutdownWrite
(
)
;
void
EnsureShutdownWriteComplete
(
)
;
static
void
IgnoreDiskCache
(
)
;
nsresult
GetDebugObjectOutputStream
(
nsIObjectOutputStream
*
aStream
nsIObjectOutputStream
*
*
outStream
)
;
static
ProcessType
GetChildProcessType
(
const
nsACString
&
remoteType
)
;
static
StartupCache
*
GetSingleton
(
)
;
static
nsresult
PartialInitSingleton
(
nsIFile
*
aProfileLocalDir
)
;
static
nsresult
FullyInitSingleton
(
)
;
static
nsresult
InitChildSingleton
(
char
*
aScacheHandleStr
char
*
aScacheSizeStr
)
;
static
void
DeleteSingleton
(
)
;
static
void
InitContentChild
(
dom
:
:
ContentParent
&
parent
)
;
void
AddStartupCacheCmdLineArgs
(
ipc
:
:
GeckoChildProcessHost
&
procHost
const
nsACString
&
aRemoteType
std
:
:
vector
<
std
:
:
string
>
&
aExtraOpts
)
;
nsresult
ParseStartupCacheCmdLineArgs
(
char
*
aScacheHandleStr
char
*
aScacheSizeStr
)
;
size_t
HeapSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
bool
ShouldCompactCache
(
)
;
nsresult
ResetStartupWriteTimer
(
)
;
bool
StartupWriteComplete
(
)
;
private
:
StartupCache
(
)
;
virtual
~
StartupCache
(
)
;
friend
class
StartupCacheInfo
;
Result
<
Ok
nsresult
>
LoadArchive
(
)
;
nsresult
PartialInit
(
nsIFile
*
aProfileLocalDir
)
;
nsresult
FullyInit
(
)
;
nsresult
InitChild
(
StartupCacheChild
*
cacheChild
)
;
void
InvalidateCacheImpl
(
bool
memoryOnly
=
false
)
;
nsresult
ResetStartupWriteTimerCheckingReadCount
(
)
;
nsresult
ResetStartupWriteTimerImpl
(
)
;
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
GetCacheFile
(
const
nsAString
&
suffix
)
;
Result
<
Ok
nsresult
>
OpenCache
(
)
;
Result
<
Ok
nsresult
>
WriteToDisk
(
)
;
Result
<
Ok
nsresult
>
DecompressEntry
(
StartupCacheEntry
&
aEntry
MaybeOwnedCharPtr
&
aBuffer
)
;
Result
<
Ok
nsresult
>
LoadEntriesOffDisk
(
)
;
Result
<
Ok
nsresult
>
LoadEntriesFromSharedMemory
(
)
;
void
WaitOnPrefetchThread
(
)
;
void
StartPrefetchMemoryThread
(
)
;
static
void
WriteTimeout
(
nsITimer
*
aTimer
void
*
aClosure
)
;
static
void
SendEntriesTimeout
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
MaybeWriteOffMainThread
(
)
;
static
void
ThreadedPrefetch
(
void
*
aClosure
)
;
EnumSet
<
ProcessType
>
mInitializedProcesses
{
}
;
nsCString
mContentStartupFinishedTopic
;
Table
mTable
;
nsTArray
<
decltype
(
mTable
)
>
mOldTables
;
nsCOMPtr
<
nsIFile
>
mFile
;
loader
:
:
AutoMemMap
mCacheData
;
loader
:
:
AutoMemMap
mSharedData
;
UniqueFileHandle
mSharedDataHandle
;
mutable
Mutex
mLock
;
nsCOMPtr
<
nsIObserverService
>
mObserverService
;
RefPtr
<
StartupCacheListener
>
mListener
;
nsCOMPtr
<
nsITimer
>
mWriteTimer
;
nsCOMPtr
<
nsITimer
>
mSendEntriesTimer
;
Atomic
<
bool
>
mDirty
;
Atomic
<
bool
>
mWrittenOnce
;
bool
mCurTableReferenced
;
bool
mLoaded
;
bool
mFullyInitialized
;
uint32_t
mRequestedCount
;
uint32_t
mPrefetchSize
;
uint32_t
mSharedDataSize
;
size_t
mCacheEntriesBaseOffset
;
static
StaticRefPtr
<
StartupCache
>
gStartupCache
;
static
bool
gIgnoreDiskCache
;
static
bool
gFoundDiskCacheOnInit
;
Atomic
<
StartupCacheChild
*
>
mChildActor
;
PRThread
*
mPrefetchThread
;
UniquePtr
<
Compression
:
:
LZ4FrameDecompressionContext
>
mDecompressionContext
;
#
ifdef
DEBUG
nsTHashtable
<
nsISupportsHashKey
>
mWriteObjectMap
;
#
endif
}
;
#
ifdef
DEBUG
class
StartupCacheDebugOutputStream
final
:
public
nsIObjectOutputStream
{
~
StartupCacheDebugOutputStream
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBJECTOUTPUTSTREAM
StartupCacheDebugOutputStream
(
nsIObjectOutputStream
*
binaryStream
nsTHashtable
<
nsISupportsHashKey
>
*
objectMap
)
:
mBinaryStream
(
binaryStream
)
mObjectMap
(
objectMap
)
{
}
NS_FORWARD_SAFE_NSIBINARYOUTPUTSTREAM
(
mBinaryStream
)
NS_FORWARD_SAFE_NSIOUTPUTSTREAM
(
mBinaryStream
)
bool
CheckReferences
(
nsISupports
*
aObject
)
;
nsCOMPtr
<
nsIObjectOutputStream
>
mBinaryStream
;
nsTHashtable
<
nsISupportsHashKey
>
*
mObjectMap
;
}
;
#
endif
}
}
#
endif
