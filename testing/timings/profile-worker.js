const
{
parentPort
workerData
}
=
require
(
"
worker_threads
"
)
;
const
fs
=
require
(
"
fs
"
)
;
const
path
=
require
(
"
path
"
)
;
const
zlib
=
require
(
"
zlib
"
)
;
function
normalizeMessage
(
message
)
{
return
message
?
.
replace
(
/
task_
\
d
+
/
g
"
task_id
"
)
.
replace
(
/
\
nRejection
date
:
[
^
\
n
]
+
/
g
"
"
)
;
}
function
extractParallelRanges
(
markers
)
{
const
parallelRanges
=
[
]
;
for
(
let
i
=
0
;
i
<
markers
.
length
;
i
+
+
)
{
const
data
=
markers
.
data
[
i
]
;
if
(
data
?
.
type
=
=
=
"
Text
"
&
&
data
.
text
=
=
=
"
parallel
"
)
{
parallelRanges
.
push
(
{
start
:
markers
.
startTime
[
i
]
end
:
markers
.
endTime
[
i
]
}
)
;
}
}
return
parallelRanges
;
}
function
isInParallelRange
(
testStart
testEnd
parallelRanges
)
{
for
(
const
range
of
parallelRanges
)
{
if
(
testStart
<
range
.
end
&
&
testEnd
>
range
.
start
)
{
return
true
;
}
}
return
false
;
}
function
extractResourceUsage
(
profile
)
{
if
(
!
profile
|
|
!
profile
.
threads
|
|
!
profile
.
threads
[
0
]
)
{
return
null
;
}
const
thread
=
profile
.
threads
[
0
]
;
const
{
markers
}
=
thread
;
if
(
!
markers
|
|
!
markers
.
data
)
{
return
null
;
}
const
machineInfo
=
{
logicalCPUs
:
profile
.
meta
?
.
logicalCPUs
|
|
null
physicalCPUs
:
profile
.
meta
?
.
physicalCPUs
|
|
null
mainMemory
:
profile
.
meta
?
.
mainMemory
?
parseFloat
(
(
profile
.
meta
.
mainMemory
/
(
1024
*
1024
*
1024
)
)
.
toFixed
(
1
)
)
:
null
}
;
let
maxMemory
=
0
;
let
idleTime
=
0
;
let
singleCoreTime
=
0
;
const
cpuBuckets
=
new
Array
(
10
)
.
fill
(
0
)
;
const
oneCorePct
=
machineInfo
.
logicalCPUs
?
100
/
machineInfo
.
logicalCPUs
:
12
.
5
;
const
idleThreshold
=
oneCorePct
/
2
;
const
singleCoreMin
=
oneCorePct
*
0
.
75
;
const
singleCoreMax
=
oneCorePct
*
1
.
25
;
for
(
let
i
=
0
;
i
<
markers
.
length
;
i
+
+
)
{
const
data
=
markers
.
data
[
i
]
;
if
(
!
data
)
{
continue
;
}
const
duration
=
markers
.
endTime
[
i
]
-
markers
.
startTime
[
i
]
;
if
(
data
.
type
=
=
=
"
Mem
"
)
{
if
(
data
.
used
>
maxMemory
)
{
maxMemory
=
data
.
used
;
}
}
else
if
(
data
.
type
=
=
=
"
CPU
"
)
{
const
cpuPercent
=
parseFloat
(
data
.
cpuPercent
)
;
if
(
isNaN
(
cpuPercent
)
)
{
continue
;
}
if
(
cpuPercent
<
idleThreshold
)
{
idleTime
+
=
duration
;
}
if
(
cpuPercent
>
=
singleCoreMin
&
&
cpuPercent
<
=
singleCoreMax
)
{
singleCoreTime
+
=
duration
;
}
const
bucketIndex
=
Math
.
min
(
Math
.
floor
(
cpuPercent
/
10
)
9
)
;
cpuBuckets
[
bucketIndex
]
+
=
duration
;
}
}
return
{
machineInfo
maxMemory
idleTime
singleCoreTime
cpuBuckets
}
;
}
function
extractTestTimings
(
profile
)
{
if
(
!
profile
|
|
!
profile
.
threads
|
|
!
profile
.
threads
[
0
]
)
{
return
[
]
;
}
const
thread
=
profile
.
threads
[
0
]
;
const
{
markers
stringArray
}
=
thread
;
if
(
!
markers
|
|
!
markers
.
data
|
|
!
markers
.
name
|
|
!
stringArray
)
{
return
[
]
;
}
const
parallelRanges
=
extractParallelRanges
(
markers
)
;
const
crashMarkers
=
[
]
;
for
(
let
i
=
0
;
i
<
markers
.
length
;
i
+
+
)
{
const
data
=
markers
.
data
[
i
]
;
if
(
data
?
.
type
!
=
=
"
Crash
"
|
|
!
data
.
test
)
{
continue
;
}
crashMarkers
.
push
(
{
testPath
:
data
.
test
startTime
:
markers
.
startTime
[
i
]
signature
:
data
.
signature
|
|
null
minidump
:
data
.
minidump
|
|
null
}
)
;
}
const
failStringId
=
stringArray
.
indexOf
(
"
FAIL
"
)
;
const
errorStringId
=
stringArray
.
indexOf
(
"
ERROR
"
)
;
const
testStatusMarkers
=
[
]
;
for
(
let
i
=
0
;
i
<
markers
.
length
;
i
+
+
)
{
const
nameId
=
markers
.
name
[
i
]
;
if
(
nameId
!
=
=
failStringId
&
&
nameId
!
=
=
errorStringId
)
{
continue
;
}
const
data
=
markers
.
data
[
i
]
;
if
(
!
data
|
|
data
.
type
!
=
=
"
TestStatus
"
|
|
!
data
.
test
)
{
continue
;
}
testStatusMarkers
.
push
(
{
test
:
data
.
test
nameId
time
:
markers
.
startTime
[
i
]
message
:
normalizeMessage
(
data
.
message
)
}
)
;
}
testStatusMarkers
.
sort
(
(
a
b
)
=
>
a
.
test
.
localeCompare
(
b
.
test
)
|
|
a
.
time
-
b
.
time
)
;
const
testStringId
=
stringArray
.
indexOf
(
"
test
"
)
;
const
timings
=
[
]
;
for
(
let
i
=
0
;
i
<
markers
.
length
;
i
+
+
)
{
if
(
markers
.
name
[
i
]
!
=
=
testStringId
)
{
continue
;
}
const
data
=
markers
.
data
[
i
]
;
if
(
!
data
)
{
continue
;
}
let
testPath
=
null
;
let
status
=
"
UNKNOWN
"
;
let
message
=
null
;
if
(
data
.
type
=
=
=
"
Test
"
)
{
const
fullTestId
=
data
.
test
|
|
data
.
name
;
testPath
=
fullTestId
;
status
=
data
.
status
|
|
"
UNKNOWN
"
;
message
=
normalizeMessage
(
data
.
message
?
data
.
message
.
replace
(
/
\
r
\
n
/
g
"
\
n
"
)
:
null
)
;
if
(
status
=
=
=
"
FAIL
"
&
&
data
.
color
=
=
=
"
green
"
)
{
status
=
"
EXPECTED
-
FAIL
"
;
}
else
if
(
[
"
TIMEOUT
"
"
FAIL
"
"
PASS
"
]
.
includes
(
status
)
&
&
parallelRanges
.
length
)
{
status
+
=
isInParallelRange
(
markers
.
startTime
[
i
]
markers
.
endTime
[
i
]
parallelRanges
)
?
"
-
PARALLEL
"
:
"
-
SEQUENTIAL
"
;
}
if
(
status
.
startsWith
(
"
FAIL
"
)
)
{
const
testStartTime
=
markers
.
startTime
[
i
]
;
const
statusMarker
=
testStatusMarkers
.
find
(
m
=
>
m
.
test
=
=
=
fullTestId
&
&
m
.
time
>
=
testStartTime
)
;
if
(
statusMarker
&
&
statusMarker
.
message
)
{
message
=
statusMarker
.
message
;
}
}
if
(
testPath
&
&
testPath
.
includes
(
"
:
"
)
)
{
testPath
=
testPath
.
split
(
"
:
"
)
[
1
]
;
}
}
else
if
(
data
.
type
=
=
=
"
Text
"
)
{
testPath
=
data
.
text
;
if
(
testPath
?
.
startsWith
(
"
replaying
full
log
for
"
)
)
{
continue
;
}
status
=
"
UNKNOWN
"
;
}
else
{
continue
;
}
if
(
!
testPath
|
|
!
testPath
.
endsWith
(
"
.
js
"
)
)
{
continue
;
}
const
testStartTime
=
markers
.
startTime
[
i
]
;
const
testEndTime
=
markers
.
endTime
[
i
]
;
const
timing
=
{
path
:
testPath
duration
:
testEndTime
-
testStartTime
status
timestamp
:
profile
.
meta
.
startTime
+
testStartTime
}
;
if
(
message
)
{
timing
.
message
=
message
;
}
if
(
status
=
=
=
"
CRASH
"
)
{
const
matchingCrash
=
crashMarkers
.
find
(
crash
=
>
crash
.
testPath
=
=
=
data
.
test
&
&
crash
.
startTime
>
=
testStartTime
&
&
crash
.
startTime
<
=
testEndTime
)
;
if
(
matchingCrash
)
{
if
(
matchingCrash
.
signature
)
{
timing
.
crashSignature
=
matchingCrash
.
signature
;
}
if
(
matchingCrash
.
minidump
)
{
timing
.
minidump
=
matchingCrash
.
minidump
;
}
}
}
timings
.
push
(
timing
)
;
}
return
timings
;
}
async
function
fetchResourceProfile
(
taskId
retryId
=
0
)
{
const
cacheFileGz
=
path
.
join
(
workerData
.
profileCacheDir
{
taskId
}
-
{
retryId
}
.
json
.
gz
)
;
if
(
fs
.
existsSync
(
cacheFileGz
)
)
{
try
{
const
compressedData
=
fs
.
readFileSync
(
cacheFileGz
)
;
const
decompressedData
=
zlib
.
gunzipSync
(
compressedData
)
;
return
JSON
.
parse
(
decompressedData
.
toString
(
"
utf
-
8
"
)
)
;
}
catch
(
error
)
{
console
.
warn
(
Error
reading
cached
gzipped
profile
{
taskId
}
:
{
error
.
message
}
)
;
}
}
const
url
=
{
workerData
.
taskclusterBaseUrl
}
/
api
/
queue
/
v1
/
task
/
{
taskId
}
/
runs
/
{
retryId
}
/
artifacts
/
public
/
test_info
/
profile_resource
-
usage
.
json
;
try
{
const
response
=
await
fetch
(
url
)
;
if
(
!
response
.
ok
)
{
return
null
;
}
const
profile
=
await
response
.
json
(
)
;
try
{
const
compressed
=
zlib
.
gzipSync
(
JSON
.
stringify
(
profile
)
)
;
fs
.
writeFileSync
(
cacheFileGz
compressed
)
;
}
catch
(
error
)
{
console
.
warn
(
Error
caching
profile
{
taskId
}
:
{
error
.
message
}
)
;
}
return
profile
;
}
catch
(
error
)
{
console
.
error
(
Error
fetching
profile
for
task
{
taskId
}
:
error
.
message
)
;
return
null
;
}
}
async
function
processJob
(
job
)
{
const
taskId
=
job
.
task_id
;
const
retryId
=
job
.
retry_id
|
|
0
;
const
jobName
=
job
.
name
;
if
(
!
taskId
)
{
return
null
;
}
const
profile
=
await
fetchResourceProfile
(
taskId
retryId
)
;
if
(
!
profile
)
{
return
null
;
}
const
timings
=
extractTestTimings
(
profile
)
;
if
(
timings
.
length
=
=
=
0
)
{
return
null
;
}
const
resourceUsage
=
extractResourceUsage
(
profile
)
;
let
commitId
=
null
;
if
(
profile
.
meta
.
sourceURL
)
{
const
match
=
profile
.
meta
.
sourceURL
.
match
(
/
\
/
rev
\
/
(
[
a
-
f0
-
9
]
+
)
/
i
)
;
if
(
match
)
{
commitId
=
match
[
1
]
;
}
}
const
startTime
=
typeof
job
.
start_time
=
=
=
"
string
"
?
Math
.
floor
(
new
Date
(
job
.
start_time
)
.
getTime
(
)
/
1000
)
:
job
.
start_time
;
return
{
jobName
taskId
retryId
repository
:
job
.
repository
startTime
timings
resourceUsage
commitId
}
;
}
async
function
main
(
)
{
try
{
const
results
=
[
]
;
parentPort
.
postMessage
(
{
type
:
"
ready
"
}
)
;
parentPort
.
on
(
"
message
"
async
message
=
>
{
if
(
message
.
type
=
=
=
"
job
"
)
{
const
result
=
await
processJob
(
message
.
job
)
;
if
(
result
)
{
results
.
push
(
result
)
;
}
parentPort
.
postMessage
(
{
type
:
"
jobComplete
"
result
}
)
;
}
else
if
(
message
.
type
=
=
=
"
shutdown
"
)
{
parentPort
.
postMessage
(
{
type
:
"
finished
"
results
}
)
;
}
}
)
;
}
catch
(
error
)
{
parentPort
.
postMessage
(
{
type
:
"
error
"
error
:
error
.
message
}
)
;
}
}
main
(
)
;
