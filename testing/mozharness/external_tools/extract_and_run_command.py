"
"
"
Usage
:
extract_and_run_command
.
py
[
-
j
N
]
[
command
to
run
]
-
-
[
files
and
/
or
directories
]
    
-
j
is
the
number
of
workers
to
start
defaulting
to
1
.
    
[
command
to
run
]
must
be
a
command
that
can
accept
one
or
many
files
    
to
process
as
arguments
.
WARNING
:
This
script
does
NOT
respond
to
SIGINT
.
You
must
use
SIGQUIT
or
SIGKILL
to
         
terminate
it
early
.
"
"
"
import
logging
import
os
import
shutil
import
subprocess
import
sys
import
tempfile
import
time
from
os
import
path
from
threading
import
Thread
try
:
    
from
Queue
import
Queue
except
ImportError
:
    
from
queue
import
Queue
logging
.
basicConfig
(
stream
=
sys
.
stdout
level
=
logging
.
INFO
format
=
"
%
(
message
)
s
"
)
log
=
logging
.
getLogger
(
__name__
)
try
:
    
from
mardor
.
marfile
import
BZ2MarFile
except
:
    
sys
.
path
.
append
(
        
path
.
join
(
path
.
dirname
(
path
.
realpath
(
__file__
)
)
"
.
.
/
buildfarm
/
utils
"
)
    
)
    
from
mar
import
BZ2MarFile
SEVENZIP
=
"
7za
"
def
extractMar
(
filename
tempdir
)
:
    
m
=
BZ2MarFile
(
filename
)
    
m
.
extractall
(
path
=
tempdir
)
def
extractExe
(
filename
tempdir
)
:
    
try
:
        
fd
=
tempfile
.
TemporaryFile
(
)
        
proc
=
subprocess
.
Popen
(
            
[
SEVENZIP
"
x
"
"
-
o
%
s
"
%
tempdir
filename
]
            
stdout
=
fd
            
stderr
=
subprocess
.
STDOUT
        
)
        
proc
.
wait
(
)
    
except
subprocess
.
CalledProcessError
:
        
pass
EXTRACTORS
=
{
    
"
.
mar
"
:
extractMar
    
"
.
exe
"
:
extractExe
}
def
find_files
(
d
)
:
    
"
"
"
yields
all
of
the
files
in
d
'
"
"
"
    
for
root
_
files
in
os
.
walk
(
d
)
:
        
for
f
in
files
:
            
yield
path
.
abspath
(
path
.
join
(
root
f
)
)
def
rchmod
(
d
mode
=
0o755
)
:
    
"
"
"
chmods
everything
in
d
'
to
mode
'
including
d
'
itself
"
"
"
    
os
.
chmod
(
d
mode
)
    
for
root
dirs
files
in
os
.
walk
(
d
)
:
        
for
item
in
dirs
:
            
os
.
chmod
(
path
.
join
(
root
item
)
mode
)
        
for
item
in
files
:
            
os
.
chmod
(
path
.
join
(
root
item
)
mode
)
def
maybe_extract
(
filename
)
:
    
"
"
"
If
an
extractor
is
found
for
filename
'
extracts
it
to
a
temporary
    
directory
and
chmods
it
.
The
consumer
is
responsible
for
removing
    
the
extracted
files
if
desired
.
"
"
"
    
ext
=
path
.
splitext
(
filename
)
[
1
]
    
if
ext
not
in
EXTRACTORS
.
keys
(
)
:
        
return
None
    
tempdir_root
=
tempfile
.
mkdtemp
(
)
    
tempdir
=
path
.
join
(
tempdir_root
filename
.
lstrip
(
"
/
"
)
)
    
os
.
makedirs
(
tempdir
)
    
EXTRACTORS
[
ext
]
(
filename
tempdir
)
    
rchmod
(
tempdir_root
)
    
return
tempdir_root
def
process
(
item
command
)
:
    
def
format_time
(
t
)
:
        
return
time
.
strftime
(
"
%
H
:
%
M
:
%
S
"
time
.
localtime
(
t
)
)
    
logs
=
[
]
    
args
=
[
item
]
    
proc
=
None
    
start
=
time
.
time
(
)
    
logs
.
append
(
"
START
%
s
:
%
s
"
%
(
format_time
(
start
)
item
)
)
    
tempdir
=
maybe_extract
(
item
)
    
if
tempdir
:
        
for
f
in
find_files
(
tempdir
)
:
            
args
.
append
(
f
)
    
try
:
        
fd
=
tempfile
.
TemporaryFile
(
)
        
proc
=
subprocess
.
Popen
(
command
+
args
stdout
=
fd
)
        
proc
.
wait
(
)
        
if
proc
.
returncode
!
=
0
:
            
raise
Exception
(
"
returned
%
s
"
%
proc
.
returncode
)
    
finally
:
        
if
tempdir
:
            
shutil
.
rmtree
(
tempdir
)
        
fd
.
seek
(
0
)
        
logs
.
append
(
fd
.
read
(
)
.
rstrip
(
)
)
        
end
=
time
.
time
(
)
        
elapsed
=
end
-
start
        
logs
.
append
(
            
"
END
%
s
(
%
d
seconds
elapsed
)
:
%
s
\
n
"
%
(
format_time
(
end
)
elapsed
item
)
        
)
        
log
.
info
(
"
\
n
"
.
join
(
logs
)
)
def
worker
(
command
errors
)
:
    
item
=
q
.
get
(
)
    
while
item
!
=
None
:
        
try
:
            
process
(
item
command
)
        
except
:
            
errors
.
put
(
item
)
        
item
=
q
.
get
(
)
if
__name__
=
=
"
__main__
"
:
    
from
getopt
import
getopt
    
options
args
=
getopt
(
sys
.
argv
[
1
:
]
"
j
:
h
"
[
"
help
"
]
)
    
concurrency
=
1
    
for
o
a
in
options
:
        
if
o
=
=
"
-
j
"
:
            
concurrency
=
int
(
a
)
        
elif
o
in
(
"
-
h
"
"
-
-
help
"
)
:
            
log
.
info
(
__doc__
)
            
sys
.
exit
(
0
)
    
if
len
(
args
)
<
3
or
"
-
-
"
not
in
args
:
        
log
.
error
(
__doc__
)
        
sys
.
exit
(
1
)
    
command
=
[
]
    
while
args
[
0
]
!
=
"
-
-
"
:
        
command
.
append
(
args
.
pop
(
0
)
)
    
args
.
pop
(
0
)
    
q
=
Queue
(
)
    
errors
=
Queue
(
)
    
threads
=
[
]
    
for
i
in
range
(
concurrency
)
:
        
t
=
Thread
(
target
=
worker
args
=
(
command
errors
)
)
        
t
.
start
(
)
        
threads
.
append
(
t
)
    
for
arg
in
args
:
        
if
path
.
isfile
(
arg
)
:
            
q
.
put
(
arg
)
        
else
:
            
for
f
in
find_files
(
arg
)
:
                
q
.
put
(
f
)
    
for
i
in
range
(
concurrency
)
:
        
q
.
put
(
None
)
    
for
t
in
threads
:
        
t
.
join
(
)
    
if
not
errors
.
empty
(
)
:
        
log
.
error
(
"
Command
failed
for
the
following
files
:
"
)
        
while
not
errors
.
empty
(
)
:
            
log
.
error
(
"
%
s
"
%
errors
.
get
(
)
)
        
sys
.
exit
(
1
)
