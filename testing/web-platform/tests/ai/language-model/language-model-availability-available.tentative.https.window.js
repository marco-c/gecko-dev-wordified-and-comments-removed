'
use
strict
'
;
promise_test
(
async
(
)
=
>
{
await
ensureLanguageModel
(
)
;
}
'
LanguageModel
.
availability
(
)
is
available
with
no
options
'
)
;
promise_test
(
async
(
)
=
>
{
await
ensureLanguageModel
(
)
;
const
kCreateOptionsSpec
=
[
{
topK
:
[
1
1
.
5
2
3
99
]
}
{
temperature
:
[
0
0
.
5
1
2
]
}
{
expectedInputs
:
[
undefined
[
]
[
{
type
:
'
text
'
}
]
[
{
type
:
'
text
'
languages
:
[
'
en
'
]
}
]
]
}
{
expectedOutputs
:
[
undefined
[
]
[
{
type
:
'
text
'
}
]
[
{
type
:
'
text
'
languages
:
[
'
en
'
]
}
]
]
}
]
;
for
(
const
options
of
generateOptionCombinations
(
kCreateOptionsSpec
)
)
{
const
availability
=
await
LanguageModel
.
availability
(
options
)
;
assert_in_array
(
availability
kValidAvailabilities
JSON
.
stringify
(
options
)
)
;
}
}
'
LanguageModel
.
availability
(
)
returns
available
with
supported
options
'
)
;
promise_test
(
async
(
)
=
>
{
await
ensureLanguageModel
(
)
;
const
kUnsupportedCreateOptions
=
[
{
expectedInputs
:
[
{
type
:
'
text
'
languages
:
[
'
unk
'
]
}
]
}
{
expectedOutputs
:
[
{
type
:
'
text
'
languages
:
[
'
unk
'
]
}
]
}
{
expectedOutputs
:
[
{
type
:
'
image
'
}
]
}
{
expectedOutputs
:
[
{
type
:
'
audio
'
}
]
}
{
topK
:
0
temperature
:
0
.
5
}
{
topK
:
-
3
temperature
:
0
.
5
}
{
topK
:
3
temperature
:
-
0
.
5
}
{
topK
:
3
}
{
temperature
:
0
.
5
}
]
;
for
(
const
options
of
kUnsupportedCreateOptions
)
{
assert_equals
(
await
LanguageModel
.
availability
(
options
)
'
unavailable
'
JSON
.
stringify
(
options
)
)
;
}
}
'
LanguageModel
.
availability
(
)
returns
unavailable
with
unsupported
options
'
)
;
promise_test
(
async
t
=
>
{
await
ensureLanguageModel
(
)
;
const
kInvalidCreateOptions
=
[
{
expectedInputs
:
[
{
type
:
'
soup
'
}
]
}
]
;
for
(
const
options
of
kInvalidCreateOptions
)
{
await
promise_rejects_js
(
t
TypeError
LanguageModel
.
availability
(
options
)
)
;
}
}
'
LanguageModel
.
availability
(
)
rejects
with
invalid
options
'
)
;
