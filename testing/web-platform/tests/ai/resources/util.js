const
kValidAvailabilities
=
[
'
unavailable
'
'
downloadable
'
'
downloading
'
'
available
'
]
;
const
kAvailableAvailabilities
=
[
'
downloadable
'
'
downloading
'
'
available
'
]
;
const
kTestPrompt
=
'
Please
write
a
sentence
in
English
.
'
;
const
kTestContext
=
'
This
is
a
test
;
this
is
only
a
test
.
'
;
function
generateOptionCombinations
(
optionsSpec
)
{
const
keys
=
optionsSpec
.
map
(
o
=
>
Object
.
keys
(
o
)
[
0
]
)
;
const
valueArrays
=
optionsSpec
.
map
(
o
=
>
Object
.
values
(
o
)
[
0
]
)
;
const
valueCombinations
=
valueArrays
.
reduce
(
(
accumulator
currentValues
)
=
>
{
if
(
accumulator
.
length
=
=
=
0
)
{
return
currentValues
.
map
(
value
=
>
[
value
]
)
;
}
return
accumulator
.
flatMap
(
existingCombo
=
>
currentValues
.
map
(
currentValue
=
>
[
.
.
.
existingCombo
currentValue
]
)
)
;
}
[
]
)
;
return
valueCombinations
.
map
(
combination
=
>
{
const
result
=
{
}
;
keys
.
forEach
(
(
key
index
)
=
>
{
if
(
combination
[
index
]
!
=
=
undefined
)
{
result
[
key
]
=
combination
[
index
]
;
}
}
)
;
return
result
;
}
)
;
}
async
function
testAbortPromise
(
t
method
)
{
{
const
controller
=
new
AbortController
(
)
;
const
promise
=
method
(
controller
.
signal
)
;
controller
.
abort
(
)
;
await
promise_rejects_dom
(
t
'
AbortError
'
promise
)
;
const
anotherPromise
=
method
(
controller
.
signal
)
;
await
promise_rejects_dom
(
t
'
AbortError
'
anotherPromise
)
;
}
{
const
err
=
new
Error
(
'
test
'
)
;
const
controller
=
new
AbortController
(
)
;
const
promise
=
method
(
controller
.
signal
)
;
controller
.
abort
(
err
)
;
await
promise_rejects_exactly
(
t
err
promise
)
;
const
anotherPromise
=
method
(
controller
.
signal
)
;
await
promise_rejects_exactly
(
t
err
anotherPromise
)
;
}
}
;
async
function
testCreateMonitorWithAbortAt
(
t
loadedToAbortAt
method
options
=
{
}
)
{
const
{
promise
:
eventPromise
resolve
}
=
Promise
.
withResolvers
(
)
;
let
hadEvent
=
false
;
function
monitor
(
m
)
{
m
.
addEventListener
(
'
downloadprogress
'
e
=
>
{
if
(
e
.
loaded
!
=
loadedToAbortAt
)
{
return
;
}
if
(
hadEvent
)
{
assert_unreached
(
'
This
should
never
be
reached
since
LanguageDetector
.
create
(
)
was
aborted
.
'
)
;
return
;
}
resolve
(
)
;
hadEvent
=
true
;
}
)
;
}
const
controller
=
new
AbortController
(
)
;
const
createPromise
=
method
(
{
.
.
.
options
monitor
signal
:
controller
.
signal
}
)
;
await
eventPromise
;
const
err
=
new
Error
(
'
test
'
)
;
controller
.
abort
(
err
)
;
await
promise_rejects_exactly
(
t
err
createPromise
)
;
}
async
function
testCreateMonitorWithAbort
(
t
method
options
=
{
}
)
{
await
testCreateMonitorWithAbortAt
(
t
0
method
options
)
;
await
testCreateMonitorWithAbortAt
(
t
1
method
options
)
;
}
async
function
testAbortReadableStream
(
t
method
)
{
{
const
controller
=
new
AbortController
(
)
;
const
stream
=
method
(
controller
.
signal
)
;
controller
.
abort
(
)
;
let
writableStream
=
new
WritableStream
(
)
;
await
promise_rejects_dom
(
t
'
AbortError
'
stream
.
pipeTo
(
writableStream
)
)
;
await
promise_rejects_dom
(
t
'
AbortError
'
new
Promise
(
(
)
=
>
{
method
(
controller
.
signal
)
;
}
)
)
;
}
{
const
error
=
new
DOMException
(
'
test
'
'
VersionError
'
)
;
const
controller
=
new
AbortController
(
)
;
const
stream
=
method
(
controller
.
signal
)
;
controller
.
abort
(
error
)
;
let
writableStream
=
new
WritableStream
(
)
;
await
promise_rejects_exactly
(
t
error
stream
.
pipeTo
(
writableStream
)
)
;
await
promise_rejects_exactly
(
t
error
new
Promise
(
(
)
=
>
{
method
(
controller
.
signal
)
;
}
)
)
;
}
}
;
async
function
testMonitor
(
createFunc
options
=
{
}
)
{
let
created
=
false
;
const
progressEvents
=
[
]
;
function
monitor
(
m
)
{
m
.
addEventListener
(
'
downloadprogress
'
e
=
>
{
assert_false
(
created
)
;
progressEvents
.
push
(
e
)
;
}
)
;
}
result
=
await
createFunc
(
{
.
.
.
options
monitor
}
)
;
created
=
true
;
assert_greater_than_equal
(
progressEvents
.
length
2
)
;
assert_equals
(
progressEvents
.
at
(
0
)
.
loaded
0
)
;
assert_equals
(
progressEvents
.
at
(
-
1
)
.
loaded
1
)
;
let
lastProgressEventLoaded
=
-
1
;
for
(
const
progressEvent
of
progressEvents
)
{
assert_equals
(
progressEvent
.
lengthComputable
true
)
;
assert_equals
(
progressEvent
.
total
1
)
;
assert_less_than_equal
(
progressEvent
.
loaded
progressEvent
.
total
)
;
assert_equals
(
progressEvent
.
loaded
%
(
1
/
0x10000
)
0
)
;
assert_greater_than
(
progressEvent
.
loaded
lastProgressEventLoaded
)
;
lastProgressEventLoaded
=
progressEvent
.
loaded
;
}
return
result
;
}
