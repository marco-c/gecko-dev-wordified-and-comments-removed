'
use
strict
'
;
function
parallelPromiseTest
(
func
description
)
{
async_test
(
(
t
)
=
>
{
Promise
.
resolve
(
func
(
t
)
)
.
then
(
(
)
=
>
t
.
done
(
)
)
.
catch
(
t
.
step_func
(
(
e
)
=
>
{
throw
e
;
}
)
)
;
}
description
)
;
}
const
BeaconTypes
=
[
{
type
:
PendingPostBeacon
name
:
'
PendingPostBeacon
'
expectedMethod
:
'
POST
'
}
{
type
:
PendingGetBeacon
name
:
'
PendingGetBeacon
'
expectedMethod
:
'
GET
'
}
]
;
const
BeaconDataType
=
{
String
:
'
String
'
ArrayBuffer
:
'
ArrayBuffer
'
FormData
:
'
FormData
'
URLSearchParams
:
'
URLSearchParams
'
Blob
:
'
Blob
'
File
:
'
File
'
}
;
const
BeaconDataTypeToSkipCharset
=
{
String
:
'
'
ArrayBuffer
:
'
'
FormData
:
'
\
n
\
r
'
URLSearchParams
:
'
;
/
?
:
&
=
+
'
Blob
:
'
'
File
:
'
'
}
;
const
BEACON_PAYLOAD_KEY
=
'
payload
'
;
function
makeBeaconData
(
data
dataType
contentType
)
{
switch
(
dataType
)
{
case
BeaconDataType
.
String
:
return
data
;
case
BeaconDataType
.
ArrayBuffer
:
return
new
TextEncoder
(
)
.
encode
(
data
)
.
buffer
;
case
BeaconDataType
.
FormData
:
const
formData
=
new
FormData
(
)
;
if
(
data
.
length
>
0
)
{
formData
.
append
(
BEACON_PAYLOAD_KEY
data
)
;
}
return
formData
;
case
BeaconDataType
.
URLSearchParams
:
if
(
data
.
length
>
0
)
{
return
new
URLSearchParams
(
{
BEACON_PAYLOAD_KEY
}
=
{
data
}
)
;
}
return
new
URLSearchParams
(
)
;
case
BeaconDataType
.
Blob
:
{
const
options
=
{
type
:
contentType
|
|
undefined
}
;
return
new
Blob
(
[
data
]
options
)
;
}
case
BeaconDataType
.
File
:
{
const
options
=
{
type
:
contentType
|
|
'
text
/
plain
'
}
;
return
new
File
(
[
data
]
'
file
.
txt
'
options
)
;
}
default
:
throw
Error
(
Unsupported
beacon
dataType
:
{
dataType
}
)
;
}
}
function
generateSequentialData
(
begin
end
skip
)
{
const
codeUnits
=
Array
(
end
-
begin
)
.
fill
(
)
.
map
(
(
el
i
)
=
>
i
+
begin
)
;
if
(
skip
)
{
return
String
.
fromCharCode
(
.
.
.
codeUnits
.
filter
(
c
=
>
!
skip
.
includes
(
String
.
fromCharCode
(
c
)
)
)
)
;
}
return
String
.
fromCharCode
(
.
.
.
codeUnits
)
;
}
function
generatePayload
(
size
)
{
let
data
=
'
'
;
if
(
size
>
0
)
{
const
prefix
=
String
(
size
)
+
'
:
'
;
data
=
prefix
+
Array
(
size
-
prefix
.
length
)
.
fill
(
'
*
'
)
.
join
(
'
'
)
;
}
return
data
;
}
function
generateSetBeaconURL
(
uuid
options
)
{
const
host
=
(
options
&
&
options
.
host
)
|
|
'
'
;
let
url
=
{
host
}
/
pending_beacon
/
resources
/
set_beacon
.
py
?
uuid
=
{
uuid
}
;
if
(
options
)
{
if
(
options
.
expectOrigin
!
=
=
undefined
)
{
url
=
{
url
}
&
expectOrigin
=
{
options
.
expectOrigin
}
;
}
if
(
options
.
expectPreflight
!
=
=
undefined
)
{
url
=
{
url
}
&
expectPreflight
=
{
options
.
expectPreflight
}
;
}
if
(
options
.
expectCredentials
!
=
=
undefined
)
{
url
=
{
url
}
&
expectCredentials
=
{
options
.
expectCredentials
}
;
}
if
(
options
.
useRedirectHandler
)
{
const
redirect
=
{
host
}
/
common
/
redirect
.
py
+
?
location
=
{
encodeURIComponent
(
url
)
}
;
url
=
redirect
;
}
}
return
url
;
}
async
function
poll
(
f
expected
)
{
const
interval
=
100
;
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
const
result
=
await
f
(
)
;
if
(
expected
(
result
)
)
{
return
result
;
}
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
interval
)
)
;
}
return
{
data
:
[
]
}
;
}
async
function
expectBeacon
(
uuid
options
)
{
const
expectedCount
=
(
options
&
&
options
.
count
!
=
=
undefined
)
?
options
.
count
:
1
;
const
res
=
await
poll
(
async
(
)
=
>
{
const
res
=
await
fetch
(
/
pending_beacon
/
resources
/
get_beacon
.
py
?
uuid
=
{
uuid
}
{
cache
:
'
no
-
store
'
}
)
;
return
await
res
.
json
(
)
;
}
(
res
)
=
>
{
return
res
.
data
.
length
=
=
expectedCount
;
}
)
;
if
(
!
options
|
|
!
options
.
data
)
{
return
;
}
if
(
expectedCount
=
=
0
)
{
return
;
}
const
decoder
=
options
&
&
options
.
percentDecoded
?
(
s
)
=
>
{
s
=
s
.
replace
(
/
\
+
/
g
'
%
20
'
)
;
return
decodeURIComponent
(
s
)
;
}
:
(
s
)
=
>
s
;
assert_equals
(
res
.
data
.
length
options
.
data
.
length
The
size
of
beacon
data
{
res
.
data
.
length
}
from
server
does
not
match
expected
value
{
options
.
data
.
length
}
.
)
;
for
(
let
i
=
0
;
i
<
options
.
data
.
length
;
i
+
+
)
{
assert_equals
(
decoder
(
res
.
data
[
i
]
)
options
.
data
[
i
]
'
The
beacon
data
does
not
match
expected
value
.
'
)
;
}
}
function
postBeaconSendDataTest
(
dataType
testData
description
options
)
{
parallelPromiseTest
(
async
t
=
>
{
const
expectNoData
=
options
&
&
options
.
expectNoData
;
const
expectCount
=
(
options
&
&
options
.
expectCount
!
=
=
undefined
)
?
options
.
expectCount
:
1
;
const
uuid
=
token
(
)
;
const
url
=
generateSetBeaconURL
(
uuid
(
options
&
&
options
.
urlOptions
)
|
|
{
}
)
;
const
beacon
=
new
PendingPostBeacon
(
url
)
;
assert_equals
(
beacon
.
method
'
POST
'
'
must
be
POST
to
call
setData
(
)
.
'
)
;
if
(
options
&
&
options
.
setCookie
)
{
document
.
cookie
=
options
.
setCookie
;
}
beacon
.
setData
(
makeBeaconData
(
testData
dataType
(
options
&
&
options
.
contentType
)
|
|
{
}
)
)
;
beacon
.
sendNow
(
)
;
const
expectedData
=
expectNoData
?
null
:
testData
;
const
percentDecoded
=
!
expectNoData
&
&
dataType
=
=
=
BeaconDataType
.
URLSearchParams
;
await
expectBeacon
(
uuid
{
count
:
expectCount
data
:
[
expectedData
]
percentDecoded
:
percentDecoded
}
)
;
}
PendingPostBeacon
(
{
dataType
}
)
:
{
description
}
)
;
}
