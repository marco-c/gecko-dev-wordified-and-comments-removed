'
use
strict
'
;
function
loadScript
(
path
)
{
let
script
=
document
.
createElement
(
'
script
'
)
;
let
promise
=
new
Promise
(
resolve
=
>
script
.
onload
=
resolve
)
;
script
.
src
=
path
;
script
.
async
=
false
;
document
.
head
.
appendChild
(
script
)
;
return
promise
;
}
async
function
performChromiumSetup
(
)
{
let
resPrefix
=
'
/
resources
'
;
const
chromiumResources
=
[
'
/
resources
/
chromium
/
web
-
bluetooth
-
test
.
js
'
]
;
const
pathname
=
window
.
location
.
pathname
;
if
(
pathname
.
includes
(
'
/
wpt_internal
/
'
)
)
{
chromiumResources
.
push
(
'
/
wpt_internal
/
bluetooth
/
resources
/
bluetooth
-
fake
-
adapter
.
js
'
)
;
}
await
loadScript
(
{
resPrefix
}
/
test
-
only
-
api
.
js
)
;
if
(
!
isChromiumBased
)
{
return
;
}
for
(
const
path
of
chromiumResources
)
{
await
loadScript
(
path
)
;
}
await
initializeChromiumResources
(
)
;
if
(
typeof
setBluetoothFakeAdapter
!
=
=
'
undefined
'
)
{
setBluetoothFakeAdapter
(
'
'
)
;
}
}
function
bluetooth_test
(
test_function
name
properties
validate_response_consumed
=
true
)
{
return
promise_test
(
async
(
t
)
=
>
{
assert_implements
(
navigator
.
bluetooth
'
missing
navigator
.
bluetooth
'
)
;
await
performChromiumSetup
(
)
;
assert_implements
(
navigator
.
bluetooth
.
test
'
missing
navigator
.
bluetooth
.
test
'
)
;
await
test_function
(
t
)
;
if
(
validate_response_consumed
)
{
let
consumed
=
await
navigator
.
bluetooth
.
test
.
allResponsesConsumed
(
)
;
assert_true
(
consumed
)
;
}
}
name
properties
)
;
}
function
waitForDocumentReady
(
)
{
return
new
Promise
(
resolve
=
>
{
if
(
document
.
readyState
=
=
=
'
complete
'
)
{
resolve
(
)
;
}
window
.
addEventListener
(
'
load
'
(
)
=
>
{
resolve
(
)
;
}
{
once
:
true
}
)
;
}
)
;
}
async
function
callWithTrustedClick
(
callback
)
{
await
waitForDocumentReady
(
)
;
return
new
Promise
(
resolve
=
>
{
let
button
=
document
.
createElement
(
'
button
'
)
;
button
.
textContent
=
'
click
to
continue
test
'
;
button
.
style
.
display
=
'
block
'
;
button
.
style
.
fontSize
=
'
20px
'
;
button
.
style
.
padding
=
'
10px
'
;
button
.
onclick
=
(
)
=
>
{
document
.
body
.
removeChild
(
button
)
;
resolve
(
callback
(
)
)
;
}
;
document
.
body
.
appendChild
(
button
)
;
test_driver
.
click
(
button
)
;
}
)
;
}
function
requestDeviceWithTrustedClick
(
)
{
let
args
=
arguments
;
return
callWithTrustedClick
(
(
)
=
>
navigator
.
bluetooth
.
requestDevice
.
apply
(
navigator
.
bluetooth
args
)
)
;
}
function
requestLEScanWithTrustedClick
(
)
{
let
args
=
arguments
;
return
callWithTrustedClick
(
(
)
=
>
navigator
.
bluetooth
.
requestLEScan
.
apply
(
navigator
.
bluetooth
args
)
)
;
}
function
assert_promise_rejects_with_message
(
promise
expected
description
)
{
return
promise
.
then
(
(
)
=
>
{
assert_unreached
(
'
Promise
should
have
rejected
:
'
+
description
)
;
}
error
=
>
{
assert_equals
(
error
.
name
expected
.
name
'
Unexpected
Error
Name
:
'
)
;
if
(
expected
.
message
)
{
assert_equals
(
error
.
message
expected
.
message
'
Unexpected
Error
Message
:
'
)
;
}
}
)
;
}
class
EventCatcher
{
constructor
(
object
event
)
{
this
.
eventFired
=
false
;
let
event_listener
=
(
)
=
>
{
object
.
removeEventListener
(
event
event_listener
)
;
this
.
eventFired
=
true
;
}
;
object
.
addEventListener
(
event
event_listener
)
;
}
}
function
eventPromise
(
target
type
options
)
{
return
new
Promise
(
resolve
=
>
{
let
wrapper
=
function
(
event
)
{
target
.
removeEventListener
(
type
wrapper
)
;
resolve
(
event
)
;
}
;
target
.
addEventListener
(
type
wrapper
options
)
;
}
)
;
}
const
ShouldBeFirst
=
{
EVENT
:
'
event
'
PROMISE_RESOLUTION
:
'
promiseresolved
'
}
;
function
assert_promise_event_order_
(
should_be_first
object
func
event
num_listeners
)
{
let
order
=
[
]
;
let
event_promises
=
[
]
;
for
(
let
i
=
0
;
i
<
num_listeners
;
i
+
+
)
{
event_promises
.
push
(
new
Promise
(
resolve
=
>
{
let
event_listener
=
(
e
)
=
>
{
object
.
removeEventListener
(
event
event_listener
)
;
order
.
push
(
ShouldBeFirst
.
EVENT
)
;
resolve
(
e
.
target
.
value
)
;
}
;
object
.
addEventListener
(
event
event_listener
)
;
}
)
)
;
}
let
func_promise
=
object
[
func
]
(
)
.
then
(
result
=
>
{
order
.
push
(
ShouldBeFirst
.
PROMISE_RESOLUTION
)
;
return
result
;
}
)
;
return
Promise
.
all
(
[
func_promise
.
.
.
event_promises
]
)
.
then
(
(
result
)
=
>
{
if
(
should_be_first
!
=
=
order
[
0
]
)
{
throw
should_be_first
=
=
=
ShouldBeFirst
.
PROMISE_RESOLUTION
?
'
{
event
}
'
was
fired
before
promise
resolved
.
:
Promise
resolved
before
'
{
event
}
'
was
fired
.
;
}
if
(
order
[
0
]
!
=
=
ShouldBeFirst
.
PROMISE_RESOLUTION
&
&
order
[
order
.
length
-
1
]
!
=
=
ShouldBeFirst
.
PROMISE_RESOLUTION
)
{
throw
'
Promise
resolved
in
between
event
listeners
.
'
;
}
return
result
;
}
)
;
}
function
assert_promise_resolves_before_event
(
object
func
event
num_listeners
=
1
)
{
return
assert_promise_event_order_
(
ShouldBeFirst
.
PROMISE_RESOLUTION
object
func
event
num_listeners
)
;
}
function
assert_promise_resolves_after_event
(
object
func
event
num_listeners
=
1
)
{
return
assert_promise_event_order_
(
ShouldBeFirst
.
EVENT
object
func
event
num_listeners
)
;
}
function
assert_no_events
(
object
event_name
)
{
return
new
Promise
(
(
resolve
)
=
>
{
let
event_listener
=
(
e
)
=
>
{
object
.
removeEventListener
(
event_name
event_listener
)
;
assert_unreached
(
'
Object
should
not
fire
an
event
.
'
)
;
}
;
object
.
addEventListener
(
event_name
event_listener
)
;
step_timeout
(
(
)
=
>
{
object
.
removeEventListener
(
event_name
event_listener
)
;
resolve
(
)
;
}
100
)
;
}
)
;
}
function
assert_properties_equal
(
properties
expected_properties
)
{
for
(
let
key
in
expected_properties
)
{
assert_equals
(
properties
[
key
]
expected_properties
[
key
]
)
;
}
}
function
assert_data_maps_equal
(
data_map
expected_key
expected_value
)
{
assert_true
(
data_map
.
has
(
expected_key
)
)
;
const
value
=
new
Uint8Array
(
data_map
.
get
(
expected_key
)
.
buffer
)
;
assert_equals
(
value
.
length
expected_value
.
length
)
;
for
(
let
i
=
0
;
i
<
value
.
length
;
+
+
i
)
{
assert_equals
(
value
[
i
]
expected_value
[
i
]
)
;
}
}
