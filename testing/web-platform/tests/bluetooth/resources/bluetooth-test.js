'
use
strict
'
;
function
loadScript
(
path
)
{
let
script
=
document
.
createElement
(
'
script
'
)
;
let
promise
=
new
Promise
(
resolve
=
>
script
.
onload
=
resolve
)
;
script
.
src
=
path
;
script
.
async
=
false
;
document
.
head
.
appendChild
(
script
)
;
return
promise
;
}
function
loadScripts
(
paths
)
{
let
chain
=
Promise
.
resolve
(
)
;
for
(
let
path
of
paths
)
{
chain
=
chain
.
then
(
(
)
=
>
loadScript
(
path
)
)
;
}
return
chain
;
}
function
performChromiumSetup
(
)
{
if
(
typeof
Mojo
=
=
=
'
undefined
'
)
{
return
;
}
let
prefix
=
'
/
resources
/
chromium
'
;
let
genPrefix
=
'
/
gen
'
;
let
extra
=
[
]
;
const
pathname
=
window
.
location
.
pathname
;
if
(
pathname
.
includes
(
'
/
LayoutTests
/
'
)
|
|
pathname
.
includes
(
'
/
web_tests
/
'
)
)
{
let
root
=
pathname
.
match
(
/
.
*
(
?
:
LayoutTests
|
web_tests
)
/
)
;
prefix
=
{
root
}
/
external
/
wpt
/
resources
/
chromium
;
extra
=
[
{
root
}
/
resources
/
bluetooth
/
bluetooth
-
fake
-
adapter
.
js
]
;
genPrefix
=
'
file
:
/
/
/
gen
'
;
}
else
if
(
window
.
location
.
pathname
.
startsWith
(
'
/
bluetooth
/
https
/
'
)
)
{
extra
=
[
'
/
js
-
test
-
resources
/
bluetooth
/
bluetooth
-
fake
-
adapter
.
js
'
]
;
}
return
loadScripts
(
[
{
genPrefix
}
/
layout_test_data
/
mojo
/
public
/
js
/
mojo_bindings
.
js
{
genPrefix
}
/
content
/
test
/
data
/
mojo_web_test_helper_test
.
mojom
.
js
{
genPrefix
}
/
device
/
bluetooth
/
public
/
mojom
/
uuid
.
mojom
.
js
{
genPrefix
}
/
url
/
mojom
/
origin
.
mojom
.
js
{
genPrefix
}
/
device
/
bluetooth
/
public
/
mojom
/
test
/
fake_bluetooth
.
mojom
.
js
{
genPrefix
}
/
content
/
shell
/
common
/
web_test
/
fake_bluetooth_chooser
.
mojom
.
js
{
prefix
}
/
web
-
bluetooth
-
test
.
js
]
.
concat
(
extra
)
)
.
then
(
(
)
=
>
typeof
setBluetoothFakeAdapter
=
=
=
'
undefined
'
?
undefined
:
setBluetoothFakeAdapter
(
'
'
)
)
;
}
function
bluetooth_test
(
test_function
name
properties
)
{
Promise
.
resolve
(
)
.
then
(
(
)
=
>
promise_test
(
t
=
>
Promise
.
resolve
(
)
.
then
(
performChromiumSetup
)
.
then
(
(
)
=
>
test_function
(
t
)
)
.
then
(
(
)
=
>
navigator
.
bluetooth
.
test
.
allResponsesConsumed
(
)
)
.
then
(
consumed
=
>
assert_true
(
consumed
)
)
name
properties
)
)
;
}
function
waitForDocumentReady
(
)
{
return
new
Promise
(
resolve
=
>
{
if
(
document
.
readyState
=
=
=
'
complete
'
)
{
resolve
(
)
;
}
window
.
addEventListener
(
'
load
'
(
)
=
>
{
resolve
(
)
;
}
{
once
:
true
}
)
;
}
)
;
}
function
callWithTrustedClick
(
callback
)
{
return
waitForDocumentReady
(
)
.
then
(
(
)
=
>
new
Promise
(
resolve
=
>
{
let
button
=
document
.
createElement
(
'
button
'
)
;
button
.
textContent
=
'
click
to
continue
test
'
;
button
.
style
.
display
=
'
block
'
;
button
.
style
.
fontSize
=
'
20px
'
;
button
.
style
.
padding
=
'
10px
'
;
button
.
onclick
=
(
)
=
>
{
document
.
body
.
removeChild
(
button
)
;
resolve
(
callback
(
)
)
;
}
;
document
.
body
.
appendChild
(
button
)
;
test_driver
.
click
(
button
)
;
}
)
)
;
}
function
requestDeviceWithTrustedClick
(
)
{
let
args
=
arguments
;
return
callWithTrustedClick
(
(
)
=
>
navigator
.
bluetooth
.
requestDevice
.
apply
(
navigator
.
bluetooth
args
)
)
;
}
function
requestLEScanWithTrustedClick
(
)
{
let
args
=
arguments
;
return
callWithTrustedClick
(
(
)
=
>
navigator
.
bluetooth
.
requestLEScan
.
apply
(
navigator
.
bluetooth
args
)
)
;
}
function
assert_promise_rejects_with_message
(
promise
expected
description
)
{
return
promise
.
then
(
(
)
=
>
{
assert_unreached
(
'
Promise
should
have
rejected
:
'
+
description
)
;
}
error
=
>
{
assert_equals
(
error
.
name
expected
.
name
'
Unexpected
Error
Name
:
'
)
;
if
(
expected
.
message
)
{
assert_equals
(
error
.
message
expected
.
message
'
Unexpected
Error
Message
:
'
)
;
}
}
)
;
}
function
runGarbageCollection
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
GCController
.
collect
(
)
;
step_timeout
(
resolve
0
)
;
}
)
;
}
class
EventCatcher
{
constructor
(
object
event
)
{
this
.
eventFired
=
false
;
let
event_listener
=
(
)
=
>
{
object
.
removeEventListener
(
event
event_listener
)
;
this
.
eventFired
=
true
;
}
;
object
.
addEventListener
(
event
event_listener
)
;
}
}
function
eventPromise
(
target
type
options
)
{
return
new
Promise
(
resolve
=
>
{
let
wrapper
=
function
(
event
)
{
target
.
removeEventListener
(
type
wrapper
)
;
resolve
(
event
)
;
}
;
target
.
addEventListener
(
type
wrapper
options
)
;
}
)
;
}
const
ShouldBeFirst
=
{
EVENT
:
'
event
'
PROMISE_RESOLUTION
:
'
promiseresolved
'
}
;
function
assert_promise_event_order_
(
should_be_first
object
func
event
num_listeners
)
{
let
order
=
[
]
;
let
event_promises
=
[
]
;
for
(
let
i
=
0
;
i
<
num_listeners
;
i
+
+
)
{
event_promises
.
push
(
new
Promise
(
resolve
=
>
{
let
event_listener
=
(
e
)
=
>
{
object
.
removeEventListener
(
event
event_listener
)
;
order
.
push
(
ShouldBeFirst
.
EVENT
)
;
resolve
(
e
.
target
.
value
)
;
}
;
object
.
addEventListener
(
event
event_listener
)
;
}
)
)
;
}
let
func_promise
=
object
[
func
]
(
)
.
then
(
result
=
>
{
order
.
push
(
ShouldBeFirst
.
PROMISE_RESOLUTION
)
;
return
result
;
}
)
;
return
Promise
.
all
(
[
func_promise
.
.
.
event_promises
]
)
.
then
(
(
result
)
=
>
{
if
(
should_be_first
!
=
=
order
[
0
]
)
{
throw
should_be_first
=
=
=
ShouldBeFirst
.
PROMISE_RESOLUTION
?
'
{
event
}
'
was
fired
before
promise
resolved
.
:
Promise
resolved
before
'
{
event
}
'
was
fired
.
;
}
if
(
order
[
0
]
!
=
=
ShouldBeFirst
.
PROMISE_RESOLUTION
&
&
order
[
order
.
length
-
1
]
!
=
=
ShouldBeFirst
.
PROMISE_RESOLUTION
)
{
throw
'
Promise
resolved
in
between
event
listeners
.
'
;
}
return
result
;
}
)
;
}
function
assert_promise_resolves_before_event
(
object
func
event
num_listeners
=
1
)
{
return
assert_promise_event_order_
(
ShouldBeFirst
.
PROMISE_RESOLUTION
object
func
event
num_listeners
)
;
}
function
assert_promise_resolves_after_event
(
object
func
event
num_listeners
=
1
)
{
return
assert_promise_event_order_
(
ShouldBeFirst
.
EVENT
object
func
event
num_listeners
)
;
}
function
assert_no_events
(
object
event_name
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
event_listener
=
(
e
)
=
>
{
object
.
removeEventListener
(
event_name
event_listener
)
;
assert_unreached
(
'
Object
should
not
fire
an
event
.
'
)
;
}
;
object
.
addEventListener
(
event_name
event_listener
)
;
step_timeout
(
(
)
=
>
{
object
.
removeEventListener
(
event_name
event_listener
)
;
resolve
(
)
;
}
100
)
;
}
)
;
}
function
assert_properties_equal
(
properties
expected_properties
)
{
for
(
let
key
in
expected_properties
)
{
assert_equals
(
properties
[
key
]
expected_properties
[
key
]
)
;
}
}
