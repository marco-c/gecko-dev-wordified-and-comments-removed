'
use
strict
'
;
class
Op
{
constructor
(
type
name
side
)
{
this
.
type
=
type
;
this
.
name
=
name
;
this
.
side
=
side
;
}
toString
(
)
{
return
this
.
side
=
=
=
undefined
?
{
this
.
type
}
on
{
this
.
name
}
:
{
this
.
type
}
on
{
this
.
name
}
(
{
this
.
side
}
)
;
}
equals
(
otherOp
)
{
return
this
.
type
=
=
=
otherOp
.
type
&
&
this
.
name
=
=
=
otherOp
.
name
&
&
this
.
side
=
=
=
otherOp
.
side
;
}
}
function
op
(
type
name
side
=
undefined
)
{
return
new
Op
(
type
name
side
)
;
}
class
OpRecorder
{
constructor
(
failureOp
)
{
this
.
ops
=
[
]
;
this
.
failureOp
=
failureOp
;
this
.
matched
=
false
;
}
recordAndCheck
(
type
name
side
=
undefined
)
{
const
recordedOp
=
op
(
type
name
side
)
;
this
.
ops
.
push
(
recordedOp
)
;
return
this
.
failureOp
.
equals
(
recordedOp
)
;
}
check
(
name
side
=
undefined
)
{
return
this
.
failureOp
.
equals
(
op
(
'
validate
'
name
side
)
)
;
}
actual
(
)
{
return
this
.
ops
.
toString
(
)
;
}
}
function
createRecordingObjectWithProperties
(
record
properties
)
{
const
recordingObject
=
{
}
;
for
(
const
property
of
properties
)
{
defineCheckedProperty
(
record
recordingObject
property
(
)
=
>
record
.
check
(
property
)
?
'
invalid
'
:
undefined
)
;
}
return
recordingObject
;
}
function
defineCheckedProperty
(
record
object
property
getter
)
{
Object
.
defineProperty
(
object
property
{
get
(
)
{
if
(
record
.
recordAndCheck
(
'
get
'
property
)
)
{
throw
new
Error
(
intentional
failure
of
get
{
property
}
)
;
}
return
getter
(
)
;
}
}
)
;
}
function
createRecordingStrategy
(
record
side
=
undefined
)
{
return
{
get
size
(
)
{
if
(
record
.
recordAndCheck
(
'
get
'
'
size
'
side
)
)
{
throw
new
Error
(
intentional
failure
of
get
size
)
;
}
return
record
.
check
(
'
size
'
side
)
?
'
invalid
'
:
undefined
;
}
get
highWaterMark
(
)
{
if
(
record
.
recordAndCheck
(
'
get
'
'
highWaterMark
'
side
)
)
{
throw
new
Error
(
intentional
failure
of
get
highWaterMark
)
;
}
return
createRecordingNumberObject
(
record
'
highWaterMark
'
side
)
;
}
}
;
}
function
createRecordingNumberObject
(
record
property
side
=
undefined
)
{
return
{
[
Symbol
.
toPrimitive
]
(
hint
)
{
assert_equals
(
hint
'
number
'
hint
for
{
property
}
should
be
'
number
'
)
;
if
(
record
.
recordAndCheck
(
'
tonumber
'
property
side
)
)
{
throw
new
Error
(
intentional
failure
of
{
op
(
'
tonumber
'
property
side
)
}
)
;
}
return
record
.
check
(
property
side
)
?
-
1
:
1
;
}
}
;
}
function
expectedAsString
(
operations
failureOp
)
{
const
expected
=
[
]
;
for
(
const
step
of
operations
)
{
if
(
step
.
type
!
=
=
'
validate
'
)
{
expected
.
push
(
step
)
;
}
if
(
step
.
equals
(
failureOp
)
)
{
break
;
}
}
return
expected
.
toString
(
)
;
}
