'
use
strict
'
;
self
.
getterRejects
=
(
t
obj
getterName
target
)
=
>
{
const
getter
=
Object
.
getOwnPropertyDescriptor
(
obj
getterName
)
.
get
;
return
promise_rejects_js
(
t
TypeError
getter
.
call
(
target
)
getterName
+
'
should
reject
with
a
TypeError
'
)
;
}
;
self
.
getterRejectsForAll
=
(
t
obj
getterName
targets
)
=
>
{
return
Promise
.
all
(
targets
.
map
(
target
=
>
self
.
getterRejects
(
t
obj
getterName
target
)
)
)
;
}
;
self
.
methodRejects
=
(
t
obj
methodName
target
args
)
=
>
{
const
method
=
obj
[
methodName
]
;
return
promise_rejects_js
(
t
TypeError
method
.
apply
(
target
args
)
methodName
+
'
should
reject
with
a
TypeError
'
)
;
}
;
self
.
methodRejectsForAll
=
(
t
obj
methodName
targets
args
)
=
>
{
return
Promise
.
all
(
targets
.
map
(
target
=
>
self
.
methodRejects
(
t
obj
methodName
target
args
)
)
)
;
}
;
self
.
getterThrows
=
(
obj
getterName
target
)
=
>
{
const
getter
=
Object
.
getOwnPropertyDescriptor
(
obj
getterName
)
.
get
;
assert_throws_js
(
TypeError
(
)
=
>
getter
.
call
(
target
)
getterName
+
'
should
throw
a
TypeError
'
)
;
}
;
self
.
getterThrowsForAll
=
(
obj
getterName
targets
)
=
>
{
targets
.
forEach
(
target
=
>
self
.
getterThrows
(
obj
getterName
target
)
)
;
}
;
self
.
methodThrows
=
(
obj
methodName
target
args
)
=
>
{
const
method
=
obj
[
methodName
]
;
assert_equals
(
typeof
method
'
function
'
methodName
+
'
should
exist
'
)
;
assert_throws_js
(
TypeError
(
)
=
>
method
.
apply
(
target
args
)
methodName
+
'
should
throw
a
TypeError
'
)
;
}
;
self
.
methodThrowsForAll
=
(
obj
methodName
targets
args
)
=
>
{
targets
.
forEach
(
target
=
>
self
.
methodThrows
(
obj
methodName
target
args
)
)
;
}
;
self
.
constructorThrowsForAll
=
(
constructor
firstArgs
)
=
>
{
firstArgs
.
forEach
(
firstArg
=
>
assert_throws_js
(
TypeError
(
)
=
>
new
constructor
(
firstArg
)
'
constructor
should
throw
a
TypeError
'
)
)
;
}
;
self
.
garbageCollect
=
async
(
)
=
>
{
if
(
self
.
TestUtils
?
.
gc
)
{
await
TestUtils
.
gc
(
)
;
}
else
if
(
self
.
gc
)
{
self
.
gc
(
)
;
}
else
if
(
self
.
GCController
)
{
GCController
.
collect
(
)
;
}
else
{
console
.
warn
(
'
Tests
are
running
without
the
ability
to
do
manual
garbage
collection
.
They
will
still
work
but
'
+
'
coverage
will
be
suboptimal
.
'
)
;
}
}
;
self
.
delay
=
ms
=
>
new
Promise
(
resolve
=
>
step_timeout
(
resolve
ms
)
)
;
self
.
flushAsyncEvents
=
(
)
=
>
delay
(
0
)
.
then
(
(
)
=
>
delay
(
0
)
)
.
then
(
(
)
=
>
delay
(
0
)
)
.
then
(
(
)
=
>
delay
(
0
)
)
;
self
.
assert_typed_array_equals
=
(
actual
expected
message
)
=
>
{
const
prefix
=
message
=
=
=
undefined
?
'
'
:
{
message
}
;
assert_equals
(
typeof
actual
'
object
'
{
prefix
}
type
is
object
)
;
assert_equals
(
actual
.
constructor
expected
.
constructor
{
prefix
}
constructor
)
;
assert_equals
(
actual
.
byteOffset
expected
.
byteOffset
{
prefix
}
byteOffset
)
;
assert_equals
(
actual
.
byteLength
expected
.
byteLength
{
prefix
}
byteLength
)
;
assert_equals
(
actual
.
buffer
.
byteLength
expected
.
buffer
.
byteLength
{
prefix
}
buffer
.
byteLength
)
;
assert_array_equals
(
[
.
.
.
actual
]
[
.
.
.
expected
]
{
prefix
}
contents
)
;
assert_array_equals
(
[
.
.
.
new
Uint8Array
(
actual
.
buffer
)
]
[
.
.
.
new
Uint8Array
(
expected
.
buffer
)
]
{
prefix
}
buffer
contents
)
;
}
;
