'
use
strict
'
;
self
.
delay
=
ms
=
>
new
Promise
(
resolve
=
>
step_timeout
(
resolve
ms
)
)
;
self
.
flushAsyncEvents
=
(
)
=
>
delay
(
0
)
.
then
(
(
)
=
>
delay
(
0
)
)
.
then
(
(
)
=
>
delay
(
0
)
)
.
then
(
(
)
=
>
delay
(
0
)
)
;
self
.
assert_typed_array_equals
=
(
actual
expected
message
)
=
>
{
const
prefix
=
message
=
=
=
undefined
?
'
'
:
{
message
}
;
assert_equals
(
typeof
actual
'
object
'
{
prefix
}
type
is
object
)
;
assert_equals
(
actual
.
constructor
expected
.
constructor
{
prefix
}
constructor
)
;
assert_equals
(
actual
.
byteOffset
expected
.
byteOffset
{
prefix
}
byteOffset
)
;
assert_equals
(
actual
.
byteLength
expected
.
byteLength
{
prefix
}
byteLength
)
;
assert_equals
(
actual
.
buffer
.
byteLength
expected
.
buffer
.
byteLength
{
prefix
}
buffer
.
byteLength
)
;
assert_array_equals
(
[
.
.
.
actual
]
[
.
.
.
expected
]
{
prefix
}
contents
)
;
assert_array_equals
(
[
.
.
.
new
Uint8Array
(
actual
.
buffer
)
]
[
.
.
.
new
Uint8Array
(
expected
.
buffer
)
]
{
prefix
}
buffer
contents
)
;
}
;
self
.
makePromiseAndResolveFunc
=
(
)
=
>
{
let
resolve
;
const
promise
=
new
Promise
(
r
=
>
{
resolve
=
r
;
}
)
;
return
[
promise
resolve
]
;
}
;
