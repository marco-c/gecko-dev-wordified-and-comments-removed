"
use
strict
"
;
window
.
onload
=
function
(
)
{
setup
(
{
explicit_timeout
:
true
}
)
;
var
serverStepDelay
=
250
;
var
mimeHtml
=
"
text
/
html
"
;
var
mimeText
=
"
text
/
plain
"
;
var
mimePng
=
"
image
/
png
"
;
var
mimeScript
=
"
application
/
javascript
"
;
var
mimeCss
=
"
text
/
css
"
;
var
greenPng
=
"
0x89504E470D0A1A0A0000000D494844520000006400000032010300000090FBECFD00000003504C544500FF00345EC0A80000000F49444154281563601805A36068020002BC00011BDDE3900000000049454E44AE426082
"
;
var
testCases
=
[
{
description
:
"
No
timeline
entry
for
about
:
blank
"
test
:
function
(
test
)
{
var
frame
=
document
.
createElement
(
"
iframe
"
)
;
frame
.
onload
=
createOnloadCallbackFn
(
test
frame
"
about
:
blank
"
function
(
initiator
entry
)
{
assert_equals
(
entry
undefined
"
Inserting
an
IFrame
with
a
src
of
'
about
:
blank
'
must
not
add
an
entry
to
the
timeline
.
"
)
;
assertInvariants
(
test
function
(
)
{
test
.
done
(
)
;
}
)
;
}
)
;
document
.
body
.
appendChild
(
frame
)
;
assert_equals
(
frame
.
contentWindow
.
location
.
href
"
about
:
blank
"
"
'
Src
'
of
new
<
iframe
>
must
be
'
about
:
blank
'
.
"
)
;
}
}
]
;
[
{
initiator
:
"
iframe
"
response
:
"
(
done
)
"
mime
:
mimeHtml
}
{
initiator
:
"
xmlhttprequest
"
response
:
"
(
done
)
"
mime
:
mimeText
}
{
initiator
:
"
script
"
response
:
'
"
"
;
'
mime
:
mimeScript
}
{
initiator
:
"
link
"
response
:
"
.
unused
{
}
"
mime
:
mimeCss
}
]
.
forEach
(
function
(
template
)
{
testCases
.
push
(
{
description
:
"
'
"
+
template
.
initiator
+
"
(
Populate
cache
)
:
The
initial
request
populates
the
cache
(
if
appropriate
)
.
"
test
:
function
(
test
)
{
initiateFetch
(
test
template
.
initiator
getSyntheticUrl
(
"
mime
:
"
+
encodeURIComponent
(
template
.
mime
)
+
"
&
send
:
"
+
encodeURIComponent
(
template
.
response
)
true
)
function
(
initiator
entry
)
{
test
.
done
(
)
;
}
)
;
}
}
)
;
testCases
.
push
(
{
description
:
"
'
"
+
template
.
initiator
+
"
(
Potentially
Cached
)
:
Immediately
fetch
the
same
URL
exercising
the
cache
hit
path
(
if
any
)
.
"
test
:
function
(
test
)
{
initiateFetch
(
test
template
.
initiator
getSyntheticUrl
(
"
mime
:
"
+
encodeURIComponent
(
template
.
mime
)
+
"
&
send
:
"
+
encodeURIComponent
(
template
.
response
)
true
)
function
(
initiator
entry
)
{
test
.
done
(
)
;
}
)
;
}
}
)
;
}
)
;
[
{
initiator
:
"
iframe
"
responsePart1
:
serverStepDelay
+
"
ms
;
"
responsePart2
:
(
serverStepDelay
*
2
)
+
"
ms
;
(
done
)
"
mime
:
mimeHtml
}
{
initiator
:
"
xmlhttprequest
"
responsePart1
:
serverStepDelay
+
"
ms
;
"
responsePart2
:
(
serverStepDelay
*
2
)
+
"
ms
;
(
done
)
"
mime
:
mimeText
}
{
initiator
:
"
script
"
responsePart1
:
'
"
'
responsePart2
:
'
"
;
'
mime
:
mimeScript
}
{
initiator
:
"
link
"
responsePart1
:
"
.
unused
{
"
responsePart2
:
"
}
"
mime
:
mimeCss
}
]
.
forEach
(
function
(
template
)
{
testCases
.
push
(
{
description
:
"
'
"
+
template
.
initiator
+
"
:
"
+
serverStepDelay
+
"
ms
delay
before
'
responseStart
'
another
"
+
serverStepDelay
+
"
ms
delay
before
'
responseEnd
'
.
"
test
:
function
(
test
)
{
initiateFetch
(
test
template
.
initiator
getSyntheticUrl
(
serverStepDelay
+
"
ms
"
+
"
&
mime
:
"
+
encodeURIComponent
(
template
.
mime
)
+
"
&
send
:
"
+
encodeURIComponent
(
template
.
responsePart1
)
+
"
&
"
+
serverStepDelay
+
"
ms
"
+
"
&
send
:
"
+
encodeURIComponent
(
template
.
responsePart2
)
)
function
(
initiator
entry
)
{
assert_equals
(
entry
.
redirectStart
0
"
When
no
redirect
occurs
redirectStart
must
be
0
.
"
)
;
assert_equals
(
entry
.
redirectEnd
0
"
When
no
redirect
occurs
redirectEnd
must
be
0
.
"
)
;
assert_greater_than_equal
(
entry
.
responseStart
entry
.
requestStart
+
serverStepDelay
"
'
responseStart
'
must
be
"
+
serverStepDelay
+
"
ms
later
than
'
requestStart
'
.
"
)
;
assert_greater_than_equal
(
entry
.
responseEnd
entry
.
responseStart
+
serverStepDelay
"
'
responseEnd
'
must
be
"
+
serverStepDelay
+
"
ms
later
than
'
responseStart
'
.
"
)
;
test
.
done
(
)
;
}
)
;
}
}
)
;
}
)
;
[
{
initiator
:
"
iframe
"
response
:
serverStepDelay
+
"
ms
;
redirect
;
"
+
(
serverStepDelay
*
2
)
+
"
ms
;
(
done
)
"
mime
:
mimeHtml
}
{
initiator
:
"
xmlhttprequest
"
response
:
serverStepDelay
+
"
ms
;
redirect
;
"
+
(
serverStepDelay
*
2
)
+
"
ms
;
(
done
)
"
mime
:
mimeText
}
{
initiator
:
"
script
"
response
:
'
"
"
;
'
mime
:
mimeScript
}
{
initiator
:
"
link
"
response
:
"
.
unused
{
}
"
mime
:
mimeCss
}
]
.
forEach
(
function
(
template
)
{
testCases
.
push
(
{
description
:
"
'
"
+
template
.
initiator
+
"
(
Redirected
)
:
"
+
serverStepDelay
+
"
ms
delay
before
'
redirectEnd
'
another
"
+
serverStepDelay
+
"
ms
delay
before
'
responseStart
'
.
"
test
:
function
(
test
)
{
initiateFetch
(
test
template
.
initiator
getSyntheticUrl
(
serverStepDelay
+
"
ms
"
+
"
&
redirect
:
"
+
encodeURIComponent
(
getSyntheticUrl
(
serverStepDelay
+
"
ms
"
+
"
&
mime
:
"
+
encodeURIComponent
(
template
.
mime
)
+
"
&
send
:
"
+
encodeURIComponent
(
template
.
response
)
)
)
)
function
(
initiator
entry
)
{
assert_equals
(
entry
.
startTime
entry
.
redirectStart
"
startTime
must
be
equal
to
redirectStart
.
"
)
;
assert_greater_than_equal
(
entry
.
redirectEnd
entry
.
redirectStart
+
serverStepDelay
"
'
redirectEnd
'
must
be
"
+
serverStepDelay
+
"
ms
later
than
'
redirectStart
'
.
"
)
;
assert_greater_than_equal
(
entry
.
responseStart
entry
.
requestStart
+
serverStepDelay
"
'
responseStart
'
must
be
"
+
serverStepDelay
+
"
ms
later
than
'
requestStart
'
.
"
)
;
test
.
done
(
)
;
}
)
;
}
}
)
;
}
)
;
[
{
initiator
:
"
iframe
"
response
:
"
(
done
)
"
mime
:
mimeHtml
}
{
initiator
:
"
xmlhttprequest
"
response
:
"
(
done
)
"
mime
:
mimeText
}
{
initiator
:
"
script
"
response
:
'
"
"
;
'
mime
:
mimeScript
}
{
initiator
:
"
link
"
response
:
"
.
unused
{
}
"
mime
:
mimeCss
}
]
.
forEach
(
function
(
template
)
{
testCases
.
push
(
{
description
:
"
'
"
+
template
.
initiator
+
"
"
+
serverStepDelay
+
"
ms
delay
in
headers
does
not
affect
responseStart
'
"
test
:
function
(
test
)
{
initiateFetch
(
test
template
.
initiator
getSyntheticUrl
(
"
status
:
200
"
+
"
&
flush
"
+
"
&
"
+
serverStepDelay
+
"
ms
"
+
"
&
mime
:
"
+
template
.
mime
+
"
&
send
:
"
+
encodeURIComponent
(
template
.
response
)
)
function
(
initiator
entry
)
{
assert_greater_than_equal
(
entry
.
responseEnd
entry
.
responseStart
+
serverStepDelay
"
Delay
after
HTTP
/
1
.
1
status
should
not
affect
'
responseStart
'
.
"
)
;
test
.
done
(
)
;
}
)
;
}
}
)
;
}
)
;
[
{
initiator
:
"
iframe
"
response
:
"
(
done
)
"
mime
:
mimeHtml
}
{
initiator
:
"
xmlhttprequest
"
response
:
"
(
done
)
"
mime
:
mimeText
}
{
initiator
:
"
script
"
response
:
'
"
"
;
'
mime
:
mimeScript
}
{
initiator
:
"
link
"
response
:
"
.
unused
{
}
"
mime
:
mimeCss
}
]
.
forEach
(
function
(
template
)
{
testCases
.
push
(
{
description
:
"
'
"
+
template
.
initiator
+
"
responseStart
uses
1XX
(
first
)
response
timings
'
"
test
:
function
(
test
)
{
initiateFetch
(
test
template
.
initiator
getSyntheticUrl
(
"
status
:
100
"
+
"
&
flush
"
+
"
&
"
+
serverStepDelay
+
"
ms
"
+
"
&
status
:
200
"
+
"
&
mime
:
"
+
template
.
mime
+
"
&
send
:
"
+
encodeURIComponent
(
template
.
response
)
)
function
(
initiator
entry
)
{
assert_greater_than_equal
(
entry
.
responseEnd
entry
.
responseStart
+
serverStepDelay
"
HTTP
/
1
.
1
1XX
(
first
)
response
should
determine
'
responseStart
'
timing
.
"
)
;
test
.
done
(
)
;
}
)
;
}
}
)
;
}
)
;
var
currentTestIndex
=
-
1
;
function
runNextCase
(
)
{
var
testCase
=
testCases
[
+
+
currentTestIndex
]
;
if
(
testCase
!
=
=
undefined
)
{
async_test
(
testCase
.
test
testCase
.
description
)
;
}
}
add_result_callback
(
runNextCase
)
;
runNextCase
(
)
;
function
assertInvariants
(
test
done
)
{
test
.
step_timeout
(
test
.
step_func
(
function
(
)
{
performance
.
getEntriesByType
(
"
resource
"
)
.
forEach
(
function
(
entry
index
entries
)
{
assertResourceEntryInvariants
(
entry
)
;
}
)
;
done
(
)
;
}
)
100
)
;
}
function
assertResourceEntryInvariants
(
actual
)
{
assert_not_equals
(
actual
.
name
"
about
:
blank
"
"
Fetch
for
'
about
:
blank
'
must
not
appear
in
timeline
.
"
)
;
assert_not_equals
(
actual
.
startTime
0
"
startTime
"
)
;
assert_in_array
(
actual
.
startTime
[
actual
.
redirectStart
actual
.
fetchStart
]
"
startTime
must
be
equal
to
redirectStart
or
fetchStart
.
"
)
;
assert_less_than_equal
(
actual
.
redirectStart
actual
.
redirectEnd
"
redirectStart
<
=
redirectEnd
"
)
;
assert_less_than_equal
(
actual
.
redirectEnd
actual
.
fetchStart
"
redirectEnd
<
=
fetchStart
"
)
;
assert_less_than_equal
(
actual
.
fetchStart
actual
.
domainLookupStart
"
fetchStart
<
=
domainLookupStart
"
)
;
assert_less_than_equal
(
actual
.
domainLookupStart
actual
.
domainLookupEnd
"
domainLookupStart
<
=
domainLookupEnd
"
)
;
assert_less_than_equal
(
actual
.
domainLookupEnd
actual
.
connectStart
"
domainLookupEnd
<
=
connectStart
"
)
;
assert_true
(
actual
.
secureConnectionStart
=
=
undefined
|
|
actual
.
secureConnectionStart
=
=
0
|
|
actual
.
secureConnectionStart
>
=
actual
.
connectEnd
"
secureConnectionStart
time
"
)
;
assert_less_than_equal
(
actual
.
connectStart
actual
.
connectEnd
"
connectStart
<
=
connectEnd
"
)
;
assert_less_than_equal
(
actual
.
connectEnd
actual
.
requestStart
"
connectEnd
<
=
requestStart
"
)
;
assert_less_than_equal
(
actual
.
requestStart
actual
.
responseStart
"
requestStart
<
=
responseStart
"
)
;
assert_less_than_equal
(
actual
.
responseStart
actual
.
responseEnd
"
responseStart
<
=
responseEnd
"
)
;
}
function
canonicalize
(
url
)
{
var
div
=
document
.
createElement
(
'
div
'
)
;
div
.
innerHTML
=
"
<
a
>
<
/
a
>
"
;
div
.
firstChild
.
href
=
url
;
div
.
innerHTML
=
div
.
innerHTML
;
return
div
.
firstChild
.
href
;
}
function
createUniqueQueryArgument
(
)
{
var
result
=
"
ignored_
"
+
Date
.
now
(
)
+
"
-
"
+
(
(
Math
.
random
(
)
*
0xFFFFFFFF
)
>
>
>
0
)
+
"
-
"
+
syntheticRequestCount
;
return
result
;
}
var
syntheticRequestCount
=
0
;
function
getSyntheticUrl
(
commands
allowCache
)
{
syntheticRequestCount
+
+
;
var
url
=
canonicalize
(
"
.
/
SyntheticResponse
.
py
"
)
+
"
?
"
+
commands
;
if
(
allowCache
!
=
=
true
)
{
url
+
=
"
&
"
+
createUniqueQueryArgument
(
)
;
}
return
url
;
}
function
initiateFetch
(
test
initiatorType
url
onloadCallback
)
{
assertInvariants
(
test
function
(
)
{
log
(
"
-
-
-
Begin
:
"
+
url
)
;
switch
(
initiatorType
)
{
case
"
script
"
:
case
"
img
"
:
case
"
iframe
"
:
{
var
element
=
document
.
createElement
(
initiatorType
)
;
document
.
body
.
appendChild
(
element
)
;
element
.
onload
=
createOnloadCallbackFn
(
test
element
url
onloadCallback
)
;
element
.
src
=
url
;
break
;
}
case
"
link
"
:
{
var
element
=
document
.
createElement
(
initiatorType
)
;
element
.
rel
=
"
stylesheet
"
;
document
.
body
.
appendChild
(
element
)
;
element
.
onload
=
createOnloadCallbackFn
(
test
element
url
onloadCallback
)
;
element
.
href
=
url
;
break
;
}
case
"
xmlhttprequest
"
:
{
var
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
'
GET
'
url
true
)
;
xhr
.
onreadystatechange
=
createOnloadCallbackFn
(
test
xhr
url
onloadCallback
)
;
xhr
.
send
(
)
;
break
;
}
default
:
assert_unreached
(
"
Unsupported
initiatorType
'
"
+
initiatorType
+
"
'
.
"
)
;
break
;
}
}
)
;
}
function
createOnloadCallbackFn
(
test
initiator
url
onloadCallback
)
{
var
beforeEntryCount
=
performance
.
getEntriesByType
(
"
resource
"
)
.
length
;
return
test
.
step_func
(
function
(
)
{
if
(
Object
.
getPrototypeOf
(
initiator
)
=
=
=
XMLHttpRequest
.
prototype
)
{
if
(
initiator
.
readyState
!
=
4
)
{
return
;
}
}
var
entries
=
performance
.
getEntriesByType
(
"
resource
"
)
;
var
candidateEntry
=
entries
[
entries
.
length
-
1
]
;
switch
(
entries
.
length
-
beforeEntryCount
)
{
case
0
:
candidateEntry
=
undefined
;
break
;
case
1
:
assert_equals
(
candidateEntry
.
name
url
"
'
name
'
did
not
match
expected
'
url
'
.
"
)
;
logResourceEntry
(
candidateEntry
)
;
break
;
default
:
assert_unreached
(
"
At
most
1
entry
should
be
added
to
the
performance
timeline
during
a
fetch
.
"
)
;
break
;
}
assertInvariants
(
test
function
(
)
{
onloadCallback
(
initiator
candidateEntry
)
;
}
)
;
}
)
;
}
function
log
(
text
)
{
var
output
=
document
.
getElementById
(
"
output
"
)
;
output
.
textContent
+
=
text
+
"
\
r
\
n
"
;
}
add_completion_callback
(
function
(
)
{
var
output
=
document
.
getElementById
(
"
output
"
)
;
var
button
=
document
.
createElement
(
'
button
'
)
;
output
.
parentNode
.
insertBefore
(
button
output
)
;
button
.
onclick
=
function
(
)
{
var
showButton
=
output
.
style
.
display
=
=
'
none
'
;
output
.
style
.
display
=
showButton
?
null
:
'
none
'
;
button
.
textContent
=
showButton
?
'
Hide
details
'
:
'
Show
details
'
;
}
button
.
onclick
(
)
;
var
iframes
=
document
.
querySelectorAll
(
'
iframe
'
)
;
for
(
var
i
=
0
;
i
<
iframes
.
length
;
i
+
+
)
iframes
[
i
]
.
parentNode
.
removeChild
(
iframes
[
i
]
)
;
}
)
;
function
logResourceEntry
(
entry
)
{
log
(
"
[
"
+
entry
.
entryType
+
"
]
"
+
entry
.
name
)
;
[
"
startTime
"
"
redirectStart
"
"
redirectEnd
"
"
fetchStart
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
"
secureConnectionStart
"
"
connectEnd
"
"
requestStart
"
"
responseStart
"
"
responseEnd
"
]
.
forEach
(
function
(
property
index
array
)
{
var
value
=
entry
[
property
]
;
log
(
property
+
"
:
\
t
"
+
value
)
;
}
)
;
log
(
"
\
r
\
n
"
)
;
}
}
;
