const
assert_all_equal_
=
(
entry
attributes
)
=
>
{
let
first
=
attributes
[
0
]
;
attributes
.
slice
(
1
)
.
forEach
(
other
=
>
{
assert_equals
(
entry
[
first
]
entry
[
other
]
{
first
}
should
be
equal
to
{
other
}
)
;
}
)
;
}
const
assert_ordered_
=
(
entry
attributes
)
=
>
{
let
before
=
attributes
[
0
]
;
attributes
.
slice
(
1
)
.
forEach
(
after
=
>
{
assert_greater_than_equal
(
entry
[
after
]
entry
[
before
]
{
after
}
should
be
greater
than
{
before
}
)
;
before
=
after
;
}
)
;
}
const
assert_zeroed_
=
(
entry
attributes
)
=
>
{
attributes
.
forEach
(
attribute
=
>
{
assert_equals
(
entry
[
attribute
]
0
{
attribute
}
should
be
0
)
;
}
)
;
}
const
assert_not_negative_
=
(
entry
attributes
)
=
>
{
attributes
.
forEach
(
attribute
=
>
{
assert_greater_than_equal
(
entry
[
attribute
]
0
{
attribute
}
should
be
greater
than
or
equal
to
0
)
;
}
)
;
}
const
assert_positive_
=
(
entry
attributes
)
=
>
{
attributes
.
forEach
(
attribute
=
>
{
assert_greater_than
(
entry
[
attribute
]
0
{
attribute
}
should
be
greater
than
0
)
;
}
)
;
}
const
invariants
=
{
assert_tao_pass_no_redirect_http
:
entry
=
>
{
assert_ordered_
(
entry
[
"
fetchStart
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
"
connectEnd
"
"
requestStart
"
"
responseStart
"
"
responseEnd
"
]
)
;
assert_zeroed_
(
entry
[
"
workerStart
"
"
secureConnectionStart
"
"
redirectStart
"
"
redirectEnd
"
]
)
;
assert_not_negative_
(
entry
[
"
duration
"
]
)
;
assert_positive_
(
entry
[
"
fetchStart
"
"
transferSize
"
"
encodedBodySize
"
"
decodedBodySize
"
]
)
;
}
assert_tao_pass_no_redirect_http_empty
:
entry
=
>
{
assert_ordered_
(
entry
[
"
fetchStart
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
"
connectEnd
"
"
requestStart
"
"
responseStart
"
"
responseEnd
"
]
)
;
assert_zeroed_
(
entry
[
"
workerStart
"
"
secureConnectionStart
"
"
redirectStart
"
"
redirectEnd
"
"
encodedBodySize
"
"
decodedBodySize
"
]
)
;
assert_not_negative_
(
entry
[
"
duration
"
]
)
;
assert_positive_
(
entry
[
"
fetchStart
"
"
transferSize
"
]
)
;
}
assert_tao_pass_no_redirect_https
:
entry
=
>
{
assert_ordered_
(
entry
[
"
fetchStart
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
secureConnectionStart
"
"
connectStart
"
"
connectEnd
"
"
requestStart
"
"
responseStart
"
"
responseEnd
"
]
)
;
assert_zeroed_
(
entry
[
"
workerStart
"
"
redirectStart
"
"
redirectEnd
"
]
)
;
assert_not_negative_
(
entry
[
"
duration
"
]
)
;
assert_positive_
(
entry
[
"
fetchStart
"
"
transferSize
"
"
encodedBodySize
"
"
decodedBodySize
"
]
)
;
}
assert_tao_pass_with_redirect_https
:
entry
=
>
{
assert_ordered_
(
entry
[
"
fetchStart
"
"
redirectStart
"
"
redirectEnd
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
secureConnectionStart
"
"
connectStart
"
"
connectEnd
"
"
requestStart
"
"
responseStart
"
"
responseEnd
"
]
)
;
assert_zeroed_
(
entry
[
"
workerStart
"
]
)
;
assert_not_negative_
(
entry
[
"
duration
"
]
)
;
assert_positive_
(
entry
[
"
fetchStart
"
"
transferSize
"
"
encodedBodySize
"
"
decodedBodySize
"
]
)
;
}
assert_tao_pass_304_not_modified_http
:
entry
=
>
{
assert_ordered_
(
entry
[
"
fetchStart
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
"
connectEnd
"
"
requestStart
"
"
responseStart
"
"
responseEnd
"
]
)
;
assert_zeroed_
(
entry
[
"
workerStart
"
"
secureConnectionStart
"
"
redirectStart
"
"
redirectEnd
"
"
encodedBodySize
"
"
decodedBodySize
"
]
)
;
assert_not_negative_
(
entry
[
"
duration
"
]
)
;
assert_positive_
(
entry
[
"
fetchStart
"
"
transferSize
"
]
)
;
}
assert_tao_pass_304_not_modified_https
:
entry
=
>
{
assert_ordered_
(
entry
[
"
fetchStart
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
secureConnectionStart
"
"
connectStart
"
"
connectEnd
"
"
requestStart
"
"
responseStart
"
"
responseEnd
"
]
)
;
assert_zeroed_
(
entry
[
"
workerStart
"
"
redirectStart
"
"
redirectEnd
"
"
encodedBodySize
"
"
decodedBodySize
"
]
)
;
assert_not_negative_
(
entry
[
"
duration
"
]
)
;
assert_positive_
(
entry
[
"
fetchStart
"
"
transferSize
"
]
)
;
}
assert_connection_reused
:
entry
=
>
{
assert_all_equal_
(
entry
[
"
fetchStart
"
"
connectStart
"
"
connectEnd
"
"
domainLookupStart
"
"
domainLookupEnd
"
]
)
;
}
assert_same_origin_redirected_resource
:
entry
=
>
{
assert_positive_
(
entry
[
"
redirectStart
"
]
)
;
assert_equals
(
entry
.
redirectStart
entry
.
startTime
"
redirectStart
should
be
equal
to
startTime
"
)
;
assert_ordered_
(
entry
[
"
redirectStart
"
"
redirectEnd
"
"
fetchStart
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
]
)
;
}
assert_cross_origin_redirected_resource
:
entry
=
>
{
assert_zeroed_
(
entry
[
"
redirectStart
"
"
redirectEnd
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
"
connectEnd
"
"
secureConnectionStart
"
"
requestStart
"
"
responseStart
"
]
)
;
assert_positive_
(
entry
[
"
fetchStart
"
"
responseEnd
"
]
)
;
assert_ordered_
(
entry
[
"
fetchStart
"
"
responseEnd
"
]
)
;
}
assert_http_to_cross_origin_redirected_resource
:
entry
=
>
{
assert_zeroed_
(
entry
[
"
redirectStart
"
"
redirectEnd
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
"
connectEnd
"
"
secureConnectionStart
"
"
requestStart
"
"
responseStart
"
]
)
;
assert_positive_
(
entry
[
"
fetchStart
"
"
responseEnd
"
]
)
;
assert_ordered_
(
entry
[
"
fetchStart
"
"
responseEnd
"
]
)
;
}
assert_tao_enabled_cross_origin_redirected_resource
:
entry
=
>
{
assert_positive_
(
entry
[
"
redirectStart
"
]
)
;
assert_ordered_
(
entry
[
"
redirectStart
"
"
redirectEnd
"
"
fetchStart
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
"
secureConnectionStart
"
"
connectEnd
"
"
requestStart
"
"
responseStart
"
"
responseEnd
"
]
)
;
}
assert_http_to_tao_enabled_cross_origin_https_redirected_resource
:
entry
=
>
{
assert_zeroed_
(
entry
[
"
secureConnectionStart
"
]
)
;
assert_positive_
(
entry
[
"
redirectStart
"
]
)
;
assert_ordered_
(
entry
[
"
redirectStart
"
"
redirectEnd
"
"
fetchStart
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
"
connectEnd
"
"
requestStart
"
"
responseStart
"
"
responseEnd
"
]
)
;
}
assert_same_origin_redirected_from_cross_origin_resource
:
entry
=
>
{
assert_zeroed_
(
entry
[
"
workerStart
"
"
redirectStart
"
"
redirectEnd
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
"
connectEnd
"
"
secureConnectionStart
"
"
requestStart
"
"
responseStart
"
"
transferSize
"
"
encodedBodySize
"
"
decodedBodySize
"
]
)
;
assert_ordered_
(
entry
[
"
fetchStart
"
"
responseEnd
"
]
)
;
assert_equals
(
entry
.
fetchStart
entry
.
startTime
"
fetchStart
must
equal
startTime
"
)
;
}
assert_tao_failure_resource
:
entry
=
>
{
assert_equals
(
entry
.
entryType
"
resource
"
"
entryType
must
always
be
'
resource
'
"
)
;
assert_positive_
(
entry
[
"
startTime
"
]
)
;
assert_not_negative_
(
entry
[
"
duration
"
]
)
;
assert_zeroed_
(
entry
[
"
redirectStart
"
"
redirectEnd
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
"
connectEnd
"
"
secureConnectionStart
"
"
requestStart
"
"
responseStart
"
"
transferSize
"
"
encodedBodySize
"
"
decodedBodySize
"
]
)
;
}
}
;
const
attribute_test_internal
=
(
loader
path
validator
run_test
test_label
)
=
>
{
promise_test
(
async
(
)
=
>
{
let
loaded_entry
=
new
Promise
(
(
resolve
reject
)
=
>
{
new
PerformanceObserver
(
(
entry_list
self
)
=
>
{
try
{
const
name_matches
=
entry_list
.
getEntries
(
)
.
forEach
(
entry
=
>
{
if
(
entry
.
name
.
includes
(
path
)
)
{
resolve
(
entry
)
;
}
}
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
.
observe
(
{
"
type
"
:
"
resource
"
}
)
;
}
)
;
await
loader
(
path
validator
)
;
const
timeout
=
new
Promise
(
r
=
>
step_timeout
(
(
)
=
>
{
console
.
log
(
"
Timeout
was
reached
before
entry
fired
"
)
;
r
(
null
)
;
}
2000
)
)
;
const
entry
=
await
Promise
.
race
(
[
loaded_entry
timeout
]
)
;
assert_not_equals
(
entry
null
'
No
entry
was
recieved
'
)
;
run_test
(
entry
)
;
}
test_label
)
;
}
;
const
attribute_test
=
(
loader
path
run_test
test_label
)
=
>
{
attribute_test_internal
(
loader
path
(
)
=
>
{
}
run_test
test_label
)
;
}
;
const
attribute_test_with_validator
=
(
loader
path
validator
run_test
test_label
)
=
>
{
attribute_test_internal
(
loader
path
validator
run_test
test_label
)
;
}
;
const
network_error_entry_test
=
(
originalURL
args
label
)
=
>
{
const
url
=
new
URL
(
originalURL
location
.
href
)
;
const
search
=
new
URLSearchParams
(
url
.
search
.
substr
(
1
)
)
;
const
timeBefore
=
performance
.
now
(
)
;
loader
=
(
)
=
>
new
Promise
(
resolve
=
>
fetch
(
url
args
)
.
catch
(
resolve
)
)
;
attribute_test
(
loader
url
(
)
=
>
{
const
timeAfter
=
performance
.
now
(
)
;
const
names
=
performance
.
getEntriesByType
(
'
resource
'
)
.
filter
(
e
=
>
e
.
initiatorType
=
=
=
'
fetch
'
)
.
map
(
e
=
>
e
.
name
)
;
const
entries
=
performance
.
getEntriesByName
(
url
.
toString
(
)
)
;
assert_equals
(
entries
.
length
1
'
resource
timing
entry
for
network
error
'
)
;
const
entry
=
entries
[
0
]
assert_equals
(
entry
.
startTime
entry
.
fetchStart
'
startTime
and
fetchStart
should
be
equal
'
)
;
assert_greater_than_equal
(
entry
.
startTime
timeBefore
'
startTime
and
fetchStart
should
be
greater
than
the
time
before
fetching
'
)
;
assert_greater_than_equal
(
timeAfter
entry
.
responseEnd
'
endTime
should
be
less
than
the
time
right
after
returning
from
the
fetch
'
)
;
invariants
.
assert_tao_failure_resource
(
entry
)
;
}
A
ResourceTiming
entry
should
be
created
for
network
error
of
type
{
label
}
)
;
}
