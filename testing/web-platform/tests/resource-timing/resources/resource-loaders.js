const
load
=
{
_cache_bust_value
:
Math
.
random
(
)
.
toString
(
)
.
substr
(
2
)
cache_bust
:
path
=
>
{
let
url
=
new
URL
(
path
location
.
origin
)
;
url
.
href
+
=
(
url
.
href
.
includes
(
"
?
"
)
)
?
'
&
'
:
'
?
'
;
url
.
href
+
=
"
unique
=
"
+
load
.
_cache_bust_value
+
+
return
url
.
href
;
}
image
:
path
=
>
{
return
new
Promise
(
resolve
=
>
{
const
img
=
new
Image
(
)
;
img
.
onload
=
img
.
onerror
=
resolve
;
img
.
src
=
load
.
cache_bust
(
path
)
;
}
)
;
}
font
:
path
=
>
{
const
div
=
document
.
createElement
(
'
div
'
)
;
div
.
innerHTML
=
<
style
>
font
-
face
{
font
-
family
:
ahem
;
src
:
url
(
'
{
load
.
cache_bust
(
path
)
}
'
)
;
}
<
/
style
>
<
div
style
=
"
font
-
family
:
ahem
;
"
>
This
fetches
ahem
font
.
<
/
div
>
;
document
.
body
.
appendChild
(
div
)
;
return
document
.
fonts
.
ready
.
then
(
(
)
=
>
{
document
.
body
.
removeChild
(
div
)
;
}
)
;
}
stylesheet
:
async
path
=
>
{
const
link
=
document
.
createElement
(
"
link
"
)
;
link
.
rel
=
"
stylesheet
"
;
link
.
type
=
"
text
/
css
"
;
link
.
href
=
load
.
cache_bust
(
path
)
;
const
loaded
=
new
Promise
(
resolve
=
>
{
link
.
onload
=
link
.
onerror
=
resolve
;
}
)
;
document
.
head
.
appendChild
(
link
)
;
await
loaded
;
document
.
head
.
removeChild
(
link
)
;
}
iframe_with_attrs
:
async
(
path
attribute_map
validator
)
=
>
{
const
frame
=
document
.
createElement
(
"
iframe
"
)
;
if
(
attribute_map
instanceof
Object
)
{
for
(
const
[
key
value
]
of
Object
.
entries
(
attribute_map
)
)
{
frame
[
key
]
=
value
;
}
}
const
loaded
=
new
Promise
(
resolve
=
>
{
frame
.
onload
=
frame
.
onerror
=
resolve
;
}
)
;
frame
.
src
=
load
.
cache_bust
(
path
)
;
document
.
body
.
appendChild
(
frame
)
;
await
loaded
;
if
(
validator
instanceof
Function
)
{
validator
(
frame
)
;
}
document
.
body
.
removeChild
(
frame
)
;
}
iframe
:
async
(
path
validator
)
=
>
{
return
load
.
iframe_with_attrs
(
path
undefined
validator
)
;
}
script
:
async
path
=
>
{
const
script
=
document
.
createElement
(
"
script
"
)
;
const
loaded
=
new
Promise
(
resolve
=
>
{
script
.
onload
=
script
.
onerror
=
resolve
;
}
)
;
script
.
src
=
load
.
cache_bust
(
path
)
;
document
.
body
.
appendChild
(
script
)
;
await
loaded
;
document
.
body
.
removeChild
(
script
)
;
}
object
:
async
(
path
type
)
=
>
{
const
object
=
document
.
createElement
(
"
object
"
)
;
const
loaded
=
new
Promise
(
resolve
=
>
{
object
.
onload
=
object
.
onerror
=
resolve
;
}
)
;
object
.
data
=
load
.
cache_bust
(
path
)
;
if
(
type
)
{
object
.
type
=
type
;
}
object
.
style
=
"
width
:
0px
;
height
:
0px
"
;
document
.
body
.
appendChild
(
object
)
;
await
loaded
;
document
.
body
.
removeChild
(
object
)
;
}
xhr_sync
:
async
(
path
headers
)
=
>
{
const
xhr
=
new
XMLHttpRequest
;
xhr
.
open
(
"
GET
"
path
false
)
;
if
(
headers
instanceof
Object
)
{
for
(
const
[
key
value
]
of
Object
.
entries
(
headers
)
)
{
xhr
.
setRequestHeader
(
key
value
)
;
}
}
xhr
.
send
(
)
;
}
}
;
