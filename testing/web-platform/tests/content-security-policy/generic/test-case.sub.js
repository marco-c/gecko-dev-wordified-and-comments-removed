function
TestCase
(
scenarios
sanityChecker
)
{
function
runTest
(
scenario
)
{
sanityChecker
.
checkScenario
(
scenario
subresourceMap
)
;
const
urls
=
getRequestURLs
(
scenario
.
subresource
scenario
.
origin
scenario
.
redirection
)
;
const
subresource
=
{
subresourceType
:
scenario
.
subresource
url
:
urls
.
testUrl
policyDeliveries
:
scenario
.
subresource_policy_deliveries
}
;
let
violationEventResolve
;
const
violationEventPromise
=
new
Promise
(
resolve
=
>
{
violationEventResolve
=
resolve
;
}
)
;
promise_test
(
async
t
=
>
{
await
xhrRequest
(
urls
.
announceUrl
)
;
const
violationEvents
=
[
]
;
const
listener
=
e
=
>
{
violationEvents
.
push
(
e
)
;
}
;
document
.
addEventListener
(
'
securitypolicyviolation
'
listener
)
;
try
{
const
mainPromise
=
invokeRequest
(
subresource
scenario
.
source_context_list
)
;
if
(
scenario
.
expectation
=
=
=
'
allowed
'
)
{
await
mainPromise
;
}
else
{
await
mainPromise
.
then
(
t
.
unreached_func
(
'
main
promise
resolved
unexpectedly
'
)
)
.
catch
(
_
=
>
{
}
)
;
}
}
finally
{
let
timeout
=
0
;
if
(
scenario
.
subresource
.
startsWith
(
'
worklet
-
'
)
&
&
navigator
.
userAgent
.
includes
(
"
Firefox
/
"
)
)
{
timeout
=
10
;
}
else
if
(
scenario
.
subresource
.
startsWith
(
'
worker
-
'
)
&
&
navigator
.
userAgent
.
includes
(
"
Servo
/
"
)
)
{
timeout
=
1
;
}
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
timeout
)
)
;
violationEventResolve
(
violationEvents
)
;
document
.
removeEventListener
(
'
securitypolicyviolation
'
listener
)
;
}
const
assertResult
=
await
xhrRequest
(
urls
.
assertUrl
)
;
assert_equals
(
assertResult
.
status
scenario
.
expectation
"
The
resource
request
should
be
'
"
+
scenario
.
expectation
+
"
'
.
"
)
;
}
scenario
.
test_description
)
;
promise_test
(
async
_
=
>
{
const
violationEvents
=
await
violationEventPromise
;
if
(
scenario
.
expectation
=
=
=
'
allowed
'
)
{
assert_array_equals
(
violationEvents
[
]
'
no
violation
events
should
be
fired
'
)
;
}
else
{
assert_equals
(
violationEvents
.
length
1
'
One
violation
event
should
be
fired
'
)
;
}
}
scenario
.
test_description
+
"
:
securitypolicyviolation
"
)
;
}
function
runTests
(
)
{
for
(
const
scenario
of
scenarios
)
{
runTest
(
scenario
)
;
}
}
return
{
start
:
runTests
}
;
}
