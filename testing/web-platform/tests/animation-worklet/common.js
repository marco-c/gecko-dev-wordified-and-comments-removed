'
use
strict
'
;
function
registerPassthroughAnimator
(
)
{
return
runInAnimationWorklet
(
registerAnimator
(
'
passthrough
'
class
{
animate
(
currentTime
effect
)
{
effect
.
localTime
=
currentTime
;
}
}
)
;
)
;
}
function
registerConstantLocalTimeAnimator
(
localTime
)
{
return
runInAnimationWorklet
(
registerAnimator
(
'
constant_time
'
class
{
animate
(
currentTime
effect
)
{
effect
.
localTime
=
{
localTime
}
;
}
}
)
;
)
;
}
function
runInAnimationWorklet
(
code
)
{
return
CSS
.
animationWorklet
.
addModule
(
URL
.
createObjectURL
(
new
Blob
(
[
code
]
{
type
:
'
text
/
javascript
'
}
)
)
)
;
}
function
approxEquals
(
actual
expected
)
{
const
epsilon
=
0
.
005
;
const
lowerBound
=
(
expected
-
epsilon
)
<
actual
;
const
upperBound
=
(
expected
+
epsilon
)
>
actual
;
return
lowerBound
&
&
upperBound
;
}
function
waitForAsyncAnimationFrames
(
count
)
{
return
waitForAnimationFrames
(
count
+
1
)
;
}
async
function
waitForAnimationFrameWithCondition
(
condition
)
{
do
{
await
new
Promise
(
window
.
requestAnimationFrame
)
;
}
while
(
!
condition
(
)
)
}
async
function
waitForDocumentTimelineAdvance
(
)
{
const
timeAtStart
=
document
.
timeline
.
currentTime
;
do
{
await
new
Promise
(
window
.
requestAnimationFrame
)
;
}
while
(
timeAtStart
=
=
=
document
.
timeline
.
currentTime
)
}
async
function
waitForNotNullLocalTime
(
animation
)
{
await
waitForAnimationFrameWithCondition
(
_
=
>
{
return
animation
.
effect
.
getComputedTiming
(
)
.
localTime
!
=
=
null
;
}
)
;
}
