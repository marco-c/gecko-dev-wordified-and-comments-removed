function
getSubresourceOrigin
(
originType
)
{
const
httpProtocol
=
"
http
"
;
const
httpsProtocol
=
"
https
"
;
const
wsProtocol
=
"
ws
"
;
const
wssProtocol
=
"
wss
"
;
const
sameOriginHost
=
"
{
{
host
}
}
"
;
const
crossOriginHost
=
"
{
{
domains
[
www1
]
}
}
"
;
const
httpPort
=
getNormalizedPort
(
parseInt
(
"
{
{
ports
[
http
]
[
0
]
}
}
"
10
)
)
;
const
httpsPort
=
getNormalizedPort
(
parseInt
(
"
{
{
ports
[
https
]
[
0
]
}
}
"
10
)
)
;
const
wsPort
=
getNormalizedPort
(
parseInt
(
"
{
{
ports
[
ws
]
[
0
]
}
}
"
10
)
)
;
const
wssPort
=
getNormalizedPort
(
parseInt
(
"
{
{
ports
[
wss
]
[
0
]
}
}
"
10
)
)
;
const
originMap
=
{
"
same
-
https
"
:
httpsProtocol
+
"
:
/
/
"
+
sameOriginHost
+
httpsPort
"
same
-
http
"
:
httpProtocol
+
"
:
/
/
"
+
sameOriginHost
+
httpPort
"
cross
-
https
"
:
httpsProtocol
+
"
:
/
/
"
+
crossOriginHost
+
httpsPort
"
cross
-
http
"
:
httpProtocol
+
"
:
/
/
"
+
crossOriginHost
+
httpPort
"
same
-
wss
"
:
wssProtocol
+
"
:
/
/
"
+
sameOriginHost
+
wssPort
"
same
-
ws
"
:
wsProtocol
+
"
:
/
/
"
+
sameOriginHost
+
wsPort
"
cross
-
wss
"
:
wssProtocol
+
"
:
/
/
"
+
crossOriginHost
+
wssPort
"
cross
-
ws
"
:
wsProtocol
+
"
:
/
/
"
+
crossOriginHost
+
wsPort
}
;
return
originMap
[
originType
]
;
}
function
stripUrlForUseAsReferrer
(
url
)
{
return
url
.
replace
(
/
#
.
*
/
"
"
)
;
}
function
invokeScenario
(
scenario
sourceContextList
)
{
const
originTypeConversion
=
{
"
same
-
origin
-
http
"
:
"
same
-
http
"
"
same
-
origin
-
https
"
:
"
same
-
https
"
"
cross
-
origin
-
http
"
:
"
cross
-
http
"
"
cross
-
origin
-
https
"
:
"
cross
-
https
"
}
;
const
urls
=
getRequestURLs
(
scenario
.
subresource
originTypeConversion
[
scenario
.
origin
+
'
-
'
+
scenario
.
target_protocol
]
scenario
.
redirection
)
;
const
deliveryTypeConversion
=
{
"
attr
-
referrer
"
:
"
attr
"
"
rel
-
noreferrer
"
:
"
rel
-
noref
"
}
;
const
delivery
=
{
deliveryType
:
deliveryTypeConversion
[
scenario
.
delivery_method
]
key
:
"
referrerPolicy
"
value
:
scenario
.
referrer_policy
}
;
const
subresource
=
{
subresourceType
:
scenario
.
subresource
url
:
urls
.
testUrl
policyDeliveries
:
[
delivery
]
}
;
return
invokeRequest
(
subresource
sourceContextList
|
|
[
]
)
;
}
function
ReferrerPolicyTestCase
(
scenario
testDescription
sanityChecker
)
{
if
(
scenario
.
subresource
=
=
"
fetch
-
request
"
&
&
!
window
.
fetch
)
{
return
{
start
:
function
(
)
{
test
(
function
(
)
{
assert_true
(
true
)
;
}
"
[
ReferrerPolicyTestCase
]
Skipping
test
:
Fetch
is
not
supported
.
"
)
;
}
}
;
}
sanityChecker
.
checkScenario
(
scenario
)
;
const
referrerUrlResolver
=
{
"
omitted
"
:
function
(
sourceUrl
)
{
return
undefined
;
}
"
origin
"
:
function
(
sourceUrl
)
{
return
new
URL
(
sourceUrl
)
.
origin
+
"
/
"
;
}
"
stripped
-
referrer
"
:
function
(
sourceUrl
)
{
return
stripUrlForUseAsReferrer
(
sourceUrl
)
;
}
}
;
const
checkResult
=
(
expectation
result
)
=
>
{
let
currentURL
=
location
.
toString
(
)
;
const
expectedReferrerUrl
=
referrerUrlResolver
[
expectation
]
(
currentURL
)
;
assert_equals
(
result
.
referrer
expectedReferrerUrl
"
Reported
Referrer
URL
is
'
"
+
expectation
+
"
'
.
"
)
;
assert_equals
(
result
.
headers
.
referer
expectedReferrerUrl
"
Reported
Referrer
URL
from
HTTP
header
is
'
"
+
expectedReferrerUrl
+
"
'
"
)
;
}
;
function
runTest
(
)
{
function
historyBackPromise
(
t
scenario
)
{
history
.
back
(
)
;
return
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
'
popstate
'
resolve
{
once
:
true
}
)
;
if
(
scenario
.
subresource
=
=
=
'
a
-
tag
'
)
{
t
.
step_timeout
(
resolve
1000
)
;
}
}
)
;
}
promise_test
(
_
=
>
{
return
invokeScenario
(
scenario
)
.
then
(
result
=
>
checkResult
(
scenario
.
referrer_url
result
)
)
;
}
testDescription
)
;
if
(
scenario
.
referrer_url
=
=
"
stripped
-
referrer
"
)
{
promise_test
(
t
=
>
{
history
.
pushState
(
null
null
"
/
"
)
;
history
.
replaceState
(
null
null
"
A
"
.
repeat
(
4096
-
location
.
href
.
length
-
1
)
)
;
return
invokeScenario
(
scenario
)
.
then
(
result
=
>
checkResult
(
scenario
.
referrer_url
result
)
)
.
finally
(
_
=
>
historyBackPromise
(
t
scenario
)
)
;
}
"
Referer
header
with
length
<
4k
is
not
stripped
to
an
origin
.
"
)
;
promise_test
(
t
=
>
{
history
.
pushState
(
null
null
"
/
"
)
;
history
.
replaceState
(
null
null
"
A
"
.
repeat
(
4096
-
location
.
href
.
length
)
)
;
return
invokeScenario
(
scenario
)
.
then
(
result
=
>
checkResult
(
scenario
.
referrer_url
result
)
)
.
finally
(
_
=
>
historyBackPromise
(
t
scenario
)
)
;
}
"
Referer
header
with
length
=
=
4k
is
not
stripped
to
an
origin
.
"
)
;
promise_test
(
t
=
>
{
history
.
pushState
(
null
null
"
/
"
)
;
history
.
replaceState
(
null
null
"
A
"
.
repeat
(
4096
-
location
.
href
.
length
+
1
)
)
;
return
invokeScenario
(
scenario
)
.
then
(
result
=
>
checkResult
(
"
origin
"
result
)
)
.
finally
(
_
=
>
historyBackPromise
(
t
scenario
)
)
;
}
"
Referer
header
with
length
>
4k
is
stripped
to
an
origin
.
"
)
;
}
if
(
scenario
.
subresource
!
=
=
"
img
-
tag
"
)
{
return
;
}
promise_test
(
_
=
>
{
const
sourceContextList
=
[
{
sourceContextType
:
"
srcdoc
"
}
]
;
return
invokeScenario
(
scenario
sourceContextList
)
.
then
(
result
=
>
checkResult
(
scenario
.
referrer_url
result
)
)
;
}
testDescription
+
"
(
srcdoc
iframe
inherits
parent
)
"
)
;
promise_test
(
_
=
>
{
const
overridingPolicy
=
scenario
.
referrer_policy
=
=
=
"
no
-
referrer
"
?
"
unsafe
-
url
"
:
"
no
-
referrer
"
;
const
overrridingExpectation
=
overridingPolicy
=
=
=
"
no
-
referrer
"
?
"
omitted
"
:
"
stripped
-
referrer
"
;
const
scenarioWithoutDelivery
=
Object
.
assign
(
{
}
scenario
)
;
scenarioWithoutDelivery
.
delivery_method
=
null
;
const
sourceContextList
=
[
{
sourceContextType
:
"
srcdoc
"
policyDeliveries
:
[
{
deliveryType
:
"
meta
"
key
:
"
referrerPolicy
"
value
:
overridingPolicy
}
]
}
]
;
return
invokeScenario
(
scenarioWithoutDelivery
sourceContextList
)
.
then
(
result
=
>
checkResult
(
overrridingExpectation
result
)
)
;
}
testDescription
+
"
(
overridden
by
srcdoc
iframe
)
"
)
;
}
return
{
start
:
runTest
}
;
}
