function
html5lib_testcases_from_script
(
)
{
return
parse_html5lib_testcases
(
document
.
querySelector
(
"
script
[
type
=
'
html5lib
-
tests
'
]
"
)
.
textContent
)
;
}
function
html5lib_testcases_from_response
(
response_promise
)
{
return
response_promise
.
then
(
response
=
>
response
.
text
(
)
)
.
then
(
parse_html5lib_testcases
)
;
}
function
add_html5lib_testcase
(
testcases
current
)
{
for
(
const
item
in
current
)
{
current
[
item
]
=
current
[
item
]
.
join
(
"
\
n
"
)
;
}
if
(
Object
.
entries
(
current
)
.
length
)
{
testcases
.
push
(
current
)
;
}
}
function
parse_html5lib_testcases
(
content
)
{
const
testcases
=
[
]
;
var
state
=
undefined
;
var
current
=
{
}
;
for
(
const
line
of
content
.
split
(
"
\
n
"
)
)
{
if
(
!
line
)
{
add_html5lib_testcase
(
testcases
current
)
;
state
=
undefined
;
current
=
{
}
;
}
else
if
(
line
[
0
]
=
=
"
#
"
)
{
state
=
line
.
substring
(
1
)
;
current
[
state
]
=
[
]
;
}
else
if
(
state
)
{
current
[
state
]
.
push
(
line
)
;
}
else
{
}
}
return
testcases
;
}
function
get_child_at
(
node
level
)
{
for
(
i
=
0
;
i
<
level
;
i
+
+
)
{
if
(
is_html_template
(
node
)
)
{
node
=
node
.
content
;
}
else
{
node
=
node
.
lastChild
;
}
}
return
node
;
}
function
append_child_at
(
node
level
child
)
{
get_child_at
(
node
level
)
.
appendChild
(
child
)
;
}
function
is_element
(
node
)
{
return
node
.
tagName
&
&
node
.
namespaceURI
;
}
function
is_html_template
(
node
)
{
return
is_element
(
node
)
&
&
node
.
tagName
=
=
"
TEMPLATE
"
&
&
node
.
namespaceURI
=
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
}
function
create_element
(
name
maybe_namespace
)
{
if
(
maybe_namespace
=
=
"
svg
"
)
{
return
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
name
)
;
}
else
if
(
maybe_namespace
=
=
"
math
"
)
{
return
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
"
name
)
;
}
else
if
(
!
maybe_namespace
)
{
return
document
.
createElement
(
name
)
;
}
else
{
assert_unreached
(
Invalid
element
name
:
"
{
maybe_namespace
}
{
name
}
"
)
;
}
}
function
set_attribute
(
node
name
maybe_namespace
value
)
{
if
(
maybe_namespace
=
=
"
xlink
"
)
{
node
.
setAttributeNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
"
name
value
)
;
}
else
if
(
maybe_namespace
=
=
"
xml
"
)
{
node
.
setAttributeNS
(
"
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
"
name
value
)
;
}
else
if
(
maybe_namespace
=
=
"
xmlns
"
)
{
node
.
setAttributeNS
(
"
http
:
/
/
www
.
w3
.
org
/
2000
/
xmlns
/
"
name
value
)
;
}
else
if
(
!
maybe_namespace
)
{
node
.
setAttribute
(
name
value
)
;
}
else
{
assert_unreached
(
Invalid
attribute
name
:
"
{
maybe_namespace
}
{
name
}
"
)
;
}
}
function
build_node_tree
(
root
docstr
)
{
if
(
!
docstr
)
return
root
;
for
(
const
line
of
docstr
.
split
(
"
\
n
"
)
)
{
const
[
_
indent
remainder
]
=
line
.
match
(
/
^
\
|
(
*
)
(
.
*
)
/
)
;
const
level
=
indent
.
length
/
2
;
if
(
match
=
remainder
.
match
(
/
^
<
(
[
a
-
z
]
*
)
?
(
[
a
-
zA
-
Z_
]
*
)
>
/
)
)
{
append_child_at
(
root
level
create_element
(
match
[
2
]
match
[
1
]
)
)
;
}
else
if
(
match
=
remainder
.
match
(
/
^
"
(
[
^
"
]
*
)
"
/
)
)
{
append_child_at
(
root
level
document
.
createTextNode
(
match
[
1
]
)
)
;
}
else
if
(
match
=
remainder
.
match
(
/
^
(
[
a
-
z
]
*
)
?
(
.
*
)
=
"
(
.
*
)
"
/
)
)
{
set_attribute
(
get_child_at
(
root
level
)
match
[
2
]
match
[
1
]
match
[
3
]
)
;
}
else
if
(
match
=
remainder
.
match
(
/
^
<
!
-
-
(
.
*
)
-
-
>
/
)
)
{
append_child_at
(
root
level
document
.
createComment
(
match
[
1
]
)
)
;
}
else
if
(
match
=
remainder
.
match
(
/
^
<
!
DOCTYPE
(
[
^
]
*
)
(
"
(
[
^
"
]
*
)
"
(
"
(
[
^
"
]
*
)
"
)
?
)
?
>
/
)
)
{
append_child_at
(
root
level
document
.
implementation
.
createDocumentType
(
match
[
1
]
match
[
3
]
match
[
5
]
)
)
;
}
else
if
(
match
=
remainder
.
match
(
/
^
<
?
(
[
a
-
z
]
*
)
(
(
.
*
)
)
>
/
)
)
{
append_child_at
(
root
level
document
.
createProcessingInstruction
(
match
[
1
]
match
[
3
]
)
)
;
}
else
if
(
remainder
=
=
"
content
"
)
{
assert_true
(
is_html_template
(
get_child_at
(
root
level
)
)
"
\
"
content
\
"
only
expected
as
child
of
a
<
template
>
.
"
)
;
}
else
{
assert_unreached
(
Unknown
line
type
.
Maybe
test
data
is
malformed
.
(
"
{
line
}
"
)
)
;
}
}
return
root
;
}
function
assert_subtree_equals
(
node1
node2
)
{
const
tree1
=
document
.
createNodeIterator
(
node1
)
;
const
tree2
=
document
.
createNodeIterator
(
node2
)
;
var
current1
=
tree1
.
nextNode
(
)
;
var
current2
=
tree2
.
nextNode
(
)
;
do
{
current1
=
tree1
.
nextNode
(
)
;
current2
=
tree2
.
nextNode
(
)
;
if
(
!
current1
)
break
;
if
(
!
current1
.
isEqualNode
(
current2
)
)
{
let
breadcrumbs
=
"
"
;
let
current
=
current1
;
while
(
current
)
{
const
here
=
is_element
(
current
)
?
<
{
current
.
tagName
}
>
:
{
current
}
;
breadcrumbs
=
{
here
}
/
{
breadcrumbs
}
;
current
=
current
.
parentNode
;
}
breadcrumbs
=
breadcrumbs
.
substring
(
0
breadcrumbs
.
length
-
3
)
;
assert_true
(
current1
.
isEqualNode
(
current2
)
{
current1
}
.
isEqual
(
{
current2
}
)
fails
.
Path
:
{
breadcrumbs
}
.
)
;
}
if
(
is_html_template
(
current1
)
&
&
is_html_template
(
current2
)
)
{
assert_subtree_equals
(
current1
.
content
current2
.
content
)
;
}
}
while
(
current1
)
;
assert_false
(
!
!
current2
"
Additional
nodes
at
the
of
node2
.
"
)
;
}
function
assert_testcase
(
node
testcase
)
{
const
context
=
document
.
createElement
(
testcase
[
"
document
-
fragment
"
]
?
?
"
div
"
)
;
const
tree
=
build_node_tree
(
context
testcase
.
document
)
;
assert_subtree_equals
(
node
tree
)
;
}
