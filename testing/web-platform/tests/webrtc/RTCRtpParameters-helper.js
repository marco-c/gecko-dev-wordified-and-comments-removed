'
use
strict
'
;
async
function
doOfferAnswerExchange
(
t
caller
)
{
const
callee
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
callee
.
close
(
)
)
;
const
offer
=
await
caller
.
createOffer
(
)
;
await
caller
.
setLocalDescription
(
offer
)
;
await
callee
.
setRemoteDescription
(
offer
)
;
const
answer
=
await
callee
.
createAnswer
(
)
;
await
callee
.
setLocalDescription
(
answer
)
;
await
caller
.
setRemoteDescription
(
answer
)
;
return
callee
;
}
function
validateSenderRtpParameters
(
param
)
{
validateRtpParameters
(
param
)
;
assert_not_equals
(
param
.
transactionId
undefined
'
Expect
sender
param
.
transactionId
to
be
set
'
)
;
assert_not_equals
(
param
.
rtcp
.
cname
undefined
'
Expect
sender
param
.
rtcp
.
cname
to
be
set
'
)
;
assert_not_equals
(
param
.
rtcp
.
reducedSize
undefined
'
Expect
sender
param
.
rtcp
.
reducedSize
to
be
set
to
either
true
or
false
'
)
;
}
function
validateReceiverRtpParameters
(
param
)
{
validateRtpParameters
(
param
)
;
assert_equals
(
param
.
transactionId
undefined
'
Expect
receiver
param
.
transactionId
to
be
unset
'
)
;
assert_not_equals
(
param
.
rtcp
.
reducedSize
undefined
'
Expect
receiver
param
.
rtcp
.
reducedSize
to
be
set
'
)
;
assert_equals
(
param
.
rtcp
.
cname
undefined
'
Expect
receiver
param
.
rtcp
.
cname
to
be
unset
'
)
;
assert_equals
(
param
.
degradationPreference
undefined
'
Expect
receiver
param
.
degradationPreference
to
be
unset
'
)
;
}
function
validateRtpParameters
(
param
)
{
assert_optional_string_field
(
param
'
transactionId
'
)
;
assert_array_field
(
param
'
encodings
'
)
;
for
(
const
encoding
of
param
.
encodings
)
{
validateEncodingParameters
(
encoding
)
;
}
assert_array_field
(
param
'
headerExtensions
'
)
;
for
(
const
headerExt
of
param
.
headerExtensions
)
{
validateHeaderExtensionParameters
(
headerExt
)
;
}
assert_dict_field
(
param
'
rtcp
'
)
;
validateRtcpParameters
(
param
.
rtcp
)
;
assert_array_field
(
param
'
codecs
'
)
;
for
(
const
codec
of
param
.
codecs
)
{
validateCodecParameters
(
codec
)
;
}
assert_optional_enum_field
(
param
'
degradationPreference
'
[
'
maintain
-
framerate
'
'
maintain
-
resolution
'
'
balanced
'
]
)
;
}
function
validateEncodingParameters
(
encoding
)
{
assert_optional_enum_field
(
encoding
'
dtx
'
[
'
disabled
'
'
enabled
'
]
)
;
assert_optional_boolean_field
(
encoding
'
active
'
)
;
assert_optional_enum_field
(
encoding
'
priority
'
[
'
very
-
low
'
'
low
'
'
medium
'
'
high
'
]
)
;
assert_optional_enum_field
(
encoding
'
networkPriority
'
[
'
very
-
low
'
'
low
'
'
medium
'
'
high
'
]
)
;
assert_optional_unsigned_int_field
(
encoding
'
ptime
'
)
;
assert_optional_unsigned_int_field
(
encoding
'
maxBitrate
'
)
;
assert_optional_number_field
(
encoding
'
maxFramerate
'
)
;
assert_optional_string_field
(
encoding
'
rid
'
)
;
assert_optional_number_field
(
encoding
'
scaleResolutionDownBy
'
)
;
}
function
validateRtcpParameters
(
rtcp
)
{
assert_optional_string_field
(
rtcp
'
cname
'
)
;
assert_optional_boolean_field
(
rtcp
'
reducedSize
'
)
;
}
function
validateHeaderExtensionParameters
(
headerExt
)
{
assert_optional_string_field
(
headerExt
'
uri
'
)
;
assert_optional_unsigned_int_field
(
headerExt
'
id
'
)
;
assert_optional_boolean_field
(
headerExt
'
encrypted
'
)
;
}
function
validateCodecParameters
(
codec
)
{
assert_optional_unsigned_int_field
(
codec
'
payloadType
'
)
;
assert_optional_string_field
(
codec
'
mimeType
'
)
;
assert_optional_unsigned_int_field
(
codec
'
clockRate
'
)
;
assert_optional_unsigned_int_field
(
codec
'
channels
'
)
;
assert_optional_string_field
(
codec
'
sdpFmtpLine
'
)
;
}
function
getFirstEncoding
(
param
)
{
const
{
encodings
}
=
param
;
assert_equals
(
encodings
.
length
1
)
;
return
encodings
[
0
]
;
}
function
test_modified_encoding
(
kind
field
value1
value2
desc
)
{
promise_test
(
async
t
=
>
{
const
pc
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
pc
.
close
(
)
)
;
const
{
sender
}
=
pc
.
addTransceiver
(
kind
{
sendEncodings
:
[
{
[
field
]
:
value1
}
]
}
)
;
await
doOfferAnswerExchange
(
t
pc
)
;
const
param1
=
sender
.
getParameters
(
)
;
validateSenderRtpParameters
(
param1
)
;
const
encoding1
=
getFirstEncoding
(
param1
)
;
assert_equals
(
encoding1
[
field
]
value1
)
;
encoding1
[
field
]
=
value2
;
await
sender
.
setParameters
(
param1
)
;
const
param2
=
sender
.
getParameters
(
)
;
validateSenderRtpParameters
(
param2
)
;
const
encoding2
=
getFirstEncoding
(
param2
)
;
assert_equals
(
encoding2
[
field
]
value2
)
;
}
desc
+
'
with
RTCRtpTransceiverInit
'
)
;
promise_test
(
async
t
=
>
{
const
pc
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
pc
.
close
(
)
)
;
const
{
sender
}
=
pc
.
addTransceiver
(
kind
)
;
await
doOfferAnswerExchange
(
t
pc
)
;
const
initParam
=
sender
.
getParameters
(
)
;
validateSenderRtpParameters
(
initParam
)
;
initParam
.
encodings
[
0
]
[
field
]
=
value1
;
await
sender
.
setParameters
(
initParam
)
;
const
param1
=
sender
.
getParameters
(
)
;
validateSenderRtpParameters
(
param1
)
;
const
encoding1
=
getFirstEncoding
(
param1
)
;
assert_equals
(
encoding1
[
field
]
value1
)
;
encoding1
[
field
]
=
value2
;
await
sender
.
setParameters
(
param1
)
;
const
param2
=
sender
.
getParameters
(
)
;
validateSenderRtpParameters
(
param2
)
;
const
encoding2
=
getFirstEncoding
(
param2
)
;
assert_equals
(
encoding2
[
field
]
value2
)
;
}
desc
+
'
without
RTCRtpTransceiverInit
'
)
;
}
