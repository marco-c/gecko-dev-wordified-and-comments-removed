'
use
strict
'
;
async
function
doOfferAnswerExchange
(
t
caller
)
{
const
callee
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
callee
.
close
(
)
)
;
const
offer
=
await
caller
.
createOffer
(
)
;
await
caller
.
setLocalDescription
(
offer
)
;
await
callee
.
setRemoteDescription
(
offer
)
;
const
answer
=
await
callee
.
createAnswer
(
)
;
await
callee
.
setLocalDescription
(
answer
)
;
await
caller
.
setRemoteDescription
(
answer
)
;
}
function
validateSenderRtpParameters
(
param
)
{
validateRtpParameters
(
param
)
;
assert_not_equals
(
param
.
transactionId
undefined
'
Expect
sender
param
.
transactionId
to
be
set
'
)
;
assert_not_equals
(
param
.
rtcp
.
cname
undefined
'
Expect
sender
param
.
rtcp
.
cname
to
be
set
'
)
;
assert_not_equals
(
param
.
rtcp
.
reducedSize
undefined
'
Expect
sender
param
.
rtcp
.
reducedSize
to
be
set
to
either
true
or
false
'
)
;
}
function
validateReceiverRtpParameters
(
param
)
{
validateRtpParameters
(
param
)
;
assert_equals
(
param
.
transactionId
undefined
'
Expect
receiver
param
.
transactionId
to
be
unset
'
)
;
assert_not_equals
(
param
.
rtcp
.
reducedSize
undefined
'
Expect
receiver
param
.
rtcp
.
reducedSize
to
be
set
'
)
;
assert_equals
(
param
.
rtcp
.
cname
undefined
'
Expect
receiver
param
.
rtcp
.
cname
to
be
unset
'
)
;
assert_equals
(
param
.
degradationPreference
undefined
'
Expect
receiver
param
.
degradationPreference
to
be
unset
'
)
;
}
function
validateRtpParameters
(
param
)
{
assert_optional_string_field
(
param
'
transactionId
'
)
;
assert_array_field
(
param
'
encodings
'
)
;
for
(
const
encoding
of
param
.
encodings
)
{
validateEncodingParameters
(
encoding
)
;
}
assert_array_field
(
param
'
headerExtensions
'
)
;
for
(
const
headerExt
of
param
.
headerExtensions
)
{
validateHeaderExtensionParameters
(
headerExt
)
;
}
assert_dict_field
(
param
'
rtcp
'
)
;
validateRtcpParameters
(
param
.
rtcp
)
;
assert_array_field
(
param
'
codecs
'
)
;
for
(
const
codec
of
param
.
codecs
)
{
validateCodecParameters
(
codec
)
;
}
assert_optional_enum_field
(
param
'
degradationPreference
'
[
'
maintain
-
framerate
'
'
maintain
-
resolution
'
'
balanced
'
]
)
;
}
function
validateEncodingParameters
(
encoding
)
{
assert_optional_unsigned_int_field
(
encoding
'
ssrc
'
)
;
assert_optional_dict_field
(
encoding
'
rtx
'
)
;
if
(
encoding
.
rtx
)
{
assert_unsigned_int_field
(
encoding
.
rtx
'
ssrc
'
)
;
}
assert_optional_dict_field
(
encoding
'
fec
'
)
;
if
(
encoding
.
fec
)
{
assert_unsigned_int_field
(
encoding
.
fec
'
ssrc
'
)
;
}
assert_optional_enum_field
(
encoding
'
dtx
'
[
'
disabled
'
'
enabled
'
]
)
;
assert_optional_boolean_field
(
encoding
'
active
'
)
;
assert_optional_enum_field
(
encoding
'
priority
'
[
'
very
-
low
'
'
low
'
'
medium
'
'
high
'
]
)
;
assert_optional_unsigned_int_field
(
encoding
'
ptime
'
)
;
assert_optional_unsigned_int_field
(
encoding
'
maxBitrate
'
)
;
assert_optional_number_field
(
encoding
'
maxFramerate
'
)
;
assert_optional_string_field
(
encoding
'
rid
'
)
;
assert_optional_number_field
(
encoding
'
scaleResolutionDownBy
'
)
;
}
function
validateRtcpParameters
(
rtcp
)
{
assert_optional_string_field
(
rtcp
'
cname
'
)
;
assert_optional_boolean_field
(
rtcp
'
reducedSize
'
)
;
}
function
validateHeaderExtensionParameters
(
headerExt
)
{
assert_optional_string_field
(
headerExt
'
uri
'
)
;
assert_optional_unsigned_int_field
(
headerExt
'
id
'
)
;
assert_optional_boolean_field
(
headerExt
'
encrypted
'
)
;
}
function
validateCodecParameters
(
codec
)
{
assert_optional_unsigned_int_field
(
codec
'
payloadType
'
)
;
assert_optional_string_field
(
codec
'
mimeType
'
)
;
assert_optional_unsigned_int_field
(
codec
'
clockRate
'
)
;
assert_optional_unsigned_int_field
(
codec
'
channels
'
)
;
assert_optional_string_field
(
codec
'
sdpFmtpLine
'
)
;
}
