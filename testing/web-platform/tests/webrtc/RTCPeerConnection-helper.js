'
use
strict
'
const
audioLineRegex
=
/
\
r
\
nm
=
audio
.
+
\
r
\
n
/
g
;
const
videoLineRegex
=
/
\
r
\
nm
=
video
.
+
\
r
\
n
/
g
;
const
applicationLineRegex
=
/
\
r
\
nm
=
application
.
+
\
r
\
n
/
g
;
function
countLine
(
sdp
regex
)
{
const
matches
=
sdp
.
match
(
regex
)
;
if
(
matches
=
=
=
null
)
{
return
0
;
}
else
{
return
matches
.
length
;
}
}
function
countAudioLine
(
sdp
)
{
return
countLine
(
sdp
audioLineRegex
)
;
}
function
countVideoLine
(
sdp
)
{
return
countLine
(
sdp
videoLineRegex
)
;
}
function
countApplicationLine
(
sdp
)
{
return
countLine
(
sdp
applicationLineRegex
)
;
}
function
similarMediaDescriptions
(
sdp1
sdp2
)
{
if
(
sdp1
=
=
=
sdp2
)
{
return
true
;
}
else
if
(
countAudioLine
(
sdp1
)
!
=
=
countAudioLine
(
sdp2
)
|
|
countVideoLine
(
sdp1
)
!
=
=
countVideoLine
(
sdp2
)
|
|
countApplicationLine
(
sdp1
)
!
=
=
countApplicationLine
(
sdp2
)
)
{
return
false
;
}
else
{
return
true
;
}
}
function
assert_is_session_description
(
sessionDesc
)
{
if
(
sessionDesc
instanceof
RTCSessionDescription
)
{
return
;
}
assert_not_equals
(
sessionDesc
undefined
'
Expect
session
description
to
be
defined
'
)
;
assert_true
(
typeof
(
sessionDesc
)
=
=
=
'
object
'
'
Expect
sessionDescription
to
be
either
a
RTCSessionDescription
or
an
object
'
)
;
assert_true
(
typeof
(
sessionDesc
.
type
)
=
=
=
'
string
'
'
Expect
sessionDescription
.
type
to
be
a
string
'
)
;
assert_true
(
typeof
(
sessionDesc
.
sdp
)
=
=
=
'
string
'
'
Expect
sessionDescription
.
sdp
to
be
a
string
'
)
;
}
function
isSimilarSessionDescription
(
sessionDesc1
sessionDesc2
)
{
assert_is_session_description
(
sessionDesc1
)
;
assert_is_session_description
(
sessionDesc2
)
;
if
(
sessionDesc1
.
type
!
=
=
sessionDesc2
.
type
)
{
return
false
;
}
else
{
return
similarMediaDescriptions
(
sessionDesc1
.
sdp
sessionDesc2
.
sdp
)
;
}
}
function
assert_session_desc_similar
(
sessionDesc1
sessionDesc2
)
{
assert_true
(
isSimilarSessionDescription
(
sessionDesc1
sessionDesc2
)
'
Expect
both
session
descriptions
to
have
the
same
count
of
media
lines
'
)
;
}
function
assert_session_desc_not_similar
(
sessionDesc1
sessionDesc2
)
{
assert_false
(
isSimilarSessionDescription
(
sessionDesc1
sessionDesc2
)
'
Expect
both
session
descriptions
to
have
different
count
of
media
lines
'
)
;
}
async
function
generateDataChannelOffer
(
pc
)
{
pc
.
createDataChannel
(
'
test
'
)
;
const
offer
=
await
pc
.
createOffer
(
)
;
assert_equals
(
countApplicationLine
(
offer
.
sdp
)
1
'
Expect
m
=
application
line
to
be
present
in
generated
SDP
'
)
;
return
offer
;
}
async
function
generateAudioReceiveOnlyOffer
(
pc
)
{
try
{
pc
.
addTransceiver
(
'
audio
'
{
direction
:
'
recvonly
'
}
)
;
return
pc
.
createOffer
(
)
;
}
catch
(
e
)
{
return
pc
.
createOffer
(
{
offerToReceiveAudio
:
true
}
)
;
}
}
async
function
generateVideoReceiveOnlyOffer
(
pc
)
{
try
{
pc
.
addTransceiver
(
'
video
'
{
direction
:
'
recvonly
'
}
)
;
return
pc
.
createOffer
(
)
;
}
catch
(
e
)
{
return
pc
.
createOffer
(
{
offerToReceiveVideo
:
true
}
)
;
}
}
async
function
generateAnswer
(
offer
)
{
const
pc
=
new
RTCPeerConnection
(
)
;
await
pc
.
setRemoteDescription
(
offer
)
;
const
answer
=
await
pc
.
createAnswer
(
)
;
pc
.
close
(
)
;
return
answer
;
}
async
function
generateOffer
(
)
{
const
pc
=
new
RTCPeerConnection
(
)
;
const
offer
=
await
pc
.
createOffer
(
)
;
pc
.
close
(
)
;
return
offer
;
}
function
test_never_resolve
(
testFunc
testName
)
{
async_test
(
t
=
>
{
testFunc
(
t
)
.
then
(
t
.
step_func
(
result
=
>
{
assert_unreached
(
Pending
promise
should
never
be
resolved
.
Instead
it
is
fulfilled
with
:
{
result
}
)
;
}
)
t
.
step_func
(
err
=
>
{
assert_unreached
(
Pending
promise
should
never
be
resolved
.
Instead
it
is
rejected
with
:
{
err
}
)
;
}
)
)
;
t
.
step_timeout
(
t
.
step_func_done
(
)
100
)
}
testName
)
;
}
function
exchangeIceCandidates
(
pc1
pc2
)
{
function
doExchange
(
localPc
remotePc
)
{
localPc
.
addEventListener
(
'
icecandidate
'
event
=
>
{
const
{
candidate
}
=
event
;
if
(
candidate
&
&
remotePc
.
signalingState
!
=
=
'
closed
'
)
{
remotePc
.
addIceCandidate
(
candidate
)
;
}
}
)
;
}
doExchange
(
pc1
pc2
)
;
doExchange
(
pc2
pc1
)
;
}
function
waitForState
(
transport
state
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
transport
.
state
=
=
state
)
{
resolve
(
)
;
}
const
eventHandler
=
(
)
=
>
{
if
(
transport
.
state
=
=
state
)
{
transport
.
removeEventListener
(
'
statechange
'
eventHandler
false
)
;
resolve
(
)
;
}
}
;
transport
.
addEventListener
(
'
statechange
'
eventHandler
false
)
;
}
)
;
}
function
listenToIceConnected
(
pc
)
{
return
new
Promise
(
(
resolve
)
=
>
{
function
isConnected
(
pc
)
{
return
pc
.
iceConnectionState
=
=
'
connected
'
|
|
pc
.
iceConnectionState
=
=
'
completed
'
;
}
if
(
isConnected
(
pc
)
)
{
resolve
(
)
;
return
;
}
pc
.
addEventListener
(
'
iceconnectionstatechange
'
(
)
=
>
{
if
(
isConnected
(
pc
)
)
resolve
(
)
;
}
)
;
}
)
;
}
function
waitForIceStateChange
(
pc
wantedStates
)
{
return
new
Promise
(
(
resolve
)
=
>
{
if
(
wantedStates
.
includes
(
pc
.
iceConnectionState
)
)
{
resolve
(
)
;
return
;
}
pc
.
addEventListener
(
'
iceconnectionstatechange
'
(
)
=
>
{
if
(
wantedStates
.
includes
(
pc
.
iceConnectionState
)
)
resolve
(
)
;
}
)
;
}
)
;
}
function
listenToConnected
(
pc
)
{
return
new
Promise
(
(
resolve
)
=
>
{
if
(
pc
.
connectionState
=
=
'
connected
'
)
{
resolve
(
)
;
return
;
}
pc
.
onconnectionstatechange
=
(
)
=
>
{
if
(
pc
.
connectionState
=
=
'
connected
'
)
resolve
(
)
;
}
;
}
)
;
}
function
waitForConnectionStateChange
(
pc
wantedStates
)
{
return
new
Promise
(
(
resolve
)
=
>
{
if
(
wantedStates
.
includes
(
pc
.
connectionState
)
)
{
resolve
(
)
;
return
;
}
pc
.
addEventListener
(
'
connectionstatechange
'
(
)
=
>
{
if
(
wantedStates
.
includes
(
pc
.
connectionState
)
)
resolve
(
)
;
}
)
;
}
)
;
}
function
waitForConnectionStateChange
(
pc
wantedStates
)
{
return
new
Promise
(
(
resolve
)
=
>
{
if
(
wantedStates
.
includes
(
pc
.
connectionState
)
)
{
resolve
(
)
;
return
;
}
pc
.
addEventListener
(
'
connectionstatechange
'
(
)
=
>
{
if
(
wantedStates
.
includes
(
pc
.
connectionState
)
)
resolve
(
)
;
}
)
;
}
)
;
}
function
listenForSSRCs
(
t
receiver
)
{
return
new
Promise
(
(
resolve
)
=
>
{
function
listen
(
)
{
const
ssrcs
=
receiver
.
getSynchronizationSources
(
)
;
assert_true
(
ssrcs
!
=
undefined
)
;
if
(
ssrcs
.
length
>
0
)
{
resolve
(
ssrcs
)
;
return
;
}
t
.
step_timeout
(
listen
0
)
;
}
;
listen
(
)
;
}
)
;
}
async
function
createDataChannelPair
(
t
options
pc1
=
createPeerConnectionWithCleanup
(
t
)
pc2
=
createPeerConnectionWithCleanup
(
t
)
)
{
let
pair
=
[
]
bothOpen
;
try
{
if
(
options
.
negotiated
)
{
pair
=
[
pc1
pc2
]
.
map
(
pc
=
>
pc
.
createDataChannel
(
'
'
options
)
)
;
bothOpen
=
Promise
.
all
(
pair
.
map
(
dc
=
>
new
Promise
(
(
r
e
)
=
>
{
dc
.
onopen
=
r
;
dc
.
onerror
=
(
{
error
}
)
=
>
e
(
error
)
;
}
)
)
)
;
}
else
{
pair
=
[
pc1
.
createDataChannel
(
'
'
options
)
]
;
bothOpen
=
Promise
.
all
(
[
new
Promise
(
(
r
e
)
=
>
{
pair
[
0
]
.
onopen
=
r
;
pair
[
0
]
.
onerror
=
(
{
error
}
)
=
>
e
(
error
)
;
}
)
new
Promise
(
(
r
e
)
=
>
pc2
.
ondatachannel
=
(
{
channel
}
)
=
>
{
pair
[
1
]
=
channel
;
channel
.
onopen
=
r
;
channel
.
onerror
=
(
{
error
}
)
=
>
e
(
error
)
;
}
)
]
)
;
}
exchangeIceCandidates
(
pc1
pc2
)
;
await
exchangeOfferAnswer
(
pc1
pc2
)
;
await
bothOpen
;
return
pair
;
}
finally
{
for
(
const
dc
of
pair
)
{
dc
.
onopen
=
dc
.
onerror
=
null
;
}
}
}
async
function
waitForRtpAndRtcpStats
(
pc
)
{
const
startTime
=
performance
.
now
(
)
;
while
(
true
)
{
const
report
=
await
pc
.
getStats
(
)
;
const
stats
=
[
.
.
.
report
.
values
(
)
]
.
filter
(
(
{
type
}
)
=
>
type
.
endsWith
(
"
bound
-
rtp
"
)
)
;
if
(
stats
.
length
&
&
stats
.
every
(
(
{
localId
remoteId
}
)
=
>
localId
|
|
remoteId
)
)
{
break
;
}
if
(
performance
.
now
(
)
>
startTime
+
5000
)
{
break
;
}
}
}
function
awaitMessage
(
channel
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
channel
.
addEventListener
(
'
message
'
event
=
>
resolve
(
event
.
data
)
{
once
:
true
}
)
;
channel
.
addEventListener
(
'
error
'
reject
{
once
:
true
}
)
;
}
)
;
}
function
blobToArrayBuffer
(
blob
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
reader
=
new
FileReader
(
)
;
reader
.
addEventListener
(
'
load
'
(
)
=
>
{
resolve
(
reader
.
result
)
;
}
)
;
reader
.
addEventListener
(
'
error
'
reject
)
;
reader
.
readAsArrayBuffer
(
blob
)
;
}
)
;
}
function
assert_equals_typed_array
(
array1
array2
)
{
const
[
view1
view2
]
=
[
array1
array2
]
.
map
(
(
array
)
=
>
{
if
(
array
instanceof
ArrayBuffer
)
{
return
new
DataView
(
array
)
;
}
else
{
assert_true
(
array
.
buffer
instanceof
ArrayBuffer
'
Expect
buffer
to
be
instance
of
ArrayBuffer
'
)
;
return
new
DataView
(
array
.
buffer
array
.
byteOffset
array
.
byteLength
)
;
}
}
)
;
assert_equals
(
view1
.
byteLength
view2
.
byteLength
'
Expect
both
arrays
to
be
of
the
same
byte
length
'
)
;
const
byteLength
=
view1
.
byteLength
;
for
(
let
i
=
0
;
i
<
byteLength
;
+
+
i
)
{
assert_equals
(
view1
.
getUint8
(
i
)
view2
.
getUint8
(
i
)
Expect
byte
at
buffer
position
{
i
}
to
be
equal
)
;
}
}
const
trackFactories
=
{
audioContext
:
null
canCreate
(
requested
)
{
const
supported
=
{
audio
:
!
!
window
.
AudioContext
&
&
!
!
window
.
MediaStreamAudioDestinationNode
video
:
!
!
HTMLCanvasElement
.
prototype
.
captureStream
}
;
return
(
!
requested
.
audio
|
|
supported
.
audio
)
&
&
(
!
requested
.
video
|
|
supported
.
video
)
;
}
audio
(
)
{
const
ctx
=
trackFactories
.
audioContext
=
trackFactories
.
audioContext
|
|
new
AudioContext
(
)
;
const
oscillator
=
ctx
.
createOscillator
(
)
;
const
dst
=
oscillator
.
connect
(
ctx
.
createMediaStreamDestination
(
)
)
;
oscillator
.
start
(
)
;
return
dst
.
stream
.
getAudioTracks
(
)
[
0
]
;
}
video
(
{
width
=
640
height
=
480
signal
=
null
}
=
{
}
)
{
const
canvas
=
Object
.
assign
(
document
.
createElement
(
"
canvas
"
)
{
width
height
}
)
;
const
ctx
=
canvas
.
getContext
(
'
2d
'
)
;
const
stream
=
canvas
.
captureStream
(
)
;
let
count
=
0
;
setInterval
(
(
)
=
>
{
ctx
.
fillStyle
=
rgb
(
{
count
%
255
}
{
count
*
count
%
255
}
{
count
%
255
}
)
;
count
+
=
1
;
ctx
.
fillRect
(
0
0
width
height
)
;
if
(
signal
!
=
=
null
)
{
ctx
.
fillStyle
=
rgb
(
{
signal
}
{
signal
}
{
signal
}
)
;
ctx
.
fillRect
(
10
10
20
20
)
;
}
}
100
)
;
if
(
document
.
body
)
{
document
.
body
.
appendChild
(
canvas
)
;
}
else
{
document
.
addEventListener
(
'
DOMContentLoaded
'
(
)
=
>
{
document
.
body
.
appendChild
(
canvas
)
;
}
)
;
}
return
stream
.
getVideoTracks
(
)
[
0
]
;
}
}
;
function
getVideoSignal
(
v
)
{
if
(
v
.
videoWidth
<
21
|
|
v
.
videoHeight
<
21
)
{
return
null
;
}
const
canvas
=
new
OffscreenCanvas
(
v
.
videoWidth
v
.
videoHeight
)
;
let
context
=
canvas
.
getContext
(
'
2d
'
)
;
context
.
drawImage
(
v
0
0
v
.
videoWidth
v
.
videoHeight
)
;
let
pixel
=
context
.
getImageData
(
20
20
1
1
)
;
return
(
pixel
.
data
[
0
]
*
0
.
21
+
pixel
.
data
[
1
]
*
0
.
72
+
pixel
.
data
[
2
]
*
0
.
07
)
;
}
function
detectSignal
(
t
v
value
)
{
return
new
Promise
(
(
resolve
)
=
>
{
let
check
=
(
)
=
>
{
const
signal
=
getVideoSignal
(
v
)
;
if
(
signal
!
=
=
null
&
&
signal
<
value
+
1
&
&
signal
>
value
-
1
)
{
resolve
(
)
;
}
else
{
t
.
step_timeout
(
check
100
)
;
}
}
check
(
)
;
}
)
;
}
async
function
getNoiseStream
(
caps
=
{
}
)
{
if
(
!
trackFactories
.
canCreate
(
caps
)
)
{
return
navigator
.
mediaDevices
.
getUserMedia
(
caps
)
;
}
const
tracks
=
[
]
;
if
(
caps
.
audio
)
{
tracks
.
push
(
trackFactories
.
audio
(
)
)
;
}
if
(
caps
.
video
)
{
tracks
.
push
(
trackFactories
.
video
(
caps
.
video
)
)
;
}
return
new
MediaStream
(
tracks
)
;
}
function
getTrackFromUserMedia
(
kind
)
{
return
getNoiseStream
(
{
[
kind
]
:
true
}
)
.
then
(
mediaStream
=
>
{
const
[
track
]
=
mediaStream
.
getTracks
(
)
;
return
[
track
mediaStream
]
;
}
)
;
}
function
getUserMediaTracksAndStreams
(
count
type
=
'
audio
'
)
{
let
otherTracksPromise
;
if
(
count
>
1
)
otherTracksPromise
=
getUserMediaTracksAndStreams
(
count
-
1
type
)
;
else
otherTracksPromise
=
Promise
.
resolve
(
[
[
]
[
]
]
)
;
return
otherTracksPromise
.
then
(
(
[
tracks
streams
]
)
=
>
{
return
getTrackFromUserMedia
(
type
)
.
then
(
(
[
track
stream
]
)
=
>
{
stream
.
removeTrack
(
track
)
;
tracks
.
push
(
track
)
;
streams
.
push
(
stream
)
;
return
[
tracks
streams
]
;
}
)
;
}
)
;
}
async
function
exchangeOffer
(
caller
callee
)
{
await
caller
.
setLocalDescription
(
await
caller
.
createOffer
(
)
)
;
await
callee
.
setRemoteDescription
(
caller
.
localDescription
)
;
}
async
function
exchangeAnswer
(
caller
callee
)
{
await
callee
.
setLocalDescription
(
await
callee
.
createAnswer
(
)
)
;
await
caller
.
setRemoteDescription
(
callee
.
localDescription
)
;
}
async
function
exchangeOfferAnswer
(
caller
callee
)
{
await
exchangeOffer
(
caller
callee
)
;
await
exchangeAnswer
(
caller
callee
)
;
}
async
function
exchangeAnswerAndListenToOntrack
(
t
caller
callee
)
{
const
ontrackPromise
=
addEventListenerPromise
(
t
caller
'
track
'
)
;
await
exchangeAnswer
(
caller
callee
)
;
return
ontrackPromise
;
}
async
function
exchangeOfferAndListenToOntrack
(
t
caller
callee
)
{
const
ontrackPromise
=
addEventListenerPromise
(
t
callee
'
track
'
)
;
await
exchangeOffer
(
caller
callee
)
;
return
ontrackPromise
;
}
class
Resolver
extends
Promise
{
constructor
(
executor
)
{
let
resolve
reject
;
super
(
(
resolve_
reject_
)
=
>
{
resolve
=
resolve_
;
reject
=
reject_
;
if
(
executor
)
{
return
executor
(
resolve_
reject_
)
;
}
}
)
;
this
.
_done
=
false
;
this
.
_resolve
=
resolve
;
this
.
_reject
=
reject
;
}
get
done
(
)
{
return
this
.
_done
;
}
resolve
(
.
.
.
args
)
{
this
.
_done
=
true
;
return
this
.
_resolve
(
.
.
.
args
)
;
}
reject
(
.
.
.
args
)
{
this
.
_done
=
true
;
return
this
.
_reject
(
.
.
.
args
)
;
}
}
function
addEventListenerPromise
(
t
target
type
listener
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
target
.
addEventListener
(
type
t
.
step_func
(
e
=
>
{
if
(
listener
!
=
undefined
)
e
=
listener
(
e
)
;
resolve
(
e
)
;
}
)
)
;
}
)
;
}
function
createPeerConnectionWithCleanup
(
t
)
{
const
pc
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
pc
.
close
(
)
)
;
return
pc
;
}
async
function
createTrackAndStreamWithCleanup
(
t
kind
=
'
audio
'
)
{
let
constraints
=
{
}
;
constraints
[
kind
]
=
true
;
const
stream
=
await
getNoiseStream
(
constraints
)
;
const
[
track
]
=
stream
.
getTracks
(
)
;
t
.
add_cleanup
(
(
)
=
>
track
.
stop
(
)
)
;
return
[
track
stream
]
;
}
function
findTransceiverForSender
(
pc
sender
)
{
const
transceivers
=
pc
.
getTransceivers
(
)
;
for
(
let
i
=
0
;
i
<
transceivers
.
length
;
+
+
i
)
{
if
(
transceivers
[
i
]
.
sender
=
=
sender
)
return
transceivers
[
i
]
;
}
return
null
;
}
function
preferCodec
(
transceiver
mimeType
sdpFmtpLine
)
{
const
{
codecs
}
=
RTCRtpSender
.
getCapabilities
(
transceiver
.
receiver
.
track
.
kind
)
;
const
selectedCodecIndex
=
codecs
.
findIndex
(
c
=
>
{
return
c
.
mimeType
=
=
=
mimeType
&
&
(
c
.
sdpFmtpLine
=
=
=
sdpFmtpLine
|
|
!
sdpFmtpLine
)
;
}
)
;
const
selectedCodec
=
codecs
[
selectedCodecIndex
]
;
codecs
.
slice
(
selectedCodecIndex
1
)
;
codecs
.
unshift
(
selectedCodec
)
;
return
transceiver
.
setCodecPreferences
(
codecs
)
;
}
class
UniqueSet
extends
Set
{
constructor
(
items
)
{
super
(
)
;
if
(
items
!
=
=
undefined
)
{
for
(
const
item
of
items
)
{
this
.
add
(
item
)
;
}
}
}
add
(
value
message
)
{
if
(
message
=
=
=
undefined
)
{
message
=
Value
'
{
value
}
'
needs
to
be
unique
but
it
is
already
in
the
set
;
}
assert_true
(
!
this
.
has
(
value
)
message
)
;
super
.
add
(
value
)
;
}
}
