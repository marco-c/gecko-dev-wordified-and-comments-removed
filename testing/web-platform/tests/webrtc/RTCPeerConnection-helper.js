'
use
strict
'
const
audioLineRegex
=
/
\
r
\
nm
=
audio
.
+
\
r
\
n
/
g
;
const
videoLineRegex
=
/
\
r
\
nm
=
video
.
+
\
r
\
n
/
g
;
const
applicationLineRegex
=
/
\
r
\
nm
=
application
.
+
\
r
\
n
/
g
;
function
countLine
(
sdp
regex
)
{
const
matches
=
sdp
.
match
(
regex
)
;
if
(
matches
=
=
=
null
)
{
return
0
;
}
else
{
return
matches
.
length
;
}
}
function
countAudioLine
(
sdp
)
{
return
countLine
(
sdp
audioLineRegex
)
;
}
function
countVideoLine
(
sdp
)
{
return
countLine
(
sdp
videoLineRegex
)
;
}
function
countApplicationLine
(
sdp
)
{
return
countLine
(
sdp
applicationLineRegex
)
;
}
function
similarMediaDescriptions
(
sdp1
sdp2
)
{
if
(
sdp1
=
=
=
sdp2
)
{
return
true
;
}
else
if
(
countAudioLine
(
sdp1
)
!
=
=
countAudioLine
(
sdp2
)
|
|
countVideoLine
(
sdp1
)
!
=
=
countVideoLine
(
sdp2
)
|
|
countApplicationLine
(
sdp1
)
!
=
=
countApplicationLine
(
sdp2
)
)
{
return
false
;
}
else
{
return
true
;
}
}
function
assert_is_session_description
(
sessionDesc
)
{
if
(
sessionDesc
instanceof
RTCSessionDescription
)
{
return
;
}
assert_not_equals
(
sessionDesc
undefined
'
Expect
session
description
to
be
defined
'
)
;
assert_true
(
typeof
(
sessionDesc
)
=
=
=
'
object
'
'
Expect
sessionDescription
to
be
either
a
RTCSessionDescription
or
an
object
'
)
;
assert_true
(
typeof
(
sessionDesc
.
type
)
=
=
=
'
string
'
'
Expect
sessionDescription
.
type
to
be
a
string
'
)
;
assert_true
(
typeof
(
sessionDesc
.
sdp
)
=
=
=
'
string
'
'
Expect
sessionDescription
.
sdp
to
be
a
string
'
)
;
}
function
isSimilarSessionDescription
(
sessionDesc1
sessionDesc2
)
{
assert_is_session_description
(
sessionDesc1
)
;
assert_is_session_description
(
sessionDesc2
)
;
if
(
sessionDesc1
.
type
!
=
=
sessionDesc2
.
type
)
{
return
false
;
}
else
{
return
similarMediaDescriptions
(
sessionDesc1
.
sdp
sessionDesc2
.
sdp
)
;
}
}
function
assert_session_desc_similar
(
sessionDesc1
sessionDesc2
)
{
assert_true
(
isSimilarSessionDescription
(
sessionDesc1
sessionDesc2
)
'
Expect
both
session
descriptions
to
have
the
same
count
of
media
lines
'
)
;
}
function
assert_session_desc_not_similar
(
sessionDesc1
sessionDesc2
)
{
assert_false
(
isSimilarSessionDescription
(
sessionDesc1
sessionDesc2
)
'
Expect
both
session
descriptions
to
have
different
count
of
media
lines
'
)
;
}
async
function
generateDataChannelOffer
(
pc
)
{
pc
.
createDataChannel
(
'
test
'
)
;
const
offer
=
await
pc
.
createOffer
(
)
;
assert_equals
(
countApplicationLine
(
offer
.
sdp
)
1
'
Expect
m
=
application
line
to
be
present
in
generated
SDP
'
)
;
return
offer
;
}
async
function
generateAudioReceiveOnlyOffer
(
pc
)
{
try
{
pc
.
addTransceiver
(
'
audio
'
{
direction
:
'
recvonly
'
}
)
;
return
pc
.
createOffer
(
)
;
}
catch
(
e
)
{
return
pc
.
createOffer
(
{
offerToReceiveAudio
:
true
}
)
;
}
}
async
function
generateVideoReceiveOnlyOffer
(
pc
)
{
try
{
pc
.
addTransceiver
(
'
video
'
{
direction
:
'
recvonly
'
}
)
;
return
pc
.
createOffer
(
)
;
}
catch
(
e
)
{
return
pc
.
createOffer
(
{
offerToReceiveVideo
:
true
}
)
;
}
}
async
function
generateAnswer
(
offer
)
{
const
pc
=
new
RTCPeerConnection
(
)
;
await
pc
.
setRemoteDescription
(
offer
)
;
const
answer
=
await
pc
.
createAnswer
(
)
;
pc
.
close
(
)
;
return
answer
;
}
async
function
generateOffer
(
)
{
const
pc
=
new
RTCPeerConnection
(
)
;
const
offer
=
await
pc
.
createOffer
(
)
;
pc
.
close
(
)
;
return
offer
;
}
function
test_never_resolve
(
testFunc
testName
)
{
async_test
(
t
=
>
{
testFunc
(
t
)
.
then
(
t
.
step_func
(
result
=
>
{
assert_unreached
(
Pending
promise
should
never
be
resolved
.
Instead
it
is
fulfilled
with
:
{
result
}
)
;
}
)
t
.
step_func
(
err
=
>
{
assert_unreached
(
Pending
promise
should
never
be
resolved
.
Instead
it
is
rejected
with
:
{
err
}
)
;
}
)
)
;
t
.
step_timeout
(
t
.
step_func_done
(
)
100
)
}
testName
)
;
}
function
exchangeIceCandidates
(
pc1
pc2
)
{
function
doExchange
(
localPc
remotePc
)
{
localPc
.
addEventListener
(
'
icecandidate
'
event
=
>
{
const
{
candidate
}
=
event
;
if
(
remotePc
.
signalingState
!
=
=
'
closed
'
)
{
remotePc
.
addIceCandidate
(
candidate
)
;
}
}
)
;
}
doExchange
(
pc1
pc2
)
;
doExchange
(
pc2
pc1
)
;
}
function
waitUntilEvent
(
obj
name
)
{
return
new
Promise
(
r
=
>
obj
.
addEventListener
(
name
r
{
once
:
true
}
)
)
;
}
async
function
waitForState
(
transport
state
)
{
while
(
transport
.
state
!
=
state
)
{
await
waitUntilEvent
(
transport
'
statechange
'
)
;
}
}
async
function
listenToIceConnected
(
pc
)
{
await
waitForIceStateChange
(
pc
[
'
connected
'
'
completed
'
]
)
;
}
async
function
waitForIceStateChange
(
pc
wantedStates
)
{
while
(
!
wantedStates
.
includes
(
pc
.
iceConnectionState
)
)
{
await
waitUntilEvent
(
pc
'
iceconnectionstatechange
'
)
;
}
}
async
function
listenToConnected
(
pc
)
{
while
(
pc
.
connectionState
!
=
'
connected
'
)
{
await
waitUntilEvent
(
pc
'
connectionstatechange
'
)
;
}
}
async
function
waitForConnectionStateChange
(
pc
wantedStates
)
{
while
(
!
wantedStates
.
includes
(
pc
.
connectionState
)
)
{
await
waitUntilEvent
(
pc
'
connectionstatechange
'
)
;
}
}
async
function
waitForIceGatheringState
(
pc
wantedStates
)
{
while
(
!
wantedStates
.
includes
(
pc
.
iceGatheringState
)
)
{
await
waitUntilEvent
(
pc
'
icegatheringstatechange
'
)
;
}
}
async
function
listenForSSRCs
(
t
receiver
)
{
while
(
true
)
{
const
ssrcs
=
receiver
.
getSynchronizationSources
(
)
;
if
(
Array
.
isArray
(
ssrcs
)
&
&
ssrcs
.
length
>
0
)
{
return
ssrcs
;
}
await
new
Promise
(
r
=
>
t
.
step_timeout
(
r
0
)
)
;
}
}
async
function
createDataChannelPair
(
t
options
pc1
=
createPeerConnectionWithCleanup
(
t
)
pc2
=
createPeerConnectionWithCleanup
(
t
)
)
{
let
pair
=
[
]
bothOpen
;
try
{
if
(
options
.
negotiated
)
{
pair
=
[
pc1
pc2
]
.
map
(
pc
=
>
pc
.
createDataChannel
(
'
'
options
)
)
;
bothOpen
=
Promise
.
all
(
pair
.
map
(
dc
=
>
new
Promise
(
(
r
e
)
=
>
{
dc
.
onopen
=
r
;
dc
.
onerror
=
(
{
error
}
)
=
>
e
(
error
)
;
}
)
)
)
;
}
else
{
pair
=
[
pc1
.
createDataChannel
(
'
'
options
)
]
;
bothOpen
=
Promise
.
all
(
[
new
Promise
(
(
r
e
)
=
>
{
pair
[
0
]
.
onopen
=
r
;
pair
[
0
]
.
onerror
=
(
{
error
}
)
=
>
e
(
error
)
;
}
)
new
Promise
(
(
r
e
)
=
>
pc2
.
ondatachannel
=
(
{
channel
}
)
=
>
{
pair
[
1
]
=
channel
;
channel
.
onopen
=
r
;
channel
.
onerror
=
(
{
error
}
)
=
>
e
(
error
)
;
}
)
]
)
;
}
exchangeIceCandidates
(
pc1
pc2
)
;
await
exchangeOfferAnswer
(
pc1
pc2
)
;
await
bothOpen
;
return
pair
;
}
finally
{
for
(
const
dc
of
pair
)
{
dc
.
onopen
=
dc
.
onerror
=
null
;
}
}
}
async
function
waitForRtpAndRtcpStats
(
pc
)
{
const
startTime
=
performance
.
now
(
)
;
while
(
true
)
{
const
report
=
await
pc
.
getStats
(
)
;
const
stats
=
[
.
.
.
report
.
values
(
)
]
.
filter
(
(
{
type
}
)
=
>
type
.
endsWith
(
"
bound
-
rtp
"
)
)
;
if
(
stats
.
length
&
&
stats
.
every
(
(
{
localId
remoteId
}
)
=
>
localId
|
|
remoteId
)
)
{
break
;
}
if
(
performance
.
now
(
)
>
startTime
+
5000
)
{
break
;
}
}
}
function
awaitMessage
(
channel
)
{
const
once
=
true
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
channel
.
addEventListener
(
'
message
'
(
{
data
}
)
=
>
resolve
(
data
)
{
once
}
)
;
channel
.
addEventListener
(
'
error
'
reject
{
once
}
)
;
}
)
;
}
async
function
blobToArrayBuffer
(
blob
)
{
const
reader
=
new
FileReader
(
)
;
reader
.
readAsArrayBuffer
(
blob
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
reader
.
addEventListener
(
'
load
'
(
)
=
>
resolve
(
reader
.
result
)
{
once
:
true
}
)
;
reader
.
addEventListener
(
'
error
'
(
)
=
>
reject
(
reader
.
error
)
{
once
:
true
}
)
;
}
)
;
}
function
assert_equals_typed_array
(
array1
array2
)
{
const
[
view1
view2
]
=
[
array1
array2
]
.
map
(
(
array
)
=
>
{
if
(
array
instanceof
ArrayBuffer
)
{
return
new
DataView
(
array
)
;
}
else
{
assert_true
(
array
.
buffer
instanceof
ArrayBuffer
'
Expect
buffer
to
be
instance
of
ArrayBuffer
'
)
;
return
new
DataView
(
array
.
buffer
array
.
byteOffset
array
.
byteLength
)
;
}
}
)
;
assert_equals
(
view1
.
byteLength
view2
.
byteLength
'
Expect
both
arrays
to
be
of
the
same
byte
length
'
)
;
const
byteLength
=
view1
.
byteLength
;
for
(
let
i
=
0
;
i
<
byteLength
;
+
+
i
)
{
assert_equals
(
view1
.
getUint8
(
i
)
view2
.
getUint8
(
i
)
Expect
byte
at
buffer
position
{
i
}
to
be
equal
)
;
}
}
const
trackFactories
=
{
audioContext
:
null
canCreate
(
requested
)
{
const
supported
=
{
audio
:
!
!
window
.
AudioContext
&
&
!
!
window
.
MediaStreamAudioDestinationNode
video
:
!
!
HTMLCanvasElement
.
prototype
.
captureStream
}
;
return
(
!
requested
.
audio
|
|
supported
.
audio
)
&
&
(
!
requested
.
video
|
|
supported
.
video
)
;
}
audio
(
)
{
const
ctx
=
trackFactories
.
audioContext
=
trackFactories
.
audioContext
|
|
new
AudioContext
(
)
;
const
oscillator
=
ctx
.
createOscillator
(
)
;
const
dst
=
oscillator
.
connect
(
ctx
.
createMediaStreamDestination
(
)
)
;
oscillator
.
start
(
)
;
return
dst
.
stream
.
getAudioTracks
(
)
[
0
]
;
}
video
(
{
width
=
640
height
=
480
signal
}
=
{
}
)
{
const
canvas
=
Object
.
assign
(
document
.
createElement
(
"
canvas
"
)
{
width
height
}
)
;
const
ctx
=
canvas
.
getContext
(
'
2d
'
)
;
const
stream
=
canvas
.
captureStream
(
)
;
let
count
=
0
;
const
interval
=
setInterval
(
(
)
=
>
{
ctx
.
fillStyle
=
rgb
(
{
count
%
255
}
{
count
*
count
%
255
}
{
count
%
255
}
)
;
count
+
=
1
;
ctx
.
fillRect
(
0
0
width
height
)
;
const
contrast
=
count
+
128
;
ctx
.
fillStyle
=
rgb
(
{
contrast
%
255
}
{
contrast
*
contrast
%
255
}
{
contrast
%
255
}
)
;
const
xpos
=
count
%
(
width
-
20
)
;
const
ypos
=
count
%
(
height
-
20
)
;
ctx
.
fillRect
(
xpos
ypos
xpos
+
20
ypos
+
20
)
;
const
xpos2
=
(
count
+
width
/
2
)
%
(
width
-
20
)
;
const
ypos2
=
(
count
+
height
/
2
)
%
(
height
-
20
)
;
ctx
.
fillRect
(
xpos2
ypos2
xpos2
+
20
ypos2
+
20
)
;
if
(
signal
!
=
undefined
)
{
ctx
.
fillStyle
=
rgb
(
{
signal
}
{
signal
}
{
signal
}
)
;
ctx
.
fillRect
(
20
20
40
40
)
;
}
}
100
)
;
if
(
document
.
body
)
{
document
.
body
.
appendChild
(
canvas
)
;
}
else
{
document
.
addEventListener
(
'
DOMContentLoaded
'
(
)
=
>
{
document
.
body
.
appendChild
(
canvas
)
;
}
{
once
:
true
}
)
;
}
const
track
=
stream
.
getVideoTracks
(
)
[
0
]
;
const
nativeStop
=
track
.
stop
;
track
.
stop
=
function
stop
(
)
{
clearInterval
(
interval
)
;
nativeStop
.
apply
(
this
)
;
if
(
document
.
body
&
&
canvas
.
parentElement
=
=
document
.
body
)
{
document
.
body
.
removeChild
(
canvas
)
;
}
}
;
return
track
;
}
}
;
function
getVideoSignal
(
v
)
{
if
(
v
.
videoWidth
<
60
|
|
v
.
videoHeight
<
60
)
{
throw
new
Error
(
'
getVideoSignal
:
video
too
small
for
test
'
)
;
}
const
canvas
=
document
.
createElement
(
"
canvas
"
)
;
canvas
.
width
=
canvas
.
height
=
60
;
const
context
=
canvas
.
getContext
(
'
2d
'
)
;
context
.
drawImage
(
v
0
0
)
;
const
pixel
=
context
.
getImageData
(
40
40
1
1
)
;
return
(
pixel
.
data
[
0
]
*
0
.
21
+
pixel
.
data
[
1
]
*
0
.
72
+
pixel
.
data
[
2
]
*
0
.
07
)
;
}
async
function
detectSignal
(
t
v
value
)
{
while
(
true
)
{
const
signal
=
getVideoSignal
(
v
)
.
toFixed
(
)
;
if
(
value
-
2
<
=
signal
&
&
signal
<
=
value
+
2
)
{
return
;
}
await
new
Promise
(
r
=
>
t
.
step_timeout
(
r
100
)
)
;
}
}
async
function
getNoiseStream
(
caps
=
{
}
)
{
if
(
!
trackFactories
.
canCreate
(
caps
)
)
{
return
navigator
.
mediaDevices
.
getUserMedia
(
caps
)
;
}
const
tracks
=
[
]
;
if
(
caps
.
audio
)
{
tracks
.
push
(
trackFactories
.
audio
(
)
)
;
}
if
(
caps
.
video
)
{
tracks
.
push
(
trackFactories
.
video
(
caps
.
video
)
)
;
}
return
new
MediaStream
(
tracks
)
;
}
function
getTrackFromUserMedia
(
kind
)
{
return
getNoiseStream
(
{
[
kind
]
:
true
}
)
.
then
(
mediaStream
=
>
{
const
[
track
]
=
mediaStream
.
getTracks
(
)
;
return
[
track
mediaStream
]
;
}
)
;
}
function
getUserMediaTracksAndStreams
(
count
type
=
'
audio
'
)
{
let
otherTracksPromise
;
if
(
count
>
1
)
otherTracksPromise
=
getUserMediaTracksAndStreams
(
count
-
1
type
)
;
else
otherTracksPromise
=
Promise
.
resolve
(
[
[
]
[
]
]
)
;
return
otherTracksPromise
.
then
(
(
[
tracks
streams
]
)
=
>
{
return
getTrackFromUserMedia
(
type
)
.
then
(
(
[
track
stream
]
)
=
>
{
stream
.
removeTrack
(
track
)
;
tracks
.
push
(
track
)
;
streams
.
push
(
stream
)
;
return
[
tracks
streams
]
;
}
)
;
}
)
;
}
async
function
exchangeOffer
(
caller
callee
)
{
await
caller
.
setLocalDescription
(
await
caller
.
createOffer
(
)
)
;
await
callee
.
setRemoteDescription
(
caller
.
localDescription
)
;
}
async
function
exchangeAnswer
(
caller
callee
)
{
const
answer
=
await
callee
.
createAnswer
(
)
;
await
caller
.
setRemoteDescription
(
answer
)
;
await
callee
.
setLocalDescription
(
answer
)
;
}
async
function
exchangeOfferAnswer
(
caller
callee
)
{
await
exchangeOffer
(
caller
callee
)
;
await
exchangeAnswer
(
caller
callee
)
;
}
async
function
exchangeAnswerAndListenToOntrack
(
t
caller
callee
)
{
const
ontrackPromise
=
addEventListenerPromise
(
t
caller
'
track
'
)
;
await
exchangeAnswer
(
caller
callee
)
;
return
ontrackPromise
;
}
async
function
exchangeOfferAndListenToOntrack
(
t
caller
callee
)
{
const
ontrackPromise
=
addEventListenerPromise
(
t
callee
'
track
'
)
;
await
exchangeOffer
(
caller
callee
)
;
return
ontrackPromise
;
}
class
Resolver
extends
Promise
{
constructor
(
executor
)
{
let
resolve
reject
;
super
(
(
resolve_
reject_
)
=
>
{
resolve
=
resolve_
;
reject
=
reject_
;
if
(
executor
)
{
return
executor
(
resolve_
reject_
)
;
}
}
)
;
this
.
_done
=
false
;
this
.
_resolve
=
resolve
;
this
.
_reject
=
reject
;
}
get
done
(
)
{
return
this
.
_done
;
}
resolve
(
.
.
.
args
)
{
this
.
_done
=
true
;
return
this
.
_resolve
(
.
.
.
args
)
;
}
reject
(
.
.
.
args
)
{
this
.
_done
=
true
;
return
this
.
_reject
(
.
.
.
args
)
;
}
}
function
addEventListenerPromise
(
t
obj
type
listener
)
{
if
(
!
listener
)
{
return
waitUntilEvent
(
obj
type
)
;
}
return
new
Promise
(
r
=
>
obj
.
addEventListener
(
type
t
.
step_func
(
e
=
>
r
(
listener
(
e
)
)
)
{
once
:
true
}
)
)
;
}
function
createPeerConnectionWithCleanup
(
t
)
{
const
pc
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
pc
.
close
(
)
)
;
return
pc
;
}
async
function
createTrackAndStreamWithCleanup
(
t
kind
=
'
audio
'
)
{
let
constraints
=
{
}
;
constraints
[
kind
]
=
true
;
const
stream
=
await
getNoiseStream
(
constraints
)
;
const
[
track
]
=
stream
.
getTracks
(
)
;
t
.
add_cleanup
(
(
)
=
>
track
.
stop
(
)
)
;
return
[
track
stream
]
;
}
function
findTransceiverForSender
(
pc
sender
)
{
const
transceivers
=
pc
.
getTransceivers
(
)
;
for
(
let
i
=
0
;
i
<
transceivers
.
length
;
+
+
i
)
{
if
(
transceivers
[
i
]
.
sender
=
=
sender
)
return
transceivers
[
i
]
;
}
return
null
;
}
function
preferCodec
(
transceiver
mimeType
sdpFmtpLine
)
{
const
{
codecs
}
=
RTCRtpSender
.
getCapabilities
(
transceiver
.
receiver
.
track
.
kind
)
;
const
selectedCodecIndex
=
codecs
.
findIndex
(
c
=
>
{
return
c
.
mimeType
=
=
=
mimeType
&
&
(
c
.
sdpFmtpLine
=
=
=
sdpFmtpLine
|
|
!
sdpFmtpLine
)
;
}
)
;
const
selectedCodec
=
codecs
[
selectedCodecIndex
]
;
codecs
.
slice
(
selectedCodecIndex
1
)
;
codecs
.
unshift
(
selectedCodec
)
;
return
transceiver
.
setCodecPreferences
(
codecs
)
;
}
class
UniqueSet
extends
Set
{
constructor
(
items
)
{
super
(
)
;
if
(
items
!
=
=
undefined
)
{
for
(
const
item
of
items
)
{
this
.
add
(
item
)
;
}
}
}
add
(
value
message
)
{
if
(
message
=
=
=
undefined
)
{
message
=
Value
'
{
value
}
'
needs
to
be
unique
but
it
is
already
in
the
set
;
}
assert_true
(
!
this
.
has
(
value
)
message
)
;
super
.
add
(
value
)
;
}
}
const
iceGatheringStateTransitions
=
async
(
pc
.
.
.
states
)
=
>
{
for
(
const
state
of
states
)
{
await
new
Promise
(
(
resolve
reject
)
=
>
{
pc
.
addEventListener
(
'
icegatheringstatechange
'
(
)
=
>
{
if
(
pc
.
iceGatheringState
=
=
state
)
{
resolve
(
)
;
}
else
{
reject
(
Unexpected
gathering
state
:
{
pc
.
iceGatheringState
}
was
expecting
{
state
}
)
;
}
}
{
once
:
true
}
)
;
}
)
;
}
}
;
const
initialOfferAnswerWithIceGatheringStateTransitions
=
async
(
pc1
pc2
offerOptions
)
=
>
{
await
pc1
.
setLocalDescription
(
await
pc1
.
createOffer
(
offerOptions
)
)
;
const
pc1Transitions
=
iceGatheringStateTransitions
(
pc1
'
gathering
'
'
complete
'
)
;
await
pc2
.
setRemoteDescription
(
pc1
.
localDescription
)
;
await
pc2
.
setLocalDescription
(
await
pc2
.
createAnswer
(
)
)
;
const
pc2Transitions
=
iceGatheringStateTransitions
(
pc2
'
gathering
'
'
complete
'
)
;
await
pc1
.
setRemoteDescription
(
pc2
.
localDescription
)
;
await
pc1Transitions
;
await
pc2Transitions
;
}
;
const
expectNoMoreGatheringStateChanges
=
async
(
t
pc
)
=
>
{
pc
.
onicegatheringstatechange
=
t
.
step_func
(
(
)
=
>
{
assert_unreached
(
'
Should
not
get
an
icegatheringstatechange
right
now
!
'
)
;
}
)
;
}
;
