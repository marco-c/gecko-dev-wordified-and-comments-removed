class
WorkerBackedDataChannel
extends
EventTarget
{
#
worker
;
#
dcAttrs
;
#
eventHandlers
;
#
errorPromise
;
#
label
;
constructor
(
worker
=
null
)
{
super
(
)
;
this
.
#
worker
=
worker
|
|
WorkerBackedDataChannel
.
makeWorker
(
)
;
this
.
#
dcAttrs
=
null
;
this
.
#
eventHandlers
=
new
Map
(
)
;
this
.
#
listenForEventMessages
(
)
;
this
.
#
errorPromise
=
new
Promise
(
(
_
reject
)
=
>
{
const
onErrorEvent
=
(
e
)
=
>
{
switch
(
e
.
type
)
{
case
'
error
'
:
case
'
messageerror
'
:
reject
(
new
Error
(
Worker
sent
{
e
.
type
}
event
:
{
e
.
message
}
)
)
;
break
;
}
}
;
this
.
#
worker
.
addEventListener
(
'
error
'
onErrorEvent
)
;
this
.
#
worker
.
addEventListener
(
'
messageerror
'
onErrorEvent
)
;
this
.
#
worker
.
addEventListener
(
'
message
'
(
{
data
}
)
=
>
{
const
{
type
label
result
}
=
data
;
if
(
type
=
=
'
workerError
'
&
&
(
label
=
=
=
undefined
|
|
label
=
=
this
.
#
label
)
)
{
reject
(
new
Error
(
Worker
code
sent
error
message
:
{
result
}
)
)
;
}
}
)
;
}
)
;
}
async
init
(
channel
)
{
this
.
#
label
=
channel
.
label
;
const
initPromise
=
this
.
#
sendRequestToWorker
(
'
init
'
channel
[
channel
]
)
;
this
.
#
dcAttrs
=
await
Promise
.
race
(
[
initPromise
this
.
#
errorPromise
]
)
;
return
this
.
#
dcAttrs
;
}
static
makeWorker
(
)
{
return
new
Worker
(
'
/
webrtc
/
RTCDataChannel
-
worker
.
js
'
)
;
}
get
worker
(
)
{
return
this
.
#
worker
;
}
get
label
(
)
{
return
this
.
#
dcAttrs
.
label
;
}
get
ordered
(
)
{
return
this
.
#
dcAttrs
.
ordered
;
}
get
maxPacketLifeTime
(
)
{
return
this
.
#
dcAttrs
.
maxPacketLifeTime
;
}
get
maxRetransmits
(
)
{
return
this
.
#
dcAttrs
.
maxRetransmits
;
}
get
protocol
(
)
{
return
this
.
#
dcAttrs
.
protocol
;
}
get
negotiated
(
)
{
return
this
.
#
dcAttrs
.
negotiated
;
}
get
id
(
)
{
return
this
.
#
dcAttrs
.
id
;
}
get
readyState
(
)
{
return
this
.
#
dcAttrs
.
readyState
;
}
get
bufferedAmount
(
)
{
return
this
.
#
dcAttrs
.
bufferedAmount
;
}
set
bufferedAmountLowThreshold
(
val
)
{
this
.
#
dcAttrs
.
bufferedAmountLowThreshold
=
val
;
this
.
#
sendRequestToWorker
(
'
setBufferedAmountLowThreshold
'
val
)
;
}
get
bufferedAmountLowThreshold
(
)
{
return
this
.
#
dcAttrs
.
bufferedAmountLowThreshold
;
}
set
binaryType
(
val
)
{
this
.
#
dcAttrs
.
binaryType
=
val
;
this
.
#
sendRequestToWorker
(
'
setBinaryType
'
val
)
;
}
get
binaryType
(
)
{
return
this
.
#
dcAttrs
.
binaryType
;
}
set
onopen
(
fn
)
{
this
.
#
setEventHandler
(
'
open
'
fn
)
;
}
set
onbufferedamountlow
(
fn
)
{
this
.
#
setEventHandler
(
'
bufferedamountlow
'
fn
)
;
}
set
onerror
(
fn
)
{
this
.
#
setEventHandler
(
'
error
'
fn
)
;
}
set
onclosing
(
fn
)
{
this
.
#
setEventHandler
(
'
closing
'
fn
)
;
}
set
onclose
(
fn
)
{
this
.
#
setEventHandler
(
'
close
'
fn
)
;
}
set
onmessage
(
fn
)
{
this
.
#
setEventHandler
(
'
message
'
fn
)
;
}
async
send
(
data
)
{
return
this
.
#
sendRequestToWorker
(
'
send
'
data
)
;
}
async
close
(
)
{
return
this
.
#
sendRequestToWorker
(
'
close
'
)
;
}
async
updateState
(
)
{
const
resp
=
await
Promise
.
race
(
[
this
.
#
sendRequestToWorker
(
'
queryState
'
)
this
.
#
errorPromise
]
)
;
this
.
#
dcAttrs
.
readyState
=
resp
.
readyState
;
this
.
#
dcAttrs
.
bufferedAmount
=
resp
.
bufferedAmount
;
this
.
#
dcAttrs
.
id
=
resp
.
id
;
return
resp
;
}
#
setEventHandler
(
type
handler
)
{
this
.
removeEventListener
(
type
this
.
#
eventHandlers
.
get
(
type
)
)
;
this
.
#
eventHandlers
.
delete
(
type
)
;
if
(
handler
)
{
this
.
addEventListener
(
type
handler
)
;
this
.
#
eventHandlers
.
set
(
type
handler
)
;
}
}
#
listenForEventMessages
(
)
{
this
.
#
worker
.
addEventListener
(
'
message
'
(
{
data
}
)
=
>
{
const
{
type
label
result
}
=
data
;
const
eventTypes
=
[
'
open
'
'
bufferedamountlow
'
'
error
'
'
closing
'
'
close
'
'
message
'
]
;
if
(
label
=
=
this
.
#
label
&
&
eventTypes
.
includes
(
type
)
)
{
let
e
;
if
(
type
=
=
'
message
'
)
{
const
{
data
origin
}
=
result
;
e
=
new
MessageEvent
(
type
{
data
origin
}
)
;
}
else
{
e
=
new
Event
(
type
)
;
}
this
.
dispatchEvent
(
e
)
;
}
}
)
;
}
#
sendRequestToWorker
(
type
arg
transferOrOptions
)
{
if
(
!
this
.
#
label
)
{
throw
new
Error
(
'
RTCDataChannel
worker
shim
not
initialized
!
'
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
msg
=
{
type
label
:
this
.
#
label
arg
}
;
const
responseType
=
{
type
}
Response
const
onResponse
=
(
{
data
}
)
=
>
{
const
{
type
label
result
}
=
data
;
if
(
type
=
=
responseType
&
&
label
=
=
this
.
#
label
)
{
this
.
#
worker
.
removeEventListener
(
'
message
'
onResponse
)
;
if
(
result
?
.
error
)
{
reject
(
new
Error
(
RTCDataChannel
error
:
{
result
.
error
.
message
}
)
)
;
}
else
{
resolve
(
result
)
;
}
}
}
;
this
.
#
worker
.
addEventListener
(
'
message
'
onResponse
)
;
this
.
#
worker
.
postMessage
(
msg
transferOrOptions
)
;
}
)
;
}
}
