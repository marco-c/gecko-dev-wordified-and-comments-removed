'
use
strict
'
;
const
ridExtensions
=
[
'
urn
:
ietf
:
params
:
rtp
-
hdrext
:
sdes
:
rtp
-
stream
-
id
'
'
urn
:
ietf
:
params
:
rtp
-
hdrext
:
sdes
:
repaired
-
rtp
-
stream
-
id
'
]
;
function
ridToMid
(
description
rids
)
{
const
sections
=
SDPUtils
.
splitSections
(
description
.
sdp
)
;
const
dtls
=
SDPUtils
.
getDtlsParameters
(
sections
[
1
]
sections
[
0
]
)
;
const
ice
=
SDPUtils
.
getIceParameters
(
sections
[
1
]
sections
[
0
]
)
;
const
rtpParameters
=
SDPUtils
.
parseRtpParameters
(
sections
[
1
]
)
;
const
setupValue
=
SDPUtils
.
matchPrefix
(
description
.
sdp
'
a
=
setup
:
'
)
[
0
]
.
substring
(
8
)
;
const
direction
=
SDPUtils
.
getDirection
(
sections
[
1
]
)
;
const
mline
=
SDPUtils
.
parseMLine
(
sections
[
1
]
)
;
rtpParameters
.
headerExtensions
=
rtpParameters
.
headerExtensions
.
filter
(
ext
=
>
ext
.
uri
!
=
'
urn
:
ietf
:
params
:
rtp
-
hdrext
:
sdes
:
mid
'
)
;
for
(
const
ext
of
rtpParameters
.
headerExtensions
)
{
if
(
ext
.
uri
=
=
=
'
urn
:
ietf
:
params
:
rtp
-
hdrext
:
sdes
:
rtp
-
stream
-
id
'
)
{
ext
.
uri
=
'
urn
:
ietf
:
params
:
rtp
-
hdrext
:
sdes
:
mid
'
;
}
}
rtpParameters
.
codecs
=
rtpParameters
.
codecs
.
filter
(
c
=
>
c
.
name
.
toUpperCase
(
)
!
=
=
'
RTX
'
)
;
if
(
!
rids
)
{
rids
=
SDPUtils
.
matchPrefix
(
sections
[
1
]
'
a
=
rid
:
'
)
.
filter
(
line
=
>
line
.
endsWith
(
'
send
'
)
)
.
map
(
line
=
>
line
.
substring
(
6
)
.
split
(
'
'
)
[
0
]
)
;
}
let
sdp
=
SDPUtils
.
writeSessionBoilerplate
(
)
+
SDPUtils
.
writeDtlsParameters
(
dtls
setupValue
)
+
SDPUtils
.
writeIceParameters
(
ice
)
+
'
a
=
group
:
BUNDLE
'
+
rids
.
join
(
'
'
)
+
'
\
r
\
n
'
;
const
baseRtpDescription
=
SDPUtils
.
writeRtpDescription
(
mline
.
kind
rtpParameters
)
;
for
(
const
rid
of
rids
)
{
sdp
+
=
baseRtpDescription
+
'
a
=
mid
:
'
+
rid
+
'
\
r
\
n
'
+
'
a
=
msid
:
rid
-
'
+
rid
+
'
rid
-
'
+
rid
+
'
\
r
\
n
'
;
sdp
+
=
'
a
=
'
+
direction
+
'
\
r
\
n
'
;
}
return
sdp
;
}
function
midToRid
(
description
localDescription
rids
)
{
const
sections
=
SDPUtils
.
splitSections
(
description
.
sdp
)
;
const
dtls
=
SDPUtils
.
getDtlsParameters
(
sections
[
1
]
sections
[
0
]
)
;
const
ice
=
SDPUtils
.
getIceParameters
(
sections
[
1
]
sections
[
0
]
)
;
const
rtpParameters
=
SDPUtils
.
parseRtpParameters
(
sections
[
1
]
)
;
const
setupValue
=
description
.
sdp
.
match
(
/
a
=
setup
:
(
.
*
)
/
)
[
1
]
;
const
direction
=
SDPUtils
.
getDirection
(
sections
[
1
]
)
;
const
mline
=
SDPUtils
.
parseMLine
(
sections
[
1
]
)
;
rtpParameters
.
headerExtensions
=
rtpParameters
.
headerExtensions
.
filter
(
ext
=
>
!
ridExtensions
.
includes
(
ext
.
uri
)
)
;
for
(
const
ext
of
rtpParameters
.
headerExtensions
)
{
if
(
ext
.
uri
=
=
=
'
urn
:
ietf
:
params
:
rtp
-
hdrext
:
sdes
:
mid
'
)
{
ext
.
uri
=
'
urn
:
ietf
:
params
:
rtp
-
hdrext
:
sdes
:
rtp
-
stream
-
id
'
;
}
}
const
localMid
=
localDescription
?
SDPUtils
.
getMid
(
SDPUtils
.
splitSections
(
localDescription
.
sdp
)
[
1
]
)
:
'
0
'
;
if
(
localDescription
)
{
const
localVideoSection
=
SDPUtils
.
splitSections
(
localDescription
.
sdp
)
[
1
]
;
const
localParameters
=
SDPUtils
.
parseRtpParameters
(
localVideoSection
)
;
const
localMidExtension
=
localParameters
.
headerExtensions
.
find
(
ext
=
>
ext
.
uri
=
=
=
'
urn
:
ietf
:
params
:
rtp
-
hdrext
:
sdes
:
mid
'
)
;
if
(
localMidExtension
)
{
rtpParameters
.
headerExtensions
.
push
(
localMidExtension
)
;
}
}
if
(
!
rids
)
{
rids
=
[
]
;
for
(
let
i
=
1
;
i
<
sections
.
length
;
i
+
+
)
{
rids
.
push
(
SDPUtils
.
getMid
(
sections
[
i
]
)
)
;
}
}
let
sdp
=
SDPUtils
.
writeSessionBoilerplate
(
)
+
SDPUtils
.
writeDtlsParameters
(
dtls
setupValue
)
+
SDPUtils
.
writeIceParameters
(
ice
)
+
'
a
=
group
:
BUNDLE
'
+
localMid
+
'
\
r
\
n
'
;
sdp
+
=
SDPUtils
.
writeRtpDescription
(
mline
.
kind
rtpParameters
)
;
sdp
+
=
'
a
=
mid
:
'
+
localMid
+
'
\
r
\
n
'
;
sdp
+
=
'
a
=
'
+
direction
+
'
\
r
\
n
'
;
for
(
const
rid
of
rids
)
{
const
stringrid
=
String
(
rid
)
;
const
choices
=
stringrid
.
split
(
'
'
)
;
choices
.
forEach
(
choice
=
>
{
sdp
+
=
'
a
=
rid
:
'
+
choice
+
'
recv
\
r
\
n
'
;
}
)
;
}
if
(
rids
.
length
)
{
sdp
+
=
'
a
=
simulcast
:
recv
'
+
rids
.
join
(
'
;
'
)
+
'
\
r
\
n
'
;
}
return
sdp
;
}
async
function
doOfferToSendSimulcast
(
offerer
answerer
)
{
await
offerer
.
setLocalDescription
(
)
;
let
mids
=
[
]
;
if
(
answerer
.
localDescription
)
{
const
sections
=
SDPUtils
.
splitSections
(
answerer
.
localDescription
.
sdp
)
;
sections
.
shift
(
)
;
mids
=
sections
.
map
(
section
=
>
SDPUtils
.
getMid
(
section
)
)
;
}
else
{
const
simulcastAttr
=
SDPUtils
.
matchPrefix
(
offerer
.
localDescription
.
sdp
'
a
=
simulcast
:
send
'
)
[
0
]
;
if
(
simulcastAttr
)
{
mids
=
simulcastAttr
.
split
(
'
'
)
[
1
]
.
split
(
'
;
'
)
;
}
}
const
nonSimulcastOffer
=
ridToMid
(
offerer
.
localDescription
mids
)
;
await
answerer
.
setRemoteDescription
(
{
type
:
'
offer
'
sdp
:
nonSimulcastOffer
}
)
;
}
async
function
doAnswerToRecvSimulcast
(
offerer
answerer
rids
)
{
await
answerer
.
setLocalDescription
(
)
;
const
simulcastAnswer
=
midToRid
(
answerer
.
localDescription
offerer
.
localDescription
rids
)
;
await
offerer
.
setRemoteDescription
(
{
type
:
'
answer
'
sdp
:
simulcastAnswer
}
)
;
}
async
function
doOfferToRecvSimulcast
(
offerer
answerer
rids
)
{
await
offerer
.
setLocalDescription
(
)
;
const
simulcastOffer
=
midToRid
(
offerer
.
localDescription
answerer
.
localDescription
rids
)
;
await
answerer
.
setRemoteDescription
(
{
type
:
'
offer
'
sdp
:
simulcastOffer
}
)
;
}
async
function
doAnswerToSendSimulcast
(
offerer
answerer
)
{
await
answerer
.
setLocalDescription
(
)
;
const
sections
=
SDPUtils
.
splitSections
(
offerer
.
localDescription
.
sdp
)
;
sections
.
shift
(
)
;
const
mids
=
sections
.
map
(
section
=
>
SDPUtils
.
getMid
(
section
)
)
;
const
nonSimulcastAnswer
=
ridToMid
(
answerer
.
localDescription
mids
)
;
await
offerer
.
setRemoteDescription
(
{
type
:
'
answer
'
sdp
:
nonSimulcastAnswer
}
)
;
}
async
function
doOfferToSendSimulcastAndAnswer
(
offerer
answerer
rids
)
{
await
doOfferToSendSimulcast
(
offerer
answerer
)
;
await
doAnswerToRecvSimulcast
(
offerer
answerer
rids
)
;
}
async
function
doOfferToRecvSimulcastAndAnswer
(
offerer
answerer
rids
)
{
await
doOfferToRecvSimulcast
(
offerer
answerer
rids
)
;
await
doAnswerToSendSimulcast
(
offerer
answerer
)
;
}
function
swapRidAndMidExtensionsInSimulcastOffer
(
offer
rids
)
{
return
ridToMid
(
offer
rids
)
;
}
function
swapRidAndMidExtensionsInSimulcastAnswer
(
answer
localDescription
rids
)
{
return
midToRid
(
answer
localDescription
rids
)
;
}
async
function
negotiateSimulcastAndWaitForVideo
(
t
rids
pc1
pc2
codec
scalabilityMode
=
undefined
)
{
exchangeIceCandidates
(
pc1
pc2
)
;
const
metadataToBeLoaded
=
[
]
;
pc2
.
ontrack
=
(
e
)
=
>
{
const
stream
=
e
.
streams
[
0
]
;
const
v
=
document
.
createElement
(
'
video
'
)
;
v
.
autoplay
=
true
;
v
.
srcObject
=
stream
;
v
.
id
=
stream
.
id
metadataToBeLoaded
.
push
(
new
Promise
(
(
resolve
)
=
>
{
v
.
addEventListener
(
'
loadedmetadata
'
(
)
=
>
{
resolve
(
)
;
}
)
;
}
)
)
;
}
;
const
sendEncodings
=
rids
.
map
(
rid
=
>
(
{
rid
}
)
)
;
let
scaleResolutionDownBy
=
2
;
for
(
let
i
=
sendEncodings
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
scalabilityMode
)
{
sendEncodings
[
i
]
.
scalabilityMode
=
scalabilityMode
;
}
sendEncodings
[
i
]
.
scaleResolutionDownBy
=
scaleResolutionDownBy
;
scaleResolutionDownBy
*
=
2
;
}
await
setMediaPermission
(
)
;
const
stream
=
await
navigator
.
mediaDevices
.
getUserMedia
(
{
video
:
{
width
:
1280
height
:
720
}
}
)
;
t
.
add_cleanup
(
(
)
=
>
stream
.
getTracks
(
)
.
forEach
(
track
=
>
track
.
stop
(
)
)
)
;
const
transceiver
=
pc1
.
addTransceiver
(
stream
.
getVideoTracks
(
)
[
0
]
{
streams
:
[
stream
]
sendEncodings
:
sendEncodings
}
)
;
if
(
codec
)
{
preferCodec
(
transceiver
codec
.
mimeType
codec
.
sdpFmtpLine
)
;
}
const
offer
=
await
pc1
.
createOffer
(
)
;
await
pc1
.
setLocalDescription
(
offer
)
await
pc2
.
setRemoteDescription
(
{
type
:
'
offer
'
sdp
:
swapRidAndMidExtensionsInSimulcastOffer
(
offer
rids
)
}
)
;
const
answer
=
await
pc2
.
createAnswer
(
)
;
await
pc2
.
setLocalDescription
(
answer
)
;
await
pc1
.
setRemoteDescription
(
{
type
:
'
answer
'
sdp
:
swapRidAndMidExtensionsInSimulcastAnswer
(
answer
pc1
.
localDescription
rids
)
}
)
;
assert_equals
(
metadataToBeLoaded
.
length
rids
.
length
)
;
return
Promise
.
all
(
metadataToBeLoaded
)
;
}
