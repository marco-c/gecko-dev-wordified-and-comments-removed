'
use
strict
'
;
function
postInheritPriorityTestTask
(
config
)
{
const
ids
=
[
]
;
const
task
=
scheduler
.
postTask
(
async
(
)
=
>
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
)
)
;
await
fetch
(
'
/
common
/
blank
.
html
'
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
)
)
;
const
subtask
=
scheduler
.
postTask
(
(
)
=
>
{
ids
.
push
(
'
subtask
'
)
;
}
{
priority
:
config
.
subTaskPriority
}
)
;
await
scheduler
.
yield
(
)
;
ids
.
push
(
'
yield
'
)
;
await
subtask
;
}
config
.
taskOptions
)
;
return
{
task
ids
}
}
for
(
let
priority
of
[
'
user
-
blocking
'
'
background
'
]
)
{
const
expected
=
priority
=
=
'
user
-
blocking
'
?
'
yield
subtask
'
:
'
subtask
yield
'
;
promise_test
(
async
t
=
>
{
const
config
=
{
taskOptions
:
{
priority
}
subTaskPriority
:
'
user
-
blocking
'
}
;
const
{
task
ids
}
=
postInheritPriorityTestTask
(
config
)
;
await
task
;
assert_equals
(
ids
.
join
(
)
expected
)
;
}
yield
(
)
inherits
priority
(
string
)
across
promises
(
{
priority
}
)
)
;
promise_test
(
async
t
=
>
{
const
signal
=
(
new
TaskController
(
{
priority
}
)
)
.
signal
;
const
config
=
{
taskOptions
:
{
signal
}
subTaskPriority
:
'
user
-
blocking
'
}
;
const
{
task
ids
}
=
postInheritPriorityTestTask
(
config
)
;
await
task
;
assert_equals
(
ids
.
join
(
)
expected
)
;
}
yield
(
)
inherits
priority
(
signal
)
across
promises
(
{
priority
}
)
)
;
}
promise_test
(
async
t
=
>
{
const
controller
=
new
TaskController
(
)
;
const
signal
=
controller
.
signal
;
return
scheduler
.
postTask
(
async
(
)
=
>
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
)
)
;
await
fetch
(
'
/
common
/
blank
.
html
'
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
)
)
;
controller
.
abort
(
)
;
const
p
=
scheduler
.
yield
(
)
;
await
promise_rejects_dom
(
t
'
AbortError
'
p
)
;
}
{
signal
}
)
;
}
yield
(
)
inherits
abort
across
promises
)
;
promise_test
(
async
t
=
>
{
const
ids
=
[
]
;
let
{
promise
:
p1
resolve
}
=
Promise
.
withResolvers
(
)
;
p1
=
p1
.
then
(
async
(
)
=
>
{
await
scheduler
.
yield
(
)
;
ids
.
push
(
'
continuation
'
)
;
}
)
;
await
scheduler
.
postTask
(
resolve
{
priority
:
'
user
-
blocking
'
}
)
;
const
p2
=
scheduler
.
postTask
(
(
)
=
>
{
ids
.
push
(
'
task
'
)
;
}
{
priority
:
'
user
-
blocking
'
}
)
;
const
result
=
await
Promise
.
all
(
[
p1
p2
]
)
;
assert_equals
(
ids
.
toString
(
)
'
task
continuation
'
)
;
}
'
yield
(
)
inherits
.
then
(
)
context
not
resolve
context
'
)
;
promise_test
(
async
t
=
>
{
const
ids
=
[
]
;
let
{
promise
:
p1
resolve
}
=
Promise
.
withResolvers
(
)
;
p1
=
p1
.
then
(
async
(
)
=
>
{
ids
.
push
(
'
p1
-
start
'
)
;
await
scheduler
.
yield
(
)
;
ids
.
push
(
'
p1
-
continuation
'
)
;
}
)
;
const
p2
=
scheduler
.
postTask
(
async
(
)
=
>
{
resolve
(
)
;
queueMicrotask
(
async
(
)
=
>
{
ids
.
push
(
'
p2
-
start
'
)
;
await
scheduler
.
yield
(
)
;
ids
.
push
(
'
p2
-
continuation
'
)
;
}
)
}
{
priority
:
'
user
-
blocking
'
}
)
;
const
p3
=
scheduler
.
postTask
(
(
)
=
>
{
ids
.
push
(
'
p3
'
)
;
}
{
priority
:
'
user
-
blocking
'
}
)
;
await
Promise
.
all
(
[
p1
p2
p3
]
)
;
assert_equals
(
ids
.
toString
(
)
"
p1
-
start
p2
-
start
p2
-
continuation
p3
p1
-
continuation
"
)
;
}
'
yield
(
)
inherits
priority
in
queueMicrotask
(
)
'
)
;
