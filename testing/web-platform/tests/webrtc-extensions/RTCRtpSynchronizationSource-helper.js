'
use
strict
'
;
var
kAbsCaptureTime
=
'
http
:
/
/
www
.
webrtc
.
org
/
experiments
/
rtp
-
hdrext
/
abs
-
capture
-
time
'
;
function
addHeaderExtensionToSdp
(
sdp
uri
)
{
const
extmap
=
new
RegExp
(
'
a
=
extmap
:
(
\
\
d
+
)
'
)
;
let
sdpLines
=
sdp
.
split
(
'
\
r
\
n
'
)
;
for
(
const
section
of
[
'
audio
'
'
video
'
]
)
{
let
found_section
=
false
;
let
maxId
=
undefined
;
let
maxIdLine
=
undefined
;
let
extmapAllowMixed
=
false
;
for
(
let
i
=
0
;
i
<
sdpLines
.
length
;
+
+
i
)
{
if
(
!
found_section
)
{
if
(
sdpLines
[
i
]
.
startsWith
(
'
m
=
'
+
section
)
)
{
found_section
=
true
;
}
continue
;
}
else
{
if
(
sdpLines
[
i
]
.
startsWith
(
'
m
=
'
)
)
{
break
;
}
}
if
(
sdpLines
[
i
]
=
=
=
'
a
=
extmap
-
allow
-
mixed
'
)
{
extmapAllowMixed
=
true
;
}
let
result
=
sdpLines
[
i
]
.
match
(
extmap
)
;
if
(
result
&
&
result
.
length
=
=
=
2
)
{
if
(
maxId
=
=
undefined
|
|
result
[
1
]
>
maxId
)
{
maxId
=
parseInt
(
result
[
1
]
)
;
maxIdLine
=
i
;
}
}
}
if
(
maxId
=
=
14
&
&
!
extmapAllowMixed
)
{
sdpLines
.
splice
(
maxIdLine
+
1
0
'
a
=
extmap
-
allow
-
mixed
'
)
;
}
if
(
maxIdLine
!
=
=
undefined
)
{
sdpLines
.
splice
(
maxIdLine
+
1
0
'
a
=
extmap
:
'
+
(
maxId
+
1
)
.
toString
(
)
+
'
'
+
uri
)
;
}
}
return
sdpLines
.
join
(
'
\
r
\
n
'
)
;
}
async
function
addAbsCaptureTimeAndExchangeOffer
(
caller
callee
)
{
let
offer
=
await
caller
.
createOffer
(
)
;
offer
.
sdp
=
addHeaderExtensionToSdp
(
offer
.
sdp
kAbsCaptureTime
)
;
await
caller
.
setLocalDescription
(
offer
)
;
return
callee
.
setRemoteDescription
(
offer
)
;
}
async
function
checkAbsCaptureTimeAndExchangeAnswer
(
caller
callee
absCaptureTimeAnswered
)
{
let
answer
=
await
callee
.
createAnswer
(
)
;
const
extmap
=
new
RegExp
(
'
a
=
extmap
:
\
\
d
+
'
+
kAbsCaptureTime
+
'
\
r
\
n
'
'
g
'
)
;
if
(
answer
.
sdp
.
match
(
extmap
)
=
=
null
)
{
assert_false
(
absCaptureTimeAnswered
'
Absolute
capture
time
RTP
'
+
'
header
extension
is
not
answered
'
)
;
}
else
{
if
(
!
absCaptureTimeAnswered
)
{
answer
.
sdp
=
answer
.
sdp
.
replace
(
extmap
'
'
)
;
}
}
await
callee
.
setLocalDescription
(
answer
)
;
return
caller
.
setRemoteDescription
(
answer
)
;
}
async
function
exchangeOfferAndListenToOntrack
(
t
caller
callee
absCaptureTimeOffered
)
{
const
ontrackPromise
=
addEventListenerPromise
(
t
callee
'
track
'
)
;
await
absCaptureTimeOffered
?
addAbsCaptureTimeAndExchangeOffer
(
caller
callee
)
:
exchangeOffer
(
caller
callee
)
;
return
ontrackPromise
;
}
async
function
initiateSingleTrackCall
(
t
cap
absCaptureTimeOffered
absCaptureTimeAnswered
)
{
const
caller
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
caller
.
close
(
)
)
;
const
callee
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
callee
.
close
(
)
)
;
const
stream
=
await
getNoiseStream
(
cap
)
;
stream
.
getTracks
(
)
.
forEach
(
track
=
>
{
caller
.
addTrack
(
track
stream
)
;
t
.
add_cleanup
(
(
)
=
>
track
.
stop
(
)
)
;
}
)
;
const
remoteVideo
=
document
.
getElementById
(
'
remote
'
)
;
callee
.
ontrack
=
e
=
>
{
remoteVideo
.
srcObject
=
e
.
streams
[
0
]
;
}
exchangeIceCandidates
(
caller
callee
)
;
await
exchangeOfferAndListenToOntrack
(
t
caller
callee
absCaptureTimeOffered
)
;
await
checkAbsCaptureTimeAndExchangeAnswer
(
caller
callee
absCaptureTimeAnswered
)
;
return
[
caller
callee
]
;
}
