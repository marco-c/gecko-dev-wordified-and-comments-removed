const
cspDirectives
=
[
"
require
-
trusted
-
types
-
for
"
"
trusted
-
types
"
"
script
-
src
"
]
;
function
trusted_type_violations_and_exception_for
(
fn
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
result
=
{
violations
:
[
]
exception
:
null
}
;
let
handler
=
e
=
>
{
if
(
cspDirectives
.
includes
(
e
.
effectiveDirective
)
)
{
result
.
violations
.
push
(
e
)
;
}
else
if
(
e
.
effectiveDirective
=
=
=
"
connect
-
src
"
)
{
self
.
removeEventListener
(
"
securitypolicyviolation
"
handler
)
;
e
.
stopPropagation
(
)
;
resolve
(
result
)
;
}
else
{
reject
(
Unexpected
violation
for
directive
{
e
.
effectiveDirective
}
)
;
}
}
self
.
addEventListener
(
"
securitypolicyviolation
"
handler
)
;
try
{
fn
(
)
;
}
catch
(
e
)
{
result
.
exception
=
e
;
}
try
{
new
WebSocket
(
"
ws
:
/
common
/
blank
.
html
"
)
;
}
catch
(
e
)
{
if
(
(
!
e
instanceof
DOMException
|
|
e
.
name
!
=
=
"
SecurityError
"
)
&
&
e
.
name
!
=
=
"
NS_ERROR_CONTENT_BLOCKED
"
)
{
throw
e
;
}
}
}
)
;
}
async
function
trusted_type_violation_for
(
expectedException
fn
)
{
let
{
violations
exception
}
=
await
trusted_type_violations_and_exception_for
(
fn
)
;
assert_equals
(
violations
.
length
1
"
a
single
violation
reported
"
)
;
assert_true
(
exception
instanceof
expectedException
{
expectedException
.
prototype
}
exception
reported
)
;
return
violations
[
0
]
;
}
async
function
no_trusted_type_violation_for
(
fn
)
{
let
{
violations
exception
}
=
await
trusted_type_violations_and_exception_for
(
fn
)
;
assert_equals
(
violations
.
length
0
"
no
violation
reported
"
)
;
assert_equals
(
exception
null
"
no
exception
thrown
"
)
;
}
async
function
trusted_type_violation_without_exception_for
(
fn
)
{
let
{
violations
exception
}
=
await
trusted_type_violations_and_exception_for
(
fn
)
;
assert_equals
(
violations
.
length
1
"
a
single
violation
reported
"
)
;
assert_equals
(
exception
null
"
no
exception
thrown
"
)
;
return
violations
[
0
]
;
}
function
clipSampleIfNeeded
(
sample
)
{
const
clippedSampleLength
=
40
;
assert_equals
(
sample
.
match
(
/
[
\
uD800
-
\
uDBFF
]
[
\
uDC00
-
\
uDFFF
]
/
)
null
)
;
return
sample
.
substring
(
0
clippedSampleLength
)
;
}
function
tryCreatingTrustedTypePoliciesWithCSP
(
policyNames
cspHeaders
)
{
return
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
"
message
"
event
=
>
{
resolve
(
event
.
data
)
;
}
{
once
:
true
}
)
;
let
iframe
=
document
.
createElement
(
"
iframe
"
)
;
let
url
=
/
trusted
-
types
/
support
/
create
-
trusted
-
type
-
policies
.
html
?
policyNames
=
{
policyNames
.
map
(
name
=
>
encodeURIComponent
(
name
)
)
.
toString
(
)
}
;
url
+
=
"
&
pipe
=
header
(
Content
-
Security
-
Policy
connect
-
src
'
none
'
)
"
if
(
cspHeaders
)
url
+
=
|
{
cspHeaders
}
;
iframe
.
src
=
url
;
document
.
head
.
appendChild
(
iframe
)
;
}
)
;
}
function
trySendingPlainStringToTrustedTypeSink
(
sinkGroups
cspHeaders
)
{
return
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
"
message
"
event
=
>
{
resolve
(
event
.
data
)
;
}
{
once
:
true
}
)
;
let
iframe
=
document
.
createElement
(
"
iframe
"
)
;
let
url
=
/
trusted
-
types
/
support
/
send
-
plain
-
string
-
to
-
trusted
-
type
-
sink
.
html
?
sinkGroups
=
{
sinkGroups
.
map
(
name
=
>
encodeURIComponent
(
name
)
)
.
toString
(
)
}
;
url
+
=
"
&
pipe
=
header
(
Content
-
Security
-
Policy
connect
-
src
'
none
'
)
"
if
(
cspHeaders
)
url
+
=
|
{
cspHeaders
}
;
iframe
.
src
=
url
;
document
.
head
.
appendChild
(
iframe
)
;
}
)
;
}
