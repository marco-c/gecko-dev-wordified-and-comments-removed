const
cspDirectives
=
[
"
require
-
trusted
-
types
-
for
"
"
trusted
-
types
"
"
script
-
src
"
]
;
function
trusted_type_violations_and_exception_for
(
fn
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
result
=
{
violations
:
[
]
exception
:
null
}
;
let
handler
=
e
=
>
{
if
(
cspDirectives
.
includes
(
e
.
effectiveDirective
)
)
{
result
.
violations
.
push
(
e
)
;
}
else
if
(
e
.
effectiveDirective
=
=
=
"
object
-
src
"
)
{
document
.
removeEventListener
(
"
securitypolicyviolation
"
handler
)
;
e
.
stopPropagation
(
)
;
resolve
(
result
)
;
}
else
{
reject
(
Unexpected
violation
for
directive
{
e
.
effectiveDirective
}
)
;
}
}
document
.
addEventListener
(
"
securitypolicyviolation
"
handler
)
;
try
{
fn
(
)
;
}
catch
(
e
)
{
result
.
exception
=
e
;
}
var
o
=
document
.
createElement
(
'
object
'
)
;
o
.
type
=
"
video
/
mp4
"
;
o
.
data
=
"
dummy
.
webm
"
;
document
.
body
.
appendChild
(
o
)
;
}
)
;
}
async
function
trusted_type_violation_for
(
expectedException
fn
)
{
let
{
violations
exception
}
=
await
trusted_type_violations_and_exception_for
(
fn
)
;
assert_equals
(
violations
.
length
1
"
a
single
violation
reported
"
)
;
assert_true
(
exception
instanceof
expectedException
{
expectedException
.
prototype
}
exception
reported
)
;
return
violations
[
0
]
;
}
async
function
no_trusted_type_violation_for
(
fn
)
{
let
{
violations
exception
}
=
await
trusted_type_violations_and_exception_for
(
fn
)
;
assert_equals
(
violations
.
length
0
"
no
violation
reported
"
)
;
assert_equals
(
exception
null
"
no
exception
thrown
"
)
;
}
async
function
trusted_type_violation_without_exception_for
(
fn
)
{
let
{
violations
exception
}
=
await
trusted_type_violations_and_exception_for
(
fn
)
;
assert_equals
(
violations
.
length
1
"
a
single
violation
reported
"
)
;
assert_equals
(
exception
null
"
no
exception
thrown
"
)
;
return
violations
[
0
]
;
}
function
clipSampleIfNeeded
(
sample
)
{
const
clippedSampleLength
=
40
;
assert_equals
(
sample
.
match
(
/
[
\
uD800
-
\
uDBFF
]
[
\
uDC00
-
\
uDFFF
]
/
)
null
)
;
return
sample
.
substring
(
0
clippedSampleLength
)
;
}
