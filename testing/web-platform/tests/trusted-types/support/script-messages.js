'
use
strict
'
const
LOG_RUN_MESSAGE
=
window
.
log_message
(
"
RUN
"
)
;
function
create_html_script_with_trusted_source_text
(
source_text
)
{
let
script
=
document
.
createElement
(
"
script
"
)
;
script
.
text
=
passthroughpolicy
.
createScript
(
source_text
)
;
return
script
;
}
function
create_html_script_with_untrusted_source_text
(
source_text
)
{
let
script
=
document
.
createElement
(
"
script
"
)
;
script
.
appendChild
(
document
.
createTextNode
(
source_text
)
)
;
return
script
;
}
function
create_svg_script_with_trusted_source_text
(
source_text
)
{
let
script
=
Array
.
from
(
document
.
querySelectorAll
(
"
svg
script
[
type
=
'
unknown
'
]
"
)
)
.
find
(
script
=
>
script
.
textContent
=
=
=
source_text
)
;
assert_true
(
!
!
script
<
script
type
=
"
unknown
"
>
{
source_text
}
<
/
script
>
not
found
!
)
;
script
.
remove
(
)
;
script
.
removeAttribute
(
"
type
"
)
;
return
script
;
}
function
create_svg_script_with_untrusted_source_text
(
source_text
)
{
let
script
=
document
.
createElementNS
(
NSURI_SVG
"
script
"
)
script
.
appendChild
(
document
.
createTextNode
(
source_text
)
)
;
return
script
;
}
function
script_messages_for
(
fn
)
{
return
new
Promise
(
async
(
resolve
reject
)
=
>
{
let
messages
=
[
]
;
let
exception
=
null
;
window
.
log_message
=
message
=
>
{
if
(
message
=
=
=
"
DONE
"
)
{
window
.
log_message
=
null
;
if
(
exception
)
{
reject
(
exception
)
;
}
else
{
resolve
(
messages
)
;
}
}
else
{
messages
.
push
(
message
)
;
}
}
;
try
{
await
fn
(
)
;
}
catch
(
e
)
{
exception
=
e
;
}
requestAnimationFrame
(
_
=
>
requestAnimationFrame
(
_
=
>
{
let
script
=
create_html_script_with_trusted_source_text
(
window
.
log_message
(
"
DONE
"
)
)
;
script
.
setAttribute
(
"
nonce
"
"
script
-
messages
"
)
;
document
.
body
.
appendChild
(
script
)
;
}
)
)
;
}
)
;
}
async
function
script_message_for
(
fn
)
{
let
messages
=
await
script_messages_for
(
fn
)
;
assert_equals
(
messages
.
length
1
Number
of
messages
(
{
messages
}
)
)
;
return
messages
[
0
]
;
}
async
function
no_script_message_for
(
fn
)
{
let
messages
=
await
script_messages_for
(
fn
)
;
assert_equals
(
messages
.
length
0
Number
of
messages
(
{
messages
}
)
)
;
}
async
function
base64_hash_for_inline_script
(
source_text
algorithm
)
{
const
encoder
=
new
TextEncoder
(
)
;
const
data
=
encoder
.
encode
(
source_text
)
;
const
hashBuffer
=
await
window
.
crypto
.
subtle
.
digest
(
algorithm
data
)
;
const
base64Array
=
(
new
Uint8Array
(
hashBuffer
)
)
.
toBase64
(
)
;
return
base64Array
.
toString
(
)
;
}
