async
function
getAndExpireCookiesForDefaultPathTest
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
try
{
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
style
=
'
display
:
none
'
;
iframe
.
src
=
'
/
cookies
/
resources
/
echo
-
cookie
.
html
'
;
iframe
.
addEventListener
(
'
load
'
(
e
)
=
>
{
const
win
=
e
.
target
.
contentWindow
;
const
iframeCookies
=
win
.
getCookies
(
)
;
win
.
expireCookies
(
)
.
then
(
(
)
=
>
{
document
.
documentElement
.
removeChild
(
iframe
)
;
resolve
(
iframeCookies
)
;
}
)
;
}
{
once
:
true
}
)
;
document
.
documentElement
.
appendChild
(
iframe
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
;
}
async
function
getAndExpireCookiesForRedirectTest
(
location
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
try
{
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
style
=
'
display
:
none
'
;
iframe
.
src
=
location
;
const
listener
=
(
e
)
=
>
{
if
(
typeof
e
.
data
=
=
'
object
'
&
&
'
cookies
'
in
e
.
data
)
{
window
.
removeEventListener
(
'
message
'
listener
)
;
document
.
documentElement
.
removeChild
(
iframe
)
;
resolve
(
e
.
data
.
cookies
)
;
}
}
;
window
.
addEventListener
(
'
message
'
listener
)
;
iframe
.
addEventListener
(
'
load
'
(
e
)
=
>
{
e
.
target
.
contentWindow
.
postMessage
(
'
getAndExpireCookiesForRedirectTest
'
'
*
'
)
;
}
{
once
:
true
}
)
;
document
.
documentElement
.
appendChild
(
iframe
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
;
}
function
httpCookieTest
(
cookie
expectedValue
name
defaultPath
=
true
)
{
return
promise_test
(
async
(
t
)
=
>
{
await
getAndExpireCookiesForDefaultPathTest
(
)
;
await
test_driver
.
delete_all_cookies
(
)
;
t
.
add_cleanup
(
test_driver
.
delete_all_cookies
)
;
let
encodedCookie
=
encodeURIComponent
(
JSON
.
stringify
(
cookie
)
)
;
await
fetch
(
/
cookies
/
resources
/
cookie
.
py
?
set
=
{
encodedCookie
}
)
;
let
cookies
=
document
.
cookie
;
if
(
defaultPath
)
{
cookies
=
await
getAndExpireCookiesForDefaultPathTest
(
)
;
}
if
(
Boolean
(
expectedValue
)
)
{
assert_equals
(
cookies
expectedValue
'
The
cookie
was
set
as
expected
.
'
)
;
}
else
{
assert_equals
(
cookies
expectedValue
'
The
cookie
was
rejected
.
'
)
;
}
}
name
)
;
}
function
httpRedirectCookieTest
(
cookie
expectedValue
name
location
)
{
return
promise_test
(
async
(
t
)
=
>
{
await
getAndExpireCookiesForRedirectTest
(
location
)
;
const
encodedCookie
=
encodeURIComponent
(
JSON
.
stringify
(
cookie
)
)
;
const
encodedLocation
=
encodeURIComponent
(
location
)
;
const
setParams
=
?
set
=
{
encodedCookie
}
&
location
=
{
encodedLocation
}
;
await
fetch
(
/
cookies
/
resources
/
cookie
.
py
{
setParams
}
)
;
const
cookies
=
await
getAndExpireCookiesForRedirectTest
(
location
)
;
if
(
Boolean
(
expectedValue
)
)
{
assert_equals
(
cookies
expectedValue
'
The
cookie
was
set
as
expected
.
'
)
;
}
else
{
assert_equals
(
cookies
expectedValue
'
The
cookie
was
rejected
.
'
)
;
}
}
name
)
;
}
function
domCookieTest
(
cookie
expectedValue
name
)
{
return
promise_test
(
async
(
t
)
=
>
{
await
test_driver
.
delete_all_cookies
(
)
;
t
.
add_cleanup
(
test_driver
.
delete_all_cookies
)
;
if
(
typeof
cookie
=
=
=
"
string
"
)
{
document
.
cookie
=
cookie
;
}
else
if
(
Array
.
isArray
(
cookie
)
)
{
for
(
const
singlecookie
of
cookie
)
{
document
.
cookie
=
singlecookie
;
}
}
else
{
throw
new
Error
(
'
Unexpected
type
passed
into
domCookieTest
as
cookie
:
'
+
typeof
cookie
)
;
}
let
cookies
=
document
.
cookie
;
assert_equals
(
cookies
expectedValue
Boolean
(
expectedValue
)
?
'
The
cookie
was
set
as
expected
.
'
:
'
The
cookie
was
rejected
.
'
)
;
}
name
)
;
}
function
getCtlCharacters
(
)
{
const
ctlCodes
=
[
.
.
.
Array
(
0x20
)
.
keys
(
)
]
.
concat
(
[
0x7F
]
)
;
return
ctlCodes
.
map
(
i
=
>
(
{
code
:
i
chr
:
String
.
fromCharCode
(
i
)
}
)
)
}
function
cookieStringWithNameAndValueLengths
(
nameLength
valueLength
)
{
return
{
"
t
"
.
repeat
(
nameLength
)
}
=
{
"
1
"
.
repeat
(
valueLength
)
}
;
}
function
setTestContextUsingRootWindow
(
)
{
let
test_window
=
window
.
top
;
while
(
test_window
.
opener
&
&
!
test_window
.
opener
.
closed
)
{
test_window
=
test_window
.
opener
.
top
;
}
test_driver
.
set_test_context
(
test_window
)
;
}
