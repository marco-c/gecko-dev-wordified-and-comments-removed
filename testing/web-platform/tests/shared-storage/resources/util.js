'
use
strict
'
;
async
function
IsSharedStorageSelectUrlAllowed
(
)
{
let
allowed
=
true
;
try
{
await
sharedStorage
.
selectURL
(
"
operation
"
[
{
url
:
"
1
.
html
"
}
]
)
;
}
catch
(
e
)
{
allowed
=
false
;
}
return
allowed
;
}
async
function
AreRegularSharedStorageMethodsAllowed
(
)
{
let
deniedCount
=
0
;
try
{
await
window
.
sharedStorage
.
worklet
.
addModule
(
'
/
shared
-
storage
/
resources
/
simple
-
module
.
js
'
)
;
}
catch
(
e
)
{
+
+
deniedCount
;
}
try
{
await
window
.
sharedStorage
.
run
(
'
operation
'
{
keepAlive
:
true
}
)
;
}
catch
(
e
)
{
+
+
deniedCount
;
}
try
{
await
sharedStorage
.
selectURL
(
"
operation
"
[
{
url
:
"
1
.
html
"
}
]
{
keepAlive
:
true
}
)
;
}
catch
(
e
)
{
+
+
deniedCount
;
}
try
{
await
window
.
sharedStorage
.
set
(
'
a
'
'
b
'
)
;
}
catch
(
e
)
{
+
+
deniedCount
;
}
try
{
await
window
.
sharedStorage
.
append
(
'
a
'
'
b
'
)
;
}
catch
(
e
)
{
+
+
deniedCount
;
}
try
{
await
window
.
sharedStorage
.
clear
(
)
;
}
catch
(
e
)
{
+
+
deniedCount
;
}
try
{
await
window
.
sharedStorage
.
delete
(
'
a
'
)
;
}
catch
(
e
)
{
+
+
deniedCount
;
}
if
(
deniedCount
=
=
=
0
)
return
true
;
return
false
;
}
async
function
addModuleOnce
(
module
)
{
try
{
await
sharedStorage
.
worklet
.
addModule
(
module
)
;
}
catch
(
e
)
{
}
}
function
validateSelectURLResult
(
result
resolve_to_config
)
{
if
(
resolve_to_config
)
{
return
result
instanceof
FencedFrameConfig
;
}
return
result
.
startsWith
(
'
urn
:
uuid
:
'
)
;
}
function
updateUrlToUseNewOrigin
(
url
newOriginString
)
{
const
origin
=
url
.
origin
;
return
new
URL
(
url
.
toString
(
)
.
replace
(
origin
newOriginString
)
)
;
}
function
appendExpectedKeyAndValue
(
url
expectedKey
expectedValue
)
{
url
.
searchParams
.
append
(
'
expectedKey
'
expectedKey
)
;
url
.
searchParams
.
append
(
'
expectedValue
'
expectedValue
)
;
return
url
;
}
function
parseExpectedKeyAndValueData
(
)
{
const
url
=
new
URL
(
location
.
href
)
;
const
key
=
url
.
searchParams
.
get
(
'
expectedKey
'
)
;
const
value
=
url
.
searchParams
.
get
(
'
expectedValue
'
)
;
return
{
'
expectedKey
'
:
key
'
expectedValue
'
:
value
}
;
}
function
appendExpectedKey
(
url
expectedKey
)
{
url
.
searchParams
.
append
(
'
expectedKey
'
expectedKey
)
;
return
url
;
}
function
parseExpectedKeyData
(
)
{
const
url
=
new
URL
(
location
.
href
)
;
const
key
=
url
.
searchParams
.
get
(
'
expectedKey
'
)
;
return
{
'
expectedKey
'
:
key
}
;
}
async
function
verifyKeyValueForOrigin
(
key
value
origin
)
{
const
outerKey
=
token
(
)
;
const
innerKey
=
token
(
)
;
let
iframeUrl
=
generateURL
(
'
/
shared
-
storage
/
resources
/
verify
-
key
-
value
.
https
.
html
'
[
outerKey
innerKey
]
)
;
iframeUrl
=
updateUrlToUseNewOrigin
(
iframeUrl
origin
)
;
iframeUrl
=
appendExpectedKeyAndValue
(
iframeUrl
key
value
)
;
attachIFrame
(
iframeUrl
)
;
const
result
=
await
nextValueFromServer
(
outerKey
)
;
assert_equals
(
result
'
verify_key_value_loaded
'
)
;
}
async
function
verifyKeyNotFoundForOrigin
(
key
origin
)
{
const
outerKey
=
token
(
)
;
const
innerKey
=
token
(
)
;
let
iframeUrl
=
generateURL
(
'
/
shared
-
storage
/
resources
/
verify
-
key
-
not
-
found
.
https
.
html
'
[
outerKey
innerKey
]
)
;
iframeUrl
=
updateUrlToUseNewOrigin
(
iframeUrl
origin
)
;
iframeUrl
=
appendExpectedKey
(
iframeUrl
key
)
;
attachIFrame
(
iframeUrl
)
;
const
result
=
await
nextValueFromServer
(
outerKey
)
;
assert_equals
(
result
'
verify_key_not_found_loaded
'
)
;
}
async
function
setKeyValueForOrigin
(
key
value
origin
)
{
const
outerKey
=
token
(
)
;
let
setIframeUrl
=
generateURL
(
'
/
shared
-
storage
/
resources
/
set
-
key
-
value
.
https
.
html
'
[
outerKey
]
)
;
setIframeUrl
=
updateUrlToUseNewOrigin
(
setIframeUrl
origin
)
;
setIframeUrl
=
appendExpectedKeyAndValue
(
setIframeUrl
key
value
)
;
attachIFrame
(
setIframeUrl
)
;
const
result
=
await
nextValueFromServer
(
outerKey
)
;
assert_equals
(
result
'
set_key_value_loaded
'
)
;
}
async
function
deleteKeyForOrigin
(
key
origin
)
{
const
outerKey
=
token
(
)
;
let
deleteIframeUrl
=
generateURL
(
'
/
shared
-
storage
/
resources
/
delete
-
key
.
https
.
html
'
[
outerKey
]
)
;
deleteIframeUrl
=
updateUrlToUseNewOrigin
(
deleteIframeUrl
origin
)
;
deleteIframeUrl
=
appendExpectedKey
(
deleteIframeUrl
key
)
;
attachIFrame
(
deleteIframeUrl
)
;
const
result
=
await
nextValueFromServer
(
outerKey
)
;
assert_equals
(
result
'
delete_key_loaded
'
)
;
}
function
getFetchedUrls
(
worker
)
{
return
new
Promise
(
function
(
resolve
)
{
var
channel
=
new
MessageChannel
(
)
;
channel
.
port1
.
onmessage
=
function
(
msg
)
{
resolve
(
msg
)
;
}
;
worker
.
postMessage
(
{
port
:
channel
.
port2
}
[
channel
.
port2
]
)
;
}
)
;
}
function
checkInterceptedUrls
(
worker
expectedRequests
)
{
return
getFetchedUrls
(
worker
)
.
then
(
function
(
msg
)
{
let
actualRequests
=
msg
.
data
.
requests
;
assert_equals
(
actualRequests
.
length
expectedRequests
.
length
)
;
assert_equals
(
JSON
.
stringify
(
actualRequests
)
JSON
.
stringify
(
expectedRequests
)
)
;
}
)
;
}
function
attachIFrameWithEventListenerForSelectURLStatus
(
url
)
{
const
frame
=
document
.
createElement
(
'
iframe
'
)
;
frame
.
src
=
url
;
const
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
window
.
addEventListener
(
'
message
'
async
function
handler
(
evt
)
{
if
(
evt
.
source
=
=
=
frame
.
contentWindow
&
&
evt
.
data
.
selectURLStatus
)
{
document
.
body
.
removeChild
(
frame
)
;
window
.
removeEventListener
(
'
message
'
handler
)
;
if
(
evt
.
data
.
selectURLStatus
=
=
=
'
success
'
)
{
resolve
(
evt
.
data
)
;
}
else
{
reject
(
new
Error
(
JSON
.
stringify
(
evt
.
data
)
)
)
;
}
}
}
)
;
}
)
;
document
.
body
.
appendChild
(
frame
)
;
return
promise
;
}
