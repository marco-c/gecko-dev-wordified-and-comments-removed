'
use
strict
'
;
var
kAbsCaptureTime
=
'
http
:
/
/
www
.
webrtc
.
org
/
experiments
/
rtp
-
hdrext
/
abs
-
capture
-
time
'
;
function
addHeaderExtensionToSdp
(
sdp
uri
)
{
const
usedIds
=
sdp
.
split
(
'
\
n
'
)
.
filter
(
line
=
>
line
.
startsWith
(
'
a
=
extmap
:
'
)
)
.
map
(
line
=
>
parseInt
(
line
.
split
(
'
'
)
[
0
]
.
substring
(
9
)
10
)
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
.
filter
(
(
item
index
array
)
=
>
array
.
indexOf
(
item
)
=
=
=
index
)
;
const
nextId
=
usedIds
[
usedIds
.
length
-
1
]
+
1
;
const
extmapLine
=
'
a
=
extmap
:
'
+
nextId
+
'
'
+
uri
+
'
\
r
\
n
'
;
const
sections
=
sdp
.
split
(
'
\
nm
=
'
)
.
map
(
(
part
index
)
=
>
{
return
(
index
>
0
?
'
m
=
'
+
part
:
part
)
.
trim
(
)
+
'
\
r
\
n
'
;
}
)
;
const
sessionPart
=
sections
.
shift
(
)
;
return
sessionPart
+
sections
.
map
(
mediaSection
=
>
mediaSection
+
extmapLine
)
.
join
(
'
'
)
;
}
async
function
addAbsCaptureTimeAndExchangeOffer
(
caller
callee
)
{
let
offer
=
await
caller
.
createOffer
(
)
;
offer
.
sdp
=
addHeaderExtensionToSdp
(
offer
.
sdp
kAbsCaptureTime
)
;
await
caller
.
setLocalDescription
(
offer
)
;
return
callee
.
setRemoteDescription
(
offer
)
;
}
async
function
checkAbsCaptureTimeAndExchangeAnswer
(
caller
callee
absCaptureTimeAnswered
)
{
let
answer
=
await
callee
.
createAnswer
(
)
;
const
extmap
=
new
RegExp
(
'
a
=
extmap
:
\
\
d
+
'
+
kAbsCaptureTime
+
'
\
r
\
n
'
'
g
'
)
;
if
(
answer
.
sdp
.
match
(
extmap
)
=
=
null
)
{
assert_false
(
absCaptureTimeAnswered
'
Absolute
capture
time
RTP
'
+
'
header
extension
is
not
answered
'
)
;
}
else
{
if
(
!
absCaptureTimeAnswered
)
{
answer
.
sdp
=
answer
.
sdp
.
replace
(
extmap
'
'
)
;
}
}
await
callee
.
setLocalDescription
(
answer
)
;
return
caller
.
setRemoteDescription
(
answer
)
;
}
async
function
exchangeOfferAndListenToOntrack
(
t
caller
callee
absCaptureTimeOffered
)
{
const
ontrackPromise
=
addEventListenerPromise
(
t
callee
'
track
'
)
;
await
absCaptureTimeOffered
?
addAbsCaptureTimeAndExchangeOffer
(
caller
callee
)
:
exchangeOffer
(
caller
callee
)
;
return
ontrackPromise
;
}
async
function
initiateCall
(
t
streamOptions
enableAbsCaptureTime
worker
enableSenderTransform
enableReceiverTransform
)
{
const
caller
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
caller
.
close
(
)
)
;
const
callee
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
callee
.
close
(
)
)
;
const
senderTransform
=
enableSenderTransform
?
new
RTCRtpScriptTransform
(
worker
{
name
:
'
sender
'
}
)
:
null
;
const
receiverTransform
=
enableReceiverTransform
?
new
RTCRtpScriptTransform
(
worker
{
name
:
'
receiver
'
}
)
:
null
;
const
stream
=
await
getNoiseStream
(
streamOptions
)
;
stream
.
getTracks
(
)
.
forEach
(
track
=
>
{
const
sender
=
caller
.
addTrack
(
track
stream
)
;
if
(
enableSenderTransform
)
{
sender
.
transform
=
senderTransform
;
}
t
.
add_cleanup
(
(
)
=
>
track
.
stop
(
)
)
;
}
)
;
callee
.
ontrack
=
e
=
>
{
if
(
enableReceiverTransform
)
{
e
.
receiver
.
transform
=
receiverTransform
;
}
}
exchangeIceCandidates
(
caller
callee
)
;
await
exchangeOfferAndListenToOntrack
(
t
caller
callee
enableAbsCaptureTime
)
;
await
checkAbsCaptureTimeAndExchangeAnswer
(
caller
callee
enableAbsCaptureTime
)
;
}
