promise_test
(
async
t
=
>
{
const
fragment
=
new
DocumentFragment
(
)
;
const
iframe1
=
fragment
.
appendChild
(
document
.
createElement
(
'
iframe
'
)
)
;
const
iframe2
=
fragment
.
appendChild
(
document
.
createElement
(
'
iframe
'
)
)
;
t
.
add_cleanup
(
(
)
=
>
{
iframe1
.
remove
(
)
;
iframe2
.
remove
(
)
;
}
)
;
let
iframe1Loaded
=
false
iframe2Loaded
=
false
;
iframe1
.
onload
=
t
.
step_func
(
e
=
>
{
iframe1Loaded
=
true
;
assert_equals
(
window
.
frames
.
length
1
"
iframe1
load
event
can
observe
its
own
participation
in
the
frame
"
+
"
tree
"
)
;
assert_equals
(
iframe1
.
contentWindow
window
.
frames
[
0
]
)
;
assert_false
(
iframe2Loaded
"
iframe2
'
s
load
event
hasn
'
t
fired
before
iframe1
'
s
"
)
;
assert_true
(
iframe2
.
isConnected
"
iframe1
can
observe
that
iframe2
is
connected
to
the
DOM
.
.
.
"
)
;
assert_equals
(
iframe2
.
contentWindow
null
"
.
.
.
but
iframe1
cannot
observe
iframe2
'
s
contentWindow
because
"
+
"
iframe2
'
s
insertion
steps
have
not
been
run
yet
"
)
;
}
)
;
iframe2
.
onload
=
t
.
step_func
(
e
=
>
{
iframe2Loaded
=
true
;
assert_equals
(
window
.
frames
.
length
2
"
iframe2
load
event
can
observe
its
own
participation
in
the
frame
tree
"
)
;
assert_equals
(
iframe1
.
contentWindow
window
.
frames
[
0
]
)
;
assert_equals
(
iframe2
.
contentWindow
window
.
frames
[
1
]
)
;
}
)
;
document
.
body
.
append
(
fragment
)
;
assert_true
(
iframe1Loaded
"
iframe1
loaded
"
)
;
assert_true
(
iframe2Loaded
"
iframe2
loaded
"
)
;
}
"
Insertion
steps
:
load
event
fires
synchronously
*
after
*
iframe
DOM
"
+
"
insertion
as
part
of
the
iframe
element
'
s
insertion
steps
"
)
;
function
runRemovalTest
(
removal_method
)
{
promise_test
(
async
t
=
>
{
const
div
=
document
.
createElement
(
'
div
'
)
;
const
iframe1
=
div
.
appendChild
(
document
.
createElement
(
'
iframe
'
)
)
;
const
iframe2
=
div
.
appendChild
(
document
.
createElement
(
'
iframe
'
)
)
;
document
.
body
.
append
(
div
)
;
let
observerCallbackInvoked
=
false
;
const
removalObserver
=
new
MutationObserver
(
t
.
step_func
(
mutations
=
>
{
assert_false
(
observerCallbackInvoked
"
MO
callback
is
only
invoked
once
not
multiple
times
i
.
e
.
for
"
+
"
each
removal
"
)
;
observerCallbackInvoked
=
true
;
assert_equals
(
mutations
.
length
1
"
Exactly
one
MutationRecord
is
recorded
"
)
;
assert_equals
(
mutations
[
0
]
.
removedNodes
.
length
2
)
;
assert_equals
(
window
.
frames
.
length
0
"
No
iframe
Windows
exist
when
the
MO
callback
is
run
"
)
;
assert_equals
(
document
.
querySelector
(
'
iframe
'
)
null
"
No
iframe
elements
are
connected
to
the
DOM
when
the
MO
callback
is
"
+
"
run
"
)
;
}
)
)
;
removalObserver
.
observe
(
div
{
childList
:
true
}
)
;
t
.
add_cleanup
(
(
)
=
>
removalObserver
.
disconnect
(
)
)
;
let
iframe1UnloadFired
=
false
iframe2UnloadFired
=
false
;
let
iframe1PagehideFired
=
false
iframe2PagehideFired
=
false
;
iframe1
.
contentWindow
.
addEventListener
(
'
pagehide
'
e
=
>
{
assert_false
(
iframe1UnloadFired
"
iframe1
pagehide
fires
before
unload
"
)
;
iframe1PagehideFired
=
true
;
}
)
;
iframe2
.
contentWindow
.
addEventListener
(
'
pagehide
'
e
=
>
{
assert_false
(
iframe2UnloadFired
"
iframe2
pagehide
fires
before
unload
"
)
;
iframe2PagehideFired
=
true
;
}
)
;
iframe1
.
contentWindow
.
addEventListener
(
'
unload
'
e
=
>
iframe1UnloadFired
=
true
)
;
iframe2
.
contentWindow
.
addEventListener
(
'
unload
'
e
=
>
iframe2UnloadFired
=
true
)
;
if
(
removal_method
=
=
=
'
replaceChildren
'
)
{
div
.
replaceChildren
(
)
;
}
else
if
(
removal_method
=
=
=
'
remove
'
)
{
div
.
remove
(
)
;
}
else
if
(
removal_method
=
=
=
'
innerHTML
'
)
{
div
.
innerHTML
=
'
'
;
}
assert_false
(
iframe1PagehideFired
"
iframe1
pagehide
did
not
fire
"
)
;
assert_false
(
iframe2PagehideFired
"
iframe2
pagehide
did
not
fire
"
)
;
assert_false
(
iframe1UnloadFired
"
iframe1
unload
did
not
fire
"
)
;
assert_false
(
iframe2UnloadFired
"
iframe2
unload
did
not
fire
"
)
;
assert_false
(
observerCallbackInvoked
"
MO
callback
is
not
invoked
synchronously
after
removals
"
)
;
await
Promise
.
resolve
(
)
;
if
(
removal_method
!
=
=
'
remove
'
)
{
assert_true
(
observerCallbackInvoked
"
MO
callback
is
invoked
asynchronously
after
removals
"
)
;
}
}
Removing
steps
(
{
removal_method
}
)
:
script
does
not
run
synchronously
during
iframe
destruction
)
;
}
runRemovalTest
(
'
innerHTML
'
)
;
runRemovalTest
(
'
replaceChildren
'
)
;
runRemovalTest
(
'
remove
'
)
;
