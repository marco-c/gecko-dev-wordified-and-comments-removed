setup
(
{
allow_uncaught_exception
:
true
}
)
;
test
(
(
)
=
>
{
assert_equals
(
typeof
Observable
.
from
"
function
"
"
Observable
.
from
(
)
is
a
function
"
)
;
}
"
from
(
)
:
Observable
.
from
(
)
is
a
function
"
)
;
test
(
(
)
=
>
{
assert_throws_js
(
TypeError
(
)
=
>
Observable
.
from
(
10
)
"
Number
cannot
convert
to
an
Observable
"
)
;
assert_throws_js
(
TypeError
(
)
=
>
Observable
.
from
(
true
)
"
Boolean
cannot
convert
to
an
Observable
"
)
;
assert_throws_js
(
TypeError
(
)
=
>
Observable
.
from
(
"
String
"
)
"
String
cannot
convert
to
an
Observable
"
)
;
assert_throws_js
(
TypeError
(
)
=
>
Observable
.
from
(
{
a
:
10
}
)
"
Object
cannot
convert
to
an
Observable
"
)
;
assert_throws_js
(
TypeError
(
)
=
>
Observable
.
from
(
Symbol
.
iterator
)
"
Bare
Symbol
.
iterator
cannot
convert
to
an
Observable
"
)
;
assert_throws_js
(
TypeError
(
)
=
>
Observable
.
from
(
Promise
)
"
Promise
constructor
cannot
convert
to
an
Observable
"
)
;
}
"
from
(
)
:
Failed
conversions
"
)
;
test
(
(
)
=
>
{
const
target
=
new
EventTarget
(
)
;
const
observable
=
target
.
when
(
'
custom
'
)
;
const
from_observable
=
Observable
.
from
(
observable
)
;
assert_equals
(
observable
from_observable
)
;
}
"
from
(
)
:
Given
an
observable
it
returns
that
exact
observable
"
)
;
test
(
(
)
=
>
{
let
completeCalled
=
false
;
const
results
=
[
]
;
const
array
=
[
1
2
3
'
a
'
new
Date
(
)
15
[
12
]
]
;
const
observable
=
Observable
.
from
(
array
)
;
observable
.
subscribe
(
{
next
:
v
=
>
results
.
push
(
v
)
error
:
e
=
>
assert_unreached
(
'
error
is
not
called
'
)
complete
:
(
)
=
>
completeCalled
=
true
}
)
;
assert_array_equals
(
results
array
)
;
assert_true
(
completeCalled
)
;
}
"
from
(
)
:
Given
an
array
"
)
;
test
(
(
)
=
>
{
const
iterable
=
{
[
Symbol
.
iterator
]
(
)
{
let
n
=
0
;
return
{
next
(
)
{
n
+
+
;
if
(
n
<
=
3
)
{
return
{
value
:
n
done
:
false
}
;
}
return
{
value
:
undefined
done
:
true
}
;
}
}
;
}
}
;
const
observable
=
Observable
.
from
(
iterable
)
;
assert_true
(
observable
instanceof
Observable
"
Observable
.
from
(
)
returns
an
Observable
"
)
;
const
results
=
[
]
;
observable
.
subscribe
(
{
next
:
(
value
)
=
>
results
.
push
(
value
)
error
:
(
)
=
>
assert_unreached
(
"
should
not
error
"
)
complete
:
(
)
=
>
results
.
push
(
"
complete
"
)
}
)
;
assert_array_equals
(
results
[
1
2
3
"
complete
"
]
"
Subscription
pushes
iterable
values
out
to
Observable
"
)
;
observable
.
subscribe
(
{
next
:
(
value
)
=
>
results
.
push
(
value
)
error
:
(
)
=
>
assert_unreached
(
"
should
not
error
"
)
complete
:
(
)
=
>
results
.
push
(
"
complete2
"
)
}
)
;
assert_array_equals
(
results
[
1
2
3
"
complete
"
1
2
3
"
complete2
"
]
"
Subscribing
again
causes
another
fresh
iteration
on
an
un
-
exhausted
iterable
"
)
;
}
"
from
(
)
:
Iterable
converts
to
Observable
"
)
;
test
(
(
)
=
>
{
const
results
=
[
]
;
const
iterable
=
{
get
[
Symbol
.
iterator
]
(
)
{
results
.
push
(
"
[
Symbol
.
iterator
]
method
GETTER
"
)
;
return
function
(
)
{
results
.
push
(
"
[
Symbol
.
iterator
implementation
]
"
)
;
return
{
get
next
(
)
{
results
.
push
(
"
next
(
)
method
GETTER
"
)
;
return
function
(
)
{
results
.
push
(
"
next
(
)
implementation
"
)
;
return
{
value
:
undefined
done
:
true
}
;
}
;
}
}
;
}
;
}
}
;
const
observable
=
Observable
.
from
(
iterable
)
;
assert_array_equals
(
results
[
"
[
Symbol
.
iterator
]
method
GETTER
"
]
)
;
let
thrownError
=
null
;
observable
.
subscribe
(
)
;
assert_array_equals
(
results
[
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
implementation
]
"
"
next
(
)
method
GETTER
"
"
next
(
)
implementation
"
]
)
;
}
"
from
(
)
:
[
Symbol
.
iterator
]
side
-
effects
(
one
observable
)
"
)
;
test
(
(
)
=
>
{
let
results
=
[
]
;
const
iterable
=
{
[
Symbol
.
iterator
]
:
10
}
;
let
errorThrown
=
null
;
try
{
Observable
.
from
(
iterable
)
;
}
catch
(
e
)
{
errorThrown
=
e
;
}
assert_true
(
errorThrown
instanceof
TypeError
)
;
assert_equals
(
errorThrown
.
message
"
Failed
to
execute
'
from
'
on
'
Observable
'
:
iterator
must
be
a
"
+
"
callable
.
"
)
;
}
"
from
(
)
:
[
Symbol
.
iterator
]
not
callable
"
)
;
test
(
(
)
=
>
{
let
results
=
[
]
;
const
customError
=
new
Error
(
"
iterator
override
error
"
)
;
const
iterable
=
{
numTimesCalled
:
0
get
[
Symbol
.
iterator
]
(
)
{
this
.
numTimesCalled
+
+
;
results
.
push
(
"
[
Symbol
.
iterator
]
method
GETTER
"
)
;
if
(
this
.
numTimesCalled
=
=
=
1
)
{
return
this
.
validIteratorImplementation
;
}
else
{
return
this
.
errorThrowingIteratorImplementation
;
}
}
validIteratorImplementation
:
function
(
)
{
results
.
push
(
"
[
Symbol
.
iterator
implementation
]
"
)
;
return
{
get
next
(
)
{
results
.
push
(
"
next
(
)
method
GETTER
"
)
;
return
function
(
)
{
results
.
push
(
"
next
(
)
implementation
"
)
;
return
{
value
:
undefined
done
:
true
}
;
}
}
}
;
}
errorThrowingIteratorImplementation
:
function
(
)
{
results
.
push
(
"
Error
-
throwing
[
Symbol
.
iterator
]
implementation
"
)
;
throw
customError
;
}
}
;
const
observable
=
Observable
.
from
(
iterable
)
;
assert_array_equals
(
results
[
"
[
Symbol
.
iterator
]
method
GETTER
"
]
)
;
let
thrownError
=
null
;
observable
.
subscribe
(
{
error
:
e
=
>
thrownError
=
e
}
)
;
assert_equals
(
thrownError
customError
"
Error
thrown
from
next
(
)
is
passed
to
the
error
(
)
handler
"
)
;
assert_array_equals
(
results
[
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
]
method
GETTER
"
"
Error
-
throwing
[
Symbol
.
iterator
]
implementation
"
]
)
;
}
"
from
(
)
:
[
Symbol
.
iterator
]
is
not
cached
"
)
;
test
(
(
)
=
>
{
const
results
=
[
]
;
let
numTimesSymbolIteratorCalled
=
0
;
let
numTimesNextCalled
=
0
;
const
iterable
=
{
get
[
Symbol
.
iterator
]
(
)
{
results
.
push
(
"
[
Symbol
.
iterator
]
method
GETTER
"
)
;
return
this
.
internalIteratorImplementation
;
}
set
[
Symbol
.
iterator
]
(
func
)
{
this
.
internalIteratorImplementation
=
func
;
}
internalIteratorImplementation
:
function
(
)
{
results
.
push
(
"
[
Symbol
.
iterator
]
implementation
"
)
;
return
{
get
next
(
)
{
results
.
push
(
"
next
(
)
method
GETTER
"
)
;
return
function
(
)
{
results
.
push
(
"
next
(
)
implementation
"
)
;
return
{
value
:
undefined
done
:
true
}
;
}
;
}
}
;
}
}
;
const
obs1
=
Observable
.
from
(
iterable
)
;
const
obs2
=
Observable
.
from
(
iterable
)
;
const
obs3
=
Observable
.
from
(
iterable
)
;
const
obs4
=
Observable
.
from
(
obs3
)
;
assert_equals
(
obs3
obs4
)
;
assert_array_equals
(
results
[
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
]
method
GETTER
"
]
)
;
obs1
.
subscribe
(
)
;
assert_array_equals
(
results
[
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
]
implementation
"
"
next
(
)
method
GETTER
"
"
next
(
)
implementation
"
]
)
;
iterable
[
Symbol
.
iterator
]
=
(
)
=
>
{
results
.
push
(
"
Error
-
throwing
[
Symbol
.
iterator
]
implementation
"
)
;
throw
new
Error
(
'
Symbol
.
iterator
override
error
'
)
;
}
;
let
errorCount
=
0
;
const
observer
=
{
error
:
e
=
>
errorCount
+
+
}
;
obs2
.
subscribe
(
observer
)
;
obs3
.
subscribe
(
observer
)
;
obs4
.
subscribe
(
observer
)
;
assert_equals
(
errorCount
3
"
Error
-
throwing
iterator
implementation
is
called
once
per
"
+
"
subscription
"
)
;
assert_array_equals
(
results
[
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
]
method
GETTER
"
"
[
Symbol
.
iterator
]
implementation
"
"
next
(
)
method
GETTER
"
"
next
(
)
implementation
"
"
[
Symbol
.
iterator
]
method
GETTER
"
"
Error
-
throwing
[
Symbol
.
iterator
]
implementation
"
"
[
Symbol
.
iterator
]
method
GETTER
"
"
Error
-
throwing
[
Symbol
.
iterator
]
implementation
"
"
[
Symbol
.
iterator
]
method
GETTER
"
"
Error
-
throwing
[
Symbol
.
iterator
]
implementation
"
]
)
;
}
"
from
(
)
:
[
Symbol
.
iterator
]
side
-
effects
(
many
observables
)
"
)
;
test
(
(
)
=
>
{
const
customError
=
new
Error
(
'
iterator
next
(
)
error
'
)
;
const
iterable
=
{
[
Symbol
.
iterator
]
(
)
{
return
{
next
(
)
{
throw
customError
;
}
}
;
}
}
;
let
thrownError
=
null
;
Observable
.
from
(
iterable
)
.
subscribe
(
{
error
:
e
=
>
thrownError
=
e
}
)
;
assert_equals
(
thrownError
customError
"
Error
thrown
from
next
(
)
is
passed
to
the
error
(
)
handler
"
)
;
}
"
from
(
)
:
[
Symbol
.
iterator
]
next
(
)
throws
error
"
)
;
promise_test
(
async
(
)
=
>
{
const
promise
=
Promise
.
resolve
(
'
value
'
)
;
const
observable
=
Observable
.
from
(
promise
)
;
assert_true
(
observable
instanceof
Observable
"
Converts
to
Observable
"
)
;
const
results
=
[
]
;
observable
.
subscribe
(
{
next
:
(
value
)
=
>
results
.
push
(
value
)
error
:
(
)
=
>
assert_unreached
(
"
error
(
)
is
not
called
"
)
complete
:
(
)
=
>
results
.
push
(
"
complete
(
)
"
)
}
)
;
assert_array_equals
(
results
[
]
"
Observable
does
not
emit
synchronously
"
)
;
await
promise
;
assert_array_equals
(
results
[
"
value
"
"
complete
(
)
"
]
"
Observable
emits
and
completes
after
Promise
resolves
"
)
;
}
"
from
(
)
:
Converts
Promise
to
Observable
"
)
;
promise_test
(
async
t
=
>
{
let
unhandledRejectionHandlerCalled
=
false
;
const
unhandledRejectionHandler
=
(
)
=
>
{
unhandledRejectionHandlerCalled
=
true
;
}
;
self
.
addEventListener
(
"
unhandledrejection
"
unhandledRejectionHandler
)
;
t
.
add_cleanup
(
(
)
=
>
self
.
removeEventListener
(
"
unhandledrejection
"
unhandledRejectionHandler
)
)
;
const
promise
=
Promise
.
reject
(
"
reason
"
)
;
const
observable
=
Observable
.
from
(
promise
)
;
assert_true
(
observable
instanceof
Observable
"
Converts
to
Observable
"
)
;
const
results
=
[
]
;
observable
.
subscribe
(
{
next
:
(
value
)
=
>
assert_unreached
(
"
next
(
)
not
called
"
)
error
:
(
error
)
=
>
results
.
push
(
error
)
complete
:
(
)
=
>
assert_unreached
(
"
complete
(
)
not
called
"
)
}
)
;
assert_array_equals
(
results
[
]
"
Observable
does
not
emit
synchronously
"
)
;
let
catchBlockEntered
=
false
;
try
{
await
promise
;
}
catch
{
catchBlockEntered
=
true
;
}
assert_true
(
catchBlockEntered
"
Catch
block
entered
"
)
;
assert_false
(
unhandledRejectionHandlerCalled
"
No
unhandledrejection
event
"
)
;
assert_array_equals
(
results
[
"
reason
"
]
"
Observable
emits
error
(
)
after
Promise
rejects
"
)
;
}
"
from
(
)
:
Converts
rejected
Promise
to
Observable
.
No
"
+
"
unhandledrejection
event
when
error
is
handled
by
subscription
"
)
;
promise_test
(
async
t
=
>
{
let
unhandledRejectionHandlerCalled
=
false
;
const
unhandledRejectionHandler
=
(
)
=
>
{
unhandledRejectionHandlerCalled
=
true
;
}
;
self
.
addEventListener
(
"
unhandledrejection
"
unhandledRejectionHandler
)
;
t
.
add_cleanup
(
(
)
=
>
self
.
removeEventListener
(
"
unhandledrejection
"
unhandledRejectionHandler
)
)
;
let
errorReported
=
null
;
self
.
addEventListener
(
"
error
"
e
=
>
errorReported
=
e
{
once
:
true
}
)
;
let
catchBlockEntered
=
false
;
try
{
const
promise
=
Promise
.
reject
(
"
custom
reason
"
)
;
const
observable
=
Observable
.
from
(
promise
)
;
observable
.
subscribe
(
)
;
await
promise
;
}
catch
{
catchBlockEntered
=
true
;
}
assert_true
(
catchBlockEntered
"
Catch
block
entered
"
)
;
assert_false
(
unhandledRejectionHandlerCalled
"
No
unhandledrejection
event
because
error
got
reported
to
global
"
)
;
assert_not_equals
(
errorReported
null
"
Error
was
reported
to
the
global
"
)
;
assert_true
(
errorReported
.
message
.
includes
(
"
custom
reason
"
)
"
Error
message
matches
"
)
;
assert_equals
(
errorReported
.
lineno
0
"
Error
lineno
is
0
"
)
;
assert_equals
(
errorReported
.
colno
0
"
Error
lineno
is
0
"
)
;
assert_equals
(
errorReported
.
error
"
custom
reason
"
"
Error
object
is
equivalent
"
)
;
}
"
from
(
)
:
Rejections
not
handled
by
subscription
are
reported
to
the
"
+
"
global
and
still
not
sent
as
an
unhandledrejection
event
"
)
;
test
(
(
)
=
>
{
const
results
=
[
]
;
const
observable
=
new
Observable
(
subscriber
=
>
{
subscriber
.
next
(
'
from
Observable
'
)
;
subscriber
.
complete
(
)
;
}
)
;
observable
[
Symbol
.
iterator
]
=
(
)
=
>
{
results
.
push
(
'
Symbol
.
iterator
(
)
called
'
)
;
return
{
next
(
)
{
return
{
value
:
'
from
iterator
'
done
:
true
}
;
}
}
;
}
;
Observable
.
from
(
observable
)
.
subscribe
(
{
next
:
v
=
>
results
.
push
(
v
)
complete
:
(
)
=
>
results
.
push
(
"
complete
"
)
}
)
;
assert_array_equals
(
results
[
"
from
Observable
"
"
complete
"
]
)
;
}
"
from
(
)
:
Observable
that
implements
iterator
protocol
gets
converted
"
+
"
as
an
Observable
not
iterator
"
)
;
test
(
(
)
=
>
{
const
results
=
[
]
;
const
promise
=
new
Promise
(
resolve
=
>
{
resolve
(
'
from
Promise
'
)
;
}
)
;
promise
[
Symbol
.
iterator
]
=
(
)
=
>
{
let
done
=
false
;
return
{
next
(
)
{
if
(
!
done
)
{
done
=
true
;
return
{
value
:
'
from
iterator
'
done
:
false
}
;
}
else
{
return
{
value
:
undefined
done
:
true
}
;
}
}
}
;
}
;
Observable
.
from
(
promise
)
.
subscribe
(
{
next
:
v
=
>
results
.
push
(
v
)
complete
:
(
)
=
>
results
.
push
(
"
complete
"
)
}
)
;
assert_array_equals
(
results
[
"
from
iterator
"
"
complete
"
]
)
;
}
"
from
(
)
:
Promise
that
implements
iterator
protocol
gets
converted
as
"
+
"
an
iterable
not
Promise
"
)
;
promise_test
(
async
(
)
=
>
{
const
promise
=
new
Promise
(
resolve
=
>
resolve
(
'
from
Promise
'
)
)
;
assert_equals
(
promise
[
Symbol
.
iterator
]
undefined
)
;
promise
[
Symbol
.
iterator
]
=
null
;
assert_equals
(
promise
[
Symbol
.
iterator
]
null
)
;
const
value
=
await
new
Promise
(
resolve
=
>
{
Observable
.
from
(
promise
)
.
subscribe
(
value
=
>
resolve
(
value
)
)
;
}
)
;
assert_equals
(
value
'
from
Promise
'
)
;
}
"
from
(
)
:
Promise
whose
[
Symbol
.
iterator
]
returns
null
converts
as
Promise
"
)
;
test
(
(
)
=
>
{
const
error
=
new
Error
(
'
thrown
from
iterator
getter
'
)
;
const
obj
=
{
get
[
Symbol
.
iterator
]
(
)
{
throw
error
;
}
}
try
{
Observable
.
from
(
obj
)
;
assert_unreached
(
"
from
(
)
conversion
throws
"
)
;
}
catch
(
e
)
{
assert_equals
(
e
error
)
;
}
}
"
from
(
)
:
Rethrows
the
error
when
Converting
an
object
whose
iterator
"
+
"
method
*
getter
*
throws
an
error
"
)
;
test
(
(
)
=
>
{
const
obj
=
{
}
;
obj
[
Symbol
.
iterator
]
=
10
;
try
{
Observable
.
from
(
obj
)
;
assert_unreached
(
"
from
(
)
conversion
throws
"
)
;
}
catch
(
e
)
{
assert_true
(
e
instanceof
TypeError
)
;
assert_equals
(
e
.
message
"
Failed
to
execute
'
from
'
on
'
Observable
'
:
iterator
must
be
a
callable
.
"
)
;
}
}
"
from
(
)
:
Throws
'
callable
'
error
when
iterator
property
is
a
"
+
"
non
-
callable
primitive
"
)
;
test
(
(
)
=
>
{
const
sync_iterable
=
{
[
Symbol
.
asyncIterator
]
:
null
[
Symbol
.
iterator
]
(
)
{
return
{
value
:
0
next
(
)
{
if
(
this
.
value
=
=
=
2
)
return
{
value
:
undefined
done
:
true
}
;
else
return
{
value
:
this
.
value
+
+
done
:
false
}
;
}
}
}
}
;
const
results
=
[
]
;
const
source
=
Observable
.
from
(
sync_iterable
)
.
subscribe
(
v
=
>
results
.
push
(
v
)
)
;
assert_array_equals
(
results
[
0
1
]
)
;
}
"
from
(
)
:
Async
iterable
protocol
null
converts
as
iterator
"
)
;
promise_test
(
async
t
=
>
{
const
results
=
[
]
;
const
async_iterable
=
{
[
Symbol
.
asyncIterator
]
(
)
{
results
.
push
(
"
[
Symbol
.
asyncIterator
]
(
)
invoked
"
)
;
return
{
val
:
0
next
(
)
{
return
new
Promise
(
resolve
=
>
{
t
.
step_timeout
(
(
)
=
>
{
resolve
(
{
value
:
this
.
val
done
:
this
.
val
+
+
=
=
=
4
?
true
:
false
}
)
;
}
400
)
;
}
)
;
}
}
;
}
}
;
const
source
=
Observable
.
from
(
async_iterable
)
;
assert_array_equals
(
results
[
]
)
;
await
new
Promise
(
resolve
=
>
{
source
.
subscribe
(
{
next
:
v
=
>
{
results
.
push
(
Observing
{
v
}
)
;
queueMicrotask
(
(
)
=
>
results
.
push
(
next
(
)
microtask
interleaving
(
v
=
{
v
}
)
)
)
;
}
complete
:
(
)
=
>
{
results
.
push
(
'
complete
(
)
'
)
;
resolve
(
)
;
}
}
)
;
}
)
;
assert_array_equals
(
results
[
"
[
Symbol
.
asyncIterator
]
(
)
invoked
"
"
Observing
0
"
"
next
(
)
microtask
interleaving
(
v
=
0
)
"
"
Observing
1
"
"
next
(
)
microtask
interleaving
(
v
=
1
)
"
"
Observing
2
"
"
next
(
)
microtask
interleaving
(
v
=
2
)
"
"
Observing
3
"
"
next
(
)
microtask
interleaving
(
v
=
3
)
"
"
complete
(
)
"
]
)
;
}
"
from
(
)
:
Asynchronous
iterable
conversion
"
)
;
promise_test
(
async
t
=
>
{
const
async_iterable
=
{
slow
:
true
[
Symbol
.
asyncIterator
]
(
)
{
const
shouldBeSlow
=
this
.
slow
;
this
.
slow
=
false
;
return
{
val
:
0
next
(
)
{
return
new
Promise
(
resolve
=
>
{
t
.
step_timeout
(
(
)
=
>
resolve
(
{
value
:
{
this
.
val
}
-
{
shouldBeSlow
?
'
slow
'
:
'
fast
'
}
done
:
this
.
val
+
+
=
=
=
4
?
true
:
false
}
)
shouldBeSlow
?
200
:
0
)
;
}
)
;
}
}
;
}
}
;
const
results
=
[
]
;
const
source
=
Observable
.
from
(
async_iterable
)
;
const
subscribeFunction
=
function
(
resolve
reject
)
{
source
.
subscribe
(
{
next
:
v
=
>
results
.
push
(
v
)
complete
:
(
)
=
>
resolve
(
)
}
)
;
t
.
step_timeout
(
(
)
=
>
reject
(
'
TIMEOUT
'
)
3000
)
;
}
const
slow_promise
=
new
Promise
(
subscribeFunction
)
;
const
fast_promise
=
new
Promise
(
subscribeFunction
)
;
await
Promise
.
all
(
[
slow_promise
fast_promise
]
)
;
assert_array_equals
(
results
[
'
0
-
fast
'
'
1
-
fast
'
'
2
-
fast
'
'
3
-
fast
'
'
0
-
slow
'
'
1
-
slow
'
'
2
-
slow
'
'
3
-
slow
'
]
)
;
}
"
from
(
)
:
Asynchronous
iterable
multiple
in
-
flight
subscriptions
competing
"
)
;
promise_test
(
async
(
)
=
>
{
const
async_generator
=
async
function
*
(
)
{
yield
1
;
yield
2
;
yield
3
;
}
;
const
results
=
[
]
;
const
source
=
Observable
.
from
(
async_generator
(
)
)
;
const
subscribeFunction
=
function
(
resolve
)
{
source
.
subscribe
(
{
next
:
v
=
>
results
.
push
(
v
)
complete
:
(
)
=
>
resolve
(
)
}
)
;
}
await
new
Promise
(
subscribeFunction
)
;
assert_array_equals
(
results
[
1
2
3
]
)
;
await
new
Promise
(
subscribeFunction
)
;
assert_array_equals
(
results
[
1
2
3
]
)
;
}
"
from
(
)
:
Asynchronous
generator
conversion
:
can
only
be
used
once
"
)
;
promise_test
(
async
(
)
=
>
{
const
results
=
[
]
;
const
async_iterable
=
{
[
Symbol
.
asyncIterator
]
(
)
{
return
{
next
(
)
{
return
{
value
:
undefined
get
done
(
)
{
results
.
push
(
'
done
(
)
GETTER
called
'
)
;
return
true
;
}
}
;
}
}
;
}
}
;
const
source
=
Observable
.
from
(
async_iterable
)
;
assert_array_equals
(
results
[
]
)
;
queueMicrotask
(
(
)
=
>
results
.
push
(
'
Microtask
queued
before
subscription
'
)
)
;
source
.
subscribe
(
)
;
assert_array_equals
(
results
[
]
)
;
await
Promise
.
resolve
(
)
;
assert_array_equals
(
results
[
"
Microtask
queued
before
subscription
"
"
done
(
)
GETTER
called
"
]
)
;
}
"
from
(
)
:
Promise
-
wrapping
semantics
of
IteratorResult
interface
"
)
;
test
(
(
)
=
>
{
const
error
=
new
Error
(
"
[
Symbol
.
asyncIterator
]
error
"
)
;
const
results
=
[
]
;
const
async_iterable
=
{
[
Symbol
.
asyncIterator
]
(
)
{
results
.
push
(
"
[
Symbol
.
asyncIterator
]
(
)
invoked
"
)
;
throw
error
;
}
}
;
Observable
.
from
(
async_iterable
)
.
subscribe
(
{
error
:
e
=
>
results
.
push
(
e
)
}
)
;
assert_array_equals
(
results
[
"
[
Symbol
.
asyncIterator
]
(
)
invoked
"
error
]
)
;
}
"
from
(
)
:
Errors
thrown
in
Symbol
.
asyncIterator
(
)
are
propagated
synchronously
"
)
;
promise_test
(
async
(
)
=
>
{
const
nextError
=
new
Error
(
'
next
error
'
)
;
const
async_iterable
=
{
[
Symbol
.
asyncIterator
]
(
)
{
return
{
get
next
(
)
{
throw
nextError
;
}
}
;
}
}
;
const
results
=
[
]
;
Observable
.
from
(
async_iterable
)
.
subscribe
(
{
error
:
e
=
>
results
.
push
(
e
)
}
)
;
assert_array_equals
(
results
[
]
)
;
await
Promise
.
resolve
(
)
;
assert_array_equals
(
results
[
nextError
]
)
;
}
"
from
(
)
:
Errors
thrown
in
async
iterator
'
s
next
(
)
GETTER
are
propagated
"
+
"
in
a
microtask
"
)
;
promise_test
(
async
(
)
=
>
{
const
nextError
=
new
Error
(
'
next
error
'
)
;
const
async_iterable
=
{
[
Symbol
.
asyncIterator
]
(
)
{
return
{
next
(
)
{
throw
nextError
;
}
}
;
}
}
;
const
results
=
[
]
;
Observable
.
from
(
async_iterable
)
.
subscribe
(
{
error
:
e
=
>
results
.
push
(
e
)
}
)
;
assert_array_equals
(
results
[
]
)
;
await
Promise
.
resolve
(
)
;
assert_array_equals
(
results
[
nextError
]
)
;
}
"
from
(
)
:
Errors
thrown
in
async
iterator
'
s
next
(
)
are
propagated
in
a
microtask
"
)
;
test
(
(
)
=
>
{
const
results
=
[
]
;
const
iterable
=
{
[
Symbol
.
iterator
]
(
)
{
return
{
val
:
0
next
(
)
{
results
.
push
(
IteratorRecord
#
next
(
)
pushing
{
this
.
val
}
)
;
return
{
value
:
this
.
val
done
:
this
.
val
+
+
=
=
=
10
?
true
:
false
}
;
}
return
(
)
{
results
.
push
(
IteratorRecord
#
return
(
)
called
with
this
.
val
=
{
this
.
val
}
)
;
}
}
;
}
}
;
const
ac
=
new
AbortController
(
)
;
Observable
.
from
(
iterable
)
.
subscribe
(
v
=
>
{
results
.
push
(
Observing
{
v
}
)
;
if
(
v
=
=
=
3
)
{
ac
.
abort
(
)
;
}
}
{
signal
:
ac
.
signal
}
)
;
assert_array_equals
(
results
[
"
IteratorRecord
#
next
(
)
pushing
0
"
"
Observing
0
"
"
IteratorRecord
#
next
(
)
pushing
1
"
"
Observing
1
"
"
IteratorRecord
#
next
(
)
pushing
2
"
"
Observing
2
"
"
IteratorRecord
#
next
(
)
pushing
3
"
"
Observing
3
"
"
IteratorRecord
#
return
(
)
called
with
this
.
val
=
4
"
]
)
;
}
"
from
(
)
:
Aborting
sync
iterable
midway
through
iteration
both
stops
iteration
"
+
"
and
invokes
IteratorRecord
#
return
(
)
"
)
;
promise_test
(
async
(
)
=
>
{
const
results
=
[
]
;
const
async_iterable
=
{
asyncIteratorGotten
:
false
get
[
Symbol
.
asyncIterator
]
(
)
{
results
.
push
(
"
[
Symbol
.
asyncIterator
]
GETTER
"
)
;
if
(
this
.
asyncIteratorGotten
)
{
return
null
;
}
this
.
asyncIteratorGotten
=
true
;
return
function
(
)
{
}
;
}
[
Symbol
.
iterator
]
(
)
{
results
.
push
(
'
[
Symbol
.
iterator
]
(
)
invoked
as
fallback
'
)
;
return
{
val
:
0
next
(
)
{
return
{
value
:
this
.
val
done
:
this
.
val
+
+
=
=
=
4
?
true
:
false
}
;
}
}
;
}
}
;
const
source
=
Observable
.
from
(
async_iterable
)
;
assert_array_equals
(
results
[
"
[
Symbol
.
asyncIterator
]
GETTER
"
]
)
;
await
new
Promise
(
(
resolve
reject
)
=
>
{
source
.
subscribe
(
{
next
:
v
=
>
{
results
.
push
(
Observing
{
v
}
)
;
queueMicrotask
(
(
)
=
>
results
.
push
(
next
(
)
microtask
interleaving
(
v
=
{
v
}
)
)
)
;
}
error
:
e
=
>
reject
(
e
)
complete
:
(
)
=
>
{
results
.
push
(
'
complete
(
)
'
)
;
resolve
(
)
;
}
}
)
;
}
)
;
assert_array_equals
(
results
[
"
[
Symbol
.
asyncIterator
]
GETTER
"
"
[
Symbol
.
asyncIterator
]
GETTER
"
"
[
Symbol
.
iterator
]
(
)
invoked
as
fallback
"
"
Observing
0
"
"
next
(
)
microtask
interleaving
(
v
=
0
)
"
"
Observing
1
"
"
next
(
)
microtask
interleaving
(
v
=
1
)
"
"
Observing
2
"
"
next
(
)
microtask
interleaving
(
v
=
2
)
"
"
Observing
3
"
"
next
(
)
microtask
interleaving
(
v
=
3
)
"
"
complete
(
)
"
]
)
;
}
"
from
(
)
:
Asynchronous
iterable
conversion
with
synchronous
iterable
fallback
"
)
;
test
(
(
)
=
>
{
const
results
=
[
]
;
let
generatorFinalized
=
false
;
const
generator
=
function
*
(
)
{
try
{
for
(
let
n
=
0
;
n
<
10
;
n
+
+
)
{
yield
n
;
}
}
finally
{
generatorFinalized
=
true
;
}
}
;
const
observable
=
Observable
.
from
(
generator
(
)
)
;
const
abortController
=
new
AbortController
(
)
;
observable
.
subscribe
(
n
=
>
{
results
.
push
(
n
)
;
if
(
n
=
=
=
3
)
{
abortController
.
abort
(
)
;
}
}
{
signal
:
abortController
.
signal
}
)
;
assert_array_equals
(
results
[
0
1
2
3
]
)
;
assert_true
(
generatorFinalized
)
;
}
"
from
(
)
:
Generator
finally
block
runs
when
subscription
is
aborted
"
)
;
test
(
(
)
=
>
{
const
results
=
[
]
;
let
generatorFinalized
=
false
;
const
generator
=
function
*
(
)
{
try
{
for
(
let
n
=
0
;
n
<
10
;
n
+
+
)
{
yield
n
;
}
}
catch
{
assert_unreached
(
"
generator
should
not
be
aborted
"
)
;
}
finally
{
generatorFinalized
=
true
;
}
}
;
const
observable
=
Observable
.
from
(
generator
(
)
)
;
observable
.
subscribe
(
(
n
)
=
>
{
results
.
push
(
n
)
;
}
)
;
assert_array_equals
(
results
[
0
1
2
3
4
5
6
7
8
9
]
)
;
assert_true
(
generatorFinalized
)
;
}
"
from
(
)
:
Generator
finally
block
run
when
Observable
completes
"
)
;
test
(
(
)
=
>
{
const
results
=
[
]
;
let
generatorFinalized
=
false
;
const
generator
=
function
*
(
)
{
try
{
for
(
let
n
=
0
;
n
<
10
;
n
+
+
)
{
yield
n
;
}
throw
new
Error
(
'
from
the
generator
'
)
;
}
finally
{
generatorFinalized
=
true
;
}
}
;
const
observable
=
Observable
.
from
(
generator
(
)
)
;
observable
.
subscribe
(
{
next
:
n
=
>
results
.
push
(
n
)
error
:
e
=
>
results
.
push
(
e
.
message
)
}
)
;
assert_array_equals
(
results
[
0
1
2
3
4
5
6
7
8
9
"
from
the
generator
"
]
)
;
assert_true
(
generatorFinalized
)
;
}
"
from
(
)
:
Generator
finally
block
run
when
Observable
errors
"
)
;
promise_test
(
async
t
=
>
{
const
results
=
[
]
;
let
generatorFinalized
=
false
;
async
function
*
asyncGenerator
(
)
{
try
{
for
(
let
n
=
0
;
n
<
10
;
n
+
+
)
{
yield
n
;
}
}
finally
{
generatorFinalized
=
true
;
}
}
const
observable
=
Observable
.
from
(
asyncGenerator
(
)
)
;
const
abortController
=
new
AbortController
(
)
;
await
new
Promise
(
(
resolve
)
=
>
{
observable
.
subscribe
(
(
n
)
=
>
{
results
.
push
(
n
)
;
if
(
n
=
=
=
3
)
{
abortController
.
abort
(
)
;
resolve
(
)
;
}
}
{
signal
:
abortController
.
signal
}
)
;
}
)
;
assert_array_equals
(
results
[
0
1
2
3
]
)
;
assert_true
(
generatorFinalized
)
;
}
"
from
(
)
:
Async
generator
finally
block
run
when
subscription
is
aborted
"
)
;
promise_test
(
async
t
=
>
{
const
results
=
[
]
;
let
generatorFinalized
=
false
;
async
function
*
asyncGenerator
(
)
{
try
{
for
(
let
n
=
0
;
n
<
10
;
n
+
+
)
{
yield
n
;
}
}
finally
{
generatorFinalized
=
true
;
}
}
const
observable
=
Observable
.
from
(
asyncGenerator
(
)
)
;
await
new
Promise
(
resolve
=
>
{
observable
.
subscribe
(
{
next
:
n
=
>
results
.
push
(
n
)
complete
:
(
)
=
>
resolve
(
)
}
)
;
}
)
;
assert_array_equals
(
results
[
0
1
2
3
4
5
6
7
8
9
]
)
;
assert_true
(
generatorFinalized
)
;
}
"
from
(
)
:
Async
generator
finally
block
runs
when
Observable
completes
"
)
;
promise_test
(
async
t
=
>
{
const
results
=
[
]
;
let
generatorFinalized
=
false
;
async
function
*
asyncGenerator
(
)
{
try
{
for
(
let
n
=
0
;
n
<
10
;
n
+
+
)
{
if
(
n
=
=
=
4
)
{
throw
new
Error
(
'
from
the
async
generator
'
)
;
}
yield
n
;
}
}
finally
{
generatorFinalized
=
true
;
}
}
const
observable
=
Observable
.
from
(
asyncGenerator
(
)
)
;
await
new
Promise
(
(
resolve
)
=
>
{
observable
.
subscribe
(
{
next
:
(
n
)
=
>
results
.
push
(
n
)
error
:
(
e
)
=
>
{
results
.
push
(
e
.
message
)
;
resolve
(
)
;
}
}
)
;
}
)
;
assert_array_equals
(
results
[
0
1
2
3
"
from
the
async
generator
"
]
)
;
assert_true
(
generatorFinalized
)
;
}
"
from
(
)
:
Async
generator
finally
block
run
when
Observable
errors
"
)
;
