'
use
strict
'
function
runAnimationEventTests
(
eventDetails
)
{
const
{
isTransition
unprefixedType
prefixedType
animationCssStyle
}
=
eventDetails
;
const
unprefixedHandler
=
on
{
unprefixedType
}
;
const
prefixedHandler
=
on
{
prefixedType
.
toLowerCase
(
)
}
;
const
style
=
document
.
createElement
(
'
style
'
)
;
document
.
head
.
appendChild
(
style
)
;
if
(
isTransition
)
{
style
.
sheet
.
insertRule
(
.
baseStyle
{
width
:
100px
;
transition
:
width
{
animationCssStyle
}
;
}
)
;
style
.
sheet
.
insertRule
(
'
.
transition
{
width
:
200px
!
important
;
}
'
)
;
}
else
{
style
.
sheet
.
insertRule
(
'
keyframes
anim
{
}
'
)
;
}
function
triggerAnimation
(
div
)
{
if
(
isTransition
)
{
div
.
classList
.
add
(
'
transition
'
)
;
}
else
{
div
.
style
.
animation
=
anim
{
animationCssStyle
}
;
}
}
test
(
t
=
>
{
const
div
=
createDiv
(
t
)
;
assert_equals
(
div
[
unprefixedHandler
]
null
{
unprefixedHandler
}
should
initially
be
null
)
;
assert_equals
(
div
[
prefixedHandler
]
null
{
prefixedHandler
}
should
initially
be
null
)
;
div
[
unprefixedHandler
]
=
(
)
=
>
{
}
;
assert_not_equals
(
div
[
unprefixedHandler
]
null
setting
{
unprefixedHandler
}
should
make
it
non
-
null
)
;
assert_equals
(
div
[
prefixedHandler
]
null
setting
{
unprefixedHandler
}
should
not
affect
{
prefixedHandler
}
)
;
div
[
prefixedHandler
]
=
(
)
=
>
{
}
;
assert_not_equals
(
div
[
prefixedHandler
]
null
setting
{
prefixedHandler
}
should
make
it
non
-
null
)
;
assert_not_equals
(
div
[
unprefixedHandler
]
div
[
prefixedHandler
]
'
the
setters
should
be
different
'
)
;
}
{
unprefixedHandler
}
and
{
prefixedHandler
}
are
not
aliases
)
;
promise_test
(
async
t
=
>
{
const
div
=
createDiv
(
t
)
;
let
receivedEventCount
=
0
;
addTestScopedEventHandler
(
t
div
prefixedHandler
(
)
=
>
{
receivedEventCount
+
+
;
}
)
;
addTestScopedEventListener
(
t
div
prefixedType
(
)
=
>
{
receivedEventCount
+
+
;
}
)
;
div
.
dispatchEvent
(
new
AnimationEvent
(
prefixedType
)
)
;
assert_equals
(
receivedEventCount
2
'
prefixed
listener
and
handler
received
event
'
)
;
}
dispatchEvent
of
a
{
prefixedType
}
event
does
trigger
a
+
prefixed
event
handler
or
listener
)
;
promise_test
(
async
t
=
>
{
const
div
=
createDiv
(
t
)
;
let
receivedEvent
=
false
;
addTestScopedEventHandler
(
t
div
unprefixedHandler
(
)
=
>
{
receivedEvent
=
true
;
}
)
;
addTestScopedEventListener
(
t
div
unprefixedType
(
)
=
>
{
receivedEvent
=
true
;
}
)
;
div
.
dispatchEvent
(
new
AnimationEvent
(
prefixedType
)
)
;
assert_false
(
receivedEvent
'
prefixed
listener
or
handler
received
event
'
)
;
}
dispatchEvent
of
a
{
prefixedType
}
event
does
not
trigger
an
+
unprefixed
event
handler
or
listener
)
;
promise_test
(
async
t
=
>
{
const
div
=
createDiv
(
t
)
;
let
receivedEvent
=
false
;
addTestScopedEventHandler
(
t
div
prefixedHandler
(
)
=
>
{
receivedEvent
=
true
;
}
)
;
addTestScopedEventListener
(
t
div
prefixedType
(
)
=
>
{
receivedEvent
=
true
;
}
)
;
div
.
dispatchEvent
(
new
AnimationEvent
(
unprefixedType
)
)
;
assert_false
(
receivedEvent
'
prefixed
listener
or
handler
received
event
'
)
;
}
dispatchEvent
of
an
{
unprefixedType
}
event
does
not
trigger
a
+
prefixed
event
handler
or
listener
)
;
promise_test
(
async
t
=
>
{
const
div
=
createDiv
(
t
)
;
let
receivedEvent
=
false
;
addTestScopedEventHandler
(
t
div
prefixedHandler
(
)
=
>
{
receivedEvent
=
true
;
}
)
;
triggerAnimation
(
div
)
;
await
waitForEventThenAnimationFrame
(
t
unprefixedType
)
;
assert_true
(
receivedEvent
received
{
prefixedHandler
}
event
)
;
}
{
prefixedHandler
}
event
handler
should
trigger
for
an
animation
)
;
promise_test
(
async
t
=
>
{
const
div
=
createDiv
(
t
)
;
let
receivedPrefixedEvent
=
false
;
addTestScopedEventHandler
(
t
div
prefixedHandler
(
)
=
>
{
receivedPrefixedEvent
=
true
;
}
)
;
let
receivedUnprefixedEvent
=
false
;
addTestScopedEventHandler
(
t
div
unprefixedHandler
(
)
=
>
{
receivedUnprefixedEvent
=
true
;
}
)
;
triggerAnimation
(
div
)
;
await
waitForEventThenAnimationFrame
(
t
unprefixedType
)
;
assert_true
(
receivedUnprefixedEvent
received
{
unprefixedHandler
}
event
)
;
assert_false
(
receivedPrefixedEvent
received
{
prefixedHandler
}
event
)
;
}
{
prefixedHandler
}
event
handler
should
not
trigger
if
an
unprefixed
+
event
handler
also
exists
)
;
promise_test
(
async
t
=
>
{
const
div
=
createDiv
(
t
)
;
let
receivedPrefixedEvent
=
false
;
addTestScopedEventHandler
(
t
div
prefixedHandler
(
)
=
>
{
receivedPrefixedEvent
=
true
;
}
)
;
let
receivedUnprefixedEvent
=
false
;
addTestScopedEventListener
(
t
div
unprefixedType
(
)
=
>
{
receivedUnprefixedEvent
=
true
;
}
)
;
triggerAnimation
(
div
)
;
await
waitForEventThenAnimationFrame
(
t
unprefixedHandler
)
;
assert_true
(
receivedUnprefixedEvent
received
{
unprefixedHandler
}
event
)
;
assert_false
(
receivedPrefixedEvent
received
{
prefixedHandler
}
event
)
;
}
{
prefixedHandler
}
event
handler
should
not
trigger
if
an
unprefixed
+
listener
also
exists
)
;
promise_test
(
async
t
=
>
{
const
parent
=
createDiv
(
t
)
;
const
child
=
createDiv
(
t
)
;
parent
.
appendChild
(
child
)
;
getComputedStyle
(
child
)
.
transition
;
getComputedStyle
(
child
)
.
width
;
let
observedUnprefixedType
;
addTestScopedEventHandler
(
t
parent
unprefixedHandler
e
=
>
{
observedUnprefixedType
=
e
.
type
;
}
)
;
let
observedPrefixedType
;
addTestScopedEventHandler
(
t
child
prefixedHandler
e
=
>
{
observedPrefixedType
=
e
.
type
;
}
)
;
triggerAnimation
(
child
)
;
await
waitForEventThenAnimationFrame
(
t
unprefixedType
)
;
assert_equals
(
observedUnprefixedType
unprefixedType
)
;
assert_equals
(
observedPrefixedType
prefixedType
)
;
}
event
types
for
prefixed
and
unprefixed
{
unprefixedType
}
event
+
handlers
should
be
named
appropriately
)
;
promise_test
(
async
t
=
>
{
const
div
=
createDiv
(
t
)
;
let
receivedEvent
=
false
;
addTestScopedEventListener
(
t
div
prefixedType
(
)
=
>
{
receivedEvent
=
true
;
}
)
;
triggerAnimation
(
div
)
;
await
waitForEventThenAnimationFrame
(
t
unprefixedHandler
)
;
assert_true
(
receivedEvent
received
{
prefixedType
}
event
)
;
}
{
prefixedType
}
event
listener
should
trigger
for
an
animation
)
;
promise_test
(
async
t
=
>
{
const
div
=
createDiv
(
t
)
;
let
receivedPrefixedEvent
=
false
;
addTestScopedEventListener
(
t
div
prefixedType
(
)
=
>
{
receivedPrefixedEvent
=
true
;
}
)
;
let
receivedUnprefixedEvent
=
false
;
addTestScopedEventListener
(
t
div
unprefixedType
(
)
=
>
{
receivedUnprefixedEvent
=
true
;
}
)
;
triggerAnimation
(
div
)
;
await
waitForEventThenAnimationFrame
(
t
unprefixedHandler
)
;
assert_true
(
receivedUnprefixedEvent
received
{
unprefixedType
}
event
)
;
assert_false
(
receivedPrefixedEvent
received
{
prefixedType
}
event
)
;
}
{
prefixedType
}
event
listener
should
not
trigger
if
an
unprefixed
+
listener
also
exists
)
;
promise_test
(
async
t
=
>
{
const
div
=
createDiv
(
t
)
;
let
receivedPrefixedEvent
=
false
;
addTestScopedEventListener
(
t
div
prefixedType
(
)
=
>
{
receivedPrefixedEvent
=
true
;
}
)
;
let
receivedUnprefixedEvent
=
false
;
addTestScopedEventHandler
(
t
div
unprefixedHandler
(
)
=
>
{
receivedUnprefixedEvent
=
true
;
}
)
;
triggerAnimation
(
div
)
;
await
waitForEventThenAnimationFrame
(
t
unprefixedHandler
)
;
assert_true
(
receivedUnprefixedEvent
received
{
unprefixedType
}
event
)
;
assert_false
(
receivedPrefixedEvent
received
{
prefixedType
}
event
)
;
}
{
prefixedType
}
event
listener
should
not
trigger
if
an
unprefixed
+
event
handler
also
exists
)
;
promise_test
(
async
t
=
>
{
const
parent
=
createDiv
(
t
)
;
const
child
=
createDiv
(
t
)
;
parent
.
appendChild
(
child
)
;
getComputedStyle
(
child
)
.
transition
;
getComputedStyle
(
child
)
.
width
;
let
observedUnprefixedType
;
addTestScopedEventListener
(
t
parent
unprefixedType
e
=
>
{
observedUnprefixedType
=
e
.
type
;
}
)
;
let
observedPrefixedType
;
addTestScopedEventListener
(
t
child
prefixedType
e
=
>
{
observedPrefixedType
=
e
.
type
;
}
)
;
triggerAnimation
(
child
)
;
await
waitForEventThenAnimationFrame
(
t
unprefixedHandler
)
;
assert_equals
(
observedUnprefixedType
unprefixedType
)
;
assert_equals
(
observedPrefixedType
prefixedType
)
;
}
event
types
for
prefixed
and
unprefixed
{
unprefixedType
}
event
+
listeners
should
be
named
appropriately
)
;
promise_test
(
async
t
=
>
{
const
div
=
createDiv
(
t
)
;
let
receivedEvent
=
false
;
addTestScopedEventListener
(
t
div
prefixedType
.
toLowerCase
(
)
(
)
=
>
{
receivedEvent
=
true
;
}
)
;
addTestScopedEventListener
(
t
div
prefixedType
.
toUpperCase
(
)
(
)
=
>
{
receivedEvent
=
true
;
}
)
;
triggerAnimation
(
div
)
;
await
waitForEventThenAnimationFrame
(
t
unprefixedHandler
)
;
assert_false
(
receivedEvent
received
{
prefixedType
}
event
)
;
}
{
prefixedType
}
event
listener
is
case
sensitive
)
;
}
function
createDiv
(
test
)
{
const
element
=
document
.
createElement
(
'
div
'
)
;
element
.
classList
.
add
(
'
baseStyle
'
)
;
document
.
body
.
appendChild
(
element
)
;
test
.
add_cleanup
(
(
)
=
>
{
element
.
remove
(
)
;
}
)
;
getComputedStyle
(
element
)
.
transition
;
getComputedStyle
(
element
)
.
width
;
return
element
;
}
function
addTestScopedEventHandler
(
test
target
handlerName
callback
)
{
assert_regexp_match
(
handlerName
/
^
on
/
'
Event
handler
names
must
start
with
"
on
"
'
)
;
assert_equals
(
target
[
handlerName
]
null
{
handlerName
}
must
be
supported
and
not
previously
set
)
;
target
[
handlerName
]
=
callback
;
test
.
add_cleanup
(
(
)
=
>
{
if
(
target
[
handlerName
]
)
target
[
handlerName
]
=
null
;
}
)
;
}
function
addTestScopedEventListener
(
test
target
type
callback
)
{
target
.
addEventListener
(
type
callback
)
;
test
.
add_cleanup
(
(
)
=
>
{
target
.
removeEventListener
(
type
callback
)
;
}
)
;
}
function
waitForEventThenAnimationFrame
(
test
eventName
)
{
return
new
Promise
(
(
resolve
_
)
=
>
{
const
eventFunc
=
eventName
.
startsWith
(
'
on
'
)
?
addTestScopedEventHandler
:
addTestScopedEventListener
;
eventFunc
(
test
window
eventName
(
)
=
>
{
requestAnimationFrame
(
resolve
)
;
}
)
;
}
)
;
}
