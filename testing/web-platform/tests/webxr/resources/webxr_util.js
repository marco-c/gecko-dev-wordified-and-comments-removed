function
xr_promise_test
(
name
func
properties
)
{
promise_test
(
async
(
t
)
=
>
{
if
(
window
.
XRTest
=
=
=
undefined
)
{
await
loadChromiumResources
;
}
return
func
(
t
)
;
}
name
properties
)
;
}
function
xr_session_promise_test
(
name
func
fakeDeviceInit
sessionMode
sessionInit
properties
)
{
let
testDeviceController
;
let
testSession
;
let
sessionObjects
=
{
}
;
const
webglCanvas
=
document
.
getElementsByTagName
(
'
canvas
'
)
[
0
]
;
if
(
!
webglCanvas
)
{
promise_test
(
async
(
t
)
=
>
{
Promise
.
reject
(
'
xr_session_promise_test
requires
a
canvas
on
the
page
!
'
)
;
}
name
properties
)
;
}
let
gl
=
webglCanvas
.
getContext
(
'
webgl
'
{
alpha
:
false
antialias
:
false
}
)
;
sessionObjects
.
gl
=
gl
;
xr_promise_test
(
name
(
t
)
=
>
{
t
.
add_cleanup
(
async
(
)
=
>
{
if
(
testSession
)
{
await
testSession
.
end
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
await
navigator
.
xr
.
test
.
disconnectAllDevices
(
)
;
}
)
;
return
navigator
.
xr
.
test
.
simulateDeviceConnection
(
fakeDeviceInit
)
.
then
(
(
controller
)
=
>
{
testDeviceController
=
controller
;
return
gl
.
makeXRCompatible
(
)
;
}
)
.
then
(
(
)
=
>
new
Promise
(
(
resolve
reject
)
=
>
{
navigator
.
xr
.
test
.
simulateUserActivation
(
(
)
=
>
{
navigator
.
xr
.
requestSession
(
sessionMode
sessionInit
|
|
{
}
)
.
then
(
(
session
)
=
>
{
testSession
=
session
;
session
.
mode
=
sessionMode
;
let
glLayer
=
new
XRWebGLLayer
(
session
gl
{
compositionDisabled
:
session
.
mode
=
=
'
inline
'
}
)
;
glLayer
.
context
=
gl
;
session
.
updateRenderState
(
{
baseLayer
:
glLayer
}
)
;
sessionObjects
.
glLayer
=
glLayer
;
resolve
(
func
(
session
testDeviceController
t
sessionObjects
)
)
;
}
)
.
catch
(
(
err
)
=
>
{
reject
(
'
Session
with
params
'
+
JSON
.
stringify
(
sessionMode
)
+
'
was
rejected
on
device
'
+
JSON
.
stringify
(
fakeDeviceInit
)
+
'
with
error
:
'
+
err
)
;
}
)
;
}
)
;
}
)
)
;
}
properties
)
;
}
function
forEachWebxrObject
(
callback
)
{
callback
(
window
.
navigator
.
xr
'
navigator
.
xr
'
)
;
callback
(
window
.
XRSession
'
XRSession
'
)
;
callback
(
window
.
XRSessionCreationOptions
'
XRSessionCreationOptions
'
)
;
callback
(
window
.
XRFrameRequestCallback
'
XRFrameRequestCallback
'
)
;
callback
(
window
.
XRPresentationContext
'
XRPresentationContext
'
)
;
callback
(
window
.
XRFrame
'
XRFrame
'
)
;
callback
(
window
.
XRView
'
XRView
'
)
;
callback
(
window
.
XRViewport
'
XRViewport
'
)
;
callback
(
window
.
XRViewerPose
'
XRViewerPose
'
)
;
callback
(
window
.
XRWebGLLayer
'
XRWebGLLayer
'
)
;
callback
(
window
.
XRWebGLLayerInit
'
XRWebGLLayerInit
'
)
;
callback
(
window
.
XRCoordinateSystem
'
XRCoordinateSystem
'
)
;
callback
(
window
.
XRFrameOfReference
'
XRFrameOfReference
'
)
;
callback
(
window
.
XRStageBounds
'
XRStageBounds
'
)
;
callback
(
window
.
XRSessionEvent
'
XRSessionEvent
'
)
;
callback
(
window
.
XRCoordinateSystemEvent
'
XRCoordinateSystemEvent
'
)
;
}
let
loadChromiumResources
=
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
if
(
!
(
'
MojoInterfaceInterceptor
'
in
self
)
)
{
return
;
}
let
chromiumResources
=
[
'
/
gen
/
layout_test_data
/
mojo
/
public
/
js
/
mojo_bindings
.
js
'
'
/
gen
/
mojo
/
public
/
mojom
/
base
/
time
.
mojom
.
js
'
'
/
gen
/
gpu
/
ipc
/
common
/
mailbox_holder
.
mojom
.
js
'
'
/
gen
/
gpu
/
ipc
/
common
/
sync_token
.
mojom
.
js
'
'
/
gen
/
ui
/
display
/
mojom
/
display
.
mojom
.
js
'
'
/
gen
/
ui
/
gfx
/
geometry
/
mojom
/
geometry
.
mojom
.
js
'
'
/
gen
/
ui
/
gfx
/
mojom
/
gpu_fence_handle
.
mojom
.
js
'
'
/
gen
/
ui
/
gfx
/
mojom
/
transform
.
mojom
.
js
'
'
/
gen
/
device
/
vr
/
public
/
mojom
/
vr_service
.
mojom
.
js
'
'
/
resources
/
chromium
/
webxr
-
test
.
js
'
'
/
resources
/
testdriver
.
js
'
'
/
resources
/
testdriver
-
vendor
.
js
'
]
;
if
(
typeof
(
additionalChromiumResources
)
!
=
=
'
undefined
'
)
{
chromiumResources
=
chromiumResources
.
concat
(
additionalChromiumResources
)
;
}
let
chain
=
Promise
.
resolve
(
)
;
chromiumResources
.
forEach
(
path
=
>
{
let
script
=
document
.
createElement
(
'
script
'
)
;
script
.
src
=
path
;
script
.
async
=
false
;
chain
=
chain
.
then
(
(
)
=
>
new
Promise
(
resolve
=
>
{
script
.
onload
=
(
)
=
>
resolve
(
)
;
}
)
)
;
document
.
head
.
appendChild
(
script
)
;
}
)
;
return
chain
;
}
)
;
