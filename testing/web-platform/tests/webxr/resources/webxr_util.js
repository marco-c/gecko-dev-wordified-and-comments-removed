'
use
strict
'
;
var
xr_debug
=
function
(
name
msg
)
{
}
;
function
xr_promise_test
(
name
func
properties
)
{
promise_test
(
async
(
t
)
=
>
{
xr_debug
(
name
'
setup
'
)
;
if
(
!
navigator
.
xr
.
test
)
{
const
script
=
document
.
createElement
(
'
script
'
)
;
script
.
src
=
'
/
resources
/
test
-
only
-
api
.
js
'
;
script
.
async
=
false
;
const
p
=
new
Promise
(
(
resolve
reject
)
=
>
{
script
.
onload
=
(
)
=
>
{
resolve
(
)
;
}
;
script
.
onerror
=
e
=
>
{
reject
(
e
)
;
}
;
}
)
document
.
head
.
appendChild
(
script
)
;
await
p
;
if
(
isChromiumBased
)
{
await
loadChromiumResources
(
)
;
}
else
if
(
isWebKitBased
)
{
await
setupWebKitWebXRTestAPI
(
)
;
}
else
{
assert_implements
(
false
"
missing
navigator
.
xr
.
test
"
)
;
}
}
if
(
!
navigator
.
xr
.
test
)
{
return
Promise
.
reject
(
"
No
navigator
.
xr
.
test
object
found
even
after
attempted
load
"
)
;
}
t
.
add_cleanup
(
async
(
)
=
>
{
xr_debug
(
name
'
cleanup
'
)
;
await
navigator
.
xr
.
test
.
disconnectAllDevices
(
)
;
}
)
;
xr_debug
(
name
'
main
'
)
;
return
func
(
t
)
;
}
name
properties
)
;
}
function
requestSkipAnimationFrame
(
session
callback
)
{
session
.
requestAnimationFrame
(
(
)
=
>
{
session
.
requestAnimationFrame
(
callback
)
;
}
)
;
}
function
xr_session_promise_test
(
name
func
fakeDeviceInit
sessionMode
sessionInit
properties
glcontextPropertiesParam
gllayerPropertiesParam
)
{
let
testDeviceController
;
let
testSession
;
let
sessionObjects
=
{
}
;
const
glcontextProperties
=
(
glcontextPropertiesParam
)
?
glcontextPropertiesParam
:
{
}
;
const
gllayerProperties
=
(
gllayerPropertiesParam
)
?
gllayerPropertiesParam
:
{
}
;
const
webglCanvas
=
document
.
getElementsByTagName
(
'
canvas
'
)
[
0
]
;
if
(
!
webglCanvas
)
{
promise_test
(
async
(
t
)
=
>
{
Promise
.
reject
(
'
xr_session_promise_test
requires
a
canvas
on
the
page
!
'
)
;
}
name
properties
)
;
}
let
gl
=
webglCanvas
.
getContext
(
'
webgl
'
{
alpha
:
false
antialias
:
false
.
.
.
glcontextProperties
}
)
;
sessionObjects
.
gl
=
gl
;
xr_promise_test
(
name
(
t
)
=
>
{
t
.
add_cleanup
(
async
(
)
=
>
{
if
(
testSession
)
{
await
testSession
.
end
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
}
)
;
return
navigator
.
xr
.
test
.
simulateDeviceConnection
(
fakeDeviceInit
)
.
then
(
(
controller
)
=
>
{
testDeviceController
=
controller
;
return
gl
.
makeXRCompatible
(
)
;
}
)
.
then
(
(
)
=
>
new
Promise
(
(
resolve
reject
)
=
>
{
xr_debug
(
name
'
simulateUserActivation
'
)
;
navigator
.
xr
.
test
.
simulateUserActivation
(
(
)
=
>
{
xr_debug
(
name
'
document
.
hasFocus
(
)
=
'
+
document
.
hasFocus
(
)
)
;
navigator
.
xr
.
requestSession
(
sessionMode
sessionInit
|
|
{
}
)
.
then
(
(
session
)
=
>
{
xr_debug
(
name
'
session
start
'
)
;
testSession
=
session
;
session
.
mode
=
sessionMode
;
let
glLayer
=
new
XRWebGLLayer
(
session
gl
gllayerProperties
)
;
glLayer
.
context
=
gl
;
session
.
updateRenderState
(
{
baseLayer
:
glLayer
}
)
;
sessionObjects
.
glLayer
=
glLayer
;
xr_debug
(
name
'
session
.
visibilityState
=
'
+
session
.
visibilityState
)
;
resolve
(
func
(
session
testDeviceController
t
sessionObjects
)
)
;
}
)
.
catch
(
(
err
)
=
>
{
xr_debug
(
name
'
error
:
'
+
err
)
;
reject
(
'
Session
with
params
'
+
JSON
.
stringify
(
sessionMode
)
+
'
was
rejected
on
device
'
+
JSON
.
stringify
(
fakeDeviceInit
)
+
'
with
error
:
'
+
err
)
;
}
)
;
}
)
;
}
)
)
;
}
properties
)
;
}
function
promise_simulate_user_activation
(
func
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
navigator
.
xr
.
test
.
simulateUserActivation
(
(
)
=
>
{
try
{
let
a
=
func
(
)
;
resolve
(
a
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
;
}
)
;
}
function
forEachWebxrObject
(
callback
)
{
callback
(
window
.
navigator
.
xr
'
navigator
.
xr
'
)
;
callback
(
window
.
XRSession
'
XRSession
'
)
;
callback
(
window
.
XRSessionCreationOptions
'
XRSessionCreationOptions
'
)
;
callback
(
window
.
XRFrameRequestCallback
'
XRFrameRequestCallback
'
)
;
callback
(
window
.
XRPresentationContext
'
XRPresentationContext
'
)
;
callback
(
window
.
XRFrame
'
XRFrame
'
)
;
callback
(
window
.
XRLayer
'
XRLayer
'
)
;
callback
(
window
.
XRView
'
XRView
'
)
;
callback
(
window
.
XRViewport
'
XRViewport
'
)
;
callback
(
window
.
XRViewerPose
'
XRViewerPose
'
)
;
callback
(
window
.
XRWebGLLayer
'
XRWebGLLayer
'
)
;
callback
(
window
.
XRWebGLLayerInit
'
XRWebGLLayerInit
'
)
;
callback
(
window
.
XRCoordinateSystem
'
XRCoordinateSystem
'
)
;
callback
(
window
.
XRFrameOfReference
'
XRFrameOfReference
'
)
;
callback
(
window
.
XRStageBounds
'
XRStageBounds
'
)
;
callback
(
window
.
XRSessionEvent
'
XRSessionEvent
'
)
;
callback
(
window
.
XRCoordinateSystemEvent
'
XRCoordinateSystemEvent
'
)
;
}
async
function
loadChromiumResources
(
)
{
const
chromiumResources
=
[
'
/
gen
/
mojo
/
public
/
mojom
/
base
/
time
.
mojom
.
js
'
'
/
gen
/
mojo
/
public
/
mojom
/
base
/
shared_memory
.
mojom
.
js
'
'
/
gen
/
mojo
/
public
/
mojom
/
base
/
unguessable_token
.
mojom
.
js
'
'
/
gen
/
gpu
/
ipc
/
common
/
sync_token
.
mojom
.
js
'
'
/
gen
/
gpu
/
ipc
/
common
/
mailbox
.
mojom
.
js
'
'
/
gen
/
gpu
/
ipc
/
common
/
mailbox_holder
.
mojom
.
js
'
'
/
gen
/
ui
/
gfx
/
geometry
/
mojom
/
geometry
.
mojom
.
js
'
'
/
gen
/
ui
/
gfx
/
mojom
/
native_handle_types
.
mojom
.
js
'
'
/
gen
/
ui
/
gfx
/
mojom
/
buffer_types
.
mojom
.
js
'
'
/
gen
/
ui
/
gfx
/
mojom
/
color_space
.
mojom
.
js
'
'
/
gen
/
ui
/
gfx
/
mojom
/
display_color_spaces
.
mojom
.
js
'
'
/
gen
/
ui
/
gfx
/
mojom
/
gpu_fence_handle
.
mojom
.
js
'
'
/
gen
/
ui
/
gfx
/
mojom
/
transform
.
mojom
.
js
'
'
/
gen
/
ui
/
display
/
mojom
/
display
.
mojom
.
js
'
'
/
gen
/
device
/
gamepad
/
public
/
mojom
/
gamepad
.
mojom
.
js
'
'
/
gen
/
device
/
vr
/
public
/
mojom
/
vr_service
.
mojom
.
js
'
]
;
let
extraResources
=
[
'
/
resources
/
chromium
/
webxr
-
test
-
math
-
helper
.
js
'
'
/
resources
/
chromium
/
webxr
-
test
.
js
'
'
/
resources
/
testdriver
.
js
'
'
/
resources
/
testdriver
-
vendor
.
js
'
]
;
if
(
typeof
(
additionalChromiumResources
)
!
=
=
'
undefined
'
)
{
extraResources
=
extraResources
.
concat
(
additionalChromiumResources
)
;
}
await
loadMojoResources
(
chromiumResources
)
;
for
(
const
path
of
extraResources
)
{
await
loadScript
(
path
)
;
}
xr_debug
=
navigator
.
xr
.
test
.
Debug
;
}
function
setupWebKitWebXRTestAPI
(
)
{
navigator
.
xr
.
test
=
internals
.
xrTest
;
return
Promise
.
resolve
(
)
;
}
