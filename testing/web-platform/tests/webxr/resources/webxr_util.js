'
use
strict
'
;
var
xr_debug
=
function
(
name
msg
)
{
}
;
function
xr_promise_test
(
name
func
properties
glContextType
glContextProperties
)
{
promise_test
(
async
(
t
)
=
>
{
if
(
glContextType
=
=
=
'
webgl2
'
)
{
assert_implements
(
'
WebGL2RenderingContext
'
in
window
'
webgl2
not
supported
.
'
)
;
}
xr_debug
(
name
'
setup
'
)
;
assert_implements
(
navigator
.
xr
'
missing
navigator
.
xr
-
ensure
test
is
run
in
a
secure
context
.
'
)
;
if
(
!
navigator
.
xr
.
test
)
{
const
script
=
document
.
createElement
(
'
script
'
)
;
script
.
src
=
'
/
resources
/
test
-
only
-
api
.
js
'
;
script
.
async
=
false
;
const
p
=
new
Promise
(
(
resolve
reject
)
=
>
{
script
.
onload
=
(
)
=
>
{
resolve
(
)
;
}
;
script
.
onerror
=
e
=
>
{
reject
(
e
)
;
}
;
}
)
document
.
head
.
appendChild
(
script
)
;
await
p
;
if
(
isChromiumBased
)
{
await
loadChromiumResources
(
)
;
}
else
if
(
isWebKitBased
)
{
await
setupWebKitWebXRTestAPI
(
)
;
}
}
assert_implements
(
navigator
.
xr
.
test
'
missing
navigator
.
xr
.
test
even
after
attempted
load
'
)
;
let
gl
=
null
;
let
canvas
=
null
;
if
(
glContextType
)
{
canvas
=
document
.
createElement
(
'
canvas
'
)
;
document
.
body
.
appendChild
(
canvas
)
;
gl
=
canvas
.
getContext
(
glContextType
glContextProperties
)
;
}
t
.
add_cleanup
(
async
(
)
=
>
{
xr_debug
(
name
'
cleanup
'
)
;
await
navigator
.
xr
.
test
.
disconnectAllDevices
(
)
;
}
)
;
xr_debug
(
name
'
main
'
)
;
return
func
(
t
gl
)
;
}
name
properties
)
;
}
function
requestSkipAnimationFrame
(
session
callback
)
{
session
.
requestAnimationFrame
(
(
)
=
>
{
session
.
requestAnimationFrame
(
callback
)
;
}
)
;
}
function
xr_session_promise_test
(
name
func
fakeDeviceInit
sessionMode
sessionInit
properties
glcontextPropertiesParam
gllayerPropertiesParam
)
{
const
glcontextProperties
=
(
glcontextPropertiesParam
)
?
glcontextPropertiesParam
:
{
}
;
const
gllayerProperties
=
(
gllayerPropertiesParam
)
?
gllayerPropertiesParam
:
{
}
;
function
runTest
(
t
glContext
)
{
let
testSession
;
let
testDeviceController
;
let
sessionObjects
=
{
gl
:
glContext
}
;
t
.
add_cleanup
(
async
(
)
=
>
{
if
(
testSession
)
{
await
testSession
.
end
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
}
)
;
return
navigator
.
xr
.
test
.
simulateDeviceConnection
(
fakeDeviceInit
)
.
then
(
(
controller
)
=
>
{
testDeviceController
=
controller
;
return
sessionObjects
.
gl
.
makeXRCompatible
(
)
;
}
)
.
then
(
(
)
=
>
new
Promise
(
(
resolve
reject
)
=
>
{
xr_debug
(
name
'
simulateUserActivation
'
)
;
navigator
.
xr
.
test
.
simulateUserActivation
(
(
)
=
>
{
xr_debug
(
name
'
document
.
hasFocus
(
)
=
'
+
document
.
hasFocus
(
)
)
;
navigator
.
xr
.
requestSession
(
sessionMode
sessionInit
|
|
{
}
)
.
then
(
(
session
)
=
>
{
xr_debug
(
name
'
session
start
'
)
;
testSession
=
session
;
session
.
mode
=
sessionMode
;
session
.
sessionInit
=
sessionInit
;
let
glLayer
=
new
XRWebGLLayer
(
session
sessionObjects
.
gl
gllayerProperties
)
;
glLayer
.
context
=
sessionObjects
.
gl
;
session
.
updateRenderState
(
{
baseLayer
:
glLayer
}
)
;
sessionObjects
.
glLayer
=
glLayer
;
xr_debug
(
name
'
session
.
visibilityState
=
'
+
session
.
visibilityState
)
;
try
{
resolve
(
func
(
session
testDeviceController
t
sessionObjects
)
)
;
}
catch
(
err
)
{
reject
(
"
Test
function
failed
with
:
"
+
err
)
;
}
}
)
.
catch
(
(
err
)
=
>
{
xr_debug
(
name
'
error
:
'
+
err
)
;
reject
(
'
Session
with
params
'
+
JSON
.
stringify
(
sessionMode
)
+
'
was
rejected
on
device
'
+
JSON
.
stringify
(
fakeDeviceInit
)
+
'
with
error
:
'
+
err
)
;
}
)
;
}
)
;
}
)
)
;
}
xr_promise_test
(
name
+
'
-
webgl
'
runTest
properties
'
webgl
'
{
alpha
:
false
antialias
:
false
.
.
.
glcontextProperties
}
)
;
xr_promise_test
(
name
+
'
-
webgl2
'
runTest
properties
'
webgl2
'
{
alpha
:
false
antialias
:
false
.
.
.
glcontextProperties
}
)
;
}
function
promise_simulate_user_activation
(
func
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
navigator
.
xr
.
test
.
simulateUserActivation
(
(
)
=
>
{
try
{
let
a
=
func
(
)
;
resolve
(
a
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
;
}
)
;
}
function
forEachWebxrObject
(
callback
)
{
callback
(
window
.
navigator
.
xr
'
navigator
.
xr
'
)
;
callback
(
window
.
XRSession
'
XRSession
'
)
;
callback
(
window
.
XRSessionCreationOptions
'
XRSessionCreationOptions
'
)
;
callback
(
window
.
XRFrameRequestCallback
'
XRFrameRequestCallback
'
)
;
callback
(
window
.
XRPresentationContext
'
XRPresentationContext
'
)
;
callback
(
window
.
XRFrame
'
XRFrame
'
)
;
callback
(
window
.
XRLayer
'
XRLayer
'
)
;
callback
(
window
.
XRView
'
XRView
'
)
;
callback
(
window
.
XRViewport
'
XRViewport
'
)
;
callback
(
window
.
XRViewerPose
'
XRViewerPose
'
)
;
callback
(
window
.
XRWebGLLayer
'
XRWebGLLayer
'
)
;
callback
(
window
.
XRWebGLLayerInit
'
XRWebGLLayerInit
'
)
;
callback
(
window
.
XRCoordinateSystem
'
XRCoordinateSystem
'
)
;
callback
(
window
.
XRFrameOfReference
'
XRFrameOfReference
'
)
;
callback
(
window
.
XRStageBounds
'
XRStageBounds
'
)
;
callback
(
window
.
XRSessionEvent
'
XRSessionEvent
'
)
;
callback
(
window
.
XRCoordinateSystemEvent
'
XRCoordinateSystemEvent
'
)
;
}
async
function
loadChromiumResources
(
)
{
await
loadScript
(
'
/
resources
/
chromium
/
webxr
-
test
-
math
-
helper
.
js
'
)
;
await
import
(
'
/
resources
/
chromium
/
webxr
-
test
.
js
'
)
;
await
loadScript
(
'
/
resources
/
testdriver
.
js
'
)
;
await
loadScript
(
'
/
resources
/
testdriver
-
vendor
.
js
'
)
;
if
(
typeof
(
additionalChromiumResources
)
!
=
=
'
undefined
'
)
{
for
(
const
path
of
additionalChromiumResources
)
{
await
loadScript
(
path
)
;
}
}
xr_debug
=
navigator
.
xr
.
test
.
Debug
;
}
function
setupWebKitWebXRTestAPI
(
)
{
navigator
.
xr
.
test
=
internals
.
xrTest
;
return
Promise
.
resolve
(
)
;
}
