const
STORE_URL
=
'
/
fenced
-
frame
/
resources
/
key
-
value
-
store
.
py
'
;
const
BEACON_URL
=
'
/
fenced
-
frame
/
resources
/
automatic
-
beacon
-
store
.
py
'
;
const
REMOTE_EXECUTOR_URL
=
'
/
fenced
-
frame
/
resources
/
remote
-
context
-
executor
.
https
.
html
'
;
const
FLEDGE_BIDDING_URL
=
'
/
fenced
-
frame
/
resources
/
fledge
-
bidding
-
logic
.
js
'
;
const
FLEDGE_BIDDING_WITH_SIZE_URL
=
'
/
fenced
-
frame
/
resources
/
fledge
-
bidding
-
logic
-
with
-
size
.
js
'
;
const
FLEDGE_DECISION_URL
=
'
/
fenced
-
frame
/
resources
/
fledge
-
decision
-
logic
.
js
'
;
function
generateURL
(
href
keylist
)
{
const
ret_url
=
new
URL
(
href
location
.
href
)
;
ret_url
.
searchParams
.
append
(
"
keylist
"
keylist
.
join
(
'
'
)
)
;
return
ret_url
;
}
function
getRemoteContextURL
(
origin
)
{
return
new
URL
(
REMOTE_EXECUTOR_URL
origin
)
;
}
async
function
runSelectRawURL
(
href
resolve_to_config
=
false
)
{
try
{
await
sharedStorage
.
worklet
.
addModule
(
"
/
shared
-
storage
/
resources
/
simple
-
module
.
js
"
)
;
}
catch
(
e
)
{
}
return
await
sharedStorage
.
selectURL
(
'
test
-
url
-
selection
-
operation
'
[
{
url
:
href
}
]
{
data
:
{
'
mockResult
'
:
0
}
resolveToConfig
:
resolve_to_config
keepAlive
:
true
}
)
;
}
async
function
runSelectURL
(
href
keylist
=
[
]
resolve_to_config
=
false
)
{
const
full_url
=
generateURL
(
href
keylist
)
;
return
await
runSelectRawURL
(
full_url
resolve_to_config
)
;
}
async
function
generateURNFromFledgeRawURL
(
href
nested_urls
resolve_to_config
=
false
ad_with_size
=
false
requested_size
=
null
)
{
const
bidding_token
=
token
(
)
;
const
seller_token
=
token
(
)
;
const
ad_components_list
=
nested_urls
.
map
(
(
url
)
=
>
{
return
ad_with_size
?
{
renderUrl
:
url
sizeGroup
:
"
group1
"
}
:
{
renderUrl
:
url
}
}
)
;
const
interestGroup
=
ad_with_size
?
{
name
:
'
testAd1
'
owner
:
location
.
origin
biddingLogicUrl
:
new
URL
(
FLEDGE_BIDDING_WITH_SIZE_URL
location
.
origin
)
ads
:
[
{
renderUrl
:
href
sizeGroup
:
"
group1
"
bid
:
1
}
]
userBiddingSignals
:
{
biddingToken
:
bidding_token
}
trustedBiddingSignalsKeys
:
[
'
key1
'
]
adComponents
:
ad_components_list
adSizes
:
{
"
size1
"
:
{
width
:
"
100px
"
height
:
"
50px
"
}
}
sizeGroups
:
{
"
group1
"
:
[
"
size1
"
]
}
}
:
{
name
:
'
testAd1
'
owner
:
location
.
origin
biddingLogicUrl
:
new
URL
(
FLEDGE_BIDDING_URL
location
.
origin
)
ads
:
[
{
renderUrl
:
href
bid
:
1
}
]
userBiddingSignals
:
{
biddingToken
:
bidding_token
}
trustedBiddingSignalsKeys
:
[
'
key1
'
]
adComponents
:
ad_components_list
}
;
navigator
.
joinAdInterestGroup
(
interestGroup
3000000
)
;
let
auctionConfig
=
{
seller
:
location
.
origin
interestGroupBuyers
:
[
location
.
origin
]
decisionLogicUrl
:
new
URL
(
FLEDGE_DECISION_URL
location
.
origin
)
auctionSignals
:
{
biddingToken
:
bidding_token
sellerToken
:
seller_token
}
resolveToConfig
:
resolve_to_config
}
;
if
(
requested_size
)
{
auctionConfig
[
'
requestedSize
'
]
=
{
width
:
requested_size
[
0
]
height
:
requested_size
[
1
]
}
;
}
return
navigator
.
runAdAuction
(
auctionConfig
)
;
}
async
function
generateURNFromFledge
(
href
keylist
nested_urls
=
[
]
resolve_to_config
=
false
ad_with_size
=
false
requested_size
=
null
)
{
const
full_url
=
generateURL
(
href
keylist
)
;
return
generateURNFromFledgeRawURL
(
full_url
nested_urls
resolve_to_config
ad_with_size
requested_size
)
;
}
function
parseKeylist
(
)
{
const
url
=
new
URL
(
location
.
href
)
;
const
keylist
=
url
.
searchParams
.
get
(
"
keylist
"
)
;
return
keylist
.
split
(
'
'
)
;
}
function
getRemoteOriginURL
(
url
https
=
true
)
{
const
same_origin
=
location
.
origin
;
const
cross_origin
=
https
?
get_host_info
(
)
.
HTTPS_REMOTE_ORIGIN
:
get_host_info
(
)
.
HTTP_REMOTE_ORIGIN
;
return
new
URL
(
url
.
toString
(
)
.
replace
(
same_origin
cross_origin
)
)
;
}
function
generateRemoteContextURL
(
headers
origin
)
{
const
uuid
=
token
(
)
;
const
url
=
getRemoteContextURL
(
origin
?
origin
:
location
.
origin
)
;
url
.
searchParams
.
append
(
'
uuid
'
uuid
)
;
headers
.
push
(
[
"
Supports
-
Loading
-
Mode
"
"
fenced
-
frame
"
]
)
;
function
escape
(
s
)
{
return
s
.
replace
(
'
(
'
'
\
\
(
'
)
.
replace
(
'
)
'
'
\
\
)
'
)
;
}
const
formatted_headers
=
headers
.
map
(
(
header
)
=
>
{
return
header
(
{
escape
(
header
[
0
]
)
}
{
escape
(
header
[
1
]
)
}
)
;
}
)
;
url
.
searchParams
.
append
(
'
pipe
'
formatted_headers
.
join
(
'
|
'
)
)
;
return
[
uuid
url
]
;
}
function
buildRemoteContextForObject
(
object
uuid
html
)
{
const
context
=
new
RemoteContext
(
uuid
)
;
if
(
html
)
{
context
.
execute_script
(
(
html_source
)
=
>
{
document
.
body
.
insertAdjacentHTML
(
'
beforebegin
'
html_source
)
;
}
[
html
]
)
;
}
const
handler
=
{
get
:
(
target
key
)
=
>
{
if
(
key
=
=
"
execute
"
)
{
return
context
.
execute_script
;
}
if
(
key
=
=
"
element
"
)
{
return
object
;
}
if
(
key
in
target
)
{
return
target
[
key
]
;
}
return
context
[
key
]
;
}
set
:
(
target
key
value
)
=
>
{
target
[
key
]
=
value
;
return
value
;
}
}
;
const
proxy
=
new
Proxy
(
object
handler
)
;
return
proxy
;
}
function
attachContext
(
object_constructor
html
headers
origin
)
{
const
[
uuid
url
]
=
generateRemoteContextURL
(
headers
origin
)
;
const
object
=
object_constructor
(
url
)
;
return
buildRemoteContextForObject
(
object
uuid
html
)
;
}
async
function
attachOpaqueContext
(
generator_api
resolve_to_config
ad_with_size
requested_size
object_constructor
html
headers
origin
)
{
const
[
uuid
url
]
=
generateRemoteContextURL
(
headers
origin
)
;
const
id
=
await
(
generator_api
=
=
'
fledge
'
?
generateURNFromFledge
(
url
[
]
[
]
resolve_to_config
ad_with_size
requested_size
)
:
runSelectURL
(
url
[
]
resolve_to_config
)
)
;
const
object
=
object_constructor
(
id
)
;
return
buildRemoteContextForObject
(
object
uuid
html
)
;
}
function
attachPotentiallyOpaqueContext
(
generator_api
resolve_to_config
ad_with_size
requested_size
frame_constructor
html
headers
origin
)
{
generator_api
=
generator_api
.
toLowerCase
(
)
;
if
(
generator_api
=
=
'
fledge
'
|
|
generator_api
=
=
'
sharedstorage
'
)
{
return
attachOpaqueContext
(
generator_api
resolve_to_config
ad_with_size
requested_size
frame_constructor
html
headers
origin
)
;
}
else
{
return
attachContext
(
frame_constructor
html
headers
origin
)
;
}
}
function
attachFrameContext
(
element_name
generator_api
resolve_to_config
ad_with_size
requested_size
html
headers
attributes
origin
)
{
frame_constructor
=
(
id
)
=
>
{
frame
=
document
.
createElement
(
element_name
)
;
attributes
.
forEach
(
attribute
=
>
{
frame
.
setAttribute
(
attribute
[
0
]
attribute
[
1
]
)
;
}
)
;
if
(
element_name
=
=
"
iframe
"
)
{
frame
.
src
=
id
;
}
else
if
(
id
instanceof
FencedFrameConfig
)
{
frame
.
config
=
id
;
}
else
{
const
config
=
new
FencedFrameConfig
(
id
)
;
frame
.
config
=
config
;
}
document
.
body
.
append
(
frame
)
;
return
frame
;
}
;
return
attachPotentiallyOpaqueContext
(
generator_api
resolve_to_config
ad_with_size
requested_size
frame_constructor
html
headers
origin
)
;
}
function
replaceFrameContext
(
frame_proxy
{
generator_api
=
"
"
resolve_to_config
=
false
ad_with_size
=
false
requested_size
=
null
html
=
"
"
headers
=
[
]
origin
=
"
"
}
=
{
}
)
{
frame_constructor
=
(
id
)
=
>
{
if
(
frame_proxy
.
element
.
nodeName
=
=
"
IFRAME
"
)
{
frame_proxy
.
element
.
src
=
id
;
}
else
if
(
id
instanceof
FencedFrameConfig
)
{
frame_proxy
.
element
.
config
=
id
;
}
else
{
const
config
=
new
FencedFrameConfig
(
id
)
;
frame_proxy
.
element
.
config
=
config
;
}
return
frame_proxy
.
element
;
}
;
return
attachPotentiallyOpaqueContext
(
generator_api
resolve_to_config
ad_with_size
requested_size
frame_constructor
html
headers
origin
)
;
}
function
attachFencedFrameContext
(
{
generator_api
=
"
"
resolve_to_config
=
false
ad_with_size
=
false
requested_size
=
null
html
=
"
"
headers
=
[
]
attributes
=
[
]
origin
=
"
"
}
=
{
}
)
{
return
attachFrameContext
(
'
fencedframe
'
generator_api
resolve_to_config
ad_with_size
requested_size
html
headers
attributes
origin
)
;
}
function
attachIFrameContext
(
{
generator_api
=
"
"
html
=
"
"
headers
=
[
]
attributes
=
[
]
origin
=
"
"
}
=
{
}
)
{
return
attachFrameContext
(
'
iframe
'
generator_api
resolve_to_config
=
false
ad_with_size
=
false
requested_size
=
null
html
headers
attributes
origin
)
;
}
function
attachWindowContext
(
{
target
=
"
_blank
"
html
=
"
"
headers
=
[
]
origin
=
"
"
}
=
{
}
)
{
window_constructor
=
(
url
)
=
>
{
return
window
.
open
(
url
target
)
;
}
return
attachContext
(
window_constructor
html
headers
origin
)
;
}
async
function
stringToStashKey
(
string
)
{
const
data
=
new
TextEncoder
(
)
.
encode
(
string
)
;
const
digest
=
await
crypto
.
subtle
.
digest
(
'
SHA
-
256
'
data
)
;
const
digest_array
=
Array
.
from
(
new
Uint8Array
(
digest
)
)
;
const
digest_as_hex
=
digest_array
.
map
(
b
=
>
b
.
toString
(
16
)
.
padStart
(
2
'
0
'
)
)
.
join
(
'
'
)
;
const
digest_slices
=
[
digest_as_hex
.
slice
(
0
8
)
digest_as_hex
.
slice
(
8
12
)
digest_as_hex
.
slice
(
12
16
)
digest_as_hex
.
slice
(
16
20
)
digest_as_hex
.
slice
(
20
32
)
]
;
return
digest_slices
.
join
(
'
-
'
)
;
}
function
attachFencedFrame
(
target
)
{
assert_implements
(
window
.
HTMLFencedFrameElement
'
The
HTMLFencedFrameElement
should
be
exposed
on
the
window
object
'
)
;
const
fenced_frame
=
document
.
createElement
(
'
fencedframe
'
)
;
if
(
target
instanceof
FencedFrameConfig
)
{
fenced_frame
.
config
=
target
;
}
else
{
const
config
=
new
FencedFrameConfig
(
target
)
;
fenced_frame
.
config
=
config
;
}
document
.
body
.
append
(
fenced_frame
)
;
return
fenced_frame
;
}
function
attachIFrame
(
url
)
{
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
src
=
url
;
document
.
body
.
append
(
iframe
)
;
return
iframe
;
}
async
function
readValueFromServer
(
key
)
{
key
=
await
key
;
const
serverUrl
=
{
STORE_URL
}
?
key
=
{
key
}
;
const
response
=
await
fetch
(
serverUrl
)
;
if
(
!
response
.
ok
)
throw
new
Error
(
'
An
error
happened
in
the
server
'
)
;
const
value
=
await
response
.
text
(
)
;
if
(
value
=
=
=
"
<
Not
set
>
"
)
return
{
status
:
false
}
;
return
{
status
:
true
value
:
value
}
;
}
async
function
nextValueFromServer
(
key
)
{
key
=
await
key
;
while
(
true
)
{
const
{
status
value
}
=
await
readValueFromServer
(
key
)
;
if
(
!
status
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
20
)
)
;
continue
;
}
return
value
;
}
}
async
function
readAutomaticBeaconDataFromServer
(
)
{
const
serverUrl
=
{
BEACON_URL
}
;
const
response
=
await
fetch
(
serverUrl
)
;
if
(
!
response
.
ok
)
throw
new
Error
(
'
An
error
happened
in
the
server
'
)
;
const
value
=
await
response
.
text
(
)
;
if
(
value
=
=
=
"
<
Not
set
>
"
)
return
{
status
:
false
}
;
return
{
status
:
true
value
:
value
}
;
}
async
function
nextAutomaticBeacon
(
)
{
while
(
true
)
{
const
{
status
value
}
=
await
readAutomaticBeaconDataFromServer
(
)
;
if
(
!
status
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
20
)
)
;
continue
;
}
return
value
;
}
}
async
function
writeValueToServer
(
key
value
origin
=
'
'
)
{
key
=
await
key
;
const
serverUrl
=
{
origin
}
{
STORE_URL
}
?
key
=
{
key
}
&
value
=
{
value
}
;
await
fetch
(
serverUrl
{
"
mode
"
:
"
no
-
cors
"
}
)
;
}
async
function
simulateGesture
(
)
{
while
(
window
.
innerWidth
=
=
0
)
{
await
new
Promise
(
resolve
=
>
requestAnimationFrame
(
resolve
)
)
;
}
await
test_driver
.
bless
(
'
simulate
gesture
'
)
;
}
function
createLocalSource
(
key
url
)
{
return
<
head
>
<
script
src
=
"
{
url
}
"
>
<
\
/
script
>
<
/
head
>
<
body
>
<
script
>
writeValueToServer
(
"
{
key
}
"
"
LOADED
"
/
*
origin
=
*
/
"
{
url
.
origin
}
"
)
;
<
\
/
script
>
<
/
body
>
;
}
function
setupCSP
(
csp
second_csp
=
null
)
{
let
meta
=
document
.
createElement
(
'
meta
'
)
;
meta
.
httpEquiv
=
"
Content
-
Security
-
Policy
"
;
meta
.
content
=
"
fenced
-
frame
-
src
"
+
csp
;
document
.
head
.
appendChild
(
meta
)
;
if
(
second_csp
!
=
null
)
{
let
second_meta
=
document
.
createElement
(
'
meta
'
)
;
second_meta
.
httpEquiv
=
"
Content
-
Security
-
Policy
"
;
second_meta
.
content
=
"
frame
-
src
"
+
second_csp
;
document
.
head
.
appendChild
(
second_meta
)
;
}
}
