const
STORE_URL
=
'
/
fenced
-
frame
/
resources
/
key
-
value
-
store
.
py
'
;
const
BEACON_URL
=
'
/
fenced
-
frame
/
resources
/
beacon
-
store
.
py
'
;
const
REMOTE_EXECUTOR_URL
=
'
/
fenced
-
frame
/
resources
/
remote
-
context
-
executor
.
https
.
html
'
;
const
FLEDGE_BIDDING_URL
=
'
/
fenced
-
frame
/
resources
/
fledge
-
bidding
-
logic
.
py
'
;
const
FLEDGE_DECISION_URL
=
'
/
fenced
-
frame
/
resources
/
fledge
-
decision
-
logic
.
py
'
;
function
generateURL
(
href
keylist
)
{
const
ret_url
=
new
URL
(
href
location
.
href
)
;
ret_url
.
searchParams
.
append
(
"
keylist
"
keylist
.
join
(
'
'
)
)
;
return
ret_url
;
}
function
getRemoteContextURL
(
origin
)
{
return
new
URL
(
REMOTE_EXECUTOR_URL
origin
)
;
}
async
function
runSelectRawURL
(
href
resolve_to_config
=
false
)
{
try
{
await
sharedStorage
.
worklet
.
addModule
(
"
/
shared
-
storage
/
resources
/
simple
-
module
.
js
"
)
;
}
catch
(
e
)
{
}
return
await
sharedStorage
.
selectURL
(
'
test
-
url
-
selection
-
operation
'
[
{
url
:
href
reportingMetadata
:
{
'
reserved
.
top_navigation_start
'
:
BEACON_URL
+
"
?
type
=
reserved
.
top_navigation_start
"
'
reserved
.
top_navigation_commit
'
:
BEACON_URL
+
"
?
type
=
reserved
.
top_navigation_commit
"
}
}
]
{
data
:
{
'
mockResult
'
:
0
}
resolveToConfig
:
resolve_to_config
keepAlive
:
true
}
)
;
}
async
function
runSelectURL
(
href
keylist
=
[
]
resolve_to_config
=
false
)
{
const
full_url
=
generateURL
(
href
keylist
)
;
return
await
runSelectRawURL
(
full_url
resolve_to_config
)
;
}
async
function
generateURNFromFledgeRawURL
(
href
nested_urls
resolve_to_config
=
false
ad_with_size
=
false
requested_size
=
null
register_beacon
=
false
)
{
const
bidding_token
=
token
(
)
;
const
seller_token
=
token
(
)
;
const
ad_components_list
=
nested_urls
.
map
(
(
url
)
=
>
{
return
ad_with_size
?
{
renderURL
:
url
sizeGroup
:
"
group1
"
}
:
{
renderURL
:
url
}
}
)
;
let
interestGroup
=
{
name
:
'
testAd1
'
owner
:
location
.
origin
biddingLogicURL
:
new
URL
(
FLEDGE_BIDDING_URL
location
.
origin
)
ads
:
[
{
renderURL
:
href
bid
:
1
allowedReportingOrigins
:
[
location
.
origin
]
}
]
userBiddingSignals
:
{
biddingToken
:
bidding_token
}
trustedBiddingSignalsKeys
:
[
'
key1
'
]
adComponents
:
ad_components_list
}
;
let
biddingURLParams
=
new
URLSearchParams
(
interestGroup
.
biddingLogicURL
.
search
)
;
if
(
requested_size
)
biddingURLParams
.
set
(
'
requested
-
size
'
requested_size
[
0
]
+
'
-
'
+
requested_size
[
1
]
)
;
if
(
ad_with_size
)
biddingURLParams
.
set
(
'
ad
-
with
-
size
'
1
)
;
if
(
register_beacon
)
biddingURLParams
.
set
(
'
beacon
'
1
)
;
interestGroup
.
biddingLogicURL
.
search
=
biddingURLParams
;
if
(
ad_with_size
)
{
interestGroup
.
ads
[
0
]
.
sizeGroup
=
'
group1
'
;
interestGroup
.
adSizes
=
{
'
size1
'
:
{
width
:
'
100px
'
height
:
'
50px
'
}
}
;
interestGroup
.
sizeGroups
=
{
'
group1
'
:
[
'
size1
'
]
}
;
}
navigator
.
joinAdInterestGroup
(
interestGroup
3000000
)
;
let
auctionConfig
=
{
seller
:
location
.
origin
interestGroupBuyers
:
[
location
.
origin
]
decisionLogicURL
:
new
URL
(
FLEDGE_DECISION_URL
location
.
origin
)
auctionSignals
:
{
biddingToken
:
bidding_token
sellerToken
:
seller_token
}
resolveToConfig
:
resolve_to_config
}
;
if
(
requested_size
)
{
let
decisionURLParams
=
new
URLSearchParams
(
auctionConfig
.
decisionLogicURL
.
search
)
;
decisionURLParams
.
set
(
'
requested
-
size
'
requested_size
[
0
]
+
'
-
'
+
requested_size
[
1
]
)
;
auctionConfig
.
decisionLogicURL
.
search
=
decisionURLParams
;
auctionConfig
[
'
requestedSize
'
]
=
{
width
:
requested_size
[
0
]
height
:
requested_size
[
1
]
}
;
}
return
navigator
.
runAdAuction
(
auctionConfig
)
;
}
async
function
generateURNFromFledge
(
href
keylist
nested_urls
=
[
]
resolve_to_config
=
false
ad_with_size
=
false
requested_size
=
null
register_beacon
=
false
)
{
const
full_url
=
generateURL
(
href
keylist
)
;
return
generateURNFromFledgeRawURL
(
full_url
nested_urls
resolve_to_config
ad_with_size
requested_size
register_beacon
)
;
}
function
parseKeylist
(
)
{
const
url
=
new
URL
(
location
.
href
)
;
const
keylist
=
url
.
searchParams
.
get
(
"
keylist
"
)
;
return
keylist
.
split
(
'
'
)
;
}
function
getRemoteOriginURL
(
url
https
=
true
)
{
const
same_origin
=
location
.
origin
;
const
cross_origin
=
https
?
get_host_info
(
)
.
HTTPS_REMOTE_ORIGIN
:
get_host_info
(
)
.
HTTP_REMOTE_ORIGIN
;
return
new
URL
(
url
.
toString
(
)
.
replace
(
same_origin
cross_origin
)
)
;
}
function
generateRemoteContextURL
(
headers
origin
)
{
const
uuid
=
token
(
)
;
const
url
=
getRemoteContextURL
(
origin
?
origin
:
location
.
origin
)
;
url
.
searchParams
.
append
(
'
uuid
'
uuid
)
;
headers
.
push
(
[
"
Supports
-
Loading
-
Mode
"
"
fenced
-
frame
"
]
)
;
function
escape
(
s
)
{
return
s
.
replace
(
'
(
'
'
\
\
(
'
)
.
replace
(
'
)
'
'
\
\
)
'
)
;
}
const
formatted_headers
=
headers
.
map
(
(
header
)
=
>
{
return
header
(
{
escape
(
header
[
0
]
)
}
{
escape
(
header
[
1
]
)
}
)
;
}
)
;
url
.
searchParams
.
append
(
'
pipe
'
formatted_headers
.
join
(
'
|
'
)
)
;
return
[
uuid
url
]
;
}
function
buildRemoteContextForObject
(
object
uuid
html
)
{
const
context
=
new
RemoteContext
(
uuid
)
;
if
(
html
)
{
context
.
execute_script
(
(
html_source
)
=
>
{
document
.
body
.
insertAdjacentHTML
(
'
beforebegin
'
html_source
)
;
}
[
html
]
)
;
}
const
handler
=
{
get
:
(
target
key
)
=
>
{
if
(
key
=
=
"
execute
"
)
{
return
context
.
execute_script
;
}
if
(
key
=
=
"
element
"
)
{
return
object
;
}
if
(
key
in
target
)
{
return
target
[
key
]
;
}
return
context
[
key
]
;
}
set
:
(
target
key
value
)
=
>
{
target
[
key
]
=
value
;
return
value
;
}
}
;
if
(
object
=
=
null
)
{
object
=
{
}
;
}
const
proxy
=
new
Proxy
(
object
handler
)
;
return
proxy
;
}
function
attachContext
(
object_constructor
html
headers
origin
)
{
const
[
uuid
url
]
=
generateRemoteContextURL
(
headers
origin
)
;
const
object
=
object_constructor
(
url
)
;
return
buildRemoteContextForObject
(
object
uuid
html
)
;
}
async
function
attachOpaqueContext
(
generator_api
resolve_to_config
ad_with_size
requested_size
register_beacon
object_constructor
html
headers
origin
component_origin
num_components
)
{
const
[
uuid
url
]
=
generateRemoteContextURL
(
headers
origin
)
;
let
components_list
=
[
]
;
for
(
let
i
=
0
;
i
<
num_components
;
i
+
+
)
{
let
[
component_uuid
component_url
]
=
generateRemoteContextURL
(
headers
component_origin
)
;
html
+
=
'
<
input
type
=
\
'
hidden
\
'
id
=
\
'
component_uuid_
'
+
i
+
'
\
'
value
=
\
'
'
+
component_uuid
+
'
\
'
>
'
;
components_list
.
push
(
component_url
)
;
}
const
id
=
await
(
generator_api
=
=
'
fledge
'
?
generateURNFromFledge
(
url
[
]
components_list
resolve_to_config
ad_with_size
requested_size
register_beacon
)
:
runSelectURL
(
url
[
]
resolve_to_config
)
)
;
const
object
=
object_constructor
(
id
)
;
return
buildRemoteContextForObject
(
object
uuid
html
)
;
}
function
attachPotentiallyOpaqueContext
(
generator_api
resolve_to_config
ad_with_size
requested_size
register_beacon
frame_constructor
html
headers
origin
component_origin
num_components
)
{
generator_api
=
generator_api
.
toLowerCase
(
)
;
if
(
generator_api
=
=
'
fledge
'
|
|
generator_api
=
=
'
sharedstorage
'
)
{
return
attachOpaqueContext
(
generator_api
resolve_to_config
ad_with_size
requested_size
register_beacon
frame_constructor
html
headers
origin
component_origin
num_components
)
;
}
else
{
return
attachContext
(
frame_constructor
html
headers
origin
)
;
}
}
function
attachFrameContext
(
element_name
generator_api
resolve_to_config
ad_with_size
requested_size
register_beacon
html
headers
attributes
origin
component_origin
num_components
)
{
frame_constructor
=
(
id
)
=
>
{
frame
=
document
.
createElement
(
element_name
)
;
attributes
.
forEach
(
attribute
=
>
{
frame
.
setAttribute
(
attribute
[
0
]
attribute
[
1
]
)
;
}
)
;
if
(
element_name
=
=
"
iframe
"
)
{
frame
.
src
=
id
;
}
else
if
(
id
instanceof
FencedFrameConfig
)
{
frame
.
config
=
id
;
}
else
{
const
config
=
new
FencedFrameConfig
(
id
)
;
frame
.
config
=
config
;
}
document
.
body
.
append
(
frame
)
;
return
frame
;
}
;
return
attachPotentiallyOpaqueContext
(
generator_api
resolve_to_config
ad_with_size
requested_size
register_beacon
frame_constructor
html
headers
origin
component_origin
num_components
)
;
}
async
function
navigateFrameContext
(
frame_proxy
{
headers
=
[
]
origin
=
'
'
}
)
{
const
[
uuid
url
]
=
generateRemoteContextURL
(
headers
origin
)
;
frame_proxy
.
execute
(
(
url
)
=
>
{
window
.
executor
.
suspend
(
(
)
=
>
{
window
.
location
=
url
;
}
)
;
}
[
url
]
)
frame_proxy
.
context_id
=
uuid
;
}
function
replaceFrameContext
(
frame_proxy
{
generator_api
=
'
'
resolve_to_config
=
false
ad_with_size
=
false
requested_size
=
null
register_beacon
=
false
html
=
'
'
headers
=
[
]
origin
=
'
'
}
=
{
}
)
{
frame_constructor
=
(
id
)
=
>
{
if
(
frame_proxy
.
element
.
nodeName
=
=
"
IFRAME
"
)
{
frame_proxy
.
element
.
src
=
id
;
}
else
if
(
id
instanceof
FencedFrameConfig
)
{
frame_proxy
.
element
.
config
=
id
;
}
else
{
const
config
=
new
FencedFrameConfig
(
id
)
;
frame_proxy
.
element
.
config
=
config
;
}
return
frame_proxy
.
element
;
}
;
return
attachPotentiallyOpaqueContext
(
generator_api
resolve_to_config
ad_with_size
requested_size
register_beacon
frame_constructor
html
headers
origin
)
;
}
function
attachFencedFrameContext
(
{
generator_api
=
'
'
resolve_to_config
=
false
ad_with_size
=
false
requested_size
=
null
register_beacon
=
false
html
=
'
'
headers
=
[
]
attributes
=
[
]
origin
=
'
'
component_origin
=
'
'
num_components
=
0
}
=
{
}
)
{
return
attachFrameContext
(
'
fencedframe
'
generator_api
resolve_to_config
ad_with_size
requested_size
register_beacon
html
headers
attributes
origin
component_origin
num_components
)
;
}
function
attachIFrameContext
(
{
generator_api
=
'
'
register_beacon
=
false
html
=
'
'
headers
=
[
]
attributes
=
[
]
origin
=
'
'
component_origin
=
'
'
num_components
=
0
}
=
{
}
)
{
return
attachFrameContext
(
'
iframe
'
generator_api
resolve_to_config
=
false
ad_with_size
=
false
requested_size
=
null
register_beacon
html
headers
attributes
origin
component_origin
num_components
)
;
}
function
attachWindowContext
(
{
target
=
"
_blank
"
html
=
"
"
headers
=
[
]
origin
=
"
"
}
=
{
}
)
{
window_constructor
=
(
url
)
=
>
{
return
window
.
open
(
url
target
)
;
}
return
attachContext
(
window_constructor
html
headers
origin
)
;
}
function
attachComponentFencedFrameContext
(
index
=
0
{
attributes
=
[
]
html
=
'
'
}
=
{
}
)
{
const
urn
=
window
.
fence
.
getNestedConfigs
(
)
[
index
]
;
return
attachComponentFrameContext
(
index
'
fencedframe
'
urn
attributes
html
)
;
}
function
attachComponentIFrameContext
(
index
=
0
{
attributes
=
[
]
html
=
'
'
}
=
{
}
)
{
const
urn
=
navigator
.
adAuctionComponents
(
index
+
1
)
[
index
]
;
return
attachComponentFrameContext
(
index
'
iframe
'
urn
attributes
html
)
;
}
function
attachComponentFrameContext
(
index
element_name
urn
attributes
html
)
{
assert_not_equals
(
document
.
getElementById
(
'
component_uuid_
'
+
index
)
null
'
Component
frames
can
only
be
attached
to
frames
loaded
with
'
+
'
attach
*
FrameContext
(
)
with
num_components
set
to
at
least
'
+
(
index
+
1
)
+
'
.
'
)
;
let
frame
=
document
.
createElement
(
element_name
)
;
attributes
.
forEach
(
attribute
=
>
{
frame
.
setAttribute
(
attribute
[
0
]
attribute
[
1
]
)
;
}
)
;
if
(
element_name
=
=
'
iframe
'
)
{
frame
.
src
=
urn
;
}
else
{
frame
.
config
=
urn
;
}
document
.
body
.
append
(
frame
)
;
const
context_uuid
=
document
.
getElementById
(
'
component_uuid_
'
+
index
)
.
value
;
return
buildRemoteContextForObject
(
frame
context_uuid
html
)
;
}
async
function
stringToStashKey
(
string
)
{
const
data
=
new
TextEncoder
(
)
.
encode
(
string
)
;
const
digest
=
await
crypto
.
subtle
.
digest
(
'
SHA
-
256
'
data
)
;
const
digest_array
=
Array
.
from
(
new
Uint8Array
(
digest
)
)
;
const
digest_as_hex
=
digest_array
.
map
(
b
=
>
b
.
toString
(
16
)
.
padStart
(
2
'
0
'
)
)
.
join
(
'
'
)
;
const
digest_slices
=
[
digest_as_hex
.
slice
(
0
8
)
digest_as_hex
.
slice
(
8
12
)
digest_as_hex
.
slice
(
12
16
)
digest_as_hex
.
slice
(
16
20
)
digest_as_hex
.
slice
(
20
32
)
]
;
return
digest_slices
.
join
(
'
-
'
)
;
}
function
attachFencedFrame
(
target
)
{
assert_implements
(
window
.
HTMLFencedFrameElement
'
The
HTMLFencedFrameElement
should
be
exposed
on
the
window
object
'
)
;
const
fenced_frame
=
document
.
createElement
(
'
fencedframe
'
)
;
if
(
target
instanceof
FencedFrameConfig
)
{
fenced_frame
.
config
=
target
;
}
else
{
const
config
=
new
FencedFrameConfig
(
target
)
;
fenced_frame
.
config
=
config
;
}
document
.
body
.
append
(
fenced_frame
)
;
return
fenced_frame
;
}
function
attachIFrame
(
url
)
{
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
src
=
url
;
document
.
body
.
append
(
iframe
)
;
return
iframe
;
}
async
function
readValueFromServer
(
key
)
{
key
=
await
key
;
const
serverURL
=
{
STORE_URL
}
?
key
=
{
key
}
;
const
response
=
await
fetch
(
serverURL
)
;
if
(
!
response
.
ok
)
throw
new
Error
(
'
An
error
happened
in
the
server
'
)
;
const
value
=
await
response
.
text
(
)
;
if
(
value
=
=
=
"
<
Not
set
>
"
)
return
{
status
:
false
}
;
return
{
status
:
true
value
:
value
}
;
}
async
function
nextValueFromServer
(
key
)
{
key
=
await
key
;
while
(
true
)
{
const
{
status
value
}
=
await
readValueFromServer
(
key
)
;
if
(
!
status
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
20
)
)
;
continue
;
}
return
value
;
}
}
async
function
readBeaconDataFromServer
(
event_type
expected_body
)
{
let
serverURL
=
{
BEACON_URL
}
;
const
response
=
await
fetch
(
serverURL
+
"
?
"
+
new
URLSearchParams
(
{
type
:
event_type
expected_body
:
expected_body
}
)
)
;
if
(
!
response
.
ok
)
throw
new
Error
(
'
An
error
happened
in
the
server
'
+
response
.
status
)
;
const
value
=
await
response
.
text
(
)
;
if
(
value
=
=
=
"
<
Not
set
>
"
)
return
{
status
:
false
}
;
return
{
status
:
true
value
:
value
}
;
}
async
function
nextBeacon
(
event_type
expected_body
)
{
while
(
true
)
{
const
{
status
value
}
=
await
readBeaconDataFromServer
(
event_type
expected_body
)
;
if
(
!
status
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
20
)
)
;
continue
;
}
return
value
;
}
}
async
function
writeValueToServer
(
key
value
origin
=
'
'
)
{
key
=
await
key
;
const
serverURL
=
{
origin
}
{
STORE_URL
}
?
key
=
{
key
}
&
value
=
{
value
}
;
await
fetch
(
serverURL
{
"
mode
"
:
"
no
-
cors
"
}
)
;
}
async
function
simulateGesture
(
)
{
while
(
window
.
innerWidth
=
=
0
)
{
await
new
Promise
(
resolve
=
>
requestAnimationFrame
(
resolve
)
)
;
}
await
test_driver
.
bless
(
'
simulate
gesture
'
)
;
}
function
createLocalSource
(
key
url
)
{
return
<
head
>
<
script
src
=
"
{
url
}
"
>
<
\
/
script
>
<
/
head
>
<
body
>
<
script
>
writeValueToServer
(
"
{
key
}
"
"
LOADED
"
/
*
origin
=
*
/
"
{
url
.
origin
}
"
)
;
<
\
/
script
>
<
/
body
>
;
}
function
setupCSP
(
csp
second_csp
=
null
)
{
let
headers
=
[
]
;
headers
.
push
(
[
"
Content
-
Security
-
Policy
"
"
fenced
-
frame
-
src
"
+
csp
]
)
;
if
(
second_csp
!
=
null
)
{
headers
.
push
(
[
"
Content
-
Security
-
Policy
"
"
frame
-
src
"
+
second_csp
]
)
;
}
const
iframe
=
attachIFrameContext
(
{
headers
:
headers
}
)
;
return
iframe
;
}
async
function
multiClick
(
x
y
click_origin
times
=
3
)
{
for
(
let
i
=
0
;
i
<
times
;
i
+
+
)
{
let
actions
=
new
test_driver
.
Actions
(
)
;
await
actions
.
pointerMove
(
x
y
{
origin
:
click_origin
}
)
.
pointerDown
(
)
.
pointerUp
(
)
.
send
(
)
;
}
}
