const
NavigationTrigger
=
{
Click
:
0
ClickOnce
:
1
CrossOriginClick
:
2
CrossOriginClickNoOptIn
:
3
}
;
async
function
setupAutomaticBeacon
(
remote_context
beacon_events
navigation_url
=
'
resources
/
dummy
.
html
'
navigation_trigger
=
NavigationTrigger
.
Click
target
=
'
_blank
'
)
{
const
full_url
=
new
URL
(
navigation_url
location
.
href
)
;
await
remote_context
.
execute
(
async
(
NavigationTrigger
beacon_events
navigation_trigger
full_url
target
)
=
>
{
switch
(
navigation_trigger
)
{
case
NavigationTrigger
.
Click
:
addEventListener
(
'
click
'
(
event
)
=
>
{
beacon_events
.
forEach
(
(
beacon_event
)
=
>
{
window
.
fence
.
setReportEventDataForAutomaticBeacons
(
beacon_event
)
;
}
)
;
window
.
open
(
full_url
target
)
;
}
)
;
break
;
case
NavigationTrigger
.
ClickOnce
:
beacon_events
.
forEach
(
(
beacon_event
)
=
>
{
window
.
fence
.
setReportEventDataForAutomaticBeacons
(
beacon_event
)
;
}
)
;
addEventListener
(
'
click
'
(
event
)
=
>
{
window
.
open
(
full_url
target
)
;
}
)
;
break
;
case
NavigationTrigger
.
CrossOriginClick
:
case
NavigationTrigger
.
CrossOriginClickNoOptIn
:
beacon_events
.
forEach
(
(
beacon_event
)
=
>
{
window
.
fence
.
setReportEventDataForAutomaticBeacons
(
beacon_event
)
;
}
)
;
const
iframe
=
await
attachIFrameContext
(
{
origin
:
get_host_info
(
)
.
HTTPS_REMOTE_ORIGIN
headers
:
[
[
'
Allow
-
Fenced
-
Frame
-
Automatic
-
Beacons
'
navigation_trigger
=
=
NavigationTrigger
.
CrossOriginClick
?
'
true
'
:
'
false
'
]
]
}
)
;
await
iframe
.
execute
(
async
(
full_url
target
)
=
>
{
addEventListener
(
'
click
'
(
event
)
=
>
{
window
.
open
(
full_url
target
)
;
}
)
;
}
[
full_url
target
]
)
;
break
;
}
}
[
NavigationTrigger
beacon_events
navigation_trigger
full_url
target
]
)
;
}
async
function
verifyBeaconData
(
event_type
event_data
expected_referrer
=
null
expected_success
=
true
t
)
{
if
(
expected_success
)
{
const
data
=
await
nextBeacon
(
event_type
event_data
)
;
const
[
beacon_initiator_origin
beacon_referrer
]
=
data
.
split
(
"
"
)
;
assert_equals
(
beacon_initiator_origin
get_host_info
(
)
.
HTTPS_ORIGIN
"
The
initiator
origin
should
be
set
as
expected
.
"
)
;
assert_equals
(
beacon_referrer
(
expected_referrer
?
expected_referrer
:
get_host_info
(
)
.
HTTPS_ORIGIN
)
+
"
/
"
"
The
beacon
referrer
should
be
set
as
expected
.
"
)
;
}
else
{
const
timeout
=
new
Promise
(
r
=
>
t
.
step_timeout
(
r
1000
)
)
;
const
result
=
await
Promise
.
race
(
[
nextBeacon
(
event_type
event_data
)
timeout
]
)
;
assert_true
(
typeof
result
=
=
=
'
undefined
'
"
The
beacon
should
not
have
sent
.
"
)
;
}
}
