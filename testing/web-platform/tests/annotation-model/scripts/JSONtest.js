function
JSONtest
(
params
)
{
'
use
strict
'
;
this
.
Assertions
=
[
]
;
this
.
AssertionText
=
"
"
;
this
.
DescriptionText
=
"
"
;
this
.
Base
=
null
;
this
.
TestDir
=
null
;
this
.
Params
=
null
;
this
.
Properties
=
null
;
this
.
Test
=
null
;
this
.
AssertionCounter
=
0
;
this
.
_assertionText
=
[
]
;
this
.
_assertionCache
=
[
]
;
this
.
_loading
=
true
;
var
pending
=
[
]
;
pending
.
push
(
new
Promise
(
function
(
resolve
)
{
on_event
(
document
"
DOMContentLoaded
"
function
(
)
{
resolve
(
true
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
)
;
this
.
ajv
=
new
Ajv
(
{
allErrors
:
true
validateSchema
:
false
}
)
;
var
l
=
document
.
location
;
var
p
=
l
.
pathname
;
this
.
TestDir
=
p
.
substr
(
0
1
+
p
.
lastIndexOf
(
'
/
'
)
)
;
this
.
Base
=
p
.
substr
(
0
1
+
p
.
indexOf
(
'
/
'
1
)
)
;
if
(
window
&
&
window
.
opener
&
&
window
.
opener
.
testharness_properties
)
{
this
.
Properties
=
window
.
opener
.
testharness_properties
;
}
this
.
Params
=
params
;
if
(
this
.
Params
.
schemaDefs
)
{
var
defPromise
=
new
Promise
(
function
(
resolve
reject
)
{
var
promisedSchema
=
this
.
Params
.
schemaDefs
.
map
(
function
(
item
)
{
return
this
.
loadDefinition
(
item
)
;
}
.
bind
(
this
)
)
;
Promise
.
all
(
promisedSchema
)
.
then
(
function
(
schemaContents
)
{
this
.
ajv
.
addSchema
(
schemaContents
)
;
resolve
(
true
)
;
}
.
bind
(
this
)
)
.
catch
(
function
(
err
)
{
reject
(
err
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
pending
.
push
(
defPromise
)
;
}
pending
.
push
(
this
.
loadTest
(
params
)
.
then
(
function
(
test
)
{
if
(
typeof
test
=
=
=
'
string
'
)
{
test
=
JSON
.
parse
(
test
)
;
}
this
.
Test
=
test
;
if
(
test
.
description
)
{
this
.
DescriptionText
=
test
.
description
;
}
return
new
Promise
(
function
(
resolve
reject
)
{
if
(
test
.
assertions
&
&
typeof
test
.
assertions
=
=
=
"
object
"
)
{
var
assertFiles
=
this
.
_assertionRefs
(
test
.
assertions
)
;
var
promisedAsserts
=
assertFiles
.
map
(
function
(
item
)
{
return
this
.
loadAssertion
(
item
)
;
}
.
bind
(
this
)
)
;
Promise
.
all
(
promisedAsserts
)
.
then
(
function
(
assertContents
)
{
var
assertIdx
=
0
;
var
buildList
=
function
(
assertions
level
)
{
if
(
level
=
=
=
undefined
)
{
level
=
1
;
}
var
list
=
[
]
;
if
(
assertions
)
{
if
(
typeof
assertions
=
=
=
"
object
"
&
&
assertions
.
hasOwnProperty
(
'
assertions
'
)
)
{
if
(
level
=
=
=
0
)
{
list
.
push
(
assertContents
[
assertIdx
]
)
;
}
this
.
AssertionText
+
=
"
<
li
>
"
+
assertContents
[
assertIdx
+
+
]
.
title
;
this
.
AssertionText
+
=
"
<
ol
>
"
;
buildList
(
assertions
.
assertions
level
+
1
)
;
this
.
AssertionText
+
=
"
<
/
ol
>
<
/
li
>
\
n
"
;
}
else
{
assertions
.
forEach
(
function
(
assert
)
{
if
(
typeof
assert
=
=
=
"
object
"
&
&
Array
.
isArray
(
assert
)
)
{
this
.
AssertionText
+
=
"
<
ol
>
"
;
buildList
(
assert
level
+
1
)
;
this
.
AssertionText
+
=
"
<
/
ol
>
\
n
"
;
}
else
if
(
typeof
assert
=
=
=
"
object
"
&
&
!
Array
.
isArray
(
assert
)
&
&
assert
.
hasOwnProperty
(
'
assertions
'
)
)
{
if
(
level
=
=
=
0
)
{
list
.
push
(
assertContents
[
assertIdx
]
)
;
}
this
.
AssertionText
+
=
"
<
li
>
"
+
assertContents
[
assertIdx
+
+
]
.
title
;
this
.
AssertionText
+
=
"
<
ol
>
"
;
buildList
(
assert
level
+
1
)
;
this
.
AssertionText
+
=
"
<
/
ol
>
<
/
li
>
\
n
"
;
}
else
{
if
(
level
=
=
=
0
)
{
list
.
push
(
assertContents
[
assertIdx
]
)
;
}
this
.
AssertionText
+
=
"
<
li
>
"
+
assertContents
[
assertIdx
+
+
]
.
title
+
"
<
/
li
>
\
n
"
;
}
}
.
bind
(
this
)
)
;
}
}
return
list
;
}
.
bind
(
this
)
;
this
.
Assertions
=
buildList
(
test
.
assertions
0
)
;
resolve
(
true
)
;
}
.
bind
(
this
)
)
.
catch
(
function
(
err
)
{
reject
(
err
)
;
}
.
bind
(
this
)
)
;
}
else
{
if
(
!
test
.
assertions
)
{
reject
(
"
Test
has
no
assertion
property
"
)
;
}
else
{
reject
(
"
Test
assertion
property
is
not
an
Array
"
)
;
}
}
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
)
;
Promise
.
all
(
pending
)
.
then
(
function
(
)
{
this
.
loading
=
false
;
this
.
init
(
)
;
}
.
bind
(
this
)
)
.
catch
(
function
(
err
)
{
test
(
function
(
)
{
assert_true
(
false
"
Loading
of
test
components
failed
:
"
+
JSON
.
stringify
(
err
)
)
;
}
"
Loading
test
components
"
)
;
done
(
)
;
return
;
}
.
bind
(
this
)
)
;
return
this
;
}
JSONtest
.
prototype
=
{
init
:
function
(
)
{
'
use
strict
'
;
var
runButton
=
document
.
getElementById
(
this
.
Params
.
runTest
)
;
var
closeButton
=
document
.
getElementById
(
this
.
Params
.
closeWindow
)
;
var
testInput
=
document
.
getElementById
(
this
.
Params
.
testInput
)
;
var
assertion
=
document
.
getElementById
(
"
assertion
"
)
;
var
desc
=
document
.
getElementById
(
"
testDescription
"
)
;
if
(
!
this
.
loading
)
{
runButton
.
disabled
=
false
;
runButton
.
value
=
"
Check
JSON
"
;
if
(
desc
)
{
desc
.
innerHTML
=
this
.
DescriptionText
;
}
if
(
assertion
)
{
assertion
.
innerHTML
=
"
<
ol
>
"
+
this
.
AssertionText
+
"
<
/
ol
>
\
n
"
;
}
}
else
{
window
.
alert
(
"
Loading
did
not
finish
before
init
handler
was
called
!
"
)
;
}
if
(
0
&
&
this
.
Properties
&
&
this
.
Properties
.
output
&
&
closeButton
)
{
add_completion_callback
(
function
(
)
{
var
p
=
new
Promise
(
function
(
resolve
)
{
closeButton
.
style
.
display
=
"
inline
"
;
closeButton
.
disabled
=
false
;
on_event
(
closeButton
"
click
"
function
(
)
{
resolve
(
true
)
;
}
)
;
}
.
bind
(
this
)
)
;
p
.
then
(
)
;
}
.
bind
(
this
)
)
;
}
on_event
(
runButton
"
click
"
function
(
)
{
var
content
=
testInput
.
value
;
runButton
.
disabled
=
true
;
if
(
typeof
content
=
=
=
"
string
"
)
{
try
{
content
=
JSON
.
parse
(
content
)
;
}
catch
(
err
)
{
test
(
function
(
)
{
assert_true
(
false
"
Parse
of
JSON
failed
:
"
+
err
)
;
}
"
Parsing
submitted
input
"
)
;
done
(
)
;
return
;
}
}
this
.
runTests
(
this
.
Assertions
content
)
;
done
(
)
;
}
.
bind
(
this
)
)
;
}
runTests
:
function
(
assertions
content
testAction
level
compareWith
)
{
'
use
strict
'
;
if
(
level
=
=
=
undefined
)
{
level
=
1
;
}
if
(
testAction
=
=
=
undefined
)
{
testAction
=
'
continue
'
;
}
if
(
compareWith
=
=
=
undefined
)
{
compareWith
=
'
and
'
;
}
var
theResults
=
[
]
;
if
(
assertions
)
{
assertions
.
forEach
(
function
(
assert
num
)
{
var
expected
=
assert
.
hasOwnProperty
(
'
expectedResult
'
)
?
assert
.
expectedResult
:
'
valid
'
;
var
message
=
assert
.
hasOwnProperty
(
'
message
'
)
?
assert
.
message
:
"
Result
was
not
"
+
expected
;
if
(
typeof
assert
=
=
=
"
object
"
&
&
!
Array
.
isArray
(
assert
)
)
{
if
(
assert
.
hasOwnProperty
(
"
compareWith
"
)
&
&
assert
.
hasOwnProperty
(
"
assertions
"
)
&
&
Array
.
isArray
(
assert
.
assertions
)
)
{
var
r
=
this
.
runTests
(
assert
.
assertions
content
testAction
level
+
1
assert
.
compareWith
)
;
testAction
=
r
.
action
;
var
result
=
true
;
var
data
=
r
.
results
;
var
i
;
if
(
assert
.
compareWith
=
=
=
"
or
"
)
{
result
=
false
;
for
(
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
if
(
data
[
i
]
)
{
result
=
true
;
}
}
}
else
{
for
(
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
if
(
!
data
[
i
]
)
{
result
=
false
;
}
}
}
test
(
function
(
)
{
var
newAction
=
this
.
determineAction
(
assert
result
)
;
testAction
=
newAction
;
var
err
=
"
;
"
;
if
(
testAction
=
=
=
'
abort
'
)
{
err
+
=
"
;
Aborting
execution
of
remaining
assertions
;
"
;
}
else
if
(
testAction
=
=
=
'
skip
'
)
{
err
+
=
"
;
Skipping
execution
of
remaining
assertions
at
level
"
+
level
+
"
;
"
;
}
if
(
result
=
=
=
false
)
{
assert_true
(
result
message
+
err
)
;
}
else
{
assert_true
(
result
err
)
;
}
}
.
bind
(
this
)
"
"
+
level
+
"
:
"
+
(
num
+
1
)
+
"
"
+
assert
.
title
)
;
return
;
}
}
else
if
(
typeof
assert
=
=
=
"
object
"
&
&
Array
.
isArray
(
assert
)
)
{
var
o
=
this
.
runTests
(
assert
content
testAction
level
+
1
)
;
if
(
o
.
result
&
&
o
.
result
=
=
=
'
abort
'
)
{
testAction
=
'
abort
'
;
}
}
if
(
testAction
=
=
=
'
abort
'
)
{
return
{
action
:
'
abort
'
}
;
}
var
schemaName
=
"
inline
"
+
level
+
"
:
"
+
(
num
+
1
)
;
if
(
typeof
assert
=
=
=
"
string
"
)
{
if
(
this
.
_assertionCache
[
assert
]
)
{
assert
=
this
.
_assertionCache
[
assert
]
;
}
else
{
test
(
function
(
)
{
assert_true
(
false
"
Reference
to
assertion
"
+
assert
+
"
at
level
"
+
level
+
"
:
"
+
(
num
+
1
)
+
"
unresolved
"
)
;
}
"
Processing
"
+
assert
)
;
return
;
}
}
if
(
assert
.
assertionFile
)
{
schemaName
=
"
external
file
"
+
assert
.
assertionFile
+
"
"
+
level
+
"
:
"
+
(
num
+
1
)
;
}
var
validate
=
null
;
try
{
validate
=
this
.
ajv
.
compile
(
assert
)
;
}
catch
(
err
)
{
test
(
function
(
)
{
assert_true
(
false
"
Compilation
of
schema
"
+
level
+
"
:
"
+
(
num
+
1
)
+
"
failed
:
"
+
err
)
;
}
"
Compiling
"
+
schemaName
)
;
return
;
}
if
(
testAction
!
=
=
'
continue
'
)
{
test
(
function
(
)
{
}
"
SKIPPED
:
"
+
assert
.
title
)
;
}
else
{
test
(
function
(
)
{
var
valid
=
validate
(
content
)
;
var
result
=
this
.
determineResult
(
assert
valid
)
;
theResults
.
push
(
result
)
;
var
newAction
=
this
.
determineAction
(
assert
result
)
;
testAction
=
newAction
;
var
err
=
"
;
"
;
if
(
validate
.
errors
!
=
=
null
)
{
err
=
"
;
Errors
:
"
+
this
.
ajv
.
errorsText
(
validate
.
errors
)
+
"
;
"
;
}
if
(
testAction
=
=
=
'
abort
'
)
{
err
+
=
"
;
Aborting
execution
of
remaining
assertions
;
"
;
}
else
if
(
testAction
=
=
=
'
skip
'
)
{
err
+
=
"
;
Skipping
execution
of
remaining
assertions
at
level
"
+
level
+
"
;
"
;
}
if
(
result
=
=
=
false
)
{
assert_true
(
result
message
+
err
)
;
}
else
{
assert_true
(
result
err
)
;
}
}
.
bind
(
this
)
"
"
+
level
+
"
:
"
+
(
num
+
1
)
+
"
"
+
assert
.
title
)
;
}
}
.
bind
(
this
)
)
;
}
return
{
action
:
testAction
results
:
theResults
}
;
}
determineResult
:
function
(
schema
valid
)
{
'
use
strict
'
;
var
r
=
'
valid
'
;
if
(
schema
.
hasOwnProperty
(
'
expectedResult
'
)
)
{
r
=
schema
.
expectedResult
;
}
if
(
r
=
=
=
'
valid
'
&
&
valid
|
|
r
=
=
=
'
invalid
'
&
&
!
valid
)
{
return
true
;
}
else
{
return
false
;
}
}
determineAction
:
function
(
schema
result
)
{
'
use
strict
'
;
var
mapping
=
{
'
failAndContinue
'
:
'
continue
'
'
failAndSkip
'
:
'
skip
'
'
failAndAbort
'
:
'
abort
'
'
passAndContinue
'
:
'
continue
'
'
passAndSkip
'
:
'
skip
'
'
passAndAbort
'
:
'
abort
'
}
;
if
(
result
)
{
return
'
continue
'
;
}
var
a
=
'
failAndContinue
'
;
if
(
schema
.
hasOwnProperty
(
'
onUnexpectedResult
'
)
)
{
a
=
schema
.
onUnexpectedResult
;
}
if
(
mapping
[
a
]
)
{
return
mapping
[
a
]
;
}
else
{
return
'
continue
'
;
}
}
loadAssertion
:
function
(
afile
)
{
'
use
strict
'
;
if
(
typeof
(
afile
)
=
=
=
'
string
'
)
{
var
theFile
=
this
.
_parseURI
(
afile
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
this
.
_loadFile
(
"
GET
"
theFile
true
)
.
then
(
function
(
data
)
{
data
.
assertionFile
=
afile
;
this
.
_assertionCache
[
afile
]
=
data
;
resolve
(
data
)
;
}
.
bind
(
this
)
)
.
catch
(
function
(
err
)
{
if
(
typeof
err
=
=
=
"
object
"
)
{
err
.
theFile
=
theFile
;
}
reject
(
err
)
;
}
)
;
}
.
bind
(
this
)
)
;
}
else
if
(
afile
.
hasOwnProperty
(
"
assertionFile
"
)
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
theFile
=
this
.
_parseURI
(
afile
.
assertionFile
)
;
this
.
_loadFile
(
"
GET
"
theFile
true
)
.
then
(
function
(
external
)
{
Object
.
keys
(
afile
)
.
forEach
(
function
(
key
)
{
if
(
key
!
=
=
'
assertionFile
'
)
{
external
[
key
]
=
afile
[
key
]
;
}
}
)
;
resolve
(
external
)
;
}
.
bind
(
this
)
)
.
catch
(
function
(
err
)
{
if
(
typeof
err
=
=
=
"
object
"
)
{
err
.
theFile
=
theFile
;
}
reject
(
err
)
;
}
)
;
}
.
bind
(
this
)
)
;
}
else
{
return
new
Promise
(
function
(
resolve
)
{
resolve
(
afile
)
;
}
)
;
}
}
loadDefinition
:
function
(
dfile
)
{
'
use
strict
'
;
return
new
Promise
(
function
(
resolve
reject
)
{
this
.
_loadFile
(
"
GET
"
this
.
_parseURI
(
dfile
)
true
)
.
then
(
function
(
data
)
{
resolve
(
data
)
;
}
.
bind
(
this
)
)
.
catch
(
function
(
err
)
{
reject
(
err
)
;
}
)
;
}
.
bind
(
this
)
)
;
}
loadTest
:
function
(
params
)
{
'
use
strict
'
;
if
(
params
.
hasOwnProperty
(
'
testFile
'
)
)
{
return
this
.
_loadFile
(
"
GET
"
params
.
testFile
)
;
}
return
new
Promise
(
function
(
resolve
reject
)
{
if
(
params
.
hasOwnProperty
(
'
test
'
)
)
{
resolve
(
params
.
test
)
;
}
else
{
reject
(
"
Must
supply
a
'
test
'
or
'
testFile
'
parameter
"
)
;
}
}
)
;
}
_parseURI
:
function
(
theURI
)
{
'
use
strict
'
;
if
(
theURI
.
indexOf
(
'
/
'
)
=
=
=
-
1
)
{
return
this
.
TestDir
+
theURI
;
}
else
if
(
theURI
.
indexOf
(
'
/
'
)
=
=
=
0
|
|
theURI
.
indexOf
(
'
http
:
'
)
=
=
=
0
|
|
theURI
.
indexOf
(
'
https
:
'
)
=
=
=
0
)
{
return
theURI
;
}
else
{
return
this
.
Base
+
theURI
;
}
}
_assertionRefs
:
function
(
assertions
)
{
'
use
strict
'
;
var
ret
=
[
]
;
if
(
typeof
(
assertions
)
=
=
=
"
object
"
&
&
!
Array
.
isArray
(
assertions
)
&
&
assertions
.
hasOwnProperty
(
'
assertions
'
)
)
{
ret
.
push
(
assertions
)
;
assertions
=
assertions
.
assertions
;
}
if
(
typeof
(
assertions
)
=
=
=
"
object
"
&
&
Array
.
isArray
(
assertions
)
)
{
assertions
.
forEach
(
function
(
assert
)
{
if
(
typeof
assert
=
=
=
"
object
"
&
&
Array
.
isArray
(
assert
)
)
{
this
.
_assertionRefs
(
assert
)
.
forEach
(
function
(
item
)
{
ret
.
push
(
item
)
;
}
.
bind
(
this
)
)
;
}
else
if
(
typeof
assert
=
=
=
"
object
"
)
{
ret
.
push
(
assert
)
;
if
(
assert
.
hasOwnProperty
(
"
assertions
"
)
)
{
ret
.
concat
(
this
.
_assertionRefs
(
assert
.
assertions
)
)
;
}
}
else
{
ret
.
push
(
assert
)
;
}
}
.
bind
(
this
)
)
;
}
return
ret
;
}
_loadFile
:
function
(
method
url
parse
)
{
'
use
strict
'
;
if
(
parse
=
=
=
undefined
)
{
parse
=
true
;
}
return
new
Promise
(
function
(
resolve
reject
)
{
if
(
document
.
location
.
search
)
{
var
s
=
document
.
location
.
search
;
s
=
s
.
replace
(
/
^
\
?
/
'
'
)
;
if
(
url
.
indexOf
(
'
?
'
)
!
=
=
-
1
)
{
url
+
=
"
&
"
+
s
;
}
else
{
url
+
=
"
?
"
+
s
;
}
}
var
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
method
url
)
;
xhr
.
onload
=
function
(
)
{
if
(
this
.
status
>
=
200
&
&
this
.
status
<
300
)
{
var
d
=
xhr
.
response
;
if
(
parse
)
{
try
{
d
=
JSON
.
parse
(
d
)
;
resolve
(
d
)
;
}
catch
(
err
)
{
reject
(
{
status
:
this
.
status
statusText
:
"
Parsing
of
"
+
url
+
"
failed
:
"
+
err
}
)
;
}
}
else
{
resolve
(
d
)
;
}
}
else
{
reject
(
{
status
:
this
.
status
statusText
:
xhr
.
statusText
}
)
;
}
}
;
xhr
.
onerror
=
function
(
)
{
reject
(
{
status
:
this
.
status
statusText
:
xhr
.
statusText
}
)
;
}
;
xhr
.
send
(
)
;
}
)
;
}
}
;
