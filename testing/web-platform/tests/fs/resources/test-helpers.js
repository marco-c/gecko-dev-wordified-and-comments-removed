const
kCurrentDirectory
=
'
.
'
;
const
kParentDirectory
=
'
.
.
'
;
const
WFS_MODES
=
[
'
siloed
'
'
exclusive
'
]
;
const
SAH_MODES
=
[
'
readwrite
'
'
read
-
only
'
'
readwrite
-
unsafe
'
]
;
const
LOCK_ACCESS
=
{
SHARED
:
'
shared
'
EXCLUSIVE
:
'
exclusive
'
}
;
function
primitiveModesAreContentious
(
exclusiveMode
mode1
mode2
)
{
return
mode1
!
=
mode2
|
|
mode1
=
=
=
exclusiveMode
;
}
function
sahModesAreContentious
(
mode1
mode2
)
{
return
primitiveModesAreContentious
(
'
readwrite
'
mode1
mode2
)
;
}
function
wfsModesAreContentious
(
mode1
mode2
)
{
return
primitiveModesAreContentious
(
'
exclusive
'
mode1
mode2
)
;
}
let
kPathSeparators
=
[
'
/
'
'
\
\
'
]
;
async
function
getFileSize
(
handle
)
{
const
file
=
await
handle
.
getFile
(
)
;
return
file
.
size
;
}
async
function
getFileContents
(
handle
)
{
const
file
=
await
handle
.
getFile
(
)
;
return
new
Response
(
file
)
.
text
(
)
;
}
async
function
getDirectoryEntryCount
(
handle
)
{
let
result
=
0
;
for
await
(
let
entry
of
handle
)
{
result
+
+
;
}
return
result
;
}
async
function
getSortedDirectoryEntries
(
handle
)
{
let
result
=
[
]
;
for
await
(
let
entry
of
handle
.
values
(
)
)
{
if
(
entry
.
kind
=
=
=
'
directory
'
)
{
result
.
push
(
entry
.
name
+
'
/
'
)
;
}
else
{
result
.
push
(
entry
.
name
)
;
}
}
result
.
sort
(
)
;
return
result
;
}
async
function
createDirectory
(
name
parent
)
{
return
await
parent
.
getDirectoryHandle
(
name
{
create
:
true
}
)
;
}
async
function
createEmptyFile
(
name
parent
)
{
const
handle
=
await
parent
.
getFileHandle
(
name
{
create
:
true
}
)
;
assert_equals
(
await
getFileSize
(
handle
)
0
)
;
return
handle
;
}
async
function
createFileWithContents
(
name
contents
parent
)
{
const
handle
=
await
createEmptyFile
(
name
parent
)
;
const
writer
=
await
handle
.
createWritable
(
)
;
await
writer
.
write
(
new
Blob
(
[
contents
]
)
)
;
await
writer
.
close
(
)
;
return
handle
;
}
var
fs_cleanups
=
[
]
;
async
function
cleanup
(
test
value
cleanup_func
)
{
if
(
fs_cleanups
.
length
=
=
=
0
)
{
test
.
add_cleanup
(
async
(
)
=
>
{
fs_cleanups
.
reverse
(
)
;
for
(
let
cleanup
of
fs_cleanups
)
{
try
{
await
cleanup
(
)
;
}
catch
(
e
)
{
}
}
fs_cleanups
.
length
=
0
;
}
)
;
}
fs_cleanups
.
push
(
cleanup_func
)
;
return
value
;
}
async
function
cleanup_writable
(
test
value
)
{
return
cleanup
(
test
value
async
(
)
=
>
{
try
{
return
(
await
value
)
.
close
(
)
;
}
catch
(
e
)
{
}
}
)
;
}
function
getUniqueName
(
name
)
{
return
unique
{
Date
.
now
(
)
}
{
Math
.
random
(
)
.
toString
(
)
.
slice
(
2
)
}
;
}
function
createFileHandles
(
dir
.
.
.
fileNames
)
{
return
Promise
.
all
(
fileNames
.
map
(
fileName
=
>
dir
.
getFileHandle
(
fileName
{
create
:
true
}
)
)
)
;
}
function
createDirectoryHandles
(
dir
.
.
.
dirNames
)
{
return
Promise
.
all
(
dirNames
.
map
(
dirName
=
>
dir
.
getDirectoryHandle
(
dirName
{
create
:
true
}
)
)
)
;
}
async
function
releaseLock
(
lockPromise
)
{
const
result
=
await
lockPromise
;
if
(
result
?
.
close
)
{
await
result
.
close
(
)
;
}
}
function
cleanupLockPromise
(
t
lockPromise
)
{
return
cleanup
(
t
lockPromise
(
)
=
>
releaseLock
(
lockPromise
)
)
;
}
function
createWFSWithCleanup
(
t
fileHandle
wfsOptions
)
{
return
cleanupLockPromise
(
t
fileHandle
.
createWritable
(
wfsOptions
)
)
;
}
function
createWFSWithCleanupFactory
(
wfsOptions
)
{
return
(
t
fileHandle
)
=
>
createWFSWithCleanup
(
t
fileHandle
wfsOptions
)
;
}
function
createSAHWithCleanup
(
t
fileHandle
sahOptions
)
{
return
cleanupLockPromise
(
t
fileHandle
.
createSyncAccessHandle
(
sahOptions
)
)
;
}
function
createSAHWithCleanupFactory
(
sahOptions
)
{
return
(
t
fileHandle
)
=
>
createSAHWithCleanup
(
t
fileHandle
sahOptions
)
;
}
function
createMoveWithCleanup
(
t
fileHandle
fileName
=
'
unique
-
file
-
name
.
test
'
)
{
return
cleanupLockPromise
(
t
fileHandle
.
move
(
fileName
)
)
;
}
function
createRemoveWithCleanup
(
t
fileHandle
)
{
return
cleanupLockPromise
(
t
fileHandle
.
remove
(
{
recursive
:
true
}
)
)
;
}
function
selectDirectoryTests
(
testDescs
testFuncs
)
{
for
(
const
testDesc
in
testDescs
)
{
if
(
!
testFuncs
.
hasOwnProperty
(
testDesc
)
)
{
throw
new
Error
(
'
Passed
a
test
description
in
testDescs
that
wasn
\
'
t
in
testFuncs
.
'
)
;
}
directory_test
(
testFuncs
[
testDesc
]
testDescs
[
testDesc
]
)
;
}
}
function
generateCrossLockTests
(
createLock1
createLock2
testDescs
)
{
if
(
testDescs
=
=
=
undefined
)
{
throw
new
Error
(
'
Must
pass
testDescs
.
'
)
;
}
selectDirectoryTests
(
testDescs
{
sameFile
:
async
(
t
rootDir
)
=
>
{
const
[
fileHandle
]
=
await
createFileHandles
(
rootDir
'
BFS
.
test
'
)
;
createLock1
(
t
fileHandle
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
fileHandle
)
)
;
}
diffFile
:
async
(
t
rootDir
)
=
>
{
const
[
fooFileHandle
barFileHandle
]
=
await
createFileHandles
(
rootDir
'
foo
.
test
'
'
bar
.
test
'
)
;
createLock1
(
t
fooFileHandle
)
;
await
createLock2
(
t
barFileHandle
)
;
}
acquireAfterRelease
:
async
(
t
rootDir
)
=
>
{
let
[
fileHandle
]
=
await
createFileHandles
(
rootDir
'
BFS
.
test
'
)
;
const
lockPromise
=
createLock1
(
t
fileHandle
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
fileHandle
)
)
;
await
releaseLock
(
lockPromise
)
;
[
fileHandle
]
=
await
createFileHandles
(
rootDir
'
BFS
.
test
'
)
;
await
createLock2
(
t
fileHandle
)
;
}
multiAcquireAfterRelease
:
async
(
t
rootDir
)
=
>
{
const
[
fileHandle
]
=
await
createFileHandles
(
rootDir
'
BFS
.
test
'
)
;
const
lock1
=
await
createLock1
(
t
fileHandle
)
;
const
lock2
=
await
createLock1
(
t
fileHandle
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
fileHandle
)
)
;
await
lock1
.
close
(
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
fileHandle
)
)
;
await
lock2
.
close
(
)
;
await
createLock2
(
t
fileHandle
)
;
}
takeDirThenFile
:
async
(
t
rootDir
)
=
>
{
const
dirHandle
=
await
rootDir
.
getDirectoryHandle
(
'
foo
'
{
create
:
true
}
)
;
const
[
fileHandle
]
=
await
createFileHandles
(
dirHandle
'
BFS
.
test
'
)
;
createLock1
(
t
dirHandle
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
fileHandle
)
)
;
}
takeFileThenDir
:
async
(
t
rootDir
)
=
>
{
const
grandparentHandle
=
await
rootDir
.
getDirectoryHandle
(
'
foo
'
{
create
:
true
}
)
;
const
parentHandle
=
await
grandparentHandle
.
getDirectoryHandle
(
'
bar
'
{
create
:
true
}
)
;
let
[
fileHandle
]
=
await
createFileHandles
(
parentHandle
'
BFS
.
test
'
)
;
const
lock1
=
createLock1
(
t
fileHandle
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
parentHandle
)
)
;
await
releaseLock
(
lock1
)
;
[
fileHandle
]
=
await
createFileHandles
(
parentHandle
'
BFS
.
test
'
)
;
createLock1
(
t
fileHandle
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
grandparentHandle
)
)
;
}
}
)
;
}
async
function
testLockAccess
(
t
fileHandle
createLock
)
{
createLock
(
t
fileHandle
)
;
let
access
;
try
{
await
createLock
(
t
fileHandle
)
;
access
=
LOCK_ACCESS
.
SHARED
;
}
catch
(
e
)
{
access
=
LOCK_ACCESS
.
EXCLUSIVE
;
assert_throws_dom
(
'
NoModificationAllowedError
'
(
)
=
>
{
throw
e
;
}
)
;
}
return
access
;
}
function
createBFCacheTest
(
testFunc
testDesc
)
{
function
executeFunc
(
rc
funcName
args
)
{
return
rc
.
executeScript
(
async
(
funcName
args
)
=
>
{
if
(
self
.
testPageFuncs
=
=
=
undefined
)
{
self
.
testPageFuncs
=
(
await
import
(
'
/
fs
/
resources
/
bfcache
-
test
-
page
.
js
'
)
)
;
}
return
await
self
.
testPageFuncs
[
funcName
]
(
.
.
.
args
)
;
}
[
funcName
args
]
)
;
}
promise_test
(
async
t
=
>
{
const
rcHelper
=
new
RemoteContextHelper
(
)
;
const
backRc
=
await
rcHelper
.
addWindow
(
null
{
features
:
'
noopener
'
}
)
;
let
curRc
=
backRc
;
const
testControls
=
{
getRemoteFuncs
:
(
.
.
.
funcNames
)
=
>
{
return
funcNames
.
map
(
funcName
=
>
(
.
.
.
args
)
=
>
executeFunc
(
curRc
funcName
args
)
)
;
}
forward
:
async
(
)
=
>
{
if
(
curRc
!
=
=
backRc
)
{
throw
new
Error
(
'
Can
only
navigate
forward
once
.
'
)
;
}
prepareForBFCache
(
curRc
)
;
curRc
=
await
curRc
.
navigateToNew
(
)
;
}
back
:
async
(
shouldRestoreFromBFCache
)
=
>
{
if
(
curRc
=
=
=
backRc
)
{
throw
new
Error
(
'
Can
\
'
t
navigate
back
if
you
haven
\
'
t
navigated
forward
.
'
)
;
}
await
curRc
.
historyBack
(
)
;
curRc
=
backRc
;
if
(
shouldRestoreFromBFCache
)
{
await
assertImplementsBFCacheOptional
(
curRc
)
;
}
else
{
await
assertNotRestoredFromBFCache
(
curRc
)
;
}
}
assertBFCacheEligibility
(
shouldRestoreFromBFCache
)
{
return
assertBFCacheEligibility
(
curRc
shouldRestoreFromBFCache
)
;
}
}
;
await
testFunc
(
t
testControls
)
;
}
testDesc
)
;
}
