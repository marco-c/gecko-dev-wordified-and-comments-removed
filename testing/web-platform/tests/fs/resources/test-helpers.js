const
kCurrentDirectory
=
'
.
'
;
const
kParentDirectory
=
'
.
.
'
;
const
WFS_MODES
=
[
'
siloed
'
'
exclusive
'
]
;
const
SAH_MODES
=
[
'
readwrite
'
'
read
-
only
'
'
readwrite
-
unsafe
'
]
;
const
LOCK_ACCESS
=
{
SHARED
:
'
shared
'
EXCLUSIVE
:
'
exclusive
'
}
;
let
kPathSeparators
=
[
'
/
'
'
\
\
'
]
;
async
function
getFileSize
(
handle
)
{
const
file
=
await
handle
.
getFile
(
)
;
return
file
.
size
;
}
async
function
getFileContents
(
handle
)
{
const
file
=
await
handle
.
getFile
(
)
;
return
new
Response
(
file
)
.
text
(
)
;
}
async
function
getDirectoryEntryCount
(
handle
)
{
let
result
=
0
;
for
await
(
let
entry
of
handle
)
{
result
+
+
;
}
return
result
;
}
async
function
getSortedDirectoryEntries
(
handle
)
{
let
result
=
[
]
;
for
await
(
let
entry
of
handle
.
values
(
)
)
{
if
(
entry
.
kind
=
=
=
'
directory
'
)
{
result
.
push
(
entry
.
name
+
'
/
'
)
;
}
else
{
result
.
push
(
entry
.
name
)
;
}
}
result
.
sort
(
)
;
return
result
;
}
async
function
createDirectory
(
test
name
parent
)
{
const
new_dir_handle
=
await
parent
.
getDirectoryHandle
(
name
{
create
:
true
}
)
;
cleanup
(
test
new_dir_handle
async
(
)
=
>
{
try
{
await
parent
.
removeEntry
(
name
{
recursive
:
true
}
)
;
}
catch
(
e
)
{
}
}
)
;
return
new_dir_handle
;
}
async
function
createEmptyFile
(
test
name
parent
)
{
const
handle
=
await
parent
.
getFileHandle
(
name
{
create
:
true
}
)
;
cleanup
(
test
handle
async
(
)
=
>
{
try
{
await
parent
.
removeEntry
(
name
)
;
}
catch
(
e
)
{
}
}
)
;
assert_equals
(
await
getFileSize
(
handle
)
0
)
;
return
handle
;
}
async
function
createFileWithContents
(
test
name
contents
parent
)
{
const
handle
=
await
createEmptyFile
(
test
name
parent
)
;
const
writer
=
await
handle
.
createWritable
(
)
;
await
writer
.
write
(
new
Blob
(
[
contents
]
)
)
;
await
writer
.
close
(
)
;
return
handle
;
}
var
fs_cleanups
=
[
]
;
async
function
cleanup
(
test
value
cleanup_func
)
{
if
(
fs_cleanups
.
length
=
=
=
0
)
{
test
.
add_cleanup
(
async
(
)
=
>
{
fs_cleanups
.
reverse
(
)
;
for
(
let
cleanup
of
fs_cleanups
)
{
try
{
await
cleanup
(
)
;
}
catch
(
e
)
{
}
}
fs_cleanups
.
length
=
0
;
}
)
;
}
fs_cleanups
.
push
(
cleanup_func
)
;
return
value
;
}
async
function
cleanup_writable
(
test
value
)
{
return
cleanup
(
test
value
async
(
)
=
>
{
try
{
return
(
await
value
)
.
close
(
)
;
}
catch
(
e
)
{
}
}
)
;
}
function
createFileHandles
(
dir
.
.
.
fileNames
)
{
return
Promise
.
all
(
fileNames
.
map
(
fileName
=
>
dir
.
getFileHandle
(
fileName
{
create
:
true
}
)
)
)
;
}
async
function
releaseLock
(
lockPromise
)
{
const
result
=
await
lockPromise
;
if
(
result
?
.
close
)
{
await
result
.
close
(
)
;
}
}
function
cleanupLockPromise
(
t
lockPromise
)
{
return
cleanup
(
t
lockPromise
(
)
=
>
releaseLock
(
lockPromise
)
)
;
}
function
createWFSWithCleanup
(
t
fileHandle
wfsOptions
)
{
return
cleanupLockPromise
(
t
fileHandle
.
createWritable
(
wfsOptions
)
)
;
}
function
createWFSWithCleanupFactory
(
wfsOptions
)
{
return
(
t
fileHandle
)
=
>
createWFSWithCleanup
(
t
fileHandle
wfsOptions
)
;
}
function
createSAHWithCleanup
(
t
fileHandle
sahOptions
)
{
return
cleanupLockPromise
(
t
fileHandle
.
createSyncAccessHandle
(
sahOptions
)
)
;
}
function
createSAHWithCleanupFactory
(
sahOptions
)
{
return
(
t
fileHandle
)
=
>
createSAHWithCleanup
(
t
fileHandle
sahOptions
)
;
}
function
createMoveWithCleanup
(
t
fileHandle
fileName
=
'
unique
-
file
-
name
.
test
'
)
{
return
cleanupLockPromise
(
t
fileHandle
.
move
(
fileName
)
)
;
}
function
createRemoveWithCleanup
(
t
fileHandle
)
{
return
cleanupLockPromise
(
t
fileHandle
.
remove
(
{
recursive
:
true
}
)
)
;
}
function
selectDirectoryTests
(
testDescs
testFuncs
)
{
for
(
const
testDesc
in
testDescs
)
{
if
(
!
testFuncs
.
hasOwnProperty
(
testDesc
)
)
{
throw
new
Error
(
'
Passed
a
test
description
in
testDescs
that
wasn
\
'
t
in
testFuncs
.
'
)
;
}
directory_test
(
testFuncs
[
testDesc
]
testDescs
[
testDesc
]
)
;
}
}
function
generateCrossLockTests
(
createLock1
createLock2
testDescs
)
{
if
(
testDescs
=
=
=
undefined
)
{
throw
new
Error
(
'
Must
pass
testDescs
.
'
)
;
}
selectDirectoryTests
(
testDescs
{
sameFile
:
async
(
t
rootDir
)
=
>
{
const
[
fileHandle
]
=
await
createFileHandles
(
rootDir
'
BFS
.
test
'
)
;
createLock1
(
t
fileHandle
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
fileHandle
)
)
;
}
diffFile
:
async
(
t
rootDir
)
=
>
{
const
[
fooFileHandle
barFileHandle
]
=
await
createFileHandles
(
rootDir
'
foo
.
test
'
'
bar
.
test
'
)
;
createLock1
(
t
fooFileHandle
)
;
await
createLock2
(
t
barFileHandle
)
;
}
acquireAfterRelease
:
async
(
t
rootDir
)
=
>
{
let
[
fileHandle
]
=
await
createFileHandles
(
rootDir
'
BFS
.
test
'
)
;
const
lockPromise
=
createLock1
(
t
fileHandle
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
fileHandle
)
)
;
await
releaseLock
(
lockPromise
)
;
[
fileHandle
]
=
await
createFileHandles
(
rootDir
'
BFS
.
test
'
)
;
await
createLock2
(
t
fileHandle
)
;
}
multiAcquireAfterRelease
:
async
(
t
rootDir
)
=
>
{
const
[
fileHandle
]
=
await
createFileHandles
(
rootDir
'
BFS
.
test
'
)
;
const
lock1
=
await
createLock1
(
t
fileHandle
)
;
const
lock2
=
await
createLock1
(
t
fileHandle
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
fileHandle
)
)
;
await
lock1
.
close
(
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
fileHandle
)
)
;
await
lock2
.
close
(
)
;
await
createLock2
(
t
fileHandle
)
;
}
takeDirThenFile
:
async
(
t
rootDir
)
=
>
{
const
dirHandle
=
await
rootDir
.
getDirectoryHandle
(
'
foo
'
{
create
:
true
}
)
;
const
[
fileHandle
]
=
await
createFileHandles
(
dirHandle
'
BFS
.
test
'
)
;
createLock1
(
t
dirHandle
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
fileHandle
)
)
;
}
takeFileThenDir
:
async
(
t
rootDir
)
=
>
{
const
grandparentHandle
=
await
rootDir
.
getDirectoryHandle
(
'
foo
'
{
create
:
true
}
)
;
const
parentHandle
=
await
grandparentHandle
.
getDirectoryHandle
(
'
bar
'
{
create
:
true
}
)
;
let
[
fileHandle
]
=
await
createFileHandles
(
parentHandle
'
BFS
.
test
'
)
;
const
lock1
=
createLock1
(
t
fileHandle
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
parentHandle
)
)
;
await
releaseLock
(
lock1
)
;
[
fileHandle
]
=
await
createFileHandles
(
parentHandle
'
BFS
.
test
'
)
;
createLock1
(
t
fileHandle
)
;
await
promise_rejects_dom
(
t
'
NoModificationAllowedError
'
createLock2
(
t
grandparentHandle
)
)
;
}
}
)
;
}
async
function
testLockAccess
(
t
fileHandle
createLock
)
{
createLock
(
t
fileHandle
)
;
let
access
;
try
{
await
createLock
(
t
fileHandle
)
;
access
=
LOCK_ACCESS
.
SHARED
;
}
catch
(
e
)
{
access
=
LOCK_ACCESS
.
EXCLUSIVE
;
assert_throws_dom
(
'
NoModificationAllowedError
'
(
)
=
>
{
throw
e
;
}
)
;
}
return
access
;
}
