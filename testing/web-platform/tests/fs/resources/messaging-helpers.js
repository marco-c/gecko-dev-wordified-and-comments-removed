'
use
strict
'
;
const
kDocumentMessageTarget
=
'
.
.
/
fs
/
resources
/
message
-
target
.
html
'
;
const
kSharedWorkerMessageTarget
=
'
.
.
/
fs
/
resources
/
message
-
target
-
shared
-
worker
.
js
'
;
const
kServiceWorkerMessageTarget
=
'
.
.
/
fs
/
resources
/
message
-
target
-
service
-
worker
.
js
'
;
const
kDedicatedWorkerMessageTarget
=
'
.
.
/
fs
/
resources
/
message
-
target
-
dedicated
-
worker
.
js
'
;
function
create_dedicated_worker
(
test
url
)
{
const
dedicated_worker
=
new
Worker
(
url
)
;
test
.
add_cleanup
(
(
)
=
>
{
dedicated_worker
.
terminate
(
)
;
}
)
;
return
dedicated_worker
;
}
async
function
create_service_worker
(
test
script_url
scope
)
{
const
registration
=
await
service_worker_unregister_and_register
(
test
script_url
scope
)
;
test
.
add_cleanup
(
(
)
=
>
{
return
registration
.
unregister
(
)
;
}
)
;
return
registration
;
}
async
function
add_iframe
(
test
options
)
{
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
if
(
options
.
sandbox
!
=
=
undefined
)
{
iframe
.
sandbox
=
options
.
sandbox
;
}
if
(
options
.
src
!
=
=
undefined
)
{
iframe
.
src
=
options
.
src
;
}
if
(
options
.
srcdoc
!
=
=
undefined
)
{
iframe
.
srcdoc
=
options
.
srcdoc
;
}
document
.
body
.
appendChild
(
iframe
)
;
test
.
add_cleanup
(
(
)
=
>
{
iframe
.
remove
(
)
;
}
)
;
await
wait_for_loaded_message
(
self
)
;
return
iframe
;
}
async
function
open_window
(
test
url
)
{
const
child_window
=
window
.
open
(
url
)
;
test
.
add_cleanup
(
(
)
=
>
{
child_window
.
close
(
)
;
}
)
;
await
wait_for_loaded_message
(
self
)
;
return
child_window
;
}
async
function
wait_for_loaded_message
(
receiver
)
{
const
message_promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
receiver
.
addEventListener
(
'
message
'
message_event
=
>
{
if
(
message_event
.
data
=
=
=
'
LOADED
'
)
{
resolve
(
)
;
}
else
{
reject
(
'
The
message
target
must
receive
a
"
LOADED
"
message
response
.
'
)
;
}
}
)
;
}
)
;
await
message_promise
;
}
function
create_message_channel
(
target
target_origin
)
{
const
message_channel
=
new
MessageChannel
(
)
;
const
message_data
=
{
type
:
'
receive
-
message
-
port
'
message_port
:
message_channel
.
port2
}
;
target
.
postMessage
(
message_data
{
transfer
:
[
message_channel
.
port2
]
targetOrigin
:
target_origin
}
)
;
message_channel
.
port1
.
start
(
)
;
return
message_channel
.
port1
;
}
async
function
create_file_system_handles
(
root
)
{
const
empty_file
=
await
createEmptyFile
(
'
empty
-
file
'
root
)
;
const
first_file
=
await
createFileWithContents
(
'
first
-
file
-
with
-
contents
'
'
first
-
text
-
content
'
root
)
;
const
second_file
=
await
createFileWithContents
(
'
second
-
file
-
with
-
contents
'
'
second
-
text
-
content
'
root
)
;
const
empty_directory
=
await
createDirectory
(
'
empty
-
directory
'
root
)
;
const
directory_with_files
=
await
createDirectory
(
'
directory
-
with
-
files
'
root
)
;
await
createFileWithContents
(
'
first
-
file
-
in
-
directory
'
'
first
-
directory
-
text
-
content
'
directory_with_files
)
;
await
createFileWithContents
(
'
second
-
file
-
in
-
directory
'
'
second
-
directory
-
text
-
content
'
directory_with_files
)
;
const
subdirectory
=
await
createDirectory
(
'
subdirectory
'
directory_with_files
)
;
await
createFileWithContents
(
'
first
-
file
-
in
-
subdirectory
'
'
first
-
subdirectory
-
text
-
content
'
subdirectory
)
;
return
[
empty_file
first_file
second_file
second_file
empty_directory
empty_directory
directory_with_files
]
;
}
async
function
do_post_message_test
(
test
root_dir
receiver
target
target_origin
)
{
const
handles
=
await
create_file_system_handles
(
root_dir
)
;
target
.
postMessage
(
{
type
:
'
receive
-
file
-
system
-
handles
'
cloned_handles
:
handles
}
{
targetOrigin
:
target_origin
}
)
;
const
event_watcher
=
new
EventWatcher
(
test
receiver
'
message
'
)
;
const
message_event
=
await
event_watcher
.
wait_for
(
'
message
'
)
;
const
response
=
message_event
.
data
;
assert_equals
(
response
.
type
'
receive
-
serialized
-
file
-
system
-
handles
'
'
The
test
runner
must
receive
a
"
serialized
-
file
-
system
-
handles
"
'
+
message
response
.
Actual
response
:
{
response
}
)
;
const
expected_serialized_handles
=
await
serialize_handles
(
handles
)
;
assert_equals_serialized_handles
(
response
.
serialized_handles
expected_serialized_handles
)
;
await
assert_equals_cloned_handles
(
response
.
cloned_handles
handles
)
;
}
async
function
do_message_port_test
(
test
root_dir
target
target_origin
)
{
const
message_port
=
create_message_channel
(
target
target_origin
)
;
await
do_post_message_test
(
test
root_dir
message_port
message_port
)
;
}
