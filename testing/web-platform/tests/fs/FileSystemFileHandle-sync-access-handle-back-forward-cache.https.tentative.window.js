'
use
strict
'
;
createBFCacheTest
(
async
(
t
testControls
)
=
>
{
const
{
getRemoteFuncs
assertBFCacheEligibility
}
=
testControls
;
const
[
createAndReleaseSAH
]
=
getRemoteFuncs
(
'
createAndReleaseSAH
'
)
;
for
(
const
mode
of
SAH_MODES
)
{
await
createAndReleaseSAH
(
mode
'
hello
.
txt
'
)
;
await
assertBFCacheEligibility
(
true
)
;
}
}
'
Creating
an
SAH
should
not
make
it
ineligible
for
the
BFCache
.
'
)
;
createBFCacheTest
(
async
(
t
testControls
)
=
>
{
const
origFile
=
'
hello
.
txt
'
;
const
diffFile
=
'
world
.
txt
'
;
const
{
getRemoteFuncs
forward
back
}
=
testControls
;
const
[
createSAH
releaseSAH
createAndReleaseSAH
]
=
getRemoteFuncs
(
'
createSAH
'
'
releaseSAH
'
'
createAndReleaseSAH
'
)
;
async
function
testTakeLockOnForward
(
mode
fileName
shouldRestoreFromBFCache
)
{
await
forward
(
)
;
assert_equals
(
await
createAndReleaseSAH
(
mode
fileName
)
shouldRestoreFromBFCache
)
;
await
back
(
shouldRestoreFromBFCache
)
;
}
for
(
const
backMode
of
SAH_MODES
)
{
for
(
const
forwMode
of
SAH_MODES
)
{
const
contentiousLocks
=
sahModesAreContentious
(
backMode
forwMode
)
;
const
lockId
=
await
createSAH
(
backMode
origFile
)
;
assert_true
(
lockId
!
=
=
undefined
)
;
await
testTakeLockOnForward
(
forwMode
diffFile
true
)
;
await
testTakeLockOnForward
(
forwMode
origFile
!
contentiousLocks
)
;
if
(
!
contentiousLocks
)
{
await
releaseSAH
(
lockId
)
;
}
}
}
}
Creating
a
SAH
on
an
active
page
evicts
an
inactive
page
on
contention
.
)
