'
use
strict
'
;
promise_test
(
async
t
=
>
{
try
{
const
observer
=
new
FileSystemObserver
(
(
)
=
>
{
}
)
;
}
catch
{
assert_unreached
(
)
;
}
}
'
Creating
a
FileSystemObserver
from
a
supported
global
succeeds
'
)
;
directory_test
(
async
(
t
root_dir
)
=
>
{
const
observer
=
new
FileSystemObserver
(
(
)
=
>
{
}
)
;
try
{
observer
.
unobserve
(
root_dir
)
;
}
catch
{
assert_unreached
(
)
;
}
}
'
Calling
unobserve
(
)
without
a
corresponding
observe
(
)
shouldn
\
'
t
throw
'
)
;
directory_test
(
async
(
t
root_dir
)
=
>
{
const
observer
=
new
FileSystemObserver
(
(
)
=
>
{
}
)
;
try
{
observer
.
unobserve
(
root_dir
)
;
observer
.
unobserve
(
root_dir
)
;
}
catch
{
assert_unreached
(
)
;
}
}
'
unobserve
(
)
is
idempotent
'
)
;
promise_test
(
async
t
=
>
{
const
observer
=
new
FileSystemObserver
(
(
)
=
>
{
}
)
;
try
{
observer
.
disconnect
(
)
;
}
catch
{
assert_unreached
(
)
;
}
}
'
Calling
disconnect
(
)
without
observing
shouldn
\
'
t
throw
'
)
;
promise_test
(
async
t
=
>
{
const
observer
=
new
FileSystemObserver
(
(
)
=
>
{
}
)
;
try
{
observer
.
disconnect
(
)
;
observer
.
disconnect
(
)
;
}
catch
{
assert_unreached
(
)
;
}
}
'
disconnect
(
)
is
idempotent
'
)
;
directory_test
(
async
(
t
root_dir
)
=
>
{
const
observer
=
new
FileSystemObserver
(
(
)
=
>
{
}
)
;
const
file
=
await
root_dir
.
getFileHandle
(
getUniqueName
(
)
{
create
:
true
}
)
;
await
file
.
remove
(
)
;
await
promise_rejects_dom
(
t
'
NotFoundError
'
observer
.
observe
(
file
)
)
;
}
'
observe
(
)
fails
when
file
does
not
exist
'
)
;
directory_test
(
async
(
t
root_dir
)
=
>
{
const
observer
=
new
FileSystemObserver
(
(
)
=
>
{
}
)
;
const
dir
=
await
root_dir
.
getDirectoryHandle
(
getUniqueName
(
)
{
create
:
true
}
)
;
await
dir
.
remove
(
)
;
await
promise_rejects_dom
(
t
'
NotFoundError
'
observer
.
observe
(
dir
)
)
;
}
'
observe
(
)
fails
when
directory
does
not
exist
'
)
;
directory_test
(
async
(
t
root_dir
)
=
>
{
const
dir
=
await
root_dir
.
getDirectoryHandle
(
getUniqueName
(
)
{
create
:
true
}
)
;
const
scope_test
=
new
ScopeTest
(
t
dir
)
;
const
watched_handle
=
await
scope_test
.
watched_handle
(
)
;
for
(
const
recursive
of
[
false
true
]
)
{
for
await
(
const
path
of
scope_test
.
in_scope_paths
(
recursive
)
)
{
const
observer
=
new
CollectingFileSystemObserver
(
t
root_dir
)
;
await
observer
.
observe
(
[
watched_handle
]
{
recursive
}
)
;
const
file
=
await
path
.
createHandle
(
)
;
const
records
=
await
observer
.
getRecords
(
)
;
await
assert_records_equal
(
watched_handle
records
[
appearedEvent
(
file
path
.
relativePathComponents
(
)
)
]
)
;
observer
.
disconnect
(
)
;
}
}
}
'
Creating
a
file
through
FileSystemDirectoryHandle
.
getFileHandle
is
reported
as
an
"
appeared
"
event
if
in
scope
'
)
;
directory_test
(
async
(
t
root_dir
)
=
>
{
const
dir
=
await
root_dir
.
getDirectoryHandle
(
getUniqueName
(
)
{
create
:
true
}
)
;
const
scope_test
=
new
ScopeTest
(
t
dir
)
;
const
watched_handle
=
await
scope_test
.
watched_handle
(
)
;
for
(
const
recursive
of
[
false
true
]
)
{
for
await
(
const
path
of
scope_test
.
in_scope_paths
(
recursive
)
)
{
const
file
=
await
path
.
createHandle
(
)
;
const
observer
=
new
CollectingFileSystemObserver
(
t
root_dir
)
;
await
observer
.
observe
(
[
watched_handle
]
{
recursive
}
)
;
await
file
.
remove
(
)
;
const
records
=
await
observer
.
getRecords
(
)
;
await
assert_records_equal
(
watched_handle
records
[
disappearedEvent
(
file
path
.
relativePathComponents
(
)
)
]
)
;
observer
.
disconnect
(
)
;
}
}
}
'
Removing
a
file
through
FileSystemFileHandle
.
remove
is
reported
as
an
"
disappeared
"
event
if
in
scope
'
)
;
directory_test
(
async
(
t
root_dir
)
=
>
{
const
dir
=
await
root_dir
.
getDirectoryHandle
(
getUniqueName
(
)
{
create
:
true
}
)
;
const
scope_test
=
new
ScopeTest
(
t
dir
)
;
const
watched_handle
=
await
scope_test
.
watched_handle
(
)
;
for
(
const
recursive
of
[
false
true
]
)
{
for
await
(
const
path
of
scope_test
.
out_of_scope_paths
(
recursive
)
)
{
const
observer
=
new
CollectingFileSystemObserver
(
t
root_dir
)
;
await
observer
.
observe
(
[
watched_handle
]
{
recursive
}
)
;
const
file
=
await
path
.
createHandle
(
)
;
await
file
.
remove
(
)
;
const
records
=
await
observer
.
getRecords
(
)
;
await
assert_records_equal
(
watched_handle
records
[
]
)
;
observer
.
disconnect
(
)
;
}
}
}
'
Events
outside
the
watch
scope
are
not
sent
to
the
observer
\
'
s
callback
'
)
;
directory_test
(
async
(
t
root_dir
)
=
>
{
const
dir
=
await
root_dir
.
getDirectoryHandle
(
getUniqueName
(
)
{
create
:
true
}
)
;
const
scope_test
=
new
ScopeTest
(
t
dir
)
;
const
watched_handle
=
await
scope_test
.
watched_handle
(
)
;
for
(
const
recursive
of
[
false
true
]
)
{
for
await
(
const
src
of
scope_test
.
in_scope_paths
(
recursive
)
)
{
for
await
(
const
dest
of
scope_test
.
in_scope_paths
(
recursive
)
)
{
const
file
=
await
src
.
createHandle
(
)
;
const
observer
=
new
CollectingFileSystemObserver
(
t
root_dir
)
;
await
observer
.
observe
(
[
watched_handle
]
{
recursive
}
)
;
await
file
.
move
(
dest
.
parentHandle
(
)
dest
.
fileName
(
)
)
;
const
records
=
await
observer
.
getRecords
(
)
;
await
assert_records_equal
(
watched_handle
records
[
movedEvent
(
file
dest
.
relativePathComponents
(
)
src
.
relativePathComponents
(
)
)
]
)
;
observer
.
disconnect
(
)
;
}
}
}
}
'
Moving
a
file
through
FileSystemFileHandle
.
move
is
reported
as
a
"
moved
"
event
if
destination
and
source
are
in
scope
'
)
;
directory_test
(
async
(
t
root_dir
)
=
>
{
const
dir
=
await
root_dir
.
getDirectoryHandle
(
getUniqueName
(
)
{
create
:
true
}
)
;
const
scope_test
=
new
ScopeTest
(
t
dir
)
;
const
watched_handle
=
await
scope_test
.
watched_handle
(
)
;
for
(
const
recursive
of
[
false
true
]
)
{
for
await
(
const
src
of
scope_test
.
out_of_scope_paths
(
recursive
)
)
{
for
await
(
const
dest
of
scope_test
.
out_of_scope_paths
(
recursive
)
)
{
const
file
=
await
src
.
createHandle
(
)
;
const
observer
=
new
CollectingFileSystemObserver
(
t
root_dir
)
;
await
observer
.
observe
(
[
watched_handle
]
{
recursive
}
)
;
await
file
.
move
(
dest
.
parentHandle
(
)
dest
.
fileName
(
)
)
;
const
records
=
await
observer
.
getRecords
(
)
;
await
assert_records_equal
(
watched_handle
records
[
]
)
;
}
}
}
}
'
Moving
a
file
through
FileSystemFileHandle
.
move
is
not
reported
if
destination
and
source
are
not
in
scope
'
)
;
directory_test
(
async
(
t
root_dir
)
=
>
{
const
dir
=
await
root_dir
.
getDirectoryHandle
(
getUniqueName
(
)
{
create
:
true
}
)
;
const
scope_test
=
new
ScopeTest
(
t
dir
)
;
const
watched_handle
=
await
scope_test
.
watched_handle
(
)
;
for
(
const
recursive
of
[
false
true
]
)
{
for
await
(
const
src
of
scope_test
.
out_of_scope_paths
(
recursive
)
)
{
for
await
(
const
dest
of
scope_test
.
in_scope_paths
(
recursive
)
)
{
const
file
=
await
src
.
createHandle
(
)
;
const
observer
=
new
CollectingFileSystemObserver
(
t
root_dir
)
;
await
observer
.
observe
(
[
watched_handle
]
{
recursive
}
)
;
await
file
.
move
(
dest
.
parentHandle
(
)
dest
.
fileName
(
)
)
;
const
records
=
await
observer
.
getRecords
(
)
;
await
assert_records_equal
(
watched_handle
records
[
appearedEvent
(
file
dest
.
relativePathComponents
(
)
)
]
)
;
}
}
}
}
'
Moving
a
file
through
FileSystemFileHandle
.
move
is
reported
as
a
"
appeared
"
event
if
only
destination
is
in
scope
'
)
;
directory_test
(
async
(
t
root_dir
)
=
>
{
const
dir
=
await
root_dir
.
getDirectoryHandle
(
getUniqueName
(
)
{
create
:
true
}
)
;
const
scope_test
=
new
ScopeTest
(
t
dir
)
;
const
watched_handle
=
await
scope_test
.
watched_handle
(
)
;
for
(
const
recursive
of
[
false
true
]
)
{
for
await
(
const
src
of
scope_test
.
in_scope_paths
(
recursive
)
)
{
for
await
(
const
dest
of
scope_test
.
out_of_scope_paths
(
recursive
)
)
{
const
file
=
await
src
.
createHandle
(
)
;
const
fileToMove
=
await
src
.
createHandle
(
)
;
const
observer
=
new
CollectingFileSystemObserver
(
t
root_dir
)
;
await
observer
.
observe
(
[
watched_handle
]
{
recursive
}
)
;
await
fileToMove
.
move
(
dest
.
parentHandle
(
)
dest
.
fileName
(
)
)
;
const
records
=
await
observer
.
getRecords
(
)
;
await
assert_records_equal
(
watched_handle
records
[
disappearedEvent
(
file
src
.
relativePathComponents
(
)
)
]
)
;
}
}
}
}
'
Moving
a
file
through
FileSystemFileHandle
.
move
is
reported
as
a
"
disappeared
"
event
if
only
source
is
in
scope
'
)
;
