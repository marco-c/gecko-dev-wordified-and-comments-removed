'
use
strict
'
;
createBFCacheTest
(
async
(
t
testControls
)
=
>
{
const
{
getRemoteFuncs
assertBFCacheEligibility
}
=
testControls
;
const
[
createAndReleaseWFS
]
=
getRemoteFuncs
(
'
createAndReleaseWFS
'
)
;
for
(
const
mode
of
WFS_MODES
)
{
await
createAndReleaseWFS
(
mode
'
hello
.
txt
'
)
;
await
assertBFCacheEligibility
(
true
)
;
}
}
'
Creating
an
WFS
should
not
make
it
ineligible
for
the
BFCache
.
'
)
;
createBFCacheTest
(
async
(
t
testControls
)
=
>
{
const
origFile
=
'
hello
.
txt
'
;
const
diffFile
=
'
world
.
txt
'
;
const
{
getRemoteFuncs
forward
back
}
=
testControls
;
const
[
createWFS
releaseWFS
createAndReleaseWFS
]
=
getRemoteFuncs
(
'
createWFS
'
'
releaseWFS
'
'
createAndReleaseWFS
'
)
;
async
function
testTakeLockOnForward
(
mode
fileName
shouldRestoreFromBFCache
)
{
await
forward
(
)
;
assert_true
(
await
createAndReleaseWFS
(
mode
fileName
)
)
;
await
back
(
shouldRestoreFromBFCache
)
;
}
for
(
const
backMode
of
WFS_MODES
)
{
for
(
const
forwMode
of
WFS_MODES
)
{
const
contentiousLocks
=
wfsModesAreContentious
(
backMode
forwMode
)
;
const
lockId
=
await
createWFS
(
backMode
origFile
)
;
assert_true
(
lockId
!
=
=
undefined
)
;
await
testTakeLockOnForward
(
forwMode
diffFile
true
)
;
await
testTakeLockOnForward
(
forwMode
origFile
!
contentiousLocks
)
;
if
(
!
contentiousLocks
)
{
await
releaseWFS
(
lockId
)
;
}
}
}
}
Creating
a
WFS
on
an
active
page
evicts
an
inactive
page
on
contention
.
)
