"
use
strict
"
;
testRanges
.
unshift
(
"
[
]
"
)
;
function
testExtendSubSet
(
startIndex
optionalEndIndex
)
{
var
endIndex
=
optionalEndIndex
=
=
=
undefined
?
testRanges
.
length
:
optionalEndIndex
;
if
(
startIndex
<
0
|
|
startIndex
>
=
testRanges
.
length
)
throw
"
Sanity
check
:
Specified
index
is
invalid
.
"
;
if
(
endIndex
<
0
|
|
endIndex
>
testRanges
.
length
)
throw
"
Sanity
check
:
Specified
index
is
invalid
.
"
;
for
(
var
i
=
startIndex
;
i
<
endIndex
;
i
+
+
)
{
var
endpoints
=
eval
(
testRanges
[
i
]
)
;
for
(
var
j
=
0
;
j
<
testPoints
.
length
;
j
+
+
)
{
if
(
endpoints
[
0
]
=
=
endpoints
[
2
]
&
&
endpoints
[
1
]
=
=
endpoints
[
3
]
)
{
test
(
function
(
)
{
setSelectionForwards
(
endpoints
)
;
testExtend
(
endpoints
eval
(
testPoints
[
j
]
)
)
;
}
"
extend
(
)
with
range
"
+
i
+
"
"
+
testRanges
[
i
]
+
"
and
point
"
+
j
+
"
"
+
testPoints
[
j
]
)
;
}
else
{
test
(
function
(
)
{
setSelectionForwards
(
endpoints
)
;
testExtend
(
endpoints
eval
(
testPoints
[
j
]
)
)
;
}
"
extend
(
)
forwards
with
range
"
+
i
+
"
"
+
testRanges
[
i
]
+
"
and
point
"
+
j
+
"
"
+
testPoints
[
j
]
)
;
test
(
function
(
)
{
setSelectionBackwards
(
endpoints
)
;
testExtend
(
endpoints
eval
(
testPoints
[
j
]
)
)
;
}
"
extend
(
)
backwards
with
range
"
+
i
+
"
"
+
testRanges
[
i
]
+
"
and
point
"
+
j
+
"
"
+
testPoints
[
j
]
)
;
}
}
}
}
function
testExtend
(
endpoints
target
)
{
assert_equals
(
getSelection
(
)
.
rangeCount
endpoints
.
length
/
4
"
Sanity
check
:
rangeCount
must
be
correct
"
)
;
var
node
=
target
[
0
]
;
var
offset
=
target
[
1
]
;
if
(
getSelection
(
)
.
rangeCount
=
=
0
)
{
assert_throws
(
"
INVALID_STATE_ERR
"
function
(
)
{
selection
.
extend
(
node
offset
)
;
}
"
extend
(
)
when
rangeCount
is
0
must
throw
InvalidStateError
"
)
;
return
;
}
assert_equals
(
getSelection
(
)
.
getRangeAt
(
0
)
.
startContainer
endpoints
[
0
]
"
Sanity
check
:
startContainer
must
be
correct
"
)
;
assert_equals
(
getSelection
(
)
.
getRangeAt
(
0
)
.
startOffset
endpoints
[
1
]
"
Sanity
check
:
startOffset
must
be
correct
"
)
;
assert_equals
(
getSelection
(
)
.
getRangeAt
(
0
)
.
endContainer
endpoints
[
2
]
"
Sanity
check
:
endContainer
must
be
correct
"
)
;
assert_equals
(
getSelection
(
)
.
getRangeAt
(
0
)
.
endOffset
endpoints
[
3
]
"
Sanity
check
:
endOffset
must
be
correct
"
)
;
var
anchorNode
=
getSelection
(
)
.
anchorNode
;
var
anchorOffset
=
getSelection
(
)
.
anchorOffset
;
var
focusNode
=
getSelection
(
)
.
focusNode
;
var
focusOffset
=
getSelection
(
)
.
focusOffset
;
if
(
node
.
nodeType
=
=
Node
.
DOCUMENT_TYPE_NODE
)
{
assert_throws
(
"
INVALID_NODE_TYPE_ERR
"
function
(
)
{
selection
.
extend
(
node
offset
)
;
}
"
extend
(
)
to
a
doctype
must
throw
InvalidNodeTypeError
"
)
;
return
;
}
if
(
offset
<
0
|
|
offset
>
getNodeLength
(
node
)
)
{
assert_throws
(
"
INDEX_SIZE_ERR
"
function
(
)
{
selection
.
extend
(
node
offset
)
;
}
"
extend
(
)
to
an
offset
that
'
s
greater
than
node
length
(
"
+
getNodeLength
(
node
)
+
"
)
must
throw
IndexSizeError
"
)
;
return
;
}
var
originalRange
=
getSelection
(
)
.
getRangeAt
(
0
)
;
getSelection
(
)
.
extend
(
node
offset
)
;
if
(
furthestAncestor
(
anchorNode
)
=
=
furthestAncestor
(
node
)
)
{
assert_equals
(
getSelection
(
)
.
anchorNode
anchorNode
"
anchorNode
must
not
change
if
the
node
passed
to
extend
(
)
has
the
same
root
as
the
original
range
"
)
;
assert_equals
(
getSelection
(
)
.
anchorOffset
anchorOffset
"
anchorOffset
must
not
change
if
the
node
passed
to
extend
(
)
has
the
same
root
as
the
original
range
"
)
;
}
else
{
assert_equals
(
getSelection
(
)
.
anchorNode
node
"
anchorNode
must
be
the
node
passed
to
extend
(
)
if
it
has
a
different
root
from
the
original
range
"
)
;
assert_equals
(
getSelection
(
)
.
anchorOffset
offset
"
anchorOffset
must
be
the
offset
passed
to
extend
(
)
if
the
node
has
a
different
root
from
the
original
range
"
)
;
}
assert_equals
(
getSelection
(
)
.
focusNode
node
"
focusNode
must
be
the
node
passed
to
extend
(
)
"
)
;
assert_equals
(
getSelection
(
)
.
focusOffset
offset
"
focusOffset
must
be
the
offset
passed
to
extend
(
)
"
)
;
assert_not_equals
(
getSelection
(
)
.
getRangeAt
(
0
)
originalRange
"
extend
(
)
must
replace
any
existing
range
with
a
new
one
not
mutate
the
existing
one
"
)
;
}
