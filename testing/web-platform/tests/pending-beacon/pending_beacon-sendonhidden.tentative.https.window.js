'
use
strict
'
;
for
(
const
beaconType
of
BeaconTypes
)
{
const
beaconName
=
beaconType
.
name
;
parallelPromiseTest
(
async
t
=
>
{
const
uuid
=
token
(
)
;
const
url
=
generateSetBeaconURL
(
uuid
)
;
const
options
=
{
backgroundTimeout
:
0
}
;
const
helper
=
new
RemoteContextHelper
(
)
;
const
rc1
=
await
helper
.
addWindow
(
null
{
features
:
'
noopener
'
}
)
;
await
rc1
.
executeScript
(
(
beaconName
url
options
)
=
>
{
const
beacon
=
beaconName
=
=
'
PendingGetBeacon
'
?
new
PendingGetBeacon
(
url
options
)
:
new
PendingPostBeacon
(
url
options
)
;
}
[
beaconName
url
options
]
)
;
await
expectBeacon
(
uuid
{
count
:
0
}
)
;
}
{
beaconName
}
:
does
not
send
without
page
navigation
.
)
;
parallelPromiseTest
(
async
t
=
>
{
const
uuid
=
token
(
)
;
const
url
=
generateSetBeaconURL
(
uuid
)
;
const
options
=
{
backgroundTimeout
:
0
}
;
const
helper
=
new
RemoteContextHelper
(
)
;
const
rc1
=
await
helper
.
addWindow
(
null
{
features
:
'
noopener
'
}
)
;
await
rc1
.
executeScript
(
(
beaconName
url
options
)
=
>
{
const
beacon
=
beaconName
=
=
'
PendingGetBeacon
'
?
new
PendingGetBeacon
(
url
options
)
:
new
PendingPostBeacon
(
url
options
)
;
}
[
beaconName
url
options
]
)
;
rc1
.
navigateToNew
(
)
;
await
expectBeacon
(
uuid
{
count
:
1
}
)
;
}
{
beaconName
}
:
sends
on
page
entering
hidden
state
(
w
/
BFCache
)
.
)
;
parallelPromiseTest
(
async
t
=
>
{
const
uuid
=
token
(
)
;
const
url
=
generateSetBeaconURL
(
uuid
)
;
const
options
=
{
backgroundTimeout
:
0
}
;
const
helper
=
new
RemoteContextHelper
(
)
;
const
rc1
=
await
helper
.
addWindow
(
)
;
await
rc1
.
executeScript
(
(
beaconName
url
options
)
=
>
{
const
beacon
=
beaconName
=
=
'
PendingGetBeacon
'
?
new
PendingGetBeacon
(
url
options
)
:
new
PendingPostBeacon
(
url
options
)
;
}
[
beaconName
url
options
]
)
;
rc1
.
navigateToNew
(
)
;
await
expectBeacon
(
uuid
{
count
:
1
}
)
;
}
{
beaconName
}
:
sends
on
page
entering
hidden
state
(
w
/
o
BFCache
)
.
)
;
}
