promise_test
(
async
t
=
>
{
const
estimate
=
await
navigator
.
storage
.
estimate
(
)
assert_equals
(
typeof
estimate
.
usageDetails
'
object
'
)
;
}
'
estimate
(
)
resolves
to
dictionary
with
usageDetails
member
'
)
;
promise_test
(
async
t
=
>
{
const
writeSize
=
1024
*
100
;
const
objectStoreName
=
'
store
'
;
const
dbname
=
self
.
location
.
pathname
;
let
usageAfterWrite
usageBeforeWrite
;
for
(
let
i
=
0
;
i
<
10
;
i
+
+
)
{
indexedDB
.
deleteDatabase
(
dbname
)
;
const
db
=
await
createDB
(
dbname
objectStoreName
t
)
;
let
estimate
=
await
navigator
.
storage
.
estimate
(
)
;
usageBeforeWrite
=
estimate
.
usageDetails
.
indexedDB
|
|
0
;
const
txn
=
db
.
transaction
(
objectStoreName
'
readwrite
'
)
;
const
valueToStore
=
largeValue
(
writeSize
Math
.
random
(
)
*
255
)
;
txn
.
objectStore
(
objectStoreName
)
.
add
(
valueToStore
1
)
;
await
transactionPromise
(
txn
)
;
estimate
=
await
navigator
.
storage
.
estimate
(
)
;
usageAfterWrite
=
estimate
.
usageDetails
.
indexedDB
;
db
.
close
(
)
;
if
(
usageAfterWrite
-
usageBeforeWrite
>
=
writeSize
)
{
break
;
}
}
assert_greater_than_equal
(
usageAfterWrite
-
usageBeforeWrite
writeSize
)
;
}
'
estimate
(
)
usage
details
reflects
increase
in
indexedDB
after
large
'
+
'
value
is
stored
'
)
;
