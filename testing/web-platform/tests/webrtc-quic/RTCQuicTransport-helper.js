'
use
strict
'
;
function
generateCertificate
(
keygenAlgorithm
)
{
return
RTCPeerConnection
.
generateCertificate
(
{
name
:
'
ECDSA
'
namedCurve
:
'
P
-
256
'
.
.
.
keygenAlgorithm
}
)
;
}
function
makeQuicTransport
(
t
iceTransport
certificates
)
{
const
quicTransport
=
new
RTCQuicTransport
(
iceTransport
certificates
)
;
t
.
add_cleanup
(
(
)
=
>
quicTransport
.
stop
(
)
)
;
return
quicTransport
;
}
async
function
makeStandaloneQuicTransport
(
t
)
{
const
certificate
=
await
generateCertificate
(
)
;
return
makeQuicTransport
(
t
makeIceTransport
(
t
)
[
certificate
]
)
;
}
async
function
makeAndStartTwoQuicTransports
(
t
)
{
const
[
localCertificate
remoteCertificate
]
=
await
Promise
.
all
(
[
generateCertificate
(
)
generateCertificate
(
)
]
)
;
const
[
localIceTransport
remoteIceTransport
]
=
makeGatherAndStartTwoIceTransports
(
t
)
;
const
localQuicTransport
=
makeQuicTransport
(
t
localIceTransport
[
localCertificate
]
)
;
const
remoteQuicTransport
=
makeQuicTransport
(
t
remoteIceTransport
[
remoteCertificate
]
)
;
localQuicTransport
.
start
(
remoteQuicTransport
.
getLocalParameters
(
)
)
;
remoteQuicTransport
.
start
(
localQuicTransport
.
getLocalParameters
(
)
)
;
return
[
localQuicTransport
remoteQuicTransport
]
;
}
async
function
makeTwoConnectedQuicTransports
(
t
)
{
function
waitForConnected
(
transport
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
eventHandler
=
t
.
step_func
(
(
)
=
>
{
assert_equals
(
transport
.
state
'
connected
'
)
;
transport
.
removeEventListener
(
'
statechange
'
eventHandler
false
)
;
resolve
(
)
;
}
)
;
transport
.
addEventListener
(
'
statechange
'
eventHandler
false
)
;
}
)
;
}
const
[
localQuicTransport
remoteQuicTransport
]
=
await
makeAndStartTwoQuicTransports
(
t
)
;
await
Promise
.
all
(
[
waitForConnected
(
localQuicTransport
)
waitForConnected
(
remoteQuicTransport
)
]
)
;
return
[
localQuicTransport
remoteQuicTransport
]
;
}
