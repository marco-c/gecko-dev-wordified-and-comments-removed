'
use
strict
'
;
function
makeQuicTransport
(
t
iceTransport
)
{
const
quicTransport
=
new
RTCQuicTransport
(
iceTransport
)
;
t
.
add_cleanup
(
(
)
=
>
quicTransport
.
stop
(
)
)
;
return
quicTransport
;
}
function
makeStandaloneQuicTransport
(
t
)
{
return
makeQuicTransport
(
t
makeIceTransport
(
t
)
)
;
}
function
makeAndStartTwoQuicTransports
(
t
)
{
const
[
localIceTransport
remoteIceTransport
]
=
makeGatherAndStartTwoIceTransports
(
t
)
;
const
localQuicTransport
=
makeQuicTransport
(
t
localIceTransport
)
;
const
remoteQuicTransport
=
makeQuicTransport
(
t
remoteIceTransport
)
;
const
remote_key
=
remoteQuicTransport
.
getKey
(
)
;
localQuicTransport
.
listen
(
remote_key
)
;
remoteQuicTransport
.
connect
(
)
;
return
[
localQuicTransport
remoteQuicTransport
]
;
}
async
function
makeTwoConnectedQuicTransports
(
t
)
{
function
waitForConnected
(
transport
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
eventHandler
=
t
.
step_func
(
(
)
=
>
{
assert_equals
(
transport
.
state
'
connected
'
)
;
transport
.
removeEventListener
(
'
statechange
'
eventHandler
false
)
;
resolve
(
)
;
}
)
;
transport
.
addEventListener
(
'
statechange
'
eventHandler
false
)
;
}
)
;
}
const
[
localQuicTransport
remoteQuicTransport
]
=
await
makeAndStartTwoQuicTransports
(
t
)
;
await
Promise
.
all
(
[
waitForConnected
(
localQuicTransport
)
waitForConnected
(
remoteQuicTransport
)
]
)
;
return
[
localQuicTransport
remoteQuicTransport
]
;
}
