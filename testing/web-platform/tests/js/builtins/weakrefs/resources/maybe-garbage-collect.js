async
function
maybeGarbageCollectAsync
(
)
{
if
(
typeof
TestUtils
!
=
=
'
undefined
'
&
&
TestUtils
.
gc
)
{
await
TestUtils
.
gc
(
)
;
}
else
if
(
self
.
gc
)
{
await
self
.
gc
(
)
;
}
else
if
(
self
.
GCController
)
{
await
GCController
.
collect
(
)
;
}
console
.
warn
(
'
Tests
are
running
without
the
ability
to
do
manual
'
+
'
garbage
collection
.
They
will
still
work
but
'
+
'
coverage
will
be
suboptimal
.
'
)
;
}
async
function
maybeGarbageCollectKeptObjectsAsync
(
)
{
let
trigger
;
if
(
typeof
ClearKeptObjects
=
=
=
'
function
'
)
{
trigger
=
ClearKeptObjects
(
)
;
}
await
maybeGarbageCollectAsync
(
)
;
return
trigger
;
}
async
function
maybeGarbageCollectAndCleanupAsync
(
.
.
.
targets
)
{
let
finalizationRegistry
=
new
FinalizationRegistry
(
(
)
=
>
{
}
)
;
let
length
=
targets
.
length
;
for
(
let
target
of
targets
)
{
finalizationRegistry
.
register
(
target
'
target
'
)
;
target
=
null
;
}
targets
=
null
;
await
'
tick
'
;
await
maybeGarbageCollectKeptObjectsAsync
(
)
;
let
names
=
[
]
;
finalizationRegistry
.
cleanupSome
(
name
=
>
names
.
push
(
name
)
)
;
if
(
names
.
length
!
=
=
length
)
{
throw
maybeGarbageCollectAndCleanupAsync
.
NOT_COLLECTED
;
}
}
maybeGarbageCollectAndCleanupAsync
.
NOT_COLLECTED
=
Symbol
(
'
Object
was
not
collected
'
)
;
function
resolveGarbageCollection
(
error
)
{
if
(
error
&
&
error
!
=
=
maybeGarbageCollectAndCleanupAsync
.
NOT_COLLECTED
)
{
throw
error
;
}
}
