let
error
=
new
Error
(
'
FinalizationRegistryError
'
)
;
let
finalizationRegistry
=
new
FinalizationRegistry
(
function
(
)
{
throw
error
;
}
)
;
setup
(
{
allow_uncaught_exception
:
true
}
)
;
promise_test
(
(
test
)
=
>
{
assert_implements
(
typeof
FinalizationRegistry
.
prototype
.
register
=
=
=
'
function
'
'
FinalizationRegistry
.
prototype
.
register
is
not
implemented
.
'
)
;
return
(
async
(
)
=
>
{
let
resolve
;
let
reject
;
let
deferred
=
new
Promise
(
(
resolverFn
rejecterFn
)
=
>
{
resolve
=
resolverFn
;
reject
=
rejecterFn
;
}
)
;
window
.
onerror
=
test
.
step_func
(
(
message
source
lineno
colno
exception
)
=
>
{
assert_equals
(
exception
error
'
window
.
onerror
received
the
intended
error
object
.
'
)
;
resolve
(
)
;
}
)
;
{
let
target
=
{
}
;
let
heldValue
=
1
;
finalizationRegistry
.
register
(
target
heldValue
)
;
target
=
null
;
}
await
maybeGarbageCollectAsync
(
)
;
test
.
step_timeout
(
(
)
=
>
{
reject
(
)
;
}
5000
)
;
return
deferred
;
}
)
(
)
.
catch
(
resolveGarbageCollection
)
;
}
'
When
called
from
HostCleanupFinalizationRegistry
if
calling
the
callback
throws
an
error
this
will
be
caught
within
the
RunJobs
algorithm
and
reported
to
the
host
.
HTML
does
not
apply
the
RunJobs
algorithm
but
will
also
report
the
error
which
may
call
window
.
onerror
.
'
)
;
