var
cacheName
=
'
urls
-
'
+
self
.
registration
.
scope
;
var
waitUntilPromiseList
=
[
]
;
async
function
getRequestInfos
(
event
)
{
await
Promise
.
all
(
waitUntilPromiseList
)
;
waitUntilPromiseList
=
[
]
;
const
cache
=
await
caches
.
open
(
cacheName
)
;
const
requestList
=
await
cache
.
keys
(
)
;
const
requestInfos
=
[
]
;
for
(
let
i
=
0
;
i
<
requestList
.
length
;
i
+
+
)
{
const
response
=
await
cache
.
match
(
requestList
[
i
]
)
;
const
body
=
await
response
.
json
(
)
;
requestInfos
[
i
]
=
{
url
:
requestList
[
i
]
.
url
resultingClientId
:
body
.
resultingClientId
}
;
}
await
caches
.
delete
(
cacheName
)
;
event
.
data
.
port
.
postMessage
(
{
requestInfos
}
)
;
}
async
function
getClients
(
event
)
{
const
actual_ids
=
event
.
data
.
actual_ids
;
const
result
=
{
}
for
(
let
key
of
Object
.
keys
(
actual_ids
)
)
{
const
id
=
actual_ids
[
key
]
;
const
client
=
await
self
.
clients
.
get
(
id
)
;
if
(
client
=
=
=
undefined
)
result
[
key
]
=
{
found
:
false
}
;
else
result
[
key
]
=
{
found
:
true
url
:
client
.
url
id
:
client
.
id
}
;
}
event
.
data
.
port
.
postMessage
(
{
clients
:
result
}
)
;
}
self
.
addEventListener
(
'
message
'
async
function
(
event
)
{
if
(
event
.
data
.
command
=
=
'
getRequestInfos
'
)
{
event
.
waitUntil
(
getRequestInfos
(
event
)
)
;
return
;
}
if
(
event
.
data
.
command
=
=
'
getClients
'
)
{
event
.
waitUntil
(
getClients
(
event
)
)
;
return
;
}
}
)
;
function
get_query_params
(
url
)
{
var
search
=
(
new
URL
(
url
)
)
.
search
;
if
(
!
search
)
{
return
{
}
;
}
var
ret
=
{
}
;
var
params
=
search
.
substring
(
1
)
.
split
(
'
&
'
)
;
params
.
forEach
(
function
(
param
)
{
var
element
=
param
.
split
(
'
=
'
)
;
ret
[
decodeURIComponent
(
element
[
0
]
)
]
=
decodeURIComponent
(
element
[
1
]
)
;
}
)
;
return
ret
;
}
self
.
addEventListener
(
'
fetch
'
function
(
event
)
{
var
waitUntilPromise
=
caches
.
open
(
cacheName
)
.
then
(
function
(
cache
)
{
const
responseBody
=
{
}
;
responseBody
[
'
resultingClientId
'
]
=
event
.
resultingClientId
;
const
headers
=
new
Headers
(
{
'
Content
-
Type
'
:
'
application
/
json
'
}
)
;
const
response
=
new
Response
(
JSON
.
stringify
(
responseBody
)
{
headers
}
)
;
return
cache
.
put
(
event
.
request
response
)
;
}
)
;
event
.
waitUntil
(
waitUntilPromise
)
;
var
params
=
get_query_params
(
event
.
request
.
url
)
;
if
(
!
params
[
'
sw
'
]
)
{
waitUntilPromiseList
.
push
(
waitUntilPromise
)
;
return
;
}
event
.
respondWith
(
waitUntilPromise
.
then
(
async
(
)
=
>
{
if
(
params
[
'
sw
'
]
=
=
'
gen
'
)
{
return
Response
.
redirect
(
params
[
'
url
'
]
)
;
}
else
if
(
params
[
'
sw
'
]
=
=
'
gen
-
manual
'
)
{
return
new
Response
(
"
"
{
status
:
301
headers
:
{
location
:
params
[
'
url
'
]
}
}
)
;
}
else
if
(
params
[
'
sw
'
]
=
=
'
fetch
'
)
{
return
fetch
(
event
.
request
)
;
}
else
if
(
params
[
'
sw
'
]
=
=
'
fetch
-
url
'
)
{
return
fetch
(
params
[
'
url
'
]
)
;
}
else
if
(
params
[
'
sw
'
]
=
=
'
follow
'
)
{
return
fetch
(
new
Request
(
event
.
request
.
url
{
redirect
:
'
follow
'
}
)
)
;
}
else
if
(
params
[
'
sw
'
]
=
=
'
manual
'
)
{
return
fetch
(
new
Request
(
event
.
request
.
url
{
redirect
:
'
manual
'
}
)
)
;
}
else
if
(
params
[
'
sw
'
]
=
=
'
manualThroughCache
'
)
{
const
url
=
event
.
request
.
url
;
await
caches
.
delete
(
url
)
const
cache
=
await
self
.
caches
.
open
(
url
)
;
const
response
=
await
fetch
(
new
Request
(
url
{
redirect
:
'
manual
'
}
)
)
;
await
cache
.
put
(
event
.
request
response
)
;
return
cache
.
match
(
url
)
;
}
}
)
)
;
}
)
;
