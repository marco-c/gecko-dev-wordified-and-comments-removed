#
-
*
-
coding
:
utf
-
8
-
*
-
"
"
"
rfc3986
.
misc
~
~
~
~
~
~
~
~
~
~
~
~
This
module
contains
important
constants
patterns
and
compiled
regular
expressions
for
parsing
and
validating
URIs
and
their
components
.
"
"
"
import
re
URI_COMPONENTS
=
[
'
scheme
'
'
authority
'
'
path
'
'
query
'
'
fragment
'
]
important_characters
=
{
    
'
generic_delimiters
'
:
"
:
/
?
#
[
]
"
    
'
sub_delimiters
'
:
"
!
&
'
(
)
*
+
;
=
"
    
'
re_sub_delimiters
'
:
"
!
&
'
(
)
\
*
+
;
=
"
    
'
unreserved_chars
'
:
(
'
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
'
                         
'
0123456789
.
_
~
-
'
)
    
'
re_unreserved
'
:
'
A
-
Za
-
z0
-
9
.
_
~
\
-
'
    
}
GENERIC_DELIMITERS
=
set
(
important_characters
[
'
generic_delimiters
'
]
)
SUB_DELIMITERS
=
set
(
important_characters
[
'
sub_delimiters
'
]
)
RESERVED_CHARS
=
GENERIC_DELIMITERS
.
union
(
SUB_DELIMITERS
)
UNRESERVED_CHARS
=
set
(
important_characters
[
'
unreserved_chars
'
]
)
NON_PCT_ENCODED
=
RESERVED_CHARS
.
union
(
UNRESERVED_CHARS
)
.
union
(
'
%
'
)
component_pattern_dict
=
{
    
'
scheme
'
:
'
[
^
:
/
?
#
]
+
'
    
'
authority
'
:
'
[
^
/
?
#
]
*
'
    
'
path
'
:
'
[
^
?
#
]
*
'
    
'
query
'
:
'
[
^
#
]
*
'
    
'
fragment
'
:
'
.
*
'
    
}
expression
=
(
'
(
?
:
(
?
P
<
scheme
>
{
scheme
}
)
:
)
?
(
?
:
/
/
(
?
P
<
authority
>
{
authority
}
)
)
?
'
              
'
(
?
P
<
path
>
{
path
}
)
(
?
:
\
?
(
?
P
<
query
>
{
query
}
)
)
?
'
              
'
(
?
:
#
(
?
P
<
fragment
>
{
fragment
}
)
)
?
'
              
)
.
format
(
*
*
component_pattern_dict
)
URI_MATCHER
=
re
.
compile
(
expression
)
reg_name
=
'
(
(
{
0
}
)
*
|
[
{
1
}
]
*
)
'
.
format
(
    
'
%
[
0
-
9A
-
Fa
-
f
]
{
2
}
'
    
important_characters
[
'
re_sub_delimiters
'
]
+
    
important_characters
[
'
re_unreserved
'
]
    
)
ipv4
=
'
(
\
d
{
1
3
}
.
)
{
3
}
\
d
{
1
3
}
'
hexdig
=
'
[
0
-
9A
-
Fa
-
f
]
{
1
4
}
'
ls32
=
'
(
{
hex
}
:
{
hex
}
|
{
ipv4
}
)
'
.
format
(
hex
=
hexdig
ipv4
=
ipv4
)
subs
=
{
'
hex
'
:
hexdig
'
ls32
'
:
ls32
}
variations
=
[
    
'
(
%
(
hex
)
s
:
)
{
6
}
%
(
ls32
)
s
'
%
subs
    
'
:
:
(
%
(
hex
)
s
:
)
{
5
}
%
(
ls32
)
s
'
%
subs
    
'
(
%
(
hex
)
s
)
?
:
:
(
%
(
hex
)
s
:
)
{
4
}
%
(
ls32
)
s
'
%
subs
    
'
(
(
%
(
hex
)
s
:
)
?
%
(
hex
)
s
)
?
:
:
(
%
(
hex
)
s
:
)
{
3
}
%
(
ls32
)
s
'
%
subs
    
'
(
(
%
(
hex
)
s
:
)
{
0
2
}
%
(
hex
)
s
)
?
:
:
(
%
(
hex
)
s
:
)
{
2
}
%
(
ls32
)
s
'
%
subs
    
'
(
(
%
(
hex
)
s
:
)
{
0
3
}
%
(
hex
)
s
)
?
:
:
%
(
hex
)
s
:
%
(
ls32
)
s
'
%
subs
    
'
(
(
%
(
hex
)
s
:
)
{
0
4
}
%
(
hex
)
s
)
?
:
:
%
(
ls32
)
s
'
%
subs
    
'
(
(
%
(
hex
)
s
:
)
{
0
5
}
%
(
hex
)
s
)
?
:
:
%
(
hex
)
s
'
%
subs
    
'
(
(
%
(
hex
)
s
:
)
{
0
6
}
%
(
hex
)
s
)
?
:
:
'
%
subs
    
]
ipv6
=
'
(
(
{
0
}
)
|
(
{
1
}
)
|
(
{
2
}
)
|
(
{
3
}
)
|
(
{
4
}
)
|
(
{
5
}
)
|
(
{
6
}
)
|
(
{
7
}
)
)
'
.
format
(
*
variations
)
ipv_future
=
'
v
[
0
-
9A
-
Fa
-
f
]
+
.
[
%
s
]
+
'
%
(
    
important_characters
[
'
re_unreserved
'
]
+
    
important_characters
[
'
re_sub_delimiters
'
]
+
    
'
:
'
)
ip_literal
=
'
\
[
(
{
0
}
|
{
1
}
)
\
]
'
.
format
(
ipv6
ipv_future
)
HOST_PATTERN
=
'
(
{
0
}
|
{
1
}
|
{
2
}
)
'
.
format
(
reg_name
ipv4
ip_literal
)
SUBAUTHORITY_MATCHER
=
re
.
compile
(
(
    
'
^
(
?
:
(
?
P
<
userinfo
>
[
A
-
Za
-
z0
-
9_
.
~
\
-
%
:
]
+
)
)
?
'
    
'
(
?
P
<
host
>
{
0
}
?
)
'
    
'
:
?
(
?
P
<
port
>
\
d
+
)
?
'
    
)
.
format
(
HOST_PATTERN
)
)
IPv4_MATCHER
=
re
.
compile
(
'
^
'
+
ipv4
+
'
'
)
pct_encoded
=
'
%
[
A
-
Fa
-
f0
-
9
]
{
2
}
'
pchar
=
(
'
(
[
'
+
important_characters
[
'
re_unreserved
'
]
         
+
important_characters
[
'
re_sub_delimiters
'
]
         
+
'
:
]
|
%
s
)
'
%
pct_encoded
)
segments
=
{
    
'
segment
'
:
pchar
+
'
*
'
    
'
segment
-
nz
'
:
pchar
+
'
+
'
    
'
segment
-
nz
-
nc
'
:
pchar
.
replace
(
'
:
'
'
'
)
+
'
+
'
    
}
path_empty
=
'
^
'
path_rootless
=
'
%
(
segment
-
nz
)
s
(
/
%
(
segment
)
s
)
*
'
%
segments
path_noscheme
=
'
%
(
segment
-
nz
-
nc
)
s
(
/
%
(
segment
)
s
)
*
'
%
segments
path_absolute
=
'
/
(
%
s
)
?
'
%
path_rootless
path_abempty
=
'
(
/
%
(
segment
)
s
)
*
'
%
segments
PATH_MATCHER
=
re
.
compile
(
'
^
(
%
s
|
%
s
|
%
s
|
%
s
|
%
s
)
'
%
(
    
path_abempty
path_absolute
path_noscheme
path_rootless
path_empty
    
)
)
QUERY_MATCHER
=
re
.
compile
(
    
'
^
(
[
/
?
:
'
+
important_characters
[
'
re_unreserved
'
]
    
+
important_characters
[
'
re_sub_delimiters
'
]
    
+
'
]
|
%
s
)
*
'
%
pct_encoded
)
FRAGMENT_MATCHER
=
QUERY_MATCHER
SCHEME_MATCHER
=
re
.
compile
(
'
^
[
A
-
Za
-
z
]
[
A
-
Za
-
z0
-
9
+
.
\
-
]
*
'
)
relative_part
=
'
(
/
/
%
s
%
s
|
%
s
|
%
s
|
%
s
)
'
%
(
    
component_pattern_dict
[
'
authority
'
]
path_abempty
path_absolute
    
path_noscheme
path_empty
    
)
RELATIVE_REF_MATCHER
=
re
.
compile
(
'
^
%
s
(
\
?
%
s
)
?
(
#
%
s
)
?
'
%
(
    
relative_part
QUERY_MATCHER
.
pattern
FRAGMENT_MATCHER
.
pattern
    
)
)
hier_part
=
'
(
/
/
%
s
%
s
|
%
s
|
%
s
|
%
s
)
'
%
(
    
component_pattern_dict
[
'
authority
'
]
path_abempty
path_absolute
    
path_rootless
path_empty
    
)
ABSOLUTE_URI_MATCHER
=
re
.
compile
(
'
^
%
s
:
%
s
(
\
?
%
s
)
?
'
%
(
    
component_pattern_dict
[
'
scheme
'
]
hier_part
QUERY_MATCHER
.
pattern
[
1
:
-
1
]
    
)
)
def
merge_paths
(
base_uri
relative_path
)
:
    
"
"
"
Merge
a
base
URI
'
s
path
with
a
relative
URI
'
s
path
.
"
"
"
    
if
base_uri
.
path
is
None
and
base_uri
.
authority
is
not
None
:
        
return
'
/
'
+
relative_path
    
else
:
        
path
=
base_uri
.
path
or
'
'
        
index
=
path
.
rfind
(
'
/
'
)
        
return
path
[
:
index
]
+
'
/
'
+
relative_path
