function
doTest
(
context
should
options
)
{
let
merger
=
new
ChannelMergerNode
(
context
{
numberOfInputs
:
context
.
destination
.
channelCount
}
)
;
merger
.
connect
(
context
.
destination
)
;
let
src
=
null
;
if
(
options
.
sourceNodeName
!
=
=
'
none
'
)
{
src
=
new
window
[
options
.
sourceNodeName
|
|
'
OscillatorNode
'
]
(
context
)
;
}
let
kRateNode
=
new
window
[
options
.
nodeName
]
(
context
options
.
nodeOptions
)
;
let
aRateNode
=
new
window
[
options
.
nodeName
]
(
context
options
.
nodeOptions
)
;
let
inverter
=
new
GainNode
(
context
{
gain
:
-
1
}
)
;
options
.
rateSettings
.
forEach
(
setting
=
>
{
kRateNode
[
setting
.
name
]
.
automationRate
=
setting
.
value
;
should
(
kRateNode
[
setting
.
name
]
.
automationRate
{
options
.
prefix
}
:
Setting
{
setting
.
name
}
.
automationRate
to
"
{
setting
.
value
}
"
)
.
beEqualTo
(
setting
.
value
)
;
}
)
;
options
.
automations
.
forEach
(
param
=
>
{
param
.
methods
.
forEach
(
method
=
>
{
let
message
=
{
param
.
name
}
.
{
method
.
name
}
(
{
method
.
options
}
)
should
(
(
)
=
>
{
kRateNode
[
param
.
name
]
[
method
.
name
]
(
.
.
.
method
.
options
)
;
}
options
.
prefix
+
'
:
k
-
rate
node
:
'
+
message
)
.
notThrow
(
)
;
}
)
;
}
)
;
options
.
automations
.
forEach
(
param
=
>
{
param
.
methods
.
forEach
(
method
=
>
{
let
message
=
{
param
.
name
}
.
{
method
.
name
}
(
{
method
.
options
}
)
should
(
(
)
=
>
{
aRateNode
[
param
.
name
]
[
method
.
name
]
(
.
.
.
method
.
options
)
;
}
options
.
prefix
+
'
:
a
-
rate
node
:
'
+
message
)
.
notThrow
(
)
;
}
)
;
}
)
;
if
(
src
)
{
src
.
connect
(
kRateNode
)
;
src
.
connect
(
aRateNode
)
;
}
kRateNode
.
connect
(
merger
0
0
)
;
aRateNode
.
connect
(
merger
0
1
)
;
kRateNode
.
connect
(
merger
0
2
)
;
aRateNode
.
connect
(
inverter
)
.
connect
(
merger
0
2
)
;
if
(
src
)
{
src
.
start
(
)
;
}
else
{
kRateNode
.
start
(
)
;
aRateNode
.
start
(
)
;
}
return
context
.
startRendering
(
)
.
then
(
renderedBuffer
=
>
{
let
kRateOutput
=
renderedBuffer
.
getChannelData
(
0
)
;
let
aRateOutput
=
renderedBuffer
.
getChannelData
(
1
)
;
let
diff
=
renderedBuffer
.
getChannelData
(
2
)
;
should
(
kRateOutput
{
options
.
prefix
}
:
Output
of
k
-
rate
{
options
.
nodeName
}
)
.
beEqualToArray
(
kRateOutput
)
;
should
(
aRateOutput
{
options
.
prefix
}
:
Output
of
a
-
rate
{
options
.
nodeName
}
)
.
beEqualToArray
(
aRateOutput
)
;
should
(
diff
{
options
.
prefix
}
:
Difference
between
a
-
rate
and
k
-
rate
{
options
.
nodeName
}
)
.
notBeConstantValueOf
(
0
)
;
if
(
options
.
verifyPieceWiseConstant
)
{
for
(
let
k
=
0
;
k
<
kRateOutput
.
length
;
k
+
=
128
)
{
should
(
kRateOutput
.
slice
(
k
k
+
128
)
{
options
.
prefix
}
k
-
rate
output
[
{
k
}
:
{
k
+
127
}
]
)
.
beConstantValueOf
(
kRateOutput
[
k
]
)
;
}
}
}
)
;
}
function
doTest_W3TH
(
context
options
)
{
const
merger
=
new
ChannelMergerNode
(
context
{
numberOfInputs
:
context
.
destination
.
channelCount
}
)
;
merger
.
connect
(
context
.
destination
)
;
let
src
=
null
;
if
(
options
.
sourceNodeName
!
=
=
'
none
'
)
{
src
=
new
window
[
options
.
sourceNodeName
|
|
'
OscillatorNode
'
]
(
context
)
;
}
const
kRateNode
=
new
window
[
options
.
nodeName
]
(
context
options
.
nodeOptions
)
;
const
aRateNode
=
new
window
[
options
.
nodeName
]
(
context
options
.
nodeOptions
)
;
const
inverter
=
new
GainNode
(
context
{
gain
:
-
1
}
)
;
options
.
rateSettings
.
forEach
(
setting
=
>
{
kRateNode
[
setting
.
name
]
.
automationRate
=
setting
.
value
;
assert_equals
(
kRateNode
[
setting
.
name
]
.
automationRate
setting
.
value
{
options
.
prefix
}
:
Setting
{
setting
.
name
}
.
automationRate
+
to
"
{
setting
.
value
}
"
)
;
}
)
;
options
.
automations
.
forEach
(
param
=
>
{
param
.
methods
.
forEach
(
method
=
>
{
const
message
=
{
param
.
name
}
.
{
method
.
name
}
(
{
method
.
options
}
)
;
try
{
kRateNode
[
param
.
name
]
[
method
.
name
]
(
.
.
.
method
.
options
)
;
}
catch
(
e
)
{
assert_unreached
(
{
options
.
prefix
}
:
k
-
rate
node
:
{
message
}
threw
:
{
e
.
message
}
)
;
}
}
)
;
}
)
;
options
.
automations
.
forEach
(
param
=
>
{
param
.
methods
.
forEach
(
method
=
>
{
const
message
=
{
param
.
name
}
.
{
method
.
name
}
(
{
method
.
options
}
)
;
try
{
aRateNode
[
param
.
name
]
[
method
.
name
]
(
.
.
.
method
.
options
)
;
}
catch
(
e
)
{
assert_unreached
(
{
options
.
prefix
}
:
a
-
rate
node
:
{
message
}
threw
:
{
e
.
message
}
)
;
}
}
)
;
}
)
;
if
(
src
)
{
src
.
connect
(
kRateNode
)
;
src
.
connect
(
aRateNode
)
;
}
kRateNode
.
connect
(
merger
0
0
)
;
aRateNode
.
connect
(
merger
0
1
)
;
kRateNode
.
connect
(
merger
0
2
)
;
aRateNode
.
connect
(
inverter
)
.
connect
(
merger
0
2
)
;
if
(
src
)
{
src
.
start
(
)
;
}
else
{
kRateNode
.
start
(
)
;
aRateNode
.
start
(
)
;
}
return
context
.
startRendering
(
)
.
then
(
renderedBuffer
=
>
{
const
kRateOutput
=
renderedBuffer
.
getChannelData
(
0
)
;
const
aRateOutput
=
renderedBuffer
.
getChannelData
(
1
)
;
const
diff
=
renderedBuffer
.
getChannelData
(
2
)
;
assert_true
(
kRateOutput
instanceof
Float32Array
{
options
.
prefix
}
:
Output
of
k
-
rate
+
{
options
.
nodeName
}
is
Float32Array
)
;
assert_true
(
aRateOutput
instanceof
Float32Array
{
options
.
prefix
}
:
Output
of
a
-
rate
+
{
options
.
nodeName
}
is
Float32Array
)
;
let
allZero
=
true
;
for
(
let
i
=
0
;
i
<
diff
.
length
;
+
+
i
)
{
if
(
diff
[
i
]
!
=
=
0
)
{
allZero
=
false
;
break
;
}
}
assert_false
(
allZero
{
options
.
prefix
}
:
Difference
between
a
-
rate
and
k
-
rate
+
{
options
.
nodeName
}
must
not
be
identically
0
)
;
if
(
options
.
verifyPieceWiseConstant
)
{
for
(
let
k
=
0
;
k
<
kRateOutput
.
length
;
k
+
=
128
)
{
const
end
=
Math
.
min
(
k
+
128
kRateOutput
.
length
)
;
const
v0
=
kRateOutput
[
k
]
;
for
(
let
i
=
k
+
1
;
i
<
end
;
+
+
i
)
{
assert_equals
(
kRateOutput
[
i
]
v0
{
options
.
prefix
}
k
-
rate
output
[
{
k
}
:
{
end
-
1
}
]
+
should
be
piecewise
constant
)
;
}
}
}
}
)
;
}
