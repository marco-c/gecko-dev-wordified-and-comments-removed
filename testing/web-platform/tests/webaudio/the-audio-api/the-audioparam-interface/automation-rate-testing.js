function
doTest
(
context
should
options
)
{
let
merger
=
new
ChannelMergerNode
(
context
{
numberOfInputs
:
context
.
destination
.
numberOfChannels
}
)
;
merger
.
connect
(
context
.
destination
)
;
let
src
=
null
;
if
(
options
.
sourceNodeName
!
=
=
'
none
'
)
{
src
=
new
window
[
options
.
sourceNodeName
|
|
'
OscillatorNode
'
]
(
context
)
;
}
let
kRateNode
=
new
window
[
options
.
nodeName
]
(
context
options
.
nodeOptions
)
;
let
aRateNode
=
new
window
[
options
.
nodeName
]
(
context
options
.
nodeOptions
)
;
let
inverter
=
new
GainNode
(
context
{
gain
:
-
1
}
)
;
options
.
rateSettings
.
forEach
(
setting
=
>
{
kRateNode
[
setting
.
name
]
.
automationRate
=
setting
.
value
;
should
(
kRateNode
[
setting
.
name
]
.
automationRate
{
options
.
prefix
}
:
Setting
{
setting
.
name
}
.
automationRate
to
"
{
setting
.
value
}
"
)
.
beEqualTo
(
setting
.
value
)
;
}
)
;
options
.
automations
.
forEach
(
param
=
>
{
param
.
methods
.
forEach
(
method
=
>
{
let
message
=
{
param
.
name
}
.
{
method
.
name
}
(
{
method
.
options
}
)
should
(
(
)
=
>
{
kRateNode
[
param
.
name
]
[
method
.
name
]
(
.
.
.
method
.
options
)
;
}
options
.
prefix
+
'
:
k
-
rate
node
:
'
+
message
)
.
notThrow
(
)
;
}
)
;
}
)
;
options
.
automations
.
forEach
(
param
=
>
{
param
.
methods
.
forEach
(
method
=
>
{
let
message
=
{
param
.
name
}
.
{
method
.
name
}
(
{
method
.
options
}
)
should
(
(
)
=
>
{
aRateNode
[
param
.
name
]
[
method
.
name
]
(
.
.
.
method
.
options
)
;
}
options
.
prefix
+
'
:
a
-
rate
node
:
'
+
message
)
.
notThrow
(
)
;
}
)
;
}
)
;
if
(
src
)
{
src
.
connect
(
kRateNode
)
;
src
.
connect
(
aRateNode
)
;
}
kRateNode
.
connect
(
merger
0
0
)
;
aRateNode
.
connect
(
merger
0
1
)
;
kRateNode
.
connect
(
merger
0
2
)
;
aRateNode
.
connect
(
inverter
)
.
connect
(
merger
0
2
)
;
if
(
src
)
{
src
.
start
(
)
;
}
else
{
kRateNode
.
start
(
)
;
aRateNode
.
start
(
)
;
}
return
context
.
startRendering
(
)
.
then
(
renderedBuffer
=
>
{
let
kRateOutput
=
renderedBuffer
.
getChannelData
(
0
)
;
let
aRateOutput
=
renderedBuffer
.
getChannelData
(
1
)
;
let
diff
=
renderedBuffer
.
getChannelData
(
2
)
;
should
(
kRateOutput
{
options
.
prefix
}
:
Output
of
k
-
rate
{
options
.
nodeName
}
)
.
beEqualToArray
(
kRateOutput
)
;
should
(
aRateOutput
{
options
.
prefix
}
:
Output
of
a
-
rate
{
options
.
nodeName
}
)
.
beEqualToArray
(
aRateOutput
)
;
should
(
diff
{
options
.
prefix
}
:
Difference
between
a
-
rate
and
k
-
rate
{
options
.
nodeName
}
)
.
notBeConstantValueOf
(
0
)
;
if
(
options
.
verifyPieceWiseConstant
)
{
for
(
let
k
=
0
;
k
<
kRateOutput
.
length
;
k
+
=
128
)
{
should
(
kRateOutput
.
slice
(
k
k
+
128
)
{
options
.
prefix
}
k
-
rate
output
[
{
k
}
:
{
k
+
127
}
]
)
.
beConstantValueOf
(
kRateOutput
[
k
]
)
;
}
}
}
)
;
}
