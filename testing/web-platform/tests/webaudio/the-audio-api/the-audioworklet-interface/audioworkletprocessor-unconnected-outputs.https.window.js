'
use
strict
'
;
const
TestValue
=
0
.
5
;
const
WorkletNodeOptions
=
{
processorOptions
:
{
testValue
:
TestValue
}
numberOfInputs
:
0
numberOfOutputs
:
4
}
;
const
processorCode
=
(
)
=
>
{
class
OutputTestProcessor
extends
AudioWorkletProcessor
{
constructor
(
options
)
{
super
(
options
)
;
this
.
testValue
=
options
.
processorOptions
.
testValue
;
}
process
(
inputs
outputs
)
{
const
output
=
outputs
[
1
]
;
for
(
const
channel
of
output
)
{
channel
.
fill
(
this
.
testValue
)
;
}
this
.
port
.
postMessage
(
{
outputs
}
)
;
return
false
;
}
}
registerProcessor
(
'
output
-
test
-
processor
'
OutputTestProcessor
)
;
class
ParamTestProcessor
extends
AudioWorkletProcessor
{
static
get
parameterDescriptors
(
)
{
return
[
{
name
:
'
testParam
'
defaultValue
:
0
.
0
}
]
;
}
process
(
inputs
outputs
params
)
{
this
.
port
.
postMessage
(
{
paramValues
:
params
.
testParam
}
)
;
return
false
;
}
}
registerProcessor
(
'
param
-
test
-
processor
'
ParamTestProcessor
)
;
}
const
initializeAudioContext
=
async
(
)
=
>
{
const
context
=
new
AudioContext
(
)
;
const
moduleString
=
(
{
processorCode
.
toString
(
)
}
)
(
)
;
;
const
blobUrl
=
window
.
URL
.
createObjectURL
(
new
Blob
(
[
moduleString
]
{
type
:
'
text
/
javascript
'
}
)
)
;
await
context
.
audioWorklet
.
addModule
(
blobUrl
)
;
context
.
suspend
(
)
;
return
context
;
}
;
promise_test
(
async
(
)
=
>
{
const
context
=
await
initializeAudioContext
(
)
;
const
outputTester
=
new
AudioWorkletNode
(
context
'
output
-
test
-
processor
'
WorkletNodeOptions
)
;
const
testGain
=
new
GainNode
(
context
)
;
outputTester
.
connect
(
testGain
1
)
;
outputTester
.
connect
(
context
.
destination
3
)
;
return
new
Promise
(
resolve
=
>
{
outputTester
.
port
.
onmessage
=
resolve
;
context
.
resume
(
)
;
}
)
.
then
(
event
=
>
{
const
outputs
=
event
.
data
.
outputs
;
assert_equals
(
outputs
.
length
WorkletNodeOptions
.
numberOfOutputs
)
;
for
(
const
output
of
outputs
)
{
assert_equals
(
output
.
length
1
)
;
for
(
const
channel
of
output
)
{
assert_true
(
channel
.
length
>
0
)
;
}
}
context
.
close
(
)
;
}
)
;
}
'
Test
if
unconnected
outputs
provides
a
non
-
zero
length
array
for
channels
'
)
;
promise_test
(
async
(
)
=
>
{
const
context
=
await
initializeAudioContext
(
)
;
const
outputTester
=
new
AudioWorkletNode
(
context
'
output
-
test
-
processor
'
WorkletNodeOptions
)
;
const
paramTester
=
new
AudioWorkletNode
(
context
'
param
-
test
-
processor
'
)
;
outputTester
.
connect
(
paramTester
.
parameters
.
get
(
'
testParam
'
)
1
)
;
outputTester
.
connect
(
context
.
destination
)
;
return
new
Promise
(
resolve
=
>
{
paramTester
.
port
.
onmessage
=
resolve
;
context
.
resume
(
)
;
}
)
.
then
(
event
=
>
{
const
actualValues
=
event
.
data
.
paramValues
;
const
expectedValues
=
(
new
Array
(
actualValues
.
length
)
)
.
fill
(
TestValue
)
;
assert_true
(
actualValues
.
length
>
0
)
;
assert_array_equals
(
actualValues
expectedValues
)
;
context
.
close
(
)
;
}
)
;
}
'
Test
if
outputs
connected
to
AudioParam
provides
a
non
-
zero
length
array
'
+
'
for
channels
'
)
;
