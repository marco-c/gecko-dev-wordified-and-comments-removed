let
StereoPannerTest
=
(
function
(
)
{
let
PI_OVER_TWO
=
Math
.
PI
*
0
.
5
;
let
gSampleRate
=
44100
;
let
gTimeStep
=
0
.
001
;
let
gNodesToCreate
=
100
;
let
gRenderLength
=
gTimeStep
*
(
gNodesToCreate
+
1
)
+
gSampleRate
;
function
getChannelGain
(
pan
numberOfChannels
)
{
pan
=
Math
.
min
(
Math
.
max
(
pan
-
1
)
1
)
;
let
gainL
gainR
;
if
(
numberOfChannels
=
=
1
)
{
let
panRadian
=
(
pan
*
0
.
5
+
0
.
5
)
*
PI_OVER_TWO
;
gainL
=
Math
.
cos
(
panRadian
)
;
gainR
=
Math
.
sin
(
panRadian
)
;
}
else
{
let
panRadian
=
(
pan
<
=
0
?
pan
+
1
:
pan
)
*
PI_OVER_TWO
;
if
(
pan
<
=
0
)
{
gainL
=
1
+
Math
.
cos
(
panRadian
)
;
gainR
=
Math
.
sin
(
panRadian
)
;
}
else
{
gainL
=
Math
.
cos
(
panRadian
)
;
gainR
=
1
+
Math
.
sin
(
panRadian
)
;
}
}
return
{
gainL
:
gainL
gainR
:
gainR
}
;
}
function
Test
(
should
options
)
{
this
.
success
=
true
;
this
.
should
=
should
;
this
.
context
=
null
;
this
.
prefix
=
options
.
prefix
;
this
.
numberOfInputChannels
=
(
options
.
numberOfInputChannels
|
|
1
)
;
switch
(
this
.
numberOfInputChannels
)
{
case
1
:
this
.
description
=
'
Test
for
mono
input
'
;
break
;
case
2
:
this
.
description
=
'
Test
for
stereo
input
'
;
break
;
}
this
.
onsets
=
[
]
;
this
.
panPositions
=
[
]
;
this
.
errors
=
[
]
;
this
.
impulseIndex
=
0
;
this
.
maxAllowedError
=
1
.
3e
-
6
;
this
.
maxErrorL
=
0
;
this
.
maxErrorR
=
0
;
this
.
maxErrorIndexL
=
0
;
this
.
maxErrorIndexR
=
0
;
this
.
panLimit
=
1
.
0625
;
}
Test
.
prototype
.
init
=
function
(
)
{
this
.
context
=
new
OfflineAudioContext
(
2
gRenderLength
gSampleRate
)
;
}
;
Test
.
prototype
.
prepare
=
function
(
)
{
let
impulse
;
let
impulseLength
=
Math
.
round
(
gTimeStep
*
gSampleRate
)
;
let
sources
=
[
]
;
let
panners
=
[
]
;
let
panStep
=
(
2
*
this
.
panLimit
)
/
(
gNodesToCreate
-
1
)
;
if
(
this
.
numberOfInputChannels
=
=
=
1
)
{
impulse
=
createImpulseBuffer
(
this
.
context
impulseLength
)
;
}
else
{
impulse
=
createStereoImpulseBuffer
(
this
.
context
impulseLength
)
;
}
for
(
let
i
=
0
;
i
<
gNodesToCreate
;
i
+
+
)
{
sources
[
i
]
=
this
.
context
.
createBufferSource
(
)
;
panners
[
i
]
=
this
.
context
.
createStereoPanner
(
)
;
sources
[
i
]
.
connect
(
panners
[
i
]
)
;
panners
[
i
]
.
connect
(
this
.
context
.
destination
)
;
sources
[
i
]
.
buffer
=
impulse
;
panners
[
i
]
.
pan
.
value
=
this
.
panPositions
[
i
]
=
panStep
*
i
-
this
.
panLimit
;
this
.
onsets
[
i
]
=
gTimeStep
*
i
;
sources
[
i
]
.
start
(
this
.
onsets
[
i
]
)
;
}
}
;
Test
.
prototype
.
verify
=
function
(
)
{
let
chanL
=
this
.
renderedBufferL
;
let
chanR
=
this
.
renderedBufferR
;
for
(
let
i
=
0
;
i
<
chanL
.
length
;
i
+
+
)
{
if
(
chanL
[
i
]
!
=
=
0
|
|
chanR
[
i
]
!
=
=
0
)
{
let
expected
=
getChannelGain
(
this
.
panPositions
[
this
.
impulseIndex
]
this
.
numberOfInputChannels
)
;
let
errorL
=
Math
.
abs
(
chanL
[
i
]
-
expected
.
gainL
)
;
let
errorR
=
Math
.
abs
(
chanR
[
i
]
-
expected
.
gainR
)
;
if
(
errorL
>
this
.
maxErrorL
)
{
this
.
maxErrorL
=
errorL
;
this
.
maxErrorIndexL
=
this
.
impulseIndex
;
}
if
(
errorR
>
this
.
maxErrorR
)
{
this
.
maxErrorR
=
errorR
;
this
.
maxErrorIndexR
=
this
.
impulseIndex
;
}
let
expectedOffset
=
timeToSampleFrame
(
this
.
onsets
[
this
.
impulseIndex
]
gSampleRate
)
;
if
(
i
!
=
expectedOffset
)
{
this
.
errors
.
push
(
{
actual
:
i
expected
:
expectedOffset
}
)
;
}
this
.
impulseIndex
+
+
;
}
}
}
;
Test
.
prototype
.
showResult
=
function
(
)
{
this
.
should
(
this
.
impulseIndex
this
.
prefix
+
'
Number
of
impulses
found
'
)
.
beEqualTo
(
gNodesToCreate
)
;
this
.
should
(
this
.
errors
.
length
this
.
prefix
+
'
Number
of
impulse
at
the
wrong
offset
'
)
.
beEqualTo
(
0
)
;
this
.
should
(
this
.
maxErrorL
this
.
prefix
+
'
Left
channel
error
magnitude
'
)
.
beLessThanOrEqualTo
(
this
.
maxAllowedError
)
;
this
.
should
(
this
.
maxErrorR
this
.
prefix
+
'
Right
channel
error
magnitude
'
)
.
beLessThanOrEqualTo
(
this
.
maxAllowedError
)
;
}
;
Test
.
prototype
.
run
=
function
(
)
{
this
.
init
(
)
;
this
.
prepare
(
)
;
return
this
.
context
.
startRendering
(
)
.
then
(
renderedBuffer
=
>
{
this
.
renderedBufferL
=
renderedBuffer
.
getChannelData
(
0
)
;
this
.
renderedBufferR
=
renderedBuffer
.
getChannelData
(
1
)
;
this
.
verify
(
)
;
this
.
showResult
(
)
;
}
)
;
}
;
return
{
create
:
function
(
should
options
)
{
return
new
Test
(
should
options
)
;
}
}
;
}
)
(
)
;
