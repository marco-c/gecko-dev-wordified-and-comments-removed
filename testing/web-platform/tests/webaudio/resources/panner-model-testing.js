let
sampleRate
=
32768
;
let
numberOfChannels
=
1
;
let
timeStep
=
Math
.
floor
(
0
.
001
*
sampleRate
)
/
sampleRate
;
let
pulseLengthFrames
=
Math
.
round
(
timeStep
*
sampleRate
)
;
let
nodesToCreate
=
100
;
let
renderLengthSeconds
=
timeStep
*
(
nodesToCreate
+
1
)
;
let
context
;
let
impulse
;
let
bufferSource
;
let
panner
;
let
position
;
let
time
;
let
renderedBuffer
;
let
renderedLeft
;
let
renderedRight
;
function
createGraph
(
context
nodeCount
positionSetter
)
{
bufferSource
=
new
Array
(
nodeCount
)
;
panner
=
new
Array
(
nodeCount
)
;
position
=
new
Array
(
nodeCount
)
;
time
=
new
Array
(
nodeCount
)
;
let
angleStep
=
Math
.
PI
/
(
nodeCount
-
1
)
;
if
(
numberOfChannels
=
=
2
)
{
impulse
=
createStereoImpulseBuffer
(
context
pulseLengthFrames
)
;
}
else
impulse
=
createImpulseBuffer
(
context
pulseLengthFrames
)
;
for
(
let
k
=
0
;
k
<
nodeCount
;
+
+
k
)
{
bufferSource
[
k
]
=
context
.
createBufferSource
(
)
;
bufferSource
[
k
]
.
buffer
=
impulse
;
panner
[
k
]
=
context
.
createPanner
(
)
;
panner
[
k
]
.
panningModel
=
'
equalpower
'
;
panner
[
k
]
.
distanceModel
=
'
linear
'
;
let
angle
=
angleStep
*
k
;
position
[
k
]
=
{
angle
:
angle
x
:
Math
.
cos
(
angle
)
z
:
Math
.
sin
(
angle
)
}
;
positionSetter
(
panner
[
k
]
position
[
k
]
.
x
0
position
[
k
]
.
z
)
;
bufferSource
[
k
]
.
connect
(
panner
[
k
]
)
;
panner
[
k
]
.
connect
(
context
.
destination
)
;
time
[
k
]
=
k
*
timeStep
;
bufferSource
[
k
]
.
start
(
time
[
k
]
)
;
}
}
function
createTestAndRun
(
context
should
nodeCount
numberOfSourceChannels
positionSetter
)
{
numberOfChannels
=
numberOfSourceChannels
;
createGraph
(
context
nodeCount
positionSetter
)
;
return
context
.
startRendering
(
)
.
then
(
buffer
=
>
checkResult
(
buffer
should
)
)
;
}
async
function
createTestAndRun_W3CTH
(
context
nodeCount
numberOfSourceChannels
positionSetter
)
{
numberOfChannels
=
numberOfSourceChannels
;
createGraph
(
context
nodeCount
positionSetter
)
;
const
renderedBuffer
=
await
context
.
startRendering
(
)
;
return
checkResult_W3CTH
(
renderedBuffer
)
;
}
function
angleToAzimuth
(
angle
)
{
return
90
-
angle
*
180
/
Math
.
PI
;
}
function
equalPowerGain
(
angle
)
{
let
azimuth
=
angleToAzimuth
(
angle
)
;
if
(
numberOfChannels
=
=
1
)
{
let
panPosition
=
(
azimuth
+
90
)
/
180
;
let
gainL
=
Math
.
cos
(
0
.
5
*
Math
.
PI
*
panPosition
)
;
let
gainR
=
Math
.
sin
(
0
.
5
*
Math
.
PI
*
panPosition
)
;
return
{
left
:
gainL
right
:
gainR
}
;
}
else
{
if
(
azimuth
<
=
0
)
{
let
panPosition
=
(
azimuth
+
90
)
/
90
;
let
gainL
=
1
+
Math
.
cos
(
0
.
5
*
Math
.
PI
*
panPosition
)
;
let
gainR
=
Math
.
sin
(
0
.
5
*
Math
.
PI
*
panPosition
)
;
return
{
left
:
gainL
right
:
gainR
}
;
}
else
{
let
panPosition
=
azimuth
/
90
;
let
gainL
=
Math
.
cos
(
0
.
5
*
Math
.
PI
*
panPosition
)
;
let
gainR
=
1
+
Math
.
sin
(
0
.
5
*
Math
.
PI
*
panPosition
)
;
return
{
left
:
gainL
right
:
gainR
}
;
}
}
}
function
checkResult
(
renderedBuffer
should
)
{
renderedLeft
=
renderedBuffer
.
getChannelData
(
0
)
;
renderedRight
=
renderedBuffer
.
getChannelData
(
1
)
;
let
maxAllowedError
=
1
.
1597e
-
6
;
let
success
=
true
;
let
impulseCount
=
0
;
let
maxErrorL
=
0
;
let
maxErrorIndexL
=
0
;
let
maxErrorR
=
0
;
let
maxErrorIndexR
=
0
;
let
timeCount
=
0
;
let
timeErrors
=
new
Array
(
)
;
for
(
let
k
=
0
;
k
<
renderedLeft
.
length
;
+
+
k
)
{
if
(
renderedLeft
[
k
]
!
=
0
|
|
renderedRight
[
k
]
!
=
0
)
{
let
pannerGain
=
equalPowerGain
(
position
[
impulseCount
]
.
angle
)
;
let
expectedL
=
pannerGain
.
left
;
let
expectedR
=
pannerGain
.
right
;
let
errorL
=
Math
.
abs
(
renderedLeft
[
k
]
-
expectedL
)
;
let
errorR
=
Math
.
abs
(
renderedRight
[
k
]
-
expectedR
)
;
if
(
Math
.
abs
(
errorL
)
>
maxErrorL
)
{
maxErrorL
=
Math
.
abs
(
errorL
)
;
maxErrorIndexL
=
impulseCount
;
}
if
(
Math
.
abs
(
errorR
)
>
maxErrorR
)
{
maxErrorR
=
Math
.
abs
(
errorR
)
;
maxErrorIndexR
=
impulseCount
;
}
let
expectedOffset
=
timeToSampleFrame
(
time
[
impulseCount
]
sampleRate
)
;
if
(
k
!
=
expectedOffset
)
{
timeErrors
[
timeCount
]
=
{
actual
:
k
expected
:
expectedOffset
}
;
+
+
timeCount
;
}
+
+
impulseCount
;
}
}
should
(
impulseCount
'
Number
of
impulses
found
'
)
.
beEqualTo
(
nodesToCreate
)
;
should
(
timeErrors
.
map
(
x
=
>
x
.
actual
)
'
Offsets
of
impulses
at
the
wrong
position
'
)
.
beEqualToArray
(
timeErrors
.
map
(
x
=
>
x
.
expected
)
)
;
should
(
maxErrorL
'
Error
in
left
channel
gain
values
'
)
.
beLessThanOrEqualTo
(
maxAllowedError
)
;
should
(
maxErrorR
'
Error
in
right
channel
gain
values
'
)
.
beLessThanOrEqualTo
(
maxAllowedError
)
;
}
function
checkResult_W3CTH
(
renderedBuffer
)
{
renderedLeft
=
renderedBuffer
.
getChannelData
(
0
)
;
renderedRight
=
renderedBuffer
.
getChannelData
(
1
)
;
const
maxAllowedError
=
1
.
1597e
-
6
;
let
impulseCount
=
0
;
let
maxErrorL
=
0
;
let
maxErrorR
=
0
;
const
timeErrors
=
[
]
;
for
(
let
k
=
0
;
k
<
renderedLeft
.
length
;
+
+
k
)
{
if
(
renderedLeft
[
k
]
!
=
=
0
|
|
renderedRight
[
k
]
!
=
=
0
)
{
const
{
left
:
expectedL
right
:
expectedR
}
=
equalPowerGain
(
position
[
impulseCount
]
.
angle
)
;
maxErrorL
=
Math
.
max
(
maxErrorL
Math
.
abs
(
renderedLeft
[
k
]
-
expectedL
)
)
;
maxErrorR
=
Math
.
max
(
maxErrorR
Math
.
abs
(
renderedRight
[
k
]
-
expectedR
)
)
;
const
expectedOffset
=
timeToSampleFrame
(
time
[
impulseCount
]
sampleRate
)
;
if
(
k
!
=
=
expectedOffset
)
{
timeErrors
.
push
(
{
actual
:
k
expected
:
expectedOffset
}
)
;
}
+
+
impulseCount
;
}
}
assert_equals
(
impulseCount
nodesToCreate
'
Number
of
impulses
found
'
)
;
assert_array_equals
(
timeErrors
.
map
(
e
=
>
e
.
actual
)
timeErrors
.
map
(
e
=
>
e
.
expected
)
'
Offsets
of
impulses
at
the
wrong
position
'
)
;
assert_less_than_equal
(
maxErrorL
maxAllowedError
Left
-
channel
gain
error
{
maxErrorL
}
>
{
maxAllowedError
}
)
;
assert_less_than_equal
(
maxErrorR
maxAllowedError
Right
-
channel
gain
error
{
maxErrorR
}
>
{
maxAllowedError
}
)
;
}
