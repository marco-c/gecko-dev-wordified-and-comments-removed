let
context
;
let
filter
;
let
signal
;
let
renderedBuffer
;
let
renderedData
;
let
sampleRate
=
44100
.
0
;
let
pulseLengthFrames
=
.
1
*
sampleRate
;
let
maxAllowedError
=
5
.
9e
-
8
;
let
timeStep
=
.
1
;
let
maxFilters
=
5
;
let
renderLengthSeconds
=
timeStep
*
(
maxFilters
+
1
)
;
let
renderLengthSamples
=
Math
.
round
(
renderLengthSeconds
*
sampleRate
)
;
let
nFilters
;
function
createImpulseBuffer
(
context
length
)
{
let
impulse
=
context
.
createBuffer
(
1
length
context
.
sampleRate
)
;
let
data
=
impulse
.
getChannelData
(
0
)
;
for
(
let
k
=
1
;
k
<
data
.
length
;
+
+
k
)
{
data
[
k
]
=
0
;
}
data
[
0
]
=
1
;
return
impulse
;
}
function
createTestAndRun
(
context
filterType
testParameters
)
{
let
filterParameters
=
testParameters
.
filterParameters
;
nFilters
=
Math
.
min
(
filterParameters
.
length
maxFilters
)
;
signal
=
new
Array
(
nFilters
)
;
filter
=
new
Array
(
nFilters
)
;
impulse
=
createImpulseBuffer
(
context
pulseLengthFrames
)
;
for
(
let
k
=
0
;
k
<
nFilters
;
+
+
k
)
{
signal
[
k
]
=
context
.
createBufferSource
(
)
;
signal
[
k
]
.
buffer
=
impulse
;
filter
[
k
]
=
context
.
createBiquadFilter
(
)
;
filter
[
k
]
.
type
=
filterType
;
filter
[
k
]
.
frequency
.
value
=
context
.
sampleRate
/
2
*
filterParameters
[
k
]
.
cutoff
;
filter
[
k
]
.
detune
.
value
=
(
filterParameters
[
k
]
.
detune
=
=
=
undefined
)
?
0
:
filterParameters
[
k
]
.
detune
;
filter
[
k
]
.
Q
.
value
=
filterParameters
[
k
]
.
q
;
filter
[
k
]
.
gain
.
value
=
filterParameters
[
k
]
.
gain
;
signal
[
k
]
.
connect
(
filter
[
k
]
)
;
filter
[
k
]
.
connect
(
context
.
destination
)
;
signal
[
k
]
.
start
(
timeStep
*
k
)
;
}
return
context
.
startRendering
(
)
.
then
(
buffer
=
>
{
checkFilterResponse
(
buffer
filterType
testParameters
)
;
}
)
;
}
function
addSignal
(
dest
src
destOffset
)
{
for
(
let
k
=
destOffset
j
=
0
;
k
<
dest
.
length
j
<
src
.
length
;
+
+
k
+
+
j
)
{
dest
[
k
]
+
=
src
[
j
]
;
}
}
function
generateReference
(
filterType
filterParameters
)
{
let
result
=
new
Array
(
renderLengthSamples
)
;
let
data
=
new
Array
(
renderLengthSamples
)
;
for
(
let
k
=
0
;
k
<
result
.
length
;
+
+
k
)
{
result
[
k
]
=
0
;
data
[
k
]
=
0
;
}
data
[
0
]
=
1
;
for
(
let
k
=
0
;
k
<
nFilters
;
+
+
k
)
{
let
detune
=
(
filterParameters
[
k
]
.
detune
=
=
=
undefined
)
?
0
:
filterParameters
[
k
]
.
detune
;
let
frequency
=
filterParameters
[
k
]
.
cutoff
*
Math
.
pow
(
2
detune
/
1200
)
;
let
filterCoef
=
createFilter
(
filterType
frequency
filterParameters
[
k
]
.
q
filterParameters
[
k
]
.
gain
)
;
let
y
=
filterData
(
filterCoef
data
renderLengthSamples
)
;
addSignal
(
result
y
timeToSampleFrame
(
timeStep
*
k
sampleRate
)
)
;
}
return
result
;
}
function
checkFilterResponse
(
renderedBuffer
filterType
testParameters
)
{
let
filterParameters
=
testParameters
.
filterParameters
;
let
maxAllowedError
=
testParameters
.
threshold
;
let
should
=
testParameters
.
should
;
renderedData
=
renderedBuffer
.
getChannelData
(
0
)
;
reference
=
generateReference
(
filterType
filterParameters
)
;
let
len
=
Math
.
min
(
renderedData
.
length
reference
.
length
)
;
let
success
=
true
;
let
maxError
=
0
;
let
maxPosition
=
0
;
let
invalidNumberCount
=
0
;
should
(
nFilters
'
Number
of
filters
tested
'
)
.
beEqualTo
(
filterParameters
.
length
)
;
for
(
let
k
=
0
;
k
<
len
;
+
+
k
)
{
let
err
=
Math
.
abs
(
renderedData
[
k
]
-
reference
[
k
]
)
;
if
(
err
>
maxError
)
{
maxError
=
err
;
maxPosition
=
k
;
}
if
(
!
isValidNumber
(
renderedData
[
k
]
)
)
{
+
+
invalidNumberCount
;
}
}
should
(
invalidNumberCount
'
Number
of
non
-
finite
values
in
the
rendered
output
'
)
.
beEqualTo
(
0
)
;
should
(
maxError
'
Max
error
in
'
+
filterTypeName
[
filterType
]
+
'
response
'
)
.
beLessThanOrEqualTo
(
maxAllowedError
)
;
}
