function
createShiftedImpulseBuffer
(
context
numberOfChannels
frameLength
)
{
let
shiftedImpulseBuffer
=
context
.
createBuffer
(
numberOfChannels
frameLength
context
.
sampleRate
)
;
for
(
let
channel
=
0
;
channel
<
numberOfChannels
;
+
+
channel
)
{
let
data
=
shiftedImpulseBuffer
.
getChannelData
(
channel
)
;
data
[
channel
]
=
1
;
}
return
shiftedImpulseBuffer
;
}
function
stringifyBuffer
(
audioBuffer
frameLength
frameOffset
)
{
frameOffset
=
(
frameOffset
|
|
0
)
;
let
stringifiedBuffer
=
'
'
;
for
(
let
channel
=
0
;
channel
<
audioBuffer
.
numberOfChannels
;
+
+
channel
)
{
let
channelData
=
audioBuffer
.
getChannelData
(
channel
)
;
for
(
let
i
=
0
;
i
<
frameLength
;
+
+
i
)
stringifiedBuffer
+
=
channelData
[
i
+
frameOffset
]
+
'
'
;
stringifiedBuffer
+
=
'
\
n
'
;
}
return
stringifiedBuffer
;
}
function
computeNumberOfChannels
(
connections
channelCount
channelCountMode
)
{
if
(
channelCountMode
=
=
'
explicit
'
)
return
channelCount
;
let
computedNumberOfChannels
=
1
;
for
(
let
i
=
0
;
i
<
connections
.
length
;
+
+
i
)
{
let
connectionNumberOfChannels
=
parseInt
(
connections
[
i
]
)
;
computedNumberOfChannels
=
Math
.
max
(
computedNumberOfChannels
connectionNumberOfChannels
)
;
}
if
(
channelCountMode
=
=
'
clamped
-
max
'
)
computedNumberOfChannels
=
Math
.
min
(
computedNumberOfChannels
channelCount
)
;
return
computedNumberOfChannels
;
}
function
speakersSum
(
input
output
)
{
if
(
input
.
length
!
=
output
.
length
)
{
throw
'
[
mixing
-
rules
.
js
]
speakerSum
(
)
:
buffer
lengths
mismatch
(
input
:
'
+
input
.
length
+
'
output
:
'
+
output
.
length
+
'
)
'
;
}
if
(
input
.
numberOfChannels
=
=
=
output
.
numberOfChannels
)
{
for
(
let
channel
=
0
;
channel
<
output
.
numberOfChannels
;
+
+
channel
)
{
let
inputChannel
=
input
.
getChannelData
(
channel
)
;
let
outputChannel
=
output
.
getChannelData
(
channel
)
;
for
(
let
i
=
0
;
i
<
outputChannel
.
length
;
i
+
+
)
outputChannel
[
i
]
+
=
inputChannel
[
i
]
;
}
}
else
if
(
input
.
numberOfChannels
<
output
.
numberOfChannels
)
{
processUpMix
(
input
output
)
;
}
else
{
processDownMix
(
input
output
)
;
}
}
function
discreteSum
(
input
output
)
{
if
(
input
.
length
!
=
output
.
length
)
{
throw
'
[
mixing
-
rules
.
js
]
speakerSum
(
)
:
buffer
lengths
mismatch
(
input
:
'
+
input
.
length
+
'
output
:
'
+
output
.
length
+
'
)
'
;
}
let
numberOfChannels
=
Math
.
min
(
input
.
numberOfChannels
output
.
numberOfChannels
)
for
(
let
channel
=
0
;
channel
<
numberOfChannels
;
+
+
channel
)
{
let
inputChannel
=
input
.
getChannelData
(
channel
)
;
let
outputChannel
=
output
.
getChannelData
(
channel
)
;
for
(
let
i
=
0
;
i
<
outputChannel
.
length
;
i
+
+
)
outputChannel
[
i
]
+
=
inputChannel
[
i
]
;
}
}
function
processUpMix
(
input
output
)
{
let
numberOfInputChannels
=
input
.
numberOfChannels
;
let
numberOfOutputChannels
=
output
.
numberOfChannels
;
let
i
length
=
output
.
length
;
if
(
(
numberOfInputChannels
=
=
=
1
&
&
numberOfOutputChannels
=
=
=
2
)
|
|
(
numberOfInputChannels
=
=
=
1
&
&
numberOfOutputChannels
=
=
=
4
)
)
{
let
inputChannel
=
input
.
getChannelData
(
0
)
;
let
outputChannel0
=
output
.
getChannelData
(
0
)
;
let
outputChannel1
=
output
.
getChannelData
(
1
)
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
{
outputChannel0
[
i
]
+
=
inputChannel
[
i
]
;
outputChannel1
[
i
]
+
=
inputChannel
[
i
]
;
}
return
;
}
if
(
numberOfInputChannels
=
=
1
&
&
numberOfOutputChannels
=
=
6
)
{
let
inputChannel
=
input
.
getChannelData
(
0
)
;
let
outputChannel2
=
output
.
getChannelData
(
2
)
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
outputChannel2
[
i
]
+
=
inputChannel
[
i
]
;
return
;
}
if
(
(
numberOfInputChannels
=
=
=
2
&
&
numberOfOutputChannels
=
=
=
4
)
|
|
(
numberOfInputChannels
=
=
=
2
&
&
numberOfOutputChannels
=
=
=
6
)
)
{
let
inputChannel0
=
input
.
getChannelData
(
0
)
;
let
inputChannel1
=
input
.
getChannelData
(
1
)
;
let
outputChannel0
=
output
.
getChannelData
(
0
)
;
let
outputChannel1
=
output
.
getChannelData
(
1
)
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
{
outputChannel0
[
i
]
+
=
inputChannel0
[
i
]
;
outputChannel1
[
i
]
+
=
inputChannel1
[
i
]
;
}
return
;
}
if
(
numberOfInputChannels
=
=
=
4
&
&
numberOfOutputChannels
=
=
=
6
)
{
let
inputChannel0
=
input
.
getChannelData
(
0
)
;
let
inputChannel1
=
input
.
getChannelData
(
1
)
;
let
inputChannel2
=
input
.
getChannelData
(
2
)
;
let
inputChannel3
=
input
.
getChannelData
(
3
)
;
let
outputChannel0
=
output
.
getChannelData
(
0
)
;
let
outputChannel1
=
output
.
getChannelData
(
1
)
;
let
outputChannel4
=
output
.
getChannelData
(
4
)
;
let
outputChannel5
=
output
.
getChannelData
(
5
)
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
{
outputChannel0
[
i
]
+
=
inputChannel0
[
i
]
;
outputChannel1
[
i
]
+
=
inputChannel1
[
i
]
;
outputChannel4
[
i
]
+
=
inputChannel2
[
i
]
;
outputChannel5
[
i
]
+
=
inputChannel3
[
i
]
;
}
return
;
}
discreteSum
(
input
output
)
;
}
function
processDownMix
(
input
output
)
{
let
numberOfInputChannels
=
input
.
numberOfChannels
;
let
numberOfOutputChannels
=
output
.
numberOfChannels
;
let
i
length
=
output
.
length
;
if
(
numberOfInputChannels
=
=
=
2
&
&
numberOfOutputChannels
=
=
=
1
)
{
let
inputChannel0
=
input
.
getChannelData
(
0
)
;
let
inputChannel1
=
input
.
getChannelData
(
1
)
;
let
outputChannel0
=
output
.
getChannelData
(
0
)
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
outputChannel0
[
i
]
+
=
0
.
5
*
(
inputChannel0
[
i
]
+
inputChannel1
[
i
]
)
;
return
;
}
if
(
numberOfInputChannels
=
=
=
4
&
&
numberOfOutputChannels
=
=
=
1
)
{
let
inputChannel0
=
input
.
getChannelData
(
0
)
;
let
inputChannel1
=
input
.
getChannelData
(
1
)
;
let
inputChannel2
=
input
.
getChannelData
(
2
)
;
let
inputChannel3
=
input
.
getChannelData
(
3
)
;
let
outputChannel0
=
output
.
getChannelData
(
0
)
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
{
outputChannel0
[
i
]
+
=
0
.
25
*
(
inputChannel0
[
i
]
+
inputChannel1
[
i
]
+
inputChannel2
[
i
]
+
inputChannel3
[
i
]
)
;
}
return
;
}
if
(
numberOfInputChannels
=
=
=
6
&
&
numberOfOutputChannels
=
=
=
1
)
{
let
inputChannel0
=
input
.
getChannelData
(
0
)
;
let
inputChannel1
=
input
.
getChannelData
(
1
)
;
let
inputChannel2
=
input
.
getChannelData
(
2
)
;
let
inputChannel4
=
input
.
getChannelData
(
4
)
;
let
inputChannel5
=
input
.
getChannelData
(
5
)
;
let
outputChannel0
=
output
.
getChannelData
(
0
)
;
let
scaleSqrtHalf
=
Math
.
sqrt
(
0
.
5
)
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
{
outputChannel0
[
i
]
+
=
scaleSqrtHalf
*
(
inputChannel0
[
i
]
+
inputChannel1
[
i
]
)
+
inputChannel2
[
i
]
+
0
.
5
*
(
inputChannel4
[
i
]
+
inputChannel5
[
i
]
)
;
}
return
;
}
if
(
numberOfInputChannels
=
=
4
&
&
numberOfOutputChannels
=
=
2
)
{
let
inputChannel0
=
input
.
getChannelData
(
0
)
;
let
inputChannel1
=
input
.
getChannelData
(
1
)
;
let
inputChannel2
=
input
.
getChannelData
(
2
)
;
let
inputChannel3
=
input
.
getChannelData
(
3
)
;
let
outputChannel0
=
output
.
getChannelData
(
0
)
;
let
outputChannel1
=
output
.
getChannelData
(
1
)
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
{
outputChannel0
[
i
]
+
=
0
.
5
*
(
inputChannel0
[
i
]
+
inputChannel2
[
i
]
)
;
outputChannel1
[
i
]
+
=
0
.
5
*
(
inputChannel1
[
i
]
+
inputChannel3
[
i
]
)
;
}
return
;
}
if
(
numberOfInputChannels
=
=
6
&
&
numberOfOutputChannels
=
=
2
)
{
let
inputChannel0
=
input
.
getChannelData
(
0
)
;
let
inputChannel1
=
input
.
getChannelData
(
1
)
;
let
inputChannel2
=
input
.
getChannelData
(
2
)
;
let
inputChannel4
=
input
.
getChannelData
(
4
)
;
let
inputChannel5
=
input
.
getChannelData
(
5
)
;
let
outputChannel0
=
output
.
getChannelData
(
0
)
;
let
outputChannel1
=
output
.
getChannelData
(
1
)
;
let
scaleSqrtHalf
=
Math
.
sqrt
(
0
.
5
)
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
{
outputChannel0
[
i
]
+
=
inputChannel0
[
i
]
+
scaleSqrtHalf
*
(
inputChannel2
[
i
]
+
inputChannel4
[
i
]
)
;
outputChannel1
[
i
]
+
=
inputChannel1
[
i
]
+
scaleSqrtHalf
*
(
inputChannel2
[
i
]
+
inputChannel5
[
i
]
)
;
}
return
;
}
if
(
numberOfInputChannels
=
=
=
6
&
&
numberOfOutputChannels
=
=
=
4
)
{
let
inputChannel0
=
input
.
getChannelData
(
0
)
;
let
inputChannel1
=
input
.
getChannelData
(
1
)
;
let
inputChannel2
=
input
.
getChannelData
(
2
)
;
let
inputChannel4
=
input
.
getChannelData
(
4
)
;
let
inputChannel5
=
input
.
getChannelData
(
5
)
;
let
outputChannel0
=
output
.
getChannelData
(
0
)
;
let
outputChannel1
=
output
.
getChannelData
(
1
)
;
let
outputChannel2
=
output
.
getChannelData
(
2
)
;
let
outputChannel3
=
output
.
getChannelData
(
3
)
;
let
scaleSqrtHalf
=
Math
.
sqrt
(
0
.
5
)
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
{
outputChannel0
[
i
]
+
=
inputChannel0
[
i
]
+
scaleSqrtHalf
*
inputChannel2
[
i
]
;
outputChannel1
[
i
]
+
=
inputChannel1
[
i
]
+
scaleSqrtHalf
*
inputChannel2
[
i
]
;
outputChannel2
[
i
]
+
=
inputChannel4
[
i
]
;
outputChannel3
[
i
]
+
=
inputChannel5
[
i
]
;
}
return
;
}
discreteSum
(
input
output
)
;
}
