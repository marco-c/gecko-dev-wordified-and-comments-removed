let
sampleRate
=
44100
.
0
;
let
renderLengthSeconds
=
8
;
let
pulseLengthSeconds
=
1
;
let
pulseLengthFrames
=
pulseLengthSeconds
*
sampleRate
;
function
createSquarePulseBuffer
(
context
sampleFrameLength
)
{
let
audioBuffer
=
context
.
createBuffer
(
1
sampleFrameLength
context
.
sampleRate
)
;
let
n
=
audioBuffer
.
length
;
let
data
=
audioBuffer
.
getChannelData
(
0
)
;
for
(
let
i
=
0
;
i
<
n
;
+
+
i
)
data
[
i
]
=
1
;
return
audioBuffer
;
}
function
createTrianglePulseBuffer
(
context
sampleFrameLength
)
{
let
audioBuffer
=
context
.
createBuffer
(
1
sampleFrameLength
context
.
sampleRate
)
;
let
n
=
audioBuffer
.
length
;
let
halfLength
=
n
/
2
;
let
data
=
audioBuffer
.
getChannelData
(
0
)
;
for
(
let
i
=
0
;
i
<
halfLength
;
+
+
i
)
data
[
i
]
=
i
+
1
;
for
(
let
i
=
halfLength
;
i
<
n
;
+
+
i
)
data
[
i
]
=
n
-
i
-
1
;
return
audioBuffer
;
}
function
log10
(
x
)
{
return
Math
.
log
(
x
)
/
Math
.
LN10
;
}
function
linearToDecibel
(
x
)
{
return
20
*
log10
(
x
)
;
}
function
checkTriangularPulse
(
rendered
reference
should
)
{
let
match
=
true
;
let
maxDelta
=
0
;
let
valueAtMaxDelta
=
0
;
let
maxDeltaIndex
=
0
;
for
(
let
i
=
0
;
i
<
reference
.
length
;
+
+
i
)
{
let
diff
=
rendered
[
i
]
-
reference
[
i
]
;
let
x
=
Math
.
abs
(
diff
)
;
if
(
x
>
maxDelta
)
{
maxDelta
=
x
;
valueAtMaxDelta
=
reference
[
i
]
;
maxDeltaIndex
=
i
;
}
}
let
allowedDeviationDecibels
=
-
124
.
41
;
let
maxDeviationDecibels
=
linearToDecibel
(
maxDelta
/
valueAtMaxDelta
)
;
should
(
maxDeviationDecibels
'
Deviation
(
in
dB
)
of
triangular
portion
of
convolution
'
)
.
beLessThanOrEqualTo
(
allowedDeviationDecibels
)
;
return
match
;
}
function
checkTail1
(
data
reference
breakpoint
should
)
{
let
isZero
=
true
;
let
tail1Max
=
0
;
for
(
let
i
=
reference
.
length
;
i
<
reference
.
length
+
breakpoint
;
+
+
i
)
{
let
mag
=
Math
.
abs
(
data
[
i
]
)
;
if
(
mag
>
tail1Max
)
{
tail1Max
=
mag
;
}
}
let
refMax
=
0
;
for
(
let
i
=
0
;
i
<
reference
.
length
;
+
+
i
)
{
refMax
=
Math
.
max
(
refMax
Math
.
abs
(
reference
[
i
]
)
)
;
}
let
threshold1
=
-
129
.
7
;
let
tail1MaxDecibels
=
linearToDecibel
(
tail1Max
/
refMax
)
;
should
(
tail1MaxDecibels
'
Deviation
in
first
part
of
tail
of
convolutions
'
)
.
beLessThanOrEqualTo
(
threshold1
)
;
return
isZero
;
}
function
checkTail2
(
data
reference
breakpoint
should
)
{
let
isZero
=
true
;
let
tail2Max
=
0
;
let
threshold2
=
0
;
for
(
let
i
=
reference
.
length
+
breakpoint
;
i
<
data
.
length
;
+
+
i
)
{
if
(
Math
.
abs
(
data
[
i
]
)
>
0
)
{
isZero
=
false
;
break
;
}
}
should
(
isZero
'
Rendered
signal
after
tail
of
convolution
is
silent
'
)
.
beTrue
(
)
;
return
isZero
;
}
function
checkConvolvedResult
(
renderedBuffer
trianglePulse
should
)
{
let
referenceData
=
trianglePulse
.
getChannelData
(
0
)
;
let
renderedData
=
renderedBuffer
.
getChannelData
(
0
)
;
let
success
=
true
;
success
=
success
&
&
checkTriangularPulse
(
renderedData
referenceData
should
)
;
let
breakpoint
=
12800
;
success
=
success
&
&
checkTail1
(
renderedData
referenceData
breakpoint
should
)
;
success
=
success
&
&
checkTail2
(
renderedData
referenceData
breakpoint
should
)
;
should
(
success
'
Test
signal
convolved
'
)
.
message
(
'
correctly
'
'
incorrectly
'
)
;
}
