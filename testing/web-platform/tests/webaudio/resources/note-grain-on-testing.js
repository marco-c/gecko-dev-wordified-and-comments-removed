let
sampleRate
=
32768
;
let
numberOfTests
=
100
;
let
duration
=
Math
.
floor
(
0
.
01
*
sampleRate
)
/
sampleRate
;
let
grainGap
=
Math
.
floor
(
0
.
005
*
sampleRate
)
/
sampleRate
;
let
timeStep
=
duration
+
grainGap
;
let
grainOffsetStep
=
Math
.
floor
(
0
.
001
*
sampleRate
)
/
sampleRate
;
let
renderTime
=
(
numberOfTests
+
1
)
*
timeStep
;
let
context
;
let
renderedData
;
function
createSignalBuffer
(
context
f
)
{
let
signalLength
=
Math
.
floor
(
1
+
sampleRate
*
(
numberOfTests
*
grainOffsetStep
+
duration
)
)
;
let
buffer
=
context
.
createBuffer
(
2
signalLength
sampleRate
)
;
let
data
=
buffer
.
getChannelData
(
0
)
;
for
(
let
k
=
0
;
k
<
signalLength
;
+
+
k
)
{
data
[
k
]
=
f
(
k
)
;
}
return
buffer
;
}
function
findStartAndEndSamples
(
data
)
{
let
nSamples
=
data
.
length
;
let
startTime
=
[
]
;
let
endTime
=
[
]
;
let
lookForStart
=
true
;
for
(
let
k
=
0
;
k
<
nSamples
;
+
+
k
)
{
if
(
lookForStart
)
{
if
(
renderedData
[
k
]
)
{
startTime
.
push
(
k
)
;
lookForStart
=
false
;
}
}
else
{
if
(
!
renderedData
[
k
]
)
{
endTime
.
push
(
k
)
;
lookForStart
=
true
;
}
}
}
return
{
start
:
startTime
end
:
endTime
}
;
}
function
playGrain
(
context
source
time
offset
duration
)
{
let
bufferSource
=
context
.
createBufferSource
(
)
;
bufferSource
.
buffer
=
source
;
bufferSource
.
connect
(
context
.
destination
)
;
bufferSource
.
start
(
time
offset
duration
)
;
}
function
playAllGrains
(
context
source
numberOfNotes
)
{
let
startTimes
=
new
Array
(
numberOfNotes
)
;
let
offsets
=
new
Array
(
numberOfNotes
)
;
for
(
let
k
=
0
;
k
<
numberOfNotes
;
+
+
k
)
{
let
timeOffset
=
k
*
timeStep
;
let
grainOffset
=
k
*
grainOffsetStep
;
playGrain
(
context
source
timeOffset
grainOffset
duration
)
;
startTimes
[
k
]
=
timeOffset
;
offsets
[
k
]
=
grainOffset
;
}
return
{
startTimes
:
startTimes
grainOffsetTimes
:
offsets
}
;
}
function
verifyStartAndEndFrames
(
startEndFrames
should
)
{
let
startFrames
=
startEndFrames
.
start
;
let
endFrames
=
startEndFrames
.
end
;
let
errorCountStart
=
0
;
let
errorCountEnd
=
0
;
should
(
startFrames
.
length
=
=
endFrames
.
length
'
Found
all
grain
starts
and
ends
'
)
.
beTrue
(
)
;
should
(
startFrames
.
length
'
Number
of
start
frames
'
)
.
beEqualTo
(
numberOfTests
)
;
should
(
endFrames
.
length
'
Number
of
end
frames
'
)
.
beEqualTo
(
numberOfTests
)
;
for
(
let
k
=
0
;
k
<
startFrames
.
length
;
+
+
k
)
{
let
expectedStart
=
timeToSampleFrame
(
k
*
timeStep
sampleRate
)
;
let
expectedEnd
=
expectedStart
+
grainLengthInSampleFrames
(
k
*
grainOffsetStep
duration
sampleRate
)
;
if
(
startFrames
[
k
]
!
=
expectedStart
)
{
+
+
errorCountStart
;
}
if
(
endFrames
[
k
]
!
=
expectedEnd
)
{
+
+
errorCountEnd
;
}
should
(
[
startFrames
[
k
]
endFrames
[
k
]
]
'
Pulse
'
+
k
+
'
boundary
'
)
.
beEqualToArray
(
[
expectedStart
expectedEnd
]
)
;
}
if
(
!
errorCountStart
)
{
should
(
startFrames
.
length
'
Number
of
grains
that
started
at
the
correct
time
'
)
.
beEqualTo
(
numberOfTests
)
;
}
else
{
should
(
errorCountStart
'
Number
of
grains
out
of
'
+
numberOfTests
+
'
that
started
at
the
wrong
time
'
)
.
beEqualTo
(
0
)
;
}
if
(
!
errorCountEnd
)
{
should
(
endFrames
.
length
'
Number
of
grains
that
ended
at
the
correct
time
'
)
.
beEqualTo
(
numberOfTests
)
;
}
else
{
should
(
errorCountEnd
'
Number
of
grains
out
of
'
+
numberOfTests
+
'
that
ended
at
the
wrong
time
'
)
.
beEqualTo
(
0
)
;
}
}
function
verifyStartAndEndFrames_W3CTH
(
startEndFrames
)
{
const
startFrames
=
startEndFrames
.
start
;
const
endFrames
=
startEndFrames
.
end
;
let
errorCountStart
=
0
;
let
errorCountEnd
=
0
;
assert_equals
(
startFrames
.
length
endFrames
.
length
'
Found
all
grain
starts
and
ends
'
)
;
assert_equals
(
startFrames
.
length
numberOfTests
'
Number
of
start
frames
'
)
;
assert_equals
(
endFrames
.
length
numberOfTests
'
Number
of
end
frames
'
)
;
for
(
let
k
=
0
;
k
<
startFrames
.
length
;
+
+
k
)
{
const
expectedStart
=
timeToSampleFrame
(
k
*
timeStep
sampleRate
)
;
const
expectedEnd
=
expectedStart
+
grainLengthInSampleFrames
(
k
*
grainOffsetStep
duration
sampleRate
)
;
if
(
startFrames
[
k
]
!
=
=
expectedStart
)
{
+
+
errorCountStart
;
}
if
(
endFrames
[
k
]
!
=
=
expectedEnd
)
{
+
+
errorCountEnd
;
}
assert_array_equals
(
[
startFrames
[
k
]
endFrames
[
k
]
]
[
expectedStart
expectedEnd
]
'
Pulse
'
+
k
+
'
boundary
'
)
;
}
if
(
!
errorCountStart
)
{
assert_equals
(
startFrames
.
length
numberOfTests
'
Number
of
grains
that
started
at
the
correct
time
'
)
;
}
else
{
assert_equals
(
errorCountStart
0
Number
of
grains
out
of
{
numberOfTests
}
that
+
started
at
the
wrong
time
)
;
}
if
(
!
errorCountEnd
)
{
assert_equals
(
endFrames
.
length
numberOfTests
'
Number
of
grains
that
ended
at
the
correct
time
'
)
;
}
else
{
assert_equals
(
errorCountEnd
0
Number
of
grains
out
of
{
numberOfTests
}
that
+
ended
at
the
wrong
time
)
;
}
}
