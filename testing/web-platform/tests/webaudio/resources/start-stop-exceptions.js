function
testStartStop
(
should
node
options
)
{
const
nonFiniteValues
=
[
NaN
Infinity
-
Infinity
]
;
nonFiniteValues
.
forEach
(
time
=
>
{
should
(
(
)
=
>
{
node
.
start
(
time
)
;
}
start
(
{
time
}
)
)
.
throw
(
TypeError
)
;
}
)
;
should
(
(
)
=
>
{
node
.
stop
(
)
;
}
'
Calling
stop
(
)
before
start
(
)
'
)
.
throw
(
DOMException
'
InvalidStateError
'
)
;
should
(
(
)
=
>
{
node
.
start
(
-
1
)
;
}
'
start
(
-
1
)
'
)
.
throw
(
RangeError
)
;
if
(
options
)
{
options
.
forEach
(
test
=
>
{
should
(
(
)
=
>
{
node
.
start
(
.
.
.
test
.
args
)
}
'
start
(
'
+
test
.
args
+
'
)
'
)
.
throw
(
test
.
errorType
)
;
}
)
;
}
node
.
start
(
)
;
should
(
(
)
=
>
{
node
.
start
(
)
;
}
'
Calling
start
(
)
twice
'
)
.
throw
(
DOMException
'
InvalidStateError
'
)
;
should
(
(
)
=
>
{
node
.
stop
(
-
1
)
;
}
'
stop
(
-
1
)
'
)
.
throw
(
RangeError
)
;
nonFiniteValues
.
forEach
(
time
=
>
{
should
(
(
)
=
>
{
node
.
stop
(
time
)
;
}
stop
(
{
time
}
)
)
.
throw
(
TypeError
)
;
}
)
;
}
const
testStartStop_W3CTH
=
(
node
options
)
=
>
{
const
nonFiniteValues
=
[
NaN
Infinity
-
Infinity
]
;
nonFiniteValues
.
forEach
(
(
time
)
=
>
{
assert_throws_js
(
TypeError
(
)
=
>
{
node
.
start
(
time
)
;
}
start
(
{
time
}
)
)
;
}
)
;
assert_throws_dom
(
'
InvalidStateError
'
(
)
=
>
{
node
.
stop
(
)
;
}
'
Calling
stop
(
)
before
start
(
)
'
)
;
assert_throws_js
(
RangeError
(
)
=
>
{
node
.
start
(
-
1
)
;
}
'
start
(
-
1
)
'
)
;
if
(
options
)
{
options
.
forEach
(
(
test
)
=
>
{
assert_throws_js
(
test
.
errorType
(
)
=
>
{
node
.
start
(
.
.
.
test
.
args
)
;
}
start
(
{
test
.
args
}
)
)
;
}
)
;
}
node
.
start
(
)
;
assert_throws_dom
(
'
InvalidStateError
'
(
)
=
>
{
node
.
start
(
)
;
}
'
Calling
start
(
)
twice
'
)
;
assert_throws_js
(
RangeError
(
)
=
>
{
node
.
stop
(
-
1
)
;
}
'
stop
(
-
1
)
'
)
;
nonFiniteValues
.
forEach
(
(
time
)
=
>
{
assert_throws_js
(
TypeError
(
)
=
>
{
node
.
stop
(
time
)
;
}
stop
(
{
time
}
)
)
;
}
)
;
}
