let
sampleRate
=
44100
.
0
;
let
nodesToCreate
=
100
;
let
timeStep
=
0
.
001
;
let
renderLengthSeconds
=
timeStep
*
(
nodesToCreate
+
1
)
;
let
pulseLengthFrames
=
Math
.
round
(
timeStep
*
sampleRate
)
;
let
context
;
let
impulse
;
let
bufferSource
;
let
panner
;
let
position
;
let
time
;
function
linearDistance
(
panner
x
y
z
)
{
let
distance
=
Math
.
sqrt
(
x
*
x
+
y
*
y
+
z
*
z
)
;
distance
=
Math
.
min
(
distance
panner
.
maxDistance
)
;
let
rolloff
=
panner
.
rolloffFactor
;
let
gain
=
(
1
-
rolloff
*
(
distance
-
panner
.
refDistance
)
/
(
panner
.
maxDistance
-
panner
.
refDistance
)
)
;
return
gain
;
}
function
inverseDistance
(
panner
x
y
z
)
{
let
distance
=
Math
.
sqrt
(
x
*
x
+
y
*
y
+
z
*
z
)
;
distance
=
Math
.
min
(
distance
panner
.
maxDistance
)
;
let
rolloff
=
panner
.
rolloffFactor
;
let
gain
=
panner
.
refDistance
/
(
panner
.
refDistance
+
rolloff
*
(
distance
-
panner
.
refDistance
)
)
;
return
gain
;
}
function
exponentialDistance
(
panner
x
y
z
)
{
let
distance
=
Math
.
sqrt
(
x
*
x
+
y
*
y
+
z
*
z
)
;
distance
=
Math
.
min
(
distance
panner
.
maxDistance
)
;
let
rolloff
=
panner
.
rolloffFactor
;
let
gain
=
Math
.
pow
(
distance
/
panner
.
refDistance
-
rolloff
)
;
return
gain
;
}
let
distanceModelFunction
=
{
'
linear
'
:
linearDistance
'
inverse
'
:
inverseDistance
'
exponential
'
:
exponentialDistance
}
;
function
createGraph
(
context
distanceModel
nodeCount
)
{
bufferSource
=
new
Array
(
nodeCount
)
;
panner
=
new
Array
(
nodeCount
)
;
position
=
new
Array
(
nodeCount
)
;
time
=
new
Array
(
nodesToCreate
)
;
impulse
=
createImpulseBuffer
(
context
pulseLengthFrames
)
;
for
(
let
k
=
0
;
k
<
nodeCount
;
+
+
k
)
{
bufferSource
[
k
]
=
context
.
createBufferSource
(
)
;
bufferSource
[
k
]
.
buffer
=
impulse
;
panner
[
k
]
=
context
.
createPanner
(
)
;
panner
[
k
]
.
panningModel
=
'
equalpower
'
;
panner
[
k
]
.
distanceModel
=
distanceModel
;
let
distanceStep
=
(
panner
[
k
]
.
maxDistance
-
panner
[
k
]
.
refDistance
)
/
nodeCount
;
position
[
k
]
=
distanceStep
*
k
+
panner
[
k
]
.
refDistance
;
panner
[
k
]
.
setPosition
(
0
0
position
[
k
]
)
;
bufferSource
[
k
]
.
connect
(
panner
[
k
]
)
;
panner
[
k
]
.
connect
(
context
.
destination
)
;
time
[
k
]
=
k
*
timeStep
;
bufferSource
[
k
]
.
start
(
time
[
k
]
)
;
}
}
function
createTestAndRun
(
context
distanceModel
should
)
{
createGraph
(
context
distanceModel
nodesToCreate
)
;
return
context
.
startRendering
(
)
.
then
(
buffer
=
>
checkDistanceResult
(
buffer
distanceModel
should
)
)
;
}
function
equalPowerGain
(
)
{
return
Math
.
SQRT1_2
;
}
function
checkDistanceResult
(
renderedBuffer
model
should
)
{
renderedData
=
renderedBuffer
.
getChannelData
(
0
)
;
let
maxAllowedError
=
3
.
3e
-
6
;
let
success
=
true
;
let
impulseCount
=
0
;
let
maxError
=
0
;
let
impulsePositionErrors
=
new
Array
(
)
;
for
(
let
k
=
0
;
k
<
renderedData
.
length
;
+
+
k
)
{
if
(
renderedData
[
k
]
!
=
0
)
{
let
distanceFunction
=
distanceModelFunction
[
model
]
;
let
expected
=
distanceFunction
(
panner
[
impulseCount
]
0
0
position
[
impulseCount
]
)
;
expected
*
=
equalPowerGain
(
)
;
let
error
=
Math
.
abs
(
renderedData
[
k
]
-
expected
)
/
Math
.
abs
(
expected
)
;
maxError
=
Math
.
max
(
maxError
Math
.
abs
(
error
)
)
;
should
(
renderedData
[
k
]
)
.
beCloseTo
(
expected
{
threshold
:
maxAllowedError
}
)
;
let
expectedOffset
=
timeToSampleFrame
(
time
[
impulseCount
]
sampleRate
)
;
if
(
k
!
=
expectedOffset
)
{
impulsePositionErrors
.
push
(
{
actual
:
k
expected
:
expectedOffset
}
)
;
}
+
+
impulseCount
;
}
}
should
(
impulseCount
'
Number
of
impulses
'
)
.
beEqualTo
(
nodesToCreate
)
;
should
(
maxError
'
Max
error
in
distance
gains
'
)
.
beLessThanOrEqualTo
(
maxAllowedError
)
;
if
(
impulsePositionErrors
.
length
>
0
)
{
let
actual
=
impulsePositionErrors
.
map
(
x
=
>
x
.
actual
)
;
let
expected
=
impulsePositionErrors
.
map
(
x
=
>
x
.
expected
)
;
should
(
actual
'
Actual
impulse
positions
found
'
)
.
beEqualToArray
(
expected
)
;
}
}
