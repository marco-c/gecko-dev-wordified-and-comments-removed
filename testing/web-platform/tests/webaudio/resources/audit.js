(
function
(
)
{
'
use
strict
'
;
let
testharnessProperties
=
[
'
test
'
'
async_test
'
'
promise_test
'
'
promise_rejects
'
'
generate_tests
'
'
setup
'
'
done
'
'
assert_true
'
'
assert_false
'
]
;
for
(
let
name
in
testharnessProperties
)
{
if
(
!
self
.
hasOwnProperty
(
testharnessProperties
[
name
]
)
)
throw
new
Error
(
'
Cannot
proceed
.
testharness
.
js
is
not
loaded
.
'
)
;
}
}
)
(
)
;
window
.
Audit
=
(
function
(
)
{
'
use
strict
'
;
function
_logError
(
message
)
{
console
.
error
(
'
[
audit
.
js
]
'
+
message
)
;
}
function
_logPassed
(
message
)
{
test
(
function
(
arg
)
{
assert_true
(
true
)
;
}
message
)
;
}
function
_logFailed
(
message
detail
)
{
test
(
function
(
)
{
assert_true
(
false
detail
)
;
}
message
)
;
}
function
_throwException
(
message
)
{
throw
new
Error
(
message
)
;
}
const
_testharnessDone
=
window
.
done
;
window
.
done
=
(
)
=
>
{
_throwException
(
'
Do
NOT
call
done
(
)
method
from
the
test
code
.
'
)
;
}
;
function
_generateDescription
(
target
options
)
{
let
targetString
;
switch
(
typeof
target
)
{
case
'
object
'
:
if
(
target
instanceof
Array
|
|
target
instanceof
Float32Array
|
|
target
instanceof
Float64Array
|
|
target
instanceof
Uint8Array
)
{
let
arrayElements
=
target
.
length
<
options
.
numberOfArrayElements
?
String
(
target
)
:
String
(
target
.
slice
(
0
options
.
numberOfArrayElements
)
)
+
'
.
.
.
'
;
targetString
=
'
[
'
+
arrayElements
+
'
]
'
;
}
else
if
(
target
=
=
=
null
)
{
targetString
=
String
(
target
)
;
}
else
{
targetString
=
'
'
+
String
(
target
)
.
split
(
/
[
\
s
\
]
]
/
)
[
1
]
;
}
break
;
case
'
function
'
:
if
(
Error
.
isPrototypeOf
(
target
)
)
{
targetString
=
"
EcmaScript
error
"
+
target
.
name
;
}
else
{
targetString
=
String
(
target
)
;
}
break
;
default
:
targetString
=
String
(
target
)
;
break
;
}
return
targetString
;
}
function
_formatFailureEntry
(
index
actual
expected
abserr
threshold
)
{
return
'
\
t
[
'
+
index
+
'
]
\
t
'
+
actual
.
toExponential
(
16
)
+
'
\
t
'
+
expected
.
toExponential
(
16
)
+
'
\
t
'
+
abserr
.
toExponential
(
16
)
+
'
\
t
'
+
(
abserr
/
Math
.
abs
(
expected
)
)
.
toExponential
(
16
)
+
'
\
t
'
+
threshold
.
toExponential
(
16
)
;
}
function
_closeToThreshold
(
abserr
relerr
expected
)
{
return
Math
.
max
(
abserr
relerr
*
Math
.
abs
(
expected
)
)
;
}
class
Should
{
constructor
(
parentTask
actual
actualDescription
)
{
this
.
_task
=
parentTask
;
this
.
_actual
=
actual
;
this
.
_actualDescription
=
(
actualDescription
|
|
null
)
;
this
.
_expected
=
null
;
this
.
_expectedDescription
=
null
;
this
.
_detail
=
'
'
;
this
.
_printActualForFailure
=
true
;
this
.
_result
=
null
;
this
.
_options
=
{
numberOfErrors
:
4
numberOfArrayElements
:
16
verbose
:
false
}
;
}
_processArguments
(
args
)
{
if
(
args
.
length
=
=
=
0
)
return
;
if
(
args
.
length
>
0
)
this
.
_expected
=
args
[
0
]
;
if
(
typeof
args
[
1
]
=
=
=
'
string
'
)
{
this
.
_expectedDescription
=
args
[
1
]
;
Object
.
assign
(
this
.
_options
args
[
2
]
)
;
}
else
if
(
typeof
args
[
1
]
=
=
=
'
object
'
)
{
Object
.
assign
(
this
.
_options
args
[
1
]
)
;
}
}
_buildResultText
(
)
{
if
(
this
.
_result
=
=
=
null
)
_throwException
(
'
Illegal
invocation
:
the
assertion
is
not
finished
.
'
)
;
let
actualString
=
_generateDescription
(
this
.
_actual
this
.
_options
)
;
if
(
!
this
.
_actualDescription
)
this
.
_actualDescription
=
actualString
;
if
(
!
this
.
_expectedDescription
)
{
this
.
_expectedDescription
=
_generateDescription
(
this
.
_expected
this
.
_options
)
;
}
this
.
_detail
=
this
.
_detail
.
replace
(
/
\
\
{
actual
\
}
/
g
this
.
_actualDescription
)
;
this
.
_detail
=
this
.
_detail
.
replace
(
/
\
\
{
expected
\
}
/
g
this
.
_expectedDescription
)
;
for
(
let
name
in
this
.
_options
)
{
if
(
name
=
=
=
'
numberOfErrors
'
|
|
name
=
=
=
'
numberOfArrayElements
'
|
|
name
=
=
=
'
verbose
'
)
{
continue
;
}
let
re
=
'
\
\
{
'
+
name
+
'
\
}
'
;
re
=
re
.
replace
(
/
(
[
.
*
+
?
^
=
!
:
{
}
(
)
|
\
[
\
]
\
/
\
\
]
)
/
g
'
\
\
1
'
)
;
this
.
_detail
=
this
.
_detail
.
replace
(
new
RegExp
(
re
'
g
'
)
_generateDescription
(
this
.
_options
[
name
]
)
)
;
}
if
(
this
.
_result
=
=
=
false
&
&
this
.
_printActualForFailure
=
=
=
true
)
{
this
.
_detail
+
=
'
Got
'
+
actualString
+
'
.
'
;
}
}
_finalize
(
)
{
if
(
this
.
_result
)
{
_logPassed
(
'
'
+
this
.
_detail
)
;
}
else
{
_logFailed
(
'
X
'
+
this
.
_detail
)
;
}
this
.
_task
.
update
(
this
)
;
}
_assert
(
condition
passDetail
failDetail
)
{
this
.
_result
=
Boolean
(
condition
)
;
this
.
_detail
=
this
.
_result
?
passDetail
:
failDetail
;
this
.
_buildResultText
(
)
;
this
.
_finalize
(
)
;
return
this
.
_result
;
}
get
result
(
)
{
return
this
.
_result
;
}
get
detail
(
)
{
return
this
.
_detail
;
}
exist
(
)
{
return
this
.
_assert
(
this
.
_actual
!
=
=
null
&
&
this
.
_actual
!
=
=
undefined
'
{
actual
}
does
exist
.
'
'
{
actual
}
does
not
exist
.
'
)
;
}
throw
(
)
{
this
.
_processArguments
(
arguments
)
;
this
.
_printActualForFailure
=
false
;
let
didThrowCorrectly
=
false
;
let
passDetail
failDetail
;
try
{
this
.
_actual
(
)
;
failDetail
=
'
{
actual
}
did
not
throw
an
exception
.
'
;
}
catch
(
error
)
{
let
errorMessage
=
this
.
_options
.
omitErrorMessage
?
'
:
[
error
message
omitted
]
'
:
'
:
"
'
+
error
.
message
+
'
"
'
;
if
(
this
.
_expected
=
=
=
null
|
|
this
.
_expected
=
=
=
undefined
)
{
didThrowCorrectly
=
true
;
passDetail
=
'
{
actual
}
threw
'
+
error
.
name
+
errorMessage
+
'
.
'
;
}
else
if
(
typeof
(
this
.
_expected
)
=
=
"
string
"
&
&
error
instanceof
DOMException
&
&
error
.
name
=
=
=
this
.
_expected
)
{
didThrowCorrectly
=
true
;
passDetail
=
'
{
actual
}
threw
{
expected
}
'
+
errorMessage
+
'
.
'
;
}
else
if
(
this
.
_expected
=
=
error
.
constructor
&
&
this
.
_expected
.
name
=
=
error
.
name
)
{
didThrowCorrectly
=
true
;
passDetail
=
'
{
actual
}
threw
{
expected
}
'
+
errorMessage
+
'
.
'
;
}
else
{
didThrowCorrectly
=
false
;
failDetail
=
'
{
actual
}
threw
"
'
+
error
.
name
+
'
"
instead
of
{
expected
}
.
'
;
}
}
return
this
.
_assert
(
didThrowCorrectly
passDetail
failDetail
)
;
}
notThrow
(
)
{
this
.
_printActualForFailure
=
false
;
let
didThrowCorrectly
=
false
;
let
passDetail
failDetail
;
try
{
this
.
_actual
(
)
;
passDetail
=
'
{
actual
}
did
not
throw
an
exception
.
'
;
}
catch
(
error
)
{
didThrowCorrectly
=
true
;
failDetail
=
'
{
actual
}
incorrectly
threw
'
+
error
.
name
+
'
:
"
'
+
error
.
message
+
'
"
.
'
;
}
return
this
.
_assert
(
!
didThrowCorrectly
passDetail
failDetail
)
;
}
beResolved
(
)
{
return
this
.
_actual
.
then
(
function
(
result
)
{
this
.
_assert
(
true
'
{
actual
}
resolved
correctly
.
'
null
)
;
return
result
;
}
.
bind
(
this
)
function
(
error
)
{
this
.
_assert
(
false
null
'
{
actual
}
rejected
incorrectly
with
'
+
error
+
'
.
'
)
;
}
.
bind
(
this
)
)
;
}
beRejected
(
)
{
return
this
.
_actual
.
then
(
function
(
)
{
this
.
_assert
(
false
null
'
{
actual
}
resolved
incorrectly
.
'
)
;
}
.
bind
(
this
)
function
(
error
)
{
this
.
_assert
(
true
'
{
actual
}
rejected
correctly
with
'
+
error
+
'
.
'
null
)
;
}
.
bind
(
this
)
)
;
}
beRejectedWith
(
)
{
this
.
_processArguments
(
arguments
)
;
return
this
.
_actual
.
then
(
function
(
)
{
this
.
_assert
(
false
null
'
{
actual
}
resolved
incorrectly
.
'
)
;
}
.
bind
(
this
)
function
(
error
)
{
if
(
this
.
_expected
!
=
=
error
.
name
)
{
this
.
_assert
(
false
null
'
{
actual
}
rejected
correctly
but
got
'
+
error
.
name
+
'
instead
of
'
+
this
.
_expected
+
'
.
'
)
;
}
else
{
this
.
_assert
(
true
'
{
actual
}
rejected
correctly
with
'
+
this
.
_expected
+
'
.
'
null
)
;
}
}
.
bind
(
this
)
)
;
}
beTrue
(
)
{
return
this
.
_assert
(
this
.
_actual
=
=
=
true
'
{
actual
}
is
true
.
'
'
{
actual
}
is
not
true
.
'
)
;
}
beFalse
(
)
{
return
this
.
_assert
(
this
.
_actual
=
=
=
false
'
{
actual
}
is
false
.
'
'
{
actual
}
is
not
false
.
'
)
;
}
beEqualTo
(
)
{
this
.
_processArguments
(
arguments
)
;
return
this
.
_assert
(
this
.
_actual
=
=
=
this
.
_expected
'
{
actual
}
is
equal
to
{
expected
}
.
'
'
{
actual
}
is
not
equal
to
{
expected
}
.
'
)
;
}
notBeEqualTo
(
)
{
this
.
_processArguments
(
arguments
)
;
return
this
.
_assert
(
this
.
_actual
!
=
=
this
.
_expected
'
{
actual
}
is
not
equal
to
{
expected
}
.
'
'
{
actual
}
should
not
be
equal
to
{
expected
}
.
'
)
;
}
beNaN
(
)
{
this
.
_processArguments
(
arguments
)
;
return
this
.
_assert
(
isNaN
(
this
.
_actual
)
'
{
actual
}
is
NaN
.
'
'
{
actual
}
is
not
NaN
but
should
be
.
'
)
;
}
notBeNaN
(
)
{
this
.
_processArguments
(
arguments
)
;
return
this
.
_assert
(
!
isNaN
(
this
.
_actual
)
'
{
actual
}
is
not
NaN
.
'
'
{
actual
}
is
NaN
but
should
not
be
.
'
)
;
}
beGreaterThan
(
)
{
this
.
_processArguments
(
arguments
)
;
return
this
.
_assert
(
this
.
_actual
>
this
.
_expected
'
{
actual
}
is
greater
than
{
expected
}
.
'
'
{
actual
}
is
not
greater
than
{
expected
}
.
'
)
;
}
beGreaterThanOrEqualTo
(
)
{
this
.
_processArguments
(
arguments
)
;
return
this
.
_assert
(
this
.
_actual
>
=
this
.
_expected
'
{
actual
}
is
greater
than
or
equal
to
{
expected
}
.
'
'
{
actual
}
is
not
greater
than
or
equal
to
{
expected
}
.
'
)
;
}
beLessThan
(
)
{
this
.
_processArguments
(
arguments
)
;
return
this
.
_assert
(
this
.
_actual
<
this
.
_expected
'
{
actual
}
is
less
than
{
expected
}
.
'
'
{
actual
}
is
not
less
than
{
expected
}
.
'
)
;
}
beLessThanOrEqualTo
(
)
{
this
.
_processArguments
(
arguments
)
;
return
this
.
_assert
(
this
.
_actual
<
=
this
.
_expected
'
{
actual
}
is
less
than
or
equal
to
{
expected
}
.
'
'
{
actual
}
is
not
less
than
or
equal
to
{
expected
}
.
'
)
;
}
beConstantValueOf
(
)
{
this
.
_processArguments
(
arguments
)
;
this
.
_printActualForFailure
=
false
;
let
passed
=
true
;
let
passDetail
failDetail
;
let
errors
=
{
}
;
let
actual
=
this
.
_actual
;
let
expected
=
this
.
_expected
;
for
(
let
index
=
0
;
index
<
actual
.
length
;
+
+
index
)
{
if
(
actual
[
index
]
!
=
=
expected
)
errors
[
index
]
=
actual
[
index
]
;
}
let
numberOfErrors
=
Object
.
keys
(
errors
)
.
length
;
passed
=
numberOfErrors
=
=
=
0
;
if
(
passed
)
{
passDetail
=
'
{
actual
}
contains
only
the
constant
{
expected
}
.
'
;
}
else
{
let
counter
=
0
;
failDetail
=
'
{
actual
}
:
Expected
{
expected
}
for
all
values
but
found
'
+
numberOfErrors
+
'
unexpected
values
:
'
;
failDetail
+
=
'
\
n
\
tIndex
\
tActual
'
;
for
(
let
errorIndex
in
errors
)
{
failDetail
+
=
'
\
n
\
t
[
'
+
errorIndex
+
'
]
'
+
'
\
t
'
+
errors
[
errorIndex
]
;
if
(
+
+
counter
>
=
this
.
_options
.
numberOfErrors
)
{
failDetail
+
=
'
\
n
\
t
.
.
.
and
'
+
(
numberOfErrors
-
counter
)
+
'
more
errors
.
'
;
break
;
}
}
}
return
this
.
_assert
(
passed
passDetail
failDetail
)
;
}
notBeConstantValueOf
(
)
{
this
.
_processArguments
(
arguments
)
;
this
.
_printActualForFailure
=
false
;
let
passed
=
true
;
let
passDetail
;
let
failDetail
;
let
differences
=
{
}
;
let
actual
=
this
.
_actual
;
let
expected
=
this
.
_expected
;
for
(
let
index
=
0
;
index
<
actual
.
length
;
+
+
index
)
{
if
(
actual
[
index
]
!
=
=
expected
)
differences
[
index
]
=
actual
[
index
]
;
}
let
numberOfDifferences
=
Object
.
keys
(
differences
)
.
length
;
passed
=
numberOfDifferences
>
0
;
if
(
passed
)
{
let
valueString
=
numberOfDifferences
>
1
?
'
values
'
:
'
value
'
;
passDetail
=
'
{
actual
}
is
not
constantly
{
expected
}
(
contains
'
+
numberOfDifferences
+
'
different
'
+
valueString
+
'
)
.
'
;
}
else
{
failDetail
=
'
{
actual
}
should
have
contain
at
least
one
value
'
+
'
different
from
{
expected
}
.
'
;
}
return
this
.
_assert
(
passed
passDetail
failDetail
)
;
}
beEqualToArray
(
)
{
this
.
_processArguments
(
arguments
)
;
this
.
_printActualForFailure
=
false
;
let
passed
=
true
;
let
passDetail
failDetail
;
let
errorIndices
=
[
]
;
if
(
this
.
_actual
.
length
!
=
=
this
.
_expected
.
length
)
{
passed
=
false
;
failDetail
=
'
The
array
length
does
not
match
.
'
;
return
this
.
_assert
(
passed
passDetail
failDetail
)
;
}
let
actual
=
this
.
_actual
;
let
expected
=
this
.
_expected
;
for
(
let
index
=
0
;
index
<
actual
.
length
;
+
+
index
)
{
if
(
actual
[
index
]
!
=
=
expected
[
index
]
)
errorIndices
.
push
(
index
)
;
}
passed
=
errorIndices
.
length
=
=
=
0
;
if
(
passed
)
{
passDetail
=
'
{
actual
}
is
identical
to
the
array
{
expected
}
.
'
;
}
else
{
let
counter
=
0
;
failDetail
=
'
{
actual
}
expected
to
be
equal
to
the
array
{
expected
}
'
+
'
but
differs
in
'
+
errorIndices
.
length
+
'
places
:
'
+
'
\
n
\
tIndex
\
tActual
\
t
\
t
\
tExpected
'
;
for
(
let
index
of
errorIndices
)
{
failDetail
+
=
'
\
n
\
t
[
'
+
index
+
'
]
'
+
'
\
t
'
+
this
.
_actual
[
index
]
.
toExponential
(
16
)
+
'
\
t
'
+
this
.
_expected
[
index
]
.
toExponential
(
16
)
;
if
(
+
+
counter
>
=
this
.
_options
.
numberOfErrors
)
{
failDetail
+
=
'
\
n
\
t
.
.
.
and
'
+
(
errorIndices
.
length
-
counter
)
+
'
more
errors
.
'
;
break
;
}
}
}
return
this
.
_assert
(
passed
passDetail
failDetail
)
;
}
containValues
(
)
{
this
.
_processArguments
(
arguments
)
;
this
.
_printActualForFailure
=
false
;
let
passed
=
true
;
let
indexedActual
=
[
]
;
let
firstErrorIndex
=
null
;
for
(
let
i
=
0
prev
=
null
;
i
<
this
.
_actual
.
length
;
i
+
+
)
{
if
(
this
.
_actual
[
i
]
!
=
=
prev
)
{
indexedActual
.
push
(
{
index
:
i
value
:
this
.
_actual
[
i
]
}
)
;
prev
=
this
.
_actual
[
i
]
;
}
}
for
(
let
j
=
0
;
j
<
this
.
_expected
.
length
;
j
+
+
)
{
if
(
this
.
_expected
[
j
]
!
=
=
indexedActual
[
j
]
.
value
)
{
firstErrorIndex
=
indexedActual
[
j
]
.
index
;
passed
=
false
;
break
;
}
}
return
this
.
_assert
(
passed
'
{
actual
}
contains
all
the
expected
values
in
the
correct
order
:
'
+
'
{
expected
}
.
'
'
{
actual
}
expected
to
have
the
value
sequence
of
{
expected
}
but
'
+
'
got
'
+
this
.
_actual
[
firstErrorIndex
]
+
'
at
index
'
+
firstErrorIndex
+
'
.
'
)
;
}
notGlitch
(
)
{
this
.
_processArguments
(
arguments
)
;
this
.
_printActualForFailure
=
false
;
let
passed
=
true
;
let
passDetail
failDetail
;
let
actual
=
this
.
_actual
;
let
expected
=
this
.
_expected
;
for
(
let
index
=
0
;
index
<
actual
.
length
;
+
+
index
)
{
let
diff
=
Math
.
abs
(
actual
[
index
-
1
]
-
actual
[
index
]
)
;
if
(
diff
>
=
expected
)
{
passed
=
false
;
failDetail
=
'
{
actual
}
has
a
glitch
at
index
'
+
index
+
'
of
size
'
+
diff
+
'
.
'
;
}
}
passDetail
=
'
{
actual
}
has
no
glitch
above
the
threshold
of
{
expected
}
.
'
;
return
this
.
_assert
(
passed
passDetail
failDetail
)
;
}
beCloseTo
(
)
{
this
.
_processArguments
(
arguments
)
;
let
absExpected
=
this
.
_expected
?
Math
.
abs
(
this
.
_expected
)
:
1
;
let
error
=
Math
.
abs
(
this
.
_actual
-
this
.
_expected
)
/
absExpected
;
return
this
.
_assert
(
error
<
=
this
.
_options
.
threshold
'
{
actual
}
is
{
expected
}
within
an
error
of
{
threshold
}
.
'
'
{
actual
}
is
not
close
to
{
expected
}
within
a
relative
error
of
'
+
'
{
threshold
}
(
RelErr
=
'
+
error
+
'
)
.
'
)
;
}
beCloseToArray
(
)
{
this
.
_processArguments
(
arguments
)
;
this
.
_printActualForFailure
=
false
;
let
passed
=
true
;
let
passDetail
failDetail
;
let
absErrorThreshold
=
(
this
.
_options
.
absoluteThreshold
|
|
0
)
;
let
relErrorThreshold
=
(
this
.
_options
.
relativeThreshold
|
|
0
)
;
let
errors
=
{
}
;
let
maxAbsError
=
-
Infinity
maxAbsErrorIndex
=
-
1
;
let
maxRelError
=
-
Infinity
maxRelErrorIndex
=
-
1
;
let
actual
=
this
.
_actual
;
let
expected
=
this
.
_expected
;
for
(
let
index
=
0
;
index
<
expected
.
length
;
+
+
index
)
{
let
diff
=
Math
.
abs
(
actual
[
index
]
-
expected
[
index
]
)
;
let
absExpected
=
Math
.
abs
(
expected
[
index
]
)
;
let
relError
=
diff
/
absExpected
;
if
(
diff
>
Math
.
max
(
absErrorThreshold
relErrorThreshold
*
absExpected
)
)
{
if
(
diff
>
maxAbsError
)
{
maxAbsErrorIndex
=
index
;
maxAbsError
=
diff
;
}
if
(
!
isNaN
(
relError
)
&
&
relError
>
maxRelError
)
{
maxRelErrorIndex
=
index
;
maxRelError
=
relError
;
}
errors
[
index
]
=
diff
;
}
}
let
numberOfErrors
=
Object
.
keys
(
errors
)
.
length
;
let
maxAllowedErrorDetail
=
JSON
.
stringify
(
{
absoluteThreshold
:
absErrorThreshold
relativeThreshold
:
relErrorThreshold
}
)
;
if
(
numberOfErrors
=
=
=
0
)
{
passDetail
=
'
{
actual
}
equals
{
expected
}
with
an
element
-
wise
'
+
'
tolerance
of
'
+
maxAllowedErrorDetail
+
'
.
'
;
}
else
{
passed
=
false
;
failDetail
=
'
{
actual
}
does
not
equal
{
expected
}
with
an
'
+
'
element
-
wise
tolerance
of
'
+
maxAllowedErrorDetail
+
'
.
\
n
'
;
let
counter
=
0
;
failDetail
+
=
'
\
tIndex
\
tActual
\
t
\
t
\
tExpected
\
t
\
tAbsError
'
+
'
\
t
\
tRelError
\
t
\
tTest
threshold
'
;
let
printedIndices
=
[
]
;
for
(
let
index
in
errors
)
{
failDetail
+
=
'
\
n
'
+
_formatFailureEntry
(
index
actual
[
index
]
expected
[
index
]
errors
[
index
]
_closeToThreshold
(
absErrorThreshold
relErrorThreshold
expected
[
index
]
)
)
;
printedIndices
.
push
(
index
)
;
if
(
+
+
counter
>
this
.
_options
.
numberOfErrors
)
{
failDetail
+
=
'
\
n
\
t
.
.
.
and
'
+
(
numberOfErrors
-
counter
)
+
'
more
errors
.
'
;
break
;
}
}
failDetail
+
=
'
\
n
'
+
'
\
tMax
AbsError
of
'
+
maxAbsError
.
toExponential
(
16
)
+
'
at
index
of
'
+
maxAbsErrorIndex
+
'
.
\
n
'
;
if
(
printedIndices
.
find
(
element
=
>
{
return
element
=
=
maxAbsErrorIndex
;
}
)
=
=
=
undefined
)
{
failDetail
+
=
_formatFailureEntry
(
maxAbsErrorIndex
actual
[
maxAbsErrorIndex
]
expected
[
maxAbsErrorIndex
]
errors
[
maxAbsErrorIndex
]
_closeToThreshold
(
absErrorThreshold
relErrorThreshold
expected
[
maxAbsErrorIndex
]
)
)
+
'
\
n
'
;
}
failDetail
+
=
'
\
tMax
RelError
of
'
+
maxRelError
.
toExponential
(
16
)
+
'
at
index
of
'
+
maxRelErrorIndex
+
'
.
\
n
'
;
if
(
printedIndices
.
find
(
element
=
>
{
return
element
=
=
maxRelErrorIndex
;
}
)
=
=
=
undefined
)
{
failDetail
+
=
_formatFailureEntry
(
maxRelErrorIndex
actual
[
maxRelErrorIndex
]
expected
[
maxRelErrorIndex
]
errors
[
maxRelErrorIndex
]
_closeToThreshold
(
absErrorThreshold
relErrorThreshold
expected
[
maxRelErrorIndex
]
)
)
+
'
\
n
'
;
}
}
return
this
.
_assert
(
passed
passDetail
failDetail
)
;
}
message
(
passDetail
failDetail
)
{
return
this
.
_assert
(
this
.
_actual
'
{
actual
}
'
+
passDetail
'
{
actual
}
'
+
failDetail
)
;
}
haveOwnProperty
(
)
{
this
.
_processArguments
(
arguments
)
;
return
this
.
_assert
(
this
.
_actual
.
hasOwnProperty
(
this
.
_expected
)
'
{
actual
}
has
an
own
property
of
"
{
expected
}
"
.
'
'
{
actual
}
does
not
own
the
property
of
"
{
expected
}
"
.
'
)
;
}
notHaveOwnProperty
(
)
{
this
.
_processArguments
(
arguments
)
;
return
this
.
_assert
(
!
this
.
_actual
.
hasOwnProperty
(
this
.
_expected
)
'
{
actual
}
does
not
have
an
own
property
of
"
{
expected
}
"
.
'
'
{
actual
}
has
an
own
the
property
of
"
{
expected
}
"
.
'
)
}
inheritFrom
(
)
{
this
.
_processArguments
(
arguments
)
;
let
prototypes
=
[
]
;
let
currentPrototype
=
Object
.
getPrototypeOf
(
this
.
_actual
)
;
while
(
currentPrototype
)
{
prototypes
.
push
(
currentPrototype
.
constructor
.
name
)
;
currentPrototype
=
Object
.
getPrototypeOf
(
currentPrototype
)
;
}
return
this
.
_assert
(
prototypes
.
includes
(
this
.
_expected
)
'
{
actual
}
inherits
from
"
{
expected
}
"
.
'
'
{
actual
}
does
not
inherit
from
"
{
expected
}
"
.
'
)
;
}
}
const
TaskState
=
{
PENDING
:
0
STARTED
:
1
FINISHED
:
2
}
;
class
Task
{
constructor
(
taskRunner
taskLabel
taskFunction
)
{
this
.
_taskRunner
=
taskRunner
;
this
.
_taskFunction
=
taskFunction
;
if
(
typeof
taskLabel
=
=
=
'
string
'
)
{
this
.
_label
=
taskLabel
;
this
.
_description
=
null
;
}
else
if
(
typeof
taskLabel
=
=
=
'
object
'
)
{
if
(
typeof
taskLabel
.
label
!
=
=
'
string
'
)
{
_throwException
(
'
Task
.
constructor
:
:
task
label
must
be
string
.
'
)
;
}
this
.
_label
=
taskLabel
.
label
;
this
.
_description
=
(
typeof
taskLabel
.
description
=
=
=
'
string
'
)
?
taskLabel
.
description
:
null
;
}
else
{
_throwException
(
'
Task
.
constructor
:
:
task
label
must
be
a
string
or
'
+
'
a
dictionary
.
'
)
;
}
this
.
_state
=
TaskState
.
PENDING
;
this
.
_result
=
true
;
this
.
_totalAssertions
=
0
;
this
.
_failedAssertions
=
0
;
}
get
label
(
)
{
return
this
.
_label
;
}
get
state
(
)
{
return
this
.
_state
;
}
get
result
(
)
{
return
this
.
_result
;
}
should
(
actual
actualDescription
)
{
if
(
arguments
.
length
=
=
=
0
)
_throwException
(
'
Task
.
should
:
:
requires
at
least
1
argument
.
'
)
;
return
new
Should
(
this
actual
actualDescription
)
;
}
run
(
)
{
this
.
_state
=
TaskState
.
STARTED
;
_logPassed
(
'
>
[
'
+
this
.
_label
+
'
]
'
+
(
this
.
_description
?
this
.
_description
:
'
'
)
)
;
this
.
_taskFunction
(
this
this
.
should
.
bind
(
this
)
)
;
}
update
(
subTask
)
{
if
(
subTask
.
result
=
=
=
false
)
{
this
.
_result
=
false
;
this
.
_failedAssertions
+
+
;
}
this
.
_totalAssertions
+
+
;
}
done
(
)
{
this
.
_state
=
TaskState
.
FINISHED
;
let
message
=
'
<
[
'
+
this
.
_label
+
'
]
'
;
if
(
this
.
_result
)
{
message
+
=
'
All
assertions
passed
.
(
total
'
+
this
.
_totalAssertions
+
'
assertions
)
'
;
_logPassed
(
message
)
;
}
else
{
message
+
=
this
.
_failedAssertions
+
'
out
of
'
+
this
.
_totalAssertions
+
'
assertions
were
failed
.
'
_logFailed
(
message
)
;
}
this
.
_taskRunner
.
_runNextTask
(
)
;
}
isPassed
(
)
{
return
this
.
_state
=
=
=
TaskState
.
FINISHED
&
&
this
.
_result
;
}
toString
(
)
{
return
'
"
'
+
this
.
_label
+
'
"
:
'
+
this
.
_description
;
}
}
class
TaskRunner
{
constructor
(
)
{
this
.
_tasks
=
{
}
;
this
.
_taskSequence
=
[
]
;
this
.
_currentTaskIndex
=
-
1
;
setup
(
new
Function
(
)
{
explicit_done
:
true
}
)
;
}
_runNextTask
(
)
{
if
(
this
.
_currentTaskIndex
<
this
.
_taskSequence
.
length
)
{
this
.
_tasks
[
this
.
_taskSequence
[
this
.
_currentTaskIndex
+
+
]
]
.
run
(
)
;
}
else
{
this
.
_finish
(
)
;
}
}
_finish
(
)
{
let
numberOfFailures
=
0
;
for
(
let
taskIndex
in
this
.
_taskSequence
)
{
let
task
=
this
.
_tasks
[
this
.
_taskSequence
[
taskIndex
]
]
;
numberOfFailures
+
=
task
.
result
?
0
:
1
;
}
let
prefix
=
'
#
AUDIT
TASK
RUNNER
FINISHED
:
'
;
if
(
numberOfFailures
>
0
)
{
_logFailed
(
prefix
+
numberOfFailures
+
'
out
of
'
+
this
.
_taskSequence
.
length
+
'
tasks
were
failed
.
'
)
;
}
else
{
_logPassed
(
prefix
+
this
.
_taskSequence
.
length
+
'
tasks
ran
successfully
.
'
)
;
}
_testharnessDone
(
)
;
}
define
(
taskLabel
taskFunction
)
{
let
task
=
new
Task
(
this
taskLabel
taskFunction
)
;
if
(
this
.
_tasks
.
hasOwnProperty
(
task
.
label
)
)
{
_throwException
(
'
Audit
.
define
:
:
Duplicate
task
definition
.
'
)
;
return
;
}
this
.
_tasks
[
task
.
label
]
=
task
;
this
.
_taskSequence
.
push
(
task
.
label
)
;
}
run
(
)
{
_logPassed
(
'
#
AUDIT
TASK
RUNNER
STARTED
.
'
)
;
if
(
arguments
.
length
>
0
)
{
this
.
_taskSequence
=
[
]
;
for
(
let
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
let
taskLabel
=
arguments
[
i
]
;
if
(
!
this
.
_tasks
.
hasOwnProperty
(
taskLabel
)
)
{
_throwException
(
'
Audit
.
run
:
:
undefined
task
.
'
)
;
}
else
if
(
this
.
_taskSequence
.
includes
(
taskLabel
)
)
{
_throwException
(
'
Audit
.
run
:
:
duplicate
task
request
.
'
)
;
}
else
{
this
.
_taskSequence
.
push
(
taskLabel
)
;
}
}
}
if
(
this
.
_taskSequence
.
length
=
=
=
0
)
{
_throwException
(
'
Audit
.
run
:
:
no
task
to
run
.
'
)
;
return
;
}
this
.
_currentTaskIndex
=
0
;
this
.
_runNextTask
(
)
;
}
}
function
loadFileFromUrl
(
fileUrl
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
'
GET
'
fileUrl
true
)
;
xhr
.
responseType
=
'
arraybuffer
'
;
xhr
.
onload
=
(
)
=
>
{
if
(
xhr
.
status
=
=
=
200
|
|
xhr
.
status
=
=
=
0
)
{
resolve
(
xhr
.
response
)
;
}
else
{
let
errorMessage
=
'
loadFile
:
Request
failed
when
loading
'
+
fileUrl
+
'
.
'
+
xhr
.
statusText
+
'
.
(
status
=
'
+
xhr
.
status
+
'
)
'
;
if
(
reject
)
{
reject
(
errorMessage
)
;
}
else
{
new
Error
(
errorMessage
)
;
}
}
}
;
xhr
.
onerror
=
(
event
)
=
>
{
let
errorMessage
=
'
loadFile
:
Network
failure
when
loading
'
+
fileUrl
+
'
.
'
;
if
(
reject
)
{
reject
(
errorMessage
)
;
}
else
{
new
Error
(
errorMessage
)
;
}
}
;
xhr
.
send
(
)
;
}
)
;
}
return
{
createTaskRunner
:
function
(
options
)
{
if
(
options
&
&
options
.
requireResultFile
=
=
true
)
{
_logError
(
'
this
test
requires
the
explicit
comparison
with
the
'
+
'
expected
result
when
it
runs
with
run_web_tests
.
py
.
'
)
;
}
return
new
TaskRunner
(
)
;
}
loadFileFromUrl
:
loadFileFromUrl
}
;
}
)
(
)
;
