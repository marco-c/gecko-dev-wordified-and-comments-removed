let
RENDER_QUANTUM_FRAMES
=
128
;
function
compareBuffersWithConstraints
(
should
actual
expected
options
)
{
if
(
!
options
)
options
=
{
}
;
if
(
actual
.
length
!
=
=
expected
.
length
)
{
should
(
actual
.
length
=
=
=
expected
.
length
'
Length
of
actual
and
expected
buffers
should
match
'
)
.
beTrue
(
)
;
}
let
maxError
=
-
1
;
let
diffCount
=
0
;
let
errorPosition
=
-
1
;
let
thresholdSNR
=
(
options
.
thresholdSNR
|
|
10000
)
;
let
thresholdDiffULP
=
(
options
.
thresholdDiffULP
|
|
0
)
;
let
thresholdDiffCount
=
(
options
.
thresholdDiffCount
|
|
0
)
;
let
bitDepth
=
(
options
.
bitDepth
|
|
16
)
;
let
scaleFactor
=
Math
.
pow
(
2
bitDepth
-
1
)
;
let
noisePower
=
0
signalPower
=
0
;
for
(
let
i
=
0
;
i
<
actual
.
length
;
i
+
+
)
{
let
diff
=
actual
[
i
]
-
expected
[
i
]
;
noisePower
+
=
diff
*
diff
;
signalPower
+
=
expected
[
i
]
*
expected
[
i
]
;
if
(
Math
.
abs
(
diff
)
>
maxError
)
{
maxError
=
Math
.
abs
(
diff
)
;
errorPosition
=
i
;
}
if
(
Math
.
abs
(
diff
)
>
scaleFactor
)
diffCount
+
+
;
}
let
snr
=
10
*
Math
.
log10
(
signalPower
/
noisePower
)
;
let
maxErrorULP
=
maxError
*
scaleFactor
;
should
(
snr
'
SNR
'
)
.
beGreaterThanOrEqualTo
(
thresholdSNR
)
;
should
(
maxErrorULP
options
.
prefix
+
'
:
Maximum
difference
(
in
ulp
units
(
'
+
bitDepth
+
'
-
bits
)
)
'
)
.
beLessThanOrEqualTo
(
thresholdDiffULP
)
;
should
(
diffCount
options
.
prefix
+
'
:
Number
of
differences
between
results
'
)
.
beLessThanOrEqualTo
(
thresholdDiffCount
)
;
}
function
createImpulseBuffer
(
context
sampleFrameLength
)
{
let
audioBuffer
=
context
.
createBuffer
(
1
sampleFrameLength
context
.
sampleRate
)
;
let
n
=
audioBuffer
.
length
;
let
dataL
=
audioBuffer
.
getChannelData
(
0
)
;
for
(
let
k
=
0
;
k
<
n
;
+
+
k
)
{
dataL
[
k
]
=
0
;
}
dataL
[
0
]
=
1
;
return
audioBuffer
;
}
function
createLinearRampBuffer
(
context
sampleFrameLength
)
{
let
audioBuffer
=
context
.
createBuffer
(
1
sampleFrameLength
context
.
sampleRate
)
;
let
n
=
audioBuffer
.
length
;
let
dataL
=
audioBuffer
.
getChannelData
(
0
)
;
for
(
let
i
=
0
;
i
<
n
;
+
+
i
)
dataL
[
i
]
=
i
/
n
;
return
audioBuffer
;
}
function
createConstantBuffer
(
context
sampleFrameLength
constantValue
)
{
let
channels
;
let
values
;
if
(
typeof
constantValue
=
=
=
'
number
'
)
{
channels
=
1
;
values
=
[
constantValue
]
;
}
else
{
channels
=
constantValue
.
length
;
values
=
constantValue
;
}
let
audioBuffer
=
context
.
createBuffer
(
channels
sampleFrameLength
context
.
sampleRate
)
;
let
n
=
audioBuffer
.
length
;
for
(
let
c
=
0
;
c
<
channels
;
+
+
c
)
{
let
data
=
audioBuffer
.
getChannelData
(
c
)
;
for
(
let
i
=
0
;
i
<
n
;
+
+
i
)
data
[
i
]
=
values
[
c
]
;
}
return
audioBuffer
;
}
function
createStereoImpulseBuffer
(
context
sampleFrameLength
)
{
let
audioBuffer
=
context
.
createBuffer
(
2
sampleFrameLength
context
.
sampleRate
)
;
let
n
=
audioBuffer
.
length
;
let
dataL
=
audioBuffer
.
getChannelData
(
0
)
;
let
dataR
=
audioBuffer
.
getChannelData
(
1
)
;
for
(
let
k
=
0
;
k
<
n
;
+
+
k
)
{
dataL
[
k
]
=
0
;
dataR
[
k
]
=
0
;
}
dataL
[
0
]
=
1
;
dataR
[
0
]
=
1
;
return
audioBuffer
;
}
function
timeToSampleFrame
(
time
sampleRate
)
{
return
Math
.
floor
(
0
.
5
+
time
*
sampleRate
)
;
}
function
grainLengthInSampleFrames
(
grainOffset
duration
sampleRate
)
{
let
startFrame
=
timeToSampleFrame
(
grainOffset
sampleRate
)
;
let
endFrame
=
timeToSampleFrame
(
grainOffset
+
duration
sampleRate
)
;
return
endFrame
-
startFrame
;
}
function
isValidNumber
(
x
)
{
return
!
isNaN
(
x
)
&
&
(
x
!
=
Infinity
)
&
&
(
x
!
=
-
Infinity
)
;
}
function
computeSNR
(
actual
expected
)
{
let
signalPower
=
0
;
let
noisePower
=
0
;
let
length
=
Math
.
min
(
actual
.
length
expected
.
length
)
;
for
(
let
k
=
0
;
k
<
length
;
+
+
k
)
{
let
diff
=
actual
[
k
]
-
expected
[
k
]
;
signalPower
+
=
expected
[
k
]
*
expected
[
k
]
;
noisePower
+
=
diff
*
diff
;
}
return
signalPower
/
noisePower
;
}
function
assert_constant_value
(
array
value
messagePrefix
=
'
'
)
{
for
(
let
i
=
0
;
i
<
array
.
length
;
+
+
i
)
{
if
(
Number
.
isNaN
(
value
)
)
{
assert_true
(
Number
.
isNaN
(
array
[
i
]
)
{
messagePrefix
}
entry
{
i
}
should
be
NaN
)
;
}
else
{
assert_equals
(
array
[
i
]
value
{
messagePrefix
}
entry
{
i
}
should
be
{
value
}
)
;
}
}
}
function
assert_array_equals_exact
(
actual
expected
message
)
{
assert_equals
(
actual
.
length
expected
.
length
'
Buffers
must
be
same
length
'
)
;
for
(
let
i
=
0
;
i
<
actual
.
length
;
+
+
i
)
{
assert_equals
(
actual
[
i
]
expected
[
i
]
{
message
}
(
at
index
{
i
}
)
)
;
}
}
function
assert_not_constant_value
(
array
constantValue
message
)
{
const
notAllSame
=
array
.
some
(
value
=
>
value
!
=
=
constantValue
)
;
assert_true
(
notAllSame
message
)
;
}
function
assert_strict_constant_value
(
array
constantValue
message
)
{
const
allSame
=
array
.
every
(
value
=
>
value
=
=
=
constantValue
)
;
assert_true
(
allSame
message
)
;
}
function
assert_array_approximately_equals
(
actual
expected
threshold
message
)
{
assert_equals
(
actual
.
length
expected
.
length
{
message
}
-
buffer
lengths
must
match
)
;
for
(
let
i
=
0
;
i
<
actual
.
length
;
+
+
i
)
{
assert_approx_equals
(
actual
[
i
]
expected
[
i
]
threshold
{
message
}
at
index
{
i
}
)
;
}
}
function
assert_close_to_array
(
actual
expected
epsilon
desc
)
{
assert_equals
(
actual
.
length
expected
.
length
{
desc
}
:
length
mismatch
)
;
for
(
let
i
=
0
;
i
<
actual
.
length
;
+
+
i
)
{
const
diff
=
Math
.
abs
(
actual
[
i
]
-
expected
[
i
]
)
;
assert_less_than_equal
(
diff
epsilon
{
desc
}
[
{
i
}
]
|
{
actual
[
i
]
}
-
{
expected
[
i
]
}
|
=
{
diff
}
>
{
epsilon
}
)
;
}
}
