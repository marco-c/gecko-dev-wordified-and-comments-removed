(
function
(
global
)
{
let
timeValueInfo
;
let
startingValueDelta
;
let
startEndValueChange
;
let
discontinuityThreshold
;
let
timeIntervalInternal
=
.
03
;
let
context
;
function
renderLength
(
numberOfTests
)
{
return
timeToSampleFrame
(
(
numberOfTests
+
1
)
*
timeInterval
sampleRate
)
;
}
function
createConstantArray
(
startTime
endTime
value
endValue
sampleRate
)
{
let
startFrame
=
timeToSampleFrame
(
startTime
sampleRate
)
;
let
endFrame
=
timeToSampleFrame
(
endTime
sampleRate
)
;
let
length
=
endFrame
-
startFrame
;
let
buffer
=
createConstantBuffer
(
context
length
value
)
;
return
buffer
.
getChannelData
(
0
)
;
}
function
getStartEndFrames
(
startTime
endTime
sampleRate
)
{
let
startFrame
=
Math
.
ceil
(
startTime
*
sampleRate
)
;
let
endFrame
=
Math
.
ceil
(
endTime
*
sampleRate
)
;
return
{
startFrame
:
startFrame
endFrame
:
endFrame
}
;
}
function
createLinearRampArray
(
startTime
endTime
startValue
endValue
sampleRate
)
{
let
frameInfo
=
getStartEndFrames
(
startTime
endTime
sampleRate
)
;
let
startFrame
=
frameInfo
.
startFrame
;
let
endFrame
=
frameInfo
.
endFrame
;
let
length
=
endFrame
-
startFrame
;
let
array
=
new
Array
(
length
)
;
let
step
=
Math
.
fround
(
(
endValue
-
startValue
)
/
(
endTime
-
startTime
)
/
sampleRate
)
;
let
start
=
Math
.
fround
(
startValue
+
(
endValue
-
startValue
)
*
(
startFrame
/
sampleRate
-
startTime
)
/
(
endTime
-
startTime
)
)
;
let
slope
=
(
endValue
-
startValue
)
/
(
endTime
-
startTime
)
;
for
(
k
=
0
;
k
<
length
;
+
+
k
)
{
let
t
=
(
startFrame
+
k
)
/
sampleRate
;
array
[
k
]
=
startValue
+
slope
*
(
t
-
startTime
)
;
}
return
array
;
}
function
createExponentialRampArray
(
startTime
endTime
startValue
endValue
sampleRate
)
{
let
deltaTime
=
endTime
-
startTime
;
let
frameInfo
=
getStartEndFrames
(
startTime
endTime
sampleRate
)
;
let
startFrame
=
frameInfo
.
startFrame
;
let
endFrame
=
frameInfo
.
endFrame
;
let
length
=
endFrame
-
startFrame
;
let
array
=
new
Array
(
length
)
;
let
ratio
=
endValue
/
startValue
;
for
(
let
k
=
0
;
k
<
length
;
+
+
k
)
{
let
t
=
Math
.
fround
(
(
startFrame
+
k
)
/
sampleRate
)
;
array
[
k
]
=
Math
.
fround
(
startValue
*
Math
.
pow
(
ratio
(
t
-
startTime
)
/
deltaTime
)
)
;
}
return
array
;
}
function
discreteTimeConstantForSampleRate
(
timeConstant
sampleRate
)
{
return
1
-
Math
.
exp
(
-
1
/
(
sampleRate
*
timeConstant
)
)
;
}
function
createExponentialApproachArray
(
startTime
endTime
startValue
targetValue
sampleRate
timeConstant
)
{
let
startFrameFloat
=
startTime
*
sampleRate
;
let
frameInfo
=
getStartEndFrames
(
startTime
endTime
sampleRate
)
;
let
startFrame
=
frameInfo
.
startFrame
;
let
endFrame
=
frameInfo
.
endFrame
;
let
length
=
Math
.
floor
(
endFrame
-
startFrame
)
;
let
array
=
new
Array
(
length
)
;
let
c
=
discreteTimeConstantForSampleRate
(
timeConstant
sampleRate
)
;
let
delta
=
startValue
-
targetValue
;
for
(
let
k
=
0
;
k
<
length
;
+
+
k
)
{
let
t
=
(
startFrame
+
k
)
/
sampleRate
;
let
value
=
targetValue
+
delta
*
Math
.
exp
(
-
(
t
-
startTime
)
/
timeConstant
)
;
array
[
k
]
=
value
;
}
return
array
;
}
function
createReferenceSineArray
(
startTime
endTime
startValue
endValue
sampleRate
)
{
let
curve
=
createSineWaveArray
(
endTime
-
startTime
freqHz
sineAmplitude
sampleRate
)
;
let
frameInfo
=
getStartEndFrames
(
startTime
endTime
sampleRate
)
;
let
startFrame
=
frameInfo
.
startFrame
;
let
endFrame
=
frameInfo
.
endFrame
;
let
length
=
Math
.
floor
(
endFrame
-
startFrame
)
;
let
array
=
new
Array
(
length
)
;
let
f
=
(
length
-
1
)
/
(
endTime
-
startTime
)
;
for
(
let
k
=
0
;
k
<
length
;
+
+
k
)
{
let
t
=
(
startFrame
+
k
)
/
sampleRate
;
let
indexFloat
=
f
*
(
t
-
startTime
)
;
let
index
=
Math
.
floor
(
indexFloat
)
;
if
(
index
+
1
<
length
)
{
let
v0
=
curve
[
index
]
;
let
v1
=
curve
[
index
+
1
]
;
array
[
k
]
=
v0
+
(
v1
-
v0
)
*
(
indexFloat
-
index
)
;
}
else
{
array
[
k
]
=
curve
[
length
-
1
]
;
}
}
return
array
;
}
function
createSineWaveArray
(
durationSeconds
freqHz
amplitude
sampleRate
)
{
let
length
=
timeToSampleFrame
(
durationSeconds
sampleRate
)
;
let
signal
=
new
Float32Array
(
length
)
;
let
omega
=
2
*
Math
.
PI
*
freqHz
/
sampleRate
;
let
halfAmplitude
=
amplitude
/
2
;
for
(
let
k
=
0
;
k
<
length
;
+
+
k
)
{
signal
[
k
]
=
halfAmplitude
+
halfAmplitude
*
Math
.
sin
(
omega
*
k
)
;
}
return
signal
;
}
function
endValueDelta
(
timeIntervalIndex
)
{
if
(
timeIntervalIndex
&
1
)
{
return
-
startEndValueChange
;
}
else
{
return
startEndValueChange
;
}
}
function
relativeErrorMetric
(
actual
expected
)
{
return
(
actual
-
expected
)
/
Math
.
abs
(
expected
)
;
}
function
differenceErrorMetric
(
actual
expected
)
{
return
actual
-
expected
;
}
function
valueUpdate
(
timeIntervalIndex
)
{
return
-
startingValueDelta
;
}
function
comparePartialSignals
(
should
rendered
expectedFunction
startTime
endTime
valueInfo
sampleRate
errorMetric
)
{
let
startSample
=
timeToSampleFrame
(
startTime
sampleRate
)
;
let
expected
=
expectedFunction
(
startTime
endTime
valueInfo
.
startValue
valueInfo
.
endValue
sampleRate
timeConstant
)
;
let
n
=
expected
.
length
;
let
maxError
=
-
1
;
let
maxErrorIndex
=
-
1
;
for
(
let
k
=
0
;
k
<
n
;
+
+
k
)
{
if
(
!
isValidNumber
(
rendered
[
startSample
+
k
]
)
)
{
maxError
=
Infinity
;
maxErrorIndex
=
startSample
+
k
;
should
(
isValidNumber
(
rendered
[
startSample
+
k
]
)
'
NaN
or
infinity
for
rendered
data
at
'
+
maxErrorIndex
)
.
beTrue
(
)
;
break
;
}
if
(
!
isValidNumber
(
expected
[
k
]
)
)
{
maxError
=
Infinity
;
maxErrorIndex
=
startSample
+
k
;
should
(
isValidNumber
(
expected
[
k
]
)
'
NaN
or
infinity
for
rendered
data
at
'
+
maxErrorIndex
)
.
beTrue
(
)
;
break
;
}
let
error
=
Math
.
abs
(
errorMetric
(
rendered
[
startSample
+
k
]
expected
[
k
]
)
)
;
if
(
error
>
maxError
)
{
maxError
=
error
;
maxErrorIndex
=
k
;
}
}
return
{
maxError
:
maxError
index
:
maxErrorIndex
expected
:
expected
}
;
}
function
verifyDiscontinuities
(
should
values
times
threshold
)
{
let
n
=
values
.
length
;
let
success
=
true
;
let
badLocations
=
0
;
let
breaks
=
[
]
;
for
(
let
k
=
1
;
k
<
n
;
+
+
k
)
{
if
(
Math
.
abs
(
values
[
k
]
-
values
[
k
-
1
]
)
>
threshold
)
{
breaks
.
push
(
k
)
;
}
}
let
testCount
;
if
(
breaks
.
length
>
=
numberOfTests
)
{
testCount
=
numberOfTests
-
1
;
should
(
breaks
.
length
'
Number
of
discontinuities
'
)
.
beLessThan
(
numberOfTests
)
;
success
=
false
;
}
else
{
testCount
=
breaks
.
length
;
}
for
(
let
k
=
0
;
k
<
testCount
;
+
+
k
)
{
let
expectedSampleFrame
=
timeToSampleFrame
(
times
[
k
+
1
]
sampleRate
)
;
if
(
breaks
[
k
]
!
=
expectedSampleFrame
)
{
success
=
false
;
+
+
badLocations
;
should
(
breaks
[
k
]
'
Discontinuity
at
index
'
)
.
beEqualTo
(
expectedSampleFrame
)
;
}
}
if
(
badLocations
)
{
should
(
badLocations
'
Number
of
discontinuites
at
incorrect
locations
'
)
.
beEqualTo
(
0
)
;
success
=
false
;
}
else
{
should
(
breaks
.
length
+
1
'
Number
of
tests
started
and
ended
at
the
correct
time
'
)
.
beEqualTo
(
numberOfTests
)
;
}
return
success
;
}
function
compareSignals
(
should
testName
maxError
renderedData
expectedFunction
timeValueInfo
breakThreshold
errorMetric
)
{
let
success
=
true
;
let
failedTestCount
=
0
;
let
times
=
timeValueInfo
.
times
;
let
values
=
timeValueInfo
.
values
;
let
n
=
values
.
length
;
let
expectedSignal
=
[
]
;
success
=
verifyDiscontinuities
(
should
renderedData
times
breakThreshold
)
;
for
(
let
k
=
0
;
k
<
n
;
+
+
k
)
{
let
result
=
comparePartialSignals
(
should
renderedData
expectedFunction
times
[
k
]
times
[
k
+
1
]
values
[
k
]
sampleRate
errorMetric
)
;
expectedSignal
=
expectedSignal
.
concat
(
Array
.
prototype
.
slice
.
call
(
result
.
expected
)
)
;
should
(
result
.
maxError
'
Max
error
for
test
'
+
k
+
'
at
offset
'
+
(
result
.
index
+
timeToSampleFrame
(
times
[
k
]
sampleRate
)
)
)
.
beLessThanOrEqualTo
(
maxError
)
;
}
should
(
failedTestCount
'
Number
of
failed
tests
with
an
acceptable
relative
tolerance
of
'
+
maxError
)
.
beEqualTo
(
0
)
;
}
function
checkResultFunction
(
task
should
testName
error
referenceFunction
jumpThreshold
errorMetric
)
{
return
function
(
event
)
{
let
buffer
=
event
.
renderedBuffer
;
renderedData
=
buffer
.
getChannelData
(
0
)
;
let
threshold
;
if
(
!
jumpThreshold
)
{
threshold
=
discontinuityThreshold
;
}
else
{
threshold
=
jumpThreshold
;
}
compareSignals
(
should
testName
error
renderedData
referenceFunction
timeValueInfo
threshold
errorMetric
)
;
task
.
done
(
)
;
}
}
function
doAutomation
(
numberOfTests
initialValue
setValueFunction
automationFunction
)
{
let
timeInfo
=
[
0
]
;
let
valueInfo
=
[
]
;
let
value
=
initialValue
;
for
(
let
k
=
0
;
k
<
numberOfTests
;
+
+
k
)
{
let
startTime
=
k
*
timeInterval
;
let
endTime
=
(
k
+
1
)
*
timeInterval
;
let
endValue
=
value
+
endValueDelta
(
k
)
;
setValueFunction
(
value
startTime
)
;
automationFunction
(
endValue
startTime
endTime
)
;
timeInfo
.
push
(
endTime
)
;
valueInfo
.
push
(
{
startValue
:
value
endValue
:
endValue
}
)
;
value
+
=
valueUpdate
(
k
)
;
}
return
{
times
:
timeInfo
values
:
valueInfo
}
;
}
function
createAudioGraphAndTest
(
task
should
numberOfTests
initialValue
setValueFunction
automationFunction
testName
maxError
referenceFunction
jumpThreshold
errorMetric
)
{
context
=
new
OfflineAudioContext
(
2
renderLength
(
numberOfTests
)
sampleRate
)
;
let
constantBuffer
=
createConstantBuffer
(
context
renderLength
(
numberOfTests
)
1
)
;
gainNode
=
context
.
createGain
(
)
;
let
bufferSource
=
context
.
createBufferSource
(
)
;
bufferSource
.
buffer
=
constantBuffer
;
bufferSource
.
connect
(
gainNode
)
;
gainNode
.
connect
(
context
.
destination
)
;
startingValueDelta
=
initialValue
/
numberOfTests
;
startEndValueChange
=
startingValueDelta
/
2
;
discontinuityThreshold
=
startEndValueChange
/
2
;
timeValueInfo
=
doAutomation
(
numberOfTests
initialValue
setValueFunction
automationFunction
)
;
bufferSource
.
start
(
0
)
;
context
.
oncomplete
=
checkResultFunction
(
task
should
testName
maxError
referenceFunction
jumpThreshold
errorMetric
|
|
relativeErrorMetric
)
;
context
.
startRendering
(
)
;
}
let
exports
=
{
'
sampleRate
'
:
44100
'
gainNode
'
:
null
'
timeInterval
'
:
timeIntervalInternal
'
timeConstant
'
:
timeIntervalInternal
/
3
'
renderLength
'
:
renderLength
'
createConstantArray
'
:
createConstantArray
'
getStartEndFrames
'
:
getStartEndFrames
'
createLinearRampArray
'
:
createLinearRampArray
'
createExponentialRampArray
'
:
createExponentialRampArray
'
discreteTimeConstantForSampleRate
'
:
discreteTimeConstantForSampleRate
'
createExponentialApproachArray
'
:
createExponentialApproachArray
'
createReferenceSineArray
'
:
createReferenceSineArray
'
createSineWaveArray
'
:
createSineWaveArray
'
endValueDelta
'
:
endValueDelta
'
relativeErrorMetric
'
:
relativeErrorMetric
'
differenceErrorMetric
'
:
differenceErrorMetric
'
valueUpdate
'
:
valueUpdate
'
comparePartialSignals
'
:
comparePartialSignals
'
verifyDiscontinuities
'
:
verifyDiscontinuities
'
compareSignals
'
:
compareSignals
'
checkResultFunction
'
:
checkResultFunction
'
doAutomation
'
:
doAutomation
'
createAudioGraphAndTest
'
:
createAudioGraphAndTest
}
;
for
(
let
reference
in
exports
)
{
global
[
reference
]
=
exports
[
reference
]
;
}
}
)
(
window
)
;
