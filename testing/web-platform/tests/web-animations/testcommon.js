'
use
strict
'
;
const
MS_PER_SEC
=
1000
;
const
TIME_PRECISION
=
0
.
0005
;
if
(
!
window
.
assert_times_equal
)
{
window
.
assert_times_equal
=
(
actual
expected
description
)
=
>
{
assert_approx_equals
(
actual
expected
TIME_PRECISION
*
2
description
)
;
}
;
}
if
(
!
window
.
assert_time_equals_literal
)
{
window
.
assert_time_equals_literal
=
(
actual
expected
description
)
=
>
{
if
(
Math
.
abs
(
expected
)
=
=
=
Infinity
)
{
assert_equals
(
actual
expected
description
)
;
}
else
{
assert_approx_equals
(
actual
expected
TIME_PRECISION
description
)
;
}
}
}
function
createDiv
(
test
doc
)
{
return
createElement
(
test
'
div
'
doc
)
;
}
function
createElement
(
test
tagName
doc
)
{
if
(
!
doc
)
{
doc
=
document
;
}
const
element
=
doc
.
createElement
(
tagName
|
|
'
div
'
)
;
doc
.
body
.
appendChild
(
element
)
;
test
.
add_cleanup
(
(
)
=
>
{
element
.
remove
(
)
;
}
)
;
return
element
;
}
function
createStyle
(
test
rules
doc
)
{
if
(
!
doc
)
{
doc
=
document
;
}
const
extraStyle
=
doc
.
createElement
(
'
style
'
)
;
doc
.
head
.
appendChild
(
extraStyle
)
;
if
(
rules
)
{
const
sheet
=
extraStyle
.
sheet
;
for
(
const
selector
in
rules
)
{
sheet
.
insertRule
(
{
selector
}
{
{
rules
[
selector
]
}
}
sheet
.
cssRules
.
length
)
;
}
}
test
.
add_cleanup
(
(
)
=
>
{
extraStyle
.
remove
(
)
;
}
)
;
}
function
cubicBezier
(
x1
y1
x2
y2
)
{
const
xForT
=
t
=
>
{
const
omt
=
1
-
t
;
return
3
*
omt
*
omt
*
t
*
x1
+
3
*
omt
*
t
*
t
*
x2
+
t
*
t
*
t
;
}
;
const
yForT
=
t
=
>
{
const
omt
=
1
-
t
;
return
3
*
omt
*
omt
*
t
*
y1
+
3
*
omt
*
t
*
t
*
y2
+
t
*
t
*
t
;
}
;
const
tForX
=
x
=
>
{
let
mint
=
0
maxt
=
1
;
for
(
let
i
=
0
;
i
<
30
;
+
+
i
)
{
const
guesst
=
(
mint
+
maxt
)
/
2
;
const
guessx
=
xForT
(
guesst
)
;
if
(
x
<
guessx
)
{
maxt
=
guesst
;
}
else
{
mint
=
guesst
;
}
}
return
(
mint
+
maxt
)
/
2
;
}
;
return
x
=
>
{
if
(
x
=
=
0
)
{
return
0
;
}
if
(
x
=
=
1
)
{
return
1
;
}
return
yForT
(
tForX
(
x
)
)
;
}
;
}
function
stepEnd
(
nsteps
)
{
return
x
=
>
Math
.
floor
(
x
*
nsteps
)
/
nsteps
;
}
function
stepStart
(
nsteps
)
{
return
x
=
>
{
const
result
=
Math
.
floor
(
x
*
nsteps
+
1
.
0
)
/
nsteps
;
return
(
result
>
1
.
0
)
?
1
.
0
:
result
;
}
;
}
function
waitForAnimationFrames
(
frameCount
)
{
return
new
Promise
(
resolve
=
>
{
function
handleFrame
(
)
{
if
(
-
-
frameCount
<
=
0
)
{
resolve
(
)
;
}
else
{
window
.
requestAnimationFrame
(
handleFrame
)
;
}
}
window
.
requestAnimationFrame
(
handleFrame
)
;
}
)
;
}
function
waitForAnimationFramesWithDelay
(
minDelay
)
{
const
startTime
=
document
.
timeline
.
currentTime
;
return
new
Promise
(
resolve
=
>
{
(
function
handleFrame
(
)
{
if
(
document
.
timeline
.
currentTime
-
startTime
>
=
minDelay
)
{
resolve
(
)
;
}
else
{
window
.
requestAnimationFrame
(
handleFrame
)
;
}
}
(
)
)
;
}
)
;
}
function
waitForNextFrame
(
)
{
const
timeAtStart
=
document
.
timeline
.
currentTime
;
return
new
Promise
(
resolve
=
>
{
(
function
handleFrame
(
)
{
if
(
timeAtStart
=
=
=
document
.
timeline
.
currentTime
)
{
window
.
requestAnimationFrame
(
handleFrame
)
;
}
else
{
resolve
(
)
;
}
}
(
)
)
;
}
)
;
}
function
createMatrixFromArray
(
array
)
{
return
(
array
.
length
=
=
16
?
'
matrix3d
'
:
'
matrix
'
)
+
(
{
array
.
join
(
)
}
)
;
}
function
rotate3dToMatrix3d
(
x
y
z
radian
)
{
return
createMatrixFromArray
(
rotate3dToMatrix
(
x
y
z
radian
)
)
;
}
function
rotate3dToMatrix
(
x
y
z
radian
)
{
const
sc
=
Math
.
sin
(
radian
/
2
)
*
Math
.
cos
(
radian
/
2
)
;
const
sq
=
Math
.
sin
(
radian
/
2
)
*
Math
.
sin
(
radian
/
2
)
;
const
length
=
Math
.
sqrt
(
x
*
x
+
y
*
y
+
z
*
z
)
;
x
/
=
length
;
y
/
=
length
;
z
/
=
length
;
return
[
1
-
2
*
(
y
*
y
+
z
*
z
)
*
sq
2
*
(
x
*
y
*
sq
+
z
*
sc
)
2
*
(
x
*
z
*
sq
-
y
*
sc
)
0
2
*
(
x
*
y
*
sq
-
z
*
sc
)
1
-
2
*
(
x
*
x
+
z
*
z
)
*
sq
2
*
(
y
*
z
*
sq
+
x
*
sc
)
0
2
*
(
x
*
z
*
sq
+
y
*
sc
)
2
*
(
y
*
z
*
sq
-
x
*
sc
)
1
-
2
*
(
x
*
x
+
y
*
y
)
*
sq
0
0
0
0
1
]
;
}
function
assert_matrix_equals
(
actual
expected
description
)
{
const
matrixRegExp
=
/
^
matrix
(
?
:
3d
)
*
\
(
(
.
+
)
\
)
/
;
assert_regexp_match
(
actual
matrixRegExp
'
Actual
value
is
not
a
matrix
'
)
assert_regexp_match
(
expected
matrixRegExp
'
Expected
value
is
not
a
matrix
'
)
;
const
actualMatrixArray
=
actual
.
match
(
matrixRegExp
)
[
1
]
.
split
(
'
'
)
.
map
(
Number
)
;
const
expectedMatrixArray
=
expected
.
match
(
matrixRegExp
)
[
1
]
.
split
(
'
'
)
.
map
(
Number
)
;
assert_equals
(
actualMatrixArray
.
length
expectedMatrixArray
.
length
dimension
of
the
matrix
:
{
description
}
)
;
for
(
let
i
=
0
;
i
<
actualMatrixArray
.
length
;
i
+
+
)
{
assert_approx_equals
(
actualMatrixArray
[
i
]
expectedMatrixArray
[
i
]
0
.
0001
expected
{
expected
}
but
got
{
actual
}
:
{
description
}
)
;
}
}
function
assert_rotate3d_equals
(
actual
expected
description
)
{
const
rotationRegExp
=
/
^
(
(
(
[
+
-
]
?
\
d
+
(
\
.
+
\
d
+
)
?
\
s
)
{
3
}
)
?
\
d
+
(
\
.
+
\
d
+
)
?
)
deg
/
;
assert_regexp_match
(
actual
rotationRegExp
'
Actual
value
is
not
a
rotate3d
vector
'
)
assert_regexp_match
(
expected
rotationRegExp
'
Expected
value
is
not
a
rotate3d
vector
'
)
;
const
actualRotationVector
=
actual
.
match
(
rotationRegExp
)
[
1
]
.
split
(
'
'
)
.
map
(
Number
)
;
const
expectedRotationVector
=
expected
.
match
(
rotationRegExp
)
[
1
]
.
split
(
'
'
)
.
map
(
Number
)
;
assert_equals
(
actualRotationVector
.
length
expectedRotationVector
.
length
dimension
of
the
matrix
:
{
description
}
)
;
for
(
let
i
=
0
;
i
<
actualRotationVector
.
length
;
i
+
+
)
{
assert_approx_equals
(
actualRotationVector
[
i
]
expectedRotationVector
[
i
]
0
.
0001
expected
{
expected
}
but
got
{
actual
}
:
{
description
}
)
;
}
}
