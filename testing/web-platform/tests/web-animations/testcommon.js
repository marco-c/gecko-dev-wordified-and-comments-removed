'
use
strict
'
;
var
MS_PER_SEC
=
1000
;
var
TIME_PRECISION
=
0
.
0005
;
if
(
!
window
.
assert_times_equal
)
{
window
.
assert_times_equal
=
function
(
actual
expected
description
)
{
assert_approx_equals
(
actual
expected
TIME_PRECISION
description
)
;
}
}
function
createDiv
(
test
doc
)
{
return
createElement
(
test
'
div
'
doc
)
;
}
function
createElement
(
test
tagName
doc
)
{
if
(
!
doc
)
{
doc
=
document
;
}
var
element
=
doc
.
createElement
(
tagName
|
|
'
div
'
)
;
doc
.
body
.
appendChild
(
element
)
;
test
.
add_cleanup
(
function
(
)
{
element
.
remove
(
)
;
}
)
;
return
element
;
}
function
createStyle
(
test
rules
doc
)
{
if
(
!
doc
)
{
doc
=
document
;
}
var
extraStyle
=
doc
.
createElement
(
'
style
'
)
;
doc
.
head
.
appendChild
(
extraStyle
)
;
if
(
rules
)
{
var
sheet
=
extraStyle
.
sheet
;
for
(
var
selector
in
rules
)
{
sheet
.
insertRule
(
selector
+
'
{
'
+
rules
[
selector
]
+
'
}
'
sheet
.
cssRules
.
length
)
;
}
}
test
.
add_cleanup
(
function
(
)
{
extraStyle
.
remove
(
)
;
}
)
;
}
function
createPseudo
(
test
type
)
{
createStyle
(
test
{
'
keyframes
anim
'
:
'
'
[
'
.
pseudo
:
:
'
+
type
]
:
'
animation
:
anim
10s
;
'
}
)
;
var
div
=
createDiv
(
test
)
;
div
.
classList
.
add
(
'
pseudo
'
)
;
var
anims
=
document
.
getAnimations
(
)
;
assert_true
(
anims
.
length
>
=
1
)
;
var
anim
=
anims
[
anims
.
length
-
1
]
;
assert_equals
(
anim
.
effect
.
target
.
parentElement
div
)
;
assert_equals
(
anim
.
effect
.
target
.
type
'
:
:
'
+
type
)
;
anim
.
cancel
(
)
;
return
anim
.
effect
.
target
;
}
function
pxToNum
(
str
)
{
return
Number
(
String
(
str
)
.
match
(
/
^
(
-
?
[
\
d
.
]
+
)
px
/
)
[
1
]
)
;
}
function
cubicBezier
(
x1
y1
x2
y2
)
{
function
xForT
(
t
)
{
var
omt
=
1
-
t
;
return
3
*
omt
*
omt
*
t
*
x1
+
3
*
omt
*
t
*
t
*
x2
+
t
*
t
*
t
;
}
function
yForT
(
t
)
{
var
omt
=
1
-
t
;
return
3
*
omt
*
omt
*
t
*
y1
+
3
*
omt
*
t
*
t
*
y2
+
t
*
t
*
t
;
}
function
tForX
(
x
)
{
var
mint
=
0
maxt
=
1
;
for
(
var
i
=
0
;
i
<
30
;
+
+
i
)
{
var
guesst
=
(
mint
+
maxt
)
/
2
;
var
guessx
=
xForT
(
guesst
)
;
if
(
x
<
guessx
)
{
maxt
=
guesst
;
}
else
{
mint
=
guesst
;
}
}
return
(
mint
+
maxt
)
/
2
;
}
return
function
bezierClosure
(
x
)
{
if
(
x
=
=
0
)
{
return
0
;
}
if
(
x
=
=
1
)
{
return
1
;
}
return
yForT
(
tForX
(
x
)
)
;
}
}
function
stepEnd
(
nsteps
)
{
return
function
stepEndClosure
(
x
)
{
return
Math
.
floor
(
x
*
nsteps
)
/
nsteps
;
}
}
function
stepStart
(
nsteps
)
{
return
function
stepStartClosure
(
x
)
{
var
result
=
Math
.
floor
(
x
*
nsteps
+
1
.
0
)
/
nsteps
;
return
(
result
>
1
.
0
)
?
1
.
0
:
result
;
}
}
function
waitForAnimationFrames
(
frameCount
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
function
handleFrame
(
)
{
if
(
-
-
frameCount
<
=
0
)
{
resolve
(
)
;
}
else
{
window
.
requestAnimationFrame
(
handleFrame
)
;
}
}
window
.
requestAnimationFrame
(
handleFrame
)
;
}
)
;
}
function
waitForAnimationFramesWithDelay
(
minDelay
)
{
var
startTime
=
document
.
timeline
.
currentTime
;
return
new
Promise
(
function
(
resolve
)
{
(
function
handleFrame
(
)
{
if
(
document
.
timeline
.
currentTime
-
startTime
>
=
minDelay
)
{
resolve
(
)
;
}
else
{
window
.
requestAnimationFrame
(
handleFrame
)
;
}
}
(
)
)
;
}
)
;
}
