'
use
strict
'
;
const
standard_fonts_tests
=
[
{
}
{
select
:
[
]
}
]
;
for
(
const
test
of
standard_fonts_tests
)
{
const
inputAsString
=
JSON
.
stringify
(
test
)
?
JSON
.
stringify
(
test
)
:
test
;
font_access_test
(
async
t
=
>
{
const
fonts
=
await
navigator
.
fonts
.
query
(
test
)
;
assert_fonts_exist
(
fonts
getEnumerationTestSet
(
)
)
;
}
query
(
)
:
standard
fonts
returned
for
input
:
{
inputAsString
}
)
;
}
font_access_test
(
async
t
=
>
{
const
fonts
=
await
navigator
.
fonts
.
query
(
)
;
let
previousFont
=
null
;
for
(
const
font
of
fonts
)
{
if
(
previousFont
)
{
assert_true
(
previousFont
.
postscriptName
<
font
.
postscriptName
font
is
not
in
expected
order
.
expected
:
{
previousFont
.
postscriptName
}
<
{
font
.
postscriptName
}
)
;
}
previousFont
=
font
;
}
}
'
query
(
)
:
fonts
are
sorted
'
)
;
font_access_test
(
async
t
=
>
{
const
test
=
{
select
:
[
getEnumerationTestSet
(
)
[
0
]
.
postscriptName
]
}
;
const
fonts
=
await
navigator
.
fonts
.
query
(
test
)
;
assert_postscript_name_exists
(
fonts
test
.
select
)
;
assert_equals
(
fonts
.
length
test
.
select
.
length
'
The
result
length
should
match
the
test
length
.
'
)
;
}
'
query
(
)
:
fonts
are
selected
for
input
'
)
;
const
non_ascii_input
=
[
{
select
:
[
'
'
]
}
{
select
:
[
'
'
]
}
{
select
:
[
'
'
]
}
{
select
:
[
'
\
u6841
\
u6d65
'
]
}
{
select
:
[
'
\
u6C34
'
]
}
{
select
:
[
'
\
uD834
\
uDD1E
'
]
}
{
select
:
[
'
\
uFFFD
'
]
}
{
select
:
[
'
\
uD800
'
]
}
{
select
:
[
'
\
uDC00
'
]
}
]
;
for
(
const
test
of
non_ascii_input
)
{
font_access_test
(
async
t
=
>
{
const
fonts
=
await
navigator
.
fonts
.
query
(
test
)
;
assert_equals
(
fonts
.
length
0
There
should
be
no
results
.
Instead
got
:
{
JSON
.
stringify
(
fonts
)
}
)
;
}
query
(
)
:
No
match
for
input
:
{
JSON
.
stringify
(
test
)
}
)
;
}
