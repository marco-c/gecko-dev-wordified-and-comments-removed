'
use
strict
'
;
const
alphabet
=
'
abcdefghijklmnopqrstuvwxyz
'
.
split
(
'
'
)
;
const
ALPHABET
=
'
ABCDEFGHIJKLMNOPQRSTUVWXYZ
'
.
split
(
'
'
)
;
const
vowels
=
'
aeiou
'
.
split
(
'
'
)
;
function
object_store_get_all_test_setup
(
storeName
callback
testDescription
)
{
const
expectedRecords
=
[
]
;
indexeddb_test
(
(
test
connection
)
=
>
{
switch
(
storeName
)
{
case
'
generated
'
:
{
const
store
=
connection
.
createObjectStore
(
storeName
{
autoIncrement
:
true
keyPath
:
'
id
'
}
)
;
alphabet
.
forEach
(
letter
=
>
{
store
.
put
(
{
ch
:
letter
}
)
;
const
generatedKey
=
alphabet
.
indexOf
(
letter
)
+
1
;
expectedRecords
.
push
(
{
key
:
generatedKey
primaryKey
:
generatedKey
value
:
{
ch
:
letter
}
}
)
;
}
)
;
return
;
}
case
'
out
-
of
-
line
'
:
{
const
store
=
connection
.
createObjectStore
(
storeName
)
;
alphabet
.
forEach
(
letter
=
>
{
store
.
put
(
value
-
{
letter
}
letter
)
;
expectedRecords
.
push
(
{
key
:
letter
primaryKey
:
letter
value
:
value
-
{
letter
}
}
)
;
}
)
;
return
;
}
case
'
empty
'
:
{
connection
.
createObjectStore
(
storeName
)
;
return
;
}
case
'
large
-
values
'
:
{
const
store
=
connection
.
createObjectStore
(
storeName
)
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
const
value
=
largeValue
(
wrapThreshold
i
)
;
store
.
put
(
value
i
)
;
expectedRecords
.
push
(
{
key
:
i
primaryKey
:
i
value
}
)
;
}
return
;
}
}
}
(
test
connection
)
=
>
{
callback
(
test
connection
expectedRecords
)
;
}
testDescription
)
;
}
function
index_get_all_test_setup
(
storeName
callback
testDescription
)
{
const
expectedRecords
=
[
]
;
indexeddb_test
(
function
(
test
connection
)
{
switch
(
storeName
)
{
case
'
generated
'
:
{
const
store
=
connection
.
createObjectStore
(
storeName
{
autoIncrement
:
true
keyPath
:
'
id
'
}
)
;
store
.
createIndex
(
'
test_idx
'
'
upper
'
)
;
alphabet
.
forEach
(
function
(
letter
)
{
const
value
=
{
ch
:
letter
upper
:
letter
.
toUpperCase
(
)
}
;
store
.
put
(
value
)
;
const
generatedKey
=
alphabet
.
indexOf
(
letter
)
+
1
;
expectedRecords
.
push
(
{
key
:
value
.
upper
primaryKey
:
generatedKey
value
}
)
;
}
)
;
return
;
}
case
'
out
-
of
-
line
'
:
{
const
store
=
connection
.
createObjectStore
(
storeName
)
;
store
.
createIndex
(
'
test_idx
'
'
upper
'
)
;
alphabet
.
forEach
(
function
(
letter
)
{
const
value
=
{
ch
:
letter
upper
:
letter
.
toUpperCase
(
)
}
;
store
.
put
(
value
letter
)
;
expectedRecords
.
push
(
{
key
:
value
.
upper
primaryKey
:
letter
value
}
)
;
}
)
;
return
;
}
case
'
out
-
of
-
line
-
not
-
unique
'
:
{
const
store
=
connection
.
createObjectStore
(
storeName
)
;
store
.
createIndex
(
'
test_idx
'
'
half
'
)
;
alphabet
.
forEach
(
function
(
letter
)
{
let
half
=
'
first
'
;
if
(
letter
>
'
m
'
)
{
half
=
'
second
'
;
}
const
value
=
{
ch
:
letter
half
}
;
store
.
put
(
value
letter
)
;
expectedRecords
.
push
(
{
key
:
half
primaryKey
:
letter
value
}
)
;
}
)
;
return
}
case
'
out
-
of
-
line
-
multi
'
:
{
const
store
=
connection
.
createObjectStore
(
storeName
)
;
store
.
createIndex
(
'
test_idx
'
'
attribs
'
{
multiEntry
:
true
}
)
;
alphabet
.
forEach
(
function
(
letter
)
{
let
attrs
=
[
]
;
if
(
[
'
a
'
'
e
'
'
i
'
'
o
'
'
u
'
]
.
indexOf
(
letter
)
!
=
-
1
)
{
attrs
.
push
(
'
vowel
'
)
;
}
else
{
attrs
.
push
(
'
consonant
'
)
;
}
if
(
letter
=
=
'
a
'
)
{
attrs
.
push
(
'
first
'
)
;
}
if
(
letter
=
=
'
z
'
)
{
attrs
.
push
(
'
last
'
)
;
}
const
value
=
{
ch
:
letter
attribs
:
attrs
}
;
store
.
put
(
value
letter
)
;
for
(
let
attr
of
attrs
)
{
expectedRecords
.
push
(
{
key
:
attr
primaryKey
:
letter
value
}
)
;
}
}
)
;
return
;
}
case
'
empty
'
:
{
const
store
=
connection
.
createObjectStore
(
storeName
)
;
store
.
createIndex
(
'
test_idx
'
'
upper
'
)
;
return
;
}
case
'
large
-
values
'
:
{
const
store
=
connection
.
createObjectStore
(
'
large
-
values
'
)
;
store
.
createIndex
(
'
test_idx
'
'
seed
'
)
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
const
seed
=
i
;
const
randomValue
=
largeValue
(
wrapThreshold
seed
)
;
const
recordValue
=
{
seed
randomValue
}
;
store
.
put
(
recordValue
i
)
;
expectedRecords
.
push
(
{
key
:
seed
primaryKey
:
i
value
:
recordValue
}
)
;
}
return
;
}
default
:
{
test
.
assert_unreached
(
Unknown
storeName
:
{
storeName
}
)
;
}
}
}
(
test
connection
)
=
>
{
callback
(
test
connection
expectedRecords
)
;
}
testDescription
)
;
}
function
get_all_test
(
getAllFunctionName
storeName
optionalIndexName
options
shouldUseDictionaryArgument
testDescription
)
{
const
testGetAllCallback
=
(
test
connection
expectedRecords
)
=
>
{
const
transaction
=
connection
.
transaction
(
storeName
'
readonly
'
)
;
let
queryTarget
=
transaction
.
objectStore
(
storeName
)
;
if
(
optionalIndexName
)
{
queryTarget
=
queryTarget
.
index
(
optionalIndexName
)
;
}
const
request
=
createGetAllRequest
(
getAllFunctionName
queryTarget
options
shouldUseDictionaryArgument
)
;
request
.
onerror
=
test
.
unreached_func
(
'
The
get
all
request
must
succeed
'
)
;
request
.
onsuccess
=
test
.
step_func
(
event
=
>
{
const
actualResults
=
event
.
target
.
result
;
const
expectedResults
=
calculateExpectedGetAllResults
(
getAllFunctionName
expectedRecords
options
)
;
verifyGetAllResults
(
getAllFunctionName
actualResults
expectedResults
)
;
test
.
done
(
)
;
}
)
;
}
;
if
(
optionalIndexName
)
{
index_get_all_test_setup
(
storeName
testGetAllCallback
testDescription
)
;
}
else
{
object_store_get_all_test_setup
(
storeName
testGetAllCallback
testDescription
)
;
}
}
function
object_store_get_all_keys_test
(
storeName
options
testDescription
)
{
get_all_test
(
'
getAllKeys
'
storeName
undefined
options
false
testDescription
)
;
}
function
object_store_get_all_values_test
(
storeName
options
testDescription
)
{
get_all_test
(
'
getAll
'
storeName
undefined
options
false
testDescription
)
;
}
function
object_store_get_all_values_with_options_test
(
storeName
options
testDescription
)
{
get_all_test
(
'
getAll
'
storeName
undefined
options
true
testDescription
)
;
}
function
object_store_get_all_keys_with_options_test
(
storeName
options
testDescription
)
{
get_all_test
(
'
getAllKeys
'
storeName
undefined
options
true
testDescription
)
;
}
function
object_store_get_all_records_test
(
storeName
options
testDescription
)
{
get_all_test
(
'
getAllRecords
'
storeName
undefined
options
true
testDescription
)
;
}
function
index_get_all_keys_test
(
storeName
options
testDescription
)
{
get_all_test
(
'
getAllKeys
'
storeName
'
test_idx
'
options
false
testDescription
)
;
}
function
index_get_all_keys_with_options_test
(
storeName
options
testDescription
)
{
get_all_test
(
'
getAllKeys
'
storeName
'
test_idx
'
options
true
testDescription
)
;
}
function
index_get_all_values_test
(
storeName
options
testDescription
)
{
get_all_test
(
'
getAll
'
storeName
'
test_idx
'
options
false
testDescription
)
;
}
function
index_get_all_values_with_options_test
(
storeName
options
testDescription
)
{
get_all_test
(
'
getAll
'
storeName
'
test_idx
'
options
true
testDescription
)
;
}
function
index_get_all_records_test
(
storeName
options
testDescription
)
{
get_all_test
(
'
getAllRecords
'
storeName
'
test_idx
'
options
true
testDescription
)
;
}
function
createGetAllRequest
(
getAllFunctionName
queryTarget
options
shouldUseDictionaryArgument
)
{
if
(
options
&
&
shouldUseDictionaryArgument
)
{
assert_true
(
'
getAllRecords
'
in
queryTarget
"
{
queryTarget
}
"
must
support
"
getAllRecords
(
)
"
to
use
an
"
IDBGetAllOptions
"
dictionary
with
"
{
getAllFunctionName
}
"
.
)
;
return
queryTarget
[
getAllFunctionName
]
(
options
)
;
}
if
(
options
&
&
options
.
count
)
{
return
queryTarget
[
getAllFunctionName
]
(
options
.
query
options
.
count
)
;
}
if
(
options
&
&
options
.
query
)
{
return
queryTarget
[
getAllFunctionName
]
(
options
.
query
)
;
}
return
queryTarget
[
getAllFunctionName
]
(
)
;
}
function
calculateExpectedGetAllResults
(
getAllFunctionName
records
options
)
{
const
expectedRecords
=
filterWithGetAllRecordsOptions
(
records
options
)
;
switch
(
getAllFunctionName
)
{
case
'
getAll
'
:
return
expectedRecords
.
map
(
(
{
value
}
)
=
>
{
return
value
}
)
;
case
'
getAllKeys
'
:
return
expectedRecords
.
map
(
(
{
primaryKey
}
)
=
>
{
return
primaryKey
}
)
;
case
'
getAllRecords
'
:
return
expectedRecords
;
}
assert_unreached
(
Unknown
getAllFunctionName
:
"
{
getAllFunctionName
}
"
)
;
}
function
verifyGetAllResults
(
getAllFunctionName
actual
expected
)
{
switch
(
getAllFunctionName
)
{
case
'
getAll
'
:
assert_idb_values_equals
(
actual
expected
)
;
return
;
case
'
getAllKeys
'
:
assert_array_equals
(
actual
expected
)
;
return
;
case
'
getAllRecords
'
:
assert_records_equals
(
actual
expected
)
;
return
;
}
assert_unreached
(
Unknown
getAllFunctionName
:
"
{
getAllFunctionName
}
"
)
;
}
function
filterWithGetAllRecordsOptions
(
records
options
)
{
if
(
!
options
)
{
return
records
;
}
if
(
options
.
query
)
{
let
query
=
options
.
query
;
if
(
!
(
query
instanceof
IDBKeyRange
)
)
{
query
=
IDBKeyRange
.
only
(
query
)
;
}
records
=
records
.
filter
(
record
=
>
query
.
includes
(
record
.
key
)
)
;
}
if
(
options
.
direction
=
=
=
'
nextunique
'
|
|
options
.
direction
=
=
=
'
prevunique
'
)
{
const
uniqueRecords
=
[
]
;
records
.
forEach
(
record
=
>
{
if
(
!
uniqueRecords
.
some
(
unique
=
>
IDBKeyRange
.
only
(
unique
.
key
)
.
includes
(
record
.
key
)
)
)
{
uniqueRecords
.
push
(
record
)
;
}
}
)
;
records
=
uniqueRecords
;
}
if
(
options
.
direction
=
=
=
'
prev
'
|
|
options
.
direction
=
=
=
'
prevunique
'
)
{
records
=
records
.
slice
(
)
.
reverse
(
)
;
}
if
(
options
.
count
)
{
records
=
records
.
slice
(
0
options
.
count
)
;
}
return
records
;
}
function
isArrayOrArrayBufferView
(
value
)
{
return
Array
.
isArray
(
value
)
|
|
ArrayBuffer
.
isView
(
value
)
;
}
function
assert_large_array_equals
(
actual
expected
description
)
{
const
array_string
=
actual
.
join
(
'
'
)
;
const
expected_string
=
expected
.
join
(
'
'
)
;
assert_equals
(
array_string
expected_string
description
)
;
}
function
assert_idb_value_equals
(
actual_value
expected_value
)
{
if
(
isArrayOrArrayBufferView
(
expected_value
)
)
{
assert_large_array_equals
(
actual_value
expected_value
'
The
record
must
have
the
expected
value
'
)
;
}
else
if
(
typeof
expected_value
=
=
=
'
object
'
)
{
for
(
let
property_name
of
Object
.
keys
(
expected_value
)
)
{
if
(
isArrayOrArrayBufferView
(
expected_value
[
property_name
]
)
)
{
assert_large_array_equals
(
actual_value
[
property_name
]
expected_value
[
property_name
]
The
record
must
contain
the
array
value
"
{
JSON
.
stringify
(
expected_value
)
}
"
with
property
"
{
property_name
}
"
)
;
}
else
{
assert_equals
(
actual_value
[
property_name
]
expected_value
[
property_name
]
The
record
must
contain
the
value
"
{
JSON
.
stringify
(
expected_value
)
}
"
with
property
"
{
property_name
}
"
)
;
}
}
}
else
{
assert_equals
(
actual_value
expected_value
'
The
record
must
have
the
expected
value
'
)
;
}
}
function
assert_record_equals
(
actual_record
expected_record
)
{
assert_class_string
(
actual_record
'
IDBRecord
'
'
The
record
must
be
an
IDBRecord
'
)
;
assert_idl_attribute
(
actual_record
'
key
'
'
The
record
must
have
a
key
attribute
'
)
;
assert_idl_attribute
(
actual_record
'
primaryKey
'
'
The
record
must
have
a
primaryKey
attribute
'
)
;
assert_idl_attribute
(
actual_record
'
value
'
'
The
record
must
have
a
value
attribute
'
)
;
assert_equals
(
actual_record
.
primaryKey
expected_record
.
primaryKey
'
The
record
must
have
the
expected
primaryKey
'
)
;
assert_equals
(
actual_record
.
key
expected_record
.
key
'
The
record
must
have
the
expected
key
'
)
;
assert_idb_value_equals
(
actual_record
.
value
expected_record
.
value
)
;
}
function
assert_records_equals
(
actual_records
expected_records
)
{
assert_true
(
Array
.
isArray
(
actual_records
)
'
The
records
must
be
an
array
of
IDBRecords
'
)
;
assert_equals
(
actual_records
.
length
expected_records
.
length
'
The
records
array
must
contain
the
expected
number
of
records
'
)
;
for
(
let
i
=
0
;
i
<
actual_records
.
length
;
i
+
+
)
{
assert_record_equals
(
actual_records
[
i
]
expected_records
[
i
]
)
;
}
}
function
assert_idb_values_equals
(
actual_values
expected_values
)
{
assert_true
(
Array
.
isArray
(
actual_values
)
'
The
values
must
be
an
array
'
)
;
assert_equals
(
actual_values
.
length
expected_values
.
length
'
The
values
array
must
contain
the
expected
number
of
values
'
)
;
for
(
let
i
=
0
;
i
<
actual_values
.
length
;
i
+
+
)
{
assert_idb_value_equals
(
actual_values
[
i
]
expected_values
[
i
]
)
;
}
}
function
get_all_with_options_and_count_test
(
getAllFunctionName
storeName
optionalIndexName
testDescription
)
{
const
setupFunction
=
optionalIndexName
?
index_get_all_test_setup
:
object_store_get_all_test_setup
;
setupFunction
(
storeName
(
test
connection
expectedRecords
)
=
>
{
const
transaction
=
connection
.
transaction
(
storeName
'
readonly
'
)
;
let
queryTarget
=
transaction
.
objectStore
(
storeName
)
;
if
(
optionalIndexName
)
{
queryTarget
=
queryTarget
.
index
(
optionalIndexName
)
;
}
const
options
=
{
count
:
10
}
;
const
request
=
queryTarget
[
getAllFunctionName
]
(
options
17
)
;
request
.
onerror
=
test
.
unreached_func
(
"
{
getAllFunctionName
}
(
)
"
request
must
succeed
.
)
;
request
.
onsuccess
=
test
.
step_func
(
event
=
>
{
const
expectedResults
=
calculateExpectedGetAllResults
(
getAllFunctionName
expectedRecords
options
)
;
const
actualResults
=
event
.
target
.
result
;
verifyGetAllResults
(
getAllFunctionName
actualResults
expectedResults
)
;
test
.
done
(
)
;
}
)
;
}
testDescription
)
;
}
function
get_all_with_invalid_keys_test
(
getAllFunctionName
storeName
optionalIndexName
shouldUseDictionaryArgument
testDescription
)
{
const
setupFunction
=
optionalIndexName
?
index_get_all_test_setup
:
object_store_get_all_test_setup
;
setupFunction
(
storeName
(
test
connection
expectedRecords
)
=
>
{
const
transaction
=
connection
.
transaction
(
storeName
'
readonly
'
)
;
let
queryTarget
=
transaction
.
objectStore
(
storeName
)
;
if
(
optionalIndexName
)
{
queryTarget
=
queryTarget
.
index
(
optionalIndexName
)
;
}
const
invalidKeys
=
[
{
description
:
'
Date
(
NaN
)
'
value
:
new
Date
(
NaN
)
}
{
description
:
'
Array
'
value
:
[
{
}
]
}
{
description
:
'
detached
TypedArray
'
value
:
createDetachedArrayBuffer
(
)
}
{
description
:
'
detached
ArrayBuffer
'
value
:
createDetachedArrayBuffer
(
)
.
buffer
}
]
;
invalidKeys
.
forEach
(
(
{
description
value
}
)
=
>
{
const
argument
=
shouldUseDictionaryArgument
?
{
query
:
value
}
:
value
;
assert_throws_dom
(
'
DataError
'
(
)
=
>
{
queryTarget
[
getAllFunctionName
]
(
argument
)
;
}
An
invalid
{
description
}
key
must
throw
an
exception
.
)
;
}
)
;
test
.
done
(
)
;
}
testDescription
)
;
}
