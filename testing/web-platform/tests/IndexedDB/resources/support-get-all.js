'
use
strict
'
;
const
alphabet
=
'
abcdefghijklmnopqrstuvwxyz
'
.
split
(
'
'
)
;
const
vowels
=
'
aeiou
'
.
split
(
'
'
)
;
function
object_store_get_all_test
(
func
name
)
{
indexeddb_test
(
(
test
connection
transaction
)
=
>
{
self
.
expectedObjectStoreRecords
=
{
'
generated
'
:
[
]
'
out
-
of
-
line
'
:
[
]
'
empty
'
:
[
]
'
large
-
values
'
:
[
]
}
;
let
store
=
connection
.
createObjectStore
(
'
generated
'
{
autoIncrement
:
true
keyPath
:
'
id
'
}
)
;
alphabet
.
forEach
(
letter
=
>
{
store
.
put
(
{
ch
:
letter
}
)
;
const
generatedKey
=
alphabet
.
indexOf
(
letter
)
+
1
;
expectedObjectStoreRecords
[
'
generated
'
]
.
push
(
{
key
:
generatedKey
primaryKey
:
generatedKey
value
:
{
ch
:
letter
}
}
)
;
}
)
;
store
=
connection
.
createObjectStore
(
'
out
-
of
-
line
'
)
;
alphabet
.
forEach
(
letter
=
>
{
store
.
put
(
value
-
{
letter
}
letter
)
;
expectedObjectStoreRecords
[
'
out
-
of
-
line
'
]
.
push
(
{
key
:
letter
primaryKey
:
letter
value
:
value
-
{
letter
}
}
)
;
}
)
;
store
=
connection
.
createObjectStore
(
'
empty
'
)
;
store
=
connection
.
createObjectStore
(
'
large
-
values
'
)
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
const
value
=
largeValue
(
wrapThreshold
i
)
;
store
.
put
(
value
i
)
;
expectedObjectStoreRecords
[
'
large
-
values
'
]
.
push
(
{
key
:
i
primaryKey
:
i
value
}
)
;
}
}
func
name
)
;
}
function
object_store_get_all_records_test
(
storeName
options
description
)
{
object_store_get_all_test
(
(
test
connection
)
=
>
{
const
request
=
createGetAllRecordsRequest
(
test
connection
storeName
options
)
;
request
.
onsuccess
=
test
.
step_func
(
event
=
>
{
let
expectedResults
=
expectedObjectStoreRecords
[
storeName
]
;
expectedResults
=
applyGetAllRecordsOptions
(
expectedResults
options
)
;
const
actualResults
=
event
.
target
.
result
;
assert_records_equals
(
actualResults
expectedResults
)
;
test
.
done
(
)
;
}
)
;
}
description
)
;
}
function
createGetAllRecordsRequest
(
test
connection
storeName
options
optionalIndexName
)
{
const
transaction
=
connection
.
transaction
(
storeName
'
readonly
'
)
;
let
queryTarget
=
transaction
.
objectStore
(
storeName
)
;
if
(
optionalIndexName
)
{
queryTarget
=
queryTarget
.
index
(
optionalIndexName
)
;
}
const
request
=
queryTarget
.
getAllRecords
(
options
)
;
request
.
onerror
=
test
.
unreached_func
(
'
getAllRecords
request
must
succeed
'
)
;
return
request
;
}
function
applyGetAllRecordsOptions
(
records
options
)
{
if
(
!
options
)
{
return
records
;
}
if
(
options
.
query
)
{
let
query
=
options
.
query
;
if
(
!
(
query
instanceof
IDBKeyRange
)
)
{
query
=
IDBKeyRange
.
only
(
query
)
;
}
records
=
records
.
filter
(
record
=
>
query
.
includes
(
record
.
key
)
)
;
}
if
(
options
.
direction
=
=
=
'
nextunique
'
|
|
options
.
direction
=
=
=
'
prevunique
'
)
{
const
uniqueRecords
=
[
]
;
records
.
forEach
(
record
=
>
{
if
(
!
uniqueRecords
.
some
(
unique
=
>
IDBKeyRange
.
only
(
unique
.
key
)
.
includes
(
record
.
key
)
)
)
{
uniqueRecords
.
push
(
record
)
;
}
}
)
;
records
=
uniqueRecords
;
}
if
(
options
.
direction
=
=
=
'
prev
'
|
|
options
.
direction
=
=
=
'
prevunique
'
)
{
records
=
records
.
slice
(
)
.
reverse
(
)
;
}
if
(
options
.
count
)
{
records
=
records
.
slice
(
0
options
.
count
)
;
}
return
records
;
}
function
isArrayOrArrayBufferView
(
value
)
{
return
Array
.
isArray
(
value
)
|
|
ArrayBuffer
.
isView
(
value
)
;
}
function
assert_large_array_equals
(
actual
expected
description
)
{
const
array_string
=
actual
.
join
(
'
'
)
;
const
expected_string
=
expected
.
join
(
'
'
)
;
assert_equals
(
array_string
expected_string
description
)
;
}
function
assert_record_equals
(
actual_record
expected_record
)
{
assert_class_string
(
actual_record
'
IDBRecord
'
'
The
record
must
be
an
IDBRecord
'
)
;
assert_idl_attribute
(
actual_record
'
key
'
'
The
record
must
have
a
key
attribute
'
)
;
assert_idl_attribute
(
actual_record
'
primaryKey
'
'
The
record
must
have
a
primaryKey
attribute
'
)
;
assert_idl_attribute
(
actual_record
'
value
'
'
The
record
must
have
a
value
attribute
'
)
;
assert_equals
(
actual_record
.
primaryKey
expected_record
.
primaryKey
'
The
record
must
have
the
expected
primaryKey
'
)
;
assert_equals
(
actual_record
.
key
expected_record
.
key
'
The
record
must
have
the
expected
key
'
)
;
const
actual_value
=
actual_record
.
value
;
const
expected_value
=
expected_record
.
value
;
if
(
isArrayOrArrayBufferView
(
expected_value
)
)
{
assert_large_array_equals
(
actual_value
expected_value
'
The
record
must
have
the
expected
value
'
)
;
}
else
if
(
typeof
expected_value
=
=
=
'
object
'
)
{
for
(
let
property_name
of
Object
.
keys
(
expected_value
)
)
{
if
(
isArrayOrArrayBufferView
(
expected_value
[
property_name
]
)
)
{
assert_large_array_equals
(
actual_value
[
property_name
]
expected_value
[
property_name
]
The
record
must
contain
the
array
value
"
{
JSON
.
stringify
(
expected_value
)
}
"
with
property
"
{
property_name
}
"
)
;
}
else
{
assert_equals
(
actual_value
[
property_name
]
expected_value
[
property_name
]
The
record
must
contain
the
value
"
{
JSON
.
stringify
(
expected_value
)
}
"
with
property
"
{
property_name
}
"
)
;
}
}
}
else
{
assert_equals
(
actual_value
expected_value
'
The
record
must
have
the
expected
value
'
)
;
}
}
function
assert_records_equals
(
actual_records
expected_records
)
{
assert_true
(
Array
.
isArray
(
actual_records
)
'
The
records
must
be
an
array
of
IDBRecords
'
)
;
assert_equals
(
actual_records
.
length
expected_records
.
length
'
The
records
array
must
contain
the
expected
number
of
records
'
)
;
for
(
let
i
=
0
;
i
<
actual_records
.
length
;
i
+
+
)
{
assert_record_equals
(
actual_records
[
i
]
expected_records
[
i
]
)
;
}
}
