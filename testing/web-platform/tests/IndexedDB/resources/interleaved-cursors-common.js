const
itemCount
=
10
;
const
largeObjectRatio
=
5
;
const
largeObjectSize
=
48
*
1024
;
function
objectKey
(
cursorIndex
itemIndex
)
{
return
{
cursorIndex
}
-
key
-
{
itemIndex
}
;
}
function
objectValue
(
cursorIndex
itemIndex
)
{
if
(
(
cursorIndex
*
itemCount
+
itemIndex
)
%
largeObjectRatio
=
=
=
0
)
{
const
buffer
=
new
Uint8Array
(
largeObjectSize
)
;
let
state
=
1000
+
(
cursorIndex
*
itemCount
+
itemIndex
)
;
for
(
let
i
=
0
;
i
<
largeObjectSize
;
+
+
i
)
{
state
^
=
state
<
<
13
;
state
^
=
state
>
>
17
;
state
^
=
state
<
<
5
;
buffer
[
i
]
=
state
&
0xff
;
}
return
buffer
;
}
return
[
cursorIndex
'
small
'
itemIndex
]
;
}
function
writeCursorObjects
(
database
cursorIndex
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
transaction
=
database
.
transaction
(
'
cache
'
'
readwrite
'
{
durability
:
'
relaxed
'
}
)
;
transaction
.
onabort
=
(
)
=
>
{
reject
(
transaction
.
error
)
;
}
;
const
store
=
transaction
.
objectStore
(
'
cache
'
)
;
for
(
let
i
=
0
;
i
<
itemCount
;
+
+
i
)
{
store
.
put
(
{
key
:
objectKey
(
cursorIndex
i
)
value
:
objectValue
(
cursorIndex
i
)
}
)
;
}
transaction
.
oncomplete
=
resolve
;
}
)
;
}
function
populateTestStore
(
testCase
database
cursorCount
)
{
let
promiseChain
=
Promise
.
resolve
(
)
;
for
(
let
i
=
0
;
i
<
cursorCount
;
+
+
i
)
promiseChain
=
promiseChain
.
then
(
(
)
=
>
writeCursorObjects
(
database
i
)
)
;
return
promiseChain
;
}
function
interleaveCursors
(
testCase
store
cursorCount
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
cursors
=
[
]
;
const
requests
=
[
]
;
const
checkCursorState
=
(
cursorIndex
itemIndex
)
=
>
{
const
cursor
=
cursors
[
cursorIndex
]
;
assert_equals
(
cursor
.
key
objectKey
(
cursorIndex
itemIndex
)
)
;
assert_equals
(
cursor
.
value
.
key
objectKey
(
cursorIndex
itemIndex
)
)
;
assert_equals
(
cursor
.
value
.
value
.
join
(
'
-
'
)
objectValue
(
cursorIndex
itemIndex
)
.
join
(
'
-
'
)
)
;
}
;
const
openCursor
=
(
cursorIndex
callback
)
=
>
{
const
request
=
store
.
openCursor
(
IDBKeyRange
.
lowerBound
(
objectKey
(
cursorIndex
0
)
)
)
;
requests
[
cursorIndex
]
=
request
;
request
.
onsuccess
=
testCase
.
step_func
(
(
)
=
>
{
const
cursor
=
request
.
result
;
cursors
[
cursorIndex
]
=
cursor
;
checkCursorState
(
cursorIndex
0
)
;
callback
(
)
;
}
)
;
request
.
onerror
=
event
=
>
reject
(
request
.
error
)
;
}
;
const
readItemFromCursor
=
(
cursorIndex
itemIndex
callback
)
=
>
{
const
request
=
requests
[
cursorIndex
]
;
request
.
onsuccess
=
testCase
.
step_func
(
(
)
=
>
{
const
cursor
=
request
.
result
;
cursors
[
cursorIndex
]
=
cursor
;
checkCursorState
(
cursorIndex
itemIndex
)
;
callback
(
)
;
}
)
;
const
cursor
=
cursors
[
cursorIndex
]
;
cursor
.
continue
(
)
;
}
;
const
steps
=
[
]
;
for
(
let
cursorIndex
=
0
;
cursorIndex
<
cursorCount
;
+
+
cursorIndex
)
steps
.
push
(
openCursor
.
bind
(
null
cursorIndex
)
)
;
for
(
let
itemIndex
=
1
;
itemIndex
<
itemCount
;
+
+
itemIndex
)
{
for
(
let
cursorIndex
=
0
;
cursorIndex
<
cursorCount
;
+
+
cursorIndex
)
steps
.
push
(
readItemFromCursor
.
bind
(
null
cursorIndex
itemIndex
)
)
;
}
const
runStep
=
(
stepIndex
)
=
>
{
if
(
stepIndex
=
=
=
steps
.
length
)
{
resolve
(
)
;
return
;
}
steps
[
stepIndex
]
(
(
)
=
>
{
runStep
(
stepIndex
+
1
)
;
}
)
;
}
;
runStep
(
0
)
;
}
)
;
}
function
cursorTest
(
cursorCount
)
{
promise_test
(
testCase
=
>
{
return
createDatabase
(
testCase
(
database
transaction
)
=
>
{
const
store
=
database
.
createObjectStore
(
'
cache
'
{
keyPath
:
'
key
'
autoIncrement
:
true
}
)
;
}
)
.
then
(
database
=
>
{
return
populateTestStore
(
testCase
database
cursorCount
)
.
then
(
(
)
=
>
database
)
;
}
)
.
then
(
database
=
>
{
database
.
close
(
)
;
}
)
.
then
(
(
)
=
>
{
return
openDatabase
(
testCase
)
;
}
)
.
then
(
database
=
>
{
const
transaction
=
database
.
transaction
(
'
cache
'
'
readonly
'
{
durability
:
'
relaxed
'
}
)
;
transaction
.
onabort
=
(
)
=
>
{
reject
(
transaction
.
error
)
;
}
;
const
store
=
transaction
.
objectStore
(
'
cache
'
)
;
return
interleaveCursors
(
testCase
store
cursorCount
)
.
then
(
(
)
=
>
database
)
;
}
)
.
then
(
database
=
>
{
database
.
close
(
)
;
}
)
;
}
{
cursorCount
}
cursors
)
;
}
