'
use
strict
'
;
function
databaseName
(
testCase
)
{
return
'
db
'
+
self
.
location
.
pathname
+
'
-
'
+
testCase
.
name
;
}
function
requestWatcher
(
testCase
request
)
{
return
new
EventWatcher
(
testCase
request
[
'
blocked
'
'
error
'
'
success
'
'
upgradeneeded
'
]
)
;
}
function
transactionWatcher
(
testCase
request
)
{
return
new
EventWatcher
(
testCase
request
[
'
abort
'
'
complete
'
'
error
'
]
)
;
}
function
promiseForRequest
(
testCase
request
)
{
const
eventWatcher
=
requestWatcher
(
testCase
request
)
;
return
eventWatcher
.
wait_for
(
'
success
'
)
.
then
(
event
=
>
event
.
target
.
result
)
;
}
function
promiseForTransaction
(
testCase
request
)
{
const
eventWatcher
=
transactionWatcher
(
testCase
request
)
;
return
eventWatcher
.
wait_for
(
'
complete
'
)
.
then
(
(
)
=
>
{
}
)
;
}
function
migrateDatabase
(
testCase
newVersion
migrationCallback
)
{
return
migrateNamedDatabase
(
testCase
databaseName
(
testCase
)
newVersion
migrationCallback
)
;
}
function
migrateNamedDatabase
(
testCase
databaseName
newVersion
migrationCallback
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
request
=
indexedDB
.
open
(
databaseName
newVersion
)
;
request
.
onupgradeneeded
=
testCase
.
step_func
(
event
=
>
{
const
database
=
event
.
target
.
result
;
const
transaction
=
event
.
target
.
transaction
;
let
shouldBeAborted
=
false
;
let
requestEventPromise
=
null
;
const
transactionAbort
=
transaction
.
abort
.
bind
(
transaction
)
;
transaction
.
abort
=
(
)
=
>
{
transaction
.
_willBeAborted
(
)
;
transactionAbort
(
)
;
}
transaction
.
_willBeAborted
=
(
)
=
>
{
requestEventPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
request
.
onerror
=
event
=
>
{
event
.
preventDefault
(
)
;
resolve
(
event
.
target
.
error
)
;
}
;
request
.
onsuccess
=
(
)
=
>
reject
(
new
Error
(
'
indexedDB
.
open
should
not
succeed
for
an
aborted
'
+
'
versionchange
transaction
'
)
)
;
}
)
;
shouldBeAborted
=
true
;
}
const
callbackResult
=
migrationCallback
(
database
transaction
request
)
;
if
(
!
shouldBeAborted
)
{
request
.
onerror
=
null
;
request
.
onsuccess
=
null
;
requestEventPromise
=
promiseForRequest
(
testCase
request
)
;
}
resolve
(
Promise
.
resolve
(
callbackResult
)
.
then
(
(
)
=
>
requestEventPromise
)
)
;
}
)
;
request
.
onerror
=
event
=
>
reject
(
event
.
target
.
error
)
;
request
.
onsuccess
=
(
)
=
>
{
const
database
=
request
.
result
;
testCase
.
add_cleanup
(
(
)
=
>
{
database
.
close
(
)
;
}
)
;
reject
(
new
Error
(
'
indexedDB
.
open
should
not
succeed
without
creating
a
'
+
'
versionchange
transaction
'
)
)
;
}
;
}
)
.
then
(
databaseOrError
=
>
{
if
(
databaseOrError
instanceof
IDBDatabase
)
testCase
.
add_cleanup
(
(
)
=
>
{
databaseOrError
.
close
(
)
;
}
)
;
return
databaseOrError
;
}
)
;
}
function
createDatabase
(
testCase
setupCallback
)
{
return
createNamedDatabase
(
testCase
databaseName
(
testCase
)
setupCallback
)
;
}
function
createNamedDatabase
(
testCase
databaseName
setupCallback
)
{
const
request
=
indexedDB
.
deleteDatabase
(
databaseName
)
;
return
promiseForRequest
(
testCase
request
)
.
then
(
(
)
=
>
{
testCase
.
add_cleanup
(
(
)
=
>
{
indexedDB
.
deleteDatabase
(
databaseName
)
;
}
)
;
return
migrateNamedDatabase
(
testCase
databaseName
1
setupCallback
)
}
)
;
}
function
openDatabase
(
testCase
version
)
{
return
openNamedDatabase
(
testCase
databaseName
(
testCase
)
version
)
;
}
function
openNamedDatabase
(
testCase
databaseName
version
)
{
const
request
=
indexedDB
.
open
(
databaseName
version
)
;
return
promiseForRequest
(
testCase
request
)
.
then
(
database
=
>
{
testCase
.
add_cleanup
(
(
)
=
>
{
database
.
close
(
)
;
}
)
;
return
database
;
}
)
;
}
const
BOOKS_RECORD_DATA
=
[
{
title
:
'
Quarry
Memories
'
author
:
'
Fred
'
isbn
:
123456
}
{
title
:
'
Water
Buffaloes
'
author
:
'
Fred
'
isbn
:
234567
}
{
title
:
'
Bedrock
Nights
'
author
:
'
Barney
'
isbn
:
345678
}
]
;
const
createBooksStore
=
(
testCase
database
)
=
>
{
const
store
=
database
.
createObjectStore
(
'
books
'
{
keyPath
:
'
isbn
'
autoIncrement
:
true
}
)
;
store
.
createIndex
(
'
by_author
'
'
author
'
)
;
store
.
createIndex
(
'
by_title
'
'
title
'
{
unique
:
true
}
)
;
for
(
let
record
of
BOOKS_RECORD_DATA
)
store
.
put
(
record
)
;
return
store
;
}
function
createNotBooksStore
(
testCase
database
)
{
const
store
=
database
.
createObjectStore
(
'
not_books
'
)
;
store
.
createIndex
(
'
not_by_author
'
'
author
'
)
;
store
.
createIndex
(
'
not_by_title
'
'
title
'
{
unique
:
true
}
)
;
return
store
;
}
function
checkStoreIndexes
(
testCase
store
errorMessage
)
{
assert_array_equals
(
store
.
indexNames
[
'
by_author
'
'
by_title
'
]
errorMessage
)
;
const
authorIndex
=
store
.
index
(
'
by_author
'
)
;
const
titleIndex
=
store
.
index
(
'
by_title
'
)
;
return
Promise
.
all
(
[
checkAuthorIndexContents
(
testCase
authorIndex
errorMessage
)
checkTitleIndexContents
(
testCase
titleIndex
errorMessage
)
]
)
;
}
function
checkStoreGenerator
(
testCase
store
expectedKey
errorMessage
)
{
const
request
=
store
.
put
(
{
title
:
'
Bedrock
Nights
'
+
expectedKey
author
:
'
Barney
'
}
)
;
return
promiseForRequest
(
testCase
request
)
.
then
(
result
=
>
{
assert_equals
(
result
expectedKey
errorMessage
)
;
}
)
;
}
function
checkStoreContents
(
testCase
store
errorMessage
)
{
const
request
=
store
.
get
(
123456
)
;
return
promiseForRequest
(
testCase
request
)
.
then
(
result
=
>
{
assert_equals
(
result
.
isbn
BOOKS_RECORD_DATA
[
0
]
.
isbn
errorMessage
)
;
assert_equals
(
result
.
author
BOOKS_RECORD_DATA
[
0
]
.
author
errorMessage
)
;
assert_equals
(
result
.
title
BOOKS_RECORD_DATA
[
0
]
.
title
errorMessage
)
;
}
)
;
}
function
checkAuthorIndexContents
(
testCase
index
errorMessage
)
{
const
request
=
index
.
get
(
BOOKS_RECORD_DATA
[
2
]
.
author
)
;
return
promiseForRequest
(
testCase
request
)
.
then
(
result
=
>
{
assert_equals
(
result
.
isbn
BOOKS_RECORD_DATA
[
2
]
.
isbn
errorMessage
)
;
assert_equals
(
result
.
title
BOOKS_RECORD_DATA
[
2
]
.
title
errorMessage
)
;
}
)
;
}
function
checkTitleIndexContents
(
testCase
index
errorMessage
)
{
const
request
=
index
.
get
(
BOOKS_RECORD_DATA
[
2
]
.
title
)
;
return
promiseForRequest
(
testCase
request
)
.
then
(
result
=
>
{
assert_equals
(
result
.
isbn
BOOKS_RECORD_DATA
[
2
]
.
isbn
errorMessage
)
;
assert_equals
(
result
.
author
BOOKS_RECORD_DATA
[
2
]
.
author
errorMessage
)
;
}
)
;
}
function
largeValue
(
size
seed
)
{
const
buffer
=
new
Uint8Array
(
size
)
;
let
state
=
1000
+
seed
;
for
(
let
i
=
0
;
i
<
size
;
+
+
i
)
{
state
^
=
state
<
<
13
;
state
^
=
state
>
>
17
;
state
^
=
state
<
<
5
;
buffer
[
i
]
=
state
&
0xff
;
}
return
buffer
;
}
async
function
deleteAllDatabases
(
testCase
)
{
const
dbs_to_delete
=
await
indexedDB
.
databases
(
)
;
for
(
const
db_info
of
dbs_to_delete
)
{
let
request
=
indexedDB
.
deleteDatabase
(
db_info
.
name
)
;
let
eventWatcher
=
requestWatcher
(
testCase
request
)
;
await
eventWatcher
.
wait_for
(
'
success
'
)
;
}
}
function
keepAlive
(
testCase
transaction
storeName
)
{
let
completed
=
false
;
transaction
.
addEventListener
(
'
complete
'
(
)
=
>
{
completed
=
true
;
}
)
;
let
keepSpinning
=
true
;
function
spin
(
)
{
if
(
!
keepSpinning
)
return
;
transaction
.
objectStore
(
storeName
)
.
get
(
0
)
.
onsuccess
=
spin
;
}
spin
(
)
;
return
testCase
.
step_func
(
(
)
=
>
{
assert_false
(
completed
'
Transaction
completed
while
kept
alive
'
)
;
keepSpinning
=
false
;
}
)
;
}
function
timeoutPromise
(
ms
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
ms
)
;
}
)
;
}
