'
use
strict
'
;
function
databaseName
(
testCase
)
{
return
'
db
'
+
self
.
location
.
pathname
+
'
-
'
+
testCase
.
name
;
}
function
requestWatcher
(
testCase
request
)
{
return
new
EventWatcher
(
testCase
request
[
'
abort
'
'
blocked
'
'
complete
'
'
error
'
'
success
'
'
upgradeneeded
'
]
)
;
}
function
migrateDatabase
(
testCase
newVersion
migrationCallback
)
{
return
migrateNamedDatabase
(
testCase
databaseName
(
testCase
)
newVersion
migrationCallback
)
;
}
function
migrateNamedDatabase
(
testCase
databaseName
newVersion
migrationCallback
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
request
=
indexedDB
.
open
(
databaseName
newVersion
)
;
request
.
onupgradeneeded
=
testCase
.
step_func
(
event
=
>
{
const
database
=
event
.
target
.
result
;
const
transaction
=
event
.
target
.
transaction
;
let
shouldBeAborted
=
false
;
let
requestEventPromise
=
null
;
const
transactionAbort
=
transaction
.
abort
.
bind
(
transaction
)
;
transaction
.
abort
=
(
)
=
>
{
transaction
.
_willBeAborted
(
)
;
transactionAbort
(
)
;
}
transaction
.
_willBeAborted
=
(
)
=
>
{
requestEventPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
request
.
onerror
=
event
=
>
{
event
.
preventDefault
(
)
;
resolve
(
event
)
;
}
;
request
.
onsuccess
=
(
)
=
>
reject
(
new
Error
(
'
indexedDB
.
open
should
not
succeed
for
an
aborted
'
+
'
versionchange
transaction
'
)
)
;
}
)
;
shouldBeAborted
=
true
;
}
const
callbackResult
=
migrationCallback
(
database
transaction
request
)
;
if
(
!
shouldBeAborted
)
{
request
.
onerror
=
null
;
request
.
onsuccess
=
null
;
requestEventPromise
=
requestWatcher
(
testCase
request
)
.
wait_for
(
'
success
'
)
;
}
resolve
(
Promise
.
resolve
(
callbackResult
)
.
then
(
(
)
=
>
requestEventPromise
)
)
;
}
)
;
request
.
onerror
=
event
=
>
reject
(
event
.
target
.
error
)
;
request
.
onsuccess
=
(
)
=
>
reject
(
new
Error
(
'
indexedDB
.
open
should
not
succeed
without
creating
a
'
+
'
versionchange
transaction
'
)
)
;
}
)
.
then
(
event
=
>
event
.
target
.
result
|
|
event
.
target
.
error
)
;
}
function
createDatabase
(
testCase
setupCallback
)
{
return
createNamedDatabase
(
testCase
databaseName
(
testCase
)
setupCallback
)
;
}
function
createNamedDatabase
(
testCase
databaseName
setupCallback
)
{
const
request
=
indexedDB
.
deleteDatabase
(
databaseName
)
;
const
eventWatcher
=
requestWatcher
(
testCase
request
)
;
return
eventWatcher
.
wait_for
(
'
success
'
)
.
then
(
event
=
>
migrateNamedDatabase
(
testCase
databaseName
1
setupCallback
)
)
;
}
function
openDatabase
(
testCase
version
)
{
return
openNamedDatabase
(
testCase
databaseName
(
testCase
)
version
)
;
}
function
openNamedDatabase
(
testCase
databaseName
version
)
{
const
request
=
indexedDB
.
open
(
databaseName
version
)
;
const
eventWatcher
=
requestWatcher
(
testCase
request
)
;
return
eventWatcher
.
wait_for
(
'
success
'
)
.
then
(
event
=
>
event
.
target
.
result
)
;
}
const
BOOKS_RECORD_DATA
=
[
{
title
:
'
Quarry
Memories
'
author
:
'
Fred
'
isbn
:
123456
}
{
title
:
'
Water
Buffaloes
'
author
:
'
Fred
'
isbn
:
234567
}
{
title
:
'
Bedrock
Nights
'
author
:
'
Barney
'
isbn
:
345678
}
]
;
const
createBooksStore
=
(
testCase
database
)
=
>
{
const
store
=
database
.
createObjectStore
(
'
books
'
{
keyPath
:
'
isbn
'
autoIncrement
:
true
}
)
;
store
.
createIndex
(
'
by_author
'
'
author
'
)
;
store
.
createIndex
(
'
by_title
'
'
title
'
{
unique
:
true
}
)
;
for
(
let
record
of
BOOKS_RECORD_DATA
)
store
.
put
(
record
)
;
return
store
;
}
function
createNotBooksStore
(
testCase
database
)
{
const
store
=
database
.
createObjectStore
(
'
not_books
'
)
;
store
.
createIndex
(
'
not_by_author
'
'
author
'
)
;
store
.
createIndex
(
'
not_by_title
'
'
title
'
{
unique
:
true
}
)
;
return
store
;
}
function
checkStoreIndexes
(
testCase
store
errorMessage
)
{
assert_array_equals
(
store
.
indexNames
[
'
by_author
'
'
by_title
'
]
errorMessage
)
;
const
authorIndex
=
store
.
index
(
'
by_author
'
)
;
const
titleIndex
=
store
.
index
(
'
by_title
'
)
;
return
Promise
.
all
(
[
checkAuthorIndexContents
(
testCase
authorIndex
errorMessage
)
checkTitleIndexContents
(
testCase
titleIndex
errorMessage
)
]
)
;
}
function
checkStoreGenerator
(
testCase
store
expectedKey
errorMessage
)
{
const
request
=
store
.
put
(
{
title
:
'
Bedrock
Nights
'
+
expectedKey
author
:
'
Barney
'
}
)
;
const
eventWatcher
=
requestWatcher
(
testCase
request
)
;
return
eventWatcher
.
wait_for
(
'
success
'
)
.
then
(
(
)
=
>
{
const
result
=
request
.
result
;
assert_equals
(
result
expectedKey
errorMessage
)
;
}
)
;
}
function
checkStoreContents
(
testCase
store
errorMessage
)
{
const
request
=
store
.
get
(
123456
)
;
const
eventWatcher
=
requestWatcher
(
testCase
request
)
;
return
eventWatcher
.
wait_for
(
'
success
'
)
.
then
(
(
)
=
>
{
const
result
=
request
.
result
;
assert_equals
(
result
.
isbn
BOOKS_RECORD_DATA
[
0
]
.
isbn
errorMessage
)
;
assert_equals
(
result
.
author
BOOKS_RECORD_DATA
[
0
]
.
author
errorMessage
)
;
assert_equals
(
result
.
title
BOOKS_RECORD_DATA
[
0
]
.
title
errorMessage
)
;
}
)
;
}
function
checkAuthorIndexContents
(
testCase
index
errorMessage
)
{
const
request
=
index
.
get
(
BOOKS_RECORD_DATA
[
2
]
.
author
)
;
const
eventWatcher
=
requestWatcher
(
testCase
request
)
;
return
eventWatcher
.
wait_for
(
'
success
'
)
.
then
(
(
)
=
>
{
const
result
=
request
.
result
;
assert_equals
(
result
.
isbn
BOOKS_RECORD_DATA
[
2
]
.
isbn
errorMessage
)
;
assert_equals
(
result
.
title
BOOKS_RECORD_DATA
[
2
]
.
title
errorMessage
)
;
}
)
;
}
function
checkTitleIndexContents
(
testCase
index
errorMessage
)
{
const
request
=
index
.
get
(
BOOKS_RECORD_DATA
[
2
]
.
title
)
;
const
eventWatcher
=
requestWatcher
(
testCase
request
)
;
return
eventWatcher
.
wait_for
(
'
success
'
)
.
then
(
(
)
=
>
{
const
result
=
request
.
result
;
assert_equals
(
result
.
isbn
BOOKS_RECORD_DATA
[
2
]
.
isbn
errorMessage
)
;
assert_equals
(
result
.
author
BOOKS_RECORD_DATA
[
2
]
.
author
errorMessage
)
;
}
)
;
}
