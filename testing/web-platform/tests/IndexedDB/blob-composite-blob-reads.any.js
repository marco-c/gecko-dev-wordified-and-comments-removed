function
composite_blob_test
(
{
blobCount
blobSize
name
}
)
{
for
(
const
mode
of
[
"
fetch
-
blob
-
url
"
"
direct
"
]
)
{
promise_test
(
async
testCase
=
>
{
const
key
=
"
the
-
blobs
"
;
let
memBlobs
=
[
]
;
for
(
let
iBlob
=
0
;
iBlob
<
blobCount
;
iBlob
+
+
)
{
memBlobs
.
push
(
new
Blob
(
[
make_arraybuffer_contents
(
iBlob
blobSize
)
]
)
)
;
}
const
db
=
await
createDatabase
(
testCase
db
=
>
{
db
.
createObjectStore
(
"
blobs
"
)
;
}
)
;
const
write_tx
=
db
.
transaction
(
"
blobs
"
"
readwrite
"
)
;
let
store
=
write_tx
.
objectStore
(
"
blobs
"
)
;
store
.
put
(
memBlobs
key
)
;
memBlobs
=
null
;
await
promiseForTransaction
(
testCase
write_tx
)
;
const
read_tx
=
db
.
transaction
(
"
blobs
"
)
;
store
=
read_tx
.
objectStore
(
"
blobs
"
)
;
const
read_req
=
store
.
get
(
key
)
;
await
promiseForTransaction
(
testCase
read_tx
)
;
const
diskBlobs
=
read_req
.
result
;
const
compositeBlob
=
new
Blob
(
diskBlobs
)
;
if
(
mode
=
=
=
"
fetch
-
blob
-
url
"
)
{
const
blobUrl
=
URL
.
createObjectURL
(
compositeBlob
)
;
let
urlResp
=
await
fetch
(
blobUrl
)
;
let
urlFetchArrayBuffer
=
await
urlResp
.
arrayBuffer
(
)
;
urlResp
=
null
;
URL
.
revokeObjectURL
(
blobUrl
)
;
validate_arraybuffer_contents
(
"
fetched
URL
"
urlFetchArrayBuffer
blobCount
blobSize
)
;
urlFetchArrayBuffer
=
null
;
}
else
if
(
mode
=
=
=
"
file
-
reader
"
)
{
let
reader
=
new
FileReader
(
)
;
let
readerPromise
=
new
Promise
(
resolve
=
>
{
reader
.
onload
=
(
)
=
>
{
resolve
(
reader
.
result
)
;
}
}
)
reader
.
readAsArrayBuffer
(
compositeBlob
)
;
let
readArrayBuffer
=
await
readerPromise
;
readerPromise
=
null
;
reader
=
null
;
validate_arraybuffer_contents
(
"
FileReader
"
readArrayBuffer
blobCount
blobSize
)
;
readArrayBuffer
=
null
;
}
else
if
(
mode
=
=
=
"
direct
"
)
{
let
directArrayBuffer
=
await
compositeBlob
.
arrayBuffer
(
)
;
validate_arraybuffer_contents
(
"
arrayBuffer
"
directArrayBuffer
blobCount
blobSize
)
;
}
}
Composite
Blob
Handling
:
{
name
}
:
{
mode
}
)
;
}
}
function
make_arraybuffer_contents
(
index
size
)
{
const
arr
=
new
Uint8Array
(
size
)
;
for
(
let
i
=
0
counter
=
0
;
i
<
size
;
i
+
=
2
counter
=
(
counter
+
3
)
%
256
)
{
arr
[
i
]
=
index
;
arr
[
i
+
1
]
=
counter
;
}
return
arr
.
buffer
;
}
function
validate_arraybuffer_contents
(
source
buffer
blobCount
blobSize
)
{
const
problems
=
[
]
;
const
arr
=
new
Uint8Array
(
buffer
)
;
const
expectedLength
=
blobCount
*
blobSize
;
const
actualCount
=
arr
.
length
/
blobSize
;
if
(
arr
.
length
!
=
=
expectedLength
)
{
problems
.
push
(
ArrayBuffer
only
holds
{
actualCount
}
blobs
'
worth
instead
of
{
blobCount
}
.
)
;
problems
.
push
(
Actual
ArrayBuffer
is
{
arr
.
length
}
bytes
but
expected
{
expectedLength
}
)
;
}
const
counterBlobStep
=
(
blobSize
/
2
*
3
)
%
256
;
let
expectedBlob
=
0
;
let
blobSeenSoFar
=
0
;
let
expectedCounter
=
0
;
let
counterDrift
=
0
;
for
(
let
i
=
0
;
i
<
arr
.
length
;
i
+
=
2
)
{
if
(
arr
[
i
]
!
=
=
expectedBlob
|
|
blobSeenSoFar
>
=
blobSize
)
{
if
(
blobSeenSoFar
!
=
=
blobSize
)
{
problems
.
push
(
Truncated
blob
{
expectedBlob
}
after
{
blobSeenSoFar
}
bytes
.
)
;
}
else
{
expectedBlob
+
+
;
}
if
(
expectedBlob
!
=
=
arr
[
i
]
)
{
problems
.
push
(
Expected
blob
{
expectedBlob
}
but
found
{
arr
[
i
]
}
compensating
.
)
;
expectedBlob
=
arr
[
i
]
;
}
blobSeenSoFar
=
0
;
expectedCounter
=
(
expectedBlob
*
counterBlobStep
)
%
256
;
counterDrift
=
0
;
}
if
(
arr
[
i
+
1
]
!
=
=
(
expectedCounter
+
counterDrift
)
%
256
)
{
const
newDrift
=
expectedCounter
-
arr
[
i
+
1
]
;
problems
.
push
(
In
blob
{
expectedBlob
}
at
{
blobSeenSoFar
+
1
}
bytes
in
counter
drift
now
{
newDrift
}
was
{
counterDrift
}
)
;
counterDrift
=
newDrift
;
}
blobSeenSoFar
+
=
2
;
expectedCounter
=
(
expectedCounter
+
3
)
%
256
;
}
if
(
problems
.
length
)
{
assert_true
(
false
{
source
}
blob
payload
problem
:
{
problems
.
join
(
"
\
n
"
)
}
)
;
}
else
{
assert_true
(
true
{
source
}
blob
payloads
validated
.
)
;
}
}
composite_blob_test
(
{
blobCount
:
16
blobSize
:
256
*
1024
name
:
"
Many
blobs
"
}
)
;
