'
use
strict
'
;
async_test
(
t
=
>
{
let
expectedOrder
=
[
'
'
'
\
x00
'
'
0
'
'
1
'
'
A
'
'
B
'
'
a
'
'
b
'
'
\
x7F
'
'
\
xC0
'
'
\
xC1
'
'
\
xE0
'
'
\
xE1
'
'
\
xFF
'
'
\
u0100
'
'
\
u1000
'
'
\
uD834
\
uDD1E
'
'
\
uFFFD
'
]
;
let
i
;
let
tmp
;
const
permutedOrder
=
expectedOrder
.
slice
(
)
;
permutedOrder
.
reverse
(
)
;
for
(
i
=
0
;
i
<
permutedOrder
.
length
-
2
;
i
+
=
2
)
{
tmp
=
permutedOrder
[
i
]
;
permutedOrder
[
i
]
=
permutedOrder
[
i
+
1
]
;
permutedOrder
[
i
+
1
]
=
tmp
;
}
let
objStore
;
let
db
;
const
sortedOrder
=
expectedOrder
.
slice
(
)
;
sortedOrder
.
sort
(
)
;
assert_array_equals
(
sortedOrder
expectedOrder
)
;
const
request
=
createdb
(
t
)
;
request
.
onupgradeneeded
=
t
.
step_func
(
(
e
)
=
>
{
db
=
e
.
target
.
result
;
for
(
let
i
=
0
;
i
<
permutedOrder
.
length
;
i
+
+
)
{
objStore
=
db
.
createObjectStore
(
permutedOrder
[
i
]
)
;
}
assert_array_equals
(
db
.
objectStoreNames
expectedOrder
)
;
for
(
let
i
=
0
;
i
<
permutedOrder
.
length
;
i
+
+
)
{
objStore
.
createIndex
(
permutedOrder
[
i
]
'
keyPath
'
)
;
}
assert_array_equals
(
objStore
.
indexNames
expectedOrder
)
;
}
)
;
request
.
onsuccess
=
t
.
step_func
(
(
e
)
=
>
{
assert_array_equals
(
db
.
objectStoreNames
expectedOrder
)
;
assert_array_equals
(
objStore
.
indexNames
expectedOrder
)
;
t
.
done
(
)
;
}
)
;
}
'
Test
string
list
ordering
in
IndexedDB
'
)
;
