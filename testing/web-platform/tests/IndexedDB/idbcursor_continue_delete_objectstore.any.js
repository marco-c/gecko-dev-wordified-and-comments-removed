'
use
strict
'
;
async_test
(
t
=
>
{
let
db
;
let
count
=
0
;
const
records
=
[
{
pKey
:
'
primaryKey_0
'
}
{
pKey
:
'
primaryKey_1
'
}
{
pKey
:
'
primaryKey_2
'
}
]
;
const
plausibleFutureKey
=
'
primaryKey_9
'
;
let
open_rq
=
createdb
(
t
)
;
open_rq
.
onupgradeneeded
=
function
(
e
)
{
db
=
e
.
target
.
result
;
let
objStore
=
db
.
createObjectStore
(
'
test
'
{
keyPath
:
'
pKey
'
}
)
;
for
(
let
i
=
0
;
i
<
records
.
length
;
i
+
+
)
objStore
.
add
(
records
[
i
]
)
;
}
;
open_rq
.
onsuccess
=
t
.
step_func
(
CursorDeleteRecord
)
;
function
CursorDeleteRecord
(
e
)
{
let
txn
=
db
.
transaction
(
'
test
'
'
readwrite
'
{
durability
:
'
relaxed
'
}
)
;
let
object_store
=
txn
.
objectStore
(
'
test
'
)
;
let
cursor_rq
=
object_store
.
openCursor
(
)
;
let
iteration
=
0
;
cursor_rq
.
onsuccess
=
t
.
step_func
(
function
(
e
)
{
let
cursor
=
e
.
target
.
result
;
switch
(
iteration
)
{
case
0
:
object_store
.
delete
(
plausibleFutureKey
)
;
assert_true
(
cursor
!
=
null
'
cursor
valid
'
)
;
assert_equals
(
cursor
.
value
.
pKey
records
[
iteration
]
.
pKey
)
;
cursor
.
continue
(
)
;
object_store
.
delete
(
records
[
2
]
.
pKey
)
;
break
;
case
1
:
assert_true
(
cursor
!
=
null
'
cursor
valid
'
)
;
assert_equals
(
cursor
.
value
.
pKey
records
[
iteration
]
.
pKey
)
;
cursor
.
continue
(
)
;
break
;
case
2
:
assert_equals
(
cursor
null
'
cursor
no
longer
valid
'
)
;
break
;
}
;
iteration
+
+
;
}
)
;
txn
.
oncomplete
=
t
.
step_func
(
VerifyRecordWasDeleted
)
;
}
function
VerifyRecordWasDeleted
(
e
)
{
let
cursor_rq
=
db
.
transaction
(
'
test
'
'
readonly
'
{
durability
:
'
relaxed
'
}
)
.
objectStore
(
'
test
'
)
.
openCursor
(
)
;
cursor_rq
.
onsuccess
=
t
.
step_func
(
function
(
e
)
{
let
cursor
=
e
.
target
.
result
;
if
(
!
cursor
)
{
assert_equals
(
count
2
'
count
'
)
;
t
.
done
(
)
;
}
assert_equals
(
cursor
.
value
.
pKey
records
[
count
]
.
pKey
)
;
count
+
+
;
cursor
.
continue
(
)
;
}
)
;
}
}
'
Object
store
-
remove
a
record
from
the
object
store
while
iterating
cursor
'
)
;
