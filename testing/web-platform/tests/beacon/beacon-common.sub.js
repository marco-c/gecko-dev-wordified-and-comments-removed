"
use
strict
"
;
var
smallPayloadSize
=
10
;
var
mediumPayloadSize
=
10000
;
var
largePayloadSize
=
50000
;
var
maxPayloadSize
=
65536
;
var
smallPayload
=
smallPayloadSize
+
"
:
"
+
Array
(
smallPayloadSize
)
.
fill
(
'
*
'
)
.
join
(
"
"
)
;
var
mediumPayload
=
mediumPayloadSize
+
"
:
"
+
Array
(
mediumPayloadSize
)
.
fill
(
'
*
'
)
.
join
(
"
"
)
;
var
largePayload
=
largePayloadSize
+
"
:
"
+
Array
(
largePayloadSize
)
.
fill
(
'
*
'
)
.
join
(
"
"
)
;
var
maxPayload
=
(
maxPayloadSize
-
6
)
+
"
:
"
+
Array
(
maxPayloadSize
-
6
)
.
fill
(
'
*
'
)
.
join
(
"
"
)
var
noDataTest
=
{
id
:
"
NoData
"
}
;
var
nullDataTest
=
{
id
:
"
NullData
"
data
:
null
}
;
var
undefinedDataTest
=
{
id
:
"
UndefinedData
"
data
:
undefined
}
;
var
smallStringTest
=
{
id
:
"
SmallString
"
data
:
smallPayload
}
;
var
mediumStringTest
=
{
id
:
"
MediumString
"
data
:
mediumPayload
}
;
var
largeStringTest
=
{
id
:
"
LargeString
"
data
:
largePayload
}
;
var
maxStringTest
=
{
id
:
"
MaxString
"
data
:
maxPayload
}
;
var
emptyBlobTest
=
{
id
:
"
EmptyBlob
"
data
:
new
Blob
(
)
}
;
var
smallBlobTest
=
{
id
:
"
SmallBlob
"
data
:
new
Blob
(
[
smallPayload
]
)
}
;
var
mediumBlobTest
=
{
id
:
"
MediumBlob
"
data
:
new
Blob
(
[
mediumPayload
]
)
}
;
var
largeBlobTest
=
{
id
:
"
LargeBlob
"
data
:
new
Blob
(
[
largePayload
]
)
}
;
var
maxBlobTest
=
{
id
:
"
MaxBlob
"
data
:
new
Blob
(
[
maxPayload
]
)
}
;
var
emptyBufferSourceTest
=
{
id
:
"
EmptyBufferSource
"
data
:
new
Uint8Array
(
)
}
;
var
smallBufferSourceTest
=
{
id
:
"
SmallBufferSource
"
data
:
CreateArrayBufferFromPayload
(
smallPayload
)
}
;
var
mediumBufferSourceTest
=
{
id
:
"
MediumBufferSource
"
data
:
CreateArrayBufferFromPayload
(
mediumPayload
)
}
;
var
largeBufferSourceTest
=
{
id
:
"
LargeBufferSource
"
data
:
CreateArrayBufferFromPayload
(
largePayload
)
}
;
var
maxBufferSourceTest
=
{
id
:
"
MaxBufferSource
"
data
:
CreateArrayBufferFromPayload
(
maxPayload
)
}
;
var
emptyFormDataTest
=
{
id
:
"
EmptyFormData
"
data
:
CreateEmptyFormDataPayload
(
)
}
;
var
smallFormDataTest
=
{
id
:
"
SmallFormData
"
data
:
CreateFormDataFromPayload
(
smallPayload
)
}
;
var
mediumFormDataTest
=
{
id
:
"
MediumFormData
"
data
:
CreateFormDataFromPayload
(
mediumPayload
)
}
;
var
largeFormDataTest
=
{
id
:
"
LargeFormData
"
data
:
CreateFormDataFromPayload
(
largePayload
)
}
;
var
smallSafeContentTypeEncodedTest
=
{
id
:
"
SmallSafeContentTypeEncoded
"
data
:
new
Blob
(
[
smallPayload
]
{
type
:
'
application
/
x
-
www
-
form
-
urlencoded
'
}
)
}
;
var
smallSafeContentTypeFormTest
=
{
id
:
"
SmallSafeContentTypeForm
"
data
:
new
FormData
(
)
}
;
var
smallSafeContentTypeTextTest
=
{
id
:
"
SmallSafeContentTypeText
"
data
:
new
Blob
(
[
smallPayload
]
{
type
:
'
text
/
plain
'
}
)
}
;
var
smallCORSContentTypeTextTest
=
{
id
:
"
SmallCORSContentTypeText
"
data
:
new
Blob
(
[
smallPayload
]
{
type
:
'
text
/
html
'
}
)
}
;
var
stringTests
=
[
noDataTest
nullDataTest
undefinedDataTest
smallStringTest
mediumStringTest
largeStringTest
]
;
var
stringMaxTest
=
[
maxStringTest
]
;
var
blobTests
=
[
emptyBlobTest
smallBlobTest
mediumBlobTest
largeBlobTest
]
;
var
blobMaxTest
=
[
maxBlobTest
]
;
var
bufferSourceTests
=
[
emptyBufferSourceTest
smallBufferSourceTest
mediumBufferSourceTest
largeBufferSourceTest
]
;
var
bufferSourceMaxTest
=
[
maxBufferSourceTest
]
;
var
formDataTests
=
[
emptyFormDataTest
smallFormDataTest
mediumFormDataTest
largeFormDataTest
]
;
var
formDataMaxTest
=
[
largeFormDataTest
]
;
var
contentTypeTests
=
[
smallSafeContentTypeEncodedTest
smallSafeContentTypeFormTest
smallSafeContentTypeTextTest
smallCORSContentTypeTextTest
]
;
var
allTests
=
[
]
.
concat
(
stringTests
stringMaxTest
blobTests
blobMaxTest
bufferSourceTests
bufferSourceMaxTest
formDataTests
formDataMaxTest
contentTypeTests
)
;
var
sampleTests
=
[
noDataTest
nullDataTest
undefinedDataTest
smallStringTest
smallBlobTest
smallBufferSourceTest
smallFormDataTest
smallSafeContentTypeEncodedTest
smallSafeContentTypeFormTest
smallSafeContentTypeTextTest
]
;
var
preflightTests
=
[
smallCORSContentTypeTextTest
]
;
var
testLookup
=
{
}
;
allTests
.
forEach
(
function
(
testCase
)
{
testLookup
[
testCase
.
id
]
=
testCase
;
}
)
;
function
CreateArrayBufferFromPayload
(
payload
)
{
var
length
=
payload
.
length
;
var
buffer
=
new
Uint8Array
(
length
)
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
buffer
[
i
]
=
payload
.
charCodeAt
(
i
)
;
}
return
buffer
;
}
function
CreateEmptyFormDataPayload
(
)
{
if
(
self
.
document
=
=
=
undefined
)
{
return
null
;
}
return
new
FormData
(
)
;
}
function
CreateFormDataFromPayload
(
payload
)
{
if
(
self
.
document
=
=
=
undefined
)
{
return
null
;
}
var
formData
=
new
FormData
(
)
;
formData
.
append
(
"
payload
"
payload
)
;
return
formData
;
}
function
initSession
(
testCases
)
{
return
{
id
:
self
.
token
(
)
testCaseLookup
:
{
}
testCases
:
[
]
totalCount
:
testCases
.
length
sentCount
:
0
doneCount
:
0
add
:
function
add
(
testCase
)
{
this
.
testCases
.
push
(
testCase
)
;
this
.
testCaseLookup
[
testCase
.
id
]
=
testCase
;
}
}
;
}
function
runTests
(
testCases
sendData
=
self
.
sendData
)
{
const
session
=
initSession
(
testCases
)
;
testCases
.
forEach
(
function
(
testCase
testIndex
)
{
const
testCaseCopy
=
Object
.
assign
(
{
session
:
session
}
testCase
)
;
testCaseCopy
.
index
=
testIndex
;
async_test
(
(
test
)
=
>
{
testCaseCopy
.
test
=
test
;
var
baseUrl
=
"
http
:
/
/
{
{
host
}
}
:
{
{
ports
[
http
]
[
0
]
}
}
"
;
if
(
self
.
buildBaseUrl
)
{
baseUrl
=
self
.
buildBaseUrl
(
baseUrl
)
;
}
var
targetUrl
=
{
baseUrl
}
/
beacon
/
resources
/
beacon
.
py
?
cmd
=
store
&
sid
=
{
session
.
id
}
&
tid
=
{
testCaseCopy
.
id
}
&
tidx
=
{
testIndex
}
;
if
(
self
.
buildTargetUrl
)
{
targetUrl
=
self
.
buildTargetUrl
(
targetUrl
)
;
}
testCaseCopy
.
url
=
targetUrl
;
assert_true
(
sendData
(
testCaseCopy
)
'
sendBeacon
should
succeed
'
)
;
waitForResult
(
testCaseCopy
)
.
then
(
(
)
=
>
test
.
done
(
)
test
.
step_func
(
(
e
)
=
>
{
throw
e
;
}
)
)
;
}
Verify
'
navigator
.
sendbeacon
(
)
'
successfully
sends
for
variant
:
{
testCaseCopy
.
id
}
)
;
}
)
;
}
function
sendData
(
testCase
)
{
return
self
.
navigator
.
sendBeacon
(
testCase
.
url
testCase
.
data
)
;
}
async
function
waitForResult
(
testCase
)
{
const
session
=
testCase
.
session
;
const
index
=
testCase
.
index
;
const
url
=
resources
/
beacon
.
py
?
cmd
=
stat
&
sid
=
{
session
.
id
}
&
tidx_min
=
{
index
}
&
tidx_max
=
{
index
}
;
for
(
let
i
=
0
;
i
<
30
;
+
+
i
)
{
const
response
=
await
fetch
(
url
)
;
const
text
=
await
response
.
text
(
)
;
const
results
=
JSON
.
parse
(
text
)
;
if
(
results
.
length
=
=
=
0
)
{
await
new
Promise
(
resolve
=
>
step_timeout
(
resolve
100
)
)
;
continue
;
}
assert_equals
(
results
.
length
1
bad
response
:
'
{
text
}
'
)
;
;
assert_equals
(
results
[
0
]
.
error
null
"
'
sendbeacon
'
data
must
not
fail
validation
"
)
;
return
;
}
assert_true
(
false
'
timeout
'
)
;
}
function
runSendInIframeAndNavigateTests
(
)
{
var
iframe
=
document
.
createElement
(
"
iframe
"
)
;
iframe
.
id
=
"
iframe
"
;
iframe
.
onload
=
function
(
)
{
iframe
.
onload
=
null
;
function
sendData
(
testCase
)
{
return
iframe
.
contentWindow
.
navigator
.
sendBeacon
(
testCase
.
url
testCase
.
data
)
;
}
const
tests
=
[
]
;
for
(
const
test
of
sampleTests
)
{
const
copy
=
Object
.
assign
(
{
}
test
)
;
copy
.
id
=
{
test
.
id
}
-
NAVIGATE
;
tests
.
push
(
copy
)
;
}
runTests
(
tests
sendData
)
;
iframe
.
contentWindow
.
location
=
"
http
:
/
/
{
{
host
}
}
:
{
{
ports
[
http
]
[
0
]
}
}
/
"
;
}
;
iframe
.
srcdoc
=
'
<
html
>
<
/
html
>
'
;
document
.
body
.
appendChild
(
iframe
)
;
}
