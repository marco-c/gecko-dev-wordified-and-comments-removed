const
AriaUtils
=
{
assignAndVerifyRolesByRoleNames
:
function
(
roleNames
)
{
if
(
!
Array
.
isArray
(
roleNames
)
|
|
!
roleNames
.
length
)
{
throw
Param
roleNames
of
assignAndVerifyRolesByRoleNames
(
"
{
roleNames
}
"
)
should
be
an
array
containing
at
least
one
role
string
.
;
}
for
(
const
role
of
roleNames
)
{
promise_test
(
async
t
=
>
{
let
el
=
document
.
createElement
(
"
div
"
)
;
el
.
appendChild
(
document
.
createTextNode
(
"
x
"
)
)
;
el
.
setAttribute
(
"
role
"
role
)
;
document
.
body
.
appendChild
(
el
)
;
const
computedRole
=
await
test_driver
.
get_computed_role
(
el
)
;
assert_equals
(
computedRole
role
el
.
outerHTML
)
;
}
role
:
{
role
}
)
;
}
}
verifyRolesBySelector
:
function
(
selector
)
{
const
els
=
document
.
querySelectorAll
(
selector
)
;
if
(
!
els
.
length
)
{
throw
Selector
passed
in
verifyRolesBySelector
(
"
{
selector
}
"
)
should
match
at
least
one
element
.
;
}
for
(
const
el
of
els
)
{
let
role
=
el
.
getAttribute
(
"
data
-
expectedrole
"
)
;
let
testName
=
el
.
getAttribute
(
"
data
-
testname
"
)
|
|
role
;
promise_test
(
async
t
=
>
{
const
expectedRole
=
el
.
getAttribute
(
"
data
-
expectedrole
"
)
;
const
computedRole
=
await
test_driver
.
get_computed_role
(
el
)
;
assert_equals
(
computedRole
expectedRole
el
.
outerHTML
)
;
}
{
testName
}
)
;
}
}
verifyRoleOrVariantRolesBySelector
:
function
(
selector
roles
)
{
const
els
=
document
.
querySelectorAll
(
selector
)
;
if
(
!
els
.
length
)
{
throw
Selector
"
{
selector
}
"
should
match
at
least
one
element
.
;
}
if
(
!
roles
.
length
|
|
roles
.
length
<
2
)
{
throw
Roles
array
[
"
{
roles
.
join
(
'
"
"
'
)
}
"
]
should
include
at
least
two
strings
a
primary
role
and
at
least
one
acceptable
implementation
-
specific
variant
.
E
.
g
.
[
"
generic
"
"
"
"
none
"
]
;
}
for
(
const
el
of
els
)
{
let
testName
=
el
.
getAttribute
(
"
data
-
testname
"
)
;
promise_test
(
async
t
=
>
{
const
expectedRoles
=
roles
;
const
computedRole
=
await
test_driver
.
get_computed_role
(
el
)
;
for
(
role
of
roles
)
{
if
(
computedRole
=
=
=
role
)
{
return
assert_equals
(
computedRole
role
Computed
Role
:
"
{
computedRole
}
"
matches
one
of
the
acceptable
role
strings
in
[
"
{
roles
.
join
(
'
"
"
'
)
}
"
]
:
{
el
.
outerHTML
}
)
;
}
}
return
assert_false
(
true
Computed
Role
:
"
{
computedRole
}
"
does
not
match
any
of
the
acceptable
role
strings
in
[
"
{
roles
.
join
(
'
"
"
'
)
}
"
]
:
{
el
.
outerHTML
}
)
;
}
{
testName
}
)
;
}
}
verifyGenericRolesBySelector
:
function
(
selector
)
{
this
.
verifyRoleOrVariantRolesBySelector
(
selector
[
"
generic
"
"
"
"
none
"
]
)
;
}
verifyLabelsBySelector
:
function
(
selector
)
{
const
els
=
document
.
querySelectorAll
(
selector
)
;
if
(
!
els
.
length
)
{
throw
Selector
passed
in
verifyLabelsBySelector
(
"
{
selector
}
"
)
should
match
at
least
one
element
.
;
}
for
(
const
el
of
els
)
{
let
label
=
el
.
getAttribute
(
"
data
-
expectedlabel
"
)
;
let
testName
=
el
.
getAttribute
(
"
data
-
testname
"
)
|
|
label
;
promise_test
(
async
t
=
>
{
const
expectedLabel
=
el
.
getAttribute
(
"
data
-
expectedlabel
"
)
;
let
computedLabel
=
await
test_driver
.
get_computed_label
(
el
)
;
computedLabel
=
computedLabel
.
trim
(
)
assert_equals
(
computedLabel
expectedLabel
el
.
outerHTML
)
;
}
{
testName
}
)
;
}
}
}
;
