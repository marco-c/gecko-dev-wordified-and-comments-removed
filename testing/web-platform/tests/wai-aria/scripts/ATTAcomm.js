function
ATTAcomm
(
params
)
{
'
use
strict
'
;
this
.
Params
=
null
;
this
.
Promise
=
null
;
this
.
Properties
=
null
;
this
.
Tests
=
null
;
this
.
testName
=
"
"
;
this
.
log
=
"
"
;
this
.
startReponse
=
{
}
;
this
.
loading
=
true
;
this
.
timeout
=
5000
;
var
pending
=
[
]
;
pending
.
push
(
new
Promise
(
function
(
resolve
)
{
on_event
(
document
"
DOMContentLoaded
"
function
(
)
{
resolve
(
true
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
)
;
if
(
window
&
&
window
.
opener
&
&
window
.
opener
.
testharness_properties
)
{
this
.
Properties
=
window
.
opener
.
testharness_properties
;
}
this
.
Params
=
params
;
if
(
this
.
Params
.
hasOwnProperty
(
"
ATTAuri
"
)
)
{
this
.
ATTAuri
=
this
.
Params
.
ATTAuri
;
}
else
{
this
.
ATTAuri
=
"
http
:
/
/
localhost
:
4119
"
;
}
if
(
this
.
Params
.
hasOwnProperty
(
"
title
"
)
)
{
this
.
testName
=
this
.
Params
.
title
;
}
pending
.
push
(
this
.
loadTest
(
params
)
.
then
(
function
(
tests
)
{
if
(
typeof
tests
=
=
=
'
string
'
)
{
tests
=
JSON
.
parse
(
tests
)
;
}
this
.
Tests
=
tests
;
}
.
bind
(
this
)
)
)
;
this
.
Promise
=
new
Promise
(
function
(
resolve
reject
)
{
Promise
.
all
(
pending
)
.
then
(
function
(
)
{
this
.
loading
=
false
;
this
.
go
(
)
;
resolve
(
this
)
;
}
.
bind
(
this
)
)
.
catch
(
function
(
err
)
{
test
(
function
(
)
{
assert_true
(
false
"
Loading
of
test
components
failed
:
"
+
JSON
.
stringify
(
err
)
)
;
}
"
Loading
test
components
"
)
;
this
.
dumpLog
(
)
;
done
(
)
;
reject
(
"
Loading
of
test
components
failed
:
"
+
JSON
.
stringify
(
err
)
)
;
return
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
return
this
;
}
ATTAcomm
.
prototype
=
{
go
:
function
(
)
{
'
use
strict
'
;
this
.
startTest
(
)
.
then
(
function
(
res
)
{
var
API
=
res
.
body
.
API
;
var
subtestsForAPI
=
false
;
this
.
Tests
.
forEach
(
function
(
subtest
)
{
if
(
subtest
.
hasOwnProperty
(
"
test
"
)
&
&
subtest
.
test
.
hasOwnProperty
(
API
)
)
{
subtestsForAPI
=
true
;
}
else
if
(
Array
.
isArray
(
subtest
)
)
{
subtest
.
forEach
(
function
(
st
)
{
if
(
st
.
hasOwnProperty
(
"
test
"
)
&
&
st
.
test
.
hasOwnProperty
(
API
)
)
{
subtestsForAPI
=
true
;
}
}
)
;
}
}
)
;
if
(
subtestsForAPI
)
{
this
.
runTests
(
API
this
.
Tests
)
.
then
(
function
(
)
{
this
.
endTest
(
)
.
then
(
function
(
)
{
this
.
dumpLog
(
)
;
done
(
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
.
catch
(
function
(
err
)
{
this
.
endTest
(
)
.
then
(
function
(
)
{
this
.
dumpLog
(
)
;
done
(
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
}
else
{
this
.
dumpLog
(
)
;
if
(
window
.
opener
&
&
window
.
opener
.
completion_callback
)
{
window
.
opener
.
completion_callback
(
[
]
{
status
:
3
message
:
"
No
steps
for
AT
API
"
+
API
}
)
;
}
else
{
done
(
)
;
}
}
}
.
bind
(
this
)
)
.
catch
(
function
(
res
)
{
if
(
res
.
timeout
|
|
res
.
status
=
=
=
102
)
{
this
.
setupManualTest
(
"
No
response
from
ATTA
at
"
+
this
.
ATTAuri
)
;
}
else
if
(
res
.
status
=
=
=
200
)
{
this
.
setupManualTest
(
res
.
message
)
;
}
else
if
(
res
.
statusText
=
=
=
"
No
response
from
ATTA
"
)
{
this
.
setupManualTest
(
"
"
)
;
}
else
{
this
.
setupManualTest
(
"
Error
from
ATTA
:
"
+
res
.
status
+
"
:
"
+
res
.
statusText
)
;
}
}
.
bind
(
this
)
)
;
}
runTests
:
function
(
API
collection
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
pending
=
[
]
;
var
testCount
=
0
;
this
.
sendEvents
(
API
collection
)
.
then
(
function
(
eventStatus
)
{
collection
.
forEach
(
function
(
subtest
)
{
var
theType
=
"
test
"
;
if
(
Array
.
isArray
(
subtest
)
)
{
Promise
.
all
(
pending
)
.
then
(
function
(
)
{
pending
=
[
]
;
pending
.
push
(
this
.
runTests
(
API
subtest
)
)
;
}
.
bind
(
this
)
)
;
}
else
if
(
subtest
.
hasOwnProperty
(
"
type
"
)
)
{
theType
=
subtest
.
type
;
}
testCount
+
+
;
if
(
theType
=
=
=
"
test
"
)
{
pending
.
push
(
this
.
runTest
(
testCount
API
subtest
)
)
;
}
else
if
(
theType
=
=
=
"
script
"
)
{
Promise
.
all
(
pending
)
.
then
(
function
(
)
{
pending
=
[
]
;
this
.
runScript
(
testCount
subtest
)
;
}
.
bind
(
this
)
)
;
}
else
if
(
theType
=
=
=
"
attribute
"
)
{
Promise
.
all
(
pending
)
.
then
(
function
(
)
{
pending
=
[
]
;
this
.
handleAttribute
(
testCount
subtest
)
;
}
.
bind
(
this
)
)
;
}
else
if
(
theType
=
=
=
"
event
"
)
{
Promise
.
all
(
pending
)
.
then
(
function
(
)
{
pending
=
[
]
;
this
.
raiseEvent
(
testCount
subtest
)
;
}
.
bind
(
this
)
)
;
}
}
.
bind
(
this
)
)
;
Promise
.
all
(
pending
)
.
then
(
function
(
)
{
if
(
eventStatus
!
=
=
"
NOEVENTS
"
)
{
this
.
sendStopListen
(
)
.
then
(
function
(
)
{
resolve
(
true
)
;
}
)
;
}
else
{
resolve
(
true
)
;
}
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
}
setupManualTest
:
function
(
message
)
{
'
use
strict
'
;
var
ref
=
document
.
getElementById
(
"
manualMode
"
)
;
if
(
ref
)
{
var
content
=
"
<
h2
>
Manual
Mode
Enabled
<
/
h2
>
<
p
>
"
+
message
+
"
<
/
p
>
"
;
if
(
this
.
Tests
.
hasOwnProperty
(
"
description
"
)
)
{
content
+
=
"
<
p
>
"
+
this
.
Tests
.
description
+
"
<
/
p
>
"
;
}
var
theTable
=
"
<
table
id
=
'
steps
'
>
<
tr
>
<
th
>
Step
<
/
th
>
<
th
>
Type
<
/
th
>
<
th
>
Element
ID
<
/
th
>
<
th
>
Assertions
<
/
th
>
<
/
tr
>
"
;
this
.
Tests
.
forEach
(
function
(
subtest
)
{
var
type
=
"
test
"
;
if
(
subtest
.
hasOwnProperty
(
"
type
"
)
)
{
type
=
subtest
.
type
;
}
var
id
=
"
"
;
if
(
subtest
.
hasOwnProperty
(
"
element
"
)
)
{
id
=
subtest
.
element
;
}
theTable
+
=
"
<
tr
>
<
td
class
=
'
step
'
>
"
+
subtest
.
title
+
"
<
/
td
>
"
;
theTable
+
=
"
<
td
class
=
'
type
'
>
"
+
type
+
"
<
/
td
>
"
;
theTable
+
=
"
<
td
class
=
'
element
'
>
"
+
id
+
"
<
/
td
>
"
;
if
(
type
=
=
=
"
test
"
)
{
theTable
+
=
"
<
td
>
"
+
this
.
buildAssertionTable
(
subtest
.
test
)
+
"
<
/
td
>
"
;
}
else
if
(
type
=
=
=
"
attribute
"
)
{
if
(
subtest
.
hasOwnProperty
(
"
attribute
"
)
&
&
subtest
.
hasOwnProperty
(
"
value
"
)
&
&
subtest
.
hasOwnProperty
(
"
element
"
)
)
{
if
(
subtest
.
value
=
=
=
"
none
"
)
{
theTable
+
=
"
<
td
>
Remove
attribute
<
code
>
"
+
subtest
.
attribute
+
"
<
/
code
>
from
the
element
with
ID
<
code
>
"
+
subtest
.
element
+
"
<
/
code
>
<
/
td
>
"
;
}
else
{
theTable
+
=
"
<
td
>
Set
attribute
<
code
>
"
+
subtest
.
attribute
+
"
<
/
code
>
on
the
element
with
ID
<
code
>
"
+
subtest
.
element
+
"
<
/
code
>
to
the
value
<
code
>
"
+
subtest
.
value
+
"
<
/
code
>
<
/
td
>
"
;
}
}
}
else
if
(
type
=
=
=
"
event
"
)
{
if
(
subtest
.
hasOwnProperty
(
"
event
"
)
&
&
subtest
.
hasOwnProperty
(
"
element
"
)
)
{
theTable
+
=
"
<
td
>
Send
event
<
code
>
"
+
subtest
.
event
+
"
<
/
code
>
to
the
element
with
ID
<
code
>
"
+
subtest
.
element
+
"
<
/
code
>
<
/
td
>
"
;
}
}
else
if
(
type
=
=
=
"
script
"
)
{
theTable
+
=
"
<
td
>
Script
:
"
+
subtest
.
script
+
"
<
/
td
>
"
;
}
else
{
theTable
+
=
"
<
td
>
Unknown
type
:
"
+
type
+
"
<
/
td
>
"
;
}
theTable
+
=
"
<
/
tr
>
"
;
}
.
bind
(
this
)
)
;
theTable
+
=
"
<
/
table
>
"
;
ref
.
innerHTML
=
content
+
theTable
;
}
}
buildAssertionTable
:
function
(
asserts
)
{
"
use
strict
"
;
var
output
=
"
<
table
class
=
'
api
'
>
<
tr
>
<
th
>
API
Name
<
/
th
>
<
th
colspan
=
'
4
'
>
Assertions
<
/
th
>
<
/
tr
>
"
;
var
APIs
=
[
]
;
for
(
var
k
in
asserts
)
{
if
(
asserts
.
hasOwnProperty
(
k
)
)
{
APIs
.
push
(
k
)
;
}
}
APIs
.
sort
(
)
.
forEach
(
function
(
theAPI
)
{
var
rows
=
asserts
[
theAPI
]
;
var
height
=
rows
.
length
;
output
+
=
"
<
tr
>
<
td
rowspan
=
'
"
+
height
+
"
'
class
=
'
apiName
'
>
"
+
theAPI
+
"
<
/
td
>
"
;
var
lastRow
=
rows
.
length
-
1
;
rows
.
forEach
(
function
(
theRow
index
)
{
var
span
=
4
-
theRow
.
length
;
var
colspan
=
span
?
"
colspan
=
'
"
+
span
+
"
'
"
:
"
"
;
theRow
.
forEach
(
function
(
item
)
{
output
+
=
"
<
td
"
+
colspan
+
"
>
"
+
item
+
"
<
/
td
>
"
;
}
)
;
output
+
=
"
<
/
tr
>
"
;
if
(
index
<
lastRow
)
{
output
+
=
"
<
tr
>
"
;
}
}
)
;
}
)
;
output
+
=
"
<
/
table
>
"
;
return
output
;
}
eventList
:
function
(
API
collection
)
{
var
eventHash
=
{
}
;
if
(
!
API
|
|
API
=
=
=
"
"
)
{
return
[
]
;
}
collection
.
forEach
(
function
(
subtest
)
{
if
(
subtest
.
hasOwnProperty
(
"
test
"
)
&
&
subtest
.
test
.
hasOwnProperty
(
API
)
)
{
subtest
.
test
[
API
]
.
forEach
(
function
(
assert
)
{
if
(
assert
[
0
]
=
=
=
"
event
"
&
&
assert
[
1
]
=
=
=
"
type
"
&
&
assert
[
2
]
=
=
=
"
is
"
)
{
eventHash
[
assert
[
3
]
]
=
1
;
}
}
)
;
}
}
)
;
return
Object
.
keys
(
eventHash
)
;
}
handleAttribute
:
function
(
testNum
subtest
)
{
"
use
strict
"
;
if
(
subtest
)
{
if
(
subtest
.
hasOwnProperty
(
"
attribute
"
)
&
&
subtest
.
hasOwnProperty
(
"
element
"
)
&
&
subtest
.
hasOwnProperty
(
"
value
"
)
)
{
try
{
var
node
=
document
.
getElementById
(
subtest
.
element
)
;
if
(
node
)
{
if
(
subtest
.
value
=
=
=
"
none
"
)
{
node
.
removeAttribute
(
subtest
.
attribute
)
;
}
else
if
(
subtest
.
value
=
=
=
'
"
"
'
)
{
node
.
setAttribute
(
subtest
.
attribute
"
"
)
;
}
else
if
(
subtest
.
value
.
match
(
/
^
"
/
)
)
{
var
v
=
subtest
.
value
;
v
=
v
.
replace
(
/
^
"
/
'
'
)
;
v
=
v
.
replace
(
/
"
/
'
'
)
;
node
.
setAttribute
(
subtest
.
attribute
v
)
;
}
else
{
node
.
setAttribute
(
subtest
.
attribute
subtest
.
value
)
;
}
}
}
catch
(
e
)
{
test
(
function
(
)
{
assert_true
(
false
"
Subtest
attribute
failed
to
update
:
"
+
e
)
;
}
"
Attribute
subtest
"
+
testNum
)
;
}
}
else
{
test
(
function
(
)
{
var
err
=
"
"
;
if
(
!
subtest
.
hasOwnProperty
(
"
attribute
"
)
)
{
err
+
=
"
Attribute
subtest
has
no
attribute
property
;
"
;
}
else
if
(
!
subtest
.
hasOwnProperty
(
"
value
"
)
)
{
err
+
=
"
Attribute
subtest
has
no
value
property
;
"
;
}
else
if
(
!
subtest
.
hasOwnProperty
(
"
element
"
)
)
{
err
+
=
"
Attribute
subtest
has
no
element
property
;
"
;
}
assert_true
(
false
err
)
;
}
"
Attribute
subtest
"
+
testNum
)
;
}
}
return
;
}
raiseEvent
:
function
(
testNum
subtest
)
{
"
use
strict
"
;
var
evt
;
if
(
subtest
)
{
var
kp
=
function
(
target
key
)
{
evt
=
document
.
createEvent
(
"
KeyboardEvent
"
)
;
evt
.
initKeyEvent
(
"
keypress
"
true
true
window
0
0
0
0
0
"
e
"
.
charCodeAt
(
0
)
)
;
target
.
dispatchEvent
(
evt
)
;
}
;
if
(
subtest
.
hasOwnProperty
(
"
event
"
)
&
&
subtest
.
hasOwnProperty
(
"
element
"
)
)
{
try
{
var
node
=
document
.
getElementById
(
subtest
.
element
)
;
if
(
node
)
{
if
(
subtest
.
event
=
=
=
"
focus
"
)
{
node
.
focus
(
)
;
}
else
if
(
subtest
.
event
=
=
=
"
select
"
)
{
node
.
click
(
)
;
}
else
if
(
subtest
.
event
.
startsWith
(
'
key
:
'
)
)
{
var
key
=
subtest
.
event
.
replace
(
'
key
:
'
'
'
)
;
evt
=
new
KeyboardEvent
(
"
keypress
"
{
"
key
"
:
key
}
)
;
node
.
dispatchEvent
(
evt
)
;
}
else
{
evt
=
new
Event
(
subtest
.
element
)
;
node
.
dispatchEvent
(
evt
)
;
}
}
}
catch
(
e
)
{
test
(
function
(
)
{
assert_true
(
false
"
Subtest
event
failed
to
dispatch
:
"
+
e
)
;
}
"
Event
subtest
"
+
testNum
)
;
}
}
else
{
test
(
function
(
)
{
var
err
=
"
"
;
if
(
!
subtest
.
hasOwnProperty
(
"
event
"
)
)
{
err
+
=
"
Event
subtest
has
no
event
property
;
"
;
}
else
if
(
!
subtest
.
hasOwnProperty
(
"
element
"
)
)
{
err
+
=
"
Event
subtest
has
no
element
property
;
"
;
}
assert_true
(
false
err
)
;
}
"
Event
subtest
"
+
testNum
)
;
}
}
return
;
}
runScript
:
function
(
testNum
subtest
)
{
"
use
strict
"
;
if
(
subtest
)
{
if
(
subtest
.
hasOwnProperty
(
"
script
"
)
&
&
typeof
subtest
.
script
=
=
=
"
string
"
)
{
try
{
eval
(
subtest
.
script
)
;
}
catch
(
e
)
{
test
(
function
(
)
{
assert_true
(
false
"
Subtest
script
"
+
subtest
.
script
+
"
failed
to
evaluate
:
"
+
e
)
;
}
"
Event
subtest
"
+
testNum
)
;
}
}
else
{
test
(
function
(
)
{
assert_true
(
false
"
Event
subtest
has
no
script
property
"
)
;
}
"
Event
subtest
"
+
testNum
)
;
}
}
return
;
}
runTest
:
function
(
testNum
API
subtest
)
{
'
use
strict
'
;
var
data
=
{
"
title
"
:
subtest
.
title
"
id
"
:
subtest
.
element
"
data
"
:
this
.
normalize
(
subtest
.
test
[
API
]
)
}
;
return
new
Promise
(
function
(
resolve
)
{
var
ANNO
=
this
;
if
(
subtest
.
test
[
API
]
)
{
promise_test
(
function
(
)
{
this
.
add_cleanup
(
function
(
)
{
resolve
(
true
)
;
}
)
;
return
ANNO
.
sendTest
(
data
)
.
then
(
function
(
res
)
{
if
(
typeof
res
.
body
=
=
=
"
object
"
&
&
res
.
body
.
hasOwnProperty
(
"
status
"
)
)
{
if
(
res
.
body
.
status
=
=
=
"
OK
"
)
{
var
messages
=
"
"
;
var
thisResult
=
null
;
var
theLog
=
"
"
;
var
assertionCount
=
0
;
res
.
body
.
results
.
forEach
(
function
(
a
)
{
if
(
typeof
a
=
=
=
"
object
"
)
{
var
aRef
=
data
.
data
[
assertionCount
]
;
var
assertionText
=
'
"
'
+
aRef
.
join
(
"
"
)
+
'
"
'
;
if
(
a
.
hasOwnProperty
(
"
log
"
)
&
&
a
.
log
!
=
=
null
&
&
a
.
log
!
=
=
'
'
)
{
theLog
+
=
"
\
n
-
-
-
Assertion
"
+
assertionCount
+
"
-
-
-
"
;
theLog
+
=
"
\
nAssertion
:
"
+
assertionText
+
"
\
nLog
data
:
"
+
a
.
log
;
}
var
theMessage
=
"
"
;
if
(
a
.
hasOwnProperty
(
"
message
"
)
)
{
theMessage
=
a
.
message
;
}
if
(
!
a
.
hasOwnProperty
(
"
result
"
)
)
{
messages
+
=
"
ATTA
did
not
report
a
result
"
+
theMessage
+
"
;
"
;
}
else
if
(
a
.
result
=
=
=
"
ERROR
"
)
{
messages
+
=
"
ATTA
reported
ERROR
with
message
:
"
+
theMessage
+
"
;
"
;
}
else
if
(
a
.
result
=
=
=
"
FAIL
"
)
{
thisResult
=
false
;
messages
+
=
assertionText
+
"
failed
"
+
theMessage
+
"
;
"
;
}
else
if
(
a
.
result
=
=
=
"
PASS
"
&
&
thisResult
=
=
=
null
)
{
thisResult
=
true
;
}
}
assertionCount
+
+
;
}
)
;
if
(
theLog
!
=
=
"
"
)
{
ANNO
.
saveLog
(
"
runTest
"
theLog
subtest
)
;
}
if
(
thisResult
!
=
=
null
)
{
assert_true
(
thisResult
messages
)
;
}
else
{
assert_true
(
false
"
ERROR
:
No
results
reported
from
ATTA
;
"
+
messages
)
;
}
}
else
if
(
res
.
body
.
status
=
=
=
"
ERROR
"
)
{
assert_true
(
false
"
ATTA
returned
ERROR
with
message
:
"
+
res
.
body
.
statusText
)
;
}
else
{
assert_true
(
false
"
ATTA
returned
unknown
status
"
+
res
.
body
.
status
+
"
with
message
:
"
+
res
.
body
.
statusText
)
;
}
}
else
{
assert_true
(
false
"
ATTA
failed
to
return
a
result
object
:
returned
:
"
+
JSON
.
stringify
(
res
)
)
;
}
}
)
;
}
subtest
.
name
)
;
}
else
{
promise_test
(
function
(
)
{
this
.
add_cleanup
(
function
(
)
{
resolve
(
true
)
;
}
)
;
return
new
Promise
(
function
(
innerResolve
)
{
innerResolve
(
true
)
;
}
)
.
then
(
function
(
res
)
{
var
theLog
=
"
\
nSUBTEST
NOTRUN
:
No
assertions
for
API
"
+
API
+
"
\
n
"
;
if
(
theLog
!
=
=
"
"
)
{
ANNO
.
saveLog
(
"
runTest
"
theLog
subtest
)
;
}
assert_false
(
true
"
NOTRUN
:
No
assertion
for
API
"
+
API
)
;
}
)
;
}
subtest
.
name
)
;
}
}
.
bind
(
this
)
)
;
}
loadTest
:
function
(
params
)
{
'
use
strict
'
;
if
(
params
.
hasOwnProperty
(
'
stepFile
'
)
)
{
return
this
.
_fetch
(
"
GET
"
params
.
stepFile
)
;
}
return
new
Promise
(
function
(
resolve
reject
)
{
if
(
params
.
hasOwnProperty
(
'
steps
'
)
)
{
resolve
(
params
.
steps
)
;
}
else
{
reject
(
"
Must
supply
a
'
steps
'
or
'
stepFile
'
parameter
"
)
;
}
}
)
;
}
dumpLog
:
function
(
)
{
'
use
strict
'
;
if
(
this
.
log
!
=
=
"
"
)
{
var
ref
=
document
.
getElementById
(
"
ATTAmessages
"
)
;
if
(
ref
)
{
var
content
=
"
<
h2
>
Logging
information
recorded
<
/
h2
>
"
;
if
(
this
.
startResponse
&
&
this
.
startResponse
.
hasOwnProperty
(
"
API
"
)
)
{
content
+
=
"
<
h3
>
ATTA
Information
<
/
h3
>
"
;
content
+
=
"
<
pre
>
"
+
JSON
.
stringify
(
this
.
startResponse
null
"
"
)
+
"
<
/
pre
>
"
;
}
content
+
=
"
<
textarea
rows
=
'
50
'
style
=
'
width
:
100
%
'
>
"
+
this
.
log
+
"
<
/
textarea
>
"
;
ref
.
innerHTML
=
content
;
}
}
}
saveLog
:
function
(
caller
message
subtest
)
{
'
use
strict
'
;
if
(
typeof
message
=
=
=
"
string
"
&
&
message
!
=
=
"
"
)
{
this
.
log
+
=
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
\
n
"
;
this
.
log
+
=
"
Message
from
"
+
caller
+
"
\
n
"
;
if
(
subtest
&
&
typeof
subtest
=
=
=
"
object
"
)
{
var
API
=
this
.
startResponse
.
API
;
this
.
log
+
=
"
\
n
SUBTEST
TITLE
:
"
+
subtest
.
title
;
this
.
log
+
=
"
\
n
SUBTEST
ELEMENT
:
"
+
subtest
.
element
;
this
.
log
+
=
"
\
n
SUBTEST
DATA
:
"
+
JSON
.
stringify
(
subtest
.
test
[
API
]
)
;
this
.
log
+
=
"
\
n
\
n
"
;
}
this
.
log
+
=
message
;
}
return
;
}
startTest
:
function
(
)
{
'
use
strict
'
;
return
new
Promise
(
function
(
resolve
reject
)
{
var
params
=
{
test
:
this
.
testName
|
|
window
.
title
url
:
document
.
location
.
href
}
;
this
.
_fetch
(
"
POST
"
this
.
ATTAuri
+
"
/
start
"
null
params
)
.
then
(
function
(
res
)
{
if
(
res
.
body
.
hasOwnProperty
(
"
status
"
)
)
{
if
(
res
.
body
.
status
=
=
=
"
READY
"
)
{
this
.
startResponse
=
res
.
body
;
if
(
res
.
body
.
hasOwnProperty
(
"
log
"
)
)
{
this
.
saveLog
(
"
startTest
"
res
.
body
.
log
)
;
}
if
(
res
.
body
.
hasOwnProperty
(
"
API
"
)
)
{
resolve
(
res
)
;
}
else
{
res
.
message
=
"
No
API
in
response
from
ATTA
"
;
reject
(
res
)
;
}
}
else
{
res
.
message
=
"
ATTA
reported
an
error
:
"
+
res
.
body
.
statusText
;
reject
(
res
)
;
}
}
else
{
res
.
message
=
"
ATTA
did
not
report
a
status
"
;
reject
(
res
)
;
}
}
.
bind
(
this
)
)
.
catch
(
function
(
res
)
{
reject
(
res
)
;
}
)
;
}
.
bind
(
this
)
)
;
}
sendEvents
:
function
(
API
collection
)
{
'
use
strict
'
;
return
new
Promise
(
function
(
resolve
reject
)
{
var
eList
=
this
.
eventList
(
API
collection
)
;
if
(
eList
&
&
eList
.
length
)
{
var
params
=
{
events
:
eList
}
;
this
.
_fetch
(
"
POST
"
this
.
ATTAuri
+
"
/
startlisten
"
null
params
)
.
then
(
function
(
res
)
{
if
(
res
.
body
.
hasOwnProperty
(
"
status
"
)
)
{
if
(
res
.
body
.
status
=
=
=
"
READY
"
)
{
if
(
res
.
body
.
hasOwnProperty
(
"
log
"
)
)
{
this
.
saveLog
(
"
sendEvents
"
res
.
body
.
log
)
;
}
resolve
(
res
.
body
.
status
)
;
}
else
{
res
.
message
=
"
ATTA
reported
an
error
:
"
+
res
.
body
.
statusText
;
reject
(
res
)
;
}
}
else
{
res
.
message
=
"
ATTA
did
not
report
a
status
"
;
reject
(
res
)
;
}
}
.
bind
(
this
)
)
.
catch
(
function
(
res
)
{
reject
(
res
)
;
}
)
;
}
else
{
resolve
(
"
NOEVENTS
"
)
;
}
}
.
bind
(
this
)
)
;
}
sendStopListen
:
function
(
)
{
'
use
strict
'
;
return
this
.
_fetch
(
"
POST
"
this
.
ATTAuri
+
"
/
stoplisten
"
null
null
)
;
}
sendTest
:
function
(
testData
)
{
'
use
strict
'
;
if
(
typeof
testData
!
=
=
"
string
"
)
{
testData
=
JSON
.
stringify
(
testData
)
;
}
var
ret
=
this
.
_fetch
(
"
POST
"
this
.
ATTAuri
+
"
/
test
"
null
testData
true
)
;
ret
.
then
(
function
(
res
)
{
if
(
res
.
body
.
hasOwnProperty
(
"
log
"
)
)
{
this
.
saveLog
(
"
sendTest
"
res
.
body
.
log
)
;
}
}
.
bind
(
this
)
)
;
return
ret
;
}
endTest
:
function
(
)
{
'
use
strict
'
;
return
this
.
_fetch
(
"
GET
"
this
.
ATTAuri
+
"
/
end
"
)
;
}
normalize
:
function
(
data
)
{
'
use
strict
'
;
var
ret
=
[
]
;
if
(
data
)
{
data
.
forEach
(
function
(
assert
)
{
var
normal
=
[
]
;
if
(
Array
.
isArray
(
assert
)
)
{
normal
[
0
]
=
assert
[
0
]
;
normal
[
1
]
=
assert
[
1
]
;
normal
[
2
]
=
assert
[
2
]
;
if
(
"
string
"
=
=
=
typeof
assert
[
3
]
&
&
assert
[
3
]
.
match
(
/
^
\
[
.
*
\
]
/
)
)
{
normal
[
3
]
=
assert
[
3
]
.
replace
(
/
+
/
'
'
)
;
}
else
{
normal
[
3
]
=
assert
[
3
]
;
}
ret
.
push
(
normal
)
;
}
else
{
ret
.
push
(
assert
)
;
}
}
)
;
}
return
ret
;
}
_fetch
:
function
(
method
url
headers
content
parse
)
{
'
use
strict
'
;
if
(
method
=
=
=
null
|
|
method
=
=
=
undefined
)
{
method
=
"
GET
"
;
}
if
(
parse
=
=
=
null
|
|
parse
=
=
=
undefined
)
{
parse
=
true
;
}
if
(
headers
=
=
=
null
|
|
headers
=
=
=
undefined
)
{
headers
=
[
]
;
}
return
new
Promise
(
function
(
resolve
reject
)
{
var
xhr
=
new
XMLHttpRequest
(
)
;
var
resp
=
{
xhr
:
xhr
headers
:
null
status
:
0
statusText
:
"
"
body
:
null
text
:
"
"
}
;
xhr
.
open
(
method
url
)
;
headers
.
forEach
(
function
(
ref
)
{
xhr
.
setRequestHeader
(
ref
[
0
]
ref
[
1
]
)
;
}
)
;
xhr
.
ontimeout
=
function
(
)
{
resp
.
timeout
=
this
.
timeout
;
resolve
(
resp
)
;
}
;
xhr
.
onerror
=
function
(
)
{
if
(
this
.
status
)
{
resp
.
status
=
this
.
status
;
resp
.
statusText
=
xhr
.
statusText
;
}
else
if
(
this
.
status
=
=
=
0
)
{
resp
.
status
=
0
;
resp
.
statusText
=
"
No
response
from
ATTA
"
;
}
reject
(
resp
)
;
}
;
xhr
.
onload
=
function
(
)
{
resp
.
status
=
this
.
status
;
if
(
this
.
status
>
=
200
&
&
this
.
status
<
300
)
{
var
d
=
xhr
.
response
;
resp
.
text
=
d
;
if
(
parse
)
{
try
{
d
=
JSON
.
parse
(
d
)
;
resp
.
body
=
d
;
}
catch
(
err
)
{
resp
.
body
=
null
;
}
}
resolve
(
resp
)
;
}
else
{
reject
(
{
status
:
this
.
status
statusText
:
xhr
.
statusText
}
)
;
}
}
;
if
(
content
!
=
=
null
&
&
content
!
=
=
undefined
)
{
if
(
"
object
"
=
=
=
typeof
(
content
)
)
{
xhr
.
send
(
JSON
.
stringify
(
content
)
)
;
}
else
if
(
"
function
"
=
=
=
typeof
(
content
)
)
{
xhr
.
send
(
content
(
)
)
;
}
else
if
(
"
string
"
=
=
=
typeof
(
content
)
)
{
xhr
.
send
(
content
)
;
}
}
else
{
xhr
.
send
(
)
;
}
}
)
;
}
}
;
