let
next_property_id
=
1
;
function
generate_name
(
)
{
return
-
-
prop
-
{
next_property_id
+
+
}
;
}
function
any_initial_value
(
syntax
)
{
let
components
=
syntax
.
split
(
'
|
'
)
.
map
(
x
=
>
x
.
trim
(
)
)
let
first_component
=
components
[
0
]
;
if
(
first_component
.
endsWith
(
'
+
'
)
|
|
first_component
.
endsWith
(
'
#
'
)
)
first_component
=
first_component
.
slice
(
0
-
1
)
;
switch
(
first_component
)
{
case
'
*
'
:
case
'
<
custom
-
ident
>
'
:
return
'
NULL
'
;
case
'
<
angle
>
'
:
return
'
0deg
'
;
case
'
<
color
>
'
:
return
'
rgb
(
0
0
0
)
'
;
case
'
<
image
>
'
:
case
'
<
url
>
'
:
return
'
url
(
0
)
'
;
case
'
<
integer
>
'
:
case
'
<
length
-
percentage
>
'
:
case
'
<
length
>
'
:
case
'
<
number
>
'
:
return
'
0
'
;
case
'
<
percentage
>
'
:
return
'
0
%
'
;
case
'
<
resolution
>
'
:
return
'
0dpi
'
;
case
'
<
time
>
'
:
return
'
0s
'
;
case
'
<
transform
-
function
>
'
:
case
'
<
transform
-
list
>
'
:
return
'
matrix
(
0
0
0
0
0
0
)
'
;
default
:
return
first_component
;
}
}
function
generate_property
(
reg
)
{
if
(
typeof
(
reg
)
=
=
=
'
object
'
)
{
const
permitted
=
new
Set
(
[
'
name
'
'
syntax
'
'
initialValue
'
'
inherits
'
]
)
;
if
(
!
Object
.
keys
(
reg
)
.
every
(
k
=
>
permitted
.
has
(
k
)
)
)
throw
new
Error
(
'
generate_property
:
invalid
parameter
'
)
;
}
let
syntax
=
typeof
(
reg
)
=
=
=
'
string
'
?
reg
:
reg
.
syntax
;
let
initial
=
typeof
(
reg
.
initialValue
)
=
=
=
'
undefined
'
?
any_initial_value
(
syntax
)
:
reg
.
initialValue
;
let
inherits
=
typeof
(
reg
.
inherits
)
=
=
=
'
undefined
'
?
false
:
reg
.
inherits
;
let
name
=
generate_name
(
)
;
CSS
.
registerProperty
(
{
name
:
name
syntax
:
syntax
initialValue
:
initial
inherits
:
inherits
}
)
;
return
name
;
}
function
all_syntaxes
(
)
{
return
[
'
*
'
'
<
angle
>
'
'
<
color
>
'
'
<
custom
-
ident
>
'
'
<
image
>
'
'
<
integer
>
'
'
<
length
-
percentage
>
'
'
<
length
>
'
'
<
number
>
'
'
<
percentage
>
'
'
<
resolution
>
'
'
<
time
>
'
'
<
transform
-
function
>
'
'
<
transform
-
list
>
'
'
<
url
>
'
]
}
