(
function
(
root
)
{
'
use
strict
'
;
root
.
setStyle
=
function
(
selector
styles
)
{
var
target
=
document
.
getElementById
(
'
dynamic
-
style
'
)
;
if
(
!
target
)
{
target
=
document
.
createElement
(
'
style
'
)
;
target
.
id
=
'
dynamic
-
style
'
;
target
.
type
=
"
text
/
css
"
;
document
.
getElementsByTagName
(
'
head
'
)
[
0
]
.
appendChild
(
target
)
;
}
var
data
=
[
]
;
if
(
typeof
selector
=
=
=
'
string
'
&
&
styles
!
=
=
undefined
)
{
data
=
[
selector
'
{
'
serializeStyles
(
styles
)
'
}
'
]
;
target
.
textContent
=
data
.
join
(
"
\
n
"
)
;
return
;
}
for
(
var
key
in
selector
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
selector
key
)
)
{
var
_data
=
[
key
'
{
'
serializeStyles
(
selector
[
key
]
)
'
}
'
]
;
data
.
push
(
_data
.
join
(
'
\
n
'
)
)
;
}
}
target
.
textContent
=
data
.
join
(
"
\
n
"
)
;
}
;
function
serializeStyles
(
styles
)
{
var
data
=
[
]
;
for
(
var
property
in
styles
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
styles
property
)
)
{
var
prefixedProperty
=
addVendorPrefix
(
property
)
;
data
.
push
(
prefixedProperty
+
"
:
"
+
styles
[
property
]
+
"
;
"
)
;
}
}
return
data
.
join
(
'
\
n
'
)
;
}
root
.
computedStyle
=
function
(
element
property
pseudo
)
{
var
prefixedProperty
=
addVendorPrefix
(
property
)
;
return
window
.
getComputedStyle
(
element
pseudo
|
|
null
)
.
getPropertyValue
(
prefixedProperty
)
;
}
;
root
.
reflow
=
function
(
)
{
document
.
body
.
offsetWidth
;
}
;
root
.
extend
=
function
(
target
)
{
Array
.
prototype
.
slice
.
call
(
arguments
1
)
.
forEach
(
function
(
obj
)
{
Object
.
keys
(
obj
)
.
forEach
(
function
(
key
)
{
target
[
key
]
=
obj
[
key
]
;
}
)
;
}
)
;
return
target
;
}
;
var
_domFixture
;
var
_domFixtureSelector
;
root
.
domFixture
=
function
(
selector
)
{
var
fixture
=
document
.
querySelector
(
selector
|
|
_domFixtureSelector
)
;
if
(
!
fixture
)
{
throw
new
Error
(
'
fixture
'
+
(
selector
|
|
_domFixtureSelector
)
+
'
not
found
!
'
)
;
}
if
(
!
_domFixture
&
&
selector
)
{
_domFixture
=
fixture
.
cloneNode
(
true
)
;
_domFixtureSelector
=
selector
;
}
else
if
(
_domFixture
)
{
var
tmp
=
_domFixture
.
cloneNode
(
true
)
;
fixture
.
parentNode
.
replaceChild
(
tmp
fixture
)
;
}
else
{
throw
new
Error
(
'
domFixture
must
be
initialized
first
!
'
)
;
}
}
;
root
.
MS_PER_SEC
=
1000
;
const
TIME_PRECISION
=
0
.
0005
;
root
.
assert_times_equal
=
function
(
actual
expected
description
)
{
assert_approx_equals
(
actual
expected
TIME_PRECISION
description
)
;
}
;
root
.
assert_time_equals_literal
=
(
actual
expected
description
)
=
>
{
assert_approx_equals
(
actual
expected
TIME_PRECISION
description
)
;
}
;
root
.
assert_end_events_equal
=
function
(
evt
propertyName
elapsedTime
pseudoElement
=
'
'
)
{
assert_equals
(
evt
.
propertyName
propertyName
)
;
assert_times_equal
(
evt
.
elapsedTime
elapsedTime
)
;
assert_equals
(
evt
.
pseudoElement
pseudoElement
)
;
}
;
root
.
assert_end_event_batch_equal
=
function
(
evts
propertyNames
elapsedTimes
pseudoElement
=
'
'
)
{
assert_equals
(
evts
.
length
propertyNames
.
length
'
Test
harness
error
:
should
have
waited
for
the
correct
number
of
events
'
)
;
assert_true
(
typeof
elapsedTimes
=
=
=
'
number
'
|
|
(
Array
.
isArray
(
elapsedTimes
)
&
&
elapsedTimes
.
length
=
=
=
propertyNames
.
length
)
'
Test
harness
error
:
elapsedTimes
must
either
be
a
number
or
an
array
of
'
+
'
numbers
with
the
same
length
as
propertyNames
'
)
;
if
(
typeof
elapsedTimes
=
=
=
'
number
'
)
{
elapsedTimes
=
Array
(
propertyNames
.
length
)
.
fill
(
elapsedTimes
)
;
}
const
testPairs
=
propertyNames
.
map
(
(
propertyName
index
)
=
>
(
{
propertyName
elapsedTime
:
elapsedTimes
[
index
]
}
)
)
;
const
sortByPropertyName
=
(
a
b
)
=
>
a
.
propertyName
.
localeCompare
(
b
.
propertyName
)
;
evts
.
sort
(
sortByPropertyName
)
;
testPairs
.
sort
(
sortByPropertyName
)
;
for
(
let
evt
of
evts
)
{
const
expected
=
testPairs
.
shift
(
)
;
assert_end_events_equal
(
evt
expected
.
propertyName
expected
.
elapsedTime
pseudoElement
)
;
}
}
root
.
addDiv
=
function
(
t
attrs
)
{
var
div
=
document
.
createElement
(
'
div
'
)
;
if
(
attrs
)
{
for
(
var
attrName
in
attrs
)
{
div
.
setAttribute
(
attrName
attrs
[
attrName
]
)
;
}
}
document
.
body
.
appendChild
(
div
)
;
if
(
t
&
&
typeof
t
.
add_cleanup
=
=
=
'
function
'
)
{
t
.
add_cleanup
(
function
(
)
{
if
(
div
.
parentNode
)
{
div
.
remove
(
)
;
}
}
)
;
}
return
div
;
}
;
root
.
addStyle
=
(
t
rules
)
=
>
{
const
extraStyle
=
document
.
createElement
(
'
style
'
)
;
document
.
head
.
appendChild
(
extraStyle
)
;
if
(
rules
)
{
const
sheet
=
extraStyle
.
sheet
;
for
(
const
selector
in
rules
)
{
sheet
.
insertRule
(
selector
+
'
{
'
+
rules
[
selector
]
+
'
}
'
sheet
.
cssRules
.
length
)
;
}
}
if
(
t
&
&
typeof
t
.
add_cleanup
=
=
=
'
function
'
)
{
t
.
add_cleanup
(
(
)
=
>
{
extraStyle
.
remove
(
)
;
}
)
;
}
return
extraStyle
;
}
;
root
.
waitForFrame
=
(
)
=
>
{
return
new
Promise
(
resolve
=
>
{
window
.
requestAnimationFrame
(
resolve
)
;
}
)
;
}
;
root
.
waitForAnimationFrames
=
(
frameCount
onFrame
)
=
>
{
const
timeAtStart
=
document
.
timeline
.
currentTime
;
return
new
Promise
(
resolve
=
>
{
function
handleFrame
(
)
{
if
(
onFrame
&
&
typeof
onFrame
=
=
=
'
function
'
)
{
onFrame
(
)
;
}
if
(
timeAtStart
!
=
document
.
timeline
.
currentTime
&
&
-
-
frameCount
<
=
0
)
{
resolve
(
)
;
}
else
{
window
.
requestAnimationFrame
(
handleFrame
)
;
}
}
window
.
requestAnimationFrame
(
handleFrame
)
;
}
)
;
}
;
root
.
waitForAllAnimations
=
animations
=
>
Promise
.
all
(
animations
.
map
(
animation
=
>
animation
.
ready
)
)
;
root
.
frameTimeout
=
(
promiseToWaitOn
framesToWait
message
)
=
>
{
let
framesRemaining
=
framesToWait
;
let
aborted
=
false
;
const
timeoutPromise
=
new
Promise
(
function
waitAFrame
(
resolve
reject
)
{
if
(
aborted
)
{
resolve
(
)
;
return
;
}
if
(
framesRemaining
-
-
>
0
)
{
requestAnimationFrame
(
(
)
=
>
{
waitAFrame
(
resolve
reject
)
;
}
)
;
return
;
}
let
errorMessage
=
'
Timed
out
waiting
for
Promise
to
resolve
'
;
if
(
message
)
{
errorMessage
+
=
:
{
message
}
;
}
reject
(
new
Error
(
errorMessage
)
)
;
}
)
;
const
wrappedPromiseToWaitOn
=
promiseToWaitOn
.
then
(
result
=
>
{
aborted
=
true
;
return
result
;
}
)
;
return
Promise
.
race
(
[
timeoutPromise
wrappedPromiseToWaitOn
]
)
;
}
;
root
.
supportsStartingStyle
=
(
)
=
>
{
let
sheet
=
new
CSSStyleSheet
(
)
;
sheet
.
replaceSync
(
"
starting
-
style
{
}
"
)
;
return
sheet
.
cssRules
.
length
=
=
1
;
}
;
}
)
(
window
)
;
