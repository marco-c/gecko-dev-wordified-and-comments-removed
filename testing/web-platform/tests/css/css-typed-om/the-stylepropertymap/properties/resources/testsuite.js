function
assert_is_unit
(
unit
result
)
{
assert_class_string
(
result
'
CSSUnitValue
'
'
relative
lengths
must
compute
to
a
CSSUnitValue
'
)
;
assert_equals
(
result
.
unit
unit
'
unit
'
)
;
}
function
assert_is_calc_sum
(
result
)
{
assert_class_string
(
result
'
CSSMathSum
'
'
specified
calc
must
be
a
CSSMathSum
'
)
;
}
const
gTestSyntaxExamples
=
{
'
<
length
>
'
:
{
description
:
'
a
length
'
examples
:
[
{
description
:
"
zero
px
"
input
:
new
CSSUnitValue
(
0
'
px
'
)
}
{
description
:
"
a
negative
em
"
input
:
new
CSSUnitValue
(
-
3
.
14
'
em
'
)
defaultComputed
:
result
=
>
assert_is_unit
(
'
px
'
result
)
}
{
description
:
"
a
positive
cm
"
input
:
new
CSSUnitValue
(
3
.
14
'
cm
'
)
defaultComputed
:
result
=
>
assert_is_unit
(
'
px
'
result
)
}
{
description
:
"
a
calc
length
"
input
:
new
CSSMathSum
(
new
CSSUnitValue
(
0
'
px
'
)
new
CSSUnitValue
(
0
'
em
'
)
)
defaultSpecified
:
assert_is_calc_sum
defaultComputed
:
result
=
>
assert_is_unit
(
'
px
'
result
)
}
]
}
'
<
percentage
>
'
:
{
description
:
'
a
percent
'
examples
:
[
{
description
:
"
zero
percent
"
input
:
new
CSSUnitValue
(
0
'
percent
'
)
}
{
description
:
"
a
negative
percent
"
input
:
new
CSSUnitValue
(
-
3
.
14
'
percent
'
)
}
{
description
:
"
a
positive
percent
"
input
:
new
CSSUnitValue
(
3
.
14
'
percent
'
)
}
{
description
:
"
a
calc
percent
"
input
:
new
CSSMathSum
(
new
CSSUnitValue
(
0
'
percent
'
)
new
CSSUnitValue
(
0
'
percent
'
)
)
defaultSpecified
:
assert_is_calc_sum
defaultComputed
:
result
=
>
assert_is_unit
(
'
percent
'
result
)
}
]
}
'
<
time
>
'
:
{
description
:
'
a
time
'
examples
:
[
{
description
:
"
zero
seconds
"
input
:
new
CSSUnitValue
(
0
'
s
'
)
}
{
description
:
"
negative
milliseconds
"
input
:
new
CSSUnitValue
(
-
3
.
14
'
ms
'
)
}
{
description
:
"
positive
seconds
"
input
:
new
CSSUnitValue
(
3
.
14
'
s
'
)
}
{
description
:
"
a
calc
time
"
input
:
new
CSSMathSum
(
new
CSSUnitValue
(
0
'
s
'
)
new
CSSUnitValue
(
0
'
ms
'
)
)
defaultSpecified
:
assert_is_calc_sum
defaultComputed
:
result
=
>
assert_is_unit
(
'
s
'
result
)
}
]
}
'
<
position
>
'
:
{
description
:
'
a
position
'
examples
:
[
{
decription
:
"
origin
position
"
input
:
new
CSSPositionValue
(
new
CSSUnitValue
(
0
'
px
'
)
new
CSSUnitValue
(
0
'
px
'
)
)
}
]
}
'
<
image
>
'
:
{
description
:
'
an
image
'
examples
:
[
{
description
:
"
a
PNG
image
"
input
:
new
CSSURLImageValue
(
'
/
media
/
1x1
.
png
'
)
defaultComputed
:
result
=
>
{
assert_true
(
result
instanceof
CSSURLImageValue
'
Computed
value
should
be
a
CSSURLImageValue
'
)
;
assert_true
(
result
.
url
.
endsWith
(
'
/
media
/
1x1
.
png
'
)
'
Computed
value
should
be
an
absolute
URL
'
)
;
}
}
]
}
'
<
transform
>
'
:
{
description
:
'
a
transform
'
examples
:
[
{
description
:
'
a
transform
containing
only
a
translate
'
input
:
new
CSSTransformValue
(
[
new
CSSTranslate
(
new
CSSUnitValue
(
0
'
px
'
)
new
CSSUnitValue
(
1
'
px
'
)
new
CSSUnitValue
(
2
'
px
'
)
)
]
)
}
]
}
}
;
function
testPropertyValid
(
propertyName
examples
specified
computed
description
)
{
test
(
t
=
>
{
let
element
=
createDivWithStyle
(
t
)
;
for
(
const
example
of
examples
)
{
element
.
attributeStyleMap
.
set
(
propertyName
example
.
input
)
;
const
specifiedResult
=
element
.
attributeStyleMap
.
get
(
propertyName
)
;
if
(
specified
|
|
example
.
defaultSpecified
)
{
(
specified
|
|
example
.
defaultSpecified
)
(
specifiedResult
)
;
}
else
{
assert_not_equals
(
specifiedResult
null
'
Specified
value
must
not
be
null
'
)
;
assert_true
(
specifiedResult
instanceof
CSSStyleValue
'
Specified
value
must
be
a
CSSStyleValue
'
)
;
assert_style_value_equals
(
specifiedResult
example
.
input
Setting
{
example
.
description
}
and
getting
its
specified
value
)
;
}
const
computedResult
=
element
.
computedStyleMap
(
)
.
get
(
propertyName
)
;
if
(
computed
|
|
example
.
defaultComputed
)
{
(
computed
|
|
example
.
defaultComputed
)
(
computedResult
)
;
}
else
{
assert_not_equals
(
computedResult
null
'
Computed
value
must
not
be
null
'
)
;
assert_true
(
computedResult
instanceof
CSSStyleValue
'
Computed
value
must
be
a
CSSStyleValue
'
)
;
assert_style_value_equals
(
computedResult
example
.
input
Setting
{
example
.
description
}
and
getting
its
computed
value
)
;
}
}
}
Can
set
'
{
propertyName
}
'
to
{
description
}
)
;
}
function
testPropertyInvalid
(
propertyName
examples
description
)
{
test
(
t
=
>
{
let
styleMap
=
createInlineStyleMap
(
t
)
;
for
(
const
example
of
examples
)
{
assert_throws
(
new
TypeError
(
)
(
)
=
>
styleMap
.
set
(
propertyName
example
.
input
)
)
;
}
}
Setting
'
{
propertyName
}
'
to
{
description
}
throws
TypeError
)
;
}
function
createKeywordExample
(
keyword
)
{
return
{
description
:
the
'
{
keyword
}
'
keyword
examples
:
[
{
input
:
new
CSSKeywordValue
(
keyword
)
}
]
}
;
}
function
runPropertyTests
(
propertyName
testCases
)
{
let
syntaxTested
=
new
Set
(
)
;
for
(
const
testCase
of
testCases
)
{
const
syntaxExamples
=
testCase
.
syntax
.
match
(
/
^
[
a
-
z
\
-
]
+
/
)
?
createKeywordExample
(
testCase
.
syntax
)
:
gTestSyntaxExamples
[
testCase
.
syntax
]
;
if
(
!
syntaxExamples
)
throw
new
Error
(
'
{
testCase
.
syntax
}
'
is
not
a
valid
CSS
component
)
;
testPropertyValid
(
propertyName
syntaxExamples
.
examples
testCase
.
specified
testCase
.
computed
syntaxExamples
.
description
)
;
syntaxTested
.
add
(
testCase
.
syntax
)
;
}
for
(
const
[
syntax
syntaxExamples
]
of
Object
.
entries
(
gTestSyntaxExamples
)
)
{
if
(
!
syntaxTested
.
has
(
syntax
)
)
{
testPropertyInvalid
(
propertyName
syntaxExamples
.
examples
syntaxExamples
.
description
)
;
}
}
}
