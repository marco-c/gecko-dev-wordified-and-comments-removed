const
gTestSyntaxExamples
=
{
'
<
length
>
'
:
{
description
:
'
a
length
'
examples
:
[
{
description
:
"
zero
px
"
input
:
new
CSSUnitValue
(
0
'
px
'
)
}
{
description
:
"
a
negative
em
"
input
:
new
CSSUnitValue
(
-
3
.
14
'
em
'
)
defaultComputed
:
value
=
>
{
assert_class_string
(
value
'
CSSUnitValue
'
'
"
em
"
lengths
must
compute
to
a
CSSUnitValue
'
)
;
assert_equals
(
value
.
unit
'
px
'
'
unit
'
)
;
}
}
{
description
:
"
a
positive
cm
"
input
:
new
CSSUnitValue
(
3
.
14
'
cm
'
)
defaultComputed
:
value
=
>
{
assert_class_string
(
value
'
CSSUnitValue
'
'
"
cm
"
lengths
must
compute
to
a
CSSUnitValue
'
)
;
assert_equals
(
value
.
unit
'
px
'
'
unit
'
)
;
}
}
]
}
'
<
percentage
>
'
:
{
description
:
'
a
percent
'
examples
:
[
{
description
:
"
zero
percent
"
input
:
new
CSSUnitValue
(
0
'
percent
'
)
}
{
description
:
"
a
negative
percent
"
input
:
new
CSSUnitValue
(
-
3
.
14
'
percent
'
)
}
{
description
:
"
a
positive
percent
"
input
:
new
CSSUnitValue
(
3
.
14
'
percent
'
)
}
]
}
'
<
time
>
'
:
{
description
:
'
a
time
'
examples
:
[
{
description
:
"
zero
seconds
"
input
:
new
CSSUnitValue
(
0
'
s
'
)
}
{
description
:
"
negative
milliseconds
"
input
:
new
CSSUnitValue
(
-
3
.
14
'
ms
'
)
}
{
description
:
"
positive
seconds
"
input
:
new
CSSUnitValue
(
3
.
14
'
s
'
)
}
]
}
}
;
function
testPropertyValid
(
propertyName
examples
specified
computed
description
)
{
test
(
t
=
>
{
let
element
=
createDivWithStyle
(
t
)
;
for
(
const
example
of
examples
)
{
element
.
attributeStyleMap
.
set
(
propertyName
example
.
input
)
;
const
specifiedResult
=
element
.
attributeStyleMap
.
get
(
propertyName
)
;
if
(
specified
|
|
example
.
defaultSpecified
)
{
(
specified
|
|
example
.
defaultSpecified
)
(
specifiedResult
)
;
}
else
{
assert_not_equals
(
specifiedResult
null
'
Specified
value
must
not
be
null
'
)
;
assert_true
(
specifiedResult
instanceof
CSSStyleValue
'
Specified
value
must
be
a
CSSStyleValue
'
)
;
assert_style_value_equals
(
specifiedResult
example
.
input
Setting
{
example
.
description
}
and
getting
its
specified
value
)
;
}
const
computedResult
=
element
.
computedStyleMap
(
)
.
get
(
propertyName
)
;
if
(
computed
|
|
example
.
defaultComputed
)
{
(
computed
|
|
example
.
defaultComputed
)
(
computedResult
)
;
}
else
{
assert_not_equals
(
computedResult
null
'
Computed
value
must
not
be
null
'
)
;
assert_true
(
computedResult
instanceof
CSSStyleValue
'
Computed
value
must
be
a
CSSStyleValue
'
)
;
assert_style_value_equals
(
computedResult
example
.
input
Setting
{
example
.
description
}
and
getting
its
computed
value
)
;
}
}
}
Can
set
'
{
propertyName
}
'
to
{
description
}
)
;
}
function
testPropertyInvalid
(
propertyName
examples
description
)
{
test
(
t
=
>
{
let
styleMap
=
createInlineStyleMap
(
t
)
;
for
(
const
example
of
examples
)
{
assert_throws
(
new
TypeError
(
)
(
)
=
>
styleMap
.
set
(
propertyName
example
.
input
)
)
;
}
}
Setting
'
{
propertyName
}
'
to
{
description
}
throws
TypeError
)
;
}
function
createKeywordExample
(
keyword
)
{
return
{
description
:
the
'
{
keyword
}
'
keyword
examples
:
[
{
input
:
new
CSSKeywordValue
(
keyword
)
}
]
}
;
}
function
runPropertyTests
(
propertyName
testCases
)
{
let
syntaxTested
=
new
Set
(
)
;
for
(
const
testCase
of
testCases
)
{
const
syntaxExamples
=
testCase
.
syntax
.
match
(
/
^
[
a
-
z
\
-
]
+
/
)
?
createKeywordExample
(
testCase
.
syntax
)
:
gTestSyntaxExamples
[
testCase
.
syntax
]
;
if
(
!
syntaxExamples
)
throw
new
Error
(
'
{
testCase
.
syntax
}
'
is
not
a
valid
CSS
component
)
;
testPropertyValid
(
propertyName
syntaxExamples
.
examples
testCase
.
specified
testCase
.
computed
syntaxExamples
.
description
)
;
syntaxTested
.
add
(
testCase
.
syntax
)
;
}
for
(
const
[
syntax
syntaxExamples
]
of
Object
.
entries
(
gTestSyntaxExamples
)
)
{
if
(
!
syntaxTested
.
has
(
syntax
)
)
{
testPropertyInvalid
(
propertyName
syntaxExamples
.
examples
syntaxExamples
.
description
)
;
}
}
}
