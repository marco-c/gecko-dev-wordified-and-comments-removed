'
use
strict
'
;
function
set_up_fuzzy_color_test
(
epsilon
)
{
if
(
!
epsilon
)
{
epsilon
=
0
.
01
;
}
function
fuzzy_compare_colors
(
input
expected
)
{
const
colorElementDividers
=
/
(
|
\
(
|
)
/
;
function
getNonNumbers
(
color
)
{
return
color
.
replace
(
/
[
0
-
9
\
.
]
/
g
'
'
)
;
}
function
getNumbers
(
color
)
{
const
result
=
[
]
;
color
.
split
(
colorElementDividers
)
.
forEach
(
element
=
>
{
const
numberElement
=
parseFloat
(
element
)
;
if
(
!
isNaN
(
numberElement
)
)
{
result
.
push
(
numberElement
)
;
}
}
)
;
return
result
;
}
try
{
assert_array_approx_equals
(
getNumbers
(
input
)
getNumbers
(
expected
)
epsilon
"
Numeric
parameters
are
approximately
equal
.
"
)
;
assert_equals
(
getNonNumbers
(
input
)
getNonNumbers
(
expected
)
"
Color
format
is
correct
.
"
)
;
}
catch
(
error
)
{
throw
Colors
do
not
match
.
\
nActual
:
{
input
}
\
nExpected
:
{
expected
}
.
\
n
{
error
}
}
}
return
fuzzy_compare_colors
;
}
function
fuzzy_test_computed_color
(
specified
computed
epsilon
)
{
if
(
!
computed
)
{
test_computed_value
(
"
color
"
specified
)
;
return
;
}
test_computed_value
(
"
color
"
specified
computed
undefined
{
comparisonFunction
:
set_up_fuzzy_color_test
(
epsilon
)
}
)
;
}
function
fuzzy_test_computed_color_property
(
property
specified
computed
epsilon
)
{
if
(
!
computed
)
{
test_computed_value
(
property
specified
)
;
return
;
}
test_computed_value
(
property
specified
computed
undefined
{
comparisonFunction
:
set_up_fuzzy_color_test
(
epsilon
)
}
)
;
}
function
fuzzy_test_valid_color
(
specified
parsed
epsilon
)
{
if
(
!
parsed
)
{
test_valid_value
(
"
color
"
specified
)
;
return
;
}
test_valid_value
(
"
color
"
specified
parsed
{
comparisonFunction
:
set_up_fuzzy_color_test
(
epsilon
)
}
)
;
}
function
fuzzy_test_valid_color_property
(
property
specified
parsed
epsilon
)
{
if
(
!
parsed
)
{
test_valid_value
(
property
specified
)
;
return
;
}
test_valid_value
(
property
specified
parsed
{
comparisonFunction
:
set_up_fuzzy_color_test
(
epsilon
)
}
)
;
}
function
assert_oklab_color
(
actual
expected
message
)
{
const
paramMatch
=
'
(
\
\
-
?
\
\
d
*
\
\
.
?
\
\
d
*
)
'
;
const
optAlphaMatch
=
'
(
\
\
/
(
\
\
d
*
\
\
.
?
\
\
d
*
)
)
?
'
;
const
pattern
=
oklab
\
\
(
{
paramMatch
}
{
paramMatch
}
{
paramMatch
}
{
optAlphaMatch
}
\
\
)
;
const
oklabRegex
=
new
RegExp
(
pattern
)
;
let
matches
=
expected
.
match
(
oklabRegex
)
;
assert_true
(
!
!
matches
Expected
value
{
expected
}
not
recognized
as
an
oklab
color
)
;
const
p0
=
parseFloat
(
matches
[
1
]
)
;
const
p1
=
parseFloat
(
matches
[
2
]
)
;
const
p2
=
parseFloat
(
matches
[
3
]
)
;
const
alpha
=
(
matches
[
5
]
!
=
=
undefined
)
?
parseFloat
(
matches
[
5
]
)
:
undefined
;
matches
=
actual
.
match
(
oklabRegex
)
;
assert_true
(
!
!
matches
Actual
value
{
actual
}
not
recognized
as
an
oklab
color
)
;
const
tolerance
=
0
.
01
;
let
colorMatch
=
Math
.
abs
(
parseFloat
(
matches
[
1
]
)
-
p0
)
<
=
tolerance
&
&
Math
.
abs
(
parseFloat
(
matches
[
2
]
)
-
p1
)
<
=
tolerance
&
&
Math
.
abs
(
parseFloat
(
matches
[
3
]
)
-
p2
)
<
=
tolerance
;
if
(
colorMatch
)
{
if
(
alpha
!
=
=
undefined
)
{
colorMatch
=
matches
[
5
]
!
=
undefined
&
&
Math
.
abs
(
parseFloat
(
matches
[
5
]
)
-
alpha
)
<
=
tolerance
;
}
else
{
colorMatch
=
matches
[
5
]
=
=
undefined
;
}
}
assert_true
(
colorMatch
expected
:
{
expected
}
actual
{
actual
}
-
-
{
message
}
)
;
}
