'
use
strict
'
;
function
test_math_used
(
testString
expectedString
{
approx
msg
msgExtra
type
prop
prefix
suffix
extraStyle
=
{
}
}
=
{
}
)
{
if
(
type
=
=
=
undefined
)
type
=
"
length
"
;
if
(
!
prop
)
{
switch
(
type
)
{
case
"
number
"
:
prop
=
"
transform
"
;
prefix
=
"
scale
(
"
;
suffix
=
"
)
"
;
break
;
case
"
integer
"
:
prop
=
"
z
-
index
"
;
extraStyle
.
position
=
"
absolute
"
;
break
;
case
"
length
"
:
prop
=
"
margin
-
left
"
;
break
;
case
"
angle
"
:
prop
=
"
transform
"
;
prefix
=
"
rotate
(
"
;
suffix
=
"
)
"
;
break
;
case
"
time
"
:
prop
=
"
transition
-
delay
"
;
break
;
case
"
resolution
"
:
prop
=
"
image
-
resolution
"
;
break
;
case
"
flex
"
:
prop
=
"
grid
-
template
-
rows
"
;
break
;
default
:
throw
Exception
(
Value
type
'
{
type
}
'
isn
'
t
capable
of
math
.
)
;
}
}
_test_math
(
{
stage
:
'
used
'
testString
expectedString
type
approx
msg
msgExtra
prop
prefix
suffix
extraStyle
}
)
;
}
function
test_math_computed
(
testString
expectedString
{
approx
msg
msgExtra
type
prop
prefix
suffix
extraStyle
=
{
}
}
=
{
}
)
{
if
(
type
=
=
=
undefined
)
type
=
"
length
"
;
if
(
!
prop
)
{
switch
(
type
)
{
case
"
number
"
:
prop
=
"
transform
"
;
prefix
=
"
scale
(
"
;
suffix
=
"
)
"
;
break
;
case
"
integer
"
:
prop
=
"
z
-
index
"
;
extraStyle
.
position
=
"
absolute
"
;
break
;
case
"
length
"
:
prop
=
"
flex
-
basis
"
;
break
;
case
"
angle
"
:
prop
=
"
transform
"
;
prefix
=
"
rotate
(
"
;
suffix
=
"
)
"
;
break
;
case
"
time
"
:
prop
=
"
transition
-
delay
"
;
break
;
case
"
resolution
"
:
prop
=
"
image
-
resolution
"
;
break
;
case
"
flex
"
:
prop
=
"
grid
-
template
-
rows
"
;
break
;
default
:
throw
Exception
(
Value
type
'
{
type
}
'
isn
'
t
capable
of
math
.
)
;
}
}
_test_math
(
{
stage
:
'
computed
'
testString
expectedString
type
approx
msg
msgExtra
prop
prefix
suffix
extraStyle
}
)
;
}
function
test_math_specified
(
testString
expectedString
{
approx
msg
msgExtra
type
prop
prefix
suffix
extraStyle
=
{
}
}
=
{
}
)
{
if
(
type
=
=
=
undefined
)
type
=
"
length
"
;
const
stage
=
"
specified
"
;
if
(
!
prop
)
{
switch
(
type
)
{
case
"
number
"
:
prop
=
"
transform
"
;
prefix
=
"
scale
(
"
;
suffix
=
"
)
"
;
break
;
case
"
integer
"
:
prop
=
"
z
-
index
"
;
extraStyle
.
position
=
"
absolute
"
;
break
;
case
"
length
"
:
prop
=
"
flex
-
basis
"
;
break
;
case
"
angle
"
:
prop
=
"
transform
"
;
prefix
=
"
rotate
(
"
;
suffix
=
"
)
"
;
break
;
case
"
time
"
:
prop
=
"
transition
-
delay
"
;
break
;
case
"
resolution
"
:
prop
=
"
image
-
resolution
"
;
break
;
case
"
flex
"
:
prop
=
"
grid
-
template
-
rows
"
;
break
;
default
:
throw
Exception
(
Value
type
'
{
type
}
'
isn
'
t
capable
of
math
.
)
;
}
}
const
testEl
=
document
.
getElementById
(
'
target
'
)
;
if
(
testEl
=
=
null
)
throw
"
Couldn
'
t
find
#
target
element
to
run
tests
on
.
"
;
testEl
.
style
=
"
"
;
for
(
const
p
in
extraStyle
)
{
testEl
.
style
[
p
]
=
extraStyle
[
p
]
;
}
if
(
!
msg
)
{
msg
=
{
testString
}
should
be
{
stage
}
-
value
-
equivalent
to
{
expectedString
}
;
if
(
msgExtra
)
msg
+
=
"
;
"
+
msgExtra
;
}
let
t
=
testString
;
let
e
=
expectedString
;
if
(
prefix
)
{
t
=
prefix
+
t
;
e
=
prefix
+
e
;
}
if
(
suffix
)
{
t
+
=
suffix
;
e
+
=
suffix
;
}
test
(
(
)
=
>
{
testEl
.
style
[
prop
]
=
'
'
;
testEl
.
style
[
prop
]
=
t
;
const
usedValue
=
testEl
.
style
[
prop
]
;
assert_not_equals
(
usedValue
'
'
{
testString
}
isn
'
t
valid
in
'
{
prop
}
'
;
got
the
default
value
instead
.
)
;
testEl
.
style
[
prop
]
=
'
'
;
testEl
.
style
[
prop
]
=
e
;
const
expectedValue
=
testEl
.
style
[
prop
]
;
assert_not_equals
(
expectedValue
'
'
{
expectedString
}
isn
'
t
valid
in
'
{
prop
}
'
;
got
the
default
value
instead
.
)
assert_equals
(
usedValue
expectedValue
{
testString
}
and
{
expectedString
}
serialize
to
the
same
thing
in
{
stage
}
values
.
)
;
}
msg
)
;
}
function
test_plus_infinity
(
testString
)
{
test_math_used
(
testString
"
calc
(
infinity
)
"
{
type
:
"
number
"
}
)
;
}
function
test_minus_infinity
(
testString
)
{
test_math_used
(
testString
"
calc
(
-
infinity
)
"
{
type
:
"
number
"
}
)
;
}
function
test_plus_zero
(
testString
)
{
test_math_used
(
calc
(
1
/
{
testString
}
)
"
calc
(
infinity
)
"
{
type
:
"
number
"
}
)
;
}
function
test_minus_zero
(
testString
)
{
test_math_used
(
calc
(
1
/
{
testString
}
)
"
calc
(
-
infinity
)
"
{
type
:
"
number
"
}
)
;
}
function
test_nan
(
testString
)
{
test_math_used
(
testString
"
calc
(
NaN
)
"
{
type
:
"
number
"
}
)
;
test_math_used
(
calc
(
-
1
*
{
testString
}
)
"
calc
(
NaN
)
"
{
type
:
"
number
"
}
)
;
}
function
_test_math
(
{
stage
testEl
testString
expectedString
type
approx
msg
msgExtra
prop
prefix
suffix
extraStyle
}
=
{
}
)
{
if
(
!
testEl
)
testEl
=
document
.
getElementById
(
'
target
'
)
;
if
(
testEl
=
=
null
)
throw
"
Couldn
'
t
find
#
target
element
to
run
tests
on
.
"
;
testEl
.
style
=
"
"
;
for
(
const
p
in
extraStyle
)
{
testEl
.
style
[
p
]
=
extraStyle
[
p
]
;
}
if
(
!
msg
)
{
msg
=
{
testString
}
should
be
{
stage
}
-
value
-
equivalent
to
{
expectedString
}
;
if
(
msgExtra
)
msg
+
=
"
;
"
+
msgExtra
;
}
let
t
=
testString
;
let
e
=
expectedString
;
if
(
prefix
)
{
t
=
prefix
+
t
;
e
=
prefix
+
e
;
}
if
(
suffix
)
{
t
+
=
suffix
;
e
+
=
suffix
;
}
test
(
(
)
=
>
{
testEl
.
style
[
prop
]
=
'
'
;
const
defaultValue
=
getComputedStyle
(
testEl
)
[
prop
]
;
testEl
.
style
[
prop
]
=
t
;
const
usedValue
=
getComputedStyle
(
testEl
)
[
prop
]
;
assert_not_equals
(
usedValue
defaultValue
{
testString
}
isn
'
t
valid
in
'
{
prop
}
'
;
got
the
default
value
instead
.
)
;
testEl
.
style
[
prop
]
=
'
'
;
testEl
.
style
[
prop
]
=
e
;
const
expectedValue
=
getComputedStyle
(
testEl
)
[
prop
]
;
assert_not_equals
(
expectedValue
defaultValue
{
expectedString
}
isn
'
t
valid
in
'
{
prop
}
'
;
got
the
default
value
instead
.
)
if
(
approx
&
&
(
type
=
=
"
number
"
|
|
type
=
=
"
angle
"
)
)
{
let
parsedUsed
=
usedValue
.
split
(
'
(
'
)
[
1
]
.
split
(
'
)
'
)
[
0
]
.
split
(
'
'
)
.
map
(
parseFloat
)
;
let
parsedExpected
=
expectedValue
.
split
(
'
(
'
)
[
1
]
.
split
(
'
)
'
)
[
0
]
.
split
(
'
'
)
.
map
(
parseFloat
)
;
assert_array_approx_equals
(
parsedUsed
parsedExpected
approx
{
testString
}
and
{
expectedString
}
{
approx
}
serialize
to
the
same
thing
in
{
stage
}
values
.
)
;
}
else
{
assert_equals
(
usedValue
expectedValue
{
testString
}
and
{
expectedString
}
serialize
to
the
same
thing
in
{
stage
}
values
.
)
;
}
}
msg
)
;
}
