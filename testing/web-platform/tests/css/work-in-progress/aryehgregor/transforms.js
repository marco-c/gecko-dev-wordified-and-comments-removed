"
use
strict
"
;
var
div
=
document
.
querySelector
(
"
#
test
"
)
;
var
divWidth
=
100
divHeight
=
50
;
var
divParentWidth
=
120
divParentHeight
=
70
;
var
pixelEpsilon
=
1
.
5
;
var
computedEpsilon
=
0
.
05
;
var
percentagesAndLengths
=
[
"
.
0
"
"
-
1px
"
"
1pt
"
"
53
.
7px
"
"
-
50
%
"
"
1em
"
"
1px
"
"
0
.
12
%
"
"
0
.
12px
"
"
0
%
"
"
-
53
.
7px
"
"
0
.
0px
"
"
1ex
"
"
1in
"
"
1cm
"
"
1mm
"
"
1pc
"
]
;
var
lengths
=
percentagesAndLengths
.
filter
(
function
(
s
)
{
return
!
/
%
/
.
test
(
s
)
}
)
;
var
rotateAngles
=
[
"
-
7deg
"
"
0
"
"
0deg
"
"
22
.
5deg
"
"
45deg
"
"
86
.
451deg
"
"
90deg
"
"
180deg
"
"
270deg
"
"
452deg
"
"
-
1rad
"
"
0rad
"
"
1rad
"
"
6
.
28rad
"
"
0
.
721turn
"
"
256grad
"
]
;
var
skewAngles
=
[
"
-
80deg
"
"
0
"
"
-
45deg
"
"
-
32
.
6deg
"
"
-
0
.
05deg
"
"
0deg
"
"
0
.
05deg
"
"
32
.
6deg
"
"
45deg
"
"
80deg
"
"
300deg
"
"
-
0
.
3rad
"
"
0rad
"
"
0
.
3rad
"
"
2
.
9rad
"
"
0
.
921turn
"
"
22grad
"
]
;
var
emPixels
=
parseFloat
(
getComputedStyle
(
div
)
.
fontSize
)
;
div
.
style
.
fontSize
=
"
1ex
"
;
var
exPixels
=
parseFloat
(
getComputedStyle
(
div
)
.
fontSize
)
;
div
.
removeAttribute
(
"
style
"
)
;
var
switchStyles
=
document
.
querySelectorAll
(
"
style
.
switch
"
)
;
[
]
.
forEach
.
call
(
switchStyles
function
(
style
)
{
style
.
disabled
=
true
}
)
;
var
section
;
var
sectionCounts
=
{
}
;
add_result_callback
(
function
(
)
{
if
(
!
(
section
in
sectionCounts
)
)
{
sectionCounts
[
section
]
=
0
;
}
sectionCounts
[
section
]
+
+
;
}
)
;
add_completion_callback
(
function
(
)
{
var
msg
=
"
Tests
:
"
;
var
total
=
0
;
for
(
var
key
in
sectionCounts
)
{
msg
+
=
key
+
"
"
+
sectionCounts
[
key
]
+
"
"
;
total
+
=
sectionCounts
[
key
]
;
}
msg
+
=
"
total
"
+
total
;
document
.
body
.
appendChild
(
document
.
createTextNode
(
msg
)
)
;
}
)
;
function
prefixProp
(
s
)
{
if
(
s
in
div
.
style
)
{
return
s
;
}
s
=
s
[
0
]
.
toUpperCase
(
)
+
s
.
slice
(
1
)
;
var
prefixes
=
[
"
ms
"
"
Moz
"
"
moz
"
"
webkit
"
"
O
"
]
;
for
(
var
i
=
0
;
i
<
prefixes
.
length
;
i
+
+
)
{
if
(
(
prefixes
[
i
]
+
s
)
in
div
.
style
)
{
return
prefixes
[
i
]
+
s
;
}
}
return
s
;
}
function
prefixHyphenatedProp
(
s
)
{
s
=
s
.
split
(
"
-
"
)
.
map
(
function
(
bit
i
)
{
return
i
=
=
0
?
bit
:
bit
[
0
]
.
toUpperCase
(
)
+
bit
.
slice
(
1
)
}
)
.
join
(
"
"
)
;
var
prefixed
=
prefixProp
(
s
)
;
if
(
prefixed
!
=
s
)
{
s
=
prefixed
[
0
]
.
toUpperCase
(
)
+
prefixed
.
slice
(
1
)
;
}
return
s
.
replace
(
/
(
[
A
-
Z
]
)
/
g
"
-
1
"
)
.
toLowerCase
(
)
;
}
function
convertToPx
(
input
percentRef
)
{
var
match
=
/
^
(
[
-
+
]
?
[
0
-
9
]
+
|
[
-
+
]
?
[
0
-
9
]
*
\
.
[
0
-
9
]
+
)
(
em
|
ex
|
in
|
cm
|
mm
|
pt
|
pc
|
px
|
%
)
?
/
.
exec
(
input
)
;
if
(
!
match
)
{
return
null
;
}
var
amount
=
Number
(
match
[
1
]
)
;
var
unit
=
match
[
2
]
;
if
(
amount
=
=
0
)
{
return
0
;
}
if
(
!
unit
)
{
return
null
;
}
if
(
unit
=
=
"
%
"
&
&
percentRef
=
=
=
undefined
)
{
return
null
;
}
return
amount
*
{
em
:
emPixels
ex
:
exPixels
in
:
72
/
0
.
75
cm
:
(
1
/
2
.
54
)
*
72
/
0
.
75
mm
:
(
1
/
25
.
4
)
*
72
/
0
.
75
pt
:
1
/
0
.
75
pc
:
12
/
0
.
75
px
:
1
"
%
"
:
percentRef
/
100
}
[
unit
]
;
}
function
convertToRad
(
input
)
{
var
match
=
/
^
(
[
-
+
]
?
[
0
-
9
]
+
|
[
-
+
]
?
[
0
-
9
]
*
\
.
[
0
-
9
]
+
)
(
deg
|
grad
|
rad
|
turn
|
)
/
.
exec
(
input
)
;
if
(
!
match
)
{
return
null
;
}
var
amount
=
Number
(
match
[
1
]
)
;
var
unit
=
match
[
2
]
;
if
(
unit
=
=
"
"
&
&
amount
=
=
0
)
{
return
0
;
}
if
(
unit
=
=
"
"
)
{
return
null
;
}
return
amount
*
{
deg
:
Math
.
PI
/
180
grad
:
Math
.
PI
/
200
rad
:
1
turn
:
2
*
Math
.
PI
}
[
unit
]
;
}
function
mxmul23
(
A
B
)
{
if
(
arguments
.
length
>
2
)
{
return
mxmul23
(
A
mxmul23
.
apply
(
this
[
]
.
slice
.
call
(
arguments
1
)
)
)
;
}
return
[
A
[
0
]
*
B
[
0
]
+
A
[
2
]
*
B
[
1
]
A
[
1
]
*
B
[
0
]
+
A
[
3
]
*
B
[
1
]
A
[
0
]
*
B
[
2
]
+
A
[
2
]
*
B
[
3
]
A
[
1
]
*
B
[
2
]
+
A
[
3
]
*
B
[
3
]
A
[
0
]
*
B
[
4
]
+
A
[
2
]
*
B
[
5
]
+
A
[
4
]
A
[
1
]
*
B
[
4
]
+
A
[
3
]
*
B
[
5
]
+
A
[
5
]
]
;
}
function
mxmul44
(
A
B
)
{
if
(
arguments
.
length
>
2
)
{
return
mxmul44
(
A
mxmul44
.
apply
(
this
[
]
.
slice
.
call
(
arguments
1
)
)
)
;
}
A
=
[
A
.
slice
(
0
4
)
A
.
slice
(
4
8
)
A
.
slice
(
8
12
)
A
.
slice
(
12
16
)
]
;
B
=
[
B
.
slice
(
0
4
)
B
.
slice
(
4
8
)
B
.
slice
(
8
12
)
B
.
slice
(
12
16
)
]
;
var
C
=
[
]
;
for
(
var
i
=
0
;
i
<
4
;
i
+
+
)
{
C
.
push
(
[
]
)
;
for
(
var
j
=
0
;
j
<
4
;
j
+
+
)
{
C
[
i
]
.
push
(
0
)
;
for
(
var
k
=
0
;
k
<
4
;
k
+
+
)
{
C
[
i
]
[
j
]
+
=
B
[
i
]
[
k
]
*
A
[
k
]
[
j
]
;
}
}
}
return
C
[
0
]
.
concat
(
C
[
1
]
)
.
concat
(
C
[
2
]
)
.
concat
(
C
[
3
]
)
;
}
function
is2dMatrix
(
mx
)
{
var
e
=
1
.
0e
-
5
;
return
Math
.
abs
(
mx
[
2
]
)
<
e
&
&
Math
.
abs
(
mx
[
3
]
)
<
e
&
&
Math
.
abs
(
mx
[
6
]
)
<
e
&
&
Math
.
abs
(
mx
[
7
]
)
<
e
&
&
Math
.
abs
(
mx
[
8
]
)
<
e
&
&
Math
.
abs
(
mx
[
9
]
)
<
e
&
&
Math
.
abs
(
mx
[
10
]
-
1
)
<
e
&
&
Math
.
abs
(
mx
[
11
]
)
<
e
&
&
Math
.
abs
(
mx
[
14
]
)
<
e
&
&
Math
.
abs
(
mx
[
15
]
-
1
)
<
e
;
}
function
getRotationMatrix
(
x
y
z
angle
)
{
var
rads
=
convertToRad
(
angle
)
;
var
len
=
Math
.
sqrt
(
x
*
x
+
y
*
y
+
z
*
z
)
;
x
/
=
len
;
y
/
=
len
;
z
/
=
len
;
var
sc
=
Math
.
sin
(
rads
/
2
)
*
Math
.
cos
(
rads
/
2
)
;
var
sq
=
Math
.
sin
(
rads
/
2
)
*
Math
.
sin
(
rads
/
2
)
;
var
ret
=
[
1
-
2
*
(
y
*
y
+
z
*
z
)
*
sq
2
*
(
x
*
y
*
sq
+
z
*
sc
)
2
*
(
x
*
z
*
sq
-
y
*
sc
)
0
2
*
(
x
*
y
*
sq
-
z
*
sc
)
1
-
2
*
(
x
*
x
+
z
*
z
)
*
sq
2
*
(
y
*
z
*
sq
+
x
*
sc
)
0
2
*
(
x
*
z
*
sq
+
y
*
sc
)
2
*
(
y
*
z
*
sq
-
x
*
sc
)
1
-
2
*
(
x
*
x
+
y
*
y
)
*
sq
0
0
0
0
1
]
;
return
ret
;
}
function
setStyles
(
divStyle
parentStyle
grandparentStyle
bodyStyle
)
{
if
(
(
setStyles
.
currentStyles
[
0
]
&
&
divStyle
&
&
Object
.
keys
(
divStyle
)
.
length
)
|
|
(
setStyles
.
currentStyles
[
1
]
&
&
parentStyle
&
&
Object
.
keys
(
parentStyle
)
.
length
)
|
|
(
setStyles
.
currentStyles
[
2
]
&
&
grandparentStyle
&
&
Object
.
keys
(
grandparentStyle
)
.
length
)
|
|
(
setStyles
.
currentStyles
[
3
]
&
&
bodyStyle
&
&
Object
.
keys
(
bodyStyle
)
.
length
)
)
{
setStyles
.
useCssomCounter
+
+
;
setStyles
.
useCssomCounter
%
=
17
;
setStyles
.
useCssom
=
Boolean
(
setStyles
.
useCssomCounter
%
2
)
;
}
if
(
divStyle
)
{
setStyles
.
currentStyles
[
0
]
=
setStyle
(
div
divStyle
)
;
}
if
(
parentStyle
)
{
setStyles
.
currentStyles
[
1
]
=
setStyle
(
div
.
parentNode
parentStyle
)
;
}
if
(
grandparentStyle
)
{
setStyles
.
currentStyles
[
2
]
=
setStyle
(
div
.
parentNode
.
parentNode
grandparentStyle
)
;
}
if
(
bodyStyle
)
{
setStyles
.
currentStyles
[
3
]
=
setStyle
(
document
.
body
bodyStyle
)
;
}
}
setStyles
.
currentStyles
=
[
"
"
"
"
"
"
"
"
]
;
setStyles
.
useCssomCounter
=
0
;
setStyles
.
useCssom
=
false
;
function
setStyle
(
node
style
)
{
node
.
setAttribute
(
"
style
"
"
"
)
;
node
.
removeAttribute
(
"
style
"
)
;
var
ret
=
[
]
;
var
textToSet
=
[
]
;
for
(
var
prop
in
style
)
{
if
(
style
[
prop
]
=
=
"
"
)
{
continue
;
}
var
hyphenatedProp
=
prop
.
replace
(
/
(
[
A
-
Z
]
)
/
g
"
-
1
"
)
.
toLowerCase
(
)
;
ret
.
push
(
hyphenatedProp
+
"
:
"
+
style
[
prop
]
)
;
if
(
setStyles
.
useCssom
)
{
node
.
style
[
prefixProp
(
prop
)
]
=
style
[
prop
]
;
}
else
{
textToSet
.
push
(
prefixHyphenatedProp
(
hyphenatedProp
)
+
"
:
"
+
style
[
prop
]
)
;
}
}
if
(
!
setStyles
.
useCssom
)
{
node
.
setAttribute
(
"
style
"
textToSet
.
join
(
"
;
"
)
)
;
}
return
ret
.
join
(
"
;
"
)
;
}
function
getStyleDescription
(
)
{
var
styleText
=
[
]
;
if
(
setStyles
.
currentStyles
[
3
]
)
{
styleText
.
push
(
'
"
'
+
setStyles
.
currentStyles
[
3
]
+
'
"
'
+
"
on
body
"
)
;
}
if
(
setStyles
.
currentStyles
[
2
]
)
{
styleText
.
push
(
'
"
'
+
setStyles
.
currentStyles
[
2
]
+
'
"
'
+
"
on
test
div
'
s
grandparent
"
)
;
}
if
(
setStyles
.
currentStyles
[
1
]
)
{
styleText
.
push
(
'
"
'
+
setStyles
.
currentStyles
[
1
]
+
'
"
'
+
"
on
test
div
'
s
parent
"
)
;
}
if
(
setStyles
.
currentStyles
[
0
]
)
{
styleText
.
push
(
'
"
'
+
setStyles
.
currentStyles
[
0
]
+
'
"
'
+
(
styleText
.
length
?
"
on
test
div
"
:
"
"
)
)
;
}
if
(
styleText
.
length
)
{
return
"
with
"
+
styleText
.
join
(
"
"
)
+
"
set
via
"
+
(
setStyles
.
useCssom
?
"
CSSOM
"
:
"
setAttribute
(
)
"
)
;
}
return
"
with
no
attributes
set
"
;
}
function
testTransform
(
value
mx
)
{
setStyles
(
{
transform
:
value
}
)
;
test
(
function
(
)
{
testComputedTransform
(
mx
)
;
}
"
getComputedStyle
(
div
)
.
transform
"
+
getStyleDescription
(
)
)
;
testTransformedBoundary
(
value
mx
)
;
}
function
testComputedTransform
(
mx
)
{
if
(
mx
.
length
=
=
0
)
{
assert_equals
(
getComputedStyle
(
div
)
[
prefixProp
(
"
transform
"
)
]
"
none
"
"
wrong
computed
value
"
)
;
return
;
}
if
(
mx
.
length
=
=
6
)
{
mx
=
[
mx
[
0
]
mx
[
1
]
0
0
mx
[
2
]
mx
[
3
]
0
0
0
0
1
0
mx
[
4
]
mx
[
5
]
0
1
]
;
}
var
computed
=
getComputedStyle
(
div
)
[
prefixProp
(
"
transform
"
)
]
;
if
(
is2dMatrix
(
mx
)
)
{
var
re
=
/
^
matrix
\
(
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
\
)
/
;
assert_regexp_match
(
computed
re
"
computed
value
has
unexpected
form
for
2D
matrix
"
)
;
var
msg
=
'
(
actual
:
"
'
+
computed
+
'
"
;
'
+
'
expected
:
"
matrix
(
'
+
[
mx
[
0
]
mx
[
1
]
mx
[
4
]
mx
[
5
]
mx
[
12
]
mx
[
13
]
]
.
join
(
'
'
)
+
'
)
"
)
'
;
var
match
=
re
.
exec
(
computed
)
;
assert_approx_equals
(
Number
(
match
[
1
]
)
mx
[
0
]
computedEpsilon
"
getComputedStyle
matrix
component
0
"
+
msg
)
;
assert_approx_equals
(
Number
(
match
[
2
]
)
mx
[
1
]
computedEpsilon
"
getComputedStyle
matrix
component
1
"
+
msg
)
;
assert_approx_equals
(
Number
(
match
[
3
]
)
mx
[
4
]
computedEpsilon
"
getComputedStyle
matrix
component
2
"
+
msg
)
;
assert_approx_equals
(
Number
(
match
[
4
]
)
mx
[
5
]
computedEpsilon
"
getComputedStyle
matrix
component
3
"
+
msg
)
;
assert_approx_equals
(
Number
(
match
[
5
]
)
mx
[
12
]
computedEpsilon
"
getComputedStyle
matrix
component
4
"
+
msg
)
;
assert_approx_equals
(
Number
(
match
[
6
]
)
mx
[
13
]
computedEpsilon
"
getComputedStyle
matrix
component
5
"
+
msg
)
;
return
;
}
var
re
=
/
^
matrix3d
\
(
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
)
(
[
^
]
+
?
)
\
)
/
;
assert_regexp_match
(
computed
re
"
computed
value
has
unexpected
form
for
3D
matrix
"
)
;
var
msg
=
'
(
actual
:
"
'
+
computed
+
'
"
;
'
+
'
expected
:
"
matrix3d
(
'
+
mx
.
join
(
'
'
)
+
'
)
"
)
'
;
var
match
=
re
.
exec
(
computed
)
;
for
(
var
i
=
0
;
i
<
16
;
i
+
+
)
{
assert_approx_equals
(
Number
(
match
[
i
+
1
]
)
mx
[
i
]
computedEpsilon
"
getComputedStyle
matrix
component
"
+
i
+
msg
)
;
}
}
function
testInlineTransform
(
expectedValue
)
{
assert_equals
(
div
.
style
[
prefixProp
(
"
transform
"
)
]
expectedValue
"
div
.
style
.
transform
"
)
;
if
(
expectedValue
=
=
"
"
)
{
assert_equals
(
div
.
style
.
cssText
"
"
"
div
.
style
.
cssText
"
)
;
}
else
{
assert_equals
(
div
.
style
.
cssText
.
replace
(
/
;
?
?
/
"
"
)
prefixHyphenatedProp
(
"
transform
"
)
+
"
:
"
+
expectedValue
"
div
.
style
.
cssText
"
)
;
}
}
function
testTransformedBoundary
(
transformValue
mx
transformOriginValue
xOffset
yOffset
zOffset
)
{
if
(
mx
.
length
=
=
0
)
{
mx
=
[
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
]
;
}
if
(
mx
.
length
=
=
6
)
{
mx
=
[
mx
[
0
]
mx
[
1
]
0
0
mx
[
2
]
mx
[
3
]
0
0
0
0
1
0
mx
[
4
]
mx
[
5
]
0
1
]
;
}
if
(
is2dMatrix
(
mx
)
&
&
mx
[
0
]
*
mx
[
5
]
-
mx
[
1
]
*
mx
[
4
]
=
=
=
0
)
{
return
;
}
if
(
transformOriginValue
=
=
=
undefined
)
{
transformOriginValue
=
"
"
;
}
if
(
xOffset
=
=
=
undefined
)
{
xOffset
=
divWidth
/
2
;
}
if
(
yOffset
=
=
=
undefined
)
{
yOffset
=
divHeight
/
2
;
}
if
(
zOffset
=
=
=
undefined
)
{
zOffset
=
0
;
}
var
originalPoints
=
[
[
0
0
]
[
0
divHeight
]
[
divWidth
0
]
[
divWidth
divHeight
]
]
;
var
newPoints
=
[
]
;
for
(
var
i
=
0
;
i
<
originalPoints
.
length
;
i
+
+
)
{
var
x
=
originalPoints
[
i
]
[
0
]
-
xOffset
;
var
y
=
originalPoints
[
i
]
[
1
]
-
yOffset
;
var
z
=
-
zOffset
;
var
newW
=
mx
[
3
]
*
x
+
mx
[
7
]
*
y
+
mx
[
11
]
*
z
+
mx
[
15
]
;
if
(
newW
<
=
0
)
{
return
;
}
var
newX
=
(
mx
[
0
]
*
x
+
mx
[
4
]
*
y
+
mx
[
8
]
*
z
+
mx
[
12
]
)
/
newW
+
xOffset
;
var
newY
=
(
mx
[
1
]
*
x
+
mx
[
5
]
*
y
+
mx
[
9
]
*
z
+
mx
[
13
]
)
/
newW
+
yOffset
;
newPoints
.
push
(
[
newX
newY
]
)
;
}
if
(
testTransformedBoundary
.
switchStyleIdx
=
=
=
undefined
)
{
testTransformedBoundary
.
switchStyleIdx
=
switchStyles
.
length
-
1
;
}
switchStyles
[
testTransformedBoundary
.
switchStyleIdx
%
switchStyles
.
length
]
.
disabled
=
true
;
testTransformedBoundary
.
switchStyleIdx
+
+
;
testTransformedBoundary
.
switchStyleIdx
%
=
19
;
switchStyles
[
testTransformedBoundary
.
switchStyleIdx
%
switchStyles
.
length
]
.
disabled
=
false
;
if
(
typeof
transformValue
=
=
"
string
"
)
{
setStyles
(
{
transform
:
transformValue
transformOrigin
:
transformOriginValue
}
)
}
else
{
setStyles
(
{
transform
:
transformValue
[
2
]
transformOrigin
:
transformOriginValue
}
{
transform
:
transformValue
[
1
]
}
{
transform
:
transformValue
[
0
]
}
)
;
}
test
(
function
(
)
{
var
expectedTop
=
Math
.
min
.
apply
(
null
newPoints
.
map
(
function
(
p
)
{
return
p
[
1
]
}
)
)
;
var
expectedRight
=
Math
.
max
.
apply
(
null
newPoints
.
map
(
function
(
p
)
{
return
p
[
0
]
}
)
)
;
var
expectedBottom
=
Math
.
max
.
apply
(
null
newPoints
.
map
(
function
(
p
)
{
return
p
[
1
]
}
)
)
;
var
expectedLeft
=
Math
.
min
.
apply
(
null
newPoints
.
map
(
function
(
p
)
{
return
p
[
0
]
}
)
)
;
var
rect
=
div
.
getBoundingClientRect
(
)
;
var
msg
=
"
(
actual
"
+
rect
.
top
.
toFixed
(
3
)
+
"
"
+
rect
.
right
.
toFixed
(
3
)
+
"
"
+
rect
.
bottom
.
toFixed
(
3
)
+
"
"
+
rect
.
left
.
toFixed
(
3
)
+
"
;
"
+
"
expected
"
+
expectedTop
.
toFixed
(
3
)
+
"
"
+
expectedRight
.
toFixed
(
3
)
+
"
"
+
expectedBottom
.
toFixed
(
3
)
+
"
"
+
expectedLeft
.
toFixed
(
3
)
+
"
)
"
;
assert_approx_equals
(
rect
.
top
expectedTop
pixelEpsilon
"
top
"
+
msg
)
;
assert_approx_equals
(
rect
.
right
expectedRight
pixelEpsilon
"
right
"
+
msg
)
;
assert_approx_equals
(
rect
.
bottom
expectedBottom
pixelEpsilon
"
bottom
"
+
msg
)
;
assert_approx_equals
(
rect
.
left
expectedLeft
pixelEpsilon
"
left
"
+
msg
)
;
assert_approx_equals
(
rect
.
width
expectedRight
-
expectedLeft
pixelEpsilon
"
width
"
+
msg
)
;
assert_approx_equals
(
rect
.
height
expectedBottom
-
expectedTop
pixelEpsilon
"
height
"
+
msg
)
;
}
"
getBoundingClientRect
(
)
"
+
getStyleDescription
(
)
+
"
;
"
+
"
switch
style
"
+
(
testTransformedBoundary
.
switchStyleIdx
%
switchStyles
.
length
)
)
;
var
getVectorToLine
=
function
(
origin
point
line
)
{
point
=
[
point
[
0
]
-
origin
[
0
]
point
[
1
]
-
origin
[
1
]
]
;
line
=
[
line
[
0
]
-
origin
[
0
]
line
[
1
]
-
origin
[
1
]
]
;
var
lineLength
=
Math
.
sqrt
(
line
[
0
]
*
line
[
0
]
+
line
[
1
]
*
line
[
1
]
)
;
line
[
0
]
/
=
lineLength
;
line
[
1
]
/
=
lineLength
;
return
[
point
[
0
]
-
line
[
0
]
*
(
point
[
0
]
*
line
[
0
]
+
point
[
1
]
*
line
[
1
]
)
point
[
1
]
-
line
[
1
]
*
(
point
[
0
]
*
line
[
0
]
+
point
[
1
]
*
line
[
1
]
)
]
;
}
;
var
getOrthogonalDistance
=
function
(
origin
point
line
)
{
var
projected
=
getVectorToLine
(
origin
point
line
)
;
return
Math
.
sqrt
(
projected
[
0
]
*
projected
[
0
]
+
projected
[
1
]
*
projected
[
1
]
)
;
}
;
var
distance1
=
getOrthogonalDistance
(
newPoints
[
0
]
[
(
newPoints
[
2
]
[
0
]
+
newPoints
[
3
]
[
0
]
)
/
2
(
newPoints
[
2
]
[
1
]
+
newPoints
[
3
]
[
1
]
)
/
2
]
newPoints
[
1
]
)
;
var
distance2
=
getOrthogonalDistance
(
newPoints
[
0
]
[
(
newPoints
[
1
]
[
0
]
+
newPoints
[
3
]
[
0
]
)
/
2
(
newPoints
[
1
]
[
1
]
+
newPoints
[
3
]
[
1
]
)
/
2
]
newPoints
[
2
]
)
;
var
testInside
=
distance1
>
=
5
&
&
distance2
>
=
5
&
&
getComputedStyle
(
div
.
parentNode
)
[
prefixProp
(
"
transformStyle
"
)
]
=
=
"
flat
"
&
&
getComputedStyle
(
div
.
parentNode
.
parentNode
)
[
prefixProp
(
"
transformStyle
"
)
]
=
=
"
flat
"
;
test
(
function
(
)
{
if
(
testInside
)
{
var
weightPoints
=
function
(
topLeft
bottomLeft
topRight
bottomRight
)
{
var
sum
=
topLeft
+
bottomLeft
+
topRight
+
bottomRight
;
topLeft
/
=
sum
;
bottomLeft
/
=
sum
;
topRight
/
=
sum
;
bottomRight
/
=
sum
;
return
[
newPoints
[
0
]
[
0
]
*
topLeft
+
newPoints
[
1
]
[
0
]
*
bottomLeft
+
newPoints
[
2
]
[
0
]
*
topRight
+
newPoints
[
3
]
[
0
]
*
bottomRight
newPoints
[
0
]
[
1
]
*
topLeft
+
newPoints
[
1
]
[
1
]
*
bottomLeft
+
newPoints
[
2
]
[
1
]
*
topRight
+
newPoints
[
3
]
[
1
]
*
bottomRight
]
;
}
;
var
pointsInside
=
[
weightPoints
(
3
3
1
1
)
weightPoints
(
1
1
3
3
)
weightPoints
(
3
1
3
1
)
weightPoints
(
1
3
1
3
)
]
;
pointsInside
.
forEach
(
function
(
p
)
{
document
.
documentElement
.
style
.
position
=
"
relative
"
;
document
.
documentElement
.
style
.
left
=
(
10
-
p
[
0
]
)
+
"
px
"
;
document
.
documentElement
.
style
.
top
=
(
10
-
p
[
1
]
)
+
"
px
"
;
assert_equals
(
document
.
elementFromPoint
(
10
10
)
div
"
Point
(
"
+
p
[
0
]
+
"
"
+
p
[
1
]
+
"
)
is
not
in
the
test
div
.
"
+
"
Expected
vertices
:
"
+
newPoints
.
map
(
function
(
p
)
{
return
"
(
"
+
p
[
0
]
+
"
"
+
p
[
1
]
+
"
)
"
;
}
)
.
join
(
"
;
"
)
)
;
}
)
;
}
var
getOutsideEdge
=
function
(
origin
point1
point2
line
)
{
var
point
=
[
(
point1
[
0
]
+
point2
[
0
]
)
/
2
(
point1
[
1
]
+
point2
[
1
]
)
/
2
]
;
var
projected
=
getVectorToLine
(
origin
point
line
)
;
var
len
=
Math
.
sqrt
(
projected
[
0
]
*
projected
[
0
]
+
projected
[
1
]
*
projected
[
1
]
)
;
projected
[
0
]
*
=
-
5
/
len
;
projected
[
1
]
*
=
-
5
/
len
;
projected
[
0
]
+
=
origin
[
0
]
;
projected
[
1
]
+
=
origin
[
1
]
;
return
projected
;
}
;
var
pointsOutside
=
[
getOutsideEdge
(
newPoints
[
0
]
newPoints
[
1
]
newPoints
[
3
]
newPoints
[
2
]
)
getOutsideEdge
(
newPoints
[
2
]
newPoints
[
0
]
newPoints
[
1
]
newPoints
[
3
]
)
getOutsideEdge
(
newPoints
[
1
]
newPoints
[
0
]
newPoints
[
2
]
newPoints
[
3
]
)
getOutsideEdge
(
newPoints
[
0
]
newPoints
[
2
]
newPoints
[
3
]
newPoints
[
1
]
)
]
;
pointsOutside
.
forEach
(
function
(
p
)
{
document
.
documentElement
.
style
.
position
=
"
relative
"
;
document
.
documentElement
.
style
.
left
=
(
10
-
p
[
0
]
)
+
"
px
"
;
document
.
documentElement
.
style
.
top
=
(
10
-
p
[
1
]
)
+
"
px
"
;
assert_not_equals
(
document
.
elementFromPoint
(
10
10
)
div
"
Point
(
"
+
p
[
0
]
+
"
"
+
p
[
1
]
+
"
)
is
in
the
test
div
.
"
+
"
Expected
vertices
:
"
+
newPoints
.
map
(
function
(
p
)
{
return
"
(
"
+
p
[
0
]
+
"
"
+
p
[
1
]
+
"
)
"
;
}
)
.
join
(
"
;
"
)
)
;
}
)
;
}
"
elementFromPoint
(
)
"
+
(
testInside
?
"
"
:
"
(
outside
points
only
)
"
)
+
getStyleDescription
(
)
+
"
;
"
+
"
switch
style
"
+
(
testTransformedBoundary
.
switchStyleIdx
%
switchStyles
.
length
)
)
;
if
(
typeof
transformValue
!
=
"
string
"
)
{
setStyles
(
undefined
{
}
{
}
)
;
}
document
.
documentElement
.
setAttribute
(
"
style
"
"
"
)
;
document
.
documentElement
.
removeAttribute
(
"
style
"
)
;
}
function
testTransformOrigin
(
value
expectedX
expectedY
expectedZ
)
{
if
(
expectedX
=
=
"
left
"
)
{
expectedX
=
"
0
%
"
;
}
else
if
(
expectedX
=
=
"
center
"
)
{
expectedX
=
"
50
%
"
;
}
else
if
(
expectedX
=
=
"
right
"
)
{
expectedX
=
"
100
%
"
;
}
if
(
expectedY
=
=
"
top
"
)
{
expectedY
=
"
0
%
"
;
}
else
if
(
expectedY
=
=
"
center
"
)
{
expectedY
=
"
50
%
"
;
}
else
if
(
expectedY
=
=
"
bottom
"
)
{
expectedY
=
"
100
%
"
;
}
expectedX
=
convertToPx
(
expectedX
divWidth
)
;
expectedY
=
convertToPx
(
expectedY
divHeight
)
;
if
(
expectedZ
!
=
=
undefined
)
{
expectedZ
=
convertToPx
(
expectedZ
)
;
}
else
{
expectedZ
=
0
;
}
if
(
testTransformOrigin
.
counter
=
=
=
undefined
)
{
testTransformOrigin
.
counter
=
0
;
}
var
transformValue
=
{
0
:
"
none
"
1
:
"
matrix
(
7
0
-
1
13
0
0
)
"
2
:
"
translate
(
4em
-
15px
)
"
3
:
"
scale
(
1
.
2
1
)
"
4
:
"
rotate
(
43deg
)
"
}
[
testTransformOrigin
.
counter
%
5
]
;
testTransformOrigin
.
counter
+
+
;
div
.
removeAttribute
(
"
style
"
)
;
setStyles
(
{
transform
:
transformValue
transformOrigin
:
value
}
)
;
test
(
function
(
)
{
var
actual
=
getComputedStyle
(
div
)
[
prefixProp
(
"
transformOrigin
"
)
]
;
var
re
=
expectedZ
=
=
0
?
/
^
(
[
^
]
+
)
px
(
[
^
]
+
)
px
/
:
/
^
(
[
^
]
+
)
px
(
[
^
]
+
)
px
(
[
^
]
+
)
px
/
;
assert_regexp_match
(
actual
re
"
Computed
value
has
unexpected
form
"
)
;
var
match
=
re
.
exec
(
actual
)
;
var
msg
=
'
(
actual
:
"
'
+
actual
+
'
"
expected
:
"
'
+
expectedX
+
"
px
"
+
expectedY
+
(
expectedZ
=
=
0
?
"
"
:
"
px
"
+
expectedZ
)
+
'
px
"
)
'
;
assert_approx_equals
(
Number
(
match
[
1
]
)
expectedX
computedEpsilon
"
Value
of
X
part
"
+
msg
)
;
assert_approx_equals
(
Number
(
match
[
2
]
)
expectedY
computedEpsilon
"
Value
of
Y
part
"
+
msg
)
;
if
(
expectedZ
!
=
0
)
{
assert_approx_equals
(
Number
(
match
[
3
]
)
expectedZ
computedEpsilon
"
Value
of
Z
part
"
+
msg
)
;
}
}
"
getComputedStyle
(
div
)
.
transformOrigin
"
+
getStyleDescription
(
)
)
;
testTransformedBoundary
(
expectedZ
=
=
=
0
?
"
rotate
(
45deg
)
"
:
"
rotate3d
(
1
-
1
1
45deg
)
"
expectedZ
=
=
=
0
?
getRotationMatrix
(
0
0
1
"
45deg
"
)
:
getRotationMatrix
(
1
-
1
1
"
45deg
"
)
value
expectedX
expectedY
expectedZ
)
;
}
function
testTransformOriginParsing
(
expectedX
expectedY
expectedZ
)
{
}
function
testPerspective
(
value
originValue
expectedX
expectedY
)
{
setStyles
(
{
}
{
perspective
:
value
}
)
;
testPerspectiveParsing
(
value
)
;
expectedX
=
convertToPx
(
expectedX
divParentWidth
)
-
(
divParentWidth
-
divWidth
)
/
2
;
expectedY
=
convertToPx
(
expectedY
divParentHeight
)
-
(
divParentHeight
-
divHeight
)
/
2
;
setStyles
(
{
}
{
perspective
:
value
perspectiveOrigin
:
originValue
}
)
;
testPerspectiveBoundary
(
value
expectedX
expectedY
)
;
setStyles
(
{
}
{
}
)
;
}
function
testPerspectiveParsing
(
value
)
{
test
(
function
(
)
{
var
actual
=
getComputedStyle
(
div
.
parentNode
)
[
prefixProp
(
"
perspective
"
)
]
;
if
(
convertToPx
(
value
)
=
=
=
null
|
|
convertToPx
(
value
)
<
=
0
)
{
assert_equals
(
actual
"
none
"
)
;
return
;
}
assert_regexp_match
(
actual
/
^
[
0
-
9
]
+
(
\
.
[
0
-
9
]
+
)
?
px
/
"
Computed
value
has
unexpected
form
"
)
;
assert_approx_equals
(
parseFloat
(
actual
)
convertToPx
(
value
)
computedEpsilon
)
;
}
"
getComputedStyle
(
div
.
parentNode
)
.
perspective
"
+
getStyleDescription
(
)
)
;
}
function
testPerspectiveBoundary
(
perspective
perspectiveOriginX
perspectiveOriginY
)
{
if
(
convertToPx
(
perspective
)
=
=
=
null
|
|
convertToPx
(
perspective
)
<
=
0
)
{
perspective
=
"
none
"
;
}
if
(
perspectiveOriginX
=
=
=
undefined
)
{
perspectiveOriginX
=
divWidth
/
2
;
}
if
(
perspectiveOriginY
=
=
=
undefined
)
{
perspectiveOriginY
=
divHeight
/
2
;
}
var
mx
=
mxmul44
(
[
1
0
0
0
0
1
0
0
0
0
1
0
-
convertToPx
(
"
50
%
"
divWidth
)
-
convertToPx
(
"
50
%
"
divHeight
)
0
1
]
[
1
0
0
0
0
1
0
0
0
0
1
0
perspectiveOriginX
perspectiveOriginY
0
1
]
[
1
0
0
0
0
1
0
0
0
0
1
perspective
=
=
"
none
"
?
0
:
-
1
/
convertToPx
(
perspective
)
0
0
0
1
]
[
1
0
0
0
0
1
0
0
0
0
1
0
-
perspectiveOriginX
-
perspectiveOriginY
0
1
]
[
1
0
0
0
0
1
0
0
0
0
1
0
convertToPx
(
"
50
%
"
divWidth
)
convertToPx
(
"
50
%
"
divHeight
)
0
1
]
getRotationMatrix
(
1
0
0
"
45deg
"
)
)
;
testTransformedBoundary
(
"
rotateX
(
45deg
)
"
mx
)
;
}
function
testPerspectiveOrigin
(
value
expectedX
expectedY
)
{
if
(
expectedX
=
=
"
left
"
)
{
expectedX
=
"
0
%
"
;
}
else
if
(
expectedX
=
=
"
center
"
)
{
expectedX
=
"
50
%
"
;
}
else
if
(
expectedX
=
=
"
right
"
)
{
expectedX
=
"
100
%
"
;
}
if
(
expectedY
=
=
"
top
"
)
{
expectedY
=
"
0
%
"
;
}
else
if
(
expectedY
=
=
"
center
"
)
{
expectedY
=
"
50
%
"
;
}
else
if
(
expectedY
=
=
"
bottom
"
)
{
expectedY
=
"
100
%
"
;
}
expectedX
=
convertToPx
(
expectedX
divWidth
)
;
expectedY
=
convertToPx
(
expectedY
divHeight
)
;
setStyles
(
{
perspectiveOrigin
:
value
}
)
;
test
(
function
(
)
{
var
actual
=
getComputedStyle
(
div
)
[
prefixProp
(
"
perspectiveOrigin
"
)
]
;
var
re
=
/
^
(
[
^
]
+
)
px
(
[
^
]
+
)
px
/
;
assert_regexp_match
(
actual
re
"
Computed
value
has
unexpected
form
"
)
;
var
match
=
re
.
exec
(
actual
)
;
var
msg
=
'
(
actual
:
"
'
+
actual
+
'
"
expected
:
"
'
+
expectedX
+
"
px
"
+
expectedY
+
'
px
"
)
'
;
assert_approx_equals
(
Number
(
match
[
1
]
)
expectedX
computedEpsilon
"
Value
of
X
part
"
+
msg
)
;
assert_approx_equals
(
Number
(
match
[
2
]
)
expectedY
computedEpsilon
"
Value
of
Y
part
"
+
msg
)
;
}
"
getComputedStyle
(
div
)
.
perspectiveOrigin
"
+
getStyleDescription
(
)
)
;
setStyles
(
{
}
)
;
}
