function
assert_fallback_position
(
anchored
anchor
direction
)
{
let
anchoredRect
=
anchored
.
getBoundingClientRect
(
)
;
let
anchorRect
=
anchor
.
getBoundingClientRect
(
)
;
let
message
=
Anchored
element
should
be
at
the
{
direction
}
of
anchor
;
switch
(
direction
)
{
case
'
top
'
:
assert_equals
(
anchoredRect
.
bottom
anchorRect
.
top
message
)
;
return
;
case
'
bottom
'
:
assert_equals
(
anchoredRect
.
top
anchorRect
.
bottom
message
)
;
return
;
case
'
left
'
:
assert_equals
(
anchoredRect
.
right
anchorRect
.
left
message
)
;
return
;
case
'
right
'
:
assert_equals
(
anchoredRect
.
left
anchorRect
.
right
message
)
;
return
;
default
:
assert_unreached
(
'
unsupported
direction
'
)
;
}
}
async
function
waitUntilNextAnimationFrame
(
)
{
return
new
Promise
(
resolve
=
>
requestAnimationFrame
(
resolve
)
)
;
}
window
.
checkLayoutForAnchorPos
=
async
function
(
selectorList
callDone
=
true
)
{
if
(
window
.
CHECK_LAYOUT_DELAY
)
{
assert_equals
(
window
.
INJECTED_SCRIPT
undefined
'
CHECK_LAYOUT_DELAY
is
only
allowed
when
serving
WPT
with
-
-
injected
-
script
.
'
)
;
await
waitUntilNextAnimationFrame
(
)
;
await
waitUntilNextAnimationFrame
(
)
;
await
waitUntilNextAnimationFrame
(
)
;
}
return
window
.
checkLayout
(
selectorList
callDone
)
;
}
