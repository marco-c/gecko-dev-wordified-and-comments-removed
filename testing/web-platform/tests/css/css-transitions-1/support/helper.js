(
function
(
root
)
{
'
use
strict
'
;
root
.
setStyle
=
function
(
selector
styles
)
{
var
target
=
document
.
getElementById
(
'
dynamic
-
style
'
)
;
if
(
!
target
)
{
target
=
document
.
createElement
(
'
style
'
)
;
target
.
id
=
'
dynamic
-
style
'
;
target
.
type
=
"
text
/
css
"
;
document
.
getElementsByTagName
(
'
head
'
)
[
0
]
.
appendChild
(
target
)
;
}
var
data
=
[
]
;
if
(
typeof
selector
=
=
=
'
string
'
&
&
styles
!
=
=
undefined
)
{
data
=
[
selector
'
{
'
serializeStyles
(
styles
)
'
}
'
]
;
target
.
textContent
=
data
.
join
(
"
\
n
"
)
;
return
;
}
for
(
var
key
in
selector
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
selector
key
)
)
{
var
_data
=
[
key
'
{
'
serializeStyles
(
selector
[
key
]
)
'
}
'
]
;
data
.
push
(
_data
.
join
(
'
\
n
'
)
)
;
}
}
target
.
textContent
=
data
.
join
(
"
\
n
"
)
;
}
;
function
serializeStyles
(
styles
)
{
var
data
=
[
]
;
for
(
var
property
in
styles
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
styles
property
)
)
{
var
prefixedProperty
=
addVendorPrefix
(
property
)
;
data
.
push
(
prefixedProperty
+
"
:
"
+
styles
[
property
]
+
"
;
"
)
;
}
}
return
data
.
join
(
'
\
n
'
)
;
}
root
.
computedStyle
=
function
(
element
property
pseudo
)
{
var
prefixedProperty
=
addVendorPrefix
(
property
)
;
return
window
.
getComputedStyle
(
element
pseudo
|
|
null
)
.
getPropertyValue
(
prefixedProperty
)
;
}
;
root
.
reflow
=
function
(
)
{
document
.
body
.
offsetWidth
;
}
;
root
.
extend
=
function
(
target
)
{
Array
.
prototype
.
slice
.
call
(
arguments
1
)
.
forEach
(
function
(
obj
)
{
Object
.
keys
(
obj
)
.
forEach
(
function
(
key
)
{
target
[
key
]
=
obj
[
key
]
;
}
)
;
}
)
;
return
target
;
}
;
var
_domFixture
;
var
_domFixtureSelector
;
root
.
domFixture
=
function
(
selector
)
{
var
fixture
=
document
.
querySelector
(
selector
|
|
_domFixtureSelector
)
;
if
(
!
fixture
)
{
throw
new
Error
(
'
fixture
'
+
(
selector
|
|
_domFixtureSelector
)
+
'
not
found
!
'
)
;
}
if
(
!
_domFixture
&
&
selector
)
{
_domFixture
=
fixture
.
cloneNode
(
true
)
;
_domFixtureSelector
=
selector
;
}
else
if
(
_domFixture
)
{
var
tmp
=
_domFixture
.
cloneNode
(
true
)
;
fixture
.
parentNode
.
replaceChild
(
tmp
fixture
)
;
}
else
{
throw
new
Error
(
'
domFixture
must
be
initialized
first
!
'
)
;
}
}
;
const
TIME_PRECISION
=
0
.
0005
;
root
.
assert_times_equal
=
function
(
actual
expected
description
)
{
assert_approx_equals
(
actual
expected
TIME_PRECISION
description
)
;
}
root
.
assert_end_events_equal
=
function
(
evt
propertyName
elapsedTime
pseudoElement
=
'
'
)
{
assert_equals
(
evt
.
propertyName
propertyName
)
;
assert_times_equal
(
evt
.
elapsedTime
elapsedTime
)
;
assert_equals
(
evt
.
pseudoElement
pseudoElement
)
;
}
root
.
assert_end_event_batch_equal
=
function
(
evts
propertyNames
elapsedTimes
pseudoElement
=
'
'
)
{
assert_equals
(
evts
.
length
propertyNames
.
length
'
Test
harness
error
:
should
have
waited
for
the
correct
number
of
events
'
)
;
assert_true
(
typeof
elapsedTimes
=
=
=
'
number
'
|
|
(
Array
.
isArray
(
elapsedTimes
)
&
&
elapsedTimes
.
length
=
=
=
propertyNames
.
length
)
'
Test
harness
error
:
elapsedTimes
must
either
be
a
number
or
an
array
of
'
+
'
numbers
with
the
same
length
as
propertyNames
'
)
;
if
(
typeof
elapsedTimes
=
=
=
'
number
'
)
{
elapsedTimes
=
Array
(
propertyNames
.
length
)
.
fill
(
elapsedTimes
)
;
}
const
testPairs
=
propertyNames
.
map
(
(
propertyName
index
)
=
>
(
{
propertyName
elapsedTime
:
elapsedTimes
[
index
]
}
)
)
;
const
sortByPropertyName
=
(
a
b
)
=
>
a
.
propertyName
.
localeCompare
(
b
.
propertyName
)
;
evts
.
sort
(
sortByPropertyName
)
;
testPairs
.
sort
(
sortByPropertyName
)
;
for
(
let
evt
of
evts
)
{
const
expected
=
testPairs
.
shift
(
)
;
assert_end_events_equal
(
evt
expected
.
propertyName
expected
.
elapsedTime
pseudoElement
)
;
}
}
root
.
addDiv
=
function
(
t
attrs
)
{
var
div
=
document
.
createElement
(
'
div
'
)
;
if
(
attrs
)
{
for
(
var
attrName
in
attrs
)
{
div
.
setAttribute
(
attrName
attrs
[
attrName
]
)
;
}
}
document
.
body
.
appendChild
(
div
)
;
if
(
t
&
&
typeof
t
.
add_cleanup
=
=
=
'
function
'
)
{
t
.
add_cleanup
(
function
(
)
{
if
(
div
.
parentNode
)
{
div
.
remove
(
)
;
}
}
)
;
}
return
div
;
}
}
)
(
window
)
;
