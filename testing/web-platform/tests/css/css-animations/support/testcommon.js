const
MS_PER_SEC
=
1000
;
var
TIME_PRECISION
=
0
.
0005
;
function
assert_times_equal
(
actual
expected
description
)
{
assert_approx_equals
(
actual
expected
TIME_PRECISION
*
2
description
)
;
}
function
assert_time_equals_literal
(
actual
expected
description
)
{
assert_approx_equals
(
actual
expected
TIME_PRECISION
description
)
;
}
function
assert_frames_equal
(
actual
expected
name
)
{
assert_array_equals
(
Object
.
keys
(
actual
)
.
sort
(
)
Object
.
keys
(
expected
)
.
sort
(
)
properties
on
{
name
}
should
match
)
;
for
(
const
prop
of
Object
.
keys
(
actual
)
.
sort
(
)
)
{
if
(
(
prop
=
=
=
'
offset
'
&
&
typeof
actual
[
prop
]
=
=
=
'
number
'
)
|
|
prop
=
=
=
'
computedOffset
'
)
{
assert_approx_equals
(
actual
[
prop
]
expected
[
prop
]
0
.
00001
"
value
for
'
"
+
prop
+
"
'
on
"
+
name
)
;
}
else
{
assert_equals
(
actual
[
prop
]
expected
[
prop
]
value
for
'
{
prop
}
'
on
{
name
}
should
match
)
;
}
}
}
function
assert_frame_lists_equal
(
actual
expected
)
{
assert_equals
(
actual
.
length
expected
.
length
'
Number
of
keyframes
should
match
'
)
;
for
(
let
i
=
0
;
i
<
actual
.
length
;
i
+
+
)
{
assert_frames_equal
(
actual
[
i
]
expected
[
i
]
Keyframe
#
{
i
}
)
;
}
}
function
addDiv
(
t
attrs
)
{
var
div
=
document
.
createElement
(
'
div
'
)
;
if
(
attrs
)
{
for
(
var
attrName
in
attrs
)
{
div
.
setAttribute
(
attrName
attrs
[
attrName
]
)
;
}
}
document
.
body
.
appendChild
(
div
)
;
if
(
t
&
&
typeof
t
.
add_cleanup
=
=
=
'
function
'
)
{
t
.
add_cleanup
(
function
(
)
{
if
(
div
.
parentNode
)
{
div
.
remove
(
)
;
}
}
)
;
}
return
div
;
}
function
addStyle
(
t
rules
)
{
var
extraStyle
=
document
.
createElement
(
'
style
'
)
;
document
.
head
.
appendChild
(
extraStyle
)
;
if
(
rules
)
{
var
sheet
=
extraStyle
.
sheet
;
for
(
var
selector
in
rules
)
{
sheet
.
insertRule
(
selector
+
'
{
'
+
rules
[
selector
]
+
'
}
'
sheet
.
cssRules
.
length
)
;
}
}
if
(
t
&
&
typeof
t
.
add_cleanup
=
=
=
'
function
'
)
{
t
.
add_cleanup
(
function
(
)
{
extraStyle
.
remove
(
)
;
}
)
;
}
}
function
waitForFrame
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
window
.
requestAnimationFrame
(
resolve
)
;
}
)
;
}
function
waitForNextFrame
(
)
{
const
timeAtStart
=
document
.
timeline
.
currentTime
;
return
new
Promise
(
resolve
=
>
{
window
.
requestAnimationFrame
(
(
)
=
>
{
if
(
timeAtStart
=
=
=
document
.
timeline
.
currentTime
)
{
window
.
requestAnimationFrame
(
resolve
)
;
}
else
{
resolve
(
)
;
}
}
)
;
}
)
;
}
function
waitForAnimationFrames
(
frameCount
onFrame
)
{
const
timeAtStart
=
document
.
timeline
.
currentTime
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
handleFrame
(
)
{
if
(
onFrame
&
&
typeof
onFrame
=
=
=
'
function
'
)
{
onFrame
(
)
;
}
if
(
timeAtStart
!
=
document
.
timeline
.
currentTime
&
&
-
-
frameCount
<
=
0
)
{
resolve
(
)
;
}
else
{
window
.
requestAnimationFrame
(
handleFrame
)
;
}
}
window
.
requestAnimationFrame
(
handleFrame
)
;
}
)
;
}
function
fastEventsTimeout
(
)
{
return
waitForAnimationFrames
(
2
)
;
}
;
function
armTimeoutWhenReady
(
animation
timeoutPromise
)
{
return
(
)
=
>
{
if
(
animation
.
pending
)
return
animation
.
ready
.
then
(
(
)
=
>
{
return
timeoutPromise
(
)
;
}
)
;
else
return
timeoutPromise
(
)
;
}
;
}
function
waitForAllAnimations
(
animations
)
{
return
Promise
.
all
(
animations
.
map
(
animation
=
>
animation
.
ready
)
)
;
}
function
flushComputedStyle
(
elem
)
{
var
cs
=
getComputedStyle
(
elem
)
;
cs
.
marginLeft
;
}
async
function
waitForAnimationReadyToRestyle
(
aAnimation
)
{
await
aAnimation
.
ready
;
if
(
animationStartsRightNow
(
aAnimation
)
)
{
await
waitForNextFrame
(
)
;
}
}
