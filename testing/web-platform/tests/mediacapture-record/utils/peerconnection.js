async
function
exchangeOfferAnswer
(
pc1
pc2
)
{
await
pc1
.
setLocalDescription
(
await
pc1
.
createOffer
(
)
)
;
await
pc2
.
setRemoteDescription
(
pc1
.
localDescription
)
;
await
pc2
.
setLocalDescription
(
await
pc2
.
createAnswer
(
)
)
;
await
pc1
.
setRemoteDescription
(
pc2
.
localDescription
)
;
}
function
setTransceiverCodecPreference
(
transceiver
codecPreference
)
{
for
(
let
codec
of
RTCRtpSender
.
getCapabilities
(
'
video
'
)
.
codecs
)
{
if
(
codec
.
mimeType
.
includes
(
codecPreference
)
)
{
transceiver
.
setCodecPreferences
(
[
codec
]
)
;
return
;
}
}
}
async
function
startConnection
(
t
useAudio
useVideo
videoCodecPreference
)
{
const
stream
=
await
navigator
.
mediaDevices
.
getUserMedia
(
{
audio
:
useAudio
video
:
useVideo
}
)
;
t
.
add_cleanup
(
(
)
=
>
stream
.
getTracks
(
)
.
forEach
(
track
=
>
track
.
stop
(
)
)
)
;
const
pc1
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
pc1
.
close
(
)
)
;
const
pc2
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
pc2
.
close
(
)
)
;
let
transceivers
=
{
}
;
stream
.
getTracks
(
)
.
forEach
(
track
=
>
{
const
transceiver
=
pc1
.
addTransceiver
(
track
)
;
transceivers
[
track
.
kind
]
=
transceiver
;
if
(
videoCodecPreference
&
&
track
.
kind
=
=
'
video
'
)
{
setTransceiverCodecPreference
(
transceiver
videoCodecPreference
)
;
}
}
)
;
function
doExchange
(
localPc
remotePc
)
{
localPc
.
addEventListener
(
'
icecandidate
'
event
=
>
{
const
{
candidate
}
=
event
;
if
(
candidate
&
&
remotePc
.
signalingState
!
=
=
'
closed
'
)
{
remotePc
.
addIceCandidate
(
candidate
)
;
}
}
)
;
}
doExchange
(
pc1
pc2
)
;
doExchange
(
pc2
pc1
)
;
exchangeOfferAnswer
(
pc1
pc2
)
;
const
remoteStream
=
await
new
Promise
(
resolve
=
>
{
let
tracks
=
[
]
;
pc2
.
ontrack
=
e
=
>
{
tracks
.
push
(
e
.
track
)
if
(
tracks
.
length
<
useAudio
+
useVideo
)
return
;
const
stream
=
new
MediaStream
(
tracks
)
;
const
remoteVideo
=
document
.
getElementById
(
'
remote
'
)
;
if
(
remoteVideo
)
{
remoteVideo
.
srcObject
=
stream
;
}
resolve
(
stream
)
}
}
)
;
return
[
pc1
pc2
remoteStream
transceivers
]
}
async
function
waitForReceivedFrames
(
t
pc
lookForAudio
lookForVideo
numFramesOrPackets
)
{
let
initialAudioPackets
=
0
;
let
initialVideoFrames
=
0
;
while
(
lookForAudio
|
|
lookForVideo
)
{
const
report
=
await
pc
.
getStats
(
)
;
report
.
forEach
(
stats
=
>
{
if
(
stats
.
type
&
&
stats
.
type
=
=
'
inbound
-
rtp
'
)
{
if
(
lookForAudio
&
&
stats
.
kind
=
=
'
audio
'
)
{
if
(
!
initialAudioPackets
)
{
initialAudioPackets
=
stats
.
packetsReceived
}
else
if
(
stats
.
packetsReceived
>
initialAudioPackets
+
numFramesOrPackets
)
{
lookForAudio
=
false
;
}
}
if
(
lookForVideo
&
&
stats
.
kind
=
=
'
video
'
)
{
if
(
!
initialVideoFrames
)
{
initialVideoFrames
=
stats
.
framesDecoded
;
}
else
if
(
stats
.
framesDecoded
>
initialVideoFrames
+
numFramesOrPackets
)
{
lookForVideo
=
false
;
}
}
}
}
)
;
await
new
Promise
(
r
=
>
{
t
.
step_timeout
(
r
100
)
;
}
)
;
}
}
async
function
waitForReceivedCodec
(
t
pc
codecToLookFor
)
{
let
currentCodecId
;
for
(
;
;
)
{
const
report
=
await
pc
.
getStats
(
)
;
report
.
forEach
(
stats
=
>
{
if
(
stats
.
id
)
{
if
(
stats
.
type
=
=
'
inbound
-
rtp
'
&
&
stats
.
kind
=
=
'
video
'
)
{
currentCodecId
=
stats
.
codecId
;
}
else
if
(
currentCodecId
&
&
stats
.
id
=
=
currentCodecId
&
&
stats
.
mimeType
.
toLowerCase
(
)
.
includes
(
codecToLookFor
.
toLowerCase
(
)
)
)
{
return
;
}
}
}
)
;
await
new
Promise
(
r
=
>
{
t
.
step_timeout
(
r
100
)
;
}
)
;
}
}
