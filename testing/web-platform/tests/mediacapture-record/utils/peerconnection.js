async
function
exchangeOfferAnswer
(
pc1
pc2
)
{
await
pc1
.
setLocalDescription
(
)
;
await
pc2
.
setRemoteDescription
(
pc1
.
localDescription
)
;
await
pc2
.
setLocalDescription
(
)
;
await
pc1
.
setRemoteDescription
(
pc2
.
localDescription
)
;
}
function
setTransceiverCodecPreference
(
transceiver
codecPreference
)
{
for
(
const
codec
of
RTCRtpSender
.
getCapabilities
(
'
video
'
)
.
codecs
)
{
if
(
codec
.
mimeType
.
includes
(
codecPreference
)
)
{
transceiver
.
setCodecPreferences
(
[
codec
]
)
;
return
;
}
}
}
async
function
startConnection
(
t
audio
video
videoCodecPreference
)
{
const
scope
=
[
]
;
if
(
audio
)
scope
.
push
(
"
microphone
"
)
;
if
(
video
)
scope
.
push
(
"
camera
"
)
;
await
setMediaPermission
(
"
granted
"
scope
)
;
const
stream
=
await
navigator
.
mediaDevices
.
getUserMedia
(
{
audio
video
}
)
;
t
.
add_cleanup
(
(
)
=
>
stream
.
getTracks
(
)
.
forEach
(
track
=
>
track
.
stop
(
)
)
)
;
const
pc1
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
pc1
.
close
(
)
)
;
const
pc2
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
pc2
.
close
(
)
)
;
const
transceivers
=
{
}
;
for
(
const
track
of
stream
.
getTracks
(
)
)
{
const
transceiver
=
pc1
.
addTransceiver
(
track
{
streams
:
[
stream
]
}
)
;
transceivers
[
track
.
kind
]
=
transceiver
;
if
(
videoCodecPreference
&
&
track
.
kind
=
=
'
video
'
)
{
setTransceiverCodecPreference
(
transceiver
videoCodecPreference
)
;
}
}
for
(
const
[
local
remote
]
of
[
[
pc1
pc2
]
[
pc2
pc1
]
]
)
{
local
.
addEventListener
(
'
icecandidate
'
(
{
candidate
}
)
=
>
{
if
(
!
candidate
|
|
remote
.
signalingState
=
=
'
closed
'
)
return
;
remote
.
addIceCandidate
(
candidate
)
;
}
)
;
}
const
haveTrackEvent
=
new
Promise
(
r
=
>
pc2
.
ontrack
=
r
)
;
await
exchangeOfferAnswer
(
pc1
pc2
)
;
const
{
streams
}
=
await
haveTrackEvent
;
return
[
pc1
pc2
streams
[
0
]
transceivers
]
;
}
async
function
waitForReceivedFramesOrPackets
(
t
pc
lookForAudio
lookForVideo
numFramesOrPackets
)
{
let
initialAudioPackets
=
0
;
let
initialVideoFrames
=
0
;
while
(
lookForAudio
|
|
lookForVideo
)
{
const
report
=
await
pc
.
getStats
(
)
;
for
(
const
stats
of
report
.
values
(
)
)
{
if
(
stats
.
type
=
=
'
inbound
-
rtp
'
)
{
if
(
lookForAudio
&
&
stats
.
kind
=
=
'
audio
'
)
{
if
(
!
initialAudioPackets
)
{
initialAudioPackets
=
stats
.
packetsReceived
;
}
else
if
(
stats
.
packetsReceived
>
initialAudioPackets
+
numFramesOrPackets
)
{
lookForAudio
=
false
;
}
}
if
(
lookForVideo
&
&
stats
.
kind
=
=
'
video
'
)
{
if
(
!
initialVideoFrames
)
{
initialVideoFrames
=
stats
.
framesDecoded
;
}
else
if
(
stats
.
framesDecoded
>
initialVideoFrames
+
numFramesOrPackets
)
{
lookForVideo
=
false
;
}
}
}
}
await
new
Promise
(
r
=
>
t
.
step_timeout
(
r
100
)
)
;
}
}
async
function
waitForReceivedCodec
(
t
pc
codecToLookFor
)
{
let
currentCodecId
;
for
(
;
;
)
{
const
report
=
await
pc
.
getStats
(
)
;
for
(
const
stats
of
report
.
values
(
)
)
{
if
(
stats
.
type
=
=
'
inbound
-
rtp
'
&
&
stats
.
kind
=
=
'
video
'
)
{
if
(
stats
.
codecId
)
{
if
(
report
.
get
(
stats
.
codecId
)
.
mimeType
.
toLowerCase
(
)
.
includes
(
codecToLookFor
.
toLowerCase
(
)
)
)
{
return
;
}
}
}
}
await
new
Promise
(
r
=
>
t
.
step_timeout
(
r
100
)
)
;
}
}
