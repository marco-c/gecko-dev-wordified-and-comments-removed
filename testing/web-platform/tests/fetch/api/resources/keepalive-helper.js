function
getKeepAliveIframeUrl
(
token
method
{
frameOrigin
=
'
DEFAULT
'
requestOrigin
=
'
'
sendOn
=
'
load
'
mode
=
'
cors
'
disallowCrossOrigin
=
false
}
=
{
}
)
{
const
https
=
location
.
protocol
.
startsWith
(
'
https
'
)
;
frameOrigin
=
frameOrigin
=
=
=
'
DEFAULT
'
?
get_host_info
(
)
[
https
?
'
HTTPS_NOTSAMESITE_ORIGIN
'
:
'
HTTP_NOTSAMESITE_ORIGIN
'
]
:
frameOrigin
;
return
{
frameOrigin
}
/
fetch
/
api
/
resources
/
keepalive
-
iframe
.
html
?
+
token
=
{
token
}
&
+
method
=
{
method
}
&
+
sendOn
=
{
sendOn
}
&
+
mode
=
{
mode
}
&
+
(
disallowCrossOrigin
?
disallowCrossOrigin
=
1
&
:
)
+
origin
=
{
requestOrigin
}
;
}
function
getKeepAliveAndRedirectIframeUrl
(
token
origin1
origin2
withPreflight
)
{
const
https
=
location
.
protocol
.
startsWith
(
'
https
'
)
;
const
frameOrigin
=
get_host_info
(
)
[
https
?
'
HTTPS_NOTSAMESITE_ORIGIN
'
:
'
HTTP_NOTSAMESITE_ORIGIN
'
]
;
return
{
frameOrigin
}
/
fetch
/
api
/
resources
/
keepalive
-
redirect
-
iframe
.
html
?
+
token
=
{
token
}
&
+
origin1
=
{
origin1
}
&
+
origin2
=
{
origin2
}
&
+
(
withPreflight
?
with
-
headers
:
)
;
}
async
function
iframeLoaded
(
iframe
)
{
return
new
Promise
(
(
resolve
)
=
>
iframe
.
addEventListener
(
'
load
'
resolve
)
)
;
}
async
function
getTokenFromMessage
(
)
{
return
new
Promise
(
(
resolve
)
=
>
{
window
.
addEventListener
(
'
message
'
(
event
)
=
>
{
resolve
(
event
.
data
)
;
}
{
once
:
true
}
)
;
}
)
;
}
async
function
queryToken
(
token
)
{
const
response
=
await
fetch
(
.
.
/
resources
/
stash
-
take
.
py
?
key
=
{
token
}
)
;
const
json
=
await
response
.
json
(
)
;
return
json
;
}
function
assertStashedTokenAsync
(
testName
token
{
expectTokenExist
=
true
}
=
{
}
)
{
async_test
(
test
=
>
{
new
Promise
(
resolve
=
>
test
.
step_timeout
(
resolve
3000
)
)
.
then
(
test
.
step_func
(
(
)
=
>
{
return
queryToken
(
token
)
;
}
)
)
.
then
(
test
.
step_func
(
result
=
>
{
if
(
expectTokenExist
)
{
assert_equals
(
result
'
on
'
token
[
{
token
}
]
should
be
on
(
stashed
)
.
)
;
test
.
done
(
)
;
}
else
{
assert_not_equals
(
result
'
on
'
token
[
{
token
}
]
should
not
be
on
(
stashed
)
.
)
;
return
Promise
.
reject
(
Failed
to
retrieve
token
[
{
token
}
]
from
server
)
;
}
}
)
)
.
catch
(
test
.
step_func
(
e
=
>
{
if
(
expectTokenExist
)
{
test
.
unreached_func
(
e
)
;
}
else
{
test
.
done
(
)
;
}
}
)
)
;
}
testName
)
;
}
