function
getKeepAliveIframeUrl
(
token
method
{
frameOrigin
=
'
DEFAULT
'
requestOrigin
=
'
'
sendOn
=
'
load
'
mode
=
'
cors
'
disallowCrossOrigin
=
false
}
=
{
}
)
{
const
https
=
location
.
protocol
.
startsWith
(
'
https
'
)
;
frameOrigin
=
frameOrigin
=
=
=
'
DEFAULT
'
?
get_host_info
(
)
[
https
?
'
HTTPS_NOTSAMESITE_ORIGIN
'
:
'
HTTP_NOTSAMESITE_ORIGIN
'
]
:
frameOrigin
;
return
{
frameOrigin
}
/
fetch
/
api
/
resources
/
keepalive
-
iframe
.
html
?
+
token
=
{
token
}
&
+
method
=
{
method
}
&
+
sendOn
=
{
sendOn
}
&
+
mode
=
{
mode
}
&
+
(
disallowCrossOrigin
?
disallowCrossOrigin
=
1
&
:
)
+
origin
=
{
requestOrigin
}
;
}
function
getKeepAliveAndRedirectIframeUrl
(
token
origin1
origin2
withPreflight
)
{
const
https
=
location
.
protocol
.
startsWith
(
'
https
'
)
;
const
frameOrigin
=
get_host_info
(
)
[
https
?
'
HTTPS_NOTSAMESITE_ORIGIN
'
:
'
HTTP_NOTSAMESITE_ORIGIN
'
]
;
return
{
frameOrigin
}
/
fetch
/
api
/
resources
/
keepalive
-
redirect
-
iframe
.
html
?
+
token
=
{
token
}
&
+
origin1
=
{
origin1
}
&
+
origin2
=
{
origin2
}
&
+
(
withPreflight
?
with
-
headers
:
)
;
}
async
function
iframeLoaded
(
iframe
)
{
return
new
Promise
(
(
resolve
)
=
>
iframe
.
addEventListener
(
'
load
'
resolve
)
)
;
}
async
function
getTokenFromMessage
(
)
{
return
new
Promise
(
(
resolve
)
=
>
{
window
.
addEventListener
(
'
message
'
(
event
)
=
>
{
resolve
(
event
.
data
)
;
}
{
once
:
true
}
)
;
}
)
;
}
async
function
queryToken
(
token
)
{
const
response
=
await
fetch
(
.
.
/
resources
/
stash
-
take
.
py
?
key
=
{
token
}
)
;
const
json
=
await
response
.
json
(
)
;
return
json
;
}
function
assertStashedTokenAsync
(
testName
token
{
expectTokenExist
=
true
}
=
{
}
)
{
async_test
(
test
=
>
{
new
Promise
(
resolve
=
>
test
.
step_timeout
(
resolve
3000
)
)
.
then
(
test
.
step_func
(
(
)
=
>
{
return
queryToken
(
token
)
;
}
)
)
.
then
(
test
.
step_func
(
result
=
>
{
if
(
expectTokenExist
)
{
assert_equals
(
result
'
on
'
token
should
be
on
(
stashed
)
.
)
;
test
.
done
(
)
;
}
else
{
assert_not_equals
(
result
'
on
'
token
should
not
be
on
(
stashed
)
.
)
;
return
Promise
.
reject
(
Failed
to
retrieve
token
from
server
)
;
}
}
)
)
.
catch
(
test
.
step_func
(
e
=
>
{
if
(
expectTokenExist
)
{
test
.
unreached_func
(
e
)
;
}
else
{
test
.
done
(
)
;
}
}
)
)
;
}
testName
)
;
}
function
keepaliveRedirectTest
(
desc
{
origin1
=
'
'
origin2
=
'
'
withPreflight
=
false
unloadIframe
=
false
expectFetchSucceed
=
true
}
=
{
}
)
{
desc
=
[
keepalive
]
[
iframe
]
[
load
]
{
desc
}
+
(
unloadIframe
?
'
[
unload
at
end
]
'
:
'
'
)
;
promise_test
(
async
(
test
)
=
>
{
const
tokenToStash
=
token
(
)
;
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
src
=
getKeepAliveAndRedirectIframeUrl
(
tokenToStash
origin1
origin2
withPreflight
)
;
document
.
body
.
appendChild
(
iframe
)
;
await
iframeLoaded
(
iframe
)
;
assert_equals
(
await
getTokenFromMessage
(
)
tokenToStash
)
;
if
(
unloadIframe
)
{
iframe
.
remove
(
)
;
}
assertStashedTokenAsync
(
desc
tokenToStash
{
expectTokenExist
:
expectFetchSucceed
}
)
;
}
{
desc
}
;
setting
up
)
;
}
function
keepaliveRedirectInUnloadTest
(
desc
{
origin1
=
'
'
origin2
=
'
'
url2
=
'
'
withPreflight
=
false
expectFetchSucceed
=
true
}
=
{
}
)
{
desc
=
[
keepalive
]
[
new
window
]
[
unload
]
{
desc
}
;
promise_test
(
async
(
test
)
=
>
{
const
targetUrl
=
{
HTTP_NOTSAMESITE_ORIGIN
}
/
fetch
/
api
/
resources
/
keepalive
-
redirect
-
window
.
html
?
+
origin1
=
{
origin1
}
&
+
origin2
=
{
origin2
}
&
+
url2
=
{
url2
}
&
+
(
withPreflight
?
with
-
headers
:
)
;
const
w
=
window
.
open
(
targetUrl
)
;
const
token
=
await
getTokenFromMessage
(
)
;
w
.
close
(
)
;
assertStashedTokenAsync
(
desc
token
{
expectTokenExist
:
expectFetchSucceed
}
)
;
}
{
desc
}
;
setting
up
)
;
}
function
createPendingKeepAliveRequest
(
delay
remote
=
false
)
{
const
trickleRemoteURL
=
get_host_info
(
)
.
HTTPS_REMOTE_ORIGIN
+
'
/
fetch
/
api
/
resources
/
trickle
.
py
?
count
=
1
&
ms
=
'
;
const
trickleLocalURL
=
get_host_info
(
)
.
HTTP_ORIGIN
+
'
/
fetch
/
api
/
resources
/
trickle
.
py
?
count
=
1
&
ms
=
'
;
url
=
remote
?
trickleRemoteURL
:
trickleLocalURL
;
const
body
=
'
*
'
.
repeat
(
10
)
;
return
fetch
(
url
+
delay
{
keepalive
:
true
body
method
:
'
POST
'
}
)
.
then
(
res
=
>
{
return
res
.
text
(
)
;
}
)
.
then
(
(
)
=
>
{
return
new
Promise
(
resolve
=
>
step_timeout
(
resolve
1
)
)
;
}
)
.
catch
(
(
error
)
=
>
{
return
Promise
.
reject
(
error
)
;
;
}
)
}
