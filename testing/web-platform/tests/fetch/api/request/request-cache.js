var
now
=
new
Date
(
)
;
function
base_path
(
)
{
return
location
.
pathname
.
replace
(
/
\
/
[
^
\
/
]
*
/
'
/
'
)
;
}
function
make_url
(
uuid
id
value
content
info
)
{
var
dates
=
{
fresh
:
new
Date
(
now
.
getFullYear
(
)
+
1
now
.
getMonth
(
)
now
.
getDay
(
)
)
.
toGMTString
(
)
stale
:
new
Date
(
now
.
getFullYear
(
)
-
1
now
.
getMonth
(
)
now
.
getDay
(
)
)
.
toGMTString
(
)
}
;
var
vary
=
"
"
;
if
(
"
vary
"
in
info
)
{
vary
=
"
&
vary
=
"
+
info
.
vary
;
}
var
cache_control
=
"
"
;
if
(
"
cache_control
"
in
info
)
{
cache_control
=
"
&
cache_control
=
"
+
info
.
cache_control
;
}
var
redirect
=
"
"
;
var
ignore_request_headers
=
"
"
;
if
(
"
request_headers
"
in
info
)
{
ignore_request_headers
=
"
&
ignore
"
;
}
var
url_sans_redirect
=
"
resources
/
cache
.
py
?
token
=
"
+
uuid
+
"
&
content
=
"
+
content
+
"
&
"
+
id
+
"
=
"
+
value
+
"
&
expires
=
"
+
dates
[
info
.
state
]
+
vary
+
cache_control
+
ignore_request_headers
;
if
(
"
redirect
"
in
info
)
{
var
host_info
=
get_host_info
(
)
;
var
origin
;
switch
(
info
.
redirect
)
{
case
"
same
-
origin
"
:
origin
=
host_info
[
'
HTTP_ORIGIN
'
]
;
break
;
case
"
cross
-
origin
"
:
origin
=
host_info
[
'
HTTP_REMOTE_ORIGIN
'
]
;
break
;
}
var
redirected_url
=
origin
+
base_path
(
)
+
url_sans_redirect
;
return
url_sans_redirect
+
"
&
redirect
=
"
+
encodeURIComponent
(
redirected_url
)
;
}
else
{
return
url_sans_redirect
;
}
}
function
expected_status
(
type
identifier
init
)
{
if
(
type
=
=
"
date
"
&
&
init
.
headers
&
&
init
.
headers
[
"
If
-
Modified
-
Since
"
]
=
=
identifier
)
{
return
[
304
"
Not
Modified
"
]
;
}
return
[
200
"
OK
"
]
;
}
function
expected_response_text
(
type
identifier
init
content
)
{
if
(
type
=
=
"
date
"
&
&
init
.
headers
&
&
init
.
headers
[
"
If
-
Modified
-
Since
"
]
=
=
identifier
)
{
return
"
"
;
}
return
content
;
}
function
server_state
(
uuid
)
{
return
fetch
(
"
resources
/
cache
.
py
?
querystate
&
token
=
"
+
uuid
)
.
then
(
function
(
response
)
{
return
response
.
text
(
)
;
}
)
.
then
(
function
(
text
)
{
return
JSON
.
parse
(
text
)
|
|
[
]
;
}
)
;
}
function
make_test
(
type
info
)
{
return
function
(
test
)
{
var
uuid
=
token
(
)
;
var
identifier
=
(
type
=
=
"
tag
"
?
Math
.
random
(
)
:
now
.
toGMTString
(
)
)
;
var
content
=
Math
.
random
(
)
.
toString
(
)
;
var
url
=
make_url
(
uuid
type
identifier
content
info
)
;
var
fetch_functions
=
[
]
;
for
(
var
i
=
0
;
i
<
info
.
request_cache
.
length
;
+
+
i
)
{
fetch_functions
.
push
(
function
(
idx
)
{
var
init
=
{
cache
:
info
.
request_cache
[
idx
]
}
;
if
(
"
request_headers
"
in
info
)
{
init
.
headers
=
info
.
request_headers
[
idx
]
;
}
if
(
init
.
cache
=
=
=
"
only
-
if
-
cached
"
)
{
init
.
mode
=
"
same
-
origin
"
;
}
return
fetch
(
url
init
)
.
then
(
function
(
response
)
{
if
(
"
response
"
in
info
&
&
info
.
response
[
idx
]
=
=
=
"
error
"
)
{
assert_true
(
false
"
fetch
should
have
been
an
error
"
)
;
return
;
}
assert_array_equals
(
[
response
.
status
response
.
statusText
]
expected_status
(
type
identifier
init
)
)
;
return
response
.
text
(
)
;
}
)
.
then
(
function
(
text
)
{
assert_equals
(
text
expected_response_text
(
type
identifier
init
content
)
)
;
}
function
(
reason
)
{
if
(
"
response
"
in
info
&
&
info
.
response
[
idx
]
=
=
=
"
error
"
)
{
assert_throws_js
(
TypeError
function
(
)
{
throw
reason
;
}
)
;
}
else
{
throw
reason
;
}
}
)
;
}
)
;
}
var
i
=
0
;
function
run_next_step
(
)
{
if
(
fetch_functions
.
length
)
{
return
fetch_functions
.
shift
(
)
(
i
+
+
)
.
then
(
run_next_step
)
;
}
else
{
return
Promise
.
resolve
(
)
;
}
}
return
run_next_step
(
)
.
then
(
function
(
)
{
return
server_state
(
uuid
)
;
}
)
.
then
(
function
(
state
)
{
var
expectedState
=
[
]
;
info
.
expected_validation_headers
.
forEach
(
function
(
validate
)
{
if
(
validate
)
{
if
(
type
=
=
"
tag
"
)
{
expectedState
.
push
(
{
"
If
-
None
-
Match
"
:
'
"
'
+
identifier
+
'
"
'
}
)
;
}
else
{
expectedState
.
push
(
{
"
If
-
Modified
-
Since
"
:
identifier
}
)
;
}
}
else
{
expectedState
.
push
(
{
}
)
;
}
}
)
;
for
(
var
i
=
0
;
i
<
info
.
expected_no_cache_headers
.
length
;
+
+
i
)
{
if
(
info
.
expected_no_cache_headers
[
i
]
)
{
expectedState
[
i
]
[
"
Pragma
"
]
=
"
no
-
cache
"
;
expectedState
[
i
]
[
"
Cache
-
Control
"
]
=
"
no
-
cache
"
;
}
}
if
(
"
expected_max_age_headers
"
in
info
)
{
for
(
var
i
=
0
;
i
<
info
.
expected_max_age_headers
.
length
;
+
+
i
)
{
if
(
info
.
expected_max_age_headers
[
i
]
)
{
expectedState
[
i
]
[
"
Cache
-
Control
"
]
=
"
max
-
age
=
0
"
;
}
}
}
assert_equals
(
state
.
length
expectedState
.
length
)
;
for
(
var
i
=
0
;
i
<
state
.
length
;
+
+
i
)
{
for
(
var
header
in
state
[
i
]
)
{
assert_equals
(
state
[
i
]
[
header
]
expectedState
[
i
]
[
header
]
)
;
delete
expectedState
[
i
]
[
header
]
;
}
for
(
var
header
in
expectedState
[
i
]
)
{
assert_false
(
header
in
state
[
i
]
)
;
}
}
}
)
;
}
;
}
function
run_tests
(
tests
)
{
tests
.
forEach
(
function
(
info
)
{
promise_test
(
make_test
(
"
tag
"
info
)
info
.
name
+
"
with
Etag
and
"
+
info
.
state
+
"
response
"
)
;
promise_test
(
make_test
(
"
date
"
info
)
info
.
name
+
"
with
Last
-
Modified
and
"
+
info
.
state
+
"
response
"
)
;
}
)
;
}
