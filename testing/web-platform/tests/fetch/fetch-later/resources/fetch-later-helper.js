'
use
strict
'
;
const
ROOT_NAME
=
'
fetch
/
fetch
-
later
'
;
function
parallelPromiseTest
(
func
description
)
{
async_test
(
(
t
)
=
>
{
Promise
.
resolve
(
func
(
t
)
)
.
then
(
(
)
=
>
t
.
done
(
)
)
.
catch
(
t
.
step_func
(
(
e
)
=
>
{
throw
e
;
}
)
)
;
}
description
)
;
}
const
BeaconDataType
=
{
String
:
'
String
'
ArrayBuffer
:
'
ArrayBuffer
'
FormData
:
'
FormData
'
URLSearchParams
:
'
URLSearchParams
'
Blob
:
'
Blob
'
File
:
'
File
'
}
;
const
BeaconDataTypeToSkipCharset
=
{
String
:
'
'
ArrayBuffer
:
'
'
FormData
:
'
\
n
\
r
'
URLSearchParams
:
'
;
/
?
:
&
=
+
'
Blob
:
'
'
File
:
'
'
}
;
const
BEACON_PAYLOAD_KEY
=
'
payload
'
;
function
makeBeaconData
(
data
dataType
contentType
)
{
switch
(
dataType
)
{
case
BeaconDataType
.
String
:
return
data
;
case
BeaconDataType
.
ArrayBuffer
:
return
new
TextEncoder
(
)
.
encode
(
data
)
.
buffer
;
case
BeaconDataType
.
FormData
:
const
formData
=
new
FormData
(
)
;
if
(
data
.
length
>
0
)
{
formData
.
append
(
BEACON_PAYLOAD_KEY
data
)
;
}
return
formData
;
case
BeaconDataType
.
URLSearchParams
:
if
(
data
.
length
>
0
)
{
return
new
URLSearchParams
(
{
BEACON_PAYLOAD_KEY
}
=
{
data
}
)
;
}
return
new
URLSearchParams
(
)
;
case
BeaconDataType
.
Blob
:
{
const
options
=
{
type
:
contentType
|
|
undefined
}
;
return
new
Blob
(
[
data
]
options
)
;
}
case
BeaconDataType
.
File
:
{
const
options
=
{
type
:
contentType
|
|
'
text
/
plain
'
}
;
return
new
File
(
[
data
]
'
file
.
txt
'
options
)
;
}
default
:
throw
Error
(
Unsupported
beacon
dataType
:
{
dataType
}
)
;
}
}
function
generateSequentialData
(
begin
end
skip
)
{
const
codeUnits
=
Array
(
end
-
begin
)
.
fill
(
)
.
map
(
(
el
i
)
=
>
i
+
begin
)
;
if
(
skip
)
{
return
String
.
fromCharCode
(
.
.
.
codeUnits
.
filter
(
c
=
>
!
skip
.
includes
(
String
.
fromCharCode
(
c
)
)
)
)
;
}
return
String
.
fromCharCode
(
.
.
.
codeUnits
)
;
}
function
generatePayload
(
size
)
{
if
(
size
=
=
0
)
{
return
'
'
;
}
const
prefix
=
String
(
size
)
+
'
:
'
;
if
(
size
<
prefix
.
length
)
{
return
Array
(
size
)
.
fill
(
'
*
'
)
.
join
(
'
'
)
;
}
if
(
size
=
=
prefix
.
length
)
{
return
prefix
;
}
return
prefix
+
Array
(
size
-
prefix
.
length
)
.
fill
(
'
*
'
)
.
join
(
'
'
)
;
}
function
generateSetBeaconURL
(
uuid
options
)
{
const
host
=
(
options
&
&
options
.
host
)
|
|
'
'
;
let
url
=
{
host
}
/
{
ROOT_NAME
}
/
resources
/
set_beacon
.
py
?
uuid
=
{
uuid
}
;
if
(
options
)
{
if
(
options
.
expectOrigin
!
=
=
undefined
)
{
url
=
{
url
}
&
expectOrigin
=
{
options
.
expectOrigin
}
;
}
if
(
options
.
expectPreflight
!
=
=
undefined
)
{
url
=
{
url
}
&
expectPreflight
=
{
options
.
expectPreflight
}
;
}
if
(
options
.
expectCredentials
!
=
=
undefined
)
{
url
=
{
url
}
&
expectCredentials
=
{
options
.
expectCredentials
}
;
}
if
(
options
.
useRedirectHandler
)
{
const
redirect
=
{
host
}
/
common
/
redirect
.
py
+
?
location
=
{
encodeURIComponent
(
url
)
}
;
url
=
redirect
;
}
}
return
url
;
}
async
function
poll
(
asyncFunc
expected
)
{
const
maxRetries
=
30
;
const
waitInterval
=
100
;
const
delay
=
ms
=
>
new
Promise
(
res
=
>
setTimeout
(
res
ms
)
)
;
let
result
=
{
data
:
[
]
}
;
for
(
let
i
=
0
;
i
<
maxRetries
;
i
+
+
)
{
result
=
await
asyncFunc
(
)
;
if
(
!
expected
(
result
)
)
{
await
delay
(
waitInterval
)
;
continue
;
}
return
result
;
}
return
result
;
}
async
function
expectBeacon
(
uuid
options
)
{
const
expectedCount
=
(
options
&
&
options
.
count
!
=
=
undefined
)
?
options
.
count
:
1
;
const
res
=
await
poll
(
async
(
)
=
>
{
const
res
=
await
fetch
(
/
{
ROOT_NAME
}
/
resources
/
get_beacon
.
py
?
uuid
=
{
uuid
}
{
cache
:
'
no
-
store
'
}
)
;
return
await
res
.
json
(
)
;
}
(
res
)
=
>
{
if
(
expectedCount
=
=
0
)
{
return
false
;
}
return
res
.
data
.
length
=
=
expectedCount
;
}
)
;
if
(
!
options
|
|
!
options
.
data
)
{
assert_equals
(
res
.
data
.
length
expectedCount
'
Number
of
sent
beacons
does
not
match
expected
count
:
'
)
;
return
;
}
if
(
expectedCount
=
=
0
)
{
assert_equals
(
res
.
data
.
length
0
'
Number
of
sent
beacons
does
not
match
expected
count
:
'
)
;
return
;
}
const
decoder
=
options
&
&
options
.
percentDecoded
?
(
s
)
=
>
{
s
=
s
.
replace
(
/
\
+
/
g
'
%
20
'
)
;
return
decodeURIComponent
(
s
)
;
}
:
(
s
)
=
>
s
;
assert_equals
(
res
.
data
.
length
options
.
data
.
length
The
size
of
beacon
data
{
res
.
data
.
length
}
from
server
does
not
match
expected
value
{
options
.
data
.
length
}
.
)
;
for
(
let
i
=
0
;
i
<
options
.
data
.
length
;
i
+
+
)
{
assert_equals
(
decoder
(
res
.
data
[
i
]
)
options
.
data
[
i
]
'
The
beacon
data
does
not
match
expected
value
.
'
)
;
}
}
function
generateHTML
(
script
)
{
return
<
!
DOCTYPE
html
>
<
body
>
<
script
>
{
script
}
<
/
script
>
<
/
body
>
;
}
async
function
loadScriptAsIframe
(
script
)
{
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
srcdoc
=
generateHTML
(
script
)
;
const
iframeLoaded
=
new
Promise
(
resolve
=
>
iframe
.
onload
=
resolve
)
;
document
.
body
.
appendChild
(
iframe
)
;
await
iframeLoaded
;
return
iframe
;
}
async
function
expectFetchLater
(
init
{
targetUrl
=
undefined
uuid
=
undefined
}
=
{
}
)
{
if
(
(
targetUrl
&
&
!
uuid
)
|
|
(
!
targetUrl
&
&
uuid
)
)
{
throw
new
Error
(
'
uuid
and
targetUrl
must
be
provided
together
.
'
)
;
}
if
(
uuid
&
&
targetUrl
&
&
!
targetUrl
.
includes
(
uuid
)
)
{
throw
new
Error
(
Conflicting
uuid
=
{
uuid
}
is
provided
:
must
also
be
included
in
the
targetUrl
{
targetUrl
}
)
;
}
if
(
!
uuid
)
{
uuid
=
token
(
)
;
}
if
(
!
targetUrl
)
{
targetUrl
=
generateSetBeaconURL
(
uuid
)
;
}
fetchLater
(
targetUrl
init
)
;
await
expectBeacon
(
uuid
{
count
:
1
}
)
;
}
async
function
loadElement
(
el
)
{
const
loaded
=
new
Promise
(
resolve
=
>
el
.
onload
=
resolve
)
;
document
.
body
.
appendChild
(
el
)
;
await
loaded
;
}
class
FetchLaterIframeOptions
{
constructor
(
)
{
this
.
targetUrl
;
this
.
uuid
;
this
.
activateAfter
;
this
.
method
;
this
.
referrer
;
this
.
bodyType
;
this
.
bodySize
;
this
.
allowDeferredFetch
;
this
.
sandbox
;
this
.
expect
;
}
}
const
FetchLaterIframeMessageType
=
{
DONE
:
'
fetchLater
.
done
'
ERROR
:
'
fetchLater
.
error
'
}
;
const
FetchLaterExpectationType
=
{
DONE
:
0
ERROR_JS
:
1
ERROR_DOM
:
2
}
;
class
FetchLaterExpectationError
extends
Error
{
constructor
(
src
actual
expected
)
{
const
message
=
iframe
[
src
=
{
src
}
]
threw
{
actual
}
expected
{
expected
}
;
super
(
message
)
;
}
}
class
FetchLaterIframeExpectation
{
constructor
(
expectationType
expectedError
)
{
this
.
expectationType
=
expectationType
;
if
(
expectationType
=
=
FetchLaterExpectationType
.
DONE
&
&
!
expectedError
)
{
this
.
expectedErrorType
=
undefined
;
}
else
if
(
expectationType
=
=
FetchLaterExpectationType
.
ERROR_JS
&
&
typeof
expectedError
=
=
'
function
'
)
{
this
.
expectedErrorType
=
expectedError
;
}
else
if
(
expectationType
=
=
FetchLaterExpectationType
.
ERROR_DOM
&
&
typeof
expectedError
=
=
'
string
'
)
{
this
.
expectedDomErrorName
=
expectedError
;
}
else
{
throw
Error
(
Expectation
type
"
{
expectationType
}
"
and
expected
error
"
{
expectedError
}
"
do
not
match
)
;
}
}
run
(
e
url
)
{
if
(
this
.
expectationType
=
=
=
FetchLaterExpectationType
.
DONE
)
{
if
(
e
.
data
.
type
=
=
=
FetchLaterIframeMessageType
.
DONE
)
{
return
true
;
}
if
(
e
.
data
.
type
=
=
=
FetchLaterIframeMessageType
.
ERROR
&
&
e
.
data
.
error
!
=
=
undefined
)
{
throw
new
FetchLaterExpectationError
(
url
e
.
data
.
error
.
name
'
no
error
'
)
;
}
}
if
(
this
.
expectationType
=
=
=
FetchLaterExpectationType
.
ERROR_JS
)
{
if
(
e
.
data
.
type
=
=
=
FetchLaterIframeMessageType
.
DONE
)
{
throw
new
FetchLaterExpectationError
(
url
'
nothing
'
this
.
expectedErrorType
.
name
)
;
}
if
(
e
.
data
.
type
=
=
=
FetchLaterIframeMessageType
.
ERROR
)
{
if
(
e
.
data
.
error
.
constructor
=
=
=
this
.
expectedErrorType
&
&
e
.
data
.
error
.
name
=
=
=
this
.
expectedErrorType
.
name
)
{
return
true
;
}
throw
new
FetchLaterExpectationError
(
url
e
.
data
.
error
this
.
expectedErrorType
.
name
)
;
}
}
if
(
this
.
expectationType
=
=
=
FetchLaterExpectationType
.
ERROR_DOM
)
{
if
(
e
.
data
.
type
=
=
=
FetchLaterIframeMessageType
.
DONE
)
{
throw
new
FetchLaterExpectationError
(
url
'
nothing
'
this
.
expectedDomErrorName
)
;
}
if
(
e
.
data
.
type
=
=
=
FetchLaterIframeMessageType
.
ERROR
)
{
const
actual
=
e
.
data
.
error
.
name
|
|
e
.
data
.
error
.
type
;
if
(
this
.
expectedDomErrorName
=
=
=
'
QuotaExceededError
'
)
{
return
actual
=
=
this
.
expectedDomErrorName
;
}
else
if
(
e
.
data
.
error
.
constructor
.
name
=
=
=
'
DOMException
'
&
&
actual
=
=
this
.
expectedDomErrorName
)
{
return
true
;
}
throw
new
FetchLaterExpectationError
(
url
actual
this
.
expectedDomErrorName
)
;
}
}
return
false
;
}
}
async
function
loadFetchLaterIframe
(
origin
{
targetUrl
=
undefined
uuid
=
undefined
activateAfter
=
undefined
referrer
=
undefined
method
=
undefined
bodyType
=
undefined
bodySize
=
undefined
allowDeferredFetch
=
false
sandbox
=
undefined
expect
=
undefined
}
=
{
}
)
{
if
(
uuid
&
&
targetUrl
&
&
!
targetUrl
.
includes
(
uuid
)
)
{
throw
new
Error
(
Conflicted
uuid
=
{
uuid
}
is
provided
:
must
also
be
included
in
the
targetUrl
{
targetUrl
}
)
;
}
if
(
!
uuid
)
{
uuid
=
targetUrl
?
undefined
:
token
(
)
;
}
targetUrl
=
targetUrl
|
|
generateSetBeaconURL
(
uuid
)
;
const
params
=
new
URLSearchParams
(
Object
.
assign
(
{
}
{
url
:
encodeURIComponent
(
targetUrl
)
}
activateAfter
!
=
=
undefined
?
{
activateAfter
}
:
null
referrer
!
=
=
undefined
?
{
referrer
}
:
null
method
!
=
=
undefined
?
{
method
}
:
null
bodyType
!
=
=
undefined
?
{
bodyType
}
:
null
bodySize
!
=
=
undefined
?
{
bodySize
}
:
null
)
)
;
const
url
=
{
origin
}
/
fetch
/
fetch
-
later
/
resources
/
fetch
-
later
.
html
?
{
params
}
;
expect
=
expect
|
|
new
FetchLaterIframeExpectation
(
FetchLaterExpectationType
.
DONE
)
;
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
if
(
allowDeferredFetch
)
{
iframe
.
allow
=
'
deferred
-
fetch
'
;
}
if
(
sandbox
)
{
iframe
.
sandbox
=
sandbox
;
}
iframe
.
src
=
url
;
const
messageReceived
=
new
Promise
(
(
resolve
reject
)
=
>
{
addEventListener
(
'
message
'
function
handler
(
e
)
{
if
(
e
.
source
!
=
=
iframe
.
contentWindow
)
{
return
;
}
try
{
if
(
expect
.
run
(
e
url
)
)
{
removeEventListener
(
'
message
'
handler
)
;
resolve
(
e
.
data
.
type
)
;
}
}
catch
(
err
)
{
reject
(
err
)
;
}
}
)
;
}
)
;
await
loadElement
(
iframe
)
;
const
messageType
=
await
messageReceived
;
if
(
messageType
=
=
=
FetchLaterIframeMessageType
.
DONE
&
&
uuid
)
{
await
expectBeacon
(
uuid
{
count
:
1
}
)
;
}
return
iframe
;
}
