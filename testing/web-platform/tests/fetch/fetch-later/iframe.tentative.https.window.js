'
use
strict
'
;
const
{
HTTPS_ORIGIN
HTTPS_NOTSAMESITE_ORIGIN
}
=
get_host_info
(
)
;
async
function
loadElement
(
el
)
{
const
loaded
=
new
Promise
(
resolve
=
>
el
.
onload
=
resolve
)
;
document
.
body
.
appendChild
(
el
)
;
await
loaded
;
}
async
function
loadFetchLaterIframe
(
host
targetUrl
)
{
const
url
=
{
host
}
/
fetch
/
fetch
-
later
/
resources
/
fetch
-
later
.
html
?
url
=
{
encodeURIComponent
(
targetUrl
)
}
;
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
src
=
url
;
await
loadElement
(
iframe
)
;
return
iframe
;
}
parallelPromiseTest
(
async
t
=
>
{
const
uuid
=
token
(
)
;
const
url
=
generateSetBeaconURL
(
uuid
)
;
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
addEventListener
(
'
load
'
(
)
=
>
{
fetchLater
(
url
{
activateAfter
:
0
}
)
;
}
)
;
await
loadElement
(
iframe
)
;
await
expectBeacon
(
uuid
{
count
:
1
}
)
;
}
'
A
blank
iframe
can
trigger
fetchLater
.
'
)
;
parallelPromiseTest
(
async
t
=
>
{
const
uuid
=
token
(
)
;
const
url
=
generateSetBeaconURL
(
uuid
)
;
await
loadFetchLaterIframe
(
HTTPS_ORIGIN
url
)
;
await
expectBeacon
(
uuid
{
count
:
1
}
)
;
}
'
A
same
-
origin
iframe
can
trigger
fetchLater
.
'
)
;
parallelPromiseTest
(
async
t
=
>
{
const
uuid
=
token
(
)
;
const
url
=
generateSetBeaconURL
(
uuid
)
;
await
loadFetchLaterIframe
(
HTTPS_NOTSAMESITE_ORIGIN
url
)
;
await
expectBeacon
(
uuid
{
count
:
1
}
)
;
}
'
A
cross
-
origin
iframe
can
trigger
fetchLater
.
'
)
;
