setup
(
(
)
=
>
{
assert_true
(
window
.
isSecureContext
)
;
}
)
;
function
otherAddressSpaces
(
addressSpace
)
{
switch
(
addressSpace
)
{
case
"
loopback
"
:
return
[
"
unknown
"
"
local
"
"
public
"
]
;
case
"
local
"
:
return
[
"
unknown
"
"
loopback
"
"
public
"
]
;
case
"
public
"
:
return
[
"
unknown
"
"
loopback
"
"
local
"
]
;
}
}
function
makeTests
(
{
source
target
}
)
{
const
sourceServer
=
Server
.
get
(
"
https
"
source
)
;
const
targetServer
=
Server
.
get
(
"
http
"
target
)
;
const
makeTest
=
(
{
fetchOptions
targetBehavior
name
expected
}
)
=
>
{
promise_test_parallel
(
t
=
>
fetchTest
(
t
{
source
:
{
server
:
sourceServer
}
target
:
{
server
:
targetServer
behavior
:
targetBehavior
}
fetchOptions
expected
}
)
{
sourceServer
.
name
}
to
{
targetServer
.
name
}
:
{
name
}
.
)
;
}
;
makeTest
(
{
name
:
"
missing
targetAddressSpace
"
targetBehavior
:
{
preflight
:
PreflightBehavior
.
success
(
token
(
)
)
response
:
ResponseBehavior
.
allowCrossOrigin
(
)
}
expected
:
FetchTestResult
.
FAILURE
}
)
;
const
correctAddressSpace
=
targetServer
.
addressSpace
;
for
(
const
targetAddressSpace
of
otherAddressSpaces
(
correctAddressSpace
)
)
{
makeTest
(
{
name
:
wrong
targetAddressSpace
"
{
targetAddressSpace
}
"
targetBehavior
:
{
preflight
:
PreflightBehavior
.
success
(
token
(
)
)
response
:
ResponseBehavior
.
allowCrossOrigin
(
)
}
fetchOptions
:
{
targetAddressSpace
}
expected
:
FetchTestResult
.
FAILURE
}
)
;
}
makeTest
(
{
name
:
"
failed
preflight
"
targetBehavior
:
{
preflight
:
PreflightBehavior
.
failure
(
)
response
:
ResponseBehavior
.
allowCrossOrigin
(
)
}
fetchOptions
:
{
targetAddressSpace
:
correctAddressSpace
}
expected
:
FetchTestResult
.
FAILURE
}
)
;
makeTest
(
{
name
:
"
success
"
targetBehavior
:
{
preflight
:
PreflightBehavior
.
success
(
token
(
)
)
response
:
ResponseBehavior
.
allowCrossOrigin
(
)
}
fetchOptions
:
{
targetAddressSpace
:
correctAddressSpace
}
expected
:
FetchTestResult
.
SUCCESS
}
)
;
makeTest
(
{
name
:
"
PUT
success
"
targetBehavior
:
{
preflight
:
PreflightBehavior
.
success
(
token
(
)
)
response
:
ResponseBehavior
.
allowCrossOrigin
(
)
}
fetchOptions
:
{
targetAddressSpace
:
correctAddressSpace
method
:
"
PUT
"
}
expected
:
FetchTestResult
.
SUCCESS
}
)
;
makeTest
(
{
name
:
"
no
-
cors
success
"
targetBehavior
:
{
preflight
:
PreflightBehavior
.
success
(
token
(
)
)
response
:
ResponseBehavior
.
allowCrossOrigin
(
)
}
fetchOptions
:
{
targetAddressSpace
:
correctAddressSpace
mode
:
"
no
-
cors
"
}
expected
:
FetchTestResult
.
OPAQUE
}
)
;
}
function
makeNoBypassTests
(
{
source
target
}
)
{
const
sourceServer
=
Server
.
get
(
"
https
"
source
)
;
const
targetServer
=
Server
.
get
(
"
http
"
target
)
;
const
prefix
=
{
sourceServer
.
name
}
to
{
targetServer
.
name
}
:
;
const
correctAddressSpace
=
targetServer
.
addressSpace
;
for
(
const
targetAddressSpace
of
otherAddressSpaces
(
correctAddressSpace
)
)
{
promise_test_parallel
(
t
=
>
fetchTest
(
t
{
source
:
{
server
:
sourceServer
}
target
:
{
server
:
targetServer
behavior
:
{
preflight
:
PreflightBehavior
.
success
(
token
(
)
)
response
:
ResponseBehavior
.
allowCrossOrigin
(
)
}
}
fetchOptions
:
{
targetAddressSpace
}
expected
:
FetchTestResult
.
FAILURE
}
)
prefix
+
wrong
targetAddressSpace
"
{
targetAddressSpace
}
"
.
)
;
}
promise_test_parallel
(
t
=
>
fetchTest
(
t
{
source
:
{
server
:
sourceServer
}
target
:
{
server
:
targetServer
behavior
:
{
preflight
:
PreflightBehavior
.
success
(
token
(
)
)
response
:
ResponseBehavior
.
allowCrossOrigin
(
)
}
}
fetchOptions
:
{
targetAddressSpace
:
correctAddressSpace
}
expected
:
FetchTestResult
.
FAILURE
}
)
prefix
+
'
not
a
local
network
request
.
'
)
;
}
makeNoBypassTests
(
{
source
:
"
loopback
"
target
:
"
loopback
"
}
)
;
makeNoBypassTests
(
{
source
:
"
loopback
"
target
:
"
local
"
}
)
;
makeNoBypassTests
(
{
source
:
"
loopback
"
target
:
"
public
"
}
)
;
makeTests
(
{
source
:
"
local
"
target
:
"
loopback
"
}
)
;
makeNoBypassTests
(
{
source
:
"
local
"
target
:
"
local
"
}
)
;
makeNoBypassTests
(
{
source
:
"
local
"
target
:
"
public
"
}
)
;
makeTests
(
{
source
:
"
public
"
target
:
"
loopback
"
}
)
;
makeTests
(
{
source
:
"
public
"
target
:
"
local
"
}
)
;
makeNoBypassTests
(
{
source
:
"
public
"
target
:
"
public
"
}
)
;
promise_test_parallel
(
t
=
>
fetchTest
(
t
{
source
:
{
server
:
Server
.
HTTPS_LOCAL
treatAsPublic
:
true
}
target
:
{
server
:
Server
.
HTTP_LOCAL
behavior
:
{
preflight
:
PreflightBehavior
.
optionalSuccess
(
token
(
)
)
response
:
ResponseBehavior
.
allowCrossOrigin
(
)
}
}
fetchOptions
:
{
targetAddressSpace
:
'
local
'
}
expected
:
FetchTestResult
.
FAILURE
}
)
'
https
-
treat
-
as
-
public
to
http
-
loopback
:
wrong
targetAddressSpace
"
local
"
.
'
)
;
promise_test_parallel
(
t
=
>
fetchTest
(
t
{
source
:
{
server
:
Server
.
HTTPS_LOCAL
treatAsPublic
:
true
}
target
:
{
server
:
Server
.
HTTP_LOCAL
behavior
:
{
preflight
:
PreflightBehavior
.
optionalSuccess
(
token
(
)
)
response
:
ResponseBehavior
.
allowCrossOrigin
(
)
}
}
fetchOptions
:
{
targetAddressSpace
:
"
loopback
"
}
expected
:
FetchTestResult
.
SUCCESS
}
)
"
https
-
treat
-
as
-
public
to
http
-
loopback
:
success
.
"
)
;
promise_test_parallel
(
t
=
>
fetchTest
(
t
{
source
:
{
server
:
Server
.
HTTPS_LOCAL
treatAsPublic
:
true
}
target
:
{
server
:
Server
.
HTTP_PRIVATE
behavior
:
{
preflight
:
PreflightBehavior
.
success
(
token
(
)
)
response
:
ResponseBehavior
.
allowCrossOrigin
(
)
}
}
fetchOptions
:
{
targetAddressSpace
:
"
loopback
"
}
expected
:
FetchTestResult
.
FAILURE
}
)
'
https
-
treat
-
as
-
public
to
http
-
local
:
wrong
targetAddressSpace
"
loopback
"
.
'
)
;
promise_test_parallel
(
t
=
>
fetchTest
(
t
{
source
:
{
server
:
Server
.
HTTPS_LOCAL
treatAsPublic
:
true
}
target
:
{
server
:
Server
.
HTTP_PRIVATE
behavior
:
{
preflight
:
PreflightBehavior
.
success
(
token
(
)
)
response
:
ResponseBehavior
.
allowCrossOrigin
(
)
}
}
fetchOptions
:
{
targetAddressSpace
:
"
local
"
}
expected
:
FetchTestResult
.
SUCCESS
}
)
"
https
-
treat
-
as
-
public
to
http
-
local
:
success
.
"
)
;
