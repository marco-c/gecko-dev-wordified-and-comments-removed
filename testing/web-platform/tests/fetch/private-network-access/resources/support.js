function
appendIframeWith
(
t
doc
func
)
{
return
new
Promise
(
resolve
=
>
{
const
child
=
doc
.
createElement
(
"
iframe
"
)
;
func
(
child
)
;
child
.
onload
=
(
)
=
>
{
resolve
(
child
)
;
}
;
doc
.
body
.
appendChild
(
child
)
;
t
.
add_cleanup
(
(
)
=
>
{
doc
.
body
.
removeChild
(
child
)
;
}
)
;
}
)
;
}
function
appendIframe
(
t
doc
src
)
{
return
appendIframeWith
(
t
doc
child
=
>
{
child
.
src
=
src
;
}
)
;
}
function
futureMessage
(
)
{
return
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
"
message
"
e
=
>
resolve
(
e
.
data
)
)
;
}
)
;
}
;
function
resolveUrl
(
url
options
)
{
const
result
=
new
URL
(
url
window
.
location
)
;
if
(
options
=
=
=
undefined
)
{
return
result
;
}
const
{
port
protocol
}
=
options
;
if
(
port
!
=
=
undefined
)
{
result
.
port
=
port
;
}
if
(
protocol
!
=
=
undefined
)
{
result
.
protocol
=
protocol
;
}
return
result
;
}
const
kDefaultSourcePath
=
"
resources
/
fetcher
.
html
"
;
const
kTreatAsPublicAddressSuffix
=
"
?
pipe
=
header
(
Content
-
Security
-
Policy
treat
-
as
-
public
-
address
)
"
;
function
sourceUrl
(
{
protocol
port
treatAsPublicAddress
}
)
{
let
path
=
kDefaultSourcePath
;
if
(
treatAsPublicAddress
)
{
path
+
=
kTreatAsPublicAddressSuffix
;
}
return
resolveUrl
(
path
{
protocol
port
}
)
;
}
const
kFetchTestResult
=
{
success
:
true
failure
:
"
TypeError
:
Failed
to
fetch
"
}
async
function
fetchTest
(
t
{
source
target
expected
}
)
{
if
(
source
=
=
=
undefined
)
{
source
=
{
}
;
}
const
iframe
=
await
appendIframe
(
t
document
sourceUrl
(
source
)
)
;
const
targetUrl
=
resolveUrl
(
"
/
common
/
blank
-
with
-
cors
.
html
"
target
)
;
const
reply
=
futureMessage
(
)
;
iframe
.
contentWindow
.
postMessage
(
targetUrl
.
href
"
*
"
)
;
assert_equals
(
await
reply
expected
)
;
}
