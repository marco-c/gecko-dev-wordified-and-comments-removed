function
appendIframeWith
(
t
doc
func
)
{
return
new
Promise
(
resolve
=
>
{
const
child
=
doc
.
createElement
(
"
iframe
"
)
;
t
.
add_cleanup
(
(
)
=
>
child
.
remove
(
)
)
;
child
.
addEventListener
(
"
load
"
(
)
=
>
resolve
(
child
)
{
once
:
true
}
)
;
func
(
child
)
;
doc
.
body
.
appendChild
(
child
)
;
}
)
;
}
function
appendIframe
(
t
doc
src
)
{
return
appendIframeWith
(
t
doc
child
=
>
{
child
.
src
=
src
;
}
)
;
}
function
futureMessage
(
options
)
{
return
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
"
message
"
(
e
)
=
>
{
if
(
options
?
.
source
&
&
options
.
source
!
=
=
e
.
source
)
{
return
;
}
if
(
options
?
.
filter
&
&
!
options
.
filter
(
e
.
data
)
)
{
return
;
}
resolve
(
e
.
data
)
;
}
)
;
}
)
;
}
;
function
promise_test_parallel
(
promise
description
)
{
async_test
(
test
=
>
{
promise
(
test
)
.
then
(
(
)
=
>
test
.
done
(
)
)
.
catch
(
test
.
step_func
(
error
=
>
{
throw
error
;
}
)
)
;
}
description
)
;
}
;
async
function
postMessageAndAwaitReply
(
target
message
)
{
const
reply
=
futureMessage
(
{
source
:
target
}
)
;
target
.
postMessage
(
message
"
*
"
)
;
return
await
reply
;
}
const
SERVER_PORTS
=
{
"
http
"
:
{
"
local
"
:
{
{
ports
[
http
]
[
0
]
}
}
"
private
"
:
{
{
ports
[
http
-
private
]
[
0
]
}
}
"
public
"
:
{
{
ports
[
http
-
public
]
[
0
]
}
}
}
"
https
"
:
{
"
local
"
:
{
{
ports
[
https
]
[
0
]
}
}
"
private
"
:
{
{
ports
[
https
-
private
]
[
0
]
}
}
"
public
"
:
{
{
ports
[
https
-
public
]
[
0
]
}
}
}
"
ws
"
:
{
"
local
"
:
{
{
ports
[
ws
]
[
0
]
}
}
}
"
wss
"
:
{
"
local
"
:
{
{
ports
[
wss
]
[
0
]
}
}
}
}
;
class
Server
{
static
get
(
protocol
addressSpace
)
{
const
ports
=
SERVER_PORTS
[
protocol
]
;
if
(
ports
=
=
=
undefined
)
{
return
null
;
}
const
port
=
ports
[
addressSpace
]
;
if
(
port
=
=
=
undefined
)
{
return
null
;
}
return
{
addressSpace
name
:
{
protocol
}
-
{
addressSpace
}
port
protocol
:
protocol
+
'
:
'
}
;
}
static
HTTP_LOCAL
=
Server
.
get
(
"
http
"
"
local
"
)
;
static
HTTP_PRIVATE
=
Server
.
get
(
"
http
"
"
private
"
)
;
static
HTTP_PUBLIC
=
Server
.
get
(
"
http
"
"
public
"
)
;
static
HTTPS_LOCAL
=
Server
.
get
(
"
https
"
"
local
"
)
;
static
HTTPS_PRIVATE
=
Server
.
get
(
"
https
"
"
private
"
)
;
static
HTTPS_PUBLIC
=
Server
.
get
(
"
https
"
"
public
"
)
;
static
WS_LOCAL
=
Server
.
get
(
"
ws
"
"
local
"
)
;
static
WSS_LOCAL
=
Server
.
get
(
"
wss
"
"
local
"
)
;
}
;
function
resolveUrl
(
url
options
)
{
const
result
=
new
URL
(
url
window
.
location
)
;
if
(
options
=
=
=
undefined
)
{
return
result
;
}
const
{
port
protocol
headers
searchParams
}
=
options
;
if
(
port
!
=
=
undefined
)
{
result
.
port
=
port
;
}
if
(
protocol
!
=
=
undefined
)
{
result
.
protocol
=
protocol
;
}
if
(
headers
!
=
=
undefined
)
{
const
pipes
=
[
]
;
for
(
key
in
headers
)
{
pipes
.
push
(
header
(
{
key
}
{
headers
[
key
]
}
)
)
;
}
result
.
searchParams
.
append
(
"
pipe
"
pipes
.
join
(
"
|
"
)
)
;
}
if
(
searchParams
!
=
=
undefined
)
{
for
(
key
in
searchParams
)
{
result
.
searchParams
.
append
(
key
searchParams
[
key
]
)
;
}
}
return
result
;
}
function
sourceResolveOptions
(
{
server
treatAsPublic
}
)
{
const
options
=
{
.
.
.
server
}
;
if
(
treatAsPublic
)
{
options
.
headers
=
{
"
Content
-
Security
-
Policy
"
:
"
treat
-
as
-
public
-
address
"
}
;
}
return
options
;
}
function
preflightUrl
(
{
server
behavior
}
)
{
const
options
=
{
.
.
.
server
}
;
if
(
behavior
)
{
const
{
preflight
response
redirect
}
=
behavior
;
options
.
searchParams
=
{
.
.
.
preflight
.
.
.
response
}
;
if
(
redirect
!
=
=
undefined
)
{
options
.
searchParams
.
redirect
=
redirect
;
}
}
return
resolveUrl
(
"
resources
/
preflight
.
py
"
options
)
;
}
const
PreflightBehavior
=
{
failure
:
(
)
=
>
(
{
}
)
noCorsHeader
:
(
uuid
)
=
>
(
{
"
preflight
-
uuid
"
:
uuid
}
)
noPnaHeader
:
(
uuid
)
=
>
(
{
"
preflight
-
uuid
"
:
uuid
"
preflight
-
headers
"
:
"
cors
"
}
)
success
:
(
uuid
)
=
>
(
{
"
preflight
-
uuid
"
:
uuid
"
preflight
-
headers
"
:
"
cors
+
pna
"
}
)
optionalSuccess
:
(
uuid
)
=
>
(
{
"
preflight
-
uuid
"
:
uuid
"
preflight
-
headers
"
:
"
cors
+
pna
"
"
is
-
preflight
-
optional
"
:
true
}
)
serviceWorkerSuccess
:
(
uuid
)
=
>
(
{
"
preflight
-
uuid
"
:
uuid
"
preflight
-
headers
"
:
"
cors
+
pna
+
sw
"
}
)
singlePreflight
:
(
uuid
)
=
>
(
{
"
preflight
-
uuid
"
:
uuid
"
preflight
-
headers
"
:
"
cors
+
pna
"
"
expect
-
single
-
preflight
"
:
true
}
)
}
;
const
ResponseBehavior
=
{
default
:
(
)
=
>
(
{
}
)
allowCrossOrigin
:
(
)
=
>
(
{
"
final
-
headers
"
:
"
cors
"
}
)
}
;
const
FetchTestResult
=
{
SUCCESS
:
{
ok
:
true
body
:
"
success
"
}
OPAQUE
:
{
ok
:
false
type
:
"
opaque
"
body
:
"
"
}
FAILURE
:
{
error
:
"
TypeError
:
Failed
to
fetch
"
}
}
;
async
function
fetchTest
(
t
{
source
target
fetchOptions
expected
}
)
{
const
sourceUrl
=
resolveUrl
(
"
resources
/
fetcher
.
html
"
sourceResolveOptions
(
source
)
)
;
const
targetUrl
=
preflightUrl
(
target
)
;
const
iframe
=
await
appendIframe
(
t
document
sourceUrl
)
;
const
reply
=
futureMessage
(
{
source
:
iframe
.
contentWindow
}
)
;
const
message
=
{
url
:
targetUrl
.
href
options
:
fetchOptions
}
;
iframe
.
contentWindow
.
postMessage
(
message
"
*
"
)
;
const
{
error
ok
type
body
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
error
"
)
;
assert_equals
(
ok
expected
.
ok
"
response
ok
"
)
;
assert_equals
(
body
expected
.
body
"
response
body
"
)
;
if
(
expected
.
type
!
=
=
undefined
)
{
assert_equals
(
type
expected
.
type
"
response
type
"
)
;
}
}
const
XhrTestResult
=
{
SUCCESS
:
{
loaded
:
true
status
:
200
body
:
"
success
"
}
FAILURE
:
{
loaded
:
false
status
:
0
}
}
;
async
function
xhrTest
(
t
{
source
target
method
expected
}
)
{
const
sourceUrl
=
resolveUrl
(
"
resources
/
xhr
-
sender
.
html
"
sourceResolveOptions
(
source
)
)
;
const
targetUrl
=
preflightUrl
(
target
)
;
const
iframe
=
await
appendIframe
(
t
document
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
const
message
=
{
url
:
targetUrl
.
href
method
:
method
}
;
iframe
.
contentWindow
.
postMessage
(
message
"
*
"
)
;
const
{
loaded
status
body
}
=
await
reply
;
assert_equals
(
loaded
expected
.
loaded
"
response
loaded
"
)
;
assert_equals
(
status
expected
.
status
"
response
status
"
)
;
assert_equals
(
body
expected
.
body
"
response
body
"
)
;
}
const
IframeTestResult
=
{
SUCCESS
:
"
loaded
"
FAILURE
:
"
timeout
"
}
;
async
function
iframeTest
(
t
{
source
target
expected
}
)
{
const
uuid
=
token
(
)
;
const
targetUrl
=
preflightUrl
(
target
)
;
targetUrl
.
searchParams
.
set
(
"
file
"
"
iframed
.
html
"
)
;
targetUrl
.
searchParams
.
set
(
"
iframe
-
uuid
"
uuid
)
;
const
sourceUrl
=
resolveUrl
(
"
resources
/
iframer
.
html
"
sourceResolveOptions
(
source
)
)
;
sourceUrl
.
searchParams
.
set
(
"
url
"
targetUrl
)
;
const
messagePromise
=
futureMessage
(
{
filter
:
(
data
)
=
>
data
.
uuid
=
=
=
uuid
}
)
;
const
iframe
=
await
appendIframe
(
t
document
sourceUrl
)
;
const
result
=
await
Promise
.
race
(
[
messagePromise
.
then
(
(
data
)
=
>
data
.
message
)
new
Promise
(
(
resolve
)
=
>
{
t
.
step_timeout
(
(
)
=
>
resolve
(
"
timeout
"
)
500
)
;
}
)
]
)
;
assert_equals
(
result
expected
)
;
}
const
iframeGrandparentTest
=
(
{
name
grandparentServer
child
grandchild
expected
}
)
=
>
promise_test_parallel
(
async
(
t
)
=
>
{
const
grandparentUuid
=
token
(
)
;
const
childUuid
=
token
(
)
;
const
grandchildUuid
=
token
(
)
;
const
grandparentUrl
=
resolveUrl
(
"
resources
/
executor
.
html
"
grandparentServer
)
;
grandparentUrl
.
searchParams
.
set
(
"
executor
-
uuid
"
grandparentUuid
)
;
const
childUrl
=
preflightUrl
(
child
)
;
childUrl
.
searchParams
.
set
(
"
file
"
"
executor
.
html
"
)
;
childUrl
.
searchParams
.
set
(
"
executor
-
uuid
"
childUuid
)
;
const
grandchildUrl
=
preflightUrl
(
grandchild
)
;
grandchildUrl
.
searchParams
.
set
(
"
file
"
"
iframed
.
html
"
)
;
grandchildUrl
.
searchParams
.
set
(
"
iframe
-
uuid
"
grandchildUuid
)
;
const
iframe
=
await
appendIframe
(
t
document
grandparentUrl
)
;
const
addChild
=
(
url
)
=
>
new
Promise
(
(
resolve
)
=
>
{
const
child
=
document
.
createElement
(
"
iframe
"
)
;
child
.
src
=
url
;
child
.
addEventListener
(
"
load
"
(
)
=
>
resolve
(
)
{
once
:
true
}
)
;
document
.
body
.
appendChild
(
child
)
;
}
)
;
const
grandparentCtx
=
new
RemoteContext
(
grandparentUuid
)
;
await
grandparentCtx
.
execute_script
(
addChild
[
childUrl
]
)
;
const
childCtx
=
new
RemoteContext
(
childUuid
)
;
await
Promise
.
race
(
[
childCtx
.
execute_script
(
addChild
[
"
about
:
blank
"
]
)
new
Promise
(
(
resolve
reject
)
=
>
t
.
step_timeout
(
(
)
=
>
reject
(
"
timeout
adding
grandchild
"
)
2000
)
)
]
)
;
const
messagePromise
=
futureMessage
(
{
filter
:
(
data
)
=
>
data
.
uuid
=
=
=
grandchildUuid
}
)
;
await
grandparentCtx
.
execute_script
(
(
url
)
=
>
{
const
child
=
window
.
frames
[
0
]
;
const
grandchild
=
child
.
frames
[
0
]
;
grandchild
.
location
=
url
;
}
[
grandchildUrl
]
)
;
const
result
=
await
Promise
.
race
(
[
messagePromise
.
then
(
(
data
)
=
>
data
.
message
)
new
Promise
(
(
resolve
)
=
>
{
t
.
step_timeout
(
(
)
=
>
resolve
(
"
timeout
"
)
2000
)
;
}
)
]
)
;
assert_equals
(
result
expected
)
;
}
name
)
;
const
WebsocketTestResult
=
{
SUCCESS
:
"
open
"
FAILURE
:
"
close
:
code
1006
"
}
;
async
function
websocketTest
(
t
{
source
target
expected
}
)
{
const
sourceUrl
=
resolveUrl
(
"
resources
/
socket
-
opener
.
html
"
sourceResolveOptions
(
source
)
)
;
const
targetUrl
=
resolveUrl
(
"
/
echo
"
target
.
server
)
;
const
iframe
=
await
appendIframe
(
t
document
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
iframe
.
contentWindow
.
postMessage
(
targetUrl
.
href
"
*
"
)
;
assert_equals
(
await
reply
expected
)
;
}
const
WorkerScriptTestResult
=
{
SUCCESS
:
{
loaded
:
true
}
FAILURE
:
{
error
:
"
unknown
error
"
}
}
;
function
workerScriptUrl
(
target
)
{
const
url
=
preflightUrl
(
target
)
;
url
.
searchParams
.
append
(
"
body
"
"
postMessage
(
{
loaded
:
true
}
)
"
)
url
.
searchParams
.
append
(
"
mime
-
type
"
"
application
/
javascript
"
)
return
url
;
}
async
function
workerScriptTest
(
t
{
source
target
expected
}
)
{
const
sourceUrl
=
resolveUrl
(
"
resources
/
worker
-
fetcher
.
html
"
sourceResolveOptions
(
source
)
)
;
const
targetUrl
=
workerScriptUrl
(
target
)
;
const
iframe
=
await
appendIframe
(
t
document
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
iframe
.
contentWindow
.
postMessage
(
{
url
:
targetUrl
.
href
}
"
*
"
)
;
const
{
error
loaded
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
worker
error
"
)
;
assert_equals
(
loaded
expected
.
loaded
"
response
loaded
"
)
;
}
async
function
nestedWorkerScriptTest
(
t
{
source
target
expected
}
)
{
const
targetUrl
=
workerScriptUrl
(
target
)
;
const
sourceUrl
=
resolveUrl
(
"
resources
/
worker
-
fetcher
.
js
"
sourceResolveOptions
(
source
)
)
;
sourceUrl
.
searchParams
.
append
(
"
url
"
targetUrl
)
;
const
iframeUrl
=
new
URL
(
"
worker
-
fetcher
.
html
"
sourceUrl
)
;
const
iframe
=
await
appendIframe
(
t
document
iframeUrl
)
;
const
reply
=
futureMessage
(
)
;
iframe
.
contentWindow
.
postMessage
(
{
url
:
sourceUrl
.
href
}
"
*
"
)
;
const
{
error
loaded
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
worker
error
"
)
;
assert_equals
(
loaded
expected
.
loaded
"
response
loaded
"
)
;
}
async
function
sharedWorkerScriptTest
(
t
{
source
target
expected
}
)
{
const
sourceUrl
=
resolveUrl
(
"
resources
/
shared
-
worker
-
fetcher
.
html
"
sourceResolveOptions
(
source
)
)
;
const
targetUrl
=
preflightUrl
(
target
)
;
targetUrl
.
searchParams
.
append
(
"
body
"
"
onconnect
=
(
e
)
=
>
e
.
ports
[
0
]
.
postMessage
(
{
loaded
:
true
}
)
"
)
targetUrl
.
searchParams
.
append
(
"
mime
-
type
"
"
application
/
javascript
"
)
const
iframe
=
await
appendIframe
(
t
document
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
iframe
.
contentWindow
.
postMessage
(
{
url
:
targetUrl
.
href
}
"
*
"
)
;
const
{
error
loaded
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
worker
error
"
)
;
assert_equals
(
loaded
expected
.
loaded
"
response
loaded
"
)
;
}
const
WorkerFetchTestResult
=
{
SUCCESS
:
{
status
:
200
body
:
"
success
"
}
FAILURE
:
{
error
:
"
TypeError
"
}
}
;
async
function
workerFetchTest
(
t
{
source
target
expected
}
)
{
const
targetUrl
=
preflightUrl
(
target
)
;
const
sourceUrl
=
resolveUrl
(
"
resources
/
fetcher
.
js
"
sourceResolveOptions
(
source
)
)
;
sourceUrl
.
searchParams
.
append
(
"
url
"
targetUrl
.
href
)
;
const
fetcherUrl
=
new
URL
(
"
worker
-
fetcher
.
html
"
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
const
iframe
=
await
appendIframe
(
t
document
fetcherUrl
)
;
iframe
.
contentWindow
.
postMessage
(
{
url
:
sourceUrl
.
href
}
"
*
"
)
;
const
{
error
status
message
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
fetch
error
"
)
;
assert_equals
(
status
expected
.
status
"
response
status
"
)
;
assert_equals
(
message
expected
.
message
"
response
body
"
)
;
}
async
function
workerBlobFetchTest
(
t
{
source
target
expected
}
)
{
const
targetUrl
=
preflightUrl
(
target
)
;
const
fetcherUrl
=
resolveUrl
(
'
resources
/
worker
-
blob
-
fetcher
.
html
'
sourceResolveOptions
(
source
)
)
;
const
reply
=
futureMessage
(
)
;
const
iframe
=
await
appendIframe
(
t
document
fetcherUrl
)
;
iframe
.
contentWindow
.
postMessage
(
{
url
:
targetUrl
.
href
}
"
*
"
)
;
const
{
error
status
message
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
fetch
error
"
)
;
assert_equals
(
status
expected
.
status
"
response
status
"
)
;
assert_equals
(
message
expected
.
message
"
response
body
"
)
;
}
async
function
sharedWorkerFetchTest
(
t
{
source
target
expected
}
)
{
const
targetUrl
=
preflightUrl
(
target
)
;
const
sourceUrl
=
resolveUrl
(
"
resources
/
shared
-
fetcher
.
js
"
sourceResolveOptions
(
source
)
)
;
sourceUrl
.
searchParams
.
append
(
"
url
"
targetUrl
.
href
)
;
const
fetcherUrl
=
new
URL
(
"
shared
-
worker
-
fetcher
.
html
"
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
const
iframe
=
await
appendIframe
(
t
document
fetcherUrl
)
;
iframe
.
contentWindow
.
postMessage
(
{
url
:
sourceUrl
.
href
}
"
*
"
)
;
const
{
error
status
message
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
fetch
error
"
)
;
assert_equals
(
status
expected
.
status
"
response
status
"
)
;
assert_equals
(
message
expected
.
message
"
response
body
"
)
;
}
async
function
sharedWorkerBlobFetchTest
(
t
{
source
target
expected
}
)
{
const
targetUrl
=
preflightUrl
(
target
)
;
const
fetcherUrl
=
resolveUrl
(
'
resources
/
shared
-
worker
-
blob
-
fetcher
.
html
'
sourceResolveOptions
(
source
)
)
;
const
reply
=
futureMessage
(
)
;
const
iframe
=
await
appendIframe
(
t
document
fetcherUrl
)
;
iframe
.
contentWindow
.
postMessage
(
{
url
:
targetUrl
.
href
}
"
*
"
)
;
const
{
error
status
message
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
fetch
error
"
)
;
assert_equals
(
status
expected
.
status
"
response
status
"
)
;
assert_equals
(
message
expected
.
message
"
response
body
"
)
;
}
