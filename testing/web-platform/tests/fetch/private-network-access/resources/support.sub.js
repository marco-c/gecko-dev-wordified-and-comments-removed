function
appendIframeWith
(
t
doc
func
)
{
return
new
Promise
(
resolve
=
>
{
const
child
=
doc
.
createElement
(
"
iframe
"
)
;
func
(
child
)
;
child
.
onload
=
(
)
=
>
{
resolve
(
child
)
;
}
;
doc
.
body
.
appendChild
(
child
)
;
t
.
add_cleanup
(
(
)
=
>
{
doc
.
body
.
removeChild
(
child
)
;
}
)
;
}
)
;
}
function
appendIframe
(
t
doc
src
)
{
return
appendIframeWith
(
t
doc
child
=
>
{
child
.
src
=
src
;
}
)
;
}
function
futureMessage
(
)
{
return
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
"
message
"
e
=
>
resolve
(
e
.
data
)
)
;
}
)
;
}
;
const
Server
=
{
HTTP_LOCAL
:
{
port
:
{
{
ports
[
http
]
[
0
]
}
}
protocol
:
"
http
:
"
}
HTTP_PRIVATE
:
{
port
:
{
{
ports
[
http
-
private
]
[
0
]
}
}
protocol
:
"
http
:
"
}
HTTP_PUBLIC
:
{
port
:
{
{
ports
[
http
-
public
]
[
0
]
}
}
protocol
:
"
http
:
"
}
HTTPS_LOCAL
:
{
port
:
{
{
ports
[
https
]
[
0
]
}
}
protocol
:
"
https
:
"
}
HTTPS_PRIVATE
:
{
port
:
{
{
ports
[
https
-
private
]
[
0
]
}
}
protocol
:
"
https
:
"
}
HTTPS_PUBLIC
:
{
port
:
{
{
ports
[
https
-
public
]
[
0
]
}
}
protocol
:
"
https
:
"
}
WS_LOCAL
:
{
port
:
{
{
ports
[
ws
]
[
0
]
}
}
protocol
:
"
ws
:
"
}
WSS_LOCAL
:
{
port
:
{
{
ports
[
wss
]
[
0
]
}
}
protocol
:
"
wss
:
"
}
}
;
function
resolveUrl
(
url
options
)
{
const
result
=
new
URL
(
url
window
.
location
)
;
if
(
options
=
=
=
undefined
)
{
return
result
;
}
const
{
port
protocol
headers
searchParams
}
=
options
;
if
(
port
!
=
=
undefined
)
{
result
.
port
=
port
;
}
if
(
protocol
!
=
=
undefined
)
{
result
.
protocol
=
protocol
;
}
if
(
headers
!
=
=
undefined
)
{
const
pipes
=
[
]
;
for
(
key
in
headers
)
{
pipes
.
push
(
header
(
{
key
}
{
headers
[
key
]
}
)
)
;
}
result
.
searchParams
.
append
(
"
pipe
"
pipes
.
join
(
"
|
"
)
)
;
}
if
(
searchParams
!
=
=
undefined
)
{
for
(
key
in
searchParams
)
{
result
.
searchParams
.
append
(
key
searchParams
[
key
]
)
;
}
}
return
result
;
}
function
sourceResolveOptions
(
{
server
treatAsPublic
}
)
{
const
options
=
{
.
.
.
server
}
;
if
(
treatAsPublic
)
{
options
.
headers
=
{
"
Content
-
Security
-
Policy
"
:
"
treat
-
as
-
public
-
address
"
}
;
}
return
options
;
}
function
preflightUrl
(
{
server
behavior
}
)
{
const
options
=
{
.
.
.
server
}
;
if
(
behavior
)
{
const
{
preflight
response
redirect
}
=
behavior
;
options
.
searchParams
=
{
.
.
.
preflight
.
.
.
response
}
;
if
(
redirect
!
=
=
undefined
)
{
options
.
searchParams
.
redirect
=
redirect
;
}
}
return
resolveUrl
(
"
resources
/
preflight
.
py
"
options
)
;
}
const
PreflightBehavior
=
{
failure
:
(
)
=
>
(
{
}
)
noCorsHeader
:
(
uuid
)
=
>
(
{
"
preflight
-
uuid
"
:
uuid
}
)
noPnaHeader
:
(
uuid
)
=
>
(
{
"
preflight
-
uuid
"
:
uuid
"
preflight
-
headers
"
:
"
cors
"
}
)
success
:
(
uuid
)
=
>
(
{
"
preflight
-
uuid
"
:
uuid
"
preflight
-
headers
"
:
"
cors
+
pna
"
}
)
singlePreflight
:
(
uuid
)
=
>
(
{
"
preflight
-
uuid
"
:
uuid
"
preflight
-
headers
"
:
"
cors
+
pna
"
"
expect
-
single
-
preflight
"
:
true
}
)
}
;
const
ResponseBehavior
=
{
default
:
(
)
=
>
(
{
}
)
allowCrossOrigin
:
(
)
=
>
(
{
"
final
-
headers
"
:
"
cors
"
}
)
}
;
const
FetchTestResult
=
{
SUCCESS
:
{
ok
:
true
body
:
"
success
"
}
OPAQUE
:
{
ok
:
false
type
:
"
opaque
"
body
:
"
"
}
FAILURE
:
{
error
:
"
TypeError
:
Failed
to
fetch
"
}
}
;
async
function
fetchTest
(
t
{
source
target
fetchOptions
expected
}
)
{
const
sourceUrl
=
resolveUrl
(
"
resources
/
fetcher
.
html
"
sourceResolveOptions
(
source
)
)
;
const
targetUrl
=
preflightUrl
(
target
)
;
const
iframe
=
await
appendIframe
(
t
document
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
const
message
=
{
url
:
targetUrl
.
href
options
:
fetchOptions
}
;
iframe
.
contentWindow
.
postMessage
(
message
"
*
"
)
;
const
{
error
ok
type
body
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
error
"
)
;
assert_equals
(
ok
expected
.
ok
"
response
ok
"
)
;
assert_equals
(
body
expected
.
body
"
response
body
"
)
;
if
(
expected
.
type
!
=
=
undefined
)
{
assert_equals
(
type
expected
.
type
"
response
type
"
)
;
}
}
const
XhrTestResult
=
{
SUCCESS
:
{
loaded
:
true
status
:
200
body
:
"
success
"
}
FAILURE
:
{
loaded
:
false
status
:
0
}
}
;
async
function
xhrTest
(
t
{
source
target
method
expected
}
)
{
const
sourceUrl
=
resolveUrl
(
"
resources
/
xhr
-
sender
.
html
"
sourceResolveOptions
(
source
)
)
;
const
targetUrl
=
preflightUrl
(
target
)
;
const
iframe
=
await
appendIframe
(
t
document
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
const
message
=
{
url
:
targetUrl
.
href
method
:
method
}
;
iframe
.
contentWindow
.
postMessage
(
message
"
*
"
)
;
const
{
loaded
status
body
}
=
await
reply
;
assert_equals
(
loaded
expected
.
loaded
"
response
loaded
"
)
;
assert_equals
(
status
expected
.
status
"
response
status
"
)
;
assert_equals
(
body
expected
.
body
"
response
body
"
)
;
}
const
WebsocketTestResult
=
{
SUCCESS
:
"
open
"
FAILURE
:
"
close
:
code
1006
"
}
;
async
function
websocketTest
(
t
{
source
target
expected
}
)
{
const
sourceUrl
=
resolveUrl
(
"
resources
/
socket
-
opener
.
html
"
sourceResolveOptions
(
source
)
)
;
const
targetUrl
=
resolveUrl
(
"
/
echo
"
target
.
server
)
;
const
iframe
=
await
appendIframe
(
t
document
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
iframe
.
contentWindow
.
postMessage
(
targetUrl
.
href
"
*
"
)
;
assert_equals
(
await
reply
expected
)
;
}
const
WorkerScriptTestResult
=
{
SUCCESS
:
{
loaded
:
true
}
FAILURE
:
{
error
:
"
unknown
error
"
}
}
;
function
workerScriptUrl
(
target
)
{
const
url
=
preflightUrl
(
target
)
;
url
.
searchParams
.
append
(
"
body
"
"
postMessage
(
{
loaded
:
true
}
)
"
)
url
.
searchParams
.
append
(
"
mime
-
type
"
"
application
/
javascript
"
)
return
url
;
}
async
function
workerScriptTest
(
t
{
source
target
expected
}
)
{
const
sourceUrl
=
resolveUrl
(
"
resources
/
worker
-
fetcher
.
html
"
sourceResolveOptions
(
source
)
)
;
const
targetUrl
=
workerScriptUrl
(
target
)
;
const
iframe
=
await
appendIframe
(
t
document
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
iframe
.
contentWindow
.
postMessage
(
{
url
:
targetUrl
.
href
}
"
*
"
)
;
const
{
error
loaded
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
worker
error
"
)
;
assert_equals
(
loaded
expected
.
loaded
"
response
loaded
"
)
;
}
async
function
nestedWorkerScriptTest
(
t
{
source
target
expected
}
)
{
const
targetUrl
=
workerScriptUrl
(
target
)
;
const
sourceUrl
=
resolveUrl
(
"
resources
/
worker
-
fetcher
.
js
"
sourceResolveOptions
(
source
)
)
;
sourceUrl
.
searchParams
.
append
(
"
url
"
targetUrl
)
;
const
iframeUrl
=
new
URL
(
"
worker
-
fetcher
.
html
"
sourceUrl
)
;
const
iframe
=
await
appendIframe
(
t
document
iframeUrl
)
;
const
reply
=
futureMessage
(
)
;
iframe
.
contentWindow
.
postMessage
(
{
url
:
sourceUrl
.
href
}
"
*
"
)
;
const
{
error
loaded
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
worker
error
"
)
;
assert_equals
(
loaded
expected
.
loaded
"
response
loaded
"
)
;
}
async
function
sharedWorkerScriptTest
(
t
{
source
target
expected
}
)
{
const
sourceUrl
=
resolveUrl
(
"
resources
/
shared
-
worker
-
fetcher
.
html
"
sourceResolveOptions
(
source
)
)
;
const
targetUrl
=
preflightUrl
(
target
)
;
targetUrl
.
searchParams
.
append
(
"
body
"
"
onconnect
=
(
e
)
=
>
e
.
ports
[
0
]
.
postMessage
(
{
loaded
:
true
}
)
"
)
targetUrl
.
searchParams
.
append
(
"
mime
-
type
"
"
application
/
javascript
"
)
const
iframe
=
await
appendIframe
(
t
document
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
iframe
.
contentWindow
.
postMessage
(
{
url
:
targetUrl
.
href
}
"
*
"
)
;
const
{
error
loaded
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
worker
error
"
)
;
assert_equals
(
loaded
expected
.
loaded
"
response
loaded
"
)
;
}
const
WorkerFetchTestResult
=
{
SUCCESS
:
{
status
:
200
body
:
"
success
"
}
FAILURE
:
{
error
:
"
TypeError
"
}
}
;
async
function
workerFetchTest
(
t
{
source
target
expected
}
)
{
const
targetUrl
=
preflightUrl
(
target
)
;
const
sourceUrl
=
resolveUrl
(
"
resources
/
fetcher
.
js
"
sourceResolveOptions
(
source
)
)
;
sourceUrl
.
searchParams
.
append
(
"
url
"
targetUrl
.
href
)
;
const
fetcherUrl
=
new
URL
(
"
worker
-
fetcher
.
html
"
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
const
iframe
=
await
appendIframe
(
t
document
fetcherUrl
)
;
iframe
.
contentWindow
.
postMessage
(
{
url
:
sourceUrl
.
href
}
"
*
"
)
;
const
{
error
status
message
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
fetch
error
"
)
;
assert_equals
(
status
expected
.
status
"
response
status
"
)
;
assert_equals
(
message
expected
.
message
"
response
body
"
)
;
}
async
function
sharedWorkerFetchTest
(
t
{
source
target
expected
}
)
{
const
targetUrl
=
preflightUrl
(
target
)
;
const
sourceUrl
=
resolveUrl
(
"
resources
/
shared
-
fetcher
.
js
"
sourceResolveOptions
(
source
)
)
;
sourceUrl
.
searchParams
.
append
(
"
url
"
targetUrl
.
href
)
;
const
fetcherUrl
=
new
URL
(
"
shared
-
worker
-
fetcher
.
html
"
sourceUrl
)
;
const
reply
=
futureMessage
(
)
;
const
iframe
=
await
appendIframe
(
t
document
fetcherUrl
)
;
iframe
.
contentWindow
.
postMessage
(
{
url
:
sourceUrl
.
href
}
"
*
"
)
;
const
{
error
status
message
}
=
await
reply
;
assert_equals
(
error
expected
.
error
"
fetch
error
"
)
;
assert_equals
(
status
expected
.
status
"
response
status
"
)
;
assert_equals
(
message
expected
.
message
"
response
body
"
)
;
}
