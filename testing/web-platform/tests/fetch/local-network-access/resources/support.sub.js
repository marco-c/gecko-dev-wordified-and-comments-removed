const
SERVER_PORTS
=
{
"
http
"
:
{
"
loopback
"
:
{
{
ports
[
http
]
[
0
]
}
}
"
other
-
loopback
"
:
{
{
ports
[
http
]
[
1
]
}
}
"
local
"
:
{
{
ports
[
http
-
local
]
[
0
]
}
}
"
public
"
:
{
{
ports
[
http
-
public
]
[
0
]
}
}
}
"
https
"
:
{
"
loopback
"
:
{
{
ports
[
https
]
[
0
]
}
}
"
other
-
loopback
"
:
{
{
ports
[
https
]
[
1
]
}
}
"
local
"
:
{
{
ports
[
https
-
local
]
[
0
]
}
}
"
public
"
:
{
{
ports
[
https
-
public
]
[
0
]
}
}
}
"
ws
"
:
{
"
loopback
"
:
{
{
ports
[
ws
]
[
0
]
}
}
}
"
wss
"
:
{
"
loopback
"
:
{
{
ports
[
wss
]
[
0
]
}
}
}
}
;
class
Server
{
static
get
(
protocol
addressSpace
)
{
const
ports
=
SERVER_PORTS
[
protocol
]
;
if
(
ports
=
=
=
undefined
)
{
return
null
;
}
const
port
=
ports
[
addressSpace
]
;
if
(
port
=
=
=
undefined
)
{
return
null
;
}
return
{
addressSpace
name
:
{
protocol
}
-
{
addressSpace
}
port
protocol
:
protocol
+
'
:
'
}
;
}
static
HTTP_LOOPBACK
=
Server
.
get
(
"
http
"
"
loopback
"
)
;
static
OTHER_HTTP_LOOPBACK
=
Server
.
get
(
"
http
"
"
other
-
loopback
"
)
;
static
HTTP_LOCAL
=
Server
.
get
(
"
http
"
"
local
"
)
;
static
HTTP_PUBLIC
=
Server
.
get
(
"
http
"
"
public
"
)
;
static
HTTPS_LOOPBACK
=
Server
.
get
(
"
https
"
"
loopback
"
)
;
static
OTHER_HTTPS_LOOPBACK
=
Server
.
get
(
"
https
"
"
other
-
loopback
"
)
;
static
HTTPS_LOCAL
=
Server
.
get
(
"
https
"
"
local
"
)
;
static
HTTPS_PUBLIC
=
Server
.
get
(
"
https
"
"
public
"
)
;
static
WS_LOOPBACK
=
Server
.
get
(
"
ws
"
"
loopback
"
)
;
static
WSS_LOOPBACK
=
Server
.
get
(
"
wss
"
"
loopback
"
)
;
}
;
function
resolveUrl
(
url
options
)
{
const
result
=
new
URL
(
url
window
.
location
)
;
if
(
options
=
=
=
undefined
)
{
return
result
;
}
const
{
port
protocol
headers
searchParams
}
=
options
;
if
(
port
!
=
=
undefined
)
{
result
.
port
=
port
;
}
if
(
protocol
!
=
=
undefined
)
{
result
.
protocol
=
protocol
;
}
if
(
headers
!
=
=
undefined
)
{
const
pipes
=
[
]
;
for
(
key
in
headers
)
{
pipes
.
push
(
header
(
{
key
}
{
headers
[
key
]
}
)
)
;
}
result
.
searchParams
.
append
(
"
pipe
"
pipes
.
join
(
"
|
"
)
)
;
}
if
(
searchParams
!
=
=
undefined
)
{
for
(
key
in
searchParams
)
{
result
.
searchParams
.
append
(
key
searchParams
[
key
]
)
;
}
}
return
result
;
}
function
sourceResolveOptions
(
{
server
treatAsPublic
}
)
{
const
options
=
{
.
.
.
server
}
;
if
(
treatAsPublic
)
{
options
.
headers
=
{
"
Content
-
Security
-
Policy
"
:
"
treat
-
as
-
public
-
address
"
}
;
}
return
options
;
}
function
resolveTargetUrl
(
{
server
behavior
}
)
{
if
(
server
=
=
=
undefined
)
{
throw
new
Error
(
"
no
server
specified
.
"
)
;
}
const
options
=
{
.
.
.
server
}
;
if
(
behavior
)
{
const
{
response
redirect
}
=
behavior
;
options
.
searchParams
=
{
.
.
.
response
}
;
if
(
redirect
!
=
=
undefined
)
{
options
.
searchParams
.
redirect
=
redirect
;
}
}
return
resolveUrl
(
"
target
.
py
"
options
)
;
}
const
ResponseBehavior
=
{
default
:
(
)
=
>
(
{
}
)
allowCrossOrigin
:
(
)
=
>
(
{
"
final
-
headers
"
:
"
cors
"
}
)
}
;
const
FetchTestResult
=
{
SUCCESS
:
{
ok
:
true
body
:
"
success
"
}
OPAQUE
:
{
ok
:
false
type
:
"
opaque
"
body
:
"
"
}
FAILURE
:
{
error
:
"
TypeError
:
Failed
to
fetch
"
}
}
;
function
checkTestResult
(
actual
expected
)
{
assert_equals
(
actual
.
error
expected
.
error
"
error
mismatch
"
)
;
assert_equals
(
actual
.
ok
expected
.
ok
"
response
ok
mismatch
"
)
;
assert_equals
(
actual
.
body
expected
.
body
"
response
body
mismatch
"
)
;
if
(
expected
.
type
!
=
=
undefined
)
{
assert_equals
(
type
expected
.
type
"
response
type
mismatch
"
)
;
}
}
function
futureMessage
(
options
)
{
return
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
'
message
'
(
e
)
=
>
{
resolve
(
e
.
data
)
;
}
)
;
}
)
;
}
;
const
NavigationTestResult
=
{
SUCCESS
:
'
loaded
'
FAILURE
:
'
timeout
'
}
;
async
function
iframeTest
(
t
{
source
target
expected
permission
=
'
denied
'
}
)
{
const
targetUrl
=
resolveUrl
(
'
resources
/
openee
.
html
'
sourceResolveOptions
(
target
)
)
;
const
sourceUrl
=
resolveUrl
(
'
resources
/
iframer
.
html
'
sourceResolveOptions
(
source
)
)
;
sourceUrl
.
searchParams
.
set
(
'
permission
'
permission
)
;
sourceUrl
.
searchParams
.
set
(
'
url
'
targetUrl
)
;
const
popup
=
window
.
open
(
sourceUrl
)
;
t
.
add_cleanup
(
(
)
=
>
popup
.
close
(
)
)
;
const
result
=
await
Promise
.
race
(
[
futureMessage
(
)
.
then
(
(
data
)
=
>
data
.
message
)
new
Promise
(
(
resolve
)
=
>
{
t
.
step_timeout
(
(
)
=
>
resolve
(
'
timeout
'
)
2000
)
;
}
)
]
)
;
assert_equals
(
result
expected
)
;
}
async
function
navigateTest
(
t
{
source
target
expected
}
)
{
const
targetUrl
=
resolveUrl
(
'
resources
/
openee
.
html
'
sourceResolveOptions
(
target
)
)
;
const
sourceUrl
=
resolveUrl
(
'
resources
/
navigate
.
html
'
sourceResolveOptions
(
source
)
)
;
sourceUrl
.
searchParams
.
set
(
'
url
'
targetUrl
)
;
const
popup
=
window
.
open
(
sourceUrl
)
;
t
.
add_cleanup
(
(
)
=
>
popup
.
close
(
)
)
;
const
result
=
await
Promise
.
race
(
[
futureMessage
(
)
.
then
(
(
data
)
=
>
data
.
message
)
new
Promise
(
(
resolve
)
=
>
{
t
.
step_timeout
(
(
)
=
>
resolve
(
'
timeout
'
)
2000
)
;
}
)
]
)
;
assert_equals
(
result
expected
)
;
}
