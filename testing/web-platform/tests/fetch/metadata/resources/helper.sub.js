'
use
strict
'
;
function
makeRequestURL
(
key
origins
params
)
{
const
byName
=
{
httpOrigin
:
'
http
:
/
/
{
{
host
}
}
:
{
{
ports
[
http
]
[
0
]
}
}
'
httpSameSite
:
'
http
:
/
/
{
{
hosts
[
]
[
www
]
}
}
:
{
{
ports
[
http
]
[
0
]
}
}
'
httpCrossSite
:
'
http
:
/
/
{
{
hosts
[
alt
]
[
]
}
}
:
{
{
ports
[
http
]
[
0
]
}
}
'
httpsOrigin
:
'
https
:
/
/
{
{
host
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
httpsSameSite
:
'
https
:
/
/
{
{
hosts
[
]
[
www
]
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
httpsCrossSite
:
'
https
:
/
/
{
{
hosts
[
alt
]
[
]
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
}
;
const
redirectPath
=
'
/
fetch
/
api
/
resources
/
redirect
.
py
?
location
=
'
;
const
path
=
'
/
fetch
/
metadata
/
resources
/
record
-
headers
.
py
?
key
=
'
+
key
;
let
requestUrl
=
path
;
if
(
params
)
{
requestUrl
+
=
'
&
'
+
new
URLSearchParams
(
params
)
.
toString
(
)
;
}
if
(
origins
&
&
origins
.
length
)
{
requestUrl
=
byName
[
origins
.
pop
(
)
]
+
requestUrl
;
while
(
origins
.
length
)
{
requestUrl
=
byName
[
origins
.
pop
(
)
]
+
redirectPath
+
encodeURIComponent
(
requestUrl
)
;
}
}
else
{
requestUrl
=
byName
.
httpsOrigin
+
requestUrl
;
}
return
requestUrl
;
}
function
retrieve
(
key
options
)
{
return
fetch
(
'
/
fetch
/
metadata
/
resources
/
record
-
headers
.
py
?
retrieve
&
key
=
'
+
key
)
.
then
(
(
response
)
=
>
{
if
(
response
.
status
=
=
=
204
&
&
options
&
&
options
.
poll
)
{
return
new
Promise
(
(
resolve
)
=
>
setTimeout
(
resolve
300
)
)
.
then
(
(
)
=
>
retrieve
(
key
options
)
)
;
}
if
(
response
.
status
!
=
=
200
)
{
throw
new
Error
(
'
Failed
to
query
for
recorded
headers
.
'
)
;
}
return
response
.
text
(
)
.
then
(
(
text
)
=
>
JSON
.
parse
(
text
)
)
;
}
)
;
}
