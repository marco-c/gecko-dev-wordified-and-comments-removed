function
send_message_to_iframe
(
iframe
message
reply
)
{
if
(
reply
=
=
=
undefined
)
{
reply
=
'
success
'
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
window
.
addEventListener
(
'
message
'
(
e
)
=
>
{
if
(
e
.
data
.
command
!
=
=
message
.
command
)
{
reject
(
Expected
reply
with
command
'
{
message
.
command
}
'
got
'
{
e
.
data
.
command
}
'
instead
)
;
return
;
}
if
(
e
.
data
.
result
=
=
=
reply
)
{
resolve
(
)
;
}
else
{
reject
(
Got
unexpected
reply
'
{
e
.
data
.
result
}
'
to
command
'
{
message
.
command
}
'
expected
'
{
reply
}
'
)
;
}
}
{
once
:
true
}
)
;
iframe
.
contentWindow
.
postMessage
(
message
'
*
'
)
;
}
)
;
}
function
run_generic_sensor_iframe_tests
(
sensorName
)
{
const
sensorType
=
self
[
sensorName
]
;
const
featurePolicies
=
get_feature_policies_for_sensor
(
sensorName
)
;
sensor_test
(
async
t
=
>
{
assert_implements
(
sensorName
in
self
{
sensorName
}
is
not
supported
.
)
;
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
allow
=
featurePolicies
.
join
(
'
;
'
)
+
'
;
'
;
iframe
.
src
=
'
https
:
/
/
{
{
domains
[
www1
]
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
/
generic
-
sensor
/
resources
/
iframe_sensor_handler
.
html
'
;
const
iframeLoadWatcher
=
new
EventWatcher
(
t
iframe
'
load
'
)
;
document
.
body
.
appendChild
(
iframe
)
;
t
.
add_cleanup
(
async
(
)
=
>
{
await
send_message_to_iframe
(
iframe
{
command
:
'
reset_sensor_backend
'
}
)
;
iframe
.
parentNode
.
removeChild
(
iframe
)
;
}
)
;
await
iframeLoadWatcher
.
wait_for
(
'
load
'
)
;
await
send_message_to_iframe
(
iframe
{
command
:
'
create_sensor
'
type
:
sensorName
}
)
;
window
.
focus
(
)
;
const
sensor
=
new
sensorType
(
)
;
const
sensorWatcher
=
new
EventWatcher
(
t
sensor
[
'
reading
'
'
error
'
]
)
;
sensor
.
start
(
)
;
await
sensorWatcher
.
wait_for
(
'
reading
'
)
;
const
cachedTimeStamp
=
sensor
.
timestamp
;
iframe
.
contentWindow
.
focus
(
)
;
await
send_message_to_iframe
(
iframe
{
command
:
'
start_sensor
'
}
)
;
window
.
focus
(
)
;
await
sensorWatcher
.
wait_for
(
'
reading
'
)
;
assert_greater_than
(
sensor
.
timestamp
cachedTimeStamp
)
;
sensor
.
stop
(
)
;
await
send_message_to_iframe
(
iframe
{
command
:
'
is_sensor_suspended
'
}
true
)
;
}
{
sensorName
}
:
sensor
is
suspended
and
resumed
when
focus
traverses
from
\
to
cross
-
origin
frame
)
;
sensor_test
(
async
t
=
>
{
assert_implements
(
sensorName
in
self
{
sensorName
}
is
not
supported
.
)
;
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
allow
=
featurePolicies
.
join
(
'
;
'
)
+
'
;
'
;
iframe
.
src
=
'
https
:
/
/
{
{
host
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
/
generic
-
sensor
/
resources
/
iframe_sensor_handler
.
html
'
;
const
iframeLoadWatcher
=
new
EventWatcher
(
t
iframe
'
load
'
)
;
document
.
body
.
appendChild
(
iframe
)
;
t
.
add_cleanup
(
async
(
)
=
>
{
await
send_message_to_iframe
(
iframe
{
command
:
'
reset_sensor_backend
'
}
)
;
iframe
.
parentNode
.
removeChild
(
iframe
)
;
}
)
;
await
iframeLoadWatcher
.
wait_for
(
'
load
'
)
;
await
send_message_to_iframe
(
iframe
{
command
:
'
create_sensor
'
type
:
sensorName
}
)
;
window
.
focus
(
)
;
const
sensor
=
new
sensorType
(
{
frequency
:
15
}
)
;
const
sensorWatcher
=
new
EventWatcher
(
t
sensor
[
'
reading
'
'
error
'
]
)
;
sensor
.
start
(
)
;
await
sensorWatcher
.
wait_for
(
'
reading
'
)
;
let
cachedTimeStamp
=
sensor
.
timestamp
;
sensor
.
stop
(
)
;
iframe
.
contentWindow
.
focus
(
)
;
await
send_message_to_iframe
(
iframe
{
command
:
'
start_sensor
'
}
)
;
window
.
focus
(
)
;
sensor
.
start
(
)
;
await
sensorWatcher
.
wait_for
(
'
reading
'
)
;
assert_greater_than
(
sensor
.
timestamp
cachedTimeStamp
)
;
cachedTimeStamp
=
sensor
.
timestamp
;
sensor
.
stop
(
)
;
await
send_message_to_iframe
(
iframe
{
command
:
'
is_sensor_suspended
'
}
false
)
;
iframe
.
contentWindow
.
focus
(
)
;
sensor
.
start
(
)
;
await
sensorWatcher
.
wait_for
(
'
reading
'
)
;
assert_greater_than
(
sensor
.
timestamp
cachedTimeStamp
)
;
sensor
.
stop
(
)
;
await
send_message_to_iframe
(
iframe
{
command
:
'
reset_sensor_backend
'
}
)
;
}
{
sensorName
}
:
sensor
is
not
suspended
when
focus
traverses
from
\
to
same
-
origin
frame
)
;
sensor_test
(
async
t
=
>
{
assert_implements
(
sensorName
in
self
{
sensorName
}
is
not
supported
.
)
;
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
allow
=
featurePolicies
.
join
(
'
;
'
)
+
'
;
'
;
iframe
.
src
=
'
https
:
/
/
{
{
host
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
/
generic
-
sensor
/
resources
/
iframe_sensor_handler
.
html
'
;
const
iframeLoadWatcher
=
new
EventWatcher
(
t
iframe
'
load
'
)
;
document
.
body
.
appendChild
(
iframe
)
;
await
iframeLoadWatcher
.
wait_for
(
'
load
'
)
;
await
send_message_to_iframe
(
iframe
{
command
:
'
create_sensor
'
type
:
sensorName
}
)
;
iframe
.
contentWindow
.
focus
(
)
;
await
send_message_to_iframe
(
iframe
{
command
:
'
start_sensor
'
}
)
;
iframe
.
parentNode
.
removeChild
(
iframe
)
;
window
.
focus
(
)
;
}
{
sensorName
}
:
losing
a
document
'
s
frame
with
an
active
sensor
does
not
crash
)
;
}
