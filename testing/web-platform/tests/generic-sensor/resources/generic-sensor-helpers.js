'
use
strict
'
;
const
loadChromiumResources
=
async
(
)
=
>
{
if
(
!
(
'
MojoInterfaceInterceptor
'
in
self
)
)
{
return
;
}
const
resources
=
[
'
/
gen
/
layout_test_data
/
mojo
/
public
/
js
/
mojo_bindings
.
js
'
'
/
gen
/
mojo
/
public
/
mojom
/
base
/
string16
.
mojom
.
js
'
'
/
gen
/
services
/
device
/
public
/
mojom
/
sensor
.
mojom
.
js
'
'
/
gen
/
services
/
device
/
public
/
mojom
/
sensor_provider
.
mojom
.
js
'
'
/
resources
/
testdriver
.
js
'
'
/
resources
/
testdriver
-
vendor
.
js
'
'
/
resources
/
chromium
/
generic_sensor_mocks
.
js
'
]
;
await
Promise
.
all
(
resources
.
map
(
path
=
>
{
const
script
=
document
.
createElement
(
'
script
'
)
;
script
.
src
=
path
;
script
.
async
=
false
;
const
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
script
.
onload
=
resolve
;
script
.
onerror
=
reject
;
}
)
;
document
.
head
.
appendChild
(
script
)
;
return
promise
;
}
)
)
;
}
;
async
function
initialize_generic_sensor_tests
(
)
{
if
(
typeof
GenericSensorTest
=
=
=
'
undefined
'
)
{
await
loadChromiumResources
(
)
;
}
assert_true
(
typeof
GenericSensorTest
!
=
=
'
undefined
'
'
Mojo
testing
interface
is
not
available
.
'
)
;
let
sensorTest
=
new
GenericSensorTest
(
)
;
await
sensorTest
.
initialize
(
)
;
return
sensorTest
;
}
function
sensor_test
(
func
name
properties
)
{
promise_test
(
async
(
t
)
=
>
{
t
.
add_cleanup
(
(
)
=
>
{
if
(
sensorTest
)
return
sensorTest
.
reset
(
)
;
}
)
;
let
sensorTest
=
await
initialize_generic_sensor_tests
(
)
;
return
func
(
t
sensorTest
.
getSensorProvider
(
)
)
;
}
name
properties
)
;
}
function
verifySensorReading
(
pattern
values
timestamp
isNull
)
{
function
round
(
val
)
{
const
res
=
Number
.
parseFloat
(
val
)
.
toPrecision
(
6
)
;
return
res
=
=
=
"
NaN
"
?
val
:
res
;
}
if
(
isNull
)
{
return
(
values
=
=
=
null
|
|
values
.
every
(
r
=
>
r
=
=
=
null
)
)
&
&
timestamp
=
=
=
null
;
}
return
values
.
every
(
(
r
i
)
=
>
round
(
r
)
=
=
=
round
(
pattern
[
i
]
)
)
&
&
timestamp
!
=
=
null
;
}
function
verifyXyzSensorReading
(
pattern
{
x
y
z
timestamp
}
isNull
)
{
return
verifySensorReading
(
pattern
[
x
y
z
]
timestamp
isNull
)
;
}
function
verifyQuatSensorReading
(
pattern
{
quaternion
timestamp
}
isNull
)
{
return
verifySensorReading
(
pattern
quaternion
timestamp
isNull
)
;
}
function
verifyAlsSensorReading
(
pattern
{
illuminance
timestamp
}
isNull
)
{
return
verifySensorReading
(
pattern
[
illuminance
]
timestamp
isNull
)
;
}
function
verifyGeoSensorReading
(
pattern
{
latitude
longitude
altitude
accuracy
altitudeAccuracy
heading
speed
timestamp
}
isNull
)
{
return
verifySensorReading
(
pattern
[
latitude
longitude
altitude
accuracy
altitudeAccuracy
heading
speed
]
timestamp
isNull
)
;
}
function
verifyProximitySensorReading
(
pattern
{
distance
max
near
timestamp
}
isNull
)
{
return
verifySensorReading
(
pattern
[
distance
max
near
]
timestamp
isNull
)
;
}
