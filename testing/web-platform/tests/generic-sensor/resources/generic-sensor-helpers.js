'
use
strict
'
;
async
function
loadChromiumResources
(
)
{
await
loadScript
(
'
/
resources
/
testdriver
.
js
'
)
;
await
loadScript
(
'
/
resources
/
testdriver
-
vendor
.
js
'
)
;
await
import
(
'
/
resources
/
chromium
/
generic_sensor_mocks
.
js
'
)
;
}
async
function
initialize_generic_sensor_tests
(
)
{
if
(
typeof
GenericSensorTest
=
=
=
'
undefined
'
)
{
const
script
=
document
.
createElement
(
'
script
'
)
;
script
.
src
=
'
/
resources
/
test
-
only
-
api
.
js
'
;
script
.
async
=
false
;
const
p
=
new
Promise
(
(
resolve
reject
)
=
>
{
script
.
onload
=
(
)
=
>
{
resolve
(
)
;
}
;
script
.
onerror
=
e
=
>
{
reject
(
e
)
;
}
;
}
)
document
.
head
.
appendChild
(
script
)
;
await
p
;
if
(
isChromiumBased
)
{
await
loadChromiumResources
(
)
;
}
}
let
sensorTest
=
new
GenericSensorTest
(
)
;
await
sensorTest
.
initialize
(
)
;
return
sensorTest
;
}
function
sensor_test
(
func
name
properties
)
{
promise_test
(
async
(
t
)
=
>
{
t
.
add_cleanup
(
(
)
=
>
{
if
(
sensorTest
)
return
sensorTest
.
reset
(
)
;
}
)
;
let
sensorTest
=
await
initialize_generic_sensor_tests
(
)
;
return
func
(
t
sensorTest
.
getSensorProvider
(
)
)
;
}
name
properties
)
;
}
function
verifySensorReading
(
pattern
values
timestamp
isNull
)
{
function
round
(
val
)
{
const
res
=
Number
.
parseFloat
(
val
)
.
toPrecision
(
6
)
;
return
res
=
=
=
"
NaN
"
?
val
:
res
;
}
if
(
isNull
)
{
return
(
values
=
=
=
null
|
|
values
.
every
(
r
=
>
r
=
=
=
null
)
)
&
&
timestamp
=
=
=
null
;
}
return
values
.
every
(
(
r
i
)
=
>
round
(
r
)
=
=
=
round
(
pattern
[
i
]
)
)
&
&
timestamp
!
=
=
null
;
}
function
verifyXyzSensorReading
(
pattern
{
x
y
z
timestamp
}
isNull
)
{
return
verifySensorReading
(
pattern
[
x
y
z
]
timestamp
isNull
)
;
}
function
verifyQuatSensorReading
(
pattern
{
quaternion
timestamp
}
isNull
)
{
return
verifySensorReading
(
pattern
quaternion
timestamp
isNull
)
;
}
function
verifyAlsSensorReading
(
pattern
{
illuminance
timestamp
}
isNull
)
{
return
verifySensorReading
(
pattern
[
illuminance
]
timestamp
isNull
)
;
}
function
verifyGeoSensorReading
(
pattern
{
latitude
longitude
altitude
accuracy
altitudeAccuracy
heading
speed
timestamp
}
isNull
)
{
return
verifySensorReading
(
pattern
[
latitude
longitude
altitude
accuracy
altitudeAccuracy
heading
speed
]
timestamp
isNull
)
;
}
function
verifyProximitySensorReading
(
pattern
{
distance
max
near
timestamp
}
isNull
)
{
return
verifySensorReading
(
pattern
[
distance
max
near
]
timestamp
isNull
)
;
}
function
assert_sensor_equals
(
actual
expected
)
{
assert_true
(
actual
instanceof
Sensor
'
assert_sensor_equals
:
actual
must
be
a
Sensor
'
)
;
assert_true
(
expected
instanceof
Sensor
'
assert_sensor_equals
:
expected
must
be
a
Sensor
'
)
;
const
CUSTOM_PROPERTIES
=
[
[
'
illuminance
'
]
[
'
quaternion
'
]
[
'
x
'
'
y
'
'
z
'
]
[
'
latitude
'
'
longitude
'
'
altitude
'
'
accuracy
'
'
altitudeAccuracy
'
'
heading
'
'
speed
'
]
]
;
const
GENERAL_PROPERTIES
=
[
'
timestamp
'
]
;
for
(
let
customProperties
of
CUSTOM_PROPERTIES
)
{
if
(
customProperties
.
every
(
p
=
>
p
in
actual
)
&
&
customProperties
.
every
(
p
=
>
p
in
expected
)
)
{
customProperties
.
forEach
(
p
=
>
{
if
(
customProperties
=
=
'
quaternion
'
)
{
assert_array_equals
(
actual
[
p
]
expected
[
p
]
assert_sensor_equals
:
property
'
{
p
}
'
does
not
match
)
;
}
else
{
assert_equals
(
actual
[
p
]
expected
[
p
]
assert_sensor_equals
:
property
'
{
p
}
'
does
not
match
)
;
}
}
)
;
GENERAL_PROPERTIES
.
forEach
(
p
=
>
{
assert_equals
(
actual
[
p
]
expected
[
p
]
assert_sensor_equals
:
property
'
{
p
}
'
does
not
match
)
;
}
)
;
return
;
}
}
assert_true
(
false
'
assert_sensor_equals
:
sensors
have
different
attributes
'
)
;
}
