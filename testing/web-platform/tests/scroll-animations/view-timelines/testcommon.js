'
use
strict
'
;
function
assert_px_equals
(
observed
expected
description
)
{
assert_equals
(
observed
.
unit
'
px
'
Unexpected
unit
type
for
'
{
description
}
'
)
;
assert_approx_equals
(
observed
.
value
expected
0
.
0001
Unexpected
value
for
{
description
}
)
;
}
function
CreateViewTimelineOpacityAnimation
(
test
target
options
)
{
const
viewTimelineOptions
=
{
subject
:
target
axis
:
'
block
'
}
;
if
(
options
)
{
for
(
let
key
in
options
)
{
viewTimelineOptions
[
key
]
=
options
[
key
]
;
}
}
const
anim
=
target
.
animate
(
{
opacity
:
[
0
.
3
0
.
7
]
}
{
timeline
:
new
ViewTimeline
(
viewTimelineOptions
)
}
)
;
test
.
add_cleanup
(
(
)
=
>
{
anim
.
cancel
(
)
;
}
)
;
return
anim
;
}
async
function
runTimelineBoundsTest
(
t
options
message
)
{
container
.
scrollLeft
=
0
;
await
waitForNextFrame
(
)
;
const
anim
=
options
.
anim
|
|
CreateViewTimelineOpacityAnimation
(
t
target
options
.
timeline
)
;
if
(
options
.
timing
)
anim
.
effect
.
updateTiming
(
options
.
timing
)
;
const
timeline
=
anim
.
timeline
;
await
anim
.
ready
;
container
.
scrollLeft
=
options
.
startOffset
;
await
waitForNextFrame
(
)
;
assert_equals
(
getComputedStyle
(
target
)
.
opacity
'
0
.
3
'
Effect
at
the
start
of
the
active
phase
:
{
message
}
)
;
container
.
scrollLeft
=
(
options
.
startOffset
+
options
.
endOffset
)
/
2
;
await
waitForNextFrame
(
)
;
assert_equals
(
getComputedStyle
(
target
)
.
opacity
'
0
.
5
'
Effect
at
the
midpoint
of
the
active
range
:
{
message
}
)
;
container
.
scrollLeft
=
options
.
endOffset
;
await
waitForNextFrame
(
)
;
assert_equals
(
getComputedStyle
(
target
)
.
opacity
'
0
.
7
'
Effect
is
in
the
active
phase
at
effect
end
time
:
{
message
}
)
;
return
anim
;
}
async
function
runTimelineRangeTest
(
t
options
)
{
const
rangeToString
=
range
=
>
{
const
parts
=
[
]
;
if
(
range
.
rangeName
)
parts
.
push
(
range
.
rangeName
)
;
if
(
range
.
offset
)
parts
.
push
(
{
range
.
offset
.
value
}
%
)
;
return
parts
.
join
(
'
'
)
;
}
;
const
range
=
{
rangeToString
(
options
.
rangeStart
)
}
to
+
{
rangeToString
(
options
.
rangeEnd
)
}
;
options
.
timeline
=
{
axis
:
'
inline
'
}
;
options
.
timing
=
{
rangeStart
:
options
.
rangeStart
rangeEnd
:
options
.
rangeEnd
fill
:
'
both
'
}
;
return
runTimelineBoundsTest
(
t
options
range
)
;
}
async
function
runTimelineInsetTest
(
t
options
)
{
options
.
timeline
=
{
axis
:
'
inline
'
inset
:
options
.
inset
}
;
options
.
timing
=
{
fill
:
'
both
'
}
const
length
=
options
.
inset
.
length
;
const
range
=
(
options
.
inset
instanceof
Array
)
?
options
.
inset
.
join
(
'
'
)
:
options
.
inset
;
return
runTimelineBoundsTest
(
t
options
range
)
;
}
