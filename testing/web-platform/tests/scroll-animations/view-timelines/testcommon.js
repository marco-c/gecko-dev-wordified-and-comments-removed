'
use
strict
'
;
function
CreateViewTimelineOpacityAnimation
(
test
target
orientation
=
'
block
'
)
{
const
anim
=
target
.
animate
(
{
opacity
:
[
0
.
3
0
.
7
]
}
{
timeline
:
new
ViewTimeline
(
{
subject
:
target
axis
:
orientation
}
)
fill
:
'
none
'
}
)
;
test
.
add_cleanup
(
(
)
=
>
{
anim
.
cancel
(
)
;
}
)
;
return
anim
;
}
async
function
runTimelineDelayTest
(
t
options
)
{
container
.
scrollLeft
=
0
;
await
waitForNextFrame
(
)
;
const
anim
=
CreateViewTimelineOpacityAnimation
(
t
target
'
inline
'
)
;
anim
.
effect
.
updateTiming
(
{
delay
:
options
.
delay
endDelay
:
options
.
endDelay
fill
:
'
both
'
}
)
;
const
timeline
=
anim
.
timeline
;
await
anim
.
ready
;
const
delayToString
=
delay
=
>
{
const
parts
=
[
]
;
if
(
delay
.
phase
)
parts
.
push
(
delay
.
phase
)
;
if
(
delay
.
percent
)
parts
.
push
(
{
delay
.
percent
.
value
}
%
)
;
return
parts
.
join
(
'
'
)
;
}
;
container
.
scrollLeft
=
options
.
rangeStart
;
await
waitForNextFrame
(
)
;
const
range
=
{
delayToString
(
options
.
delay
)
}
to
+
{
delayToString
(
options
.
endDelay
)
}
;
assert_equals
(
getComputedStyle
(
target
)
.
opacity
'
0
.
3
'
Effect
at
the
start
of
the
active
phase
:
{
range
}
)
;
container
.
scrollLeft
=
(
options
.
rangeStart
+
options
.
rangeEnd
)
/
2
;
await
waitForNextFrame
(
)
;
assert_equals
(
getComputedStyle
(
target
)
.
opacity
'
0
.
5
'
Effect
at
the
midpoint
of
the
active
range
:
{
range
}
)
;
container
.
scrollLeft
=
options
.
rangeEnd
;
await
waitForNextFrame
(
)
;
assert_equals
(
getComputedStyle
(
target
)
.
opacity
'
0
.
7
'
Effect
is
in
the
active
phase
at
effect
end
time
:
{
range
}
)
;
}
