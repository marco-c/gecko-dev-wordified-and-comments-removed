let
polyfillExports
;
let
builtinExports
;
setup
(
(
)
=
>
{
const
builder
=
new
WasmModuleBuilder
(
)
;
const
arrayIndex
=
builder
.
addArray
(
kWasmI16
true
kNoSuperType
true
)
;
const
builtins
=
[
{
name
:
"
test
"
params
:
[
kWasmExternRef
]
results
:
[
kWasmI32
]
}
{
name
:
"
cast
"
params
:
[
kWasmExternRef
]
results
:
[
wasmRefType
(
kWasmExternRef
)
]
}
{
name
:
"
fromCharCodeArray
"
params
:
[
wasmRefNullType
(
arrayIndex
)
kWasmI32
kWasmI32
]
results
:
[
wasmRefType
(
kWasmExternRef
)
]
}
{
name
:
"
intoCharCodeArray
"
params
:
[
kWasmExternRef
wasmRefNullType
(
arrayIndex
)
kWasmI32
]
results
:
[
kWasmI32
]
}
{
name
:
"
fromCharCode
"
params
:
[
kWasmI32
]
results
:
[
wasmRefType
(
kWasmExternRef
)
]
}
{
name
:
"
fromCodePoint
"
params
:
[
kWasmI32
]
results
:
[
wasmRefType
(
kWasmExternRef
)
]
}
{
name
:
"
charCodeAt
"
params
:
[
kWasmExternRef
kWasmI32
]
results
:
[
kWasmI32
]
}
{
name
:
"
codePointAt
"
params
:
[
kWasmExternRef
kWasmI32
]
results
:
[
kWasmI32
]
}
{
name
:
"
length
"
params
:
[
kWasmExternRef
]
results
:
[
kWasmI32
]
}
{
name
:
"
concat
"
params
:
[
kWasmExternRef
kWasmExternRef
]
results
:
[
wasmRefType
(
kWasmExternRef
)
]
}
{
name
:
"
substring
"
params
:
[
kWasmExternRef
kWasmI32
kWasmI32
]
results
:
[
wasmRefType
(
kWasmExternRef
)
]
}
{
name
:
"
equals
"
params
:
[
kWasmExternRef
kWasmExternRef
]
results
:
[
kWasmI32
]
}
{
name
:
"
compare
"
params
:
[
kWasmExternRef
kWasmExternRef
]
results
:
[
kWasmI32
]
}
]
;
for
(
let
builtin
of
builtins
)
{
builtin
.
type
=
builder
.
addType
(
{
params
:
builtin
.
params
results
:
builtin
.
results
}
)
;
}
for
(
let
builtin
of
builtins
)
{
builtin
.
importFuncIndex
=
builder
.
addImport
(
"
wasm
:
js
-
string
"
builtin
.
name
builtin
.
type
)
;
}
for
(
let
builtin
of
builtins
)
{
let
func
=
builder
.
addFunction
(
builtin
.
name
+
"
Imp
"
builtin
.
type
)
;
func
.
addLocals
(
builtin
.
params
.
length
)
;
let
body
=
[
]
;
for
(
let
i
=
0
;
i
<
builtin
.
params
.
length
;
i
+
+
)
{
body
.
push
(
kExprLocalGet
)
;
body
.
push
(
.
.
.
wasmSignedLeb
(
i
)
)
;
}
body
.
push
(
kExprCallFunction
)
;
body
.
push
(
.
.
.
wasmSignedLeb
(
builtin
.
importFuncIndex
)
)
;
func
.
addBody
(
body
)
;
func
.
exportAs
(
builtin
.
name
)
;
}
const
buffer
=
builder
.
toBuffer
(
)
;
const
builtinModule
=
new
WebAssembly
.
Module
(
buffer
{
builtins
:
[
"
js
-
string
"
]
}
)
;
const
builtinInstance
=
new
WebAssembly
.
Instance
(
builtinModule
{
}
)
;
builtinExports
=
builtinInstance
.
exports
;
const
polyfillModule
=
new
WebAssembly
.
Module
(
buffer
)
;
const
polyfillInstance
=
new
WebAssembly
.
Instance
(
polyfillModule
{
"
wasm
:
js
-
string
"
:
polyfillImports
}
)
;
polyfillExports
=
polyfillInstance
.
exports
;
}
)
;
function
assert_same_behavior
(
funcA
funcB
.
.
.
params
)
{
let
resultA
;
let
errA
=
null
;
try
{
resultA
=
funcA
(
.
.
.
params
)
;
}
catch
(
err
)
{
errA
=
err
;
}
let
resultB
;
let
errB
=
null
;
try
{
resultB
=
funcB
(
.
.
.
params
)
;
}
catch
(
err
)
{
errB
=
err
;
}
if
(
errA
|
|
errB
)
{
assert_equals
(
errA
=
=
=
null
errB
=
=
=
null
errA
?
errA
.
message
:
errB
.
message
)
;
assert_equals
(
Object
.
getPrototypeOf
(
errA
)
Object
.
getPrototypeOf
(
errB
)
)
;
}
assert_equals
(
resultA
resultB
)
;
if
(
errA
)
{
throw
errA
;
}
return
resultA
;
}
function
assert_throws_if
(
func
shouldThrow
constructor
)
{
let
error
=
null
;
try
{
func
(
)
;
}
catch
(
e
)
{
error
=
e
;
}
assert_equals
(
error
!
=
=
null
shouldThrow
"
shouldThrow
mismatch
"
)
;
if
(
shouldThrow
&
&
error
!
=
=
null
)
{
assert_true
(
error
instanceof
constructor
)
;
}
}
const
testStrings
=
[
"
"
"
a
"
"
1
"
"
ab
"
"
hello
world
"
"
\
n
"
"
"
"
"
String
.
fromCodePoint
(
0x10000
0x10001
)
]
;
const
testCharCodes
=
[
1
2
3
10
0x7f
0xff
0xfffe
0xffff
]
;
const
testCodePoints
=
[
1
2
3
10
0x7f
0xff
0xfffe
0xffff
0x10000
0x10001
]
;
const
testExternRefValues
=
[
null
undefined
true
false
{
x
:
1337
}
[
"
abracadabra
"
]
13
.
37
-
0
0x7fffffff
+
0
.
1
-
0x7fffffff
-
0
.
1
0x80000000
+
0
.
1
-
0x80000000
-
0
.
1
0xffffffff
+
0
.
1
-
0xffffffff
-
0
.
1
Number
.
EPSILON
Number
.
MAX_SAFE_INTEGER
Number
.
MIN_SAFE_INTEGER
Number
.
MIN_VALUE
Number
.
MAX_VALUE
Number
.
NaN
"
hi
"
37n
new
Number
(
42
)
new
Boolean
(
true
)
Symbol
(
"
status
"
)
(
)
=
>
1337
]
;
test
(
(
)
=
>
{
for
(
let
a
of
testExternRefValues
)
{
let
isString
=
assert_same_behavior
(
builtinExports
[
'
test
'
]
polyfillExports
[
'
test
'
]
a
)
;
assert_throws_if
(
(
)
=
>
assert_same_behavior
(
builtinExports
[
'
cast
'
]
polyfillExports
[
'
cast
'
]
a
)
!
isString
WebAssembly
.
RuntimeError
)
;
let
arrayMutI16
=
helperExports
.
createArrayMutI16
(
10
)
;
assert_throws_if
(
(
)
=
>
assert_same_behavior
(
builtinExports
[
'
intoCharCodeArray
'
]
polyfillExports
[
'
intoCharCodeArray
'
]
a
arrayMutI16
0
)
!
isString
WebAssembly
.
RuntimeError
)
;
assert_throws_if
(
(
)
=
>
assert_same_behavior
(
builtinExports
[
'
charCodeAt
'
]
polyfillExports
[
'
charCodeAt
'
]
a
0
)
!
isString
WebAssembly
.
RuntimeError
)
;
assert_throws_if
(
(
)
=
>
assert_same_behavior
(
builtinExports
[
'
codePointAt
'
]
polyfillExports
[
'
codePointAt
'
]
a
0
)
!
isString
WebAssembly
.
RuntimeError
)
;
assert_throws_if
(
(
)
=
>
assert_same_behavior
(
builtinExports
[
'
length
'
]
polyfillExports
[
'
length
'
]
a
)
!
isString
WebAssembly
.
RuntimeError
)
;
assert_throws_if
(
(
)
=
>
assert_same_behavior
(
builtinExports
[
'
concat
'
]
polyfillExports
[
'
concat
'
]
a
a
)
!
isString
WebAssembly
.
RuntimeError
)
;
assert_throws_if
(
(
)
=
>
assert_same_behavior
(
builtinExports
[
'
substring
'
]
polyfillExports
[
'
substring
'
]
a
0
0
)
!
isString
WebAssembly
.
RuntimeError
)
;
assert_throws_if
(
(
)
=
>
assert_same_behavior
(
builtinExports
[
'
equals
'
]
polyfillExports
[
'
equals
'
]
a
a
)
a
!
=
=
null
&
&
!
isString
WebAssembly
.
RuntimeError
)
;
assert_throws_if
(
(
)
=
>
assert_same_behavior
(
builtinExports
[
'
compare
'
]
polyfillExports
[
'
compare
'
]
a
a
)
!
isString
WebAssembly
.
RuntimeError
)
;
}
}
)
;
test
(
(
)
=
>
{
for
(
let
a
of
testCharCodes
)
{
assert_same_behavior
(
builtinExports
[
'
fromCharCode
'
]
polyfillExports
[
'
fromCharCode
'
]
a
)
;
}
}
)
;
test
(
(
)
=
>
{
for
(
let
a
of
testCodePoints
)
{
assert_same_behavior
(
builtinExports
[
'
fromCodePoint
'
]
polyfillExports
[
'
fromCodePoint
'
]
a
)
;
}
}
)
;
test
(
(
)
=
>
{
for
(
let
a
of
testStrings
)
{
let
length
=
assert_same_behavior
(
builtinExports
[
'
length
'
]
polyfillExports
[
'
length
'
]
a
)
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
let
charCode
=
assert_same_behavior
(
builtinExports
[
'
charCodeAt
'
]
polyfillExports
[
'
charCodeAt
'
]
a
i
)
;
}
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
let
charCode
=
assert_same_behavior
(
builtinExports
[
'
codePointAt
'
]
polyfillExports
[
'
codePointAt
'
]
a
i
)
;
}
let
arrayMutI16
=
helperExports
.
createArrayMutI16
(
length
)
;
assert_same_behavior
(
builtinExports
[
'
intoCharCodeArray
'
]
polyfillExports
[
'
intoCharCodeArray
'
]
a
arrayMutI16
0
)
;
assert_same_behavior
(
builtinExports
[
'
fromCharCodeArray
'
]
polyfillExports
[
'
fromCharCodeArray
'
]
arrayMutI16
0
length
)
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
length
;
j
+
+
)
{
assert_same_behavior
(
builtinExports
[
'
substring
'
]
polyfillExports
[
'
substring
'
]
a
i
j
)
;
}
}
}
}
)
;
test
(
(
)
=
>
{
for
(
let
a
of
testStrings
)
{
for
(
let
b
of
testStrings
)
{
assert_same_behavior
(
builtinExports
[
'
concat
'
]
polyfillExports
[
'
concat
'
]
a
b
)
;
assert_same_behavior
(
builtinExports
[
'
equals
'
]
polyfillExports
[
'
equals
'
]
a
b
)
;
assert_same_behavior
(
builtinExports
[
'
compare
'
]
polyfillExports
[
'
compare
'
]
a
b
)
;
}
}
}
)
;
