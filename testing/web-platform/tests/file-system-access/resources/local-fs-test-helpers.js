const
directory_promise
=
(
async
(
)
=
>
{
await
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
'
DOMContentLoaded
'
resolve
)
;
}
)
;
await
new
Promise
(
resolve
=
>
step_timeout
(
resolve
100
)
)
;
await
window
.
test_driver
.
bless
(
'
show
a
file
picker
.
<
br
/
>
Please
select
an
empty
directory
'
)
;
const
entries
=
await
self
.
showDirectoryPicker
(
)
;
assert_true
(
entries
instanceof
FileSystemHandle
)
;
assert_true
(
entries
instanceof
FileSystemDirectoryHandle
)
;
for
await
(
const
entry
of
entries
)
{
assert_unreached
(
'
Selected
directory
is
not
empty
'
)
;
}
return
entries
;
}
)
(
)
;
function
directory_test
(
func
description
)
{
promise_test
(
async
t
=
>
{
const
directory
=
await
directory_promise
;
for
await
(
let
entry
of
directory
.
values
(
)
)
{
await
directory
.
removeEntry
(
entry
.
name
{
recursive
:
entry
.
kind
=
=
=
'
directory
'
}
)
;
}
await
func
(
t
directory
)
;
}
description
)
;
}
directory_test
(
async
(
t
dir
)
=
>
{
assert_equals
(
await
dir
.
queryPermission
(
{
mode
:
'
read
'
}
)
'
granted
'
)
;
}
'
User
succesfully
selected
an
empty
directory
.
'
)
;
directory_test
(
async
(
t
dir
)
=
>
{
const
status
=
await
dir
.
queryPermission
(
{
mode
:
'
readwrite
'
}
)
;
if
(
status
=
=
'
granted
'
)
return
;
await
window
.
test_driver
.
bless
(
'
ask
for
write
permission
'
)
;
assert_equals
(
await
dir
.
requestPermission
(
{
mode
:
'
readwrite
'
}
)
'
granted
'
)
;
}
'
User
granted
write
access
.
'
)
;
const
child_frame_js
=
(
origin
frameFn
done
)
=
>
const
importScript
=
{
importScript
}
;
await
importScript
(
"
/
html
/
cross
-
origin
-
embedder
-
policy
/
credentialless
"
+
"
/
resources
/
common
.
js
"
)
;
await
importScript
(
"
/
html
/
anonymous
-
iframe
/
resources
/
common
.
js
"
)
;
await
importScript
(
"
/
common
/
utils
.
js
"
)
;
await
send
(
"
{
done
}
"
{
frameFn
}
(
"
{
origin
}
"
)
)
;
;
const
FRAME_CONTEXT
=
{
firstParty
:
0
thirdPartySameSite
:
1
thirdPartySameSite_AncestorBit
:
2
thirdPartyCrossSite
:
3
anonymousFrameSameSite
:
4
anonymousFrameSameSite_AncestorBit
:
5
anonymousFrameCrossSite
:
6
}
;
const
sameSiteContexts
=
[
FRAME_CONTEXT
.
firstParty
FRAME_CONTEXT
.
thirdPartySameSite
FRAME_CONTEXT
.
anonymousFrameSameSite
]
;
const
crossSiteContexts
=
[
FRAME_CONTEXT
.
thirdPartyCrossSite
FRAME_CONTEXT
.
anonymousFrameCrossSite
]
;
const
childContexts
=
[
FRAME_CONTEXT
.
thirdPartySameSite
FRAME_CONTEXT
.
thirdPartyCrossSite
FRAME_CONTEXT
.
anonymousFrameSameSite
FRAME_CONTEXT
.
anonymousFrameCrossSite
]
;
function
framed_test
(
func
description
)
{
const
same_site_origin
=
get_host_info
(
)
.
HTTPS_ORIGIN
;
const
cross_site_origin
=
get_host_info
(
)
.
HTTPS_NOTSAMESITE_ORIGIN
;
const
frames
=
Object
.
values
(
FRAME_CONTEXT
)
;
promise_test
(
async
(
t
)
=
>
{
return
new
Promise
(
async
(
resolve
reject
)
=
>
{
try
{
const
directory
=
await
directory_promise
;
for
await
(
let
entry
of
directory
.
values
(
)
)
{
await
directory
.
removeEntry
(
entry
.
name
{
recursive
:
entry
.
kind
=
=
=
'
directory
'
}
)
;
}
const
handles
=
[
null
newIframe
(
same_site_origin
)
null
newIframe
(
cross_site_origin
)
newAnonymousIframe
(
same_site_origin
)
null
newAnonymousIframe
(
cross_site_origin
)
]
;
const
setUpQueue
=
token
(
)
;
send
(
newIframe
(
cross_site_origin
)
child_frame_js
(
same_site_origin
"
newIframe
"
setUpQueue
)
)
;
handles
[
FRAME_CONTEXT
.
thirdPartySameSite_AncestorBit
]
=
await
receive
(
setUpQueue
)
;
send
(
newAnonymousIframe
(
cross_site_origin
)
child_frame_js
(
same_site_origin
"
newAnonymousIframe
"
setUpQueue
)
)
;
handles
[
FRAME_CONTEXT
.
anonymousFrameSameSite_AncestorBit
]
=
await
receive
(
setUpQueue
)
;
const
sendTo
=
(
contexts
js_generator
)
=
>
{
return
Promise
.
all
(
contexts
.
map
(
async
(
context
)
=
>
{
const
queue
=
token
(
)
;
const
js_string
=
js_generator
(
queue
context
)
;
switch
(
context
)
{
case
FRAME_CONTEXT
.
firstParty
:
eval
(
(
async
(
)
=
>
{
{
js_string
}
}
)
(
)
)
;
break
;
case
FRAME_CONTEXT
.
thirdPartySameSite
:
case
FRAME_CONTEXT
.
thirdPartyCrossSite
:
case
FRAME_CONTEXT
.
anonymousFrameSameSite
:
case
FRAME_CONTEXT
.
anonymousFrameCrossSite
:
case
FRAME_CONTEXT
.
thirdPartySameSite_AncestorBit
:
case
FRAME_CONTEXT
.
anonymousFrameSameSite_AncestorBit
:
send
(
handles
[
context
]
js_string
)
;
break
;
default
:
reject
(
Cannot
execute
in
context
:
{
context
}
)
;
}
if
(
await
receive
(
queue
)
!
=
"
done
"
)
{
reject
(
Script
failed
in
frame
{
context
}
:
{
js_string
}
)
;
}
}
)
)
;
}
;
await
func
(
t
sendTo
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
resolve
(
)
;
}
)
;
}
description
)
;
}
