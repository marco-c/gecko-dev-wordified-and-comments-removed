'
use
strict
'
;
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
bgFetch
.
fetch
(
uniqueId
(
)
'
https
:
/
/
example
.
com
'
)
;
}
'
https
:
fetch
should
register
ok
'
)
;
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
bgFetch
.
fetch
(
uniqueId
(
)
'
http
:
/
/
127
.
0
.
0
.
1
'
)
;
}
'
loopback
IPv4
http
:
fetch
should
register
ok
'
)
;
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
bgFetch
.
fetch
(
uniqueId
(
)
'
http
:
/
/
[
:
:
1
]
'
)
;
}
'
loopback
IPv6
http
:
fetch
should
register
ok
'
)
;
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
bgFetch
.
fetch
(
uniqueId
(
)
'
http
:
/
/
localhost
'
)
;
}
'
localhost
http
:
fetch
should
register
ok
'
)
;
function
testBgFetch
(
bgFetch
url
)
{
return
bgFetch
.
fetch
(
uniqueId
(
)
url
)
.
then
(
fetch
=
>
{
return
fetch
.
match
(
url
)
;
}
)
.
then
(
match
=
>
match
.
responseReady
)
;
}
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
promise_rejects_js
(
t
TypeError
testBgFetch
(
bgFetch
'
wss
:
127
.
0
.
0
.
1
'
)
)
;
}
'
wss
:
fetch
should
reject
'
)
;
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
promise_rejects_js
(
t
TypeError
testBgFetch
(
bgFetch
'
file
:
/
/
/
'
)
)
;
}
'
file
:
fetch
should
reject
'
)
;
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
promise_rejects_js
(
t
TypeError
testBgFetch
(
bgFetch
'
data
:
text
/
plain
foo
'
)
)
;
}
'
data
:
fetch
should
reject
'
)
;
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
promise_rejects_js
(
t
TypeError
testBgFetch
(
bgFetch
'
foobar
:
bazqux
'
)
)
;
}
'
unknown
scheme
fetch
should
reject
'
)
;
