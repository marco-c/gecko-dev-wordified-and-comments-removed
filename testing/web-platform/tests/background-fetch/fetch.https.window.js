'
use
strict
'
;
const
wait
=
milliseconds
=
>
new
Promise
(
resolve
=
>
step_timeout
(
resolve
milliseconds
)
)
;
promise_test
(
async
test
=
>
{
const
script
=
'
service_workers
/
sw
.
js
'
;
const
scope
=
'
service_workers
/
'
+
location
.
pathname
;
const
serviceWorkerRegistration
=
await
service_worker_unregister_and_register
(
test
script
scope
)
;
assert_equals
(
serviceWorkerRegistration
.
active
null
'
There
must
not
be
an
activated
worker
'
)
;
await
promise_rejects
(
test
new
TypeError
(
)
serviceWorkerRegistration
.
backgroundFetch
.
fetch
(
uniqueId
(
)
[
'
resources
/
feature
-
name
.
txt
'
]
)
'
fetch
(
)
must
reject
on
pending
and
installing
workers
'
)
;
}
'
Background
Fetch
requires
an
activated
Service
Worker
'
)
;
backgroundFetchTest
(
async
(
test
backgroundFetch
)
=
>
{
await
promise_rejects
(
test
new
TypeError
(
)
backgroundFetch
.
fetch
(
uniqueId
(
)
[
]
)
'
Empty
sequences
are
treated
as
NULL
'
)
;
await
promise_rejects
(
test
new
TypeError
(
)
backgroundFetch
.
fetch
(
uniqueId
(
)
'
https
:
/
/
user
:
pass
domain
/
secret
.
txt
'
)
'
Exceptions
thrown
in
the
Request
constructor
are
rethrown
'
)
;
{
const
request
=
new
Request
(
'
resources
/
feature
-
name
.
txt
'
{
mode
:
'
no
-
cors
'
}
)
;
await
promise_rejects
(
test
new
TypeError
(
)
backgroundFetch
.
fetch
(
uniqueId
(
)
request
)
'
Requests
must
not
be
in
no
-
cors
mode
'
)
;
}
}
'
Argument
verification
is
done
for
BackgroundFetchManager
.
fetch
(
)
'
)
;
backgroundFetchTest
(
async
(
test
backgroundFetch
)
=
>
{
return
promise_rejects
(
test
new
TypeError
(
)
Promise
.
all
(
[
backgroundFetch
.
fetch
(
'
my
-
id
'
'
resources
/
feature
-
name
.
txt
?
1
'
)
backgroundFetch
.
fetch
(
'
my
-
id
'
'
resources
/
feature
-
name
.
txt
?
2
'
)
]
)
)
;
}
'
IDs
must
be
unique
among
active
Background
Fetch
registrations
'
)
;
backgroundFetchTest
(
async
(
test
backgroundFetch
)
=
>
{
const
registrationId
=
uniqueId
(
)
;
const
registration
=
await
backgroundFetch
.
fetch
(
registrationId
'
'
)
;
assert_equals
(
registration
.
id
registrationId
)
;
const
{
type
eventRegistration
results
}
=
await
getMessageFromServiceWorker
(
)
;
assert_equals
(
'
backgroundfetchsuccess
'
type
)
;
assert_equals
(
eventRegistration
.
result
'
success
'
)
;
assert_equals
(
eventRegistration
.
failureReason
'
'
)
;
}
'
Empty
URL
is
OK
.
'
)
;
backgroundFetchTest
(
async
(
test
backgroundFetch
)
=
>
{
const
registrationId
=
uniqueId
(
)
;
const
registration
=
await
backgroundFetch
.
fetch
(
registrationId
'
resources
/
feature
-
name
.
txt
'
)
;
assert_equals
(
registration
.
id
registrationId
)
;
assert_equals
(
registration
.
uploadTotal
0
)
;
assert_equals
(
registration
.
uploaded
0
)
;
assert_equals
(
registration
.
downloadTotal
0
)
;
assert_equals
(
registration
.
result
'
'
)
;
assert_equals
(
registration
.
failureReason
'
'
)
;
assert_true
(
registration
.
recordsAvailable
)
;
const
{
type
eventRegistration
results
}
=
await
getMessageFromServiceWorker
(
)
;
assert_equals
(
'
backgroundfetchsuccess
'
type
)
;
assert_equals
(
results
.
length
1
)
;
assert_equals
(
eventRegistration
.
id
registration
.
id
)
;
assert_equals
(
eventRegistration
.
result
'
success
'
)
;
assert_equals
(
eventRegistration
.
failureReason
'
'
)
;
assert_true
(
results
[
0
]
.
url
.
includes
(
'
resources
/
feature
-
name
.
txt
'
)
)
;
assert_equals
(
results
[
0
]
.
status
200
)
;
assert_equals
(
results
[
0
]
.
text
'
Background
Fetch
'
)
;
}
'
Using
Background
Fetch
to
successfully
fetch
a
single
resource
'
)
;
backgroundFetchTest
(
async
(
test
backgroundFetch
)
=
>
{
const
registrationId
=
uniqueId
(
)
;
const
options
=
{
downloadTotal
:
Number
.
MAX_SAFE_INTEGER
}
;
await
promise_rejects
(
test
'
QUOTA_EXCEEDED_ERR
'
backgroundFetch
.
fetch
(
registrationId
'
resources
/
feature
-
name
.
txt
'
options
)
'
This
fetch
should
have
thrown
a
quota
exceeded
error
'
)
;
}
'
Background
Fetch
that
exceeds
the
quota
throws
a
QuotaExceededError
'
)
;
backgroundFetchTest
(
async
(
test
backgroundFetch
)
=
>
{
const
registration
=
await
backgroundFetch
.
fetch
(
'
my
-
id
'
[
'
resources
/
feature
-
name
.
txt
'
'
resources
/
feature
-
name
.
txt
'
]
)
;
const
{
type
eventRegistration
results
}
=
await
getMessageFromServiceWorker
(
)
;
assert_equals
(
'
backgroundfetchsuccess
'
type
)
;
assert_equals
(
results
.
length
2
)
;
assert_equals
(
eventRegistration
.
id
registration
.
id
)
;
assert_equals
(
eventRegistration
.
result
'
success
'
)
;
assert_equals
(
eventRegistration
.
failureReason
'
'
)
;
for
(
const
result
of
results
)
{
assert_true
(
result
.
url
.
includes
(
'
resources
/
feature
-
name
.
txt
'
)
)
;
assert_equals
(
result
.
status
200
)
;
assert_equals
(
result
.
text
'
Background
Fetch
'
)
;
}
}
'
Fetches
can
have
requests
with
duplicate
URLs
'
)
;
backgroundFetchTest
(
async
(
test
backgroundFetch
)
=
>
{
const
request
=
new
Request
(
'
resources
/
feature
-
name
.
txt
'
{
method
:
'
POST
'
body
:
'
TestBody
'
}
)
;
const
registration
=
await
backgroundFetch
.
fetch
(
'
my
-
id
'
request
)
;
const
{
type
eventRegistration
results
}
=
await
getMessageFromServiceWorker
(
)
;
assert_equals
(
'
backgroundfetchsuccess
'
type
)
;
assert_equals
(
results
.
length
1
)
;
assert_equals
(
eventRegistration
.
id
registration
.
id
)
;
assert_equals
(
eventRegistration
.
failureReason
'
'
)
;
assert_true
(
results
[
0
]
.
url
.
includes
(
'
resources
/
feature
-
name
.
txt
'
)
)
;
assert_equals
(
results
[
0
]
.
status
200
)
;
assert_equals
(
results
[
0
]
.
text
'
Background
Fetch
'
)
;
}
'
Fetches
can
have
requests
with
a
body
'
)
;
backgroundFetchTest
(
async
(
test
backgroundFetch
)
=
>
{
const
registrationId
=
uniqueId
(
)
;
const
registration
=
await
backgroundFetch
.
fetch
(
registrationId
'
resources
/
feature
-
name
.
txt
'
)
;
assert_true
(
registration
.
recordsAvailable
)
;
const
{
type
eventRegistration
results
}
=
await
getMessageFromServiceWorker
(
)
;
assert_equals
(
'
backgroundfetchsuccess
'
type
)
;
assert_equals
(
results
.
length
1
)
;
for
(
let
i
=
0
;
i
<
50
;
+
+
i
)
{
if
(
!
registration
.
recordsAvailable
)
break
;
await
wait
(
100
)
;
}
assert_false
(
registration
.
recordsAvailable
)
;
}
'
recordsAvailable
is
false
after
onbackgroundfetchsuccess
finishes
execution
.
'
)
;
backgroundFetchTest
(
async
(
test
backgroundFetch
)
=
>
{
const
registrationId
=
uniqueId
(
)
;
const
registration
=
await
backgroundFetch
.
fetch
(
registrationId
'
resources
/
missing
-
cat
.
txt
'
)
;
assert_equals
(
registration
.
id
registrationId
)
;
assert_equals
(
registration
.
result
'
'
)
;
assert_equals
(
registration
.
failureReason
'
'
)
;
const
{
type
eventRegistration
results
}
=
await
getMessageFromServiceWorker
(
)
;
assert_equals
(
type
'
backgroundfetchfail
'
)
;
assert_equals
(
results
.
length
1
)
;
assert_true
(
results
[
0
]
.
url
.
includes
(
'
resources
/
missing
-
cat
.
txt
'
)
)
;
assert_equals
(
results
[
0
]
.
status
404
)
;
assert_equals
(
results
[
0
]
.
text
'
'
)
;
assert_equals
(
eventRegistration
.
id
registration
.
id
)
;
assert_equals
(
eventRegistration
.
result
'
failure
'
)
;
assert_equals
(
eventRegistration
.
failureReason
'
bad
-
status
'
)
;
}
'
Using
Background
Fetch
to
fetch
a
non
-
existent
resource
should
fail
.
'
)
;
backgroundFetchTest
(
async
(
test
backgroundFetch
)
=
>
{
const
registration
=
await
backgroundFetch
.
fetch
(
'
my
-
id
'
[
'
https
:
/
/
example
.
com
'
'
http
:
/
/
example
.
com
'
]
)
;
const
{
type
eventRegistration
results
}
=
await
getMessageFromServiceWorker
(
)
;
assert_equals
(
'
backgroundfetchfail
'
type
)
;
assert_equals
(
eventRegistration
.
failureReason
'
fetch
-
error
'
)
;
assert_equals
(
results
.
length
2
)
;
assert_true
(
results
[
0
]
.
url
.
includes
(
'
https
:
/
/
example
.
com
'
)
)
;
assert_equals
(
results
[
1
]
.
url
'
'
)
;
}
'
Fetches
with
mixed
content
should
fail
.
'
)
;
