'
use
strict
'
;
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
bgFetch
.
fetch
(
uniqueId
(
)
'
https
:
/
/
example
.
com
'
)
;
}
'
fetch
to
default
https
port
should
register
ok
'
)
;
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
bgFetch
.
fetch
(
uniqueId
(
)
'
http
:
/
/
127
.
0
.
0
.
1
'
)
;
}
'
fetch
to
default
http
port
should
register
ok
'
)
;
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
bgFetch
.
fetch
(
uniqueId
(
)
'
https
:
/
/
example
.
com
:
443
'
)
;
}
'
fetch
to
port
443
should
register
ok
'
)
;
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
bgFetch
.
fetch
(
uniqueId
(
)
'
https
:
/
/
example
.
com
:
80
'
)
;
}
'
fetch
to
port
80
should
register
ok
even
over
https
'
)
;
backgroundFetchTest
(
(
t
bgFetch
)
=
>
{
return
bgFetch
.
fetch
(
uniqueId
(
)
'
https
:
/
/
example
.
com
:
8080
'
)
;
}
'
fetch
to
non
-
default
non
-
bad
port
(
8080
)
should
register
ok
'
)
;
backgroundFetchTest
(
async
(
t
bgFetch
)
=
>
{
const
promise
=
bgFetch
.
fetch
(
uniqueId
(
)
'
https
:
/
/
example
.
com
:
587
'
)
.
then
(
fetch
=
>
{
return
fetch
.
match
(
'
https
:
/
/
example
.
com
:
587
'
)
;
}
)
.
then
(
record
=
>
record
.
responseReady
)
;
return
promise_rejects_js
(
t
TypeError
promise
)
;
}
'
fetch
to
bad
port
(
SMTP
)
should
reject
'
)
;
