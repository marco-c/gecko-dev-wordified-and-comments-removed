'
use
strict
'
;
promise_test
(
async
test
=
>
{
const
script
=
'
resources
/
sw
.
js
'
;
const
scope
=
'
resources
/
scope
'
+
location
.
pathname
;
const
serviceWorkerRegistration
=
await
service_worker_unregister_and_register
(
test
script
scope
)
;
assert_equals
(
serviceWorkerRegistration
.
active
null
'
There
must
not
be
an
activated
worker
'
)
;
const
registration
=
await
serviceWorkerRegistration
.
backgroundFetch
.
get
(
'
x
'
)
;
assert_equals
(
registration
undefined
)
;
}
'
BackgroundFetchManager
.
get
(
)
does
not
require
an
activated
worker
'
)
;
backgroundFetchTest
(
async
(
test
backgroundFetch
)
=
>
{
await
promise_rejects
(
test
new
TypeError
(
)
backgroundFetch
.
get
(
)
)
;
const
registration
=
await
backgroundFetch
.
get
(
'
my
-
id
'
)
;
assert_equals
(
registration
undefined
)
;
}
'
Getting
non
-
existing
registrations
yields
undefined
'
)
;
backgroundFetchTest
(
async
(
test
backgroundFetch
)
=
>
{
const
registrationId
=
uniqueId
(
)
;
const
registration
=
await
backgroundFetch
.
fetch
(
registrationId
'
resources
/
feature
-
name
.
txt
'
{
downloadTotal
:
1234
}
)
;
assert_equals
(
registration
.
id
registrationId
)
;
assert_equals
(
registration
.
uploadTotal
0
)
;
assert_equals
(
registration
.
uploaded
0
)
;
assert_equals
(
registration
.
downloadTotal
1234
)
;
const
secondRegistration
=
await
backgroundFetch
.
get
(
registrationId
)
;
assert_not_equals
(
secondRegistration
null
)
;
assert_equals
(
secondRegistration
.
id
registration
.
id
)
;
assert_equals
(
secondRegistration
.
uploadTotal
registration
.
uploadTotal
)
;
assert_equals
(
secondRegistration
.
uploaded
registration
.
uploaded
)
;
assert_equals
(
secondRegistration
.
downloadTotal
registration
.
downloadTotal
)
;
assert_equals
(
secondRegistration
.
downloaded
registration
.
downloaded
)
;
}
'
Getting
an
existing
registration
has
the
expected
values
'
)
;
