function
toBase64Url
(
array
)
{
return
btoa
(
[
.
.
.
array
]
.
map
(
c
=
>
String
.
fromCharCode
(
c
)
)
.
join
(
'
'
)
)
.
replaceAll
(
"
+
"
"
-
"
)
.
replaceAll
(
"
/
"
"
_
"
)
.
replaceAll
(
"
=
"
"
"
)
}
class
VAPID
{
#
publicKey
;
#
privateKey
;
constructor
(
publicKey
privateKey
)
{
this
.
#
publicKey
=
publicKey
;
this
.
#
privateKey
=
privateKey
;
}
get
publicKey
(
)
{
return
this
.
#
publicKey
;
}
async
#
jws
(
audience
)
{
const
rawHeader
=
{
typ
:
"
JWT
"
alg
:
"
ES256
"
}
;
const
header
=
toBase64Url
(
new
TextEncoder
(
)
.
encode
(
JSON
.
stringify
(
rawHeader
)
)
)
;
const
rawPayload
=
{
aud
:
audience
exp
:
parseInt
(
new
Date
(
)
.
getTime
(
)
/
1000
)
+
24
*
60
*
60
sub
:
"
mailto
:
webpush
example
.
com
"
}
;
const
payload
=
toBase64Url
(
new
TextEncoder
(
)
.
encode
(
JSON
.
stringify
(
rawPayload
)
)
)
;
const
input
=
{
header
}
.
{
payload
}
;
const
rawSignature
=
await
crypto
.
subtle
.
sign
(
{
name
:
"
ECDSA
"
namedCurve
:
"
P
-
256
"
hash
:
{
name
:
"
SHA
-
256
"
}
}
this
.
#
privateKey
new
TextEncoder
(
)
.
encode
(
input
)
)
;
const
signature
=
toBase64Url
(
new
Uint8Array
(
rawSignature
)
)
;
return
{
input
}
.
{
signature
}
;
}
async
generateAuthHeader
(
audience
)
{
const
t
=
await
this
.
#
jws
(
audience
)
;
const
k
=
toBase64Url
(
this
.
#
publicKey
)
return
vapid
t
=
{
t
}
k
=
{
k
}
;
}
}
;
export
async
function
createVapid
(
)
{
const
keys
=
await
crypto
.
subtle
.
generateKey
(
{
name
:
"
ECDSA
"
namedCurve
:
"
P
-
256
"
}
true
[
"
sign
"
]
)
;
const
publicKey
=
new
Uint8Array
(
await
crypto
.
subtle
.
exportKey
(
"
raw
"
keys
.
publicKey
)
)
;
const
privateKey
=
keys
.
privateKey
;
return
new
VAPID
(
publicKey
privateKey
)
;
}
;
