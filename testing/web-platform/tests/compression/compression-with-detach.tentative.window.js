'
use
strict
'
;
const
kInputLength
=
500000
;
function
createLargeRandomInput
(
)
{
const
buffer
=
new
ArrayBuffer
(
kInputLength
)
;
const
kChunkSize
=
65536
;
for
(
let
offset
=
0
;
offset
<
kInputLength
;
offset
+
=
kChunkSize
)
{
const
length
=
offset
+
kChunkSize
>
kInputLength
?
kInputLength
-
offset
:
kChunkSize
;
const
view
=
new
Uint8Array
(
buffer
offset
length
)
;
crypto
.
getRandomValues
(
view
)
;
}
return
new
Uint8Array
(
buffer
)
;
}
function
decompress
(
view
)
{
const
ds
=
new
DecompressionStream
(
'
deflate
'
)
;
const
writer
=
ds
.
writable
.
getWriter
(
)
;
writer
.
write
(
view
)
;
writer
.
close
(
)
;
return
concatenateStream
(
ds
.
readable
)
;
}
promise_test
(
async
(
)
=
>
{
const
input
=
createLargeRandomInput
(
)
;
const
inputCopy
=
input
.
slice
(
0
input
.
byteLength
)
;
const
cs
=
new
CompressionStream
(
'
deflate
'
)
;
const
writer
=
cs
.
writable
.
getWriter
(
)
;
writer
.
write
(
input
)
;
writer
.
close
(
)
;
Object
.
defineProperty
(
Object
.
prototype
'
then
'
{
get
(
)
{
try
{
postMessage
(
undefined
'
nowhere
'
[
input
.
buffer
]
)
;
}
catch
(
e
)
{
}
}
}
)
;
const
output
=
await
concatenateStream
(
cs
.
readable
)
;
assert_equals
(
inputCopy
.
toString
(
)
(
await
decompress
(
output
)
)
.
toString
(
)
'
decompressing
the
output
should
return
the
input
'
)
;
}
'
data
should
be
correctly
compressed
even
if
input
is
detached
partway
'
)
;
