'
use
strict
'
;
pressure_test
(
async
(
t
)
=
>
{
await
create_virtual_pressure_source
(
'
cpu
'
)
;
t
.
add_cleanup
(
async
(
)
=
>
{
await
remove_virtual_pressure_source
(
'
cpu
'
)
;
}
)
;
const
changes
=
await
new
Promise
(
(
resolve
reject
)
=
>
{
const
observer
=
new
PressureObserver
(
resolve
)
;
t
.
add_cleanup
(
(
)
=
>
observer
.
disconnect
(
)
)
;
observer
.
observe
(
'
cpu
'
)
.
catch
(
reject
)
;
update_virtual_pressure_source
(
'
cpu
'
'
critical
'
)
.
catch
(
reject
)
;
}
)
;
assert_less_than
(
changes
[
0
]
.
time
performance
.
now
(
)
)
;
}
'
Timestamp
from
update
should
be
tied
to
the
global
object
\
'
s
time
origin
'
)
;
pressure_test
(
async
(
t
)
=
>
{
await
create_virtual_pressure_source
(
'
cpu
'
)
;
t
.
add_cleanup
(
async
(
)
=
>
{
await
remove_virtual_pressure_source
(
'
cpu
'
)
;
}
)
;
const
readings
=
[
'
critical
'
'
critical
'
]
;
const
syncObserver
=
new
SyncPressureObserver
(
t
)
;
for
(
let
i
=
0
;
i
<
readings
.
length
;
+
+
i
)
{
await
syncObserver
.
observer
(
)
.
observe
(
'
cpu
'
{
sampleInterval
:
500
}
)
;
await
update_virtual_pressure_source
(
'
cpu
'
readings
[
i
]
)
;
await
syncObserver
.
waitForUpdate
(
)
;
syncObserver
.
observer
(
)
.
disconnect
(
)
;
}
const
pressureChanges
=
syncObserver
.
changes
(
)
;
assert_equals
(
pressureChanges
.
length
readings
.
length
)
;
assert_equals
(
pressureChanges
[
0
]
[
0
]
.
state
'
critical
'
)
;
assert_equals
(
pressureChanges
[
1
]
[
0
]
.
state
'
critical
'
)
;
}
'
disconnect
(
)
should
update
[
[
LastRecordMap
]
]
'
)
;
mark_as_done
(
)
;
