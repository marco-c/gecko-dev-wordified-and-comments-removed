'
use
strict
'
;
pressure_test
(
async
(
t
mockPressureService
)
=
>
{
const
video
=
await
loadVideo
(
)
;
document
.
body
.
appendChild
(
video
)
;
const
pipWindow
=
await
requestPictureInPictureWithTrustedClick
(
video
)
;
assert_not_equals
(
pipWindow
.
width
0
)
;
assert_not_equals
(
pipWindow
.
height
0
)
;
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
src
=
get_host_info
(
)
.
HTTPS_REMOTE_ORIGIN
+
'
/
compute
-
pressure
/
resources
/
support
-
iframe
.
html
'
;
const
iframeLoadWatcher
=
new
EventWatcher
(
t
iframe
'
load
'
)
;
document
.
body
.
appendChild
(
iframe
)
;
await
iframeLoadWatcher
.
wait_for
(
'
load
'
)
;
iframe
.
contentWindow
.
focus
(
)
;
await
new
Promise
(
resolve
=
>
{
const
observer
=
new
PressureObserver
(
resolve
)
;
t
.
add_cleanup
(
async
(
)
=
>
{
observer
.
disconnect
(
)
;
iframe
.
remove
(
)
;
if
(
document
.
pictureInPictureElement
)
{
await
document
.
exitPictureInPicture
(
)
;
}
video
.
remove
(
)
;
}
)
;
observer
.
observe
(
'
cpu
'
)
;
mockPressureService
.
setPressureUpdate
(
'
cpu
'
'
critical
'
)
;
mockPressureService
.
startPlatformCollector
(
5
.
0
)
;
}
)
;
}
'
Observer
should
receive
PressureRecord
if
associated
document
is
the
initiator
of
active
Picture
-
in
-
Picture
session
'
)
;
pressure_test
(
async
(
t
mockPressureService
)
=
>
{
await
setMediaPermission
(
)
;
const
stream
=
await
navigator
.
mediaDevices
.
getUserMedia
(
{
video
:
true
audio
:
true
}
)
;
assert_true
(
stream
.
active
)
;
const
iframe
=
document
.
createElement
(
'
iframe
'
)
;
iframe
.
src
=
get_host_info
(
)
.
HTTPS_REMOTE_ORIGIN
+
'
/
compute
-
pressure
/
resources
/
support
-
iframe
.
html
'
;
const
iframeLoadWatcher
=
new
EventWatcher
(
t
iframe
'
load
'
)
;
document
.
body
.
appendChild
(
iframe
)
;
await
iframeLoadWatcher
.
wait_for
(
'
load
'
)
;
iframe
.
contentWindow
.
focus
(
)
;
await
new
Promise
(
resolve
=
>
{
const
observer
=
new
PressureObserver
(
resolve
)
;
t
.
add_cleanup
(
async
(
)
=
>
{
observer
.
disconnect
(
)
;
iframe
.
remove
(
)
;
stream
.
getTracks
(
)
.
forEach
(
track
=
>
track
.
stop
(
)
)
;
}
)
;
observer
.
observe
(
'
cpu
'
)
;
mockPressureService
.
setPressureUpdate
(
'
cpu
'
'
critical
'
)
;
mockPressureService
.
startPlatformCollector
(
5
.
0
)
;
}
)
;
}
'
Observer
should
receive
PressureRecord
if
browsing
context
is
capturing
'
)
;
