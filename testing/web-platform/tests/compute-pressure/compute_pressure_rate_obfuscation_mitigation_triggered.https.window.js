'
use
strict
'
;
pressure_test
(
async
(
t
mockPressureService
)
=
>
{
const
sampleRateInHz
=
25
;
const
readings
=
[
'
nominal
'
'
fair
'
'
serious
'
'
critical
'
]
;
const
minPenaltyTimeInMs
=
5000
;
const
maxChangesThreshold
=
100
;
const
minChangesThreshold
=
50
;
let
gotPenalty
=
false
;
await
new
Promise
(
async
resolve
=
>
{
const
observerChanges
=
[
]
;
const
observer
=
new
PressureObserver
(
changes
=
>
{
if
(
observerChanges
.
length
>
=
(
minChangesThreshold
-
1
)
)
{
const
lastSample
=
observerChanges
.
at
(
-
1
)
;
if
(
(
changes
[
0
]
.
time
-
lastSample
[
0
]
.
time
)
>
=
minPenaltyTimeInMs
)
{
gotPenalty
=
true
;
observer
.
disconnect
(
)
;
resolve
(
)
;
}
}
observerChanges
.
push
(
changes
)
;
}
{
sampleRate
:
sampleRateInHz
}
)
;
observer
.
observe
(
'
cpu
'
)
;
mockPressureService
.
startPlatformCollector
(
sampleRateInHz
)
;
let
i
=
0
;
while
(
observerChanges
.
length
<
=
maxChangesThreshold
|
|
!
gotPenalty
)
{
mockPressureService
.
setPressureUpdate
(
'
cpu
'
readings
[
i
+
+
%
readings
.
length
]
)
;
await
new
Promise
(
(
resolve
)
=
>
t
.
step_timeout
(
resolve
0
)
)
;
await
t
.
step_wait
(
(
)
=
>
mockPressureService
.
updatesDelivered
(
)
>
=
i
At
least
{
i
}
readings
have
been
delivered
)
;
}
assert_true
(
gotPenalty
'
Penalty
not
triggered
'
)
;
}
)
;
}
'
Rate
obfuscation
mitigation
should
have
been
triggered
when
changes
is
higher
than
minimum
changes
before
penalty
'
)
;
