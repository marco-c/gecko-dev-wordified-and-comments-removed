'
use
strict
'
;
pressure_test
(
async
(
t
mockPressureService
)
=
>
{
const
sampleRateInHz
=
10
;
const
readings
=
[
'
nominal
'
'
fair
'
'
serious
'
'
critical
'
]
;
const
minPenaltyTimeInMs
=
5000
;
const
maxChangesThreshold
=
100
;
const
changes
=
await
new
Promise
(
async
resolve
=
>
{
const
observerChanges
=
[
]
;
const
observer
=
new
PressureObserver
(
changes
=
>
{
observerChanges
.
push
(
changes
)
;
}
{
sampleRate
:
sampleRateInHz
}
)
;
observer
.
observe
(
'
cpu
'
)
;
mockPressureService
.
startPlatformCollector
(
sampleRateInHz
)
;
let
i
=
0
;
while
(
observerChanges
.
length
<
=
maxChangesThreshold
)
{
mockPressureService
.
setPressureUpdate
(
'
cpu
'
readings
[
i
+
+
%
readings
.
length
]
)
;
await
t
.
step_wait
(
(
)
=
>
mockPressureService
.
updatesDelivered
(
)
>
=
i
At
least
{
i
}
readings
have
been
delivered
)
;
}
observer
.
disconnect
(
)
;
resolve
(
observerChanges
)
;
}
)
;
assert_equals
(
changes
.
length
(
maxChangesThreshold
+
1
)
)
;
let
gotPenalty
=
false
;
for
(
let
i
=
0
;
i
<
changes
.
length
;
i
+
+
)
{
if
(
(
changes
[
i
+
1
]
[
0
]
.
time
-
changes
[
i
]
[
0
]
.
time
)
>
=
minPenaltyTimeInMs
)
{
gotPenalty
=
true
;
break
;
}
}
assert_true
(
gotPenalty
)
;
}
'
Rate
obfuscation
mitigation
should
have
been
triggered
when
changes
is
higher
than
minimum
changes
before
penalty
'
)
;
