function
run_test
(
algorithmNames
)
{
var
subtle
=
crypto
.
subtle
;
setup
(
{
explicit_timeout
:
true
}
)
;
var
allTestVectors
=
[
{
name
:
"
Ed25519
"
privateUsages
:
[
"
sign
"
]
publicUsages
:
[
"
verify
"
]
}
{
name
:
"
Ed448
"
privateUsages
:
[
"
sign
"
]
publicUsages
:
[
"
verify
"
]
}
{
name
:
"
ECDSA
"
privateUsages
:
[
"
sign
"
]
publicUsages
:
[
"
verify
"
]
}
{
name
:
"
X25519
"
privateUsages
:
[
"
deriveKey
"
"
deriveBits
"
]
publicUsages
:
[
]
}
{
name
:
"
X448
"
privateUsages
:
[
"
deriveKey
"
"
deriveBits
"
]
publicUsages
:
[
]
}
{
name
:
"
ECDH
"
privateUsages
:
[
"
deriveKey
"
"
deriveBits
"
]
publicUsages
:
[
]
}
]
;
var
testVectors
=
[
]
;
if
(
algorithmNames
&
&
!
Array
.
isArray
(
algorithmNames
)
)
{
algorithmNames
=
[
algorithmNames
]
;
}
;
allTestVectors
.
forEach
(
function
(
vector
)
{
if
(
!
algorithmNames
|
|
algorithmNames
.
includes
(
vector
.
name
)
)
{
testVectors
.
push
(
vector
)
;
}
}
)
;
function
parameterString
(
format
algorithm
extractable
usages
data
)
{
if
(
typeof
algorithm
!
=
=
"
object
"
&
&
typeof
algorithm
!
=
=
"
string
"
)
{
alert
(
algorithm
)
;
}
var
jwk_label
=
"
"
;
if
(
format
=
=
=
"
jwk
"
)
jwk_label
=
data
.
d
=
=
=
undefined
?
"
(
public
)
"
:
"
(
private
)
"
;
var
result
=
"
(
"
+
objectToString
(
format
)
+
jwk_label
+
"
"
+
objectToString
(
algorithm
)
+
"
"
+
objectToString
(
extractable
)
+
"
"
+
objectToString
(
usages
)
+
"
)
"
;
return
result
;
}
function
testError
(
format
algorithm
keyData
keySize
usages
extractable
expectedError
testTag
)
{
promise_test
(
async
(
)
=
>
{
let
key
;
try
{
key
=
await
subtle
.
importKey
(
format
keyData
algorithm
extractable
usages
)
;
}
catch
(
err
)
{
let
actualError
=
typeof
expectedError
=
=
=
"
number
"
?
err
.
code
:
err
.
name
;
assert_equals
(
actualError
expectedError
testTag
+
"
not
supported
.
"
)
;
}
assert_equals
(
key
undefined
"
Operation
succeeded
but
should
not
have
.
"
)
;
}
testTag
+
"
:
importKey
"
+
parameterString
(
format
algorithm
extractable
usages
keyData
)
)
;
}
function
invalidUsages
(
validUsages
mandatoryUsages
)
{
var
results
=
[
]
;
var
illegalUsages
=
[
]
;
[
"
encrypt
"
"
decrypt
"
"
sign
"
"
verify
"
"
wrapKey
"
"
unwrapKey
"
"
deriveKey
"
"
deriveBits
"
]
.
forEach
(
function
(
usage
)
{
if
(
!
validUsages
.
includes
(
usage
)
)
{
illegalUsages
.
push
(
usage
)
;
}
}
)
;
var
goodUsageCombinations
=
validUsages
.
length
=
=
=
0
?
[
]
:
allValidUsages
(
validUsages
false
mandatoryUsages
)
;
illegalUsages
.
forEach
(
function
(
illegalUsage
)
{
results
.
push
(
[
illegalUsage
]
)
;
goodUsageCombinations
.
forEach
(
function
(
usageCombination
)
{
results
.
push
(
usageCombination
.
concat
(
[
illegalUsage
]
)
)
;
}
)
;
}
)
;
return
results
;
}
function
validUsages
(
usages
format
data
)
{
if
(
format
=
=
=
'
spki
'
|
|
format
=
=
=
'
raw
'
)
return
usages
.
publicUsages
if
(
format
=
=
=
'
pkcs8
'
)
return
usages
.
privateUsages
if
(
format
=
=
=
'
jwk
'
)
{
if
(
data
=
=
=
undefined
)
return
[
]
;
return
data
.
d
=
=
=
undefined
?
usages
.
publicUsages
:
usages
.
privateUsages
;
}
return
[
]
;
}
function
isPrivateKey
(
data
)
{
return
data
.
d
!
=
=
undefined
;
}
testVectors
.
forEach
(
function
(
vector
)
{
var
name
=
vector
.
name
;
allAlgorithmSpecifiersFor
(
name
)
.
forEach
(
function
(
algorithm
)
{
getValidKeyData
(
algorithm
)
.
forEach
(
function
(
test
)
{
invalidUsages
(
validUsages
(
vector
test
.
format
test
.
data
)
)
.
forEach
(
function
(
usages
)
{
[
true
false
]
.
forEach
(
function
(
extractable
)
{
testError
(
test
.
format
algorithm
test
.
data
name
usages
extractable
"
SyntaxError
"
"
Bad
usages
"
)
;
}
)
;
}
)
;
}
)
;
}
)
;
}
)
;
testVectors
.
forEach
(
function
(
vector
)
{
var
name
=
vector
.
name
;
allAlgorithmSpecifiersFor
(
name
)
.
forEach
(
function
(
algorithm
)
{
getValidKeyData
(
algorithm
)
.
filter
(
(
test
)
=
>
test
.
format
=
=
=
'
pkcs8
'
|
|
(
test
.
format
=
=
=
'
jwk
'
&
&
isPrivateKey
(
test
.
data
)
)
)
.
forEach
(
function
(
test
)
{
[
true
false
]
.
forEach
(
function
(
extractable
)
{
testError
(
test
.
format
algorithm
test
.
data
name
[
]
extractable
"
SyntaxError
"
"
Empty
usages
"
)
;
}
)
;
}
)
;
}
)
;
}
)
;
testVectors
.
forEach
(
function
(
vector
)
{
var
name
=
vector
.
name
;
allAlgorithmSpecifiersFor
(
name
)
.
forEach
(
function
(
algorithm
)
{
getBadKeyLengthData
(
algorithm
)
.
forEach
(
function
(
test
)
{
allValidUsages
(
validUsages
(
vector
test
.
format
test
.
data
)
)
.
forEach
(
function
(
usages
)
{
[
true
false
]
.
forEach
(
function
(
extractable
)
{
testError
(
test
.
format
algorithm
test
.
data
name
usages
extractable
"
DataError
"
"
Bad
key
length
"
)
;
}
)
;
}
)
;
}
)
;
}
)
;
}
)
;
testVectors
.
forEach
(
function
(
vector
)
{
var
name
=
vector
.
name
;
allAlgorithmSpecifiersFor
(
name
)
.
forEach
(
function
(
algorithm
)
{
getMissingJWKFieldKeyData
(
algorithm
)
.
forEach
(
function
(
test
)
{
allValidUsages
(
validUsages
(
vector
'
jwk
'
test
.
data
)
)
.
forEach
(
function
(
usages
)
{
[
true
false
]
.
forEach
(
function
(
extractable
)
{
testError
(
'
jwk
'
algorithm
test
.
data
name
usages
extractable
"
DataError
"
"
Missing
JWK
'
"
+
test
.
param
+
"
'
parameter
"
)
;
}
)
;
}
)
;
}
)
;
}
)
;
}
)
;
testVectors
.
forEach
(
function
(
vector
)
{
var
name
=
vector
.
name
;
allAlgorithmSpecifiersFor
(
name
)
.
forEach
(
function
(
algorithm
)
{
getMismatchedJWKKeyData
(
algorithm
)
.
forEach
(
function
(
data
)
{
allValidUsages
(
vector
.
privateUsages
)
.
forEach
(
function
(
usages
)
{
[
true
]
.
forEach
(
function
(
extractable
)
{
testError
(
'
jwk
'
algorithm
data
name
usages
extractable
"
DataError
"
"
Invalid
key
pair
"
)
;
}
)
;
}
)
;
}
)
;
}
)
;
}
)
;
testVectors
.
forEach
(
function
(
vector
)
{
var
name
=
vector
.
name
;
var
algorithm
=
allAlgorithmSpecifiersFor
(
name
)
[
0
]
;
getValidKeyData
(
algorithm
)
.
forEach
(
function
(
test
)
{
validUsages
(
vector
test
.
format
test
.
data
)
.
forEach
(
function
(
usages
)
{
[
true
false
]
.
forEach
(
function
(
extractable
)
{
testError
(
test
.
format
{
}
test
.
data
name
usages
extractable
"
TypeError
"
"
Missing
algorithm
name
"
)
;
}
)
;
}
)
;
}
)
;
}
)
;
testVectors
.
forEach
(
function
(
vector
)
{
var
name
=
vector
.
name
;
allAlgorithmSpecifiersFor
(
name
)
.
forEach
(
function
(
algorithm
)
{
getValidKeyData
(
algorithm
)
.
forEach
(
function
(
test
)
{
if
(
test
.
format
=
=
=
"
jwk
"
)
{
var
data
=
{
crv
:
test
.
data
.
crv
kty
:
test
.
data
.
kty
d
:
test
.
data
.
d
x
:
test
.
data
.
x
d
:
test
.
data
.
d
}
;
data
.
kty
=
getMismatchedKtyField
(
algorithm
)
;
var
usages
=
validUsages
(
vector
'
jwk
'
test
.
data
)
;
testError
(
'
jwk
'
algorithm
data
name
usages
true
"
DataError
"
"
Invalid
'
kty
'
field
"
)
;
}
}
)
;
}
)
;
}
)
;
testVectors
.
forEach
(
function
(
vector
)
{
var
name
=
vector
.
name
;
allAlgorithmSpecifiersFor
(
name
)
.
forEach
(
function
(
algorithm
)
{
getValidKeyData
(
algorithm
)
.
forEach
(
function
(
test
)
{
if
(
test
.
format
=
=
=
"
jwk
"
)
{
var
data
=
{
crv
:
test
.
data
.
crv
kty
:
test
.
data
.
kty
d
:
test
.
data
.
d
x
:
test
.
data
.
x
d
:
test
.
data
.
d
}
;
data
.
ext
=
false
;
var
usages
=
validUsages
(
vector
'
jwk
'
test
.
data
)
;
testError
(
'
jwk
'
algorithm
data
name
usages
true
"
DataError
"
"
Import
from
a
non
-
extractable
"
)
;
}
}
)
;
}
)
;
}
)
;
testVectors
.
forEach
(
function
(
vector
)
{
var
name
=
vector
.
name
;
allAlgorithmSpecifiersFor
(
name
)
.
forEach
(
function
(
algorithm
)
{
getValidKeyData
(
algorithm
)
.
forEach
(
function
(
test
)
{
if
(
test
.
format
=
=
=
"
jwk
"
)
{
var
data
=
{
crv
:
test
.
data
.
crv
kty
:
test
.
data
.
kty
d
:
test
.
data
.
d
x
:
test
.
data
.
x
d
:
test
.
data
.
d
}
;
data
.
use
=
"
invalid
"
;
var
usages
=
validUsages
(
vector
'
jwk
'
test
.
data
)
;
if
(
usages
.
length
!
=
=
0
)
testError
(
'
jwk
'
algorithm
data
name
usages
true
"
DataError
"
"
Invalid
'
use
'
field
"
)
;
}
}
)
;
}
)
;
}
)
;
testVectors
.
forEach
(
function
(
vector
)
{
var
name
=
vector
.
name
;
allAlgorithmSpecifiersFor
(
name
)
.
forEach
(
function
(
algorithm
)
{
getValidKeyData
(
algorithm
)
.
forEach
(
function
(
test
)
{
if
(
test
.
format
=
=
=
"
jwk
"
)
{
var
data
=
{
crv
:
test
.
data
.
crv
kty
:
test
.
data
.
kty
d
:
test
.
data
.
d
x
:
test
.
data
.
x
d
:
test
.
data
.
d
}
;
data
.
crv
=
getMismatchedCrvField
(
algorithm
)
var
usages
=
validUsages
(
vector
'
jwk
'
test
.
data
)
;
testError
(
'
jwk
'
algorithm
data
name
usages
true
"
DataError
"
"
Invalid
'
crv
'
field
"
)
;
}
}
)
;
}
)
;
}
)
;
}
