promise_test
(
async
t
=
>
{
const
controller
=
new
AbortController
(
)
;
controller
.
abort
(
)
;
const
key
=
token
(
)
;
const
wsUrl
=
new
URL
(
/
fetch
/
api
/
resources
/
stash
-
put
.
py
?
key
=
{
key
}
&
value
=
connected
location
.
href
)
;
wsUrl
.
protocol
=
wsUrl
.
protocol
.
replace
(
'
http
'
'
ws
'
)
;
const
wss
=
new
WebSocketStream
(
wsUrl
{
signal
:
controller
.
signal
}
)
;
await
promise_rejects_dom
(
t
'
AbortError
'
wss
.
connection
'
connection
should
reject
'
)
;
await
promise_rejects_dom
(
t
'
AbortError
'
wss
.
closed
'
closed
should
reject
'
)
;
const
response
=
await
fetch
(
/
fetch
/
api
/
resources
/
stash
-
take
.
py
?
key
=
{
key
}
)
;
assert_equals
(
await
response
.
text
(
)
'
null
'
'
response
should
be
null
'
)
;
}
'
abort
before
constructing
should
prevent
connection
'
)
;
promise_test
(
async
t
=
>
{
const
controller
=
new
AbortController
(
)
;
const
wss
=
new
WebSocketStream
(
{
BASEURL
}
/
handshake_sleep_2
{
signal
:
controller
.
signal
}
)
;
await
new
Promise
(
resolve
=
>
t
.
step_timeout
(
resolve
0
)
)
;
controller
.
abort
(
)
;
await
promise_rejects_dom
(
t
'
AbortError
'
wss
.
connection
'
connection
should
reject
'
)
;
await
promise_rejects_dom
(
t
'
AbortError
'
wss
.
closed
'
closed
should
reject
'
)
;
}
'
abort
during
handshake
should
work
'
)
;
promise_test
(
async
t
=
>
{
const
controller
=
new
AbortController
(
)
;
const
wss
=
new
WebSocketStream
(
ECHOURL
{
signal
:
controller
.
signal
}
)
;
const
{
readable
writable
}
=
await
wss
.
connection
;
controller
.
abort
(
)
;
writable
.
getWriter
(
)
.
write
(
'
connected
'
)
;
const
{
value
}
=
await
readable
.
getReader
(
)
.
read
(
)
;
assert_equals
(
value
'
connected
'
'
value
should
match
'
)
;
}
'
abort
after
connect
should
do
nothing
'
)
;
