'
use
strict
'
;
const
GOODBYE_MESSAGE
=
'
Goodbye
'
;
const
BIG_MESSAGE_SIZE
=
8
*
1024
*
1024
;
async
function
sendGoodbyeThenBigMessage
(
t
)
{
const
wss
=
new
WebSocketStream
(
BASEURL
+
'
/
echo_exit
'
)
;
const
{
writable
}
=
await
wss
.
opened
;
const
writer
=
writable
.
getWriter
(
)
;
const
bigMessage
=
new
Uint8Array
(
BIG_MESSAGE_SIZE
)
;
const
goodbyePromise
=
writer
.
write
(
GOODBYE_MESSAGE
)
;
const
bigMessagePromise
=
writer
.
write
(
bigMessage
)
;
await
goodbyePromise
;
await
wss
.
closed
.
then
(
t
.
unreached_func
(
'
closed
promise
should
reject
'
)
e
=
>
assert_equals
(
e
.
constructor
WebSocketError
'
a
WebSocketError
should
be
thrown
'
)
)
;
return
{
writer
bigMessagePromise
}
;
}
promise_test
(
async
t
=
>
{
const
{
writer
bigMessagePromise
}
=
await
sendGoodbyeThenBigMessage
(
t
)
;
await
promise_rejects_dom
(
t
'
InvalidStateError
'
bigMessagePromise
'
write
(
)
should
reject
with
an
InvalidStateError
'
)
;
const
invalidStateError
=
await
bigMessagePromise
.
then
(
t
.
unreached_func
(
'
write
(
)
promise
should
reject
'
)
e
=
>
e
)
;
await
promise_rejects_exactly
(
t
invalidStateError
writer
.
write
(
'
word
'
)
'
stream
should
be
errored
with
same
object
'
)
;
}
'
a
write
that
was
incomplete
at
close
time
should
reject
'
)
;
promise_test
(
async
t
=
>
{
const
{
bigMessagePromise
}
=
await
sendGoodbyeThenBigMessage
(
t
)
;
for
(
let
i
=
0
;
i
<
5
;
+
+
i
)
{
await
garbageCollect
(
)
;
}
await
promise_rejects_dom
(
t
'
InvalidStateError
'
bigMessagePromise
'
write
(
)
should
reject
with
an
InvalidStateError
'
)
;
}
'
garbage
collection
after
close
with
a
pending
write
promise
should
not
'
+
'
crash
'
)
;
promise_test
(
async
t
=
>
{
const
wss
=
new
WebSocketStream
(
ECHOURL
)
;
const
{
writable
}
=
await
wss
.
opened
;
const
writer
=
writable
.
getWriter
(
)
;
const
cannotStringify
=
{
toString
(
)
{
return
this
;
}
}
;
await
promise_rejects_js
(
t
TypeError
writer
.
write
(
cannotStringify
)
'
write
(
)
should
reject
'
)
;
}
'
writing
a
value
that
cannot
be
stringified
should
cause
a
rejection
'
)
;
promise_test
(
async
t
=
>
{
const
wss
=
new
WebSocketStream
(
ECHOURL
)
;
const
{
writable
}
=
await
wss
.
opened
;
const
writer
=
writable
.
getWriter
(
)
;
const
buffer
=
new
ArrayBuffer
(
1024
{
maxByteLength
:
65536
}
)
;
await
promise_rejects_js
(
t
TypeError
writer
.
write
(
buffer
)
'
write
(
)
should
reject
'
)
;
}
'
writing
a
resizable
ArrayBuffer
should
be
rejected
'
)
;
promise_test
(
async
t
=
>
{
const
wss
=
new
WebSocketStream
(
ECHOURL
)
;
const
{
writable
}
=
await
wss
.
opened
;
const
writer
=
writable
.
getWriter
(
)
;
const
memory
=
new
WebAssembly
.
Memory
(
{
initial
:
4096
maximum
:
65536
shared
:
true
}
)
;
const
view
=
new
Uint8Array
(
memory
.
buffer
)
;
await
promise_rejects_js
(
t
TypeError
writer
.
write
(
view
)
'
write
(
)
should
reject
'
)
;
}
'
writing
a
view
on
a
shared
buffer
should
be
rejected
'
)
;
