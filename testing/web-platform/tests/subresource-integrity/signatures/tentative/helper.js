const
kValidKeys
=
{
rfc
:
"
JrQLj5P
/
89iXES9
+
vFgrIy29clF9CC
/
oPPsw3c5D0bs
=
"
arbitrary
:
"
xDnP380zcL4rJ76rXYjeHlfMyPZEOqpJYjsjEppbuXE
=
"
}
;
const
kValidKeysJWK
=
{
rfc
:
{
"
kty
"
:
"
OKP
"
"
crv
"
:
"
Ed25519
"
"
kid
"
:
"
test
-
key
-
ed25519
"
"
d
"
:
"
n4Ni
-
HpISpVObnQMW0wOhCKROaIKqKtW_2ZYb2p9KcU
"
"
x
"
:
"
JrQLj5P_89iXES9
-
vFgrIy29clF9CC_oPPsw3c5D0bs
"
}
arbitrary
:
{
"
crv
"
:
"
Ed25519
"
"
d
"
:
"
MTodZiTA9CBsuIvSfO679TThkG3b7ce6R3sq_CdyVp4
"
"
ext
"
:
true
"
kty
"
:
"
OKP
"
"
x
"
:
"
xDnP380zcL4rJ76rXYjeHlfMyPZEOqpJYjsjEppbuXE
"
}
}
;
const
kInvalidKey
=
"
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
=
"
;
const
EXPECT_BLOCKED
=
"
block
"
;
const
EXPECT_LOADED
=
"
loaded
"
;
const
kAcceptSignature
=
"
accept
-
signature
"
;
let
counter
=
0
;
function
resourceURL
(
data
host
)
{
counter
+
+
;
data
.
type
?
?
=
"
application
/
javascript
"
;
data
.
counter
=
counter
;
let
params
=
new
URLSearchParams
(
data
)
;
let
result
=
new
URL
(
"
/
subresource
-
integrity
/
signatures
/
resource
.
py
?
"
+
params
.
toString
(
)
self
.
location
)
;
if
(
host
)
{
result
.
host
=
host
;
}
return
result
.
href
;
}
async
function
signSignatureBase
(
signatureBase
privateKeyJWK
)
{
assert_true
(
self
.
isSecureContext
"
Signatures
can
only
be
generated
in
secure
contexts
.
"
)
;
const
privateKey
=
await
crypto
.
subtle
.
importKey
(
'
jwk
'
privateKeyJWK
'
Ed25519
'
true
[
'
sign
'
]
)
;
const
encoder
=
new
TextEncoder
(
)
;
const
messageBytes
=
encoder
.
encode
(
signatureBase
)
;
const
signatureBytes
=
await
crypto
.
subtle
.
sign
(
{
name
:
'
Ed25519
'
}
privateKey
messageBytes
)
;
return
btoa
(
String
.
fromCharCode
(
.
.
.
new
Uint8Array
(
signatureBytes
)
)
)
;
}
function
generate_fetch_test
(
request_data
options
expectation
description
)
{
promise_test
(
test
=
>
{
const
url
=
resourceURL
(
request_data
options
.
host
)
;
let
fetch_options
=
{
}
;
if
(
options
.
mode
)
{
fetch_options
.
mode
=
options
.
mode
;
}
if
(
options
.
integrity
)
{
fetch_options
.
integrity
=
options
.
integrity
;
}
let
fetcher
=
fetch
(
url
fetch_options
)
;
if
(
expectation
=
=
EXPECT_LOADED
)
{
return
fetcher
.
then
(
r
=
>
{
const
expected_status
=
options
.
mode
=
=
"
no
-
cors
"
?
0
:
(
request_data
.
status
?
?
200
)
;
assert_equals
(
r
.
status
expected_status
Response
status
is
{
expected_status
}
.
)
;
if
(
options
.
integrity
?
.
includes
(
ed25519
-
{
kInvalidKey
}
)
)
{
assert_equals
(
r
.
headers
.
get
(
kAcceptSignature
)
sig0
=
(
"
unencoded
-
digest
"
;
sf
)
;
keyid
=
"
{
kValidKeys
[
'
rfc
'
]
}
"
;
tag
=
"
sri
"
sig1
=
(
"
unencoded
-
digest
"
;
sf
)
;
keyid
=
"
{
kInvalidKey
}
"
;
tag
=
"
sri
"
"
accept
-
signature
was
set
.
"
)
;
}
else
if
(
options
.
integrity
?
.
includes
(
ed25519
-
{
kValidKeys
[
'
rfc
'
]
}
)
)
{
assert_equals
(
r
.
headers
.
get
(
kAcceptSignature
)
sig0
=
(
"
unencoded
-
digest
"
;
sf
)
;
keyid
=
"
{
kValidKeys
[
'
rfc
'
]
}
"
;
tag
=
"
sri
"
"
accept
-
signature
was
set
.
"
)
;
}
}
)
;
}
else
{
return
promise_rejects_js
(
test
TypeError
fetcher
)
;
}
}
"
fetch
(
)
:
"
+
description
)
;
}
function
generate_query_test
(
query
options
expectation
description
)
{
promise_test
(
test
=
>
{
let
url
=
new
URL
(
"
/
subresource
-
integrity
/
signatures
/
query
-
resource
.
py
?
"
+
query
self
.
location
)
;
let
fetch_options
=
{
}
;
if
(
options
.
mode
)
{
fetch_options
.
mode
=
options
.
mode
;
}
if
(
options
.
integrity
)
{
fetch_options
.
integrity
=
options
.
integrity
;
}
let
fetcher
=
fetch
(
url
fetch_options
)
;
if
(
expectation
=
=
EXPECT_LOADED
)
{
return
fetcher
.
then
(
r
=
>
{
const
expected_status
=
options
.
mode
=
=
"
no
-
cors
"
?
0
:
200
;
assert_equals
(
r
.
status
expected_status
Response
status
is
{
expected_status
}
.
)
;
}
)
;
}
else
{
return
promise_rejects_js
(
test
TypeError
fetcher
)
;
}
}
"
fetch
(
)
:
"
+
description
)
;
}
const
kScriptToExecute
=
{
body
:
"
window
.
hello
=
world
;
"
hash
:
"
PZJ
+
9CdAAIacg7wfUe4t
/
RkDQJVKM0mCZ2K7qiRhHFc
=
"
signatures
:
{
rfc
:
"
A1wOGCGrcfN34uMe2Umt7hJ6Su1MQFUL1QuT5nmk1R8I761eXUt2Zv4D5fOt1h1
+
4DlHPiA1FVwfJLbwlWnpBw
=
=
"
arbitrary
:
"
odk
/
ec9gO
/
DCcLPa1xSW1cSmB2s4XU3iDOxJAiod4v5
/
YBESjvwEJNAO9x4Frn
/
7rRIZ7sL5LwRNaymdHokOBQ
=
=
"
}
}
;
const
kScriptToBlock
=
{
body
:
"
assert_unreached
(
This
code
should
not
execute
.
)
;
"
hash
:
"
FUSFR1N3vTmSGbI7q9jaMbHq
+
ogNeBfpznOIufaIfpc
=
"
signatures
:
{
rfc
:
"
bR3fU6kzmMLol4GIcgj19
+
It0GB0dlKrD4ssH
+
SCz0vTLAdT3zt6Kfq4V60NnDdn62XGNr20b0TEKtfcremcDw
=
=
"
arbitrary
:
"
+
5Iol
+
V65SW2qkpsTCyqYQJC4NZIsUGeNbO5kS9WdTboa9gg
/
nV6LwnySM02612YvPm
+
+
671nN9dBDJPYncuBA
=
=
"
}
}
;
const
kUnsignedShouldExecute
=
{
body
:
kScriptToExecute
[
'
body
'
]
}
;
const
kUnsignedShouldBlock
=
{
body
:
kScriptToBlock
[
'
body
'
]
}
;
const
kSignedShouldExecute
=
{
body
:
kScriptToExecute
[
'
body
'
]
digest
:
sha
-
256
=
:
{
kScriptToExecute
[
'
hash
'
]
}
:
signatureInput
:
signature
=
(
"
unencoded
-
digest
"
;
sf
)
;
keyid
=
"
{
kValidKeys
[
'
rfc
'
]
}
"
;
tag
=
"
sri
"
signature
:
signature
=
:
{
kScriptToExecute
[
'
signatures
'
]
[
'
rfc
'
]
}
:
}
;
const
kSignedShouldBlock
=
{
body
:
kScriptToBlock
[
'
body
'
]
digest
:
sha
-
256
=
:
{
kScriptToBlock
[
'
hash
'
]
}
:
signatureInput
:
signature
=
(
"
unencoded
-
digest
"
;
sf
)
;
keyid
=
"
{
kValidKeys
[
'
rfc
'
]
}
"
;
tag
=
"
sri
"
signature
:
signature
=
:
{
kScriptToBlock
[
'
signatures
'
]
[
'
rfc
'
]
}
:
}
;
const
kMultiplySignedShouldExecute
=
{
body
:
kScriptToExecute
[
'
body
'
]
digest
:
sha
-
256
=
:
{
kScriptToExecute
[
'
hash
'
]
}
:
signatureInput
:
signature1
=
(
"
unencoded
-
digest
"
;
sf
)
;
keyid
=
"
{
kValidKeys
[
'
rfc
'
]
}
"
;
tag
=
"
sri
"
+
signature2
=
(
"
unencoded
-
digest
"
;
sf
)
;
keyid
=
"
{
kValidKeys
[
'
arbitrary
'
]
}
"
;
tag
=
"
sri
"
signature
:
signature1
=
:
{
kScriptToExecute
[
'
signatures
'
]
[
'
rfc
'
]
}
:
+
signature2
=
:
{
kScriptToExecute
[
'
signatures
'
]
[
'
arbitrary
'
]
}
:
}
;
const
kMultiplySignedShouldBlock
=
{
body
:
kScriptToBlock
[
'
body
'
]
digest
:
sha
-
256
=
:
{
kScriptToBlock
[
'
hash
'
]
}
:
signatureInput
:
signature1
=
(
"
unencoded
-
digest
"
;
sf
)
;
keyid
=
"
{
kValidKeys
[
'
rfc
'
]
}
"
;
tag
=
"
sri
"
+
signature2
=
(
"
unencoded
-
digest
"
;
sf
)
;
keyid
=
"
{
kValidKeys
[
'
arbitrary
'
]
}
"
;
tag
=
"
sri
"
signature
:
signature1
=
:
{
kScriptToBlock
[
'
signatures
'
]
[
'
rfc
'
]
}
:
+
signature2
=
:
{
kScriptToBlock
[
'
signatures
'
]
[
'
arbitrary
'
]
}
:
}
;
function
generate_script_test
(
request_data
integrity
expectation
description
)
{
async_test
(
t
=
>
{
let
s
=
document
.
createElement
(
'
script
'
)
;
s
.
src
=
resourceURL
(
request_data
)
;
s
.
integrity
=
integrity
;
if
(
expectation
=
=
EXPECT_BLOCKED
)
{
s
.
onerror
=
t
.
step_func_done
(
e
=
>
{
assert_equals
(
"
error
"
e
.
type
)
;
}
)
;
s
.
onload
=
t
.
unreached_func
(
"
Script
should
not
execute
.
"
)
;
}
else
{
s
.
onload
=
t
.
step_func_done
(
e
=
>
{
assert_equals
(
"
load
"
e
.
type
)
;
}
)
;
s
.
onerror
=
t
.
unreached_func
(
"
Script
should
not
fail
.
"
)
;
}
document
.
body
.
appendChild
(
s
)
;
}
"
<
script
>
:
"
+
description
)
;
}
