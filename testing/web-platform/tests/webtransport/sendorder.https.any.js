promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
{
readable
writable
}
=
await
wt
.
createBidirectionalStream
(
{
sendOrder
:
3
}
)
;
assert_equals
(
writable
.
sendOrder
3
)
;
const
writer
=
writable
.
getWriter
(
)
;
const
encoder
=
new
TextEncoder
(
)
;
writer
.
write
(
encoder
.
encode
(
'
Hello
World
'
)
)
.
catch
(
(
)
=
>
{
}
)
;
await
writer
.
close
(
)
;
const
reply
=
await
read_stream_as_string
(
readable
)
;
assert_equals
(
reply
'
Hello
World
'
)
;
}
'
WebTransport
client
should
be
able
to
create
and
handle
a
bidirectional
stream
with
sendOrder
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
{
readable
writable
}
=
await
wt
.
createBidirectionalStream
(
)
;
assert_equals
(
writable
.
sendOrder
null
)
;
writable
.
sendOrder
=
4
;
assert_equals
(
writable
.
sendOrder
4
)
;
}
'
WebTransport
client
should
be
able
to
modify
unset
sendOrder
after
stream
creation
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
{
readable
writable
}
=
await
wt
.
createBidirectionalStream
(
{
sendOrder
:
3
}
)
;
assert_equals
(
writable
.
sendOrder
3
)
;
writable
.
sendOrder
=
5
;
assert_equals
(
writable
.
sendOrder
5
)
;
writable
.
sendOrder
=
null
;
assert_equals
(
writable
.
sendOrder
null
)
;
}
'
WebTransport
client
should
be
able
to
modify
existing
sendOrder
after
stream
creation
'
)
;
promise_test
(
async
t
=
>
{
const
id
=
token
(
)
;
const
wt
=
new
WebTransport
(
webtransport_url
(
sendorder
.
py
?
token
=
{
id
}
)
)
;
await
wt
.
ready
;
const
bytes_low
=
new
Uint8Array
(
65536
)
.
fill
(
'
1
'
)
;
const
bytes_unordered
=
new
Uint8Array
(
65536
)
.
fill
(
'
0
'
)
;
const
{
writable
:
unordered_writable
}
=
await
wt
.
createBidirectionalStream
(
)
;
const
{
writable
:
low_writable
}
=
await
wt
.
createBidirectionalStream
(
{
sendOrder
:
1
}
)
;
const
low_writer
=
low_writable
.
getWriter
(
)
;
assert_equals
(
low_writable
.
sendOrder
1
)
;
const
unordered_writer
=
unordered_writable
.
getWriter
(
)
;
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
low_writer
.
write
(
bytes_low
)
.
catch
(
(
)
=
>
{
}
)
;
}
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
unordered_writer
.
write
(
bytes_unordered
)
.
catch
(
(
)
=
>
{
}
)
;
}
await
Promise
.
all
(
[
low_writer
.
close
(
)
unordered_writer
.
close
(
)
]
)
;
const
reply
=
await
query
(
id
)
;
let
ok
=
false
;
for
(
i
=
0
;
i
<
reply
.
length
;
i
+
+
)
{
if
(
reply
[
i
]
=
=
1
)
{
for
(
;
i
<
reply
.
length
;
i
+
+
)
{
if
(
reply
[
i
]
=
=
0
)
{
for
(
;
i
<
reply
.
length
;
i
+
+
)
{
if
(
reply
[
i
]
=
=
1
)
{
ok
=
true
;
break
;
}
}
break
;
}
}
break
;
}
}
assert_true
(
ok
)
;
}
'
WebTransport
sendorder
should
not
starve
a
stream
without
sendorder
'
)
;
promise_test
(
async
t
=
>
{
const
id
=
token
(
)
;
const
wt
=
new
WebTransport
(
webtransport_url
(
sendorder
.
py
?
token
=
{
id
}
)
)
;
await
wt
.
ready
;
const
bytes_low
=
new
Uint8Array
(
65536
)
.
fill
(
'
1
'
)
;
const
bytes_unordered
=
new
Uint8Array
(
65536
)
.
fill
(
'
0
'
)
;
const
bytes_high
=
new
Uint8Array
(
65536
)
.
fill
(
'
2
'
)
;
const
{
writable
:
unordered_writable
}
=
await
wt
.
createBidirectionalStream
(
)
;
const
{
writable
:
low_writable
}
=
await
wt
.
createBidirectionalStream
(
{
sendOrder
:
1
}
)
;
const
{
writable
:
high_writable
}
=
await
wt
.
createBidirectionalStream
(
{
sendOrder
:
2
}
)
;
const
unordered_writer
=
unordered_writable
.
getWriter
(
)
;
const
low_writer
=
low_writable
.
getWriter
(
)
;
assert_equals
(
low_writable
.
sendOrder
1
)
;
const
high_writer
=
high_writable
.
getWriter
(
)
;
assert_equals
(
high_writable
.
sendOrder
2
)
;
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
unordered_writer
.
write
(
bytes_unordered
)
.
catch
(
(
)
=
>
{
}
)
;
}
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
low_writer
.
write
(
bytes_low
)
.
catch
(
(
)
=
>
{
}
)
;
}
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
high_writer
.
write
(
bytes_high
)
.
catch
(
(
)
=
>
{
}
)
;
}
await
Promise
.
all
(
[
low_writer
.
close
(
)
unordered_writer
.
close
(
)
high_writer
.
close
(
)
]
)
;
const
reply
=
await
query
(
id
)
;
assert_true
(
reply
[
reply
.
length
-
1
]
!
=
2
)
;
}
'
WebTransport
sendorder
should
starve
a
lower
priority
stream
'
)
;
promise_test
(
async
t
=
>
{
const
id
=
token
(
)
;
const
wt
=
new
WebTransport
(
webtransport_url
(
sendorder
.
py
?
token
=
{
id
}
)
)
;
await
wt
.
ready
;
const
bytes_low
=
new
Uint8Array
(
65536
)
.
fill
(
'
1
'
)
;
const
bytes_unordered
=
new
Uint8Array
(
65536
)
.
fill
(
'
0
'
)
;
const
bytes_high
=
new
Uint8Array
(
65536
)
.
fill
(
'
2
'
)
;
const
{
writable
:
unordered_writable
}
=
await
wt
.
createBidirectionalStream
(
)
;
const
{
writable
:
low_writable
}
=
await
wt
.
createBidirectionalStream
(
{
sendOrder
:
1
}
)
;
const
{
writable
:
high_writable
}
=
await
wt
.
createBidirectionalStream
(
{
sendOrder
:
2
}
)
;
const
unordered_writer
=
unordered_writable
.
getWriter
(
)
;
const
low_writer
=
low_writable
.
getWriter
(
)
;
assert_equals
(
low_writable
.
sendOrder
1
)
;
const
high_writer
=
high_writable
.
getWriter
(
)
;
assert_equals
(
high_writable
.
sendOrder
2
)
;
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
unordered_writer
.
write
(
bytes_unordered
)
.
catch
(
(
)
=
>
{
}
)
;
}
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
high_writer
.
write
(
bytes_high
)
.
catch
(
(
)
=
>
{
}
)
;
}
for
(
let
i
=
0
;
i
<
30
;
i
+
+
)
{
low_writer
.
write
(
bytes_low
)
.
catch
(
(
)
=
>
{
}
)
;
}
await
Promise
.
all
(
[
low_writer
.
close
(
)
unordered_writer
.
close
(
)
high_writer
.
close
(
)
]
)
;
const
reply
=
await
query
(
id
)
;
let
ok
=
true
;
for
(
i
=
0
;
i
<
reply
.
length
;
i
+
+
)
{
if
(
reply
[
i
]
=
=
1
)
{
for
(
;
i
<
reply
.
length
;
i
+
+
)
{
if
(
reply
[
i
]
=
=
2
)
{
ok
=
false
;
break
;
}
}
break
;
}
}
assert_true
(
ok
)
;
}
'
WebTransport
sendorder
should
starve
a
lower
priority
stream
variant
2
'
)
;
