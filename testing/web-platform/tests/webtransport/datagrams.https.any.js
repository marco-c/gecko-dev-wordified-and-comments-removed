async
function
write_datagrams
(
writer
signal
)
{
const
encoder
=
new
TextEncoder
(
)
;
let
counter
=
0
;
const
sentTokens
=
[
]
;
const
aborted
=
new
Promise
(
(
resolve
)
=
>
{
signal
.
addEventListener
(
'
abort
'
resolve
)
;
}
)
;
while
(
true
)
{
await
Promise
.
race
(
[
writer
.
ready
aborted
]
)
;
if
(
signal
.
aborted
)
{
break
;
}
var
token
=
counter
.
toString
(
)
;
sentTokens
.
push
(
token
)
;
writer
.
write
(
encoder
.
encode
(
token
)
)
;
counter
+
+
;
}
return
sentTokens
;
}
async
function
read_datagrams
(
reader
controller
N
)
{
const
decoder
=
new
TextDecoder
(
)
;
const
receivedTokens
=
[
]
;
while
(
receivedTokens
.
length
<
N
)
{
const
{
value
:
token
done
}
=
await
reader
.
read
(
)
;
assert_false
(
done
)
;
receivedTokens
.
push
(
decoder
.
decode
(
token
)
)
;
}
controller
.
abort
(
)
;
return
receivedTokens
;
}
async
function
write_numbers
(
writer
signal
)
{
let
counter
=
0
;
const
sentNumbers
=
[
]
;
const
aborted
=
new
Promise
(
(
resolve
)
=
>
{
signal
.
addEventListener
(
'
abort
'
resolve
)
;
}
)
;
while
(
true
&
&
counter
<
256
)
{
await
Promise
.
race
(
[
writer
.
ready
aborted
]
)
if
(
signal
.
aborted
)
{
break
;
}
sentNumbers
.
push
(
counter
)
;
chunk
=
new
Uint8Array
(
1
)
;
chunk
[
0
]
=
counter
;
writer
.
write
(
chunk
)
;
counter
+
+
;
}
return
sentNumbers
;
}
async
function
read_numbers_byob
(
reader
controller
N
)
{
let
buffer
=
new
ArrayBuffer
(
N
)
;
buffer
=
await
readInto
(
reader
buffer
)
;
controller
.
abort
(
)
;
return
Array
.
from
(
new
Uint8Array
(
buffer
)
)
;
}
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
reader
=
wt
.
datagrams
.
readable
.
getReader
(
)
;
const
controller
=
new
AbortController
(
)
;
const
signal
=
controller
.
signal
;
const
N
=
5
;
const
[
sentTokens
receivedTokens
]
=
await
Promise
.
all
(
[
write_datagrams
(
writer
signal
)
read_datagrams
(
reader
controller
N
)
]
)
;
const
subset
=
receivedTokens
.
every
(
token
=
>
sentTokens
.
includes
(
token
)
)
;
assert_true
(
subset
)
;
}
'
Datagrams
are
echoed
successfully
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
reader
=
wt
.
datagrams
.
readable
.
getReader
(
{
mode
:
'
byob
'
}
)
;
const
controller
=
new
AbortController
(
)
;
const
signal
=
controller
.
signal
;
const
N
=
5
;
const
[
sentNumbers
receiveNumbers
]
=
await
Promise
.
all
(
[
write_numbers
(
writer
signal
)
read_numbers_byob
(
reader
controller
N
)
]
)
;
assert_equals
(
(
new
Set
(
receiveNumbers
)
)
.
size
N
)
;
const
subset
=
receiveNumbers
.
every
(
token
=
>
sentNumbers
.
includes
(
token
)
)
;
assert_true
(
subset
)
;
}
'
Successfully
reading
datagrams
with
BYOB
reader
.
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
reader
=
wt
.
datagrams
.
readable
.
getReader
(
)
;
const
controller
=
new
AbortController
(
)
;
const
signal
=
controller
.
signal
;
const
N
=
1
;
const
[
sentTokens
receivedTokens
]
=
await
Promise
.
all
(
[
write_datagrams
(
writer
signal
)
read_datagrams
(
reader
controller
N
)
]
)
;
const
subset
=
receivedTokens
.
every
(
token
=
>
sentTokens
.
includes
(
token
)
)
;
assert_true
(
subset
)
;
await
wt
.
ready
;
}
'
Sending
and
receiving
datagrams
is
ready
to
use
before
session
is
established
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
N
=
5
;
wt
.
datagrams
.
outgoingHighWaterMark
=
N
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
encoder
=
new
TextEncoder
(
)
;
let
counter
;
for
(
counter
=
0
;
counter
<
N
-
1
;
counter
+
+
)
{
var
datagram
=
counter
.
toString
(
)
;
let
resolved
=
false
;
writer
.
write
(
encoder
.
encode
(
datagram
)
)
;
writer
.
ready
.
then
(
(
)
=
>
resolved
=
true
)
;
for
(
let
i
=
0
;
i
<
10
;
i
+
+
)
{
await
Promise
.
resolve
(
)
;
}
assert_true
(
resolved
)
;
}
resolved
=
false
;
const
last_datagram
=
counter
.
toString
(
)
;
writer
.
write
(
encoder
.
encode
(
last_datagram
)
)
;
writer
.
ready
.
then
(
(
)
=
>
resolved
=
true
)
;
for
(
let
i
=
0
;
i
<
10
;
i
+
+
)
{
await
Promise
.
resolve
(
)
;
}
assert_false
(
resolved
)
;
await
writer
.
ready
;
}
'
Datagram
\
'
s
outgoingHighWaterMark
correctly
regulates
written
datagrams
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
N
=
5
;
wt
.
datagrams
.
incomingHighWaterMark
=
N
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
encoder
=
new
TextEncoder
(
)
;
let
counter
;
for
(
counter
=
0
;
counter
<
10
*
N
;
counter
+
+
)
{
var
datagram
=
counter
.
toString
(
)
;
writer
.
write
(
encoder
.
encode
(
datagram
)
)
;
await
writer
.
ready
;
}
wait
(
500
)
;
const
reader
=
wt
.
datagrams
.
readable
.
getReader
(
)
;
let
receivedDatagrams
=
0
;
while
(
true
)
{
let
resolved
=
false
;
reader
.
read
(
)
.
then
(
(
)
=
>
resolved
=
true
)
;
for
(
let
i
=
0
;
i
<
10
;
i
+
+
)
{
await
Promise
.
resolve
(
)
;
}
if
(
!
resolved
)
{
break
;
}
receivedDatagrams
+
+
;
}
assert_less_than_equal
(
receivedDatagrams
N
)
;
}
'
Datagrams
read
is
less
than
or
equal
to
the
incomingHighWaterMark
'
)
;
