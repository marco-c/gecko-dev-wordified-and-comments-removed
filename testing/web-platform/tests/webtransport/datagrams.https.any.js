async
function
write_datagrams
(
writer
signal
)
{
const
encoder
=
new
TextEncoder
(
)
;
let
counter
=
0
;
const
sentTokens
=
[
]
;
const
aborted
=
new
Promise
(
(
resolve
)
=
>
{
signal
.
addEventListener
(
'
abort
'
resolve
)
;
}
)
;
while
(
true
)
{
await
Promise
.
race
(
[
writer
.
ready
aborted
]
)
;
if
(
signal
.
aborted
)
{
break
;
}
var
token
=
counter
.
toString
(
)
;
sentTokens
.
push
(
token
)
;
writer
.
write
(
encoder
.
encode
(
token
)
)
;
counter
+
+
;
}
return
sentTokens
;
}
async
function
write_N_datagrams
(
writer
n
)
{
const
encoder
=
new
TextEncoder
(
)
;
const
sentTokens
=
[
]
;
const
promises
=
[
]
;
while
(
sentTokens
.
length
<
n
)
{
const
token
=
sentTokens
.
length
.
toString
(
)
;
sentTokens
.
push
(
token
)
;
promises
.
push
(
writer
.
write
(
encoder
.
encode
(
token
)
)
)
;
}
await
Promise
.
all
(
promises
)
;
return
sentTokens
;
}
async
function
read_datagrams
(
reader
controller
N
)
{
const
decoder
=
new
TextDecoder
(
)
;
const
receivedTokens
=
[
]
;
while
(
receivedTokens
.
length
<
N
)
{
const
{
value
:
token
done
}
=
await
reader
.
read
(
)
;
assert_false
(
done
)
;
receivedTokens
.
push
(
decoder
.
decode
(
token
)
)
;
}
controller
.
abort
(
)
;
return
receivedTokens
;
}
async
function
write_numbers
(
writer
signal
)
{
let
counter
=
0
;
const
sentNumbers
=
[
]
;
const
aborted
=
new
Promise
(
(
resolve
)
=
>
signal
.
addEventListener
(
'
abort
'
resolve
)
)
;
while
(
counter
<
256
)
{
await
Promise
.
race
(
[
writer
.
ready
aborted
]
)
if
(
signal
.
aborted
)
{
break
;
}
sentNumbers
.
push
(
counter
)
;
chunk
=
new
Uint8Array
(
1
)
;
chunk
[
0
]
=
counter
;
writer
.
write
(
chunk
)
;
counter
+
+
;
}
return
sentNumbers
;
}
async
function
write_large_datagrams
(
writer
signal
)
{
const
aborted
=
new
Promise
(
(
resolve
)
=
>
{
signal
.
addEventListener
(
'
abort
'
resolve
)
;
}
)
;
while
(
true
)
{
await
Promise
.
race
(
[
writer
.
ready
aborted
]
)
;
if
(
signal
.
aborted
)
{
break
;
}
writer
.
write
(
new
Uint8Array
(
10
)
)
;
}
}
async
function
read_numbers_byob
(
reader
controller
N
)
{
let
buffer
=
new
ArrayBuffer
(
N
)
;
buffer
=
await
readInto
(
reader
buffer
)
;
controller
.
abort
(
)
;
return
Array
.
from
(
new
Uint8Array
(
buffer
)
)
;
}
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
reader
=
wt
.
datagrams
.
readable
.
getReader
(
)
;
const
controller
=
new
AbortController
(
)
;
const
signal
=
controller
.
signal
;
const
N
=
5
;
const
[
sentTokens
receivedTokens
]
=
await
Promise
.
all
(
[
write_datagrams
(
writer
signal
)
read_datagrams
(
reader
controller
N
)
]
)
;
const
subset
=
receivedTokens
.
every
(
token
=
>
sentTokens
.
includes
(
token
)
)
;
assert_true
(
subset
)
;
}
'
Datagrams
are
echoed
successfully
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
reader
=
wt
.
datagrams
.
readable
.
getReader
(
{
mode
:
'
byob
'
}
)
;
const
controller
=
new
AbortController
(
)
;
const
signal
=
controller
.
signal
;
const
N
=
5
;
const
[
sentNumbers
receiveNumbers
]
=
await
Promise
.
all
(
[
write_numbers
(
writer
signal
)
read_numbers_byob
(
reader
controller
N
)
]
)
;
assert_equals
(
(
new
Set
(
receiveNumbers
)
)
.
size
N
)
;
const
subset
=
receiveNumbers
.
every
(
token
=
>
sentNumbers
.
includes
(
token
)
)
;
assert_true
(
subset
)
;
}
'
Successfully
reading
datagrams
with
BYOB
reader
.
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
reader
=
wt
.
datagrams
.
readable
.
getReader
(
{
mode
:
'
byob
'
}
)
;
const
controller
=
new
AbortController
(
)
;
const
signal
=
controller
.
signal
;
const
buffer
=
new
ArrayBuffer
(
1
)
;
const
[
error
_
]
=
await
Promise
.
all
(
[
reader
.
read
(
new
Uint8Array
(
buffer
)
)
.
catch
(
e
=
>
{
controller
.
abort
(
)
;
return
e
;
}
)
write_large_datagrams
(
writer
signal
)
]
)
;
assert_equals
(
error
.
name
'
RangeError
'
)
;
}
'
Reading
datagrams
with
insufficient
buffer
should
be
rejected
.
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
reader
=
wt
.
datagrams
.
readable
.
getReader
(
)
;
await
writer
.
write
(
new
Uint8Array
(
wt
.
datagrams
.
maxDatagramSize
)
)
;
const
{
value
:
token
done
}
=
await
reader
.
read
(
)
;
assert_false
(
done
)
;
assert_equals
(
token
.
length
wt
.
datagrams
.
maxDatagramSize
)
;
}
'
Transfer
max
-
size
datagram
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
reader
=
wt
.
datagrams
.
readable
.
getReader
(
)
;
await
writer
.
write
(
new
Uint8Array
(
wt
.
datagrams
.
maxDatagramSize
+
1
)
)
;
const
result
=
await
Promise
.
race
(
[
reader
.
read
(
)
wait
(
500
)
]
)
;
assert_equals
(
result
undefined
)
;
}
'
Fail
to
transfer
max
-
size
+
1
datagram
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
reader
=
wt
.
datagrams
.
readable
.
getReader
(
)
;
const
controller
=
new
AbortController
(
)
;
const
signal
=
controller
.
signal
;
const
N
=
5
;
wt
.
datagrams
.
outgoingHighWaterMark
=
N
;
const
[
sentTokens
receivedTokens
]
=
await
Promise
.
all
(
[
write_N_datagrams
(
writer
N
)
read_datagrams
(
reader
controller
N
)
]
)
;
const
subset
=
receivedTokens
.
every
(
token
=
>
sentTokens
.
includes
(
token
)
)
;
assert_true
(
subset
)
;
await
wt
.
ready
;
}
'
Sending
and
receiving
datagrams
is
ready
to
use
before
session
is
established
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
N
=
5
;
wt
.
datagrams
.
outgoingHighWaterMark
=
N
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
encoder
=
new
TextEncoder
(
)
;
let
counter
;
for
(
counter
=
0
;
counter
<
N
-
1
;
counter
+
+
)
{
var
datagram
=
counter
.
toString
(
)
;
let
resolved
=
false
;
writer
.
write
(
encoder
.
encode
(
datagram
)
)
;
writer
.
ready
.
then
(
(
)
=
>
resolved
=
true
)
;
for
(
let
i
=
0
;
i
<
10
;
i
+
+
)
{
await
Promise
.
resolve
(
)
;
}
assert_true
(
resolved
)
;
}
resolved
=
false
;
const
last_datagram
=
counter
.
toString
(
)
;
writer
.
write
(
encoder
.
encode
(
last_datagram
)
)
;
writer
.
ready
.
then
(
(
)
=
>
resolved
=
true
)
;
for
(
let
i
=
0
;
i
<
10
;
i
+
+
)
{
await
Promise
.
resolve
(
)
;
}
assert_false
(
resolved
)
;
await
writer
.
ready
;
}
'
Datagram
\
'
s
outgoingHighWaterMark
correctly
regulates
written
datagrams
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
N
=
5
;
wt
.
datagrams
.
incomingHighWaterMark
=
N
;
const
writer
=
wt
.
datagrams
.
writable
.
getWriter
(
)
;
const
encoder
=
new
TextEncoder
(
)
;
let
counter
;
for
(
counter
=
0
;
counter
<
10
*
N
;
counter
+
+
)
{
var
datagram
=
counter
.
toString
(
)
;
writer
.
write
(
encoder
.
encode
(
datagram
)
)
;
await
writer
.
ready
;
}
wait
(
500
)
;
const
reader
=
wt
.
datagrams
.
readable
.
getReader
(
)
;
let
receivedDatagrams
=
0
;
while
(
true
)
{
let
resolved
=
false
;
reader
.
read
(
)
.
then
(
(
)
=
>
resolved
=
true
)
;
for
(
let
i
=
0
;
i
<
10
;
i
+
+
)
{
await
Promise
.
resolve
(
)
;
}
if
(
!
resolved
)
{
break
;
}
receivedDatagrams
+
+
;
}
assert_less_than_equal
(
receivedDatagrams
N
)
;
}
'
Datagrams
read
is
less
than
or
equal
to
the
incomingHighWaterMark
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
assert_equals
(
wt
.
datagrams
.
incomingMaxAge
Infinity
)
;
assert_equals
(
wt
.
datagrams
.
outgoingMaxAge
Infinity
)
;
wt
.
datagrams
.
incomingMaxAge
=
5
;
assert_equals
(
wt
.
datagrams
.
incomingMaxAge
5
)
;
wt
.
datagrams
.
outgoingMaxAge
=
5
;
assert_equals
(
wt
.
datagrams
.
outgoingMaxAge
5
)
;
assert_throws_js
(
RangeError
(
)
=
>
{
wt
.
datagrams
.
incomingMaxAge
=
-
1
;
}
)
;
assert_throws_js
(
RangeError
(
)
=
>
{
wt
.
datagrams
.
outgoingMaxAge
=
-
1
;
}
)
;
assert_throws_js
(
RangeError
(
)
=
>
{
wt
.
datagrams
.
incomingMaxAge
=
NaN
;
}
)
;
assert_throws_js
(
RangeError
(
)
=
>
{
wt
.
datagrams
.
outgoingMaxAge
=
NaN
;
}
)
;
wt
.
datagrams
.
incomingMaxAge
=
0
;
assert_equals
(
wt
.
datagrams
.
incomingMaxAge
Infinity
)
;
wt
.
datagrams
.
outgoingMaxAge
=
0
;
assert_equals
(
wt
.
datagrams
.
outgoingMaxAge
Infinity
)
;
}
'
Datagram
MaxAge
getters
/
setters
work
correctly
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
assert_greater_than_equal
(
wt
.
datagrams
.
incomingHighWaterMark
1
)
;
assert_greater_than_equal
(
wt
.
datagrams
.
outgoingHighWaterMark
1
)
;
wt
.
datagrams
.
incomingHighWaterMark
=
5
;
assert_equals
(
wt
.
datagrams
.
incomingHighWaterMark
5
)
;
wt
.
datagrams
.
outgoingHighWaterMark
=
5
;
assert_equals
(
wt
.
datagrams
.
outgoingHighWaterMark
5
)
;
assert_throws_js
(
RangeError
(
)
=
>
{
wt
.
datagrams
.
incomingHighWaterMark
=
-
1
;
}
)
;
assert_throws_js
(
RangeError
(
)
=
>
{
wt
.
datagrams
.
outgoingHighWaterMark
=
-
1
;
}
)
;
assert_throws_js
(
RangeError
(
)
=
>
{
wt
.
datagrams
.
incomingHighWaterMark
=
NaN
;
}
)
;
assert_throws_js
(
RangeError
(
)
=
>
{
wt
.
datagrams
.
outgoingHighWaterMark
=
NaN
;
}
)
;
wt
.
datagrams
.
incomingHighWaterMark
=
0
.
5
;
assert_equals
(
wt
.
datagrams
.
incomingHighWaterMark
1
)
;
wt
.
datagrams
.
outgoingHighWaterMark
=
0
.
5
;
assert_equals
(
wt
.
datagrams
.
outgoingHighWaterMark
1
)
;
wt
.
datagrams
.
incomingHighWaterMark
=
0
;
assert_equals
(
wt
.
datagrams
.
incomingHighWaterMark
1
)
;
wt
.
datagrams
.
outgoingHighWaterMark
=
0
;
assert_equals
(
wt
.
datagrams
.
outgoingHighWaterMark
1
)
;
}
'
Datagram
HighWaterMark
getters
/
setters
work
correctly
'
)
;
