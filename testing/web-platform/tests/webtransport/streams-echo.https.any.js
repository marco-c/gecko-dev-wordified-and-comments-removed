promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
bidi_stream
=
await
wt
.
createBidirectionalStream
(
)
;
const
writer
=
bidi_stream
.
writable
.
getWriter
(
)
;
const
encoder
=
new
TextEncoder
(
)
;
await
writer
.
write
(
encoder
.
encode
(
'
Hello
World
'
)
)
;
await
writer
.
close
(
)
;
const
reply
=
await
read_stream_as_string
(
bidi_stream
.
readable
)
;
assert_equals
(
reply
'
Hello
World
'
)
;
}
'
WebTransport
server
should
be
able
to
create
and
handle
a
bidirectional
stream
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
stream_reader
=
wt
.
incomingBidirectionalStreams
.
getReader
(
)
;
const
{
value
:
bidi_stream
}
=
await
stream_reader
.
read
(
)
;
stream_reader
.
releaseLock
(
)
;
const
encoder
=
new
TextEncoderStream
(
)
;
encoder
.
readable
.
pipeTo
(
bidi_stream
.
writable
)
;
const
writer
=
encoder
.
writable
.
getWriter
(
)
;
await
writer
.
write
(
'
Hello
World
'
)
;
await
writer
.
close
(
)
;
const
reply
=
await
read_stream_as_string
(
bidi_stream
.
readable
)
;
assert_equals
(
reply
'
Hello
World
'
)
;
}
'
WebTransport
server
should
be
able
to
accept
and
handle
a
bidirectional
stream
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
writable
=
await
wt
.
createUnidirectionalStream
(
)
;
const
encoder
=
new
TextEncoderStream
(
)
;
encoder
.
readable
.
pipeTo
(
writable
)
;
const
writer
=
encoder
.
writable
.
getWriter
(
)
;
await
writer
.
write
(
'
Hello
World
'
)
;
await
writer
.
close
(
)
;
const
readable
=
wt
.
incomingUnidirectionalStreams
;
const
stream_reader
=
readable
.
getReader
(
)
;
const
{
value
:
recv_stream
}
=
await
stream_reader
.
read
(
)
;
stream_reader
.
releaseLock
(
)
;
const
reply
=
await
read_stream_as_string
(
recv_stream
)
;
assert_equals
(
reply
'
Hello
World
'
)
;
}
'
WebTransport
server
should
be
able
to
create
accept
and
handle
a
unidirectional
stream
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
stream_reader
=
wt
.
incomingBidirectionalStreams
.
getReader
(
)
;
const
{
value
:
bidi_stream
}
=
await
stream_reader
.
read
(
)
;
stream_reader
.
releaseLock
(
)
;
const
buffer_size
=
256
;
const
data
=
new
Uint8Array
(
buffer_size
)
;
for
(
let
i
=
0
;
i
<
data
.
byteLength
;
+
+
i
)
{
data
[
i
]
=
i
;
}
const
writer
=
bidi_stream
.
writable
.
getWriter
(
)
;
writer
.
write
(
data
)
;
await
writer
.
close
(
)
;
const
reader
=
bidi_stream
.
readable
.
getReader
(
{
mode
:
'
byob
'
}
)
;
assert_true
(
reader
instanceof
ReadableStreamBYOBReader
)
;
const
half_buffer_size
=
buffer_size
/
2
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
let
buffer
=
new
ArrayBuffer
(
half_buffer_size
)
;
buffer
=
await
readInto
(
reader
buffer
)
;
assert_array_equals
(
new
Uint8Array
(
buffer
)
data
.
subarray
(
half_buffer_size
*
i
half_buffer_size
*
(
i
+
1
)
)
)
}
reader
.
releaseLock
(
)
;
}
'
Can
read
data
from
a
bidirectional
stream
with
BYOB
reader
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
writable
=
await
wt
.
createUnidirectionalStream
(
)
;
const
buffer_size
=
256
;
const
data
=
new
Uint8Array
(
buffer_size
)
;
for
(
let
i
=
0
;
i
<
data
.
byteLength
;
+
+
i
)
{
data
[
i
]
=
i
;
}
const
writer
=
writable
.
getWriter
(
)
;
writer
.
write
(
data
)
;
await
writer
.
close
(
)
;
const
readable
=
wt
.
incomingUnidirectionalStreams
;
const
stream_reader
=
readable
.
getReader
(
)
;
const
{
value
:
recv_stream
}
=
await
stream_reader
.
read
(
)
;
stream_reader
.
releaseLock
(
)
;
const
reader
=
recv_stream
.
getReader
(
{
mode
:
'
byob
'
}
)
;
assert_true
(
reader
instanceof
ReadableStreamBYOBReader
)
;
const
half_buffer_size
=
buffer_size
/
2
;
let
buffer
=
new
ArrayBuffer
(
half_buffer_size
)
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
buffer
=
await
readInto
(
reader
buffer
)
;
assert_array_equals
(
new
Uint8Array
(
buffer
)
data
.
subarray
(
half_buffer_size
*
i
half_buffer_size
*
(
i
+
1
)
)
)
}
reader
.
releaseLock
(
)
;
}
'
Can
read
data
from
a
unidirectional
stream
with
BYOB
reader
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
bidi_stream
=
await
wt
.
createBidirectionalStream
(
)
;
const
writer
=
bidi_stream
.
writable
.
getWriter
(
)
;
const
bytes
=
new
Uint8Array
(
16384
)
;
const
[
reply
]
=
await
Promise
.
all
(
[
read_stream
(
bidi_stream
.
readable
)
writer
.
write
(
bytes
)
writer
.
write
(
bytes
)
writer
.
write
(
bytes
)
writer
.
close
(
)
]
)
;
let
len
=
0
;
for
(
chunk
of
reply
)
{
len
+
=
chunk
.
length
;
}
assert_equals
(
len
3
*
bytes
.
length
)
;
}
'
Transfer
large
chunks
of
data
on
a
bidirectional
stream
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
uni_stream
=
await
wt
.
createUnidirectionalStream
(
)
;
const
writer
=
uni_stream
.
getWriter
(
)
;
const
bytes
=
new
Uint8Array
(
16384
)
;
await
Promise
.
all
(
[
writer
.
write
(
bytes
)
writer
.
write
(
bytes
)
writer
.
write
(
bytes
)
writer
.
close
(
)
]
)
;
const
readable
=
wt
.
incomingUnidirectionalStreams
;
const
stream_reader
=
readable
.
getReader
(
)
;
const
{
value
:
recv_stream
}
=
await
stream_reader
.
read
(
)
;
stream_reader
.
releaseLock
(
)
;
const
reply
=
await
read_stream
(
recv_stream
)
;
let
len
=
0
;
for
(
chunk
of
reply
)
{
len
+
=
chunk
.
length
;
}
assert_equals
(
len
3
*
bytes
.
length
)
;
}
'
Transfer
large
chunks
of
data
on
a
unidirectional
stream
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
bidi_stream
=
await
wt
.
createBidirectionalStream
(
)
;
const
writer
=
bidi_stream
.
writable
.
getWriter
(
)
;
writer
.
close
(
)
;
const
chunks
=
await
read_stream
(
bidi_stream
.
readable
)
;
assert_equals
(
chunks
.
length
0
)
;
await
bidi_stream
.
readable
.
closed
;
}
'
Closing
the
stream
with
no
data
still
resolves
the
read
request
'
)
;
