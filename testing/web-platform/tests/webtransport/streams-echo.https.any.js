promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
bidi_stream
=
await
wt
.
createBidirectionalStream
(
)
;
const
writer
=
bidi_stream
.
writable
.
getWriter
(
)
;
const
encoder
=
new
TextEncoder
(
)
;
await
writer
.
write
(
encoder
.
encode
(
'
Hello
World
'
)
)
;
await
writer
.
close
(
)
;
const
reply
=
await
read_stream_as_string
(
bidi_stream
.
readable
)
;
assert_equals
(
reply
'
Hello
World
'
)
;
}
'
WebTransport
server
should
be
able
to
create
and
handle
a
bidirectional
stream
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
stream_reader
=
wt
.
incomingBidirectionalStreams
.
getReader
(
)
;
const
{
value
:
bidi_stream
}
=
await
stream_reader
.
read
(
)
;
stream_reader
.
releaseLock
(
)
;
const
encoder
=
new
TextEncoderStream
(
)
;
encoder
.
readable
.
pipeTo
(
bidi_stream
.
writable
)
;
const
writer
=
encoder
.
writable
.
getWriter
(
)
;
await
writer
.
write
(
'
Hello
World
'
)
;
await
writer
.
close
(
)
;
const
reply
=
await
read_stream_as_string
(
bidi_stream
.
readable
)
;
assert_equals
(
reply
'
Hello
World
'
)
;
}
'
WebTransport
server
should
be
able
to
accept
and
handle
a
bidirectional
stream
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
writable
=
await
wt
.
createUnidirectionalStream
(
)
;
const
encoder
=
new
TextEncoderStream
(
)
;
encoder
.
readable
.
pipeTo
(
writable
)
;
const
writer
=
encoder
.
writable
.
getWriter
(
)
;
await
writer
.
write
(
'
Hello
World
'
)
;
await
writer
.
close
(
)
;
const
readable
=
wt
.
incomingUnidirectionalStreams
;
const
stream_reader
=
readable
.
getReader
(
)
;
const
{
value
:
recv_stream
}
=
await
stream_reader
.
read
(
)
;
stream_reader
.
releaseLock
(
)
;
const
reply
=
await
read_stream_as_string
(
recv_stream
)
;
assert_equals
(
reply
'
Hello
World
'
)
;
}
'
WebTransport
server
should
be
able
to
create
accept
and
handle
a
unidirectional
stream
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
stream_reader
=
wt
.
incomingBidirectionalStreams
.
getReader
(
)
;
const
{
value
:
bidi_stream
}
=
await
stream_reader
.
read
(
)
;
stream_reader
.
releaseLock
(
)
;
const
buffer_size
=
256
;
const
data
=
new
Uint8Array
(
buffer_size
)
;
for
(
let
i
=
0
;
i
<
data
.
byteLength
;
+
+
i
)
{
data
[
i
]
=
i
;
}
const
writer
=
bidi_stream
.
writable
.
getWriter
(
)
;
writer
.
write
(
data
)
;
await
writer
.
close
(
)
;
const
reader
=
bidi_stream
.
readable
.
getReader
(
{
mode
:
'
byob
'
}
)
;
assert_true
(
reader
instanceof
ReadableStreamBYOBReader
)
;
const
half_buffer_size
=
buffer_size
/
2
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
let
buffer
=
new
ArrayBuffer
(
half_buffer_size
)
;
buffer
=
await
readInto
(
reader
buffer
)
;
assert_array_equals
(
new
Uint8Array
(
buffer
)
data
.
subarray
(
half_buffer_size
*
i
half_buffer_size
*
(
i
+
1
)
)
)
}
reader
.
releaseLock
(
)
;
}
'
Can
read
data
from
a
bidirectional
stream
with
BYOB
reader
'
)
;
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
webtransport_url
(
'
echo
.
py
'
)
)
;
await
wt
.
ready
;
const
writable
=
await
wt
.
createUnidirectionalStream
(
)
;
const
buffer_size
=
256
;
const
data
=
new
Uint8Array
(
buffer_size
)
;
for
(
let
i
=
0
;
i
<
data
.
byteLength
;
+
+
i
)
{
data
[
i
]
=
i
;
}
const
writer
=
writable
.
getWriter
(
)
;
writer
.
write
(
data
)
;
await
writer
.
close
(
)
;
const
readable
=
wt
.
incomingUnidirectionalStreams
;
const
stream_reader
=
readable
.
getReader
(
)
;
const
{
value
:
recv_stream
}
=
await
stream_reader
.
read
(
)
;
stream_reader
.
releaseLock
(
)
;
const
reader
=
recv_stream
.
getReader
(
{
mode
:
'
byob
'
}
)
;
assert_true
(
reader
instanceof
ReadableStreamBYOBReader
)
;
const
half_buffer_size
=
buffer_size
/
2
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
let
buffer
=
new
ArrayBuffer
(
half_buffer_size
)
;
buffer
=
await
readInto
(
reader
buffer
)
;
assert_array_equals
(
new
Uint8Array
(
buffer
)
data
.
subarray
(
half_buffer_size
*
i
half_buffer_size
*
(
i
+
1
)
)
)
}
reader
.
releaseLock
(
)
;
}
'
Can
read
data
from
a
unidirectional
stream
with
BYOB
reader
'
)
;
