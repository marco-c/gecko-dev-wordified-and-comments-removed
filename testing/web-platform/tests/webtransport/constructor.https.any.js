const
BAD_URLS
=
[
null
'
'
'
no
-
scheme
'
'
http
:
/
/
example
.
com
/
'
'
quic
-
transport
:
/
/
example
.
com
/
'
'
https
:
/
/
/
'
'
https
:
/
/
example
.
com
/
#
failing
'
https
:
/
/
{
HOST
}
:
999999
/
]
;
for
(
const
url
of
BAD_URLS
)
{
test
(
(
)
=
>
{
assert_throws_dom
(
'
SyntaxError
'
(
)
=
>
new
WebTransport
(
url
)
'
constructor
should
throw
'
)
;
}
WebTransport
constructor
should
reject
URL
'
{
url
}
'
)
;
}
const
OPTIONS
=
[
{
allowPooling
:
true
}
{
requireUnreliable
:
true
}
{
allowPooling
:
true
requireUnreliable
:
true
}
{
congestionControl
:
"
default
"
}
{
congestionControl
:
"
throughput
"
}
{
congestionControl
:
"
low
-
latency
"
}
{
allowPooling
:
true
requireUnreliable
:
true
congestionControl
:
"
low
-
latency
"
}
]
;
for
(
const
options
of
OPTIONS
)
{
promise_test
(
async
t
=
>
{
const
id
=
token
(
)
;
const
wt
=
new
WebTransport
(
webtransport_url
(
client
-
close
.
py
?
token
=
{
id
}
)
options
)
;
await
wt
.
ready
;
wt
.
close
(
)
;
}
"
WebTransport
constructor
should
allow
options
"
+
JSON
.
stringify
(
options
)
)
;
}
promise_test
(
async
t
=
>
{
const
wt
=
new
WebTransport
(
https
:
/
/
{
HOST
}
:
0
/
)
;
const
e
=
await
wt
.
ready
.
catch
(
e
=
>
e
)
;
await
promise_rejects_exactly
(
t
e
wt
.
ready
'
ready
should
be
rejected
'
)
;
await
promise_rejects_exactly
(
t
e
wt
.
closed
'
closed
should
be
rejected
'
)
;
assert_true
(
e
instanceof
WebTransportError
)
;
assert_equals
(
e
.
source
'
session
'
'
source
'
)
;
assert_equals
(
e
.
streamErrorCode
null
'
streamErrorCode
'
)
;
}
'
Connection
to
port
0
should
fail
'
)
;
