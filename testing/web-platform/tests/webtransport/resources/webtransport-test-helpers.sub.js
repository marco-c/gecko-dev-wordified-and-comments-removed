const
HOST
=
get_host_info
(
)
.
ORIGINAL_HOST
;
const
PORT
=
'
{
{
ports
[
webtransport
-
h3
]
[
0
]
}
}
'
;
const
BASE
=
https
:
/
/
{
HOST
}
:
{
PORT
}
;
function
wait
(
ms
)
{
return
new
Promise
(
res
=
>
step_timeout
(
res
ms
)
)
;
}
function
webtransport_url
(
handler
)
{
return
{
BASE
}
/
webtransport
/
handlers
/
{
handler
}
;
}
function
webtransport_code_to_http_code
(
n
)
{
const
first
=
0x52e4a40fa8db
;
return
first
+
n
+
Math
.
floor
(
n
/
0x1e
)
;
}
async
function
read_stream_as_string
(
readable_stream
)
{
const
decoder
=
new
TextDecoderStream
(
)
;
const
decode_stream
=
readable_stream
.
pipeThrough
(
decoder
)
;
const
reader
=
decode_stream
.
getReader
(
)
;
let
chunks
=
'
'
;
while
(
true
)
{
const
{
value
:
chunk
done
}
=
await
reader
.
read
(
)
;
if
(
done
)
{
break
;
}
chunks
+
=
chunk
;
}
reader
.
releaseLock
(
)
;
return
chunks
;
}
async
function
read_stream_as_json
(
readable_stream
)
{
const
text
=
await
read_stream_as_string
(
readable_stream
)
;
return
JSON
.
parse
(
text
)
;
}
function
check_and_remove_standard_headers
(
headers
)
{
assert_equals
(
headers
[
'
:
scheme
'
]
'
https
'
)
;
delete
headers
[
'
:
scheme
'
]
;
assert_equals
(
headers
[
'
:
method
'
]
'
CONNECT
'
)
;
delete
headers
[
'
:
method
'
]
;
assert_equals
(
headers
[
'
:
authority
'
]
{
HOST
}
:
{
PORT
}
)
;
delete
headers
[
'
:
authority
'
]
;
assert_equals
(
headers
[
'
:
path
'
]
'
/
webtransport
/
handlers
/
echo
-
request
-
headers
.
py
'
)
;
delete
headers
[
'
:
path
'
]
;
assert_equals
(
headers
[
'
:
protocol
'
]
'
webtransport
'
)
;
delete
headers
[
'
:
protocol
'
]
;
assert_equals
(
headers
[
'
origin
'
]
{
get_host_info
(
)
.
ORIGIN
}
)
;
delete
headers
[
'
origin
'
]
;
}
async
function
query
(
token
)
{
const
wt
=
new
WebTransport
(
webtransport_url
(
query
.
py
?
token
=
{
token
}
)
)
;
try
{
await
wt
.
ready
;
const
streams
=
await
wt
.
incomingUnidirectionalStreams
;
const
streams_reader
=
streams
.
getReader
(
)
;
const
{
value
:
readable
}
=
await
streams_reader
.
read
(
)
;
streams_reader
.
releaseLock
(
)
;
return
await
read_stream_as_json
(
readable
)
;
}
finally
{
wt
.
close
(
)
;
}
}
