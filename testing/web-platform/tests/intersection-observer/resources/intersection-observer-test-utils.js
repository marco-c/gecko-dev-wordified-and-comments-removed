function
waitForNotification
(
t
f
)
{
return
new
Promise
(
resolve
=
>
{
requestAnimationFrame
(
function
(
)
{
requestAnimationFrame
(
function
(
)
{
let
callback
=
function
(
)
{
resolve
(
)
;
if
(
f
)
{
f
(
)
;
}
}
;
if
(
t
)
{
t
.
step_timeout
(
callback
)
;
}
else
{
setTimeout
(
callback
)
;
}
}
)
;
}
)
;
}
)
;
}
function
waitForFrame
(
t
f
)
{
return
new
Promise
(
resolve
=
>
{
requestAnimationFrame
(
function
(
)
{
t
.
step_timeout
(
function
(
)
{
resolve
(
)
;
if
(
f
)
{
f
(
)
;
}
}
)
;
}
)
;
}
)
;
}
function
runTestCycle
(
f
description
delay
)
{
async_test
(
function
(
t
)
{
if
(
delay
)
{
step_timeout
(
(
)
=
>
{
waitForNotification
(
t
t
.
step_func_done
(
f
)
)
;
}
delay
)
;
}
else
{
waitForNotification
(
t
t
.
step_func_done
(
f
)
)
;
}
}
description
)
;
}
function
contentBounds
(
root
)
{
var
left
=
root
.
offsetLeft
+
root
.
clientLeft
;
var
right
=
left
+
root
.
clientWidth
;
var
top
=
root
.
offsetTop
+
root
.
clientTop
;
var
bottom
=
top
+
root
.
clientHeight
;
return
[
left
right
top
bottom
]
;
}
function
borderBoxBounds
(
root
)
{
var
left
=
root
.
offsetLeft
;
var
right
=
left
+
root
.
offsetWidth
;
var
top
=
root
.
offsetTop
;
var
bottom
=
top
+
root
.
offsetHeight
;
return
[
left
right
top
bottom
]
;
}
function
clientBounds
(
element
)
{
var
rect
=
element
.
getBoundingClientRect
(
)
;
return
[
rect
.
left
rect
.
right
rect
.
top
rect
.
bottom
]
;
}
function
rectArea
(
rect
)
{
return
(
rect
.
left
-
rect
.
right
)
*
(
rect
.
bottom
-
rect
.
top
)
;
}
function
checkRect
(
actual
expected
description
epsilon
=
0
)
{
if
(
!
expected
.
length
)
return
;
assert_approx_equals
(
actual
.
left
expected
[
0
]
epsilon
description
+
'
.
left
'
)
;
assert_approx_equals
(
actual
.
right
expected
[
1
]
epsilon
description
+
'
.
right
'
)
;
assert_approx_equals
(
actual
.
top
expected
[
2
]
epsilon
description
+
'
.
top
'
)
;
assert_approx_equals
(
actual
.
bottom
expected
[
3
]
epsilon
description
+
'
.
bottom
'
)
;
}
function
checkLastEntry
(
entries
i
expected
epsilon
=
0
)
{
assert_equals
(
entries
.
length
i
+
1
'
entries
.
length
'
)
;
if
(
expected
)
{
checkRect
(
entries
[
i
]
.
boundingClientRect
expected
.
slice
(
0
4
)
'
entries
[
'
+
i
+
'
]
.
boundingClientRect
'
epsilon
)
;
checkRect
(
entries
[
i
]
.
intersectionRect
expected
.
slice
(
4
8
)
'
entries
[
'
+
i
+
'
]
.
intersectionRect
'
epsilon
)
;
checkRect
(
entries
[
i
]
.
rootBounds
expected
.
slice
(
8
12
)
'
entries
[
'
+
i
+
'
]
.
rootBounds
'
epsilon
)
;
if
(
expected
.
length
>
12
)
{
assert_equals
(
entries
[
i
]
.
isIntersecting
expected
[
12
]
'
entries
[
'
+
i
+
'
]
.
isIntersecting
'
)
;
}
}
}
function
checkJsonEntry
(
actual
expected
)
{
checkRect
(
actual
.
boundingClientRect
expected
.
boundingClientRect
'
entry
.
boundingClientRect
'
)
;
checkRect
(
actual
.
intersectionRect
expected
.
intersectionRect
'
entry
.
intersectionRect
'
)
;
if
(
actual
.
rootBounds
=
=
'
null
'
)
assert_equals
(
expected
.
rootBounds
'
null
'
'
rootBounds
is
null
'
)
;
else
checkRect
(
actual
.
rootBounds
expected
.
rootBounds
'
entry
.
rootBounds
'
)
;
assert_equals
(
actual
.
isIntersecting
expected
.
isIntersecting
)
;
assert_equals
(
actual
.
target
expected
.
target
)
;
}
function
checkJsonEntries
(
actual
expected
description
)
{
test
(
function
(
)
{
assert_equals
(
actual
.
length
expected
.
length
)
;
for
(
var
i
=
0
;
i
<
actual
.
length
;
i
+
+
)
checkJsonEntry
(
actual
[
i
]
expected
[
i
]
)
;
}
description
)
;
}
function
checkIsIntersecting
(
entries
i
expected
)
{
assert_equals
(
entries
[
i
]
.
isIntersecting
expected
'
entries
[
'
+
i
+
'
]
.
target
.
isIntersecting
equals
'
+
expected
)
;
}
