'
use
strict
'
;
let
testPrefix
=
'
insecure
-
context
'
;
let
topLevelDocument
=
true
;
const
queryParams
=
window
.
location
.
search
.
substring
(
1
)
.
split
(
'
&
'
)
;
queryParams
.
forEach
(
(
param
)
=
>
{
if
(
param
.
toLowerCase
(
)
=
=
'
rootdocument
=
false
'
)
{
topLevelDocument
=
false
;
}
else
if
(
param
.
split
(
'
=
'
)
[
0
]
.
toLowerCase
(
)
=
=
'
testcase
'
)
{
testPrefix
=
param
.
split
(
'
=
'
)
[
1
]
;
}
}
)
;
function
RunRequestStorageAccessForInDetachedFrame
(
origin
)
{
const
nestedFrame
=
document
.
createElement
(
'
iframe
'
)
;
document
.
body
.
append
(
nestedFrame
)
;
const
inner_doc
=
nestedFrame
.
contentDocument
;
nestedFrame
.
remove
(
)
;
return
inner_doc
.
requestStorageAccessFor
(
origin
)
;
}
function
RunRequestStorageAccessForViaDomParser
(
origin
)
{
const
parser
=
new
DOMParser
(
)
;
const
doc
=
parser
.
parseFromString
(
'
<
html
>
<
/
html
>
'
'
text
/
html
'
)
;
return
doc
.
requestStorageAccessFor
(
origin
)
;
}
test
(
(
)
=
>
{
assert_not_equals
(
document
.
requestStorageAccessFor
undefined
)
;
}
'
[
'
+
testPrefix
+
'
]
document
.
requestStorageAccessFor
(
)
should
be
supported
on
the
document
interface
'
)
;
if
(
topLevelDocument
)
{
promise_test
(
t
=
>
{
return
promise_rejects_dom
(
t
'
NotAllowedError
'
document
.
requestStorageAccessFor
(
'
https
:
/
/
test
.
com
'
)
'
document
.
requestStorageAccessFor
(
)
call
without
user
gesture
'
)
;
}
'
[
'
+
testPrefix
+
'
]
document
.
requestStorageAccessFor
(
)
should
be
rejected
by
default
with
no
user
gesture
'
)
;
promise_test
(
async
t
=
>
{
const
description
=
'
document
.
requestStorageAccessFor
(
)
call
in
a
detached
frame
'
;
return
RunRequestStorageAccessForInDetachedFrame
(
'
https
:
/
/
foo
.
com
'
)
.
then
(
t
.
unreached_func
(
'
Should
have
rejected
:
'
+
description
)
)
.
catch
(
(
e
)
=
>
{
assert_equals
(
e
.
name
'
InvalidStateError
'
description
)
;
}
)
;
}
'
[
non
-
fully
-
active
]
document
.
requestStorageAccessFor
(
)
should
not
resolve
when
run
in
a
detached
frame
'
)
;
promise_test
(
async
t
=
>
{
const
description
=
'
document
.
requestStorageAccessFor
(
)
in
a
detached
DOMParser
result
'
;
return
RunRequestStorageAccessForViaDomParser
(
'
https
:
/
/
foo
.
com
'
)
.
then
(
t
.
unreached_func
(
'
Should
have
rejected
:
'
+
description
)
)
.
catch
(
(
e
)
=
>
{
assert_equals
(
e
.
name
'
InvalidStateError
'
description
)
;
}
)
;
}
'
[
non
-
fully
-
active
]
document
.
requestStorageAccessFor
(
)
should
not
resolve
when
run
in
a
detached
DOMParser
document
'
)
;
RunTestsInIFrame
(
'
.
/
resources
/
requestStorageAccessFor
-
iframe
.
html
?
testCase
=
frame
-
on
-
insecure
-
page
&
rootdocument
=
false
'
)
;
promise_test
(
async
t
=
>
{
await
RunCallbackWithGesture
(
(
)
=
>
promise_rejects_dom
(
t
'
NotAllowedError
'
document
.
requestStorageAccessFor
(
document
.
location
.
origin
)
'
document
.
requestStorageAccessFor
(
)
call
in
insecure
context
'
)
)
;
}
'
[
'
+
testPrefix
+
'
]
document
.
requestStorageAccessFor
(
)
should
be
rejected
when
called
in
an
insecure
context
'
)
;
}
else
{
promise_test
(
async
t
=
>
{
await
RunCallbackWithGesture
(
(
)
=
>
promise_rejects_dom
(
t
'
NotAllowedError
'
document
.
requestStorageAccessFor
(
document
.
location
.
origin
)
'
document
.
requestStorageAccessFor
(
)
call
in
a
non
-
top
-
level
context
'
)
)
;
}
'
[
'
+
testPrefix
+
'
]
document
.
requestStorageAccessFor
(
)
should
be
rejected
when
called
in
an
iframe
'
)
;
}
