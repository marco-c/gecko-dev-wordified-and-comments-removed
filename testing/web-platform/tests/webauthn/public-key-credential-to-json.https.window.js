function
assertObjectKeysEq
(
a
b
)
{
let
a_keys
=
new
Set
(
Object
.
keys
(
a
)
)
;
let
b_keys
=
new
Set
(
Object
.
keys
(
b
)
)
;
assert_true
(
a_keys
.
length
=
=
b_keys
.
length
&
&
[
.
.
.
a_keys
]
.
every
(
k
=
>
b_keys
.
has
(
k
)
)
keys
differ
:
{
a_keys
}
!
=
{
b_keys
}
)
;
}
function
convertValue
(
value
optParent
)
{
switch
(
typeof
value
)
{
case
'
undefined
'
:
case
'
boolean
'
:
case
'
number
'
:
case
'
bigint
'
:
case
'
string
'
:
case
'
symbol
'
:
return
value
;
case
'
function
'
:
return
value
.
apply
(
optParent
)
;
case
'
object
'
:
if
(
value
=
=
=
null
)
{
return
value
;
}
if
(
value
.
__proto__
.
constructor
=
=
=
Object
)
{
var
result
=
{
}
;
Object
.
entries
(
value
)
.
map
(
(
k
v
)
=
>
{
result
[
k
]
=
convertValue
(
k
v
)
;
}
)
;
return
result
;
}
if
(
value
instanceof
Array
)
{
return
value
.
map
(
convertValue
)
;
}
if
(
value
instanceof
ArrayBuffer
)
{
return
base64urlEncode
(
new
Uint8Array
(
value
)
)
;
}
throw
can
'
t
convert
value
{
value
}
in
{
parent
}
;
default
:
throw
{
value
}
has
unexpected
type
;
}
}
function
convertObject
(
obj
params
)
{
let
result
=
{
}
;
params
.
forEach
(
(
param
)
=
>
{
switch
(
typeof
(
param
)
)
{
case
'
string
'
:
assert_true
(
param
in
obj
missing
{
param
}
)
;
result
[
param
]
=
convertValue
(
obj
[
param
]
obj
)
;
break
;
case
'
object
'
:
assert_true
(
param
.
name
in
obj
missing
{
param
.
name
}
)
;
const
val
=
obj
[
param
.
name
]
;
const
target_key
=
param
.
target
|
|
param
.
name
;
const
convert_func
=
param
.
func
|
|
convertValue
;
try
{
result
[
target_key
]
=
convert_func
(
(
(
typeof
val
)
=
=
'
function
'
?
val
.
apply
(
obj
)
:
val
)
)
;
}
catch
(
e
)
{
throw
failed
to
convert
{
param
.
name
}
:
{
e
}
}
break
;
default
:
throw
invalid
key
{
param
}
;
}
}
)
;
return
result
;
}
function
authenticatorResponseToJson
(
response
)
{
assert_true
(
(
response
instanceof
AuthenticatorAttestationResponse
)
|
|
(
response
instanceof
AuthenticatorAssertionResponse
)
)
;
const
isAttestation
=
(
response
instanceof
AuthenticatorAttestationResponse
)
;
const
keys
=
(
isAttestation
?
[
'
clientDataJSON
'
'
attestationObject
'
{
name
:
'
getTransports
'
target
:
'
transports
'
}
]
:
[
'
clientDataJSON
'
'
authenticatorData
'
'
signature
'
'
userHandle
'
]
)
;
return
convertObject
(
response
keys
)
;
}
function
publicKeyCredentialToJson
(
cred
)
{
const
keys
=
[
'
id
'
'
rawId
'
{
name
:
'
response
'
func
:
authenticatorResponseToJson
}
'
authenticatorAttachment
'
{
name
:
'
getClientExtensionResults
'
target
:
'
clientExtensionResults
'
}
'
type
'
]
;
return
convertObject
(
cred
keys
)
;
}
function
deepSortKeys
(
jsonObj
)
{
if
(
typeof
jsonObj
!
=
=
'
object
'
|
|
jsonObj
=
=
=
null
|
|
jsonObj
.
__proto__
.
constructor
!
=
=
Object
|
|
Object
.
keys
(
jsonObj
)
.
length
=
=
=
0
)
{
return
jsonObj
;
}
return
Object
.
keys
(
jsonObj
)
.
sort
(
)
.
reduce
(
(
acc
key
)
=
>
{
acc
[
key
]
=
deepSortKeys
(
jsonObj
[
key
]
)
;
return
acc
;
}
{
}
)
;
}
function
assertJsonEquals
(
actual
expected
optMsg
)
{
assert_equals
(
JSON
.
stringify
(
deepSortKeys
(
actual
)
)
JSON
.
stringify
(
deepSortKeys
(
expected
)
)
optMsg
)
;
}
virtualAuthenticatorPromiseTest
(
async
t
=
>
{
let
credential
=
await
createCredential
(
)
;
assertJsonEquals
(
credential
.
toJSON
(
)
publicKeyCredentialToJson
(
credential
)
)
;
let
assertion
=
await
assertCredential
(
credential
)
;
assertJsonEquals
(
assertion
.
toJSON
(
)
publicKeyCredentialToJson
(
assertion
)
)
;
}
{
protocol
:
'
ctap2_1
'
transport
:
'
usb
'
}
'
toJSON
(
)
'
)
;
