const
cose_kty
=
1
;
const
cose_kty_ec2
=
2
;
const
cose_alg
=
3
;
const
cose_alg_ECDSA_w_SHA256
=
-
7
;
const
cose_alg_ECDSA_w_SHA512
=
-
36
;
const
cose_crv
=
-
1
;
const
cose_crv_P256
=
1
;
const
cose_crv_x
=
-
2
;
const
cose_crv_y
=
-
3
;
var
createCredentialDefaultArgs
=
{
options
:
{
publicKey
:
{
rp
:
{
name
:
"
Acme
"
icon
:
"
https
:
/
/
www
.
w3
.
org
/
StyleSheets
/
TR
/
2016
/
logos
/
W3C
"
}
user
:
{
id
:
new
Uint8Array
(
16
)
name
:
"
john
.
p
.
smith
example
.
com
"
displayName
:
"
John
P
.
Smith
"
icon
:
"
https
:
/
/
pics
.
acme
.
com
/
00
/
p
/
aBjjjpqPb
.
png
"
}
pubKeyCredParams
:
[
{
type
:
"
public
-
key
"
alg
:
cose_alg_ECDSA_w_SHA256
}
]
timeout
:
60000
excludeCredentials
:
[
]
}
}
}
;
var
getCredentialDefaultArgs
=
{
options
:
{
publicKey
:
{
timeout
:
60000
}
}
}
;
function
createCredential
(
opts
)
{
opts
=
opts
|
|
{
}
;
var
createArgs
=
cloneObject
(
createCredentialDefaultArgs
)
;
let
challengeBytes
=
new
Uint8Array
(
16
)
;
window
.
crypto
.
getRandomValues
(
challengeBytes
)
;
createArgs
.
options
.
publicKey
.
challenge
=
challengeBytes
;
createArgs
.
options
.
publicKey
.
user
.
id
=
new
Uint8Array
(
16
)
;
extendObject
(
createArgs
opts
)
;
return
navigator
.
credentials
.
create
(
createArgs
.
options
)
;
}
function
createRandomString
(
len
)
{
var
text
=
"
"
;
var
possible
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
"
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
text
+
=
possible
.
charAt
(
Math
.
floor
(
Math
.
random
(
)
*
possible
.
length
)
)
;
}
return
text
;
}
function
ab2str
(
buf
)
{
return
String
.
fromCharCode
.
apply
(
null
new
Uint8Array
(
buf
)
)
;
}
const
authenticator_data_user_present
=
0x01
;
const
authenticator_data_user_verified
=
0x04
;
const
authenticator_data_attested_cred_data
=
0x40
;
const
authenticator_data_extension_data
=
0x80
;
function
parseAuthenticatorData
(
buf
)
{
if
(
buf
.
byteLength
<
37
)
{
throw
new
TypeError
(
"
parseAuthenticatorData
:
buffer
must
be
at
least
37
bytes
"
)
;
}
printHex
(
"
authnrData
"
buf
)
;
var
authnrData
=
new
DataView
(
buf
)
;
var
authnrDataObj
=
{
}
;
authnrDataObj
.
length
=
buf
.
byteLength
;
authnrDataObj
.
rpIdHash
=
new
Uint8Array
(
buf
.
slice
(
0
32
)
)
;
authnrDataObj
.
rawFlags
=
authnrData
.
getUint8
(
32
)
;
authnrDataObj
.
counter
=
authnrData
.
getUint32
(
33
false
)
;
authnrDataObj
.
rawCounter
=
[
]
;
authnrDataObj
.
rawCounter
[
0
]
=
authnrData
.
getUint8
(
33
)
;
authnrDataObj
.
rawCounter
[
1
]
=
authnrData
.
getUint8
(
34
)
;
authnrDataObj
.
rawCounter
[
2
]
=
authnrData
.
getUint8
(
35
)
;
authnrDataObj
.
rawCounter
[
3
]
=
authnrData
.
getUint8
(
36
)
;
authnrDataObj
.
flags
=
{
}
;
authnrDataObj
.
flags
.
userPresent
=
(
authnrDataObj
.
rawFlags
&
authenticator_data_user_present
)
?
true
:
false
;
authnrDataObj
.
flags
.
userVerified
=
(
authnrDataObj
.
rawFlags
&
authenticator_data_user_verified
)
?
true
:
false
;
authnrDataObj
.
flags
.
attestedCredentialData
=
(
authnrDataObj
.
rawFlags
&
authenticator_data_attested_cred_data
)
?
true
:
false
;
authnrDataObj
.
flags
.
extensionData
=
(
authnrDataObj
.
rawFlags
&
authenticator_data_extension_data
)
?
true
:
false
;
return
authnrDataObj
;
}
class
TestCase
{
constructor
(
)
{
this
.
testFunction
=
function
(
)
{
throw
new
Error
(
"
Test
Function
not
implemented
"
)
;
}
;
this
.
testObject
=
{
}
;
this
.
argOrder
=
[
]
;
this
.
ctx
=
null
;
}
toObject
(
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
this
.
testObject
)
)
;
}
toArgs
(
)
{
var
ret
=
[
]
;
for
(
let
idx
of
this
.
argOrder
)
{
ret
.
push
(
this
.
testObject
[
idx
]
)
;
}
return
ret
;
}
modify
(
arg1
arg2
)
{
var
mods
;
if
(
typeof
arg1
=
=
=
"
string
"
&
&
arg2
!
=
=
undefined
)
{
mods
=
{
path
:
arg1
value
:
arg2
}
;
}
else
{
mods
=
arg1
;
}
if
(
!
Array
.
isArray
(
mods
)
&
&
typeof
mods
=
=
=
"
object
"
)
{
mods
=
[
mods
]
;
}
for
(
let
idx
in
mods
)
{
var
mod
=
mods
[
idx
]
;
let
paths
=
mod
.
path
.
split
(
"
.
"
)
;
recursiveSetObject
(
this
.
testObject
paths
mod
.
value
)
;
}
function
recursiveSetObject
(
obj
pathArray
value
)
{
var
currPath
=
pathArray
.
shift
(
)
;
if
(
typeof
obj
[
currPath
]
!
=
=
"
object
"
)
{
obj
[
currPath
]
=
{
}
;
}
if
(
pathArray
.
length
>
0
)
{
return
recursiveSetObject
(
obj
[
currPath
]
pathArray
value
)
;
}
obj
[
currPath
]
=
value
;
}
return
this
;
}
doIt
(
)
{
if
(
typeof
this
.
testFunction
!
=
=
"
function
"
)
{
throw
new
Error
(
"
Test
function
not
found
"
)
;
}
return
this
.
testFunction
.
call
(
this
.
ctx
.
.
.
this
.
toArgs
(
)
)
;
}
testPasses
(
desc
)
{
return
this
.
doIt
(
)
.
then
(
(
ret
)
=
>
{
this
.
validateRet
(
ret
)
;
return
ret
;
}
)
;
}
testFails
(
t
testDesc
expectedErr
)
{
if
(
typeof
expectedErr
=
=
"
string
"
)
{
return
promise_rejects_dom
(
t
expectedErr
this
.
doIt
(
)
"
Expected
bad
parameters
to
fail
"
)
;
}
return
promise_rejects_js
(
t
expectedErr
this
.
doIt
(
)
"
Expected
bad
parameters
to
fail
"
)
;
}
runTest
(
desc
expectedErr
)
{
promise_test
(
(
t
)
=
>
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
return
this
.
testSetup
(
)
;
}
)
.
then
(
(
)
=
>
{
if
(
expectedErr
=
=
=
undefined
)
{
return
this
.
testPasses
(
desc
)
;
}
else
{
return
this
.
testFails
(
t
desc
expectedErr
)
;
}
}
)
.
then
(
(
res
)
=
>
{
return
this
.
testTeardown
(
res
)
;
}
)
}
desc
)
}
testSetup
(
)
{
if
(
this
.
beforeTestFn
)
{
this
.
beforeTestFn
.
call
(
this
)
;
}
return
Promise
.
resolve
(
)
;
}
beforeTest
(
fn
)
{
if
(
typeof
fn
!
=
=
"
function
"
)
{
throw
new
Error
(
"
Tried
to
call
non
-
function
before
test
"
)
;
}
this
.
beforeTestFn
=
fn
;
return
this
;
}
testTeardown
(
res
)
{
if
(
this
.
afterTestFn
)
{
this
.
afterTestFn
.
call
(
this
res
)
;
}
return
Promise
.
resolve
(
)
;
}
afterTest
(
fn
)
{
if
(
typeof
fn
!
=
=
"
function
"
)
{
throw
new
Error
(
"
Tried
to
call
non
-
function
after
test
"
)
;
}
this
.
afterTestFn
=
fn
;
return
this
;
}
validateRet
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
function
cloneObject
(
o
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
o
)
)
;
}
function
extendObject
(
dst
src
)
{
Object
.
keys
(
src
)
.
forEach
(
function
(
key
)
{
if
(
isSimpleObject
(
src
[
key
]
)
)
{
extendObject
(
dst
[
key
]
src
[
key
]
)
;
}
else
{
dst
[
key
]
=
src
[
key
]
;
}
}
)
;
}
function
isSimpleObject
(
o
)
{
return
(
typeof
o
=
=
=
"
object
"
&
&
!
Array
.
isArray
(
o
)
&
&
!
(
o
instanceof
ArrayBuffer
)
)
;
}
class
CreateCredentialsTest
extends
TestCase
{
constructor
(
)
{
super
(
)
;
this
.
testFunction
=
navigator
.
credentials
.
create
;
this
.
ctx
=
navigator
.
credentials
;
let
challengeBytes
=
new
Uint8Array
(
16
)
;
window
.
crypto
.
getRandomValues
(
challengeBytes
)
;
this
.
testObject
=
cloneObject
(
createCredentialDefaultArgs
)
;
this
.
testObject
.
options
.
publicKey
.
user
.
id
=
new
Uint8Array
(
16
)
;
this
.
testObject
.
options
.
publicKey
.
challenge
=
challengeBytes
;
this
.
argOrder
=
[
"
options
"
]
;
if
(
arguments
.
length
)
this
.
modify
(
.
.
.
arguments
)
;
}
validateRet
(
ret
)
{
validatePublicKeyCredential
(
ret
)
;
validateAuthenticatorAttestationResponse
(
ret
.
response
)
;
}
}
class
GetCredentialsTest
extends
TestCase
{
constructor
(
.
.
.
args
)
{
super
(
)
;
this
.
testFunction
=
navigator
.
credentials
.
get
;
this
.
ctx
=
navigator
.
credentials
;
let
challengeBytes
=
new
Uint8Array
(
16
)
;
window
.
crypto
.
getRandomValues
(
challengeBytes
)
;
this
.
testObject
=
cloneObject
(
getCredentialDefaultArgs
)
;
this
.
testObject
.
options
.
publicKey
.
challenge
=
challengeBytes
;
this
.
argOrder
=
[
"
options
"
]
;
this
.
credentialPromiseList
=
[
]
;
if
(
arguments
.
length
)
{
if
(
args
.
cred
instanceof
Promise
)
this
.
credPromise
=
args
.
cred
;
else
if
(
typeof
args
.
cred
=
=
=
"
object
"
)
this
.
credPromise
=
Promise
.
resolve
(
args
.
cred
)
;
delete
args
.
cred
;
this
.
modify
(
.
.
.
arguments
)
;
}
}
addCredential
(
arg
)
{
if
(
arg
instanceof
Promise
)
{
this
.
credentialPromiseList
.
push
(
arg
)
;
return
this
;
}
if
(
typeof
arg
=
=
=
"
object
"
)
{
this
.
credentialPromiseList
.
push
(
Promise
.
resolve
(
arg
)
)
;
return
this
;
}
var
p
=
createCredential
(
)
;
this
.
credentialPromiseList
.
push
(
p
)
;
return
this
;
}
testSetup
(
desc
)
{
if
(
!
this
.
credentialPromiseList
.
length
)
{
throw
new
Error
(
"
Attempting
list
without
defining
credential
to
test
"
)
;
}
return
Promise
.
all
(
this
.
credentialPromiseList
)
.
then
(
(
credList
)
=
>
{
var
idList
=
credList
.
map
(
(
cred
)
=
>
{
return
{
id
:
cred
.
rawId
transports
:
[
"
usb
"
"
nfc
"
"
ble
"
]
type
:
"
public
-
key
"
}
;
}
)
;
this
.
testObject
.
options
.
publicKey
.
allowCredentials
=
idList
;
}
)
.
catch
(
(
err
)
=
>
{
throw
Error
(
err
)
;
}
)
;
}
validateRet
(
ret
)
{
validatePublicKeyCredential
(
ret
)
;
validateAuthenticatorAssertionResponse
(
ret
.
response
)
;
}
}
function
validatePublicKeyCredential
(
cred
)
{
assert_class_string
(
cred
"
PublicKeyCredential
"
"
Expected
return
to
be
instance
of
'
PublicKeyCredential
'
class
"
)
;
assert_idl_attribute
(
cred
"
id
"
"
should
return
PublicKeyCredential
with
id
attribute
"
)
;
assert_readonly
(
cred
"
id
"
"
should
return
PublicKeyCredential
with
readonly
id
attribute
"
)
;
assert_idl_attribute
(
cred
"
rawId
"
"
should
return
PublicKeyCredential
with
rawId
attribute
"
)
;
assert_readonly
(
cred
"
rawId
"
"
should
return
PublicKeyCredential
with
readonly
rawId
attribute
"
)
;
assert_idl_attribute
(
cred
"
type
"
"
should
return
PublicKeyCredential
with
type
attribute
"
)
;
assert_equals
(
cred
.
type
"
public
-
key
"
"
should
return
PublicKeyCredential
with
type
'
public
-
key
'
"
)
;
}
function
validateAuthenticatorAttestationResponse
(
attr
)
{
assert_class_string
(
attr
"
AuthenticatorAttestationResponse
"
"
Expected
credentials
.
create
(
)
to
return
instance
of
'
AuthenticatorAttestationResponse
'
class
"
)
;
assert_idl_attribute
(
attr
"
clientDataJSON
"
"
credentials
.
create
(
)
should
return
AuthenticatorAttestationResponse
with
clientDataJSON
attribute
"
)
;
assert_readonly
(
attr
"
clientDataJSON
"
"
credentials
.
create
(
)
should
return
AuthenticatorAttestationResponse
with
readonly
clientDataJSON
attribute
"
)
;
assert_idl_attribute
(
attr
"
attestationObject
"
"
credentials
.
create
(
)
should
return
AuthenticatorAttestationResponse
with
attestationObject
attribute
"
)
;
assert_readonly
(
attr
"
attestationObject
"
"
credentials
.
create
(
)
should
return
AuthenticatorAttestationResponse
with
readonly
attestationObject
attribute
"
)
;
}
function
validateAuthenticatorAssertionResponse
(
assert
)
{
assert_class_string
(
assert
"
AuthenticatorAssertionResponse
"
"
Expected
credentials
.
create
(
)
to
return
instance
of
'
AuthenticatorAssertionResponse
'
class
"
)
;
assert_idl_attribute
(
assert
"
clientDataJSON
"
"
credentials
.
get
(
)
should
return
AuthenticatorAssertionResponse
with
clientDataJSON
attribute
"
)
;
assert_readonly
(
assert
"
clientDataJSON
"
"
credentials
.
get
(
)
should
return
AuthenticatorAssertionResponse
with
readonly
clientDataJSON
attribute
"
)
;
assert_idl_attribute
(
assert
"
signature
"
"
credentials
.
get
(
)
should
return
AuthenticatorAssertionResponse
with
signature
attribute
"
)
;
assert_readonly
(
assert
"
signature
"
"
credentials
.
get
(
)
should
return
AuthenticatorAssertionResponse
with
readonly
signature
attribute
"
)
;
assert_idl_attribute
(
assert
"
authenticatorData
"
"
credentials
.
get
(
)
should
return
AuthenticatorAssertionResponse
with
authenticatorData
attribute
"
)
;
assert_readonly
(
assert
"
authenticatorData
"
"
credentials
.
get
(
)
should
return
AuthenticatorAssertionResponse
with
readonly
authenticatorData
attribute
"
)
;
}
function
standardSetup
(
cb
)
{
window
.
test_driver
.
add_virtual_authenticator
(
{
protocol
:
"
ctap1
/
u2f
"
transport
:
"
usb
"
}
)
.
then
(
cb
)
.
catch
(
error
=
>
{
if
(
error
=
=
=
"
error
:
Action
add_virtual_authenticator
not
implemented
"
)
{
cb
(
)
;
return
;
}
throw
error
;
}
)
;
}
