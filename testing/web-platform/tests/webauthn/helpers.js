const
cose_kty
=
1
;
const
cose_kty_ec2
=
2
;
const
cose_alg
=
3
;
const
cose_alg_ECDSA_w_SHA256
=
-
7
;
const
cose_alg_ECDSA_w_SHA512
=
-
36
;
const
cose_crv
=
-
1
;
const
cose_crv_P256
=
1
;
const
cose_crv_x
=
-
2
;
const
cose_crv_y
=
-
3
;
var
createCredentialDefaultArgs
=
{
options
:
{
publicKey
:
{
rp
:
{
name
:
"
Acme
"
}
user
:
{
id
:
new
Uint8Array
(
16
)
name
:
"
john
.
p
.
smith
example
.
com
"
displayName
:
"
John
P
.
Smith
"
}
pubKeyCredParams
:
[
{
type
:
"
public
-
key
"
alg
:
cose_alg_ECDSA_w_SHA256
}
]
authenticatorSelection
:
{
requireResidentKey
:
false
}
timeout
:
60000
excludeCredentials
:
[
]
}
}
}
;
var
getCredentialDefaultArgs
=
{
options
:
{
publicKey
:
{
timeout
:
60000
}
}
}
;
function
createCredential
(
opts
)
{
opts
=
opts
|
|
{
}
;
var
createArgs
=
cloneObject
(
createCredentialDefaultArgs
)
;
let
challengeBytes
=
new
Uint8Array
(
16
)
;
window
.
crypto
.
getRandomValues
(
challengeBytes
)
;
createArgs
.
options
.
publicKey
.
challenge
=
challengeBytes
;
createArgs
.
options
.
publicKey
.
user
.
id
=
new
Uint8Array
(
16
)
;
extendObject
(
createArgs
opts
)
;
return
navigator
.
credentials
.
create
(
createArgs
.
options
)
;
}
function
assertCredential
(
credential
)
{
var
options
=
cloneObject
(
getCredentialDefaultArgs
)
;
let
challengeBytes
=
new
Uint8Array
(
16
)
;
window
.
crypto
.
getRandomValues
(
challengeBytes
)
;
options
.
challenge
=
challengeBytes
;
options
.
allowCredentials
=
[
{
type
:
'
public
-
key
'
id
:
credential
.
rawId
}
]
;
return
navigator
.
credentials
.
get
(
{
publicKey
:
options
}
)
;
}
function
createRandomString
(
len
)
{
var
text
=
"
"
;
var
possible
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
"
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
text
+
=
possible
.
charAt
(
Math
.
floor
(
Math
.
random
(
)
*
possible
.
length
)
)
;
}
return
text
;
}
function
ab2str
(
buf
)
{
return
String
.
fromCharCode
.
apply
(
null
new
Uint8Array
(
buf
)
)
;
}
const
authenticator_data_user_present
=
0x01
;
const
authenticator_data_user_verified
=
0x04
;
const
authenticator_data_attested_cred_data
=
0x40
;
const
authenticator_data_extension_data
=
0x80
;
function
parseAuthenticatorData
(
buf
)
{
if
(
buf
.
byteLength
<
37
)
{
throw
new
TypeError
(
"
parseAuthenticatorData
:
buffer
must
be
at
least
37
bytes
"
)
;
}
printHex
(
"
authnrData
"
buf
)
;
var
authnrData
=
new
DataView
(
buf
)
;
var
authnrDataObj
=
{
}
;
authnrDataObj
.
length
=
buf
.
byteLength
;
authnrDataObj
.
rpIdHash
=
new
Uint8Array
(
buf
.
slice
(
0
32
)
)
;
authnrDataObj
.
rawFlags
=
authnrData
.
getUint8
(
32
)
;
authnrDataObj
.
counter
=
authnrData
.
getUint32
(
33
false
)
;
authnrDataObj
.
rawCounter
=
[
]
;
authnrDataObj
.
rawCounter
[
0
]
=
authnrData
.
getUint8
(
33
)
;
authnrDataObj
.
rawCounter
[
1
]
=
authnrData
.
getUint8
(
34
)
;
authnrDataObj
.
rawCounter
[
2
]
=
authnrData
.
getUint8
(
35
)
;
authnrDataObj
.
rawCounter
[
3
]
=
authnrData
.
getUint8
(
36
)
;
authnrDataObj
.
flags
=
{
}
;
authnrDataObj
.
flags
.
userPresent
=
(
authnrDataObj
.
rawFlags
&
authenticator_data_user_present
)
?
true
:
false
;
authnrDataObj
.
flags
.
userVerified
=
(
authnrDataObj
.
rawFlags
&
authenticator_data_user_verified
)
?
true
:
false
;
authnrDataObj
.
flags
.
attestedCredentialData
=
(
authnrDataObj
.
rawFlags
&
authenticator_data_attested_cred_data
)
?
true
:
false
;
authnrDataObj
.
flags
.
extensionData
=
(
authnrDataObj
.
rawFlags
&
authenticator_data_extension_data
)
?
true
:
false
;
return
authnrDataObj
;
}
class
TestCase
{
constructor
(
)
{
this
.
testFunction
=
function
(
)
{
throw
new
Error
(
"
Test
Function
not
implemented
"
)
;
}
;
this
.
testObject
=
{
}
;
this
.
argOrder
=
[
]
;
this
.
ctx
=
null
;
}
toObject
(
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
this
.
testObject
)
)
;
}
toArgs
(
)
{
var
ret
=
[
]
;
for
(
let
idx
of
this
.
argOrder
)
{
ret
.
push
(
this
.
testObject
[
idx
]
)
;
}
return
ret
;
}
modify
(
arg1
arg2
)
{
var
mods
;
if
(
typeof
arg1
=
=
=
"
string
"
&
&
arg2
!
=
=
undefined
)
{
mods
=
{
path
:
arg1
value
:
arg2
}
;
}
else
{
mods
=
arg1
;
}
if
(
!
Array
.
isArray
(
mods
)
&
&
typeof
mods
=
=
=
"
object
"
)
{
mods
=
[
mods
]
;
}
for
(
let
idx
in
mods
)
{
var
mod
=
mods
[
idx
]
;
let
paths
=
mod
.
path
.
split
(
"
.
"
)
;
recursiveSetObject
(
this
.
testObject
paths
mod
.
value
)
;
}
function
recursiveSetObject
(
obj
pathArray
value
)
{
var
currPath
=
pathArray
.
shift
(
)
;
if
(
typeof
obj
[
currPath
]
!
=
=
"
object
"
)
{
obj
[
currPath
]
=
{
}
;
}
if
(
pathArray
.
length
>
0
)
{
return
recursiveSetObject
(
obj
[
currPath
]
pathArray
value
)
;
}
obj
[
currPath
]
=
value
;
}
return
this
;
}
doIt
(
)
{
if
(
typeof
this
.
testFunction
!
=
=
"
function
"
)
{
throw
new
Error
(
"
Test
function
not
found
"
)
;
}
return
this
.
testFunction
.
call
(
this
.
ctx
.
.
.
this
.
toArgs
(
)
)
;
}
testPasses
(
desc
)
{
return
this
.
doIt
(
)
.
then
(
(
ret
)
=
>
{
this
.
validateRet
(
ret
)
;
return
ret
;
}
)
;
}
testFails
(
t
testDesc
expectedErr
)
{
if
(
typeof
expectedErr
=
=
"
string
"
)
{
return
promise_rejects_dom
(
t
expectedErr
this
.
doIt
(
)
"
Expected
bad
parameters
to
fail
"
)
;
}
return
promise_rejects_js
(
t
expectedErr
this
.
doIt
(
)
"
Expected
bad
parameters
to
fail
"
)
;
}
runTest
(
desc
expectedErr
)
{
promise_test
(
(
t
)
=
>
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
return
this
.
testSetup
(
)
;
}
)
.
then
(
(
)
=
>
{
if
(
expectedErr
=
=
=
undefined
)
{
return
this
.
testPasses
(
desc
)
;
}
else
{
return
this
.
testFails
(
t
desc
expectedErr
)
;
}
}
)
.
then
(
(
res
)
=
>
{
return
this
.
testTeardown
(
res
)
;
}
)
}
desc
)
}
testSetup
(
)
{
if
(
this
.
beforeTestFn
)
{
this
.
beforeTestFn
.
call
(
this
)
;
}
return
Promise
.
resolve
(
)
;
}
beforeTest
(
fn
)
{
if
(
typeof
fn
!
=
=
"
function
"
)
{
throw
new
Error
(
"
Tried
to
call
non
-
function
before
test
"
)
;
}
this
.
beforeTestFn
=
fn
;
return
this
;
}
testTeardown
(
res
)
{
if
(
this
.
afterTestFn
)
{
this
.
afterTestFn
.
call
(
this
res
)
;
}
return
Promise
.
resolve
(
)
;
}
afterTest
(
fn
)
{
if
(
typeof
fn
!
=
=
"
function
"
)
{
throw
new
Error
(
"
Tried
to
call
non
-
function
after
test
"
)
;
}
this
.
afterTestFn
=
fn
;
return
this
;
}
validateRet
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
function
cloneObject
(
o
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
o
)
)
;
}
function
extendObject
(
dst
src
)
{
Object
.
keys
(
src
)
.
forEach
(
function
(
key
)
{
if
(
isSimpleObject
(
src
[
key
]
)
&
&
!
isAbortSignal
(
src
[
key
]
)
)
{
dst
[
key
]
|
|
=
{
}
;
extendObject
(
dst
[
key
]
src
[
key
]
)
;
}
else
{
dst
[
key
]
=
src
[
key
]
;
}
}
)
;
}
function
isSimpleObject
(
o
)
{
return
(
typeof
o
=
=
=
"
object
"
&
&
!
Array
.
isArray
(
o
)
&
&
!
(
o
instanceof
ArrayBuffer
)
&
&
!
(
o
instanceof
Uint8Array
)
)
;
}
function
isAbortSignal
(
o
)
{
return
(
o
instanceof
AbortSignal
)
;
}
class
CreateCredentialsTest
extends
TestCase
{
constructor
(
)
{
super
(
)
;
this
.
testFunction
=
navigator
.
credentials
.
create
;
this
.
ctx
=
navigator
.
credentials
;
let
challengeBytes
=
new
Uint8Array
(
16
)
;
window
.
crypto
.
getRandomValues
(
challengeBytes
)
;
this
.
testObject
=
cloneObject
(
createCredentialDefaultArgs
)
;
this
.
testObject
.
options
.
publicKey
.
user
.
id
=
new
Uint8Array
(
16
)
;
this
.
testObject
.
options
.
publicKey
.
challenge
=
challengeBytes
;
this
.
argOrder
=
[
"
options
"
]
;
if
(
arguments
.
length
)
this
.
modify
(
.
.
.
arguments
)
;
}
validateRet
(
ret
)
{
validatePublicKeyCredential
(
ret
)
;
validateAuthenticatorAttestationResponse
(
ret
.
response
)
;
}
}
class
GetCredentialsTest
extends
TestCase
{
constructor
(
.
.
.
args
)
{
super
(
)
;
this
.
testFunction
=
navigator
.
credentials
.
get
;
this
.
ctx
=
navigator
.
credentials
;
let
challengeBytes
=
new
Uint8Array
(
16
)
;
window
.
crypto
.
getRandomValues
(
challengeBytes
)
;
this
.
testObject
=
cloneObject
(
getCredentialDefaultArgs
)
;
this
.
testObject
.
options
.
publicKey
.
challenge
=
challengeBytes
;
this
.
argOrder
=
[
"
options
"
]
;
this
.
credentialPromiseList
=
[
]
;
this
.
isResidentKeyTest
=
false
;
if
(
arguments
.
length
)
{
if
(
args
.
cred
instanceof
Promise
)
this
.
credPromise
=
args
.
cred
;
else
if
(
typeof
args
.
cred
=
=
=
"
object
"
)
this
.
credPromise
=
Promise
.
resolve
(
args
.
cred
)
;
delete
args
.
cred
;
this
.
modify
(
.
.
.
arguments
)
;
}
}
addCredential
(
arg
)
{
if
(
arg
instanceof
Promise
)
{
this
.
credentialPromiseList
.
push
(
arg
)
;
return
this
;
}
if
(
typeof
arg
=
=
=
"
object
"
)
{
this
.
credentialPromiseList
.
push
(
Promise
.
resolve
(
arg
)
)
;
return
this
;
}
var
p
=
createCredential
(
)
;
this
.
credentialPromiseList
.
push
(
p
)
;
return
this
;
}
testSetup
(
desc
)
{
if
(
!
this
.
credentialPromiseList
.
length
)
{
throw
new
Error
(
"
Attempting
list
without
defining
credential
to
test
"
)
;
}
return
Promise
.
all
(
this
.
credentialPromiseList
)
.
then
(
(
credList
)
=
>
{
var
idList
=
credList
.
map
(
(
cred
)
=
>
{
return
{
id
:
cred
.
rawId
transports
:
[
"
usb
"
"
nfc
"
"
ble
"
]
type
:
"
public
-
key
"
}
;
}
)
;
if
(
!
this
.
isResidentKeyTest
)
{
this
.
testObject
.
options
.
publicKey
.
allowCredentials
=
idList
;
}
}
)
.
catch
(
(
err
)
=
>
{
throw
Error
(
err
)
;
}
)
;
}
validateRet
(
ret
)
{
validatePublicKeyCredential
(
ret
)
;
validateAuthenticatorAssertionResponse
(
ret
.
response
)
;
}
setIsResidentKeyTest
(
isResidentKeyTest
)
{
this
.
isResidentKeyTest
=
isResidentKeyTest
;
return
this
;
}
}
function
base64urlEncode
(
array
)
{
let
string
=
String
.
fromCharCode
.
apply
(
null
array
)
;
let
result
=
btoa
(
string
)
;
return
result
.
replace
(
/
=
+
/
g
'
'
)
.
replace
(
/
\
+
/
g
"
-
"
)
.
replace
(
/
\
/
/
g
"
_
"
)
;
}
function
validatePublicKeyCredential
(
cred
)
{
assert_class_string
(
cred
"
PublicKeyCredential
"
"
Expected
return
to
be
instance
of
'
PublicKeyCredential
'
class
"
)
;
assert_idl_attribute
(
cred
"
id
"
"
should
return
PublicKeyCredential
with
id
attribute
"
)
;
assert_readonly
(
cred
"
id
"
"
should
return
PublicKeyCredential
with
readonly
id
attribute
"
)
;
assert_idl_attribute
(
cred
"
rawId
"
"
should
return
PublicKeyCredential
with
rawId
attribute
"
)
;
assert_readonly
(
cred
"
rawId
"
"
should
return
PublicKeyCredential
with
readonly
rawId
attribute
"
)
;
assert_equals
(
cred
.
id
base64urlEncode
(
new
Uint8Array
(
cred
.
rawId
)
)
"
should
return
PublicKeyCredential
with
id
attribute
set
to
base64
encoding
of
rawId
attribute
"
)
;
assert_idl_attribute
(
cred
"
type
"
"
should
return
PublicKeyCredential
with
type
attribute
"
)
;
assert_equals
(
cred
.
type
"
public
-
key
"
"
should
return
PublicKeyCredential
with
type
'
public
-
key
'
"
)
;
}
function
validateAuthenticatorAttestationResponse
(
attr
)
{
assert_class_string
(
attr
"
AuthenticatorAttestationResponse
"
"
Expected
credentials
.
create
(
)
to
return
instance
of
'
AuthenticatorAttestationResponse
'
class
"
)
;
assert_idl_attribute
(
attr
"
clientDataJSON
"
"
credentials
.
create
(
)
should
return
AuthenticatorAttestationResponse
with
clientDataJSON
attribute
"
)
;
assert_readonly
(
attr
"
clientDataJSON
"
"
credentials
.
create
(
)
should
return
AuthenticatorAttestationResponse
with
readonly
clientDataJSON
attribute
"
)
;
assert_idl_attribute
(
attr
"
attestationObject
"
"
credentials
.
create
(
)
should
return
AuthenticatorAttestationResponse
with
attestationObject
attribute
"
)
;
assert_readonly
(
attr
"
attestationObject
"
"
credentials
.
create
(
)
should
return
AuthenticatorAttestationResponse
with
readonly
attestationObject
attribute
"
)
;
}
function
validateAuthenticatorAssertionResponse
(
assert
)
{
assert_class_string
(
assert
"
AuthenticatorAssertionResponse
"
"
Expected
credentials
.
create
(
)
to
return
instance
of
'
AuthenticatorAssertionResponse
'
class
"
)
;
assert_idl_attribute
(
assert
"
clientDataJSON
"
"
credentials
.
get
(
)
should
return
AuthenticatorAssertionResponse
with
clientDataJSON
attribute
"
)
;
assert_readonly
(
assert
"
clientDataJSON
"
"
credentials
.
get
(
)
should
return
AuthenticatorAssertionResponse
with
readonly
clientDataJSON
attribute
"
)
;
assert_idl_attribute
(
assert
"
signature
"
"
credentials
.
get
(
)
should
return
AuthenticatorAssertionResponse
with
signature
attribute
"
)
;
assert_readonly
(
assert
"
signature
"
"
credentials
.
get
(
)
should
return
AuthenticatorAssertionResponse
with
readonly
signature
attribute
"
)
;
assert_idl_attribute
(
assert
"
authenticatorData
"
"
credentials
.
get
(
)
should
return
AuthenticatorAssertionResponse
with
authenticatorData
attribute
"
)
;
assert_readonly
(
assert
"
authenticatorData
"
"
credentials
.
get
(
)
should
return
AuthenticatorAssertionResponse
with
readonly
authenticatorData
attribute
"
)
;
}
function
defaultAuthenticatorArgs
(
)
{
return
{
protocol
:
'
ctap1
/
u2f
'
transport
:
'
usb
'
hasResidentKey
:
false
hasUserVerification
:
false
isUserVerified
:
false
}
;
}
function
standardSetup
(
cb
options
=
{
}
)
{
let
authenticatorArgs
=
Object
.
assign
(
defaultAuthenticatorArgs
(
)
options
)
;
window
.
test_driver
.
add_virtual_authenticator
(
authenticatorArgs
)
.
then
(
authenticator
=
>
{
cb
(
)
;
promise_test
(
(
)
=
>
window
.
test_driver
.
remove_virtual_authenticator
(
authenticator
)
'
Clean
up
the
test
environment
'
)
;
}
)
.
catch
(
error
=
>
{
if
(
error
!
=
=
'
error
:
Action
add_virtual_authenticator
not
implemented
'
)
{
throw
error
;
}
cb
(
)
;
}
)
;
}
function
virtualAuthenticatorPromiseTest
(
testCb
options
=
{
}
name
=
'
Virtual
Authenticator
Test
'
)
{
let
authenticatorArgs
=
Object
.
assign
(
defaultAuthenticatorArgs
(
)
options
)
;
promise_test
(
async
t
=
>
{
let
authenticator
;
try
{
authenticator
=
await
window
.
test_driver
.
add_virtual_authenticator
(
authenticatorArgs
)
;
t
.
add_cleanup
(
(
)
=
>
window
.
test_driver
.
remove_virtual_authenticator
(
authenticator
)
)
;
}
catch
(
error
)
{
if
(
error
!
=
=
'
error
:
Action
add_virtual_authenticator
not
implemented
'
)
{
throw
error
;
}
}
return
testCb
(
t
authenticator
)
;
}
name
)
;
}
function
bytesEqual
(
a
b
)
{
if
(
a
instanceof
ArrayBuffer
)
{
a
=
new
Uint8Array
(
a
)
;
}
if
(
b
instanceof
ArrayBuffer
)
{
b
=
new
Uint8Array
(
b
)
;
}
if
(
a
.
byteLength
!
=
b
.
byteLength
)
{
return
false
;
}
for
(
let
i
=
0
;
i
<
a
.
byteLength
;
i
+
+
)
{
if
(
a
[
i
]
!
=
b
[
i
]
)
{
return
false
;
}
}
return
true
;
}
function
userEntityEquals
(
a
b
)
{
return
bytesEqual
(
a
.
id
b
.
id
)
&
&
a
.
name
=
=
b
.
name
&
&
a
.
displayName
=
=
b
.
displayName
;
}
function
assertJsonEquals
(
actual
expected
optMsg
)
{
function
deepSortKeys
(
jsonObj
)
{
if
(
jsonObj
instanceof
Array
)
{
return
Array
.
from
(
jsonObj
(
x
)
=
>
{
return
deepSortKeys
(
x
)
;
}
)
}
if
(
typeof
jsonObj
!
=
=
'
object
'
|
|
jsonObj
=
=
=
null
|
|
jsonObj
.
__proto__
.
constructor
!
=
=
Object
|
|
Object
.
keys
(
jsonObj
)
.
length
=
=
=
0
)
{
return
jsonObj
;
}
return
Object
.
keys
(
jsonObj
)
.
sort
(
)
.
reduce
(
(
acc
key
)
=
>
{
acc
[
key
]
=
deepSortKeys
(
jsonObj
[
key
]
)
;
return
acc
;
}
{
}
)
;
}
assert_equals
(
JSON
.
stringify
(
deepSortKeys
(
actual
)
)
JSON
.
stringify
(
deepSortKeys
(
expected
)
)
optMsg
)
;
}
