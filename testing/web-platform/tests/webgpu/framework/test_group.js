function
_defineProperty
(
obj
key
value
)
{
if
(
key
in
obj
)
{
Object
.
defineProperty
(
obj
key
{
value
:
value
enumerable
:
true
configurable
:
true
writable
:
true
}
)
;
}
else
{
obj
[
key
]
=
value
;
}
return
obj
;
}
import
{
allowedTestNameCharacters
}
from
'
.
/
allowed_characters
.
js
'
;
import
{
extractPublicParams
paramsEquals
}
from
'
.
/
params
/
index
.
js
'
;
import
{
checkPublicParamType
}
from
'
.
/
url_query
.
js
'
;
import
{
assert
}
from
'
.
/
util
/
index
.
js
'
;
const
validNames
=
new
RegExp
(
'
^
[
'
+
allowedTestNameCharacters
+
'
]
+
'
)
;
export
class
TestGroup
{
constructor
(
fixture
)
{
_defineProperty
(
this
"
fixture
"
void
0
)
;
_defineProperty
(
this
"
seen
"
new
Set
(
)
)
;
_defineProperty
(
this
"
tests
"
[
]
)
;
this
.
fixture
=
fixture
;
}
*
iterate
(
log
)
{
for
(
const
test
of
this
.
tests
)
{
yield
*
test
.
iterate
(
log
)
;
}
}
checkName
(
name
)
{
assert
(
validNames
.
test
(
name
)
Invalid
test
name
{
name
}
;
must
match
[
{
validNames
}
]
+
)
;
assert
(
name
=
=
=
decodeURIComponent
(
name
)
Not
decodeURIComponent
-
idempotent
:
{
name
}
!
=
=
{
decodeURIComponent
(
name
)
}
)
;
assert
(
!
this
.
seen
.
has
(
name
)
Duplicate
test
name
:
{
name
}
)
;
this
.
seen
.
add
(
name
)
;
}
test
(
name
fn
)
{
assert
(
name
.
indexOf
(
'
_
'
)
=
=
=
-
1
'
Invalid
test
name
{
name
}
:
contains
underscore
(
use
space
)
'
)
;
name
=
name
.
replace
(
/
/
g
'
_
'
)
;
this
.
checkName
(
name
)
;
const
test
=
new
Test
(
name
this
.
fixture
fn
)
;
this
.
tests
.
push
(
test
)
;
return
test
;
}
}
class
Test
{
constructor
(
name
fixture
fn
)
{
_defineProperty
(
this
"
name
"
void
0
)
;
_defineProperty
(
this
"
fixture
"
void
0
)
;
_defineProperty
(
this
"
fn
"
void
0
)
;
_defineProperty
(
this
"
cases
"
null
)
;
this
.
name
=
name
;
this
.
fixture
=
fixture
;
this
.
fn
=
fn
;
}
params
(
specs
)
{
assert
(
this
.
cases
=
=
=
null
'
test
case
is
already
parameterized
'
)
;
const
cases
=
Array
.
from
(
specs
)
;
const
seen
=
[
]
;
for
(
const
spec
of
cases
)
{
const
publicParams
=
extractPublicParams
(
spec
)
;
for
(
const
v
of
Object
.
values
(
publicParams
)
)
{
checkPublicParamType
(
v
)
;
}
assert
(
!
seen
.
some
(
x
=
>
paramsEquals
(
x
publicParams
)
)
'
Duplicate
test
case
params
'
)
;
seen
.
push
(
publicParams
)
;
}
this
.
cases
=
cases
;
}
*
iterate
(
rec
)
{
for
(
const
params
of
this
.
cases
|
|
[
null
]
)
{
yield
new
RunCaseSpecific
(
rec
this
.
name
params
this
.
fixture
this
.
fn
)
;
}
}
}
class
RunCaseSpecific
{
constructor
(
recorder
test
params
fixture
fn
)
{
_defineProperty
(
this
"
id
"
void
0
)
;
_defineProperty
(
this
"
params
"
void
0
)
;
_defineProperty
(
this
"
recorder
"
void
0
)
;
_defineProperty
(
this
"
fixture
"
void
0
)
;
_defineProperty
(
this
"
fn
"
void
0
)
;
this
.
id
=
{
test
params
:
params
?
extractPublicParams
(
params
)
:
null
}
;
this
.
params
=
params
;
this
.
recorder
=
recorder
;
this
.
fixture
=
fixture
;
this
.
fn
=
fn
;
}
async
run
(
debug
)
{
const
[
rec
res
]
=
this
.
recorder
.
record
(
this
.
id
.
test
this
.
id
.
params
)
;
rec
.
start
(
debug
)
;
try
{
const
inst
=
new
this
.
fixture
(
rec
this
.
params
|
|
{
}
)
;
try
{
await
inst
.
init
(
)
;
await
this
.
fn
(
inst
)
;
}
finally
{
await
inst
.
finalize
(
)
;
}
}
catch
(
ex
)
{
rec
.
threw
(
ex
)
;
}
rec
.
finish
(
)
;
return
res
;
}
injectResult
(
result
)
{
const
[
res
]
=
this
.
recorder
.
record
(
this
.
id
.
test
this
.
id
.
params
)
;
Object
.
assign
(
res
result
)
;
}
}
