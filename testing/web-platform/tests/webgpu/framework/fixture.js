function
_defineProperty
(
obj
key
value
)
{
if
(
key
in
obj
)
{
Object
.
defineProperty
(
obj
key
{
value
:
value
enumerable
:
true
configurable
:
true
writable
:
true
}
)
;
}
else
{
obj
[
key
]
=
value
;
}
return
obj
;
}
export
class
Fixture
{
constructor
(
rec
params
)
{
_defineProperty
(
this
"
params
"
void
0
)
;
_defineProperty
(
this
"
rec
"
void
0
)
;
_defineProperty
(
this
"
numOutstandingAsyncExpectations
"
0
)
;
this
.
rec
=
rec
;
this
.
params
=
params
;
}
async
init
(
)
{
}
debug
(
msg
)
{
this
.
rec
.
debug
(
msg
)
;
}
log
(
msg
)
{
this
.
rec
.
log
(
msg
)
;
}
async
finalize
(
)
{
if
(
this
.
numOutstandingAsyncExpectations
!
=
=
0
)
{
throw
new
Error
(
'
there
were
outstanding
asynchronous
expectations
(
e
.
g
.
shouldReject
)
at
the
end
of
the
test
'
)
;
}
}
warn
(
msg
)
{
this
.
rec
.
warn
(
msg
)
;
}
fail
(
msg
)
{
this
.
rec
.
fail
(
msg
)
;
}
ok
(
msg
)
{
const
m
=
msg
?
'
:
'
+
msg
:
'
'
;
this
.
log
(
'
OK
'
+
m
)
;
}
async
asyncExpectation
(
fn
)
{
this
.
numOutstandingAsyncExpectations
+
+
;
const
ret
=
await
fn
(
)
;
this
.
numOutstandingAsyncExpectations
-
-
;
return
ret
;
}
expectErrorValue
(
expectedName
ex
m
)
{
if
(
!
(
ex
instanceof
Error
)
)
{
this
.
fail
(
'
THREW
NON
-
ERROR
'
)
;
return
;
}
const
actualName
=
ex
.
name
;
if
(
actualName
!
=
=
expectedName
)
{
this
.
fail
(
THREW
{
actualName
}
INSTEAD
OF
{
expectedName
}
{
m
}
)
;
}
else
{
this
.
ok
(
threw
{
actualName
}
{
m
}
)
;
}
}
async
shouldReject
(
expectedName
p
msg
)
{
this
.
asyncExpectation
(
async
(
)
=
>
{
const
m
=
msg
?
'
:
'
+
msg
:
'
'
;
try
{
await
p
;
this
.
fail
(
'
DID
NOT
THROW
'
+
m
)
;
}
catch
(
ex
)
{
this
.
expectErrorValue
(
expectedName
ex
m
)
;
}
}
)
;
}
shouldThrow
(
expectedName
fn
msg
)
{
const
m
=
msg
?
'
:
'
+
msg
:
'
'
;
try
{
fn
(
)
;
this
.
fail
(
'
DID
NOT
THROW
'
+
m
)
;
}
catch
(
ex
)
{
this
.
expectErrorValue
(
expectedName
ex
m
)
;
}
}
expect
(
cond
msg
)
{
if
(
cond
)
{
this
.
ok
(
msg
)
;
}
else
{
this
.
rec
.
fail
(
msg
)
;
}
return
cond
;
}
}
