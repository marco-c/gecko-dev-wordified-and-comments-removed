export
const
description
=
createBindGroupLayout
validation
tests
.
;
import
{
C
TestGroup
poptions
}
from
'
.
.
/
.
.
/
.
.
/
framework
/
index
.
js
'
;
import
{
kBindingTypeInfo
kBindingTypes
kMaxBindingsPerBindGroup
kPerStageBindingLimits
kShaderStages
}
from
'
.
.
/
capability_info
.
js
'
;
import
{
ValidationTest
}
from
'
.
/
validation_test
.
js
'
;
function
clone
(
descriptor
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
descriptor
)
)
;
}
export
const
g
=
new
TestGroup
(
ValidationTest
)
;
g
.
test
(
'
some
binding
index
was
specified
more
than
once
'
async
t
=
>
{
const
goodDescriptor
=
{
bindings
:
[
{
binding
:
0
visibility
:
GPUShaderStage
.
COMPUTE
type
:
C
.
BindingType
.
StorageBuffer
}
{
binding
:
1
visibility
:
GPUShaderStage
.
COMPUTE
type
:
C
.
BindingType
.
StorageBuffer
}
]
}
;
t
.
device
.
createBindGroupLayout
(
goodDescriptor
)
;
const
badDescriptor
=
clone
(
goodDescriptor
)
;
badDescriptor
.
bindings
[
1
]
.
binding
=
0
;
t
.
expectValidationError
(
(
)
=
>
{
t
.
device
.
createBindGroupLayout
(
badDescriptor
)
;
}
)
;
}
)
;
g
.
test
(
'
Visibility
of
bindings
can
be
0
'
async
t
=
>
{
t
.
device
.
createBindGroupLayout
(
{
bindings
:
[
{
binding
:
0
visibility
:
0
type
:
'
storage
-
buffer
'
}
]
}
)
;
}
)
;
g
.
test
(
'
number
of
dynamic
buffers
exceeds
the
maximum
value
'
async
t
=
>
{
const
{
type
maxDynamicBufferCount
}
=
t
.
params
;
const
maxDynamicBufferBindings
=
[
]
;
for
(
let
i
=
0
;
i
<
maxDynamicBufferCount
;
i
+
+
)
{
maxDynamicBufferBindings
.
push
(
{
binding
:
i
visibility
:
GPUShaderStage
.
COMPUTE
type
hasDynamicOffset
:
true
}
)
;
}
const
goodDescriptor
=
{
bindings
:
[
.
.
.
maxDynamicBufferBindings
{
binding
:
maxDynamicBufferBindings
.
length
visibility
:
GPUShaderStage
.
COMPUTE
type
hasDynamicOffset
:
false
}
]
}
;
t
.
device
.
createBindGroupLayout
(
goodDescriptor
)
;
const
badDescriptor
=
clone
(
goodDescriptor
)
;
badDescriptor
.
bindings
[
maxDynamicBufferCount
]
.
hasDynamicOffset
=
true
;
t
.
expectValidationError
(
(
)
=
>
{
t
.
device
.
createBindGroupLayout
(
badDescriptor
)
;
}
)
;
}
)
.
params
(
[
{
type
:
C
.
BindingType
.
StorageBuffer
maxDynamicBufferCount
:
4
}
{
type
:
C
.
BindingType
.
UniformBuffer
maxDynamicBufferCount
:
8
}
]
)
;
g
.
test
(
'
dynamic
set
to
true
is
allowed
only
for
buffers
'
async
t
=
>
{
const
type
=
t
.
params
.
type
;
const
success
=
kBindingTypeInfo
[
type
]
.
type
=
=
=
'
buffer
'
;
const
descriptor
=
{
bindings
:
[
{
binding
:
0
visibility
:
GPUShaderStage
.
FRAGMENT
type
hasDynamicOffset
:
true
}
]
}
;
t
.
expectValidationError
(
(
)
=
>
{
t
.
device
.
createBindGroupLayout
(
descriptor
)
;
}
!
success
)
;
}
)
.
params
(
poptions
(
'
type
'
kBindingTypes
)
)
;
let
kCasesForMaxResourcesPerStageTests
;
{
function
pickExtraBindingTypes
(
type
extraTypeSame
)
{
if
(
extraTypeSame
)
{
switch
(
type
)
{
case
'
storage
-
buffer
'
:
case
'
readonly
-
storage
-
buffer
'
:
return
[
'
storage
-
buffer
'
'
readonly
-
storage
-
buffer
'
]
;
default
:
return
[
type
]
;
}
}
else
{
return
type
=
=
=
'
sampler
'
?
[
'
sampled
-
texture
'
]
:
[
'
sampler
'
]
;
}
}
kCasesForMaxResourcesPerStageTests
=
[
]
;
for
(
const
maxedType
of
kBindingTypes
)
{
for
(
const
maxedVisibility
of
kShaderStages
)
{
if
(
!
(
kBindingTypeInfo
[
maxedType
]
.
validStages
&
maxedVisibility
)
)
continue
;
for
(
const
extraTypeSame
of
[
true
false
]
)
{
for
(
const
extraType
of
pickExtraBindingTypes
(
maxedType
extraTypeSame
)
)
{
for
(
const
extraVisibility
of
kShaderStages
)
{
if
(
!
(
kBindingTypeInfo
[
extraType
]
.
validStages
&
extraVisibility
)
)
continue
;
kCasesForMaxResourcesPerStageTests
.
push
(
{
maxedType
maxedVisibility
extraType
extraVisibility
}
)
;
}
}
}
}
}
}
g
.
test
(
'
max
resources
per
stage
/
in
bind
group
layout
'
async
t
=
>
{
const
maxedType
=
t
.
params
.
maxedType
;
const
extraType
=
t
.
params
.
extraType
;
const
{
maxedVisibility
extraVisibility
}
=
t
.
params
;
const
maxedCount
=
kPerStageBindingLimits
[
kBindingTypeInfo
[
maxedType
]
.
perStageLimitType
]
;
const
maxResourceBindings
=
[
]
;
for
(
let
i
=
0
;
i
<
maxedCount
;
i
+
+
)
{
maxResourceBindings
.
push
(
{
binding
:
i
visibility
:
maxedVisibility
type
:
maxedType
}
)
;
}
const
goodDescriptor
=
{
bindings
:
maxResourceBindings
}
;
t
.
device
.
createBindGroupLayout
(
goodDescriptor
)
;
const
newDescriptor
=
clone
(
goodDescriptor
)
;
newDescriptor
.
bindings
.
push
(
{
binding
:
maxedCount
visibility
:
extraVisibility
type
:
extraType
}
)
;
const
shouldError
=
maxedCount
>
=
kMaxBindingsPerBindGroup
;
t
.
expectValidationError
(
(
)
=
>
{
t
.
device
.
createBindGroupLayout
(
newDescriptor
)
;
}
shouldError
)
;
}
)
.
params
(
kCasesForMaxResourcesPerStageTests
)
;
g
.
test
(
'
max
resources
per
stage
/
in
pipeline
layout
'
async
t
=
>
{
const
maxedType
=
t
.
params
.
maxedType
;
const
extraType
=
t
.
params
.
extraType
;
const
{
maxedVisibility
extraVisibility
}
=
t
.
params
;
const
maxedCount
=
kPerStageBindingLimits
[
kBindingTypeInfo
[
maxedType
]
.
perStageLimitType
]
;
const
maxResourceBindings
=
[
]
;
for
(
let
i
=
0
;
i
<
maxedCount
;
i
+
+
)
{
maxResourceBindings
.
push
(
{
binding
:
i
visibility
:
maxedVisibility
type
:
maxedType
}
)
;
}
const
goodLayout
=
t
.
device
.
createBindGroupLayout
(
{
bindings
:
maxResourceBindings
}
)
;
t
.
device
.
createPipelineLayout
(
{
bindGroupLayouts
:
[
goodLayout
]
}
)
;
const
extraLayout
=
t
.
device
.
createBindGroupLayout
(
{
bindings
:
[
{
binding
:
0
visibility
:
extraVisibility
type
:
extraType
}
]
}
)
;
const
newBindingCountsTowardSamePerStageLimit
=
(
maxedVisibility
&
extraVisibility
)
!
=
=
0
&
&
kBindingTypeInfo
[
maxedType
]
.
perStageLimitType
=
=
=
kBindingTypeInfo
[
extraType
]
.
perStageLimitType
;
const
layoutExceedsPerStageLimit
=
newBindingCountsTowardSamePerStageLimit
;
t
.
expectValidationError
(
(
)
=
>
{
t
.
device
.
createPipelineLayout
(
{
bindGroupLayouts
:
[
goodLayout
extraLayout
]
}
)
;
}
layoutExceedsPerStageLimit
)
;
}
)
.
params
(
kCasesForMaxResourcesPerStageTests
)
;
