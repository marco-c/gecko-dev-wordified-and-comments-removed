function
_defineProperty
(
obj
key
value
)
{
if
(
key
in
obj
)
{
Object
.
defineProperty
(
obj
key
{
value
:
value
enumerable
:
true
configurable
:
true
writable
:
true
}
)
;
}
else
{
obj
[
key
]
=
value
;
}
return
obj
;
}
import
{
assert
raceWithRejectOnTimeout
unreachable
assertReject
}
from
'
.
.
/
util
/
util
.
js
'
;
import
{
getGPU
}
from
'
.
/
implementation
.
js
'
;
class
TestFailedButDeviceReusable
extends
Error
{
}
export
class
TestOOMedShouldAttemptGC
extends
Error
{
}
const
kPopErrorScopeTimeoutMS
=
5000
;
export
class
DevicePool
{
constructor
(
)
{
_defineProperty
(
this
"
failed
"
false
)
;
_defineProperty
(
this
"
holder
"
undefined
)
;
}
async
acquire
(
)
{
assert
(
!
this
.
failed
'
WebGPU
device
previously
failed
to
initialize
;
not
retrying
'
)
;
if
(
this
.
holder
=
=
=
undefined
)
{
try
{
this
.
holder
=
await
DevicePool
.
makeHolder
(
)
;
}
catch
(
ex
)
{
this
.
failed
=
true
;
throw
ex
;
}
}
assert
(
!
this
.
holder
.
acquired
'
Device
was
in
use
on
DevicePool
.
acquire
'
)
;
this
.
holder
.
acquired
=
true
;
this
.
beginErrorScopes
(
)
;
return
this
.
holder
.
device
;
}
async
release
(
device
)
{
const
holder
=
this
.
holder
;
assert
(
holder
!
=
=
undefined
'
trying
to
release
a
device
while
pool
is
uninitialized
'
)
;
assert
(
holder
.
acquired
'
trying
to
release
a
device
while
already
released
'
)
;
assert
(
device
=
=
=
holder
.
device
'
Released
device
was
the
wrong
device
'
)
;
try
{
await
raceWithRejectOnTimeout
(
this
.
endErrorScopes
(
)
kPopErrorScopeTimeoutMS
'
finalization
popErrorScope
timed
out
'
)
;
const
lostReason
=
holder
.
lostReason
;
if
(
lostReason
!
=
=
undefined
)
{
unreachable
(
Device
was
lost
:
{
lostReason
}
)
;
}
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
TestFailedButDeviceReusable
)
)
{
this
.
holder
=
undefined
;
}
throw
ex
;
}
finally
{
holder
.
acquired
=
false
;
}
}
static
async
makeHolder
(
)
{
const
gpu
=
getGPU
(
)
;
const
adapter
=
await
gpu
.
requestAdapter
(
)
;
const
holder
=
{
acquired
:
false
device
:
await
adapter
.
requestDevice
(
)
lostReason
:
undefined
}
;
holder
.
device
.
lost
.
then
(
ev
=
>
{
holder
.
lostReason
=
ev
.
message
;
}
)
;
return
holder
;
}
beginErrorScopes
(
)
{
assert
(
this
.
holder
!
=
=
undefined
)
;
this
.
holder
.
device
.
pushErrorScope
(
'
out
-
of
-
memory
'
)
;
this
.
holder
.
device
.
pushErrorScope
(
'
validation
'
)
;
}
async
endErrorScopes
(
)
{
assert
(
this
.
holder
!
=
=
undefined
)
;
let
gpuValidationError
;
let
gpuOutOfMemoryError
;
try
{
gpuValidationError
=
await
this
.
holder
.
device
.
popErrorScope
(
)
;
gpuOutOfMemoryError
=
await
this
.
holder
.
device
.
popErrorScope
(
)
;
}
catch
(
ex
)
{
assert
(
this
.
holder
.
lostReason
!
=
=
undefined
"
popErrorScope
failed
but
device
.
lost
hasn
'
t
fired
(
yet
)
"
)
;
throw
ex
;
}
await
assertReject
(
this
.
holder
.
device
.
popErrorScope
(
)
'
There
was
an
extra
error
scope
on
the
stack
after
a
test
'
)
;
if
(
gpuValidationError
!
=
=
null
)
{
assert
(
gpuValidationError
instanceof
GPUValidationError
)
;
throw
new
TestFailedButDeviceReusable
(
Unexpected
validation
error
occurred
:
{
gpuValidationError
.
message
}
)
;
}
if
(
gpuOutOfMemoryError
!
=
=
null
)
{
assert
(
gpuOutOfMemoryError
instanceof
GPUOutOfMemoryError
)
;
throw
new
TestOOMedShouldAttemptGC
(
'
Unexpected
out
-
of
-
memory
error
occurred
'
)
;
}
}
}
