function
_defineProperty
(
obj
key
value
)
{
if
(
key
in
obj
)
{
Object
.
defineProperty
(
obj
key
{
value
:
value
enumerable
:
true
configurable
:
true
writable
:
true
}
)
;
}
else
{
obj
[
key
]
=
value
;
}
return
obj
;
}
import
{
extractPublicParams
publicParamsEquals
}
from
'
.
/
params_utils
.
js
'
;
import
{
kPathSeparator
}
from
'
.
/
query
/
separators
.
js
'
;
import
{
stringifyPublicParams
}
from
'
.
/
query
/
stringify_params
.
js
'
;
import
{
validQueryPart
}
from
'
.
/
query
/
validQueryPart
.
js
'
;
import
{
assert
}
from
'
.
/
util
/
util
.
js
'
;
export
function
makeTestGroup
(
fixture
)
{
return
new
TestGroup
(
fixture
)
;
}
export
function
makeTestGroupForUnitTesting
(
fixture
)
{
return
new
TestGroup
(
fixture
)
;
}
class
TestGroup
{
constructor
(
fixture
)
{
_defineProperty
(
this
"
fixture
"
void
0
)
;
_defineProperty
(
this
"
seen
"
new
Set
(
)
)
;
_defineProperty
(
this
"
tests
"
[
]
)
;
this
.
fixture
=
fixture
;
}
*
iterate
(
)
{
for
(
const
test
of
this
.
tests
)
{
yield
*
test
.
iterate
(
)
;
}
}
checkName
(
name
)
{
assert
(
name
=
=
=
decodeURIComponent
(
name
)
Not
decodeURIComponent
-
idempotent
:
{
name
}
!
=
=
{
decodeURIComponent
(
name
)
}
)
;
assert
(
!
this
.
seen
.
has
(
name
)
Duplicate
test
name
:
{
name
}
)
;
this
.
seen
.
add
(
name
)
;
}
test
(
name
)
{
this
.
checkName
(
name
)
;
const
parts
=
name
.
split
(
kPathSeparator
)
;
for
(
const
p
of
parts
)
{
assert
(
validQueryPart
.
test
(
p
)
Invalid
test
name
part
{
p
}
;
must
match
{
validQueryPart
}
)
;
}
const
test
=
new
TestBuilder
(
parts
this
.
fixture
)
;
this
.
tests
.
push
(
test
)
;
return
test
;
}
checkCaseNamesAndDuplicates
(
)
{
for
(
const
test
of
this
.
tests
)
{
test
.
checkCaseNamesAndDuplicates
(
)
;
}
}
}
class
TestBuilder
{
constructor
(
testPath
fixture
)
{
_defineProperty
(
this
"
testPath
"
void
0
)
;
_defineProperty
(
this
"
fixture
"
void
0
)
;
_defineProperty
(
this
"
testFn
"
void
0
)
;
_defineProperty
(
this
"
cases
"
undefined
)
;
this
.
testPath
=
testPath
;
this
.
fixture
=
fixture
;
}
fn
(
fn
)
{
this
.
testFn
=
fn
;
}
checkCaseNamesAndDuplicates
(
)
{
if
(
this
.
cases
=
=
=
undefined
)
{
return
;
}
const
seen
=
[
]
;
for
(
const
testcase
of
this
.
cases
)
{
const
testcaseString
=
stringifyPublicParams
(
testcase
)
;
assert
(
!
seen
.
some
(
x
=
>
publicParamsEquals
(
x
testcase
)
)
Duplicate
public
test
case
params
:
{
testcaseString
}
)
;
seen
.
push
(
testcase
)
;
}
}
params
(
casesIterable
)
{
assert
(
this
.
cases
=
=
=
undefined
'
test
case
is
already
parameterized
'
)
;
this
.
cases
=
Array
.
from
(
casesIterable
)
;
return
this
;
}
*
iterate
(
)
{
assert
(
this
.
testFn
!
=
=
undefined
'
No
test
function
(
.
fn
(
)
)
for
test
'
)
;
for
(
const
params
of
this
.
cases
|
|
[
{
}
]
)
{
yield
new
RunCaseSpecific
(
this
.
testPath
params
this
.
fixture
this
.
testFn
)
;
}
}
}
class
RunCaseSpecific
{
constructor
(
testPath
params
fixture
fn
)
{
_defineProperty
(
this
"
id
"
void
0
)
;
_defineProperty
(
this
"
params
"
void
0
)
;
_defineProperty
(
this
"
fixture
"
void
0
)
;
_defineProperty
(
this
"
fn
"
void
0
)
;
this
.
id
=
{
test
:
testPath
params
:
extractPublicParams
(
params
)
}
;
this
.
params
=
params
;
this
.
fixture
=
fixture
;
this
.
fn
=
fn
;
}
async
run
(
rec
)
{
rec
.
start
(
)
;
try
{
const
inst
=
new
this
.
fixture
(
rec
this
.
params
|
|
{
}
)
;
try
{
await
inst
.
init
(
)
;
await
this
.
fn
(
inst
)
;
}
finally
{
await
inst
.
finalize
(
)
;
}
}
catch
(
ex
)
{
rec
.
threw
(
ex
)
;
}
rec
.
finish
(
)
;
}
}
