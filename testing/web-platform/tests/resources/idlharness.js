(
function
(
)
{
"
use
strict
"
;
if
(
!
(
'
subsetTestByKey
'
in
self
)
)
{
self
.
subsetTestByKey
=
function
(
key
callback
.
.
.
args
)
{
return
callback
(
.
.
.
args
)
;
}
self
.
shouldRunSubTest
=
(
)
=
>
true
;
}
function
constValue
(
cnt
)
{
if
(
cnt
.
type
=
=
=
"
null
"
)
return
null
;
if
(
cnt
.
type
=
=
=
"
NaN
"
)
return
NaN
;
if
(
cnt
.
type
=
=
=
"
Infinity
"
)
return
cnt
.
negative
?
-
Infinity
:
Infinity
;
if
(
cnt
.
type
=
=
=
"
number
"
)
return
+
cnt
.
value
;
return
cnt
.
value
;
}
function
minOverloadLength
(
overloads
)
{
if
(
!
overloads
.
length
)
{
return
0
;
}
return
overloads
.
map
(
function
(
attr
)
{
return
attr
.
arguments
?
attr
.
arguments
.
filter
(
function
(
arg
)
{
return
!
arg
.
optional
&
&
!
arg
.
variadic
;
}
)
.
length
:
0
;
}
)
.
reduce
(
function
(
m
n
)
{
return
Math
.
min
(
m
n
)
;
}
)
;
}
function
globalOf
(
func
)
{
try
{
return
func
.
constructor
(
"
return
this
;
"
)
(
)
;
}
catch
(
e
)
{
}
return
self
;
}
function
isConstructor
(
o
)
{
try
{
new
(
new
Proxy
(
o
{
construct
:
(
)
=
>
(
{
}
)
}
)
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
function
throwOrReject
(
a_test
operation
fn
obj
args
message
cb
)
{
if
(
operation
.
idlType
.
generic
!
=
=
"
Promise
"
)
{
assert_throws_js
(
globalOf
(
fn
)
.
TypeError
function
(
)
{
fn
.
apply
(
obj
args
)
;
}
message
)
;
cb
(
)
;
}
else
{
try
{
promise_rejects_js
(
a_test
TypeError
fn
.
apply
(
obj
args
)
message
)
.
then
(
cb
cb
)
;
}
catch
(
e
)
{
a_test
.
step
(
function
(
)
{
assert_unreached
(
"
Throws
\
"
"
+
e
+
"
\
"
instead
of
rejecting
promise
"
)
;
cb
(
)
;
}
)
;
}
}
}
function
awaitNCallbacks
(
n
cb
ctx
)
{
var
counter
=
0
;
return
function
(
)
{
counter
+
+
;
if
(
counter
>
=
n
)
{
cb
(
)
;
}
}
;
}
self
.
IdlHarnessError
=
function
(
message
)
{
this
.
message
=
message
;
}
;
IdlHarnessError
.
prototype
=
Object
.
create
(
Error
.
prototype
)
;
IdlHarnessError
.
prototype
.
toString
=
function
(
)
{
return
this
.
message
;
}
;
self
.
IdlArray
=
function
(
)
{
this
.
members
=
{
}
;
this
.
objects
=
{
}
;
this
.
partials
=
[
]
;
this
.
includes
=
[
]
;
this
.
skipped
=
new
Map
(
)
;
}
;
IdlArray
.
prototype
.
add_idls
=
function
(
raw_idls
options
)
{
this
.
internal_add_idls
(
WebIDL2
.
parse
(
raw_idls
)
options
)
;
}
;
IdlArray
.
prototype
.
add_untested_idls
=
function
(
raw_idls
options
)
{
var
parsed_idls
=
WebIDL2
.
parse
(
raw_idls
)
;
this
.
mark_as_untested
(
parsed_idls
)
;
this
.
internal_add_idls
(
parsed_idls
options
)
;
}
;
IdlArray
.
prototype
.
mark_as_untested
=
function
(
parsed_idls
)
{
for
(
var
i
=
0
;
i
<
parsed_idls
.
length
;
i
+
+
)
{
parsed_idls
[
i
]
.
untested
=
true
;
if
(
"
members
"
in
parsed_idls
[
i
]
)
{
for
(
var
j
=
0
;
j
<
parsed_idls
[
i
]
.
members
.
length
;
j
+
+
)
{
parsed_idls
[
i
]
.
members
[
j
]
.
untested
=
true
;
}
}
}
}
;
IdlArray
.
prototype
.
is_excluded_by_options
=
function
(
name
options
)
{
return
options
&
&
(
options
.
except
&
&
options
.
except
.
includes
(
name
)
|
|
options
.
only
&
&
!
options
.
only
.
includes
(
name
)
)
;
}
;
IdlArray
.
prototype
.
add_dependency_idls
=
function
(
raw_idls
options
)
{
return
this
.
internal_add_dependency_idls
(
WebIDL2
.
parse
(
raw_idls
)
options
)
;
}
;
IdlArray
.
prototype
.
internal_add_dependency_idls
=
function
(
parsed_idls
options
)
{
const
new_options
=
{
only
:
[
]
}
const
all_deps
=
new
Set
(
)
;
Object
.
values
(
this
.
members
)
.
forEach
(
v
=
>
{
if
(
v
.
base
)
{
all_deps
.
add
(
v
.
base
)
;
}
}
)
;
this
.
includes
.
forEach
(
i
=
>
{
all_deps
.
add
(
i
.
target
)
;
all_deps
.
add
(
i
.
includes
)
;
}
)
;
this
.
partials
.
forEach
(
p
=
>
all_deps
.
add
(
p
.
name
)
)
;
Object
.
entries
(
this
.
members
)
.
forEach
(
(
[
k
v
]
)
=
>
{
if
(
v
instanceof
IdlTypedef
)
{
let
defs
=
v
.
idlType
.
union
?
v
.
idlType
.
idlType
.
map
(
t
=
>
t
.
idlType
)
:
[
v
.
idlType
.
idlType
]
;
defs
.
forEach
(
d
=
>
all_deps
.
add
(
d
)
)
;
}
}
)
;
const
attrDeps
=
parsedIdls
=
>
{
return
parsedIdls
.
reduce
(
(
deps
parsed
)
=
>
{
if
(
parsed
.
members
)
{
for
(
const
attr
of
Object
.
values
(
parsed
.
members
)
.
filter
(
m
=
>
m
.
type
=
=
=
'
attribute
'
)
)
{
let
attrType
=
attr
.
idlType
;
if
(
attrType
.
generic
)
{
deps
.
add
(
attrType
.
generic
)
;
attrType
=
attrType
.
idlType
;
}
deps
.
add
(
attrType
.
idlType
)
;
}
}
if
(
parsed
.
base
in
this
.
members
)
{
attrDeps
(
[
this
.
members
[
parsed
.
base
]
]
)
.
forEach
(
dep
=
>
deps
.
add
(
dep
)
)
;
}
return
deps
;
}
new
Set
(
)
)
;
}
;
const
testedMembers
=
Object
.
values
(
this
.
members
)
.
filter
(
m
=
>
!
m
.
untested
&
&
m
.
members
)
;
attrDeps
(
testedMembers
)
.
forEach
(
dep
=
>
all_deps
.
add
(
dep
)
)
;
const
testedPartials
=
this
.
partials
.
filter
(
m
=
>
!
m
.
untested
&
&
m
.
members
)
;
attrDeps
(
testedPartials
)
.
forEach
(
dep
=
>
all_deps
.
add
(
dep
)
)
;
if
(
options
&
&
options
.
except
&
&
options
.
only
)
{
throw
new
IdlHarnessError
(
"
The
only
and
except
options
can
'
t
be
used
together
.
"
)
;
}
const
defined_or_untested
=
name
=
>
{
return
name
in
this
.
members
|
|
this
.
is_excluded_by_options
(
name
options
)
;
}
const
process
=
function
(
parsed
)
{
var
deps
=
[
]
;
if
(
parsed
.
name
)
{
deps
.
push
(
parsed
.
name
)
;
}
else
if
(
parsed
.
type
=
=
=
"
includes
"
)
{
deps
.
push
(
parsed
.
target
)
;
deps
.
push
(
parsed
.
includes
)
;
}
deps
=
deps
.
filter
(
function
(
name
)
{
if
(
!
name
|
|
name
=
=
=
parsed
.
name
&
&
defined_or_untested
(
name
)
|
|
!
all_deps
.
has
(
name
)
)
{
if
(
name
&
&
!
(
name
in
this
.
members
)
)
{
this
.
skipped
.
has
(
name
)
?
this
.
skipped
.
get
(
name
)
.
push
(
parsed
)
:
this
.
skipped
.
set
(
name
[
parsed
]
)
;
}
return
false
;
}
return
true
;
}
.
bind
(
this
)
)
;
deps
.
forEach
(
function
(
name
)
{
if
(
!
new_options
.
only
.
includes
(
name
)
)
{
new_options
.
only
.
push
(
name
)
;
}
const
follow_up
=
new
Set
(
)
;
for
(
const
dep_type
of
[
"
inheritance
"
"
includes
"
]
)
{
if
(
parsed
[
dep_type
]
)
{
const
inheriting
=
parsed
[
dep_type
]
;
const
inheritor
=
parsed
.
name
|
|
parsed
.
target
;
const
deps
=
[
inheriting
]
;
if
(
dep_type
!
=
=
"
includes
"
|
|
inheriting
in
this
.
members
&
&
!
this
.
members
[
inheriting
]
.
untested
|
|
this
.
partials
.
some
(
function
(
p
)
{
return
p
.
name
=
=
=
inheriting
;
}
)
)
{
deps
.
push
(
inheritor
)
;
}
for
(
const
dep
of
deps
)
{
if
(
!
new_options
.
only
.
includes
(
dep
)
)
{
new_options
.
only
.
push
(
dep
)
;
}
all_deps
.
add
(
dep
)
;
follow_up
.
add
(
dep
)
;
}
}
}
for
(
const
deferred
of
follow_up
)
{
if
(
this
.
skipped
.
has
(
deferred
)
)
{
const
next
=
this
.
skipped
.
get
(
deferred
)
;
this
.
skipped
.
delete
(
deferred
)
;
next
.
forEach
(
process
)
;
}
}
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
;
for
(
let
parsed
of
parsed_idls
)
{
process
(
parsed
)
;
}
this
.
mark_as_untested
(
parsed_idls
)
;
if
(
new_options
.
only
.
length
)
{
this
.
internal_add_idls
(
parsed_idls
new_options
)
;
}
}
IdlArray
.
prototype
.
internal_add_idls
=
function
(
parsed_idls
options
)
{
if
(
options
&
&
options
.
only
&
&
options
.
except
)
{
throw
new
IdlHarnessError
(
"
The
only
and
except
options
can
'
t
be
used
together
.
"
)
;
}
var
should_skip
=
name
=
>
{
return
this
.
is_excluded_by_options
(
name
options
)
;
}
parsed_idls
.
forEach
(
function
(
parsed_idl
)
{
var
partial_types
=
[
"
interface
"
"
interface
mixin
"
"
dictionary
"
"
namespace
"
]
;
if
(
parsed_idl
.
partial
&
&
partial_types
.
includes
(
parsed_idl
.
type
)
)
{
if
(
should_skip
(
parsed_idl
.
name
)
)
{
return
;
}
this
.
partials
.
push
(
parsed_idl
)
;
return
;
}
if
(
parsed_idl
.
type
=
=
"
includes
"
)
{
if
(
should_skip
(
parsed_idl
.
target
)
)
{
return
;
}
this
.
includes
.
push
(
parsed_idl
)
;
return
;
}
parsed_idl
.
array
=
this
;
if
(
should_skip
(
parsed_idl
.
name
)
)
{
return
;
}
if
(
parsed_idl
.
name
in
this
.
members
)
{
throw
new
IdlHarnessError
(
"
Duplicate
identifier
"
+
parsed_idl
.
name
)
;
}
switch
(
parsed_idl
.
type
)
{
case
"
interface
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlInterface
(
parsed_idl
false
false
)
;
break
;
case
"
interface
mixin
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlInterface
(
parsed_idl
false
true
)
;
break
;
case
"
dictionary
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlDictionary
(
parsed_idl
)
;
break
;
case
"
typedef
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlTypedef
(
parsed_idl
)
;
break
;
case
"
callback
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlCallback
(
parsed_idl
)
;
break
;
case
"
enum
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlEnum
(
parsed_idl
)
;
break
;
case
"
callback
interface
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlInterface
(
parsed_idl
true
false
)
;
break
;
case
"
namespace
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlNamespace
(
parsed_idl
)
;
break
;
default
:
throw
parsed_idl
.
name
+
"
:
"
+
parsed_idl
.
type
+
"
not
yet
supported
"
;
}
}
.
bind
(
this
)
)
;
}
;
IdlArray
.
prototype
.
add_objects
=
function
(
dict
)
{
for
(
var
k
in
dict
)
{
if
(
k
in
this
.
objects
)
{
this
.
objects
[
k
]
=
this
.
objects
[
k
]
.
concat
(
dict
[
k
]
)
;
}
else
{
this
.
objects
[
k
]
=
dict
[
k
]
;
}
}
}
;
IdlArray
.
prototype
.
prevent_multiple_testing
=
function
(
name
)
{
this
.
members
[
name
]
.
prevent_multiple_testing
=
true
;
}
;
IdlArray
.
prototype
.
is_json_type
=
function
(
type
)
{
var
idlType
=
type
.
idlType
;
if
(
type
.
generic
=
=
"
Promise
"
)
{
return
false
;
}
if
(
type
.
union
|
|
type
.
generic
=
=
"
record
"
)
{
return
idlType
.
every
(
this
.
is_json_type
this
)
;
}
if
(
type
.
generic
=
=
"
sequence
"
|
|
type
.
generic
=
=
"
FrozenArray
"
)
{
return
this
.
is_json_type
(
idlType
[
0
]
)
;
}
if
(
typeof
idlType
!
=
"
string
"
)
{
throw
new
Error
(
"
Unexpected
type
"
+
JSON
.
stringify
(
idlType
)
)
;
}
switch
(
idlType
)
{
case
"
byte
"
:
case
"
octet
"
:
case
"
short
"
:
case
"
unsigned
short
"
:
case
"
long
"
:
case
"
unsigned
long
"
:
case
"
long
long
"
:
case
"
unsigned
long
long
"
:
case
"
float
"
:
case
"
double
"
:
case
"
unrestricted
float
"
:
case
"
unrestricted
double
"
:
case
"
boolean
"
:
case
"
DOMString
"
:
case
"
ByteString
"
:
case
"
USVString
"
:
case
"
object
"
:
return
true
;
case
"
Error
"
:
case
"
DOMException
"
:
case
"
Int8Array
"
:
case
"
Int16Array
"
:
case
"
Int32Array
"
:
case
"
Uint8Array
"
:
case
"
Uint16Array
"
:
case
"
Uint32Array
"
:
case
"
Uint8ClampedArray
"
:
case
"
BigInt64Array
"
:
case
"
BigUint64Array
"
:
case
"
Float32Array
"
:
case
"
Float64Array
"
:
case
"
ArrayBuffer
"
:
case
"
DataView
"
:
case
"
any
"
:
return
false
;
default
:
var
thing
=
this
.
members
[
idlType
]
;
if
(
!
thing
)
{
throw
new
Error
(
"
Type
"
+
idlType
+
"
not
found
"
)
;
}
if
(
thing
instanceof
IdlEnum
)
{
return
true
;
}
if
(
thing
instanceof
IdlTypedef
)
{
return
this
.
is_json_type
(
thing
.
idlType
)
;
}
if
(
thing
instanceof
IdlDictionary
)
{
const
map
=
new
Map
(
)
;
for
(
const
dict
of
thing
.
get_reverse_inheritance_stack
(
)
)
{
for
(
const
m
of
dict
.
members
)
{
map
.
set
(
m
.
name
m
.
idlType
)
;
}
}
return
Array
.
from
(
map
.
values
(
)
)
.
every
(
this
.
is_json_type
this
)
;
}
if
(
thing
instanceof
IdlInterface
)
{
var
base
;
while
(
thing
)
{
if
(
thing
.
has_to_json_regular_operation
(
)
)
{
return
true
;
}
var
mixins
=
this
.
includes
[
thing
.
name
]
;
if
(
mixins
)
{
mixins
=
mixins
.
map
(
function
(
id
)
{
var
mixin
=
this
.
members
[
id
]
;
if
(
!
mixin
)
{
throw
new
Error
(
"
Interface
"
+
id
+
"
not
found
(
implemented
by
"
+
thing
.
name
+
"
)
"
)
;
}
return
mixin
;
}
this
)
;
if
(
mixins
.
some
(
function
(
m
)
{
return
m
.
has_to_json_regular_operation
(
)
}
)
)
{
return
true
;
}
}
if
(
!
thing
.
base
)
{
return
false
;
}
base
=
this
.
members
[
thing
.
base
]
;
if
(
!
base
)
{
throw
new
Error
(
"
Interface
"
+
thing
.
base
+
"
not
found
(
inherited
by
"
+
thing
.
name
+
"
)
"
)
;
}
thing
=
base
;
}
return
false
;
}
return
false
;
}
}
;
function
exposure_set
(
object
default_set
)
{
var
exposed
=
object
.
extAttrs
&
&
object
.
extAttrs
.
filter
(
a
=
>
a
.
name
=
=
=
"
Exposed
"
)
;
if
(
exposed
&
&
exposed
.
length
>
1
)
{
throw
new
IdlHarnessError
(
Multiple
'
Exposed
'
extended
attributes
on
{
object
.
name
}
)
;
}
let
result
=
default_set
|
|
[
"
Window
"
]
;
if
(
result
&
&
!
(
result
instanceof
Set
)
)
{
result
=
new
Set
(
result
)
;
}
if
(
exposed
&
&
exposed
.
length
)
{
const
{
rhs
}
=
exposed
[
0
]
;
const
set
=
rhs
.
type
=
=
=
"
*
"
?
[
"
*
"
]
:
rhs
.
type
=
=
=
"
identifier
-
list
"
?
rhs
.
value
.
map
(
id
=
>
id
.
value
)
:
[
rhs
.
value
]
;
result
=
new
Set
(
set
)
;
}
if
(
result
&
&
result
.
has
(
"
*
"
)
)
{
return
"
*
"
;
}
if
(
result
&
&
result
.
has
(
"
Worker
"
)
)
{
result
.
delete
(
"
Worker
"
)
;
result
.
add
(
"
DedicatedWorker
"
)
;
result
.
add
(
"
ServiceWorker
"
)
;
result
.
add
(
"
SharedWorker
"
)
;
}
return
result
;
}
function
exposed_in
(
globals
)
{
if
(
globals
=
=
=
"
*
"
)
{
return
true
;
}
if
(
'
Window
'
in
self
)
{
return
globals
.
has
(
"
Window
"
)
;
}
if
(
'
DedicatedWorkerGlobalScope
'
in
self
&
&
self
instanceof
DedicatedWorkerGlobalScope
)
{
return
globals
.
has
(
"
DedicatedWorker
"
)
;
}
if
(
'
SharedWorkerGlobalScope
'
in
self
&
&
self
instanceof
SharedWorkerGlobalScope
)
{
return
globals
.
has
(
"
SharedWorker
"
)
;
}
if
(
'
ServiceWorkerGlobalScope
'
in
self
&
&
self
instanceof
ServiceWorkerGlobalScope
)
{
return
globals
.
has
(
"
ServiceWorker
"
)
;
}
if
(
Object
.
getPrototypeOf
(
self
)
=
=
=
Object
.
prototype
)
{
return
false
;
}
throw
new
IdlHarnessError
(
"
Unexpected
global
object
"
)
;
}
IdlArray
.
prototype
.
assert_throws
=
function
(
error
idlArrayFunc
)
{
try
{
idlArrayFunc
.
call
(
this
this
)
;
}
catch
(
e
)
{
if
(
e
instanceof
AssertionError
)
{
throw
e
;
}
if
(
error
instanceof
IdlHarnessError
)
{
error
=
error
.
message
;
}
if
(
e
.
message
!
=
=
error
)
{
throw
new
IdlHarnessError
(
{
idlArrayFunc
}
threw
"
{
e
}
"
not
the
expected
IdlHarnessError
"
{
error
}
"
)
;
}
return
;
}
throw
new
IdlHarnessError
(
{
idlArrayFunc
}
did
not
throw
the
expected
IdlHarnessError
)
;
}
IdlArray
.
prototype
.
test
=
function
(
)
{
this
.
merge_partials
(
)
;
this
.
merge_mixins
(
)
;
for
(
const
member
of
Object
.
values
(
this
.
members
)
.
filter
(
m
=
>
m
.
base
)
)
{
const
lhs
=
member
.
name
;
const
rhs
=
member
.
base
;
if
(
!
(
rhs
in
this
.
members
)
)
throw
new
IdlHarnessError
(
{
lhs
}
inherits
{
rhs
}
but
{
rhs
}
is
undefined
.
)
;
const
lhs_is_interface
=
this
.
members
[
lhs
]
instanceof
IdlInterface
;
const
rhs_is_interface
=
this
.
members
[
rhs
]
instanceof
IdlInterface
;
if
(
rhs_is_interface
!
=
lhs_is_interface
)
{
if
(
!
lhs_is_interface
)
throw
new
IdlHarnessError
(
{
lhs
}
inherits
{
rhs
}
but
{
lhs
}
is
not
an
interface
.
)
;
if
(
!
rhs_is_interface
)
throw
new
IdlHarnessError
(
{
lhs
}
inherits
{
rhs
}
but
{
rhs
}
is
not
an
interface
.
)
;
}
member
.
get_reverse_inheritance_stack
(
)
;
}
Object
.
getOwnPropertyNames
(
this
.
members
)
.
forEach
(
function
(
memberName
)
{
var
member
=
this
.
members
[
memberName
]
;
if
(
!
(
member
instanceof
IdlInterface
)
)
{
return
;
}
var
globals
=
exposure_set
(
member
)
;
member
.
exposed
=
exposed_in
(
globals
)
;
member
.
exposureSet
=
globals
;
}
.
bind
(
this
)
)
;
for
(
var
name
in
this
.
members
)
{
this
.
members
[
name
]
.
test
(
)
;
if
(
name
in
this
.
objects
)
{
const
objects
=
this
.
objects
[
name
]
;
if
(
!
objects
|
|
!
Array
.
isArray
(
objects
)
)
{
throw
new
IdlHarnessError
(
Invalid
or
empty
objects
for
member
{
name
}
)
;
}
objects
.
forEach
(
function
(
str
)
{
if
(
!
this
.
members
[
name
]
|
|
!
(
this
.
members
[
name
]
instanceof
IdlInterface
)
)
{
throw
new
IdlHarnessError
(
Invalid
object
member
name
{
name
}
)
;
}
this
.
members
[
name
]
.
test_object
(
str
)
;
}
.
bind
(
this
)
)
;
}
}
}
;
IdlArray
.
prototype
.
merge_partials
=
function
(
)
{
const
testedPartials
=
new
Map
(
)
;
this
.
partials
.
forEach
(
function
(
parsed_idl
)
{
const
originalExists
=
parsed_idl
.
name
in
this
.
members
&
&
(
this
.
members
[
parsed_idl
.
name
]
instanceof
IdlInterface
|
|
this
.
members
[
parsed_idl
.
name
]
instanceof
IdlDictionary
|
|
this
.
members
[
parsed_idl
.
name
]
instanceof
IdlNamespace
)
;
let
partialTestName
=
parsed_idl
.
name
;
let
partialTestCount
=
1
;
if
(
testedPartials
.
has
(
parsed_idl
.
name
)
)
{
partialTestCount
+
=
testedPartials
.
get
(
parsed_idl
.
name
)
;
partialTestName
=
{
partialTestName
}
[
{
partialTestCount
}
]
;
}
testedPartials
.
set
(
parsed_idl
.
name
partialTestCount
)
;
if
(
!
parsed_idl
.
untested
)
{
test
(
function
(
)
{
assert_true
(
originalExists
Original
{
parsed_idl
.
type
}
should
be
defined
)
;
var
expected
;
switch
(
parsed_idl
.
type
)
{
case
'
dictionary
'
:
expected
=
IdlDictionary
;
break
;
case
'
namespace
'
:
expected
=
IdlNamespace
;
break
;
case
'
interface
'
:
case
'
interface
mixin
'
:
default
:
expected
=
IdlInterface
;
break
;
}
assert_true
(
expected
.
prototype
.
isPrototypeOf
(
this
.
members
[
parsed_idl
.
name
]
)
Original
{
parsed_idl
.
name
}
definition
should
have
type
{
parsed_idl
.
type
}
)
;
}
.
bind
(
this
)
Partial
{
parsed_idl
.
type
}
{
partialTestName
}
:
original
{
parsed_idl
.
type
}
defined
)
;
}
if
(
!
originalExists
)
{
return
;
}
if
(
parsed_idl
.
extAttrs
)
{
const
exposureAttr
=
parsed_idl
.
extAttrs
.
find
(
a
=
>
a
.
name
=
=
=
"
Exposed
"
)
;
if
(
exposureAttr
)
{
if
(
!
parsed_idl
.
untested
)
{
test
(
function
(
)
{
const
partialExposure
=
exposure_set
(
parsed_idl
)
;
const
memberExposure
=
exposure_set
(
this
.
members
[
parsed_idl
.
name
]
)
;
if
(
memberExposure
=
=
=
"
*
"
)
{
return
;
}
if
(
partialExposure
=
=
=
"
*
"
)
{
throw
new
IdlHarnessError
(
Partial
{
parsed_idl
.
name
}
{
parsed_idl
.
type
}
is
exposed
everywhere
the
original
{
parsed_idl
.
type
}
is
not
.
)
;
}
partialExposure
.
forEach
(
name
=
>
{
if
(
!
memberExposure
|
|
!
memberExposure
.
has
(
name
)
)
{
throw
new
IdlHarnessError
(
Partial
{
parsed_idl
.
name
}
{
parsed_idl
.
type
}
is
exposed
to
'
{
name
}
'
the
original
{
parsed_idl
.
type
}
is
not
.
)
;
}
}
)
;
}
.
bind
(
this
)
Partial
{
parsed_idl
.
type
}
{
partialTestName
}
:
valid
exposure
set
)
;
}
parsed_idl
.
members
.
forEach
(
function
(
member
)
{
member
.
extAttrs
.
push
(
exposureAttr
)
;
}
.
bind
(
this
)
)
;
}
parsed_idl
.
extAttrs
.
forEach
(
function
(
extAttr
)
{
if
(
extAttr
.
name
=
=
=
"
Exposed
"
)
{
return
;
}
this
.
members
[
parsed_idl
.
name
]
.
extAttrs
.
push
(
extAttr
)
;
}
.
bind
(
this
)
)
;
}
if
(
parsed_idl
.
members
.
length
)
{
test
(
function
(
)
{
var
clash
=
parsed_idl
.
members
.
find
(
function
(
member
)
{
return
this
.
members
[
parsed_idl
.
name
]
.
members
.
find
(
function
(
m
)
{
return
this
.
are_duplicate_members
(
m
member
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
parsed_idl
.
members
.
forEach
(
function
(
member
)
{
this
.
members
[
parsed_idl
.
name
]
.
members
.
push
(
new
IdlInterfaceMember
(
member
)
)
;
}
.
bind
(
this
)
)
;
assert_true
(
!
clash
"
member
"
+
(
clash
&
&
clash
.
name
)
+
"
is
unique
"
)
;
}
.
bind
(
this
)
Partial
{
parsed_idl
.
type
}
{
partialTestName
}
:
member
names
are
unique
)
;
}
}
.
bind
(
this
)
)
;
this
.
partials
=
[
]
;
}
IdlArray
.
prototype
.
merge_mixins
=
function
(
)
{
for
(
const
parsed_idl
of
this
.
includes
)
{
const
lhs
=
parsed_idl
.
target
;
const
rhs
=
parsed_idl
.
includes
;
var
errStr
=
lhs
+
"
includes
"
+
rhs
+
"
but
"
;
if
(
!
(
lhs
in
this
.
members
)
)
throw
errStr
+
lhs
+
"
is
undefined
.
"
;
if
(
!
(
this
.
members
[
lhs
]
instanceof
IdlInterface
)
)
throw
errStr
+
lhs
+
"
is
not
an
interface
.
"
;
if
(
!
(
rhs
in
this
.
members
)
)
throw
errStr
+
rhs
+
"
is
undefined
.
"
;
if
(
!
(
this
.
members
[
rhs
]
instanceof
IdlInterface
)
)
throw
errStr
+
rhs
+
"
is
not
an
interface
.
"
;
if
(
this
.
members
[
rhs
]
.
members
.
length
)
{
test
(
function
(
)
{
var
clash
=
this
.
members
[
rhs
]
.
members
.
find
(
function
(
member
)
{
return
this
.
members
[
lhs
]
.
members
.
find
(
function
(
m
)
{
return
this
.
are_duplicate_members
(
m
member
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
this
.
members
[
rhs
]
.
members
.
forEach
(
function
(
member
)
{
assert_true
(
this
.
members
[
lhs
]
.
members
.
every
(
m
=
>
!
this
.
are_duplicate_members
(
m
member
)
)
"
member
"
+
member
.
name
+
"
is
unique
"
)
;
this
.
members
[
lhs
]
.
members
.
push
(
new
IdlInterfaceMember
(
member
)
)
;
}
.
bind
(
this
)
)
;
assert_true
(
!
clash
"
member
"
+
(
clash
&
&
clash
.
name
)
+
"
is
unique
"
)
;
}
.
bind
(
this
)
lhs
+
"
includes
"
+
rhs
+
"
:
member
names
are
unique
"
)
;
}
}
this
.
includes
=
[
]
;
}
IdlArray
.
prototype
.
are_duplicate_members
=
function
(
m1
m2
)
{
if
(
m1
.
name
!
=
=
m2
.
name
)
{
return
false
;
}
if
(
m1
.
type
=
=
=
'
operation
'
&
&
m2
.
type
=
=
=
'
operation
'
&
&
m1
.
arguments
.
length
!
=
=
m2
.
arguments
.
length
)
{
return
false
;
}
return
true
;
}
IdlArray
.
prototype
.
assert_type_is
=
function
(
value
type
)
{
if
(
type
.
idlType
in
this
.
members
&
&
this
.
members
[
type
.
idlType
]
instanceof
IdlTypedef
)
{
this
.
assert_type_is
(
value
this
.
members
[
type
.
idlType
]
.
idlType
)
;
return
;
}
if
(
type
.
nullable
&
&
value
=
=
=
null
)
{
return
;
}
if
(
type
.
union
)
{
for
(
var
i
=
0
;
i
<
type
.
idlType
.
length
;
i
+
+
)
{
try
{
this
.
assert_type_is
(
value
type
.
idlType
[
i
]
)
;
return
;
}
catch
(
e
)
{
if
(
e
instanceof
AssertionError
)
{
continue
;
}
throw
e
;
}
}
assert_true
(
false
"
Attribute
has
value
"
+
format_value
(
value
)
+
"
which
doesn
'
t
match
any
of
the
types
in
the
union
"
)
;
}
if
(
type
.
idlType
=
=
"
any
"
)
{
return
;
}
if
(
type
.
array
)
{
return
;
}
if
(
type
.
generic
=
=
=
"
sequence
"
|
|
type
.
generic
=
=
"
ObservableArray
"
)
{
assert_true
(
Array
.
isArray
(
value
)
"
should
be
an
Array
"
)
;
if
(
!
value
.
length
)
{
return
;
}
this
.
assert_type_is
(
value
[
0
]
type
.
idlType
[
0
]
)
;
return
;
}
if
(
type
.
generic
=
=
=
"
Promise
"
)
{
assert_true
(
"
then
"
in
value
"
Attribute
with
a
Promise
type
should
have
a
then
property
"
)
;
return
;
}
if
(
type
.
generic
=
=
=
"
FrozenArray
"
)
{
assert_true
(
Array
.
isArray
(
value
)
"
Value
should
be
array
"
)
;
assert_true
(
Object
.
isFrozen
(
value
)
"
Value
should
be
frozen
"
)
;
if
(
!
value
.
length
)
{
return
;
}
this
.
assert_type_is
(
value
[
0
]
type
.
idlType
[
0
]
)
;
return
;
}
type
=
Array
.
isArray
(
type
.
idlType
)
?
type
.
idlType
[
0
]
:
type
.
idlType
;
switch
(
type
)
{
case
"
undefined
"
:
assert_equals
(
value
undefined
)
;
return
;
case
"
boolean
"
:
assert_equals
(
typeof
value
"
boolean
"
)
;
return
;
case
"
byte
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
floor
(
value
)
"
should
be
an
integer
"
)
;
assert_true
(
-
128
<
=
value
&
&
value
<
=
127
"
byte
"
+
value
+
"
should
be
in
range
[
-
128
127
]
"
)
;
return
;
case
"
octet
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
floor
(
value
)
"
should
be
an
integer
"
)
;
assert_true
(
0
<
=
value
&
&
value
<
=
255
"
octet
"
+
value
+
"
should
be
in
range
[
0
255
]
"
)
;
return
;
case
"
short
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
floor
(
value
)
"
should
be
an
integer
"
)
;
assert_true
(
-
32768
<
=
value
&
&
value
<
=
32767
"
short
"
+
value
+
"
should
be
in
range
[
-
32768
32767
]
"
)
;
return
;
case
"
unsigned
short
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
floor
(
value
)
"
should
be
an
integer
"
)
;
assert_true
(
0
<
=
value
&
&
value
<
=
65535
"
unsigned
short
"
+
value
+
"
should
be
in
range
[
0
65535
]
"
)
;
return
;
case
"
long
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
floor
(
value
)
"
should
be
an
integer
"
)
;
assert_true
(
-
2147483648
<
=
value
&
&
value
<
=
2147483647
"
long
"
+
value
+
"
should
be
in
range
[
-
2147483648
2147483647
]
"
)
;
return
;
case
"
unsigned
long
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
floor
(
value
)
"
should
be
an
integer
"
)
;
assert_true
(
0
<
=
value
&
&
value
<
=
4294967295
"
unsigned
long
"
+
value
+
"
should
be
in
range
[
0
4294967295
]
"
)
;
return
;
case
"
long
long
"
:
assert_equals
(
typeof
value
"
number
"
)
;
return
;
case
"
unsigned
long
long
"
:
case
"
DOMTimeStamp
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_true
(
0
<
=
value
"
unsigned
long
long
should
be
positive
"
)
;
return
;
case
"
float
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
fround
(
value
)
"
float
rounded
to
32
-
bit
float
should
be
itself
"
)
;
assert_not_equals
(
value
Infinity
)
;
assert_not_equals
(
value
-
Infinity
)
;
assert_not_equals
(
value
NaN
)
;
return
;
case
"
DOMHighResTimeStamp
"
:
case
"
double
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_not_equals
(
value
Infinity
)
;
assert_not_equals
(
value
-
Infinity
)
;
assert_not_equals
(
value
NaN
)
;
return
;
case
"
unrestricted
float
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
fround
(
value
)
"
unrestricted
float
rounded
to
32
-
bit
float
should
be
itself
"
)
;
return
;
case
"
unrestricted
double
"
:
assert_equals
(
typeof
value
"
number
"
)
;
return
;
case
"
DOMString
"
:
assert_equals
(
typeof
value
"
string
"
)
;
return
;
case
"
ByteString
"
:
assert_equals
(
typeof
value
"
string
"
)
;
assert_regexp_match
(
value
/
^
[
\
x00
-
\
x7F
]
*
/
)
;
return
;
case
"
USVString
"
:
assert_equals
(
typeof
value
"
string
"
)
;
assert_regexp_match
(
value
/
^
(
[
\
x00
-
\
ud7ff
\
ue000
-
\
uffff
]
|
[
\
ud800
-
\
udbff
]
[
\
udc00
-
\
udfff
]
)
*
/
)
;
return
;
case
"
ArrayBufferView
"
:
assert_true
(
ArrayBuffer
.
isView
(
value
)
)
;
return
;
case
"
object
"
:
assert_in_array
(
typeof
value
[
"
object
"
"
function
"
]
"
wrong
type
:
not
object
or
function
"
)
;
return
;
}
if
(
!
(
type
in
this
.
members
)
)
{
assert_true
(
value
instanceof
self
[
type
]
"
wrong
type
:
not
a
"
+
type
)
;
return
;
}
if
(
this
.
members
[
type
]
instanceof
IdlInterface
)
{
assert_in_array
(
typeof
value
[
"
object
"
"
function
"
]
"
wrong
type
:
not
object
or
function
"
)
;
if
(
value
instanceof
Object
&
&
!
this
.
members
[
type
]
.
has_extended_attribute
(
"
LegacyNoInterfaceObject
"
)
&
&
type
in
self
)
{
assert_true
(
value
instanceof
self
[
type
]
"
instanceof
"
+
type
)
;
}
}
else
if
(
this
.
members
[
type
]
instanceof
IdlEnum
)
{
assert_equals
(
typeof
value
"
string
"
)
;
}
else
if
(
this
.
members
[
type
]
instanceof
IdlDictionary
)
{
}
else
if
(
this
.
members
[
type
]
instanceof
IdlCallback
)
{
assert_equals
(
typeof
value
"
function
"
)
;
}
else
{
throw
new
IdlHarnessError
(
"
Type
"
+
type
+
"
isn
'
t
an
interface
callback
or
dictionary
"
)
;
}
}
;
function
IdlObject
(
)
{
}
IdlObject
.
prototype
.
test
=
function
(
)
{
}
;
IdlObject
.
prototype
.
has_extended_attribute
=
function
(
name
)
{
return
this
.
extAttrs
.
some
(
function
(
o
)
{
return
o
.
name
=
=
name
;
}
)
;
}
;
function
IdlDictionary
(
obj
)
{
this
.
name
=
obj
.
name
;
this
.
array
=
obj
.
array
;
this
.
members
=
obj
.
members
;
this
.
base
=
obj
.
inheritance
;
}
IdlDictionary
.
prototype
=
Object
.
create
(
IdlObject
.
prototype
)
;
IdlDictionary
.
prototype
.
get_reverse_inheritance_stack
=
function
(
)
{
return
IdlInterface
.
prototype
.
get_reverse_inheritance_stack
.
call
(
this
)
;
}
;
function
IdlInterface
(
obj
is_callback
is_mixin
)
{
this
.
name
=
obj
.
name
;
this
.
array
=
obj
.
array
;
this
.
untested
=
obj
.
untested
;
this
.
extAttrs
=
obj
.
extAttrs
;
this
.
members
=
obj
.
members
.
map
(
function
(
m
)
{
return
new
IdlInterfaceMember
(
m
)
;
}
)
;
if
(
this
.
has_extended_attribute
(
"
LegacyUnforgeable
"
)
)
{
this
.
members
.
filter
(
function
(
m
)
{
return
m
.
special
!
=
=
"
static
"
&
&
(
m
.
type
=
=
"
attribute
"
|
|
m
.
type
=
=
"
operation
"
)
;
}
)
.
forEach
(
function
(
m
)
{
return
m
.
isUnforgeable
=
true
;
}
)
;
}
this
.
base
=
obj
.
inheritance
;
this
.
_is_callback
=
is_callback
;
this
.
_is_mixin
=
is_mixin
;
}
IdlInterface
.
prototype
=
Object
.
create
(
IdlObject
.
prototype
)
;
IdlInterface
.
prototype
.
is_callback
=
function
(
)
{
return
this
.
_is_callback
;
}
;
IdlInterface
.
prototype
.
is_mixin
=
function
(
)
{
return
this
.
_is_mixin
;
}
;
IdlInterface
.
prototype
.
has_constants
=
function
(
)
{
return
this
.
members
.
some
(
function
(
member
)
{
return
member
.
type
=
=
=
"
const
"
;
}
)
;
}
;
IdlInterface
.
prototype
.
get_unscopables
=
function
(
)
{
return
this
.
members
.
filter
(
function
(
member
)
{
return
member
.
isUnscopable
;
}
)
;
}
;
IdlInterface
.
prototype
.
is_global
=
function
(
)
{
return
this
.
extAttrs
.
some
(
function
(
attribute
)
{
return
attribute
.
name
=
=
=
"
Global
"
;
}
)
;
}
;
IdlInterface
.
prototype
.
get_legacy_namespace
=
function
(
)
{
var
legacyNamespace
=
this
.
extAttrs
.
find
(
function
(
attribute
)
{
return
attribute
.
name
=
=
=
"
LegacyNamespace
"
;
}
)
;
return
legacyNamespace
?
legacyNamespace
.
rhs
.
value
:
undefined
;
}
;
IdlInterface
.
prototype
.
get_interface_object_owner
=
function
(
)
{
var
legacyNamespace
=
this
.
get_legacy_namespace
(
)
;
return
legacyNamespace
?
self
[
legacyNamespace
]
:
self
;
}
;
IdlInterface
.
prototype
.
should_have_interface_object
=
function
(
)
{
return
this
.
is_callback
(
)
?
this
.
has_constants
(
)
:
!
this
.
has_extended_attribute
(
"
LegacyNoInterfaceObject
"
)
;
}
;
IdlInterface
.
prototype
.
assert_interface_object_exists
=
function
(
)
{
var
owner
=
this
.
get_legacy_namespace
(
)
|
|
"
self
"
;
assert_own_property
(
self
[
owner
]
this
.
name
owner
+
"
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
}
;
IdlInterface
.
prototype
.
get_interface_object
=
function
(
)
{
if
(
!
this
.
should_have_interface_object
(
)
)
{
var
reason
=
this
.
is_callback
(
)
?
"
lack
of
declared
constants
"
:
"
declared
[
LegacyNoInterfaceObject
]
attribute
"
;
throw
new
IdlHarnessError
(
this
.
name
+
"
has
no
interface
object
due
to
"
+
reason
)
;
}
return
this
.
get_interface_object_owner
(
)
[
this
.
name
]
;
}
;
IdlInterface
.
prototype
.
get_qualified_name
=
function
(
)
{
var
legacyNamespace
=
this
.
get_legacy_namespace
(
)
;
if
(
legacyNamespace
)
{
return
legacyNamespace
+
"
.
"
+
this
.
name
;
}
return
this
.
name
;
}
;
IdlInterface
.
prototype
.
has_to_json_regular_operation
=
function
(
)
{
return
this
.
members
.
some
(
function
(
m
)
{
return
m
.
is_to_json_regular_operation
(
)
;
}
)
;
}
;
IdlInterface
.
prototype
.
has_default_to_json_regular_operation
=
function
(
)
{
return
this
.
members
.
some
(
function
(
m
)
{
return
m
.
is_to_json_regular_operation
(
)
&
&
m
.
has_extended_attribute
(
"
Default
"
)
;
}
)
;
}
;
IdlInterface
.
prototype
.
get_reverse_inheritance_stack
=
function
(
)
{
const
stack
=
[
this
]
;
let
idl_interface
=
this
;
while
(
idl_interface
.
base
)
{
const
base
=
this
.
array
.
members
[
idl_interface
.
base
]
;
if
(
!
base
)
{
throw
new
Error
(
idl_interface
.
type
+
"
"
+
idl_interface
.
base
+
"
not
found
(
inherited
by
"
+
idl_interface
.
name
+
"
)
"
)
;
}
else
if
(
stack
.
indexOf
(
base
)
>
-
1
)
{
stack
.
unshift
(
base
)
;
const
dep_chain
=
stack
.
map
(
i
=
>
i
.
name
)
.
join
(
'
'
)
;
throw
new
IdlHarnessError
(
{
this
.
name
}
has
a
circular
dependency
:
{
dep_chain
}
)
;
}
idl_interface
=
base
;
stack
.
unshift
(
idl_interface
)
;
}
return
stack
;
}
;
IdlInterface
.
prototype
.
default_to_json_operation
=
function
(
)
{
const
map
=
new
Map
(
)
let
isDefault
=
false
;
for
(
const
I
of
this
.
get_reverse_inheritance_stack
(
)
)
{
if
(
I
.
has_default_to_json_regular_operation
(
)
)
{
isDefault
=
true
;
for
(
const
m
of
I
.
members
)
{
if
(
m
.
special
!
=
=
"
static
"
&
&
m
.
type
=
=
"
attribute
"
&
&
I
.
array
.
is_json_type
(
m
.
idlType
)
)
{
map
.
set
(
m
.
name
m
.
idlType
)
;
}
}
}
else
if
(
I
.
has_to_json_regular_operation
(
)
)
{
isDefault
=
false
;
}
}
return
isDefault
?
map
:
null
;
}
;
IdlInterface
.
prototype
.
test
=
function
(
)
{
if
(
this
.
has_extended_attribute
(
"
LegacyNoInterfaceObject
"
)
|
|
this
.
is_mixin
(
)
)
{
return
;
}
if
(
!
this
.
exposed
)
{
if
(
!
this
.
untested
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_false
(
this
.
name
in
self
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
existence
and
properties
of
interface
object
"
)
;
}
return
;
}
if
(
!
this
.
untested
)
{
this
.
test_self
(
)
;
}
this
.
test_members
(
)
;
}
;
IdlInterface
.
prototype
.
constructors
=
function
(
)
{
return
this
.
members
.
filter
(
function
(
m
)
{
return
m
.
type
=
=
"
constructor
"
;
}
)
;
}
IdlInterface
.
prototype
.
test_self
=
function
(
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
if
(
!
this
.
should_have_interface_object
(
)
)
{
return
;
}
this
.
assert_interface_object_exists
(
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
this
.
get_interface_object_owner
(
)
this
.
name
)
;
assert_false
(
"
get
"
in
desc
"
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
should
not
have
a
setter
"
)
;
assert_true
(
desc
.
writable
"
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
should
be
writable
"
)
;
assert_false
(
desc
.
enumerable
"
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
"
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
should
be
configurable
"
)
;
if
(
this
.
is_callback
(
)
)
{
assert_equals
(
Object
.
getPrototypeOf
(
this
.
get_interface_object
(
)
)
Function
.
prototype
"
prototype
of
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
is
not
Object
.
prototype
"
)
;
return
;
}
assert_class_string
(
this
.
get_interface_object
(
)
"
Function
"
"
class
string
of
"
+
this
.
name
)
;
var
prototype
=
Object
.
getPrototypeOf
(
this
.
get_interface_object
(
)
)
;
if
(
this
.
base
)
{
var
inherited_interface
=
this
.
array
.
members
[
this
.
base
]
;
if
(
!
inherited_interface
.
has_extended_attribute
(
"
LegacyNoInterfaceObject
"
)
)
{
inherited_interface
.
assert_interface_object_exists
(
)
;
assert_equals
(
prototype
inherited_interface
.
get_interface_object
(
)
'
prototype
of
'
+
this
.
name
+
'
is
not
'
+
this
.
base
)
;
}
}
else
{
assert_equals
(
prototype
Function
.
prototype
"
prototype
of
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
is
not
Function
.
prototype
"
)
;
}
assert_true
(
isConstructor
(
this
.
get_interface_object
(
)
)
"
interface
object
must
pass
IsConstructor
check
"
)
;
var
interface_object
=
this
.
get_interface_object
(
)
;
assert_throws_js
(
globalOf
(
interface_object
)
.
TypeError
function
(
)
{
interface_object
(
)
;
}
"
interface
object
didn
'
t
throw
TypeError
when
called
as
a
function
"
)
;
if
(
!
this
.
constructors
(
)
.
length
)
{
assert_throws_js
(
globalOf
(
interface_object
)
.
TypeError
function
(
)
{
new
interface_object
(
)
;
}
"
interface
object
didn
'
t
throw
TypeError
when
called
as
a
constructor
"
)
;
}
}
.
bind
(
this
)
this
.
name
+
"
interface
:
existence
and
properties
of
interface
object
"
)
;
if
(
this
.
should_have_interface_object
(
)
&
&
!
this
.
is_callback
(
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
this
.
assert_interface_object_exists
(
)
;
assert_own_property
(
this
.
get_interface_object
(
)
"
length
"
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
this
.
get_interface_object
(
)
"
length
"
)
;
assert_false
(
"
get
"
in
desc
this
.
name
+
"
.
length
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
this
.
name
+
"
.
length
should
not
have
a
setter
"
)
;
assert_false
(
desc
.
writable
this
.
name
+
"
.
length
should
not
be
writable
"
)
;
assert_false
(
desc
.
enumerable
this
.
name
+
"
.
length
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
this
.
name
+
"
.
length
should
be
configurable
"
)
;
var
constructors
=
this
.
constructors
(
)
;
var
expected_length
=
minOverloadLength
(
constructors
)
;
assert_equals
(
this
.
get_interface_object
(
)
.
length
expected_length
"
wrong
value
for
"
+
this
.
name
+
"
.
length
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
object
length
"
)
;
}
if
(
this
.
should_have_interface_object
(
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
this
.
assert_interface_object_exists
(
)
;
assert_own_property
(
this
.
get_interface_object
(
)
"
name
"
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
this
.
get_interface_object
(
)
"
name
"
)
;
assert_false
(
"
get
"
in
desc
this
.
name
+
"
.
name
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
this
.
name
+
"
.
name
should
not
have
a
setter
"
)
;
assert_false
(
desc
.
writable
this
.
name
+
"
.
name
should
not
be
writable
"
)
;
assert_false
(
desc
.
enumerable
this
.
name
+
"
.
name
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
this
.
name
+
"
.
name
should
be
configurable
"
)
;
assert_equals
(
this
.
get_interface_object
(
)
.
name
this
.
name
"
wrong
value
for
"
+
this
.
name
+
"
.
name
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
object
name
"
)
;
}
if
(
this
.
has_extended_attribute
(
"
LegacyWindowAlias
"
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
aliasAttrs
=
this
.
extAttrs
.
filter
(
function
(
o
)
{
return
o
.
name
=
=
=
"
LegacyWindowAlias
"
;
}
)
;
if
(
aliasAttrs
.
length
>
1
)
{
throw
new
IdlHarnessError
(
"
Invalid
IDL
:
multiple
LegacyWindowAlias
extended
attributes
on
"
+
this
.
name
)
;
}
if
(
this
.
is_callback
(
)
)
{
throw
new
IdlHarnessError
(
"
Invalid
IDL
:
LegacyWindowAlias
extended
attribute
on
non
-
interface
"
+
this
.
name
)
;
}
if
(
!
(
this
.
exposureSet
=
=
=
"
*
"
|
|
this
.
exposureSet
.
has
(
"
Window
"
)
)
)
{
throw
new
IdlHarnessError
(
"
Invalid
IDL
:
LegacyWindowAlias
extended
attribute
on
"
+
this
.
name
+
"
which
is
not
exposed
in
Window
"
)
;
}
var
rhs
=
aliasAttrs
[
0
]
.
rhs
;
if
(
!
rhs
)
{
throw
new
IdlHarnessError
(
"
Invalid
IDL
:
LegacyWindowAlias
extended
attribute
on
"
+
this
.
name
+
"
without
identifier
"
)
;
}
var
aliases
;
if
(
rhs
.
type
=
=
=
"
identifier
-
list
"
)
{
aliases
=
rhs
.
value
.
map
(
id
=
>
id
.
value
)
;
}
else
{
aliases
=
[
rhs
.
value
]
;
}
var
alias
;
if
(
exposed_in
(
exposure_set
(
this
this
.
exposureSet
)
)
&
&
'
document
'
in
self
)
{
for
(
alias
of
aliases
)
{
assert_true
(
alias
in
self
alias
+
"
should
exist
"
)
;
assert_equals
(
self
[
alias
]
this
.
get_interface_object
(
)
"
self
.
"
+
alias
+
"
should
be
the
same
value
as
self
.
"
+
this
.
get_qualified_name
(
)
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
alias
)
;
assert_equals
(
desc
.
value
this
.
get_interface_object
(
)
"
wrong
value
in
"
+
alias
+
"
property
descriptor
"
)
;
assert_true
(
desc
.
writable
alias
+
"
should
be
writable
"
)
;
assert_false
(
desc
.
enumerable
alias
+
"
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
alias
+
"
should
be
configurable
"
)
;
assert_false
(
'
get
'
in
desc
alias
+
"
should
not
have
a
getter
"
)
;
assert_false
(
'
set
'
in
desc
alias
+
"
should
not
have
a
setter
"
)
;
}
}
else
{
for
(
alias
of
aliases
)
{
assert_false
(
alias
in
self
alias
+
"
should
not
exist
"
)
;
}
}
}
.
bind
(
this
)
this
.
name
+
"
interface
:
legacy
window
alias
"
)
;
}
if
(
this
.
has_extended_attribute
(
"
LegacyFactoryFunction
"
)
)
{
var
constructors
=
this
.
extAttrs
.
filter
(
function
(
attr
)
{
return
attr
.
name
=
=
"
LegacyFactoryFunction
"
;
}
)
;
if
(
constructors
.
length
!
=
=
1
)
{
throw
new
IdlHarnessError
(
"
Internal
error
:
missing
support
for
multiple
LegacyFactoryFunction
extended
attributes
"
)
;
}
var
constructor
=
constructors
[
0
]
;
var
min_length
=
minOverloadLength
(
[
constructor
]
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
name
=
constructor
.
rhs
.
value
;
assert_own_property
(
self
name
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
name
)
;
assert_equals
(
desc
.
value
self
[
name
]
"
wrong
value
in
"
+
name
+
"
property
descriptor
"
)
;
assert_true
(
desc
.
writable
name
+
"
should
be
writable
"
)
;
assert_false
(
desc
.
enumerable
name
+
"
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
name
+
"
should
be
configurable
"
)
;
assert_false
(
"
get
"
in
desc
name
+
"
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
name
+
"
should
not
have
a
setter
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
named
constructor
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
name
=
constructor
.
rhs
.
value
;
var
value
=
self
[
name
]
;
assert_equals
(
typeof
value
"
function
"
"
type
of
value
in
"
+
name
+
"
property
descriptor
"
)
;
assert_not_equals
(
value
this
.
get_interface_object
(
)
"
wrong
value
in
"
+
name
+
"
property
descriptor
"
)
;
assert_equals
(
Object
.
getPrototypeOf
(
value
)
Function
.
prototype
"
wrong
value
for
"
+
name
+
"
'
s
prototype
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
named
constructor
object
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
name
=
constructor
.
rhs
.
value
;
var
expected
=
this
.
get_interface_object
(
)
.
prototype
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
[
name
]
"
prototype
"
)
;
assert_equals
(
desc
.
value
expected
"
wrong
value
for
"
+
name
+
"
.
prototype
"
)
;
assert_false
(
desc
.
writable
"
prototype
should
not
be
writable
"
)
;
assert_false
(
desc
.
enumerable
"
prototype
should
not
be
enumerable
"
)
;
assert_false
(
desc
.
configurable
"
prototype
should
not
be
configurable
"
)
;
assert_false
(
"
get
"
in
desc
"
prototype
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
prototype
should
not
have
a
setter
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
named
constructor
prototype
property
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
name
=
constructor
.
rhs
.
value
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
[
name
]
"
name
"
)
;
assert_equals
(
desc
.
value
name
"
wrong
value
for
"
+
name
+
"
.
name
"
)
;
assert_false
(
desc
.
writable
"
name
should
not
be
writable
"
)
;
assert_false
(
desc
.
enumerable
"
name
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
"
name
should
be
configurable
"
)
;
assert_false
(
"
get
"
in
desc
"
name
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
name
should
not
have
a
setter
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
named
constructor
name
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
name
=
constructor
.
rhs
.
value
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
[
name
]
"
length
"
)
;
assert_equals
(
desc
.
value
min_length
"
wrong
value
for
"
+
name
+
"
.
length
"
)
;
assert_false
(
desc
.
writable
"
length
should
not
be
writable
"
)
;
assert_false
(
desc
.
enumerable
"
length
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
"
length
should
be
configurable
"
)
;
assert_false
(
"
get
"
in
desc
"
length
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
length
should
not
have
a
setter
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
named
constructor
length
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
name
=
constructor
.
rhs
.
value
;
var
args
=
constructor
.
arguments
.
map
(
function
(
arg
)
{
return
create_suitable_object
(
arg
.
idlType
)
;
}
)
;
assert_throws_js
(
globalOf
(
self
[
name
]
)
.
TypeError
function
(
)
{
self
[
name
]
(
.
.
.
args
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
named
constructor
without
'
new
'
"
)
;
}
subsetTestByKey
(
this
.
name
test
function
(
)
{
if
(
!
this
.
should_have_interface_object
(
)
)
{
return
;
}
this
.
assert_interface_object_exists
(
)
;
if
(
this
.
is_callback
(
)
)
{
assert_false
(
"
prototype
"
in
this
.
get_interface_object
(
)
this
.
name
+
'
should
not
have
a
"
prototype
"
property
'
)
;
return
;
}
assert_own_property
(
this
.
get_interface_object
(
)
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
this
.
get_interface_object
(
)
"
prototype
"
)
;
assert_false
(
"
get
"
in
desc
this
.
name
+
"
.
prototype
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
this
.
name
+
"
.
prototype
should
not
have
a
setter
"
)
;
assert_false
(
desc
.
writable
this
.
name
+
"
.
prototype
should
not
be
writable
"
)
;
assert_false
(
desc
.
enumerable
this
.
name
+
"
.
prototype
should
not
be
enumerable
"
)
;
assert_false
(
desc
.
configurable
this
.
name
+
"
.
prototype
should
not
be
configurable
"
)
;
if
(
this
.
name
=
=
=
"
Window
"
)
{
assert_class_string
(
Object
.
getPrototypeOf
(
this
.
get_interface_object
(
)
.
prototype
)
'
WindowProperties
'
'
Class
name
for
prototype
of
Window
'
+
'
.
prototype
is
not
"
WindowProperties
"
'
)
;
}
else
{
var
inherit_interface
inherit_interface_interface_object
;
if
(
this
.
base
)
{
inherit_interface
=
this
.
base
;
var
parent
=
this
.
array
.
members
[
inherit_interface
]
;
if
(
!
parent
.
has_extended_attribute
(
"
LegacyNoInterfaceObject
"
)
)
{
parent
.
assert_interface_object_exists
(
)
;
inherit_interface_interface_object
=
parent
.
get_interface_object
(
)
;
}
}
else
if
(
this
.
name
=
=
=
"
DOMException
"
)
{
inherit_interface
=
'
Error
'
;
inherit_interface_interface_object
=
self
.
Error
;
}
else
{
inherit_interface
=
'
Object
'
;
inherit_interface_interface_object
=
self
.
Object
;
}
if
(
inherit_interface_interface_object
)
{
assert_not_equals
(
inherit_interface_interface_object
undefined
'
should
inherit
from
'
+
inherit_interface
+
'
but
there
is
no
such
property
'
)
;
assert_own_property
(
inherit_interface_interface_object
'
prototype
'
'
should
inherit
from
'
+
inherit_interface
+
'
but
that
object
has
no
"
prototype
"
property
'
)
;
assert_equals
(
Object
.
getPrototypeOf
(
this
.
get_interface_object
(
)
.
prototype
)
inherit_interface_interface_object
.
prototype
'
prototype
of
'
+
this
.
name
+
'
.
prototype
is
not
'
+
inherit_interface
+
'
.
prototype
'
)
;
}
else
{
assert_class_string
(
Object
.
getPrototypeOf
(
this
.
get_interface_object
(
)
.
prototype
)
inherit_interface
+
'
Prototype
'
'
Class
name
for
prototype
of
'
+
this
.
name
+
'
.
prototype
is
not
"
'
+
inherit_interface
+
'
Prototype
"
'
)
;
}
}
if
(
!
this
.
has_stringifier
(
)
)
{
}
}
.
bind
(
this
)
this
.
name
+
"
interface
:
existence
and
properties
of
interface
prototype
object
"
)
;
if
(
this
.
is_global
(
)
)
{
this
.
test_immutable_prototype
(
"
interface
prototype
object
"
this
.
get_interface_object
(
)
.
prototype
)
;
}
subsetTestByKey
(
this
.
name
test
function
(
)
{
if
(
!
this
.
should_have_interface_object
(
)
)
{
return
;
}
this
.
assert_interface_object_exists
(
)
;
if
(
this
.
is_callback
(
)
)
{
assert_false
(
"
prototype
"
in
this
.
get_interface_object
(
)
this
.
name
+
'
should
not
have
a
"
prototype
"
property
'
)
;
return
;
}
assert_own_property
(
this
.
get_interface_object
(
)
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
assert_own_property
(
this
.
get_interface_object
(
)
.
prototype
"
constructor
"
this
.
name
+
'
.
prototype
does
not
have
own
property
"
constructor
"
'
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
this
.
get_interface_object
(
)
.
prototype
"
constructor
"
)
;
assert_false
(
"
get
"
in
desc
this
.
name
+
"
.
prototype
.
constructor
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
this
.
name
+
"
.
prototype
.
constructor
should
not
have
a
setter
"
)
;
assert_true
(
desc
.
writable
this
.
name
+
"
.
prototype
.
constructor
should
be
writable
"
)
;
assert_false
(
desc
.
enumerable
this
.
name
+
"
.
prototype
.
constructor
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
this
.
name
+
"
.
prototype
.
constructor
should
be
configurable
"
)
;
assert_equals
(
this
.
get_interface_object
(
)
.
prototype
.
constructor
this
.
get_interface_object
(
)
this
.
name
+
'
.
prototype
.
constructor
is
not
the
same
object
as
'
+
this
.
name
)
;
}
.
bind
(
this
)
this
.
name
+
'
interface
:
existence
and
properties
of
interface
prototype
object
\
'
s
"
constructor
"
property
'
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
if
(
!
this
.
should_have_interface_object
(
)
)
{
return
;
}
this
.
assert_interface_object_exists
(
)
;
if
(
this
.
is_callback
(
)
)
{
assert_false
(
"
prototype
"
in
this
.
get_interface_object
(
)
this
.
name
+
'
should
not
have
a
"
prototype
"
property
'
)
;
return
;
}
assert_own_property
(
this
.
get_interface_object
(
)
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
var
unscopables
=
this
.
get_unscopables
(
)
.
map
(
m
=
>
m
.
name
)
;
var
proto
=
this
.
get_interface_object
(
)
.
prototype
;
if
(
unscopables
.
length
!
=
0
)
{
assert_own_property
(
proto
Symbol
.
unscopables
this
.
name
+
'
.
prototype
should
have
an
unscopables
property
'
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
proto
Symbol
.
unscopables
)
;
assert_false
(
"
get
"
in
desc
this
.
name
+
"
.
prototype
[
Symbol
.
unscopables
]
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
this
.
name
+
"
.
prototype
[
Symbol
.
unscopables
]
should
not
have
a
setter
"
)
;
assert_false
(
desc
.
writable
this
.
name
+
"
.
prototype
[
Symbol
.
unscopables
]
should
not
be
writable
"
)
;
assert_false
(
desc
.
enumerable
this
.
name
+
"
.
prototype
[
Symbol
.
unscopables
]
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
this
.
name
+
"
.
prototype
[
Symbol
.
unscopables
]
should
be
configurable
"
)
;
assert_equals
(
desc
.
value
proto
[
Symbol
.
unscopables
]
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
should
be
in
the
descriptor
'
)
;
assert_equals
(
typeof
desc
.
value
"
object
"
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
should
be
an
object
'
)
;
assert_equals
(
Object
.
getPrototypeOf
(
desc
.
value
)
null
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
should
have
a
null
prototype
'
)
;
assert_equals
(
Object
.
getOwnPropertySymbols
(
desc
.
value
)
.
length
0
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
should
have
the
right
number
of
symbol
-
named
properties
'
)
;
var
observed
=
Object
.
getOwnPropertyNames
(
desc
.
value
)
;
for
(
var
prop
of
observed
)
{
assert_not_equals
(
unscopables
.
indexOf
(
prop
)
-
1
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
has
unexpected
property
"
'
+
prop
+
'
"
'
)
;
}
}
else
{
assert_equals
(
Object
.
getOwnPropertyDescriptor
(
this
.
get_interface_object
(
)
.
prototype
Symbol
.
unscopables
)
undefined
this
.
name
+
'
.
prototype
should
not
have
unscopables
'
)
;
}
}
.
bind
(
this
)
this
.
name
+
'
interface
:
existence
and
properties
of
interface
prototype
object
\
'
s
unscopables
property
'
)
;
}
;
IdlInterface
.
prototype
.
test_immutable_prototype
=
function
(
type
obj
)
{
if
(
typeof
Object
.
setPrototypeOf
!
=
=
"
function
"
)
{
return
;
}
subsetTestByKey
(
this
.
name
test
function
(
t
)
{
var
originalValue
=
Object
.
getPrototypeOf
(
obj
)
;
var
newValue
=
Object
.
create
(
null
)
;
t
.
add_cleanup
(
function
(
)
{
try
{
Object
.
setPrototypeOf
(
obj
originalValue
)
;
}
catch
(
err
)
{
}
}
)
;
assert_throws_js
(
TypeError
function
(
)
{
Object
.
setPrototypeOf
(
obj
newValue
)
;
}
)
;
assert_equals
(
Object
.
getPrototypeOf
(
obj
)
originalValue
"
original
value
not
modified
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
internal
[
[
SetPrototypeOf
]
]
method
"
+
"
of
"
+
type
+
"
-
setting
to
a
new
value
via
Object
.
setPrototypeOf
"
+
"
should
throw
a
TypeError
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
t
)
{
var
originalValue
=
Object
.
getPrototypeOf
(
obj
)
;
var
newValue
=
Object
.
create
(
null
)
;
t
.
add_cleanup
(
function
(
)
{
let
setter
=
Object
.
getOwnPropertyDescriptor
(
Object
.
prototype
'
__proto__
'
)
.
set
;
try
{
setter
.
call
(
obj
originalValue
)
;
}
catch
(
err
)
{
}
}
)
;
let
setter
;
{
let
cur
=
obj
;
while
(
cur
)
{
const
desc
=
Object
.
getOwnPropertyDescriptor
(
cur
"
__proto__
"
)
;
if
(
desc
)
{
setter
=
desc
.
set
;
break
;
}
cur
=
Object
.
getPrototypeOf
(
cur
)
;
}
}
assert_throws_js
(
globalOf
(
setter
)
.
TypeError
function
(
)
{
obj
.
__proto__
=
newValue
;
}
)
;
assert_equals
(
Object
.
getPrototypeOf
(
obj
)
originalValue
"
original
value
not
modified
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
internal
[
[
SetPrototypeOf
]
]
method
"
+
"
of
"
+
type
+
"
-
setting
to
a
new
value
via
__proto__
"
+
"
should
throw
a
TypeError
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
t
)
{
var
originalValue
=
Object
.
getPrototypeOf
(
obj
)
;
var
newValue
=
Object
.
create
(
null
)
;
t
.
add_cleanup
(
function
(
)
{
try
{
Reflect
.
setPrototypeOf
(
obj
originalValue
)
;
}
catch
(
err
)
{
}
}
)
;
assert_false
(
Reflect
.
setPrototypeOf
(
obj
newValue
)
)
;
assert_equals
(
Object
.
getPrototypeOf
(
obj
)
originalValue
"
original
value
not
modified
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
internal
[
[
SetPrototypeOf
]
]
method
"
+
"
of
"
+
type
+
"
-
setting
to
a
new
value
via
Reflect
.
setPrototypeOf
"
+
"
should
return
false
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
originalValue
=
Object
.
getPrototypeOf
(
obj
)
;
Object
.
setPrototypeOf
(
obj
originalValue
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
internal
[
[
SetPrototypeOf
]
]
method
"
+
"
of
"
+
type
+
"
-
setting
to
its
original
value
via
Object
.
setPrototypeOf
"
+
"
should
not
throw
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
originalValue
=
Object
.
getPrototypeOf
(
obj
)
;
obj
.
__proto__
=
originalValue
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
internal
[
[
SetPrototypeOf
]
]
method
"
+
"
of
"
+
type
+
"
-
setting
to
its
original
value
via
__proto__
"
+
"
should
not
throw
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
originalValue
=
Object
.
getPrototypeOf
(
obj
)
;
assert_true
(
Reflect
.
setPrototypeOf
(
obj
originalValue
)
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
internal
[
[
SetPrototypeOf
]
]
method
"
+
"
of
"
+
type
+
"
-
setting
to
its
original
value
via
Reflect
.
setPrototypeOf
"
+
"
should
return
true
"
)
;
}
;
IdlInterface
.
prototype
.
test_member_const
=
function
(
member
)
{
if
(
!
this
.
has_constants
(
)
)
{
throw
new
IdlHarnessError
(
"
Internal
error
:
test_member_const
called
without
any
constants
"
)
;
}
subsetTestByKey
(
this
.
name
test
function
(
)
{
this
.
assert_interface_object_exists
(
)
;
assert_own_property
(
this
.
get_interface_object
(
)
member
.
name
)
;
assert_equals
(
this
.
get_interface_object
(
)
[
member
.
name
]
constValue
(
member
.
value
)
"
property
has
wrong
value
"
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
this
.
get_interface_object
(
)
member
.
name
)
;
assert_false
(
"
get
"
in
desc
"
property
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
property
should
not
have
a
setter
"
)
;
assert_false
(
desc
.
writable
"
property
should
not
be
writable
"
)
;
assert_true
(
desc
.
enumerable
"
property
should
be
enumerable
"
)
;
assert_false
(
desc
.
configurable
"
property
should
not
be
configurable
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
constant
"
+
member
.
name
+
"
on
interface
object
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
this
.
assert_interface_object_exists
(
)
;
if
(
this
.
is_callback
(
)
)
{
assert_false
(
"
prototype
"
in
this
.
get_interface_object
(
)
this
.
name
+
'
should
not
have
a
"
prototype
"
property
'
)
;
return
;
}
assert_own_property
(
this
.
get_interface_object
(
)
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
assert_own_property
(
this
.
get_interface_object
(
)
.
prototype
member
.
name
)
;
assert_equals
(
this
.
get_interface_object
(
)
.
prototype
[
member
.
name
]
constValue
(
member
.
value
)
"
property
has
wrong
value
"
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
this
.
get_interface_object
(
)
member
.
name
)
;
assert_false
(
"
get
"
in
desc
"
property
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
property
should
not
have
a
setter
"
)
;
assert_false
(
desc
.
writable
"
property
should
not
be
writable
"
)
;
assert_true
(
desc
.
enumerable
"
property
should
be
enumerable
"
)
;
assert_false
(
desc
.
configurable
"
property
should
not
be
configurable
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
constant
"
+
member
.
name
+
"
on
interface
prototype
object
"
)
;
}
;
IdlInterface
.
prototype
.
test_member_attribute
=
function
(
member
)
{
if
(
!
shouldRunSubTest
(
this
.
name
)
)
{
return
;
}
var
a_test
=
subsetTestByKey
(
this
.
name
async_test
this
.
name
+
"
interface
:
attribute
"
+
member
.
name
)
;
a_test
.
step
(
function
(
)
{
if
(
!
this
.
should_have_interface_object
(
)
)
{
a_test
.
done
(
)
;
return
;
}
this
.
assert_interface_object_exists
(
)
;
assert_own_property
(
this
.
get_interface_object
(
)
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
if
(
member
.
special
=
=
=
"
static
"
)
{
assert_own_property
(
this
.
get_interface_object
(
)
member
.
name
"
The
interface
object
must
have
a
property
"
+
format_value
(
member
.
name
)
)
;
a_test
.
done
(
)
;
return
;
}
this
.
do_member_unscopable_asserts
(
member
)
;
if
(
this
.
is_global
(
)
)
{
assert_own_property
(
self
member
.
name
"
The
global
object
must
have
a
property
"
+
format_value
(
member
.
name
)
)
;
assert_false
(
member
.
name
in
this
.
get_interface_object
(
)
.
prototype
"
The
prototype
object
should
not
have
a
property
"
+
format_value
(
member
.
name
)
)
;
var
getter
=
Object
.
getOwnPropertyDescriptor
(
self
member
.
name
)
.
get
;
assert_equals
(
typeof
(
getter
)
"
function
"
format_value
(
member
.
name
)
+
"
must
have
a
getter
"
)
;
var
gotValue
;
var
propVal
;
try
{
propVal
=
self
[
member
.
name
]
;
gotValue
=
true
;
}
catch
(
e
)
{
gotValue
=
false
;
}
if
(
gotValue
)
{
assert_equals
(
propVal
getter
.
call
(
undefined
)
"
Gets
on
a
global
should
not
require
an
explicit
this
"
)
;
}
this
.
do_interface_attribute_asserts
(
self
member
a_test
)
;
}
else
{
assert_true
(
member
.
name
in
this
.
get_interface_object
(
)
.
prototype
"
The
prototype
object
must
have
a
property
"
+
format_value
(
member
.
name
)
)
;
if
(
!
member
.
has_extended_attribute
(
"
LegacyLenientThis
"
)
)
{
if
(
member
.
idlType
.
generic
!
=
=
"
Promise
"
)
{
assert_throws_js
(
TypeError
function
(
)
{
this
.
get_interface_object
(
)
.
prototype
[
member
.
name
]
;
}
.
bind
(
this
)
"
getting
property
on
prototype
object
must
throw
TypeError
"
)
;
this
.
do_interface_attribute_asserts
(
this
.
get_interface_object
(
)
.
prototype
member
a_test
)
;
}
else
{
promise_rejects_js
(
a_test
TypeError
this
.
get_interface_object
(
)
.
prototype
[
member
.
name
]
)
.
then
(
a_test
.
step_func
(
function
(
)
{
this
.
do_interface_attribute_asserts
(
this
.
get_interface_object
(
)
.
prototype
member
a_test
)
;
}
.
bind
(
this
)
)
)
;
}
}
else
{
assert_equals
(
this
.
get_interface_object
(
)
.
prototype
[
member
.
name
]
undefined
"
getting
property
on
prototype
object
must
return
undefined
"
)
;
this
.
do_interface_attribute_asserts
(
this
.
get_interface_object
(
)
.
prototype
member
a_test
)
;
}
}
}
.
bind
(
this
)
)
;
}
;
IdlInterface
.
prototype
.
test_member_operation
=
function
(
member
)
{
if
(
!
shouldRunSubTest
(
this
.
name
)
)
{
return
;
}
var
a_test
=
subsetTestByKey
(
this
.
name
async_test
this
.
name
+
"
interface
:
operation
"
+
member
)
;
a_test
.
step
(
function
(
)
{
if
(
!
this
.
should_have_interface_object
(
)
)
{
a_test
.
done
(
)
;
return
;
}
this
.
assert_interface_object_exists
(
)
;
if
(
this
.
is_callback
(
)
)
{
assert_false
(
"
prototype
"
in
this
.
get_interface_object
(
)
this
.
name
+
'
should
not
have
a
"
prototype
"
property
'
)
;
a_test
.
done
(
)
;
return
;
}
assert_own_property
(
this
.
get_interface_object
(
)
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
var
memberHolderObject
;
if
(
member
.
special
=
=
=
"
static
"
)
{
assert_own_property
(
this
.
get_interface_object
(
)
member
.
name
"
interface
object
missing
static
operation
"
)
;
memberHolderObject
=
this
.
get_interface_object
(
)
;
}
else
if
(
this
.
is_global
(
)
)
{
assert_own_property
(
self
member
.
name
"
global
object
missing
non
-
static
operation
"
)
;
memberHolderObject
=
self
;
}
else
{
assert_own_property
(
this
.
get_interface_object
(
)
.
prototype
member
.
name
"
interface
prototype
object
missing
non
-
static
operation
"
)
;
memberHolderObject
=
this
.
get_interface_object
(
)
.
prototype
;
}
this
.
do_member_unscopable_asserts
(
member
)
;
this
.
do_member_operation_asserts
(
memberHolderObject
member
a_test
)
;
}
.
bind
(
this
)
)
;
}
;
IdlInterface
.
prototype
.
do_member_unscopable_asserts
=
function
(
member
)
{
if
(
!
member
.
isUnscopable
)
{
return
;
}
var
unscopables
=
this
.
get_interface_object
(
)
.
prototype
[
Symbol
.
unscopables
]
;
var
prop
=
member
.
name
;
var
propDesc
=
Object
.
getOwnPropertyDescriptor
(
unscopables
prop
)
;
assert_equals
(
typeof
propDesc
"
object
"
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
exist
'
)
assert_false
(
"
get
"
in
propDesc
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
have
no
getter
'
)
;
assert_false
(
"
set
"
in
propDesc
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
have
no
setter
'
)
;
assert_true
(
propDesc
.
writable
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
be
writable
'
)
;
assert_true
(
propDesc
.
enumerable
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
be
enumerable
'
)
;
assert_true
(
propDesc
.
configurable
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
be
configurable
'
)
;
assert_equals
(
propDesc
.
value
true
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
have
the
value
true
'
)
;
}
;
IdlInterface
.
prototype
.
do_member_operation_asserts
=
function
(
memberHolderObject
member
a_test
)
{
var
done
=
a_test
.
done
.
bind
(
a_test
)
;
var
operationUnforgeable
=
member
.
isUnforgeable
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
memberHolderObject
member
.
name
)
;
assert_false
(
"
get
"
in
desc
"
property
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
property
should
not
have
a
setter
"
)
;
assert_equals
(
desc
.
writable
!
operationUnforgeable
"
property
should
be
writable
if
and
only
if
not
unforgeable
"
)
;
assert_true
(
desc
.
enumerable
"
property
should
be
enumerable
"
)
;
assert_equals
(
desc
.
configurable
!
operationUnforgeable
"
property
should
be
configurable
if
and
only
if
not
unforgeable
"
)
;
assert_equals
(
typeof
memberHolderObject
[
member
.
name
]
"
function
"
"
property
must
be
a
function
"
)
;
const
ctors
=
this
.
members
.
filter
(
function
(
m
)
{
return
m
.
type
=
=
"
operation
"
&
&
m
.
name
=
=
member
.
name
;
}
)
;
assert_equals
(
memberHolderObject
[
member
.
name
]
.
length
minOverloadLength
(
ctors
)
"
property
has
wrong
.
length
"
)
;
assert_equals
(
memberHolderObject
[
member
.
name
]
.
name
member
.
name
"
property
has
wrong
.
name
"
)
;
var
args
=
member
.
arguments
.
map
(
function
(
arg
)
{
return
create_suitable_object
(
arg
.
idlType
)
;
}
)
;
if
(
member
.
special
!
=
=
"
static
"
)
{
var
cb
;
if
(
!
this
.
is_global
(
)
&
&
memberHolderObject
[
member
.
name
]
!
=
self
[
member
.
name
]
)
{
cb
=
awaitNCallbacks
(
2
done
)
;
throwOrReject
(
a_test
member
memberHolderObject
[
member
.
name
]
null
args
"
calling
operation
with
this
=
null
didn
'
t
throw
TypeError
"
cb
)
;
}
else
{
cb
=
awaitNCallbacks
(
1
done
)
;
}
throwOrReject
(
a_test
member
memberHolderObject
[
member
.
name
]
{
}
args
"
calling
operation
with
this
=
{
}
didn
'
t
throw
TypeError
"
cb
)
;
}
else
{
done
(
)
;
}
}
IdlInterface
.
prototype
.
test_to_json_operation
=
function
(
desc
memberHolderObject
member
)
{
var
instanceName
=
memberHolderObject
&
&
memberHolderObject
.
constructor
.
name
|
|
member
.
name
+
"
object
"
;
if
(
member
.
has_extended_attribute
(
"
Default
"
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
map
=
this
.
default_to_json_operation
(
)
;
var
json
=
memberHolderObject
.
toJSON
(
)
;
map
.
forEach
(
function
(
type
k
)
{
assert_true
(
k
in
json
"
property
"
+
JSON
.
stringify
(
k
)
+
"
should
be
present
in
the
output
of
"
+
this
.
name
+
"
.
prototype
.
toJSON
(
)
"
)
;
var
descriptor
=
Object
.
getOwnPropertyDescriptor
(
json
k
)
;
assert_true
(
descriptor
.
writable
"
property
"
+
k
+
"
should
be
writable
"
)
;
assert_true
(
descriptor
.
configurable
"
property
"
+
k
+
"
should
be
configurable
"
)
;
assert_true
(
descriptor
.
enumerable
"
property
"
+
k
+
"
should
be
enumerable
"
)
;
this
.
array
.
assert_type_is
(
json
[
k
]
type
)
;
delete
json
[
k
]
;
}
this
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
default
toJSON
operation
on
"
+
desc
)
;
}
else
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_true
(
this
.
array
.
is_json_type
(
member
.
idlType
)
JSON
.
stringify
(
member
.
idlType
)
+
"
is
not
an
appropriate
return
value
for
the
toJSON
operation
of
"
+
instanceName
)
;
this
.
array
.
assert_type_is
(
memberHolderObject
.
toJSON
(
)
member
.
idlType
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
toJSON
operation
on
"
+
desc
)
;
}
}
;
IdlInterface
.
prototype
.
test_member_maplike
=
function
(
member
)
{
subsetTestByKey
(
this
.
name
test
(
)
=
>
{
const
proto
=
this
.
get_interface_object
(
)
.
prototype
;
const
methods
=
[
[
"
entries
"
0
]
[
"
keys
"
0
]
[
"
values
"
0
]
[
"
forEach
"
1
]
[
"
get
"
1
]
[
"
has
"
1
]
]
;
if
(
!
member
.
readonly
)
{
methods
.
push
(
[
"
set
"
2
]
[
"
delete
"
1
]
[
"
clear
"
1
]
)
;
}
for
(
const
[
name
length
]
of
methods
)
{
const
desc
=
Object
.
getOwnPropertyDescriptor
(
proto
name
)
;
assert_equals
(
typeof
desc
.
value
"
function
"
{
name
}
should
be
a
function
)
;
assert_equals
(
desc
.
enumerable
true
{
name
}
enumerable
)
;
assert_equals
(
desc
.
configurable
true
{
name
}
configurable
)
;
assert_equals
(
desc
.
writable
true
{
name
}
writable
)
;
assert_equals
(
desc
.
value
.
length
length
{
name
}
function
object
length
should
be
{
length
}
)
;
assert_equals
(
desc
.
value
.
name
name
{
name
}
function
object
should
have
the
right
name
)
;
}
const
iteratorDesc
=
Object
.
getOwnPropertyDescriptor
(
proto
Symbol
.
iterator
)
;
assert_equals
(
iteratorDesc
.
value
proto
.
entries
iterator
should
equal
entries
)
;
assert_equals
(
iteratorDesc
.
enumerable
false
iterator
enumerable
)
;
assert_equals
(
iteratorDesc
.
configurable
true
iterator
configurable
)
;
assert_equals
(
iteratorDesc
.
writable
true
iterator
writable
)
;
const
sizeDesc
=
Object
.
getOwnPropertyDescriptor
(
proto
"
size
"
)
;
assert_equals
(
typeof
sizeDesc
.
get
"
function
"
size
getter
should
be
a
function
)
;
assert_equals
(
sizeDesc
.
set
undefined
size
should
not
have
a
setter
)
;
assert_equals
(
sizeDesc
.
enumerable
true
size
enumerable
)
;
assert_equals
(
sizeDesc
.
configurable
true
size
configurable
)
;
assert_equals
(
sizeDesc
.
get
.
length
0
size
getter
length
should
have
the
right
length
)
;
assert_equals
(
sizeDesc
.
get
.
name
"
get
size
"
size
getter
have
the
right
name
)
;
}
{
this
.
name
}
interface
:
maplike
<
{
member
.
idlType
.
map
(
t
=
>
t
.
idlType
)
.
join
(
"
"
)
}
>
)
;
}
;
IdlInterface
.
prototype
.
test_member_setlike
=
function
(
member
)
{
subsetTestByKey
(
this
.
name
test
(
)
=
>
{
const
proto
=
this
.
get_interface_object
(
)
.
prototype
;
const
methods
=
[
[
"
entries
"
0
]
[
"
keys
"
0
]
[
"
values
"
0
]
[
"
forEach
"
1
]
[
"
has
"
1
]
]
;
if
(
!
member
.
readonly
)
{
methods
.
push
(
[
"
add
"
1
]
[
"
delete
"
1
]
[
"
clear
"
1
]
)
;
}
for
(
const
[
name
length
]
of
methods
)
{
const
desc
=
Object
.
getOwnPropertyDescriptor
(
proto
name
)
;
assert_equals
(
typeof
desc
.
value
"
function
"
{
name
}
should
be
a
function
)
;
assert_equals
(
desc
.
enumerable
true
{
name
}
enumerable
)
;
assert_equals
(
desc
.
configurable
true
{
name
}
configurable
)
;
assert_equals
(
desc
.
writable
true
{
name
}
writable
)
;
assert_equals
(
desc
.
value
.
length
length
{
name
}
function
object
length
should
be
{
length
}
)
;
assert_equals
(
desc
.
value
.
name
name
{
name
}
function
object
should
have
the
right
name
)
;
}
const
iteratorDesc
=
Object
.
getOwnPropertyDescriptor
(
proto
Symbol
.
iterator
)
;
assert_equals
(
iteratorDesc
.
value
proto
.
values
iterator
should
equal
values
)
;
assert_equals
(
iteratorDesc
.
enumerable
false
iterator
enumerable
)
;
assert_equals
(
iteratorDesc
.
configurable
true
iterator
configurable
)
;
assert_equals
(
iteratorDesc
.
writable
true
iterator
writable
)
;
const
sizeDesc
=
Object
.
getOwnPropertyDescriptor
(
proto
"
size
"
)
;
assert_equals
(
typeof
sizeDesc
.
get
"
function
"
size
getter
should
be
a
function
)
;
assert_equals
(
sizeDesc
.
set
undefined
size
should
not
have
a
setter
)
;
assert_equals
(
sizeDesc
.
enumerable
true
size
enumerable
)
;
assert_equals
(
sizeDesc
.
configurable
true
size
configurable
)
;
assert_equals
(
sizeDesc
.
get
.
length
0
size
getter
length
should
have
the
right
length
)
;
assert_equals
(
sizeDesc
.
get
.
name
"
size
"
size
getter
have
the
right
name
)
;
}
{
this
.
name
}
interface
:
setlike
<
{
member
.
idlType
.
map
(
t
=
>
t
.
idlType
)
.
join
(
"
"
)
}
>
)
;
}
;
IdlInterface
.
prototype
.
test_member_iterable
=
function
(
member
)
{
subsetTestByKey
(
this
.
name
test
(
)
=
>
{
const
isPairIterator
=
member
.
idlType
.
length
=
=
=
2
;
const
proto
=
this
.
get_interface_object
(
)
.
prototype
;
const
methods
=
[
[
"
entries
"
0
]
[
"
keys
"
0
]
[
"
values
"
0
]
[
"
forEach
"
1
]
]
;
for
(
const
[
name
length
]
of
methods
)
{
const
desc
=
Object
.
getOwnPropertyDescriptor
(
proto
name
)
;
assert_equals
(
typeof
desc
.
value
"
function
"
{
name
}
should
be
a
function
)
;
assert_equals
(
desc
.
enumerable
true
{
name
}
enumerable
)
;
assert_equals
(
desc
.
configurable
true
{
name
}
configurable
)
;
assert_equals
(
desc
.
writable
true
{
name
}
writable
)
;
assert_equals
(
desc
.
value
.
length
length
{
name
}
function
object
length
should
be
{
length
}
)
;
assert_equals
(
desc
.
value
.
name
name
{
name
}
function
object
should
have
the
right
name
)
;
if
(
!
isPairIterator
)
{
assert_equals
(
desc
.
value
Array
.
prototype
[
name
]
{
name
}
equality
with
Array
.
prototype
version
)
;
}
}
const
iteratorDesc
=
Object
.
getOwnPropertyDescriptor
(
proto
Symbol
.
iterator
)
;
assert_equals
(
iteratorDesc
.
enumerable
false
iterator
enumerable
)
;
assert_equals
(
iteratorDesc
.
configurable
true
iterator
configurable
)
;
assert_equals
(
iteratorDesc
.
writable
true
iterator
writable
)
;
if
(
isPairIterator
)
{
assert_equals
(
iteratorDesc
.
value
proto
.
entries
iterator
equality
with
entries
)
;
}
else
{
assert_equals
(
iteratorDesc
.
value
Array
.
prototype
[
Symbol
.
iterator
]
iterator
equality
with
Array
.
prototype
version
)
;
}
}
{
this
.
name
}
interface
:
iterable
<
{
member
.
idlType
.
map
(
t
=
>
t
.
idlType
)
.
join
(
"
"
)
}
>
)
;
}
;
IdlInterface
.
prototype
.
test_member_async_iterable
=
function
(
member
)
{
subsetTestByKey
(
this
.
name
test
(
)
=
>
{
const
isPairIterator
=
member
.
idlType
.
length
=
=
=
2
;
const
proto
=
this
.
get_interface_object
(
)
.
prototype
;
const
methods
=
[
[
"
values
"
0
]
]
;
if
(
isPairIterator
)
{
methods
.
push
(
[
"
entries
"
0
]
[
"
keys
"
0
]
)
;
}
for
(
const
[
name
length
]
of
methods
)
{
const
desc
=
Object
.
getOwnPropertyDescriptor
(
proto
name
)
;
assert_equals
(
typeof
desc
.
value
"
function
"
{
name
}
should
be
a
function
)
;
assert_equals
(
desc
.
enumerable
true
{
name
}
enumerable
)
;
assert_equals
(
desc
.
configurable
true
{
name
}
configurable
)
;
assert_equals
(
desc
.
writable
true
{
name
}
writable
)
;
assert_equals
(
desc
.
value
.
length
length
{
name
}
function
object
length
should
be
{
length
}
)
;
assert_equals
(
desc
.
value
.
name
name
{
name
}
function
object
should
have
the
right
name
)
;
}
const
iteratorDesc
=
Object
.
getOwnPropertyDescriptor
(
proto
Symbol
.
asyncIterator
)
;
assert_equals
(
iteratorDesc
.
enumerable
false
iterator
enumerable
)
;
assert_equals
(
iteratorDesc
.
configurable
true
iterator
configurable
)
;
assert_equals
(
iteratorDesc
.
writable
true
iterator
writable
)
;
if
(
isPairIterator
)
{
assert_equals
(
iteratorDesc
.
value
proto
.
entries
iterator
equality
with
entries
)
;
}
else
{
assert_equals
(
iteratorDesc
.
value
proto
.
values
iterator
equality
with
values
)
;
}
}
{
this
.
name
}
interface
:
async
iterable
<
{
member
.
idlType
.
map
(
t
=
>
t
.
idlType
)
.
join
(
"
"
)
}
>
)
;
}
;
IdlInterface
.
prototype
.
test_member_stringifier
=
function
(
member
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
if
(
!
this
.
should_have_interface_object
(
)
)
{
return
;
}
this
.
assert_interface_object_exists
(
)
;
if
(
this
.
is_callback
(
)
)
{
assert_false
(
"
prototype
"
in
this
.
get_interface_object
(
)
this
.
name
+
'
should
not
have
a
"
prototype
"
property
'
)
;
return
;
}
assert_own_property
(
this
.
get_interface_object
(
)
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
var
interfacePrototypeObject
=
this
.
get_interface_object
(
)
.
prototype
;
assert_own_property
(
interfacePrototypeObject
"
toString
"
"
interface
prototype
object
missing
non
-
static
operation
"
)
;
var
stringifierUnforgeable
=
member
.
isUnforgeable
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
interfacePrototypeObject
"
toString
"
)
;
assert_false
(
"
get
"
in
desc
"
property
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
property
should
not
have
a
setter
"
)
;
assert_equals
(
desc
.
writable
!
stringifierUnforgeable
"
property
should
be
writable
if
and
only
if
not
unforgeable
"
)
;
assert_true
(
desc
.
enumerable
"
property
should
be
enumerable
"
)
;
assert_equals
(
desc
.
configurable
!
stringifierUnforgeable
"
property
should
be
configurable
if
and
only
if
not
unforgeable
"
)
;
assert_equals
(
typeof
interfacePrototypeObject
.
toString
"
function
"
"
property
must
be
a
function
"
)
;
assert_equals
(
interfacePrototypeObject
.
toString
.
length
0
"
property
has
wrong
.
length
"
)
;
assert_throws_js
(
globalOf
(
interfacePrototypeObject
.
toString
)
.
TypeError
function
(
)
{
interfacePrototypeObject
.
toString
.
apply
(
null
[
]
)
;
}
"
calling
stringifier
with
this
=
null
didn
'
t
throw
TypeError
"
)
;
assert_throws_js
(
globalOf
(
interfacePrototypeObject
.
toString
)
.
TypeError
function
(
)
{
interfacePrototypeObject
.
toString
.
apply
(
{
}
[
]
)
;
}
"
calling
stringifier
with
this
=
{
}
didn
'
t
throw
TypeError
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
stringifier
"
)
;
}
;
IdlInterface
.
prototype
.
test_members
=
function
(
)
{
for
(
var
i
=
0
;
i
<
this
.
members
.
length
;
i
+
+
)
{
var
member
=
this
.
members
[
i
]
;
if
(
member
.
untested
)
{
continue
;
}
if
(
!
exposed_in
(
exposure_set
(
member
this
.
exposureSet
)
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_false
(
member
.
name
in
this
.
get_interface_object
(
)
"
The
interface
object
must
not
have
a
property
"
+
format_value
(
member
.
name
)
)
;
assert_false
(
member
.
name
in
this
.
get_interface_object
(
)
.
prototype
"
The
prototype
object
must
not
have
a
property
"
+
format_value
(
member
.
name
)
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
member
"
+
member
.
name
)
;
continue
;
}
switch
(
member
.
type
)
{
case
"
const
"
:
this
.
test_member_const
(
member
)
;
break
;
case
"
attribute
"
:
if
(
!
member
.
isUnforgeable
)
{
this
.
test_member_attribute
(
member
)
;
}
if
(
member
.
special
=
=
=
"
stringifier
"
)
{
this
.
test_member_stringifier
(
member
)
;
}
break
;
case
"
operation
"
:
if
(
member
.
name
)
{
if
(
!
member
.
isUnforgeable
)
{
this
.
test_member_operation
(
member
)
;
}
}
else
if
(
member
.
special
=
=
=
"
stringifier
"
)
{
this
.
test_member_stringifier
(
member
)
;
}
break
;
case
"
iterable
"
:
if
(
member
.
async
)
{
this
.
test_member_async_iterable
(
member
)
;
}
else
{
this
.
test_member_iterable
(
member
)
;
}
break
;
case
"
maplike
"
:
this
.
test_member_maplike
(
member
)
;
break
;
case
"
setlike
"
:
this
.
test_member_setlike
(
member
)
;
break
;
default
:
break
;
}
}
}
;
IdlInterface
.
prototype
.
test_object
=
function
(
desc
)
{
var
obj
exception
=
null
;
try
{
obj
=
eval
(
desc
)
;
}
catch
(
e
)
{
exception
=
e
;
}
var
expected_typeof
;
if
(
this
.
name
=
=
"
HTMLAllCollection
"
)
{
expected_typeof
=
"
undefined
"
;
}
else
{
expected_typeof
=
"
object
"
;
}
this
.
test_primary_interface_of
(
desc
obj
exception
expected_typeof
)
;
var
current_interface
=
this
;
while
(
current_interface
)
{
if
(
!
(
current_interface
.
name
in
this
.
array
.
members
)
)
{
throw
new
IdlHarnessError
(
"
Interface
"
+
current_interface
.
name
+
"
not
found
(
inherited
by
"
+
this
.
name
+
"
)
"
)
;
}
if
(
current_interface
.
prevent_multiple_testing
&
&
current_interface
.
already_tested
)
{
return
;
}
current_interface
.
test_interface_of
(
desc
obj
exception
expected_typeof
)
;
current_interface
=
this
.
array
.
members
[
current_interface
.
base
]
;
}
}
;
IdlInterface
.
prototype
.
test_primary_interface_of
=
function
(
desc
obj
exception
expected_typeof
)
{
if
(
this
.
untested
)
{
return
;
}
if
(
this
.
is_global
(
)
)
{
this
.
test_immutable_prototype
(
"
global
platform
object
"
obj
)
;
}
if
(
this
.
should_have_interface_object
(
)
&
&
(
typeof
obj
!
=
expected_typeof
|
|
obj
instanceof
Object
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_equals
(
typeof
obj
expected_typeof
"
wrong
typeof
object
"
)
;
this
.
assert_interface_object_exists
(
)
;
assert_own_property
(
this
.
get_interface_object
(
)
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
assert_equals
(
Object
.
getPrototypeOf
(
obj
)
this
.
get_interface_object
(
)
.
prototype
desc
+
"
'
s
prototype
is
not
"
+
this
.
name
+
"
.
prototype
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
must
be
primary
interface
of
"
+
desc
)
;
}
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_equals
(
typeof
obj
expected_typeof
"
wrong
typeof
object
"
)
;
assert_class_string
(
obj
this
.
get_qualified_name
(
)
"
class
string
of
"
+
desc
)
;
if
(
!
this
.
has_stringifier
(
)
)
{
assert_equals
(
String
(
obj
)
"
[
object
"
+
this
.
get_qualified_name
(
)
+
"
]
"
"
String
(
"
+
desc
+
"
)
"
)
;
}
}
.
bind
(
this
)
"
Stringification
of
"
+
desc
)
;
}
;
IdlInterface
.
prototype
.
test_interface_of
=
function
(
desc
obj
exception
expected_typeof
)
{
this
.
already_tested
=
true
;
if
(
!
shouldRunSubTest
(
this
.
name
)
)
{
return
;
}
for
(
var
i
=
0
;
i
<
this
.
members
.
length
;
i
+
+
)
{
var
member
=
this
.
members
[
i
]
;
if
(
member
.
untested
)
{
continue
;
}
if
(
!
exposed_in
(
exposure_set
(
member
this
.
exposureSet
)
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_false
(
member
.
name
in
obj
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
"
+
desc
+
'
must
not
have
property
"
'
+
member
.
name
+
'
"
'
)
;
continue
;
}
if
(
member
.
type
=
=
"
attribute
"
&
&
member
.
isUnforgeable
)
{
var
a_test
=
subsetTestByKey
(
this
.
name
async_test
this
.
name
+
"
interface
:
"
+
desc
+
'
must
have
own
property
"
'
+
member
.
name
+
'
"
'
)
;
a_test
.
step
(
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_equals
(
typeof
obj
expected_typeof
"
wrong
typeof
object
"
)
;
this
.
do_interface_attribute_asserts
(
obj
member
a_test
)
;
}
.
bind
(
this
)
)
;
}
else
if
(
member
.
type
=
=
"
operation
"
&
&
member
.
name
&
&
member
.
isUnforgeable
)
{
var
a_test
=
subsetTestByKey
(
this
.
name
async_test
this
.
name
+
"
interface
:
"
+
desc
+
'
must
have
own
property
"
'
+
member
.
name
+
'
"
'
)
;
a_test
.
step
(
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_equals
(
typeof
obj
expected_typeof
"
wrong
typeof
object
"
)
;
assert_own_property
(
obj
member
.
name
"
Doesn
'
t
have
the
unforgeable
operation
property
"
)
;
this
.
do_member_operation_asserts
(
obj
member
a_test
)
;
}
.
bind
(
this
)
)
;
}
else
if
(
(
member
.
type
=
=
"
const
"
|
|
member
.
type
=
=
"
attribute
"
|
|
member
.
type
=
=
"
operation
"
)
&
&
member
.
name
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_equals
(
typeof
obj
expected_typeof
"
wrong
typeof
object
"
)
;
if
(
member
.
special
!
=
=
"
static
"
)
{
if
(
!
this
.
is_global
(
)
)
{
assert_inherits
(
obj
member
.
name
)
;
}
else
{
assert_own_property
(
obj
member
.
name
)
;
}
if
(
member
.
type
=
=
"
const
"
)
{
assert_equals
(
obj
[
member
.
name
]
constValue
(
member
.
value
)
)
;
}
if
(
member
.
type
=
=
"
attribute
"
)
{
var
property
thrown
=
false
;
try
{
property
=
obj
[
member
.
name
]
;
}
catch
(
e
)
{
thrown
=
true
;
}
if
(
!
thrown
)
{
if
(
this
.
name
=
=
"
Document
"
&
&
member
.
name
=
=
"
all
"
)
{
assert_equals
(
typeof
property
"
undefined
"
)
;
}
else
{
this
.
array
.
assert_type_is
(
property
member
.
idlType
)
;
}
}
}
if
(
member
.
type
=
=
"
operation
"
)
{
assert_equals
(
typeof
obj
[
member
.
name
]
"
function
"
)
;
}
}
}
.
bind
(
this
)
this
.
name
+
"
interface
:
"
+
desc
+
'
must
inherit
property
"
'
+
member
+
'
"
with
the
proper
type
'
)
;
}
if
(
member
.
type
=
=
"
operation
"
&
&
member
.
name
&
&
member
.
arguments
.
length
)
{
var
description
=
this
.
name
+
"
interface
:
calling
"
+
member
+
"
on
"
+
desc
+
"
with
too
few
arguments
must
throw
TypeError
"
;
var
a_test
=
subsetTestByKey
(
this
.
name
async_test
description
)
;
a_test
.
step
(
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_equals
(
typeof
obj
expected_typeof
"
wrong
typeof
object
"
)
;
var
fn
;
if
(
member
.
special
!
=
=
"
static
"
)
{
if
(
!
this
.
is_global
(
)
&
&
!
member
.
isUnforgeable
)
{
assert_inherits
(
obj
member
.
name
)
;
}
else
{
assert_own_property
(
obj
member
.
name
)
;
}
fn
=
obj
[
member
.
name
]
;
}
else
{
assert_own_property
(
obj
.
constructor
member
.
name
"
interface
object
must
have
static
operation
as
own
property
"
)
;
fn
=
obj
.
constructor
[
member
.
name
]
;
}
var
minLength
=
minOverloadLength
(
this
.
members
.
filter
(
function
(
m
)
{
return
m
.
type
=
=
"
operation
"
&
&
m
.
name
=
=
member
.
name
;
}
)
)
;
var
args
=
[
]
;
var
cb
=
awaitNCallbacks
(
minLength
a_test
.
done
.
bind
(
a_test
)
)
;
for
(
var
i
=
0
;
i
<
minLength
;
i
+
+
)
{
throwOrReject
(
a_test
member
fn
obj
args
"
Called
with
"
+
i
+
"
arguments
"
cb
)
;
args
.
push
(
create_suitable_object
(
member
.
arguments
[
i
]
.
idlType
)
)
;
}
if
(
minLength
=
=
=
0
)
{
cb
(
)
;
}
}
.
bind
(
this
)
)
;
}
if
(
member
.
is_to_json_regular_operation
(
)
)
{
this
.
test_to_json_operation
(
desc
obj
member
)
;
}
}
}
;
IdlInterface
.
prototype
.
has_stringifier
=
function
(
)
{
if
(
this
.
name
=
=
=
"
DOMException
"
)
{
return
true
;
}
if
(
this
.
members
.
some
(
function
(
member
)
{
return
member
.
special
=
=
=
"
stringifier
"
;
}
)
)
{
return
true
;
}
if
(
this
.
base
&
&
this
.
array
.
members
[
this
.
base
]
.
has_stringifier
(
)
)
{
return
true
;
}
return
false
;
}
;
IdlInterface
.
prototype
.
do_interface_attribute_asserts
=
function
(
obj
member
a_test
)
{
var
pendingPromises
=
[
]
;
assert_own_property
(
obj
member
.
name
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
obj
member
.
name
)
;
assert_false
(
"
value
"
in
desc
'
property
descriptor
should
not
have
a
"
value
"
field
'
)
;
assert_false
(
"
writable
"
in
desc
'
property
descriptor
should
not
have
a
"
writable
"
field
'
)
;
assert_true
(
desc
.
enumerable
"
property
should
be
enumerable
"
)
;
if
(
member
.
isUnforgeable
)
{
assert_false
(
desc
.
configurable
"
[
LegacyUnforgeable
]
property
must
not
be
configurable
"
)
;
}
else
{
assert_true
(
desc
.
configurable
"
property
must
be
configurable
"
)
;
}
assert_equals
(
typeof
desc
.
get
"
function
"
"
getter
must
be
Function
"
)
;
if
(
member
.
special
!
=
=
"
static
"
)
{
if
(
!
member
.
has_extended_attribute
(
"
LegacyLenientThis
"
)
)
{
if
(
member
.
idlType
.
generic
!
=
=
"
Promise
"
)
{
assert_throws_js
(
globalOf
(
desc
.
get
)
.
TypeError
function
(
)
{
desc
.
get
.
call
(
{
}
)
;
}
.
bind
(
this
)
"
calling
getter
on
wrong
object
type
must
throw
TypeError
"
)
;
}
else
{
pendingPromises
.
push
(
promise_rejects_js
(
a_test
TypeError
desc
.
get
.
call
(
{
}
)
"
calling
getter
on
wrong
object
type
must
reject
the
return
promise
with
TypeError
"
)
)
;
}
}
else
{
assert_equals
(
desc
.
get
.
call
(
{
}
)
undefined
"
calling
getter
on
wrong
object
type
must
return
undefined
"
)
;
}
}
assert_equals
(
desc
.
get
.
length
0
"
getter
length
must
be
0
"
)
;
assert_equals
(
desc
.
get
.
name
"
get
"
+
member
.
name
"
getter
must
have
the
name
'
get
"
+
member
.
name
+
"
'
"
)
;
if
(
member
.
readonly
&
&
!
member
.
has_extended_attribute
(
"
LegacyLenientSetter
"
)
&
&
!
member
.
has_extended_attribute
(
"
PutForwards
"
)
&
&
!
member
.
has_extended_attribute
(
"
Replaceable
"
)
)
{
assert_equals
(
desc
.
set
undefined
"
setter
must
be
undefined
for
readonly
attributes
"
)
;
}
else
{
assert_equals
(
typeof
desc
.
set
"
function
"
"
setter
must
be
function
for
PutForwards
Replaceable
or
non
-
readonly
attributes
"
)
;
if
(
member
.
special
!
=
=
"
static
"
)
{
if
(
!
member
.
has_extended_attribute
(
"
LegacyLenientThis
"
)
)
{
assert_throws_js
(
globalOf
(
desc
.
set
)
.
TypeError
function
(
)
{
desc
.
set
.
call
(
{
}
)
;
}
.
bind
(
this
)
"
calling
setter
on
wrong
object
type
must
throw
TypeError
"
)
;
}
else
{
assert_equals
(
desc
.
set
.
call
(
{
}
)
undefined
"
calling
setter
on
wrong
object
type
must
return
undefined
"
)
;
}
}
assert_equals
(
desc
.
set
.
length
1
"
setter
length
must
be
1
"
)
;
assert_equals
(
desc
.
set
.
name
"
set
"
+
member
.
name
"
The
attribute
setter
must
have
the
name
'
set
"
+
member
.
name
+
"
'
"
)
;
}
Promise
.
all
(
pendingPromises
)
.
then
(
a_test
.
done
.
bind
(
a_test
)
)
;
}
function
IdlInterfaceMember
(
obj
)
{
for
(
var
k
in
obj
.
toJSON
(
)
)
{
this
[
k
]
=
obj
[
k
]
;
}
if
(
!
(
"
extAttrs
"
in
this
)
)
{
this
.
extAttrs
=
[
]
;
}
this
.
isUnforgeable
=
this
.
has_extended_attribute
(
"
LegacyUnforgeable
"
)
;
this
.
isUnscopable
=
this
.
has_extended_attribute
(
"
Unscopable
"
)
;
}
IdlInterfaceMember
.
prototype
=
Object
.
create
(
IdlObject
.
prototype
)
;
IdlInterfaceMember
.
prototype
.
toJSON
=
function
(
)
{
return
this
;
}
;
IdlInterfaceMember
.
prototype
.
is_to_json_regular_operation
=
function
(
)
{
return
this
.
type
=
=
"
operation
"
&
&
this
.
special
!
=
=
"
static
"
&
&
this
.
name
=
=
"
toJSON
"
;
}
;
IdlInterfaceMember
.
prototype
.
toString
=
function
(
)
{
function
formatType
(
type
)
{
var
result
;
if
(
type
.
generic
)
{
result
=
type
.
generic
+
"
<
"
+
type
.
idlType
.
map
(
formatType
)
.
join
(
"
"
)
+
"
>
"
;
}
else
if
(
type
.
union
)
{
result
=
"
(
"
+
type
.
subtype
.
map
(
formatType
)
.
join
(
"
or
"
)
+
"
)
"
;
}
else
{
result
=
type
.
idlType
;
}
if
(
type
.
nullable
)
{
result
+
=
"
?
"
}
return
result
;
}
if
(
this
.
type
=
=
=
"
operation
"
)
{
var
args
=
this
.
arguments
.
map
(
function
(
m
)
{
return
[
m
.
optional
?
"
optional
"
:
"
"
formatType
(
m
.
idlType
)
m
.
variadic
?
"
.
.
.
"
:
"
"
]
.
join
(
"
"
)
;
}
)
.
join
(
"
"
)
;
return
this
.
name
+
"
(
"
+
args
+
"
)
"
;
}
return
this
.
name
;
}
function
create_suitable_object
(
type
)
{
if
(
type
.
nullable
)
{
return
null
;
}
switch
(
type
.
idlType
)
{
case
"
any
"
:
case
"
boolean
"
:
return
true
;
case
"
byte
"
:
case
"
octet
"
:
case
"
short
"
:
case
"
unsigned
short
"
:
case
"
long
"
:
case
"
unsigned
long
"
:
case
"
long
long
"
:
case
"
unsigned
long
long
"
:
case
"
float
"
:
case
"
double
"
:
case
"
unrestricted
float
"
:
case
"
unrestricted
double
"
:
return
7
;
case
"
DOMString
"
:
case
"
ByteString
"
:
case
"
USVString
"
:
return
"
foo
"
;
case
"
object
"
:
return
{
a
:
"
b
"
}
;
case
"
Node
"
:
return
document
.
createTextNode
(
"
abc
"
)
;
}
return
null
;
}
function
IdlEnum
(
obj
)
{
this
.
name
=
obj
.
name
;
this
.
values
=
obj
.
values
;
}
IdlEnum
.
prototype
=
Object
.
create
(
IdlObject
.
prototype
)
;
function
IdlCallback
(
obj
)
{
this
.
name
=
obj
.
name
;
this
.
arguments
=
obj
.
arguments
;
}
IdlCallback
.
prototype
=
Object
.
create
(
IdlObject
.
prototype
)
;
function
IdlTypedef
(
obj
)
{
this
.
name
=
obj
.
name
;
this
.
idlType
=
obj
.
idlType
;
}
IdlTypedef
.
prototype
=
Object
.
create
(
IdlObject
.
prototype
)
;
function
IdlNamespace
(
obj
)
{
this
.
name
=
obj
.
name
;
this
.
extAttrs
=
obj
.
extAttrs
;
this
.
untested
=
obj
.
untested
;
this
.
array
=
obj
.
array
;
this
.
members
=
obj
.
members
.
map
(
m
=
>
new
IdlInterfaceMember
(
m
)
)
;
}
IdlNamespace
.
prototype
=
Object
.
create
(
IdlObject
.
prototype
)
;
IdlNamespace
.
prototype
.
do_member_operation_asserts
=
function
(
memberHolderObject
member
a_test
)
{
var
desc
=
Object
.
getOwnPropertyDescriptor
(
memberHolderObject
member
.
name
)
;
assert_false
(
"
get
"
in
desc
"
property
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
property
should
not
have
a
setter
"
)
;
assert_equals
(
desc
.
writable
!
member
.
isUnforgeable
"
property
should
be
writable
if
and
only
if
not
unforgeable
"
)
;
assert_true
(
desc
.
enumerable
"
property
should
be
enumerable
"
)
;
assert_equals
(
desc
.
configurable
!
member
.
isUnforgeable
"
property
should
be
configurable
if
and
only
if
not
unforgeable
"
)
;
assert_equals
(
typeof
memberHolderObject
[
member
.
name
]
"
function
"
"
property
must
be
a
function
"
)
;
assert_equals
(
memberHolderObject
[
member
.
name
]
.
length
minOverloadLength
(
this
.
members
.
filter
(
function
(
m
)
{
return
m
.
type
=
=
"
operation
"
&
&
m
.
name
=
=
member
.
name
;
}
)
)
"
operation
has
wrong
.
length
"
)
;
a_test
.
done
(
)
;
}
IdlNamespace
.
prototype
.
test_member_operation
=
function
(
member
)
{
if
(
!
shouldRunSubTest
(
this
.
name
)
)
{
return
;
}
var
a_test
=
subsetTestByKey
(
this
.
name
async_test
this
.
name
+
'
namespace
:
operation
'
+
member
)
;
a_test
.
step
(
function
(
)
{
assert_own_property
(
self
[
this
.
name
]
member
.
name
'
namespace
object
missing
operation
'
+
format_value
(
member
.
name
)
)
;
this
.
do_member_operation_asserts
(
self
[
this
.
name
]
member
a_test
)
;
}
.
bind
(
this
)
)
;
}
;
IdlNamespace
.
prototype
.
test_member_attribute
=
function
(
member
)
{
if
(
!
shouldRunSubTest
(
this
.
name
)
)
{
return
;
}
var
a_test
=
subsetTestByKey
(
this
.
name
async_test
this
.
name
+
'
namespace
:
attribute
'
+
member
.
name
)
;
a_test
.
step
(
function
(
)
{
assert_own_property
(
self
[
this
.
name
]
member
.
name
this
.
name
+
'
does
not
have
property
'
+
format_value
(
member
.
name
)
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
[
this
.
name
]
member
.
name
)
;
assert_equals
(
desc
.
set
undefined
"
setter
must
be
undefined
for
namespace
members
"
)
;
a_test
.
done
(
)
;
}
.
bind
(
this
)
)
;
}
;
IdlNamespace
.
prototype
.
test_self
=
function
(
)
{
subsetTestByKey
(
this
.
name
test
(
)
=
>
{
assert_true
(
this
.
extAttrs
.
every
(
o
=
>
o
.
name
=
=
=
"
Exposed
"
|
|
o
.
name
=
=
=
"
SecureContext
"
)
"
Only
the
[
Exposed
]
and
[
SecureContext
]
extended
attributes
are
applicable
to
namespaces
"
)
;
assert_true
(
this
.
has_extended_attribute
(
"
Exposed
"
)
"
Namespaces
must
be
annotated
with
the
[
Exposed
]
extended
attribute
"
)
;
}
{
this
.
name
}
namespace
:
extended
attributes
)
;
const
namespaceObject
=
self
[
this
.
name
]
;
subsetTestByKey
(
this
.
name
test
(
)
=
>
{
const
desc
=
Object
.
getOwnPropertyDescriptor
(
self
this
.
name
)
;
assert_equals
(
desc
.
value
namespaceObject
wrong
value
for
{
this
.
name
}
namespace
object
)
;
assert_true
(
desc
.
writable
"
namespace
object
should
be
writable
"
)
;
assert_false
(
desc
.
enumerable
"
namespace
object
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
"
namespace
object
should
be
configurable
"
)
;
assert_false
(
"
get
"
in
desc
"
namespace
object
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
namespace
object
should
not
have
a
setter
"
)
;
}
{
this
.
name
}
namespace
:
property
descriptor
)
;
subsetTestByKey
(
this
.
name
test
(
)
=
>
{
assert_true
(
Object
.
isExtensible
(
namespaceObject
)
)
;
}
{
this
.
name
}
namespace
:
[
[
Extensible
]
]
is
true
)
;
subsetTestByKey
(
this
.
name
test
(
)
=
>
{
assert_true
(
namespaceObject
instanceof
Object
)
;
if
(
this
.
name
=
=
=
"
console
"
)
{
const
namespacePrototype
=
Object
.
getPrototypeOf
(
namespaceObject
)
;
assert_equals
(
Reflect
.
ownKeys
(
namespacePrototype
)
.
length
0
)
;
assert_equals
(
Object
.
getPrototypeOf
(
namespacePrototype
)
Object
.
prototype
)
;
}
else
{
assert_equals
(
Object
.
getPrototypeOf
(
namespaceObject
)
Object
.
prototype
)
;
}
}
{
this
.
name
}
namespace
:
[
[
Prototype
]
]
is
Object
.
prototype
)
;
subsetTestByKey
(
this
.
name
test
(
)
=
>
{
assert_equals
(
typeof
namespaceObject
"
object
"
)
;
}
{
this
.
name
}
namespace
:
typeof
is
"
object
"
)
;
subsetTestByKey
(
this
.
name
test
(
)
=
>
{
assert_equals
(
Object
.
getOwnPropertyDescriptor
(
namespaceObject
"
length
"
)
undefined
"
length
property
must
be
undefined
"
)
;
}
{
this
.
name
}
namespace
:
has
no
length
property
)
;
subsetTestByKey
(
this
.
name
test
(
)
=
>
{
assert_equals
(
Object
.
getOwnPropertyDescriptor
(
namespaceObject
"
name
"
)
undefined
"
name
property
must
be
undefined
"
)
;
}
{
this
.
name
}
namespace
:
has
no
name
property
)
;
}
;
IdlNamespace
.
prototype
.
test
=
function
(
)
{
if
(
!
this
.
untested
)
{
this
.
test_self
(
)
;
}
for
(
const
v
of
Object
.
values
(
this
.
members
)
)
{
switch
(
v
.
type
)
{
case
'
operation
'
:
this
.
test_member_operation
(
v
)
;
break
;
case
'
attribute
'
:
this
.
test_member_attribute
(
v
)
;
break
;
default
:
throw
'
Invalid
namespace
member
'
+
v
.
name
+
'
:
'
+
v
.
type
+
'
not
supported
'
;
}
}
;
}
;
}
(
)
)
;
function
idl_test
(
srcs
deps
idl_setup_func
)
{
return
promise_test
(
function
(
t
)
{
var
idl_array
=
new
IdlArray
(
)
;
var
setup_error
=
null
;
const
validationIgnored
=
[
"
constructor
-
member
"
"
dict
-
arg
-
default
"
"
require
-
exposed
"
]
;
return
Promise
.
all
(
srcs
.
concat
(
deps
)
.
map
(
fetch_spec
)
)
.
then
(
function
(
results
)
{
const
astArray
=
results
.
map
(
result
=
>
WebIDL2
.
parse
(
result
.
idl
{
sourceName
:
result
.
spec
}
)
)
;
test
(
(
)
=
>
{
const
validations
=
WebIDL2
.
validate
(
astArray
)
.
filter
(
v
=
>
!
validationIgnored
.
includes
(
v
.
ruleName
)
)
;
if
(
validations
.
length
)
{
const
message
=
validations
.
map
(
v
=
>
v
.
message
)
.
join
(
"
\
n
\
n
"
)
;
throw
new
Error
(
message
)
;
}
}
"
idl_test
validation
"
)
;
for
(
var
i
=
0
;
i
<
srcs
.
length
;
i
+
+
)
{
idl_array
.
internal_add_idls
(
astArray
[
i
]
)
;
}
for
(
var
i
=
srcs
.
length
;
i
<
srcs
.
length
+
deps
.
length
;
i
+
+
)
{
idl_array
.
internal_add_dependency_idls
(
astArray
[
i
]
)
;
}
}
)
.
then
(
function
(
)
{
if
(
idl_setup_func
)
{
return
idl_setup_func
(
idl_array
t
)
;
}
}
)
.
catch
(
function
(
e
)
{
setup_error
=
e
|
|
'
IDL
setup
failed
.
'
;
}
)
.
then
(
function
(
)
{
var
error
=
setup_error
;
try
{
idl_array
.
test
(
)
;
}
catch
(
e
)
{
error
=
error
|
|
e
;
}
if
(
error
)
{
throw
error
;
}
}
)
;
}
'
idl_test
setup
'
)
;
}
function
fetch_spec
(
spec
)
{
var
url
=
'
/
interfaces
/
'
+
spec
+
'
.
idl
'
;
return
fetch
(
url
)
.
then
(
function
(
r
)
{
if
(
!
r
.
ok
)
{
throw
new
IdlHarnessError
(
"
Error
fetching
"
+
url
+
"
.
"
)
;
}
return
r
.
text
(
)
;
}
)
.
then
(
idl
=
>
(
{
spec
idl
}
)
)
;
}
