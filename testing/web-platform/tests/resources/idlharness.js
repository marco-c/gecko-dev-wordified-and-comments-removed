(
function
(
)
{
"
use
strict
"
;
if
(
!
(
'
subsetTestByKey
'
in
self
)
)
{
self
.
subsetTestByKey
=
function
(
key
callback
.
.
.
args
)
{
return
callback
(
.
.
.
args
)
;
}
self
.
shouldRunSubTest
=
(
)
=
>
true
;
}
function
constValue
(
cnt
)
{
if
(
cnt
.
type
=
=
=
"
null
"
)
return
null
;
if
(
cnt
.
type
=
=
=
"
NaN
"
)
return
NaN
;
if
(
cnt
.
type
=
=
=
"
Infinity
"
)
return
cnt
.
negative
?
-
Infinity
:
Infinity
;
if
(
cnt
.
type
=
=
=
"
number
"
)
return
+
cnt
.
value
;
return
cnt
.
value
;
}
function
minOverloadLength
(
overloads
)
{
if
(
!
overloads
.
length
)
{
return
0
;
}
return
overloads
.
map
(
function
(
attr
)
{
return
attr
.
arguments
?
attr
.
arguments
.
filter
(
function
(
arg
)
{
return
!
arg
.
optional
&
&
!
arg
.
variadic
;
}
)
.
length
:
0
;
}
)
.
reduce
(
function
(
m
n
)
{
return
Math
.
min
(
m
n
)
;
}
)
;
}
function
throwOrReject
(
a_test
operation
fn
obj
args
message
cb
)
{
if
(
operation
.
idlType
.
generic
!
=
=
"
Promise
"
)
{
assert_throws
(
new
TypeError
(
)
function
(
)
{
fn
.
apply
(
obj
args
)
;
}
message
)
;
cb
(
)
;
}
else
{
try
{
promise_rejects
(
a_test
new
TypeError
(
)
fn
.
apply
(
obj
args
)
message
)
.
then
(
cb
cb
)
;
}
catch
(
e
)
{
a_test
.
step
(
function
(
)
{
assert_unreached
(
"
Throws
\
"
"
+
e
+
"
\
"
instead
of
rejecting
promise
"
)
;
cb
(
)
;
}
)
;
}
}
}
function
awaitNCallbacks
(
n
cb
ctx
)
{
var
counter
=
0
;
return
function
(
)
{
counter
+
+
;
if
(
counter
>
=
n
)
{
cb
(
)
;
}
}
;
}
var
fround
=
(
function
(
)
{
if
(
Math
.
fround
)
return
Math
.
fround
;
var
arr
=
new
Float32Array
(
1
)
;
return
function
fround
(
n
)
{
arr
[
0
]
=
n
;
return
arr
[
0
]
;
}
;
}
)
(
)
;
self
.
IdlHarnessError
=
function
(
message
)
{
this
.
message
=
message
;
}
;
IdlHarnessError
.
prototype
=
Object
.
create
(
Error
.
prototype
)
;
IdlHarnessError
.
prototype
.
toString
=
function
(
)
{
return
this
.
message
;
}
;
self
.
IdlArray
=
function
(
)
{
this
.
members
=
{
}
;
this
.
objects
=
{
}
;
this
.
partials
=
[
]
;
this
[
"
implements
"
]
=
{
}
;
this
[
"
includes
"
]
=
{
}
;
this
[
"
inheritance
"
]
=
{
}
;
}
;
IdlArray
.
prototype
.
add_idls
=
function
(
raw_idls
options
)
{
this
.
internal_add_idls
(
WebIDL2
.
parse
(
raw_idls
)
options
)
;
}
;
IdlArray
.
prototype
.
add_untested_idls
=
function
(
raw_idls
options
)
{
var
parsed_idls
=
WebIDL2
.
parse
(
raw_idls
)
;
this
.
mark_as_untested
(
parsed_idls
)
;
this
.
internal_add_idls
(
parsed_idls
options
)
;
}
;
IdlArray
.
prototype
.
mark_as_untested
=
function
(
parsed_idls
)
{
for
(
var
i
=
0
;
i
<
parsed_idls
.
length
;
i
+
+
)
{
parsed_idls
[
i
]
.
untested
=
true
;
if
(
"
members
"
in
parsed_idls
[
i
]
)
{
for
(
var
j
=
0
;
j
<
parsed_idls
[
i
]
.
members
.
length
;
j
+
+
)
{
parsed_idls
[
i
]
.
members
[
j
]
.
untested
=
true
;
}
}
}
}
;
IdlArray
.
prototype
.
is_excluded_by_options
=
function
(
name
options
)
{
return
options
&
&
(
options
.
except
&
&
options
.
except
.
includes
(
name
)
|
|
options
.
only
&
&
!
options
.
only
.
includes
(
name
)
)
;
}
;
IdlArray
.
prototype
.
add_dependency_idls
=
function
(
raw_idls
options
)
{
const
parsed_idls
=
WebIDL2
.
parse
(
raw_idls
)
;
const
new_options
=
{
only
:
[
]
}
const
all_deps
=
new
Set
(
)
;
Object
.
values
(
this
.
inheritance
)
.
forEach
(
v
=
>
all_deps
.
add
(
v
)
)
;
Object
.
values
(
this
.
implements
)
.
forEach
(
v
=
>
all_deps
.
add
(
v
)
)
;
Object
.
keys
(
this
.
includes
)
.
forEach
(
k
=
>
{
all_deps
.
add
(
k
)
;
this
.
includes
[
k
]
.
forEach
(
v
=
>
all_deps
.
add
(
v
)
)
;
}
)
;
this
.
partials
.
map
(
p
=
>
p
.
name
)
.
forEach
(
v
=
>
all_deps
.
add
(
v
)
)
;
for
(
const
obj
of
[
this
.
members
this
.
partials
]
)
{
const
tested
=
Object
.
values
(
obj
)
.
filter
(
m
=
>
!
m
.
untested
&
&
m
.
members
)
;
for
(
const
parsed
of
tested
)
{
for
(
const
attr
of
Object
.
values
(
parsed
.
members
)
.
filter
(
m
=
>
!
m
.
untested
&
&
m
.
type
=
=
=
'
attribute
'
)
)
{
all_deps
.
add
(
attr
.
idlType
.
idlType
)
;
}
}
}
if
(
options
&
&
options
.
except
&
&
options
.
only
)
{
throw
new
IdlHarnessError
(
"
The
only
and
except
options
can
'
t
be
used
together
.
"
)
;
}
const
should_skip
=
name
=
>
{
return
name
in
this
.
members
|
|
this
.
is_excluded_by_options
(
name
options
)
;
}
const
skipped
=
new
Map
(
)
;
const
process
=
function
(
parsed
)
{
let
name
=
parsed
.
name
|
|
parsed
.
type
=
=
"
implements
"
&
&
parsed
.
target
|
|
parsed
.
type
=
=
"
includes
"
&
&
parsed
.
target
;
if
(
!
name
|
|
should_skip
(
name
)
|
|
!
all_deps
.
has
(
name
)
)
{
name
&
&
skipped
.
has
(
name
)
?
skipped
.
get
(
name
)
.
push
(
parsed
)
:
skipped
.
set
(
name
[
parsed
]
)
;
return
;
}
new_options
.
only
.
push
(
name
)
;
const
follow_up
=
[
]
;
for
(
const
dep_type
of
[
"
inheritance
"
"
implements
"
"
includes
"
]
)
{
if
(
parsed
[
dep_type
]
)
{
const
dep
=
parsed
[
dep_type
]
;
new_options
.
only
.
push
(
dep
)
;
all_deps
.
add
(
dep
)
;
follow_up
.
push
(
dep
)
;
}
}
for
(
const
deferred
of
follow_up
)
{
if
(
skipped
.
has
(
deferred
)
)
{
const
next
=
skipped
.
get
(
deferred
)
;
skipped
.
delete
(
deferred
)
;
next
.
forEach
(
process
)
;
}
}
}
for
(
let
parsed
of
parsed_idls
)
{
process
(
parsed
)
;
}
this
.
mark_as_untested
(
parsed_idls
)
;
if
(
new_options
.
only
.
length
)
{
this
.
internal_add_idls
(
parsed_idls
new_options
)
;
}
}
IdlArray
.
prototype
.
internal_add_idls
=
function
(
parsed_idls
options
)
{
if
(
options
&
&
options
.
only
&
&
options
.
except
)
{
throw
new
IdlHarnessError
(
"
The
only
and
except
options
can
'
t
be
used
together
.
"
)
;
}
var
should_skip
=
name
=
>
{
return
this
.
is_excluded_by_options
(
name
options
)
;
}
parsed_idls
.
forEach
(
function
(
parsed_idl
)
{
if
(
parsed_idl
.
partial
&
&
[
"
interface
"
"
dictionary
"
]
.
includes
(
parsed_idl
.
type
)
)
{
if
(
should_skip
(
parsed_idl
.
name
)
)
{
return
;
}
this
.
partials
.
push
(
parsed_idl
)
;
return
;
}
if
(
parsed_idl
.
type
=
=
"
implements
"
)
{
if
(
should_skip
(
parsed_idl
.
target
)
)
{
return
;
}
if
(
!
(
parsed_idl
.
target
in
this
[
"
implements
"
]
)
)
{
this
[
"
implements
"
]
[
parsed_idl
.
target
]
=
[
]
;
}
this
[
"
implements
"
]
[
parsed_idl
.
target
]
.
push
(
parsed_idl
[
"
implements
"
]
)
;
return
;
}
if
(
parsed_idl
.
type
=
=
"
includes
"
)
{
if
(
should_skip
(
parsed_idl
.
target
)
)
{
return
;
}
if
(
!
(
parsed_idl
.
target
in
this
[
"
includes
"
]
)
)
{
this
[
"
includes
"
]
[
parsed_idl
.
target
]
=
[
]
;
}
this
[
"
includes
"
]
[
parsed_idl
.
target
]
.
push
(
parsed_idl
[
"
includes
"
]
)
;
return
;
}
parsed_idl
.
array
=
this
;
if
(
should_skip
(
parsed_idl
.
name
)
)
{
return
;
}
if
(
parsed_idl
.
name
in
this
.
members
)
{
throw
new
IdlHarnessError
(
"
Duplicate
identifier
"
+
parsed_idl
.
name
)
;
}
if
(
parsed_idl
[
"
inheritance
"
]
)
{
if
(
parsed_idl
.
name
in
this
[
"
inheritance
"
]
&
&
parsed_idl
[
"
inheritance
"
]
!
=
this
[
"
inheritance
"
]
[
parsed_idl
.
name
]
)
{
throw
new
IdlHarnessError
(
Inheritance
for
{
parsed_idl
.
name
}
was
already
defined
)
;
}
this
[
"
inheritance
"
]
[
parsed_idl
.
name
]
=
parsed_idl
[
"
inheritance
"
]
;
}
switch
(
parsed_idl
.
type
)
{
case
"
interface
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlInterface
(
parsed_idl
false
false
)
;
break
;
case
"
interface
mixin
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlInterface
(
parsed_idl
false
true
)
;
break
;
case
"
dictionary
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlDictionary
(
parsed_idl
)
;
break
;
case
"
typedef
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlTypedef
(
parsed_idl
)
;
break
;
case
"
callback
"
:
console
.
log
(
"
callback
not
yet
supported
"
)
;
break
;
case
"
enum
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlEnum
(
parsed_idl
)
;
break
;
case
"
callback
interface
"
:
this
.
members
[
parsed_idl
.
name
]
=
new
IdlInterface
(
parsed_idl
true
false
)
;
break
;
default
:
throw
parsed_idl
.
name
+
"
:
"
+
parsed_idl
.
type
+
"
not
yet
supported
"
;
}
}
.
bind
(
this
)
)
;
}
;
IdlArray
.
prototype
.
add_objects
=
function
(
dict
)
{
for
(
var
k
in
dict
)
{
if
(
k
in
this
.
objects
)
{
this
.
objects
[
k
]
=
this
.
objects
[
k
]
.
concat
(
dict
[
k
]
)
;
}
else
{
this
.
objects
[
k
]
=
dict
[
k
]
;
}
}
}
;
IdlArray
.
prototype
.
prevent_multiple_testing
=
function
(
name
)
{
this
.
members
[
name
]
.
prevent_multiple_testing
=
true
;
}
;
IdlArray
.
prototype
.
recursively_get_implements
=
function
(
interface_name
)
{
var
ret
=
this
[
"
implements
"
]
[
interface_name
]
;
if
(
ret
=
=
=
undefined
)
{
return
[
]
;
}
for
(
var
i
=
0
;
i
<
this
[
"
implements
"
]
[
interface_name
]
.
length
;
i
+
+
)
{
ret
=
ret
.
concat
(
this
.
recursively_get_implements
(
ret
[
i
]
)
)
;
if
(
ret
.
indexOf
(
ret
[
i
]
)
!
=
ret
.
lastIndexOf
(
ret
[
i
]
)
)
{
throw
new
IdlHarnessError
(
"
Circular
implements
statements
involving
"
+
ret
[
i
]
)
;
}
}
return
ret
;
}
;
IdlArray
.
prototype
.
recursively_get_includes
=
function
(
interface_name
)
{
var
ret
=
this
[
"
includes
"
]
[
interface_name
]
;
if
(
ret
=
=
=
undefined
)
{
return
[
]
;
}
for
(
var
i
=
0
;
i
<
this
[
"
includes
"
]
[
interface_name
]
.
length
;
i
+
+
)
{
ret
=
ret
.
concat
(
this
.
recursively_get_includes
(
ret
[
i
]
)
)
;
if
(
ret
.
indexOf
(
ret
[
i
]
)
!
=
ret
.
lastIndexOf
(
ret
[
i
]
)
)
{
throw
new
IdlHarnessError
(
"
Circular
includes
statements
involving
"
+
ret
[
i
]
)
;
}
}
return
ret
;
}
;
IdlArray
.
prototype
.
is_json_type
=
function
(
type
)
{
var
idlType
=
type
.
idlType
;
if
(
type
.
generic
=
=
"
Promise
"
)
{
return
false
;
}
if
(
type
.
union
|
|
type
.
generic
=
=
"
record
"
)
{
return
idlType
.
every
(
this
.
is_json_type
this
)
;
}
if
(
type
.
generic
=
=
"
sequence
"
|
|
type
.
generic
=
=
"
FrozenArray
"
)
{
return
this
.
is_json_type
(
idlType
)
;
}
if
(
typeof
idlType
!
=
"
string
"
)
{
throw
new
Error
(
"
Unexpected
type
"
+
JSON
.
stringify
(
idlType
)
)
;
}
switch
(
idlType
)
{
case
"
byte
"
:
case
"
octet
"
:
case
"
short
"
:
case
"
unsigned
short
"
:
case
"
long
"
:
case
"
unsigned
long
"
:
case
"
long
long
"
:
case
"
unsigned
long
long
"
:
case
"
float
"
:
case
"
double
"
:
case
"
unrestricted
float
"
:
case
"
unrestricted
double
"
:
case
"
boolean
"
:
case
"
DOMString
"
:
case
"
ByteString
"
:
case
"
USVString
"
:
case
"
object
"
:
return
true
;
case
"
Error
"
:
case
"
DOMException
"
:
case
"
Int8Array
"
:
case
"
Int16Array
"
:
case
"
Int32Array
"
:
case
"
Uint8Array
"
:
case
"
Uint16Array
"
:
case
"
Uint32Array
"
:
case
"
Uint8ClampedArray
"
:
case
"
Float32Array
"
:
case
"
ArrayBuffer
"
:
case
"
DataView
"
:
case
"
any
"
:
return
false
;
default
:
var
thing
=
this
.
members
[
idlType
]
;
if
(
!
thing
)
{
throw
new
Error
(
"
Type
"
+
idlType
+
"
not
found
"
)
;
}
if
(
thing
instanceof
IdlEnum
)
{
return
true
;
}
if
(
thing
instanceof
IdlTypedef
)
{
return
this
.
is_json_type
(
thing
.
idlType
)
;
}
if
(
thing
instanceof
IdlDictionary
)
{
var
stack
=
thing
.
get_inheritance_stack
(
)
;
var
map
=
new
Map
(
)
;
while
(
stack
.
length
)
{
stack
.
pop
(
)
.
members
.
forEach
(
function
(
m
)
{
map
.
set
(
m
.
name
m
.
idlType
)
}
)
;
}
return
Array
.
from
(
map
.
values
(
)
)
.
every
(
this
.
is_json_type
this
)
;
}
if
(
thing
instanceof
IdlInterface
)
{
var
base
;
while
(
thing
)
{
if
(
thing
.
has_to_json_regular_operation
(
)
)
{
return
true
;
}
var
mixins
=
this
.
implements
[
thing
.
name
]
|
|
this
.
includes
[
thing
.
name
]
;
if
(
mixins
)
{
mixins
=
mixins
.
map
(
function
(
id
)
{
var
mixin
=
this
.
members
[
id
]
;
if
(
!
mixin
)
{
throw
new
Error
(
"
Interface
"
+
id
+
"
not
found
(
implemented
by
"
+
thing
.
name
+
"
)
"
)
;
}
return
mixin
;
}
this
)
;
if
(
mixins
.
some
(
function
(
m
)
{
return
m
.
has_to_json_regular_operation
(
)
}
)
)
{
return
true
;
}
}
if
(
!
thing
.
base
)
{
return
false
;
}
base
=
this
.
members
[
thing
.
base
]
;
if
(
!
base
)
{
throw
new
Error
(
"
Interface
"
+
thing
.
base
+
"
not
found
(
inherited
by
"
+
thing
.
name
+
"
)
"
)
;
}
thing
=
base
;
}
return
false
;
}
return
false
;
}
}
;
function
exposure_set
(
object
default_set
)
{
var
exposed
=
object
.
extAttrs
&
&
object
.
extAttrs
.
filter
(
a
=
>
a
.
name
=
=
=
"
Exposed
"
)
;
if
(
exposed
&
&
exposed
.
length
>
1
)
{
throw
new
IdlHarnessError
(
Multiple
'
Exposed
'
extended
attributes
on
{
object
.
name
}
)
;
}
let
result
=
default_set
|
|
[
"
Window
"
]
;
if
(
result
&
&
!
(
result
instanceof
Set
)
)
{
result
=
new
Set
(
result
)
;
}
if
(
exposed
&
&
exposed
.
length
)
{
var
set
=
exposed
[
0
]
.
rhs
.
value
;
if
(
typeof
set
=
=
"
string
"
)
{
set
=
[
set
]
;
}
result
=
new
Set
(
set
)
;
}
if
(
result
&
&
result
.
has
(
"
Worker
"
)
)
{
result
.
delete
(
"
Worker
"
)
;
result
.
add
(
"
DedicatedWorker
"
)
;
result
.
add
(
"
ServiceWorker
"
)
;
result
.
add
(
"
SharedWorker
"
)
;
}
return
result
;
}
function
exposed_in
(
globals
)
{
if
(
'
document
'
in
self
)
{
return
globals
.
has
(
"
Window
"
)
;
}
if
(
'
DedicatedWorkerGlobalScope
'
in
self
&
&
self
instanceof
DedicatedWorkerGlobalScope
)
{
return
globals
.
has
(
"
DedicatedWorker
"
)
;
}
if
(
'
SharedWorkerGlobalScope
'
in
self
&
&
self
instanceof
SharedWorkerGlobalScope
)
{
return
globals
.
has
(
"
SharedWorker
"
)
;
}
if
(
'
ServiceWorkerGlobalScope
'
in
self
&
&
self
instanceof
ServiceWorkerGlobalScope
)
{
return
globals
.
has
(
"
ServiceWorker
"
)
;
}
throw
new
IdlHarnessError
(
"
Unexpected
global
object
"
)
;
}
IdlArray
.
prototype
.
assert_throws
=
function
(
error
idlArrayFunc
)
{
try
{
idlArrayFunc
.
call
(
this
this
)
;
}
catch
(
e
)
{
if
(
e
instanceof
AssertionError
)
{
throw
e
;
}
if
(
error
instanceof
IdlHarnessError
)
{
error
=
error
.
message
;
}
if
(
e
.
message
!
=
=
error
)
{
throw
new
IdlHarnessError
(
{
idlArrayFunc
}
threw
"
{
e
}
"
not
the
expected
IdlHarnessError
"
{
error
}
"
)
;
}
return
;
}
throw
new
IdlHarnessError
(
{
idlArrayFunc
}
did
not
throw
the
expected
IdlHarnessError
)
;
}
IdlArray
.
prototype
.
test
=
function
(
)
{
this
.
collapse_partials
(
)
;
for
(
var
lhs
in
this
[
"
implements
"
]
)
{
this
.
recursively_get_implements
(
lhs
)
.
forEach
(
function
(
rhs
)
{
var
errStr
=
lhs
+
"
implements
"
+
rhs
+
"
but
"
;
if
(
!
(
lhs
in
this
.
members
)
)
throw
errStr
+
lhs
+
"
is
undefined
.
"
;
if
(
!
(
this
.
members
[
lhs
]
instanceof
IdlInterface
)
)
throw
errStr
+
lhs
+
"
is
not
an
interface
.
"
;
if
(
!
(
rhs
in
this
.
members
)
)
throw
errStr
+
rhs
+
"
is
undefined
.
"
;
if
(
!
(
this
.
members
[
rhs
]
instanceof
IdlInterface
)
)
throw
errStr
+
rhs
+
"
is
not
an
interface
.
"
;
this
.
members
[
rhs
]
.
members
.
forEach
(
function
(
member
)
{
this
.
members
[
lhs
]
.
members
.
push
(
new
IdlInterfaceMember
(
member
)
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
}
this
[
"
implements
"
]
=
{
}
;
for
(
var
lhs
in
this
[
"
includes
"
]
)
{
this
.
recursively_get_includes
(
lhs
)
.
forEach
(
function
(
rhs
)
{
var
errStr
=
lhs
+
"
includes
"
+
rhs
+
"
but
"
;
if
(
!
(
lhs
in
this
.
members
)
)
throw
errStr
+
lhs
+
"
is
undefined
.
"
;
if
(
!
(
this
.
members
[
lhs
]
instanceof
IdlInterface
)
)
throw
errStr
+
lhs
+
"
is
not
an
interface
.
"
;
if
(
!
(
rhs
in
this
.
members
)
)
throw
errStr
+
rhs
+
"
is
undefined
.
"
;
if
(
!
(
this
.
members
[
rhs
]
instanceof
IdlInterface
)
)
throw
errStr
+
rhs
+
"
is
not
an
interface
.
"
;
this
.
members
[
rhs
]
.
members
.
forEach
(
function
(
member
)
{
this
.
members
[
lhs
]
.
members
.
push
(
new
IdlInterfaceMember
(
member
)
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
}
this
[
"
includes
"
]
=
{
}
;
for
(
var
member
of
Object
.
values
(
this
.
members
)
.
filter
(
m
=
>
m
.
base
)
)
{
const
lhs
=
member
.
name
;
const
rhs
=
member
.
base
;
if
(
!
(
rhs
in
this
.
members
)
)
throw
new
IdlHarnessError
(
{
lhs
}
inherits
{
rhs
}
but
{
rhs
}
is
undefined
.
)
;
const
lhs_is_interface
=
this
.
members
[
lhs
]
instanceof
IdlInterface
;
const
rhs_is_interface
=
this
.
members
[
rhs
]
instanceof
IdlInterface
;
if
(
rhs_is_interface
!
=
lhs_is_interface
)
{
if
(
!
lhs_is_interface
)
throw
new
IdlHarnessError
(
{
lhs
}
inherits
{
rhs
}
but
{
lhs
}
is
not
an
interface
.
)
;
if
(
!
rhs_is_interface
)
throw
new
IdlHarnessError
(
{
lhs
}
inherits
{
rhs
}
but
{
rhs
}
is
not
an
interface
.
)
;
}
member
.
get_inheritance_stack
(
)
;
}
Object
.
getOwnPropertyNames
(
this
.
members
)
.
forEach
(
function
(
memberName
)
{
var
member
=
this
.
members
[
memberName
]
;
if
(
!
(
member
instanceof
IdlInterface
)
)
{
return
;
}
var
globals
=
exposure_set
(
member
)
;
member
.
exposed
=
exposed_in
(
globals
)
;
member
.
exposureSet
=
globals
;
}
.
bind
(
this
)
)
;
for
(
var
name
in
this
.
members
)
{
this
.
members
[
name
]
.
test
(
)
;
if
(
name
in
this
.
objects
)
{
this
.
objects
[
name
]
.
forEach
(
function
(
str
)
{
this
.
members
[
name
]
.
test_object
(
str
)
;
}
.
bind
(
this
)
)
;
}
}
}
;
IdlArray
.
prototype
.
collapse_partials
=
function
(
)
{
const
testedPartials
=
new
Map
(
)
;
this
.
partials
.
forEach
(
function
(
parsed_idl
)
{
const
originalExists
=
parsed_idl
.
name
in
this
.
members
&
&
(
this
.
members
[
parsed_idl
.
name
]
instanceof
IdlInterface
|
|
this
.
members
[
parsed_idl
.
name
]
instanceof
IdlDictionary
)
;
let
partialTestName
=
parsed_idl
.
name
;
if
(
!
parsed_idl
.
untested
)
{
let
partialTestCount
=
1
;
if
(
testedPartials
.
has
(
parsed_idl
.
name
)
)
{
partialTestCount
+
=
testedPartials
.
get
(
parsed_idl
.
name
)
;
partialTestName
=
{
partialTestName
}
[
{
partialTestCount
}
]
;
}
testedPartials
.
set
(
parsed_idl
.
name
partialTestCount
)
;
test
(
function
(
)
{
assert_true
(
originalExists
Original
{
parsed_idl
.
type
}
should
be
defined
)
;
}
.
bind
(
this
)
Partial
{
parsed_idl
.
type
}
{
partialTestName
}
:
original
{
parsed_idl
.
type
}
defined
)
;
}
if
(
!
originalExists
)
{
return
;
}
if
(
parsed_idl
.
extAttrs
)
{
const
exposureAttr
=
parsed_idl
.
extAttrs
.
find
(
a
=
>
a
.
name
=
=
=
"
Exposed
"
)
;
if
(
exposureAttr
)
{
if
(
!
parsed_idl
.
untested
)
{
test
(
function
(
)
{
const
partialExposure
=
exposure_set
(
parsed_idl
)
;
const
memberExposure
=
exposure_set
(
this
.
members
[
parsed_idl
.
name
]
)
;
partialExposure
.
forEach
(
name
=
>
{
if
(
!
memberExposure
|
|
!
memberExposure
.
has
(
name
)
)
{
throw
new
IdlHarnessError
(
Partial
{
parsed_idl
.
name
}
{
parsed_idl
.
type
}
is
exposed
to
'
{
name
}
'
the
original
{
parsed_idl
.
type
}
is
not
.
)
;
}
}
)
;
}
.
bind
(
this
)
Partial
{
parsed_idl
.
type
}
{
partialTestName
}
:
valid
exposure
set
)
;
}
parsed_idl
.
members
.
forEach
(
function
(
member
)
{
member
.
extAttrs
.
push
(
exposureAttr
)
;
}
.
bind
(
this
)
)
;
}
parsed_idl
.
extAttrs
.
forEach
(
function
(
extAttr
)
{
if
(
extAttr
.
name
=
=
=
"
Exposed
"
)
{
return
;
}
this
.
members
[
parsed_idl
.
name
]
.
extAttrs
.
push
(
extAttr
)
;
}
.
bind
(
this
)
)
;
}
parsed_idl
.
members
.
forEach
(
function
(
member
)
{
this
.
members
[
parsed_idl
.
name
]
.
members
.
push
(
new
IdlInterfaceMember
(
member
)
)
;
}
.
bind
(
this
)
)
;
}
.
bind
(
this
)
)
;
this
.
partials
=
[
]
;
}
IdlArray
.
prototype
.
assert_type_is
=
function
(
value
type
)
{
if
(
type
.
idlType
in
this
.
members
&
&
this
.
members
[
type
.
idlType
]
instanceof
IdlTypedef
)
{
this
.
assert_type_is
(
value
this
.
members
[
type
.
idlType
]
.
idlType
)
;
return
;
}
if
(
type
.
union
)
{
for
(
var
i
=
0
;
i
<
type
.
idlType
.
length
;
i
+
+
)
{
try
{
this
.
assert_type_is
(
value
type
.
idlType
[
i
]
)
;
return
;
}
catch
(
e
)
{
if
(
e
instanceof
AssertionError
)
{
continue
;
}
throw
e
;
}
}
assert_true
(
false
"
Attribute
has
value
"
+
format_value
(
value
)
+
"
which
doesn
'
t
match
any
of
the
types
in
the
union
"
)
;
}
if
(
type
.
idlType
=
=
"
any
"
)
{
return
;
}
if
(
type
.
nullable
&
&
value
=
=
=
null
)
{
return
;
}
if
(
type
.
array
)
{
return
;
}
if
(
type
.
generic
=
=
=
"
sequence
"
)
{
assert_true
(
Array
.
isArray
(
value
)
"
should
be
an
Array
"
)
;
if
(
!
value
.
length
)
{
return
;
}
this
.
assert_type_is
(
value
[
0
]
type
.
idlType
)
;
return
;
}
if
(
type
.
generic
=
=
=
"
Promise
"
)
{
assert_true
(
"
then
"
in
value
"
Attribute
with
a
Promise
type
should
have
a
then
property
"
)
;
return
;
}
if
(
type
.
generic
=
=
=
"
FrozenArray
"
)
{
assert_true
(
Array
.
isArray
(
value
)
"
Value
should
be
array
"
)
;
assert_true
(
Object
.
isFrozen
(
value
)
"
Value
should
be
frozen
"
)
;
if
(
!
value
.
length
)
{
return
;
}
this
.
assert_type_is
(
value
[
0
]
type
.
idlType
)
;
return
;
}
type
=
type
.
idlType
;
switch
(
type
)
{
case
"
void
"
:
assert_equals
(
value
undefined
)
;
return
;
case
"
boolean
"
:
assert_equals
(
typeof
value
"
boolean
"
)
;
return
;
case
"
byte
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
floor
(
value
)
"
should
be
an
integer
"
)
;
assert_true
(
-
128
<
=
value
&
&
value
<
=
127
"
byte
"
+
value
+
"
should
be
in
range
[
-
128
127
]
"
)
;
return
;
case
"
octet
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
floor
(
value
)
"
should
be
an
integer
"
)
;
assert_true
(
0
<
=
value
&
&
value
<
=
255
"
octet
"
+
value
+
"
should
be
in
range
[
0
255
]
"
)
;
return
;
case
"
short
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
floor
(
value
)
"
should
be
an
integer
"
)
;
assert_true
(
-
32768
<
=
value
&
&
value
<
=
32767
"
short
"
+
value
+
"
should
be
in
range
[
-
32768
32767
]
"
)
;
return
;
case
"
unsigned
short
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
floor
(
value
)
"
should
be
an
integer
"
)
;
assert_true
(
0
<
=
value
&
&
value
<
=
65535
"
unsigned
short
"
+
value
+
"
should
be
in
range
[
0
65535
]
"
)
;
return
;
case
"
long
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
floor
(
value
)
"
should
be
an
integer
"
)
;
assert_true
(
-
2147483648
<
=
value
&
&
value
<
=
2147483647
"
long
"
+
value
+
"
should
be
in
range
[
-
2147483648
2147483647
]
"
)
;
return
;
case
"
unsigned
long
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
Math
.
floor
(
value
)
"
should
be
an
integer
"
)
;
assert_true
(
0
<
=
value
&
&
value
<
=
4294967295
"
unsigned
long
"
+
value
+
"
should
be
in
range
[
0
4294967295
]
"
)
;
return
;
case
"
long
long
"
:
assert_equals
(
typeof
value
"
number
"
)
;
return
;
case
"
unsigned
long
long
"
:
case
"
DOMTimeStamp
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_true
(
0
<
=
value
"
unsigned
long
long
should
be
positive
"
)
;
return
;
case
"
float
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
fround
(
value
)
"
float
rounded
to
32
-
bit
float
should
be
itself
"
)
;
assert_not_equals
(
value
Infinity
)
;
assert_not_equals
(
value
-
Infinity
)
;
assert_not_equals
(
value
NaN
)
;
return
;
case
"
DOMHighResTimeStamp
"
:
case
"
double
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_not_equals
(
value
Infinity
)
;
assert_not_equals
(
value
-
Infinity
)
;
assert_not_equals
(
value
NaN
)
;
return
;
case
"
unrestricted
float
"
:
assert_equals
(
typeof
value
"
number
"
)
;
assert_equals
(
value
fround
(
value
)
"
unrestricted
float
rounded
to
32
-
bit
float
should
be
itself
"
)
;
return
;
case
"
unrestricted
double
"
:
assert_equals
(
typeof
value
"
number
"
)
;
return
;
case
"
DOMString
"
:
assert_equals
(
typeof
value
"
string
"
)
;
return
;
case
"
ByteString
"
:
assert_equals
(
typeof
value
"
string
"
)
;
assert_regexp_match
(
value
/
^
[
\
x00
-
\
x7F
]
*
/
)
;
return
;
case
"
USVString
"
:
assert_equals
(
typeof
value
"
string
"
)
;
assert_regexp_match
(
value
/
^
(
[
\
x00
-
\
ud7ff
\
ue000
-
\
uffff
]
|
[
\
ud800
-
\
udbff
]
[
\
udc00
-
\
udfff
]
)
*
/
)
;
return
;
case
"
object
"
:
assert_in_array
(
typeof
value
[
"
object
"
"
function
"
]
"
wrong
type
:
not
object
or
function
"
)
;
return
;
}
if
(
!
(
type
in
this
.
members
)
)
{
throw
new
IdlHarnessError
(
"
Unrecognized
type
"
+
type
)
;
}
if
(
this
.
members
[
type
]
instanceof
IdlInterface
)
{
assert_in_array
(
typeof
value
[
"
object
"
"
function
"
]
"
wrong
type
:
not
object
or
function
"
)
;
if
(
value
instanceof
Object
&
&
!
this
.
members
[
type
]
.
has_extended_attribute
(
"
NoInterfaceObject
"
)
&
&
type
in
self
)
{
assert_true
(
value
instanceof
self
[
type
]
"
instanceof
"
+
type
)
;
}
}
else
if
(
this
.
members
[
type
]
instanceof
IdlEnum
)
{
assert_equals
(
typeof
value
"
string
"
)
;
}
else
if
(
this
.
members
[
type
]
instanceof
IdlDictionary
)
{
}
else
{
throw
new
IdlHarnessError
(
"
Type
"
+
type
+
"
isn
'
t
an
interface
or
dictionary
"
)
;
}
}
;
function
IdlObject
(
)
{
}
IdlObject
.
prototype
.
test
=
function
(
)
{
}
;
IdlObject
.
prototype
.
has_extended_attribute
=
function
(
name
)
{
return
this
.
extAttrs
.
some
(
function
(
o
)
{
return
o
.
name
=
=
name
;
}
)
;
}
;
function
IdlDictionary
(
obj
)
{
this
.
name
=
obj
.
name
;
this
.
array
=
obj
.
array
;
this
.
members
=
obj
.
members
;
this
.
base
=
obj
.
inheritance
;
}
IdlDictionary
.
prototype
=
Object
.
create
(
IdlObject
.
prototype
)
;
IdlDictionary
.
prototype
.
get_inheritance_stack
=
function
(
)
{
return
IdlInterface
.
prototype
.
get_inheritance_stack
.
call
(
this
)
;
}
;
function
IdlInterface
(
obj
is_callback
is_mixin
)
{
this
.
name
=
obj
.
name
;
this
.
array
=
obj
.
array
;
this
.
untested
=
obj
.
untested
;
this
.
extAttrs
=
obj
.
extAttrs
;
this
.
members
=
obj
.
members
.
map
(
function
(
m
)
{
return
new
IdlInterfaceMember
(
m
)
;
}
)
;
if
(
this
.
has_extended_attribute
(
"
Unforgeable
"
)
)
{
this
.
members
.
filter
(
function
(
m
)
{
return
!
m
[
"
static
"
]
&
&
(
m
.
type
=
=
"
attribute
"
|
|
m
.
type
=
=
"
operation
"
)
;
}
)
.
forEach
(
function
(
m
)
{
return
m
.
isUnforgeable
=
true
;
}
)
;
}
this
.
base
=
obj
.
inheritance
;
this
.
_is_callback
=
is_callback
;
this
.
_is_mixin
=
is_mixin
;
}
IdlInterface
.
prototype
=
Object
.
create
(
IdlObject
.
prototype
)
;
IdlInterface
.
prototype
.
is_callback
=
function
(
)
{
return
this
.
_is_callback
;
}
;
IdlInterface
.
prototype
.
is_mixin
=
function
(
)
{
return
this
.
_is_mixin
;
}
;
IdlInterface
.
prototype
.
has_constants
=
function
(
)
{
return
this
.
members
.
some
(
function
(
member
)
{
return
member
.
type
=
=
=
"
const
"
;
}
)
;
}
;
IdlInterface
.
prototype
.
get_unscopables
=
function
(
)
{
return
this
.
members
.
filter
(
function
(
member
)
{
return
member
.
isUnscopable
;
}
)
;
}
;
IdlInterface
.
prototype
.
is_global
=
function
(
)
{
return
this
.
extAttrs
.
some
(
function
(
attribute
)
{
return
attribute
.
name
=
=
=
"
Global
"
;
}
)
;
}
;
IdlInterface
.
prototype
.
has_to_json_regular_operation
=
function
(
)
{
return
this
.
members
.
some
(
function
(
m
)
{
return
m
.
is_to_json_regular_operation
(
)
;
}
)
;
}
;
IdlInterface
.
prototype
.
has_default_to_json_regular_operation
=
function
(
)
{
return
this
.
members
.
some
(
function
(
m
)
{
return
m
.
is_to_json_regular_operation
(
)
&
&
m
.
has_extended_attribute
(
"
Default
"
)
;
}
)
;
}
;
IdlInterface
.
prototype
.
get_inheritance_stack
=
function
(
)
{
var
stack
=
[
this
]
;
var
idl_interface
=
this
;
while
(
idl_interface
.
base
)
{
var
base
=
this
.
array
.
members
[
idl_interface
.
base
]
;
if
(
!
base
)
{
throw
new
Error
(
idl_interface
.
type
+
"
"
+
idl_interface
.
base
+
"
not
found
(
inherited
by
"
+
idl_interface
.
name
+
"
)
"
)
;
}
else
if
(
stack
.
indexOf
(
base
)
>
-
1
)
{
stack
.
push
(
base
)
;
let
dep_chain
=
stack
.
map
(
i
=
>
i
.
name
)
.
join
(
'
'
)
;
throw
new
IdlHarnessError
(
{
this
.
name
}
has
a
circular
dependency
:
{
dep_chain
}
)
;
}
idl_interface
=
base
;
stack
.
push
(
idl_interface
)
;
}
return
stack
;
}
;
IdlInterface
.
prototype
.
default_to_json_operation
=
function
(
callback
)
{
var
map
=
new
Map
(
)
isDefault
=
false
;
this
.
traverse_inherited_and_consequential_interfaces
(
function
(
I
)
{
if
(
I
.
has_default_to_json_regular_operation
(
)
)
{
isDefault
=
true
;
I
.
members
.
forEach
(
function
(
m
)
{
if
(
!
m
.
static
&
&
m
.
type
=
=
"
attribute
"
&
&
I
.
array
.
is_json_type
(
m
.
idlType
)
)
{
map
.
set
(
m
.
name
m
.
idlType
)
;
}
}
)
;
}
else
if
(
I
.
has_to_json_regular_operation
(
)
)
{
isDefault
=
false
;
}
}
)
;
return
isDefault
?
map
:
null
;
}
;
IdlInterface
.
prototype
.
traverse_inherited_and_consequential_interfaces
=
function
(
callback
)
{
if
(
typeof
callback
!
=
"
function
"
)
{
throw
new
TypeError
(
)
;
}
var
stack
=
this
.
get_inheritance_stack
(
)
;
_traverse_inherited_and_consequential_interfaces
(
stack
callback
)
;
}
;
function
_traverse_inherited_and_consequential_interfaces
(
stack
callback
)
{
var
I
=
stack
.
pop
(
)
;
callback
(
I
)
;
var
mixins
=
I
.
array
[
"
implements
"
]
[
I
.
name
]
|
|
I
.
array
[
"
includes
"
]
[
I
.
name
]
;
if
(
mixins
)
{
mixins
.
forEach
(
function
(
id
)
{
var
mixin
=
I
.
array
.
members
[
id
]
;
if
(
!
mixin
)
{
throw
new
Error
(
"
Interface
"
+
id
+
"
not
found
(
implemented
by
"
+
I
.
name
+
"
)
"
)
;
}
var
interfaces
=
mixin
.
get_inheritance_stack
(
)
;
_traverse_inherited_and_consequential_interfaces
(
interfaces
callback
)
;
}
)
;
}
if
(
stack
.
length
>
0
)
{
_traverse_inherited_and_consequential_interfaces
(
stack
callback
)
;
}
}
IdlInterface
.
prototype
.
test
=
function
(
)
{
if
(
this
.
has_extended_attribute
(
"
NoInterfaceObject
"
)
|
|
this
.
is_mixin
(
)
)
{
return
;
}
if
(
!
this
.
exposed
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_false
(
this
.
name
in
self
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
existence
and
properties
of
interface
object
"
)
;
return
;
}
if
(
!
this
.
untested
)
{
this
.
test_self
(
)
;
}
this
.
test_members
(
)
;
}
;
IdlInterface
.
prototype
.
test_self
=
function
(
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
if
(
this
.
is_callback
(
)
&
&
!
this
.
has_constants
(
)
)
{
return
;
}
assert_own_property
(
self
this
.
name
"
self
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
this
.
name
)
;
assert_false
(
"
get
"
in
desc
"
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
should
not
have
a
setter
"
)
;
assert_true
(
desc
.
writable
"
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
should
be
writable
"
)
;
assert_false
(
desc
.
enumerable
"
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
"
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
should
be
configurable
"
)
;
if
(
this
.
is_callback
(
)
)
{
assert_equals
(
Object
.
getPrototypeOf
(
self
[
this
.
name
]
)
Function
.
prototype
"
prototype
of
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
is
not
Object
.
prototype
"
)
;
return
;
}
assert_class_string
(
self
[
this
.
name
]
"
Function
"
"
class
string
of
"
+
this
.
name
)
;
var
prototype
=
Object
.
getPrototypeOf
(
self
[
this
.
name
]
)
;
if
(
this
.
base
)
{
var
has_interface_object
=
!
this
.
array
.
members
[
this
.
base
]
.
has_extended_attribute
(
"
NoInterfaceObject
"
)
;
if
(
has_interface_object
)
{
assert_own_property
(
self
this
.
base
'
should
inherit
from
'
+
this
.
base
+
'
but
self
has
no
such
property
'
)
;
assert_equals
(
prototype
self
[
this
.
base
]
'
prototype
of
'
+
this
.
name
+
'
is
not
'
+
this
.
base
)
;
}
}
else
{
assert_equals
(
prototype
Function
.
prototype
"
prototype
of
self
'
s
property
"
+
format_value
(
this
.
name
)
+
"
is
not
Function
.
prototype
"
)
;
}
if
(
!
this
.
has_extended_attribute
(
"
Constructor
"
)
)
{
assert_throws
(
new
TypeError
(
)
function
(
)
{
self
[
this
.
name
]
(
)
;
}
.
bind
(
this
)
"
interface
object
didn
'
t
throw
TypeError
when
called
as
a
function
"
)
;
assert_throws
(
new
TypeError
(
)
function
(
)
{
new
self
[
this
.
name
]
(
)
;
}
.
bind
(
this
)
"
interface
object
didn
'
t
throw
TypeError
when
called
as
a
constructor
"
)
;
}
}
.
bind
(
this
)
this
.
name
+
"
interface
:
existence
and
properties
of
interface
object
"
)
;
if
(
!
this
.
is_callback
(
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_own_property
(
self
this
.
name
"
self
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
assert_own_property
(
self
[
this
.
name
]
"
length
"
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
[
this
.
name
]
"
length
"
)
;
assert_false
(
"
get
"
in
desc
this
.
name
+
"
.
length
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
this
.
name
+
"
.
length
should
not
have
a
setter
"
)
;
assert_false
(
desc
.
writable
this
.
name
+
"
.
length
should
not
be
writable
"
)
;
assert_false
(
desc
.
enumerable
this
.
name
+
"
.
length
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
this
.
name
+
"
.
length
should
be
configurable
"
)
;
var
constructors
=
this
.
extAttrs
.
filter
(
function
(
attr
)
{
return
attr
.
name
=
=
"
Constructor
"
;
}
)
;
var
expected_length
=
minOverloadLength
(
constructors
)
;
assert_equals
(
self
[
this
.
name
]
.
length
expected_length
"
wrong
value
for
"
+
this
.
name
+
"
.
length
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
object
length
"
)
;
}
if
(
!
this
.
is_callback
(
)
|
|
this
.
has_constants
(
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_own_property
(
self
this
.
name
"
self
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
assert_own_property
(
self
[
this
.
name
]
"
name
"
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
[
this
.
name
]
"
name
"
)
;
assert_false
(
"
get
"
in
desc
this
.
name
+
"
.
name
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
this
.
name
+
"
.
name
should
not
have
a
setter
"
)
;
assert_false
(
desc
.
writable
this
.
name
+
"
.
name
should
not
be
writable
"
)
;
assert_false
(
desc
.
enumerable
this
.
name
+
"
.
name
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
this
.
name
+
"
.
name
should
be
configurable
"
)
;
assert_equals
(
self
[
this
.
name
]
.
name
this
.
name
"
wrong
value
for
"
+
this
.
name
+
"
.
name
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
object
name
"
)
;
}
if
(
this
.
has_extended_attribute
(
"
LegacyWindowAlias
"
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
aliasAttrs
=
this
.
extAttrs
.
filter
(
function
(
o
)
{
return
o
.
name
=
=
=
"
LegacyWindowAlias
"
;
}
)
;
if
(
aliasAttrs
.
length
>
1
)
{
throw
new
IdlHarnessError
(
"
Invalid
IDL
:
multiple
LegacyWindowAlias
extended
attributes
on
"
+
this
.
name
)
;
}
if
(
this
.
is_callback
(
)
)
{
throw
new
IdlHarnessError
(
"
Invalid
IDL
:
LegacyWindowAlias
extended
attribute
on
non
-
interface
"
+
this
.
name
)
;
}
if
(
!
this
.
exposureSet
.
has
(
"
Window
"
)
)
{
throw
new
IdlHarnessError
(
"
Invalid
IDL
:
LegacyWindowAlias
extended
attribute
on
"
+
this
.
name
+
"
which
is
not
exposed
in
Window
"
)
;
}
var
rhs
=
aliasAttrs
[
0
]
.
rhs
;
if
(
!
rhs
)
{
throw
new
IdlHarnessError
(
"
Invalid
IDL
:
LegacyWindowAlias
extended
attribute
on
"
+
this
.
name
+
"
without
identifier
"
)
;
}
var
aliases
;
if
(
rhs
.
type
=
=
=
"
identifier
-
list
"
)
{
aliases
=
rhs
.
value
;
}
else
{
aliases
=
[
rhs
.
value
]
;
}
var
alias
;
if
(
exposed_in
(
exposure_set
(
this
this
.
exposureSet
)
)
&
&
'
document
'
in
self
)
{
for
(
alias
of
aliases
)
{
assert_true
(
alias
in
self
alias
+
"
should
exist
"
)
;
assert_equals
(
self
[
alias
]
self
[
this
.
name
]
"
self
.
"
+
alias
+
"
should
be
the
same
value
as
self
.
"
+
this
.
name
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
alias
)
;
assert_equals
(
desc
.
value
self
[
this
.
name
]
"
wrong
value
in
"
+
alias
+
"
property
descriptor
"
)
;
assert_true
(
desc
.
writable
alias
+
"
should
be
writable
"
)
;
assert_false
(
desc
.
enumerable
alias
+
"
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
alias
+
"
should
be
configurable
"
)
;
assert_false
(
'
get
'
in
desc
alias
+
"
should
not
have
a
getter
"
)
;
assert_false
(
'
set
'
in
desc
alias
+
"
should
not
have
a
setter
"
)
;
}
}
else
{
for
(
alias
of
aliases
)
{
assert_false
(
alias
in
self
alias
+
"
should
not
exist
"
)
;
}
}
}
.
bind
(
this
)
this
.
name
+
"
interface
:
legacy
window
alias
"
)
;
}
subsetTestByKey
(
this
.
name
test
function
(
)
{
if
(
this
.
is_callback
(
)
&
&
!
this
.
has_constants
(
)
)
{
return
;
}
assert_own_property
(
self
this
.
name
"
self
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
if
(
this
.
is_callback
(
)
)
{
assert_false
(
"
prototype
"
in
self
[
this
.
name
]
this
.
name
+
'
should
not
have
a
"
prototype
"
property
'
)
;
return
;
}
assert_own_property
(
self
[
this
.
name
]
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
[
this
.
name
]
"
prototype
"
)
;
assert_false
(
"
get
"
in
desc
this
.
name
+
"
.
prototype
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
this
.
name
+
"
.
prototype
should
not
have
a
setter
"
)
;
assert_false
(
desc
.
writable
this
.
name
+
"
.
prototype
should
not
be
writable
"
)
;
assert_false
(
desc
.
enumerable
this
.
name
+
"
.
prototype
should
not
be
enumerable
"
)
;
assert_false
(
desc
.
configurable
this
.
name
+
"
.
prototype
should
not
be
configurable
"
)
;
if
(
this
.
name
=
=
=
"
Window
"
)
{
assert_class_string
(
Object
.
getPrototypeOf
(
self
[
this
.
name
]
.
prototype
)
'
WindowProperties
'
'
Class
name
for
prototype
of
Window
'
+
'
.
prototype
is
not
"
WindowProperties
"
'
)
;
}
else
{
var
inherit_interface
inherit_interface_has_interface_object
;
if
(
this
.
base
)
{
inherit_interface
=
this
.
base
;
inherit_interface_has_interface_object
=
!
this
.
array
.
members
[
inherit_interface
]
.
has_extended_attribute
(
"
NoInterfaceObject
"
)
;
}
else
if
(
this
.
name
=
=
=
"
DOMException
"
)
{
inherit_interface
=
'
Error
'
;
inherit_interface_has_interface_object
=
true
;
}
else
{
inherit_interface
=
'
Object
'
;
inherit_interface_has_interface_object
=
true
;
}
if
(
inherit_interface_has_interface_object
)
{
assert_own_property
(
self
inherit_interface
'
should
inherit
from
'
+
inherit_interface
+
'
but
self
has
no
such
property
'
)
;
assert_own_property
(
self
[
inherit_interface
]
'
prototype
'
'
should
inherit
from
'
+
inherit_interface
+
'
but
that
object
has
no
"
prototype
"
property
'
)
;
assert_equals
(
Object
.
getPrototypeOf
(
self
[
this
.
name
]
.
prototype
)
self
[
inherit_interface
]
.
prototype
'
prototype
of
'
+
this
.
name
+
'
.
prototype
is
not
'
+
inherit_interface
+
'
.
prototype
'
)
;
}
else
{
assert_class_string
(
Object
.
getPrototypeOf
(
self
[
this
.
name
]
.
prototype
)
inherit_interface
+
'
Prototype
'
'
Class
name
for
prototype
of
'
+
this
.
name
+
'
.
prototype
is
not
"
'
+
inherit_interface
+
'
Prototype
"
'
)
;
}
}
if
(
!
this
.
has_stringifier
(
)
)
{
}
}
.
bind
(
this
)
this
.
name
+
"
interface
:
existence
and
properties
of
interface
prototype
object
"
)
;
if
(
this
.
is_global
(
)
)
{
this
.
test_immutable_prototype
(
"
interface
prototype
object
"
self
[
this
.
name
]
.
prototype
)
;
}
subsetTestByKey
(
this
.
name
test
function
(
)
{
if
(
this
.
is_callback
(
)
&
&
!
this
.
has_constants
(
)
)
{
return
;
}
assert_own_property
(
self
this
.
name
"
self
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
if
(
this
.
is_callback
(
)
)
{
assert_false
(
"
prototype
"
in
self
[
this
.
name
]
this
.
name
+
'
should
not
have
a
"
prototype
"
property
'
)
;
return
;
}
assert_own_property
(
self
[
this
.
name
]
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
assert_own_property
(
self
[
this
.
name
]
.
prototype
"
constructor
"
this
.
name
+
'
.
prototype
does
not
have
own
property
"
constructor
"
'
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
[
this
.
name
]
.
prototype
"
constructor
"
)
;
assert_false
(
"
get
"
in
desc
this
.
name
+
"
.
prototype
.
constructor
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
this
.
name
+
"
.
prototype
.
constructor
should
not
have
a
setter
"
)
;
assert_true
(
desc
.
writable
this
.
name
+
"
.
prototype
.
constructor
should
be
writable
"
)
;
assert_false
(
desc
.
enumerable
this
.
name
+
"
.
prototype
.
constructor
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
this
.
name
+
"
.
prototype
.
constructor
should
be
configurable
"
)
;
assert_equals
(
self
[
this
.
name
]
.
prototype
.
constructor
self
[
this
.
name
]
this
.
name
+
'
.
prototype
.
constructor
is
not
the
same
object
as
'
+
this
.
name
)
;
}
.
bind
(
this
)
this
.
name
+
'
interface
:
existence
and
properties
of
interface
prototype
object
\
'
s
"
constructor
"
property
'
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
if
(
this
.
is_callback
(
)
&
&
!
this
.
has_constants
(
)
)
{
return
;
}
assert_own_property
(
self
this
.
name
"
self
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
if
(
this
.
is_callback
(
)
)
{
assert_false
(
"
prototype
"
in
self
[
this
.
name
]
this
.
name
+
'
should
not
have
a
"
prototype
"
property
'
)
;
return
;
}
assert_own_property
(
self
[
this
.
name
]
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
var
unscopables
=
this
.
get_unscopables
(
)
.
map
(
m
=
>
m
.
name
)
;
var
proto
=
self
[
this
.
name
]
.
prototype
;
if
(
unscopables
.
length
!
=
0
)
{
assert_own_property
(
proto
Symbol
.
unscopables
this
.
name
+
'
.
prototype
should
have
an
unscopables
property
'
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
proto
Symbol
.
unscopables
)
;
assert_false
(
"
get
"
in
desc
this
.
name
+
"
.
prototype
[
Symbol
.
unscopables
]
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
this
.
name
+
"
.
prototype
[
Symbol
.
unscopables
]
should
not
have
a
setter
"
)
;
assert_false
(
desc
.
writable
this
.
name
+
"
.
prototype
[
Symbol
.
unscopables
]
should
not
be
writable
"
)
;
assert_false
(
desc
.
enumerable
this
.
name
+
"
.
prototype
[
Symbol
.
unscopables
]
should
not
be
enumerable
"
)
;
assert_true
(
desc
.
configurable
this
.
name
+
"
.
prototype
[
Symbol
.
unscopables
]
should
be
configurable
"
)
;
assert_equals
(
desc
.
value
proto
[
Symbol
.
unscopables
]
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
should
be
in
the
descriptor
'
)
;
assert_equals
(
typeof
desc
.
value
"
object
"
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
should
be
an
object
'
)
;
assert_equals
(
Object
.
getPrototypeOf
(
desc
.
value
)
null
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
should
have
a
null
prototype
'
)
;
assert_equals
(
Object
.
getOwnPropertySymbols
(
desc
.
value
)
.
length
0
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
should
have
the
right
number
of
symbol
-
named
properties
'
)
;
}
else
{
}
}
.
bind
(
this
)
this
.
name
+
'
interface
:
existence
and
properties
of
interface
prototype
object
\
'
s
unscopables
property
'
)
;
}
;
IdlInterface
.
prototype
.
test_immutable_prototype
=
function
(
type
obj
)
{
if
(
typeof
Object
.
setPrototypeOf
!
=
=
"
function
"
)
{
return
;
}
subsetTestByKey
(
this
.
name
test
function
(
t
)
{
var
originalValue
=
Object
.
getPrototypeOf
(
obj
)
;
var
newValue
=
Object
.
create
(
null
)
;
t
.
add_cleanup
(
function
(
)
{
try
{
Object
.
setPrototypeOf
(
obj
originalValue
)
;
}
catch
(
err
)
{
}
}
)
;
assert_throws
(
new
TypeError
(
)
function
(
)
{
Object
.
setPrototypeOf
(
obj
newValue
)
;
}
)
;
assert_equals
(
Object
.
getPrototypeOf
(
obj
)
originalValue
"
original
value
not
modified
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
internal
[
[
SetPrototypeOf
]
]
method
"
+
"
of
"
+
type
+
"
-
setting
to
a
new
value
via
Object
.
setPrototypeOf
"
+
"
should
throw
a
TypeError
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
t
)
{
var
originalValue
=
Object
.
getPrototypeOf
(
obj
)
;
var
newValue
=
Object
.
create
(
null
)
;
t
.
add_cleanup
(
function
(
)
{
var
setter
=
Object
.
getOwnPropertyDescriptor
(
Object
.
prototype
'
__proto__
'
)
.
set
;
try
{
setter
.
call
(
obj
originalValue
)
;
}
catch
(
err
)
{
}
}
)
;
assert_throws
(
new
TypeError
(
)
function
(
)
{
obj
.
__proto__
=
newValue
;
}
)
;
assert_equals
(
Object
.
getPrototypeOf
(
obj
)
originalValue
"
original
value
not
modified
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
internal
[
[
SetPrototypeOf
]
]
method
"
+
"
of
"
+
type
+
"
-
setting
to
a
new
value
via
__proto__
"
+
"
should
throw
a
TypeError
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
t
)
{
var
originalValue
=
Object
.
getPrototypeOf
(
obj
)
;
var
newValue
=
Object
.
create
(
null
)
;
t
.
add_cleanup
(
function
(
)
{
try
{
Reflect
.
setPrototypeOf
(
obj
originalValue
)
;
}
catch
(
err
)
{
}
}
)
;
assert_false
(
Reflect
.
setPrototypeOf
(
obj
newValue
)
)
;
assert_equals
(
Object
.
getPrototypeOf
(
obj
)
originalValue
"
original
value
not
modified
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
internal
[
[
SetPrototypeOf
]
]
method
"
+
"
of
"
+
type
+
"
-
setting
to
a
new
value
via
Reflect
.
setPrototypeOf
"
+
"
should
return
false
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
originalValue
=
Object
.
getPrototypeOf
(
obj
)
;
Object
.
setPrototypeOf
(
obj
originalValue
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
internal
[
[
SetPrototypeOf
]
]
method
"
+
"
of
"
+
type
+
"
-
setting
to
its
original
value
via
Object
.
setPrototypeOf
"
+
"
should
not
throw
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
originalValue
=
Object
.
getPrototypeOf
(
obj
)
;
obj
.
__proto__
=
originalValue
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
internal
[
[
SetPrototypeOf
]
]
method
"
+
"
of
"
+
type
+
"
-
setting
to
its
original
value
via
__proto__
"
+
"
should
not
throw
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
originalValue
=
Object
.
getPrototypeOf
(
obj
)
;
assert_true
(
Reflect
.
setPrototypeOf
(
obj
originalValue
)
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
internal
[
[
SetPrototypeOf
]
]
method
"
+
"
of
"
+
type
+
"
-
setting
to
its
original
value
via
Reflect
.
setPrototypeOf
"
+
"
should
return
true
"
)
;
}
;
IdlInterface
.
prototype
.
test_member_const
=
function
(
member
)
{
if
(
!
this
.
has_constants
(
)
)
{
throw
new
IdlHarnessError
(
"
Internal
error
:
test_member_const
called
without
any
constants
"
)
;
}
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_own_property
(
self
this
.
name
"
self
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
assert_own_property
(
self
[
this
.
name
]
member
.
name
)
;
assert_equals
(
self
[
this
.
name
]
[
member
.
name
]
constValue
(
member
.
value
)
"
property
has
wrong
value
"
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
[
this
.
name
]
member
.
name
)
;
assert_false
(
"
get
"
in
desc
"
property
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
property
should
not
have
a
setter
"
)
;
assert_false
(
desc
.
writable
"
property
should
not
be
writable
"
)
;
assert_true
(
desc
.
enumerable
"
property
should
be
enumerable
"
)
;
assert_false
(
desc
.
configurable
"
property
should
not
be
configurable
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
constant
"
+
member
.
name
+
"
on
interface
object
"
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_own_property
(
self
this
.
name
"
self
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
if
(
this
.
is_callback
(
)
)
{
assert_false
(
"
prototype
"
in
self
[
this
.
name
]
this
.
name
+
'
should
not
have
a
"
prototype
"
property
'
)
;
return
;
}
assert_own_property
(
self
[
this
.
name
]
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
assert_own_property
(
self
[
this
.
name
]
.
prototype
member
.
name
)
;
assert_equals
(
self
[
this
.
name
]
.
prototype
[
member
.
name
]
constValue
(
member
.
value
)
"
property
has
wrong
value
"
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
self
[
this
.
name
]
member
.
name
)
;
assert_false
(
"
get
"
in
desc
"
property
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
property
should
not
have
a
setter
"
)
;
assert_false
(
desc
.
writable
"
property
should
not
be
writable
"
)
;
assert_true
(
desc
.
enumerable
"
property
should
be
enumerable
"
)
;
assert_false
(
desc
.
configurable
"
property
should
not
be
configurable
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
constant
"
+
member
.
name
+
"
on
interface
prototype
object
"
)
;
}
;
IdlInterface
.
prototype
.
test_member_attribute
=
function
(
member
)
{
if
(
!
shouldRunSubTest
(
this
.
name
)
)
{
return
;
}
var
a_test
=
subsetTestByKey
(
this
.
name
async_test
this
.
name
+
"
interface
:
attribute
"
+
member
.
name
)
;
a_test
.
step
(
function
(
)
{
if
(
this
.
is_callback
(
)
&
&
!
this
.
has_constants
(
)
)
{
a_test
.
done
(
)
return
;
}
assert_own_property
(
self
this
.
name
"
self
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
assert_own_property
(
self
[
this
.
name
]
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
if
(
member
[
"
static
"
]
)
{
assert_own_property
(
self
[
this
.
name
]
member
.
name
"
The
interface
object
must
have
a
property
"
+
format_value
(
member
.
name
)
)
;
a_test
.
done
(
)
;
}
else
if
(
this
.
is_global
(
)
)
{
assert_own_property
(
self
member
.
name
"
The
global
object
must
have
a
property
"
+
format_value
(
member
.
name
)
)
;
assert_false
(
member
.
name
in
self
[
this
.
name
]
.
prototype
"
The
prototype
object
should
not
have
a
property
"
+
format_value
(
member
.
name
)
)
;
var
getter
=
Object
.
getOwnPropertyDescriptor
(
self
member
.
name
)
.
get
;
assert_equals
(
typeof
(
getter
)
"
function
"
format_value
(
member
.
name
)
+
"
must
have
a
getter
"
)
;
var
gotValue
;
var
propVal
;
try
{
propVal
=
self
[
member
.
name
]
;
gotValue
=
true
;
}
catch
(
e
)
{
gotValue
=
false
;
}
if
(
gotValue
)
{
assert_equals
(
propVal
getter
.
call
(
undefined
)
"
Gets
on
a
global
should
not
require
an
explicit
this
"
)
;
}
this
.
do_interface_attribute_asserts
(
self
member
a_test
)
;
}
else
{
assert_true
(
member
.
name
in
self
[
this
.
name
]
.
prototype
"
The
prototype
object
must
have
a
property
"
+
format_value
(
member
.
name
)
)
;
if
(
!
member
.
has_extended_attribute
(
"
LenientThis
"
)
)
{
if
(
member
.
idlType
.
generic
!
=
=
"
Promise
"
)
{
assert_throws
(
new
TypeError
(
)
function
(
)
{
self
[
this
.
name
]
.
prototype
[
member
.
name
]
;
}
.
bind
(
this
)
"
getting
property
on
prototype
object
must
throw
TypeError
"
)
;
this
.
do_interface_attribute_asserts
(
self
[
this
.
name
]
.
prototype
member
a_test
)
;
}
else
{
promise_rejects
(
a_test
new
TypeError
(
)
self
[
this
.
name
]
.
prototype
[
member
.
name
]
)
.
then
(
function
(
)
{
this
.
do_interface_attribute_asserts
(
self
[
this
.
name
]
.
prototype
member
a_test
)
;
}
.
bind
(
this
)
)
;
}
}
else
{
assert_equals
(
self
[
this
.
name
]
.
prototype
[
member
.
name
]
undefined
"
getting
property
on
prototype
object
must
return
undefined
"
)
;
this
.
do_interface_attribute_asserts
(
self
[
this
.
name
]
.
prototype
member
a_test
)
;
}
}
}
.
bind
(
this
)
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
this
.
do_member_unscopable_asserts
(
member
)
;
}
.
bind
(
this
)
'
Unscopable
handled
correctly
for
'
+
member
.
name
+
'
property
on
'
+
this
.
name
)
;
}
;
IdlInterface
.
prototype
.
test_member_operation
=
function
(
member
)
{
if
(
!
shouldRunSubTest
(
this
.
name
)
)
{
return
;
}
var
a_test
=
subsetTestByKey
(
this
.
name
async_test
this
.
name
+
"
interface
:
operation
"
+
member
.
name
+
"
(
"
+
member
.
arguments
.
map
(
function
(
m
)
{
return
m
.
idlType
.
idlType
;
}
)
.
join
(
"
"
)
+
"
)
"
)
;
a_test
.
step
(
function
(
)
{
if
(
this
.
is_callback
(
)
&
&
!
this
.
has_constants
(
)
)
{
a_test
.
done
(
)
;
return
;
}
assert_own_property
(
self
this
.
name
"
self
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
if
(
this
.
is_callback
(
)
)
{
assert_false
(
"
prototype
"
in
self
[
this
.
name
]
this
.
name
+
'
should
not
have
a
"
prototype
"
property
'
)
;
a_test
.
done
(
)
;
return
;
}
assert_own_property
(
self
[
this
.
name
]
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
var
memberHolderObject
;
if
(
member
[
"
static
"
]
)
{
assert_own_property
(
self
[
this
.
name
]
member
.
name
"
interface
object
missing
static
operation
"
)
;
memberHolderObject
=
self
[
this
.
name
]
;
}
else
if
(
this
.
is_global
(
)
)
{
assert_own_property
(
self
member
.
name
"
global
object
missing
non
-
static
operation
"
)
;
memberHolderObject
=
self
;
}
else
{
assert_own_property
(
self
[
this
.
name
]
.
prototype
member
.
name
"
interface
prototype
object
missing
non
-
static
operation
"
)
;
memberHolderObject
=
self
[
this
.
name
]
.
prototype
;
}
this
.
do_member_operation_asserts
(
memberHolderObject
member
a_test
)
;
}
.
bind
(
this
)
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
this
.
do_member_unscopable_asserts
(
member
)
;
}
.
bind
(
this
)
'
Unscopable
handled
correctly
for
'
+
member
.
name
+
"
(
"
+
member
.
arguments
.
map
(
function
(
m
)
{
return
m
.
idlType
.
idlType
;
}
)
.
join
(
"
"
)
+
"
)
"
+
'
on
'
+
this
.
name
)
;
}
;
IdlInterface
.
prototype
.
do_member_unscopable_asserts
=
function
(
member
)
{
if
(
!
member
.
isUnscopable
)
{
return
;
}
var
unscopables
=
self
[
this
.
name
]
.
prototype
[
Symbol
.
unscopables
]
;
assert_equals
(
typeof
unscopables
"
object
"
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
must
exist
'
)
;
var
prop
=
member
.
name
;
var
propDesc
=
Object
.
getOwnPropertyDescriptor
(
unscopables
prop
)
;
assert_equals
(
typeof
propDesc
"
object
"
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
exist
'
)
assert_false
(
"
get
"
in
propDesc
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
have
no
getter
'
)
;
assert_false
(
"
set
"
in
propDesc
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
have
no
setter
'
)
;
assert_true
(
propDesc
.
writable
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
be
writable
'
)
;
assert_true
(
propDesc
.
enumerable
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
be
enumerable
'
)
;
assert_true
(
propDesc
.
configurable
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
be
configurable
'
)
;
assert_equals
(
propDesc
.
value
true
this
.
name
+
'
.
prototype
[
Symbol
.
unscopables
]
.
'
+
prop
+
'
must
have
the
value
true
'
)
;
}
;
IdlInterface
.
prototype
.
do_member_operation_asserts
=
function
(
memberHolderObject
member
a_test
)
{
var
done
=
a_test
.
done
.
bind
(
a_test
)
;
var
operationUnforgeable
=
member
.
isUnforgeable
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
memberHolderObject
member
.
name
)
;
assert_false
(
"
get
"
in
desc
"
property
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
property
should
not
have
a
setter
"
)
;
assert_equals
(
desc
.
writable
!
operationUnforgeable
"
property
should
be
writable
if
and
only
if
not
unforgeable
"
)
;
assert_true
(
desc
.
enumerable
"
property
should
be
enumerable
"
)
;
assert_equals
(
desc
.
configurable
!
operationUnforgeable
"
property
should
be
configurable
if
and
only
if
not
unforgeable
"
)
;
assert_equals
(
typeof
memberHolderObject
[
member
.
name
]
"
function
"
"
property
must
be
a
function
"
)
;
assert_equals
(
memberHolderObject
[
member
.
name
]
.
length
minOverloadLength
(
this
.
members
.
filter
(
function
(
m
)
{
return
m
.
type
=
=
"
operation
"
&
&
m
.
name
=
=
member
.
name
;
}
)
)
"
property
has
wrong
.
length
"
)
;
var
args
=
member
.
arguments
.
map
(
function
(
arg
)
{
return
create_suitable_object
(
arg
.
idlType
)
;
}
)
;
if
(
!
member
[
"
static
"
]
)
{
var
cb
;
if
(
!
this
.
is_global
(
)
&
&
memberHolderObject
[
member
.
name
]
!
=
self
[
member
.
name
]
)
{
cb
=
awaitNCallbacks
(
2
done
)
;
throwOrReject
(
a_test
member
memberHolderObject
[
member
.
name
]
null
args
"
calling
operation
with
this
=
null
didn
'
t
throw
TypeError
"
cb
)
;
}
else
{
cb
=
awaitNCallbacks
(
1
done
)
;
}
throwOrReject
(
a_test
member
memberHolderObject
[
member
.
name
]
{
}
args
"
calling
operation
with
this
=
{
}
didn
'
t
throw
TypeError
"
cb
)
;
}
else
{
done
(
)
;
}
}
IdlInterface
.
prototype
.
add_iterable_members
=
function
(
member
)
{
this
.
members
.
push
(
new
IdlInterfaceMember
(
{
type
:
"
operation
"
name
:
"
entries
"
idlType
:
"
iterator
"
arguments
:
[
]
}
)
)
;
this
.
members
.
push
(
new
IdlInterfaceMember
(
{
type
:
"
operation
"
name
:
"
keys
"
idlType
:
"
iterator
"
arguments
:
[
]
}
)
)
;
this
.
members
.
push
(
new
IdlInterfaceMember
(
{
type
:
"
operation
"
name
:
"
values
"
idlType
:
"
iterator
"
arguments
:
[
]
}
)
)
;
this
.
members
.
push
(
new
IdlInterfaceMember
(
{
type
:
"
operation
"
name
:
"
forEach
"
idlType
:
"
void
"
arguments
:
[
{
name
:
"
callback
"
idlType
:
{
idlType
:
"
function
"
}
}
{
name
:
"
thisValue
"
idlType
:
{
idlType
:
"
any
"
}
optional
:
true
}
]
}
)
)
;
}
;
IdlInterface
.
prototype
.
test_to_json_operation
=
function
(
memberHolderObject
member
)
{
var
instanceName
=
memberHolderObject
.
constructor
.
name
;
if
(
member
.
has_extended_attribute
(
"
Default
"
)
)
{
var
map
=
this
.
default_to_json_operation
(
)
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
json
=
memberHolderObject
.
toJSON
(
)
;
map
.
forEach
(
function
(
type
k
)
{
assert_true
(
k
in
json
"
property
"
+
JSON
.
stringify
(
k
)
+
"
should
be
present
in
the
output
of
"
+
this
.
name
+
"
.
prototype
.
toJSON
(
)
"
)
;
var
descriptor
=
Object
.
getOwnPropertyDescriptor
(
json
k
)
;
assert_true
(
descriptor
.
writable
"
property
"
+
k
+
"
should
be
writable
"
)
;
assert_true
(
descriptor
.
configurable
"
property
"
+
k
+
"
should
be
configurable
"
)
;
assert_true
(
descriptor
.
enumerable
"
property
"
+
k
+
"
should
be
enumerable
"
)
;
this
.
array
.
assert_type_is
(
json
[
k
]
type
)
;
delete
json
[
k
]
;
}
this
)
;
}
.
bind
(
this
)
"
Test
default
toJSON
operation
of
"
+
instanceName
)
;
}
else
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_true
(
this
.
array
.
is_json_type
(
member
.
idlType
)
JSON
.
stringify
(
member
.
idlType
)
+
"
is
not
an
appropriate
return
value
for
the
toJSON
operation
of
"
+
instanceName
)
;
this
.
array
.
assert_type_is
(
memberHolderObject
.
toJSON
(
)
member
.
idlType
)
;
}
.
bind
(
this
)
"
Test
toJSON
operation
of
"
+
instanceName
)
;
}
}
;
IdlInterface
.
prototype
.
test_member_iterable
=
function
(
member
)
{
var
interfaceName
=
this
.
name
;
var
isPairIterator
=
member
.
idlType
.
length
=
=
=
2
;
subsetTestByKey
(
this
.
name
test
function
(
)
{
var
descriptor
=
Object
.
getOwnPropertyDescriptor
(
self
[
interfaceName
]
.
prototype
Symbol
.
iterator
)
;
assert_true
(
descriptor
.
writable
"
property
should
be
writable
"
)
;
assert_true
(
descriptor
.
configurable
"
property
should
be
configurable
"
)
;
assert_false
(
descriptor
.
enumerable
"
property
should
not
be
enumerable
"
)
;
assert_equals
(
self
[
interfaceName
]
.
prototype
[
Symbol
.
iterator
]
.
name
isPairIterator
?
"
entries
"
:
"
values
"
"
iterator
function
does
not
have
the
right
name
"
)
;
}
"
Testing
Symbol
.
iterator
property
of
iterable
interface
"
+
interfaceName
)
;
if
(
isPairIterator
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_equals
(
self
[
interfaceName
]
.
prototype
[
Symbol
.
iterator
]
self
[
interfaceName
]
.
prototype
[
"
entries
"
]
"
entries
method
is
not
the
same
as
iterator
"
)
;
}
"
Testing
pair
iterable
interface
"
+
interfaceName
)
;
}
else
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
[
"
entries
"
"
keys
"
"
values
"
"
forEach
"
Symbol
.
Iterator
]
.
forEach
(
function
(
property
)
{
assert_equals
(
self
[
interfaceName
]
.
prototype
[
property
]
Array
.
prototype
[
property
]
property
+
"
function
is
not
the
same
as
Array
one
"
)
;
}
)
;
}
"
Testing
value
iterable
interface
"
+
interfaceName
)
;
}
}
;
IdlInterface
.
prototype
.
test_member_stringifier
=
function
(
member
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
if
(
this
.
is_callback
(
)
&
&
!
this
.
has_constants
(
)
)
{
return
;
}
assert_own_property
(
self
this
.
name
"
self
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
if
(
this
.
is_callback
(
)
)
{
assert_false
(
"
prototype
"
in
self
[
this
.
name
]
this
.
name
+
'
should
not
have
a
"
prototype
"
property
'
)
;
return
;
}
assert_own_property
(
self
[
this
.
name
]
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
var
interfacePrototypeObject
=
self
[
this
.
name
]
.
prototype
;
assert_own_property
(
self
[
this
.
name
]
.
prototype
"
toString
"
"
interface
prototype
object
missing
non
-
static
operation
"
)
;
var
stringifierUnforgeable
=
member
.
isUnforgeable
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
interfacePrototypeObject
"
toString
"
)
;
assert_false
(
"
get
"
in
desc
"
property
should
not
have
a
getter
"
)
;
assert_false
(
"
set
"
in
desc
"
property
should
not
have
a
setter
"
)
;
assert_equals
(
desc
.
writable
!
stringifierUnforgeable
"
property
should
be
writable
if
and
only
if
not
unforgeable
"
)
;
assert_true
(
desc
.
enumerable
"
property
should
be
enumerable
"
)
;
assert_equals
(
desc
.
configurable
!
stringifierUnforgeable
"
property
should
be
configurable
if
and
only
if
not
unforgeable
"
)
;
assert_equals
(
typeof
interfacePrototypeObject
.
toString
"
function
"
"
property
must
be
a
function
"
)
;
assert_equals
(
interfacePrototypeObject
.
toString
.
length
0
"
property
has
wrong
.
length
"
)
;
assert_throws
(
new
TypeError
(
)
function
(
)
{
self
[
this
.
name
]
.
prototype
.
toString
.
apply
(
null
[
]
)
;
}
"
calling
stringifier
with
this
=
null
didn
'
t
throw
TypeError
"
)
;
assert_throws
(
new
TypeError
(
)
function
(
)
{
self
[
this
.
name
]
.
prototype
.
toString
.
apply
(
{
}
[
]
)
;
}
"
calling
stringifier
with
this
=
{
}
didn
'
t
throw
TypeError
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
stringifier
"
)
;
}
;
IdlInterface
.
prototype
.
test_members
=
function
(
)
{
for
(
var
i
=
0
;
i
<
this
.
members
.
length
;
i
+
+
)
{
var
member
=
this
.
members
[
i
]
;
switch
(
member
.
type
)
{
case
"
iterable
"
:
this
.
add_iterable_members
(
member
)
;
break
;
default
:
break
;
}
}
for
(
var
i
=
0
;
i
<
this
.
members
.
length
;
i
+
+
)
{
var
member
=
this
.
members
[
i
]
;
if
(
member
.
untested
)
{
continue
;
}
if
(
!
exposed_in
(
exposure_set
(
member
this
.
exposureSet
)
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_false
(
member
.
name
in
self
[
this
.
name
]
"
The
interface
object
must
not
have
a
property
"
+
format_value
(
member
.
name
)
)
;
assert_false
(
member
.
name
in
self
[
this
.
name
]
.
prototype
"
The
prototype
object
must
not
have
a
property
"
+
format_value
(
member
.
name
)
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
member
"
+
member
.
name
)
;
continue
;
}
switch
(
member
.
type
)
{
case
"
const
"
:
this
.
test_member_const
(
member
)
;
break
;
case
"
attribute
"
:
if
(
!
member
.
isUnforgeable
)
{
this
.
test_member_attribute
(
member
)
;
}
if
(
member
.
stringifier
)
{
this
.
test_member_stringifier
(
member
)
;
}
break
;
case
"
operation
"
:
if
(
member
.
name
)
{
if
(
!
member
.
isUnforgeable
)
{
this
.
test_member_operation
(
member
)
;
}
}
else
if
(
member
.
stringifier
)
{
this
.
test_member_stringifier
(
member
)
;
}
break
;
case
"
iterable
"
:
this
.
test_member_iterable
(
member
)
;
break
;
default
:
break
;
}
}
}
;
IdlInterface
.
prototype
.
test_object
=
function
(
desc
)
{
var
obj
exception
=
null
;
try
{
obj
=
eval
(
desc
)
;
}
catch
(
e
)
{
exception
=
e
;
}
var
expected_typeof
=
this
.
members
.
some
(
function
(
member
)
{
return
member
.
legacycaller
;
}
)
?
"
function
"
:
"
object
"
;
this
.
test_primary_interface_of
(
desc
obj
exception
expected_typeof
)
;
var
current_interface
=
this
;
while
(
current_interface
)
{
if
(
!
(
current_interface
.
name
in
this
.
array
.
members
)
)
{
throw
new
IdlHarnessError
(
"
Interface
"
+
current_interface
.
name
+
"
not
found
(
inherited
by
"
+
this
.
name
+
"
)
"
)
;
}
if
(
current_interface
.
prevent_multiple_testing
&
&
current_interface
.
already_tested
)
{
return
;
}
current_interface
.
test_interface_of
(
desc
obj
exception
expected_typeof
)
;
current_interface
=
this
.
array
.
members
[
current_interface
.
base
]
;
}
}
;
IdlInterface
.
prototype
.
test_primary_interface_of
=
function
(
desc
obj
exception
expected_typeof
)
{
if
(
this
.
untested
)
{
return
;
}
if
(
this
.
is_global
(
)
)
{
this
.
test_immutable_prototype
(
"
global
platform
object
"
obj
)
;
}
if
(
!
this
.
has_extended_attribute
(
"
NoInterfaceObject
"
)
&
&
(
typeof
obj
!
=
expected_typeof
|
|
obj
instanceof
Object
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_equals
(
typeof
obj
expected_typeof
"
wrong
typeof
object
"
)
;
assert_own_property
(
self
this
.
name
"
self
does
not
have
own
property
"
+
format_value
(
this
.
name
)
)
;
assert_own_property
(
self
[
this
.
name
]
"
prototype
"
'
interface
"
'
+
this
.
name
+
'
"
does
not
have
own
property
"
prototype
"
'
)
;
assert_equals
(
Object
.
getPrototypeOf
(
obj
)
self
[
this
.
name
]
.
prototype
desc
+
"
'
s
prototype
is
not
"
+
this
.
name
+
"
.
prototype
"
)
;
}
.
bind
(
this
)
this
.
name
+
"
must
be
primary
interface
of
"
+
desc
)
;
}
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_equals
(
typeof
obj
expected_typeof
"
wrong
typeof
object
"
)
;
assert_class_string
(
obj
this
.
name
"
class
string
of
"
+
desc
)
;
if
(
!
this
.
has_stringifier
(
)
)
{
assert_equals
(
String
(
obj
)
"
[
object
"
+
this
.
name
+
"
]
"
"
String
(
"
+
desc
+
"
)
"
)
;
}
}
.
bind
(
this
)
"
Stringification
of
"
+
desc
)
;
}
;
IdlInterface
.
prototype
.
test_interface_of
=
function
(
desc
obj
exception
expected_typeof
)
{
this
.
already_tested
=
true
;
if
(
!
shouldRunSubTest
(
this
.
name
)
)
{
return
;
}
for
(
var
i
=
0
;
i
<
this
.
members
.
length
;
i
+
+
)
{
var
member
=
this
.
members
[
i
]
;
if
(
member
.
untested
)
{
continue
;
}
if
(
!
exposed_in
(
exposure_set
(
member
this
.
exposureSet
)
)
)
{
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_false
(
member
.
name
in
obj
)
;
}
.
bind
(
this
)
this
.
name
+
"
interface
:
"
+
desc
+
'
must
not
have
property
"
'
+
member
.
name
+
'
"
'
)
;
continue
;
}
if
(
member
.
type
=
=
"
attribute
"
&
&
member
.
isUnforgeable
)
{
var
a_test
=
subsetTestByKey
(
this
.
name
async_test
this
.
name
+
"
interface
:
"
+
desc
+
'
must
have
own
property
"
'
+
member
.
name
+
'
"
'
)
;
a_test
.
step
(
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_equals
(
typeof
obj
expected_typeof
"
wrong
typeof
object
"
)
;
this
.
do_interface_attribute_asserts
(
obj
member
a_test
)
;
}
.
bind
(
this
)
)
;
}
else
if
(
member
.
type
=
=
"
operation
"
&
&
member
.
name
&
&
member
.
isUnforgeable
)
{
var
a_test
=
subsetTestByKey
(
this
.
name
async_test
this
.
name
+
"
interface
:
"
+
desc
+
'
must
have
own
property
"
'
+
member
.
name
+
'
"
'
)
;
a_test
.
step
(
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_equals
(
typeof
obj
expected_typeof
"
wrong
typeof
object
"
)
;
assert_own_property
(
obj
member
.
name
"
Doesn
'
t
have
the
unforgeable
operation
property
"
)
;
this
.
do_member_operation_asserts
(
obj
member
a_test
)
;
}
.
bind
(
this
)
)
;
}
else
if
(
(
member
.
type
=
=
"
const
"
|
|
member
.
type
=
=
"
attribute
"
|
|
member
.
type
=
=
"
operation
"
)
&
&
member
.
name
)
{
var
described_name
=
member
.
name
;
if
(
member
.
type
=
=
"
operation
"
)
{
described_name
+
=
"
(
"
+
member
.
arguments
.
map
(
arg
=
>
arg
.
idlType
.
idlType
)
.
join
(
"
"
)
+
"
)
"
;
}
subsetTestByKey
(
this
.
name
test
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_equals
(
typeof
obj
expected_typeof
"
wrong
typeof
object
"
)
;
if
(
!
member
[
"
static
"
]
)
{
if
(
!
this
.
is_global
(
)
)
{
assert_inherits
(
obj
member
.
name
)
;
}
else
{
assert_own_property
(
obj
member
.
name
)
;
}
if
(
member
.
type
=
=
"
const
"
)
{
assert_equals
(
obj
[
member
.
name
]
constValue
(
member
.
value
)
)
;
}
if
(
member
.
type
=
=
"
attribute
"
)
{
var
property
thrown
=
false
;
try
{
property
=
obj
[
member
.
name
]
;
}
catch
(
e
)
{
thrown
=
true
;
}
if
(
!
thrown
)
{
this
.
array
.
assert_type_is
(
property
member
.
idlType
)
;
}
}
if
(
member
.
type
=
=
"
operation
"
)
{
assert_equals
(
typeof
obj
[
member
.
name
]
"
function
"
)
;
}
}
}
.
bind
(
this
)
this
.
name
+
"
interface
:
"
+
desc
+
'
must
inherit
property
"
'
+
described_name
+
'
"
with
the
proper
type
'
)
;
}
if
(
member
.
type
=
=
"
operation
"
&
&
member
.
name
&
&
member
.
arguments
.
length
)
{
var
a_test
=
subsetTestByKey
(
this
.
name
async_test
this
.
name
+
"
interface
:
calling
"
+
member
.
name
+
"
(
"
+
member
.
arguments
.
map
(
function
(
m
)
{
return
m
.
idlType
.
idlType
;
}
)
.
join
(
"
"
)
+
"
)
on
"
+
desc
+
"
with
too
few
arguments
must
throw
TypeError
"
)
;
a_test
.
step
(
function
(
)
{
assert_equals
(
exception
null
"
Unexpected
exception
when
evaluating
object
"
)
;
assert_equals
(
typeof
obj
expected_typeof
"
wrong
typeof
object
"
)
;
var
fn
;
if
(
!
member
[
"
static
"
]
)
{
if
(
!
this
.
is_global
(
)
&
&
!
member
.
isUnforgeable
)
{
assert_inherits
(
obj
member
.
name
)
;
}
else
{
assert_own_property
(
obj
member
.
name
)
;
}
fn
=
obj
[
member
.
name
]
;
}
else
{
assert_own_property
(
obj
.
constructor
member
.
name
"
interface
object
must
have
static
operation
as
own
property
"
)
;
fn
=
obj
.
constructor
[
member
.
name
]
;
}
var
minLength
=
minOverloadLength
(
this
.
members
.
filter
(
function
(
m
)
{
return
m
.
type
=
=
"
operation
"
&
&
m
.
name
=
=
member
.
name
;
}
)
)
;
var
args
=
[
]
;
var
cb
=
awaitNCallbacks
(
minLength
a_test
.
done
.
bind
(
a_test
)
)
;
for
(
var
i
=
0
;
i
<
minLength
;
i
+
+
)
{
throwOrReject
(
a_test
member
fn
obj
args
"
Called
with
"
+
i
+
"
arguments
"
cb
)
;
args
.
push
(
create_suitable_object
(
member
.
arguments
[
i
]
.
idlType
)
)
;
}
if
(
minLength
=
=
=
0
)
{
cb
(
)
;
}
}
.
bind
(
this
)
)
;
}
if
(
member
.
is_to_json_regular_operation
(
)
)
{
this
.
test_to_json_operation
(
obj
member
)
;
}
}
}
;
IdlInterface
.
prototype
.
has_stringifier
=
function
(
)
{
if
(
this
.
name
=
=
=
"
DOMException
"
)
{
return
true
;
}
if
(
this
.
members
.
some
(
function
(
member
)
{
return
member
.
stringifier
;
}
)
)
{
return
true
;
}
if
(
this
.
base
&
&
this
.
array
.
members
[
this
.
base
]
.
has_stringifier
(
)
)
{
return
true
;
}
return
false
;
}
;
IdlInterface
.
prototype
.
do_interface_attribute_asserts
=
function
(
obj
member
a_test
)
{
var
pendingPromises
=
[
]
;
assert_own_property
(
obj
member
.
name
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
obj
member
.
name
)
;
assert_false
(
"
value
"
in
desc
'
property
descriptor
should
not
have
a
"
value
"
field
'
)
;
assert_false
(
"
writable
"
in
desc
'
property
descriptor
should
not
have
a
"
writable
"
field
'
)
;
assert_true
(
desc
.
enumerable
"
property
should
be
enumerable
"
)
;
if
(
member
.
isUnforgeable
)
{
assert_false
(
desc
.
configurable
"
[
Unforgeable
]
property
must
not
be
configurable
"
)
;
}
else
{
assert_true
(
desc
.
configurable
"
property
must
be
configurable
"
)
;
}
assert_equals
(
typeof
desc
.
get
"
function
"
"
getter
must
be
Function
"
)
;
if
(
!
member
[
"
static
"
]
)
{
if
(
!
member
.
has_extended_attribute
(
"
LenientThis
"
)
)
{
if
(
member
.
idlType
.
generic
!
=
=
"
Promise
"
)
{
assert_throws
(
new
TypeError
(
)
function
(
)
{
desc
.
get
.
call
(
{
}
)
;
}
.
bind
(
this
)
"
calling
getter
on
wrong
object
type
must
throw
TypeError
"
)
;
}
else
{
pendingPromises
.
push
(
promise_rejects
(
a_test
new
TypeError
(
)
desc
.
get
.
call
(
{
}
)
"
calling
getter
on
wrong
object
type
must
reject
the
return
promise
with
TypeError
"
)
)
;
}
}
else
{
assert_equals
(
desc
.
get
.
call
(
{
}
)
undefined
"
calling
getter
on
wrong
object
type
must
return
undefined
"
)
;
}
}
assert_equals
(
desc
.
get
.
length
0
"
getter
length
must
be
0
"
)
;
if
(
member
.
readonly
&
&
!
member
.
has_extended_attribute
(
"
LenientSetter
"
)
&
&
!
member
.
has_extended_attribute
(
"
PutForwards
"
)
&
&
!
member
.
has_extended_attribute
(
"
Replaceable
"
)
)
{
assert_equals
(
desc
.
set
undefined
"
setter
must
be
undefined
for
readonly
attributes
"
)
;
}
else
{
assert_equals
(
typeof
desc
.
set
"
function
"
"
setter
must
be
function
for
PutForwards
Replaceable
or
non
-
readonly
attributes
"
)
;
if
(
!
member
[
"
static
"
]
)
{
if
(
!
member
.
has_extended_attribute
(
"
LenientThis
"
)
)
{
assert_throws
(
new
TypeError
(
)
function
(
)
{
desc
.
set
.
call
(
{
}
)
;
}
.
bind
(
this
)
"
calling
setter
on
wrong
object
type
must
throw
TypeError
"
)
;
}
else
{
assert_equals
(
desc
.
set
.
call
(
{
}
)
undefined
"
calling
setter
on
wrong
object
type
must
return
undefined
"
)
;
}
}
assert_equals
(
desc
.
set
.
length
1
"
setter
length
must
be
1
"
)
;
}
Promise
.
all
(
pendingPromises
)
.
then
(
a_test
.
done
.
bind
(
a_test
)
)
;
}
function
IdlInterfaceMember
(
obj
)
{
for
(
var
k
in
obj
)
{
this
[
k
]
=
obj
[
k
]
;
}
if
(
!
(
"
extAttrs
"
in
this
)
)
{
this
.
extAttrs
=
[
]
;
}
this
.
isUnforgeable
=
this
.
has_extended_attribute
(
"
Unforgeable
"
)
;
this
.
isUnscopable
=
this
.
has_extended_attribute
(
"
Unscopable
"
)
;
}
IdlInterfaceMember
.
prototype
=
Object
.
create
(
IdlObject
.
prototype
)
;
IdlInterfaceMember
.
prototype
.
is_to_json_regular_operation
=
function
(
)
{
return
this
.
type
=
=
"
operation
"
&
&
!
this
.
static
&
&
this
.
name
=
=
"
toJSON
"
;
}
;
function
create_suitable_object
(
type
)
{
if
(
type
.
nullable
)
{
return
null
;
}
switch
(
type
.
idlType
)
{
case
"
any
"
:
case
"
boolean
"
:
return
true
;
case
"
byte
"
:
case
"
octet
"
:
case
"
short
"
:
case
"
unsigned
short
"
:
case
"
long
"
:
case
"
unsigned
long
"
:
case
"
long
long
"
:
case
"
unsigned
long
long
"
:
case
"
float
"
:
case
"
double
"
:
case
"
unrestricted
float
"
:
case
"
unrestricted
double
"
:
return
7
;
case
"
DOMString
"
:
case
"
ByteString
"
:
case
"
USVString
"
:
return
"
foo
"
;
case
"
object
"
:
return
{
a
:
"
b
"
}
;
case
"
Node
"
:
return
document
.
createTextNode
(
"
abc
"
)
;
}
return
null
;
}
function
IdlEnum
(
obj
)
{
this
.
name
=
obj
.
name
;
this
.
values
=
obj
.
values
;
}
IdlEnum
.
prototype
=
Object
.
create
(
IdlObject
.
prototype
)
;
function
IdlTypedef
(
obj
)
{
this
.
name
=
obj
.
name
;
this
.
idlType
=
obj
.
idlType
;
}
IdlTypedef
.
prototype
=
Object
.
create
(
IdlObject
.
prototype
)
;
}
(
)
)
;
