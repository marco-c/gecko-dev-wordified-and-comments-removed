(
function
(
)
{
function
randInt
(
bits
)
{
if
(
bits
<
1
|
|
bits
>
53
)
{
throw
new
TypeError
(
)
;
}
else
{
if
(
bits
>
=
1
&
&
bits
<
=
30
)
{
return
0
|
(
(
1
<
<
bits
)
*
Math
.
random
(
)
)
;
}
else
{
var
high
=
(
0
|
(
(
1
<
<
(
bits
-
30
)
)
*
Math
.
random
(
)
)
)
*
(
1
<
<
30
)
;
var
low
=
0
|
(
(
1
<
<
30
)
*
Math
.
random
(
)
)
;
return
high
+
low
;
}
}
}
function
toHex
(
x
length
)
{
var
rv
=
x
.
toString
(
16
)
;
while
(
rv
.
length
<
length
)
{
rv
=
"
0
"
+
rv
;
}
return
rv
;
}
function
createUuid
(
)
{
return
[
toHex
(
randInt
(
32
)
8
)
toHex
(
randInt
(
16
)
4
)
toHex
(
0x4000
|
randInt
(
12
)
4
)
toHex
(
0x8000
|
randInt
(
14
)
4
)
toHex
(
randInt
(
48
)
12
)
]
.
join
(
"
-
"
)
;
}
class
SocketCache
{
constructor
(
)
{
this
.
readSockets
=
new
Map
(
)
;
this
.
writeSockets
=
new
Map
(
)
;
}
;
async
getOrCreate
(
type
uuid
onmessage
=
null
)
{
function
createSocket
(
)
{
let
protocol
=
self
.
isSecureContext
?
"
wss
"
:
"
ws
"
;
let
port
=
self
.
isSecureContext
?
"
{
{
ports
[
wss
]
[
0
]
}
}
"
:
"
{
{
ports
[
ws
]
[
0
]
}
}
"
;
let
url
=
{
protocol
}
:
/
/
{
{
host
}
}
:
{
port
}
/
msg_channel
?
uuid
=
{
uuid
}
&
direction
=
{
type
}
;
let
socket
=
new
WebSocket
(
url
)
;
if
(
onmessage
!
=
=
null
)
{
socket
.
onmessage
=
onmessage
;
}
;
return
new
Promise
(
resolve
=
>
socket
.
addEventListener
(
"
open
"
(
)
=
>
resolve
(
socket
)
)
)
;
}
let
socket
;
if
(
type
=
=
=
"
read
"
)
{
if
(
this
.
readSockets
.
has
(
uuid
)
)
{
throw
new
Error
(
"
Can
'
t
create
multiple
read
sockets
with
same
UUID
"
)
;
}
socket
=
await
createSocket
(
)
;
socket
.
addEventListener
(
"
close
"
(
)
=
>
this
.
readSockets
.
delete
(
uuid
)
)
;
this
.
readSockets
.
set
(
uuid
socket
)
;
}
else
if
(
type
=
=
=
"
write
"
)
{
let
count
;
if
(
onmessage
!
=
=
null
)
{
throw
new
Error
(
"
Can
'
t
set
message
handler
for
write
sockets
"
)
;
}
if
(
this
.
writeSockets
.
has
(
uuid
)
)
{
[
socket
count
]
=
this
.
writeSockets
.
get
(
uuid
)
;
}
else
{
socket
=
await
createSocket
(
)
;
count
=
0
;
}
count
+
=
1
;
socket
.
addEventListener
(
"
close
"
(
)
=
>
this
.
writeSockets
.
delete
(
uuid
)
)
;
this
.
writeSockets
.
set
(
uuid
[
socket
count
]
)
;
}
else
{
throw
new
Error
(
Unknown
type
{
type
}
)
;
}
return
socket
;
}
;
async
close
(
type
uuid
)
{
let
target
=
type
=
=
=
"
read
"
?
this
.
readSockets
:
this
.
writeSockets
;
const
data
=
target
.
get
(
uuid
)
;
if
(
!
data
)
{
return
;
}
let
count
socket
;
if
(
type
=
=
"
read
"
)
{
socket
=
data
;
count
=
0
;
}
else
if
(
type
=
=
=
"
write
"
)
{
[
socket
count
]
=
data
;
count
-
=
1
;
if
(
count
>
0
)
{
target
.
set
(
uuid
[
socket
count
]
)
;
}
}
;
if
(
count
<
=
0
&
&
socket
)
{
target
.
delete
(
uuid
)
;
socket
.
close
(
1000
)
;
await
new
Promise
(
resolve
=
>
socket
.
addEventListener
(
"
close
"
resolve
)
)
;
}
}
;
async
closeAll
(
)
{
let
sockets
=
[
]
;
this
.
readSockets
.
forEach
(
value
=
>
sockets
.
push
(
value
)
)
;
this
.
writeSockets
.
forEach
(
value
=
>
sockets
.
push
(
value
[
0
]
)
)
;
let
closePromises
=
sockets
.
map
(
socket
=
>
new
Promise
(
resolve
=
>
socket
.
addEventListener
(
"
close
"
resolve
)
)
)
;
sockets
.
forEach
(
socket
=
>
socket
.
close
(
1000
)
)
;
this
.
readSockets
.
clear
(
)
;
this
.
writeSockets
.
clear
(
)
;
await
Promise
.
all
(
closePromises
)
;
}
}
const
socketCache
=
new
SocketCache
(
)
;
class
Channel
{
type
=
null
;
constructor
(
uuid
)
{
this
.
uuid
=
uuid
;
this
.
socket
=
null
;
this
.
eventListeners
=
{
connect
:
new
Set
(
)
close
:
new
Set
(
)
}
;
}
hasConnection
(
)
{
return
this
.
socket
!
=
=
null
&
&
this
.
socket
.
readyState
<
=
WebSocket
.
OPEN
;
}
async
connect
(
onmessage
)
{
if
(
this
.
hasConnection
(
)
)
{
return
;
}
this
.
socket
=
await
socketCache
.
getOrCreate
(
this
.
type
this
.
uuid
onmessage
)
;
this
.
_dispatch
(
"
connect
"
)
;
}
async
close
(
)
{
this
.
socket
=
null
;
await
socketCache
.
close
(
this
.
type
this
.
uuid
)
;
this
.
_dispatch
(
"
close
"
)
;
}
addEventListener
(
type
fn
)
{
if
(
typeof
type
!
=
=
"
string
"
)
{
throw
new
TypeError
(
Expected
string
got
{
typeof
type
}
)
;
}
if
(
typeof
fn
!
=
=
"
function
"
)
{
throw
new
TypeError
(
Expected
function
got
{
typeof
fn
}
)
;
}
if
(
!
this
.
eventListeners
.
hasOwnProperty
(
type
)
)
{
throw
new
Error
(
Unrecognised
event
type
{
type
}
)
;
}
this
.
eventListeners
[
type
]
.
add
(
fn
)
;
}
;
removeEventListener
(
type
fn
)
{
if
(
!
typeof
type
=
=
=
"
string
"
)
{
throw
new
TypeError
(
Expected
string
got
{
typeof
type
}
)
;
}
if
(
typeof
fn
!
=
=
"
function
"
)
{
throw
new
TypeError
(
Expected
function
got
{
typeof
fn
}
)
;
}
let
listeners
=
this
.
eventListeners
[
type
]
;
if
(
listeners
)
{
listeners
.
delete
(
fn
)
;
}
}
;
_dispatch
(
type
data
)
{
let
listeners
=
this
.
eventListeners
[
type
]
;
if
(
listeners
)
{
listeners
.
forEach
(
fn
=
>
fn
(
{
type
data
}
)
)
;
}
}
;
}
class
SendChannel
extends
Channel
{
type
=
"
write
"
;
async
connect
(
)
{
return
super
.
connect
(
null
)
;
}
async
_send
(
cmd
body
=
null
)
{
if
(
!
this
.
hasConnection
(
)
)
{
await
this
.
connect
(
)
;
}
this
.
socket
.
send
(
JSON
.
stringify
(
[
cmd
body
]
)
)
;
}
async
send
(
msg
)
{
await
this
.
_send
(
"
message
"
msg
)
;
}
async
disconnectReader
(
)
{
await
this
.
_send
(
"
disconnectReader
"
)
;
}
async
delete
(
)
{
await
this
.
_send
(
"
delete
"
)
;
}
}
;
self
.
SendChannel
=
SendChannel
;
const
recvChannelsCreated
=
new
Set
(
)
;
class
RecvChannel
extends
Channel
{
type
=
"
read
"
;
constructor
(
uuid
)
{
if
(
recvChannelsCreated
.
has
(
uuid
)
)
{
throw
new
Error
(
Already
created
RecvChannel
with
id
{
uuid
}
)
;
}
super
(
uuid
)
;
this
.
eventListeners
.
message
=
new
Set
(
)
;
}
async
connect
(
)
{
if
(
this
.
hasConnection
(
)
)
{
return
;
}
await
super
.
connect
(
event
=
>
this
.
readMessage
(
event
.
data
)
)
;
}
readMessage
(
data
)
{
let
msg
=
JSON
.
parse
(
data
)
;
this
.
_dispatch
(
"
message
"
msg
)
;
}
nextMessage
(
)
{
return
new
Promise
(
resolve
=
>
{
let
fn
=
(
{
data
}
)
=
>
{
this
.
removeEventListener
(
"
message
"
fn
)
;
resolve
(
data
)
;
}
;
this
.
addEventListener
(
"
message
"
fn
)
;
}
)
;
}
}
self
.
channel
=
function
(
)
{
let
uuid
=
createUuid
(
)
;
let
recvChannel
=
new
RecvChannel
(
uuid
)
;
let
sendChannel
=
new
SendChannel
(
uuid
)
;
return
[
recvChannel
sendChannel
]
;
}
;
self
.
global_channel
=
function
(
)
{
let
uuid
=
new
URLSearchParams
(
location
.
search
)
.
get
(
"
uuid
"
)
;
if
(
!
uuid
)
{
throw
new
Error
(
"
URL
must
have
a
uuid
parameter
to
use
as
a
RemoteGlobal
"
)
;
}
return
new
RemoteGlobalCommandRecvChannel
(
new
RecvChannel
(
uuid
)
)
;
}
;
self
.
start_global_channel
=
async
function
(
)
{
let
channel
=
self
.
global_channel
(
)
;
await
channel
.
connect
(
)
;
return
channel
;
}
;
self
.
close_all_channel_sockets
=
async
function
(
)
{
await
socketCache
.
closeAll
(
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
;
class
RemoteGlobalCommandRecvChannel
{
constructor
(
recvChannel
)
{
this
.
channel
=
recvChannel
;
this
.
uuid
=
recvChannel
.
uuid
;
this
.
channel
.
addEventListener
(
"
message
"
(
{
data
}
)
=
>
this
.
handleMessage
(
data
)
)
;
this
.
messageHandlers
=
new
Set
(
)
;
}
;
async
connect
(
)
{
await
this
.
channel
.
connect
(
)
;
}
async
close
(
)
{
await
this
.
channel
.
close
(
)
;
}
async
handleMessage
(
msg
)
{
const
{
id
command
params
respChannel
}
=
msg
;
let
result
=
{
}
;
let
resp
=
{
id
result
}
;
if
(
command
=
=
=
"
call
"
)
{
const
fn
=
deserialize
(
params
.
fn
)
;
const
args
=
params
.
args
.
map
(
deserialize
)
;
try
{
let
resultValue
=
await
fn
(
.
.
.
args
)
;
result
.
result
=
serialize
(
resultValue
)
;
}
catch
(
e
)
{
let
exception
=
serialize
(
e
)
;
const
getAsInt
=
(
obj
prop
)
=
>
{
let
value
=
prop
in
obj
?
parseInt
(
obj
[
prop
]
)
:
0
;
return
Number
.
isNaN
(
value
)
?
0
:
value
;
}
;
result
.
exceptionDetails
=
{
text
:
e
.
toString
(
)
lineNumber
:
getAsInt
(
e
"
lineNumber
"
)
columnNumber
:
getAsInt
(
e
"
columnNumber
"
)
exception
}
;
}
}
else
if
(
command
=
=
=
"
postMessage
"
)
{
this
.
messageHandlers
.
forEach
(
fn
=
>
fn
(
deserialize
(
params
.
msg
)
)
)
;
}
if
(
respChannel
)
{
let
chan
=
deserialize
(
respChannel
)
;
await
chan
.
connect
(
)
;
await
chan
.
send
(
resp
)
;
}
}
addMessageHandler
(
fn
)
{
this
.
messageHandlers
.
add
(
fn
)
;
}
removeMessageHandler
(
fn
)
{
this
.
messageHandlers
.
delete
(
fn
)
;
}
nextMessage
(
)
{
return
new
Promise
(
resolve
=
>
{
let
fn
=
(
msg
)
=
>
{
this
.
removeMessageHandler
(
fn
)
;
resolve
(
msg
)
;
}
;
this
.
addMessageHandler
(
fn
)
;
}
)
;
}
}
class
RemoteGlobalResponseRecvChannel
{
constructor
(
recvChannel
)
{
this
.
channel
=
recvChannel
;
this
.
channel
.
addEventListener
(
"
message
"
(
{
data
}
)
=
>
this
.
handleMessage
(
data
)
)
;
this
.
responseHandlers
=
new
Map
(
)
;
}
setResponseHandler
(
commandId
fn
)
{
this
.
responseHandlers
.
set
(
commandId
fn
)
;
}
handleMessage
(
msg
)
{
let
{
id
result
}
=
msg
;
let
handler
=
this
.
responseHandlers
.
get
(
id
)
;
if
(
handler
)
{
this
.
responseHandlers
.
delete
(
id
)
;
handler
(
result
)
;
}
}
close
(
)
{
return
this
.
channel
.
close
(
)
;
}
}
class
RemoteGlobal
{
constructor
(
dest
)
{
if
(
dest
=
=
=
undefined
|
|
dest
=
=
=
null
)
{
dest
=
createUuid
(
)
;
}
if
(
typeof
dest
=
=
"
string
"
)
{
this
.
uuid
=
dest
;
this
.
sendChannel
=
new
SendChannel
(
dest
)
;
}
else
if
(
dest
instanceof
SendChannel
)
{
this
.
sendChannel
=
dest
;
this
.
uuid
=
dest
.
uuid
;
}
else
{
throw
new
TypeError
(
"
Unrecognised
type
expected
string
or
SendChannel
"
)
;
}
this
.
recvChannel
=
null
;
this
.
respChannel
=
null
;
this
.
connected
=
false
;
this
.
commandId
=
0
;
}
async
connect
(
)
{
if
(
this
.
connected
)
{
return
;
}
let
[
recvChannel
respChannel
]
=
self
.
channel
(
)
;
await
Promise
.
all
(
[
this
.
sendChannel
.
connect
(
)
recvChannel
.
connect
(
)
]
)
;
this
.
recvChannel
=
new
RemoteGlobalResponseRecvChannel
(
recvChannel
)
;
this
.
respChannel
=
respChannel
;
this
.
connected
=
true
;
}
async
sendMessage
(
command
params
hasResp
=
true
)
{
if
(
!
this
.
connected
)
{
await
this
.
connect
(
)
;
}
let
msg
=
{
id
:
this
.
commandId
+
+
command
params
}
;
if
(
hasResp
)
{
msg
.
respChannel
=
serialize
(
this
.
respChannel
)
;
}
let
response
;
if
(
hasResp
)
{
response
=
new
Promise
(
resolve
=
>
this
.
recvChannel
.
setResponseHandler
(
msg
.
id
resolve
)
)
;
}
else
{
response
=
null
;
}
this
.
sendChannel
.
send
(
msg
)
;
return
await
response
;
}
async
call
(
fn
.
.
.
args
)
{
let
result
=
await
this
.
sendMessage
(
"
call
"
{
fn
:
serialize
(
fn
)
args
:
args
.
map
(
x
=
>
serialize
(
x
)
)
}
true
)
;
if
(
result
.
exceptionDetails
)
{
throw
deserialize
(
result
.
exceptionDetails
.
exception
)
;
}
return
deserialize
(
result
.
result
)
;
}
async
postMessage
(
msg
)
{
await
this
.
sendMessage
(
"
postMessage
"
{
msg
:
serialize
(
msg
)
}
false
)
;
}
disconnectReader
(
)
{
return
this
.
sendChannel
.
disconnectReader
(
)
;
}
close
(
)
{
let
closers
=
[
this
.
sendChannel
.
close
(
)
]
;
if
(
this
.
recvChannel
!
=
=
null
)
{
closers
.
push
(
this
.
recvChannel
.
close
(
)
)
;
}
if
(
this
.
respChannel
!
=
=
null
)
{
closers
.
push
(
this
.
respChannel
.
close
(
)
)
;
}
return
Promise
.
all
(
closers
)
;
}
}
self
.
RemoteGlobal
=
RemoteGlobal
;
function
typeName
(
value
)
{
let
type
=
typeof
value
;
if
(
type
=
=
=
"
undefined
"
|
|
type
=
=
=
"
string
"
|
|
type
=
=
=
"
boolean
"
|
|
type
=
=
=
"
number
"
|
|
type
=
=
=
"
bigint
"
|
|
type
=
=
=
"
symbol
"
|
|
type
=
=
=
"
function
"
)
{
return
type
;
}
if
(
value
=
=
=
null
)
{
return
"
null
"
;
}
if
(
value
instanceof
RemoteObject
)
{
return
"
remoteobject
"
;
}
if
(
value
instanceof
SendChannel
)
{
return
"
sendchannel
"
;
}
if
(
value
instanceof
RecvChannel
)
{
return
"
recvchannel
"
;
}
if
(
value
instanceof
Error
)
{
return
"
error
"
;
}
if
(
Array
.
isArray
(
value
)
)
{
return
"
array
"
;
}
let
constructor
=
value
.
constructor
&
&
value
.
constructor
.
name
;
if
(
constructor
=
=
=
"
RegExp
"
|
|
constructor
=
=
=
"
Date
"
|
|
constructor
=
=
=
"
Map
"
|
|
constructor
=
=
=
"
Set
"
|
|
constructor
=
=
"
WeakMap
"
|
|
constructor
=
=
"
WeakSet
"
)
{
return
constructor
.
toLowerCase
(
)
;
}
if
(
typeof
window
=
=
"
object
"
&
&
window
=
=
=
self
)
{
if
(
value
instanceof
Element
)
{
return
"
element
"
;
}
if
(
value
instanceof
Document
)
{
return
"
document
"
;
}
if
(
value
instanceof
Node
)
{
return
"
node
"
;
}
if
(
value
instanceof
Window
)
{
return
"
window
"
;
}
}
if
(
Promise
.
resolve
(
value
)
=
=
=
value
)
{
return
"
promise
"
;
}
return
"
object
"
;
}
let
remoteObjectsById
=
new
Map
(
)
;
function
remoteId
(
obj
)
{
let
rv
;
rv
=
createUuid
(
)
;
remoteObjectsById
.
set
(
rv
obj
)
;
return
rv
;
}
class
RemoteObject
{
constructor
(
type
objectId
)
{
this
.
type
=
type
;
this
.
objectId
=
objectId
;
}
static
from
(
obj
)
{
let
type
=
typeName
(
obj
)
;
let
id
=
remoteId
(
obj
)
;
return
new
RemoteObject
(
type
id
)
;
}
toLocal
(
)
{
if
(
remoteObjectsById
.
has
(
this
.
objectId
)
)
{
return
remoteObjectsById
.
get
(
this
.
objectId
)
;
}
return
null
;
}
delete
(
)
{
remoteObjectsById
.
delete
(
this
.
objectId
)
;
}
}
self
.
RemoteObject
=
RemoteObject
;
function
serialize
(
inValue
)
{
const
queue
=
[
{
item
:
inValue
}
]
;
let
outValue
=
null
;
let
objectsSeen
=
new
Map
(
)
;
let
lastObjectId
=
0
;
while
(
queue
.
length
>
0
)
{
const
{
item
target
targetName
}
=
queue
.
shift
(
)
;
let
type
=
typeName
(
item
)
;
let
serialized
=
{
type
}
;
if
(
objectsSeen
.
has
(
item
)
)
{
let
outputValue
=
objectsSeen
.
get
(
item
)
;
if
(
!
outputValue
.
hasOwnProperty
(
"
objectId
"
)
)
{
outputValue
.
objectId
=
lastObjectId
+
+
;
}
serialized
.
objectId
=
outputValue
.
objectId
;
}
else
{
switch
(
type
)
{
case
"
undefined
"
:
case
"
null
"
:
break
;
case
"
string
"
:
case
"
boolean
"
:
serialized
.
value
=
item
;
break
;
case
"
number
"
:
if
(
item
!
=
=
item
)
{
serialized
.
value
=
"
NaN
"
;
}
else
if
(
item
=
=
=
0
&
&
1
/
item
=
=
Number
.
NEGATIVE_INFINITY
)
{
serialized
.
value
=
"
-
0
"
;
}
else
if
(
item
=
=
=
Number
.
POSITIVE_INFINITY
)
{
serialized
.
value
=
"
+
Infinity
"
;
}
else
if
(
item
=
=
=
Number
.
NEGATIVE_INFINITY
)
{
serialized
.
value
=
"
-
Infinity
"
;
}
else
{
serialized
.
value
=
item
;
}
break
;
case
"
bigint
"
:
case
"
function
"
:
serialized
.
value
=
item
.
toString
(
)
;
break
;
case
"
remoteobject
"
:
serialized
.
value
=
{
type
:
item
.
type
objectId
:
item
.
objectId
}
;
break
;
case
"
sendchannel
"
:
serialized
.
value
=
item
.
uuid
;
break
;
case
"
regexp
"
:
serialized
.
value
=
{
pattern
:
item
.
source
flags
:
item
.
flags
}
;
break
;
case
"
date
"
:
serialized
.
value
=
Date
.
prototype
.
toJSON
.
call
(
item
)
;
break
;
case
"
error
"
:
serialized
.
value
=
{
type
:
item
.
constructor
.
name
name
:
item
.
name
message
:
item
.
message
lineNumber
:
item
.
lineNumber
columnNumber
:
item
.
columnNumber
fileName
:
item
.
fileName
stack
:
item
.
stack
}
;
break
;
case
"
array
"
:
case
"
set
"
:
serialized
.
value
=
[
]
;
for
(
let
child
of
item
)
{
queue
.
push
(
{
item
:
child
target
:
serialized
}
)
;
}
break
;
case
"
object
"
:
serialized
.
value
=
{
}
;
for
(
let
[
targetName
child
]
of
Object
.
entries
(
item
)
)
{
queue
.
push
(
{
item
:
child
target
:
serialized
targetName
}
)
;
}
break
;
case
"
map
"
:
serialized
.
value
=
[
]
;
for
(
let
[
childKey
childValue
]
of
item
.
entries
(
)
)
{
queue
.
push
(
{
item
:
childKey
target
:
serialized
targetName
:
"
key
"
}
)
;
queue
.
push
(
{
item
:
childValue
target
:
serialized
targetName
:
"
value
"
}
)
;
}
break
;
default
:
throw
new
TypeError
(
Can
'
t
serialize
value
of
type
{
type
}
;
consider
using
RemoteObject
.
from
(
)
to
wrap
the
object
)
;
}
;
}
if
(
serialized
.
objectId
=
=
=
undefined
)
{
objectsSeen
.
set
(
item
serialized
)
;
}
if
(
target
=
=
=
undefined
)
{
if
(
outValue
!
=
=
null
)
{
throw
new
Error
(
"
Tried
to
create
multiple
output
values
"
)
;
}
outValue
=
serialized
;
}
else
{
switch
(
target
.
type
)
{
case
"
array
"
:
case
"
set
"
:
target
.
value
.
push
(
serialized
)
;
break
;
case
"
object
"
:
target
.
value
[
targetName
]
=
serialized
;
break
;
case
"
map
"
:
if
(
targetName
=
=
=
"
key
"
)
{
target
.
value
.
push
(
[
]
)
;
}
target
.
value
[
target
.
value
.
length
-
1
]
.
push
(
serialized
)
;
break
;
default
:
throw
new
Error
(
Unknown
collection
target
type
{
target
.
type
}
)
;
}
}
}
return
outValue
;
}
function
deserialize
(
obj
)
{
let
deserialized
=
null
;
let
queue
=
[
{
item
:
obj
target
:
null
}
]
;
let
objectMap
=
new
Map
(
)
;
while
(
queue
.
length
>
0
)
{
const
{
item
target
targetName
}
=
queue
.
shift
(
)
;
const
{
type
value
objectId
}
=
item
;
let
result
;
let
newTarget
;
if
(
objectId
!
=
=
undefined
&
&
value
=
=
=
undefined
)
{
result
=
objectMap
.
get
(
objectId
)
;
}
else
{
switch
(
type
)
{
case
"
undefined
"
:
result
=
undefined
;
break
;
case
"
null
"
:
result
=
null
;
break
;
case
"
string
"
:
case
"
boolean
"
:
result
=
value
;
break
;
case
"
number
"
:
if
(
typeof
value
=
=
=
"
string
"
)
{
switch
(
value
)
{
case
"
NaN
"
:
result
=
NaN
;
break
;
case
"
-
0
"
:
result
=
-
0
;
break
;
case
"
+
Infinity
"
:
result
=
Number
.
POSITIVE_INFINITY
;
break
;
case
"
-
Infinity
"
:
result
=
Number
.
NEGATIVE_INFINITY
;
break
;
default
:
throw
new
Error
(
Unexpected
number
value
"
{
value
}
"
)
;
}
}
else
{
result
=
value
;
}
break
;
case
"
bigint
"
:
result
=
BigInt
(
value
)
;
break
;
case
"
function
"
:
result
=
new
Function
(
"
.
.
.
args
"
return
(
{
value
}
)
.
apply
(
null
args
)
)
;
break
;
case
"
remoteobject
"
:
let
remote
=
new
RemoteObject
(
value
.
type
value
.
objectId
)
;
let
local
=
remote
.
toLocal
(
)
;
if
(
local
!
=
=
null
)
{
result
=
local
;
}
else
{
result
=
remote
;
}
break
;
case
"
sendchannel
"
:
result
=
new
SendChannel
(
value
)
;
break
;
case
"
regexp
"
:
result
=
new
RegExp
(
value
.
pattern
value
.
flags
)
;
break
;
case
"
date
"
:
result
=
new
Date
(
value
)
;
break
;
case
"
error
"
:
if
(
item
.
value
.
type
in
self
&
&
typeof
self
[
item
.
value
.
type
]
=
=
=
"
function
"
)
{
result
=
new
self
[
item
.
value
.
type
]
(
item
.
value
.
message
)
;
}
else
{
result
=
new
Error
(
item
.
value
.
message
)
;
}
result
.
name
=
item
.
value
.
name
;
result
.
lineNumber
=
item
.
value
.
lineNumber
;
result
.
columnNumber
=
item
.
value
.
columnNumber
;
result
.
fileName
=
item
.
value
.
fileName
;
result
.
stack
=
item
.
value
.
stack
;
break
;
case
"
array
"
:
result
=
[
]
;
newTarget
=
{
type
value
:
result
}
;
for
(
let
child
of
value
)
{
queue
.
push
(
{
item
:
child
target
:
newTarget
}
)
;
}
break
;
case
"
set
"
:
result
=
new
Set
(
)
;
newTarget
=
{
type
value
:
result
}
;
for
(
let
child
of
value
)
{
queue
.
push
(
{
item
:
child
target
:
newTarget
}
)
;
}
break
;
case
"
object
"
:
result
=
{
}
;
newTarget
=
{
type
value
:
result
}
;
for
(
let
[
targetName
child
]
of
Object
.
entries
(
value
)
)
{
queue
.
push
(
{
item
:
child
target
:
newTarget
targetName
}
)
;
}
break
;
case
"
map
"
:
result
=
new
Map
(
)
;
newTarget
=
{
type
value
:
result
}
;
for
(
let
[
key
child
]
of
value
)
{
queue
.
push
(
{
item
:
key
target
:
newTarget
targetName
:
"
key
"
}
)
;
queue
.
push
(
{
item
:
child
target
:
newTarget
targetName
:
"
value
"
}
)
;
}
break
;
default
:
throw
new
TypeError
(
Can
'
t
deserialize
object
of
type
{
type
}
)
;
}
if
(
objectId
!
=
=
undefined
)
{
objectMap
.
set
(
objectId
result
)
;
}
}
if
(
target
=
=
=
null
)
{
if
(
deserialized
!
=
=
null
)
{
throw
new
Error
(
Tried
to
deserialized
a
non
-
root
output
value
without
a
target
container
object
.
)
;
}
deserialized
=
result
;
}
else
{
switch
(
target
.
type
)
{
case
"
array
"
:
target
.
value
.
push
(
result
)
;
break
;
case
"
set
"
:
target
.
value
.
add
(
result
)
;
break
;
case
"
object
"
:
target
.
value
[
targetName
]
=
result
;
break
;
case
"
map
"
:
if
(
targetName
=
=
=
"
key
"
)
{
target
.
key
=
result
;
}
else
{
target
.
value
.
set
(
target
.
key
result
)
;
}
break
;
default
:
throw
new
Error
(
Unknown
target
type
{
target
.
type
}
)
;
}
}
}
return
deserialized
;
}
}
)
(
)
;
