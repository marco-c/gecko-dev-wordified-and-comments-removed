function
fetch_text
(
url
)
{
return
fetch
(
url
)
.
then
(
function
(
r
)
{
if
(
!
r
.
ok
)
{
throw
new
Error
(
"
Error
fetching
"
+
url
+
"
.
"
)
;
}
return
r
.
text
(
)
;
}
)
;
}
function
idl_test_shadowrealm
(
srcs
deps
)
{
const
script_urls
=
[
"
/
resources
/
testharness
.
js
"
"
/
resources
/
WebIDLParser
.
js
"
"
/
resources
/
idlharness
.
js
"
]
;
promise_setup
(
async
t
=
>
{
const
realm
=
new
ShadowRealm
(
)
;
realm
.
evaluate
(
"
globalThis
.
self
=
globalThis
;
undefined
;
"
)
;
realm
.
evaluate
(
globalThis
.
self
.
GLOBAL
=
{
isWindow
:
function
(
)
{
return
false
;
}
isWorker
:
function
(
)
{
return
false
;
}
isShadowRealm
:
function
(
)
{
return
true
;
}
}
;
undefined
;
)
;
const
ss
=
await
Promise
.
all
(
script_urls
.
map
(
url
=
>
fetch_text
(
url
)
)
)
;
for
(
const
s
of
ss
)
{
realm
.
evaluate
(
s
)
;
}
const
specs
=
await
Promise
.
all
(
srcs
.
concat
(
deps
)
.
map
(
spec
=
>
{
return
fetch_text
(
"
/
interfaces
/
"
+
spec
+
"
.
idl
"
)
;
}
)
)
;
const
idls
=
JSON
.
stringify
(
specs
)
;
const
results
=
JSON
.
parse
(
await
new
Promise
(
realm
.
evaluate
(
(
resolve
reject
)
=
>
{
const
idls
=
{
idls
}
;
add_completion_callback
(
function
(
tests
harness_status
asserts_run
)
{
resolve
(
JSON
.
stringify
(
tests
)
)
;
}
)
;
/
/
Without
the
wrapping
test
testharness
.
js
will
think
it
'
s
done
after
it
has
run
/
/
the
first
idlharness
test
.
test
(
(
)
=
>
{
const
idl_array
=
new
IdlArray
(
)
;
for
(
let
i
=
0
;
i
<
{
srcs
.
length
}
;
i
+
+
)
{
idl_array
.
add_idls
(
idls
[
i
]
)
;
}
for
(
let
i
=
{
srcs
.
length
}
;
i
<
{
srcs
.
length
+
deps
.
length
}
;
i
+
+
)
{
idl_array
.
add_dependency_idls
(
idls
[
i
]
)
;
}
idl_array
.
test
(
)
;
}
"
setup
"
)
;
}
)
)
)
;
for
(
const
{
name
status
message
}
of
results
)
{
promise_test
(
t
=
>
{
t
.
set_status
(
status
message
)
;
t
.
phase
=
t
.
phases
.
HAS_RESULT
;
t
.
done
(
)
}
name
)
;
}
}
"
outer
setup
"
)
;
}
