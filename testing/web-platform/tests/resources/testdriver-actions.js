(
function
(
)
{
let
sourceNameIdx
=
0
;
function
Actions
(
defaultTickDuration
=
16
)
{
this
.
sourceTypes
=
new
Map
(
[
[
"
key
"
KeySource
]
[
"
pointer
"
PointerSource
]
[
"
none
"
GeneralSource
]
]
)
;
this
.
sources
=
new
Map
(
)
;
this
.
sourceOrder
=
[
]
;
for
(
let
sourceType
of
this
.
sourceTypes
.
keys
(
)
)
{
this
.
sources
.
set
(
sourceType
new
Map
(
)
)
;
}
this
.
currentSources
=
new
Map
(
)
;
for
(
let
sourceType
of
this
.
sourceTypes
.
keys
(
)
)
{
this
.
currentSources
.
set
(
sourceType
null
)
;
}
this
.
createSource
(
"
none
"
)
;
this
.
tickIdx
=
0
;
this
.
defaultTickDuration
=
defaultTickDuration
;
}
Actions
.
prototype
=
{
ButtonType
:
{
LEFT
:
0
MIDDLE
:
1
RIGHT
:
2
BACK
:
3
FORWARD
:
4
}
serialize
:
function
(
)
{
let
actions
=
[
]
;
for
(
let
[
sourceType
sourceName
]
of
this
.
sourceOrder
)
{
let
source
=
this
.
sources
.
get
(
sourceType
)
.
get
(
sourceName
)
;
let
serialized
=
source
.
serialize
(
this
.
tickIdx
+
1
this
.
defaultTickDuration
)
;
if
(
serialized
)
{
serialized
.
id
=
sourceName
;
actions
.
push
(
serialized
)
;
}
}
return
actions
;
}
send
:
function
(
)
{
let
actions
;
try
{
actions
=
this
.
serialize
(
)
;
}
catch
(
e
)
{
return
Promise
.
reject
(
e
)
;
}
return
test_driver
.
action_sequence
(
actions
)
;
}
getSource
:
function
(
type
name
)
{
if
(
!
this
.
sources
.
has
(
type
)
)
{
throw
new
Error
(
{
type
}
is
not
a
valid
action
type
)
;
}
if
(
name
=
=
=
null
|
|
name
=
=
=
undefined
)
{
name
=
this
.
currentSources
.
get
(
type
)
;
}
if
(
name
=
=
=
null
|
|
name
=
=
=
undefined
)
{
return
this
.
createSource
(
type
null
)
;
}
return
this
.
sources
.
get
(
type
)
.
get
(
name
)
;
}
setSource
:
function
(
type
name
)
{
if
(
!
this
.
sources
.
has
(
type
)
)
{
throw
new
Error
(
{
type
}
is
not
a
valid
action
type
)
;
}
if
(
!
this
.
sources
.
get
(
type
)
.
has
(
name
)
)
{
throw
new
Error
(
{
name
}
is
not
a
valid
source
for
{
type
}
)
;
}
this
.
currentSources
.
set
(
type
name
)
;
return
this
;
}
addKeyboard
:
function
(
name
set
=
true
)
{
this
.
createSource
(
"
key
"
name
)
;
if
(
set
)
{
this
.
setKeyboard
(
name
)
;
}
return
this
;
}
setKeyboard
:
function
(
name
)
{
this
.
setSource
(
"
key
"
name
)
;
return
this
;
}
addPointer
:
function
(
name
pointerType
=
"
mouse
"
set
=
true
)
{
this
.
createSource
(
"
pointer
"
name
{
pointerType
:
pointerType
}
)
;
if
(
set
)
{
this
.
setPointer
(
name
)
;
}
return
this
;
}
setPointer
:
function
(
name
)
{
this
.
setSource
(
"
pointer
"
name
)
;
return
this
;
}
createSource
:
function
(
type
name
parameters
=
{
}
)
{
if
(
!
this
.
sources
.
has
(
type
)
)
{
throw
new
Error
(
{
type
}
is
not
a
valid
action
type
)
;
}
let
sourceNames
=
new
Set
(
)
;
for
(
let
[
_
name
]
of
this
.
sourceOrder
)
{
sourceNames
.
add
(
name
)
;
}
if
(
!
name
)
{
do
{
name
=
"
"
+
sourceNameIdx
+
+
;
}
while
(
sourceNames
.
has
(
name
)
)
}
else
{
if
(
sourceNames
.
has
(
name
)
)
{
throw
new
Error
(
Alreay
have
a
source
of
type
{
type
}
named
{
name
}
.
)
;
}
}
this
.
sources
.
get
(
type
)
.
set
(
name
new
(
this
.
sourceTypes
.
get
(
type
)
)
(
parameters
)
)
;
this
.
currentSources
.
set
(
type
name
)
;
this
.
sourceOrder
.
push
(
[
type
name
]
)
;
return
this
.
sources
.
get
(
type
)
.
get
(
name
)
;
}
addTick
:
function
(
duration
)
{
this
.
tickIdx
+
=
1
;
if
(
duration
)
{
this
.
pause
(
duration
)
;
}
return
this
;
}
pause
:
function
(
duration
)
{
this
.
getSource
(
"
none
"
)
.
addPause
(
this
duration
)
;
return
this
;
}
keyDown
:
function
(
key
{
sourceName
=
null
}
=
{
}
)
{
let
source
=
this
.
getSource
(
"
key
"
sourceName
)
;
source
.
keyDown
(
this
key
)
;
return
this
;
}
keyUp
:
function
(
key
{
sourceName
=
null
}
=
{
}
)
{
let
source
=
this
.
getSource
(
"
key
"
sourceName
)
;
source
.
keyUp
(
this
key
)
;
return
this
;
}
pointerDown
:
function
(
{
button
=
this
.
ButtonType
.
LEFT
sourceName
=
null
}
=
{
}
)
{
let
source
=
this
.
getSource
(
"
pointer
"
sourceName
)
;
source
.
pointerDown
(
this
button
)
;
return
this
;
}
pointerUp
:
function
(
{
button
=
this
.
ButtonType
.
LEFT
sourceName
=
null
}
=
{
}
)
{
let
source
=
this
.
getSource
(
"
pointer
"
sourceName
)
;
source
.
pointerUp
(
this
button
)
;
return
this
;
}
pointerMove
:
function
(
x
y
{
origin
=
"
viewport
"
duration
sourceName
=
null
}
=
{
}
)
{
let
source
=
this
.
getSource
(
"
pointer
"
sourceName
)
;
source
.
pointerMove
(
this
x
y
duration
origin
)
;
return
this
;
}
}
;
function
GeneralSource
(
)
{
this
.
actions
=
new
Map
(
)
;
}
GeneralSource
.
prototype
=
{
serialize
:
function
(
tickCount
defaultTickDuration
)
{
let
actions
=
[
]
;
let
data
=
{
"
type
"
:
"
none
"
"
actions
"
:
actions
}
;
for
(
let
i
=
0
;
i
<
tickCount
;
i
+
+
)
{
if
(
this
.
actions
.
has
(
i
)
)
{
actions
.
push
(
this
.
actions
.
get
(
i
)
)
;
}
else
{
actions
.
push
(
{
"
type
"
:
"
pause
"
duration
:
defaultTickDuration
}
)
;
}
}
return
data
;
}
addPause
:
function
(
actions
duration
)
{
let
tick
=
actions
.
tickIdx
;
if
(
this
.
actions
.
has
(
tick
)
)
{
throw
new
Error
(
Already
have
a
pause
action
for
the
current
tick
)
;
}
this
.
actions
.
set
(
tick
{
type
:
"
pause
"
duration
:
duration
}
)
;
}
}
;
function
KeySource
(
)
{
this
.
actions
=
new
Map
(
)
;
}
KeySource
.
prototype
=
{
serialize
:
function
(
tickCount
)
{
if
(
!
this
.
actions
.
size
)
{
return
undefined
;
}
let
actions
=
[
]
;
let
data
=
{
"
type
"
:
"
key
"
"
actions
"
:
actions
}
;
for
(
let
i
=
0
;
i
<
tickCount
;
i
+
+
)
{
if
(
this
.
actions
.
has
(
i
)
)
{
actions
.
push
(
this
.
actions
.
get
(
i
)
)
;
}
else
{
actions
.
push
(
{
"
type
"
:
"
pause
"
}
)
;
}
}
return
data
;
}
keyDown
:
function
(
actions
key
)
{
let
tick
=
actions
.
tickIdx
;
if
(
this
.
actions
.
has
(
tick
)
)
{
tick
=
actions
.
addTick
(
)
.
tickIdx
;
}
this
.
actions
.
set
(
tick
{
type
:
"
keyDown
"
value
:
key
}
)
;
}
keyUp
:
function
(
actions
key
)
{
let
tick
=
actions
.
tickIdx
;
if
(
this
.
actions
.
has
(
tick
)
)
{
tick
=
actions
.
addTick
(
)
.
tickIdx
;
}
this
.
actions
.
set
(
tick
{
type
:
"
keyUp
"
value
:
key
}
)
;
}
}
;
function
PointerSource
(
parameters
=
{
pointerType
:
"
mouse
"
}
)
{
let
pointerType
=
parameters
.
pointerType
|
|
"
mouse
"
;
if
(
!
[
"
mouse
"
"
pen
"
"
touch
"
]
.
includes
(
pointerType
)
)
{
throw
new
Error
(
Invalid
pointerType
{
pointerType
}
)
;
}
this
.
type
=
pointerType
;
this
.
actions
=
new
Map
(
)
;
}
PointerSource
.
prototype
=
{
serialize
:
function
(
tickCount
)
{
if
(
!
this
.
actions
.
size
)
{
return
undefined
;
}
let
actions
=
[
]
;
let
data
=
{
"
type
"
:
"
pointer
"
"
actions
"
:
actions
"
parameters
"
:
{
"
pointerType
"
:
this
.
type
}
}
;
for
(
let
i
=
0
;
i
<
tickCount
;
i
+
+
)
{
if
(
this
.
actions
.
has
(
i
)
)
{
actions
.
push
(
this
.
actions
.
get
(
i
)
)
;
}
else
{
actions
.
push
(
{
"
type
"
:
"
pause
"
}
)
;
}
}
return
data
;
}
pointerDown
:
function
(
actions
button
)
{
let
tick
=
actions
.
tickIdx
;
if
(
this
.
actions
.
has
(
tick
)
)
{
tick
=
actions
.
addTick
(
)
.
tickIdx
;
}
this
.
actions
.
set
(
tick
{
type
:
"
pointerDown
"
button
}
)
;
}
pointerUp
:
function
(
actions
button
)
{
let
tick
=
actions
.
tickIdx
;
if
(
this
.
actions
.
has
(
tick
)
)
{
tick
=
actions
.
addTick
(
)
.
tickIdx
;
}
this
.
actions
.
set
(
tick
{
type
:
"
pointerUp
"
button
}
)
;
}
pointerMove
:
function
(
actions
x
y
duration
origin
)
{
let
tick
=
actions
.
tickIdx
;
if
(
this
.
actions
.
has
(
tick
)
)
{
tick
=
actions
.
addTick
(
)
.
tickIdx
;
}
this
.
actions
.
set
(
tick
{
type
:
"
pointerMove
"
x
y
origin
}
)
;
if
(
duration
)
{
this
.
actions
.
get
(
tick
)
.
duration
=
duration
;
}
}
}
;
test_driver
.
Actions
=
Actions
;
}
)
(
)
;
