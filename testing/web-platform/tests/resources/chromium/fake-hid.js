import
{
HidConnectionReceiver
HidDeviceInfo
}
from
'
/
gen
/
services
/
device
/
public
/
mojom
/
hid
.
mojom
.
m
.
js
'
;
import
{
HidService
HidServiceReceiver
}
from
'
/
gen
/
third_party
/
blink
/
public
/
mojom
/
hid
/
hid
.
mojom
.
m
.
js
'
;
class
FakeHidConnection
{
constructor
(
client
)
{
this
.
client_
=
client
;
this
.
receiver_
=
new
HidConnectionReceiver
(
this
)
;
this
.
expectedWrites_
=
[
]
;
this
.
expectedGetFeatureReports_
=
[
]
;
this
.
expectedSendFeatureReports_
=
[
]
;
}
bindNewPipeAndPassRemote
(
)
{
return
this
.
receiver_
.
.
bindNewPipeAndPassRemote
(
)
;
}
simulateInputReport
(
reportId
reportData
)
{
if
(
this
.
client_
)
{
this
.
client_
.
onInputReport
(
reportId
reportData
)
;
}
}
queueExpectedWrite
(
success
reportId
reportData
)
{
this
.
expectedWrites_
.
push
(
{
params
:
{
reportId
data
:
reportData
}
result
:
{
success
}
}
)
;
}
queueExpectedGetFeatureReport
(
success
reportId
reportData
)
{
this
.
expectedGetFeatureReports_
.
push
(
{
params
:
{
reportId
}
result
:
{
success
buffer
:
reportData
}
}
)
;
}
queueExpectedSendFeatureReport
(
success
reportId
reportData
)
{
this
.
expectedSendFeatureReports_
.
push
(
{
params
:
{
reportId
data
:
reportData
}
result
:
{
success
}
}
)
;
}
assertExpectationsMet
(
)
{
assert_equals
(
this
.
expectedWrites_
.
length
0
)
;
assert_equals
(
this
.
expectedGetFeatureReports_
.
length
0
)
;
assert_equals
(
this
.
expectedSendFeatureReports_
.
length
0
)
;
}
read
(
)
{
}
async
write
(
reportId
buffer
)
{
let
expectedWrite
=
this
.
expectedWrites_
.
shift
(
)
;
assert_not_equals
(
expectedWrite
undefined
)
;
assert_equals
(
reportId
expectedWrite
.
params
.
reportId
)
;
let
actual
=
new
Uint8Array
(
buffer
)
;
compareDataViews
(
new
DataView
(
actual
.
buffer
actual
.
byteOffset
)
new
DataView
(
expectedWrite
.
params
.
data
.
buffer
expectedWrite
.
params
.
data
.
byteOffset
)
)
;
return
expectedWrite
.
result
;
}
async
getFeatureReport
(
reportId
)
{
let
expectedGetFeatureReport
=
this
.
expectedGetFeatureReports_
.
shift
(
)
;
assert_not_equals
(
expectedGetFeatureReport
undefined
)
;
assert_equals
(
reportId
expectedGetFeatureReport
.
params
.
reportId
)
;
return
expectedGetFeatureReport
.
result
;
}
async
sendFeatureReport
(
reportId
buffer
)
{
let
expectedSendFeatureReport
=
this
.
expectedSendFeatureReports_
.
shift
(
)
;
assert_not_equals
(
expectedSendFeatureReport
undefined
)
;
assert_equals
(
reportId
expectedSendFeatureReport
.
params
.
reportId
)
;
let
actual
=
new
Uint8Array
(
buffer
)
;
compareDataViews
(
new
DataView
(
actual
.
buffer
actual
.
byteOffset
)
new
DataView
(
expectedSendFeatureReport
.
params
.
data
.
buffer
expectedSendFeatureReport
.
params
.
data
.
byteOffset
)
)
;
return
expectedSendFeatureReport
.
result
;
}
}
class
FakeHidService
{
constructor
(
)
{
this
.
interceptor_
=
new
MojoInterfaceInterceptor
(
HidService
.
interfaceName
)
;
this
.
interceptor_
.
oninterfacerequest
=
e
=
>
this
.
bind
(
e
.
handle
)
;
this
.
receiver_
=
new
HidServiceReceiver
(
this
)
;
this
.
nextGuidValue_
=
0
;
this
.
simulateConnectFailure_
=
false
;
this
.
reset
(
)
;
}
start
(
)
{
this
.
interceptor_
.
start
(
)
;
}
stop
(
)
{
this
.
interceptor_
.
stop
(
)
;
}
reset
(
)
{
this
.
devices_
=
new
Map
(
)
;
this
.
allowedDevices_
=
new
Map
(
)
;
this
.
fakeConnections_
=
new
Map
(
)
;
this
.
selectedDevices_
=
[
]
;
}
makeDevice
(
vendorId
productId
)
{
let
guidValue
=
+
+
this
.
nextGuidValue_
;
let
info
=
new
HidDeviceInfo
(
)
;
info
.
guid
=
'
guid
-
'
+
guidValue
.
toString
(
)
;
info
.
physicalDeviceId
=
'
physical
-
device
-
id
-
'
+
guidValue
.
toString
(
)
;
info
.
vendorId
=
vendorId
;
info
.
productId
=
productId
;
info
.
productName
=
'
product
name
'
;
info
.
serialNumber
=
'
0
'
;
info
.
reportDescriptor
=
new
Uint8Array
(
)
;
info
.
collections
=
[
]
;
info
.
deviceNode
=
'
device
node
'
;
return
info
;
}
addDevice
(
deviceInfo
grantPermission
=
true
)
{
let
key
=
deviceInfo
.
physicalDeviceId
;
if
(
key
.
length
=
=
=
0
)
key
=
deviceInfo
.
guid
;
let
devices
=
this
.
devices_
.
get
(
key
)
|
|
[
]
;
devices
.
push
(
deviceInfo
)
;
this
.
devices_
.
set
(
key
devices
)
;
if
(
grantPermission
)
{
let
allowedDevices
=
this
.
allowedDevices_
.
get
(
key
)
|
|
[
]
;
allowedDevices
.
push
(
deviceInfo
)
;
this
.
allowedDevices_
.
set
(
key
allowedDevices
)
;
}
if
(
this
.
client_
)
this
.
client_
.
deviceAdded
(
deviceInfo
)
;
return
key
;
}
removeDevice
(
key
)
{
let
devices
=
this
.
devices_
.
get
(
key
)
;
this
.
devices_
.
delete
(
key
)
;
if
(
this
.
client_
&
&
devices
)
{
devices
.
forEach
(
deviceInfo
=
>
{
this
.
client_
.
deviceRemoved
(
deviceInfo
)
;
}
)
;
}
}
changeDevice
(
deviceInfo
)
{
let
key
=
deviceInfo
.
physicalDeviceId
;
if
(
key
.
length
=
=
=
0
)
key
=
deviceInfo
.
guid
;
let
devices
=
this
.
devices_
.
get
(
key
)
|
|
[
]
;
let
i
=
devices
.
length
;
while
(
i
-
-
)
{
if
(
devices
[
i
]
.
guid
=
=
deviceInfo
.
guid
)
devices
.
splice
(
i
1
)
;
}
devices
.
push
(
deviceInfo
)
;
this
.
devices_
.
set
(
key
devices
)
;
let
allowedDevices
=
this
.
allowedDevices_
.
get
(
key
)
|
|
[
]
;
let
j
=
allowedDevices
.
length
;
while
(
j
-
-
)
{
if
(
allowedDevices
[
j
]
.
guid
=
=
deviceInfo
.
guid
)
allowedDevices
.
splice
(
j
1
)
;
}
allowedDevices
.
push
(
deviceInfo
)
;
this
.
allowedDevices_
.
set
(
key
allowedDevices
)
;
if
(
this
.
client_
)
this
.
client_
.
deviceChanged
(
deviceInfo
)
;
return
key
;
}
simulateConnectFailure
(
)
{
this
.
simulateConnectFailure_
=
true
;
}
setSelectedDevice
(
key
)
{
this
.
selectedDevices_
=
this
.
devices_
.
get
(
key
)
;
}
getFakeConnection
(
guid
)
{
return
this
.
fakeConnections_
.
get
(
guid
)
;
}
bind
(
handle
)
{
this
.
receiver_
.
.
bindHandle
(
handle
)
;
}
registerClient
(
client
)
{
this
.
client_
=
client
;
}
async
getDevices
(
)
{
let
devices
=
[
]
;
this
.
allowedDevices_
.
forEach
(
(
value
)
=
>
{
devices
=
devices
.
concat
(
value
)
;
}
)
;
return
{
devices
}
;
}
async
requestDevice
(
options
)
{
return
{
devices
:
this
.
selectedDevices_
}
;
}
async
connect
(
guid
connectionClient
)
{
if
(
this
.
simulateConnectFailure_
)
{
this
.
simulateConnectFailure_
=
false
;
return
{
connection
:
null
}
;
}
const
fakeConnection
=
new
FakeHidConnection
(
connectionClient
)
;
this
.
fakeConnections_
.
set
(
guid
fakeConnection
)
;
return
{
connection
:
fakeConnection
.
bindNewPipeAndPassRemote
(
)
}
;
}
async
forget
(
deviceInfo
)
{
for
(
const
[
key
value
]
of
this
.
allowedDevices_
)
{
for
(
const
device
of
value
)
{
if
(
device
.
guid
=
=
deviceInfo
.
guid
)
{
this
.
allowedDevices_
.
delete
(
key
)
;
break
;
}
}
}
return
{
success
:
true
}
;
}
}
export
const
fakeHidService
=
new
FakeHidService
(
)
;
