import
*
as
vrMojom
from
'
/
gen
/
device
/
vr
/
public
/
mojom
/
vr_service
.
mojom
.
m
.
js
'
;
import
{
GamepadHand
GamepadMapping
}
from
'
/
gen
/
device
/
gamepad
/
public
/
mojom
/
gamepad
.
mojom
.
m
.
js
'
;
const
defaultMojoFromFloor
=
{
matrix
:
[
1
0
0
0
0
1
0
0
0
0
1
0
0
-
1
.
65
0
1
]
}
;
const
default_stage_parameters
=
{
mojoFromFloor
:
defaultMojoFromFloor
bounds
:
null
}
;
const
default_framebuffer_scale
=
0
.
7
;
function
getMatrixFromTransform
(
transform
)
{
const
x
=
transform
.
orientation
[
0
]
;
const
y
=
transform
.
orientation
[
1
]
;
const
z
=
transform
.
orientation
[
2
]
;
const
w
=
transform
.
orientation
[
3
]
;
const
m11
=
1
.
0
-
2
.
0
*
(
y
*
y
+
z
*
z
)
;
const
m21
=
2
.
0
*
(
x
*
y
+
z
*
w
)
;
const
m31
=
2
.
0
*
(
x
*
z
-
y
*
w
)
;
const
m12
=
2
.
0
*
(
x
*
y
-
z
*
w
)
;
const
m22
=
1
.
0
-
2
.
0
*
(
x
*
x
+
z
*
z
)
;
const
m32
=
2
.
0
*
(
y
*
z
+
x
*
w
)
;
const
m13
=
2
.
0
*
(
x
*
z
+
y
*
w
)
;
const
m23
=
2
.
0
*
(
y
*
z
-
x
*
w
)
;
const
m33
=
1
.
0
-
2
.
0
*
(
x
*
x
+
y
*
y
)
;
const
m14
=
transform
.
position
[
0
]
;
const
m24
=
transform
.
position
[
1
]
;
const
m34
=
transform
.
position
[
2
]
;
return
[
m11
m21
m31
0
m12
m22
m32
0
m13
m23
m33
0
m14
m24
m34
1
]
;
}
function
getPoseFromTransform
(
transform
)
{
const
[
px
py
pz
]
=
transform
.
position
;
const
[
ox
oy
oz
ow
]
=
transform
.
orientation
;
return
{
position
:
{
x
:
px
y
:
py
z
:
pz
}
orientation
:
{
x
:
ox
y
:
oy
z
:
oz
w
:
ow
}
}
;
}
function
composeGFXTransform
(
fakeTransformInit
)
{
return
{
matrix
:
getMatrixFromTransform
(
fakeTransformInit
)
}
;
}
class
ChromeXRTest
{
constructor
(
)
{
this
.
mockVRService_
=
new
MockVRService
(
)
;
}
simulateDeviceConnection
(
init_params
)
{
return
Promise
.
resolve
(
this
.
mockVRService_
.
addRuntime
(
init_params
)
)
;
}
disconnectAllDevices
(
)
{
this
.
mockVRService_
.
removeAllRuntimes
(
)
;
return
Promise
.
resolve
(
)
;
}
simulateUserActivation
(
callback
)
{
if
(
window
.
top
!
=
=
window
)
{
xr_debug
(
'
simulateUserActivation
'
'
use
eventSender
'
)
;
document
.
addEventListener
(
'
click
'
callback
)
;
eventSender
.
mouseMoveTo
(
0
0
)
;
eventSender
.
mouseDown
(
)
;
eventSender
.
mouseUp
(
)
;
document
.
removeEventListener
(
'
click
'
callback
)
;
return
;
}
const
button
=
document
.
createElement
(
'
button
'
)
;
button
.
textContent
=
'
click
to
continue
test
'
;
button
.
style
.
display
=
'
block
'
;
button
.
style
.
fontSize
=
'
20px
'
;
button
.
style
.
padding
=
'
10px
'
;
button
.
onclick
=
(
)
=
>
{
callback
(
)
;
document
.
body
.
removeChild
(
button
)
;
}
;
document
.
body
.
appendChild
(
button
)
;
test_driver
.
click
(
button
)
;
}
Debug
(
name
msg
)
{
console
.
log
(
new
Date
(
)
.
toISOString
(
)
+
'
DEBUG
[
'
+
name
+
'
]
'
+
msg
)
;
}
}
class
MockVRService
{
constructor
(
)
{
this
.
receiver_
=
new
vrMojom
.
VRServiceReceiver
(
this
)
;
this
.
runtimes_
=
[
]
;
this
.
interceptor_
=
new
MojoInterfaceInterceptor
(
vrMojom
.
VRService
.
interfaceName
)
;
this
.
interceptor_
.
oninterfacerequest
=
e
=
>
this
.
receiver_
.
.
bindHandle
(
e
.
handle
)
;
this
.
interceptor_
.
start
(
)
;
}
addRuntime
(
fakeDeviceInit
)
{
const
runtime
=
new
MockRuntime
(
fakeDeviceInit
this
)
;
this
.
runtimes_
.
push
(
runtime
)
;
if
(
this
.
client_
)
{
this
.
client_
.
onDeviceChanged
(
)
;
}
return
runtime
;
}
removeAllRuntimes
(
)
{
if
(
this
.
client_
)
{
this
.
client_
.
onDeviceChanged
(
)
;
}
this
.
runtimes_
=
[
]
;
}
removeRuntime
(
device
)
{
const
index
=
this
.
runtimes_
.
indexOf
(
device
)
;
if
(
index
>
=
0
)
{
this
.
runtimes_
.
splice
(
index
1
)
;
if
(
this
.
client_
)
{
this
.
client_
.
onDeviceChanged
(
)
;
}
}
}
setClient
(
client
)
{
if
(
this
.
client_
)
{
throw
new
Error
(
"
setClient
should
only
be
called
once
"
)
;
}
this
.
client_
=
client
;
}
requestSession
(
sessionOptions
)
{
const
requests
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
runtimes_
.
length
;
i
+
+
)
{
requests
[
i
]
=
this
.
runtimes_
[
i
]
.
requestRuntimeSession
(
sessionOptions
)
;
}
return
Promise
.
all
(
requests
)
.
then
(
(
results
)
=
>
{
for
(
let
i
=
0
;
i
<
results
.
length
;
i
+
+
)
{
if
(
results
[
i
]
.
session
)
{
const
metricsRecorderPtr
=
new
vrMojom
.
XRSessionMetricsRecorderRemote
(
)
;
metricsRecorderPtr
.
.
bindNewPipeAndPassReceiver
(
)
.
handle
.
close
(
)
;
const
success
=
{
session
:
results
[
i
]
.
session
metricsRecorder
:
metricsRecorderPtr
}
;
return
{
result
:
{
success
}
}
;
}
}
return
{
result
:
{
failureReason
:
vrMojom
.
RequestSessionError
.
NO_RUNTIME_FOUND
}
}
;
}
)
;
}
exitPresent
(
)
{
return
Promise
.
resolve
(
)
;
}
supportsSession
(
sessionOptions
)
{
const
requests
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
runtimes_
.
length
;
i
+
+
)
{
requests
[
i
]
=
this
.
runtimes_
[
i
]
.
runtimeSupportsSession
(
sessionOptions
)
;
}
return
Promise
.
all
(
requests
)
.
then
(
(
results
)
=
>
{
for
(
let
i
=
0
;
i
<
results
.
length
;
i
+
+
)
{
if
(
results
[
i
]
.
supportsSession
)
{
return
results
[
i
]
;
}
}
return
{
supportsSession
:
false
}
;
}
)
;
}
setFramesThrottled
(
throttled
)
{
this
.
setFramesThrottledImpl
(
throttled
)
;
}
setFramesThrottledImpl
(
throttled
)
{
}
makeXrCompatible
(
)
{
if
(
this
.
runtimes_
.
length
=
=
0
)
{
return
{
xrCompatibleResult
:
vrMojom
.
XrCompatibleResult
.
kNoDeviceAvailable
}
;
}
return
{
xrCompatibleResult
:
vrMojom
.
XrCompatibleResult
.
kAlreadyCompatible
}
;
}
}
class
FakeXRAnchorController
{
constructor
(
)
{
this
.
device_
=
null
;
this
.
id_
=
null
;
this
.
dirty_
=
true
;
this
.
deleted_
=
false
;
this
.
paused_
=
false
;
this
.
anchorOrigin_
=
XRMathHelper
.
identity
(
)
;
}
get
deleted
(
)
{
return
this
.
deleted_
;
}
pauseTracking
(
)
{
if
(
!
this
.
paused_
)
{
this
.
paused_
=
true
;
this
.
dirty_
=
true
;
}
}
resumeTracking
(
)
{
if
(
this
.
paused_
)
{
this
.
paused_
=
false
;
this
.
dirty_
=
true
;
}
}
stopTracking
(
)
{
if
(
!
this
.
deleted_
)
{
this
.
device_
.
deleteAnchorController
(
this
.
id_
)
;
this
.
deleted_
=
true
;
this
.
dirty_
=
true
;
}
}
setAnchorOrigin
(
anchorOrigin
)
{
this
.
anchorOrigin_
=
getMatrixFromTransform
(
anchorOrigin
)
;
this
.
dirty_
=
true
;
}
set
id
(
value
)
{
this
.
id_
=
value
;
}
set
device
(
value
)
{
this
.
device_
=
value
;
}
get
dirty
(
)
{
return
this
.
dirty_
;
}
get
paused
(
)
{
return
this
.
paused_
;
}
markProcessed
(
)
{
this
.
dirty_
=
false
;
}
getAnchorOrigin
(
)
{
return
this
.
anchorOrigin_
;
}
}
class
FakeXRHitTestSourceController
{
constructor
(
id
)
{
this
.
id_
=
id
;
this
.
deleted_
=
false
;
}
get
deleted
(
)
{
return
this
.
deleted_
;
}
set
deleted
(
value
)
{
this
.
deleted_
=
value
;
}
}
class
MockRuntime
{
static
featureToMojoMap
=
{
'
viewer
'
:
vrMojom
.
XRSessionFeature
.
REF_SPACE_VIEWER
'
local
'
:
vrMojom
.
XRSessionFeature
.
REF_SPACE_LOCAL
'
local
-
floor
'
:
vrMojom
.
XRSessionFeature
.
REF_SPACE_LOCAL_FLOOR
'
bounded
-
floor
'
:
vrMojom
.
XRSessionFeature
.
REF_SPACE_BOUNDED_FLOOR
'
unbounded
'
:
vrMojom
.
XRSessionFeature
.
REF_SPACE_UNBOUNDED
'
hit
-
test
'
:
vrMojom
.
XRSessionFeature
.
HIT_TEST
'
dom
-
overlay
'
:
vrMojom
.
XRSessionFeature
.
DOM_OVERLAY
'
light
-
estimation
'
:
vrMojom
.
XRSessionFeature
.
LIGHT_ESTIMATION
'
anchors
'
:
vrMojom
.
XRSessionFeature
.
ANCHORS
'
depth
-
sensing
'
:
vrMojom
.
XRSessionFeature
.
DEPTH
}
;
static
sessionModeToMojoMap
=
{
"
inline
"
:
vrMojom
.
XRSessionMode
.
kInline
"
immersive
-
vr
"
:
vrMojom
.
XRSessionMode
.
kImmersiveVr
"
immersive
-
ar
"
:
vrMojom
.
XRSessionMode
.
kImmersiveAr
}
;
static
environmentBlendModeToMojoMap
=
{
"
opaque
"
:
vrMojom
.
XREnvironmentBlendMode
.
kOpaque
"
alpha
-
blend
"
:
vrMojom
.
XREnvironmentBlendMode
.
kAlphaBlend
"
additive
"
:
vrMojom
.
XREnvironmentBlendMode
.
kAdditive
}
;
static
interactionModeToMojoMap
=
{
"
screen
-
space
"
:
vrMojom
.
XRInteractionMode
.
kScreenSpace
"
world
-
space
"
:
vrMojom
.
XRInteractionMode
.
kWorldSpace
}
;
constructor
(
fakeDeviceInit
service
)
{
this
.
sessionClient_
=
null
;
this
.
presentation_provider_
=
new
MockXRPresentationProvider
(
)
;
this
.
pose_
=
null
;
this
.
next_frame_id_
=
0
;
this
.
bounds_
=
null
;
this
.
send_mojo_space_reset_
=
false
;
this
.
stageParameters_
=
null
;
this
.
stageParametersId_
=
1
;
this
.
service_
=
service
;
this
.
framesOfReference
=
{
}
;
this
.
input_sources_
=
new
Map
(
)
;
this
.
next_input_source_index_
=
1
;
this
.
hitTestSubscriptions_
=
new
Map
(
)
;
this
.
transientHitTestSubscriptions_
=
new
Map
(
)
;
this
.
next_hit_test_id_
=
1n
;
this
.
anchor_controllers_
=
new
Map
(
)
;
this
.
next_anchor_id_
=
1n
;
this
.
anchor_creation_callback_
=
null
;
this
.
depthSensingData_
=
null
;
this
.
depthSensingDataDirty_
=
false
;
let
supportedModes
=
[
]
;
if
(
fakeDeviceInit
.
supportedModes
)
{
supportedModes
=
fakeDeviceInit
.
supportedModes
.
slice
(
)
;
if
(
fakeDeviceInit
.
supportedModes
.
length
=
=
=
0
)
{
supportedModes
=
[
"
inline
"
]
;
}
}
else
{
console
.
warn
(
"
Please
use
supportedModes
to
signal
which
modes
are
supported
by
this
device
.
"
)
;
if
(
fakeDeviceInit
.
supportsImmersive
=
=
null
)
{
throw
new
TypeError
(
"
'
supportsImmersive
'
must
be
set
"
)
;
}
supportedModes
=
[
"
inline
"
]
;
if
(
fakeDeviceInit
.
supportsImmersive
)
{
supportedModes
.
push
(
"
immersive
-
vr
"
)
;
}
}
this
.
supportedModes_
=
this
.
_convertModesToEnum
(
supportedModes
)
;
if
(
this
.
supportedModes_
.
includes
(
vrMojom
.
XRSessionMode
.
kImmersiveVr
)
|
|
this
.
supportedModes_
.
includes
(
vrMojom
.
XRSessionMode
.
kImmersiveAr
)
)
{
this
.
displayInfo_
=
this
.
getImmersiveDisplayInfo
(
)
;
}
else
if
(
this
.
supportedModes_
.
includes
(
vrMojom
.
XRSessionMode
.
kInline
)
)
{
this
.
displayInfo_
=
this
.
getNonImmersiveDisplayInfo
(
)
;
}
else
{
console
.
error
(
"
Device
has
empty
supported
modes
array
!
"
)
;
throw
new
InvalidStateError
(
)
;
}
if
(
fakeDeviceInit
.
viewerOrigin
!
=
null
)
{
this
.
setViewerOrigin
(
fakeDeviceInit
.
viewerOrigin
)
;
}
if
(
fakeDeviceInit
.
floorOrigin
!
=
null
)
{
this
.
setFloorOrigin
(
fakeDeviceInit
.
floorOrigin
)
;
}
if
(
fakeDeviceInit
.
world
)
{
this
.
world_
=
fakeDeviceInit
.
world
;
}
if
(
fakeDeviceInit
.
depthSensingData
)
{
this
.
setDepthSensingData
(
fakeDeviceInit
.
depthSensingData
)
;
}
this
.
defaultFramebufferScale_
=
default_framebuffer_scale
;
this
.
enviromentBlendMode_
=
this
.
_convertBlendModeToEnum
(
fakeDeviceInit
.
environmentBlendMode
)
;
this
.
interactionMode_
=
this
.
_convertInteractionModeToEnum
(
fakeDeviceInit
.
interactionMode
)
;
this
.
setBoundsGeometry
(
fakeDeviceInit
.
boundsCoordinates
)
;
this
.
setViews
(
fakeDeviceInit
.
views
)
;
this
.
setFeatures
(
fakeDeviceInit
.
supportedFeatures
|
|
[
]
)
;
}
_convertModeToEnum
(
sessionMode
)
{
if
(
sessionMode
in
MockRuntime
.
sessionModeToMojoMap
)
{
return
MockRuntime
.
sessionModeToMojoMap
[
sessionMode
]
;
}
throw
new
TypeError
(
"
Unrecognized
value
for
XRSessionMode
enum
:
"
+
sessionMode
)
;
}
_convertModesToEnum
(
sessionModes
)
{
return
sessionModes
.
map
(
mode
=
>
this
.
_convertModeToEnum
(
mode
)
)
;
}
_convertBlendModeToEnum
(
blendMode
)
{
if
(
blendMode
in
MockRuntime
.
environmentBlendModeToMojoMap
)
{
return
MockRuntime
.
environmentBlendModeToMojoMap
[
blendMode
]
;
}
else
{
if
(
this
.
supportedModes_
.
includes
(
vrMojom
.
XRSessionMode
.
kImmersiveAr
)
)
{
return
vrMojom
.
XREnvironmentBlendMode
.
kAdditive
;
}
else
if
(
this
.
supportedModes_
.
includes
(
vrMojom
.
XRSessionMode
.
kImmersiveVr
)
)
{
return
vrMojom
.
XREnvironmentBlendMode
.
kOpaque
;
}
}
}
_convertInteractionModeToEnum
(
interactionMode
)
{
if
(
interactionMode
in
MockRuntime
.
interactionModeToMojoMap
)
{
return
MockRuntime
.
interactionModeToMojoMap
[
interactionMode
]
;
}
else
{
return
vrMojom
.
XRInteractionMode
.
kWorldSpace
;
}
}
disconnect
(
)
{
this
.
service_
.
removeRuntime
(
this
)
;
this
.
presentation_provider_
.
Close
(
)
;
if
(
this
.
sessionClient_
)
{
this
.
sessionClient_
.
.
close
(
)
;
this
.
sessionClient_
=
null
;
}
return
Promise
.
resolve
(
)
;
}
setViews
(
views
)
{
if
(
views
)
{
this
.
displayInfo_
.
views
=
[
]
;
this
.
viewOffsets_
=
[
]
;
for
(
let
i
=
0
;
i
<
views
.
length
;
i
+
+
)
{
this
.
displayInfo_
.
views
[
i
]
=
this
.
getView
(
views
[
i
]
)
;
this
.
viewOffsets_
[
i
]
=
composeGFXTransform
(
views
[
i
]
.
viewOffset
)
;
}
if
(
this
.
sessionClient_
)
{
this
.
sessionClient_
.
onChanged
(
this
.
displayInfo_
)
;
}
}
}
setViewerOrigin
(
origin
emulatedPosition
=
false
)
{
const
p
=
origin
.
position
;
const
q
=
origin
.
orientation
;
this
.
pose_
=
{
orientation
:
{
x
:
q
[
0
]
y
:
q
[
1
]
z
:
q
[
2
]
w
:
q
[
3
]
}
position
:
{
x
:
p
[
0
]
y
:
p
[
1
]
z
:
p
[
2
]
}
emulatedPosition
:
emulatedPosition
angularVelocity
:
null
linearVelocity
:
null
angularAcceleration
:
null
linearAcceleration
:
null
inputState
:
null
poseIndex
:
0
}
;
}
clearViewerOrigin
(
)
{
this
.
pose_
=
null
;
}
simulateVisibilityChange
(
visibilityState
)
{
let
mojoState
=
null
;
switch
(
visibilityState
)
{
case
"
visible
"
:
mojoState
=
vrMojom
.
XRVisibilityState
.
VISIBLE
;
break
;
case
"
visible
-
blurred
"
:
mojoState
=
vrMojom
.
XRVisibilityState
.
VISIBLE_BLURRED
;
break
;
case
"
hidden
"
:
mojoState
=
vrMojom
.
XRVisibilityState
.
HIDDEN
;
break
;
}
if
(
mojoState
&
&
this
.
sessionClient_
)
{
this
.
sessionClient_
.
onVisibilityStateChanged
(
mojoState
)
;
}
}
setBoundsGeometry
(
bounds
)
{
if
(
bounds
=
=
null
)
{
this
.
bounds_
=
null
;
}
else
if
(
bounds
.
length
<
3
)
{
throw
new
Error
(
"
Bounds
must
have
a
length
of
at
least
3
"
)
;
}
else
{
this
.
bounds_
=
bounds
;
}
if
(
this
.
stageParameters_
)
{
this
.
stageParameters_
.
bounds
=
this
.
bounds_
;
this
.
onStageParametersUpdated
(
)
;
}
}
setFloorOrigin
(
floorOrigin
)
{
if
(
!
this
.
stageParameters_
)
{
this
.
stageParameters_
=
default_stage_parameters
;
this
.
stageParameters_
.
bounds
=
this
.
bounds_
;
}
this
.
stageParameters_
.
mojoFromFloor
=
{
matrix
:
getMatrixFromTransform
(
floorOrigin
)
}
;
this
.
onStageParametersUpdated
(
)
;
}
clearFloorOrigin
(
)
{
if
(
this
.
stageParameters_
)
{
this
.
stageParameters_
=
null
;
this
.
onStageParametersUpdated
(
)
;
}
}
onStageParametersUpdated
(
)
{
this
.
stageParametersId_
+
+
;
}
simulateResetPose
(
)
{
this
.
send_mojo_space_reset_
=
true
;
}
simulateInputSourceConnection
(
fakeInputSourceInit
)
{
const
index
=
this
.
next_input_source_index_
;
this
.
next_input_source_index_
+
+
;
const
source
=
new
MockXRInputSource
(
fakeInputSourceInit
index
this
)
;
this
.
input_sources_
.
set
(
index
source
)
;
return
source
;
}
setAnchorCreationCallback
(
callback
)
{
this
.
anchor_creation_callback_
=
callback
;
}
setHitTestSourceCreationCallback
(
callback
)
{
this
.
hit_test_source_creation_callback_
=
callback
;
}
setLightEstimate
(
fakeXrLightEstimateInit
)
{
if
(
!
fakeXrLightEstimateInit
.
sphericalHarmonicsCoefficients
)
{
throw
new
TypeError
(
"
sphericalHarmonicsCoefficients
must
be
set
"
)
;
}
if
(
fakeXrLightEstimateInit
.
sphericalHarmonicsCoefficients
.
length
!
=
27
)
{
throw
new
TypeError
(
"
Must
supply
all
27
sphericalHarmonicsCoefficients
"
)
;
}
if
(
fakeXrLightEstimateInit
.
primaryLightDirection
&
&
fakeXrLightEstimateInit
.
primaryLightDirection
.
w
!
=
0
)
{
throw
new
TypeError
(
"
W
component
of
primaryLightDirection
must
be
0
"
)
;
}
if
(
fakeXrLightEstimateInit
.
primaryLightIntensity
&
&
fakeXrLightEstimateInit
.
primaryLightIntensity
.
w
!
=
1
)
{
throw
new
TypeError
(
"
W
component
of
primaryLightIntensity
must
be
1
"
)
;
}
if
(
!
fakeXrLightEstimateInit
.
primaryLightDirection
)
{
fakeXrLightEstimateInit
.
primaryLightDirection
=
{
x
:
0
.
0
y
:
1
.
0
z
:
0
.
0
w
:
0
.
0
}
;
}
if
(
!
fakeXrLightEstimateInit
.
primaryLightIntensity
)
{
fakeXrLightEstimateInit
.
primaryLightIntensity
=
{
x
:
0
.
0
y
:
0
.
0
z
:
0
.
0
w
:
1
.
0
}
;
}
let
c
=
fakeXrLightEstimateInit
.
sphericalHarmonicsCoefficients
;
this
.
light_estimate_
=
{
lightProbe
:
{
sphericalHarmonics
:
{
coefficients
:
[
{
red
:
c
[
0
]
green
:
c
[
1
]
blue
:
c
[
2
]
}
{
red
:
c
[
3
]
green
:
c
[
4
]
blue
:
c
[
5
]
}
{
red
:
c
[
6
]
green
:
c
[
7
]
blue
:
c
[
8
]
}
{
red
:
c
[
9
]
green
:
c
[
10
]
blue
:
c
[
11
]
}
{
red
:
c
[
12
]
green
:
c
[
13
]
blue
:
c
[
14
]
}
{
red
:
c
[
15
]
green
:
c
[
16
]
blue
:
c
[
17
]
}
{
red
:
c
[
18
]
green
:
c
[
19
]
blue
:
c
[
20
]
}
{
red
:
c
[
21
]
green
:
c
[
22
]
blue
:
c
[
23
]
}
{
red
:
c
[
24
]
green
:
c
[
25
]
blue
:
c
[
26
]
}
]
}
mainLightDirection
:
{
x
:
fakeXrLightEstimateInit
.
primaryLightDirection
.
x
y
:
fakeXrLightEstimateInit
.
primaryLightDirection
.
y
z
:
fakeXrLightEstimateInit
.
primaryLightDirection
.
z
}
mainLightIntensity
:
{
red
:
fakeXrLightEstimateInit
.
primaryLightIntensity
.
x
green
:
fakeXrLightEstimateInit
.
primaryLightIntensity
.
y
blue
:
fakeXrLightEstimateInit
.
primaryLightIntensity
.
z
}
}
}
}
setDepthSensingData
(
depthSensingData
)
{
for
(
const
key
of
[
"
depthData
"
"
normDepthBufferFromNormView
"
"
rawValueToMeters
"
"
width
"
"
height
"
]
)
{
if
(
!
(
key
in
depthSensingData
)
)
{
throw
new
TypeError
(
"
Required
key
not
present
.
Key
:
"
+
key
)
;
}
}
if
(
depthSensingData
.
depthData
!
=
null
)
{
this
.
depthSensingData_
=
Object
.
assign
(
{
}
depthSensingData
{
normDepthBufferFromNormView
:
composeGFXTransform
(
depthSensingData
.
normDepthBufferFromNormView
)
}
)
;
}
else
{
throw
new
TypeError
(
"
depthData
is
not
set
"
)
;
}
this
.
depthSensingDataDirty_
=
true
;
}
clearDepthSensingData
(
)
{
this
.
depthSensingData_
=
null
;
this
.
depthSensingDataDirty_
=
true
;
}
getNonImmersiveDisplayInfo
(
)
{
const
displayInfo
=
this
.
getImmersiveDisplayInfo
(
)
;
displayInfo
.
capabilities
.
canPresent
=
false
;
displayInfo
.
views
=
[
]
;
return
displayInfo
;
}
getImmersiveDisplayInfo
(
)
{
const
viewport_size
=
20
;
return
{
displayName
:
'
FakeDevice
'
capabilities
:
{
hasPosition
:
false
hasExternalDisplay
:
false
canPresent
:
true
maxLayers
:
1
}
stageParameters
:
null
views
:
[
{
eye
:
vrMojom
.
XREye
.
kLeft
fieldOfView
:
{
upDegrees
:
48
.
316
downDegrees
:
50
.
099
leftDegrees
:
50
.
899
rightDegrees
:
35
.
197
}
mojoFromView
:
this
.
_getMojoFromViewerWithOffset
(
composeGFXTransform
(
{
position
:
[
-
0
.
032
0
0
]
orientation
:
[
0
0
0
1
]
}
)
)
viewport
:
{
width
:
viewport_size
height
:
viewport_size
}
}
{
eye
:
vrMojom
.
XREye
.
kRight
fieldOfView
:
{
upDegrees
:
48
.
316
downDegrees
:
50
.
099
leftDegrees
:
50
.
899
rightDegrees
:
35
.
197
}
mojoFromView
:
this
.
_getMojoFromViewerWithOffset
(
composeGFXTransform
(
{
position
:
[
0
.
032
0
0
]
orientation
:
[
0
0
0
1
]
}
)
)
viewport
:
{
width
:
viewport_size
height
:
viewport_size
}
}
]
}
;
}
getView
(
fakeXRViewInit
)
{
let
fov
=
null
;
if
(
fakeXRViewInit
.
fieldOfView
)
{
fov
=
{
upDegrees
:
fakeXRViewInit
.
fieldOfView
.
upDegrees
downDegrees
:
fakeXRViewInit
.
fieldOfView
.
downDegrees
leftDegrees
:
fakeXRViewInit
.
fieldOfView
.
leftDegrees
rightDegrees
:
fakeXRViewInit
.
fieldOfView
.
rightDegrees
}
;
}
else
{
const
m
=
fakeXRViewInit
.
projectionMatrix
;
function
toDegrees
(
tan
)
{
return
Math
.
atan
(
tan
)
*
180
/
Math
.
PI
;
}
const
leftTan
=
(
1
-
m
[
8
]
)
/
m
[
0
]
;
const
rightTan
=
(
1
+
m
[
8
]
)
/
m
[
0
]
;
const
upTan
=
(
1
+
m
[
9
]
)
/
m
[
5
]
;
const
downTan
=
(
1
-
m
[
9
]
)
/
m
[
5
]
;
fov
=
{
upDegrees
:
toDegrees
(
upTan
)
downDegrees
:
toDegrees
(
downTan
)
leftDegrees
:
toDegrees
(
leftTan
)
rightDegrees
:
toDegrees
(
rightTan
)
}
;
}
let
viewEye
=
vrMojom
.
XREye
.
kNone
;
switch
(
fakeXRViewInit
.
eye
)
{
case
"
none
"
:
viewEye
=
vrMojom
.
XREye
.
kNone
;
break
;
case
"
left
"
:
viewEye
=
vrMojom
.
XREye
.
kLeft
;
break
;
case
"
right
"
:
viewEye
=
vrMojom
.
XREye
.
kRight
;
break
;
}
return
{
eye
:
viewEye
fieldOfView
:
fov
mojoFromView
:
this
.
_getMojoFromViewerWithOffset
(
composeGFXTransform
(
fakeXRViewInit
.
viewOffset
)
)
viewport
:
{
width
:
fakeXRViewInit
.
resolution
.
width
height
:
fakeXRViewInit
.
resolution
.
height
}
}
;
}
setFeatures
(
supportedFeatures
)
{
function
convertFeatureToMojom
(
feature
)
{
if
(
feature
in
MockRuntime
.
featureToMojoMap
)
{
return
MockRuntime
.
featureToMojoMap
[
feature
]
;
}
else
{
return
vrMojom
.
XRSessionFeature
.
INVALID
;
}
}
this
.
supportedFeatures_
=
[
]
;
for
(
let
i
=
0
;
i
<
supportedFeatures
.
length
;
i
+
+
)
{
const
feature
=
convertFeatureToMojom
(
supportedFeatures
[
i
]
)
;
if
(
feature
!
=
=
vrMojom
.
XRSessionFeature
.
INVALID
)
{
this
.
supportedFeatures_
.
push
(
feature
)
;
}
}
}
addInputSource
(
source
)
{
if
(
!
this
.
input_sources_
.
has
(
source
.
source_id_
)
)
{
this
.
input_sources_
.
set
(
source
.
source_id_
source
)
;
}
}
removeInputSource
(
source
)
{
this
.
input_sources_
.
delete
(
source
.
source_id_
)
;
}
deleteAnchorController
(
controllerId
)
{
this
.
anchor_controllers_
.
delete
(
controllerId
)
;
}
_injectAdditionalFrameData
(
options
frameData
)
{
}
getFrameData
(
options
)
{
return
new
Promise
(
(
resolve
)
=
>
{
const
populatePose
=
(
)
=
>
{
const
mojo_space_reset
=
this
.
send_mojo_space_reset_
;
this
.
send_mojo_space_reset_
=
false
;
if
(
this
.
pose_
)
{
this
.
pose_
.
poseIndex
+
+
;
}
let
input_state
=
null
;
if
(
this
.
input_sources_
.
size
>
0
)
{
input_state
=
[
]
;
for
(
const
input_source
of
this
.
input_sources_
.
values
(
)
)
{
input_state
.
push
(
input_source
.
getInputSourceState
(
)
)
;
}
}
let
views
=
this
.
displayInfo_
.
views
;
for
(
let
i
=
0
;
i
<
views
.
length
;
i
+
+
)
{
views
[
i
]
.
mojoFromView
=
this
.
_getMojoFromViewerWithOffset
(
this
.
viewOffsets_
[
i
]
)
;
}
const
frameData
=
{
pose
:
this
.
pose_
views
:
views
mojoSpaceReset
:
mojo_space_reset
inputState
:
input_state
timeDelta
:
{
microseconds
:
BigInt
(
Math
.
floor
(
window
.
performance
.
now
(
)
*
1000
)
)
}
frameId
:
this
.
next_frame_id_
bufferHolder
:
null
bufferSize
:
{
}
renderingTimeRatio
:
0
stageParameters
:
this
.
stageParameters_
stageParametersId
:
this
.
stageParametersId_
lightEstimationData
:
this
.
light_estimate_
}
;
this
.
next_frame_id_
+
+
;
this
.
_calculateHitTestResults
(
frameData
)
;
this
.
_calculateAnchorInformation
(
frameData
)
;
this
.
_calculateDepthInformation
(
frameData
)
;
this
.
_injectAdditionalFrameData
(
options
frameData
)
;
resolve
(
{
frameData
}
)
;
}
;
if
(
this
.
sessionOptions_
.
mode
=
=
vrMojom
.
XRSessionMode
.
kInline
)
{
populatePose
(
)
;
}
else
{
setTimeout
(
populatePose
3
)
;
}
}
)
;
}
getEnvironmentIntegrationProvider
(
environmentProviderRequest
)
{
if
(
this
.
environmentProviderReceiver_
)
{
this
.
environmentProviderReceiver_
.
.
close
(
)
;
}
this
.
environmentProviderReceiver_
=
new
vrMojom
.
XREnvironmentIntegrationProviderReceiver
(
this
)
;
this
.
environmentProviderReceiver_
.
.
bindHandle
(
environmentProviderRequest
.
handle
)
;
}
setInputSourceButtonListener
(
listener
)
{
listener
.
.
close
(
)
;
}
closeEnvironmentIntegrationProvider
(
)
{
if
(
this
.
environmentProviderReceiver_
)
{
this
.
environmentProviderReceiver_
.
.
close
(
)
;
}
}
closeDataProvider
(
)
{
this
.
closeEnvironmentIntegrationProvider
(
)
;
this
.
dataProviderReceiver_
.
.
close
(
)
;
this
.
sessionOptions_
=
null
;
}
subscribeToHitTest
(
nativeOriginInformation
entityTypes
ray
)
{
if
(
!
this
.
supportedModes_
.
includes
(
vrMojom
.
XRSessionMode
.
kImmersiveAr
)
)
{
return
Promise
.
resolve
(
{
result
:
vrMojom
.
SubscribeToHitTestResult
.
FAILURE_GENERIC
subscriptionId
:
0n
}
)
;
}
if
(
!
this
.
_nativeOriginKnown
(
nativeOriginInformation
)
)
{
return
Promise
.
resolve
(
{
result
:
vrMojom
.
SubscribeToHitTestResult
.
FAILURE_GENERIC
subscriptionId
:
0n
}
)
;
}
const
id
=
this
.
next_hit_test_id_
+
+
;
const
hitTestParameters
=
{
isTransient
:
false
profileName
:
null
}
;
const
controller
=
new
FakeXRHitTestSourceController
(
id
)
;
return
this
.
_shouldHitTestSourceCreationSucceed
(
hitTestParameters
controller
)
.
then
(
(
succeeded
)
=
>
{
if
(
succeeded
)
{
this
.
hitTestSubscriptions_
.
set
(
id
{
nativeOriginInformation
entityTypes
ray
controller
}
)
;
return
Promise
.
resolve
(
{
result
:
vrMojom
.
SubscribeToHitTestResult
.
SUCCESS
subscriptionId
:
id
}
)
;
}
else
{
return
Promise
.
resolve
(
{
result
:
vrMojom
.
SubscribeToHitTestResult
.
FAILURE_GENERIC
subscriptionId
:
0n
}
)
;
}
}
)
;
}
subscribeToHitTestForTransientInput
(
profileName
entityTypes
ray
)
{
if
(
!
this
.
supportedModes_
.
includes
(
vrMojom
.
XRSessionMode
.
kImmersiveAr
)
)
{
return
Promise
.
resolve
(
{
result
:
vrMojom
.
SubscribeToHitTestResult
.
FAILURE_GENERIC
subscriptionId
:
0n
}
)
;
}
const
id
=
this
.
next_hit_test_id_
+
+
;
const
hitTestParameters
=
{
isTransient
:
true
profileName
:
profileName
}
;
const
controller
=
new
FakeXRHitTestSourceController
(
id
)
;
return
this
.
_shouldHitTestSourceCreationSucceed
(
hitTestParameters
controller
)
.
then
(
(
succeeded
)
=
>
{
if
(
succeeded
)
{
this
.
transientHitTestSubscriptions_
.
set
(
id
{
profileName
entityTypes
ray
controller
}
)
;
return
Promise
.
resolve
(
{
result
:
vrMojom
.
SubscribeToHitTestResult
.
SUCCESS
subscriptionId
:
id
}
)
;
}
else
{
return
Promise
.
resolve
(
{
result
:
vrMojom
.
SubscribeToHitTestResult
.
FAILURE_GENERIC
subscriptionId
:
0n
}
)
;
}
}
)
;
}
unsubscribeFromHitTest
(
subscriptionId
)
{
let
controller
=
null
;
if
(
this
.
transientHitTestSubscriptions_
.
has
(
subscriptionId
)
)
{
controller
=
this
.
transientHitTestSubscriptions_
.
get
(
subscriptionId
)
.
controller
;
this
.
transientHitTestSubscriptions_
.
delete
(
subscriptionId
)
;
}
else
if
(
this
.
hitTestSubscriptions_
.
has
(
subscriptionId
)
)
{
controller
=
this
.
hitTestSubscriptions_
.
get
(
subscriptionId
)
.
controller
;
this
.
hitTestSubscriptions_
.
delete
(
subscriptionId
)
;
}
if
(
controller
)
{
controller
.
deleted
=
true
;
}
}
createAnchor
(
nativeOriginInformation
nativeOriginFromAnchor
)
{
return
new
Promise
(
(
resolve
)
=
>
{
if
(
this
.
anchor_creation_callback_
=
=
null
)
{
resolve
(
{
result
:
vrMojom
.
CreateAnchorResult
.
FAILURE
anchorId
:
0n
}
)
;
return
;
}
const
mojoFromNativeOrigin
=
this
.
_getMojoFromNativeOrigin
(
nativeOriginInformation
)
;
if
(
mojoFromNativeOrigin
=
=
null
)
{
resolve
(
{
result
:
vrMojom
.
CreateAnchorResult
.
FAILURE
anchorId
:
0n
}
)
;
return
;
}
const
mojoFromAnchor
=
XRMathHelper
.
mul4x4
(
mojoFromNativeOrigin
nativeOriginFromAnchor
)
;
const
anchorCreationParameters
=
{
requestedAnchorOrigin
:
mojoFromAnchor
isAttachedToEntity
:
false
}
;
const
anchorController
=
new
FakeXRAnchorController
(
)
;
this
.
anchor_creation_callback_
(
anchorCreationParameters
anchorController
)
.
then
(
(
result
)
=
>
{
if
(
result
)
{
const
anchor_id
=
this
.
next_anchor_id_
;
this
.
next_anchor_id_
+
+
;
this
.
anchor_controllers_
.
set
(
anchor_id
anchorController
)
;
anchorController
.
device
=
this
;
anchorController
.
id
=
anchor_id
;
resolve
(
{
result
:
vrMojom
.
CreateAnchorResult
.
SUCCESS
anchorId
:
anchor_id
}
)
;
}
else
{
resolve
(
{
result
:
vrMojom
.
CreateAnchorResult
.
FAILURE
anchorId
:
0n
}
)
;
}
}
)
.
catch
(
(
)
=
>
{
resolve
(
{
result
:
vrMojom
.
CreateAnchorResult
.
FAILURE
anchorId
:
0n
}
)
;
}
)
;
}
)
;
}
createPlaneAnchor
(
planeFromAnchor
planeId
)
{
return
new
Promise
(
(
resolve
)
=
>
{
resolve
(
{
result
:
vrMojom
.
CreateAnchorResult
.
FAILURE
anchorId
:
0n
}
)
;
}
)
;
}
detachAnchor
(
anchorId
)
{
}
requestRuntimeSession
(
sessionOptions
)
{
return
this
.
runtimeSupportsSession
(
sessionOptions
)
.
then
(
(
result
)
=
>
{
const
options
=
{
transportMethod
:
vrMojom
.
XRPresentationTransportMethod
.
SUBMIT_AS_MAILBOX_HOLDER
waitForTransferNotification
:
true
waitForRenderNotification
:
true
waitForGpuFence
:
false
}
;
let
submit_frame_sink
;
if
(
result
.
supportsSession
)
{
submit_frame_sink
=
{
clientReceiver
:
this
.
presentation_provider_
.
getClientReceiver
(
)
provider
:
this
.
presentation_provider_
.
bindProvider
(
sessionOptions
)
transportOptions
:
options
}
;
const
dataProviderPtr
=
new
vrMojom
.
XRFrameDataProviderRemote
(
)
;
this
.
dataProviderReceiver_
=
new
vrMojom
.
XRFrameDataProviderReceiver
(
this
)
;
this
.
dataProviderReceiver_
.
.
bindHandle
(
dataProviderPtr
.
.
bindNewPipeAndPassReceiver
(
)
.
handle
)
;
this
.
sessionOptions_
=
sessionOptions
;
this
.
sessionClient_
=
new
vrMojom
.
XRSessionClientRemote
(
)
;
const
clientReceiver
=
this
.
sessionClient_
.
.
bindNewPipeAndPassReceiver
(
)
;
const
enabled_features
=
[
]
;
for
(
let
i
=
0
;
i
<
sessionOptions
.
requiredFeatures
.
length
;
i
+
+
)
{
if
(
this
.
supportedFeatures_
.
indexOf
(
sessionOptions
.
requiredFeatures
[
i
]
)
!
=
=
-
1
)
{
enabled_features
.
push
(
sessionOptions
.
requiredFeatures
[
i
]
)
;
}
else
{
return
Promise
.
resolve
(
{
session
:
null
}
)
;
}
}
for
(
let
i
=
0
;
i
<
sessionOptions
.
optionalFeatures
.
length
;
i
+
+
)
{
if
(
this
.
supportedFeatures_
.
indexOf
(
sessionOptions
.
optionalFeatures
[
i
]
)
!
=
=
-
1
)
{
enabled_features
.
push
(
sessionOptions
.
optionalFeatures
[
i
]
)
;
}
}
this
.
enabledFeatures_
=
enabled_features
;
return
Promise
.
resolve
(
{
session
:
{
submitFrameSink
:
submit_frame_sink
dataProvider
:
dataProviderPtr
clientReceiver
:
clientReceiver
displayInfo
:
this
.
displayInfo_
enabledFeatures
:
enabled_features
deviceConfig
:
{
usesInputEventing
:
false
defaultFramebufferScale
:
this
.
defaultFramebufferScale_
supportsViewportScaling
:
true
depthConfiguration
:
enabled_features
.
includes
(
vrMojom
.
XRSessionFeature
.
DEPTH
)
?
{
depthUsage
:
vrMojom
.
XRDepthUsage
.
kCPUOptimized
depthDataFormat
:
vrMojom
.
XRDepthDataFormat
.
kLuminanceAlpha
}
:
null
}
enviromentBlendMode
:
this
.
enviromentBlendMode_
interactionMode
:
this
.
interactionMode_
}
}
)
;
}
else
{
return
Promise
.
resolve
(
{
session
:
null
}
)
;
}
}
)
;
}
runtimeSupportsSession
(
options
)
{
let
result
=
this
.
supportedModes_
.
includes
(
options
.
mode
)
;
if
(
options
.
requiredFeatures
.
includes
(
vrMojom
.
XRSessionFeature
.
DEPTH
)
|
|
options
.
optionalFeatures
.
includes
(
vrMojom
.
XRSessionFeature
.
DEPTH
)
)
{
result
&
=
options
.
depthOptions
.
usagePreferences
.
includes
(
vrMojom
.
XRDepthUsage
.
kCPUOptimized
)
;
result
&
=
options
.
depthOptions
.
dataFormatPreferences
.
includes
(
vrMojom
.
XRDepthDataFormat
.
kLuminanceAlpha
)
;
}
return
Promise
.
resolve
(
{
supportsSession
:
result
}
)
;
}
_nativeOriginKnown
(
nativeOriginInformation
)
{
if
(
nativeOriginInformation
.
inputSourceSpaceInfo
!
=
=
undefined
)
{
if
(
!
this
.
input_sources_
.
has
(
nativeOriginInformation
.
inputSourceSpaceInfo
.
inputSourceId
)
)
{
return
false
;
}
return
true
;
}
else
if
(
nativeOriginInformation
.
referenceSpaceType
!
=
=
undefined
)
{
if
(
nativeOriginInformation
.
referenceSpaceType
=
=
vrMojom
.
XRReferenceSpaceType
.
kUnbounded
|
|
nativeOriginInformation
.
referenceSpaceType
=
=
vrMojom
.
XRReferenceSpaceType
.
kBoundedFloor
)
{
return
false
;
}
return
true
;
}
else
{
return
false
;
}
}
_calculateAnchorInformation
(
frameData
)
{
if
(
!
this
.
supportedModes_
.
includes
(
vrMojom
.
XRSessionMode
.
kImmersiveAr
)
)
{
return
;
}
frameData
.
anchorsData
=
{
allAnchorsIds
:
[
]
updatedAnchorsData
:
[
]
}
;
for
(
const
[
id
controller
]
of
this
.
anchor_controllers_
)
{
frameData
.
anchorsData
.
allAnchorsIds
.
push
(
id
)
;
if
(
controller
.
dirty
)
{
const
anchorData
=
{
id
}
;
if
(
!
controller
.
paused
)
{
anchorData
.
mojoFromAnchor
=
getPoseFromTransform
(
XRMathHelper
.
decomposeRigidTransform
(
controller
.
getAnchorOrigin
(
)
)
)
;
}
controller
.
markProcessed
(
)
;
frameData
.
anchorsData
.
updatedAnchorsData
.
push
(
anchorData
)
;
}
}
}
_calculateDepthInformation
(
frameData
)
{
if
(
!
this
.
supportedModes_
.
includes
(
vrMojom
.
XRSessionMode
.
kImmersiveAr
)
)
{
return
;
}
if
(
!
this
.
enabledFeatures_
.
includes
(
vrMojom
.
XRSessionFeature
.
DEPTH
)
)
{
return
;
}
if
(
this
.
depthSensingData_
=
=
null
)
{
frameData
.
depthData
=
null
;
return
;
}
if
(
!
this
.
depthSensingDataDirty_
)
{
frameData
.
depthData
=
{
dataStillValid
:
{
}
}
;
return
;
}
frameData
.
depthData
=
{
updatedDepthData
:
{
timeDelta
:
frameData
.
timeDelta
normTextureFromNormView
:
this
.
depthSensingData_
.
normDepthBufferFromNormView
rawValueToMeters
:
this
.
depthSensingData_
.
rawValueToMeters
size
:
{
width
:
this
.
depthSensingData_
.
width
height
:
this
.
depthSensingData_
.
height
}
pixelData
:
{
bytes
:
this
.
depthSensingData_
.
depthData
}
}
}
;
this
.
depthSensingDataDirty_
=
false
;
}
_shouldHitTestSourceCreationSucceed
(
hitTestParameters
controller
)
{
if
(
this
.
hit_test_source_creation_callback_
)
{
return
this
.
hit_test_source_creation_callback_
(
hitTestParameters
controller
)
;
}
else
{
return
Promise
.
resolve
(
true
)
;
}
}
_calculateHitTestResults
(
frameData
)
{
if
(
!
this
.
supportedModes_
.
includes
(
vrMojom
.
XRSessionMode
.
kImmersiveAr
)
)
{
return
;
}
frameData
.
hitTestSubscriptionResults
=
{
results
:
[
]
transientInputResults
:
[
]
}
;
if
(
!
this
.
world_
)
{
return
;
}
for
(
const
[
id
subscription
]
of
this
.
hitTestSubscriptions_
)
{
const
mojo_from_native_origin
=
this
.
_getMojoFromNativeOrigin
(
subscription
.
nativeOriginInformation
)
;
if
(
!
mojo_from_native_origin
)
continue
;
const
[
mojo_ray_origin
mojo_ray_direction
]
=
this
.
_transformRayToMojoSpace
(
subscription
.
ray
mojo_from_native_origin
)
;
const
results
=
this
.
_hitTestWorld
(
mojo_ray_origin
mojo_ray_direction
subscription
.
entityTypes
)
;
frameData
.
hitTestSubscriptionResults
.
results
.
push
(
{
subscriptionId
:
id
hitTestResults
:
results
}
)
;
}
const
mojo_from_viewer
=
this
.
_getMojoFromViewer
(
)
;
for
(
const
[
id
subscription
]
of
this
.
transientHitTestSubscriptions_
)
{
const
result
=
{
subscriptionId
:
id
inputSourceIdToHitTestResults
:
new
Map
(
)
}
;
const
matching_input_sources
=
Array
.
from
(
this
.
input_sources_
.
values
(
)
)
.
filter
(
input_source
=
>
input_source
.
profiles_
.
includes
(
subscription
.
profileName
)
)
;
for
(
const
input_source
of
matching_input_sources
)
{
const
mojo_from_native_origin
=
input_source
.
_getMojoFromInputSource
(
mojo_from_viewer
)
;
const
[
mojo_ray_origin
mojo_ray_direction
]
=
this
.
_transformRayToMojoSpace
(
subscription
.
ray
mojo_from_native_origin
)
;
const
results
=
this
.
_hitTestWorld
(
mojo_ray_origin
mojo_ray_direction
subscription
.
entityTypes
)
;
result
.
inputSourceIdToHitTestResults
.
set
(
input_source
.
source_id_
results
)
;
}
frameData
.
hitTestSubscriptionResults
.
transientInputResults
.
push
(
result
)
;
}
}
_transformRayToMojoSpace
(
ray
mojo_from_native_origin
)
{
const
ray_origin
=
{
x
:
ray
.
origin
.
x
y
:
ray
.
origin
.
y
z
:
ray
.
origin
.
z
w
:
1
}
;
const
ray_direction
=
{
x
:
ray
.
direction
.
x
y
:
ray
.
direction
.
y
z
:
ray
.
direction
.
z
w
:
0
}
;
const
mojo_ray_origin
=
XRMathHelper
.
transform_by_matrix
(
mojo_from_native_origin
ray_origin
)
;
const
mojo_ray_direction
=
XRMathHelper
.
transform_by_matrix
(
mojo_from_native_origin
ray_direction
)
;
return
[
mojo_ray_origin
mojo_ray_direction
]
;
}
_hitTestWorld
(
origin
direction
entityTypes
)
{
let
result
=
[
]
;
for
(
const
region
of
this
.
world_
.
hitTestRegions
)
{
const
partial_result
=
this
.
_hitTestRegion
(
region
origin
direction
entityTypes
)
;
result
=
result
.
concat
(
partial_result
)
;
}
return
result
.
sort
(
(
lhs
rhs
)
=
>
lhs
.
distance
-
rhs
.
distance
)
.
map
(
(
hitTest
)
=
>
{
delete
hitTest
.
distance
;
return
hitTest
;
}
)
;
}
_hitTestRegion
(
region
origin
direction
entityTypes
)
{
const
regionNameToMojoEnum
=
{
"
point
"
:
vrMojom
.
EntityTypeForHitTest
.
POINT
"
plane
"
:
vrMojom
.
EntityTypeForHitTest
.
PLANE
"
mesh
"
:
null
}
;
if
(
!
entityTypes
.
includes
(
regionNameToMojoEnum
[
region
.
type
]
)
)
{
return
[
]
;
}
const
result
=
[
]
;
for
(
const
face
of
region
.
faces
)
{
const
maybe_hit
=
this
.
_hitTestFace
(
face
origin
direction
)
;
if
(
maybe_hit
)
{
result
.
push
(
maybe_hit
)
;
}
}
return
result
.
sort
(
(
lhs
rhs
)
=
>
lhs
.
distance
-
rhs
.
distance
)
.
filter
(
(
val
index
array
)
=
>
index
=
=
=
0
|
|
val
.
distance
!
=
=
array
[
index
-
1
]
.
distance
)
;
}
_hitTestFace
(
face
origin
direction
)
{
const
add
=
XRMathHelper
.
add
;
const
sub
=
XRMathHelper
.
sub
;
const
mul
=
XRMathHelper
.
mul
;
const
normalize
=
XRMathHelper
.
normalize
;
const
dot
=
XRMathHelper
.
dot
;
const
cross
=
XRMathHelper
.
cross
;
const
neg
=
XRMathHelper
.
neg
;
const
point_A
=
face
.
vertices
[
0
]
;
const
point_B
=
face
.
vertices
[
1
]
;
const
point_C
=
face
.
vertices
[
2
]
;
const
edge_AB
=
sub
(
point_B
point_A
)
;
const
edge_AC
=
sub
(
point_C
point_A
)
;
const
normal
=
normalize
(
cross
(
edge_AB
edge_AC
)
)
;
const
numerator
=
dot
(
sub
(
point_A
origin
)
normal
)
;
const
denominator
=
dot
(
direction
normal
)
;
if
(
Math
.
abs
(
denominator
)
<
XRMathHelper
.
EPSILON
)
{
return
null
;
}
else
{
const
distance
=
numerator
/
denominator
;
if
(
distance
<
0
)
{
return
null
;
}
else
{
const
intersection_point
=
add
(
origin
mul
(
distance
direction
)
)
;
const
y_axis
=
denominator
>
0
?
neg
(
normal
)
:
normal
;
let
z_axis
=
null
;
const
cos_direction_and_y_axis
=
dot
(
direction
y_axis
)
;
if
(
Math
.
abs
(
cos_direction_and_y_axis
)
>
(
1
-
XRMathHelper
.
EPSILON
)
)
{
const
up
=
{
x
:
0
.
0
y
:
1
.
0
z
:
0
.
0
w
:
0
.
0
}
;
const
right
=
{
x
:
1
.
0
y
:
0
.
0
z
:
0
.
0
w
:
0
.
0
}
;
z_axis
=
Math
.
abs
(
dot
(
up
y_axis
)
)
>
(
1
-
XRMathHelper
.
EPSILON
)
?
sub
(
up
mul
(
dot
(
right
y_axis
)
y_axis
)
)
:
sub
(
up
mul
(
dot
(
up
y_axis
)
y_axis
)
)
;
}
else
{
z_axis
=
neg
(
sub
(
direction
mul
(
cos_direction_and_y_axis
y_axis
)
)
)
;
}
z_axis
=
normalize
(
z_axis
)
;
const
x_axis
=
normalize
(
cross
(
y_axis
z_axis
)
)
;
if
(
!
XRMathHelper
.
pointInFace
(
intersection_point
face
)
)
{
return
null
;
}
const
hitResult
=
{
planeId
:
0n
}
;
hitResult
.
distance
=
distance
;
const
matrix
=
new
Array
(
16
)
;
matrix
[
0
]
=
x_axis
.
x
;
matrix
[
1
]
=
x_axis
.
y
;
matrix
[
2
]
=
x_axis
.
z
;
matrix
[
3
]
=
0
;
matrix
[
4
]
=
y_axis
.
x
;
matrix
[
5
]
=
y_axis
.
y
;
matrix
[
6
]
=
y_axis
.
z
;
matrix
[
7
]
=
0
;
matrix
[
8
]
=
z_axis
.
x
;
matrix
[
9
]
=
z_axis
.
y
;
matrix
[
10
]
=
z_axis
.
z
;
matrix
[
11
]
=
0
;
matrix
[
12
]
=
intersection_point
.
x
;
matrix
[
13
]
=
intersection_point
.
y
;
matrix
[
14
]
=
intersection_point
.
z
;
matrix
[
15
]
=
1
;
hitResult
.
mojoFromResult
=
getPoseFromTransform
(
XRMathHelper
.
decomposeRigidTransform
(
matrix
)
)
;
return
hitResult
;
}
}
}
_getMojoFromViewer
(
)
{
if
(
!
this
.
pose_
)
{
return
XRMathHelper
.
identity
(
)
;
}
const
transform
=
{
position
:
[
this
.
pose_
.
position
.
x
this
.
pose_
.
position
.
y
this
.
pose_
.
position
.
z
]
orientation
:
[
this
.
pose_
.
orientation
.
x
this
.
pose_
.
orientation
.
y
this
.
pose_
.
orientation
.
z
this
.
pose_
.
orientation
.
w
]
}
;
return
getMatrixFromTransform
(
transform
)
;
}
_getMojoFromViewerWithOffset
(
viewOffset
)
{
return
{
matrix
:
XRMathHelper
.
mul4x4
(
this
.
_getMojoFromViewer
(
)
viewOffset
.
matrix
)
}
;
}
_getMojoFromNativeOrigin
(
nativeOriginInformation
)
{
const
mojo_from_viewer
=
this
.
_getMojoFromViewer
(
)
;
if
(
nativeOriginInformation
.
inputSourceSpaceInfo
!
=
=
undefined
)
{
if
(
!
this
.
input_sources_
.
has
(
nativeOriginInformation
.
inputSourceSpaceInfo
.
inputSourceId
)
)
{
return
null
;
}
else
{
const
inputSource
=
this
.
input_sources_
.
get
(
nativeOriginInformation
.
inputSourceSpaceInfo
.
inputSourceId
)
;
return
inputSource
.
_getMojoFromInputSource
(
mojo_from_viewer
)
;
}
}
else
if
(
nativeOriginInformation
.
referenceSpaceType
!
=
=
undefined
)
{
switch
(
nativeOriginInformation
.
referenceSpaceType
)
{
case
vrMojom
.
XRReferenceSpaceType
.
kLocal
:
return
XRMathHelper
.
identity
(
)
;
case
vrMojom
.
XRReferenceSpaceType
.
kLocalFloor
:
if
(
this
.
stageParameters_
=
=
null
|
|
this
.
stageParameters_
.
mojoFromFloor
=
=
null
)
{
console
.
warn
(
"
Standing
transform
not
available
.
"
)
;
return
null
;
}
return
this
.
stageParameters_
.
mojoFromFloor
.
matrix
;
case
vrMojom
.
XRReferenceSpaceType
.
kViewer
:
return
mojo_from_viewer
;
case
vrMojom
.
XRReferenceSpaceType
.
kBoundedFloor
:
return
null
;
case
vrMojom
.
XRReferenceSpaceType
.
kUnbounded
:
return
null
;
default
:
throw
new
TypeError
(
"
Unrecognized
XRReferenceSpaceType
!
"
)
;
}
}
else
{
return
null
;
}
}
}
class
MockXRInputSource
{
constructor
(
fakeInputSourceInit
id
pairedDevice
)
{
this
.
source_id_
=
id
;
this
.
pairedDevice_
=
pairedDevice
;
this
.
handedness_
=
fakeInputSourceInit
.
handedness
;
this
.
target_ray_mode_
=
fakeInputSourceInit
.
targetRayMode
;
if
(
fakeInputSourceInit
.
pointerOrigin
=
=
null
)
{
throw
new
TypeError
(
"
FakeXRInputSourceInit
.
pointerOrigin
is
required
.
"
)
;
}
this
.
setPointerOrigin
(
fakeInputSourceInit
.
pointerOrigin
)
;
this
.
setProfiles
(
fakeInputSourceInit
.
profiles
)
;
this
.
primary_input_pressed_
=
false
;
if
(
fakeInputSourceInit
.
selectionStarted
!
=
null
)
{
this
.
primary_input_pressed_
=
fakeInputSourceInit
.
selectionStarted
;
}
this
.
primary_input_clicked_
=
false
;
if
(
fakeInputSourceInit
.
selectionClicked
!
=
null
)
{
this
.
primary_input_clicked_
=
fakeInputSourceInit
.
selectionClicked
;
}
this
.
primary_squeeze_pressed_
=
false
;
this
.
primary_squeeze_clicked_
=
false
;
this
.
mojo_from_input_
=
null
;
if
(
fakeInputSourceInit
.
gripOrigin
!
=
null
)
{
this
.
setGripOrigin
(
fakeInputSourceInit
.
gripOrigin
)
;
}
this
.
setSupportedButtons
(
fakeInputSourceInit
.
supportedButtons
)
;
this
.
emulated_position_
=
false
;
this
.
desc_dirty_
=
true
;
}
setHandedness
(
handedness
)
{
if
(
this
.
handedness_
!
=
handedness
)
{
this
.
desc_dirty_
=
true
;
this
.
handedness_
=
handedness
;
}
}
setTargetRayMode
(
targetRayMode
)
{
if
(
this
.
target_ray_mode_
!
=
targetRayMode
)
{
this
.
desc_dirty_
=
true
;
this
.
target_ray_mode_
=
targetRayMode
;
}
}
setProfiles
(
profiles
)
{
this
.
desc_dirty_
=
true
;
this
.
profiles_
=
profiles
;
}
setGripOrigin
(
transform
emulatedPosition
=
false
)
{
this
.
mojo_from_input_
=
composeGFXTransform
(
transform
)
;
this
.
emulated_position_
=
emulatedPosition
;
this
.
desc_dirty_
=
true
;
}
clearGripOrigin
(
)
{
if
(
this
.
mojo_from_input_
!
=
null
)
{
this
.
mojo_from_input_
=
null
;
this
.
emulated_position_
=
false
;
this
.
desc_dirty_
=
true
;
}
}
setPointerOrigin
(
transform
emulatedPosition
=
false
)
{
this
.
desc_dirty_
=
true
;
this
.
mojo_from_pointer_
=
composeGFXTransform
(
transform
)
;
this
.
emulated_position_
=
emulatedPosition
;
}
disconnect
(
)
{
this
.
pairedDevice_
.
removeInputSource
(
this
)
;
}
reconnect
(
)
{
this
.
pairedDevice_
.
addInputSource
(
this
)
;
}
startSelection
(
)
{
this
.
primary_input_pressed_
=
true
;
if
(
this
.
gamepad_
)
{
this
.
gamepad_
.
buttons
[
0
]
.
pressed
=
true
;
this
.
gamepad_
.
buttons
[
0
]
.
touched
=
true
;
}
}
endSelection
(
)
{
if
(
!
this
.
primary_input_pressed_
)
{
throw
new
Error
(
"
Attempted
to
end
selection
which
was
not
started
"
)
;
}
this
.
primary_input_pressed_
=
false
;
this
.
primary_input_clicked_
=
true
;
if
(
this
.
gamepad_
)
{
this
.
gamepad_
.
buttons
[
0
]
.
pressed
=
false
;
this
.
gamepad_
.
buttons
[
0
]
.
touched
=
false
;
}
}
simulateSelect
(
)
{
this
.
primary_input_clicked_
=
true
;
}
setSupportedButtons
(
supportedButtons
)
{
this
.
gamepad_
=
null
;
this
.
supported_buttons_
=
[
]
;
if
(
supportedButtons
=
=
null
|
|
supportedButtons
.
length
<
1
)
{
return
;
}
const
supported_button_map
=
{
}
;
this
.
gamepad_
=
this
.
getEmptyGamepad
(
)
;
for
(
let
i
=
0
;
i
<
supportedButtons
.
length
;
i
+
+
)
{
const
buttonType
=
supportedButtons
[
i
]
.
buttonType
;
this
.
supported_buttons_
.
push
(
buttonType
)
;
supported_button_map
[
buttonType
]
=
supportedButtons
[
i
]
;
}
this
.
gamepad_
.
buttons
.
push
(
{
pressed
:
this
.
primary_input_pressed_
touched
:
this
.
primary_input_pressed_
value
:
this
.
primary_input_pressed_
?
1
.
0
:
0
.
0
}
)
;
this
.
addGamepadButton
(
supported_button_map
[
'
grip
'
]
)
;
this
.
addGamepadButton
(
supported_button_map
[
'
touchpad
'
]
)
;
this
.
addGamepadButton
(
supported_button_map
[
'
thumbstick
'
]
)
;
this
.
addGamepadButton
(
supported_button_map
[
'
optional
-
button
'
]
)
;
this
.
addGamepadButton
(
supported_button_map
[
'
optional
-
thumbstick
'
]
)
;
for
(
let
i
=
0
;
i
<
this
.
gamepad_
.
buttons
.
length
;
i
+
+
)
{
if
(
this
.
gamepad_
.
buttons
[
i
]
=
=
null
)
{
this
.
gamepad_
.
buttons
[
i
]
=
{
pressed
:
false
touched
:
false
value
:
0
}
;
}
}
for
(
let
i
=
0
;
i
<
this
.
gamepad_
.
axes
.
length
;
i
+
+
)
{
if
(
this
.
gamepad_
.
axes
[
i
]
=
=
null
)
{
this
.
gamepad_
.
axes
[
i
]
=
0
;
}
}
}
updateButtonState
(
buttonState
)
{
if
(
this
.
supported_buttons_
.
indexOf
(
buttonState
.
buttonType
)
=
=
-
1
)
{
throw
new
Error
(
"
Tried
to
update
state
on
an
unsupported
button
"
)
;
}
const
buttonIndex
=
this
.
getButtonIndex
(
buttonState
.
buttonType
)
;
const
axesStartIndex
=
this
.
getAxesStartIndex
(
buttonState
.
buttonType
)
;
if
(
buttonIndex
=
=
-
1
)
{
throw
new
Error
(
"
Unknown
Button
Type
!
"
)
;
}
if
(
buttonIndex
=
=
=
this
.
getButtonIndex
(
'
grip
'
)
)
{
if
(
buttonState
.
pressed
)
{
this
.
primary_squeeze_pressed_
=
true
;
}
else
if
(
this
.
gamepad_
.
buttons
[
buttonIndex
]
.
pressed
)
{
this
.
primary_squeeze_clicked_
=
true
;
this
.
primary_squeeze_pressed_
=
false
;
}
else
{
this
.
primary_squeeze_clicked_
=
false
;
this
.
primary_squeeze_pressed_
=
false
;
}
}
this
.
gamepad_
.
buttons
[
buttonIndex
]
.
pressed
=
buttonState
.
pressed
;
this
.
gamepad_
.
buttons
[
buttonIndex
]
.
touched
=
buttonState
.
touched
;
this
.
gamepad_
.
buttons
[
buttonIndex
]
.
value
=
buttonState
.
pressedValue
;
if
(
axesStartIndex
!
=
-
1
)
{
this
.
gamepad_
.
axes
[
axesStartIndex
]
=
buttonState
.
xValue
=
=
null
?
0
.
0
:
buttonState
.
xValue
;
this
.
gamepad_
.
axes
[
axesStartIndex
+
1
]
=
buttonState
.
yValue
=
=
null
?
0
.
0
:
buttonState
.
yValue
;
}
}
getInputSourceState
(
)
{
const
input_state
=
{
}
;
input_state
.
sourceId
=
this
.
source_id_
;
input_state
.
isAuxiliary
=
false
;
input_state
.
primaryInputPressed
=
this
.
primary_input_pressed_
;
input_state
.
primaryInputClicked
=
this
.
primary_input_clicked_
;
input_state
.
primarySqueezePressed
=
this
.
primary_squeeze_pressed_
;
input_state
.
primarySqueezeClicked
=
this
.
primary_squeeze_clicked_
;
this
.
primary_input_clicked_
=
false
;
this
.
primary_squeeze_clicked_
=
false
;
input_state
.
mojoFromInput
=
this
.
mojo_from_input_
;
input_state
.
gamepad
=
this
.
gamepad_
;
input_state
.
emulatedPosition
=
this
.
emulated_position_
;
if
(
this
.
desc_dirty_
)
{
const
input_desc
=
{
}
;
switch
(
this
.
target_ray_mode_
)
{
case
'
gaze
'
:
input_desc
.
targetRayMode
=
vrMojom
.
XRTargetRayMode
.
GAZING
;
break
;
case
'
tracked
-
pointer
'
:
input_desc
.
targetRayMode
=
vrMojom
.
XRTargetRayMode
.
POINTING
;
break
;
case
'
screen
'
:
input_desc
.
targetRayMode
=
vrMojom
.
XRTargetRayMode
.
TAPPING
;
break
;
default
:
throw
new
Error
(
'
Unhandled
target
ray
mode
'
+
this
.
target_ray_mode_
)
;
}
switch
(
this
.
handedness_
)
{
case
'
left
'
:
input_desc
.
handedness
=
vrMojom
.
XRHandedness
.
LEFT
;
break
;
case
'
right
'
:
input_desc
.
handedness
=
vrMojom
.
XRHandedness
.
RIGHT
;
break
;
default
:
input_desc
.
handedness
=
vrMojom
.
XRHandedness
.
NONE
;
break
;
}
let
mojo_from_input
=
XRMathHelper
.
identity
(
)
;
switch
(
this
.
target_ray_mode_
)
{
case
'
gaze
'
:
case
'
screen
'
:
mojo_from_input
=
this
.
pairedDevice_
.
_getMojoFromViewer
(
)
;
break
;
case
'
tracked
-
pointer
'
:
if
(
this
.
mojo_from_input_
)
{
mojo_from_input
=
this
.
mojo_from_input_
.
matrix
;
}
break
;
default
:
throw
new
Error
(
'
Unhandled
target
ray
mode
'
+
this
.
target_ray_mode_
)
;
}
let
input_from_mojo
=
XRMathHelper
.
inverse
(
mojo_from_input
)
;
input_desc
.
inputFromPointer
=
{
}
;
input_desc
.
inputFromPointer
.
matrix
=
XRMathHelper
.
mul4x4
(
input_from_mojo
this
.
mojo_from_pointer_
.
matrix
)
;
input_desc
.
profiles
=
this
.
profiles_
;
input_state
.
description
=
input_desc
;
this
.
desc_dirty_
=
false
;
}
if
(
this
.
overlay_pointer_position_
)
{
input_state
.
overlayPointerPosition
=
this
.
overlay_pointer_position_
;
this
.
overlay_pointer_position_
=
null
;
}
return
input_state
;
}
setOverlayPointerPosition
(
x
y
)
{
this
.
overlay_pointer_position_
=
{
x
:
x
y
:
y
}
;
}
getEmptyGamepad
(
)
{
const
gamepad
=
{
connected
:
true
id
:
[
]
timestamp
:
0n
axes
:
[
]
buttons
:
[
]
mapping
:
GamepadMapping
.
GamepadMappingStandard
displayId
:
0
}
;
switch
(
this
.
handedness_
)
{
case
'
left
'
:
gamepad
.
hand
=
GamepadHand
.
GamepadHandLeft
;
break
;
case
'
right
'
:
gamepad
.
hand
=
GamepadHand
.
GamepadHandRight
;
break
;
default
:
gamepad
.
hand
=
GamepadHand
.
GamepadHandNone
;
break
;
}
return
gamepad
;
}
addGamepadButton
(
buttonState
)
{
if
(
buttonState
=
=
null
)
{
return
;
}
const
buttonIndex
=
this
.
getButtonIndex
(
buttonState
.
buttonType
)
;
const
axesStartIndex
=
this
.
getAxesStartIndex
(
buttonState
.
buttonType
)
;
if
(
buttonIndex
=
=
-
1
)
{
throw
new
Error
(
"
Unknown
Button
Type
!
"
)
;
}
this
.
gamepad_
.
buttons
[
buttonIndex
]
=
{
pressed
:
buttonState
.
pressed
touched
:
buttonState
.
touched
value
:
buttonState
.
pressedValue
}
;
if
(
axesStartIndex
!
=
-
1
)
{
this
.
gamepad_
.
axes
[
axesStartIndex
]
=
(
buttonState
.
xValue
=
=
null
?
0
.
0
:
buttonSate
.
xValue
)
;
this
.
gamepad_
.
axes
[
axesStartIndex
+
1
]
=
(
buttonState
.
yValue
=
=
null
?
0
.
0
:
buttonSate
.
yValue
)
;
}
}
getButtonIndex
(
buttonType
)
{
switch
(
buttonType
)
{
case
'
grip
'
:
return
1
;
case
'
touchpad
'
:
return
2
;
case
'
thumbstick
'
:
return
3
;
case
'
optional
-
button
'
:
return
4
;
case
'
optional
-
thumbstick
'
:
return
5
;
default
:
return
-
1
;
}
}
getAxesStartIndex
(
buttonType
)
{
switch
(
buttonType
)
{
case
'
touchpad
'
:
return
0
;
case
'
thumbstick
'
:
return
2
;
case
'
optional
-
thumbstick
'
:
return
4
;
default
:
return
-
1
;
}
}
_getMojoFromInputSource
(
mojo_from_viewer
)
{
return
this
.
mojo_from_pointer_
.
matrix
;
}
}
class
MockXRPresentationProvider
{
constructor
(
)
{
this
.
receiver_
=
null
;
this
.
submit_frame_count_
=
0
;
this
.
missing_frame_count_
=
0
;
}
bindProvider
(
)
{
const
provider
=
new
vrMojom
.
XRPresentationProviderRemote
(
)
;
if
(
this
.
receiver_
)
{
this
.
receiver_
.
.
close
(
)
;
}
this
.
receiver_
=
new
vrMojom
.
XRPresentationProviderReceiver
(
this
)
;
this
.
receiver_
.
.
bindHandle
(
provider
.
.
bindNewPipeAndPassReceiver
(
)
.
handle
)
;
return
provider
;
}
getClientReceiver
(
)
{
this
.
submitFrameClient_
=
new
vrMojom
.
XRPresentationClientRemote
(
)
;
return
this
.
submitFrameClient_
.
.
bindNewPipeAndPassReceiver
(
)
;
}
updateLayerBounds
(
frameId
leftBounds
rightBounds
sourceSize
)
{
}
submitFrameMissing
(
frameId
mailboxHolder
timeWaited
)
{
this
.
missing_frame_count_
+
+
;
}
submitFrame
(
frameId
mailboxHolder
timeWaited
)
{
this
.
submit_frame_count_
+
+
;
this
.
submitFrameClient_
.
onSubmitFrameTransferred
(
true
)
;
this
.
submitFrameClient_
.
onSubmitFrameRendered
(
)
;
}
submitFrameWithTextureHandle
(
frameId
texture
)
{
}
submitFrameDrawnIntoTexture
(
frameId
syncToken
timeWaited
)
{
}
Close
(
)
{
if
(
this
.
receiver_
)
{
this
.
receiver_
.
.
close
(
)
;
}
}
}
self
.
ChromeXRTest
=
ChromeXRTest
;
self
.
MockRuntime
=
MockRuntime
;
self
.
MockVRService
=
MockVRService
;
self
.
SubscribeToHitTestResult
=
vrMojom
.
SubscribeToHitTestResult
;
navigator
.
xr
.
test
=
new
ChromeXRTest
(
)
;
