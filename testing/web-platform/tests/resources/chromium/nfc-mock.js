'
use
strict
'
;
function
toMojoNDEFPushTarget
(
target
)
{
switch
(
target
)
{
case
'
peer
'
:
return
device
.
mojom
.
NDEFPushTarget
.
PEER
;
case
'
tag
'
:
return
device
.
mojom
.
NDEFPushTarget
.
TAG
;
}
return
device
.
mojom
.
NDEFPushTarget
.
ANY
;
}
function
toMojoNDEFMessage
(
message
)
{
let
ndefMessage
=
new
device
.
mojom
.
NDEFMessage
(
)
;
ndefMessage
.
url
=
message
.
url
;
ndefMessage
.
data
=
[
]
;
for
(
let
record
of
message
.
records
)
{
ndefMessage
.
data
.
push
(
toMojoNDEFRecord
(
record
)
)
;
}
return
ndefMessage
;
}
function
toMojoNDEFRecord
(
record
)
{
let
nfcRecord
=
new
device
.
mojom
.
NDEFRecord
(
)
;
nfcRecord
.
recordType
=
record
.
recordType
;
nfcRecord
.
mediaType
=
record
.
mediaType
;
nfcRecord
.
data
=
toByteArray
(
record
.
data
)
;
if
(
record
.
data
!
=
null
&
&
record
.
data
.
records
!
=
=
undefined
)
{
nfcRecord
.
payloadMessage
=
toMojoNDEFMessage
(
record
.
data
)
;
}
return
nfcRecord
;
}
function
toByteArray
(
data
)
{
if
(
data
instanceof
ArrayBuffer
)
return
new
Uint8Array
(
data
)
;
else
if
(
ArrayBuffer
.
isView
(
data
)
)
return
new
Uint8Array
(
data
.
buffer
data
.
byteOffset
data
.
byteLength
)
;
let
byteArray
=
new
Uint8Array
(
0
)
;
let
tmpData
=
data
;
if
(
typeof
tmpData
=
=
=
'
object
'
|
|
typeof
tmpData
=
=
=
'
number
'
)
tmpData
=
JSON
.
stringify
(
tmpData
)
;
if
(
typeof
tmpData
=
=
=
'
string
'
)
byteArray
=
new
TextEncoder
(
'
utf
-
8
'
)
.
encode
(
tmpData
)
;
return
byteArray
;
}
function
compareNDEFRecords
(
providedRecord
receivedRecord
)
{
assert_equals
(
providedRecord
.
recordType
receivedRecord
.
recordType
)
;
assert_equals
(
providedRecord
.
mediaType
receivedRecord
.
mediaType
.
substring
(
0
providedRecord
.
mediaType
.
length
)
)
;
assert_not_equals
(
providedRecord
.
recordType
'
empty
'
)
;
assert_array_equals
(
toByteArray
(
providedRecord
.
data
)
new
Uint8Array
(
receivedRecord
.
data
)
)
;
}
function
assertNDEFPushOptionsEqual
(
provided
received
)
{
if
(
provided
.
ignoreRead
!
=
=
undefined
)
assert_equals
(
provided
.
ignoreRead
!
!
received
.
ignoreRead
)
;
else
assert_equals
(
!
!
received
.
ignore_read
true
)
;
if
(
provided
.
timeout
!
=
=
undefined
)
assert_equals
(
provided
.
timeout
received
.
timeout
)
;
else
assert_equals
(
received
.
timeout
Infinity
)
;
if
(
provided
.
target
!
=
=
undefined
)
assert_equals
(
toMojoNDEFPushTarget
(
provided
.
target
)
received
.
target
)
;
else
assert_equals
(
received
.
target
device
.
mojom
.
NDEFPushTarget
.
ANY
)
;
}
function
assertNDEFReaderOptionsEqual
(
provided
received
)
{
if
(
provided
.
url
!
=
=
undefined
)
assert_equals
(
provided
.
url
received
.
url
)
;
else
assert_equals
(
received
.
url
'
'
)
;
if
(
provided
.
mediaType
!
=
=
undefined
)
assert_equals
(
provided
.
mediaType
received
.
mediaType
)
;
else
assert_equals
(
received
.
mediaType
'
'
)
;
if
(
provided
.
recordType
!
=
=
undefined
)
{
assert_equals
(
provided
.
recordType
received
.
recordType
)
;
}
}
function
matchesWatchOptions
(
message
options
)
{
if
(
!
matchesWebNfcId
(
message
.
url
options
.
url
)
)
return
false
;
if
(
(
options
.
mediaType
=
=
null
|
|
options
.
mediaType
=
=
=
'
'
)
&
&
options
.
recordType
=
=
null
)
{
return
true
;
}
for
(
let
record
of
message
.
records
)
{
if
(
options
.
mediaType
!
=
null
&
&
options
.
mediaType
!
=
=
"
"
&
&
options
.
mediaType
!
=
=
record
.
mediaType
)
{
return
false
;
}
if
(
options
.
recordType
!
=
null
&
&
options
.
recordType
!
=
=
record
.
recordType
)
{
return
false
;
}
}
return
true
;
}
function
matchesWebNfcId
(
id
pattern
)
{
if
(
id
!
=
null
&
&
id
!
=
=
"
"
&
&
pattern
!
=
null
&
&
pattern
!
=
=
"
"
)
{
const
id_url
=
new
URL
(
id
)
;
const
pattern_url
=
new
URL
(
pattern
)
;
if
(
id_url
.
protocol
!
=
=
pattern_url
.
protocol
)
return
false
;
if
(
!
id_url
.
host
.
endsWith
(
"
.
"
+
pattern_url
.
host
)
&
&
id_url
.
host
!
=
=
pattern_url
.
host
)
{
return
false
;
}
if
(
pattern_url
.
pathname
=
=
=
"
/
*
"
)
return
true
;
if
(
id_url
.
pathname
.
startsWith
(
pattern_url
.
pathname
)
)
return
true
;
return
false
;
}
return
true
;
}
function
createNDEFError
(
type
)
{
return
{
error
:
type
?
new
device
.
mojom
.
NDEFError
(
{
errorType
:
type
}
)
:
null
}
;
}
var
WebNFCTest
=
(
(
)
=
>
{
class
MockNFC
{
constructor
(
)
{
this
.
bindingSet_
=
new
mojo
.
BindingSet
(
device
.
mojom
.
NFC
)
;
this
.
interceptor_
=
new
MojoInterfaceInterceptor
(
device
.
mojom
.
NFC
.
name
"
context
"
true
)
;
this
.
interceptor_
.
oninterfacerequest
=
e
=
>
this
.
bindingSet_
.
addBinding
(
this
e
.
handle
)
;
this
.
interceptor_
.
start
(
)
;
this
.
hw_status_
=
NFCHWStatus
.
ENABLED
;
this
.
pushed_message_
=
null
;
this
.
push_options_
=
null
;
this
.
pending_promise_func_
=
null
;
this
.
push_completed_
=
true
;
this
.
push_should_timeout_
=
false
;
this
.
client_
=
null
;
this
.
watchers_
=
[
]
;
this
.
reading_messages_
=
[
]
;
this
.
operations_suspended_
=
false
;
this
.
is_ndef_tech_
=
true
;
this
.
is_formatted_tag_
=
false
;
}
async
push
(
message
options
)
{
let
error
=
this
.
getHWError
(
)
;
if
(
error
)
return
error
;
if
(
this
.
pending_promise_func_
)
{
this
.
cancelPendingPushOperation
(
)
;
}
this
.
pushed_message_
=
message
;
this
.
push_options_
=
options
;
return
new
Promise
(
resolve
=
>
{
this
.
pending_promise_func_
=
resolve
;
if
(
this
.
operations_suspended_
)
{
}
else
if
(
options
.
timeout
&
&
options
.
timeout
!
=
=
Infinity
&
&
!
this
.
push_completed_
)
{
if
(
this
.
push_should_timeout_
)
{
resolve
(
createNDEFError
(
device
.
mojom
.
NDEFErrorType
.
TIMER_EXPIRED
)
)
;
}
}
else
if
(
!
this
.
is_ndef_tech_
)
{
resolve
(
createNDEFError
(
device
.
mojom
.
NDEFErrorType
.
NOT_SUPPORTED
)
)
;
}
else
if
(
this
.
is_formatted_tag_
&
&
!
options
.
overwrite
)
{
resolve
(
createNDEFError
(
device
.
mojom
.
NDEFErrorType
.
NOT_ALLOWED
)
)
;
}
else
{
resolve
(
createNDEFError
(
null
)
)
;
}
}
)
;
}
async
cancelPush
(
target
)
{
if
(
this
.
push_options_
&
&
(
(
target
=
=
=
device
.
mojom
.
NDEFPushTarget
.
ANY
)
|
|
(
this
.
push_options_
.
target
=
=
=
target
)
)
)
{
this
.
cancelPendingPushOperation
(
)
;
}
return
createNDEFError
(
null
)
;
}
setClient
(
client
)
{
this
.
client_
=
client
;
}
async
watch
(
options
id
)
{
assert_true
(
id
>
0
)
;
let
error
=
this
.
getHWError
(
)
;
if
(
error
)
{
return
error
;
}
this
.
watchers_
.
push
(
{
id
:
id
options
:
options
}
)
;
if
(
!
this
.
operations_suspended_
&
&
this
.
is_ndef_tech_
)
{
for
(
let
message
of
this
.
reading_messages_
)
{
if
(
matchesWatchOptions
(
message
options
)
)
{
this
.
client_
.
onWatch
(
[
id
]
fake_tag_serial_number
toMojoNDEFMessage
(
message
)
)
;
}
}
}
return
createNDEFError
(
null
)
;
}
async
cancelWatch
(
id
)
{
let
index
=
this
.
watchers_
.
findIndex
(
value
=
>
value
.
id
=
=
=
id
)
;
if
(
index
=
=
=
-
1
)
{
return
createNDEFError
(
device
.
mojom
.
NDEFErrorType
.
NOT_FOUND
)
;
}
this
.
watchers_
.
splice
(
index
1
)
;
return
createNDEFError
(
null
)
;
}
async
cancelAllWatches
(
)
{
if
(
this
.
watchers_
.
length
=
=
=
0
)
{
return
createNDEFError
(
device
.
mojom
.
NDEFErrorType
.
NOT_FOUND
)
;
}
this
.
watchers_
.
splice
(
0
this
.
watchers_
.
length
)
;
return
createNDEFError
(
null
)
;
}
getHWError
(
)
{
if
(
this
.
hw_status_
=
=
=
NFCHWStatus
.
DISABLED
)
return
createNDEFError
(
device
.
mojom
.
NDEFErrorType
.
NOT_READABLE
)
;
if
(
this
.
hw_status_
=
=
=
NFCHWStatus
.
NOT_SUPPORTED
)
return
createNDEFError
(
device
.
mojom
.
NDEFErrorType
.
NOT_SUPPORTED
)
;
return
null
;
}
setHWStatus
(
status
)
{
this
.
hw_status_
=
status
;
}
pushedMessage
(
)
{
return
this
.
pushed_message_
;
}
pushOptions
(
)
{
return
this
.
push_options_
;
}
watchOptions
(
)
{
assert_not_equals
(
this
.
watchers_
.
length
0
)
;
return
this
.
watchers_
[
this
.
watchers_
.
length
-
1
]
.
options
;
}
setPendingPushCompleted
(
result
)
{
this
.
push_completed_
=
result
;
}
reset
(
)
{
this
.
hw_status_
=
NFCHWStatus
.
ENABLED
;
this
.
push_completed_
=
true
;
this
.
watchers_
=
[
]
;
this
.
reading_messages_
=
[
]
;
this
.
operations_suspended_
=
false
;
this
.
cancelPendingPushOperation
(
)
;
this
.
bindingSet_
.
closeAllBindings
(
)
;
this
.
interceptor_
.
stop
(
)
;
this
.
is_ndef_tech_
=
true
;
this
.
is_formatted_tag_
=
false
;
}
cancelPendingPushOperation
(
)
{
if
(
this
.
pending_promise_func_
)
{
this
.
pending_promise_func_
(
createNDEFError
(
device
.
mojom
.
NDEFErrorType
.
OPERATION_CANCELLED
)
)
;
}
this
.
pushed_message_
=
null
;
this
.
push_options_
=
null
;
this
.
pending_promise_func_
=
null
;
this
.
push_should_timeout_
=
false
;
this
.
push_completed_
=
true
;
}
setReadingMessage
(
message
)
{
this
.
reading_messages_
.
push
(
message
)
;
if
(
!
this
.
is_ndef_tech_
)
return
;
if
(
this
.
operations_suspended_
)
return
;
if
(
this
.
push_options_
&
&
this
.
push_options_
.
ignoreRead
)
return
;
for
(
let
watcher
of
this
.
watchers_
)
{
if
(
matchesWatchOptions
(
message
watcher
.
options
)
)
{
this
.
client_
.
onWatch
(
[
watcher
.
id
]
fake_tag_serial_number
toMojoNDEFMessage
(
message
)
)
;
}
}
}
setPushShouldTimeout
(
result
)
{
this
.
push_should_timeout_
=
result
;
}
suspendNFCOperations
(
)
{
this
.
operations_suspended_
=
true
;
}
resumeNFCOperations
(
)
{
this
.
operations_suspended_
=
false
;
for
(
let
watcher
of
this
.
watchers_
)
{
for
(
let
message
of
this
.
reading_messages_
)
{
if
(
matchesWatchOptions
(
message
watcher
.
options
)
&
&
this
.
is_ndef_tech_
)
{
this
.
client_
.
onWatch
(
[
watcher
.
id
]
fake_tag_serial_number
toMojoNDEFMessage
(
message
)
)
;
}
}
}
if
(
this
.
pending_promise_func_
)
{
this
.
pending_promise_func_
(
createNDEFError
(
null
)
)
;
}
}
setIsNDEFTech
(
isNdef
)
{
this
.
is_ndef_tech_
=
isNdef
;
}
setIsFormattedTag
(
isFormatted
)
{
this
.
is_formatted_tag_
=
isFormatted
;
}
}
let
testInternal
=
{
initialized
:
false
mockNFC
:
null
}
class
NFCTestChromium
{
constructor
(
)
{
Object
.
freeze
(
this
)
;
}
initialize
(
)
{
if
(
testInternal
.
initialized
)
throw
new
Error
(
'
Call
reset
(
)
before
initialize
(
)
.
'
)
;
testInternal
.
mockNFC
=
new
MockNFC
;
testInternal
.
initialized
=
true
;
}
async
reset
(
)
{
if
(
!
testInternal
.
initialized
)
throw
new
Error
(
'
Call
initialize
(
)
before
reset
(
)
.
'
)
;
testInternal
.
mockNFC
.
reset
(
)
;
testInternal
.
mockNFC
=
null
;
testInternal
.
initialized
=
false
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
getMockNFC
(
)
{
return
testInternal
.
mockNFC
;
}
}
return
NFCTestChromium
;
}
)
(
)
;
