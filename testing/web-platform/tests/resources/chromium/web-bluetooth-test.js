'
use
strict
'
;
function
toMojoCentralState
(
state
)
{
switch
(
state
)
{
case
'
absent
'
:
return
bluetooth
.
mojom
.
CentralState
.
ABSENT
;
case
'
powered
-
off
'
:
return
bluetooth
.
mojom
.
CentralState
.
POWERED_OFF
;
case
'
powered
-
on
'
:
return
bluetooth
.
mojom
.
CentralState
.
POWERED_ON
;
default
:
throw
Unsupported
value
{
state
}
for
state
.
;
}
}
function
writeTypeToString
(
writeType
)
{
switch
(
writeType
)
{
case
bluetooth
.
mojom
.
WriteType
.
kNone
:
return
'
none
'
;
case
bluetooth
.
mojom
.
WriteType
.
kWriteDefaultDeprecated
:
return
'
default
-
deprecated
'
;
case
bluetooth
.
mojom
.
WriteType
.
kWriteWithResponse
:
return
'
with
-
response
'
;
case
bluetooth
.
mojom
.
WriteType
.
kWriteWithoutResponse
:
return
'
without
-
response
'
;
default
:
throw
Unknown
bluetooth
.
mojom
.
WriteType
:
{
writeType
}
;
}
}
function
canonicalizeAndConvertToMojoUUID
(
uuids
)
{
let
canonicalUUIDs
=
uuids
.
map
(
val
=
>
(
{
uuid
:
BluetoothUUID
.
getService
(
val
)
}
)
)
;
return
canonicalUUIDs
;
}
function
convertToMojoMap
(
record
keyFn
isNumberKey
=
false
)
{
let
map
=
new
Map
(
)
;
for
(
const
[
key
value
]
of
Object
.
entries
(
record
)
)
{
let
buffer
=
ArrayBuffer
.
isView
(
value
)
?
value
.
buffer
:
value
;
if
(
isNumberKey
)
{
let
numberKey
=
parseInt
(
key
)
;
if
(
Number
.
isNaN
(
numberKey
)
)
throw
Map
key
{
key
}
is
not
a
number
;
map
.
set
(
keyFn
(
numberKey
)
Array
.
from
(
new
Uint8Array
(
buffer
)
)
)
;
continue
;
}
map
.
set
(
keyFn
(
key
)
Array
.
from
(
new
Uint8Array
(
buffer
)
)
)
;
}
return
map
;
}
const
CHARACTERISTIC_PROPERTIES_WEB_TO_MOJO
=
{
broadcast
:
'
broadcast
'
read
:
'
read
'
write_without_response
:
'
write_without_response
'
write
:
'
write
'
notify
:
'
notify
'
indicate
:
'
indicate
'
authenticatedSignedWrites
:
'
authenticated_signed_writes
'
extended_properties
:
'
extended_properties
'
}
;
const
MOJO_CHOOSER_EVENT_TYPE_MAP
=
(
(
)
=
>
{
const
ChooserEventType
=
content
.
mojom
.
ChooserEventType
;
return
{
[
ChooserEventType
.
CHOOSER_OPENED
]
:
'
chooser
-
opened
'
[
ChooserEventType
.
CHOOSER_CLOSED
]
:
'
chooser
-
closed
'
[
ChooserEventType
.
ADAPTER_REMOVED
]
:
'
adapter
-
removed
'
[
ChooserEventType
.
ADAPTER_DISABLED
]
:
'
adapter
-
disabled
'
[
ChooserEventType
.
ADAPTER_ENABLED
]
:
'
adapter
-
enabled
'
[
ChooserEventType
.
DISCOVERY_FAILED_TO_START
]
:
'
discovery
-
failed
-
to
-
start
'
[
ChooserEventType
.
DISCOVERING
]
:
'
discovering
'
[
ChooserEventType
.
DISCOVERY_IDLE
]
:
'
discovery
-
idle
'
[
ChooserEventType
.
ADD_OR_UPDATE_DEVICE
]
:
'
add
-
or
-
update
-
device
'
}
}
)
(
)
;
function
ArrayToMojoCharacteristicProperties
(
arr
)
{
let
struct
=
new
bluetooth
.
mojom
.
CharacteristicProperties
(
)
;
arr
.
forEach
(
val
=
>
{
let
mojo_property
=
CHARACTERISTIC_PROPERTIES_WEB_TO_MOJO
[
val
]
;
if
(
struct
.
hasOwnProperty
(
mojo_property
)
)
struct
[
mojo_property
]
=
true
;
else
throw
Invalid
member
'
{
val
}
'
for
CharacteristicProperties
;
}
)
;
return
struct
;
}
class
FakeBluetooth
{
constructor
(
)
{
this
.
fake_bluetooth_ptr_
=
new
bluetooth
.
mojom
.
FakeBluetoothPtr
(
)
;
Mojo
.
bindInterface
(
bluetooth
.
mojom
.
FakeBluetooth
.
name
mojo
.
makeRequest
(
this
.
fake_bluetooth_ptr_
)
.
handle
'
process
'
)
;
this
.
fake_central_
=
null
;
}
async
setLESupported
(
supported
)
{
if
(
typeof
supported
!
=
=
'
boolean
'
)
throw
'
Type
Not
Supported
'
;
await
this
.
fake_bluetooth_ptr_
.
setLESupported
(
supported
)
;
}
async
simulateCentral
(
{
state
}
)
{
if
(
this
.
fake_central_
)
throw
'
simulateCentral
(
)
should
only
be
called
once
'
;
await
this
.
setLESupported
(
true
)
;
let
{
fakeCentral
:
fake_central_ptr
}
=
await
this
.
fake_bluetooth_ptr_
.
simulateCentral
(
toMojoCentralState
(
state
)
)
;
this
.
fake_central_
=
new
FakeCentral
(
fake_central_ptr
)
;
return
this
.
fake_central_
;
}
async
allResponsesConsumed
(
)
{
let
{
consumed
}
=
await
this
.
fake_bluetooth_ptr_
.
allResponsesConsumed
(
)
;
return
consumed
;
}
async
getManualChooser
(
)
{
if
(
typeof
this
.
fake_chooser_
=
=
=
'
undefined
'
)
{
this
.
fake_chooser_
=
new
FakeChooser
(
)
;
}
return
this
.
fake_chooser_
;
}
}
class
FakeCentral
{
constructor
(
fake_central_ptr
)
{
this
.
fake_central_ptr_
=
fake_central_ptr
;
this
.
peripherals_
=
new
Map
(
)
;
}
async
simulatePreconnectedPeripheral
(
{
address
name
knownServiceUUIDs
=
[
]
}
)
{
await
this
.
fake_central_ptr_
.
simulatePreconnectedPeripheral
(
address
name
canonicalizeAndConvertToMojoUUID
(
knownServiceUUIDs
)
)
;
return
this
.
fetchOrCreatePeripheral_
(
address
)
;
}
async
simulateAdvertisementReceived
(
scanResult
)
{
let
clonedScanResult
=
JSON
.
parse
(
JSON
.
stringify
(
scanResult
)
)
;
if
(
'
uuids
'
in
scanResult
.
scanRecord
)
{
clonedScanResult
.
scanRecord
.
uuids
=
canonicalizeAndConvertToMojoUUID
(
scanResult
.
scanRecord
.
uuids
)
;
}
const
has_appearance
=
'
appearance
'
in
scanResult
.
scanRecord
;
clonedScanResult
.
scanRecord
.
appearance
=
{
hasValue
:
has_appearance
value
:
(
has_appearance
?
scanResult
.
scanRecord
.
appearance
:
0
)
}
const
has_tx_power
=
'
txPower
'
in
scanResult
.
scanRecord
;
clonedScanResult
.
scanRecord
.
txPower
=
{
hasValue
:
has_tx_power
value
:
(
has_tx_power
?
scanResult
.
scanRecord
.
txPower
:
0
)
}
if
(
'
manufacturerData
'
in
scanResult
.
scanRecord
)
{
clonedScanResult
.
scanRecord
.
manufacturerData
=
convertToMojoMap
(
scanResult
.
scanRecord
.
manufacturerData
Number
true
)
;
}
if
(
'
serviceData
'
in
scanResult
.
scanRecord
)
{
clonedScanResult
.
scanRecord
.
serviceData
.
serviceData
=
convertToMojoMap
(
scanResult
.
scanRecord
.
serviceData
BluetoothUUID
.
getService
false
)
;
}
await
this
.
fake_central_ptr_
.
simulateAdvertisementReceived
(
new
bluetooth
.
mojom
.
ScanResult
(
clonedScanResult
)
)
;
return
this
.
fetchOrCreatePeripheral_
(
clonedScanResult
.
deviceAddress
)
;
}
async
setState
(
state
)
{
await
this
.
fake_central_ptr_
.
setState
(
toMojoCentralState
(
state
)
)
;
}
fetchOrCreatePeripheral_
(
address
)
{
let
peripheral
=
this
.
peripherals_
.
get
(
address
)
;
if
(
peripheral
=
=
=
undefined
)
{
peripheral
=
new
FakePeripheral
(
address
this
.
fake_central_ptr_
)
;
this
.
peripherals_
.
set
(
address
peripheral
)
;
}
return
peripheral
;
}
}
class
FakePeripheral
{
constructor
(
address
fake_central_ptr
)
{
this
.
address
=
address
;
this
.
fake_central_ptr_
=
fake_central_ptr
;
}
async
addFakeService
(
{
uuid
}
)
{
let
{
serviceId
:
service_id
}
=
await
this
.
fake_central_ptr_
.
addFakeService
(
this
.
address
{
uuid
:
BluetoothUUID
.
getService
(
uuid
)
}
)
;
if
(
service_id
=
=
=
null
)
throw
'
addFakeService
failed
'
;
return
new
FakeRemoteGATTService
(
service_id
this
.
address
this
.
fake_central_ptr_
)
;
}
async
setNextGATTConnectionResponse
(
{
code
}
)
{
let
{
success
}
=
await
this
.
fake_central_ptr_
.
setNextGATTConnectionResponse
(
this
.
address
code
)
;
if
(
success
!
=
=
true
)
throw
'
setNextGATTConnectionResponse
failed
.
'
;
}
async
setNextGATTDiscoveryResponse
(
{
code
}
)
{
let
{
success
}
=
await
this
.
fake_central_ptr_
.
setNextGATTDiscoveryResponse
(
this
.
address
code
)
;
if
(
success
!
=
=
true
)
throw
'
setNextGATTDiscoveryResponse
failed
.
'
;
}
async
simulateGATTDisconnection
(
)
{
let
{
success
}
=
await
this
.
fake_central_ptr_
.
simulateGATTDisconnection
(
this
.
address
)
;
if
(
success
!
=
=
true
)
throw
'
simulateGATTDisconnection
failed
.
'
;
}
async
simulateGATTServicesChanged
(
)
{
let
{
success
}
=
await
this
.
fake_central_ptr_
.
simulateGATTServicesChanged
(
this
.
address
)
;
if
(
success
!
=
=
true
)
throw
'
simulateGATTServicesChanged
failed
.
'
;
}
}
class
FakeRemoteGATTService
{
constructor
(
service_id
peripheral_address
fake_central_ptr
)
{
this
.
service_id_
=
service_id
;
this
.
peripheral_address_
=
peripheral_address
;
this
.
fake_central_ptr_
=
fake_central_ptr
;
}
async
addFakeCharacteristic
(
{
uuid
properties
}
)
{
let
{
characteristicId
:
characteristic_id
}
=
await
this
.
fake_central_ptr_
.
addFakeCharacteristic
(
{
uuid
:
BluetoothUUID
.
getCharacteristic
(
uuid
)
}
ArrayToMojoCharacteristicProperties
(
properties
)
this
.
service_id_
this
.
peripheral_address_
)
;
if
(
characteristic_id
=
=
=
null
)
throw
'
addFakeCharacteristic
failed
'
;
return
new
FakeRemoteGATTCharacteristic
(
characteristic_id
this
.
service_id_
this
.
peripheral_address_
this
.
fake_central_ptr_
)
;
}
async
remove
(
)
{
let
{
success
}
=
await
this
.
fake_central_ptr_
.
removeFakeService
(
this
.
service_id_
this
.
peripheral_address_
)
;
if
(
!
success
)
throw
'
remove
failed
'
;
}
}
class
FakeRemoteGATTCharacteristic
{
constructor
(
characteristic_id
service_id
peripheral_address
fake_central_ptr
)
{
this
.
ids_
=
[
characteristic_id
service_id
peripheral_address
]
;
this
.
descriptors_
=
[
]
;
this
.
fake_central_ptr_
=
fake_central_ptr
;
}
async
addFakeDescriptor
(
{
uuid
}
)
{
let
{
descriptorId
:
descriptor_id
}
=
await
this
.
fake_central_ptr_
.
addFakeDescriptor
(
{
uuid
:
BluetoothUUID
.
getDescriptor
(
uuid
)
}
.
.
.
this
.
ids_
)
;
if
(
descriptor_id
=
=
=
null
)
throw
'
addFakeDescriptor
failed
'
;
let
fake_descriptor
=
new
FakeRemoteGATTDescriptor
(
descriptor_id
.
.
.
this
.
ids_
this
.
fake_central_ptr_
)
;
this
.
descriptors_
.
push
(
fake_descriptor
)
;
return
fake_descriptor
;
}
async
setNextReadResponse
(
gatt_code
value
=
null
)
{
if
(
gatt_code
=
=
=
0
&
&
value
=
=
=
null
)
{
throw
'
|
value
|
can
\
'
t
be
null
if
read
should
success
.
'
;
}
if
(
gatt_code
!
=
=
0
&
&
value
!
=
=
null
)
{
throw
'
|
value
|
must
be
null
if
read
should
fail
.
'
;
}
let
{
success
}
=
await
this
.
fake_central_ptr_
.
setNextReadCharacteristicResponse
(
gatt_code
value
.
.
.
this
.
ids_
)
;
if
(
!
success
)
throw
'
setNextReadCharacteristicResponse
failed
'
;
}
async
setNextWriteResponse
(
gatt_code
)
{
let
{
success
}
=
await
this
.
fake_central_ptr_
.
setNextWriteCharacteristicResponse
(
gatt_code
.
.
.
this
.
ids_
)
;
if
(
!
success
)
throw
'
setNextWriteCharacteristicResponse
failed
'
;
}
async
setNextSubscribeToNotificationsResponse
(
gatt_code
)
{
let
{
success
}
=
await
this
.
fake_central_ptr_
.
setNextSubscribeToNotificationsResponse
(
gatt_code
.
.
.
this
.
ids_
)
;
if
(
!
success
)
throw
'
setNextSubscribeToNotificationsResponse
failed
'
;
}
async
setNextUnsubscribeFromNotificationsResponse
(
gatt_code
)
{
let
{
success
}
=
await
this
.
fake_central_ptr_
.
setNextUnsubscribeFromNotificationsResponse
(
gatt_code
.
.
.
this
.
ids_
)
;
if
(
!
success
)
throw
'
setNextUnsubscribeToNotificationsResponse
failed
'
;
}
async
isNotifying
(
)
{
let
{
success
isNotifying
}
=
await
this
.
fake_central_ptr_
.
isNotifying
(
.
.
.
this
.
ids_
)
;
if
(
!
success
)
throw
'
isNotifying
failed
'
;
return
isNotifying
;
}
async
getLastWrittenValue
(
)
{
let
{
success
value
writeType
}
=
await
this
.
fake_central_ptr_
.
getLastWrittenCharacteristicValue
(
.
.
.
this
.
ids_
)
;
if
(
!
success
)
throw
'
getLastWrittenCharacteristicValue
failed
'
;
return
{
lastValue
:
value
lastWriteType
:
writeTypeToString
(
writeType
)
}
;
}
async
remove
(
)
{
let
{
success
}
=
await
this
.
fake_central_ptr_
.
removeFakeCharacteristic
(
.
.
.
this
.
ids_
)
;
if
(
!
success
)
throw
'
remove
failed
'
;
}
}
class
FakeRemoteGATTDescriptor
{
constructor
(
descriptor_id
characteristic_id
service_id
peripheral_address
fake_central_ptr
)
{
this
.
ids_
=
[
descriptor_id
characteristic_id
service_id
peripheral_address
]
;
this
.
fake_central_ptr_
=
fake_central_ptr
;
}
async
setNextReadResponse
(
gatt_code
value
=
null
)
{
if
(
gatt_code
=
=
=
0
&
&
value
=
=
=
null
)
{
throw
'
|
value
|
cannot
be
null
if
read
should
succeed
.
'
;
}
if
(
gatt_code
!
=
=
0
&
&
value
!
=
=
null
)
{
throw
'
|
value
|
must
be
null
if
read
should
fail
.
'
;
}
let
{
success
}
=
await
this
.
fake_central_ptr_
.
setNextReadDescriptorResponse
(
gatt_code
value
.
.
.
this
.
ids_
)
;
if
(
!
success
)
throw
'
setNextReadDescriptorResponse
failed
'
;
}
async
setNextWriteResponse
(
gatt_code
)
{
let
{
success
}
=
await
this
.
fake_central_ptr_
.
setNextWriteDescriptorResponse
(
gatt_code
.
.
.
this
.
ids_
)
;
if
(
!
success
)
throw
'
setNextWriteDescriptorResponse
failed
'
;
}
async
getLastWrittenValue
(
)
{
let
{
success
value
}
=
await
this
.
fake_central_ptr_
.
getLastWrittenDescriptorValue
(
.
.
.
this
.
ids_
)
;
if
(
!
success
)
throw
'
getLastWrittenDescriptorValue
failed
'
;
return
value
;
}
async
remove
(
)
{
let
{
success
}
=
await
this
.
fake_central_ptr_
.
removeFakeDescriptor
(
.
.
.
this
.
ids_
)
;
if
(
!
success
)
throw
'
remove
failed
'
;
}
}
class
FakeChooser
{
constructor
(
)
{
let
fakeBluetoothChooserFactoryPtr
=
new
content
.
mojom
.
FakeBluetoothChooserFactoryPtr
(
)
;
Mojo
.
bindInterface
(
content
.
mojom
.
FakeBluetoothChooserFactory
.
name
mojo
.
makeRequest
(
fakeBluetoothChooserFactoryPtr
)
.
handle
'
process
'
)
;
this
.
fake_bluetooth_chooser_ptr_
=
new
content
.
mojom
.
FakeBluetoothChooserPtr
(
)
;
let
clientPtrInfo
=
new
mojo
.
AssociatedInterfacePtrInfo
(
)
;
this
.
fake_bluetooth_chooser_client_binding_
=
new
mojo
.
AssociatedBinding
(
content
.
mojom
.
FakeBluetoothChooserClient
this
mojo
.
makeRequest
(
clientPtrInfo
)
)
;
fakeBluetoothChooserFactoryPtr
.
createFakeBluetoothChooser
(
mojo
.
makeRequest
(
this
.
fake_bluetooth_chooser_ptr_
)
clientPtrInfo
)
;
this
.
events_
=
new
Array
(
)
;
this
.
event_listener_
=
null
;
}
async
waitForEvents
(
numOfEvents
)
{
return
new
Promise
(
resolve
=
>
{
if
(
this
.
events_
.
length
>
numOfEvents
)
{
throw
Asked
for
{
numOfEvents
}
event
(
s
)
but
received
+
{
this
.
events_
.
length
}
.
;
}
this
.
event_listener_
=
(
)
=
>
{
if
(
this
.
events_
.
length
=
=
=
numOfEvents
)
{
let
result
=
Array
.
from
(
this
.
events_
)
;
this
.
event_listener_
=
null
;
this
.
events_
=
[
]
;
resolve
(
result
)
;
}
}
;
this
.
event_listener_
(
)
;
}
)
;
}
async
selectPeripheral
(
peripheral
)
{
if
(
!
(
peripheral
instanceof
FakePeripheral
)
)
{
throw
'
|
peripheral
|
must
be
an
instance
of
FakePeripheral
'
;
}
await
this
.
fake_bluetooth_chooser_ptr_
.
selectPeripheral
(
peripheral
.
address
)
;
}
async
cancel
(
)
{
await
this
.
fake_bluetooth_chooser_ptr_
.
cancel
(
)
;
}
async
rescan
(
)
{
await
this
.
fake_bluetooth_chooser_ptr_
.
rescan
(
)
;
}
onEvent
(
chooserEvent
)
{
chooserEvent
.
type
=
MOJO_CHOOSER_EVENT_TYPE_MAP
[
chooserEvent
.
type
]
;
this
.
events_
.
push
(
chooserEvent
)
;
if
(
this
.
event_listener_
!
=
=
null
)
{
this
.
event_listener_
(
)
;
}
}
}
try
{
navigator
.
bluetooth
.
test
=
new
FakeBluetooth
(
)
;
}
catch
{
throw
'
Web
Bluetooth
Test
API
is
not
implemented
on
this
'
+
'
environment
.
See
the
bluetooth
README
at
'
+
'
https
:
/
/
github
.
com
/
web
-
platform
-
tests
/
wpt
/
blob
/
master
/
bluetooth
/
README
.
md
#
web
-
bluetooth
-
testing
'
;
}
