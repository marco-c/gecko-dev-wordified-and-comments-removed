globalThis
.
shadowRealmEvalAsync
=
function
(
realm
asyncBody
)
{
return
new
Promise
(
realm
.
evaluate
(
(
resolve
reject
)
=
>
{
(
async
(
)
=
>
{
{
asyncBody
}
}
)
(
)
.
then
(
resolve
(
e
)
=
>
reject
(
e
.
toString
(
)
+
"
\
\
n
"
+
(
e
.
stack
|
|
"
"
)
)
)
;
}
)
)
;
}
;
globalThis
.
fetchAdaptor
=
(
resource
)
=
>
(
resolve
reject
)
=
>
{
fetch
(
resource
)
.
then
(
res
=
>
res
.
text
(
)
)
.
then
(
resolve
(
e
)
=
>
reject
(
e
.
toString
(
)
)
)
;
}
;
let
sharedWorkerMessagePortPromise
;
globalThis
.
getPostMessageFunc
=
async
function
(
)
{
if
(
typeof
postMessage
=
=
=
"
function
"
)
{
return
postMessage
;
}
if
(
typeof
clients
=
=
=
"
object
"
)
{
const
allClients
=
await
clients
.
matchAll
(
{
includeUncontrolled
:
true
}
)
;
return
function
broadcast
(
msg
)
{
allClients
.
map
(
client
=
>
client
.
postMessage
(
msg
)
)
;
}
}
if
(
sharedWorkerMessagePortPromise
)
{
return
await
sharedWorkerMessagePortPromise
;
}
throw
new
Error
(
"
getPostMessageFunc
is
intended
for
Worker
scopes
"
)
;
}
let
savedResolver
;
if
(
globalThis
.
constructor
.
name
=
=
=
"
SharedWorkerGlobalScope
"
)
{
sharedWorkerMessagePortPromise
=
new
Promise
(
(
resolve
)
=
>
{
savedResolver
=
resolve
;
}
)
;
addEventListener
(
"
connect
"
function
(
event
)
{
const
port
=
event
.
ports
[
0
]
;
savedResolver
(
port
.
postMessage
.
bind
(
port
)
)
;
}
)
;
}
globalThis
.
setupFakeDynamicImportInShadowRealm
=
function
(
realm
adaptor
)
{
function
fetchModuleTextExecutor
(
url
)
{
return
(
resolve
reject
)
=
>
{
new
Promise
(
adaptor
(
url
)
)
.
then
(
text
=
>
realm
.
evaluate
(
text
+
"
;
\
nundefined
"
)
)
.
then
(
resolve
(
e
)
=
>
reject
(
e
.
toString
(
)
)
)
;
}
}
realm
.
evaluate
(
(
fetchModuleTextExecutor
)
=
>
{
globalThis
.
fakeDynamicImport
=
function
(
url
)
{
return
new
Promise
(
fetchModuleTextExecutor
(
url
)
)
;
}
}
)
(
fetchModuleTextExecutor
)
;
}
;
globalThis
.
setupFakeFetchOverMessagePort
=
function
(
port
)
{
port
.
addEventListener
(
"
message
"
(
event
)
=
>
{
if
(
typeof
event
.
data
!
=
=
"
string
"
|
|
!
event
.
data
.
startsWith
(
"
fetchRequest
:
:
"
)
)
{
return
;
}
fetch
(
event
.
data
.
slice
(
"
fetchRequest
:
:
"
.
length
)
)
.
then
(
res
=
>
res
.
text
(
)
)
.
then
(
text
=
>
port
.
postMessage
(
fetchResult
:
:
success
:
:
{
text
}
)
error
=
>
port
.
postMessage
(
fetchResult
:
:
fail
:
:
{
error
}
)
)
;
}
)
;
port
.
start
(
)
;
}
globalThis
.
createSetupErrorResult
=
function
(
message
)
{
return
{
type
:
"
complete
"
tests
:
[
]
asserts
:
[
]
status
:
{
status
:
1
message
}
}
;
}
;
