(
function
(
)
{
"
use
strict
"
;
var
idCounter
=
0
;
function
getInViewCenterPoint
(
rect
)
{
var
left
=
Math
.
max
(
0
rect
.
left
)
;
var
right
=
Math
.
min
(
window
.
innerWidth
rect
.
right
)
;
var
top
=
Math
.
max
(
0
rect
.
top
)
;
var
bottom
=
Math
.
min
(
window
.
innerHeight
rect
.
bottom
)
;
var
x
=
0
.
5
*
(
left
+
right
)
;
var
y
=
0
.
5
*
(
top
+
bottom
)
;
return
[
x
y
]
;
}
function
getPointerInteractablePaintTree
(
element
)
{
if
(
!
window
.
document
.
contains
(
element
)
)
{
return
[
]
;
}
var
rectangles
=
element
.
getClientRects
(
)
;
if
(
rectangles
.
length
=
=
=
0
)
{
return
[
]
;
}
var
centerPoint
=
getInViewCenterPoint
(
rectangles
[
0
]
)
;
if
(
"
elementsFromPoint
"
in
document
)
{
return
document
.
elementsFromPoint
(
centerPoint
[
0
]
centerPoint
[
1
]
)
;
}
else
if
(
"
msElementsFromPoint
"
in
document
)
{
var
rv
=
document
.
msElementsFromPoint
(
centerPoint
[
0
]
centerPoint
[
1
]
)
;
return
Array
.
prototype
.
slice
.
call
(
rv
?
rv
:
[
]
)
;
}
else
{
throw
new
Error
(
"
document
.
elementsFromPoint
unsupported
"
)
;
}
}
function
inView
(
element
)
{
var
pointerInteractablePaintTree
=
getPointerInteractablePaintTree
(
element
)
;
return
pointerInteractablePaintTree
.
indexOf
(
element
)
!
=
=
-
1
;
}
window
.
test_driver
=
{
bless
:
function
(
intent
action
)
{
var
button
=
document
.
createElement
(
"
button
"
)
;
button
.
innerHTML
=
"
This
test
requires
user
interaction
.
<
br
/
>
"
+
"
Please
click
here
to
allow
"
+
intent
+
"
.
"
;
button
.
id
=
"
wpt
-
test
-
driver
-
bless
-
"
+
(
idCounter
+
=
1
)
;
const
elem
=
document
.
body
|
|
document
.
documentElement
;
elem
.
appendChild
(
button
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
button
.
addEventListener
(
"
click
"
resolve
)
;
test_driver
.
click
(
button
)
.
catch
(
reject
)
;
}
)
.
then
(
function
(
)
{
button
.
remove
(
)
;
if
(
typeof
action
=
=
=
"
function
"
)
{
return
action
(
)
;
}
}
)
;
}
click
:
function
(
element
)
{
if
(
window
.
top
!
=
=
window
)
{
return
Promise
.
reject
(
new
Error
(
"
can
only
click
in
top
-
level
window
"
)
)
;
}
if
(
!
window
.
document
.
contains
(
element
)
)
{
return
Promise
.
reject
(
new
Error
(
"
element
in
different
document
or
shadow
tree
"
)
)
;
}
if
(
!
inView
(
element
)
)
{
element
.
scrollIntoView
(
{
behavior
:
"
instant
"
block
:
"
end
"
inline
:
"
nearest
"
}
)
;
}
var
pointerInteractablePaintTree
=
getPointerInteractablePaintTree
(
element
)
;
if
(
pointerInteractablePaintTree
.
length
=
=
=
0
|
|
!
element
.
contains
(
pointerInteractablePaintTree
[
0
]
)
)
{
return
Promise
.
reject
(
new
Error
(
"
element
click
intercepted
error
"
)
)
;
}
var
rect
=
element
.
getClientRects
(
)
[
0
]
;
var
centerPoint
=
getInViewCenterPoint
(
rect
)
;
return
window
.
test_driver_internal
.
click
(
element
{
x
:
centerPoint
[
0
]
y
:
centerPoint
[
1
]
}
)
;
}
send_keys
:
function
(
element
keys
)
{
if
(
window
.
top
!
=
=
window
)
{
return
Promise
.
reject
(
new
Error
(
"
can
only
send
keys
in
top
-
level
window
"
)
)
;
}
if
(
!
window
.
document
.
contains
(
element
)
)
{
return
Promise
.
reject
(
new
Error
(
"
element
in
different
document
or
shadow
tree
"
)
)
;
}
if
(
!
inView
(
element
)
)
{
element
.
scrollIntoView
(
{
behavior
:
"
instant
"
block
:
"
end
"
inline
:
"
nearest
"
}
)
;
}
var
pointerInteractablePaintTree
=
getPointerInteractablePaintTree
(
element
)
;
if
(
pointerInteractablePaintTree
.
length
=
=
=
0
|
|
!
element
.
contains
(
pointerInteractablePaintTree
[
0
]
)
)
{
return
Promise
.
reject
(
new
Error
(
"
element
send_keys
intercepted
error
"
)
)
;
}
return
window
.
test_driver_internal
.
send_keys
(
element
keys
)
;
}
freeze
:
function
(
)
{
return
window
.
test_driver_internal
.
freeze
(
)
;
}
action_sequence
:
function
(
actions
)
{
return
window
.
test_driver_internal
.
action_sequence
(
actions
)
;
}
}
;
var
manual
=
{
in_automation
:
false
click
:
function
(
element
coords
)
{
if
(
this
.
in_automation
)
{
return
Promise
.
reject
(
new
Error
(
'
Not
implemented
'
)
)
;
}
return
new
Promise
(
function
(
resolve
reject
)
{
element
.
addEventListener
(
"
click
"
resolve
)
;
}
)
;
}
send_keys
:
function
(
element
keys
)
{
if
(
this
.
in_automation
)
{
return
Promise
.
reject
(
new
Error
(
'
Not
implemented
'
)
)
;
}
return
new
Promise
(
function
(
resolve
reject
)
{
var
seen
=
"
"
;
function
remove
(
)
{
element
.
removeEventListener
(
"
keydown
"
onKeyDown
)
;
}
function
onKeyDown
(
event
)
{
if
(
event
.
key
.
length
>
1
)
{
return
;
}
seen
+
=
event
.
key
;
if
(
keys
.
indexOf
(
seen
)
!
=
=
0
)
{
reject
(
new
Error
(
"
Unexpected
key
sequence
:
"
+
seen
)
)
;
remove
(
)
;
}
else
if
(
seen
=
=
=
keys
)
{
resolve
(
)
;
remove
(
)
;
}
}
element
.
addEventListener
(
"
keydown
"
onKeyDown
)
;
}
)
;
}
freeze
:
function
(
)
{
return
Promise
.
reject
(
new
Error
(
"
unimplemented
"
)
)
;
}
action_sequence
:
function
(
actions
)
{
return
Promise
.
reject
(
new
Error
(
"
unimplemented
"
)
)
;
}
}
;
window
.
test_driver_internal
=
Object
.
create
(
manual
)
;
}
)
(
)
;
