'
use
strict
'
;
async_test
(
t
=
>
{
window
.
addEventListener
(
"
message
"
t
.
step_func
(
e
=
>
{
if
(
e
.
data
.
type
!
=
"
result
"
)
{
return
;
}
assert_equals
(
e
.
data
.
message
"
HasAccess
for
SharedWorker
"
"
Storage
Access
API
should
be
accessible
and
return
first
-
party
data
"
)
;
}
)
)
;
const
id
=
Date
.
now
(
)
;
const
relay_worker
=
new
SharedWorker
(
"
/
storage
-
access
-
api
/
resources
/
shared
-
worker
-
relay
.
js
"
{
name
:
id
sameSiteCookies
:
'
none
'
}
)
;
relay_worker
.
port
.
onmessage
=
t
.
step_func
(
e
=
>
{
assert_equals
(
e
.
data
"
Same
-
origin
handle
access
"
"
Relay
worker
should
divert
messages
here
"
)
;
const
cookie_worker
=
new
SharedWorker
(
"
/
storage
-
access
-
api
/
resources
/
shared
-
worker
-
cookies
.
py
"
{
name
:
id
sameSiteCookies
:
'
none
'
}
)
;
cookie_worker
.
port
.
onmessage
=
t
.
step_func
(
async
(
e
)
=
>
{
assert_equals
(
e
.
data
"
ReadOnLoad
:
None
ReadOnFetch
:
None
ConnectionsMade
:
2
"
"
Worker
should
already
have
been
opened
and
only
see
SameSite
=
None
cookies
"
)
;
await
test_driver
.
delete_all_cookies
(
)
;
t
.
done
(
)
;
}
)
;
}
)
;
const
cookie_set_window
=
window
.
open
(
"
/
storage
-
access
-
api
/
resources
/
set_cookies
.
py
"
)
;
cookie_set_window
.
onload
=
t
.
step_func
(
_
=
>
{
let
iframe
=
document
.
createElement
(
"
iframe
"
)
;
iframe
.
src
=
"
https
:
/
/
{
{
hosts
[
alt
]
[
]
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
/
storage
-
access
-
api
/
resources
/
storage
-
access
-
beyond
-
cookies
-
iframe
.
sub
.
html
?
type
=
SharedWorker
&
id
=
"
+
id
;
document
.
body
.
appendChild
(
iframe
)
;
}
)
;
}
"
Verify
StorageAccessAPIBeyondCookies
for
Shared
Worker
"
)
;
