'
use
strict
'
;
function
processQueryParams
(
)
{
const
url
=
new
URL
(
window
.
location
)
;
const
queryParams
=
url
.
searchParams
;
return
{
topLevelDocument
:
window
=
=
=
window
.
top
testPrefix
:
queryParams
.
get
(
"
testCase
"
)
|
|
"
top
-
level
-
context
"
}
;
}
async
function
CreateFrameHelper
(
setUpFrame
fetchTests
)
{
const
frame
=
document
.
createElement
(
'
iframe
'
)
;
const
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
frame
.
onload
=
(
)
=
>
resolve
(
frame
)
;
frame
.
onerror
=
reject
;
}
)
;
setUpFrame
(
frame
)
;
if
(
fetchTests
)
{
await
fetch_tests_from_window
(
frame
.
contentWindow
)
;
}
return
promise
;
}
function
CreateFrame
(
sourceURL
fetchTests
=
false
frameSandboxAttribute
=
undefined
frameAllowAttribute
=
undefined
)
{
return
CreateFrameHelper
(
(
frame
)
=
>
{
if
(
frameSandboxAttribute
!
=
=
undefined
)
{
frame
.
sandbox
=
frameSandboxAttribute
;
}
if
(
frameAllowAttribute
!
=
=
undefined
)
{
frame
.
setAttribute
(
"
allow
"
frameAllowAttribute
)
;
}
frame
.
src
=
sourceURL
;
document
.
body
.
appendChild
(
frame
)
;
}
fetchTests
)
;
}
function
RunTestsInIFrame
(
sourceURL
frameSandboxAttribute
=
undefined
)
{
return
CreateFrame
(
sourceURL
true
frameSandboxAttribute
)
;
}
function
RunTestsInNestedIFrame
(
sourceURL
)
{
return
CreateFrameHelper
(
(
frame
)
=
>
{
document
.
body
.
appendChild
(
frame
)
;
frame
.
contentDocument
.
write
(
<
script
src
=
"
/
resources
/
testharness
.
js
"
>
<
/
script
>
<
script
src
=
"
helpers
.
js
"
>
<
/
script
>
<
body
>
<
script
>
RunTestsInIFrame
(
"
{
sourceURL
}
"
)
;
<
/
script
>
)
;
frame
.
contentDocument
.
close
(
)
;
}
true
)
;
}
function
CreateDetachedFrame
(
)
{
const
frame
=
document
.
createElement
(
'
iframe
'
)
;
document
.
body
.
append
(
frame
)
;
const
inner_doc
=
frame
.
contentDocument
;
frame
.
remove
(
)
;
return
inner_doc
;
}
function
CreateDocumentViaDOMParser
(
)
{
const
parser
=
new
DOMParser
(
)
;
const
doc
=
parser
.
parseFromString
(
'
<
html
>
<
/
html
>
'
'
text
/
html
'
)
;
return
doc
;
}
function
RunCallbackWithGesture
(
callback
)
{
return
test_driver
.
bless
(
'
run
callback
with
user
gesture
'
callback
)
;
}
function
PostMessageAndAwaitReply
(
message
targetWindow
)
{
const
timestamp
=
window
.
performance
.
now
(
)
;
const
reply
=
ReplyPromise
(
timestamp
)
;
targetWindow
.
postMessage
(
{
timestamp
.
.
.
message
}
"
*
"
)
;
return
reply
;
}
function
ReplyPromise
(
timestamp
)
{
return
new
Promise
(
(
resolve
)
=
>
{
const
listener
=
(
event
)
=
>
{
if
(
event
.
data
.
timestamp
=
=
timestamp
)
{
window
.
removeEventListener
(
"
message
"
listener
)
;
resolve
(
event
.
data
.
data
)
;
}
}
;
window
.
addEventListener
(
"
message
"
listener
)
;
}
)
;
}
function
LoadPromise
(
frame
)
{
return
new
Promise
(
(
resolve
)
=
>
{
frame
.
addEventListener
(
"
load
"
(
event
)
=
>
{
resolve
(
)
;
}
{
once
:
true
}
)
;
}
)
;
}
function
SetDocumentCookieFromFrame
(
frame
cookie
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
write
document
.
cookie
"
cookie
}
frame
.
contentWindow
)
;
}
function
GetJSCookiesFromFrame
(
frame
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
document
.
cookie
"
}
frame
.
contentWindow
)
;
}
async
function
DeleteCookieInFrame
(
frame
name
params
)
{
await
SetDocumentCookieFromFrame
(
frame
{
name
}
=
0
;
expires
=
{
new
Date
(
0
)
.
toUTCString
(
)
}
;
{
params
}
;
)
;
assert_false
(
cookieStringHasCookie
(
name
'
0
'
await
GetJSCookiesFromFrame
(
frame
)
)
Verify
that
cookie
'
{
name
}
'
has
been
deleted
.
)
;
}
async
function
CanFrameWriteCookies
(
frame
keep_after_writing
=
false
)
{
const
cookie_suffix
=
"
Secure
;
SameSite
=
None
;
Path
=
/
"
;
await
DeleteCookieInFrame
(
frame
"
cookie
"
cookie_suffix
)
;
await
DeleteCookieInFrame
(
frame
"
foo
"
cookie_suffix
)
;
await
SetDocumentCookieFromFrame
(
frame
cookie
=
monster
;
{
cookie_suffix
}
)
;
await
SetDocumentCookieFromFrame
(
frame
foo
=
bar
;
{
cookie_suffix
}
)
;
const
cookies
=
await
GetJSCookiesFromFrame
(
frame
)
;
const
can_write
=
cookieStringHasCookie
(
"
cookie
"
"
monster
"
cookies
)
&
&
cookieStringHasCookie
(
"
foo
"
"
bar
"
cookies
)
;
if
(
!
keep_after_writing
)
{
await
DeleteCookieInFrame
(
frame
"
cookie
"
cookie_suffix
)
;
await
DeleteCookieInFrame
(
frame
"
foo
"
cookie_suffix
)
;
}
return
can_write
;
}
async
function
SetFirstPartyCookieAndUnsetStorageAccessPermission
(
origin
)
{
let
frame
=
await
CreateFrame
(
{
origin
}
/
storage
-
access
-
api
/
resources
/
script
-
with
-
cookie
-
header
.
py
?
script
=
embedded_responder
.
js
)
;
await
SetPermissionInFrame
(
frame
[
{
name
:
'
storage
-
access
'
}
'
granted
'
]
)
;
await
RequestStorageAccessInFrame
(
frame
)
;
await
SetDocumentCookieFromFrame
(
frame
cookie
=
unpartitioned
;
Secure
;
SameSite
=
None
;
Path
=
/
)
;
await
SetPermissionInFrame
(
frame
[
{
name
:
'
storage
-
access
'
}
'
prompt
'
]
)
;
}
async
function
HasUnpartitionedCookie
(
frame
)
{
let
frameDocumentCookie
=
await
GetJSCookiesFromFrame
(
frame
)
;
let
jsAccess
=
cookieStringHasCookie
(
"
cookie
"
"
unpartitioned
"
frameDocumentCookie
)
;
const
httpCookie
=
await
FetchSubresourceCookiesFromFrame
(
frame
"
"
)
;
let
httpAccess
=
cookieStringHasCookie
(
"
cookie
"
"
unpartitioned
"
httpCookie
)
;
assert_equals
(
jsAccess
httpAccess
"
HTTP
and
Javascript
cookies
must
be
in
sync
"
)
;
return
jsAccess
&
&
httpAccess
;
}
async
function
CanAccessCookiesViaHTTP
(
)
{
await
fetch
(
{
window
.
location
.
origin
}
/
storage
-
access
-
api
/
resources
/
set
-
cookie
-
header
.
py
?
cookie
=
1
;
path
=
/
;
SameSite
=
None
;
Secure
)
;
const
http_cookies
=
await
fetch
(
{
window
.
location
.
origin
}
/
storage
-
access
-
api
/
resources
/
echo
-
cookie
-
header
.
py
)
.
then
(
(
resp
)
=
>
resp
.
text
(
)
)
;
const
can_access
=
cookieStringHasCookie
(
"
cookie
"
"
1
"
http_cookies
)
;
erase_cookie_from_js
(
"
cookie
"
"
SameSite
=
None
;
Secure
;
Path
=
/
"
)
;
return
can_access
;
}
function
CanAccessCookiesViaJS
(
)
{
erase_cookie_from_js
(
"
cookie
"
"
SameSite
=
None
;
Secure
;
Path
=
/
"
)
;
assert_false
(
cookieStringHasCookie
(
"
cookie
"
"
1
"
document
.
cookie
)
)
;
document
.
cookie
=
"
cookie
=
1
;
SameSite
=
None
;
Secure
;
Path
=
/
"
;
const
can_access
=
cookieStringHasCookie
(
"
cookie
"
"
1
"
document
.
cookie
)
;
erase_cookie_from_js
(
"
cookie
"
"
SameSite
=
None
;
Secure
;
Path
=
/
"
)
;
assert_false
(
cookieStringHasCookie
(
"
cookie
"
"
1
"
document
.
cookie
)
)
;
return
can_access
;
}
function
GetHTTPCookiesFromFrame
(
frame
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
httpCookies
"
}
frame
.
contentWindow
)
;
}
function
FrameHasStorageAccess
(
frame
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
hasStorageAccess
"
}
frame
.
contentWindow
)
;
}
function
RequestStorageAccessInFrame
(
frame
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
requestStorageAccess
"
}
frame
.
contentWindow
)
;
}
function
GetPermissionInFrame
(
frame
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
get_permission
"
}
frame
.
contentWindow
)
;
}
function
SetPermissionInFrame
(
frame
args
=
[
]
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
set_permission
"
args
}
frame
.
contentWindow
)
;
}
function
ObservePermissionChange
(
frame
args
=
[
]
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
observe_permission_change
"
args
}
frame
.
contentWindow
)
;
}
function
FrameInitiatedReload
(
frame
)
{
const
reload
=
LoadPromise
(
frame
)
;
frame
.
contentWindow
.
postMessage
(
{
command
:
"
reload
"
}
"
*
"
)
;
return
reload
;
}
function
FrameInitiatedNavigation
(
frame
url
)
{
const
load
=
LoadPromise
(
frame
)
;
frame
.
contentWindow
.
postMessage
(
{
command
:
"
navigate
"
url
}
"
*
"
)
;
return
load
;
}
function
FetchSubresourceCookiesFromFrame
(
frame
host
)
{
return
FetchFromFrame
(
frame
{
host
}
/
storage
-
access
-
api
/
resources
/
echo
-
cookie
-
header
.
py
)
;
}
function
FetchFromFrame
(
frame
url
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
cors
fetch
"
url
}
frame
.
contentWindow
)
;
}
function
NoCorsSubresourceCookiesFromFrame
(
frame
host
)
{
const
url
=
{
host
}
/
storage
-
access
-
api
/
resources
/
echo
-
cookie
-
header
.
py
;
return
PostMessageAndAwaitReply
(
{
command
:
"
no
-
cors
fetch
"
url
}
frame
.
contentWindow
)
;
}
async
function
MaybeSetStorageAccess
(
origin
embedding_origin
value
)
{
try
{
await
test_driver
.
set_storage_access
(
origin
embedding_origin
value
)
;
}
catch
(
e
)
{
}
}
function
NavigateChild
(
frame
url
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
navigate_child
"
url
}
frame
.
contentWindow
)
;
}
function
StartDedicatedWorker
(
frame
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
start_dedicated_worker
"
}
frame
.
contentWindow
)
;
}
function
MessageWorker
(
frame
message
=
{
}
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
message_worker
"
message
}
frame
.
contentWindow
)
;
}
function
ReadCookiesFromWebSocketConnection
(
frame
origin
)
{
return
PostMessageAndAwaitReply
(
{
command
:
"
get_cookie_via_websocket
"
origin
}
frame
.
contentWindow
)
;
}
