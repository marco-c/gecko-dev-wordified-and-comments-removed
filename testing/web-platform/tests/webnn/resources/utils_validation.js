'
use
strict
'
;
const
allWebNNOperandDataTypes
=
[
'
float32
'
'
float16
'
'
int32
'
'
uint32
'
'
int64
'
'
uint64
'
'
int8
'
'
uint8
'
]
;
const
kMaxUnsignedLong
=
2
*
*
32
-
1
;
const
floatingPointTypes
=
[
'
float32
'
'
float16
'
]
;
const
signedIntegerTypes
=
[
'
int32
'
'
int64
'
'
int8
'
]
;
const
unsignedLongType
=
'
unsigned
long
'
;
const
shape0D
=
[
]
;
const
shape1D
=
[
2
]
;
const
shape2D
=
[
2
3
]
;
const
shape3D
=
[
2
3
4
]
;
const
shape4D
=
[
2
3
4
5
]
;
const
shape5D
=
[
2
3
4
5
6
]
;
const
adjustOffsetsArray
=
[
-
1
1
]
;
const
allWebNNShapesArray
=
[
shape0D
shape1D
shape2D
shape3D
shape4D
shape5D
]
;
const
notUnsignedLongAxisArray
=
[
'
abc
'
BigInt
(
100
)
{
value
:
1
}
[
0
1
]
new
Date
(
"
2024
-
01
-
01
"
)
]
;
function
getRank
(
inputShape
)
{
return
inputShape
.
length
;
}
function
getAxisArray
(
inputShape
)
{
return
Array
.
from
(
{
length
:
inputShape
.
length
}
(
_
i
)
=
>
i
)
;
}
function
getAxesArrayContainSameValues
(
inputShape
)
{
const
axesArrayContainSameValues
=
[
]
;
const
length
=
inputShape
.
length
;
if
(
length
>
=
2
)
{
const
validAxesArrayFull
=
getAxisArray
(
inputShape
)
;
for
(
let
index
=
0
;
index
<
length
;
index
+
+
)
{
axesArrayContainSameValues
.
push
(
new
Array
(
2
)
.
fill
(
validAxesArrayFull
[
index
]
)
)
;
if
(
length
>
2
)
{
axesArrayContainSameValues
.
push
(
new
Array
(
3
)
.
fill
(
validAxesArrayFull
[
index
]
)
)
;
}
}
}
return
axesArrayContainSameValues
;
}
function
generateUnbroadcastableShapes
(
shape
)
{
if
(
shape
.
every
(
dimension
=
>
dimension
=
=
=
1
)
)
{
throw
new
Error
(
[
{
shape
}
]
always
can
be
broadcasted
)
;
}
const
resultShapes
=
[
]
;
const
length
=
shape
.
length
;
if
(
!
shape
.
slice
(
0
length
-
1
)
.
every
(
dimension
=
>
dimension
=
=
=
1
)
)
{
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
shape
[
i
]
!
=
=
1
)
{
for
(
let
offset
of
[
-
1
1
]
)
{
const
shapeB
=
shape
.
slice
(
)
;
shapeB
[
i
]
+
=
offset
;
if
(
shapeB
[
i
]
!
=
=
1
)
{
resultShapes
.
push
(
shapeB
)
;
}
}
}
}
}
const
lastDimensionSize
=
shape
[
length
-
1
]
;
if
(
lastDimensionSize
!
=
=
1
)
{
for
(
let
j
=
0
;
j
<
=
length
;
j
+
+
)
{
if
(
lastDimensionSize
>
2
)
{
resultShapes
.
push
(
Array
(
j
)
.
fill
(
1
)
.
concat
(
[
lastDimensionSize
-
1
]
)
)
;
}
resultShapes
.
push
(
Array
(
j
)
.
fill
(
1
)
.
concat
(
[
lastDimensionSize
+
1
]
)
)
;
}
}
return
resultShapes
;
}
function
generateOutOfRangeValuesArray
(
type
)
{
let
range
outsideValueArray
;
switch
(
type
)
{
case
'
unsigned
long
'
:
range
=
[
0
kMaxUnsignedLong
]
;
break
;
default
:
throw
new
Error
(
Unsupport
{
type
}
)
;
}
outsideValueArray
=
[
range
[
0
]
-
1
range
[
1
]
+
1
]
;
return
outsideValueArray
;
}
let
inputIndex
=
0
;
let
inputAIndex
=
0
;
let
inputBIndex
=
0
;
let
context
;
test
(
(
)
=
>
assert_not_equals
(
navigator
.
ml
undefined
"
ml
property
is
defined
on
navigator
"
)
)
;
promise_setup
(
async
(
)
=
>
{
if
(
navigator
.
ml
=
=
=
undefined
)
{
return
;
}
const
deviceType
=
location
.
search
.
substring
(
1
)
;
context
=
await
navigator
.
ml
.
createContext
(
{
deviceType
:
deviceType
}
)
;
}
{
explicit_timeout
:
true
}
)
;
function
assert_throws_with_label
(
func
regrexp
)
{
try
{
func
.
call
(
this
)
;
assert_true
(
false
'
Graph
builder
method
unexpectedly
succeeded
'
)
;
}
catch
(
e
)
{
assert_equals
(
e
.
name
'
TypeError
'
)
;
const
error_message
=
e
.
message
;
assert_not_equals
(
error_message
.
match
(
regrexp
)
null
)
;
}
}
function
validateTwoInputsBroadcastable
(
operationName
label
)
{
if
(
navigator
.
ml
=
=
=
undefined
)
{
return
;
}
promise_test
(
async
t
=
>
{
const
builder
=
new
MLGraphBuilder
(
context
)
;
for
(
let
dataType
of
allWebNNOperandDataTypes
)
{
if
(
!
context
.
opSupportLimits
(
)
.
input
.
dataTypes
.
includes
(
dataType
)
)
{
assert_throws_js
(
TypeError
(
)
=
>
builder
.
input
(
inputA
{
+
+
inputAIndex
}
{
dataType
shape
:
shape1D
}
)
)
;
continue
;
}
for
(
let
shape
of
allWebNNShapesArray
)
{
if
(
shape
.
length
>
0
)
{
const
inputA
=
builder
.
input
(
inputA
{
+
+
inputAIndex
}
{
dataType
shape
}
)
;
const
unbroadcastableShapes
=
generateUnbroadcastableShapes
(
shape
)
;
for
(
let
shape
of
unbroadcastableShapes
)
{
const
inputB
=
builder
.
input
(
inputB
{
+
+
inputBIndex
}
{
dataType
shape
}
)
;
assert_equals
(
typeof
builder
[
operationName
]
'
function
'
)
;
const
options
=
{
label
}
;
const
regrexp
=
new
RegExp
(
'
\
\
[
'
+
label
+
'
\
\
]
'
)
;
assert_throws_with_label
(
(
)
=
>
builder
[
operationName
]
(
inputA
inputB
options
)
regrexp
)
;
assert_throws_with_label
(
(
)
=
>
builder
[
operationName
]
(
inputB
inputA
options
)
regrexp
)
;
}
}
}
}
}
[
{
operationName
}
]
TypeError
is
expected
if
two
inputs
aren
'
t
broadcastable
)
;
}
function
validateTwoBroadcastableInputsTensorLimit
(
operationName
label
)
{
if
(
navigator
.
ml
=
=
=
undefined
)
{
return
;
}
promise_test
(
async
t
=
>
{
const
builder
=
new
MLGraphBuilder
(
context
)
;
const
a
=
builder
.
input
(
'
a
'
{
dataType
:
'
float32
'
shape
:
[
context
.
opSupportLimits
(
)
.
maxTensorByteLength
/
4
1
]
}
)
;
const
b
=
builder
.
input
(
'
b
'
{
dataType
:
'
float32
'
shape
:
[
1
5
]
}
)
;
const
options
=
{
label
}
;
const
regrexp
=
new
RegExp
(
'
\
\
[
'
+
label
+
'
\
\
]
'
)
;
assert_throws_with_label
(
(
)
=
>
builder
[
operationName
]
(
a
b
options
)
regrexp
)
;
}
[
{
operationName
}
]
throw
if
the
output
tensor
byte
length
exceeds
limit
)
;
}
function
validateTwoInputsOfSameDataType
(
operationName
label
)
{
if
(
navigator
.
ml
=
=
=
undefined
)
{
return
;
}
let
operationNameArray
;
if
(
typeof
operationName
=
=
=
'
string
'
)
{
operationNameArray
=
[
operationName
]
;
}
else
if
(
Array
.
isArray
(
operationName
)
)
{
operationNameArray
=
operationName
;
}
else
{
throw
new
Error
(
{
operationName
}
should
be
an
operation
name
string
or
an
operation
name
string
array
)
;
}
for
(
let
subOperationName
of
operationNameArray
)
{
promise_test
(
async
t
=
>
{
const
builder
=
new
MLGraphBuilder
(
context
)
;
for
(
let
dataType
of
allWebNNOperandDataTypes
)
{
if
(
!
context
.
opSupportLimits
(
)
.
input
.
dataTypes
.
includes
(
dataType
)
)
{
assert_throws_js
(
TypeError
(
)
=
>
builder
.
input
(
inputA
{
+
+
inputAIndex
}
{
dataType
shape
:
shape1D
}
)
)
;
continue
;
}
for
(
let
shape
of
allWebNNShapesArray
)
{
const
inputA
=
builder
.
input
(
inputA
{
+
+
inputAIndex
}
{
dataType
shape
}
)
;
for
(
let
dataTypeB
of
allWebNNOperandDataTypes
)
{
if
(
!
context
.
opSupportLimits
(
)
.
input
.
dataTypes
.
includes
(
dataTypeB
)
)
{
assert_throws_js
(
TypeError
(
)
=
>
builder
.
input
(
inputB
{
+
+
inputBIndex
}
{
dataTypeB
shape1D
}
)
)
;
continue
;
}
if
(
dataType
!
=
=
dataTypeB
)
{
const
inputB
=
builder
.
input
(
inputB
{
+
+
inputBIndex
}
{
dataType
:
dataTypeB
shape
}
)
;
const
options
=
{
label
}
;
const
regrexp
=
new
RegExp
(
'
\
\
[
'
+
label
+
'
\
\
]
'
)
;
assert_equals
(
typeof
builder
[
subOperationName
]
'
function
'
)
;
assert_throws_with_label
(
(
)
=
>
builder
[
subOperationName
]
(
inputA
inputB
options
)
regrexp
)
;
}
}
}
}
}
[
{
subOperationName
}
]
TypeError
is
expected
if
two
inputs
aren
'
t
of
same
data
type
)
;
}
}
function
validateOptionsAxes
(
operationName
)
{
if
(
navigator
.
ml
=
=
=
undefined
)
{
return
;
}
let
operationNameArray
;
if
(
typeof
operationName
=
=
=
'
string
'
)
{
operationNameArray
=
[
operationName
]
;
}
else
if
(
Array
.
isArray
(
operationName
)
)
{
operationNameArray
=
operationName
;
}
else
{
throw
new
Error
(
{
operationName
}
should
be
an
operation
name
string
or
an
operation
name
string
array
)
;
}
const
invalidAxisArray
=
generateOutOfRangeValuesArray
(
unsignedLongType
)
;
for
(
let
subOperationName
of
operationNameArray
)
{
promise_test
(
async
t
=
>
{
const
builder
=
new
MLGraphBuilder
(
context
)
;
for
(
let
dataType
of
allWebNNOperandDataTypes
)
{
if
(
!
context
.
opSupportLimits
(
)
.
input
.
dataTypes
.
includes
(
dataType
)
)
{
assert_throws_js
(
TypeError
(
)
=
>
builder
.
input
(
inputA
{
+
+
inputAIndex
}
{
dataType
shape
:
shape1D
}
)
)
;
continue
;
}
for
(
let
shape
of
allWebNNShapesArray
)
{
const
rank
=
getRank
(
shape
)
;
if
(
rank
>
=
1
)
{
const
input
=
builder
.
input
(
input
{
+
+
inputIndex
}
{
dataType
shape
}
)
;
for
(
let
invalidAxis
of
invalidAxisArray
)
{
assert_equals
(
typeof
builder
[
subOperationName
]
'
function
'
)
;
assert_throws_js
(
TypeError
(
)
=
>
builder
[
subOperationName
]
(
input
{
axes
:
invalidAxis
}
)
)
;
}
for
(
let
axis
of
notUnsignedLongAxisArray
)
{
assert_false
(
typeof
axis
=
=
=
'
number
'
&
&
Number
.
isInteger
(
axis
)
[
{
subOperationName
}
]
any
of
options
.
axes
elements
should
be
of
'
unsigned
long
'
)
;
assert_equals
(
typeof
builder
[
subOperationName
]
'
function
'
)
;
assert_throws_js
(
TypeError
(
)
=
>
builder
[
subOperationName
]
(
input
{
axes
:
[
axis
]
}
)
)
;
}
}
}
}
}
[
{
subOperationName
}
]
TypeError
is
expected
if
any
of
options
.
axes
elements
is
not
an
unsigned
long
interger
)
;
promise_test
(
async
t
=
>
{
const
builder
=
new
MLGraphBuilder
(
context
)
;
for
(
let
dataType
of
allWebNNOperandDataTypes
)
{
if
(
!
context
.
opSupportLimits
(
)
.
input
.
dataTypes
.
includes
(
dataType
)
)
{
assert_throws_js
(
TypeError
(
)
=
>
builder
.
input
(
inputA
{
+
+
inputAIndex
}
{
dataType
shape
:
shape1D
}
)
)
;
continue
;
}
for
(
let
shape
of
allWebNNShapesArray
)
{
const
rank
=
getRank
(
shape
)
;
if
(
rank
>
=
1
)
{
const
input
=
builder
.
input
(
input
{
+
+
inputIndex
}
{
dataType
shape
}
)
;
assert_equals
(
typeof
builder
[
subOperationName
]
'
function
'
)
;
assert_throws_js
(
TypeError
(
)
=
>
builder
[
subOperationName
]
(
input
{
axes
:
[
rank
]
}
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
builder
[
subOperationName
]
(
input
{
axes
:
[
rank
+
1
]
}
)
)
;
}
}
}
}
[
{
subOperationName
}
]
TypeError
is
expected
if
any
of
options
.
axes
elements
is
greater
or
equal
to
the
size
of
input
)
;
promise_test
(
async
t
=
>
{
const
builder
=
new
MLGraphBuilder
(
context
)
;
for
(
let
dataType
of
allWebNNOperandDataTypes
)
{
if
(
!
context
.
opSupportLimits
(
)
.
input
.
dataTypes
.
includes
(
dataType
)
)
{
assert_throws_js
(
TypeError
(
)
=
>
builder
.
input
(
inputA
{
+
+
inputAIndex
}
{
dataType
shape
:
shape1D
}
)
)
;
continue
;
}
for
(
let
shape
of
allWebNNShapesArray
)
{
const
rank
=
getRank
(
shape
)
;
if
(
rank
>
=
2
)
{
const
input
=
builder
.
input
(
input
{
+
+
inputIndex
}
{
dataType
shape
}
)
;
const
axesArrayContainSameValues
=
getAxesArrayContainSameValues
(
shape
)
;
for
(
let
axes
of
axesArrayContainSameValues
)
{
assert_equals
(
typeof
builder
[
subOperationName
]
'
function
'
)
;
assert_throws_js
(
TypeError
(
)
=
>
builder
[
subOperationName
]
(
input
{
axes
}
)
)
;
}
}
}
}
}
[
{
subOperationName
}
]
TypeError
is
expected
if
two
or
more
values
are
same
in
the
axes
sequence
)
;
}
}
function
validateUnaryOperation
(
operationName
supportedDataTypes
label
)
{
promise_test
(
async
t
=
>
{
const
builder
=
new
MLGraphBuilder
(
context
)
;
for
(
let
dataType
of
supportedDataTypes
)
{
if
(
!
context
.
opSupportLimits
(
)
.
input
.
dataTypes
.
includes
(
dataType
)
)
{
assert_throws_js
(
TypeError
(
)
=
>
builder
.
input
(
inputA
{
+
+
inputAIndex
}
{
dataType
shape
:
shape1D
}
)
)
;
continue
;
}
for
(
let
shape
of
allWebNNShapesArray
)
{
const
input
=
builder
.
input
(
input
{
dataType
shape
}
)
;
assert_equals
(
typeof
builder
[
operationName
]
'
function
'
)
;
const
output
=
builder
[
operationName
]
(
input
)
;
assert_equals
(
output
.
dataType
dataType
)
;
assert_array_equals
(
output
.
shape
shape
)
;
}
}
}
[
{
operationName
}
]
Test
building
an
unary
operator
with
supported
type
.
)
;
const
unsupportedDataTypes
=
new
Set
(
allWebNNOperandDataTypes
)
.
difference
(
new
Set
(
supportedDataTypes
)
)
;
promise_test
(
async
t
=
>
{
const
builder
=
new
MLGraphBuilder
(
context
)
;
for
(
let
dataType
of
unsupportedDataTypes
)
{
if
(
!
context
.
opSupportLimits
(
)
.
input
.
dataTypes
.
includes
(
dataType
)
)
{
assert_throws_js
(
TypeError
(
)
=
>
builder
.
input
(
inputA
{
+
+
inputAIndex
}
{
dataType
shape
:
shape1D
}
)
)
;
continue
;
}
for
(
let
shape
of
allWebNNShapesArray
)
{
const
input
=
builder
.
input
(
input
{
dataType
shape
}
)
;
assert_equals
(
typeof
builder
[
operationName
]
'
function
'
)
;
const
options
=
{
label
}
;
const
regrexp
=
new
RegExp
(
'
\
\
[
'
+
label
+
'
\
\
]
'
)
;
assert_throws_with_label
(
(
)
=
>
builder
[
operationName
]
(
input
options
)
regrexp
)
;
}
}
}
[
{
operationName
}
]
Throw
if
the
dataType
is
not
supported
for
an
unary
operator
.
)
;
}
function
validateSingleInputOperation
(
operationName
label
)
{
promise_test
(
async
t
=
>
{
const
builder
=
new
MLGraphBuilder
(
context
)
;
const
supportedDataTypes
=
context
.
opSupportLimits
(
)
[
operationName
]
.
input
.
dataTypes
;
for
(
let
dataType
of
supportedDataTypes
)
{
if
(
!
context
.
opSupportLimits
(
)
.
input
.
dataTypes
.
includes
(
dataType
)
)
{
continue
;
}
for
(
let
shape
of
allWebNNShapesArray
)
{
const
input
=
builder
.
input
(
input
{
dataType
shape
}
)
;
const
output
=
builder
[
operationName
]
(
input
)
;
assert_equals
(
output
.
dataType
dataType
)
;
assert_array_equals
(
output
.
shape
shape
)
;
}
}
}
[
{
operationName
}
]
Test
building
the
operator
with
supported
data
type
.
)
;
promise_test
(
async
t
=
>
{
const
builder
=
new
MLGraphBuilder
(
context
)
;
const
unsupportedDataTypes
=
new
Set
(
allWebNNOperandDataTypes
)
.
difference
(
new
Set
(
context
.
opSupportLimits
(
)
[
operationName
]
.
input
.
dataTypes
)
)
;
for
(
let
dataType
of
unsupportedDataTypes
)
{
if
(
!
context
.
opSupportLimits
(
)
.
input
.
dataTypes
.
includes
(
dataType
)
)
{
assert_throws_js
(
TypeError
(
)
=
>
builder
.
input
(
inputA
{
+
+
inputAIndex
}
{
dataType
shape
:
shape1D
}
)
)
;
continue
;
}
for
(
let
shape
of
allWebNNShapesArray
)
{
const
input
=
builder
.
input
(
input
{
dataType
shape
}
)
;
assert_equals
(
typeof
builder
[
operationName
]
'
function
'
)
;
const
options
=
{
label
}
;
const
regrexp
=
new
RegExp
(
'
\
\
[
'
+
label
+
'
\
\
]
'
)
;
assert_throws_with_label
(
(
)
=
>
builder
[
operationName
]
(
input
options
)
regrexp
)
;
}
}
}
[
{
operationName
}
]
Throw
if
the
data
type
is
not
supported
for
the
operator
.
)
;
}
function
validateInputFromAnotherBuilder
(
operatorName
operatorDescriptor
=
{
dataType
:
'
float32
'
shape
:
[
2
2
]
}
)
{
multi_builder_test
(
async
(
t
builder
otherBuilder
)
=
>
{
const
inputFromOtherBuilder
=
otherBuilder
.
input
(
'
input
'
operatorDescriptor
)
;
assert_equals
(
typeof
builder
[
operatorName
]
'
function
'
)
;
assert_throws_js
(
TypeError
(
)
=
>
builder
[
operatorName
]
(
inputFromOtherBuilder
)
)
;
}
[
{
operatorName
}
]
throw
if
input
is
from
another
builder
)
;
}
;
function
validateTwoInputsFromMultipleBuilders
(
operatorName
)
{
const
opDescriptor
=
{
dataType
:
'
float32
'
shape
:
[
2
2
]
}
;
multi_builder_test
(
async
(
t
builder
otherBuilder
)
=
>
{
const
inputFromOtherBuilder
=
otherBuilder
.
input
(
'
other
'
opDescriptor
)
;
const
input
=
builder
.
input
(
'
input
'
opDescriptor
)
;
assert_equals
(
typeof
builder
[
operatorName
]
'
function
'
)
;
assert_throws_js
(
TypeError
(
)
=
>
builder
[
operatorName
]
(
inputFromOtherBuilder
input
)
)
;
}
[
{
operatorName
}
]
throw
if
first
input
is
from
another
builder
)
;
multi_builder_test
(
async
(
t
builder
otherBuilder
)
=
>
{
const
inputFromOtherBuilder
=
otherBuilder
.
input
(
'
other
'
opDescriptor
)
;
const
input
=
builder
.
input
(
'
input
'
opDescriptor
)
;
assert_equals
(
typeof
builder
[
operatorName
]
'
function
'
)
;
assert_throws_js
(
TypeError
(
)
=
>
builder
[
operatorName
]
(
input
inputFromOtherBuilder
)
)
;
}
[
{
operatorName
}
]
throw
if
second
input
is
from
another
builder
)
;
}
;
function
multi_builder_test
(
func
description
)
{
promise_test
(
async
t
=
>
{
const
builder
=
new
MLGraphBuilder
(
context
)
;
const
otherBuilder
=
new
MLGraphBuilder
(
context
)
;
await
func
(
t
builder
otherBuilder
)
;
}
description
)
;
}
