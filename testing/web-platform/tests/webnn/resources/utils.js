'
use
strict
'
;
const
TypedArrayDict
=
{
float32
:
Float32Array
float16
:
Uint16Array
int64
:
BigInt64Array
uint64
:
BigUint64Array
int32
:
Int32Array
uint32
:
Uint32Array
int8
:
Int8Array
uint8
:
Uint8Array
}
;
const
kIntTypes
=
[
'
uint8
'
'
int8
'
'
uint32
'
'
int32
'
'
uint64
'
'
int64
'
]
;
const
kFloatTypes
=
[
'
float16
'
'
float32
'
]
;
const
findCompatibleType
=
(
dataType
supportedTypes
)
=
>
{
for
(
let
supportedType
of
supportedTypes
)
{
if
(
kIntTypes
.
includes
(
dataType
)
)
{
if
(
kIntTypes
.
indexOf
(
supportedType
)
>
kIntTypes
.
indexOf
(
dataType
)
)
{
return
supportedType
;
}
}
if
(
kFloatTypes
.
includes
(
dataType
)
)
{
if
(
kFloatTypes
.
indexOf
(
supportedType
)
>
kFloatTypes
.
indexOf
(
dataType
)
)
{
return
supportedType
;
}
}
}
return
null
;
}
;
const
kMaximumIndexToValidate
=
1000
;
const
kContextOptionsForVariant
=
{
cpu
:
{
deviceType
:
'
cpu
'
}
gpu
:
{
deviceType
:
'
gpu
'
}
npu
:
{
deviceType
:
'
npu
'
}
}
;
const
variant
=
location
.
search
.
substring
(
1
)
;
const
contextOptions
=
kContextOptionsForVariant
[
variant
]
;
const
assertDescriptorsEquals
=
(
outputOperand
expected
)
=
>
{
const
dataType
=
expected
.
castedType
?
expected
.
castedType
:
expected
.
dataType
;
assert_true
(
outputOperand
.
dataType
(
)
=
=
=
dataType
'
actual
output
dataType
should
be
equal
to
expected
output
dataType
'
)
;
assert_array_equals
(
outputOperand
.
shape
(
)
expected
.
dimensions
'
actual
output
dimesnisons
should
be
equal
to
expected
output
dimensions
'
)
;
}
;
const
toHalf
=
(
value
)
=
>
{
let
floatView
=
new
Float32Array
(
1
)
;
let
int32View
=
new
Int32Array
(
floatView
.
buffer
)
;
floatView
[
0
]
=
value
;
let
x
=
int32View
[
0
]
;
let
bits
=
(
x
>
>
16
)
&
0x8000
;
let
m
=
(
x
>
>
12
)
&
0x07ff
;
let
e
=
(
x
>
>
23
)
&
0xff
;
if
(
e
<
103
)
{
return
bits
;
}
if
(
e
>
142
)
{
bits
|
=
0x7c00
;
bits
|
=
(
(
e
=
=
255
)
?
0
:
1
)
&
&
(
x
&
0x007fffff
)
;
return
bits
;
}
if
(
e
<
113
)
{
m
|
=
0x0800
;
bits
|
=
(
m
>
>
(
114
-
e
)
)
+
(
(
m
>
>
(
113
-
e
)
)
&
1
)
;
return
bits
;
}
bits
|
=
(
(
e
-
112
)
<
<
10
)
|
(
m
>
>
1
)
;
bits
+
=
m
&
1
;
return
bits
;
}
;
const
getTypedArrayData
=
(
type
size
data
)
=
>
{
let
outData
;
if
(
type
=
=
=
'
float16
'
)
{
if
(
typeof
(
data
)
=
=
=
'
number
'
&
&
size
>
1
)
{
return
new
TypedArrayDict
[
type
]
(
size
)
.
fill
(
toHalf
(
data
)
)
;
}
outData
=
new
TypedArrayDict
[
type
]
(
data
.
length
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
outData
[
i
]
=
toHalf
(
data
[
i
]
)
;
}
}
else
if
(
type
=
=
=
'
int64
'
)
{
if
(
typeof
(
data
)
=
=
=
'
number
'
&
&
size
>
1
)
{
return
new
TypedArrayDict
[
type
]
(
size
)
.
fill
(
BigInt
(
data
)
)
;
}
outData
=
new
TypedArrayDict
[
type
]
(
data
.
length
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
outData
[
i
]
=
BigInt
(
data
[
i
]
)
;
}
}
else
{
if
(
typeof
(
data
)
=
=
=
'
number
'
&
&
size
>
1
)
{
return
new
TypedArrayDict
[
type
]
(
size
)
.
fill
(
data
)
;
}
outData
=
new
TypedArrayDict
[
type
]
(
data
)
;
}
return
outData
;
}
;
const
sizeOfShape
=
(
array
)
=
>
{
return
array
.
reduce
(
(
accumulator
currentValue
)
=
>
accumulator
*
currentValue
1
)
;
}
;
const
getBitwise
=
(
value
dataType
)
=
>
{
const
buffer
=
new
ArrayBuffer
(
8
)
;
const
int64Array
=
new
BigInt64Array
(
buffer
)
;
int64Array
[
0
]
=
value
<
0
?
~
BigInt
(
0
)
:
BigInt
(
0
)
;
let
typedArray
;
if
(
dataType
=
=
=
"
float32
"
)
{
typedArray
=
new
Float32Array
(
buffer
)
;
}
else
{
throw
new
AssertionError
(
Data
type
{
dataType
}
is
not
supported
)
;
}
typedArray
[
0
]
=
value
;
return
int64Array
[
0
]
;
}
;
const
assert_array_approx_equals_ulp
=
(
actual
expected
nulp
dataType
description
)
=
>
{
assert_true
(
actual
.
length
=
=
=
expected
.
length
assert_array_approx_equals_ulp
:
{
description
}
lengths
differ
+
expected
{
expected
.
length
}
but
got
{
actual
.
length
}
)
;
let
actualBitwise
expectedBitwise
distance
;
for
(
let
i
=
0
;
i
<
actual
.
length
;
i
+
+
)
{
if
(
actual
[
i
]
=
=
=
expected
[
i
]
)
{
continue
;
}
else
{
if
(
dataType
=
=
=
'
float32
'
)
{
actualBitwise
=
getBitwise
(
actual
[
i
]
dataType
)
;
expectedBitwise
=
getBitwise
(
expected
[
i
]
dataType
)
;
}
else
if
(
dataType
=
=
=
'
float16
'
)
{
actualBitwise
=
actual
[
i
]
;
expectedBitwise
=
toHalf
(
expected
[
i
]
)
;
}
else
if
(
dataType
=
=
=
'
int64
'
)
{
actualBitwise
=
actual
[
i
]
;
expectedBitwise
=
BigInt
(
expected
[
i
]
)
;
}
distance
=
actualBitwise
-
expectedBitwise
;
distance
=
distance
>
=
0
?
distance
:
-
distance
;
if
(
distance
>
nulp
)
{
assert_true
(
false
assert_array_approx_equals_ulp
:
{
description
}
actual
+
{
actual
[
i
]
}
should
be
close
enough
to
expected
+
{
expected
[
i
]
}
by
the
acceptable
{
nulp
}
ULP
distance
+
but
they
have
{
distance
}
ULP
distance
)
;
}
}
}
}
;
const
doAssert
=
(
operatorName
actual
expected
metricType
toleranceValue
dataType
)
=
>
{
const
description
=
test
{
operatorName
}
{
dataType
}
;
if
(
typeof
expected
=
=
=
'
number
'
)
{
expected
=
[
expected
]
;
actual
=
[
actual
]
;
}
if
(
metricType
=
=
=
'
ULP
'
)
{
assert_array_approx_equals_ulp
(
actual
expected
toleranceValue
dataType
description
)
;
}
else
if
(
metricType
=
=
=
'
ATOL
'
)
{
assert_array_approx_equals
(
actual
expected
toleranceValue
description
)
;
}
else
{
throw
new
AssertionError
(
Tolerance
Metric
type
'
{
metricType
}
'
is
not
supported
)
;
}
}
;
const
assertResultsEquals
=
(
toleranceFunc
actual
graphResources
)
=
>
{
const
operatorName
=
graphResources
.
operators
.
map
(
operator
=
>
operator
.
name
)
.
join
(
'
'
)
;
const
expectedOutputs
=
graphResources
.
expectedOutputs
;
const
toleranceInfo
=
toleranceFunc
(
graphResources
)
;
const
metricType
=
toleranceInfo
.
metricType
;
const
toleranceValue
=
toleranceInfo
.
value
;
let
outputData
;
for
(
let
operandName
in
actual
)
{
const
expectedSuboutput
=
expectedOutputs
[
operandName
]
;
outputData
=
actual
[
operandName
]
;
if
(
typeof
(
expectedSuboutput
.
data
)
=
=
=
'
number
'
&
&
expectedSuboutput
.
dimensions
&
&
sizeOfShape
(
expectedSuboutput
.
dimensions
)
>
1
)
{
const
size
=
Math
.
min
(
kMaximumIndexToValidate
sizeOfShape
(
expectedSuboutput
.
dimensions
)
)
;
expectedSuboutput
.
data
=
new
Array
(
size
)
.
fill
(
expectedSuboutput
.
data
)
;
outputData
=
outputData
.
subarray
(
0
kMaximumIndexToValidate
)
;
}
doAssert
(
operatorName
outputData
expectedSuboutput
.
data
metricType
toleranceValue
expectedSuboutput
.
dataType
)
;
}
}
;
const
createOperand
=
(
context
builder
operandName
resources
)
=
>
{
let
operand
;
const
descriptor
=
resources
.
descriptor
;
const
dataType
=
descriptor
.
dataType
;
if
(
!
context
.
opSupportLimits
(
)
.
input
.
dataTypes
.
includes
(
dataType
)
)
{
const
compatibleType
=
findCompatibleType
(
dataType
context
.
opSupportLimits
(
)
.
input
.
dataTypes
)
;
if
(
compatibleType
)
{
descriptor
.
castedType
=
compatibleType
;
descriptor
.
dataType
=
compatibleType
;
}
}
operand
=
resources
.
constant
?
builder
.
constant
(
descriptor
getTypedArrayData
(
descriptor
.
dataType
sizeOfShape
(
descriptor
.
dimensions
)
resources
.
data
)
)
:
builder
.
input
(
operandName
descriptor
)
;
if
(
descriptor
.
castedType
)
{
operand
=
builder
.
cast
(
operand
dataType
)
;
}
return
operand
;
}
;
const
prepareInputsForGraph
=
(
inputs
resources
)
=
>
{
for
(
let
operandName
of
Object
.
keys
(
resources
)
)
{
const
inputOperandResources
=
resources
[
operandName
]
;
if
(
!
inputOperandResources
.
constant
)
{
inputs
[
operandName
]
=
getTypedArrayData
(
inputOperandResources
.
descriptor
.
castedType
?
inputOperandResources
.
descriptor
.
castedType
:
inputOperandResources
.
descriptor
.
dataType
sizeOfShape
(
inputOperandResources
.
descriptor
.
dimensions
)
inputOperandResources
.
data
)
;
}
}
}
;
const
prepareOutputsForGraph
=
(
outputs
resources
)
=
>
{
for
(
let
operandName
of
Object
.
keys
(
resources
)
)
{
const
descriptor
=
resources
[
operandName
]
.
descriptor
;
const
dataType
=
descriptor
.
castedType
?
descriptor
.
castedType
:
descriptor
.
dataType
;
outputs
[
operandName
]
=
new
TypedArrayDict
[
dataType
]
(
sizeOfShape
(
descriptor
.
dimensions
)
)
;
}
}
;
const
buildGraphAndCompute
=
async
(
context
builder
graphResources
)
=
>
{
let
outputOperands
;
const
graphInputs
=
graphResources
.
inputs
;
const
graphOperators
=
graphResources
.
operators
;
if
(
graphOperators
.
length
=
=
=
1
)
{
const
argumentArray
=
[
]
;
for
(
const
argument
of
graphOperators
[
0
]
.
arguments
)
{
for
(
const
argumentName
in
argument
)
{
if
(
argumentName
!
=
=
'
options
'
)
{
if
(
graphInputs
.
hasOwnProperty
(
argument
[
argumentName
]
)
)
{
const
operandName
=
argument
[
argumentName
]
;
const
operand
=
createOperand
(
context
builder
operandName
graphInputs
[
operandName
]
)
;
argumentArray
.
push
(
operand
)
;
}
else
{
argumentArray
.
push
(
argument
[
argumentName
]
)
;
}
}
else
{
for
(
const
[
optionalArgumentName
value
]
of
Object
.
entries
(
argument
[
'
options
'
]
)
)
{
if
(
typeof
value
=
=
=
'
string
'
&
&
graphInputs
.
hasOwnProperty
(
value
)
)
{
const
operandName
=
value
;
const
operand
=
createOperand
(
context
builder
operandName
graphInputs
[
operandName
]
)
;
argument
[
'
options
'
]
[
optionalArgumentName
]
=
operand
;
}
}
argumentArray
.
push
(
argument
[
'
options
'
]
)
;
}
}
}
outputOperands
=
builder
[
graphOperators
[
0
]
.
name
]
(
.
.
.
argumentArray
)
;
}
else
{
}
if
(
!
Array
.
isArray
(
outputOperands
)
)
{
outputOperands
=
[
outputOperands
]
;
}
for
(
let
i
=
0
;
i
<
outputOperands
.
length
;
+
+
i
)
{
const
expectedDescriptor
=
graphResources
.
expectedOutputs
[
Object
.
keys
(
graphResources
.
expectedOutputs
)
[
i
]
]
.
descriptor
;
if
(
!
context
.
opSupportLimits
(
)
.
output
.
dataTypes
.
includes
(
expectedDescriptor
.
dataType
)
)
{
const
compatibleType
=
findCompatibleType
(
expectedDescriptor
.
dataType
context
.
opSupportLimits
(
)
.
output
.
dataTypes
)
;
outputOperands
[
i
]
=
builder
.
cast
(
outputOperands
[
i
]
compatibleType
)
;
expectedDescriptor
.
castedType
=
compatibleType
;
}
}
const
outputNameArray
=
Object
.
keys
(
graphResources
.
expectedOutputs
)
;
for
(
let
i
=
0
;
i
<
outputOperands
.
length
;
+
+
i
)
{
assertDescriptorsEquals
(
outputOperands
[
i
]
graphResources
.
expectedOutputs
[
outputNameArray
[
i
]
]
.
descriptor
)
;
}
const
namedOutputOperand
=
{
}
;
outputNameArray
.
forEach
(
(
name
index
)
=
>
namedOutputOperand
[
name
]
=
outputOperands
[
index
]
)
;
const
graph
=
await
builder
.
build
(
namedOutputOperand
)
;
const
inputs
=
{
}
;
prepareInputsForGraph
(
inputs
graphInputs
)
;
const
outputs
=
{
}
;
prepareOutputsForGraph
(
outputs
graphResources
.
expectedOutputs
)
;
const
result
=
await
context
.
compute
(
graph
inputs
outputs
)
;
return
result
;
}
;
const
getConv2dPrecisionTolerance
=
(
graphResources
)
=
>
{
const
operatorResources
=
graphResources
.
operators
[
0
]
;
const
operatorName
=
operatorResources
.
name
;
const
args
=
operatorResources
.
arguments
;
const
inputShape
=
graphResources
.
inputs
[
args
[
0
]
[
Object
.
keys
(
args
[
0
]
)
[
0
]
]
]
.
descriptor
.
dimensions
;
const
filterShape
=
graphResources
.
inputs
[
args
[
1
]
[
Object
.
keys
(
args
[
1
]
)
[
0
]
]
]
.
descriptor
.
dimensions
;
const
options
=
args
.
length
=
=
=
3
?
{
.
.
.
args
[
2
]
[
Object
.
keys
(
args
[
2
]
)
[
0
]
]
}
:
{
}
;
let
inputChannels
=
inputShape
[
1
]
;
let
filterWidth
=
filterShape
[
3
]
;
let
filterHeight
=
filterShape
[
2
]
;
const
groups
=
options
.
groups
?
options
.
groups
:
1
;
if
(
options
.
inputLayout
)
{
if
(
!
[
'
nchw
'
'
nhwc
'
]
.
includes
(
options
.
inputLayout
)
)
{
throw
new
Error
(
Unknown
inputLayout
{
options
.
inputLayout
}
)
;
}
inputChannels
=
options
.
inputLayout
=
=
=
'
nchw
'
?
inputChannels
:
inputShape
[
3
]
;
}
if
(
options
.
filterLayout
)
{
let
filterLayouts
=
[
'
oihw
'
'
hwio
'
'
ohwi
'
'
ihwo
'
]
;
if
(
operatorName
=
=
=
'
convTranspose2d
'
)
{
filterLayouts
=
[
'
iohw
'
'
hwoi
'
'
ohwi
'
]
;
}
if
(
!
filterLayouts
.
includes
(
options
.
filterLayout
)
)
{
throw
new
Error
(
Unknown
filterLayout
{
options
.
filterLayout
}
)
;
}
switch
(
options
.
filterLayout
)
{
case
'
oihw
'
:
case
'
iohw
'
:
break
;
case
'
hwio
'
:
case
'
hwoi
'
:
filterWidth
=
filterShape
[
1
]
;
filterHeight
=
filterShape
[
0
]
;
break
;
case
'
ohwi
'
:
case
'
ihwo
'
:
filterWidth
=
filterShape
[
2
]
;
filterHeight
=
filterShape
[
1
]
;
break
;
default
:
break
;
}
}
const
tolerance
=
filterWidth
*
filterHeight
*
(
inputChannels
/
groups
)
*
2
;
const
toleranceValueDict
=
{
float32
:
tolerance
float16
:
tolerance
}
;
const
expectedDataType
=
getExpectedDataTypeOfSingleOutput
(
graphResources
.
expectedOutputs
)
;
return
{
metricType
:
'
ULP
'
value
:
toleranceValueDict
[
expectedDataType
]
}
;
}
;
const
getExpectedDataTypeOfSingleOutput
=
(
expectedOutput
)
=
>
{
const
expectedDescriptor
=
expectedOutput
[
Object
.
keys
(
expectedOutput
)
[
0
]
]
.
descriptor
;
const
dataType
=
expectedDescriptor
.
castedType
?
expectedDescriptor
.
castedType
:
expectedDescriptor
.
dataType
;
return
dataType
;
}
;
const
webnn_conformance_test
=
(
buildGraphAndComputeFunc
toleranceFunc
testResources
)
=
>
{
promise_test
(
async
(
)
=
>
{
let
context
;
try
{
context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
}
catch
(
e
)
{
throw
new
AssertionError
(
Unable
to
create
context
for
{
variant
}
variant
.
{
e
}
)
;
}
const
builder
=
new
MLGraphBuilder
(
context
)
;
const
result
=
await
buildGraphAndComputeFunc
(
context
builder
testResources
.
graph
)
;
assertResultsEquals
(
toleranceFunc
result
.
outputs
testResources
.
graph
)
;
}
testResources
.
name
)
;
}
;
