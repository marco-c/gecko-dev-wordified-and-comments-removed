'
use
strict
'
;
const
TypedArrayDict
=
{
float16
:
Uint16Array
float32
:
Float32Array
int32
:
Int32Array
uint32
:
Uint32Array
int8
:
Int8Array
uint8
:
Uint8Array
int64
:
BigInt64Array
}
;
const
kContextOptionsForVariant
=
{
cpu
:
{
deviceType
:
'
cpu
'
}
gpu
:
{
deviceType
:
'
gpu
'
}
npu
:
{
deviceType
:
'
npu
'
}
}
;
const
kMaximumIndexToValidate
=
1000
;
const
getTypedArrayData
=
(
type
size
data
)
=
>
{
let
outData
;
if
(
type
=
=
=
'
float16
'
)
{
if
(
typeof
(
data
)
=
=
=
'
number
'
&
&
size
>
1
)
{
return
new
TypedArrayDict
[
type
]
(
size
)
.
fill
(
toHalf
(
data
)
)
;
}
outData
=
new
TypedArrayDict
[
type
]
(
data
.
length
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
outData
[
i
]
=
toHalf
(
data
[
i
]
)
;
}
}
else
if
(
type
=
=
=
'
int64
'
)
{
if
(
typeof
(
data
)
=
=
=
'
number
'
&
&
size
>
1
)
{
return
new
TypedArrayDict
[
type
]
(
size
)
.
fill
(
BigInt
(
data
)
)
;
}
outData
=
new
TypedArrayDict
[
type
]
(
data
.
length
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
outData
[
i
]
=
BigInt
(
data
[
i
]
)
;
}
}
else
{
if
(
typeof
(
data
)
=
=
=
'
number
'
&
&
size
>
1
)
{
return
new
TypedArrayDict
[
type
]
(
size
)
.
fill
(
data
)
;
}
outData
=
new
TypedArrayDict
[
type
]
(
data
)
;
}
return
outData
;
}
;
const
bytesPerDataType
=
(
dataType
)
=
>
{
if
(
dataType
=
=
=
'
int8
'
|
|
dataType
=
=
=
'
uint8
'
)
{
return
1
;
}
else
if
(
dataType
=
=
=
'
float16
'
)
{
return
2
;
}
else
if
(
dataType
=
=
=
'
float32
'
|
|
dataType
=
=
=
'
int32
'
|
|
dataType
=
=
=
'
uint32
'
)
{
return
4
;
}
else
if
(
dataType
=
=
=
'
int64
'
|
|
dataType
=
=
=
'
uint64
'
)
{
return
8
;
}
}
;
const
sizeOfShape
=
(
array
)
=
>
{
return
array
.
reduce
(
(
accumulator
currentValue
)
=
>
accumulator
*
currentValue
1
)
;
}
;
const
sizeOfDescriptor
=
(
descriptor
)
=
>
{
return
descriptor
.
dimensions
.
reduce
(
(
accumulator
currentValue
)
=
>
accumulator
*
currentValue
bytesPerDataType
(
descriptor
.
dataType
)
)
;
}
;
const
getDescriptorFromBuffer
=
(
buffer
)
=
>
{
return
{
dataType
:
buffer
.
dataType
dimensions
:
buffer
.
shape
}
;
}
;
const
loadTests
=
(
operationName
)
=
>
{
const
loadJSON
=
(
file
)
=
>
{
let
xmlhttp
=
new
XMLHttpRequest
(
)
;
xmlhttp
.
open
(
"
GET
"
file
false
)
;
xmlhttp
.
overrideMimeType
(
"
application
/
json
"
)
;
xmlhttp
.
send
(
)
;
if
(
xmlhttp
.
status
=
=
200
&
&
xmlhttp
.
readyState
=
=
4
)
{
return
xmlhttp
.
responseText
;
}
else
{
throw
new
Error
(
Failed
to
load
{
file
}
)
;
}
}
;
const
capitalLetterMatches
=
operationName
.
match
(
/
[
A
-
Z
]
/
g
)
;
if
(
capitalLetterMatches
!
=
=
null
)
{
capitalLetterMatches
.
forEach
(
capitalLetter
=
>
operationName
=
operationName
.
replace
(
capitalLetter
_
{
capitalLetter
.
toLowerCase
(
)
}
)
)
}
const
json
=
loadJSON
(
/
webnn
/
resources
/
test_data
/
{
operationName
}
.
json
)
;
const
resources
=
JSON
.
parse
(
json
.
replace
(
/
\
\
"
|
"
(
?
:
\
\
"
|
[
^
"
]
)
*
"
|
(
\
/
\
/
.
*
|
\
/
\
*
[
\
s
\
S
]
*
?
\
*
\
/
)
/
g
(
m
g
)
=
>
g
?
"
"
:
m
)
)
;
return
resources
.
tests
;
}
;
const
getNamedResource
=
(
resources
outputName
)
=
>
{
let
ret
;
for
(
let
resource
of
resources
)
{
if
(
resource
.
name
=
=
=
outputName
)
{
ret
=
resource
;
break
;
}
}
if
(
ret
=
=
=
undefined
)
{
throw
new
Error
(
Failed
to
get
expected
resource
by
{
outputName
}
)
;
}
return
ret
;
}
;
const
getConv2dPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
inputNameArray
=
Object
.
keys
(
resources
.
inputs
)
;
const
inputShape
=
resources
.
inputs
[
inputNameArray
[
0
]
]
.
shape
;
const
filterShape
=
resources
.
inputs
[
inputNameArray
[
1
]
]
.
shape
;
const
options
=
resources
.
options
;
let
groups
=
1
;
let
inputChannels
=
inputShape
[
1
]
;
let
filterWidth
=
filterShape
[
3
]
;
let
filterHeight
=
filterShape
[
2
]
;
if
(
options
)
{
if
(
options
.
groups
)
{
groups
=
options
.
groups
;
}
if
(
options
.
inputLayout
)
{
if
(
!
[
'
nchw
'
'
nhwc
'
]
.
includes
(
options
.
inputLayout
)
)
{
throw
new
Error
(
Unsupported
inputLayout
{
options
.
inputLayout
}
)
;
}
inputChannels
=
options
.
inputLayout
=
=
=
'
nchw
'
?
inputChannels
:
inputShape
[
3
]
;
}
if
(
options
.
filterLayout
)
{
let
filterLayouts
=
[
'
oihw
'
'
hwio
'
'
ohwi
'
'
ihwo
'
]
;
if
(
operationName
=
=
=
'
convTranspose2d
'
)
{
filterLayouts
=
[
'
iohw
'
'
hwoi
'
'
ohwi
'
]
;
}
if
(
!
filterLayouts
.
includes
(
options
.
filterLayout
)
)
{
throw
new
Error
(
Unsupported
filterLayout
{
options
.
filterLayout
}
)
;
}
switch
(
options
.
filterLayout
)
{
case
'
oihw
'
:
case
'
iohw
'
:
break
;
case
'
hwio
'
:
case
'
hwoi
'
:
filterWidth
=
filterShape
[
1
]
;
filterHeight
=
filterShape
[
0
]
;
break
;
case
'
ohwi
'
:
case
'
ihwo
'
:
filterWidth
=
filterShape
[
2
]
;
filterHeight
=
filterShape
[
1
]
;
break
;
default
:
break
;
}
}
}
const
tolerance
=
filterWidth
*
filterHeight
*
(
inputChannels
/
groups
)
*
2
;
return
tolerance
;
}
;
const
getGemmPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
shapeA
=
resources
.
inputs
[
Object
.
keys
(
resources
.
inputs
)
[
0
]
]
.
shape
;
const
options
=
{
.
.
.
resources
.
options
}
;
const
width
=
options
.
aTranspose
?
shapeA
[
0
]
:
shapeA
[
1
]
;
let
tolerance
=
width
*
2
;
if
(
options
.
alpha
!
=
=
undefined
&
&
options
.
alpha
!
=
=
1
.
0
)
{
tolerance
+
+
;
}
if
(
options
.
c
&
&
options
.
beta
!
=
=
0
.
0
)
{
if
(
options
.
beta
!
=
=
undefined
&
&
options
.
beta
!
=
=
1
.
0
)
{
tolerance
+
+
;
}
tolerance
+
+
;
}
return
tolerance
;
}
;
const
getMatmulPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
shapeA
=
resources
.
inputs
[
Object
.
keys
(
resources
.
inputs
)
[
0
]
]
.
shape
;
const
tolerance
=
shapeA
[
shapeA
.
length
-
1
]
*
2
;
return
tolerance
;
}
;
const
getAveragePool2dPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
inputShape
=
resources
.
inputs
[
Object
.
keys
(
resources
.
inputs
)
[
0
]
]
.
shape
;
let
height
;
let
width
;
const
options
=
{
.
.
.
resources
.
options
}
;
if
(
options
.
windowDimensions
)
{
height
=
options
.
windowDimensions
[
0
]
;
width
=
options
.
windowDimensions
[
1
]
;
}
else
{
if
(
options
.
layout
&
&
options
.
layout
=
=
=
'
nhwc
'
)
{
height
=
inputShape
[
1
]
;
width
=
inputShape
[
2
]
;
}
else
{
height
=
inputShape
[
2
]
;
width
=
inputShape
[
3
]
;
}
}
const
tolerance
=
height
*
width
+
2
;
return
tolerance
;
}
;
const
getSoftmaxPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
inputShape
=
resources
.
inputs
[
Object
.
keys
(
resources
.
inputs
)
[
0
]
]
.
shape
;
const
tolerance
=
inputShape
[
1
]
*
3
+
3
;
return
tolerance
;
}
;
const
getReductionPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
inputShape
=
resources
.
inputs
[
Object
.
keys
(
resources
.
inputs
)
[
0
]
]
.
shape
;
const
rank
=
inputShape
.
length
;
const
options
=
{
.
.
.
resources
.
options
}
;
let
sizes
;
if
(
options
&
&
options
.
axes
)
{
sizes
=
options
.
axes
.
map
(
(
axis
)
=
>
axis
<
0
?
inputShape
[
axis
+
rank
]
:
inputShape
[
axis
]
)
;
}
else
{
sizes
=
inputShape
;
}
const
reducedElementCount
=
sizes
.
length
?
sizes
.
reduce
(
(
accumulator
currentValue
)
=
>
accumulator
*
currentValue
)
:
1
;
let
tolerance
;
switch
(
operationName
)
{
case
'
reduceL1
'
:
case
'
reduceProduct
'
:
case
'
reduceSum
'
:
tolerance
=
reducedElementCount
;
break
;
case
'
reduceL2
'
:
tolerance
=
reducedElementCount
*
2
+
1
;
break
;
case
'
reduceMean
'
:
tolerance
=
reducedElementCount
+
2
;
break
;
case
'
reduceLogSum
'
:
tolerance
=
reducedElementCount
+
18
;
break
;
case
'
reduceLogSumExp
'
:
tolerance
=
reducedElementCount
*
2
+
18
;
break
;
case
'
reduceSumSquare
'
:
tolerance
=
reducedElementCount
*
2
;
break
;
default
:
break
;
}
return
tolerance
;
}
;
const
getResample2dPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
options
=
{
.
.
.
resources
.
options
}
;
let
tolerance
;
if
(
options
.
mode
&
&
options
.
mode
=
=
=
'
linear
'
)
{
const
precisionType
=
resources
.
expected
.
type
;
if
(
precisionType
=
=
=
'
float32
'
)
{
tolerance
=
84
;
}
else
if
(
precisionType
=
=
=
'
float16
'
)
{
tolerance
=
10
;
}
else
{
tolerance
=
1
;
}
}
else
{
tolerance
=
0
;
}
return
tolerance
;
}
;
const
PrecisionMetrics
=
{
argMax
:
{
ULP
:
{
int64
:
0
}
}
argMin
:
{
ULP
:
{
int64
:
0
}
}
batchNormalization
:
{
ULP
:
{
float32
:
6
float16
:
6
}
}
cast
:
{
ULP
:
{
float32
:
1
float16
:
1
int32
:
0
uint32
:
0
int64
:
0
int8
:
0
uint8
:
0
}
}
clamp
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
concat
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
constant
:
{
ULP
:
{
float32
:
2
float16
:
2
int32
:
0
uint32
:
0
int64
:
0
int8
:
0
uint8
:
0
}
}
conv2d
:
{
ULP
:
{
float32
:
getConv2dPrecisionTolerance
float16
:
getConv2dPrecisionTolerance
}
}
convTranspose2d
:
{
ULP
:
{
float32
:
getConv2dPrecisionTolerance
float16
:
getConv2dPrecisionTolerance
}
}
add
:
{
ULP
:
{
float32
:
1
float16
:
1
}
}
sub
:
{
ULP
:
{
float32
:
1
float16
:
1
}
}
mul
:
{
ULP
:
{
float32
:
1
float16
:
1
}
}
div
:
{
ULP
:
{
float32
:
2
float16
:
2
}
}
max
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
min
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
pow
:
{
ULP
:
{
float32
:
32
float16
:
2
}
}
equal
:
{
ULP
:
{
uint8
:
0
}
}
greater
:
{
ULP
:
{
uint8
:
0
}
}
greaterOrEqual
:
{
ULP
:
{
uint8
:
0
}
}
lesser
:
{
ULP
:
{
uint8
:
0
}
}
lesserOrEqual
:
{
ULP
:
{
uint8
:
0
}
}
logicalNot
:
{
ULP
:
{
uint8
:
0
}
}
abs
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
ceil
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
cos
:
{
ATOL
:
{
float32
:
1
/
1024
float16
:
1
/
512
}
}
erf
:
{
ATOL
:
{
float32
:
1
/
1024
float16
:
1
/
512
}
}
exp
:
{
ULP
:
{
float32
:
32
float16
:
1
}
}
floor
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
identity
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
log
:
{
ATOL
:
{
float32
:
1
/
1024
float16
:
1
/
1024
}
}
neg
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
reciprocal
:
{
ULP
:
{
float32
:
2
float16
:
2
}
}
sin
:
{
ATOL
:
{
float32
:
1
/
1024
float16
:
1
/
512
}
}
sqrt
:
{
ULP
:
{
float32
:
1
float16
:
1
}
}
tan
:
{
ATOL
:
{
float32
:
1
/
1024
float16
:
1
/
512
}
}
elu
:
{
ULP
:
{
float32
:
18
float16
:
18
}
}
expand
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
gather
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
gelu
:
{
ULP
:
{
float32
:
18
float16
:
18
}
}
gemm
:
{
ULP
:
{
float32
:
getGemmPrecisionTolerance
float16
:
getGemmPrecisionTolerance
}
}
instanceNormalization
:
{
ULP
:
{
float32
:
840
float16
:
8400
}
}
hardSigmoid
:
{
ULP
:
{
float32
:
2
float16
:
2
}
}
hardSwish
:
{
ULP
:
{
float32
:
4
float16
:
4
}
}
layerNormalization
:
{
ATOL
:
{
float32
:
1
/
1024
float16
:
1
/
512
}
}
leakyRelu
:
{
ULP
:
{
float32
:
1
float16
:
1
}
}
linear
:
{
ULP
:
{
float32
:
2
float16
:
2
}
}
matmul
:
{
ULP
:
{
float32
:
getMatmulPrecisionTolerance
float16
:
getMatmulPrecisionTolerance
}
}
pad
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
averagePool2d
:
{
ULP
:
{
float32
:
getAveragePool2dPrecisionTolerance
float16
:
getAveragePool2dPrecisionTolerance
}
}
l2Pool2d
:
{
ULP
:
{
float32
:
getAveragePool2dPrecisionTolerance
float16
:
getAveragePool2dPrecisionTolerance
}
}
maxPool2d
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
prelu
:
{
ULP
:
{
float32
:
1
float16
:
1
}
}
reduceL1
:
{
ULP
:
{
float32
:
getReductionPrecisionTolerance
float16
:
getReductionPrecisionTolerance
}
}
reduceL2
:
{
ULP
:
{
float32
:
getReductionPrecisionTolerance
float16
:
getReductionPrecisionTolerance
}
}
reduceLogSum
:
{
ULP
:
{
float32
:
getReductionPrecisionTolerance
float16
:
getReductionPrecisionTolerance
}
}
reduceLogSumExp
:
{
ULP
:
{
float32
:
getReductionPrecisionTolerance
float16
:
getReductionPrecisionTolerance
}
}
reduceMax
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
reduceMean
:
{
ULP
:
{
float32
:
getReductionPrecisionTolerance
float16
:
getReductionPrecisionTolerance
}
}
reduceMin
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
reduceProduct
:
{
ULP
:
{
float32
:
getReductionPrecisionTolerance
float16
:
getReductionPrecisionTolerance
}
}
reduceSum
:
{
ULP
:
{
float32
:
getReductionPrecisionTolerance
float16
:
getReductionPrecisionTolerance
}
}
reduceSumSquare
:
{
ULP
:
{
float32
:
getReductionPrecisionTolerance
float16
:
getReductionPrecisionTolerance
}
}
relu
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
resample2d
:
{
ULP
:
{
float32
:
getResample2dPrecisionTolerance
float16
:
getResample2dPrecisionTolerance
}
}
reshape
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
sigmoid
:
{
ULP
:
{
float32
:
32
+
2
float16
:
3
}
}
slice
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
softmax
:
{
ULP
:
{
float32
:
getSoftmaxPrecisionTolerance
float16
:
getSoftmaxPrecisionTolerance
}
}
softplus
:
{
ULP
:
{
float32
:
18
float16
:
18
}
}
softsign
:
{
ULP
:
{
float32
:
3
float16
:
3
}
}
split
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
tanh
:
{
ATOL
:
{
float32
:
1
/
1024
float16
:
1
/
512
}
}
transpose
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
triangular
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
where
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
}
;
const
getPrecisonTolerance
=
(
operationName
metricType
resources
)
=
>
{
const
precisionType
=
Array
.
isArray
(
resources
.
expected
)
?
resources
.
expected
[
0
]
.
type
:
resources
.
expected
.
type
;
let
tolerance
=
PrecisionMetrics
[
operationName
]
[
metricType
]
[
precisionType
]
;
if
(
tolerance
instanceof
Function
)
{
tolerance
=
tolerance
(
resources
operationName
)
;
}
return
tolerance
;
}
;
const
getBitwise
=
(
value
dataType
)
=
>
{
const
buffer
=
new
ArrayBuffer
(
8
)
;
const
int64Array
=
new
BigInt64Array
(
buffer
)
;
int64Array
[
0
]
=
value
<
0
?
~
BigInt
(
0
)
:
BigInt
(
0
)
;
let
typedArray
;
if
(
dataType
=
=
=
"
float32
"
)
{
typedArray
=
new
Float32Array
(
buffer
)
;
}
else
{
throw
new
AssertionError
(
Data
type
{
dataType
}
is
not
supported
)
;
}
typedArray
[
0
]
=
value
;
return
int64Array
[
0
]
;
}
;
const
assert_array_approx_equals_ulp
=
(
actual
expected
nulp
dataType
description
)
=
>
{
assert_true
(
actual
.
length
=
=
=
expected
.
length
assert_array_approx_equals_ulp
:
{
description
}
lengths
differ
expected
{
expected
.
length
}
but
got
{
actual
.
length
}
)
;
let
actualBitwise
expectedBitwise
distance
;
for
(
let
i
=
0
;
i
<
actual
.
length
;
i
+
+
)
{
if
(
actual
[
i
]
=
=
=
expected
[
i
]
)
{
continue
;
}
else
{
if
(
dataType
=
=
=
'
float32
'
)
{
actualBitwise
=
getBitwise
(
actual
[
i
]
dataType
)
;
expectedBitwise
=
getBitwise
(
expected
[
i
]
dataType
)
;
}
else
if
(
dataType
=
=
=
'
float16
'
)
{
actualBitwise
=
actual
[
i
]
;
expectedBitwise
=
toHalf
(
expected
[
i
]
)
;
}
else
if
(
dataType
=
=
=
'
int64
'
)
{
actualBitwise
=
actual
[
i
]
;
expectedBitwise
=
BigInt
(
expected
[
i
]
)
;
}
distance
=
actualBitwise
-
expectedBitwise
;
distance
=
distance
>
=
0
?
distance
:
-
distance
;
assert_true
(
distance
<
=
nulp
assert_array_approx_equals_ulp
:
{
description
}
actual
{
actual
[
i
]
}
should
be
close
enough
to
expected
{
expected
[
i
]
}
by
the
acceptable
{
nulp
}
ULP
distance
but
they
have
{
distance
}
ULP
distance
)
;
}
}
}
;
const
doAssert
=
(
operationName
actual
expected
tolerance
operandType
metricType
)
=
>
{
const
description
=
test
{
operationName
}
{
operandType
}
;
if
(
typeof
expected
=
=
=
'
number
'
)
{
expected
=
[
expected
]
;
actual
=
[
actual
]
;
}
if
(
metricType
=
=
=
'
ULP
'
)
{
assert_array_approx_equals_ulp
(
actual
expected
tolerance
operandType
description
)
;
}
else
if
(
metricType
=
=
=
'
ATOL
'
)
{
assert_array_approx_equals
(
actual
expected
tolerance
description
)
;
}
}
;
const
checkResults
=
(
operationName
namedOutputOperands
outputs
resources
)
=
>
{
const
metricType
=
Object
.
keys
(
PrecisionMetrics
[
operationName
]
)
[
0
]
;
const
expected
=
resources
.
expected
;
let
tolerance
;
let
operandType
;
let
outputData
;
let
expectedData
;
if
(
Array
.
isArray
(
expected
)
)
{
for
(
let
operandName
in
namedOutputOperands
)
{
const
suboutputResource
=
getNamedResource
(
expected
operandName
)
;
outputData
=
outputs
[
operandName
]
;
if
(
typeof
(
suboutputResource
.
data
)
=
=
=
'
number
'
&
&
suboutputResource
.
shape
&
&
sizeOfShape
(
suboutputResource
.
shape
)
>
1
)
{
const
size
=
Math
.
min
(
kMaximumIndexToValidate
sizeOfShape
(
suboutputResource
.
shape
)
)
;
suboutputResource
.
data
=
[
new
Array
(
size
)
.
fill
(
suboutputResource
.
data
)
suboutputResource
.
type
]
;
outputData
=
outputData
.
subarray
(
0
kMaximumIndexToValidate
)
;
}
assert_array_equals
(
namedOutputOperands
[
operandName
]
.
shape
(
)
suboutputResource
.
shape
?
?
[
]
)
;
tolerance
=
getPrecisonTolerance
(
operationName
metricType
resources
)
;
doAssert
(
operationName
outputData
suboutputResource
.
data
tolerance
suboutputResource
.
type
metricType
)
}
}
else
{
assert_array_equals
(
namedOutputOperands
[
expected
.
name
]
.
shape
(
)
expected
.
shape
?
?
[
]
)
;
outputData
=
outputs
[
expected
.
name
]
;
if
(
typeof
(
expected
.
data
)
=
=
=
'
number
'
&
&
expected
.
shape
&
&
sizeOfShape
(
expected
.
shape
)
>
1
)
{
const
size
=
Math
.
min
(
kMaximumIndexToValidate
sizeOfShape
(
expected
.
shape
)
)
;
expected
.
data
=
new
Array
(
size
)
.
fill
(
expected
.
data
)
;
outputData
=
outputData
.
subarray
(
0
kMaximumIndexToValidate
)
;
}
expectedData
=
expected
.
data
;
operandType
=
expected
.
type
;
tolerance
=
getPrecisonTolerance
(
operationName
metricType
resources
)
;
doAssert
(
operationName
outputData
expectedData
tolerance
operandType
metricType
)
}
}
;
const
createConstantOperand
=
(
builder
resources
)
=
>
{
const
bufferView
=
(
typeof
(
resources
.
data
)
=
=
=
'
number
'
&
&
sizeOfShape
(
resources
.
shape
)
>
1
)
?
new
TypedArrayDict
[
resources
.
type
]
(
sizeOfShape
(
resources
.
shape
)
)
.
fill
(
resources
.
data
)
:
new
TypedArrayDict
[
resources
.
type
]
(
resources
.
data
)
;
return
builder
.
constant
(
{
dataType
:
resources
.
type
type
:
resources
.
type
dimensions
:
resources
.
shape
}
bufferView
)
;
}
;
const
createSingleInputOperand
=
(
builder
resources
inputOperandName
)
=
>
{
inputOperandName
=
inputOperandName
?
inputOperandName
:
Object
.
keys
(
resources
.
inputs
)
[
0
]
;
const
inputResources
=
resources
.
inputs
[
inputOperandName
]
;
let
operand
;
if
(
resources
.
inputs
[
inputOperandName
]
.
hasOwnProperty
(
'
constant
'
)
&
&
resources
.
inputs
[
inputOperandName
]
[
'
constant
'
]
)
{
operand
=
createConstantOperand
(
builder
resources
.
inputs
[
inputOperandName
]
)
;
}
else
{
operand
=
builder
.
input
(
inputOperandName
{
dataType
:
inputResources
.
type
type
:
inputResources
.
type
dimensions
:
inputResources
.
shape
}
)
;
}
return
operand
;
}
;
const
createMultiInputOperands
=
(
builder
resources
)
=
>
{
let
inputOperands
=
[
]
;
const
inputOperandNameArray
=
Object
.
keys
(
resources
.
inputs
)
;
inputOperandNameArray
.
forEach
(
inputOperandName
=
>
{
const
operand
=
createSingleInputOperand
(
builder
resources
inputOperandName
)
;
inputOperands
.
push
(
operand
)
;
}
)
;
return
inputOperands
;
}
;
const
buildOperationWithSingleInput
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
inputOperand
=
createSingleInputOperand
(
builder
resources
)
;
const
outputOperand
=
resources
.
options
?
builder
[
operationName
]
(
inputOperand
resources
.
options
)
:
builder
[
operationName
]
(
inputOperand
)
;
namedOutputOperand
[
resources
.
expected
.
name
]
=
outputOperand
;
return
namedOutputOperand
;
}
;
const
buildOperationWithTwoInputs
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
[
inputOperandA
inputOperandB
]
=
createMultiInputOperands
(
builder
resources
)
;
const
outputOperand
=
resources
.
options
?
builder
[
operationName
]
(
inputOperandA
inputOperandB
resources
.
options
)
:
builder
[
operationName
]
(
inputOperandA
inputOperandB
)
;
namedOutputOperand
[
resources
.
expected
.
name
]
=
outputOperand
;
return
namedOutputOperand
;
}
;
const
buildBatchNorm
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
[
inputOperand
meanOperand
varianceOperand
]
=
createMultiInputOperands
(
builder
resources
)
;
const
batchNormOptions
=
{
.
.
.
resources
.
options
}
;
if
(
batchNormOptions
.
scale
)
{
batchNormOptions
.
scale
=
createConstantOperand
(
builder
batchNormOptions
.
scale
)
;
}
if
(
batchNormOptions
.
bias
)
{
batchNormOptions
.
bias
=
createConstantOperand
(
builder
batchNormOptions
.
bias
)
;
}
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
inputOperand
meanOperand
varianceOperand
batchNormOptions
)
;
return
namedOutputOperand
;
}
;
const
buildCast
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
inputOperand
=
createSingleInputOperand
(
builder
resources
)
;
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
inputOperand
resources
.
type
)
;
return
namedOutputOperand
;
}
;
const
buildConcat
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
inputOperands
=
[
]
;
let
operand
;
for
(
let
input
of
resources
.
inputs
)
{
if
(
input
.
hasOwnProperty
(
'
constant
'
)
&
&
input
[
'
constant
'
]
)
{
operand
=
createConstantOperand
(
builder
input
)
;
}
else
{
operand
=
builder
.
input
(
input
.
name
{
dataType
:
input
.
type
type
:
input
.
type
dimensions
:
input
.
shape
}
)
;
}
inputOperands
.
push
(
operand
)
;
}
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
inputOperands
resources
.
axis
)
;
return
namedOutputOperand
;
}
;
const
buildConstantRange
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
resources
.
inputs
.
start
resources
.
inputs
.
step
resources
.
outputShape
resources
.
type
)
;
return
namedOutputOperand
;
}
;
const
buildConvTranspose2d
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
[
inputOperand
filterOperand
]
=
createMultiInputOperands
(
builder
resources
)
;
let
convTranspose2dOptions
=
{
.
.
.
resources
.
options
}
;
if
(
convTranspose2dOptions
.
bias
)
{
convTranspose2dOptions
.
bias
=
createConstantOperand
(
builder
convTranspose2dOptions
.
bias
)
;
}
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
inputOperand
filterOperand
convTranspose2dOptions
)
;
return
namedOutputOperand
;
}
;
const
buildConv2d
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
[
inputOperand
filterOperand
]
=
createMultiInputOperands
(
builder
resources
)
;
let
conv2dOptions
=
{
.
.
.
resources
.
options
}
;
if
(
conv2dOptions
.
bias
)
{
conv2dOptions
.
bias
=
createConstantOperand
(
builder
conv2dOptions
.
bias
)
;
}
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
inputOperand
filterOperand
conv2dOptions
)
;
return
namedOutputOperand
;
}
;
const
buildGemm
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
[
inputOperandA
inputOperandB
]
=
createMultiInputOperands
(
builder
resources
)
;
let
gemmOptions
=
{
.
.
.
resources
.
options
}
;
if
(
gemmOptions
.
c
)
{
if
(
gemmOptions
.
c
.
shape
)
{
gemmOptions
.
c
=
createConstantOperand
(
builder
gemmOptions
.
c
)
;
}
else
{
gemmOptions
.
c
=
builder
.
constant
(
{
dataType
:
'
float32
'
type
:
'
float32
'
dimensions
:
[
1
]
}
new
Float32Array
(
[
gemmOptions
.
c
]
)
)
;
}
}
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
inputOperandA
inputOperandB
gemmOptions
)
;
return
namedOutputOperand
;
}
;
const
buildLayerNorm
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
inputOperand
=
createSingleInputOperand
(
builder
resources
)
;
const
layerNormOptions
=
{
.
.
.
resources
.
options
}
;
if
(
layerNormOptions
.
scale
)
{
layerNormOptions
.
scale
=
createConstantOperand
(
builder
layerNormOptions
.
scale
)
;
}
if
(
layerNormOptions
.
bias
)
{
layerNormOptions
.
bias
=
createConstantOperand
(
builder
layerNormOptions
.
bias
)
;
}
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
inputOperand
layerNormOptions
)
;
return
namedOutputOperand
;
}
;
const
buildPad
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
inputOperand
=
createSingleInputOperand
(
builder
resources
)
;
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
inputOperand
resources
.
beginningPadding
resources
.
endingPadding
resources
.
options
)
;
return
namedOutputOperand
;
}
;
const
buildReshape
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
inputOperand
=
createSingleInputOperand
(
builder
resources
)
;
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
inputOperand
resources
.
newShape
)
;
return
namedOutputOperand
;
}
;
const
buildSlice
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
inputOperand
=
createSingleInputOperand
(
builder
resources
)
;
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
inputOperand
resources
.
starts
resources
.
sizes
)
;
return
namedOutputOperand
;
}
;
const
buildSoftmax
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
inputOperand
=
createSingleInputOperand
(
builder
resources
)
;
if
(
resources
.
axis
!
=
=
undefined
)
{
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
inputOperand
resources
.
axis
)
;
}
else
{
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
inputOperand
)
;
}
return
namedOutputOperand
;
}
;
const
buildSplit
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
inputOperand
=
createSingleInputOperand
(
builder
resources
)
;
const
outputOperands
=
builder
[
operationName
]
(
inputOperand
resources
.
splits
resources
.
options
)
;
resources
.
expected
.
forEach
(
(
resourceDict
index
)
=
>
{
namedOutputOperand
[
resourceDict
.
name
]
=
outputOperands
[
index
]
;
}
)
;
return
namedOutputOperand
;
}
;
const
buildWhere
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
[
conditionOperand
trueValuesOperand
falseValuesOperand
]
=
createMultiInputOperands
(
builder
resources
)
;
namedOutputOperand
[
resources
.
expected
.
name
]
=
builder
[
operationName
]
(
conditionOperand
trueValuesOperand
falseValuesOperand
)
;
return
namedOutputOperand
;
}
;
const
buildGraph
=
(
operationName
builder
resources
buildFunc
)
=
>
{
const
namedOperands
=
buildFunc
(
operationName
builder
resources
)
;
let
inputs
=
{
}
;
if
(
Array
.
isArray
(
resources
.
inputs
)
)
{
for
(
let
subInput
of
resources
.
inputs
)
{
if
(
!
subInput
.
hasOwnProperty
(
'
constant
'
)
|
|
!
subInput
.
constant
)
{
inputs
[
subInput
.
name
]
=
getTypedArrayData
(
subInput
.
type
sizeOfShape
(
subInput
.
shape
)
subInput
.
data
)
;
}
}
}
else
{
for
(
let
inputName
in
resources
.
inputs
)
{
const
subTestByName
=
resources
.
inputs
[
inputName
]
;
if
(
!
subTestByName
.
hasOwnProperty
(
'
constant
'
)
|
|
!
subTestByName
.
constant
)
{
inputs
[
inputName
]
=
getTypedArrayData
(
subTestByName
.
type
sizeOfShape
(
subTestByName
.
shape
)
subTestByName
.
data
)
;
}
}
}
let
outputs
=
{
}
;
if
(
Array
.
isArray
(
resources
.
expected
)
)
{
for
(
let
i
=
0
;
i
<
resources
.
expected
.
length
;
i
+
+
)
{
const
subExpected
=
resources
.
expected
[
i
]
;
outputs
[
subExpected
.
name
]
=
new
TypedArrayDict
[
subExpected
.
type
]
(
sizeOfShape
(
subExpected
.
shape
)
)
;
}
}
else
{
const
shape
=
resources
.
expected
.
shape
?
resources
.
expected
.
shape
:
[
1
]
;
outputs
[
resources
.
expected
.
name
]
=
new
TypedArrayDict
[
resources
.
expected
.
type
]
(
sizeOfShape
(
shape
)
)
;
}
return
[
namedOperands
inputs
outputs
]
;
}
;
const
run
=
async
(
operationName
context
builder
resources
buildFunc
)
=
>
{
const
[
namedOutputOperands
inputs
outputs
]
=
buildGraph
(
operationName
builder
resources
buildFunc
)
;
const
graph
=
await
builder
.
build
(
namedOutputOperands
)
;
const
result
=
await
context
.
compute
(
graph
inputs
outputs
)
;
checkResults
(
operationName
namedOutputOperands
result
.
outputs
resources
)
;
}
;
const
variant
=
location
.
search
.
substring
(
1
)
;
const
contextOptions
=
kContextOptionsForVariant
[
variant
]
;
const
isMLBufferSupported
=
(
ml_context
)
=
>
{
return
(
createBuffer
(
ml_context
{
dataType
:
'
int32
'
dimensions
:
[
2
2
]
}
)
!
=
=
undefined
)
;
}
const
testWebNNOperation
=
(
operationName
buildFunc
)
=
>
{
let
operationNameArray
;
if
(
typeof
operationName
=
=
=
'
string
'
)
{
operationNameArray
=
[
operationName
]
;
}
else
if
(
Array
.
isArray
(
operationName
)
)
{
operationNameArray
=
operationName
;
}
let
context
;
let
builder
;
operationNameArray
.
forEach
(
(
subOperationName
)
=
>
{
const
tests
=
loadTests
(
subOperationName
)
;
promise_setup
(
async
(
)
=
>
{
let
supported
=
false
;
try
{
context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
supported
=
true
;
}
catch
(
e
)
{
}
assert_implements
(
supported
Unable
to
create
context
for
{
variant
}
variant
)
;
builder
=
new
MLGraphBuilder
(
context
)
;
}
)
;
for
(
const
subTest
of
tests
)
{
promise_test
(
async
(
)
=
>
{
await
run
(
subOperationName
context
builder
subTest
buildFunc
)
;
}
{
subTest
.
name
}
)
;
}
}
)
;
}
;
const
testParallelCompute
=
(
)
=
>
{
let
ml_context
;
let
ml_graph
;
promise_setup
(
async
(
)
=
>
{
let
supported
=
false
;
try
{
ml_context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
supported
=
true
;
}
catch
(
e
)
{
}
assert_implements
(
supported
Unable
to
create
context
for
{
variant
}
variant
)
;
const
builder
=
new
MLGraphBuilder
(
ml_context
)
;
const
operandType
=
{
dataType
:
'
float32
'
dimensions
:
[
1
]
}
;
const
input_operand
=
builder
.
input
(
'
input
'
operandType
)
;
const
const_operand
=
builder
.
constant
(
operandType
Float32Array
.
from
(
[
2
]
)
)
;
const
output_operand
=
builder
.
mul
(
input_operand
const_operand
)
;
ml_graph
=
await
builder
.
build
(
{
'
output
'
:
output_operand
}
)
;
}
)
;
promise_test
(
async
(
)
=
>
{
const
test_inputs
=
[
1
2
3
4
]
;
const
actual_outputs
=
await
Promise
.
all
(
test_inputs
.
map
(
async
(
input
)
=
>
{
let
inputs
=
{
'
input
'
:
Float32Array
.
from
(
[
input
]
)
}
;
let
outputs
=
{
'
output
'
:
new
Float32Array
(
1
)
}
;
(
{
inputs
outputs
}
=
await
ml_context
.
compute
(
ml_graph
inputs
outputs
)
)
;
return
outputs
.
output
[
0
]
;
}
)
)
;
const
expected_outputs
=
[
2
4
6
8
]
;
assert_array_equals
(
actual_outputs
expected_outputs
)
;
}
)
;
}
;
const
runWebNNConformanceTests
=
(
operationName
buildFunc
)
=
>
{
if
(
navigator
.
ml
)
{
testWebNNOperation
(
operationName
buildFunc
)
;
}
else
{
test
(
(
)
=
>
assert_not_equals
(
navigator
.
ml
undefined
'
ml
property
is
defined
on
navigator
'
)
)
;
}
}
;
const
toHalf
=
(
value
)
=
>
{
let
floatView
=
new
Float32Array
(
1
)
;
let
int32View
=
new
Int32Array
(
floatView
.
buffer
)
;
floatView
[
0
]
=
value
;
let
x
=
int32View
[
0
]
;
let
bits
=
(
x
>
>
16
)
&
0x8000
;
let
m
=
(
x
>
>
12
)
&
0x07ff
;
let
e
=
(
x
>
>
23
)
&
0xff
;
if
(
e
<
103
)
{
return
bits
;
}
if
(
e
>
142
)
{
bits
|
=
0x7c00
;
bits
|
=
(
(
e
=
=
255
)
?
0
:
1
)
&
&
(
x
&
0x007fffff
)
;
return
bits
;
}
if
(
e
<
113
)
{
m
|
=
0x0800
;
bits
|
=
(
m
>
>
(
114
-
e
)
)
+
(
(
m
>
>
(
113
-
e
)
)
&
1
)
;
return
bits
;
}
bits
|
=
(
(
e
-
112
)
<
<
10
)
|
(
m
>
>
1
)
;
bits
+
=
m
&
1
;
return
bits
;
}
;
const
createBuffer
=
(
context
bufferDescriptor
)
=
>
{
let
buffer
;
try
{
buffer
=
context
.
createBuffer
(
bufferDescriptor
)
;
assert_equals
(
buffer
.
dataType
bufferDescriptor
.
dataType
'
buffer
data
types
do
not
match
'
)
;
assert_array_equals
(
buffer
.
shape
bufferDescriptor
.
dimensions
'
buffer
shapes
do
not
match
'
)
;
}
catch
(
e
)
{
assert_true
(
e
instanceof
DOMException
)
;
assert_equals
(
e
.
name
"
NotSupportedError
"
)
;
}
return
buffer
;
}
;
const
testDestroyWebNNBuffer
=
(
testName
)
=
>
{
let
context
;
let
buffer
;
promise_setup
(
async
(
)
=
>
{
let
supported
=
false
;
try
{
context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
supported
=
true
;
}
catch
(
e
)
{
}
assert_implements
(
supported
Unable
to
create
context
for
{
variant
}
variant
)
;
buffer
=
createBuffer
(
context
{
dataType
:
'
int32
'
dimensions
:
[
2
3
]
}
)
;
}
)
;
promise_test
(
async
(
)
=
>
{
if
(
buffer
=
=
=
undefined
)
{
return
;
}
buffer
.
destroy
(
)
;
buffer
.
destroy
(
)
;
}
{
testName
}
)
;
}
;
const
testCreateWebNNBuffer
=
(
testName
bufferDescriptor
)
=
>
{
let
context
;
promise_setup
(
async
(
)
=
>
{
let
supported
=
false
;
try
{
context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
supported
=
true
;
}
catch
(
e
)
{
}
assert_implements
(
supported
Unable
to
create
context
for
{
variant
}
variant
)
;
}
)
;
promise_test
(
async
(
)
=
>
{
createBuffer
(
context
bufferDescriptor
)
;
}
{
testName
}
/
{
bufferDescriptor
.
dataType
}
)
;
}
;
const
testCreateWebNNBufferFails
=
(
testName
bufferDescriptor
)
=
>
{
let
context
;
promise_setup
(
async
(
)
=
>
{
let
supported
=
false
;
try
{
context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
supported
=
true
;
}
catch
(
e
)
{
}
assert_implements
(
supported
Unable
to
create
context
for
{
variant
}
variant
)
;
}
)
;
promise_test
(
async
(
)
=
>
{
assert_throws_js
(
TypeError
(
)
=
>
context
.
createBuffer
(
bufferDescriptor
)
)
;
}
{
testName
}
/
{
bufferDescriptor
.
dataType
}
)
;
}
;
const
assert_buffer_data_equals
=
async
(
ml_context
ml_buffer
expected
)
=
>
{
const
actual
=
await
ml_context
.
readBuffer
(
ml_buffer
)
;
assert_array_equals
(
new
expected
.
constructor
(
actual
)
expected
'
Read
buffer
data
equals
expected
data
.
'
)
;
}
;
const
testWriteWebNNBuffer
=
(
testName
)
=
>
{
let
ml_context
;
promise_setup
(
async
(
)
=
>
{
let
supported
=
false
;
try
{
ml_context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
supported
=
true
;
}
catch
(
e
)
{
}
assert_implements
(
supported
Unable
to
create
context
for
{
variant
}
variant
)
;
}
)
;
promise_test
(
async
(
)
=
>
{
const
descriptor
=
{
dataType
:
'
int32
'
dimensions
:
[
1
]
}
;
let
ml_buffer
=
createBuffer
(
ml_context
descriptor
)
;
if
(
ml_buffer
=
=
=
undefined
)
{
return
;
}
const
bufferByteLength
=
sizeOfDescriptor
(
descriptor
)
;
let
array_buffer
=
new
ArrayBuffer
(
bufferByteLength
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
writeBuffer
(
ml_buffer
new
Uint8Array
(
array_buffer
)
0
bufferByteLength
+
1
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
writeBuffer
(
ml_buffer
new
Uint8Array
(
array_buffer
)
3
bufferByteLength
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
writeBuffer
(
ml_buffer
new
Uint8Array
(
array_buffer
)
bufferByteLength
+
1
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
writeBuffer
(
ml_buffer
new
Uint8Array
(
array_buffer
)
bufferByteLength
+
1
undefined
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
writeBuffer
(
ml_buffer
new
Uint8Array
(
array_buffer
)
undefined
bufferByteLength
+
1
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
writeBuffer
(
ml_buffer
Uint8Array
.
from
(
[
0xEE
0xEE
0xEE
0xEE
0xEE
]
)
)
)
;
}
{
testName
}
/
error
)
;
promise_test
(
async
(
)
=
>
{
const
descriptor
=
{
dataType
:
'
int32
'
dimensions
:
[
2
2
]
}
;
let
ml_buffer
=
createBuffer
(
ml_context
descriptor
)
;
if
(
ml_buffer
=
=
=
undefined
)
{
return
;
}
ml_buffer
.
destroy
(
)
;
assert_throws_dom
(
'
InvalidStateError
'
(
)
=
>
ml_context
.
writeBuffer
(
ml_buffer
new
Uint8Array
(
sizeOfDescriptor
(
descriptor
)
)
)
)
;
}
{
testName
}
/
destroy
)
;
promise_test
(
async
(
)
=
>
{
const
descriptor
=
{
dataType
:
'
int32
'
dimensions
:
[
2
2
]
}
;
let
ml_buffer
=
createBuffer
(
ml_context
descriptor
)
;
if
(
ml_buffer
=
=
=
undefined
)
{
return
;
}
const
array_buffer
=
new
ArrayBuffer
(
sizeOfDescriptor
(
descriptor
)
)
;
const
detached_buffer
=
array_buffer
.
transfer
(
)
;
assert_true
(
array_buffer
.
detached
'
array
buffer
should
be
detached
.
'
)
;
ml_context
.
writeBuffer
(
ml_buffer
array_buffer
)
;
}
{
testName
}
/
detached
)
;
promise_test
(
async
(
)
=
>
{
const
bufferDescriptor
=
{
dataType
:
'
int32
'
dimensions
:
[
2
3
]
}
;
let
ml_buffer
=
createBuffer
(
ml_context
bufferDescriptor
)
;
if
(
ml_buffer
=
=
=
undefined
)
{
return
;
}
let
another_ml_context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
let
another_ml_buffer
=
createBuffer
(
another_ml_context
bufferDescriptor
)
;
let
input_data
=
new
Uint8Array
(
sizeOfDescriptor
(
bufferDescriptor
)
)
.
fill
(
0xAA
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
writeBuffer
(
another_ml_buffer
input_data
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
another_ml_context
.
writeBuffer
(
ml_buffer
input_data
)
)
;
}
{
testName
}
/
context_mismatch
)
;
}
;
const
testReadWebNNBuffer
=
(
testName
)
=
>
{
let
ml_context
;
promise_setup
(
async
(
)
=
>
{
let
supported
=
false
;
try
{
ml_context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
supported
=
true
;
}
catch
(
e
)
{
}
assert_implements
(
supported
Unable
to
create
context
for
{
variant
}
variant
)
;
}
)
;
promise_test
(
async
t
=
>
{
let
ml_buffer
=
createBuffer
(
ml_context
{
dataType
:
'
int32
'
dimensions
:
[
2
2
]
}
)
;
if
(
ml_buffer
=
=
=
undefined
)
{
return
;
}
ml_buffer
.
destroy
(
)
;
await
promise_rejects_dom
(
t
'
InvalidStateError
'
ml_context
.
readBuffer
(
ml_buffer
)
)
;
}
{
testName
}
/
destroy
)
;
promise_test
(
async
(
)
=
>
{
let
ml_buffer
=
createBuffer
(
ml_context
{
dataType
:
'
int32
'
dimensions
:
[
1
]
}
)
;
if
(
ml_buffer
=
=
=
undefined
)
{
return
;
}
ml_context
.
writeBuffer
(
ml_buffer
Uint8Array
.
from
(
[
0xAA
0xAA
0xAA
0xAA
]
)
)
;
ml_context
.
writeBuffer
(
ml_buffer
Uint32Array
.
from
(
[
0xBBBBBBBB
]
)
)
;
await
assert_buffer_data_equals
(
ml_context
ml_buffer
Uint32Array
.
from
(
[
0xBBBBBBBB
]
)
)
;
;
}
{
testName
}
/
full_size
)
;
promise_test
(
async
(
)
=
>
{
let
ml_buffer
=
createBuffer
(
ml_context
{
dataType
:
'
int32
'
dimensions
:
[
1
]
}
)
;
if
(
ml_buffer
=
=
=
undefined
)
{
return
;
}
ml_context
.
writeBuffer
(
ml_buffer
Uint8Array
.
from
(
[
0xAA
0xAA
0xAA
0xAA
]
)
)
;
ml_context
.
writeBuffer
(
ml_buffer
Uint8Array
.
from
(
[
0xCC
0xCC
0xBB
0xBB
]
)
2
)
;
await
assert_buffer_data_equals
(
ml_context
ml_buffer
Uint8Array
.
from
(
[
0xBB
0xBB
0xAA
0xAA
]
)
)
;
}
{
testName
}
/
src_offset_only
)
;
promise_test
(
async
(
)
=
>
{
let
ml_buffer
=
createBuffer
(
ml_context
{
dataType
:
'
int32
'
dimensions
:
[
1
]
}
)
;
if
(
ml_buffer
=
=
=
undefined
)
{
return
;
}
const
input_data
=
[
0xAA
0xAA
0xAA
0xAA
]
;
ml_context
.
writeBuffer
(
ml_buffer
Uint8Array
.
from
(
input_data
)
)
;
ml_context
.
writeBuffer
(
ml_buffer
Uint32Array
.
from
(
[
0xBBBBBBBB
]
)
1
)
;
await
assert_buffer_data_equals
(
ml_context
ml_buffer
Uint8Array
.
from
(
input_data
)
)
;
}
{
testName
}
/
zero_write
)
;
promise_test
(
async
(
)
=
>
{
let
ml_buffer
=
createBuffer
(
ml_context
{
dataType
:
'
int32
'
dimensions
:
[
1
]
}
)
;
if
(
ml_buffer
=
=
=
undefined
)
{
return
;
}
ml_context
.
writeBuffer
(
ml_buffer
Uint8Array
.
from
(
[
0xAA
0xAA
0xAA
0xAA
]
)
)
;
ml_context
.
writeBuffer
(
ml_buffer
Uint8Array
.
from
(
[
0xDD
0xDD
0xCC
0xDD
]
)
2
1
)
;
await
assert_buffer_data_equals
(
ml_context
ml_buffer
Uint8Array
.
from
(
[
0xCC
0xAA
0xAA
0xAA
]
)
)
;
}
{
testName
}
/
src_offset_and_size
)
;
promise_test
(
async
(
)
=
>
{
let
ml_buffer
=
createBuffer
(
ml_context
{
dataType
:
'
int32
'
dimensions
:
[
1
]
}
)
;
if
(
ml_buffer
=
=
=
undefined
)
{
return
;
}
ml_context
.
writeBuffer
(
ml_buffer
Uint8Array
.
from
(
[
0xAA
0xAA
0xAA
0xAA
]
)
)
;
ml_context
.
writeBuffer
(
ml_buffer
Uint8Array
.
from
(
[
0xEE
0xEE
0xEE
0xEE
0xEE
]
)
1
)
;
await
assert_buffer_data_equals
(
ml_context
ml_buffer
Uint8Array
.
from
(
[
0xEE
0xEE
0xEE
0xEE
]
)
)
;
}
{
testName
}
/
larger_src_data
)
;
promise_test
(
async
(
)
=
>
{
let
ml_buffer
=
createBuffer
(
ml_context
{
dataType
:
'
int32
'
dimensions
:
[
1
]
}
)
;
if
(
ml_buffer
=
=
=
undefined
)
{
return
;
}
const
input_data
=
[
0xAA
0xAA
0xAA
0xAA
]
;
ml_context
.
writeBuffer
(
ml_buffer
Uint8Array
.
from
(
input_data
)
undefined
input_data
.
length
)
;
await
assert_buffer_data_equals
(
ml_context
ml_buffer
Uint8Array
.
from
(
input_data
)
)
;
}
{
testName
}
/
no_src_offset
)
;
promise_test
(
async
t
=
>
{
const
bufferDescriptor
=
{
dataType
:
'
int32
'
dimensions
:
[
2
3
]
}
;
let
ml_buffer
=
createBuffer
(
ml_context
bufferDescriptor
)
;
if
(
ml_buffer
=
=
=
undefined
)
{
return
;
}
let
another_ml_context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
let
another_ml_buffer
=
createBuffer
(
another_ml_context
bufferDescriptor
)
;
await
promise_rejects_js
(
t
TypeError
ml_context
.
readBuffer
(
another_ml_buffer
)
)
;
await
promise_rejects_js
(
t
TypeError
another_ml_context
.
readBuffer
(
ml_buffer
)
)
;
}
{
testName
}
/
context_mismatch
)
;
}
;
const
testDispatchWebNNBuffer
=
(
testName
)
=
>
{
let
ml_context
;
let
ml_graph
;
const
shape
=
[
3
5
]
;
let
inputs
=
{
}
;
let
outputs
=
{
}
;
promise_setup
(
async
(
)
=
>
{
let
supported
=
false
;
try
{
ml_context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
supported
=
true
;
}
catch
(
e
)
{
}
assert_implements
(
supported
Unable
to
create
context
for
{
variant
}
variant
)
;
const
builder
=
new
MLGraphBuilder
(
ml_context
)
;
const
descriptor
=
{
dataType
:
'
float32
'
dimensions
:
shape
}
;
const
lhs_operand
=
builder
.
input
(
'
lhs
'
descriptor
)
;
const
rhs_operand
=
builder
.
input
(
'
rhs
'
descriptor
)
;
const
output_1_operand
=
builder
.
add
(
lhs_operand
rhs_operand
)
;
const
output_2_operand
=
builder
.
add
(
lhs_operand
rhs_operand
)
;
ml_graph
=
await
builder
.
build
(
{
'
output1
'
:
output_1_operand
'
output2
'
:
output_2_operand
}
)
;
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
inputs
=
{
'
lhs
'
:
ml_context
.
createBuffer
(
descriptor
)
'
rhs
'
:
ml_context
.
createBuffer
(
descriptor
)
}
;
outputs
=
{
'
output1
'
:
ml_context
.
createBuffer
(
descriptor
)
'
output2
'
:
ml_context
.
createBuffer
(
descriptor
)
}
;
}
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
let
another_ml_context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
ml_context
.
dispatch
(
ml_graph
inputs
outputs
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
{
'
lhs
'
:
another_ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
lhs
'
]
)
)
'
rhs
'
:
inputs
[
'
rhs
'
]
}
outputs
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
inputs
{
'
output1
'
:
another_ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output1
'
]
)
)
'
output2
'
:
outputs
[
'
output2
'
]
}
)
)
;
}
{
testName
}
/
context_mismatch
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
ml_context
.
dispatch
(
ml_graph
inputs
outputs
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
{
'
lhs
'
:
ml_context
.
createBuffer
(
{
dataType
:
inputs
[
'
lhs
'
]
.
dataType
dimensions
:
inputs
[
'
lhs
'
]
.
shape
.
concat
(
[
2
]
)
}
)
'
rhs
'
:
inputs
[
'
rhs
'
]
}
outputs
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
{
'
lhs
'
:
inputs
[
'
lhs
'
]
'
rhs
'
:
ml_context
.
createBuffer
(
{
dataType
:
inputs
[
'
rhs
'
]
.
dataType
dimensions
:
inputs
[
'
rhs
'
]
.
shape
.
slice
(
1
)
}
)
}
outputs
)
)
;
let
output1WrongShape
=
[
.
.
.
outputs
[
'
output1
'
]
.
shape
]
;
output1WrongShape
[
0
]
+
=
2
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
inputs
{
'
output1
'
:
ml_context
.
createBuffer
(
{
dataType
:
outputs
[
'
output1
'
]
.
dataType
dimensions
:
output1WrongShape
}
)
'
output2
'
:
outputs
[
'
output2
'
]
}
)
)
;
let
output2WrongShape
=
[
.
.
.
outputs
[
'
output2
'
]
.
shape
]
;
output2WrongShape
[
1
]
-
=
1
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
inputs
{
'
output1
'
:
outputs
[
'
output1
'
]
'
output2
'
:
ml_context
.
createBuffer
(
{
dataType
:
outputs
[
'
output2
'
]
.
dataType
dimensions
:
output2WrongShape
}
)
}
)
)
;
}
{
testName
}
/
invalid
shape
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
ml_context
.
dispatch
(
ml_graph
inputs
outputs
)
;
const
inputWrongDataType
=
'
int32
'
;
assert_not_equals
(
inputs
[
'
lhs
'
]
.
dataType
inputWrongDataType
)
;
assert_not_equals
(
inputs
[
'
rhs
'
]
.
dataType
inputWrongDataType
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
{
'
lhs
'
:
ml_context
.
createBuffer
(
{
dataType
:
inputWrongDataType
dimensions
:
inputs
[
'
lhs
'
]
.
shape
}
)
'
rhs
'
:
inputs
[
'
rhs
'
]
}
outputs
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
{
'
lhs
'
:
inputs
[
'
lhs
'
]
'
rhs
'
:
ml_context
.
createBuffer
(
{
dataType
:
inputWrongDataType
dimensions
:
inputs
[
'
rhs
'
]
.
shape
}
)
}
outputs
)
)
;
const
outputWrongDataType
=
'
int32
'
;
assert_not_equals
(
outputs
[
'
output1
'
]
.
dataType
outputWrongDataType
)
;
assert_not_equals
(
outputs
[
'
output2
'
]
.
dataType
outputWrongDataType
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
inputs
{
'
output1
'
:
ml_context
.
createBuffer
(
{
dataType
:
outputWrongDataType
dimensions
:
outputs
[
'
output1
'
]
.
shape
}
)
'
output2
'
:
outputs
[
'
output2
'
]
}
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
inputs
{
'
output1
'
:
outputs
[
'
output1
'
]
'
output2
'
:
ml_context
.
createBuffer
(
{
dataType
:
outputWrongDataType
dimensions
:
outputs
[
'
output2
'
]
.
shape
}
)
}
)
)
;
}
{
testName
}
/
invalid
data
type
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
ml_context
.
dispatch
(
ml_graph
inputs
outputs
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
{
}
{
}
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
{
'
a_different_input_name
'
:
inputs
[
'
lhs
'
]
'
rhs
'
:
inputs
[
'
rhs
'
]
}
outputs
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
{
'
lhs
'
:
inputs
[
'
lhs
'
]
'
a_different_input_name
'
:
inputs
[
'
rhs
'
]
}
outputs
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
inputs
{
'
a_different_output_name
'
:
outputs
[
'
output1
'
]
'
output2
'
:
outputs
[
'
output2
'
]
}
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
inputs
{
'
output1
'
:
outputs
[
'
output1
'
]
'
a_different_output_name
'
:
outputs
[
'
output2
'
]
}
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
{
'
lhs
'
:
inputs
[
'
lhs
'
]
}
outputs
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
{
'
lhs
'
:
inputs
[
'
lhs
'
]
'
rhs
'
:
inputs
[
'
rhs
'
]
'
a_different_input_name
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
rhs
'
]
)
)
}
outputs
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
inputs
{
'
output1
'
:
outputs
[
'
output1
'
]
}
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
inputs
{
'
output1
'
:
outputs
[
'
output1
'
]
'
output2
'
:
outputs
[
'
output2
'
]
'
a_different_output_name
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output2
'
]
)
)
}
)
)
;
}
{
testName
}
/
invalid_name
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
ml_context
.
dispatch
(
ml_graph
inputs
outputs
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
inputs
{
'
output1
'
:
outputs
[
'
output1
'
]
'
output2
'
:
outputs
[
'
output1
'
]
}
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
inputs
{
'
output1
'
:
inputs
[
'
lhs
'
]
'
output2
'
:
outputs
[
'
output2
'
]
}
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
{
'
lhs
'
:
outputs
[
'
output1
'
]
'
rhs
'
:
inputs
[
'
rhs
'
]
}
outputs
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
{
'
lhs
'
:
undefined
'
rhs
'
:
inputs
[
'
rhs
'
]
}
outputs
)
)
;
assert_throws_js
(
TypeError
(
)
=
>
ml_context
.
dispatch
(
ml_graph
inputs
{
'
output1
'
:
undefined
'
output2
'
:
outputs
[
'
output2
'
]
}
)
)
;
}
{
testName
}
/
invalid_buffer
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
const
dispatch_inputs
=
{
'
lhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
lhs
'
]
)
)
'
rhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
rhs
'
]
)
)
}
;
const
dispatch_1_outputs
=
{
'
output1
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output1
'
]
)
)
'
output2
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output2
'
]
)
)
}
;
const
dispatch_2_outputs
=
{
'
output1
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output1
'
]
)
)
'
output2
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output2
'
]
)
)
}
;
const
input_data
=
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
1
.
0
)
;
ml_context
.
writeBuffer
(
dispatch_inputs
[
'
lhs
'
]
input_data
)
;
ml_context
.
writeBuffer
(
dispatch_inputs
[
'
rhs
'
]
input_data
)
;
ml_context
.
dispatch
(
ml_graph
dispatch_inputs
dispatch_1_outputs
)
;
ml_context
.
dispatch
(
ml_graph
dispatch_inputs
dispatch_2_outputs
)
;
await
assert_buffer_data_equals
(
ml_context
dispatch_1_outputs
[
'
output1
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
2
.
0
)
)
;
await
assert_buffer_data_equals
(
ml_context
dispatch_1_outputs
[
'
output2
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
2
.
0
)
)
;
await
assert_buffer_data_equals
(
ml_context
dispatch_2_outputs
[
'
output1
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
2
.
0
)
)
;
await
assert_buffer_data_equals
(
ml_context
dispatch_2_outputs
[
'
output2
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
2
.
0
)
)
;
}
{
testName
}
/
same_inputs
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
const
dispatch_1_inputs
=
{
'
lhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
lhs
'
]
)
)
'
rhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
rhs
'
]
)
)
}
;
const
dispatch_2_inputs
=
{
'
lhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
lhs
'
]
)
)
'
rhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
rhs
'
]
)
)
}
;
const
dispatch_outputs
=
{
'
output1
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output1
'
]
)
)
'
output2
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output2
'
]
)
)
}
;
const
input_1_data
=
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
1
.
0
)
;
ml_context
.
writeBuffer
(
dispatch_1_inputs
[
'
lhs
'
]
input_1_data
)
;
ml_context
.
writeBuffer
(
dispatch_1_inputs
[
'
rhs
'
]
input_1_data
)
;
const
input_2_data
=
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
2
.
0
)
;
ml_context
.
writeBuffer
(
dispatch_2_inputs
[
'
lhs
'
]
input_2_data
)
;
ml_context
.
writeBuffer
(
dispatch_2_inputs
[
'
rhs
'
]
input_2_data
)
;
ml_context
.
dispatch
(
ml_graph
dispatch_1_inputs
dispatch_outputs
)
;
ml_context
.
dispatch
(
ml_graph
dispatch_2_inputs
dispatch_outputs
)
;
await
assert_buffer_data_equals
(
ml_context
dispatch_outputs
[
'
output1
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
4
.
0
)
)
;
await
assert_buffer_data_equals
(
ml_context
dispatch_outputs
[
'
output2
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
4
.
0
)
)
;
}
{
testName
}
/
same_outputs
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
const
dispatch_inputs
=
{
'
lhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
lhs
'
]
)
)
'
rhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
rhs
'
]
)
)
}
;
const
dispatch_outputs
=
{
'
output1
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output1
'
]
)
)
'
output2
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output2
'
]
)
)
}
;
const
input_data
=
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
1
.
0
)
;
ml_context
.
writeBuffer
(
dispatch_inputs
[
'
lhs
'
]
input_data
)
;
ml_context
.
writeBuffer
(
dispatch_inputs
[
'
rhs
'
]
input_data
)
;
ml_context
.
dispatch
(
ml_graph
dispatch_inputs
dispatch_outputs
)
;
ml_context
.
dispatch
(
ml_graph
dispatch_inputs
dispatch_outputs
)
;
await
assert_buffer_data_equals
(
ml_context
dispatch_outputs
[
'
output1
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
2
.
0
)
)
;
await
assert_buffer_data_equals
(
ml_context
dispatch_outputs
[
'
output2
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
2
.
0
)
)
;
}
{
testName
}
/
same_inputs_and_outputs
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
const
dispatch_inputs
=
{
'
lhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
lhs
'
]
)
)
'
rhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
rhs
'
]
)
)
}
;
const
dispatch_1_outputs
=
{
'
output1
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output1
'
]
)
)
'
output2
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output2
'
]
)
)
}
;
const
dispatch_2_outputs
=
{
'
output1
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output1
'
]
)
)
'
output2
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output2
'
]
)
)
}
;
const
input_data
=
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
1
.
0
)
;
ml_context
.
writeBuffer
(
dispatch_inputs
[
'
lhs
'
]
input_data
)
;
ml_context
.
writeBuffer
(
dispatch_inputs
[
'
rhs
'
]
input_data
)
;
ml_context
.
dispatch
(
ml_graph
dispatch_inputs
dispatch_1_outputs
)
;
ml_context
.
dispatch
(
ml_graph
{
'
lhs
'
:
dispatch_1_outputs
[
'
output1
'
]
'
rhs
'
:
dispatch_1_outputs
[
'
output2
'
]
}
dispatch_2_outputs
)
;
ml_context
.
dispatch
(
ml_graph
{
'
lhs
'
:
dispatch_2_outputs
[
'
output1
'
]
'
rhs
'
:
dispatch_2_outputs
[
'
output2
'
]
}
dispatch_1_outputs
)
;
await
assert_buffer_data_equals
(
ml_context
dispatch_1_outputs
[
'
output1
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
8
)
)
;
await
assert_buffer_data_equals
(
ml_context
dispatch_1_outputs
[
'
output2
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
8
)
)
;
}
{
testName
}
/
outputs_as_inputs
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
const
builder
=
new
MLGraphBuilder
(
ml_context
)
;
const
operandType
=
{
dataType
:
'
float32
'
dimensions
:
shape
}
;
const
lhsOperand
=
builder
.
input
(
'
lhs
'
operandType
)
;
const
rhsOperand
=
builder
.
input
(
'
rhs
'
operandType
)
;
const
graph
=
await
builder
.
build
(
{
'
output
'
:
builder
.
sub
(
lhsOperand
rhsOperand
)
}
)
;
const
lhsBuffer
=
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
lhs
'
]
)
)
;
const
rhsBuffer
=
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
rhs
'
]
)
)
;
const
dispatchOutputs
=
{
'
output
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output1
'
]
)
)
}
;
ml_context
.
writeBuffer
(
lhsBuffer
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
5
.
0
)
)
;
ml_context
.
writeBuffer
(
rhsBuffer
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
3
.
0
)
)
;
ml_context
.
dispatch
(
graph
{
'
lhs
'
:
lhsBuffer
'
rhs
'
:
rhsBuffer
}
dispatchOutputs
)
;
await
assert_buffer_data_equals
(
ml_context
dispatchOutputs
[
'
output
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
2
)
)
;
ml_context
.
dispatch
(
graph
{
'
lhs
'
:
rhsBuffer
'
rhs
'
:
lhsBuffer
}
dispatchOutputs
)
;
await
assert_buffer_data_equals
(
ml_context
dispatchOutputs
[
'
output
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
-
2
)
)
;
}
{
testName
}
/
same
name
diff
input
buffers
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
const
dispatchInputs
=
{
'
lhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
lhs
'
]
)
)
'
rhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
rhs
'
]
)
)
}
;
const
outputBuffer1
=
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output1
'
]
)
)
;
const
outputBuffer2
=
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output2
'
]
)
)
;
const
inputData1
=
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
1
.
0
)
;
ml_context
.
writeBuffer
(
dispatchInputs
[
'
lhs
'
]
inputData1
)
;
ml_context
.
writeBuffer
(
dispatchInputs
[
'
rhs
'
]
inputData1
)
;
ml_context
.
dispatch
(
ml_graph
dispatchInputs
{
'
output1
'
:
outputBuffer1
'
output2
'
:
outputBuffer2
}
)
;
const
inputData2
=
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
2
.
0
)
;
ml_context
.
writeBuffer
(
dispatchInputs
[
'
lhs
'
]
inputData2
)
;
ml_context
.
writeBuffer
(
dispatchInputs
[
'
rhs
'
]
inputData2
)
;
ml_context
.
dispatch
(
ml_graph
dispatchInputs
{
'
output1
'
:
outputBuffer1
'
output2
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output2
'
]
)
)
}
)
;
await
assert_buffer_data_equals
(
ml_context
outputBuffer2
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
2
)
)
;
}
{
testName
}
/
same
name
diff
outputs
buffers
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
const
dispatchInputs
=
{
'
lhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
lhs
'
]
)
)
'
rhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
rhs
'
]
)
)
}
;
const
dispatchOutputs
=
{
'
output1
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output1
'
]
)
)
'
output2
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output2
'
]
)
)
}
;
const
inputData
=
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
1
.
0
)
;
ml_context
.
writeBuffer
(
dispatchInputs
[
'
lhs
'
]
inputData
)
;
ml_context
.
writeBuffer
(
dispatchInputs
[
'
rhs
'
]
inputData
)
;
ml_context
.
dispatch
(
ml_graph
dispatchInputs
dispatchOutputs
)
;
dispatchInputs
[
'
lhs
'
]
.
destroy
(
)
;
dispatchInputs
[
'
lhs
'
]
=
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
lhs
'
]
)
)
;
const
newInputData
=
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
2
.
0
)
;
ml_context
.
writeBuffer
(
dispatchInputs
[
'
lhs
'
]
newInputData
)
;
ml_context
.
dispatch
(
ml_graph
dispatchInputs
dispatchOutputs
)
;
await
assert_buffer_data_equals
(
ml_context
dispatchOutputs
[
'
output1
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
3
)
)
;
dispatchInputs
[
'
rhs
'
]
.
destroy
(
)
;
dispatchInputs
[
'
rhs
'
]
=
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
rhs
'
]
)
)
;
ml_context
.
writeBuffer
(
dispatchInputs
[
'
rhs
'
]
newInputData
)
;
ml_context
.
dispatch
(
ml_graph
dispatchInputs
dispatchOutputs
)
;
await
assert_buffer_data_equals
(
ml_context
dispatchOutputs
[
'
output1
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
4
)
)
;
}
{
testName
}
/
same
name
diff
inputs
buffers
destroy
)
;
promise_test
(
async
(
)
=
>
{
if
(
!
isMLBufferSupported
(
ml_context
)
)
{
return
;
}
const
dispatchInputs
=
{
'
lhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
lhs
'
]
)
)
'
rhs
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
inputs
[
'
rhs
'
]
)
)
}
;
const
dispatchOutputs
=
{
'
output1
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output1
'
]
)
)
'
output2
'
:
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output2
'
]
)
)
}
;
const
inputData
=
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
1
.
0
)
;
ml_context
.
writeBuffer
(
dispatchInputs
[
'
lhs
'
]
inputData
)
;
ml_context
.
writeBuffer
(
dispatchInputs
[
'
rhs
'
]
inputData
)
;
ml_context
.
dispatch
(
ml_graph
dispatchInputs
dispatchOutputs
)
;
dispatchOutputs
[
'
output1
'
]
.
destroy
(
)
;
dispatchOutputs
[
'
output1
'
]
=
ml_context
.
createBuffer
(
getDescriptorFromBuffer
(
outputs
[
'
output1
'
]
)
)
;
const
newInputData
=
new
TypedArrayDict
[
'
float32
'
]
(
sizeOfShape
(
shape
)
)
.
fill
(
2
.
0
)
;
ml_context
.
writeBuffer
(
dispatchInputs
[
'
lhs
'
]
newInputData
)
;
ml_context
.
dispatch
(
ml_graph
dispatchInputs
dispatchOutputs
)
;
await
assert_buffer_data_equals
(
ml_context
dispatchOutputs
[
'
output1
'
]
new
Float32Array
(
sizeOfShape
(
shape
)
)
.
fill
(
3
)
)
;
}
{
testName
}
/
same
name
diff
outputs
buffers
destroy
)
;
}
;
