'
use
strict
'
;
const
ExecutionArray
=
[
'
sync
'
'
async
'
]
;
const
DeviceTypeArray
=
[
'
cpu
'
'
gpu
'
]
;
const
TypedArrayDict
=
{
float32
:
Float32Array
int32
:
Int32Array
uint32
:
Uint32Array
int8
:
Int8Array
uint8
:
Uint8Array
}
;
const
sizeOfShape
=
(
array
)
=
>
{
return
array
.
reduce
(
(
accumulator
currentValue
)
=
>
accumulator
*
currentValue
1
)
;
}
;
const
loadTests
=
(
operationName
)
=
>
{
const
loadJSON
=
(
file
)
=
>
{
let
xmlhttp
=
new
XMLHttpRequest
(
)
;
xmlhttp
.
open
(
"
GET
"
file
false
)
;
xmlhttp
.
overrideMimeType
(
"
application
/
json
"
)
;
xmlhttp
.
send
(
)
;
if
(
xmlhttp
.
status
=
=
200
&
&
xmlhttp
.
readyState
=
=
4
)
{
return
xmlhttp
.
responseText
;
}
else
{
throw
new
Error
(
Failed
to
load
{
file
}
)
;
}
}
;
const
capitalLetterMatches
=
operationName
.
match
(
/
[
A
-
Z
]
/
)
;
if
(
capitalLetterMatches
!
=
=
null
)
{
const
capitalLetter
=
capitalLetterMatches
[
0
]
;
operationName
=
operationName
.
replace
(
capitalLetter
_
{
capitalLetter
.
toLowerCase
(
)
}
)
;
}
const
json
=
loadJSON
(
/
webnn
/
resources
/
test_data
/
{
operationName
}
.
json
)
;
const
resources
=
JSON
.
parse
(
json
.
replace
(
/
\
\
"
|
"
(
?
:
\
\
"
|
[
^
"
]
)
*
"
|
(
\
/
\
/
.
*
|
\
/
\
*
[
\
s
\
S
]
*
?
\
*
\
/
)
/
g
(
m
g
)
=
>
g
?
"
"
:
m
)
)
;
return
resources
.
tests
;
}
;
const
getExpectedDataAndType
=
(
resources
outputName
)
=
>
{
let
ret
;
for
(
let
subResources
of
resources
)
{
if
(
subResources
.
name
=
=
=
outputName
)
{
ret
=
[
subResources
.
data
subResources
.
type
]
;
break
;
}
}
if
(
ret
=
=
=
undefined
)
{
throw
new
Error
(
Failed
to
get
expected
data
sources
and
type
by
{
outputName
}
)
;
}
return
ret
;
}
;
const
getConv2dPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
inputNameArray
=
Object
.
keys
(
resources
.
inputs
)
;
const
inputShape
=
resources
.
inputs
[
inputNameArray
[
0
]
]
.
shape
;
const
filterShape
=
resources
.
inputs
[
inputNameArray
[
1
]
]
.
shape
;
const
options
=
resources
.
options
;
let
groups
=
1
;
let
inputChannels
=
inputShape
[
1
]
;
let
filterWidth
=
filterShape
[
3
]
;
let
filterHeight
=
filterShape
[
2
]
;
if
(
options
)
{
if
(
options
.
groups
)
{
groups
=
options
.
groups
;
}
if
(
options
.
inputLayout
)
{
if
(
!
[
'
nchw
'
'
nhwc
'
]
.
includes
(
options
.
inputLayout
)
)
{
throw
new
Error
(
Unsupported
inputLayout
{
options
.
inputLayout
}
)
;
}
inputChannels
=
options
.
inputLayout
=
=
=
'
nchw
'
?
inputChannels
:
inputShape
[
3
]
;
}
if
(
options
.
filterLayout
)
{
let
filterLayouts
=
[
'
oihw
'
'
hwio
'
'
ohwi
'
'
ihwo
'
]
;
if
(
operationName
=
=
=
'
convTranspose2d
'
)
{
filterLayouts
=
[
'
iohw
'
'
hwoi
'
'
ohwi
'
]
;
}
if
(
!
filterLayouts
.
includes
(
options
.
filterLayout
)
)
{
throw
new
Error
(
Unsupported
filterLayout
{
options
.
filterLayout
}
)
;
}
switch
(
options
.
filterLayout
)
{
case
'
oihw
'
:
case
'
iohw
'
:
break
;
case
'
hwio
'
:
case
'
hwoi
'
:
filterWidth
=
filterShape
[
1
]
;
filterHeight
=
filterShape
[
0
]
;
break
;
case
'
ohwi
'
:
case
'
ihwo
'
:
filterWidth
=
filterShape
[
2
]
;
filterHeight
=
filterShape
[
1
]
;
break
;
default
:
break
;
}
}
}
const
tolerance
=
filterWidth
*
filterHeight
*
(
inputChannels
/
groups
)
*
2
;
return
tolerance
;
}
;
const
getGemmPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
shapeA
=
resources
.
inputs
[
Object
.
keys
(
resources
.
inputs
)
[
0
]
]
.
shape
;
const
options
=
{
.
.
.
resources
.
options
}
;
const
width
=
options
.
aTranspose
?
shapeA
[
0
]
:
shapeA
[
1
]
;
let
tolerance
=
width
*
2
;
if
(
options
.
alpha
!
=
=
undefined
&
&
options
.
alpha
!
=
=
1
.
0
)
{
tolerance
+
+
;
}
if
(
options
.
c
&
&
options
.
beta
!
=
=
0
.
0
)
{
if
(
options
.
beta
!
=
=
undefined
&
&
options
.
beta
!
=
=
1
.
0
)
{
tolerance
+
+
;
}
tolerance
+
+
;
}
return
tolerance
;
}
;
const
getMatmulPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
shapeA
=
resources
.
inputs
[
Object
.
keys
(
resources
.
inputs
)
[
0
]
]
.
shape
;
const
tolerance
=
shapeA
[
shapeA
.
length
-
1
]
*
2
;
return
tolerance
;
}
;
const
getAveragePool2dPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
inputShape
=
resources
.
inputs
[
Object
.
keys
(
resources
.
inputs
)
[
0
]
]
.
shape
;
let
height
;
let
width
;
const
options
=
{
.
.
.
resources
.
options
}
;
if
(
options
.
windowDimensions
)
{
height
=
options
.
windowDimensions
[
0
]
;
width
=
options
.
windowDimensions
[
1
]
;
}
else
{
if
(
options
.
layout
&
&
options
.
layout
=
=
=
'
nhwc
'
)
{
height
=
inputShape
[
1
]
;
width
=
inputShape
[
2
]
;
}
else
{
height
=
inputShape
[
2
]
;
width
=
inputShape
[
3
]
;
}
}
const
tolerance
=
height
*
width
+
2
;
return
tolerance
;
}
;
const
getSoftmaxPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
inputShape
=
resources
.
inputs
[
Object
.
keys
(
resources
.
inputs
)
[
0
]
]
.
shape
;
const
tolerance
=
inputShape
[
1
]
*
3
+
3
;
return
tolerance
;
}
;
const
getReductionPrecisionTolerance
=
(
resources
operationName
)
=
>
{
const
inputShape
=
resources
.
inputs
[
Object
.
keys
(
resources
.
inputs
)
[
0
]
]
.
shape
;
const
rank
=
inputShape
.
length
;
const
options
=
{
.
.
.
resources
.
options
}
;
let
sizes
;
if
(
options
&
&
options
.
axes
)
{
sizes
=
options
.
axes
.
map
(
(
axis
)
=
>
axis
<
0
?
inputShape
[
axis
+
rank
]
:
inputShape
[
axis
]
)
;
}
else
{
sizes
=
inputShape
;
}
let
tolerance
=
sizes
.
reduce
(
(
accumulator
currentValue
)
=
>
accumulator
*
currentValue
)
;
if
(
operationName
=
=
=
'
reduceMean
'
)
{
tolerance
+
=
2
;
}
return
tolerance
;
}
;
const
PrecisionMetrics
=
{
batchNormalization
:
{
ULP
:
{
float32
:
6
float16
:
6
}
}
clamp
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
concat
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
conv2d
:
{
ULP
:
{
float32
:
getConv2dPrecisionTolerance
float16
:
getConv2dPrecisionTolerance
}
}
convTranspose2d
:
{
ULP
:
{
float32
:
getConv2dPrecisionTolerance
float16
:
getConv2dPrecisionTolerance
}
}
add
:
{
ULP
:
{
float32
:
1
float16
:
1
}
}
sub
:
{
ULP
:
{
float32
:
1
float16
:
1
}
}
mul
:
{
ULP
:
{
float32
:
1
float16
:
1
}
}
div
:
{
ULP
:
{
float32
:
2
float16
:
2
}
}
max
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
min
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
pow
:
{
ULP
:
{
float32
:
32
float16
:
2
}
}
abs
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
ceil
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
cos
:
{
ATOL
:
{
float32
:
1
/
1024
float16
:
1
/
512
}
}
exp
:
{
ULP
:
{
float32
:
32
float16
:
1
}
}
floor
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
log
:
{
ATOL
:
{
float32
:
1
/
1024
float16
:
1
/
1024
}
}
neg
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
sin
:
{
ATOL
:
{
float32
:
1
/
1024
float16
:
1
/
512
}
}
tan
:
{
ATOL
:
{
float32
:
1
/
1024
float16
:
1
/
512
}
}
gemm
:
{
ULP
:
{
float32
:
getGemmPrecisionTolerance
float16
:
getGemmPrecisionTolerance
}
}
leakyRelu
:
{
ULP
:
{
float32
:
1
float16
:
1
}
}
matmul
:
{
ULP
:
{
float32
:
getMatmulPrecisionTolerance
float16
:
getMatmulPrecisionTolerance
}
}
averagePool2d
:
{
ULP
:
{
float32
:
getAveragePool2dPrecisionTolerance
float16
:
getAveragePool2dPrecisionTolerance
}
}
maxPool2d
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
reduceMax
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
reduceMean
:
{
ULP
:
{
float32
:
getReductionPrecisionTolerance
float16
:
getReductionPrecisionTolerance
}
}
reduceMin
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
reduceProduct
:
{
ULP
:
{
float32
:
getReductionPrecisionTolerance
float16
:
getReductionPrecisionTolerance
}
}
reduceSum
:
{
ULP
:
{
float32
:
getReductionPrecisionTolerance
float16
:
getReductionPrecisionTolerance
}
}
relu
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
reshape
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
sigmoid
:
{
ULP
:
{
float32
:
32
+
2
float16
:
3
}
}
slice
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
softmax
:
{
ULP
:
{
float32
:
getSoftmaxPrecisionTolerance
float16
:
getSoftmaxPrecisionTolerance
}
}
split
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
squeeze
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
tanh
:
{
ATOL
:
{
float32
:
1
/
1024
float16
:
1
/
512
}
}
transpose
:
{
ULP
:
{
float32
:
0
float16
:
0
}
}
}
;
const
getPrecisonTolerance
=
(
operationName
metricType
resources
)
=
>
{
const
precisionType
=
Array
.
isArray
(
resources
.
expected
)
?
resources
.
expected
[
0
]
.
type
:
resources
.
expected
.
type
;
let
tolerance
=
PrecisionMetrics
[
operationName
]
[
metricType
]
[
precisionType
]
;
if
(
tolerance
instanceof
Function
)
{
tolerance
=
tolerance
(
resources
operationName
)
;
}
return
tolerance
;
}
;
const
getBitwise
=
(
value
dataType
)
=
>
{
const
buffer
=
new
ArrayBuffer
(
8
)
;
const
int64Array
=
new
BigInt64Array
(
buffer
)
;
int64Array
[
0
]
=
value
<
0
?
~
BigInt
(
0
)
:
BigInt
(
0
)
;
let
typedArray
;
if
(
dataType
=
=
=
"
float32
"
)
{
typedArray
=
new
Float32Array
(
buffer
)
;
}
else
{
throw
new
AssertionError
(
Data
type
{
dataType
}
is
not
supported
)
;
}
typedArray
[
0
]
=
value
;
return
int64Array
[
0
]
;
}
;
const
assert_array_approx_equals_ulp
=
(
actual
expected
nulp
dataType
description
)
=
>
{
assert_true
(
actual
.
length
=
=
=
expected
.
length
assert_array_approx_equals_ulp
:
{
description
}
lengths
differ
expected
{
expected
.
length
}
but
got
{
actual
.
length
}
)
;
let
actualBitwise
expectedBitwise
distance
;
for
(
let
i
=
0
;
i
<
actual
.
length
;
i
+
+
)
{
actualBitwise
=
getBitwise
(
actual
[
i
]
dataType
)
;
expectedBitwise
=
getBitwise
(
expected
[
i
]
dataType
)
;
distance
=
actualBitwise
-
expectedBitwise
;
distance
=
distance
>
=
0
?
distance
:
-
distance
;
assert_true
(
distance
<
=
nulp
assert_array_approx_equals_ulp
:
{
description
}
actual
{
actual
[
i
]
}
should
be
close
enough
to
expected
{
expected
[
i
]
}
by
the
acceptable
{
nulp
}
ULP
distance
but
they
have
{
distance
}
ULP
distance
)
;
}
}
;
const
doAssert
=
(
operationName
actual
expected
tolerance
operandType
metricType
)
=
>
{
const
description
=
test
{
operationName
}
{
operandType
}
;
if
(
typeof
expected
=
=
=
'
number
'
)
{
expected
=
[
expected
]
;
actual
=
[
actual
]
;
}
if
(
metricType
=
=
=
'
ULP
'
)
{
assert_array_approx_equals_ulp
(
actual
expected
tolerance
operandType
description
)
;
}
else
if
(
metricType
=
=
=
'
ATOL
'
)
{
assert_array_approx_equals
(
actual
expected
tolerance
description
)
;
}
}
;
const
checkResults
=
(
operationName
namedOutputOperands
outputs
resources
)
=
>
{
const
metricType
=
Object
.
keys
(
PrecisionMetrics
[
operationName
]
)
[
0
]
;
const
expected
=
resources
.
expected
;
let
tolerance
;
let
operandType
;
let
outputData
;
let
expectedData
;
if
(
Array
.
isArray
(
expected
)
)
{
for
(
let
operandName
in
namedOutputOperands
)
{
outputData
=
outputs
[
operandName
]
;
[
expectedData
operandType
]
=
getExpectedDataAndType
(
expected
operandName
)
;
tolerance
=
getPrecisonTolerance
(
operationName
metricType
resources
)
;
doAssert
(
operationName
outputData
expectedData
tolerance
operandType
metricType
)
}
}
else
{
outputData
=
outputs
[
expected
.
name
]
;
expectedData
=
expected
.
data
;
operandType
=
expected
.
type
;
tolerance
=
getPrecisonTolerance
(
operationName
metricType
resources
)
;
doAssert
(
operationName
outputData
expectedData
tolerance
operandType
metricType
)
}
}
;
const
createConstantOperand
=
(
builder
resources
)
=
>
{
const
bufferView
=
new
TypedArrayDict
[
resources
.
type
]
(
resources
.
data
)
;
return
builder
.
constant
(
{
type
:
resources
.
type
dimensions
:
resources
.
shape
}
bufferView
)
;
}
;
const
createSingleInputOperand
=
(
builder
resources
inputOperandName
)
=
>
{
inputOperandName
=
inputOperandName
?
inputOperandName
:
Object
.
keys
(
resources
.
inputs
)
[
0
]
;
const
inputResources
=
resources
.
inputs
[
inputOperandName
]
;
return
builder
.
input
(
inputOperandName
{
type
:
inputResources
.
type
dimensions
:
inputResources
.
shape
}
)
;
}
;
const
createMultiInputOperands
=
(
builder
resources
)
=
>
{
let
inputOperands
=
[
]
;
const
inputOperandNameArray
=
Object
.
keys
(
resources
.
inputs
)
;
inputOperandNameArray
.
forEach
(
inputOperandName
=
>
{
let
operand
;
if
(
resources
.
inputs
[
inputOperandName
]
.
hasOwnProperty
(
'
constant
'
)
&
&
resources
.
inputs
[
inputOperandName
]
[
'
constant
'
]
)
{
operand
=
createConstantOperand
(
builder
resources
.
inputs
[
inputOperandName
]
)
;
}
else
{
operand
=
createSingleInputOperand
(
builder
resources
inputOperandName
)
;
}
inputOperands
.
push
(
operand
)
;
}
)
;
return
inputOperands
;
}
;
const
buildOperationWithSingleInput
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
inputOperand
=
createSingleInputOperand
(
builder
resources
)
;
const
outputOperand
=
resources
.
options
?
builder
[
operationName
]
(
inputOperand
resources
.
options
)
:
builder
[
operationName
]
(
inputOperand
)
;
namedOutputOperand
[
resources
.
expected
.
name
]
=
outputOperand
;
return
namedOutputOperand
;
}
;
const
buildOperationWithTwoInputs
=
(
operationName
builder
resources
)
=
>
{
const
namedOutputOperand
=
{
}
;
const
[
inputOperandA
inputOperandB
]
=
createMultiInputOperands
(
builder
resources
)
;
const
outputOperand
=
resources
.
options
?
builder
[
operationName
]
(
inputOperandA
inputOperandB
resources
.
options
)
:
builder
[
operationName
]
(
inputOperandA
inputOperandB
)
;
namedOutputOperand
[
resources
.
expected
.
name
]
=
outputOperand
;
return
namedOutputOperand
;
}
;
const
buildGraph
=
(
operationName
builder
resources
buildFunc
)
=
>
{
const
namedOperands
=
buildFunc
(
operationName
builder
resources
)
;
let
inputs
=
{
}
;
if
(
Array
.
isArray
(
resources
.
inputs
)
)
{
for
(
let
subInput
of
resources
.
inputs
)
{
if
(
!
subInput
.
hasOwnProperty
(
'
constant
'
)
|
|
!
subInput
.
constant
)
{
inputs
[
subInput
.
name
]
=
new
TypedArrayDict
[
subInput
.
type
]
(
subInput
.
data
)
;
}
}
}
else
{
for
(
let
inputName
in
resources
.
inputs
)
{
const
subTestByName
=
resources
.
inputs
[
inputName
]
;
if
(
!
subTestByName
.
hasOwnProperty
(
'
constant
'
)
|
|
!
subTestByName
.
constant
)
{
inputs
[
inputName
]
=
new
TypedArrayDict
[
subTestByName
.
type
]
(
subTestByName
.
data
)
;
}
}
}
let
outputs
=
{
}
;
if
(
Array
.
isArray
(
resources
.
expected
)
)
{
for
(
let
i
=
0
;
i
<
resources
.
expected
.
length
;
i
+
+
)
{
const
subExpected
=
resources
.
expected
[
i
]
;
outputs
[
subExpected
.
name
]
=
new
TypedArrayDict
[
subExpected
.
type
]
(
sizeOfShape
(
subExpected
.
shape
)
)
;
}
}
else
{
const
shape
=
resources
.
expected
.
shape
?
resources
.
expected
.
shape
:
[
1
]
;
outputs
[
resources
.
expected
.
name
]
=
new
TypedArrayDict
[
resources
.
expected
.
type
]
(
sizeOfShape
(
shape
)
)
;
}
return
[
namedOperands
inputs
outputs
]
;
}
;
const
runSync
=
(
operationName
context
builder
resources
buildFunc
)
=
>
{
const
[
namedOutputOperands
inputs
outputs
]
=
buildGraph
(
operationName
builder
resources
buildFunc
)
;
const
graph
=
builder
.
buildSync
(
namedOutputOperands
)
;
context
.
computeSync
(
graph
inputs
outputs
)
;
checkResults
(
operationName
namedOutputOperands
outputs
resources
)
;
}
;
const
run
=
async
(
operationName
context
builder
resources
buildFunc
)
=
>
{
const
[
namedOutputOperands
inputs
outputs
]
=
buildGraph
(
operationName
builder
resources
buildFunc
)
;
const
graph
=
await
builder
.
build
(
namedOutputOperands
)
;
await
context
.
compute
(
graph
inputs
outputs
)
;
checkResults
(
operationName
namedOutputOperands
outputs
resources
)
;
}
;
const
testWebNNOperation
=
(
operationName
buildFunc
)
=
>
{
let
operationNameArray
;
if
(
typeof
operationName
=
=
=
'
string
'
)
{
operationNameArray
=
[
operationName
]
;
}
else
if
(
Array
.
isArray
(
operationName
)
)
{
operationNameArray
=
operationName
;
}
ExecutionArray
.
forEach
(
executionType
=
>
{
const
isSync
=
executionType
=
=
=
'
sync
'
;
if
(
self
.
GLOBAL
.
isWindow
(
)
&
&
isSync
)
{
return
;
}
let
context
;
let
builder
;
if
(
isSync
)
{
operationNameArray
.
forEach
(
(
subOperationName
)
=
>
{
const
tests
=
loadTests
(
subOperationName
)
;
DeviceTypeArray
.
forEach
(
deviceType
=
>
{
setup
(
(
)
=
>
{
context
=
navigator
.
ml
.
createContextSync
(
{
deviceType
}
)
;
builder
=
new
MLGraphBuilder
(
context
)
;
}
)
;
for
(
const
subTest
of
tests
)
{
test
(
(
)
=
>
{
runSync
(
subOperationName
context
builder
subTest
buildFunc
)
;
}
{
subTest
.
name
}
/
{
deviceType
}
/
{
executionType
}
)
;
}
}
)
;
}
)
;
}
else
{
operationNameArray
.
forEach
(
(
subOperationName
)
=
>
{
const
tests
=
loadTests
(
subOperationName
)
;
DeviceTypeArray
.
forEach
(
deviceType
=
>
{
promise_setup
(
async
(
)
=
>
{
context
=
await
navigator
.
ml
.
createContext
(
{
deviceType
}
)
;
builder
=
new
MLGraphBuilder
(
context
)
;
}
)
;
for
(
const
subTest
of
tests
)
{
promise_test
(
async
(
)
=
>
{
await
run
(
subOperationName
context
builder
subTest
buildFunc
)
;
}
{
subTest
.
name
}
/
{
deviceType
}
/
{
executionType
}
)
;
}
}
)
;
}
)
;
}
}
)
;
}
;
