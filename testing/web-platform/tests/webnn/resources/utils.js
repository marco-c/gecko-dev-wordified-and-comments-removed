'
use
strict
'
;
const
operatorToleranceDict
=
{
batchNormalization
:
{
float32
:
6
float16
:
6
}
clamp
:
{
float32
:
0
float16
:
0
}
elu
:
{
float32
:
18
float16
:
18
}
gelu
:
{
float32
:
18
float16
:
18
}
hardSigmoid
:
{
float32
:
2
float16
:
2
}
hardSwish
:
{
float32
:
4
float16
:
4
}
leakyRelu
:
{
float32
:
1
float16
:
1
}
linear
:
{
float32
:
2
float16
:
2
}
prelu
:
{
float32
:
1
float16
:
1
}
relu
:
{
float32
:
0
float16
:
0
}
reshape
:
{
float32
:
0
float16
:
0
}
sigmoid
:
{
float32
:
34
float16
:
3
}
softplus
:
{
float32
:
18
float16
:
18
}
softsign
:
{
float32
:
3
float16
:
3
}
}
;
const
getSoftmaxPrecisionTolerance
=
(
op
graphResources
intermediateOperands
)
=
>
{
const
{
inputs
}
=
graphResources
;
const
args
=
op
.
arguments
;
let
inputShape
;
const
inputIndex
=
args
[
0
]
[
Object
.
keys
(
args
[
0
]
)
[
0
]
]
;
if
(
inputs
[
inputIndex
]
)
{
inputShape
=
inputs
[
inputIndex
]
.
descriptor
.
shape
;
}
else
{
inputShape
=
intermediateOperands
[
inputIndex
]
.
shape
;
}
const
axis
=
args
.
length
=
=
=
2
?
args
[
1
]
[
Object
.
keys
(
args
[
1
]
)
[
0
]
]
:
1
;
const
tolerance
=
inputShape
[
axis
]
*
3
+
3
;
const
toleranceValueDict
=
{
float32
:
tolerance
float16
:
tolerance
}
;
const
expectedDataType
=
getExpectedDataTypeOfSingleOutput
(
graphResources
.
expectedOutputs
)
;
return
{
metricType
:
'
ULP
'
value
:
toleranceValueDict
[
expectedDataType
]
}
;
}
;
const
getPrecisionTolerance
=
(
graphResources
intermediateOperands
)
=
>
{
const
expectedDataType
=
getExpectedDataTypeOfSingleOutput
(
graphResources
.
expectedOutputs
)
;
let
toleranceValue
=
0
;
graphResources
.
operators
.
forEach
(
op
=
>
{
switch
(
op
.
name
)
{
case
'
conv2d
'
:
toleranceValue
+
=
getConv2dPrecisionTolerance
(
op
graphResources
intermediateOperands
)
.
value
;
break
;
case
'
convTranspose2d
'
:
toleranceValue
+
=
getConv2dPrecisionTolerance
(
op
graphResources
intermediateOperands
)
.
value
;
break
;
case
'
gemm
'
:
toleranceValue
+
=
getGemmPrecisionTolerance
(
op
graphResources
intermediateOperands
)
.
value
;
break
;
case
'
softmax
'
:
toleranceValue
+
=
getSoftmaxPrecisionTolerance
(
op
graphResources
intermediateOperands
)
.
value
;
break
;
default
:
const
operatorTolerance
=
operatorToleranceDict
[
op
.
name
]
?
.
[
expectedDataType
]
;
if
(
operatorTolerance
!
=
=
undefined
)
{
toleranceValue
+
=
operatorTolerance
;
}
}
}
)
;
return
{
metricType
:
'
ULP
'
value
:
toleranceValue
}
;
}
;
const
TypedArrayDict
=
{
float32
:
Float32Array
float16
:
Uint16Array
int64
:
BigInt64Array
uint64
:
BigUint64Array
int32
:
Int32Array
uint32
:
Uint32Array
int8
:
Int8Array
uint8
:
Uint8Array
int4
:
Uint8Array
uint4
:
Uint8Array
}
;
const
kIntTypes
=
[
'
uint4
'
'
int4
'
'
uint8
'
'
int8
'
'
uint32
'
'
int32
'
'
uint64
'
'
int64
'
]
;
const
kFloatTypes
=
[
'
float16
'
'
float32
'
]
;
const
findCompatibleType
=
(
dataType
supportedTypes
castOpSupportLimits
)
=
>
{
if
(
!
castOpSupportLimits
.
input
.
dataTypes
.
includes
(
dataType
)
)
{
return
null
;
}
for
(
let
supportedType
of
supportedTypes
)
{
if
(
kIntTypes
.
includes
(
dataType
)
&
&
castOpSupportLimits
.
output
.
dataTypes
.
includes
(
dataType
)
&
&
kIntTypes
.
indexOf
(
supportedType
)
>
kIntTypes
.
indexOf
(
dataType
)
)
{
return
supportedType
;
}
if
(
kFloatTypes
.
includes
(
dataType
)
)
{
if
(
kFloatTypes
.
indexOf
(
supportedType
)
>
kFloatTypes
.
indexOf
(
dataType
)
)
{
return
supportedType
;
}
}
}
return
null
;
}
;
const
kMaximumIndexToValidate
=
1000
;
const
kContextOptionsForVariant
=
{
cpu
:
{
deviceType
:
'
cpu
'
}
gpu
:
{
deviceType
:
'
gpu
'
}
npu
:
{
deviceType
:
'
npu
'
}
}
;
const
variant
=
location
.
search
.
substring
(
1
)
;
const
contextOptions
=
kContextOptionsForVariant
[
variant
]
;
const
assertDescriptorsEquals
=
(
outputOperand
expected
)
=
>
{
const
dataType
=
expected
.
castedType
?
expected
.
castedType
:
expected
.
dataType
;
assert_true
(
outputOperand
.
dataType
=
=
=
dataType
'
actual
output
dataType
should
be
equal
to
expected
output
dataType
'
)
;
assert_array_equals
(
outputOperand
.
shape
expected
.
shape
'
actual
output
shape
should
be
equal
to
expected
output
shape
'
)
;
}
;
const
toHalf
=
(
value
)
=
>
{
let
floatView
=
new
Float32Array
(
1
)
;
let
int32View
=
new
Int32Array
(
floatView
.
buffer
)
;
floatView
[
0
]
=
value
;
let
x
=
int32View
[
0
]
;
let
bits
=
(
x
>
>
16
)
&
0x8000
;
let
m
=
(
x
>
>
12
)
&
0x07ff
;
let
e
=
(
x
>
>
23
)
&
0xff
;
if
(
e
<
103
)
{
return
bits
;
}
if
(
e
>
142
)
{
bits
|
=
0x7c00
;
bits
|
=
(
(
e
=
=
255
)
?
0
:
1
)
&
&
(
x
&
0x007fffff
)
;
return
bits
;
}
if
(
e
<
113
)
{
m
|
=
0x0800
;
bits
|
=
(
m
>
>
(
114
-
e
)
)
+
(
(
m
>
>
(
113
-
e
)
)
&
1
)
;
return
bits
;
}
bits
|
=
(
(
e
-
112
)
<
<
10
)
|
(
m
>
>
1
)
;
bits
+
=
m
&
1
;
return
bits
;
}
;
const
getTypedArrayData
=
(
type
size
data
)
=
>
{
let
outData
;
if
(
type
=
=
=
'
float16
'
)
{
if
(
typeof
(
data
)
=
=
=
'
number
'
&
&
size
>
1
)
{
return
new
TypedArrayDict
[
type
]
(
size
)
.
fill
(
toHalf
(
data
)
)
;
}
outData
=
new
TypedArrayDict
[
type
]
(
data
.
length
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
outData
[
i
]
=
toHalf
(
data
[
i
]
)
;
}
}
else
if
(
type
=
=
=
'
int64
'
)
{
if
(
typeof
(
data
)
=
=
=
'
number
'
&
&
size
>
1
)
{
return
new
TypedArrayDict
[
type
]
(
size
)
.
fill
(
BigInt
(
data
)
)
;
}
outData
=
new
TypedArrayDict
[
type
]
(
data
.
length
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
outData
[
i
]
=
BigInt
(
data
[
i
]
)
;
}
}
else
if
(
type
=
=
=
'
uint4
'
|
|
type
=
=
=
'
int4
'
)
{
const
array
=
new
TypedArrayDict
[
type
]
(
Math
.
ceil
(
size
/
2
)
)
;
let
i
=
0
;
while
(
i
<
size
-
1
)
{
const
packedByte
=
(
(
data
[
i
+
1
]
&
0xF
)
<
<
4
)
|
(
data
[
i
]
&
0xF
)
;
array
[
Math
.
floor
(
i
/
2
)
]
=
packedByte
;
i
=
i
+
2
;
}
if
(
i
=
=
=
size
-
1
)
{
const
packedByte
=
data
[
i
]
&
0xF
;
array
[
Math
.
floor
(
i
/
2
)
]
=
packedByte
;
}
return
array
;
}
else
{
if
(
typeof
(
data
)
=
=
=
'
number
'
&
&
size
>
1
)
{
return
new
TypedArrayDict
[
type
]
(
size
)
.
fill
(
data
)
;
}
outData
=
new
TypedArrayDict
[
type
]
(
data
)
;
}
return
outData
;
}
;
const
sizeOfShape
=
(
array
)
=
>
{
return
array
.
reduce
(
(
accumulator
currentValue
)
=
>
accumulator
*
currentValue
1
)
;
}
;
const
getBitwise
=
(
value
dataType
)
=
>
{
const
buffer
=
new
ArrayBuffer
(
8
)
;
const
int64Array
=
new
BigInt64Array
(
buffer
)
;
let
typedArray
;
if
(
dataType
=
=
=
"
float32
"
)
{
typedArray
=
new
Float32Array
(
buffer
)
;
}
else
{
throw
new
AssertionError
(
Data
type
{
dataType
}
is
not
supported
)
;
}
typedArray
[
0
]
=
Math
.
abs
(
value
)
;
const
int64
=
int64Array
[
0
]
;
return
(
value
<
0
)
?
-
int64
:
int64
;
}
;
const
assert_array_approx_equals_ulp
=
(
actual
expected
nulp
dataType
description
)
=
>
{
assert_true
(
actual
.
length
=
=
=
expected
.
length
assert_array_approx_equals_ulp
:
{
description
}
lengths
differ
+
expected
{
expected
.
length
}
but
got
{
actual
.
length
}
)
;
let
actualBitwise
expectedBitwise
distance
;
for
(
let
i
=
0
;
i
<
actual
.
length
;
i
+
+
)
{
if
(
actual
[
i
]
=
=
=
expected
[
i
]
)
{
continue
;
}
else
{
if
(
dataType
=
=
=
'
float32
'
)
{
actualBitwise
=
getBitwise
(
actual
[
i
]
dataType
)
;
expectedBitwise
=
getBitwise
(
expected
[
i
]
dataType
)
;
}
else
if
(
dataType
=
=
=
'
float16
'
)
{
actualBitwise
=
actual
[
i
]
;
expectedBitwise
=
toHalf
(
expected
[
i
]
)
;
}
else
if
(
dataType
=
=
=
'
int64
'
)
{
actualBitwise
=
actual
[
i
]
;
expectedBitwise
=
BigInt
(
expected
[
i
]
)
;
}
else
if
(
dataType
=
=
=
'
uint64
'
)
{
actualBitwise
=
actual
[
i
]
;
expectedBitwise
=
BigUint64Array
(
expected
[
i
]
)
;
}
else
if
(
dataType
=
=
=
'
int8
'
|
|
dataType
=
=
=
'
uint8
'
|
|
dataType
=
=
=
'
int32
'
|
|
dataType
=
=
=
'
uint32
'
|
|
dataType
=
=
=
'
int4
'
|
|
dataType
=
=
=
'
uint4
'
)
{
actualBitwise
=
actual
[
i
]
;
expectedBitwise
=
expected
[
i
]
;
}
distance
=
actualBitwise
-
expectedBitwise
;
distance
=
distance
>
=
0
?
distance
:
-
distance
;
if
(
distance
>
nulp
)
{
assert_true
(
false
assert_array_approx_equals_ulp
:
{
description
}
actual
+
{
actual
[
i
]
}
should
be
close
enough
to
expected
+
{
expected
[
i
]
}
by
the
acceptable
{
nulp
}
ULP
distance
+
but
they
have
{
distance
}
ULP
distance
)
;
}
}
}
}
;
function
float16AsUint16ToNumber
(
uint16
)
{
const
sign
=
(
uint16
>
>
15
)
&
0x1
;
const
exponent
=
(
uint16
>
>
10
)
&
0x1F
;
const
mantissa
=
uint16
&
0x3FF
;
let
float16
;
if
(
exponent
=
=
=
0
)
{
float16
=
(
mantissa
/
1024
)
*
Math
.
pow
(
2
-
14
)
;
}
else
if
(
exponent
=
=
=
0x1F
)
{
float16
=
mantissa
?
NaN
:
Infinity
;
}
else
{
float16
=
(
1
+
mantissa
/
1024
)
*
Math
.
pow
(
2
exponent
-
15
)
;
}
return
sign
?
-
float16
:
float16
;
}
const
doAssert
=
(
operatorName
actual
expected
metricType
toleranceValue
dataType
)
=
>
{
const
description
=
test
{
operatorName
}
{
dataType
}
;
if
(
typeof
expected
=
=
=
'
number
'
)
{
expected
=
[
expected
]
;
actual
=
[
actual
]
;
}
if
(
metricType
=
=
=
'
ULP
'
)
{
assert_array_approx_equals_ulp
(
actual
expected
toleranceValue
dataType
description
)
;
}
else
if
(
metricType
=
=
=
'
ATOL
'
)
{
let
actualData
;
if
(
dataType
=
=
=
'
float16
'
)
{
actualData
=
new
Array
(
actual
.
length
)
;
actual
.
forEach
(
(
x
index
)
=
>
actualData
[
index
]
=
float16AsUint16ToNumber
(
x
)
)
;
}
else
{
actualData
=
actual
;
}
assert_array_approx_equals
(
actualData
expected
toleranceValue
description
)
;
}
else
{
throw
new
AssertionError
(
Tolerance
Metric
type
'
{
metricType
}
'
is
not
supported
)
;
}
}
;
const
assertResultsEquals
=
(
toleranceFunc
actual
graphResources
intermediateOperands
)
=
>
{
const
operatorName
=
graphResources
.
operators
.
map
(
operator
=
>
operator
.
name
)
.
join
(
'
'
)
;
const
expectedOutputs
=
graphResources
.
expectedOutputs
;
const
toleranceInfo
=
toleranceFunc
(
graphResources
intermediateOperands
)
;
const
metricType
=
toleranceInfo
.
metricType
;
const
toleranceValue
=
toleranceInfo
.
value
;
let
outputData
;
for
(
let
operandName
in
actual
)
{
const
expectedSuboutput
=
expectedOutputs
[
operandName
]
;
const
expectedDescriptor
=
expectedSuboutput
.
descriptor
;
let
expectedData
=
expectedSuboutput
.
data
;
outputData
=
actual
[
operandName
]
;
if
(
typeof
(
expectedData
)
=
=
=
'
number
'
&
&
expectedDescriptor
.
shape
&
&
sizeOfShape
(
expectedDescriptor
.
shape
)
>
1
)
{
const
size
=
Math
.
min
(
kMaximumIndexToValidate
sizeOfShape
(
expectedDescriptor
.
shape
)
)
;
expectedData
=
new
Array
(
size
)
.
fill
(
expectedData
)
;
outputData
=
outputData
.
subarray
(
0
kMaximumIndexToValidate
)
;
}
else
if
(
expectedDescriptor
.
dataType
=
=
=
'
uint4
'
|
|
expectedDescriptor
.
dataType
=
=
=
'
int4
'
)
{
let
newOutputData
;
if
(
expectedDescriptor
.
dataType
=
=
=
'
uint4
'
)
{
newOutputData
=
new
Uint8Array
(
sizeOfShape
(
expectedDescriptor
.
shape
)
)
;
}
else
{
newOutputData
=
new
Int8Array
(
sizeOfShape
(
expectedDescriptor
.
shape
)
)
;
}
const
signMask
=
(
expectedDescriptor
.
dataType
=
=
=
'
int4
'
)
?
0x08
:
0x00
;
for
(
let
i
=
0
;
i
<
sizeOfShape
(
expectedDescriptor
.
shape
)
;
i
+
+
)
{
const
byteIndex
=
Math
.
floor
(
i
/
2
)
;
let
value
=
(
outputData
[
byteIndex
]
>
>
(
(
i
&
1
)
<
<
2
)
)
&
0xF
;
if
(
value
&
signMask
)
{
value
|
=
0xF0
;
}
newOutputData
[
i
]
=
value
;
}
outputData
=
newOutputData
;
}
doAssert
(
operatorName
outputData
expectedData
metricType
toleranceValue
expectedDescriptor
.
dataType
)
;
}
}
;
const
createOperand
=
(
context
builder
operandName
resources
)
=
>
{
let
operand
;
const
descriptor
=
resources
.
descriptor
;
const
dataType
=
descriptor
.
dataType
;
const
supportedDataTypes
=
resources
.
constant
?
context
.
opSupportLimits
(
)
.
constant
.
dataTypes
:
context
.
opSupportLimits
(
)
.
input
.
dataTypes
;
if
(
!
supportedDataTypes
.
includes
(
dataType
)
)
{
const
compatibleType
=
findCompatibleType
(
dataType
supportedDataTypes
context
.
opSupportLimits
(
)
.
cast
)
;
if
(
compatibleType
)
{
descriptor
.
castedType
=
compatibleType
;
descriptor
.
dataType
=
compatibleType
;
}
}
operand
=
resources
.
constant
?
builder
.
constant
(
descriptor
getTypedArrayData
(
descriptor
.
dataType
sizeOfShape
(
descriptor
.
shape
)
resources
.
data
)
)
:
builder
.
input
(
operandName
descriptor
)
;
if
(
descriptor
.
castedType
)
{
operand
=
builder
.
cast
(
operand
dataType
)
;
}
return
operand
;
}
;
async
function
createTensorWithData
(
context
dataType
shape
data
)
{
const
tensorDesc
=
{
dataType
shape
}
;
if
(
data
)
{
tensorDesc
.
writable
=
true
;
}
else
{
tensorDesc
.
readable
=
true
;
}
let
tensor
=
await
context
.
createTensor
(
tensorDesc
)
;
if
(
data
)
{
context
.
writeTensor
(
tensor
data
)
;
}
return
tensor
;
}
async
function
prepareInputsForGraph
(
context
resources
)
{
const
inputOperandNameArray
=
Object
.
keys
(
resources
)
.
filter
(
operandName
=
>
!
resources
[
operandName
]
.
constant
)
;
const
tensors
=
await
Promise
.
all
(
inputOperandNameArray
.
map
(
(
operandName
)
=
>
{
const
inputOperandResources
=
resources
[
operandName
]
;
const
descriptor
=
inputOperandResources
.
descriptor
;
const
targetDataType
=
descriptor
.
castedType
?
descriptor
.
castedType
:
descriptor
.
dataType
;
const
inputBuffer
=
getTypedArrayData
(
targetDataType
sizeOfShape
(
descriptor
.
shape
)
inputOperandResources
.
data
)
;
return
createTensorWithData
(
context
targetDataType
descriptor
.
shape
inputBuffer
)
;
}
)
)
;
const
inputs
=
{
}
;
inputOperandNameArray
.
forEach
(
(
name
index
)
=
>
inputs
[
name
]
=
tensors
[
index
]
)
;
return
inputs
;
}
async
function
prepareOutputsForGraph
(
context
resources
)
{
const
outputOperandNameArray
=
Object
.
keys
(
resources
)
;
const
tensors
=
await
Promise
.
all
(
outputOperandNameArray
.
map
(
(
operandName
)
=
>
{
const
descriptor
=
resources
[
operandName
]
.
descriptor
;
const
dataType
=
descriptor
.
castedType
?
descriptor
.
castedType
:
descriptor
.
dataType
;
return
createTensorWithData
(
context
dataType
descriptor
.
shape
)
;
}
)
)
;
const
outputs
=
{
}
;
outputOperandNameArray
.
forEach
(
(
name
index
)
=
>
outputs
[
name
]
=
tensors
[
index
]
)
;
return
outputs
;
}
function
getInputName
(
operatorArguments
operandName
)
{
for
(
let
argument
of
operatorArguments
)
{
const
name
=
Object
.
keys
(
argument
)
[
0
]
;
if
(
name
=
=
=
operandName
)
{
return
argument
[
operandName
]
;
}
else
if
(
name
=
=
=
'
options
'
)
{
if
(
Object
.
keys
(
argument
[
name
]
)
.
includes
(
operandName
)
)
{
return
argument
[
name
]
[
operandName
]
;
}
}
}
return
null
;
}
function
assert
(
condition
message
)
{
if
(
!
condition
)
{
throw
new
Error
(
Wrong
test
case
{
message
}
)
;
}
}
function
validateContextSupportsGraph
(
context
graph
)
{
const
supportLimits
=
context
.
opSupportLimits
(
)
;
const
inputDataTypes
=
supportLimits
.
input
.
dataTypes
;
const
constantDataTypes
=
supportLimits
.
constant
.
dataTypes
;
const
outputDataTypes
=
supportLimits
.
output
.
dataTypes
;
function
validateInputOrConstantDataType
(
inputName
operatorSupportLimits
operand
)
{
const
inputDataType
=
graph
.
inputs
[
inputName
]
.
descriptor
.
dataType
;
if
(
graph
.
inputs
[
inputName
]
.
constant
)
{
if
(
!
constantDataTypes
.
includes
(
inputDataType
)
)
{
throw
new
TypeError
(
Unsupported
data
type
constant
'
{
operand
}
'
data
type
{
inputDataType
}
must
be
one
of
[
{
constantDataTypes
}
]
.
)
;
}
}
else
{
if
(
!
inputDataTypes
.
includes
(
inputDataType
)
)
{
throw
new
TypeError
(
Unsupported
data
type
input
'
{
operand
}
'
data
type
{
inputDataType
}
must
be
one
of
[
{
inputDataTypes
}
]
.
)
;
}
}
if
(
!
operatorSupportLimits
[
operand
]
.
dataTypes
.
includes
(
inputDataType
)
)
{
throw
new
TypeError
(
Unsupported
data
type
input
'
{
operand
}
'
data
type
{
inputDataType
}
must
be
one
of
[
{
operatorSupportLimits
[
operand
]
.
dataTypes
}
]
.
)
;
}
}
function
validateOutputDataType
(
outputName
operatorSupportLimits
operand
)
{
const
outputDataType
=
graph
.
expectedOutputs
[
outputName
]
.
descriptor
.
dataType
;
if
(
!
outputDataTypes
.
includes
(
outputDataType
)
)
{
throw
new
TypeError
(
Unsupported
data
type
output
'
{
operand
}
'
data
type
{
outputDataType
}
must
be
one
of
[
{
outputDataTypes
}
]
.
)
;
}
if
(
!
operatorSupportLimits
[
operand
]
.
dataTypes
.
includes
(
outputDataType
)
)
{
throw
new
TypeError
(
Unsupported
data
type
output
'
{
operand
}
'
data
type
{
outputDataType
}
must
be
one
of
[
{
operatorSupportLimits
[
operand
]
.
dataTypes
}
]
.
)
;
}
}
for
(
let
operator
of
graph
.
operators
)
{
const
operatorName
=
operator
.
name
;
const
operatorSupportLimits
=
supportLimits
[
operatorName
]
;
for
(
let
operand
of
Object
.
keys
(
operatorSupportLimits
)
)
{
if
(
operand
=
=
=
'
output
'
)
{
assert
(
typeof
operator
.
outputs
=
=
=
'
string
'
the
outputs
of
{
operatorName
}
should
be
a
string
.
)
;
if
(
!
graph
.
expectedOutputs
[
operator
.
outputs
]
)
{
continue
;
}
validateOutputDataType
(
operator
.
outputs
operatorSupportLimits
'
output
'
)
;
}
else
if
(
operand
=
=
=
'
outputs
'
)
{
assert
(
Array
.
isArray
(
operator
.
outputs
)
the
outputs
of
{
operatorName
}
should
be
a
string
array
.
)
;
for
(
const
outputName
of
operator
.
outputs
)
{
assert
(
typeof
outputName
=
=
=
'
string
'
the
outputs
'
item
of
{
operatorName
}
should
be
a
string
.
)
;
if
(
!
graph
.
expectedOutputs
[
outputName
]
)
{
continue
;
}
validateOutputDataType
(
outputName
operatorSupportLimits
'
outputs
'
)
;
}
}
else
{
if
(
operatorName
=
=
=
'
concat
'
)
{
const
inputNameArray
=
operator
.
arguments
[
0
]
[
operand
]
;
assert
(
Array
.
isArray
(
inputNameArray
)
the
inputs
of
{
operatorName
}
should
be
a
string
array
.
)
;
for
(
const
inputName
of
inputNameArray
)
{
assert
(
typeof
inputName
=
=
=
'
string
'
the
inputs
'
item
of
{
operatorName
}
should
be
a
string
.
)
;
validateInputOrConstantDataType
(
inputName
operatorSupportLimits
'
inputs
'
)
;
}
}
else
{
const
inputName
=
getInputName
(
operator
.
arguments
operand
)
;
if
(
inputName
=
=
=
null
|
|
!
graph
.
inputs
[
inputName
]
)
{
continue
;
}
validateInputOrConstantDataType
(
inputName
operatorSupportLimits
operand
)
;
}
}
}
}
}
async
function
computeGraph
(
context
graph
graphInputs
expectedOutputs
)
{
const
inputs
=
await
prepareInputsForGraph
(
context
graphInputs
)
;
const
outputs
=
await
prepareOutputsForGraph
(
context
expectedOutputs
)
;
context
.
dispatch
(
graph
inputs
outputs
)
;
const
result
=
{
}
;
const
outputNameArray
=
Object
.
keys
(
expectedOutputs
)
;
const
outputBuffers
=
await
Promise
.
all
(
Object
.
values
(
outputs
)
.
map
(
(
tensor
)
=
>
{
return
context
.
readTensor
(
tensor
)
}
)
)
;
outputNameArray
.
forEach
(
(
name
index
)
=
>
{
const
dataType
=
expectedOutputs
[
name
]
.
descriptor
.
castedType
?
expectedOutputs
[
name
]
.
descriptor
.
castedType
:
expectedOutputs
[
name
]
.
descriptor
.
dataType
;
result
[
name
]
=
new
TypedArrayDict
[
dataType
]
(
outputBuffers
[
index
]
)
}
)
;
return
result
;
}
const
buildAndExecuteGraph
=
async
(
context
builder
graphResources
)
=
>
{
const
outputOperands
=
[
]
;
const
graphInputs
=
graphResources
.
inputs
;
const
graphOperators
=
graphResources
.
operators
;
const
intermediateOperands
=
{
}
;
for
(
const
operator
of
graphOperators
)
{
const
argumentArray
=
[
]
;
for
(
const
argument
of
operator
.
arguments
)
{
for
(
const
argumentName
in
argument
)
{
if
(
argumentName
!
=
=
'
options
'
)
{
if
(
graphInputs
.
hasOwnProperty
(
argument
[
argumentName
]
)
)
{
const
operandName
=
argument
[
argumentName
]
;
const
operand
=
createOperand
(
context
builder
operandName
graphInputs
[
operandName
]
)
;
argumentArray
.
push
(
operand
)
;
}
else
if
(
intermediateOperands
.
hasOwnProperty
(
argument
[
argumentName
]
)
)
{
argumentArray
.
push
(
intermediateOperands
[
argument
[
argumentName
]
]
)
;
}
else
{
argumentArray
.
push
(
argument
[
argumentName
]
)
;
}
}
else
{
for
(
const
[
optionalArgumentName
value
]
of
Object
.
entries
(
argument
[
'
options
'
]
)
)
{
if
(
typeof
value
=
=
=
'
string
'
&
&
graphInputs
.
hasOwnProperty
(
value
)
)
{
const
operandName
=
value
;
const
operand
=
createOperand
(
context
builder
operandName
graphInputs
[
operandName
]
)
;
argument
[
'
options
'
]
[
optionalArgumentName
]
=
operand
;
}
else
if
(
typeof
value
=
=
=
'
string
'
&
&
intermediateOperands
.
hasOwnProperty
(
value
)
)
{
argument
[
'
options
'
]
[
optionalArgumentName
]
=
intermediateOperands
[
value
]
;
}
}
argumentArray
.
push
(
argument
[
'
options
'
]
)
;
}
}
}
const
currentOutput
=
builder
[
operator
.
name
]
(
.
.
.
argumentArray
)
;
if
(
Array
.
isArray
(
operator
.
outputs
)
)
{
operator
.
outputs
.
forEach
(
(
outputName
index
)
=
>
{
intermediateOperands
[
outputName
]
=
currentOutput
[
index
]
;
}
)
;
}
else
{
intermediateOperands
[
operator
.
outputs
]
=
currentOutput
;
}
}
const
outputNames
=
Object
.
keys
(
graphResources
.
expectedOutputs
)
;
outputNames
.
forEach
(
outputName
=
>
{
if
(
intermediateOperands
.
hasOwnProperty
(
outputName
)
)
{
outputOperands
.
push
(
intermediateOperands
[
outputName
]
)
;
}
}
)
;
if
(
outputOperands
.
length
!
=
=
outputNames
.
length
)
{
throw
new
Error
(
'
Graph
outputs
are
not
properly
defined
'
)
;
}
for
(
let
i
=
0
;
i
<
outputOperands
.
length
;
+
+
i
)
{
const
expectedDescriptor
=
graphResources
.
expectedOutputs
[
Object
.
keys
(
graphResources
.
expectedOutputs
)
[
i
]
]
.
descriptor
;
if
(
!
context
.
opSupportLimits
(
)
.
output
.
dataTypes
.
includes
(
expectedDescriptor
.
dataType
)
)
{
const
compatibleType
=
findCompatibleType
(
expectedDescriptor
.
dataType
context
.
opSupportLimits
(
)
.
output
.
dataTypes
context
.
opSupportLimits
(
)
.
cast
)
;
outputOperands
[
i
]
=
builder
.
cast
(
outputOperands
[
i
]
compatibleType
)
;
expectedDescriptor
.
castedType
=
compatibleType
;
}
}
const
outputNameArray
=
Object
.
keys
(
graphResources
.
expectedOutputs
)
;
for
(
let
i
=
0
;
i
<
outputOperands
.
length
;
+
+
i
)
{
assertDescriptorsEquals
(
outputOperands
[
i
]
graphResources
.
expectedOutputs
[
outputNameArray
[
i
]
]
.
descriptor
)
;
}
const
namedOutputOperand
=
{
}
;
outputNameArray
.
forEach
(
(
name
index
)
=
>
namedOutputOperand
[
name
]
=
outputOperands
[
index
]
)
;
const
graph
=
await
builder
.
build
(
namedOutputOperand
)
;
const
result
=
await
computeGraph
(
context
graph
graphInputs
graphResources
.
expectedOutputs
)
;
return
{
result
intermediateOperands
}
;
}
;
const
getGemmPrecisionTolerance
=
(
op
graphResources
intermediateOperands
)
=
>
{
const
{
inputs
}
=
graphResources
;
const
args
=
op
.
arguments
;
let
ShapeA
;
const
indexA
=
args
[
0
]
[
Object
.
keys
(
args
[
0
]
)
[
0
]
]
;
if
(
inputs
[
indexA
]
)
{
ShapeA
=
inputs
[
indexA
]
.
descriptor
.
shape
;
}
else
{
ShapeA
=
intermediateOperands
[
indexA
]
.
shape
;
}
const
options
=
args
.
length
=
=
=
3
?
{
.
.
.
args
[
2
]
[
Object
.
keys
(
args
[
2
]
)
[
0
]
]
}
:
{
}
;
const
width
=
options
.
aTranspose
?
ShapeA
[
0
]
:
ShapeA
[
1
]
;
let
tolerance
=
width
*
2
;
if
(
options
.
alpha
!
=
=
undefined
&
&
options
.
alpha
!
=
=
1
.
0
)
{
tolerance
+
+
;
}
if
(
options
.
c
&
&
options
.
beta
!
=
=
0
.
0
)
{
if
(
options
.
beta
!
=
=
undefined
&
&
options
.
beta
!
=
=
1
.
0
)
{
tolerance
+
+
;
}
tolerance
+
+
;
}
const
toleranceValueDict
=
{
float32
:
tolerance
float16
:
tolerance
}
;
const
expectedDataType
=
getExpectedDataTypeOfSingleOutput
(
graphResources
.
expectedOutputs
)
;
return
{
metricType
:
'
ULP
'
value
:
toleranceValueDict
[
expectedDataType
]
}
;
}
;
const
getConv2dPrecisionTolerance
=
(
op
graphResources
intermediateOperands
)
=
>
{
const
{
inputs
}
=
graphResources
;
const
operatorName
=
op
.
name
;
const
args
=
op
.
arguments
;
let
inputShape
;
const
inputIndex
=
args
[
0
]
[
Object
.
keys
(
args
[
0
]
)
[
0
]
]
;
const
filterIndex
=
args
[
1
]
[
Object
.
keys
(
args
[
1
]
)
[
0
]
]
;
if
(
inputs
[
inputIndex
]
)
{
inputShape
=
inputs
[
inputIndex
]
.
descriptor
.
shape
;
}
else
{
inputShape
=
intermediateOperands
[
inputIndex
]
.
shape
;
}
let
filterShape
;
if
(
inputs
[
filterIndex
]
)
{
filterShape
=
inputs
[
filterIndex
]
.
descriptor
.
shape
;
}
else
{
filterShape
=
intermediateOperands
[
filterIndex
]
.
shape
;
}
const
options
=
args
.
length
=
=
=
3
?
{
.
.
.
args
[
2
]
[
Object
.
keys
(
args
[
2
]
)
[
0
]
]
}
:
{
}
;
let
inputChannels
=
inputShape
[
1
]
;
let
filterWidth
=
filterShape
[
3
]
;
let
filterHeight
=
filterShape
[
2
]
;
const
groups
=
options
.
groups
?
options
.
groups
:
1
;
if
(
options
.
inputLayout
)
{
if
(
!
[
'
nchw
'
'
nhwc
'
]
.
includes
(
options
.
inputLayout
)
)
{
throw
new
Error
(
Unknown
inputLayout
{
options
.
inputLayout
}
)
;
}
inputChannels
=
options
.
inputLayout
=
=
=
'
nchw
'
?
inputChannels
:
inputShape
[
3
]
;
}
if
(
options
.
filterLayout
)
{
let
filterLayouts
=
[
'
oihw
'
'
hwio
'
'
ohwi
'
'
ihwo
'
]
;
if
(
operatorName
=
=
=
'
convTranspose2d
'
)
{
filterLayouts
=
[
'
iohw
'
'
hwoi
'
'
ohwi
'
]
;
}
if
(
!
filterLayouts
.
includes
(
options
.
filterLayout
)
)
{
throw
new
Error
(
Unknown
filterLayout
{
options
.
filterLayout
}
)
;
}
switch
(
options
.
filterLayout
)
{
case
'
oihw
'
:
case
'
iohw
'
:
break
;
case
'
hwio
'
:
case
'
hwoi
'
:
filterWidth
=
filterShape
[
1
]
;
filterHeight
=
filterShape
[
0
]
;
break
;
case
'
ohwi
'
:
case
'
ihwo
'
:
filterWidth
=
filterShape
[
2
]
;
filterHeight
=
filterShape
[
1
]
;
break
;
default
:
break
;
}
}
const
tolerance
=
filterWidth
*
filterHeight
*
(
inputChannels
/
groups
)
*
2
;
const
toleranceValueDict
=
{
float32
:
tolerance
float16
:
tolerance
}
;
const
expectedDataType
=
getExpectedDataTypeOfSingleOutput
(
graphResources
.
expectedOutputs
)
;
return
{
metricType
:
'
ULP
'
value
:
toleranceValueDict
[
expectedDataType
]
}
;
}
;
const
getExpectedDataTypeOfSingleOutput
=
(
expectedOutput
)
=
>
{
const
expectedDescriptor
=
expectedOutput
[
Object
.
keys
(
expectedOutput
)
[
0
]
]
.
descriptor
;
const
dataType
=
expectedDescriptor
.
castedType
?
expectedDescriptor
.
castedType
:
expectedDescriptor
.
dataType
;
return
dataType
;
}
;
const
getReducedElementCount
=
(
graphResources
)
=
>
{
const
args
=
graphResources
.
operators
[
0
]
.
arguments
;
const
inputShape
=
graphResources
.
inputs
[
args
[
0
]
[
Object
.
keys
(
args
[
0
]
)
[
0
]
]
]
.
descriptor
.
shape
;
const
rank
=
inputShape
.
length
;
const
options
=
args
.
length
=
=
=
2
?
{
.
.
.
args
[
1
]
[
Object
.
keys
(
args
[
1
]
)
[
0
]
]
}
:
{
}
;
let
sizes
;
if
(
options
&
&
options
.
axes
)
{
sizes
=
options
.
axes
.
map
(
(
axis
)
=
>
axis
<
0
?
inputShape
[
axis
+
rank
]
:
inputShape
[
axis
]
)
;
}
else
{
sizes
=
inputShape
;
}
return
sizes
.
length
?
sizes
.
reduce
(
(
accumulator
currentValue
)
=
>
accumulator
*
currentValue
)
:
1
;
}
;
const
webnn_conformance_test
=
(
buildAndExecuteGraphFunc
toleranceFunc
testResources
cast_to_supported_type
=
false
)
=
>
{
promise_test
(
async
(
)
=
>
{
let
context
;
try
{
context
=
await
navigator
.
ml
.
createContext
(
contextOptions
)
;
}
catch
(
e
)
{
throw
new
AssertionError
(
Unable
to
create
context
for
{
variant
}
variant
.
{
e
}
)
;
}
if
(
!
cast_to_supported_type
)
{
validateContextSupportsGraph
(
context
testResources
.
graph
)
;
}
const
builder
=
new
MLGraphBuilder
(
context
)
;
const
{
result
intermediateOperands
}
=
await
buildAndExecuteGraphFunc
(
context
builder
testResources
.
graph
)
;
assertResultsEquals
(
toleranceFunc
result
testResources
.
graph
intermediateOperands
)
;
}
testResources
.
name
)
;
}
;
