'
use
strict
'
;
const
getLstmCellPrecisionTolerance
=
(
graphResources
)
=
>
{
const
toleranceValueDict
=
{
float32
:
1
}
;
const
expectedDataType
=
graphResources
.
expectedOutputs
[
Object
.
keys
(
graphResources
.
expectedOutputs
)
[
0
]
]
.
descriptor
.
dataType
;
return
{
metricType
:
'
ULP
'
value
:
toleranceValueDict
[
expectedDataType
]
}
;
}
;
const
lstmCellTests
=
[
{
'
name
'
:
'
lstmCell
float32
tensors
with
options
.
bias
options
.
recurrentBias
and
options
.
activations
=
[
\
'
relu
\
'
\
'
relu
\
'
\
'
relu
\
'
]
'
'
graph
'
:
{
'
inputs
'
:
{
'
lstmCellInput
'
:
{
'
data
'
:
[
1
2
2
1
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellWeight
'
:
{
'
data
'
:
[
1
-
1
2
-
2
1
-
1
2
-
2
1
-
1
2
-
2
1
-
1
2
-
2
]
'
descriptor
'
:
{
shape
:
[
8
2
]
dataType
:
'
float32
'
}
}
'
lstmCellRecurrentWeight
'
:
{
'
data
'
:
[
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
]
'
descriptor
'
:
{
shape
:
[
8
2
]
dataType
:
'
float32
'
}
}
'
lstmCellHiddenState
'
:
{
'
data
'
:
[
0
0
0
0
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellCellState
'
:
{
'
data
'
:
[
0
0
0
0
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellBias
'
:
{
'
data
'
:
[
1
2
1
2
1
2
1
2
]
'
descriptor
'
:
{
shape
:
[
8
]
dataType
:
'
float32
'
}
}
'
lstmCellRecurrentBias
'
:
{
'
data
'
:
[
1
2
1
2
1
2
1
2
]
'
descriptor
'
:
{
shape
:
[
8
]
dataType
:
'
float32
'
}
}
}
'
operators
'
:
[
{
'
name
'
:
'
lstmCell
'
'
arguments
'
:
[
{
'
input
'
:
'
lstmCellInput
'
}
{
'
weight
'
:
'
lstmCellWeight
'
}
{
'
recurrentWeight
'
:
'
lstmCellRecurrentWeight
'
}
{
'
hiddenState
'
:
'
lstmCellHiddenState
'
}
{
'
cellState
'
:
'
lstmCellCellState
'
}
{
'
hiddenSize
'
:
2
}
{
'
options
'
:
{
'
bias
'
:
'
lstmCellBias
'
'
recurrentBias
'
:
'
lstmCellRecurrentBias
'
'
activations
'
:
[
'
relu
'
'
relu
'
'
relu
'
]
}
}
]
'
outputs
'
:
[
'
lstmCellOutput1
'
'
lstmCellOutput2
'
]
}
]
'
expectedOutputs
'
:
{
'
lstmCellOutput1
'
:
{
'
data
'
:
[
1
8
27
216
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellOutput2
'
:
{
'
data
'
:
[
1
4
9
36
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
}
}
}
{
'
name
'
:
'
lstmCell
float32
tensors
with
options
.
bias
options
.
recurrentBias
options
.
activations
=
[
\
'
relu
\
'
\
'
relu
\
'
\
'
relu
\
'
]
and
options
.
peepholeWeight
'
'
graph
'
:
{
'
inputs
'
:
{
'
lstmCellInput
'
:
{
'
data
'
:
[
1
2
2
1
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellWeight
'
:
{
'
data
'
:
[
1
-
1
2
-
2
1
-
1
2
-
2
1
-
1
2
-
2
1
-
1
2
-
2
]
'
descriptor
'
:
{
shape
:
[
8
2
]
dataType
:
'
float32
'
}
}
'
lstmCellRecurrentWeight
'
:
{
'
data
'
:
[
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
]
'
descriptor
'
:
{
shape
:
[
8
2
]
dataType
:
'
float32
'
}
}
'
lstmCellHiddenState
'
:
{
'
data
'
:
[
0
0
0
0
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellCellState
'
:
{
'
data
'
:
[
0
0
0
0
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellBias
'
:
{
'
data
'
:
[
1
2
1
2
1
2
1
2
]
'
descriptor
'
:
{
shape
:
[
8
]
dataType
:
'
float32
'
}
}
'
lstmCellRecurrentBias
'
:
{
'
data
'
:
[
1
2
1
2
1
2
1
2
]
'
descriptor
'
:
{
shape
:
[
8
]
dataType
:
'
float32
'
}
}
'
lstmCellPeepholeWeight
'
:
{
'
data
'
:
[
0
0
0
0
0
0
]
'
descriptor
'
:
{
shape
:
[
6
]
dataType
:
'
float32
'
}
}
}
'
operators
'
:
[
{
'
name
'
:
'
lstmCell
'
'
arguments
'
:
[
{
'
input
'
:
'
lstmCellInput
'
}
{
'
weight
'
:
'
lstmCellWeight
'
}
{
'
recurrentWeight
'
:
'
lstmCellRecurrentWeight
'
}
{
'
hiddenState
'
:
'
lstmCellHiddenState
'
}
{
'
cellState
'
:
'
lstmCellCellState
'
}
{
'
hiddenSize
'
:
2
}
{
'
options
'
:
{
'
bias
'
:
'
lstmCellBias
'
'
recurrentBias
'
:
'
lstmCellRecurrentBias
'
'
peepholeWeight
'
:
'
lstmCellPeepholeWeight
'
'
activations
'
:
[
'
relu
'
'
relu
'
'
relu
'
]
}
}
]
'
outputs
'
:
[
'
lstmCellOutput1
'
'
lstmCellOutput2
'
]
}
]
'
expectedOutputs
'
:
{
'
lstmCellOutput1
'
:
{
'
data
'
:
[
1
8
27
216
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellOutput2
'
:
{
'
data
'
:
[
1
4
9
36
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
}
}
}
{
'
name
'
:
'
lstmCell
float32
tensors
with
options
.
bias
options
.
recurrentBias
options
.
activations
=
[
\
'
relu
\
'
\
'
relu
\
'
\
'
relu
\
'
]
and
explicit
options
.
layout
=
\
'
iofg
\
'
'
'
graph
'
:
{
'
inputs
'
:
{
'
lstmCellInput
'
:
{
'
data
'
:
[
1
2
2
1
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellWeight
'
:
{
'
data
'
:
[
1
-
1
2
-
2
1
-
1
2
-
2
1
-
1
2
-
2
1
-
1
2
-
2
]
'
descriptor
'
:
{
shape
:
[
8
2
]
dataType
:
'
float32
'
}
}
'
lstmCellRecurrentWeight
'
:
{
'
data
'
:
[
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
]
'
descriptor
'
:
{
shape
:
[
8
2
]
dataType
:
'
float32
'
}
}
'
lstmCellHiddenState
'
:
{
'
data
'
:
[
0
0
0
0
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellCellState
'
:
{
'
data
'
:
[
0
0
0
0
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellBias
'
:
{
'
data
'
:
[
1
2
1
2
1
2
1
2
]
'
descriptor
'
:
{
shape
:
[
8
]
dataType
:
'
float32
'
}
}
'
lstmCellRecurrentBias
'
:
{
'
data
'
:
[
1
2
1
2
1
2
1
2
]
'
descriptor
'
:
{
shape
:
[
8
]
dataType
:
'
float32
'
}
}
}
'
operators
'
:
[
{
'
name
'
:
'
lstmCell
'
'
arguments
'
:
[
{
'
input
'
:
'
lstmCellInput
'
}
{
'
weight
'
:
'
lstmCellWeight
'
}
{
'
recurrentWeight
'
:
'
lstmCellRecurrentWeight
'
}
{
'
hiddenState
'
:
'
lstmCellHiddenState
'
}
{
'
cellState
'
:
'
lstmCellCellState
'
}
{
'
hiddenSize
'
:
2
}
{
'
options
'
:
{
'
bias
'
:
'
lstmCellBias
'
'
recurrentBias
'
:
'
lstmCellRecurrentBias
'
'
layout
'
:
'
iofg
'
'
activations
'
:
[
'
relu
'
'
relu
'
'
relu
'
]
}
}
]
'
outputs
'
:
[
'
lstmCellOutput1
'
'
lstmCellOutput2
'
]
}
]
'
expectedOutputs
'
:
{
'
lstmCellOutput1
'
:
{
'
data
'
:
[
1
8
27
216
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellOutput2
'
:
{
'
data
'
:
[
1
4
9
36
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
}
}
}
{
'
name
'
:
'
lstmCell
float32
tensors
with
options
.
bias
options
.
recurrentBias
options
.
activations
=
[
\
'
relu
\
'
\
'
relu
\
'
\
'
relu
\
'
]
and
options
.
layout
=
\
'
ifgo
\
'
'
'
graph
'
:
{
'
inputs
'
:
{
'
lstmCellInput
'
:
{
'
data
'
:
[
1
2
2
1
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellWeight
'
:
{
'
data
'
:
[
1
-
1
2
-
2
1
-
1
2
-
2
1
-
1
2
-
2
1
-
1
2
-
2
]
'
descriptor
'
:
{
shape
:
[
8
2
]
dataType
:
'
float32
'
}
}
'
lstmCellRecurrentWeight
'
:
{
'
data
'
:
[
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
]
'
descriptor
'
:
{
shape
:
[
8
2
]
dataType
:
'
float32
'
}
}
'
lstmCellHiddenState
'
:
{
'
data
'
:
[
0
0
0
0
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellCellState
'
:
{
'
data
'
:
[
0
0
0
0
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellBias
'
:
{
'
data
'
:
[
1
2
1
2
1
2
1
2
]
'
descriptor
'
:
{
shape
:
[
8
]
dataType
:
'
float32
'
}
}
'
lstmCellRecurrentBias
'
:
{
'
data
'
:
[
1
2
1
2
1
2
1
2
]
'
descriptor
'
:
{
shape
:
[
8
]
dataType
:
'
float32
'
}
}
}
'
operators
'
:
[
{
'
name
'
:
'
lstmCell
'
'
arguments
'
:
[
{
'
input
'
:
'
lstmCellInput
'
}
{
'
weight
'
:
'
lstmCellWeight
'
}
{
'
recurrentWeight
'
:
'
lstmCellRecurrentWeight
'
}
{
'
hiddenState
'
:
'
lstmCellHiddenState
'
}
{
'
cellState
'
:
'
lstmCellCellState
'
}
{
'
hiddenSize
'
:
2
}
{
'
options
'
:
{
'
bias
'
:
'
lstmCellBias
'
'
recurrentBias
'
:
'
lstmCellRecurrentBias
'
'
layout
'
:
'
ifgo
'
'
activations
'
:
[
'
relu
'
'
relu
'
'
relu
'
]
}
}
]
'
outputs
'
:
[
'
lstmCellOutput1
'
'
lstmCellOutput2
'
]
}
]
'
expectedOutputs
'
:
{
'
lstmCellOutput1
'
:
{
'
data
'
:
[
1
8
27
216
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellOutput2
'
:
{
'
data
'
:
[
1
4
9
36
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
}
}
}
{
'
name
'
:
'
lstmCell
float32
tensors
with
all
options
'
'
graph
'
:
{
'
inputs
'
:
{
'
lstmCellInput
'
:
{
'
data
'
:
[
1
2
2
1
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellWeight
'
:
{
'
data
'
:
[
1
-
1
2
-
2
1
-
1
2
-
2
1
-
1
2
-
2
1
-
1
2
-
2
]
'
descriptor
'
:
{
shape
:
[
8
2
]
dataType
:
'
float32
'
}
}
'
lstmCellRecurrentWeight
'
:
{
'
data
'
:
[
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
0
.
1
]
'
descriptor
'
:
{
shape
:
[
8
2
]
dataType
:
'
float32
'
}
}
'
lstmCellHiddenState
'
:
{
'
data
'
:
[
0
0
0
0
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellCellState
'
:
{
'
data
'
:
[
0
0
0
0
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellBias
'
:
{
'
data
'
:
[
1
2
1
2
1
2
1
2
]
'
descriptor
'
:
{
shape
:
[
8
]
dataType
:
'
float32
'
}
}
'
lstmCellRecurrentBias
'
:
{
'
data
'
:
[
1
2
1
2
1
2
1
2
]
'
descriptor
'
:
{
shape
:
[
8
]
dataType
:
'
float32
'
}
}
'
lstmCellPeepholeWeight
'
:
{
'
data
'
:
[
0
0
0
0
0
0
]
'
descriptor
'
:
{
shape
:
[
6
]
dataType
:
'
float32
'
}
}
}
'
operators
'
:
[
{
'
name
'
:
'
lstmCell
'
'
arguments
'
:
[
{
'
input
'
:
'
lstmCellInput
'
}
{
'
weight
'
:
'
lstmCellWeight
'
}
{
'
recurrentWeight
'
:
'
lstmCellRecurrentWeight
'
}
{
'
hiddenState
'
:
'
lstmCellHiddenState
'
}
{
'
cellState
'
:
'
lstmCellCellState
'
}
{
'
hiddenSize
'
:
2
}
{
'
options
'
:
{
'
bias
'
:
'
lstmCellBias
'
'
recurrentBias
'
:
'
lstmCellRecurrentBias
'
'
peepholeWeight
'
:
'
lstmCellPeepholeWeight
'
'
layout
'
:
'
iofg
'
'
activations
'
:
[
'
relu
'
'
relu
'
'
relu
'
]
}
}
]
'
outputs
'
:
[
'
lstmCellOutput1
'
'
lstmCellOutput2
'
]
}
]
'
expectedOutputs
'
:
{
'
lstmCellOutput1
'
:
{
'
data
'
:
[
1
8
27
216
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
'
lstmCellOutput2
'
:
{
'
data
'
:
[
1
4
9
36
]
'
descriptor
'
:
{
shape
:
[
2
2
]
dataType
:
'
float32
'
}
}
}
}
}
]
;
if
(
navigator
.
ml
)
{
lstmCellTests
.
forEach
(
(
test
)
=
>
{
webnn_conformance_test
(
buildGraphAndCompute
getLstmCellPrecisionTolerance
test
)
;
}
)
;
}
else
{
test
(
(
)
=
>
assert_implements
(
navigator
.
ml
'
missing
navigator
.
ml
'
)
)
;
}
