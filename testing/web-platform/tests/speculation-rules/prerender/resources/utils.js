const
STORE_URL
=
'
/
speculation
-
rules
/
prerender
/
resources
/
key
-
value
-
store
.
py
'
;
function
startPrerendering
(
url
rule_extras
=
{
}
)
{
const
script
=
document
.
createElement
(
'
script
'
)
;
script
.
type
=
'
speculationrules
'
;
script
.
text
=
JSON
.
stringify
(
{
prerender
:
[
{
source
:
'
list
'
urls
:
[
url
]
.
.
.
rule_extras
}
]
}
)
;
document
.
head
.
appendChild
(
script
)
;
}
class
PrerenderChannel
extends
EventTarget
{
#
ids
=
new
Set
(
)
;
#
url
;
#
active
=
true
;
constructor
(
name
uid
=
new
URLSearchParams
(
location
.
search
)
.
get
(
'
uid
'
)
)
{
super
(
)
;
this
.
#
url
=
/
speculation
-
rules
/
prerender
/
resources
/
deprecated
-
broadcast
-
channel
.
py
?
name
=
{
name
}
&
uid
=
{
uid
}
;
(
async
(
)
=
>
{
while
(
this
.
#
active
)
{
const
messages
=
await
(
await
fetch
(
this
.
#
url
{
keepalive
:
true
}
)
)
.
json
(
)
;
for
(
const
{
data
id
}
of
messages
)
{
if
(
!
this
.
#
ids
.
has
(
id
)
)
this
.
dispatchEvent
(
new
MessageEvent
(
'
message
'
{
data
}
)
)
;
this
.
#
ids
.
add
(
id
)
;
}
}
}
)
(
)
;
}
close
(
)
{
this
.
#
active
=
false
;
}
set
onmessage
(
m
)
{
this
.
addEventListener
(
'
message
'
m
)
}
async
postMessage
(
data
)
{
const
id
=
new
Date
(
)
.
valueOf
(
)
;
this
.
#
ids
.
add
(
id
)
;
await
fetch
(
this
.
#
url
{
method
:
'
POST
'
body
:
JSON
.
stringify
(
{
data
id
}
)
keepalive
:
true
}
)
;
}
}
async
function
readValueFromServer
(
key
)
{
const
serverUrl
=
{
STORE_URL
}
?
key
=
{
key
}
;
const
response
=
await
fetch
(
serverUrl
)
;
if
(
!
response
.
ok
)
throw
new
Error
(
'
An
error
happened
in
the
server
'
)
;
const
value
=
await
response
.
text
(
)
;
if
(
value
=
=
=
"
"
)
return
{
status
:
false
}
;
return
{
status
:
true
value
:
value
}
;
}
async
function
nextValueFromServer
(
key
)
{
let
retry
=
0
;
while
(
true
)
{
let
success
=
true
;
const
{
status
value
}
=
await
readValueFromServer
(
key
)
.
catch
(
e
=
>
{
if
(
retry
+
+
>
=
5
)
{
throw
new
Error
(
'
readValueFromServer
failed
'
)
;
}
success
=
false
;
}
)
;
if
(
!
success
|
|
!
status
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
100
)
)
;
continue
;
}
return
value
;
}
}
async
function
writeValueToServer
(
key
value
)
{
const
serverUrl
=
{
STORE_URL
}
?
key
=
{
key
}
&
value
=
{
value
}
;
await
fetch
(
serverUrl
)
;
}
function
loadInitiatorPage
(
rule_extras
=
{
}
)
{
const
prerenderChannel
=
new
PrerenderChannel
(
'
prerender
-
channel
'
)
;
window
.
addEventListener
(
'
unload
'
(
)
=
>
{
prerenderChannel
.
close
(
)
;
}
)
;
const
readyToActivate
=
new
Promise
(
(
resolve
reject
)
=
>
{
prerenderChannel
.
addEventListener
(
'
message
'
e
=
>
{
if
(
e
.
data
!
=
'
readyToActivate
'
)
reject
(
The
initiator
page
receives
an
unsupported
message
:
{
e
.
data
}
)
;
resolve
(
e
.
data
)
;
}
)
;
}
)
;
const
url
=
new
URL
(
document
.
URL
)
;
url
.
searchParams
.
append
(
'
prerendering
'
'
'
)
;
startPrerendering
(
url
.
toString
(
)
rule_extras
)
;
readyToActivate
.
then
(
(
)
=
>
{
if
(
rule_extras
[
'
target_hint
'
]
=
=
=
'
_blank
'
)
{
window
.
open
(
url
.
toString
(
)
'
_blank
'
'
noopener
'
)
;
}
else
{
window
.
location
=
url
.
toString
(
)
;
}
}
)
.
catch
(
e
=
>
{
const
testChannel
=
new
PrerenderChannel
(
'
test
-
channel
'
)
;
testChannel
.
postMessage
(
Failed
to
navigate
the
prerendered
page
:
{
e
.
toString
(
)
}
)
;
testChannel
.
close
(
)
;
window
.
close
(
)
;
}
)
;
}
class
BroadcastMessageQueue
{
constructor
(
c
)
{
this
.
messages
=
[
]
;
this
.
resolveFunctions
=
[
]
;
this
.
channel
=
c
;
this
.
channel
.
addEventListener
(
'
message
'
e
=
>
{
if
(
this
.
resolveFunctions
.
length
>
0
)
{
const
fn
=
this
.
resolveFunctions
.
shift
(
)
;
fn
(
e
.
data
)
;
}
else
{
this
.
messages
.
push
(
e
.
data
)
;
}
}
)
;
}
nextMessage
(
)
{
return
new
Promise
(
resolve
=
>
{
if
(
this
.
messages
.
length
>
0
)
resolve
(
this
.
messages
.
shift
(
)
)
else
this
.
resolveFunctions
.
push
(
resolve
)
;
}
)
;
}
}
function
createFrame
(
url
)
{
return
new
Promise
(
resolve
=
>
{
const
frame
=
document
.
createElement
(
'
iframe
'
)
;
frame
.
src
=
url
;
frame
.
onload
=
(
)
=
>
resolve
(
frame
)
;
document
.
body
.
appendChild
(
frame
)
;
}
)
;
}
async
function
create_prerendered_page
(
t
opt
=
{
}
init_opt
=
{
}
rule_extras
=
{
}
)
{
const
baseUrl
=
'
/
speculation
-
rules
/
prerender
/
resources
/
exec
.
py
'
;
const
init_uuid
=
token
(
)
;
const
prerender_uuid
=
token
(
)
;
const
discard_uuid
=
token
(
)
;
const
init_remote
=
new
RemoteContext
(
init_uuid
)
;
const
prerender_remote
=
new
RemoteContext
(
prerender_uuid
)
;
const
discard_remote
=
new
RemoteContext
(
discard_uuid
)
;
const
init_params
=
new
URLSearchParams
(
baseUrl
.
search
)
;
init_params
.
set
(
'
uuid
'
init_uuid
)
;
for
(
const
p
in
init_opt
)
init_params
.
set
(
p
init_opt
[
p
]
)
;
window
.
open
(
{
baseUrl
}
?
{
init_params
.
toString
(
)
}
&
init
'
_blank
'
'
noopener
'
)
;
const
params
=
new
URLSearchParams
(
baseUrl
.
search
)
;
params
.
set
(
'
uuid
'
prerender_uuid
)
;
params
.
set
(
'
discard_uuid
'
discard_uuid
)
;
for
(
const
p
in
opt
)
params
.
set
(
p
opt
[
p
]
)
;
const
url
=
{
baseUrl
}
?
{
params
.
toString
(
)
}
;
if
(
init_opt
.
prefetch
)
{
await
init_remote
.
execute_script
(
(
url
rule_extras
)
=
>
{
const
a
=
document
.
createElement
(
'
a
'
)
;
a
.
href
=
url
;
a
.
innerText
=
'
Activate
(
prefetch
)
'
;
document
.
body
.
appendChild
(
a
)
;
const
rules
=
document
.
createElement
(
'
script
'
)
;
rules
.
type
=
"
speculationrules
"
;
rules
.
text
=
JSON
.
stringify
(
{
prefetch
:
[
{
source
:
'
list
'
urls
:
[
url
]
.
.
.
rule_extras
}
]
}
)
;
document
.
head
.
appendChild
(
rules
)
;
}
[
url
rule_extras
]
)
;
await
new
Promise
(
resolve
=
>
t
.
step_timeout
(
resolve
3000
)
)
;
}
await
init_remote
.
execute_script
(
(
url
rule_extras
)
=
>
{
const
a
=
document
.
createElement
(
'
a
'
)
;
a
.
href
=
url
;
a
.
innerText
=
'
Activate
'
;
document
.
body
.
appendChild
(
a
)
;
const
rules
=
document
.
createElement
(
'
script
'
)
;
rules
.
type
=
"
speculationrules
"
;
rules
.
text
=
JSON
.
stringify
(
{
prerender
:
[
{
source
:
'
list
'
urls
:
[
url
]
.
.
.
rule_extras
}
]
}
)
;
document
.
head
.
appendChild
(
rules
)
;
}
[
url
rule_extras
]
)
;
await
Promise
.
any
(
[
prerender_remote
.
execute_script
(
(
)
=
>
{
window
.
import_script_to_prerendered_page
=
src
=
>
{
const
script
=
document
.
createElement
(
'
script
'
)
;
script
.
src
=
src
;
document
.
head
.
appendChild
(
script
)
;
return
new
Promise
(
resolve
=
>
script
.
addEventListener
(
'
load
'
resolve
)
)
;
}
}
)
new
Promise
(
r
=
>
t
.
step_timeout
(
r
3000
)
)
]
)
;
t
.
add_cleanup
(
(
)
=
>
{
init_remote
.
execute_script
(
(
)
=
>
window
.
close
(
)
)
;
discard_remote
.
execute_script
(
(
)
=
>
window
.
close
(
)
)
;
prerender_remote
.
execute_script
(
(
)
=
>
window
.
close
(
)
)
;
}
)
;
async
function
tryToActivate
(
)
{
const
prerendering
=
prerender_remote
.
execute_script
(
(
)
=
>
new
Promise
(
resolve
=
>
{
if
(
!
document
.
prerendering
)
resolve
(
'
activated
'
)
;
else
document
.
addEventListener
(
'
prerenderingchange
'
(
)
=
>
resolve
(
'
activated
'
)
)
;
}
)
)
;
const
discarded
=
discard_remote
.
execute_script
(
(
)
=
>
Promise
.
resolve
(
'
discarded
'
)
)
;
init_remote
.
execute_script
(
url
=
>
{
location
.
href
=
url
;
}
[
url
]
)
;
return
Promise
.
any
(
[
prerendering
discarded
]
)
;
}
async
function
activate
(
)
{
const
prerendering
=
await
tryToActivate
(
)
;
if
(
prerendering
!
=
=
'
activated
'
)
throw
new
Error
(
'
Should
not
be
prerendering
at
this
point
'
)
}
async
function
getNetworkRequestCount
(
)
{
return
await
(
await
fetch
(
url
+
'
&
get
-
fetch
-
count
'
)
)
.
text
(
)
;
}
return
{
exec
:
(
fn
args
)
=
>
prerender_remote
.
execute_script
(
fn
args
)
activate
tryToActivate
getNetworkRequestCount
}
;
}
function
test_prerender_restricted
(
fn
expected
label
)
{
promise_test
(
async
t
=
>
{
const
{
exec
}
=
await
create_prerendered_page
(
t
)
;
let
result
=
null
;
try
{
await
exec
(
fn
)
;
result
=
"
OK
"
;
}
catch
(
e
)
{
result
=
e
.
name
;
}
assert_equals
(
result
expected
)
;
}
label
)
;
}
function
test_prerender_defer
(
fn
label
)
{
promise_test
(
async
t
=
>
{
const
{
exec
activate
}
=
await
create_prerendered_page
(
t
)
;
let
activated
=
false
;
const
deferred
=
exec
(
fn
)
;
const
post
=
new
Promise
(
resolve
=
>
deferred
.
then
(
result
=
>
{
assert_true
(
activated
"
Deferred
operation
should
occur
only
after
activation
"
)
;
resolve
(
result
)
;
}
)
)
;
await
activate
(
)
;
activated
=
true
;
await
post
;
}
label
)
;
}
function
addPrerenderRC
(
referrerRemoteContext
extraConfig
)
{
return
referrerRemoteContext
.
helper
.
createContext
(
{
executorCreator
(
url
)
{
return
referrerRemoteContext
.
executeScript
(
url
=
>
{
const
script
=
document
.
createElement
(
"
script
"
)
;
script
.
type
=
"
speculationrules
"
;
script
.
textContent
=
JSON
.
stringify
(
{
prerender
:
[
{
source
:
"
list
"
urls
:
[
url
]
}
]
}
)
;
document
.
head
.
append
(
script
)
;
}
[
url
]
)
;
}
extraConfig
}
)
;
}
async
function
activatePrerenderRC
(
referrerRC
prerenderedRC
navigateFn
)
{
await
prerenderedRC
.
executeScript
(
(
)
=
>
{
window
.
activatedPromise
=
new
Promise
(
resolve
=
>
{
document
.
addEventListener
(
"
prerenderingchange
"
(
)
=
>
resolve
(
"
activated
"
)
)
;
}
)
;
}
)
;
if
(
navigateFn
=
=
=
undefined
)
{
referrerRC
.
navigateTo
(
prerenderedRC
.
url
)
;
}
else
{
referrerRC
.
navigate
(
navigateFn
[
prerenderedRC
.
url
]
)
;
}
assert_equals
(
await
prerenderedRC
.
executeScript
(
(
)
=
>
window
.
activatedPromise
)
"
activated
"
"
The
prerendered
page
must
be
activated
;
instead
a
normal
navigation
happened
.
"
)
;
}
async
function
getActivationStart
(
prerenderedRC
)
{
return
await
prerenderedRC
.
executeScript
(
(
)
=
>
{
const
entry
=
performance
.
getEntriesByType
(
"
navigation
"
)
[
0
]
;
return
entry
.
activationStart
;
}
)
;
;
}
function
failTest
(
reason
uid
)
{
const
bc
=
new
PrerenderChannel
(
'
test
-
channel
'
uid
)
;
bc
.
postMessage
(
{
result
:
'
FAILED
'
reason
}
)
;
bc
.
close
(
)
;
}
function
getTargetHint
(
)
{
const
params
=
new
URLSearchParams
(
window
.
location
.
search
)
;
const
target_hint
=
params
.
get
(
'
target_hint
'
)
;
if
(
target_hint
=
=
=
null
)
throw
new
Error
(
'
window
.
location
does
not
have
a
target
hint
param
'
)
;
if
(
target_hint
!
=
=
'
_self
'
&
&
target_hint
!
=
=
'
_blank
'
)
throw
new
Error
(
'
window
.
location
does
not
have
a
valid
target
hint
param
'
)
;
return
target_hint
;
}
