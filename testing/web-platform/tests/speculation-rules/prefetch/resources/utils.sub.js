const
SR_PREFETCH_UTILS_URL
=
new
URL
(
document
.
currentScript
.
src
document
.
baseURI
)
;
const
PREFETCH_PROXY_BYPASS_HOST
=
"
{
{
hosts
[
alt
]
[
]
}
}
"
;
class
PrefetchAgent
extends
RemoteContext
{
constructor
(
uuid
t
)
{
super
(
uuid
)
;
this
.
t
=
t
;
}
getExecutorURL
(
options
=
{
}
)
{
let
{
hostname
username
password
protocol
executor
.
.
.
extra
}
=
options
;
let
params
=
new
URLSearchParams
(
{
uuid
:
this
.
context_id
.
.
.
extra
}
)
;
if
(
executor
=
=
=
undefined
)
{
executor
=
"
executor
.
sub
.
html
"
;
}
let
url
=
new
URL
(
{
executor
}
?
{
params
}
SR_PREFETCH_UTILS_URL
)
;
if
(
hostname
!
=
=
undefined
)
{
url
.
hostname
=
hostname
;
}
if
(
username
!
=
=
undefined
)
{
url
.
username
=
username
;
}
if
(
password
!
=
=
undefined
)
{
url
.
password
=
password
;
}
if
(
protocol
!
=
=
undefined
)
{
url
.
protocol
=
protocol
;
url
.
port
=
protocol
=
=
=
"
https
"
?
"
{
{
ports
[
https
]
[
0
]
}
}
"
:
"
{
{
ports
[
http
]
[
0
]
}
}
"
;
}
return
url
;
}
async
forceSinglePrefetch
(
url
extra
=
{
}
wait_for_completion
=
true
)
{
return
this
.
forceSpeculationRules
(
{
prefetch
:
[
{
source
:
'
list
'
urls
:
[
url
]
.
.
.
extra
}
]
}
wait_for_completion
)
;
}
async
forceSpeculationRules
(
rules
wait_for_completion
=
true
)
{
await
this
.
execute_script
(
(
rules
)
=
>
{
insertSpeculationRules
(
rules
)
;
}
[
rules
]
)
;
if
(
!
wait_for_completion
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
this
.
t
.
step_timeout
(
resolve
2000
)
)
;
}
async
navigate
(
url
{
expectedDestinationUrl
}
=
{
}
)
{
await
this
.
execute_script
(
(
url
)
=
>
{
window
.
executor
.
suspend
(
(
)
=
>
{
location
.
href
=
url
;
}
)
;
}
[
url
]
)
;
if
(
expectedDestinationUrl
=
=
=
undefined
)
{
expectedDestinationUrl
=
url
;
}
if
(
expectedDestinationUrl
)
{
expectedDestinationUrl
.
username
=
'
'
;
expectedDestinationUrl
.
password
=
'
'
;
assert_equals
(
await
this
.
execute_script
(
(
)
=
>
location
.
href
)
expectedDestinationUrl
.
toString
(
)
"
expected
navigation
to
reach
destination
URL
"
)
;
}
await
this
.
execute_script
(
(
)
=
>
{
}
)
;
}
async
getRequestHeaders
(
)
{
return
this
.
execute_script
(
(
)
=
>
requestHeaders
)
;
}
async
getResponseCookies
(
)
{
return
this
.
execute_script
(
(
)
=
>
{
let
cookie
=
{
}
;
document
.
cookie
.
split
(
/
\
s
*
;
\
s
*
/
)
.
forEach
(
(
kv
)
=
>
{
let
[
key
value
]
=
kv
.
split
(
/
\
s
*
=
\
s
*
/
)
;
cookie
[
key
]
=
value
;
}
)
;
return
cookie
;
}
)
;
}
async
getRequestCookies
(
)
{
return
this
.
execute_script
(
(
)
=
>
window
.
requestCookies
)
;
}
async
getRequestCredentials
(
)
{
return
this
.
execute_script
(
(
)
=
>
window
.
requestCredentials
)
;
}
async
setReferrerPolicy
(
referrerPolicy
)
{
return
this
.
execute_script
(
referrerPolicy
=
>
{
const
meta
=
document
.
createElement
(
"
meta
"
)
;
meta
.
name
=
"
referrer
"
;
meta
.
content
=
referrerPolicy
;
document
.
head
.
append
(
meta
)
;
}
[
referrerPolicy
]
)
;
}
async
getDeliveryType
(
)
{
return
this
.
execute_script
(
(
)
=
>
{
return
performance
.
getEntriesByType
(
"
navigation
"
)
[
0
]
.
deliveryType
;
}
)
;
}
}
function
getPrefetchUrl
(
extra_params
=
{
}
)
{
let
params
=
new
URLSearchParams
(
{
uuid
:
token
(
)
.
.
.
extra_params
}
)
;
return
new
URL
(
prefetch
.
py
?
{
params
}
SR_PREFETCH_UTILS_URL
)
;
}
function
getPrefetchUrlList
(
n
)
{
return
Array
.
from
(
{
length
:
n
}
(
)
=
>
getPrefetchUrl
(
)
)
;
}
async
function
isUrlPrefetched
(
url
)
{
let
response
=
await
fetch
(
url
{
redirect
:
'
follow
'
}
)
;
assert_true
(
response
.
ok
)
;
return
response
.
json
(
)
;
}
async
function
spawnWindowWithReference
(
t
options
=
{
}
uuid
=
token
(
)
)
{
let
agent
=
new
PrefetchAgent
(
uuid
t
)
;
let
w
=
window
.
open
(
agent
.
getExecutorURL
(
options
)
'
_blank
'
options
)
;
t
.
add_cleanup
(
(
)
=
>
w
.
close
(
)
)
;
return
{
"
agent
"
:
agent
"
window
"
:
w
}
;
}
async
function
spawnWindow
(
t
options
=
{
}
uuid
=
token
(
)
)
{
let
agent_window_pair
=
await
spawnWindowWithReference
(
t
options
uuid
)
;
return
agent_window_pair
.
agent
;
}
function
insertSpeculationRules
(
body
)
{
let
script
=
document
.
createElement
(
'
script
'
)
;
script
.
type
=
'
speculationrules
'
;
script
.
textContent
=
JSON
.
stringify
(
body
)
;
document
.
head
.
appendChild
(
script
)
;
}
function
addLink
(
href
insertion_point
=
document
.
body
)
{
const
a
=
document
.
createElement
(
'
a
'
)
;
a
.
href
=
href
;
insertion_point
.
appendChild
(
a
)
;
return
a
;
}
function
insertDocumentRule
(
predicate
extra_options
=
{
}
)
{
insertSpeculationRules
(
{
prefetch
:
[
{
source
:
'
document
'
eagerness
:
'
eager
'
where
:
predicate
.
.
.
extra_options
}
]
}
)
;
}
function
assert_prefetched
(
requestHeaders
description
)
{
assert_in_array
(
requestHeaders
.
purpose
[
undefined
"
prefetch
"
]
"
The
vendor
-
specific
header
Purpose
if
present
must
be
'
prefetch
'
.
"
)
;
assert_in_array
(
requestHeaders
[
'
sec
-
purpose
'
]
[
"
prefetch
"
"
prefetch
;
anonymous
-
client
-
ip
"
]
description
)
;
}
function
assert_prefetched_anonymous_client_ip
(
requestHeaders
description
)
{
assert_in_array
(
requestHeaders
.
purpose
[
undefined
"
prefetch
"
]
"
The
vendor
-
specific
header
Purpose
if
present
must
be
'
prefetch
'
.
"
)
;
assert_equals
(
requestHeaders
[
'
sec
-
purpose
'
]
"
prefetch
;
anonymous
-
client
-
ip
"
description
)
;
}
function
assert_not_prefetched
(
requestHeaders
description
)
{
assert_equals
(
requestHeaders
.
purpose
undefined
description
)
;
assert_equals
(
requestHeaders
[
'
sec
-
purpose
'
]
undefined
description
)
;
}
function
assert_prefetched_without_sec_purpose
(
requestHeaders
description
)
{
assert_in_array
(
requestHeaders
.
purpose
[
undefined
"
prefetch
"
]
"
The
vendor
-
specific
header
Purpose
if
present
must
be
'
prefetch
'
.
"
)
;
assert_equals
(
requestHeaders
[
'
sec
-
purpose
'
]
undefined
description
)
;
}
function
assert_intercept_prefetch
(
interceptedRequest
expectedUrl
)
{
assert_equals
(
interceptedRequest
.
request
.
url
expectedUrl
.
toString
(
)
"
intercepted
request
URL
.
"
)
;
assert_prefetched
(
interceptedRequest
.
request
.
headers
"
Prefetch
request
should
be
intercepted
.
"
)
;
if
(
new
URL
(
location
.
href
)
.
searchParams
.
has
(
'
clientId
'
)
)
{
assert_equals
(
interceptedRequest
.
resultingClientId
"
"
"
resultingClientId
shouldn
'
t
be
exposed
.
"
)
;
assert_false
(
interceptedRequest
.
clientId
=
=
=
"
"
"
clientId
should
be
initiator
.
"
)
;
}
}
function
assert_intercept_non_prefetch
(
interceptedRequest
expectedUrl
)
{
assert_equals
(
interceptedRequest
.
request
.
url
expectedUrl
.
toString
(
)
"
intercepted
request
URL
.
"
)
;
assert_not_prefetched
(
interceptedRequest
.
request
.
headers
"
Non
-
prefetch
request
should
be
intercepted
.
"
)
;
if
(
new
URL
(
location
.
href
)
.
searchParams
.
has
(
'
clientId
'
)
)
{
assert_not_equals
(
interceptedRequest
.
resultingClientId
"
"
"
resultingClientId
can
be
exposed
.
"
)
;
assert_not_equals
(
interceptedRequest
.
clientId
"
"
"
clientId
should
be
initiator
.
"
)
;
}
}
function
addNoVarySearchHeaderUsingQueryParam
(
url
value
)
{
if
(
value
)
{
url
.
searchParams
.
append
(
"
nvs_header
"
value
)
;
}
}
