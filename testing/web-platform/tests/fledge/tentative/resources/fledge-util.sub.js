"
use
strict
;
"
const
BASE_URL
=
document
.
baseURI
.
substring
(
0
document
.
baseURI
.
lastIndexOf
(
'
/
'
)
+
1
)
;
const
BASE_PATH
=
(
new
URL
(
BASE_URL
)
)
.
pathname
;
const
RESOURCE_PATH
=
{
BASE_PATH
}
resources
/
const
DEFAULT_INTEREST_GROUP_NAME
=
'
default
name
'
;
const
TRUSTED_BIDDING_SIGNALS_URL
=
{
BASE_URL
}
resources
/
trusted
-
bidding
-
signals
.
py
;
const
TRUSTED_SCORING_SIGNALS_URL
=
{
BASE_URL
}
resources
/
trusted
-
scoring
-
signals
.
py
;
const
OTHER_ORIGIN1
=
'
https
:
/
/
{
{
hosts
[
alt
]
[
]
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
;
const
OTHER_ORIGIN2
=
'
https
:
/
/
{
{
hosts
[
alt
]
[
]
}
}
:
{
{
ports
[
https
]
[
1
]
}
}
'
;
const
OTHER_ORIGIN3
=
'
https
:
/
/
{
{
hosts
[
]
[
]
}
}
:
{
{
ports
[
https
]
[
1
]
}
}
'
;
const
OTHER_ORIGIN4
=
'
https
:
/
/
{
{
hosts
[
]
[
www
]
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
;
const
OTHER_ORIGIN5
=
'
https
:
/
/
{
{
hosts
[
]
[
www
]
}
}
:
{
{
ports
[
https
]
[
1
]
}
}
'
;
const
OTHER_ORIGIN6
=
'
https
:
/
/
{
{
hosts
[
alt
]
[
www
]
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
;
const
OTHER_ORIGIN7
=
'
https
:
/
/
{
{
hosts
[
alt
]
[
www
]
}
}
:
{
{
ports
[
https
]
[
1
]
}
}
'
;
function
createTrackerURL
(
origin
uuid
dispatch
id
=
null
)
{
let
url
=
new
URL
(
{
origin
}
{
BASE_PATH
}
resources
/
request
-
tracker
.
py
)
;
url
.
searchParams
.
append
(
'
uuid
'
uuid
)
;
url
.
searchParams
.
append
(
'
dispatch
'
dispatch
)
;
if
(
id
)
url
.
searchParams
.
append
(
'
id
'
id
)
;
return
url
.
toString
(
)
;
}
function
createCleanupURL
(
uuid
)
{
return
createTrackerURL
(
window
.
location
.
origin
uuid
'
clean_up
'
)
;
}
function
createBidderReportURL
(
uuid
id
=
'
1
'
origin
=
window
.
location
.
origin
)
{
return
createTrackerURL
(
origin
uuid
track_get
bidder_report_
{
id
}
)
;
}
function
createSellerReportURL
(
uuid
id
=
'
1
'
origin
=
window
.
location
.
origin
)
{
return
createTrackerURL
(
origin
uuid
track_get
seller_report_
{
id
}
)
;
}
function
createBidderBeaconURL
(
uuid
id
=
'
1
'
origin
=
window
.
location
.
origin
)
{
return
createTrackerURL
(
origin
uuid
track_post
bidder_beacon_
{
id
}
)
;
}
function
createSellerBeaconURL
(
uuid
id
=
'
1
'
origin
=
window
.
location
.
origin
)
{
return
createTrackerURL
(
origin
uuid
track_post
seller_beacon_
{
id
}
)
;
}
function
createDirectFromSellerSignalsURL
(
origin
=
window
.
location
.
origin
)
{
let
url
=
new
URL
(
{
origin
}
{
BASE_PATH
}
resources
/
direct
-
from
-
seller
-
signals
.
py
)
;
return
url
.
toString
(
)
;
}
function
generateUuid
(
test
)
{
let
uuid
=
token
(
)
;
test
.
add_cleanup
(
async
(
)
=
>
{
let
response
=
await
fetch
(
createCleanupURL
(
uuid
)
{
credentials
:
'
omit
'
mode
:
'
cors
'
}
)
;
assert_equals
(
await
response
.
text
(
)
'
cleanup
complete
'
Sever
state
cleanup
failed
)
;
}
)
;
return
uuid
;
}
async
function
fetchTrackedData
(
uuid
)
{
let
trackedRequestsURL
=
createTrackerURL
(
window
.
location
.
origin
uuid
'
tracked_data
'
)
;
let
response
=
await
fetch
(
trackedRequestsURL
{
credentials
:
'
omit
'
mode
:
'
cors
'
}
)
;
let
trackedData
=
await
response
.
json
(
)
;
if
(
trackedData
.
error
)
{
throw
trackedRequestsURL
+
'
fetch
failed
:
'
+
JSON
.
stringify
(
trackedData
)
;
}
if
(
trackedData
.
errors
.
length
>
0
)
{
throw
'
Errors
reported
by
request
-
tracker
.
py
:
'
+
JSON
.
stringify
(
trackedData
.
errors
)
;
}
return
trackedData
;
}
async
function
waitForObservedRequests
(
uuid
expectedRequests
)
{
expectedRequests
=
expectedRequests
.
sort
(
)
.
map
(
(
url
)
=
>
url
.
replace
(
uuid
'
<
uuid
>
'
)
)
;
while
(
true
)
{
let
trackedData
=
await
fetchTrackedData
(
uuid
)
;
let
trackedRequests
=
trackedData
.
trackedRequests
.
sort
(
)
.
map
(
(
url
)
=
>
url
.
replace
(
uuid
'
<
uuid
>
'
)
)
;
if
(
trackedRequests
.
length
=
=
expectedRequests
.
length
)
{
assert_array_equals
(
trackedRequests
expectedRequests
)
;
break
;
}
for
(
const
trackedRequest
of
trackedRequests
)
{
assert_in_array
(
trackedRequest
expectedRequests
)
;
}
}
}
function
createBiddingScriptURL
(
params
=
{
}
)
{
let
origin
=
params
.
origin
?
params
.
origin
:
new
URL
(
BASE_URL
)
.
origin
;
let
url
=
new
URL
(
{
origin
}
{
RESOURCE_PATH
}
bidding
-
logic
.
sub
.
py
)
;
if
(
params
.
generateBid
)
url
.
searchParams
.
append
(
'
generateBid
'
params
.
generateBid
)
;
if
(
params
.
reportWin
)
url
.
searchParams
.
append
(
'
reportWin
'
params
.
reportWin
)
;
if
(
params
.
error
)
url
.
searchParams
.
append
(
'
error
'
params
.
error
)
;
if
(
params
.
bid
)
url
.
searchParams
.
append
(
'
bid
'
params
.
bid
)
;
if
(
params
.
bidCurrency
)
url
.
searchParams
.
append
(
'
bidCurrency
'
params
.
bidCurrency
)
;
if
(
params
.
allowComponentAuction
!
=
=
undefined
)
url
.
searchParams
.
append
(
'
allowComponentAuction
'
JSON
.
stringify
(
params
.
allowComponentAuction
)
)
return
url
.
toString
(
)
;
}
function
createBiddingWasmHelperURL
(
params
=
{
}
)
{
let
origin
=
params
.
origin
?
params
.
origin
:
new
URL
(
BASE_URL
)
.
origin
;
return
{
origin
}
{
RESOURCE_PATH
}
bidding
-
wasmlogic
.
wasm
;
}
function
createDecisionScriptURL
(
uuid
params
=
{
}
)
{
let
origin
=
params
.
origin
?
params
.
origin
:
new
URL
(
BASE_URL
)
.
origin
;
let
url
=
new
URL
(
{
origin
}
{
RESOURCE_PATH
}
decision
-
logic
.
sub
.
py
)
;
url
.
searchParams
.
append
(
'
uuid
'
uuid
)
;
if
(
params
.
scoreAd
)
url
.
searchParams
.
append
(
'
scoreAd
'
params
.
scoreAd
)
;
if
(
params
.
reportResult
)
url
.
searchParams
.
append
(
'
reportResult
'
params
.
reportResult
)
;
if
(
params
.
error
)
url
.
searchParams
.
append
(
'
error
'
params
.
error
)
;
return
url
.
toString
(
)
;
}
function
createRenderURL
(
uuid
script
signalsParams
origin
)
{
if
(
origin
=
=
null
)
origin
=
new
URL
(
BASE_URL
)
.
origin
;
let
url
=
new
URL
(
{
origin
}
{
RESOURCE_PATH
}
fenced
-
frame
.
sub
.
py
)
;
if
(
script
)
url
.
searchParams
.
append
(
'
script
'
script
)
;
if
(
signalsParams
)
url
.
searchParams
.
append
(
'
signalsParams
'
signalsParams
)
;
url
.
searchParams
.
append
(
'
uuid
'
uuid
)
;
return
url
.
toString
(
)
;
}
function
createInterestGroupForOrigin
(
uuid
origin
interestGroupOverrides
=
{
}
)
{
return
{
owner
:
origin
name
:
DEFAULT_INTEREST_GROUP_NAME
biddingLogicURL
:
createBiddingScriptURL
(
{
origin
:
origin
reportWin
:
sendReportTo
(
'
{
createBidderReportURL
(
uuid
)
}
'
)
;
}
)
ads
:
[
{
renderURL
:
createRenderURL
(
uuid
)
}
]
.
.
.
interestGroupOverrides
}
;
}
async
function
joinInterestGroup
(
test
uuid
interestGroupOverrides
=
{
}
durationSeconds
=
60
)
{
let
interestGroup
=
createInterestGroupForOrigin
(
uuid
window
.
location
.
origin
interestGroupOverrides
)
;
await
navigator
.
joinAdInterestGroup
(
interestGroup
durationSeconds
)
;
test
.
add_cleanup
(
async
(
)
=
>
{
await
navigator
.
leaveAdInterestGroup
(
interestGroup
)
}
)
;
}
async
function
leaveInterestGroup
(
interestGroupOverrides
=
{
}
)
{
let
interestGroup
=
{
owner
:
window
.
location
.
origin
name
:
DEFAULT_INTEREST_GROUP_NAME
.
.
.
interestGroupOverrides
}
;
await
navigator
.
leaveAdInterestGroup
(
interestGroup
)
;
}
async
function
runBasicFledgeAuction
(
test
uuid
auctionConfigOverrides
=
{
}
)
{
let
auctionConfig
=
{
seller
:
window
.
location
.
origin
decisionLogicURL
:
createDecisionScriptURL
(
uuid
{
reportResult
:
sendReportTo
(
'
{
createSellerReportURL
(
uuid
)
}
'
)
;
}
)
interestGroupBuyers
:
[
window
.
location
.
origin
]
resolveToConfig
:
true
.
.
.
auctionConfigOverrides
}
;
return
await
navigator
.
runAdAuction
(
auctionConfig
)
;
}
function
expectSuccess
(
config
)
{
assert_true
(
config
!
=
=
null
Auction
unexpectedly
had
no
winner
)
;
assert_true
(
config
instanceof
FencedFrameConfig
Wrong
value
type
returned
from
auction
:
{
config
.
constructor
.
type
}
)
;
}
function
expectNoWinner
(
result
)
{
assert_true
(
result
=
=
=
null
'
Auction
unexpectedly
had
a
winner
'
)
;
}
async
function
runBasicFledgeTestExpectingWinner
(
test
uuid
auctionConfigOverrides
=
{
}
)
{
let
config
=
await
runBasicFledgeAuction
(
test
uuid
auctionConfigOverrides
)
;
expectSuccess
(
config
)
;
return
config
;
}
async
function
runBasicFledgeTestExpectingNoWinner
(
test
uuid
auctionConfigOverrides
=
{
}
)
{
let
result
=
await
runBasicFledgeAuction
(
test
uuid
auctionConfigOverrides
)
;
expectNoWinner
(
result
)
;
}
function
createAndNavigateFencedFrame
(
test
fencedFrameConfig
)
{
let
fencedFrame
=
document
.
createElement
(
'
fencedframe
'
)
;
fencedFrame
.
mode
=
'
opaque
-
ads
'
;
fencedFrame
.
config
=
fencedFrameConfig
;
document
.
body
.
appendChild
(
fencedFrame
)
;
test
.
add_cleanup
(
(
)
=
>
{
document
.
body
.
removeChild
(
fencedFrame
)
;
}
)
;
}
async
function
runBasicFledgeAuctionAndNavigate
(
test
uuid
auctionConfigOverrides
=
{
}
)
{
let
config
=
await
runBasicFledgeTestExpectingWinner
(
test
uuid
auctionConfigOverrides
)
;
createAndNavigateFencedFrame
(
test
config
)
;
}
async
function
joinGroupAndRunBasicFledgeTestExpectingWinner
(
test
testConfig
=
{
}
)
{
const
uuid
=
testConfig
.
uuid
?
testConfig
.
uuid
:
generateUuid
(
test
)
;
await
joinInterestGroup
(
test
uuid
testConfig
.
interestGroupOverrides
)
;
await
runBasicFledgeTestExpectingWinner
(
test
uuid
testConfig
.
auctionConfigOverrides
)
;
}
async
function
joinGroupAndRunBasicFledgeTestExpectingNoWinner
(
test
testConfig
=
{
}
)
{
const
uuid
=
testConfig
.
uuid
?
testConfig
.
uuid
:
generateUuid
(
test
)
;
await
joinInterestGroup
(
test
uuid
testConfig
.
interestGroupOverrides
)
;
await
runBasicFledgeTestExpectingNoWinner
(
test
uuid
testConfig
.
auctionConfigOverrides
)
;
}
async
function
runReportTest
(
test
uuid
codeToInsert
expectedReportURLs
renderURLOverride
auctionConfigOverrides
)
{
let
scoreAd
=
codeToInsert
.
scoreAd
;
let
reportResultSuccessCondition
=
codeToInsert
.
reportResultSuccessCondition
;
let
reportResult
=
codeToInsert
.
reportResult
;
let
generateBid
=
codeToInsert
.
generateBid
;
let
reportWinSuccessCondition
=
codeToInsert
.
reportWinSuccessCondition
;
let
reportWin
=
codeToInsert
.
reportWin
;
let
decisionScriptURLOrigin
=
codeToInsert
.
decisionScriptURLOrigin
;
if
(
reportResultSuccessCondition
)
{
reportResult
=
if
(
!
(
{
reportResultSuccessCondition
}
)
)
{
sendReportTo
(
'
{
createSellerReportURL
(
uuid
'
error
'
)
}
'
)
;
return
false
;
}
{
reportResult
}
;
}
let
decisionScriptURLParams
=
{
}
;
if
(
scoreAd
!
=
=
undefined
)
{
decisionScriptURLParams
.
scoreAd
=
scoreAd
;
}
if
(
reportResult
!
=
=
null
)
decisionScriptURLParams
.
reportResult
=
reportResult
;
else
decisionScriptURLParams
.
error
=
'
no
-
reportResult
'
;
if
(
decisionScriptURLOrigin
!
=
=
undefined
)
{
decisionScriptURLParams
.
origin
=
decisionScriptURLOrigin
;
}
if
(
reportWinSuccessCondition
)
{
reportWin
=
if
(
!
(
{
reportWinSuccessCondition
}
)
)
{
sendReportTo
(
'
{
createBidderReportURL
(
uuid
'
error
'
)
}
'
)
;
return
false
;
}
{
reportWin
}
;
}
let
biddingScriptURLParams
=
{
}
;
if
(
generateBid
!
=
=
undefined
)
{
biddingScriptURLParams
.
generateBid
=
generateBid
;
}
if
(
reportWin
!
=
=
null
)
biddingScriptURLParams
.
reportWin
=
reportWin
;
else
biddingScriptURLParams
.
error
=
'
no
-
reportWin
'
;
let
interestGroupOverrides
=
{
biddingLogicURL
:
createBiddingScriptURL
(
biddingScriptURLParams
)
}
;
if
(
renderURLOverride
)
interestGroupOverrides
.
ads
=
[
{
renderURL
:
renderURLOverride
}
]
await
joinInterestGroup
(
test
uuid
interestGroupOverrides
)
;
if
(
auctionConfigOverrides
=
=
=
undefined
)
{
auctionConfigOverrides
=
{
decisionLogicURL
:
createDecisionScriptURL
(
uuid
decisionScriptURLParams
)
}
;
}
else
if
(
auctionConfigOverrides
.
decisionLogicURL
=
=
=
undefined
)
{
auctionConfigOverrides
.
decisionLogicURL
=
createDecisionScriptURL
(
uuid
decisionScriptURLParams
)
;
}
await
runBasicFledgeAuctionAndNavigate
(
test
uuid
auctionConfigOverrides
)
;
await
waitForObservedRequests
(
uuid
expectedReportURLs
)
;
}
async
function
runInFrame
(
test
child_window
script
param
)
{
const
messageUuid
=
generateUuid
(
test
)
;
let
receivedResponse
=
{
}
;
let
promise
=
new
Promise
(
function
(
resolve
reject
)
{
function
WaitForMessage
(
event
)
{
if
(
event
.
data
.
messageUuid
!
=
messageUuid
)
return
;
receivedResponse
=
event
.
data
;
if
(
event
.
data
.
result
=
=
=
'
success
'
)
{
resolve
(
)
;
}
else
{
reject
(
event
.
data
.
result
)
;
}
}
window
.
addEventListener
(
'
message
'
WaitForMessage
)
;
child_window
.
postMessage
(
{
messageUuid
:
messageUuid
script
:
script
param
:
param
}
'
*
'
)
;
}
)
;
await
promise
;
return
receivedResponse
.
returnValue
;
}
async
function
createFrame
(
test
origin
is_iframe
=
true
permissions
=
null
)
{
const
frameUuid
=
generateUuid
(
test
)
;
const
frameUrl
=
{
origin
}
{
RESOURCE_PATH
}
subordinate
-
frame
.
sub
.
html
?
uuid
=
{
frameUuid
}
;
let
promise
=
new
Promise
(
function
(
resolve
reject
)
{
function
WaitForMessage
(
event
)
{
if
(
event
.
data
.
messageUuid
!
=
frameUuid
)
return
;
if
(
event
.
data
.
result
=
=
=
'
load
complete
'
)
{
resolve
(
)
;
}
else
{
reject
(
event
.
data
.
result
)
;
}
}
window
.
addEventListener
(
'
message
'
WaitForMessage
)
;
}
)
;
if
(
is_iframe
)
{
let
iframe
=
document
.
createElement
(
'
iframe
'
)
;
if
(
permissions
)
iframe
.
allow
=
permissions
;
iframe
.
src
=
frameUrl
;
document
.
body
.
appendChild
(
iframe
)
;
test
.
add_cleanup
(
async
(
)
=
>
{
await
runInFrame
(
test
iframe
.
contentWindow
"
await
test_instance
.
do_cleanup
(
)
;
"
)
;
document
.
body
.
removeChild
(
iframe
)
;
}
)
;
await
promise
;
return
iframe
.
contentWindow
;
}
let
child_window
=
window
.
open
(
frameUrl
)
;
test
.
add_cleanup
(
async
(
)
=
>
{
await
runInFrame
(
test
child_window
"
await
test_instance
.
do_cleanup
(
)
;
"
)
;
child_window
.
close
(
)
;
}
)
;
await
promise
;
return
child_window
;
}
async
function
createIframe
(
test
origin
permissions
=
null
)
{
return
await
createFrame
(
test
origin
true
permissions
)
;
}
async
function
createTopLevelWindow
(
test
origin
)
{
return
await
createFrame
(
test
origin
false
)
;
}
async
function
joinCrossOriginInterestGroup
(
test
uuid
origin
interestGroupOverrides
=
{
}
)
{
let
interestGroup
=
JSON
.
stringify
(
createInterestGroupForOrigin
(
uuid
origin
interestGroupOverrides
)
)
;
let
iframe
=
await
createIframe
(
test
origin
'
join
-
ad
-
interest
-
group
'
)
;
await
runInFrame
(
test
iframe
await
joinInterestGroup
(
test_instance
"
{
uuid
}
"
{
interestGroup
}
)
)
;
}
async
function
joinInterestGroupInTopLevelWindow
(
test
uuid
origin
interestGroupOverrides
=
{
}
)
{
let
interestGroup
=
JSON
.
stringify
(
createInterestGroupForOrigin
(
uuid
origin
interestGroupOverrides
)
)
;
let
topLeveWindow
=
await
createTopLevelWindow
(
test
origin
)
;
await
runInFrame
(
test
topLeveWindow
await
joinInterestGroup
(
test_instance
"
{
uuid
}
"
{
interestGroup
}
)
)
;
}
async
function
fetchDirectFromSellerSignals
(
headers_content
origin
)
{
const
response
=
await
fetch
(
createDirectFromSellerSignalsURL
(
origin
)
{
adAuctionHeaders
:
true
headers
:
headers_content
}
)
;
if
(
!
(
'
Negative
-
Test
-
Option
'
in
headers_content
)
)
{
assert_equals
(
response
.
status
200
'
Failed
to
fetch
directFromSellerSignals
:
'
+
await
response
.
text
(
)
)
;
}
assert_false
(
response
.
headers
.
has
(
'
Ad
-
Auction
-
Signals
'
)
'
Header
"
Ad
-
Auction
-
Signals
"
should
be
hidden
from
documents
.
'
)
;
}
function
directFromSellerSignalsValidatorCode
(
uuid
expectedSellerSignals
expectedAuctionSignals
expectedPerBuyerSignals
)
{
expectedSellerSignals
=
JSON
.
stringify
(
expectedSellerSignals
)
;
expectedAuctionSignals
=
JSON
.
stringify
(
expectedAuctionSignals
)
;
expectedPerBuyerSignals
=
JSON
.
stringify
(
expectedPerBuyerSignals
)
;
return
{
scoreAd
:
if
(
directFromSellerSignals
=
=
=
null
|
|
directFromSellerSignals
.
sellerSignals
!
=
=
{
expectedSellerSignals
}
|
|
directFromSellerSignals
.
auctionSignals
!
=
=
{
expectedAuctionSignals
}
|
|
Object
.
keys
(
directFromSellerSignals
)
.
length
!
=
2
)
{
throw
'
Failed
to
get
expected
directFromSellerSignals
in
scoreAd
(
)
:
'
+
JSON
.
stringify
(
directFromSellerSignals
)
;
}
reportResultSuccessCondition
:
directFromSellerSignals
!
=
=
null
&
&
directFromSellerSignals
.
sellerSignals
=
=
=
{
expectedSellerSignals
}
&
&
directFromSellerSignals
.
auctionSignals
=
=
=
{
expectedAuctionSignals
}
&
&
Object
.
keys
(
directFromSellerSignals
)
.
length
=
=
2
reportResult
:
sendReportTo
(
"
{
createSellerReportURL
(
uuid
)
}
"
)
;
generateBid
:
if
(
directFromSellerSignals
=
=
=
null
|
|
directFromSellerSignals
.
perBuyerSignals
!
=
=
{
expectedPerBuyerSignals
}
|
|
directFromSellerSignals
.
auctionSignals
!
=
=
{
expectedAuctionSignals
}
|
|
Object
.
keys
(
directFromSellerSignals
)
.
length
!
=
2
)
{
throw
'
Failed
to
get
expected
directFromSellerSignals
in
generateBid
(
)
:
'
+
JSON
.
stringify
(
directFromSellerSignals
)
;
}
reportWinSuccessCondition
:
directFromSellerSignals
!
=
=
null
&
&
directFromSellerSignals
.
perBuyerSignals
=
=
=
{
expectedPerBuyerSignals
}
&
&
directFromSellerSignals
.
auctionSignals
=
=
=
{
expectedAuctionSignals
}
&
&
Object
.
keys
(
directFromSellerSignals
)
.
length
=
=
2
reportWin
:
sendReportTo
(
"
{
createBidderReportURL
(
uuid
)
}
"
)
;
}
;
}
