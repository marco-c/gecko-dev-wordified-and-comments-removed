"
use
strict
;
"
const
BASE_URL
=
document
.
baseURI
.
substring
(
0
document
.
baseURI
.
lastIndexOf
(
'
/
'
)
+
1
)
;
const
BASE_PATH
=
(
new
URL
(
BASE_URL
)
)
.
pathname
;
RESOURCE_PATH
=
{
BASE_PATH
}
resources
/
const
DEFAULT_INTEREST_GROUP_NAME
=
'
default
name
'
;
const
TRUSTED_BIDDING_SIGNALS_URL
=
{
BASE_URL
}
resources
/
trusted
-
bidding
-
signals
.
py
;
const
TRUSTED_SCORING_SIGNALS_URL
=
{
BASE_URL
}
resources
/
trusted
-
scoring
-
signals
.
py
;
const
OTHER_ORIGIN1
=
'
https
:
/
/
{
{
hosts
[
alt
]
[
]
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
;
const
OTHER_ORIGIN2
=
'
https
:
/
/
{
{
hosts
[
alt
]
[
]
}
}
:
{
{
ports
[
https
]
[
1
]
}
}
'
;
const
OTHER_ORIGIN3
=
'
https
:
/
/
{
{
hosts
[
]
[
]
}
}
:
{
{
ports
[
https
]
[
1
]
}
}
'
;
const
OTHER_ORIGIN4
=
'
https
:
/
/
{
{
hosts
[
]
[
www
]
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
;
const
OTHER_ORIGIN5
=
'
https
:
/
/
{
{
hosts
[
]
[
www
]
}
}
:
{
{
ports
[
https
]
[
1
]
}
}
'
;
const
OTHER_ORIGIN6
=
'
https
:
/
/
{
{
hosts
[
alt
]
[
www
]
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
;
const
OTHER_ORIGIN7
=
'
https
:
/
/
{
{
hosts
[
alt
]
[
www
]
}
}
:
{
{
ports
[
https
]
[
1
]
}
}
'
;
const
CROSS_ORIGIN_TRUSTED_BIDDING_SIGNALS_URL
=
OTHER_ORIGIN1
+
BASE_PATH
+
'
resources
/
trusted
-
bidding
-
signals
.
py
'
;
const
CROSS_ORIGIN_TRUSTED_SCORING_SIGNALS_URL
=
OTHER_ORIGIN1
+
BASE_PATH
+
'
resources
/
trusted
-
scoring
-
signals
.
py
'
;
function
createTrackerURL
(
origin
uuid
dispatch
id
=
null
)
{
let
url
=
new
URL
(
{
origin
}
{
RESOURCE_PATH
}
request
-
tracker
.
py
)
;
let
search
=
uuid
=
{
uuid
}
&
dispatch
=
{
dispatch
}
;
if
(
id
)
search
+
=
&
id
=
{
id
}
;
url
.
search
=
search
;
return
url
.
toString
(
)
;
}
function
createCleanupURL
(
uuid
)
{
return
createTrackerURL
(
window
.
location
.
origin
uuid
'
clean_up
'
)
;
}
function
createBidderReportURL
(
uuid
id
=
'
1
'
origin
=
window
.
location
.
origin
)
{
return
createTrackerURL
(
origin
uuid
track_get
bidder_report_
{
id
}
)
;
}
function
createSellerReportURL
(
uuid
id
=
'
1
'
origin
=
window
.
location
.
origin
)
{
return
createTrackerURL
(
origin
uuid
track_get
seller_report_
{
id
}
)
;
}
function
createHighestScoringOtherBidReportURL
(
uuid
highestScoringOtherBid
)
{
return
createSellerReportURL
(
uuid
)
+
'
&
highestScoringOtherBid
=
'
+
Math
.
round
(
highestScoringOtherBid
)
;
}
function
createBidderBeaconURL
(
uuid
id
=
'
1
'
origin
=
window
.
location
.
origin
)
{
return
createTrackerURL
(
origin
uuid
track_post
bidder_beacon_
{
id
}
)
;
}
function
createSellerBeaconURL
(
uuid
id
=
'
1
'
origin
=
window
.
location
.
origin
)
{
return
createTrackerURL
(
origin
uuid
track_post
seller_beacon_
{
id
}
)
;
}
function
createDirectFromSellerSignalsURL
(
origin
=
window
.
location
.
origin
)
{
let
url
=
new
URL
(
{
origin
}
{
RESOURCE_PATH
}
direct
-
from
-
seller
-
signals
.
py
)
;
return
url
.
toString
(
)
;
}
function
createUpdateURL
(
params
=
{
}
)
{
let
origin
=
window
.
location
.
origin
;
let
url
=
new
URL
(
{
origin
}
{
RESOURCE_PATH
}
update
-
url
.
py
)
;
url
.
searchParams
.
append
(
'
body
'
params
.
body
)
;
url
.
searchParams
.
append
(
'
uuid
'
params
.
uuid
)
;
return
url
.
toString
(
)
;
}
function
generateUuid
(
test
)
{
let
uuid
=
token
(
)
;
test
.
add_cleanup
(
async
(
)
=
>
{
let
response
=
await
fetch
(
createCleanupURL
(
uuid
)
{
credentials
:
'
omit
'
mode
:
'
cors
'
}
)
;
assert_equals
(
await
response
.
text
(
)
'
cleanup
complete
'
Sever
state
cleanup
failed
)
;
}
)
;
return
uuid
;
}
async
function
fetchTrackedData
(
uuid
)
{
let
trackedRequestsURL
=
createTrackerURL
(
window
.
location
.
origin
uuid
'
tracked_data
'
)
;
let
response
=
await
fetch
(
trackedRequestsURL
{
credentials
:
'
omit
'
mode
:
'
cors
'
}
)
;
let
trackedData
=
await
response
.
json
(
)
;
if
(
trackedData
.
error
)
{
throw
trackedRequestsURL
+
'
fetch
failed
:
'
+
JSON
.
stringify
(
trackedData
)
;
}
if
(
trackedData
.
errors
.
length
>
0
)
{
throw
'
Errors
reported
by
request
-
tracker
.
py
:
'
+
JSON
.
stringify
(
trackedData
.
errors
)
;
}
return
trackedData
;
}
async
function
waitForObservedRequests
(
uuid
expectedRequests
filter
)
{
expectedRequests
=
expectedRequests
.
map
(
(
url
)
=
>
url
.
replace
(
uuid
'
<
uuid
>
'
)
)
.
sort
(
)
;
while
(
true
)
{
let
trackedData
=
await
fetchTrackedData
(
uuid
)
;
let
trackedRequests
=
trackedData
.
trackedRequests
.
map
(
(
url
)
=
>
url
.
replace
(
uuid
'
<
uuid
>
'
)
)
.
sort
(
)
;
if
(
filter
)
{
trackedRequests
=
trackedRequests
.
filter
(
filter
)
;
}
for
(
const
trackedRequest
of
trackedRequests
)
{
assert_in_array
(
trackedRequest
expectedRequests
)
;
}
if
(
trackedRequests
.
length
>
=
expectedRequests
.
length
)
{
assert_array_equals
(
trackedRequests
expectedRequests
)
;
break
;
}
}
}
async
function
waitForObservedRequestsIgnoreDebugOnlyReports
(
uuid
expectedRequests
)
{
return
waitForObservedRequests
(
uuid
expectedRequests
request
=
>
!
request
.
includes
(
'
forDebuggingOnly
'
)
)
;
}
function
createBiddingScriptURL
(
params
=
{
}
)
{
let
origin
=
params
.
origin
?
params
.
origin
:
new
URL
(
BASE_URL
)
.
origin
;
let
url
=
new
URL
(
{
origin
}
{
RESOURCE_PATH
}
bidding
-
logic
.
sub
.
py
)
;
if
(
params
.
generateBid
!
=
null
)
url
.
searchParams
.
append
(
'
generateBid
'
params
.
generateBid
)
;
if
(
params
.
reportWin
!
=
null
)
url
.
searchParams
.
append
(
'
reportWin
'
params
.
reportWin
)
;
if
(
params
.
reportAdditionalBidWin
!
=
null
)
url
.
searchParams
.
append
(
'
reportAdditionalBidWin
'
params
.
reportAdditionalBidWin
)
;
if
(
params
.
error
!
=
null
)
url
.
searchParams
.
append
(
'
error
'
params
.
error
)
;
if
(
params
.
bid
!
=
null
)
url
.
searchParams
.
append
(
'
bid
'
params
.
bid
)
;
if
(
params
.
bidCurrency
!
=
null
)
url
.
searchParams
.
append
(
'
bidCurrency
'
params
.
bidCurrency
)
;
if
(
params
.
allowComponentAuction
!
=
null
)
url
.
searchParams
.
append
(
'
allowComponentAuction
'
JSON
.
stringify
(
params
.
allowComponentAuction
)
)
return
url
.
toString
(
)
;
}
function
createBiddingWasmHelperURL
(
params
=
{
}
)
{
let
origin
=
params
.
origin
?
params
.
origin
:
new
URL
(
BASE_URL
)
.
origin
;
return
{
origin
}
{
RESOURCE_PATH
}
bidding
-
wasmlogic
.
wasm
;
}
function
createDecisionScriptURL
(
uuid
params
=
{
}
)
{
let
origin
=
params
.
origin
?
params
.
origin
:
new
URL
(
BASE_URL
)
.
origin
;
let
url
=
new
URL
(
{
origin
}
{
RESOURCE_PATH
}
decision
-
logic
.
sub
.
py
)
;
url
.
searchParams
.
append
(
'
uuid
'
uuid
)
;
if
(
params
.
scoreAd
!
=
null
)
url
.
searchParams
.
append
(
'
scoreAd
'
params
.
scoreAd
)
;
if
(
params
.
reportResult
!
=
null
)
url
.
searchParams
.
append
(
'
reportResult
'
params
.
reportResult
)
;
if
(
params
.
error
!
=
null
)
url
.
searchParams
.
append
(
'
error
'
params
.
error
)
;
if
(
params
.
permitCrossOriginTrustedSignals
!
=
null
)
{
url
.
searchParams
.
append
(
'
permit
-
cross
-
origin
-
trusted
-
signals
'
params
.
permitCrossOriginTrustedSignals
)
;
}
return
url
.
toString
(
)
;
}
function
createRenderURL
(
uuid
script
signalsParams
origin
)
{
if
(
origin
=
=
null
)
origin
=
new
URL
(
BASE_URL
)
.
origin
;
let
url
=
new
URL
(
{
origin
}
{
RESOURCE_PATH
}
fenced
-
frame
.
sub
.
py
)
;
if
(
script
!
=
null
)
url
.
searchParams
.
append
(
'
script
'
script
)
;
if
(
signalsParams
!
=
null
)
url
.
searchParams
.
append
(
'
signalsParams
'
signalsParams
)
;
url
.
searchParams
.
append
(
'
uuid
'
uuid
)
;
return
url
.
toString
(
)
;
}
function
createInterestGroupForOrigin
(
uuid
origin
interestGroupOverrides
=
{
}
)
{
return
{
owner
:
origin
name
:
DEFAULT_INTEREST_GROUP_NAME
biddingLogicURL
:
createBiddingScriptURL
(
{
origin
:
origin
reportWin
:
sendReportTo
(
'
{
createBidderReportURL
(
uuid
)
}
'
)
;
}
)
ads
:
[
{
renderURL
:
createRenderURL
(
uuid
)
}
]
.
.
.
interestGroupOverrides
}
;
}
async
function
joinInterestGroupWithoutDefaults
(
test
interestGroup
durationSeconds
=
60
)
{
await
navigator
.
joinAdInterestGroup
(
interestGroup
durationSeconds
)
;
test
.
add_cleanup
(
async
(
)
=
>
{
await
navigator
.
leaveAdInterestGroup
(
interestGroup
)
;
}
)
;
}
async
function
joinInterestGroup
(
test
uuid
interestGroupOverrides
=
{
}
durationSeconds
=
60
)
{
await
joinInterestGroupWithoutDefaults
(
test
createInterestGroupForOrigin
(
uuid
window
.
location
.
origin
interestGroupOverrides
)
durationSeconds
)
;
}
async
function
joinNegativeInterestGroup
(
test
owner
name
additionalBidKey
)
{
let
interestGroup
=
{
owner
:
owner
name
:
name
additionalBidKey
:
additionalBidKey
}
;
if
(
owner
!
=
=
window
.
location
.
origin
)
{
let
iframe
=
await
createIframe
(
test
owner
'
join
-
ad
-
interest
-
group
'
)
;
await
runInFrame
(
test
iframe
await
joinInterestGroupWithoutDefaults
(
+
test_instance
{
JSON
.
stringify
(
interestGroup
)
}
)
)
;
}
else
{
await
joinInterestGroupWithoutDefaults
(
test
interestGroup
)
;
}
}
async
function
leaveInterestGroup
(
interestGroupOverrides
=
{
}
)
{
let
interestGroup
=
{
owner
:
window
.
location
.
origin
name
:
DEFAULT_INTEREST_GROUP_NAME
.
.
.
interestGroupOverrides
}
;
await
navigator
.
leaveAdInterestGroup
(
interestGroup
)
;
}
async
function
runBasicFledgeAuction
(
test
uuid
auctionConfigOverrides
=
{
}
)
{
let
auctionConfig
=
{
seller
:
window
.
location
.
origin
decisionLogicURL
:
createDecisionScriptURL
(
uuid
{
reportResult
:
sendReportTo
(
'
{
createSellerReportURL
(
uuid
)
}
'
)
;
}
)
interestGroupBuyers
:
[
window
.
location
.
origin
]
resolveToConfig
:
true
.
.
.
auctionConfigOverrides
}
;
return
await
navigator
.
runAdAuction
(
auctionConfig
)
;
}
function
expectSuccess
(
config
)
{
assert_true
(
config
!
=
=
null
Auction
unexpectedly
had
no
winner
)
;
assert_true
(
config
instanceof
FencedFrameConfig
Wrong
value
type
returned
from
auction
:
{
config
.
constructor
.
type
}
)
;
}
function
expectNoWinner
(
result
)
{
assert_true
(
result
=
=
=
null
'
Auction
unexpectedly
had
a
winner
'
)
;
}
async
function
runBasicFledgeTestExpectingWinner
(
test
uuid
auctionConfigOverrides
=
{
}
)
{
let
config
=
await
runBasicFledgeAuction
(
test
uuid
auctionConfigOverrides
)
;
expectSuccess
(
config
)
;
return
config
;
}
async
function
runBasicFledgeTestExpectingNoWinner
(
test
uuid
auctionConfigOverrides
=
{
}
)
{
let
result
=
await
runBasicFledgeAuction
(
test
uuid
auctionConfigOverrides
)
;
expectNoWinner
(
result
)
;
}
function
createAndNavigateFencedFrame
(
test
fencedFrameConfig
)
{
let
fencedFrame
=
document
.
createElement
(
'
fencedframe
'
)
;
fencedFrame
.
mode
=
'
opaque
-
ads
'
;
fencedFrame
.
config
=
fencedFrameConfig
;
document
.
body
.
appendChild
(
fencedFrame
)
;
test
.
add_cleanup
(
(
)
=
>
{
document
.
body
.
removeChild
(
fencedFrame
)
;
}
)
;
}
async
function
runBasicFledgeAuctionAndNavigate
(
test
uuid
auctionConfigOverrides
=
{
}
)
{
let
config
=
await
runBasicFledgeTestExpectingWinner
(
test
uuid
auctionConfigOverrides
)
;
createAndNavigateFencedFrame
(
test
config
)
;
}
async
function
joinGroupAndRunBasicFledgeTestExpectingWinner
(
test
testConfig
=
{
}
)
{
const
uuid
=
testConfig
.
uuid
?
testConfig
.
uuid
:
generateUuid
(
test
)
;
await
joinInterestGroup
(
test
uuid
testConfig
.
interestGroupOverrides
)
;
await
runBasicFledgeTestExpectingWinner
(
test
uuid
testConfig
.
auctionConfigOverrides
)
;
}
async
function
joinGroupAndRunBasicFledgeTestExpectingNoWinner
(
test
testConfig
=
{
}
)
{
const
uuid
=
testConfig
.
uuid
?
testConfig
.
uuid
:
generateUuid
(
test
)
;
await
joinInterestGroup
(
test
uuid
testConfig
.
interestGroupOverrides
)
;
await
runBasicFledgeTestExpectingNoWinner
(
test
uuid
testConfig
.
auctionConfigOverrides
)
;
}
async
function
runReportTest
(
test
uuid
codeToInsert
expectedReportURLs
renderURLOverride
auctionConfigOverrides
)
{
let
scoreAd
=
codeToInsert
.
scoreAd
;
let
reportResultSuccessCondition
=
codeToInsert
.
reportResultSuccessCondition
;
let
reportResult
=
codeToInsert
.
reportResult
;
let
generateBid
=
codeToInsert
.
generateBid
;
let
reportWinSuccessCondition
=
codeToInsert
.
reportWinSuccessCondition
;
let
reportWin
=
codeToInsert
.
reportWin
;
let
decisionScriptURLOrigin
=
codeToInsert
.
decisionScriptURLOrigin
;
if
(
reportResultSuccessCondition
)
{
reportResult
=
if
(
!
(
{
reportResultSuccessCondition
}
)
)
{
sendReportTo
(
'
{
createSellerReportURL
(
uuid
'
error
'
)
}
'
)
;
return
false
;
}
{
reportResult
}
;
}
let
decisionScriptURLParams
=
{
}
;
if
(
scoreAd
!
=
=
undefined
)
{
decisionScriptURLParams
.
scoreAd
=
scoreAd
;
}
if
(
reportResult
!
=
=
null
)
decisionScriptURLParams
.
reportResult
=
reportResult
;
else
decisionScriptURLParams
.
error
=
'
no
-
reportResult
'
;
if
(
decisionScriptURLOrigin
!
=
=
undefined
)
{
decisionScriptURLParams
.
origin
=
decisionScriptURLOrigin
;
}
if
(
reportWinSuccessCondition
)
{
reportWin
=
if
(
!
(
{
reportWinSuccessCondition
}
)
)
{
sendReportTo
(
'
{
createBidderReportURL
(
uuid
'
error
'
)
}
'
)
;
return
false
;
}
{
reportWin
}
;
}
let
biddingScriptURLParams
=
{
}
;
if
(
generateBid
!
=
=
undefined
)
{
biddingScriptURLParams
.
generateBid
=
generateBid
;
}
if
(
reportWin
!
=
=
null
)
biddingScriptURLParams
.
reportWin
=
reportWin
;
else
biddingScriptURLParams
.
error
=
'
no
-
reportWin
'
;
let
interestGroupOverrides
=
{
biddingLogicURL
:
createBiddingScriptURL
(
biddingScriptURLParams
)
}
;
if
(
renderURLOverride
)
interestGroupOverrides
.
ads
=
[
{
renderURL
:
renderURLOverride
}
]
await
joinInterestGroup
(
test
uuid
interestGroupOverrides
)
;
if
(
auctionConfigOverrides
=
=
=
undefined
)
{
auctionConfigOverrides
=
{
decisionLogicURL
:
createDecisionScriptURL
(
uuid
decisionScriptURLParams
)
}
;
}
else
if
(
auctionConfigOverrides
.
decisionLogicURL
=
=
=
undefined
)
{
auctionConfigOverrides
.
decisionLogicURL
=
createDecisionScriptURL
(
uuid
decisionScriptURLParams
)
;
}
await
runBasicFledgeAuctionAndNavigate
(
test
uuid
auctionConfigOverrides
)
;
await
waitForObservedRequests
(
uuid
expectedReportURLs
)
;
}
async
function
runAdditionalBidTest
(
test
uuid
buyers
auctionNonce
additionalBidsPromise
highestScoringOtherBid
winningAdditionalBidId
)
{
await
runBasicFledgeAuctionAndNavigate
(
test
uuid
{
interestGroupBuyers
:
buyers
auctionNonce
:
auctionNonce
additionalBids
:
additionalBidsPromise
decisionLogicURL
:
createDecisionScriptURL
(
uuid
{
reportResult
:
sendReportTo
(
"
{
createSellerReportURL
(
uuid
)
}
&
highestScoringOtherBid
=
"
+
Math
.
round
(
browserSignals
.
highestScoringOtherBid
)
)
;
}
)
}
)
;
await
waitForObservedRequests
(
uuid
[
createHighestScoringOtherBidReportURL
(
uuid
highestScoringOtherBid
)
createBidderReportURL
(
uuid
winningAdditionalBidId
)
]
)
;
}
async
function
runAdditionalBidTestNoWinner
(
test
uuid
buyers
auctionNonce
additionalBidsPromise
)
{
await
runBasicFledgeTestExpectingNoWinner
(
test
uuid
{
interestGroupBuyers
:
buyers
auctionNonce
:
auctionNonce
additionalBids
:
additionalBidsPromise
decisionLogicURL
:
createDecisionScriptURL
(
uuid
)
}
)
;
}
async
function
runInFrame
(
test
child_window
script
param
)
{
const
messageUuid
=
generateUuid
(
test
)
;
let
receivedResponse
=
{
}
;
let
promise
=
new
Promise
(
function
(
resolve
reject
)
{
function
WaitForMessage
(
event
)
{
if
(
event
.
data
.
messageUuid
!
=
=
messageUuid
)
return
;
receivedResponse
=
event
.
data
;
if
(
event
.
data
.
result
=
=
=
'
success
'
)
{
resolve
(
)
;
}
else
{
reject
(
event
.
data
.
result
)
;
}
}
window
.
addEventListener
(
'
message
'
WaitForMessage
)
;
child_window
.
postMessage
(
{
messageUuid
:
messageUuid
script
:
script
param
:
param
}
'
*
'
)
;
}
)
;
await
promise
;
return
receivedResponse
.
returnValue
;
}
async
function
createFrame
(
test
origin
is_iframe
=
true
permissions
=
null
)
{
const
frameUuid
=
generateUuid
(
test
)
;
const
frameURL
=
{
origin
}
{
RESOURCE_PATH
}
subordinate
-
frame
.
sub
.
html
?
uuid
=
{
frameUuid
}
;
let
promise
=
new
Promise
(
function
(
resolve
reject
)
{
function
WaitForMessage
(
event
)
{
if
(
event
.
data
.
messageUuid
!
=
=
frameUuid
)
return
;
if
(
event
.
data
.
result
=
=
=
'
load
complete
'
)
{
resolve
(
)
;
}
else
{
reject
(
event
.
data
.
result
)
;
}
}
window
.
addEventListener
(
'
message
'
WaitForMessage
)
;
}
)
;
if
(
is_iframe
)
{
let
iframe
=
document
.
createElement
(
'
iframe
'
)
;
if
(
permissions
)
iframe
.
allow
=
permissions
;
iframe
.
src
=
frameURL
;
document
.
body
.
appendChild
(
iframe
)
;
test
.
add_cleanup
(
async
(
)
=
>
{
await
runInFrame
(
test
iframe
.
contentWindow
"
await
test_instance
.
do_cleanup
(
)
;
"
)
;
document
.
body
.
removeChild
(
iframe
)
;
}
)
;
await
promise
;
return
iframe
.
contentWindow
;
}
let
child_window
=
window
.
open
(
frameURL
)
;
test
.
add_cleanup
(
async
(
)
=
>
{
await
runInFrame
(
test
child_window
"
await
test_instance
.
do_cleanup
(
)
;
"
)
;
child_window
.
close
(
)
;
}
)
;
await
promise
;
return
child_window
;
}
async
function
createIframe
(
test
origin
permissions
=
null
)
{
return
await
createFrame
(
test
origin
true
permissions
)
;
}
async
function
createTopLevelWindow
(
test
origin
)
{
return
await
createFrame
(
test
origin
false
)
;
}
async
function
joinCrossOriginInterestGroup
(
test
uuid
origin
interestGroupOverrides
=
{
}
)
{
let
interestGroup
=
JSON
.
stringify
(
createInterestGroupForOrigin
(
uuid
origin
interestGroupOverrides
)
)
;
let
iframe
=
await
createIframe
(
test
origin
'
join
-
ad
-
interest
-
group
'
)
;
await
runInFrame
(
test
iframe
await
joinInterestGroup
(
test_instance
"
{
uuid
}
"
{
interestGroup
}
)
)
;
}
async
function
joinInterestGroupInTopLevelWindow
(
test
uuid
origin
interestGroupOverrides
=
{
}
)
{
let
interestGroup
=
JSON
.
stringify
(
createInterestGroupForOrigin
(
uuid
origin
interestGroupOverrides
)
)
;
let
topLevelWindow
=
await
createTopLevelWindow
(
test
origin
)
;
await
runInFrame
(
test
topLevelWindow
await
joinInterestGroup
(
test_instance
"
{
uuid
}
"
{
interestGroup
}
)
)
;
}
async
function
joinCrossOriginInterestGroupInTopLevelWindow
(
test
uuid
windowOrigin
interestGroupOrigin
interestGroupOverrides
=
{
}
)
{
let
interestGroup
=
JSON
.
stringify
(
createInterestGroupForOrigin
(
uuid
interestGroupOrigin
interestGroupOverrides
)
)
;
let
topLevelWindow
=
await
createTopLevelWindow
(
test
windowOrigin
)
;
await
runInFrame
(
test
topLevelWindow
await
joinCrossOriginInterestGroup
(
test_instance
"
{
uuid
}
"
"
{
interestGroupOrigin
}
"
{
interestGroup
}
)
)
;
}
async
function
fetchDirectFromSellerSignals
(
headers_content
origin
)
{
const
response
=
await
fetch
(
createDirectFromSellerSignalsURL
(
origin
)
{
adAuctionHeaders
:
true
headers
:
headers_content
}
)
;
if
(
!
(
'
Negative
-
Test
-
Option
'
in
headers_content
)
)
{
assert_equals
(
response
.
status
200
'
Failed
to
fetch
directFromSellerSignals
:
'
+
await
response
.
text
(
)
)
;
}
assert_false
(
response
.
headers
.
has
(
'
Ad
-
Auction
-
Signals
'
)
'
Header
"
Ad
-
Auction
-
Signals
"
should
be
hidden
from
documents
.
'
)
;
}
function
directFromSellerSignalsValidatorCode
(
uuid
expectedSellerSignals
expectedAuctionSignals
expectedPerBuyerSignals
)
{
expectedSellerSignals
=
JSON
.
stringify
(
expectedSellerSignals
)
;
expectedAuctionSignals
=
JSON
.
stringify
(
expectedAuctionSignals
)
;
expectedPerBuyerSignals
=
JSON
.
stringify
(
expectedPerBuyerSignals
)
;
return
{
scoreAd
:
if
(
directFromSellerSignals
=
=
null
|
|
directFromSellerSignals
.
sellerSignals
!
=
=
{
expectedSellerSignals
}
|
|
directFromSellerSignals
.
auctionSignals
!
=
=
{
expectedAuctionSignals
}
|
|
Object
.
keys
(
directFromSellerSignals
)
.
length
!
=
=
2
)
{
throw
'
Failed
to
get
expected
directFromSellerSignals
in
scoreAd
(
)
:
'
+
JSON
.
stringify
(
directFromSellerSignals
)
;
}
reportResultSuccessCondition
:
directFromSellerSignals
!
=
null
&
&
directFromSellerSignals
.
sellerSignals
=
=
=
{
expectedSellerSignals
}
&
&
directFromSellerSignals
.
auctionSignals
=
=
=
{
expectedAuctionSignals
}
&
&
Object
.
keys
(
directFromSellerSignals
)
.
length
=
=
=
2
reportResult
:
sendReportTo
(
"
{
createSellerReportURL
(
uuid
)
}
"
)
;
generateBid
:
if
(
directFromSellerSignals
=
=
null
|
|
directFromSellerSignals
.
perBuyerSignals
!
=
=
{
expectedPerBuyerSignals
}
|
|
directFromSellerSignals
.
auctionSignals
!
=
=
{
expectedAuctionSignals
}
|
|
Object
.
keys
(
directFromSellerSignals
)
.
length
!
=
=
2
)
{
throw
'
Failed
to
get
expected
directFromSellerSignals
in
generateBid
(
)
:
'
+
JSON
.
stringify
(
directFromSellerSignals
)
;
}
reportWinSuccessCondition
:
directFromSellerSignals
!
=
null
&
&
directFromSellerSignals
.
perBuyerSignals
=
=
=
{
expectedPerBuyerSignals
}
&
&
directFromSellerSignals
.
auctionSignals
=
=
=
{
expectedAuctionSignals
}
&
&
Object
.
keys
(
directFromSellerSignals
)
.
length
=
=
=
2
reportWin
:
sendReportTo
(
"
{
createBidderReportURL
(
uuid
)
}
"
)
;
}
;
}
let
additionalBidHelper
=
function
(
)
{
function
createAdditionalBid
(
uuid
seller
buyer
interestGroupName
bidAmount
)
{
return
{
interestGroup
:
{
name
:
interestGroupName
biddingLogicURL
:
createBiddingScriptURL
(
{
origin
:
buyer
reportAdditionalBidWin
:
sendReportTo
(
"
{
createBidderReportURL
(
uuid
interestGroupName
)
}
"
)
;
}
)
owner
:
buyer
}
bid
:
{
ad
:
[
'
metadata
'
]
bid
:
bidAmount
render
:
createRenderURL
(
uuid
)
}
seller
:
seller
testMetadata
:
{
}
}
;
}
function
setAuctionNonceInHeader
(
additionalBid
auctionNonce
)
{
additionalBid
.
testMetadata
.
auctionNonce
=
auctionNonce
;
}
function
setSellerNonceInHeader
(
additionalBid
sellerNonce
)
{
additionalBid
.
testMetadata
.
sellerNonce
=
sellerNonce
;
}
function
signWithSecretKeys
(
additionalBid
secretKeys
)
{
additionalBid
.
testMetadata
.
secretKeysForValidSignatures
=
secretKeys
;
}
function
incorrectlySignWithSecretKeys
(
additionalBid
secretKeys
)
{
additionalBid
.
testMetadata
.
secretKeysForInvalidSignatures
=
secretKeys
;
}
async
function
computeBidNonce
(
auctionNonce
sellerNonce
)
{
const
combined_utf8
=
new
TextEncoder
(
)
.
encode
(
auctionNonce
+
sellerNonce
)
;
const
hashed
=
await
crypto
.
subtle
.
digest
(
'
SHA
-
256
'
combined_utf8
)
;
return
btoa
(
String
.
fromCharCode
(
.
.
.
new
Uint8Array
(
hashed
)
)
)
;
}
function
addNegativeInterestGroup
(
additionalBid
negativeInterestGroup
)
{
additionalBid
.
negativeInterestGroup
=
negativeInterestGroup
;
}
function
addNegativeInterestGroups
(
additionalBid
negativeInterestGroups
joiningOrigin
)
{
additionalBid
.
negativeInterestGroups
=
{
joiningOrigin
:
joiningOrigin
interestGroupNames
:
negativeInterestGroups
}
;
}
const
_ed25519ModulePromise
=
import
(
'
.
.
/
third_party
/
noble
-
ed25519
/
noble
-
ed25519
.
js
'
)
;
async
function
_generateSignature
(
message
base64EncodedSecretKey
)
{
const
ed25519
=
await
_ed25519ModulePromise
;
const
secretKey
=
Uint8Array
.
from
(
atob
(
base64EncodedSecretKey
)
c
=
>
c
.
charCodeAt
(
0
)
)
;
const
[
publicKey
signature
]
=
await
Promise
.
all
(
[
ed25519
.
getPublicKeyAsync
(
secretKey
)
ed25519
.
signAsync
(
new
TextEncoder
(
)
.
encode
(
message
)
secretKey
)
]
)
;
return
{
'
key
'
:
btoa
(
String
.
fromCharCode
(
.
.
.
publicKey
)
)
'
signature
'
:
btoa
(
String
.
fromCharCode
(
.
.
.
signature
)
)
}
;
}
async
function
_signAdditionalBid
(
additionalBid
secretKeysForValidSignatures
secretKeysForInvalidSignatures
)
{
async
function
_signString
(
string
secretKeys
)
{
if
(
!
secretKeys
)
{
return
[
]
;
}
return
await
Promise
.
all
(
secretKeys
.
map
(
async
secretKey
=
>
await
_generateSignature
(
string
secretKey
)
)
)
;
}
assert_not_own_property
(
additionalBid
'
testMetadata
'
'
testMetadata
should
be
removed
from
additionalBid
before
signing
'
)
;
const
additionalBidString
=
JSON
.
stringify
(
additionalBid
)
;
let
[
validSignatures
invalidSignatures
]
=
await
Promise
.
all
(
[
_signString
(
additionalBidString
secretKeysForValidSignatures
)
_signString
(
'
invalid
'
+
additionalBidString
secretKeysForInvalidSignatures
)
]
)
;
return
{
'
bid
'
:
additionalBidString
'
signatures
'
:
validSignatures
.
concat
(
invalidSignatures
)
}
;
}
async
function
_convertAdditionalBidToResponseHeader
(
additionalBid
)
{
const
testMetadata
=
additionalBid
.
testMetadata
;
delete
additionalBid
.
testMetadata
;
const
signedAdditionalBid
=
await
_signAdditionalBid
(
additionalBid
testMetadata
.
secretKeysForValidSignatures
testMetadata
.
secretKeysForInvalidSignatures
)
;
return
[
testMetadata
.
auctionNonce
testMetadata
.
sellerNonce
btoa
(
JSON
.
stringify
(
signedAdditionalBid
)
)
]
.
filter
(
k
=
>
k
!
=
=
undefined
)
.
join
(
'
:
'
)
;
}
async
function
fetchAdditionalBids
(
seller
additionalBids
)
{
additionalBidHeaderValues
=
await
Promise
.
all
(
additionalBids
.
map
(
async
additionalBid
=
>
await
_convertAdditionalBidToResponseHeader
(
additionalBid
)
)
)
;
const
url
=
new
URL
(
{
seller
}
{
RESOURCE_PATH
}
additional
-
bids
.
py
)
;
url
.
searchParams
.
append
(
'
additionalBidHeaderValues
'
JSON
.
stringify
(
additionalBidHeaderValues
)
)
;
const
response
=
await
fetch
(
url
.
href
{
adAuctionHeaders
:
true
}
)
;
assert_equals
(
response
.
status
200
'
Failed
to
fetch
additional
bid
:
'
+
await
response
.
text
(
)
)
;
assert_false
(
response
.
headers
.
has
(
'
Ad
-
Auction
-
Additional
-
Bid
'
)
'
Header
"
Ad
-
Auction
-
Additional
-
Bid
"
should
not
be
available
in
JavaScript
context
.
'
)
;
}
return
{
createAdditionalBid
:
createAdditionalBid
setAuctionNonceInHeader
:
setAuctionNonceInHeader
setSellerNonceInHeader
:
setSellerNonceInHeader
signWithSecretKeys
:
signWithSecretKeys
incorrectlySignWithSecretKeys
:
incorrectlySignWithSecretKeys
computeBidNonce
:
computeBidNonce
addNegativeInterestGroup
:
addNegativeInterestGroup
addNegativeInterestGroups
:
addNegativeInterestGroups
fetchAdditionalBids
:
fetchAdditionalBids
}
;
}
(
)
;
function
createStringBeforeAndAfterReplacements
(
deprecatedRenderURLReplacements
)
{
let
beforeReplacements
=
'
'
;
let
afterReplacements
=
'
'
;
if
(
deprecatedRenderURLReplacements
)
{
for
(
const
[
match
replacement
]
of
Object
.
entries
(
deprecatedRenderURLReplacements
)
)
{
beforeReplacements
+
=
match
+
"
/
"
;
afterReplacements
+
=
replacement
+
"
/
"
;
}
}
return
{
beforeReplacements
afterReplacements
}
;
}
async
function
deleteAllCookies
(
)
{
await
test_driver
.
delete_all_cookies
(
)
;
}
async
function
setCookie
(
test
)
{
await
deleteAllCookies
(
)
;
document
.
cookie
=
'
cookie
=
cookie
;
path
=
/
'
test
.
add_cleanup
(
deleteAllCookies
)
;
}
