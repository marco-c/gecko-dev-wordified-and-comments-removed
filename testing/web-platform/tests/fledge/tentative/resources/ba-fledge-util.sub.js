'
use
strict
;
'
let
BA
=
{
}
;
(
function
(
BA
)
{
const
TestPrivateKey
=
new
Uint8Array
(
[
0xff
0x1f
0x47
0xb1
0x68
0xb6
0xb9
0xea
0x65
0xf7
0x97
0x4f
0xf2
0x2e
0xf2
0x36
0x94
0xe2
0xf6
0xb6
0x8d
0x66
0xf3
0xa7
0x64
0x14
0x28
0xd4
0x45
0x35
0x01
0x8f
]
)
;
const
_hpkeModulePromise
=
import
(
'
.
.
/
third_party
/
hpke
-
js
/
hpke
.
js
'
)
;
function
_get16
(
buffer
offset
)
{
return
buffer
[
offset
]
<
<
8
|
buffer
[
offset
+
1
]
;
}
function
_get32
(
buffer
offset
)
{
return
buffer
[
offset
]
<
<
24
|
buffer
[
offset
+
1
]
<
<
16
|
buffer
[
offset
+
2
]
<
<
8
|
buffer
[
offset
+
3
]
;
}
function
_put16
(
buffer
offset
val
)
{
buffer
[
offset
]
=
val
>
>
8
;
buffer
[
offset
+
1
]
=
val
&
0xFF
;
}
function
_put32
(
buffer
offset
val
)
{
buffer
[
offset
]
=
(
val
>
>
24
)
&
0xFF
;
buffer
[
offset
+
1
]
=
(
val
>
>
16
)
&
0xFF
;
buffer
[
offset
+
2
]
=
(
val
>
>
8
)
&
0xFF
;
buffer
[
offset
+
3
]
=
val
&
0xFF
;
}
function
_concat
(
a
b
)
{
let
c
=
new
Uint8Array
(
a
.
length
+
b
.
length
)
;
for
(
var
i
=
0
;
i
<
a
.
length
;
+
+
i
)
{
c
[
i
]
=
a
[
i
]
;
}
for
(
var
i
=
0
;
i
<
b
.
length
;
+
+
i
)
{
c
[
i
+
a
.
length
]
=
b
[
i
]
;
}
return
c
;
}
function
_toArrayBuffer
(
typedArray
)
{
return
typedArray
.
buffer
.
slice
(
typedArray
.
byteOffset
typedArray
.
byteOffset
+
typedArray
.
byteLength
)
;
}
function
_toBytesArrayBuffer
(
str
)
{
return
_toArrayBuffer
(
new
TextEncoder
(
)
.
encode
(
str
)
)
;
}
function
_bufferAsStream
(
buffer
)
{
return
new
ReadableStream
(
{
start
:
controller
=
>
{
controller
.
enqueue
(
buffer
)
;
controller
.
close
(
)
;
}
}
)
;
}
async
function
_applyTransform
(
inData
transform
)
{
const
resultResponse
=
new
Response
(
_bufferAsStream
(
inData
)
.
pipeThrough
(
transform
)
)
;
const
resultBlob
=
await
resultResponse
.
blob
(
)
;
return
await
resultBlob
.
arrayBuffer
(
)
;
}
async
function
_gzip
(
inData
)
{
const
compress
=
new
CompressionStream
(
'
gzip
'
)
;
return
_applyTransform
(
inData
compress
)
;
}
async
function
_gunzip
(
inData
)
{
const
decompress
=
new
DecompressionStream
(
'
gzip
'
)
;
return
_applyTransform
(
inData
decompress
)
;
}
function
_decodeIgDataHeader
(
igData
)
{
if
(
igData
.
length
<
8
)
{
throw
'
Not
enough
data
for
B
&
A
and
OHTTP
headers
'
;
}
return
{
version
:
igData
[
0
]
keyId
:
igData
[
1
]
kemId
:
_get16
(
igData
2
)
kdfId
:
_get16
(
igData
4
)
aeadId
:
_get16
(
igData
6
)
payload
:
igData
.
slice
(
8
)
}
;
}
function
_splitIgDataPayloadIntoEncAndCt
(
header
suite
)
{
const
RequestMessageType
=
'
message
/
auction
request
'
;
const
infoLength
=
RequestMessageType
.
length
+
1
+
1
+
6
;
let
info
=
new
Uint8Array
(
infoLength
)
;
for
(
let
pos
=
0
;
pos
<
RequestMessageType
.
length
;
+
+
pos
)
{
info
[
pos
]
=
RequestMessageType
.
charCodeAt
(
pos
)
;
}
info
[
RequestMessageType
.
length
]
=
0
;
info
[
RequestMessageType
.
length
+
1
]
=
header
.
keyId
;
_put16
(
info
RequestMessageType
.
length
+
2
header
.
kemId
)
;
_put16
(
info
RequestMessageType
.
length
+
4
header
.
kdfId
)
;
_put16
(
info
RequestMessageType
.
length
+
6
header
.
aeadId
)
;
return
{
info
:
info
enc
:
header
.
payload
.
slice
(
0
suite
.
kem
.
encSize
)
ct
:
header
.
payload
.
slice
(
suite
.
kem
.
encSize
)
}
;
}
function
_decodeIgDataPaddingHeader
(
decryptedText
)
{
let
length
=
_get32
(
decryptedText
1
)
;
let
format
=
decryptedText
[
0
]
;
assert_equals
(
format
2
)
;
return
{
format
:
format
data
:
decryptedText
.
slice
(
5
5
+
length
)
}
;
}
function
_frameServerResponse
(
arrayBuffer
)
{
let
array
=
new
Uint8Array
(
arrayBuffer
)
;
let
framedLength
=
5
+
array
.
length
;
let
framed
=
new
Uint8Array
(
framedLength
)
;
framed
[
0
]
=
2
;
_put32
(
framed
1
array
.
length
)
;
for
(
let
i
=
0
;
i
<
array
.
length
;
+
+
i
)
{
framed
[
i
+
5
]
=
array
[
i
]
;
}
return
framed
;
}
async
function
_encryptServerResponse
(
payload
decoded
)
{
const
ResponseMessageType
=
'
message
/
auction
response
'
;
const
Nk
=
decoded
.
cipherSuite
.
aead
.
keySize
;
const
Nn
=
decoded
.
cipherSuite
.
aead
.
nonceSize
;
let
secret
=
await
decoded
.
receiveContext
.
export
(
_toBytesArrayBuffer
(
ResponseMessageType
)
Math
.
max
(
Nk
Nn
)
)
;
let
responseNonce
=
new
Uint8Array
(
Math
.
max
(
Nk
Nn
)
)
;
crypto
.
getRandomValues
(
responseNonce
)
;
let
salt
=
_concat
(
decoded
.
enc
responseNonce
)
;
let
prk
=
await
decoded
.
cipherSuite
.
kdf
.
extract
(
salt
secret
)
;
let
aeadKey
=
await
decoded
.
cipherSuite
.
kdf
.
expand
(
prk
_toBytesArrayBuffer
(
'
key
'
)
Nk
)
;
let
aeadNonce
=
await
decoded
.
cipherSuite
.
kdf
.
expand
(
prk
_toBytesArrayBuffer
(
'
nonce
'
)
Nn
)
;
let
encContext
=
decoded
.
cipherSuite
.
aead
.
createEncryptionContext
(
aeadKey
)
;
let
ct
=
await
encContext
.
seal
(
aeadNonce
payload
_toBytesArrayBuffer
(
'
'
)
)
;
return
_concat
(
responseNonce
new
Uint8Array
(
ct
)
)
;
}
function
_sortForCbor
(
input
)
{
if
(
input
=
=
=
null
|
|
typeof
input
!
=
=
'
object
'
)
{
return
input
;
}
if
(
input
instanceof
Array
)
{
let
out
=
[
]
;
for
(
let
i
=
0
;
i
<
input
.
length
;
+
+
i
)
{
out
[
i
]
=
_sortForCbor
(
input
[
i
]
)
;
}
return
out
;
}
else
{
let
keys
=
Object
.
getOwnPropertyNames
(
input
)
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
length
<
b
.
length
)
return
-
1
;
if
(
a
.
length
>
b
.
length
)
return
1
;
if
(
a
<
b
)
return
-
1
;
if
(
a
>
b
)
return
1
;
return
0
;
}
)
;
let
out
=
{
}
;
for
(
let
key
of
keys
)
{
out
[
key
]
=
_sortForCbor
(
input
[
key
]
)
;
}
return
out
;
}
}
BA
.
decodeInterestGroupData
=
async
function
(
igData
)
{
const
hpke
=
await
_hpkeModulePromise
;
const
header
=
_decodeIgDataHeader
(
igData
)
;
assert_equals
(
header
.
version
0
)
;
assert_equals
(
header
.
keyId
0x12
)
;
assert_equals
(
header
.
kemId
hpke
.
KemId
.
DhkemX25519HkdfSha256
)
;
assert_equals
(
header
.
kdfId
hpke
.
KdfId
.
HkdfSha256
)
;
assert_equals
(
header
.
aeadId
hpke
.
AeadId
.
Aes256Gcm
)
;
const
suite
=
new
hpke
.
CipherSuite
(
{
kem
:
header
.
kemId
kdf
:
header
.
kdfId
aead
:
header
.
aeadId
}
)
;
const
pieces
=
_splitIgDataPayloadIntoEncAndCt
(
header
suite
)
;
const
privateKey
=
await
suite
.
kem
.
importKey
(
'
raw
'
TestPrivateKey
)
;
const
recipient
=
await
suite
.
createRecipientContext
(
{
recipientKey
:
privateKey
info
:
pieces
.
info
enc
:
pieces
.
enc
}
)
;
const
pt
=
new
Uint8Array
(
await
recipient
.
open
(
pieces
.
ct
)
)
;
const
withoutPadding
=
_decodeIgDataPaddingHeader
(
pt
)
;
const
decoded
=
CBOR
.
decode
(
_toArrayBuffer
(
withoutPadding
.
data
)
)
;
for
(
let
key
of
Object
.
getOwnPropertyNames
(
decoded
.
interestGroups
)
)
{
let
val
=
decoded
.
interestGroups
[
key
]
;
let
decompressedVal
=
await
_gunzip
(
val
)
;
decoded
.
interestGroups
[
key
]
=
CBOR
.
decode
(
decompressedVal
)
;
}
return
{
paddedSize
:
pt
.
length
message
:
decoded
receiveContext
:
recipient
cipherSuite
:
suite
enc
:
pieces
.
enc
}
;
}
;
BA
.
encodeServerResponse
=
async
function
(
responseObject
decoded
)
{
let
cborPayload
=
new
Uint8Array
(
CBOR
.
encode
(
_sortForCbor
(
responseObject
)
)
)
;
let
gzipPayload
=
await
_gzip
(
cborPayload
)
;
let
framedPayload
=
_toArrayBuffer
(
_frameServerResponse
(
gzipPayload
)
)
;
return
await
_encryptServerResponse
(
framedPayload
decoded
)
;
}
;
BA
.
payloadHash
=
async
function
(
serverResponse
)
{
let
hash
=
new
Uint8Array
(
await
crypto
.
subtle
.
digest
(
'
SHA
-
256
'
serverResponse
)
)
;
let
hashString
=
'
'
for
(
let
i
=
0
;
i
<
hash
.
length
;
+
+
i
)
{
hashString
+
=
String
.
fromCharCode
(
hash
[
i
]
)
;
}
return
btoa
(
hashString
)
.
replace
(
/
\
+
/
g
'
-
'
)
.
replace
(
/
\
/
/
g
'
_
'
)
.
replace
(
/
=
+
/
g
'
'
)
;
}
;
BA
.
authorizeServerResponseHashes
=
async
function
(
hashes
)
{
let
authorizeURL
=
new
URL
(
'
resources
/
authorize
-
server
-
response
.
py
'
window
.
location
)
;
authorizeURL
.
searchParams
.
append
(
'
hashes
'
hashes
.
join
(
'
'
)
)
;
await
fetch
(
authorizeURL
{
adAuctionHeaders
:
true
}
)
;
}
;
}
)
(
BA
)
;
