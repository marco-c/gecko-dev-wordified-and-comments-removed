import
collections
import
json
from
urllib
.
parse
import
unquote_plus
from
fledge
.
tentative
.
resources
import
fledge_http_server_util
def
main
(
request
response
)
:
    
hostname
=
None
    
keys
=
None
    
interestGroupNames
=
None
    
for
param
in
request
.
url_parts
.
query
.
split
(
"
&
"
)
:
        
pair
=
param
.
split
(
"
=
"
1
)
        
if
len
(
pair
)
!
=
2
:
            
fail
(
response
"
Bad
query
parameter
:
"
+
param
)
            
return
        
if
"
%
20
"
in
pair
[
1
]
:
            
fail
(
response
"
Query
parameter
should
escape
using
'
+
'
:
"
+
param
)
            
return
        
if
pair
[
0
]
=
=
"
hostname
"
and
hostname
=
=
None
and
len
(
pair
[
1
]
)
>
0
:
            
hostname
=
pair
[
1
]
            
continue
        
if
pair
[
0
]
=
=
"
keys
"
and
keys
=
=
None
:
            
keys
=
list
(
map
(
unquote_plus
pair
[
1
]
.
split
(
"
"
)
)
)
            
continue
        
if
pair
[
0
]
=
=
"
interestGroupNames
"
and
interestGroupNames
=
=
None
:
            
interestGroupNames
=
list
(
map
(
unquote_plus
pair
[
1
]
.
split
(
"
"
)
)
)
            
continue
        
if
pair
[
0
]
=
=
"
slotSize
"
or
pair
[
0
]
=
=
"
allSlotsRequestedSizes
"
:
            
continue
        
fail
(
response
"
Unexpected
query
parameter
:
"
+
param
)
        
return
    
if
keys
and
"
cors
"
in
keys
and
fledge_http_server_util
.
handle_cors_headers_fail_if_preflight
(
            
request
response
)
:
        
return
    
if
not
hostname
:
        
fail
(
response
"
hostname
missing
"
)
        
return
    
if
not
interestGroupNames
:
        
fail
(
response
"
interestGroupNames
missing
"
)
        
return
    
response
.
status
=
(
200
b
"
OK
"
)
    
responseBody
=
{
"
keys
"
:
{
}
}
    
body
=
None
    
contentType
=
"
application
/
json
"
    
adAuctionAllowed
=
"
true
"
    
dataVersion
=
None
    
if
keys
:
        
for
key
in
keys
:
            
value
=
"
default
value
"
            
if
key
=
=
"
close
-
connection
"
:
                
response
.
writer
.
write
(
"
"
)
                
response
.
close_connection
=
True
                
return
            
elif
key
.
startswith
(
"
replace
-
body
:
"
)
:
                
body
=
key
.
split
(
'
:
'
1
)
[
1
]
            
elif
key
.
startswith
(
"
data
-
version
:
"
)
:
                
dataVersion
=
key
.
split
(
'
:
'
1
)
[
1
]
            
elif
key
=
=
"
http
-
error
"
:
                
response
.
status
=
(
404
b
"
Not
found
"
)
            
elif
key
=
=
"
no
-
content
-
type
"
:
                
contentType
=
None
            
elif
key
=
=
"
wrong
-
content
-
type
"
:
                
contentType
=
'
text
/
plain
'
            
elif
key
=
=
"
bad
-
ad
-
auction
-
allowed
"
:
                
adAuctionAllowed
=
"
sometimes
"
            
elif
key
=
=
"
ad
-
auction
-
not
-
allowed
"
:
                
adAuctionAllowed
=
"
false
"
            
elif
key
=
=
"
no
-
ad
-
auction
-
allow
"
:
                
adAuctionAllowed
=
None
            
elif
key
=
=
"
no
-
value
"
:
                
continue
            
elif
key
=
=
"
wrong
-
value
"
:
                
responseBody
[
"
keys
"
]
[
"
another
-
value
"
]
=
"
another
-
value
"
                
continue
            
elif
key
=
=
"
null
-
value
"
:
                
value
=
None
            
elif
key
=
=
"
num
-
value
"
:
                
value
=
1
            
elif
key
=
=
"
string
-
value
"
:
                
value
=
"
1
"
            
elif
key
=
=
"
array
-
value
"
:
                
value
=
[
1
"
foo
"
None
]
            
elif
key
=
=
"
object
-
value
"
:
                
value
=
{
"
a
"
:
"
b
"
"
c
"
:
[
"
d
"
]
}
            
elif
key
=
=
"
interest
-
group
-
names
"
:
                
value
=
json
.
dumps
(
interestGroupNames
)
            
elif
key
=
=
"
hostname
"
:
                
value
=
request
.
GET
.
first
(
b
"
hostname
"
b
"
not
-
found
"
)
.
decode
(
"
ASCII
"
)
            
elif
key
=
=
"
headers
"
:
                
value
=
fledge_http_server_util
.
headers_to_ascii
(
request
.
headers
)
            
elif
key
=
=
"
slotSize
"
:
                
value
=
request
.
GET
.
first
(
b
"
slotSize
"
b
"
not
-
found
"
)
.
decode
(
"
ASCII
"
)
            
elif
key
=
=
"
allSlotsRequestedSizes
"
:
                
value
=
request
.
GET
.
first
(
b
"
allSlotsRequestedSizes
"
b
"
not
-
found
"
)
.
decode
(
"
ASCII
"
)
            
elif
key
=
=
"
url
"
:
                
value
=
request
.
url
            
responseBody
[
"
keys
"
]
[
key
]
=
value
    
if
"
data
-
version
"
in
interestGroupNames
:
        
dataVersion
=
"
4
"
    
per_interest_group_data
=
collections
.
defaultdict
(
dict
)
    
for
name
in
interestGroupNames
:
      
if
name
=
=
"
use
-
update
-
if
-
older
-
than
-
ms
"
:
        
per_interest_group_data
[
name
]
[
"
updateIfOlderThanMs
"
]
=
3_600_000
      
elif
name
=
=
"
use
-
update
-
if
-
older
-
than
-
ms
-
small
"
:
        
per_interest_group_data
[
name
]
[
"
updateIfOlderThanMs
"
]
=
1
      
elif
name
=
=
"
use
-
update
-
if
-
older
-
than
-
ms
-
zero
"
:
        
per_interest_group_data
[
name
]
[
"
updateIfOlderThanMs
"
]
=
0
      
elif
name
=
=
"
use
-
update
-
if
-
older
-
than
-
ms
-
negative
"
:
        
per_interest_group_data
[
name
]
[
"
updateIfOlderThanMs
"
]
=
-
1
    
if
per_interest_group_data
:
      
responseBody
[
"
perInterestGroupData
"
]
=
dict
(
per_interest_group_data
)
    
if
contentType
:
        
response
.
headers
.
set
(
"
Content
-
Type
"
contentType
)
    
if
adAuctionAllowed
:
        
response
.
headers
.
set
(
"
Ad
-
Auction
-
Allowed
"
adAuctionAllowed
)
    
if
dataVersion
:
        
response
.
headers
.
set
(
"
Data
-
Version
"
dataVersion
)
    
response
.
headers
.
set
(
"
Ad
-
Auction
-
Bidding
-
Signals
-
Format
-
Version
"
"
2
"
)
    
if
body
!
=
None
:
        
return
body
    
return
json
.
dumps
(
responseBody
)
