function
MixedContentTestCase
(
scenario
description
sanityChecker
)
{
var
httpProtocol
=
"
http
"
;
var
httpsProtocol
=
"
https
"
;
var
wsProtocol
=
"
ws
"
;
var
wssProtocol
=
"
wss
"
;
var
sameOriginHost
=
location
.
hostname
;
var
crossOriginHost
=
"
{
{
domains
[
www1
]
}
}
"
;
var
httpPort
=
getNormalizedPort
(
parseInt
(
"
{
{
ports
[
http
]
[
0
]
}
}
"
10
)
)
;
var
httpsPort
=
getNormalizedPort
(
parseInt
(
"
{
{
ports
[
https
]
[
0
]
}
}
"
10
)
)
;
var
wsPort
=
getNormalizedPort
(
parseInt
(
"
{
{
ports
[
ws
]
[
0
]
}
}
"
10
)
)
;
var
wssPort
=
getNormalizedPort
(
parseInt
(
"
{
{
ports
[
wss
]
[
0
]
}
}
"
10
)
)
;
var
resourcePath
=
"
/
mixed
-
content
/
generic
/
expect
.
py
"
;
var
wsResourcePath
=
"
/
stash_responder
"
;
var
endpoint
=
{
"
same
-
origin
"
:
location
.
origin
+
resourcePath
"
same
-
host
-
https
"
:
httpsProtocol
+
"
:
/
/
"
+
sameOriginHost
+
httpsPort
+
resourcePath
"
same
-
host
-
http
"
:
httpProtocol
+
"
:
/
/
"
+
sameOriginHost
+
httpPort
+
resourcePath
"
cross
-
origin
-
https
"
:
httpsProtocol
+
"
:
/
/
"
+
crossOriginHost
+
httpsPort
+
resourcePath
"
cross
-
origin
-
http
"
:
httpProtocol
+
"
:
/
/
"
+
crossOriginHost
+
httpPort
+
resourcePath
"
same
-
host
-
wss
"
:
wssProtocol
+
"
:
/
/
"
+
sameOriginHost
+
wssPort
+
wsResourcePath
"
same
-
host
-
ws
"
:
wsProtocol
+
"
:
/
/
"
+
sameOriginHost
+
wsPort
+
wsResourcePath
"
cross
-
origin
-
wss
"
:
wssProtocol
+
"
:
/
/
"
+
crossOriginHost
+
wssPort
+
wsResourcePath
"
cross
-
origin
-
ws
"
:
wsProtocol
+
"
:
/
/
"
+
crossOriginHost
+
wsPort
+
wsResourcePath
}
;
var
resourceMap
=
{
"
a
-
tag
"
:
requestViaAnchor
"
area
-
tag
"
:
requestViaArea
"
beacon
-
request
"
:
requestViaSendBeacon
"
fetch
-
request
"
:
requestViaFetch
"
form
-
tag
"
:
requestViaForm
"
iframe
-
tag
"
:
requestViaIframe
"
img
-
tag
"
:
requestViaImage
"
script
-
tag
"
:
requestViaScript
"
worker
-
request
"
:
url
=
>
requestViaDedicatedWorker
(
url
)
"
module
-
worker
-
top
-
level
"
:
url
=
>
requestViaDedicatedWorker
(
url
{
type
:
"
module
"
}
)
"
module
-
data
-
worker
-
import
"
:
url
=
>
requestViaDedicatedWorker
(
workerUrlThatImports
(
url
)
{
type
:
"
module
"
}
)
"
classic
-
data
-
worker
-
fetch
"
:
url
=
>
requestViaDedicatedWorker
(
dedicatedWorkerUrlThatFetches
(
url
)
{
}
)
"
xhr
-
request
"
:
requestViaXhr
"
audio
-
tag
"
:
requestViaAudio
"
video
-
tag
"
:
requestViaVideo
"
picture
-
tag
"
:
requestViaPicture
"
object
-
tag
"
:
requestViaObject
"
link
-
css
-
tag
"
:
requestViaLinkStylesheet
"
link
-
prefetch
-
tag
"
:
requestViaLinkPrefetch
"
websocket
-
request
"
:
requestViaWebSocket
}
;
var
contentType
=
{
"
a
-
tag
"
:
"
text
/
html
"
"
area
-
tag
"
:
"
text
/
html
"
"
beacon
-
request
"
:
"
text
/
plain
"
"
fetch
-
request
"
:
"
application
/
json
"
"
form
-
tag
"
:
"
text
/
html
"
"
iframe
-
tag
"
:
"
text
/
html
"
"
img
-
tag
"
:
"
image
/
png
"
"
script
-
tag
"
:
"
text
/
javascript
"
"
worker
-
request
"
:
"
application
/
javascript
"
"
module
-
worker
-
top
-
level
"
:
"
application
/
javascript
"
"
module
-
data
-
worker
-
import
"
:
"
application
/
javascript
"
"
classic
-
data
-
worker
-
fetch
"
:
"
application
/
javascript
"
"
xhr
-
request
"
:
"
application
/
json
"
"
audio
-
tag
"
:
"
audio
/
wav
"
"
video
-
tag
"
:
"
video
/
ogg
"
"
picture
-
tag
"
:
"
image
/
png
"
"
object
-
tag
"
:
"
text
/
html
"
"
link
-
css
-
tag
"
:
"
text
/
css
"
"
link
-
prefetch
-
tag
"
:
"
text
/
html
"
"
websocket
-
request
"
:
"
application
/
json
"
}
;
for
(
const
workletType
of
[
'
animation
'
'
audio
'
'
layout
'
'
paint
'
]
)
{
resourceMap
[
worklet
-
{
workletType
}
-
top
-
level
]
=
url
=
>
requestViaWorklet
(
workletType
url
)
;
contentType
[
worklet
-
{
workletType
}
-
top
-
level
]
=
"
application
/
javascript
"
;
resourceMap
[
worklet
-
{
workletType
}
-
data
-
import
]
=
url
=
>
requestViaWorklet
(
workletType
workerUrlThatImports
(
url
)
)
;
contentType
[
worklet
-
{
workletType
}
-
data
-
import
]
=
"
application
/
javascript
"
;
}
sanityChecker
.
checkScenario
(
scenario
resourceMap
)
;
var
mixed_content_test
=
async_test
(
description
)
;
function
runTest
(
)
{
sanityChecker
.
setFailTimeout
(
mixed_content_test
)
;
var
key
=
guid
(
)
;
var
value
=
guid
(
)
;
var
stash_path
=
encodeURIComponent
(
"
/
mixed
-
content
"
)
;
var
announceResourceRequestUrl
=
endpoint
[
'
same
-
origin
'
]
+
"
?
action
=
put
&
key
=
"
+
key
+
"
&
value
=
"
+
value
+
"
&
path
=
"
+
stash_path
;
var
assertResourceRequestUrl
=
endpoint
[
'
same
-
origin
'
]
+
"
?
action
=
take
&
key
=
"
+
key
+
"
&
path
=
"
+
stash_path
;
var
resourceRequestUrl
=
endpoint
[
scenario
.
origin
]
+
"
?
redirection
=
"
+
scenario
.
redirection
+
"
&
action
=
purge
&
key
=
"
+
key
+
"
&
path
=
"
+
stash_path
+
"
&
content_type
=
"
+
contentType
[
scenario
.
subresource
]
;
xhrRequest
(
announceResourceRequestUrl
)
.
then
(
mixed_content_test
.
step_func
(
_
=
>
{
return
resourceMap
[
scenario
.
subresource
]
(
resourceRequestUrl
)
;
}
)
)
.
then
(
mixed_content_test
.
step_func
(
_
=
>
{
return
xhrRequest
(
assertResourceRequestUrl
)
;
}
)
)
.
catch
(
mixed_content_test
.
step_func
(
e
=
>
{
return
xhrRequest
(
assertResourceRequestUrl
)
;
}
)
)
.
then
(
mixed_content_test
.
step_func_done
(
response
=
>
{
assert_equals
(
response
.
status
scenario
.
expectation
"
The
resource
request
should
be
'
"
+
scenario
.
expectation
+
"
'
.
"
)
;
}
)
)
;
}
return
{
start
:
mixed_content_test
.
step_func
(
runTest
)
}
;
}
