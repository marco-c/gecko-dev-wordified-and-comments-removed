importScripts
(
"
mediasource
-
worker
-
util
.
js
"
)
;
onmessage
=
function
(
evt
)
{
postMessage
(
{
subject
:
messageSubject
.
ERROR
info
:
"
No
message
expected
by
Worker
"
}
)
;
}
;
let
util
=
new
MediaSourceWorkerUtil
(
)
;
let
sentStartedBufferingMessage
=
false
;
util
.
mediaSource
.
addEventListener
(
"
sourceopen
"
(
)
=
>
{
URL
.
revokeObjectURL
(
util
.
mediaSourceObjectUrl
)
;
let
sourceBuffer
;
try
{
sourceBuffer
=
util
.
mediaSource
.
addSourceBuffer
(
util
.
mediaMetadata
.
type
)
;
}
catch
(
e
)
{
return
;
}
sourceBuffer
.
onerror
=
(
err
)
=
>
{
postMessage
(
{
subject
:
messageSubject
.
ERROR
info
:
err
}
)
;
}
;
util
.
mediaLoadPromise
.
then
(
mediaData
=
>
bufferInto
(
sourceBuffer
mediaData
100
0
)
err
=
>
{
postMessage
(
{
subject
:
messageSubject
.
ERROR
info
:
err
}
)
}
)
;
}
{
once
:
true
}
)
;
postMessage
(
{
subject
:
messageSubject
.
OBJECT_URL
info
:
util
.
mediaSourceObjectUrl
}
)
;
function
bufferInto
(
sourceBuffer
mediaData
appendSize
position
)
{
if
(
position
>
=
mediaData
.
byteLength
)
{
postMessage
(
{
subject
:
messageSubject
.
FINISHED_BUFFERING
}
)
;
try
{
util
.
mediaSource
.
endOfStream
(
)
;
}
catch
(
e
)
{
}
return
;
}
var
nextPosition
=
position
+
appendSize
;
const
pieceToAppend
=
mediaData
.
slice
(
position
nextPosition
)
;
position
=
nextPosition
;
appendSize
+
=
100
;
sourceBuffer
.
addEventListener
(
"
updateend
"
(
)
=
>
{
if
(
!
sentStartedBufferingMessage
)
{
postMessage
(
{
subject
:
messageSubject
.
STARTED_BUFFERING
}
)
;
sentStartedBufferingMessage
=
true
;
}
bufferInto
(
sourceBuffer
mediaData
appendSize
position
)
;
}
{
once
:
true
}
)
;
try
{
sourceBuffer
.
appendBuffer
(
pieceToAppend
)
;
}
catch
(
e
)
{
}
}
