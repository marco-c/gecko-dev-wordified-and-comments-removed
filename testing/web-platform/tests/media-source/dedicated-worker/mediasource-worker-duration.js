importScripts
(
"
mediasource
-
worker
-
util
.
js
"
)
;
let
util
=
new
MediaSourceWorkerUtil
(
)
;
let
sourceBuffer
;
const
testPhase
=
{
kInitial
:
"
Initial
"
kAttaching
:
"
Awaiting
sourceopen
event
that
signals
attachment
is
setup
"
kRequestNaNDurationCheck
:
"
Sending
request
to
main
thread
to
verify
expected
duration
of
the
freshly
setup
attachment
"
kConfirmNaNDurationResult
:
"
Checking
that
main
thread
correctly
ACK
'
ed
the
freshly
setup
attachment
'
s
duration
verification
request
"
kRequestHaveNothingReadyStateCheck
:
"
Sending
request
to
main
thread
to
verify
expected
readyState
of
HAVE_NOTHING
of
the
freshly
setup
attachment
"
kConfirmHaveNothingReadyStateResult
:
"
Checking
that
main
thread
correctly
ACK
'
ed
the
freshly
setup
attachment
'
s
readyState
HAVE_NOTHING
verification
request
"
kRequestSetDurationCheck
:
"
Sending
request
to
main
thread
to
verify
explicitly
set
duration
before
any
media
data
has
been
appended
"
kConfirmSetDurationResult
:
"
Checking
that
main
thread
correctly
ACK
'
ed
the
duration
verification
request
of
explicitly
set
duration
before
any
media
data
has
been
appended
"
kRequestHaveNothingReadyStateRecheck
:
"
Sending
request
to
main
thread
to
recheck
that
the
readyState
is
still
HAVE_NOTHING
"
kConfirmHaveNothingReadyStateRecheckResult
:
"
Checking
that
main
thread
correctly
ACK
'
ed
the
request
to
recheck
readyState
of
HAVE_NOTHING
"
kRequestAwaitNewDurationCheck
:
"
Buffering
media
and
then
sending
request
to
main
thread
to
await
duration
reaching
the
expected
value
due
to
buffering
"
kConfirmAwaitNewDurationResult
:
"
Checking
that
main
thread
correctly
ACK
'
ed
the
request
to
await
duration
reaching
the
expected
value
due
to
buffering
"
kRequestAtLeastHaveMetadataReadyStateCheck
:
"
Sending
request
to
main
thread
to
verify
expected
readyState
of
at
least
HAVE_METADATA
due
to
buffering
"
kConfirmAtLeastHaveMetadataReadyStateResult
:
"
Checking
that
main
thread
correctly
ACK
'
ed
the
request
to
verify
expected
readyState
of
at
least
HAVE_METADATA
due
to
buffering
"
}
;
let
phase
=
testPhase
.
kInitial
;
util
.
mediaSource
.
addEventListener
(
"
sourceopen
"
(
)
=
>
{
assert
(
phase
=
=
=
testPhase
.
kAttaching
"
Unexpected
sourceopen
received
by
Worker
mediaSource
.
"
)
;
phase
=
testPhase
.
kRequestNaNDurationCheck
;
processPhase
(
)
;
}
{
once
:
true
}
)
;
let
ackVerificationData
;
onmessage
=
e
=
>
{
if
(
e
.
data
=
=
=
undefined
|
|
e
.
data
.
subject
!
=
=
messageSubject
.
ACK_VERIFIED
|
|
e
.
data
.
info
=
=
=
undefined
)
{
postMessage
(
{
subject
:
messageSubject
.
ERROR
info
:
"
Invalid
message
received
by
Worker
"
}
)
;
return
;
}
ackVerificationData
=
e
.
data
.
info
;
processPhase
(
true
)
;
}
;
processPhase
(
)
;
function
checkAckVerificationData
(
expectedRequest
)
{
function
messageValuesEqual
(
m1
m2
)
{
if
(
m1
.
subject
!
=
=
m1
.
subject
)
{
if
(
m2
.
subject
=
=
=
m2
.
subject
)
return
false
;
}
else
if
(
m1
.
subject
!
=
=
m2
.
subject
)
{
return
false
;
}
if
(
m1
.
info
!
=
=
m1
.
info
)
{
return
(
m2
.
info
!
=
=
m2
.
info
)
;
}
return
m1
.
info
=
=
=
m2
.
info
;
}
if
(
messageValuesEqual
(
expectedRequest
ackVerificationData
)
)
{
ackVerificationData
=
undefined
;
return
true
;
}
postMessage
(
{
subject
:
messageSubject
.
ERROR
info
:
"
ACK_VERIFIED
message
from
main
thread
was
for
a
mismatching
request
for
this
phase
.
phase
=
[
"
+
phase
+
"
]
expected
request
that
would
produce
ACK
in
this
phase
=
[
"
+
JSON
.
stringify
(
expectedRequest
)
+
"
]
actual
request
reported
with
the
ACK
=
[
"
+
JSON
.
stringify
(
ackVerificationData
)
+
"
]
"
}
)
;
ackVerificationData
=
undefined
;
return
false
;
}
function
bufferMediaAndSendDurationVerificationRequest
(
)
{
sourceBuffer
=
util
.
mediaSource
.
addSourceBuffer
(
util
.
mediaMetadata
.
type
)
;
sourceBuffer
.
onerror
=
(
err
)
=
>
{
postMessage
(
{
subject
:
messageSubject
.
ERROR
info
:
err
}
)
;
}
;
sourceBuffer
.
onupdateend
=
(
)
=
>
{
var
duration
=
util
.
mediaSource
.
duration
;
if
(
isNaN
(
duration
)
|
|
duration
<
=
0
.
0
)
{
postMessage
(
{
subject
:
messageSubject
.
ERROR
info
:
"
mediaSource
.
duration
"
+
duration
+
"
is
not
within
expected
range
(
0
1
)
"
}
)
;
return
;
}
postMessage
(
getAwaitCurrentDurationRequest
(
)
)
;
}
;
util
.
mediaLoadPromise
.
then
(
mediaData
=
>
{
sourceBuffer
.
appendBuffer
(
mediaData
)
;
}
err
=
>
{
postMessage
(
{
subject
:
messageSubject
.
ERROR
info
:
err
}
)
}
)
;
}
function
getAwaitCurrentDurationRequest
(
)
{
const
dur
=
util
.
mediaSource
.
duration
;
assert
(
!
Number
.
isNaN
(
dur
)
"
Unexpected
NaN
duration
in
worker
"
)
;
return
{
subject
:
messageSubject
.
AWAIT_DURATION
info
:
dur
}
;
}
function
assert
(
conditionBool
description
)
{
if
(
conditionBool
!
=
=
true
)
{
postMessage
(
{
subject
:
messageSubject
.
ERROR
info
:
"
Current
test
phase
[
"
+
phase
+
"
]
failed
worker
assertion
.
"
+
description
}
)
;
}
}
function
processPhase
(
isResponseToAck
=
false
)
{
assert
(
!
isResponseToAck
|
|
(
phase
!
=
=
testPhase
.
kInitial
&
&
phase
!
=
=
testPhase
.
kAttaching
)
"
Phase
does
not
expect
verification
ack
receipt
from
main
thread
"
)
;
const
nanDurationCheckRequest
=
{
subject
:
messageSubject
.
VERIFY_DURATION
info
:
NaN
}
;
const
haveNothingReadyStateCheckRequest
=
{
subject
:
messageSubject
.
VERIFY_HAVE_NOTHING
}
;
const
setDurationCheckRequest
=
{
subject
:
messageSubject
.
AWAIT_DURATION
info
:
0
.
1
}
;
const
atLeastHaveMetadataReadyStateCheckRequest
=
{
subject
:
messageSubject
.
VERIFY_AT_LEAST_HAVE_METADATA
}
;
switch
(
phase
)
{
case
testPhase
.
kInitial
:
assert
(
Number
.
isNaN
(
util
.
mediaSource
.
duration
)
"
Initial
unattached
MediaSource
duration
must
be
NaN
but
instead
is
"
+
util
.
mediaSource
.
duration
)
;
phase
=
testPhase
.
kAttaching
;
let
handle
=
util
.
mediaSource
.
getHandle
(
)
;
postMessage
(
{
subject
:
messageSubject
.
HANDLE
info
:
handle
}
{
transfer
:
[
handle
]
}
)
;
break
;
case
testPhase
.
kAttaching
:
postMessage
(
{
subject
:
messageSubject
.
ERROR
info
:
"
kAttaching
phase
is
handled
by
main
thread
and
by
worker
onsourceopen
not
this
switch
case
.
"
}
)
;
break
;
case
testPhase
.
kRequestNaNDurationCheck
:
assert
(
!
isResponseToAck
)
;
postMessage
(
nanDurationCheckRequest
)
;
phase
=
testPhase
.
kConfirmNaNDurationResult
;
break
;
case
testPhase
.
kConfirmNaNDurationResult
:
assert
(
isResponseToAck
)
;
if
(
checkAckVerificationData
(
nanDurationCheckRequest
)
)
{
phase
=
testPhase
.
kRequestHaveNothingReadyStateCheck
;
processPhase
(
)
;
}
break
;
case
testPhase
.
kRequestHaveNothingReadyStateCheck
:
assert
(
!
isResponseToAck
)
;
postMessage
(
haveNothingReadyStateCheckRequest
)
;
phase
=
testPhase
.
kConfirmHaveNothingReadyStateResult
;
break
;
case
testPhase
.
kConfirmHaveNothingReadyStateResult
:
assert
(
isResponseToAck
)
;
if
(
checkAckVerificationData
(
haveNothingReadyStateCheckRequest
)
)
{
phase
=
testPhase
.
kRequestSetDurationCheck
;
processPhase
(
)
;
}
break
;
case
testPhase
.
kRequestSetDurationCheck
:
assert
(
!
isResponseToAck
)
;
const
newDuration
=
setDurationCheckRequest
.
info
;
assert
(
!
Number
.
isNaN
(
newDuration
)
&
&
newDuration
>
0
)
;
util
.
mediaSource
.
duration
=
newDuration
;
postMessage
(
setDurationCheckRequest
)
;
phase
=
testPhase
.
kConfirmSetDurationResult
;
break
;
case
testPhase
.
kConfirmSetDurationResult
:
assert
(
isResponseToAck
)
;
if
(
checkAckVerificationData
(
setDurationCheckRequest
)
)
{
phase
=
testPhase
.
kRequestHaveNothingReadyStateRecheck
;
processPhase
(
)
;
}
break
;
case
testPhase
.
kRequestHaveNothingReadyStateRecheck
:
assert
(
!
isResponseToAck
)
;
postMessage
(
haveNothingReadyStateCheckRequest
)
;
phase
=
testPhase
.
kConfirmHaveNothingReadyStateRecheckResult
;
break
;
case
testPhase
.
kConfirmHaveNothingReadyStateRecheckResult
:
assert
(
isResponseToAck
)
;
if
(
checkAckVerificationData
(
haveNothingReadyStateCheckRequest
)
)
{
phase
=
testPhase
.
kRequestAwaitNewDurationCheck
;
processPhase
(
)
;
}
break
;
case
testPhase
.
kRequestAwaitNewDurationCheck
:
assert
(
!
isResponseToAck
)
;
bufferMediaAndSendDurationVerificationRequest
(
)
;
phase
=
testPhase
.
kConfirmAwaitNewDurationResult
;
break
;
case
testPhase
.
kConfirmAwaitNewDurationResult
:
assert
(
isResponseToAck
)
;
if
(
checkAckVerificationData
(
getAwaitCurrentDurationRequest
(
)
)
)
{
phase
=
testPhase
.
kRequestAtLeastHaveMetadataReadyStateCheck
;
processPhase
(
)
;
}
break
;
case
testPhase
.
kRequestAtLeastHaveMetadataReadyStateCheck
:
assert
(
!
isResponseToAck
)
;
postMessage
(
atLeastHaveMetadataReadyStateCheckRequest
)
;
phase
=
testPhase
.
kConfirmAtLeastHaveMetadataReadyStateResult
;
break
;
case
testPhase
.
kConfirmAtLeastHaveMetadataReadyStateResult
:
assert
(
isResponseToAck
)
;
if
(
checkAckVerificationData
(
atLeastHaveMetadataReadyStateCheckRequest
)
)
{
postMessage
(
{
subject
:
messageSubject
.
WORKER_DONE
}
)
;
}
phase
=
"
No
further
phase
processing
should
occur
once
WORKER_DONE
message
has
been
sent
"
;
break
;
default
:
postMessage
(
{
subject
:
messageSubject
.
ERROR
info
:
"
Unexpected
test
phase
in
worker
:
"
+
phase
}
)
;
}
}
