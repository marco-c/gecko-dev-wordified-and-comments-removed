function
findSupportedChangeTypeTestTypes
(
cb
)
{
let
CHANGE_TYPE_MEDIA_LIST
=
[
{
type
:
'
video
/
webm
;
codecs
=
"
vp8
"
'
relaxed_type
:
'
video
/
webm
'
mime_subtype
:
'
webm
'
is_video
:
true
url
:
'
webm
/
test
-
v
-
128k
-
320x240
-
24fps
-
8kfr
.
webm
'
start_time
:
0
.
0
}
{
type
:
'
video
/
webm
;
codecs
=
"
vp9
"
'
relaxed_type
:
'
video
/
webm
'
mime_subtype
:
'
webm
'
is_video
:
true
url
:
'
webm
/
test
-
vp9
.
webm
'
start_time
:
0
.
0
}
{
type
:
'
video
/
mp4
;
codecs
=
"
avc1
.
4D4001
"
'
relaxed_type
:
'
video
/
mp4
'
mime_subtype
:
'
mp4
'
is_video
:
true
url
:
'
mp4
/
test
-
v
-
128k
-
320x240
-
24fps
-
8kfr
.
mp4
'
start_time
:
0
.
083333
keyframe_interval
:
0
.
333333
}
{
type
:
'
audio
/
webm
;
codecs
=
"
vorbis
"
'
relaxed_type
:
'
audio
/
webm
'
mime_subtype
:
'
webm
'
is_video
:
false
url
:
'
webm
/
test
-
a
-
128k
-
44100Hz
-
1ch
.
webm
'
start_time
:
0
.
0
}
{
type
:
'
audio
/
mp4
;
codecs
=
"
mp4a
.
40
.
2
"
'
relaxed_type
:
'
audio
/
mp4
'
mime_subtype
:
'
mp4
'
is_video
:
false
url
:
'
mp4
/
test
-
a
-
128k
-
44100Hz
-
1ch
.
mp4
'
start_time
:
0
.
0
}
{
type
:
'
audio
/
mpeg
'
relaxed_type
:
'
audio
/
mpeg
'
mime_subtype
:
'
mpeg
'
is_video
:
false
url
:
'
mp3
/
sound_5
.
mp3
'
start_time
:
0
.
0
}
]
;
let
audio_result
=
[
]
;
let
video_result
=
[
]
;
for
(
let
i
=
0
;
i
<
CHANGE_TYPE_MEDIA_LIST
.
length
;
+
+
i
)
{
let
media
=
CHANGE_TYPE_MEDIA_LIST
[
i
]
;
if
(
window
.
MediaSource
&
&
MediaSource
.
isTypeSupported
(
media
.
type
)
)
{
if
(
media
.
is_video
=
=
=
true
)
{
video_result
.
push
(
media
)
;
}
else
{
audio_result
.
push
(
media
)
;
}
}
}
cb
(
audio_result
video_result
)
;
}
function
appendBuffer
(
test
sourceBuffer
data
)
{
test
.
expectEvent
(
sourceBuffer
"
update
"
)
;
test
.
expectEvent
(
sourceBuffer
"
updateend
"
)
;
sourceBuffer
.
appendBuffer
(
data
)
;
}
function
trimBuffered
(
test
mediaElement
sourceBuffer
minimumPreviousDuration
newDuration
skip_duration_prechecks
)
{
if
(
!
skip_duration_prechecks
)
{
assert_less_than
(
newDuration
minimumPreviousDuration
)
;
assert_less_than
(
minimumPreviousDuration
mediaElement
.
duration
)
;
}
test
.
expectEvent
(
sourceBuffer
"
update
"
)
;
test
.
expectEvent
(
sourceBuffer
"
updateend
"
)
;
sourceBuffer
.
remove
(
newDuration
Infinity
)
;
}
function
trimDuration
(
test
mediaElement
mediaSource
newDuration
skip_duration_prechecks
)
{
if
(
!
skip_duration_prechecks
)
{
assert_less_than
(
newDuration
mediaElement
.
duration
)
;
}
test
.
expectEvent
(
mediaElement
"
durationchange
"
)
;
mediaSource
.
duration
=
newDuration
;
}
function
runChangeTypeTest
(
test
mediaElement
mediaSource
metadataA
typeA
dataA
metadataB
typeB
dataB
implicit_changetype
negative_test
)
{
function
findSafeOffset
(
targetTime
overlappedMediaMetadata
overlappedStartTime
overlappingMediaMetadata
)
{
assert_greater_than_equal
(
targetTime
overlappedStartTime
)
;
let
offset
=
targetTime
;
if
(
"
start_time
"
in
overlappingMediaMetadata
)
{
offset
-
=
overlappingMediaMetadata
[
"
start_time
"
]
;
}
if
(
!
(
"
keyframe_interval
"
in
overlappedMediaMetadata
)
)
{
return
{
"
offset
"
:
offset
"
adjustedTime
"
:
targetTime
}
;
}
let
gopsToRetain
=
Math
.
ceil
(
(
targetTime
-
overlappedStartTime
)
/
overlappedMediaMetadata
[
"
keyframe_interval
"
]
)
;
let
adjustedTime
=
overlappedStartTime
+
gopsToRetain
*
overlappedMediaMetadata
[
"
keyframe_interval
"
]
;
assert_greater_than_equal
(
adjustedTime
targetTime
)
;
offset
+
=
adjustedTime
-
targetTime
;
return
{
"
offset
"
:
offset
"
adjustedTime
"
:
adjustedTime
}
;
}
let
sourceBuffer
=
mediaSource
.
addSourceBuffer
(
typeA
)
;
if
(
negative_test
)
{
sourceBuffer
.
addEventListener
(
"
error
"
test
.
step_func_done
(
)
)
;
}
else
{
sourceBuffer
.
addEventListener
(
"
error
"
test
.
unreached_func
(
"
Unexpected
event
'
error
'
"
)
)
;
}
appendBuffer
(
test
sourceBuffer
dataA
)
;
let
lastStart
=
metadataA
[
"
start_time
"
]
;
if
(
lastStart
=
=
null
)
{
lastStart
=
0
.
0
;
}
test
.
waitForExpectedEvents
(
(
)
=
>
{
let
safeOffset
=
findSafeOffset
(
0
.
5
metadataA
lastStart
metadataB
)
;
lastStart
=
safeOffset
[
"
adjustedTime
"
]
;
if
(
!
implicit_changetype
)
{
try
{
sourceBuffer
.
changeType
(
typeB
)
;
}
catch
(
err
)
{
if
(
negative_test
)
test
.
done
(
)
;
else
throw
err
;
}
}
sourceBuffer
.
timestampOffset
=
safeOffset
[
"
offset
"
]
;
appendBuffer
(
test
sourceBuffer
dataB
)
;
}
)
;
test
.
waitForExpectedEvents
(
(
)
=
>
{
assert_less_than
(
lastStart
1
.
0
)
;
let
safeOffset
=
findSafeOffset
(
1
.
0
metadataB
lastStart
metadataB
)
;
lastStart
=
safeOffset
[
"
adjustedTime
"
]
;
if
(
!
implicit_changetype
)
{
try
{
sourceBuffer
.
changeType
(
typeB
)
;
}
catch
(
err
)
{
if
(
negative_test
)
test
.
done
(
)
;
else
throw
err
;
}
}
sourceBuffer
.
timestampOffset
=
safeOffset
[
"
offset
"
]
;
appendBuffer
(
test
sourceBuffer
dataB
)
;
}
)
;
test
.
waitForExpectedEvents
(
(
)
=
>
{
assert_less_than
(
lastStart
1
.
5
)
;
let
safeOffset
=
findSafeOffset
(
1
.
5
metadataB
lastStart
metadataA
)
;
if
(
!
implicit_changetype
)
{
try
{
sourceBuffer
.
changeType
(
typeA
)
;
}
catch
(
err
)
{
if
(
negative_test
)
test
.
done
(
)
;
else
throw
err
;
}
}
sourceBuffer
.
timestampOffset
=
safeOffset
[
"
offset
"
]
;
appendBuffer
(
test
sourceBuffer
dataA
)
;
}
)
;
test
.
waitForExpectedEvents
(
(
)
=
>
{
assert_less_than
(
lastStart
1
.
3
)
;
let
safeOffset
=
findSafeOffset
(
1
.
3
metadataB
lastStart
metadataA
)
;
if
(
!
implicit_changetype
)
{
try
{
sourceBuffer
.
changeType
(
typeA
)
;
}
catch
(
err
)
{
if
(
negative_test
)
test
.
done
(
)
;
else
throw
err
;
}
}
sourceBuffer
.
timestampOffset
=
safeOffset
[
"
offset
"
]
;
appendBuffer
(
test
sourceBuffer
dataA
)
;
}
)
;
test
.
waitForExpectedEvents
(
(
)
=
>
{
trimBuffered
(
test
mediaElement
sourceBuffer
2
.
1
2
negative_test
)
;
}
)
;
test
.
waitForExpectedEvents
(
(
)
=
>
{
trimDuration
(
test
mediaElement
mediaSource
2
negative_test
)
;
}
)
;
test
.
waitForExpectedEvents
(
(
)
=
>
{
assert_equals
(
mediaElement
.
currentTime
0
)
;
test
.
expectEvent
(
mediaSource
"
sourceended
"
)
;
test
.
expectEvent
(
mediaElement
"
play
"
)
;
test
.
expectEvent
(
mediaElement
"
ended
"
)
;
mediaSource
.
endOfStream
(
)
;
mediaElement
.
play
(
)
;
}
)
;
test
.
waitForExpectedEvents
(
(
)
=
>
{
if
(
negative_test
)
assert_unreached
(
"
Received
'
ended
'
while
negative
testing
.
"
)
;
else
test
.
done
(
)
;
}
)
;
}
function
mediaSourceChangeTypeTest
(
metadataA
metadataB
description
options
=
{
}
)
{
mediasource_test
(
(
test
mediaElement
mediaSource
)
=
>
{
let
typeA
=
metadataA
.
type
;
let
typeB
=
metadataB
.
type
;
if
(
options
.
hasOwnProperty
(
"
use_relaxed_mime_types
"
)
&
&
options
.
use_relaxed_mime_types
=
=
=
true
)
{
typeA
=
metadataA
.
relaxed_type
;
typeB
=
metadataB
.
relaxed_type
;
}
let
implicit_changetype
=
options
.
hasOwnProperty
(
"
implicit_changetype
"
)
&
&
options
.
implicit_changetype
=
=
=
true
;
let
negative_test
=
options
.
hasOwnProperty
(
"
negative_test
"
)
&
&
options
.
negative_test
=
=
=
true
;
mediaElement
.
pause
(
)
;
if
(
negative_test
)
{
mediaElement
.
addEventListener
(
"
error
"
test
.
step_func_done
(
)
)
;
}
else
{
mediaElement
.
addEventListener
(
"
error
"
test
.
unreached_func
(
"
Unexpected
event
'
error
'
"
)
)
;
}
MediaSourceUtil
.
loadBinaryData
(
test
metadataA
.
url
(
dataA
)
=
>
{
MediaSourceUtil
.
loadBinaryData
(
test
metadataB
.
url
(
dataB
)
=
>
{
runChangeTypeTest
(
test
mediaElement
mediaSource
metadataA
typeA
dataA
metadataB
typeB
dataB
implicit_changetype
negative_test
)
;
}
)
;
}
)
;
}
description
)
;
}
