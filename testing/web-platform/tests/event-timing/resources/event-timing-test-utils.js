function
mainThreadBusy
(
ms
)
{
const
target
=
performance
.
now
(
)
+
ms
;
while
(
performance
.
now
(
)
<
target
)
;
}
async
function
wait
(
)
{
return
new
Promise
(
resolve
=
>
step_timeout
(
resolve
0
)
)
;
}
async
function
raf
(
)
{
return
new
Promise
(
resolve
=
>
requestAnimationFrame
(
resolve
)
)
;
}
async
function
afterNextPaint
(
)
{
await
raf
(
)
;
await
wait
(
)
;
}
async
function
blockNextEventListener
(
target
eventType
duration
=
120
)
{
return
new
Promise
(
resolve
=
>
{
target
.
addEventListener
(
eventType
(
)
=
>
{
mainThreadBusy
(
duration
)
;
resolve
(
)
;
}
{
once
:
true
}
)
;
}
)
;
}
async
function
clickAndBlockMain
(
id
options
=
{
}
)
{
options
=
{
eventType
:
"
pointerdown
"
duration
:
120
.
.
.
options
}
;
const
element
=
document
.
getElementById
(
id
)
;
await
Promise
.
all
(
[
blockNextEventListener
(
element
options
.
eventType
options
.
duration
)
click
(
element
)
]
)
;
}
function
verifyEvent
(
entry
eventType
targetId
isFirst
=
false
minDuration
=
104
notCancelable
=
false
)
{
assert_equals
(
entry
.
cancelable
!
notCancelable
'
cancelable
property
'
)
;
assert_equals
(
entry
.
name
eventType
)
;
assert_equals
(
entry
.
entryType
'
event
'
)
;
assert_greater_than_equal
(
entry
.
duration
minDuration
"
The
entry
'
s
duration
should
be
greater
than
or
equal
to
"
+
minDuration
+
"
ms
.
"
)
;
assert_greater_than_equal
(
entry
.
processingStart
entry
.
startTime
"
The
entry
'
s
processingStart
should
be
greater
than
or
equal
to
startTime
.
"
)
;
assert_greater_than_equal
(
entry
.
processingEnd
entry
.
processingStart
"
The
entry
'
s
processingEnd
must
be
at
least
as
large
as
processingStart
.
"
)
;
assert_greater_than_equal
(
entry
.
duration
+
4
entry
.
processingEnd
-
entry
.
startTime
"
The
entry
'
s
duration
must
be
at
least
as
large
as
processingEnd
-
startTime
.
"
)
;
if
(
isFirst
)
{
let
firstInputs
=
performance
.
getEntriesByType
(
'
first
-
input
'
)
;
assert_equals
(
firstInputs
.
length
1
'
There
should
be
a
single
first
-
input
entry
'
)
;
let
firstInput
=
firstInputs
[
0
]
;
assert_equals
(
firstInput
.
name
entry
.
name
)
;
assert_equals
(
firstInput
.
entryType
'
first
-
input
'
)
;
assert_equals
(
firstInput
.
startTime
entry
.
startTime
)
;
assert_equals
(
firstInput
.
duration
entry
.
duration
)
;
assert_equals
(
firstInput
.
processingStart
entry
.
processingStart
)
;
assert_equals
(
firstInput
.
processingEnd
entry
.
processingEnd
)
;
assert_equals
(
firstInput
.
cancelable
entry
.
cancelable
)
;
}
if
(
targetId
)
assert_equals
(
entry
.
target
document
.
getElementById
(
targetId
)
)
;
}
function
verifyClickEvent
(
entry
targetId
isFirst
=
false
minDuration
=
104
event
=
'
pointerdown
'
)
{
verifyEvent
(
entry
event
targetId
isFirst
minDuration
)
;
}
async
function
testDuration
(
t
id
numEntries
dur
slowDur
)
{
assert_implements
(
window
.
PerformanceEventTiming
'
Event
Timing
is
not
supported
.
'
)
;
const
observerPromise
=
new
Promise
(
async
resolve
=
>
{
let
minDuration
=
Math
.
ceil
(
dur
/
8
)
*
8
;
minDuration
=
Math
.
max
(
minDuration
16
)
;
let
numEntriesReceived
=
0
;
new
PerformanceObserver
(
list
=
>
{
const
pointerDowns
=
list
.
getEntriesByName
(
'
pointerdown
'
)
;
pointerDowns
.
forEach
(
e
=
>
{
t
.
step
(
(
)
=
>
{
verifyClickEvent
(
e
id
false
minDuration
)
;
}
)
;
}
)
;
numEntriesReceived
+
=
pointerDowns
.
length
;
if
(
numEntriesReceived
=
=
=
numEntries
)
resolve
(
)
;
}
)
.
observe
(
{
type
:
"
event
"
durationThreshold
:
dur
}
)
;
}
)
;
const
clicksPromise
=
new
Promise
(
async
resolve
=
>
{
for
(
let
index
=
0
;
index
<
numEntries
;
index
+
+
)
{
await
clickAndBlockMain
(
id
{
duration
:
slowDur
}
)
;
}
resolve
(
)
;
}
)
;
return
Promise
.
all
(
[
observerPromise
clicksPromise
]
)
;
}
async
function
testDurationWithDurationThreshold
(
t
id
numEntries
durThreshold
processingDelay
)
{
assert_implements
(
window
.
PerformanceEventTiming
'
Event
Timing
is
not
supported
.
'
)
;
const
observerPromise
=
new
Promise
(
async
resolve
=
>
{
let
minDuration
=
Math
.
ceil
(
durThreshold
/
8
)
*
8
;
minDuration
=
Math
.
max
(
minDuration
16
)
;
new
PerformanceObserver
(
t
.
step_func
(
list
=
>
{
const
pointerDowns
=
list
.
getEntriesByName
(
'
pointerdown
'
)
;
pointerDowns
.
forEach
(
p
=
>
{
assert_greater_than_equal
(
p
.
duration
minDuration
"
The
entry
'
s
duration
should
be
greater
than
or
equal
to
"
+
minDuration
+
"
ms
.
"
)
;
}
)
;
resolve
(
)
;
}
)
)
.
observe
(
{
type
:
"
event
"
durationThreshold
:
durThreshold
}
)
;
}
)
;
for
(
let
index
=
0
;
index
<
numEntries
;
index
+
+
)
{
await
clickAndBlockMain
(
id
{
duration
:
processingDelay
}
)
;
}
await
clickAndBlockMain
(
id
{
duration
:
durThreshold
}
)
;
return
observerPromise
;
}
function
applyAction
(
eventType
target
)
{
const
actions
=
new
test_driver
.
Actions
(
)
;
if
(
eventType
=
=
=
'
auxclick
'
)
{
actions
.
pointerMove
(
0
0
{
origin
:
target
}
)
.
pointerDown
(
{
button
:
actions
.
ButtonType
.
MIDDLE
}
)
.
pointerUp
(
{
button
:
actions
.
ButtonType
.
MIDDLE
}
)
;
}
else
if
(
eventType
=
=
=
'
click
'
|
|
eventType
=
=
=
'
mousedown
'
|
|
eventType
=
=
=
'
mouseup
'
|
|
eventType
=
=
=
'
pointerdown
'
|
|
eventType
=
=
=
'
pointerup
'
|
|
eventType
=
=
=
'
touchstart
'
|
|
eventType
=
=
=
'
touchend
'
)
{
actions
.
pointerMove
(
0
0
{
origin
:
target
}
)
.
pointerDown
(
)
.
pointerUp
(
)
;
}
else
if
(
eventType
=
=
=
'
contextmenu
'
)
{
actions
.
pointerMove
(
0
0
{
origin
:
target
}
)
.
pointerDown
(
{
button
:
actions
.
ButtonType
.
RIGHT
}
)
.
pointerUp
(
{
button
:
actions
.
ButtonType
.
RIGHT
}
)
;
}
else
if
(
eventType
=
=
=
'
dblclick
'
)
{
actions
.
pointerMove
(
0
0
{
origin
:
target
}
)
.
pointerDown
(
)
.
pointerUp
(
)
.
pointerDown
(
)
.
pointerUp
(
)
.
pointerMove
(
0
0
)
.
pointerDown
(
)
}
else
if
(
eventType
=
=
=
'
mouseenter
'
|
|
eventType
=
=
=
'
mouseover
'
|
|
eventType
=
=
=
'
pointerenter
'
|
|
eventType
=
=
=
'
pointerover
'
)
{
actions
.
pointerMove
(
0
1
)
.
pointerMove
(
0
0
{
origin
:
target
}
)
;
}
else
if
(
eventType
=
=
=
'
mouseleave
'
|
|
eventType
=
=
=
'
mouseout
'
|
|
eventType
=
=
=
'
pointerleave
'
|
|
eventType
=
=
=
'
pointerout
'
)
{
actions
.
pointerMove
(
0
0
{
origin
:
target
}
)
.
pointerMove
(
0
0
)
;
}
else
if
(
eventType
=
=
=
'
keyup
'
|
|
eventType
=
=
=
'
keydown
'
)
{
const
key
=
'
k
'
;
return
test_driver
.
send_keys
(
target
key
)
;
}
else
{
assert_unreached
(
'
The
event
type
'
+
eventType
+
'
is
not
supported
.
'
)
;
}
return
actions
.
send
(
)
;
}
function
requiresListener
(
eventType
)
{
return
[
'
mouseenter
'
'
mouseleave
'
'
pointerdown
'
'
pointerenter
'
'
pointerleave
'
'
pointerout
'
'
pointerover
'
'
pointerup
'
'
keyup
'
'
keydown
'
]
.
includes
(
eventType
)
;
}
function
notCancelable
(
eventType
)
{
return
[
'
mouseenter
'
'
mouseleave
'
'
pointerenter
'
'
pointerleave
'
]
.
includes
(
eventType
)
;
}
function
testCounts
(
t
resolve
looseCount
eventType
expectedCount
)
{
const
counts
=
performance
.
eventCounts
.
get
(
eventType
)
;
if
(
counts
<
expectedCount
)
{
t
.
step_timeout
(
(
)
=
>
{
testCounts
(
t
resolve
looseCount
eventType
expectedCount
)
;
}
10
)
;
return
;
}
if
(
looseCount
)
{
assert_greater_than_equal
(
performance
.
eventCounts
.
get
(
eventType
)
expectedCount
Should
have
at
least
{
expectedCount
}
{
eventType
}
events
)
}
else
{
assert_equals
(
performance
.
eventCounts
.
get
(
eventType
)
expectedCount
Should
have
{
expectedCount
}
{
eventType
}
events
)
;
}
resolve
(
)
;
}
async
function
testEventType
(
t
eventType
looseCount
=
false
)
{
assert_implements
(
window
.
EventCounts
"
Event
Counts
isn
'
t
supported
"
)
;
const
target
=
document
.
getElementById
(
'
target
'
)
;
if
(
requiresListener
(
eventType
)
)
{
target
.
addEventListener
(
eventType
(
)
=
>
{
}
)
;
}
const
initialCount
=
performance
.
eventCounts
.
get
(
eventType
)
;
if
(
!
looseCount
)
{
assert_equals
(
initialCount
0
'
No
events
yet
.
'
)
;
}
await
applyAction
(
eventType
target
)
;
await
applyAction
(
eventType
target
)
;
await
afterNextPaint
(
)
;
await
new
Promise
(
t
.
step_func
(
resolve
=
>
{
testCounts
(
t
resolve
looseCount
eventType
initialCount
+
2
)
;
}
)
)
;
const
durationThreshold
=
16
;
target
.
addEventListener
(
eventType
(
)
=
>
{
mainThreadBusy
(
durationThreshold
+
4
)
;
}
)
;
const
observerPromise
=
new
Promise
(
async
resolve
=
>
{
new
PerformanceObserver
(
t
.
step_func
(
entryList
=
>
{
let
eventTypeEntries
=
entryList
.
getEntriesByName
(
eventType
)
;
if
(
eventTypeEntries
.
length
=
=
=
0
)
return
;
let
entry
=
null
;
if
(
!
looseCount
)
{
entry
=
eventTypeEntries
[
0
]
;
assert_equals
(
eventTypeEntries
.
length
1
)
;
}
else
{
eventTypeEntries
.
forEach
(
e
=
>
{
if
(
e
.
target
=
=
=
document
.
getElementById
(
'
target
'
)
)
entry
=
e
;
}
)
;
if
(
!
entry
)
return
;
}
verifyEvent
(
entry
eventType
'
target
'
false
durationThreshold
notCancelable
(
eventType
)
)
;
testCounts
(
t
resolve
looseCount
eventType
initialCount
+
3
)
;
}
)
)
.
observe
(
{
type
:
'
event
'
durationThreshold
:
durationThreshold
}
)
;
}
)
;
await
applyAction
(
eventType
target
)
;
await
afterNextPaint
(
)
;
await
observerPromise
;
}
function
addListeners
(
target
events
)
{
const
eventListener
=
(
e
)
=
>
{
mainThreadBusy
(
200
)
;
}
;
events
.
forEach
(
e
=
>
{
target
.
addEventListener
(
e
eventListener
)
;
}
)
;
}
async
function
tap
(
target
)
{
return
new
test_driver
.
Actions
(
)
.
addPointer
(
"
touchPointer
"
"
touch
"
)
.
pointerMove
(
0
0
{
origin
:
target
}
)
.
pointerDown
(
)
.
pointerUp
(
)
.
send
(
)
;
}
async
function
click
(
target
)
{
return
test_driver
.
click
(
target
)
;
}
async
function
auxClick
(
target
)
{
const
actions
=
new
test_driver
.
Actions
(
)
;
return
actions
.
addPointer
(
"
mousePointer
"
"
mouse
"
)
.
pointerMove
(
0
0
{
origin
:
target
}
)
.
pointerDown
(
{
button
:
actions
.
ButtonType
.
RIGHT
}
)
.
pointerUp
(
{
button
:
actions
.
ButtonType
.
RIGHT
}
)
.
send
(
)
;
}
async
function
pointerdown
(
target
)
{
const
actions
=
new
test_driver
.
Actions
(
)
;
return
actions
.
addPointer
(
"
mousePointer
"
"
mouse
"
)
.
pointerMove
(
0
0
{
origin
:
target
}
)
.
pointerDown
(
)
.
send
(
)
;
}
async
function
pointerup
(
target
)
{
const
actions
=
new
test_driver
.
Actions
(
)
;
return
actions
.
addPointer
(
"
mousePointer
"
"
mouse
"
)
.
pointerMove
(
0
0
{
origin
:
target
}
)
.
pointerUp
(
)
.
send
(
)
;
}
async
function
auxPointerdown
(
target
)
{
const
actions
=
new
test_driver
.
Actions
(
)
;
return
actions
.
addPointer
(
"
mousePointer
"
"
mouse
"
)
.
pointerMove
(
0
0
{
origin
:
target
}
)
.
pointerDown
(
{
button
:
actions
.
ButtonType
.
RIGHT
}
)
.
send
(
)
;
}
async
function
pressKey
(
target
key
)
{
await
test_driver
.
send_keys
(
target
key
)
;
}
async
function
addListenersAndPress
(
target
key
events
)
{
addListeners
(
target
events
)
;
return
pressKey
(
target
key
)
;
}
async
function
addListenersAndClick
(
target
)
{
addListeners
(
target
[
'
mousedown
'
'
mouseup
'
'
pointerdown
'
'
pointerup
'
'
click
'
]
)
;
return
click
(
target
)
;
}
function
filterAndAddToMap
(
events
map
)
{
return
function
(
entry
)
{
if
(
events
.
includes
(
entry
.
name
)
)
{
map
.
set
(
entry
.
name
entry
.
interactionId
)
;
return
true
;
}
return
false
;
}
}
async
function
createPerformanceObserverPromise
(
observeTypes
callback
readyToResolve
)
{
return
new
Promise
(
resolve
=
>
{
new
PerformanceObserver
(
entryList
=
>
{
callback
(
entryList
)
;
if
(
readyToResolve
(
)
)
{
resolve
(
)
;
}
}
)
.
observe
(
{
entryTypes
:
observeTypes
}
)
;
}
)
;
}
async
function
interactAndObserve
(
interactionType
target
observerPromise
key
=
'
'
)
{
let
interactionPromise
;
switch
(
interactionType
)
{
case
'
key
'
:
{
addListeners
(
target
[
'
keydown
'
'
keyup
'
]
)
;
interactionPromise
=
pressKey
(
target
key
)
;
}
case
'
tap
'
:
{
addListeners
(
target
[
'
pointerdown
'
'
pointerup
'
]
)
;
interactionPromise
=
tap
(
target
)
;
break
;
}
case
'
click
'
:
{
addListeners
(
target
[
'
mousedown
'
'
mouseup
'
'
pointerdown
'
'
pointerup
'
'
click
'
]
)
;
interactionPromise
=
click
(
target
)
;
break
;
}
case
'
auxclick
'
:
{
addListeners
(
target
[
'
mousedown
'
'
mouseup
'
'
pointerdown
'
'
pointerup
'
'
contextmenu
'
'
auxclick
'
]
)
;
interactionPromise
=
auxClick
(
target
)
;
break
;
}
case
'
aux
-
pointerdown
'
:
{
addListeners
(
target
[
'
mousedown
'
'
pointerdown
'
'
contextmenu
'
]
)
;
interactionPromise
=
auxPointerdown
(
target
)
;
break
;
}
case
'
aux
-
pointerdown
-
and
-
pointerdown
'
:
{
addListeners
(
target
[
'
mousedown
'
'
pointerdown
'
'
contextmenu
'
]
)
;
interactionPromise
=
Promise
.
all
(
[
auxPointerdown
(
target
)
pointerdown
(
target
)
]
)
;
break
;
}
case
'
orphan
-
pointerup
'
:
{
addListeners
(
target
[
'
pointerup
'
]
)
;
interactionPromise
=
pointerup
(
target
)
;
break
;
}
}
return
Promise
.
all
(
[
interactionPromise
observerPromise
]
)
;
}
async
function
interact
(
interactionType
element
key
=
'
'
)
{
switch
(
interactionType
)
{
case
'
click
'
:
{
return
click
(
element
)
;
}
case
'
tap
'
:
{
return
tap
(
element
)
;
}
case
'
key
'
:
{
return
test_driver
.
send_keys
(
element
key
)
;
}
}
}
async
function
verifyInteractionCount
(
t
expectedCount
)
{
await
t
.
step_wait
(
(
)
=
>
{
return
performance
.
interactionCount
>
=
expectedCount
;
}
'
interactionCount
did
not
increase
enough
'
10000
5
)
;
assert_equals
(
performance
.
interactionCount
expectedCount
'
interactionCount
increased
more
than
expected
'
)
;
}
function
interactionCount_test
(
interactionType
elements
key
=
'
'
)
{
return
promise_test
(
async
t
=
>
{
assert_implements
(
window
.
PerformanceEventTiming
'
Event
Timing
is
not
supported
'
)
;
assert_equals
(
performance
.
interactionCount
0
'
Initial
count
is
not
0
'
)
;
let
expectedCount
=
1
;
for
(
let
element
of
elements
)
{
await
interact
(
interactionType
element
key
)
;
await
verifyInteractionCount
(
t
expectedCount
+
+
)
;
}
}
EventTiming
:
verify
interactionCount
for
{
interactionType
}
interaction
)
;
}
