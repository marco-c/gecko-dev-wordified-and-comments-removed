function
getInitData
(
initDataType
)
{
if
(
initDataType
=
=
'
webm
'
)
{
return
new
Uint8Array
(
[
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
]
)
;
}
if
(
initDataType
=
=
'
cenc
'
)
{
return
new
Uint8Array
(
[
0x00
0x00
0x00
0x34
0x70
0x73
0x73
0x68
0x01
0x00
0x00
0x00
0x10
0x77
0xEF
0xEC
0xC0
0xB2
0x4D
0x02
0xAC
0xE3
0x3C
0x1E
0x52
0xE2
0xFB
0x4B
0x00
0x00
0x00
0x01
0x00
0x00
0x00
0x00
0x03
0xd2
0xfc
0x41
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
]
)
;
}
if
(
initDataType
=
=
'
keyids
'
)
{
var
keyId
=
new
Uint8Array
(
[
0x00
0x00
0x00
0x00
0x03
0xd2
0xfc
0x41
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
]
)
;
return
stringToUint8Array
(
createKeyIDs
(
keyId
)
)
;
}
throw
'
initDataType
'
+
initDataType
+
'
not
supported
.
'
;
}
function
stringToUint8Array
(
str
)
{
var
result
=
new
Uint8Array
(
str
.
length
)
;
for
(
var
i
=
0
;
i
<
str
.
length
;
i
+
+
)
{
result
[
i
]
=
str
.
charCodeAt
(
i
)
;
}
return
result
;
}
function
base64urlEncode
(
data
)
{
var
result
=
btoa
(
String
.
fromCharCode
.
apply
(
null
data
)
)
;
return
result
.
replace
(
/
=
+
/
g
'
'
)
.
replace
(
/
\
+
/
g
"
-
"
)
.
replace
(
/
\
/
/
g
"
_
"
)
;
}
function
base64urlDecode
(
encoded
)
{
return
atob
(
encoded
.
replace
(
/
\
-
/
g
"
+
"
)
.
replace
(
/
\
_
/
g
"
/
"
)
)
;
}
function
base64DecodeToUnit8Array
(
encoded
)
{
return
new
Uint8Array
(
atob
(
encoded
)
.
split
(
'
'
)
.
map
(
function
(
c
)
{
return
c
.
charCodeAt
(
0
)
;
}
)
)
;
}
function
createKeyIDs
(
)
{
var
keyIds
=
'
{
"
kids
"
:
[
"
'
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
if
(
i
!
=
0
)
keyIds
+
=
'
"
"
'
;
keyIds
+
=
base64urlEncode
(
arguments
[
i
]
)
;
}
keyIds
+
=
'
"
]
}
'
;
return
keyIds
;
}
function
getSupportedKeySystem
(
)
{
var
userAgent
=
navigator
.
userAgent
.
toLowerCase
(
)
;
var
keysystem
=
undefined
;
if
(
userAgent
.
indexOf
(
'
chrome
'
)
>
-
1
|
|
userAgent
.
indexOf
(
'
firefox
'
)
>
-
1
)
{
keysystem
=
'
com
.
widevine
.
alpha
'
;
}
else
if
(
(
userAgent
.
indexOf
(
'
edge
'
)
>
-
1
)
{
keysystem
=
'
com
.
microsoft
.
playready
'
;
}
return
keysystem
;
}
function
waitForEventAndRunStep
(
eventName
element
func
stepTest
)
{
var
eventCallback
=
function
(
event
)
{
if
(
func
)
func
(
event
)
;
}
element
.
addEventListener
(
eventName
stepTest
.
step_func
(
eventCallback
)
true
)
;
}
var
consoleDiv
=
null
;
function
consoleWrite
(
text
)
{
if
(
!
consoleDiv
&
&
document
.
body
)
{
consoleDiv
=
document
.
createElement
(
'
div
'
)
;
document
.
body
.
appendChild
(
consoleDiv
)
;
}
var
span
=
document
.
createElement
(
'
span
'
)
;
span
.
appendChild
(
document
.
createTextNode
(
text
)
)
;
span
.
appendChild
(
document
.
createElement
(
'
br
'
)
)
;
consoleDiv
.
appendChild
(
span
)
;
}
function
forceTestFailureFromPromise
(
test
error
message
)
{
if
(
message
)
consoleWrite
(
message
+
'
:
'
+
error
.
message
)
;
else
if
(
error
)
consoleWrite
(
error
)
;
test
.
force_timeout
(
)
;
test
.
done
(
)
;
}
function
getPossibleAudioCapabilities
(
)
{
return
[
{
contentType
:
'
audio
/
mp4
;
codecs
=
"
mp4a
.
40
.
2
"
'
}
{
contentType
:
'
audio
/
webm
;
codecs
=
"
opus
"
'
}
]
;
}
function
getSimpleConfiguration
(
)
{
return
[
{
initDataTypes
:
[
'
webm
'
'
cenc
'
'
keyids
'
]
audioCapabilities
:
getPossibleAudioCapabilities
(
)
}
]
;
}
function
getSimpleConfigurationForInitDataType
(
initDataType
)
{
return
[
{
initDataTypes
:
[
initDataType
]
audioCapabilities
:
getPossibleAudioCapabilities
(
)
}
]
;
}
function
isInitDataTypeSupported
(
keysystem
initDataType
)
{
return
navigator
.
requestMediaKeySystemAccess
(
keysystem
getSimpleConfigurationForInitDataType
(
initDataType
)
)
.
then
(
function
(
)
{
return
true
;
}
function
(
)
{
return
false
;
}
)
;
}
function
getSupportedInitDataTypes
(
keysystem
)
{
return
[
'
cenc
'
'
keyids
'
'
webm
'
]
.
filter
(
isInitDataTypeSupported
.
bind
(
null
keysystem
)
)
;
}
function
arrayBufferAsString
(
buffer
)
{
var
array
=
[
]
;
Array
.
prototype
.
push
.
apply
(
array
new
Uint8Array
(
buffer
)
)
;
return
'
0x
'
+
array
.
map
(
function
(
x
)
{
return
x
<
16
?
'
0
'
+
x
.
toString
(
16
)
:
x
.
toString
(
16
)
;
}
)
.
join
(
'
'
)
;
}
function
dumpKeyStatuses
(
keyStatuses
)
{
consoleWrite
(
"
for
(
var
entry
of
keyStatuses
)
"
)
;
for
(
var
entry
of
keyStatuses
)
{
consoleWrite
(
arrayBufferAsString
(
entry
[
0
]
)
+
"
:
"
+
entry
[
1
]
)
;
}
consoleWrite
(
"
for
(
var
keyId
of
keyStatuses
.
keys
(
)
)
"
)
;
for
(
var
keyId
of
keyStatuses
.
keys
(
)
)
{
consoleWrite
(
arrayBufferAsString
(
keyId
)
)
;
}
consoleWrite
(
"
for
(
var
status
of
keyStatuses
.
values
(
)
)
"
)
;
for
(
var
status
of
keyStatuses
.
values
(
)
)
{
consoleWrite
(
status
)
;
}
consoleWrite
(
"
for
(
var
entry
of
keyStatuses
.
entries
(
)
)
"
)
;
for
(
var
entry
of
keyStatuses
.
entries
(
)
)
{
consoleWrite
(
arrayBufferAsString
(
entry
[
0
]
)
+
"
:
"
+
entry
[
1
]
)
;
}
consoleWrite
(
"
keyStatuses
.
forEach
(
)
"
)
;
keyStatuses
.
forEach
(
function
(
status
keyId
)
{
consoleWrite
(
arrayBufferAsString
(
keyId
)
+
"
:
"
+
status
)
;
}
)
;
}
function
verifyKeyStatuses
(
keyStatuses
keys
)
{
var
expected
=
keys
.
expected
|
|
[
]
;
var
unexpected
=
keys
.
unexpected
|
|
[
]
;
assert_equals
(
keyStatuses
.
size
expected
.
length
)
;
expected
.
map
(
function
(
key
)
{
assert_true
(
keyStatuses
.
has
(
key
)
)
;
assert_equals
(
keyStatuses
.
get
(
key
)
'
usable
'
)
;
}
)
;
unexpected
.
map
(
function
(
key
)
{
assert_false
(
keyStatuses
.
has
(
key
)
)
;
assert_equals
(
keyStatuses
.
get
(
key
)
undefined
)
;
}
)
;
}
