function
runTest
(
config
)
{
var
debugEncryptedEventFired
=
false
;
var
debugWaitingForKeyEventFired
=
false
;
var
debugTimeUpdateEventCount
=
0
;
var
debugMessage
=
'
'
;
setup
(
{
explicit_timeout
:
true
}
)
;
promise_test
(
function
(
test
)
{
var
video
=
config
.
video
;
var
keysystem
=
config
.
keysystem
;
var
configuration
=
{
initDataTypes
:
[
config
.
initDataType
]
audioCapabilities
:
[
{
contentType
:
config
.
audioType
}
]
videoCapabilities
:
[
{
contentType
:
config
.
videoType
}
]
sessionTypes
:
[
'
temporary
'
]
}
;
var
initData
;
var
initDataType
;
var
mediaKeySession
;
var
keyId
=
new
Uint8Array
(
config
.
content
.
keys
[
0
]
.
kid
)
;
var
rawKey
=
new
Uint8Array
(
config
.
content
.
keys
[
0
]
.
key
)
;
var
handler
=
config
.
messageHandler
|
|
null
;
test
.
timeout
=
function
(
)
{
var
message
=
'
timeout
.
message
=
'
+
debugMessage
+
'
encrypted
:
'
+
debugEncryptedEventFired
+
'
waitingforkey
:
'
+
debugWaitingForKeyEventFired
+
'
timeupdate
count
:
'
+
debugTimeUpdateEventCount
;
this
.
timeout_id
=
null
;
this
.
set_status
(
this
.
TIMEOUT
message
)
;
this
.
phase
=
this
.
phases
.
HAS_RESULT
;
this
.
done
(
)
;
}
;
return
navigator
.
requestMediaKeySystemAccess
(
keysystem
[
configuration
]
)
.
then
(
function
(
access
)
{
debugMessage
=
'
createMediaKeys
(
)
'
;
return
access
.
createMediaKeys
(
)
;
}
)
.
then
(
function
(
mediaKeys
)
{
debugMessage
=
'
setMediaKeys
(
)
'
;
return
video
.
setMediaKeys
(
mediaKeys
)
;
}
)
.
then
(
function
(
)
{
return
testmediasource
(
config
)
;
}
)
.
then
(
function
(
source
)
{
debugMessage
=
'
wait_for_encrypted_event
(
)
'
;
mediaSource
=
source
;
video
.
src
=
URL
.
createObjectURL
(
mediaSource
)
;
video
.
play
(
)
;
return
wait_for_encrypted_event
(
video
)
;
}
)
.
then
(
function
(
e
)
{
initDataType
=
config
.
initData
?
config
.
initDataType
:
e
.
initDataType
;
initData
=
config
.
initData
|
|
e
.
initData
;
debugMessage
=
'
wait_for_waitingforkey_event
(
)
'
;
return
wait_for_waitingforkey_event
(
video
)
;
}
)
.
then
(
function
(
)
{
assert_false
(
video
.
paused
)
;
assert_less_than
(
video
.
currentTime
0
.
2
)
;
mediaKeySession
=
video
.
mediaKeys
.
createSession
(
'
temporary
'
)
;
debugMessage
=
'
generateRequest
(
)
'
;
return
mediaKeySession
.
generateRequest
(
initDataType
initData
)
;
}
)
.
then
(
function
(
)
{
return
wait_for_message_event
(
mediaKeySession
handler
)
;
}
)
.
then
(
function
(
)
{
debugMessage
=
'
wait_for_timeupdate_event
(
)
'
;
return
wait_for_timeupdate_event
(
video
)
;
}
)
.
catch
(
function
(
error
)
{
assert_unreached
(
'
Error
:
'
+
error
.
name
)
;
}
)
;
}
'
Waiting
for
a
key
.
'
{
timeout
:
20000
}
)
;
function
wait_for_encrypted_event
(
video
)
{
return
new
Promise
(
function
(
resolve
)
{
video
.
addEventListener
(
'
encrypted
'
function
listener
(
e
)
{
assert_equals
(
e
.
target
video
)
;
assert_true
(
e
instanceof
window
.
MediaEncryptedEvent
)
;
assert_equals
(
e
.
type
'
encrypted
'
)
;
debugEncryptedEventFired
=
true
;
video
.
removeEventListener
(
'
encrypted
'
listener
)
;
resolve
(
e
)
;
}
)
;
}
)
;
}
;
function
wait_for_waitingforkey_event
(
video
)
{
return
new
Promise
(
function
(
resolve
)
{
video
.
addEventListener
(
'
waitingforkey
'
function
listener
(
e
)
{
assert_equals
(
e
.
target
video
)
;
assert_equals
(
e
.
type
'
waitingforkey
'
)
;
debugWaitingForKeyEventFired
=
true
;
video
.
removeEventListener
(
'
waitingforkey
'
listener
)
;
resolve
(
e
)
;
}
)
;
}
)
;
}
;
function
wait_for_timeupdate_event
(
video
)
{
return
new
Promise
(
function
(
resolve
)
{
video
.
addEventListener
(
'
timeupdate
'
function
listener
(
e
)
{
assert_equals
(
e
.
target
video
)
;
+
+
debugTimeUpdateEventCount
;
if
(
video
.
currentTime
<
0
.
2
)
return
;
video
.
removeEventListener
(
'
timeupdate
'
listener
)
;
resolve
(
e
)
;
}
)
;
}
)
;
}
;
function
wait_for_message_event
(
mediaKeySession
handler
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
mediaKeySession
.
addEventListener
(
'
message
'
function
listener
(
e
)
{
assert_equals
(
e
.
target
mediaKeySession
)
;
assert_equals
(
e
.
type
'
message
'
)
;
video
.
removeEventListener
(
'
message
'
listener
)
;
return
handler
(
e
.
messageType
e
.
message
)
.
then
(
function
(
response
)
{
return
e
.
target
.
update
(
response
)
}
)
.
then
(
resolve
reject
)
;
}
)
;
}
)
;
}
}
