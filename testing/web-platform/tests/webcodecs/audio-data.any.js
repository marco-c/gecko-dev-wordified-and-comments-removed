var
defaultInit
=
{
timestamp
:
1234
channels
:
2
sampleRate
:
8000
frames
:
100
}
;
function
createDefaultAudioData
(
)
{
return
make_audio_data
(
defaultInit
.
timestamp
defaultInit
.
channels
defaultInit
.
sampleRate
defaultInit
.
frames
)
;
}
test
(
t
=
>
{
let
local_data
=
new
Float32Array
(
defaultInit
.
channels
*
defaultInit
.
frames
)
;
let
audio_data_init
=
{
timestamp
:
defaultInit
.
timestamp
data
:
local_data
numberOfFrames
:
defaultInit
.
frames
numberOfChannels
:
defaultInit
.
channels
sampleRate
:
defaultInit
.
sampleRate
format
:
'
f32
-
planar
'
}
let
data
=
new
AudioData
(
audio_data_init
)
;
assert_equals
(
data
.
timestamp
defaultInit
.
timestamp
'
timestamp
'
)
;
assert_equals
(
data
.
numberOfFrames
defaultInit
.
frames
'
frames
'
)
;
assert_equals
(
data
.
numberOfChannels
defaultInit
.
channels
'
channels
'
)
;
assert_equals
(
data
.
sampleRate
defaultInit
.
sampleRate
'
sampleRate
'
)
;
assert_equals
(
data
.
duration
defaultInit
.
frames
/
defaultInit
.
sampleRate
*
1_000_000
'
duration
'
)
;
assert_equals
(
data
.
format
'
f32
-
planar
'
'
format
'
)
;
let
small_data
=
new
Int16Array
(
defaultInit
.
channels
*
defaultInit
.
frames
)
;
let
wrong_format_init
=
{
.
.
.
audio_data_init
}
;
wrong_format_init
.
data
=
small_data
;
assert_throws_js
(
TypeError
(
)
=
>
{
let
data
=
new
AudioData
(
wrong_format_init
)
;
}
AudioDataInit
.
data
needs
to
be
big
enough
)
;
var
members
=
[
'
timestamp
'
'
data
'
'
numberOfFrames
'
'
numberOfChannels
'
'
sampleRate
'
'
format
'
]
;
for
(
const
member
of
members
)
{
let
incomplete_init
=
{
.
.
.
audio_data_init
}
;
delete
incomplete_init
[
member
]
;
assert_throws_js
(
TypeError
(
)
=
>
{
let
data
=
new
AudioData
(
incomplete_init
)
}
'
AudioData
requires
\
'
'
+
member
+
'
\
'
'
)
;
}
let
invalid_init
=
{
.
.
.
audio_data_init
}
;
invalid_init
.
numberOfFrames
=
0
assert_throws_js
(
TypeError
(
)
=
>
{
let
data
=
new
AudioData
(
invalid_init
)
}
'
AudioData
requires
numberOfFrames
>
0
'
)
;
invalid_init
=
{
.
.
.
audio_data_init
}
;
invalid_init
.
numberOfChannels
=
0
assert_throws_js
(
TypeError
(
)
=
>
{
let
data
=
new
AudioData
(
invalid_init
)
}
'
AudioData
requires
numberOfChannels
>
0
'
)
;
}
'
Verify
AudioData
constructors
'
)
;
test
(
t
=
>
{
let
data
=
createDefaultAudioData
(
)
;
let
clone
=
data
.
clone
(
)
;
assert_equals
(
data
.
timestamp
clone
.
timestamp
'
timestamp
'
)
;
assert_equals
(
data
.
numberOfFrames
clone
.
numberOfFrames
'
frames
'
)
;
assert_equals
(
data
.
numberOfChannels
clone
.
numberOfChannels
'
channels
'
)
;
assert_equals
(
data
.
sampleRate
clone
.
sampleRate
'
sampleRate
'
)
;
assert_equals
(
data
.
format
clone
.
format
'
format
'
)
;
const
data_copyDest
=
new
Float32Array
(
defaultInit
.
frames
)
;
const
clone_copyDest
=
new
Float32Array
(
defaultInit
.
frames
)
;
for
(
var
channel
=
0
;
channel
<
defaultInit
.
channels
;
channel
+
+
)
{
data
.
copyTo
(
data_copyDest
{
planeIndex
:
channel
}
)
;
clone
.
copyTo
(
clone_copyDest
{
planeIndex
:
channel
}
)
;
assert_array_equals
(
data_copyDest
clone_copyDest
'
Cloned
data
ch
=
'
+
channel
)
;
}
data
.
close
(
)
;
assert_equals
(
data
.
numberOfFrames
0
'
data
.
buffer
(
closed
)
'
)
;
assert_not_equals
(
clone
.
numberOfFrames
0
'
clone
.
buffer
(
not
closed
)
'
)
;
clone
.
close
(
)
;
assert_equals
(
clone
.
numberOfFrames
0
'
clone
.
buffer
(
closed
)
'
)
;
data
.
close
(
)
;
}
'
Verify
closing
and
cloning
AudioData
'
)
;
test
(
t
=
>
{
let
data
=
make_audio_data
(
-
10
defaultInit
.
channels
defaultInit
.
sampleRate
defaultInit
.
frames
)
;
assert_equals
(
data
.
timestamp
-
10
'
timestamp
'
)
;
data
.
close
(
)
;
}
'
Test
we
can
construct
AudioData
with
a
negative
timestamp
.
'
)
;
test
(
t
=
>
{
var
data
=
new
Float32Array
(
[
0
]
)
;
let
audio_data_init
=
{
timestamp
:
0
data
:
data
numberOfFrames
:
1
numberOfChannels
:
1
sampleRate
:
44100
format
:
'
f32
'
}
;
let
audioData
=
new
AudioData
(
audio_data_init
)
;
assert_not_equals
(
data
.
length
0
"
Input
data
is
copied
when
constructing
an
AudioData
"
)
;
}
'
Test
input
array
is
copied
on
construction
'
)
;
test
(
t
=
>
{
let
audio_data_init
=
{
timestamp
:
0
data
:
new
Float32Array
(
[
1
2
3
4
5
6
7
8
]
)
numberOfFrames
:
4
numberOfChannels
:
2
sampleRate
:
44100
format
:
'
f32
'
}
;
let
audioData
=
new
AudioData
(
audio_data_init
)
;
let
dest
=
new
Float32Array
(
8
)
;
assert_throws_js
(
RangeError
(
)
=
>
audioData
.
copyTo
(
dest
{
planeIndex
:
1
}
)
'
copyTo
from
interleaved
data
with
non
-
zero
planeIndex
throws
'
)
;
audioData
.
close
(
)
;
}
'
Test
that
copyTo
throws
if
copying
from
interleaved
with
a
non
-
zero
planeIndex
'
)
;
const
MIN
=
0
;
const
MAX
=
1
;
const
HALF
=
2
;
const
NEGATIVE_HALF
=
3
;
const
BIAS
=
4
;
const
DISCRETE_STEPS
=
5
;
function
pow2
(
p
)
{
return
2
*
*
p
;
}
let
r
=
Math
.
floor
.
bind
(
this
)
;
const
TEST_VALUES
=
{
u8
:
[
0
255
191
64
128
256
]
s16
:
[
-
pow2
(
15
)
pow2
(
15
)
-
1
r
(
(
pow2
(
15
)
-
1
)
/
2
)
r
(
-
pow2
(
15
)
/
2
)
0
pow2
(
16
)
]
s32
:
[
-
pow2
(
31
)
pow2
(
31
)
-
1
r
(
(
pow2
(
31
)
-
1
)
/
2
)
r
(
-
pow2
(
31
)
/
2
)
0
pow2
(
32
)
]
f32
:
[
-
1
.
0
1
.
0
0
.
5
-
0
.
5
0
pow2
(
24
)
]
}
;
const
TEST_TEMPLATE
=
{
channels
:
2
frames
:
5
testInput
:
[
MIN
BIAS
MAX
MIN
HALF
NEGATIVE_HALF
BIAS
MAX
BIAS
BIAS
]
testInterleavedResult
:
[
MIN
NEGATIVE_HALF
BIAS
BIAS
MAX
MAX
MIN
BIAS
HALF
BIAS
]
testVectorInterleavedResult
:
[
[
MIN
MAX
HALF
BIAS
BIAS
]
[
BIAS
MIN
NEGATIVE_HALF
MAX
BIAS
]
]
testVectorPlanarResult
:
[
[
MIN
BIAS
MAX
MIN
HALF
]
[
NEGATIVE_HALF
BIAS
MAX
BIAS
BIAS
]
]
}
;
function
isInteger
(
type
)
{
switch
(
type
)
{
case
"
u8
"
:
case
"
s16
"
:
case
"
s32
"
:
return
true
;
case
"
f32
"
:
return
false
;
default
:
throw
"
invalid
type
"
;
}
}
function
epsilon
(
expectedDestValue
sourceType
destType
)
{
if
(
sourceType
=
=
destType
)
{
return
0
.
0
;
}
if
(
expectedDestValue
=
=
TEST_VALUES
[
destType
]
[
MAX
]
)
{
if
(
sourceType
=
=
"
u8
"
&
&
destType
=
=
"
s16
"
)
{
return
expectedDestValue
-
32511
;
}
else
if
(
sourceType
=
=
"
u8
"
&
&
destType
=
=
"
s32
"
)
{
return
expectedDestValue
-
2130706432
;
}
else
if
(
sourceType
=
=
"
s16
"
&
&
destType
=
=
"
s32
"
)
{
return
expectedDestValue
-
2147418112
;
}
}
if
(
isInteger
(
sourceType
)
&
&
isInteger
(
destType
)
)
{
if
(
expectedDestValue
=
=
TEST_VALUES
[
destType
]
[
MIN
]
|
|
expectedDestValue
=
=
TEST_VALUES
[
destType
]
[
BIAS
]
)
{
return
0
.
0
;
}
}
if
(
!
isInteger
(
sourceType
)
&
&
isInteger
(
destType
)
&
&
destType
!
=
"
s32
"
)
{
return
1
.
0
;
}
var
sourceResolution
=
TEST_VALUES
[
sourceType
]
[
DISCRETE_STEPS
]
;
var
destResolution
=
TEST_VALUES
[
destType
]
[
DISCRETE_STEPS
]
;
if
(
sourceResolution
>
destResolution
)
{
return
0
.
0
;
}
else
{
return
destResolution
/
sourceResolution
;
}
}
function
get_type_values
(
type
)
{
let
cloned
=
structuredClone
(
TEST_TEMPLATE
)
;
cloned
.
testInput
=
Array
.
from
(
cloned
.
testInput
idx
=
>
TEST_VALUES
[
type
]
[
idx
]
)
;
cloned
.
testInterleavedResult
=
Array
.
from
(
cloned
.
testInterleavedResult
idx
=
>
TEST_VALUES
[
type
]
[
idx
]
)
;
cloned
.
testVectorInterleavedResult
=
Array
.
from
(
cloned
.
testVectorInterleavedResult
c
=
>
{
return
Array
.
from
(
c
idx
=
>
{
return
TEST_VALUES
[
type
]
[
idx
]
;
}
)
;
}
)
;
cloned
.
testVectorPlanarResult
=
Array
.
from
(
cloned
.
testVectorPlanarResult
c
=
>
{
return
Array
.
from
(
c
idx
=
>
{
return
TEST_VALUES
[
type
]
[
idx
]
;
}
)
;
}
)
;
return
cloned
;
}
function
typeToArrayType
(
type
)
{
switch
(
type
)
{
case
"
u8
"
:
return
Uint8Array
;
case
"
s16
"
:
return
Int16Array
;
case
"
s32
"
:
return
Int32Array
;
case
"
f32
"
:
return
Float32Array
;
default
:
throw
"
Unexpected
"
;
}
}
function
arrayTypeToType
(
array
)
{
switch
(
array
.
constructor
)
{
case
Uint8Array
:
return
"
u8
"
;
case
Int16Array
:
return
"
s16
"
;
case
Int32Array
:
return
"
s32
"
;
case
Float32Array
:
return
"
f32
"
;
default
:
throw
"
Unexpected
"
;
}
}
function
check_array_equality
(
values
expected
sourceType
message
assert_func
)
{
if
(
values
.
length
!
=
expected
.
length
)
{
throw
"
Array
not
of
the
same
length
"
;
}
for
(
var
i
=
0
;
i
<
values
.
length
;
i
+
+
)
{
var
eps
=
epsilon
(
expected
[
i
]
sourceType
arrayTypeToType
(
values
)
)
;
assert_func
(
Math
.
abs
(
expected
[
i
]
-
values
[
i
]
)
<
=
eps
Got
{
values
[
i
]
}
but
expected
result
{
expected
[
i
]
}
at
index
{
i
}
when
converting
from
{
sourceType
}
to
{
arrayTypeToType
(
values
)
}
epsilon
{
eps
}
)
;
}
assert_func
(
true
{
values
}
is
equal
to
{
expected
}
when
converting
from
{
sourceType
}
to
{
arrayTypeToType
(
values
)
}
)
;
}
function
conversionTest
(
sourceType
destinationType
)
{
test
(
function
(
t
)
{
var
test
=
get_type_values
(
sourceType
)
;
var
result
=
get_type_values
(
destinationType
)
;
var
sourceArrayCtor
=
typeToArrayType
(
sourceType
)
;
var
destArrayCtor
=
typeToArrayType
(
destinationType
)
;
let
data
=
new
AudioData
(
{
timestamp
:
defaultInit
.
timestamp
data
:
new
sourceArrayCtor
(
test
.
testInput
)
numberOfFrames
:
test
.
frames
numberOfChannels
:
test
.
channels
sampleRate
:
defaultInit
.
sampleRate
format
:
sourceType
}
)
;
var
assert_func
=
destinationType
=
=
"
f32
"
?
assert_true
:
assert_implements_optional
;
let
dest
=
new
destArrayCtor
(
data
.
numberOfFrames
)
;
data
.
copyTo
(
dest
{
planeIndex
:
0
format
:
destinationType
+
"
-
planar
"
}
)
;
check_array_equality
(
dest
result
.
testVectorInterleavedResult
[
0
]
sourceType
"
interleaved
channel
0
"
assert_func
)
;
data
.
copyTo
(
dest
{
planeIndex
:
1
format
:
destinationType
+
"
-
planar
"
}
)
;
check_array_equality
(
dest
result
.
testVectorInterleavedResult
[
1
]
sourceType
"
interleaved
channel
0
"
assert_func
)
;
let
destInterleaved
=
new
destArrayCtor
(
data
.
numberOfFrames
*
data
.
numberOfChannels
)
;
data
.
copyTo
(
destInterleaved
{
planeIndex
:
0
format
:
destinationType
}
)
;
check_array_equality
(
destInterleaved
result
.
testInput
sourceType
"
copyTo
from
interleaved
to
interleaved
(
conversion
only
)
"
assert_implements_optional
)
;
data
=
new
AudioData
(
{
timestamp
:
defaultInit
.
timestamp
data
:
new
sourceArrayCtor
(
test
.
testInput
)
numberOfFrames
:
test
.
frames
numberOfChannels
:
test
.
channels
sampleRate
:
defaultInit
.
sampleRate
format
:
sourceType
+
"
-
planar
"
}
)
;
data
.
copyTo
(
dest
{
planeIndex
:
0
format
:
destinationType
+
"
-
planar
"
}
)
;
check_array_equality
(
dest
result
.
testVectorPlanarResult
[
0
]
sourceType
"
planar
channel
0
"
assert_func
)
;
data
.
copyTo
(
dest
{
planeIndex
:
1
format
:
destinationType
+
"
-
planar
"
}
)
;
check_array_equality
(
dest
result
.
testVectorPlanarResult
[
1
]
sourceType
"
planar
channel
1
"
assert_func
)
;
data
.
copyTo
(
destInterleaved
{
planeIndex
:
0
format
:
destinationType
}
)
;
check_array_equality
(
destInterleaved
result
.
testInterleavedResult
sourceType
"
planar
to
interleaved
"
assert_func
)
;
}
Test
conversion
of
{
sourceType
}
to
{
destinationType
}
)
;
}
const
TYPES
=
[
"
u8
"
"
s16
"
"
s32
"
"
f32
"
]
;
TYPES
.
forEach
(
sourceType
=
>
{
TYPES
.
forEach
(
destinationType
=
>
{
conversionTest
(
sourceType
destinationType
)
;
}
)
;
}
)
;
