function
make_audio_frame
(
timestamp
channels
sampleRate
length
)
{
let
buffer
=
new
AudioBuffer
(
{
length
:
length
numberOfChannels
:
channels
sampleRate
:
sampleRate
}
)
;
for
(
var
channel
=
0
;
channel
<
buffer
.
numberOfChannels
;
channel
+
+
)
{
var
array
=
buffer
.
getChannelData
(
channel
)
;
let
hz
=
100
+
channel
*
50
;
for
(
var
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
let
t
=
(
i
/
sampleRate
)
*
hz
*
(
Math
.
PI
*
2
)
;
array
[
i
]
=
Math
.
sin
(
t
)
;
}
}
return
new
AudioFrame
(
{
timestamp
:
timestamp
buffer
:
buffer
}
)
;
}
function
makeOffscreenCanvas
(
width
height
)
{
let
canvas
=
new
OffscreenCanvas
(
width
height
)
;
let
ctx
=
canvas
.
getContext
(
'
2d
'
)
;
ctx
.
fillStyle
=
'
rgba
(
50
100
150
255
)
'
;
ctx
.
fillRect
(
0
0
width
height
)
;
return
canvas
;
}
function
makeImageBitmap
(
width
height
)
{
return
makeOffscreenCanvas
(
width
height
)
.
transferToImageBitmap
(
)
;
}
function
endAfterEventLoopTurn
(
)
{
return
new
Promise
(
resolve
=
>
step_timeout
(
resolve
0
)
)
;
}
function
getDefaultCodecInit
(
test
)
{
return
{
output
:
test
.
unreached_func
(
"
unexpected
output
"
)
error
:
test
.
unreached_func
(
"
unexpected
error
"
)
}
}
function
testConfigurations
(
codec
validCondig
invalidCodecs
)
{
assert_equals
(
codec
.
state
"
unconfigured
"
)
;
const
requiredConfigPairs
=
validCondig
;
let
incrementalConfig
=
{
}
;
for
(
let
key
in
requiredConfigPairs
)
{
assert_throws_js
(
TypeError
(
)
=
>
{
codec
.
configure
(
incrementalConfig
)
;
}
)
;
incrementalConfig
[
key
]
=
requiredConfigPairs
[
key
]
;
assert_equals
(
codec
.
state
"
unconfigured
"
)
;
}
codec
.
configure
(
incrementalConfig
)
;
assert_equals
(
codec
.
state
"
configured
"
)
;
codec
.
configure
(
incrementalConfig
)
;
assert_equals
(
codec
.
state
"
configured
"
)
;
let
config
=
incrementalConfig
;
invalidCodecs
.
forEach
(
badCodec
=
>
{
config
.
codec
=
badCodec
;
assert_throws_js
(
TypeError
(
)
=
>
{
codec
.
configure
(
config
)
;
}
badCodec
)
;
}
)
assert_equals
(
codec
.
state
"
configured
"
)
;
codec
.
reset
(
)
assert_equals
(
codec
.
state
"
unconfigured
"
)
;
codec
.
configure
(
validCondig
)
;
assert_equals
(
codec
.
state
"
configured
"
)
;
}
function
encodeOrDecodeShouldThrow
(
codec
input
)
{
assert_not_equals
(
codec
.
state
"
configured
"
)
;
if
(
codec
.
decode
)
{
assert_throws_dom
(
"
InvalidStateError
"
(
)
=
>
codec
.
decode
(
input
)
"
decode
"
)
;
}
else
if
(
codec
.
encode
)
{
assert_throws_dom
(
"
InvalidStateError
"
(
)
=
>
codec
.
encode
(
input
.
clone
(
)
)
"
encode
"
)
;
}
else
{
assert_unreached
(
"
Codec
should
have
encode
or
decode
function
"
)
;
}
}
function
testClosedCodec
(
test
codec
validconfig
codecInput
)
{
assert_equals
(
codec
.
state
"
unconfigured
"
)
;
codec
.
close
(
)
;
assert_equals
(
codec
.
state
"
closed
"
)
;
assert_throws_dom
(
"
InvalidStateError
"
(
)
=
>
codec
.
configure
(
validconfig
)
"
configure
"
)
;
assert_throws_dom
(
"
InvalidStateError
"
(
)
=
>
codec
.
reset
(
)
"
reset
"
)
;
assert_throws_dom
(
"
InvalidStateError
"
(
)
=
>
codec
.
close
(
)
"
close
"
)
;
encodeOrDecodeShouldThrow
(
codec
codecInput
)
;
return
promise_rejects_dom
(
test
'
InvalidStateError
'
codec
.
flush
(
)
'
flush
'
)
;
}
function
testUnconfiguredCodec
(
test
codec
codecInput
)
{
assert_equals
(
codec
.
state
"
unconfigured
"
)
;
codec
.
reset
(
)
;
assert_equals
(
codec
.
state
"
unconfigured
"
)
;
encodeOrDecodeShouldThrow
(
codec
codecInput
)
;
return
promise_rejects_dom
(
test
'
InvalidStateError
'
codec
.
flush
(
)
'
flush
'
)
;
}
function
verifyPlane
(
expected
actual
)
{
assert_less_than_equal
(
expected
.
stride
actual
.
stride
'
plane
strides
'
)
;
assert_equals
(
expected
.
rows
actual
.
rows
'
plane
rows
'
)
;
assert_less_than_equal
(
expected
.
stride
*
expected
.
rows
actual
.
length
'
plane
size
'
)
;
var
testBuffer
=
new
Uint8Array
(
actual
.
length
)
;
actual
.
readInto
(
testBuffer
)
;
for
(
var
h
=
0
;
h
<
actual
.
rows
;
+
+
h
)
{
assert_array_equals
(
expected
.
src
.
slice
(
h
*
expected
.
stride
expected
.
stride
)
testBuffer
.
slice
(
h
*
actual
.
stride
expected
.
stride
)
'
plane
data
'
)
;
}
}
const
kSRGBPixel
=
[
50
100
150
255
]
;
const
kP3Pixel
=
[
62
99
146
255
]
;
const
kRec2020Pixel
=
[
87
106
151
255
]
;
const
kCanvasOptionsP3Uint8
=
{
colorSpace
:
'
display
-
p3
'
pixelFormat
:
'
uint8
'
}
;
const
kImageSettingOptionsP3Uint8
=
{
colorSpace
:
'
display
-
p3
'
storageFormat
:
'
uint8
'
}
;
const
kCanvasOptionsRec2020Uint8
=
{
colorSpace
:
'
rec2020
'
pixelFormat
:
'
uint8
'
}
;
const
kImageSettingOptionsRec2020Uint8
=
{
colorSpace
:
'
rec2020
'
storageFormat
:
'
uint8
'
}
;
function
testCanvas
(
ctx
width
height
expected_pixel
imageSetting
assert_compares
)
{
let
imageData
=
ctx
.
getImageData
(
0
0
width
height
imageSetting
)
;
let
colorData
=
ctx
.
getImageData
(
0
0
width
height
imageSetting
)
.
data
;
const
kMaxPixelToCheck
=
128
*
96
;
let
step
=
width
*
height
/
kMaxPixelToCheck
;
step
=
Math
.
round
(
step
)
;
step
=
(
step
<
1
)
?
1
:
step
;
for
(
let
i
=
0
;
i
<
4
*
width
*
height
;
i
+
=
(
4
*
step
)
)
{
assert_compares
(
colorData
[
i
]
expected_pixel
[
0
]
)
;
assert_compares
(
colorData
[
i
+
1
]
expected_pixel
[
1
]
)
;
assert_compares
(
colorData
[
i
+
2
]
expected_pixel
[
2
]
)
;
assert_compares
(
colorData
[
i
+
3
]
expected_pixel
[
3
]
)
;
}
}
