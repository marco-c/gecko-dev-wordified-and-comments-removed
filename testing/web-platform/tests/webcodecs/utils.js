function
makeImageBitmap
(
width
height
)
{
let
canvas
=
new
OffscreenCanvas
(
width
height
)
;
let
ctx
=
canvas
.
getContext
(
'
2d
'
)
;
ctx
.
fillStyle
=
'
rgba
(
50
100
150
255
)
'
;
ctx
.
fillRect
(
0
0
width
height
)
;
return
canvas
.
transferToImageBitmap
(
)
;
}
function
endAfterEventLoopTurn
(
)
{
return
new
Promise
(
resolve
=
>
step_timeout
(
resolve
0
)
)
;
}
function
getDefaultCodecInit
(
test
)
{
return
{
output
:
test
.
unreached_func
(
"
unexpected
output
"
)
error
:
test
.
unreached_func
(
"
unexpected
error
"
)
}
}
function
testConfigurations
(
codec
validCondig
invalidCodecs
)
{
assert_equals
(
codec
.
state
"
unconfigured
"
)
;
const
requiredConfigPairs
=
validCondig
;
let
incrementalConfig
=
{
}
;
for
(
let
key
in
requiredConfigPairs
)
{
assert_throws_js
(
TypeError
(
)
=
>
{
codec
.
configure
(
incrementalConfig
)
;
}
)
;
incrementalConfig
[
key
]
=
requiredConfigPairs
[
key
]
;
assert_equals
(
codec
.
state
"
unconfigured
"
)
;
}
codec
.
configure
(
incrementalConfig
)
;
assert_equals
(
codec
.
state
"
configured
"
)
;
codec
.
configure
(
incrementalConfig
)
;
assert_equals
(
codec
.
state
"
configured
"
)
;
let
config
=
incrementalConfig
;
invalidCodecs
.
forEach
(
badCodec
=
>
{
config
.
codec
=
badCodec
;
assert_throws_js
(
TypeError
(
)
=
>
{
codec
.
configure
(
config
)
;
}
badCodec
)
;
}
)
assert_equals
(
codec
.
state
"
configured
"
)
;
codec
.
reset
(
)
assert_equals
(
codec
.
state
"
unconfigured
"
)
;
codec
.
configure
(
validCondig
)
;
assert_equals
(
codec
.
state
"
configured
"
)
;
}
function
encodeOrDecodeShouldThrow
(
codec
input
)
{
assert_not_equals
(
codec
.
state
"
configured
"
)
;
if
(
codec
.
decode
)
{
assert_throws_dom
(
"
InvalidStateError
"
(
)
=
>
codec
.
decode
(
input
)
"
decode
"
)
;
}
else
if
(
codec
.
encode
)
{
assert_throws_dom
(
"
InvalidStateError
"
(
)
=
>
codec
.
encode
(
input
.
clone
(
)
)
"
encode
"
)
;
}
else
{
assert_unreached
(
"
Codec
should
have
encode
or
decode
function
"
)
;
}
}
function
testClosedCodec
(
test
codec
validconfig
codecInput
)
{
assert_equals
(
codec
.
state
"
unconfigured
"
)
;
codec
.
close
(
)
;
assert_equals
(
codec
.
state
"
closed
"
)
;
assert_throws_dom
(
"
InvalidStateError
"
(
)
=
>
codec
.
configure
(
validconfig
)
"
configure
"
)
;
assert_throws_dom
(
"
InvalidStateError
"
(
)
=
>
codec
.
reset
(
)
"
reset
"
)
;
assert_throws_dom
(
"
InvalidStateError
"
(
)
=
>
codec
.
close
(
)
"
close
"
)
;
encodeOrDecodeShouldThrow
(
codec
codecInput
)
;
return
promise_rejects_dom
(
test
'
InvalidStateError
'
codec
.
flush
(
)
'
flush
'
)
;
}
function
testUnconfiguredCodec
(
test
codec
codecInput
)
{
assert_equals
(
codec
.
state
"
unconfigured
"
)
;
codec
.
reset
(
)
;
assert_equals
(
codec
.
state
"
unconfigured
"
)
;
encodeOrDecodeShouldThrow
(
codec
codecInput
)
;
return
promise_rejects_dom
(
test
'
InvalidStateError
'
codec
.
flush
(
)
'
flush
'
)
;
}
