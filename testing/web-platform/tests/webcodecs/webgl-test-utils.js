WebGLTestUtils
=
(
function
(
)
{
var
glEnumToString
=
function
(
gl
value
)
{
for
(
var
p
in
gl
)
{
if
(
gl
[
p
]
=
=
value
)
{
return
p
;
}
}
return
'
0x
'
+
value
.
toString
(
16
)
;
}
;
var
lastError
=
'
'
;
var
getLastError
=
function
(
)
{
return
lastError
;
}
;
var
simpleTextureVertexShader
=
[
'
attribute
vec4
vPosition
;
'
'
attribute
vec2
texCoord0
;
'
'
varying
vec2
texCoord
;
'
'
void
main
(
)
{
'
'
gl_Position
=
vPosition
;
'
'
texCoord
=
texCoord0
;
'
'
}
'
]
.
join
(
'
\
n
'
)
;
var
simpleTextureFragmentShader
=
[
'
precision
mediump
float
;
'
'
uniform
sampler2D
tex
;
'
'
varying
vec2
texCoord
;
'
'
void
main
(
)
{
'
'
gl_FragData
[
0
]
=
texture2D
(
tex
texCoord
)
;
'
'
}
'
]
.
join
(
'
\
n
'
)
;
var
setupSimpleTextureVertexShader
=
function
(
gl
)
{
return
loadShader
(
gl
simpleTextureVertexShader
gl
.
VERTEX_SHADER
)
;
}
;
var
setupSimpleTextureFragmentShader
=
function
(
gl
)
{
return
loadShader
(
gl
simpleTextureFragmentShader
gl
.
FRAGMENT_SHADER
)
;
}
;
var
setupProgram
=
function
(
gl
shaders
opt_attribs
opt_locations
)
{
var
realShaders
=
[
]
;
var
program
=
gl
.
createProgram
(
)
;
for
(
var
ii
=
0
;
ii
<
shaders
.
length
;
+
+
ii
)
{
var
shader
=
shaders
[
ii
]
;
if
(
typeof
shader
=
=
'
string
'
)
{
var
element
=
document
.
getElementById
(
shader
)
;
if
(
element
)
{
shader
=
loadShaderFromScript
(
gl
shader
)
;
}
else
{
shader
=
loadShader
(
gl
shader
ii
?
gl
.
FRAGMENT_SHADER
:
gl
.
VERTEX_SHADER
)
;
}
}
gl
.
attachShader
(
program
shader
)
;
}
if
(
opt_attribs
)
{
for
(
var
ii
=
0
;
ii
<
opt_attribs
.
length
;
+
+
ii
)
{
gl
.
bindAttribLocation
(
program
opt_locations
?
opt_locations
[
ii
]
:
ii
opt_attribs
[
ii
]
)
;
}
}
gl
.
linkProgram
(
program
)
;
var
linked
=
gl
.
getProgramParameter
(
program
gl
.
LINK_STATUS
)
;
if
(
!
linked
)
{
gl
.
deleteProgram
(
program
)
;
return
null
;
}
gl
.
useProgram
(
program
)
;
return
program
;
}
;
var
setupSimpleTextureProgram
=
function
(
gl
opt_positionLocation
opt_texcoordLocation
)
{
opt_positionLocation
=
opt_positionLocation
|
|
0
;
opt_texcoordLocation
=
opt_texcoordLocation
|
|
1
;
var
vs
=
setupSimpleTextureVertexShader
(
gl
)
;
var
fs
=
setupSimpleTextureFragmentShader
(
gl
)
;
if
(
!
vs
|
|
!
fs
)
{
return
null
;
}
var
program
=
setupProgram
(
gl
[
vs
fs
]
[
'
vPosition
'
'
texCoord0
'
]
[
opt_positionLocation
opt_texcoordLocation
]
)
;
if
(
!
program
)
{
gl
.
deleteShader
(
fs
)
;
gl
.
deleteShader
(
vs
)
;
}
gl
.
useProgram
(
program
)
;
return
program
;
}
;
var
setupUnitQuad
=
function
(
gl
opt_positionLocation
opt_texcoordLocation
)
{
opt_positionLocation
=
opt_positionLocation
|
|
0
;
opt_texcoordLocation
=
opt_texcoordLocation
|
|
1
;
var
objects
=
[
]
;
var
vertexObject
=
gl
.
createBuffer
(
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
vertexObject
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
new
Float32Array
(
[
1
.
0
1
.
0
0
.
0
-
1
.
0
1
.
0
0
.
0
-
1
.
0
-
1
.
0
0
.
0
1
.
0
1
.
0
0
.
0
-
1
.
0
-
1
.
0
0
.
0
1
.
0
-
1
.
0
0
.
0
]
)
gl
.
STATIC_DRAW
)
;
gl
.
enableVertexAttribArray
(
opt_positionLocation
)
;
gl
.
vertexAttribPointer
(
opt_positionLocation
3
gl
.
FLOAT
false
0
0
)
;
objects
.
push
(
vertexObject
)
;
var
vertexObject
=
gl
.
createBuffer
(
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
vertexObject
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
new
Float32Array
(
[
1
.
0
1
.
0
0
.
0
1
.
0
0
.
0
0
.
0
1
.
0
1
.
0
0
.
0
0
.
0
1
.
0
0
.
0
]
)
gl
.
STATIC_DRAW
)
;
gl
.
enableVertexAttribArray
(
opt_texcoordLocation
)
;
gl
.
vertexAttribPointer
(
opt_texcoordLocation
2
gl
.
FLOAT
false
0
0
)
;
objects
.
push
(
vertexObject
)
;
return
objects
;
}
;
var
setupTexturedQuad
=
function
(
gl
opt_positionLocation
opt_texcoordLocation
)
{
var
program
=
setupSimpleTextureProgram
(
gl
opt_positionLocation
opt_texcoordLocation
)
;
setupUnitQuad
(
gl
opt_positionLocation
opt_texcoordLocation
)
;
return
program
;
}
;
var
drawQuad
=
function
(
gl
opt_color
)
{
opt_color
=
opt_color
|
|
[
255
255
255
255
]
;
gl
.
clearColor
(
opt_color
[
0
]
/
255
opt_color
[
1
]
/
255
opt_color
[
2
]
/
255
opt_color
[
3
]
/
255
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
)
;
gl
.
drawArrays
(
gl
.
TRIANGLES
0
6
)
;
}
;
var
linkProgram
=
function
(
gl
program
opt_errorCallback
)
{
gl
.
linkProgram
(
program
)
;
var
linked
=
gl
.
getProgramParameter
(
program
gl
.
LINK_STATUS
)
;
if
(
!
linked
)
{
gl
.
deleteProgram
(
program
)
;
return
false
;
}
return
true
;
}
;
var
loadShader
=
function
(
gl
shaderSource
shaderType
opt_errorCallback
)
{
var
errFn
=
opt_errorCallback
|
|
(
_
=
>
{
}
)
;
var
shader
=
gl
.
createShader
(
shaderType
)
;
if
(
shader
=
=
null
)
{
errFn
(
'
*
*
*
Error
:
unable
to
create
shader
\
'
'
+
shaderSource
+
'
\
'
'
)
;
return
null
;
}
gl
.
shaderSource
(
shader
shaderSource
)
;
var
err
=
gl
.
getError
(
)
;
if
(
err
!
=
gl
.
NO_ERROR
)
{
errFn
(
'
*
*
*
Error
loading
shader
\
'
'
+
shader
+
'
\
'
:
'
+
glEnumToString
(
gl
err
)
)
;
return
null
;
}
gl
.
compileShader
(
shader
)
;
var
compiled
=
gl
.
getShaderParameter
(
shader
gl
.
COMPILE_STATUS
)
;
if
(
!
compiled
)
{
lastError
=
gl
.
getShaderInfoLog
(
shader
)
;
errFn
(
'
*
*
*
Error
compiling
shader
\
'
'
+
shader
+
'
\
'
:
'
+
lastError
)
;
gl
.
deleteShader
(
shader
)
;
return
null
;
}
return
shader
;
}
var
loadProgram
=
function
(
gl
vertexShader
fragmentShader
opt_errorCallback
)
{
var
program
=
gl
.
createProgram
(
)
;
gl
.
attachShader
(
program
loadShader
(
gl
vertexShader
gl
.
VERTEX_SHADER
opt_errorCallback
)
)
;
gl
.
attachShader
(
program
loadShader
(
gl
fragmentShader
gl
.
FRAGMENT_SHADER
opt_errorCallback
)
)
;
return
linkProgram
(
gl
program
opt_errorCallback
)
?
program
:
null
;
}
;
return
{
drawQuad
:
drawQuad
getLastError
:
getLastError
glEnumToString
:
glEnumToString
loadProgram
:
loadProgram
loadShader
:
loadShader
setupProgram
:
setupProgram
setupSimpleTextureFragmentShader
:
setupSimpleTextureFragmentShader
setupSimpleTextureProgram
:
setupSimpleTextureProgram
setupSimpleTextureVertexShader
:
setupSimpleTextureVertexShader
setupTexturedQuad
:
setupTexturedQuad
setupUnitQuad
:
setupUnitQuad
}
;
}
(
)
)
;
