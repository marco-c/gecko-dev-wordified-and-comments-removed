(
(
)
=
>
{
let
res_num
=
0
;
self
.
uniqueName
=
(
testCase
prefix
)
=
>
{
return
{
self
.
location
.
pathname
}
-
{
prefix
}
-
{
testCase
.
name
}
-
{
+
+
res_num
}
;
}
;
self
.
uniqueNameByQuery
=
(
)
=
>
{
const
prefix
=
new
URL
(
location
.
href
)
.
searchParams
.
get
(
'
prefix
'
)
;
return
{
prefix
}
-
{
+
+
res_num
}
;
}
self
.
iframe
=
url
=
>
new
Promise
(
resolve
=
>
{
const
element
=
document
.
createElement
(
'
iframe
'
)
;
element
.
addEventListener
(
'
load
'
(
)
=
>
{
resolve
(
element
)
;
}
{
once
:
true
}
)
;
element
.
src
=
url
;
document
.
documentElement
.
appendChild
(
element
)
;
}
)
;
let
next_request_id
=
0
;
self
.
postToFrameAndWait
=
(
frame
data
)
=
>
{
const
iframe_window
=
frame
.
contentWindow
;
data
.
rqid
=
next_request_id
+
+
;
iframe_window
.
postMessage
(
data
'
*
'
)
;
return
new
Promise
(
resolve
=
>
{
const
listener
=
event
=
>
{
if
(
event
.
source
!
=
=
iframe_window
|
|
event
.
data
.
rqid
!
=
=
data
.
rqid
)
return
;
self
.
removeEventListener
(
'
message
'
listener
)
;
resolve
(
event
.
data
)
;
}
;
self
.
addEventListener
(
'
message
'
listener
)
;
}
)
;
}
;
self
.
postToWorkerAndWait
=
(
worker
data
)
=
>
{
return
new
Promise
(
resolve
=
>
{
data
.
rqid
=
next_request_id
+
+
;
worker
.
postMessage
(
data
)
;
const
listener
=
event
=
>
{
if
(
event
.
data
.
rqid
!
=
=
data
.
rqid
)
return
;
worker
.
removeEventListener
(
'
message
'
listener
)
;
resolve
(
event
.
data
)
;
}
;
worker
.
addEventListener
(
'
message
'
listener
)
;
}
)
;
}
;
self
.
requestLockAndHold
=
(
t
name
options
=
{
}
)
=
>
{
let
[
promise
resolve
]
=
self
.
makePromiseAndResolveFunc
(
)
;
const
released
=
navigator
.
locks
.
request
(
name
options
(
)
=
>
promise
)
;
t
.
add_cleanup
(
(
)
=
>
{
resolve
(
)
;
return
released
.
catch
(
(
)
=
>
undefined
)
;
}
)
;
return
released
;
}
;
self
.
makePromiseAndResolveFunc
=
(
)
=
>
{
let
resolve
;
const
promise
=
new
Promise
(
r
=
>
{
resolve
=
r
;
}
)
;
return
[
promise
resolve
]
;
}
;
}
)
(
)
;
