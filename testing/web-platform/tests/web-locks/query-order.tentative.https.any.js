'
use
strict
'
;
function
getLockAndHoldUntilReleased
(
name
options
)
{
let
release
;
const
promise
=
new
Promise
(
resolve
=
>
{
release
=
resolve
;
}
)
;
return
new
Promise
(
resolve
=
>
{
navigator
.
locks
.
request
(
name
options
|
|
{
}
lock
=
>
{
resolve
(
release
)
;
return
promise
;
}
)
.
catch
(
_
=
>
{
}
)
;
}
)
;
}
promise_test
(
async
t
=
>
{
const
res1
=
uniqueName
(
t
)
;
const
res2
=
uniqueName
(
t
)
;
const
res3
=
uniqueName
(
t
)
;
await
Promise
.
all
(
[
getLockAndHoldUntilReleased
(
res1
)
getLockAndHoldUntilReleased
(
res2
)
getLockAndHoldUntilReleased
(
res3
)
]
)
;
navigator
.
locks
.
request
(
res3
{
mode
:
'
shared
'
}
lock
=
>
{
}
)
;
navigator
.
locks
.
request
(
res2
{
mode
:
'
shared
'
}
lock
=
>
{
}
)
;
navigator
.
locks
.
request
(
res1
{
mode
:
'
shared
'
}
lock
=
>
{
}
)
;
const
state
=
await
navigator
.
locks
.
query
(
)
;
const
relevant_pending_names
=
state
.
pending
.
map
(
lock
=
>
lock
.
name
)
.
filter
(
name
=
>
[
res1
res2
res3
]
.
includes
(
name
)
)
;
assert_array_equals
(
relevant_pending_names
[
res3
res2
res1
]
'
Pending
locks
should
appear
in
order
.
'
)
;
}
'
Requests
appear
in
state
in
order
made
'
)
;
promise_test
(
async
t
=
>
{
const
res1
=
uniqueName
(
t
)
;
const
res2
=
uniqueName
(
t
)
;
const
res3
=
uniqueName
(
t
)
;
const
[
release1
release2
release3
]
=
await
Promise
.
all
(
[
getLockAndHoldUntilReleased
(
res1
)
getLockAndHoldUntilReleased
(
res2
)
getLockAndHoldUntilReleased
(
res3
)
]
)
;
const
requests
=
[
getLockAndHoldUntilReleased
(
res1
)
getLockAndHoldUntilReleased
(
res2
)
getLockAndHoldUntilReleased
(
res3
)
]
;
await
navigator
.
locks
.
request
(
uniqueName
(
t
)
lock
=
>
{
}
)
;
release2
(
)
;
release3
(
)
;
release1
(
)
;
await
Promise
.
all
(
requests
)
;
const
state
=
await
navigator
.
locks
.
query
(
)
;
const
relevant_held_names
=
state
.
held
.
map
(
lock
=
>
lock
.
name
)
.
filter
(
name
=
>
[
res1
res2
res3
]
.
includes
(
name
)
)
;
assert_array_equals
(
relevant_held_names
[
res2
res3
res1
]
'
Held
locks
should
appear
in
granted
order
.
'
)
;
}
'
Held
locks
appear
in
state
in
order
granted
'
)
;
promise_test
(
async
t
=
>
{
const
res1
=
uniqueName
(
t
)
;
const
res2
=
uniqueName
(
t
)
;
const
res3
=
uniqueName
(
t
)
;
await
Promise
.
all
(
[
getLockAndHoldUntilReleased
(
res1
)
getLockAndHoldUntilReleased
(
res2
)
getLockAndHoldUntilReleased
(
res3
)
]
)
;
await
Promise
.
all
(
[
getLockAndHoldUntilReleased
(
res3
{
steal
:
true
}
)
getLockAndHoldUntilReleased
(
res1
{
steal
:
true
}
)
getLockAndHoldUntilReleased
(
res2
{
steal
:
true
}
)
]
)
;
const
state
=
await
navigator
.
locks
.
query
(
)
;
const
relevant_held_names
=
state
.
held
.
map
(
lock
=
>
lock
.
name
)
.
filter
(
name
=
>
[
res1
res2
res3
]
.
includes
(
name
)
)
;
assert_array_equals
(
relevant_held_names
[
res3
res1
res2
]
'
Held
locks
should
appear
in
granted
order
.
'
)
;
}
'
Held
locks
appear
in
state
in
order
granted
including
when
stolen
'
)
;
