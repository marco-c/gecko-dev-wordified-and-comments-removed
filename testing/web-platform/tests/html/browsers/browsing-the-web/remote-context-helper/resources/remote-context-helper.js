'
use
strict
'
;
{
const
RESOURCES_PATH
=
'
/
html
/
browsers
/
browsing
-
the
-
web
/
remote
-
context
-
helper
/
resources
'
;
const
WINDOW_EXECUTOR_PATH
=
{
RESOURCES_PATH
}
/
executor
-
window
.
py
;
const
WORKER_EXECUTOR_PATH
=
{
RESOURCES_PATH
}
/
executor
-
worker
.
js
;
function
finalizeOrigin
(
origin
)
{
if
(
!
origin
)
{
return
location
.
origin
;
}
if
(
!
origin
.
includes
(
'
/
'
)
)
{
const
origins
=
get_host_info
(
)
;
if
(
origin
in
origins
)
{
return
origins
[
origin
]
;
}
else
{
throw
new
RangeError
(
{
origin
}
is
not
a
key
in
the
get_host_info
(
)
object
)
;
}
}
return
origin
;
}
function
makeAbsolute
(
url
)
{
return
new
URL
(
url
location
)
.
toString
(
)
;
}
async
function
fetchText
(
url
)
{
return
fetch
(
url
)
.
then
(
r
=
>
r
.
text
(
)
)
;
}
class
RemoteContextConfig
{
constructor
(
{
origin
scripts
=
[
]
headers
=
[
]
startOn
status
urlType
}
=
{
}
)
{
this
.
origin
=
origin
;
this
.
scripts
=
scripts
;
this
.
headers
=
headers
;
this
.
startOn
=
startOn
;
this
.
status
=
status
;
this
.
urlType
=
urlType
;
}
static
ensure
(
config
)
{
if
(
!
config
)
{
return
DEFAULT_CONTEXT_CONFIG
;
}
return
new
RemoteContextConfig
(
config
)
;
}
merged
(
extraConfig
)
{
let
origin
=
this
.
origin
;
if
(
extraConfig
.
origin
)
{
origin
=
extraConfig
.
origin
;
}
let
startOn
=
this
.
startOn
;
if
(
extraConfig
.
startOn
)
{
startOn
=
extraConfig
.
startOn
;
}
let
status
=
this
.
status
;
if
(
extraConfig
.
status
)
{
status
=
extraConfig
.
status
;
}
let
urlType
=
this
.
urlType
;
if
(
extraConfig
.
urlType
)
{
urlType
=
extraConfig
.
urlType
;
}
const
headers
=
this
.
headers
.
concat
(
extraConfig
.
headers
)
;
const
scripts
=
this
.
scripts
.
concat
(
extraConfig
.
scripts
)
;
return
new
RemoteContextConfig
(
{
origin
headers
scripts
startOn
status
urlType
}
)
;
}
async
createExecutorUrl
(
uuid
isWorker
)
{
const
origin
=
finalizeOrigin
(
this
.
origin
)
;
const
url
=
new
URL
(
isWorker
?
WORKER_EXECUTOR_PATH
:
WINDOW_EXECUTOR_PATH
origin
)
;
url
.
searchParams
.
append
(
'
uuid
'
uuid
)
;
if
(
this
.
headers
)
{
addHeaders
(
url
this
.
headers
)
;
}
for
(
const
script
of
this
.
scripts
)
{
url
.
searchParams
.
append
(
'
script
'
makeAbsolute
(
script
)
)
;
}
if
(
this
.
startOn
)
{
url
.
searchParams
.
append
(
'
startOn
'
this
.
startOn
)
;
}
if
(
this
.
status
)
{
url
.
searchParams
.
append
(
'
status
'
this
.
status
)
;
}
const
urlType
=
this
.
urlType
|
|
'
origin
'
;
switch
(
urlType
)
{
case
'
origin
'
:
case
'
blank
'
:
return
url
.
href
;
case
'
data
'
:
return
data
:
text
/
html
;
base64
{
btoa
(
await
fetchText
(
url
.
href
)
)
}
;
case
'
blob
'
:
return
URL
.
createObjectURL
(
new
Blob
(
[
await
fetchText
(
url
.
href
)
]
{
type
:
'
text
/
html
'
}
)
)
;
default
:
throw
TypeError
(
Invalid
urlType
:
{
urlType
}
)
;
}
;
}
}
const
DEFAULT_CONTEXT_CONFIG
=
new
RemoteContextConfig
(
)
;
function
addHeaders
(
url
headers
)
{
function
escape
(
s
)
{
return
s
.
replace
(
'
(
'
'
\
\
(
'
)
.
replace
(
'
)
'
'
\
\
)
'
)
.
replace
(
'
'
'
\
\
'
)
;
}
const
formattedHeaders
=
headers
.
map
(
(
header
)
=
>
{
return
header
(
{
escape
(
header
[
0
]
)
}
{
escape
(
header
[
1
]
)
}
)
;
}
)
;
url
.
searchParams
.
append
(
'
pipe
'
formattedHeaders
.
join
(
'
|
'
)
)
;
}
function
windowExecutorCreator
(
{
target
=
'
_blank
'
features
}
=
{
}
remoteContextWrapper
)
{
let
openWindow
=
(
url
target
features
documentContent
)
=
>
{
const
w
=
window
.
open
(
url
target
features
)
;
if
(
documentContent
)
{
w
.
document
.
open
(
)
;
w
.
document
.
write
(
documentContent
)
;
w
.
document
.
close
(
)
;
}
}
;
return
(
url
documentContent
)
=
>
{
if
(
url
&
&
url
.
substring
(
0
5
)
=
=
'
data
:
'
)
{
throw
new
TypeError
(
'
Windows
cannot
use
data
:
URLs
.
'
)
;
}
if
(
remoteContextWrapper
)
{
return
remoteContextWrapper
.
executeScript
(
openWindow
[
url
target
features
documentContent
]
)
;
}
else
{
openWindow
(
url
target
features
documentContent
)
;
}
}
;
}
function
elementExecutorCreator
(
remoteContextWrapper
elementName
attributes
)
{
return
(
url
documentContent
)
=
>
{
return
remoteContextWrapper
.
executeScript
(
(
url
elementName
attributes
documentContent
)
=
>
{
const
el
=
document
.
createElement
(
elementName
)
;
for
(
const
attribute
in
attributes
)
{
el
.
setAttribute
(
attribute
attributes
[
attribute
]
)
;
}
if
(
url
)
{
if
(
elementName
=
=
'
object
'
)
{
el
.
data
=
url
;
}
else
{
el
.
src
=
url
;
}
}
const
parent
=
elementName
=
=
'
frame
'
?
findOrCreateFrameset
(
)
:
document
.
body
;
parent
.
appendChild
(
el
)
;
if
(
documentContent
)
{
el
.
contentDocument
.
open
(
)
;
el
.
contentDocument
.
write
(
documentContent
)
;
el
.
contentDocument
.
close
(
)
;
}
}
[
url
elementName
attributes
documentContent
]
)
;
}
;
}
function
iframeSrcdocExecutorCreator
(
remoteContextWrapper
attributes
)
{
return
async
(
url
)
=
>
{
attributes
[
'
srcdoc
'
]
=
await
fetchText
(
url
)
;
elementExecutorCreator
(
remoteContextWrapper
'
iframe
'
attributes
)
(
undefined
)
;
}
;
}
function
workerExecutorCreator
(
remoteContextWrapper
globalVariable
)
{
return
url
=
>
{
return
remoteContextWrapper
.
executeScript
(
(
url
globalVariable
)
=
>
{
const
worker
=
new
Worker
(
url
)
;
if
(
globalVariable
)
{
window
[
globalVariable
]
=
worker
;
}
}
[
url
globalVariable
]
)
;
}
;
}
function
navigateExecutorCreator
(
remoteContextWrapper
)
{
return
url
=
>
{
return
remoteContextWrapper
.
navigate
(
(
url
)
=
>
{
window
.
location
=
url
;
}
[
url
]
)
;
}
;
}
class
RemoteContextWrapper
{
constructor
(
context
helper
url
)
{
this
.
context
=
context
;
this
.
helper
=
helper
;
this
.
url
=
url
;
}
async
executeScript
(
fn
args
)
{
return
this
.
context
.
execute_script
(
fn
args
)
;
}
async
addHTML
(
html
)
{
return
this
.
executeScript
(
(
htmlSource
)
=
>
{
document
.
body
.
insertAdjacentHTML
(
'
beforebegin
'
htmlSource
)
;
}
[
html
]
)
;
}
async
addScripts
(
urls
)
{
if
(
!
urls
)
{
return
[
]
;
}
return
this
.
executeScript
(
urls
=
>
{
return
addScripts
(
urls
)
;
}
[
urls
.
map
(
makeAbsolute
)
]
)
;
}
addIframe
(
extraConfig
attributes
=
{
}
)
{
return
this
.
helper
.
createContext
(
{
executorCreator
:
elementExecutorCreator
(
this
'
iframe
'
attributes
)
extraConfig
}
)
;
}
addFrame
(
extraConfig
attributes
=
{
}
)
{
return
this
.
helper
.
createContext
(
{
executorCreator
:
elementExecutorCreator
(
this
'
frame
'
attributes
)
extraConfig
}
)
;
}
addEmbed
(
extraConfig
attributes
=
{
}
)
{
return
this
.
helper
.
createContext
(
{
executorCreator
:
elementExecutorCreator
(
this
'
embed
'
attributes
)
extraConfig
}
)
;
}
addObject
(
extraConfig
attributes
=
{
}
)
{
return
this
.
helper
.
createContext
(
{
executorCreator
:
elementExecutorCreator
(
this
'
object
'
attributes
)
extraConfig
}
)
;
}
addIframeSrcdoc
(
extraConfig
attributes
=
{
}
)
{
return
this
.
helper
.
createContext
(
{
executorCreator
:
iframeSrcdocExecutorCreator
(
this
attributes
)
extraConfig
}
)
;
}
addWindow
(
extraConfig
options
)
{
return
this
.
helper
.
createContext
(
{
executorCreator
:
windowExecutorCreator
(
options
this
)
extraConfig
}
)
;
}
addWorker
(
globalVariable
extraConfig
)
{
return
this
.
helper
.
createContext
(
{
executorCreator
:
workerExecutorCreator
(
this
globalVariable
)
extraConfig
isWorker
:
true
}
)
;
}
async
getRequestHeaders
(
)
{
const
asNestedArrays
=
await
this
.
executeScript
(
(
)
=
>
[
.
.
.
window
.
__requestHeaders
]
)
;
return
new
Headers
(
asNestedArrays
)
;
}
navigate
(
fn
args
)
{
return
this
.
executeScript
(
(
fnText
args
)
=
>
{
executeScriptToNavigate
(
fnText
args
)
;
}
[
fn
.
toString
(
)
args
]
)
;
}
navigateTo
(
url
)
{
return
this
.
navigate
(
url
=
>
{
location
.
href
=
url
;
}
[
url
.
toString
(
)
]
)
;
}
async
navigateToNew
(
extraConfig
)
{
return
this
.
helper
.
createContext
(
{
executorCreator
:
navigateExecutorCreator
(
this
)
extraConfig
}
)
;
}
async
waitUntilLocationIs
(
expectedLocation
)
{
return
this
.
executeScript
(
async
(
expectedLocation
)
=
>
{
if
(
location
.
href
=
=
=
expectedLocation
)
{
return
;
}
await
new
Promise
(
resolve
=
>
{
const
listener
=
addEventListener
(
'
hashchange
'
(
event
)
=
>
{
if
(
event
.
newURL
=
=
=
expectedLocation
)
{
removeEventListener
(
listener
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
[
expectedLocation
]
)
;
}
async
historyGo
(
n
expectedLocation
)
{
await
this
.
navigate
(
(
n
)
=
>
{
history
.
go
(
n
)
;
}
[
n
]
)
;
if
(
expectedLocation
)
{
await
this
.
waitUntilLocationIs
(
expectedLocation
)
;
}
}
async
historyBack
(
expectedLocation
)
{
await
this
.
navigate
(
(
)
=
>
{
history
.
back
(
)
;
}
)
;
if
(
expectedLocation
)
{
await
this
.
waitUntilLocationIs
(
expectedLocation
)
;
}
}
async
historyForward
(
expectedLocation
)
{
await
this
.
navigate
(
(
)
=
>
{
history
.
forward
(
)
;
}
)
;
if
(
expectedLocation
)
{
await
this
.
waitUntilLocationIs
(
expectedLocation
)
;
}
}
}
class
RemoteContextHelper
{
static
RemoteContextWrapper
=
RemoteContextWrapper
;
constructor
(
config
)
{
this
.
config
=
RemoteContextConfig
.
ensure
(
config
)
;
}
async
createContext
(
{
executorCreator
extraConfig
isWorker
=
false
}
)
{
const
config
=
this
.
config
.
merged
(
RemoteContextConfig
.
ensure
(
extraConfig
)
)
;
const
uuid
=
token
(
)
;
const
url
=
await
config
.
createExecutorUrl
(
uuid
isWorker
)
;
if
(
executorCreator
)
{
if
(
config
.
urlType
=
=
'
blank
'
)
{
await
executorCreator
(
undefined
await
fetchText
(
url
)
)
;
}
else
{
await
executorCreator
(
url
undefined
)
;
}
}
return
new
this
.
constructor
.
RemoteContextWrapper
(
new
RemoteContext
(
uuid
)
this
url
)
;
}
addWindow
(
extraConfig
options
)
{
return
this
.
createContext
(
{
executorCreator
:
windowExecutorCreator
(
options
)
extraConfig
}
)
;
}
}
self
.
RemoteContextHelper
=
RemoteContextHelper
;
}
