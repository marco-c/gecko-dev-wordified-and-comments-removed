async
function
prepareForBFCache
(
remoteContextHelper
)
{
await
remoteContextHelper
.
executeScript
(
(
)
=
>
{
window
.
beforeBFCache
=
true
;
}
)
;
}
async
function
getBeforeBFCache
(
remoteContextHelper
)
{
return
await
remoteContextHelper
.
executeScript
(
(
)
=
>
{
return
window
.
beforeBFCache
;
}
)
;
}
async
function
assertImplementsBFCacheOptional
(
remoteContextHelper
)
{
var
beforeBFCache
=
await
getBeforeBFCache
(
remoteContextHelper
)
;
assert_implements_optional
(
beforeBFCache
=
=
true
'
BFCache
not
supported
.
'
)
;
}
function
setMinus
(
a
b
)
{
const
minus
=
new
Set
(
)
;
a
.
forEach
(
e
=
>
{
if
(
!
b
.
has
(
e
)
)
{
minus
.
add
(
e
)
;
}
}
)
;
return
minus
;
}
function
sorted
(
s
)
{
return
Array
.
from
(
s
)
.
sort
(
)
;
}
function
matchReasons
(
expectedNotRestoredReasonsSet
notRestoredReasonsSet
)
{
const
missing
=
setMinus
(
expectedNotRestoredReasonsSet
notRestoredReasonsSet
)
;
const
extra
=
setMinus
(
notRestoredReasonsSet
expectedNotRestoredReasonsSet
)
;
assert_true
(
missing
.
size
=
=
0
Expected
:
{
sorted
(
expectedNotRestoredReasonsSet
)
}
\
n
+
Got
:
{
sorted
(
notRestoredReasonsSet
)
}
\
n
+
Missing
:
{
sorted
(
missing
)
}
\
n
+
Extra
:
{
sorted
(
extra
)
}
\
n
)
;
}
function
extractReason
(
reasonSet
)
{
let
reasonsExtracted
=
new
Set
(
)
;
for
(
let
reason
of
reasonSet
)
{
reasonsExtracted
.
add
(
reason
.
reason
)
;
}
return
reasonsExtracted
;
}
async
function
assertNotRestoredFromBFCache
(
remoteContextHelper
notRestoredReasons
preconditionFailReasons
=
null
)
{
var
beforeBFCache
=
await
getBeforeBFCache
(
remoteContextHelper
)
;
assert_equals
(
beforeBFCache
undefined
'
document
unexpectedly
BFCached
'
)
;
if
(
notRestoredReasons
=
=
=
undefined
)
{
return
;
}
let
isFeatureEnabled
=
await
remoteContextHelper
.
executeScript
(
(
)
=
>
{
return
'
notRestoredReasons
'
in
performance
.
getEntriesByType
(
'
navigation
'
)
[
0
]
;
}
)
;
if
(
!
isFeatureEnabled
)
{
return
;
}
let
result
=
await
remoteContextHelper
.
executeScript
(
(
)
=
>
{
return
performance
.
getEntriesByType
(
'
navigation
'
)
[
0
]
.
notRestoredReasons
;
}
)
;
let
expectedNotRestoredReasonsSet
=
new
Set
(
notRestoredReasons
)
;
let
notRestoredReasonsSet
=
new
Set
(
)
;
const
collectReason
=
(
node
)
=
>
{
for
(
let
reason
of
node
.
reasons
)
{
notRestoredReasonsSet
.
add
(
reason
.
reason
)
;
}
for
(
let
child
of
node
.
children
)
{
collectReason
(
child
)
;
}
}
;
collectReason
(
result
)
;
if
(
preconditionFailReasons
)
{
let
preconditionFailReasonsSet
=
new
Set
(
preconditionFailReasons
)
;
const
missing
=
setMinus
(
preconditionFailReasonsSet
notRestoredReasonsSet
)
;
const
extra
=
setMinus
(
notRestoredReasonsSet
preconditionFailReasonsSet
)
;
assert_implements_optional
(
!
(
missing
.
size
=
=
0
&
&
extra
.
size
=
=
0
)
'
Precondition
fail
reasons
are
reported
.
'
)
;
}
matchReasons
(
expectedNotRestoredReasonsSet
notRestoredReasonsSet
)
;
}
async
function
assertBFCacheEligibility
(
remoteContextHelper
shouldRestoreFromBFCache
)
{
await
prepareForBFCache
(
remoteContextHelper
)
;
const
newRemoteContextHelper
=
await
remoteContextHelper
.
navigateToNew
(
)
;
await
newRemoteContextHelper
.
historyBack
(
)
;
if
(
shouldRestoreFromBFCache
)
{
await
assertImplementsBFCacheOptional
(
remoteContextHelper
)
;
}
else
{
await
assertNotRestoredFromBFCache
(
remoteContextHelper
)
;
}
}
