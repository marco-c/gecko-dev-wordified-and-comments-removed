function
runTest
(
urlToFetch
hasCSP
shouldSucceed
description
)
{
runBfcacheTest
(
{
funcBeforeNavigation
:
async
(
urlToFetch
hasCSP
)
=
>
{
if
(
hasCSP
)
{
const
meta
=
document
.
createElement
(
'
meta
'
)
;
meta
.
setAttribute
(
'
http
-
equiv
'
'
Content
-
Security
-
Policy
'
)
;
meta
.
setAttribute
(
'
content
'
"
connect
-
src
'
self
'
"
)
;
document
.
head
.
appendChild
(
meta
)
;
}
window
.
fetchPromise
=
fetch
(
urlToFetch
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
500
)
)
;
}
argsBeforeNavigation
:
[
urlToFetch
hasCSP
]
funcBeforeBackNavigation
:
(
)
=
>
{
return
new
Promise
(
resolve
=
>
setTimeout
(
resolve
2000
)
)
;
}
funcAfterAssertion
:
async
(
pageA
pageB
t
)
=
>
{
const
result
=
pageA
.
execute_script
(
(
)
=
>
window
.
fetchPromise
.
then
(
r
=
>
r
.
text
(
)
)
)
;
if
(
shouldSucceed
)
{
assert_equals
(
await
result
'
Body
'
'
Fetch
should
complete
successfully
after
restored
from
BFCache
'
)
;
}
else
{
await
promise_rejects_js
(
t
TypeError
result
'
Fetch
should
fail
after
restored
from
BFCache
'
)
;
}
}
}
'
Eligibility
(
in
-
flight
fetch
)
:
'
+
description
)
;
}
const
url
=
new
URL
(
'
.
.
/
resources
/
slow
.
py
'
location
)
;
const
sameOriginUrl
=
url
.
href
;
const
crossSiteUrl
=
originCrossSite
+
url
.
pathname
;
