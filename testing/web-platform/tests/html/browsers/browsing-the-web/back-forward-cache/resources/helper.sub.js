const
originSameOrigin
=
location
.
protocol
=
=
=
'
http
:
'
?
'
http
:
/
/
{
{
host
}
}
:
{
{
ports
[
http
]
[
0
]
}
}
'
:
'
https
:
/
/
{
{
host
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
;
const
originSameSite
=
location
.
protocol
=
=
=
'
http
:
'
?
'
http
:
/
/
{
{
host
}
}
:
{
{
ports
[
http
]
[
1
]
}
}
'
:
'
https
:
/
/
{
{
host
}
}
:
{
{
ports
[
https
]
[
1
]
}
}
'
;
const
originCrossSite
=
location
.
protocol
=
=
=
'
http
:
'
?
'
http
:
/
/
{
{
hosts
[
alt
]
[
www
]
}
}
:
{
{
ports
[
http
]
[
0
]
}
}
'
:
'
https
:
/
/
{
{
hosts
[
alt
]
[
www
]
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
;
const
executorPath
=
'
/
html
/
browsers
/
browsing
-
the
-
web
/
back
-
forward
-
cache
/
resources
/
executor
.
html
?
uuid
=
'
;
async
function
assert_bfcached
(
target
)
{
const
status
=
await
getBFCachedStatus
(
target
)
;
assert_implements_optional
(
status
=
=
=
'
BFCached
'
"
Could
have
been
BFCached
but
actually
wasn
'
t
"
)
;
}
async
function
assert_not_bfcached
(
target
)
{
const
status
=
await
getBFCachedStatus
(
target
)
;
assert_implements
(
status
!
=
=
'
BFCached
'
'
Should
not
be
BFCached
but
actually
was
'
)
;
}
async
function
getBFCachedStatus
(
target
)
{
const
[
loadCount
isPageshowFired
isPageshowPersisted
]
=
await
target
.
execute_script
(
(
)
=
>
[
window
.
loadCount
window
.
isPageshowFired
window
.
isPageshowPersisted
]
)
;
if
(
loadCount
=
=
=
1
&
&
isPageshowFired
=
=
=
true
&
&
isPageshowPersisted
=
=
=
true
)
{
return
'
BFCached
'
;
}
else
if
(
loadCount
=
=
=
2
&
&
isPageshowFired
=
=
=
false
)
{
return
'
Not
BFCached
'
;
}
else
{
assert_unreached
(
Got
unexpected
BFCache
status
:
loadCount
=
{
loadCount
}
+
isPageshowFired
=
{
isPageshowFired
}
+
isPageshowPersisted
=
{
isPageshowPersisted
}
)
;
}
}
const
waitForPageShow
=
(
)
=
>
window
.
pageShowPromise
;
function
runEventTest
(
params
description
)
{
const
defaultParams
=
{
openFunc
(
url
)
{
window
.
open
(
{
url
}
&
events
=
{
this
.
events
.
join
(
'
'
)
}
'
_blank
'
'
noopener
'
)
}
events
:
[
'
pagehide
'
'
pageshow
'
'
load
'
]
expectedEvents
:
[
'
window
.
load
'
'
window
.
pageshow
'
'
window
.
pagehide
.
persisted
'
'
window
.
pageshow
.
persisted
'
]
async
funcAfterAssertion
(
pageA
)
{
assert_array_equals
(
await
pageA
.
execute_script
(
(
)
=
>
getRecordedEvents
(
)
)
this
.
expectedEvents
)
;
}
}
params
=
{
.
.
.
defaultParams
.
.
.
params
}
;
runBfcacheTest
(
params
description
)
;
}
async
function
navigateAndThenBack
(
pageA
pageB
urlB
scripts
=
[
]
funcBeforeBackNavigation
argsBeforeBackNavigation
)
{
await
pageA
.
execute_script
(
(
url
)
=
>
{
prepareNavigation
(
(
)
=
>
{
location
.
href
=
url
;
}
)
;
}
[
urlB
]
)
;
await
pageB
.
execute_script
(
waitForPageShow
)
;
for
(
const
src
of
scripts
)
{
await
pageB
.
execute_script
(
(
src
)
=
>
{
const
script
=
document
.
createElement
(
"
script
"
)
;
script
.
src
=
src
;
document
.
head
.
append
(
script
)
;
return
new
Promise
(
resolve
=
>
script
.
onload
=
resolve
)
;
}
[
src
]
)
;
}
if
(
funcBeforeBackNavigation
)
{
await
pageB
.
execute_script
(
funcBeforeBackNavigation
argsBeforeBackNavigation
)
;
}
await
pageB
.
execute_script
(
(
)
=
>
{
prepareNavigation
(
(
)
=
>
{
history
.
back
(
)
;
}
)
;
}
)
;
await
pageA
.
execute_script
(
waitForPageShow
)
;
}
function
runBfcacheTest
(
params
description
)
{
const
defaultParams
=
{
openFunc
:
url
=
>
window
.
open
(
url
'
_blank
'
'
noopener
'
)
scripts
:
[
]
funcBeforeNavigation
:
(
)
=
>
{
}
argsBeforeNavigation
:
[
]
targetOrigin
:
originCrossSite
funcBeforeBackNavigation
:
(
)
=
>
{
}
argsBeforeBackNavigation
:
[
]
shouldBeCached
:
true
funcAfterAssertion
:
(
)
=
>
{
}
}
params
=
{
.
.
.
defaultParams
.
.
.
params
}
;
promise_test
(
async
t
=
>
{
const
pageA
=
new
RemoteContext
(
token
(
)
)
;
const
pageB
=
new
RemoteContext
(
token
(
)
)
;
const
urlA
=
executorPath
+
pageA
.
context_id
;
const
urlB
=
params
.
targetOrigin
+
executorPath
+
pageB
.
context_id
;
pageA
.
url
=
originSameOrigin
+
urlA
;
pageB
.
url
=
urlB
;
params
.
openFunc
(
urlA
)
;
await
pageA
.
execute_script
(
waitForPageShow
)
;
for
(
const
src
of
params
.
scripts
)
{
await
pageA
.
execute_script
(
(
src
)
=
>
{
const
script
=
document
.
createElement
(
"
script
"
)
;
script
.
src
=
src
;
document
.
head
.
append
(
script
)
;
return
new
Promise
(
resolve
=
>
script
.
onload
=
resolve
)
;
}
[
src
]
)
;
}
await
pageA
.
execute_script
(
params
.
funcBeforeNavigation
params
.
argsBeforeNavigation
)
;
await
navigateAndThenBack
(
pageA
pageB
urlB
params
.
scripts
params
.
funcBeforeBackNavigation
params
.
argsBeforeBackNavigation
)
;
if
(
params
.
shouldBeCached
)
{
await
assert_bfcached
(
pageA
)
;
}
else
{
await
assert_not_bfcached
(
pageA
)
;
}
if
(
params
.
funcAfterAssertion
)
{
await
params
.
funcAfterAssertion
(
pageA
pageB
t
)
;
}
}
description
)
;
}
async
function
claim
(
t
worker
)
{
const
channel
=
new
MessageChannel
(
)
;
const
sawMessage
=
new
Promise
(
function
(
resolve
)
{
channel
.
port1
.
onmessage
=
t
.
step_func
(
function
(
e
)
{
assert_equals
(
e
.
data
'
PASS
'
'
Worker
call
to
claim
(
)
should
fulfill
.
'
)
;
resolve
(
)
;
}
)
;
}
)
;
worker
.
postMessage
(
{
type
:
"
claim
"
port
:
channel
.
port2
}
[
channel
.
port2
]
)
;
await
sawMessage
;
}
async
function
storeClients
(
t
worker
)
{
const
channel
=
new
MessageChannel
(
)
;
const
sawMessage
=
new
Promise
(
function
(
resolve
)
{
channel
.
port1
.
onmessage
=
t
.
step_func
(
function
(
e
)
{
assert_equals
(
e
.
data
'
PASS
'
'
storeClients
'
)
;
resolve
(
)
;
}
)
;
}
)
;
worker
.
postMessage
(
{
type
:
"
storeClients
"
port
:
channel
.
port2
}
[
channel
.
port2
]
)
;
await
sawMessage
;
}
async
function
postMessageToStoredClients
(
t
worker
)
{
const
channel
=
new
MessageChannel
(
)
;
const
sawMessage
=
new
Promise
(
function
(
resolve
)
{
channel
.
port1
.
onmessage
=
t
.
step_func
(
function
(
e
)
{
assert_equals
(
e
.
data
'
PASS
'
'
postMessageToStoredClients
'
)
;
resolve
(
)
;
}
)
;
}
)
;
worker
.
postMessage
(
{
type
:
"
postMessageToStoredClients
"
port
:
channel
.
port2
}
[
channel
.
port2
]
)
;
await
sawMessage
;
}
async
function
postMessageViaTransferredPort
(
t
worker
)
{
const
channel
=
new
MessageChannel
(
)
;
const
sawMessage
=
new
Promise
(
resolve
=
>
{
channel
.
port1
.
onmessage
=
t
.
step_func
(
e
=
>
{
assert_equals
(
e
.
data
'
PASS
'
'
SW
should
confirm
message
was
sent
.
'
)
;
resolve
(
)
;
}
)
;
}
)
;
worker
.
postMessage
(
{
type
:
'
postMessageViaTransferredPort
'
port
:
channel
.
port2
}
[
channel
.
port2
]
)
;
await
sawMessage
;
}
async
function
createServiceWorkerControlledPage
(
t
workerUrl
=
'
/
html
/
browsers
/
browsing
-
the
-
web
/
back
-
forward
-
cache
/
resources
/
service
-
worker
.
js
?
pipe
=
header
(
Service
-
Worker
-
Allowed
/
)
'
scope
=
'
/
'
)
{
const
registration
=
await
service_worker_unregister_and_register
(
t
workerUrl
scope
)
;
t
.
add_cleanup
(
(
)
=
>
registration
.
unregister
(
)
)
;
await
wait_for_state
(
t
registration
.
installing
'
activated
'
)
;
const
controllerChanged
=
new
Promise
(
resolve
=
>
navigator
.
serviceWorker
.
oncontrollerchange
=
resolve
)
;
await
claim
(
t
registration
.
active
)
;
await
controllerChanged
;
const
rcHelper
=
new
RemoteContextHelper
(
)
;
const
page
=
await
rcHelper
.
addWindow
(
{
}
{
features
:
'
noopener
'
}
)
;
assert_true
(
await
page
.
executeScript
(
(
)
=
>
(
navigator
.
serviceWorker
.
controller
!
=
=
null
)
)
'
Page
should
be
controlled
before
navigation
'
)
;
return
{
registration
page
}
;
}
