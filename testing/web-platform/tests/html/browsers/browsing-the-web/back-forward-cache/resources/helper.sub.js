const
originSameOrigin
=
location
.
protocol
=
=
=
'
http
:
'
?
'
http
:
/
/
{
{
host
}
}
:
{
{
ports
[
http
]
[
0
]
}
}
'
:
'
https
:
/
/
{
{
host
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
;
const
originSameSite
=
location
.
protocol
=
=
=
'
http
:
'
?
'
http
:
/
/
{
{
host
}
}
:
{
{
ports
[
http
]
[
1
]
}
}
'
:
'
https
:
/
/
{
{
host
}
}
:
{
{
ports
[
https
]
[
1
]
}
}
'
;
const
originCrossSite
=
location
.
protocol
=
=
=
'
http
:
'
?
'
http
:
/
/
{
{
hosts
[
alt
]
[
www
]
}
}
:
{
{
ports
[
http
]
[
0
]
}
}
'
:
'
https
:
/
/
{
{
hosts
[
alt
]
[
www
]
}
}
:
{
{
ports
[
https
]
[
0
]
}
}
'
;
const
executorPath
=
'
/
html
/
browsers
/
browsing
-
the
-
web
/
back
-
forward
-
cache
/
resources
/
executor
.
html
?
uuid
=
'
;
async
function
assert_bfcached
(
target
)
{
const
status
=
await
getBFCachedStatus
(
target
)
;
assert_implements_optional
(
status
=
=
=
'
BFCached
'
"
Should
be
BFCached
but
actually
wasn
'
t
"
)
;
}
async
function
assert_not_bfcached
(
target
)
{
const
status
=
await
getBFCachedStatus
(
target
)
;
assert_implements
(
status
!
=
=
'
BFCached
'
'
Should
not
be
BFCached
but
actually
was
'
)
;
}
async
function
getBFCachedStatus
(
target
)
{
const
[
loadCount
isPageshowFired
isPageshowPersisted
]
=
await
target
.
execute_script
(
(
)
=
>
[
window
.
loadCount
window
.
isPageshowFired
window
.
isPageshowPersisted
]
)
;
if
(
loadCount
=
=
=
1
&
&
isPageshowFired
=
=
=
true
&
&
isPageshowPersisted
=
=
=
true
)
{
return
'
BFCached
'
;
}
else
if
(
loadCount
=
=
=
2
&
&
isPageshowFired
=
=
=
false
)
{
return
'
Not
BFCached
'
;
}
else
{
assert_unreached
(
Got
unexpected
BFCache
status
:
loadCount
=
{
loadCount
}
+
isPageshowFired
=
{
isPageshowFired
}
+
isPageshowPersisted
=
{
isPageshowPersisted
}
)
;
}
}
const
waitForPageShow
=
(
)
=
>
window
.
pageShowPromise
;
function
runEventTest
(
params
description
)
{
const
defaultParams
=
{
openFunc
(
url
)
{
window
.
open
(
{
url
}
&
events
=
{
this
.
events
.
join
(
'
'
)
}
'
_blank
'
'
noopener
'
)
}
events
:
[
'
pagehide
'
'
pageshow
'
'
load
'
]
expectedEvents
:
[
'
window
.
load
'
'
window
.
pageshow
'
'
window
.
pagehide
.
persisted
'
'
window
.
pageshow
.
persisted
'
]
async
funcAfterAssertion
(
pageA
)
{
assert_array_equals
(
await
pageA
.
execute_script
(
(
)
=
>
getRecordedEvents
(
)
)
this
.
expectedEvents
)
;
}
}
params
=
{
.
.
.
defaultParams
.
.
.
params
}
;
runBfcacheTest
(
params
description
)
;
}
async
function
navigateAndThenBack
(
pageA
pageB
urlB
funcBeforeBackNavigation
argsBeforeBackNavigation
)
{
await
pageA
.
execute_script
(
(
url
)
=
>
{
prepareNavigation
(
(
)
=
>
{
location
.
href
=
url
;
}
)
;
}
[
urlB
]
)
;
await
pageB
.
execute_script
(
waitForPageShow
)
;
if
(
funcBeforeBackNavigation
)
{
await
pageB
.
execute_script
(
funcBeforeBackNavigation
argsBeforeBackNavigation
)
;
}
await
pageB
.
execute_script
(
(
)
=
>
{
prepareNavigation
(
(
)
=
>
{
history
.
back
(
)
;
}
)
;
}
)
;
await
pageA
.
execute_script
(
waitForPageShow
)
;
}
function
runBfcacheTest
(
params
description
)
{
const
defaultParams
=
{
openFunc
:
url
=
>
window
.
open
(
url
'
_blank
'
'
noopener
'
)
scripts
:
[
]
funcBeforeNavigation
:
(
)
=
>
{
}
argsBeforeNavigation
:
[
]
targetOrigin
:
originCrossSite
funcBeforeBackNavigation
:
(
)
=
>
{
}
argsBeforeBackNavigation
:
[
]
shouldBeCached
:
true
funcAfterAssertion
:
(
)
=
>
{
}
}
params
=
{
.
.
.
defaultParams
.
.
.
params
}
;
promise_test
(
async
t
=
>
{
const
pageA
=
new
RemoteContext
(
token
(
)
)
;
const
pageB
=
new
RemoteContext
(
token
(
)
)
;
const
urlA
=
executorPath
+
pageA
.
context_id
;
const
urlB
=
params
.
targetOrigin
+
executorPath
+
pageB
.
context_id
;
pageA
.
url
=
originSameOrigin
+
urlA
;
pageB
.
url
=
urlB
;
params
.
openFunc
(
urlA
)
;
await
pageA
.
execute_script
(
waitForPageShow
)
;
for
(
const
src
of
params
.
scripts
)
{
await
pageA
.
execute_script
(
(
src
)
=
>
{
const
script
=
document
.
createElement
(
"
script
"
)
;
script
.
src
=
src
;
document
.
head
.
append
(
script
)
;
return
new
Promise
(
resolve
=
>
script
.
onload
=
resolve
)
;
}
[
src
]
)
;
}
await
pageA
.
execute_script
(
params
.
funcBeforeNavigation
params
.
argsBeforeNavigation
)
;
await
navigateAndThenBack
(
pageA
pageB
urlB
params
.
funcBeforeBackNavigation
params
.
argsBeforeBackNavigation
)
;
if
(
params
.
shouldBeCached
)
{
await
assert_bfcached
(
pageA
)
;
}
else
{
await
assert_not_bfcached
(
pageA
)
;
}
if
(
params
.
funcAfterAssertion
)
{
await
params
.
funcAfterAssertion
(
pageA
pageB
t
)
;
}
}
description
)
;
}
