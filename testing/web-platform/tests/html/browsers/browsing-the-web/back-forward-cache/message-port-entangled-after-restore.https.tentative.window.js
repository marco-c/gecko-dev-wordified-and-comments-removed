promise_test
(
async
t
=
>
{
const
scope
=
'
/
html
/
browsers
/
browsing
-
the
-
web
/
remote
-
context
-
helper
/
resources
'
const
workerUrl
=
resources
/
service
-
worker
.
js
?
pipe
=
header
(
Service
-
Worker
-
Allowed
{
scope
}
)
;
const
registration
=
await
service_worker_unregister_and_register
(
t
workerUrl
scope
)
;
t
.
add_cleanup
(
_
=
>
registration
.
unregister
(
)
)
;
await
wait_for_state
(
t
registration
.
installing
'
activated
'
)
;
const
rcHelper
=
new
RemoteContextHelper
(
)
;
const
rc1
=
await
rcHelper
.
addWindow
(
null
{
features
:
'
noopener
'
}
)
;
assert_true
(
await
rc1
.
executeScript
(
(
)
=
>
(
navigator
.
serviceWorker
.
controller
!
=
=
null
)
)
'
The
page
should
be
controlled
before
navigation
'
)
;
await
rc1
.
executeScript
(
(
)
=
>
{
const
{
port1
port2
}
=
new
MessageChannel
(
)
;
port1
.
start
(
)
;
const
ctrl
=
navigator
.
serviceWorker
.
controller
;
ctrl
.
postMessage
(
{
type
:
'
storeMessagePort
'
}
[
port2
]
)
;
self
.
waitForMessage
=
(
sentMessage
)
=
>
{
return
new
Promise
(
resolve
=
>
{
port1
.
addEventListener
(
'
message
'
(
event
)
=
>
{
resolve
(
event
.
data
)
;
}
)
;
port1
.
postMessage
(
sentMessage
)
;
}
)
;
}
;
}
)
;
await
assertBFCacheEligibility
(
rc1
true
)
;
assert_equals
(
await
rc1
.
executeScript
(
async
(
)
=
>
await
self
.
waitForMessage
(
'
Confirm
the
ports
can
communicate
'
)
)
'
Receive
message
'
)
;
assert_false
(
await
rc1
.
executeScript
(
async
(
)
=
>
await
self
.
waitForMessage
(
'
Ask
if
the
close
event
was
fired
'
)
)
)
;
}
'
MessagePort
still
works
after
the
page
is
restored
from
BFCache
'
)
;
