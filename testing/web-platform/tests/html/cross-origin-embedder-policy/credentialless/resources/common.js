const
directory
=
'
/
html
/
cross
-
origin
-
embedder
-
policy
/
credentialless
'
;
const
executor_path
=
directory
+
'
/
resources
/
executor
.
html
?
pipe
=
'
;
const
executor_js_path
=
directory
+
'
/
resources
/
executor
.
js
?
pipe
=
'
;
const
coep_none
=
'
|
header
(
Cross
-
Origin
-
Embedder
-
Policy
none
)
'
;
const
coep_credentialless
=
'
|
header
(
Cross
-
Origin
-
Embedder
-
Policy
credentialless
)
'
;
const
coep_require_corp
=
'
|
header
(
Cross
-
Origin
-
Embedder
-
Policy
require
-
corp
)
'
;
const
coep_report_only_credentialless
=
'
|
header
(
Cross
-
Origin
-
Embedder
-
Policy
-
Report
-
Only
credentialless
)
'
;
const
coop_same_origin
=
'
|
header
(
Cross
-
Origin
-
Opener
-
Policy
same
-
origin
)
'
;
const
corp_cross_origin
=
'
|
header
(
Cross
-
Origin
-
Resource
-
Policy
cross
-
origin
)
'
;
let
promise_test_parallel
=
(
promise
description
)
=
>
{
async_test
(
test
=
>
{
promise
(
test
)
.
then
(
(
)
=
>
test
.
done
(
)
)
.
catch
(
test
.
step_func
(
error
=
>
{
throw
error
;
}
)
)
;
}
description
)
;
}
;
const
setCookie
=
async
(
origin
cookie_key
cookie_value
)
=
>
{
const
popup_token
=
token
(
)
;
const
popup_url
=
origin
+
executor_path
+
&
uuid
=
{
popup_token
}
;
const
popup
=
window
.
open
(
popup_url
)
;
const
reply_token
=
token
(
)
;
send
(
popup_token
document
.
cookie
=
"
{
cookie_key
}
=
{
cookie_value
}
"
;
send
(
"
{
reply_token
}
"
"
done
"
)
;
)
;
assert_equals
(
await
receive
(
reply_token
)
"
done
"
)
;
popup
.
close
(
)
;
}
let
parseCookies
=
function
(
headers_json
)
{
if
(
!
headers_json
[
"
cookie
"
]
)
return
{
}
;
return
headers_json
[
"
cookie
"
]
.
split
(
'
;
'
)
.
map
(
v
=
>
v
.
split
(
'
=
'
)
)
.
reduce
(
(
acc
v
)
=
>
{
acc
[
v
[
0
]
]
=
v
[
1
]
;
return
acc
;
}
{
}
)
;
}
const
newCredentiallessWindow
=
(
origin
)
=
>
{
const
main_document_token
=
token
(
)
;
const
url
=
origin
+
executor_path
+
coep_credentialless
+
&
uuid
=
{
main_document_token
}
;
const
context
=
window
.
open
(
url
)
;
add_completion_callback
(
(
)
=
>
w
.
close
(
)
)
;
return
main_document_token
;
}
;
const
newCredentiallessIframe
=
(
parent_token
child_origin
)
=
>
{
const
sub_document_token
=
token
(
)
;
const
iframe_url
=
child_origin
+
executor_path
+
coep_credentialless
+
&
uuid
=
{
sub_document_token
}
;
send
(
parent_token
let
iframe
=
document
.
createElement
(
"
iframe
"
)
;
iframe
.
src
=
"
{
iframe_url
}
"
;
document
.
body
.
appendChild
(
iframe
)
;
)
return
sub_document_token
;
}
;
const
environments
=
{
document
:
headers
=
>
{
const
tok
=
token
(
)
;
const
url
=
window
.
origin
+
executor_path
+
headers
+
&
uuid
=
{
tok
}
;
const
context
=
window
.
open
(
url
)
;
add_completion_callback
(
(
)
=
>
context
.
close
(
)
)
;
return
tok
;
}
dedicated_worker
:
headers
=
>
{
const
tok
=
token
(
)
;
const
url
=
window
.
origin
+
executor_js_path
+
headers
+
&
uuid
=
{
tok
}
;
const
context
=
new
Worker
(
url
)
;
return
tok
;
}
shared_worker
:
headers
=
>
{
const
tok
=
token
(
)
;
const
url
=
window
.
origin
+
executor_js_path
+
headers
+
&
uuid
=
{
tok
}
;
const
context
=
new
SharedWorker
(
url
)
;
return
tok
;
}
service_worker
:
headers
=
>
{
const
tok
=
token
(
)
;
const
url
=
window
.
origin
+
executor_js_path
+
headers
+
&
uuid
=
{
tok
}
;
const
scope
=
url
;
navigator
.
serviceWorker
.
register
(
url
{
scope
:
scope
}
)
.
then
(
registration
=
>
{
add_completion_callback
(
(
)
=
>
registration
.
unregister
(
)
)
;
}
)
;
return
tok
;
}
}
;
