const
same_origin
=
get_host_info
(
)
.
HTTPS_ORIGIN
;
const
cross_origin
=
get_host_info
(
)
.
HTTPS_REMOTE_ORIGIN
;
const
cookie_key
=
token
(
)
;
const
cookie_same_origin
=
"
same_origin
"
;
const
cookie_cross_origin
=
"
cross_origin
"
;
const
variants
=
new
URLSearchParams
(
window
.
location
.
search
)
;
const
window_dip
=
variants
.
get
(
'
window_dip
'
)
=
=
'
none
'
?
dip_none
:
dip_credentialless
;
const
worker_dip
=
variants
.
get
(
'
worker_dip
'
)
=
=
'
none
'
?
dip_none
:
dip_credentialless
;
const
request_origin
=
variants
.
get
(
'
request_origin
'
)
=
=
'
same
-
origin
'
?
same_origin
:
cross_origin
;
const
worker_expected_cookie
=
request_origin
=
=
same_origin
?
cookie_same_origin
:
(
worker_dip
=
=
dip_credentialless
?
undefined
:
cookie_cross_origin
)
;
const
get_cookie
=
(
response
)
=
>
{
const
headers_credentialless
=
JSON
.
parse
(
response
)
;
return
parseCookies
(
headers_credentialless
)
[
cookie_key
]
;
}
promise_test
(
async
test
=
>
{
await
Promise
.
all
(
[
setCookie
(
same_origin
cookie_key
cookie_same_origin
+
cookie_same_site_none
)
setCookie
(
cross_origin
cookie_key
cookie_cross_origin
+
cookie_same_site_none
)
]
)
;
const
popup
=
environments
.
document
(
window_dip
)
[
0
]
;
const
worker_token
=
token
(
)
;
const
worker_error
=
token
(
)
;
const
worker_src
=
same_origin
+
executor_worker_path
+
worker_dip
+
&
uuid
=
{
worker_token
}
;
send
(
popup
let
worker
=
new
SharedWorker
(
"
{
worker_src
}
"
{
}
)
;
worker
.
onerror
=
(
)
=
>
{
send
(
"
{
worker_error
}
"
"
Worker
blocked
"
)
;
}
)
;
const
request_token
=
token
(
)
;
const
request_url
=
showRequestHeaders
(
request_origin
request_token
)
;
send
(
worker_token
fetch
(
"
{
request_url
}
"
{
mode
:
'
no
-
cors
'
credentials
:
'
include
'
}
)
)
;
const
request_cookie
=
await
Promise
.
race
(
[
receive
(
worker_error
)
receive
(
request_token
)
.
then
(
get_cookie
)
]
)
;
assert_equals
(
request_cookie
worker_expected_cookie
)
;
}
)
