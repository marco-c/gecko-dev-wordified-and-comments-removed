ReflectionTests
=
{
}
;
ReflectionTests
.
start
=
new
Date
(
)
.
getTime
(
)
;
ReflectionTests
.
resolveUrl
=
function
(
url
)
{
url
=
String
(
url
)
;
var
el
=
document
.
createElement
(
"
a
"
)
;
el
.
href
=
url
;
var
ret
=
el
.
protocol
+
"
/
/
"
+
el
.
host
+
el
.
pathname
+
el
.
search
+
el
.
hash
;
if
(
ret
=
=
"
/
/
"
)
{
return
url
;
}
else
{
return
ret
;
}
}
;
ReflectionTests
.
parseNonneg
=
function
(
input
)
{
var
value
=
this
.
parseInt
(
input
)
;
if
(
value
=
=
=
false
|
|
value
<
0
)
{
return
false
;
}
return
value
;
}
;
ReflectionTests
.
parseInt
=
function
(
input
)
{
var
position
=
0
;
var
sign
=
1
;
while
(
input
.
length
>
position
&
&
/
^
[
\
t
\
n
\
f
\
r
]
/
.
test
(
input
[
position
]
)
)
{
position
+
+
;
}
if
(
position
>
=
input
.
length
)
{
return
false
;
}
if
(
input
[
position
]
=
=
"
-
"
)
{
sign
=
-
1
;
position
+
+
;
}
else
if
(
input
[
position
]
=
=
"
+
"
)
{
position
+
+
;
}
if
(
position
>
=
input
.
length
)
{
return
false
;
}
if
(
!
/
^
[
0
-
9
]
/
.
test
(
input
[
position
]
)
)
{
return
false
;
}
var
value
=
0
;
while
(
input
.
length
>
position
&
&
/
^
[
0
-
9
]
/
.
test
(
input
[
position
]
)
)
{
value
*
=
10
;
value
+
=
input
.
charCodeAt
(
position
)
-
"
0
"
.
charCodeAt
(
0
)
;
position
+
+
;
}
if
(
value
=
=
=
0
)
{
return
0
;
}
return
sign
*
value
;
}
;
ReflectionTests
.
parseFloat
=
function
(
input
)
{
var
position
=
0
;
var
value
=
1
;
var
divisor
=
1
;
var
exponent
=
1
;
while
(
input
.
length
>
position
&
&
/
^
[
\
t
\
n
\
f
\
r
]
/
.
test
(
input
[
position
]
)
)
{
position
+
+
;
}
if
(
position
>
=
input
.
length
)
{
return
false
;
}
if
(
input
[
position
]
=
=
"
-
"
)
{
value
=
-
1
;
divisor
=
-
1
;
position
+
+
;
}
else
if
(
input
[
position
]
=
=
"
+
"
)
{
position
+
+
;
}
if
(
position
>
=
input
.
length
)
{
return
false
;
}
if
(
input
[
position
]
=
=
"
.
"
&
&
position
+
1
<
input
.
length
&
&
/
^
[
0
-
9
]
/
.
test
(
input
[
position
+
1
]
)
)
{
value
=
0
;
}
else
if
(
!
/
^
[
0
-
9
]
/
.
test
(
input
[
position
]
)
)
{
return
false
;
}
else
{
var
val
=
0
;
while
(
input
.
length
>
position
&
&
/
^
[
0
-
9
]
/
.
test
(
input
[
position
]
)
)
{
val
*
=
10
;
val
+
=
input
.
charCodeAt
(
position
)
-
"
0
"
.
charCodeAt
(
0
)
;
position
+
+
;
}
value
*
=
val
;
}
if
(
input
.
length
>
position
&
&
input
[
position
]
=
=
"
.
"
)
{
position
+
+
;
while
(
input
.
length
>
position
&
&
/
^
[
0
-
9
]
/
.
test
(
input
[
position
]
)
)
{
divisor
*
=
10
;
value
+
=
(
input
.
charCodeAt
(
position
)
-
"
0
"
.
charCodeAt
(
0
)
)
/
divisor
;
position
+
+
;
}
}
if
(
input
.
length
>
position
&
&
(
input
[
position
]
=
=
"
e
"
|
|
input
[
position
]
=
=
"
E
"
)
)
{
position
+
+
;
if
(
input
.
length
>
position
)
{
if
(
input
[
position
]
=
=
"
-
"
)
{
exponent
=
-
1
;
position
+
+
;
}
else
if
(
input
[
position
]
=
=
"
+
"
)
{
position
+
+
;
}
if
(
input
.
length
>
position
&
&
/
^
[
0
-
9
]
/
.
test
(
input
[
position
]
)
)
{
var
exp
=
0
;
do
{
exp
*
=
10
;
exp
+
=
input
.
charCodeAt
(
position
)
-
"
0
"
.
charCodeAt
(
0
)
;
position
+
+
;
}
while
(
input
.
length
>
position
&
&
/
^
[
0
-
9
]
/
.
test
(
input
[
position
]
)
)
;
exponent
*
=
exp
;
value
*
=
Math
.
pow
(
10
exponent
)
;
}
}
}
if
(
!
Number
.
isFinite
(
value
)
)
{
return
false
;
}
if
(
value
=
=
=
0
)
{
return
0
;
}
return
value
;
}
var
binaryString
=
"
\
x00
\
x01
\
x02
\
x03
\
x04
\
x05
\
x06
\
x07
"
+
"
\
x08
\
x09
\
x0a
\
x0b
\
x0c
\
x0d
\
x0e
\
x0f
"
+
"
\
x10
\
x11
\
x12
\
x13
\
x14
\
x15
\
x16
\
x17
"
+
"
\
x18
\
x19
\
x1a
\
x1b
\
x1c
\
x1d
\
x1e
\
x1f
"
;
var
maxInt
=
2147483647
;
var
minInt
=
-
2147483648
;
var
maxUnsigned
=
4294967295
;
ReflectionTests
.
typeMap
=
{
"
string
"
:
{
"
jsType
"
:
"
string
"
"
defaultVal
"
:
"
"
"
domTests
"
:
[
"
"
"
"
+
binaryString
+
"
foo
"
undefined
7
1
.
5
"
5
%
"
"
+
100
"
"
.
5
"
true
false
{
"
test
"
:
6
}
NaN
+
Infinity
-
Infinity
"
\
0
"
null
{
"
toString
"
:
function
(
)
{
return
"
test
-
toString
"
;
}
}
{
"
valueOf
"
:
function
(
)
{
return
"
test
-
valueOf
"
;
}
toString
:
null
}
]
}
"
url
"
:
{
"
jsType
"
:
"
string
"
"
defaultVal
"
:
"
"
"
domTests
"
:
[
"
"
"
foo
"
"
http
:
/
/
site
.
example
/
"
"
/
/
site
.
example
/
path
?
?
?
#
l
"
binaryString
undefined
7
1
.
5
"
5
%
"
"
+
100
"
"
.
5
"
true
false
{
"
test
"
:
6
}
NaN
+
Infinity
-
Infinity
"
\
0
"
null
{
"
toString
"
:
function
(
)
{
return
"
test
-
toString
"
;
}
}
{
"
valueOf
"
:
function
(
)
{
return
"
test
-
valueOf
"
;
}
toString
:
null
}
]
"
domExpected
"
:
ReflectionTests
.
resolveUrl
"
idlIdlExpected
"
:
ReflectionTests
.
resolveUrl
}
"
enum
"
:
{
"
jsType
"
:
"
string
"
"
defaultVal
"
:
"
"
"
domTests
"
:
[
"
"
"
"
+
binaryString
+
"
foo
"
undefined
7
1
.
5
"
5
%
"
"
+
100
"
"
.
5
"
true
false
{
"
test
"
:
6
}
NaN
+
Infinity
-
Infinity
"
\
0
"
null
{
"
toString
"
:
function
(
)
{
return
"
test
-
toString
"
;
}
}
{
"
valueOf
"
:
function
(
)
{
return
"
test
-
valueOf
"
;
}
toString
:
null
}
]
}
"
boolean
"
:
{
"
jsType
"
:
"
boolean
"
"
defaultVal
"
:
false
"
domTests
"
:
[
"
"
"
foo
"
undefined
null
7
1
.
5
"
5
%
"
"
+
100
"
"
.
5
"
true
false
{
"
test
"
:
6
}
NaN
+
Infinity
-
Infinity
"
\
0
"
{
"
toString
"
:
function
(
)
{
return
"
test
-
toString
"
;
}
}
{
"
valueOf
"
:
function
(
)
{
return
"
test
-
valueOf
"
;
}
toString
:
null
}
]
"
domExpected
"
:
function
(
val
)
{
return
true
;
}
}
"
long
"
:
{
"
jsType
"
:
"
number
"
"
defaultVal
"
:
0
"
domTests
"
:
[
-
36
-
1
0
1
maxInt
minInt
maxInt
+
1
minInt
-
1
maxUnsigned
maxUnsigned
+
1
"
"
"
-
"
"
+
"
"
-
1
"
"
-
0
"
"
0
"
"
1
"
"
"
+
binaryString
+
"
foo
"
"
\
u00097
"
"
\
u000B7
"
"
\
u000C7
"
"
\
u00207
"
"
\
u00A07
"
"
\
uFEFF7
"
"
\
u000A7
"
"
\
u000D7
"
"
\
u20287
"
"
\
u20297
"
"
\
u16807
"
"
\
u180E7
"
"
\
u20007
"
"
\
u20017
"
"
\
u20027
"
"
\
u20037
"
"
\
u20047
"
"
\
u20057
"
"
\
u20067
"
"
\
u20077
"
"
\
u20087
"
"
\
u20097
"
"
\
u200A7
"
"
\
u202F7
"
"
\
u30007
"
"
\
t
\
u000B7
"
"
\
n
\
u000B7
"
"
\
f
\
u000B7
"
"
\
r
\
u000B7
"
"
\
x20
\
u000B7
"
"
7
\
u000B
"
undefined
1
.
5
"
5
%
"
"
+
100
"
"
.
5
"
true
false
{
"
test
"
:
6
}
NaN
+
Infinity
-
Infinity
"
\
0
"
{
toString
:
function
(
)
{
return
2
;
}
valueOf
:
null
}
{
valueOf
:
function
(
)
{
return
3
;
}
toString
:
null
}
]
"
domExpected
"
:
function
(
val
)
{
var
parsed
=
ReflectionTests
.
parseInt
(
String
(
val
)
)
;
if
(
parsed
=
=
=
false
|
|
parsed
>
maxInt
|
|
parsed
<
minInt
)
{
return
null
;
}
return
parsed
;
}
"
idlTests
"
:
[
-
36
-
1
0
1
2147483647
-
2147483648
]
"
idlDomExpected
"
:
[
-
36
-
1
0
1
2147483647
-
2147483648
]
}
"
limited
long
"
:
{
"
jsType
"
:
"
number
"
"
defaultVal
"
:
-
1
"
domTests
"
:
[
minInt
-
1
minInt
-
36
-
1
-
0
0
1
maxInt
maxInt
+
1
maxUnsigned
maxUnsigned
+
1
"
"
"
-
"
"
+
"
"
-
1
"
"
-
0
"
"
0
"
"
1
"
"
"
+
binaryString
+
"
foo
"
"
\
u00097
"
"
\
u000B7
"
"
\
u000C7
"
"
\
u00207
"
"
\
u00A07
"
"
\
uFEFF7
"
"
\
u000A7
"
"
\
u000D7
"
"
\
u20287
"
"
\
u20297
"
"
\
u16807
"
"
\
u180E7
"
"
\
u20007
"
"
\
u20017
"
"
\
u20027
"
"
\
u20037
"
"
\
u20047
"
"
\
u20057
"
"
\
u20067
"
"
\
u20077
"
"
\
u20087
"
"
\
u20097
"
"
\
u200A7
"
"
\
u202F7
"
"
\
u30007
"
"
\
t
\
u000B7
"
"
\
n
\
u000B7
"
"
\
f
\
u000B7
"
"
\
r
\
u000B7
"
"
\
x20
\
u000B7
"
"
7
\
u000B
"
undefined
1
.
5
"
5
%
"
"
+
100
"
"
.
5
"
true
false
{
"
test
"
:
6
}
NaN
+
Infinity
-
Infinity
"
\
0
"
{
toString
:
function
(
)
{
return
2
;
}
valueOf
:
null
}
{
valueOf
:
function
(
)
{
return
3
;
}
toString
:
null
}
]
"
domExpected
"
:
function
(
val
)
{
var
parsed
=
ReflectionTests
.
parseNonneg
(
String
(
val
)
)
;
if
(
parsed
=
=
=
false
|
|
parsed
>
maxInt
|
|
parsed
<
minInt
)
{
return
null
;
}
return
parsed
;
}
"
idlTests
"
:
[
minInt
-
36
-
1
0
1
maxInt
]
"
idlDomExpected
"
:
[
null
null
null
0
1
maxInt
]
}
"
unsigned
long
"
:
{
"
jsType
"
:
"
number
"
"
defaultVal
"
:
0
"
domTests
"
:
[
minInt
-
1
minInt
-
36
-
1
0
1
257
maxInt
maxInt
+
1
maxUnsigned
maxUnsigned
+
1
"
"
"
-
"
"
+
"
"
-
1
"
"
-
0
"
"
0
"
"
1
"
"
\
u00097
"
"
\
u000B7
"
"
\
u000C7
"
"
\
u00207
"
"
\
u00A07
"
"
\
uFEFF7
"
"
\
u000A7
"
"
\
u000D7
"
"
\
u20287
"
"
\
u20297
"
"
\
u16807
"
"
\
u180E7
"
"
\
u20007
"
"
\
u20017
"
"
\
u20027
"
"
\
u20037
"
"
\
u20047
"
"
\
u20057
"
"
\
u20067
"
"
\
u20077
"
"
\
u20087
"
"
\
u20097
"
"
\
u200A7
"
"
\
u202F7
"
"
\
u30007
"
"
\
t
\
u000B7
"
"
\
n
\
u000B7
"
"
\
f
\
u000B7
"
"
\
r
\
u000B7
"
"
\
x20
\
u000B7
"
"
7
\
u000B
"
"
"
+
binaryString
+
"
foo
"
undefined
1
.
5
"
5
%
"
"
+
100
"
"
.
5
"
true
false
{
"
test
"
:
6
}
NaN
+
Infinity
-
Infinity
"
\
0
"
{
toString
:
function
(
)
{
return
2
;
}
valueOf
:
null
}
{
valueOf
:
function
(
)
{
return
3
;
}
toString
:
null
}
]
"
domExpected
"
:
function
(
val
)
{
var
parsed
=
ReflectionTests
.
parseNonneg
(
String
(
val
)
)
;
if
(
parsed
=
=
=
false
|
|
parsed
<
0
|
|
parsed
>
maxInt
)
{
return
null
;
}
return
parsed
;
}
"
idlTests
"
:
[
0
1
257
maxInt
"
-
0
"
maxInt
+
1
maxUnsigned
]
"
idlIdlExpected
"
:
[
0
1
257
maxInt
0
null
null
]
"
idlDomExpected
"
:
[
0
1
257
maxInt
0
null
null
]
}
"
limited
unsigned
long
"
:
{
"
jsType
"
:
"
number
"
"
defaultVal
"
:
1
"
domTests
"
:
[
minInt
-
1
minInt
-
36
-
1
0
1
maxInt
maxInt
+
1
maxUnsigned
maxUnsigned
+
1
"
"
"
-
"
"
+
"
"
-
1
"
"
-
0
"
"
0
"
"
1
"
"
\
u00097
"
"
\
u000B7
"
"
\
u000C7
"
"
\
u00207
"
"
\
u00A07
"
"
\
uFEFF7
"
"
\
u000A7
"
"
\
u000D7
"
"
\
u20287
"
"
\
u20297
"
"
\
u16807
"
"
\
u180E7
"
"
\
u20007
"
"
\
u20017
"
"
\
u20027
"
"
\
u20037
"
"
\
u20047
"
"
\
u20057
"
"
\
u20067
"
"
\
u20077
"
"
\
u20087
"
"
\
u20097
"
"
\
u200A7
"
"
\
u202F7
"
"
\
u30007
"
"
\
t
\
u000B7
"
"
\
n
\
u000B7
"
"
\
f
\
u000B7
"
"
\
r
\
u000B7
"
"
\
x20
\
u000B7
"
"
7
\
u000B
"
"
"
+
binaryString
+
"
foo
"
undefined
1
.
5
"
5
%
"
"
+
100
"
"
.
5
"
true
false
{
"
test
"
:
6
}
NaN
+
Infinity
-
Infinity
"
\
0
"
{
toString
:
function
(
)
{
return
2
;
}
valueOf
:
null
}
{
valueOf
:
function
(
)
{
return
3
;
}
toString
:
null
}
]
"
domExpected
"
:
function
(
val
)
{
var
parsed
=
ReflectionTests
.
parseNonneg
(
String
(
val
)
)
;
if
(
parsed
=
=
=
false
|
|
parsed
<
1
|
|
parsed
>
maxInt
)
{
return
null
;
}
return
parsed
;
}
"
idlTests
"
:
[
0
1
maxInt
maxInt
+
1
maxUnsigned
]
"
idlDomExpected
"
:
[
null
1
maxInt
null
null
]
}
"
limited
unsigned
long
with
fallback
"
:
{
"
jsType
"
:
"
number
"
"
domTests
"
:
[
minInt
-
1
minInt
-
36
-
1
0
1
maxInt
maxInt
+
1
maxUnsigned
maxUnsigned
+
1
"
"
"
-
"
"
+
"
"
-
1
"
"
-
0
"
"
0
"
"
1
"
"
\
u00097
"
"
\
u000B7
"
"
\
u000C7
"
"
\
u00207
"
"
\
u00A07
"
"
\
uFEFF7
"
"
\
u000A7
"
"
\
u000D7
"
"
\
u20287
"
"
\
u20297
"
"
\
u16807
"
"
\
u180E7
"
"
\
u20007
"
"
\
u20017
"
"
\
u20027
"
"
\
u20037
"
"
\
u20047
"
"
\
u20057
"
"
\
u20067
"
"
\
u20077
"
"
\
u20087
"
"
\
u20097
"
"
\
u200A7
"
"
\
u202F7
"
"
\
u30007
"
"
\
t
\
u000B7
"
"
\
n
\
u000B7
"
"
\
f
\
u000B7
"
"
\
r
\
u000B7
"
"
\
x20
\
u000B7
"
"
7
\
u000B
"
"
"
+
binaryString
+
"
foo
"
undefined
1
.
5
"
5
%
"
"
+
100
"
"
.
5
"
true
false
{
"
test
"
:
6
}
NaN
+
Infinity
-
Infinity
"
\
0
"
{
toString
:
function
(
)
{
return
2
;
}
valueOf
:
null
}
{
valueOf
:
function
(
)
{
return
3
;
}
toString
:
null
}
]
"
domExpected
"
:
function
(
val
)
{
var
parsed
=
ReflectionTests
.
parseNonneg
(
String
(
val
)
)
;
if
(
parsed
=
=
=
false
|
|
parsed
<
1
|
|
parsed
>
maxInt
)
{
return
null
;
}
return
parsed
;
}
"
idlTests
"
:
[
0
1
maxInt
maxInt
+
1
maxUnsigned
]
"
idlDomExpected
"
:
[
null
1
maxInt
null
null
]
}
"
clamped
unsigned
long
"
:
{
"
jsType
"
:
"
number
"
"
domTests
"
:
[
minInt
-
1
minInt
-
36
-
1
0
1
maxInt
maxInt
+
1
maxUnsigned
maxUnsigned
+
1
"
"
"
-
"
"
+
"
"
-
1
"
"
-
0
"
"
0
"
"
1
"
"
\
u00097
"
"
\
u000B7
"
"
\
u000C7
"
"
\
u00207
"
"
\
u00A07
"
"
\
uFEFF7
"
"
\
u000A7
"
"
\
u000D7
"
"
\
u20287
"
"
\
u20297
"
"
\
u16807
"
"
\
u180E7
"
"
\
u20007
"
"
\
u20017
"
"
\
u20027
"
"
\
u20037
"
"
\
u20047
"
"
\
u20057
"
"
\
u20067
"
"
\
u20077
"
"
\
u20087
"
"
\
u20097
"
"
\
u200A7
"
"
\
u202F7
"
"
\
u30007
"
"
\
t
\
u000B7
"
"
\
n
\
u000B7
"
"
\
f
\
u000B7
"
"
\
r
\
u000B7
"
"
\
x20
\
u000B7
"
"
7
\
u000B
"
"
"
+
binaryString
+
"
foo
"
undefined
1
.
5
"
5
%
"
"
+
100
"
"
.
5
"
true
false
{
"
test
"
:
6
}
NaN
+
Infinity
-
Infinity
"
\
0
"
{
toString
:
function
(
)
{
return
2
;
}
valueOf
:
null
}
{
valueOf
:
function
(
)
{
return
3
;
}
toString
:
null
}
]
"
idlTests
"
:
[
0
1
257
maxInt
"
-
0
"
maxInt
+
1
maxUnsigned
]
"
idlDomExpected
"
:
[
0
1
257
maxInt
0
null
null
]
}
"
double
"
:
{
"
jsType
"
:
"
number
"
"
defaultVal
"
:
0
.
0
"
domTests
"
:
[
minInt
-
1
minInt
-
36
-
1
0
1
maxInt
maxInt
+
1
maxUnsigned
maxUnsigned
+
1
"
"
"
-
"
"
+
"
"
\
u00097
"
"
\
u000B7
"
"
\
u000C7
"
"
\
u00207
"
"
\
u00A07
"
"
\
uFEFF7
"
"
\
u000A7
"
"
\
u000D7
"
"
\
u20287
"
"
\
u20297
"
"
\
u16807
"
"
\
u180E7
"
"
\
u20007
"
"
\
u20017
"
"
\
u20027
"
"
\
u20037
"
"
\
u20047
"
"
\
u20057
"
"
\
u20067
"
"
\
u20077
"
"
\
u20087
"
"
\
u20097
"
"
\
u200A7
"
"
\
u202F7
"
"
\
u30007
"
"
\
t
\
u000B7
"
"
\
n
\
u000B7
"
"
\
f
\
u000B7
"
"
\
r
\
u000B7
"
"
\
x20
\
u000B7
"
"
7
\
u000B
"
"
"
+
binaryString
+
"
foo
"
undefined
1
.
5
"
5
%
"
"
+
100
"
"
.
5
"
true
false
"
1
.
"
"
1e2
"
"
1e
+
2
"
"
1e
-
2
"
"
1E2
"
"
1E
+
2
"
"
1E
-
2
"
"
1
.
e2
"
"
1
.
0e2
"
"
1
.
1
"
"
1
.
1
"
"
1
.
e2
"
"
1
.
e2
"
"
1
e2
"
"
1e
2
"
"
1e
-
2
"
"
1e
-
2
"
"
1
.
8e308
"
"
-
1
.
8e308
"
{
"
test
"
:
6
}
NaN
+
Infinity
-
Infinity
"
\
0
"
{
toString
:
function
(
)
{
return
2
;
}
valueOf
:
null
}
{
valueOf
:
function
(
)
{
return
3
;
}
toString
:
null
}
]
"
domExpected
"
:
function
(
val
)
{
var
parsed
=
ReflectionTests
.
parseFloat
(
String
(
val
)
)
;
if
(
parsed
=
=
=
false
)
{
return
null
;
}
return
parsed
;
}
"
idlTests
"
:
[
-
10000000000
-
1
-
0
0
1
10000000000
1e
-
10
1e
-
4
1
.
5
1e25
]
"
idlIdlExpected
"
:
function
(
val
)
{
return
ReflectionTests
.
parseFloat
(
String
(
val
)
)
;
}
}
"
limited
double
"
:
{
"
jsType
"
:
"
number
"
"
defaultVal
"
:
0
.
0
"
domTests
"
:
[
minInt
-
1
minInt
-
36
-
1
0
1
maxInt
maxInt
+
1
maxUnsigned
maxUnsigned
+
1
"
"
"
-
"
"
+
"
"
\
u00097
"
"
\
u000B7
"
"
\
u000C7
"
"
\
u00207
"
"
\
u00A07
"
"
\
uFEFF7
"
"
\
u000A7
"
"
\
u000D7
"
"
\
u20287
"
"
\
u20297
"
"
\
u16807
"
"
\
u180E7
"
"
\
u20007
"
"
\
u20017
"
"
\
u20027
"
"
\
u20037
"
"
\
u20047
"
"
\
u20057
"
"
\
u20067
"
"
\
u20077
"
"
\
u20087
"
"
\
u20097
"
"
\
u200A7
"
"
\
u202F7
"
"
\
u30007
"
"
\
t
\
u000B7
"
"
\
n
\
u000B7
"
"
\
f
\
u000B7
"
"
\
r
\
u000B7
"
"
\
x20
\
u000B7
"
"
7
\
u000B
"
"
"
+
binaryString
+
"
foo
"
undefined
1
.
5
"
5
%
"
"
+
100
"
"
.
5
"
true
false
"
1
.
"
"
1e2
"
"
1e
+
2
"
"
1e
-
2
"
"
1E2
"
"
1E
+
2
"
"
1E
-
2
"
"
1
.
e2
"
"
1
.
0e2
"
"
1
.
1
"
"
1
.
1
"
"
1
.
e2
"
"
1
.
e2
"
"
1
e2
"
"
1e
2
"
"
1e
-
2
"
"
1e
-
2
"
"
1
.
8e308
"
"
-
1
.
8e308
"
{
"
test
"
:
6
}
NaN
+
Infinity
-
Infinity
"
\
0
"
{
toString
:
function
(
)
{
return
2
;
}
valueOf
:
null
}
{
valueOf
:
function
(
)
{
return
3
;
}
toString
:
null
}
]
"
domExpected
"
:
function
(
val
)
{
var
parsed
=
ReflectionTests
.
parseFloat
(
String
(
val
)
)
;
if
(
parsed
=
=
=
false
|
|
parsed
<
=
0
)
{
return
null
;
}
return
parsed
;
}
"
idlTests
"
:
[
-
10000000000
-
1
-
0
0
1
10000000000
1e
-
10
1e
-
4
1
.
5
1e25
]
"
idlIdlExpected
"
:
function
(
val
)
{
return
ReflectionTests
.
parseFloat
(
String
(
val
)
)
;
}
}
}
;
for
(
var
type
in
ReflectionTests
.
typeMap
)
{
var
props
=
ReflectionTests
.
typeMap
[
type
]
;
var
cast
=
window
[
props
.
jsType
[
0
]
.
toUpperCase
(
)
+
props
.
jsType
.
slice
(
1
)
]
;
if
(
props
.
domExpected
=
=
=
undefined
)
{
props
.
domExpected
=
props
.
domTests
.
map
(
cast
)
;
}
else
if
(
typeof
props
.
domExpected
=
=
"
function
"
)
{
props
.
domExpected
=
props
.
domTests
.
map
(
props
.
domExpected
)
;
}
if
(
props
.
idlTests
=
=
=
undefined
)
{
props
.
idlTests
=
props
.
domTests
;
}
if
(
props
.
idlDomExpected
=
=
=
undefined
)
{
props
.
idlDomExpected
=
props
.
idlTests
.
map
(
cast
)
;
}
else
if
(
typeof
props
.
idlDomExpected
=
=
"
function
"
)
{
props
.
idlDomExpected
=
props
.
idlTests
.
map
(
props
.
idlDomExpected
)
;
}
if
(
props
.
idlIdlExpected
=
=
=
undefined
)
{
props
.
idlIdlExpected
=
props
.
idlDomExpected
;
}
else
if
(
typeof
props
.
idlIdlExpected
=
=
"
function
"
)
{
props
.
idlIdlExpected
=
props
.
idlTests
.
map
(
props
.
idlIdlExpected
)
;
}
}
ReflectionTests
.
reflects
=
function
(
data
idlName
idlObj
domName
domObj
)
{
if
(
typeof
data
=
=
"
string
"
)
{
data
=
{
type
:
data
}
;
}
if
(
domName
=
=
=
undefined
)
{
domName
=
idlName
;
}
if
(
typeof
idlObj
=
=
"
string
"
)
{
idlObj
=
document
.
createElement
(
idlObj
)
;
}
if
(
domObj
=
=
=
undefined
)
{
domObj
=
idlObj
;
}
ReflectionHarness
.
currentTestInfo
=
{
data
:
data
idlName
:
idlName
idlObj
:
idlObj
domName
:
domName
domObj
:
domObj
}
;
if
(
this
.
typeMap
[
data
.
type
]
=
=
=
undefined
)
{
if
(
unimplemented
.
indexOf
(
data
.
type
)
=
=
-
1
)
{
unimplemented
.
push
(
data
.
type
)
;
}
return
;
}
var
typeInfo
=
this
.
typeMap
[
data
.
type
]
;
if
(
typeof
data
.
isNullable
=
=
"
undefined
"
)
{
data
.
isNullable
=
false
;
}
var
expectedType
=
data
.
isNullable
&
&
data
.
defaultVal
=
=
=
null
?
"
object
"
:
typeInfo
.
jsType
;
ReflectionHarness
.
test
(
function
(
)
{
ReflectionHarness
.
assertEquals
(
typeof
idlObj
[
idlName
]
expectedType
)
;
}
"
typeof
IDL
attribute
"
)
;
if
(
!
ReflectionHarness
.
conformanceTesting
&
&
typeof
idlObj
[
idlName
]
!
=
=
expectedType
)
{
return
;
}
var
defaultVal
=
data
.
defaultVal
;
if
(
defaultVal
=
=
=
undefined
)
{
defaultVal
=
typeInfo
.
defaultVal
;
}
if
(
(
domObj
.
localName
=
=
=
"
form
"
&
&
domName
=
=
=
"
action
"
)
|
|
(
[
"
button
"
"
input
"
]
.
includes
(
domObj
.
localName
)
&
&
domName
=
=
=
"
formAction
"
)
)
{
defaultVal
=
domObj
.
ownerDocument
.
URL
;
}
if
(
!
data
.
customGetter
&
&
(
defaultVal
!
=
=
null
|
|
data
.
isNullable
)
)
{
ReflectionHarness
.
test
(
function
(
)
{
ReflectionHarness
.
assertEquals
(
idlObj
[
idlName
]
defaultVal
)
;
}
"
IDL
get
with
DOM
attribute
unset
"
)
;
}
var
domTests
=
typeInfo
.
domTests
.
slice
(
0
)
;
var
domExpected
=
typeInfo
.
domExpected
.
map
(
function
(
val
)
{
return
val
=
=
=
null
?
defaultVal
:
val
;
}
)
;
var
idlTests
=
typeInfo
.
idlTests
.
slice
(
0
)
;
var
idlDomExpected
=
typeInfo
.
idlDomExpected
.
map
(
function
(
val
)
{
return
val
=
=
=
null
?
defaultVal
:
val
;
}
)
;
var
idlIdlExpected
=
typeInfo
.
idlIdlExpected
.
map
(
function
(
val
)
{
return
val
=
=
=
null
?
defaultVal
:
val
;
}
)
;
switch
(
data
.
type
)
{
case
"
boolean
"
:
domTests
.
push
(
domName
)
;
domExpected
.
push
(
true
)
;
break
;
case
"
enum
"
:
if
(
typeof
data
.
invalidVal
=
=
"
undefined
"
)
{
data
.
invalidVal
=
defaultVal
;
}
if
(
typeof
data
.
nonCanon
=
=
"
undefined
"
)
{
data
.
nonCanon
=
{
}
;
}
for
(
var
i
=
0
;
i
<
data
.
keywords
.
length
;
i
+
+
)
{
if
(
data
.
keywords
[
i
]
!
=
"
"
)
{
domTests
.
push
(
data
.
keywords
[
i
]
"
x
"
+
data
.
keywords
[
i
]
data
.
keywords
[
i
]
+
"
\
0
"
)
;
idlTests
.
push
(
data
.
keywords
[
i
]
"
x
"
+
data
.
keywords
[
i
]
data
.
keywords
[
i
]
+
"
\
0
"
)
;
}
if
(
data
.
keywords
[
i
]
.
length
>
1
)
{
var
sliced
=
data
.
keywords
[
i
]
.
slice
(
1
)
;
if
(
data
.
keywords
.
indexOf
(
sliced
)
=
=
-
1
)
{
domTests
.
push
(
sliced
)
;
idlTests
.
push
(
sliced
)
;
}
}
if
(
data
.
keywords
[
i
]
!
=
data
.
keywords
[
i
]
.
toLowerCase
(
)
)
{
domTests
.
push
(
data
.
keywords
[
i
]
.
toLowerCase
(
)
)
;
idlTests
.
push
(
data
.
keywords
[
i
]
.
toLowerCase
(
)
)
;
}
if
(
data
.
keywords
[
i
]
!
=
data
.
keywords
[
i
]
.
toUpperCase
(
)
)
{
domTests
.
push
(
data
.
keywords
[
i
]
.
toUpperCase
(
)
)
;
idlTests
.
push
(
data
.
keywords
[
i
]
.
toUpperCase
(
)
)
;
}
if
(
data
.
keywords
[
i
]
.
indexOf
(
"
k
"
)
!
=
-
1
)
{
domTests
.
push
(
data
.
keywords
[
i
]
.
replace
(
/
k
/
g
"
\
u212A
"
)
)
;
idlTests
.
push
(
data
.
keywords
[
i
]
.
replace
(
/
k
/
g
"
\
u212A
"
)
)
;
}
if
(
data
.
keywords
[
i
]
.
indexOf
(
"
s
"
)
!
=
-
1
)
{
domTests
.
push
(
data
.
keywords
[
i
]
.
replace
(
/
s
/
g
"
\
u017F
"
)
)
;
idlTests
.
push
(
data
.
keywords
[
i
]
.
replace
(
/
s
/
g
"
\
u017F
"
)
)
;
}
}
if
(
!
data
.
isNullable
)
{
idlDomExpected
=
idlTests
.
slice
(
0
)
;
}
else
{
idlDomExpected
=
[
]
;
for
(
var
i
=
0
;
i
<
idlTests
.
length
;
i
+
+
)
{
idlDomExpected
.
push
(
(
idlTests
[
i
]
=
=
=
null
|
|
idlTests
[
i
]
=
=
=
undefined
)
?
null
:
idlTests
[
i
]
)
;
}
}
domExpected
=
[
]
;
idlIdlExpected
=
[
]
;
for
(
var
i
=
0
;
i
<
domTests
.
length
;
i
+
+
)
{
domExpected
.
push
(
this
.
enumExpected
(
data
.
keywords
data
.
nonCanon
data
.
invalidVal
domTests
[
i
]
)
)
;
}
for
(
var
i
=
0
;
i
<
idlTests
.
length
;
i
+
+
)
{
if
(
data
.
isNullable
&
&
(
idlTests
[
i
]
=
=
=
null
|
|
idlTests
[
i
]
=
=
=
undefined
)
)
{
idlIdlExpected
.
push
(
null
)
;
}
else
{
idlIdlExpected
.
push
(
this
.
enumExpected
(
data
.
keywords
data
.
nonCanon
data
.
invalidVal
idlTests
[
i
]
)
)
;
}
}
break
;
case
"
string
"
:
if
(
"
treatNullAsEmptyString
"
in
data
)
{
for
(
var
i
=
0
;
i
<
idlTests
.
length
;
i
+
+
)
{
if
(
idlTests
[
i
]
=
=
=
null
)
{
idlDomExpected
[
i
]
=
idlIdlExpected
[
i
]
=
"
"
;
}
}
}
break
;
case
"
clamped
unsigned
long
"
:
[
data
.
min
-
1
data
.
min
data
.
max
data
.
max
+
1
]
.
forEach
(
function
(
val
)
{
if
(
domTests
.
indexOf
(
val
)
=
=
-
1
)
{
domTests
.
push
(
val
)
;
}
if
(
idlTests
.
indexOf
(
val
)
=
=
-
1
&
&
0
<
=
val
&
&
val
<
=
maxUnsigned
)
{
idlTests
.
push
(
val
)
;
if
(
typeof
val
!
=
"
number
"
)
{
val
=
ReflectionTests
.
parseNonneg
(
val
)
;
}
idlDomExpected
.
push
(
val
>
maxInt
?
null
:
val
)
;
}
}
)
;
domExpected
=
domTests
.
map
(
function
(
val
)
{
var
parsed
=
ReflectionTests
.
parseNonneg
(
String
(
val
)
)
;
if
(
parsed
=
=
=
false
)
{
return
defaultVal
;
}
if
(
parsed
<
data
.
min
)
{
return
data
.
min
;
}
if
(
parsed
>
data
.
max
)
{
return
data
.
max
;
}
return
parsed
;
}
)
;
idlIdlExpected
=
idlTests
.
map
(
function
(
val
)
{
if
(
typeof
val
!
=
"
number
"
)
{
val
=
ReflectionTests
.
parseNonneg
(
val
)
;
}
if
(
val
<
0
|
|
val
>
maxUnsigned
)
{
throw
"
Test
bug
:
val
should
be
an
unsigned
long
"
;
}
if
(
val
>
maxInt
)
{
return
defaultVal
;
}
if
(
val
<
data
.
min
)
{
return
data
.
min
;
}
if
(
val
>
data
.
max
)
{
return
data
.
max
;
}
return
val
;
}
)
;
break
;
}
if
(
domObj
.
tagName
.
toLowerCase
(
)
=
=
"
canvas
"
&
&
(
domName
=
=
"
width
"
|
|
domName
=
=
"
height
"
)
)
{
domTests
=
domTests
.
filter
(
function
(
element
index
array
)
{
return
domExpected
[
index
]
<
1000
;
}
)
;
domExpected
=
domExpected
.
filter
(
function
(
element
index
array
)
{
return
element
<
1000
;
}
)
;
idlTests
=
idlTests
.
filter
(
function
(
element
index
array
)
{
return
idlIdlExpected
[
index
]
<
1000
;
}
)
;
idlDomExpected
=
idlDomExpected
.
filter
(
function
(
element
index
array
)
{
return
idlIdlExpected
[
index
]
<
1000
;
}
)
;
idlIdlExpected
=
idlIdlExpected
.
filter
(
function
(
element
index
array
)
{
return
idlIdlExpected
[
index
]
<
1000
;
}
)
;
}
if
(
(
domObj
.
localName
=
=
=
"
form
"
&
&
domName
=
=
=
"
action
"
)
|
|
(
[
"
button
"
"
input
"
]
.
includes
(
domObj
.
localName
)
&
&
domName
=
=
=
"
formAction
"
)
)
{
for
(
var
i
=
0
;
i
<
domTests
.
length
;
i
+
+
)
{
if
(
domTests
[
i
]
=
=
=
"
"
)
{
domExpected
[
i
]
=
domObj
.
ownerDocument
.
URL
;
}
}
for
(
var
i
=
0
;
i
<
idlTests
.
length
;
i
+
+
)
{
if
(
idlTests
[
i
]
=
=
=
"
"
)
{
idlIdlExpected
[
i
]
=
domObj
.
ownerDocument
.
URL
;
}
}
}
if
(
data
.
customGetter
)
{
domTests
=
[
]
;
domExpected
=
[
]
;
idlIdlExpected
=
idlIdlExpected
.
map
(
(
)
=
>
null
)
;
}
for
(
var
i
=
0
;
i
<
domTests
.
length
;
i
+
+
)
{
if
(
domExpected
[
i
]
=
=
=
null
&
&
!
data
.
isNullable
)
{
continue
;
}
ReflectionHarness
.
test
(
function
(
)
{
domObj
.
setAttribute
(
domName
domTests
[
i
]
)
;
ReflectionHarness
.
assertEquals
(
domObj
.
getAttribute
(
domName
)
String
(
domTests
[
i
]
)
"
getAttribute
(
)
"
)
;
ReflectionHarness
.
assertEquals
(
idlObj
[
idlName
]
domExpected
[
i
]
"
IDL
get
"
)
;
}
"
setAttribute
(
)
to
"
+
ReflectionHarness
.
stringRep
(
domTests
[
i
]
)
)
;
}
for
(
var
i
=
0
;
i
<
idlTests
.
length
;
i
+
+
)
{
ReflectionHarness
.
test
(
function
(
)
{
if
(
(
data
.
type
=
=
"
limited
long
"
&
&
idlTests
[
i
]
<
0
)
|
|
(
data
.
type
=
=
"
limited
unsigned
long
"
&
&
idlTests
[
i
]
=
=
0
)
)
{
ReflectionHarness
.
assertThrows
(
"
IndexSizeError
"
function
(
)
{
idlObj
[
idlName
]
=
idlTests
[
i
]
;
}
)
;
}
else
if
(
data
.
type
=
=
"
limited
double
"
&
&
idlTests
[
i
]
<
=
0
)
{
domObj
.
setAttribute
(
domName
"
previous
value
"
)
;
var
previousIdl
=
idlObj
[
idlName
]
;
idlObj
[
idlName
]
=
idlTests
[
i
]
;
ReflectionHarness
.
assertEquals
(
domObj
.
getAttribute
(
domName
)
"
previous
value
"
"
getAttribute
(
)
"
)
;
ReflectionHarness
.
assertEquals
(
idlObj
[
idlName
]
previousIdl
"
IDL
get
"
)
;
}
else
{
idlObj
[
idlName
]
=
idlTests
[
i
]
;
if
(
data
.
type
=
=
"
boolean
"
)
{
ReflectionHarness
.
assertEquals
(
domObj
.
hasAttribute
(
domName
)
Boolean
(
idlTests
[
i
]
)
"
hasAttribute
(
)
"
)
;
}
else
if
(
idlDomExpected
[
i
]
!
=
=
null
|
|
data
.
isNullable
)
{
var
expected
=
idlDomExpected
[
i
]
+
"
"
;
if
(
data
.
isNullable
&
&
idlDomExpected
[
i
]
=
=
=
null
)
{
expected
=
null
;
}
ReflectionHarness
.
assertEquals
(
domObj
.
getAttribute
(
domName
)
expected
"
getAttribute
(
)
"
)
;
}
if
(
idlIdlExpected
[
i
]
!
=
=
null
|
|
data
.
isNullable
)
{
ReflectionHarness
.
assertEquals
(
idlObj
[
idlName
]
idlIdlExpected
[
i
]
"
IDL
get
"
)
;
}
}
}
"
IDL
set
to
"
+
ReflectionHarness
.
stringRep
(
idlTests
[
i
]
)
)
;
}
}
;
function
toASCIILowerCase
(
str
)
{
return
str
.
replace
(
/
[
A
-
Z
]
/
g
function
(
m
)
{
return
m
.
toLowerCase
(
)
;
}
)
;
}
ReflectionTests
.
enumExpected
=
function
(
keywords
nonCanon
invalidVal
contentVal
)
{
var
ret
=
invalidVal
;
for
(
var
i
=
0
;
i
<
keywords
.
length
;
i
+
+
)
{
if
(
toASCIILowerCase
(
String
(
contentVal
)
)
=
=
=
toASCIILowerCase
(
keywords
[
i
]
)
)
{
ret
=
keywords
[
i
]
;
break
;
}
}
if
(
typeof
nonCanon
[
ret
]
!
=
"
undefined
"
)
{
return
nonCanon
[
ret
]
;
}
return
ret
;
}
;
var
unimplemented
=
[
]
;
for
(
var
element
in
elements
)
{
ReflectionTests
.
reflects
(
"
string
"
"
title
"
element
)
;
ReflectionTests
.
reflects
(
"
string
"
"
lang
"
element
)
;
ReflectionTests
.
reflects
(
{
type
:
"
enum
"
keywords
:
[
"
ltr
"
"
rtl
"
"
auto
"
]
}
"
dir
"
element
)
;
ReflectionTests
.
reflects
(
"
string
"
"
className
"
element
"
class
"
)
;
ReflectionTests
.
reflects
(
"
tokenlist
"
"
classList
"
element
"
class
"
)
;
ReflectionTests
.
reflects
(
"
boolean
"
"
autofocus
"
element
)
;
ReflectionTests
.
reflects
(
"
boolean
"
"
hidden
"
element
)
;
ReflectionTests
.
reflects
(
"
string
"
"
accessKey
"
element
)
;
ReflectionTests
.
reflects
(
{
type
:
"
long
"
defaultVal
:
null
}
"
tabIndex
"
element
)
;
for
(
var
idlAttrName
in
elements
[
element
]
)
{
var
type
=
elements
[
element
]
[
idlAttrName
]
;
ReflectionTests
.
reflects
(
type
idlAttrName
element
typeof
type
=
=
"
object
"
&
&
"
domAttrName
"
in
type
?
type
.
domAttrName
:
idlAttrName
)
;
}
}
for
(
var
i
=
0
;
i
<
extraTests
.
length
;
i
+
+
)
{
extraTests
[
i
]
(
)
;
}
var
time
=
document
.
getElementById
(
"
time
"
)
;
if
(
time
)
{
time
.
innerHTML
=
(
new
Date
(
)
.
getTime
(
)
-
ReflectionTests
.
start
)
/
1000
;
}
if
(
unimplemented
.
length
)
{
var
p
=
document
.
createElement
(
"
p
"
)
;
p
.
textContent
=
"
(
Note
:
missing
tests
for
types
"
+
unimplemented
.
join
(
"
"
)
+
"
.
)
"
;
document
.
body
.
appendChild
(
p
)
;
}
