function
waitForRender
(
)
{
return
new
Promise
(
resolve
=
>
requestAnimationFrame
(
(
)
=
>
requestAnimationFrame
(
resolve
)
)
)
;
}
function
waitForTick
(
)
{
return
new
Promise
(
resolve
=
>
step_timeout
(
resolve
0
)
)
;
}
async
function
clickOn
(
element
)
{
const
actions
=
new
test_driver
.
Actions
(
)
;
await
waitForRender
(
)
;
await
actions
.
pointerMove
(
0
0
{
origin
:
element
}
)
.
pointerDown
(
{
button
:
actions
.
ButtonType
.
LEFT
}
)
.
pointerUp
(
{
button
:
actions
.
ButtonType
.
LEFT
}
)
.
send
(
)
;
await
waitForRender
(
)
;
}
async
function
sendTab
(
)
{
await
waitForRender
(
)
;
const
kTab
=
'
\
uE004
'
;
await
new
test_driver
.
send_keys
(
document
.
documentElement
kTab
)
;
await
waitForRender
(
)
;
}
async
function
sendEscape
(
)
{
await
waitForRender
(
)
;
await
new
test_driver
.
send_keys
(
document
.
documentElement
'
\
uE00C
'
)
;
await
waitForRender
(
)
;
}
async
function
sendEnter
(
)
{
await
waitForRender
(
)
;
await
new
test_driver
.
send_keys
(
document
.
documentElement
'
\
uE007
'
)
;
await
waitForRender
(
)
;
}
function
isElementVisible
(
el
)
{
return
!
!
(
el
.
offsetWidth
|
|
el
.
offsetHeight
|
|
el
.
getClientRects
(
)
.
length
)
;
}
function
isTopLayer
(
el
)
{
const
properties
=
[
'
right
'
'
background
'
]
;
const
testEl
=
document
.
createElement
(
'
div
'
)
;
document
.
body
.
appendChild
(
testEl
)
;
const
computedStyle
=
getComputedStyle
(
testEl
'
:
:
backdrop
'
)
;
const
nonTopLayerValues
=
properties
.
map
(
p
=
>
computedStyle
[
p
]
)
;
testEl
.
remove
(
)
;
for
(
let
i
=
0
;
i
<
properties
.
length
;
+
+
i
)
{
if
(
getComputedStyle
(
el
'
:
:
backdrop
'
)
[
properties
[
i
]
]
!
=
=
nonTopLayerValues
[
i
]
)
{
return
true
;
}
}
return
false
;
}
async
function
finishAnimations
(
popover
)
{
popover
.
getAnimations
(
{
subtree
:
true
}
)
.
forEach
(
animation
=
>
animation
.
finish
(
)
)
;
await
waitForRender
(
)
;
}
let
mouseOverStarted
;
function
mouseOver
(
element
)
{
mouseOverStarted
=
performance
.
now
(
)
;
return
(
new
test_driver
.
Actions
(
)
)
.
pointerMove
(
0
0
{
origin
:
element
}
)
.
send
(
)
;
}
function
msSinceMouseOver
(
)
{
return
performance
.
now
(
)
-
mouseOverStarted
;
}
async
function
waitForHoverTime
(
hoverWaitTimeMs
)
{
await
new
Promise
(
resolve
=
>
step_timeout
(
resolve
hoverWaitTimeMs
)
)
;
await
waitForRender
(
)
;
}
;
async
function
blessTopLayer
(
visibleElement
)
{
const
button
=
document
.
createElement
(
'
button
'
)
;
button
.
innerHTML
=
"
Click
me
to
activate
"
;
visibleElement
.
appendChild
(
button
)
;
let
wait_click
=
new
Promise
(
resolve
=
>
button
.
addEventListener
(
"
click
"
resolve
{
once
:
true
}
)
)
;
await
test_driver
.
click
(
button
)
;
await
wait_click
;
button
.
remove
(
)
;
}
function
showDefaultopenPopoversOnLoad
(
)
{
function
show
(
)
{
const
popovers
=
Array
.
from
(
document
.
querySelectorAll
(
'
[
popover
]
[
defaultopen
]
'
)
)
;
popovers
.
forEach
(
(
p
)
=
>
{
if
(
p
instanceof
HTMLDialogElement
&
&
p
.
hasAttribute
(
'
open
'
)
)
return
;
switch
(
p
.
popover
)
{
case
'
auto
'
:
if
(
!
document
.
querySelector
(
'
[
popover
]
:
popover
-
open
'
)
)
p
.
showPopover
(
)
;
return
;
case
'
manual
'
:
p
.
showPopover
(
)
;
return
;
default
:
assert_unreached
(
Unknown
popover
type
{
p
.
popover
}
)
;
}
}
)
;
}
if
(
document
.
readyState
=
=
=
'
complete
'
)
{
show
(
)
;
}
else
{
window
.
addEventListener
(
'
load
'
show
{
once
:
true
}
)
;
}
}
function
popoverHintSupported
(
)
{
const
testElement
=
document
.
createElement
(
'
div
'
)
;
testElement
.
popover
=
'
hint
'
;
return
testElement
.
popover
=
=
=
'
hint
'
;
}
function
assertPopoverVisibility
(
popover
isPopover
expectedVisibility
message
)
{
const
isVisible
=
isElementVisible
(
popover
)
;
assert_equals
(
isVisible
expectedVisibility
{
message
}
:
Expected
this
element
to
be
{
expectedVisibility
?
"
visible
"
:
"
not
visible
"
}
)
;
if
(
isVisible
)
{
assert_not_equals
(
window
.
getComputedStyle
(
popover
)
.
display
'
none
'
)
;
assert_equals
(
popover
.
matches
(
'
:
popover
-
open
'
)
isPopover
{
message
}
:
Visible
popovers
should
match
:
popover
-
open
)
;
}
else
{
assert_equals
(
window
.
getComputedStyle
(
popover
)
.
display
'
none
'
{
message
}
:
Non
-
showing
popovers
should
have
display
:
none
)
;
assert_false
(
popover
.
matches
(
'
:
popover
-
open
'
)
{
message
}
:
Non
-
showing
popovers
should
*
not
*
match
:
popover
-
open
)
;
}
}
function
assertIsFunctionalPopover
(
popover
checkVisibility
)
{
assertPopoverVisibility
(
popover
true
false
'
A
popover
should
start
out
hidden
'
)
;
popover
.
showPopover
(
)
;
if
(
checkVisibility
)
assertPopoverVisibility
(
popover
true
true
'
After
showPopover
(
)
a
popover
should
be
visible
'
)
;
popover
.
showPopover
(
)
;
popover
.
hidePopover
(
)
;
if
(
checkVisibility
)
assertPopoverVisibility
(
popover
true
false
'
After
hidePopover
(
)
a
popover
should
be
hidden
'
)
;
popover
.
hidePopover
(
)
;
popover
.
togglePopover
(
)
;
if
(
checkVisibility
)
assertPopoverVisibility
(
popover
true
true
'
After
togglePopover
(
)
on
hidden
popover
it
should
be
visible
'
)
;
popover
.
togglePopover
(
)
;
if
(
checkVisibility
)
assertPopoverVisibility
(
popover
true
false
'
After
togglePopover
(
)
on
visible
popover
it
should
be
hidden
'
)
;
popover
.
togglePopover
(
true
)
;
if
(
checkVisibility
)
assertPopoverVisibility
(
popover
true
true
'
After
togglePopover
(
true
)
on
hidden
popover
it
should
be
visible
'
)
;
popover
.
togglePopover
(
true
)
;
if
(
checkVisibility
)
assertPopoverVisibility
(
popover
true
true
'
After
togglePopover
(
true
)
on
visible
popover
it
should
be
visible
'
)
;
popover
.
togglePopover
(
false
)
;
if
(
checkVisibility
)
assertPopoverVisibility
(
popover
true
false
'
After
togglePopover
(
false
)
on
visible
popover
it
should
be
hidden
'
)
;
popover
.
togglePopover
(
false
)
;
if
(
checkVisibility
)
assertPopoverVisibility
(
popover
true
false
'
After
togglePopover
(
false
)
on
hidden
popover
it
should
be
hidden
'
)
;
const
parent
=
popover
.
parentElement
;
popover
.
remove
(
)
;
assert_throws_dom
(
"
InvalidStateError
"
(
)
=
>
popover
.
showPopover
(
)
'
Calling
showPopover
on
a
disconnected
popover
should
throw
InvalidStateError
'
)
;
popover
.
hidePopover
(
)
;
assert_throws_dom
(
"
InvalidStateError
"
(
)
=
>
popover
.
togglePopover
(
)
'
Calling
hidePopover
on
a
disconnected
popover
should
throw
InvalidStateError
'
)
;
parent
.
appendChild
(
popover
)
;
}
function
assertNotAPopover
(
nonPopover
)
{
const
expectVisible
=
!
nonPopover
.
hasAttribute
(
'
popover
'
)
;
assertPopoverVisibility
(
nonPopover
false
expectVisible
'
A
non
-
popover
should
start
out
visible
'
)
;
assert_throws_dom
(
"
NotSupportedError
"
(
)
=
>
nonPopover
.
showPopover
(
)
'
Calling
showPopover
on
a
non
-
popover
should
throw
NotSupported
'
)
;
assertPopoverVisibility
(
nonPopover
false
expectVisible
'
Calling
showPopover
on
a
non
-
popover
should
leave
it
visible
'
)
;
assert_throws_dom
(
"
NotSupportedError
"
(
)
=
>
nonPopover
.
hidePopover
(
)
'
Calling
hidePopover
on
a
non
-
popover
should
throw
NotSupported
'
)
;
assertPopoverVisibility
(
nonPopover
false
expectVisible
'
Calling
hidePopover
on
a
non
-
popover
should
leave
it
visible
'
)
;
assert_throws_dom
(
"
NotSupportedError
"
(
)
=
>
nonPopover
.
togglePopover
(
)
'
Calling
togglePopover
on
a
non
-
popover
should
throw
NotSupported
'
)
;
assertPopoverVisibility
(
nonPopover
false
expectVisible
'
Calling
togglePopover
on
a
non
-
popover
should
leave
it
visible
'
)
;
}
