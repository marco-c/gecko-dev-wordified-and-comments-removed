function
getExecutorPath
(
uuid
origin
coop
)
{
const
executor_path
=
'
/
common
/
dispatcher
/
executor
.
html
?
'
;
const
coop_header
=
|
header
(
Cross
-
Origin
-
Opener
-
Policy
{
encodeURIComponent
(
coop
)
}
)
;
return
origin
+
executor_path
+
uuid
=
{
uuid
}
+
'
&
pipe
=
'
+
coop_header
;
}
function
getPopupHasOpener
(
popup_token
)
{
const
reply_token
=
token
(
)
;
send
(
popup_token
send
(
'
{
reply_token
}
'
window
.
opener
!
=
null
)
;
)
;
return
receive
(
reply_token
)
;
}
function
canAccessProperty
(
object
property
)
{
try
{
const
unused
=
object
[
property
]
;
return
true
;
}
catch
(
errors
)
{
return
false
;
}
}
async
function
popup_test
(
description
origin
coop_header
expected_opener_state
)
{
promise_test
(
async
t
=
>
{
const
popup_token
=
token
(
)
;
const
reply_token
=
token
(
)
;
const
popup_url
=
getExecutorPath
(
popup_token
origin
.
origin
coop_header
)
;
const
popup
=
window
.
open
(
popup_url
)
;
send
(
popup_token
send
(
'
{
reply_token
}
'
'
Popup
loaded
'
)
;
)
;
assert_equals
(
await
receive
(
reply_token
)
'
Popup
loaded
'
)
;
t
.
add_cleanup
(
(
)
=
>
{
send
(
popup_token
close
(
)
)
;
}
)
;
await
new
Promise
(
resolve
=
>
{
t
.
step_timeout
(
resolve
500
)
;
}
)
;
switch
(
expected_opener_state
)
{
case
'
preserved
'
:
{
assert_false
(
popup
.
closed
'
Popup
is
closed
from
opener
?
'
)
;
assert_true
(
await
getPopupHasOpener
(
popup_token
)
=
=
=
"
true
"
'
Popup
has
nulled
opener
?
'
)
;
assert_equals
(
canAccessProperty
(
popup
"
document
"
)
origin
=
=
=
SAME_ORIGIN
'
Main
page
has
dom
access
to
the
popup
?
'
)
;
assert_true
(
canAccessProperty
(
popup
"
frames
"
)
'
Main
page
has
cross
origin
access
to
the
popup
?
'
)
;
break
;
}
case
'
severed
'
:
{
assert_true
(
popup
.
closed
'
Popup
is
closed
from
opener
?
'
)
;
assert_false
(
await
getPopupHasOpener
(
popup_token
)
=
=
=
"
true
"
'
Popup
has
nulled
opener
?
'
)
;
break
;
}
default
:
assert_unreached
(
true
"
Unrecognized
opener
relationship
:
"
+
expected_opener_state
)
;
}
}
description
)
;
}
