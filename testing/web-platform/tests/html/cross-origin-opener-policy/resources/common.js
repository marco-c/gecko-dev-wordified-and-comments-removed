const
SAME_ORIGIN
=
{
origin
:
get_host_info
(
)
.
HTTPS_ORIGIN
name
:
"
SAME_ORIGIN
"
}
;
const
SAME_SITE
=
{
origin
:
get_host_info
(
)
.
HTTPS_REMOTE_ORIGIN
name
:
"
SAME_SITE
"
}
;
const
CROSS_ORIGIN
=
{
origin
:
get_host_info
(
)
.
HTTPS_NOTSAMESITE_ORIGIN
name
:
"
CROSS_ORIGIN
"
}
function
addScriptAndTriggerOnload
(
src
onload
)
{
return
script
=
document
.
createElement
(
"
script
"
)
;
script
.
src
=
"
{
src
}
"
;
script
.
onload
=
(
)
=
>
{
{
onload
}
}
;
document
.
head
.
append
(
script
)
;
}
function
verify_window
(
callback
w
hasOpener
)
{
assert_equals
(
w
.
closed
!
hasOpener
'
w
.
closed
'
)
;
assert_equals
(
w
.
length
hasOpener
?
1
:
0
'
w
.
length
'
)
;
callback
(
)
;
}
function
validate_results
(
callback
test
w
channelName
hasOpener
openerDOMAccess
payload
)
{
assert_equals
(
payload
.
name
hasOpener
?
channelName
:
"
"
'
name
'
)
;
assert_equals
(
payload
.
opener
hasOpener
'
opener
'
)
;
if
(
openerDOMAccess
!
=
=
undefined
)
{
assert_equals
(
payload
.
openerDOMAccess
openerDOMAccess
'
openerDOMAccess
'
)
;
}
if
(
!
w
.
closed
&
&
w
.
length
=
=
0
)
{
test
.
step_timeout
(
(
)
=
>
{
verify_window
(
callback
w
hasOpener
)
;
}
500
)
;
}
else
{
verify_window
(
callback
w
hasOpener
)
;
}
}
function
url_test
(
t
url
channelName
hasOpener
openerDOMAccess
callback
)
{
if
(
callback
=
=
=
undefined
)
{
callback
=
(
)
=
>
{
t
.
done
(
)
;
}
;
}
const
bc
=
new
BroadcastChannel
(
channelName
)
;
bc
.
onmessage
=
t
.
step_func
(
event
=
>
{
const
payload
=
event
.
data
;
validate_results
(
callback
t
w
channelName
hasOpener
openerDOMAccess
payload
)
;
}
)
;
const
w
=
window
.
open
(
url
channelName
)
;
t
.
add_cleanup
(
(
)
=
>
{
bc
.
postMessage
(
"
close
"
)
;
}
)
;
}
function
run_coop_test_iframe
(
documentTitle
iframe_origin
popup_origin
popup_coop
expects_opener
expects_name
)
{
for
(
const
popup_via
of
[
"
window_open
"
"
anchor
"
"
form_GET
"
"
form_POST
"
]
)
{
const
name
=
iframe_origin
.
name
+
"
_iframe_opening_
"
+
popup_origin
.
name
+
"
_popup_via_
"
+
popup_via
+
"
_with_coop_
"
+
popup_coop
;
async_test
(
t
=
>
{
const
frame
=
document
.
createElement
(
"
iframe
"
)
;
t
.
add_cleanup
(
(
)
=
>
{
frame
.
remove
(
)
;
bc
.
postMessage
(
"
close
"
)
;
}
)
;
const
origin
=
CROSS_ORIGIN
.
origin
;
const
path
=
new
URL
(
"
resources
/
iframe
-
popup
.
sub
.
html
"
window
.
location
)
.
pathname
;
const
bc
=
new
BroadcastChannel
(
name
)
;
frame
.
src
=
{
iframe_origin
.
origin
}
{
path
}
?
popup_origin
=
{
popup_origin
.
origin
}
&
popup_coop
=
{
popup_coop
}
&
channel
=
{
name
}
&
popup_via
=
{
popup_via
}
;
bc
.
onmessage
=
t
.
step_func_done
(
event
=
>
{
const
payload
=
event
.
data
;
assert_equals
(
payload
.
opener
expects_opener
'
opener
'
)
;
assert_equals
(
payload
.
name
expects_name
?
name
:
"
"
'
name
'
)
;
}
)
;
document
.
body
.
append
(
frame
)
;
}
{
documentTitle
}
with
{
iframe_origin
.
name
}
iframe
opening
popup
via
{
popup_via
}
a
{
popup_origin
.
name
}
with
COOP
:
{
format_value
(
popup_coop
)
}
)
;
}
}
