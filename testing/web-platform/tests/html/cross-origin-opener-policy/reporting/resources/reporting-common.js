const
executor_path
=
"
/
common
/
dispatcher
/
executor
.
html
?
pipe
=
"
;
const
coep_header
=
'
|
header
(
Cross
-
Origin
-
Embedder
-
Policy
require
-
corp
)
'
;
Object
.
defineProperty
(
RegExp
.
prototype
"
toJSON
"
{
value
:
RegExp
.
prototype
.
toString
}
)
;
function
wait
(
ms
)
{
return
new
Promise
(
resolve
=
>
step_timeout
(
resolve
ms
)
)
;
}
function
isCoopOpenerBreakageReport
(
report
)
{
if
(
report
.
type
!
=
"
coop
"
)
return
false
;
if
(
report
.
body
.
type
!
=
"
navigation
-
from
-
response
"
&
&
report
.
body
.
type
!
=
"
navigation
-
to
-
response
"
)
{
return
false
;
}
return
true
;
}
async
function
pollReports
(
endpoint
)
{
const
res
=
await
fetch
(
/
reporting
/
resources
/
report
.
py
?
endpoint
=
{
endpoint
.
name
}
{
cache
:
'
no
-
store
'
}
)
;
if
(
res
.
status
!
=
=
200
)
{
return
;
}
for
(
const
report
of
await
res
.
json
(
)
)
{
if
(
isCoopOpenerBreakageReport
(
report
)
)
endpoint
.
reports
.
push
(
report
)
;
}
}
function
isObjectAsExpected
(
report
expectedReport
)
{
if
(
(
report
=
=
=
undefined
|
|
report
=
=
=
null
|
|
expectedReport
=
=
=
undefined
|
|
expectedReport
=
=
=
null
)
&
&
report
!
=
=
expectedReport
)
{
return
false
;
}
if
(
expectedReport
instanceof
RegExp
&
&
typeof
report
=
=
=
"
string
"
)
{
return
expectedReport
.
test
(
report
)
;
}
if
(
typeof
report
!
=
=
typeof
expectedReport
)
return
false
;
if
(
typeof
expectedReport
=
=
=
'
object
'
)
{
return
Object
.
keys
(
expectedReport
)
.
every
(
key
=
>
{
return
isObjectAsExpected
(
report
[
key
]
expectedReport
[
key
]
)
;
}
)
;
}
return
report
=
=
expectedReport
;
}
async
function
checkForExpectedReport
(
expectedReport
)
{
return
new
Promise
(
async
(
resolve
reject
)
=
>
{
const
polls
=
30
;
const
waitTime
=
100
;
for
(
var
i
=
0
;
i
<
polls
;
+
+
i
)
{
pollReports
(
expectedReport
.
endpoint
)
;
for
(
var
j
=
0
;
j
<
expectedReport
.
endpoint
.
reports
.
length
;
+
+
j
)
{
if
(
isObjectAsExpected
(
expectedReport
.
endpoint
.
reports
[
j
]
expectedReport
.
report
)
)
{
expectedReport
.
endpoint
.
reports
.
splice
(
j
1
)
;
resolve
(
)
;
return
;
}
}
;
await
wait
(
waitTime
)
;
}
reject
(
replaceTokensInReceivedReport
(
"
No
report
matched
the
expected
report
for
endpoint
:
"
+
expectedReport
.
endpoint
.
name
+
"
expected
report
:
"
+
JSON
.
stringify
(
expectedReport
.
report
)
+
"
within
available
reports
:
"
+
JSON
.
stringify
(
expectedReport
.
endpoint
.
reports
)
)
)
;
}
)
;
}
function
replaceFromRegexOrString
(
str
match
value
)
{
if
(
str
instanceof
RegExp
)
{
return
RegExp
(
str
.
source
.
replace
(
match
value
)
)
;
}
return
str
.
replace
(
match
value
)
;
}
function
replaceValuesInExpectedReport
(
expectedReport
executorUuid
)
{
if
(
expectedReport
.
report
.
body
!
=
=
undefined
)
{
if
(
expectedReport
.
report
.
body
.
nextResponseURL
!
=
=
undefined
)
{
expectedReport
.
report
.
body
.
nextResponseURL
=
replaceFromRegexOrString
(
expectedReport
.
report
.
body
.
nextResponseURL
"
EXECUTOR_UUID
"
executorUuid
)
;
}
if
(
expectedReport
.
report
.
body
.
previousResponseURL
!
=
=
undefined
)
{
expectedReport
.
report
.
body
.
previousResponseURL
=
replaceFromRegexOrString
(
expectedReport
.
report
.
body
.
previousResponseURL
"
EXECUTOR_UUID
"
executorUuid
)
;
}
if
(
expectedReport
.
report
.
body
.
referrer
!
=
=
undefined
)
{
expectedReport
.
report
.
body
.
referrer
=
replaceFromRegexOrString
(
expectedReport
.
report
.
body
.
referrer
"
EXECUTOR_UUID
"
executorUuid
)
;
}
}
if
(
expectedReport
.
report
.
url
!
=
=
undefined
)
{
expectedReport
.
report
.
url
=
replaceFromRegexOrString
(
expectedReport
.
report
.
url
"
EXECUTOR_UUID
"
executorUuid
)
;
}
return
expectedReport
;
}
function
replaceTokensInReceivedReport
(
str
)
{
return
str
.
replace
(
/
.
{
8
}
-
.
{
4
}
-
.
{
4
}
-
.
{
4
}
-
.
{
12
}
/
g
(
uuid
)
)
;
}
async
function
reportingTest
(
testFunction
executorToken
expectedReports
)
{
await
new
Promise
(
testFunction
)
;
expectedReports
=
Array
.
from
(
expectedReports
report
=
>
replaceValuesInExpectedReport
(
report
executorToken
)
)
;
await
Promise
.
all
(
Array
.
from
(
expectedReports
checkForExpectedReport
)
)
;
}
function
getReportEndpoints
(
host
)
{
result
=
"
"
;
reportEndpoints
.
forEach
(
reportEndpoint
=
>
{
let
reportToJSON
=
{
'
group
'
:
{
reportEndpoint
.
name
}
'
max_age
'
:
3600
'
endpoints
'
:
[
{
'
url
'
:
{
host
}
/
reporting
/
resources
/
report
.
py
?
endpoint
=
{
reportEndpoint
.
name
}
}
]
}
;
result
+
=
JSON
.
stringify
(
reportToJSON
)
.
replace
(
/
/
g
'
\
\
'
)
.
replace
(
/
\
(
/
g
'
\
\
\
(
'
)
.
replace
(
/
\
)
/
g
'
\
\
\
)
=
'
)
+
"
\
\
"
;
}
)
;
return
result
.
slice
(
0
-
2
)
;
}
function
navigationReportingTest
(
testName
host
coop
coep
coopRo
coepRo
expectedReports
)
{
const
executorToken
=
token
(
)
;
const
callbackToken
=
token
(
)
;
promise_test
(
async
t
=
>
{
await
reportingTest
(
async
resolve
=
>
{
const
openee_url
=
host
.
origin
+
executor_path
+
|
header
(
report
-
to
{
encodeURIComponent
(
getReportEndpoints
(
host
.
origin
)
)
}
)
+
|
header
(
Cross
-
Origin
-
Opener
-
Policy
{
encodeURIComponent
(
coop
)
}
)
+
|
header
(
Cross
-
Origin
-
Embedder
-
Policy
{
encodeURIComponent
(
coep
)
}
)
+
|
header
(
Cross
-
Origin
-
Opener
-
Policy
-
Report
-
Only
{
encodeURIComponent
(
coopRo
)
}
)
+
|
header
(
Cross
-
Origin
-
Embedder
-
Policy
-
Report
-
Only
{
encodeURIComponent
(
coepRo
)
}
)
+
&
uuid
=
{
executorToken
}
;
const
openee
=
window
.
open
(
openee_url
)
;
const
uuid
=
token
(
)
;
t
.
add_cleanup
(
(
)
=
>
send
(
uuid
"
window
.
close
(
)
"
)
)
;
send
(
executorToken
send
(
"
{
callbackToken
}
"
"
Ready
"
)
;
)
;
let
reply
=
await
receive
(
callbackToken
)
;
assert_equals
(
reply
"
Ready
"
)
;
resolve
(
)
;
}
executorToken
expectedReports
)
;
}
coop
reporting
test
{
testName
}
to
{
host
.
name
}
with
{
coop
}
{
coep
}
{
coopRo
}
{
coepRo
}
)
;
}
function
runNavigationReportingTests
(
testName
tests
)
{
tests
.
forEach
(
test
=
>
{
navigationReportingTest
(
testName
.
.
.
test
)
;
}
)
;
verifyRemainingReports
(
)
;
}
const
reportEndpoint
=
{
name
:
"
coop
-
report
-
endpoint
"
reports
:
[
]
}
const
reportOnlyEndpoint
=
{
name
:
"
coop
-
report
-
only
-
endpoint
"
reports
:
[
]
}
const
popupReportEndpoint
=
{
name
:
"
coop
-
popup
-
report
-
endpoint
"
reports
:
[
]
}
const
popupReportOnlyEndpoint
=
{
name
:
"
coop
-
popup
-
report
-
only
-
endpoint
"
reports
:
[
]
}
const
redirectReportEndpoint
=
{
name
:
"
coop
-
redirect
-
report
-
endpoint
"
reports
:
[
]
}
const
redirectReportOnlyEndpoint
=
{
name
:
"
coop
-
redirect
-
report
-
only
-
endpoint
"
reports
:
[
]
}
const
reportEndpoints
=
[
reportEndpoint
reportOnlyEndpoint
popupReportEndpoint
popupReportOnlyEndpoint
redirectReportEndpoint
redirectReportOnlyEndpoint
]
function
verifyRemainingReports
(
)
{
promise_test
(
async
t
=
>
{
await
Promise
.
all
(
Array
.
from
(
reportEndpoints
(
endpoint
)
=
>
{
return
new
Promise
(
async
(
resolve
reject
)
=
>
{
await
pollReports
(
endpoint
)
;
if
(
endpoint
.
reports
.
length
!
=
0
)
reject
(
{
endpoint
.
name
}
not
empty
)
;
resolve
(
)
;
}
)
;
}
)
)
;
}
"
verify
remaining
reports
"
)
;
}
const
receiveReport
=
async
function
(
uuid
type
)
{
while
(
true
)
{
let
reports
=
await
receive
(
uuid
)
;
if
(
reports
=
=
"
timeout
"
)
return
"
timeout
"
;
reports
=
JSON
.
parse
(
reports
)
;
for
(
report
of
reports
)
{
if
(
report
?
.
body
?
.
type
=
=
type
)
return
report
;
}
}
}
const
reportToHeaders
=
function
(
uuid
)
{
const
report_endpoint_url
=
dispatcher_path
+
?
uuid
=
{
uuid
}
;
let
reportToJSON
=
{
'
group
'
:
{
uuid
}
'
max_age
'
:
3600
'
endpoints
'
:
[
{
'
url
'
:
report_endpoint_url
.
toString
(
)
}
]
}
;
reportToJSON
=
JSON
.
stringify
(
reportToJSON
)
.
replace
(
/
/
g
'
\
\
'
)
.
replace
(
/
\
(
/
g
'
\
\
\
(
'
)
.
replace
(
/
\
)
/
g
'
\
\
\
)
=
'
)
;
return
{
header
:
|
header
(
report
-
to
{
reportToJSON
}
)
coopSameOriginHeader
:
|
header
(
Cross
-
Origin
-
Opener
-
Policy
same
-
origin
%
3Breport
-
to
=
"
{
uuid
}
"
)
coopSameOriginAllowPopupsHeader
:
|
header
(
Cross
-
Origin
-
Opener
-
Policy
same
-
origin
-
allow
-
popups
%
3Breport
-
to
=
"
{
uuid
}
"
)
coopReportOnlySameOriginHeader
:
|
header
(
Cross
-
Origin
-
Opener
-
Policy
-
Report
-
Only
same
-
origin
%
3Breport
-
to
=
"
{
uuid
}
"
)
coopReportOnlySameOriginAllowPopupsHeader
:
|
header
(
Cross
-
Origin
-
Opener
-
Policy
-
Report
-
Only
same
-
origin
-
allow
-
popups
%
3Breport
-
to
=
"
{
uuid
}
"
)
}
;
}
;
