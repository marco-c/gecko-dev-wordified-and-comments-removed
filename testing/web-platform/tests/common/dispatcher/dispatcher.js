const
dispatcher_path
=
"
/
common
/
dispatcher
/
dispatcher
.
py
"
;
function
findLocationFromAncestors
(
w
)
{
if
(
w
.
location
.
href
=
=
'
about
:
srcdoc
'
)
{
return
findLocationFromAncestors
(
w
.
parent
)
;
}
return
w
.
location
;
}
function
findLocation
(
)
{
if
(
location
.
href
=
=
'
about
:
srcdoc
'
)
{
return
findLocationFromAncestors
(
window
.
parent
)
;
}
if
(
location
.
protocol
=
=
'
blob
:
'
|
|
location
.
protocol
=
=
'
data
:
'
)
{
if
(
self
.
document
&
&
self
.
document
.
baseURI
)
{
return
self
.
document
.
baseURI
;
}
}
return
location
;
}
const
dispatcherLocation
=
findLocation
(
)
;
const
dispatcher_url
=
new
URL
(
dispatcher_path
dispatcherLocation
)
.
href
;
const
concurrencyLimiter
=
(
max_concurrency
)
=
>
{
let
pending
=
0
;
let
waiting
=
[
]
;
return
async
(
task
)
=
>
{
pending
+
+
;
if
(
pending
>
max_concurrency
)
await
new
Promise
(
resolve
=
>
waiting
.
push
(
resolve
)
)
;
let
result
=
await
task
(
)
;
pending
-
-
;
waiting
.
shift
(
)
?
.
(
)
;
return
result
;
}
;
}
const
randomDelay
=
(
)
=
>
{
return
new
Promise
(
resolve
=
>
setTimeout
(
resolve
10
+
90
*
Math
.
random
(
)
)
)
;
}
const
limiter
=
concurrencyLimiter
(
6
)
;
const
sendQueues
=
new
Map
(
)
;
const
sendItem
=
async
function
(
uuid
resolver
message
)
{
await
limiter
(
async
(
)
=
>
{
while
(
1
)
{
try
{
let
response
=
await
fetch
(
dispatcher_url
+
?
uuid
=
{
uuid
}
{
method
:
'
POST
'
body
:
message
}
)
if
(
await
response
.
text
(
)
=
=
"
done
"
)
{
resolver
(
)
;
return
;
}
}
catch
(
fetch_error
)
{
}
await
randomDelay
(
)
;
}
;
}
)
;
}
const
processQueue
=
async
function
(
uuid
queue
)
{
while
(
queue
.
length
)
{
const
[
resolver
message
]
=
queue
.
shift
(
)
;
await
sendItem
(
uuid
resolver
message
)
;
}
sendQueues
.
delete
(
uuid
)
;
}
const
send
=
async
function
(
uuid
message
)
{
const
itemSentPromise
=
new
Promise
(
(
resolve
)
=
>
{
const
item
=
[
resolve
message
]
;
if
(
sendQueues
.
has
(
uuid
)
)
{
sendQueues
.
get
(
uuid
)
.
push
(
item
)
;
}
else
{
const
queue
=
[
item
]
;
sendQueues
.
set
(
uuid
queue
)
;
processQueue
(
uuid
queue
)
;
}
}
)
;
await
itemSentPromise
;
}
const
receive
=
async
function
(
uuid
)
{
while
(
1
)
{
let
data
=
"
not
ready
"
;
try
{
data
=
await
limiter
(
async
(
)
=
>
{
let
response
=
await
fetch
(
dispatcher_url
+
?
uuid
=
{
uuid
}
)
;
return
await
response
.
text
(
)
;
}
)
;
}
catch
(
fetch_error
)
{
}
if
(
data
=
=
"
not
ready
"
)
{
await
randomDelay
(
)
;
continue
;
}
return
data
;
}
}
const
showRequestHeaders
=
function
(
origin
uuid
)
{
return
origin
+
dispatcher_path
+
?
uuid
=
{
uuid
}
&
show
-
headers
;
}
const
cacheableShowRequestHeaders
=
function
(
origin
uuid
)
{
return
origin
+
dispatcher_path
+
?
uuid
=
{
uuid
}
&
cacheable
&
show
-
headers
;
}
function
remoteExecutorUrl
(
uuid
options
)
{
const
url
=
new
URL
(
"
/
common
/
dispatcher
/
remote
-
executor
.
html
"
dispatcherLocation
)
;
url
.
searchParams
.
set
(
"
uuid
"
uuid
)
;
if
(
options
?
.
host
)
{
url
.
host
=
options
.
host
;
}
if
(
options
?
.
protocol
)
{
url
.
protocol
=
options
.
protocol
;
}
return
url
;
}
class
RemoteContext
{
constructor
(
uuid
)
{
this
.
context_id
=
uuid
;
}
async
execute_script
(
fn
args
)
{
const
receiver
=
token
(
)
;
await
this
.
send
(
{
receiver
:
receiver
fn
:
fn
.
toString
(
)
args
:
args
}
)
;
const
response
=
JSON
.
parse
(
await
receive
(
receiver
)
)
;
if
(
response
.
status
=
=
=
'
success
'
)
{
return
response
.
value
;
}
if
(
response
.
name
=
=
=
'
TypeError
'
)
{
throw
new
TypeError
(
response
.
value
)
;
}
throw
new
Error
(
response
.
value
)
;
}
async
send
(
msg
)
{
return
await
send
(
this
.
context_id
JSON
.
stringify
(
msg
)
)
;
}
}
;
class
Executor
{
constructor
(
uuid
)
{
this
.
uuid
=
uuid
;
this
.
suspend_callback
=
null
;
this
.
execute
(
)
;
}
suspend
(
callback
)
{
this
.
suspend_callback
=
callback
;
}
resume
(
)
{
}
async
execute
(
)
{
while
(
true
)
{
if
(
this
.
suspend_callback
!
=
=
null
)
{
this
.
suspend_callback
(
)
;
this
.
suspend_callback
=
null
;
await
new
Promise
(
resolve
=
>
this
.
resume
=
resolve
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
continue
;
}
const
task
=
JSON
.
parse
(
await
receive
(
this
.
uuid
)
)
;
let
response
;
try
{
const
value
=
await
eval
(
task
.
fn
)
.
apply
(
null
task
.
args
)
;
response
=
JSON
.
stringify
(
{
status
:
'
success
'
value
:
value
}
)
;
}
catch
(
e
)
{
response
=
JSON
.
stringify
(
{
status
:
'
exception
'
name
:
e
.
name
value
:
e
.
message
}
)
;
}
await
send
(
task
.
receiver
response
)
;
}
}
}
