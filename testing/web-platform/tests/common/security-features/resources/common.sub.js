function
timeoutPromise
(
t
ms
)
{
return
new
Promise
(
resolve
=
>
{
t
.
step_timeout
(
resolve
ms
)
;
}
)
;
}
function
getNormalizedPort
(
targetPort
)
{
return
(
[
80
443
"
"
]
.
indexOf
(
targetPort
)
>
=
0
)
?
"
"
:
"
:
"
+
targetPort
;
}
function
guid
(
)
{
return
'
xxxxxxxx
-
xxxx
-
4xxx
-
yxxx
-
xxxxxxxxxxxx
'
.
replace
(
/
[
xy
]
/
g
function
(
c
)
{
var
r
=
Math
.
random
(
)
*
16
|
0
v
=
c
=
=
'
x
'
?
r
:
(
r
&
0x3
|
0x8
)
;
return
v
.
toString
(
16
)
;
}
)
;
}
function
xhrRequest
(
url
responseType
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
'
GET
'
url
true
)
;
xhr
.
responseType
=
responseType
|
|
"
json
"
;
xhr
.
addEventListener
(
"
error
"
function
(
)
{
reject
(
Error
(
"
Network
Error
"
)
)
;
}
)
;
xhr
.
addEventListener
(
"
load
"
function
(
)
{
if
(
xhr
.
status
!
=
200
)
reject
(
Error
(
xhr
.
statusText
)
)
;
else
resolve
(
xhr
.
response
)
;
}
)
;
xhr
.
send
(
)
;
}
)
;
}
function
setAttributes
(
el
attrs
)
{
attrs
=
attrs
|
|
{
}
for
(
var
attr
in
attrs
)
{
if
(
attr
!
=
=
'
src
'
)
el
.
setAttribute
(
attr
attrs
[
attr
]
)
;
}
for
(
var
attr
in
attrs
)
{
if
(
attr
=
=
=
'
src
'
)
el
.
setAttribute
(
attr
attrs
[
attr
]
)
;
}
}
function
bindEvents
(
element
resolveEventName
rejectEventName
)
{
element
.
eventPromise
=
bindEvents2
(
element
resolveEventName
element
rejectEventName
)
;
}
function
bindEvents2
(
resolveObject
resolveEventName
rejectObject
rejectEventName
rejectObject2
rejectEventName2
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
const
actualResolveEventName
=
resolveEventName
|
|
"
load
"
;
const
actualRejectEventName
=
rejectEventName
|
|
"
error
"
;
const
actualRejectEventName2
=
rejectEventName2
|
|
"
error
"
;
const
resolveHandler
=
function
(
event
)
{
cleanup
(
)
;
resolve
(
event
)
;
}
;
const
rejectHandler
=
function
(
event
)
{
event
.
preventDefault
(
)
;
cleanup
(
)
;
reject
(
event
)
;
}
;
const
cleanup
=
function
(
)
{
resolveObject
.
removeEventListener
(
actualResolveEventName
resolveHandler
)
;
rejectObject
.
removeEventListener
(
actualRejectEventName
rejectHandler
)
;
if
(
rejectObject2
)
{
rejectObject2
.
removeEventListener
(
actualRejectEventName2
rejectHandler
)
;
}
}
;
resolveObject
.
addEventListener
(
actualResolveEventName
resolveHandler
)
;
rejectObject
.
addEventListener
(
actualRejectEventName
rejectHandler
)
;
if
(
rejectObject2
)
{
rejectObject2
.
addEventListener
(
actualRejectEventName2
rejectHandler
)
;
}
}
)
;
}
function
createElement
(
tagName
attrs
parentNode
doBindEvents
)
{
var
element
=
document
.
createElement
(
tagName
)
;
if
(
doBindEvents
)
{
bindEvents
(
element
)
;
if
(
element
.
tagName
=
=
"
IFRAME
"
&
&
!
(
'
srcdoc
'
in
attrs
|
|
'
src
'
in
attrs
)
)
{
element
.
eventPromise
=
element
.
eventPromise
.
then
(
(
)
=
>
{
return
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
}
)
;
}
}
var
isImg
=
(
tagName
=
=
"
img
"
)
;
if
(
!
isImg
)
setAttributes
(
element
attrs
)
;
if
(
parentNode
)
parentNode
.
appendChild
(
element
)
;
if
(
isImg
)
setAttributes
(
element
attrs
)
;
return
element
;
}
function
createRequestViaElement
(
tagName
attrs
parentNode
)
{
return
createElement
(
tagName
attrs
parentNode
true
)
.
eventPromise
;
}
function
createHelperIframe
(
name
doBindEvents
)
{
return
createElement
(
"
iframe
"
{
"
name
"
:
name
"
id
"
:
name
}
document
.
body
doBindEvents
)
;
}
function
wrapResult
(
server_data
)
{
if
(
typeof
(
server_data
)
=
=
=
"
string
"
)
{
throw
server_data
;
}
return
{
referrer
:
server_data
.
headers
.
referer
headers
:
server_data
.
headers
}
}
function
requestViaIframe
(
url
additionalAttributes
)
{
const
iframe
=
createElement
(
"
iframe
"
Object
.
assign
(
{
"
src
"
:
url
}
additionalAttributes
)
document
.
body
false
)
;
return
bindEvents2
(
window
"
message
"
iframe
"
error
"
window
"
error
"
)
.
then
(
event
=
>
{
if
(
event
.
source
!
=
=
iframe
.
contentWindow
)
return
Promise
.
reject
(
new
Error
(
'
Unexpected
event
.
source
'
)
)
;
return
event
.
data
;
}
)
;
}
function
requestViaImage
(
url
additionalAttributes
)
{
const
img
=
createElement
(
"
img
"
Object
.
assign
(
{
"
src
"
:
url
"
crossOrigin
"
:
"
Anonymous
"
}
additionalAttributes
)
document
.
body
true
)
;
return
img
.
eventPromise
.
then
(
(
)
=
>
wrapResult
(
decodeImageData
(
img
)
)
)
;
}
function
decodeImageData
(
img
)
{
var
canvas
=
document
.
createElement
(
"
canvas
"
)
;
var
context
=
canvas
.
getContext
(
'
2d
'
)
;
context
.
drawImage
(
img
0
0
)
;
var
imgData
=
context
.
getImageData
(
0
0
img
.
clientWidth
img
.
clientHeight
)
;
const
rgba
=
imgData
.
data
;
let
decodedBytes
=
new
Uint8ClampedArray
(
rgba
.
length
)
;
let
decodedLength
=
0
;
for
(
var
i
=
0
;
i
+
12
<
=
rgba
.
length
;
i
+
=
12
)
{
const
bits
=
[
]
;
for
(
let
j
=
0
;
j
<
3
;
+
+
j
)
{
bits
.
push
(
rgba
[
i
+
j
*
4
+
0
]
)
;
bits
.
push
(
rgba
[
i
+
j
*
4
+
1
]
)
;
bits
.
push
(
rgba
[
i
+
j
*
4
+
2
]
)
;
}
bits
.
pop
(
)
;
let
byte
=
0
;
for
(
let
j
=
0
;
j
<
8
;
+
+
j
)
{
byte
<
<
=
1
;
if
(
bits
[
j
]
>
=
128
)
byte
|
=
1
;
}
if
(
byte
=
=
0
)
break
;
decodedBytes
[
decodedLength
+
+
]
=
byte
;
}
decodedBytes
=
decodedBytes
.
subarray
(
0
decodedLength
)
;
var
string_data
=
(
new
TextDecoder
(
"
ascii
"
)
)
.
decode
(
decodedBytes
)
;
return
JSON
.
parse
(
string_data
)
;
}
function
requestViaXhr
(
url
)
{
return
xhrRequest
(
url
)
.
then
(
result
=
>
wrapResult
(
result
)
)
;
}
function
requestViaFetch
(
url
)
{
return
fetch
(
url
)
.
then
(
res
=
>
res
.
json
(
)
)
.
then
(
j
=
>
wrapResult
(
j
)
)
;
}
function
dedicatedWorkerUrlThatFetches
(
url
)
{
return
data
:
text
/
javascript
fetch
(
'
{
url
}
'
)
.
then
(
r
=
>
r
.
json
(
)
)
.
then
(
j
=
>
postMessage
(
j
)
)
.
catch
(
(
e
)
=
>
postMessage
(
e
.
message
)
)
;
;
}
function
workerUrlThatImports
(
url
)
{
return
data
:
text
/
javascript
import
'
{
url
}
'
;
;
}
function
requestViaDedicatedWorker
(
url
options
)
{
var
worker
;
try
{
worker
=
new
Worker
(
url
options
)
;
}
catch
(
e
)
{
return
Promise
.
reject
(
e
)
;
}
worker
.
postMessage
(
'
'
)
;
return
bindEvents2
(
worker
"
message
"
worker
"
error
"
)
.
then
(
event
=
>
wrapResult
(
event
.
data
)
)
;
}
function
requestViaSharedWorker
(
url
)
{
var
worker
;
try
{
worker
=
new
SharedWorker
(
url
)
;
}
catch
(
e
)
{
return
Promise
.
reject
(
e
)
;
}
const
promise
=
bindEvents2
(
worker
.
port
"
message
"
worker
"
error
"
)
.
then
(
event
=
>
wrapResult
(
event
.
data
)
)
;
worker
.
port
.
start
(
)
;
return
promise
;
}
function
get_worklet
(
type
)
{
if
(
type
=
=
'
animation
'
)
return
CSS
.
animationWorklet
;
if
(
type
=
=
'
layout
'
)
return
CSS
.
layoutWorklet
;
if
(
type
=
=
'
paint
'
)
return
CSS
.
paintWorklet
;
if
(
type
=
=
'
audio
'
)
return
new
OfflineAudioContext
(
2
44100
*
40
44100
)
.
audioWorklet
;
throw
new
Error
(
'
unknown
worklet
type
is
passed
.
'
)
;
}
function
requestViaWorklet
(
type
url
)
{
try
{
return
get_worklet
(
type
)
.
addModule
(
url
)
;
}
catch
(
e
)
{
return
Promise
.
reject
(
e
)
;
}
}
function
requestViaNavigable
(
navigableElement
url
)
{
var
iframe
=
createHelperIframe
(
guid
(
)
false
)
;
setAttributes
(
navigableElement
{
"
href
"
:
url
"
target
"
:
iframe
.
name
}
)
;
const
promise
=
bindEvents2
(
window
"
message
"
iframe
"
error
"
window
"
error
"
)
.
then
(
event
=
>
{
if
(
event
.
source
!
=
=
iframe
.
contentWindow
)
return
Promise
.
reject
(
new
Error
(
'
Unexpected
event
.
source
'
)
)
;
return
event
.
data
;
}
)
;
navigableElement
.
click
(
)
;
return
promise
;
}
function
requestViaAnchor
(
url
additionalAttributes
)
{
var
a
=
createElement
(
"
a
"
Object
.
assign
(
{
"
innerHTML
"
:
"
Link
to
resource
"
}
additionalAttributes
)
document
.
body
)
;
return
requestViaNavigable
(
a
url
)
;
}
function
requestViaArea
(
url
additionalAttributes
)
{
var
area
=
createElement
(
"
area
"
Object
.
assign
(
{
}
additionalAttributes
)
document
.
body
)
;
return
requestViaNavigable
(
area
url
)
;
}
function
requestViaScript
(
url
additionalAttributes
)
{
const
script
=
createElement
(
"
script
"
Object
.
assign
(
{
"
src
"
:
url
}
additionalAttributes
)
document
.
body
false
)
;
return
bindEvents2
(
window
"
message
"
script
"
error
"
window
"
error
"
)
.
then
(
event
=
>
wrapResult
(
event
.
data
)
)
;
}
function
requestViaForm
(
url
)
{
var
iframe
=
createHelperIframe
(
guid
(
)
)
;
var
form
=
createElement
(
"
form
"
{
"
action
"
:
url
"
method
"
:
"
POST
"
"
target
"
:
iframe
.
name
}
document
.
body
)
;
bindEvents
(
iframe
)
;
form
.
submit
(
)
;
return
iframe
.
eventPromise
;
}
function
requestViaLinkStylesheet
(
url
)
{
return
createRequestViaElement
(
"
link
"
{
"
rel
"
:
"
stylesheet
"
"
href
"
:
url
}
document
.
head
)
;
}
function
requestViaLinkPrefetch
(
url
)
{
var
link
=
document
.
createElement
(
'
link
'
)
;
if
(
link
.
relList
&
&
link
.
relList
.
supports
&
&
link
.
relList
.
supports
(
"
prefetch
"
)
)
{
return
createRequestViaElement
(
"
link
"
{
"
rel
"
:
"
prefetch
"
"
href
"
:
url
}
document
.
head
)
;
}
else
{
return
Promise
.
reject
(
"
This
browser
does
not
support
'
prefetch
'
.
"
)
;
}
}
async
function
requestViaSendBeacon
(
url
)
{
function
wait
(
ms
)
{
return
new
Promise
(
resolve
=
>
step_timeout
(
resolve
ms
)
)
;
}
if
(
!
navigator
.
sendBeacon
(
url
)
)
{
throw
new
Error
(
'
sendBeacon
(
)
fails
.
'
)
;
}
await
wait
(
500
)
;
return
'
allowed
'
;
}
function
createMediaElement
(
type
media_attrs
source_attrs
)
{
var
mediaElement
=
createElement
(
type
{
}
)
;
var
sourceElement
=
createElement
(
"
source
"
{
}
)
;
mediaElement
.
eventPromise
=
new
Promise
(
function
(
resolve
reject
)
{
mediaElement
.
addEventListener
(
"
loadeddata
"
function
(
e
)
{
resolve
(
e
)
;
}
)
;
mediaElement
.
addEventListener
(
"
stalled
"
function
(
e
)
{
reject
(
e
)
;
}
)
;
sourceElement
.
addEventListener
(
"
error
"
function
(
e
)
{
reject
(
e
)
;
}
)
;
}
)
;
setAttributes
(
mediaElement
media_attrs
)
;
setAttributes
(
sourceElement
source_attrs
)
;
mediaElement
.
appendChild
(
sourceElement
)
;
document
.
body
.
appendChild
(
mediaElement
)
;
return
mediaElement
;
}
function
requestViaVideo
(
url
)
{
return
createMediaElement
(
"
video
"
{
}
{
"
src
"
:
url
}
)
.
eventPromise
;
}
function
requestViaAudio
(
url
)
{
return
createMediaElement
(
"
audio
"
{
}
{
"
type
"
:
"
audio
/
wav
"
"
src
"
:
url
}
)
.
eventPromise
;
}
function
requestViaPicture
(
url
)
{
var
picture
=
createMediaElement
(
"
picture
"
{
}
{
"
srcset
"
:
url
"
type
"
:
"
image
/
png
"
}
)
;
return
createRequestViaElement
(
"
img
"
{
"
src
"
:
url
}
picture
)
;
}
function
requestViaObject
(
url
)
{
return
createRequestViaElement
(
"
object
"
{
"
data
"
:
url
"
type
"
:
"
text
/
html
"
}
document
.
body
)
;
}
function
requestViaWebSocket
(
url
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
websocket
=
new
WebSocket
(
url
)
;
websocket
.
addEventListener
(
"
message
"
function
(
e
)
{
resolve
(
e
.
data
)
;
}
)
;
websocket
.
addEventListener
(
"
open
"
function
(
e
)
{
websocket
.
send
(
"
echo
"
)
;
}
)
;
websocket
.
addEventListener
(
"
error
"
function
(
e
)
{
reject
(
e
)
}
)
;
}
)
.
then
(
data
=
>
{
return
JSON
.
parse
(
data
)
;
}
)
;
}
const
subresourceMap
=
{
"
a
-
tag
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
document
.
py
"
invoker
:
requestViaAnchor
}
"
area
-
tag
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
document
.
py
"
invoker
:
requestViaArea
}
"
audio
-
tag
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
audio
.
py
"
invoker
:
requestViaAudio
}
"
beacon
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
empty
.
py
"
invoker
:
requestViaSendBeacon
}
"
fetch
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
xhr
.
py
"
invoker
:
requestViaFetch
}
"
form
-
tag
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
empty
.
py
"
invoker
:
requestViaForm
}
"
iframe
-
tag
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
document
.
py
"
invoker
:
requestViaIframe
}
"
img
-
tag
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
image
.
py
"
invoker
:
requestViaImage
}
"
link
-
css
-
tag
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
empty
.
py
"
invoker
:
requestViaLinkStylesheet
}
"
link
-
prefetch
-
tag
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
empty
.
py
"
invoker
:
requestViaLinkPrefetch
}
"
object
-
tag
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
empty
.
py
"
invoker
:
requestViaObject
}
"
picture
-
tag
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
image
.
py
"
invoker
:
requestViaPicture
}
"
script
-
tag
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
script
.
py
"
invoker
:
requestViaScript
}
"
video
-
tag
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
video
.
py
"
invoker
:
requestViaVideo
}
"
xhr
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
xhr
.
py
"
invoker
:
requestViaXhr
}
"
worker
-
classic
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
worker
.
py
"
invoker
:
url
=
>
requestViaDedicatedWorker
(
url
)
}
"
worker
-
module
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
worker
.
py
"
invoker
:
url
=
>
requestViaDedicatedWorker
(
url
{
type
:
"
module
"
}
)
}
"
worker
-
import
-
data
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
worker
.
py
"
invoker
:
url
=
>
requestViaDedicatedWorker
(
workerUrlThatImports
(
url
)
{
type
:
"
module
"
}
)
}
"
sharedworker
-
classic
"
:
{
path
:
"
/
common
/
security
-
features
/
subresource
/
shared
-
worker
.
py
"
invoker
:
requestViaSharedWorker
}
"
websocket
"
:
{
path
:
"
/
stash_responder
"
invoker
:
requestViaWebSocket
}
}
;
for
(
const
workletType
of
[
'
animation
'
'
audio
'
'
layout
'
'
paint
'
]
)
{
subresourceMap
[
worklet
-
{
workletType
}
]
=
{
path
:
"
/
common
/
security
-
features
/
subresource
/
worker
.
py
"
invoker
:
url
=
>
requestViaWorklet
(
workletType
url
)
}
;
subresourceMap
[
worklet
-
{
workletType
}
-
import
-
data
]
=
{
path
:
"
/
common
/
security
-
features
/
subresource
/
worker
.
py
"
invoker
:
url
=
>
requestViaWorklet
(
workletType
workerUrlThatImports
(
url
)
)
}
;
}
function
getSubresourceOrigin
(
originType
)
{
const
httpProtocol
=
"
http
"
;
const
httpsProtocol
=
"
https
"
;
const
wsProtocol
=
"
ws
"
;
const
wssProtocol
=
"
wss
"
;
const
sameOriginHost
=
"
{
{
host
}
}
"
;
const
crossOriginHost
=
"
{
{
domains
[
www1
]
}
}
"
;
const
httpPort
=
getNormalizedPort
(
parseInt
(
"
{
{
ports
[
http
]
[
0
]
}
}
"
10
)
)
;
const
httpsRawPort
=
parseInt
(
"
{
{
ports
[
https
]
[
0
]
}
}
"
10
)
;
const
httpsPort
=
getNormalizedPort
(
httpsRawPort
)
;
const
wsPort
=
getNormalizedPort
(
parseInt
(
"
{
{
ports
[
ws
]
[
0
]
}
}
"
10
)
)
;
const
wssRawPort
=
parseInt
(
"
{
{
ports
[
wss
]
[
0
]
}
}
"
10
)
;
const
wssPort
=
getNormalizedPort
(
wssRawPort
)
;
const
originMap
=
{
"
same
-
https
"
:
httpsProtocol
+
"
:
/
/
"
+
sameOriginHost
+
httpsPort
"
same
-
http
"
:
httpProtocol
+
"
:
/
/
"
+
sameOriginHost
+
httpPort
"
cross
-
https
"
:
httpsProtocol
+
"
:
/
/
"
+
crossOriginHost
+
httpsPort
"
cross
-
http
"
:
httpProtocol
+
"
:
/
/
"
+
crossOriginHost
+
httpPort
"
same
-
wss
"
:
wssProtocol
+
"
:
/
/
"
+
sameOriginHost
+
wssPort
"
same
-
ws
"
:
wsProtocol
+
"
:
/
/
"
+
sameOriginHost
+
wsPort
"
cross
-
wss
"
:
wssProtocol
+
"
:
/
/
"
+
crossOriginHost
+
wssPort
"
cross
-
ws
"
:
wsProtocol
+
"
:
/
/
"
+
crossOriginHost
+
wsPort
"
same
-
http
-
downgrade
"
:
httpProtocol
+
"
:
/
/
"
+
sameOriginHost
+
"
:
"
+
httpsRawPort
"
cross
-
http
-
downgrade
"
:
httpProtocol
+
"
:
/
/
"
+
crossOriginHost
+
"
:
"
+
httpsRawPort
"
same
-
ws
-
downgrade
"
:
wsProtocol
+
"
:
/
/
"
+
sameOriginHost
+
"
:
"
+
wssRawPort
"
cross
-
ws
-
downgrade
"
:
wsProtocol
+
"
:
/
/
"
+
crossOriginHost
+
"
:
"
+
wssRawPort
}
;
return
originMap
[
originType
]
;
}
function
getRequestURLs
(
subresourceType
originType
redirectionType
)
{
const
key
=
guid
(
)
;
const
value
=
guid
(
)
;
const
stashPath
=
encodeURIComponent
(
"
/
mixed
-
content
"
)
;
const
stashEndpoint
=
"
/
common
/
security
-
features
/
subresource
/
xhr
.
py
?
key
=
"
+
key
+
"
&
path
=
"
+
stashPath
;
return
{
testUrl
:
getSubresourceOrigin
(
originType
)
+
subresourceMap
[
subresourceType
]
.
path
+
"
?
redirection
=
"
+
encodeURIComponent
(
redirectionType
)
+
"
&
action
=
purge
&
key
=
"
+
key
+
"
&
path
=
"
+
stashPath
announceUrl
:
stashEndpoint
+
"
&
action
=
put
&
value
=
"
+
value
assertUrl
:
stashEndpoint
+
"
&
action
=
take
"
}
;
}
function
invokeRequest
(
subresource
sourceContextList
)
{
if
(
sourceContextList
.
length
=
=
=
0
)
{
const
additionalAttributes
=
{
}
;
for
(
const
policyDelivery
of
(
subresource
.
policyDeliveries
|
|
[
]
)
)
{
if
(
policyDelivery
.
deliveryType
=
=
=
"
attr
"
)
{
additionalAttributes
[
policyDelivery
.
key
]
=
policyDelivery
.
value
;
}
else
if
(
policyDelivery
.
deliveryType
=
=
=
"
rel
-
noref
"
)
{
additionalAttributes
[
"
rel
"
]
=
"
noreferrer
"
;
}
}
return
subresourceMap
[
subresource
.
subresourceType
]
.
invoker
(
subresource
.
url
additionalAttributes
)
.
then
(
result
=
>
Object
.
assign
(
{
sourceContextUrl
:
location
.
toString
(
)
}
result
)
)
;
}
const
sourceContextMap
=
{
"
srcdoc
"
:
{
invoker
:
invokeFromIframe
}
"
iframe
"
:
{
invoker
:
invokeFromIframe
}
"
iframe
-
blank
"
:
{
invoker
:
invokeFromIframe
}
"
worker
-
classic
"
:
{
invoker
:
invokeFromWorker
.
bind
(
undefined
false
{
}
)
}
"
worker
-
classic
-
data
"
:
{
invoker
:
invokeFromWorker
.
bind
(
undefined
true
{
}
)
}
"
worker
-
module
"
:
{
invoker
:
invokeFromWorker
.
bind
(
undefined
false
{
type
:
'
module
'
}
)
}
"
worker
-
module
-
data
"
:
{
invoker
:
invokeFromWorker
.
bind
(
undefined
true
{
type
:
'
module
'
}
)
}
}
;
return
sourceContextMap
[
sourceContextList
[
0
]
.
sourceContextType
]
.
invoker
(
subresource
sourceContextList
)
;
}
self
.
invokeRequest
=
invokeRequest
;
function
invokeFromWorker
(
isDataUrl
workerOptions
subresource
sourceContextList
)
{
const
currentSourceContext
=
sourceContextList
[
0
]
;
let
workerUrl
=
"
/
common
/
security
-
features
/
scope
/
worker
.
py
?
policyDeliveries
=
"
+
encodeURIComponent
(
JSON
.
stringify
(
currentSourceContext
.
policyDeliveries
|
|
[
]
)
)
;
if
(
workerOptions
.
type
=
=
=
'
module
'
)
{
workerUrl
+
=
"
&
type
=
module
"
;
}
let
promise
;
if
(
isDataUrl
)
{
promise
=
fetch
(
workerUrl
)
.
then
(
r
=
>
r
.
text
(
)
)
.
then
(
source
=
>
{
return
'
data
:
text
/
javascript
;
base64
'
+
btoa
(
source
)
;
}
)
;
}
else
{
promise
=
Promise
.
resolve
(
workerUrl
)
;
}
return
promise
.
then
(
url
=
>
{
const
worker
=
new
Worker
(
url
workerOptions
)
;
worker
.
postMessage
(
{
subresource
:
subresource
sourceContextList
:
sourceContextList
.
slice
(
1
)
}
)
;
return
bindEvents2
(
worker
"
message
"
worker
"
error
"
window
"
error
"
)
;
}
)
.
then
(
event
=
>
{
if
(
event
.
data
.
error
)
return
Promise
.
reject
(
event
.
data
.
error
)
;
return
event
.
data
;
}
)
;
}
function
invokeFromIframe
(
subresource
sourceContextList
)
{
const
currentSourceContext
=
sourceContextList
[
0
]
;
const
frameUrl
=
"
/
common
/
security
-
features
/
scope
/
document
.
py
?
policyDeliveries
=
"
+
encodeURIComponent
(
JSON
.
stringify
(
currentSourceContext
.
policyDeliveries
|
|
[
]
)
)
;
let
iframe
;
let
promise
;
if
(
currentSourceContext
.
sourceContextType
=
=
=
'
srcdoc
'
)
{
promise
=
fetch
(
frameUrl
)
.
then
(
r
=
>
r
.
text
(
)
)
.
then
(
srcdoc
=
>
{
iframe
=
createElement
(
"
iframe
"
{
srcdoc
:
srcdoc
}
document
.
body
true
)
;
return
iframe
.
eventPromise
;
}
)
;
}
else
if
(
currentSourceContext
.
sourceContextType
=
=
=
'
iframe
'
)
{
iframe
=
createElement
(
"
iframe
"
{
src
:
frameUrl
}
document
.
body
true
)
;
promise
=
iframe
.
eventPromise
;
}
else
if
(
currentSourceContext
.
sourceContextType
=
=
=
'
iframe
-
blank
'
)
{
let
frameContent
;
promise
=
fetch
(
frameUrl
)
.
then
(
r
=
>
r
.
text
(
)
)
.
then
(
t
=
>
{
frameContent
=
t
;
iframe
=
createElement
(
"
iframe
"
{
}
document
.
body
true
)
;
return
iframe
.
eventPromise
;
}
)
.
then
(
(
)
=
>
{
bindEvents
(
iframe
)
;
iframe
.
contentDocument
.
write
(
frameContent
)
;
iframe
.
contentDocument
.
close
(
)
;
return
iframe
.
eventPromise
;
}
)
;
}
return
promise
.
then
(
(
)
=
>
{
const
promise
=
bindEvents2
(
window
"
message
"
iframe
"
error
"
window
"
error
"
)
;
iframe
.
contentWindow
.
postMessage
(
{
subresource
:
subresource
sourceContextList
:
sourceContextList
.
slice
(
1
)
}
"
*
"
)
;
return
promise
;
}
)
.
then
(
event
=
>
{
if
(
event
.
data
.
error
)
return
Promise
.
reject
(
event
.
data
.
error
)
;
return
event
.
data
;
}
)
;
}
function
SanityChecker
(
)
{
}
SanityChecker
.
prototype
.
checkScenario
=
function
(
)
{
}
;
SanityChecker
.
prototype
.
setFailTimeout
=
function
(
test
timeout
)
{
}
;
SanityChecker
.
prototype
.
checkSubresourceResult
=
function
(
)
{
}
;
