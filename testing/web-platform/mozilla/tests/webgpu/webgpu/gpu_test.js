import
{
Fixture
SkipTestCase
SubcaseBatchState
}
from
'
.
.
/
common
/
framework
/
fixture
.
js
'
;
import
{
globalTestConfig
}
from
'
.
.
/
common
/
framework
/
test_config
.
js
'
;
import
{
assert
makeValueTestVariant
memcpy
range
unreachable
}
from
'
.
.
/
common
/
util
/
util
.
js
'
;
import
{
getDefaultLimits
kQueryTypeInfo
}
from
'
.
/
capability_info
.
js
'
;
import
{
kTextureFormatInfo
kEncodableTextureFormats
resolvePerAspectFormat
isCompressedTextureFormat
}
from
'
.
/
format_info
.
js
'
;
import
{
makeBufferWithContents
}
from
'
.
/
util
/
buffer
.
js
'
;
import
{
checkElementsEqual
checkElementsBetween
}
from
'
.
/
util
/
check_contents
.
js
'
;
import
{
CommandBufferMaker
}
from
'
.
/
util
/
command_buffer_maker
.
js
'
;
import
{
DevicePool
}
from
'
.
/
util
/
device_pool
.
js
'
;
import
{
align
roundDown
}
from
'
.
/
util
/
math
.
js
'
;
import
{
physicalMipSizeFromTexture
virtualMipSize
}
from
'
.
/
util
/
texture
/
base
.
js
'
;
import
{
bytesInACompleteRow
getTextureCopyLayout
getTextureSubCopyLayout
}
from
'
.
/
util
/
texture
/
layout
.
js
'
;
import
{
kTexelRepresentationInfo
}
from
'
.
/
util
/
texture
/
texel_data
.
js
'
;
import
{
TexelView
}
from
'
.
/
util
/
texture
/
texel_view
.
js
'
;
import
{
textureContentIsOKByT2B
}
from
'
.
/
util
/
texture
/
texture_ok
.
js
'
;
import
{
createTextureFromTexelView
createTextureFromTexelViews
}
from
'
.
/
util
/
texture
.
js
'
;
import
{
reifyOrigin3D
}
from
'
.
/
util
/
unions
.
js
'
;
const
devicePool
=
new
DevicePool
(
)
;
const
mismatchedDevicePool
=
new
DevicePool
(
)
;
const
kResourceStateValues
=
[
'
valid
'
'
invalid
'
'
destroyed
'
]
;
export
const
kResourceStates
=
kResourceStateValues
;
export
function
initUncanonicalizedDeviceDescriptor
(
descriptor
)
{
if
(
typeof
descriptor
=
=
=
'
string
'
)
{
return
{
requiredFeatures
:
[
descriptor
]
}
;
}
else
if
(
descriptor
instanceof
Array
)
{
return
{
requiredFeatures
:
descriptor
.
filter
(
(
f
)
=
>
f
!
=
=
undefined
)
}
;
}
else
{
return
descriptor
;
}
}
export
class
GPUTestSubcaseBatchState
extends
SubcaseBatchState
{
async
postInit
(
)
{
await
this
.
acquireProvider
(
)
;
}
async
finalize
(
)
{
await
super
.
finalize
(
)
;
await
Promise
.
all
(
[
this
.
provider
?
.
then
(
(
x
)
=
>
devicePool
.
release
(
x
)
)
this
.
mismatchedProvider
?
.
then
(
(
x
)
=
>
devicePool
.
release
(
x
)
)
]
)
;
}
acquireProvider
(
)
{
if
(
this
.
provider
=
=
=
undefined
)
{
this
.
selectDeviceOrSkipTestCase
(
undefined
)
;
}
assert
(
this
.
provider
!
=
=
undefined
)
;
return
this
.
provider
;
}
get
isCompatibility
(
)
{
return
globalTestConfig
.
compatibility
;
}
getDefaultLimits
(
)
{
return
getDefaultLimits
(
this
.
isCompatibility
?
'
compatibility
'
:
'
core
'
)
;
}
selectDeviceOrSkipTestCase
(
descriptor
)
{
assert
(
this
.
provider
=
=
=
undefined
"
Can
'
t
selectDeviceOrSkipTestCase
(
)
multiple
times
"
)
;
this
.
provider
=
devicePool
.
acquire
(
this
.
recorder
initUncanonicalizedDeviceDescriptor
(
descriptor
)
)
;
this
.
provider
.
catch
(
(
)
=
>
{
}
)
;
}
selectDeviceForTextureFormatOrSkipTestCase
(
formats
)
{
if
(
!
Array
.
isArray
(
formats
)
)
{
formats
=
[
formats
]
;
}
const
features
=
new
Set
(
)
;
for
(
const
format
of
formats
)
{
if
(
format
!
=
=
undefined
)
{
this
.
skipIfTextureFormatNotSupported
(
format
)
;
features
.
add
(
kTextureFormatInfo
[
format
]
.
feature
)
;
}
}
this
.
selectDeviceOrSkipTestCase
(
Array
.
from
(
features
)
)
;
}
selectDeviceForQueryTypeOrSkipTestCase
(
types
)
{
if
(
!
Array
.
isArray
(
types
)
)
{
types
=
[
types
]
;
}
const
features
=
types
.
map
(
(
t
)
=
>
kQueryTypeInfo
[
t
]
.
feature
)
;
this
.
selectDeviceOrSkipTestCase
(
features
)
;
}
acquireMismatchedProvider
(
)
{
return
this
.
mismatchedProvider
;
}
selectMismatchedDeviceOrSkipTestCase
(
descriptor
)
{
assert
(
this
.
mismatchedProvider
=
=
=
undefined
"
Can
'
t
selectMismatchedDeviceOrSkipTestCase
(
)
multiple
times
"
)
;
this
.
mismatchedProvider
=
mismatchedDevicePool
.
acquire
(
this
.
recorder
initUncanonicalizedDeviceDescriptor
(
descriptor
)
)
;
this
.
mismatchedProvider
.
catch
(
(
)
=
>
{
}
)
;
}
skip
(
msg
)
{
throw
new
SkipTestCase
(
msg
)
;
}
skipIf
(
cond
msg
=
'
'
)
{
if
(
cond
)
{
this
.
skip
(
typeof
msg
=
=
=
'
function
'
?
msg
(
)
:
msg
)
;
}
}
skipIfTextureFormatNotSupported
(
.
.
.
formats
)
{
if
(
this
.
isCompatibility
)
{
for
(
const
format
of
formats
)
{
if
(
format
=
=
=
'
bgra8unorm
-
srgb
'
)
{
this
.
skip
(
texture
format
'
{
format
}
is
not
supported
)
;
}
}
}
}
skipIfCopyTextureToTextureNotSupportedForFormat
(
.
.
.
formats
)
{
if
(
this
.
isCompatibility
)
{
for
(
const
format
of
formats
)
{
if
(
format
&
&
isCompressedTextureFormat
(
format
)
)
{
this
.
skip
(
copyTextureToTexture
with
{
format
}
is
not
supported
)
;
}
}
}
}
skipIfTextureViewDimensionNotSupported
(
.
.
.
dimensions
)
{
if
(
this
.
isCompatibility
)
{
for
(
const
dimension
of
dimensions
)
{
if
(
dimension
=
=
=
'
cube
-
array
'
)
{
this
.
skip
(
texture
view
dimension
'
{
dimension
}
'
is
not
supported
)
;
}
}
}
}
}
export
class
GPUTestBase
extends
Fixture
{
static
MakeSharedState
(
recorder
params
)
{
return
new
GPUTestSubcaseBatchState
(
recorder
params
)
;
}
get
device
(
)
{
unreachable
(
)
;
return
null
;
}
get
queue
(
)
{
return
this
.
device
.
queue
;
}
get
isCompatibility
(
)
{
return
globalTestConfig
.
compatibility
;
}
getDefaultLimits
(
)
{
return
getDefaultLimits
(
this
.
isCompatibility
?
'
compatibility
'
:
'
core
'
)
;
}
getDefaultLimit
(
limit
)
{
return
this
.
getDefaultLimits
(
)
[
limit
]
.
default
;
}
makeLimitVariant
(
limit
variant
)
{
return
makeValueTestVariant
(
this
.
device
.
limits
[
limit
]
variant
)
;
}
canCallCopyTextureToBufferWithTextureFormat
(
format
)
{
return
!
this
.
isCompatibility
|
|
!
isCompressedTextureFormat
(
format
)
;
}
createCopyForMapRead
(
src
srcOffset
size
)
{
assert
(
srcOffset
%
4
=
=
=
0
)
;
assert
(
size
%
4
=
=
=
0
)
;
const
dst
=
this
.
device
.
createBuffer
(
{
size
usage
:
GPUBufferUsage
.
MAP_READ
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
dst
)
;
const
c
=
this
.
device
.
createCommandEncoder
(
)
;
c
.
copyBufferToBuffer
(
src
srcOffset
dst
0
size
)
;
this
.
queue
.
submit
(
[
c
.
finish
(
)
]
)
;
return
dst
;
}
createAlignedCopyForMapRead
(
src
size
offset
)
{
const
alignedOffset
=
roundDown
(
offset
4
)
;
const
subarrayByteStart
=
offset
-
alignedOffset
;
const
alignedSize
=
align
(
size
+
subarrayByteStart
4
)
;
const
mappable
=
this
.
createCopyForMapRead
(
src
alignedOffset
alignedSize
)
;
return
{
mappable
subarrayByteStart
}
;
}
async
readGPUBufferRangeTyped
(
src
{
srcByteOffset
=
0
method
=
'
copy
'
type
typedLength
}
)
{
assert
(
srcByteOffset
%
type
.
BYTES_PER_ELEMENT
=
=
=
0
'
srcByteOffset
must
be
a
multiple
of
BYTES_PER_ELEMENT
'
)
;
const
byteLength
=
typedLength
*
type
.
BYTES_PER_ELEMENT
;
let
mappable
;
let
mapOffset
mapSize
subarrayByteStart
;
if
(
method
=
=
=
'
copy
'
)
{
(
{
mappable
subarrayByteStart
}
=
this
.
createAlignedCopyForMapRead
(
src
byteLength
srcByteOffset
)
)
;
}
else
if
(
method
=
=
=
'
map
'
)
{
mappable
=
src
;
mapOffset
=
roundDown
(
srcByteOffset
8
)
;
mapSize
=
align
(
byteLength
4
)
;
subarrayByteStart
=
srcByteOffset
-
mapOffset
;
}
else
{
unreachable
(
)
;
}
assert
(
subarrayByteStart
%
type
.
BYTES_PER_ELEMENT
=
=
=
0
)
;
const
subarrayStart
=
subarrayByteStart
/
type
.
BYTES_PER_ELEMENT
;
await
mappable
.
mapAsync
(
GPUMapMode
.
READ
mapOffset
mapSize
)
;
const
mapped
=
new
type
(
mappable
.
getMappedRange
(
mapOffset
mapSize
)
)
;
const
data
=
mapped
.
subarray
(
subarrayStart
typedLength
)
;
return
{
data
cleanup
(
)
{
mappable
.
unmap
(
)
;
mappable
.
destroy
(
)
;
}
}
;
}
skipIfTextureFormatNotSupported
(
.
.
.
formats
)
{
if
(
this
.
isCompatibility
)
{
for
(
const
format
of
formats
)
{
if
(
format
=
=
=
'
bgra8unorm
-
srgb
'
)
{
this
.
skip
(
texture
format
'
{
format
}
is
not
supported
)
;
}
}
}
}
skipIfTextureViewDimensionNotSupported
(
.
.
.
dimensions
)
{
if
(
this
.
isCompatibility
)
{
for
(
const
dimension
of
dimensions
)
{
if
(
dimension
=
=
=
'
cube
-
array
'
)
{
this
.
skip
(
texture
view
dimension
'
{
dimension
}
'
is
not
supported
)
;
}
}
}
}
skipIfCopyTextureToTextureNotSupportedForFormat
(
.
.
.
formats
)
{
if
(
this
.
isCompatibility
)
{
for
(
const
format
of
formats
)
{
if
(
format
&
&
isCompressedTextureFormat
(
format
)
)
{
this
.
skip
(
copyTextureToTexture
with
{
format
}
is
not
supported
)
;
}
}
}
}
expectGPUBufferValuesPassCheck
(
src
check
{
srcByteOffset
=
0
type
typedLength
method
=
'
copy
'
mode
=
'
fail
'
}
)
{
const
readbackPromise
=
this
.
readGPUBufferRangeTyped
(
src
{
srcByteOffset
type
typedLength
method
}
)
;
this
.
eventualAsyncExpectation
(
async
(
niceStack
)
=
>
{
const
readback
=
await
readbackPromise
;
this
.
expectOK
(
check
(
readback
.
data
)
{
mode
niceStack
}
)
;
readback
.
cleanup
(
)
;
}
)
;
}
expectGPUBufferValuesEqual
(
src
expected
srcByteOffset
=
0
{
method
=
'
copy
'
mode
=
'
fail
'
}
=
{
}
)
{
this
.
expectGPUBufferValuesPassCheck
(
src
(
a
)
=
>
checkElementsEqual
(
a
expected
)
{
srcByteOffset
type
:
expected
.
constructor
typedLength
:
expected
.
length
method
mode
}
)
;
}
expectGPUBufferRepeatsSingleValue
(
buffer
{
expectedValue
numRows
minBytesPerRow
bytesPerRow
}
)
{
const
valueSize
=
expectedValue
.
byteLength
;
assert
(
valueSize
=
=
=
1
|
|
valueSize
=
=
=
2
|
|
valueSize
%
4
=
=
=
0
)
;
assert
(
minBytesPerRow
%
valueSize
=
=
=
0
)
;
assert
(
bytesPerRow
%
4
=
=
=
0
)
;
const
kMaxBufferSizeToCheckOnCpu
=
256
*
1024
;
const
bufferSize
=
bytesPerRow
*
(
numRows
-
1
)
+
minBytesPerRow
;
if
(
bufferSize
<
=
kMaxBufferSizeToCheckOnCpu
)
{
const
valueBytes
=
Array
.
from
(
new
Uint8Array
(
expectedValue
)
)
;
const
rowValues
=
new
Array
(
minBytesPerRow
/
valueSize
)
.
fill
(
valueBytes
)
;
const
rowBytes
=
new
Uint8Array
(
[
]
.
concat
(
.
.
.
rowValues
)
)
;
const
expectedContents
=
new
Uint8Array
(
bufferSize
)
;
range
(
numRows
(
row
)
=
>
expectedContents
.
set
(
rowBytes
row
*
bytesPerRow
)
)
;
this
.
expectGPUBufferValuesEqual
(
buffer
expectedContents
)
;
return
;
}
const
storageBuffer
=
this
.
device
.
createBuffer
(
{
size
:
bufferSize
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
storageBuffer
)
;
const
expectedDataSize
=
Math
.
max
(
4
valueSize
)
;
const
expectedDataBuffer
=
this
.
device
.
createBuffer
(
{
size
:
expectedDataSize
usage
:
GPUBufferUsage
.
STORAGE
mappedAtCreation
:
true
}
)
;
this
.
trackForCleanup
(
expectedDataBuffer
)
;
const
expectedData
=
new
Uint32Array
(
expectedDataBuffer
.
getMappedRange
(
)
)
;
if
(
valueSize
=
=
=
1
)
{
const
value
=
new
Uint8Array
(
expectedValue
)
[
0
]
;
const
values
=
new
Array
(
Math
.
min
(
4
minBytesPerRow
)
)
.
fill
(
value
)
;
const
padding
=
new
Array
(
Math
.
max
(
0
4
-
values
.
length
)
)
.
fill
(
0
)
;
const
expectedBytes
=
new
Uint8Array
(
expectedData
.
buffer
)
;
expectedBytes
.
set
(
[
.
.
.
values
.
.
.
padding
]
)
;
}
else
if
(
valueSize
=
=
=
2
)
{
const
value
=
new
Uint16Array
(
expectedValue
)
[
0
]
;
const
expectedWords
=
new
Uint16Array
(
expectedData
.
buffer
)
;
expectedWords
.
set
(
[
value
minBytesPerRow
>
2
?
value
:
0
]
)
;
}
else
{
expectedData
.
set
(
new
Uint32Array
(
expectedValue
)
)
;
}
expectedDataBuffer
.
unmap
(
)
;
const
resultBuffer
=
this
.
device
.
createBuffer
(
{
size
:
numRows
*
4
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_SRC
}
)
;
this
.
trackForCleanup
(
resultBuffer
)
;
const
readsPerRow
=
Math
.
ceil
(
minBytesPerRow
/
expectedDataSize
)
;
const
reducer
=
struct
Buffer
{
data
:
array
<
u32
>
}
;
group
(
0
)
binding
(
0
)
var
<
storage
read
>
expected
:
Buffer
;
group
(
0
)
binding
(
1
)
var
<
storage
read
>
in
:
Buffer
;
group
(
0
)
binding
(
2
)
var
<
storage
read_write
>
out
:
Buffer
;
compute
workgroup_size
(
1
)
fn
reduce
(
builtin
(
global_invocation_id
)
id
:
vec3
<
u32
>
)
{
let
rowBaseIndex
=
id
.
x
*
{
bytesPerRow
/
4
}
u
;
let
readSize
=
{
expectedDataSize
/
4
}
u
;
out
.
data
[
id
.
x
]
=
1u
;
for
(
var
i
:
u32
=
0u
;
i
<
{
readsPerRow
}
u
;
i
=
i
+
1u
)
{
let
elementBaseIndex
=
rowBaseIndex
+
i
*
readSize
;
for
(
var
j
:
u32
=
0u
;
j
<
readSize
;
j
=
j
+
1u
)
{
if
(
in
.
data
[
elementBaseIndex
+
j
]
!
=
expected
.
data
[
j
]
)
{
out
.
data
[
id
.
x
]
=
0u
;
return
;
}
}
}
}
;
const
pipeline
=
this
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
reducer
}
)
entryPoint
:
'
reduce
'
}
}
)
;
const
bindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
expectedDataBuffer
}
}
{
binding
:
1
resource
:
{
buffer
:
storageBuffer
}
}
{
binding
:
2
resource
:
{
buffer
:
resultBuffer
}
}
]
}
)
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
copyBufferToBuffer
(
buffer
0
storageBuffer
0
bufferSize
)
;
const
pass
=
commandEncoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
bindGroup
)
;
pass
.
dispatchWorkgroups
(
numRows
)
;
pass
.
end
(
)
;
this
.
device
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
const
expectedResults
=
new
Array
(
numRows
)
.
fill
(
1
)
;
this
.
expectGPUBufferValuesEqual
(
resultBuffer
new
Uint32Array
(
expectedResults
)
)
;
}
expectSingleColor
(
src
format
{
size
exp
dimension
=
'
2d
'
slice
=
0
layout
}
)
{
assert
(
slice
=
=
=
0
|
|
dimension
=
=
=
'
2d
'
'
texture
slices
are
only
implemented
for
2d
textures
'
)
;
format
=
resolvePerAspectFormat
(
format
layout
?
.
aspect
)
;
const
{
byteLength
minBytesPerRow
bytesPerRow
rowsPerImage
mipSize
}
=
getTextureCopyLayout
(
format
dimension
size
layout
)
;
const
copySize
=
[
mipSize
[
0
]
dimension
!
=
=
'
1d
'
?
mipSize
[
1
]
:
1
dimension
=
=
=
'
3d
'
?
mipSize
[
2
]
:
1
]
;
const
rep
=
kTexelRepresentationInfo
[
format
]
;
const
expectedTexelData
=
rep
.
pack
(
rep
.
encode
(
exp
)
)
;
const
buffer
=
this
.
device
.
createBuffer
(
{
size
:
byteLength
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
buffer
)
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
copyTextureToBuffer
(
{
texture
:
src
mipLevel
:
layout
?
.
mipLevel
origin
:
{
x
:
0
y
:
0
z
:
slice
}
aspect
:
layout
?
.
aspect
}
{
buffer
bytesPerRow
rowsPerImage
}
copySize
)
;
this
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
this
.
expectGPUBufferRepeatsSingleValue
(
buffer
{
expectedValue
:
expectedTexelData
numRows
:
rowsPerImage
*
copySize
[
2
]
minBytesPerRow
bytesPerRow
}
)
;
}
readSinglePixelFrom2DTexture
(
src
format
{
x
y
}
{
slice
=
0
layout
}
)
{
const
{
byteLength
bytesPerRow
rowsPerImage
}
=
getTextureSubCopyLayout
(
format
[
1
1
]
layout
)
;
const
buffer
=
this
.
device
.
createBuffer
(
{
size
:
byteLength
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
buffer
)
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
copyTextureToBuffer
(
{
texture
:
src
mipLevel
:
layout
?
.
mipLevel
origin
:
{
x
y
z
:
slice
}
}
{
buffer
bytesPerRow
rowsPerImage
}
[
1
1
]
)
;
this
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
return
buffer
;
}
expectSinglePixelBetweenTwoValuesIn2DTexture
(
src
format
{
x
y
}
{
exp
slice
=
0
layout
generateWarningOnly
=
false
checkElementsBetweenFn
=
(
act
[
a
b
]
)
=
>
checkElementsBetween
(
act
[
(
i
)
=
>
a
[
i
]
(
i
)
=
>
b
[
i
]
]
)
}
)
{
assert
(
exp
[
0
]
.
constructor
=
=
=
exp
[
1
]
.
constructor
)
;
const
constructor
=
exp
[
0
]
.
constructor
;
assert
(
exp
[
0
]
.
length
=
=
=
exp
[
1
]
.
length
)
;
const
typedLength
=
exp
[
0
]
.
length
;
const
buffer
=
this
.
readSinglePixelFrom2DTexture
(
src
format
{
x
y
}
{
slice
layout
}
)
;
this
.
expectGPUBufferValuesPassCheck
(
buffer
(
a
)
=
>
checkElementsBetweenFn
(
a
exp
)
{
type
:
constructor
typedLength
mode
:
generateWarningOnly
?
'
warn
'
:
'
fail
'
}
)
;
}
copySinglePixelTextureToBufferUsingComputePass
(
type
componentCount
textureView
sampleCount
)
{
const
textureSrcCode
=
sampleCount
=
=
=
1
?
group
(
0
)
binding
(
0
)
var
src
:
texture_2d
<
{
type
}
>
;
:
group
(
0
)
binding
(
0
)
var
src
:
texture_multisampled_2d
<
{
type
}
>
;
;
const
code
=
struct
Buffer
{
data
:
array
<
{
type
}
>
}
;
{
textureSrcCode
}
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
dst
:
Buffer
;
compute
workgroup_size
(
1
)
fn
main
(
)
{
var
coord
=
vec2
<
i32
>
(
0
0
)
;
for
(
var
sampleIndex
=
0
;
sampleIndex
<
{
sampleCount
}
;
sampleIndex
=
sampleIndex
+
1
)
{
let
o
=
sampleIndex
*
{
componentCount
}
;
let
v
=
textureLoad
(
src
coord
sampleIndex
)
;
for
(
var
component
=
0
;
component
<
{
componentCount
}
;
component
=
component
+
1
)
{
dst
.
data
[
o
+
component
]
=
v
[
component
]
;
}
}
}
;
const
computePipeline
=
this
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
}
)
entryPoint
:
'
main
'
}
}
)
;
const
storageBuffer
=
this
.
device
.
createBuffer
(
{
size
:
sampleCount
*
type
.
size
*
componentCount
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
COPY_SRC
}
)
;
this
.
trackForCleanup
(
storageBuffer
)
;
const
uniformBindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
computePipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
textureView
}
{
binding
:
1
resource
:
{
buffer
:
storageBuffer
}
}
]
}
)
;
const
encoder
=
this
.
device
.
createCommandEncoder
(
)
;
const
pass
=
encoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
computePipeline
)
;
pass
.
setBindGroup
(
0
uniformBindGroup
)
;
pass
.
dispatchWorkgroups
(
1
)
;
pass
.
end
(
)
;
this
.
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
return
storageBuffer
;
}
expectGPUError
(
filter
fn
shouldError
=
true
)
{
if
(
!
shouldError
)
{
return
fn
(
)
;
}
this
.
device
.
pushErrorScope
(
filter
)
;
const
returnValue
=
fn
(
)
;
const
promise
=
this
.
device
.
popErrorScope
(
)
;
this
.
eventualAsyncExpectation
(
async
(
niceStack
)
=
>
{
const
error
=
await
promise
;
let
failed
=
false
;
switch
(
filter
)
{
case
'
out
-
of
-
memory
'
:
failed
=
!
(
error
instanceof
GPUOutOfMemoryError
)
;
break
;
case
'
validation
'
:
failed
=
!
(
error
instanceof
GPUValidationError
)
;
break
;
}
if
(
failed
)
{
niceStack
.
message
=
Expected
{
filter
}
error
;
this
.
rec
.
expectationFailed
(
niceStack
)
;
}
else
{
niceStack
.
message
=
Captured
{
filter
}
error
;
if
(
error
instanceof
GPUValidationError
)
{
niceStack
.
message
+
=
-
{
error
.
message
}
;
}
this
.
rec
.
debug
(
niceStack
)
;
}
}
)
;
return
returnValue
;
}
expectValidationError
(
fn
shouldError
=
true
)
{
if
(
shouldError
)
{
this
.
device
.
pushErrorScope
(
'
validation
'
)
;
}
const
returnValue
=
fn
(
)
;
assert
(
returnValue
=
=
=
undefined
'
expectValidationError
callback
should
not
return
a
value
(
or
be
async
)
'
)
;
if
(
shouldError
)
{
const
promise
=
this
.
device
.
popErrorScope
(
)
;
this
.
eventualAsyncExpectation
(
async
(
niceStack
)
=
>
{
const
gpuValidationError
=
await
promise
;
if
(
!
gpuValidationError
)
{
niceStack
.
message
=
'
Validation
succeeded
unexpectedly
.
'
;
this
.
rec
.
validationFailed
(
niceStack
)
;
}
else
if
(
gpuValidationError
instanceof
GPUValidationError
)
{
niceStack
.
message
=
Validation
failed
as
expected
-
{
gpuValidationError
.
message
}
;
this
.
rec
.
debug
(
niceStack
)
;
}
}
)
;
}
}
makeBufferWithContents
(
dataArray
usage
)
{
return
this
.
trackForCleanup
(
makeBufferWithContents
(
this
.
device
dataArray
usage
)
)
;
}
createEncoder
(
encoderType
{
attachmentInfo
occlusionQuerySet
}
=
{
}
)
{
const
fullAttachmentInfo
=
{
colorFormats
:
[
'
rgba8unorm
'
]
sampleCount
:
1
.
.
.
attachmentInfo
}
;
switch
(
encoderType
)
{
case
'
non
-
pass
'
:
{
const
encoder
=
this
.
device
.
createCommandEncoder
(
)
;
return
new
CommandBufferMaker
(
this
encoder
(
)
=
>
{
return
encoder
.
finish
(
)
;
}
)
;
}
case
'
render
bundle
'
:
{
const
device
=
this
.
device
;
const
rbEncoder
=
device
.
createRenderBundleEncoder
(
fullAttachmentInfo
)
;
const
pass
=
this
.
createEncoder
(
'
render
pass
'
{
attachmentInfo
}
)
;
return
new
CommandBufferMaker
(
this
rbEncoder
(
)
=
>
{
pass
.
encoder
.
executeBundles
(
[
rbEncoder
.
finish
(
)
]
)
;
return
pass
.
finish
(
)
;
}
)
;
}
case
'
compute
pass
'
:
{
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
const
encoder
=
commandEncoder
.
beginComputePass
(
)
;
return
new
CommandBufferMaker
(
this
encoder
(
)
=
>
{
encoder
.
end
(
)
;
return
commandEncoder
.
finish
(
)
;
}
)
;
}
case
'
render
pass
'
:
{
const
makeAttachmentView
=
(
format
)
=
>
this
.
trackForCleanup
(
this
.
device
.
createTexture
(
{
size
:
[
16
16
1
]
format
usage
:
GPUTextureUsage
.
RENDER_ATTACHMENT
sampleCount
:
fullAttachmentInfo
.
sampleCount
}
)
)
.
createView
(
)
;
let
depthStencilAttachment
=
undefined
;
if
(
fullAttachmentInfo
.
depthStencilFormat
!
=
=
undefined
)
{
depthStencilAttachment
=
{
view
:
makeAttachmentView
(
fullAttachmentInfo
.
depthStencilFormat
)
depthReadOnly
:
fullAttachmentInfo
.
depthReadOnly
stencilReadOnly
:
fullAttachmentInfo
.
stencilReadOnly
}
;
if
(
kTextureFormatInfo
[
fullAttachmentInfo
.
depthStencilFormat
]
.
depth
&
&
!
fullAttachmentInfo
.
depthReadOnly
)
{
depthStencilAttachment
.
depthClearValue
=
0
;
depthStencilAttachment
.
depthLoadOp
=
'
clear
'
;
depthStencilAttachment
.
depthStoreOp
=
'
discard
'
;
}
if
(
kTextureFormatInfo
[
fullAttachmentInfo
.
depthStencilFormat
]
.
stencil
&
&
!
fullAttachmentInfo
.
stencilReadOnly
)
{
depthStencilAttachment
.
stencilClearValue
=
1
;
depthStencilAttachment
.
stencilLoadOp
=
'
clear
'
;
depthStencilAttachment
.
stencilStoreOp
=
'
discard
'
;
}
}
const
passDesc
=
{
colorAttachments
:
Array
.
from
(
fullAttachmentInfo
.
colorFormats
(
format
)
=
>
format
?
{
view
:
makeAttachmentView
(
format
)
clearValue
:
[
0
0
0
0
]
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
:
null
)
depthStencilAttachment
occlusionQuerySet
}
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
const
encoder
=
commandEncoder
.
beginRenderPass
(
passDesc
)
;
return
new
CommandBufferMaker
(
this
encoder
(
)
=
>
{
encoder
.
end
(
)
;
return
commandEncoder
.
finish
(
)
;
}
)
;
}
}
unreachable
(
)
;
}
}
export
class
GPUTest
extends
GPUTestBase
{
async
init
(
)
{
await
super
.
init
(
)
;
this
.
provider
=
await
this
.
sharedState
.
acquireProvider
(
)
;
this
.
mismatchedProvider
=
await
this
.
sharedState
.
acquireMismatchedProvider
(
)
;
}
get
device
(
)
{
assert
(
this
.
provider
!
=
=
undefined
'
internal
error
:
GPUDevice
missing
?
'
)
;
return
this
.
provider
.
device
;
}
get
mismatchedDevice
(
)
{
assert
(
this
.
mismatchedProvider
!
=
=
undefined
'
selectMismatchedDeviceOrSkipTestCase
was
not
called
in
beforeAllSubcases
'
)
;
return
this
.
mismatchedProvider
.
device
;
}
expectDeviceLost
(
reason
)
{
assert
(
this
.
provider
!
=
=
undefined
'
internal
error
:
GPUDevice
missing
?
'
)
;
this
.
provider
.
expectDeviceLost
(
reason
)
;
}
}
const
s_deviceToResourcesMap
=
new
WeakMap
(
)
;
function
getPipelineToRenderTextureToRGB8UnormTexture
(
device
)
{
if
(
!
s_deviceToResourcesMap
.
has
(
device
)
)
{
const
module
=
device
.
createShaderModule
(
{
code
:
struct
VSOutput
{
builtin
(
position
)
position
:
vec4f
location
(
0
)
texcoord
:
vec2f
}
;
vertex
fn
vs
(
builtin
(
vertex_index
)
vertexIndex
:
u32
)
-
>
VSOutput
{
let
pos
=
array
(
vec2f
(
-
1
-
1
)
vec2f
(
-
1
3
)
vec2f
(
3
-
1
)
)
;
var
vsOutput
:
VSOutput
;
let
xy
=
pos
[
vertexIndex
]
;
vsOutput
.
position
=
vec4f
(
xy
0
.
0
1
.
0
)
;
vsOutput
.
texcoord
=
xy
*
vec2f
(
0
.
5
-
0
.
5
)
+
vec2f
(
0
.
5
)
;
return
vsOutput
;
}
group
(
0
)
binding
(
0
)
var
ourSampler
:
sampler
;
group
(
0
)
binding
(
1
)
var
ourTexture
:
texture_2d
<
f32
>
;
fragment
fn
fs
(
fsInput
:
VSOutput
)
-
>
location
(
0
)
vec4f
{
return
textureSample
(
ourTexture
ourSampler
fsInput
.
texcoord
)
;
}
}
)
;
const
pipeline
=
device
.
createRenderPipeline
(
{
layout
:
'
auto
'
vertex
:
{
module
entryPoint
:
'
vs
'
}
fragment
:
{
module
entryPoint
:
'
fs
'
targets
:
[
{
format
:
'
rgba8unorm
'
}
]
}
}
)
;
s_deviceToResourcesMap
.
set
(
device
{
pipeline
}
)
;
}
const
{
pipeline
}
=
s_deviceToResourcesMap
.
get
(
device
)
;
return
pipeline
;
}
export
function
TextureTestMixin
(
Base
)
{
class
TextureExpectations
extends
Base
{
createTextureFromTexelView
(
texelView
desc
)
{
return
this
.
trackForCleanup
(
createTextureFromTexelView
(
this
.
device
texelView
desc
)
)
;
}
createTextureFromTexelViewsMultipleMipmaps
(
texelViews
desc
)
{
return
this
.
trackForCleanup
(
createTextureFromTexelViews
(
this
.
device
texelViews
desc
)
)
;
}
expectTexelViewComparisonIsOkInTexture
(
src
exp
size
comparisonOptions
=
{
maxIntDiff
:
0
maxDiffULPsForNormFormat
:
1
maxDiffULPsForFloatFormat
:
1
}
)
{
this
.
eventualExpectOK
(
textureContentIsOKByT2B
(
this
src
size
{
expTexelView
:
exp
}
comparisonOptions
)
)
;
}
expectSinglePixelComparisonsAreOkInTexture
(
src
exp
comparisonOptions
=
{
maxIntDiff
:
0
maxDiffULPsForNormFormat
:
1
maxDiffULPsForFloatFormat
:
1
}
)
{
assert
(
exp
.
length
>
0
'
must
specify
at
least
one
pixel
comparison
'
)
;
assert
(
kEncodableTextureFormats
.
includes
(
src
.
texture
.
format
)
(
)
=
>
{
src
.
texture
.
format
}
is
not
an
encodable
format
)
;
const
lowerCorner
=
[
src
.
texture
.
width
src
.
texture
.
height
src
.
texture
.
depthOrArrayLayers
]
;
const
upperCorner
=
[
0
0
0
]
;
const
expMap
=
new
Map
(
)
;
const
coords
=
[
]
;
for
(
const
e
of
exp
)
{
const
coord
=
reifyOrigin3D
(
e
.
coord
)
;
const
coordKey
=
JSON
.
stringify
(
coord
)
;
coords
.
push
(
coord
)
;
lowerCorner
[
0
]
=
Math
.
min
(
lowerCorner
[
0
]
coord
.
x
)
;
lowerCorner
[
1
]
=
Math
.
min
(
lowerCorner
[
1
]
coord
.
y
)
;
lowerCorner
[
2
]
=
Math
.
min
(
lowerCorner
[
2
]
coord
.
z
)
;
upperCorner
[
0
]
=
Math
.
max
(
upperCorner
[
0
]
coord
.
x
)
;
upperCorner
[
1
]
=
Math
.
max
(
upperCorner
[
1
]
coord
.
y
)
;
upperCorner
[
2
]
=
Math
.
max
(
upperCorner
[
2
]
coord
.
z
)
;
assert
(
!
expMap
.
has
(
coordKey
)
(
)
=
>
duplicate
pixel
expectation
at
coordinate
(
{
coord
.
x
}
{
coord
.
y
}
{
coord
.
z
}
)
)
;
expMap
.
set
(
coordKey
e
.
exp
)
;
}
const
size
=
[
upperCorner
[
0
]
-
lowerCorner
[
0
]
+
1
upperCorner
[
1
]
-
lowerCorner
[
1
]
+
1
upperCorner
[
2
]
-
lowerCorner
[
2
]
+
1
]
;
let
expTexelView
;
if
(
Symbol
.
iterator
in
exp
[
0
]
.
exp
)
{
expTexelView
=
TexelView
.
fromTexelsAsBytes
(
src
.
texture
.
format
(
coord
)
=
>
{
const
res
=
expMap
.
get
(
JSON
.
stringify
(
coord
)
)
;
assert
(
res
!
=
=
undefined
(
)
=
>
invalid
coordinate
(
{
coord
.
x
}
{
coord
.
y
}
{
coord
.
z
}
)
in
sparse
texel
view
)
;
return
res
;
}
)
;
}
else
{
expTexelView
=
TexelView
.
fromTexelsAsColors
(
src
.
texture
.
format
(
coord
)
=
>
{
const
res
=
expMap
.
get
(
JSON
.
stringify
(
coord
)
)
;
assert
(
res
!
=
=
undefined
(
)
=
>
invalid
coordinate
(
{
coord
.
x
}
{
coord
.
y
}
{
coord
.
z
}
)
in
sparse
texel
view
)
;
return
res
;
}
)
;
}
const
coordsF
=
function
*
(
)
{
for
(
const
coord
of
coords
)
{
yield
coord
;
}
}
(
)
;
this
.
eventualExpectOK
(
textureContentIsOKByT2B
(
this
{
.
.
.
src
origin
:
reifyOrigin3D
(
lowerCorner
)
}
size
{
expTexelView
}
comparisonOptions
coordsF
)
)
;
}
expectTexturesToMatchByRendering
(
actualTexture
expectedTexture
mipLevel
origin
size
)
{
const
pipeline
=
getPipelineToRenderTextureToRGB8UnormTexture
(
this
.
device
)
;
const
readbackPromisesPerTexturePerLayer
=
[
actualTexture
expectedTexture
]
.
map
(
(
texture
ndx
)
=
>
{
const
attachmentSize
=
virtualMipSize
(
'
2d
'
[
texture
.
width
texture
.
height
1
]
mipLevel
)
;
const
attachment
=
this
.
device
.
createTexture
(
{
label
:
readback
{
ndx
}
size
:
attachmentSize
format
:
'
rgba8unorm
'
usage
:
GPUTextureUsage
.
COPY_SRC
|
GPUTextureUsage
.
RENDER_ATTACHMENT
}
)
;
this
.
trackForCleanup
(
attachment
)
;
const
sampler
=
this
.
device
.
createSampler
(
)
;
const
numLayers
=
texture
.
depthOrArrayLayers
;
const
readbackPromisesPerLayer
=
[
]
;
for
(
let
layer
=
0
;
layer
<
numLayers
;
+
+
layer
)
{
const
bindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
sampler
}
{
binding
:
1
resource
:
texture
.
createView
(
{
baseMipLevel
:
mipLevel
mipLevelCount
:
1
baseArrayLayer
:
layer
arrayLayerCount
:
1
dimension
:
'
2d
'
}
)
}
]
}
)
;
const
encoder
=
this
.
device
.
createCommandEncoder
(
)
;
const
pass
=
encoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
attachment
.
createView
(
)
clearValue
:
[
0
.
5
0
.
5
0
.
5
0
.
5
]
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
]
}
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
bindGroup
)
;
pass
.
draw
(
3
)
;
pass
.
end
(
)
;
this
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
const
buffer
=
this
.
copyWholeTextureToNewBufferSimple
(
attachment
0
)
;
readbackPromisesPerLayer
.
push
(
this
.
readGPUBufferRangeTyped
(
buffer
{
type
:
Uint8Array
typedLength
:
buffer
.
size
}
)
)
;
}
return
readbackPromisesPerLayer
;
}
)
;
this
.
eventualAsyncExpectation
(
async
(
niceStack
)
=
>
{
const
readbacksPerTexturePerLayer
=
[
]
;
for
(
const
readbackPromises
of
readbackPromisesPerTexturePerLayer
)
{
readbacksPerTexturePerLayer
.
push
(
await
Promise
.
all
(
readbackPromises
)
)
;
}
function
arrayNotAllTheSameValue
(
arr
msg
)
{
const
first
=
arr
[
0
]
;
return
arr
.
length
<
=
1
|
|
arr
.
findIndex
(
(
v
)
=
>
v
!
=
=
first
)
>
=
0
?
undefined
:
Error
(
array
is
entirely
{
first
}
so
likely
nothing
was
tested
:
{
msg
|
|
'
'
}
)
;
}
const
[
actualReadbacksPerLayer
expectedReadbacksPerLayer
]
=
readbacksPerTexturePerLayer
;
for
(
let
layer
=
0
;
layer
<
actualReadbacksPerLayer
.
length
;
+
+
layer
)
{
const
actualReadback
=
actualReadbacksPerLayer
[
layer
]
;
const
expectedReadback
=
expectedReadbacksPerLayer
[
layer
]
;
const
sameOk
=
size
.
width
=
=
=
0
|
|
size
.
height
=
=
=
0
|
|
layer
<
origin
.
z
|
|
layer
>
=
origin
.
z
+
size
.
depthOrArrayLayers
;
this
.
expectOK
(
sameOk
?
undefined
:
arrayNotAllTheSameValue
(
actualReadback
.
data
'
actualTexture
'
)
)
;
this
.
expectOK
(
sameOk
?
undefined
:
arrayNotAllTheSameValue
(
expectedReadback
.
data
'
expectedTexture
'
)
)
;
this
.
expectOK
(
checkElementsEqual
(
actualReadback
.
data
expectedReadback
.
data
)
{
mode
:
'
fail
'
niceStack
}
)
;
actualReadback
.
cleanup
(
)
;
expectedReadback
.
cleanup
(
)
;
}
}
)
;
}
copyWholeTextureToNewBufferSimple
(
texture
mipLevel
)
{
const
{
blockWidth
blockHeight
bytesPerBlock
}
=
kTextureFormatInfo
[
texture
.
format
]
;
const
mipSize
=
physicalMipSizeFromTexture
(
texture
mipLevel
)
;
assert
(
bytesPerBlock
!
=
=
undefined
)
;
const
blocksPerRow
=
mipSize
[
0
]
/
blockWidth
;
const
blocksPerColumn
=
mipSize
[
1
]
/
blockHeight
;
assert
(
blocksPerRow
%
1
=
=
=
0
)
;
assert
(
blocksPerColumn
%
1
=
=
=
0
)
;
const
bytesPerRow
=
align
(
blocksPerRow
*
bytesPerBlock
256
)
;
const
byteLength
=
bytesPerRow
*
blocksPerColumn
*
mipSize
[
2
]
;
return
this
.
copyWholeTextureToNewBuffer
(
{
texture
mipLevel
}
{
bytesPerBlock
bytesPerRow
rowsPerImage
:
blocksPerColumn
byteLength
}
)
;
}
copyWholeTextureToNewBuffer
(
{
texture
mipLevel
}
resultDataLayout
)
{
const
{
byteLength
bytesPerRow
rowsPerImage
}
=
resultDataLayout
;
const
buffer
=
this
.
device
.
createBuffer
(
{
size
:
align
(
byteLength
4
)
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
buffer
)
;
const
mipSize
=
physicalMipSizeFromTexture
(
texture
mipLevel
|
|
0
)
;
const
encoder
=
this
.
device
.
createCommandEncoder
(
)
;
encoder
.
copyTextureToBuffer
(
{
texture
mipLevel
}
{
buffer
bytesPerRow
rowsPerImage
}
mipSize
)
;
this
.
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
return
buffer
;
}
updateLinearTextureDataSubBox
(
format
copySize
copyParams
)
{
const
{
src
dest
}
=
copyParams
;
const
rowLength
=
bytesInACompleteRow
(
copySize
.
width
format
)
;
for
(
const
texel
of
this
.
iterateBlockRows
(
copySize
format
)
)
{
const
srcOffsetElements
=
this
.
getTexelOffsetInBytes
(
src
.
dataLayout
format
texel
src
.
origin
)
;
const
dstOffsetElements
=
this
.
getTexelOffsetInBytes
(
dest
.
dataLayout
format
texel
dest
.
origin
)
;
memcpy
(
{
src
:
src
.
data
start
:
srcOffsetElements
length
:
rowLength
}
{
dst
:
dest
.
data
start
:
dstOffsetElements
}
)
;
}
}
getTexelOffsetInBytes
(
textureDataLayout
format
texel
origin
=
{
x
:
0
y
:
0
z
:
0
}
)
{
const
{
offset
bytesPerRow
rowsPerImage
}
=
textureDataLayout
;
const
info
=
kTextureFormatInfo
[
format
]
;
assert
(
texel
.
x
%
info
.
blockWidth
=
=
=
0
)
;
assert
(
texel
.
y
%
info
.
blockHeight
=
=
=
0
)
;
assert
(
origin
.
x
%
info
.
blockWidth
=
=
=
0
)
;
assert
(
origin
.
y
%
info
.
blockHeight
=
=
=
0
)
;
const
bytesPerImage
=
rowsPerImage
*
bytesPerRow
;
return
(
offset
+
(
texel
.
z
+
origin
.
z
)
*
bytesPerImage
+
(
texel
.
y
+
origin
.
y
)
/
info
.
blockHeight
*
bytesPerRow
+
(
texel
.
x
+
origin
.
x
)
/
info
.
blockWidth
*
info
.
color
.
bytes
)
;
}
*
iterateBlockRows
(
size
format
)
{
if
(
size
.
width
=
=
=
0
|
|
size
.
height
=
=
=
0
|
|
size
.
depthOrArrayLayers
=
=
=
0
)
{
return
;
}
const
info
=
kTextureFormatInfo
[
format
]
;
assert
(
size
.
height
%
info
.
blockHeight
=
=
=
0
)
;
for
(
let
z
=
0
;
z
<
size
.
depthOrArrayLayers
;
+
+
z
)
{
for
(
let
y
=
0
;
y
<
size
.
height
;
y
+
=
info
.
blockHeight
)
{
yield
{
x
:
0
y
z
}
;
}
}
}
}
return
TextureExpectations
;
}
