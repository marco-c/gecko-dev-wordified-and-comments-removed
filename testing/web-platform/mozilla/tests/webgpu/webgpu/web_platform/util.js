import
{
SkipTestCase
}
from
'
.
.
/
.
.
/
common
/
framework
/
fixture
.
js
'
;
import
{
getResourcePath
}
from
'
.
.
/
.
.
/
common
/
framework
/
resources
.
js
'
;
import
{
keysOf
}
from
'
.
.
/
.
.
/
common
/
util
/
data_tables
.
js
'
;
import
{
timeout
}
from
'
.
.
/
.
.
/
common
/
util
/
timeout
.
js
'
;
import
{
ErrorWithExtra
raceWithRejectOnTimeout
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
srgbToDisplayP3
}
from
'
.
.
/
util
/
color_space_conversion
.
js
'
;
export
function
convertToUnorm8
(
expectation
)
{
const
rgba8Unorm
=
new
Uint8ClampedArray
(
4
)
;
rgba8Unorm
[
0
]
=
Math
.
round
(
expectation
.
R
*
255
.
0
)
;
rgba8Unorm
[
1
]
=
Math
.
round
(
expectation
.
G
*
255
.
0
)
;
rgba8Unorm
[
2
]
=
Math
.
round
(
expectation
.
B
*
255
.
0
)
;
rgba8Unorm
[
3
]
=
Math
.
round
(
expectation
.
A
*
255
.
0
)
;
return
new
Uint8Array
(
rgba8Unorm
.
buffer
)
;
}
const
kBt601PixelValue
=
{
srgb
:
{
red
:
{
R
:
0
.
972945567233341
G
:
0
.
141794376683341
B
:
-
0
.
0209589916711088
A
:
1
.
0
}
green
:
{
R
:
0
.
248234279433399
G
:
0
.
984810378661784
B
:
-
0
.
0564701319494314
A
:
1
.
0
}
blue
:
{
R
:
0
.
10159735826538
G
:
0
.
135451122863674
B
:
1
.
00262982899724
A
:
1
.
0
}
yellow
:
{
R
:
0
.
995470750775951
G
:
0
.
992742114518355
B
:
-
0
.
0701036235167653
A
:
1
.
0
}
}
}
;
const
kBt709PixelValue
=
{
srgb
:
{
red
:
{
R
:
1
.
0
G
:
0
.
0
B
:
0
.
0
A
:
1
.
0
}
green
:
{
R
:
0
.
0
G
:
1
.
0
B
:
0
.
0
A
:
1
.
0
}
blue
:
{
R
:
0
.
0
G
:
0
.
0
B
:
1
.
0
A
:
1
.
0
}
yellow
:
{
R
:
1
.
0
G
:
1
.
0
B
:
0
.
0
A
:
1
.
0
}
}
}
;
function
makeTable
(
{
table
}
)
{
return
Object
.
fromEntries
(
Object
.
entries
(
table
)
.
map
(
(
[
k
row
]
)
=
>
[
k
{
.
.
.
row
}
]
)
)
;
}
export
const
kVideoExpectedColors
=
makeTable
(
{
table
:
{
bt601
:
{
'
display
-
p3
'
:
{
yellow
:
srgbToDisplayP3
(
kBt601PixelValue
.
srgb
.
yellow
)
red
:
srgbToDisplayP3
(
kBt601PixelValue
.
srgb
.
red
)
blue
:
srgbToDisplayP3
(
kBt601PixelValue
.
srgb
.
blue
)
green
:
srgbToDisplayP3
(
kBt601PixelValue
.
srgb
.
green
)
}
srgb
:
{
yellow
:
kBt601PixelValue
.
srgb
.
yellow
red
:
kBt601PixelValue
.
srgb
.
red
blue
:
kBt601PixelValue
.
srgb
.
blue
green
:
kBt601PixelValue
.
srgb
.
green
}
}
bt709
:
{
'
display
-
p3
'
:
{
yellow
:
srgbToDisplayP3
(
kBt709PixelValue
.
srgb
.
yellow
)
red
:
srgbToDisplayP3
(
kBt709PixelValue
.
srgb
.
red
)
blue
:
srgbToDisplayP3
(
kBt709PixelValue
.
srgb
.
blue
)
green
:
srgbToDisplayP3
(
kBt709PixelValue
.
srgb
.
green
)
}
srgb
:
{
yellow
:
kBt709PixelValue
.
srgb
.
yellow
red
:
kBt709PixelValue
.
srgb
.
red
blue
:
kBt709PixelValue
.
srgb
.
blue
green
:
kBt709PixelValue
.
srgb
.
green
}
}
}
}
)
;
export
const
kVideoInfo
=
makeTable
(
{
table
:
{
'
four
-
colors
-
vp8
-
bt601
.
webm
'
:
{
mimeType
:
'
video
/
webm
;
codecs
=
vp8
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
display
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
}
'
four
-
colors
-
h264
-
bt601
.
mp4
'
:
{
mimeType
:
'
video
/
mp4
;
codecs
=
avc1
.
4d400c
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
display
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
}
'
four
-
colors
-
vp9
-
bt601
.
webm
'
:
{
mimeType
:
'
video
/
webm
;
codecs
=
vp9
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
display
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
}
'
four
-
colors
-
vp9
-
bt709
.
webm
'
:
{
mimeType
:
'
video
/
webm
;
codecs
=
vp9
'
colorSpace
:
'
bt709
'
coded
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
display
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
}
'
four
-
colors
-
h264
-
bt601
-
rotate
-
90
.
mp4
'
:
{
mimeType
:
'
video
/
mp4
;
codecs
=
avc1
.
4d400c
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
red
'
topRightColor
:
'
green
'
bottomLeftColor
:
'
yellow
'
bottomRightColor
:
'
blue
'
}
display
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
}
'
four
-
colors
-
h264
-
bt601
-
rotate
-
180
.
mp4
'
:
{
mimeType
:
'
video
/
mp4
;
codecs
=
avc1
.
4d400c
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
green
'
topRightColor
:
'
blue
'
bottomLeftColor
:
'
red
'
bottomRightColor
:
'
yellow
'
}
display
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
}
'
four
-
colors
-
h264
-
bt601
-
rotate
-
270
.
mp4
'
:
{
mimeType
:
'
video
/
mp4
;
codecs
=
avc1
.
4d400c
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
blue
'
topRightColor
:
'
yellow
'
bottomLeftColor
:
'
green
'
bottomRightColor
:
'
red
'
}
display
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
}
'
four
-
colors
-
vp9
-
bt601
-
rotate
-
90
.
mp4
'
:
{
mimeType
:
'
video
/
mp4
;
codecs
=
vp09
.
00
.
10
.
08
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
red
'
topRightColor
:
'
green
'
bottomLeftColor
:
'
yellow
'
bottomRightColor
:
'
blue
'
}
display
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
}
'
four
-
colors
-
vp9
-
bt601
-
rotate
-
180
.
mp4
'
:
{
mimeType
:
'
video
/
mp4
;
codecs
=
vp09
.
00
.
10
.
08
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
green
'
topRightColor
:
'
blue
'
bottomLeftColor
:
'
red
'
bottomRightColor
:
'
yellow
'
}
display
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
}
'
four
-
colors
-
vp9
-
bt601
-
rotate
-
270
.
mp4
'
:
{
mimeType
:
'
video
/
mp4
;
codecs
=
vp09
.
00
.
10
.
08
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
blue
'
topRightColor
:
'
yellow
'
bottomLeftColor
:
'
green
'
bottomRightColor
:
'
red
'
}
display
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
}
'
four
-
colors
-
h264
-
bt601
-
hflip
.
mp4
'
:
{
mimeType
:
'
video
/
mp4
;
codecs
=
avc1
.
4d400c
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
display
:
{
topLeftColor
:
'
red
'
topRightColor
:
'
yellow
'
bottomLeftColor
:
'
green
'
bottomRightColor
:
'
blue
'
}
}
'
four
-
colors
-
h264
-
bt601
-
vflip
.
mp4
'
:
{
mimeType
:
'
video
/
mp4
;
codecs
=
avc1
.
4d400c
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
display
:
{
topLeftColor
:
'
blue
'
topRightColor
:
'
green
'
bottomLeftColor
:
'
yellow
'
bottomRightColor
:
'
red
'
}
}
'
four
-
colors
-
vp9
-
bt601
-
hflip
.
mp4
'
:
{
mimeType
:
'
video
/
mp4
;
codecs
=
vp09
.
00
.
10
.
08
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
display
:
{
topLeftColor
:
'
red
'
topRightColor
:
'
yellow
'
bottomLeftColor
:
'
green
'
bottomRightColor
:
'
blue
'
}
}
'
four
-
colors
-
vp9
-
bt601
-
vflip
.
mp4
'
:
{
mimeType
:
'
video
/
mp4
;
codecs
=
vp09
.
00
.
10
.
08
'
colorSpace
:
'
bt601
'
coded
:
{
topLeftColor
:
'
yellow
'
topRightColor
:
'
red
'
bottomLeftColor
:
'
blue
'
bottomRightColor
:
'
green
'
}
display
:
{
topLeftColor
:
'
blue
'
topRightColor
:
'
green
'
bottomLeftColor
:
'
yellow
'
bottomRightColor
:
'
red
'
}
}
}
}
)
;
export
const
kVideoNames
=
keysOf
(
kVideoInfo
)
;
export
const
kPredefinedColorSpace
=
[
'
display
-
p3
'
'
srgb
'
]
;
export
function
startPlayingAndWaitForVideo
(
video
callback
)
{
return
raceWithRejectOnTimeout
(
new
Promise
(
(
resolve
reject
)
=
>
{
const
callbackAndResolve
=
(
)
=
>
void
(
async
(
)
=
>
{
try
{
await
callback
(
)
;
resolve
(
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
}
)
(
)
;
if
(
video
.
error
)
{
reject
(
new
ErrorWithExtra
(
'
Video
.
error
:
'
+
video
.
error
.
message
(
)
=
>
(
{
error
:
video
.
error
}
)
)
)
;
return
;
}
video
.
addEventListener
(
'
error
'
(
event
)
=
>
reject
(
new
ErrorWithExtra
(
'
Video
received
"
error
"
event
message
:
'
+
event
.
message
(
)
=
>
(
{
event
}
)
)
)
true
)
;
if
(
video
.
requestVideoFrameCallback
)
{
video
.
requestVideoFrameCallback
(
(
)
=
>
{
callbackAndResolve
(
)
;
}
)
;
}
else
{
const
timeWatcher
=
(
)
=
>
{
if
(
video
.
currentTime
>
0
)
{
callbackAndResolve
(
)
;
}
else
{
requestAnimationFrame
(
timeWatcher
)
;
}
}
;
timeWatcher
(
)
;
}
video
.
loop
=
true
;
video
.
muted
=
true
;
video
.
preload
=
'
auto
'
;
video
.
play
(
)
.
catch
(
reject
)
;
}
)
2000
'
Video
never
became
ready
'
)
;
}
export
function
waitForNextTask
(
callback
)
{
const
{
promise
callbackAndResolve
}
=
callbackHelper
(
callback
'
wait
for
next
task
timed
out
'
)
;
timeout
(
(
)
=
>
{
callbackAndResolve
(
)
;
}
0
)
;
return
promise
;
}
export
function
waitForNextFrame
(
video
callback
)
{
const
{
promise
callbackAndResolve
}
=
callbackHelper
(
callback
'
waitForNextFrame
timed
out
'
)
;
if
(
'
requestVideoFrameCallback
'
in
video
)
{
video
.
requestVideoFrameCallback
(
(
)
=
>
{
callbackAndResolve
(
)
;
}
)
;
}
else
{
throw
new
SkipTestCase
(
'
waitForNextFrame
currently
requires
requestVideoFrameCallback
'
)
;
}
return
promise
;
}
export
async
function
getVideoFrameFromVideoElement
(
test
video
)
{
if
(
video
.
captureStream
=
=
=
undefined
)
{
test
.
skip
(
'
HTMLVideoElement
.
captureStream
is
not
supported
'
)
;
}
return
raceWithRejectOnTimeout
(
new
Promise
(
(
resolve
)
=
>
{
const
videoTrack
=
video
.
captureStream
(
)
.
getVideoTracks
(
)
[
0
]
;
const
trackProcessor
=
new
MediaStreamTrackProcessor
(
{
track
:
videoTrack
}
)
;
const
transformer
=
new
TransformStream
(
{
transform
(
videoFrame
_controller
)
{
videoTrack
.
stop
(
)
;
test
.
trackForCleanup
(
videoFrame
)
;
resolve
(
videoFrame
)
;
}
flush
(
controller
)
{
controller
.
terminate
(
)
;
}
}
)
;
const
trackGenerator
=
new
MediaStreamTrackGenerator
(
{
kind
:
'
video
'
}
)
;
trackProcessor
.
readable
.
pipeThrough
(
transformer
)
.
pipeTo
(
trackGenerator
.
writable
)
.
catch
(
(
)
=
>
{
}
)
;
}
)
2000
'
Video
never
became
ready
'
)
;
}
export
function
getVideoElement
(
t
videoName
)
{
if
(
typeof
HTMLVideoElement
=
=
=
'
undefined
'
)
{
t
.
skip
(
'
HTMLVideoElement
not
available
'
)
;
}
const
videoElement
=
document
.
createElement
(
'
video
'
)
;
const
videoInfo
=
kVideoInfo
[
videoName
]
;
if
(
videoElement
.
canPlayType
(
videoInfo
.
mimeType
)
=
=
=
'
'
)
{
t
.
skip
(
'
Video
codec
is
not
supported
'
)
;
}
const
videoUrl
=
getResourcePath
(
videoName
)
;
videoElement
.
src
=
videoUrl
;
t
.
trackForCleanup
(
videoElement
)
;
return
videoElement
;
}
function
callbackHelper
(
callback
timeoutMessage
)
{
let
callbackAndResolve
;
const
promiseWithoutTimeout
=
new
Promise
(
(
resolve
reject
)
=
>
{
callbackAndResolve
=
(
)
=
>
void
(
async
(
)
=
>
{
try
{
await
callback
(
)
;
resolve
(
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
}
)
(
)
;
}
)
;
const
promise
=
raceWithRejectOnTimeout
(
promiseWithoutTimeout
2000
timeoutMessage
)
;
return
{
promise
callbackAndResolve
:
callbackAndResolve
}
;
}
export
async
function
captureCameraFrame
(
test
)
{
if
(
typeof
navigator
.
mediaDevices
=
=
=
'
undefined
'
|
|
typeof
navigator
.
mediaDevices
.
getUserMedia
=
=
=
'
undefined
'
)
{
test
.
skip
(
"
Browser
doesn
'
t
support
capture
frame
from
camera
.
"
)
;
}
const
stream
=
await
navigator
.
mediaDevices
.
getUserMedia
(
{
video
:
true
}
)
;
const
track
=
stream
.
getVideoTracks
(
)
[
0
]
;
if
(
!
track
)
{
test
.
skip
(
"
Doesn
'
t
have
valid
camera
captured
stream
for
testing
.
"
)
;
}
if
(
typeof
MediaStreamTrackProcessor
!
=
=
'
undefined
'
)
{
const
trackProcessor
=
new
MediaStreamTrackProcessor
(
{
track
}
)
;
const
reader
=
trackProcessor
.
readable
.
getReader
(
)
;
const
result
=
await
reader
.
read
(
)
;
if
(
result
.
done
)
{
test
.
skip
(
'
MediaStreamTrackProcessor
:
Cannot
get
valid
frame
from
readable
stream
.
'
)
;
}
return
result
.
value
;
}
if
(
typeof
ImageCapture
!
=
=
'
undefined
'
)
{
const
imageCapture
=
new
ImageCapture
(
track
)
;
const
imageBitmap
=
await
imageCapture
.
grabFrame
(
)
;
return
new
VideoFrame
(
imageBitmap
)
;
}
if
(
typeof
HTMLVideoElement
=
=
=
'
undefined
'
)
{
test
.
skip
(
'
Try
to
use
HTMLVideoElement
do
capture
but
HTMLVideoElement
not
available
.
'
)
;
}
const
video
=
document
.
createElement
(
'
video
'
)
;
video
.
srcObject
=
stream
;
const
frame
=
await
getVideoFrameFromVideoElement
(
test
video
)
;
test
.
trackForCleanup
(
frame
)
;
return
frame
;
}
