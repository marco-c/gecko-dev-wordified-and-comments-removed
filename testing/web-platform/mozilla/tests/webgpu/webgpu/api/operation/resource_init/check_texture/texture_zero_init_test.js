import
{
kUnitCaseParamsBuilder
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
common
/
framework
/
params_builder
.
js
'
;
import
{
assert
unreachable
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
kTextureAspects
kTextureDimensions
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
capability_info
.
js
'
;
import
{
GPUConst
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
constants
.
js
'
;
import
{
kTextureFormatInfo
kUncompressedTextureFormats
textureDimensionAndFormatCompatible
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
format_info
.
js
'
;
import
{
GPUTest
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
gpu_test
.
js
'
;
import
{
virtualMipSize
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
util
/
texture
/
base
.
js
'
;
import
{
createTextureUploadBuffer
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
util
/
texture
/
layout
.
js
'
;
import
{
SubresourceRange
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
util
/
texture
/
subresource
.
js
'
;
import
{
kTexelRepresentationInfo
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
util
/
texture
/
texel_data
.
js
'
;
export
let
UninitializeMethod
=
function
(
UninitializeMethod
)
{
UninitializeMethod
[
"
Creation
"
]
=
"
Creation
"
;
UninitializeMethod
[
"
StoreOpClear
"
]
=
"
StoreOpClear
"
;
return
UninitializeMethod
;
}
(
{
}
)
;
const
kUninitializeMethods
=
Object
.
keys
(
UninitializeMethod
)
;
export
let
ReadMethod
=
function
(
ReadMethod
)
{
ReadMethod
[
"
Sample
"
]
=
"
Sample
"
;
ReadMethod
[
"
CopyToBuffer
"
]
=
"
CopyToBuffer
"
;
ReadMethod
[
"
CopyToTexture
"
]
=
"
CopyToTexture
"
;
ReadMethod
[
"
DepthTest
"
]
=
"
DepthTest
"
;
ReadMethod
[
"
StencilTest
"
]
=
"
StencilTest
"
;
ReadMethod
[
"
ColorBlending
"
]
=
"
ColorBlending
"
;
ReadMethod
[
"
Storage
"
]
=
"
Storage
"
;
return
ReadMethod
;
}
(
{
}
)
;
const
kMipLevelCounts
=
[
1
5
]
;
const
kUninitializedMipRangesToTest
=
{
1
:
[
{
begin
:
0
end
:
1
}
]
5
:
[
{
begin
:
0
end
:
2
}
{
begin
:
3
end
:
4
}
]
}
;
const
kSampleCounts
=
[
1
4
]
;
const
kUninitializedLayerRangesToTest
=
{
1
:
[
{
begin
:
0
end
:
1
}
]
7
:
[
{
begin
:
2
end
:
4
}
{
begin
:
6
end
:
7
}
]
}
;
export
let
InitializedState
=
function
(
InitializedState
)
{
InitializedState
[
InitializedState
[
"
Canary
"
]
=
0
]
=
"
Canary
"
;
InitializedState
[
InitializedState
[
"
Zero
"
]
=
1
]
=
"
Zero
"
;
return
InitializedState
;
}
(
{
}
)
;
const
initializedStateAsFloat
=
{
[
InitializedState
.
Zero
]
:
0
[
InitializedState
.
Canary
]
:
1
}
;
const
initializedStateAsUint
=
{
[
InitializedState
.
Zero
]
:
0
[
InitializedState
.
Canary
]
:
1
}
;
const
initializedStateAsSint
=
{
[
InitializedState
.
Zero
]
:
0
[
InitializedState
.
Canary
]
:
-
1
}
;
function
initializedStateAsColor
(
state
format
)
{
let
value
;
if
(
format
.
indexOf
(
'
uint
'
)
!
=
=
-
1
)
{
value
=
initializedStateAsUint
[
state
]
;
}
else
if
(
format
.
indexOf
(
'
sint
'
)
!
=
=
-
1
)
{
value
=
initializedStateAsSint
[
state
]
;
}
else
{
value
=
initializedStateAsFloat
[
state
]
;
}
return
[
value
value
value
value
]
;
}
const
initializedStateAsDepth
=
{
[
InitializedState
.
Zero
]
:
0
[
InitializedState
.
Canary
]
:
0
.
8
}
;
const
initializedStateAsStencil
=
{
[
InitializedState
.
Zero
]
:
0
[
InitializedState
.
Canary
]
:
42
}
;
function
allAspectsCopyDst
(
info
)
{
return
(
(
!
info
.
color
|
|
info
.
color
.
copyDst
)
&
&
(
!
info
.
depth
|
|
info
.
depth
.
copyDst
)
&
&
(
!
info
.
stencil
|
|
info
.
stencil
.
copyDst
)
)
;
}
export
function
getRequiredTextureUsage
(
format
sampleCount
uninitializeMethod
readMethod
)
{
let
usage
=
GPUConst
.
TextureUsage
.
COPY_DST
;
switch
(
uninitializeMethod
)
{
case
UninitializeMethod
.
Creation
:
break
;
case
UninitializeMethod
.
StoreOpClear
:
usage
|
=
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
;
break
;
default
:
unreachable
(
)
;
}
switch
(
readMethod
)
{
case
ReadMethod
.
CopyToBuffer
:
case
ReadMethod
.
CopyToTexture
:
usage
|
=
GPUConst
.
TextureUsage
.
COPY_SRC
;
break
;
case
ReadMethod
.
Sample
:
usage
|
=
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
;
break
;
case
ReadMethod
.
Storage
:
usage
|
=
GPUConst
.
TextureUsage
.
STORAGE_BINDING
;
break
;
case
ReadMethod
.
DepthTest
:
case
ReadMethod
.
StencilTest
:
case
ReadMethod
.
ColorBlending
:
usage
|
=
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
;
break
;
default
:
unreachable
(
)
;
}
if
(
sampleCount
>
1
)
{
usage
|
=
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
;
}
const
info
=
kTextureFormatInfo
[
format
]
;
if
(
!
allAspectsCopyDst
(
info
)
)
{
if
(
info
.
color
)
assert
(
!
!
info
.
colorRender
'
not
implemented
for
non
-
renderable
color
'
)
;
usage
|
=
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
;
}
return
usage
;
}
export
class
TextureZeroInitTest
extends
GPUTest
{
constructor
(
sharedState
rec
params
)
{
super
(
sharedState
rec
params
)
;
this
.
p
=
params
;
const
stateToTexelComponents
=
(
state
)
=
>
{
const
[
R
G
B
A
]
=
initializedStateAsColor
(
state
this
.
p
.
format
)
;
return
{
R
G
B
A
Depth
:
initializedStateAsDepth
[
state
]
Stencil
:
initializedStateAsStencil
[
state
]
}
;
}
;
this
.
stateToTexelComponents
=
{
[
InitializedState
.
Zero
]
:
stateToTexelComponents
(
InitializedState
.
Zero
)
[
InitializedState
.
Canary
]
:
stateToTexelComponents
(
InitializedState
.
Canary
)
}
;
}
get
textureWidth
(
)
{
let
width
=
1
<
<
this
.
p
.
mipLevelCount
;
if
(
this
.
p
.
nonPowerOfTwo
)
{
width
=
2
*
width
-
1
;
}
return
width
;
}
get
textureHeight
(
)
{
if
(
this
.
p
.
dimension
=
=
=
'
1d
'
)
{
return
1
;
}
let
height
=
1
<
<
this
.
p
.
mipLevelCount
;
if
(
this
.
p
.
nonPowerOfTwo
)
{
height
=
2
*
height
-
1
;
}
return
height
;
}
get
textureDepth
(
)
{
return
this
.
p
.
dimension
=
=
=
'
3d
'
?
11
:
1
;
}
get
textureDepthOrArrayLayers
(
)
{
return
this
.
p
.
dimension
=
=
=
'
2d
'
?
this
.
p
.
layerCount
:
this
.
textureDepth
;
}
*
iterateUninitializedSubresources
(
)
{
for
(
const
mipRange
of
kUninitializedMipRangesToTest
[
this
.
p
.
mipLevelCount
]
)
{
for
(
const
layerRange
of
kUninitializedLayerRangesToTest
[
this
.
p
.
layerCount
]
)
{
yield
new
SubresourceRange
(
{
mipRange
layerRange
}
)
;
}
}
}
*
iterateInitializedSubresources
(
)
{
const
uninitialized
=
new
Array
(
this
.
p
.
mipLevelCount
)
;
for
(
let
level
=
0
;
level
<
uninitialized
.
length
;
+
+
level
)
{
uninitialized
[
level
]
=
new
Array
(
this
.
p
.
layerCount
)
;
}
for
(
const
subresources
of
this
.
iterateUninitializedSubresources
(
)
)
{
for
(
const
{
level
layer
}
of
subresources
.
each
(
)
)
{
uninitialized
[
level
]
[
layer
]
=
true
;
}
}
for
(
let
level
=
0
;
level
<
uninitialized
.
length
;
+
+
level
)
{
for
(
let
layer
=
0
;
layer
<
uninitialized
[
level
]
.
length
;
+
+
layer
)
{
if
(
!
uninitialized
[
level
]
[
layer
]
)
{
yield
new
SubresourceRange
(
{
mipRange
:
{
begin
:
level
count
:
1
}
layerRange
:
{
begin
:
layer
count
:
1
}
}
)
;
}
}
}
}
*
generateTextureViewDescriptorsForRendering
(
aspect
subresourceRange
)
{
const
viewDescriptor
=
{
dimension
:
'
2d
'
aspect
}
;
if
(
subresourceRange
=
=
=
undefined
)
{
return
viewDescriptor
;
}
for
(
const
{
level
layer
}
of
subresourceRange
.
each
(
)
)
{
yield
{
.
.
.
viewDescriptor
baseMipLevel
:
level
mipLevelCount
:
1
baseArrayLayer
:
layer
arrayLayerCount
:
1
}
;
}
}
initializeWithStoreOp
(
state
texture
subresourceRange
)
{
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
pushDebugGroup
(
'
initializeWithStoreOp
'
)
;
for
(
const
viewDescriptor
of
this
.
generateTextureViewDescriptorsForRendering
(
'
all
'
subresourceRange
)
)
{
if
(
kTextureFormatInfo
[
this
.
p
.
format
]
.
color
)
{
commandEncoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
texture
.
createView
(
viewDescriptor
)
clearValue
:
initializedStateAsColor
(
state
this
.
p
.
format
)
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
]
}
)
.
end
(
)
;
}
else
{
const
depthStencilAttachment
=
{
view
:
texture
.
createView
(
viewDescriptor
)
}
;
if
(
kTextureFormatInfo
[
this
.
p
.
format
]
.
depth
)
{
depthStencilAttachment
.
depthClearValue
=
initializedStateAsDepth
[
state
]
;
depthStencilAttachment
.
depthLoadOp
=
'
clear
'
;
depthStencilAttachment
.
depthStoreOp
=
'
store
'
;
}
if
(
kTextureFormatInfo
[
this
.
p
.
format
]
.
stencil
)
{
depthStencilAttachment
.
stencilClearValue
=
initializedStateAsStencil
[
state
]
;
depthStencilAttachment
.
stencilLoadOp
=
'
clear
'
;
depthStencilAttachment
.
stencilStoreOp
=
'
store
'
;
}
commandEncoder
.
beginRenderPass
(
{
colorAttachments
:
[
]
depthStencilAttachment
}
)
.
end
(
)
;
}
}
commandEncoder
.
popDebugGroup
(
)
;
this
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
}
initializeWithCopy
(
texture
state
subresourceRange
)
{
assert
(
this
.
p
.
format
in
kTextureFormatInfo
)
;
const
format
=
this
.
p
.
format
;
const
firstSubresource
=
subresourceRange
.
each
(
)
.
next
(
)
.
value
;
assert
(
typeof
firstSubresource
!
=
=
'
undefined
'
)
;
const
textureSize
=
[
this
.
textureWidth
this
.
textureHeight
this
.
textureDepth
]
;
const
[
largestWidth
largestHeight
largestDepth
]
=
virtualMipSize
(
this
.
p
.
dimension
textureSize
firstSubresource
.
level
)
;
const
rep
=
kTexelRepresentationInfo
[
format
]
;
const
texelData
=
new
Uint8Array
(
rep
.
pack
(
rep
.
encode
(
this
.
stateToTexelComponents
[
state
]
)
)
)
;
const
{
buffer
bytesPerRow
rowsPerImage
}
=
createTextureUploadBuffer
(
this
texelData
format
this
.
p
.
dimension
[
largestWidth
largestHeight
largestDepth
]
)
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
for
(
const
{
level
layer
}
of
subresourceRange
.
each
(
)
)
{
const
[
width
height
depth
]
=
virtualMipSize
(
this
.
p
.
dimension
textureSize
level
)
;
commandEncoder
.
copyBufferToTexture
(
{
buffer
bytesPerRow
rowsPerImage
}
{
texture
mipLevel
:
level
origin
:
{
x
:
0
y
:
0
z
:
layer
}
}
{
width
height
depthOrArrayLayers
:
depth
}
)
;
}
this
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
buffer
.
destroy
(
)
;
}
initializeTexture
(
texture
state
subresourceRange
)
{
const
info
=
kTextureFormatInfo
[
this
.
p
.
format
]
;
if
(
this
.
p
.
sampleCount
>
1
|
|
!
allAspectsCopyDst
(
info
)
)
{
if
(
info
.
color
)
assert
(
!
!
info
.
colorRender
'
not
implemented
for
non
-
renderable
color
'
)
;
this
.
initializeWithStoreOp
(
state
texture
subresourceRange
)
;
}
else
{
this
.
initializeWithCopy
(
texture
state
subresourceRange
)
;
}
}
discardTexture
(
texture
subresourceRange
)
{
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
pushDebugGroup
(
'
discardTexture
'
)
;
for
(
const
desc
of
this
.
generateTextureViewDescriptorsForRendering
(
'
all
'
subresourceRange
)
)
{
if
(
kTextureFormatInfo
[
this
.
p
.
format
]
.
color
)
{
commandEncoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
texture
.
createView
(
desc
)
loadOp
:
'
load
'
storeOp
:
'
discard
'
}
]
}
)
.
end
(
)
;
}
else
{
const
depthStencilAttachment
=
{
view
:
texture
.
createView
(
desc
)
}
;
if
(
kTextureFormatInfo
[
this
.
p
.
format
]
.
depth
)
{
depthStencilAttachment
.
depthLoadOp
=
'
load
'
;
depthStencilAttachment
.
depthStoreOp
=
'
discard
'
;
}
if
(
kTextureFormatInfo
[
this
.
p
.
format
]
.
stencil
)
{
depthStencilAttachment
.
stencilLoadOp
=
'
load
'
;
depthStencilAttachment
.
stencilStoreOp
=
'
discard
'
;
}
commandEncoder
.
beginRenderPass
(
{
colorAttachments
:
[
]
depthStencilAttachment
}
)
.
end
(
)
;
}
}
commandEncoder
.
popDebugGroup
(
)
;
this
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
}
}
export
const
kTestParams
=
kUnitCaseParamsBuilder
.
combine
(
'
dimension
'
kTextureDimensions
)
.
combine
(
'
readMethod
'
[
ReadMethod
.
CopyToBuffer
ReadMethod
.
CopyToTexture
ReadMethod
.
Sample
ReadMethod
.
DepthTest
ReadMethod
.
StencilTest
]
)
.
combine
(
'
format
'
kUncompressedTextureFormats
)
.
filter
(
(
{
dimension
format
}
)
=
>
textureDimensionAndFormatCompatible
(
dimension
format
)
)
.
beginSubcases
(
)
.
combine
(
'
aspect
'
kTextureAspects
)
.
unless
(
(
{
readMethod
format
aspect
}
)
=
>
{
const
info
=
kTextureFormatInfo
[
format
]
;
return
(
readMethod
=
=
=
ReadMethod
.
DepthTest
&
&
(
!
info
.
depth
|
|
aspect
=
=
=
'
stencil
-
only
'
)
|
|
readMethod
=
=
=
ReadMethod
.
StencilTest
&
&
(
!
info
.
stencil
|
|
aspect
=
=
=
'
depth
-
only
'
)
|
|
readMethod
=
=
=
ReadMethod
.
ColorBlending
&
&
!
info
.
color
|
|
readMethod
=
=
=
ReadMethod
.
Sample
&
&
(
!
!
info
.
depth
|
|
!
!
info
.
stencil
)
|
|
aspect
=
=
=
'
depth
-
only
'
&
&
!
info
.
depth
|
|
aspect
=
=
=
'
stencil
-
only
'
&
&
!
info
.
stencil
|
|
aspect
=
=
=
'
all
'
&
&
!
!
info
.
depth
&
&
!
!
info
.
stencil
|
|
(
readMethod
=
=
=
ReadMethod
.
CopyToBuffer
|
|
readMethod
=
=
=
ReadMethod
.
CopyToTexture
)
&
&
(
format
=
=
=
'
depth24plus
'
|
|
format
=
=
=
'
depth24plus
-
stencil8
'
)
)
;
}
)
.
combine
(
'
mipLevelCount
'
kMipLevelCounts
)
.
unless
(
(
p
)
=
>
p
.
dimension
=
=
=
'
1d
'
&
&
p
.
mipLevelCount
!
=
=
1
)
.
combine
(
'
sampleCount
'
kSampleCounts
)
.
unless
(
(
{
readMethod
sampleCount
}
)
=
>
sampleCount
>
1
&
&
(
readMethod
=
=
=
ReadMethod
.
CopyToBuffer
|
|
readMethod
=
=
=
ReadMethod
.
CopyToTexture
)
)
.
unless
(
(
{
sampleCount
mipLevelCount
}
)
=
>
sampleCount
>
1
&
&
mipLevelCount
>
1
)
.
combine
(
'
uninitializeMethod
'
kUninitializeMethods
)
.
unless
(
(
{
dimension
readMethod
uninitializeMethod
format
sampleCount
}
)
=
>
{
const
formatInfo
=
kTextureFormatInfo
[
format
]
;
return
(
dimension
!
=
=
'
2d
'
&
&
(
sampleCount
>
1
|
|
!
!
formatInfo
.
depth
|
|
!
!
formatInfo
.
stencil
|
|
readMethod
=
=
=
ReadMethod
.
DepthTest
|
|
readMethod
=
=
=
ReadMethod
.
StencilTest
|
|
readMethod
=
=
=
ReadMethod
.
ColorBlending
|
|
uninitializeMethod
=
=
=
UninitializeMethod
.
StoreOpClear
)
)
;
}
)
.
expandWithParams
(
function
*
(
{
dimension
}
)
{
switch
(
dimension
)
{
case
'
2d
'
:
yield
{
layerCount
:
1
}
;
yield
{
layerCount
:
7
}
;
break
;
case
'
1d
'
:
case
'
3d
'
:
yield
{
layerCount
:
1
}
;
break
;
}
}
)
.
unless
(
(
{
sampleCount
layerCount
}
)
=
>
sampleCount
>
1
&
&
layerCount
>
1
)
.
unless
(
(
{
format
sampleCount
uninitializeMethod
readMethod
}
)
=
>
{
const
usage
=
getRequiredTextureUsage
(
format
sampleCount
uninitializeMethod
readMethod
)
;
const
info
=
kTextureFormatInfo
[
format
]
;
return
(
(
usage
&
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
)
!
=
=
0
&
&
info
.
color
&
&
!
info
.
colorRender
|
|
(
usage
&
GPUConst
.
TextureUsage
.
STORAGE_BINDING
)
!
=
=
0
&
&
!
info
.
color
?
.
storage
|
|
sampleCount
>
1
&
&
!
info
.
multisample
)
;
}
)
.
combine
(
'
nonPowerOfTwo
'
[
false
true
]
)
.
combine
(
'
canaryOnCreation
'
[
false
true
]
)
;
