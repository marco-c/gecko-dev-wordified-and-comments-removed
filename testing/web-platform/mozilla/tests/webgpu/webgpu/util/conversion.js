import
{
Colors
}
from
'
.
.
/
.
.
/
common
/
util
/
colors
.
js
'
;
import
{
assert
objectEquals
unreachable
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
Float16Array
}
from
'
.
.
/
.
.
/
external
/
petamoriken
/
float16
/
float16
.
js
'
;
import
{
kBit
}
from
'
.
/
constants
.
js
'
;
import
{
cartesianProduct
clamp
correctlyRoundedF16
isFiniteF16
isSubnormalNumberF16
isSubnormalNumberF32
isSubnormalNumberF64
}
from
'
.
/
math
.
js
'
;
export
function
floatAsNormalizedInteger
(
float
bits
signed
)
{
if
(
signed
)
{
assert
(
float
>
=
-
1
&
&
float
<
=
1
(
)
=
>
{
float
}
out
of
bounds
of
snorm
)
;
const
max
=
Math
.
pow
(
2
bits
-
1
)
-
1
;
return
Math
.
round
(
float
*
max
)
;
}
else
{
assert
(
float
>
=
0
&
&
float
<
=
1
(
)
=
>
{
float
}
out
of
bounds
of
unorm
)
;
const
max
=
Math
.
pow
(
2
bits
)
-
1
;
return
Math
.
round
(
float
*
max
)
;
}
}
export
function
normalizedIntegerAsFloat
(
integer
bits
signed
)
{
assert
(
Number
.
isInteger
(
integer
)
)
;
if
(
signed
)
{
const
max
=
Math
.
pow
(
2
bits
-
1
)
-
1
;
assert
(
integer
>
=
-
max
-
1
&
&
integer
<
=
max
)
;
if
(
integer
=
=
=
-
max
-
1
)
{
integer
=
-
max
;
}
return
integer
/
max
;
}
else
{
const
max
=
Math
.
pow
(
2
bits
)
-
1
;
assert
(
integer
>
=
0
&
&
integer
<
=
max
)
;
return
integer
/
max
;
}
}
export
function
numbersApproximatelyEqual
(
a
b
maxDiff
=
0
)
{
return
(
(
Number
.
isNaN
(
a
)
&
&
Number
.
isNaN
(
b
)
)
|
|
(
a
=
=
=
Number
.
POSITIVE_INFINITY
&
&
b
=
=
=
Number
.
POSITIVE_INFINITY
)
|
|
(
a
=
=
=
Number
.
NEGATIVE_INFINITY
&
&
b
=
=
=
Number
.
NEGATIVE_INFINITY
)
|
|
Math
.
abs
(
a
-
b
)
<
=
maxDiff
)
;
}
export
function
float32ToFloatBits
(
n
signBits
exponentBits
mantissaBits
bias
)
{
assert
(
exponentBits
<
=
8
)
;
assert
(
mantissaBits
<
=
23
)
;
if
(
Number
.
isNaN
(
n
)
)
{
return
(
(
(
1
<
<
exponentBits
)
-
1
)
<
<
mantissaBits
)
|
(
(
1
<
<
mantissaBits
)
-
1
)
;
}
const
buf
=
new
DataView
(
new
ArrayBuffer
(
Float32Array
.
BYTES_PER_ELEMENT
)
)
;
buf
.
setFloat32
(
0
n
true
)
;
const
bits
=
buf
.
getUint32
(
0
true
)
;
const
sign
=
(
bits
>
>
31
)
&
signBits
;
if
(
n
=
=
=
0
)
{
if
(
sign
=
=
=
1
)
{
return
1
<
<
(
exponentBits
+
mantissaBits
)
;
}
return
0
;
}
if
(
signBits
=
=
=
0
)
{
assert
(
n
>
=
0
)
;
}
if
(
!
Number
.
isFinite
(
n
)
)
{
return
(
(
(
(
1
<
<
exponentBits
)
-
1
)
<
<
mantissaBits
)
|
(
n
<
0
?
2
*
*
(
exponentBits
+
mantissaBits
)
:
0
)
)
;
}
const
mantissaBitsToDiscard
=
23
-
mantissaBits
;
const
exp
=
(
(
bits
>
>
23
)
&
0xff
)
-
127
;
const
newBiasedExp
=
bias
+
exp
;
assert
(
newBiasedExp
<
1
<
<
exponentBits
(
)
=
>
input
number
{
n
}
overflows
target
type
)
;
if
(
newBiasedExp
<
=
0
)
{
return
sign
<
<
(
exponentBits
+
mantissaBits
)
;
}
else
{
const
newMantissa
=
(
bits
&
0x7fffff
)
>
>
mantissaBitsToDiscard
;
return
(
sign
<
<
(
exponentBits
+
mantissaBits
)
)
|
(
newBiasedExp
<
<
mantissaBits
)
|
newMantissa
;
}
}
export
function
float32ToFloat16Bits
(
n
)
{
return
float32ToFloatBits
(
n
1
5
10
15
)
;
}
export
function
float16BitsToFloat32
(
float16Bits
)
{
return
floatBitsToNumber
(
float16Bits
kFloat16Format
)
;
}
export
const
kFloat32Format
=
{
signed
:
1
exponentBits
:
8
mantissaBits
:
23
bias
:
127
}
;
export
const
kFloat16Format
=
{
signed
:
1
exponentBits
:
5
mantissaBits
:
10
bias
:
15
}
;
export
const
kUFloat9e5Format
=
{
signed
:
0
exponentBits
:
5
mantissaBits
:
9
bias
:
15
}
;
const
workingData
=
new
ArrayBuffer
(
4
)
;
const
workingDataU32
=
new
Uint32Array
(
workingData
)
;
const
workingDataU16
=
new
Uint16Array
(
workingData
)
;
const
workingDataU8
=
new
Uint8Array
(
workingData
)
;
const
workingDataF32
=
new
Float32Array
(
workingData
)
;
const
workingDataF16
=
new
Float16Array
(
workingData
)
;
const
workingDataI16
=
new
Int16Array
(
workingData
)
;
const
workingDataI8
=
new
Int8Array
(
workingData
)
;
export
function
float32BitsToNumber
(
bits
)
{
workingDataU32
[
0
]
=
bits
;
return
workingDataF32
[
0
]
;
}
export
function
numberToFloat32Bits
(
number
)
{
workingDataF32
[
0
]
=
number
;
return
workingDataU32
[
0
]
;
}
export
function
floatBitsToNumber
(
bits
fmt
)
{
const
kNonSignBits
=
fmt
.
exponentBits
+
fmt
.
mantissaBits
;
const
kNonSignBitsMask
=
(
1
<
<
kNonSignBits
)
-
1
;
const
exponentAndMantissaBits
=
bits
&
kNonSignBitsMask
;
const
exponentMask
=
(
(
1
<
<
fmt
.
exponentBits
)
-
1
)
<
<
fmt
.
mantissaBits
;
const
infinityOrNaN
=
(
bits
&
exponentMask
)
=
=
=
exponentMask
;
if
(
infinityOrNaN
)
{
const
mantissaMask
=
(
1
<
<
fmt
.
mantissaBits
)
-
1
;
const
signBit
=
2
*
*
kNonSignBits
;
const
isNegative
=
(
bits
&
signBit
)
!
=
=
0
;
return
bits
&
mantissaMask
?
Number
.
NaN
:
isNegative
?
Number
.
NEGATIVE_INFINITY
:
Number
.
POSITIVE_INFINITY
;
}
let
f32BitsWithWrongBias
=
exponentAndMantissaBits
<
<
(
kFloat32Format
.
mantissaBits
-
fmt
.
mantissaBits
)
;
f32BitsWithWrongBias
|
=
(
bits
<
<
(
31
-
kNonSignBits
)
)
&
0x8000_0000
;
const
numberWithWrongBias
=
float32BitsToNumber
(
f32BitsWithWrongBias
)
;
return
numberWithWrongBias
*
2
*
*
(
kFloat32Format
.
bias
-
fmt
.
bias
)
;
}
export
function
ufloatM9E5BitsToNumber
(
bits
fmt
)
{
const
exponent
=
bits
>
>
fmt
.
mantissaBits
;
const
mantissaMask
=
(
1
<
<
fmt
.
mantissaBits
)
-
1
;
const
mantissa
=
bits
&
mantissaMask
;
return
mantissa
*
2
*
*
(
exponent
-
fmt
.
bias
-
fmt
.
mantissaBits
)
;
}
export
function
numberToFloatBits
(
number
fmt
)
{
return
float32ToFloatBits
(
number
fmt
.
signed
fmt
.
exponentBits
fmt
.
mantissaBits
fmt
.
bias
)
;
}
export
function
floatBitsToNormalULPFromZero
(
bits
fmt
)
{
const
mask_sign
=
fmt
.
signed
<
<
(
fmt
.
exponentBits
+
fmt
.
mantissaBits
)
;
const
mask_expt
=
(
(
1
<
<
fmt
.
exponentBits
)
-
1
)
<
<
fmt
.
mantissaBits
;
const
mask_mant
=
(
1
<
<
fmt
.
mantissaBits
)
-
1
;
const
mask_rest
=
mask_expt
|
mask_mant
;
assert
(
fmt
.
exponentBits
+
fmt
.
mantissaBits
<
=
31
)
;
const
sign
=
bits
&
mask_sign
?
-
1
:
1
;
const
rest
=
bits
&
mask_rest
;
const
subnormal_or_zero
=
(
bits
&
mask_expt
)
=
=
=
0
;
const
infinity_or_nan
=
(
bits
&
mask_expt
)
=
=
=
mask_expt
;
assert
(
!
infinity_or_nan
'
no
ulp
representation
for
infinity
/
nan
'
)
;
const
abs_ulp_from_zero
=
subnormal_or_zero
?
0
:
rest
-
mask_mant
;
return
sign
*
abs_ulp_from_zero
;
}
export
function
packRGB9E5UFloat
(
r
g
b
)
{
const
N
=
9
;
const
Emax
=
31
;
const
B
=
15
;
const
sharedexp_max
=
(
(
(
1
<
<
N
)
-
1
)
/
(
1
<
<
N
)
)
*
2
*
*
(
Emax
-
B
)
;
const
red_c
=
clamp
(
r
{
min
:
0
max
:
sharedexp_max
}
)
;
const
green_c
=
clamp
(
g
{
min
:
0
max
:
sharedexp_max
}
)
;
const
blue_c
=
clamp
(
b
{
min
:
0
max
:
sharedexp_max
}
)
;
const
max_c
=
Math
.
max
(
red_c
green_c
blue_c
)
;
const
exp_shared_p
=
Math
.
max
(
-
B
-
1
Math
.
floor
(
Math
.
log2
(
max_c
)
)
)
+
1
+
B
;
const
max_s
=
Math
.
floor
(
max_c
/
2
*
*
(
exp_shared_p
-
B
-
N
)
+
0
.
5
)
;
const
exp_shared
=
max_s
=
=
=
1
<
<
N
?
exp_shared_p
+
1
:
exp_shared_p
;
const
scalar
=
1
/
2
*
*
(
exp_shared
-
B
-
N
)
;
const
red_s
=
Math
.
floor
(
red_c
*
scalar
+
0
.
5
)
;
const
green_s
=
Math
.
floor
(
green_c
*
scalar
+
0
.
5
)
;
const
blue_s
=
Math
.
floor
(
blue_c
*
scalar
+
0
.
5
)
;
assert
(
red_s
>
=
0
&
&
red_s
<
=
0b111111111
)
;
assert
(
green_s
>
=
0
&
&
green_s
<
=
0b111111111
)
;
assert
(
blue_s
>
=
0
&
&
blue_s
<
=
0b111111111
)
;
assert
(
exp_shared
>
=
0
&
&
exp_shared
<
=
0b11111
)
;
return
(
(
exp_shared
<
<
27
)
|
(
blue_s
<
<
18
)
|
(
green_s
<
<
9
)
|
red_s
)
>
>
>
0
;
}
export
function
unpackRGB9E5UFloat
(
encoded
)
{
const
N
=
9
;
const
B
=
15
;
const
red_s
=
(
encoded
>
>
>
0
)
&
0b111111111
;
const
green_s
=
(
encoded
>
>
>
9
)
&
0b111111111
;
const
blue_s
=
(
encoded
>
>
>
18
)
&
0b111111111
;
const
exp_shared
=
(
encoded
>
>
>
27
)
&
0b11111
;
const
exp
=
Math
.
pow
(
2
exp_shared
-
B
-
N
)
;
return
{
R
:
exp
*
red_s
G
:
exp
*
green_s
B
:
exp
*
blue_s
}
;
}
export
function
pack2x16float
(
x
y
)
{
const
generateU16s
=
n
=
>
{
let
contains_subnormals
=
isSubnormalNumberF32
(
n
)
;
const
n_f16s
=
correctlyRoundedF16
(
n
)
;
contains_subnormals
|
|
=
n_f16s
.
some
(
isSubnormalNumberF16
)
;
const
n_u16s
=
n_f16s
.
map
(
f16
=
>
{
workingDataF16
[
0
]
=
f16
;
return
workingDataU16
[
0
]
;
}
)
;
const
contains_poszero
=
n_u16s
.
some
(
u
=
>
u
=
=
=
kBit
.
f16
.
positive
.
zero
)
;
const
contains_negzero
=
n_u16s
.
some
(
u
=
>
u
=
=
=
kBit
.
f16
.
negative
.
zero
)
;
if
(
!
contains_negzero
&
&
(
contains_poszero
|
|
contains_subnormals
)
)
{
n_u16s
.
push
(
kBit
.
f16
.
negative
.
zero
)
;
}
if
(
!
contains_poszero
&
&
(
contains_negzero
|
|
contains_subnormals
)
)
{
n_u16s
.
push
(
kBit
.
f16
.
positive
.
zero
)
;
}
return
n_u16s
;
}
;
if
(
!
isFiniteF16
(
x
)
|
|
!
isFiniteF16
(
y
)
)
{
return
[
undefined
]
;
}
const
results
=
new
Array
(
)
;
for
(
const
p
of
cartesianProduct
(
generateU16s
(
x
)
generateU16s
(
y
)
)
)
{
assert
(
p
.
length
=
=
=
2
'
cartesianProduct
of
2
arrays
returned
an
entry
with
not
2
elements
'
)
;
workingDataU16
[
0
]
=
p
[
0
]
;
workingDataU16
[
1
]
=
p
[
1
]
;
results
.
push
(
workingDataU32
[
0
]
)
;
}
return
results
;
}
export
function
pack2x16snorm
(
x
y
)
{
const
generateI16
=
n
=
>
{
return
Math
.
floor
(
0
.
5
+
32767
*
Math
.
min
(
1
Math
.
max
(
-
1
n
)
)
)
;
}
;
workingDataI16
[
0
]
=
generateI16
(
x
)
;
workingDataI16
[
1
]
=
generateI16
(
y
)
;
return
workingDataU32
[
0
]
;
}
export
function
pack2x16unorm
(
x
y
)
{
const
generateU16
=
n
=
>
{
return
Math
.
floor
(
0
.
5
+
65535
*
Math
.
min
(
1
Math
.
max
(
0
n
)
)
)
;
}
;
workingDataU16
[
0
]
=
generateU16
(
x
)
;
workingDataU16
[
1
]
=
generateU16
(
y
)
;
return
workingDataU32
[
0
]
;
}
export
function
pack4x8snorm
(
.
.
.
vals
)
{
const
generateI8
=
n
=
>
{
return
Math
.
floor
(
0
.
5
+
127
*
Math
.
min
(
1
Math
.
max
(
-
1
n
)
)
)
;
}
;
for
(
const
idx
in
vals
)
{
workingDataI8
[
idx
]
=
generateI8
(
vals
[
idx
]
)
;
}
return
workingDataU32
[
0
]
;
}
export
function
pack4x8unorm
(
.
.
.
vals
)
{
const
generateU8
=
n
=
>
{
return
Math
.
floor
(
0
.
5
+
255
*
Math
.
min
(
1
Math
.
max
(
0
n
)
)
)
;
}
;
for
(
const
idx
in
vals
)
{
workingDataU8
[
idx
]
=
generateU8
(
vals
[
idx
]
)
;
}
return
workingDataU32
[
0
]
;
}
export
function
assertInIntegerRange
(
n
bits
signed
)
{
if
(
signed
)
{
const
min
=
-
Math
.
pow
(
2
bits
-
1
)
;
const
max
=
Math
.
pow
(
2
bits
-
1
)
-
1
;
assert
(
n
>
=
min
&
&
n
<
=
max
)
;
}
else
{
const
max
=
Math
.
pow
(
2
bits
)
-
1
;
assert
(
n
>
=
0
&
&
n
<
=
max
)
;
}
}
export
function
gammaCompress
(
n
)
{
n
=
n
<
=
0
.
0031308
?
(
323
*
n
)
/
25
:
(
211
*
Math
.
pow
(
n
5
/
12
)
-
11
)
/
200
;
return
clamp
(
n
{
min
:
0
max
:
1
}
)
;
}
export
function
gammaDecompress
(
n
)
{
n
=
n
<
=
0
.
04045
?
(
n
*
25
)
/
323
:
Math
.
pow
(
(
200
*
n
+
11
)
/
211
12
/
5
)
;
return
clamp
(
n
{
min
:
0
max
:
1
}
)
;
}
export
function
float32ToUint32
(
f32
)
{
const
f32Arr
=
new
Float32Array
(
1
)
;
f32Arr
[
0
]
=
f32
;
const
u32Arr
=
new
Uint32Array
(
f32Arr
.
buffer
)
;
return
u32Arr
[
0
]
;
}
export
function
uint32ToFloat32
(
u32
)
{
const
u32Arr
=
new
Uint32Array
(
1
)
;
u32Arr
[
0
]
=
u32
;
const
f32Arr
=
new
Float32Array
(
u32Arr
.
buffer
)
;
return
f32Arr
[
0
]
;
}
export
function
float32ToInt32
(
f32
)
{
const
f32Arr
=
new
Float32Array
(
1
)
;
f32Arr
[
0
]
=
f32
;
const
i32Arr
=
new
Int32Array
(
f32Arr
.
buffer
)
;
return
i32Arr
[
0
]
;
}
export
function
uint32ToInt32
(
u32
)
{
const
u32Arr
=
new
Uint32Array
(
1
)
;
u32Arr
[
0
]
=
u32
;
const
i32Arr
=
new
Int32Array
(
u32Arr
.
buffer
)
;
return
i32Arr
[
0
]
;
}
export
function
float16ToUint16
(
f16
)
{
const
f16Arr
=
new
Float16Array
(
1
)
;
f16Arr
[
0
]
=
f16
;
const
u16Arr
=
new
Uint16Array
(
f16Arr
.
buffer
)
;
return
u16Arr
[
0
]
;
}
export
function
uint16ToFloat16
(
u16
)
{
const
u16Arr
=
new
Uint16Array
(
1
)
;
u16Arr
[
0
]
=
u16
;
const
f16Arr
=
new
Float16Array
(
u16Arr
.
buffer
)
;
return
f16Arr
[
0
]
;
}
export
function
float16ToInt16
(
f16
)
{
const
f16Arr
=
new
Float16Array
(
1
)
;
f16Arr
[
0
]
=
f16
;
const
i16Arr
=
new
Int16Array
(
f16Arr
.
buffer
)
;
return
i16Arr
[
0
]
;
}
export
class
ScalarType
{
constructor
(
kind
size
read
)
{
this
.
kind
=
kind
;
this
.
_size
=
size
;
this
.
read
=
read
;
}
toString
(
)
{
return
this
.
kind
;
}
get
size
(
)
{
return
this
.
_size
;
}
create
(
value
)
{
switch
(
this
.
kind
)
{
case
'
abstract
-
float
'
:
return
abstractFloat
(
value
)
;
case
'
f64
'
:
return
f64
(
value
)
;
case
'
f32
'
:
return
f32
(
value
)
;
case
'
f16
'
:
return
f16
(
value
)
;
case
'
u32
'
:
return
u32
(
value
)
;
case
'
u16
'
:
return
u16
(
value
)
;
case
'
u8
'
:
return
u8
(
value
)
;
case
'
i32
'
:
return
i32
(
value
)
;
case
'
i16
'
:
return
i16
(
value
)
;
case
'
i8
'
:
return
i8
(
value
)
;
case
'
bool
'
:
return
bool
(
value
!
=
=
0
)
;
}
}
}
export
class
VectorType
{
constructor
(
width
elementType
)
{
this
.
width
=
width
;
this
.
elementType
=
elementType
;
}
read
(
buf
offset
)
{
const
elements
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
width
;
i
+
+
)
{
elements
[
i
]
=
this
.
elementType
.
read
(
buf
offset
)
;
offset
+
=
this
.
elementType
.
size
;
}
return
new
Vector
(
elements
)
;
}
toString
(
)
{
return
vec
{
this
.
width
}
<
{
this
.
elementType
}
>
;
}
get
size
(
)
{
return
this
.
elementType
.
size
*
this
.
width
;
}
create
(
value
)
{
if
(
value
instanceof
Array
)
{
assert
(
value
.
length
=
=
=
this
.
width
)
;
}
else
{
value
=
Array
(
this
.
width
)
.
fill
(
value
)
;
}
return
new
Vector
(
value
.
map
(
v
=
>
this
.
elementType
.
create
(
v
)
)
)
;
}
}
const
vectorTypes
=
new
Map
(
)
;
export
function
TypeVec
(
width
elementType
)
{
const
key
=
{
elementType
.
toString
(
)
}
{
width
}
}
;
let
ty
=
vectorTypes
.
get
(
key
)
;
if
(
ty
!
=
=
undefined
)
{
return
ty
;
}
ty
=
new
VectorType
(
width
elementType
)
;
vectorTypes
.
set
(
key
ty
)
;
return
ty
;
}
export
class
MatrixType
{
constructor
(
cols
rows
elementType
)
{
this
.
cols
=
cols
;
this
.
rows
=
rows
;
assert
(
elementType
.
kind
=
=
=
'
f32
'
|
|
elementType
.
kind
=
=
=
'
f16
'
|
|
elementType
.
kind
=
=
=
'
abstract
-
float
'
"
MatrixType
can
only
have
elementType
of
'
f32
'
or
'
f16
'
or
'
abstract
-
float
'
"
)
;
this
.
elementType
=
elementType
;
}
read
(
buf
offset
)
{
const
elements
=
[
.
.
.
Array
(
this
.
cols
)
]
.
map
(
_
=
>
[
.
.
.
Array
(
this
.
rows
)
]
)
;
for
(
let
c
=
0
;
c
<
this
.
cols
;
c
+
+
)
{
for
(
let
r
=
0
;
r
<
this
.
rows
;
r
+
+
)
{
elements
[
c
]
[
r
]
=
this
.
elementType
.
read
(
buf
offset
)
;
offset
+
=
this
.
elementType
.
size
;
}
if
(
this
.
rows
=
=
=
3
)
{
offset
+
=
this
.
elementType
.
size
;
}
}
return
new
Matrix
(
elements
)
;
}
toString
(
)
{
return
mat
{
this
.
cols
}
x
{
this
.
rows
}
<
{
this
.
elementType
}
>
;
}
}
const
matrixTypes
=
new
Map
(
)
;
export
function
TypeMat
(
cols
rows
elementType
)
{
const
key
=
{
elementType
.
toString
(
)
}
{
cols
}
{
rows
}
;
let
ty
=
matrixTypes
.
get
(
key
)
;
if
(
ty
!
=
=
undefined
)
{
return
ty
;
}
ty
=
new
MatrixType
(
cols
rows
elementType
)
;
matrixTypes
.
set
(
key
ty
)
;
return
ty
;
}
export
const
TypeI32
=
new
ScalarType
(
'
i32
'
4
(
buf
offset
)
=
>
i32
(
new
Int32Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeU32
=
new
ScalarType
(
'
u32
'
4
(
buf
offset
)
=
>
u32
(
new
Uint32Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeAbstractFloat
=
new
ScalarType
(
'
abstract
-
float
'
8
(
buf
offset
)
=
>
abstractFloat
(
new
Float64Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeF64
=
new
ScalarType
(
'
f64
'
8
(
buf
offset
)
=
>
f64
(
new
Float64Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeF32
=
new
ScalarType
(
'
f32
'
4
(
buf
offset
)
=
>
f32
(
new
Float32Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeI16
=
new
ScalarType
(
'
i16
'
2
(
buf
offset
)
=
>
i16
(
new
Int16Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeU16
=
new
ScalarType
(
'
u16
'
2
(
buf
offset
)
=
>
u16
(
new
Uint16Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeF16
=
new
ScalarType
(
'
f16
'
2
(
buf
offset
)
=
>
f16Bits
(
new
Uint16Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeI8
=
new
ScalarType
(
'
i8
'
1
(
buf
offset
)
=
>
i8
(
new
Int8Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeU8
=
new
ScalarType
(
'
u8
'
1
(
buf
offset
)
=
>
u8
(
new
Uint8Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeBool
=
new
ScalarType
(
'
bool
'
4
(
buf
offset
)
=
>
bool
(
new
Uint32Array
(
buf
.
buffer
offset
)
[
0
]
!
=
=
0
)
)
;
export
function
scalarType
(
kind
)
{
switch
(
kind
)
{
case
'
abstract
-
float
'
:
return
TypeAbstractFloat
;
case
'
f64
'
:
return
TypeF64
;
case
'
f32
'
:
return
TypeF32
;
case
'
f16
'
:
return
TypeF16
;
case
'
u32
'
:
return
TypeU32
;
case
'
u16
'
:
return
TypeU16
;
case
'
u8
'
:
return
TypeU8
;
case
'
i32
'
:
return
TypeI32
;
case
'
i16
'
:
return
TypeI16
;
case
'
i8
'
:
return
TypeI8
;
case
'
bool
'
:
return
TypeBool
;
}
}
export
function
numElementsOf
(
ty
)
{
if
(
ty
instanceof
ScalarType
)
{
return
1
;
}
if
(
ty
instanceof
VectorType
)
{
return
ty
.
width
;
}
if
(
ty
instanceof
MatrixType
)
{
return
ty
.
cols
*
ty
.
rows
;
}
throw
new
Error
(
unhandled
type
{
ty
}
)
;
}
export
function
elementsOf
(
value
)
{
if
(
value
instanceof
Scalar
)
{
return
[
value
]
;
}
if
(
value
instanceof
Vector
)
{
return
value
.
elements
;
}
if
(
value
instanceof
Matrix
)
{
return
value
.
elements
.
flat
(
)
;
}
throw
new
Error
(
unhandled
value
{
value
}
)
;
}
export
function
scalarTypeOf
(
ty
)
{
if
(
ty
instanceof
ScalarType
)
{
return
ty
;
}
if
(
ty
instanceof
VectorType
)
{
return
ty
.
elementType
;
}
if
(
ty
instanceof
MatrixType
)
{
return
ty
.
elementType
;
}
throw
new
Error
(
unhandled
type
{
ty
}
)
;
}
export
class
Scalar
{
constructor
(
type
value
bits
)
{
this
.
value
=
value
;
this
.
type
=
type
;
this
.
bits
=
new
Uint8Array
(
bits
.
buffer
)
;
}
copyTo
(
buffer
offset
)
{
assert
(
this
.
type
.
kind
!
=
=
'
f64
'
Copying
f64
values
to
/
from
buffers
is
not
defined
)
;
for
(
let
i
=
0
;
i
<
this
.
bits
.
length
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
this
.
bits
[
i
]
;
}
}
wgsl
(
)
{
const
withPoint
=
x
=
>
{
const
str
=
{
x
}
;
return
str
.
indexOf
(
'
.
'
)
>
0
|
|
str
.
indexOf
(
'
e
'
)
>
0
?
str
:
{
str
}
.
0
;
}
;
if
(
isFinite
(
this
.
value
)
)
{
switch
(
this
.
type
.
kind
)
{
case
'
abstract
-
float
'
:
return
{
withPoint
(
this
.
value
)
}
;
case
'
f64
'
:
return
{
withPoint
(
this
.
value
)
}
;
case
'
f32
'
:
return
{
withPoint
(
this
.
value
)
}
f
;
case
'
f16
'
:
return
{
withPoint
(
this
.
value
)
}
h
;
case
'
u32
'
:
return
{
this
.
value
}
u
;
case
'
i32
'
:
return
i32
(
{
this
.
value
}
)
;
case
'
bool
'
:
return
{
this
.
value
}
;
}
}
throw
new
Error
(
scalar
of
value
{
this
.
value
}
and
type
{
this
.
type
}
has
no
WGSL
representation
)
;
}
toString
(
)
{
if
(
this
.
type
.
kind
=
=
=
'
bool
'
)
{
return
Colors
.
bold
(
this
.
value
.
toString
(
)
)
;
}
switch
(
this
.
value
)
{
case
Infinity
:
case
-
Infinity
:
return
Colors
.
bold
(
this
.
value
.
toString
(
)
)
;
default
:
{
const
hex
=
Array
.
from
(
this
.
bits
)
.
reverse
(
)
.
map
(
x
=
>
x
.
toString
(
16
)
.
padStart
(
2
'
0
'
)
)
.
join
(
'
'
)
;
const
n
=
this
.
value
;
if
(
n
!
=
=
null
&
&
isFloatValue
(
this
)
)
{
let
str
=
this
.
value
.
toString
(
)
;
str
=
str
.
indexOf
(
'
.
'
)
>
0
|
|
str
.
indexOf
(
'
e
'
)
>
0
?
str
:
{
str
}
.
0
;
switch
(
this
.
type
.
kind
)
{
case
'
abstract
-
float
'
:
return
isSubnormalNumberF64
(
n
.
valueOf
(
)
)
?
{
Colors
.
bold
(
str
)
}
(
0x
{
hex
}
subnormal
)
:
{
Colors
.
bold
(
str
)
}
(
0x
{
hex
}
)
;
case
'
f64
'
:
return
isSubnormalNumberF64
(
n
.
valueOf
(
)
)
?
{
Colors
.
bold
(
str
)
}
(
0x
{
hex
}
subnormal
)
:
{
Colors
.
bold
(
str
)
}
(
0x
{
hex
}
)
;
case
'
f32
'
:
return
isSubnormalNumberF32
(
n
.
valueOf
(
)
)
?
{
Colors
.
bold
(
str
)
}
(
0x
{
hex
}
subnormal
)
:
{
Colors
.
bold
(
str
)
}
(
0x
{
hex
}
)
;
case
'
f16
'
:
return
isSubnormalNumberF16
(
n
.
valueOf
(
)
)
?
{
Colors
.
bold
(
str
)
}
(
0x
{
hex
}
subnormal
)
:
{
Colors
.
bold
(
str
)
}
(
0x
{
hex
}
)
;
default
:
unreachable
(
Printing
of
floating
point
kind
{
this
.
type
.
kind
}
is
not
implemented
.
.
.
)
;
}
}
return
{
Colors
.
bold
(
this
.
value
.
toString
(
)
)
}
(
0x
{
hex
}
)
;
}
}
}
}
export
function
abstractFloat
(
value
)
{
const
arr
=
new
Float64Array
(
[
value
]
)
;
return
new
Scalar
(
TypeAbstractFloat
arr
[
0
]
arr
)
;
}
export
function
f64
(
value
)
{
const
arr
=
new
Float64Array
(
[
value
]
)
;
return
new
Scalar
(
TypeF64
arr
[
0
]
arr
)
;
}
export
function
f32
(
value
)
{
const
arr
=
new
Float32Array
(
[
value
]
)
;
return
new
Scalar
(
TypeF32
arr
[
0
]
arr
)
;
}
export
function
f16
(
value
)
{
const
arr
=
new
Float16Array
(
[
value
]
)
;
return
new
Scalar
(
TypeF16
arr
[
0
]
arr
)
;
}
export
function
f32Bits
(
bits
)
{
const
arr
=
new
Uint32Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeF32
new
Float32Array
(
arr
.
buffer
)
[
0
]
arr
)
;
}
export
function
f16Bits
(
bits
)
{
const
arr
=
new
Uint16Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeF16
new
Float16Array
(
arr
.
buffer
)
[
0
]
arr
)
;
}
export
function
i32
(
value
)
{
const
arr
=
new
Int32Array
(
[
value
]
)
;
return
new
Scalar
(
TypeI32
arr
[
0
]
arr
)
;
}
export
function
i16
(
value
)
{
const
arr
=
new
Int16Array
(
[
value
]
)
;
return
new
Scalar
(
TypeI16
arr
[
0
]
arr
)
;
}
export
function
i8
(
value
)
{
const
arr
=
new
Int8Array
(
[
value
]
)
;
return
new
Scalar
(
TypeI8
arr
[
0
]
arr
)
;
}
export
function
i32Bits
(
bits
)
{
const
arr
=
new
Uint32Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeI32
new
Int32Array
(
arr
.
buffer
)
[
0
]
arr
)
;
}
export
function
i16Bits
(
bits
)
{
const
arr
=
new
Uint16Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeI16
new
Int16Array
(
arr
.
buffer
)
[
0
]
arr
)
;
}
export
function
i8Bits
(
bits
)
{
const
arr
=
new
Uint8Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeI8
new
Int8Array
(
arr
.
buffer
)
[
0
]
arr
)
;
}
export
function
u32
(
value
)
{
const
arr
=
new
Uint32Array
(
[
value
]
)
;
return
new
Scalar
(
TypeU32
arr
[
0
]
arr
)
;
}
export
function
u16
(
value
)
{
const
arr
=
new
Uint16Array
(
[
value
]
)
;
return
new
Scalar
(
TypeU16
arr
[
0
]
arr
)
;
}
export
function
u8
(
value
)
{
const
arr
=
new
Uint8Array
(
[
value
]
)
;
return
new
Scalar
(
TypeU8
arr
[
0
]
arr
)
;
}
export
function
u32Bits
(
bits
)
{
const
arr
=
new
Uint32Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeU32
bits
arr
)
;
}
export
function
u16Bits
(
bits
)
{
const
arr
=
new
Uint16Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeU16
bits
arr
)
;
}
export
function
u8Bits
(
bits
)
{
const
arr
=
new
Uint8Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeU8
bits
arr
)
;
}
export
function
bool
(
value
)
{
const
arr
=
new
Uint32Array
(
[
value
?
1
:
0
]
)
;
return
new
Scalar
(
TypeBool
value
arr
)
;
}
export
const
True
=
bool
(
true
)
;
export
const
False
=
bool
(
false
)
;
export
function
reinterpretF64AsU32s
(
f64
)
{
const
array
=
new
Float64Array
(
1
)
;
array
[
0
]
=
f64
;
const
u32s
=
new
Uint32Array
(
array
.
buffer
)
;
return
[
u32s
[
0
]
u32s
[
1
]
]
;
}
export
function
reinterpretU32sAsF64
(
u32s
)
{
const
array
=
new
Uint32Array
(
2
)
;
array
[
0
]
=
u32s
[
0
]
;
array
[
1
]
=
u32s
[
1
]
;
return
new
Float64Array
(
array
.
buffer
)
[
0
]
;
}
export
function
reinterpretF32AsU32
(
f32
)
{
const
array
=
new
Float32Array
(
1
)
;
array
[
0
]
=
f32
;
return
new
Uint32Array
(
array
.
buffer
)
[
0
]
;
}
export
function
reinterpretF32AsI32
(
f32
)
{
const
array
=
new
Float32Array
(
1
)
;
array
[
0
]
=
f32
;
return
new
Int32Array
(
array
.
buffer
)
[
0
]
;
}
export
function
reinterpretU32AsF32
(
u32
)
{
const
array
=
new
Uint32Array
(
1
)
;
array
[
0
]
=
u32
;
return
new
Float32Array
(
array
.
buffer
)
[
0
]
;
}
export
function
reinterpretU32AsI32
(
u32
)
{
const
array
=
new
Uint32Array
(
1
)
;
array
[
0
]
=
u32
;
return
new
Int32Array
(
array
.
buffer
)
[
0
]
;
}
export
function
reinterpretI32AsU32
(
i32
)
{
const
array
=
new
Int32Array
(
1
)
;
array
[
0
]
=
i32
;
return
new
Uint32Array
(
array
.
buffer
)
[
0
]
;
}
export
function
reinterpretI32AsF32
(
i32
)
{
const
array
=
new
Int32Array
(
1
)
;
array
[
0
]
=
i32
;
return
new
Float32Array
(
array
.
buffer
)
[
0
]
;
}
export
function
reinterpretF16AsU16
(
f16
)
{
const
array
=
new
Float16Array
(
1
)
;
array
[
0
]
=
f16
;
return
new
Uint16Array
(
array
.
buffer
)
[
0
]
;
}
export
function
reinterpretU16AsF16
(
u16
)
{
const
array
=
new
Uint16Array
(
1
)
;
array
[
0
]
=
u16
;
return
new
Float16Array
(
array
.
buffer
)
[
0
]
;
}
export
class
Vector
{
constructor
(
elements
)
{
if
(
elements
.
length
<
2
|
|
elements
.
length
>
4
)
{
throw
new
Error
(
vector
element
count
must
be
between
2
and
4
got
{
elements
.
length
}
)
;
}
for
(
let
i
=
1
;
i
<
elements
.
length
;
i
+
+
)
{
const
a
=
elements
[
0
]
.
type
;
const
b
=
elements
[
i
]
.
type
;
if
(
a
!
=
=
b
)
{
throw
new
Error
(
cannot
mix
vector
element
types
.
Found
elements
with
types
'
{
a
}
'
and
'
{
b
}
'
)
;
}
}
this
.
elements
=
elements
;
this
.
type
=
TypeVec
(
elements
.
length
elements
[
0
]
.
type
)
;
}
copyTo
(
buffer
offset
)
{
for
(
const
element
of
this
.
elements
)
{
element
.
copyTo
(
buffer
offset
)
;
offset
+
=
this
.
type
.
elementType
.
size
;
}
}
wgsl
(
)
{
const
els
=
this
.
elements
.
map
(
v
=
>
v
.
wgsl
(
)
)
.
join
(
'
'
)
;
return
vec
{
this
.
type
.
width
}
(
{
els
}
)
;
}
toString
(
)
{
return
{
this
.
type
}
(
{
this
.
elements
.
map
(
e
=
>
e
.
toString
(
)
)
.
join
(
'
'
)
}
)
;
}
get
x
(
)
{
assert
(
0
<
this
.
elements
.
length
)
;
return
this
.
elements
[
0
]
;
}
get
y
(
)
{
assert
(
1
<
this
.
elements
.
length
)
;
return
this
.
elements
[
1
]
;
}
get
z
(
)
{
assert
(
2
<
this
.
elements
.
length
)
;
return
this
.
elements
[
2
]
;
}
get
w
(
)
{
assert
(
3
<
this
.
elements
.
length
)
;
return
this
.
elements
[
3
]
;
}
}
export
function
vec2
(
x
y
)
{
return
new
Vector
(
[
x
y
]
)
;
}
export
function
vec3
(
x
y
z
)
{
return
new
Vector
(
[
x
y
z
]
)
;
}
export
function
vec4
(
x
y
z
w
)
{
return
new
Vector
(
[
x
y
z
w
]
)
;
}
export
function
toVector
(
v
op
)
{
switch
(
v
.
length
)
{
case
2
:
return
vec2
(
op
(
v
[
0
]
)
op
(
v
[
1
]
)
)
;
case
3
:
return
vec3
(
op
(
v
[
0
]
)
op
(
v
[
1
]
)
op
(
v
[
2
]
)
)
;
case
4
:
return
vec4
(
op
(
v
[
0
]
)
op
(
v
[
1
]
)
op
(
v
[
2
]
)
op
(
v
[
3
]
)
)
;
}
unreachable
(
input
to
'
toVector
'
must
contain
2
3
or
4
elements
)
;
}
export
class
Matrix
{
constructor
(
elements
)
{
const
num_cols
=
elements
.
length
;
if
(
num_cols
<
2
|
|
num_cols
>
4
)
{
throw
new
Error
(
matrix
cols
count
must
be
between
2
and
4
got
{
num_cols
}
)
;
}
const
num_rows
=
elements
[
0
]
.
length
;
if
(
!
elements
.
every
(
c
=
>
c
.
length
=
=
=
num_rows
)
)
{
throw
new
Error
(
cannot
mix
matrix
column
lengths
)
;
}
if
(
num_rows
<
2
|
|
num_rows
>
4
)
{
throw
new
Error
(
matrix
rows
count
must
be
between
2
and
4
got
{
num_rows
}
)
;
}
const
elem_type
=
elements
[
0
]
[
0
]
.
type
;
if
(
!
elements
.
every
(
c
=
>
c
.
every
(
r
=
>
objectEquals
(
r
.
type
elem_type
)
)
)
)
{
throw
new
Error
(
cannot
mix
matrix
element
types
)
;
}
this
.
elements
=
elements
;
this
.
type
=
TypeMat
(
num_cols
num_rows
elem_type
)
;
}
copyTo
(
buffer
offset
)
{
for
(
let
i
=
0
;
i
<
this
.
type
.
cols
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
this
.
type
.
rows
;
j
+
+
)
{
this
.
elements
[
i
]
[
j
]
.
copyTo
(
buffer
offset
)
;
offset
+
=
this
.
type
.
elementType
.
size
;
}
if
(
this
.
type
.
rows
=
=
=
3
)
{
offset
+
=
this
.
type
.
elementType
.
size
;
}
}
}
wgsl
(
)
{
const
els
=
this
.
elements
.
flatMap
(
c
=
>
c
.
map
(
r
=
>
r
.
wgsl
(
)
)
)
.
join
(
'
'
)
;
return
mat
{
this
.
type
.
cols
}
x
{
this
.
type
.
rows
}
(
{
els
}
)
;
}
toString
(
)
{
return
{
this
.
type
}
(
{
this
.
elements
.
map
(
c
=
>
c
.
join
(
'
'
)
)
.
join
(
'
'
)
}
)
;
}
}
export
function
toMatrix
(
m
op
)
{
const
cols
=
m
.
length
;
const
rows
=
m
[
0
]
.
length
;
const
elements
=
[
.
.
.
Array
(
cols
)
]
.
map
(
_
=
>
[
.
.
.
Array
(
rows
)
]
)
;
for
(
let
i
=
0
;
i
<
cols
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
rows
;
j
+
+
)
{
elements
[
i
]
[
j
]
=
op
(
m
[
i
]
[
j
]
)
;
}
}
return
new
Matrix
(
elements
)
;
}
export
function
serializeValue
(
v
)
{
const
value
=
(
kind
s
)
=
>
{
switch
(
kind
)
{
case
'
f32
'
:
return
new
Uint32Array
(
s
.
bits
.
buffer
)
[
0
]
;
case
'
f16
'
:
return
new
Uint16Array
(
s
.
bits
.
buffer
)
[
0
]
;
default
:
return
s
.
value
;
}
}
;
if
(
v
instanceof
Scalar
)
{
const
kind
=
v
.
type
.
kind
;
return
{
kind
:
'
scalar
'
type
:
kind
value
:
value
(
kind
v
)
}
;
}
if
(
v
instanceof
Vector
)
{
const
kind
=
v
.
type
.
elementType
.
kind
;
return
{
kind
:
'
vector
'
type
:
kind
value
:
v
.
elements
.
map
(
e
=
>
value
(
kind
e
)
)
}
;
}
if
(
v
instanceof
Matrix
)
{
const
kind
=
v
.
type
.
elementType
.
kind
;
return
{
kind
:
'
matrix
'
type
:
kind
value
:
v
.
elements
.
map
(
c
=
>
c
.
map
(
r
=
>
value
(
kind
r
)
)
)
}
;
}
unreachable
(
unhandled
value
type
:
{
v
}
)
;
}
export
function
deserializeValue
(
data
)
{
const
buildScalar
=
v
=
>
{
switch
(
data
.
type
)
{
case
'
abstract
-
float
'
:
return
abstractFloat
(
v
)
;
case
'
f64
'
:
return
f64
(
v
)
;
case
'
i32
'
:
return
i32
(
v
)
;
case
'
u32
'
:
return
u32
(
v
)
;
case
'
f32
'
:
return
f32Bits
(
v
)
;
case
'
i16
'
:
return
i16
(
v
)
;
case
'
u16
'
:
return
u16
(
v
)
;
case
'
f16
'
:
return
f16Bits
(
v
)
;
case
'
i8
'
:
return
i8
(
v
)
;
case
'
u8
'
:
return
u8
(
v
)
;
case
'
bool
'
:
return
bool
(
v
)
;
default
:
unreachable
(
unhandled
value
type
:
{
data
.
type
}
)
;
}
}
;
switch
(
data
.
kind
)
{
case
'
scalar
'
:
{
return
buildScalar
(
data
.
value
)
;
}
case
'
vector
'
:
{
return
new
Vector
(
data
.
value
.
map
(
v
=
>
buildScalar
(
v
)
)
)
;
}
case
'
matrix
'
:
{
return
new
Matrix
(
data
.
value
.
map
(
c
=
>
c
.
map
(
buildScalar
)
)
)
;
}
}
}
export
function
isFloatValue
(
v
)
{
return
isFloatType
(
v
.
type
)
;
}
export
function
isAbstractType
(
ty
)
{
if
(
ty
instanceof
ScalarType
)
{
return
ty
.
kind
=
=
=
'
abstract
-
float
'
;
}
return
false
;
}
export
function
isFloatType
(
ty
)
{
if
(
ty
instanceof
ScalarType
)
{
return
(
ty
.
kind
=
=
=
'
abstract
-
float
'
|
|
ty
.
kind
=
=
=
'
f64
'
|
|
ty
.
kind
=
=
=
'
f32
'
|
|
ty
.
kind
=
=
=
'
f16
'
)
;
}
return
false
;
}
export
const
kAllFloatScalars
=
[
TypeAbstractFloat
TypeF32
TypeF16
]
;
export
const
kAllFloatVector2
=
[
TypeVec
(
2
TypeAbstractFloat
)
TypeVec
(
2
TypeF32
)
TypeVec
(
2
TypeF16
)
]
;
export
const
kAllFloatVector3
=
[
TypeVec
(
3
TypeAbstractFloat
)
TypeVec
(
3
TypeF32
)
TypeVec
(
3
TypeF16
)
]
;
export
const
kAllFloatVector4
=
[
TypeVec
(
4
TypeAbstractFloat
)
TypeVec
(
4
TypeF32
)
TypeVec
(
4
TypeF16
)
]
;
export
const
kAllFloatVectors
=
[
.
.
.
kAllFloatVector2
.
.
.
kAllFloatVector3
.
.
.
kAllFloatVector4
]
;
export
const
kAllFloatScalarsAndVectors
=
[
.
.
.
kAllFloatScalars
.
.
.
kAllFloatVectors
]
;
export
const
kAllIntegerScalarsAndVectors
=
[
TypeI32
TypeVec
(
2
TypeI32
)
TypeVec
(
3
TypeI32
)
TypeVec
(
4
TypeI32
)
TypeU32
TypeVec
(
2
TypeU32
)
TypeVec
(
3
TypeU32
)
TypeVec
(
4
TypeU32
)
]
;
export
const
kAllSignedIntegerScalarsAndVectors
=
[
TypeI32
TypeVec
(
2
TypeI32
)
TypeVec
(
3
TypeI32
)
TypeVec
(
4
TypeI32
)
]
;
export
const
kAllUnsignedIntegerScalarsAndVectors
=
[
TypeU32
TypeVec
(
2
TypeU32
)
TypeVec
(
3
TypeU32
)
TypeVec
(
4
TypeU32
)
]
;
export
const
kAllFloatAndIntegerScalarsAndVectors
=
[
.
.
.
kAllFloatScalarsAndVectors
.
.
.
kAllIntegerScalarsAndVectors
]
;
export
const
kAllFloatAndSignedIntegerScalarsAndVectors
=
[
.
.
.
kAllFloatScalarsAndVectors
.
.
.
kAllSignedIntegerScalarsAndVectors
]
;
export
function
elementType
(
t
)
{
if
(
t
instanceof
ScalarType
)
{
return
t
;
}
return
t
.
elementType
;
}
