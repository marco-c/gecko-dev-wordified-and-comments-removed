import
{
Colors
}
from
'
.
.
/
.
.
/
common
/
util
/
colors
.
js
'
;
import
{
assert
unreachable
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
Float16Array
}
from
'
.
.
/
.
.
/
external
/
petamoriken
/
float16
/
float16
.
js
'
;
import
{
kBit
}
from
'
.
/
constants
.
js
'
;
import
{
cartesianProduct
clamp
correctlyRoundedF16
isFiniteF16
isSubnormalNumberF16
isSubnormalNumberF32
}
from
'
.
/
math
.
js
'
;
export
function
floatAsNormalizedInteger
(
float
bits
signed
)
{
if
(
signed
)
{
assert
(
float
>
=
-
1
&
&
float
<
=
1
(
)
=
>
{
float
}
out
of
bounds
of
snorm
)
;
const
max
=
Math
.
pow
(
2
bits
-
1
)
-
1
;
return
Math
.
round
(
float
*
max
)
;
}
else
{
assert
(
float
>
=
0
&
&
float
<
=
1
(
)
=
>
{
float
}
out
of
bounds
of
unorm
)
;
const
max
=
Math
.
pow
(
2
bits
)
-
1
;
return
Math
.
round
(
float
*
max
)
;
}
}
export
function
normalizedIntegerAsFloat
(
integer
bits
signed
)
{
assert
(
Number
.
isInteger
(
integer
)
)
;
if
(
signed
)
{
const
max
=
Math
.
pow
(
2
bits
-
1
)
-
1
;
assert
(
integer
>
=
-
max
-
1
&
&
integer
<
=
max
)
;
if
(
integer
=
=
=
-
max
-
1
)
{
integer
=
-
max
;
}
return
integer
/
max
;
}
else
{
const
max
=
Math
.
pow
(
2
bits
)
-
1
;
assert
(
integer
>
=
0
&
&
integer
<
=
max
)
;
return
integer
/
max
;
}
}
export
function
float32ToFloatBits
(
n
signBits
exponentBits
mantissaBits
bias
)
{
assert
(
exponentBits
<
=
8
)
;
assert
(
mantissaBits
<
=
23
)
;
assert
(
Number
.
isFinite
(
n
)
)
;
if
(
n
=
=
=
0
)
{
return
0
;
}
if
(
signBits
=
=
=
0
)
{
assert
(
n
>
=
0
)
;
}
const
buf
=
new
DataView
(
new
ArrayBuffer
(
Float32Array
.
BYTES_PER_ELEMENT
)
)
;
buf
.
setFloat32
(
0
n
true
)
;
const
bits
=
buf
.
getUint32
(
0
true
)
;
const
mantissaBitsToDiscard
=
23
-
mantissaBits
;
const
sign
=
(
bits
>
>
31
)
&
signBits
;
const
exp
=
(
(
bits
>
>
23
)
&
0xff
)
-
127
;
const
newBiasedExp
=
bias
+
exp
;
assert
(
newBiasedExp
<
1
<
<
exponentBits
(
)
=
>
input
number
{
n
}
overflows
target
type
)
;
if
(
newBiasedExp
<
=
0
)
{
return
sign
<
<
(
exponentBits
+
mantissaBits
)
;
}
else
{
const
newMantissa
=
(
bits
&
0x7fffff
)
>
>
mantissaBitsToDiscard
;
return
(
sign
<
<
(
exponentBits
+
mantissaBits
)
)
|
(
newBiasedExp
<
<
mantissaBits
)
|
newMantissa
;
}
}
export
function
float32ToFloat16Bits
(
n
)
{
return
float32ToFloatBits
(
n
1
5
10
15
)
;
}
export
function
float16BitsToFloat32
(
float16Bits
)
{
return
floatBitsToNumber
(
float16Bits
kFloat16Format
)
;
}
export
const
kFloat32Format
=
{
signed
:
1
exponentBits
:
8
mantissaBits
:
23
bias
:
127
}
;
export
const
kFloat16Format
=
{
signed
:
1
exponentBits
:
5
mantissaBits
:
10
bias
:
15
}
;
const
workingData
=
new
ArrayBuffer
(
4
)
;
const
workingDataU32
=
new
Uint32Array
(
workingData
)
;
const
workingDataU16
=
new
Uint16Array
(
workingData
)
;
const
workingDataU8
=
new
Uint8Array
(
workingData
)
;
const
workingDataF32
=
new
Float32Array
(
workingData
)
;
const
workingDataF16
=
new
Float16Array
(
workingData
)
;
const
workingDataI16
=
new
Int16Array
(
workingData
)
;
const
workingDataI8
=
new
Int8Array
(
workingData
)
;
export
function
float32BitsToNumber
(
bits
)
{
workingDataU32
[
0
]
=
bits
;
return
workingDataF32
[
0
]
;
}
export
function
numberToFloat32Bits
(
number
)
{
workingDataF32
[
0
]
=
number
;
return
workingDataU32
[
0
]
;
}
export
function
floatBitsToNumber
(
bits
fmt
)
{
const
kNonSignBits
=
fmt
.
exponentBits
+
fmt
.
mantissaBits
;
const
kNonSignBitsMask
=
(
1
<
<
kNonSignBits
)
-
1
;
const
expAndMantBits
=
bits
&
kNonSignBitsMask
;
let
f32BitsWithWrongBias
=
expAndMantBits
<
<
(
kFloat32Format
.
mantissaBits
-
fmt
.
mantissaBits
)
;
f32BitsWithWrongBias
|
=
(
bits
<
<
(
31
-
kNonSignBits
)
)
&
0x8000_0000
;
const
numberWithWrongBias
=
float32BitsToNumber
(
f32BitsWithWrongBias
)
;
return
numberWithWrongBias
*
2
*
*
(
kFloat32Format
.
bias
-
fmt
.
bias
)
;
}
export
function
numberToFloatBits
(
number
fmt
)
{
return
float32ToFloatBits
(
number
fmt
.
signed
fmt
.
exponentBits
fmt
.
mantissaBits
fmt
.
bias
)
;
}
export
function
floatBitsToNormalULPFromZero
(
bits
fmt
)
{
const
mask_sign
=
fmt
.
signed
<
<
(
fmt
.
exponentBits
+
fmt
.
mantissaBits
)
;
const
mask_expt
=
(
(
1
<
<
fmt
.
exponentBits
)
-
1
)
<
<
fmt
.
mantissaBits
;
const
mask_mant
=
(
1
<
<
fmt
.
mantissaBits
)
-
1
;
const
mask_rest
=
mask_expt
|
mask_mant
;
assert
(
fmt
.
exponentBits
+
fmt
.
mantissaBits
<
=
31
)
;
const
sign
=
bits
&
mask_sign
?
-
1
:
1
;
const
rest
=
bits
&
mask_rest
;
const
subnormal_or_zero
=
(
bits
&
mask_expt
)
=
=
=
0
;
const
infinity_or_nan
=
(
bits
&
mask_expt
)
=
=
=
mask_expt
;
assert
(
!
infinity_or_nan
'
no
ulp
representation
for
infinity
/
nan
'
)
;
const
abs_ulp_from_zero
=
subnormal_or_zero
?
0
:
rest
-
mask_mant
;
return
sign
*
abs_ulp_from_zero
;
}
export
function
packRGB9E5UFloat
(
r
g
b
)
{
for
(
const
v
of
[
r
g
b
]
)
{
assert
(
v
>
=
0
&
&
v
<
Math
.
pow
(
2
16
)
)
;
}
const
buf
=
new
DataView
(
new
ArrayBuffer
(
Float32Array
.
BYTES_PER_ELEMENT
)
)
;
const
extractMantissaAndExponent
=
n
=
>
{
const
mantissaBits
=
9
;
buf
.
setFloat32
(
0
n
true
)
;
const
bits
=
buf
.
getUint32
(
0
true
)
;
let
biasedExponent
=
(
bits
>
>
23
)
&
0xff
;
const
mantissaBitsToDiscard
=
23
-
mantissaBits
;
let
mantissa
=
(
bits
&
0x7fffff
)
>
>
mantissaBitsToDiscard
;
if
(
biasedExponent
!
=
=
0
)
{
mantissa
=
(
mantissa
>
>
1
)
|
0b100000000
;
biasedExponent
+
=
1
;
}
return
{
biasedExponent
mantissa
}
;
}
;
const
{
biasedExponent
:
rExp
mantissa
:
rOrigMantissa
}
=
extractMantissaAndExponent
(
r
)
;
const
{
biasedExponent
:
gExp
mantissa
:
gOrigMantissa
}
=
extractMantissaAndExponent
(
g
)
;
const
{
biasedExponent
:
bExp
mantissa
:
bOrigMantissa
}
=
extractMantissaAndExponent
(
b
)
;
const
exp
=
Math
.
max
(
rExp
gExp
bExp
)
;
const
rMantissa
=
rOrigMantissa
>
>
(
exp
-
rExp
)
;
const
gMantissa
=
gOrigMantissa
>
>
(
exp
-
gExp
)
;
const
bMantissa
=
bOrigMantissa
>
>
(
exp
-
bExp
)
;
const
bias
=
15
;
const
biasedExp
=
exp
=
=
=
0
?
0
:
exp
-
127
+
bias
;
assert
(
biasedExp
>
=
0
&
&
biasedExp
<
=
31
)
;
return
rMantissa
|
(
gMantissa
<
<
9
)
|
(
bMantissa
<
<
18
)
|
(
biasedExp
<
<
27
)
;
}
export
function
pack2x16float
(
x
y
)
{
const
generateU16s
=
n
=
>
{
let
contains_subnormals
=
isSubnormalNumberF32
(
n
)
;
const
n_f16s
=
correctlyRoundedF16
(
n
)
;
contains_subnormals
|
|
=
n_f16s
.
some
(
isSubnormalNumberF16
)
;
const
n_u16s
=
n_f16s
.
map
(
f16
=
>
{
workingDataF16
[
0
]
=
f16
;
return
workingDataU16
[
0
]
;
}
)
;
const
contains_poszero
=
n_u16s
.
some
(
u
=
>
u
=
=
=
kBit
.
f16
.
positive
.
zero
)
;
const
contains_negzero
=
n_u16s
.
some
(
u
=
>
u
=
=
=
kBit
.
f16
.
negative
.
zero
)
;
if
(
!
contains_negzero
&
&
(
contains_poszero
|
|
contains_subnormals
)
)
{
n_u16s
.
push
(
kBit
.
f16
.
negative
.
zero
)
;
}
if
(
!
contains_poszero
&
&
(
contains_negzero
|
|
contains_subnormals
)
)
{
n_u16s
.
push
(
kBit
.
f16
.
positive
.
zero
)
;
}
return
n_u16s
;
}
;
if
(
!
isFiniteF16
(
x
)
|
|
!
isFiniteF16
(
y
)
)
{
return
[
undefined
]
;
}
const
results
=
new
Array
(
)
;
for
(
const
p
of
cartesianProduct
(
generateU16s
(
x
)
generateU16s
(
y
)
)
)
{
assert
(
p
.
length
=
=
=
2
'
cartesianProduct
of
2
arrays
returned
an
entry
with
not
2
elements
'
)
;
workingDataU16
[
0
]
=
p
[
0
]
;
workingDataU16
[
1
]
=
p
[
1
]
;
results
.
push
(
workingDataU32
[
0
]
)
;
}
return
results
;
}
export
function
pack2x16snorm
(
x
y
)
{
const
generateI16
=
n
=
>
{
return
Math
.
floor
(
0
.
5
+
32767
*
Math
.
min
(
1
Math
.
max
(
-
1
n
)
)
)
;
}
;
workingDataI16
[
0
]
=
generateI16
(
x
)
;
workingDataI16
[
1
]
=
generateI16
(
y
)
;
return
workingDataU32
[
0
]
;
}
export
function
pack2x16unorm
(
x
y
)
{
const
generateU16
=
n
=
>
{
return
Math
.
floor
(
0
.
5
+
65535
*
Math
.
min
(
1
Math
.
max
(
0
n
)
)
)
;
}
;
workingDataU16
[
0
]
=
generateU16
(
x
)
;
workingDataU16
[
1
]
=
generateU16
(
y
)
;
return
workingDataU32
[
0
]
;
}
export
function
pack4x8snorm
(
.
.
.
vals
)
{
const
generateI8
=
n
=
>
{
return
Math
.
floor
(
0
.
5
+
127
*
Math
.
min
(
1
Math
.
max
(
-
1
n
)
)
)
;
}
;
for
(
const
idx
in
vals
)
{
workingDataI8
[
idx
]
=
generateI8
(
vals
[
idx
]
)
;
}
return
workingDataU32
[
0
]
;
}
export
function
pack4x8unorm
(
.
.
.
vals
)
{
const
generateU8
=
n
=
>
{
return
Math
.
floor
(
0
.
5
+
255
*
Math
.
min
(
1
Math
.
max
(
0
n
)
)
)
;
}
;
for
(
const
idx
in
vals
)
{
workingDataU8
[
idx
]
=
generateU8
(
vals
[
idx
]
)
;
}
return
workingDataU32
[
0
]
;
}
export
function
assertInIntegerRange
(
n
bits
signed
)
{
if
(
signed
)
{
const
min
=
-
Math
.
pow
(
2
bits
-
1
)
;
const
max
=
Math
.
pow
(
2
bits
-
1
)
-
1
;
assert
(
n
>
=
min
&
&
n
<
=
max
)
;
}
else
{
const
max
=
Math
.
pow
(
2
bits
)
-
1
;
assert
(
n
>
=
0
&
&
n
<
=
max
)
;
}
}
export
function
gammaCompress
(
n
)
{
n
=
n
<
=
0
.
0031308
?
(
323
*
n
)
/
25
:
(
211
*
Math
.
pow
(
n
5
/
12
)
-
11
)
/
200
;
return
clamp
(
n
{
min
:
0
max
:
1
}
)
;
}
export
function
gammaDecompress
(
n
)
{
n
=
n
<
=
0
.
04045
?
(
n
*
25
)
/
323
:
Math
.
pow
(
(
200
*
n
+
11
)
/
211
12
/
5
)
;
return
clamp
(
n
{
min
:
0
max
:
1
}
)
;
}
export
function
float32ToUint32
(
f32
)
{
const
f32Arr
=
new
Float32Array
(
1
)
;
f32Arr
[
0
]
=
f32
;
const
u32Arr
=
new
Uint32Array
(
f32Arr
.
buffer
)
;
return
u32Arr
[
0
]
;
}
export
function
uint32ToFloat32
(
u32
)
{
const
u32Arr
=
new
Uint32Array
(
1
)
;
u32Arr
[
0
]
=
u32
;
const
f32Arr
=
new
Float32Array
(
u32Arr
.
buffer
)
;
return
f32Arr
[
0
]
;
}
export
function
float32ToInt32
(
f32
)
{
const
f32Arr
=
new
Float32Array
(
1
)
;
f32Arr
[
0
]
=
f32
;
const
i32Arr
=
new
Int32Array
(
f32Arr
.
buffer
)
;
return
i32Arr
[
0
]
;
}
export
function
uint32ToInt32
(
u32
)
{
const
u32Arr
=
new
Uint32Array
(
1
)
;
u32Arr
[
0
]
=
u32
;
const
i32Arr
=
new
Int32Array
(
u32Arr
.
buffer
)
;
return
i32Arr
[
0
]
;
}
export
function
float16ToUint16
(
f16
)
{
const
f16Arr
=
new
Float16Array
(
1
)
;
f16Arr
[
0
]
=
f16
;
const
u16Arr
=
new
Uint16Array
(
f16Arr
.
buffer
)
;
return
u16Arr
[
0
]
;
}
export
function
uint16ToFloat16
(
u16
)
{
const
u16Arr
=
new
Uint16Array
(
1
)
;
u16Arr
[
0
]
=
u16
;
const
f16Arr
=
new
Float16Array
(
u16Arr
.
buffer
)
;
return
f16Arr
[
0
]
;
}
export
function
float16ToInt16
(
f16
)
{
const
f16Arr
=
new
Float16Array
(
1
)
;
f16Arr
[
0
]
=
f16
;
const
i16Arr
=
new
Int16Array
(
f16Arr
.
buffer
)
;
return
i16Arr
[
0
]
;
}
export
class
ScalarType
{
constructor
(
kind
size
read
)
{
this
.
kind
=
kind
;
this
.
_size
=
size
;
this
.
read
=
read
;
}
toString
(
)
{
return
this
.
kind
;
}
get
size
(
)
{
return
this
.
_size
;
}
}
export
class
VectorType
{
constructor
(
width
elementType
)
{
this
.
width
=
width
;
this
.
elementType
=
elementType
;
}
read
(
buf
offset
)
{
const
elements
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
width
;
i
+
+
)
{
elements
[
i
]
=
this
.
elementType
.
read
(
buf
offset
)
;
offset
+
=
this
.
elementType
.
size
;
}
return
new
Vector
(
elements
)
;
}
toString
(
)
{
return
vec
{
this
.
width
}
<
{
this
.
elementType
}
>
;
}
get
size
(
)
{
return
this
.
elementType
.
size
*
this
.
width
;
}
}
const
vectorTypes
=
new
Map
(
)
;
export
function
TypeVec
(
width
elementType
)
{
const
key
=
{
elementType
.
toString
(
)
}
{
width
}
}
;
let
ty
=
vectorTypes
.
get
(
key
)
;
if
(
ty
!
=
=
undefined
)
{
return
ty
;
}
ty
=
new
VectorType
(
width
elementType
)
;
vectorTypes
.
set
(
key
ty
)
;
return
ty
;
}
export
const
TypeI32
=
new
ScalarType
(
'
i32
'
4
(
buf
offset
)
=
>
i32
(
new
Int32Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeU32
=
new
ScalarType
(
'
u32
'
4
(
buf
offset
)
=
>
u32
(
new
Uint32Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeF64
=
new
ScalarType
(
'
f64
'
8
(
buf
offset
)
=
>
f32
(
new
Float64Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeF32
=
new
ScalarType
(
'
f32
'
4
(
buf
offset
)
=
>
f32
(
new
Float32Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeI16
=
new
ScalarType
(
'
i16
'
2
(
buf
offset
)
=
>
i16
(
new
Int16Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeU16
=
new
ScalarType
(
'
u16
'
2
(
buf
offset
)
=
>
u16
(
new
Uint16Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeF16
=
new
ScalarType
(
'
f16
'
2
(
buf
offset
)
=
>
f16Bits
(
new
Uint16Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeI8
=
new
ScalarType
(
'
i8
'
1
(
buf
offset
)
=
>
i8
(
new
Int8Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeU8
=
new
ScalarType
(
'
u8
'
1
(
buf
offset
)
=
>
u8
(
new
Uint8Array
(
buf
.
buffer
offset
)
[
0
]
)
)
;
export
const
TypeBool
=
new
ScalarType
(
'
bool
'
4
(
buf
offset
)
=
>
bool
(
new
Uint32Array
(
buf
.
buffer
offset
)
[
0
]
!
=
=
0
)
)
;
export
function
scalarType
(
kind
)
{
switch
(
kind
)
{
case
'
f64
'
:
return
TypeF64
;
case
'
f32
'
:
return
TypeF32
;
case
'
f16
'
:
return
TypeF16
;
case
'
u32
'
:
return
TypeU32
;
case
'
u16
'
:
return
TypeU16
;
case
'
u8
'
:
return
TypeU8
;
case
'
i32
'
:
return
TypeI32
;
case
'
i16
'
:
return
TypeI16
;
case
'
i8
'
:
return
TypeI8
;
case
'
bool
'
:
return
TypeBool
;
}
}
export
function
numElementsOf
(
ty
)
{
if
(
ty
instanceof
ScalarType
)
{
return
1
;
}
if
(
ty
instanceof
VectorType
)
{
return
ty
.
width
;
}
throw
new
Error
(
unhandled
type
{
ty
}
)
;
}
export
function
scalarTypeOf
(
ty
)
{
if
(
ty
instanceof
ScalarType
)
{
return
ty
;
}
if
(
ty
instanceof
VectorType
)
{
return
ty
.
elementType
;
}
throw
new
Error
(
unhandled
type
{
ty
}
)
;
}
export
class
Scalar
{
constructor
(
type
value
bits
)
{
this
.
value
=
value
;
this
.
type
=
type
;
this
.
bits
=
new
Uint8Array
(
bits
.
buffer
)
;
}
copyTo
(
buffer
offset
)
{
for
(
let
i
=
0
;
i
<
this
.
bits
.
length
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
this
.
bits
[
i
]
;
}
}
wgsl
(
)
{
const
withPoint
=
x
=
>
{
const
str
=
{
x
}
;
return
str
.
indexOf
(
'
.
'
)
>
0
|
|
str
.
indexOf
(
'
e
'
)
>
0
?
str
:
{
str
}
.
0
;
}
;
if
(
isFinite
(
this
.
value
)
)
{
switch
(
this
.
type
.
kind
)
{
case
'
f32
'
:
return
{
withPoint
(
this
.
value
)
}
f
;
case
'
f16
'
:
return
{
withPoint
(
this
.
value
)
}
h
;
case
'
u32
'
:
return
{
this
.
value
}
u
;
case
'
i32
'
:
return
i32
(
{
this
.
value
}
)
;
case
'
bool
'
:
return
{
this
.
value
}
;
}
}
throw
new
Error
(
scalar
of
value
{
this
.
value
}
and
type
{
this
.
type
}
has
no
WGSL
representation
)
;
}
toString
(
)
{
if
(
this
.
type
.
kind
=
=
=
'
bool
'
)
{
return
Colors
.
bold
(
this
.
value
.
toString
(
)
)
;
}
switch
(
this
.
value
)
{
case
Infinity
:
case
-
Infinity
:
return
Colors
.
bold
(
this
.
value
.
toString
(
)
)
;
default
:
{
const
hex
=
Array
.
from
(
this
.
bits
)
.
reverse
(
)
.
map
(
x
=
>
x
.
toString
(
16
)
.
padStart
(
2
'
0
'
)
)
.
join
(
'
'
)
;
const
n
=
this
.
value
;
if
(
n
!
=
=
null
&
&
isFloatValue
(
this
)
)
{
let
str
=
this
.
value
.
toString
(
)
;
str
=
str
.
indexOf
(
'
.
'
)
>
0
|
|
str
.
indexOf
(
'
e
'
)
>
0
?
str
:
{
str
}
.
0
;
return
isSubnormalNumberF32
(
n
.
valueOf
(
)
)
?
{
Colors
.
bold
(
str
)
}
(
0x
{
hex
}
subnormal
)
:
{
Colors
.
bold
(
str
)
}
(
0x
{
hex
}
)
;
}
return
{
Colors
.
bold
(
this
.
value
.
toString
(
)
)
}
(
0x
{
hex
}
)
;
}
}
}
}
export
function
f64
(
value
)
{
const
arr
=
new
Float64Array
(
[
value
]
)
;
return
new
Scalar
(
TypeF64
arr
[
0
]
arr
)
;
}
export
function
f32
(
value
)
{
const
arr
=
new
Float32Array
(
[
value
]
)
;
return
new
Scalar
(
TypeF32
arr
[
0
]
arr
)
;
}
export
function
f16
(
value
)
{
const
arr
=
new
Float16Array
(
[
value
]
)
;
return
new
Scalar
(
TypeF16
arr
[
0
]
arr
)
;
}
export
function
f32Bits
(
bits
)
{
const
arr
=
new
Uint32Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeF32
new
Float32Array
(
arr
.
buffer
)
[
0
]
arr
)
;
}
export
function
f16Bits
(
bits
)
{
const
arr
=
new
Uint16Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeF16
new
Float16Array
(
arr
.
buffer
)
[
0
]
arr
)
;
}
export
function
i32
(
value
)
{
const
arr
=
new
Int32Array
(
[
value
]
)
;
return
new
Scalar
(
TypeI32
arr
[
0
]
arr
)
;
}
export
function
i16
(
value
)
{
const
arr
=
new
Int16Array
(
[
value
]
)
;
return
new
Scalar
(
TypeI16
arr
[
0
]
arr
)
;
}
export
function
i8
(
value
)
{
const
arr
=
new
Int8Array
(
[
value
]
)
;
return
new
Scalar
(
TypeI8
arr
[
0
]
arr
)
;
}
export
function
i32Bits
(
bits
)
{
const
arr
=
new
Uint32Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeI32
new
Int32Array
(
arr
.
buffer
)
[
0
]
arr
)
;
}
export
function
i16Bits
(
bits
)
{
const
arr
=
new
Uint16Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeI16
new
Int16Array
(
arr
.
buffer
)
[
0
]
arr
)
;
}
export
function
i8Bits
(
bits
)
{
const
arr
=
new
Uint8Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeI8
new
Int8Array
(
arr
.
buffer
)
[
0
]
arr
)
;
}
export
function
u32
(
value
)
{
const
arr
=
new
Uint32Array
(
[
value
]
)
;
return
new
Scalar
(
TypeU32
arr
[
0
]
arr
)
;
}
export
function
u16
(
value
)
{
const
arr
=
new
Uint16Array
(
[
value
]
)
;
return
new
Scalar
(
TypeU16
arr
[
0
]
arr
)
;
}
export
function
u8
(
value
)
{
const
arr
=
new
Uint8Array
(
[
value
]
)
;
return
new
Scalar
(
TypeU8
arr
[
0
]
arr
)
;
}
export
function
u32Bits
(
bits
)
{
const
arr
=
new
Uint32Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeU32
bits
arr
)
;
}
export
function
u16Bits
(
bits
)
{
const
arr
=
new
Uint16Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeU16
bits
arr
)
;
}
export
function
u8Bits
(
bits
)
{
const
arr
=
new
Uint8Array
(
[
bits
]
)
;
return
new
Scalar
(
TypeU8
bits
arr
)
;
}
export
function
bool
(
value
)
{
const
arr
=
new
Uint32Array
(
[
value
?
1
:
0
]
)
;
return
new
Scalar
(
TypeBool
value
arr
)
;
}
export
const
True
=
bool
(
true
)
;
export
const
False
=
bool
(
false
)
;
export
function
reinterpretF32AsU32
(
f32
)
{
const
array
=
new
Float32Array
(
1
)
;
array
[
0
]
=
f32
;
return
new
Uint32Array
(
array
.
buffer
)
[
0
]
;
}
export
function
reinterpretU32AsF32
(
u32
)
{
const
array
=
new
Uint32Array
(
1
)
;
array
[
0
]
=
u32
;
return
new
Float32Array
(
array
.
buffer
)
[
0
]
;
}
export
class
Vector
{
constructor
(
elements
)
{
if
(
elements
.
length
<
2
|
|
elements
.
length
>
4
)
{
throw
new
Error
(
vector
element
count
must
be
between
2
and
4
got
{
elements
.
length
}
)
;
}
for
(
let
i
=
1
;
i
<
elements
.
length
;
i
+
+
)
{
const
a
=
elements
[
0
]
.
type
;
const
b
=
elements
[
i
]
.
type
;
if
(
a
!
=
=
b
)
{
throw
new
Error
(
cannot
mix
vector
element
types
.
Found
elements
with
types
'
{
a
}
'
and
'
{
b
}
'
)
;
}
}
this
.
elements
=
elements
;
this
.
type
=
TypeVec
(
elements
.
length
elements
[
0
]
.
type
)
;
}
copyTo
(
buffer
offset
)
{
for
(
const
element
of
this
.
elements
)
{
element
.
copyTo
(
buffer
offset
)
;
offset
+
=
this
.
type
.
elementType
.
size
;
}
}
wgsl
(
)
{
const
els
=
this
.
elements
.
map
(
v
=
>
v
.
wgsl
(
)
)
.
join
(
'
'
)
;
return
vec
{
this
.
type
.
width
}
(
{
els
}
)
;
}
toString
(
)
{
return
{
this
.
type
}
(
{
this
.
elements
.
map
(
e
=
>
e
.
toString
(
)
)
.
join
(
'
'
)
}
)
;
}
get
x
(
)
{
assert
(
0
<
this
.
elements
.
length
)
;
return
this
.
elements
[
0
]
;
}
get
y
(
)
{
assert
(
1
<
this
.
elements
.
length
)
;
return
this
.
elements
[
1
]
;
}
get
z
(
)
{
assert
(
2
<
this
.
elements
.
length
)
;
return
this
.
elements
[
2
]
;
}
get
w
(
)
{
assert
(
3
<
this
.
elements
.
length
)
;
return
this
.
elements
[
3
]
;
}
}
export
function
vec2
(
x
y
)
{
return
new
Vector
(
[
x
y
]
)
;
}
export
function
vec3
(
x
y
z
)
{
return
new
Vector
(
[
x
y
z
]
)
;
}
export
function
vec4
(
x
y
z
w
)
{
return
new
Vector
(
[
x
y
z
w
]
)
;
}
export
function
toVector
(
v
op
)
{
switch
(
v
.
length
)
{
case
2
:
return
vec2
(
op
(
v
[
0
]
)
op
(
v
[
1
]
)
)
;
case
3
:
return
vec3
(
op
(
v
[
0
]
)
op
(
v
[
1
]
)
op
(
v
[
2
]
)
)
;
case
4
:
return
vec4
(
op
(
v
[
0
]
)
op
(
v
[
1
]
)
op
(
v
[
2
]
)
op
(
v
[
3
]
)
)
;
}
unreachable
(
input
to
'
toVector
'
must
contain
2
3
or
4
elements
)
;
}
export
function
serializeValue
(
v
)
{
const
value
=
(
kind
s
)
=
>
{
switch
(
kind
)
{
case
'
f32
'
:
return
new
Uint32Array
(
s
.
bits
.
buffer
)
[
0
]
;
case
'
f16
'
:
return
new
Uint16Array
(
s
.
bits
.
buffer
)
[
0
]
;
default
:
return
s
.
value
;
}
}
;
if
(
v
instanceof
Scalar
)
{
const
kind
=
v
.
type
.
kind
;
return
{
kind
:
'
scalar
'
type
:
kind
value
:
value
(
kind
v
)
}
;
}
if
(
v
instanceof
Vector
)
{
const
kind
=
v
.
type
.
elementType
.
kind
;
return
{
kind
:
'
vector
'
type
:
kind
value
:
v
.
elements
.
map
(
e
=
>
value
(
kind
e
)
)
}
;
}
unreachable
(
unhandled
value
type
:
{
v
}
)
;
}
export
function
deserializeValue
(
data
)
{
const
buildScalar
=
v
=
>
{
switch
(
data
.
type
)
{
case
'
f64
'
:
return
f64
(
v
)
;
case
'
i32
'
:
return
i32
(
v
)
;
case
'
u32
'
:
return
u32
(
v
)
;
case
'
f32
'
:
return
f32Bits
(
v
)
;
case
'
i16
'
:
return
i16
(
v
)
;
case
'
u16
'
:
return
u16
(
v
)
;
case
'
f16
'
:
return
f16Bits
(
v
)
;
case
'
i8
'
:
return
i8
(
v
)
;
case
'
u8
'
:
return
u8
(
v
)
;
case
'
bool
'
:
return
bool
(
v
)
;
default
:
unreachable
(
unhandled
value
type
:
{
data
.
type
}
)
;
}
}
;
switch
(
data
.
kind
)
{
case
'
scalar
'
:
{
return
buildScalar
(
data
.
value
)
;
}
case
'
vector
'
:
{
return
new
Vector
(
data
.
value
.
map
(
v
=
>
buildScalar
(
v
)
)
)
;
}
}
}
export
function
isFloatValue
(
v
)
{
if
(
v
instanceof
Scalar
)
{
const
s
=
v
;
return
s
.
type
.
kind
=
=
=
'
f64
'
|
|
s
.
type
.
kind
=
=
=
'
f32
'
|
|
s
.
type
.
kind
=
=
=
'
f16
'
;
}
return
false
;
}
