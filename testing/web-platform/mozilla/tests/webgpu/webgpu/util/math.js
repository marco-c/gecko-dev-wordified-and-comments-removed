import
{
assert
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
Float16Array
}
from
'
.
.
/
.
.
/
external
/
petamoriken
/
float16
/
float16
.
js
'
;
import
{
kBit
kValue
}
from
'
.
/
constants
.
js
'
;
import
{
f16
f16Bits
f32
f32Bits
floatBitsToNumber
i32
kFloat16Format
kFloat32Format
u32
}
from
'
.
/
conversion
.
js
'
;
export
const
kMaxSafeMultipleOf8
=
Number
.
MAX_SAFE_INTEGER
-
7
;
export
function
align
(
n
alignment
)
{
assert
(
Number
.
isInteger
(
n
)
&
&
n
>
=
0
'
n
must
be
a
non
-
negative
integer
'
)
;
assert
(
Number
.
isInteger
(
alignment
)
&
&
alignment
>
0
'
alignment
must
be
a
positive
integer
'
)
;
return
Math
.
ceil
(
n
/
alignment
)
*
alignment
;
}
export
function
roundDown
(
n
alignment
)
{
assert
(
Number
.
isInteger
(
n
)
&
&
n
>
=
0
'
n
must
be
a
non
-
negative
integer
'
)
;
assert
(
Number
.
isInteger
(
alignment
)
&
&
alignment
>
0
'
alignment
must
be
a
positive
integer
'
)
;
return
Math
.
floor
(
n
/
alignment
)
*
alignment
;
}
export
function
clamp
(
n
{
min
max
}
)
{
assert
(
max
>
=
min
)
;
return
Math
.
min
(
Math
.
max
(
n
min
)
max
)
;
}
export
function
flushSubnormalNumberF32
(
val
)
{
return
isSubnormalNumberF32
(
val
)
?
0
:
val
;
}
export
function
flushSubnormalScalarF32
(
val
)
{
return
isSubnormalScalarF32
(
val
)
?
f32
(
0
)
:
val
;
}
export
function
isSubnormalScalarF32
(
val
)
{
if
(
val
.
type
.
kind
!
=
=
'
f32
'
)
{
return
false
;
}
if
(
val
=
=
=
f32
(
0
)
)
{
return
false
;
}
const
u32_val
=
new
Uint32Array
(
new
Float32Array
(
[
val
.
value
.
valueOf
(
)
]
)
.
buffer
)
[
0
]
;
return
(
u32_val
&
0x7f800000
)
=
=
=
0
;
}
export
function
isSubnormalNumberF32
(
n
)
{
return
n
>
kValue
.
f32
.
negative
.
max
&
&
n
<
kValue
.
f32
.
positive
.
min
;
}
export
function
isFiniteF32
(
n
)
{
return
n
>
=
kValue
.
f32
.
negative
.
min
&
&
n
<
=
kValue
.
f32
.
positive
.
max
;
}
export
function
flushSubnormalNumberF16
(
val
)
{
return
isSubnormalNumberF16
(
val
)
?
0
:
val
;
}
export
function
flushSubnormalScalarF16
(
val
)
{
return
isSubnormalScalarF16
(
val
)
?
f16
(
0
)
:
val
;
}
export
function
isSubnormalScalarF16
(
val
)
{
if
(
val
.
type
.
kind
!
=
=
'
f16
'
)
{
return
false
;
}
if
(
val
=
=
=
f16
(
0
)
)
{
return
false
;
}
const
u16_val
=
new
Uint16Array
(
new
Float16Array
(
[
val
.
value
.
valueOf
(
)
]
)
.
buffer
)
[
0
]
;
return
(
u16_val
&
0x7f800000
)
=
=
=
0
;
}
export
function
isSubnormalNumberF16
(
n
)
{
return
n
>
kValue
.
f16
.
negative
.
max
&
&
n
<
kValue
.
f16
.
positive
.
min
;
}
export
function
isFiniteF16
(
n
)
{
return
n
>
=
kValue
.
f16
.
negative
.
min
&
&
n
<
=
kValue
.
f16
.
positive
.
max
;
}
export
function
nextAfterF32
(
val
dir
=
true
mode
)
{
if
(
Number
.
isNaN
(
val
)
)
{
return
f32Bits
(
kBit
.
f32
.
nan
.
positive
.
s
)
;
}
if
(
val
=
=
=
Number
.
POSITIVE_INFINITY
)
{
return
f32Bits
(
kBit
.
f32
.
infinity
.
positive
)
;
}
if
(
val
=
=
=
Number
.
NEGATIVE_INFINITY
)
{
return
f32Bits
(
kBit
.
f32
.
infinity
.
negative
)
;
}
assert
(
val
<
=
kValue
.
f32
.
positive
.
max
&
&
val
>
=
kValue
.
f32
.
negative
.
min
{
val
}
is
not
in
the
range
of
float32
)
;
val
=
mode
=
=
=
'
flush
'
?
flushSubnormalNumberF32
(
val
)
:
val
;
if
(
val
=
=
=
0
)
{
if
(
dir
)
{
return
mode
=
=
=
'
flush
'
?
f32Bits
(
kBit
.
f32
.
positive
.
min
)
:
f32Bits
(
kBit
.
f32
.
subnormal
.
positive
.
min
)
;
}
else
{
return
mode
=
=
=
'
flush
'
?
f32Bits
(
kBit
.
f32
.
negative
.
max
)
:
f32Bits
(
kBit
.
f32
.
subnormal
.
negative
.
max
)
;
}
}
const
converted
=
new
Float32Array
(
[
val
]
)
[
0
]
;
let
u32_result
;
if
(
val
=
=
=
converted
)
{
u32_result
=
new
Uint32Array
(
new
Float32Array
(
[
val
]
)
.
buffer
)
[
0
]
;
const
is_positive
=
(
u32_result
&
0x80000000
)
=
=
=
0
;
if
(
dir
=
=
=
is_positive
)
{
u32_result
+
=
1
;
}
else
{
u32_result
-
=
1
;
}
}
else
{
if
(
dir
=
=
=
converted
>
val
)
{
u32_result
=
new
Uint32Array
(
new
Float32Array
(
[
converted
]
)
.
buffer
)
[
0
]
;
}
else
{
const
next
=
nextAfterF32
(
converted
dir
mode
)
.
value
.
valueOf
(
)
;
u32_result
=
new
Uint32Array
(
new
Float32Array
(
[
next
]
)
.
buffer
)
[
0
]
;
}
}
if
(
(
u32_result
&
0x7f800000
)
=
=
=
0x7f800000
)
{
if
(
dir
)
{
return
f32Bits
(
kBit
.
f32
.
infinity
.
positive
)
;
}
else
{
return
f32Bits
(
kBit
.
f32
.
infinity
.
negative
)
;
}
}
const
f32_result
=
f32Bits
(
u32_result
)
;
return
mode
=
=
=
'
flush
'
?
flushSubnormalScalarF32
(
f32_result
)
:
f32_result
;
}
export
function
nextAfterF16
(
val
dir
=
true
mode
)
{
if
(
Number
.
isNaN
(
val
)
)
{
return
f16Bits
(
kBit
.
f16
.
nan
.
positive
.
s
)
;
}
if
(
val
=
=
=
Number
.
POSITIVE_INFINITY
)
{
return
f16Bits
(
kBit
.
f16
.
infinity
.
positive
)
;
}
if
(
val
=
=
=
Number
.
NEGATIVE_INFINITY
)
{
return
f16Bits
(
kBit
.
f16
.
infinity
.
negative
)
;
}
assert
(
val
<
=
kValue
.
f16
.
positive
.
max
&
&
val
>
=
kValue
.
f16
.
negative
.
min
{
val
}
is
not
in
the
range
of
float16
)
;
val
=
mode
=
=
=
'
flush
'
?
flushSubnormalNumberF16
(
val
)
:
val
;
if
(
val
=
=
=
0
)
{
if
(
dir
)
{
return
mode
=
=
=
'
flush
'
?
f16Bits
(
kBit
.
f16
.
positive
.
min
)
:
f16Bits
(
kBit
.
f16
.
subnormal
.
positive
.
min
)
;
}
else
{
return
mode
=
=
=
'
flush
'
?
f16Bits
(
kBit
.
f16
.
negative
.
max
)
:
f16Bits
(
kBit
.
f16
.
subnormal
.
negative
.
max
)
;
}
}
const
converted
=
new
Float16Array
(
[
val
]
)
[
0
]
;
let
u16_result
;
if
(
val
=
=
=
converted
)
{
u16_result
=
new
Uint16Array
(
new
Float16Array
(
[
val
]
)
.
buffer
)
[
0
]
;
const
is_positive
=
(
u16_result
&
0x8000
)
=
=
=
0
;
if
(
dir
=
=
=
is_positive
)
{
u16_result
+
=
1
;
}
else
{
u16_result
-
=
1
;
}
}
else
{
if
(
dir
=
=
=
converted
>
val
)
{
u16_result
=
new
Uint16Array
(
new
Float16Array
(
[
converted
]
)
.
buffer
)
[
0
]
;
}
else
{
const
next
=
nextAfterF16
(
converted
dir
mode
)
.
value
.
valueOf
(
)
;
u16_result
=
new
Uint16Array
(
new
Float16Array
(
[
next
]
)
.
buffer
)
[
0
]
;
}
}
if
(
(
u16_result
&
0x7f800000
)
=
=
=
0x7f800000
)
{
if
(
dir
)
{
return
f16Bits
(
kBit
.
f16
.
infinity
.
positive
)
;
}
else
{
return
f16Bits
(
kBit
.
f16
.
infinity
.
negative
)
;
}
}
const
f16_result
=
f16Bits
(
u16_result
)
;
return
mode
=
=
=
'
flush
'
?
flushSubnormalScalarF16
(
f16_result
)
:
f16_result
;
}
export
function
oneULP
(
target
mode
=
'
flush
'
)
{
if
(
Number
.
isNaN
(
target
)
)
{
return
Number
.
NaN
;
}
target
=
mode
=
=
=
'
flush
'
?
flushSubnormalNumberF32
(
target
)
:
target
;
if
(
target
=
=
=
Number
.
POSITIVE_INFINITY
|
|
target
>
=
kValue
.
f32
.
positive
.
max
)
{
return
kValue
.
f32
.
positive
.
max
-
kValue
.
f32
.
positive
.
nearest_max
;
}
else
if
(
target
=
=
=
Number
.
NEGATIVE_INFINITY
|
|
target
<
=
kValue
.
f32
.
negative
.
min
)
{
return
kValue
.
f32
.
negative
.
nearest_min
-
kValue
.
f32
.
negative
.
min
;
}
const
before
=
nextAfterF32
(
target
false
mode
)
.
value
.
valueOf
(
)
;
const
after
=
nextAfterF32
(
target
true
mode
)
.
value
.
valueOf
(
)
;
const
converted
=
new
Float32Array
(
[
target
]
)
[
0
]
;
if
(
converted
=
=
=
target
)
{
return
Math
.
min
(
target
-
before
after
-
target
)
;
}
else
{
return
after
-
before
;
}
}
export
function
correctlyRoundedF32
(
n
)
{
assert
(
!
Number
.
isNaN
(
n
)
correctlyRoundedF32
not
defined
for
NaN
)
;
if
(
n
=
=
=
Number
.
POSITIVE_INFINITY
|
|
n
>
kValue
.
f32
.
positive
.
max
)
{
return
[
kValue
.
f32
.
positive
.
max
Number
.
POSITIVE_INFINITY
]
;
}
if
(
n
=
=
=
Number
.
NEGATIVE_INFINITY
|
|
n
<
kValue
.
f32
.
negative
.
min
)
{
return
[
Number
.
NEGATIVE_INFINITY
kValue
.
f32
.
negative
.
min
]
;
}
const
n_32
=
new
Float32Array
(
[
n
]
)
[
0
]
;
const
converted
=
n_32
;
if
(
n
=
=
=
converted
)
{
return
[
n
]
;
}
if
(
converted
>
n
)
{
const
other
=
nextAfterF32
(
n_32
false
'
no
-
flush
'
)
.
value
;
return
[
other
converted
]
;
}
else
{
const
other
=
nextAfterF32
(
n_32
true
'
no
-
flush
'
)
.
value
;
return
[
converted
other
]
;
}
}
export
function
correctlyRoundedF16
(
n
)
{
assert
(
!
Number
.
isNaN
(
n
)
correctlyRoundedF16
not
defined
for
NaN
)
;
if
(
n
=
=
=
Number
.
POSITIVE_INFINITY
|
|
n
>
kValue
.
f16
.
positive
.
max
)
{
return
[
kValue
.
f16
.
positive
.
max
Number
.
POSITIVE_INFINITY
]
;
}
if
(
n
=
=
=
Number
.
NEGATIVE_INFINITY
|
|
n
<
kValue
.
f16
.
negative
.
min
)
{
return
[
Number
.
NEGATIVE_INFINITY
kValue
.
f16
.
negative
.
min
]
;
}
const
n_16
=
new
Float16Array
(
[
n
]
)
[
0
]
;
const
converted
=
n_16
;
if
(
n
=
=
=
converted
)
{
return
[
n
]
;
}
if
(
converted
>
n
)
{
const
other
=
nextAfterF16
(
n_16
false
'
no
-
flush
'
)
.
value
;
return
[
other
converted
]
;
}
else
{
const
other
=
nextAfterF16
(
n_16
true
'
no
-
flush
'
)
.
value
;
return
[
converted
other
]
;
}
}
export
function
lerp
(
a
b
t
)
{
if
(
!
Number
.
isFinite
(
a
)
|
|
!
Number
.
isFinite
(
b
)
)
{
return
Number
.
NaN
;
}
if
(
(
a
<
=
0
.
0
&
&
b
>
=
0
.
0
)
|
|
(
a
>
=
0
.
0
&
&
b
<
=
0
.
0
)
)
{
return
t
*
b
+
(
1
-
t
)
*
a
;
}
if
(
t
=
=
=
1
.
0
)
{
return
b
;
}
const
x
=
a
+
t
*
(
b
-
a
)
;
return
t
>
1
.
0
=
=
=
b
>
a
?
Math
.
max
(
b
x
)
:
Math
.
min
(
b
x
)
;
}
export
function
linearRange
(
a
b
num_steps
)
{
if
(
num_steps
<
=
0
)
{
return
Array
(
)
;
}
if
(
num_steps
=
=
=
1
)
{
return
[
a
]
;
}
return
Array
.
from
(
Array
(
num_steps
)
.
keys
(
)
)
.
map
(
i
=
>
lerp
(
a
b
i
/
(
num_steps
-
1
)
)
)
;
}
export
function
biasedRange
(
a
b
num_steps
)
{
const
c
=
2
;
if
(
num_steps
<
=
0
)
{
return
Array
(
)
;
}
if
(
num_steps
=
=
=
1
)
{
return
[
a
]
;
}
return
Array
.
from
(
Array
(
num_steps
)
.
keys
(
)
)
.
map
(
i
=
>
lerp
(
a
b
Math
.
pow
(
i
/
(
num_steps
-
1
)
c
)
)
)
;
}
export
function
fullF32Range
(
counts
=
{
pos_sub
:
10
pos_norm
:
50
}
)
{
counts
.
neg_norm
=
counts
.
neg_norm
=
=
=
undefined
?
counts
.
pos_norm
:
counts
.
neg_norm
;
counts
.
neg_sub
=
counts
.
neg_sub
=
=
=
undefined
?
counts
.
pos_sub
:
counts
.
neg_sub
;
const
bit_fields
=
[
.
.
.
linearRange
(
kBit
.
f32
.
negative
.
min
kBit
.
f32
.
negative
.
max
counts
.
neg_norm
)
.
.
.
linearRange
(
kBit
.
f32
.
subnormal
.
negative
.
min
kBit
.
f32
.
subnormal
.
negative
.
max
counts
.
neg_sub
)
0
.
.
.
linearRange
(
kBit
.
f32
.
subnormal
.
positive
.
min
kBit
.
f32
.
subnormal
.
positive
.
max
counts
.
pos_sub
)
.
.
.
linearRange
(
kBit
.
f32
.
positive
.
min
kBit
.
f32
.
positive
.
max
counts
.
pos_norm
)
]
.
map
(
Math
.
trunc
)
;
return
bit_fields
.
map
(
hexToF32
)
;
}
export
function
sourceFilteredF32Range
(
source
low
high
)
{
return
fullF32Range
(
)
.
filter
(
x
=
>
source
!
=
=
'
const
'
|
|
(
x
>
=
low
&
&
x
<
=
high
)
)
;
}
export
function
fullF16Range
(
counts
=
{
pos_sub
:
10
pos_norm
:
50
}
)
{
counts
.
neg_norm
=
counts
.
neg_norm
=
=
=
undefined
?
counts
.
pos_norm
:
counts
.
neg_norm
;
counts
.
neg_sub
=
counts
.
neg_sub
=
=
=
undefined
?
counts
.
pos_sub
:
counts
.
neg_sub
;
const
bit_fields
=
[
.
.
.
linearRange
(
kBit
.
f16
.
negative
.
min
kBit
.
f16
.
negative
.
max
counts
.
neg_norm
)
.
.
.
linearRange
(
kBit
.
f16
.
subnormal
.
negative
.
min
kBit
.
f16
.
subnormal
.
negative
.
max
counts
.
neg_sub
)
0
.
.
.
linearRange
(
kBit
.
f16
.
subnormal
.
positive
.
min
kBit
.
f16
.
subnormal
.
positive
.
max
counts
.
pos_sub
)
.
.
.
linearRange
(
kBit
.
f16
.
positive
.
min
kBit
.
f16
.
positive
.
max
counts
.
pos_norm
)
]
.
map
(
Math
.
trunc
)
;
return
bit_fields
.
map
(
hexToF16
)
;
}
export
function
fullI32Range
(
counts
=
{
positive
:
50
}
)
{
counts
.
negative
=
counts
.
negative
=
=
=
undefined
?
counts
.
positive
:
counts
.
negative
;
return
[
.
.
.
biasedRange
(
kValue
.
i32
.
negative
.
min
-
1
counts
.
negative
)
0
.
.
.
biasedRange
(
1
kValue
.
i32
.
positive
.
max
counts
.
positive
)
]
.
map
(
Math
.
trunc
)
;
}
const
kInterestingU32Values
=
[
0
1
kValue
.
u32
.
max
/
2
kValue
.
u32
.
max
]
;
export
function
sparseU32Range
(
)
{
return
kInterestingU32Values
;
}
const
kVectorU32Values
=
{
2
:
kInterestingU32Values
.
flatMap
(
f
=
>
[
[
f
1
]
[
1
f
]
]
)
3
:
kInterestingU32Values
.
flatMap
(
f
=
>
[
[
f
1
2
]
[
1
f
2
]
[
1
2
f
]
]
)
4
:
kInterestingU32Values
.
flatMap
(
f
=
>
[
[
f
1
2
3
]
[
1
f
2
3
]
[
1
2
f
3
]
[
1
2
3
f
]
]
)
}
;
export
function
vectorU32Range
(
dim
)
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
vectorU32Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kVectorU32Values
[
dim
]
;
}
export
function
fullU32Range
(
count
=
50
)
{
return
[
0
.
.
.
biasedRange
(
1
kValue
.
u32
.
max
count
)
]
.
map
(
Math
.
trunc
)
;
}
const
kInterestingF32Values
=
[
kValue
.
f32
.
negative
.
min
-
10
.
0
-
1
.
0
kValue
.
f32
.
negative
.
max
kValue
.
f32
.
subnormal
.
negative
.
min
kValue
.
f32
.
subnormal
.
negative
.
max
0
.
0
kValue
.
f32
.
subnormal
.
positive
.
min
kValue
.
f32
.
subnormal
.
positive
.
max
kValue
.
f32
.
positive
.
min
1
.
0
10
.
0
kValue
.
f32
.
positive
.
max
]
;
export
function
sparseF32Range
(
)
{
return
kInterestingF32Values
;
}
const
kVectorF32Values
=
{
2
:
kInterestingF32Values
.
flatMap
(
f
=
>
[
[
f
1
.
0
]
[
1
.
0
f
]
[
f
-
1
.
0
]
[
-
1
.
0
f
]
]
)
3
:
kInterestingF32Values
.
flatMap
(
f
=
>
[
[
f
1
.
0
2
.
0
]
[
1
.
0
f
2
.
0
]
[
1
.
0
2
.
0
f
]
[
f
-
1
.
0
-
2
.
0
]
[
-
1
.
0
f
-
2
.
0
]
[
-
1
.
0
-
2
.
0
f
]
]
)
4
:
kInterestingF32Values
.
flatMap
(
f
=
>
[
[
f
1
.
0
2
.
0
3
.
0
]
[
1
.
0
f
2
.
0
3
.
0
]
[
1
.
0
2
.
0
f
3
.
0
]
[
1
.
0
2
.
0
3
.
0
f
]
[
f
-
1
.
0
-
2
.
0
-
3
.
0
]
[
-
1
.
0
f
-
2
.
0
-
3
.
0
]
[
-
1
.
0
-
2
.
0
f
-
3
.
0
]
[
-
1
.
0
-
2
.
0
-
3
.
0
f
]
]
)
}
;
export
function
vectorF32Range
(
dim
)
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
vectorF32Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kVectorF32Values
[
dim
]
;
}
const
kSparseVectorF32Values
=
{
2
:
sparseF32Range
(
)
.
map
(
(
f
idx
)
=
>
[
idx
%
2
=
=
=
0
?
f
:
idx
idx
%
2
=
=
=
1
?
f
:
-
idx
]
)
3
:
sparseF32Range
(
)
.
map
(
(
f
idx
)
=
>
[
idx
%
3
=
=
=
0
?
f
:
idx
idx
%
3
=
=
=
1
?
f
:
-
idx
idx
%
3
=
=
=
2
?
f
:
idx
]
)
4
:
sparseF32Range
(
)
.
map
(
(
f
idx
)
=
>
[
idx
%
4
=
=
=
0
?
f
:
idx
idx
%
4
=
=
=
1
?
f
:
-
idx
idx
%
4
=
=
=
2
?
f
:
idx
idx
%
4
=
=
=
3
?
f
:
-
idx
]
)
}
;
export
function
sparseVectorF32Range
(
dim
)
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
sparseVectorF32Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kSparseVectorF32Values
[
dim
]
;
}
export
function
multiplyMatrices
(
A
B
)
{
assert
(
A
.
length
>
0
&
&
B
.
length
>
0
&
&
B
[
0
]
.
length
>
0
&
&
A
[
0
]
.
length
=
=
=
B
.
length
)
;
const
product
=
new
Array
(
A
.
length
)
;
for
(
let
i
=
0
;
i
<
product
.
length
;
+
+
i
)
{
product
[
i
]
=
new
Array
(
B
[
0
]
.
length
)
.
fill
(
0
)
;
}
for
(
let
m
=
0
;
m
<
A
.
length
;
+
+
m
)
{
for
(
let
p
=
0
;
p
<
B
[
0
]
.
length
;
+
+
p
)
{
for
(
let
n
=
0
;
n
<
B
.
length
;
+
+
n
)
{
product
[
m
]
[
p
]
+
=
A
[
m
]
[
n
]
*
B
[
n
]
[
p
]
;
}
}
}
return
product
;
}
export
function
signExtend
(
n
bits
)
{
const
shift
=
32
-
bits
;
return
(
n
<
<
shift
)
>
>
shift
;
}
export
function
quantizeToF32
(
num
)
{
return
f32
(
num
)
.
value
;
}
export
function
quantizeToI32
(
num
)
{
return
i32
(
num
)
.
value
;
}
export
function
quantizeToU32
(
num
)
{
return
u32
(
num
)
.
value
;
}
export
function
isPowerOfTwo
(
n
)
{
if
(
!
Number
.
isInteger
(
n
)
)
{
return
false
;
}
return
n
!
=
=
0
&
&
(
n
&
(
n
-
1
)
)
=
=
=
0
;
}
export
function
gcd
(
a
b
)
{
assert
(
Number
.
isInteger
(
a
)
&
&
a
>
0
)
;
assert
(
Number
.
isInteger
(
b
)
&
&
b
>
0
)
;
while
(
b
!
=
=
0
)
{
const
bTemp
=
b
;
b
=
a
%
b
;
a
=
bTemp
;
}
return
a
;
}
export
function
lcm
(
a
b
)
{
return
(
a
*
b
)
/
gcd
(
a
b
)
;
}
export
function
hexToF32
(
hex
)
{
return
floatBitsToNumber
(
hex
kFloat32Format
)
;
}
export
function
hexToF16
(
hex
)
{
return
floatBitsToNumber
(
hex
kFloat16Format
)
;
}
export
function
hexToF64
(
h32
l32
)
{
const
u32Arr
=
new
Uint32Array
(
2
)
;
u32Arr
[
0
]
=
l32
;
u32Arr
[
1
]
=
h32
;
const
f64Arr
=
new
Float64Array
(
u32Arr
.
buffer
)
;
return
f64Arr
[
0
]
;
}
function
cartesianProductImpl
(
elements
intermediate
)
{
const
result
=
[
]
;
elements
.
forEach
(
e
=
>
{
if
(
intermediate
.
length
>
0
)
{
intermediate
.
forEach
(
i
=
>
{
result
.
push
(
[
.
.
.
i
e
]
)
;
}
)
;
}
else
{
result
.
push
(
[
e
]
)
;
}
}
)
;
return
result
;
}
export
function
cartesianProduct
(
.
.
.
inputs
)
{
let
result
=
[
]
;
inputs
.
forEach
(
i
=
>
{
result
=
cartesianProductImpl
(
i
result
)
;
}
)
;
return
result
;
}
export
function
calculatePermutations
(
input
)
{
if
(
input
.
length
=
=
=
0
)
{
return
[
]
;
}
if
(
input
.
length
=
=
=
1
)
{
return
[
input
]
;
}
if
(
input
.
length
=
=
=
2
)
{
return
[
input
[
input
[
1
]
input
[
0
]
]
]
;
}
const
result
=
[
]
;
input
.
forEach
(
(
head
idx
)
=
>
{
const
tail
=
input
.
slice
(
0
idx
)
.
concat
(
input
.
slice
(
idx
+
1
)
)
;
const
permutations
=
calculatePermutations
(
tail
)
;
permutations
.
forEach
(
p
=
>
{
result
.
push
(
[
head
.
.
.
p
]
)
;
}
)
;
}
)
;
return
result
;
}
