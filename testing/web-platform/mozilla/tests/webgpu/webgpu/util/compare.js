import
{
getIsBuildingDataCache
}
from
'
.
.
/
.
.
/
common
/
framework
/
data_cache
.
js
'
;
import
{
Colors
}
from
'
.
.
/
.
.
/
common
/
util
/
colors
.
js
'
;
import
{
assert
unreachable
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
deserializeExpectation
serializeExpectation
}
from
'
.
.
/
shader
/
execution
/
expression
/
case_cache
.
js
'
;
import
{
toComparator
}
from
'
.
.
/
shader
/
execution
/
expression
/
expectation
.
js
'
;
import
{
ArrayValue
isFloatValue
isScalarValue
MatrixValue
VectorValue
}
from
'
.
/
conversion
.
js
'
;
import
{
FPInterval
}
from
'
.
/
floating_point
.
js
'
;
var
SerializedComparatorKind
=
function
(
SerializedComparatorKind
)
{
SerializedComparatorKind
[
SerializedComparatorKind
[
"
AnyOf
"
]
=
0
]
=
"
AnyOf
"
;
SerializedComparatorKind
[
SerializedComparatorKind
[
"
SkipUndefined
"
]
=
1
]
=
"
SkipUndefined
"
;
SerializedComparatorKind
[
SerializedComparatorKind
[
"
AlwaysPass
"
]
=
2
]
=
"
AlwaysPass
"
;
return
SerializedComparatorKind
;
}
(
SerializedComparatorKind
|
|
{
}
)
;
function
serializeComparatorKind
(
s
value
)
{
switch
(
value
)
{
case
'
anyOf
'
:
return
s
.
writeU8
(
SerializedComparatorKind
.
AnyOf
)
;
case
'
skipUndefined
'
:
return
s
.
writeU8
(
SerializedComparatorKind
.
SkipUndefined
)
;
case
'
alwaysPass
'
:
return
s
.
writeU8
(
SerializedComparatorKind
.
AlwaysPass
)
;
}
}
function
deserializeComparatorKind
(
s
)
{
const
kind
=
s
.
readU8
(
)
;
switch
(
kind
)
{
case
SerializedComparatorKind
.
AnyOf
:
return
'
anyOf
'
;
case
SerializedComparatorKind
.
SkipUndefined
:
return
'
skipUndefined
'
;
case
SerializedComparatorKind
.
AlwaysPass
:
return
'
alwaysPass
'
;
default
:
unreachable
(
invalid
serialized
ComparatorKind
:
{
kind
}
)
;
}
}
function
compareValue
(
got
expected
)
{
{
const
gTy
=
got
.
type
;
const
eTy
=
expected
.
type
;
const
bothFloatTypes
=
isFloatValue
(
got
)
&
&
isFloatValue
(
expected
)
;
if
(
gTy
!
=
=
eTy
&
&
!
bothFloatTypes
)
{
return
{
matched
:
false
got
:
{
Colors
.
red
(
gTy
.
toString
(
)
)
}
(
{
got
}
)
expected
:
{
Colors
.
red
(
eTy
.
toString
(
)
)
}
(
{
expected
}
)
}
;
}
}
if
(
isScalarValue
(
got
)
)
{
const
g
=
got
;
const
e
=
expected
;
const
isFloat
=
g
.
type
.
kind
=
=
=
'
f64
'
|
|
g
.
type
.
kind
=
=
=
'
f32
'
|
|
g
.
type
.
kind
=
=
=
'
f16
'
;
const
matched
=
isFloat
&
&
g
.
value
=
=
=
e
.
value
|
|
!
isFloat
&
&
g
.
value
=
=
=
e
.
value
;
return
{
matched
got
:
g
.
toString
(
)
expected
:
matched
?
Colors
.
green
(
e
.
toString
(
)
)
:
Colors
.
red
(
e
.
toString
(
)
)
}
;
}
if
(
got
instanceof
VectorValue
|
|
got
instanceof
ArrayValue
)
{
const
e
=
expected
;
const
gLen
=
got
.
elements
.
length
;
const
eLen
=
e
.
elements
.
length
;
let
matched
=
gLen
=
=
=
eLen
;
if
(
matched
)
{
matched
=
got
.
elements
.
every
(
(
_
i
)
=
>
{
return
compare
(
got
.
elements
[
i
]
e
.
elements
[
i
]
)
.
matched
;
}
)
;
}
return
{
matched
got
:
{
got
.
toString
(
)
}
expected
:
matched
?
Colors
.
green
(
e
.
toString
(
)
)
:
Colors
.
red
(
e
.
toString
(
)
)
}
;
}
if
(
got
instanceof
MatrixValue
)
{
const
e
=
expected
;
const
gCols
=
got
.
type
.
cols
;
const
eCols
=
e
.
type
.
cols
;
const
gRows
=
got
.
type
.
rows
;
const
eRows
=
e
.
type
.
rows
;
let
matched
=
gCols
=
=
=
eCols
&
&
gRows
=
=
=
eRows
;
if
(
matched
)
{
matched
=
got
.
elements
.
every
(
(
c
i
)
=
>
{
return
c
.
every
(
(
_
j
)
=
>
{
return
compare
(
got
.
elements
[
i
]
[
j
]
e
.
elements
[
i
]
[
j
]
)
.
matched
;
}
)
;
}
)
;
}
return
{
matched
got
:
{
got
.
toString
(
)
}
expected
:
matched
?
Colors
.
green
(
e
.
toString
(
)
)
:
Colors
.
red
(
e
.
toString
(
)
)
}
;
}
throw
new
Error
(
unhandled
type
'
{
typeof
got
}
'
)
;
}
function
compareInterval
(
got
expected
)
{
{
const
gTy
=
got
.
type
;
if
(
!
isFloatValue
(
got
)
)
{
return
{
matched
:
false
got
:
{
Colors
.
red
(
gTy
.
toString
(
)
)
}
(
{
got
}
)
expected
:
floating
point
value
}
;
}
}
if
(
isScalarValue
(
got
)
)
{
const
g
=
got
.
value
;
const
matched
=
expected
.
contains
(
g
)
;
return
{
matched
got
:
g
.
toString
(
)
expected
:
matched
?
Colors
.
green
(
expected
.
toString
(
)
)
:
Colors
.
red
(
expected
.
toString
(
)
)
}
;
}
throw
new
Error
(
unhandled
type
'
{
typeof
got
}
)
;
}
function
compareVector
(
got
expected
)
{
if
(
!
(
got
instanceof
VectorValue
)
)
{
return
{
matched
:
false
got
:
{
Colors
.
red
(
(
typeof
got
)
.
toString
(
)
)
}
(
{
got
}
)
expected
:
Vector
}
;
}
{
const
gTy
=
got
.
type
.
elementType
;
if
(
!
isFloatValue
(
got
.
elements
[
0
]
)
)
{
return
{
matched
:
false
got
:
{
Colors
.
red
(
gTy
.
toString
(
)
)
}
(
{
got
}
)
expected
:
floating
point
elements
}
;
}
}
if
(
got
.
elements
.
length
!
=
=
expected
.
length
)
{
return
{
matched
:
false
got
:
Vector
of
{
got
.
elements
.
length
}
elements
expected
:
{
expected
.
length
}
elements
}
;
}
const
results
=
got
.
elements
.
map
(
(
_
idx
)
=
>
{
const
g
=
got
.
elements
[
idx
]
.
value
;
return
{
match
:
expected
[
idx
]
.
contains
(
g
)
index
:
idx
}
;
}
)
;
const
failures
=
results
.
filter
(
(
v
)
=
>
!
v
.
match
)
.
map
(
(
v
)
=
>
v
.
index
)
;
if
(
failures
.
length
!
=
=
0
)
{
const
expected_string
=
expected
.
map
(
(
v
idx
)
=
>
idx
in
failures
?
Colors
.
red
(
[
{
v
}
]
)
:
Colors
.
green
(
[
{
v
}
]
)
)
;
return
{
matched
:
false
got
:
[
{
got
.
elements
}
]
expected
:
[
{
expected_string
}
]
}
;
}
return
{
matched
:
true
got
:
[
{
got
.
elements
}
]
expected
:
[
{
Colors
.
green
(
expected
.
toString
(
)
)
}
]
}
;
}
function
convertArrayToString
(
m
)
{
return
[
{
m
.
join
(
'
'
)
}
]
;
}
function
compareMatrix
(
got
expected
)
{
if
(
!
(
got
instanceof
MatrixValue
)
)
{
return
{
matched
:
false
got
:
{
Colors
.
red
(
(
typeof
got
)
.
toString
(
)
)
}
(
{
got
}
)
expected
:
Matrix
}
;
}
{
const
gTy
=
got
.
type
.
elementType
;
if
(
!
isFloatValue
(
got
.
elements
[
0
]
[
0
]
)
)
{
return
{
matched
:
false
got
:
{
Colors
.
red
(
gTy
.
toString
(
)
)
}
(
{
got
}
)
expected
:
floating
point
elements
}
;
}
}
{
const
gCols
=
got
.
elements
.
length
;
const
gRows
=
got
.
elements
[
0
]
.
length
;
const
eCols
=
expected
.
length
;
const
eRows
=
expected
[
0
]
.
length
;
if
(
gCols
!
=
=
eCols
|
|
gRows
!
=
=
eRows
)
{
assert
(
false
)
;
return
{
matched
:
false
got
:
Matrix
of
{
gCols
}
x
{
gRows
}
elements
expected
:
Matrix
of
{
eCols
}
x
{
eRows
}
elements
}
;
}
}
let
matched
=
true
;
const
expected_strings
=
[
.
.
.
Array
(
got
.
elements
.
length
)
]
.
map
(
(
_
)
=
>
[
.
.
.
Array
(
got
.
elements
[
0
]
.
length
)
]
)
;
got
.
elements
.
forEach
(
(
c
i
)
=
>
{
c
.
forEach
(
(
r
j
)
=
>
{
const
g
=
r
.
value
;
if
(
expected
[
i
]
[
j
]
.
contains
(
g
)
)
{
expected_strings
[
i
]
[
j
]
=
Colors
.
green
(
[
{
expected
[
i
]
[
j
]
}
]
)
;
}
else
{
matched
=
false
;
expected_strings
[
i
]
[
j
]
=
Colors
.
red
(
[
{
expected
[
i
]
[
j
]
}
]
)
;
}
}
)
;
}
)
;
return
{
matched
got
:
convertArrayToString
(
got
.
elements
.
map
(
convertArrayToString
)
)
expected
:
convertArrayToString
(
expected_strings
.
map
(
convertArrayToString
)
)
}
;
}
export
function
compare
(
got
expected
)
{
if
(
expected
instanceof
Array
)
{
if
(
expected
[
0
]
instanceof
Array
)
{
expected
=
expected
;
return
compareMatrix
(
got
expected
)
;
}
else
{
expected
=
expected
;
return
compareVector
(
got
expected
)
;
}
}
if
(
expected
instanceof
FPInterval
)
{
return
compareInterval
(
got
expected
)
;
}
return
compareValue
(
got
expected
)
;
}
export
function
anyOf
(
.
.
.
expectations
)
{
const
c
=
{
compare
:
(
got
)
=
>
{
const
failed
=
new
Set
(
)
;
for
(
const
e
of
expectations
)
{
const
cmp
=
toComparator
(
e
)
.
compare
(
got
)
;
if
(
cmp
.
matched
)
{
return
cmp
;
}
failed
.
add
(
cmp
.
expected
)
;
}
return
{
matched
:
false
got
:
got
.
toString
(
)
expected
:
[
.
.
.
failed
]
.
join
(
'
or
'
)
}
;
}
kind
:
'
anyOf
'
}
;
if
(
getIsBuildingDataCache
(
)
)
{
c
.
data
=
expectations
;
}
return
c
;
}
export
function
skipUndefined
(
expectation
)
{
const
c
=
{
compare
:
(
got
)
=
>
{
if
(
expectation
!
=
=
undefined
)
{
return
toComparator
(
expectation
)
.
compare
(
got
)
;
}
return
{
matched
:
true
got
:
got
.
toString
(
)
expected
:
Treating
'
undefined
'
as
Any
}
;
}
kind
:
'
skipUndefined
'
}
;
if
(
expectation
!
=
=
undefined
&
&
getIsBuildingDataCache
(
)
)
{
c
.
data
=
expectation
;
}
return
c
;
}
export
function
alwaysPass
(
msg
=
'
always
pass
'
)
{
const
c
=
{
compare
:
(
got
)
=
>
{
return
{
matched
:
true
got
:
got
.
toString
(
)
expected
:
msg
}
;
}
kind
:
'
alwaysPass
'
}
;
if
(
getIsBuildingDataCache
(
)
)
{
c
.
data
=
msg
;
}
return
c
;
}
export
function
serializeComparator
(
s
c
)
{
serializeComparatorKind
(
s
c
.
kind
)
;
switch
(
c
.
kind
)
{
case
'
anyOf
'
:
s
.
writeArray
(
c
.
data
serializeExpectation
)
;
return
;
case
'
skipUndefined
'
:
s
.
writeCond
(
c
.
data
!
=
=
undefined
{
if_true
:
(
)
=
>
{
serializeExpectation
(
s
c
.
data
)
;
}
if_false
:
(
)
=
>
{
}
}
)
;
return
;
case
'
alwaysPass
'
:
{
s
.
writeString
(
c
.
data
)
;
return
;
}
case
'
value
'
:
case
'
packed
'
:
{
unreachable
(
Serializing
'
{
c
.
kind
}
'
comparators
is
not
allowed
(
{
c
}
)
)
;
break
;
}
}
unreachable
(
Unable
serialize
comparator
'
{
c
}
'
)
;
}
export
function
deserializeComparator
(
s
)
{
const
kind
=
deserializeComparatorKind
(
s
)
;
switch
(
kind
)
{
case
'
anyOf
'
:
return
anyOf
(
.
.
.
s
.
readArray
(
deserializeExpectation
)
)
;
case
'
skipUndefined
'
:
return
s
.
readCond
(
{
if_true
:
(
)
=
>
{
return
skipUndefined
(
deserializeExpectation
(
s
)
)
;
}
if_false
:
(
)
=
>
{
return
skipUndefined
(
undefined
)
;
}
}
)
;
case
'
alwaysPass
'
:
return
alwaysPass
(
s
.
readString
(
)
)
;
}
unreachable
(
Unable
deserialize
comparator
'
{
s
}
'
)
;
}
