import
{
assert
unreachable
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
Float16Array
}
from
'
.
.
/
.
.
/
external
/
petamoriken
/
float16
/
float16
.
js
'
;
import
{
anyOf
}
from
'
.
/
compare
.
js
'
;
import
{
kValue
}
from
'
.
/
constants
.
js
'
;
import
{
abstractFloat
f16
f32
isFloatType
toMatrix
toVector
u32
}
from
'
.
/
conversion
.
js
'
;
import
{
calculatePermutations
cartesianProduct
correctlyRoundedF16
correctlyRoundedF32
correctlyRoundedF64
every2DArray
flatten2DArray
flushSubnormalNumberF16
flushSubnormalNumberF32
flushSubnormalNumberF64
isFiniteF16
isFiniteF32
isSubnormalNumberF16
isSubnormalNumberF32
isSubnormalNumberF64
map2DArray
oneULPF16
oneULPF32
nextAfterF64
quantizeToF16
quantizeToF32
scalarF16Range
scalarF32Range
scalarF64Range
sparseMatrixF16Range
sparseMatrixF32Range
sparseMatrixF64Range
sparseScalarF16Range
sparseScalarF32Range
sparseScalarF64Range
sparseVectorF16Range
sparseVectorF32Range
sparseVectorF64Range
unflatten2DArray
vectorF16Range
vectorF32Range
vectorF64Range
}
from
'
.
/
math
.
js
'
;
var
SerializedFPIntervalKind
=
function
(
SerializedFPIntervalKind
)
{
SerializedFPIntervalKind
[
SerializedFPIntervalKind
[
"
Abstract
"
]
=
0
]
=
"
Abstract
"
;
SerializedFPIntervalKind
[
SerializedFPIntervalKind
[
"
F32
"
]
=
1
]
=
"
F32
"
;
SerializedFPIntervalKind
[
SerializedFPIntervalKind
[
"
F16
"
]
=
2
]
=
"
F16
"
;
return
SerializedFPIntervalKind
;
}
(
SerializedFPIntervalKind
|
|
{
}
)
;
export
function
serializeFPKind
(
s
value
)
{
switch
(
value
)
{
case
'
abstract
'
:
s
.
writeU8
(
SerializedFPIntervalKind
.
Abstract
)
;
break
;
case
'
f16
'
:
s
.
writeU8
(
SerializedFPIntervalKind
.
F16
)
;
break
;
case
'
f32
'
:
s
.
writeU8
(
SerializedFPIntervalKind
.
F32
)
;
break
;
}
}
export
function
deserializeFPKind
(
s
)
{
const
kind
=
s
.
readU8
(
)
;
switch
(
kind
)
{
case
SerializedFPIntervalKind
.
Abstract
:
return
'
abstract
'
;
case
SerializedFPIntervalKind
.
F16
:
return
'
f16
'
;
case
SerializedFPIntervalKind
.
F32
:
return
'
f32
'
;
default
:
unreachable
(
invalid
deserialized
FPKind
:
{
kind
}
)
;
}
}
export
class
FPInterval
{
constructor
(
kind
.
.
.
endpoints
)
{
this
.
kind
=
kind
;
const
begin
=
endpoints
[
0
]
;
const
end
=
endpoints
.
length
=
=
=
2
?
endpoints
[
1
]
:
endpoints
[
0
]
;
assert
(
!
Number
.
isNaN
(
begin
)
&
&
!
Number
.
isNaN
(
end
)
endpoints
need
to
be
non
-
NaN
)
;
assert
(
begin
<
=
end
endpoints
[
0
]
(
{
begin
}
)
must
be
less
than
or
equal
to
endpoints
[
1
]
(
{
end
}
)
)
;
this
.
begin
=
begin
;
this
.
end
=
end
;
}
traits
(
)
{
return
FP
[
this
.
kind
]
;
}
endpoints
(
)
{
return
this
.
isPoint
(
)
?
[
this
.
begin
]
:
[
this
.
begin
this
.
end
]
;
}
contains
(
n
)
{
if
(
Number
.
isNaN
(
n
)
)
{
return
this
.
begin
=
=
=
Number
.
NEGATIVE_INFINITY
&
&
this
.
end
=
=
=
Number
.
POSITIVE_INFINITY
;
}
if
(
n
instanceof
FPInterval
)
{
return
this
.
begin
<
=
n
.
begin
&
&
this
.
end
>
=
n
.
end
;
}
return
this
.
begin
<
=
n
&
&
this
.
end
>
=
n
;
}
containsZeroOrSubnormals
(
)
{
return
!
(
this
.
end
<
this
.
traits
(
)
.
constants
(
)
.
negative
.
subnormal
.
min
|
|
this
.
begin
>
this
.
traits
(
)
.
constants
(
)
.
positive
.
subnormal
.
max
)
;
}
isPoint
(
)
{
return
this
.
begin
=
=
=
this
.
end
;
}
isFinite
(
)
{
return
this
.
traits
(
)
.
isFinite
(
this
.
begin
)
&
&
this
.
traits
(
)
.
isFinite
(
this
.
end
)
;
}
toString
(
)
{
return
{
'
{
this
.
kind
}
'
[
{
this
.
endpoints
(
)
.
map
(
this
.
traits
(
)
.
scalarBuilder
)
}
]
}
;
}
}
export
function
serializeFPInterval
(
s
i
)
{
serializeFPKind
(
s
i
.
kind
)
;
const
traits
=
FP
[
i
.
kind
]
;
s
.
writeCond
(
i
!
=
=
traits
.
constants
(
)
.
unboundedInterval
{
if_true
:
(
)
=
>
{
switch
(
i
.
kind
)
{
case
'
abstract
'
:
s
.
writeF64
(
i
.
begin
)
;
s
.
writeF64
(
i
.
end
)
;
break
;
case
'
f32
'
:
s
.
writeF32
(
i
.
begin
)
;
s
.
writeF32
(
i
.
end
)
;
break
;
case
'
f16
'
:
s
.
writeF16
(
i
.
begin
)
;
s
.
writeF16
(
i
.
end
)
;
break
;
default
:
unreachable
(
Unable
to
serialize
FPInterval
{
i
}
)
;
break
;
}
}
if_false
:
(
)
=
>
{
}
}
)
;
}
export
function
deserializeFPInterval
(
s
)
{
const
kind
=
deserializeFPKind
(
s
)
;
const
traits
=
FP
[
kind
]
;
return
s
.
readCond
(
{
if_true
:
(
)
=
>
{
switch
(
kind
)
{
case
'
abstract
'
:
return
new
FPInterval
(
traits
.
kind
s
.
readF64
(
)
s
.
readF64
(
)
)
;
case
'
f32
'
:
return
new
FPInterval
(
traits
.
kind
s
.
readF32
(
)
s
.
readF32
(
)
)
;
case
'
f16
'
:
return
new
FPInterval
(
traits
.
kind
s
.
readF16
(
)
s
.
readF16
(
)
)
;
}
unreachable
(
Unable
to
deserialize
FPInterval
with
kind
{
kind
}
)
;
}
if_false
:
(
)
=
>
{
return
traits
.
constants
(
)
.
unboundedInterval
;
}
}
)
;
}
function
addFlushedIfNeededF16
(
values
)
{
return
values
.
some
(
(
v
)
=
>
v
!
=
=
0
&
&
isSubnormalNumberF16
(
v
)
)
?
values
.
concat
(
0
)
:
values
;
}
export
class
FPTraits
{
constructor
(
k
)
{
this
.
kind
=
k
;
}
toInterval
(
n
)
{
if
(
n
instanceof
FPInterval
)
{
if
(
n
.
kind
=
=
=
this
.
kind
)
{
return
n
;
}
if
(
!
n
.
isFinite
(
)
)
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
return
new
FPInterval
(
this
.
kind
.
.
.
n
.
endpoints
(
)
)
;
}
if
(
n
instanceof
Array
)
{
return
new
FPInterval
(
this
.
kind
.
.
.
n
)
;
}
return
new
FPInterval
(
this
.
kind
n
n
)
;
}
correctlyRoundedIntervalWithUnboundedPrecisionForAddition
(
val
large_val
small_val
)
{
if
(
val
=
=
=
large_val
&
&
!
(
small_val
=
=
=
0
.
0
)
)
{
if
(
Math
.
sign
(
small_val
)
>
=
0
)
{
return
this
.
correctlyRoundedInterval
(
this
.
toInterval
(
[
large_val
nextAfterF64
(
large_val
'
positive
'
'
flush
'
)
]
)
)
;
}
else
{
return
this
.
correctlyRoundedInterval
(
this
.
toInterval
(
[
nextAfterF64
(
large_val
'
negative
'
'
flush
'
)
large_val
]
)
)
;
}
}
return
this
.
correctlyRoundedInterval
(
val
)
;
}
toParam
(
n
)
{
return
{
kind
:
this
.
kind
interval
:
n
}
;
}
fromParam
(
p
)
{
const
param
=
p
;
if
(
param
.
interval
&
&
param
.
kind
)
{
assert
(
param
.
kind
=
=
=
this
.
kind
)
;
return
this
.
toInterval
(
param
.
interval
)
;
}
return
p
;
}
spanIntervals
(
.
.
.
intervals
)
{
assert
(
intervals
.
length
>
0
span
of
an
empty
list
of
FPIntervals
is
not
allowed
)
;
assert
(
intervals
.
every
(
(
i
)
=
>
i
.
kind
=
=
=
this
.
kind
)
span
is
only
defined
for
intervals
with
the
same
kind
)
;
let
begin
=
Number
.
POSITIVE_INFINITY
;
let
end
=
Number
.
NEGATIVE_INFINITY
;
intervals
.
forEach
(
(
i
)
=
>
{
begin
=
Math
.
min
(
i
.
begin
begin
)
;
end
=
Math
.
max
(
i
.
end
end
)
;
}
)
;
return
this
.
toInterval
(
[
begin
end
]
)
;
}
isVector
(
v
)
{
if
(
v
.
every
(
(
e
)
=
>
e
instanceof
FPInterval
&
&
e
.
kind
=
=
=
this
.
kind
)
)
{
return
v
.
length
=
=
=
2
|
|
v
.
length
=
=
=
3
|
|
v
.
length
=
=
=
4
;
}
return
false
;
}
toVector
(
v
)
{
if
(
this
.
isVector
(
v
)
&
&
v
.
every
(
(
e
)
=
>
e
.
kind
=
=
=
this
.
kind
)
)
{
return
v
;
}
const
f
=
v
.
map
(
(
e
)
=
>
this
.
toInterval
(
e
)
)
;
if
(
this
.
isVector
(
f
)
)
{
return
f
;
}
unreachable
(
Cannot
convert
[
{
v
}
]
to
FPVector
)
;
}
spanVectors
(
.
.
.
vectors
)
{
assert
(
vectors
.
every
(
(
e
)
=
>
this
.
isVector
(
e
)
)
'
Vector
span
is
not
defined
for
vectors
of
differing
floating
point
kinds
'
)
;
const
vector_length
=
vectors
[
0
]
.
length
;
assert
(
vectors
.
every
(
(
e
)
=
>
e
.
length
=
=
=
vector_length
)
Vector
span
is
not
defined
for
vectors
of
differing
lengths
)
;
const
result
=
new
Array
(
vector_length
)
;
for
(
let
i
=
0
;
i
<
vector_length
;
i
+
+
)
{
result
[
i
]
=
this
.
spanIntervals
(
.
.
.
vectors
.
map
(
(
v
)
=
>
v
[
i
]
)
)
;
}
return
this
.
toVector
(
result
)
;
}
isMatrix
(
m
)
{
if
(
!
m
.
every
(
(
c
)
=
>
c
.
every
(
(
e
)
=
>
e
instanceof
FPInterval
&
&
e
.
kind
=
=
=
this
.
kind
)
)
)
{
return
false
;
}
m
=
m
;
if
(
m
.
length
>
4
|
|
m
.
length
<
2
)
{
return
false
;
}
const
num_rows
=
m
[
0
]
.
length
;
if
(
num_rows
>
4
|
|
num_rows
<
2
)
{
return
false
;
}
return
m
.
every
(
(
c
)
=
>
c
.
length
=
=
=
num_rows
)
;
}
toMatrix
(
m
)
{
if
(
this
.
isMatrix
(
m
)
&
&
every2DArray
(
m
(
e
)
=
>
{
return
e
.
kind
=
=
=
this
.
kind
;
}
)
)
{
return
m
;
}
const
result
=
map2DArray
(
m
this
.
toInterval
.
bind
(
this
)
)
;
if
(
this
.
isMatrix
(
result
)
)
{
return
result
;
}
unreachable
(
Cannot
convert
{
m
}
to
FPMatrix
)
;
}
spanMatrices
(
.
.
.
matrices
)
{
const
ms
=
matrices
;
const
num_cols
=
ms
[
0
]
.
length
;
const
num_rows
=
ms
[
0
]
[
0
]
.
length
;
assert
(
ms
.
every
(
(
m
)
=
>
m
.
length
=
=
=
num_cols
&
&
m
.
every
(
(
r
)
=
>
r
.
length
=
=
=
num_rows
)
)
Matrix
span
is
not
defined
for
Matrices
of
differing
dimensions
)
;
const
result
=
[
.
.
.
Array
(
num_cols
)
]
.
map
(
(
_
)
=
>
[
.
.
.
Array
(
num_rows
)
]
)
;
for
(
let
i
=
0
;
i
<
num_cols
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
num_rows
;
j
+
+
)
{
result
[
i
]
[
j
]
=
this
.
spanIntervals
(
.
.
.
ms
.
map
(
(
m
)
=
>
m
[
i
]
[
j
]
)
)
;
}
}
return
this
.
toMatrix
(
result
)
;
}
addFlushedIfNeeded
(
values
)
{
const
subnormals
=
values
.
filter
(
this
.
isSubnormal
)
;
const
needs_zero
=
subnormals
.
length
>
0
&
&
subnormals
.
every
(
(
s
)
=
>
s
!
=
=
0
)
;
return
needs_zero
?
values
.
concat
(
0
)
:
values
;
}
unimplementedScalarToInterval
(
name
_x
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedScalarPairToInterval
(
name
_x
_y
)
{
unreachable
(
'
{
name
}
'
is
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedScalarTripleToInterval
(
name
_x
_y
_z
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedScalarToVector
(
name
_x
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedVectorToInterval
(
name
_x
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedVectorPairToInterval
(
name
_x
_y
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedVectorToVector
(
name
_x
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedVectorPairToVector
(
name
_x
_y
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedVectorScalarToVector
(
name
_x
_y
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedScalarVectorToVector
(
name
_x
_y
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedMatrixToInterval
(
name
_x
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedMatrixToMatrix
(
name
_x
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedMatrixPairToMatrix
(
name
_x
_y
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedMatrixScalarToMatrix
(
name
_x
_y
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedScalarMatrixToMatrix
(
name
_x
_y
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedMatrixVectorToVector
(
name
_x
_y
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedVectorMatrixToVector
(
name
_x
_y
)
{
unreachable
(
'
{
name
}
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedDistance
(
_x
_y
)
{
unreachable
(
'
distance
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedFaceForward
(
_x
_y
_z
)
{
unreachable
(
'
faceForward
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedLength
(
_x
)
{
unreachable
(
'
length
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedModf
(
_x
)
{
unreachable
(
'
modf
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedRefract
(
_i
_s
_r
)
{
unreachable
(
'
refract
'
is
not
yet
implemented
for
'
{
this
.
kind
}
'
)
;
}
unimplementedAbsoluteErrorInterval
(
_n
_error_range
)
{
unreachable
(
Absolute
Error
is
not
implement
for
'
{
this
.
kind
}
'
)
;
}
unimplementedUlpInterval
(
_n
_numULP
)
{
unreachable
(
ULP
Error
is
not
implement
for
'
{
this
.
kind
}
'
)
;
}
makeScalarToIntervalCase
(
param
filter
.
.
.
ops
)
{
param
=
this
.
quantize
(
param
)
;
const
intervals
=
ops
.
map
(
(
o
)
=
>
o
(
param
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
intervals
.
some
(
(
i
)
=
>
!
i
.
isFinite
(
)
)
)
{
return
undefined
;
}
return
{
input
:
[
this
.
scalarBuilder
(
param
)
]
expected
:
anyOf
(
.
.
.
intervals
)
}
;
}
generateScalarToIntervalCases
(
params
filter
.
.
.
ops
)
{
return
params
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
this
.
makeScalarToIntervalCase
(
e
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
(
)
)
;
}
makeScalarPairToIntervalCase
(
param0
param1
filter
.
.
.
ops
)
{
param0
=
this
.
quantize
(
param0
)
;
param1
=
this
.
quantize
(
param1
)
;
const
intervals
=
ops
.
map
(
(
o
)
=
>
o
(
param0
param1
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
intervals
.
some
(
(
i
)
=
>
!
i
.
isFinite
(
)
)
)
{
return
undefined
;
}
return
{
input
:
[
this
.
scalarBuilder
(
param0
)
this
.
scalarBuilder
(
param1
)
]
expected
:
anyOf
(
.
.
.
intervals
)
}
;
}
generateScalarPairToIntervalCases
(
param0s
param1s
filter
.
.
.
ops
)
{
return
cartesianProduct
(
param0s
param1s
)
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
this
.
makeScalarPairToIntervalCase
(
e
[
0
]
e
[
1
]
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
(
)
)
;
}
makeScalarTripleToIntervalCase
(
param0
param1
param2
filter
.
.
.
ops
)
{
param0
=
this
.
quantize
(
param0
)
;
param1
=
this
.
quantize
(
param1
)
;
param2
=
this
.
quantize
(
param2
)
;
const
intervals
=
ops
.
map
(
(
o
)
=
>
o
(
param0
param1
param2
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
intervals
.
some
(
(
i
)
=
>
!
i
.
isFinite
(
)
)
)
{
return
undefined
;
}
return
{
input
:
[
this
.
scalarBuilder
(
param0
)
this
.
scalarBuilder
(
param1
)
this
.
scalarBuilder
(
param2
)
]
expected
:
anyOf
(
.
.
.
intervals
)
}
;
}
generateScalarTripleToIntervalCases
(
param0s
param1s
param2s
filter
.
.
.
ops
)
{
return
cartesianProduct
(
param0s
param1s
param2s
)
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
this
.
makeScalarTripleToIntervalCase
(
e
[
0
]
e
[
1
]
e
[
2
]
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
(
)
)
;
}
makeVectorToIntervalCase
(
param
filter
.
.
.
ops
)
{
param
=
param
.
map
(
this
.
quantize
)
;
const
intervals
=
ops
.
map
(
(
o
)
=
>
o
(
param
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
intervals
.
some
(
(
i
)
=
>
!
i
.
isFinite
(
)
)
)
{
return
undefined
;
}
return
{
input
:
[
toVector
(
param
this
.
scalarBuilder
)
]
expected
:
anyOf
(
.
.
.
intervals
)
}
;
}
generateVectorToIntervalCases
(
params
filter
.
.
.
ops
)
{
return
params
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
this
.
makeVectorToIntervalCase
(
e
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
(
)
)
;
}
makeVectorPairToIntervalCase
(
param0
param1
filter
.
.
.
ops
)
{
param0
=
param0
.
map
(
this
.
quantize
)
;
param1
=
param1
.
map
(
this
.
quantize
)
;
const
intervals
=
ops
.
map
(
(
o
)
=
>
o
(
param0
param1
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
intervals
.
some
(
(
i
)
=
>
!
i
.
isFinite
(
)
)
)
{
return
undefined
;
}
return
{
input
:
[
toVector
(
param0
this
.
scalarBuilder
)
toVector
(
param1
this
.
scalarBuilder
)
]
expected
:
anyOf
(
.
.
.
intervals
)
}
;
}
generateVectorPairToIntervalCases
(
param0s
param1s
filter
.
.
.
ops
)
{
return
cartesianProduct
(
param0s
param1s
)
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
this
.
makeVectorPairToIntervalCase
(
e
[
0
]
e
[
1
]
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
(
)
)
;
}
makeVectorToVectorCase
(
param
filter
.
.
.
ops
)
{
param
=
param
.
map
(
this
.
quantize
)
;
const
vectors
=
ops
.
map
(
(
o
)
=
>
o
(
param
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
vectors
.
some
(
(
v
)
=
>
v
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
toVector
(
param
this
.
scalarBuilder
)
]
expected
:
anyOf
(
.
.
.
vectors
)
}
;
}
generateVectorToVectorCases
(
params
filter
.
.
.
ops
)
{
return
params
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
this
.
makeVectorToVectorCase
(
e
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
(
)
)
;
}
makeScalarVectorToVectorCase
(
scalar
vector
filter
.
.
.
ops
)
{
scalar
=
this
.
quantize
(
scalar
)
;
vector
=
vector
.
map
(
this
.
quantize
)
;
const
results
=
ops
.
map
(
(
o
)
=
>
o
(
scalar
vector
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
results
.
some
(
(
r
)
=
>
r
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
this
.
scalarBuilder
(
scalar
)
toVector
(
vector
this
.
scalarBuilder
)
]
expected
:
anyOf
(
.
.
.
results
)
}
;
}
generateScalarVectorToVectorCases
(
scalars
vectors
filter
.
.
.
ops
)
{
const
cases
=
[
]
;
scalars
.
forEach
(
(
scalar
)
=
>
{
vectors
.
forEach
(
(
vector
)
=
>
{
const
c
=
this
.
makeScalarVectorToVectorCase
(
scalar
vector
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
}
)
;
}
)
;
return
cases
;
}
makeVectorScalarToVectorCase
(
vector
scalar
filter
.
.
.
ops
)
{
vector
=
vector
.
map
(
this
.
quantize
)
;
scalar
=
this
.
quantize
(
scalar
)
;
const
results
=
ops
.
map
(
(
o
)
=
>
o
(
vector
scalar
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
results
.
some
(
(
r
)
=
>
r
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
toVector
(
vector
this
.
scalarBuilder
)
this
.
scalarBuilder
(
scalar
)
]
expected
:
anyOf
(
.
.
.
results
)
}
;
}
generateVectorScalarToVectorCases
(
vectors
scalars
filter
.
.
.
ops
)
{
const
cases
=
[
]
;
vectors
.
forEach
(
(
vector
)
=
>
{
scalars
.
forEach
(
(
scalar
)
=
>
{
const
c
=
this
.
makeVectorScalarToVectorCase
(
vector
scalar
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
}
)
;
}
)
;
return
cases
;
}
makeVectorPairToVectorCase
(
param0
param1
filter
.
.
.
ops
)
{
param0
=
param0
.
map
(
this
.
quantize
)
;
param1
=
param1
.
map
(
this
.
quantize
)
;
const
vectors
=
ops
.
map
(
(
o
)
=
>
o
(
param0
param1
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
vectors
.
some
(
(
v
)
=
>
v
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
toVector
(
param0
this
.
scalarBuilder
)
toVector
(
param1
this
.
scalarBuilder
)
]
expected
:
anyOf
(
.
.
.
vectors
)
}
;
}
generateVectorPairToVectorCases
(
param0s
param1s
filter
.
.
.
ops
)
{
return
cartesianProduct
(
param0s
param1s
)
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
this
.
makeVectorPairToVectorCase
(
e
[
0
]
e
[
1
]
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
(
)
)
;
}
makeVectorPairScalarToVectorComponentWiseCase
(
param0
param1
param2
filter
.
.
.
componentWiseOps
)
{
const
width
=
param0
.
length
;
assert
(
2
<
=
width
&
&
width
<
=
4
'
input
vector
width
must
between
2
and
4
'
)
;
assert
(
param1
.
length
=
=
=
width
'
two
input
vectors
must
have
the
same
width
'
)
;
param0
=
param0
.
map
(
this
.
quantize
)
;
param1
=
param1
.
map
(
this
.
quantize
)
;
param2
=
this
.
quantize
(
param2
)
;
const
results
=
componentWiseOps
.
map
(
(
o
)
=
>
{
return
param0
.
map
(
(
el0
index
)
=
>
o
(
el0
param1
[
index
]
param2
)
)
;
}
)
;
if
(
filter
=
=
=
'
finite
'
&
&
results
.
some
(
(
r
)
=
>
r
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
toVector
(
param0
this
.
scalarBuilder
)
toVector
(
param1
this
.
scalarBuilder
)
this
.
scalarBuilder
(
param2
)
]
expected
:
anyOf
(
.
.
.
results
)
}
;
}
generateVectorPairScalarToVectorComponentWiseCase
(
param0s
param1s
param2s
filter
.
.
.
componentWiseOps
)
{
const
cases
=
[
]
;
param0s
.
forEach
(
(
param0
)
=
>
{
param1s
.
forEach
(
(
param1
)
=
>
{
param2s
.
forEach
(
(
param2
)
=
>
{
const
c
=
this
.
makeVectorPairScalarToVectorComponentWiseCase
(
param0
param1
param2
filter
.
.
.
componentWiseOps
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
}
)
;
}
)
;
}
)
;
return
cases
;
}
makeMatrixToScalarCase
(
param
filter
.
.
.
ops
)
{
param
=
map2DArray
(
param
this
.
quantize
)
;
const
results
=
ops
.
map
(
(
o
)
=
>
o
(
param
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
results
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
)
{
return
undefined
;
}
return
{
input
:
[
toMatrix
(
param
this
.
scalarBuilder
)
]
expected
:
anyOf
(
.
.
.
results
)
}
;
}
generateMatrixToScalarCases
(
params
filter
.
.
.
ops
)
{
return
params
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
this
.
makeMatrixToScalarCase
(
e
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
(
)
)
;
}
makeMatrixToMatrixCase
(
param
filter
.
.
.
ops
)
{
param
=
map2DArray
(
param
this
.
quantize
)
;
const
results
=
ops
.
map
(
(
o
)
=
>
o
(
param
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
results
.
some
(
(
m
)
=
>
m
.
some
(
(
c
)
=
>
c
.
some
(
(
r
)
=
>
!
r
.
isFinite
(
)
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
toMatrix
(
param
this
.
scalarBuilder
)
]
expected
:
anyOf
(
.
.
.
results
)
}
;
}
generateMatrixToMatrixCases
(
params
filter
.
.
.
ops
)
{
return
params
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
this
.
makeMatrixToMatrixCase
(
e
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
(
)
)
;
}
makeMatrixPairToMatrixCase
(
param0
param1
filter
.
.
.
ops
)
{
param0
=
map2DArray
(
param0
this
.
quantize
)
;
param1
=
map2DArray
(
param1
this
.
quantize
)
;
const
results
=
ops
.
map
(
(
o
)
=
>
o
(
param0
param1
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
results
.
some
(
(
m
)
=
>
m
.
some
(
(
c
)
=
>
c
.
some
(
(
r
)
=
>
!
r
.
isFinite
(
)
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
toMatrix
(
param0
this
.
scalarBuilder
)
toMatrix
(
param1
this
.
scalarBuilder
)
]
expected
:
anyOf
(
.
.
.
results
)
}
;
}
generateMatrixPairToMatrixCases
(
param0s
param1s
filter
.
.
.
ops
)
{
return
cartesianProduct
(
param0s
param1s
)
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
this
.
makeMatrixPairToMatrixCase
(
e
[
0
]
e
[
1
]
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
(
)
)
;
}
makeMatrixScalarToMatrixCase
(
mat
scalar
filter
.
.
.
ops
)
{
mat
=
map2DArray
(
mat
this
.
quantize
)
;
scalar
=
this
.
quantize
(
scalar
)
;
const
results
=
ops
.
map
(
(
o
)
=
>
o
(
mat
scalar
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
results
.
some
(
(
m
)
=
>
m
.
some
(
(
c
)
=
>
c
.
some
(
(
r
)
=
>
!
r
.
isFinite
(
)
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
toMatrix
(
mat
this
.
scalarBuilder
)
this
.
scalarBuilder
(
scalar
)
]
expected
:
anyOf
(
.
.
.
results
)
}
;
}
generateMatrixScalarToMatrixCases
(
mats
scalars
filter
.
.
.
ops
)
{
const
cases
=
[
]
;
mats
.
forEach
(
(
mat
)
=
>
{
scalars
.
forEach
(
(
scalar
)
=
>
{
const
c
=
this
.
makeMatrixScalarToMatrixCase
(
mat
scalar
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
}
)
;
}
)
;
return
cases
;
}
makeScalarMatrixToMatrixCase
(
scalar
mat
filter
.
.
.
ops
)
{
scalar
=
this
.
quantize
(
scalar
)
;
mat
=
map2DArray
(
mat
this
.
quantize
)
;
const
results
=
ops
.
map
(
(
o
)
=
>
o
(
scalar
mat
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
results
.
some
(
(
m
)
=
>
m
.
some
(
(
c
)
=
>
c
.
some
(
(
r
)
=
>
!
r
.
isFinite
(
)
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
this
.
scalarBuilder
(
scalar
)
toMatrix
(
mat
this
.
scalarBuilder
)
]
expected
:
anyOf
(
.
.
.
results
)
}
;
}
generateScalarMatrixToMatrixCases
(
scalars
mats
filter
.
.
.
ops
)
{
const
cases
=
[
]
;
mats
.
forEach
(
(
mat
)
=
>
{
scalars
.
forEach
(
(
scalar
)
=
>
{
const
c
=
this
.
makeScalarMatrixToMatrixCase
(
scalar
mat
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
}
)
;
}
)
;
return
cases
;
}
makeMatrixVectorToVectorCase
(
mat
vec
filter
.
.
.
ops
)
{
mat
=
map2DArray
(
mat
this
.
quantize
)
;
vec
=
vec
.
map
(
this
.
quantize
)
;
const
results
=
ops
.
map
(
(
o
)
=
>
o
(
mat
vec
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
results
.
some
(
(
v
)
=
>
v
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
toMatrix
(
mat
this
.
scalarBuilder
)
toVector
(
vec
this
.
scalarBuilder
)
]
expected
:
anyOf
(
.
.
.
results
)
}
;
}
generateMatrixVectorToVectorCases
(
mats
vecs
filter
.
.
.
ops
)
{
const
cases
=
[
]
;
mats
.
forEach
(
(
mat
)
=
>
{
vecs
.
forEach
(
(
vec
)
=
>
{
const
c
=
this
.
makeMatrixVectorToVectorCase
(
mat
vec
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
}
)
;
}
)
;
return
cases
;
}
makeVectorMatrixToVectorCase
(
vec
mat
filter
.
.
.
ops
)
{
vec
=
vec
.
map
(
this
.
quantize
)
;
mat
=
map2DArray
(
mat
this
.
quantize
)
;
const
results
=
ops
.
map
(
(
o
)
=
>
o
(
vec
mat
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
results
.
some
(
(
v
)
=
>
v
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
toVector
(
vec
this
.
scalarBuilder
)
toMatrix
(
mat
this
.
scalarBuilder
)
]
expected
:
anyOf
(
.
.
.
results
)
}
;
}
generateVectorMatrixToVectorCases
(
vecs
mats
filter
.
.
.
ops
)
{
const
cases
=
[
]
;
vecs
.
forEach
(
(
vec
)
=
>
{
mats
.
forEach
(
(
mat
)
=
>
{
const
c
=
this
.
makeVectorMatrixToVectorCase
(
vec
mat
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
}
)
;
}
)
;
return
cases
;
}
roundAndFlushScalarToInterval
(
n
op
)
{
assert
(
!
Number
.
isNaN
(
n
)
flush
not
defined
for
NaN
)
;
const
values
=
this
.
correctlyRounded
(
n
)
;
const
inputs
=
this
.
addFlushedIfNeeded
(
values
)
;
if
(
op
.
domain
!
=
=
undefined
)
{
const
domain
=
op
.
domain
(
)
;
if
(
inputs
.
some
(
(
i
)
=
>
!
domain
.
contains
(
i
)
)
)
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
}
const
results
=
new
Set
(
inputs
.
map
(
op
.
impl
)
)
;
return
this
.
spanIntervals
(
.
.
.
results
)
;
}
roundAndFlushScalarPairToInterval
(
x
y
op
)
{
assert
(
!
Number
.
isNaN
(
x
)
flush
not
defined
for
NaN
)
;
assert
(
!
Number
.
isNaN
(
y
)
flush
not
defined
for
NaN
)
;
const
x_values
=
this
.
correctlyRounded
(
x
)
;
const
y_values
=
this
.
correctlyRounded
(
y
)
;
const
x_inputs
=
this
.
addFlushedIfNeeded
(
x_values
)
;
const
y_inputs
=
this
.
addFlushedIfNeeded
(
y_values
)
;
if
(
op
.
domain
!
=
=
undefined
)
{
const
domain
=
op
.
domain
(
)
;
if
(
x_inputs
.
some
(
(
i
)
=
>
!
domain
.
x
.
some
(
(
e
)
=
>
e
.
contains
(
i
)
)
)
)
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
if
(
y_inputs
.
some
(
(
j
)
=
>
!
domain
.
y
.
some
(
(
e
)
=
>
e
.
contains
(
j
)
)
)
)
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
}
const
intervals
=
new
Set
(
)
;
x_inputs
.
forEach
(
(
inner_x
)
=
>
{
y_inputs
.
forEach
(
(
inner_y
)
=
>
{
intervals
.
add
(
op
.
impl
(
inner_x
inner_y
)
)
;
}
)
;
}
)
;
return
this
.
spanIntervals
(
.
.
.
intervals
)
;
}
roundAndFlushScalarTripleToInterval
(
x
y
z
op
)
{
assert
(
!
Number
.
isNaN
(
x
)
flush
not
defined
for
NaN
)
;
assert
(
!
Number
.
isNaN
(
y
)
flush
not
defined
for
NaN
)
;
assert
(
!
Number
.
isNaN
(
z
)
flush
not
defined
for
NaN
)
;
const
x_values
=
this
.
correctlyRounded
(
x
)
;
const
y_values
=
this
.
correctlyRounded
(
y
)
;
const
z_values
=
this
.
correctlyRounded
(
z
)
;
const
x_inputs
=
this
.
addFlushedIfNeeded
(
x_values
)
;
const
y_inputs
=
this
.
addFlushedIfNeeded
(
y_values
)
;
const
z_inputs
=
this
.
addFlushedIfNeeded
(
z_values
)
;
const
intervals
=
new
Set
(
)
;
x_inputs
.
forEach
(
(
inner_x
)
=
>
{
y_inputs
.
forEach
(
(
inner_y
)
=
>
{
z_inputs
.
forEach
(
(
inner_z
)
=
>
{
intervals
.
add
(
op
.
impl
(
inner_x
inner_y
inner_z
)
)
;
}
)
;
}
)
;
}
)
;
return
this
.
spanIntervals
(
.
.
.
intervals
)
;
}
roundAndFlushVectorToInterval
(
x
op
)
{
assert
(
x
.
every
(
(
e
)
=
>
!
Number
.
isNaN
(
e
)
)
flush
not
defined
for
NaN
)
;
const
x_rounded
=
x
.
map
(
this
.
correctlyRounded
)
;
const
x_flushed
=
x_rounded
.
map
(
this
.
addFlushedIfNeeded
.
bind
(
this
)
)
;
const
x_inputs
=
cartesianProduct
(
.
.
.
x_flushed
)
;
const
intervals
=
new
Set
(
)
;
x_inputs
.
forEach
(
(
inner_x
)
=
>
{
intervals
.
add
(
op
.
impl
(
inner_x
)
)
;
}
)
;
return
this
.
spanIntervals
(
.
.
.
intervals
)
;
}
roundAndFlushVectorPairToInterval
(
x
y
op
)
{
assert
(
x
.
every
(
(
e
)
=
>
!
Number
.
isNaN
(
e
)
)
flush
not
defined
for
NaN
)
;
assert
(
y
.
every
(
(
e
)
=
>
!
Number
.
isNaN
(
e
)
)
flush
not
defined
for
NaN
)
;
const
x_rounded
=
x
.
map
(
this
.
correctlyRounded
)
;
const
y_rounded
=
y
.
map
(
this
.
correctlyRounded
)
;
const
x_flushed
=
x_rounded
.
map
(
this
.
addFlushedIfNeeded
.
bind
(
this
)
)
;
const
y_flushed
=
y_rounded
.
map
(
this
.
addFlushedIfNeeded
.
bind
(
this
)
)
;
const
x_inputs
=
cartesianProduct
(
.
.
.
x_flushed
)
;
const
y_inputs
=
cartesianProduct
(
.
.
.
y_flushed
)
;
const
intervals
=
new
Set
(
)
;
x_inputs
.
forEach
(
(
inner_x
)
=
>
{
y_inputs
.
forEach
(
(
inner_y
)
=
>
{
intervals
.
add
(
op
.
impl
(
inner_x
inner_y
)
)
;
}
)
;
}
)
;
return
this
.
spanIntervals
(
.
.
.
intervals
)
;
}
roundAndFlushVectorToVector
(
x
op
)
{
assert
(
x
.
every
(
(
e
)
=
>
!
Number
.
isNaN
(
e
)
)
flush
not
defined
for
NaN
)
;
const
x_rounded
=
x
.
map
(
this
.
correctlyRounded
)
;
const
x_flushed
=
x_rounded
.
map
(
this
.
addFlushedIfNeeded
.
bind
(
this
)
)
;
const
x_inputs
=
cartesianProduct
(
.
.
.
x_flushed
)
;
const
interval_vectors
=
new
Set
(
)
;
x_inputs
.
forEach
(
(
inner_x
)
=
>
{
interval_vectors
.
add
(
op
.
impl
(
inner_x
)
)
;
}
)
;
return
this
.
spanVectors
(
.
.
.
interval_vectors
)
;
}
roundAndFlushVectorPairToVector
(
x
y
op
)
{
assert
(
x
.
every
(
(
e
)
=
>
!
Number
.
isNaN
(
e
)
)
flush
not
defined
for
NaN
)
;
assert
(
y
.
every
(
(
e
)
=
>
!
Number
.
isNaN
(
e
)
)
flush
not
defined
for
NaN
)
;
const
x_rounded
=
x
.
map
(
this
.
correctlyRounded
)
;
const
y_rounded
=
y
.
map
(
this
.
correctlyRounded
)
;
const
x_flushed
=
x_rounded
.
map
(
this
.
addFlushedIfNeeded
.
bind
(
this
)
)
;
const
y_flushed
=
y_rounded
.
map
(
this
.
addFlushedIfNeeded
.
bind
(
this
)
)
;
const
x_inputs
=
cartesianProduct
(
.
.
.
x_flushed
)
;
const
y_inputs
=
cartesianProduct
(
.
.
.
y_flushed
)
;
const
interval_vectors
=
new
Set
(
)
;
x_inputs
.
forEach
(
(
inner_x
)
=
>
{
y_inputs
.
forEach
(
(
inner_y
)
=
>
{
interval_vectors
.
add
(
op
.
impl
(
inner_x
inner_y
)
)
;
}
)
;
}
)
;
return
this
.
spanVectors
(
.
.
.
interval_vectors
)
;
}
roundAndFlushMatrixToMatrix
(
m
op
)
{
const
num_cols
=
m
.
length
;
const
num_rows
=
m
[
0
]
.
length
;
assert
(
m
.
every
(
(
c
)
=
>
c
.
every
(
(
r
)
=
>
!
Number
.
isNaN
(
r
)
)
)
flush
not
defined
for
NaN
)
;
const
m_flat
=
flatten2DArray
(
m
)
;
const
m_rounded
=
m_flat
.
map
(
this
.
correctlyRounded
)
;
const
m_flushed
=
m_rounded
.
map
(
this
.
addFlushedIfNeeded
.
bind
(
this
)
)
;
const
m_options
=
cartesianProduct
(
.
.
.
m_flushed
)
;
const
m_inputs
=
m_options
.
map
(
(
e
)
=
>
unflatten2DArray
(
e
num_cols
num_rows
)
)
;
const
interval_matrices
=
new
Set
(
)
;
m_inputs
.
forEach
(
(
inner_m
)
=
>
{
interval_matrices
.
add
(
op
.
impl
(
inner_m
)
)
;
}
)
;
return
this
.
spanMatrices
(
.
.
.
interval_matrices
)
;
}
runScalarToIntervalOp
(
x
op
)
{
if
(
!
x
.
isFinite
(
)
)
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
if
(
op
.
extrema
!
=
=
undefined
)
{
x
=
op
.
extrema
(
x
)
;
}
const
result
=
this
.
spanIntervals
(
.
.
.
x
.
endpoints
(
)
.
map
(
(
b
)
=
>
this
.
roundAndFlushScalarToInterval
(
b
op
)
)
)
;
return
result
.
isFinite
(
)
?
result
:
this
.
constants
(
)
.
unboundedInterval
;
}
runScalarPairToIntervalOp
(
x
y
op
)
{
if
(
!
x
.
isFinite
(
)
|
|
!
y
.
isFinite
(
)
)
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
if
(
op
.
extrema
!
=
=
undefined
)
{
[
x
y
]
=
op
.
extrema
(
x
y
)
;
}
const
outputs
=
new
Set
(
)
;
x
.
endpoints
(
)
.
forEach
(
(
inner_x
)
=
>
{
y
.
endpoints
(
)
.
forEach
(
(
inner_y
)
=
>
{
outputs
.
add
(
this
.
roundAndFlushScalarPairToInterval
(
inner_x
inner_y
op
)
)
;
}
)
;
}
)
;
const
result
=
this
.
spanIntervals
(
.
.
.
outputs
)
;
return
result
.
isFinite
(
)
?
result
:
this
.
constants
(
)
.
unboundedInterval
;
}
runScalarTripleToIntervalOp
(
x
y
z
op
)
{
if
(
!
x
.
isFinite
(
)
|
|
!
y
.
isFinite
(
)
|
|
!
z
.
isFinite
(
)
)
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
const
outputs
=
new
Set
(
)
;
x
.
endpoints
(
)
.
forEach
(
(
inner_x
)
=
>
{
y
.
endpoints
(
)
.
forEach
(
(
inner_y
)
=
>
{
z
.
endpoints
(
)
.
forEach
(
(
inner_z
)
=
>
{
outputs
.
add
(
this
.
roundAndFlushScalarTripleToInterval
(
inner_x
inner_y
inner_z
op
)
)
;
}
)
;
}
)
;
}
)
;
const
result
=
this
.
spanIntervals
(
.
.
.
outputs
)
;
return
result
.
isFinite
(
)
?
result
:
this
.
constants
(
)
.
unboundedInterval
;
}
runVectorToIntervalOp
(
x
op
)
{
if
(
x
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
)
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
const
x_values
=
cartesianProduct
(
.
.
.
x
.
map
(
(
e
)
=
>
e
.
endpoints
(
)
)
)
;
const
outputs
=
new
Set
(
)
;
x_values
.
forEach
(
(
inner_x
)
=
>
{
outputs
.
add
(
this
.
roundAndFlushVectorToInterval
(
inner_x
op
)
)
;
}
)
;
const
result
=
this
.
spanIntervals
(
.
.
.
outputs
)
;
return
result
.
isFinite
(
)
?
result
:
this
.
constants
(
)
.
unboundedInterval
;
}
runVectorPairToIntervalOp
(
x
y
op
)
{
if
(
x
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
|
|
y
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
)
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
const
x_values
=
cartesianProduct
(
.
.
.
x
.
map
(
(
e
)
=
>
e
.
endpoints
(
)
)
)
;
const
y_values
=
cartesianProduct
(
.
.
.
y
.
map
(
(
e
)
=
>
e
.
endpoints
(
)
)
)
;
const
outputs
=
new
Set
(
)
;
x_values
.
forEach
(
(
inner_x
)
=
>
{
y_values
.
forEach
(
(
inner_y
)
=
>
{
outputs
.
add
(
this
.
roundAndFlushVectorPairToInterval
(
inner_x
inner_y
op
)
)
;
}
)
;
}
)
;
const
result
=
this
.
spanIntervals
(
.
.
.
outputs
)
;
return
result
.
isFinite
(
)
?
result
:
this
.
constants
(
)
.
unboundedInterval
;
}
runVectorToVectorOp
(
x
op
)
{
if
(
x
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
)
{
return
this
.
constants
(
)
.
unboundedVector
[
x
.
length
]
;
}
const
x_values
=
cartesianProduct
(
.
.
.
x
.
map
(
(
e
)
=
>
e
.
endpoints
(
)
)
)
;
const
outputs
=
new
Set
(
)
;
x_values
.
forEach
(
(
inner_x
)
=
>
{
outputs
.
add
(
this
.
roundAndFlushVectorToVector
(
inner_x
op
)
)
;
}
)
;
const
result
=
this
.
spanVectors
(
.
.
.
outputs
)
;
return
result
.
every
(
(
e
)
=
>
e
.
isFinite
(
)
)
?
result
:
this
.
constants
(
)
.
unboundedVector
[
result
.
length
]
;
}
runScalarToIntervalOpComponentWise
(
x
op
)
{
return
this
.
toVector
(
x
.
map
(
(
e
)
=
>
this
.
runScalarToIntervalOp
(
e
op
)
)
)
;
}
runVectorPairToVectorOp
(
x
y
op
)
{
if
(
x
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
|
|
y
.
some
(
(
e
)
=
>
!
e
.
isFinite
(
)
)
)
{
return
this
.
constants
(
)
.
unboundedVector
[
x
.
length
]
;
}
const
x_values
=
cartesianProduct
(
.
.
.
x
.
map
(
(
e
)
=
>
e
.
endpoints
(
)
)
)
;
const
y_values
=
cartesianProduct
(
.
.
.
y
.
map
(
(
e
)
=
>
e
.
endpoints
(
)
)
)
;
const
outputs
=
new
Set
(
)
;
x_values
.
forEach
(
(
inner_x
)
=
>
{
y_values
.
forEach
(
(
inner_y
)
=
>
{
outputs
.
add
(
this
.
roundAndFlushVectorPairToVector
(
inner_x
inner_y
op
)
)
;
}
)
;
}
)
;
const
result
=
this
.
spanVectors
(
.
.
.
outputs
)
;
return
result
.
every
(
(
e
)
=
>
e
.
isFinite
(
)
)
?
result
:
this
.
constants
(
)
.
unboundedVector
[
result
.
length
]
;
}
runScalarPairToIntervalOpVectorComponentWise
(
x
y
op
)
{
assert
(
x
.
length
=
=
=
y
.
length
runScalarPairToIntervalOpVectorComponentWise
requires
vectors
of
the
same
dimensions
)
;
return
this
.
toVector
(
x
.
map
(
(
i
idx
)
=
>
{
return
this
.
runScalarPairToIntervalOp
(
i
y
[
idx
]
op
)
;
}
)
)
;
}
runMatrixToMatrixOp
(
m
op
)
{
const
num_cols
=
m
.
length
;
const
num_rows
=
m
[
0
]
.
length
;
const
m_flat
=
flatten2DArray
(
m
)
;
const
m_values
=
cartesianProduct
(
.
.
.
m_flat
.
map
(
(
e
)
=
>
e
.
endpoints
(
)
)
)
;
const
outputs
=
new
Set
(
)
;
m_values
.
forEach
(
(
inner_m
)
=
>
{
const
unflat_m
=
unflatten2DArray
(
inner_m
num_cols
num_rows
)
;
outputs
.
add
(
this
.
roundAndFlushMatrixToMatrix
(
unflat_m
op
)
)
;
}
)
;
const
result
=
this
.
spanMatrices
(
.
.
.
outputs
)
;
const
result_cols
=
result
.
length
;
const
result_rows
=
result
[
0
]
.
length
;
return
result
.
every
(
(
c
)
=
>
c
.
every
(
(
r
)
=
>
r
.
isFinite
(
)
)
)
?
result
:
this
.
constants
(
)
.
unboundedMatrix
[
result_cols
]
[
result_rows
]
;
}
runScalarPairToIntervalOpScalarMatrixComponentWise
(
i
m
op
)
{
const
cols
=
m
.
length
;
const
rows
=
m
[
0
]
.
length
;
return
this
.
toMatrix
(
unflatten2DArray
(
flatten2DArray
(
m
)
.
map
(
(
e
)
=
>
this
.
runScalarPairToIntervalOp
(
i
e
op
)
)
cols
rows
)
)
;
}
runScalarPairToIntervalOpMatrixMatrixComponentWise
(
x
y
op
)
{
assert
(
x
.
length
=
=
=
y
.
length
&
&
x
[
0
]
.
length
=
=
=
y
[
0
]
.
length
runScalarPairToIntervalOpMatrixMatrixComponentWise
requires
matrices
of
the
same
dimensions
)
;
const
cols
=
x
.
length
;
const
rows
=
x
[
0
]
.
length
;
const
flat_x
=
flatten2DArray
(
x
)
;
const
flat_y
=
flatten2DArray
(
y
)
;
return
this
.
toMatrix
(
unflatten2DArray
(
flat_x
.
map
(
(
i
idx
)
=
>
{
return
this
.
runScalarPairToIntervalOp
(
i
flat_y
[
idx
]
op
)
;
}
)
cols
rows
)
)
;
}
AbsoluteErrorIntervalOp
(
error_range
)
{
const
op
=
{
impl
:
(
_
)
=
>
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
}
;
assert
(
error_range
>
=
0
absoluteErrorInterval
must
have
non
-
negative
error
range
get
{
error_range
}
)
;
if
(
this
.
isFinite
(
error_range
)
)
{
op
.
impl
=
(
n
)
=
>
{
assert
(
!
Number
.
isNaN
(
n
)
absolute
error
not
defined
for
NaN
)
;
if
(
!
this
.
isFinite
(
n
)
)
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
return
this
.
toInterval
(
[
n
-
error_range
n
+
error_range
]
)
;
}
;
}
return
op
;
}
absoluteErrorIntervalImpl
(
n
error_range
)
{
error_range
=
Math
.
abs
(
error_range
)
;
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
AbsoluteErrorIntervalOp
(
error_range
)
)
;
}
CorrectlyRoundedIntervalOp
=
{
impl
:
(
n
)
=
>
{
assert
(
!
Number
.
isNaN
(
n
)
absolute
not
defined
for
NaN
)
;
return
this
.
toInterval
(
n
)
;
}
}
;
correctlyRoundedIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
CorrectlyRoundedIntervalOp
)
;
}
correctlyRoundedMatrixImpl
(
m
)
{
return
this
.
toMatrix
(
map2DArray
(
m
this
.
correctlyRoundedInterval
)
)
;
}
ULPIntervalOp
(
numULP
)
{
const
op
=
{
impl
:
(
_
)
=
>
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
}
;
if
(
this
.
isFinite
(
numULP
)
)
{
op
.
impl
=
(
n
)
=
>
{
assert
(
!
Number
.
isNaN
(
n
)
ULP
error
not
defined
for
NaN
)
;
const
ulp
=
this
.
oneULP
(
n
)
;
const
begin
=
n
-
numULP
*
ulp
;
const
end
=
n
+
numULP
*
ulp
;
return
this
.
toInterval
(
[
Math
.
min
(
begin
this
.
flushSubnormal
(
begin
)
)
Math
.
max
(
end
this
.
flushSubnormal
(
end
)
)
]
)
;
}
;
}
return
op
;
}
ulpIntervalImpl
(
n
numULP
)
{
numULP
=
Math
.
abs
(
numULP
)
;
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
ULPIntervalOp
(
numULP
)
)
;
}
AbsIntervalOp
=
{
impl
:
(
n
)
=
>
{
return
this
.
correctlyRoundedInterval
(
Math
.
abs
(
n
)
)
;
}
}
;
absIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
AbsIntervalOp
)
;
}
AcosIntervalOp
=
{
impl
:
(
n
)
=
>
{
assert
(
this
.
kind
=
=
=
'
f32
'
|
|
this
.
kind
=
=
=
'
f16
'
)
;
const
y
=
this
.
sqrtInterval
(
this
.
subtractionInterval
(
1
this
.
multiplicationInterval
(
n
n
)
)
)
;
const
approx_abs_error
=
this
.
kind
=
=
=
'
f32
'
?
6
.
77e
-
5
:
3
.
91e
-
3
;
return
this
.
spanIntervals
(
this
.
atan2Interval
(
y
n
)
this
.
absoluteErrorInterval
(
Math
.
acos
(
n
)
approx_abs_error
)
)
;
}
domain
:
(
)
=
>
{
return
this
.
constants
(
)
.
negOneToOneInterval
;
}
}
;
acosIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
AcosIntervalOp
)
;
}
AcoshAlternativeIntervalOp
=
{
impl
:
(
x
)
=
>
{
const
inner_value
=
this
.
multiplicationInterval
(
this
.
additionInterval
(
x
1
.
0
)
this
.
subtractionInterval
(
x
1
.
0
)
)
;
const
sqrt_value
=
this
.
sqrtInterval
(
inner_value
)
;
return
this
.
logInterval
(
this
.
additionInterval
(
x
sqrt_value
)
)
;
}
}
;
acoshAlternativeIntervalImpl
(
x
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
x
)
this
.
AcoshAlternativeIntervalOp
)
;
}
AcoshPrimaryIntervalOp
=
{
impl
:
(
x
)
=
>
{
const
inner_value
=
this
.
subtractionInterval
(
this
.
multiplicationInterval
(
x
x
)
1
.
0
)
;
const
sqrt_value
=
this
.
sqrtInterval
(
inner_value
)
;
return
this
.
logInterval
(
this
.
additionInterval
(
x
sqrt_value
)
)
;
}
}
;
acoshPrimaryIntervalImpl
(
x
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
x
)
this
.
AcoshPrimaryIntervalOp
)
;
}
AdditionIntervalOp
=
{
impl
:
(
x
y
)
=
>
{
const
sum
=
x
+
y
;
const
large_val
=
Math
.
abs
(
x
)
>
Math
.
abs
(
y
)
?
x
:
y
;
const
small_val
=
Math
.
abs
(
x
)
>
Math
.
abs
(
y
)
?
y
:
x
;
return
this
.
correctlyRoundedIntervalWithUnboundedPrecisionForAddition
(
sum
large_val
small_val
)
;
}
}
;
additionIntervalImpl
(
x
y
)
{
return
this
.
runScalarPairToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
AdditionIntervalOp
)
;
}
additionMatrixMatrixIntervalImpl
(
x
y
)
{
return
this
.
runScalarPairToIntervalOpMatrixMatrixComponentWise
(
this
.
toMatrix
(
x
)
this
.
toMatrix
(
y
)
this
.
AdditionIntervalOp
)
;
}
AsinIntervalOp
=
{
impl
:
(
n
)
=
>
{
assert
(
this
.
kind
=
=
=
'
f32
'
|
|
this
.
kind
=
=
=
'
f16
'
)
;
const
x
=
this
.
sqrtInterval
(
this
.
subtractionInterval
(
1
this
.
multiplicationInterval
(
n
n
)
)
)
;
const
approx_abs_error
=
this
.
kind
=
=
=
'
f32
'
?
6
.
81e
-
5
:
3
.
91e
-
3
;
return
this
.
spanIntervals
(
this
.
atan2Interval
(
n
x
)
this
.
absoluteErrorInterval
(
Math
.
asin
(
n
)
approx_abs_error
)
)
;
}
domain
:
(
)
=
>
{
return
this
.
constants
(
)
.
negOneToOneInterval
;
}
}
;
asinIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
AsinIntervalOp
)
;
}
AsinhIntervalOp
=
{
impl
:
(
x
)
=
>
{
const
inner_value
=
this
.
additionInterval
(
this
.
multiplicationInterval
(
x
x
)
1
.
0
)
;
const
sqrt_value
=
this
.
sqrtInterval
(
inner_value
)
;
return
this
.
logInterval
(
this
.
additionInterval
(
x
sqrt_value
)
)
;
}
}
;
asinhIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
AsinhIntervalOp
)
;
}
AtanIntervalOp
=
{
impl
:
(
n
)
=
>
{
assert
(
this
.
kind
=
=
=
'
f32
'
|
|
this
.
kind
=
=
=
'
f16
'
)
;
const
ulp_error
=
this
.
kind
=
=
=
'
f32
'
?
4096
:
5
;
return
this
.
ulpInterval
(
Math
.
atan
(
n
)
ulp_error
)
;
}
}
;
atanIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
AtanIntervalOp
)
;
}
Atan2IntervalOpBuilder
(
)
{
assert
(
this
.
kind
=
=
=
'
f32
'
|
|
this
.
kind
=
=
=
'
f16
'
)
;
const
constants
=
this
.
constants
(
)
;
const
domain_x
=
[
this
.
toInterval
(
[
constants
.
negative
.
min
constants
.
negative
.
max
]
)
this
.
toInterval
(
[
constants
.
positive
.
min
constants
.
positive
.
max
]
)
]
;
const
domain_y
=
this
.
kind
=
=
=
'
f32
'
?
[
this
.
toInterval
(
[
-
(
2
*
*
126
)
-
(
2
*
*
-
126
)
]
)
this
.
toInterval
(
[
2
*
*
-
126
2
*
*
126
]
)
]
:
[
this
.
toInterval
(
[
-
(
2
*
*
14
)
-
(
2
*
*
-
14
)
]
)
this
.
toInterval
(
[
2
*
*
-
14
2
*
*
14
]
)
]
;
const
ulp_error
=
this
.
kind
=
=
=
'
f32
'
?
4096
:
5
;
return
{
impl
:
(
y
x
)
=
>
{
let
atan_yx
=
Math
.
atan
(
y
/
x
)
;
if
(
x
<
0
)
{
if
(
y
>
0
)
{
atan_yx
=
atan_yx
+
kValue
.
f64
.
positive
.
pi
.
whole
;
}
else
{
atan_yx
=
atan_yx
-
kValue
.
f64
.
positive
.
pi
.
whole
;
}
}
return
this
.
ulpInterval
(
atan_yx
ulp_error
)
;
}
extrema
:
(
y
x
)
=
>
{
if
(
y
.
contains
(
0
)
)
{
if
(
x
.
contains
(
0
)
)
{
return
[
this
.
toInterval
(
0
)
this
.
toInterval
(
0
)
]
;
}
return
[
this
.
toInterval
(
0
)
x
]
;
}
return
[
y
x
]
;
}
domain
:
(
)
=
>
{
return
{
x
:
domain_x
y
:
domain_y
}
;
}
}
;
}
atan2IntervalImpl
(
y
x
)
{
return
this
.
runScalarPairToIntervalOp
(
this
.
toInterval
(
y
)
this
.
toInterval
(
x
)
this
.
Atan2IntervalOpBuilder
(
)
)
;
}
AtanhIntervalOp
=
{
impl
:
(
n
)
=
>
{
const
numerator
=
this
.
additionInterval
(
1
.
0
n
)
;
const
denominator
=
this
.
subtractionInterval
(
1
.
0
n
)
;
const
log_interval
=
this
.
logInterval
(
this
.
divisionInterval
(
numerator
denominator
)
)
;
return
this
.
multiplicationInterval
(
log_interval
0
.
5
)
;
}
}
;
atanhIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
AtanhIntervalOp
)
;
}
CeilIntervalOp
=
{
impl
:
(
n
)
=
>
{
return
this
.
correctlyRoundedInterval
(
Math
.
ceil
(
n
)
)
;
}
}
;
ceilIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
CeilIntervalOp
)
;
}
ClampMedianIntervalOp
=
{
impl
:
(
x
y
z
)
=
>
{
return
this
.
correctlyRoundedInterval
(
[
x
y
z
]
.
sort
(
(
a
b
)
=
>
{
if
(
a
<
b
)
{
return
-
1
;
}
if
(
a
>
b
)
{
return
1
;
}
return
0
;
}
)
[
1
]
)
;
}
}
;
clampMedianIntervalImpl
(
x
y
z
)
{
return
this
.
runScalarTripleToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
toInterval
(
z
)
this
.
ClampMedianIntervalOp
)
;
}
ClampMinMaxIntervalOp
=
{
impl
:
(
x
low
high
)
=
>
{
return
this
.
minInterval
(
this
.
maxInterval
(
x
low
)
high
)
;
}
}
;
clampMinMaxIntervalImpl
(
x
low
high
)
{
return
this
.
runScalarTripleToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
low
)
this
.
toInterval
(
high
)
this
.
ClampMinMaxIntervalOp
)
;
}
CosIntervalOp
=
{
impl
:
(
n
)
=
>
{
assert
(
this
.
kind
=
=
=
'
f32
'
|
|
this
.
kind
=
=
=
'
f16
'
)
;
const
abs_error
=
this
.
kind
=
=
=
'
f32
'
?
2
*
*
-
11
:
2
*
*
-
7
;
return
this
.
absoluteErrorInterval
(
Math
.
cos
(
n
)
abs_error
)
;
}
domain
:
(
)
=
>
{
return
this
.
constants
(
)
.
negPiToPiInterval
;
}
}
;
cosIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
CosIntervalOp
)
;
}
CoshIntervalOp
=
{
impl
:
(
n
)
=
>
{
const
minus_n
=
this
.
negationInterval
(
n
)
;
return
this
.
multiplicationInterval
(
this
.
additionInterval
(
this
.
expInterval
(
n
)
this
.
expInterval
(
minus_n
)
)
0
.
5
)
;
}
}
;
coshIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
CoshIntervalOp
)
;
}
CrossIntervalOp
=
{
impl
:
(
x
y
)
=
>
{
assert
(
x
.
length
=
=
=
3
CrossIntervalOp
received
x
with
{
x
.
length
}
instead
of
3
)
;
assert
(
y
.
length
=
=
=
3
CrossIntervalOp
received
y
with
{
y
.
length
}
instead
of
3
)
;
const
r0
=
this
.
subtractionInterval
(
this
.
multiplicationInterval
(
x
[
1
]
y
[
2
]
)
this
.
multiplicationInterval
(
x
[
2
]
y
[
1
]
)
)
;
const
r1
=
this
.
subtractionInterval
(
this
.
multiplicationInterval
(
x
[
2
]
y
[
0
]
)
this
.
multiplicationInterval
(
x
[
0
]
y
[
2
]
)
)
;
const
r2
=
this
.
subtractionInterval
(
this
.
multiplicationInterval
(
x
[
0
]
y
[
1
]
)
this
.
multiplicationInterval
(
x
[
1
]
y
[
0
]
)
)
;
if
(
r0
.
isFinite
(
)
&
&
r1
.
isFinite
(
)
&
&
r2
.
isFinite
(
)
)
{
return
[
r0
r1
r2
]
;
}
return
this
.
constants
(
)
.
unboundedVector
[
3
]
;
}
}
;
crossIntervalImpl
(
x
y
)
{
assert
(
x
.
length
=
=
=
3
Cross
is
only
defined
for
vec3
)
;
assert
(
y
.
length
=
=
=
3
Cross
is
only
defined
for
vec3
)
;
return
this
.
runVectorPairToVectorOp
(
this
.
toVector
(
x
)
this
.
toVector
(
y
)
this
.
CrossIntervalOp
)
;
}
DegreesIntervalOp
=
{
impl
:
(
n
)
=
>
{
return
this
.
multiplicationInterval
(
n
57
.
295779513082322865
)
;
}
}
;
degreesIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
DegreesIntervalOp
)
;
}
minorNxN
(
m
col
row
)
{
const
dim
=
m
.
length
;
assert
(
m
.
length
=
=
=
m
[
0
]
.
length
minorMatrix
is
only
defined
for
square
matrices
)
;
assert
(
col
>
=
0
&
&
col
<
dim
col
{
col
}
needs
be
in
[
0
#
of
columns
'
{
dim
}
'
)
)
;
assert
(
row
>
=
0
&
&
row
<
dim
row
{
row
}
needs
be
in
[
0
#
of
rows
'
{
dim
}
'
)
)
;
const
result
=
[
.
.
.
Array
(
dim
-
1
)
]
.
map
(
(
_
)
=
>
[
.
.
.
Array
(
dim
-
1
)
]
)
;
const
col_indices
=
[
.
.
.
Array
(
dim
)
.
keys
(
)
]
.
filter
(
(
e
)
=
>
e
!
=
=
col
)
;
const
row_indices
=
[
.
.
.
Array
(
dim
)
.
keys
(
)
]
.
filter
(
(
e
)
=
>
e
!
=
=
row
)
;
col_indices
.
forEach
(
(
c
i
)
=
>
{
row_indices
.
forEach
(
(
r
j
)
=
>
{
result
[
i
]
[
j
]
=
m
[
c
]
[
r
]
;
}
)
;
}
)
;
return
result
;
}
determinant2x2Interval
(
m
)
{
assert
(
m
.
length
=
=
=
m
[
0
]
.
length
&
&
m
.
length
=
=
=
2
determinant2x2Interval
called
on
non
-
2x2
matrix
)
;
return
this
.
subtractionInterval
(
this
.
multiplicationInterval
(
m
[
0
]
[
0
]
m
[
1
]
[
1
]
)
this
.
multiplicationInterval
(
m
[
0
]
[
1
]
m
[
1
]
[
0
]
)
)
;
}
determinant3x3Interval
(
m
)
{
assert
(
m
.
length
=
=
=
m
[
0
]
.
length
&
&
m
.
length
=
=
=
3
determinant3x3Interval
called
on
non
-
3x3
matrix
)
;
const
A
=
this
.
multiplicationInterval
(
m
[
0
]
[
0
]
this
.
determinant2x2Interval
(
this
.
minorNxN
(
m
0
0
)
)
)
;
const
B
=
this
.
multiplicationInterval
(
-
m
[
0
]
[
1
]
this
.
determinant2x2Interval
(
this
.
minorNxN
(
m
0
1
)
)
)
;
const
C
=
this
.
multiplicationInterval
(
m
[
0
]
[
2
]
this
.
determinant2x2Interval
(
this
.
minorNxN
(
m
0
2
)
)
)
;
const
permutations
=
calculatePermutations
(
[
A
B
C
]
)
;
return
this
.
spanIntervals
(
.
.
.
permutations
.
map
(
(
p
)
=
>
p
.
reduce
(
(
prev
cur
)
=
>
this
.
additionInterval
(
prev
cur
)
)
)
)
;
}
determinant4x4Interval
(
m
)
{
assert
(
m
.
length
=
=
=
m
[
0
]
.
length
&
&
m
.
length
=
=
=
4
determinant3x3Interval
called
on
non
-
4x4
matrix
)
;
const
A
=
this
.
multiplicationInterval
(
m
[
0
]
[
0
]
this
.
determinant3x3Interval
(
this
.
minorNxN
(
m
0
0
)
)
)
;
const
B
=
this
.
multiplicationInterval
(
-
m
[
0
]
[
1
]
this
.
determinant3x3Interval
(
this
.
minorNxN
(
m
0
1
)
)
)
;
const
C
=
this
.
multiplicationInterval
(
m
[
0
]
[
2
]
this
.
determinant3x3Interval
(
this
.
minorNxN
(
m
0
2
)
)
)
;
const
D
=
this
.
multiplicationInterval
(
-
m
[
0
]
[
3
]
this
.
determinant3x3Interval
(
this
.
minorNxN
(
m
0
3
)
)
)
;
const
permutations
=
calculatePermutations
(
[
A
B
C
D
]
)
;
return
this
.
spanIntervals
(
.
.
.
permutations
.
map
(
(
p
)
=
>
p
.
reduce
(
(
prev
cur
)
=
>
this
.
additionInterval
(
prev
cur
)
)
)
)
;
}
determinantIntervalImpl
(
x
)
{
const
dim
=
x
.
length
;
assert
(
x
[
0
]
.
length
=
=
=
dim
&
&
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
)
determinantInterval
only
defined
for
2x2
3x3
and
4x4
matrices
)
;
switch
(
dim
)
{
case
2
:
return
this
.
determinant2x2Interval
(
x
)
;
case
3
:
return
this
.
determinant3x3Interval
(
x
)
;
case
4
:
return
this
.
determinant4x4Interval
(
x
)
;
}
unreachable
(
"
determinantInterval
called
on
x
where
which
has
an
unexpected
dimension
of
'
{
dim
}
'
"
)
;
}
DistanceIntervalScalarOp
=
{
impl
:
(
x
y
)
=
>
{
return
this
.
lengthInterval
(
this
.
subtractionInterval
(
x
y
)
)
;
}
}
;
DistanceIntervalVectorOp
=
{
impl
:
(
x
y
)
=
>
{
return
this
.
lengthInterval
(
this
.
runScalarPairToIntervalOpVectorComponentWise
(
this
.
toVector
(
x
)
this
.
toVector
(
y
)
this
.
SubtractionIntervalOp
)
)
;
}
}
;
distanceIntervalImpl
(
x
y
)
{
if
(
x
instanceof
Array
&
&
y
instanceof
Array
)
{
assert
(
x
.
length
=
=
=
y
.
length
distanceInterval
requires
both
params
to
have
the
same
number
of
elements
)
;
return
this
.
runVectorPairToIntervalOp
(
this
.
toVector
(
x
)
this
.
toVector
(
y
)
this
.
DistanceIntervalVectorOp
)
;
}
else
if
(
!
(
x
instanceof
Array
)
&
&
!
(
y
instanceof
Array
)
)
{
return
this
.
runScalarPairToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
DistanceIntervalScalarOp
)
;
}
unreachable
(
distanceInterval
requires
both
params
to
both
the
same
type
either
scalars
or
vectors
)
;
}
DivisionIntervalOpBuilder
(
)
{
const
constants
=
this
.
constants
(
)
;
const
domain_x
=
[
this
.
toInterval
(
[
constants
.
negative
.
min
constants
.
positive
.
max
]
)
]
;
const
domain_y
=
this
.
kind
=
=
=
'
f32
'
|
|
this
.
kind
=
=
=
'
abstract
'
?
[
this
.
toInterval
(
[
-
(
2
*
*
126
)
-
(
2
*
*
-
126
)
]
)
this
.
toInterval
(
[
2
*
*
-
126
2
*
*
126
]
)
]
:
[
this
.
toInterval
(
[
-
(
2
*
*
14
)
-
(
2
*
*
-
14
)
]
)
this
.
toInterval
(
[
2
*
*
-
14
2
*
*
14
]
)
]
;
return
{
impl
:
(
x
y
)
=
>
{
if
(
y
=
=
=
0
)
{
return
constants
.
unboundedInterval
;
}
return
this
.
ulpInterval
(
x
/
y
2
.
5
)
;
}
extrema
:
(
x
y
)
=
>
{
if
(
y
.
contains
(
0
)
)
{
y
=
this
.
toInterval
(
0
)
;
}
return
[
x
y
]
;
}
domain
:
(
)
=
>
{
return
{
x
:
domain_x
y
:
domain_y
}
;
}
}
;
}
divisionIntervalImpl
(
x
y
)
{
return
this
.
runScalarPairToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
DivisionIntervalOpBuilder
(
)
)
;
}
DotIntervalOp
=
{
impl
:
(
x
y
)
=
>
{
const
multiplications
=
this
.
runScalarPairToIntervalOpVectorComponentWise
(
this
.
toVector
(
x
)
this
.
toVector
(
y
)
this
.
MultiplicationIntervalOp
)
;
if
(
multiplications
.
length
=
=
=
2
)
{
return
this
.
additionInterval
(
multiplications
[
0
]
multiplications
[
1
]
)
;
}
const
permutations
=
calculatePermutations
(
multiplications
)
;
return
this
.
spanIntervals
(
.
.
.
permutations
.
map
(
(
p
)
=
>
p
.
reduce
(
(
prev
cur
)
=
>
this
.
additionInterval
(
prev
cur
)
)
)
)
;
}
}
;
dotIntervalImpl
(
x
y
)
{
assert
(
x
.
length
=
=
=
y
.
length
dot
not
defined
for
vectors
with
different
lengths
x
=
{
x
}
y
=
{
y
}
)
;
return
this
.
runVectorPairToIntervalOp
(
this
.
toVector
(
x
)
this
.
toVector
(
y
)
this
.
DotIntervalOp
)
;
}
ExpIntervalOp
=
{
impl
:
(
n
)
=
>
{
assert
(
this
.
kind
=
=
=
'
f32
'
|
|
this
.
kind
=
=
=
'
f16
'
)
;
const
ulp_error
=
this
.
kind
=
=
=
'
f32
'
?
3
+
2
*
Math
.
abs
(
n
)
:
1
+
2
*
Math
.
abs
(
n
)
;
return
this
.
ulpInterval
(
Math
.
exp
(
n
)
ulp_error
)
;
}
}
;
expIntervalImpl
(
x
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
x
)
this
.
ExpIntervalOp
)
;
}
Exp2IntervalOp
=
{
impl
:
(
n
)
=
>
{
assert
(
this
.
kind
=
=
=
'
f32
'
|
|
this
.
kind
=
=
=
'
f16
'
)
;
const
ulp_error
=
this
.
kind
=
=
=
'
f32
'
?
3
+
2
*
Math
.
abs
(
n
)
:
1
+
2
*
Math
.
abs
(
n
)
;
return
this
.
ulpInterval
(
Math
.
pow
(
2
n
)
ulp_error
)
;
}
}
;
exp2IntervalImpl
(
x
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
x
)
this
.
Exp2IntervalOp
)
;
}
faceForwardIntervalsImpl
(
x
y
z
)
{
const
x_vec
=
this
.
toVector
(
x
)
;
const
positive_x
=
this
.
runScalarToIntervalOpComponentWise
(
x_vec
{
impl
:
(
i
)
=
>
{
return
this
.
toInterval
(
i
)
;
}
}
)
;
const
negative_x
=
this
.
runScalarToIntervalOpComponentWise
(
x_vec
this
.
NegationIntervalOp
)
;
const
dot_interval
=
this
.
dotInterval
(
z
y
)
;
const
results
=
[
]
;
if
(
!
dot_interval
.
isFinite
(
)
)
{
results
.
push
(
undefined
)
;
}
if
(
dot_interval
.
begin
<
0
|
|
dot_interval
.
end
<
0
)
{
results
.
push
(
positive_x
)
;
}
if
(
dot_interval
.
begin
>
=
0
|
|
dot_interval
.
end
>
=
0
)
{
results
.
push
(
negative_x
)
;
}
assert
(
results
.
length
>
0
|
|
results
.
every
(
(
r
)
=
>
r
=
=
=
undefined
)
faceForwardInterval
selected
neither
positive
x
or
negative
x
for
the
result
this
shouldn
'
t
be
possible
)
;
return
results
;
}
FloorIntervalOp
=
{
impl
:
(
n
)
=
>
{
return
this
.
correctlyRoundedInterval
(
Math
.
floor
(
n
)
)
;
}
}
;
floorIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
FloorIntervalOp
)
;
}
FmaIntervalOp
=
{
impl
:
(
x
y
z
)
=
>
{
return
this
.
additionInterval
(
this
.
multiplicationInterval
(
x
y
)
z
)
;
}
}
;
fmaIntervalImpl
(
x
y
z
)
{
return
this
.
runScalarTripleToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
toInterval
(
z
)
this
.
FmaIntervalOp
)
;
}
FractIntervalOp
=
{
impl
:
(
n
)
=
>
{
const
result
=
this
.
subtractionInterval
(
n
this
.
floorInterval
(
n
)
)
;
assert
(
this
.
toInterval
(
[
this
.
constants
(
)
.
negative
.
subnormal
.
min
1
.
0
]
)
.
contains
(
result
)
fract
(
{
n
}
)
interval
[
{
result
}
]
unexpectedly
extends
beyond
[
~
0
.
0
1
.
0
]
)
;
if
(
result
.
contains
(
1
)
)
{
return
this
.
spanIntervals
(
result
this
.
toInterval
(
this
.
constants
(
)
.
positive
.
less_than_one
)
)
;
}
return
result
;
}
}
;
fractIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
FractIntervalOp
)
;
}
InverseSqrtIntervalOp
=
{
impl
:
(
n
)
=
>
{
return
this
.
ulpInterval
(
1
/
Math
.
sqrt
(
n
)
2
)
;
}
domain
:
(
)
=
>
{
return
this
.
constants
(
)
.
greaterThanZeroInterval
;
}
}
;
inverseSqrtIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
InverseSqrtIntervalOp
)
;
}
LdexpIntervalOp
=
{
impl
:
(
e1
e2
)
=
>
{
assert
(
Number
.
isInteger
(
e2
)
'
the
second
param
of
ldexp
must
be
an
integer
'
)
;
if
(
e2
>
this
.
constants
(
)
.
bias
+
1
)
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
const
result
=
e1
*
2
*
*
e2
;
if
(
!
Number
.
isFinite
(
result
)
)
{
return
this
.
constants
(
)
.
unboundedInterval
;
}
return
this
.
correctlyRoundedInterval
(
result
)
;
}
}
;
ldexpIntervalImpl
(
e1
e2
)
{
return
this
.
roundAndFlushScalarToInterval
(
e1
{
impl
:
(
e1
)
=
>
this
.
LdexpIntervalOp
.
impl
(
e1
e2
)
}
)
;
}
LengthIntervalScalarOp
=
{
impl
:
(
n
)
=
>
{
return
this
.
sqrtInterval
(
this
.
multiplicationInterval
(
n
n
)
)
;
}
}
;
LengthIntervalVectorOp
=
{
impl
:
(
n
)
=
>
{
return
this
.
sqrtInterval
(
this
.
dotInterval
(
n
n
)
)
;
}
}
;
lengthIntervalImpl
(
n
)
{
if
(
n
instanceof
Array
)
{
return
this
.
runVectorToIntervalOp
(
this
.
toVector
(
n
)
this
.
LengthIntervalVectorOp
)
;
}
else
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
LengthIntervalScalarOp
)
;
}
}
LogIntervalOp
=
{
impl
:
(
n
)
=
>
{
assert
(
this
.
kind
=
=
=
'
f32
'
|
|
this
.
kind
=
=
=
'
f16
'
)
;
const
abs_error
=
this
.
kind
=
=
=
'
f32
'
?
2
*
*
-
21
:
2
*
*
-
7
;
if
(
n
>
=
0
.
5
&
&
n
<
=
2
.
0
)
{
return
this
.
absoluteErrorInterval
(
Math
.
log
(
n
)
abs_error
)
;
}
return
this
.
ulpInterval
(
Math
.
log
(
n
)
3
)
;
}
domain
:
(
)
=
>
{
return
this
.
constants
(
)
.
greaterThanZeroInterval
;
}
}
;
logIntervalImpl
(
x
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
x
)
this
.
LogIntervalOp
)
;
}
Log2IntervalOp
=
{
impl
:
(
n
)
=
>
{
assert
(
this
.
kind
=
=
=
'
f32
'
|
|
this
.
kind
=
=
=
'
f16
'
)
;
const
abs_error
=
this
.
kind
=
=
=
'
f32
'
?
2
*
*
-
21
:
2
*
*
-
7
;
if
(
n
>
=
0
.
5
&
&
n
<
=
2
.
0
)
{
return
this
.
absoluteErrorInterval
(
Math
.
log2
(
n
)
abs_error
)
;
}
return
this
.
ulpInterval
(
Math
.
log2
(
n
)
3
)
;
}
domain
:
(
)
=
>
{
return
this
.
constants
(
)
.
greaterThanZeroInterval
;
}
}
;
log2IntervalImpl
(
x
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
x
)
this
.
Log2IntervalOp
)
;
}
MaxIntervalOp
=
{
impl
:
(
x
y
)
=
>
{
if
(
this
.
isSubnormal
(
x
)
&
&
this
.
isSubnormal
(
y
)
)
{
return
this
.
correctlyRoundedInterval
(
this
.
spanIntervals
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
)
)
;
}
return
this
.
correctlyRoundedInterval
(
Math
.
max
(
x
y
)
)
;
}
}
;
maxIntervalImpl
(
x
y
)
{
return
this
.
runScalarPairToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
MaxIntervalOp
)
;
}
MinIntervalOp
=
{
impl
:
(
x
y
)
=
>
{
if
(
this
.
isSubnormal
(
x
)
&
&
this
.
isSubnormal
(
y
)
)
{
return
this
.
correctlyRoundedInterval
(
this
.
spanIntervals
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
)
)
;
}
return
this
.
correctlyRoundedInterval
(
Math
.
min
(
x
y
)
)
;
}
}
;
minIntervalImpl
(
x
y
)
{
return
this
.
runScalarPairToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
MinIntervalOp
)
;
}
MixImpreciseIntervalOp
=
{
impl
:
(
x
y
z
)
=
>
{
const
t
=
this
.
multiplicationInterval
(
this
.
subtractionInterval
(
y
x
)
z
)
;
return
this
.
additionInterval
(
x
t
)
;
}
}
;
mixImpreciseIntervalImpl
(
x
y
z
)
{
return
this
.
runScalarTripleToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
toInterval
(
z
)
this
.
MixImpreciseIntervalOp
)
;
}
MixPreciseIntervalOp
=
{
impl
:
(
x
y
z
)
=
>
{
const
t
=
this
.
multiplicationInterval
(
x
this
.
subtractionInterval
(
1
.
0
z
)
)
;
const
s
=
this
.
multiplicationInterval
(
y
z
)
;
return
this
.
additionInterval
(
t
s
)
;
}
}
;
mixPreciseIntervalImpl
(
x
y
z
)
{
return
this
.
runScalarTripleToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
toInterval
(
z
)
this
.
MixPreciseIntervalOp
)
;
}
modfIntervalImpl
(
n
)
{
const
fract
=
this
.
correctlyRoundedInterval
(
n
%
1
.
0
)
;
const
whole
=
this
.
correctlyRoundedInterval
(
n
-
n
%
1
.
0
)
;
return
{
fract
whole
}
;
}
MultiplicationInnerOp
=
{
impl
:
(
x
y
)
=
>
{
return
this
.
correctlyRoundedInterval
(
x
*
y
)
;
}
}
;
MultiplicationIntervalOp
=
{
impl
:
(
x
y
)
=
>
{
return
this
.
roundAndFlushScalarPairToInterval
(
x
y
this
.
MultiplicationInnerOp
)
;
}
}
;
multiplicationIntervalImpl
(
x
y
)
{
return
this
.
runScalarPairToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
MultiplicationIntervalOp
)
;
}
multiplyVectorByScalar
(
v
c
)
{
return
this
.
toVector
(
v
.
map
(
(
x
)
=
>
this
.
multiplicationInterval
(
x
c
)
)
)
;
}
multiplicationMatrixScalarIntervalImpl
(
mat
scalar
)
{
return
this
.
runScalarPairToIntervalOpScalarMatrixComponentWise
(
this
.
toInterval
(
scalar
)
this
.
toMatrix
(
mat
)
this
.
MultiplicationIntervalOp
)
;
}
multiplicationScalarMatrixIntervalImpl
(
scalar
mat
)
{
return
this
.
multiplicationMatrixScalarInterval
(
mat
scalar
)
;
}
multiplicationMatrixMatrixIntervalImpl
(
mat_x
mat_y
)
{
const
x_cols
=
mat_x
.
length
;
const
x_rows
=
mat_x
[
0
]
.
length
;
const
y_cols
=
mat_y
.
length
;
const
y_rows
=
mat_y
[
0
]
.
length
;
assert
(
x_cols
=
=
=
y_rows
'
mat
{
x_cols
}
x
{
x_rows
}
*
mat
{
y_cols
}
x
{
y_rows
}
'
is
not
defined
)
;
const
x_transposed
=
this
.
transposeInterval
(
mat_x
)
;
let
oob_result
=
false
;
const
result
=
[
.
.
.
Array
(
y_cols
)
]
.
map
(
(
_
)
=
>
[
.
.
.
Array
(
x_rows
)
]
)
;
mat_y
.
forEach
(
(
y
i
)
=
>
{
x_transposed
.
forEach
(
(
x
j
)
=
>
{
result
[
i
]
[
j
]
=
this
.
dotInterval
(
x
y
)
;
if
(
!
oob_result
&
&
!
result
[
i
]
[
j
]
.
isFinite
(
)
)
{
oob_result
=
true
;
}
}
)
;
}
)
;
if
(
oob_result
)
{
return
this
.
constants
(
)
.
unboundedMatrix
[
result
.
length
]
[
result
[
0
]
.
length
]
;
}
return
result
;
}
multiplicationMatrixVectorIntervalImpl
(
x
y
)
{
const
cols
=
x
.
length
;
const
rows
=
x
[
0
]
.
length
;
assert
(
y
.
length
=
=
=
cols
'
mat
{
cols
}
x
{
rows
}
*
vec
{
y
.
length
}
'
is
not
defined
)
;
return
this
.
transposeInterval
(
x
)
.
map
(
(
e
)
=
>
this
.
dotInterval
(
e
y
)
)
;
}
multiplicationVectorMatrixIntervalImpl
(
x
y
)
{
const
cols
=
y
.
length
;
const
rows
=
y
[
0
]
.
length
;
assert
(
x
.
length
=
=
=
rows
'
vec
{
x
.
length
}
*
mat
{
cols
}
x
{
rows
}
'
is
not
defined
)
;
return
y
.
map
(
(
e
)
=
>
this
.
dotInterval
(
x
e
)
)
;
}
NegationIntervalOp
=
{
impl
:
(
n
)
=
>
{
return
this
.
correctlyRoundedInterval
(
-
n
)
;
}
}
;
negationIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
NegationIntervalOp
)
;
}
NormalizeIntervalOp
=
{
impl
:
(
n
)
=
>
{
const
length
=
this
.
lengthInterval
(
n
)
;
const
result
=
this
.
toVector
(
n
.
map
(
(
e
)
=
>
this
.
divisionInterval
(
e
length
)
)
)
;
if
(
result
.
some
(
(
r
)
=
>
!
r
.
isFinite
(
)
)
)
{
return
this
.
constants
(
)
.
unboundedVector
[
result
.
length
]
;
}
return
result
;
}
}
;
normalizeIntervalImpl
(
n
)
{
return
this
.
runVectorToVectorOp
(
this
.
toVector
(
n
)
this
.
NormalizeIntervalOp
)
;
}
PowIntervalOp
=
{
impl
:
(
x
y
)
=
>
{
return
this
.
exp2Interval
(
this
.
multiplicationInterval
(
y
this
.
log2Interval
(
x
)
)
)
;
}
}
;
powIntervalImpl
(
x
y
)
{
return
this
.
runScalarPairToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
PowIntervalOp
)
;
}
RadiansIntervalOp
=
{
impl
:
(
n
)
=
>
{
return
this
.
multiplicationInterval
(
n
0
.
017453292519943295474
)
;
}
}
;
radiansIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
RadiansIntervalOp
)
;
}
ReflectIntervalOp
=
{
impl
:
(
x
y
)
=
>
{
assert
(
x
.
length
=
=
=
y
.
length
ReflectIntervalOp
received
x
(
{
x
}
)
and
y
(
{
y
}
)
with
different
numbers
of
elements
)
;
const
t
=
this
.
multiplicationInterval
(
2
.
0
this
.
dotInterval
(
x
y
)
)
;
const
rhs
=
this
.
multiplyVectorByScalar
(
y
t
)
;
const
result
=
this
.
runScalarPairToIntervalOpVectorComponentWise
(
this
.
toVector
(
x
)
rhs
this
.
SubtractionIntervalOp
)
;
if
(
result
.
some
(
(
r
)
=
>
!
r
.
isFinite
(
)
)
)
{
return
this
.
constants
(
)
.
unboundedVector
[
result
.
length
]
;
}
return
result
;
}
}
;
reflectIntervalImpl
(
x
y
)
{
assert
(
x
.
length
=
=
=
y
.
length
reflect
is
only
defined
for
vectors
with
the
same
number
of
elements
)
;
return
this
.
runVectorPairToVectorOp
(
this
.
toVector
(
x
)
this
.
toVector
(
y
)
this
.
ReflectIntervalOp
)
;
}
refractIntervalImpl
(
i
s
r
)
{
assert
(
i
.
length
=
=
=
s
.
length
refract
is
only
defined
for
vectors
with
the
same
number
of
elements
)
;
const
r_squared
=
this
.
multiplicationInterval
(
r
r
)
;
const
dot
=
this
.
dotInterval
(
s
i
)
;
const
dot_squared
=
this
.
multiplicationInterval
(
dot
dot
)
;
const
one_minus_dot_squared
=
this
.
subtractionInterval
(
1
dot_squared
)
;
const
k
=
this
.
subtractionInterval
(
1
.
0
this
.
multiplicationInterval
(
r_squared
one_minus_dot_squared
)
)
;
if
(
!
k
.
isFinite
(
)
|
|
k
.
containsZeroOrSubnormals
(
)
)
{
return
this
.
constants
(
)
.
unboundedVector
[
this
.
toVector
(
i
)
.
length
]
;
}
if
(
k
.
end
<
0
.
0
)
{
return
this
.
constants
(
)
.
zeroVector
[
this
.
toVector
(
i
)
.
length
]
;
}
const
dot_times_r
=
this
.
multiplicationInterval
(
dot
r
)
;
const
k_sqrt
=
this
.
sqrtInterval
(
k
)
;
const
t
=
this
.
additionInterval
(
dot_times_r
k_sqrt
)
;
const
result
=
this
.
runScalarPairToIntervalOpVectorComponentWise
(
this
.
multiplyVectorByScalar
(
i
r
)
this
.
multiplyVectorByScalar
(
s
t
)
this
.
SubtractionIntervalOp
)
;
if
(
result
.
some
(
(
r
)
=
>
!
r
.
isFinite
(
)
)
)
{
return
this
.
constants
(
)
.
unboundedVector
[
result
.
length
]
;
}
return
result
;
}
RemainderIntervalOp
=
{
impl
:
(
x
y
)
=
>
{
return
this
.
subtractionInterval
(
x
this
.
multiplicationInterval
(
y
this
.
truncInterval
(
this
.
divisionInterval
(
x
y
)
)
)
)
;
}
}
;
remainderIntervalImpl
(
x
y
)
{
return
this
.
runScalarPairToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
RemainderIntervalOp
)
;
}
RoundIntervalOp
=
{
impl
:
(
n
)
=
>
{
const
k
=
Math
.
floor
(
n
)
;
const
diff_before
=
n
-
k
;
const
diff_after
=
k
+
1
-
n
;
if
(
diff_before
<
diff_after
)
{
return
this
.
correctlyRoundedInterval
(
k
)
;
}
else
if
(
diff_before
>
diff_after
)
{
return
this
.
correctlyRoundedInterval
(
k
+
1
)
;
}
if
(
k
%
2
=
=
=
0
)
{
return
this
.
correctlyRoundedInterval
(
k
)
;
}
return
this
.
correctlyRoundedInterval
(
k
+
1
)
;
}
}
;
roundIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
RoundIntervalOp
)
;
}
saturateIntervalImpl
(
n
)
{
return
this
.
runScalarTripleToIntervalOp
(
this
.
toInterval
(
n
)
this
.
toInterval
(
0
.
0
)
this
.
toInterval
(
1
.
0
)
this
.
ClampMinMaxIntervalOp
)
;
}
SignIntervalOp
=
{
impl
:
(
n
)
=
>
{
if
(
n
>
0
.
0
)
{
return
this
.
correctlyRoundedInterval
(
1
.
0
)
;
}
if
(
n
<
0
.
0
)
{
return
this
.
correctlyRoundedInterval
(
-
1
.
0
)
;
}
return
this
.
correctlyRoundedInterval
(
0
.
0
)
;
}
}
;
signIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
SignIntervalOp
)
;
}
SinIntervalOp
=
{
impl
:
(
n
)
=
>
{
assert
(
this
.
kind
=
=
=
'
f32
'
|
|
this
.
kind
=
=
=
'
f16
'
)
;
const
abs_error
=
this
.
kind
=
=
=
'
f32
'
?
2
*
*
-
11
:
2
*
*
-
7
;
return
this
.
absoluteErrorInterval
(
Math
.
sin
(
n
)
abs_error
)
;
}
domain
:
(
)
=
>
{
return
this
.
constants
(
)
.
negPiToPiInterval
;
}
}
;
sinIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
SinIntervalOp
)
;
}
SinhIntervalOp
=
{
impl
:
(
n
)
=
>
{
const
minus_n
=
this
.
negationInterval
(
n
)
;
return
this
.
multiplicationInterval
(
this
.
subtractionInterval
(
this
.
expInterval
(
n
)
this
.
expInterval
(
minus_n
)
)
0
.
5
)
;
}
}
;
sinhIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
SinhIntervalOp
)
;
}
SmoothStepOp
=
{
impl
:
(
low
high
x
)
=
>
{
const
t
=
this
.
clampMedianInterval
(
this
.
divisionInterval
(
this
.
subtractionInterval
(
x
low
)
this
.
subtractionInterval
(
high
low
)
)
0
.
0
1
.
0
)
;
return
this
.
multiplicationInterval
(
t
this
.
multiplicationInterval
(
t
this
.
subtractionInterval
(
3
.
0
this
.
multiplicationInterval
(
2
.
0
t
)
)
)
)
;
}
}
;
smoothStepIntervalImpl
(
low
high
x
)
{
return
this
.
runScalarTripleToIntervalOp
(
this
.
toInterval
(
low
)
this
.
toInterval
(
high
)
this
.
toInterval
(
x
)
this
.
SmoothStepOp
)
;
}
SqrtIntervalOp
=
{
impl
:
(
n
)
=
>
{
return
this
.
divisionInterval
(
1
.
0
this
.
inverseSqrtInterval
(
n
)
)
;
}
}
;
sqrtIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
SqrtIntervalOp
)
;
}
StepIntervalOp
=
{
impl
:
(
edge
x
)
=
>
{
if
(
edge
<
=
x
)
{
return
this
.
correctlyRoundedInterval
(
1
.
0
)
;
}
return
this
.
correctlyRoundedInterval
(
0
.
0
)
;
}
}
;
stepIntervalImpl
(
edge
x
)
{
return
this
.
runScalarPairToIntervalOp
(
this
.
toInterval
(
edge
)
this
.
toInterval
(
x
)
this
.
StepIntervalOp
)
;
}
SubtractionIntervalOp
=
{
impl
:
(
x
y
)
=
>
{
const
difference
=
x
-
y
;
const
large_val
=
Math
.
abs
(
x
)
>
Math
.
abs
(
y
)
?
x
:
-
y
;
const
small_val
=
Math
.
abs
(
x
)
>
Math
.
abs
(
y
)
?
-
y
:
x
;
return
this
.
correctlyRoundedIntervalWithUnboundedPrecisionForAddition
(
difference
large_val
small_val
)
;
}
}
;
subtractionIntervalImpl
(
x
y
)
{
return
this
.
runScalarPairToIntervalOp
(
this
.
toInterval
(
x
)
this
.
toInterval
(
y
)
this
.
SubtractionIntervalOp
)
;
}
subtractionMatrixMatrixIntervalImpl
(
x
y
)
{
return
this
.
runScalarPairToIntervalOpMatrixMatrixComponentWise
(
this
.
toMatrix
(
x
)
this
.
toMatrix
(
y
)
this
.
SubtractionIntervalOp
)
;
}
TanIntervalOp
=
{
impl
:
(
n
)
=
>
{
return
this
.
divisionInterval
(
this
.
sinInterval
(
n
)
this
.
cosInterval
(
n
)
)
;
}
}
;
tanIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
TanIntervalOp
)
;
}
TanhIntervalOp
=
{
impl
:
(
n
)
=
>
{
const
approx_abs_error
=
1
.
0e
-
5
;
return
this
.
spanIntervals
(
this
.
divisionInterval
(
this
.
sinhInterval
(
n
)
this
.
coshInterval
(
n
)
)
this
.
absoluteErrorInterval
(
Math
.
tanh
(
n
)
approx_abs_error
)
)
;
}
}
;
tanhIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
TanhIntervalOp
)
;
}
TransposeIntervalOp
=
{
impl
:
(
m
)
=
>
{
const
num_cols
=
m
.
length
;
const
num_rows
=
m
[
0
]
.
length
;
const
result
=
[
.
.
.
Array
(
num_rows
)
]
.
map
(
(
_
)
=
>
[
.
.
.
Array
(
num_cols
)
]
)
;
for
(
let
i
=
0
;
i
<
num_cols
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
num_rows
;
j
+
+
)
{
result
[
j
]
[
i
]
=
this
.
correctlyRoundedInterval
(
m
[
i
]
[
j
]
)
;
}
}
return
this
.
toMatrix
(
result
)
;
}
}
;
transposeIntervalImpl
(
m
)
{
return
this
.
runMatrixToMatrixOp
(
this
.
toMatrix
(
m
)
this
.
TransposeIntervalOp
)
;
}
TruncIntervalOp
=
{
impl
:
(
n
)
=
>
{
return
this
.
correctlyRoundedInterval
(
Math
.
trunc
(
n
)
)
;
}
}
;
truncIntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
TruncIntervalOp
)
;
}
}
const
kF32UnboundedInterval
=
new
FPInterval
(
'
f32
'
Number
.
NEGATIVE_INFINITY
Number
.
POSITIVE_INFINITY
)
;
const
kF32ZeroInterval
=
new
FPInterval
(
'
f32
'
0
)
;
class
F32Traits
extends
FPTraits
{
static
_constants
=
{
positive
:
{
min
:
kValue
.
f32
.
positive
.
min
max
:
kValue
.
f32
.
positive
.
max
infinity
:
kValue
.
f32
.
positive
.
infinity
nearest_max
:
kValue
.
f32
.
positive
.
nearest_max
less_than_one
:
kValue
.
f32
.
positive
.
less_than_one
subnormal
:
{
min
:
kValue
.
f32
.
positive
.
subnormal
.
min
max
:
kValue
.
f32
.
positive
.
subnormal
.
max
}
pi
:
{
whole
:
kValue
.
f32
.
positive
.
pi
.
whole
three_quarters
:
kValue
.
f32
.
positive
.
pi
.
three_quarters
half
:
kValue
.
f32
.
positive
.
pi
.
half
third
:
kValue
.
f32
.
positive
.
pi
.
third
quarter
:
kValue
.
f32
.
positive
.
pi
.
quarter
sixth
:
kValue
.
f32
.
positive
.
pi
.
sixth
}
e
:
kValue
.
f32
.
positive
.
e
}
negative
:
{
min
:
kValue
.
f32
.
negative
.
min
max
:
kValue
.
f32
.
negative
.
max
infinity
:
kValue
.
f32
.
negative
.
infinity
nearest_min
:
kValue
.
f32
.
negative
.
nearest_min
less_than_one
:
kValue
.
f32
.
negative
.
less_than_one
subnormal
:
{
min
:
kValue
.
f32
.
negative
.
subnormal
.
min
max
:
kValue
.
f32
.
negative
.
subnormal
.
max
}
pi
:
{
whole
:
kValue
.
f32
.
negative
.
pi
.
whole
three_quarters
:
kValue
.
f32
.
negative
.
pi
.
three_quarters
half
:
kValue
.
f32
.
negative
.
pi
.
half
third
:
kValue
.
f32
.
negative
.
pi
.
third
quarter
:
kValue
.
f32
.
negative
.
pi
.
quarter
sixth
:
kValue
.
f32
.
negative
.
pi
.
sixth
}
}
bias
:
127
unboundedInterval
:
kF32UnboundedInterval
zeroInterval
:
kF32ZeroInterval
negPiToPiInterval
:
new
FPInterval
(
'
f32
'
kValue
.
f32
.
negative
.
pi
.
whole
kValue
.
f32
.
positive
.
pi
.
whole
)
greaterThanZeroInterval
:
new
FPInterval
(
'
f32
'
kValue
.
f32
.
positive
.
subnormal
.
min
kValue
.
f32
.
positive
.
max
)
negOneToOneInterval
:
new
FPInterval
(
'
f32
'
-
1
1
)
zeroVector
:
{
2
:
[
kF32ZeroInterval
kF32ZeroInterval
]
3
:
[
kF32ZeroInterval
kF32ZeroInterval
kF32ZeroInterval
]
4
:
[
kF32ZeroInterval
kF32ZeroInterval
kF32ZeroInterval
kF32ZeroInterval
]
}
unboundedVector
:
{
2
:
[
kF32UnboundedInterval
kF32UnboundedInterval
]
3
:
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
4
:
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
}
unboundedMatrix
:
{
2
:
{
2
:
[
[
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
]
]
3
:
[
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
]
4
:
[
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
]
}
3
:
{
2
:
[
[
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
]
]
3
:
[
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
]
4
:
[
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
]
}
4
:
{
2
:
[
[
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
]
]
3
:
[
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
]
4
:
[
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
[
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
kF32UnboundedInterval
]
]
}
}
}
;
constructor
(
)
{
super
(
'
f32
'
)
;
}
constants
(
)
{
return
F32Traits
.
_constants
;
}
quantize
=
quantizeToF32
;
correctlyRounded
=
correctlyRoundedF32
;
isFinite
=
isFiniteF32
;
isSubnormal
=
isSubnormalNumberF32
;
flushSubnormal
=
flushSubnormalNumberF32
;
oneULP
=
oneULPF32
;
scalarBuilder
=
f32
;
scalarRange
=
scalarF32Range
;
sparseScalarRange
=
sparseScalarF32Range
;
vectorRange
=
vectorF32Range
;
sparseVectorRange
=
sparseVectorF32Range
;
sparseMatrixRange
=
sparseMatrixF32Range
;
absoluteErrorInterval
=
this
.
absoluteErrorIntervalImpl
.
bind
(
this
)
;
correctlyRoundedInterval
=
this
.
correctlyRoundedIntervalImpl
.
bind
(
this
)
;
correctlyRoundedMatrix
=
this
.
correctlyRoundedMatrixImpl
.
bind
(
this
)
;
ulpInterval
=
this
.
ulpIntervalImpl
.
bind
(
this
)
;
absInterval
=
this
.
absIntervalImpl
.
bind
(
this
)
;
acosInterval
=
this
.
acosIntervalImpl
.
bind
(
this
)
;
acoshAlternativeInterval
=
this
.
acoshAlternativeIntervalImpl
.
bind
(
this
)
;
acoshPrimaryInterval
=
this
.
acoshPrimaryIntervalImpl
.
bind
(
this
)
;
acoshIntervals
=
[
this
.
acoshAlternativeInterval
this
.
acoshPrimaryInterval
]
;
additionInterval
=
this
.
additionIntervalImpl
.
bind
(
this
)
;
additionMatrixMatrixInterval
=
this
.
additionMatrixMatrixIntervalImpl
.
bind
(
this
)
;
asinInterval
=
this
.
asinIntervalImpl
.
bind
(
this
)
;
asinhInterval
=
this
.
asinhIntervalImpl
.
bind
(
this
)
;
atanInterval
=
this
.
atanIntervalImpl
.
bind
(
this
)
;
atan2Interval
=
this
.
atan2IntervalImpl
.
bind
(
this
)
;
atanhInterval
=
this
.
atanhIntervalImpl
.
bind
(
this
)
;
ceilInterval
=
this
.
ceilIntervalImpl
.
bind
(
this
)
;
clampMedianInterval
=
this
.
clampMedianIntervalImpl
.
bind
(
this
)
;
clampMinMaxInterval
=
this
.
clampMinMaxIntervalImpl
.
bind
(
this
)
;
clampIntervals
=
[
this
.
clampMedianInterval
this
.
clampMinMaxInterval
]
;
cosInterval
=
this
.
cosIntervalImpl
.
bind
(
this
)
;
coshInterval
=
this
.
coshIntervalImpl
.
bind
(
this
)
;
crossInterval
=
this
.
crossIntervalImpl
.
bind
(
this
)
;
degreesInterval
=
this
.
degreesIntervalImpl
.
bind
(
this
)
;
determinantInterval
=
this
.
determinantIntervalImpl
.
bind
(
this
)
;
distanceInterval
=
this
.
distanceIntervalImpl
.
bind
(
this
)
;
divisionInterval
=
this
.
divisionIntervalImpl
.
bind
(
this
)
;
dotInterval
=
this
.
dotIntervalImpl
.
bind
(
this
)
;
expInterval
=
this
.
expIntervalImpl
.
bind
(
this
)
;
exp2Interval
=
this
.
exp2IntervalImpl
.
bind
(
this
)
;
faceForwardIntervals
=
this
.
faceForwardIntervalsImpl
.
bind
(
this
)
;
floorInterval
=
this
.
floorIntervalImpl
.
bind
(
this
)
;
fmaInterval
=
this
.
fmaIntervalImpl
.
bind
(
this
)
;
fractInterval
=
this
.
fractIntervalImpl
.
bind
(
this
)
;
inverseSqrtInterval
=
this
.
inverseSqrtIntervalImpl
.
bind
(
this
)
;
ldexpInterval
=
this
.
ldexpIntervalImpl
.
bind
(
this
)
;
lengthInterval
=
this
.
lengthIntervalImpl
.
bind
(
this
)
;
logInterval
=
this
.
logIntervalImpl
.
bind
(
this
)
;
log2Interval
=
this
.
log2IntervalImpl
.
bind
(
this
)
;
maxInterval
=
this
.
maxIntervalImpl
.
bind
(
this
)
;
minInterval
=
this
.
minIntervalImpl
.
bind
(
this
)
;
mixImpreciseInterval
=
this
.
mixImpreciseIntervalImpl
.
bind
(
this
)
;
mixPreciseInterval
=
this
.
mixPreciseIntervalImpl
.
bind
(
this
)
;
mixIntervals
=
[
this
.
mixImpreciseInterval
this
.
mixPreciseInterval
]
;
modfInterval
=
this
.
modfIntervalImpl
.
bind
(
this
)
;
multiplicationInterval
=
this
.
multiplicationIntervalImpl
.
bind
(
this
)
;
multiplicationMatrixMatrixInterval
=
this
.
multiplicationMatrixMatrixIntervalImpl
.
bind
(
this
)
;
multiplicationMatrixScalarInterval
=
this
.
multiplicationMatrixScalarIntervalImpl
.
bind
(
this
)
;
multiplicationScalarMatrixInterval
=
this
.
multiplicationScalarMatrixIntervalImpl
.
bind
(
this
)
;
multiplicationMatrixVectorInterval
=
this
.
multiplicationMatrixVectorIntervalImpl
.
bind
(
this
)
;
multiplicationVectorMatrixInterval
=
this
.
multiplicationVectorMatrixIntervalImpl
.
bind
(
this
)
;
negationInterval
=
this
.
negationIntervalImpl
.
bind
(
this
)
;
normalizeInterval
=
this
.
normalizeIntervalImpl
.
bind
(
this
)
;
powInterval
=
this
.
powIntervalImpl
.
bind
(
this
)
;
radiansInterval
=
this
.
radiansIntervalImpl
.
bind
(
this
)
;
reflectInterval
=
this
.
reflectIntervalImpl
.
bind
(
this
)
;
refractInterval
=
this
.
refractIntervalImpl
.
bind
(
this
)
;
remainderInterval
=
this
.
remainderIntervalImpl
.
bind
(
this
)
;
roundInterval
=
this
.
roundIntervalImpl
.
bind
(
this
)
;
saturateInterval
=
this
.
saturateIntervalImpl
.
bind
(
this
)
;
signInterval
=
this
.
signIntervalImpl
.
bind
(
this
)
;
sinInterval
=
this
.
sinIntervalImpl
.
bind
(
this
)
;
sinhInterval
=
this
.
sinhIntervalImpl
.
bind
(
this
)
;
smoothStepInterval
=
this
.
smoothStepIntervalImpl
.
bind
(
this
)
;
sqrtInterval
=
this
.
sqrtIntervalImpl
.
bind
(
this
)
;
stepInterval
=
this
.
stepIntervalImpl
.
bind
(
this
)
;
subtractionInterval
=
this
.
subtractionIntervalImpl
.
bind
(
this
)
;
subtractionMatrixMatrixInterval
=
this
.
subtractionMatrixMatrixIntervalImpl
.
bind
(
this
)
;
tanInterval
=
this
.
tanIntervalImpl
.
bind
(
this
)
;
tanhInterval
=
this
.
tanhIntervalImpl
.
bind
(
this
)
;
transposeInterval
=
this
.
transposeIntervalImpl
.
bind
(
this
)
;
truncInterval
=
this
.
truncIntervalImpl
.
bind
(
this
)
;
makeU32ToVectorCase
(
param
filter
.
.
.
ops
)
{
param
=
Math
.
trunc
(
param
)
;
const
vectors
=
ops
.
map
(
(
o
)
=
>
o
(
param
)
)
;
if
(
filter
=
=
=
'
finite
'
&
&
vectors
.
some
(
(
v
)
=
>
!
v
.
every
(
(
e
)
=
>
e
.
isFinite
(
)
)
)
)
{
return
undefined
;
}
return
{
input
:
u32
(
param
)
expected
:
anyOf
(
.
.
.
vectors
)
}
;
}
generateU32ToIntervalCases
(
params
filter
.
.
.
ops
)
{
return
params
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
this
.
makeU32ToVectorCase
(
e
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
(
)
)
;
}
QuantizeToF16IntervalOp
=
{
impl
:
(
n
)
=
>
{
const
rounded
=
correctlyRoundedF16
(
n
)
;
const
flushed
=
addFlushedIfNeededF16
(
rounded
)
;
return
this
.
spanIntervals
(
.
.
.
flushed
.
map
(
(
f
)
=
>
this
.
toInterval
(
f
)
)
)
;
}
}
;
quantizeToF16IntervalImpl
(
n
)
{
return
this
.
runScalarToIntervalOp
(
this
.
toInterval
(
n
)
this
.
QuantizeToF16IntervalOp
)
;
}
quantizeToF16Interval
=
this
.
quantizeToF16IntervalImpl
.
bind
(
this
)
;
unpackData
=
new
ArrayBuffer
(
4
)
;
unpackDataU32
=
new
Uint32Array
(
this
.
unpackData
)
;
unpackDataU16
=
new
Uint16Array
(
this
.
unpackData
)
;
unpackDataU8
=
new
Uint8Array
(
this
.
unpackData
)
;
unpackDataI16
=
new
Int16Array
(
this
.
unpackData
)
;
unpackDataI8
=
new
Int8Array
(
this
.
unpackData
)
;
unpackDataF16
=
new
Float16Array
(
this
.
unpackData
)
;
unpack2x16floatIntervalImpl
(
n
)
{
assert
(
n
>
=
kValue
.
u32
.
min
&
&
n
<
=
kValue
.
u32
.
max
'
unpack2x16floatInterval
only
accepts
valid
u32
values
'
)
;
this
.
unpackDataU32
[
0
]
=
n
;
if
(
this
.
unpackDataF16
.
some
(
(
f
)
=
>
!
isFiniteF16
(
f
)
)
)
{
return
[
this
.
constants
(
)
.
unboundedInterval
this
.
constants
(
)
.
unboundedInterval
]
;
}
const
result
=
[
this
.
quantizeToF16Interval
(
this
.
unpackDataF16
[
0
]
)
this
.
quantizeToF16Interval
(
this
.
unpackDataF16
[
1
]
)
]
;
if
(
result
.
some
(
(
r
)
=
>
!
r
.
isFinite
(
)
)
)
{
return
[
this
.
constants
(
)
.
unboundedInterval
this
.
constants
(
)
.
unboundedInterval
]
;
}
return
result
;
}
unpack2x16floatInterval
=
this
.
unpack2x16floatIntervalImpl
.
bind
(
this
)
;
unpack2x16snormIntervalImpl
(
n
)
{
assert
(
n
>
=
kValue
.
u32
.
min
&
&
n
<
=
kValue
.
u32
.
max
'
unpack2x16snormInterval
only
accepts
valid
u32
values
'
)
;
const
op
=
(
n
)
=
>
{
return
this
.
ulpInterval
(
Math
.
max
(
n
/
32767
-
1
)
3
)
;
}
;
this
.
unpackDataU32
[
0
]
=
n
;
return
[
op
(
this
.
unpackDataI16
[
0
]
)
op
(
this
.
unpackDataI16
[
1
]
)
]
;
}
unpack2x16snormInterval
=
this
.
unpack2x16snormIntervalImpl
.
bind
(
this
)
;
unpack2x16unormIntervalImpl
(
n
)
{
assert
(
n
>
=
kValue
.
u32
.
min
&
&
n
<
=
kValue
.
u32
.
max
'
unpack2x16unormInterval
only
accepts
valid
u32
values
'
)
;
const
op
=
(
n
)
=
>
{
return
this
.
ulpInterval
(
n
/
65535
3
)
;
}
;
this
.
unpackDataU32
[
0
]
=
n
;
return
[
op
(
this
.
unpackDataU16
[
0
]
)
op
(
this
.
unpackDataU16
[
1
]
)
]
;
}
unpack2x16unormInterval
=
this
.
unpack2x16unormIntervalImpl
.
bind
(
this
)
;
unpack4x8snormIntervalImpl
(
n
)
{
assert
(
n
>
=
kValue
.
u32
.
min
&
&
n
<
=
kValue
.
u32
.
max
'
unpack4x8snormInterval
only
accepts
valid
u32
values
'
)
;
const
op
=
(
n
)
=
>
{
return
this
.
ulpInterval
(
Math
.
max
(
n
/
127
-
1
)
3
)
;
}
;
this
.
unpackDataU32
[
0
]
=
n
;
return
[
op
(
this
.
unpackDataI8
[
0
]
)
op
(
this
.
unpackDataI8
[
1
]
)
op
(
this
.
unpackDataI8
[
2
]
)
op
(
this
.
unpackDataI8
[
3
]
)
]
;
}
unpack4x8snormInterval
=
this
.
unpack4x8snormIntervalImpl
.
bind
(
this
)
;
unpack4x8unormIntervalImpl
(
n
)
{
assert
(
n
>
=
kValue
.
u32
.
min
&
&
n
<
=
kValue
.
u32
.
max
'
unpack4x8unormInterval
only
accepts
valid
u32
values
'
)
;
const
op
=
(
n
)
=
>
{
return
this
.
ulpInterval
(
n
/
255
3
)
;
}
;
this
.
unpackDataU32
[
0
]
=
n
;
return
[
op
(
this
.
unpackDataU8
[
0
]
)
op
(
this
.
unpackDataU8
[
1
]
)
op
(
this
.
unpackDataU8
[
2
]
)
op
(
this
.
unpackDataU8
[
3
]
)
]
;
}
unpack4x8unormInterval
=
this
.
unpack4x8unormIntervalImpl
.
bind
(
this
)
;
}
const
kF32Traits
=
new
F32Traits
(
)
;
const
kAbstractUnboundedInterval
=
new
FPInterval
(
'
abstract
'
Number
.
NEGATIVE_INFINITY
Number
.
POSITIVE_INFINITY
)
;
const
kAbstractZeroInterval
=
new
FPInterval
(
'
abstract
'
0
)
;
class
FPAbstractTraits
extends
FPTraits
{
static
_constants
=
{
positive
:
{
min
:
kValue
.
f64
.
positive
.
min
max
:
kValue
.
f64
.
positive
.
max
infinity
:
kValue
.
f64
.
positive
.
infinity
nearest_max
:
kValue
.
f64
.
positive
.
nearest_max
less_than_one
:
kValue
.
f64
.
positive
.
less_than_one
subnormal
:
{
min
:
kValue
.
f64
.
positive
.
subnormal
.
min
max
:
kValue
.
f64
.
positive
.
subnormal
.
max
}
pi
:
{
whole
:
kValue
.
f64
.
positive
.
pi
.
whole
three_quarters
:
kValue
.
f64
.
positive
.
pi
.
three_quarters
half
:
kValue
.
f64
.
positive
.
pi
.
half
third
:
kValue
.
f64
.
positive
.
pi
.
third
quarter
:
kValue
.
f64
.
positive
.
pi
.
quarter
sixth
:
kValue
.
f64
.
positive
.
pi
.
sixth
}
e
:
kValue
.
f64
.
positive
.
e
}
negative
:
{
min
:
kValue
.
f64
.
negative
.
min
max
:
kValue
.
f64
.
negative
.
max
infinity
:
kValue
.
f64
.
negative
.
infinity
nearest_min
:
kValue
.
f64
.
negative
.
nearest_min
less_than_one
:
kValue
.
f64
.
negative
.
less_than_one
subnormal
:
{
min
:
kValue
.
f64
.
negative
.
subnormal
.
min
max
:
kValue
.
f64
.
negative
.
subnormal
.
max
}
pi
:
{
whole
:
kValue
.
f64
.
negative
.
pi
.
whole
three_quarters
:
kValue
.
f64
.
negative
.
pi
.
three_quarters
half
:
kValue
.
f64
.
negative
.
pi
.
half
third
:
kValue
.
f64
.
negative
.
pi
.
third
quarter
:
kValue
.
f64
.
negative
.
pi
.
quarter
sixth
:
kValue
.
f64
.
negative
.
pi
.
sixth
}
}
bias
:
1023
unboundedInterval
:
kAbstractUnboundedInterval
zeroInterval
:
kAbstractZeroInterval
negPiToPiInterval
:
new
FPInterval
(
'
abstract
'
kValue
.
f64
.
negative
.
pi
.
whole
kValue
.
f64
.
positive
.
pi
.
whole
)
greaterThanZeroInterval
:
new
FPInterval
(
'
abstract
'
kValue
.
f64
.
positive
.
subnormal
.
min
kValue
.
f64
.
positive
.
max
)
negOneToOneInterval
:
new
FPInterval
(
'
abstract
'
-
1
1
)
zeroVector
:
{
2
:
[
kAbstractZeroInterval
kAbstractZeroInterval
]
3
:
[
kAbstractZeroInterval
kAbstractZeroInterval
kAbstractZeroInterval
]
4
:
[
kAbstractZeroInterval
kAbstractZeroInterval
kAbstractZeroInterval
kAbstractZeroInterval
]
}
unboundedVector
:
{
2
:
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
3
:
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
4
:
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
}
unboundedMatrix
:
{
2
:
{
2
:
[
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
]
3
:
[
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
]
4
:
[
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
]
}
3
:
{
2
:
[
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
]
3
:
[
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
]
4
:
[
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
]
}
4
:
{
2
:
[
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
]
3
:
[
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
]
4
:
[
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
[
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
kAbstractUnboundedInterval
]
]
}
}
}
;
constructor
(
)
{
super
(
'
abstract
'
)
;
}
constants
(
)
{
return
FPAbstractTraits
.
_constants
;
}
quantize
=
(
n
)
=
>
{
return
n
;
}
;
correctlyRounded
=
correctlyRoundedF64
;
isFinite
=
Number
.
isFinite
;
isSubnormal
=
isSubnormalNumberF64
;
flushSubnormal
=
flushSubnormalNumberF64
;
oneULP
=
(
_target
_mode
=
'
flush
'
)
=
>
{
unreachable
(
'
FPAbstractTraits
.
oneULP
should
never
be
called
)
;
}
;
scalarBuilder
=
abstractFloat
;
scalarRange
=
scalarF64Range
;
sparseScalarRange
=
sparseScalarF64Range
;
vectorRange
=
vectorF64Range
;
sparseVectorRange
=
sparseVectorF64Range
;
sparseMatrixRange
=
sparseMatrixF64Range
;
absoluteErrorInterval
=
this
.
unimplementedAbsoluteErrorInterval
.
bind
(
this
)
;
correctlyRoundedInterval
=
this
.
correctlyRoundedIntervalImpl
.
bind
(
this
)
;
correctlyRoundedMatrix
=
this
.
correctlyRoundedMatrixImpl
.
bind
(
this
)
;
ulpInterval
=
this
.
unimplementedUlpInterval
.
bind
(
this
)
;
absInterval
=
this
.
absIntervalImpl
.
bind
(
this
)
;
acosInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
acosInterval
'
)
;
acoshAlternativeInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
acoshAlternativeInterval
'
)
;
acoshPrimaryInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
acoshPrimaryInterval
'
)
;
acoshIntervals
=
[
this
.
acoshAlternativeInterval
this
.
acoshPrimaryInterval
]
;
additionInterval
=
this
.
unimplementedScalarPairToInterval
.
bind
(
this
'
additionInterval
'
)
;
additionMatrixMatrixInterval
=
this
.
unimplementedMatrixPairToMatrix
.
bind
(
this
'
additionMatrixMatrixInterval
'
)
;
asinInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
asinInterval
'
)
;
asinhInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
asinhInterval
'
)
;
atanInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
atanInterval
'
)
;
atan2Interval
=
this
.
unimplementedScalarPairToInterval
.
bind
(
this
'
atan2Interval
'
)
;
atanhInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
atanhInterval
'
)
;
ceilInterval
=
this
.
ceilIntervalImpl
.
bind
(
this
)
;
clampMedianInterval
=
this
.
clampMedianIntervalImpl
.
bind
(
this
)
;
clampMinMaxInterval
=
this
.
clampMinMaxIntervalImpl
.
bind
(
this
)
;
clampIntervals
=
[
this
.
clampMedianInterval
this
.
clampMinMaxInterval
]
;
cosInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
cosInterval
'
)
;
coshInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
coshInterval
'
)
;
crossInterval
=
this
.
unimplementedVectorPairToVector
.
bind
(
this
'
crossInterval
'
)
;
degreesInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
degreesInterval
'
)
;
determinantInterval
=
this
.
unimplementedMatrixToInterval
.
bind
(
this
'
determinant
'
)
;
distanceInterval
=
this
.
unimplementedDistance
.
bind
(
this
)
;
divisionInterval
=
this
.
unimplementedScalarPairToInterval
.
bind
(
this
'
divisionInterval
'
)
;
dotInterval
=
this
.
unimplementedVectorPairToInterval
.
bind
(
this
'
dotInterval
'
)
;
expInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
expInterval
'
)
;
exp2Interval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
exp2Interval
'
)
;
faceForwardIntervals
=
this
.
unimplementedFaceForward
.
bind
(
this
)
;
floorInterval
=
this
.
floorIntervalImpl
.
bind
(
this
)
;
fmaInterval
=
this
.
unimplementedScalarTripleToInterval
.
bind
(
this
'
fmaInterval
'
)
;
fractInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
fractInterval
'
)
;
inverseSqrtInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
inverseSqrtInterval
'
)
;
ldexpInterval
=
this
.
ldexpIntervalImpl
.
bind
(
this
)
;
lengthInterval
=
this
.
unimplementedLength
.
bind
(
this
)
;
logInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
logInterval
'
)
;
log2Interval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
log2Interval
'
)
;
maxInterval
=
this
.
maxIntervalImpl
.
bind
(
this
)
;
minInterval
=
this
.
minIntervalImpl
.
bind
(
this
)
;
mixImpreciseInterval
=
this
.
unimplementedScalarTripleToInterval
.
bind
(
this
'
mixImpreciseInterval
'
)
;
mixPreciseInterval
=
this
.
unimplementedScalarTripleToInterval
.
bind
(
this
'
mixPreciseInterval
'
)
;
mixIntervals
=
[
this
.
mixImpreciseInterval
this
.
mixPreciseInterval
]
;
modfInterval
=
this
.
modfIntervalImpl
.
bind
(
this
)
;
multiplicationInterval
=
this
.
unimplementedScalarPairToInterval
.
bind
(
this
'
multiplicationInterval
'
)
;
multiplicationMatrixMatrixInterval
=
this
.
unimplementedMatrixPairToMatrix
.
bind
(
this
'
multiplicationMatrixMatrixInterval
'
)
;
multiplicationMatrixScalarInterval
=
this
.
unimplementedMatrixScalarToMatrix
.
bind
(
this
'
multiplicationMatrixScalarInterval
'
)
;
multiplicationScalarMatrixInterval
=
this
.
unimplementedScalarMatrixToMatrix
.
bind
(
this
'
multiplicationScalarMatrixInterval
'
)
;
multiplicationMatrixVectorInterval
=
this
.
unimplementedMatrixVectorToVector
.
bind
(
this
'
multiplicationMatrixVectorInterval
'
)
;
multiplicationVectorMatrixInterval
=
this
.
unimplementedVectorMatrixToVector
.
bind
(
this
'
multiplicationVectorMatrixInterval
'
)
;
negationInterval
=
this
.
negationIntervalImpl
.
bind
(
this
)
;
normalizeInterval
=
this
.
unimplementedVectorToVector
.
bind
(
this
'
normalizeInterval
'
)
;
powInterval
=
this
.
unimplementedScalarPairToInterval
.
bind
(
this
'
powInterval
'
)
;
radiansInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
radiansImpl
'
)
;
reflectInterval
=
this
.
unimplementedVectorPairToVector
.
bind
(
this
'
reflectInterval
'
)
;
refractInterval
=
this
.
unimplementedRefract
.
bind
(
this
)
;
remainderInterval
=
this
.
unimplementedScalarPairToInterval
.
bind
(
this
'
remainderInterval
'
)
;
roundInterval
=
this
.
roundIntervalImpl
.
bind
(
this
)
;
saturateInterval
=
this
.
saturateIntervalImpl
.
bind
(
this
)
;
signInterval
=
this
.
signIntervalImpl
.
bind
(
this
)
;
sinInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
sinInterval
'
)
;
sinhInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
sinhInterval
'
)
;
smoothStepInterval
=
this
.
unimplementedScalarTripleToInterval
.
bind
(
this
'
smoothStepInterval
'
)
;
sqrtInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
sqrtInterval
'
)
;
stepInterval
=
this
.
stepIntervalImpl
.
bind
(
this
)
;
subtractionInterval
=
this
.
unimplementedScalarPairToInterval
.
bind
(
this
'
subtractionInterval
'
)
;
subtractionMatrixMatrixInterval
=
this
.
unimplementedMatrixPairToMatrix
.
bind
(
this
'
subtractionMatrixMatrixInterval
'
)
;
tanInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
tanInterval
'
)
;
tanhInterval
=
this
.
unimplementedScalarToInterval
.
bind
(
this
'
tanhInterval
'
)
;
transposeInterval
=
this
.
transposeIntervalImpl
.
bind
(
this
)
;
truncInterval
=
this
.
truncIntervalImpl
.
bind
(
this
)
;
}
const
kF16UnboundedInterval
=
new
FPInterval
(
'
f16
'
Number
.
NEGATIVE_INFINITY
Number
.
POSITIVE_INFINITY
)
;
const
kF16ZeroInterval
=
new
FPInterval
(
'
f16
'
0
)
;
class
F16Traits
extends
FPTraits
{
static
_constants
=
{
positive
:
{
min
:
kValue
.
f16
.
positive
.
min
max
:
kValue
.
f16
.
positive
.
max
infinity
:
kValue
.
f16
.
positive
.
infinity
nearest_max
:
kValue
.
f16
.
positive
.
nearest_max
less_than_one
:
kValue
.
f16
.
positive
.
less_than_one
subnormal
:
{
min
:
kValue
.
f16
.
positive
.
subnormal
.
min
max
:
kValue
.
f16
.
positive
.
subnormal
.
max
}
pi
:
{
whole
:
kValue
.
f16
.
positive
.
pi
.
whole
three_quarters
:
kValue
.
f16
.
positive
.
pi
.
three_quarters
half
:
kValue
.
f16
.
positive
.
pi
.
half
third
:
kValue
.
f16
.
positive
.
pi
.
third
quarter
:
kValue
.
f16
.
positive
.
pi
.
quarter
sixth
:
kValue
.
f16
.
positive
.
pi
.
sixth
}
e
:
kValue
.
f16
.
positive
.
e
}
negative
:
{
min
:
kValue
.
f16
.
negative
.
min
max
:
kValue
.
f16
.
negative
.
max
infinity
:
kValue
.
f16
.
negative
.
infinity
nearest_min
:
kValue
.
f16
.
negative
.
nearest_min
less_than_one
:
kValue
.
f16
.
negative
.
less_than_one
subnormal
:
{
min
:
kValue
.
f16
.
negative
.
subnormal
.
min
max
:
kValue
.
f16
.
negative
.
subnormal
.
max
}
pi
:
{
whole
:
kValue
.
f16
.
negative
.
pi
.
whole
three_quarters
:
kValue
.
f16
.
negative
.
pi
.
three_quarters
half
:
kValue
.
f16
.
negative
.
pi
.
half
third
:
kValue
.
f16
.
negative
.
pi
.
third
quarter
:
kValue
.
f16
.
negative
.
pi
.
quarter
sixth
:
kValue
.
f16
.
negative
.
pi
.
sixth
}
}
bias
:
15
unboundedInterval
:
kF16UnboundedInterval
zeroInterval
:
kF16ZeroInterval
negPiToPiInterval
:
new
FPInterval
(
'
f16
'
kValue
.
f16
.
negative
.
pi
.
whole
kValue
.
f16
.
positive
.
pi
.
whole
)
greaterThanZeroInterval
:
new
FPInterval
(
'
f16
'
kValue
.
f16
.
positive
.
subnormal
.
min
kValue
.
f16
.
positive
.
max
)
negOneToOneInterval
:
new
FPInterval
(
'
f16
'
-
1
1
)
zeroVector
:
{
2
:
[
kF16ZeroInterval
kF16ZeroInterval
]
3
:
[
kF16ZeroInterval
kF16ZeroInterval
kF16ZeroInterval
]
4
:
[
kF16ZeroInterval
kF16ZeroInterval
kF16ZeroInterval
kF16ZeroInterval
]
}
unboundedVector
:
{
2
:
[
kF16UnboundedInterval
kF16UnboundedInterval
]
3
:
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
4
:
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
}
unboundedMatrix
:
{
2
:
{
2
:
[
[
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
]
]
3
:
[
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
]
4
:
[
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
]
}
3
:
{
2
:
[
[
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
]
]
3
:
[
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
]
4
:
[
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
]
}
4
:
{
2
:
[
[
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
]
]
3
:
[
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
]
4
:
[
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
[
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
kF16UnboundedInterval
]
]
}
}
}
;
constructor
(
)
{
super
(
'
f16
'
)
;
}
constants
(
)
{
return
F16Traits
.
_constants
;
}
quantize
=
quantizeToF16
;
correctlyRounded
=
correctlyRoundedF16
;
isFinite
=
isFiniteF16
;
isSubnormal
=
isSubnormalNumberF16
;
flushSubnormal
=
flushSubnormalNumberF16
;
oneULP
=
oneULPF16
;
scalarBuilder
=
f16
;
scalarRange
=
scalarF16Range
;
sparseScalarRange
=
sparseScalarF16Range
;
vectorRange
=
vectorF16Range
;
sparseVectorRange
=
sparseVectorF16Range
;
sparseMatrixRange
=
sparseMatrixF16Range
;
absoluteErrorInterval
=
this
.
absoluteErrorIntervalImpl
.
bind
(
this
)
;
correctlyRoundedInterval
=
this
.
correctlyRoundedIntervalImpl
.
bind
(
this
)
;
correctlyRoundedMatrix
=
this
.
correctlyRoundedMatrixImpl
.
bind
(
this
)
;
ulpInterval
=
this
.
ulpIntervalImpl
.
bind
(
this
)
;
absInterval
=
this
.
absIntervalImpl
.
bind
(
this
)
;
acosInterval
=
this
.
acosIntervalImpl
.
bind
(
this
)
;
acoshAlternativeInterval
=
this
.
acoshAlternativeIntervalImpl
.
bind
(
this
)
;
acoshPrimaryInterval
=
this
.
acoshPrimaryIntervalImpl
.
bind
(
this
)
;
acoshIntervals
=
[
this
.
acoshAlternativeInterval
this
.
acoshPrimaryInterval
]
;
additionInterval
=
this
.
additionIntervalImpl
.
bind
(
this
)
;
additionMatrixMatrixInterval
=
this
.
additionMatrixMatrixIntervalImpl
.
bind
(
this
)
;
asinInterval
=
this
.
asinIntervalImpl
.
bind
(
this
)
;
asinhInterval
=
this
.
asinhIntervalImpl
.
bind
(
this
)
;
atanInterval
=
this
.
atanIntervalImpl
.
bind
(
this
)
;
atan2Interval
=
this
.
atan2IntervalImpl
.
bind
(
this
)
;
atanhInterval
=
this
.
atanhIntervalImpl
.
bind
(
this
)
;
ceilInterval
=
this
.
ceilIntervalImpl
.
bind
(
this
)
;
clampMedianInterval
=
this
.
clampMedianIntervalImpl
.
bind
(
this
)
;
clampMinMaxInterval
=
this
.
clampMinMaxIntervalImpl
.
bind
(
this
)
;
clampIntervals
=
[
this
.
clampMedianInterval
this
.
clampMinMaxInterval
]
;
cosInterval
=
this
.
cosIntervalImpl
.
bind
(
this
)
;
coshInterval
=
this
.
coshIntervalImpl
.
bind
(
this
)
;
crossInterval
=
this
.
crossIntervalImpl
.
bind
(
this
)
;
degreesInterval
=
this
.
degreesIntervalImpl
.
bind
(
this
)
;
determinantInterval
=
this
.
determinantIntervalImpl
.
bind
(
this
)
;
distanceInterval
=
this
.
distanceIntervalImpl
.
bind
(
this
)
;
divisionInterval
=
this
.
divisionIntervalImpl
.
bind
(
this
)
;
dotInterval
=
this
.
dotIntervalImpl
.
bind
(
this
)
;
expInterval
=
this
.
expIntervalImpl
.
bind
(
this
)
;
exp2Interval
=
this
.
exp2IntervalImpl
.
bind
(
this
)
;
faceForwardIntervals
=
this
.
faceForwardIntervalsImpl
.
bind
(
this
)
;
floorInterval
=
this
.
floorIntervalImpl
.
bind
(
this
)
;
fmaInterval
=
this
.
fmaIntervalImpl
.
bind
(
this
)
;
fractInterval
=
this
.
fractIntervalImpl
.
bind
(
this
)
;
inverseSqrtInterval
=
this
.
inverseSqrtIntervalImpl
.
bind
(
this
)
;
ldexpInterval
=
this
.
ldexpIntervalImpl
.
bind
(
this
)
;
lengthInterval
=
this
.
lengthIntervalImpl
.
bind
(
this
)
;
logInterval
=
this
.
logIntervalImpl
.
bind
(
this
)
;
log2Interval
=
this
.
log2IntervalImpl
.
bind
(
this
)
;
maxInterval
=
this
.
maxIntervalImpl
.
bind
(
this
)
;
minInterval
=
this
.
minIntervalImpl
.
bind
(
this
)
;
mixImpreciseInterval
=
this
.
mixImpreciseIntervalImpl
.
bind
(
this
)
;
mixPreciseInterval
=
this
.
mixPreciseIntervalImpl
.
bind
(
this
)
;
mixIntervals
=
[
this
.
mixImpreciseInterval
this
.
mixPreciseInterval
]
;
modfInterval
=
this
.
modfIntervalImpl
.
bind
(
this
)
;
multiplicationInterval
=
this
.
multiplicationIntervalImpl
.
bind
(
this
)
;
multiplicationMatrixMatrixInterval
=
this
.
multiplicationMatrixMatrixIntervalImpl
.
bind
(
this
)
;
multiplicationMatrixScalarInterval
=
this
.
multiplicationMatrixScalarIntervalImpl
.
bind
(
this
)
;
multiplicationScalarMatrixInterval
=
this
.
multiplicationScalarMatrixIntervalImpl
.
bind
(
this
)
;
multiplicationMatrixVectorInterval
=
this
.
multiplicationMatrixVectorIntervalImpl
.
bind
(
this
)
;
multiplicationVectorMatrixInterval
=
this
.
multiplicationVectorMatrixIntervalImpl
.
bind
(
this
)
;
negationInterval
=
this
.
negationIntervalImpl
.
bind
(
this
)
;
normalizeInterval
=
this
.
normalizeIntervalImpl
.
bind
(
this
)
;
powInterval
=
this
.
powIntervalImpl
.
bind
(
this
)
;
radiansInterval
=
this
.
radiansIntervalImpl
.
bind
(
this
)
;
reflectInterval
=
this
.
reflectIntervalImpl
.
bind
(
this
)
;
refractInterval
=
this
.
refractIntervalImpl
.
bind
(
this
)
;
remainderInterval
=
this
.
remainderIntervalImpl
.
bind
(
this
)
;
roundInterval
=
this
.
roundIntervalImpl
.
bind
(
this
)
;
saturateInterval
=
this
.
saturateIntervalImpl
.
bind
(
this
)
;
signInterval
=
this
.
signIntervalImpl
.
bind
(
this
)
;
sinInterval
=
this
.
sinIntervalImpl
.
bind
(
this
)
;
sinhInterval
=
this
.
sinhIntervalImpl
.
bind
(
this
)
;
smoothStepInterval
=
this
.
smoothStepIntervalImpl
.
bind
(
this
)
;
sqrtInterval
=
this
.
sqrtIntervalImpl
.
bind
(
this
)
;
stepInterval
=
this
.
stepIntervalImpl
.
bind
(
this
)
;
subtractionInterval
=
this
.
subtractionIntervalImpl
.
bind
(
this
)
;
subtractionMatrixMatrixInterval
=
this
.
subtractionMatrixMatrixIntervalImpl
.
bind
(
this
)
;
tanInterval
=
this
.
tanIntervalImpl
.
bind
(
this
)
;
tanhInterval
=
this
.
tanhIntervalImpl
.
bind
(
this
)
;
transposeInterval
=
this
.
transposeIntervalImpl
.
bind
(
this
)
;
truncInterval
=
this
.
truncIntervalImpl
.
bind
(
this
)
;
}
export
const
FP
=
{
f32
:
kF32Traits
f16
:
new
F16Traits
(
)
abstract
:
new
FPAbstractTraits
(
)
}
;
export
function
fpTraitsFor
(
type
)
{
switch
(
type
.
kind
)
{
case
'
abstract
-
float
'
:
return
FP
.
abstract
;
case
'
f32
'
:
return
FP
.
f32
;
case
'
f16
'
:
return
FP
.
f16
;
default
:
unreachable
(
unsupported
type
:
{
type
}
)
;
}
}
export
function
isRepresentable
(
value
type
)
{
if
(
!
Number
.
isFinite
(
value
)
)
{
return
false
;
}
if
(
isFloatType
(
type
)
)
{
const
constants
=
fpTraitsFor
(
type
)
.
constants
(
)
;
return
value
>
=
constants
.
negative
.
min
&
&
value
<
=
constants
.
positive
.
max
;
}
assert
(
false
isRepresentable
(
)
is
not
yet
implemented
for
type
{
type
}
)
;
}
