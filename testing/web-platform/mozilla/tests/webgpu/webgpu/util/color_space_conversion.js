import
{
assert
unreachable
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
multiplyMatrices
}
from
'
.
/
math
.
js
'
;
function
lin_sRGB
(
RGB
)
{
return
RGB
.
map
(
(
val
)
=
>
{
const
sign
=
val
<
0
?
-
1
:
1
;
const
abs
=
Math
.
abs
(
val
)
;
if
(
abs
<
0
.
04045
)
{
return
val
/
12
.
92
;
}
return
sign
*
Math
.
pow
(
(
abs
+
0
.
055
)
/
1
.
055
2
.
4
)
;
}
)
;
}
function
gam_sRGB
(
RGB
)
{
return
RGB
.
map
(
(
val
)
=
>
{
const
sign
=
val
<
0
?
-
1
:
1
;
const
abs
=
Math
.
abs
(
val
)
;
if
(
abs
>
0
.
0031308
)
{
return
sign
*
(
1
.
055
*
Math
.
pow
(
abs
1
/
2
.
4
)
-
0
.
055
)
;
}
return
12
.
92
*
val
;
}
)
;
}
function
lin_sRGB_to_XYZ
(
rgb
)
{
const
M
=
[
[
506752
/
1228815
87881
/
245763
12673
/
70218
]
[
87098
/
409605
175762
/
245763
12673
/
175545
]
[
7918
/
409605
87881
/
737289
1001167
/
1053270
]
]
;
return
multiplyMatrices
(
M
rgb
)
;
}
function
XYZ_to_lin_sRGB
(
XYZ
)
{
const
M
=
[
[
12831
/
3959
-
329
/
214
-
1974
/
3959
]
[
-
851781
/
878810
1648619
/
878810
36519
/
878810
]
[
705
/
12673
-
2585
/
12673
705
/
667
]
]
;
return
multiplyMatrices
(
M
XYZ
)
;
}
function
lin_P3
(
RGB
)
{
return
lin_sRGB
(
RGB
)
;
}
function
gam_P3
(
RGB
)
{
return
gam_sRGB
(
RGB
)
;
}
function
lin_P3_to_XYZ
(
rgb
)
{
const
M
=
[
[
608311
/
1250200
189793
/
714400
198249
/
1000160
]
[
35783
/
156275
247089
/
357200
198249
/
2500400
]
[
0
/
1
32229
/
714400
5220557
/
5000800
]
]
;
return
multiplyMatrices
(
M
rgb
)
;
}
function
XYZ_to_lin_P3
(
XYZ
)
{
const
M
=
[
[
446124
/
178915
-
333277
/
357830
-
72051
/
178915
]
[
-
14852
/
17905
63121
/
35810
423
/
17905
]
[
11844
/
330415
-
50337
/
660830
316169
/
330415
]
]
;
return
multiplyMatrices
(
M
XYZ
)
;
}
export
function
displayP3ToSrgb
(
pixel
)
{
assert
(
pixel
.
R
!
=
=
undefined
&
&
pixel
.
G
!
=
=
undefined
&
&
pixel
.
B
!
=
=
undefined
'
color
space
conversion
requires
all
of
R
G
and
B
components
'
)
;
let
rgbVec
=
[
pixel
.
R
pixel
.
G
pixel
.
B
]
;
rgbVec
=
lin_P3
(
rgbVec
)
;
let
rgbMatrix
=
[
[
rgbVec
[
0
]
]
[
rgbVec
[
1
]
]
[
rgbVec
[
2
]
]
]
;
rgbMatrix
=
XYZ_to_lin_sRGB
(
lin_P3_to_XYZ
(
rgbMatrix
)
)
;
rgbVec
=
[
rgbMatrix
[
0
]
[
0
]
rgbMatrix
[
1
]
[
0
]
rgbMatrix
[
2
]
[
0
]
]
;
rgbVec
=
gam_sRGB
(
rgbVec
)
;
return
{
R
:
rgbVec
[
0
]
G
:
rgbVec
[
1
]
B
:
rgbVec
[
2
]
A
:
pixel
.
A
}
;
}
export
function
srgbToDisplayP3
(
pixel
)
{
assert
(
pixel
.
R
!
=
=
undefined
&
&
pixel
.
G
!
=
=
undefined
&
&
pixel
.
B
!
=
=
undefined
'
color
space
conversion
requires
all
of
R
G
and
B
components
'
)
;
let
rgbVec
=
[
pixel
.
R
pixel
.
G
pixel
.
B
]
;
rgbVec
=
lin_sRGB
(
rgbVec
)
;
let
rgbMatrix
=
[
[
rgbVec
[
0
]
]
[
rgbVec
[
1
]
]
[
rgbVec
[
2
]
]
]
;
rgbMatrix
=
XYZ_to_lin_P3
(
lin_sRGB_to_XYZ
(
rgbMatrix
)
)
;
rgbVec
=
[
rgbMatrix
[
0
]
[
0
]
rgbMatrix
[
1
]
[
0
]
rgbMatrix
[
2
]
[
0
]
]
;
rgbVec
=
gam_P3
(
rgbVec
)
;
return
{
R
:
rgbVec
[
0
]
G
:
rgbVec
[
1
]
B
:
rgbVec
[
2
]
A
:
pixel
.
A
}
;
}
export
function
makeInPlaceColorConversion
(
{
srcPremultiplied
dstPremultiplied
srcColorSpace
=
'
srgb
'
dstColorSpace
=
'
srgb
'
}
)
{
const
requireColorSpaceConversion
=
srcColorSpace
!
=
=
dstColorSpace
;
const
requireUnpremultiplyAlpha
=
srcPremultiplied
&
&
(
requireColorSpaceConversion
|
|
srcPremultiplied
!
=
=
dstPremultiplied
)
;
const
requirePremultiplyAlpha
=
dstPremultiplied
&
&
(
requireColorSpaceConversion
|
|
srcPremultiplied
!
=
=
dstPremultiplied
)
;
return
(
rgba
)
=
>
{
assert
(
rgba
.
A
>
=
0
.
0
&
&
rgba
.
A
<
=
1
.
0
'
rgba
.
A
out
of
bounds
'
)
;
if
(
requireUnpremultiplyAlpha
)
{
if
(
rgba
.
A
!
=
=
0
.
0
)
{
rgba
.
R
/
=
rgba
.
A
;
rgba
.
G
/
=
rgba
.
A
;
rgba
.
B
/
=
rgba
.
A
;
}
else
{
assert
(
rgba
.
R
=
=
=
0
.
0
&
&
rgba
.
G
=
=
=
0
.
0
&
&
rgba
.
B
=
=
=
0
.
0
&
&
rgba
.
A
=
=
=
0
.
0
'
Unpremultiply
ops
with
alpha
value
0
.
0
requires
all
channels
equals
to
0
.
0
'
)
;
}
}
if
(
requireColorSpaceConversion
)
{
if
(
srcColorSpace
=
=
=
'
display
-
p3
'
&
&
dstColorSpace
=
=
=
'
srgb
'
)
{
Object
.
assign
(
rgba
displayP3ToSrgb
(
rgba
)
)
;
}
else
if
(
srcColorSpace
=
=
=
'
srgb
'
&
&
dstColorSpace
=
=
=
'
display
-
p3
'
)
{
Object
.
assign
(
rgba
srgbToDisplayP3
(
rgba
)
)
;
}
else
{
unreachable
(
)
;
}
}
if
(
requirePremultiplyAlpha
)
{
rgba
.
R
*
=
rgba
.
A
;
rgba
.
G
*
=
rgba
.
A
;
rgba
.
B
*
=
rgba
.
A
;
}
}
;
}
