import
{
globalTestConfig
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
framework
/
test_config
.
js
'
;
import
{
assert
objectEquals
unreachable
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
kValue
}
from
'
.
.
/
.
.
/
.
.
/
util
/
constants
.
js
'
;
import
{
MatrixType
ScalarType
Type
VectorType
VectorValue
isAbstractType
scalarTypeOf
ArrayType
elementTypeOf
}
from
'
.
.
/
.
.
/
.
.
/
util
/
conversion
.
js
'
;
import
{
align
}
from
'
.
.
/
.
.
/
.
.
/
util
/
math
.
js
'
;
import
{
toComparator
}
from
'
.
/
expectation
.
js
'
;
export
const
allInputSources
=
[
'
const
'
'
uniform
'
'
storage_r
'
'
storage_rw
'
]
;
export
const
onlyConstInputSource
=
[
'
const
'
]
;
export
const
allButConstInputSource
=
[
'
uniform
'
'
storage_r
'
'
storage_rw
'
]
;
function
sizeAndAlignmentOf
(
ty
source
)
{
if
(
ty
instanceof
ScalarType
)
{
if
(
ty
.
kind
=
=
=
'
abstract
-
float
'
|
|
ty
.
kind
=
=
=
'
abstract
-
int
'
)
{
return
{
size
:
8
alignment
:
8
}
;
}
return
{
size
:
ty
.
size
alignment
:
ty
.
alignment
}
;
}
if
(
ty
instanceof
VectorType
)
{
const
out
=
sizeAndAlignmentOf
(
ty
.
elementType
source
)
;
const
n
=
ty
.
width
=
=
=
3
?
4
:
ty
.
width
;
out
.
size
*
=
n
;
out
.
alignment
*
=
n
;
return
out
;
}
if
(
ty
instanceof
MatrixType
)
{
const
out
=
sizeAndAlignmentOf
(
ty
.
elementType
source
)
;
const
n
=
ty
.
rows
=
=
=
3
?
4
:
ty
.
rows
;
out
.
size
*
=
n
*
ty
.
cols
;
out
.
alignment
*
=
n
;
return
out
;
}
if
(
ty
instanceof
ArrayType
)
{
const
out
=
sizeAndAlignmentOf
(
ty
.
elementType
source
)
;
if
(
source
=
=
=
'
uniform
'
)
{
out
.
alignment
=
align
(
out
.
alignment
16
)
;
}
out
.
size
*
=
ty
.
count
;
return
out
;
}
unreachable
(
unhandled
type
:
{
ty
}
)
;
}
function
strideOf
(
ty
source
)
{
const
sizeAndAlign
=
sizeAndAlignmentOf
(
ty
source
)
;
return
align
(
sizeAndAlign
.
size
sizeAndAlign
.
alignment
)
;
}
export
function
structLayout
(
members
source
callback
)
{
let
offset
=
0
;
let
alignment
=
1
;
for
(
let
i
=
0
;
i
<
members
.
length
;
i
+
+
)
{
const
member
=
members
[
i
]
;
const
sizeAndAlign
=
sizeAndAlignmentOf
(
member
source
)
;
offset
=
align
(
offset
sizeAndAlign
.
alignment
)
;
if
(
callback
)
{
callback
(
{
index
:
i
type
:
member
size
:
sizeAndAlign
.
size
alignment
:
sizeAndAlign
.
alignment
offset
}
)
;
}
offset
+
=
sizeAndAlign
.
size
;
alignment
=
Math
.
max
(
alignment
sizeAndAlign
.
alignment
)
;
}
if
(
source
=
=
=
'
uniform
'
)
{
alignment
=
align
(
alignment
16
)
;
}
const
size
=
offset
;
const
stride
=
align
(
size
alignment
)
;
return
{
size
stride
alignment
}
;
}
export
function
structStride
(
members
source
)
{
return
structLayout
(
members
source
)
.
stride
;
}
function
wgslMembers
(
members
source
memberName
)
{
const
lines
=
[
]
;
const
layout
=
structLayout
(
members
source
(
m
)
=
>
{
lines
.
push
(
size
(
{
m
.
size
}
)
{
memberName
(
lines
.
length
)
}
:
{
m
.
type
}
)
;
}
)
;
const
padding
=
layout
.
stride
-
layout
.
size
;
if
(
padding
>
0
)
{
const
ty
=
(
padding
&
2
)
!
=
=
0
?
'
f16
'
:
'
i32
'
;
lines
.
push
(
size
(
{
padding
}
)
padding
:
{
ty
}
)
;
}
return
lines
.
join
(
'
\
n
'
)
;
}
function
storageType
(
ty
)
{
if
(
ty
instanceof
ScalarType
)
{
assert
(
ty
.
kind
!
=
=
'
f64
'
No
storage
type
defined
for
'
f64
'
values
)
;
assert
(
ty
.
kind
!
=
=
'
abstract
-
int
'
Custom
handling
is
implemented
for
'
abstract
-
int
'
values
)
;
assert
(
ty
.
kind
!
=
=
'
abstract
-
float
'
Custom
handling
is
implemented
for
'
abstract
-
float
'
values
)
;
if
(
ty
.
kind
=
=
=
'
bool
'
)
{
return
Type
.
u32
;
}
}
if
(
ty
instanceof
VectorType
)
{
return
Type
.
vec
(
ty
.
width
storageType
(
ty
.
elementType
)
)
;
}
if
(
ty
instanceof
ArrayType
)
{
return
Type
.
array
(
ty
.
count
storageType
(
ty
.
elementType
)
)
;
}
return
ty
;
}
function
fromStorage
(
ty
expr
helpers
)
{
if
(
ty
instanceof
ScalarType
)
{
assert
(
ty
.
kind
!
=
=
'
abstract
-
int
'
'
abstract
-
int
'
values
should
not
be
in
input
storage
)
;
assert
(
ty
.
kind
!
=
=
'
abstract
-
float
'
'
abstract
-
float
'
values
should
not
be
in
input
storage
)
;
assert
(
ty
.
kind
!
=
=
'
f64
'
'
No
storage
type
defined
for
'
f64
'
values
)
;
if
(
ty
.
kind
=
=
=
'
bool
'
)
{
return
{
expr
}
!
=
0u
;
}
}
if
(
ty
instanceof
VectorType
)
{
assert
(
ty
.
elementType
.
kind
!
=
=
'
abstract
-
int
'
'
abstract
-
int
'
values
cannot
appear
in
input
storage
)
;
assert
(
ty
.
elementType
.
kind
!
=
=
'
abstract
-
float
'
'
abstract
-
float
'
values
cannot
appear
in
input
storage
)
;
assert
(
ty
.
elementType
.
kind
!
=
=
'
f64
'
'
No
storage
type
defined
for
'
f64
'
values
)
;
if
(
ty
.
elementType
.
kind
=
=
=
'
bool
'
)
{
return
(
{
expr
}
!
=
vec
{
ty
.
width
}
<
u32
>
(
0u
)
)
;
}
}
if
(
ty
instanceof
ArrayType
&
&
elementTypeOf
(
ty
)
=
=
=
Type
.
bool
)
{
const
conv
=
helpers
.
uniqueID
(
)
;
const
inTy
=
Type
.
array
(
ty
.
count
Type
.
u32
)
;
helpers
.
wgsl
+
=
fn
{
conv
}
(
in
:
{
inTy
}
)
-
>
{
ty
}
{
var
out
:
{
ty
}
;
for
(
var
i
=
0
;
i
<
{
ty
.
count
}
;
i
+
+
)
{
out
[
i
]
=
in
[
i
]
!
=
0
;
}
return
out
;
}
;
return
{
conv
}
(
{
expr
}
)
;
}
return
expr
;
}
function
toStorage
(
ty
expr
helpers
)
{
if
(
ty
instanceof
ScalarType
)
{
assert
(
ty
.
kind
!
=
=
'
abstract
-
int
'
'
abstract
-
int
'
values
have
custom
code
for
writing
to
storage
)
;
assert
(
ty
.
kind
!
=
=
'
abstract
-
float
'
'
abstract
-
float
'
values
have
custom
code
for
writing
to
storage
)
;
assert
(
ty
.
kind
!
=
=
'
f64
'
No
storage
type
defined
for
'
f64
'
values
)
;
if
(
ty
.
kind
=
=
=
'
bool
'
)
{
return
select
(
0u
1u
{
expr
}
)
;
}
}
if
(
ty
instanceof
VectorType
)
{
assert
(
ty
.
elementType
.
kind
!
=
=
'
abstract
-
int
'
'
abstract
-
int
'
values
have
custom
code
for
writing
to
storage
)
;
assert
(
ty
.
elementType
.
kind
!
=
=
'
abstract
-
float
'
'
abstract
-
float
'
values
have
custom
code
for
writing
to
storage
)
;
assert
(
ty
.
elementType
.
kind
!
=
=
'
f64
'
'
No
storage
type
defined
for
'
f64
'
values
)
;
if
(
ty
.
elementType
.
kind
=
=
=
'
bool
'
)
{
return
select
(
vec
{
ty
.
width
}
<
u32
>
(
0u
)
vec
{
ty
.
width
}
<
u32
>
(
1u
)
{
expr
}
)
;
}
}
if
(
ty
instanceof
ArrayType
&
&
elementTypeOf
(
ty
)
=
=
=
Type
.
bool
)
{
const
conv
=
helpers
.
uniqueID
(
)
;
const
outTy
=
Type
.
array
(
ty
.
count
Type
.
u32
)
;
helpers
.
wgsl
+
=
fn
{
conv
}
(
in
:
{
ty
}
)
-
>
{
outTy
}
{
var
out
:
{
outTy
}
;
for
(
var
i
=
0
;
i
<
{
ty
.
count
}
;
i
+
+
)
{
out
[
i
]
=
select
(
0u
1u
in
[
i
]
)
;
}
return
out
;
}
;
return
{
conv
}
(
{
expr
}
)
;
}
return
expr
;
}
function
getOrCreate
(
map
key
create
)
{
const
existing
=
map
.
get
(
key
)
;
if
(
existing
!
=
=
undefined
)
{
return
existing
;
}
const
value
=
create
(
)
;
map
.
set
(
key
value
)
;
return
value
;
}
export
async
function
run
(
t
shaderBuilder
parameterTypes
resultType
cfg
=
{
inputSource
:
'
storage_r
'
}
cases
batch_size
)
{
if
(
cfg
.
vectorize
!
=
=
undefined
)
{
const
packed
=
packScalarsToVector
(
parameterTypes
resultType
cases
cfg
.
vectorize
)
;
cases
=
packed
.
cases
;
parameterTypes
=
packed
.
parameterTypes
;
resultType
=
packed
.
resultType
;
}
const
casesPerBatch
=
function
(
)
{
if
(
batch_size
)
{
return
batch_size
;
}
switch
(
cfg
.
inputSource
)
{
case
'
const
'
:
return
32
;
case
'
uniform
'
:
return
Math
.
floor
(
Math
.
min
(
1024
*
2
t
.
device
.
limits
.
maxUniformBufferBindingSize
)
/
structStride
(
parameterTypes
cfg
.
inputSource
)
)
;
case
'
storage_r
'
:
case
'
storage_rw
'
:
return
Math
.
floor
(
t
.
device
.
limits
.
maxStorageBufferBindingSize
/
structStride
(
parameterTypes
cfg
.
inputSource
)
)
;
}
}
(
)
;
const
pipelineCache
=
new
Map
(
)
;
const
maxBatchesInFlight
=
5
;
let
batchesInFlight
=
0
;
let
resolvePromiseBlockingBatch
=
undefined
;
const
batchFinishedCallback
=
(
)
=
>
{
batchesInFlight
-
=
1
;
if
(
resolvePromiseBlockingBatch
)
{
resolvePromiseBlockingBatch
(
)
;
resolvePromiseBlockingBatch
=
undefined
;
}
}
;
const
processBatch
=
async
(
batchCases
)
=
>
{
const
shaderBuilderParams
=
{
parameterTypes
resultType
cases
:
batchCases
inputSource
:
cfg
.
inputSource
constEvaluationMode
:
cfg
.
constEvaluationMode
}
;
const
checkBatch
=
await
submitBatch
(
t
shaderBuilder
shaderBuilderParams
pipelineCache
)
;
checkBatch
(
)
;
await
t
.
queue
.
onSubmittedWorkDone
(
)
;
}
;
const
pendingBatches
=
[
]
;
for
(
let
i
=
0
;
i
<
cases
.
length
;
i
+
=
casesPerBatch
)
{
const
batchCases
=
cases
.
slice
(
i
Math
.
min
(
i
+
casesPerBatch
cases
.
length
)
)
;
if
(
batchesInFlight
>
maxBatchesInFlight
)
{
await
new
Promise
(
(
resolve
)
=
>
{
assert
(
resolvePromiseBlockingBatch
=
=
=
undefined
)
;
resolvePromiseBlockingBatch
=
resolve
;
}
)
;
}
batchesInFlight
+
=
1
;
pendingBatches
.
push
(
processBatch
(
batchCases
)
.
catch
(
(
err
)
=
>
{
if
(
err
instanceof
GPUPipelineError
)
{
t
.
fail
(
Pipeline
Creation
Error
{
err
.
reason
}
:
{
err
.
message
}
)
;
}
else
{
throw
err
;
}
}
)
.
finally
(
batchFinishedCallback
)
)
;
}
await
Promise
.
all
(
pendingBatches
)
;
}
async
function
submitBatch
(
t
shaderBuilder
shaderBuilderParams
pipelineCache
)
{
const
{
resultType
cases
}
=
shaderBuilderParams
;
const
outputStride
=
structStride
(
[
resultType
]
'
storage_rw
'
)
;
const
outputBufferSize
=
align
(
cases
.
length
*
outputStride
4
)
;
const
outputBuffer
=
t
.
createBufferTracked
(
{
size
:
outputBufferSize
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
}
)
;
const
[
pipeline
group
]
=
await
buildPipeline
(
t
shaderBuilder
shaderBuilderParams
outputBuffer
pipelineCache
)
;
const
encoder
=
t
.
device
.
createCommandEncoder
(
)
;
const
pass
=
encoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
group
)
;
pass
.
dispatchWorkgroups
(
1
)
;
pass
.
end
(
)
;
globalTestConfig
.
testHeartbeatCallback
(
)
;
t
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
return
(
)
=
>
{
const
checkExpectation
=
(
outputData
)
=
>
{
const
outputs
=
new
Array
(
cases
.
length
)
;
for
(
let
i
=
0
;
i
<
cases
.
length
;
i
+
+
)
{
outputs
[
i
]
=
resultType
.
read
(
outputData
i
*
outputStride
)
;
}
const
errs
=
[
]
;
for
(
let
caseIdx
=
0
;
caseIdx
<
cases
.
length
;
caseIdx
+
+
)
{
const
c
=
cases
[
caseIdx
]
;
const
got
=
outputs
[
caseIdx
]
;
const
cmp
=
toComparator
(
c
.
expected
)
.
compare
(
got
)
;
if
(
!
cmp
.
matched
)
{
errs
.
push
(
(
{
c
.
input
instanceof
Array
?
c
.
input
.
join
(
'
'
)
:
c
.
input
}
)
returned
:
{
cmp
.
got
}
expected
:
{
cmp
.
expected
}
)
;
}
}
return
errs
.
length
>
0
?
new
Error
(
errs
.
join
(
'
\
n
\
n
'
)
)
:
undefined
;
}
;
globalTestConfig
.
testHeartbeatCallback
(
)
;
t
.
expectGPUBufferValuesPassCheck
(
outputBuffer
checkExpectation
{
type
:
Uint8Array
typedLength
:
outputBufferSize
}
)
;
}
;
}
function
map
(
v
fn
)
{
if
(
v
instanceof
Array
)
{
return
v
.
map
(
fn
)
;
}
return
[
fn
(
v
0
)
]
;
}
function
wgslOutputs
(
resultType
count
)
{
let
output_struct
=
undefined
;
if
(
scalarTypeOf
(
resultType
)
.
kind
!
=
=
'
abstract
-
float
'
&
&
scalarTypeOf
(
resultType
)
.
kind
!
=
=
'
abstract
-
int
'
)
{
output_struct
=
struct
Output
{
size
(
{
strideOf
(
resultType
'
storage_rw
'
)
}
)
value
:
{
storageType
(
resultType
)
}
}
;
;
}
else
{
if
(
resultType
instanceof
ScalarType
)
{
output_struct
=
struct
AF
{
low
:
u32
high
:
u32
}
;
struct
Output
{
size
(
{
strideOf
(
resultType
'
storage_rw
'
)
}
)
value
:
AF
}
;
;
}
if
(
resultType
instanceof
VectorType
)
{
const
dim
=
resultType
.
width
;
output_struct
=
struct
AF
{
low
:
u32
high
:
u32
}
;
struct
Output
{
size
(
{
strideOf
(
resultType
'
storage_rw
'
)
}
)
value
:
array
<
AF
{
dim
}
>
}
;
;
}
if
(
resultType
instanceof
MatrixType
)
{
const
cols
=
resultType
.
cols
;
const
rows
=
resultType
.
rows
=
=
=
2
?
2
:
4
;
output_struct
=
struct
AF
{
low
:
u32
high
:
u32
}
;
struct
Output
{
size
(
{
strideOf
(
resultType
'
storage_rw
'
)
}
)
value
:
array
<
array
<
AF
{
rows
}
>
{
cols
}
>
}
;
;
}
assert
(
output_struct
!
=
=
undefined
No
implementation
for
result
type
'
{
resultType
}
'
)
;
}
return
{
output_struct
}
group
(
0
)
binding
(
0
)
var
<
storage
read_write
>
outputs
:
array
<
Output
{
count
}
>
;
;
}
function
wgslValuesArray
(
cases
expressionBuilder
)
{
return
const
values
=
array
(
{
cases
.
map
(
(
c
)
=
>
expressionBuilder
(
map
(
c
.
input
(
v
)
=
>
v
.
wgsl
(
)
)
)
)
.
join
(
'
\
n
'
)
}
)
;
;
}
function
wgslInputVar
(
inputSource
count
)
{
switch
(
inputSource
)
{
case
'
storage_r
'
:
return
group
(
0
)
binding
(
1
)
var
<
storage
read
>
inputs
:
array
<
Input
{
count
}
>
;
;
case
'
storage_rw
'
:
return
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
inputs
:
array
<
Input
{
count
}
>
;
;
case
'
uniform
'
:
return
group
(
0
)
binding
(
1
)
var
<
uniform
>
inputs
:
array
<
Input
{
count
}
>
;
;
}
throw
new
Error
(
InputSource
{
inputSource
}
does
not
use
an
input
var
)
;
}
function
wgslHeader
(
parameterTypes
resultType
)
{
const
usedF16
=
scalarTypeOf
(
resultType
)
.
kind
=
=
=
'
f16
'
|
|
parameterTypes
.
some
(
(
ty
)
=
>
scalarTypeOf
(
ty
)
.
kind
=
=
=
'
f16
'
)
;
const
header
=
usedF16
?
'
enable
f16
;
\
n
'
:
'
'
;
return
header
;
}
function
basicExpressionShaderBody
(
expressionBuilder
params
)
{
const
{
parameterTypes
resultType
cases
inputSource
}
=
params
;
assert
(
scalarTypeOf
(
resultType
)
.
kind
!
=
=
'
abstract
-
int
'
abstractIntShaderBuilder
should
be
used
when
result
type
is
'
abstract
-
int
'
)
;
assert
(
scalarTypeOf
(
resultType
)
.
kind
!
=
=
'
abstract
-
float
'
abstractFloatShaderBuilder
should
be
used
when
result
type
is
'
abstract
-
float
'
)
;
let
nextUniqueIDSuffix
=
0
;
const
convHelpers
=
{
wgsl
:
'
'
uniqueID
:
(
)
=
>
cts_symbol_
{
nextUniqueIDSuffix
+
+
}
}
;
if
(
inputSource
=
=
=
'
const
'
)
{
let
constEvaluationMode
=
params
.
constEvaluationMode
;
if
(
constEvaluationMode
=
=
=
undefined
)
{
if
(
parameterTypes
.
some
(
(
ty
)
=
>
isAbstractType
(
scalarTypeOf
(
ty
)
)
)
)
{
constEvaluationMode
=
'
direct
'
;
}
else
{
constEvaluationMode
=
globalTestConfig
.
unrollConstEvalLoops
?
'
unrolled
'
:
'
loop
'
;
}
}
let
body
=
'
'
;
let
valuesArray
=
'
'
;
switch
(
constEvaluationMode
)
{
case
'
direct
'
:
{
body
=
cases
.
map
(
(
c
i
)
=
>
outputs
[
{
i
}
]
.
value
=
{
toStorage
(
resultType
expressionBuilder
(
map
(
c
.
input
(
v
)
=
>
v
.
wgsl
(
)
)
)
convHelpers
)
}
;
)
.
join
(
'
\
n
'
)
;
break
;
}
case
'
unrolled
'
:
{
body
=
cases
.
map
(
(
_
i
)
=
>
{
const
value
=
values
[
{
i
}
]
;
return
outputs
[
{
i
}
]
.
value
=
{
toStorage
(
resultType
value
convHelpers
)
}
;
;
}
)
.
join
(
'
\
n
'
)
;
valuesArray
=
wgslValuesArray
(
cases
expressionBuilder
)
;
break
;
}
case
'
loop
'
:
{
body
=
for
(
var
i
=
0u
;
i
<
{
cases
.
length
}
;
i
+
+
)
{
outputs
[
i
]
.
value
=
{
toStorage
(
resultType
values
[
i
]
convHelpers
)
}
;
}
;
valuesArray
=
wgslValuesArray
(
cases
expressionBuilder
)
;
break
;
}
}
return
{
wgslOutputs
(
resultType
cases
.
length
)
}
{
valuesArray
}
{
convHelpers
.
wgsl
}
compute
workgroup_size
(
1
)
fn
main
(
)
{
{
body
}
}
;
}
else
{
const
paramExpr
=
(
ty
i
)
=
>
fromStorage
(
ty
inputs
[
i
]
.
param
{
i
}
convHelpers
)
;
const
expr
=
toStorage
(
resultType
expressionBuilder
(
parameterTypes
.
map
(
paramExpr
)
)
convHelpers
)
;
return
struct
Input
{
{
wgslMembers
(
parameterTypes
.
map
(
storageType
)
inputSource
(
i
)
=
>
param
{
i
}
)
}
}
{
wgslOutputs
(
resultType
cases
.
length
)
}
{
wgslInputVar
(
inputSource
cases
.
length
)
}
{
convHelpers
.
wgsl
}
compute
workgroup_size
(
1
)
fn
main
(
)
{
for
(
var
i
=
0
;
i
<
{
cases
.
length
}
;
i
+
+
)
{
outputs
[
i
]
.
value
=
{
expr
}
;
}
}
;
}
}
export
function
basicExpressionBuilder
(
expressionBuilder
)
{
return
(
params
)
=
>
{
return
\
{
wgslHeader
(
params
.
parameterTypes
params
.
resultType
)
}
{
basicExpressionShaderBody
(
expressionBuilder
params
)
}
;
}
;
}
export
function
basicExpressionWithPredeclarationBuilder
(
expressionBuilder
predeclaration
)
{
return
(
params
)
=
>
{
return
\
{
wgslHeader
(
params
.
parameterTypes
params
.
resultType
)
}
{
predeclaration
}
{
basicExpressionShaderBody
(
expressionBuilder
params
)
}
;
}
;
}
export
function
compoundAssignmentBuilder
(
op
)
{
return
(
params
)
=
>
{
const
{
parameterTypes
resultType
cases
inputSource
}
=
params
;
if
(
parameterTypes
.
length
!
=
=
2
)
{
throw
new
Error
(
compoundBinaryOp
(
)
requires
exactly
two
parameters
values
per
case
)
;
}
const
lhsType
=
parameterTypes
[
0
]
;
const
rhsType
=
parameterTypes
[
1
]
;
if
(
!
objectEquals
(
lhsType
resultType
)
)
{
throw
new
Error
(
compoundBinaryOp
(
)
requires
result
type
(
{
resultType
}
)
to
be
equal
to
the
LHS
type
(
{
lhsType
}
)
)
;
}
if
(
inputSource
=
=
=
'
const
'
)
{
let
body
=
'
'
;
if
(
globalTestConfig
.
unrollConstEvalLoops
)
{
body
=
cases
.
map
(
(
_
i
)
=
>
{
return
var
ret_
{
i
}
=
lhs
[
{
i
}
]
;
ret_
{
i
}
{
op
}
rhs
[
{
i
}
]
;
outputs
[
{
i
}
]
.
value
=
{
storageType
(
resultType
)
}
(
ret_
{
i
}
)
;
;
}
)
.
join
(
'
\
n
'
)
;
}
else
{
body
=
for
(
var
i
=
0u
;
i
<
{
cases
.
length
}
;
i
+
+
)
{
var
ret
=
lhs
[
i
]
;
ret
{
op
}
rhs
[
i
]
;
outputs
[
i
]
.
value
=
{
storageType
(
resultType
)
}
(
ret
)
;
}
;
}
const
values
=
cases
.
map
(
(
c
)
=
>
c
.
input
.
map
(
(
v
)
=
>
v
.
wgsl
(
)
)
)
;
return
{
wgslHeader
(
parameterTypes
resultType
)
}
{
wgslOutputs
(
resultType
cases
.
length
)
}
const
lhs
=
array
(
{
values
.
map
(
(
c
)
=
>
{
c
[
0
]
}
)
.
join
(
'
\
n
'
)
}
)
;
const
rhs
=
array
(
{
values
.
map
(
(
c
)
=
>
{
c
[
1
]
}
)
.
join
(
'
\
n
'
)
}
)
;
compute
workgroup_size
(
1
)
fn
main
(
)
{
{
body
}
}
;
}
else
{
let
operation
=
'
'
;
if
(
inputSource
=
=
=
'
storage_rw
'
&
&
objectEquals
(
resultType
storageType
(
resultType
)
)
)
{
operation
=
outputs
[
i
]
.
value
=
{
storageType
(
resultType
)
}
(
inputs
[
i
]
.
lhs
)
;
outputs
[
i
]
.
value
{
op
}
{
rhsType
}
(
inputs
[
i
]
.
rhs
)
;
;
}
else
{
operation
=
var
ret
=
{
lhsType
}
(
inputs
[
i
]
.
lhs
)
;
ret
{
op
}
{
rhsType
}
(
inputs
[
i
]
.
rhs
)
;
outputs
[
i
]
.
value
=
{
storageType
(
resultType
)
}
(
ret
)
;
;
}
return
{
wgslHeader
(
parameterTypes
resultType
)
}
{
wgslOutputs
(
resultType
cases
.
length
)
}
struct
Input
{
{
wgslMembers
(
[
lhsType
rhsType
]
.
map
(
storageType
)
inputSource
(
i
)
=
>
[
'
lhs
'
'
rhs
'
]
[
i
]
)
}
}
{
wgslInputVar
(
inputSource
cases
.
length
)
}
compute
workgroup_size
(
1
)
fn
main
(
)
{
for
(
var
i
=
0
;
i
<
{
cases
.
length
}
;
i
+
+
)
{
{
operation
}
}
}
;
}
}
;
}
function
abstractFloatSnippet
(
expr
case_idx
accessor
=
'
'
)
{
return
{
const
kExponentBias
=
1022
;
const
subnormal_or_zero
:
bool
=
(
{
expr
}
{
accessor
}
<
=
{
kValue
.
f64
.
positive
.
subnormal
.
max
}
)
&
&
(
{
expr
}
{
accessor
}
>
=
{
kValue
.
f64
.
negative
.
subnormal
.
min
}
)
;
const
sign_bit
:
u32
=
select
(
0
0x80000000
{
expr
}
{
accessor
}
<
0
)
;
const
f
=
frexp
(
abs
(
{
expr
}
{
accessor
}
)
)
;
const
f_fract
=
select
(
f
.
fract
0
subnormal_or_zero
)
;
const
f_exp
=
select
(
f
.
exp
-
kExponentBias
subnormal_or_zero
)
;
const
exponent_bits
:
u32
=
(
f_exp
+
kExponentBias
)
<
<
20
;
const
high_mantissa
=
ldexp
(
f_fract
21
)
;
const
high_mantissa_bits
:
u32
=
u32
(
ldexp
(
f_fract
21
)
)
&
0x000fffff
;
const
low_mantissa
=
f_fract
-
ldexp
(
floor
(
high_mantissa
)
-
21
)
;
const
low_mantissa_bits
=
u32
(
ldexp
(
low_mantissa
53
)
)
;
outputs
[
{
case_idx
}
]
.
value
{
accessor
}
.
high
=
sign_bit
|
exponent_bits
|
high_mantissa_bits
;
outputs
[
{
case_idx
}
]
.
value
{
accessor
}
.
low
=
low_mantissa_bits
;
}
;
}
function
abstractFloatCaseBody
(
expr
resultType
i
)
{
if
(
resultType
instanceof
ScalarType
)
{
return
abstractFloatSnippet
(
expr
i
)
;
}
if
(
resultType
instanceof
VectorType
)
{
return
[
.
.
.
Array
(
resultType
.
width
)
.
keys
(
)
]
.
map
(
(
idx
)
=
>
abstractFloatSnippet
(
expr
i
[
{
idx
}
]
)
)
.
join
(
'
\
n
'
)
;
}
if
(
resultType
instanceof
MatrixType
)
{
const
cols
=
resultType
.
cols
;
const
rows
=
resultType
.
rows
;
const
results
=
[
.
.
.
Array
(
cols
*
rows
)
]
;
for
(
let
c
=
0
;
c
<
cols
;
c
+
+
)
{
for
(
let
r
=
0
;
r
<
rows
;
r
+
+
)
{
results
[
c
*
rows
+
r
]
=
abstractFloatSnippet
(
expr
i
[
{
c
}
]
[
{
r
}
]
)
;
}
}
return
results
.
join
(
'
\
n
'
)
;
}
unreachable
(
Results
of
type
'
{
resultType
}
'
not
yet
implemented
)
;
}
export
function
abstractFloatShaderBuilder
(
expressionBuilder
)
{
return
(
params
)
=
>
{
const
{
parameterTypes
resultType
cases
inputSource
}
=
params
;
assert
(
inputSource
=
=
=
'
const
'
'
abstract
-
float
'
results
are
only
defined
for
const
-
eval
)
;
assert
(
scalarTypeOf
(
resultType
)
.
kind
=
=
=
'
abstract
-
float
'
Expected
resultType
of
'
abstract
-
float
'
received
'
{
scalarTypeOf
(
resultType
)
.
kind
}
'
instead
)
;
const
body
=
cases
.
map
(
(
c
i
)
=
>
{
const
expr
=
{
expressionBuilder
(
map
(
c
.
input
(
v
)
=
>
v
.
wgsl
(
)
)
)
}
;
return
abstractFloatCaseBody
(
expr
resultType
i
)
;
}
)
.
join
(
'
\
n
'
)
;
return
{
wgslHeader
(
parameterTypes
resultType
)
}
{
wgslOutputs
(
resultType
cases
.
length
)
}
compute
workgroup_size
(
1
)
fn
main
(
)
{
{
body
}
}
;
}
;
}
function
abstractIntSnippet
(
expr
case_idx
accessor
=
'
'
)
{
return
{
outputs
[
{
case_idx
}
]
.
value
{
accessor
}
.
high
=
bitcast
<
u32
>
(
i32
(
{
expr
}
{
accessor
}
>
>
32
)
)
&
0xFFFFFFFF
;
const
low_sign
=
(
{
expr
}
{
accessor
}
&
(
1
<
<
31
)
)
;
outputs
[
{
case_idx
}
]
.
value
{
accessor
}
.
low
=
bitcast
<
u32
>
(
(
{
expr
}
{
accessor
}
&
0x7FFFFFFF
)
)
|
low_sign
;
}
;
}
function
abstractIntCaseBody
(
expr
resultType
i
)
{
if
(
resultType
instanceof
ScalarType
)
{
return
abstractIntSnippet
(
expr
i
)
;
}
if
(
resultType
instanceof
VectorType
)
{
return
[
.
.
.
Array
(
resultType
.
width
)
.
keys
(
)
]
.
map
(
(
idx
)
=
>
abstractIntSnippet
(
expr
i
[
{
idx
}
]
)
)
.
join
(
'
\
n
'
)
;
}
unreachable
(
Results
of
type
'
{
resultType
}
'
not
yet
implemented
)
;
}
export
function
abstractIntShaderBuilder
(
expressionBuilder
)
{
return
(
params
)
=
>
{
const
{
parameterTypes
resultType
cases
inputSource
}
=
params
;
assert
(
inputSource
=
=
=
'
const
'
'
abstract
-
int
'
results
are
only
defined
for
const
-
eval
)
;
assert
(
scalarTypeOf
(
resultType
)
.
kind
=
=
=
'
abstract
-
int
'
Expected
resultType
of
'
abstract
-
int
'
received
'
{
scalarTypeOf
(
resultType
)
.
kind
}
'
instead
)
;
const
body
=
cases
.
map
(
(
c
i
)
=
>
{
const
expr
=
{
expressionBuilder
(
map
(
c
.
input
(
v
)
=
>
v
.
wgsl
(
)
)
)
}
;
return
abstractIntCaseBody
(
expr
resultType
i
)
;
}
)
.
join
(
'
\
n
'
)
;
return
{
wgslHeader
(
parameterTypes
resultType
)
}
{
wgslOutputs
(
resultType
cases
.
length
)
}
compute
workgroup_size
(
1
)
fn
main
(
)
{
{
body
}
}
;
}
;
}
async
function
buildPipeline
(
t
shaderBuilder
shaderBuilderParams
outputBuffer
pipelineCache
)
{
const
{
parameterTypes
cases
inputSource
}
=
shaderBuilderParams
;
cases
.
forEach
(
(
c
)
=
>
{
const
inputTypes
=
c
.
input
instanceof
Array
?
c
.
input
.
map
(
(
i
)
=
>
i
.
type
)
:
[
c
.
input
.
type
]
;
if
(
!
objectEquals
(
inputTypes
parameterTypes
)
)
{
const
input_str
=
[
{
inputTypes
.
join
(
'
'
)
}
]
;
const
param_str
=
[
{
parameterTypes
.
join
(
'
'
)
}
]
;
throw
new
Error
(
case
input
types
{
input_str
}
do
not
match
provided
runner
parameter
types
{
param_str
}
)
;
}
}
)
;
const
source
=
shaderBuilder
(
shaderBuilderParams
)
;
switch
(
inputSource
)
{
case
'
const
'
:
{
const
module
=
t
.
device
.
createShaderModule
(
{
code
:
source
}
)
;
const
pipeline
=
await
t
.
device
.
createComputePipelineAsync
(
{
layout
:
'
auto
'
compute
:
{
module
entryPoint
:
'
main
'
}
}
)
;
const
group
=
t
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
outputBuffer
}
}
]
}
)
;
return
[
pipeline
group
]
;
}
case
'
uniform
'
:
case
'
storage_r
'
:
case
'
storage_rw
'
:
{
const
caseStride
=
structStride
(
parameterTypes
inputSource
)
;
const
inputSize
=
align
(
cases
.
length
*
caseStride
4
)
;
const
inputData
=
new
Uint8Array
(
inputSize
)
;
for
(
let
caseIdx
=
0
;
caseIdx
<
cases
.
length
;
caseIdx
+
+
)
{
const
offset
=
caseIdx
*
caseStride
;
structLayout
(
parameterTypes
inputSource
(
m
)
=
>
{
const
arg
=
cases
[
caseIdx
]
.
input
;
if
(
arg
instanceof
Array
)
{
arg
[
m
.
index
]
.
copyTo
(
inputData
offset
+
m
.
offset
)
;
}
else
{
arg
.
copyTo
(
inputData
offset
+
m
.
offset
)
;
}
}
)
;
}
const
pipeline
=
getOrCreate
(
pipelineCache
source
(
)
=
>
{
const
module
=
t
.
device
.
createShaderModule
(
{
code
:
source
}
)
;
return
t
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
entryPoint
:
'
main
'
}
}
)
;
}
)
;
const
inputBuffer
=
t
.
makeBufferWithContents
(
inputData
GPUBufferUsage
.
COPY_SRC
|
(
inputSource
=
=
=
'
uniform
'
?
GPUBufferUsage
.
UNIFORM
:
GPUBufferUsage
.
STORAGE
)
)
;
const
group
=
t
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
outputBuffer
}
}
{
binding
:
1
resource
:
{
buffer
:
inputBuffer
}
}
]
}
)
;
return
[
pipeline
group
]
;
}
}
}
export
function
packScalarsToVector
(
parameterTypes
resultType
cases
vectorWidth
)
{
for
(
let
i
=
0
;
i
<
parameterTypes
.
length
;
i
+
+
)
{
const
ty
=
parameterTypes
[
i
]
;
if
(
!
(
ty
instanceof
ScalarType
)
)
{
throw
new
Error
(
packScalarsToVector
(
)
can
only
be
used
on
scalar
parameter
types
but
the
{
i
}
'
th
parameter
type
is
a
{
ty
}
'
)
;
}
}
if
(
!
(
resultType
instanceof
ScalarType
)
)
{
throw
new
Error
(
packScalarsToVector
(
)
can
only
be
used
with
a
scalar
return
type
but
the
return
type
is
a
{
resultType
}
'
)
;
}
const
packedCases
=
[
]
;
const
packedParameterTypes
=
parameterTypes
.
map
(
(
p
)
=
>
Type
.
vec
(
vectorWidth
p
)
)
;
const
packedResultType
=
Type
.
vec
(
vectorWidth
resultType
)
;
const
clampCaseIdx
=
(
idx
)
=
>
Math
.
min
(
idx
cases
.
length
-
1
)
;
let
caseIdx
=
0
;
while
(
caseIdx
<
cases
.
length
)
{
const
packedInputs
=
new
Array
(
parameterTypes
.
length
)
;
for
(
let
paramIdx
=
0
;
paramIdx
<
parameterTypes
.
length
;
paramIdx
+
+
)
{
const
inputElements
=
new
Array
(
vectorWidth
)
;
for
(
let
i
=
0
;
i
<
vectorWidth
;
i
+
+
)
{
const
input
=
cases
[
clampCaseIdx
(
caseIdx
+
i
)
]
.
input
;
inputElements
[
i
]
=
input
instanceof
Array
?
input
[
paramIdx
]
:
input
;
}
packedInputs
[
paramIdx
]
=
new
VectorValue
(
inputElements
)
;
}
const
cmp_impls
=
new
Array
(
vectorWidth
)
;
for
(
let
i
=
0
;
i
<
vectorWidth
;
i
+
+
)
{
cmp_impls
[
i
]
=
toComparator
(
cases
[
clampCaseIdx
(
caseIdx
+
i
)
]
.
expected
)
.
compare
;
}
const
comparators
=
{
compare
:
(
got
)
=
>
{
let
matched
=
true
;
const
gElements
=
new
Array
(
vectorWidth
)
;
const
eElements
=
new
Array
(
vectorWidth
)
;
for
(
let
i
=
0
;
i
<
vectorWidth
;
i
+
+
)
{
const
d
=
cmp_impls
[
i
]
(
got
.
elements
[
i
]
)
;
matched
=
matched
&
&
d
.
matched
;
gElements
[
i
]
=
d
.
got
;
eElements
[
i
]
=
d
.
expected
;
}
return
{
matched
got
:
{
packedResultType
}
(
{
gElements
.
join
(
'
'
)
}
)
expected
:
{
packedResultType
}
(
{
eElements
.
join
(
'
'
)
}
)
}
;
}
kind
:
'
packed
'
}
;
packedCases
.
push
(
{
input
:
packedInputs
expected
:
comparators
}
)
;
caseIdx
+
=
vectorWidth
;
}
return
{
cases
:
packedCases
parameterTypes
:
packedParameterTypes
resultType
:
packedResultType
}
;
}
