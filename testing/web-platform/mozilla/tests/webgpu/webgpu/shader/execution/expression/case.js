import
{
crc32
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
crc32
.
js
'
;
import
{
assert
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
abstractInt
i32
u32
VectorValue
}
from
'
.
.
/
.
.
/
.
.
/
util
/
conversion
.
js
'
;
import
{
cartesianProduct
quantizeToI32
quantizeToI64
quantizeToU32
}
from
'
.
.
/
.
.
/
.
.
/
util
/
math
.
js
'
;
function
notUndefined
(
value
)
{
return
value
!
=
=
undefined
;
}
export
function
selectNCases
(
dis
n
cases
)
{
assert
(
n
>
0
&
&
Math
.
round
(
n
)
=
=
=
n
n
{
n
}
is
expected
to
be
a
positive
integer
)
;
const
count
=
cases
.
length
;
if
(
n
>
=
count
)
{
return
cases
;
}
const
dis_crc32
=
crc32
(
dis
)
;
return
cases
.
filter
(
(
c
)
=
>
Math
.
trunc
(
n
/
count
*
0xffff_ffff
)
>
(
crc32
(
c
.
input
.
toString
(
)
)
^
dis_crc32
)
>
>
>
0
)
;
}
function
makeScalarVectorBinaryToVectorCase
(
scalar
vector
op
quantize
scalarize
)
{
scalar
=
quantize
(
scalar
)
;
vector
=
vector
.
map
(
quantize
)
;
const
result
=
vector
.
map
(
(
v
)
=
>
op
(
scalar
v
)
)
;
if
(
result
.
includes
(
undefined
)
)
{
return
undefined
;
}
return
{
input
:
[
scalarize
(
scalar
)
new
VectorValue
(
vector
.
map
(
scalarize
)
)
]
expected
:
new
VectorValue
(
result
.
filter
(
notUndefined
)
.
map
(
scalarize
)
)
}
;
}
function
generateScalarVectorBinaryToVectorCases
(
scalars
vectors
op
quantize
scalarize
)
{
return
scalars
.
flatMap
(
(
s
)
=
>
{
return
vectors
.
map
(
(
v
)
=
>
{
return
makeScalarVectorBinaryToVectorCase
(
s
v
op
quantize
scalarize
)
;
}
)
.
filter
(
notUndefined
)
;
}
)
;
}
function
makeVectorScalarBinaryToVectorCase
(
vector
scalar
op
quantize
scalarize
)
{
vector
=
vector
.
map
(
quantize
)
;
scalar
=
quantize
(
scalar
)
;
const
result
=
vector
.
map
(
(
v
)
=
>
op
(
v
scalar
)
)
;
if
(
result
.
includes
(
undefined
)
)
{
return
undefined
;
}
return
{
input
:
[
new
VectorValue
(
vector
.
map
(
scalarize
)
)
scalarize
(
scalar
)
]
expected
:
new
VectorValue
(
result
.
filter
(
notUndefined
)
.
map
(
scalarize
)
)
}
;
}
function
generateVectorScalarBinaryToVectorCases
(
vectors
scalars
op
quantize
scalarize
)
{
return
scalars
.
flatMap
(
(
s
)
=
>
{
return
vectors
.
map
(
(
v
)
=
>
{
return
makeVectorScalarBinaryToVectorCase
(
v
s
op
quantize
scalarize
)
;
}
)
.
filter
(
notUndefined
)
;
}
)
;
}
export
function
generateU32VectorBinaryToVectorCases
(
scalars
vectors
op
)
{
return
generateScalarVectorBinaryToVectorCases
(
scalars
vectors
op
quantizeToU32
u32
)
;
}
export
function
generateVectorU32BinaryToVectorCases
(
vectors
scalars
op
)
{
return
generateVectorScalarBinaryToVectorCases
(
vectors
scalars
op
quantizeToU32
u32
)
;
}
export
function
generateI32VectorBinaryToVectorCases
(
scalars
vectors
op
)
{
return
generateScalarVectorBinaryToVectorCases
(
scalars
vectors
op
quantizeToI32
i32
)
;
}
export
function
generateVectorI32BinaryToVectorCases
(
vectors
scalars
op
)
{
return
generateVectorScalarBinaryToVectorCases
(
vectors
scalars
op
quantizeToI32
i32
)
;
}
export
function
generateI64VectorBinaryToVectorCases
(
scalars
vectors
op
)
{
return
generateScalarVectorBinaryToVectorCases
(
scalars
vectors
op
quantizeToI64
abstractInt
)
;
}
export
function
generateVectorI64BinaryToVectorCases
(
vectors
scalars
op
)
{
return
generateVectorScalarBinaryToVectorCases
(
vectors
scalars
op
quantizeToI64
abstractInt
)
;
}
function
generateScalarBinaryToScalarCases
(
param0s
param1s
op
quantize
scalarize
)
{
param0s
=
param0s
.
map
(
quantize
)
;
param1s
=
param1s
.
map
(
quantize
)
;
return
cartesianProduct
(
param0s
param1s
)
.
reduce
(
(
cases
e
)
=
>
{
const
expected
=
op
(
e
[
0
]
e
[
1
]
)
;
if
(
expected
!
=
=
undefined
)
{
cases
.
push
(
{
input
:
[
scalarize
(
e
[
0
]
)
scalarize
(
e
[
1
]
)
]
expected
:
scalarize
(
expected
)
}
)
;
}
return
cases
;
}
new
Array
(
)
)
;
}
export
function
generateBinaryToI32Cases
(
param0s
param1s
op
)
{
return
generateScalarBinaryToScalarCases
(
param0s
param1s
op
quantizeToI32
i32
)
;
}
export
function
generateBinaryToU32Cases
(
param0s
param1s
op
)
{
return
generateScalarBinaryToScalarCases
(
param0s
param1s
op
quantizeToU32
u32
)
;
}
export
function
generateBinaryToI64Cases
(
param0s
param1s
op
)
{
return
generateScalarBinaryToScalarCases
(
param0s
param1s
op
quantizeToI64
abstractInt
)
;
}
function
makeVectorVectorToScalarCase
(
param0
param1
op
quantize
scalarize
)
{
const
param0_quantized
=
param0
.
map
(
quantize
)
;
const
param1_quantized
=
param1
.
map
(
quantize
)
;
const
result
=
op
(
param0_quantized
param1_quantized
)
;
if
(
result
=
=
=
undefined
)
return
undefined
;
return
{
input
:
[
new
VectorValue
(
param0_quantized
.
map
(
scalarize
)
)
new
VectorValue
(
param1_quantized
.
map
(
scalarize
)
)
]
expected
:
scalarize
(
result
)
}
;
}
function
generateVectorVectorToScalarCases
(
param0s
param1s
op
quantize
scalarize
)
{
return
param0s
.
flatMap
(
(
param0
)
=
>
{
return
param1s
.
map
(
(
param1
)
=
>
{
return
makeVectorVectorToScalarCase
(
param0
param1
op
quantize
scalarize
)
;
}
)
.
filter
(
notUndefined
)
;
}
)
;
}
export
function
generateVectorVectorToI32Cases
(
param0s
param1s
op
)
{
return
generateVectorVectorToScalarCases
(
param0s
param1s
op
quantizeToI32
i32
)
;
}
export
function
generateVectorVectorToU32Cases
(
param0s
param1s
op
)
{
return
generateVectorVectorToScalarCases
(
param0s
param1s
op
quantizeToU32
u32
)
;
}
export
function
generateVectorVectorToI64Cases
(
param0s
param1s
op
)
{
return
generateVectorVectorToScalarCases
(
param0s
param1s
op
quantizeToI64
abstractInt
)
;
}
