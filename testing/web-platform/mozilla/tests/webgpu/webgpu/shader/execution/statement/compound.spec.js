export
const
description
=
Compound
statement
execution
.
;
import
{
makeTestGroup
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
framework
/
test_group
.
js
'
;
import
{
keysOf
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
data_tables
.
js
'
;
import
{
GPUTest
}
from
'
.
.
/
.
.
/
.
.
/
gpu_test
.
js
'
;
export
const
g
=
makeTestGroup
(
GPUTest
)
;
export
function
runStatementTest
(
t
ty
values
wgsl_main
)
{
const
wgsl
=
struct
Outputs
{
data
:
array
<
{
ty
}
>
}
;
var
<
private
>
count
:
u32
=
0
;
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
outputs
:
Outputs
;
fn
put
(
value
:
{
ty
}
)
{
outputs
.
data
[
count
]
=
value
;
count
+
=
1
;
}
compute
workgroup_size
(
1
)
fn
main
(
)
{
_
=
&
outputs
;
{
wgsl_main
}
}
;
const
pipeline
=
t
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
:
t
.
device
.
createShaderModule
(
{
code
:
wgsl
}
)
entryPoint
:
'
main
'
}
}
)
;
const
maxOutputValues
=
1000
;
const
outputBuffer
=
t
.
device
.
createBuffer
(
{
size
:
4
*
(
1
+
maxOutputValues
)
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_SRC
}
)
;
const
bindGroup
=
t
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
1
resource
:
{
buffer
:
outputBuffer
}
}
]
}
)
;
const
encoder
=
t
.
device
.
createCommandEncoder
(
)
;
const
pass
=
encoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
bindGroup
)
;
pass
.
dispatchWorkgroups
(
1
)
;
pass
.
end
(
)
;
t
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
t
.
expectGPUBufferValuesEqual
(
outputBuffer
values
)
;
}
const
kTests
=
{
uses
:
{
src
:
let
x
=
1
;
put
(
x
)
;
{
put
(
x
)
;
let
x
=
x
+
1
;
/
/
The
declaration
in
question
put
(
x
)
;
{
put
(
x
)
;
}
put
(
x
)
;
}
put
(
x
)
;
values
:
[
1
1
2
2
2
1
]
}
shadowed
:
{
src
:
let
x
=
1
;
put
(
x
)
;
{
put
(
x
)
;
let
x
=
x
+
1
;
/
/
The
declaration
in
question
put
(
x
)
;
{
let
x
=
x
+
1
;
/
/
A
shadow
put
(
x
)
;
}
put
(
x
)
;
}
put
(
x
)
;
values
:
[
1
1
2
3
2
1
]
}
gone
:
{
src
:
{
let
x
=
2
;
/
/
The
declaration
in
question
put
(
x
)
;
}
let
x
=
1
;
put
(
x
)
;
values
:
[
2
1
]
}
}
;
g
.
test
(
'
decl
'
)
.
desc
(
'
Tests
the
value
of
a
declared
value
in
a
compound
statment
.
'
)
.
params
(
(
u
)
=
>
u
.
combine
(
'
case
'
keysOf
(
kTests
)
)
)
.
fn
(
(
t
)
=
>
{
runStatementTest
(
t
'
i32
'
new
Int32Array
(
kTests
[
t
.
params
.
case
]
.
values
)
kTests
[
t
.
params
.
case
]
.
src
)
;
}
)
;
