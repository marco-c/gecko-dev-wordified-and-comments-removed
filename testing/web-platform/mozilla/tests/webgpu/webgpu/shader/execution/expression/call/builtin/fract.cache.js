import
{
assert
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
FP
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
floating_point
.
js
'
;
import
{
kFractTable
}
from
'
.
.
/
.
.
/
binary
/
af_data
.
js
'
;
import
{
makeCaseCache
}
from
'
.
.
/
.
.
/
case_cache
.
js
'
;
const
kCommonValues
=
[
0
.
5
0
.
9
1
2
1
.
11
-
0
.
1
-
0
.
5
-
0
.
9
-
1
-
2
-
1
.
11
]
;
const
kTraitSpecificValues
=
{
f32
:
[
10
.
0001
-
10
.
0001
0x8000_0000
]
f16
:
[
10
.
0078125
-
10
.
0078125
658
.
5
0x8000
]
}
;
const
concrete_cases
=
[
'
f32
'
'
f16
'
]
.
map
(
(
trait
)
=
>
(
{
[
{
trait
}
]
:
(
)
=
>
{
return
FP
[
trait
]
.
generateScalarToIntervalCases
(
[
.
.
.
kCommonValues
.
.
.
kTraitSpecificValues
[
trait
]
.
.
.
FP
[
trait
]
.
scalarRange
(
)
]
'
unfiltered
'
FP
[
trait
]
.
fractInterval
)
;
}
}
)
)
.
reduce
(
(
a
b
)
=
>
(
{
.
.
.
a
.
.
.
b
}
)
{
}
)
;
const
abstract_cases
=
(
)
=
>
{
return
FP
.
abstract
.
generateScalarToIntervalCases
(
[
.
.
.
kFractTable
.
keys
(
)
]
'
finite
'
(
x
)
=
>
{
assert
(
kFractTable
.
has
(
x
)
)
;
return
kFractTable
.
get
(
x
)
;
}
)
;
}
;
export
const
d
=
makeCaseCache
(
'
fract
'
{
abstract
:
abstract_cases
.
.
.
concrete_cases
}
)
;
