import
{
anyOf
skipUndefined
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
compare
.
js
'
;
import
{
f32
pack2x16float
u32
vec2
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
conversion
.
js
'
;
import
{
cartesianProduct
quantizeToF32
scalarF32Range
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
math
.
js
'
;
import
{
makeCaseCache
}
from
'
.
.
/
.
.
/
case_cache
.
js
'
;
function
makeCase
(
param0
param1
filter_undefined
)
{
param0
=
quantizeToF32
(
param0
)
;
param1
=
quantizeToF32
(
param1
)
;
const
results
=
pack2x16float
(
param0
param1
)
;
if
(
filter_undefined
&
&
results
.
some
(
(
r
)
=
>
r
=
=
=
undefined
)
)
{
return
undefined
;
}
return
{
input
:
[
vec2
(
f32
(
param0
)
f32
(
param1
)
)
]
expected
:
anyOf
(
.
.
.
results
.
map
(
(
r
)
=
>
r
=
=
=
undefined
?
skipUndefined
(
undefined
)
:
skipUndefined
(
u32
(
r
)
)
)
)
}
;
}
function
generateCases
(
param0s
param1s
filter_undefined
)
{
return
cartesianProduct
(
param0s
param1s
)
.
map
(
(
e
)
=
>
makeCase
(
e
[
0
]
e
[
1
]
filter_undefined
)
)
.
filter
(
(
c
)
=
>
c
!
=
=
undefined
)
;
}
export
const
d
=
makeCaseCache
(
'
pack2x16float
'
{
f32_const
:
(
)
=
>
{
return
generateCases
(
scalarF32Range
(
)
scalarF32Range
(
)
true
)
;
}
f32_non_const
:
(
)
=
>
{
return
generateCases
(
scalarF32Range
(
)
scalarF32Range
(
)
false
)
;
}
}
)
;
