import
{
checkElementsPassPredicate
}
from
'
.
.
/
.
.
/
.
.
/
util
/
check_contents
.
js
'
;
import
{
align
}
from
'
.
.
/
.
.
/
.
.
/
util
/
math
.
js
'
;
import
{
PRNG
}
from
'
.
.
/
.
.
/
.
.
/
util
/
prng
.
js
'
;
export
const
kAccessValueTypes
=
[
'
f16
'
'
u32
'
]
;
const
kWidth
=
4096
;
const
numMemLocations
=
2
;
const
numReadOutputs
=
2
;
const
numStressParams
=
12
;
const
barrierParamIndex
=
0
;
const
memStressIndex
=
1
;
const
memStressIterationsIndex
=
2
;
const
memStressPatternIndex
=
3
;
const
preStressIndex
=
4
;
const
preStressIterationsIndex
=
5
;
const
preStressPatternIndex
=
6
;
const
permuteFirstIndex
=
7
;
const
permuteSecondIndex
=
8
;
const
testingWorkgroupsIndex
=
9
;
const
memStrideIndex
=
10
;
const
memLocationOffsetIndex
=
11
;
const
bytesPerWord
=
4
;
function
shaderPreamble
(
accessValueType
constants
)
{
if
(
accessValueType
=
=
=
'
f16
'
)
{
return
enable
f16
;
\
nalias
AccessValueTy
=
f16
;
\
n
{
constants
}
\
n
;
}
return
alias
AccessValueTy
=
{
accessValueType
}
;
\
n
{
constants
}
\
n
;
}
export
class
MemoryModelTester
{
constructor
(
t
params
testShader
resultShader
accessValueType
=
'
u32
'
useTexture
=
false
)
{
this
.
prng
=
new
PRNG
(
1
)
;
this
.
test
=
t
;
this
.
params
=
params
;
this
.
useTexture
=
useTexture
;
const
workgroupXSize
=
Math
.
min
(
params
.
workgroupSize
t
.
device
.
limits
.
maxComputeWorkgroupSizeX
)
;
const
constants
=
const
kNumBarriers
=
1u
;
/
/
MAINTENANCE_TODO
:
make
barrier
not
an
array
const
kMaxWorkgroups
=
{
params
.
maxWorkgroups
}
u
;
const
kScratchMemorySize
=
{
params
.
scratchMemorySize
}
u
;
const
kWorkgroupXSize
=
{
workgroupXSize
}
u
;
;
testShader
=
shaderPreamble
(
accessValueType
constants
)
+
testShader
;
resultShader
=
shaderPreamble
(
accessValueType
constants
)
+
resultShader
;
const
testingThreads
=
workgroupXSize
*
this
.
params
.
testingWorkgroups
;
const
testLocationsSize
=
testingThreads
*
numMemLocations
*
this
.
params
.
memStride
*
bytesPerWord
;
const
testLocationsBuffer
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
label
:
'
testLocationsBuffer
'
size
:
testLocationsSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
label
:
'
testLocationsSrcBuf
'
size
:
testLocationsSize
usage
:
GPUBufferUsage
.
COPY_SRC
}
)
size
:
testLocationsSize
}
;
const
readResultsSize
=
testingThreads
*
numReadOutputs
*
bytesPerWord
;
const
readResultsBuffer
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
label
:
'
readResultsBuffer
'
size
:
readResultsSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
label
:
'
readResultsSrcBuf
'
size
:
readResultsSize
usage
:
GPUBufferUsage
.
COPY_SRC
}
)
size
:
readResultsSize
}
;
const
testResultsSize
=
this
.
params
.
numBehaviors
*
bytesPerWord
;
const
testResultsBuffer
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
label
:
'
testResultsBuffer
'
size
:
testResultsSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_SRC
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
label
:
'
testResultsSrcBuffer
'
size
:
testResultsSize
usage
:
GPUBufferUsage
.
COPY_SRC
}
)
size
:
testResultsSize
}
;
const
shuffledWorkgroupsSize
=
this
.
params
.
maxWorkgroups
*
bytesPerWord
;
const
shuffledWorkgroupsBuffer
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
shuffledWorkgroupsSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
shuffledWorkgroupsSize
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
MAP_WRITE
}
)
size
:
shuffledWorkgroupsSize
}
;
if
(
this
.
useTexture
)
{
const
numTexels
=
testLocationsSize
/
bytesPerWord
;
const
width
=
kWidth
;
const
height
=
numTexels
/
width
;
const
textureSize
=
{
width
height
}
;
const
textureLocations
=
{
deviceTex
:
this
.
test
.
device
.
createTexture
(
{
format
:
'
r32uint
'
dimension
:
'
2d
'
size
:
textureSize
usage
:
GPUTextureUsage
.
COPY_DST
|
GPUTextureUsage
.
STORAGE_BINDING
}
)
srcBuf
:
testLocationsBuffer
.
srcBuf
size
:
testLocationsSize
}
;
this
.
textures
=
{
testLocations
:
textureLocations
}
;
}
const
falseSharingAvoidanceQuantum
=
4096
;
const
barrierSize
=
align
(
bytesPerWord
falseSharingAvoidanceQuantum
)
;
const
scratchpadSize
=
align
(
this
.
params
.
scratchMemorySize
*
bytesPerWord
falseSharingAvoidanceQuantum
)
;
const
scratchMemoryLocationsSize
=
align
(
this
.
params
.
maxWorkgroups
*
bytesPerWord
falseSharingAvoidanceQuantum
)
;
const
comboSize
=
barrierSize
+
scratchpadSize
+
scratchMemoryLocationsSize
;
const
comboBuffer
=
this
.
test
.
device
.
createBuffer
(
{
label
:
'
comboBuffer
'
size
:
comboSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
}
)
;
const
barrierBuffer
=
{
deviceBuf
:
comboBuffer
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
label
:
'
barrierSrcBuf
'
size
:
barrierSize
usage
:
GPUBufferUsage
.
COPY_SRC
}
)
size
:
barrierSize
offset
:
0
}
;
const
scratchpadBuffer
=
{
deviceBuf
:
comboBuffer
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
label
:
'
scratchpadSrcBuf
'
size
:
scratchpadSize
usage
:
GPUBufferUsage
.
COPY_SRC
}
)
size
:
scratchpadSize
offset
:
barrierSize
}
;
const
scratchMemoryLocationsBuffer
=
{
deviceBuf
:
comboBuffer
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
label
:
'
scratchMemoryLocationsSrcBuf
'
size
:
scratchMemoryLocationsSize
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
MAP_WRITE
}
)
size
:
scratchMemoryLocationsSize
offset
:
barrierSize
+
scratchpadSize
}
;
const
stressParamsSize
=
numStressParams
*
bytesPerWord
;
const
stressParamsBuffer
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
label
:
'
stressParamsBuffer
'
size
:
stressParamsSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
UNIFORM
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
label
:
'
stressParamsSrcBuf
'
size
:
stressParamsSize
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
MAP_WRITE
}
)
size
:
stressParamsSize
}
;
this
.
buffers
=
{
testLocations
:
testLocationsBuffer
readResults
:
readResultsBuffer
testResults
:
testResultsBuffer
shuffledWorkgroups
:
shuffledWorkgroupsBuffer
barrier
:
barrierBuffer
scratchpad
:
scratchpadBuffer
scratchMemoryLocations
:
scratchMemoryLocationsBuffer
stressParams
:
stressParamsBuffer
}
;
const
testLayout
=
this
.
test
.
device
.
createBindGroupLayout
(
{
label
:
'
testLayout
'
entries
:
[
{
binding
:
0
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
1
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
2
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
read
-
only
-
storage
'
}
}
{
binding
:
3
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
4
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
uniform
'
}
}
]
}
)
;
let
layouts
=
[
testLayout
]
;
if
(
this
.
useTexture
)
{
const
textureLayout
=
this
.
test
.
device
.
createBindGroupLayout
(
{
label
:
'
textureLayout
'
entries
:
[
{
binding
:
0
visibility
:
GPUShaderStage
.
COMPUTE
storageTexture
:
{
access
:
'
read
-
write
'
format
:
'
r32uint
'
viewDimension
:
'
2d
'
}
}
]
}
)
;
layouts
=
[
testLayout
textureLayout
]
;
const
texLocations
=
this
.
textures
.
testLocations
.
deviceTex
;
this
.
textureBindGroup
=
this
.
test
.
device
.
createBindGroup
(
{
label
:
'
textureBindGroup
'
entries
:
[
{
binding
:
0
resource
:
texLocations
.
createView
(
)
}
]
layout
:
textureLayout
}
)
;
}
this
.
testPipeline
=
this
.
test
.
device
.
createComputePipeline
(
{
label
:
'
testPipeline
'
layout
:
this
.
test
.
device
.
createPipelineLayout
(
{
bindGroupLayouts
:
layouts
}
)
compute
:
{
module
:
this
.
test
.
device
.
createShaderModule
(
{
code
:
testShader
}
)
entryPoint
:
'
main
'
}
}
)
;
this
.
testBindGroup
=
this
.
test
.
device
.
createBindGroup
(
{
label
:
'
testBindGroup
'
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
this
.
buffers
.
testLocations
.
deviceBuf
}
}
{
binding
:
1
resource
:
{
buffer
:
this
.
buffers
.
readResults
.
deviceBuf
}
}
{
binding
:
2
resource
:
{
buffer
:
this
.
buffers
.
shuffledWorkgroups
.
deviceBuf
}
}
{
binding
:
3
resource
:
{
buffer
:
comboBuffer
}
}
{
binding
:
4
resource
:
{
buffer
:
this
.
buffers
.
stressParams
.
deviceBuf
}
}
]
layout
:
testLayout
}
)
;
const
resultLayout
=
this
.
test
.
device
.
createBindGroupLayout
(
{
label
:
'
resultLayout
'
entries
:
[
{
binding
:
0
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
1
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
2
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
3
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
uniform
'
}
}
]
}
)
;
this
.
resultPipeline
=
this
.
test
.
device
.
createComputePipeline
(
{
label
:
'
resultPipeline
'
layout
:
this
.
test
.
device
.
createPipelineLayout
(
{
bindGroupLayouts
:
[
resultLayout
]
}
)
compute
:
{
module
:
this
.
test
.
device
.
createShaderModule
(
{
code
:
resultShader
}
)
entryPoint
:
'
main
'
}
}
)
;
this
.
resultBindGroup
=
this
.
test
.
device
.
createBindGroup
(
{
label
:
'
resultBindGroup
'
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
this
.
buffers
.
testLocations
.
deviceBuf
}
}
{
binding
:
1
resource
:
{
buffer
:
this
.
buffers
.
readResults
.
deviceBuf
}
}
{
binding
:
2
resource
:
{
buffer
:
this
.
buffers
.
testResults
.
deviceBuf
}
}
{
binding
:
3
resource
:
{
buffer
:
this
.
buffers
.
stressParams
.
deviceBuf
}
}
]
layout
:
resultLayout
}
)
;
}
async
run
(
iterations
weakIndex
)
{
for
(
let
i
=
0
;
i
<
iterations
;
i
+
+
)
{
const
numWorkgroups
=
this
.
getRandomInRange
(
this
.
params
.
testingWorkgroups
this
.
params
.
maxWorkgroups
)
;
await
this
.
setShuffledWorkgroups
(
numWorkgroups
)
;
await
this
.
setScratchLocations
(
numWorkgroups
)
;
await
this
.
setStressParams
(
)
;
const
encoder
=
this
.
test
.
device
.
createCommandEncoder
(
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
testLocations
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
readResults
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
testResults
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
barrier
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
shuffledWorkgroups
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
scratchpad
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
scratchMemoryLocations
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
stressParams
)
;
if
(
this
.
useTexture
)
{
this
.
copyBufferToTexture
(
encoder
this
.
textures
.
testLocations
)
;
}
const
testPass
=
encoder
.
beginComputePass
(
)
;
testPass
.
setPipeline
(
this
.
testPipeline
)
;
testPass
.
setBindGroup
(
0
this
.
testBindGroup
)
;
if
(
this
.
useTexture
)
{
testPass
.
setBindGroup
(
1
this
.
textureBindGroup
)
;
}
testPass
.
dispatchWorkgroups
(
numWorkgroups
)
;
testPass
.
end
(
)
;
const
resultPass
=
encoder
.
beginComputePass
(
)
;
resultPass
.
setPipeline
(
this
.
resultPipeline
)
;
resultPass
.
setBindGroup
(
0
this
.
resultBindGroup
)
;
resultPass
.
dispatchWorkgroups
(
this
.
params
.
testingWorkgroups
)
;
resultPass
.
end
(
)
;
this
.
test
.
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
this
.
test
.
expectGPUBufferValuesPassCheck
(
this
.
buffers
.
testResults
.
deviceBuf
this
.
checkWeakIndex
(
weakIndex
)
{
type
:
Uint32Array
typedLength
:
this
.
params
.
numBehaviors
}
)
;
}
}
checkWeakIndex
(
weakIndex
)
{
const
checkResult
=
this
.
checkResult
(
weakIndex
)
;
const
resultPrinter
=
this
.
resultPrinter
(
weakIndex
)
;
return
function
(
a
)
{
return
checkElementsPassPredicate
(
a
checkResult
{
predicatePrinter
:
[
{
leftHeader
:
'
expected
=
=
'
getValueForCell
:
resultPrinter
}
]
}
)
;
}
;
}
checkResult
(
weakIndex
)
{
return
function
(
i
v
)
{
if
(
i
=
=
=
weakIndex
&
&
v
>
0
)
{
return
false
;
}
return
true
;
}
;
}
resultPrinter
(
weakIndex
)
{
return
function
(
i
)
{
if
(
i
=
=
=
weakIndex
)
{
return
0
;
}
else
{
return
'
any
value
'
;
}
}
;
}
copyBufferToBuffer
(
encoder
buffer
)
{
encoder
.
copyBufferToBuffer
(
buffer
.
srcBuf
0
buffer
.
deviceBuf
buffer
.
offset
|
|
0
buffer
.
size
)
;
}
copyBufferToTexture
(
encoder
texture
)
{
const
bytesPerWord
=
4
;
const
numTexels
=
texture
.
size
/
bytesPerWord
;
const
size
=
{
width
:
kWidth
height
:
numTexels
/
kWidth
}
;
encoder
.
copyBufferToTexture
(
{
buffer
:
texture
.
srcBuf
offset
:
0
bytesPerRow
:
kWidth
*
bytesPerWord
rowsPerImage
:
size
.
height
}
{
texture
:
texture
.
deviceTex
}
size
)
;
}
getRandomInt
(
max
)
{
return
this
.
prng
.
randomU32
(
)
%
max
;
}
getRandomInRange
(
min
max
)
{
if
(
min
=
=
=
max
)
{
return
min
;
}
else
{
const
offset
=
this
.
getRandomInt
(
max
-
min
)
;
return
min
+
offset
;
}
}
shuffleArray
(
a
)
{
for
(
let
i
=
a
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
toSwap
=
this
.
getRandomInt
(
i
+
1
)
;
const
temp
=
a
[
toSwap
]
;
a
[
toSwap
]
=
a
[
i
]
;
a
[
i
]
=
temp
;
}
}
async
setShuffledWorkgroups
(
numWorkgroups
)
{
await
this
.
buffers
.
shuffledWorkgroups
.
srcBuf
.
mapAsync
(
GPUMapMode
.
WRITE
)
;
const
shuffledWorkgroupsBuffer
=
this
.
buffers
.
shuffledWorkgroups
.
srcBuf
.
getMappedRange
(
)
;
const
shuffledWorkgroupsArray
=
new
Uint32Array
(
shuffledWorkgroupsBuffer
)
;
for
(
let
i
=
0
;
i
<
numWorkgroups
;
i
+
+
)
{
shuffledWorkgroupsArray
[
i
]
=
i
;
}
if
(
this
.
getRandomInt
(
100
)
<
this
.
params
.
shufflePct
)
{
for
(
let
i
=
numWorkgroups
-
1
;
i
>
0
;
i
-
-
)
{
const
x
=
this
.
getRandomInt
(
i
+
1
)
;
const
temp
=
shuffledWorkgroupsArray
[
i
]
;
shuffledWorkgroupsArray
[
i
]
=
shuffledWorkgroupsArray
[
x
]
;
shuffledWorkgroupsArray
[
x
]
=
temp
;
}
}
this
.
buffers
.
shuffledWorkgroups
.
srcBuf
.
unmap
(
)
;
}
async
setScratchLocations
(
numWorkgroups
)
{
await
this
.
buffers
.
scratchMemoryLocations
.
srcBuf
.
mapAsync
(
GPUMapMode
.
WRITE
)
;
const
scratchLocationsArrayBuffer
=
this
.
buffers
.
scratchMemoryLocations
.
srcBuf
.
getMappedRange
(
)
;
const
scratchLocationsArray
=
new
Uint32Array
(
scratchLocationsArrayBuffer
)
;
const
scratchNumRegions
=
this
.
params
.
scratchMemorySize
/
this
.
params
.
stressLineSize
;
const
scratchRegions
=
[
.
.
.
Array
(
scratchNumRegions
)
.
keys
(
)
]
;
this
.
shuffleArray
(
scratchRegions
)
;
for
(
let
i
=
0
;
i
<
this
.
params
.
stressTargetLines
;
i
+
+
)
{
const
region
=
scratchRegions
[
i
]
;
const
locInRegion
=
this
.
getRandomInt
(
this
.
params
.
stressLineSize
)
;
if
(
this
.
getRandomInt
(
100
)
<
this
.
params
.
stressStrategyBalancePct
)
{
for
(
let
j
=
i
;
j
<
numWorkgroups
;
j
+
=
this
.
params
.
stressTargetLines
)
{
scratchLocationsArray
[
j
]
=
region
*
this
.
params
.
stressLineSize
+
locInRegion
;
}
}
else
{
const
workgroupsPerLocation
=
numWorkgroups
/
this
.
params
.
stressTargetLines
;
for
(
let
j
=
0
;
j
<
workgroupsPerLocation
;
j
+
+
)
{
scratchLocationsArray
[
i
*
workgroupsPerLocation
+
j
]
=
region
*
this
.
params
.
stressLineSize
+
locInRegion
;
}
if
(
i
=
=
=
this
.
params
.
stressTargetLines
-
1
&
&
numWorkgroups
%
this
.
params
.
stressTargetLines
!
=
=
0
)
{
for
(
let
j
=
0
;
j
<
numWorkgroups
%
this
.
params
.
stressTargetLines
;
j
+
+
)
{
scratchLocationsArray
[
numWorkgroups
-
j
-
1
]
=
region
*
this
.
params
.
stressLineSize
+
locInRegion
;
}
}
}
}
this
.
buffers
.
scratchMemoryLocations
.
srcBuf
.
unmap
(
)
;
}
async
setStressParams
(
)
{
await
this
.
buffers
.
stressParams
.
srcBuf
.
mapAsync
(
GPUMapMode
.
WRITE
)
;
const
stressParamsArrayBuffer
=
this
.
buffers
.
stressParams
.
srcBuf
.
getMappedRange
(
)
;
const
stressParamsArray
=
new
Uint32Array
(
stressParamsArrayBuffer
)
;
if
(
this
.
getRandomInt
(
100
)
<
this
.
params
.
barrierPct
)
{
stressParamsArray
[
barrierParamIndex
]
=
1
;
}
else
{
stressParamsArray
[
barrierParamIndex
]
=
0
;
}
if
(
this
.
getRandomInt
(
100
)
<
this
.
params
.
memStressPct
)
{
stressParamsArray
[
memStressIndex
]
=
1
;
}
else
{
stressParamsArray
[
memStressIndex
]
=
0
;
}
stressParamsArray
[
memStressIterationsIndex
]
=
this
.
params
.
memStressIterations
;
const
memStressStoreFirst
=
this
.
getRandomInt
(
100
)
<
this
.
params
.
memStressStoreFirstPct
;
const
memStressStoreSecond
=
this
.
getRandomInt
(
100
)
<
this
.
params
.
memStressStoreSecondPct
;
let
memStressPattern
;
if
(
memStressStoreFirst
&
&
memStressStoreSecond
)
{
memStressPattern
=
0
;
}
else
if
(
memStressStoreFirst
&
&
!
memStressStoreSecond
)
{
memStressPattern
=
1
;
}
else
if
(
!
memStressStoreFirst
&
&
memStressStoreSecond
)
{
memStressPattern
=
2
;
}
else
{
memStressPattern
=
3
;
}
stressParamsArray
[
memStressPatternIndex
]
=
memStressPattern
;
if
(
this
.
getRandomInt
(
100
)
<
this
.
params
.
preStressPct
)
{
stressParamsArray
[
preStressIndex
]
=
1
;
}
else
{
stressParamsArray
[
preStressIndex
]
=
0
;
}
stressParamsArray
[
preStressIterationsIndex
]
=
this
.
params
.
preStressIterations
;
const
preStressStoreFirst
=
this
.
getRandomInt
(
100
)
<
this
.
params
.
preStressStoreFirstPct
;
const
preStressStoreSecond
=
this
.
getRandomInt
(
100
)
<
this
.
params
.
preStressStoreSecondPct
;
let
preStressPattern
;
if
(
preStressStoreFirst
&
&
preStressStoreSecond
)
{
preStressPattern
=
0
;
}
else
if
(
preStressStoreFirst
&
&
!
preStressStoreSecond
)
{
preStressPattern
=
1
;
}
else
if
(
!
preStressStoreFirst
&
&
preStressStoreSecond
)
{
preStressPattern
=
2
;
}
else
{
preStressPattern
=
3
;
}
stressParamsArray
[
preStressPatternIndex
]
=
preStressPattern
;
stressParamsArray
[
permuteFirstIndex
]
=
this
.
params
.
permuteFirst
;
stressParamsArray
[
permuteSecondIndex
]
=
this
.
params
.
permuteSecond
;
stressParamsArray
[
testingWorkgroupsIndex
]
=
this
.
params
.
testingWorkgroups
;
stressParamsArray
[
memStrideIndex
]
=
this
.
params
.
memStride
;
if
(
this
.
params
.
aliasedMemory
)
{
stressParamsArray
[
memLocationOffsetIndex
]
=
0
;
}
else
{
stressParamsArray
[
memLocationOffsetIndex
]
=
this
.
params
.
memStride
;
}
this
.
buffers
.
stressParams
.
srcBuf
.
unmap
(
)
;
}
}
const
shaderMemStructures
=
struct
Memory
{
value
:
array
<
AccessValueTy
>
}
;
struct
AtomicMemory
{
value
:
array
<
atomic
<
u32
>
>
}
;
struct
IndexMemory
{
value
:
array
<
u32
>
}
;
struct
AtomicMemoryBarrier
{
value
:
array
<
atomic
<
u32
>
kNumBarriers
>
}
;
struct
IndexMemoryScratchpad
{
value
:
array
<
u32
kMaxWorkgroups
>
}
;
struct
IndexMemoryScratchLocations
{
value
:
array
<
u32
kScratchMemorySize
>
}
;
struct
ReadResult
{
r0
:
atomic
<
u32
>
r1
:
atomic
<
u32
>
}
;
struct
ReadResults
{
value
:
array
<
ReadResult
>
}
;
/
/
These
arrays
are
combine
into
1
buffer
because
compat
mode
only
supports
4
storage
buffers
by
default
.
struct
CombinedData
{
barrier
:
AtomicMemoryBarrier
scratchpad
:
IndexMemoryScratchpad
scratch_locations
:
IndexMemoryScratchLocations
}
;
struct
StressParamsMemory
{
do_barrier
:
u32
mem_stress
:
u32
mem_stress_iterations
:
u32
mem_stress_pattern
:
u32
pre_stress
:
u32
pre_stress_iterations
:
u32
pre_stress_pattern
:
u32
permute_first
:
u32
permute_second
:
u32
testing_workgroups
:
u32
mem_stride
:
u32
location_offset
:
u32
}
;
;
const
fourBehaviorTestResultStructure
=
struct
TestResults
{
seq0
:
atomic
<
u32
>
seq1
:
atomic
<
u32
>
interleaved
:
atomic
<
u32
>
weak
:
atomic
<
u32
>
}
;
;
const
twoBehaviorTestResultStructure
=
struct
TestResults
{
seq
:
atomic
<
u32
>
weak
:
atomic
<
u32
>
}
;
;
const
commonTestShaderBindings
=
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
results
:
ReadResults
;
group
(
0
)
binding
(
2
)
var
<
storage
read
>
shuffled_workgroups
:
IndexMemory
;
group
(
0
)
binding
(
3
)
var
<
storage
read_write
>
combo
:
CombinedData
;
group
(
0
)
binding
(
4
)
var
<
uniform
>
stress_params
:
StressParamsMemory
;
;
const
atomicTestShaderBindings
=
[
group
(
0
)
binding
(
0
)
var
<
storage
read_write
>
test_locations
:
AtomicMemory
;
commonTestShaderBindings
]
.
join
(
'
\
n
'
)
;
const
nonAtomicTestShaderBindings
=
[
group
(
0
)
binding
(
0
)
var
<
storage
read_write
>
test_locations
:
Memory
;
commonTestShaderBindings
]
.
join
(
'
\
n
'
)
;
const
textureBindings
=
group
(
1
)
binding
(
0
)
var
texture_locations
:
texture_storage_2d
<
r32uint
read_write
>
;
;
const
resultShaderBindings
=
group
(
0
)
binding
(
0
)
var
<
storage
read_write
>
test_locations
:
Memory
;
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
read_results
:
ReadResults
;
group
(
0
)
binding
(
2
)
var
<
storage
read_write
>
test_results
:
TestResults
;
group
(
0
)
binding
(
3
)
var
<
uniform
>
stress_params
:
StressParamsMemory
;
;
const
atomicWorkgroupMemory
=
var
<
workgroup
>
wg_test_locations
:
array
<
atomic
<
u32
>
3584
>
;
;
const
nonAtomicWorkgroupMemory
=
var
<
workgroup
>
wg_test_locations
:
array
<
AccessValueTy
3584
>
;
;
const
memoryLocationFunctions
=
fn
permute_id
(
id
:
u32
factor
:
u32
mask
:
u32
)
-
>
u32
{
return
(
id
*
factor
)
%
mask
;
}
fn
stripe_workgroup
(
workgroup_id
:
u32
local_id
:
u32
)
-
>
u32
{
return
(
workgroup_id
+
1u
+
local_id
%
(
stress_params
.
testing_workgroups
-
1u
)
)
%
stress_params
.
testing_workgroups
;
}
;
const
textureFunctions
=
const
kWidth
=
{
kWidth
}
;
fn
indexToCoord
(
idx
:
u32
)
-
>
vec2u
{
return
vec2u
(
idx
%
kWidth
idx
/
kWidth
)
;
}
;
const
testShaderFunctions
=
/
/
Force
the
invocations
in
the
workgroup
to
wait
for
each
other
but
without
the
general
memory
ordering
/
/
effects
of
a
control
barrier
.
The
barrier
spins
until
either
all
invocations
have
incremented
the
atomic
/
/
variable
or
1024
loops
have
occurred
.
1024
was
chosen
because
it
gives
more
time
for
invocations
to
enter
/
/
the
barrier
but
does
not
overly
reduce
testing
throughput
.
fn
spin
(
limit
:
u32
)
{
var
i
:
u32
=
0u
;
var
bar_val
:
u32
=
atomicAdd
(
&
combo
.
barrier
.
value
[
0
]
1u
)
;
loop
{
if
(
i
=
=
1024u
|
|
bar_val
>
=
limit
)
{
break
;
}
bar_val
=
atomicAdd
(
&
combo
.
barrier
.
value
[
0
]
0u
)
;
i
=
i
+
1u
;
}
}
/
/
Perform
iterations
of
stress
depending
on
the
specified
pattern
.
Pattern
0
is
store
-
store
pattern
1
is
store
-
load
/
/
pattern
2
is
load
-
store
and
pattern
3
is
load
-
load
.
The
extra
if
condition
(
if
tmpX
>
100000u
)
is
used
to
avoid
/
/
the
compiler
optimizing
out
unused
loads
where
100
000
is
larger
than
the
maximum
number
of
stress
iterations
used
/
/
in
any
test
.
fn
do_stress
(
iterations
:
u32
pattern
:
u32
workgroup_id
:
u32
)
{
let
addr
=
combo
.
scratch_locations
.
value
[
workgroup_id
]
;
switch
(
pattern
)
{
case
0u
:
{
for
(
var
i
:
u32
=
0u
;
i
<
iterations
;
i
=
i
+
1u
)
{
combo
.
scratchpad
.
value
[
addr
]
=
i
;
combo
.
scratchpad
.
value
[
addr
]
=
i
+
1u
;
}
}
case
1u
:
{
for
(
var
i
:
u32
=
0u
;
i
<
iterations
;
i
=
i
+
1u
)
{
combo
.
scratchpad
.
value
[
addr
]
=
i
;
let
tmp1
:
u32
=
combo
.
scratchpad
.
value
[
addr
]
;
if
(
tmp1
>
100000u
)
{
combo
.
scratchpad
.
value
[
addr
]
=
i
;
break
;
}
}
}
case
2u
:
{
for
(
var
i
:
u32
=
0u
;
i
<
iterations
;
i
=
i
+
1u
)
{
let
tmp1
:
u32
=
combo
.
scratchpad
.
value
[
addr
]
;
if
(
tmp1
>
100000u
)
{
combo
.
scratchpad
.
value
[
addr
]
=
i
;
break
;
}
combo
.
scratchpad
.
value
[
addr
]
=
i
;
}
}
case
3u
:
{
for
(
var
i
:
u32
=
0u
;
i
<
iterations
;
i
=
i
+
1u
)
{
let
tmp1
:
u32
=
combo
.
scratchpad
.
value
[
addr
]
;
if
(
tmp1
>
100000u
)
{
combo
.
scratchpad
.
value
[
addr
]
=
i
;
break
;
}
let
tmp2
:
u32
=
combo
.
scratchpad
.
value
[
addr
]
;
if
(
tmp2
>
100000u
)
{
combo
.
scratchpad
.
value
[
addr
]
=
i
;
break
;
}
}
}
default
:
{
}
}
}
;
const
shaderEntryPoint
=
/
/
Change
to
pipeline
overridable
constant
when
possible
.
const
workgroupXSize
=
kWorkgroupXSize
;
compute
workgroup_size
(
workgroupXSize
)
fn
main
(
builtin
(
local_invocation_id
)
local_invocation_id
:
vec3
<
u32
>
builtin
(
workgroup_id
)
workgroup_id
:
vec3
<
u32
>
)
{
;
const
testShaderCommonHeader
=
let
shuffled_workgroup
=
shuffled_workgroups
.
value
[
workgroup_id
[
0
]
]
;
if
(
shuffled_workgroup
<
stress_params
.
testing_workgroups
)
{
;
const
testShaderCommonCalculations
=
let
x_0
=
id_0
*
stress_params
.
mem_stride
*
2u
;
let
y_0
=
permute_id
(
id_0
stress_params
.
permute_second
total_ids
)
*
stress_params
.
mem_stride
*
2u
+
stress_params
.
location_offset
;
let
x_1
=
id_1
*
stress_params
.
mem_stride
*
2u
;
let
y_1
=
permute_id
(
id_1
stress_params
.
permute_second
total_ids
)
*
stress_params
.
mem_stride
*
2u
+
stress_params
.
location_offset
;
if
(
stress_params
.
pre_stress
=
=
1u
)
{
do_stress
(
stress_params
.
pre_stress_iterations
stress_params
.
pre_stress_pattern
shuffled_workgroup
)
;
}
;
const
interWorkgroupTestShaderCode
=
[
let
total_ids
=
workgroupXSize
*
stress_params
.
testing_workgroups
;
let
id_0
=
shuffled_workgroup
*
workgroupXSize
+
local_invocation_id
[
0
]
;
let
new_workgroup
=
stripe_workgroup
(
shuffled_workgroup
local_invocation_id
[
0
]
)
;
let
id_1
=
new_workgroup
*
workgroupXSize
+
permute_id
(
local_invocation_id
[
0
]
stress_params
.
permute_first
workgroupXSize
)
;
testShaderCommonCalculations
if
(
stress_params
.
do_barrier
=
=
1u
)
{
spin
(
workgroupXSize
*
stress_params
.
testing_workgroups
)
;
}
]
.
join
(
'
\
n
'
)
;
const
intraWorkgroupTestShaderCode
=
[
let
total_ids
=
workgroupXSize
;
let
id_0
=
local_invocation_id
[
0
]
;
let
id_1
=
permute_id
(
local_invocation_id
[
0
]
stress_params
.
permute_first
workgroupXSize
)
;
testShaderCommonCalculations
if
(
stress_params
.
do_barrier
=
=
1u
)
{
spin
(
workgroupXSize
)
;
}
]
.
join
(
'
\
n
'
)
;
const
storageIntraWorkgroupTestShaderCode
=
let
total_ids
=
workgroupXSize
;
let
id_0
=
local_invocation_id
[
0
]
;
let
id_1
=
permute_id
(
local_invocation_id
[
0
]
stress_params
.
permute_first
workgroupXSize
)
;
let
x_0
=
(
shuffled_workgroup
*
workgroupXSize
+
id_0
)
*
stress_params
.
mem_stride
*
2u
;
let
y_0
=
(
shuffled_workgroup
*
workgroupXSize
+
permute_id
(
id_0
stress_params
.
permute_second
total_ids
)
)
*
stress_params
.
mem_stride
*
2u
+
stress_params
.
location_offset
;
let
x_1
=
(
shuffled_workgroup
*
workgroupXSize
+
id_1
)
*
stress_params
.
mem_stride
*
2u
;
let
y_1
=
(
shuffled_workgroup
*
workgroupXSize
+
permute_id
(
id_1
stress_params
.
permute_second
total_ids
)
)
*
stress_params
.
mem_stride
*
2u
+
stress_params
.
location_offset
;
if
(
stress_params
.
pre_stress
=
=
1u
)
{
do_stress
(
stress_params
.
pre_stress_iterations
stress_params
.
pre_stress_pattern
shuffled_workgroup
)
;
}
if
(
stress_params
.
do_barrier
=
=
1u
)
{
spin
(
workgroupXSize
)
;
}
;
const
testShaderCommonFooter
=
}
else
if
(
stress_params
.
mem_stress
=
=
1u
)
{
do_stress
(
stress_params
.
mem_stress_iterations
stress_params
.
mem_stress_pattern
shuffled_workgroup
)
;
}
}
;
const
resultShaderCommonCalculations
=
let
id_0
=
workgroup_id
[
0
]
*
workgroupXSize
+
local_invocation_id
[
0
]
;
let
x_0
=
id_0
*
stress_params
.
mem_stride
*
2u
;
let
mem_x_0
=
u32
(
test_locations
.
value
[
x_0
]
)
;
let
r0
=
atomicLoad
(
&
read_results
.
value
[
id_0
]
.
r0
)
;
let
r1
=
atomicLoad
(
&
read_results
.
value
[
id_0
]
.
r1
)
;
;
const
interWorkgroupResultShaderCode
=
[
resultShaderCommonCalculations
let
total_ids
=
workgroupXSize
*
stress_params
.
testing_workgroups
;
let
y_0
=
permute_id
(
id_0
stress_params
.
permute_second
total_ids
)
*
stress_params
.
mem_stride
*
2u
+
stress_params
.
location_offset
;
let
mem_y_0
=
u32
(
test_locations
.
value
[
y_0
]
)
;
]
.
join
(
'
\
n
'
)
;
const
intraWorkgroupResultShaderCode
=
[
resultShaderCommonCalculations
let
total_ids
=
workgroupXSize
;
let
y_0
=
(
workgroup_id
[
0
]
*
workgroupXSize
+
permute_id
(
local_invocation_id
[
0
]
stress_params
.
permute_second
total_ids
)
)
*
stress_params
.
mem_stride
*
2u
+
stress_params
.
location_offset
;
let
mem_y_0
=
u32
(
test_locations
.
value
[
y_0
]
)
;
]
.
join
(
'
\
n
'
)
;
const
resultShaderCommonFooter
=
}
;
const
storageMemoryAtomicTestShaderCode
=
[
shaderMemStructures
atomicTestShaderBindings
memoryLocationFunctions
testShaderFunctions
shaderEntryPoint
testShaderCommonHeader
]
.
join
(
'
\
n
'
)
;
const
storageMemoryNonAtomicTestShaderCode
=
[
shaderMemStructures
nonAtomicTestShaderBindings
memoryLocationFunctions
testShaderFunctions
shaderEntryPoint
testShaderCommonHeader
]
.
join
(
'
\
n
'
)
;
const
textureMemoryNonAtomicTestShaderCode
=
[
shaderMemStructures
nonAtomicTestShaderBindings
textureBindings
memoryLocationFunctions
textureFunctions
testShaderFunctions
shaderEntryPoint
testShaderCommonHeader
]
.
join
(
'
\
n
'
)
;
const
workgroupMemoryAtomicTestShaderCode
=
[
shaderMemStructures
atomicTestShaderBindings
atomicWorkgroupMemory
memoryLocationFunctions
testShaderFunctions
shaderEntryPoint
testShaderCommonHeader
]
.
join
(
'
\
n
'
)
;
const
workgroupMemoryNonAtomicTestShaderCode
=
[
shaderMemStructures
nonAtomicTestShaderBindings
nonAtomicWorkgroupMemory
memoryLocationFunctions
testShaderFunctions
shaderEntryPoint
testShaderCommonHeader
]
.
join
(
'
\
n
'
)
;
const
resultShaderCommonCode
=
[
shaderMemStructures
resultShaderBindings
memoryLocationFunctions
shaderEntryPoint
]
.
join
(
'
\
n
'
)
;
export
let
MemoryType
=
function
(
MemoryType
)
{
MemoryType
[
"
AtomicStorageClass
"
]
=
"
atomic_storage
"
;
MemoryType
[
"
NonAtomicStorageClass
"
]
=
"
non_atomic_storage
"
;
MemoryType
[
"
AtomicWorkgroupClass
"
]
=
"
atomic_workgroup
"
;
MemoryType
[
"
NonAtomicWorkgroupClass
"
]
=
"
non_atomic_workgroup
"
;
MemoryType
[
"
NonAtomicTextureClass
"
]
=
"
non_atomic_texture
"
;
return
MemoryType
;
}
(
{
}
)
;
export
let
TestType
=
function
(
TestType
)
{
TestType
[
"
InterWorkgroup
"
]
=
"
inter_workgroup
"
;
TestType
[
"
IntraWorkgroup
"
]
=
"
intra_workgroup
"
;
return
TestType
;
}
(
{
}
)
;
export
let
ResultType
=
function
(
ResultType
)
{
ResultType
[
ResultType
[
"
TwoBehavior
"
]
=
0
]
=
"
TwoBehavior
"
;
ResultType
[
ResultType
[
"
FourBehavior
"
]
=
1
]
=
"
FourBehavior
"
;
return
ResultType
;
}
(
{
}
)
;
export
function
buildTestShader
(
testCode
memoryType
testType
)
{
let
memoryTypeCode
;
let
isGlobalSpace
=
false
;
switch
(
memoryType
)
{
case
MemoryType
.
AtomicStorageClass
:
memoryTypeCode
=
storageMemoryAtomicTestShaderCode
;
isGlobalSpace
=
true
;
break
;
case
MemoryType
.
NonAtomicStorageClass
:
memoryTypeCode
=
storageMemoryNonAtomicTestShaderCode
;
isGlobalSpace
=
true
;
break
;
case
MemoryType
.
AtomicWorkgroupClass
:
memoryTypeCode
=
workgroupMemoryAtomicTestShaderCode
;
break
;
case
MemoryType
.
NonAtomicWorkgroupClass
:
memoryTypeCode
=
workgroupMemoryNonAtomicTestShaderCode
;
break
;
case
MemoryType
.
NonAtomicTextureClass
:
memoryTypeCode
=
textureMemoryNonAtomicTestShaderCode
;
isGlobalSpace
=
true
;
break
;
}
let
testTypeCode
;
switch
(
testType
)
{
case
TestType
.
InterWorkgroup
:
testTypeCode
=
interWorkgroupTestShaderCode
;
break
;
case
TestType
.
IntraWorkgroup
:
if
(
isGlobalSpace
)
{
testTypeCode
=
storageIntraWorkgroupTestShaderCode
;
}
else
{
testTypeCode
=
intraWorkgroupTestShaderCode
;
}
}
return
[
memoryTypeCode
testTypeCode
testCode
testShaderCommonFooter
]
.
join
(
'
\
n
'
)
;
}
export
function
buildResultShader
(
resultCode
testType
resultType
)
{
let
resultStructure
;
switch
(
resultType
)
{
case
ResultType
.
TwoBehavior
:
resultStructure
=
twoBehaviorTestResultStructure
;
break
;
case
ResultType
.
FourBehavior
:
resultStructure
=
fourBehaviorTestResultStructure
;
}
let
testTypeCode
;
switch
(
testType
)
{
case
TestType
.
InterWorkgroup
:
testTypeCode
=
interWorkgroupResultShaderCode
;
break
;
case
TestType
.
IntraWorkgroup
:
testTypeCode
=
intraWorkgroupResultShaderCode
;
}
return
[
resultStructure
resultShaderCommonCode
testTypeCode
resultCode
resultShaderCommonFooter
]
.
join
(
'
\
n
'
)
;
}
