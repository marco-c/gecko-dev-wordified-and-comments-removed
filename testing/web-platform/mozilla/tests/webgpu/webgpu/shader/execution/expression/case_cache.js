import
{
dataCache
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
framework
/
data_cache
.
js
'
;
import
{
unreachable
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
BinaryStream
from
'
.
.
/
.
.
/
.
.
/
util
/
binary_stream
.
js
'
;
import
{
deserializeComparator
serializeComparator
}
from
'
.
.
/
.
.
/
.
.
/
util
/
compare
.
js
'
;
import
{
MatrixValue
VectorValue
deserializeValue
isScalarValue
serializeValue
}
from
'
.
.
/
.
.
/
.
.
/
util
/
conversion
.
js
'
;
import
{
FPInterval
deserializeFPInterval
serializeFPInterval
}
from
'
.
.
/
.
.
/
.
.
/
util
/
floating_point
.
js
'
;
import
{
flatten2DArray
unflatten2DArray
}
from
'
.
.
/
.
.
/
.
.
/
util
/
math
.
js
'
;
import
{
isComparator
}
from
'
.
/
expectation
.
js
'
;
var
SerializedExpectationKind
=
function
(
SerializedExpectationKind
)
{
SerializedExpectationKind
[
SerializedExpectationKind
[
"
Value
"
]
=
0
]
=
"
Value
"
;
SerializedExpectationKind
[
SerializedExpectationKind
[
"
Interval
"
]
=
1
]
=
"
Interval
"
;
SerializedExpectationKind
[
SerializedExpectationKind
[
"
Interval1DArray
"
]
=
2
]
=
"
Interval1DArray
"
;
SerializedExpectationKind
[
SerializedExpectationKind
[
"
Interval2DArray
"
]
=
3
]
=
"
Interval2DArray
"
;
SerializedExpectationKind
[
SerializedExpectationKind
[
"
Array
"
]
=
4
]
=
"
Array
"
;
SerializedExpectationKind
[
SerializedExpectationKind
[
"
Comparator
"
]
=
5
]
=
"
Comparator
"
;
return
SerializedExpectationKind
;
}
(
SerializedExpectationKind
|
|
{
}
)
;
export
function
serializeExpectation
(
s
e
)
{
if
(
isScalarValue
(
e
)
|
|
e
instanceof
VectorValue
|
|
e
instanceof
MatrixValue
)
{
s
.
writeU8
(
SerializedExpectationKind
.
Value
)
;
serializeValue
(
s
e
)
;
return
;
}
if
(
e
instanceof
FPInterval
)
{
s
.
writeU8
(
SerializedExpectationKind
.
Interval
)
;
serializeFPInterval
(
s
e
)
;
return
;
}
if
(
e
instanceof
Array
)
{
if
(
e
[
0
]
instanceof
Array
)
{
e
=
e
;
const
cols
=
e
.
length
;
const
rows
=
e
[
0
]
.
length
;
s
.
writeU8
(
SerializedExpectationKind
.
Interval2DArray
)
;
s
.
writeU16
(
cols
)
;
s
.
writeU16
(
rows
)
;
s
.
writeArray
(
flatten2DArray
(
e
)
serializeFPInterval
)
;
}
else
{
e
=
e
;
s
.
writeU8
(
SerializedExpectationKind
.
Interval1DArray
)
;
s
.
writeArray
(
e
serializeFPInterval
)
;
}
return
;
}
if
(
isComparator
(
e
)
)
{
s
.
writeU8
(
SerializedExpectationKind
.
Comparator
)
;
serializeComparator
(
s
e
)
;
return
;
}
unreachable
(
cannot
serialize
Expectation
{
e
}
)
;
}
export
function
deserializeExpectation
(
s
)
{
const
kind
=
s
.
readU8
(
)
;
switch
(
kind
)
{
case
SerializedExpectationKind
.
Value
:
{
return
deserializeValue
(
s
)
;
}
case
SerializedExpectationKind
.
Interval
:
{
return
deserializeFPInterval
(
s
)
;
}
case
SerializedExpectationKind
.
Interval1DArray
:
{
return
s
.
readArray
(
deserializeFPInterval
)
;
}
case
SerializedExpectationKind
.
Interval2DArray
:
{
const
cols
=
s
.
readU16
(
)
;
const
rows
=
s
.
readU16
(
)
;
return
unflatten2DArray
(
s
.
readArray
(
deserializeFPInterval
)
cols
rows
)
;
}
case
SerializedExpectationKind
.
Comparator
:
{
return
deserializeComparator
(
s
)
;
}
default
:
{
unreachable
(
invalid
serialized
expectation
kind
:
{
kind
}
)
;
}
}
}
export
function
serializeCase
(
s
c
)
{
s
.
writeCond
(
c
.
input
instanceof
Array
{
if_true
:
(
)
=
>
{
s
.
writeArray
(
c
.
input
serializeValue
)
;
}
if_false
:
(
)
=
>
{
serializeValue
(
s
c
.
input
)
;
}
}
)
;
serializeExpectation
(
s
c
.
expected
)
;
}
export
function
deserializeCase
(
s
)
{
const
input
=
s
.
readCond
(
{
if_true
:
(
)
=
>
{
return
s
.
readArray
(
deserializeValue
)
;
}
if_false
:
(
)
=
>
{
return
deserializeValue
(
s
)
;
}
}
)
;
const
expected
=
deserializeExpectation
(
s
)
;
return
{
input
expected
}
;
}
export
class
CaseCache
{
constructor
(
name
builders
)
{
this
.
path
=
webgpu
/
shader
/
execution
/
{
name
}
.
bin
;
this
.
builders
=
builders
;
}
async
get
(
name
)
{
const
data
=
await
dataCache
.
fetch
(
this
)
;
return
data
[
name
]
;
}
build
(
)
{
const
built
=
{
}
;
for
(
const
name
in
this
.
builders
)
{
const
cases
=
this
.
builders
[
name
]
(
)
;
built
[
name
]
=
cases
;
}
return
Promise
.
resolve
(
built
)
;
}
serialize
(
data
)
{
const
maxSize
=
32
<
<
20
;
const
stream
=
new
BinaryStream
(
new
ArrayBuffer
(
maxSize
)
)
;
stream
.
writeU32
(
Object
.
keys
(
data
)
.
length
)
;
for
(
const
name
in
data
)
{
stream
.
writeString
(
name
)
;
stream
.
writeArray
(
data
[
name
]
serializeCase
)
;
}
return
stream
.
buffer
(
)
;
}
deserialize
(
array
)
{
const
s
=
new
BinaryStream
(
array
.
buffer
)
;
const
casesByName
=
{
}
;
const
numRecords
=
s
.
readU32
(
)
;
for
(
let
i
=
0
;
i
<
numRecords
;
i
+
+
)
{
const
name
=
s
.
readString
(
)
;
const
cases
=
s
.
readArray
(
deserializeCase
)
;
casesByName
[
name
]
=
cases
;
}
return
casesByName
;
}
}
export
function
makeCaseCache
(
name
builders
)
{
return
new
CaseCache
(
name
builders
)
;
}
