export
function
generateShader
(
{
attribute
type
stage
io
use_struct
}
)
{
let
code
=
'
'
;
if
(
attribute
.
includes
(
'
subgroup
'
)
)
{
code
+
=
'
enable
subgroups
;
\
n
'
;
}
if
(
attribute
.
includes
(
'
clip_distances
'
)
)
{
code
+
=
'
enable
clip_distances
;
\
n
'
;
}
if
(
use_struct
)
{
code
+
=
'
struct
S
{
\
n
'
;
code
+
=
{
attribute
}
value
:
{
type
}
\
n
;
if
(
stage
=
=
=
'
vertex
'
&
&
io
=
=
=
'
out
'
&
&
!
attribute
.
includes
(
'
builtin
(
position
)
'
)
)
{
code
+
=
builtin
(
position
)
position
:
vec4
<
f32
>
\
n
;
}
code
+
=
'
}
;
\
n
\
n
'
;
}
if
(
stage
!
=
=
'
'
)
{
code
+
=
{
stage
}
;
if
(
stage
=
=
=
'
compute
'
)
{
code
+
=
'
workgroup_size
(
1
)
'
;
}
}
let
param
=
'
'
;
let
retType
=
'
'
;
let
retVal
=
'
'
;
if
(
io
=
=
=
'
in
'
)
{
if
(
use_struct
)
{
param
=
in
:
S
;
}
else
{
param
=
{
attribute
}
value
:
{
type
}
;
}
if
(
stage
=
=
=
'
vertex
'
)
{
retType
=
-
>
builtin
(
position
)
vec4
<
f32
>
;
retVal
=
return
vec4
<
f32
>
(
)
;
;
}
}
else
if
(
io
=
=
=
'
out
'
)
{
if
(
use_struct
)
{
retType
=
'
-
>
S
'
;
retVal
=
return
S
(
)
;
;
}
else
{
retType
=
-
>
{
attribute
}
{
type
}
;
retVal
=
return
{
type
}
(
)
;
;
}
}
code
+
=
fn
main
(
{
param
}
)
{
retType
}
{
{
retVal
}
}
;
return
code
;
}
function
groupAndBinding
(
group
binding
)
{
return
(
{
group
!
=
=
undefined
?
group
(
{
group
}
)
:
'
/
*
no
group
*
/
'
}
+
{
binding
!
=
=
undefined
?
binding
(
{
binding
}
)
:
'
/
*
no
binding
*
/
'
}
)
;
}
function
basicEmitter
(
type
)
{
return
(
name
group
binding
)
=
>
{
groupAndBinding
(
group
binding
)
}
var
{
name
}
:
{
type
}
;
\
n
;
}
export
const
kResourceEmitters
=
new
Map
(
[
[
'
texture_1d
'
basicEmitter
(
'
texture_1d
<
i32
>
'
)
]
[
'
texture_2d
'
basicEmitter
(
'
texture_2d
<
i32
>
'
)
]
[
'
texture_2d_array
'
basicEmitter
(
'
texture_2d_array
<
f32
>
'
)
]
[
'
texture_3d
'
basicEmitter
(
'
texture_3d
<
i32
>
'
)
]
[
'
texture_cube
'
basicEmitter
(
'
texture_cube
<
u32
>
'
)
]
[
'
texture_cube_array
'
basicEmitter
(
'
texture_cube_array
<
u32
>
'
)
]
[
'
texture_multisampled_2d
'
basicEmitter
(
'
texture_multisampled_2d
<
i32
>
'
)
]
[
'
texture_external
'
basicEmitter
(
'
texture_external
'
)
]
[
'
texture_storage_1d
'
basicEmitter
(
'
texture_storage_1d
<
rgba8unorm
write
>
'
)
]
[
'
texture_storage_2d
'
basicEmitter
(
'
texture_storage_2d
<
rgba8sint
write
>
'
)
]
[
'
texture_storage_2d_array
'
basicEmitter
(
'
texture_storage_2d_array
<
r32uint
write
>
'
)
]
[
'
texture_storage_3d
'
basicEmitter
(
'
texture_storage_3d
<
rgba32uint
write
>
'
)
]
[
'
texture_depth_2d
'
basicEmitter
(
'
texture_depth_2d
'
)
]
[
'
texture_depth_2d_array
'
basicEmitter
(
'
texture_depth_2d_array
'
)
]
[
'
texture_depth_cube
'
basicEmitter
(
'
texture_depth_cube
'
)
]
[
'
texture_depth_cube_array
'
basicEmitter
(
'
texture_depth_cube_array
'
)
]
[
'
texture_depth_multisampled_2d
'
basicEmitter
(
'
texture_depth_multisampled_2d
'
)
]
[
'
sampler
'
basicEmitter
(
'
sampler
'
)
]
[
'
sampler_comparison
'
basicEmitter
(
'
sampler_comparison
'
)
]
[
'
uniform
'
(
name
group
binding
)
=
>
{
groupAndBinding
(
group
binding
)
}
var
<
uniform
>
{
name
}
:
array
<
vec4
<
f32
>
16
>
;
\
n
]
[
'
storage
'
(
name
group
binding
)
=
>
{
groupAndBinding
(
group
binding
)
}
var
<
storage
>
{
name
}
:
array
<
vec4
<
f32
>
16
>
;
\
n
]
]
)
;
export
const
kResourceKindsAll
=
[
'
texture_1d
'
'
texture_2d
'
'
texture_2d_array
'
'
texture_3d
'
'
texture_cube
'
'
texture_cube_array
'
'
texture_multisampled_2d
'
'
texture_external
'
'
texture_storage_1d
'
'
texture_storage_2d
'
'
texture_storage_2d_array
'
'
texture_storage_3d
'
'
texture_depth_2d
'
'
texture_depth_2d_array
'
'
texture_depth_cube
'
'
texture_depth_cube_array
'
'
texture_depth_multisampled_2d
'
'
sampler
'
'
sampler_comparison
'
'
uniform
'
'
storage
'
]
;
export
const
kResourceKindsA
=
[
'
storage
'
'
texture_2d
'
'
texture_external
'
'
uniform
'
]
;
export
const
kResourceKindsB
=
[
'
texture_3d
'
'
texture_storage_1d
'
'
uniform
'
]
;
export
function
declareEntrypoint
(
name
stage
body
)
{
switch
(
stage
)
{
case
'
vertex
'
:
return
vertex
fn
{
name
}
(
)
-
>
builtin
(
position
)
vec4f
{
{
body
}
return
vec4f
(
)
;
}
;
case
'
fragment
'
:
return
fragment
fn
{
name
}
(
)
{
{
body
}
}
;
case
'
compute
'
:
return
compute
workgroup_size
(
1
)
fn
{
name
}
(
)
{
{
body
}
}
;
}
}
