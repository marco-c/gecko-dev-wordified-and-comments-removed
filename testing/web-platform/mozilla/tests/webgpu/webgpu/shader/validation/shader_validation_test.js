import
{
keysOf
}
from
'
.
.
/
.
.
/
.
.
/
common
/
util
/
data_tables
.
js
'
;
import
{
ErrorWithExtra
}
from
'
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
GPUTest
}
from
'
.
.
/
.
.
/
gpu_test
.
js
'
;
export
class
ShaderValidationTest
extends
GPUTest
{
expectCompileResult
(
expectedResult
code
)
{
let
shaderModule
;
this
.
expectGPUError
(
'
validation
'
(
)
=
>
{
shaderModule
=
this
.
device
.
createShaderModule
(
{
code
}
)
;
}
expectedResult
!
=
=
true
)
;
const
error
=
new
ErrorWithExtra
(
'
'
(
)
=
>
(
{
shaderModule
}
)
)
;
this
.
eventualAsyncExpectation
(
async
(
)
=
>
{
const
compilationInfo
=
await
shaderModule
.
getCompilationInfo
(
)
;
const
messagesLog
=
compilationInfo
.
messages
.
map
(
(
m
)
=
>
{
m
.
lineNum
}
:
{
m
.
linePos
}
:
{
m
.
type
}
:
{
m
.
message
}
)
.
join
(
'
\
n
'
)
+
'
\
n
\
n
-
-
-
-
shader
-
-
-
-
\
n
'
+
code
;
error
.
extra
.
compilationInfo
=
compilationInfo
;
if
(
compilationInfo
.
messages
.
some
(
(
m
)
=
>
m
.
type
=
=
=
'
error
'
)
)
{
if
(
expectedResult
)
{
error
.
message
=
Unexpected
compilationInfo
'
error
'
message
.
\
n
+
messagesLog
;
this
.
rec
.
validationFailed
(
error
)
;
}
else
{
error
.
message
=
Found
expected
compilationInfo
'
error
'
message
.
\
n
+
messagesLog
;
this
.
rec
.
debug
(
error
)
;
}
}
else
{
if
(
!
expectedResult
)
{
error
.
message
=
Missing
expected
compilationInfo
'
error
'
message
.
\
n
+
messagesLog
;
this
.
rec
.
validationFailed
(
error
)
;
}
else
{
error
.
message
=
No
compilationInfo
'
error
'
messages
as
expected
.
\
n
+
messagesLog
;
this
.
rec
.
debug
(
error
)
;
}
}
}
)
;
}
expectCompileWarning
(
expectWarning
code
)
{
let
shaderModule
;
this
.
expectGPUError
(
'
validation
'
(
)
=
>
{
shaderModule
=
this
.
device
.
createShaderModule
(
{
code
}
)
;
}
false
)
;
const
error
=
new
ErrorWithExtra
(
'
'
(
)
=
>
(
{
shaderModule
}
)
)
;
this
.
eventualAsyncExpectation
(
async
(
)
=
>
{
const
compilationInfo
=
await
shaderModule
.
getCompilationInfo
(
)
;
const
messagesLog
=
compilationInfo
.
messages
.
map
(
(
m
)
=
>
{
m
.
lineNum
}
:
{
m
.
linePos
}
:
{
m
.
type
}
:
{
m
.
message
}
)
.
join
(
'
\
n
'
)
;
error
.
extra
.
compilationInfo
=
compilationInfo
;
if
(
compilationInfo
.
messages
.
some
(
(
m
)
=
>
m
.
type
=
=
=
'
warning
'
)
)
{
if
(
expectWarning
)
{
error
.
message
=
No
'
warning
'
message
as
expected
.
\
n
+
messagesLog
;
this
.
rec
.
debug
(
error
)
;
}
else
{
error
.
message
=
Missing
expected
compilationInfo
'
warning
'
message
.
\
n
+
messagesLog
;
this
.
rec
.
validationFailed
(
error
)
;
}
}
else
{
if
(
expectWarning
)
{
error
.
message
=
Missing
expected
'
warning
'
message
.
\
n
+
messagesLog
;
this
.
rec
.
validationFailed
(
error
)
;
}
else
{
error
.
message
=
Found
a
'
warning
'
message
as
expected
.
\
n
+
messagesLog
;
this
.
rec
.
debug
(
error
)
;
}
}
}
)
;
}
expectPipelineResult
(
args
)
{
const
phonies
=
[
]
;
if
(
args
.
statements
!
=
=
undefined
)
{
phonies
.
push
(
.
.
.
args
.
statements
)
;
}
if
(
args
.
constants
!
=
=
undefined
)
{
phonies
.
push
(
.
.
.
keysOf
(
args
.
constants
)
.
map
(
(
c
)
=
>
_
=
{
c
}
;
)
)
;
}
if
(
args
.
reference
!
=
=
undefined
)
{
phonies
.
push
(
.
.
.
args
.
reference
.
map
(
(
c
)
=
>
_
=
{
c
}
;
)
)
;
}
const
code
=
args
.
code
+
compute
workgroup_size
(
1
)
fn
main
(
)
{
{
phonies
.
join
(
'
\
n
'
)
}
}
;
let
shaderModule
;
this
.
expectGPUError
(
'
validation
'
(
)
=
>
{
shaderModule
=
this
.
device
.
createShaderModule
(
{
code
}
)
;
}
false
)
;
this
.
expectGPUError
(
'
validation
'
(
)
=
>
{
this
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
:
shaderModule
entryPoint
:
'
main
'
constants
:
args
.
constants
}
}
)
;
}
!
args
.
expectedResult
)
;
}
wrapInEntryPoint
(
code
enabledExtensions
=
[
]
)
{
const
enableDirectives
=
enabledExtensions
.
map
(
(
x
)
=
>
enable
{
x
}
;
)
.
join
(
'
\
n
'
)
;
return
{
enableDirectives
}
compute
workgroup_size
(
1
)
fn
main
(
)
{
{
code
}
}
;
}
}
