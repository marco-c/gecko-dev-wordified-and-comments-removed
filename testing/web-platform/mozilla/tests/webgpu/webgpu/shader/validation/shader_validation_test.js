import
{
ErrorWithExtra
}
from
'
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
GPUTest
}
from
'
.
.
/
.
.
/
gpu_test
.
js
'
;
export
class
ShaderValidationTest
extends
GPUTest
{
expectCompileResult
(
expectedResult
code
)
{
let
shaderModule
;
this
.
expectGPUError
(
'
validation
'
(
)
=
>
{
shaderModule
=
this
.
device
.
createShaderModule
(
{
code
}
)
;
}
expectedResult
!
=
=
true
)
;
const
error
=
new
ErrorWithExtra
(
'
'
(
)
=
>
(
{
shaderModule
}
)
)
;
this
.
eventualAsyncExpectation
(
async
(
)
=
>
{
const
compilationInfo
=
await
shaderModule
.
compilationInfo
(
)
;
const
messagesLog
=
compilationInfo
.
messages
.
map
(
m
=
>
{
m
.
lineNum
}
:
{
m
.
linePos
}
:
{
m
.
type
}
:
{
m
.
message
}
)
.
join
(
'
\
n
'
)
;
error
.
extra
.
compilationInfo
=
compilationInfo
;
if
(
compilationInfo
.
messages
.
some
(
m
=
>
m
.
type
=
=
=
'
error
'
)
)
{
if
(
expectedResult
)
{
error
.
message
=
Unexpected
compilationInfo
'
error
'
message
.
\
n
+
messagesLog
;
this
.
rec
.
validationFailed
(
error
)
;
}
else
{
error
.
message
=
Found
expected
compilationInfo
'
error
'
message
.
\
n
+
messagesLog
;
this
.
rec
.
debug
(
error
)
;
}
}
else
{
if
(
!
expectedResult
)
{
error
.
message
=
Missing
expected
compilationInfo
'
error
'
message
.
\
n
+
messagesLog
;
this
.
rec
.
validationFailed
(
error
)
;
}
else
{
error
.
message
=
No
compilationInfo
'
error
'
messages
as
expected
.
\
n
+
messagesLog
;
this
.
rec
.
debug
(
error
)
;
}
}
}
)
;
}
wrapInEntryPoint
(
code
enabledExtensions
=
[
]
)
{
const
enableDirectives
=
enabledExtensions
.
map
(
x
=
>
enable
{
x
}
;
)
.
join
(
'
\
n
'
)
;
return
{
enableDirectives
}
compute
workgroup_size
(
1
)
fn
main
(
)
{
{
code
}
}
;
}
}
