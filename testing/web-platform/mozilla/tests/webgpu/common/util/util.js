import
{
Float16Array
}
from
'
.
.
/
.
.
/
external
/
petamoriken
/
float16
/
float16
.
js
'
;
import
{
SkipTestCase
}
from
'
.
.
/
framework
/
fixture
.
js
'
;
import
{
globalTestConfig
}
from
'
.
.
/
framework
/
test_config
.
js
'
;
import
{
keysOf
}
from
'
.
/
data_tables
.
js
'
;
import
{
timeout
}
from
'
.
/
timeout
.
js
'
;
export
class
ErrorWithExtra
extends
Error
{
constructor
(
baseOrMessage
newExtra
)
{
const
message
=
typeof
baseOrMessage
=
=
=
'
string
'
?
baseOrMessage
:
baseOrMessage
.
message
;
super
(
message
)
;
const
oldExtras
=
baseOrMessage
instanceof
ErrorWithExtra
?
baseOrMessage
.
extra
:
{
}
;
this
.
extra
=
globalTestConfig
.
enableDebugLogs
?
{
.
.
.
oldExtras
.
.
.
newExtra
(
)
}
:
{
omitted
:
'
pass
?
debug
=
1
'
}
;
}
}
export
function
assert
(
condition
msg
)
{
if
(
!
condition
)
{
throw
new
Error
(
msg
&
&
(
typeof
msg
=
=
=
'
string
'
?
msg
:
msg
(
)
)
)
;
}
}
export
function
assertOK
(
value
)
{
if
(
value
instanceof
Error
)
{
throw
value
;
}
return
value
;
}
export
async
function
assertReject
(
expectedName
p
{
allowMissingStack
=
false
message
}
=
{
}
)
{
await
p
.
then
(
(
)
=
>
{
unreachable
(
message
)
;
}
(
ex
)
=
>
{
assert
(
ex
instanceof
Error
'
rejected
with
a
non
-
Error
object
'
)
;
assert
(
ex
.
name
=
=
=
expectedName
rejected
with
name
{
ex
.
name
}
instead
of
{
expectedName
}
)
;
if
(
!
allowMissingStack
)
{
const
m
=
message
?
(
{
message
}
)
:
'
'
;
assert
(
typeof
ex
.
stack
=
=
=
'
string
'
'
threw
as
expected
but
missing
stack
'
+
m
)
;
}
}
)
;
}
export
function
unreachable
(
msg
)
{
throw
new
Error
(
msg
)
;
}
export
function
skipTestCase
(
msg
)
{
throw
new
SkipTestCase
(
msg
)
;
}
const
perf
=
typeof
performance
!
=
=
'
undefined
'
?
performance
:
require
(
'
perf_hooks
'
)
.
performance
;
export
function
now
(
)
{
return
perf
.
now
(
)
;
}
export
function
resolveOnTimeout
(
ms
)
{
return
new
Promise
(
(
resolve
)
=
>
{
timeout
(
(
)
=
>
{
resolve
(
)
;
}
ms
)
;
}
)
;
}
export
class
PromiseTimeoutError
extends
Error
{
}
export
function
rejectOnTimeout
(
ms
msg
)
{
return
new
Promise
(
(
_resolve
reject
)
=
>
{
timeout
(
(
)
=
>
{
reject
(
new
PromiseTimeoutError
(
msg
)
)
;
}
ms
)
;
}
)
;
}
export
function
raceWithRejectOnTimeout
(
p
ms
msg
)
{
if
(
globalTestConfig
.
noRaceWithRejectOnTimeout
)
{
return
p
;
}
const
timeoutPromise
=
new
Promise
(
(
_resolve
reject
)
=
>
{
const
handle
=
timeout
(
(
)
=
>
{
reject
(
new
PromiseTimeoutError
(
msg
)
)
;
}
ms
)
;
p
=
p
.
finally
(
(
)
=
>
clearTimeout
(
handle
)
)
;
}
)
;
return
Promise
.
race
(
[
p
timeoutPromise
]
)
;
}
export
function
assertNotSettledWithinTime
(
p
ms
msg
)
{
const
rejectWhenSettled
=
p
.
then
(
(
)
=
>
Promise
.
reject
(
new
Error
(
msg
)
)
)
;
const
timeoutPromise
=
new
Promise
(
(
resolve
)
=
>
{
const
handle
=
timeout
(
(
)
=
>
{
resolve
(
undefined
)
;
}
ms
)
;
void
p
.
finally
(
(
)
=
>
clearTimeout
(
handle
)
)
;
}
)
;
return
Promise
.
race
(
[
rejectWhenSettled
timeoutPromise
]
)
;
}
export
function
rejectWithoutUncaught
(
err
)
{
const
p
=
Promise
.
reject
(
err
)
;
p
.
catch
(
(
)
=
>
{
}
)
;
return
p
;
}
export
function
isPlainObject
(
v
)
{
return
!
!
v
&
&
Object
.
getPrototypeOf
(
v
)
.
constructor
=
=
=
Object
.
prototype
.
constructor
;
}
export
function
sortObjectByKey
(
v
)
{
const
sortedObject
=
{
}
;
for
(
const
k
of
Object
.
keys
(
v
)
.
sort
(
)
)
{
sortedObject
[
k
]
=
v
[
k
]
;
}
return
sortedObject
;
}
export
function
objectEquals
(
x
y
distinguishSignedZero
=
false
)
{
if
(
typeof
x
!
=
=
'
object
'
|
|
typeof
y
!
=
=
'
object
'
)
{
if
(
typeof
x
=
=
=
'
number
'
&
&
typeof
y
=
=
=
'
number
'
&
&
Number
.
isNaN
(
x
)
&
&
Number
.
isNaN
(
y
)
)
{
return
true
;
}
return
distinguishSignedZero
?
Object
.
is
(
x
y
)
:
x
=
=
=
y
;
}
if
(
x
=
=
=
null
|
|
y
=
=
=
null
)
return
x
=
=
=
y
;
if
(
x
.
constructor
!
=
=
y
.
constructor
)
return
false
;
if
(
x
instanceof
Function
)
return
x
=
=
=
y
;
if
(
x
instanceof
RegExp
)
return
x
=
=
=
y
;
if
(
x
=
=
=
y
|
|
x
.
valueOf
(
)
=
=
=
y
.
valueOf
(
)
)
return
true
;
if
(
Array
.
isArray
(
x
)
&
&
Array
.
isArray
(
y
)
&
&
x
.
length
!
=
=
y
.
length
)
return
false
;
if
(
x
instanceof
Date
)
return
false
;
if
(
!
(
x
instanceof
Object
)
)
return
false
;
if
(
!
(
y
instanceof
Object
)
)
return
false
;
const
x1
=
x
;
const
y1
=
y
;
const
p
=
Object
.
keys
(
x
)
;
return
Object
.
keys
(
y
)
.
every
(
(
i
)
=
>
p
.
indexOf
(
i
)
!
=
=
-
1
)
&
&
p
.
every
(
(
i
)
=
>
objectEquals
(
x1
[
i
]
y1
[
i
]
)
)
;
}
export
function
range
(
n
fn
)
{
return
[
.
.
.
new
Array
(
n
)
]
.
map
(
(
_
i
)
=
>
fn
(
i
)
)
;
}
export
function
*
iterRange
(
n
fn
)
{
for
(
let
i
=
0
;
i
<
n
;
+
+
i
)
{
yield
fn
(
i
)
;
}
}
export
function
mapLazy
(
xs
f
)
{
return
{
*
[
Symbol
.
iterator
]
(
)
{
for
(
const
x
of
xs
)
{
yield
f
(
x
)
;
}
}
}
;
}
export
function
count
(
xs
predicate
)
{
let
count
=
0
;
for
(
const
x
of
xs
)
{
if
(
predicate
(
x
)
)
count
+
+
;
}
return
count
;
}
const
ReorderOrders
=
{
forward
:
true
backward
:
true
shiftByHalf
:
true
}
;
export
const
kReorderOrderKeys
=
keysOf
(
ReorderOrders
)
;
export
function
shiftByHalf
(
arr
)
{
const
len
=
arr
.
length
;
const
half
=
len
/
2
|
0
;
const
firstHalf
=
arr
.
splice
(
0
half
)
;
return
[
.
.
.
arr
.
.
.
firstHalf
]
;
}
export
function
reorder
(
order
arr
)
{
switch
(
order
)
{
case
'
forward
'
:
return
arr
.
slice
(
)
;
case
'
backward
'
:
return
arr
.
slice
(
)
.
reverse
(
)
;
case
'
shiftByHalf
'
:
{
return
shiftByHalf
(
arr
)
;
}
}
}
export
function
typedEntries
(
obj
)
{
return
Object
.
entries
(
obj
)
;
}
const
TypedArrayBufferViewInstances
=
[
new
Uint8Array
(
)
new
Uint8ClampedArray
(
)
new
Uint16Array
(
)
new
Uint32Array
(
)
new
Int8Array
(
)
new
Int16Array
(
)
new
Int32Array
(
)
new
Float16Array
(
)
new
Float32Array
(
)
new
Float64Array
(
)
new
BigInt64Array
(
)
new
BigUint64Array
(
)
]
;
export
const
kTypedArrayBufferViews
=
{
.
.
.
(
(
)
=
>
{
const
result
=
{
}
;
for
(
const
v
of
TypedArrayBufferViewInstances
)
{
result
[
v
.
constructor
.
name
]
=
v
.
constructor
;
}
return
result
;
}
)
(
)
}
;
export
const
kTypedArrayBufferViewKeys
=
keysOf
(
kTypedArrayBufferViews
)
;
export
const
kTypedArrayBufferViewConstructors
=
Object
.
values
(
kTypedArrayBufferViews
)
;
export
function
typedArrayParam
(
type
data
)
{
return
{
type
data
}
;
}
export
function
createTypedArray
(
type
data
)
{
return
new
kTypedArrayBufferViews
[
type
]
(
data
)
;
}
export
function
typedArrayFromParam
(
param
)
{
const
{
type
data
}
=
param
;
return
createTypedArray
(
type
data
)
;
}
function
subarrayAsU8
(
buf
{
start
=
0
length
}
)
{
if
(
buf
instanceof
ArrayBuffer
)
{
return
new
Uint8Array
(
buf
start
length
)
;
}
else
if
(
buf
instanceof
Uint8Array
|
|
buf
instanceof
Uint8ClampedArray
)
{
if
(
start
=
=
=
0
&
&
(
length
=
=
=
undefined
|
|
length
=
=
=
buf
.
byteLength
)
)
{
return
buf
;
}
}
const
byteOffset
=
buf
.
byteOffset
+
start
*
buf
.
BYTES_PER_ELEMENT
;
const
byteLength
=
length
!
=
=
undefined
?
length
*
buf
.
BYTES_PER_ELEMENT
:
buf
.
byteLength
-
(
byteOffset
-
buf
.
byteOffset
)
;
return
new
Uint8Array
(
buf
.
buffer
byteOffset
byteLength
)
;
}
export
function
memcpy
(
src
dst
)
{
subarrayAsU8
(
dst
.
dst
dst
)
.
set
(
subarrayAsU8
(
src
.
src
src
)
)
;
}
export
function
filterUniqueValueTestVariants
(
valueTestVariants
)
{
return
new
Map
(
valueTestVariants
.
map
(
(
v
)
=
>
[
m
:
{
v
.
mult
}
a
:
{
v
.
add
}
v
]
)
)
.
values
(
)
;
}
export
function
makeValueTestVariant
(
base
variant
)
{
return
base
*
variant
.
mult
+
variant
.
add
;
}
export
function
hasFeature
(
features
feature
)
{
return
features
.
has
(
feature
)
;
}
export
function
combinationsOfOneOrTwoUsages
(
usages
)
{
const
combinations
=
[
]
;
for
(
const
usage0
of
usages
)
{
for
(
const
usage1
of
usages
)
{
if
(
usage0
<
=
usage1
)
{
combinations
.
push
(
usage0
|
usage1
)
;
}
}
}
return
combinations
;
}
