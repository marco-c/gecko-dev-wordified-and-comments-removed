import
{
optionWorkerMode
}
from
'
.
.
/
.
.
/
runtime
/
helper
/
options
.
js
'
;
import
{
assert
unreachable
}
from
'
.
.
/
.
.
/
util
/
util
.
js
'
;
import
{
compareQueries
Ordering
}
from
'
.
/
compare
.
js
'
;
import
{
encodeURIComponentSelectively
}
from
'
.
/
encode_selectively
.
js
'
;
import
{
parseQuery
}
from
'
.
/
parseQuery
.
js
'
;
import
{
kBigSeparator
kPathSeparator
kWildcard
}
from
'
.
/
separators
.
js
'
;
import
{
stringifyPublicParams
}
from
'
.
/
stringify_params
.
js
'
;
export
class
TestQueryMultiFile
{
level
=
1
;
isMultiFile
=
true
;
constructor
(
suite
file
)
{
this
.
suite
=
suite
;
this
.
filePathParts
=
[
.
.
.
file
]
;
}
get
depthInLevel
(
)
{
return
this
.
filePathParts
.
length
;
}
toString
(
)
{
return
encodeURIComponentSelectively
(
this
.
toStringHelper
(
)
.
join
(
kBigSeparator
)
)
;
}
toStringHelper
(
)
{
return
[
this
.
suite
[
.
.
.
this
.
filePathParts
kWildcard
]
.
join
(
kPathSeparator
)
]
;
}
}
export
class
TestQueryMultiTest
extends
TestQueryMultiFile
{
level
=
2
;
isMultiFile
=
false
;
isMultiTest
=
true
;
constructor
(
suite
file
test
)
{
super
(
suite
file
)
;
assert
(
file
.
length
>
0
'
multi
-
test
(
or
finer
)
query
must
have
file
-
path
'
)
;
this
.
testPathParts
=
[
.
.
.
test
]
;
}
get
depthInLevel
(
)
{
return
this
.
testPathParts
.
length
;
}
toStringHelper
(
)
{
return
[
this
.
suite
this
.
filePathParts
.
join
(
kPathSeparator
)
[
.
.
.
this
.
testPathParts
kWildcard
]
.
join
(
kPathSeparator
)
]
;
}
}
export
class
TestQueryMultiCase
extends
TestQueryMultiTest
{
level
=
3
;
isMultiTest
=
false
;
isMultiCase
=
true
;
constructor
(
suite
file
test
params
)
{
super
(
suite
file
test
)
;
assert
(
test
.
length
>
0
'
multi
-
case
(
or
finer
)
query
must
have
test
-
path
'
)
;
this
.
params
=
{
.
.
.
params
}
;
}
get
depthInLevel
(
)
{
return
Object
.
keys
(
this
.
params
)
.
length
;
}
toStringHelper
(
)
{
return
[
this
.
suite
this
.
filePathParts
.
join
(
kPathSeparator
)
this
.
testPathParts
.
join
(
kPathSeparator
)
stringifyPublicParams
(
this
.
params
true
)
]
;
}
}
export
class
TestQuerySingleCase
extends
TestQueryMultiCase
{
level
=
4
;
isMultiCase
=
false
;
get
depthInLevel
(
)
{
return
0
;
}
toStringHelper
(
)
{
return
[
this
.
suite
this
.
filePathParts
.
join
(
kPathSeparator
)
this
.
testPathParts
.
join
(
kPathSeparator
)
stringifyPublicParams
(
this
.
params
)
]
;
}
}
export
function
parseExpectationsForTestQuery
(
rawExpectations
query
wptURL
)
{
if
(
!
Array
.
isArray
(
rawExpectations
)
)
{
unreachable
(
'
Expectations
should
be
an
array
'
)
;
}
const
expectations
=
[
]
;
for
(
const
entry
of
rawExpectations
)
{
assert
(
typeof
entry
=
=
=
'
object
'
)
;
const
rawExpectation
=
entry
;
assert
(
rawExpectation
.
query
!
=
=
undefined
'
Expectation
missing
query
string
'
)
;
assert
(
rawExpectation
.
expectation
!
=
=
undefined
'
Expectation
missing
expectation
string
'
)
;
let
expectationQuery
;
if
(
wptURL
!
=
=
undefined
)
{
const
expectationURL
=
new
URL
(
{
wptURL
.
origin
}
/
{
entry
.
query
}
)
;
if
(
expectationURL
.
pathname
!
=
=
wptURL
.
pathname
)
{
continue
;
}
assert
(
expectationURL
.
pathname
=
=
=
wptURL
.
pathname
Invalid
expectation
path
{
expectationURL
.
pathname
}
Expectation
should
be
of
the
form
path
/
to
/
cts
.
https
.
html
?
debug
=
0
&
q
=
suite
:
test_path
:
test_name
:
foo
=
1
;
bar
=
2
;
.
.
.
)
;
const
params
=
expectationURL
.
searchParams
;
if
(
optionWorkerMode
(
'
worker
'
params
)
!
=
=
optionWorkerMode
(
'
worker
'
wptURL
.
searchParams
)
)
{
continue
;
}
const
qs
=
params
.
getAll
(
'
q
'
)
;
assert
(
qs
.
length
=
=
=
1
'
currently
there
must
be
exactly
one
?
q
=
in
the
expectation
string
'
)
;
expectationQuery
=
parseQuery
(
qs
[
0
]
)
;
}
else
{
expectationQuery
=
parseQuery
(
entry
.
query
)
;
}
const
queryForFilter
=
expectationQuery
instanceof
TestQueryMultiCase
?
new
TestQueryMultiCase
(
expectationQuery
.
suite
expectationQuery
.
filePathParts
expectationQuery
.
testPathParts
{
}
)
:
expectationQuery
;
if
(
compareQueries
(
query
queryForFilter
)
=
=
=
Ordering
.
Unordered
)
{
continue
;
}
switch
(
entry
.
expectation
)
{
case
'
pass
'
:
case
'
skip
'
:
case
'
fail
'
:
break
;
default
:
unreachable
(
Invalid
expectation
{
entry
.
expectation
}
)
;
}
expectations
.
push
(
{
query
:
expectationQuery
expectation
:
entry
.
expectation
}
)
;
}
return
expectations
;
}
export
function
relativeQueryString
(
parent
child
)
{
const
ordering
=
compareQueries
(
parent
child
)
;
if
(
ordering
=
=
=
Ordering
.
Equal
)
{
return
'
'
;
}
else
if
(
ordering
=
=
=
Ordering
.
StrictSuperset
)
{
const
parentString
=
parent
.
toString
(
)
;
assert
(
parentString
.
endsWith
(
kWildcard
)
)
;
const
childString
=
child
.
toString
(
)
;
assert
(
childString
.
startsWith
(
parentString
.
substring
(
0
parentString
.
length
-
2
)
)
'
impossible
?
:
childString
does
not
start
with
parentString
[
:
-
2
]
'
)
;
return
childString
.
substring
(
parentString
.
length
-
2
)
;
}
else
{
unreachable
(
relativeQueryString
arguments
have
invalid
ordering
{
ordering
}
:
\
n
{
parent
}
\
n
{
child
}
)
;
}
}
