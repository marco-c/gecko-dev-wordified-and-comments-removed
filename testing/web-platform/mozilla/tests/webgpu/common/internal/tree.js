import
{
assert
}
from
'
.
.
/
util
/
util
.
js
'
;
import
{
compareQueries
Ordering
}
from
'
.
/
query
/
compare
.
js
'
;
import
{
TestQueryMultiCase
TestQuerySingleCase
TestQueryMultiFile
TestQueryMultiTest
}
from
'
.
/
query
/
query
.
js
'
;
import
{
kBigSeparator
kWildcard
kPathSeparator
kParamSeparator
}
from
'
.
/
query
/
separators
.
js
'
;
import
{
stringifySingleParam
}
from
'
.
/
query
/
stringify_params
.
js
'
;
import
{
StacklessError
}
from
'
.
/
util
.
js
'
;
export
class
TestTree
{
constructor
(
forQuery
root
)
{
this
.
forQuery
=
forQuery
;
TestTree
.
propagateCounts
(
root
)
;
this
.
root
=
root
;
assert
(
root
.
query
.
level
=
=
=
1
&
&
root
.
query
.
depthInLevel
=
=
=
0
'
TestTree
root
must
be
the
root
(
suite
:
*
)
'
)
;
}
iterateCollapsedNodes
(
{
includeIntermediateNodes
=
false
includeEmptySubtrees
=
false
alwaysExpandThroughLevel
}
)
{
const
expandThroughLevel
=
Math
.
max
(
this
.
forQuery
.
level
alwaysExpandThroughLevel
)
;
return
TestTree
.
iterateSubtreeNodes
(
this
.
root
{
includeIntermediateNodes
includeEmptySubtrees
expandThroughLevel
}
)
;
}
iterateLeaves
(
)
{
return
TestTree
.
iterateSubtreeLeaves
(
this
.
root
)
;
}
dissolveSingleChildTrees
(
)
{
const
newRoot
=
dissolveSingleChildTrees
(
this
.
root
)
;
assert
(
newRoot
=
=
=
this
.
root
)
;
}
toString
(
)
{
return
TestTree
.
subtreeToString
(
'
(
root
)
'
this
.
root
'
'
)
;
}
static
*
iterateSubtreeNodes
(
subtree
opts
)
{
if
(
opts
.
includeIntermediateNodes
)
{
yield
subtree
;
}
for
(
const
[
child
]
of
subtree
.
children
)
{
if
(
'
children
'
in
child
)
{
const
collapsible
=
child
.
collapsible
&
&
child
.
query
.
level
>
opts
.
expandThroughLevel
;
if
(
child
.
children
.
size
>
0
&
&
!
collapsible
)
{
yield
*
TestTree
.
iterateSubtreeNodes
(
child
opts
)
;
}
else
if
(
child
.
children
.
size
>
0
|
|
opts
.
includeEmptySubtrees
)
{
yield
child
;
}
}
else
{
yield
child
;
}
}
}
static
*
iterateSubtreeLeaves
(
subtree
)
{
for
(
const
[
child
]
of
subtree
.
children
)
{
if
(
'
children
'
in
child
)
{
yield
*
TestTree
.
iterateSubtreeLeaves
(
child
)
;
}
else
{
yield
child
;
}
}
}
static
propagateCounts
(
subtree
)
{
subtree
.
subtreeCounts
?
?
=
{
tests
:
0
nodesWithTODO
:
0
}
;
for
(
const
[
child
]
of
subtree
.
children
)
{
if
(
'
children
'
in
child
)
{
const
counts
=
TestTree
.
propagateCounts
(
child
)
;
subtree
.
subtreeCounts
.
tests
+
=
counts
.
tests
;
subtree
.
subtreeCounts
.
nodesWithTODO
+
=
counts
.
nodesWithTODO
;
}
}
return
subtree
.
subtreeCounts
;
}
static
countsToString
(
tree
)
{
if
(
tree
.
subtreeCounts
)
{
return
{
tree
.
subtreeCounts
.
nodesWithTODO
}
/
{
tree
.
subtreeCounts
.
tests
}
;
}
else
{
return
'
'
;
}
}
static
subtreeToString
(
name
tree
indent
)
{
const
collapsible
=
'
run
'
in
tree
?
'
>
'
:
tree
.
collapsible
?
'
+
'
:
'
-
'
;
let
s
=
indent
+
{
collapsible
}
{
TestTree
.
countsToString
(
tree
)
}
{
JSON
.
stringify
(
name
)
}
=
>
{
tree
.
query
}
;
if
(
'
children
'
in
tree
)
{
if
(
tree
.
description
!
=
=
undefined
)
{
s
+
=
\
n
{
indent
}
|
{
JSON
.
stringify
(
tree
.
description
)
}
;
}
for
(
const
[
name
child
]
of
tree
.
children
)
{
s
+
=
'
\
n
'
+
TestTree
.
subtreeToString
(
name
child
indent
+
'
'
)
;
}
}
return
s
;
}
}
export
async
function
loadTreeForQuery
(
loader
queryToLoad
subqueriesToExpand
)
{
const
suite
=
queryToLoad
.
suite
;
const
specs
=
await
loader
.
listing
(
suite
)
;
const
subqueriesToExpandEntries
=
Array
.
from
(
subqueriesToExpand
.
entries
(
)
)
;
const
seenSubqueriesToExpand
=
new
Array
(
subqueriesToExpand
.
length
)
;
seenSubqueriesToExpand
.
fill
(
false
)
;
const
isCollapsible
=
(
subquery
)
=
>
subqueriesToExpandEntries
.
every
(
(
[
i
toExpand
]
)
=
>
{
const
ordering
=
compareQueries
(
toExpand
subquery
)
;
if
(
ordering
=
=
=
Ordering
.
Equal
)
seenSubqueriesToExpand
[
i
]
=
true
;
return
ordering
!
=
=
Ordering
.
StrictSubset
;
}
)
;
let
foundCase
=
false
;
const
subtreeL0
=
makeTreeForSuite
(
suite
isCollapsible
)
;
for
(
const
entry
of
specs
)
{
if
(
entry
.
file
.
length
=
=
=
0
&
&
'
readme
'
in
entry
)
{
setSubtreeDescriptionAndCountTODOs
(
subtreeL0
entry
.
readme
)
;
continue
;
}
{
const
queryL1
=
new
TestQueryMultiFile
(
suite
entry
.
file
)
;
const
orderingL1
=
compareQueries
(
queryL1
queryToLoad
)
;
if
(
orderingL1
=
=
=
Ordering
.
Unordered
)
{
continue
;
}
}
if
(
'
readme
'
in
entry
)
{
const
readmeSubtree
=
addSubtreeForDirPath
(
subtreeL0
entry
.
file
isCollapsible
)
;
setSubtreeDescriptionAndCountTODOs
(
readmeSubtree
entry
.
readme
)
;
continue
;
}
const
spec
=
await
loader
.
importSpecFile
(
queryToLoad
.
suite
entry
.
file
)
;
const
subtreeL1
=
addSubtreeForFilePath
(
subtreeL0
entry
.
file
isCollapsible
)
;
setSubtreeDescriptionAndCountTODOs
(
subtreeL1
spec
.
description
)
;
let
groupHasTests
=
false
;
for
(
const
t
of
spec
.
g
.
iterate
(
)
)
{
groupHasTests
=
true
;
{
const
queryL2
=
new
TestQueryMultiCase
(
suite
entry
.
file
t
.
testPath
{
}
)
;
const
orderingL2
=
compareQueries
(
queryL2
queryToLoad
)
;
if
(
orderingL2
=
=
=
Ordering
.
Unordered
)
{
continue
;
}
}
const
subtreeL2
=
addSubtreeForTestPath
(
subtreeL1
t
.
testPath
t
.
testCreationStack
isCollapsible
)
;
subtreeL2
.
subtreeCounts
?
?
=
{
tests
:
1
nodesWithTODO
:
0
}
;
if
(
t
.
description
)
setSubtreeDescriptionAndCountTODOs
(
subtreeL2
t
.
description
)
;
for
(
const
c
of
t
.
iterate
(
)
)
{
{
const
queryL3
=
new
TestQuerySingleCase
(
suite
entry
.
file
c
.
id
.
test
c
.
id
.
params
)
;
const
orderingL3
=
compareQueries
(
queryL3
queryToLoad
)
;
if
(
orderingL3
=
=
=
Ordering
.
Unordered
|
|
orderingL3
=
=
=
Ordering
.
StrictSuperset
)
{
continue
;
}
}
addLeafForCase
(
subtreeL2
c
isCollapsible
)
;
foundCase
=
true
;
}
}
if
(
!
groupHasTests
&
&
!
subtreeL1
.
subtreeCounts
)
{
throw
new
StacklessError
(
{
subtreeL1
.
query
}
has
no
tests
-
it
must
have
"
TODO
"
in
its
description
)
;
}
}
for
(
const
[
i
sq
]
of
subqueriesToExpandEntries
)
{
const
subquerySeen
=
seenSubqueriesToExpand
[
i
]
;
if
(
!
subquerySeen
)
{
throw
new
StacklessError
(
subqueriesToExpand
entry
did
not
match
anything
\
(
could
be
wrong
or
could
be
redundant
with
a
previous
subquery
)
:
\
n
{
sq
.
toString
(
)
}
)
;
}
}
assert
(
foundCase
Query
\
{
queryToLoad
.
toString
(
)
}
\
does
not
match
any
cases
)
;
return
new
TestTree
(
queryToLoad
subtreeL0
)
;
}
function
setSubtreeDescriptionAndCountTODOs
(
subtree
description
)
{
assert
(
subtree
.
description
=
=
=
undefined
)
;
subtree
.
description
=
description
.
trim
(
)
;
subtree
.
subtreeCounts
?
?
=
{
tests
:
0
nodesWithTODO
:
0
}
;
if
(
subtree
.
description
.
indexOf
(
'
TODO
'
)
!
=
=
-
1
)
{
subtree
.
subtreeCounts
.
nodesWithTODO
+
+
;
}
}
function
makeTreeForSuite
(
suite
isCollapsible
)
{
const
query
=
new
TestQueryMultiFile
(
suite
[
]
)
;
return
{
readableRelativeName
:
suite
+
kBigSeparator
query
children
:
new
Map
(
)
collapsible
:
isCollapsible
(
query
)
}
;
}
function
addSubtreeForDirPath
(
tree
file
isCollapsible
)
{
const
subqueryFile
=
[
]
;
for
(
const
part
of
file
)
{
subqueryFile
.
push
(
part
)
;
tree
=
getOrInsertSubtree
(
part
tree
(
)
=
>
{
const
query
=
new
TestQueryMultiFile
(
tree
.
query
.
suite
subqueryFile
)
;
return
{
readableRelativeName
:
part
+
kPathSeparator
+
kWildcard
query
collapsible
:
isCollapsible
(
query
)
}
;
}
)
;
}
return
tree
;
}
function
addSubtreeForFilePath
(
tree
file
isCollapsible
)
{
tree
=
addSubtreeForDirPath
(
tree
file
isCollapsible
)
;
const
subtree
=
getOrInsertSubtree
(
'
'
tree
(
)
=
>
{
const
query
=
new
TestQueryMultiTest
(
tree
.
query
.
suite
tree
.
query
.
filePathParts
[
]
)
;
assert
(
file
.
length
>
0
'
file
path
is
empty
'
)
;
return
{
readableRelativeName
:
file
[
file
.
length
-
1
]
+
kBigSeparator
+
kWildcard
query
collapsible
:
isCollapsible
(
query
)
}
;
}
)
;
return
subtree
;
}
function
addSubtreeForTestPath
(
tree
test
testCreationStack
isCollapsible
)
{
const
subqueryTest
=
[
]
;
for
(
const
part
of
test
)
{
subqueryTest
.
push
(
part
)
;
tree
=
getOrInsertSubtree
(
part
tree
(
)
=
>
{
const
query
=
new
TestQueryMultiTest
(
tree
.
query
.
suite
tree
.
query
.
filePathParts
subqueryTest
)
;
return
{
readableRelativeName
:
part
+
kPathSeparator
+
kWildcard
query
collapsible
:
isCollapsible
(
query
)
}
;
}
)
;
}
return
getOrInsertSubtree
(
'
'
tree
(
)
=
>
{
const
query
=
new
TestQueryMultiCase
(
tree
.
query
.
suite
tree
.
query
.
filePathParts
subqueryTest
{
}
)
;
assert
(
subqueryTest
.
length
>
0
'
subqueryTest
is
empty
'
)
;
return
{
readableRelativeName
:
subqueryTest
[
subqueryTest
.
length
-
1
]
+
kBigSeparator
+
kWildcard
kWildcard
query
testCreationStack
collapsible
:
isCollapsible
(
query
)
}
;
}
)
;
}
function
addLeafForCase
(
tree
t
checkCollapsible
)
{
const
query
=
tree
.
query
;
let
name
=
'
'
;
const
subqueryParams
=
{
}
;
for
(
const
[
k
v
]
of
Object
.
entries
(
t
.
id
.
params
)
)
{
name
=
stringifySingleParam
(
k
v
)
;
subqueryParams
[
k
]
=
v
;
tree
=
getOrInsertSubtree
(
name
tree
(
)
=
>
{
const
subquery
=
new
TestQueryMultiCase
(
query
.
suite
query
.
filePathParts
query
.
testPathParts
subqueryParams
)
;
return
{
readableRelativeName
:
name
+
kParamSeparator
+
kWildcard
query
:
subquery
collapsible
:
checkCollapsible
(
subquery
)
}
;
}
)
;
}
const
subquery
=
new
TestQuerySingleCase
(
query
.
suite
query
.
filePathParts
query
.
testPathParts
subqueryParams
)
;
checkCollapsible
(
subquery
)
;
insertLeaf
(
tree
subquery
t
)
;
}
function
getOrInsertSubtree
(
key
parent
createSubtree
)
{
let
v
;
const
child
=
parent
.
children
.
get
(
key
)
;
if
(
child
!
=
=
undefined
)
{
assert
(
'
children
'
in
child
)
;
v
=
child
;
}
else
{
v
=
{
.
.
.
createSubtree
(
)
children
:
new
Map
(
)
}
;
parent
.
children
.
set
(
key
v
)
;
}
return
v
;
}
function
insertLeaf
(
parent
query
t
)
{
const
leaf
=
{
readableRelativeName
:
readableNameForCase
(
query
)
query
run
:
(
rec
expectations
)
=
>
t
.
run
(
rec
query
expectations
|
|
[
]
)
isUnimplemented
:
t
.
isUnimplemented
}
;
const
key
=
'
'
;
assert
(
!
parent
.
children
.
has
(
key
)
Duplicate
testcase
:
{
query
}
)
;
parent
.
children
.
set
(
key
leaf
)
;
}
function
dissolveSingleChildTrees
(
tree
)
{
if
(
'
children
'
in
tree
)
{
const
shouldDissolveThisTree
=
tree
.
children
.
size
=
=
=
1
&
&
tree
.
query
.
depthInLevel
!
=
=
0
&
&
tree
.
description
=
=
=
undefined
;
if
(
shouldDissolveThisTree
)
{
for
(
const
[
child
]
of
tree
.
children
)
{
return
dissolveSingleChildTrees
(
child
)
;
}
}
for
(
const
[
k
child
]
of
tree
.
children
)
{
const
newChild
=
dissolveSingleChildTrees
(
child
)
;
if
(
newChild
!
=
=
child
)
{
tree
.
children
.
set
(
k
newChild
)
;
}
}
}
return
tree
;
}
function
readableNameForCase
(
query
)
{
const
paramsKeys
=
Object
.
keys
(
query
.
params
)
;
if
(
paramsKeys
.
length
=
=
=
0
)
{
return
query
.
testPathParts
[
query
.
testPathParts
.
length
-
1
]
+
kBigSeparator
;
}
else
{
const
lastKey
=
paramsKeys
[
paramsKeys
.
length
-
1
]
;
return
stringifySingleParam
(
lastKey
query
.
params
[
lastKey
]
)
;
}
}
