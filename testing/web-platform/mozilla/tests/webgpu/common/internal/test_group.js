import
{
SkipTestCase
UnexpectedPassError
}
from
'
.
.
/
framework
/
fixture
.
js
'
;
import
{
builderIterateCasesWithSubcases
kUnitCaseParamsBuilder
}
from
'
.
.
/
framework
/
params_builder
.
js
'
;
import
{
globalTestConfig
}
from
'
.
.
/
framework
/
test_config
.
js
'
;
import
{
extractPublicParams
mergeParams
}
from
'
.
.
/
internal
/
params_utils
.
js
'
;
import
{
compareQueries
Ordering
}
from
'
.
.
/
internal
/
query
/
compare
.
js
'
;
import
{
TestQueryMultiTest
TestQuerySingleCase
}
from
'
.
.
/
internal
/
query
/
query
.
js
'
;
import
{
kPathSeparator
}
from
'
.
.
/
internal
/
query
/
separators
.
js
'
;
import
{
stringifyPublicParams
stringifyPublicParamsUniquely
}
from
'
.
.
/
internal
/
query
/
stringify_params
.
js
'
;
import
{
validQueryPart
}
from
'
.
.
/
internal
/
query
/
validQueryPart
.
js
'
;
import
{
attemptGarbageCollection
}
from
'
.
.
/
util
/
collect_garbage
.
js
'
;
import
{
assert
unreachable
}
from
'
.
.
/
util
/
util
.
js
'
;
import
{
logToWebSocket
}
from
'
.
/
websocket_logger
.
js
'
;
export
function
makeTestGroup
(
fixture
)
{
return
new
TestGroup
(
fixture
)
;
}
export
function
makeTestGroupForUnitTesting
(
fixture
)
{
return
new
TestGroup
(
fixture
)
;
}
export
const
kQueryMaxLength
=
375
;
const
kBatchParamName
=
'
batch__
'
;
export
class
TestGroup
{
seen
=
new
Set
(
)
;
tests
=
[
]
;
constructor
(
fixture
)
{
this
.
fixture
=
fixture
;
}
iterate
(
)
{
return
this
.
tests
;
}
checkName
(
name
)
{
assert
(
name
=
=
=
decodeURIComponent
(
name
)
Not
decodeURIComponent
-
idempotent
:
{
name
}
!
=
=
{
decodeURIComponent
(
name
)
}
)
;
assert
(
!
this
.
seen
.
has
(
name
)
Duplicate
test
name
:
{
name
}
)
;
this
.
seen
.
add
(
name
)
;
}
test
(
name
)
{
const
testCreationStack
=
new
Error
(
Test
created
:
{
name
}
)
;
this
.
checkName
(
name
)
;
const
parts
=
name
.
split
(
kPathSeparator
)
;
for
(
const
p
of
parts
)
{
assert
(
validQueryPart
.
test
(
p
)
Invalid
test
name
part
{
p
}
;
must
match
{
validQueryPart
}
)
;
}
const
test
=
new
TestBuilder
(
parts
this
.
fixture
testCreationStack
)
;
this
.
tests
.
push
(
test
)
;
return
test
;
}
validate
(
fileQuery
)
{
for
(
const
test
of
this
.
tests
)
{
const
testQuery
=
new
TestQueryMultiTest
(
fileQuery
.
suite
fileQuery
.
filePathParts
test
.
testPath
)
;
test
.
validate
(
testQuery
)
;
}
}
collectNonEmptyTests
(
)
{
const
testPaths
=
[
]
;
for
(
const
test
of
this
.
tests
)
{
if
(
test
.
computeCaseCount
(
)
>
0
)
{
testPaths
.
push
(
{
testPath
:
test
.
testPath
}
)
;
}
}
return
testPaths
;
}
}
class
TestBuilder
{
testCases
=
undefined
;
batchSize
=
0
;
constructor
(
testPath
fixture
testCreationStack
)
{
this
.
testPath
=
testPath
;
this
.
isUnimplemented
=
false
;
this
.
fixture
=
fixture
;
this
.
testCreationStack
=
testCreationStack
;
}
desc
(
description
)
{
this
.
description
=
description
.
trim
(
)
;
return
this
;
}
specURL
(
_url
)
{
return
this
;
}
beforeAllSubcases
(
fn
)
{
assert
(
this
.
beforeFn
=
=
=
undefined
)
;
this
.
beforeFn
=
fn
;
return
this
;
}
fn
(
fn
)
{
assert
(
this
.
testFn
=
=
=
undefined
)
;
this
.
testFn
=
fn
;
}
batch
(
b
)
{
this
.
batchSize
=
b
;
return
this
;
}
unimplemented
(
)
{
assert
(
this
.
testFn
=
=
=
undefined
)
;
this
.
description
=
(
this
.
description
?
this
.
description
+
'
\
n
\
n
'
:
'
'
)
+
'
TODO
:
.
unimplemented
(
)
'
;
this
.
isUnimplemented
=
true
;
this
.
beforeFn
=
(
)
=
>
{
throw
new
SkipTestCase
(
'
test
unimplemented
'
)
;
}
;
this
.
testFn
=
(
)
=
>
{
}
;
}
validate
(
testQuery
)
{
const
testPathString
=
this
.
testPath
.
join
(
kPathSeparator
)
;
assert
(
this
.
testFn
!
=
=
undefined
(
)
=
>
{
let
s
=
Test
is
missing
.
fn
(
)
:
{
testPathString
}
;
if
(
this
.
testCreationStack
.
stack
)
{
s
+
=
\
n
-
>
test
created
at
:
\
n
{
this
.
testCreationStack
.
stack
}
;
}
return
s
;
}
)
;
assert
(
testQuery
.
toString
(
)
.
length
<
=
kQueryMaxLength
(
)
=
>
Test
query
{
testQuery
}
is
too
long
.
Max
length
is
{
kQueryMaxLength
}
characters
.
Please
shorten
names
or
reduce
parameters
.
)
;
if
(
this
.
testCases
=
=
=
undefined
)
{
return
;
}
const
seen
=
new
Set
(
)
;
for
(
const
[
caseParams
subcases
]
of
builderIterateCasesWithSubcases
(
this
.
testCases
null
)
)
{
const
caseQuery
=
new
TestQuerySingleCase
(
testQuery
.
suite
testQuery
.
filePathParts
testQuery
.
testPathParts
caseParams
)
.
toString
(
)
;
assert
(
caseQuery
.
length
<
=
kQueryMaxLength
(
)
=
>
Case
query
{
caseQuery
}
is
too
long
.
Max
length
is
{
kQueryMaxLength
}
characters
.
Please
shorten
names
or
reduce
parameters
.
)
;
for
(
const
subcaseParams
of
subcases
?
?
[
{
}
]
)
{
const
params
=
mergeParams
(
caseParams
subcaseParams
)
;
assert
(
this
.
batchSize
=
=
=
0
|
|
!
(
kBatchParamName
in
params
)
)
;
let
testcaseString
;
try
{
testcaseString
=
stringifyPublicParams
(
params
)
;
}
catch
(
e
)
{
throw
new
Error
(
{
e
}
:
{
testPathString
}
)
;
}
const
testcaseStringUnique
=
stringifyPublicParamsUniquely
(
params
)
;
assert
(
!
seen
.
has
(
testcaseStringUnique
)
Duplicate
public
test
case
+
subcase
params
for
test
{
testPathString
}
:
{
testcaseString
}
(
{
caseQuery
}
)
)
;
seen
.
add
(
testcaseStringUnique
)
;
}
}
}
computeCaseCount
(
)
{
if
(
this
.
testCases
=
=
=
undefined
)
{
return
1
;
}
let
caseCount
=
0
;
for
(
const
[
_caseParams
_subcases
]
of
builderIterateCasesWithSubcases
(
this
.
testCases
null
)
)
{
caseCount
+
+
;
}
return
caseCount
;
}
params
(
cases
)
{
assert
(
this
.
testCases
=
=
=
undefined
'
test
case
is
already
parameterized
'
)
;
if
(
cases
instanceof
Function
)
{
this
.
testCases
=
cases
(
kUnitCaseParamsBuilder
)
;
}
else
{
this
.
testCases
=
cases
;
}
return
this
;
}
paramsSimple
(
cases
)
{
assert
(
this
.
testCases
=
=
=
undefined
'
test
case
is
already
parameterized
'
)
;
this
.
testCases
=
kUnitCaseParamsBuilder
.
combineWithParams
(
cases
)
;
return
this
;
}
paramsSubcasesOnly
(
subcases
)
{
if
(
subcases
instanceof
Function
)
{
return
this
.
params
(
subcases
(
kUnitCaseParamsBuilder
.
beginSubcases
(
)
)
)
;
}
else
{
return
this
.
params
(
kUnitCaseParamsBuilder
.
beginSubcases
(
)
.
combineWithParams
(
subcases
)
)
;
}
}
makeCaseSpecific
(
params
subcases
)
{
assert
(
this
.
testFn
!
=
=
undefined
'
No
test
function
(
.
fn
(
)
)
for
test
'
)
;
return
new
RunCaseSpecific
(
this
.
testPath
params
this
.
isUnimplemented
subcases
this
.
fixture
this
.
testFn
this
.
beforeFn
this
.
testCreationStack
)
;
}
*
iterate
(
caseFilter
)
{
this
.
testCases
?
?
=
kUnitCaseParamsBuilder
;
let
filterToBatch
;
const
caseFilterWithoutBatch
=
caseFilter
?
{
.
.
.
caseFilter
}
:
null
;
if
(
caseFilterWithoutBatch
&
&
kBatchParamName
in
caseFilterWithoutBatch
)
{
const
batchParam
=
caseFilterWithoutBatch
[
kBatchParamName
]
;
assert
(
typeof
batchParam
=
=
=
'
number
'
)
;
filterToBatch
=
batchParam
;
delete
caseFilterWithoutBatch
[
kBatchParamName
]
;
}
for
(
const
[
caseParams
subcases
]
of
builderIterateCasesWithSubcases
(
this
.
testCases
caseFilterWithoutBatch
)
)
{
if
(
this
.
batchSize
=
=
=
0
|
|
subcases
=
=
=
undefined
)
{
yield
this
.
makeCaseSpecific
(
caseParams
subcases
)
;
continue
;
}
const
subcaseArray
=
Array
.
from
(
subcases
)
;
if
(
subcaseArray
.
length
<
=
this
.
batchSize
)
{
yield
this
.
makeCaseSpecific
(
caseParams
subcaseArray
)
;
continue
;
}
const
makeCaseForBatch
=
(
batch
)
=
>
{
const
sliceStart
=
batch
*
this
.
batchSize
;
return
this
.
makeCaseSpecific
(
{
.
.
.
caseParams
[
kBatchParamName
]
:
batch
}
subcaseArray
.
slice
(
sliceStart
Math
.
min
(
subcaseArray
.
length
sliceStart
+
this
.
batchSize
)
)
)
;
}
;
if
(
filterToBatch
!
=
=
undefined
)
{
yield
makeCaseForBatch
(
filterToBatch
)
;
continue
;
}
for
(
let
batch
=
0
;
batch
*
this
.
batchSize
<
subcaseArray
.
length
;
+
+
batch
)
{
yield
makeCaseForBatch
(
batch
)
;
}
}
}
}
class
RunCaseSpecific
{
constructor
(
testPath
params
isUnimplemented
subcases
fixture
fn
beforeFn
testCreationStack
)
{
this
.
id
=
{
test
:
testPath
params
:
extractPublicParams
(
params
)
}
;
this
.
isUnimplemented
=
isUnimplemented
;
this
.
params
=
params
;
this
.
subcases
=
subcases
;
this
.
fixture
=
fixture
;
this
.
fn
=
fn
;
this
.
beforeFn
=
beforeFn
;
this
.
testCreationStack
=
testCreationStack
;
}
computeSubcaseCount
(
)
{
if
(
this
.
subcases
)
{
let
count
=
0
;
for
(
const
_subcase
of
this
.
subcases
)
{
count
+
+
;
}
return
count
;
}
else
{
return
1
;
}
}
async
runTest
(
rec
sharedState
params
throwSkip
expectedStatus
)
{
try
{
rec
.
beginSubCase
(
)
;
if
(
expectedStatus
=
=
=
'
skip
'
)
{
throw
new
SkipTestCase
(
'
Skipped
by
expectations
'
)
;
}
const
inst
=
new
this
.
fixture
(
sharedState
rec
params
)
;
try
{
await
inst
.
init
(
)
;
await
this
.
fn
(
inst
)
;
rec
.
passed
(
)
;
}
finally
{
await
inst
.
finalize
(
)
;
}
}
catch
(
ex
)
{
rec
.
threw
(
ex
)
;
if
(
throwSkip
&
&
ex
instanceof
SkipTestCase
)
{
throw
ex
;
}
}
finally
{
try
{
rec
.
endSubCase
(
expectedStatus
)
;
}
catch
(
ex
)
{
assert
(
ex
instanceof
UnexpectedPassError
)
;
ex
.
message
=
Testcase
passed
unexpectedly
.
;
ex
.
stack
=
this
.
testCreationStack
.
stack
;
rec
.
warn
(
ex
)
;
}
}
}
async
run
(
rec
selfQuery
expectations
)
{
const
getExpectedStatus
=
(
selfQueryWithSubParams
)
=
>
{
let
didSeeFail
=
false
;
for
(
const
exp
of
expectations
)
{
const
ordering
=
compareQueries
(
exp
.
query
selfQueryWithSubParams
)
;
if
(
ordering
=
=
=
Ordering
.
Unordered
|
|
ordering
=
=
=
Ordering
.
StrictSubset
)
{
continue
;
}
switch
(
exp
.
expectation
)
{
case
'
skip
'
:
return
'
skip
'
;
case
'
fail
'
:
didSeeFail
=
true
;
break
;
default
:
unreachable
(
)
;
}
}
return
didSeeFail
?
'
fail
'
:
'
pass
'
;
}
;
const
{
testHeartbeatCallback
maxSubcasesInFlight
}
=
globalTestConfig
;
try
{
rec
.
start
(
)
;
const
sharedState
=
this
.
fixture
.
MakeSharedState
(
rec
this
.
params
)
;
try
{
await
sharedState
.
init
(
)
;
if
(
this
.
beforeFn
)
{
await
this
.
beforeFn
(
sharedState
)
;
}
await
sharedState
.
postInit
(
)
;
testHeartbeatCallback
(
)
;
let
allPreviousSubcasesFinalizedPromise
=
Promise
.
resolve
(
)
;
if
(
this
.
subcases
)
{
let
totalCount
=
0
;
let
skipCount
=
0
;
let
subcasesInFlight
=
0
;
let
resolvePromiseBlockingSubcase
=
undefined
;
const
subcaseFinishedCallback
=
(
)
=
>
{
subcasesInFlight
-
=
1
;
if
(
resolvePromiseBlockingSubcase
)
{
resolvePromiseBlockingSubcase
(
)
;
resolvePromiseBlockingSubcase
=
undefined
;
}
}
;
for
(
const
subParams
of
this
.
subcases
)
{
const
subRec
=
rec
.
makeDeferredSubRecorder
(
(
in
subcase
:
{
stringifyPublicParams
(
subParams
)
}
)
allPreviousSubcasesFinalizedPromise
)
;
const
params
=
mergeParams
(
this
.
params
subParams
)
;
const
subcaseQuery
=
new
TestQuerySingleCase
(
selfQuery
.
suite
selfQuery
.
filePathParts
selfQuery
.
testPathParts
params
)
;
if
(
subcasesInFlight
>
=
maxSubcasesInFlight
)
{
await
new
Promise
(
(
resolve
)
=
>
{
assert
(
resolvePromiseBlockingSubcase
=
=
=
undefined
)
;
resolvePromiseBlockingSubcase
=
resolve
;
}
)
;
}
subcasesInFlight
+
=
1
;
const
finalizePromise
=
this
.
runTest
(
subRec
sharedState
params
true
getExpectedStatus
(
subcaseQuery
)
)
.
then
(
(
)
=
>
{
subRec
.
info
(
new
Error
(
'
subcase
ran
'
)
)
;
}
)
.
catch
(
(
ex
)
=
>
{
if
(
ex
instanceof
SkipTestCase
)
{
ex
.
message
=
'
subcase
skipped
:
'
+
ex
.
message
;
subRec
.
info
(
new
Error
(
'
subcase
skipped
'
)
)
;
+
+
skipCount
;
}
else
{
subRec
.
threw
(
ex
)
;
}
}
)
.
finally
(
attemptGarbageCollectionIfDue
)
.
finally
(
subcaseFinishedCallback
)
;
allPreviousSubcasesFinalizedPromise
=
allPreviousSubcasesFinalizedPromise
.
then
(
(
)
=
>
finalizePromise
)
;
+
+
totalCount
;
}
await
allPreviousSubcasesFinalizedPromise
;
if
(
skipCount
=
=
=
totalCount
)
{
rec
.
skipped
(
new
SkipTestCase
(
'
all
subcases
were
skipped
'
)
)
;
}
}
else
{
try
{
await
this
.
runTest
(
rec
sharedState
this
.
params
false
getExpectedStatus
(
selfQuery
)
)
;
}
finally
{
await
attemptGarbageCollectionIfDue
(
)
;
}
}
}
finally
{
testHeartbeatCallback
(
)
;
await
sharedState
.
finalize
(
)
;
testHeartbeatCallback
(
)
;
}
}
catch
(
ex
)
{
rec
.
threw
(
ex
)
;
}
finally
{
rec
.
finish
(
)
;
const
msg
=
{
q
:
selfQuery
.
toString
(
)
timems
:
rec
.
result
.
timems
nonskippedSubcaseCount
:
rec
.
nonskippedSubcaseCount
}
;
logToWebSocket
(
JSON
.
stringify
(
msg
)
)
;
}
}
}
const
attemptGarbageCollectionIfDue
=
(
(
)
=
>
{
let
subcasesSinceLastGC
=
0
;
return
async
function
attemptGarbageCollectionIfDue
(
)
{
subcasesSinceLastGC
+
+
;
if
(
subcasesSinceLastGC
>
=
globalTestConfig
.
subcasesBetweenAttemptingGC
)
{
subcasesSinceLastGC
=
0
;
return
attemptGarbageCollection
(
)
;
}
}
;
}
)
(
)
;
