import
{
assert
}
from
'
.
.
/
util
/
util
.
js
'
;
class
DataCacheNode
{
constructor
(
path
data
)
{
this
.
path
=
path
;
this
.
data
=
data
;
}
insertAfter
(
prev
)
{
this
.
unlink
(
)
;
this
.
next
=
prev
.
next
;
this
.
prev
=
prev
;
prev
.
next
=
this
;
if
(
this
.
next
)
{
this
.
next
.
prev
=
this
;
}
}
unlink
(
)
{
const
prev
=
this
.
prev
;
const
next
=
this
.
next
;
if
(
prev
)
{
prev
.
next
=
next
;
}
if
(
next
)
{
next
.
prev
=
prev
;
}
this
.
prev
=
null
;
this
.
next
=
null
;
}
prev
=
null
;
next
=
null
;
}
export
class
DataCache
{
constructor
(
)
{
this
.
lruHeadNode
.
next
=
this
.
lruTailNode
;
this
.
lruTailNode
.
prev
=
this
.
lruHeadNode
;
}
setStore
(
dataStore
)
{
this
.
dataStore
=
dataStore
;
}
setDebugLogger
(
logger
)
{
this
.
debugLogger
=
logger
;
}
async
fetch
(
cacheable
)
{
{
const
node
=
this
.
cache
.
get
(
cacheable
.
path
)
;
if
(
node
!
=
=
undefined
)
{
this
.
log
(
'
in
-
memory
cache
hit
'
)
;
node
.
insertAfter
(
this
.
lruHeadNode
)
;
return
Promise
.
resolve
(
node
.
data
)
;
}
}
this
.
log
(
'
in
-
memory
cache
miss
'
)
;
if
(
this
.
dataStore
!
=
=
null
&
&
!
this
.
unavailableFiles
.
has
(
cacheable
.
path
)
)
{
let
serialized
;
try
{
serialized
=
await
this
.
dataStore
.
load
(
cacheable
.
path
)
;
this
.
log
(
'
loaded
serialized
'
)
;
}
catch
(
err
)
{
this
.
log
(
failed
to
load
(
{
cacheable
.
path
}
)
:
{
err
}
)
;
this
.
unavailableFiles
.
add
(
cacheable
.
path
)
;
}
if
(
serialized
!
=
=
undefined
)
{
this
.
log
(
deserializing
)
;
const
data
=
cacheable
.
deserialize
(
serialized
)
;
this
.
addToCache
(
cacheable
.
path
data
)
;
return
data
;
}
}
this
.
log
(
cache
:
building
(
{
cacheable
.
path
}
)
)
;
const
data
=
await
cacheable
.
build
(
)
;
this
.
addToCache
(
cacheable
.
path
data
)
;
return
data
;
}
addToCache
(
path
data
)
{
if
(
this
.
cache
.
size
>
=
this
.
maxCount
)
{
const
toEvict
=
this
.
lruTailNode
.
prev
;
assert
(
toEvict
!
=
=
null
)
;
toEvict
.
unlink
(
)
;
this
.
cache
.
delete
(
toEvict
.
path
)
;
this
.
log
(
evicting
{
toEvict
.
path
}
)
;
}
const
node
=
new
DataCacheNode
(
path
data
)
;
node
.
insertAfter
(
this
.
lruHeadNode
)
;
this
.
cache
.
set
(
path
node
)
;
this
.
log
(
added
{
path
}
.
new
count
:
{
this
.
cache
.
size
}
)
;
}
log
(
msg
)
{
if
(
this
.
debugLogger
!
=
=
null
)
{
this
.
debugLogger
(
DataCache
:
{
msg
}
)
;
}
}
maxCount
=
4
;
cache
=
new
Map
(
)
;
lruHeadNode
=
new
DataCacheNode
(
'
'
null
)
;
lruTailNode
=
new
DataCacheNode
(
'
'
null
)
;
unavailableFiles
=
new
Set
(
)
;
dataStore
=
null
;
debugLogger
=
null
;
}
export
const
dataCache
=
new
DataCache
(
)
;
let
isBuildingDataCache
=
false
;
export
function
getIsBuildingDataCache
(
)
{
return
isBuildingDataCache
;
}
export
function
setIsBuildingDataCache
(
value
=
true
)
{
isBuildingDataCache
=
value
;
}
