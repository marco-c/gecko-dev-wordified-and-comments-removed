import
{
assert
unreachable
}
from
'
.
.
/
util
/
util
.
js
'
;
export
class
SkipTestCase
extends
Error
{
}
export
class
UnexpectedPassError
extends
Error
{
}
export
{
TestCaseRecorder
}
from
'
.
.
/
internal
/
logging
/
test_case_recorder
.
js
'
;
export
class
SubcaseBatchState
{
constructor
(
recorder
params
)
{
this
.
recorder
=
recorder
;
this
.
params
=
params
;
}
async
init
(
)
{
}
async
postInit
(
)
{
}
async
finalize
(
)
{
}
skip
(
msg
)
{
throw
new
SkipTestCase
(
msg
)
;
}
skipIf
(
cond
msg
=
'
'
)
{
if
(
cond
)
{
this
.
skip
(
typeof
msg
=
=
=
'
function
'
?
msg
(
)
:
msg
)
;
}
}
}
export
class
Fixture
{
eventualExpectations
=
[
]
;
numOutstandingAsyncExpectations
=
0
;
objectsToCleanUp
=
[
]
;
static
MakeSharedState
(
recorder
params
)
{
return
new
SubcaseBatchState
(
recorder
params
)
;
}
constructor
(
sharedState
rec
params
)
{
this
.
_sharedState
=
sharedState
;
this
.
rec
=
rec
;
this
.
_params
=
params
;
}
get
params
(
)
{
return
this
.
_params
;
}
get
sharedState
(
)
{
return
this
.
_sharedState
;
}
async
init
(
)
{
}
async
finalize
(
)
{
assert
(
this
.
numOutstandingAsyncExpectations
=
=
=
0
'
there
were
outstanding
immediateAsyncExpectations
(
e
.
g
.
expectUncapturedError
)
at
the
end
of
the
test
'
)
;
while
(
this
.
eventualExpectations
.
length
)
{
const
p
=
this
.
eventualExpectations
.
shift
(
)
;
try
{
await
p
;
}
catch
(
ex
)
{
this
.
rec
.
threw
(
ex
)
;
}
}
for
(
const
o
of
this
.
objectsToCleanUp
)
{
if
(
'
getExtension
'
in
o
)
{
const
WEBGL_lose_context
=
o
.
getExtension
(
'
WEBGL_lose_context
'
)
;
if
(
WEBGL_lose_context
)
WEBGL_lose_context
.
loseContext
(
)
;
}
else
if
(
'
destroy
'
in
o
)
{
o
.
destroy
(
)
;
}
else
if
(
'
destroyAsync
'
in
o
)
{
await
o
.
destroyAsync
(
)
;
}
else
if
(
'
close
'
in
o
)
{
o
.
close
(
)
;
}
else
{
o
.
src
=
'
'
;
o
.
srcObject
=
null
;
}
}
}
trackForCleanup
(
o
)
{
if
(
o
instanceof
Promise
)
{
this
.
eventualAsyncExpectation
(
(
)
=
>
o
.
then
(
(
o
)
=
>
this
.
trackForCleanup
(
o
)
(
)
=
>
{
}
)
)
;
return
o
;
}
if
(
o
instanceof
GPUDevice
)
{
this
.
objectsToCleanUp
.
push
(
{
async
destroyAsync
(
)
{
o
.
destroy
(
)
;
await
o
.
lost
;
}
}
)
;
}
else
{
this
.
objectsToCleanUp
.
push
(
o
)
;
}
return
o
;
}
tryTrackForCleanup
(
o
)
{
if
(
typeof
o
=
=
=
'
object
'
&
&
o
!
=
=
null
)
{
if
(
'
destroy
'
in
o
|
|
'
close
'
in
o
|
|
o
instanceof
WebGLRenderingContext
|
|
o
instanceof
WebGL2RenderingContext
)
{
this
.
objectsToCleanUp
.
push
(
o
)
;
}
}
return
o
;
}
requestDeviceTracked
(
adapter
desc
=
undefined
)
{
return
this
.
trackForCleanup
(
adapter
.
requestDevice
(
desc
)
)
;
}
debug
(
msg
)
{
if
(
!
this
.
rec
.
debugging
)
return
;
if
(
typeof
msg
=
=
=
'
function
'
)
{
msg
=
msg
(
)
;
}
this
.
rec
.
debug
(
new
Error
(
msg
)
)
;
}
info
(
msg
)
{
this
.
rec
.
info
(
new
Error
(
msg
)
)
;
}
skip
(
msg
)
{
throw
new
SkipTestCase
(
msg
)
;
}
skipIf
(
cond
msg
=
'
'
)
{
if
(
cond
)
{
this
.
skip
(
typeof
msg
=
=
=
'
function
'
?
msg
(
)
:
msg
)
;
}
}
warn
(
msg
)
{
this
.
rec
.
warn
(
new
Error
(
msg
)
)
;
}
fail
(
msg
)
{
this
.
rec
.
expectationFailed
(
new
Error
(
msg
)
)
;
}
async
immediateAsyncExpectation
(
fn
)
{
this
.
numOutstandingAsyncExpectations
+
+
;
const
ret
=
await
fn
(
)
;
this
.
numOutstandingAsyncExpectations
-
-
;
return
ret
;
}
eventualAsyncExpectation
(
fn
)
{
const
promise
=
fn
(
new
Error
(
)
)
;
this
.
eventualExpectations
.
push
(
promise
)
;
}
expectErrorValue
(
expectedError
ex
niceStack
)
{
if
(
!
(
ex
instanceof
Error
)
)
{
niceStack
.
message
=
THREW
non
-
error
value
of
type
{
typeof
ex
}
:
{
ex
}
;
this
.
rec
.
expectationFailed
(
niceStack
)
;
return
;
}
const
actualName
=
ex
.
name
;
if
(
expectedError
!
=
=
true
&
&
actualName
!
=
=
expectedError
)
{
niceStack
.
message
=
THREW
{
actualName
}
instead
of
{
expectedError
}
:
{
ex
}
;
this
.
rec
.
expectationFailed
(
niceStack
)
;
}
else
{
niceStack
.
message
=
OK
:
threw
{
actualName
}
:
{
ex
.
message
}
;
this
.
rec
.
debug
(
niceStack
)
;
}
}
shouldResolve
(
p
msg
)
{
this
.
eventualAsyncExpectation
(
async
(
niceStack
)
=
>
{
const
m
=
msg
?
'
:
'
+
msg
:
'
'
;
try
{
await
p
;
niceStack
.
message
=
'
resolved
as
expected
'
+
m
;
}
catch
(
ex
)
{
niceStack
.
message
=
REJECTED
{
m
}
;
if
(
ex
instanceof
Error
)
{
niceStack
.
message
+
=
'
\
n
'
+
ex
.
message
;
}
this
.
rec
.
expectationFailed
(
niceStack
)
;
}
}
)
;
}
shouldReject
(
expectedName
p
{
allowMissingStack
=
false
message
}
=
{
}
)
{
this
.
eventualAsyncExpectation
(
async
(
niceStack
)
=
>
{
const
m
=
message
?
'
:
'
+
message
:
'
'
;
try
{
await
p
;
niceStack
.
message
=
'
DID
NOT
REJECT
'
+
m
;
this
.
rec
.
expectationFailed
(
niceStack
)
;
}
catch
(
ex
)
{
this
.
expectErrorValue
(
expectedName
ex
niceStack
)
;
if
(
!
allowMissingStack
)
{
if
(
!
(
ex
instanceof
Error
&
&
typeof
ex
.
stack
=
=
=
'
string
'
)
)
{
const
exMessage
=
ex
instanceof
Error
?
ex
.
message
:
'
?
'
;
niceStack
.
message
=
rejected
as
expected
but
missing
stack
(
{
exMessage
}
)
{
m
}
;
this
.
rec
.
expectationFailed
(
niceStack
)
;
}
}
}
}
)
;
}
shouldThrow
(
expectedError
fn
{
allowMissingStack
=
false
message
}
=
{
}
)
{
const
m
=
message
?
'
:
'
+
message
:
'
'
;
try
{
fn
(
)
;
if
(
expectedError
=
=
=
false
)
{
this
.
rec
.
debug
(
new
Error
(
'
did
not
throw
as
expected
'
+
m
)
)
;
}
else
{
this
.
rec
.
expectationFailed
(
new
Error
(
'
unexpectedly
did
not
throw
'
+
m
)
)
;
}
}
catch
(
ex
)
{
if
(
expectedError
=
=
=
false
)
{
this
.
rec
.
expectationFailed
(
new
Error
(
'
threw
unexpectedly
'
+
m
)
)
;
}
else
{
this
.
expectErrorValue
(
expectedError
ex
new
Error
(
m
)
)
;
if
(
!
allowMissingStack
)
{
if
(
!
(
ex
instanceof
Error
&
&
typeof
ex
.
stack
=
=
=
'
string
'
)
)
{
this
.
rec
.
expectationFailed
(
new
Error
(
'
threw
as
expected
but
missing
stack
'
+
m
)
)
;
}
}
}
}
}
expect
(
cond
msg
)
{
if
(
typeof
cond
=
=
=
'
function
'
)
{
if
(
msg
=
=
=
undefined
)
{
msg
=
cond
.
toString
(
)
;
}
cond
=
cond
(
)
;
}
if
(
cond
)
{
const
m
=
msg
?
'
:
'
+
msg
:
'
'
;
this
.
rec
.
debug
(
new
Error
(
'
expect
OK
'
+
m
)
)
;
}
else
{
this
.
rec
.
expectationFailed
(
new
Error
(
msg
)
)
;
}
return
cond
;
}
expectOK
(
error
{
mode
=
'
fail
'
niceStack
}
=
{
}
)
{
const
handleError
=
(
error
)
=
>
{
if
(
error
instanceof
Error
)
{
if
(
niceStack
)
{
error
.
stack
=
niceStack
.
stack
;
}
if
(
mode
=
=
=
'
fail
'
)
{
this
.
rec
.
expectationFailed
(
error
)
;
}
else
if
(
mode
=
=
=
'
warn
'
)
{
this
.
rec
.
warn
(
error
)
;
}
else
{
unreachable
(
)
;
}
}
}
;
if
(
Array
.
isArray
(
error
)
)
{
for
(
const
e
of
error
)
{
handleError
(
e
)
;
}
}
else
{
handleError
(
error
)
;
}
}
eventualExpectOK
(
error
{
mode
=
'
fail
'
}
=
{
}
)
{
this
.
eventualAsyncExpectation
(
async
(
niceStack
)
=
>
{
this
.
expectOK
(
await
error
{
mode
niceStack
}
)
;
}
)
;
}
}
