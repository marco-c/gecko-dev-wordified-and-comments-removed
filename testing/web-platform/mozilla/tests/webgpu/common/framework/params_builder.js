import
{
mergeParams
mergeParamsChecked
}
from
'
.
.
/
internal
/
params_utils
.
js
'
;
import
{
comparePublicParamsPaths
Ordering
}
from
'
.
.
/
internal
/
query
/
compare
.
js
'
;
import
{
stringifyPublicParams
}
from
'
.
.
/
internal
/
query
/
stringify_params
.
js
'
;
import
{
assert
mapLazy
objectEquals
}
from
'
.
.
/
util
/
util
.
js
'
;
export
class
ParamsBuilderBase
{
constructor
(
cases
)
{
this
.
cases
=
cases
;
}
}
export
function
builderIterateCasesWithSubcases
(
builder
caseFilter
)
{
return
builder
.
iterateCasesWithSubcases
(
caseFilter
)
;
}
export
class
CaseParamsBuilder
extends
ParamsBuilderBase
{
*
iterateCasesWithSubcases
(
caseFilter
)
{
for
(
const
caseP
of
this
.
cases
(
caseFilter
)
)
{
if
(
caseFilter
)
{
const
ordering
=
comparePublicParamsPaths
(
caseP
caseFilter
)
;
if
(
ordering
=
=
=
Ordering
.
StrictSuperset
|
|
ordering
=
=
=
Ordering
.
Unordered
)
{
continue
;
}
}
yield
[
caseP
undefined
]
;
}
}
[
Symbol
.
iterator
]
(
)
{
return
this
.
cases
(
null
)
;
}
expandWithParams
(
expander
)
{
const
baseGenerator
=
this
.
cases
;
return
new
CaseParamsBuilder
(
function
*
(
caseFilter
)
{
for
(
const
a
of
baseGenerator
(
caseFilter
)
)
{
for
(
const
b
of
expander
(
a
)
)
{
if
(
caseFilter
)
{
const
kvPairs
=
Object
.
entries
(
b
)
;
if
(
kvPairs
.
some
(
(
[
k
v
]
)
=
>
k
in
caseFilter
&
&
!
objectEquals
(
caseFilter
[
k
]
v
)
)
)
{
continue
;
}
}
yield
mergeParamsChecked
(
a
b
)
;
}
}
}
)
;
}
expand
(
key
expander
)
{
const
baseGenerator
=
this
.
cases
;
return
new
CaseParamsBuilder
(
function
*
(
caseFilter
)
{
for
(
const
a
of
baseGenerator
(
caseFilter
)
)
{
assert
(
!
(
key
in
a
)
New
key
'
{
key
}
'
already
exists
in
{
JSON
.
stringify
(
a
)
}
)
;
for
(
const
v
of
expander
(
a
)
)
{
if
(
caseFilter
&
&
key
in
caseFilter
)
{
if
(
!
objectEquals
(
caseFilter
[
key
]
v
)
)
{
continue
;
}
}
yield
{
.
.
.
a
[
key
]
:
v
}
;
}
}
}
)
;
}
combineWithParams
(
newParams
)
{
assertNotGenerator
(
newParams
)
;
const
seenValues
=
new
Set
(
)
;
for
(
const
params
of
newParams
)
{
const
paramsStr
=
stringifyPublicParams
(
params
)
;
assert
(
!
seenValues
.
has
(
paramsStr
)
Duplicate
entry
in
combine
[
WithParams
]
:
{
paramsStr
}
)
;
seenValues
.
add
(
paramsStr
)
;
}
return
this
.
expandWithParams
(
(
)
=
>
newParams
)
;
}
combine
(
key
values
)
{
assertNotGenerator
(
values
)
;
const
mapped
=
mapLazy
(
values
v
=
>
(
{
[
key
]
:
v
}
)
)
;
return
this
.
combineWithParams
(
mapped
)
;
}
filter
(
pred
)
{
const
baseGenerator
=
this
.
cases
;
return
new
CaseParamsBuilder
(
function
*
(
caseFilter
)
{
for
(
const
a
of
baseGenerator
(
caseFilter
)
)
{
if
(
pred
(
a
)
)
yield
a
;
}
}
)
;
}
unless
(
pred
)
{
return
this
.
filter
(
x
=
>
!
pred
(
x
)
)
;
}
beginSubcases
(
)
{
return
new
SubcaseParamsBuilder
(
this
.
cases
function
*
(
)
{
yield
{
}
;
}
)
;
}
}
export
const
kUnitCaseParamsBuilder
=
new
CaseParamsBuilder
(
function
*
(
)
{
yield
{
}
;
}
)
;
export
class
SubcaseParamsBuilder
extends
ParamsBuilderBase
{
constructor
(
cases
generator
)
{
super
(
cases
)
;
this
.
subcases
=
generator
;
}
*
iterateCasesWithSubcases
(
caseFilter
)
{
for
(
const
caseP
of
this
.
cases
(
caseFilter
)
)
{
if
(
caseFilter
)
{
const
ordering
=
comparePublicParamsPaths
(
caseP
caseFilter
)
;
if
(
ordering
=
=
=
Ordering
.
StrictSuperset
|
|
ordering
=
=
=
Ordering
.
Unordered
)
{
continue
;
}
}
const
subcases
=
Array
.
from
(
this
.
subcases
(
caseP
)
)
;
if
(
subcases
.
length
)
{
yield
[
caseP
subcases
]
;
}
}
}
expandWithParams
(
expander
)
{
const
baseGenerator
=
this
.
subcases
;
return
new
SubcaseParamsBuilder
(
this
.
cases
function
*
(
base
)
{
for
(
const
a
of
baseGenerator
(
base
)
)
{
for
(
const
b
of
expander
(
mergeParams
(
base
a
)
)
)
{
yield
mergeParamsChecked
(
a
b
)
;
}
}
}
)
;
}
expand
(
key
expander
)
{
const
baseGenerator
=
this
.
subcases
;
return
new
SubcaseParamsBuilder
(
this
.
cases
function
*
(
base
)
{
for
(
const
a
of
baseGenerator
(
base
)
)
{
const
before
=
mergeParams
(
base
a
)
;
assert
(
!
(
key
in
before
)
(
)
=
>
Key
'
{
key
}
'
already
exists
in
{
JSON
.
stringify
(
before
)
}
)
;
for
(
const
v
of
expander
(
before
)
)
{
yield
{
.
.
.
a
[
key
]
:
v
}
;
}
}
}
)
;
}
combineWithParams
(
newParams
)
{
assertNotGenerator
(
newParams
)
;
return
this
.
expandWithParams
(
(
)
=
>
newParams
)
;
}
combine
(
key
values
)
{
assertNotGenerator
(
values
)
;
return
this
.
expand
(
key
(
)
=
>
values
)
;
}
filter
(
pred
)
{
const
baseGenerator
=
this
.
subcases
;
return
new
SubcaseParamsBuilder
(
this
.
cases
function
*
(
base
)
{
for
(
const
a
of
baseGenerator
(
base
)
)
{
if
(
pred
(
mergeParams
(
base
a
)
)
)
yield
a
;
}
}
)
;
}
unless
(
pred
)
{
return
this
.
filter
(
x
=
>
!
pred
(
x
)
)
;
}
}
function
assertNotGenerator
(
x
)
{
if
(
'
constructor
'
in
x
)
{
assert
(
x
.
constructor
!
=
=
(
function
*
(
)
{
}
)
(
)
.
constructor
'
Argument
must
not
be
a
generator
as
generators
are
not
reusable
'
)
;
}
}
