import
{
mergeParams
}
from
'
.
.
/
internal
/
params_utils
.
js
'
;
import
{
stringifyPublicParams
}
from
'
.
.
/
internal
/
query
/
stringify_params
.
js
'
;
import
{
assert
mapLazy
}
from
'
.
.
/
util
/
util
.
js
'
;
export
class
ParamsBuilderBase
{
constructor
(
cases
)
{
this
.
cases
=
cases
;
}
}
export
function
builderIterateCasesWithSubcases
(
builder
)
{
return
builder
.
iterateCasesWithSubcases
(
)
;
}
export
class
CaseParamsBuilder
extends
ParamsBuilderBase
{
*
iterateCasesWithSubcases
(
)
{
for
(
const
a
of
this
.
cases
(
)
)
{
yield
[
a
undefined
]
;
}
}
[
Symbol
.
iterator
]
(
)
{
return
this
.
cases
(
)
;
}
expandWithParams
(
expander
)
{
const
newGenerator
=
expanderGenerator
(
this
.
cases
expander
)
;
return
new
CaseParamsBuilder
(
(
)
=
>
newGenerator
(
{
}
)
)
;
}
expand
(
key
expander
)
{
return
this
.
expandWithParams
(
function
*
(
p
)
{
for
(
const
value
of
expander
(
p
)
)
{
yield
{
[
key
]
:
value
}
;
}
}
)
;
}
combineWithParams
(
newParams
)
{
assertNotGenerator
(
newParams
)
;
const
seenValues
=
new
Set
(
)
;
for
(
const
params
of
newParams
)
{
const
paramsStr
=
stringifyPublicParams
(
params
)
;
assert
(
!
seenValues
.
has
(
paramsStr
)
Duplicate
entry
in
combine
[
WithParams
]
:
{
paramsStr
}
)
;
seenValues
.
add
(
paramsStr
)
;
}
return
this
.
expandWithParams
(
(
)
=
>
newParams
)
;
}
combine
(
key
values
)
{
assertNotGenerator
(
values
)
;
const
mapped
=
mapLazy
(
values
v
=
>
(
{
[
key
]
:
v
}
)
)
;
return
this
.
combineWithParams
(
mapped
)
;
}
filter
(
pred
)
{
const
newGenerator
=
filterGenerator
(
this
.
cases
pred
)
;
return
new
CaseParamsBuilder
(
(
)
=
>
newGenerator
(
{
}
)
)
;
}
unless
(
pred
)
{
return
this
.
filter
(
x
=
>
!
pred
(
x
)
)
;
}
beginSubcases
(
)
{
return
new
SubcaseParamsBuilder
(
(
)
=
>
this
.
cases
(
)
function
*
(
)
{
yield
{
}
;
}
)
;
}
}
export
const
kUnitCaseParamsBuilder
=
new
CaseParamsBuilder
(
function
*
(
)
{
yield
{
}
;
}
)
;
export
class
SubcaseParamsBuilder
extends
ParamsBuilderBase
{
constructor
(
cases
generator
)
{
super
(
cases
)
;
this
.
subcases
=
generator
;
}
*
iterateCasesWithSubcases
(
)
{
for
(
const
caseP
of
this
.
cases
(
)
)
{
const
subcases
=
Array
.
from
(
this
.
subcases
(
caseP
)
)
;
if
(
subcases
.
length
)
{
yield
[
caseP
subcases
]
;
}
}
}
expandWithParams
(
expander
)
{
return
new
SubcaseParamsBuilder
(
this
.
cases
expanderGenerator
(
this
.
subcases
expander
)
)
;
}
expand
(
key
expander
)
{
return
this
.
expandWithParams
(
function
*
(
p
)
{
for
(
const
value
of
expander
(
p
)
)
{
yield
{
[
key
]
:
value
}
;
}
}
)
;
}
combineWithParams
(
newParams
)
{
assertNotGenerator
(
newParams
)
;
return
this
.
expandWithParams
(
(
)
=
>
newParams
)
;
}
combine
(
key
values
)
{
assertNotGenerator
(
values
)
;
return
this
.
expand
(
key
(
)
=
>
values
)
;
}
filter
(
pred
)
{
return
new
SubcaseParamsBuilder
(
this
.
cases
filterGenerator
(
this
.
subcases
pred
)
)
;
}
unless
(
pred
)
{
return
this
.
filter
(
x
=
>
!
pred
(
x
)
)
;
}
}
function
expanderGenerator
(
baseGenerator
expander
)
{
return
function
*
(
base
)
{
for
(
const
a
of
baseGenerator
(
base
)
)
{
for
(
const
b
of
expander
(
mergeParams
(
base
a
)
)
)
{
yield
mergeParams
(
a
b
)
;
}
}
}
;
}
function
filterGenerator
(
baseGenerator
pred
)
{
return
function
*
(
base
)
{
for
(
const
a
of
baseGenerator
(
base
)
)
{
if
(
pred
(
mergeParams
(
base
a
)
)
)
{
yield
a
;
}
}
}
;
}
function
assertNotGenerator
(
x
)
{
if
(
'
constructor
'
in
x
)
{
assert
(
x
.
constructor
!
=
=
(
function
*
(
)
{
}
)
(
)
.
constructor
'
Argument
must
not
be
a
generator
as
generators
are
not
reusable
'
)
;
}
}
