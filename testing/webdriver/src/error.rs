use
backtrace
:
:
Backtrace
;
use
hyper
:
:
status
:
:
StatusCode
;
use
rustc_serialize
:
:
base64
:
:
FromBase64Error
;
use
rustc_serialize
:
:
json
:
:
{
DecoderError
Json
ParserError
ToJson
}
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
collections
:
:
BTreeMap
;
use
std
:
:
convert
:
:
From
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
fmt
;
use
std
:
:
io
;
#
[
derive
(
Debug
PartialEq
)
]
pub
enum
ErrorStatus
{
ElementClickIntercepted
ElementNotInteractable
ElementNotSelectable
InsecureCertificate
InvalidArgument
InvalidCookieDomain
InvalidCoordinates
InvalidElementState
InvalidSelector
InvalidSessionId
JavascriptError
MoveTargetOutOfBounds
NoSuchAlert
NoSuchCookie
NoSuchElement
NoSuchFrame
NoSuchWindow
ScriptTimeout
SessionNotCreated
StaleElementReference
Timeout
UnableToCaptureScreen
UnableToSetCookie
UnexpectedAlertOpen
UnknownCommand
UnknownError
UnknownMethod
UnknownPath
UnsupportedOperation
}
impl
ErrorStatus
{
pub
fn
error_code
(
&
self
)
-
>
&
'
static
str
{
use
self
:
:
ErrorStatus
:
:
*
;
match
*
self
{
ElementClickIntercepted
=
>
"
element
click
intercepted
"
ElementNotInteractable
=
>
"
element
not
interactable
"
ElementNotSelectable
=
>
"
element
not
selectable
"
InsecureCertificate
=
>
"
insecure
certificate
"
InvalidArgument
=
>
"
invalid
argument
"
InvalidCookieDomain
=
>
"
invalid
cookie
domain
"
InvalidCoordinates
=
>
"
invalid
coordinates
"
InvalidElementState
=
>
"
invalid
element
state
"
InvalidSelector
=
>
"
invalid
selector
"
InvalidSessionId
=
>
"
invalid
session
id
"
JavascriptError
=
>
"
javascript
error
"
MoveTargetOutOfBounds
=
>
"
move
target
out
of
bounds
"
NoSuchAlert
=
>
"
no
such
alert
"
NoSuchCookie
=
>
"
no
such
cookie
"
NoSuchElement
=
>
"
no
such
element
"
NoSuchFrame
=
>
"
no
such
frame
"
NoSuchWindow
=
>
"
no
such
window
"
ScriptTimeout
=
>
"
script
timeout
"
SessionNotCreated
=
>
"
session
not
created
"
StaleElementReference
=
>
"
stale
element
reference
"
Timeout
=
>
"
timeout
"
UnableToCaptureScreen
=
>
"
unable
to
capture
screen
"
UnableToSetCookie
=
>
"
unable
to
set
cookie
"
UnexpectedAlertOpen
=
>
"
unexpected
alert
open
"
UnknownCommand
|
UnknownError
=
>
"
unknown
error
"
UnknownMethod
=
>
"
unknown
method
"
UnknownPath
=
>
"
unknown
command
"
UnsupportedOperation
=
>
"
unsupported
operation
"
}
}
pub
fn
http_status
(
&
self
)
-
>
StatusCode
{
use
self
:
:
ErrorStatus
:
:
*
;
use
self
:
:
StatusCode
:
:
*
;
match
*
self
{
ElementClickIntercepted
=
>
BadRequest
ElementNotInteractable
=
>
BadRequest
ElementNotSelectable
=
>
BadRequest
InsecureCertificate
=
>
BadRequest
InvalidArgument
=
>
BadRequest
InvalidCookieDomain
=
>
BadRequest
InvalidCoordinates
=
>
BadRequest
InvalidElementState
=
>
BadRequest
InvalidSelector
=
>
BadRequest
InvalidSessionId
=
>
NotFound
JavascriptError
=
>
InternalServerError
MoveTargetOutOfBounds
=
>
InternalServerError
NoSuchAlert
=
>
NotFound
NoSuchCookie
=
>
NotFound
NoSuchElement
=
>
NotFound
NoSuchFrame
=
>
NotFound
NoSuchWindow
=
>
NotFound
ScriptTimeout
=
>
RequestTimeout
SessionNotCreated
=
>
InternalServerError
StaleElementReference
=
>
BadRequest
Timeout
=
>
RequestTimeout
UnableToCaptureScreen
=
>
BadRequest
UnableToSetCookie
=
>
InternalServerError
UnexpectedAlertOpen
=
>
InternalServerError
UnknownCommand
=
>
NotFound
UnknownError
=
>
InternalServerError
UnknownMethod
=
>
MethodNotAllowed
UnknownPath
=
>
NotFound
UnsupportedOperation
=
>
InternalServerError
}
}
}
pub
type
WebDriverResult
<
T
>
=
Result
<
T
WebDriverError
>
;
#
[
derive
(
Debug
)
]
pub
struct
WebDriverError
{
pub
error
:
ErrorStatus
pub
message
:
Cow
<
'
static
str
>
pub
stack
:
Cow
<
'
static
str
>
pub
delete_session
:
bool
}
impl
WebDriverError
{
pub
fn
new
<
S
>
(
error
:
ErrorStatus
message
:
S
)
-
>
WebDriverError
where
S
:
Into
<
Cow
<
'
static
str
>
>
{
WebDriverError
{
error
:
error
message
:
message
.
into
(
)
stack
:
format
!
(
"
{
:
?
}
"
Backtrace
:
:
new
(
)
)
.
into
(
)
delete_session
:
false
}
}
pub
fn
new_with_stack
<
S
>
(
error
:
ErrorStatus
message
:
S
stack
:
S
)
-
>
WebDriverError
where
S
:
Into
<
Cow
<
'
static
str
>
>
{
WebDriverError
{
error
:
error
message
:
message
.
into
(
)
stack
:
stack
.
into
(
)
delete_session
:
false
}
}
pub
fn
error_code
(
&
self
)
-
>
&
'
static
str
{
self
.
error
.
error_code
(
)
}
pub
fn
http_status
(
&
self
)
-
>
StatusCode
{
self
.
error
.
http_status
(
)
}
pub
fn
to_json_string
(
&
self
)
-
>
String
{
self
.
to_json
(
)
.
to_string
(
)
}
}
impl
ToJson
for
WebDriverError
{
fn
to_json
(
&
self
)
-
>
Json
{
let
mut
data
=
BTreeMap
:
:
new
(
)
;
data
.
insert
(
"
error
"
.
into
(
)
self
.
error_code
(
)
.
to_json
(
)
)
;
data
.
insert
(
"
message
"
.
into
(
)
self
.
message
.
to_json
(
)
)
;
data
.
insert
(
"
stacktrace
"
.
into
(
)
self
.
stack
.
to_json
(
)
)
;
let
mut
wrapper
=
BTreeMap
:
:
new
(
)
;
wrapper
.
insert
(
"
value
"
.
into
(
)
Json
:
:
Object
(
data
)
)
;
Json
:
:
Object
(
wrapper
)
}
}
impl
Error
for
WebDriverError
{
fn
description
(
&
self
)
-
>
&
str
{
self
.
error_code
(
)
}
fn
cause
(
&
self
)
-
>
Option
<
&
Error
>
{
None
}
}
impl
fmt
:
:
Display
for
WebDriverError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
message
.
fmt
(
f
)
}
}
impl
From
<
ParserError
>
for
WebDriverError
{
fn
from
(
err
:
ParserError
)
-
>
WebDriverError
{
WebDriverError
:
:
new
(
ErrorStatus
:
:
UnknownError
err
.
description
(
)
.
to_string
(
)
)
}
}
impl
From
<
io
:
:
Error
>
for
WebDriverError
{
fn
from
(
err
:
io
:
:
Error
)
-
>
WebDriverError
{
WebDriverError
:
:
new
(
ErrorStatus
:
:
UnknownError
err
.
description
(
)
.
to_string
(
)
)
}
}
impl
From
<
DecoderError
>
for
WebDriverError
{
fn
from
(
err
:
DecoderError
)
-
>
WebDriverError
{
WebDriverError
:
:
new
(
ErrorStatus
:
:
UnknownError
err
.
description
(
)
.
to_string
(
)
)
}
}
impl
From
<
FromBase64Error
>
for
WebDriverError
{
fn
from
(
err
:
FromBase64Error
)
-
>
WebDriverError
{
WebDriverError
:
:
new
(
ErrorStatus
:
:
UnknownError
err
.
description
(
)
.
to_string
(
)
)
}
}
impl
From
<
Box
<
Error
>
>
for
WebDriverError
{
fn
from
(
err
:
Box
<
Error
>
)
-
>
WebDriverError
{
WebDriverError
:
:
new
(
ErrorStatus
:
:
UnknownError
err
.
description
(
)
.
to_string
(
)
)
}
}
