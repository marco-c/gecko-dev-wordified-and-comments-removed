"
use
strict
"
;
if
(
!
Cu
.
isInAutomation
)
{
throw
new
Error
(
"
WrapPrivileged
.
jsm
is
only
for
use
in
automation
"
)
;
}
Cu
.
forcePermissiveCOWs
(
)
;
var
EXPORTED_SYMBOLS
=
[
"
WrapPrivileged
"
]
;
function
isWrappable
(
x
)
{
if
(
typeof
x
=
=
=
"
object
"
)
{
return
x
!
=
=
null
;
}
return
typeof
x
=
=
=
"
function
"
;
}
function
isWrapper
(
x
)
{
try
{
return
isWrappable
(
x
)
&
&
typeof
x
.
SpecialPowers_wrappedObject
!
=
=
"
undefined
"
;
}
catch
(
e
)
{
return
false
;
}
}
function
unwrapIfWrapped
(
x
)
{
return
isWrapper
(
x
)
?
unwrapPrivileged
(
x
)
:
x
;
}
function
wrapIfUnwrapped
(
x
)
{
return
isWrapper
(
x
)
?
x
:
wrapPrivileged
(
x
)
;
}
function
isObjectOrArray
(
obj
)
{
if
(
Object
(
obj
)
!
=
=
obj
)
{
return
false
;
}
let
arrayClasses
=
[
"
Object
"
"
Array
"
"
Int8Array
"
"
Uint8Array
"
"
Int16Array
"
"
Uint16Array
"
"
Int32Array
"
"
Uint32Array
"
"
Float32Array
"
"
Float64Array
"
"
Uint8ClampedArray
"
]
;
let
className
=
Cu
.
getClassName
(
obj
true
)
;
return
arrayClasses
.
includes
(
className
)
;
}
function
waiveXraysIfAppropriate
(
obj
propName
)
{
if
(
propName
=
=
"
toString
"
|
|
isObjectOrArray
(
obj
)
|
|
/
Opaque
/
.
test
(
Object
.
prototype
.
toString
.
call
(
obj
)
)
)
{
return
XPCNativeWrapper
.
unwrap
(
obj
)
;
}
return
obj
;
}
function
doApply
(
fun
invocant
args
)
{
args
=
args
.
map
(
x
=
>
(
isObjectOrArray
(
x
)
?
Cu
.
waiveXrays
(
x
)
:
x
)
)
;
return
Reflect
.
apply
(
fun
invocant
args
)
;
}
function
wrapPrivileged
(
obj
)
{
if
(
!
isWrappable
(
obj
)
)
{
return
obj
;
}
if
(
isWrapper
(
obj
)
)
{
throw
new
Error
(
"
Trying
to
double
-
wrap
object
!
"
)
;
}
let
dummy
;
if
(
typeof
obj
=
=
=
"
function
"
)
{
dummy
=
function
(
)
{
}
;
}
else
{
dummy
=
Object
.
create
(
null
)
;
}
return
new
Proxy
(
dummy
new
SpecialPowersHandler
(
obj
)
)
;
}
function
unwrapPrivileged
(
x
)
{
if
(
!
isWrappable
(
x
)
)
{
return
x
;
}
if
(
!
isWrapper
(
x
)
)
{
throw
new
Error
(
"
Trying
to
unwrap
a
non
-
wrapped
object
!
"
)
;
}
var
obj
=
x
.
SpecialPowers_wrappedObject
;
return
obj
;
}
function
specialPowersHasInstance
(
value
)
{
return
value
instanceof
this
;
}
function
SpecialPowersHandler
(
wrappedObject
)
{
this
.
wrappedObject
=
wrappedObject
;
}
SpecialPowersHandler
.
prototype
=
{
construct
(
target
args
)
{
var
unwrappedArgs
=
Array
.
prototype
.
slice
.
call
(
args
)
.
map
(
unwrapIfWrapped
)
;
try
{
return
wrapIfUnwrapped
(
Reflect
.
construct
(
this
.
wrappedObject
unwrappedArgs
)
)
;
}
catch
(
e
)
{
throw
wrapIfUnwrapped
(
e
)
;
}
}
apply
(
target
thisValue
args
)
{
var
invocant
=
unwrapIfWrapped
(
thisValue
)
;
var
unwrappedArgs
=
Array
.
prototype
.
slice
.
call
(
args
)
.
map
(
unwrapIfWrapped
)
;
try
{
return
wrapIfUnwrapped
(
doApply
(
this
.
wrappedObject
invocant
unwrappedArgs
)
)
;
}
catch
(
e
)
{
throw
wrapIfUnwrapped
(
e
)
;
}
}
has
(
target
prop
)
{
if
(
prop
=
=
=
"
SpecialPowers_wrappedObject
"
)
{
return
true
;
}
return
Reflect
.
has
(
this
.
wrappedObject
prop
)
;
}
get
(
target
prop
receiver
)
{
if
(
prop
=
=
=
"
SpecialPowers_wrappedObject
"
)
{
return
this
.
wrappedObject
;
}
let
obj
=
waiveXraysIfAppropriate
(
this
.
wrappedObject
prop
)
;
let
val
=
Reflect
.
get
(
obj
prop
)
;
if
(
val
=
=
=
undefined
&
&
prop
=
=
Symbol
.
hasInstance
)
{
return
wrapPrivileged
(
specialPowersHasInstance
)
;
}
return
wrapIfUnwrapped
(
val
)
;
}
set
(
target
prop
val
receiver
)
{
if
(
prop
=
=
=
"
SpecialPowers_wrappedObject
"
)
{
return
false
;
}
let
obj
=
waiveXraysIfAppropriate
(
this
.
wrappedObject
prop
)
;
return
Reflect
.
set
(
obj
prop
unwrapIfWrapped
(
val
)
)
;
}
delete
(
target
prop
)
{
if
(
prop
=
=
=
"
SpecialPowers_wrappedObject
"
)
{
return
false
;
}
return
Reflect
.
deleteProperty
(
this
.
wrappedObject
prop
)
;
}
defineProperty
(
target
prop
descriptor
)
{
throw
new
Error
(
"
Can
'
t
call
defineProperty
on
SpecialPowers
wrapped
object
"
)
;
}
getOwnPropertyDescriptor
(
target
prop
)
{
if
(
prop
=
=
=
"
SpecialPowers_wrappedObject
"
)
{
return
{
value
:
this
.
wrappedObject
writeable
:
true
configurable
:
true
enumerable
:
false
}
;
}
let
obj
=
waiveXraysIfAppropriate
(
this
.
wrappedObject
prop
)
;
let
desc
=
Reflect
.
getOwnPropertyDescriptor
(
obj
prop
)
;
if
(
desc
=
=
=
undefined
)
{
if
(
prop
=
=
Symbol
.
hasInstance
)
{
return
{
value
:
wrapPrivileged
(
specialPowersHasInstance
)
writeable
:
true
configurable
:
true
enumerable
:
false
}
;
}
return
undefined
;
}
function
wrapIfExists
(
key
)
{
if
(
key
in
desc
)
{
desc
[
key
]
=
wrapIfUnwrapped
(
desc
[
key
]
)
;
}
}
wrapIfExists
(
"
value
"
)
;
wrapIfExists
(
"
get
"
)
;
wrapIfExists
(
"
set
"
)
;
desc
.
configurable
=
true
;
return
desc
;
}
ownKeys
(
target
)
{
let
props
=
[
"
SpecialPowers_wrappedObject
"
]
;
let
flt
=
a
=
>
!
props
.
includes
(
a
)
;
props
=
props
.
concat
(
Reflect
.
ownKeys
(
this
.
wrappedObject
)
.
filter
(
flt
)
)
;
if
(
"
wrappedJSObject
"
in
this
.
wrappedObject
)
{
props
=
props
.
concat
(
Reflect
.
ownKeys
(
this
.
wrappedObject
.
wrappedJSObject
)
.
filter
(
flt
)
)
;
}
return
props
;
}
preventExtensions
(
target
)
{
throw
new
Error
(
"
Can
'
t
call
preventExtensions
on
SpecialPowers
wrapped
object
"
)
;
}
}
;
function
wrapCallback
(
cb
)
{
return
function
SpecialPowersCallbackWrapper
(
)
{
var
args
=
Array
.
prototype
.
map
.
call
(
arguments
wrapIfUnwrapped
)
;
return
cb
.
apply
(
this
args
)
;
}
;
}
function
wrapCallbackObject
(
obj
)
{
obj
=
Cu
.
waiveXrays
(
obj
)
;
var
wrapper
=
{
}
;
for
(
var
i
in
obj
)
{
if
(
typeof
obj
[
i
]
=
=
"
function
"
)
{
wrapper
[
i
]
=
wrapCallback
(
obj
[
i
]
)
;
}
else
{
wrapper
[
i
]
=
obj
[
i
]
;
}
}
return
wrapper
;
}
var
WrapPrivileged
=
{
wrap
:
wrapIfUnwrapped
unwrap
:
unwrapIfWrapped
isWrapper
wrapCallback
wrapCallbackObject
}
;
