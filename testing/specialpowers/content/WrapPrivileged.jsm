"
use
strict
"
;
Cu
.
crashIfNotInAutomation
(
)
;
var
EXPORTED_SYMBOLS
=
[
"
WrapPrivileged
"
]
;
let
wrappedObjects
=
new
WeakMap
(
)
;
let
perWindowInfo
=
new
WeakMap
(
)
;
let
noAutoWrap
=
new
WeakSet
(
)
;
function
isWrappable
(
x
)
{
if
(
typeof
x
=
=
=
"
object
"
)
{
return
x
!
=
=
null
;
}
return
typeof
x
=
=
=
"
function
"
;
}
function
isWrapper
(
x
)
{
try
{
return
isWrappable
(
x
)
&
&
wrappedObjects
.
has
(
x
)
;
}
catch
(
e
)
{
return
false
;
}
}
function
unwrapIfWrapped
(
x
)
{
return
isWrapper
(
x
)
?
unwrapPrivileged
(
x
)
:
x
;
}
function
wrapIfUnwrapped
(
x
w
)
{
return
isWrapper
(
x
)
?
x
:
wrapPrivileged
(
x
w
)
;
}
function
isObjectOrArray
(
obj
)
{
if
(
Object
(
obj
)
!
=
=
obj
)
{
return
false
;
}
let
arrayClasses
=
[
"
Object
"
"
Array
"
"
Int8Array
"
"
Uint8Array
"
"
Int16Array
"
"
Uint16Array
"
"
Int32Array
"
"
Uint32Array
"
"
Float32Array
"
"
Float64Array
"
"
Uint8ClampedArray
"
]
;
let
className
=
Cu
.
getClassName
(
obj
true
)
;
return
arrayClasses
.
includes
(
className
)
;
}
function
waiveXraysIfAppropriate
(
obj
propName
)
{
if
(
propName
=
=
"
toString
"
|
|
isObjectOrArray
(
obj
)
|
|
/
Opaque
/
.
test
(
Object
.
prototype
.
toString
.
call
(
obj
)
)
)
{
return
XPCNativeWrapper
.
unwrap
(
obj
)
;
}
return
obj
;
}
function
doApply
(
fun
invocant
args
)
{
args
=
args
.
map
(
x
=
>
(
isObjectOrArray
(
x
)
?
Cu
.
waiveXrays
(
x
)
:
x
)
)
;
return
Reflect
.
apply
(
fun
invocant
args
)
;
}
function
wrapPrivileged
(
obj
win
)
{
if
(
!
isWrappable
(
obj
)
)
{
return
obj
;
}
if
(
isWrapper
(
obj
)
)
{
throw
new
Error
(
"
Trying
to
double
-
wrap
object
!
"
)
;
}
let
{
windowID
proxies
handler
}
=
perWindowInfo
.
get
(
win
)
|
|
{
}
;
let
currentID
=
win
.
windowGlobalChild
?
win
.
windowGlobalChild
.
innerWindowId
:
0
;
if
(
windowID
!
=
=
currentID
)
{
windowID
=
currentID
;
proxies
=
new
WeakMap
(
)
;
handler
=
Cu
.
cloneInto
(
SpecialPowersHandler
win
{
cloneFunctions
:
true
}
)
;
handler
.
wrapped
=
new
win
.
WeakMap
(
)
;
perWindowInfo
.
set
(
win
{
windowID
proxies
handler
}
)
;
}
if
(
proxies
.
has
(
obj
)
)
{
return
proxies
.
get
(
obj
)
.
proxy
;
}
let
className
=
Cu
.
getClassName
(
obj
true
)
;
if
(
className
=
=
=
"
ArrayBuffer
"
)
{
return
obj
instanceof
win
.
ArrayBuffer
?
obj
:
Cu
.
cloneInto
(
obj
win
)
;
}
let
dummy
;
if
(
typeof
obj
=
=
=
"
function
"
)
{
dummy
=
Cu
.
exportFunction
(
function
(
)
{
}
win
)
;
}
else
{
dummy
=
new
win
.
Object
(
)
;
}
handler
.
wrapped
.
set
(
dummy
{
obj
}
)
;
let
proxy
=
new
win
.
Proxy
(
dummy
handler
)
;
wrappedObjects
.
set
(
proxy
obj
)
;
switch
(
className
)
{
case
"
AnonymousContent
"
:
break
;
case
"
CSS2Properties
"
:
case
"
CSSStyleRule
"
:
case
"
CSSStyleSheet
"
:
break
;
default
:
proxies
.
set
(
obj
{
proxy
}
)
;
break
;
}
return
proxy
;
}
function
unwrapPrivileged
(
x
)
{
if
(
!
isWrappable
(
x
)
)
{
return
x
;
}
if
(
!
isWrapper
(
x
)
)
{
throw
new
Error
(
"
Trying
to
unwrap
a
non
-
wrapped
object
!
"
)
;
}
return
wrappedObjects
.
get
(
x
)
;
}
function
wrapExceptions
(
global
fn
)
{
try
{
return
fn
(
)
;
}
catch
(
e
)
{
throw
wrapIfUnwrapped
(
e
global
)
;
}
}
let
SpecialPowersHandler
=
{
construct
(
target
args
)
{
var
unwrappedArgs
=
Array
.
from
(
Cu
.
waiveXrays
(
args
)
x
=
>
unwrapIfWrapped
(
Cu
.
unwaiveXrays
(
x
)
)
)
;
let
global
=
Cu
.
getGlobalForObject
(
this
)
;
return
wrapExceptions
(
global
(
)
=
>
wrapIfUnwrapped
(
Reflect
.
construct
(
this
.
wrapped
.
get
(
target
)
.
obj
unwrappedArgs
)
global
)
)
;
}
apply
(
target
thisValue
args
)
{
let
wrappedObject
=
this
.
wrapped
.
get
(
target
)
.
obj
;
let
global
=
Cu
.
getGlobalForObject
(
this
)
;
var
invocant
=
unwrapIfWrapped
(
thisValue
)
;
return
wrapExceptions
(
global
(
)
=
>
{
if
(
noAutoWrap
.
has
(
wrappedObject
)
)
{
args
=
Array
.
from
(
Cu
.
waiveXrays
(
args
)
x
=
>
Cu
.
unwaiveXrays
(
x
)
)
;
return
doApply
(
wrappedObject
invocant
args
)
;
}
if
(
wrappedObject
.
name
=
=
"
then
"
)
{
args
=
Array
.
from
(
Cu
.
waiveXrays
(
args
)
x
=
>
wrapCallback
(
Cu
.
unwaiveXrays
(
x
)
global
)
)
;
}
else
{
args
=
Array
.
from
(
Cu
.
waiveXrays
(
args
)
x
=
>
unwrapIfWrapped
(
Cu
.
unwaiveXrays
(
x
)
)
)
;
}
return
wrapIfUnwrapped
(
doApply
(
wrappedObject
invocant
args
)
global
)
;
}
)
;
}
has
(
target
prop
)
{
return
Reflect
.
has
(
this
.
wrapped
.
get
(
target
)
.
obj
prop
)
;
}
get
(
target
prop
receiver
)
{
let
global
=
Cu
.
getGlobalForObject
(
this
)
;
return
wrapExceptions
(
global
(
)
=
>
{
let
obj
=
waiveXraysIfAppropriate
(
this
.
wrapped
.
get
(
target
)
.
obj
prop
)
;
let
val
=
Reflect
.
get
(
obj
prop
)
;
return
wrapIfUnwrapped
(
val
global
)
;
}
)
;
}
set
(
target
prop
val
receiver
)
{
return
wrapExceptions
(
Cu
.
getGlobalForObject
(
this
)
(
)
=
>
{
let
obj
=
waiveXraysIfAppropriate
(
this
.
wrapped
.
get
(
target
)
.
obj
prop
)
;
return
Reflect
.
set
(
obj
prop
unwrapIfWrapped
(
val
)
)
;
}
)
;
}
delete
(
target
prop
)
{
return
wrapExceptions
(
Cu
.
getGlobalForObject
(
this
)
(
)
=
>
{
return
Reflect
.
deleteProperty
(
this
.
wrapped
.
get
(
target
)
.
obj
prop
)
;
}
)
;
}
defineProperty
(
target
prop
descriptor
)
{
throw
new
Error
(
"
Can
'
t
call
defineProperty
on
SpecialPowers
wrapped
object
"
)
;
}
getOwnPropertyDescriptor
(
target
prop
)
{
let
global
=
Cu
.
getGlobalForObject
(
this
)
;
return
wrapExceptions
(
global
(
)
=
>
{
let
obj
=
waiveXraysIfAppropriate
(
this
.
wrapped
.
get
(
target
)
.
obj
prop
)
;
let
desc
=
Reflect
.
getOwnPropertyDescriptor
(
obj
prop
)
;
if
(
desc
=
=
=
undefined
)
{
return
undefined
;
}
let
wrapIfExists
=
key
=
>
{
if
(
key
in
desc
)
{
desc
[
key
]
=
wrapIfUnwrapped
(
desc
[
key
]
global
)
;
}
}
;
wrapIfExists
(
"
value
"
)
;
wrapIfExists
(
"
get
"
)
;
wrapIfExists
(
"
set
"
)
;
desc
.
configurable
=
true
;
return
wrapIfUnwrapped
(
desc
global
)
;
}
)
;
}
ownKeys
(
target
)
{
let
props
=
[
]
;
let
wrappedObject
=
this
.
wrapped
.
get
(
target
)
.
obj
;
let
flt
=
a
=
>
!
props
.
includes
(
a
)
;
props
=
props
.
concat
(
Reflect
.
ownKeys
(
wrappedObject
)
.
filter
(
flt
)
)
;
if
(
"
wrappedJSObject
"
in
wrappedObject
)
{
props
=
props
.
concat
(
Reflect
.
ownKeys
(
wrappedObject
.
wrappedJSObject
)
.
filter
(
flt
)
)
;
}
return
Cu
.
cloneInto
(
props
Cu
.
getGlobalForObject
(
this
)
)
;
}
preventExtensions
(
target
)
{
throw
new
Error
(
"
Can
'
t
call
preventExtensions
on
SpecialPowers
wrapped
object
"
)
;
}
}
;
function
wrapCallback
(
cb
win
)
{
if
(
!
isWrappable
(
cb
)
|
|
Cu
.
getObjectPrincipal
(
cb
)
.
isSystemPrincipal
)
{
return
cb
;
}
return
function
SpecialPowersCallbackWrapper
(
)
{
var
args
=
Array
.
from
(
arguments
obj
=
>
wrapIfUnwrapped
(
obj
win
)
)
;
let
invocant
=
wrapIfUnwrapped
(
this
win
)
;
return
unwrapIfWrapped
(
cb
.
apply
(
invocant
args
)
)
;
}
;
}
function
wrapCallbackObject
(
obj
win
)
{
if
(
!
isWrappable
(
obj
)
|
|
Cu
.
getObjectPrincipal
(
obj
)
.
isSystemPrincipal
)
{
return
obj
;
}
obj
=
Cu
.
waiveXrays
(
obj
)
;
var
wrapper
=
{
}
;
for
(
var
i
in
obj
)
{
if
(
typeof
obj
[
i
]
=
=
"
function
"
)
{
wrapper
[
i
]
=
wrapCallback
(
Cu
.
unwaiveXrays
(
obj
[
i
]
)
win
)
;
}
else
{
wrapper
[
i
]
=
obj
[
i
]
;
}
}
return
wrapper
;
}
function
disableAutoWrap
(
.
.
.
objs
)
{
objs
.
forEach
(
x
=
>
noAutoWrap
.
add
(
x
)
)
;
}
var
WrapPrivileged
=
{
wrap
:
wrapIfUnwrapped
unwrap
:
unwrapIfWrapped
isWrapper
wrapCallback
wrapCallbackObject
disableAutoWrap
}
;
