var
EXPORTED_SYMBOLS
=
[
"
SpecialPowersSandbox
"
]
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
Assert
"
"
resource
:
/
/
testing
-
common
/
Assert
.
jsm
"
)
;
const
SANDBOX_GLOBALS
=
[
"
Blob
"
"
ChromeUtils
"
"
FileReader
"
"
TextDecoder
"
"
TextEncoder
"
"
URL
"
]
;
const
EXTRA_IMPORTS
=
{
EventUtils
:
"
resource
:
/
/
specialpowers
/
SpecialPowersEventUtils
.
jsm
"
}
;
let
expectFail
=
false
;
function
expectingFail
(
fn
)
{
try
{
expectFail
=
true
;
fn
(
)
;
}
finally
{
expectFail
=
false
;
}
}
class
SpecialPowersSandbox
{
constructor
(
name
reportCallback
opts
=
{
}
)
{
this
.
name
=
name
;
this
.
reportCallback
=
reportCallback
;
this
.
_Assert
=
null
;
this
.
sandbox
=
Cu
.
Sandbox
(
Cu
.
getGlobalForObject
(
{
}
)
Object
.
assign
(
{
wantGlobalProperties
:
SANDBOX_GLOBALS
}
opts
.
sandboxOptions
)
)
;
for
(
let
prop
of
[
"
assert
"
"
Assert
"
]
)
{
Object
.
defineProperty
(
this
.
sandbox
prop
{
get
:
(
)
=
>
{
return
this
.
Assert
;
}
enumerable
:
true
configurable
:
true
}
)
;
}
let
imports
=
{
.
.
.
EXTRA_IMPORTS
.
.
.
opts
.
imports
}
;
for
(
let
[
symbol
url
]
of
Object
.
entries
(
imports
)
)
{
ChromeUtils
.
defineModuleGetter
(
this
.
sandbox
symbol
url
)
;
}
Object
.
assign
(
this
.
sandbox
{
BrowsingContext
InspectorUtils
ok
:
(
.
.
.
args
)
=
>
{
this
.
Assert
.
ok
(
.
.
.
args
)
;
}
is
:
(
.
.
.
args
)
=
>
{
this
.
Assert
.
equal
(
.
.
.
args
)
;
}
isnot
:
(
.
.
.
args
)
=
>
{
this
.
Assert
.
notEqual
(
.
.
.
args
)
;
}
todo
:
(
.
.
.
args
)
=
>
{
expectingFail
(
(
)
=
>
this
.
Assert
.
ok
(
.
.
.
args
)
)
;
}
todo_is
:
(
.
.
.
args
)
=
>
{
expectingFail
(
(
)
=
>
this
.
Assert
.
equal
(
.
.
.
args
)
)
;
}
info
:
info
=
>
{
this
.
reportCallback
(
{
info
}
)
;
}
}
)
;
}
get
Assert
(
)
{
if
(
!
this
.
_Assert
)
{
this
.
_Assert
=
new
lazy
.
Assert
(
(
err
message
stack
)
=
>
{
this
.
report
(
err
message
stack
)
;
}
)
;
}
return
this
.
_Assert
;
}
report
(
err
name
stack
)
{
let
diag
;
if
(
err
)
{
diag
=
got
{
uneval
(
err
.
actual
)
}
expected
{
uneval
(
err
.
expected
)
}
+
(
operator
{
err
.
operator
}
)
;
}
this
.
reportCallback
(
{
name
diag
passed
:
!
err
stack
:
stack
&
&
stack
.
formattedStack
expectFail
}
)
;
}
execute
(
task
args
caller
)
{
let
func
=
Cu
.
evalInSandbox
(
(
{
task
}
)
this
.
sandbox
undefined
caller
.
filename
caller
.
lineNumber
)
;
return
func
(
.
.
.
args
)
;
}
}
