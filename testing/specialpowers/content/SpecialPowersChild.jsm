"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SpecialPowersChild
"
]
;
var
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MockFilePicker
"
"
resource
:
/
/
specialpowers
/
MockFilePicker
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MockColorPicker
"
"
resource
:
/
/
specialpowers
/
MockColorPicker
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MockPermissionPrompt
"
"
resource
:
/
/
specialpowers
/
MockPermissionPrompt
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SpecialPowersSandbox
"
"
resource
:
/
/
specialpowers
/
SpecialPowersSandbox
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
WrapPrivileged
"
"
resource
:
/
/
specialpowers
/
WrapPrivileged
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PerTestCoverageUtils
"
"
resource
:
/
/
testing
-
common
/
PerTestCoverageUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ContentTaskUtils
"
"
resource
:
/
/
testing
-
common
/
ContentTaskUtils
.
jsm
"
)
;
Cu
.
crashIfNotInAutomation
(
)
;
function
bindDOMWindowUtils
(
aWindow
)
{
return
aWindow
&
&
WrapPrivileged
.
wrap
(
aWindow
.
windowUtils
aWindow
)
;
}
function
defineSpecialPowers
(
sp
)
{
let
window
=
sp
.
contentWindow
;
window
.
SpecialPowers
=
sp
;
if
(
window
=
=
=
window
.
wrappedJSObject
)
{
return
;
}
Object
.
defineProperty
(
window
.
wrappedJSObject
"
SpecialPowers
"
{
get
(
)
{
let
value
=
WrapPrivileged
.
wrap
(
sp
window
)
;
Object
.
defineProperty
(
window
.
wrappedJSObject
"
SpecialPowers
"
{
configurable
:
true
enumerable
:
true
value
writable
:
true
}
)
;
return
value
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
function
SPConsoleListener
(
callback
contentWindow
)
{
this
.
callback
=
callback
;
this
.
contentWindow
=
contentWindow
;
}
SPConsoleListener
.
prototype
=
{
observe
(
msg
topic
)
{
let
m
=
{
message
:
msg
.
message
errorMessage
:
null
cssSelectors
:
null
sourceName
:
null
sourceLine
:
null
lineNumber
:
null
columnNumber
:
null
category
:
null
windowID
:
null
isScriptError
:
false
isConsoleEvent
:
false
isWarning
:
false
}
;
if
(
msg
instanceof
Ci
.
nsIScriptError
)
{
m
.
errorMessage
=
msg
.
errorMessage
;
m
.
cssSelectors
=
msg
.
cssSelectors
;
m
.
sourceName
=
msg
.
sourceName
;
m
.
sourceLine
=
msg
.
sourceLine
;
m
.
lineNumber
=
msg
.
lineNumber
;
m
.
columnNumber
=
msg
.
columnNumber
;
m
.
category
=
msg
.
category
;
m
.
windowID
=
msg
.
outerWindowID
;
m
.
innerWindowID
=
msg
.
innerWindowID
;
m
.
isScriptError
=
true
;
m
.
isWarning
=
(
msg
.
flags
&
Ci
.
nsIScriptError
.
warningFlag
)
=
=
=
1
;
}
else
if
(
topic
=
=
=
"
console
-
api
-
log
-
event
"
)
{
let
unwrapped
=
msg
.
wrappedJSObject
;
m
.
errorMessage
=
unwrapped
.
arguments
[
0
]
;
m
.
sourceName
=
unwrapped
.
filename
;
m
.
lineNumber
=
unwrapped
.
lineNumber
;
m
.
columnNumber
=
unwrapped
.
columnNumber
;
m
.
windowID
=
unwrapped
.
ID
;
m
.
innerWindowID
=
unwrapped
.
innerID
;
m
.
isConsoleEvent
=
true
;
m
.
isWarning
=
unwrapped
.
level
=
=
=
"
warning
"
;
}
Object
.
freeze
(
m
)
;
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
this
.
callback
.
call
(
undefined
Cu
.
cloneInto
(
m
this
.
contentWindow
)
)
;
}
)
;
if
(
!
m
.
isScriptError
&
&
!
m
.
isConsoleEvent
&
&
m
.
message
=
=
=
"
SENTINEL
"
)
{
Services
.
obs
.
removeObserver
(
this
"
console
-
api
-
log
-
event
"
)
;
Services
.
console
.
unregisterListener
(
this
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIConsoleListener
"
"
nsIObserver
"
]
)
}
;
class
SpecialPowersChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
_windowID
=
null
;
this
.
_encounteredCrashDumpFiles
=
[
]
;
this
.
_unexpectedCrashDumpFiles
=
{
}
;
this
.
_crashDumpDir
=
null
;
this
.
_serviceWorkerRegistered
=
false
;
this
.
_serviceWorkerCleanUpRequests
=
new
Map
(
)
;
Object
.
defineProperty
(
this
"
Components
"
{
configurable
:
true
enumerable
:
true
value
:
Components
}
)
;
this
.
_createFilesOnError
=
null
;
this
.
_createFilesOnSuccess
=
null
;
this
.
_messageListeners
=
new
ExtensionUtils
.
DefaultMap
(
(
)
=
>
new
Set
(
)
)
;
this
.
_consoleListeners
=
[
]
;
this
.
_spawnTaskImports
=
{
}
;
this
.
_encounteredCrashDumpFiles
=
[
]
;
this
.
_unexpectedCrashDumpFiles
=
{
}
;
this
.
_crashDumpDir
=
null
;
this
.
_mfl
=
null
;
this
.
_asyncObservers
=
new
WeakMap
(
)
;
this
.
_xpcomabi
=
null
;
this
.
_os
=
null
;
this
.
_pu
=
null
;
this
.
_nextExtensionID
=
0
;
this
.
_extensionListeners
=
null
;
WrapPrivileged
.
disableAutoWrap
(
this
.
unwrap
this
.
isWrapper
this
.
wrapCallback
this
.
wrapCallbackObject
this
.
setWrapped
this
.
nondeterministicGetWeakMapKeys
this
.
snapshotWindowWithOptions
this
.
snapshotWindow
this
.
snapshotRect
this
.
getDOMRequestService
)
;
}
observe
(
aSubject
aTopic
aData
)
{
}
actorCreated
(
)
{
this
.
attachToWindow
(
)
;
}
attachToWindow
(
)
{
let
window
=
this
.
contentWindow
;
if
(
!
(
"
SpecialPowers
"
in
window
.
wrappedJSObject
)
)
{
this
.
_windowID
=
window
.
windowGlobalChild
.
innerWindowId
;
defineSpecialPowers
(
this
)
;
}
}
get
window
(
)
{
return
this
.
contentWindow
;
}
toJSON
(
)
{
return
{
}
;
}
toString
(
)
{
return
"
[
SpecialPowers
]
"
;
}
sanityCheck
(
)
{
return
"
foo
"
;
}
_addMessageListener
(
msgname
listener
)
{
this
.
_messageListeners
.
get
(
msgname
)
.
add
(
listener
)
;
}
_removeMessageListener
(
msgname
listener
)
{
this
.
_messageListeners
.
get
(
msgname
)
.
delete
(
listener
)
;
}
receiveMessage
(
message
)
{
if
(
this
.
_messageListeners
.
has
(
message
.
name
)
)
{
for
(
let
listener
of
this
.
_messageListeners
.
get
(
message
.
name
)
)
{
try
{
if
(
typeof
listener
=
=
=
"
function
"
)
{
listener
(
message
)
;
}
else
{
listener
.
receiveMessage
(
message
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
switch
(
message
.
name
)
{
case
"
SPProcessCrashService
"
:
if
(
message
.
json
.
type
=
=
"
crash
-
observed
"
)
{
for
(
let
e
of
message
.
json
.
dumpIDs
)
{
this
.
_encounteredCrashDumpFiles
.
push
(
e
.
id
+
"
.
"
+
e
.
extension
)
;
}
}
break
;
case
"
SPServiceWorkerRegistered
"
:
this
.
_serviceWorkerRegistered
=
message
.
data
.
registered
;
break
;
case
"
SpecialPowers
.
FilesCreated
"
:
var
createdHandler
=
this
.
_createFilesOnSuccess
;
this
.
_createFilesOnSuccess
=
null
;
this
.
_createFilesOnError
=
null
;
if
(
createdHandler
)
{
createdHandler
(
Cu
.
cloneInto
(
message
.
data
this
.
contentWindow
)
)
;
}
break
;
case
"
SpecialPowers
.
FilesError
"
:
var
errorHandler
=
this
.
_createFilesOnError
;
this
.
_createFilesOnSuccess
=
null
;
this
.
_createFilesOnError
=
null
;
if
(
errorHandler
)
{
errorHandler
(
message
.
data
)
;
}
break
;
case
"
Spawn
"
:
let
{
task
args
caller
taskId
imports
}
=
message
.
data
;
return
this
.
_spawnTask
(
task
args
caller
taskId
imports
)
;
case
"
Assert
"
:
{
if
(
"
info
"
in
message
.
data
)
{
this
.
SimpleTest
.
info
(
message
.
data
.
info
)
;
break
;
}
let
{
name
passed
stack
diag
expectFail
}
=
message
.
data
;
let
{
SimpleTest
}
=
this
;
if
(
SimpleTest
)
{
let
expected
=
expectFail
?
"
fail
"
:
"
pass
"
;
SimpleTest
.
record
(
passed
name
diag
stack
expected
)
;
}
else
{
dump
(
name
+
"
\
n
"
)
;
}
}
break
;
}
return
undefined
;
}
registerProcessCrashObservers
(
)
{
this
.
sendAsyncMessage
(
"
SPProcessCrashService
"
{
op
:
"
register
-
observer
"
}
)
;
}
unregisterProcessCrashObservers
(
)
{
this
.
sendAsyncMessage
(
"
SPProcessCrashService
"
{
op
:
"
unregister
-
observer
"
}
)
;
}
wrap
(
obj
)
{
return
obj
;
}
unwrap
(
obj
)
{
return
WrapPrivileged
.
unwrap
(
obj
)
;
}
isWrapper
(
val
)
{
return
WrapPrivileged
.
isWrapper
(
val
)
;
}
wrapFor
(
obj
win
)
{
return
WrapPrivileged
.
wrap
(
obj
win
)
;
}
wrapCallback
(
func
)
{
return
WrapPrivileged
.
wrapCallback
(
func
this
.
contentWindow
)
;
}
wrapCallbackObject
(
obj
)
{
return
WrapPrivileged
.
wrapCallbackObject
(
obj
this
.
contentWindow
)
;
}
setWrapped
(
obj
prop
val
)
{
if
(
!
WrapPrivileged
.
isWrapper
(
obj
)
)
{
throw
new
Error
(
"
You
only
need
to
use
this
for
SpecialPowers
wrapped
objects
"
)
;
}
obj
=
WrapPrivileged
.
unwrap
(
obj
)
;
return
Reflect
.
set
(
obj
prop
val
)
;
}
createBlankObject
(
)
{
return
{
}
;
}
compare
(
a
b
)
{
return
WrapPrivileged
.
unwrap
(
a
)
=
=
=
WrapPrivileged
.
unwrap
(
b
)
;
}
get
MockFilePicker
(
)
{
return
MockFilePicker
;
}
get
MockColorPicker
(
)
{
return
MockColorPicker
;
}
get
MockPermissionPrompt
(
)
{
return
MockPermissionPrompt
;
}
quit
(
)
{
this
.
sendAsyncMessage
(
"
SpecialPowers
.
Quit
"
{
}
)
;
}
createFiles
(
fileRequests
onCreation
onError
)
{
return
this
.
sendQuery
(
"
SpecialPowers
.
CreateFiles
"
fileRequests
)
.
then
(
files
=
>
onCreation
(
Cu
.
cloneInto
(
files
this
.
contentWindow
)
)
onError
)
;
}
removeFiles
(
)
{
this
.
sendAsyncMessage
(
"
SpecialPowers
.
RemoveFiles
"
{
}
)
;
}
executeAfterFlushingMessageQueue
(
aCallback
)
{
return
this
.
sendQuery
(
"
Ping
"
)
.
then
(
aCallback
)
;
}
async
registeredServiceWorkers
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
dom
.
serviceWorkers
.
parent_intercept
"
false
)
)
{
let
swm
=
Cc
[
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
]
.
getService
(
Ci
.
nsIServiceWorkerManager
)
;
let
regs
=
swm
.
getAllRegistrations
(
)
;
let
workers
=
new
Array
(
regs
.
length
)
;
for
(
let
i
=
0
;
i
<
workers
.
length
;
+
+
i
)
{
let
{
scope
scriptSpec
}
=
regs
.
queryElementAt
(
i
Ci
.
nsIServiceWorkerRegistrationInfo
)
;
workers
[
i
]
=
{
scope
scriptSpec
}
;
}
return
workers
;
}
if
(
this
.
_serviceWorkerRegistered
)
{
let
{
workers
}
=
await
this
.
sendQuery
(
"
SPCheckServiceWorkers
"
)
;
return
workers
;
}
return
[
]
;
}
loadPrivilegedScript
(
aFunction
)
{
var
str
=
"
(
"
+
aFunction
.
toString
(
)
+
"
)
(
)
;
"
;
let
gGlobalObject
=
Cu
.
getGlobalForObject
(
this
)
;
let
sb
=
Cu
.
Sandbox
(
gGlobalObject
)
;
var
window
=
this
.
contentWindow
;
var
mc
=
new
window
.
MessageChannel
(
)
;
sb
.
port
=
mc
.
port1
;
let
blob
=
new
Blob
(
[
str
]
{
type
:
"
application
/
javascript
"
}
)
;
let
blobUrl
=
URL
.
createObjectURL
(
blob
)
;
Services
.
scriptloader
.
loadSubScript
(
blobUrl
sb
)
;
return
mc
.
port2
;
}
_readUrlAsString
(
aUrl
)
{
var
scriptableStream
=
Cc
[
"
mozilla
.
org
/
scriptableinputstream
;
1
"
]
.
getService
(
Ci
.
nsIScriptableInputStream
)
;
var
channel
=
NetUtil
.
newChannel
(
{
uri
:
aUrl
loadUsingSystemPrincipal
:
true
}
)
;
var
input
=
channel
.
open
(
)
;
scriptableStream
.
init
(
input
)
;
var
str
;
var
buffer
=
[
]
;
while
(
(
str
=
scriptableStream
.
read
(
4096
)
)
)
{
buffer
.
push
(
str
)
;
}
var
output
=
buffer
.
join
(
"
"
)
;
scriptableStream
.
close
(
)
;
input
.
close
(
)
;
var
status
;
if
(
channel
instanceof
Ci
.
nsIHttpChannel
)
{
status
=
channel
.
responseStatus
;
}
if
(
status
=
=
404
)
{
throw
new
Error
(
Error
while
executing
chrome
script
'
{
aUrl
}
'
:
\
n
+
"
The
script
doesn
'
t
exist
.
Ensure
you
have
registered
it
in
"
+
"
'
support
-
files
'
in
your
mochitest
.
ini
.
"
)
;
}
return
output
;
}
loadChromeScript
(
urlOrFunction
sandboxOptions
)
{
let
uuidGenerator
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
let
id
=
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
;
let
scriptArgs
=
{
id
sandboxOptions
}
;
if
(
typeof
urlOrFunction
=
=
"
function
"
)
{
scriptArgs
.
function
=
{
body
:
"
(
"
+
urlOrFunction
.
toString
(
)
+
"
)
(
)
;
"
name
:
urlOrFunction
.
name
}
;
}
else
{
scriptArgs
.
function
=
{
body
:
this
.
_readUrlAsString
(
urlOrFunction
)
}
;
scriptArgs
.
url
=
urlOrFunction
;
}
this
.
sendAsyncMessage
(
"
SPLoadChromeScript
"
scriptArgs
)
;
let
listeners
=
[
]
;
let
chromeScript
=
{
addMessageListener
:
(
name
listener
)
=
>
{
listeners
.
push
(
{
name
listener
}
)
;
}
promiseOneMessage
:
name
=
>
new
Promise
(
resolve
=
>
{
chromeScript
.
addMessageListener
(
name
function
listener
(
message
)
{
chromeScript
.
removeMessageListener
(
name
listener
)
;
resolve
(
message
)
;
}
)
;
}
)
removeMessageListener
:
(
name
listener
)
=
>
{
listeners
=
listeners
.
filter
(
o
=
>
o
.
name
!
=
name
|
|
o
.
listener
!
=
listener
)
;
}
sendAsyncMessage
:
(
name
message
)
=
>
{
this
.
sendAsyncMessage
(
"
SPChromeScriptMessage
"
{
id
name
message
}
)
;
}
sendQuery
:
(
name
message
)
=
>
{
return
this
.
sendQuery
(
"
SPChromeScriptMessage
"
{
id
name
message
}
)
;
}
destroy
:
(
)
=
>
{
listeners
=
[
]
;
this
.
_removeMessageListener
(
"
SPChromeScriptMessage
"
chromeScript
)
;
}
receiveMessage
:
aMessage
=
>
{
let
messageId
=
aMessage
.
json
.
id
;
let
name
=
aMessage
.
json
.
name
;
let
message
=
aMessage
.
json
.
message
;
if
(
this
.
contentWindow
)
{
message
=
new
StructuredCloneHolder
(
message
)
.
deserialize
(
this
.
contentWindow
)
;
}
if
(
messageId
!
=
id
)
{
return
null
;
}
let
result
;
if
(
aMessage
.
name
=
=
"
SPChromeScriptMessage
"
)
{
for
(
let
listener
of
listeners
.
filter
(
o
=
>
o
.
name
=
=
name
)
)
{
result
=
listener
.
listener
(
message
)
;
}
}
return
result
;
}
}
;
this
.
_addMessageListener
(
"
SPChromeScriptMessage
"
chromeScript
)
;
return
chromeScript
;
}
async
importInMainProcess
(
importString
)
{
var
message
=
await
this
.
sendQuery
(
"
SPImportInMainProcess
"
importString
)
;
if
(
message
.
hadError
)
{
throw
new
Error
(
"
SpecialPowers
.
importInMainProcess
failed
with
error
"
+
message
.
errorMessage
)
;
}
}
get
Services
(
)
{
return
Services
;
}
get
Cc
(
)
{
return
Cc
;
}
get
Ci
(
)
{
return
Ci
;
}
get
Cu
(
)
{
return
Cu
;
}
get
Cr
(
)
{
return
Cr
;
}
get
addProfilerMarker
(
)
{
return
ChromeUtils
.
addProfilerMarker
;
}
get
DOMWindowUtils
(
)
{
return
this
.
contentWindow
.
windowUtils
;
}
getDOMWindowUtils
(
aWindow
)
{
if
(
aWindow
=
=
this
.
contentWindow
)
{
return
aWindow
.
windowUtils
;
}
return
bindDOMWindowUtils
(
Cu
.
unwaiveXrays
(
aWindow
)
)
;
}
async
toggleMuteState
(
aMuted
aWindow
)
{
let
actor
=
aWindow
?
aWindow
.
windowGlobalChild
.
getActor
(
"
SpecialPowers
"
)
:
this
;
return
actor
.
sendQuery
(
"
SPToggleMuteAudio
"
{
mute
:
aMuted
}
)
;
}
getNoXULDOMParser
(
)
{
return
new
DOMParser
(
)
;
}
get
InspectorUtils
(
)
{
return
InspectorUtils
;
}
get
PromiseDebugging
(
)
{
return
PromiseDebugging
;
}
async
waitForCrashes
(
aExpectingProcessCrash
)
{
if
(
!
aExpectingProcessCrash
)
{
return
;
}
var
crashIds
=
this
.
_encounteredCrashDumpFiles
.
filter
(
filename
=
>
{
return
filename
.
length
=
=
=
40
&
&
filename
.
endsWith
(
"
.
dmp
"
)
;
}
)
.
map
(
id
=
>
{
return
id
.
slice
(
0
-
4
)
;
}
)
;
await
this
.
sendQuery
(
"
SPProcessCrashManagerWait
"
{
crashIds
}
)
;
}
async
removeExpectedCrashDumpFiles
(
aExpectingProcessCrash
)
{
var
success
=
true
;
if
(
aExpectingProcessCrash
)
{
var
message
=
{
op
:
"
delete
-
crash
-
dump
-
files
"
filenames
:
this
.
_encounteredCrashDumpFiles
}
;
if
(
!
(
await
this
.
sendQuery
(
"
SPProcessCrashService
"
message
)
)
)
{
success
=
false
;
}
}
this
.
_encounteredCrashDumpFiles
.
length
=
0
;
return
success
;
}
async
findUnexpectedCrashDumpFiles
(
)
{
var
self
=
this
;
var
message
=
{
op
:
"
find
-
crash
-
dump
-
files
"
crashDumpFilesToIgnore
:
this
.
_unexpectedCrashDumpFiles
}
;
var
crashDumpFiles
=
await
this
.
sendQuery
(
"
SPProcessCrashService
"
message
)
;
crashDumpFiles
.
forEach
(
function
(
aFilename
)
{
self
.
_unexpectedCrashDumpFiles
[
aFilename
]
=
true
;
}
)
;
return
crashDumpFiles
;
}
removePendingCrashDumpFiles
(
)
{
var
message
=
{
op
:
"
delete
-
pending
-
crash
-
dump
-
files
"
}
;
return
this
.
sendQuery
(
"
SPProcessCrashService
"
message
)
;
}
_setTimeout
(
callback
)
{
if
(
typeof
this
.
chromeWindow
!
=
"
undefined
"
)
{
this
.
chromeWindow
.
setTimeout
(
callback
0
)
;
}
else
{
this
.
contentWindow
.
setTimeout
(
callback
0
)
;
}
}
promiseTimeout
(
delay
)
{
return
new
Promise
(
resolve
=
>
{
this
.
_setTimeout
(
resolve
delay
)
;
}
)
;
}
_delayCallbackTwice
(
callback
)
{
let
delayedCallback
=
(
)
=
>
{
let
delayAgain
=
aCallback
=
>
{
this
.
_setTimeout
(
aCallback
)
;
}
;
delayAgain
(
delayAgain
.
bind
(
this
callback
)
)
;
}
;
return
delayedCallback
;
}
async
pushPermissions
(
inPermissions
callback
)
{
let
permissions
=
[
]
;
for
(
let
perm
of
inPermissions
)
{
let
principal
=
this
.
_getPrincipalFromArg
(
perm
.
context
)
;
permissions
.
push
(
{
.
.
.
perm
context
:
null
principal
}
)
;
}
await
this
.
sendQuery
(
"
PushPermissions
"
permissions
)
.
then
(
callback
)
;
await
this
.
promiseTimeout
(
0
)
;
}
async
popPermissions
(
callback
=
null
)
{
await
this
.
sendQuery
(
"
PopPermissions
"
)
.
then
(
callback
)
;
await
this
.
promiseTimeout
(
0
)
;
}
async
flushPermissions
(
callback
=
null
)
{
await
this
.
sendQuery
(
"
FlushPermissions
"
)
.
then
(
callback
)
;
await
this
.
promiseTimeout
(
0
)
;
}
registerObservers
(
topic
)
{
var
msg
=
{
op
:
"
add
"
observerTopic
:
topic
}
;
return
this
.
sendQuery
(
"
SPObserverService
"
msg
)
;
}
setTestPluginEnabledState
(
newEnabledState
pluginName
)
{
return
this
.
sendQuery
(
"
SPSetTestPluginEnabledState
"
{
newEnabledState
pluginName
}
)
;
}
async
pushPrefEnv
(
inPrefs
callback
=
null
)
{
await
this
.
sendQuery
(
"
PushPrefEnv
"
inPrefs
)
.
then
(
callback
)
;
await
this
.
promiseTimeout
(
0
)
;
}
async
popPrefEnv
(
callback
=
null
)
{
await
this
.
sendQuery
(
"
PopPrefEnv
"
)
.
then
(
callback
)
;
await
this
.
promiseTimeout
(
0
)
;
}
async
flushPrefEnv
(
callback
=
null
)
{
await
this
.
sendQuery
(
"
FlushPrefEnv
"
)
.
then
(
callback
)
;
await
this
.
promiseTimeout
(
0
)
;
}
_addObserverProxy
(
notification
)
{
if
(
notification
in
this
.
_proxiedObservers
)
{
this
.
_addMessageListener
(
notification
this
.
_proxiedObservers
[
notification
]
)
;
}
}
_removeObserverProxy
(
notification
)
{
if
(
notification
in
this
.
_proxiedObservers
)
{
this
.
_removeMessageListener
(
notification
this
.
_proxiedObservers
[
notification
]
)
;
}
}
addObserver
(
obs
notification
weak
)
{
this
.
sendAsyncMessage
(
"
Wakeup
"
)
;
this
.
_addObserverProxy
(
notification
)
;
obs
=
Cu
.
waiveXrays
(
obs
)
;
if
(
typeof
obs
=
=
"
object
"
&
&
obs
.
observe
.
name
!
=
"
SpecialPowersCallbackWrapper
"
)
{
obs
.
observe
=
WrapPrivileged
.
wrapCallback
(
Cu
.
unwaiveXrays
(
obs
.
observe
)
this
.
contentWindow
)
;
}
Services
.
obs
.
addObserver
(
obs
notification
weak
)
;
}
removeObserver
(
obs
notification
)
{
this
.
_removeObserverProxy
(
notification
)
;
Services
.
obs
.
removeObserver
(
Cu
.
waiveXrays
(
obs
)
notification
)
;
}
notifyObservers
(
subject
topic
data
)
{
Services
.
obs
.
notifyObservers
(
subject
topic
data
)
;
}
addAsyncObserver
(
obs
notification
weak
)
{
obs
=
Cu
.
waiveXrays
(
obs
)
;
if
(
typeof
obs
=
=
"
object
"
&
&
obs
.
observe
.
name
!
=
"
SpecialPowersCallbackWrapper
"
)
{
obs
.
observe
=
WrapPrivileged
.
wrapCallback
(
Cu
.
unwaiveXrays
(
obs
.
observe
)
this
.
contentWindow
)
;
}
let
asyncObs
=
(
.
.
.
args
)
=
>
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
if
(
typeof
obs
=
=
"
function
"
)
{
obs
(
.
.
.
args
)
;
}
else
{
obs
.
observe
.
call
(
undefined
.
.
.
args
)
;
}
}
)
;
}
;
this
.
_asyncObservers
.
set
(
obs
asyncObs
)
;
Services
.
obs
.
addObserver
(
asyncObs
notification
weak
)
;
}
removeAsyncObserver
(
obs
notification
)
{
let
asyncObs
=
this
.
_asyncObservers
.
get
(
Cu
.
waiveXrays
(
obs
)
)
;
Services
.
obs
.
removeObserver
(
asyncObs
notification
)
;
}
can_QI
(
obj
)
{
return
obj
.
QueryInterface
!
=
=
undefined
;
}
do_QueryInterface
(
obj
iface
)
{
return
obj
.
QueryInterface
(
Ci
[
iface
]
)
;
}
call_Instanceof
(
obj1
obj2
)
{
obj1
=
WrapPrivileged
.
unwrap
(
obj1
)
;
obj2
=
WrapPrivileged
.
unwrap
(
obj2
)
;
return
obj1
instanceof
obj2
;
}
do_lookupGetter
(
obj
name
)
{
return
Object
.
prototype
.
__lookupGetter__
.
call
(
obj
name
)
;
}
getBoolPref
(
.
.
.
args
)
{
return
Services
.
prefs
.
getBoolPref
(
.
.
.
args
)
;
}
getIntPref
(
.
.
.
args
)
{
return
Services
.
prefs
.
getIntPref
(
.
.
.
args
)
;
}
getCharPref
(
.
.
.
args
)
{
return
Services
.
prefs
.
getCharPref
(
.
.
.
args
)
;
}
getComplexValue
(
prefName
iid
)
{
return
Services
.
prefs
.
getComplexValue
(
prefName
iid
)
;
}
getParentBoolPref
(
prefName
defaultValue
)
{
return
this
.
_getParentPref
(
prefName
"
BOOL
"
{
defaultValue
}
)
;
}
getParentIntPref
(
prefName
defaultValue
)
{
return
this
.
_getParentPref
(
prefName
"
INT
"
{
defaultValue
}
)
;
}
getParentCharPref
(
prefName
defaultValue
)
{
return
this
.
_getParentPref
(
prefName
"
CHAR
"
{
defaultValue
}
)
;
}
setBoolPref
(
prefName
value
)
{
return
this
.
_setPref
(
prefName
"
BOOL
"
value
)
;
}
setIntPref
(
prefName
value
)
{
return
this
.
_setPref
(
prefName
"
INT
"
value
)
;
}
setCharPref
(
prefName
value
)
{
return
this
.
_setPref
(
prefName
"
CHAR
"
value
)
;
}
setComplexValue
(
prefName
iid
value
)
{
return
this
.
_setPref
(
prefName
"
COMPLEX
"
value
iid
)
;
}
clearUserPref
(
prefName
)
{
let
msg
=
{
op
:
"
clear
"
prefName
prefType
:
"
"
}
;
return
this
.
sendQuery
(
"
SPPrefService
"
msg
)
;
}
async
_getParentPref
(
prefName
prefType
{
defaultValue
iid
}
)
{
let
msg
=
{
op
:
"
get
"
prefName
prefType
iid
defaultValue
}
;
let
val
=
await
this
.
sendQuery
(
"
SPPrefService
"
msg
)
;
if
(
val
=
=
null
)
{
throw
new
Error
(
Error
getting
pref
'
{
prefName
}
'
)
;
}
return
val
;
}
_getPref
(
prefName
prefType
{
defaultValue
}
)
{
switch
(
prefType
)
{
case
"
BOOL
"
:
return
Services
.
prefs
.
getBoolPref
(
prefName
)
;
case
"
INT
"
:
return
Services
.
prefs
.
getIntPref
(
prefName
)
;
case
"
CHAR
"
:
return
Services
.
prefs
.
getCharPref
(
prefName
)
;
}
return
undefined
;
}
_setPref
(
prefName
prefType
prefValue
iid
)
{
let
msg
=
{
op
:
"
set
"
prefName
prefType
iid
prefValue
}
;
return
this
.
sendQuery
(
"
SPPrefService
"
msg
)
;
}
_getMUDV
(
window
)
{
return
window
.
docShell
.
contentViewer
;
}
_getTopChromeWindow
(
window
)
{
return
window
.
browsingContext
.
topChromeWindow
;
}
_getAutoCompletePopup
(
window
)
{
return
this
.
_getTopChromeWindow
(
window
)
.
document
.
getElementById
(
"
PopupAutoComplete
"
)
;
}
addAutoCompletePopupEventListener
(
window
eventname
listener
)
{
this
.
_getAutoCompletePopup
(
window
)
.
addEventListener
(
eventname
listener
)
;
}
removeAutoCompletePopupEventListener
(
window
eventname
listener
)
{
this
.
_getAutoCompletePopup
(
window
)
.
removeEventListener
(
eventname
listener
)
;
}
get
formHistory
(
)
{
let
tmp
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
tmp
)
;
return
tmp
.
FormHistory
;
}
getFormFillController
(
window
)
{
return
Cc
[
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
]
.
getService
(
Ci
.
nsIFormFillController
)
;
}
attachFormFillControllerTo
(
window
)
{
this
.
getFormFillController
(
)
.
attachPopupElementToDocument
(
window
.
document
this
.
_getAutoCompletePopup
(
window
)
)
;
}
detachFormFillControllerFrom
(
window
)
{
this
.
getFormFillController
(
)
.
detachFromDocument
(
window
.
document
)
;
}
isBackButtonEnabled
(
window
)
{
return
!
this
.
_getTopChromeWindow
(
window
)
.
document
.
getElementById
(
"
Browser
:
Back
"
)
.
hasAttribute
(
"
disabled
"
)
;
}
addChromeEventListener
(
type
listener
capture
allowUntrusted
)
{
this
.
docShell
.
chromeEventHandler
.
addEventListener
(
type
listener
capture
allowUntrusted
)
;
}
removeChromeEventListener
(
type
listener
capture
)
{
this
.
docShell
.
chromeEventHandler
.
removeEventListener
(
type
listener
capture
)
;
}
async
generateMediaControlKeyTestEvent
(
event
)
{
await
this
.
sendQuery
(
"
SPGenerateMediaControlKeyTestEvent
"
{
event
}
)
;
}
registerConsoleListener
(
callback
)
{
let
listener
=
new
SPConsoleListener
(
callback
this
.
contentWindow
)
;
Services
.
console
.
registerListener
(
listener
)
;
Services
.
obs
.
addObserver
(
listener
"
console
-
api
-
log
-
event
"
)
;
}
postConsoleSentinel
(
)
{
Services
.
console
.
logStringMessage
(
"
SENTINEL
"
)
;
}
resetConsole
(
)
{
Services
.
console
.
reset
(
)
;
}
getFullZoom
(
window
)
{
return
BrowsingContext
.
getFromWindow
(
window
)
.
fullZoom
;
}
getDeviceFullZoom
(
window
)
{
return
this
.
_getMUDV
(
window
)
.
deviceFullZoomForTest
;
}
setFullZoom
(
window
zoom
)
{
BrowsingContext
.
getFromWindow
(
window
)
.
fullZoom
=
zoom
;
}
getTextZoom
(
window
)
{
return
BrowsingContext
.
getFromWindow
(
window
)
.
textZoom
;
}
setTextZoom
(
window
zoom
)
{
BrowsingContext
.
getFromWindow
(
window
)
.
textZoom
=
zoom
;
}
getOverrideDPPX
(
window
)
{
return
this
.
_getMUDV
(
window
)
.
overrideDPPX
;
}
setOverrideDPPX
(
window
dppx
)
{
this
.
_getMUDV
(
window
)
.
overrideDPPX
=
dppx
;
}
emulateMedium
(
window
mediaType
)
{
this
.
_getMUDV
(
window
)
.
emulateMedium
(
mediaType
)
;
}
stopEmulatingMedium
(
window
)
{
this
.
_getMUDV
(
window
)
.
stopEmulatingMedium
(
)
;
}
snapshotWindowWithOptions
(
content
rect
bgcolor
options
)
{
function
getImageData
(
rect
bgcolor
options
)
{
let
el
=
content
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
if
(
rect
=
=
=
undefined
)
{
rect
=
{
top
:
content
.
scrollY
left
:
content
.
scrollX
width
:
content
.
innerWidth
height
:
content
.
innerHeight
}
;
}
if
(
bgcolor
=
=
=
undefined
)
{
bgcolor
=
"
rgb
(
255
255
255
)
"
;
}
if
(
options
=
=
=
undefined
)
{
options
=
{
}
;
}
el
.
width
=
rect
.
width
;
el
.
height
=
rect
.
height
;
let
ctx
=
el
.
getContext
(
"
2d
"
)
;
let
flags
=
0
;
for
(
let
option
in
options
)
{
flags
|
=
options
[
option
]
&
&
ctx
[
option
]
;
}
ctx
.
drawWindow
(
content
rect
.
left
rect
.
top
rect
.
width
rect
.
height
bgcolor
flags
)
;
return
ctx
.
getImageData
(
0
0
el
.
width
el
.
height
)
;
}
let
toCanvas
=
imageData
=
>
{
let
el
=
this
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
el
.
width
=
imageData
.
width
;
el
.
height
=
imageData
.
height
;
if
(
ImageData
.
isInstance
(
imageData
)
)
{
let
ctx
=
el
.
getContext
(
"
2d
"
)
;
ctx
.
putImageData
(
imageData
0
0
)
;
}
return
el
;
}
;
if
(
Window
.
isInstance
(
content
)
)
{
if
(
rect
&
&
!
(
rect
.
width
&
&
rect
.
height
)
)
{
return
toCanvas
(
rect
)
;
}
return
toCanvas
(
getImageData
(
rect
bgcolor
options
)
)
;
}
let
promise
=
this
.
spawn
(
content
[
rect
bgcolor
options
]
getImageData
)
.
then
(
toCanvas
)
;
if
(
Cu
.
isXrayWrapper
(
this
.
contentWindow
)
)
{
return
new
this
.
contentWindow
.
Promise
(
(
resolve
reject
)
=
>
{
promise
.
then
(
resolve
reject
)
;
}
)
;
}
return
promise
;
}
snapshotWindow
(
win
withCaret
rect
bgcolor
)
{
return
this
.
snapshotWindowWithOptions
(
win
rect
bgcolor
{
DRAWWINDOW_DRAW_CARET
:
withCaret
}
)
;
}
snapshotRect
(
win
rect
bgcolor
)
{
return
this
.
snapshotWindowWithOptions
(
win
rect
bgcolor
)
;
}
gc
(
)
{
this
.
contentWindow
.
windowUtils
.
garbageCollect
(
)
;
}
forceGC
(
)
{
Cu
.
forceGC
(
)
;
}
forceShrinkingGC
(
)
{
Cu
.
forceShrinkingGC
(
)
;
}
forceCC
(
)
{
Cu
.
forceCC
(
)
;
}
finishCC
(
)
{
Cu
.
finishCC
(
)
;
}
ccSlice
(
budget
)
{
Cu
.
ccSlice
(
budget
)
;
}
exactGC
(
callback
)
{
let
count
=
0
;
function
genGCCallback
(
cb
)
{
return
function
(
)
{
Cu
.
forceCC
(
)
;
if
(
+
+
count
<
3
)
{
Cu
.
schedulePreciseGC
(
genGCCallback
(
cb
)
)
;
}
else
if
(
cb
)
{
cb
(
)
;
}
}
;
}
Cu
.
schedulePreciseGC
(
genGCCallback
(
callback
)
)
;
}
nondeterministicGetWeakMapKeys
(
m
)
{
let
keys
=
ChromeUtils
.
nondeterministicGetWeakMapKeys
(
m
)
;
if
(
!
keys
)
{
return
undefined
;
}
return
this
.
contentWindow
.
Array
.
from
(
keys
)
;
}
getMemoryReports
(
)
{
try
{
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
.
getReports
(
(
)
=
>
{
}
null
(
)
=
>
{
}
null
false
)
;
}
catch
(
e
)
{
}
}
setGCZeal
(
zeal
)
{
Cu
.
setGCZeal
(
zeal
)
;
}
isMainProcess
(
)
{
try
{
return
(
Services
.
appinfo
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
)
;
}
catch
(
e
)
{
}
return
true
;
}
get
XPCOMABI
(
)
{
if
(
this
.
_xpcomabi
!
=
null
)
{
return
this
.
_xpcomabi
;
}
var
xulRuntime
=
Services
.
appinfo
.
QueryInterface
(
Ci
.
nsIXULRuntime
)
;
this
.
_xpcomabi
=
xulRuntime
.
XPCOMABI
;
return
this
.
_xpcomabi
;
}
executeSoon
(
aFun
aWin
)
{
var
runnable
=
{
}
;
if
(
aWin
)
{
runnable
=
Cu
.
createObjectIn
(
aWin
)
;
}
runnable
.
run
=
aFun
;
Cu
.
dispatch
(
runnable
aWin
)
;
}
get
OS
(
)
{
if
(
this
.
_os
!
=
null
)
{
return
this
.
_os
;
}
this
.
_os
=
Services
.
appinfo
.
OS
;
return
this
.
_os
;
}
get
useRemoteSubframes
(
)
{
return
this
.
docShell
.
nsILoadContext
.
useRemoteSubframes
;
}
addSystemEventListener
(
target
type
listener
useCapture
)
{
Services
.
els
.
addSystemEventListener
(
target
type
listener
useCapture
)
;
}
removeSystemEventListener
(
target
type
listener
useCapture
)
{
Services
.
els
.
removeSystemEventListener
(
target
type
listener
useCapture
)
;
}
defaultPreventedInAnyGroup
(
event
)
{
return
event
.
defaultPrevented
;
}
getDOMRequestService
(
)
{
var
serv
=
Services
.
DOMRequest
;
var
res
=
{
}
;
var
props
=
[
"
createRequest
"
"
createCursor
"
"
fireError
"
"
fireSuccess
"
"
fireDone
"
"
fireDetailedError
"
]
;
for
(
var
i
in
props
)
{
let
prop
=
props
[
i
]
;
res
[
prop
]
=
function
(
)
{
return
serv
[
prop
]
.
apply
(
serv
arguments
)
;
}
;
}
return
Cu
.
cloneInto
(
res
this
.
contentWindow
{
cloneFunctions
:
true
}
)
;
}
addCategoryEntry
(
category
entry
value
persists
replace
)
{
Services
.
catMan
.
addCategoryEntry
(
category
entry
value
persists
replace
)
;
}
deleteCategoryEntry
(
category
entry
persists
)
{
Services
.
catMan
.
deleteCategoryEntry
(
category
entry
persists
)
;
}
openDialog
(
win
args
)
{
return
win
.
openDialog
.
apply
(
win
args
)
;
}
spinEventLoop
(
win
)
{
var
syncXHR
=
new
win
.
XMLHttpRequest
(
)
;
syncXHR
.
open
(
"
GET
"
win
.
location
false
)
;
syncXHR
.
send
(
)
;
}
getPrivilegedProps
(
obj
props
)
{
var
parts
=
props
.
split
(
"
.
"
)
;
for
(
var
i
=
0
;
i
<
parts
.
length
;
i
+
+
)
{
var
p
=
parts
[
i
]
;
if
(
obj
[
p
]
!
=
undefined
)
{
obj
=
obj
[
p
]
;
}
else
{
return
null
;
}
}
return
obj
;
}
_browsingContextForTarget
(
target
)
{
if
(
BrowsingContext
.
isInstance
(
target
)
)
{
return
target
;
}
if
(
Element
.
isInstance
(
target
)
)
{
return
target
.
browsingContext
;
}
return
BrowsingContext
.
getFromWindow
(
target
)
;
}
getBrowsingContextID
(
target
)
{
return
this
.
_browsingContextForTarget
(
target
)
.
id
;
}
*
getGroupTopLevelWindows
(
target
)
{
let
{
group
}
=
this
.
_browsingContextForTarget
(
target
)
;
for
(
let
bc
of
group
.
getToplevels
(
)
)
{
yield
bc
.
window
;
}
}
spawn
(
target
args
task
)
{
let
browsingContext
=
this
.
_browsingContextForTarget
(
target
)
;
return
this
.
sendQuery
(
"
Spawn
"
{
browsingContext
args
task
:
String
(
task
)
caller
:
Cu
.
getFunctionSourceLocation
(
task
)
hasHarness
:
typeof
this
.
SimpleTest
=
=
=
"
object
"
imports
:
this
.
_spawnTaskImports
}
)
;
}
spawnChrome
(
args
task
)
{
return
this
.
sendQuery
(
"
SpawnChrome
"
{
args
task
:
String
(
task
)
caller
:
Cu
.
getFunctionSourceLocation
(
task
)
imports
:
this
.
_spawnTaskImports
}
)
;
}
snapshotContext
(
target
rect
background
)
{
let
browsingContext
=
this
.
_browsingContextForTarget
(
target
)
;
return
this
.
sendQuery
(
"
Snapshot
"
{
browsingContext
rect
background
}
)
.
then
(
imageData
=
>
{
return
this
.
contentWindow
.
createImageBitmap
(
imageData
)
;
}
)
;
}
getSecurityState
(
target
)
{
let
browsingContext
=
this
.
_browsingContextForTarget
(
target
)
;
return
this
.
sendQuery
(
"
SecurityState
"
{
browsingContext
}
)
;
}
_spawnTask
(
task
args
caller
taskId
imports
)
{
let
sb
=
new
SpecialPowersSandbox
(
null
data
=
>
{
this
.
sendAsyncMessage
(
"
ProxiedAssert
"
{
taskId
data
}
)
;
}
{
imports
}
)
;
sb
.
sandbox
.
SpecialPowers
=
this
;
sb
.
sandbox
.
ContentTaskUtils
=
ContentTaskUtils
;
for
(
let
[
global
prop
]
of
Object
.
entries
(
{
content
:
"
contentWindow
"
docShell
:
"
docShell
"
}
)
)
{
Object
.
defineProperty
(
sb
.
sandbox
global
{
get
:
(
)
=
>
{
return
this
[
prop
]
;
}
enumerable
:
true
}
)
;
}
return
sb
.
execute
(
task
args
caller
)
;
}
addTaskImport
(
symbol
url
)
{
this
.
_spawnTaskImports
[
symbol
]
=
url
;
}
get
SimpleTest
(
)
{
return
this
.
_SimpleTest
|
|
this
.
contentWindow
.
wrappedJSObject
.
SimpleTest
;
}
set
SimpleTest
(
val
)
{
this
.
_SimpleTest
=
val
;
}
setAsDefaultAssertHandler
(
)
{
this
.
sendAsyncMessage
(
"
SetAsDefaultAssertHandler
"
)
;
}
getFocusedElementForWindow
(
targetWindow
aDeep
)
{
var
outParam
=
{
}
;
Services
.
focus
.
getFocusedElementForWindow
(
targetWindow
aDeep
outParam
)
;
return
outParam
.
value
;
}
get
focusManager
(
)
{
return
Services
.
focus
;
}
activeWindow
(
)
{
return
Services
.
focus
.
activeWindow
;
}
focusedWindow
(
)
{
return
Services
.
focus
.
focusedWindow
;
}
focus
(
aWindow
)
{
if
(
aWindow
)
{
aWindow
.
focus
(
)
;
}
try
{
let
actor
=
aWindow
?
aWindow
.
windowGlobalChild
.
getActor
(
"
SpecialPowers
"
)
:
this
;
actor
.
sendAsyncMessage
(
"
SpecialPowers
.
Focus
"
{
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
getClipboardData
(
flavor
whichClipboard
)
{
if
(
whichClipboard
=
=
=
undefined
)
{
whichClipboard
=
Services
.
clipboard
.
kGlobalClipboard
;
}
var
xferable
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
xferable
.
init
(
this
.
docShell
)
;
xferable
.
addDataFlavor
(
flavor
)
;
Services
.
clipboard
.
getData
(
xferable
whichClipboard
)
;
var
data
=
{
}
;
try
{
xferable
.
getTransferData
(
flavor
data
)
;
}
catch
(
e
)
{
}
data
=
data
.
value
|
|
null
;
if
(
data
=
=
null
)
{
return
"
"
;
}
return
data
.
QueryInterface
(
Ci
.
nsISupportsString
)
.
data
;
}
clipboardCopyString
(
str
)
{
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
.
copyString
(
str
)
;
}
supportsSelectionClipboard
(
)
{
return
Services
.
clipboard
.
supportsSelectionClipboard
(
)
;
}
swapFactoryRegistration
(
cid
contractID
newFactory
)
{
newFactory
=
Cu
.
waiveXrays
(
newFactory
)
;
var
componentRegistrar
=
Components
.
manager
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
var
currentCID
=
componentRegistrar
.
contractIDToCID
(
contractID
)
;
var
currentFactory
=
Components
.
manager
.
getClassObject
(
Cc
[
contractID
]
Ci
.
nsIFactory
)
;
if
(
cid
)
{
componentRegistrar
.
unregisterFactory
(
currentCID
currentFactory
)
;
}
else
{
let
uuidGenerator
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
cid
=
uuidGenerator
.
generateUUID
(
)
;
}
componentRegistrar
.
registerFactory
(
cid
"
"
contractID
newFactory
)
;
return
{
originalCID
:
currentCID
}
;
}
_getElement
(
aWindow
id
)
{
return
typeof
id
=
=
"
string
"
?
aWindow
.
document
.
getElementById
(
id
)
:
id
;
}
dispatchEvent
(
aWindow
target
event
)
{
var
el
=
this
.
_getElement
(
aWindow
target
)
;
return
el
.
dispatchEvent
(
event
)
;
}
get
isDebugBuild
(
)
{
return
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
.
isDebugBuild
;
}
assertionCount
(
)
{
var
debugsvc
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
return
debugsvc
.
assertionCount
;
}
_getPrincipalFromArg
(
arg
)
{
arg
=
WrapPrivileged
.
unwrap
(
Cu
.
unwaiveXrays
(
arg
)
)
;
if
(
arg
.
nodePrincipal
)
{
return
arg
.
nodePrincipal
;
}
let
secMan
=
Services
.
scriptSecurityManager
;
if
(
typeof
arg
=
=
"
string
"
)
{
let
uri
=
Services
.
io
.
newURI
(
arg
)
;
return
secMan
.
createContentPrincipal
(
uri
{
}
)
;
}
let
uri
=
Services
.
io
.
newURI
(
arg
.
url
)
;
let
attrs
=
arg
.
originAttributes
|
|
{
}
;
return
secMan
.
createContentPrincipal
(
uri
attrs
)
;
}
async
addPermission
(
type
allow
arg
expireType
expireTime
)
{
let
principal
=
this
.
_getPrincipalFromArg
(
arg
)
;
if
(
principal
.
isSystemPrincipal
)
{
return
;
}
let
permission
=
allow
;
if
(
typeof
permission
=
=
=
"
boolean
"
)
{
permission
=
Ci
.
nsIPermissionManager
[
allow
?
"
ALLOW_ACTION
"
:
"
DENY_ACTION
"
]
;
}
var
msg
=
{
op
:
"
add
"
type
permission
principal
expireType
:
typeof
expireType
=
=
=
"
number
"
?
expireType
:
0
expireTime
:
typeof
expireTime
=
=
=
"
number
"
?
expireTime
:
0
}
;
await
this
.
sendQuery
(
"
SPPermissionManager
"
msg
)
;
}
async
removePermission
(
type
arg
)
{
let
principal
=
this
.
_getPrincipalFromArg
(
arg
)
;
if
(
principal
.
isSystemPrincipal
)
{
return
;
}
var
msg
=
{
op
:
"
remove
"
type
principal
}
;
await
this
.
sendQuery
(
"
SPPermissionManager
"
msg
)
;
}
async
hasPermission
(
type
arg
)
{
let
principal
=
this
.
_getPrincipalFromArg
(
arg
)
;
if
(
principal
.
isSystemPrincipal
)
{
return
true
;
}
var
msg
=
{
op
:
"
has
"
type
principal
}
;
return
this
.
sendQuery
(
"
SPPermissionManager
"
msg
)
;
}
async
testPermission
(
type
value
arg
)
{
let
principal
=
this
.
_getPrincipalFromArg
(
arg
)
;
if
(
principal
.
isSystemPrincipal
)
{
return
true
;
}
var
msg
=
{
op
:
"
test
"
type
value
principal
}
;
return
this
.
sendQuery
(
"
SPPermissionManager
"
msg
)
;
}
isContentWindowPrivate
(
win
)
{
return
PrivateBrowsingUtils
.
isContentWindowPrivate
(
win
)
;
}
async
notifyObserversInParentProcess
(
subject
topic
data
)
{
if
(
subject
)
{
throw
new
Error
(
"
Can
'
t
send
subject
to
another
process
!
"
)
;
}
if
(
this
.
isMainProcess
(
)
)
{
this
.
notifyObservers
(
subject
topic
data
)
;
return
;
}
var
msg
=
{
op
:
"
notify
"
observerTopic
:
topic
observerData
:
data
}
;
await
this
.
sendQuery
(
"
SPObserverService
"
msg
)
;
}
removeAllServiceWorkerData
(
)
{
return
this
.
sendQuery
(
"
SPRemoveAllServiceWorkers
"
{
}
)
;
}
removeServiceWorkerDataForExampleDomain
(
)
{
return
this
.
sendQuery
(
"
SPRemoveServiceWorkerDataForExampleDomain
"
{
}
)
;
}
cleanUpSTSData
(
origin
flags
)
{
return
this
.
sendQuery
(
"
SPCleanUpSTSData
"
{
origin
flags
:
flags
|
|
0
}
)
;
}
async
requestDumpCoverageCounters
(
cb
)
{
if
(
!
PerTestCoverageUtils
.
enabled
)
{
return
;
}
await
this
.
sendQuery
(
"
SPRequestDumpCoverageCounters
"
{
}
)
;
}
async
requestResetCoverageCounters
(
cb
)
{
if
(
!
PerTestCoverageUtils
.
enabled
)
{
return
;
}
await
this
.
sendQuery
(
"
SPRequestResetCoverageCounters
"
{
}
)
;
}
loadExtension
(
ext
handler
)
{
if
(
this
.
_extensionListeners
=
=
null
)
{
this
.
_extensionListeners
=
new
Set
(
)
;
this
.
_addMessageListener
(
"
SPExtensionMessage
"
msg
=
>
{
for
(
let
listener
of
this
.
_extensionListeners
)
{
try
{
listener
(
msg
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
)
;
}
let
id
=
this
.
_nextExtensionID
+
+
;
handler
=
Cu
.
waiveXrays
(
handler
)
;
ext
=
Cu
.
waiveXrays
(
ext
)
;
let
sp
=
this
;
let
state
=
"
uninitialized
"
;
let
extension
=
{
get
state
(
)
{
return
state
;
}
startup
(
)
{
state
=
"
pending
"
;
return
sp
.
sendQuery
(
"
SPStartupExtension
"
{
id
}
)
.
then
(
(
)
=
>
{
state
=
"
running
"
;
}
(
)
=
>
{
state
=
"
failed
"
;
sp
.
_extensionListeners
.
delete
(
listener
)
;
return
Promise
.
reject
(
"
startup
failed
"
)
;
}
)
;
}
unload
(
)
{
state
=
"
unloading
"
;
return
sp
.
sendQuery
(
"
SPUnloadExtension
"
{
id
}
)
.
finally
(
(
)
=
>
{
sp
.
_extensionListeners
.
delete
(
listener
)
;
state
=
"
unloaded
"
;
}
)
;
}
sendMessage
(
.
.
.
args
)
{
sp
.
sendAsyncMessage
(
"
SPExtensionMessage
"
{
id
args
}
)
;
}
grantActiveTab
(
tabId
)
{
sp
.
sendAsyncMessage
(
"
SPExtensionGrantActiveTab
"
{
id
tabId
}
)
;
}
}
;
this
.
sendAsyncMessage
(
"
SPLoadExtension
"
{
ext
id
}
)
;
let
listener
=
msg
=
>
{
if
(
msg
.
data
.
id
=
=
id
)
{
if
(
msg
.
data
.
type
=
=
"
extensionSetId
"
)
{
extension
.
id
=
msg
.
data
.
args
[
0
]
;
extension
.
uuid
=
msg
.
data
.
args
[
1
]
;
}
else
if
(
msg
.
data
.
type
in
handler
)
{
handler
[
msg
.
data
.
type
]
(
.
.
.
Cu
.
cloneInto
(
msg
.
data
.
args
this
.
contentWindow
)
)
;
}
else
{
dump
(
Unexpected
:
{
msg
.
data
.
type
}
\
n
)
;
}
}
}
;
this
.
_extensionListeners
.
add
(
listener
)
;
return
extension
;
}
invalidateExtensionStorageCache
(
)
{
this
.
notifyObserversInParentProcess
(
null
"
extension
-
invalidate
-
storage
-
cache
"
"
"
)
;
}
allowMedia
(
window
enable
)
{
window
.
docShell
.
allowMedia
=
enable
;
}
createChromeCache
(
name
url
)
{
let
principal
=
this
.
_getPrincipalFromArg
(
url
)
;
return
new
this
.
contentWindow
.
CacheStorage
(
name
principal
)
;
}
loadChannelAndReturnStatus
(
url
loadUsingSystemPrincipal
)
{
const
BinaryInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
binaryinputstream
;
1
"
"
nsIBinaryInputStream
"
"
setInputStream
"
)
;
return
new
Promise
(
function
(
resolve
)
{
let
listener
=
{
httpStatus
:
0
onStartRequest
(
request
)
{
request
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
this
.
httpStatus
=
request
.
responseStatus
;
}
onDataAvailable
(
request
stream
offset
count
)
{
new
BinaryInputStream
(
stream
)
.
readByteArray
(
count
)
;
}
onStopRequest
(
request
status
)
{
let
httpStatus
=
this
.
httpStatus
;
resolve
(
{
status
httpStatus
}
)
;
}
}
;
let
uri
=
NetUtil
.
newURI
(
url
)
;
let
channel
=
NetUtil
.
newChannel
(
{
uri
loadUsingSystemPrincipal
}
)
;
channel
.
loadFlags
|
=
Ci
.
nsIChannel
.
LOAD_DOCUMENT_URI
;
channel
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
;
channel
.
documentURI
=
uri
;
channel
.
asyncOpen
(
listener
)
;
}
)
;
}
get
ParserUtils
(
)
{
if
(
this
.
_pu
!
=
null
)
{
return
this
.
_pu
;
}
let
pu
=
Cc
[
"
mozilla
.
org
/
parserutils
;
1
"
]
.
getService
(
Ci
.
nsIParserUtils
)
;
this
.
_pu
=
{
sanitize
(
src
flags
)
{
return
pu
.
sanitize
(
src
flags
)
;
}
convertToPlainText
(
src
flags
wrapCol
)
{
return
pu
.
convertToPlainText
(
src
flags
wrapCol
)
;
}
parseFragment
(
fragment
flags
isXML
baseURL
element
)
{
let
baseURI
=
baseURL
?
NetUtil
.
newURI
(
baseURL
)
:
null
;
return
pu
.
parseFragment
(
WrapPrivileged
.
unwrap
(
fragment
)
flags
isXML
baseURI
WrapPrivileged
.
unwrap
(
element
)
)
;
}
}
;
return
this
.
_pu
;
}
createDOMWalker
(
node
showAnonymousContent
)
{
node
=
WrapPrivileged
.
unwrap
(
node
)
;
let
walker
=
Cc
[
"
mozilla
.
org
/
inspector
/
deep
-
tree
-
walker
;
1
"
]
.
createInstance
(
Ci
.
inIDeepTreeWalker
)
;
walker
.
showAnonymousContent
=
showAnonymousContent
;
walker
.
init
(
node
.
ownerDocument
NodeFilter
.
SHOW_ALL
)
;
walker
.
currentNode
=
node
;
let
contentWindow
=
this
.
contentWindow
;
return
{
get
firstChild
(
)
{
return
WrapPrivileged
.
wrap
(
walker
.
firstChild
(
)
contentWindow
)
;
}
get
lastChild
(
)
{
return
WrapPrivileged
.
wrap
(
walker
.
lastChild
(
)
contentWindow
)
;
}
}
;
}
observeMutationEvents
(
mo
node
nativeAnonymousChildList
subtree
)
{
WrapPrivileged
.
unwrap
(
mo
)
.
observe
(
WrapPrivileged
.
unwrap
(
node
)
{
nativeAnonymousChildList
subtree
}
)
;
}
doCommand
(
window
cmd
param
)
{
switch
(
cmd
)
{
case
"
cmd_align
"
:
case
"
cmd_backgroundColor
"
:
case
"
cmd_fontColor
"
:
case
"
cmd_fontFace
"
:
case
"
cmd_fontSize
"
:
case
"
cmd_highlight
"
:
case
"
cmd_insertImageNoUI
"
:
case
"
cmd_insertLinkNoUI
"
:
case
"
cmd_paragraphState
"
:
let
params
=
Cu
.
createCommandParams
(
)
;
params
.
setStringValue
(
"
state_attribute
"
param
)
;
return
window
.
docShell
.
doCommandWithParams
(
cmd
params
)
;
default
:
return
window
.
docShell
.
doCommand
(
cmd
)
;
}
}
isCommandEnabled
(
window
cmd
)
{
return
window
.
docShell
.
isCommandEnabled
(
cmd
)
;
}
setCommandNode
(
window
node
)
{
return
window
.
docShell
.
contentViewer
.
QueryInterface
(
Ci
.
nsIContentViewerEdit
)
.
setCommandNode
(
node
)
;
}
doUrlClassify
(
principal
eventTarget
callback
)
{
let
classifierService
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
dbservice
;
1
"
]
.
getService
(
Ci
.
nsIURIClassifier
)
;
let
wrapCallback
=
(
.
.
.
args
)
=
>
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
if
(
typeof
callback
=
=
"
function
"
)
{
callback
(
.
.
.
args
)
;
}
else
{
callback
.
onClassifyComplete
.
call
(
undefined
.
.
.
args
)
;
}
}
)
;
}
;
return
classifierService
.
classify
(
WrapPrivileged
.
unwrap
(
principal
)
eventTarget
wrapCallback
)
;
}
doUrlClassifyLocal
(
uri
tables
callback
)
{
let
classifierService
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
dbservice
;
1
"
]
.
getService
(
Ci
.
nsIURIClassifier
)
;
let
wrapCallback
=
results
=
>
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
if
(
typeof
callback
=
=
"
function
"
)
{
callback
(
WrapPrivileged
.
wrap
(
results
this
.
contentWindow
)
)
;
}
else
{
callback
.
onClassifyComplete
.
call
(
undefined
WrapPrivileged
.
wrap
(
results
this
.
contentWindow
)
)
;
}
}
)
;
}
;
let
feature
=
classifierService
.
createFeatureWithTables
(
"
test
"
tables
.
split
(
"
"
)
[
]
)
;
return
classifierService
.
asyncClassifyLocalWithFeatures
(
WrapPrivileged
.
unwrap
(
uri
)
[
feature
]
Ci
.
nsIUrlClassifierFeature
.
blocklist
wrapCallback
)
;
}
}
SpecialPowersChild
.
prototype
.
_proxiedObservers
=
{
"
specialpowers
-
http
-
notify
-
request
"
:
function
(
aMessage
)
{
let
uri
=
aMessage
.
json
.
uri
;
Services
.
obs
.
notifyObservers
(
null
"
specialpowers
-
http
-
notify
-
request
"
uri
)
;
}
"
specialpowers
-
service
-
worker
-
shutdown
"
:
function
(
aMessage
)
{
Services
.
obs
.
notifyObservers
(
null
"
specialpowers
-
service
-
worker
-
shutdown
"
)
;
}
"
specialpowers
-
csp
-
on
-
violate
-
policy
"
:
function
(
aMessage
)
{
let
subject
=
null
;
try
{
subject
=
Services
.
io
.
newURI
(
aMessage
.
data
.
subject
)
;
}
catch
(
ex
)
{
subject
=
Cc
[
"
mozilla
.
org
/
supports
-
cstring
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsCString
)
;
subject
.
data
=
aMessage
.
data
.
subject
;
}
Services
.
obs
.
notifyObservers
(
subject
"
specialpowers
-
csp
-
on
-
violate
-
policy
"
aMessage
.
data
.
data
)
;
}
"
specialpowers
-
xfo
-
on
-
violate
-
policy
"
:
function
(
aMessage
)
{
let
subject
=
Services
.
io
.
newURI
(
aMessage
.
data
.
subject
)
;
Services
.
obs
.
notifyObservers
(
subject
"
specialpowers
-
xfo
-
on
-
violate
-
policy
"
aMessage
.
data
.
data
)
;
}
}
;
SpecialPowersChild
.
prototype
.
EARLY_BETA_OR_EARLIER
=
AppConstants
.
EARLY_BETA_OR_EARLIER
;
