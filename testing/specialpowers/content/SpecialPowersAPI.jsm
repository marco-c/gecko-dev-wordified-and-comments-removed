"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SpecialPowersAPI
"
"
bindDOMWindowUtils
"
]
;
var
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MockFilePicker
"
"
resource
:
/
/
specialpowers
/
MockFilePicker
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MockColorPicker
"
"
resource
:
/
/
specialpowers
/
MockColorPicker
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MockPermissionPrompt
"
"
resource
:
/
/
specialpowers
/
MockPermissionPrompt
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SpecialPowersSandbox
"
"
resource
:
/
/
specialpowers
/
SpecialPowersSandbox
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
WrapPrivileged
"
"
resource
:
/
/
specialpowers
/
WrapPrivileged
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PerTestCoverageUtils
"
"
resource
:
/
/
testing
-
common
/
PerTestCoverageUtils
.
jsm
"
)
;
Cu
.
forcePermissiveCOWs
(
)
;
function
bindDOMWindowUtils
(
aWindow
)
{
return
aWindow
&
&
WrapPrivileged
.
wrap
(
aWindow
.
windowUtils
)
;
}
function
SPConsoleListener
(
callback
)
{
this
.
callback
=
callback
;
}
SPConsoleListener
.
prototype
=
{
observe
(
msg
topic
)
{
let
m
=
{
message
:
msg
.
message
errorMessage
:
null
cssSelectors
:
null
sourceName
:
null
sourceLine
:
null
lineNumber
:
null
columnNumber
:
null
category
:
null
windowID
:
null
isScriptError
:
false
isConsoleEvent
:
false
isWarning
:
false
isException
:
false
isStrict
:
false
}
;
if
(
msg
instanceof
Ci
.
nsIScriptError
)
{
m
.
errorMessage
=
msg
.
errorMessage
;
m
.
cssSelectors
=
msg
.
cssSelectors
;
m
.
sourceName
=
msg
.
sourceName
;
m
.
sourceLine
=
msg
.
sourceLine
;
m
.
lineNumber
=
msg
.
lineNumber
;
m
.
columnNumber
=
msg
.
columnNumber
;
m
.
category
=
msg
.
category
;
m
.
windowID
=
msg
.
outerWindowID
;
m
.
innerWindowID
=
msg
.
innerWindowID
;
m
.
isScriptError
=
true
;
m
.
isWarning
=
(
msg
.
flags
&
Ci
.
nsIScriptError
.
warningFlag
)
=
=
=
1
;
m
.
isException
=
(
msg
.
flags
&
Ci
.
nsIScriptError
.
exceptionFlag
)
=
=
=
1
;
m
.
isStrict
=
(
msg
.
flags
&
Ci
.
nsIScriptError
.
strictFlag
)
=
=
=
1
;
}
else
if
(
topic
=
=
=
"
console
-
api
-
log
-
event
"
)
{
let
unwrapped
=
msg
.
wrappedJSObject
;
m
.
errorMessage
=
unwrapped
.
arguments
[
0
]
;
m
.
sourceName
=
unwrapped
.
filename
;
m
.
lineNumber
=
unwrapped
.
lineNumber
;
m
.
columnNumber
=
unwrapped
.
columnNumber
;
m
.
windowID
=
unwrapped
.
ID
;
m
.
innerWindowID
=
unwrapped
.
innerID
;
m
.
isConsoleEvent
=
true
;
m
.
isWarning
=
unwrapped
.
level
=
=
=
"
warning
"
;
}
Object
.
freeze
(
m
)
;
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
this
.
callback
.
call
(
undefined
m
)
;
}
)
;
if
(
!
m
.
isScriptError
&
&
!
m
.
isConsoleEvent
&
&
m
.
message
=
=
=
"
SENTINEL
"
)
{
Services
.
obs
.
removeObserver
(
this
"
console
-
api
-
log
-
event
"
)
;
Services
.
console
.
unregisterListener
(
this
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIConsoleListener
Ci
.
nsIObserver
]
)
}
;
class
SpecialPowersAPI
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
_consoleListeners
=
[
]
;
this
.
_encounteredCrashDumpFiles
=
[
]
;
this
.
_unexpectedCrashDumpFiles
=
{
}
;
this
.
_crashDumpDir
=
null
;
this
.
_mfl
=
null
;
this
.
_applyingPermissions
=
false
;
this
.
_observingPermissions
=
false
;
this
.
_asyncObservers
=
new
WeakMap
(
)
;
this
.
_xpcomabi
=
null
;
this
.
_os
=
null
;
this
.
_pu
=
null
;
this
.
_nextExtensionID
=
0
;
this
.
_extensionListeners
=
null
;
}
toJSON
(
)
{
return
{
}
;
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
Assert
"
:
{
let
{
name
passed
stack
diag
}
=
message
.
data
;
let
SimpleTest
=
this
.
contentWindow
&
&
this
.
contentWindow
.
wrappedJSObject
.
SimpleTest
;
if
(
SimpleTest
)
{
SimpleTest
.
record
(
passed
name
diag
stack
&
&
stack
.
formattedStack
)
;
}
else
{
dump
(
name
+
"
\
n
"
)
;
}
}
break
;
}
return
undefined
;
}
wrap
(
obj
)
{
return
WrapPrivileged
.
wrap
(
obj
)
;
}
unwrap
(
obj
)
{
return
WrapPrivileged
.
unwrap
(
obj
)
;
}
isWrapper
(
val
)
{
return
WrapPrivileged
.
isWrapper
(
val
)
;
}
wrapCallback
(
func
)
{
return
WrapPrivileged
.
wrapCallback
(
func
)
;
}
wrapCallbackObject
(
obj
)
{
return
WrapPrivileged
.
wrapCallbackObject
(
obj
)
;
}
setWrapped
(
obj
prop
val
)
{
if
(
!
WrapPrivileged
.
isWrapper
(
obj
)
)
{
throw
new
Error
(
"
You
only
need
to
use
this
for
SpecialPowers
wrapped
objects
"
)
;
}
obj
=
WrapPrivileged
.
unwrap
(
obj
)
;
return
Reflect
.
set
(
obj
prop
val
)
;
}
createBlankObject
(
)
{
return
{
}
;
}
compare
(
a
b
)
{
return
WrapPrivileged
.
unwrap
(
a
)
=
=
=
WrapPrivileged
.
unwrap
(
b
)
;
}
get
MockFilePicker
(
)
{
return
MockFilePicker
;
}
get
MockColorPicker
(
)
{
return
MockColorPicker
;
}
get
MockPermissionPrompt
(
)
{
return
MockPermissionPrompt
;
}
loadPrivilegedScript
(
aFunction
)
{
var
str
=
"
(
"
+
aFunction
.
toString
(
)
+
"
)
(
)
;
"
;
let
gGlobalObject
=
Cu
.
getGlobalForObject
(
this
)
;
let
sb
=
Cu
.
Sandbox
(
gGlobalObject
)
;
var
window
=
this
.
contentWindow
;
var
mc
=
new
window
.
MessageChannel
(
)
;
sb
.
port
=
mc
.
port1
;
try
{
let
blob
=
new
Blob
(
[
str
]
{
type
:
"
application
/
javascript
"
}
)
;
let
blobUrl
=
URL
.
createObjectURL
(
blob
)
;
Services
.
scriptloader
.
loadSubScript
(
blobUrl
sb
)
;
}
catch
(
e
)
{
throw
WrapPrivileged
.
wrap
(
e
)
;
}
return
mc
.
port2
;
}
_readUrlAsString
(
aUrl
)
{
var
scriptableStream
=
Cc
[
"
mozilla
.
org
/
scriptableinputstream
;
1
"
]
.
getService
(
Ci
.
nsIScriptableInputStream
)
;
var
channel
=
NetUtil
.
newChannel
(
{
uri
:
aUrl
loadUsingSystemPrincipal
:
true
}
)
;
var
input
=
channel
.
open
(
)
;
scriptableStream
.
init
(
input
)
;
var
str
;
var
buffer
=
[
]
;
while
(
(
str
=
scriptableStream
.
read
(
4096
)
)
)
{
buffer
.
push
(
str
)
;
}
var
output
=
buffer
.
join
(
"
"
)
;
scriptableStream
.
close
(
)
;
input
.
close
(
)
;
var
status
;
if
(
channel
instanceof
Ci
.
nsIHttpChannel
)
{
status
=
channel
.
responseStatus
;
}
if
(
status
=
=
404
)
{
throw
new
Error
(
Error
while
executing
chrome
script
'
{
aUrl
}
'
:
\
n
+
"
The
script
doesn
'
t
exist
.
Ensure
you
have
registered
it
in
"
+
"
'
support
-
files
'
in
your
mochitest
.
ini
.
"
)
;
}
return
output
;
}
loadChromeScript
(
urlOrFunction
sandboxOptions
)
{
let
uuidGenerator
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
let
id
=
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
;
let
scriptArgs
=
{
id
sandboxOptions
}
;
if
(
typeof
urlOrFunction
=
=
"
function
"
)
{
scriptArgs
.
function
=
{
body
:
"
(
"
+
urlOrFunction
.
toString
(
)
+
"
)
(
)
;
"
name
:
urlOrFunction
.
name
}
;
}
else
{
scriptArgs
.
function
=
{
body
:
this
.
_readUrlAsString
(
urlOrFunction
)
}
;
scriptArgs
.
url
=
urlOrFunction
;
}
this
.
sendAsyncMessage
(
"
SPLoadChromeScript
"
scriptArgs
)
;
let
listeners
=
[
]
;
let
chromeScript
=
{
addMessageListener
:
(
name
listener
)
=
>
{
listeners
.
push
(
{
name
listener
}
)
;
}
promiseOneMessage
:
name
=
>
new
Promise
(
resolve
=
>
{
chromeScript
.
addMessageListener
(
name
function
listener
(
message
)
{
chromeScript
.
removeMessageListener
(
name
listener
)
;
resolve
(
message
)
;
}
)
;
}
)
removeMessageListener
:
(
name
listener
)
=
>
{
listeners
=
listeners
.
filter
(
o
=
>
o
.
name
!
=
name
|
|
o
.
listener
!
=
listener
)
;
}
sendAsyncMessage
:
(
name
message
)
=
>
{
this
.
sendAsyncMessage
(
"
SPChromeScriptMessage
"
{
id
name
message
}
)
;
}
sendQuery
:
(
name
message
)
=
>
{
return
this
.
sendQuery
(
"
SPChromeScriptMessage
"
{
id
name
message
}
)
;
}
destroy
:
(
)
=
>
{
listeners
=
[
]
;
this
.
_removeMessageListener
(
"
SPChromeScriptMessage
"
chromeScript
)
;
}
receiveMessage
:
aMessage
=
>
{
let
messageId
=
aMessage
.
json
.
id
;
let
name
=
aMessage
.
json
.
name
;
let
message
=
aMessage
.
json
.
message
;
if
(
this
.
contentWindow
)
{
message
=
new
StructuredCloneHolder
(
message
)
.
deserialize
(
this
.
contentWindow
)
;
}
if
(
messageId
!
=
id
)
{
return
null
;
}
let
result
;
if
(
aMessage
.
name
=
=
"
SPChromeScriptMessage
"
)
{
for
(
let
listener
of
listeners
.
filter
(
o
=
>
o
.
name
=
=
name
)
)
{
result
=
listener
.
listener
(
message
)
;
}
}
return
result
;
}
}
;
this
.
_addMessageListener
(
"
SPChromeScriptMessage
"
chromeScript
)
;
return
this
.
wrap
(
chromeScript
)
;
}
async
importInMainProcess
(
importString
)
{
var
message
=
await
this
.
sendQuery
(
"
SPImportInMainProcess
"
importString
)
;
if
(
message
.
hadError
)
{
throw
new
Error
(
"
SpecialPowers
.
importInMainProcess
failed
with
error
"
+
message
.
errorMessage
)
;
}
}
get
Services
(
)
{
return
WrapPrivileged
.
wrap
(
Services
)
;
}
getFullComponents
(
)
{
return
Components
;
}
get
Cc
(
)
{
return
WrapPrivileged
.
wrap
(
this
.
getFullComponents
(
)
.
classes
)
;
}
get
Ci
(
)
{
return
WrapPrivileged
.
wrap
(
this
.
getFullComponents
(
)
.
interfaces
)
;
}
get
Cu
(
)
{
return
WrapPrivileged
.
wrap
(
this
.
getFullComponents
(
)
.
utils
)
;
}
get
Cr
(
)
{
return
WrapPrivileged
.
wrap
(
this
.
getFullComponents
(
)
.
results
)
;
}
getDOMWindowUtils
(
aWindow
)
{
if
(
aWindow
=
=
this
.
contentWindow
&
&
this
.
DOMWindowUtils
!
=
null
)
{
return
this
.
DOMWindowUtils
;
}
return
bindDOMWindowUtils
(
aWindow
)
;
}
getNoXULDOMParser
(
)
{
return
WrapPrivileged
.
wrap
(
new
DOMParser
(
)
)
;
}
get
InspectorUtils
(
)
{
return
WrapPrivileged
.
wrap
(
InspectorUtils
)
;
}
get
PromiseDebugging
(
)
{
return
WrapPrivileged
.
wrap
(
PromiseDebugging
)
;
}
async
waitForCrashes
(
aExpectingProcessCrash
)
{
if
(
!
aExpectingProcessCrash
)
{
return
;
}
var
crashIds
=
this
.
_encounteredCrashDumpFiles
.
filter
(
filename
=
>
{
return
filename
.
length
=
=
=
40
&
&
filename
.
endsWith
(
"
.
dmp
"
)
;
}
)
.
map
(
id
=
>
{
return
id
.
slice
(
0
-
4
)
;
}
)
;
await
this
.
sendQuery
(
"
SPProcessCrashManagerWait
"
{
crashIds
}
)
;
}
async
removeExpectedCrashDumpFiles
(
aExpectingProcessCrash
)
{
var
success
=
true
;
if
(
aExpectingProcessCrash
)
{
var
message
=
{
op
:
"
delete
-
crash
-
dump
-
files
"
filenames
:
this
.
_encounteredCrashDumpFiles
}
;
if
(
!
(
await
this
.
sendQuery
(
"
SPProcessCrashService
"
message
)
)
)
{
success
=
false
;
}
}
this
.
_encounteredCrashDumpFiles
.
length
=
0
;
return
success
;
}
async
findUnexpectedCrashDumpFiles
(
)
{
var
self
=
this
;
var
message
=
{
op
:
"
find
-
crash
-
dump
-
files
"
crashDumpFilesToIgnore
:
this
.
_unexpectedCrashDumpFiles
}
;
var
crashDumpFiles
=
await
this
.
sendQuery
(
"
SPProcessCrashService
"
message
)
;
crashDumpFiles
.
forEach
(
function
(
aFilename
)
{
self
.
_unexpectedCrashDumpFiles
[
aFilename
]
=
true
;
}
)
;
return
crashDumpFiles
;
}
removePendingCrashDumpFiles
(
)
{
var
message
=
{
op
:
"
delete
-
pending
-
crash
-
dump
-
files
"
}
;
return
this
.
sendQuery
(
"
SPProcessCrashService
"
message
)
;
}
_setTimeout
(
callback
)
{
if
(
typeof
this
.
chromeWindow
!
=
"
undefined
"
)
{
this
.
chromeWindow
.
setTimeout
(
callback
0
)
;
}
else
{
this
.
contentWindow
.
setTimeout
(
callback
0
)
;
}
}
promiseTimeout
(
delay
)
{
return
new
Promise
(
resolve
=
>
{
this
.
_setTimeout
(
resolve
delay
)
;
}
)
;
}
_delayCallbackTwice
(
callback
)
{
let
delayedCallback
=
(
)
=
>
{
let
delayAgain
=
aCallback
=
>
{
this
.
_setTimeout
(
aCallback
)
;
}
;
delayAgain
(
delayAgain
.
bind
(
this
callback
)
)
;
}
;
return
delayedCallback
;
}
async
pushPermissions
(
inPermissions
callback
)
{
inPermissions
=
Cu
.
waiveXrays
(
inPermissions
)
;
var
pendingPermissions
=
[
]
;
var
cleanupPermissions
=
[
]
;
for
(
var
p
in
inPermissions
)
{
var
permission
=
inPermissions
[
p
]
;
var
originalValue
=
Ci
.
nsIPermissionManager
.
UNKNOWN_ACTION
;
var
context
=
Cu
.
unwaiveXrays
(
permission
.
context
)
;
if
(
await
this
.
testPermission
(
permission
.
type
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
context
)
)
{
originalValue
=
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
;
}
else
if
(
await
this
.
testPermission
(
permission
.
type
Ci
.
nsIPermissionManager
.
DENY_ACTION
context
)
)
{
originalValue
=
Ci
.
nsIPermissionManager
.
DENY_ACTION
;
}
else
if
(
await
this
.
testPermission
(
permission
.
type
Ci
.
nsIPermissionManager
.
PROMPT_ACTION
context
)
)
{
originalValue
=
Ci
.
nsIPermissionManager
.
PROMPT_ACTION
;
}
else
if
(
await
this
.
testPermission
(
permission
.
type
Ci
.
nsICookiePermission
.
ACCESS_SESSION
context
)
)
{
originalValue
=
Ci
.
nsICookiePermission
.
ACCESS_SESSION
;
}
let
principal
=
this
.
_getPrincipalFromArg
(
context
)
;
if
(
principal
.
isSystemPrincipal
)
{
continue
;
}
let
perm
;
if
(
typeof
permission
.
allow
!
=
=
"
boolean
"
)
{
perm
=
permission
.
allow
;
}
else
{
perm
=
permission
.
allow
?
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
:
Ci
.
nsIPermissionManager
.
DENY_ACTION
;
}
if
(
permission
.
remove
)
{
perm
=
Ci
.
nsIPermissionManager
.
UNKNOWN_ACTION
;
}
if
(
originalValue
=
=
perm
)
{
continue
;
}
var
todo
=
{
op
:
"
add
"
type
:
permission
.
type
permission
:
perm
value
:
perm
principal
expireType
:
typeof
permission
.
expireType
=
=
=
"
number
"
?
permission
.
expireType
:
0
expireTime
:
typeof
permission
.
expireTime
=
=
=
"
number
"
?
permission
.
expireTime
:
0
}
;
var
cleanupTodo
=
Object
.
assign
(
{
}
todo
)
;
if
(
permission
.
remove
)
{
todo
.
op
=
"
remove
"
;
}
pendingPermissions
.
push
(
todo
)
;
if
(
originalValue
=
=
Ci
.
nsIPermissionManager
.
UNKNOWN_ACTION
)
{
cleanupTodo
.
op
=
"
remove
"
;
}
else
{
cleanupTodo
.
value
=
originalValue
;
cleanupTodo
.
permission
=
originalValue
;
}
cleanupPermissions
.
push
(
cleanupTodo
)
;
}
if
(
pendingPermissions
.
length
>
0
)
{
if
(
!
this
.
_observingPermissions
)
{
this
.
_observingPermissions
=
true
;
if
(
this
.
isMainProcess
(
)
)
{
this
.
permissionObserverProxy
.
_specialPowersAPI
=
this
;
Services
.
obs
.
addObserver
(
this
.
permissionObserverProxy
"
perm
-
changed
"
)
;
}
else
{
this
.
registerObservers
(
"
perm
-
changed
"
)
;
this
.
_addMessageListener
(
"
specialpowers
-
perm
-
changed
"
this
.
permChangedProxy
.
bind
(
this
)
)
;
}
}
this
.
_permissionsUndoStack
.
push
(
cleanupPermissions
)
;
this
.
_pendingPermissions
.
push
(
[
pendingPermissions
this
.
_delayCallbackTwice
(
callback
)
]
)
;
this
.
_applyPermissions
(
)
;
}
else
{
this
.
_setTimeout
(
callback
)
;
}
}
registerObservers
(
topic
)
{
var
msg
=
{
op
:
"
add
"
observerTopic
:
topic
}
;
return
this
.
sendQuery
(
"
SPObserverService
"
msg
)
;
}
permChangedProxy
(
aMessage
)
{
let
permission
=
aMessage
.
json
.
permission
;
let
aData
=
aMessage
.
json
.
aData
;
this
.
_permissionObserver
.
observe
(
permission
aData
)
;
}
popPermissions
(
callback
)
{
let
promise
=
new
Promise
(
resolve
=
>
{
if
(
this
.
_permissionsUndoStack
.
length
>
0
)
{
let
cb
=
this
.
_delayCallbackTwice
(
resolve
)
;
this
.
_pendingPermissions
.
push
(
[
this
.
_permissionsUndoStack
.
pop
(
)
cb
]
)
;
this
.
_applyPermissions
(
)
;
}
else
{
if
(
this
.
_observingPermissions
)
{
this
.
_observingPermissions
=
false
;
this
.
_removeMessageListener
(
"
specialpowers
-
perm
-
changed
"
this
.
permChangedProxy
.
bind
(
this
)
)
;
}
this
.
_setTimeout
(
resolve
)
;
}
}
)
;
if
(
callback
)
{
promise
.
then
(
callback
)
;
}
return
promise
;
}
flushPermissions
(
callback
)
{
while
(
this
.
_permissionsUndoStack
.
length
>
1
)
{
this
.
popPermissions
(
null
)
;
}
return
this
.
popPermissions
(
callback
)
;
}
setTestPluginEnabledState
(
newEnabledState
pluginName
)
{
return
this
.
sendQuery
(
"
SPSetTestPluginEnabledState
"
{
newEnabledState
pluginName
}
)
;
}
_applyPermissions
(
)
{
if
(
this
.
_applyingPermissions
|
|
this
.
_pendingPermissions
.
length
<
=
0
)
{
return
;
}
this
.
_applyingPermissions
=
true
;
var
transaction
=
this
.
_pendingPermissions
.
shift
(
)
;
var
pendingActions
=
transaction
[
0
]
;
var
callback
=
transaction
[
1
]
;
var
lastPermission
=
pendingActions
[
pendingActions
.
length
-
1
]
;
var
self
=
this
;
this
.
_permissionObserver
.
_self
=
self
;
this
.
_permissionObserver
.
_lastPermission
=
lastPermission
;
this
.
_permissionObserver
.
_callback
=
callback
;
this
.
_permissionObserver
.
_nextCallback
=
function
(
)
{
self
.
_applyingPermissions
=
false
;
self
.
_applyPermissions
(
)
;
}
;
for
(
var
idx
in
pendingActions
)
{
var
perm
=
pendingActions
[
idx
]
;
this
.
sendAsyncMessage
(
"
SPPermissionManager
"
perm
)
;
}
}
async
pushPrefEnv
(
inPrefs
callback
=
null
)
{
await
this
.
sendQuery
(
"
PushPrefEnv
"
inPrefs
)
.
then
(
callback
)
;
await
this
.
promiseTimeout
(
0
)
;
}
async
popPrefEnv
(
callback
=
null
)
{
await
this
.
sendQuery
(
"
PopPrefEnv
"
)
.
then
(
callback
)
;
await
this
.
promiseTimeout
(
0
)
;
}
async
flushPrefEnv
(
callback
=
null
)
{
await
this
.
sendQuery
(
"
FlushPrefEnv
"
)
.
then
(
callback
)
;
await
this
.
promiseTimeout
(
0
)
;
}
_addObserverProxy
(
notification
)
{
if
(
notification
in
this
.
_proxiedObservers
)
{
this
.
_addMessageListener
(
notification
this
.
_proxiedObservers
[
notification
]
)
;
}
}
_removeObserverProxy
(
notification
)
{
if
(
notification
in
this
.
_proxiedObservers
)
{
this
.
_removeMessageListener
(
notification
this
.
_proxiedObservers
[
notification
]
)
;
}
}
addObserver
(
obs
notification
weak
)
{
this
.
sendAsyncMessage
(
"
Wakeup
"
)
;
this
.
_addObserverProxy
(
notification
)
;
obs
=
Cu
.
waiveXrays
(
obs
)
;
if
(
typeof
obs
=
=
"
object
"
&
&
obs
.
observe
.
name
!
=
"
SpecialPowersCallbackWrapper
"
)
{
obs
.
observe
=
WrapPrivileged
.
wrapCallback
(
obs
.
observe
)
;
}
Services
.
obs
.
addObserver
(
obs
notification
weak
)
;
}
removeObserver
(
obs
notification
)
{
this
.
_removeObserverProxy
(
notification
)
;
Services
.
obs
.
removeObserver
(
Cu
.
waiveXrays
(
obs
)
notification
)
;
}
notifyObservers
(
subject
topic
data
)
{
Services
.
obs
.
notifyObservers
(
subject
topic
data
)
;
}
addAsyncObserver
(
obs
notification
weak
)
{
obs
=
Cu
.
waiveXrays
(
obs
)
;
if
(
typeof
obs
=
=
"
object
"
&
&
obs
.
observe
.
name
!
=
"
SpecialPowersCallbackWrapper
"
)
{
obs
.
observe
=
WrapPrivileged
.
wrapCallback
(
obs
.
observe
)
;
}
let
asyncObs
=
(
.
.
.
args
)
=
>
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
if
(
typeof
obs
=
=
"
function
"
)
{
obs
(
.
.
.
args
)
;
}
else
{
obs
.
observe
.
call
(
undefined
.
.
.
args
)
;
}
}
)
;
}
;
this
.
_asyncObservers
.
set
(
obs
asyncObs
)
;
Services
.
obs
.
addObserver
(
asyncObs
notification
weak
)
;
}
removeAsyncObserver
(
obs
notification
)
{
let
asyncObs
=
this
.
_asyncObservers
.
get
(
Cu
.
waiveXrays
(
obs
)
)
;
Services
.
obs
.
removeObserver
(
asyncObs
notification
)
;
}
can_QI
(
obj
)
{
return
obj
.
QueryInterface
!
=
=
undefined
;
}
do_QueryInterface
(
obj
iface
)
{
return
obj
.
QueryInterface
(
Ci
[
iface
]
)
;
}
call_Instanceof
(
obj1
obj2
)
{
obj1
=
WrapPrivileged
.
unwrap
(
obj1
)
;
obj2
=
WrapPrivileged
.
unwrap
(
obj2
)
;
return
obj1
instanceof
obj2
;
}
do_lookupGetter
(
obj
name
)
{
return
Object
.
prototype
.
__lookupGetter__
.
call
(
obj
name
)
;
}
getBoolPref
(
.
.
.
args
)
{
return
Services
.
prefs
.
getBoolPref
(
.
.
.
args
)
;
}
getIntPref
(
.
.
.
args
)
{
return
Services
.
prefs
.
getIntPref
(
.
.
.
args
)
;
}
getCharPref
(
.
.
.
args
)
{
return
Services
.
prefs
.
getCharPref
(
.
.
.
args
)
;
}
getComplexValue
(
prefName
iid
)
{
return
Services
.
prefs
.
getComplexValue
(
prefName
iid
)
;
}
getParentBoolPref
(
prefName
defaultValue
)
{
return
this
.
_getParentPref
(
prefName
"
BOOL
"
{
defaultValue
}
)
;
}
getParentIntPref
(
prefName
defaultValue
)
{
return
this
.
_getParentPref
(
prefName
"
INT
"
{
defaultValue
}
)
;
}
getParentCharPref
(
prefName
defaultValue
)
{
return
this
.
_getParentPref
(
prefName
"
CHAR
"
{
defaultValue
}
)
;
}
setBoolPref
(
prefName
value
)
{
return
this
.
_setPref
(
prefName
"
BOOL
"
value
)
;
}
setIntPref
(
prefName
value
)
{
return
this
.
_setPref
(
prefName
"
INT
"
value
)
;
}
setCharPref
(
prefName
value
)
{
return
this
.
_setPref
(
prefName
"
CHAR
"
value
)
;
}
setComplexValue
(
prefName
iid
value
)
{
return
this
.
_setPref
(
prefName
"
COMPLEX
"
value
iid
)
;
}
clearUserPref
(
prefName
)
{
let
msg
=
{
op
:
"
clear
"
prefName
prefType
:
"
"
}
;
return
this
.
sendQuery
(
"
SPPrefService
"
msg
)
;
}
async
_getParentPref
(
prefName
prefType
{
defaultValue
iid
}
)
{
let
msg
=
{
op
:
"
get
"
prefName
prefType
iid
defaultValue
}
;
let
val
=
await
this
.
sendQuery
(
"
SPPrefService
"
msg
)
;
if
(
val
=
=
null
)
{
throw
new
Error
(
Error
getting
pref
'
{
prefName
}
'
)
;
}
return
val
;
}
_getPref
(
prefName
prefType
{
defaultValue
}
)
{
switch
(
prefType
)
{
case
"
BOOL
"
:
return
Services
.
prefs
.
getBoolPref
(
prefName
)
;
case
"
INT
"
:
return
Services
.
prefs
.
getIntPref
(
prefName
)
;
case
"
CHAR
"
:
return
Services
.
prefs
.
getCharPref
(
prefName
)
;
}
return
undefined
;
}
_setPref
(
prefName
prefType
prefValue
iid
)
{
let
msg
=
{
op
:
"
set
"
prefName
prefType
iid
prefValue
}
;
return
this
.
sendQuery
(
"
SPPrefService
"
msg
)
;
}
_getMUDV
(
window
)
{
return
window
.
docShell
.
contentViewer
;
}
_getTopChromeWindow
(
window
)
{
return
window
.
docShell
.
rootTreeItem
.
domWindow
;
}
_getAutoCompletePopup
(
window
)
{
return
this
.
_getTopChromeWindow
(
window
)
.
document
.
getElementById
(
"
PopupAutoComplete
"
)
;
}
addAutoCompletePopupEventListener
(
window
eventname
listener
)
{
this
.
_getAutoCompletePopup
(
window
)
.
addEventListener
(
eventname
listener
)
;
}
removeAutoCompletePopupEventListener
(
window
eventname
listener
)
{
this
.
_getAutoCompletePopup
(
window
)
.
removeEventListener
(
eventname
listener
)
;
}
get
formHistory
(
)
{
let
tmp
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
tmp
)
;
return
WrapPrivileged
.
wrap
(
tmp
.
FormHistory
)
;
}
getFormFillController
(
window
)
{
return
Cc
[
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
]
.
getService
(
Ci
.
nsIFormFillController
)
;
}
attachFormFillControllerTo
(
window
)
{
this
.
getFormFillController
(
)
.
attachPopupElementToBrowser
(
window
.
docShell
this
.
_getAutoCompletePopup
(
window
)
)
;
}
detachFormFillControllerFrom
(
window
)
{
this
.
getFormFillController
(
)
.
detachFromBrowser
(
window
.
docShell
)
;
}
isBackButtonEnabled
(
window
)
{
return
!
this
.
_getTopChromeWindow
(
window
)
.
document
.
getElementById
(
"
Browser
:
Back
"
)
.
hasAttribute
(
"
disabled
"
)
;
}
addChromeEventListener
(
type
listener
capture
allowUntrusted
)
{
this
.
docShell
.
chromeEventHandler
.
addEventListener
(
type
listener
capture
allowUntrusted
)
;
}
removeChromeEventListener
(
type
listener
capture
)
{
this
.
docShell
.
chromeEventHandler
.
removeEventListener
(
type
listener
capture
)
;
}
registerConsoleListener
(
callback
)
{
let
listener
=
new
SPConsoleListener
(
callback
)
;
Services
.
console
.
registerListener
(
listener
)
;
Services
.
obs
.
addObserver
(
listener
"
console
-
api
-
log
-
event
"
)
;
}
postConsoleSentinel
(
)
{
Services
.
console
.
logStringMessage
(
"
SENTINEL
"
)
;
}
resetConsole
(
)
{
Services
.
console
.
reset
(
)
;
}
getFullZoom
(
window
)
{
return
this
.
_getMUDV
(
window
)
.
fullZoom
;
}
getDeviceFullZoom
(
window
)
{
return
this
.
_getMUDV
(
window
)
.
deviceFullZoom
;
}
setFullZoom
(
window
zoom
)
{
this
.
_getMUDV
(
window
)
.
fullZoom
=
zoom
;
}
getTextZoom
(
window
)
{
return
this
.
_getMUDV
(
window
)
.
textZoom
;
}
setTextZoom
(
window
zoom
)
{
this
.
_getMUDV
(
window
)
.
textZoom
=
zoom
;
}
getOverrideDPPX
(
window
)
{
return
this
.
_getMUDV
(
window
)
.
overrideDPPX
;
}
setOverrideDPPX
(
window
dppx
)
{
this
.
_getMUDV
(
window
)
.
overrideDPPX
=
dppx
;
}
emulateMedium
(
window
mediaType
)
{
this
.
_getMUDV
(
window
)
.
emulateMedium
(
mediaType
)
;
}
stopEmulatingMedium
(
window
)
{
this
.
_getMUDV
(
window
)
.
stopEmulatingMedium
(
)
;
}
snapshotWindowWithOptions
(
content
rect
bgcolor
options
)
{
function
getImageData
(
rect
bgcolor
options
)
{
let
el
=
content
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
if
(
rect
=
=
=
undefined
)
{
rect
=
{
top
:
content
.
scrollY
left
:
content
.
scrollX
width
:
content
.
innerWidth
height
:
content
.
innerHeight
}
;
}
if
(
bgcolor
=
=
=
undefined
)
{
bgcolor
=
"
rgb
(
255
255
255
)
"
;
}
if
(
options
=
=
=
undefined
)
{
options
=
{
}
;
}
el
.
width
=
rect
.
width
;
el
.
height
=
rect
.
height
;
let
ctx
=
el
.
getContext
(
"
2d
"
)
;
let
flags
=
0
;
for
(
let
option
in
options
)
{
flags
|
=
options
[
option
]
&
&
ctx
[
option
]
;
}
ctx
.
drawWindow
(
content
rect
.
left
rect
.
top
rect
.
width
rect
.
height
bgcolor
flags
)
;
return
ctx
.
getImageData
(
0
0
el
.
width
el
.
height
)
;
}
let
toCanvas
=
imageData
=
>
{
let
el
=
this
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
el
.
width
=
imageData
.
width
;
el
.
height
=
imageData
.
height
;
let
ctx
=
el
.
getContext
(
"
2d
"
)
;
ctx
.
putImageData
(
imageData
0
0
)
;
return
el
;
}
;
if
(
Window
.
isInstance
(
content
)
)
{
return
toCanvas
(
getImageData
(
rect
bgcolor
options
)
)
;
}
return
this
.
spawn
(
content
[
rect
bgcolor
options
]
getImageData
)
.
then
(
toCanvas
)
;
}
snapshotWindow
(
win
withCaret
rect
bgcolor
)
{
return
this
.
snapshotWindowWithOptions
(
win
rect
bgcolor
{
DRAWWINDOW_DRAW_CARET
:
withCaret
}
)
;
}
snapshotRect
(
win
rect
bgcolor
)
{
return
this
.
snapshotWindowWithOptions
(
win
rect
bgcolor
)
;
}
gc
(
)
{
this
.
DOMWindowUtils
.
garbageCollect
(
)
;
}
forceGC
(
)
{
Cu
.
forceGC
(
)
;
}
forceShrinkingGC
(
)
{
Cu
.
forceShrinkingGC
(
)
;
}
forceCC
(
)
{
Cu
.
forceCC
(
)
;
}
finishCC
(
)
{
Cu
.
finishCC
(
)
;
}
ccSlice
(
budget
)
{
Cu
.
ccSlice
(
budget
)
;
}
exactGC
(
callback
)
{
let
count
=
0
;
function
genGCCallback
(
cb
)
{
return
function
(
)
{
Cu
.
forceCC
(
)
;
if
(
+
+
count
<
3
)
{
Cu
.
schedulePreciseGC
(
genGCCallback
(
cb
)
)
;
}
else
if
(
cb
)
{
cb
(
)
;
}
}
;
}
Cu
.
schedulePreciseGC
(
genGCCallback
(
callback
)
)
;
}
nondeterministicGetWeakMapKeys
(
m
)
{
return
ChromeUtils
.
nondeterministicGetWeakMapKeys
(
m
)
;
}
getMemoryReports
(
)
{
try
{
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
.
getReports
(
(
)
=
>
{
}
null
(
)
=
>
{
}
null
false
)
;
}
catch
(
e
)
{
}
}
setGCZeal
(
zeal
)
{
Cu
.
setGCZeal
(
zeal
)
;
}
isMainProcess
(
)
{
try
{
return
(
Services
.
appinfo
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
)
;
}
catch
(
e
)
{
}
return
true
;
}
get
XPCOMABI
(
)
{
if
(
this
.
_xpcomabi
!
=
null
)
{
return
this
.
_xpcomabi
;
}
var
xulRuntime
=
Services
.
appinfo
.
QueryInterface
(
Ci
.
nsIXULRuntime
)
;
this
.
_xpcomabi
=
xulRuntime
.
XPCOMABI
;
return
this
.
_xpcomabi
;
}
executeSoon
(
aFun
aWin
)
{
var
runnable
=
{
}
;
if
(
aWin
)
{
runnable
=
Cu
.
createObjectIn
(
aWin
)
;
}
runnable
.
run
=
aFun
;
Cu
.
dispatch
(
runnable
aWin
)
;
}
get
OS
(
)
{
if
(
this
.
_os
!
=
null
)
{
return
this
.
_os
;
}
this
.
_os
=
Services
.
appinfo
.
OS
;
return
this
.
_os
;
}
get
useRemoteSubframes
(
)
{
return
this
.
docShell
.
nsILoadContext
.
useRemoteSubframes
;
}
addSystemEventListener
(
target
type
listener
useCapture
)
{
Services
.
els
.
addSystemEventListener
(
target
type
listener
useCapture
)
;
}
removeSystemEventListener
(
target
type
listener
useCapture
)
{
Services
.
els
.
removeSystemEventListener
(
target
type
listener
useCapture
)
;
}
defaultPreventedInAnyGroup
(
event
)
{
return
event
.
defaultPrevented
;
}
getDOMRequestService
(
)
{
var
serv
=
Services
.
DOMRequest
;
var
res
=
{
}
;
var
props
=
[
"
createRequest
"
"
createCursor
"
"
fireError
"
"
fireSuccess
"
"
fireDone
"
"
fireDetailedError
"
]
;
for
(
var
i
in
props
)
{
let
prop
=
props
[
i
]
;
res
[
prop
]
=
function
(
)
{
return
serv
[
prop
]
.
apply
(
serv
arguments
)
;
}
;
}
return
res
;
}
addCategoryEntry
(
category
entry
value
persists
replace
)
{
Services
.
catMan
.
addCategoryEntry
(
category
entry
value
persists
replace
)
;
}
deleteCategoryEntry
(
category
entry
persists
)
{
Services
.
catMan
.
deleteCategoryEntry
(
category
entry
persists
)
;
}
openDialog
(
win
args
)
{
return
win
.
openDialog
.
apply
(
win
args
)
;
}
spinEventLoop
(
win
)
{
var
syncXHR
=
new
win
.
XMLHttpRequest
(
)
;
syncXHR
.
open
(
"
GET
"
win
.
location
false
)
;
syncXHR
.
send
(
)
;
}
getPrivilegedProps
(
obj
props
)
{
var
parts
=
props
.
split
(
"
.
"
)
;
for
(
var
i
=
0
;
i
<
parts
.
length
;
i
+
+
)
{
var
p
=
parts
[
i
]
;
if
(
obj
[
p
]
!
=
undefined
)
{
obj
=
obj
[
p
]
;
}
else
{
return
null
;
}
}
return
obj
;
}
spawn
(
target
args
task
)
{
let
browsingContext
;
if
(
BrowsingContext
.
isInstance
(
target
)
)
{
browsingContext
=
target
;
}
else
if
(
Element
.
isInstance
(
target
)
)
{
browsingContext
=
target
.
browsingContext
;
}
else
{
browsingContext
=
BrowsingContext
.
getFromWindow
(
target
)
;
}
return
this
.
sendQuery
(
"
Spawn
"
{
browsingContext
args
task
:
String
(
task
)
caller
:
SpecialPowersSandbox
.
getCallerInfo
(
Components
.
stack
.
caller
)
}
)
;
}
_spawnTask
(
task
args
caller
taskId
)
{
let
sb
=
new
SpecialPowersSandbox
(
null
data
=
>
{
this
.
sendAsyncMessage
(
"
ProxiedAssert
"
{
taskId
data
}
)
;
}
)
;
sb
.
sandbox
.
SpecialPowers
=
this
;
Object
.
defineProperty
(
sb
.
sandbox
"
content
"
{
get
:
(
)
=
>
{
return
this
.
contentWindow
;
}
enumerable
:
true
}
)
;
return
sb
.
execute
(
task
args
caller
)
;
}
getFocusedElementForWindow
(
targetWindow
aDeep
)
{
var
outParam
=
{
}
;
Services
.
focus
.
getFocusedElementForWindow
(
targetWindow
aDeep
outParam
)
;
return
outParam
.
value
;
}
get
focusManager
(
)
{
return
Services
.
focus
;
}
activeWindow
(
)
{
return
Services
.
focus
.
activeWindow
;
}
focusedWindow
(
)
{
return
Services
.
focus
.
focusedWindow
;
}
focus
(
aWindow
)
{
if
(
aWindow
)
{
aWindow
.
focus
(
)
;
}
try
{
let
actor
=
aWindow
?
aWindow
.
getWindowGlobalChild
(
)
.
getActor
(
"
SpecialPowers
"
)
:
this
;
actor
.
sendAsyncMessage
(
"
SpecialPowers
.
Focus
"
{
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
getClipboardData
(
flavor
whichClipboard
)
{
if
(
whichClipboard
=
=
=
undefined
)
{
whichClipboard
=
Services
.
clipboard
.
kGlobalClipboard
;
}
var
xferable
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
xferable
.
init
(
this
.
docShell
)
;
xferable
.
addDataFlavor
(
flavor
)
;
Services
.
clipboard
.
getData
(
xferable
whichClipboard
)
;
var
data
=
{
}
;
try
{
xferable
.
getTransferData
(
flavor
data
)
;
}
catch
(
e
)
{
}
data
=
data
.
value
|
|
null
;
if
(
data
=
=
null
)
{
return
"
"
;
}
return
data
.
QueryInterface
(
Ci
.
nsISupportsString
)
.
data
;
}
clipboardCopyString
(
str
)
{
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
.
copyString
(
str
)
;
}
supportsSelectionClipboard
(
)
{
return
Services
.
clipboard
.
supportsSelectionClipboard
(
)
;
}
swapFactoryRegistration
(
cid
contractID
newFactory
)
{
newFactory
=
Cu
.
waiveXrays
(
newFactory
)
;
var
componentRegistrar
=
Components
.
manager
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
var
currentCID
=
componentRegistrar
.
contractIDToCID
(
contractID
)
;
var
currentFactory
=
Components
.
manager
.
getClassObject
(
Cc
[
contractID
]
Ci
.
nsIFactory
)
;
if
(
cid
)
{
componentRegistrar
.
unregisterFactory
(
currentCID
currentFactory
)
;
}
else
{
let
uuidGenerator
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
cid
=
uuidGenerator
.
generateUUID
(
)
;
}
componentRegistrar
.
registerFactory
(
cid
"
"
contractID
newFactory
)
;
return
{
originalCID
:
currentCID
}
;
}
_getElement
(
aWindow
id
)
{
return
typeof
id
=
=
"
string
"
?
aWindow
.
document
.
getElementById
(
id
)
:
id
;
}
dispatchEvent
(
aWindow
target
event
)
{
var
el
=
this
.
_getElement
(
aWindow
target
)
;
return
el
.
dispatchEvent
(
event
)
;
}
get
isDebugBuild
(
)
{
delete
SpecialPowersAPI
.
prototype
.
isDebugBuild
;
var
debug
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
return
(
SpecialPowersAPI
.
prototype
.
isDebugBuild
=
debug
.
isDebugBuild
)
;
}
assertionCount
(
)
{
var
debugsvc
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
return
debugsvc
.
assertionCount
;
}
getBrowserFrameMessageManager
(
aFrameElement
)
{
return
this
.
wrap
(
aFrameElement
.
frameLoader
.
messageManager
)
;
}
_getPrincipalFromArg
(
arg
)
{
let
principal
;
let
secMan
=
Services
.
scriptSecurityManager
;
if
(
typeof
arg
=
=
"
string
"
)
{
let
uri
=
Services
.
io
.
newURI
(
arg
)
;
principal
=
secMan
.
createContentPrincipal
(
uri
{
}
)
;
}
else
if
(
arg
.
nodePrincipal
)
{
principal
=
WrapPrivileged
.
unwrap
(
arg
)
.
nodePrincipal
;
}
else
{
let
uri
=
Services
.
io
.
newURI
(
arg
.
url
)
;
let
attrs
=
arg
.
originAttributes
|
|
{
}
;
principal
=
secMan
.
createContentPrincipal
(
uri
attrs
)
;
}
return
principal
;
}
async
addPermission
(
type
allow
arg
expireType
expireTime
)
{
let
principal
=
this
.
_getPrincipalFromArg
(
arg
)
;
if
(
principal
.
isSystemPrincipal
)
{
return
;
}
let
permission
;
if
(
typeof
allow
!
=
=
"
boolean
"
)
{
permission
=
allow
;
}
else
{
permission
=
allow
?
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
:
Ci
.
nsIPermissionManager
.
DENY_ACTION
;
}
var
msg
=
{
op
:
"
add
"
type
permission
principal
expireType
:
typeof
expireType
=
=
=
"
number
"
?
expireType
:
0
expireTime
:
typeof
expireTime
=
=
=
"
number
"
?
expireTime
:
0
}
;
await
this
.
sendQuery
(
"
SPPermissionManager
"
msg
)
;
}
async
removePermission
(
type
arg
)
{
let
principal
=
this
.
_getPrincipalFromArg
(
arg
)
;
if
(
principal
.
isSystemPrincipal
)
{
return
;
}
var
msg
=
{
op
:
"
remove
"
type
principal
}
;
await
this
.
sendQuery
(
"
SPPermissionManager
"
msg
)
;
}
async
hasPermission
(
type
arg
)
{
let
principal
=
this
.
_getPrincipalFromArg
(
arg
)
;
if
(
principal
.
isSystemPrincipal
)
{
return
true
;
}
var
msg
=
{
op
:
"
has
"
type
principal
}
;
return
this
.
sendQuery
(
"
SPPermissionManager
"
msg
)
;
}
async
testPermission
(
type
value
arg
)
{
let
principal
=
this
.
_getPrincipalFromArg
(
arg
)
;
if
(
principal
.
isSystemPrincipal
)
{
return
true
;
}
var
msg
=
{
op
:
"
test
"
type
value
principal
}
;
return
this
.
sendQuery
(
"
SPPermissionManager
"
msg
)
;
}
isContentWindowPrivate
(
win
)
{
return
PrivateBrowsingUtils
.
isContentWindowPrivate
(
win
)
;
}
async
notifyObserversInParentProcess
(
subject
topic
data
)
{
if
(
subject
)
{
throw
new
Error
(
"
Can
'
t
send
subject
to
another
process
!
"
)
;
}
if
(
this
.
isMainProcess
(
)
)
{
this
.
notifyObservers
(
subject
topic
data
)
;
return
;
}
var
msg
=
{
op
:
"
notify
"
observerTopic
:
topic
observerData
:
data
}
;
await
this
.
sendQuery
(
"
SPObserverService
"
msg
)
;
}
removeAllServiceWorkerData
(
)
{
return
this
.
sendQuery
(
"
SPRemoveAllServiceWorkers
"
{
}
)
;
}
removeServiceWorkerDataForExampleDomain
(
)
{
return
this
.
sendQuery
(
"
SPRemoveServiceWorkerDataForExampleDomain
"
{
}
)
;
}
cleanUpSTSData
(
origin
flags
)
{
return
this
.
sendQuery
(
"
SPCleanUpSTSData
"
{
origin
flags
:
flags
|
|
0
}
)
;
}
async
requestDumpCoverageCounters
(
cb
)
{
if
(
!
PerTestCoverageUtils
.
enabled
)
{
return
;
}
await
this
.
sendQuery
(
"
SPRequestDumpCoverageCounters
"
{
}
)
;
}
async
requestResetCoverageCounters
(
cb
)
{
if
(
!
PerTestCoverageUtils
.
enabled
)
{
return
;
}
await
this
.
sendQuery
(
"
SPRequestResetCoverageCounters
"
{
}
)
;
}
loadExtension
(
ext
handler
)
{
if
(
this
.
_extensionListeners
=
=
null
)
{
this
.
_extensionListeners
=
new
Set
(
)
;
this
.
_addMessageListener
(
"
SPExtensionMessage
"
msg
=
>
{
for
(
let
listener
of
this
.
_extensionListeners
)
{
try
{
listener
(
msg
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
)
;
}
let
id
=
this
.
_nextExtensionID
+
+
;
handler
=
Cu
.
waiveXrays
(
handler
)
;
ext
=
Cu
.
waiveXrays
(
ext
)
;
let
sp
=
this
;
let
state
=
"
uninitialized
"
;
let
extension
=
{
get
state
(
)
{
return
state
;
}
startup
(
)
{
state
=
"
pending
"
;
return
sp
.
sendQuery
(
"
SPStartupExtension
"
{
id
}
)
.
then
(
(
)
=
>
{
state
=
"
running
"
;
}
(
)
=
>
{
state
=
"
failed
"
;
sp
.
_extensionListeners
.
delete
(
listener
)
;
return
Promise
.
reject
(
"
startup
failed
"
)
;
}
)
;
}
unload
(
)
{
state
=
"
unloading
"
;
return
sp
.
sendQuery
(
"
SPUnloadExtension
"
{
id
}
)
.
finally
(
(
)
=
>
{
sp
.
_extensionListeners
.
delete
(
listener
)
;
state
=
"
unloaded
"
;
}
)
;
}
sendMessage
(
.
.
.
args
)
{
sp
.
sendAsyncMessage
(
"
SPExtensionMessage
"
{
id
args
}
)
;
}
}
;
this
.
sendAsyncMessage
(
"
SPLoadExtension
"
{
ext
id
}
)
;
let
listener
=
msg
=
>
{
if
(
msg
.
data
.
id
=
=
id
)
{
if
(
msg
.
data
.
type
=
=
"
extensionSetId
"
)
{
extension
.
id
=
msg
.
data
.
args
[
0
]
;
extension
.
uuid
=
msg
.
data
.
args
[
1
]
;
}
else
if
(
msg
.
data
.
type
in
handler
)
{
handler
[
msg
.
data
.
type
]
(
.
.
.
Cu
.
cloneInto
(
msg
.
data
.
args
this
.
contentWindow
)
)
;
}
else
{
dump
(
Unexpected
:
{
msg
.
data
.
type
}
\
n
)
;
}
}
}
;
this
.
_extensionListeners
.
add
(
listener
)
;
return
extension
;
}
invalidateExtensionStorageCache
(
)
{
this
.
notifyObserversInParentProcess
(
null
"
extension
-
invalidate
-
storage
-
cache
"
"
"
)
;
}
allowMedia
(
window
enable
)
{
window
.
docShell
.
allowMedia
=
enable
;
}
createChromeCache
(
name
url
)
{
let
principal
=
this
.
_getPrincipalFromArg
(
url
)
;
return
WrapPrivileged
.
wrap
(
new
this
.
contentWindow
.
CacheStorage
(
name
principal
)
)
;
}
loadChannelAndReturnStatus
(
url
loadUsingSystemPrincipal
)
{
const
BinaryInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
binaryinputstream
;
1
"
"
nsIBinaryInputStream
"
"
setInputStream
"
)
;
return
new
Promise
(
function
(
resolve
)
{
let
listener
=
{
httpStatus
:
0
onStartRequest
(
request
)
{
request
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
this
.
httpStatus
=
request
.
responseStatus
;
}
onDataAvailable
(
request
stream
offset
count
)
{
new
BinaryInputStream
(
stream
)
.
readByteArray
(
count
)
;
}
onStopRequest
(
request
status
)
{
let
httpStatus
=
this
.
httpStatus
;
resolve
(
{
status
httpStatus
}
)
;
}
}
;
let
uri
=
NetUtil
.
newURI
(
url
)
;
let
channel
=
NetUtil
.
newChannel
(
{
uri
loadUsingSystemPrincipal
}
)
;
channel
.
loadFlags
|
=
Ci
.
nsIChannel
.
LOAD_DOCUMENT_URI
;
channel
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
;
channel
.
documentURI
=
uri
;
channel
.
asyncOpen
(
listener
)
;
}
)
;
}
get
ParserUtils
(
)
{
if
(
this
.
_pu
!
=
null
)
{
return
this
.
_pu
;
}
let
pu
=
Cc
[
"
mozilla
.
org
/
parserutils
;
1
"
]
.
getService
(
Ci
.
nsIParserUtils
)
;
this
.
_pu
=
{
sanitize
(
src
flags
)
{
return
pu
.
sanitize
(
src
flags
)
;
}
convertToPlainText
(
src
flags
wrapCol
)
{
return
pu
.
convertToPlainText
(
src
flags
wrapCol
)
;
}
parseFragment
(
fragment
flags
isXML
baseURL
element
)
{
let
baseURI
=
baseURL
?
NetUtil
.
newURI
(
baseURL
)
:
null
;
return
pu
.
parseFragment
(
WrapPrivileged
.
unwrap
(
fragment
)
flags
isXML
baseURI
WrapPrivileged
.
unwrap
(
element
)
)
;
}
}
;
return
this
.
_pu
;
}
createDOMWalker
(
node
showAnonymousContent
)
{
node
=
WrapPrivileged
.
unwrap
(
node
)
;
let
walker
=
Cc
[
"
mozilla
.
org
/
inspector
/
deep
-
tree
-
walker
;
1
"
]
.
createInstance
(
Ci
.
inIDeepTreeWalker
)
;
walker
.
showAnonymousContent
=
showAnonymousContent
;
walker
.
init
(
node
.
ownerDocument
NodeFilter
.
SHOW_ALL
)
;
walker
.
currentNode
=
node
;
return
{
get
firstChild
(
)
{
return
WrapPrivileged
.
wrap
(
walker
.
firstChild
(
)
)
;
}
get
lastChild
(
)
{
return
WrapPrivileged
.
wrap
(
walker
.
lastChild
(
)
)
;
}
}
;
}
observeMutationEvents
(
mo
node
nativeAnonymousChildList
subtree
)
{
WrapPrivileged
.
unwrap
(
mo
)
.
observe
(
WrapPrivileged
.
unwrap
(
node
)
{
nativeAnonymousChildList
subtree
}
)
;
}
doCommand
(
window
cmd
)
{
return
window
.
docShell
.
doCommand
(
cmd
)
;
}
isCommandEnabled
(
window
cmd
)
{
return
window
.
docShell
.
isCommandEnabled
(
cmd
)
;
}
setCommandNode
(
window
node
)
{
return
window
.
docShell
.
contentViewer
.
QueryInterface
(
Ci
.
nsIContentViewerEdit
)
.
setCommandNode
(
node
)
;
}
doUrlClassify
(
principal
eventTarget
callback
)
{
let
classifierService
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
dbservice
;
1
"
]
.
getService
(
Ci
.
nsIURIClassifier
)
;
let
wrapCallback
=
(
.
.
.
args
)
=
>
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
if
(
typeof
callback
=
=
"
function
"
)
{
callback
(
.
.
.
args
)
;
}
else
{
callback
.
onClassifyComplete
.
call
(
undefined
.
.
.
args
)
;
}
}
)
;
}
;
return
classifierService
.
classify
(
WrapPrivileged
.
unwrap
(
principal
)
eventTarget
wrapCallback
)
;
}
doUrlClassifyLocal
(
uri
tables
callback
)
{
let
classifierService
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
dbservice
;
1
"
]
.
getService
(
Ci
.
nsIURIClassifier
)
;
let
wrapCallback
=
results
=
>
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
if
(
typeof
callback
=
=
"
function
"
)
{
callback
(
WrapPrivileged
.
wrap
(
results
)
)
;
}
else
{
callback
.
onClassifyComplete
.
call
(
undefined
WrapPrivileged
.
wrap
(
results
)
)
;
}
}
)
;
}
;
let
feature
=
classifierService
.
createFeatureWithTables
(
"
test
"
tables
.
split
(
"
"
)
[
]
)
;
return
classifierService
.
asyncClassifyLocalWithFeatures
(
WrapPrivileged
.
unwrap
(
uri
)
[
feature
]
Ci
.
nsIUrlClassifierFeature
.
blacklist
wrapCallback
)
;
}
}
SpecialPowersAPI
.
prototype
.
_proxiedObservers
=
{
"
specialpowers
-
http
-
notify
-
request
"
:
function
(
aMessage
)
{
let
uri
=
aMessage
.
json
.
uri
;
Services
.
obs
.
notifyObservers
(
null
"
specialpowers
-
http
-
notify
-
request
"
uri
)
;
}
"
specialpowers
-
service
-
worker
-
shutdown
"
:
function
(
aMessage
)
{
Services
.
obs
.
notifyObservers
(
null
"
specialpowers
-
service
-
worker
-
shutdown
"
)
;
}
}
;
SpecialPowersAPI
.
prototype
.
permissionObserverProxy
=
{
_specialPowersAPI
:
null
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
perm
-
changed
"
)
{
var
permission
=
aSubject
.
QueryInterface
(
Ci
.
nsIPermission
)
;
this
.
_specialPowersAPI
.
_permissionObserver
.
observe
(
permission
aData
)
;
}
}
}
;
SpecialPowersAPI
.
prototype
.
_permissionObserver
=
{
_self
:
null
_lastPermission
:
{
}
_callBack
:
null
_nextCallback
:
null
_obsDataMap
:
{
deleted
:
"
remove
"
added
:
"
add
"
}
observe
(
permission
aData
)
{
if
(
this
.
_self
.
_applyingPermissions
)
{
if
(
permission
.
type
=
=
this
.
_lastPermission
.
type
)
{
this
.
_self
.
_setTimeout
(
this
.
_callback
)
;
this
.
_self
.
_setTimeout
(
this
.
_nextCallback
)
;
this
.
_callback
=
null
;
this
.
_nextCallback
=
null
;
}
}
else
{
var
found
=
false
;
for
(
var
i
=
0
;
!
found
&
&
i
<
this
.
_self
.
_permissionsUndoStack
.
length
;
i
+
+
)
{
var
undos
=
this
.
_self
.
_permissionsUndoStack
[
i
]
;
for
(
var
j
=
0
;
j
<
undos
.
length
;
j
+
+
)
{
var
undo
=
undos
[
j
]
;
if
(
undo
.
op
=
=
this
.
_obsDataMap
[
aData
]
&
&
undo
.
type
=
=
permission
.
type
)
{
undos
.
splice
(
j
1
)
;
found
=
true
;
break
;
}
}
if
(
!
undos
.
length
)
{
this
.
_self
.
_permissionsUndoStack
.
splice
(
i
1
)
;
}
}
}
}
}
;
SpecialPowersAPI
.
prototype
.
EARLY_BETA_OR_EARLIER
=
AppConstants
.
EARLY_BETA_OR_EARLIER
;
Object
.
assign
(
SpecialPowersAPI
.
prototype
{
_permissionsUndoStack
:
[
]
_pendingPermissions
:
[
]
}
)
;
this
.
SpecialPowersAPI
=
SpecialPowersAPI
;
this
.
bindDOMWindowUtils
=
bindDOMWindowUtils
;
