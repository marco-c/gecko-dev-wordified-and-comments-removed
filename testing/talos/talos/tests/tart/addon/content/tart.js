let
aboutNewTabService
=
Cc
[
"
mozilla
.
org
/
browser
/
aboutnewtab
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAboutNewTabService
)
;
function
Tart
(
)
{
}
Tart
.
prototype
=
{
tabDetector
:
{
arm
(
handler
win
)
{
win
.
gBrowser
.
tabContainer
.
addEventListener
(
"
transitionend
"
handler
)
;
}
measureNow
(
e
)
{
return
(
e
.
type
=
=
"
transitionend
"
&
&
e
.
propertyName
=
=
"
max
-
width
"
)
;
}
cleanup
(
handler
win
)
{
win
.
gBrowser
.
tabContainer
.
removeEventListener
(
"
transitionend
"
handler
)
;
}
}
customizeEnterDetector
:
{
arm
(
handler
win
)
{
win
.
gNavToolbox
.
addEventListener
(
"
customizationready
"
handler
)
;
}
measureNow
(
e
)
{
return
(
e
.
type
=
=
"
customizationready
"
)
;
}
cleanup
(
handler
win
)
{
win
.
gNavToolbox
.
removeEventListener
(
"
customizationready
"
handler
)
;
}
}
makeNewTabURLChangePromise
(
url
)
{
let
promise
=
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
data
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
if
(
data
=
=
url
)
{
resolve
(
)
;
}
}
"
newtab
-
url
-
changed
"
)
;
}
)
;
if
(
url
=
=
=
"
about
:
newtab
"
)
{
aboutNewTabService
.
resetNewTabURL
(
)
;
}
else
{
aboutNewTabService
.
newTabURL
=
url
;
}
return
promise
;
}
customizeEnterCssDetector
:
{
arm
(
handler
win
)
{
win
.
gNavToolbox
.
addEventListener
(
"
customizationready
"
handler
)
;
win
.
gNavToolbox
.
addEventListener
(
"
customization
-
transitionend
"
handler
)
;
}
measureNow
(
e
)
{
return
(
e
.
type
=
=
"
customization
-
transitionend
"
)
;
}
keepListening
(
e
)
{
return
(
e
.
type
!
=
"
customizationready
"
)
;
}
cleanup
(
handler
win
)
{
win
.
gNavToolbox
.
removeEventListener
(
"
customization
-
transitionend
"
handler
)
;
win
.
gNavToolbox
.
removeEventListener
(
"
customizationready
"
handler
)
;
}
}
customizeExitDetector
:
{
arm
(
handler
win
)
{
win
.
gNavToolbox
.
addEventListener
(
"
aftercustomization
"
handler
)
;
}
measureNow
(
e
)
{
return
(
e
.
type
=
=
"
aftercustomization
"
)
;
}
cleanup
(
handler
win
)
{
win
.
gNavToolbox
.
removeEventListener
(
"
aftercustomization
"
handler
)
;
}
}
clickNewTab
(
)
{
this
.
_endDetection
=
this
.
tabDetector
;
this
.
_win
.
BrowserOpenTab
(
)
;
return
this
.
_win
.
gBrowser
.
selectedTab
;
}
clickCloseCurrentTab
(
)
{
this
.
_endDetection
=
this
.
tabDetector
;
this
.
_win
.
BrowserCloseTabOrWindow
(
)
;
return
this
.
_win
.
gBrowser
.
selectedTab
;
}
fadeOutCurrentTab
(
)
{
this
.
_endDetection
=
this
.
tabDetector
;
this
.
_win
.
gBrowser
.
selectedTab
.
removeAttribute
(
"
fadein
"
)
;
}
fadeInCurrentTab
(
)
{
this
.
_endDetection
=
this
.
tabDetector
;
this
.
_win
.
gBrowser
.
selectedTab
.
setAttribute
(
"
fadein
"
"
true
"
)
;
}
addSomeChromeUriTab
(
)
{
this
.
_endDetection
=
this
.
tabDetector
;
this
.
_win
.
gBrowser
.
selectedTab
=
this
.
_win
.
gBrowser
.
addTrustedTab
(
"
chrome
:
/
/
tart
/
content
/
blank
.
icon
.
html
"
)
;
}
triggerCustomizeEnter
(
)
{
this
.
_endDetection
=
this
.
customizeEnterDetector
;
this
.
_win
.
gCustomizeMode
.
enter
(
)
;
}
triggerCustomizeEnterCss
(
)
{
this
.
_endDetection
=
this
.
customizeEnterCssDetector
;
this
.
_win
.
gCustomizeMode
.
enter
(
)
;
}
triggerCustomizeExit
(
)
{
this
.
_endDetection
=
this
.
customizeExitDetector
;
this
.
_win
.
gCustomizeMode
.
exit
(
)
;
}
pinTart
(
)
{
return
this
.
_win
.
gBrowser
.
pinTab
(
this
.
_tartTab
)
;
}
unpinTart
(
)
{
return
this
.
_win
.
gBrowser
.
unpinTab
(
this
.
_tartTab
)
;
}
USE_RECORDING_API
:
true
_win
:
undefined
_tartTab
:
undefined
_results
:
[
]
_config
:
{
subtests
:
[
]
repeat
:
1
rest
:
500
tickle
:
true
controlProfiler
:
true
}
_animate
(
preWaitMs
triggerFunc
onDoneCallback
isReportResult
name
referenceDuration
)
{
var
self
=
this
;
var
recordingHandle
;
var
timeoutId
=
0
;
var
detector
;
var
rAF
=
window
.
requestAnimationFrame
|
|
window
.
mozRequestAnimationFrame
;
var
_recording
=
[
]
;
var
_abortRecording
=
false
;
var
startRecordTimestamp
;
function
startRecord
(
)
{
if
(
self
.
_config
.
controlProfiler
)
{
if
(
isReportResult
)
Profiler
.
resume
(
name
)
;
}
else
{
Profiler
.
mark
(
"
Start
:
"
+
(
isReportResult
?
name
:
"
[
warmup
]
"
)
true
)
;
}
startRecordTimestamp
=
window
.
performance
.
now
(
)
;
if
(
self
.
USE_RECORDING_API
)
{
return
window
.
windowUtils
.
startFrameTimeRecording
(
)
;
}
_recording
=
[
]
;
_abortRecording
=
false
;
var
last
=
performance
.
now
(
)
;
function
rec
(
)
{
if
(
_abortRecording
)
return
;
var
now
=
performance
.
now
(
)
;
_recording
.
push
(
now
-
last
)
;
last
=
now
;
rAF
(
rec
)
;
}
rAF
(
rec
)
;
return
1
;
}
var
recordingAbsoluteDuration
;
function
stopRecord
(
)
{
recordingAbsoluteDuration
=
window
.
performance
.
now
(
)
-
startRecordTimestamp
;
if
(
self
.
_config
.
controlProfiler
)
{
if
(
isReportResult
)
Profiler
.
pause
(
name
)
;
}
else
{
Profiler
.
mark
(
"
End
:
"
+
(
isReportResult
?
name
:
"
[
warmup
]
"
)
true
)
;
}
if
(
self
.
USE_RECORDING_API
)
{
return
window
.
windowUtils
.
stopFrameTimeRecording
(
recordingHandle
)
;
}
_abortRecording
=
true
;
return
_recording
.
slice
(
0
)
;
}
function
addResult
(
intervals
)
{
var
sumLastHalf
=
0
;
var
countLastHalf
=
0
;
var
sumMost
=
0
;
var
sum
=
0
;
for
(
var
i
=
intervals
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
sum
+
=
intervals
[
i
]
;
if
(
sumLastHalf
<
referenceDuration
/
2
)
{
sumLastHalf
+
=
intervals
[
i
]
;
countLastHalf
+
+
;
}
if
(
sumMost
<
referenceDuration
*
.
85
)
{
sumMost
+
=
intervals
[
i
]
;
}
}
dump
(
"
overall
:
"
+
sum
+
"
\
n
"
)
;
var
averageLastHalf
=
countLastHalf
?
sumLastHalf
/
countLastHalf
:
0
;
var
averageOverall
=
intervals
.
length
?
sum
/
intervals
.
length
:
0
;
var
durationDiff
=
Math
.
abs
(
recordingAbsoluteDuration
-
referenceDuration
)
;
self
.
_results
.
push
(
{
name
:
name
+
"
.
raw
.
TART
"
value
:
intervals
}
)
;
self
.
_results
.
push
(
{
name
:
name
+
"
.
half
.
TART
"
value
:
averageLastHalf
}
)
;
self
.
_results
.
push
(
{
name
:
name
+
"
.
all
.
TART
"
value
:
averageOverall
}
)
;
self
.
_results
.
push
(
{
name
:
name
+
"
.
error
.
TART
"
value
:
durationDiff
}
)
;
}
function
transEnd
(
e
)
{
if
(
e
)
{
let
isMeasureNow
=
detector
.
measureNow
(
e
)
;
if
(
isMeasureNow
)
{
let
intervals
=
stopRecord
(
)
;
if
(
isReportResult
)
{
addResult
(
intervals
)
;
}
}
if
(
detector
.
keepListening
?
detector
.
keepListening
(
e
)
:
!
isMeasureNow
)
{
return
;
}
}
else
{
dump
(
"
TART
:
TIMEOUT
\
n
"
)
;
}
detector
.
cleanup
(
transEnd
self
.
_win
)
;
clearTimeout
(
timeoutId
)
;
onDoneCallback
(
)
;
}
function
trigger
(
f
)
{
if
(
!
self
.
USE_RECORDING_API
)
return
rAF
(
f
)
;
var
id
=
"
back
-
button
"
;
var
orig
=
self
.
_win
.
document
.
getElementById
(
id
)
.
style
.
opacity
;
var
i
=
0
;
function
tickleLoop
(
)
{
if
(
i
+
+
<
(
(
isReportResult
&
&
self
.
_config
.
tickle
)
?
17
:
0
)
)
{
self
.
_win
.
document
.
getElementById
(
id
)
.
style
.
opacity
=
i
%
10
/
10
+
.
05
;
return
rAF
(
tickleLoop
)
;
}
self
.
_win
.
document
.
getElementById
(
id
)
.
style
.
opacity
=
orig
;
return
rAF
(
f
)
;
}
tickleLoop
(
)
;
return
false
;
}
setTimeout
(
function
(
)
{
trigger
(
function
(
)
{
timeoutId
=
setTimeout
(
transEnd
3000
)
;
recordingHandle
=
startRecord
(
)
;
triggerFunc
(
)
;
detector
=
self
.
_endDetection
;
detector
.
arm
(
transEnd
self
.
_win
)
;
}
)
;
}
preWaitMs
)
;
}
_nextCommandIx
:
0
_commands
:
[
]
_onSequenceComplete
:
0
_nextCommand
(
)
{
if
(
this
.
_nextCommandIx
>
=
this
.
_commands
.
length
)
{
this
.
_onSequenceComplete
(
)
;
return
;
}
this
.
_commands
[
this
.
_nextCommandIx
+
+
]
(
)
;
}
_doSequence
(
commands
onComplete
)
{
this
.
_commands
=
commands
;
this
.
_onSequenceComplete
=
onComplete
;
this
.
_results
=
[
]
;
this
.
_nextCommandIx
=
0
;
this
.
_nextCommand
(
)
;
}
_log
(
str
)
{
if
(
window
.
MozillaFileLogger
&
&
window
.
MozillaFileLogger
.
log
)
window
.
MozillaFileLogger
.
log
(
str
)
;
window
.
dump
(
str
)
;
}
_logLine
(
str
)
{
return
this
.
_log
(
str
+
"
\
n
"
)
;
}
_reportAllResults
(
)
{
var
out
=
"
"
;
for
(
var
i
in
this
.
_results
)
{
res
=
this
.
_results
[
i
]
;
var
disp
=
[
]
.
concat
(
res
.
value
)
.
map
(
function
(
a
)
{
return
(
isNaN
(
a
)
?
-
1
:
a
.
toFixed
(
1
)
)
;
}
)
.
join
(
"
"
)
;
out
+
=
res
.
name
+
"
:
"
+
disp
+
"
\
n
"
;
}
this
.
_log
(
"
\
n
"
+
out
)
;
}
_onTestComplete
:
null
_doneInternal
(
)
{
this
.
_logLine
(
"
TART_RESULTS_JSON
=
"
+
JSON
.
stringify
(
this
.
_results
)
)
;
this
.
_reportAllResults
(
)
;
this
.
_win
.
gBrowser
.
selectedTab
=
this
.
_tartTab
;
if
(
this
.
_onTestComplete
)
{
this
.
_onTestComplete
(
JSON
.
parse
(
JSON
.
stringify
(
this
.
_results
)
)
)
;
}
}
_startTest
(
)
{
var
origPreload
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
newtab
.
preload
"
)
;
var
origDpi
=
Services
.
prefs
.
getCharPref
(
"
layout
.
css
.
devPixelsPerPx
"
)
;
var
origPinned
=
this
.
_tartTab
.
pinned
;
var
self
=
this
;
var
animate
=
this
.
_animate
.
bind
(
this
)
;
var
addTab
=
this
.
clickNewTab
.
bind
(
this
)
;
var
closeCurrentTab
=
this
.
clickCloseCurrentTab
.
bind
(
this
)
;
var
fadein
=
this
.
fadeInCurrentTab
.
bind
(
this
)
;
var
fadeout
=
this
.
fadeOutCurrentTab
.
bind
(
this
)
;
var
addSomeTab
=
this
.
addSomeChromeUriTab
.
bind
(
this
)
;
var
customizeEnter
=
this
.
triggerCustomizeEnter
.
bind
(
this
)
;
var
customizeEnterCss
=
this
.
triggerCustomizeEnterCss
.
bind
(
this
)
;
var
customizeExit
=
this
.
triggerCustomizeExit
.
bind
(
this
)
;
var
next
=
this
.
_nextCommand
.
bind
(
this
)
;
var
rest
=
500
;
if
(
this
.
_config
.
rest
)
{
rest
=
this
.
_config
.
rest
;
}
function
getMaxTabTransitionTimeMs
(
aTab
)
{
let
cstyle
=
window
.
getComputedStyle
(
aTab
)
;
try
{
return
1000
*
Math
.
max
.
apply
(
null
cstyle
.
transitionDuration
.
split
(
"
"
)
.
map
(
s
=
>
parseFloat
(
s
10
)
)
)
;
}
catch
(
e
)
{
return
250
;
}
}
function
getReferenceCustomizationDuration
(
)
{
try
{
let
deck
=
document
.
getElementById
(
"
content
-
deck
"
)
;
let
cstyle
=
window
.
getComputedStyle
(
deck
)
;
return
1000
*
parseFloat
(
cstyle
.
transitionDuration
10
)
;
}
catch
(
e
)
{
return
150
;
}
}
this
.
unpinTart
(
)
;
var
tabRefDuration
=
getMaxTabTransitionTimeMs
(
this
.
_tartTab
)
;
if
(
tabRefDuration
<
20
|
|
tabRefDuration
>
2000
)
{
tabRefDuration
=
250
;
}
var
custRefDuration
=
getReferenceCustomizationDuration
(
)
;
var
subtests
=
{
init
:
[
function
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
newtab
.
preload
"
false
)
;
self
.
pinTart
(
)
;
self
.
makeNewTabURLChangePromise
(
"
about
:
blank
"
)
.
then
(
next
)
;
}
]
restore
:
[
function
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
newtab
.
preload
"
origPreload
)
;
Services
.
prefs
.
setCharPref
(
"
layout
.
css
.
devPixelsPerPx
"
origDpi
)
;
if
(
origPinned
)
self
.
pinTart
(
)
;
else
self
.
unpinTart
(
)
;
self
.
makeNewTabURLChangePromise
(
"
about
:
newtab
"
)
.
then
(
next
)
;
}
]
simple
:
[
function
(
)
{
Services
.
prefs
.
setCharPref
(
"
layout
.
css
.
devPixelsPerPx
"
"
1
"
)
;
next
(
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
function
(
)
{
animate
(
rest
addTab
next
true
"
simple
-
open
-
DPI1
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
closeCurrentTab
next
true
"
simple
-
close
-
DPI1
"
tabRefDuration
)
;
}
]
iconDpi1
:
[
function
(
)
{
Services
.
prefs
.
setCharPref
(
"
layout
.
css
.
devPixelsPerPx
"
"
1
"
)
;
self
.
makeNewTabURLChangePromise
(
"
chrome
:
/
/
tart
/
content
/
blank
.
icon
.
html
"
)
.
then
(
next
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
function
(
)
{
animate
(
rest
addTab
next
true
"
icon
-
open
-
DPI1
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
closeCurrentTab
next
true
"
icon
-
close
-
DPI1
"
tabRefDuration
)
;
}
]
iconDpi2
:
[
function
(
)
{
Services
.
prefs
.
setCharPref
(
"
layout
.
css
.
devPixelsPerPx
"
"
2
"
)
;
self
.
makeNewTabURLChangePromise
(
"
chrome
:
/
/
tart
/
content
/
blank
.
icon
.
html
"
)
.
then
(
next
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
function
(
)
{
animate
(
rest
addTab
next
true
"
icon
-
open
-
DPI2
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
closeCurrentTab
next
true
"
icon
-
close
-
DPI2
"
tabRefDuration
)
;
}
]
newtabNoPreload
:
[
function
(
)
{
Services
.
prefs
.
setCharPref
(
"
layout
.
css
.
devPixelsPerPx
"
"
-
1
"
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
newtab
.
preload
"
false
)
;
self
.
makeNewTabURLChangePromise
(
"
about
:
newtab
"
)
.
then
(
next
)
;
}
function
(
)
{
animate
(
rest
addTab
next
true
"
newtab
-
open
-
preload
-
no
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
]
newtabYesPreload
:
[
function
(
)
{
Services
.
prefs
.
setCharPref
(
"
layout
.
css
.
devPixelsPerPx
"
"
-
1
"
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
newtab
.
preload
"
true
)
;
self
.
makeNewTabURLChangePromise
(
"
about
:
newtab
"
)
.
then
(
next
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
function
(
)
{
animate
(
1000
addTab
next
true
"
newtab
-
open
-
preload
-
yes
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
]
simple3open3closeDpiCurrent
:
[
function
(
)
{
animate
(
rest
addTab
next
true
"
simple3
-
1
-
open
-
DPIcurrent
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
addTab
next
true
"
simple3
-
2
-
open
-
DPIcurrent
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
addTab
next
true
"
simple3
-
3
-
open
-
DPIcurrent
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
closeCurrentTab
next
true
"
simple3
-
3
-
close
-
DPIcurrent
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
closeCurrentTab
next
true
"
simple3
-
2
-
close
-
DPIcurrent
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
closeCurrentTab
next
true
"
simple3
-
1
-
close
-
DPIcurrent
"
tabRefDuration
)
;
}
]
multi
:
[
function
(
)
{
Services
.
prefs
.
setCharPref
(
"
layout
.
css
.
devPixelsPerPx
"
"
1
.
0
"
)
;
self
.
makeNewTabURLChangePromise
(
"
chrome
:
/
/
tart
/
content
/
blank
.
icon
.
html
"
)
.
then
(
next
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
rest
*
2
addTab
next
true
"
multi
-
open
-
DPI1
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
*
2
closeCurrentTab
next
true
"
multi
-
close
-
DPI1
"
tabRefDuration
)
;
}
function
(
)
{
Services
.
prefs
.
setCharPref
(
"
layout
.
css
.
devPixelsPerPx
"
"
2
"
)
;
next
(
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
function
(
)
{
animate
(
rest
*
2
addTab
next
true
"
multi
-
open
-
DPI2
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
*
2
closeCurrentTab
next
true
"
multi
-
close
-
DPI2
"
tabRefDuration
)
;
}
function
(
)
{
Services
.
prefs
.
setCharPref
(
"
layout
.
css
.
devPixelsPerPx
"
"
-
1
"
)
;
next
(
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
]
simpleFadeDpiCurrent
:
[
function
(
)
{
self
.
makeNewTabURLChangePromise
(
"
about
:
blank
"
)
.
then
(
next
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
rest
fadeout
next
true
"
simpleFade
-
close
-
DPIcurrent
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
fadein
next
true
"
simpleFade
-
open
-
DPIcurrent
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
]
iconFadeDpiCurrent
:
[
function
(
)
{
self
.
makeNewTabURLChangePromise
(
"
chrome
:
/
/
tart
/
content
/
blank
.
icon
.
html
"
)
.
then
(
next
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
rest
fadeout
next
true
"
iconFade
-
close
-
DPIcurrent
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
fadein
next
true
"
iconFade
-
open
-
DPIcurrent
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
]
iconFadeDpi2
:
[
function
(
)
{
Services
.
prefs
.
setCharPref
(
"
layout
.
css
.
devPixelsPerPx
"
"
2
"
)
;
self
.
makeNewTabURLChangePromise
(
"
chrome
:
/
/
tart
/
content
/
blank
.
icon
.
html
"
)
.
then
(
next
)
;
}
function
(
)
{
animate
(
0
addTab
next
)
;
}
function
(
)
{
animate
(
rest
fadeout
next
true
"
iconFade
-
close
-
DPI2
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
fadein
next
true
"
iconFade
-
open
-
DPI2
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
]
lastTabFadeDpiCurrent
:
[
function
(
)
{
self
.
_win
.
gBrowser
.
selectedTab
=
self
.
_win
.
gBrowser
.
tabs
[
gBrowser
.
tabs
.
length
-
1
]
;
next
(
)
;
}
function
(
)
{
animate
(
rest
fadeout
next
true
"
lastTabFade
-
close
-
DPIcurrent
"
tabRefDuration
)
;
}
function
(
)
{
animate
(
rest
fadein
next
true
"
lastTabFade
-
open
-
DPIcurrent
"
tabRefDuration
)
;
}
]
customize
:
[
function
(
)
{
Services
.
prefs
.
setCharPref
(
"
layout
.
css
.
devPixelsPerPx
"
"
-
1
"
)
;
next
(
)
;
}
function
(
)
{
animate
(
0
addSomeTab
next
)
;
}
function
(
)
{
animate
(
rest
customizeEnter
next
true
"
1
-
customize
-
enter
"
custRefDuration
)
;
}
function
(
)
{
animate
(
rest
customizeExit
next
true
"
2
-
customize
-
exit
"
custRefDuration
)
;
}
function
(
)
{
animate
(
rest
customizeEnterCss
next
true
"
3
-
customize
-
enter
-
css
"
custRefDuration
)
;
}
function
(
)
{
animate
(
0
customizeExit
next
)
;
}
function
(
)
{
animate
(
0
closeCurrentTab
next
)
;
}
]
}
;
sequenceArray
=
[
]
;
for
(
var
i
in
this
.
_config
.
subtests
)
{
for
(
var
r
=
0
;
r
<
this
.
_config
.
repeat
;
r
+
+
)
{
sequenceArray
=
sequenceArray
.
concat
(
subtests
.
init
)
;
sequenceArray
=
sequenceArray
.
concat
(
subtests
[
this
.
_config
.
subtests
[
i
]
]
)
;
}
}
sequenceArray
=
sequenceArray
.
concat
(
subtests
.
restore
)
;
this
.
_doSequence
(
sequenceArray
this
.
_doneInternal
)
;
}
startTest
(
doneCallback
config
)
{
this
.
_onTestComplete
=
function
(
results
)
{
Profiler
.
mark
(
"
TART
-
end
"
true
)
;
doneCallback
(
results
)
;
}
;
this
.
_config
=
config
;
this
.
_win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
this
.
_tartTab
=
this
.
_win
.
gBrowser
.
selectedTab
;
this
.
_win
.
gBrowser
.
selectedBrowser
.
focus
(
)
;
Profiler
.
mark
(
"
TART
-
start
"
true
)
;
return
this
.
_startTest
(
)
;
}
}
;
