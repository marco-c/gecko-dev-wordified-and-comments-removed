ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
RemotePageManager
.
jsm
"
)
;
let
context
=
{
}
;
let
TalosParentProfiler
;
function
promiseOneEvent
(
target
eventName
capture
)
{
return
new
Promise
(
resolve
=
>
{
target
.
addEventListener
(
eventName
function
handler
(
event
)
{
resolve
(
)
;
}
{
capture
once
:
true
}
)
;
}
)
;
}
function
executeSoon
(
callback
)
{
Services
.
tm
.
dispatchToMainThread
(
callback
)
;
}
function
waitForDelayedStartup
(
win
)
{
return
new
Promise
(
(
resolve
)
=
>
{
const
topic
=
"
browser
-
delayed
-
startup
-
finished
"
;
Services
.
obs
.
addObserver
(
function
onStartup
(
subject
)
{
if
(
win
=
=
subject
)
{
Services
.
obs
.
removeObserver
(
onStartup
topic
)
;
resolve
(
)
;
}
}
topic
)
;
}
)
;
}
function
loadTabs
(
gBrowser
urls
)
{
return
new
Promise
(
(
resolve
)
=
>
{
gBrowser
.
loadTabs
(
urls
{
inBackground
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
let
waitingToLoad
=
new
Set
(
urls
)
;
let
listener
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
onStateChange
(
aBrowser
aWebProgress
aRequest
aStateFlags
aStatus
)
{
let
loadedState
=
Ci
.
nsIWebProgressListener
.
STATE_STOP
|
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
;
if
(
(
aStateFlags
&
loadedState
)
=
=
loadedState
&
&
!
aWebProgress
.
isLoadingDocument
&
&
aWebProgress
.
isTopLevel
&
&
Components
.
isSuccessCode
(
aStatus
)
)
{
dump
(
Loaded
:
{
aBrowser
.
currentURI
.
spec
}
\
n
)
;
waitingToLoad
.
delete
(
aBrowser
.
currentURI
.
spec
)
;
if
(
!
waitingToLoad
.
size
)
{
gBrowser
.
removeTabsProgressListener
(
listener
)
;
dump
(
"
Loads
complete
-
starting
tab
switches
\
n
"
)
;
resolve
(
)
;
}
}
}
}
;
gBrowser
.
addTabsProgressListener
(
listener
)
;
}
)
;
}
function
loadTPSContentScript
(
browser
)
{
return
new
Promise
(
(
resolve
)
=
>
{
let
script
=
function
(
)
{
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
let
cwu
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
let
lastTransactionId
=
cwu
.
lastTransactionId
;
Services
.
profiler
.
AddMarker
(
"
Content
waiting
for
id
>
"
+
lastTransactionId
)
;
addEventListener
(
"
MozAfterPaint
"
function
onPaint
(
event
)
{
Services
.
profiler
.
AddMarker
(
"
Content
saw
transaction
id
:
"
+
event
.
transactionId
)
;
if
(
event
.
transactionId
>
lastTransactionId
)
{
Services
.
profiler
.
AddMarker
(
"
Content
saw
correct
MozAfterPaint
"
)
;
let
time
=
Math
.
floor
(
content
.
performance
.
timing
.
navigationStart
+
content
.
performance
.
now
(
)
)
;
sendAsyncMessage
(
"
TPS
:
ContentSawPaint
"
{
time
}
)
;
removeEventListener
(
"
MozAfterPaint
"
onPaint
)
;
}
}
)
;
sendAsyncMessage
(
"
TPS
:
ContentReady
"
)
;
}
;
let
mm
=
browser
.
messageManager
;
mm
.
loadFrameScript
(
"
data
:
(
"
+
script
.
toString
(
)
+
"
)
(
)
;
"
true
)
;
mm
.
addMessageListener
(
"
TPS
:
ContentReady
"
function
onReady
(
)
{
mm
.
removeMessageListener
(
"
TPS
:
ContentReady
"
onReady
)
;
resolve
(
)
;
}
)
;
}
)
;
}
async
function
switchToTab
(
tab
)
{
let
browser
=
tab
.
linkedBrowser
;
let
gBrowser
=
tab
.
ownerGlobal
.
gBrowser
;
await
loadTPSContentScript
(
browser
)
;
let
start
=
Cu
.
now
(
)
;
let
switchDone
=
waitForTabSwitchDone
(
browser
)
;
let
finishPromise
=
waitForContentPresented
(
browser
)
;
gBrowser
.
selectedTab
=
tab
;
await
switchDone
;
let
finish
=
await
finishPromise
;
return
finish
-
start
;
}
function
waitForTabSwitchDone
(
browser
)
{
return
new
Promise
(
(
resolve
)
=
>
{
let
gBrowser
=
browser
.
ownerGlobal
.
gBrowser
;
gBrowser
.
addEventListener
(
"
TabSwitchDone
"
function
onTabSwitchDone
(
)
{
resolve
(
)
;
}
{
once
:
true
}
)
;
}
)
;
}
function
waitForContentPresented
(
browser
)
{
return
new
Promise
(
(
resolve
)
=
>
{
browser
.
addEventListener
(
"
MozLayerTreeReady
"
function
onLayersReady
(
event
)
{
let
now
=
Cu
.
now
(
)
;
TalosParentProfiler
.
mark
(
"
MozLayerTreeReady
seen
by
tps
"
)
;
resolve
(
now
)
;
}
{
once
:
true
}
)
;
}
)
;
}
function
forceGC
(
win
browser
)
{
browser
.
messageManager
.
loadFrameScript
(
"
chrome
:
/
/
pageloader
/
content
/
talos
-
content
.
js
"
false
)
;
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
garbageCollect
(
)
;
return
new
Promise
(
(
resolve
)
=
>
{
let
mm
=
browser
.
messageManager
;
mm
.
addMessageListener
(
"
Talos
:
ForceGC
:
OK
"
function
onTalosContentForceGC
(
msg
)
{
mm
.
removeMessageListener
(
"
Talos
:
ForceGC
:
OK
"
onTalosContentForceGC
)
;
resolve
(
)
;
}
)
;
mm
.
sendAsyncMessage
(
"
Talos
:
ForceGC
"
)
;
}
)
;
}
async
function
test
(
window
)
{
if
(
!
window
.
gMultiProcessBrowser
)
{
dump
(
"
*
*
The
TPS
Talos
test
does
not
support
running
in
non
-
e10s
mode
"
+
"
anymore
!
Bailing
out
!
\
n
"
)
;
return
;
}
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
talos
-
powers
-
content
/
content
/
TalosParentProfiler
.
js
"
context
)
;
TalosParentProfiler
=
context
.
TalosParentProfiler
;
let
testURLs
=
[
]
;
let
win
=
window
.
OpenBrowserWindow
(
)
;
try
{
let
prefFile
=
Services
.
prefs
.
getCharPref
(
"
addon
.
test
.
tabswitch
.
urlfile
"
)
;
if
(
prefFile
)
{
testURLs
=
handleFile
(
win
prefFile
)
;
}
}
catch
(
ex
)
{
}
if
(
!
testURLs
|
|
testURLs
.
length
=
=
0
)
{
dump
(
"
no
tabs
to
test
'
addon
.
test
.
tabswitch
.
urlfile
'
pref
isn
'
t
set
to
page
set
path
\
n
"
)
;
return
;
}
await
waitForDelayedStartup
(
win
)
;
let
gBrowser
=
win
.
gBrowser
;
gBrowser
.
tabContainer
.
style
.
opacity
=
"
0
"
;
let
initialTab
=
gBrowser
.
selectedTab
;
await
loadTabs
(
gBrowser
testURLs
)
;
initialTab
.
linkedBrowser
.
loadURI
(
"
about
:
blank
"
null
null
)
;
let
tabs
=
gBrowser
.
getTabsToTheEndFrom
(
initialTab
)
;
let
times
=
[
]
;
for
(
let
tab
of
tabs
)
{
await
switchToTab
(
tab
)
;
await
switchToTab
(
initialTab
)
;
}
for
(
let
tab
of
tabs
)
{
gBrowser
.
moveTabTo
(
tab
1
)
;
await
forceGC
(
win
tab
.
linkedBrowser
)
;
TalosParentProfiler
.
resume
(
"
start
:
"
+
tab
.
linkedBrowser
.
currentURI
.
spec
)
;
let
time
=
await
switchToTab
(
tab
)
;
TalosParentProfiler
.
pause
(
"
finish
:
"
+
tab
.
linkedBrowser
.
currentURI
.
spec
)
;
dump
(
{
tab
.
linkedBrowser
.
currentURI
.
spec
}
:
{
time
}
ms
\
n
)
;
times
.
push
(
time
)
;
await
switchToTab
(
initialTab
)
;
}
let
output
=
"
<
!
DOCTYPE
html
>
"
+
'
<
html
lang
=
"
en
"
>
'
+
"
<
head
>
<
title
>
Tab
Switch
Results
<
/
title
>
<
/
head
>
"
+
"
<
body
>
<
h1
>
Tab
switch
times
<
/
h1
>
"
+
"
<
table
>
"
;
let
time
=
0
;
for
(
let
i
in
times
)
{
time
+
=
times
[
i
]
;
output
+
=
"
<
tr
>
<
td
>
"
+
testURLs
[
i
]
+
"
<
/
td
>
<
td
>
"
+
times
[
i
]
+
"
ms
<
/
td
>
<
/
tr
>
"
;
}
output
+
=
"
<
/
table
>
<
/
body
>
<
/
html
>
"
;
dump
(
"
total
tab
switch
time
:
"
+
time
+
"
\
n
"
)
;
let
resultsTab
=
win
.
gBrowser
.
loadOneTab
(
"
data
:
text
/
html
;
charset
=
utf
-
8
"
+
encodeURIComponent
(
output
)
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
win
.
gBrowser
.
selectedTab
=
resultsTab
;
remotePage
.
sendAsyncMessage
(
"
tabswitch
-
test
-
results
"
{
times
urls
:
testURLs
}
)
;
TalosParentProfiler
.
afterProfileGathered
(
)
.
then
(
(
)
=
>
{
win
.
close
(
)
;
}
)
;
}
function
handleFile
(
win
file
)
{
let
localFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
localFile
.
initWithPath
(
file
)
;
let
localURI
=
Services
.
io
.
newFileURI
(
localFile
)
;
let
req
=
new
win
.
XMLHttpRequest
(
)
;
req
.
open
(
"
get
"
localURI
.
spec
false
)
;
req
.
send
(
null
)
;
let
testURLs
=
[
]
;
let
server
=
Services
.
prefs
.
getCharPref
(
"
addon
.
test
.
tabswitch
.
webserver
"
)
;
let
maxurls
=
Services
.
prefs
.
getIntPref
(
"
addon
.
test
.
tabswitch
.
maxurls
"
)
;
let
parent
=
server
+
"
/
tests
/
"
;
let
lines
=
req
.
responseText
.
split
(
'
<
a
href
=
\
"
'
)
;
testURLs
=
[
]
;
if
(
maxurls
&
&
maxurls
>
0
)
{
lines
.
splice
(
maxurls
lines
.
length
)
;
}
lines
.
forEach
(
function
(
a
)
{
if
(
a
.
split
(
'
\
"
'
)
[
0
]
!
=
"
"
)
{
testURLs
.
push
(
parent
+
"
tp5n
/
"
+
a
.
split
(
'
\
"
'
)
[
0
]
)
;
}
}
)
;
return
testURLs
;
}
var
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
tabswitch
-
urlfile
"
)
{
handleFile
(
aSubject
aData
)
;
}
}
}
;
var
remotePage
;
this
.
tps
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
return
{
tps
:
{
setup
(
{
frameScriptPath
}
)
{
const
AboutNewTabService
=
Cc
[
"
mozilla
.
org
/
browser
/
aboutnewtab
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAboutNewTabService
)
;
AboutNewTabService
.
newTabURL
=
"
about
:
blank
"
;
Services
.
obs
.
addObserver
(
observer
"
tabswitch
-
urlfile
"
)
;
const
frameScriptURL
=
context
.
extension
.
baseURI
.
resolve
(
frameScriptPath
)
;
Services
.
ppmm
.
loadFrameScript
(
frameScriptURL
true
)
;
remotePage
=
new
RemotePages
(
"
about
:
tabswitch
"
)
;
remotePage
.
addMessageListener
(
"
tabswitch
-
do
-
test
"
function
doTest
(
msg
)
{
test
(
msg
.
target
.
browser
.
ownerGlobal
)
;
}
)
;
return
(
)
=
>
{
Services
.
ppmm
.
sendAsyncMessage
(
"
TPS
:
Teardown
"
)
;
Services
.
obs
.
removeObserver
(
observer
"
tabswitch
-
urlfile
"
)
;
remotePage
.
destroy
(
)
;
AboutNewTabService
.
resetNewTabURL
(
)
;
}
;
}
}
}
;
}
}
;
