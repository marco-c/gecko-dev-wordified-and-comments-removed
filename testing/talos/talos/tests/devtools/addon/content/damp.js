const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
{
}
)
;
const
gMgr
=
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
require
"
function
(
)
{
let
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
return
require
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gDevTools
"
function
(
)
{
let
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
return
gDevTools
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
EVENTS
"
function
(
)
{
let
{
EVENTS
}
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
constants
"
)
;
return
EVENTS
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
TargetFactory
"
function
(
)
{
let
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
return
TargetFactory
;
}
)
;
const
webserver
=
Services
.
prefs
.
getCharPref
(
"
addon
.
test
.
damp
.
webserver
"
)
;
const
SIMPLE_URL
=
webserver
+
"
/
tests
/
devtools
/
addon
/
content
/
pages
/
simple
.
html
"
;
const
COMPLICATED_URL
=
webserver
+
"
/
tests
/
tp5n
/
bild
.
de
/
www
.
bild
.
de
/
index
.
html
"
;
const
CUSTOM_URL
=
webserver
+
"
/
tests
/
devtools
/
addon
/
content
/
pages
/
custom
/
TOOL
.
html
"
;
const
DEBUG_ALLOCATIONS
=
env
.
get
(
"
DEBUG_DEVTOOLS_ALLOCATIONS
"
)
;
function
getMostRecentBrowserWindow
(
)
{
return
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
}
function
getActiveTab
(
window
)
{
return
window
.
gBrowser
.
selectedTab
;
}
const
DEBUGGER_POLLING_INTERVAL
=
50
;
const
debuggerHelper
=
{
waitForState
(
dbg
predicate
msg
)
{
return
new
Promise
(
resolve
=
>
{
dump
(
Waiting
for
state
change
:
{
msg
}
\
n
)
;
if
(
predicate
(
dbg
.
store
.
getState
(
)
)
)
{
dump
(
Finished
waiting
for
state
change
:
{
msg
}
\
n
)
;
return
resolve
(
)
;
}
const
unsubscribe
=
dbg
.
store
.
subscribe
(
(
)
=
>
{
if
(
predicate
(
dbg
.
store
.
getState
(
)
)
)
{
dump
(
Finished
waiting
for
state
change
:
{
msg
}
\
n
)
;
unsubscribe
(
)
;
resolve
(
)
;
}
}
)
;
return
false
;
}
)
;
}
waitForDispatch
(
dbg
type
)
{
return
new
Promise
(
resolve
=
>
{
dbg
.
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
action
=
>
{
if
(
action
.
type
=
=
=
type
)
{
return
action
.
status
?
action
.
status
=
=
=
"
done
"
|
|
action
.
status
=
=
=
"
error
"
:
true
;
}
return
false
;
}
run
:
(
dispatch
getState
action
)
=
>
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
async
waitUntil
(
predicate
msg
)
{
dump
(
Waiting
until
:
{
msg
}
\
n
)
;
return
new
Promise
(
resolve
=
>
{
const
timer
=
setInterval
(
(
)
=
>
{
if
(
predicate
(
)
)
{
clearInterval
(
timer
)
;
dump
(
Finished
Waiting
until
:
{
msg
}
\
n
)
;
resolve
(
)
;
}
}
DEBUGGER_POLLING_INTERVAL
)
;
}
)
;
}
findSource
(
dbg
url
)
{
const
sources
=
dbg
.
selectors
.
getSources
(
dbg
.
getState
(
)
)
;
return
sources
.
find
(
s
=
>
(
s
.
get
(
"
url
"
)
|
|
"
"
)
.
includes
(
url
)
)
;
}
getCM
(
dbg
)
{
const
el
=
dbg
.
win
.
document
.
querySelector
(
"
.
CodeMirror
"
)
;
return
el
.
CodeMirror
;
}
waitForText
(
dbg
url
text
)
{
return
this
.
waitUntil
(
(
)
=
>
{
const
welcomebox
=
dbg
.
win
.
document
.
querySelector
(
"
.
welcomebox
"
)
;
if
(
welcomebox
)
{
return
false
;
}
const
cm
=
this
.
getCM
(
dbg
)
;
const
editorText
=
cm
.
doc
.
getValue
(
)
;
return
editorText
.
includes
(
text
)
;
}
"
text
is
visible
"
)
;
}
waitForMetaData
(
dbg
)
{
return
this
.
waitUntil
(
(
)
=
>
{
const
state
=
dbg
.
store
.
getState
(
)
;
const
source
=
dbg
.
selectors
.
getSelectedSource
(
state
)
;
const
metaData
=
dbg
.
selectors
.
getSourceMetaData
(
state
source
.
get
(
"
id
"
)
)
;
return
!
!
Object
.
keys
(
metaData
)
.
length
;
}
"
has
file
metadata
"
)
;
}
waitForSources
(
dbg
expectedSources
)
{
const
{
selectors
}
=
dbg
;
function
countSources
(
state
)
{
const
sources
=
selectors
.
getSources
(
state
)
;
return
sources
.
size
>
=
expectedSources
;
}
return
this
.
waitForState
(
dbg
countSources
"
count
sources
"
)
;
}
async
createContext
(
panel
)
{
const
{
store
selectors
actions
}
=
panel
.
getVarsForTests
(
)
;
return
{
actions
selectors
getState
:
store
.
getState
win
:
panel
.
panelWin
store
}
;
}
selectSource
(
dbg
url
)
{
dump
(
Selecting
source
:
{
url
}
\
n
)
;
const
line
=
1
;
const
source
=
this
.
findSource
(
dbg
url
)
;
dbg
.
actions
.
selectLocation
(
{
sourceId
:
source
.
get
(
"
id
"
)
line
}
)
;
return
this
.
waitForState
(
dbg
state
=
>
{
const
source
=
dbg
.
selectors
.
getSelectedSource
(
state
)
;
const
isLoaded
=
source
&
&
source
.
get
(
"
loadedState
"
)
=
=
=
"
loaded
"
;
if
(
!
isLoaded
)
{
return
false
;
}
return
dbg
.
selectors
.
hasSymbols
(
state
source
.
toJS
(
)
)
;
}
"
selected
source
"
)
;
}
}
;
async
function
garbageCollect
(
)
{
dump
(
"
Garbage
collect
\
n
"
)
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
Cu
.
forceGC
(
)
;
await
new
Promise
(
done
=
>
setTimeout
(
done
0
)
)
;
}
}
function
Damp
(
)
{
this
.
_heapSnapshotFilePath
=
null
;
this
.
_snapshot
=
null
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
webconsole
.
new
-
frontend
-
enabled
"
true
)
;
}
Damp
.
prototype
=
{
runTest
(
label
)
{
if
(
DEBUG_ALLOCATIONS
)
{
if
(
!
this
.
allocationTracker
)
{
this
.
allocationTracker
=
this
.
startAllocationTracker
(
)
;
}
this
.
allocationTracker
.
flushAllocations
(
)
;
}
let
startLabel
=
label
+
"
.
start
"
;
performance
.
mark
(
startLabel
)
;
let
start
=
performance
.
now
(
)
;
return
{
done
:
(
)
=
>
{
let
end
=
performance
.
now
(
)
;
let
duration
=
end
-
start
;
performance
.
measure
(
label
startLabel
)
;
this
.
_results
.
push
(
{
name
:
label
value
:
duration
}
)
;
if
(
DEBUG_ALLOCATIONS
=
=
"
normal
"
)
{
this
.
_results
.
push
(
{
name
:
label
+
"
.
allocations
"
value
:
this
.
allocationTracker
.
countAllocations
(
)
}
)
;
}
else
if
(
DEBUG_ALLOCATIONS
=
=
"
verbose
"
)
{
this
.
allocationTracker
.
logAllocationSites
(
)
;
}
}
}
;
}
addTab
(
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
tab
=
this
.
_win
.
gBrowser
.
selectedTab
=
this
.
_win
.
gBrowser
.
addTab
(
url
)
;
let
browser
=
tab
.
linkedBrowser
;
browser
.
addEventListener
(
"
load
"
function
onload
(
)
{
resolve
(
tab
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
)
;
}
async
closeCurrentTab
(
)
{
let
onTransition
=
new
Promise
(
done
=
>
{
this
.
_win
.
gBrowser
.
tabContainer
.
addEventListener
(
"
transitionend
"
done
{
once
:
true
}
)
;
}
)
;
this
.
_win
.
BrowserCloseTabOrWindow
(
)
;
await
onTransition
;
return
this
.
_win
.
gBrowser
.
selectedTab
;
}
reloadPage
(
onReload
)
{
return
new
Promise
(
resolve
=
>
{
let
browser
=
gBrowser
.
selectedBrowser
;
if
(
typeof
(
onReload
)
=
=
"
function
"
)
{
onReload
(
)
.
then
(
resolve
)
;
}
else
{
browser
.
addEventListener
(
"
load
"
resolve
{
capture
:
true
once
:
true
}
)
;
}
browser
.
reload
(
)
;
}
)
;
}
async
openToolbox
(
tool
=
"
webconsole
"
onLoad
)
{
let
tab
=
getActiveTab
(
getMostRecentBrowserWindow
(
)
)
;
let
target
=
TargetFactory
.
forTab
(
tab
)
;
let
onToolboxCreated
=
gDevTools
.
once
(
"
toolbox
-
created
"
)
;
let
showPromise
=
gDevTools
.
showToolbox
(
target
tool
)
;
let
toolbox
=
await
onToolboxCreated
;
if
(
typeof
(
onLoad
)
=
=
"
function
"
)
{
let
panel
=
await
toolbox
.
getPanelWhenReady
(
tool
)
;
await
onLoad
(
toolbox
panel
)
;
}
await
showPromise
;
return
toolbox
;
}
async
closeToolbox
(
)
{
let
tab
=
getActiveTab
(
getMostRecentBrowserWindow
(
)
)
;
let
target
=
TargetFactory
.
forTab
(
tab
)
;
await
target
.
client
.
waitForRequestsToSettle
(
)
;
await
gDevTools
.
closeToolbox
(
target
)
;
}
async
saveHeapSnapshot
(
label
)
{
let
tab
=
getActiveTab
(
getMostRecentBrowserWindow
(
)
)
;
let
target
=
TargetFactory
.
forTab
(
tab
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
let
panel
=
toolbox
.
getCurrentPanel
(
)
;
let
memoryFront
=
panel
.
panelWin
.
gFront
;
let
test
=
this
.
runTest
(
label
+
"
.
saveHeapSnapshot
"
)
;
this
.
_heapSnapshotFilePath
=
await
memoryFront
.
saveHeapSnapshot
(
)
;
test
.
done
(
)
;
}
readHeapSnapshot
(
label
)
{
let
test
=
this
.
runTest
(
label
+
"
.
readHeapSnapshot
"
)
;
this
.
_snapshot
=
ChromeUtils
.
readHeapSnapshot
(
this
.
_heapSnapshotFilePath
)
;
test
.
done
(
)
;
return
Promise
.
resolve
(
)
;
}
async
waitForNetworkRequests
(
label
toolbox
expectedRequests
)
{
let
test
=
this
.
runTest
(
label
+
"
.
requestsFinished
.
DAMP
"
)
;
await
this
.
waitForAllRequestsFinished
(
expectedRequests
)
;
test
.
done
(
)
;
}
async
_consoleBulkLoggingTest
(
)
{
let
TOTAL_MESSAGES
=
10
;
let
tab
=
await
this
.
testSetup
(
SIMPLE_URL
)
;
let
messageManager
=
tab
.
linkedBrowser
.
messageManager
;
let
toolbox
=
await
this
.
openToolbox
(
"
webconsole
"
)
;
let
webconsole
=
toolbox
.
getPanel
(
"
webconsole
"
)
;
let
allMessagesReceived
=
new
Promise
(
resolve
=
>
{
function
receiveMessages
(
e
messages
)
{
for
(
let
m
of
messages
)
{
if
(
m
.
node
.
textContent
.
includes
(
"
damp
"
+
TOTAL_MESSAGES
)
)
{
webconsole
.
hud
.
ui
.
off
(
"
new
-
messages
"
receiveMessages
)
;
requestAnimationFrame
(
resolve
)
;
}
}
}
webconsole
.
hud
.
ui
.
on
(
"
new
-
messages
"
receiveMessages
)
;
}
)
;
messageManager
.
loadFrameScript
(
"
data
:
(
"
+
encodeURIComponent
(
function
(
)
{
addMessageListener
(
"
do
-
logs
"
function
(
)
{
for
(
var
i
=
0
;
i
<
{
TOTAL_MESSAGES
}
;
i
+
+
)
{
content
.
console
.
log
(
'
damp
'
i
+
1
content
)
;
}
}
)
;
}
)
+
"
)
(
)
"
true
)
;
messageManager
.
sendAsyncMessage
(
"
do
-
logs
"
)
;
let
test
=
this
.
runTest
(
"
console
.
bulklog
"
)
;
await
allMessagesReceived
;
test
.
done
(
)
;
await
this
.
closeToolbox
(
)
;
await
this
.
testTeardown
(
)
;
}
async
_consoleStreamLoggingTest
(
)
{
let
TOTAL_MESSAGES
=
100
;
let
tab
=
await
this
.
testSetup
(
SIMPLE_URL
)
;
let
messageManager
=
tab
.
linkedBrowser
.
messageManager
;
await
this
.
openToolbox
(
"
webconsole
"
)
;
messageManager
.
loadFrameScript
(
"
data
:
(
"
+
encodeURIComponent
(
function
(
)
{
let
count
=
0
;
let
startTime
=
content
.
performance
.
now
(
)
;
function
log
(
)
{
if
(
+
+
count
<
{
TOTAL_MESSAGES
}
)
{
content
.
document
.
querySelector
(
"
h1
"
)
.
textContent
+
=
count
+
"
\
\
n
"
;
content
.
console
.
log
(
'
damp
'
count
content
content
.
document
content
.
document
.
body
content
.
document
.
documentElement
new
Array
(
100
)
.
join
(
"
DAMP
?
DAMP
!
"
)
)
;
content
.
requestAnimationFrame
(
log
)
;
}
else
{
let
avgTime
=
(
content
.
performance
.
now
(
)
-
startTime
)
/
{
TOTAL_MESSAGES
}
;
sendSyncMessage
(
"
done
"
Math
.
round
(
avgTime
)
)
;
}
}
log
(
)
;
}
)
+
"
)
(
)
"
true
)
;
let
avgTime
=
await
new
Promise
(
resolve
=
>
{
messageManager
.
addMessageListener
(
"
done
"
(
e
)
=
>
{
resolve
(
e
.
data
)
;
}
)
;
}
)
;
this
.
_results
.
push
(
{
name
:
"
console
.
streamlog
"
value
:
avgTime
}
)
;
await
this
.
closeToolbox
(
)
;
await
this
.
testTeardown
(
)
;
}
async
_consoleObjectExpansionTest
(
)
{
let
tab
=
await
this
.
testSetup
(
SIMPLE_URL
)
;
let
messageManager
=
tab
.
linkedBrowser
.
messageManager
;
let
toolbox
=
await
this
.
openToolbox
(
"
webconsole
"
)
;
let
webconsole
=
toolbox
.
getPanel
(
"
webconsole
"
)
;
let
onMessageReceived
=
new
Promise
(
resolve
=
>
{
function
receiveMessages
(
e
messages
)
{
for
(
let
m
of
messages
)
{
resolve
(
m
)
;
}
}
webconsole
.
hud
.
ui
.
once
(
"
new
-
messages
"
receiveMessages
)
;
}
)
;
messageManager
.
loadFrameScript
(
"
data
:
(
"
+
encodeURIComponent
(
function
(
)
{
addMessageListener
(
"
do
-
dir
"
function
(
)
{
content
.
console
.
dir
(
Array
.
from
(
{
length
:
1000
}
)
.
reduce
(
(
res
_
i
)
=
>
{
res
[
"
item_
"
+
i
]
=
i
;
return
res
;
}
{
}
)
)
;
}
)
;
}
)
+
"
)
(
)
"
true
)
;
messageManager
.
sendAsyncMessage
(
"
do
-
dir
"
)
;
let
test
=
this
.
runTest
(
"
console
.
objectexpand
"
)
;
await
onMessageReceived
;
const
tree
=
webconsole
.
hud
.
ui
.
outputNode
.
querySelector
(
"
.
dir
.
message
.
tree
"
)
;
if
(
tree
.
querySelectorAll
(
"
.
node
"
)
.
length
=
=
=
1
)
{
await
new
Promise
(
resolve
=
>
{
const
observer
=
new
MutationObserver
(
mutations
=
>
{
resolve
(
mutations
)
;
observer
.
disconnect
(
)
;
}
)
;
observer
.
observe
(
tree
{
childList
:
true
}
)
;
}
)
;
}
test
.
done
(
)
;
await
this
.
closeToolboxAndLog
(
"
console
.
objectexpanded
"
toolbox
)
;
await
this
.
testTeardown
(
)
;
}
async
_consoleOpenWithCachedMessagesTest
(
)
{
let
TOTAL_MESSAGES
=
100
;
let
tab
=
await
this
.
testSetup
(
SIMPLE_URL
)
;
tab
.
linkedBrowser
.
messageManager
.
loadFrameScript
(
"
data
:
(
"
+
encodeURIComponent
(
function
(
)
{
for
(
var
i
=
0
;
i
<
{
TOTAL_MESSAGES
}
;
i
+
+
)
{
content
.
console
.
log
(
'
damp
'
i
+
1
content
)
;
}
}
)
+
"
)
(
)
"
true
)
;
await
this
.
openToolboxAndLog
(
"
console
.
openwithcache
"
"
webconsole
"
)
;
await
this
.
closeToolbox
(
)
;
await
this
.
testTeardown
(
)
;
}
async
_inspectorMutationsTest
(
)
{
let
tab
=
await
this
.
testSetup
(
SIMPLE_URL
)
;
let
messageManager
=
tab
.
linkedBrowser
.
messageManager
;
let
toolbox
=
await
this
.
openToolbox
(
"
inspector
"
)
;
let
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
const
LIMIT
=
100
;
const
DELAY
=
5
;
messageManager
.
loadFrameScript
(
"
data
:
(
"
+
encodeURIComponent
(
function
(
)
{
const
LIMIT
=
{
LIMIT
}
;
addMessageListener
(
"
start
-
mutations
-
test
"
function
(
)
{
let
addElement
=
function
(
index
)
{
if
(
index
=
=
LIMIT
)
{
/
/
LIMIT
was
reached
stop
adding
elements
.
return
;
}
let
div
=
content
.
document
.
createElement
(
"
div
"
)
;
content
.
document
.
body
.
appendChild
(
div
)
;
content
.
setTimeout
(
(
)
=
>
addElement
(
index
+
1
)
{
DELAY
}
)
;
}
;
addElement
(
0
)
;
}
)
;
}
)
+
"
)
(
)
"
false
)
;
let
test
=
this
.
runTest
(
"
inspector
.
mutations
"
)
;
await
new
Promise
(
resolve
=
>
{
let
childListMutationsCounter
=
0
;
inspector
.
on
(
"
markupmutation
"
(
evt
mutations
)
=
>
{
let
childListMutations
=
mutations
.
filter
(
m
=
>
m
.
type
=
=
=
"
childList
"
)
;
childListMutationsCounter
+
=
childListMutations
.
length
;
if
(
childListMutationsCounter
=
=
=
LIMIT
)
{
resolve
(
)
;
}
}
)
;
messageManager
.
sendAsyncMessage
(
"
start
-
mutations
-
test
"
)
;
}
)
;
test
.
done
(
)
;
await
this
.
closeToolbox
(
)
;
await
this
.
testTeardown
(
)
;
}
async
_inspectorLayoutTest
(
)
{
let
tab
=
await
this
.
testSetup
(
SIMPLE_URL
)
;
let
messageManager
=
tab
.
linkedBrowser
.
messageManager
;
let
sidebarTab
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
)
;
Services
.
prefs
.
setCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
"
layoutview
"
)
;
await
new
Promise
(
resolve
=
>
{
messageManager
.
addMessageListener
(
"
setup
-
test
-
done
"
resolve
)
;
const
NODES
=
5000
;
const
GRID_NODES
=
10
;
messageManager
.
loadFrameScript
(
"
data
:
(
"
+
encodeURIComponent
(
function
(
)
{
let
div
=
content
.
document
.
createElement
(
"
div
"
)
;
div
.
innerHTML
=
new
Array
(
{
NODES
}
)
.
join
(
"
<
div
>
<
/
div
>
"
)
+
new
Array
(
{
GRID_NODES
}
)
.
join
(
"
<
div
style
=
'
display
:
grid
'
>
<
/
div
>
"
)
;
content
.
document
.
body
.
appendChild
(
div
)
;
sendSyncMessage
(
"
setup
-
test
-
done
"
)
;
}
)
+
"
)
(
)
"
false
)
;
}
)
;
let
start
=
performance
.
now
(
)
;
await
this
.
openToolbox
(
"
inspector
"
)
;
this
.
_results
.
push
(
{
name
:
"
inspector
.
layout
.
open
"
value
:
performance
.
now
(
)
-
start
}
)
;
await
this
.
closeToolbox
(
)
;
Services
.
prefs
.
setCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
sidebarTab
)
;
await
this
.
testTeardown
(
)
;
}
takeCensus
(
label
)
{
let
test
=
this
.
runTest
(
label
+
"
.
takeCensus
"
)
;
this
.
_snapshot
.
takeCensus
(
{
breakdown
:
{
by
:
"
coarseType
"
objects
:
{
by
:
"
objectClass
"
then
:
{
by
:
"
count
"
bytes
:
true
count
:
true
}
other
:
{
by
:
"
count
"
bytes
:
true
count
:
true
}
}
strings
:
{
by
:
"
internalType
"
then
:
{
by
:
"
count
"
bytes
:
true
count
:
true
}
}
scripts
:
{
by
:
"
internalType
"
then
:
{
by
:
"
count
"
bytes
:
true
count
:
true
}
}
other
:
{
by
:
"
internalType
"
then
:
{
by
:
"
count
"
bytes
:
true
count
:
true
}
}
}
}
)
;
test
.
done
(
)
;
return
Promise
.
resolve
(
)
;
}
async
waitForPendingPaints
(
toolbox
)
{
let
panel
=
toolbox
.
getCurrentPanel
(
)
;
let
window
=
panel
.
panelWin
|
|
panel
.
_frameWindow
|
|
panel
.
panelWindow
;
let
utils
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
window
.
performance
.
mark
(
"
pending
paints
.
start
"
)
;
while
(
utils
.
isMozAfterPaintPending
)
{
await
new
Promise
(
done
=
>
{
window
.
addEventListener
(
"
MozAfterPaint
"
function
listener
(
)
{
window
.
performance
.
mark
(
"
pending
paint
"
)
;
done
(
)
;
}
{
once
:
true
}
)
;
}
)
;
}
window
.
performance
.
measure
(
"
pending
paints
"
"
pending
paints
.
start
"
)
;
}
async
openToolboxAndLog
(
name
tool
onLoad
)
{
dump
(
"
Open
toolbox
on
'
"
+
name
+
"
'
\
n
"
)
;
let
test
=
this
.
runTest
(
name
+
"
.
open
.
DAMP
"
)
;
let
toolbox
=
await
this
.
openToolbox
(
tool
onLoad
)
;
test
.
done
(
)
;
test
=
this
.
runTest
(
name
+
"
.
open
.
settle
.
DAMP
"
)
;
await
this
.
waitForPendingPaints
(
toolbox
)
;
test
.
done
(
)
;
await
garbageCollect
(
)
;
return
toolbox
;
}
async
closeToolboxAndLog
(
name
toolbox
)
{
let
{
target
}
=
toolbox
;
dump
(
"
Close
toolbox
on
'
"
+
name
+
"
'
\
n
"
)
;
await
target
.
client
.
waitForRequestsToSettle
(
)
;
let
test
=
this
.
runTest
(
name
+
"
.
close
.
DAMP
"
)
;
await
gDevTools
.
closeToolbox
(
target
)
;
test
.
done
(
)
;
}
async
reloadPageAndLog
(
name
toolbox
onReload
)
{
dump
(
"
Reload
page
on
'
"
+
name
+
"
'
\
n
"
)
;
let
test
=
this
.
runTest
(
name
+
"
.
reload
.
DAMP
"
)
;
await
this
.
reloadPage
(
onReload
)
;
test
.
done
(
)
;
test
=
this
.
runTest
(
name
+
"
.
reload
.
settle
.
DAMP
"
)
;
await
this
.
waitForPendingPaints
(
toolbox
)
;
test
.
done
(
)
;
}
async
_coldInspectorOpen
(
)
{
await
this
.
testSetup
(
SIMPLE_URL
)
;
await
this
.
openToolboxAndLog
(
"
cold
.
inspector
"
"
inspector
"
)
;
await
this
.
closeToolbox
(
)
;
await
this
.
testTeardown
(
)
;
}
async
_panelsInBackgroundReload
(
)
{
let
url
=
"
data
:
text
/
html
;
charset
=
UTF
-
8
"
+
encodeURIComponent
(
<
script
>
/
/
Log
a
significant
amount
of
messages
for
(
let
i
=
0
;
i
<
2000
;
i
+
+
)
{
console
.
log
(
"
log
in
background
"
i
)
;
}
<
/
script
>
)
;
await
this
.
testSetup
(
url
)
;
let
toolbox
=
await
this
.
openToolbox
(
"
webconsole
"
)
;
await
toolbox
.
selectTool
(
"
options
"
)
;
await
this
.
reloadPageAndLog
(
"
panelsInBackground
"
toolbox
)
;
await
this
.
closeToolbox
(
)
;
await
this
.
testTeardown
(
)
;
}
async
reloadInspectorAndLog
(
label
toolbox
)
{
let
onReload
=
async
function
(
)
{
let
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
await
inspector
.
once
(
"
new
-
root
"
)
;
await
inspector
.
once
(
"
inspector
-
updated
"
)
;
}
;
await
this
.
reloadPageAndLog
(
label
+
"
.
inspector
"
toolbox
onReload
)
;
}
async
customInspector
(
)
{
let
url
=
CUSTOM_URL
.
replace
(
/
\
TOOL
/
"
inspector
"
)
;
await
this
.
testSetup
(
url
)
;
let
toolbox
=
await
this
.
openToolboxAndLog
(
"
custom
.
inspector
"
"
inspector
"
)
;
await
this
.
reloadInspectorAndLog
(
"
custom
"
toolbox
)
;
await
this
.
closeToolboxAndLog
(
"
custom
.
inspector
"
toolbox
)
;
await
this
.
testTeardown
(
)
;
}
async
openDebuggerAndLog
(
label
expectedSources
selectedFile
expectedText
)
{
const
onLoad
=
async
(
toolbox
panel
)
=
>
{
const
dbg
=
await
debuggerHelper
.
createContext
(
panel
)
;
await
debuggerHelper
.
waitForSources
(
dbg
expectedSources
)
;
await
debuggerHelper
.
selectSource
(
dbg
selectedFile
)
;
await
debuggerHelper
.
waitForText
(
dbg
selectedFile
expectedText
)
;
await
debuggerHelper
.
waitForMetaData
(
dbg
)
;
}
;
const
toolbox
=
await
this
.
openToolboxAndLog
(
label
+
"
.
jsdebugger
"
"
jsdebugger
"
onLoad
)
;
return
toolbox
;
}
async
reloadDebuggerAndLog
(
label
toolbox
expectedSources
selectedFile
expectedText
)
{
const
onReload
=
async
(
)
=
>
{
const
panel
=
await
toolbox
.
getPanelWhenReady
(
"
jsdebugger
"
)
;
const
dbg
=
await
debuggerHelper
.
createContext
(
panel
)
;
await
debuggerHelper
.
waitForDispatch
(
dbg
"
NAVIGATE
"
)
;
await
debuggerHelper
.
waitForSources
(
dbg
expectedSources
)
;
await
debuggerHelper
.
waitForText
(
dbg
selectedFile
expectedText
)
;
await
debuggerHelper
.
waitForMetaData
(
dbg
)
;
}
;
await
this
.
reloadPageAndLog
(
{
label
}
.
jsdebugger
toolbox
onReload
)
;
}
async
customDebugger
(
)
{
const
label
=
"
custom
"
;
const
expectedSources
=
7
;
let
url
=
CUSTOM_URL
.
replace
(
/
\
TOOL
/
"
debugger
/
index
"
)
;
await
this
.
testSetup
(
url
)
;
const
selectedFile
=
"
App
.
js
"
;
const
expectedText
=
"
import
React
{
Component
}
from
'
react
'
;
"
;
const
toolbox
=
await
this
.
openDebuggerAndLog
(
label
expectedSources
selectedFile
expectedText
)
;
await
this
.
reloadDebuggerAndLog
(
label
toolbox
expectedSources
selectedFile
expectedText
)
;
await
this
.
closeToolboxAndLog
(
"
custom
.
jsdebugger
"
toolbox
)
;
await
this
.
testTeardown
(
)
;
}
async
reloadConsoleAndLog
(
label
toolbox
expectedMessages
)
{
let
onReload
=
async
function
(
)
{
let
webconsole
=
toolbox
.
getPanel
(
"
webconsole
"
)
;
await
new
Promise
(
done
=
>
{
let
messages
=
0
;
let
receiveMessages
=
(
)
=
>
{
if
(
+
+
messages
=
=
expectedMessages
)
{
webconsole
.
hud
.
ui
.
off
(
"
new
-
messages
"
receiveMessages
)
;
done
(
)
;
}
}
;
webconsole
.
hud
.
ui
.
on
(
"
new
-
messages
"
receiveMessages
)
;
}
)
;
}
;
await
this
.
reloadPageAndLog
(
label
+
"
.
webconsole
"
toolbox
onReload
)
;
}
async
customConsole
(
)
{
let
sync
=
250
stream
=
250
async
=
250
;
let
page
=
console
.
html
?
sync
=
{
sync
}
&
stream
=
{
stream
}
&
async
=
{
async
}
;
let
url
=
CUSTOM_URL
.
replace
(
/
\
TOOL
\
.
html
/
page
)
;
await
this
.
testSetup
(
url
)
;
let
toolbox
=
await
this
.
openToolboxAndLog
(
"
custom
.
webconsole
"
"
webconsole
"
)
;
await
this
.
reloadConsoleAndLog
(
"
custom
"
toolbox
sync
+
stream
+
async
)
;
await
this
.
closeToolboxAndLog
(
"
custom
.
webconsole
"
toolbox
)
;
await
this
.
testTeardown
(
)
;
}
_getToolLoadingTests
(
url
label
{
expectedMessages
expectedRequests
expectedSources
selectedFile
expectedText
}
)
{
let
tests
=
{
async
inspector
(
)
{
await
this
.
testSetup
(
url
)
;
let
toolbox
=
await
this
.
openToolboxAndLog
(
label
+
"
.
inspector
"
"
inspector
"
)
;
await
this
.
reloadInspectorAndLog
(
label
toolbox
)
;
await
this
.
closeToolboxAndLog
(
label
+
"
.
inspector
"
toolbox
)
;
await
this
.
testTeardown
(
)
;
}
async
webconsole
(
)
{
await
this
.
testSetup
(
url
)
;
let
toolbox
=
await
this
.
openToolboxAndLog
(
label
+
"
.
webconsole
"
"
webconsole
"
)
;
await
this
.
reloadConsoleAndLog
(
label
toolbox
expectedMessages
)
;
await
this
.
closeToolboxAndLog
(
label
+
"
.
webconsole
"
toolbox
)
;
await
this
.
testTeardown
(
)
;
}
async
debugger
(
)
{
await
this
.
testSetup
(
url
)
;
let
toolbox
=
await
this
.
openDebuggerAndLog
(
label
expectedSources
selectedFile
expectedText
)
;
await
this
.
reloadDebuggerAndLog
(
label
toolbox
expectedSources
selectedFile
expectedText
)
;
await
this
.
closeToolboxAndLog
(
label
+
"
.
jsdebugger
"
toolbox
)
;
await
this
.
testTeardown
(
)
;
}
async
styleeditor
(
)
{
await
this
.
testSetup
(
url
)
;
const
toolbox
=
await
this
.
openToolboxAndLog
(
label
+
"
.
styleeditor
"
"
styleeditor
"
)
;
await
this
.
reloadPageAndLog
(
label
+
"
.
styleeditor
"
toolbox
)
;
await
this
.
closeToolboxAndLog
(
label
+
"
.
styleeditor
"
toolbox
)
;
await
this
.
testTeardown
(
)
;
}
async
performance
(
)
{
await
this
.
testSetup
(
url
)
;
const
toolbox
=
await
this
.
openToolboxAndLog
(
label
+
"
.
performance
"
"
performance
"
)
;
await
this
.
reloadPageAndLog
(
label
+
"
.
performance
"
toolbox
)
;
await
this
.
closeToolboxAndLog
(
label
+
"
.
performance
"
toolbox
)
;
await
this
.
testTeardown
(
)
;
}
async
netmonitor
(
)
{
await
this
.
testSetup
(
url
)
;
const
toolbox
=
await
this
.
openToolboxAndLog
(
label
+
"
.
netmonitor
"
"
netmonitor
"
)
;
const
requestsDone
=
this
.
waitForNetworkRequests
(
label
+
"
.
netmonitor
"
toolbox
expectedRequests
)
;
await
this
.
reloadPageAndLog
(
label
+
"
.
netmonitor
"
toolbox
)
;
await
requestsDone
;
await
this
.
closeToolboxAndLog
(
label
+
"
.
netmonitor
"
toolbox
)
;
await
this
.
testTeardown
(
)
;
}
async
saveAndReadHeapSnapshot
(
)
{
await
this
.
testSetup
(
url
)
;
const
toolbox
=
await
this
.
openToolboxAndLog
(
label
+
"
.
memory
"
"
memory
"
)
;
await
this
.
reloadPageAndLog
(
label
+
"
.
memory
"
toolbox
)
;
await
this
.
saveHeapSnapshot
(
label
)
;
await
this
.
readHeapSnapshot
(
label
)
;
await
this
.
takeCensus
(
label
)
;
await
this
.
closeToolboxAndLog
(
label
+
"
.
memory
"
toolbox
)
;
await
this
.
testTeardown
(
)
;
}
}
;
for
(
let
name
in
tests
)
{
tests
[
label
+
"
.
"
+
name
]
=
tests
[
name
]
;
delete
tests
[
name
]
;
}
return
tests
;
}
async
testSetup
(
url
)
{
let
tab
=
await
this
.
addTab
(
url
)
;
await
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
this
.
_config
.
rest
)
;
}
)
;
return
tab
;
}
async
testTeardown
(
url
)
{
await
this
.
closeCurrentTab
(
)
;
await
garbageCollect
(
)
;
this
.
_nextCommand
(
)
;
}
_win
:
undefined
_dampTab
:
undefined
_results
:
[
]
_config
:
{
subtests
:
[
]
repeat
:
1
rest
:
100
}
_nextCommandIx
:
0
_commands
:
[
]
_onSequenceComplete
:
0
_nextCommand
(
)
{
if
(
this
.
_nextCommandIx
>
=
this
.
_commands
.
length
)
{
this
.
_onSequenceComplete
(
)
;
return
;
}
this
.
_commands
[
this
.
_nextCommandIx
+
+
]
.
call
(
this
)
;
}
_doSequence
(
commands
onComplete
)
{
this
.
_commands
=
commands
;
this
.
_onSequenceComplete
=
onComplete
;
this
.
_results
=
[
]
;
this
.
_nextCommandIx
=
0
;
this
.
_nextCommand
(
)
;
}
_log
(
str
)
{
if
(
window
.
MozillaFileLogger
&
&
window
.
MozillaFileLogger
.
log
)
window
.
MozillaFileLogger
.
log
(
str
)
;
window
.
dump
(
str
)
;
}
_logLine
(
str
)
{
return
this
.
_log
(
str
+
"
\
n
"
)
;
}
_reportAllResults
(
)
{
var
testNames
=
[
]
;
var
testResults
=
[
]
;
var
out
=
"
"
;
for
(
var
i
in
this
.
_results
)
{
res
=
this
.
_results
[
i
]
;
var
disp
=
[
]
.
concat
(
res
.
value
)
.
map
(
function
(
a
)
{
return
(
isNaN
(
a
)
?
-
1
:
a
.
toFixed
(
1
)
)
;
}
)
.
join
(
"
"
)
;
out
+
=
res
.
name
+
"
:
"
+
disp
+
"
\
n
"
;
if
(
!
Array
.
isArray
(
res
.
value
)
)
{
testNames
.
push
(
res
.
name
)
;
testResults
.
push
(
res
.
value
)
;
}
}
this
.
_log
(
"
\
n
"
+
out
)
;
if
(
content
&
&
content
.
tpRecordTime
)
{
content
.
tpRecordTime
(
testResults
.
join
(
"
"
)
0
testNames
.
join
(
"
"
)
)
;
}
else
{
}
}
_onTestComplete
:
null
_doneInternal
(
)
{
if
(
this
.
allocationTracker
)
{
this
.
allocationTracker
.
stop
(
)
;
this
.
allocationTracker
=
null
;
}
this
.
_logLine
(
"
DAMP_RESULTS_JSON
=
"
+
JSON
.
stringify
(
this
.
_results
)
)
;
this
.
_reportAllResults
(
)
;
this
.
_win
.
gBrowser
.
selectedTab
=
this
.
_dampTab
;
if
(
this
.
_onTestComplete
)
{
this
.
_onTestComplete
(
JSON
.
parse
(
JSON
.
stringify
(
this
.
_results
)
)
)
;
}
}
waitForAllRequestsFinished
(
expectedRequests
)
{
let
tab
=
getActiveTab
(
getMostRecentBrowserWindow
(
)
)
;
let
target
=
TargetFactory
.
forTab
(
tab
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
let
window
=
toolbox
.
getCurrentPanel
(
)
.
panelWin
;
return
new
Promise
(
resolve
=
>
{
let
payloadReady
=
0
;
let
timingsUpdated
=
0
;
function
onPayloadReady
(
_
id
)
{
payloadReady
+
+
;
maybeResolve
(
)
;
}
function
onTimingsUpdated
(
_
id
)
{
timingsUpdated
+
+
;
maybeResolve
(
)
;
}
function
maybeResolve
(
)
{
if
(
payloadReady
=
=
=
expectedRequests
&
&
timingsUpdated
=
=
=
expectedRequests
)
{
window
.
off
(
EVENTS
.
PAYLOAD_READY
onPayloadReady
)
;
window
.
off
(
EVENTS
.
RECEIVED_EVENT_TIMINGS
onTimingsUpdated
)
;
resolve
(
)
;
}
}
window
.
on
(
EVENTS
.
PAYLOAD_READY
onPayloadReady
)
;
window
.
on
(
EVENTS
.
RECEIVED_EVENT_TIMINGS
onTimingsUpdated
)
;
}
)
;
}
startAllocationTracker
(
)
{
const
{
allocationTracker
}
=
require
(
"
devtools
/
shared
/
test
-
helpers
/
allocation
-
tracker
"
)
;
return
allocationTracker
(
)
;
}
startTest
(
doneCallback
config
)
{
this
.
_onTestComplete
=
function
(
results
)
{
TalosParentProfiler
.
pause
(
"
DAMP
-
end
"
)
;
doneCallback
(
results
)
;
}
;
this
.
_config
=
config
;
var
wm
=
Components
.
classes
[
"
mozilla
.
org
/
appshell
/
window
-
mediator
;
1
"
]
.
getService
(
Ci
.
nsIWindowMediator
)
;
this
.
_win
=
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
this
.
_dampTab
=
this
.
_win
.
gBrowser
.
selectedTab
;
this
.
_win
.
gBrowser
.
selectedBrowser
.
focus
(
)
;
TalosParentProfiler
.
resume
(
"
DAMP
-
start
"
)
;
let
tests
=
{
}
;
let
topWindow
=
getMostRecentBrowserWindow
(
)
;
if
(
!
topWindow
.
coldRunDAMP
)
{
topWindow
.
coldRunDAMP
=
true
;
tests
[
"
cold
.
inspector
"
]
=
this
.
_coldInspectorOpen
;
}
tests
[
"
panelsInBackground
.
reload
"
]
=
this
.
_panelsInBackgroundReload
;
Object
.
assign
(
tests
this
.
_getToolLoadingTests
(
SIMPLE_URL
"
simple
"
{
expectedMessages
:
1
expectedRequests
:
1
expectedSources
:
1
selectedFile
:
"
simple
.
html
"
expectedText
:
"
This
is
a
simple
page
"
}
)
)
;
Object
.
assign
(
tests
this
.
_getToolLoadingTests
(
COMPLICATED_URL
"
complicated
"
{
expectedMessages
:
7
expectedRequests
:
280
expectedSources
:
14
selectedFile
:
"
ga
.
js
"
expectedText
:
"
Math
;
function
ga
(
a
b
)
{
return
a
.
name
=
b
}
"
}
)
)
;
tests
[
"
custom
.
inspector
"
]
=
this
.
customInspector
;
tests
[
"
custom
.
debugger
"
]
=
this
.
customDebugger
;
tests
[
"
custom
.
webconsole
"
]
=
this
.
customConsole
;
tests
[
"
console
.
bulklog
"
]
=
this
.
_consoleBulkLoggingTest
;
tests
[
"
console
.
streamlog
"
]
=
this
.
_consoleStreamLoggingTest
;
tests
[
"
console
.
objectexpand
"
]
=
this
.
_consoleObjectExpansionTest
;
tests
[
"
console
.
openwithcache
"
]
=
this
.
_consoleOpenWithCachedMessagesTest
;
tests
[
"
inspector
.
mutations
"
]
=
this
.
_inspectorMutationsTest
;
tests
[
"
inspector
.
layout
"
]
=
this
.
_inspectorLayoutTest
;
let
filter
=
Services
.
prefs
.
getCharPref
(
"
talos
.
subtests
"
"
"
)
;
if
(
filter
)
{
for
(
let
name
in
tests
)
{
if
(
!
name
.
includes
(
filter
)
)
{
delete
tests
[
name
]
;
}
}
if
(
Object
.
keys
(
tests
)
.
length
=
=
0
)
{
dump
(
"
ERROR
:
Unable
to
find
any
test
matching
'
"
+
filter
+
"
'
\
n
"
)
;
this
.
_doneInternal
(
)
;
return
;
}
}
let
sequenceArray
=
[
]
;
for
(
var
i
in
config
.
subtests
)
{
for
(
var
r
=
0
;
r
<
config
.
repeat
;
r
+
+
)
{
if
(
!
config
.
subtests
[
i
]
|
|
!
tests
[
config
.
subtests
[
i
]
]
)
{
continue
;
}
sequenceArray
.
push
(
tests
[
config
.
subtests
[
i
]
]
)
;
}
}
garbageCollect
(
)
.
then
(
(
)
=
>
{
this
.
_doSequence
(
sequenceArray
this
.
_doneInternal
)
;
}
)
.
catch
(
e
=
>
{
dump
(
"
Exception
while
running
DAMP
tests
:
"
+
e
+
"
\
n
"
+
e
.
stack
+
"
\
n
"
)
;
}
)
;
}
}
;
