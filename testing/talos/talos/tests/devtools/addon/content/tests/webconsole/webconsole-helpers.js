"
use
strict
"
;
const
{
reloadPageAndLog
waitForDOMPredicate
}
=
require
(
"
damp
-
test
/
tests
/
head
"
)
;
exports
.
reloadConsoleAndLog
=
async
function
(
label
toolbox
expectedMessages
)
{
const
webConsole
=
toolbox
.
getPanel
(
"
webconsole
"
)
;
const
onWebConsoleReload
=
webConsole
.
once
(
"
reloaded
"
)
;
const
onReload
=
async
function
(
)
{
const
{
hud
}
=
webConsole
;
const
expected
=
typeof
expectedMessages
=
=
=
"
number
"
?
[
{
text
:
"
"
count
:
expectedMessages
}
]
:
expectedMessages
;
let
logMissingMessagesTimeoutId
;
await
onWebConsoleReload
;
const
checkMessages
=
consoleOutputEl
=
>
{
if
(
logMissingMessagesTimeoutId
)
{
clearTimeout
(
logMissingMessagesTimeoutId
)
;
logMissingMessagesTimeoutId
=
null
;
}
const
messages
=
Array
.
from
(
consoleOutputEl
.
querySelectorAll
(
"
.
message
"
)
)
;
const
missing
=
new
Map
(
expected
.
map
(
e
=
>
[
e
.
text
e
.
count
|
|
1
]
)
)
;
for
(
const
{
text
count
=
1
stacktrace
}
of
expected
)
{
let
found
=
0
;
for
(
const
message
of
messages
)
{
const
messageText
=
message
.
querySelector
(
"
.
message
-
body
"
)
.
innerText
;
if
(
messageText
.
includes
(
text
)
&
&
(
!
stacktrace
|
|
message
.
querySelector
(
"
.
frames
.
frame
"
)
)
)
{
const
repeat
=
message
.
querySelector
(
"
.
message
-
repeats
"
)
?
.
innerText
?
.
trim
(
)
;
found
=
found
+
(
repeat
?
parseInt
(
repeat
)
:
1
)
;
}
}
const
allFound
=
found
>
=
count
;
if
(
allFound
)
{
missing
.
delete
(
text
)
;
}
else
{
missing
.
set
(
text
count
-
found
)
;
}
}
const
foundAllMessages
=
missing
.
size
=
=
0
;
if
(
!
foundAllMessages
)
{
logMissingMessagesTimeoutId
=
setTimeout
(
(
)
=
>
{
dump
(
[
TEST_LOG
]
Still
waiting
for
the
following
messages
:
\
n
{
Array
.
from
(
missing
.
entries
(
)
)
.
map
(
(
[
text
count
]
)
=
>
{
text
|
|
"
<
any
text
>
"
}
(
{
count
}
)
)
.
join
(
"
\
n
"
)
}
\
n
)
;
dump
(
"
-
-
-
\
n
"
)
;
}
3000
)
;
}
return
foundAllMessages
;
}
;
if
(
checkMessages
(
getConsoleOutputElement
(
hud
)
)
)
{
return
;
}
await
waitForConsoleOutputChildListChange
(
hud
checkMessages
)
;
}
;
await
reloadPageAndLog
(
label
+
"
.
webconsole
"
toolbox
onReload
)
;
}
;
async
function
waitForConsoleOutputChildListChange
(
hud
predicate
)
{
const
webConsoleOutputEl
=
getConsoleOutputElement
(
hud
)
;
await
waitForDOMPredicate
(
webConsoleOutputEl
(
)
=
>
predicate
(
webConsoleOutputEl
)
{
childList
:
true
subtree
:
true
}
)
;
}
exports
.
waitForConsoleOutputChildListChange
=
waitForConsoleOutputChildListChange
;
function
getConsoleOutputElement
(
hud
)
{
return
hud
.
ui
.
document
.
querySelector
(
"
.
webconsole
-
output
"
)
;
}
