"
use
strict
"
;
const
{
openToolbox
closeToolbox
testSetup
testTeardown
runTest
waitForDOMElement
waitForDOMPredicate
}
=
require
(
"
damp
-
test
/
tests
/
head
"
)
;
const
{
waitForConsoleOutputChildListChange
}
=
require
(
"
damp
-
test
/
tests
/
webconsole
/
webconsole
-
helpers
"
)
;
const
{
TRACER_FIELDS_INDEXES
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
tracer
.
js
"
)
;
const
TEST_URL
=
data
:
text
/
html
<
!
DOCTYPE
html
>
<
meta
charset
=
utf8
>
<
script
>
window
.
onclick
=
(
)
=
>
{
for
(
let
i
=
0
;
i
<
100000
;
i
+
+
)
{
a
(
)
;
b
(
)
;
}
c
(
)
;
}
;
function
a
(
)
{
}
;
function
b
(
)
{
}
;
function
c
(
)
{
}
;
<
/
script
>
;
module
.
exports
=
async
function
(
)
{
Services
.
prefs
.
setBoolPref
(
"
devtools
.
debugger
.
features
.
javascript
-
tracing
"
true
)
;
const
tab
=
await
testSetup
(
TEST_URL
)
;
const
messageManager
=
tab
.
linkedBrowser
.
messageManager
;
const
toolbox
=
await
openToolbox
(
"
options
"
)
;
await
testServerPerformance
(
messageManager
toolbox
)
;
await
testWebConsolePerformance
(
messageManager
toolbox
)
;
await
testDebuggerSidebarPerformance
(
messageManager
toolbox
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
javascript
-
tracing
-
log
-
method
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
features
.
javascript
-
tracing
"
)
;
await
closeToolbox
(
)
;
await
testTeardown
(
)
;
}
;
async
function
testServerPerformance
(
messageManager
toolbox
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
debugger
.
javascript
-
tracing
-
log
-
method
"
"
console
"
)
;
const
{
resourceCommand
}
=
toolbox
.
commands
;
const
{
promise
resolve
}
=
Promise
.
withResolvers
(
)
;
function
onAvailable
(
resources
)
{
const
tracedLastFunctionCall
=
resources
.
some
(
resource
=
>
{
const
type
=
resource
[
TRACER_FIELDS_INDEXES
.
TYPE
]
;
return
(
type
=
=
"
frame
"
&
&
resource
[
TRACER_FIELDS_INDEXES
.
FRAME_NAME
]
=
=
"
c
"
)
;
}
)
;
if
(
tracedLastFunctionCall
)
{
resolve
(
)
;
}
}
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
JSTRACER_TRACE
]
{
onAvailable
}
)
;
await
startTracing
(
toolbox
)
;
await
toolbox
.
closeSplitConsole
(
)
;
let
test
=
runTest
(
"
jstracer
.
server
-
performance
.
DAMP
"
)
;
messageManager
.
loadFrameScript
(
"
data
:
(
"
+
encodeURIComponent
(
content
.
document
.
documentElement
.
click
(
)
)
+
"
)
(
)
"
true
)
;
await
promise
;
test
.
done
(
)
;
await
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
JSTRACER_TRACE
]
{
onAvailable
}
)
;
await
stopAndClearTracerData
(
toolbox
)
;
}
async
function
testWebConsolePerformance
(
messageManager
toolbox
)
{
const
{
hud
}
=
await
toolbox
.
selectTool
(
"
webconsole
"
)
;
await
startTracing
(
toolbox
)
;
const
test
=
runTest
(
"
jstracer
.
webconsole
-
performance
.
DAMP
"
)
;
messageManager
.
loadFrameScript
(
"
data
:
(
"
+
encodeURIComponent
(
content
.
document
.
documentElement
.
click
(
)
)
+
"
)
(
)
"
true
)
;
await
waitForConsoleOutputChildListChange
(
hud
consoleOutput
=
>
{
const
messages
=
consoleOutput
.
querySelectorAll
(
"
.
message
-
body
"
)
;
return
(
messages
&
&
messages
[
messages
.
length
-
1
]
?
.
textContent
.
includes
(
"
c
"
)
)
;
}
)
;
test
.
done
(
)
;
await
stopAndClearTracerData
(
toolbox
)
;
}
async
function
testDebuggerSidebarPerformance
(
messageManager
toolbox
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
debugger
.
javascript
-
tracing
-
log
-
method
"
"
debugger
-
sidebar
"
)
;
const
panel
=
await
toolbox
.
selectTool
(
"
jsdebugger
"
)
;
await
startTracing
(
toolbox
)
;
const
test
=
runTest
(
"
jstracer
.
debugger
-
sidebar
-
performance
.
DAMP
"
)
;
messageManager
.
loadFrameScript
(
"
data
:
(
"
+
encodeURIComponent
(
content
.
document
.
documentElement
.
click
(
)
)
+
"
)
(
)
"
true
)
;
dump
(
"
Wait
for
tracer
tree
\
n
"
)
;
const
traceTree
=
await
waitForDOMElement
(
panel
.
panelWin
.
document
.
body
"
#
tracer
-
tab
-
panel
.
tree
"
)
;
dump
(
"
Wait
for
first
trace
arrow
element
\
n
"
)
;
const
firstTraceArrow
=
await
waitForDOMElement
(
traceTree
"
.
arrow
:
not
(
.
open
)
"
)
;
dump
(
"
got
the
arrow
\
n
"
)
;
firstTraceArrow
.
click
(
)
;
await
waitForDOMPredicate
(
traceTree
function
scrollDown
(
)
{
traceTree
.
scrollBy
(
0
1000000
)
;
const
lastTreeNode
=
traceTree
.
lastElementChild
?
.
previousElementSibling
;
const
traceDisplayName
=
lastTreeNode
?
.
querySelector
(
"
.
frame
-
link
-
function
-
display
-
name
"
)
?
.
textContent
;
if
(
traceDisplayName
?
.
includes
(
"
c
"
)
)
{
return
true
;
}
return
false
;
}
)
;
dump
(
"
Found
the
last
logged
tree
in
the
tree
"
)
;
test
.
done
(
)
;
await
stopAndClearTracerData
(
toolbox
)
;
}
async
function
startTracing
(
toolbox
)
{
const
{
tracerCommand
}
=
toolbox
.
commands
;
const
onTracingActive
=
new
Promise
(
resolve
=
>
{
tracerCommand
.
on
(
"
toggle
"
function
listener
(
)
{
if
(
!
tracerCommand
.
isTracingActive
)
{
return
;
}
tracerCommand
.
off
(
"
toggle
"
listener
)
;
resolve
(
)
;
}
)
;
}
)
;
await
tracerCommand
.
toggle
(
)
;
await
onTracingActive
;
}
async
function
stopAndClearTracerData
(
toolbox
)
{
const
{
tracerCommand
resourceCommand
}
=
toolbox
.
commands
;
await
tracerCommand
.
toggle
(
)
;
await
resourceCommand
.
clearResources
(
[
resourceCommand
.
TYPES
.
JSTRACER_TRACE
]
)
;
}
