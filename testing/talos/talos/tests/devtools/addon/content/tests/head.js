"
use
strict
"
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
BASE_DOMAIN
=
"
http
:
/
/
damp
.
top
.
com
"
;
const
PAGES_BASE_URL
=
BASE_DOMAIN
+
"
/
tests
/
devtools
/
addon
/
content
/
pages
/
"
;
exports
.
PAGES_BASE_URL
=
PAGES_BASE_URL
;
exports
.
SIMPLE_URL
=
PAGES_BASE_URL
+
"
simple
.
html
"
;
exports
.
COMPLICATED_URL
=
"
http
:
/
/
www
.
bild
.
de
-
talos
/
fis
/
tp5n
/
bild
.
de
/
www
.
bild
.
de
/
index
.
html
"
;
const
{
damp
}
=
require
(
"
damp
-
test
/
damp
"
)
;
function
garbageCollect
(
)
{
return
damp
.
garbageCollect
(
)
;
}
exports
.
garbageCollect
=
garbageCollect
;
function
runTest
(
label
record
)
{
return
damp
.
runTest
(
label
record
)
;
}
exports
.
runTest
=
runTest
;
exports
.
testSetup
=
function
(
url
{
disableCache
}
=
{
}
)
{
if
(
disableCache
)
{
Services
.
prefs
.
setBoolPref
(
"
devtools
.
cache
.
disabled
"
true
)
;
}
return
damp
.
testSetup
(
url
)
;
}
;
exports
.
testTeardown
=
function
(
)
{
Services
.
prefs
.
setBoolPref
(
"
devtools
.
cache
.
disabled
"
false
)
;
return
damp
.
testTeardown
(
)
;
}
;
exports
.
logTestResult
=
function
(
name
value
)
{
damp
.
_results
.
push
(
{
name
value
}
)
;
}
;
function
getBrowserWindow
(
)
{
return
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
}
exports
.
getBrowserWindow
=
getBrowserWindow
;
function
getActiveTab
(
)
{
return
getBrowserWindow
(
)
.
gBrowser
.
selectedTab
;
}
exports
.
getActiveTab
=
getActiveTab
;
exports
.
getToolbox
=
function
(
)
{
let
tab
=
getActiveTab
(
)
;
return
gDevTools
.
getToolboxForTab
(
tab
)
;
}
;
async
function
waitForPendingPaints
(
toolbox
)
{
let
panel
=
toolbox
.
getCurrentPanel
(
)
;
let
window
=
panel
.
panelWin
|
|
panel
.
_frameWindow
|
|
panel
.
panelWindow
;
return
damp
.
waitForPendingPaints
(
window
)
;
}
exports
.
waitForPendingPaints
=
waitForPendingPaints
;
exports
.
waitForDOMElement
=
async
function
(
target
selector
)
{
return
waitForDOMPredicate
(
target
(
)
=
>
target
.
querySelector
(
selector
)
)
;
}
;
function
waitForDOMPredicate
(
target
predicate
options
=
{
attributes
:
true
childList
:
true
subtree
:
true
}
)
{
let
rv
=
predicate
(
)
;
if
(
rv
)
{
return
Promise
.
resolve
(
rv
)
;
}
return
new
Promise
(
resolve
=
>
{
const
observer
=
new
target
.
ownerGlobal
.
MutationObserver
(
(
)
=
>
{
rv
=
predicate
(
)
;
if
(
rv
)
{
resolve
(
rv
)
;
observer
.
disconnect
(
)
;
}
}
)
;
observer
.
observe
(
target
options
)
;
}
)
;
}
exports
.
waitForDOMPredicate
=
waitForDOMPredicate
;
const
openToolbox
=
async
function
(
tool
=
"
webconsole
"
onLoad
)
{
dump
(
Open
toolbox
on
'
{
tool
}
'
\
n
)
;
let
tab
=
getActiveTab
(
)
;
dump
(
Open
toolbox
-
Call
showToolboxForTab
\
n
)
;
const
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
{
toolId
:
tool
}
)
;
if
(
typeof
onLoad
=
=
"
function
"
)
{
dump
(
Open
toolbox
-
Wait
for
custom
onLoad
callback
\
n
)
;
let
panel
=
await
toolbox
.
getPanelWhenReady
(
tool
)
;
await
onLoad
(
toolbox
panel
)
;
}
return
toolbox
;
}
;
exports
.
openToolbox
=
openToolbox
;
exports
.
closeToolbox
=
async
function
(
)
{
let
tab
=
getActiveTab
(
)
;
let
toolbox
=
gDevTools
.
getToolboxForTab
(
tab
)
;
await
toolbox
.
target
.
client
.
waitForRequestsToSettle
(
)
;
await
gDevTools
.
closeToolboxForTab
(
tab
)
;
}
;
async
function
recordPendingPaints
(
name
toolbox
)
{
dump
(
Wait
for
pending
paints
on
'
{
name
}
'
\
n
)
;
const
test
=
runTest
(
{
name
}
.
settle
.
DAMP
false
)
;
await
waitForPendingPaints
(
toolbox
)
;
test
.
done
(
)
;
}
exports
.
recordPendingPaints
=
recordPendingPaints
;
exports
.
openToolboxAndLog
=
async
function
(
name
tool
onLoad
)
{
const
test
=
runTest
(
{
name
}
.
open
.
DAMP
)
;
let
toolbox
=
await
openToolbox
(
tool
onLoad
)
;
test
.
done
(
)
;
await
recordPendingPaints
(
{
name
}
.
open
toolbox
)
;
await
garbageCollect
(
)
;
return
toolbox
;
}
;
exports
.
closeToolboxAndLog
=
async
function
(
name
toolbox
)
{
let
{
target
}
=
toolbox
;
dump
(
Close
toolbox
on
'
{
name
}
'
\
n
)
;
await
target
.
client
.
waitForRequestsToSettle
(
)
;
let
test
=
runTest
(
{
name
}
.
close
.
DAMP
)
;
await
toolbox
.
destroy
(
)
;
test
.
done
(
)
;
}
;
exports
.
navigatePageAndLog
=
async
function
(
url
name
toolbox
)
{
dump
(
Navigate
page
on
'
{
name
}
'
to
url
'
{
url
}
'
\
n
)
;
let
test
=
runTest
(
{
name
}
.
navigate
.
DAMP
)
;
await
damp
.
navigatePage
(
url
)
;
test
.
done
(
)
;
await
recordPendingPaints
(
{
name
}
.
navigate
toolbox
)
;
}
;
exports
.
reloadPageAndLog
=
async
function
(
name
toolbox
onReload
)
{
dump
(
Reload
page
on
'
{
name
}
'
\
n
)
;
let
test
=
runTest
(
{
name
}
.
reload
.
DAMP
)
;
await
damp
.
reloadPage
(
onReload
)
;
test
.
done
(
)
;
await
recordPendingPaints
(
{
name
}
.
reload
toolbox
)
;
}
;
exports
.
isFissionEnabled
=
function
(
)
{
return
Services
.
appinfo
.
fissionAutostart
;
}
;
exports
.
waitForTick
=
(
)
=
>
new
Promise
(
res
=
>
setTimeout
(
res
0
)
)
;
