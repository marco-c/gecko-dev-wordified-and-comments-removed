"
use
strict
"
;
const
{
EVENTS
}
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
constants
"
)
;
const
Actions
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
const
{
getToolbox
runTest
}
=
require
(
"
.
.
/
head
"
)
;
async
function
waitForAllRequestsFinished
(
expectedRequests
)
{
let
toolbox
=
await
getToolbox
(
)
;
let
window
=
toolbox
.
getCurrentPanel
(
)
.
panelWin
;
return
new
Promise
(
resolve
=
>
{
let
payloadReady
=
0
;
function
onPayloadReady
(
_
id
)
{
payloadReady
+
+
;
maybeResolve
(
)
;
}
function
maybeResolve
(
)
{
if
(
payloadReady
>
=
expectedRequests
)
{
window
.
api
.
off
(
EVENTS
.
PAYLOAD_READY
onPayloadReady
)
;
setTimeout
(
resolve
1
)
;
}
}
window
.
api
.
on
(
EVENTS
.
PAYLOAD_READY
onPayloadReady
)
;
}
)
;
}
function
waitForDOMElement
(
target
selector
win
)
{
return
new
Promise
(
resolve
=
>
{
const
observer
=
new
win
.
MutationObserver
(
mutations
=
>
{
mutations
.
forEach
(
mutation
=
>
{
const
element
=
mutation
.
target
.
querySelector
(
selector
)
;
if
(
element
!
=
=
null
)
{
observer
.
disconnect
(
)
;
resolve
(
element
)
;
}
}
)
;
}
)
;
observer
.
observe
(
target
{
attributes
:
true
childList
:
true
subtree
:
true
}
)
;
}
)
;
}
function
waitForLoad
(
iframe
)
{
return
new
Promise
(
resolve
=
>
iframe
.
addEventListener
(
"
load
"
resolve
)
)
;
}
function
clickElement
(
el
win
)
{
const
clickEvent
=
new
win
.
MouseEvent
(
"
click
"
{
bubbles
:
true
cancelable
:
true
view
:
win
}
)
;
el
.
dispatchEvent
(
clickEvent
)
;
}
function
mouseDownElement
(
el
win
)
{
const
mouseEvent
=
new
win
.
MouseEvent
(
"
mousedown
"
{
bubbles
:
true
cancelable
:
true
view
:
win
}
)
;
el
.
dispatchEvent
(
mouseEvent
)
;
}
exports
.
waitForNetworkRequests
=
async
function
(
label
toolbox
expectedRequests
)
{
let
test
=
runTest
(
label
+
"
.
requestsFinished
.
DAMP
"
)
;
await
waitForAllRequestsFinished
(
expectedRequests
)
;
test
.
done
(
)
;
}
;
exports
.
exportHar
=
async
function
(
label
toolbox
)
{
let
test
=
runTest
(
label
+
"
.
exportHar
"
)
;
await
toolbox
.
getHARFromNetMonitor
(
)
;
test
.
done
(
)
;
}
;
exports
.
openResponseDetailsPanel
=
async
function
(
label
toolbox
)
{
const
win
=
toolbox
.
getCurrentPanel
(
)
.
panelWin
;
const
{
document
store
}
=
win
;
const
monitor
=
document
.
querySelector
(
"
.
monitor
-
panel
"
)
;
const
testHtml
=
runTest
(
label
+
"
.
responsePanel
.
html
"
)
;
store
.
dispatch
(
Actions
.
batchEnable
(
false
)
)
;
const
waitForDetailsBar
=
waitForDOMElement
(
monitor
"
.
network
-
details
-
bar
"
win
)
;
store
.
dispatch
(
Actions
.
toggleNetworkDetails
(
)
)
;
await
waitForDetailsBar
;
const
sideBar
=
document
.
querySelector
(
"
.
network
-
details
-
bar
"
)
;
const
iframeSelector
=
"
#
response
-
panel
.
html
-
preview
iframe
"
;
const
waitForIframe
=
waitForDOMElement
(
sideBar
iframeSelector
win
)
;
clickElement
(
document
.
querySelector
(
"
#
response
-
tab
"
)
win
)
;
await
waitForIframe
;
await
waitForLoad
(
document
.
querySelector
(
iframeSelector
)
)
;
testHtml
.
done
(
)
;
store
.
dispatch
(
Actions
.
toggleNetworkDetails
(
)
)
;
const
sizeColumnHeader
=
document
.
querySelector
(
"
#
requests
-
list
-
contentSize
-
button
"
)
;
const
waitForDesc
=
waitForDOMElement
(
sizeColumnHeader
.
parentNode
"
#
requests
-
list
-
contentSize
-
button
[
data
-
sorted
=
'
descending
'
]
"
win
)
;
clickElement
(
sizeColumnHeader
win
)
;
clickElement
(
sizeColumnHeader
win
)
;
await
waitForDesc
;
const
testEditor
=
runTest
(
label
+
"
.
responsePanel
.
editor
"
)
;
const
request
=
document
.
querySelectorAll
(
"
.
request
-
list
-
item
"
)
[
0
]
;
const
waitForPre
=
waitForDOMElement
(
monitor
"
#
response
-
panel
.
responseTextContainer
pre
"
win
)
;
mouseDownElement
(
request
win
)
;
await
waitForPre
;
testEditor
.
done
(
)
;
store
.
dispatch
(
Actions
.
toggleNetworkDetails
(
)
)
;
}
;
