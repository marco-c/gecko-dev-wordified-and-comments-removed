"
use
strict
"
;
const
{
EVENTS
}
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
constants
"
)
;
const
Actions
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
const
{
getToolbox
runTest
waitForDOMElement
}
=
require
(
"
damp
-
test
/
tests
/
head
"
)
;
async
function
waitForAllRequestsFinished
(
minExpectedRequests
maxExpectedRequests
predicate
)
{
let
toolbox
=
getToolbox
(
)
;
let
window
=
toolbox
.
getCurrentPanel
(
)
.
panelWin
;
const
requests
=
[
]
;
return
new
Promise
(
resolve
=
>
{
let
payloadReady
=
0
;
let
resolveWithLessThanMaxRequestsTimer
=
null
;
let
remainingLastDump
=
Infinity
;
function
onPayloadReady
(
request
)
{
payloadReady
+
+
;
if
(
predicate
!
=
null
)
{
requests
.
push
(
request
)
;
}
const
remaining
=
maxExpectedRequests
-
payloadReady
;
if
(
remainingLastDump
-
remaining
>
maxExpectedRequests
/
20
)
{
remainingLastDump
=
remaining
;
dump
(
[
waitForAllRequestsFinished
]
Waiting
for
{
remaining
}
/
{
maxExpectedRequests
}
requests
\
n
)
;
}
maybeResolve
(
)
;
}
function
doResolve
(
)
{
window
.
api
.
off
(
EVENTS
.
PAYLOAD_READY
onPayloadReady
)
;
setTimeout
(
resolve
1
)
;
}
function
maybeResolve
(
)
{
if
(
resolveWithLessThanMaxRequestsTimer
)
{
clearTimeout
(
resolveWithLessThanMaxRequestsTimer
)
;
resolveWithLessThanMaxRequestsTimer
=
null
;
}
if
(
predicate
!
=
null
&
&
!
predicate
(
requests
)
)
{
return
;
}
if
(
payloadReady
>
=
maxExpectedRequests
)
{
dump
(
[
waitForAllRequestsFinished
]
Received
more
than
{
maxExpectedRequests
}
(
max
)
requests
resolving
\
n
)
;
doResolve
(
)
;
return
;
}
if
(
payloadReady
>
=
minExpectedRequests
)
{
resolveWithLessThanMaxRequestsTimer
=
setTimeout
(
(
)
=
>
{
dump
(
[
waitForAllRequestsFinished
]
Received
more
than
{
minExpectedRequests
}
(
min
)
requests
resolving
\
n
)
;
doResolve
(
)
;
}
1000
)
;
}
}
window
.
api
.
on
(
EVENTS
.
PAYLOAD_READY
onPayloadReady
)
;
}
)
;
}
function
waitForLoad
(
iframe
)
{
return
new
Promise
(
resolve
=
>
iframe
.
addEventListener
(
"
load
"
resolve
)
)
;
}
function
clickElement
(
el
win
)
{
const
clickEvent
=
new
win
.
MouseEvent
(
"
click
"
{
bubbles
:
true
cancelable
:
true
view
:
win
}
)
;
el
.
dispatchEvent
(
clickEvent
)
;
}
function
mouseDownElement
(
el
win
)
{
const
mouseEvent
=
new
win
.
MouseEvent
(
"
mousedown
"
{
bubbles
:
true
cancelable
:
true
view
:
win
}
)
;
el
.
dispatchEvent
(
mouseEvent
)
;
}
exports
.
waitForNetworkRequests
=
async
function
(
label
toolbox
minExpectedRequests
maxExpectedRequests
=
minExpectedRequests
predicate
=
null
)
{
let
test
=
runTest
(
label
+
"
.
requestsFinished
.
DAMP
"
)
;
await
waitForAllRequestsFinished
(
minExpectedRequests
maxExpectedRequests
predicate
)
;
test
.
done
(
)
;
}
;
exports
.
exportHar
=
async
function
(
label
toolbox
)
{
let
test
=
runTest
(
label
+
"
.
exportHar
"
)
;
await
toolbox
.
getHARFromNetMonitor
(
)
;
test
.
done
(
)
;
}
;
exports
.
openResponseDetailsPanel
=
async
function
(
label
toolbox
)
{
const
win
=
toolbox
.
getCurrentPanel
(
)
.
panelWin
;
const
{
document
store
}
=
win
;
const
monitor
=
document
.
querySelector
(
"
.
monitor
-
panel
"
)
;
const
testHtml
=
runTest
(
label
+
"
.
responsePanel
.
html
"
)
;
store
.
dispatch
(
Actions
.
batchEnable
(
false
)
)
;
const
waitForDetailsBar
=
waitForDOMElement
(
monitor
"
.
network
-
details
-
bar
"
)
;
store
.
dispatch
(
Actions
.
toggleNetworkDetails
(
)
)
;
await
waitForDetailsBar
;
const
sideBar
=
document
.
querySelector
(
"
.
network
-
details
-
bar
"
)
;
const
iframeSelector
=
"
#
response
-
panel
.
html
-
preview
iframe
"
;
const
waitForIframe
=
waitForDOMElement
(
sideBar
iframeSelector
)
;
clickElement
(
document
.
querySelector
(
"
#
response
-
tab
"
)
win
)
;
await
waitForIframe
;
await
waitForLoad
(
document
.
querySelector
(
iframeSelector
)
)
;
testHtml
.
done
(
)
;
store
.
dispatch
(
Actions
.
toggleNetworkDetails
(
)
)
;
const
sizeColumnHeader
=
document
.
querySelector
(
"
#
requests
-
list
-
contentSize
-
button
"
)
;
const
waitForDesc
=
waitForDOMElement
(
sizeColumnHeader
.
parentNode
"
#
requests
-
list
-
contentSize
-
button
[
data
-
sorted
=
'
descending
'
]
"
)
;
clickElement
(
sizeColumnHeader
win
)
;
clickElement
(
sizeColumnHeader
win
)
;
await
waitForDesc
;
const
testEditor
=
runTest
(
label
+
"
.
responsePanel
.
editor
"
)
;
const
request
=
document
.
querySelectorAll
(
"
.
request
-
list
-
item
"
)
[
0
]
;
const
waitForEditor
=
waitForDOMElement
(
monitor
"
#
response
-
panel
.
cm
-
editor
"
)
;
mouseDownElement
(
request
win
)
;
await
waitForEditor
;
testEditor
.
done
(
)
;
store
.
dispatch
(
Actions
.
toggleNetworkDetails
(
)
)
;
}
;
