;
(
function
(
)
{
var
sMap
=
null
;
if
(
(
sMap
|
|
(
typeof
djConfig
!
=
"
undefined
"
&
&
djConfig
.
scopeMap
)
)
&
&
(
typeof
window
!
=
"
undefined
"
)
)
{
var
scopeDef
=
"
"
scopePrefix
=
"
"
scopeSuffix
=
"
"
scopeMap
=
{
}
scopeMapRev
=
{
}
;
sMap
=
sMap
|
|
djConfig
.
scopeMap
;
for
(
var
i
=
0
;
i
<
sMap
.
length
;
i
+
+
)
{
var
newScope
=
sMap
[
i
]
;
scopeDef
+
=
"
var
"
+
newScope
[
0
]
+
"
=
{
}
;
"
+
newScope
[
1
]
+
"
=
"
+
newScope
[
0
]
+
"
;
"
+
newScope
[
1
]
+
"
.
_scopeName
=
'
"
+
newScope
[
1
]
+
"
'
;
"
;
scopePrefix
+
=
(
i
=
=
0
?
"
"
:
"
"
)
+
newScope
[
0
]
;
scopeSuffix
+
=
(
i
=
=
0
?
"
"
:
"
"
)
+
newScope
[
1
]
;
scopeMap
[
newScope
[
0
]
]
=
newScope
[
1
]
;
scopeMapRev
[
newScope
[
1
]
]
=
newScope
[
0
]
;
}
eval
(
scopeDef
+
"
dojo
.
_scopeArgs
=
[
"
+
scopeSuffix
+
"
]
;
"
)
;
dojo
.
_scopePrefixArgs
=
scopePrefix
;
dojo
.
_scopePrefix
=
"
(
function
(
"
+
scopePrefix
+
"
)
{
"
;
dojo
.
_scopeSuffix
=
"
}
)
(
"
+
scopeSuffix
+
"
)
"
;
dojo
.
_scopeMap
=
scopeMap
;
dojo
.
_scopeMapRev
=
scopeMapRev
;
}
(
function
(
)
{
if
(
!
this
[
"
console
"
]
)
{
this
.
console
=
{
}
;
}
var
cn
=
[
"
assert
"
"
count
"
"
debug
"
"
dir
"
"
dirxml
"
"
error
"
"
group
"
"
groupEnd
"
"
info
"
"
profile
"
"
profileEnd
"
"
time
"
"
timeEnd
"
"
trace
"
"
warn
"
"
log
"
]
;
var
i
=
0
tn
;
while
(
(
tn
=
cn
[
i
+
+
]
)
)
{
if
(
!
console
[
tn
]
)
{
(
function
(
)
{
var
tcn
=
tn
+
"
"
;
console
[
tcn
]
=
(
'
log
'
in
console
)
?
function
(
)
{
var
a
=
Array
.
apply
(
{
}
arguments
)
;
a
.
unshift
(
tcn
+
"
:
"
)
;
console
[
"
log
"
]
(
a
.
join
(
"
"
)
)
;
}
:
function
(
)
{
}
}
)
(
)
;
}
}
if
(
typeof
dojo
=
=
"
undefined
"
)
{
this
.
dojo
=
{
_scopeName
:
"
dojo
"
_scopePrefix
:
"
"
_scopePrefixArgs
:
"
"
_scopeSuffix
:
"
"
_scopeMap
:
{
}
_scopeMapRev
:
{
}
}
;
}
var
d
=
dojo
;
if
(
typeof
dijit
=
=
"
undefined
"
)
{
this
.
dijit
=
{
_scopeName
:
"
dijit
"
}
;
}
if
(
typeof
dojox
=
=
"
undefined
"
)
{
this
.
dojox
=
{
_scopeName
:
"
dojox
"
}
;
}
if
(
!
d
.
_scopeArgs
)
{
d
.
_scopeArgs
=
[
dojo
dijit
dojox
]
;
}
d
.
global
=
this
;
d
.
config
=
{
isDebug
:
false
debugAtAllCosts
:
false
}
;
if
(
typeof
djConfig
!
=
"
undefined
"
)
{
for
(
var
opt
in
djConfig
)
{
d
.
config
[
opt
]
=
djConfig
[
opt
]
;
}
}
var
_platforms
=
[
"
Browser
"
"
Rhino
"
"
Spidermonkey
"
"
Mobile
"
]
;
var
t
;
while
(
(
t
=
_platforms
.
shift
(
)
)
)
{
d
[
"
is
"
+
t
]
=
false
;
}
dojo
.
locale
=
d
.
config
.
locale
;
var
rev
=
"
Rev
:
15729
"
.
match
(
/
\
d
+
/
)
;
dojo
.
version
=
{
major
:
1
minor
:
2
patch
:
2
flag
:
"
"
revision
:
rev
?
+
rev
[
0
]
:
999999
toString
:
function
(
)
{
with
(
d
.
version
)
{
return
major
+
"
.
"
+
minor
+
"
.
"
+
patch
+
flag
+
"
(
"
+
revision
+
"
)
"
;
}
}
}
if
(
typeof
OpenAjax
!
=
"
undefined
"
)
{
OpenAjax
.
hub
.
registerLibrary
(
dojo
.
_scopeName
"
http
:
/
/
dojotoolkit
.
org
"
d
.
version
.
toString
(
)
)
;
}
dojo
.
_mixin
=
function
(
obj
props
)
{
var
tobj
=
{
}
;
for
(
var
x
in
props
)
{
if
(
tobj
[
x
]
=
=
=
undefined
|
|
tobj
[
x
]
!
=
props
[
x
]
)
{
obj
[
x
]
=
props
[
x
]
;
}
}
if
(
d
[
"
isIE
"
]
&
&
props
)
{
var
p
=
props
.
toString
;
if
(
typeof
p
=
=
"
function
"
&
&
p
!
=
obj
.
toString
&
&
p
!
=
tobj
.
toString
&
&
p
!
=
"
\
nfunction
toString
(
)
{
\
n
[
native
code
]
\
n
}
\
n
"
)
{
obj
.
toString
=
props
.
toString
;
}
}
return
obj
;
}
dojo
.
mixin
=
function
(
obj
props
)
{
for
(
var
i
=
1
l
=
arguments
.
length
;
i
<
l
;
i
+
+
)
{
d
.
_mixin
(
obj
arguments
[
i
]
)
;
}
return
obj
;
}
dojo
.
_getProp
=
function
(
parts
create
context
)
{
var
obj
=
context
|
|
d
.
global
;
for
(
var
i
=
0
p
;
obj
&
&
(
p
=
parts
[
i
]
)
;
i
+
+
)
{
if
(
i
=
=
0
&
&
this
.
_scopeMap
[
p
]
)
{
p
=
this
.
_scopeMap
[
p
]
;
}
obj
=
(
p
in
obj
?
obj
[
p
]
:
(
create
?
obj
[
p
]
=
{
}
:
undefined
)
)
;
}
return
obj
;
}
dojo
.
setObject
=
function
(
name
value
context
)
{
var
parts
=
name
.
split
(
"
.
"
)
p
=
parts
.
pop
(
)
obj
=
d
.
_getProp
(
parts
true
context
)
;
return
obj
&
&
p
?
(
obj
[
p
]
=
value
)
:
undefined
;
}
dojo
.
getObject
=
function
(
name
create
context
)
{
return
d
.
_getProp
(
name
.
split
(
"
.
"
)
create
context
)
;
}
dojo
.
exists
=
function
(
name
obj
)
{
return
!
!
d
.
getObject
(
name
false
obj
)
;
}
dojo
[
"
eval
"
]
=
function
(
scriptFragment
)
{
return
d
.
global
.
eval
?
d
.
global
.
eval
(
scriptFragment
)
:
eval
(
scriptFragment
)
;
}
d
.
deprecated
=
d
.
experimental
=
function
(
)
{
}
;
}
)
(
)
;
(
function
(
)
{
var
d
=
dojo
;
d
.
mixin
(
d
{
_loadedModules
:
{
}
_inFlightCount
:
0
_hasResource
:
{
}
_modulePrefixes
:
{
dojo
:
{
name
:
"
dojo
"
value
:
"
.
"
}
doh
:
{
name
:
"
doh
"
value
:
"
.
.
/
util
/
doh
"
}
tests
:
{
name
:
"
tests
"
value
:
"
tests
"
}
}
_moduleHasPrefix
:
function
(
module
)
{
var
mp
=
this
.
_modulePrefixes
;
return
!
!
(
mp
[
module
]
&
&
mp
[
module
]
.
value
)
;
}
_getModulePrefix
:
function
(
module
)
{
var
mp
=
this
.
_modulePrefixes
;
if
(
this
.
_moduleHasPrefix
(
module
)
)
{
return
mp
[
module
]
.
value
;
}
return
module
;
}
_loadedUrls
:
[
]
_postLoad
:
false
_loaders
:
[
]
_unloaders
:
[
]
_loadNotifying
:
false
}
)
;
dojo
.
_loadPath
=
function
(
relpath
module
cb
)
{
var
uri
=
(
(
relpath
.
charAt
(
0
)
=
=
'
/
'
|
|
relpath
.
match
(
/
^
\
w
+
:
/
)
)
?
"
"
:
this
.
baseUrl
)
+
relpath
;
try
{
return
!
module
?
this
.
_loadUri
(
uri
cb
)
:
this
.
_loadUriAndCheck
(
uri
module
cb
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
return
false
;
}
}
dojo
.
_loadUri
=
function
(
uri
cb
)
{
if
(
this
.
_loadedUrls
[
uri
]
)
{
return
true
;
}
var
contents
=
this
.
_getText
(
uri
true
)
;
if
(
!
contents
)
{
return
false
;
}
this
.
_loadedUrls
[
uri
]
=
true
;
this
.
_loadedUrls
.
push
(
uri
)
;
if
(
cb
)
{
contents
=
'
(
'
+
contents
+
'
)
'
;
}
else
{
contents
=
this
.
_scopePrefix
+
contents
+
this
.
_scopeSuffix
;
}
if
(
d
.
isMoz
)
{
contents
+
=
"
\
r
\
n
/
/
sourceURL
=
"
+
uri
;
}
var
value
=
d
[
"
eval
"
]
(
contents
)
;
if
(
cb
)
{
cb
(
value
)
;
}
return
true
;
}
dojo
.
_loadUriAndCheck
=
function
(
uri
moduleName
cb
)
{
var
ok
=
false
;
try
{
ok
=
this
.
_loadUri
(
uri
cb
)
;
}
catch
(
e
)
{
console
.
error
(
"
failed
loading
"
+
uri
+
"
with
error
:
"
+
e
)
;
}
return
!
!
(
ok
&
&
this
.
_loadedModules
[
moduleName
]
)
;
}
dojo
.
loaded
=
function
(
)
{
this
.
_loadNotifying
=
true
;
this
.
_postLoad
=
true
;
var
mll
=
d
.
_loaders
;
this
.
_loaders
=
[
]
;
for
(
var
x
=
0
;
x
<
mll
.
length
;
x
+
+
)
{
mll
[
x
]
(
)
;
}
this
.
_loadNotifying
=
false
;
if
(
d
.
_postLoad
&
&
d
.
_inFlightCount
=
=
0
&
&
mll
.
length
)
{
d
.
_callLoaded
(
)
;
}
}
dojo
.
unloaded
=
function
(
)
{
var
mll
=
this
.
_unloaders
;
while
(
mll
.
length
)
{
(
mll
.
pop
(
)
)
(
)
;
}
}
d
.
_onto
=
function
(
arr
obj
fn
)
{
if
(
!
fn
)
{
arr
.
push
(
obj
)
;
}
else
if
(
fn
)
{
var
func
=
(
typeof
fn
=
=
"
string
"
)
?
obj
[
fn
]
:
fn
;
arr
.
push
(
function
(
)
{
func
.
call
(
obj
)
;
}
)
;
}
}
dojo
.
addOnLoad
=
function
(
obj
functionName
)
{
d
.
_onto
(
d
.
_loaders
obj
functionName
)
;
if
(
d
.
_postLoad
&
&
d
.
_inFlightCount
=
=
0
&
&
!
d
.
_loadNotifying
)
{
d
.
_callLoaded
(
)
;
}
}
var
dca
=
d
.
config
.
addOnLoad
;
if
(
dca
)
{
d
.
addOnLoad
[
(
dca
instanceof
Array
?
"
apply
"
:
"
call
"
)
]
(
d
dca
)
;
}
dojo
.
addOnUnload
=
function
(
obj
functionName
)
{
d
.
_onto
(
d
.
_unloaders
obj
functionName
)
;
}
dojo
.
_modulesLoaded
=
function
(
)
{
if
(
d
.
_postLoad
)
{
return
;
}
if
(
d
.
_inFlightCount
>
0
)
{
console
.
warn
(
"
files
still
in
flight
!
"
)
;
return
;
}
d
.
_callLoaded
(
)
;
}
dojo
.
_callLoaded
=
function
(
)
{
if
(
typeof
setTimeout
=
=
"
object
"
|
|
(
dojo
.
config
.
useXDomain
&
&
d
.
isOpera
)
)
{
if
(
dojo
.
isAIR
)
{
setTimeout
(
function
(
)
{
dojo
.
loaded
(
)
;
}
0
)
;
}
else
{
setTimeout
(
dojo
.
_scopeName
+
"
.
loaded
(
)
;
"
0
)
;
}
}
else
{
d
.
loaded
(
)
;
}
}
dojo
.
_getModuleSymbols
=
function
(
modulename
)
{
var
syms
=
modulename
.
split
(
"
.
"
)
;
for
(
var
i
=
syms
.
length
;
i
>
0
;
i
-
-
)
{
var
parentModule
=
syms
.
slice
(
0
i
)
.
join
(
"
.
"
)
;
if
(
(
i
=
=
1
)
&
&
!
this
.
_moduleHasPrefix
(
parentModule
)
)
{
syms
[
0
]
=
"
.
.
/
"
+
syms
[
0
]
;
}
else
{
var
parentModulePath
=
this
.
_getModulePrefix
(
parentModule
)
;
if
(
parentModulePath
!
=
parentModule
)
{
syms
.
splice
(
0
i
parentModulePath
)
;
break
;
}
}
}
return
syms
;
}
dojo
.
_global_omit_module_check
=
false
;
dojo
.
loadInit
=
function
(
init
)
{
init
(
)
;
}
dojo
.
_loadModule
=
dojo
.
require
=
function
(
moduleName
omitModuleCheck
)
{
omitModuleCheck
=
this
.
_global_omit_module_check
|
|
omitModuleCheck
;
var
module
=
this
.
_loadedModules
[
moduleName
]
;
if
(
module
)
{
return
module
;
}
var
relpath
=
this
.
_getModuleSymbols
(
moduleName
)
.
join
(
"
/
"
)
+
'
.
js
'
;
var
modArg
=
(
!
omitModuleCheck
)
?
moduleName
:
null
;
var
ok
=
this
.
_loadPath
(
relpath
modArg
)
;
if
(
!
ok
&
&
!
omitModuleCheck
)
{
throw
new
Error
(
"
Could
not
load
'
"
+
moduleName
+
"
'
;
last
tried
'
"
+
relpath
+
"
'
"
)
;
}
if
(
!
omitModuleCheck
&
&
!
this
.
_isXDomain
)
{
module
=
this
.
_loadedModules
[
moduleName
]
;
if
(
!
module
)
{
throw
new
Error
(
"
symbol
'
"
+
moduleName
+
"
'
is
not
defined
after
loading
'
"
+
relpath
+
"
'
"
)
;
}
}
return
module
;
}
dojo
.
provide
=
function
(
resourceName
)
{
resourceName
=
resourceName
+
"
"
;
return
(
d
.
_loadedModules
[
resourceName
]
=
d
.
getObject
(
resourceName
true
)
)
;
}
dojo
.
platformRequire
=
function
(
modMap
)
{
var
common
=
modMap
.
common
|
|
[
]
;
var
result
=
common
.
concat
(
modMap
[
d
.
_name
]
|
|
modMap
[
"
default
"
]
|
|
[
]
)
;
for
(
var
x
=
0
;
x
<
result
.
length
;
x
+
+
)
{
var
curr
=
result
[
x
]
;
if
(
curr
.
constructor
=
=
Array
)
{
d
.
_loadModule
.
apply
(
d
curr
)
;
}
else
{
d
.
_loadModule
(
curr
)
;
}
}
}
dojo
.
requireIf
=
function
(
condition
resourceName
)
{
if
(
condition
=
=
=
true
)
{
var
args
=
[
]
;
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
args
.
push
(
arguments
[
i
]
)
;
}
d
.
require
.
apply
(
d
args
)
;
}
}
dojo
.
requireAfterIf
=
d
.
requireIf
;
dojo
.
registerModulePath
=
function
(
module
prefix
)
{
d
.
_modulePrefixes
[
module
]
=
{
name
:
module
value
:
prefix
}
;
}
dojo
.
requireLocalization
=
function
(
moduleName
bundleName
locale
availableFlatLocales
)
{
d
.
require
(
"
dojo
.
i18n
"
)
;
d
.
i18n
.
_requireLocalization
.
apply
(
d
.
hostenv
arguments
)
;
}
;
var
ore
=
new
RegExp
(
"
^
(
(
[
^
:
/
?
#
]
+
)
:
)
?
(
/
/
(
[
^
/
?
#
]
*
)
)
?
(
[
^
?
#
]
*
)
(
\
\
?
(
[
^
#
]
*
)
)
?
(
#
(
.
*
)
)
?
"
)
;
var
ire
=
new
RegExp
(
"
^
(
(
(
[
^
\
\
[
:
]
+
)
:
)
?
(
[
^
]
+
)
)
?
(
\
\
[
(
[
^
\
\
]
]
+
)
\
\
]
|
(
[
^
\
\
[
:
]
*
)
)
(
:
(
[
0
-
9
]
+
)
)
?
"
)
;
dojo
.
_Url
=
function
(
)
{
var
n
=
null
;
var
_a
=
arguments
;
var
uri
=
[
_a
[
0
]
]
;
for
(
var
i
=
1
;
i
<
_a
.
length
;
i
+
+
)
{
if
(
!
_a
[
i
]
)
{
continue
;
}
var
relobj
=
new
d
.
_Url
(
_a
[
i
]
+
"
"
)
;
var
uriobj
=
new
d
.
_Url
(
uri
[
0
]
+
"
"
)
;
if
(
relobj
.
path
=
=
"
"
&
&
!
relobj
.
scheme
&
&
!
relobj
.
authority
&
&
!
relobj
.
query
)
{
if
(
relobj
.
fragment
!
=
n
)
{
uriobj
.
fragment
=
relobj
.
fragment
;
}
relobj
=
uriobj
;
}
else
if
(
!
relobj
.
scheme
)
{
relobj
.
scheme
=
uriobj
.
scheme
;
if
(
!
relobj
.
authority
)
{
relobj
.
authority
=
uriobj
.
authority
;
if
(
relobj
.
path
.
charAt
(
0
)
!
=
"
/
"
)
{
var
path
=
uriobj
.
path
.
substring
(
0
uriobj
.
path
.
lastIndexOf
(
"
/
"
)
+
1
)
+
relobj
.
path
;
var
segs
=
path
.
split
(
"
/
"
)
;
for
(
var
j
=
0
;
j
<
segs
.
length
;
j
+
+
)
{
if
(
segs
[
j
]
=
=
"
.
"
)
{
if
(
j
=
=
segs
.
length
-
1
)
{
segs
[
j
]
=
"
"
;
}
else
{
segs
.
splice
(
j
1
)
;
j
-
-
;
}
}
else
if
(
j
>
0
&
&
!
(
j
=
=
1
&
&
segs
[
0
]
=
=
"
"
)
&
&
segs
[
j
]
=
=
"
.
.
"
&
&
segs
[
j
-
1
]
!
=
"
.
.
"
)
{
if
(
j
=
=
(
segs
.
length
-
1
)
)
{
segs
.
splice
(
j
1
)
;
segs
[
j
-
1
]
=
"
"
;
}
else
{
segs
.
splice
(
j
-
1
2
)
;
j
-
=
2
;
}
}
}
relobj
.
path
=
segs
.
join
(
"
/
"
)
;
}
}
}
uri
=
[
]
;
if
(
relobj
.
scheme
)
{
uri
.
push
(
relobj
.
scheme
"
:
"
)
;
}
if
(
relobj
.
authority
)
{
uri
.
push
(
"
/
/
"
relobj
.
authority
)
;
}
uri
.
push
(
relobj
.
path
)
;
if
(
relobj
.
query
)
{
uri
.
push
(
"
?
"
relobj
.
query
)
;
}
if
(
relobj
.
fragment
)
{
uri
.
push
(
"
#
"
relobj
.
fragment
)
;
}
}
this
.
uri
=
uri
.
join
(
"
"
)
;
var
r
=
this
.
uri
.
match
(
ore
)
;
this
.
scheme
=
r
[
2
]
|
|
(
r
[
1
]
?
"
"
:
n
)
;
this
.
authority
=
r
[
4
]
|
|
(
r
[
3
]
?
"
"
:
n
)
;
this
.
path
=
r
[
5
]
;
this
.
query
=
r
[
7
]
|
|
(
r
[
6
]
?
"
"
:
n
)
;
this
.
fragment
=
r
[
9
]
|
|
(
r
[
8
]
?
"
"
:
n
)
;
if
(
this
.
authority
!
=
n
)
{
r
=
this
.
authority
.
match
(
ire
)
;
this
.
user
=
r
[
3
]
|
|
n
;
this
.
password
=
r
[
4
]
|
|
n
;
this
.
host
=
r
[
6
]
|
|
r
[
7
]
;
this
.
port
=
r
[
9
]
|
|
n
;
}
}
dojo
.
_Url
.
prototype
.
toString
=
function
(
)
{
return
this
.
uri
;
}
;
dojo
.
moduleUrl
=
function
(
module
url
)
{
var
loc
=
d
.
_getModuleSymbols
(
module
)
.
join
(
'
/
'
)
;
if
(
!
loc
)
{
return
null
;
}
if
(
loc
.
lastIndexOf
(
"
/
"
)
!
=
loc
.
length
-
1
)
{
loc
+
=
"
/
"
;
}
var
colonIndex
=
loc
.
indexOf
(
"
:
"
)
;
if
(
loc
.
charAt
(
0
)
!
=
"
/
"
&
&
(
colonIndex
=
=
-
1
|
|
colonIndex
>
loc
.
indexOf
(
"
/
"
)
)
)
{
loc
=
d
.
baseUrl
+
loc
;
}
return
new
d
.
_Url
(
loc
url
)
;
}
}
)
(
)
;
if
(
typeof
window
!
=
'
undefined
'
)
{
dojo
.
isBrowser
=
true
;
dojo
.
_name
=
"
browser
"
;
(
function
(
)
{
var
d
=
dojo
;
if
(
document
&
&
document
.
getElementsByTagName
)
{
var
scripts
=
document
.
getElementsByTagName
(
"
script
"
)
;
var
rePkg
=
/
dojo
(
\
.
xd
)
?
\
.
js
(
\
W
|
)
/
i
;
for
(
var
i
=
0
;
i
<
scripts
.
length
;
i
+
+
)
{
var
src
=
scripts
[
i
]
.
getAttribute
(
"
src
"
)
;
if
(
!
src
)
{
continue
;
}
var
m
=
src
.
match
(
rePkg
)
;
if
(
m
)
{
if
(
!
d
.
config
.
baseUrl
)
{
d
.
config
.
baseUrl
=
src
.
substring
(
0
m
.
index
)
;
}
var
cfg
=
scripts
[
i
]
.
getAttribute
(
"
djConfig
"
)
;
if
(
cfg
)
{
var
cfgo
=
eval
(
"
(
{
"
+
cfg
+
"
}
)
"
)
;
for
(
var
x
in
cfgo
)
{
dojo
.
config
[
x
]
=
cfgo
[
x
]
;
}
}
break
;
}
}
}
d
.
baseUrl
=
d
.
config
.
baseUrl
;
var
n
=
navigator
;
var
dua
=
n
.
userAgent
;
var
dav
=
n
.
appVersion
;
var
tv
=
parseFloat
(
dav
)
;
if
(
dua
.
indexOf
(
"
Opera
"
)
>
=
0
)
{
d
.
isOpera
=
tv
;
}
var
index
=
Math
.
max
(
dav
.
indexOf
(
"
WebKit
"
)
dav
.
indexOf
(
"
Safari
"
)
0
)
;
if
(
index
)
{
d
.
isSafari
=
parseFloat
(
dav
.
split
(
"
Version
/
"
)
[
1
]
)
|
|
(
parseFloat
(
dav
.
substr
(
index
+
7
)
)
>
419
.
3
)
?
3
:
2
;
}
if
(
dua
.
indexOf
(
"
AdobeAIR
"
)
>
=
0
)
{
d
.
isAIR
=
1
;
}
if
(
dav
.
indexOf
(
"
Konqueror
"
)
>
=
0
|
|
d
.
isSafari
)
{
d
.
isKhtml
=
tv
;
}
if
(
dua
.
indexOf
(
"
Gecko
"
)
>
=
0
&
&
!
d
.
isKhtml
)
{
d
.
isMozilla
=
d
.
isMoz
=
tv
;
}
if
(
d
.
isMoz
)
{
d
.
isFF
=
parseFloat
(
dua
.
split
(
"
Firefox
/
"
)
[
1
]
)
|
|
undefined
;
}
if
(
document
.
all
&
&
!
d
.
isOpera
)
{
d
.
isIE
=
parseFloat
(
dav
.
split
(
"
MSIE
"
)
[
1
]
)
|
|
undefined
;
}
if
(
dojo
.
isIE
&
&
window
.
location
.
protocol
=
=
=
"
file
:
"
)
{
dojo
.
config
.
ieForceActiveXXhr
=
true
;
}
var
cm
=
document
.
compatMode
;
d
.
isQuirks
=
cm
=
=
"
BackCompat
"
|
|
cm
=
=
"
QuirksMode
"
|
|
d
.
isIE
<
6
;
d
.
locale
=
dojo
.
config
.
locale
|
|
(
d
.
isIE
?
n
.
userLanguage
:
n
.
language
)
.
toLowerCase
(
)
;
d
.
_XMLHTTP_PROGIDS
=
[
'
Msxml2
.
XMLHTTP
'
'
Microsoft
.
XMLHTTP
'
'
Msxml2
.
XMLHTTP
.
4
.
0
'
]
;
d
.
_xhrObj
=
function
(
)
{
var
http
=
null
;
var
last_e
=
null
;
if
(
!
dojo
.
isIE
|
|
!
dojo
.
config
.
ieForceActiveXXhr
)
{
try
{
http
=
new
XMLHttpRequest
(
)
;
}
catch
(
e
)
{
}
}
if
(
!
http
)
{
for
(
var
i
=
0
;
i
<
3
;
+
+
i
)
{
var
progid
=
d
.
_XMLHTTP_PROGIDS
[
i
]
;
try
{
http
=
new
ActiveXObject
(
progid
)
;
}
catch
(
e
)
{
last_e
=
e
;
}
if
(
http
)
{
d
.
_XMLHTTP_PROGIDS
=
[
progid
]
;
break
;
}
}
}
if
(
!
http
)
{
throw
new
Error
(
"
XMLHTTP
not
available
:
"
+
last_e
)
;
}
return
http
;
}
d
.
_isDocumentOk
=
function
(
http
)
{
var
stat
=
http
.
status
|
|
0
;
return
(
stat
>
=
200
&
&
stat
<
300
)
|
|
stat
=
=
304
|
|
stat
=
=
1223
|
|
(
!
stat
&
&
(
location
.
protocol
=
=
"
file
:
"
|
|
location
.
protocol
=
=
"
chrome
:
"
)
)
;
}
var
owloc
=
window
.
location
+
"
"
;
var
base
=
document
.
getElementsByTagName
(
"
base
"
)
;
var
hasBase
=
(
base
&
&
base
.
length
>
0
)
;
d
.
_getText
=
function
(
uri
fail_ok
)
{
var
http
=
this
.
_xhrObj
(
)
;
if
(
!
hasBase
&
&
dojo
.
_Url
)
{
uri
=
(
new
dojo
.
_Url
(
owloc
uri
)
)
.
toString
(
)
;
}
if
(
d
.
config
.
cacheBust
)
{
uri
+
=
"
"
;
uri
+
=
(
uri
.
indexOf
(
"
?
"
)
=
=
-
1
?
"
?
"
:
"
&
"
)
+
String
(
d
.
config
.
cacheBust
)
.
replace
(
/
\
W
+
/
g
"
"
)
;
}
http
.
open
(
'
GET
'
uri
false
)
;
try
{
http
.
send
(
null
)
;
if
(
!
d
.
_isDocumentOk
(
http
)
)
{
var
err
=
Error
(
"
Unable
to
load
"
+
uri
+
"
status
:
"
+
http
.
status
)
;
err
.
status
=
http
.
status
;
err
.
responseText
=
http
.
responseText
;
throw
err
;
}
}
catch
(
e
)
{
if
(
fail_ok
)
{
return
null
;
}
throw
e
;
}
return
http
.
responseText
;
}
d
.
_windowUnloaders
=
[
]
;
d
.
windowUnloaded
=
function
(
)
{
var
mll
=
this
.
_windowUnloaders
;
while
(
mll
.
length
)
{
(
mll
.
pop
(
)
)
(
)
;
}
}
d
.
addOnWindowUnload
=
function
(
obj
functionName
)
{
d
.
_onto
(
d
.
_windowUnloaders
obj
functionName
)
;
}
}
)
(
)
;
dojo
.
_initFired
=
false
;
dojo
.
_loadInit
=
function
(
e
)
{
dojo
.
_initFired
=
true
;
var
type
=
(
e
&
&
e
.
type
)
?
e
.
type
.
toLowerCase
(
)
:
"
load
"
;
if
(
arguments
.
callee
.
initialized
|
|
(
type
!
=
"
domcontentloaded
"
&
&
type
!
=
"
load
"
)
)
{
return
;
}
arguments
.
callee
.
initialized
=
true
;
if
(
"
_khtmlTimer
"
in
dojo
)
{
clearInterval
(
dojo
.
_khtmlTimer
)
;
delete
dojo
.
_khtmlTimer
;
}
if
(
dojo
.
_inFlightCount
=
=
0
)
{
dojo
.
_modulesLoaded
(
)
;
}
}
dojo
.
_fakeLoadInit
=
function
(
)
{
dojo
.
_loadInit
(
{
type
:
"
load
"
}
)
;
}
if
(
!
dojo
.
config
.
afterOnLoad
)
{
if
(
document
.
addEventListener
)
{
if
(
dojo
.
isOpera
|
|
dojo
.
isFF
>
=
3
|
|
(
dojo
.
isMoz
&
&
dojo
.
config
.
enableMozDomContentLoaded
=
=
=
true
)
)
{
document
.
addEventListener
(
"
DOMContentLoaded
"
dojo
.
_loadInit
null
)
;
}
window
.
addEventListener
(
"
load
"
dojo
.
_loadInit
null
)
;
}
if
(
dojo
.
isAIR
)
{
window
.
addEventListener
(
"
load
"
dojo
.
_loadInit
null
)
;
}
else
if
(
/
(
WebKit
|
khtml
)
/
i
.
test
(
navigator
.
userAgent
)
)
{
dojo
.
_khtmlTimer
=
setInterval
(
function
(
)
{
if
(
/
loaded
|
complete
/
.
test
(
document
.
readyState
)
)
{
dojo
.
_loadInit
(
)
;
}
}
10
)
;
}
}
(
function
(
)
{
var
_w
=
window
;
var
_handleNodeEvent
=
function
(
evtName
fp
)
{
var
oldHandler
=
_w
[
evtName
]
|
|
function
(
)
{
}
;
_w
[
evtName
]
=
function
(
)
{
fp
.
apply
(
_w
arguments
)
;
oldHandler
.
apply
(
_w
arguments
)
;
}
;
}
;
if
(
dojo
.
isIE
)
{
if
(
!
dojo
.
config
.
afterOnLoad
)
{
document
.
write
(
'
<
scr
'
+
'
ipt
defer
src
=
"
/
/
:
"
'
+
'
onreadystatechange
=
"
if
(
this
.
readyState
=
=
\
'
complete
\
'
)
{
'
+
dojo
.
_scopeName
+
'
.
_loadInit
(
)
;
}
"
>
'
+
'
<
/
scr
'
+
'
ipt
>
'
)
;
}
try
{
document
.
namespaces
.
add
(
"
v
"
"
urn
:
schemas
-
microsoft
-
com
:
vml
"
)
;
document
.
createStyleSheet
(
)
.
addRule
(
"
v
\
\
:
*
"
"
behavior
:
url
(
#
default
#
VML
)
"
)
;
}
catch
(
e
)
{
}
}
_handleNodeEvent
(
"
onbeforeunload
"
function
(
)
{
dojo
.
unloaded
(
)
;
}
)
;
_handleNodeEvent
(
"
onunload
"
function
(
)
{
dojo
.
windowUnloaded
(
)
;
}
)
;
}
)
(
)
;
}
(
function
(
)
{
var
mp
=
dojo
.
config
[
"
modulePaths
"
]
;
if
(
mp
)
{
for
(
var
param
in
mp
)
{
dojo
.
registerModulePath
(
param
mp
[
param
]
)
;
}
}
}
)
(
)
;
if
(
dojo
.
config
.
isDebug
)
{
dojo
.
require
(
"
dojo
.
_firebug
.
firebug
"
)
;
}
if
(
dojo
.
config
.
debugAtAllCosts
)
{
dojo
.
config
.
useXDomain
=
true
;
dojo
.
require
(
"
dojo
.
_base
.
_loader
.
loader_xd
"
)
;
dojo
.
require
(
"
dojo
.
_base
.
_loader
.
loader_debug
"
)
;
dojo
.
require
(
"
dojo
.
i18n
"
)
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
lang
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
lang
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
lang
"
)
;
dojo
.
isString
=
function
(
it
)
{
return
!
!
arguments
.
length
&
&
it
!
=
null
&
&
(
typeof
it
=
=
"
string
"
|
|
it
instanceof
String
)
;
}
dojo
.
isArray
=
function
(
it
)
{
return
it
&
&
(
it
instanceof
Array
|
|
typeof
it
=
=
"
array
"
)
;
}
dojo
.
isFunction
=
(
function
(
)
{
var
_isFunction
=
function
(
it
)
{
return
it
&
&
(
typeof
it
=
=
"
function
"
|
|
it
instanceof
Function
)
;
}
;
return
dojo
.
isSafari
?
function
(
it
)
{
if
(
typeof
it
=
=
"
function
"
&
&
it
=
=
"
[
object
NodeList
]
"
)
{
return
false
;
}
return
_isFunction
(
it
)
;
}
:
_isFunction
;
}
)
(
)
;
dojo
.
isObject
=
function
(
it
)
{
return
it
!
=
=
undefined
&
&
(
it
=
=
=
null
|
|
typeof
it
=
=
"
object
"
|
|
dojo
.
isArray
(
it
)
|
|
dojo
.
isFunction
(
it
)
)
;
}
dojo
.
isArrayLike
=
function
(
it
)
{
var
d
=
dojo
;
return
it
&
&
it
!
=
=
undefined
&
&
!
d
.
isString
(
it
)
&
&
!
d
.
isFunction
(
it
)
&
&
!
(
it
.
tagName
&
&
it
.
tagName
.
toLowerCase
(
)
=
=
'
form
'
)
&
&
(
d
.
isArray
(
it
)
|
|
isFinite
(
it
.
length
)
)
;
}
dojo
.
isAlien
=
function
(
it
)
{
return
it
&
&
!
dojo
.
isFunction
(
it
)
&
&
/
\
{
\
s
*
\
[
native
code
\
]
\
s
*
\
}
/
.
test
(
String
(
it
)
)
;
}
dojo
.
extend
=
function
(
constructor
props
)
{
for
(
var
i
=
1
l
=
arguments
.
length
;
i
<
l
;
i
+
+
)
{
dojo
.
_mixin
(
constructor
.
prototype
arguments
[
i
]
)
;
}
return
constructor
;
}
dojo
.
_hitchArgs
=
function
(
scope
method
)
{
var
pre
=
dojo
.
_toArray
(
arguments
2
)
;
var
named
=
dojo
.
isString
(
method
)
;
return
function
(
)
{
var
args
=
dojo
.
_toArray
(
arguments
)
;
var
f
=
named
?
(
scope
|
|
dojo
.
global
)
[
method
]
:
method
;
return
f
&
&
f
.
apply
(
scope
|
|
this
pre
.
concat
(
args
)
)
;
}
}
dojo
.
hitch
=
function
(
scope
method
)
{
if
(
arguments
.
length
>
2
)
{
return
dojo
.
_hitchArgs
.
apply
(
dojo
arguments
)
;
}
if
(
!
method
)
{
method
=
scope
;
scope
=
null
;
}
if
(
dojo
.
isString
(
method
)
)
{
scope
=
scope
|
|
dojo
.
global
;
if
(
!
scope
[
method
]
)
{
throw
(
[
'
dojo
.
hitch
:
scope
[
"
'
method
'
"
]
is
null
(
scope
=
"
'
scope
'
"
)
'
]
.
join
(
'
'
)
)
;
}
return
function
(
)
{
return
scope
[
method
]
.
apply
(
scope
arguments
|
|
[
]
)
;
}
;
}
return
!
scope
?
method
:
function
(
)
{
return
method
.
apply
(
scope
arguments
|
|
[
]
)
;
}
;
}
dojo
.
delegate
=
dojo
.
_delegate
=
(
function
(
)
{
function
TMP
(
)
{
}
;
return
function
(
obj
props
)
{
TMP
.
prototype
=
obj
;
var
tmp
=
new
TMP
(
)
;
if
(
props
)
{
dojo
.
_mixin
(
tmp
props
)
;
}
return
tmp
;
}
}
)
(
)
;
(
function
(
)
{
var
efficient
=
function
(
obj
offset
startWith
)
{
return
(
startWith
|
|
[
]
)
.
concat
(
Array
.
prototype
.
slice
.
call
(
obj
offset
|
|
0
)
)
;
}
;
var
slow
=
function
(
obj
offset
startWith
)
{
var
arr
=
startWith
|
|
[
]
;
for
(
var
x
=
offset
|
|
0
;
x
<
obj
.
length
;
x
+
+
)
{
arr
.
push
(
obj
[
x
]
)
;
}
return
arr
;
}
;
dojo
.
_toArray
=
(
!
dojo
.
isIE
)
?
efficient
:
function
(
obj
)
{
return
(
(
obj
.
item
)
?
slow
:
efficient
)
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
dojo
.
partial
=
function
(
method
)
{
var
arr
=
[
null
]
;
return
dojo
.
hitch
.
apply
(
dojo
arr
.
concat
(
dojo
.
_toArray
(
arguments
)
)
)
;
}
dojo
.
clone
=
function
(
o
)
{
if
(
!
o
)
{
return
o
;
}
if
(
dojo
.
isArray
(
o
)
)
{
var
r
=
[
]
;
for
(
var
i
=
0
;
i
<
o
.
length
;
+
+
i
)
{
r
.
push
(
dojo
.
clone
(
o
[
i
]
)
)
;
}
return
r
;
}
if
(
!
dojo
.
isObject
(
o
)
)
{
return
o
;
}
if
(
o
.
nodeType
&
&
o
.
cloneNode
)
{
return
o
.
cloneNode
(
true
)
;
}
if
(
o
instanceof
Date
)
{
return
new
Date
(
o
.
getTime
(
)
)
;
}
var
r
=
new
o
.
constructor
(
)
;
for
(
var
i
in
o
)
{
if
(
!
(
i
in
r
)
|
|
r
[
i
]
!
=
o
[
i
]
)
{
r
[
i
]
=
dojo
.
clone
(
o
[
i
]
)
;
}
}
return
r
;
}
dojo
.
trim
=
function
(
str
)
{
return
str
.
replace
(
/
^
\
s
\
s
*
/
'
'
)
.
replace
(
/
\
s
\
s
*
/
'
'
)
;
}
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
declare
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
declare
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
declare
"
)
;
dojo
.
declare
=
function
(
className
superclass
props
)
{
var
dd
=
arguments
.
callee
mixins
;
if
(
dojo
.
isArray
(
superclass
)
)
{
mixins
=
superclass
;
superclass
=
mixins
.
shift
(
)
;
}
if
(
mixins
)
{
dojo
.
forEach
(
mixins
function
(
m
)
{
if
(
!
m
)
{
throw
(
className
+
"
:
mixin
#
"
+
i
+
"
is
null
"
)
;
}
superclass
=
dd
.
_delegate
(
superclass
m
)
;
}
)
;
}
var
ctor
=
dd
.
_delegate
(
superclass
)
;
props
=
props
|
|
{
}
;
ctor
.
extend
(
props
)
;
dojo
.
extend
(
ctor
{
declaredClass
:
className
_constructor
:
props
.
constructor
}
)
;
ctor
.
prototype
.
constructor
=
ctor
;
return
dojo
.
setObject
(
className
ctor
)
;
}
;
dojo
.
mixin
(
dojo
.
declare
{
_delegate
:
function
(
base
mixin
)
{
var
bp
=
(
base
|
|
0
)
.
prototype
mp
=
(
mixin
|
|
0
)
.
prototype
dd
=
dojo
.
declare
;
var
ctor
=
dd
.
_makeCtor
(
)
;
dojo
.
mixin
(
ctor
{
superclass
:
bp
mixin
:
mp
extend
:
dd
.
_extend
}
)
;
if
(
base
)
{
ctor
.
prototype
=
dojo
.
_delegate
(
bp
)
;
}
dojo
.
extend
(
ctor
dd
.
_core
mp
|
|
0
{
_constructor
:
null
preamble
:
null
}
)
;
ctor
.
prototype
.
constructor
=
ctor
;
ctor
.
prototype
.
declaredClass
=
(
bp
|
|
0
)
.
declaredClass
+
'
_
'
+
(
mp
|
|
0
)
.
declaredClass
;
return
ctor
;
}
_extend
:
function
(
props
)
{
var
i
fn
;
for
(
i
in
props
)
{
if
(
dojo
.
isFunction
(
fn
=
props
[
i
]
)
&
&
!
0
[
i
]
)
{
fn
.
nom
=
i
;
fn
.
ctor
=
this
;
}
}
dojo
.
extend
(
this
props
)
;
}
_makeCtor
:
function
(
)
{
return
function
(
)
{
this
.
_construct
(
arguments
)
;
}
;
}
_core
:
{
_construct
:
function
(
args
)
{
var
c
=
args
.
callee
s
=
c
.
superclass
ct
=
s
&
&
s
.
constructor
m
=
c
.
mixin
mct
=
m
&
&
m
.
constructor
a
=
args
ii
fn
;
if
(
a
[
0
]
)
{
if
(
(
(
fn
=
a
[
0
]
.
preamble
)
)
)
{
a
=
fn
.
apply
(
this
a
)
|
|
a
;
}
}
if
(
(
fn
=
c
.
prototype
.
preamble
)
)
{
a
=
fn
.
apply
(
this
a
)
|
|
a
;
}
if
(
ct
&
&
ct
.
apply
)
{
ct
.
apply
(
this
a
)
;
}
if
(
mct
&
&
mct
.
apply
)
{
mct
.
apply
(
this
a
)
;
}
if
(
(
ii
=
c
.
prototype
.
_constructor
)
)
{
ii
.
apply
(
this
args
)
;
}
if
(
this
.
constructor
.
prototype
=
=
c
.
prototype
&
&
(
ct
=
this
.
postscript
)
)
{
ct
.
apply
(
this
args
)
;
}
}
_findMixin
:
function
(
mixin
)
{
var
c
=
this
.
constructor
p
m
;
while
(
c
)
{
p
=
c
.
superclass
;
m
=
c
.
mixin
;
if
(
m
=
=
mixin
|
|
(
m
instanceof
mixin
.
constructor
)
)
{
return
p
;
}
if
(
m
&
&
m
.
_findMixin
&
&
(
m
=
m
.
_findMixin
(
mixin
)
)
)
{
return
m
;
}
c
=
p
&
&
p
.
constructor
;
}
}
_findMethod
:
function
(
name
method
ptype
has
)
{
var
p
=
ptype
c
m
f
;
do
{
c
=
p
.
constructor
;
m
=
c
.
mixin
;
if
(
m
&
&
(
m
=
this
.
_findMethod
(
name
method
m
has
)
)
)
{
return
m
;
}
if
(
(
f
=
p
[
name
]
)
&
&
(
has
=
=
(
f
=
=
method
)
)
)
{
return
p
;
}
p
=
c
.
superclass
;
}
while
(
p
)
;
return
!
has
&
&
(
p
=
this
.
_findMixin
(
ptype
)
)
&
&
this
.
_findMethod
(
name
method
p
has
)
;
}
inherited
:
function
(
name
args
newArgs
)
{
var
a
=
arguments
;
if
(
!
dojo
.
isString
(
a
[
0
]
)
)
{
newArgs
=
args
;
args
=
name
;
name
=
args
.
callee
.
nom
;
}
a
=
newArgs
|
|
args
;
var
c
=
args
.
callee
p
=
this
.
constructor
.
prototype
fn
mp
;
if
(
this
[
name
]
!
=
c
|
|
p
[
name
]
=
=
c
)
{
mp
=
(
c
.
ctor
|
|
0
)
.
superclass
|
|
this
.
_findMethod
(
name
c
p
true
)
;
if
(
!
mp
)
{
throw
(
this
.
declaredClass
+
'
:
inherited
method
"
'
+
name
+
'
"
mismatch
'
)
;
}
p
=
this
.
_findMethod
(
name
c
mp
false
)
;
}
fn
=
p
&
&
p
[
name
]
;
if
(
!
fn
)
{
throw
(
mp
.
declaredClass
+
'
:
inherited
method
"
'
+
name
+
'
"
not
found
'
)
;
}
return
fn
.
apply
(
this
a
)
;
}
}
}
)
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
connect
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
connect
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
connect
"
)
;
dojo
.
_listener
=
{
getDispatcher
:
function
(
)
{
return
function
(
)
{
var
ap
=
Array
.
prototype
c
=
arguments
.
callee
ls
=
c
.
_listeners
t
=
c
.
target
;
var
r
=
t
&
&
t
.
apply
(
this
arguments
)
;
var
lls
;
lls
=
[
]
.
concat
(
ls
)
;
for
(
var
i
in
lls
)
{
if
(
!
(
i
in
ap
)
)
{
lls
[
i
]
.
apply
(
this
arguments
)
;
}
}
return
r
;
}
}
add
:
function
(
source
method
listener
)
{
source
=
source
|
|
dojo
.
global
;
var
f
=
source
[
method
]
;
if
(
!
f
|
|
!
f
.
_listeners
)
{
var
d
=
dojo
.
_listener
.
getDispatcher
(
)
;
d
.
target
=
f
;
d
.
_listeners
=
[
]
;
f
=
source
[
method
]
=
d
;
}
return
f
.
_listeners
.
push
(
listener
)
;
}
remove
:
function
(
source
method
handle
)
{
var
f
=
(
source
|
|
dojo
.
global
)
[
method
]
;
if
(
f
&
&
f
.
_listeners
&
&
handle
-
-
)
{
delete
f
.
_listeners
[
handle
]
;
}
}
}
;
dojo
.
connect
=
function
(
obj
event
context
method
dontFix
)
{
var
a
=
arguments
args
=
[
]
i
=
0
;
args
.
push
(
dojo
.
isString
(
a
[
0
]
)
?
null
:
a
[
i
+
+
]
a
[
i
+
+
]
)
;
var
a1
=
a
[
i
+
1
]
;
args
.
push
(
dojo
.
isString
(
a1
)
|
|
dojo
.
isFunction
(
a1
)
?
a
[
i
+
+
]
:
null
a
[
i
+
+
]
)
;
for
(
var
l
=
a
.
length
;
i
<
l
;
i
+
+
)
{
args
.
push
(
a
[
i
]
)
;
}
return
dojo
.
_connect
.
apply
(
this
args
)
;
}
dojo
.
_connect
=
function
(
obj
event
context
method
)
{
var
l
=
dojo
.
_listener
h
=
l
.
add
(
obj
event
dojo
.
hitch
(
context
method
)
)
;
return
[
obj
event
h
l
]
;
}
dojo
.
disconnect
=
function
(
handle
)
{
if
(
handle
&
&
handle
[
0
]
!
=
=
undefined
)
{
dojo
.
_disconnect
.
apply
(
this
handle
)
;
delete
handle
[
0
]
;
}
}
dojo
.
_disconnect
=
function
(
obj
event
handle
listener
)
{
listener
.
remove
(
obj
event
handle
)
;
}
dojo
.
_topics
=
{
}
;
dojo
.
subscribe
=
function
(
topic
context
method
)
{
return
[
topic
dojo
.
_listener
.
add
(
dojo
.
_topics
topic
dojo
.
hitch
(
context
method
)
)
]
;
}
dojo
.
unsubscribe
=
function
(
handle
)
{
if
(
handle
)
{
dojo
.
_listener
.
remove
(
dojo
.
_topics
handle
[
0
]
handle
[
1
]
)
;
}
}
dojo
.
publish
=
function
(
topic
args
)
{
var
f
=
dojo
.
_topics
[
topic
]
;
if
(
f
)
{
f
.
apply
(
this
args
|
|
[
]
)
;
}
}
dojo
.
connectPublisher
=
function
(
topic
obj
event
)
{
var
pf
=
function
(
)
{
dojo
.
publish
(
topic
arguments
)
;
}
return
(
event
)
?
dojo
.
connect
(
obj
event
pf
)
:
dojo
.
connect
(
obj
pf
)
;
}
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
Deferred
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
Deferred
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
Deferred
"
)
;
dojo
.
Deferred
=
function
(
canceller
)
{
this
.
chain
=
[
]
;
this
.
id
=
this
.
_nextId
(
)
;
this
.
fired
=
-
1
;
this
.
paused
=
0
;
this
.
results
=
[
null
null
]
;
this
.
canceller
=
canceller
;
this
.
silentlyCancelled
=
false
;
}
;
dojo
.
extend
(
dojo
.
Deferred
{
_nextId
:
(
function
(
)
{
var
n
=
1
;
return
function
(
)
{
return
n
+
+
;
}
;
}
)
(
)
cancel
:
function
(
)
{
var
err
;
if
(
this
.
fired
=
=
-
1
)
{
if
(
this
.
canceller
)
{
err
=
this
.
canceller
(
this
)
;
}
else
{
this
.
silentlyCancelled
=
true
;
}
if
(
this
.
fired
=
=
-
1
)
{
if
(
!
(
err
instanceof
Error
)
)
{
var
res
=
err
;
err
=
new
Error
(
"
Deferred
Cancelled
"
)
;
err
.
dojoType
=
"
cancel
"
;
err
.
cancelResult
=
res
;
}
this
.
errback
(
err
)
;
}
}
else
if
(
(
this
.
fired
=
=
0
)
&
&
(
this
.
results
[
0
]
instanceof
dojo
.
Deferred
)
)
{
this
.
results
[
0
]
.
cancel
(
)
;
}
}
_resback
:
function
(
res
)
{
this
.
fired
=
(
(
res
instanceof
Error
)
?
1
:
0
)
;
this
.
results
[
this
.
fired
]
=
res
;
this
.
_fire
(
)
;
}
_check
:
function
(
)
{
if
(
this
.
fired
!
=
-
1
)
{
if
(
!
this
.
silentlyCancelled
)
{
throw
new
Error
(
"
already
called
!
"
)
;
}
this
.
silentlyCancelled
=
false
;
return
;
}
}
callback
:
function
(
res
)
{
this
.
_check
(
)
;
this
.
_resback
(
res
)
;
}
errback
:
function
(
res
)
{
this
.
_check
(
)
;
if
(
!
(
res
instanceof
Error
)
)
{
res
=
new
Error
(
res
)
;
}
this
.
_resback
(
res
)
;
}
addBoth
:
function
(
cb
cbfn
)
{
var
enclosed
=
dojo
.
hitch
.
apply
(
dojo
arguments
)
;
return
this
.
addCallbacks
(
enclosed
enclosed
)
;
}
addCallback
:
function
(
cb
cbfn
)
{
return
this
.
addCallbacks
(
dojo
.
hitch
.
apply
(
dojo
arguments
)
)
;
}
addErrback
:
function
(
cb
cbfn
)
{
return
this
.
addCallbacks
(
null
dojo
.
hitch
.
apply
(
dojo
arguments
)
)
;
}
addCallbacks
:
function
(
cb
eb
)
{
this
.
chain
.
push
(
[
cb
eb
]
)
if
(
this
.
fired
>
=
0
)
{
this
.
_fire
(
)
;
}
return
this
;
}
_fire
:
function
(
)
{
var
chain
=
this
.
chain
;
var
fired
=
this
.
fired
;
var
res
=
this
.
results
[
fired
]
;
var
self
=
this
;
var
cb
=
null
;
while
(
(
chain
.
length
>
0
)
&
&
(
this
.
paused
=
=
0
)
)
{
var
f
=
chain
.
shift
(
)
[
fired
]
;
if
(
!
f
)
{
continue
;
}
var
func
=
function
(
)
{
var
ret
=
f
(
res
)
;
if
(
typeof
ret
!
=
"
undefined
"
)
{
res
=
ret
;
}
fired
=
(
(
res
instanceof
Error
)
?
1
:
0
)
;
if
(
res
instanceof
dojo
.
Deferred
)
{
cb
=
function
(
res
)
{
self
.
_resback
(
res
)
;
self
.
paused
-
-
;
if
(
(
self
.
paused
=
=
0
)
&
&
(
self
.
fired
>
=
0
)
)
{
self
.
_fire
(
)
;
}
}
this
.
paused
+
+
;
}
}
;
if
(
dojo
.
config
.
isDebug
)
{
func
.
call
(
this
)
;
}
else
{
try
{
func
.
call
(
this
)
;
}
catch
(
err
)
{
fired
=
1
;
res
=
err
;
}
}
}
this
.
fired
=
fired
;
this
.
results
[
fired
]
=
res
;
if
(
(
cb
)
&
&
(
this
.
paused
)
)
{
res
.
addBoth
(
cb
)
;
}
}
}
)
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
json
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
json
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
json
"
)
;
dojo
.
fromJson
=
function
(
json
)
{
return
eval
(
"
(
"
+
json
+
"
)
"
)
;
}
dojo
.
_escapeString
=
function
(
str
)
{
return
(
'
"
'
+
str
.
replace
(
/
(
[
"
\
\
]
)
/
g
'
\
\
1
'
)
+
'
"
'
)
.
replace
(
/
[
\
f
]
/
g
"
\
\
f
"
)
.
replace
(
/
[
\
b
]
/
g
"
\
\
b
"
)
.
replace
(
/
[
\
n
]
/
g
"
\
\
n
"
)
.
replace
(
/
[
\
t
]
/
g
"
\
\
t
"
)
.
replace
(
/
[
\
r
]
/
g
"
\
\
r
"
)
;
}
dojo
.
toJsonIndentStr
=
"
\
t
"
;
dojo
.
toJson
=
function
(
it
prettyPrint
_indentStr
)
{
if
(
it
=
=
=
undefined
)
{
return
"
undefined
"
;
}
var
objtype
=
typeof
it
;
if
(
objtype
=
=
"
number
"
|
|
objtype
=
=
"
boolean
"
)
{
return
it
+
"
"
;
}
if
(
it
=
=
=
null
)
{
return
"
null
"
;
}
if
(
dojo
.
isString
(
it
)
)
{
return
dojo
.
_escapeString
(
it
)
;
}
var
recurse
=
arguments
.
callee
;
var
newObj
;
_indentStr
=
_indentStr
|
|
"
"
;
var
nextIndent
=
prettyPrint
?
_indentStr
+
dojo
.
toJsonIndentStr
:
"
"
;
var
tf
=
it
.
__json__
|
|
it
.
json
;
if
(
dojo
.
isFunction
(
tf
)
)
{
newObj
=
tf
.
call
(
it
)
;
if
(
it
!
=
=
newObj
)
{
return
recurse
(
newObj
prettyPrint
nextIndent
)
;
}
}
if
(
it
.
nodeType
&
&
it
.
cloneNode
)
{
throw
new
Error
(
"
Can
'
t
serialize
DOM
nodes
"
)
;
}
var
sep
=
prettyPrint
?
"
"
:
"
"
;
var
newLine
=
prettyPrint
?
"
\
n
"
:
"
"
;
if
(
dojo
.
isArray
(
it
)
)
{
var
res
=
dojo
.
map
(
it
function
(
obj
)
{
var
val
=
recurse
(
obj
prettyPrint
nextIndent
)
;
if
(
typeof
val
!
=
"
string
"
)
{
val
=
"
undefined
"
;
}
return
newLine
+
nextIndent
+
val
;
}
)
;
return
"
[
"
+
res
.
join
(
"
"
+
sep
)
+
newLine
+
_indentStr
+
"
]
"
;
}
if
(
objtype
=
=
"
function
"
)
{
return
null
;
}
var
output
=
[
]
key
;
for
(
key
in
it
)
{
var
keyStr
val
;
if
(
typeof
key
=
=
"
number
"
)
{
keyStr
=
'
"
'
+
key
+
'
"
'
;
}
else
if
(
typeof
key
=
=
"
string
"
)
{
keyStr
=
dojo
.
_escapeString
(
key
)
;
}
else
{
continue
;
}
val
=
recurse
(
it
[
key
]
prettyPrint
nextIndent
)
;
if
(
typeof
val
!
=
"
string
"
)
{
continue
;
}
output
.
push
(
newLine
+
nextIndent
+
keyStr
+
"
:
"
+
sep
+
val
)
;
}
return
"
{
"
+
output
.
join
(
"
"
+
sep
)
+
newLine
+
_indentStr
+
"
}
"
;
}
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
array
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
array
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
array
"
)
;
(
function
(
)
{
var
_getParts
=
function
(
arr
obj
cb
)
{
return
[
dojo
.
isString
(
arr
)
?
arr
.
split
(
"
"
)
:
arr
obj
|
|
dojo
.
global
dojo
.
isString
(
cb
)
?
new
Function
(
"
item
"
"
index
"
"
array
"
cb
)
:
cb
]
;
}
;
dojo
.
mixin
(
dojo
{
indexOf
:
function
(
array
value
fromIndex
findLast
)
{
var
step
=
1
end
=
array
.
length
|
|
0
i
=
0
;
if
(
findLast
)
{
i
=
end
-
1
;
step
=
end
=
-
1
;
}
if
(
fromIndex
!
=
undefined
)
{
i
=
fromIndex
;
}
if
(
(
findLast
&
&
i
>
end
)
|
|
i
<
end
)
{
for
(
;
i
!
=
end
;
i
+
=
step
)
{
if
(
array
[
i
]
=
=
value
)
{
return
i
;
}
}
}
return
-
1
;
}
lastIndexOf
:
function
(
array
value
fromIndex
)
{
return
dojo
.
indexOf
(
array
value
fromIndex
true
)
;
}
forEach
:
function
(
arr
callback
thisObject
)
{
if
(
!
arr
|
|
!
arr
.
length
)
{
return
;
}
var
_p
=
_getParts
(
arr
thisObject
callback
)
;
arr
=
_p
[
0
]
;
for
(
var
i
=
0
l
=
arr
.
length
;
i
<
l
;
+
+
i
)
{
_p
[
2
]
.
call
(
_p
[
1
]
arr
[
i
]
i
arr
)
;
}
}
_everyOrSome
:
function
(
every
arr
callback
thisObject
)
{
var
_p
=
_getParts
(
arr
thisObject
callback
)
;
arr
=
_p
[
0
]
;
for
(
var
i
=
0
l
=
arr
.
length
;
i
<
l
;
+
+
i
)
{
var
result
=
!
!
_p
[
2
]
.
call
(
_p
[
1
]
arr
[
i
]
i
arr
)
;
if
(
every
^
result
)
{
return
result
;
}
}
return
every
;
}
every
:
function
(
arr
callback
thisObject
)
{
return
this
.
_everyOrSome
(
true
arr
callback
thisObject
)
;
}
some
:
function
(
arr
callback
thisObject
)
{
return
this
.
_everyOrSome
(
false
arr
callback
thisObject
)
;
}
map
:
function
(
arr
callback
thisObject
)
{
var
_p
=
_getParts
(
arr
thisObject
callback
)
;
arr
=
_p
[
0
]
;
var
outArr
=
(
arguments
[
3
]
?
(
new
arguments
[
3
]
(
)
)
:
[
]
)
;
for
(
var
i
=
0
l
=
arr
.
length
;
i
<
l
;
+
+
i
)
{
outArr
.
push
(
_p
[
2
]
.
call
(
_p
[
1
]
arr
[
i
]
i
arr
)
)
;
}
return
outArr
;
}
filter
:
function
(
arr
callback
thisObject
)
{
var
_p
=
_getParts
(
arr
thisObject
callback
)
;
arr
=
_p
[
0
]
;
var
outArr
=
[
]
;
for
(
var
i
=
0
l
=
arr
.
length
;
i
<
l
;
+
+
i
)
{
if
(
_p
[
2
]
.
call
(
_p
[
1
]
arr
[
i
]
i
arr
)
)
{
outArr
.
push
(
arr
[
i
]
)
;
}
}
return
outArr
;
}
}
)
;
}
)
(
)
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
Color
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
Color
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
Color
"
)
;
dojo
.
Color
=
function
(
color
)
{
if
(
color
)
{
this
.
setColor
(
color
)
;
}
}
;
dojo
.
Color
.
named
=
{
black
:
[
0
0
0
]
silver
:
[
192
192
192
]
gray
:
[
128
128
128
]
white
:
[
255
255
255
]
maroon
:
[
128
0
0
]
red
:
[
255
0
0
]
purple
:
[
128
0
128
]
fuchsia
:
[
255
0
255
]
green
:
[
0
128
0
]
lime
:
[
0
255
0
]
olive
:
[
128
128
0
]
yellow
:
[
255
255
0
]
navy
:
[
0
0
128
]
blue
:
[
0
0
255
]
teal
:
[
0
128
128
]
aqua
:
[
0
255
255
]
}
;
dojo
.
extend
(
dojo
.
Color
{
r
:
255
g
:
255
b
:
255
a
:
1
_set
:
function
(
r
g
b
a
)
{
var
t
=
this
;
t
.
r
=
r
;
t
.
g
=
g
;
t
.
b
=
b
;
t
.
a
=
a
;
}
setColor
:
function
(
color
)
{
var
d
=
dojo
;
if
(
d
.
isString
(
color
)
)
{
d
.
colorFromString
(
color
this
)
;
}
else
if
(
d
.
isArray
(
color
)
)
{
d
.
colorFromArray
(
color
this
)
;
}
else
{
this
.
_set
(
color
.
r
color
.
g
color
.
b
color
.
a
)
;
if
(
!
(
color
instanceof
d
.
Color
)
)
{
this
.
sanitize
(
)
;
}
}
return
this
;
}
sanitize
:
function
(
)
{
return
this
;
}
toRgb
:
function
(
)
{
var
t
=
this
;
return
[
t
.
r
t
.
g
t
.
b
]
;
}
toRgba
:
function
(
)
{
var
t
=
this
;
return
[
t
.
r
t
.
g
t
.
b
t
.
a
]
;
}
toHex
:
function
(
)
{
var
arr
=
dojo
.
map
(
[
"
r
"
"
g
"
"
b
"
]
function
(
x
)
{
var
s
=
this
[
x
]
.
toString
(
16
)
;
return
s
.
length
<
2
?
"
0
"
+
s
:
s
;
}
this
)
;
return
"
#
"
+
arr
.
join
(
"
"
)
;
}
toCss
:
function
(
includeAlpha
)
{
var
t
=
this
rgb
=
t
.
r
+
"
"
+
t
.
g
+
"
"
+
t
.
b
;
return
(
includeAlpha
?
"
rgba
(
"
+
rgb
+
"
"
+
t
.
a
:
"
rgb
(
"
+
rgb
)
+
"
)
"
;
}
toString
:
function
(
)
{
return
this
.
toCss
(
true
)
;
}
}
)
;
dojo
.
blendColors
=
function
(
start
end
weight
obj
)
{
var
d
=
dojo
t
=
obj
|
|
new
dojo
.
Color
(
)
;
d
.
forEach
(
[
"
r
"
"
g
"
"
b
"
"
a
"
]
function
(
x
)
{
t
[
x
]
=
start
[
x
]
+
(
end
[
x
]
-
start
[
x
]
)
*
weight
;
if
(
x
!
=
"
a
"
)
{
t
[
x
]
=
Math
.
round
(
t
[
x
]
)
;
}
}
)
;
return
t
.
sanitize
(
)
;
}
;
dojo
.
colorFromRgb
=
function
(
color
obj
)
{
var
m
=
color
.
toLowerCase
(
)
.
match
(
/
^
rgba
?
\
(
(
[
\
s
\
.
0
-
9
]
+
)
\
)
/
)
;
return
m
&
&
dojo
.
colorFromArray
(
m
[
1
]
.
split
(
/
\
s
*
\
s
*
/
)
obj
)
;
}
;
dojo
.
colorFromHex
=
function
(
color
obj
)
{
var
d
=
dojo
t
=
obj
|
|
new
d
.
Color
(
)
bits
=
(
color
.
length
=
=
4
)
?
4
:
8
mask
=
(
1
<
<
bits
)
-
1
;
color
=
Number
(
"
0x
"
+
color
.
substr
(
1
)
)
;
if
(
isNaN
(
color
)
)
{
return
null
;
}
d
.
forEach
(
[
"
b
"
"
g
"
"
r
"
]
function
(
x
)
{
var
c
=
color
&
mask
;
color
>
>
=
bits
;
t
[
x
]
=
bits
=
=
4
?
17
*
c
:
c
;
}
)
;
t
.
a
=
1
;
return
t
;
}
;
dojo
.
colorFromArray
=
function
(
a
obj
)
{
var
t
=
obj
|
|
new
dojo
.
Color
(
)
;
t
.
_set
(
Number
(
a
[
0
]
)
Number
(
a
[
1
]
)
Number
(
a
[
2
]
)
Number
(
a
[
3
]
)
)
;
if
(
isNaN
(
t
.
a
)
)
{
t
.
a
=
1
;
}
return
t
.
sanitize
(
)
;
}
;
dojo
.
colorFromString
=
function
(
str
obj
)
{
var
a
=
dojo
.
Color
.
named
[
str
]
;
return
a
&
&
dojo
.
colorFromArray
(
a
obj
)
|
|
dojo
.
colorFromRgb
(
str
obj
)
|
|
dojo
.
colorFromHex
(
str
obj
)
;
}
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
"
)
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
window
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
window
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
window
"
)
;
dojo
.
doc
=
window
[
"
document
"
]
|
|
null
;
dojo
.
body
=
function
(
)
{
return
dojo
.
doc
.
body
|
|
dojo
.
doc
.
getElementsByTagName
(
"
body
"
)
[
0
]
;
}
dojo
.
setContext
=
function
(
globalObject
globalDocument
)
{
dojo
.
global
=
globalObject
;
dojo
.
doc
=
globalDocument
;
}
;
dojo
.
_fireCallback
=
function
(
callback
context
cbArguments
)
{
if
(
context
&
&
dojo
.
isString
(
callback
)
)
{
callback
=
context
[
callback
]
;
}
return
callback
.
apply
(
context
cbArguments
|
|
[
]
)
;
}
dojo
.
withGlobal
=
function
(
globalObject
callback
thisObject
cbArguments
)
{
var
rval
;
var
oldGlob
=
dojo
.
global
;
var
oldDoc
=
dojo
.
doc
;
try
{
dojo
.
setContext
(
globalObject
globalObject
.
document
)
;
rval
=
dojo
.
_fireCallback
(
callback
thisObject
cbArguments
)
;
}
finally
{
dojo
.
setContext
(
oldGlob
oldDoc
)
;
}
return
rval
;
}
dojo
.
withDoc
=
function
(
documentObject
callback
thisObject
cbArguments
)
{
var
rval
;
var
oldDoc
=
dojo
.
doc
;
try
{
dojo
.
doc
=
documentObject
;
rval
=
dojo
.
_fireCallback
(
callback
thisObject
cbArguments
)
;
}
finally
{
dojo
.
doc
=
oldDoc
;
}
return
rval
;
}
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
event
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
event
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
event
"
)
;
(
function
(
)
{
var
del
=
(
dojo
.
_event_listener
=
{
add
:
function
(
node
name
fp
)
{
if
(
!
node
)
{
return
;
}
name
=
del
.
_normalizeEventName
(
name
)
;
fp
=
del
.
_fixCallback
(
name
fp
)
;
var
oname
=
name
;
if
(
!
dojo
.
isIE
&
&
(
name
=
=
"
mouseenter
"
|
|
name
=
=
"
mouseleave
"
)
)
{
var
ofp
=
fp
;
name
=
(
name
=
=
"
mouseenter
"
)
?
"
mouseover
"
:
"
mouseout
"
;
fp
=
function
(
e
)
{
try
{
e
.
relatedTarget
.
tagName
;
}
catch
(
e2
)
{
return
;
}
if
(
!
dojo
.
isDescendant
(
e
.
relatedTarget
node
)
)
{
return
ofp
.
call
(
this
e
)
;
}
}
}
node
.
addEventListener
(
name
fp
false
)
;
return
fp
;
}
remove
:
function
(
node
event
handle
)
{
if
(
node
)
{
event
=
del
.
_normalizeEventName
(
event
)
;
if
(
!
dojo
.
isIE
&
&
(
event
=
=
"
mouseenter
"
|
|
event
=
=
"
mouseleave
"
)
)
{
event
=
(
event
=
=
"
mouseenter
"
)
?
"
mouseover
"
:
"
mouseout
"
;
}
node
.
removeEventListener
(
event
handle
false
)
;
}
}
_normalizeEventName
:
function
(
name
)
{
return
name
.
slice
(
0
2
)
=
=
"
on
"
?
name
.
slice
(
2
)
:
name
;
}
_fixCallback
:
function
(
name
fp
)
{
return
name
!
=
"
keypress
"
?
fp
:
function
(
e
)
{
return
fp
.
call
(
this
del
.
_fixEvent
(
e
this
)
)
;
}
;
}
_fixEvent
:
function
(
evt
sender
)
{
switch
(
evt
.
type
)
{
case
"
keypress
"
:
del
.
_setKeyChar
(
evt
)
;
break
;
}
return
evt
;
}
_setKeyChar
:
function
(
evt
)
{
evt
.
keyChar
=
evt
.
charCode
?
String
.
fromCharCode
(
evt
.
charCode
)
:
'
'
;
evt
.
charOrCode
=
evt
.
keyChar
|
|
evt
.
keyCode
;
}
_punctMap
:
{
106
:
42
111
:
47
186
:
59
187
:
43
188
:
44
189
:
45
190
:
46
191
:
47
192
:
96
219
:
91
220
:
92
221
:
93
222
:
39
}
}
)
;
dojo
.
fixEvent
=
function
(
evt
sender
)
{
return
del
.
_fixEvent
(
evt
sender
)
;
}
dojo
.
stopEvent
=
function
(
evt
)
{
evt
.
preventDefault
(
)
;
evt
.
stopPropagation
(
)
;
}
var
node_listener
=
dojo
.
_listener
;
dojo
.
_connect
=
function
(
obj
event
context
method
dontFix
)
{
var
isNode
=
obj
&
&
(
obj
.
nodeType
|
|
obj
.
attachEvent
|
|
obj
.
addEventListener
)
;
var
lid
=
!
isNode
?
0
:
(
!
dontFix
?
1
:
2
)
l
=
[
dojo
.
_listener
del
node_listener
]
[
lid
]
;
var
h
=
l
.
add
(
obj
event
dojo
.
hitch
(
context
method
)
)
;
return
[
obj
event
h
lid
]
;
}
dojo
.
_disconnect
=
function
(
obj
event
handle
listener
)
{
(
[
dojo
.
_listener
del
node_listener
]
[
listener
]
)
.
remove
(
obj
event
handle
)
;
}
dojo
.
keys
=
{
BACKSPACE
:
8
TAB
:
9
CLEAR
:
12
ENTER
:
13
SHIFT
:
16
CTRL
:
17
ALT
:
18
PAUSE
:
19
CAPS_LOCK
:
20
ESCAPE
:
27
SPACE
:
32
PAGE_UP
:
33
PAGE_DOWN
:
34
END
:
35
HOME
:
36
LEFT_ARROW
:
37
UP_ARROW
:
38
RIGHT_ARROW
:
39
DOWN_ARROW
:
40
INSERT
:
45
DELETE
:
46
HELP
:
47
LEFT_WINDOW
:
91
RIGHT_WINDOW
:
92
SELECT
:
93
NUMPAD_0
:
96
NUMPAD_1
:
97
NUMPAD_2
:
98
NUMPAD_3
:
99
NUMPAD_4
:
100
NUMPAD_5
:
101
NUMPAD_6
:
102
NUMPAD_7
:
103
NUMPAD_8
:
104
NUMPAD_9
:
105
NUMPAD_MULTIPLY
:
106
NUMPAD_PLUS
:
107
NUMPAD_ENTER
:
108
NUMPAD_MINUS
:
109
NUMPAD_PERIOD
:
110
NUMPAD_DIVIDE
:
111
F1
:
112
F2
:
113
F3
:
114
F4
:
115
F5
:
116
F6
:
117
F7
:
118
F8
:
119
F9
:
120
F10
:
121
F11
:
122
F12
:
123
F13
:
124
F14
:
125
F15
:
126
NUM_LOCK
:
144
SCROLL_LOCK
:
145
}
;
if
(
dojo
.
isIE
)
{
var
_trySetKeyCode
=
function
(
e
code
)
{
try
{
return
(
e
.
keyCode
=
code
)
;
}
catch
(
e
)
{
return
0
;
}
}
var
iel
=
dojo
.
_listener
;
var
listenersName
=
dojo
.
_ieListenersName
=
"
_
"
+
dojo
.
_scopeName
+
"
_listeners
"
;
if
(
!
dojo
.
config
.
_allow_leaks
)
{
node_listener
=
iel
=
dojo
.
_ie_listener
=
{
handlers
:
[
]
add
:
function
(
source
method
listener
)
{
source
=
source
|
|
dojo
.
global
;
var
f
=
source
[
method
]
;
if
(
!
f
|
|
!
f
[
listenersName
]
)
{
var
d
=
dojo
.
_getIeDispatcher
(
)
;
d
.
target
=
f
&
&
(
ieh
.
push
(
f
)
-
1
)
;
d
[
listenersName
]
=
[
]
;
f
=
source
[
method
]
=
d
;
}
return
f
[
listenersName
]
.
push
(
ieh
.
push
(
listener
)
-
1
)
;
}
remove
:
function
(
source
method
handle
)
{
var
f
=
(
source
|
|
dojo
.
global
)
[
method
]
l
=
f
&
&
f
[
listenersName
]
;
if
(
f
&
&
l
&
&
handle
-
-
)
{
delete
ieh
[
l
[
handle
]
]
;
delete
l
[
handle
]
;
}
}
}
;
var
ieh
=
iel
.
handlers
;
}
dojo
.
mixin
(
del
{
add
:
function
(
node
event
fp
)
{
if
(
!
node
)
{
return
;
}
event
=
del
.
_normalizeEventName
(
event
)
;
if
(
event
=
=
"
onkeypress
"
)
{
var
kd
=
node
.
onkeydown
;
if
(
!
kd
|
|
!
kd
[
listenersName
]
|
|
!
kd
.
_stealthKeydownHandle
)
{
var
h
=
del
.
add
(
node
"
onkeydown
"
del
.
_stealthKeyDown
)
;
kd
=
node
.
onkeydown
;
kd
.
_stealthKeydownHandle
=
h
;
kd
.
_stealthKeydownRefs
=
1
;
}
else
{
kd
.
_stealthKeydownRefs
+
+
;
}
}
return
iel
.
add
(
node
event
del
.
_fixCallback
(
fp
)
)
;
}
remove
:
function
(
node
event
handle
)
{
event
=
del
.
_normalizeEventName
(
event
)
;
iel
.
remove
(
node
event
handle
)
;
if
(
event
=
=
"
onkeypress
"
)
{
var
kd
=
node
.
onkeydown
;
if
(
-
-
kd
.
_stealthKeydownRefs
<
=
0
)
{
iel
.
remove
(
node
"
onkeydown
"
kd
.
_stealthKeydownHandle
)
;
delete
kd
.
_stealthKeydownHandle
;
}
}
}
_normalizeEventName
:
function
(
eventName
)
{
return
eventName
.
slice
(
0
2
)
!
=
"
on
"
?
"
on
"
+
eventName
:
eventName
;
}
_nop
:
function
(
)
{
}
_fixEvent
:
function
(
evt
sender
)
{
if
(
!
evt
)
{
var
w
=
sender
&
&
(
sender
.
ownerDocument
|
|
sender
.
document
|
|
sender
)
.
parentWindow
|
|
window
;
evt
=
w
.
event
;
}
if
(
!
evt
)
{
return
(
evt
)
;
}
evt
.
target
=
evt
.
srcElement
;
evt
.
currentTarget
=
(
sender
|
|
evt
.
srcElement
)
;
evt
.
layerX
=
evt
.
offsetX
;
evt
.
layerY
=
evt
.
offsetY
;
var
se
=
evt
.
srcElement
doc
=
(
se
&
&
se
.
ownerDocument
)
|
|
document
;
var
docBody
=
(
(
dojo
.
isIE
<
6
)
|
|
(
doc
[
"
compatMode
"
]
=
=
"
BackCompat
"
)
)
?
doc
.
body
:
doc
.
documentElement
;
var
offset
=
dojo
.
_getIeDocumentElementOffset
(
)
;
evt
.
pageX
=
evt
.
clientX
+
dojo
.
_fixIeBiDiScrollLeft
(
docBody
.
scrollLeft
|
|
0
)
-
offset
.
x
;
evt
.
pageY
=
evt
.
clientY
+
(
docBody
.
scrollTop
|
|
0
)
-
offset
.
y
;
if
(
evt
.
type
=
=
"
mouseover
"
)
{
evt
.
relatedTarget
=
evt
.
fromElement
;
}
if
(
evt
.
type
=
=
"
mouseout
"
)
{
evt
.
relatedTarget
=
evt
.
toElement
;
}
evt
.
stopPropagation
=
del
.
_stopPropagation
;
evt
.
preventDefault
=
del
.
_preventDefault
;
return
del
.
_fixKeys
(
evt
)
;
}
_fixKeys
:
function
(
evt
)
{
switch
(
evt
.
type
)
{
case
"
keypress
"
:
var
c
=
(
"
charCode
"
in
evt
?
evt
.
charCode
:
evt
.
keyCode
)
;
if
(
c
=
=
10
)
{
c
=
0
;
evt
.
keyCode
=
13
;
}
else
if
(
c
=
=
13
|
|
c
=
=
27
)
{
c
=
0
;
}
else
if
(
c
=
=
3
)
{
c
=
99
;
}
evt
.
charCode
=
c
;
del
.
_setKeyChar
(
evt
)
;
break
;
}
return
evt
;
}
_stealthKeyDown
:
function
(
evt
)
{
var
kp
=
evt
.
currentTarget
.
onkeypress
;
if
(
!
kp
|
|
!
kp
[
listenersName
]
)
{
return
;
}
var
k
=
evt
.
keyCode
;
var
unprintable
=
(
k
!
=
13
)
&
&
(
k
!
=
32
)
&
&
(
k
!
=
27
)
&
&
(
k
<
48
|
|
k
>
90
)
&
&
(
k
<
96
|
|
k
>
111
)
&
&
(
k
<
186
|
|
k
>
192
)
&
&
(
k
<
219
|
|
k
>
222
)
;
if
(
unprintable
|
|
evt
.
ctrlKey
)
{
var
c
=
unprintable
?
0
:
k
;
if
(
evt
.
ctrlKey
)
{
if
(
k
=
=
3
|
|
k
=
=
13
)
{
return
;
}
else
if
(
c
>
95
&
&
c
<
106
)
{
c
-
=
48
;
}
else
if
(
(
!
evt
.
shiftKey
)
&
&
(
c
>
=
65
&
&
c
<
=
90
)
)
{
c
+
=
32
;
}
else
{
c
=
del
.
_punctMap
[
c
]
|
|
c
;
}
}
var
faux
=
del
.
_synthesizeEvent
(
evt
{
type
:
'
keypress
'
faux
:
true
charCode
:
c
}
)
;
kp
.
call
(
evt
.
currentTarget
faux
)
;
evt
.
cancelBubble
=
faux
.
cancelBubble
;
evt
.
returnValue
=
faux
.
returnValue
;
_trySetKeyCode
(
evt
faux
.
keyCode
)
;
}
}
_stopPropagation
:
function
(
)
{
this
.
cancelBubble
=
true
;
}
_preventDefault
:
function
(
)
{
this
.
bubbledKeyCode
=
this
.
keyCode
;
if
(
this
.
ctrlKey
)
{
_trySetKeyCode
(
this
0
)
;
}
this
.
returnValue
=
false
;
}
}
)
;
dojo
.
stopEvent
=
function
(
evt
)
{
evt
=
evt
|
|
window
.
event
;
del
.
_stopPropagation
.
call
(
evt
)
;
del
.
_preventDefault
.
call
(
evt
)
;
}
}
del
.
_synthesizeEvent
=
function
(
evt
props
)
{
var
faux
=
dojo
.
mixin
(
{
}
evt
props
)
;
del
.
_setKeyChar
(
faux
)
;
faux
.
preventDefault
=
function
(
)
{
evt
.
preventDefault
(
)
;
}
;
faux
.
stopPropagation
=
function
(
)
{
evt
.
stopPropagation
(
)
;
}
;
return
faux
;
}
if
(
dojo
.
isOpera
)
{
dojo
.
mixin
(
del
{
_fixEvent
:
function
(
evt
sender
)
{
switch
(
evt
.
type
)
{
case
"
keypress
"
:
var
c
=
evt
.
which
;
if
(
c
=
=
3
)
{
c
=
99
;
}
c
=
(
(
c
<
41
)
&
&
(
!
evt
.
shiftKey
)
?
0
:
c
)
;
if
(
(
evt
.
ctrlKey
)
&
&
(
!
evt
.
shiftKey
)
&
&
(
c
>
=
65
)
&
&
(
c
<
=
90
)
)
{
c
+
=
32
;
}
return
del
.
_synthesizeEvent
(
evt
{
charCode
:
c
}
)
;
}
return
evt
;
}
}
)
;
}
if
(
dojo
.
isSafari
)
{
del
.
_add
=
del
.
add
;
del
.
_remove
=
del
.
remove
;
dojo
.
mixin
(
del
{
add
:
function
(
node
event
fp
)
{
if
(
!
node
)
{
return
;
}
var
handle
=
del
.
_add
(
node
event
fp
)
;
if
(
del
.
_normalizeEventName
(
event
)
=
=
"
keypress
"
)
{
handle
.
_stealthKeyDownHandle
=
del
.
_add
(
node
"
keydown
"
function
(
evt
)
{
var
k
=
evt
.
keyCode
;
var
unprintable
=
(
k
!
=
13
)
&
&
(
k
!
=
32
)
&
&
(
k
!
=
27
)
&
&
(
k
<
48
|
|
k
>
90
)
&
&
(
k
<
96
|
|
k
>
111
)
&
&
(
k
<
186
|
|
k
>
192
)
&
&
(
k
<
219
|
|
k
>
222
)
;
if
(
unprintable
|
|
evt
.
ctrlKey
)
{
var
c
=
unprintable
?
0
:
k
;
if
(
evt
.
ctrlKey
)
{
if
(
k
=
=
3
|
|
k
=
=
13
)
{
return
;
}
else
if
(
c
>
95
&
&
c
<
106
)
{
c
-
=
48
;
}
else
if
(
(
!
evt
.
shiftKey
)
&
&
(
c
>
=
65
&
&
c
<
=
90
)
)
{
c
+
=
32
;
}
else
{
c
=
del
.
_punctMap
[
c
]
|
|
c
;
}
}
var
faux
=
del
.
_synthesizeEvent
(
evt
{
type
:
'
keypress
'
faux
:
true
charCode
:
c
}
)
;
fp
.
call
(
evt
.
currentTarget
faux
)
;
}
}
)
;
}
return
handle
;
}
remove
:
function
(
node
event
handle
)
{
if
(
node
)
{
if
(
handle
.
_stealthKeyDownHandle
)
{
del
.
_remove
(
node
"
keydown
"
handle
.
_stealthKeyDownHandle
)
;
}
del
.
_remove
(
node
event
handle
)
;
}
}
_fixEvent
:
function
(
evt
sender
)
{
switch
(
evt
.
type
)
{
case
"
keypress
"
:
if
(
evt
.
faux
)
{
return
evt
;
}
var
c
=
evt
.
charCode
;
c
=
c
>
=
32
?
c
:
0
;
return
del
.
_synthesizeEvent
(
evt
{
charCode
:
c
faux
:
true
}
)
;
}
return
evt
;
}
}
)
;
}
}
)
(
)
;
if
(
dojo
.
isIE
)
{
dojo
.
_ieDispatcher
=
function
(
args
sender
)
{
var
ap
=
Array
.
prototype
h
=
dojo
.
_ie_listener
.
handlers
c
=
args
.
callee
ls
=
c
[
dojo
.
_ieListenersName
]
t
=
h
[
c
.
target
]
;
var
r
=
t
&
&
t
.
apply
(
sender
args
)
;
var
lls
=
[
]
.
concat
(
ls
)
;
for
(
var
i
in
lls
)
{
if
(
!
(
i
in
ap
)
)
{
h
[
lls
[
i
]
]
.
apply
(
sender
args
)
;
}
}
return
r
;
}
dojo
.
_getIeDispatcher
=
function
(
)
{
return
new
Function
(
dojo
.
_scopeName
+
"
.
_ieDispatcher
(
arguments
this
)
"
)
;
}
dojo
.
_event_listener
.
_fixCallback
=
function
(
fp
)
{
var
f
=
dojo
.
_event_listener
.
_fixEvent
;
return
function
(
e
)
{
return
fp
.
call
(
this
f
(
e
this
)
)
;
}
;
}
}
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
html
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
html
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
html
"
)
;
try
{
document
.
execCommand
(
"
BackgroundImageCache
"
false
true
)
;
}
catch
(
e
)
{
}
if
(
dojo
.
isIE
|
|
dojo
.
isOpera
)
{
dojo
.
byId
=
function
(
id
doc
)
{
if
(
dojo
.
isString
(
id
)
)
{
var
_d
=
doc
|
|
dojo
.
doc
;
var
te
=
_d
.
getElementById
(
id
)
;
if
(
te
&
&
te
.
attributes
.
id
.
value
=
=
id
)
{
return
te
;
}
else
{
var
eles
=
_d
.
all
[
id
]
;
if
(
!
eles
|
|
!
eles
.
length
)
{
return
eles
;
}
var
i
=
0
;
while
(
(
te
=
eles
[
i
+
+
]
)
)
{
if
(
te
.
attributes
.
id
.
value
=
=
id
)
{
return
te
;
}
}
}
}
else
{
return
id
;
}
}
}
else
{
dojo
.
byId
=
function
(
id
doc
)
{
return
dojo
.
isString
(
id
)
?
(
doc
|
|
dojo
.
doc
)
.
getElementById
(
id
)
:
id
;
}
}
(
function
(
)
{
var
d
=
dojo
;
var
_destroyContainer
=
null
;
dojo
.
addOnWindowUnload
(
function
(
)
{
_destroyContainer
=
null
;
}
)
;
dojo
.
_destroyElement
=
function
(
node
)
{
node
=
d
.
byId
(
node
)
;
try
{
if
(
!
_destroyContainer
|
|
_destroyContainer
.
ownerDocument
!
=
node
.
ownerDocument
)
{
_destroyContainer
=
node
.
ownerDocument
.
createElement
(
"
div
"
)
;
}
_destroyContainer
.
appendChild
(
node
.
parentNode
?
node
.
parentNode
.
removeChild
(
node
)
:
node
)
;
_destroyContainer
.
innerHTML
=
"
"
;
}
catch
(
e
)
{
}
}
;
dojo
.
isDescendant
=
function
(
node
ancestor
)
{
try
{
node
=
d
.
byId
(
node
)
;
ancestor
=
d
.
byId
(
ancestor
)
;
while
(
node
)
{
if
(
node
=
=
=
ancestor
)
{
return
true
;
}
node
=
node
.
parentNode
;
}
}
catch
(
e
)
{
}
return
false
;
}
;
dojo
.
setSelectable
=
function
(
node
selectable
)
{
node
=
d
.
byId
(
node
)
;
if
(
d
.
isMozilla
)
{
node
.
style
.
MozUserSelect
=
selectable
?
"
"
:
"
none
"
;
}
else
if
(
d
.
isKhtml
)
{
node
.
style
.
KhtmlUserSelect
=
selectable
?
"
auto
"
:
"
none
"
;
}
else
if
(
d
.
isIE
)
{
var
v
=
(
node
.
unselectable
=
selectable
?
"
"
:
"
on
"
)
;
d
.
query
(
"
*
"
node
)
.
forEach
(
"
item
.
unselectable
=
'
"
+
v
+
"
'
"
)
;
}
}
;
var
_insertBefore
=
function
(
node
ref
)
{
ref
.
parentNode
.
insertBefore
(
node
ref
)
;
return
true
;
}
var
_insertAfter
=
function
(
node
ref
)
{
var
pn
=
ref
.
parentNode
;
if
(
ref
=
=
pn
.
lastChild
)
{
pn
.
appendChild
(
node
)
;
}
else
{
return
_insertBefore
(
node
ref
.
nextSibling
)
;
}
return
true
;
}
dojo
.
place
=
function
(
node
refNode
position
)
{
if
(
!
node
|
|
!
refNode
)
{
return
false
;
}
node
=
d
.
byId
(
node
)
;
refNode
=
d
.
byId
(
refNode
)
;
if
(
typeof
position
=
=
"
number
"
)
{
var
cn
=
refNode
.
childNodes
;
if
(
!
cn
.
length
|
|
cn
.
length
<
=
position
)
{
refNode
.
appendChild
(
node
)
;
return
true
;
}
return
_insertBefore
(
node
position
<
=
0
?
refNode
.
firstChild
:
cn
[
position
]
)
;
}
switch
(
position
)
{
case
"
before
"
:
return
_insertBefore
(
node
refNode
)
;
case
"
after
"
:
return
_insertAfter
(
node
refNode
)
;
case
"
first
"
:
if
(
refNode
.
firstChild
)
{
return
_insertBefore
(
node
refNode
.
firstChild
)
;
}
default
:
refNode
.
appendChild
(
node
)
;
return
true
;
}
}
dojo
.
boxModel
=
"
content
-
box
"
;
if
(
d
.
isIE
)
{
var
_dcm
=
document
.
compatMode
;
d
.
boxModel
=
_dcm
=
=
"
BackCompat
"
|
|
_dcm
=
=
"
QuirksMode
"
|
|
d
.
isIE
<
6
?
"
border
-
box
"
:
"
content
-
box
"
;
}
var
gcs
;
if
(
d
.
isSafari
)
{
gcs
=
function
(
node
)
{
var
s
;
if
(
node
instanceof
HTMLElement
)
{
var
dv
=
node
.
ownerDocument
.
defaultView
;
s
=
dv
.
getComputedStyle
(
node
null
)
;
if
(
!
s
&
&
node
.
style
)
{
node
.
style
.
display
=
"
"
;
s
=
dv
.
getComputedStyle
(
node
null
)
;
}
}
return
s
|
|
{
}
;
}
;
}
else
if
(
d
.
isIE
)
{
gcs
=
function
(
node
)
{
return
node
.
nodeType
=
=
1
?
node
.
currentStyle
:
{
}
;
}
;
}
else
{
gcs
=
function
(
node
)
{
return
node
instanceof
HTMLElement
?
node
.
ownerDocument
.
defaultView
.
getComputedStyle
(
node
null
)
:
{
}
;
}
;
}
dojo
.
getComputedStyle
=
gcs
;
if
(
!
d
.
isIE
)
{
dojo
.
_toPixelValue
=
function
(
element
value
)
{
return
parseFloat
(
value
)
|
|
0
;
}
;
}
else
{
dojo
.
_toPixelValue
=
function
(
element
avalue
)
{
if
(
!
avalue
)
{
return
0
;
}
if
(
avalue
=
=
"
medium
"
)
{
return
4
;
}
if
(
avalue
.
slice
&
&
(
avalue
.
slice
(
-
2
)
=
=
'
px
'
)
)
{
return
parseFloat
(
avalue
)
;
}
with
(
element
)
{
var
sLeft
=
style
.
left
;
var
rsLeft
=
runtimeStyle
.
left
;
runtimeStyle
.
left
=
currentStyle
.
left
;
try
{
style
.
left
=
avalue
;
avalue
=
style
.
pixelLeft
;
}
catch
(
e
)
{
avalue
=
0
;
}
style
.
left
=
sLeft
;
runtimeStyle
.
left
=
rsLeft
;
}
return
avalue
;
}
}
var
px
=
d
.
_toPixelValue
;
var
astr
=
"
DXImageTransform
.
Microsoft
.
Alpha
"
;
var
af
=
function
(
n
f
)
{
try
{
return
n
.
filters
.
item
(
astr
)
;
}
catch
(
e
)
{
return
f
?
{
}
:
null
;
}
}
dojo
.
_getOpacity
=
d
.
isIE
?
function
(
node
)
{
try
{
return
af
(
node
)
.
Opacity
/
100
;
}
catch
(
e
)
{
return
1
;
}
}
:
function
(
node
)
{
return
gcs
(
node
)
.
opacity
;
}
;
dojo
.
_setOpacity
=
d
.
isIE
?
function
(
node
opacity
)
{
var
ov
=
opacity
*
100
;
node
.
style
.
zoom
=
1
.
0
;
af
(
node
1
)
.
Enabled
=
(
opacity
=
=
1
?
false
:
true
)
;
if
(
!
af
(
node
)
)
{
node
.
style
.
filter
+
=
"
progid
:
"
+
astr
+
"
(
Opacity
=
"
+
ov
+
"
)
"
;
}
else
{
af
(
node
1
)
.
Opacity
=
ov
;
}
if
(
node
.
nodeName
.
toLowerCase
(
)
=
=
"
tr
"
)
{
d
.
query
(
"
>
td
"
node
)
.
forEach
(
function
(
i
)
{
d
.
_setOpacity
(
i
opacity
)
;
}
)
;
}
return
opacity
;
}
:
function
(
node
opacity
)
{
return
node
.
style
.
opacity
=
opacity
;
}
;
var
_pixelNamesCache
=
{
left
:
true
top
:
true
}
;
var
_pixelRegExp
=
/
margin
|
padding
|
width
|
height
|
max
|
min
|
offset
/
;
var
_toStyleValue
=
function
(
node
type
value
)
{
type
=
type
.
toLowerCase
(
)
;
if
(
d
.
isIE
)
{
if
(
value
=
=
"
auto
"
)
{
if
(
type
=
=
"
height
"
)
{
return
node
.
offsetHeight
;
}
if
(
type
=
=
"
width
"
)
{
return
node
.
offsetWidth
;
}
}
if
(
type
=
=
"
fontweight
"
)
{
switch
(
value
)
{
case
700
:
return
"
bold
"
;
case
400
:
default
:
return
"
normal
"
;
}
}
}
if
(
!
(
type
in
_pixelNamesCache
)
)
{
_pixelNamesCache
[
type
]
=
_pixelRegExp
.
test
(
type
)
;
}
return
_pixelNamesCache
[
type
]
?
px
(
node
value
)
:
value
;
}
var
_floatStyle
=
d
.
isIE
?
"
styleFloat
"
:
"
cssFloat
"
;
var
_floatAliases
=
{
"
cssFloat
"
:
_floatStyle
"
styleFloat
"
:
_floatStyle
"
float
"
:
_floatStyle
}
;
dojo
.
style
=
function
(
node
style
value
)
{
var
n
=
d
.
byId
(
node
)
args
=
arguments
.
length
op
=
(
style
=
=
"
opacity
"
)
;
style
=
_floatAliases
[
style
]
|
|
style
;
if
(
args
=
=
3
)
{
return
op
?
d
.
_setOpacity
(
n
value
)
:
n
.
style
[
style
]
=
value
;
}
if
(
args
=
=
2
&
&
op
)
{
return
d
.
_getOpacity
(
n
)
;
}
var
s
=
gcs
(
n
)
;
if
(
args
=
=
2
&
&
!
d
.
isString
(
style
)
)
{
for
(
var
x
in
style
)
{
d
.
style
(
node
x
style
[
x
]
)
;
}
return
s
;
}
return
(
args
=
=
1
)
?
s
:
_toStyleValue
(
n
style
s
[
style
]
|
|
n
.
style
[
style
]
)
;
}
dojo
.
_getPadExtents
=
function
(
n
computedStyle
)
{
var
s
=
computedStyle
|
|
gcs
(
n
)
l
=
px
(
n
s
.
paddingLeft
)
t
=
px
(
n
s
.
paddingTop
)
;
return
{
l
:
l
t
:
t
w
:
l
+
px
(
n
s
.
paddingRight
)
h
:
t
+
px
(
n
s
.
paddingBottom
)
}
;
}
dojo
.
_getBorderExtents
=
function
(
n
computedStyle
)
{
var
ne
=
"
none
"
s
=
computedStyle
|
|
gcs
(
n
)
bl
=
(
s
.
borderLeftStyle
!
=
ne
?
px
(
n
s
.
borderLeftWidth
)
:
0
)
bt
=
(
s
.
borderTopStyle
!
=
ne
?
px
(
n
s
.
borderTopWidth
)
:
0
)
;
return
{
l
:
bl
t
:
bt
w
:
bl
+
(
s
.
borderRightStyle
!
=
ne
?
px
(
n
s
.
borderRightWidth
)
:
0
)
h
:
bt
+
(
s
.
borderBottomStyle
!
=
ne
?
px
(
n
s
.
borderBottomWidth
)
:
0
)
}
;
}
dojo
.
_getPadBorderExtents
=
function
(
n
computedStyle
)
{
var
s
=
computedStyle
|
|
gcs
(
n
)
p
=
d
.
_getPadExtents
(
n
s
)
b
=
d
.
_getBorderExtents
(
n
s
)
;
return
{
l
:
p
.
l
+
b
.
l
t
:
p
.
t
+
b
.
t
w
:
p
.
w
+
b
.
w
h
:
p
.
h
+
b
.
h
}
;
}
dojo
.
_getMarginExtents
=
function
(
n
computedStyle
)
{
var
s
=
computedStyle
|
|
gcs
(
n
)
l
=
px
(
n
s
.
marginLeft
)
t
=
px
(
n
s
.
marginTop
)
r
=
px
(
n
s
.
marginRight
)
b
=
px
(
n
s
.
marginBottom
)
;
if
(
d
.
isSafari
&
&
(
s
.
position
!
=
"
absolute
"
)
)
{
r
=
l
;
}
return
{
l
:
l
t
:
t
w
:
l
+
r
h
:
t
+
b
}
;
}
dojo
.
_getMarginBox
=
function
(
node
computedStyle
)
{
var
s
=
computedStyle
|
|
gcs
(
node
)
me
=
d
.
_getMarginExtents
(
node
s
)
;
var
l
=
node
.
offsetLeft
-
me
.
l
t
=
node
.
offsetTop
-
me
.
t
p
=
node
.
parentNode
;
if
(
d
.
isMoz
)
{
var
sl
=
parseFloat
(
s
.
left
)
st
=
parseFloat
(
s
.
top
)
;
if
(
!
isNaN
(
sl
)
&
&
!
isNaN
(
st
)
)
{
l
=
sl
t
=
st
;
}
else
{
if
(
p
&
&
p
.
style
)
{
var
pcs
=
gcs
(
p
)
;
if
(
pcs
.
overflow
!
=
"
visible
"
)
{
var
be
=
d
.
_getBorderExtents
(
p
pcs
)
;
l
+
=
be
.
l
t
+
=
be
.
t
;
}
}
}
}
else
if
(
d
.
isOpera
)
{
if
(
p
)
{
var
be
=
d
.
_getBorderExtents
(
p
)
;
l
-
=
be
.
l
;
t
-
=
be
.
t
;
}
}
return
{
l
:
l
t
:
t
w
:
node
.
offsetWidth
+
me
.
w
h
:
node
.
offsetHeight
+
me
.
h
}
;
}
dojo
.
_getContentBox
=
function
(
node
computedStyle
)
{
var
s
=
computedStyle
|
|
gcs
(
node
)
pe
=
d
.
_getPadExtents
(
node
s
)
be
=
d
.
_getBorderExtents
(
node
s
)
w
=
node
.
clientWidth
h
;
if
(
!
w
)
{
w
=
node
.
offsetWidth
h
=
node
.
offsetHeight
;
}
else
{
h
=
node
.
clientHeight
be
.
w
=
be
.
h
=
0
;
}
if
(
d
.
isOpera
)
{
pe
.
l
+
=
be
.
l
;
pe
.
t
+
=
be
.
t
;
}
;
return
{
l
:
pe
.
l
t
:
pe
.
t
w
:
w
-
pe
.
w
-
be
.
w
h
:
h
-
pe
.
h
-
be
.
h
}
;
}
dojo
.
_getBorderBox
=
function
(
node
computedStyle
)
{
var
s
=
computedStyle
|
|
gcs
(
node
)
pe
=
d
.
_getPadExtents
(
node
s
)
cb
=
d
.
_getContentBox
(
node
s
)
;
return
{
l
:
cb
.
l
-
pe
.
l
t
:
cb
.
t
-
pe
.
t
w
:
cb
.
w
+
pe
.
w
h
:
cb
.
h
+
pe
.
h
}
;
}
dojo
.
_setBox
=
function
(
node
l
t
w
h
u
)
{
u
=
u
|
|
"
px
"
;
var
s
=
node
.
style
;
if
(
!
isNaN
(
l
)
)
{
s
.
left
=
l
+
u
;
}
if
(
!
isNaN
(
t
)
)
{
s
.
top
=
t
+
u
;
}
if
(
w
>
=
0
)
{
s
.
width
=
w
+
u
;
}
if
(
h
>
=
0
)
{
s
.
height
=
h
+
u
;
}
}
dojo
.
_isButtonTag
=
function
(
node
)
{
return
node
.
tagName
=
=
"
BUTTON
"
|
|
node
.
tagName
=
=
"
INPUT
"
&
&
node
.
getAttribute
(
"
type
"
)
.
toUpperCase
(
)
=
=
"
BUTTON
"
;
}
dojo
.
_usesBorderBox
=
function
(
node
)
{
var
n
=
node
.
tagName
;
return
d
.
boxModel
=
=
"
border
-
box
"
|
|
n
=
=
"
TABLE
"
|
|
dojo
.
_isButtonTag
(
node
)
;
}
dojo
.
_setContentSize
=
function
(
node
widthPx
heightPx
computedStyle
)
{
if
(
d
.
_usesBorderBox
(
node
)
)
{
var
pb
=
d
.
_getPadBorderExtents
(
node
computedStyle
)
;
if
(
widthPx
>
=
0
)
{
widthPx
+
=
pb
.
w
;
}
if
(
heightPx
>
=
0
)
{
heightPx
+
=
pb
.
h
;
}
}
d
.
_setBox
(
node
NaN
NaN
widthPx
heightPx
)
;
}
dojo
.
_setMarginBox
=
function
(
node
leftPx
topPx
widthPx
heightPx
computedStyle
)
{
var
s
=
computedStyle
|
|
gcs
(
node
)
;
var
bb
=
d
.
_usesBorderBox
(
node
)
pb
=
bb
?
_nilExtents
:
d
.
_getPadBorderExtents
(
node
s
)
;
if
(
dojo
.
isSafari
)
{
if
(
dojo
.
_isButtonTag
(
node
)
)
{
var
ns
=
node
.
style
;
if
(
widthPx
>
=
0
&
&
!
ns
.
width
)
{
ns
.
width
=
"
4px
"
;
}
if
(
heightPx
>
=
0
&
&
!
ns
.
height
)
{
ns
.
height
=
"
4px
"
;
}
}
}
var
mb
=
d
.
_getMarginExtents
(
node
s
)
;
if
(
widthPx
>
=
0
)
{
widthPx
=
Math
.
max
(
widthPx
-
pb
.
w
-
mb
.
w
0
)
;
}
if
(
heightPx
>
=
0
)
{
heightPx
=
Math
.
max
(
heightPx
-
pb
.
h
-
mb
.
h
0
)
;
}
d
.
_setBox
(
node
leftPx
topPx
widthPx
heightPx
)
;
}
var
_nilExtents
=
{
l
:
0
t
:
0
w
:
0
h
:
0
}
;
dojo
.
marginBox
=
function
(
node
box
)
{
var
n
=
d
.
byId
(
node
)
s
=
gcs
(
n
)
b
=
box
;
return
!
b
?
d
.
_getMarginBox
(
n
s
)
:
d
.
_setMarginBox
(
n
b
.
l
b
.
t
b
.
w
b
.
h
s
)
;
}
dojo
.
contentBox
=
function
(
node
box
)
{
var
n
=
d
.
byId
(
node
)
s
=
gcs
(
n
)
b
=
box
;
return
!
b
?
d
.
_getContentBox
(
n
s
)
:
d
.
_setContentSize
(
n
b
.
w
b
.
h
s
)
;
}
var
_sumAncestorProperties
=
function
(
node
prop
)
{
if
(
!
(
node
=
(
node
|
|
0
)
.
parentNode
)
)
{
return
0
}
;
var
val
retVal
=
0
_b
=
d
.
body
(
)
;
while
(
node
&
&
node
.
style
)
{
if
(
gcs
(
node
)
.
position
=
=
"
fixed
"
)
{
return
0
;
}
val
=
node
[
prop
]
;
if
(
val
)
{
retVal
+
=
val
-
0
;
if
(
node
=
=
_b
)
{
break
;
}
}
node
=
node
.
parentNode
;
}
return
retVal
;
}
dojo
.
_docScroll
=
function
(
)
{
var
_b
=
d
.
body
(
)
_w
=
d
.
global
de
=
d
.
doc
.
documentElement
;
return
{
y
:
(
_w
.
pageYOffset
|
|
de
.
scrollTop
|
|
_b
.
scrollTop
|
|
0
)
x
:
(
_w
.
pageXOffset
|
|
d
.
_fixIeBiDiScrollLeft
(
de
.
scrollLeft
)
|
|
_b
.
scrollLeft
|
|
0
)
}
;
}
;
dojo
.
_isBodyLtr
=
function
(
)
{
return
!
(
"
_bodyLtr
"
in
d
)
?
d
.
_bodyLtr
=
gcs
(
d
.
body
(
)
)
.
direction
=
=
"
ltr
"
:
d
.
_bodyLtr
;
}
dojo
.
_getIeDocumentElementOffset
=
function
(
)
{
var
de
=
d
.
doc
.
documentElement
;
return
(
d
.
isIE
>
=
7
)
?
{
x
:
de
.
getBoundingClientRect
(
)
.
left
y
:
de
.
getBoundingClientRect
(
)
.
top
}
:
{
x
:
d
.
_isBodyLtr
(
)
|
|
window
.
parent
=
=
window
?
de
.
clientLeft
:
de
.
offsetWidth
-
de
.
clientWidth
-
de
.
clientLeft
y
:
de
.
clientTop
}
;
}
;
dojo
.
_fixIeBiDiScrollLeft
=
function
(
scrollLeft
)
{
var
dd
=
d
.
doc
;
if
(
d
.
isIE
&
&
!
dojo
.
_isBodyLtr
(
)
)
{
var
de
=
dd
.
compatMode
=
=
"
BackCompat
"
?
dd
.
body
:
dd
.
documentElement
;
return
scrollLeft
+
de
.
clientWidth
-
de
.
scrollWidth
;
}
return
scrollLeft
;
}
dojo
.
_abs
=
function
(
node
includeScroll
)
{
var
ownerDocument
=
node
.
ownerDocument
;
var
ret
=
{
x
:
0
y
:
0
}
;
var
db
=
d
.
body
(
)
;
if
(
d
.
isIE
|
|
(
d
.
isFF
>
=
3
)
)
{
var
client
=
node
.
getBoundingClientRect
(
)
;
var
cs
;
if
(
d
.
isFF
)
{
var
dv
=
node
.
ownerDocument
.
defaultView
;
cs
=
dv
.
getComputedStyle
(
db
.
parentNode
null
)
;
}
var
offset
=
(
d
.
isIE
)
?
d
.
_getIeDocumentElementOffset
(
)
:
{
x
:
px
(
db
.
parentNode
cs
.
marginLeft
)
y
:
px
(
db
.
parentNode
cs
.
marginTop
)
}
;
ret
.
x
=
client
.
left
-
offset
.
x
;
ret
.
y
=
client
.
top
-
offset
.
y
;
}
else
{
if
(
node
[
"
offsetParent
"
]
)
{
var
endNode
;
if
(
d
.
isSafari
&
&
(
gcs
(
node
)
.
position
=
=
"
absolute
"
)
&
&
(
node
.
parentNode
=
=
db
)
)
{
endNode
=
db
;
}
else
{
endNode
=
db
.
parentNode
;
}
var
cs
=
gcs
(
node
)
;
var
n
=
node
;
if
(
d
.
isOpera
&
&
cs
.
position
!
=
"
absolute
"
)
{
n
=
n
.
offsetParent
;
}
ret
.
x
-
=
_sumAncestorProperties
(
n
"
scrollLeft
"
)
;
ret
.
y
-
=
_sumAncestorProperties
(
n
"
scrollTop
"
)
;
var
curnode
=
node
;
do
{
var
n
=
curnode
.
offsetLeft
;
if
(
!
d
.
isOpera
|
|
n
>
0
)
{
ret
.
x
+
=
isNaN
(
n
)
?
0
:
n
;
}
var
t
=
curnode
.
offsetTop
;
ret
.
y
+
=
isNaN
(
t
)
?
0
:
t
;
var
cs
=
gcs
(
curnode
)
;
if
(
curnode
!
=
node
)
{
if
(
d
.
isSafari
)
{
ret
.
x
+
=
px
(
curnode
cs
.
borderLeftWidth
)
;
ret
.
y
+
=
px
(
curnode
cs
.
borderTopWidth
)
;
}
else
if
(
d
.
isFF
)
{
ret
.
x
+
=
2
*
px
(
curnode
cs
.
borderLeftWidth
)
;
ret
.
y
+
=
2
*
px
(
curnode
cs
.
borderTopWidth
)
;
}
}
if
(
d
.
isFF
&
&
cs
.
position
=
=
"
static
"
)
{
var
parent
=
curnode
.
parentNode
;
while
(
parent
!
=
curnode
.
offsetParent
)
{
var
pcs
=
gcs
(
parent
)
;
if
(
pcs
.
position
=
=
"
static
"
)
{
ret
.
x
+
=
px
(
curnode
pcs
.
borderLeftWidth
)
;
ret
.
y
+
=
px
(
curnode
pcs
.
borderTopWidth
)
;
}
parent
=
parent
.
parentNode
;
}
}
curnode
=
curnode
.
offsetParent
;
}
while
(
(
curnode
!
=
endNode
)
&
&
curnode
)
;
}
else
if
(
node
.
x
&
&
node
.
y
)
{
ret
.
x
+
=
isNaN
(
node
.
x
)
?
0
:
node
.
x
;
ret
.
y
+
=
isNaN
(
node
.
y
)
?
0
:
node
.
y
;
}
}
if
(
includeScroll
)
{
var
scroll
=
d
.
_docScroll
(
)
;
ret
.
y
+
=
scroll
.
y
;
ret
.
x
+
=
scroll
.
x
;
}
return
ret
;
}
dojo
.
coords
=
function
(
node
includeScroll
)
{
var
n
=
d
.
byId
(
node
)
s
=
gcs
(
n
)
mb
=
d
.
_getMarginBox
(
n
s
)
;
var
abs
=
d
.
_abs
(
n
includeScroll
)
;
mb
.
x
=
abs
.
x
;
mb
.
y
=
abs
.
y
;
return
mb
;
}
var
ieLT8
=
d
.
isIE
<
8
;
var
_fixAttrName
=
function
(
name
)
{
switch
(
name
.
toLowerCase
(
)
)
{
case
"
tabindex
"
:
return
ieLT8
?
"
tabIndex
"
:
"
tabindex
"
;
case
"
for
"
:
case
"
htmlfor
"
:
return
ieLT8
?
"
htmlFor
"
:
"
for
"
;
case
"
class
"
:
return
d
.
isIE
?
"
className
"
:
"
class
"
;
default
:
return
name
;
}
}
var
_attrProps
=
{
colspan
:
"
colSpan
"
enctype
:
"
enctype
"
frameborder
:
"
frameborder
"
method
:
"
method
"
rowspan
:
"
rowSpan
"
scrolling
:
"
scrolling
"
shape
:
"
shape
"
span
:
"
span
"
type
:
"
type
"
valuetype
:
"
valueType
"
}
dojo
.
hasAttr
=
function
(
node
name
)
{
node
=
d
.
byId
(
node
)
;
var
fixName
=
_fixAttrName
(
name
)
;
fixName
=
fixName
=
=
"
htmlFor
"
?
"
for
"
:
fixName
;
var
attr
=
node
.
getAttributeNode
&
&
node
.
getAttributeNode
(
fixName
)
;
return
attr
?
attr
.
specified
:
false
;
}
var
_evtHdlrMap
=
{
}
var
_ctr
=
0
;
var
_attrId
=
dojo
.
_scopeName
+
"
attrid
"
;
dojo
.
attr
=
function
(
node
name
value
)
{
var
args
=
arguments
.
length
;
if
(
args
=
=
2
&
&
!
d
.
isString
(
name
)
)
{
for
(
var
x
in
name
)
{
d
.
attr
(
node
x
name
[
x
]
)
;
}
return
;
}
node
=
d
.
byId
(
node
)
;
name
=
_fixAttrName
(
name
)
;
if
(
args
=
=
3
)
{
if
(
d
.
isFunction
(
value
)
)
{
var
attrId
=
d
.
attr
(
node
_attrId
)
;
if
(
!
attrId
)
{
attrId
=
_ctr
+
+
;
d
.
attr
(
node
_attrId
attrId
)
;
}
if
(
!
_evtHdlrMap
[
attrId
]
)
{
_evtHdlrMap
[
attrId
]
=
{
}
;
}
var
h
=
_evtHdlrMap
[
attrId
]
[
name
]
;
if
(
h
)
{
d
.
disconnect
(
h
)
;
}
else
{
try
{
delete
node
[
name
]
;
}
catch
(
e
)
{
}
}
_evtHdlrMap
[
attrId
]
[
name
]
=
d
.
connect
(
node
name
value
)
;
}
else
if
(
(
typeof
value
=
=
"
boolean
"
)
|
|
(
name
=
=
"
innerHTML
"
)
)
{
node
[
name
]
=
value
;
}
else
if
(
(
name
=
=
"
style
"
)
&
&
(
!
d
.
isString
(
value
)
)
)
{
d
.
style
(
node
value
)
;
}
else
{
node
.
setAttribute
(
name
value
)
;
}
return
;
}
else
{
var
prop
=
_attrProps
[
name
.
toLowerCase
(
)
]
;
if
(
prop
)
{
return
node
[
prop
]
;
}
else
{
var
attrValue
=
node
[
name
]
;
return
(
typeof
attrValue
=
=
'
boolean
'
|
|
typeof
attrValue
=
=
'
function
'
)
?
attrValue
:
(
d
.
hasAttr
(
node
name
)
?
node
.
getAttribute
(
name
)
:
null
)
;
}
}
}
dojo
.
removeAttr
=
function
(
node
name
)
{
d
.
byId
(
node
)
.
removeAttribute
(
_fixAttrName
(
name
)
)
;
}
var
_className
=
"
className
"
;
dojo
.
hasClass
=
function
(
node
classStr
)
{
return
(
(
"
"
+
d
.
byId
(
node
)
[
_className
]
+
"
"
)
.
indexOf
(
"
"
+
classStr
+
"
"
)
>
=
0
)
;
}
;
dojo
.
addClass
=
function
(
node
classStr
)
{
node
=
d
.
byId
(
node
)
;
var
cls
=
node
[
_className
]
;
if
(
(
"
"
+
cls
+
"
"
)
.
indexOf
(
"
"
+
classStr
+
"
"
)
<
0
)
{
node
[
_className
]
=
cls
+
(
cls
?
'
'
:
'
'
)
+
classStr
;
}
}
;
dojo
.
removeClass
=
function
(
node
classStr
)
{
node
=
d
.
byId
(
node
)
;
var
t
=
d
.
trim
(
(
"
"
+
node
[
_className
]
+
"
"
)
.
replace
(
"
"
+
classStr
+
"
"
"
"
)
)
;
if
(
node
[
_className
]
!
=
t
)
{
node
[
_className
]
=
t
;
}
}
;
dojo
.
toggleClass
=
function
(
node
classStr
condition
)
{
if
(
condition
=
=
=
undefined
)
{
condition
=
!
d
.
hasClass
(
node
classStr
)
;
}
d
[
condition
?
"
addClass
"
:
"
removeClass
"
]
(
node
classStr
)
;
}
;
}
)
(
)
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
NodeList
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
NodeList
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
NodeList
"
)
;
(
function
(
)
{
var
d
=
dojo
;
var
tnl
=
function
(
arr
)
{
arr
.
constructor
=
dojo
.
NodeList
;
dojo
.
_mixin
(
arr
dojo
.
NodeList
.
prototype
)
;
return
arr
;
}
var
_mapIntoDojo
=
function
(
func
alwaysThis
)
{
return
function
(
)
{
var
_a
=
arguments
;
var
aa
=
d
.
_toArray
(
_a
0
[
null
]
)
;
var
s
=
this
.
map
(
function
(
i
)
{
aa
[
0
]
=
i
;
return
d
[
func
]
.
apply
(
d
aa
)
;
}
)
;
return
(
alwaysThis
|
|
(
(
_a
.
length
>
1
)
|
|
!
d
.
isString
(
_a
[
0
]
)
)
)
?
this
:
s
;
}
}
;
dojo
.
NodeList
=
function
(
)
{
return
tnl
(
Array
.
apply
(
null
arguments
)
)
;
}
dojo
.
NodeList
.
_wrap
=
tnl
;
dojo
.
extend
(
dojo
.
NodeList
{
slice
:
function
(
)
{
var
a
=
d
.
_toArray
(
arguments
)
;
return
tnl
(
a
.
slice
.
apply
(
this
a
)
)
;
}
splice
:
function
(
)
{
var
a
=
d
.
_toArray
(
arguments
)
;
return
tnl
(
a
.
splice
.
apply
(
this
a
)
)
;
}
concat
:
function
(
)
{
var
a
=
d
.
_toArray
(
arguments
0
[
this
]
)
;
return
tnl
(
a
.
concat
.
apply
(
[
]
a
)
)
;
}
indexOf
:
function
(
value
fromIndex
)
{
return
d
.
indexOf
(
this
value
fromIndex
)
;
}
lastIndexOf
:
function
(
)
{
return
d
.
lastIndexOf
.
apply
(
d
d
.
_toArray
(
arguments
0
[
this
]
)
)
;
}
every
:
function
(
callback
thisObject
)
{
return
d
.
every
(
this
callback
thisObject
)
;
}
some
:
function
(
callback
thisObject
)
{
return
d
.
some
(
this
callback
thisObject
)
;
}
map
:
function
(
func
obj
)
{
return
d
.
map
(
this
func
obj
d
.
NodeList
)
;
}
forEach
:
function
(
callback
thisObj
)
{
d
.
forEach
(
this
callback
thisObj
)
;
return
this
;
}
coords
:
function
(
)
{
return
d
.
map
(
this
d
.
coords
)
;
}
attr
:
_mapIntoDojo
(
"
attr
"
)
style
:
_mapIntoDojo
(
"
style
"
)
addClass
:
_mapIntoDojo
(
"
addClass
"
true
)
removeClass
:
_mapIntoDojo
(
"
removeClass
"
true
)
toggleClass
:
_mapIntoDojo
(
"
toggleClass
"
true
)
connect
:
_mapIntoDojo
(
"
connect
"
true
)
place
:
function
(
queryOrNode
position
)
{
var
item
=
d
.
query
(
queryOrNode
)
[
0
]
;
return
this
.
forEach
(
function
(
i
)
{
d
.
place
(
i
item
position
)
;
}
)
;
}
orphan
:
function
(
simpleFilter
)
{
return
(
simpleFilter
?
d
.
_filterQueryResult
(
this
simpleFilter
)
:
this
)
.
forEach
(
"
if
(
item
.
parentNode
)
{
item
.
parentNode
.
removeChild
(
item
)
;
}
"
)
;
}
adopt
:
function
(
queryOrListOrNode
position
)
{
var
item
=
this
[
0
]
;
return
d
.
query
(
queryOrListOrNode
)
.
forEach
(
function
(
ai
)
{
d
.
place
(
ai
item
position
|
|
"
last
"
)
;
}
)
;
}
query
:
function
(
queryStr
)
{
if
(
!
queryStr
)
{
return
this
;
}
var
ret
=
d
.
NodeList
(
)
;
this
.
forEach
(
function
(
item
)
{
ret
=
ret
.
concat
(
d
.
query
(
queryStr
item
)
.
filter
(
function
(
subItem
)
{
return
(
subItem
!
=
=
undefined
)
;
}
)
)
;
}
)
;
return
ret
;
}
filter
:
function
(
simpleQuery
)
{
var
items
=
this
;
var
_a
=
arguments
;
var
r
=
d
.
NodeList
(
)
;
var
rp
=
function
(
t
)
{
if
(
t
!
=
=
undefined
)
{
r
.
push
(
t
)
;
}
}
if
(
d
.
isString
(
simpleQuery
)
)
{
items
=
d
.
_filterQueryResult
(
this
_a
[
0
]
)
;
if
(
_a
.
length
=
=
1
)
{
return
items
;
}
_a
.
shift
(
)
;
}
d
.
forEach
(
d
.
filter
(
items
_a
[
0
]
_a
[
1
]
)
rp
)
;
return
r
;
}
addContent
:
function
(
content
position
)
{
var
ta
=
d
.
doc
.
createElement
(
"
span
"
)
;
if
(
d
.
isString
(
content
)
)
{
ta
.
innerHTML
=
content
;
}
else
{
ta
.
appendChild
(
content
)
;
}
if
(
position
=
=
=
undefined
)
{
position
=
"
last
"
;
}
var
ct
=
(
position
=
=
"
first
"
|
|
position
=
=
"
after
"
)
?
"
lastChild
"
:
"
firstChild
"
;
this
.
forEach
(
function
(
item
)
{
var
tn
=
ta
.
cloneNode
(
true
)
;
while
(
tn
[
ct
]
)
{
d
.
place
(
tn
[
ct
]
item
position
)
;
}
}
)
;
return
this
;
}
empty
:
function
(
)
{
return
this
.
forEach
(
"
item
.
innerHTML
=
'
'
;
"
)
;
}
instantiate
:
function
(
declaredClass
properties
)
{
var
c
=
d
.
isFunction
(
declaredClass
)
?
declaredClass
:
d
.
getObject
(
declaredClass
)
;
return
this
.
forEach
(
function
(
i
)
{
new
c
(
properties
|
|
{
}
i
)
;
}
)
}
at
:
function
(
)
{
var
nl
=
new
dojo
.
NodeList
(
)
;
dojo
.
forEach
(
arguments
function
(
i
)
{
if
(
this
[
i
]
)
{
nl
.
push
(
this
[
i
]
)
;
}
}
this
)
;
return
nl
;
}
}
)
;
d
.
forEach
(
[
"
blur
"
"
focus
"
"
click
"
"
keydown
"
"
keypress
"
"
keyup
"
"
mousedown
"
"
mouseenter
"
"
mouseleave
"
"
mousemove
"
"
mouseout
"
"
mouseover
"
"
mouseup
"
"
submit
"
"
load
"
"
error
"
]
function
(
evt
)
{
var
_oe
=
"
on
"
+
evt
;
d
.
NodeList
.
prototype
[
_oe
]
=
function
(
a
b
)
{
return
this
.
connect
(
_oe
a
b
)
;
}
}
)
;
}
)
(
)
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
query
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
query
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
query
"
)
;
;
(
function
(
)
{
var
d
=
dojo
;
var
childNodesName
=
dojo
.
isIE
?
"
children
"
:
"
childNodes
"
;
var
caseSensitive
=
false
;
var
getQueryParts
=
function
(
query
)
{
if
(
"
>
~
+
"
.
indexOf
(
query
.
charAt
(
query
.
length
-
1
)
)
>
=
0
)
{
query
+
=
"
*
"
}
query
+
=
"
"
;
var
ts
=
function
(
s
e
)
{
return
d
.
trim
(
query
.
slice
(
s
e
)
)
;
}
var
qparts
=
[
]
;
var
inBrackets
=
-
1
;
var
inParens
=
-
1
;
var
inMatchFor
=
-
1
;
var
inPseudo
=
-
1
;
var
inClass
=
-
1
;
var
inId
=
-
1
;
var
inTag
=
-
1
;
var
lc
=
"
"
;
var
cc
=
"
"
;
var
pStart
;
var
x
=
0
;
var
ql
=
query
.
length
;
var
currentPart
=
null
;
var
_cp
=
null
;
var
endTag
=
function
(
)
{
if
(
inTag
>
=
0
)
{
var
tv
=
(
inTag
=
=
x
)
?
null
:
ts
(
inTag
x
)
;
currentPart
[
(
"
>
~
+
"
.
indexOf
(
tv
)
<
0
)
?
"
tag
"
:
"
oper
"
]
=
tv
;
inTag
=
-
1
;
}
}
var
endId
=
function
(
)
{
if
(
inId
>
=
0
)
{
currentPart
.
id
=
ts
(
inId
x
)
.
replace
(
/
\
\
/
g
"
"
)
;
inId
=
-
1
;
}
}
var
endClass
=
function
(
)
{
if
(
inClass
>
=
0
)
{
currentPart
.
classes
.
push
(
ts
(
inClass
+
1
x
)
.
replace
(
/
\
\
/
g
"
"
)
)
;
inClass
=
-
1
;
}
}
var
endAll
=
function
(
)
{
endId
(
)
;
endTag
(
)
;
endClass
(
)
;
}
for
(
;
lc
=
cc
cc
=
query
.
charAt
(
x
)
x
<
ql
;
x
+
+
)
{
if
(
lc
=
=
"
\
\
"
)
{
continue
;
}
if
(
!
currentPart
)
{
pStart
=
x
;
currentPart
=
{
query
:
null
pseudos
:
[
]
attrs
:
[
]
classes
:
[
]
tag
:
null
oper
:
null
id
:
null
}
;
inTag
=
x
;
}
if
(
inBrackets
>
=
0
)
{
if
(
cc
=
=
"
]
"
)
{
if
(
!
_cp
.
attr
)
{
_cp
.
attr
=
ts
(
inBrackets
+
1
x
)
;
}
else
{
_cp
.
matchFor
=
ts
(
(
inMatchFor
|
|
inBrackets
+
1
)
x
)
;
}
var
cmf
=
_cp
.
matchFor
;
if
(
cmf
)
{
if
(
(
cmf
.
charAt
(
0
)
=
=
'
"
'
)
|
|
(
cmf
.
charAt
(
0
)
=
=
"
'
"
)
)
{
_cp
.
matchFor
=
cmf
.
substring
(
1
cmf
.
length
-
1
)
;
}
}
currentPart
.
attrs
.
push
(
_cp
)
;
_cp
=
null
;
inBrackets
=
inMatchFor
=
-
1
;
}
else
if
(
cc
=
=
"
=
"
)
{
var
addToCc
=
(
"
|
~
^
*
"
.
indexOf
(
lc
)
>
=
0
)
?
lc
:
"
"
;
_cp
.
type
=
addToCc
+
cc
;
_cp
.
attr
=
ts
(
inBrackets
+
1
x
-
addToCc
.
length
)
;
inMatchFor
=
x
+
1
;
}
}
else
if
(
inParens
>
=
0
)
{
if
(
cc
=
=
"
)
"
)
{
if
(
inPseudo
>
=
0
)
{
_cp
.
value
=
ts
(
inParens
+
1
x
)
;
}
inPseudo
=
inParens
=
-
1
;
}
}
else
if
(
cc
=
=
"
#
"
)
{
endAll
(
)
;
inId
=
x
+
1
;
}
else
if
(
cc
=
=
"
.
"
)
{
endAll
(
)
;
inClass
=
x
;
}
else
if
(
cc
=
=
"
:
"
)
{
endAll
(
)
;
inPseudo
=
x
;
}
else
if
(
cc
=
=
"
[
"
)
{
endAll
(
)
;
inBrackets
=
x
;
_cp
=
{
}
;
}
else
if
(
cc
=
=
"
(
"
)
{
if
(
inPseudo
>
=
0
)
{
_cp
=
{
name
:
ts
(
inPseudo
+
1
x
)
value
:
null
}
currentPart
.
pseudos
.
push
(
_cp
)
;
}
inParens
=
x
;
}
else
if
(
cc
=
=
"
"
&
&
lc
!
=
cc
)
{
endAll
(
)
;
if
(
inPseudo
>
=
0
)
{
currentPart
.
pseudos
.
push
(
{
name
:
ts
(
inPseudo
+
1
x
)
}
)
;
}
currentPart
.
hasLoops
=
(
currentPart
.
pseudos
.
length
|
|
currentPart
.
attrs
.
length
|
|
currentPart
.
classes
.
length
)
;
currentPart
.
query
=
ts
(
pStart
x
)
;
currentPart
.
otag
=
currentPart
.
tag
=
(
currentPart
[
"
oper
"
]
)
?
null
:
(
currentPart
.
tag
|
|
"
*
"
)
;
if
(
currentPart
.
tag
)
{
currentPart
.
tag
=
currentPart
.
tag
.
toUpperCase
(
)
;
}
qparts
.
push
(
currentPart
)
;
currentPart
=
null
;
}
}
return
qparts
;
}
;
var
xPathAttrs
=
{
"
*
=
"
:
function
(
attr
value
)
{
return
"
[
contains
(
"
+
attr
+
"
'
"
+
value
+
"
'
)
]
"
;
}
"
^
=
"
:
function
(
attr
value
)
{
return
"
[
starts
-
with
(
"
+
attr
+
"
'
"
+
value
+
"
'
)
]
"
;
}
"
=
"
:
function
(
attr
value
)
{
return
"
[
substring
(
"
+
attr
+
"
string
-
length
(
"
+
attr
+
"
)
-
"
+
(
value
.
length
-
1
)
+
"
)
=
'
"
+
value
+
"
'
]
"
;
}
"
~
=
"
:
function
(
attr
value
)
{
return
"
[
contains
(
concat
(
'
'
"
+
attr
+
"
'
'
)
'
"
+
value
+
"
'
)
]
"
;
}
"
|
=
"
:
function
(
attr
value
)
{
return
"
[
contains
(
concat
(
'
'
"
+
attr
+
"
'
'
)
'
"
+
value
+
"
-
'
)
]
"
;
}
"
=
"
:
function
(
attr
value
)
{
return
"
[
"
+
attr
+
"
=
'
"
+
value
+
"
'
]
"
;
}
}
;
var
handleAttrs
=
function
(
attrList
query
getDefault
handleMatch
)
{
d
.
forEach
(
query
.
attrs
function
(
attr
)
{
var
matcher
;
if
(
attr
.
type
&
&
attrList
[
attr
.
type
]
)
{
matcher
=
attrList
[
attr
.
type
]
(
attr
.
attr
attr
.
matchFor
)
;
}
else
if
(
attr
.
attr
.
length
)
{
matcher
=
getDefault
(
attr
.
attr
)
;
}
if
(
matcher
)
{
handleMatch
(
matcher
)
;
}
}
)
;
}
var
buildPath
=
function
(
query
)
{
var
xpath
=
"
.
"
;
var
qparts
=
getQueryParts
(
d
.
trim
(
query
)
)
;
while
(
qparts
.
length
)
{
var
tqp
=
qparts
.
shift
(
)
;
var
prefix
;
var
postfix
=
"
"
;
if
(
tqp
.
oper
=
=
"
>
"
)
{
prefix
=
"
/
"
;
tqp
=
qparts
.
shift
(
)
;
}
else
if
(
tqp
.
oper
=
=
"
~
"
)
{
prefix
=
"
/
following
-
sibling
:
:
"
;
tqp
=
qparts
.
shift
(
)
;
}
else
if
(
tqp
.
oper
=
=
"
+
"
)
{
prefix
=
"
/
following
-
sibling
:
:
"
;
postfix
=
"
[
position
(
)
=
1
]
"
;
tqp
=
qparts
.
shift
(
)
;
}
else
{
prefix
=
"
/
/
"
;
}
xpath
+
=
prefix
+
tqp
.
tag
+
postfix
;
if
(
tqp
.
id
)
{
xpath
+
=
"
[
id
=
'
"
+
tqp
.
id
+
"
'
]
[
1
]
"
;
}
d
.
forEach
(
tqp
.
classes
function
(
cn
)
{
var
cnl
=
cn
.
length
;
var
padding
=
"
"
;
if
(
cn
.
charAt
(
cnl
-
1
)
=
=
"
*
"
)
{
padding
=
"
"
;
cn
=
cn
.
substr
(
0
cnl
-
1
)
;
}
xpath
+
=
"
[
contains
(
concat
(
'
'
class
'
'
)
'
"
+
cn
+
padding
+
"
'
)
]
"
;
}
)
;
handleAttrs
(
xPathAttrs
tqp
function
(
condition
)
{
return
"
[
"
+
condition
+
"
]
"
;
}
function
(
matcher
)
{
xpath
+
=
matcher
;
}
)
;
}
;
return
xpath
;
}
;
var
_xpathFuncCache
=
{
}
;
var
getXPathFunc
=
function
(
path
)
{
if
(
_xpathFuncCache
[
path
]
)
{
return
_xpathFuncCache
[
path
]
;
}
var
doc
=
d
.
doc
;
var
xpath
=
buildPath
(
path
)
;
var
tf
=
function
(
parent
)
{
var
ret
=
[
]
;
var
xpathResult
;
var
tdoc
=
doc
;
if
(
parent
)
{
tdoc
=
(
parent
.
nodeType
=
=
9
)
?
parent
:
parent
.
ownerDocument
;
}
try
{
xpathResult
=
tdoc
.
evaluate
(
xpath
parent
null
XPathResult
.
ANY_TYPE
null
)
;
}
catch
(
e
)
{
}
var
result
=
xpathResult
.
iterateNext
(
)
;
while
(
result
)
{
ret
.
push
(
result
)
;
result
=
xpathResult
.
iterateNext
(
)
;
}
return
ret
;
}
return
_xpathFuncCache
[
path
]
=
tf
;
}
;
var
_filtersCache
=
{
}
;
var
_simpleFiltersCache
=
{
}
;
var
agree
=
function
(
first
second
)
{
if
(
!
first
)
{
return
second
;
}
if
(
!
second
)
{
return
first
;
}
return
function
(
)
{
return
first
.
apply
(
window
arguments
)
&
&
second
.
apply
(
window
arguments
)
;
}
}
var
_childElements
=
function
(
root
)
{
var
ret
=
[
]
;
var
te
x
=
0
tret
=
root
[
childNodesName
]
;
while
(
(
te
=
tret
[
x
+
+
]
)
)
{
if
(
te
.
nodeType
=
=
1
)
{
ret
.
push
(
te
)
;
}
}
return
ret
;
}
var
_nextSiblings
=
function
(
root
single
)
{
var
ret
=
[
]
;
var
te
=
root
;
while
(
te
=
te
.
nextSibling
)
{
if
(
te
.
nodeType
=
=
1
)
{
ret
.
push
(
te
)
;
if
(
single
)
{
break
;
}
}
}
return
ret
;
}
var
_filterDown
=
function
(
element
queryParts
matchArr
idx
)
{
var
nidx
=
idx
+
1
;
var
isFinal
=
(
queryParts
.
length
=
=
nidx
)
;
var
tqp
=
queryParts
[
idx
]
;
if
(
tqp
.
oper
)
{
var
ecn
=
(
tqp
.
oper
=
=
"
>
"
)
?
_childElements
(
element
)
:
_nextSiblings
(
element
(
tqp
.
oper
=
=
"
+
"
)
)
;
if
(
!
ecn
|
|
!
ecn
.
length
)
{
return
;
}
nidx
+
+
;
isFinal
=
(
queryParts
.
length
=
=
nidx
)
;
var
tf
=
getFilterFunc
(
queryParts
[
idx
+
1
]
)
;
for
(
var
x
=
0
ecnl
=
ecn
.
length
te
;
x
<
ecnl
te
=
ecn
[
x
]
;
x
+
+
)
{
if
(
tf
(
te
)
)
{
if
(
isFinal
)
{
matchArr
.
push
(
te
)
;
}
else
{
_filterDown
(
te
queryParts
matchArr
nidx
)
;
}
}
}
}
var
candidates
=
getElementsFunc
(
tqp
)
(
element
)
;
if
(
isFinal
)
{
while
(
candidates
.
length
)
{
matchArr
.
push
(
candidates
.
shift
(
)
)
;
}
}
else
{
while
(
candidates
.
length
)
{
_filterDown
(
candidates
.
shift
(
)
queryParts
matchArr
nidx
)
;
}
}
}
var
filterDown
=
function
(
elements
queryParts
)
{
var
ret
=
[
]
;
var
x
=
elements
.
length
-
1
te
;
while
(
(
te
=
elements
[
x
-
-
]
)
)
{
_filterDown
(
te
queryParts
ret
0
)
;
}
return
ret
;
}
var
getFilterFunc
=
function
(
q
)
{
if
(
_filtersCache
[
q
.
query
]
)
{
return
_filtersCache
[
q
.
query
]
;
}
var
ff
=
null
;
if
(
q
.
tag
)
{
if
(
q
.
tag
=
=
"
*
"
)
{
ff
=
agree
(
ff
function
(
elem
)
{
return
(
elem
.
nodeType
=
=
1
)
;
}
)
;
}
else
{
ff
=
agree
(
ff
function
(
elem
)
{
return
(
(
elem
.
nodeType
=
=
1
)
&
&
(
q
[
caseSensitive
?
"
otag
"
:
"
tag
"
]
=
=
elem
.
tagName
)
)
;
}
)
;
}
}
if
(
q
.
id
)
{
ff
=
agree
(
ff
function
(
elem
)
{
return
(
(
elem
.
nodeType
=
=
1
)
&
&
(
elem
.
id
=
=
q
.
id
)
)
;
}
)
;
}
if
(
q
.
hasLoops
)
{
ff
=
agree
(
ff
getSimpleFilterFunc
(
q
)
)
;
}
return
_filtersCache
[
q
.
query
]
=
ff
;
}
var
getNodeIndex
=
function
(
node
)
{
var
pn
=
node
.
parentNode
;
var
pnc
=
pn
.
childNodes
;
var
nidx
=
-
1
;
var
child
=
pn
.
firstChild
;
if
(
!
child
)
{
return
nidx
;
}
var
ci
=
node
[
"
__cachedIndex
"
]
;
var
cl
=
pn
[
"
__cachedLength
"
]
;
if
(
(
(
typeof
cl
=
=
"
number
"
)
&
&
(
cl
!
=
pnc
.
length
)
)
|
|
(
typeof
ci
!
=
"
number
"
)
)
{
pn
[
"
__cachedLength
"
]
=
pnc
.
length
;
var
idx
=
1
;
do
{
if
(
child
=
=
=
node
)
{
nidx
=
idx
;
}
if
(
child
.
nodeType
=
=
1
)
{
child
[
"
__cachedIndex
"
]
=
idx
;
idx
+
+
;
}
child
=
child
.
nextSibling
;
}
while
(
child
)
;
}
else
{
nidx
=
ci
;
}
return
nidx
;
}
var
firedCount
=
0
;
var
blank
=
"
"
;
var
_getAttr
=
function
(
elem
attr
)
{
if
(
attr
=
=
"
class
"
)
{
return
elem
.
className
|
|
blank
;
}
if
(
attr
=
=
"
for
"
)
{
return
elem
.
htmlFor
|
|
blank
;
}
if
(
attr
=
=
"
style
"
)
{
return
elem
.
style
.
cssText
|
|
blank
;
}
return
(
caseSensitive
?
elem
.
getAttribute
(
attr
)
:
elem
.
getAttribute
(
attr
2
)
)
|
|
blank
;
}
var
attrs
=
{
"
*
=
"
:
function
(
attr
value
)
{
return
function
(
elem
)
{
return
(
_getAttr
(
elem
attr
)
.
indexOf
(
value
)
>
=
0
)
;
}
}
"
^
=
"
:
function
(
attr
value
)
{
return
function
(
elem
)
{
return
(
_getAttr
(
elem
attr
)
.
indexOf
(
value
)
=
=
0
)
;
}
}
"
=
"
:
function
(
attr
value
)
{
var
tval
=
"
"
+
value
;
return
function
(
elem
)
{
var
ea
=
"
"
+
_getAttr
(
elem
attr
)
;
return
(
ea
.
lastIndexOf
(
value
)
=
=
(
ea
.
length
-
value
.
length
)
)
;
}
}
"
~
=
"
:
function
(
attr
value
)
{
var
tval
=
"
"
+
value
+
"
"
;
return
function
(
elem
)
{
var
ea
=
"
"
+
_getAttr
(
elem
attr
)
+
"
"
;
return
(
ea
.
indexOf
(
tval
)
>
=
0
)
;
}
}
"
|
=
"
:
function
(
attr
value
)
{
var
valueDash
=
"
"
+
value
+
"
-
"
;
return
function
(
elem
)
{
var
ea
=
"
"
+
(
elem
.
getAttribute
(
attr
2
)
|
|
"
"
)
;
return
(
(
ea
=
=
value
)
|
|
(
ea
.
indexOf
(
valueDash
)
=
=
0
)
)
;
}
}
"
=
"
:
function
(
attr
value
)
{
return
function
(
elem
)
{
return
(
_getAttr
(
elem
attr
)
=
=
value
)
;
}
}
}
;
var
pseudos
=
{
"
checked
"
:
function
(
name
condition
)
{
return
function
(
elem
)
{
return
!
!
d
.
attr
(
elem
"
checked
"
)
;
}
}
"
first
-
child
"
:
function
(
name
condition
)
{
return
function
(
elem
)
{
if
(
elem
.
nodeType
!
=
1
)
{
return
false
;
}
var
fc
=
elem
.
previousSibling
;
while
(
fc
&
&
(
fc
.
nodeType
!
=
1
)
)
{
fc
=
fc
.
previousSibling
;
}
return
(
!
fc
)
;
}
}
"
last
-
child
"
:
function
(
name
condition
)
{
return
function
(
elem
)
{
if
(
elem
.
nodeType
!
=
1
)
{
return
false
;
}
var
nc
=
elem
.
nextSibling
;
while
(
nc
&
&
(
nc
.
nodeType
!
=
1
)
)
{
nc
=
nc
.
nextSibling
;
}
return
(
!
nc
)
;
}
}
"
empty
"
:
function
(
name
condition
)
{
return
function
(
elem
)
{
var
cn
=
elem
.
childNodes
;
var
cnl
=
elem
.
childNodes
.
length
;
for
(
var
x
=
cnl
-
1
;
x
>
=
0
;
x
-
-
)
{
var
nt
=
cn
[
x
]
.
nodeType
;
if
(
(
nt
=
=
1
)
|
|
(
nt
=
=
3
)
)
{
return
false
;
}
}
return
true
;
}
}
"
contains
"
:
function
(
name
condition
)
{
return
function
(
elem
)
{
if
(
condition
.
charAt
(
0
)
=
=
'
"
'
|
|
condition
.
charAt
(
0
)
=
=
"
'
"
)
{
condition
=
condition
.
substr
(
1
condition
.
length
-
2
)
;
}
return
(
elem
.
innerHTML
.
indexOf
(
condition
)
>
=
0
)
;
}
}
"
not
"
:
function
(
name
condition
)
{
var
ntf
=
getFilterFunc
(
getQueryParts
(
condition
)
[
0
]
)
;
return
function
(
elem
)
{
return
(
!
ntf
(
elem
)
)
;
}
}
"
nth
-
child
"
:
function
(
name
condition
)
{
var
pi
=
parseInt
;
if
(
condition
=
=
"
odd
"
)
{
condition
=
"
2n
+
1
"
;
}
else
if
(
condition
=
=
"
even
"
)
{
condition
=
"
2n
"
;
}
if
(
condition
.
indexOf
(
"
n
"
)
!
=
-
1
)
{
var
tparts
=
condition
.
split
(
"
n
"
2
)
;
var
pred
=
tparts
[
0
]
?
(
tparts
[
0
]
=
=
'
-
'
?
-
1
:
pi
(
tparts
[
0
]
)
)
:
1
;
var
idx
=
tparts
[
1
]
?
pi
(
tparts
[
1
]
)
:
0
;
var
lb
=
0
ub
=
-
1
;
if
(
pred
>
0
)
{
if
(
idx
<
0
)
{
idx
=
(
idx
%
pred
)
&
&
(
pred
+
(
idx
%
pred
)
)
;
}
else
if
(
idx
>
0
)
{
if
(
idx
>
=
pred
)
{
lb
=
idx
-
idx
%
pred
;
}
idx
=
idx
%
pred
;
}
}
else
if
(
pred
<
0
)
{
pred
*
=
-
1
;
if
(
idx
>
0
)
{
ub
=
idx
;
idx
=
idx
%
pred
;
}
}
if
(
pred
>
0
)
{
return
function
(
elem
)
{
var
i
=
getNodeIndex
(
elem
)
;
return
(
i
>
=
lb
)
&
&
(
ub
<
0
|
|
i
<
=
ub
)
&
&
(
(
i
%
pred
)
=
=
idx
)
;
}
}
else
{
condition
=
idx
;
}
}
var
ncount
=
pi
(
condition
)
;
return
function
(
elem
)
{
return
(
getNodeIndex
(
elem
)
=
=
ncount
)
;
}
}
}
;
var
defaultGetter
=
(
d
.
isIE
)
?
function
(
cond
)
{
var
clc
=
cond
.
toLowerCase
(
)
;
return
function
(
elem
)
{
return
(
caseSensitive
?
elem
.
getAttribute
(
cond
)
:
elem
[
cond
]
|
|
elem
[
clc
]
)
;
}
}
:
function
(
cond
)
{
return
function
(
elem
)
{
return
(
elem
&
&
elem
.
getAttribute
&
&
elem
.
hasAttribute
(
cond
)
)
;
}
}
;
var
getSimpleFilterFunc
=
function
(
query
)
{
var
fcHit
=
(
_simpleFiltersCache
[
query
.
query
]
|
|
_filtersCache
[
query
.
query
]
)
;
if
(
fcHit
)
{
return
fcHit
;
}
var
ff
=
null
;
if
(
query
.
id
)
{
if
(
query
.
tag
!
=
"
*
"
)
{
ff
=
agree
(
ff
function
(
elem
)
{
return
(
elem
.
tagName
=
=
query
[
caseSensitive
?
"
otag
"
:
"
tag
"
]
)
;
}
)
;
}
}
d
.
forEach
(
query
.
classes
function
(
cname
idx
arr
)
{
var
isWildcard
=
cname
.
charAt
(
cname
.
length
-
1
)
=
=
"
*
"
;
if
(
isWildcard
)
{
cname
=
cname
.
substr
(
0
cname
.
length
-
1
)
;
}
var
re
=
new
RegExp
(
"
(
?
:
^
|
\
\
s
)
"
+
cname
+
(
isWildcard
?
"
.
*
"
:
"
"
)
+
"
(
?
:
\
\
s
|
)
"
)
;
ff
=
agree
(
ff
function
(
elem
)
{
return
re
.
test
(
elem
.
className
)
;
}
)
;
ff
.
count
=
idx
;
}
)
;
d
.
forEach
(
query
.
pseudos
function
(
pseudo
)
{
if
(
pseudos
[
pseudo
.
name
]
)
{
ff
=
agree
(
ff
pseudos
[
pseudo
.
name
]
(
pseudo
.
name
pseudo
.
value
)
)
;
}
}
)
;
handleAttrs
(
attrs
query
defaultGetter
function
(
tmatcher
)
{
ff
=
agree
(
ff
tmatcher
)
;
}
)
;
if
(
!
ff
)
{
ff
=
function
(
)
{
return
true
;
}
;
}
return
_simpleFiltersCache
[
query
.
query
]
=
ff
;
}
var
_getElementsFuncCache
=
{
}
;
var
getElementsFunc
=
function
(
query
root
)
{
var
fHit
=
_getElementsFuncCache
[
query
.
query
]
;
if
(
fHit
)
{
return
fHit
;
}
if
(
query
.
id
&
&
!
query
.
hasLoops
&
&
!
query
.
tag
)
{
return
_getElementsFuncCache
[
query
.
query
]
=
function
(
root
)
{
return
[
d
.
byId
(
query
.
id
)
]
;
}
}
var
filterFunc
=
getSimpleFilterFunc
(
query
)
;
var
retFunc
;
if
(
query
.
tag
&
&
query
.
id
&
&
!
query
.
hasLoops
)
{
retFunc
=
function
(
root
)
{
var
te
=
d
.
byId
(
query
.
id
(
root
.
ownerDocument
|
|
root
)
)
;
if
(
filterFunc
(
te
)
)
{
return
[
te
]
;
}
}
}
else
{
var
tret
;
if
(
!
query
.
hasLoops
)
{
retFunc
=
function
(
root
)
{
var
ret
=
[
]
;
var
te
x
=
0
tret
=
root
.
getElementsByTagName
(
query
[
caseSensitive
?
"
otag
"
:
"
tag
"
]
)
;
while
(
(
te
=
tret
[
x
+
+
]
)
)
{
ret
.
push
(
te
)
;
}
return
ret
;
}
}
else
{
retFunc
=
function
(
root
)
{
var
ret
=
[
]
;
var
te
x
=
0
tret
=
root
.
getElementsByTagName
(
query
[
caseSensitive
?
"
otag
"
:
"
tag
"
]
)
;
while
(
(
te
=
tret
[
x
+
+
]
)
)
{
if
(
filterFunc
(
te
)
)
{
ret
.
push
(
te
)
;
}
}
return
ret
;
}
}
}
return
_getElementsFuncCache
[
query
.
query
]
=
retFunc
;
}
var
_partsCache
=
{
}
;
var
_queryFuncCache
=
{
"
*
"
:
d
.
isIE
?
function
(
root
)
{
return
root
.
all
;
}
:
function
(
root
)
{
return
root
.
getElementsByTagName
(
"
*
"
)
;
}
"
~
"
:
_nextSiblings
"
+
"
:
function
(
root
)
{
return
_nextSiblings
(
root
true
)
;
}
"
>
"
:
_childElements
}
;
var
getStepQueryFunc
=
function
(
query
)
{
var
qparts
=
getQueryParts
(
d
.
trim
(
query
)
)
;
if
(
qparts
.
length
=
=
1
)
{
var
tt
=
getElementsFunc
(
qparts
[
0
]
)
;
tt
.
nozip
=
true
;
return
tt
;
}
var
sqf
=
function
(
root
)
{
var
localQueryParts
=
qparts
.
slice
(
0
)
;
var
candidates
;
if
(
localQueryParts
[
0
]
.
oper
=
=
"
>
"
)
{
candidates
=
[
root
]
;
}
else
{
candidates
=
getElementsFunc
(
localQueryParts
.
shift
(
)
)
(
root
)
;
}
return
filterDown
(
candidates
localQueryParts
)
;
}
return
sqf
;
}
var
_getQueryFunc
=
(
(
document
[
"
evaluate
"
]
&
&
!
d
.
isSafari
)
?
function
(
query
root
)
{
var
qparts
=
query
.
split
(
"
"
)
;
if
(
(
!
caseSensitive
)
&
&
(
document
[
"
evaluate
"
]
)
&
&
(
query
.
indexOf
(
"
:
"
)
=
=
-
1
)
&
&
(
query
.
indexOf
(
"
+
"
)
=
=
-
1
)
)
{
if
(
(
(
qparts
.
length
>
2
)
&
&
(
query
.
indexOf
(
"
>
"
)
=
=
-
1
)
)
|
|
(
qparts
.
length
>
3
)
|
|
(
query
.
indexOf
(
"
[
"
)
>
=
0
)
|
|
(
(
1
=
=
qparts
.
length
)
&
&
(
0
<
=
query
.
indexOf
(
"
.
"
)
)
)
)
{
return
getXPathFunc
(
query
)
;
}
}
return
getStepQueryFunc
(
query
)
;
}
:
getStepQueryFunc
)
;
var
getQueryFunc
=
function
(
query
)
{
var
qcz
=
query
.
charAt
(
0
)
;
if
(
d
.
doc
[
"
querySelectorAll
"
]
&
&
(
(
!
d
.
isSafari
)
|
|
(
d
.
isSafari
>
3
.
1
)
)
&
&
(
"
>
+
~
"
.
indexOf
(
qcz
)
=
=
-
1
)
)
{
return
function
(
root
)
{
var
r
=
root
.
querySelectorAll
(
query
)
;
r
.
nozip
=
true
;
return
r
;
}
;
}
if
(
_queryFuncCache
[
query
]
)
{
return
_queryFuncCache
[
query
]
;
}
if
(
0
>
query
.
indexOf
(
"
"
)
)
{
return
_queryFuncCache
[
query
]
=
_getQueryFunc
(
query
)
;
}
else
{
var
parts
=
query
.
split
(
/
\
s
*
\
s
*
/
)
;
var
tf
=
function
(
root
)
{
var
pindex
=
0
;
var
ret
=
[
]
;
var
tp
;
while
(
(
tp
=
parts
[
pindex
+
+
]
)
)
{
ret
=
ret
.
concat
(
_getQueryFunc
(
tp
tp
.
indexOf
(
"
"
)
)
(
root
)
)
;
}
return
ret
;
}
return
_queryFuncCache
[
query
]
=
tf
;
}
}
var
_zipIdx
=
0
;
var
_zip
=
function
(
arr
)
{
if
(
arr
&
&
arr
.
nozip
)
{
return
d
.
NodeList
.
_wrap
(
arr
)
;
}
var
ret
=
new
d
.
NodeList
(
)
;
if
(
!
arr
)
{
return
ret
;
}
if
(
arr
[
0
]
)
{
ret
.
push
(
arr
[
0
]
)
;
}
if
(
arr
.
length
<
2
)
{
return
ret
;
}
_zipIdx
+
+
;
if
(
d
.
isIE
&
&
caseSensitive
)
{
var
szidx
=
_zipIdx
+
"
"
;
arr
[
0
]
.
setAttribute
(
"
_zipIdx
"
szidx
)
;
for
(
var
x
=
1
te
;
te
=
arr
[
x
]
;
x
+
+
)
{
if
(
arr
[
x
]
.
getAttribute
(
"
_zipIdx
"
)
!
=
szidx
)
{
ret
.
push
(
te
)
;
}
te
.
setAttribute
(
"
_zipIdx
"
szidx
)
;
}
}
else
{
arr
[
0
]
[
"
_zipIdx
"
]
=
_zipIdx
;
for
(
var
x
=
1
te
;
te
=
arr
[
x
]
;
x
+
+
)
{
if
(
arr
[
x
]
[
"
_zipIdx
"
]
!
=
_zipIdx
)
{
ret
.
push
(
te
)
;
}
te
[
"
_zipIdx
"
]
=
_zipIdx
;
}
}
return
ret
;
}
d
.
query
=
function
(
query
root
)
{
if
(
query
.
constructor
=
=
d
.
NodeList
)
{
return
query
;
}
if
(
!
d
.
isString
(
query
)
)
{
return
new
d
.
NodeList
(
query
)
;
}
if
(
d
.
isString
(
root
)
)
{
root
=
d
.
byId
(
root
)
;
}
root
=
root
|
|
d
.
doc
;
var
od
=
root
.
ownerDocument
|
|
root
.
documentElement
;
caseSensitive
=
(
root
.
contentType
&
&
root
.
contentType
=
=
"
application
/
xml
"
)
|
|
(
!
!
od
)
&
&
(
d
.
isIE
?
od
.
xml
:
(
root
.
xmlVersion
|
|
od
.
xmlVersion
)
)
;
return
_zip
(
getQueryFunc
(
query
)
(
root
)
)
;
}
d
.
query
.
pseudos
=
pseudos
;
d
.
_filterQueryResult
=
function
(
nodeList
simpleFilter
)
{
var
tnl
=
new
d
.
NodeList
(
)
;
var
ff
=
(
simpleFilter
)
?
getFilterFunc
(
getQueryParts
(
simpleFilter
)
[
0
]
)
:
function
(
)
{
return
true
;
}
;
for
(
var
x
=
0
te
;
te
=
nodeList
[
x
]
;
x
+
+
)
{
if
(
ff
(
te
)
)
{
tnl
.
push
(
te
)
;
}
}
return
tnl
;
}
}
)
(
)
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
xhr
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
xhr
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
xhr
"
)
;
(
function
(
)
{
var
_d
=
dojo
;
function
setValue
(
obj
name
value
)
{
var
val
=
obj
[
name
]
;
if
(
_d
.
isString
(
val
)
)
{
obj
[
name
]
=
[
val
value
]
;
}
else
if
(
_d
.
isArray
(
val
)
)
{
val
.
push
(
value
)
;
}
else
{
obj
[
name
]
=
value
;
}
}
dojo
.
formToObject
=
function
(
formNode
)
{
var
ret
=
{
}
;
var
exclude
=
"
file
|
submit
|
image
|
reset
|
button
|
"
;
_d
.
forEach
(
dojo
.
byId
(
formNode
)
.
elements
function
(
item
)
{
var
_in
=
item
.
name
;
var
type
=
(
item
.
type
|
|
"
"
)
.
toLowerCase
(
)
;
if
(
_in
&
&
type
&
&
exclude
.
indexOf
(
type
)
=
=
-
1
&
&
!
item
.
disabled
)
{
if
(
type
=
=
"
radio
"
|
|
type
=
=
"
checkbox
"
)
{
if
(
item
.
checked
)
{
setValue
(
ret
_in
item
.
value
)
;
}
}
else
if
(
item
.
multiple
)
{
ret
[
_in
]
=
[
]
;
_d
.
query
(
"
option
"
item
)
.
forEach
(
function
(
opt
)
{
if
(
opt
.
selected
)
{
setValue
(
ret
_in
opt
.
value
)
;
}
}
)
;
}
else
{
setValue
(
ret
_in
item
.
value
)
;
if
(
type
=
=
"
image
"
)
{
ret
[
_in
+
"
.
x
"
]
=
ret
[
_in
+
"
.
y
"
]
=
ret
[
_in
]
.
x
=
ret
[
_in
]
.
y
=
0
;
}
}
}
}
)
;
return
ret
;
}
dojo
.
objectToQuery
=
function
(
map
)
{
var
enc
=
encodeURIComponent
;
var
pairs
=
[
]
;
var
backstop
=
{
}
;
for
(
var
name
in
map
)
{
var
value
=
map
[
name
]
;
if
(
value
!
=
backstop
[
name
]
)
{
var
assign
=
enc
(
name
)
+
"
=
"
;
if
(
_d
.
isArray
(
value
)
)
{
for
(
var
i
=
0
;
i
<
value
.
length
;
i
+
+
)
{
pairs
.
push
(
assign
+
enc
(
value
[
i
]
)
)
;
}
}
else
{
pairs
.
push
(
assign
+
enc
(
value
)
)
;
}
}
}
return
pairs
.
join
(
"
&
"
)
;
}
dojo
.
formToQuery
=
function
(
formNode
)
{
return
_d
.
objectToQuery
(
_d
.
formToObject
(
formNode
)
)
;
}
dojo
.
formToJson
=
function
(
formNode
prettyPrint
)
{
return
_d
.
toJson
(
_d
.
formToObject
(
formNode
)
prettyPrint
)
;
}
dojo
.
queryToObject
=
function
(
str
)
{
var
ret
=
{
}
;
var
qp
=
str
.
split
(
"
&
"
)
;
var
dec
=
decodeURIComponent
;
_d
.
forEach
(
qp
function
(
item
)
{
if
(
item
.
length
)
{
var
parts
=
item
.
split
(
"
=
"
)
;
var
name
=
dec
(
parts
.
shift
(
)
)
;
var
val
=
dec
(
parts
.
join
(
"
=
"
)
)
;
if
(
_d
.
isString
(
ret
[
name
]
)
)
{
ret
[
name
]
=
[
ret
[
name
]
]
;
}
if
(
_d
.
isArray
(
ret
[
name
]
)
)
{
ret
[
name
]
.
push
(
val
)
;
}
else
{
ret
[
name
]
=
val
;
}
}
}
)
;
return
ret
;
}
dojo
.
_blockAsync
=
false
;
dojo
.
_contentHandlers
=
{
"
text
"
:
function
(
xhr
)
{
return
xhr
.
responseText
;
}
"
json
"
:
function
(
xhr
)
{
return
_d
.
fromJson
(
xhr
.
responseText
|
|
null
)
;
}
"
json
-
comment
-
filtered
"
:
function
(
xhr
)
{
if
(
!
dojo
.
config
.
useCommentedJson
)
{
console
.
warn
(
"
Consider
using
the
standard
mimetype
:
application
/
json
.
"
+
"
json
-
commenting
can
introduce
security
issues
.
To
"
+
"
decrease
the
chances
of
hijacking
use
the
standard
the
'
json
'
handler
and
"
+
"
prefix
your
json
with
:
{
}
&
&
\
n
"
+
"
Use
djConfig
.
useCommentedJson
=
true
to
turn
off
this
message
.
"
)
;
}
var
value
=
xhr
.
responseText
;
var
cStartIdx
=
value
.
indexOf
(
"
\
/
*
"
)
;
var
cEndIdx
=
value
.
lastIndexOf
(
"
*
\
/
"
)
;
if
(
cStartIdx
=
=
-
1
|
|
cEndIdx
=
=
-
1
)
{
throw
new
Error
(
"
JSON
was
not
comment
filtered
"
)
;
}
return
_d
.
fromJson
(
value
.
substring
(
cStartIdx
+
2
cEndIdx
)
)
;
}
"
javascript
"
:
function
(
xhr
)
{
return
_d
.
eval
(
xhr
.
responseText
)
;
}
"
xml
"
:
function
(
xhr
)
{
var
result
=
xhr
.
responseXML
;
if
(
_d
.
isIE
&
&
(
!
result
|
|
result
.
documentElement
=
=
null
)
)
{
_d
.
forEach
(
[
"
MSXML2
"
"
Microsoft
"
"
MSXML
"
"
MSXML3
"
]
function
(
prefix
)
{
try
{
var
dom
=
new
ActiveXObject
(
prefix
+
"
.
XMLDOM
"
)
;
dom
.
async
=
false
;
dom
.
loadXML
(
xhr
.
responseText
)
;
result
=
dom
;
}
catch
(
e
)
{
}
}
)
;
}
return
result
;
}
}
;
dojo
.
_contentHandlers
[
"
json
-
comment
-
optional
"
]
=
function
(
xhr
)
{
var
handlers
=
_d
.
_contentHandlers
;
if
(
xhr
.
responseText
&
&
xhr
.
responseText
.
indexOf
(
"
\
/
*
"
)
!
=
-
1
)
{
return
handlers
[
"
json
-
comment
-
filtered
"
]
(
xhr
)
;
}
else
{
return
handlers
[
"
json
"
]
(
xhr
)
;
}
}
;
dojo
.
_ioSetArgs
=
function
(
args
canceller
okHandler
errHandler
)
{
var
ioArgs
=
{
args
:
args
url
:
args
.
url
}
;
var
formObject
=
null
;
if
(
args
.
form
)
{
var
form
=
_d
.
byId
(
args
.
form
)
;
var
actnNode
=
form
.
getAttributeNode
(
"
action
"
)
;
ioArgs
.
url
=
ioArgs
.
url
|
|
(
actnNode
?
actnNode
.
value
:
null
)
;
formObject
=
_d
.
formToObject
(
form
)
;
}
var
miArgs
=
[
{
}
]
;
if
(
formObject
)
{
miArgs
.
push
(
formObject
)
;
}
if
(
args
.
content
)
{
miArgs
.
push
(
args
.
content
)
;
}
if
(
args
.
preventCache
)
{
miArgs
.
push
(
{
"
dojo
.
preventCache
"
:
new
Date
(
)
.
valueOf
(
)
}
)
;
}
ioArgs
.
query
=
_d
.
objectToQuery
(
_d
.
mixin
.
apply
(
null
miArgs
)
)
;
ioArgs
.
handleAs
=
args
.
handleAs
|
|
"
text
"
;
var
d
=
new
_d
.
Deferred
(
canceller
)
;
d
.
addCallbacks
(
okHandler
function
(
error
)
{
return
errHandler
(
error
d
)
;
}
)
;
var
ld
=
args
.
load
;
if
(
ld
&
&
_d
.
isFunction
(
ld
)
)
{
d
.
addCallback
(
function
(
value
)
{
return
ld
.
call
(
args
value
ioArgs
)
;
}
)
;
}
var
err
=
args
.
error
;
if
(
err
&
&
_d
.
isFunction
(
err
)
)
{
d
.
addErrback
(
function
(
value
)
{
return
err
.
call
(
args
value
ioArgs
)
;
}
)
;
}
var
handle
=
args
.
handle
;
if
(
handle
&
&
_d
.
isFunction
(
handle
)
)
{
d
.
addBoth
(
function
(
value
)
{
return
handle
.
call
(
args
value
ioArgs
)
;
}
)
;
}
d
.
ioArgs
=
ioArgs
;
return
d
;
}
var
_deferredCancel
=
function
(
dfd
)
{
dfd
.
canceled
=
true
;
var
xhr
=
dfd
.
ioArgs
.
xhr
;
var
_at
=
typeof
xhr
.
abort
;
if
(
_at
=
=
"
function
"
|
|
_at
=
=
"
object
"
|
|
_at
=
=
"
unknown
"
)
{
xhr
.
abort
(
)
;
}
var
err
=
dfd
.
ioArgs
.
error
;
if
(
!
err
)
{
err
=
new
Error
(
"
xhr
cancelled
"
)
;
err
.
dojoType
=
"
cancel
"
;
}
return
err
;
}
var
_deferredOk
=
function
(
dfd
)
{
var
ret
=
_d
.
_contentHandlers
[
dfd
.
ioArgs
.
handleAs
]
(
dfd
.
ioArgs
.
xhr
)
;
return
(
typeof
ret
=
=
"
undefined
"
)
?
null
:
ret
;
}
var
_deferError
=
function
(
error
dfd
)
{
return
error
;
}
var
_inFlightIntvl
=
null
;
var
_inFlight
=
[
]
;
var
_watchInFlight
=
function
(
)
{
var
now
=
(
new
Date
(
)
)
.
getTime
(
)
;
if
(
!
_d
.
_blockAsync
)
{
for
(
var
i
=
0
tif
;
i
<
_inFlight
.
length
&
&
(
tif
=
_inFlight
[
i
]
)
;
i
+
+
)
{
var
dfd
=
tif
.
dfd
;
var
func
=
function
(
)
{
if
(
!
dfd
|
|
dfd
.
canceled
|
|
!
tif
.
validCheck
(
dfd
)
)
{
_inFlight
.
splice
(
i
-
-
1
)
;
}
else
if
(
tif
.
ioCheck
(
dfd
)
)
{
_inFlight
.
splice
(
i
-
-
1
)
;
tif
.
resHandle
(
dfd
)
;
}
else
if
(
dfd
.
startTime
)
{
if
(
dfd
.
startTime
+
(
dfd
.
ioArgs
.
args
.
timeout
|
|
0
)
<
now
)
{
_inFlight
.
splice
(
i
-
-
1
)
;
var
err
=
new
Error
(
"
timeout
exceeded
"
)
;
err
.
dojoType
=
"
timeout
"
;
dfd
.
errback
(
err
)
;
dfd
.
cancel
(
)
;
}
}
}
;
if
(
dojo
.
config
.
isDebug
)
{
func
.
call
(
this
)
;
}
else
{
try
{
func
.
call
(
this
)
;
}
catch
(
e
)
{
dfd
.
errback
(
e
)
;
}
}
}
}
if
(
!
_inFlight
.
length
)
{
clearInterval
(
_inFlightIntvl
)
;
_inFlightIntvl
=
null
;
return
;
}
}
dojo
.
_ioCancelAll
=
function
(
)
{
try
{
_d
.
forEach
(
_inFlight
function
(
i
)
{
try
{
i
.
dfd
.
cancel
(
)
;
}
catch
(
e
)
{
}
}
)
;
}
catch
(
e
)
{
}
}
if
(
_d
.
isIE
)
{
_d
.
addOnWindowUnload
(
_d
.
_ioCancelAll
)
;
}
_d
.
_ioWatch
=
function
(
dfd
validCheck
ioCheck
resHandle
)
{
if
(
dfd
.
ioArgs
.
args
.
timeout
)
{
dfd
.
startTime
=
(
new
Date
(
)
)
.
getTime
(
)
;
}
_inFlight
.
push
(
{
dfd
:
dfd
validCheck
:
validCheck
ioCheck
:
ioCheck
resHandle
:
resHandle
}
)
;
if
(
!
_inFlightIntvl
)
{
_inFlightIntvl
=
setInterval
(
_watchInFlight
50
)
;
}
_watchInFlight
(
)
;
}
var
_defaultContentType
=
"
application
/
x
-
www
-
form
-
urlencoded
"
;
var
_validCheck
=
function
(
dfd
)
{
return
dfd
.
ioArgs
.
xhr
.
readyState
;
}
var
_ioCheck
=
function
(
dfd
)
{
return
4
=
=
dfd
.
ioArgs
.
xhr
.
readyState
;
}
var
_resHandle
=
function
(
dfd
)
{
var
xhr
=
dfd
.
ioArgs
.
xhr
;
if
(
_d
.
_isDocumentOk
(
xhr
)
)
{
dfd
.
callback
(
dfd
)
;
}
else
{
var
err
=
new
Error
(
"
Unable
to
load
"
+
dfd
.
ioArgs
.
url
+
"
status
:
"
+
xhr
.
status
)
;
err
.
status
=
xhr
.
status
;
err
.
responseText
=
xhr
.
responseText
;
dfd
.
errback
(
err
)
;
}
}
dojo
.
_ioAddQueryToUrl
=
function
(
ioArgs
)
{
if
(
ioArgs
.
query
.
length
)
{
ioArgs
.
url
+
=
(
ioArgs
.
url
.
indexOf
(
"
?
"
)
=
=
-
1
?
"
?
"
:
"
&
"
)
+
ioArgs
.
query
;
ioArgs
.
query
=
null
;
}
}
dojo
.
xhr
=
function
(
method
args
hasBody
)
{
var
dfd
=
_d
.
_ioSetArgs
(
args
_deferredCancel
_deferredOk
_deferError
)
;
dfd
.
ioArgs
.
xhr
=
_d
.
_xhrObj
(
dfd
.
ioArgs
.
args
)
;
if
(
hasBody
)
{
if
(
"
postData
"
in
args
)
{
dfd
.
ioArgs
.
query
=
args
.
postData
;
}
else
if
(
"
putData
"
in
args
)
{
dfd
.
ioArgs
.
query
=
args
.
putData
;
}
}
else
{
_d
.
_ioAddQueryToUrl
(
dfd
.
ioArgs
)
;
}
var
ioArgs
=
dfd
.
ioArgs
;
var
xhr
=
ioArgs
.
xhr
;
xhr
.
open
(
method
ioArgs
.
url
args
.
sync
!
=
=
true
args
.
user
|
|
undefined
args
.
password
|
|
undefined
)
;
if
(
args
.
headers
)
{
for
(
var
hdr
in
args
.
headers
)
{
if
(
hdr
.
toLowerCase
(
)
=
=
=
"
content
-
type
"
&
&
!
args
.
contentType
)
{
args
.
contentType
=
args
.
headers
[
hdr
]
;
}
else
{
xhr
.
setRequestHeader
(
hdr
args
.
headers
[
hdr
]
)
;
}
}
}
xhr
.
setRequestHeader
(
"
Content
-
Type
"
args
.
contentType
|
|
_defaultContentType
)
;
if
(
!
args
.
headers
|
|
!
args
.
headers
[
"
X
-
Requested
-
With
"
]
)
{
xhr
.
setRequestHeader
(
"
X
-
Requested
-
With
"
"
XMLHttpRequest
"
)
;
}
if
(
dojo
.
config
.
isDebug
)
{
xhr
.
send
(
ioArgs
.
query
)
;
}
else
{
try
{
xhr
.
send
(
ioArgs
.
query
)
;
}
catch
(
e
)
{
dfd
.
ioArgs
.
error
=
e
;
dfd
.
cancel
(
)
;
}
}
_d
.
_ioWatch
(
dfd
_validCheck
_ioCheck
_resHandle
)
;
xhr
=
null
;
return
dfd
;
}
dojo
.
xhrGet
=
function
(
args
)
{
return
_d
.
xhr
(
"
GET
"
args
)
;
}
dojo
.
rawXhrPost
=
dojo
.
xhrPost
=
function
(
args
)
{
return
_d
.
xhr
(
"
POST
"
args
true
)
;
}
dojo
.
rawXhrPut
=
dojo
.
xhrPut
=
function
(
args
)
{
return
_d
.
xhr
(
"
PUT
"
args
true
)
;
}
dojo
.
xhrDelete
=
function
(
args
)
{
return
_d
.
xhr
(
"
DELETE
"
args
)
;
}
}
)
(
)
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
fx
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
fx
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
fx
"
)
;
(
function
(
)
{
var
d
=
dojo
;
dojo
.
_Line
=
function
(
start
end
)
{
this
.
start
=
start
;
this
.
end
=
end
;
this
.
getValue
=
function
(
n
)
{
return
(
(
this
.
end
-
this
.
start
)
*
n
)
+
this
.
start
;
}
}
d
.
declare
(
"
dojo
.
_Animation
"
null
{
constructor
:
function
(
args
)
{
d
.
mixin
(
this
args
)
;
if
(
d
.
isArray
(
this
.
curve
)
)
{
this
.
curve
=
new
d
.
_Line
(
this
.
curve
[
0
]
this
.
curve
[
1
]
)
;
}
}
duration
:
350
repeat
:
0
rate
:
10
_percent
:
0
_startRepeatCount
:
0
_fire
:
function
(
evt
args
)
{
if
(
this
[
evt
]
)
{
if
(
dojo
.
config
.
isDebug
)
{
this
[
evt
]
.
apply
(
this
args
|
|
[
]
)
;
}
else
{
try
{
this
[
evt
]
.
apply
(
this
args
|
|
[
]
)
;
}
catch
(
e
)
{
console
.
error
(
"
exception
in
animation
handler
for
:
"
evt
)
;
console
.
error
(
e
)
;
}
}
}
return
this
;
}
play
:
function
(
delay
gotoStart
)
{
var
_t
=
this
;
if
(
gotoStart
)
{
_t
.
_stopTimer
(
)
;
_t
.
_active
=
_t
.
_paused
=
false
;
_t
.
_percent
=
0
;
}
else
if
(
_t
.
_active
&
&
!
_t
.
_paused
)
{
return
_t
;
}
_t
.
_fire
(
"
beforeBegin
"
)
;
var
de
=
delay
|
|
_t
.
delay
;
var
_p
=
dojo
.
hitch
(
_t
"
_play
"
gotoStart
)
;
if
(
de
>
0
)
{
setTimeout
(
_p
de
)
;
return
_t
;
}
_p
(
)
;
return
_t
;
}
_play
:
function
(
gotoStart
)
{
var
_t
=
this
;
_t
.
_startTime
=
new
Date
(
)
.
valueOf
(
)
;
if
(
_t
.
_paused
)
{
_t
.
_startTime
-
=
_t
.
duration
*
_t
.
_percent
;
}
_t
.
_endTime
=
_t
.
_startTime
+
_t
.
duration
;
_t
.
_active
=
true
;
_t
.
_paused
=
false
;
var
value
=
_t
.
curve
.
getValue
(
_t
.
_percent
)
;
if
(
!
_t
.
_percent
)
{
if
(
!
_t
.
_startRepeatCount
)
{
_t
.
_startRepeatCount
=
_t
.
repeat
;
}
_t
.
_fire
(
"
onBegin
"
[
value
]
)
;
}
_t
.
_fire
(
"
onPlay
"
[
value
]
)
;
_t
.
_cycle
(
)
;
return
_t
;
}
pause
:
function
(
)
{
this
.
_stopTimer
(
)
;
if
(
!
this
.
_active
)
{
return
this
;
}
this
.
_paused
=
true
;
this
.
_fire
(
"
onPause
"
[
this
.
curve
.
getValue
(
this
.
_percent
)
]
)
;
return
this
;
}
gotoPercent
:
function
(
percent
andPlay
)
{
this
.
_stopTimer
(
)
;
this
.
_active
=
this
.
_paused
=
true
;
this
.
_percent
=
percent
;
if
(
andPlay
)
{
this
.
play
(
)
;
}
return
this
;
}
stop
:
function
(
gotoEnd
)
{
if
(
!
this
.
_timer
)
{
return
this
;
}
this
.
_stopTimer
(
)
;
if
(
gotoEnd
)
{
this
.
_percent
=
1
;
}
this
.
_fire
(
"
onStop
"
[
this
.
curve
.
getValue
(
this
.
_percent
)
]
)
;
this
.
_active
=
this
.
_paused
=
false
;
return
this
;
}
status
:
function
(
)
{
if
(
this
.
_active
)
{
return
this
.
_paused
?
"
paused
"
:
"
playing
"
;
}
return
"
stopped
"
;
}
_cycle
:
function
(
)
{
var
_t
=
this
;
if
(
_t
.
_active
)
{
var
curr
=
new
Date
(
)
.
valueOf
(
)
;
var
step
=
(
curr
-
_t
.
_startTime
)
/
(
_t
.
_endTime
-
_t
.
_startTime
)
;
if
(
step
>
=
1
)
{
step
=
1
;
}
_t
.
_percent
=
step
;
if
(
_t
.
easing
)
{
step
=
_t
.
easing
(
step
)
;
}
_t
.
_fire
(
"
onAnimate
"
[
_t
.
curve
.
getValue
(
step
)
]
)
;
if
(
_t
.
_percent
<
1
)
{
_t
.
_startTimer
(
)
;
}
else
{
_t
.
_active
=
false
;
if
(
_t
.
repeat
>
0
)
{
_t
.
repeat
-
-
;
_t
.
play
(
null
true
)
;
}
else
if
(
_t
.
repeat
=
=
-
1
)
{
_t
.
play
(
null
true
)
;
}
else
{
if
(
_t
.
_startRepeatCount
)
{
_t
.
repeat
=
_t
.
_startRepeatCount
;
_t
.
_startRepeatCount
=
0
;
}
}
_t
.
_percent
=
0
;
_t
.
_fire
(
"
onEnd
"
)
;
_t
.
_stopTimer
(
)
;
}
}
return
_t
;
}
}
)
;
var
ctr
=
0
;
var
_globalTimerList
=
[
]
;
var
runner
=
{
run
:
function
(
)
{
}
}
;
var
timer
=
null
;
dojo
.
_Animation
.
prototype
.
_startTimer
=
function
(
)
{
if
(
!
this
.
_timer
)
{
this
.
_timer
=
d
.
connect
(
runner
"
run
"
this
"
_cycle
"
)
;
ctr
+
+
;
}
if
(
!
timer
)
{
timer
=
setInterval
(
d
.
hitch
(
runner
"
run
"
)
this
.
rate
)
;
}
}
;
dojo
.
_Animation
.
prototype
.
_stopTimer
=
function
(
)
{
if
(
this
.
_timer
)
{
d
.
disconnect
(
this
.
_timer
)
;
this
.
_timer
=
null
;
ctr
-
-
;
}
if
(
ctr
<
=
0
)
{
clearInterval
(
timer
)
;
timer
=
null
;
ctr
=
0
;
}
}
;
var
_makeFadeable
=
(
d
.
isIE
)
?
function
(
node
)
{
var
ns
=
node
.
style
;
if
(
!
ns
.
width
.
length
&
&
d
.
style
(
node
"
width
"
)
=
=
"
auto
"
)
{
ns
.
width
=
"
auto
"
;
}
}
:
function
(
)
{
}
;
dojo
.
_fade
=
function
(
args
)
{
args
.
node
=
d
.
byId
(
args
.
node
)
;
var
fArgs
=
d
.
mixin
(
{
properties
:
{
}
}
args
)
;
var
props
=
(
fArgs
.
properties
.
opacity
=
{
}
)
;
props
.
start
=
!
(
"
start
"
in
fArgs
)
?
function
(
)
{
return
Number
(
d
.
style
(
fArgs
.
node
"
opacity
"
)
)
;
}
:
fArgs
.
start
;
props
.
end
=
fArgs
.
end
;
var
anim
=
d
.
animateProperty
(
fArgs
)
;
d
.
connect
(
anim
"
beforeBegin
"
d
.
partial
(
_makeFadeable
fArgs
.
node
)
)
;
return
anim
;
}
dojo
.
fadeIn
=
function
(
args
)
{
return
d
.
_fade
(
d
.
mixin
(
{
end
:
1
}
args
)
)
;
}
dojo
.
fadeOut
=
function
(
args
)
{
return
d
.
_fade
(
d
.
mixin
(
{
end
:
0
}
args
)
)
;
}
dojo
.
_defaultEasing
=
function
(
n
)
{
return
0
.
5
+
(
(
Math
.
sin
(
(
n
+
1
.
5
)
*
Math
.
PI
)
)
/
2
)
;
}
var
PropLine
=
function
(
properties
)
{
this
.
_properties
=
properties
;
for
(
var
p
in
properties
)
{
var
prop
=
properties
[
p
]
;
if
(
prop
.
start
instanceof
d
.
Color
)
{
prop
.
tempColor
=
new
d
.
Color
(
)
;
}
}
this
.
getValue
=
function
(
r
)
{
var
ret
=
{
}
;
for
(
var
p
in
this
.
_properties
)
{
var
prop
=
this
.
_properties
[
p
]
;
var
start
=
prop
.
start
;
if
(
start
instanceof
d
.
Color
)
{
ret
[
p
]
=
d
.
blendColors
(
start
prop
.
end
r
prop
.
tempColor
)
.
toCss
(
)
;
}
else
if
(
!
d
.
isArray
(
start
)
)
{
ret
[
p
]
=
(
(
prop
.
end
-
start
)
*
r
)
+
start
+
(
p
!
=
"
opacity
"
?
prop
.
units
|
|
"
px
"
:
"
"
)
;
}
}
return
ret
;
}
}
dojo
.
animateProperty
=
function
(
args
)
{
args
.
node
=
d
.
byId
(
args
.
node
)
;
if
(
!
args
.
easing
)
{
args
.
easing
=
d
.
_defaultEasing
;
}
var
anim
=
new
d
.
_Animation
(
args
)
;
d
.
connect
(
anim
"
beforeBegin
"
anim
function
(
)
{
var
pm
=
{
}
;
for
(
var
p
in
this
.
properties
)
{
if
(
p
=
=
"
width
"
|
|
p
=
=
"
height
"
)
{
this
.
node
.
display
=
"
block
"
;
}
var
prop
=
this
.
properties
[
p
]
;
prop
=
pm
[
p
]
=
d
.
mixin
(
{
}
(
d
.
isObject
(
prop
)
?
prop
:
{
end
:
prop
}
)
)
;
if
(
d
.
isFunction
(
prop
.
start
)
)
{
prop
.
start
=
prop
.
start
(
)
;
}
if
(
d
.
isFunction
(
prop
.
end
)
)
{
prop
.
end
=
prop
.
end
(
)
;
}
var
isColor
=
(
p
.
toLowerCase
(
)
.
indexOf
(
"
color
"
)
>
=
0
)
;
function
getStyle
(
node
p
)
{
var
v
=
(
{
height
:
node
.
offsetHeight
width
:
node
.
offsetWidth
}
)
[
p
]
;
if
(
v
!
=
=
undefined
)
{
return
v
;
}
v
=
d
.
style
(
node
p
)
;
return
(
p
=
=
"
opacity
"
)
?
Number
(
v
)
:
(
isColor
?
v
:
parseFloat
(
v
)
)
;
}
if
(
!
(
"
end
"
in
prop
)
)
{
prop
.
end
=
getStyle
(
this
.
node
p
)
;
}
else
if
(
!
(
"
start
"
in
prop
)
)
{
prop
.
start
=
getStyle
(
this
.
node
p
)
;
}
if
(
isColor
)
{
prop
.
start
=
new
d
.
Color
(
prop
.
start
)
;
prop
.
end
=
new
d
.
Color
(
prop
.
end
)
;
}
else
{
prop
.
start
=
(
p
=
=
"
opacity
"
)
?
Number
(
prop
.
start
)
:
parseFloat
(
prop
.
start
)
;
}
}
this
.
curve
=
new
PropLine
(
pm
)
;
}
)
;
d
.
connect
(
anim
"
onAnimate
"
d
.
hitch
(
d
"
style
"
anim
.
node
)
)
;
return
anim
;
}
dojo
.
anim
=
function
(
node
properties
duration
easing
onEnd
delay
)
{
return
d
.
animateProperty
(
{
node
:
node
duration
:
duration
|
|
d
.
_Animation
.
prototype
.
duration
properties
:
properties
easing
:
easing
onEnd
:
onEnd
}
)
.
play
(
delay
|
|
0
)
;
}
}
)
(
)
;
}
if
(
!
dojo
.
_hasResource
[
"
dojo
.
_base
.
browser
"
]
)
{
dojo
.
_hasResource
[
"
dojo
.
_base
.
browser
"
]
=
true
;
dojo
.
provide
(
"
dojo
.
_base
.
browser
"
)
;
if
(
dojo
.
config
.
require
)
{
dojo
.
forEach
(
dojo
.
config
.
require
"
dojo
[
'
require
'
]
(
item
)
;
"
)
;
}
}
if
(
dojo
.
config
.
afterOnLoad
&
&
dojo
.
isBrowser
)
{
window
.
setTimeout
(
dojo
.
_fakeLoadInit
1000
)
;
}
}
)
(
)
;
