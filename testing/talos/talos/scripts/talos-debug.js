window
.
talosDebug
=
{
disabled
:
false
ignore
:
-
1
displayData
:
false
fixed
:
2
sum
(
values
)
{
return
values
.
reduce
(
function
(
a
b
)
{
return
a
+
b
;
}
)
;
}
average
(
values
)
{
var
d
=
window
.
talosDebug
;
return
values
.
length
?
d
.
sum
(
values
)
/
values
.
length
:
999999
;
}
median
(
values
)
{
var
clone
=
values
.
slice
(
0
)
;
var
sorted
=
clone
.
sort
(
function
(
a
b
)
{
return
a
>
b
?
1
:
a
<
b
?
-
1
:
0
;
}
)
;
var
len
=
values
.
length
;
if
(
!
len
)
{
return
999999
;
}
if
(
len
%
2
)
{
return
sorted
[
(
len
-
1
)
/
2
]
;
}
return
(
sorted
[
len
/
2
]
+
sorted
[
len
/
2
-
1
]
)
/
2
;
}
stddev
(
values
avg
)
{
if
(
values
.
length
<
=
1
)
{
return
0
;
}
return
Math
.
sqrt
(
values
.
map
(
function
(
v
)
{
return
Math
.
pow
(
v
-
avg
2
)
;
}
)
.
reduce
(
function
(
a
b
)
{
return
a
+
b
;
}
)
/
(
values
.
length
-
1
)
)
;
}
detectWarmup
(
values
)
{
var
MIN_WIDTH
=
3
;
var
MAX_WIDTH
=
7
;
var
d
=
window
.
talosDebug
;
function
windowStd
(
from
winSize
)
{
var
win
=
values
.
slice
(
from
from
+
winSize
)
;
return
d
.
stddev
(
win
d
.
median
(
values
)
)
;
}
var
stableFrom
=
-
1
;
var
overallAverage
=
d
.
median
(
values
)
;
for
(
var
winWidth
=
MIN_WIDTH
;
winWidth
<
MAX_WIDTH
+
1
;
winWidth
+
+
)
{
var
prevStd
=
windowStd
(
0
winWidth
)
;
for
(
var
i
=
1
;
i
<
values
.
length
-
winWidth
-
3
;
i
+
+
)
{
var
w0
=
windowStd
(
i
+
0
winWidth
)
;
var
w1
=
windowStd
(
i
+
1
winWidth
)
;
var
w2
=
windowStd
(
i
+
2
winWidth
)
;
if
(
w0
>
=
prevStd
&
&
!
(
w1
<
w0
&
&
w2
<
w1
)
)
{
if
(
i
>
stableFrom
)
{
stableFrom
=
i
;
}
break
;
}
prevStd
=
w0
;
}
}
function
withinPercentage
(
base
value
percentage
)
{
return
Math
.
abs
(
base
-
value
)
<
(
base
*
percentage
)
/
100
;
}
var
baseStd
=
d
.
stddev
(
values
.
slice
(
stableFrom
)
overallAverage
)
;
var
len
=
values
.
length
;
while
(
true
)
{
var
current
=
d
.
stddev
(
values
.
slice
(
stableFrom
-
1
)
overallAverage
)
;
if
(
stableFrom
>
0
&
&
(
current
<
baseStd
|
|
withinPercentage
(
baseStd
current
200
/
(
len
?
len
:
100
)
)
)
)
{
stableFrom
-
-
;
}
else
{
break
;
}
}
return
stableFrom
;
}
statsDisplay
(
collection
)
{
var
d
=
window
.
talosDebug
;
var
std
=
d
.
stddev
(
collection
d
.
average
(
collection
)
)
;
var
avg
=
d
.
average
(
collection
)
;
var
med
=
d
.
median
(
collection
)
;
return
(
"
Count
:
"
+
collection
.
length
+
"
\
nAverage
:
"
+
avg
.
toFixed
(
d
.
fixed
)
+
"
\
nMedian
:
"
+
med
.
toFixed
(
d
.
fixed
)
+
"
\
nStdDev
:
"
+
std
.
toFixed
(
d
.
fixed
)
+
"
(
"
+
(
(
100
*
std
)
/
(
avg
?
avg
:
1
)
)
.
toFixed
(
d
.
fixed
)
+
"
%
of
average
)
"
)
;
}
tpRecordTime
(
dataCSV
)
{
var
d
=
window
.
talosDebug
;
if
(
d
.
disabled
)
{
return
;
}
var
collection
=
(
"
"
+
dataCSV
)
.
split
(
"
"
)
.
map
(
function
(
item
)
{
return
parseFloat
(
item
)
;
}
)
;
var
res
=
d
.
statsDisplay
(
collection
)
;
var
warmup
=
d
.
ignore
>
=
0
?
d
.
ignore
:
d
.
detectWarmup
(
collection
)
;
if
(
warmup
>
=
0
)
{
res
+
=
"
\
n
\
nWarmup
"
+
(
d
.
ignore
>
=
0
?
"
requested
:
"
:
"
auto
-
detected
:
"
)
+
warmup
;
var
warmedUp
=
collection
.
slice
(
warmup
)
;
if
(
warmup
)
{
res
+
=
"
\
nAfter
ignoring
first
"
+
(
warmup
>
1
?
warmup
+
"
items
"
:
"
item
"
)
+
"
:
\
n
"
;
res
+
=
d
.
statsDisplay
(
warmedUp
)
;
}
}
else
{
res
+
=
"
\
n
\
nWarmup
auto
-
detection
:
Failed
.
"
;
}
if
(
d
.
displayData
)
{
var
disp
=
collection
.
map
(
function
(
item
)
{
return
item
.
toFixed
(
d
.
fixed
)
;
}
)
;
if
(
warmup
>
=
0
)
{
disp
.
splice
(
warmup
0
"
[
warmed
-
up
:
]
"
)
;
}
res
+
=
"
\
n
\
nRecorded
:
\
n
"
+
disp
.
join
(
"
"
)
;
res
+
=
"
\
n
\
nStddev
from
item
NN
to
last
:
\
n
"
;
disp
=
collection
.
map
(
function
(
value
index
)
{
return
d
.
stddev
(
collection
.
slice
(
index
)
d
.
average
(
collection
.
slice
(
index
)
)
)
.
toFixed
(
d
.
fixed
)
;
}
)
;
if
(
warmup
>
=
0
)
{
disp
.
splice
(
warmup
0
"
[
warmed
-
up
:
]
"
)
;
}
res
+
=
disp
.
join
(
"
"
)
;
}
else
{
res
+
=
"
\
n
\
n
[
set
window
.
talosDebug
.
displayData
=
true
for
data
]
"
;
}
alert
(
res
)
;
}
}
;
if
(
typeof
tpRecordTime
=
=
=
"
undefined
"
)
{
tpRecordTime
=
window
.
talosDebug
.
tpRecordTime
;
}
