"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
StartupPerformance
"
"
resource
:
/
/
/
modules
/
sessionstore
/
StartupPerformance
.
jsm
"
)
;
const
WINDOW_READY_TOPIC
=
"
browser
-
idle
-
startup
-
tasks
-
finished
"
;
const
MSG_REQUEST
=
"
session
-
restore
-
test
?
duration
"
;
const
MSG_PROVIDE
=
"
session
-
restore
-
test
:
duration
"
;
const
sessionRestoreTest
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
observe
:
function
DS_observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
StartupPerformance
.
RESTORED_TOPIC
:
this
.
onReady
(
true
)
;
break
;
case
WINDOW_READY_TOPIC
:
Services
.
obs
.
removeObserver
(
this
WINDOW_READY_TOPIC
)
;
this
.
onWindow
(
aSubject
)
;
break
;
default
:
throw
new
Error
(
Unknown
topic
{
aTopic
}
)
;
}
}
init
(
)
{
if
(
StartupPerformance
.
isRestored
)
{
this
.
onReady
(
true
)
;
}
else
{
let
sessionStartup
=
Cc
[
"
mozilla
.
org
/
browser
/
sessionstartup
;
1
"
]
.
getService
(
Ci
.
nsISessionStartup
)
;
sessionStartup
.
onceInitialized
.
then
(
(
)
=
>
{
if
(
sessionStartup
.
sessionType
=
=
Ci
.
nsISessionStartup
.
NO_SESSION
|
|
sessionStartup
.
sessionType
=
=
Ci
.
nsISessionStartup
.
DEFER_SESSION
)
{
this
.
onReady
(
false
)
;
}
else
{
Services
.
obs
.
addObserver
(
this
StartupPerformance
.
RESTORED_TOPIC
)
;
}
}
)
;
}
}
onReady
(
hasRestoredTabs
)
{
if
(
hasRestoredTabs
)
{
Services
.
obs
.
removeObserver
(
this
StartupPerformance
.
RESTORED_TOPIC
)
;
}
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
!
win
|
|
!
win
.
gBrowserInit
|
|
!
win
.
gBrowserInit
.
idleTasksFinished
)
{
Services
.
obs
.
addObserver
(
this
WINDOW_READY_TOPIC
)
;
}
else
{
this
.
onWindow
(
win
)
;
}
try
{
setTimeout
(
function
(
)
{
let
startup_info
=
Services
.
startup
.
getStartupInfo
(
)
;
let
duration
=
hasRestoredTabs
?
StartupPerformance
.
latestRestoredTimeStamp
-
startup_info
.
sessionRestoreInit
:
startup_info
.
sessionRestored
-
startup_info
.
sessionRestoreInit
;
Services
.
ppmm
.
broadcastAsyncMessage
(
MSG_PROVIDE
{
duration
}
)
;
Services
.
ppmm
.
addMessageListener
(
MSG_REQUEST
function
listener
(
)
{
Services
.
ppmm
.
removeMessageListener
(
MSG_REQUEST
listener
)
;
Services
.
ppmm
.
broadcastAsyncMessage
(
MSG_PROVIDE
{
duration
}
)
;
}
)
;
}
0
)
;
}
catch
(
ex
)
{
dump
(
SessionRestoreTalosTest
:
error
{
ex
}
\
n
)
;
dump
(
ex
.
stack
)
;
dump
(
"
\
n
"
)
;
}
}
onWindow
(
win
)
{
let
args
=
win
.
arguments
[
0
]
;
let
queryString
=
"
"
;
if
(
args
&
&
args
instanceof
Ci
.
nsIArray
)
{
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
let
url
=
new
URL
(
args
.
queryElementAt
(
0
Ci
.
nsISupportsString
)
.
data
)
;
queryString
=
url
.
search
;
}
win
.
gBrowser
.
addTab
(
"
chrome
:
/
/
session
-
restore
-
test
/
content
/
index
.
html
"
+
queryString
)
;
}
}
;
function
startup
(
data
reason
)
{
sessionRestoreTest
.
init
(
)
;
}
function
shutdown
(
data
reason
)
{
}
function
install
(
data
reason
)
{
}
function
uninstall
(
data
reason
)
{
}
