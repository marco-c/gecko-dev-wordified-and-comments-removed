"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
sys
.
mjs
"
SessionStartup
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStartup
.
sys
.
mjs
"
StartupPerformance
:
"
resource
:
/
/
/
modules
/
sessionstore
/
StartupPerformance
.
sys
.
mjs
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
}
)
;
this
.
sessionrestore
=
class
extends
ExtensionAPI
{
onStartup
(
)
{
this
.
promiseIdleFinished
=
Promise
.
withResolvers
(
)
;
Services
.
obs
.
addObserver
(
this
"
browser
-
idle
-
startup
-
tasks
-
finished
"
)
;
this
.
run
(
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
browser
-
idle
-
startup
-
tasks
-
finished
"
)
{
this
.
promiseIdleFinished
.
resolve
(
)
;
}
}
async
ensureTalosParentProfiler
(
)
{
async
function
getTalosParentProfiler
(
)
{
try
{
var
{
TalosParentProfiler
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
talos
-
powers
/
TalosParentProfiler
.
sys
.
mjs
"
)
;
return
TalosParentProfiler
;
}
catch
(
err
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
500
)
)
;
return
getTalosParentProfiler
(
)
;
}
}
this
.
TalosParentProfiler
=
await
getTalosParentProfiler
(
)
;
}
async
finishProfiling
(
msg
)
{
await
this
.
ensureTalosParentProfiler
(
)
;
if
(
!
BrowserWindowTracker
.
windowCount
)
{
const
BROWSER_WINDOW_READY_TOPIC
=
"
browser
-
delayed
-
startup
-
finished
"
;
await
new
Promise
(
resolve
=
>
{
let
observe
=
async
(
)
=
>
{
Services
.
obs
.
removeObserver
(
observe
BROWSER_WINDOW_READY_TOPIC
)
;
resolve
(
)
;
}
;
Services
.
obs
.
addObserver
(
observe
BROWSER_WINDOW_READY_TOPIC
)
;
}
)
;
}
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
let
args
=
win
.
arguments
[
0
]
;
if
(
args
&
&
args
instanceof
Ci
.
nsIArray
)
{
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
let
url
=
new
URL
(
args
.
queryElementAt
(
0
Ci
.
nsISupportsString
)
.
data
)
;
this
.
TalosParentProfiler
.
initFromURLQueryParams
(
url
.
search
)
;
}
await
this
.
TalosParentProfiler
.
subtestEnd
(
msg
)
;
await
this
.
TalosParentProfiler
.
finishStartupProfiling
(
)
;
}
async
run
(
)
{
try
{
let
didRestore
=
true
;
if
(
!
StartupPerformance
.
isRestored
)
{
await
SessionStartup
.
onceInitialized
;
if
(
SessionStartup
.
sessionType
=
=
SessionStartup
.
NO_SESSION
|
|
SessionStartup
.
sessionType
=
=
SessionStartup
.
DEFER_SESSION
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
talos
.
sessionrestore
.
norestore
"
false
)
)
{
throw
new
Error
(
"
Session
was
not
restored
!
"
)
;
}
await
this
.
finishProfiling
(
"
This
test
measures
the
time
between
process
"
+
"
creation
and
sessionRestored
.
"
)
;
didRestore
=
false
;
}
else
{
await
new
Promise
(
resolve
=
>
{
let
observe
=
async
(
)
=
>
{
Services
.
obs
.
removeObserver
(
observe
StartupPerformance
.
RESTORED_TOPIC
)
;
await
this
.
finishProfiling
(
"
This
test
measures
the
time
between
process
"
+
"
creation
and
the
last
restored
tab
.
"
)
;
resolve
(
)
;
}
;
Services
.
obs
.
addObserver
(
observe
StartupPerformance
.
RESTORED_TOPIC
)
;
}
)
;
}
}
let
startup_info
=
Services
.
startup
.
getStartupInfo
(
)
;
let
restoreTime
=
didRestore
?
StartupPerformance
.
latestRestoredTimeStamp
:
startup_info
.
sessionRestored
;
let
duration
=
restoreTime
-
startup_info
.
process
;
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
dump
(
"
__start_report
"
+
duration
+
"
__end_report
\
n
\
n
"
)
;
dump
(
"
__startTimestamp
"
+
win
.
performance
.
now
(
)
+
"
__endTimestamp
\
n
\
n
"
)
;
}
catch
(
ex
)
{
dump
(
SessionRestoreTalosTest
:
error
{
ex
}
\
n
)
;
dump
(
ex
.
stack
)
;
dump
(
"
\
n
"
)
;
}
await
this
.
promiseIdleFinished
.
promise
;
Services
.
startup
.
quit
(
Services
.
startup
.
eForceQuit
)
;
}
}
;
