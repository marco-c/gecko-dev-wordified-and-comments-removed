"
use
strict
"
;
var
escope
=
require
(
"
escope
"
)
;
var
espree
=
require
(
"
espree
"
)
;
var
path
=
require
(
"
path
"
)
;
var
regexes
=
[
/
^
(
?
:
Cu
|
Components
\
.
utils
)
\
.
import
\
(
"
.
*
\
/
(
.
*
?
)
\
.
jsm
?
"
\
)
;
?
/
/
^
loader
\
.
lazyImporter
\
(
\
w
+
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyRequireGetter
\
(
\
w
+
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyServiceGetter
\
(
\
w
+
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyModuleGetter
\
(
\
w
+
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyGetter
\
(
\
w
+
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyGetter
\
(
\
w
+
"
(
\
w
+
)
"
/
]
;
module
.
exports
=
{
getAST
:
function
(
sourceText
)
{
var
config
=
this
.
getPermissiveConfig
(
)
;
return
espree
.
parse
(
sourceText
config
)
;
}
getSource
:
function
(
node
context
)
{
return
context
.
getSource
(
node
)
.
replace
(
/
[
\
r
\
n
]
+
\
s
*
/
g
"
"
)
.
replace
(
/
\
s
*
=
\
s
*
/
g
"
=
"
)
.
replace
(
/
\
s
+
\
.
/
g
"
.
"
)
.
replace
(
/
\
s
+
/
g
"
"
)
.
replace
(
/
;
\
n
(
\
d
+
)
/
g
"
;
1
"
)
.
replace
(
/
\
s
+
/
g
"
"
)
;
}
getVarNameFromImportSource
:
function
(
source
)
{
for
(
var
i
=
0
;
i
<
regexes
.
length
;
i
+
+
)
{
var
regex
=
regexes
[
i
]
;
var
matches
=
source
.
match
(
regex
)
;
if
(
matches
)
{
var
name
=
matches
[
1
]
;
return
name
;
}
}
}
getGlobals
:
function
(
ast
)
{
var
scopeManager
=
escope
.
analyze
(
ast
)
;
var
globalScope
=
scopeManager
.
acquire
(
ast
)
;
var
result
=
[
]
;
for
(
var
variable
in
globalScope
.
variables
)
{
var
name
=
globalScope
.
variables
[
variable
]
.
name
;
result
.
push
(
name
)
;
}
return
result
;
}
addVarToScope
:
function
(
name
context
)
{
var
scope
=
context
.
getScope
(
)
;
var
variables
=
scope
.
variables
;
var
variable
=
new
escope
.
Variable
(
name
scope
)
;
variable
.
eslintExplicitGlobal
=
false
;
variable
.
writeable
=
true
;
variables
.
push
(
variable
)
;
if
(
scope
.
set
)
{
scope
.
set
.
set
(
name
variable
)
;
}
}
getTextForNode
:
function
(
node
text
)
{
var
source
=
text
.
substr
(
node
.
range
[
0
]
node
.
range
[
1
]
-
node
.
range
[
0
]
)
;
return
source
.
replace
(
/
[
\
r
\
n
]
+
\
s
*
/
g
"
"
)
.
replace
(
/
\
s
*
=
\
s
*
/
g
"
=
"
)
.
replace
(
/
\
s
+
\
.
/
g
"
.
"
)
.
replace
(
/
\
s
+
/
g
"
"
)
.
replace
(
/
;
\
n
(
\
d
+
)
/
g
"
;
1
"
)
;
}
getPermissiveConfig
:
function
(
)
{
return
{
range
:
true
loc
:
true
tolerant
:
true
ecmaFeatures
:
{
arrowFunctions
:
true
binaryLiterals
:
true
blockBindings
:
true
classes
:
true
defaultParams
:
true
destructuring
:
true
forOf
:
true
generators
:
true
globalReturn
:
true
modules
:
true
objectLiteralComputedProperties
:
true
objectLiteralDuplicateProperties
:
true
objectLiteralShorthandMethods
:
true
objectLiteralShorthandProperties
:
true
octalLiterals
:
true
regexUFlag
:
true
regexYFlag
:
true
restParams
:
true
spread
:
true
superInFunctions
:
true
templateStrings
:
true
unicodeCodePointEscapes
:
true
}
}
;
}
getIsGlobalScope
:
function
(
context
)
{
var
ancestors
=
context
.
getAncestors
(
)
;
var
parent
=
ancestors
.
pop
(
)
;
if
(
parent
.
type
=
=
"
ExpressionStatement
"
)
{
parent
=
ancestors
.
pop
(
)
;
}
return
parent
.
type
=
=
"
Program
"
;
}
getIsBrowserMochitest
:
function
(
scope
)
{
var
pathAndFilename
=
scope
.
getFilename
(
)
;
return
/
.
*
[
\
\
/
]
browser_
.
+
\
.
js
/
.
test
(
pathAndFilename
)
;
}
getAbsoluteFilePath
:
function
(
context
)
{
var
fileName
=
context
.
getFilename
(
)
;
var
cwd
=
process
.
cwd
(
)
;
if
(
path
.
isAbsolute
(
fileName
)
)
{
return
fileName
;
}
else
{
var
dirName
=
path
.
dirname
(
fileName
)
;
return
cwd
.
slice
(
0
cwd
.
length
-
dirName
.
length
)
+
fileName
;
}
}
}
;
