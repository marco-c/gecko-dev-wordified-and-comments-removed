"
use
strict
"
;
var
escope
=
require
(
"
escope
"
)
;
var
espree
=
require
(
"
espree
"
)
;
var
estraverse
=
require
(
"
estraverse
"
)
;
var
path
=
require
(
"
path
"
)
;
var
fs
=
require
(
"
fs
"
)
;
var
definitions
=
[
/
^
loader
\
.
lazyGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyImporter
\
(
this
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyServiceGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyRequireGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyModuleGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyServiceGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineConstant
\
(
this
"
(
\
w
+
)
"
/
/
^
DevToolsUtils
\
.
defineLazyModuleGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
DevToolsUtils
\
.
defineLazyGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
Object
\
.
defineProperty
\
(
this
"
(
\
w
+
)
"
/
/
^
Reflect
\
.
defineProperty
\
(
this
"
(
\
w
+
)
"
/
/
^
this
\
.
__defineGetter__
\
(
"
(
\
w
+
)
"
/
/
^
this
\
.
(
\
w
+
)
=
/
]
;
var
imports
=
[
/
^
(
?
:
Cu
|
Components
\
.
utils
)
\
.
import
\
(
"
.
*
\
/
(
.
*
?
)
\
.
jsm
?
"
(
?
:
this
)
?
\
)
/
]
;
module
.
exports
=
{
getAST
:
function
(
sourceText
)
{
var
config
=
this
.
getPermissiveConfig
(
)
;
return
espree
.
parse
(
sourceText
config
)
;
}
getASTSource
:
function
(
node
)
{
switch
(
node
.
type
)
{
case
"
MemberExpression
"
:
if
(
node
.
computed
)
throw
new
Error
(
"
getASTSource
unsupported
computed
MemberExpression
"
)
;
return
this
.
getASTSource
(
node
.
object
)
+
"
.
"
+
this
.
getASTSource
(
node
.
property
)
;
case
"
ThisExpression
"
:
return
"
this
"
;
case
"
Identifier
"
:
return
node
.
name
;
case
"
Literal
"
:
return
JSON
.
stringify
(
node
.
value
)
;
case
"
CallExpression
"
:
var
args
=
node
.
arguments
.
map
(
a
=
>
this
.
getASTSource
(
a
)
)
.
join
(
"
"
)
;
return
this
.
getASTSource
(
node
.
callee
)
+
"
(
"
+
args
+
"
)
"
;
case
"
ObjectExpression
"
:
return
"
{
}
"
;
case
"
ExpressionStatement
"
:
return
this
.
getASTSource
(
node
.
expression
)
+
"
;
"
;
case
"
FunctionExpression
"
:
return
"
function
(
)
{
}
"
;
case
"
ArrowFunctionExpression
"
:
return
"
(
)
=
>
{
}
"
;
case
"
AssignmentExpression
"
:
return
this
.
getASTSource
(
node
.
left
)
+
"
=
"
+
this
.
getASTSource
(
node
.
right
)
;
default
:
throw
new
Error
(
"
getASTSource
unsupported
node
type
:
"
+
node
.
type
)
;
}
}
walkAST
(
ast
listener
)
{
let
parents
=
[
]
;
let
seenComments
=
new
Set
(
)
;
function
sendCommentEvents
(
comments
)
{
if
(
!
comments
)
{
return
;
}
for
(
let
comment
of
comments
)
{
if
(
seenComments
.
has
(
comment
)
)
{
return
;
}
seenComments
.
add
(
comment
)
;
listener
(
comment
.
type
+
"
Comment
"
comment
parents
)
;
}
}
estraverse
.
traverse
(
ast
{
enter
(
node
parent
)
{
let
leadingComments
=
node
.
leadingComments
;
if
(
node
.
type
=
=
=
"
Program
"
&
&
node
.
body
.
length
=
=
0
)
{
leadingComments
=
node
.
comments
;
}
sendCommentEvents
(
leadingComments
)
;
listener
(
node
.
type
node
parents
)
;
sendCommentEvents
(
node
.
trailingComments
)
;
parents
.
push
(
node
)
;
}
leave
(
node
parent
)
{
listener
(
node
.
type
+
"
:
exit
"
node
parents
)
;
if
(
parents
.
length
=
=
0
)
{
throw
new
Error
(
"
Left
more
nodes
than
entered
.
"
)
;
}
parents
.
pop
(
)
;
}
}
)
;
if
(
parents
.
length
)
{
throw
new
Error
(
"
Entered
more
nodes
than
left
.
"
)
;
}
}
convertExpressionToGlobal
:
function
(
node
isGlobal
)
{
try
{
var
source
=
this
.
getASTSource
(
node
)
;
}
catch
(
e
)
{
return
null
;
}
for
(
var
reg
of
definitions
)
{
var
match
=
source
.
match
(
reg
)
;
if
(
match
)
{
if
(
!
isGlobal
)
{
return
null
;
}
return
match
[
1
]
;
}
}
for
(
reg
of
imports
)
{
var
match
=
source
.
match
(
reg
)
;
if
(
match
)
{
if
(
node
.
expression
.
arguments
.
length
>
1
&
&
!
isGlobal
)
{
return
null
;
}
return
match
[
1
]
;
}
}
return
null
;
}
addVarToScope
:
function
(
name
scope
writable
)
{
if
(
scope
.
set
&
&
scope
.
set
.
has
(
name
)
)
{
return
;
}
writable
=
writable
=
=
=
undefined
?
true
:
writable
;
var
variables
=
scope
.
variables
;
var
variable
=
new
escope
.
Variable
(
name
scope
)
;
variable
.
eslintExplicitGlobal
=
false
;
variable
.
writeable
=
writable
;
variables
.
push
(
variable
)
;
if
(
scope
.
set
)
{
scope
.
set
.
set
(
name
variable
)
;
}
}
addGlobals
:
function
(
globalVars
scope
)
{
globalVars
.
forEach
(
v
=
>
this
.
addVarToScope
(
v
.
name
scope
v
.
writable
)
)
;
}
getPermissiveConfig
:
function
(
)
{
return
{
comment
:
true
attachComment
:
true
range
:
true
loc
:
true
tolerant
:
true
ecmaFeatures
:
{
arrowFunctions
:
true
binaryLiterals
:
true
blockBindings
:
true
classes
:
true
defaultParams
:
true
destructuring
:
true
forOf
:
true
generators
:
true
globalReturn
:
true
modules
:
true
objectLiteralComputedProperties
:
true
objectLiteralDuplicateProperties
:
true
objectLiteralShorthandMethods
:
true
objectLiteralShorthandProperties
:
true
octalLiterals
:
true
regexUFlag
:
true
regexYFlag
:
true
restParams
:
true
spread
:
true
superInFunctions
:
true
templateStrings
:
true
unicodeCodePointEscapes
:
true
}
}
;
}
getIsGlobalScope
:
function
(
ancestors
)
{
for
(
let
parent
of
ancestors
)
{
if
(
parent
.
type
=
=
"
FunctionExpression
"
|
|
parent
.
type
=
=
"
FunctionDeclaration
"
)
{
return
false
;
}
}
return
true
;
}
getIsHeadFile
:
function
(
scope
)
{
var
pathAndFilename
=
scope
.
getFilename
(
)
;
return
/
.
*
[
\
\
/
]
head
(
_
.
+
)
?
\
.
js
/
.
test
(
pathAndFilename
)
;
}
getIsXpcshellTest
:
function
(
scope
)
{
var
pathAndFilename
=
scope
.
getFilename
(
)
;
return
/
.
*
[
\
\
/
]
test_
.
+
\
.
js
/
.
test
(
pathAndFilename
)
;
}
getIsBrowserMochitest
:
function
(
scope
)
{
var
pathAndFilename
=
scope
.
getFilename
(
)
;
return
/
.
*
[
\
\
/
]
browser_
.
+
\
.
js
/
.
test
(
pathAndFilename
)
;
}
getIsTest
:
function
(
scope
)
{
var
pathAndFilename
=
scope
.
getFilename
(
)
;
if
(
this
.
getIsXpcshellTest
(
scope
)
)
{
return
true
;
}
return
this
.
getIsBrowserMochitest
(
scope
)
;
}
getRootDir
:
function
(
context
)
{
var
fileName
=
this
.
getAbsoluteFilePath
(
context
)
;
var
dirName
=
path
.
dirname
(
fileName
)
;
while
(
dirName
&
&
!
fs
.
existsSync
(
path
.
join
(
dirName
"
.
eslintignore
"
)
)
)
{
dirName
=
path
.
dirname
(
dirName
)
;
}
if
(
!
dirName
)
{
throw
new
Error
(
"
Unable
to
find
root
of
repository
"
)
;
}
return
dirName
;
}
getAbsoluteFilePath
:
function
(
context
)
{
var
fileName
=
context
.
getFilename
(
)
;
var
cwd
=
process
.
cwd
(
)
;
if
(
path
.
isAbsolute
(
fileName
)
)
{
return
fileName
;
}
else
{
var
dirName
=
path
.
dirname
(
fileName
)
;
return
cwd
.
slice
(
0
cwd
.
length
-
dirName
.
length
)
+
fileName
;
}
}
}
;
