"
use
strict
"
;
var
escope
=
require
(
"
escope
"
)
;
var
espree
=
require
(
"
espree
"
)
;
var
estraverse
=
require
(
"
estraverse
"
)
;
var
path
=
require
(
"
path
"
)
;
var
fs
=
require
(
"
fs
"
)
;
var
definitions
=
[
/
^
loader
\
.
lazyGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyImporter
\
(
this
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyServiceGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyRequireGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyModuleGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyServiceGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineConstant
\
(
this
"
(
\
w
+
)
"
/
/
^
DevToolsUtils
\
.
defineLazyModuleGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
DevToolsUtils
\
.
defineLazyGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
Object
\
.
defineProperty
\
(
this
"
(
\
w
+
)
"
/
/
^
Reflect
\
.
defineProperty
\
(
this
"
(
\
w
+
)
"
/
/
^
this
\
.
__defineGetter__
\
(
"
(
\
w
+
)
"
/
]
;
var
imports
=
[
/
^
(
?
:
Cu
|
Components
\
.
utils
)
\
.
import
\
(
"
.
*
\
/
(
.
*
?
)
\
.
jsm
?
"
(
?
:
this
)
?
\
)
/
]
;
module
.
exports
=
{
getAST
:
function
(
sourceText
)
{
var
config
=
this
.
getPermissiveConfig
(
)
;
return
espree
.
parse
(
sourceText
config
)
;
}
getASTSource
:
function
(
node
)
{
switch
(
node
.
type
)
{
case
"
MemberExpression
"
:
if
(
node
.
computed
)
throw
new
Error
(
"
getASTSource
unsupported
computed
MemberExpression
"
)
;
return
this
.
getASTSource
(
node
.
object
)
+
"
.
"
+
this
.
getASTSource
(
node
.
property
)
;
case
"
ThisExpression
"
:
return
"
this
"
;
case
"
Identifier
"
:
return
node
.
name
;
case
"
Literal
"
:
return
JSON
.
stringify
(
node
.
value
)
;
case
"
CallExpression
"
:
var
args
=
node
.
arguments
.
map
(
a
=
>
this
.
getASTSource
(
a
)
)
.
join
(
"
"
)
;
return
this
.
getASTSource
(
node
.
callee
)
+
"
(
"
+
args
+
"
)
"
;
case
"
ObjectExpression
"
:
return
"
{
}
"
;
case
"
ExpressionStatement
"
:
return
this
.
getASTSource
(
node
.
expression
)
+
"
;
"
;
case
"
FunctionExpression
"
:
return
"
function
(
)
{
}
"
;
case
"
ArrowFunctionExpression
"
:
return
"
(
)
=
>
{
}
"
;
default
:
throw
new
Error
(
"
getASTSource
unsupported
node
type
:
"
+
node
.
type
)
;
}
}
convertExpressionToGlobal
:
function
(
node
isGlobal
)
{
try
{
var
source
=
this
.
getASTSource
(
node
)
;
}
catch
(
e
)
{
return
null
;
}
for
(
var
reg
of
definitions
)
{
var
match
=
source
.
match
(
reg
)
;
if
(
match
)
{
if
(
!
isGlobal
)
{
return
null
;
}
return
match
[
1
]
;
}
}
for
(
reg
of
imports
)
{
var
match
=
source
.
match
(
reg
)
;
if
(
match
)
{
if
(
node
.
expression
.
arguments
.
length
>
1
&
&
!
isGlobal
)
{
return
null
;
}
return
match
[
1
]
;
}
}
return
null
;
}
expressionTraverse
:
function
(
ast
callback
)
{
var
helpers
=
this
;
var
parents
=
new
Map
(
)
;
function
isGlobal
(
node
)
{
var
parent
=
parents
.
get
(
node
)
;
while
(
parent
)
{
if
(
parent
.
type
=
=
"
FunctionExpression
"
|
|
parent
.
type
=
=
"
FunctionDeclaration
"
)
{
return
false
;
}
parent
=
parents
.
get
(
parent
)
;
}
return
true
;
}
estraverse
.
traverse
(
ast
{
enter
:
function
(
node
parent
)
{
parents
.
set
(
node
parent
)
;
if
(
node
.
type
=
=
"
ExpressionStatement
"
)
{
callback
(
node
isGlobal
(
node
)
)
;
}
}
}
)
;
}
getGlobals
:
function
(
ast
)
{
var
scopeManager
=
escope
.
analyze
(
ast
)
;
var
globalScope
=
scopeManager
.
acquire
(
ast
)
;
var
result
=
[
]
;
for
(
var
variable
in
globalScope
.
variables
)
{
var
name
=
globalScope
.
variables
[
variable
]
.
name
;
result
.
push
(
name
)
;
}
var
helpers
=
this
;
this
.
expressionTraverse
(
ast
function
(
node
isGlobal
)
{
var
name
=
helpers
.
convertExpressionToGlobal
(
node
isGlobal
)
;
if
(
name
)
{
result
.
push
(
name
)
;
}
}
)
;
return
result
;
}
addVarToScope
:
function
(
name
context
)
{
var
scope
=
context
.
getScope
(
)
;
var
variables
=
scope
.
variables
;
var
variable
=
new
escope
.
Variable
(
name
scope
)
;
variable
.
eslintExplicitGlobal
=
false
;
variable
.
writeable
=
true
;
variables
.
push
(
variable
)
;
if
(
scope
.
set
)
{
scope
.
set
.
set
(
name
variable
)
;
}
}
globalCache
:
new
Map
(
)
getGlobalsForFile
:
function
(
fileName
)
{
var
content
=
fs
.
readFileSync
(
fileName
"
utf8
"
)
;
if
(
this
.
globalCache
.
has
(
fileName
)
)
{
return
this
.
globalCache
.
get
(
fileName
)
;
}
var
ast
=
this
.
getAST
(
content
)
;
var
globalVars
=
this
.
getGlobals
(
ast
)
;
this
.
globalCache
.
set
(
fileName
globalVars
)
;
return
globalVars
;
}
addGlobals
:
function
(
globalVars
context
)
{
for
(
var
i
=
0
;
i
<
globalVars
.
length
;
i
+
+
)
{
var
varName
=
globalVars
[
i
]
;
this
.
addVarToScope
(
varName
context
)
;
}
}
getPermissiveConfig
:
function
(
)
{
return
{
range
:
true
loc
:
true
tolerant
:
true
ecmaFeatures
:
{
arrowFunctions
:
true
binaryLiterals
:
true
blockBindings
:
true
classes
:
true
defaultParams
:
true
destructuring
:
true
forOf
:
true
generators
:
true
globalReturn
:
true
modules
:
true
objectLiteralComputedProperties
:
true
objectLiteralDuplicateProperties
:
true
objectLiteralShorthandMethods
:
true
objectLiteralShorthandProperties
:
true
octalLiterals
:
true
regexUFlag
:
true
regexYFlag
:
true
restParams
:
true
spread
:
true
superInFunctions
:
true
templateStrings
:
true
unicodeCodePointEscapes
:
true
}
}
;
}
getIsGlobalScope
:
function
(
context
)
{
var
ancestors
=
context
.
getAncestors
(
)
;
var
parent
=
ancestors
.
pop
(
)
;
if
(
parent
.
type
=
=
"
ExpressionStatement
"
)
{
parent
=
ancestors
.
pop
(
)
;
}
return
parent
.
type
=
=
"
Program
"
;
}
getIsBrowserMochitest
:
function
(
scope
)
{
var
pathAndFilename
=
scope
.
getFilename
(
)
;
return
/
.
*
[
\
\
/
]
browser_
.
+
\
.
js
/
.
test
(
pathAndFilename
)
;
}
getIsTest
:
function
(
scope
)
{
var
pathAndFilename
=
scope
.
getFilename
(
)
;
if
(
/
.
*
[
\
\
/
]
test_
.
+
\
.
js
/
.
test
(
pathAndFilename
)
)
{
return
true
;
}
return
this
.
getIsBrowserMochitest
(
scope
)
;
}
getRootDir
:
function
(
context
)
{
var
fileName
=
this
.
getAbsoluteFilePath
(
context
)
;
var
dirName
=
path
.
dirname
(
fileName
)
;
while
(
dirName
&
&
!
fs
.
existsSync
(
path
.
join
(
dirName
"
.
eslintignore
"
)
)
)
{
dirName
=
path
.
dirname
(
dirName
)
;
}
if
(
!
dirName
)
{
throw
new
Error
(
"
Unable
to
find
root
of
repository
"
)
;
}
return
dirName
;
}
getAbsoluteFilePath
:
function
(
context
)
{
var
fileName
=
context
.
getFilename
(
)
;
var
cwd
=
process
.
cwd
(
)
;
if
(
path
.
isAbsolute
(
fileName
)
)
{
return
fileName
;
}
else
{
var
dirName
=
path
.
dirname
(
fileName
)
;
return
cwd
.
slice
(
0
cwd
.
length
-
dirName
.
length
)
+
fileName
;
}
}
}
;
