"
use
strict
"
;
const
NS_XBL
=
"
http
:
/
/
www
.
mozilla
.
org
/
xbl
"
;
let
sax
=
require
(
"
sax
"
)
;
let
errorRegex
=
/
(
.
*
)
\
nLine
:
(
\
d
+
)
\
nColumn
:
(
\
d
+
)
\
nChar
:
(
.
*
)
/
function
parseError
(
err
)
{
let
matches
=
err
.
message
.
match
(
errorRegex
)
;
if
(
!
matches
)
return
null
;
return
{
fatal
:
true
message
:
matches
[
1
]
line
:
parseInt
(
matches
[
2
]
)
+
1
column
:
parseInt
(
matches
[
3
]
)
}
}
let
entityRegex
=
/
&
[
\
w
]
[
\
w
-
\
.
]
*
;
/
g
;
function
XMLParser
(
parser
)
{
this
.
parser
=
parser
;
parser
.
onopentag
=
this
.
onOpenTag
.
bind
(
this
)
;
parser
.
onclosetag
=
this
.
onCloseTag
.
bind
(
this
)
;
parser
.
ontext
=
this
.
onText
.
bind
(
this
)
;
parser
.
oncdata
=
this
.
onCDATA
.
bind
(
this
)
;
this
.
document
=
{
local
:
"
#
document
"
uri
:
null
children
:
[
]
}
this
.
_currentNode
=
this
.
document
;
}
XMLParser
.
prototype
=
{
parser
:
null
onOpenTag
:
function
(
tag
)
{
let
node
=
{
parentNode
:
this
.
_currentNode
local
:
tag
.
local
namespace
:
tag
.
uri
attributes
:
{
}
children
:
[
]
textContent
:
"
"
textStart
:
{
line
:
this
.
parser
.
line
column
:
this
.
parser
.
column
}
}
for
(
let
attr
of
Object
.
keys
(
tag
.
attributes
)
)
{
if
(
tag
.
attributes
[
attr
]
.
uri
=
=
"
"
)
{
node
.
attributes
[
attr
]
=
tag
.
attributes
[
attr
]
.
value
;
}
}
this
.
_currentNode
.
children
.
push
(
node
)
;
this
.
_currentNode
=
node
;
}
onCloseTag
:
function
(
tagname
)
{
this
.
_currentNode
=
this
.
_currentNode
.
parentNode
;
}
addText
:
function
(
text
)
{
this
.
_currentNode
.
textContent
+
=
text
;
}
onText
:
function
(
text
)
{
this
.
addText
(
text
.
replace
(
entityRegex
"
null
"
)
)
;
}
onCDATA
:
function
(
text
)
{
this
.
addText
(
"
"
.
repeat
(
"
<
!
[
CDATA
[
"
.
length
)
)
;
this
.
addText
(
text
)
;
}
}
function
buildCodeBlock
(
tag
prefix
suffix
indent
)
{
prefix
=
prefix
=
=
=
undefined
?
"
"
:
prefix
;
suffix
=
suffix
=
=
=
undefined
?
"
\
n
}
"
:
suffix
;
indent
=
indent
=
=
=
undefined
?
2
:
indent
;
let
text
=
tag
.
textContent
;
let
line
=
tag
.
textStart
.
line
;
let
column
=
tag
.
textStart
.
column
;
let
lines
=
text
.
split
(
"
\
n
"
)
;
while
(
lines
.
length
&
&
lines
[
0
]
.
trim
(
)
=
=
"
"
)
{
column
=
0
;
line
+
+
;
lines
.
shift
(
)
;
}
while
(
lines
.
length
&
&
lines
[
lines
.
length
-
1
]
.
trim
(
)
=
=
"
"
)
{
lines
.
pop
(
)
;
}
if
(
lines
.
length
&
&
column
)
{
lines
[
0
]
=
"
"
.
repeat
(
column
)
+
lines
[
0
]
;
}
let
indents
=
lines
.
filter
(
s
=
>
s
.
trim
(
)
.
length
>
0
)
.
map
(
s
=
>
s
.
length
-
s
.
trimLeft
(
)
.
length
)
;
let
minIndent
=
Math
.
min
.
apply
(
null
indents
)
;
let
indentstr
=
"
"
.
repeat
(
indent
)
;
lines
=
lines
.
map
(
s
=
>
s
.
length
?
indentstr
+
s
.
substring
(
minIndent
)
:
s
)
;
let
block
=
{
script
:
prefix
+
lines
.
join
(
"
\
n
"
)
+
suffix
+
"
\
n
"
line
:
line
-
prefix
.
split
(
"
\
n
"
)
.
length
indent
:
minIndent
-
indent
}
;
return
block
;
}
let
xmlParseError
=
null
;
let
blocks
=
[
]
;
module
.
exports
=
{
preprocess
:
function
(
text
filename
)
{
xmlParseError
=
null
;
blocks
=
[
]
;
let
parser
=
sax
.
parser
(
false
{
lowercase
:
true
xmlns
:
true
}
)
;
parser
.
onerror
=
function
(
err
)
{
xmlParseError
=
parseError
(
err
)
;
}
let
xp
=
new
XMLParser
(
parser
)
;
parser
.
write
(
text
)
;
let
document
=
xp
.
document
;
if
(
document
.
children
.
length
!
=
1
)
{
return
[
]
;
}
let
bindings
=
document
.
children
[
0
]
;
if
(
bindings
.
local
!
=
"
bindings
"
|
|
bindings
.
namespace
!
=
NS_XBL
)
{
return
[
]
;
}
let
scripts
=
[
]
;
for
(
let
binding
of
bindings
.
children
)
{
if
(
binding
.
local
!
=
"
binding
"
|
|
binding
.
namespace
!
=
NS_XBL
)
{
continue
;
}
for
(
let
part
of
binding
.
children
)
{
if
(
part
.
namespace
!
=
NS_XBL
)
{
continue
;
}
if
(
part
.
local
!
=
"
implementation
"
&
&
part
.
local
!
=
"
handlers
"
)
{
continue
;
}
for
(
let
item
of
part
.
children
)
{
if
(
item
.
namespace
!
=
NS_XBL
)
{
continue
;
}
switch
(
item
.
local
)
{
case
"
field
"
:
{
if
(
item
.
textContent
.
trim
(
)
.
length
=
=
0
)
{
continue
;
}
blocks
.
push
(
buildCodeBlock
(
item
"
"
"
"
0
)
)
;
break
;
}
case
"
constructor
"
:
case
"
destructor
"
:
{
blocks
.
push
(
buildCodeBlock
(
item
function
{
item
.
local
}
(
)
{
\
n
)
)
;
break
;
}
case
"
method
"
:
{
let
params
=
item
.
children
.
filter
(
n
=
>
n
.
local
=
=
"
parameter
"
&
&
n
.
namespace
=
=
NS_XBL
)
.
map
(
n
=
>
n
.
attributes
.
name
)
.
join
(
"
"
)
;
let
body
=
item
.
children
.
filter
(
n
=
>
n
.
local
=
=
"
body
"
&
&
n
.
namespace
=
=
NS_XBL
)
[
0
]
;
blocks
.
push
(
buildCodeBlock
(
body
function
{
item
.
attributes
.
name
}
(
{
params
}
)
{
\
n
)
)
;
break
;
}
case
"
property
"
:
{
for
(
let
propdef
of
item
.
children
)
{
if
(
propdef
.
namespace
!
=
NS_XBL
)
{
continue
;
}
let
params
=
propdef
.
local
=
=
"
setter
"
?
"
val
"
:
"
"
;
blocks
.
push
(
buildCodeBlock
(
propdef
function
{
item
.
attributes
.
name
}
_
{
propdef
.
local
}
(
{
params
}
)
{
\
n
)
)
;
}
break
;
}
case
"
handler
"
:
{
blocks
.
push
(
buildCodeBlock
(
item
function
onevent
(
event
)
{
\
n
)
)
;
break
;
}
default
:
continue
;
}
}
}
}
return
blocks
.
map
(
b
=
>
b
.
script
)
;
}
postprocess
:
function
(
messages
filename
)
{
if
(
xmlParseError
)
{
return
[
xmlParseError
]
;
}
let
errors
=
[
]
;
for
(
let
i
=
0
;
i
<
messages
.
length
;
i
+
+
)
{
let
block
=
blocks
[
i
]
;
for
(
let
message
of
messages
[
i
]
)
{
message
.
line
+
=
block
.
line
+
1
;
message
.
column
+
=
block
.
indent
;
errors
.
push
(
message
)
;
}
}
return
errors
;
}
}
;
