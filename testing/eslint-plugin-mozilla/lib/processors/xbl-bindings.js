"
use
strict
"
;
const
NS_XBL
=
"
http
:
/
/
www
.
mozilla
.
org
/
xbl
"
;
let
sax
=
require
(
"
sax
"
)
;
let
errorRegex
=
/
(
.
*
)
\
nLine
:
(
\
d
+
)
\
nColumn
:
(
\
d
+
)
\
nChar
:
(
.
*
)
/
function
parseError
(
err
)
{
let
matches
=
err
.
message
.
match
(
errorRegex
)
;
if
(
!
matches
)
return
null
;
return
{
fatal
:
true
message
:
matches
[
1
]
line
:
parseInt
(
matches
[
2
]
)
+
1
column
:
parseInt
(
matches
[
3
]
)
}
}
function
XMLParser
(
parser
)
{
this
.
parser
=
parser
;
parser
.
onopentag
=
this
.
onOpenTag
.
bind
(
this
)
;
parser
.
onclosetag
=
this
.
onCloseTag
.
bind
(
this
)
;
parser
.
ontext
=
this
.
onText
.
bind
(
this
)
;
parser
.
oncdata
=
this
.
onText
.
bind
(
this
)
;
this
.
document
=
{
local
:
"
#
document
"
uri
:
null
children
:
[
]
}
this
.
_currentNode
=
this
.
document
;
}
XMLParser
.
prototype
=
{
parser
:
null
onOpenTag
:
function
(
tag
)
{
let
node
=
{
parentNode
:
this
.
_currentNode
local
:
tag
.
local
namespace
:
tag
.
uri
attributes
:
{
}
children
:
[
]
textContent
:
"
"
textStart
:
this
.
parser
.
line
}
for
(
let
attr
of
Object
.
keys
(
tag
.
attributes
)
)
{
if
(
tag
.
attributes
[
attr
]
.
uri
=
=
"
"
)
{
node
.
attributes
[
attr
]
=
tag
.
attributes
[
attr
]
.
value
;
}
}
this
.
_currentNode
.
children
.
push
(
node
)
;
this
.
_currentNode
=
node
;
}
onCloseTag
:
function
(
tagname
)
{
this
.
_currentNode
=
this
.
_currentNode
.
parentNode
;
}
onText
:
function
(
text
)
{
this
.
_currentNode
.
textContent
+
=
text
;
}
}
function
reindent
(
text
)
{
let
lines
=
text
.
split
(
"
\
n
"
)
;
if
(
lines
[
lines
.
length
-
1
]
.
trim
(
)
=
=
"
"
)
{
lines
.
pop
(
)
;
}
if
(
!
lines
.
length
)
{
return
"
"
;
}
let
indents
=
lines
.
filter
(
s
=
>
s
.
trim
(
)
.
length
>
0
)
.
map
(
s
=
>
s
.
length
-
s
.
trimLeft
(
)
.
length
)
;
let
minIndent
=
Math
.
min
(
.
.
.
indents
)
;
lines
=
lines
.
map
(
s
=
>
s
.
length
>
0
?
"
"
+
s
.
substring
(
minIndent
)
:
s
)
;
return
lines
.
join
(
"
\
n
"
)
+
"
\
n
"
;
}
let
xmlParseError
=
null
;
let
blockLines
=
[
]
;
module
.
exports
=
{
preprocess
:
function
(
text
filename
)
{
xmlParseError
=
null
;
blockLines
=
[
]
;
let
parser
=
sax
.
parser
(
false
{
lowercase
:
true
xmlns
:
true
}
)
;
parser
.
onerror
=
function
(
err
)
{
xmlParseError
=
parseError
(
err
)
;
}
let
xp
=
new
XMLParser
(
parser
)
;
parser
.
write
(
text
)
;
let
document
=
xp
.
document
;
if
(
document
.
children
.
length
!
=
1
)
{
return
[
]
;
}
let
bindings
=
document
.
children
[
0
]
;
if
(
bindings
.
local
!
=
"
bindings
"
|
|
bindings
.
namespace
!
=
NS_XBL
)
{
return
[
]
;
}
let
scripts
=
[
]
;
for
(
let
binding
of
bindings
.
children
)
{
if
(
binding
.
local
!
=
"
binding
"
|
|
binding
.
namespace
!
=
NS_XBL
)
{
continue
;
}
for
(
let
part
of
binding
.
children
)
{
if
(
part
.
namespace
!
=
NS_XBL
)
{
continue
;
}
if
(
part
.
local
!
=
"
implementation
"
&
&
part
.
local
!
=
"
handlers
"
)
{
continue
;
}
for
(
let
item
of
part
.
children
)
{
if
(
item
.
namespace
!
=
NS_XBL
)
{
continue
;
}
switch
(
item
.
local
)
{
case
"
field
"
:
{
let
def
=
item
.
textContent
.
trimRight
(
)
;
if
(
def
.
trim
(
)
.
length
=
=
0
)
{
continue
;
}
blockLines
.
push
(
item
.
textStart
)
;
scripts
.
push
(
let
{
item
.
attributes
.
name
}
=
{
def
}
\
n
)
;
break
;
}
case
"
constructor
"
:
case
"
destructor
"
:
{
blockLines
.
push
(
item
.
textStart
)
;
let
content
=
reindent
(
item
.
textContent
)
;
scripts
.
push
(
function
{
item
.
local
}
(
)
{
{
content
}
}
\
n
)
;
break
;
}
case
"
method
"
:
{
let
params
=
item
.
children
.
filter
(
n
=
>
n
.
local
=
=
"
parameter
"
&
&
n
.
namespace
=
=
NS_XBL
)
.
map
(
n
=
>
n
.
attributes
.
name
)
.
join
(
"
"
)
;
let
body
=
item
.
children
.
filter
(
n
=
>
n
.
local
=
=
"
body
"
&
&
n
.
namespace
=
=
NS_XBL
)
[
0
]
;
blockLines
.
push
(
body
.
textStart
)
;
body
=
reindent
(
body
.
textContent
)
;
scripts
.
push
(
function
{
item
.
attributes
.
name
}
(
{
params
}
)
{
{
body
}
}
\
n
)
break
;
}
case
"
property
"
:
{
for
(
let
propdef
of
item
.
children
)
{
if
(
propdef
.
namespace
!
=
NS_XBL
)
{
continue
;
}
blockLines
.
push
(
propdef
.
textStart
)
;
let
content
=
reindent
(
propdef
.
textContent
)
;
let
params
=
propdef
.
local
=
=
"
setter
"
?
"
val
"
:
"
"
;
scripts
.
push
(
function
{
item
.
attributes
.
name
}
_
{
propdef
.
local
}
(
{
params
}
)
{
{
content
}
}
\
n
)
;
}
break
;
}
case
"
handler
"
:
{
blockLines
.
push
(
item
.
textStart
)
;
let
content
=
reindent
(
item
.
textContent
)
;
scripts
.
push
(
function
on
{
item
.
attributes
.
event
}
(
event
)
{
{
content
}
}
\
n
)
;
break
;
}
default
:
continue
;
}
}
}
}
return
scripts
;
}
postprocess
:
function
(
messages
filename
)
{
if
(
xmlParseError
)
{
return
[
xmlParseError
]
;
}
let
errors
=
[
]
;
for
(
let
i
=
0
;
i
<
messages
.
length
;
i
+
+
)
{
let
line
=
blockLines
[
i
]
;
for
(
let
message
of
messages
[
i
]
)
{
message
.
line
+
=
line
;
errors
.
push
(
message
)
;
}
}
return
errors
;
}
}
;
