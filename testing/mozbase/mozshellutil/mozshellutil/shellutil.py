import
re
def
_tokens2re
(
*
*
tokens
)
:
    
all_tokens
=
"
|
"
.
join
(
        
"
(
?
P
<
%
s
>
%
s
)
"
%
(
name
value
)
for
name
value
in
tokens
.
items
(
)
    
)
    
nonescaped
=
r
"
(
?
<
!
\
\
)
(
?
:
%
s
)
"
%
all_tokens
    
return
re
.
compile
(
"
(
?
:
%
s
|
%
s
)
"
%
(
nonescaped
r
"
(
?
P
<
escape
>
\
\
\
\
)
"
)
)
UNQUOTED_TOKENS_RE
=
_tokens2re
(
    
whitespace
=
r
"
[
\
t
\
r
\
n
]
+
"
    
quote
=
r
'
[
\
'
"
]
'
    
comment
=
"
#
"
    
special
=
r
"
[
<
>
&
|
(
)
{
}
;
\
*
\
?
]
"
    
backslashed
=
r
"
\
\
[
^
\
\
]
"
)
DOUBLY_QUOTED_TOKENS_RE
=
_tokens2re
(
    
quote
=
'
"
'
    
backslashedquote
=
r
'
\
\
"
'
    
special
=
r
"
\
"
    
backslashed
=
r
'
\
\
[
^
\
\
"
]
'
)
ESCAPED_NEWLINES_RE
=
re
.
compile
(
r
"
\
\
\
n
"
)
SHELL_QUOTE_RE
=
re
.
compile
(
r
"
[
\
\
\
t
\
r
\
n
\
'
\
"
#
<
>
&
|
(
)
{
}
;
\
*
\
?
]
"
)
class
MetaCharacterException
(
Exception
)
:
    
def
__init__
(
self
char
)
:
        
self
.
char
=
char
class
_ClineSplitter
:
    
"
"
"
    
Parses
a
given
command
line
string
and
creates
a
list
of
command
    
and
arguments
with
wildcard
expansion
.
    
"
"
"
    
def
__init__
(
self
cline
)
:
        
self
.
arg
=
None
        
self
.
cline
=
cline
        
self
.
result
=
[
]
        
self
.
_parse_unquoted
(
)
    
def
_push
(
self
str
)
:
        
"
"
"
        
Push
the
given
string
as
part
of
the
current
argument
        
"
"
"
        
if
self
.
arg
is
None
:
            
self
.
arg
=
"
"
        
self
.
arg
+
=
str
    
def
_next
(
self
)
:
        
"
"
"
        
Finalize
current
argument
effectively
adding
it
to
the
list
.
        
"
"
"
        
if
self
.
arg
is
None
:
            
return
        
self
.
result
.
append
(
self
.
arg
)
        
self
.
arg
=
None
    
def
_parse_unquoted
(
self
)
:
        
"
"
"
        
Parse
command
line
remainder
in
the
context
of
an
unquoted
string
.
        
"
"
"
        
while
self
.
cline
:
            
m
=
UNQUOTED_TOKENS_RE
.
search
(
self
.
cline
)
            
if
not
m
:
                
self
.
_push
(
self
.
cline
)
                
break
            
if
m
.
start
(
)
:
                
self
.
_push
(
self
.
cline
[
:
m
.
start
(
)
]
)
            
self
.
cline
=
self
.
cline
[
m
.
end
(
)
:
]
            
match
=
{
name
:
value
for
name
value
in
m
.
groupdict
(
)
.
items
(
)
if
value
}
            
if
"
quote
"
in
match
:
                
if
match
[
"
quote
"
]
=
=
'
"
'
:
                    
self
.
_parse_doubly_quoted
(
)
                
else
:
                    
self
.
_parse_quoted
(
)
            
elif
"
comment
"
in
match
:
                
break
            
elif
"
special
"
in
match
:
                
raise
MetaCharacterException
(
match
[
"
special
"
]
)
            
elif
"
whitespace
"
in
match
:
                
self
.
_next
(
)
            
elif
"
escape
"
in
match
:
                
self
.
_push
(
"
\
\
"
)
            
elif
"
backslashed
"
in
match
:
                
self
.
_push
(
match
[
"
backslashed
"
]
[
1
]
)
            
else
:
                
raise
Exception
(
"
Shouldn
'
t
reach
here
"
)
        
if
self
.
arg
:
            
self
.
_next
(
)
    
def
_parse_quoted
(
self
)
:
        
index
=
self
.
cline
.
find
(
"
'
"
)
        
if
index
=
=
-
1
:
            
raise
Exception
(
"
Unterminated
quoted
string
in
command
"
)
        
self
.
_push
(
self
.
cline
[
:
index
]
)
        
self
.
cline
=
self
.
cline
[
index
+
1
:
]
    
def
_parse_doubly_quoted
(
self
)
:
        
if
not
self
.
cline
:
            
raise
Exception
(
"
Unterminated
quoted
string
in
command
"
)
        
while
self
.
cline
:
            
m
=
DOUBLY_QUOTED_TOKENS_RE
.
search
(
self
.
cline
)
            
if
not
m
:
                
raise
Exception
(
"
Unterminated
quoted
string
in
command
"
)
            
self
.
_push
(
self
.
cline
[
:
m
.
start
(
)
]
)
            
self
.
cline
=
self
.
cline
[
m
.
end
(
)
:
]
            
match
=
{
name
:
value
for
name
value
in
m
.
groupdict
(
)
.
items
(
)
if
value
}
            
if
"
quote
"
in
match
:
                
return
            
elif
"
special
"
in
match
:
                
raise
MetaCharacterException
(
match
[
"
special
"
]
)
            
elif
"
escape
"
in
match
:
                
self
.
_push
(
"
\
\
"
)
            
elif
"
backslashedquote
"
in
match
:
                
self
.
_push
(
'
"
'
)
            
elif
"
backslashed
"
in
match
:
                
self
.
_push
(
match
[
"
backslashed
"
]
)
def
split
(
cline
)
:
    
"
"
"
    
Split
the
given
command
line
string
.
    
"
"
"
    
s
=
ESCAPED_NEWLINES_RE
.
sub
(
"
"
cline
)
    
return
_ClineSplitter
(
s
)
.
result
def
_quote
(
s
)
:
    
"
"
"
Given
a
string
returns
a
version
that
can
be
used
literally
on
a
shell
    
command
line
enclosing
it
with
single
quotes
if
necessary
.
    
As
a
special
case
if
given
an
int
returns
a
string
containing
the
int
    
not
enclosed
in
quotes
.
    
"
"
"
    
if
type
(
s
)
is
int
:
        
return
f
"
{
s
}
"
    
if
s
and
not
SHELL_QUOTE_RE
.
search
(
s
)
and
s
[
0
]
!
=
"
~
"
:
        
return
s
    
t
=
type
(
s
)
    
return
t
(
"
'
%
s
'
"
)
%
s
.
replace
(
t
(
"
'
"
)
t
(
"
'
\
\
'
'
"
)
)
def
quote
(
*
strings
)
:
    
"
"
"
Given
one
or
more
strings
returns
a
quoted
string
that
can
be
used
    
literally
on
a
shell
command
line
.
        
>
>
>
quote
(
'
a
'
'
b
'
)
        
"
a
b
"
        
>
>
>
quote
(
'
a
b
'
'
c
'
)
        
"
'
a
b
'
c
"
    
"
"
"
    
return
"
"
.
join
(
_quote
(
s
)
for
s
in
strings
)
__all__
=
[
"
MetaCharacterException
"
"
split
"
"
quote
"
]
