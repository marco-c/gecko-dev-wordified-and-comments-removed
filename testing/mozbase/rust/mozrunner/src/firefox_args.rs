use
std
:
:
ffi
:
:
{
OsStr
OsString
}
;
use
crate
:
:
runner
:
:
platform
;
fn
parse_arg_name_value
<
T
>
(
arg
:
T
)
-
>
(
Option
<
String
>
Option
<
String
>
)
where
T
:
AsRef
<
OsStr
>
{
let
arg_os_str
:
&
OsStr
=
arg
.
as_ref
(
)
;
let
arg_str
=
arg_os_str
.
to_string_lossy
(
)
;
let
mut
name_start
=
0
;
let
mut
name_end
=
0
;
for
(
i
c
)
in
arg_str
.
chars
(
)
.
enumerate
(
)
{
if
i
=
=
0
{
if
!
platform
:
:
arg_prefix_char
(
c
)
{
break
;
}
}
else
if
i
=
=
1
{
if
name_end_char
(
c
)
{
break
;
}
else
if
c
!
=
'
-
'
{
name_start
=
i
;
name_end
=
name_start
+
1
;
}
else
{
name_start
=
i
+
1
;
name_end
=
name_start
;
}
}
else
{
name_end
+
=
1
;
if
name_end_char
(
c
)
{
name_end
-
=
1
;
break
;
}
}
}
let
name
=
if
name_start
>
0
&
&
name_end
>
name_start
{
Some
(
arg_str
[
name_start
.
.
name_end
]
.
into
(
)
)
}
else
{
None
}
;
let
mut
value_start
=
name_end
;
let
value_end
=
arg_str
.
len
(
)
;
let
value
=
if
value_start
<
value_end
{
if
let
Some
(
c
)
=
arg_str
[
value_start
.
.
value_end
]
.
chars
(
)
.
next
(
)
{
if
name_end_char
(
c
)
{
value_start
+
=
1
;
}
}
Some
(
arg_str
[
value_start
.
.
value_end
]
.
into
(
)
)
}
else
{
None
}
;
(
name
value
)
}
fn
name_end_char
(
c
:
char
)
-
>
bool
{
c
=
=
'
'
|
|
c
=
=
'
=
'
}
#
[
derive
(
Debug
PartialEq
)
]
pub
enum
Arg
{
Foreground
NoRemote
NamedProfile
Profile
ProfileManager
Other
(
String
)
None
}
impl
Arg
{
fn
new
(
name
:
&
str
)
-
>
Arg
{
match
&
*
name
{
"
profile
"
=
>
Arg
:
:
Profile
"
P
"
=
>
Arg
:
:
NamedProfile
"
ProfileManager
"
=
>
Arg
:
:
ProfileManager
"
foreground
"
=
>
Arg
:
:
Foreground
"
no
-
remote
"
=
>
Arg
:
:
NoRemote
_
=
>
Arg
:
:
Other
(
name
.
into
(
)
)
}
}
}
impl
<
'
a
>
From
<
&
'
a
OsString
>
for
Arg
{
fn
from
(
arg_str
:
&
OsString
)
-
>
Arg
{
if
let
(
Some
(
name
)
_
)
=
parse_arg_name_value
(
arg_str
)
{
Arg
:
:
new
(
&
name
)
}
else
{
Arg
:
:
None
}
}
}
pub
fn
parse_args
<
'
a
>
(
args
:
impl
Iterator
<
Item
=
&
'
a
OsString
>
)
-
>
Vec
<
(
Option
<
Arg
>
Option
<
String
>
)
>
{
args
.
map
(
parse_arg_name_value
)
.
map
(
|
(
name
value
)
|
{
if
let
Some
(
arg_name
)
=
name
{
(
Some
(
Arg
:
:
new
(
&
arg_name
)
)
value
)
}
else
{
(
None
value
)
}
}
)
.
collect
(
)
}
pub
fn
get_arg_value
<
'
a
>
(
mut
parsed_args
:
impl
Iterator
<
Item
=
&
'
a
(
Option
<
Arg
>
Option
<
String
>
)
>
arg
:
Arg
)
-
>
Option
<
String
>
{
let
mut
found_value
=
None
;
for
(
arg_name
arg_value
)
in
&
mut
parsed_args
{
if
let
(
Some
(
name
)
value
)
=
(
arg_name
arg_value
)
{
if
*
name
=
=
arg
{
found_value
=
value
.
clone
(
)
;
break
;
}
}
}
if
found_value
.
is_none
(
)
{
if
let
Some
(
(
None
value
)
)
=
parsed_args
.
next
(
)
{
found_value
=
value
.
clone
(
)
;
}
}
found_value
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
get_arg_value
parse_arg_name_value
parse_args
Arg
}
;
use
std
:
:
ffi
:
:
OsString
;
fn
parse
(
arg
:
&
str
name
:
Option
<
&
str
>
)
{
let
(
result
_
)
=
parse_arg_name_value
(
arg
)
;
assert_eq
!
(
result
name
.
map
(
|
x
|
x
.
to_string
(
)
)
)
;
}
#
[
test
]
fn
test_parse_arg_name_value
(
)
{
parse
(
"
-
p
"
Some
(
"
p
"
)
)
;
parse
(
"
-
-
p
"
Some
(
"
p
"
)
)
;
parse
(
"
-
-
profile
foo
"
Some
(
"
profile
"
)
)
;
parse
(
"
-
-
profile
"
Some
(
"
profile
"
)
)
;
parse
(
"
-
-
"
None
)
;
parse
(
"
"
None
)
;
parse
(
"
-
=
"
None
)
;
parse
(
"
-
-
=
"
None
)
;
parse
(
"
-
-
foo
"
None
)
;
parse
(
"
foo
"
None
)
;
parse
(
"
/
foo
"
None
)
;
parse
(
"
/
-
foo
"
None
)
;
parse
(
"
/
=
foo
"
None
)
;
parse
(
"
foo
"
None
)
;
parse
(
"
-
profile
"
Some
(
"
profile
"
)
)
;
parse
(
"
-
profile
=
foo
"
Some
(
"
profile
"
)
)
;
parse
(
"
-
profile
=
foo
"
Some
(
"
profile
"
)
)
;
parse
(
"
-
profile
abc
"
Some
(
"
profile
"
)
)
;
parse
(
"
-
profile
/
foo
"
Some
(
"
profile
"
)
)
;
}
#
[
cfg
(
target_os
=
"
windows
"
)
]
#
[
test
]
fn
test_parse_arg_name_value_windows
(
)
{
parse
(
"
/
profile
"
Some
(
"
profile
"
)
)
;
}
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
#
[
test
]
fn
test_parse_arg_name_value_non_windows
(
)
{
parse
(
"
/
profile
"
None
)
;
}
#
[
test
]
fn
test_arg_from_osstring
(
)
{
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
-
profile
"
)
)
Arg
:
:
None
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
profile
"
)
)
Arg
:
:
None
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
profile
-
P
"
)
)
Arg
:
:
None
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
profiled
"
)
)
Arg
:
:
Other
(
"
profiled
"
.
into
(
)
)
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
PROFILEMANAGER
"
)
)
Arg
:
:
Other
(
"
PROFILEMANAGER
"
.
into
(
)
)
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
-
profile
"
)
)
Arg
:
:
Profile
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
profile
foo
"
)
)
Arg
:
:
Profile
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
-
ProfileManager
"
)
)
Arg
:
:
ProfileManager
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
ProfileManager
"
)
)
Arg
:
:
ProfileManager
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
P
"
)
)
Arg
:
:
NamedProfile
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
P
test
"
)
)
Arg
:
:
NamedProfile
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
-
foreground
"
)
)
Arg
:
:
Foreground
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
foreground
"
)
)
Arg
:
:
Foreground
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
-
no
-
remote
"
)
)
Arg
:
:
NoRemote
)
;
assert_eq
!
(
Arg
:
:
from
(
&
OsString
:
:
from
(
"
-
no
-
remote
"
)
)
Arg
:
:
NoRemote
)
;
}
#
[
test
]
fn
test_get_arg_value
(
)
{
let
args
=
vec
!
[
"
-
P
"
"
ProfileName
"
"
-
-
profile
=
/
path
/
"
"
-
-
no
-
remote
"
]
.
iter
(
)
.
map
(
|
x
|
OsString
:
:
from
(
x
)
)
.
collect
:
:
<
Vec
<
OsString
>
>
(
)
;
let
parsed_args
=
parse_args
(
args
.
iter
(
)
)
;
assert_eq
!
(
get_arg_value
(
parsed_args
.
iter
(
)
Arg
:
:
NamedProfile
)
Some
(
"
ProfileName
"
.
into
(
)
)
)
;
assert_eq
!
(
get_arg_value
(
parsed_args
.
iter
(
)
Arg
:
:
Profile
)
Some
(
"
/
path
/
"
.
into
(
)
)
)
;
assert_eq
!
(
get_arg_value
(
parsed_args
.
iter
(
)
Arg
:
:
NoRemote
)
None
)
;
let
args
=
vec
!
[
"
-
-
profile
=
"
"
-
P
test
"
]
.
iter
(
)
.
map
(
|
x
|
OsString
:
:
from
(
x
)
)
.
collect
:
:
<
Vec
<
OsString
>
>
(
)
;
let
parsed_args
=
parse_args
(
args
.
iter
(
)
)
;
assert_eq
!
(
get_arg_value
(
parsed_args
.
iter
(
)
Arg
:
:
NamedProfile
)
Some
(
"
test
"
.
into
(
)
)
)
;
assert_eq
!
(
get_arg_value
(
parsed_args
.
iter
(
)
Arg
:
:
Profile
)
Some
(
"
"
.
into
(
)
)
)
;
}
}
