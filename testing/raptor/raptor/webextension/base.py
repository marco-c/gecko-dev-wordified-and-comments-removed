from
__future__
import
absolute_import
import
json
import
os
import
requests
import
time
from
benchmark
import
Benchmark
from
cmdline
import
CHROMIUM_DISTROS
from
control_server
import
RaptorControlServer
from
gen_test_config
import
gen_test_config
from
logger
.
logger
import
RaptorLogger
from
memory
import
generate_android_memory_profile
from
perftest
import
Perftest
from
results
import
RaptorResultsHandler
LOG
=
RaptorLogger
(
component
=
"
raptor
-
webext
"
)
here
=
os
.
path
.
abspath
(
os
.
path
.
dirname
(
__file__
)
)
webext_dir
=
os
.
path
.
join
(
here
"
.
.
"
"
.
.
"
"
webext
"
)
class
WebExtension
(
Perftest
)
:
    
"
"
"
Container
class
for
WebExtension
.
"
"
"
    
def
__init__
(
self
*
args
*
*
kwargs
)
:
        
self
.
raptor_webext
=
None
        
self
.
control_server
=
None
        
self
.
cpu_profiler
=
None
        
super
(
WebExtension
self
)
.
__init__
(
*
args
*
*
kwargs
)
        
self
.
using_condprof
=
self
.
config
.
get
(
"
using_condprof
"
True
)
        
self
.
results_handler
=
RaptorResultsHandler
(
*
*
self
.
config
)
        
browser_name
browser_version
=
self
.
get_browser_meta
(
)
        
self
.
results_handler
.
add_browser_meta
(
self
.
config
[
"
app
"
]
browser_version
)
        
self
.
start_control_server
(
)
    
def
run_test_setup
(
self
test
)
:
        
super
(
WebExtension
self
)
.
run_test_setup
(
test
)
        
LOG
.
info
(
"
starting
web
extension
test
:
%
s
"
%
test
[
"
name
"
]
)
        
LOG
.
info
(
"
test
settings
:
%
s
"
%
str
(
test
)
)
        
LOG
.
info
(
"
web
extension
config
:
%
s
"
%
str
(
self
.
config
)
)
        
if
test
.
get
(
"
type
"
)
=
=
"
benchmark
"
:
            
self
.
serve_benchmark_source
(
test
)
        
gen_test_config
(
            
test
[
"
name
"
]
            
self
.
control_server
.
port
            
self
.
post_startup_delay
            
host
=
self
.
config
[
"
host
"
]
            
b_port
=
int
(
self
.
benchmark
.
port
)
if
self
.
benchmark
else
0
            
debug_mode
=
1
if
self
.
debug_mode
else
0
            
browser_cycle
=
test
.
get
(
"
browser_cycle
"
1
)
        
)
        
self
.
install_raptor_webext
(
)
    
def
wait_for_test_finish
(
self
test
timeout
process_exists_callback
=
None
)
:
        
timeout
=
int
(
timeout
/
1000
)
*
int
(
test
.
get
(
"
page_cycles
"
1
)
)
        
timeout
+
=
int
(
self
.
post_startup_delay
/
1000
)
+
10
        
if
test
.
get
(
"
type
"
)
=
=
"
pageload
"
:
            
timeout
+
=
10
*
int
(
test
.
get
(
"
page_cycles
"
1
)
)
        
if
self
.
config
[
"
gecko_profile
"
]
is
True
:
            
timeout
+
=
5
*
60
        
timeout
+
=
60
        
end_time
=
time
.
time
(
)
+
timeout
-
5
        
while
not
self
.
control_server
.
_finished
:
            
if
not
self
.
control_server
.
_is_shutting_down
:
                
if
callable
(
process_exists_callback
)
and
not
process_exists_callback
(
)
:
                    
raise
RuntimeError
(
"
Process
has
been
unexpectedly
closed
"
)
            
if
self
.
config
[
"
enable_control_server_wait
"
]
:
                
response
=
self
.
control_server_wait_get
(
)
                
if
response
=
=
"
webext_shutdownBrowser
"
:
                    
if
self
.
config
[
"
memory_test
"
]
:
                        
generate_android_memory_profile
(
self
test
[
"
name
"
]
)
                    
if
self
.
cpu_profiler
:
                        
self
.
cpu_profiler
.
generate_android_cpu_profile
(
test
[
"
name
"
]
)
                    
self
.
control_server_wait_continue
(
)
            
time
.
sleep
(
1
)
            
if
not
self
.
debug_mode
and
end_time
<
time
.
time
(
)
:
                
self
.
control_server
.
wait_for_quit
(
)
                
if
not
self
.
control_server
.
is_webextension_loaded
:
                    
raise
RuntimeError
(
"
Connection
to
Raptor
webextension
failed
!
"
)
                
raise
RuntimeError
(
                    
"
Test
failed
to
finish
.
"
                    
"
Application
timed
out
after
{
}
seconds
"
.
format
(
timeout
)
                
)
        
if
self
.
control_server
.
_runtime_error
:
            
raise
RuntimeError
(
"
Failed
to
run
{
}
:
{
}
\
nStack
:
\
n
{
}
"
.
format
(
                
test
[
"
name
"
]
                
self
.
control_server
.
_runtime_error
[
"
error
"
]
                
self
.
control_server
.
_runtime_error
[
"
stack
"
]
            
)
)
    
def
run_test_teardown
(
self
test
)
:
        
super
(
WebExtension
self
)
.
run_test_teardown
(
test
)
        
if
self
.
playback
is
not
None
:
            
self
.
playback
.
stop
(
)
            
confidence_values
=
self
.
playback
.
confidence
(
)
            
if
confidence_values
:
                
mozproxy_replay
=
{
                    
u
'
summarize
-
values
'
:
False
                    
u
'
suite
-
suffix
-
type
'
:
False
                    
u
'
type
'
:
u
'
mozproxy
'
                    
u
'
test
'
:
test
[
"
name
"
]
                    
u
'
unit
'
:
u
'
a
.
u
.
'
                    
u
'
values
'
:
confidence_values
                    
u
'
shouldAlert
'
:
False
                
}
                
self
.
control_server
.
submit_supporting_data
(
mozproxy_replay
)
            
else
:
                
LOG
.
info
(
"
Mozproxy
replay
confidence
data
not
available
!
"
)
            
self
.
playback
=
None
        
self
.
remove_raptor_webext
(
)
    
def
set_browser_test_prefs
(
self
raw_prefs
)
:
        
LOG
.
info
(
"
setting
test
-
specific
Firefox
preferences
"
)
        
self
.
profile
.
set_preferences
(
json
.
loads
(
raw_prefs
)
)
    
def
build_browser_profile
(
self
)
:
        
super
(
WebExtension
self
)
.
build_browser_profile
(
)
        
if
self
.
control_server
:
            
self
.
control_server
.
user_profile
=
self
.
profile
    
def
start_control_server
(
self
)
:
        
self
.
control_server
=
RaptorControlServer
(
            
self
.
results_handler
            
self
.
debug_mode
        
)
        
self
.
control_server
.
user_profile
=
self
.
profile
        
self
.
control_server
.
start
(
)
        
if
self
.
config
[
"
enable_control_server_wait
"
]
:
            
self
.
control_server_wait_set
(
"
webext_shutdownBrowser
"
)
    
def
serve_benchmark_source
(
self
test
)
:
        
self
.
benchmark
=
Benchmark
(
self
.
config
test
)
    
def
install_raptor_webext
(
self
)
:
        
self
.
raptor_webext
=
os
.
path
.
join
(
webext_dir
"
raptor
"
)
        
LOG
.
info
(
"
installing
webext
%
s
"
%
self
.
raptor_webext
)
        
self
.
profile
.
addons
.
install
(
self
.
raptor_webext
)
        
try
:
            
self
.
webext_id
=
self
.
profile
.
addons
.
addon_details
(
self
.
raptor_webext
)
[
"
id
"
]
        
except
AttributeError
:
            
self
.
webext_id
=
None
        
self
.
control_server
.
startup_handler
(
False
)
    
def
remove_raptor_webext
(
self
)
:
        
if
not
self
.
raptor_webext
:
            
LOG
.
info
(
"
raptor
webext
not
installed
-
not
attempting
removal
"
)
            
return
        
LOG
.
info
(
"
removing
webext
%
s
"
%
self
.
raptor_webext
)
        
if
self
.
config
[
"
app
"
]
in
[
"
firefox
"
"
geckoview
"
"
fennec
"
"
refbrow
"
"
fenix
"
]
:
            
self
.
profile
.
addons
.
remove_addon
(
self
.
webext_id
)
        
chrome_apps
=
CHROMIUM_DISTROS
+
[
"
chrome
-
android
"
"
chromium
-
android
"
]
        
if
self
.
config
[
"
app
"
]
in
chrome_apps
:
            
self
.
profile
.
addons
.
remove
(
self
.
raptor_webext
)
        
self
.
raptor_webext
=
None
    
def
clean_up
(
self
)
:
        
super
(
WebExtension
self
)
.
clean_up
(
)
        
if
self
.
config
[
"
enable_control_server_wait
"
]
:
            
self
.
control_server_wait_clear
(
"
all
"
)
        
self
.
control_server
.
stop
(
)
        
LOG
.
info
(
"
finished
"
)
    
def
control_server_wait_set
(
self
state
)
:
        
response
=
requests
.
post
(
            
"
http
:
/
/
127
.
0
.
0
.
1
:
%
s
/
"
%
self
.
control_server
.
port
            
json
=
{
"
type
"
:
"
wait
-
set
"
"
data
"
:
state
}
        
)
        
return
response
.
text
    
def
control_server_wait_timeout
(
self
timeout
)
:
        
response
=
requests
.
post
(
            
"
http
:
/
/
127
.
0
.
0
.
1
:
%
s
/
"
%
self
.
control_server
.
port
            
json
=
{
"
type
"
:
"
wait
-
timeout
"
"
data
"
:
timeout
}
        
)
        
return
response
.
text
    
def
control_server_wait_get
(
self
)
:
        
response
=
requests
.
post
(
            
"
http
:
/
/
127
.
0
.
0
.
1
:
%
s
/
"
%
self
.
control_server
.
port
            
json
=
{
"
type
"
:
"
wait
-
get
"
"
data
"
:
"
"
}
        
)
        
return
response
.
text
    
def
control_server_wait_continue
(
self
)
:
        
response
=
requests
.
post
(
            
"
http
:
/
/
127
.
0
.
0
.
1
:
%
s
/
"
%
self
.
control_server
.
port
            
json
=
{
"
type
"
:
"
wait
-
continue
"
"
data
"
:
"
"
}
        
)
        
return
response
.
text
    
def
control_server_wait_clear
(
self
state
)
:
        
response
=
requests
.
post
(
            
"
http
:
/
/
127
.
0
.
0
.
1
:
%
s
/
"
%
self
.
control_server
.
port
            
json
=
{
"
type
"
:
"
wait
-
clear
"
"
data
"
:
state
}
        
)
        
return
response
.
text
