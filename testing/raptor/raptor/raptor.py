from
__future__
import
absolute_import
from
abc
import
ABCMeta
abstractmethod
import
json
import
os
import
posixpath
import
re
import
shutil
import
signal
import
six
import
subprocess
import
sys
import
tempfile
import
time
import
requests
import
mozcrash
import
mozinfo
import
mozprocess
import
mozproxy
.
utils
as
mpu
import
mozversion
from
logger
.
logger
import
RaptorLogger
from
mozdevice
import
ADBDevice
from
mozlog
import
commandline
from
mozpower
import
MozPower
from
mozprofile
import
create_profile
from
mozproxy
import
get_playback
from
mozrunner
import
runners
here
=
os
.
path
.
abspath
(
os
.
path
.
dirname
(
__file__
)
)
paths
=
[
here
]
webext_dir
=
os
.
path
.
join
(
here
'
.
.
'
'
webext
'
)
paths
.
append
(
webext_dir
)
for
path
in
paths
:
    
if
not
os
.
path
.
exists
(
path
)
:
        
raise
IOError
(
"
%
s
does
not
exist
.
"
%
path
)
    
sys
.
path
.
insert
(
0
path
)
try
:
    
from
mozbuild
.
base
import
MozbuildObject
    
build
=
MozbuildObject
.
from_environment
(
cwd
=
here
)
except
ImportError
:
    
build
=
None
from
benchmark
import
Benchmark
from
cmdline
import
(
parse_args
                     
FIREFOX_ANDROID_APPS
                     
CHROMIUM_DISTROS
)
from
control_server
import
RaptorControlServer
from
gecko_profile
import
GeckoProfile
from
gen_test_config
import
gen_test_config
from
outputhandler
import
OutputHandler
from
manifest
import
get_raptor_test_list
from
memory
import
generate_android_memory_profile
from
performance_tuning
import
tune_performance
from
power
import
init_android_power_test
finish_android_power_test
from
results
import
RaptorResultsHandler
BrowsertimeResultsHandler
from
utils
import
view_gecko_profile
write_yml_file
from
cpu
import
start_android_cpu_profiler
LOG
=
RaptorLogger
(
component
=
'
raptor
-
main
'
)
mpu
.
LOG
=
RaptorLogger
(
component
=
'
raptor
-
mitmproxy
'
)
DEFAULT_CHROMEVERSION
=
'
77
'
class
SignalHandler
:
    
def
__init__
(
self
)
:
        
signal
.
signal
(
signal
.
SIGINT
self
.
handle_signal
)
        
signal
.
signal
(
signal
.
SIGTERM
self
.
handle_signal
)
    
def
handle_signal
(
self
signum
frame
)
:
        
raise
SignalHandlerException
(
"
Program
aborted
due
to
signal
%
s
"
%
signum
)
class
SignalHandlerException
(
Exception
)
:
    
pass
class
Perftest
(
object
)
:
    
"
"
"
Abstract
base
class
for
perftests
that
execute
via
a
subharness
either
Raptor
or
browsertime
.
"
"
"
    
__metaclass__
=
ABCMeta
    
def
__init__
(
self
app
binary
run_local
=
False
noinstall
=
False
                 
obj_path
=
None
profile_class
=
None
installerpath
=
None
                 
gecko_profile
=
False
gecko_profile_interval
=
None
gecko_profile_entries
=
None
                 
symbols_path
=
None
host
=
None
power_test
=
False
cpu_test
=
False
memory_test
=
False
                 
is_release_build
=
False
debug_mode
=
False
post_startup_delay
=
None
                 
interrupt_handler
=
None
e10s
=
True
enable_webrender
=
False
                 
results_handler_class
=
RaptorResultsHandler
                 
*
*
kwargs
)
:
        
if
host
=
=
'
HOST_IP
'
:
            
host
=
os
.
environ
[
'
HOST_IP
'
]
        
self
.
config
=
{
            
'
app
'
:
app
            
'
binary
'
:
binary
            
'
platform
'
:
mozinfo
.
os
            
'
processor
'
:
mozinfo
.
processor
            
'
run_local
'
:
run_local
            
'
obj_path
'
:
obj_path
            
'
gecko_profile
'
:
gecko_profile
            
'
gecko_profile_interval
'
:
gecko_profile_interval
            
'
gecko_profile_entries
'
:
gecko_profile_entries
            
'
symbols_path
'
:
symbols_path
            
'
host
'
:
host
            
'
power_test
'
:
power_test
            
'
memory_test
'
:
memory_test
            
'
cpu_test
'
:
cpu_test
            
'
is_release_build
'
:
is_release_build
            
'
enable_control_server_wait
'
:
memory_test
or
cpu_test
            
'
e10s
'
:
e10s
            
'
enable_webrender
'
:
enable_webrender
        
}
        
if
self
.
config
[
'
app
'
]
=
=
'
fennec
'
:
            
self
.
config
[
'
e10s
'
]
=
False
        
self
.
browser_name
=
None
        
self
.
browser_version
=
None
        
self
.
raptor_venv
=
os
.
path
.
join
(
os
.
getcwd
(
)
'
raptor
-
venv
'
)
        
self
.
installerpath
=
installerpath
        
self
.
playback
=
None
        
self
.
benchmark
=
None
        
self
.
benchmark_port
=
0
        
self
.
gecko_profiler
=
None
        
self
.
post_startup_delay
=
post_startup_delay
        
self
.
device
=
None
        
self
.
profile_class
=
profile_class
or
app
        
self
.
firefox_android_apps
=
FIREFOX_ANDROID_APPS
        
self
.
interrupt_handler
=
interrupt_handler
        
self
.
results_handler
=
results_handler_class
(
*
*
self
.
config
)
        
self
.
browser_name
self
.
browser_version
=
self
.
get_browser_meta
(
)
        
browser_name
browser_version
=
self
.
get_browser_meta
(
)
        
self
.
results_handler
.
add_browser_meta
(
self
.
config
[
'
app
'
]
browser_version
)
        
self
.
debug_mode
=
debug_mode
if
self
.
config
[
'
run_local
'
]
else
False
        
if
self
.
debug_mode
:
            
self
.
post_startup_delay
=
min
(
self
.
post_startup_delay
3000
)
            
LOG
.
info
(
"
debug
-
mode
enabled
reducing
post
-
browser
startup
pause
to
%
d
ms
"
                     
%
self
.
post_startup_delay
)
        
LOG
.
info
(
"
main
raptor
init
config
is
:
%
s
"
%
str
(
self
.
config
)
)
        
self
.
build_browser_profile
(
)
    
def
build_browser_profile
(
self
)
:
        
self
.
profile
=
create_profile
(
self
.
profile_class
)
        
with
open
(
os
.
path
.
join
(
self
.
profile_data_dir
'
profiles
.
json
'
)
'
r
'
)
as
fh
:
            
base_profiles
=
json
.
load
(
fh
)
[
'
raptor
'
]
        
for
profile
in
base_profiles
:
            
path
=
os
.
path
.
join
(
self
.
profile_data_dir
profile
)
            
LOG
.
info
(
"
Merging
profile
:
{
}
"
.
format
(
path
)
)
            
self
.
profile
.
merge
(
path
)
        
self
.
config
[
'
local_profile_dir
'
]
=
self
.
profile
.
profile
        
LOG
.
info
(
'
Local
browser
profile
:
{
}
'
.
format
(
self
.
profile
.
profile
)
)
    
property
    
def
profile_data_dir
(
self
)
:
        
if
'
MOZ_DEVELOPER_REPO_DIR
'
in
os
.
environ
:
            
return
os
.
path
.
join
(
os
.
environ
[
'
MOZ_DEVELOPER_REPO_DIR
'
]
'
testing
'
'
profiles
'
)
        
if
build
:
            
return
os
.
path
.
join
(
build
.
topsrcdir
'
testing
'
'
profiles
'
)
        
return
os
.
path
.
join
(
here
'
profile_data
'
)
    
property
    
def
artifact_dir
(
self
)
:
        
artifact_dir
=
os
.
getcwd
(
)
        
if
self
.
config
.
get
(
'
run_local
'
False
)
:
            
if
'
MOZ_DEVELOPER_REPO_DIR
'
in
os
.
environ
:
                
artifact_dir
=
os
.
path
.
join
(
os
.
environ
[
'
MOZ_DEVELOPER_REPO_DIR
'
]
                                            
'
testing
'
'
mozharness
'
'
build
'
)
            
else
:
                
artifact_dir
=
here
        
elif
os
.
getenv
(
'
MOZ_UPLOAD_DIR
'
)
:
            
artifact_dir
=
os
.
getenv
(
'
MOZ_UPLOAD_DIR
'
)
        
return
artifact_dir
    
abstractmethod
    
def
run_test_setup
(
self
test
)
:
        
LOG
.
info
(
"
starting
test
:
%
s
"
%
test
[
'
name
'
]
)
        
self
.
config
[
'
subtest_alert_on
'
]
=
test
.
get
(
'
alert_on
'
)
        
if
test
.
get
(
"
preferences
"
)
is
not
None
:
            
self
.
set_browser_test_prefs
(
test
[
'
preferences
'
]
)
    
abstractmethod
    
def
setup_chrome_args
(
self
)
:
        
pass
    
abstractmethod
    
def
get_browser_meta
(
self
)
:
        
pass
    
def
run_tests
(
self
tests
test_names
)
:
        
try
:
            
for
test
in
tests
:
                
try
:
                    
self
.
run_test
(
test
timeout
=
int
(
test
.
get
(
'
page_timeout
'
)
)
)
                
except
RuntimeError
as
e
:
                    
LOG
.
critical
(
"
Tests
failed
to
finish
!
Application
timed
out
.
"
)
                    
LOG
.
error
(
e
)
                
finally
:
                    
self
.
run_test_teardown
(
test
)
            
return
self
.
process_results
(
tests
test_names
)
        
finally
:
            
self
.
clean_up
(
)
    
abstractmethod
    
def
run_test
(
self
test
timeout
)
:
        
raise
NotImplementedError
(
)
    
abstractmethod
    
def
run_test_teardown
(
self
test
)
:
        
self
.
check_for_crashes
(
)
        
if
self
.
config
[
'
gecko_profile
'
]
is
True
:
            
self
.
gecko_profiler
.
symbolicate
(
)
            
LOG
.
info
(
"
cleaning
up
after
gecko
profiling
"
)
            
self
.
gecko_profiler
.
clean
(
)
    
def
process_results
(
self
tests
test_names
)
:
        
raptor_json_path
=
os
.
path
.
join
(
self
.
artifact_dir
'
raptor
.
json
'
)
        
if
not
self
.
config
.
get
(
'
run_local
'
False
)
:
            
raptor_json_path
=
os
.
path
.
join
(
os
.
getcwd
(
)
'
local
.
json
'
)
        
self
.
config
[
'
raptor_json_path
'
]
=
raptor_json_path
        
self
.
config
[
'
artifact_dir
'
]
=
self
.
artifact_dir
        
return
self
.
results_handler
.
summarize_and_output
(
self
.
config
tests
test_names
)
    
abstractmethod
    
def
set_browser_test_prefs
(
self
)
:
        
pass
    
abstractmethod
    
def
check_for_crashes
(
self
)
:
        
pass
    
abstractmethod
    
def
clean_up
(
self
)
:
        
pass
    
def
get_page_timeout_list
(
self
)
:
        
return
self
.
results_handler
.
page_timeout_list
    
def
get_recording_paths
(
self
test
)
:
        
recordings
=
test
.
get
(
"
playback_recordings
"
)
        
if
recordings
:
            
recording_paths
=
[
]
            
proxy_dir
=
self
.
playback
.
mozproxy_dir
            
for
recording
in
recordings
.
split
(
)
:
                
if
not
recording
:
                    
continue
                
recording_paths
.
append
(
os
.
path
.
join
(
proxy_dir
recording
)
)
            
return
recording_paths
    
def
log_recording_dates
(
self
test
)
:
        
_recording_paths
=
self
.
get_recording_paths
(
test
)
        
if
_recording_paths
is
None
:
            
LOG
.
info
(
"
No
playback
recordings
specified
in
the
test
;
so
not
getting
recording
info
"
)
            
return
        
for
r
in
_recording_paths
:
            
json_path
=
'
{
}
.
json
'
.
format
(
r
.
split
(
'
.
'
)
[
0
]
)
            
if
os
.
path
.
exists
(
json_path
)
:
                
with
open
(
json_path
)
as
f
:
                    
recording_date
=
json
.
loads
(
f
.
read
(
)
)
.
get
(
'
recording_date
'
)
                    
if
recording_date
is
not
None
:
                        
LOG
.
info
(
'
Playback
recording
date
:
{
}
'
.
                                 
format
(
recording_date
.
split
(
'
'
)
[
0
]
)
)
                    
else
:
                        
LOG
.
info
(
'
Playback
recording
date
not
available
'
)
            
else
:
                
LOG
.
info
(
'
Playback
recording
information
not
available
'
)
    
def
get_playback_config
(
self
test
)
:
        
platform
=
self
.
config
[
'
platform
'
]
        
playback_dir
=
os
.
path
.
join
(
here
'
playback
'
)
        
self
.
config
.
update
(
{
            
'
playback_tool
'
:
test
.
get
(
'
playback
'
)
            
'
playback_version
'
:
test
.
get
(
'
playback_version
'
"
4
.
0
.
4
"
)
            
'
playback_binary_zip
'
:
test
.
get
(
'
playback_binary_zip_
%
s
'
%
platform
)
            
'
playback_pageset_zip
'
:
test
.
get
(
'
playback_pageset_zip_
%
s
'
%
platform
)
            
'
playback_binary_manifest
'
:
test
.
get
(
'
playback_binary_manifest
'
)
            
'
playback_pageset_manifest
'
:
test
.
get
(
'
playback_pageset_manifest
'
)
        
}
)
        
for
key
in
(
'
playback_pageset_manifest
'
'
playback_pageset_zip
'
)
:
            
if
self
.
config
.
get
(
key
)
is
None
:
                
continue
            
self
.
config
[
key
]
=
os
.
path
.
join
(
playback_dir
self
.
config
[
key
]
)
        
LOG
.
info
(
"
test
uses
playback
tool
:
%
s
"
%
self
.
config
[
'
playback_tool
'
]
)
    
def
delete_proxy_settings_from_profile
(
self
)
:
        
userjspath
=
os
.
path
.
join
(
self
.
profile
.
profile
'
user
.
js
'
)
        
with
open
(
userjspath
)
as
userjsfile
:
            
prefs
=
userjsfile
.
readlines
(
)
        
prefs
=
[
pref
for
pref
in
prefs
if
'
network
.
proxy
'
not
in
pref
]
        
with
open
(
userjspath
'
w
'
)
as
userjsfile
:
            
userjsfile
.
writelines
(
prefs
)
    
def
start_playback
(
self
test
)
:
        
self
.
get_playback_config
(
test
)
        
self
.
playback
=
get_playback
(
self
.
config
)
        
self
.
playback
.
config
[
'
playback_files
'
]
=
self
.
get_recording_paths
(
test
)
        
self
.
playback
.
start
(
)
        
self
.
log_recording_dates
(
test
)
class
PerftestDesktop
(
Perftest
)
:
    
"
"
"
Mixin
class
for
Desktop
-
specific
Perftest
subclasses
"
"
"
    
def
setup_chrome_args
(
self
test
)
:
        
'
'
'
Sets
up
chrome
/
chromium
cmd
-
line
arguments
.
        
Needs
to
be
"
implemented
"
here
to
deal
with
Python
2
        
unittest
failures
.
        
'
'
'
        
raise
NotImplementedError
    
def
desktop_chrome_args
(
self
test
)
:
        
'
'
'
Returns
cmd
line
options
required
to
run
pageload
tests
on
Desktop
Chrome
        
and
Chromium
.
Also
add
the
cmd
line
options
to
turn
on
the
proxy
and
        
ignore
security
certificate
errors
if
using
host
localhost
127
.
0
.
0
.
1
.
        
'
'
'
        
chrome_args
=
[
            
'
-
-
use
-
mock
-
keychain
'
            
'
-
-
no
-
default
-
browser
-
check
'
        
]
        
if
test
.
get
(
'
playback
'
False
)
:
            
pb_args
=
[
                
'
-
-
proxy
-
server
=
127
.
0
.
0
.
1
:
8080
'
                
'
-
-
proxy
-
bypass
-
list
=
localhost
;
127
.
0
.
0
.
1
'
                
'
-
-
ignore
-
certificate
-
errors
'
            
]
            
if
self
.
config
[
'
host
'
]
not
in
(
'
localhost
'
'
127
.
0
.
0
.
1
'
)
:
                
pb_args
[
0
]
=
pb_args
[
0
]
.
replace
(
'
127
.
0
.
0
.
1
'
self
.
config
[
'
host
'
]
)
            
chrome_args
.
extend
(
pb_args
)
        
if
self
.
debug_mode
:
            
chrome_args
.
extend
(
[
'
-
-
auto
-
open
-
devtools
-
for
-
tabs
'
]
)
        
return
chrome_args
    
def
get_browser_meta
(
self
)
:
        
'
'
'
Returns
the
browser
name
and
version
in
a
tuple
(
name
version
)
.
        
On
desktop
we
use
mozversion
but
a
fallback
method
also
exists
        
for
non
-
firefox
browsers
where
mozversion
is
known
to
fail
.
The
        
methods
are
OS
-
specific
with
windows
being
the
outlier
.
        
'
'
'
        
browser_name
=
None
        
browser_version
=
None
        
try
:
            
meta
=
mozversion
.
get_version
(
binary
=
self
.
config
[
'
binary
'
]
)
            
browser_name
=
meta
.
get
(
'
application_name
'
)
            
browser_version
=
meta
.
get
(
'
application_version
'
)
        
except
Exception
as
e
:
            
LOG
.
warning
(
                
"
Failed
to
get
browser
meta
data
through
mozversion
:
%
s
-
%
s
"
%
                
(
e
.
__class__
.
__name__
e
)
            
)
            
LOG
.
info
(
"
Attempting
to
get
version
through
fallback
method
.
.
.
"
)
            
try
:
                
if
'
linux
'
in
self
.
config
[
'
platform
'
]
or
'
mac
'
in
self
.
config
[
'
platform
'
]
:
                    
command
=
[
self
.
config
[
'
binary
'
]
'
-
-
version
'
]
                    
proc
=
mozprocess
.
ProcessHandler
(
command
)
                    
proc
.
run
(
timeout
=
10
outputTimeout
=
10
)
                    
proc
.
wait
(
)
                    
bmeta
=
proc
.
output
                    
meta_re
=
re
.
compile
(
r
"
(
[
A
-
z
\
s
]
+
)
\
s
+
(
[
\
w
.
]
*
)
"
)
                    
if
len
(
bmeta
)
!
=
0
:
                        
match
=
meta_re
.
match
(
bmeta
[
0
]
)
                        
if
match
:
                            
browser_name
=
self
.
config
[
'
app
'
]
                            
browser_version
=
match
.
group
(
2
)
                    
else
:
                        
LOG
.
info
(
"
Couldn
'
t
get
browser
version
and
name
"
)
                
else
:
                    
command
=
r
'
wmic
datafile
where
name
=
"
{
0
}
"
'
.
format
(
                        
self
.
config
[
'
binary
'
]
.
replace
(
'
\
\
'
r
"
\
\
"
)
                    
)
                    
bmeta
=
subprocess
.
check_output
(
command
)
                    
meta_re
=
re
.
compile
(
r
"
\
s
+
(
[
\
d
.
a
-
z
]
+
)
\
s
+
"
)
                    
match
=
meta_re
.
findall
(
bmeta
)
                    
if
len
(
match
)
>
0
:
                        
browser_name
=
self
.
config
[
'
app
'
]
                        
browser_version
=
match
[
-
1
]
                    
else
:
                        
LOG
.
info
(
"
Couldn
'
t
get
browser
version
and
name
"
)
            
except
Exception
as
e
:
                
LOG
.
warning
(
                    
"
Failed
to
get
browser
meta
data
through
fallback
method
:
%
s
-
%
s
"
%
                    
(
e
.
__class__
.
__name__
e
)
                
)
        
if
not
browser_name
:
            
LOG
.
warning
(
"
Could
not
find
a
browser
name
"
)
        
else
:
            
LOG
.
info
(
"
Browser
name
:
%
s
"
%
browser_name
)
        
if
not
browser_version
:
            
LOG
.
warning
(
"
Could
not
find
a
browser
version
"
)
        
else
:
            
LOG
.
info
(
"
Browser
version
:
%
s
"
%
browser_version
)
        
return
(
browser_name
browser_version
)
class
PerftestAndroid
(
Perftest
)
:
    
"
"
"
Mixin
class
for
Android
-
specific
Perftest
subclasses
.
"
"
"
    
def
setup_chrome_args
(
self
test
)
:
        
'
'
'
Sets
up
chrome
/
chromium
cmd
-
line
arguments
.
        
Needs
to
be
"
implemented
"
here
to
deal
with
Python
2
        
unittest
failures
.
        
'
'
'
        
raise
NotImplementedError
    
def
get_browser_meta
(
self
)
:
        
'
'
'
Returns
the
browser
name
and
version
in
a
tuple
(
name
version
)
.
        
Uses
mozversion
as
the
primary
method
to
get
this
meta
data
and
for
        
android
this
is
the
only
method
which
exists
to
get
this
data
.
With
android
        
we
use
the
installerpath
attribute
to
determine
this
and
this
only
works
        
with
Firefox
browsers
.
        
'
'
'
        
browser_name
=
None
        
browser_version
=
None
        
if
self
.
config
[
'
app
'
]
in
self
.
firefox_android_apps
:
            
try
:
                
meta
=
mozversion
.
get_version
(
binary
=
self
.
installerpath
)
                
browser_name
=
meta
.
get
(
'
application_name
'
)
                
browser_version
=
meta
.
get
(
'
application_version
'
)
            
except
Exception
as
e
:
                
LOG
.
warning
(
                    
"
Failed
to
get
android
browser
meta
data
through
mozversion
:
%
s
-
%
s
"
%
                    
(
e
.
__class__
.
__name__
e
)
                
)
        
if
not
browser_name
:
            
LOG
.
warning
(
"
Could
not
find
a
browser
name
"
)
        
else
:
            
LOG
.
info
(
"
Browser
name
:
%
s
"
%
browser_name
)
        
if
not
browser_version
:
            
LOG
.
warning
(
"
Could
not
find
a
browser
version
"
)
        
else
:
            
LOG
.
info
(
"
Browser
version
:
%
s
"
%
browser_version
)
        
return
(
browser_name
browser_version
)
class
Browsertime
(
Perftest
)
:
    
"
"
"
Abstract
base
class
for
Browsertime
"
"
"
    
__metaclass__
=
ABCMeta
    
property
    
abstractmethod
    
def
browsertime_args
(
self
)
:
        
pass
    
def
__init__
(
self
app
binary
process_handler
=
None
*
*
kwargs
)
:
        
self
.
process_handler
=
process_handler
or
mozprocess
.
ProcessHandler
        
for
key
in
list
(
kwargs
)
:
            
if
key
.
startswith
(
'
browsertime_
'
)
:
                
value
=
kwargs
.
pop
(
key
)
                
setattr
(
self
key
value
)
        
def
klass
(
*
*
config
)
:
            
root_results_dir
=
os
.
path
.
join
(
os
.
environ
.
get
(
'
MOZ_UPLOAD_DIR
'
os
.
getcwd
(
)
)
                                            
'
browsertime
-
results
'
)
            
return
BrowsertimeResultsHandler
(
config
root_results_dir
=
root_results_dir
)
        
super
(
Browsertime
self
)
.
__init__
(
app
binary
results_handler_class
=
klass
*
*
kwargs
)
        
LOG
.
info
(
"
cwd
:
'
{
}
'
"
.
format
(
os
.
getcwd
(
)
)
)
        
for
k
in
(
"
browsertime_node
"
                  
"
browsertime_browsertimejs
"
                  
"
browsertime_ffmpeg
"
                  
"
browsertime_geckodriver
"
                  
"
browsertime_chromedriver
"
)
:
            
try
:
                
if
not
self
.
browsertime_video
and
k
=
=
"
browsertime_ffmpeg
"
:
                    
continue
                
LOG
.
info
(
"
{
}
:
{
}
"
.
format
(
k
getattr
(
self
k
)
)
)
                
LOG
.
info
(
"
{
}
:
{
}
"
.
format
(
k
os
.
stat
(
getattr
(
self
k
)
)
)
)
            
except
Exception
as
e
:
                
LOG
.
info
(
"
{
}
:
{
}
"
.
format
(
k
e
)
)
    
def
build_browser_profile
(
self
)
:
        
super
(
Browsertime
self
)
.
build_browser_profile
(
)
        
self
.
remove_mozprofile_delimiters_from_profile
(
)
    
def
remove_mozprofile_delimiters_from_profile
(
self
)
:
        
LOG
.
info
(
"
Removing
mozprofile
delimiters
from
browser
profile
"
)
        
userjspath
=
os
.
path
.
join
(
self
.
profile
.
profile
'
user
.
js
'
)
        
try
:
            
with
open
(
userjspath
)
as
userjsfile
:
                
lines
=
userjsfile
.
readlines
(
)
            
lines
=
[
line
for
line
in
lines
if
not
line
.
startswith
(
'
#
MozRunner
'
)
]
            
with
open
(
userjspath
'
w
'
)
as
userjsfile
:
                
userjsfile
.
writelines
(
lines
)
        
except
Exception
as
e
:
            
LOG
.
critical
(
"
Exception
{
}
while
removing
mozprofile
delimiters
"
.
format
(
e
)
)
    
def
set_browser_test_prefs
(
self
raw_prefs
)
:
        
LOG
.
info
(
"
setting
test
-
specific
Firefox
preferences
"
)
        
self
.
profile
.
set_preferences
(
json
.
loads
(
raw_prefs
)
)
    
def
run_test_setup
(
self
test
)
:
        
super
(
Browsertime
self
)
.
run_test_setup
(
test
)
        
if
test
.
get
(
'
type
'
)
=
=
"
benchmark
"
:
            
self
.
benchmark
=
Benchmark
(
self
.
config
test
)
            
test
[
'
test_url
'
]
=
test
[
'
test_url
'
]
.
replace
(
'
<
host
>
'
self
.
benchmark
.
host
)
            
test
[
'
test_url
'
]
=
test
[
'
test_url
'
]
.
replace
(
'
<
port
>
'
self
.
benchmark
.
port
)
        
if
test
.
get
(
'
playback
'
)
is
not
None
:
            
self
.
start_playback
(
test
)
        
self
.
driver_paths
=
[
]
        
if
self
.
browsertime_geckodriver
:
            
self
.
driver_paths
.
extend
(
[
'
-
-
firefox
.
geckodriverPath
'
self
.
browsertime_geckodriver
]
)
        
if
self
.
browsertime_chromedriver
:
            
if
not
self
.
config
.
get
(
'
run_local
'
None
)
or
'
{
}
'
in
self
.
browsertime_chromedriver
:
                
if
self
.
browser_version
:
                    
bvers
=
str
(
self
.
browser_version
)
                    
chromedriver_version
=
bvers
.
split
(
'
.
'
)
[
0
]
                
else
:
                    
chromedriver_version
=
DEFAULT_CHROMEVERSION
                
self
.
browsertime_chromedriver
=
self
.
browsertime_chromedriver
.
format
(
                    
chromedriver_version
                
)
            
self
.
driver_paths
.
extend
(
[
                
'
-
-
chrome
.
chromedriverPath
'
                
self
.
browsertime_chromedriver
            
]
)
        
LOG
.
info
(
'
test
:
{
}
'
.
format
(
test
)
)
    
def
run_test_teardown
(
self
test
)
:
        
super
(
Browsertime
self
)
.
run_test_teardown
(
test
)
        
if
self
.
playback
is
not
None
:
            
self
.
playback
.
stop
(
)
    
def
check_for_crashes
(
self
)
:
        
super
(
Browsertime
self
)
.
check_for_crashes
(
)
    
def
clean_up
(
self
)
:
        
super
(
Browsertime
self
)
.
clean_up
(
)
    
def
run_test
(
self
test
timeout
)
:
        
self
.
run_test_setup
(
test
)
        
browsertime_script
=
[
os
.
path
.
join
(
os
.
path
.
dirname
(
__file__
)
"
.
.
"
                              
"
browsertime
"
"
browsertime_pageload
.
js
"
)
]
        
btime_args
=
self
.
browsertime_args
        
if
self
.
config
[
'
app
'
]
in
(
'
chrome
'
'
chromium
'
)
:
            
btime_args
.
extend
(
self
.
setup_chrome_args
(
test
)
)
        
browsertime_script
.
extend
(
btime_args
)
        
bt_timeout
=
int
(
timeout
/
1000
)
*
int
(
test
.
get
(
"
page_cycles
"
1
)
)
        
bt_timeout
+
=
int
(
self
.
post_startup_delay
/
1000
)
        
bt_timeout
+
=
20
        
bt_timeout
=
bt_timeout
*
int
(
test
.
get
(
'
browser_cycles
'
1
)
)
        
if
self
.
config
[
'
gecko_profile
'
]
is
True
:
            
bt_timeout
+
=
5
*
60
        
browsertime_script
.
extend
(
[
"
-
-
browsertime
.
page_cycles
"
                                  
str
(
test
.
get
(
"
page_cycles
"
1
)
)
]
)
        
browsertime_script
.
extend
(
[
"
-
-
browsertime
.
url
"
test
[
"
test_url
"
]
]
)
        
browsertime_script
.
extend
(
[
"
-
-
browsertime
.
page_cycle_delay
"
"
1000
"
]
)
        
browsertime_script
.
extend
(
[
"
-
-
browsertime
.
foreground_delay
"
"
5000
"
]
)
        
browsertime_script
.
extend
(
[
"
-
-
browsertime
.
post_startup_delay
"
                                  
str
(
self
.
post_startup_delay
)
]
)
        
cmd
=
(
[
self
.
browsertime_node
self
.
browsertime_browsertimejs
]
+
               
self
.
driver_paths
+
               
browsertime_script
+
               
[
'
-
-
firefox
.
profileTemplate
'
str
(
self
.
profile
.
profile
)
                
'
-
-
skipHar
'
                
'
-
-
video
'
self
.
browsertime_video
and
'
true
'
or
'
false
'
                
'
-
-
visualMetrics
'
'
false
'
                
'
-
-
timeouts
.
pageLoad
'
str
(
timeout
)
                
'
-
-
timeouts
.
script
'
str
(
timeout
*
int
(
test
.
get
(
"
page_cycles
"
1
)
)
)
                
'
-
vv
'
                
'
-
-
resultDir
'
self
.
results_handler
.
result_dir_for_test
(
test
)
                
'
-
n
'
str
(
test
.
get
(
'
browser_cycles
'
1
)
)
]
)
        
if
test
.
get
(
'
type
'
)
=
=
"
benchmark
"
:
            
cmd
.
extend
(
[
'
-
-
script
'
                        
os
.
path
.
join
(
os
.
path
.
dirname
(
__file__
)
"
.
.
"
                                     
"
browsertime
"
"
browsertime_benchmark
.
js
"
)
                        
]
)
        
LOG
.
info
(
'
timeout
(
s
)
:
{
}
'
.
format
(
timeout
)
)
        
LOG
.
info
(
'
browsertime
cwd
:
{
}
'
.
format
(
os
.
getcwd
(
)
)
)
        
LOG
.
info
(
'
browsertime
cmd
:
{
}
'
.
format
(
"
"
.
join
(
cmd
)
)
)
        
if
self
.
browsertime_video
:
            
LOG
.
info
(
'
browsertime_ffmpeg
:
{
}
'
.
format
(
self
.
browsertime_ffmpeg
)
)
        
env
=
dict
(
os
.
environ
)
        
if
self
.
browsertime_video
and
self
.
browsertime_ffmpeg
:
            
ffmpeg_dir
=
os
.
path
.
dirname
(
os
.
path
.
abspath
(
self
.
browsertime_ffmpeg
)
)
            
old_path
=
env
.
setdefault
(
'
PATH
'
'
'
)
            
new_path
=
os
.
pathsep
.
join
(
[
ffmpeg_dir
old_path
]
)
            
if
isinstance
(
new_path
six
.
text_type
)
:
                
new_path
=
new_path
.
encode
(
'
utf
-
8
'
'
strict
'
)
            
env
[
'
PATH
'
]
=
new_path
        
LOG
.
info
(
'
PATH
:
{
}
'
.
format
(
env
[
'
PATH
'
]
)
)
        
try
:
            
proc
=
self
.
process_handler
(
cmd
env
=
env
)
            
proc
.
run
(
timeout
=
bt_timeout
                     
outputTimeout
=
2
*
60
)
            
proc
.
wait
(
)
        
except
Exception
as
e
:
            
LOG
.
critical
(
"
Error
while
attempting
to
run
browsertime
:
%
s
"
%
str
(
e
)
)
            
raise
class
BrowsertimeDesktop
(
PerftestDesktop
Browsertime
)
:
    
def
__init__
(
self
*
args
*
*
kwargs
)
:
        
super
(
BrowsertimeDesktop
self
)
.
__init__
(
*
args
*
*
kwargs
)
    
property
    
def
browsertime_args
(
self
)
:
        
binary_path
=
self
.
config
[
'
binary
'
]
        
LOG
.
info
(
'
binary_path
:
{
}
'
.
format
(
binary_path
)
)
        
if
self
.
config
[
'
app
'
]
=
=
'
chrome
'
:
            
return
[
'
-
-
browser
'
self
.
config
[
'
app
'
]
'
-
-
chrome
.
binaryPath
'
binary_path
]
        
return
[
'
-
-
browser
'
self
.
config
[
'
app
'
]
'
-
-
firefox
.
binaryPath
'
binary_path
]
    
def
setup_chrome_args
(
self
test
)
:
        
chrome_args
=
self
.
desktop_chrome_args
(
test
)
        
chrome_args
.
append
(
'
-
-
no
-
first
-
run
'
)
        
btime_chrome_args
=
[
]
        
for
arg
in
chrome_args
:
            
btime_chrome_args
.
extend
(
[
                
'
-
-
chrome
.
args
=
'
+
str
(
arg
.
replace
(
"
'
"
'
"
'
)
)
            
]
)
        
return
btime_chrome_args
class
BrowsertimeAndroid
(
PerftestAndroid
Browsertime
)
:
    
def
__init__
(
self
app
binary
activity
=
None
intent
=
None
*
*
kwargs
)
:
        
super
(
BrowsertimeAndroid
self
)
.
__init__
(
app
binary
profile_class
=
"
firefox
"
*
*
kwargs
)
        
self
.
config
.
update
(
{
            
'
activity
'
:
activity
            
'
intent
'
:
intent
        
}
)
    
property
    
def
browsertime_args
(
self
)
:
        
return
[
'
-
-
browser
'
'
firefox
'
'
-
-
android
'
                
'
-
-
firefox
.
binaryPath
'
self
.
browsertime_node
                
'
-
-
firefox
.
android
.
package
'
self
.
config
[
'
binary
'
]
                
'
-
-
firefox
.
android
.
activity
'
self
.
config
[
'
activity
'
]
]
    
def
build_browser_profile
(
self
)
:
        
super
(
BrowsertimeAndroid
self
)
.
build_browser_profile
(
)
        
path
=
os
.
path
.
join
(
self
.
profile_data_dir
'
raptor
-
android
'
)
        
LOG
.
info
(
"
Merging
profile
:
{
}
"
.
format
(
path
)
)
        
self
.
profile
.
merge
(
path
)
        
self
.
profile
.
set_preferences
(
{
'
browser
.
tabs
.
remote
.
autostart
'
:
self
.
config
[
'
e10s
'
]
}
)
        
self
.
remove_mozprofile_delimiters_from_profile
(
)
class
Raptor
(
Perftest
)
:
    
"
"
"
Container
class
for
Raptor
"
"
"
    
def
__init__
(
self
*
args
*
*
kwargs
)
:
        
self
.
raptor_webext
=
None
        
self
.
control_server
=
None
        
self
.
cpu_profiler
=
None
        
super
(
Raptor
self
)
.
__init__
(
*
args
*
*
kwargs
)
        
self
.
results_handler
=
RaptorResultsHandler
(
            
gecko_profile
=
self
.
config
.
get
(
'
gecko_profile
'
)
            
power_test
=
self
.
config
.
get
(
'
power_test
'
)
            
cpu_test
=
self
.
config
.
get
(
'
cpu_test
'
)
            
memory_test
=
self
.
config
.
get
(
'
memory_test
'
)
        
)
        
browser_name
browser_version
=
self
.
get_browser_meta
(
)
        
self
.
results_handler
.
add_browser_meta
(
self
.
config
[
'
app
'
]
browser_version
)
        
self
.
start_control_server
(
)
    
def
run_test_setup
(
self
test
)
:
        
super
(
Raptor
self
)
.
run_test_setup
(
test
)
        
LOG
.
info
(
"
starting
raptor
test
:
%
s
"
%
test
[
'
name
'
]
)
        
LOG
.
info
(
"
test
settings
:
%
s
"
%
str
(
test
)
)
        
LOG
.
info
(
"
raptor
config
:
%
s
"
%
str
(
self
.
config
)
)
        
if
test
.
get
(
'
type
'
)
=
=
"
benchmark
"
:
            
self
.
serve_benchmark_source
(
test
)
        
gen_test_config
(
            
self
.
config
[
'
app
'
]
            
test
[
'
name
'
]
            
self
.
control_server
.
port
            
self
.
post_startup_delay
            
host
=
self
.
config
[
'
host
'
]
            
b_port
=
self
.
benchmark_port
            
debug_mode
=
1
if
self
.
debug_mode
else
0
            
browser_cycle
=
test
.
get
(
'
browser_cycle
'
1
)
        
)
        
self
.
install_raptor_webext
(
)
    
def
wait_for_test_finish
(
self
test
timeout
)
:
        
timeout
=
int
(
timeout
/
1000
)
*
int
(
test
.
get
(
'
page_cycles
'
1
)
)
        
timeout
+
=
(
int
(
self
.
post_startup_delay
/
1000
)
+
10
)
        
if
test
.
get
(
'
type
'
)
=
=
"
pageload
"
:
            
timeout
+
=
(
10
*
int
(
test
.
get
(
'
page_cycles
'
1
)
)
)
        
if
self
.
config
[
'
gecko_profile
'
]
is
True
:
            
timeout
+
=
5
*
60
        
timeout
+
=
60
        
elapsed_time
=
0
        
while
not
self
.
control_server
.
_finished
:
            
if
self
.
config
[
'
enable_control_server_wait
'
]
:
                
response
=
self
.
control_server_wait_get
(
)
                
if
response
=
=
'
webext_shutdownBrowser
'
:
                    
if
self
.
config
[
'
memory_test
'
]
:
                        
generate_android_memory_profile
(
self
test
[
'
name
'
]
)
                    
if
self
.
cpu_profiler
:
                        
self
.
cpu_profiler
.
generate_android_cpu_profile
(
test
[
'
name
'
]
)
                    
self
.
control_server_wait_continue
(
)
            
time
.
sleep
(
1
)
            
if
not
self
.
debug_mode
:
                
elapsed_time
+
=
1
                
if
elapsed_time
>
(
timeout
)
-
5
:
                    
self
.
control_server
.
wait_for_quit
(
)
                    
raise
RuntimeError
(
"
Test
failed
to
finish
.
"
                                       
"
Application
timed
out
after
{
}
seconds
"
.
format
(
timeout
)
)
    
def
run_test_teardown
(
self
test
)
:
        
super
(
Raptor
self
)
.
run_test_teardown
(
test
)
        
if
self
.
playback
is
not
None
:
            
self
.
playback
.
stop
(
)
        
self
.
remove_raptor_webext
(
)
    
def
set_browser_test_prefs
(
self
raw_prefs
)
:
        
LOG
.
info
(
"
setting
test
-
specific
Firefox
preferences
"
)
        
self
.
profile
.
set_preferences
(
json
.
loads
(
raw_prefs
)
)
    
def
build_browser_profile
(
self
)
:
        
super
(
Raptor
self
)
.
build_browser_profile
(
)
        
if
self
.
control_server
:
            
self
.
control_server
.
user_profile
=
self
.
profile
    
def
start_control_server
(
self
)
:
        
self
.
control_server
=
RaptorControlServer
(
self
.
results_handler
self
.
debug_mode
)
        
self
.
control_server
.
user_profile
=
self
.
profile
        
self
.
control_server
.
start
(
)
        
if
self
.
config
[
'
enable_control_server_wait
'
]
:
            
self
.
control_server_wait_set
(
'
webext_shutdownBrowser
'
)
    
def
serve_benchmark_source
(
self
test
)
:
        
self
.
benchmark
=
Benchmark
(
self
.
config
test
)
        
self
.
benchmark_port
=
int
(
self
.
benchmark
.
port
)
    
def
install_raptor_webext
(
self
)
:
        
self
.
raptor_webext
=
os
.
path
.
join
(
webext_dir
'
raptor
'
)
        
LOG
.
info
(
"
installing
webext
%
s
"
%
self
.
raptor_webext
)
        
self
.
profile
.
addons
.
install
(
self
.
raptor_webext
)
        
try
:
            
self
.
webext_id
=
self
.
profile
.
addons
.
addon_details
(
self
.
raptor_webext
)
[
'
id
'
]
        
except
AttributeError
:
            
self
.
webext_id
=
None
    
def
remove_raptor_webext
(
self
)
:
        
if
not
self
.
raptor_webext
:
            
LOG
.
info
(
"
raptor
webext
not
installed
-
not
attempting
removal
"
)
            
return
        
LOG
.
info
(
"
removing
webext
%
s
"
%
self
.
raptor_webext
)
        
if
self
.
config
[
'
app
'
]
in
[
'
firefox
'
'
geckoview
'
'
fennec
'
'
refbrow
'
'
fenix
'
]
:
            
self
.
profile
.
addons
.
remove_addon
(
self
.
webext_id
)
        
chrome_apps
=
CHROMIUM_DISTROS
+
[
"
chrome
-
android
"
"
chromium
-
android
"
]
        
if
self
.
config
[
'
app
'
]
in
chrome_apps
:
            
self
.
profile
.
addons
.
remove
(
self
.
raptor_webext
)
    
def
_init_gecko_profiling
(
self
test
)
:
        
LOG
.
info
(
"
initializing
gecko
profiler
"
)
        
upload_dir
=
os
.
getenv
(
'
MOZ_UPLOAD_DIR
'
)
        
if
not
upload_dir
:
            
LOG
.
critical
(
"
Profiling
ignored
because
MOZ_UPLOAD_DIR
was
not
set
"
)
        
else
:
            
self
.
gecko_profiler
=
GeckoProfile
(
upload_dir
                                               
self
.
config
                                               
test
)
    
def
clean_up
(
self
)
:
        
super
(
Raptor
self
)
.
clean_up
(
)
        
if
self
.
config
[
'
enable_control_server_wait
'
]
:
            
self
.
control_server_wait_clear
(
'
all
'
)
        
self
.
control_server
.
stop
(
)
        
LOG
.
info
(
"
finished
"
)
    
def
control_server_wait_set
(
self
state
)
:
        
response
=
requests
.
post
(
"
http
:
/
/
127
.
0
.
0
.
1
:
%
s
/
"
%
self
.
control_server
.
port
                                 
json
=
{
"
type
"
:
"
wait
-
set
"
"
data
"
:
state
}
)
        
return
response
.
text
    
def
control_server_wait_timeout
(
self
timeout
)
:
        
response
=
requests
.
post
(
"
http
:
/
/
127
.
0
.
0
.
1
:
%
s
/
"
%
self
.
control_server
.
port
                                 
json
=
{
"
type
"
:
"
wait
-
timeout
"
"
data
"
:
timeout
}
)
        
return
response
.
text
    
def
control_server_wait_get
(
self
)
:
        
response
=
requests
.
post
(
"
http
:
/
/
127
.
0
.
0
.
1
:
%
s
/
"
%
self
.
control_server
.
port
                                 
json
=
{
"
type
"
:
"
wait
-
get
"
"
data
"
:
"
"
}
)
        
return
response
.
text
    
def
control_server_wait_continue
(
self
)
:
        
response
=
requests
.
post
(
"
http
:
/
/
127
.
0
.
0
.
1
:
%
s
/
"
%
self
.
control_server
.
port
                                 
json
=
{
"
type
"
:
"
wait
-
continue
"
"
data
"
:
"
"
}
)
        
return
response
.
text
    
def
control_server_wait_clear
(
self
state
)
:
        
response
=
requests
.
post
(
"
http
:
/
/
127
.
0
.
0
.
1
:
%
s
/
"
%
self
.
control_server
.
port
                                 
json
=
{
"
type
"
:
"
wait
-
clear
"
"
data
"
:
state
}
)
        
return
response
.
text
class
RaptorDesktop
(
PerftestDesktop
Raptor
)
:
    
def
__init__
(
self
*
args
*
*
kwargs
)
:
        
super
(
RaptorDesktop
self
)
.
__init__
(
*
args
*
*
kwargs
)
        
LOG
.
info
(
"
creating
browser
runner
using
mozrunner
"
)
        
self
.
output_handler
=
OutputHandler
(
)
        
process_args
=
{
            
'
processOutputLine
'
:
[
self
.
output_handler
]
        
}
        
runner_cls
=
runners
[
self
.
config
[
'
app
'
]
]
        
self
.
runner
=
runner_cls
(
            
self
.
config
[
'
binary
'
]
profile
=
self
.
profile
process_args
=
process_args
            
symbols_path
=
self
.
config
[
'
symbols_path
'
]
)
        
if
self
.
config
[
'
enable_webrender
'
]
:
            
self
.
runner
.
env
[
'
MOZ_WEBRENDER
'
]
=
'
1
'
            
self
.
runner
.
env
[
'
MOZ_ACCELERATED
'
]
=
'
1
'
        
else
:
            
self
.
runner
.
env
[
'
MOZ_WEBRENDER
'
]
=
'
0
'
    
def
launch_desktop_browser
(
self
test
)
:
        
raise
NotImplementedError
    
def
start_runner_proc
(
self
)
:
        
self
.
runner
.
start
(
)
        
proc
=
self
.
runner
.
process_handler
        
self
.
output_handler
.
proc
=
proc
        
self
.
control_server
.
browser_proc
=
proc
    
def
run_test
(
self
test
timeout
)
:
        
mozpower_measurer
=
None
        
if
self
.
config
.
get
(
'
power_test
'
False
)
:
            
powertest_name
=
test
[
'
name
'
]
.
replace
(
'
/
'
'
-
'
)
.
replace
(
'
\
\
'
'
-
'
)
            
output_dir
=
os
.
path
.
join
(
self
.
artifact_dir
'
power
-
measurements
-
%
s
'
%
powertest_name
)
            
test_dir
=
os
.
path
.
join
(
output_dir
powertest_name
)
            
try
:
                
if
not
os
.
path
.
exists
(
output_dir
)
:
                    
os
.
mkdir
(
output_dir
)
                
if
not
os
.
path
.
exists
(
test_dir
)
:
                    
os
.
mkdir
(
test_dir
)
            
except
Exception
:
                
LOG
.
critical
(
"
Could
not
create
directories
to
store
power
testing
data
.
"
)
                
raise
            
mozpower_measurer
=
MozPower
(
                
ipg_measure_duration
=
30
                
sampling_rate
=
1000
                
output_file_path
=
os
.
path
.
join
(
test_dir
'
power
-
usage
'
)
            
)
            
mozpower_measurer
.
initialize_power_measurements
(
)
        
if
test
.
get
(
'
cold
'
False
)
is
True
:
            
self
.
__run_test_cold
(
test
timeout
)
        
else
:
            
self
.
__run_test_warm
(
test
timeout
)
        
if
mozpower_measurer
:
            
mozpower_measurer
.
finalize_power_measurements
(
test_name
=
test
[
'
name
'
]
)
            
perfherder_data
=
mozpower_measurer
.
get_perfherder_data
(
)
            
if
not
self
.
config
.
get
(
'
run_local
'
False
)
:
                
powertest_name
=
test
[
'
name
'
]
.
replace
(
'
/
'
'
-
'
)
.
replace
(
'
\
\
'
'
-
'
)
                
power_data_path
=
os
.
path
.
join
(
                    
self
.
artifact_dir
                    
'
power
-
measurements
-
%
s
'
%
powertest_name
                
)
                
shutil
.
make_archive
(
power_data_path
'
zip
'
power_data_path
)
                
shutil
.
rmtree
(
power_data_path
)
            
for
data_type
in
perfherder_data
:
                
self
.
control_server
.
submit_supporting_data
(
                    
perfherder_data
[
data_type
]
                
)
    
def
__run_test_cold
(
self
test
timeout
)
:
        
'
'
'
        
Run
the
Raptor
test
but
restart
the
entire
browser
app
between
page
-
cycles
.
        
Note
:
For
page
-
load
tests
playback
will
only
be
started
once
-
at
the
beginning
of
all
        
browser
cycles
and
then
stopped
after
all
cycles
are
finished
.
That
includes
the
import
        
of
the
mozproxy
ssl
cert
and
turning
on
the
browser
proxy
.
        
Since
we
'
re
running
in
cold
-
mode
before
this
point
(
in
manifest
.
py
)
the
        
'
expected
-
browser
-
cycles
'
value
was
already
set
to
the
initial
'
page
-
cycles
'
value
;
        
and
the
'
page
-
cycles
'
value
was
set
to
1
as
we
want
to
perform
one
page
-
cycle
per
        
browser
restart
.
        
The
'
browser
-
cycle
'
value
is
the
current
overall
browser
start
iteration
.
The
control
        
server
will
receive
the
current
'
browser
-
cycle
'
and
the
'
expected
-
browser
-
cycles
'
in
        
each
results
set
received
;
and
will
pass
that
on
as
part
of
the
results
so
that
the
        
results
processing
will
know
results
for
multiple
browser
cycles
are
being
received
.
        
The
default
will
be
to
run
in
warm
mode
;
unless
'
cold
=
true
'
is
set
in
the
test
INI
.
        
'
'
'
        
LOG
.
info
(
"
test
%
s
is
running
in
cold
mode
;
browser
WILL
be
restarted
between
"
                 
"
page
cycles
"
%
test
[
'
name
'
]
)
        
for
test
[
'
browser_cycle
'
]
in
range
(
1
test
[
'
expected_browser_cycles
'
]
+
1
)
:
            
LOG
.
info
(
"
begin
browser
cycle
%
d
of
%
d
for
test
%
s
"
                     
%
(
test
[
'
browser_cycle
'
]
test
[
'
expected_browser_cycles
'
]
test
[
'
name
'
]
)
)
            
self
.
run_test_setup
(
test
)
            
if
test
[
'
browser_cycle
'
]
=
=
1
:
                
if
test
.
get
(
'
playback
'
)
is
not
None
:
                    
self
.
start_playback
(
test
)
                
if
self
.
config
[
'
host
'
]
not
in
(
'
localhost
'
'
127
.
0
.
0
.
1
'
)
:
                    
self
.
delete_proxy_settings_from_profile
(
)
            
else
:
                
self
.
build_browser_profile
(
)
                
self
.
runner
.
profile
=
self
.
profile
                
self
.
run_test_setup
(
test
)
            
self
.
launch_desktop_browser
(
test
)
            
self
.
control_server
.
_finished
=
False
            
self
.
wait_for_test_finish
(
test
timeout
)
    
def
__run_test_warm
(
self
test
timeout
)
:
        
self
.
run_test_setup
(
test
)
        
if
test
.
get
(
'
playback
'
)
is
not
None
:
            
self
.
start_playback
(
test
)
        
if
self
.
config
[
'
host
'
]
not
in
(
'
localhost
'
'
127
.
0
.
0
.
1
'
)
:
            
self
.
delete_proxy_settings_from_profile
(
)
        
self
.
launch_desktop_browser
(
test
)
        
self
.
control_server
.
_finished
=
False
        
self
.
wait_for_test_finish
(
test
timeout
)
    
def
run_test_teardown
(
self
test
)
:
        
if
not
self
.
debug_mode
:
            
if
self
.
runner
.
is_running
(
)
:
                
self
.
runner
.
stop
(
)
        
else
:
            
if
self
.
config
[
'
run_local
'
]
:
                
LOG
.
info
(
"
*
debug
-
mode
enabled
-
please
shutdown
the
browser
manually
.
.
.
"
)
                
self
.
runner
.
wait
(
timeout
=
None
)
        
super
(
RaptorDesktop
self
)
.
run_test_teardown
(
test
)
    
def
check_for_crashes
(
self
)
:
        
super
(
RaptorDesktop
self
)
.
check_for_crashes
(
)
        
try
:
            
self
.
runner
.
check_for_crashes
(
)
        
except
NotImplementedError
:
            
pass
    
def
clean_up
(
self
)
:
        
self
.
runner
.
stop
(
)
        
super
(
RaptorDesktop
self
)
.
clean_up
(
)
class
RaptorDesktopFirefox
(
RaptorDesktop
)
:
    
def
disable_non_local_connections
(
self
)
:
        
LOG
.
info
(
"
setting
MOZ_DISABLE_NONLOCAL_CONNECTIONS
=
1
"
)
        
os
.
environ
[
'
MOZ_DISABLE_NONLOCAL_CONNECTIONS
'
]
=
"
1
"
    
def
enable_non_local_connections
(
self
)
:
        
LOG
.
info
(
"
setting
MOZ_DISABLE_NONLOCAL_CONNECTIONS
=
0
"
)
        
os
.
environ
[
'
MOZ_DISABLE_NONLOCAL_CONNECTIONS
'
]
=
"
0
"
    
def
launch_desktop_browser
(
self
test
)
:
        
LOG
.
info
(
"
starting
%
s
"
%
self
.
config
[
'
app
'
]
)
        
if
self
.
config
[
'
is_release_build
'
]
:
            
self
.
disable_non_local_connections
(
)
        
if
self
.
debug_mode
:
            
self
.
runner
.
cmdargs
.
extend
(
[
'
-
jsconsole
'
]
)
        
self
.
start_runner_proc
(
)
        
if
self
.
config
[
'
is_release_build
'
]
and
test
.
get
(
'
playback
'
)
is
not
None
:
            
self
.
enable_non_local_connections
(
)
        
if
self
.
config
[
'
gecko_profile
'
]
is
True
:
            
self
.
_init_gecko_profiling
(
test
)
            
self
.
control_server
.
gecko_profile_dir
=
self
.
gecko_profiler
.
gecko_profile_dir
class
RaptorDesktopChrome
(
RaptorDesktop
)
:
    
def
setup_chrome_args
(
self
test
)
:
        
chrome_args
=
self
.
desktop_chrome_args
(
test
)
        
if
'
'
.
join
(
chrome_args
)
not
in
'
'
.
join
(
self
.
runner
.
cmdargs
)
:
            
self
.
runner
.
cmdargs
.
extend
(
chrome_args
)
    
def
launch_desktop_browser
(
self
test
)
:
        
LOG
.
info
(
"
starting
%
s
"
%
self
.
config
[
'
app
'
]
)
        
self
.
setup_chrome_args
(
test
)
        
self
.
start_runner_proc
(
)
    
def
set_browser_test_prefs
(
self
raw_prefs
)
:
        
LOG
.
info
(
"
preferences
were
configured
for
the
test
however
\
                        
we
currently
do
not
install
them
on
non
-
Firefox
browsers
.
"
)
class
RaptorAndroid
(
PerftestAndroid
Raptor
)
:
    
def
__init__
(
self
app
binary
activity
=
None
intent
=
None
*
*
kwargs
)
:
        
super
(
RaptorAndroid
self
)
.
__init__
(
app
binary
profile_class
=
"
firefox
"
*
*
kwargs
)
        
self
.
config
.
update
(
{
            
'
activity
'
:
activity
            
'
intent
'
:
intent
        
}
)
        
self
.
remote_test_root
=
os
.
path
.
abspath
(
os
.
path
.
join
(
os
.
sep
'
sdcard
'
'
raptor
'
)
)
        
self
.
remote_profile
=
os
.
path
.
join
(
self
.
remote_test_root
"
profile
"
)
        
self
.
os_baseline_data
=
None
        
self
.
power_test_time
=
None
        
self
.
screen_off_timeout
=
0
        
self
.
screen_brightness
=
127
        
self
.
app_launched
=
False
    
def
set_reverse_port
(
self
port
)
:
        
tcp_port
=
"
tcp
:
{
}
"
.
format
(
port
)
        
self
.
device
.
create_socket_connection
(
'
reverse
'
tcp_port
tcp_port
)
    
def
set_reverse_ports
(
self
is_benchmark
=
False
)
:
        
if
self
.
config
[
'
host
'
]
in
(
'
localhost
'
'
127
.
0
.
0
.
1
'
)
:
            
LOG
.
info
(
"
making
the
raptor
control
server
port
available
to
device
"
)
            
self
.
set_reverse_port
(
self
.
control_server
.
port
)
        
if
self
.
config
[
'
host
'
]
in
(
'
localhost
'
'
127
.
0
.
0
.
1
'
)
:
            
LOG
.
info
(
"
making
the
raptor
playback
server
port
available
to
device
"
)
            
self
.
set_reverse_port
(
8080
)
        
if
is_benchmark
and
self
.
config
[
'
host
'
]
in
(
'
localhost
'
'
127
.
0
.
0
.
1
'
)
:
            
LOG
.
info
(
"
making
the
raptor
benchmarks
server
port
available
to
device
"
)
            
self
.
set_reverse_port
(
self
.
benchmark_port
)
    
def
setup_adb_device
(
self
)
:
        
if
self
.
device
is
None
:
            
self
.
device
=
ADBDevice
(
verbose
=
True
)
            
tune_performance
(
self
.
device
log
=
LOG
)
        
LOG
.
info
(
"
creating
remote
root
folder
for
raptor
:
%
s
"
%
self
.
remote_test_root
)
        
self
.
device
.
rm
(
self
.
remote_test_root
force
=
True
recursive
=
True
)
        
self
.
device
.
mkdir
(
self
.
remote_test_root
)
        
self
.
device
.
chmod
(
self
.
remote_test_root
recursive
=
True
root
=
True
)
        
self
.
clear_app_data
(
)
        
self
.
set_debug_app_flag
(
)
    
def
build_browser_profile
(
self
)
:
        
super
(
RaptorAndroid
self
)
.
build_browser_profile
(
)
        
path
=
os
.
path
.
join
(
self
.
profile_data_dir
'
raptor
-
android
'
)
        
LOG
.
info
(
"
Merging
profile
:
{
}
"
.
format
(
path
)
)
        
self
.
profile
.
merge
(
path
)
        
self
.
profile
.
set_preferences
(
{
'
browser
.
tabs
.
remote
.
autostart
'
:
self
.
config
[
'
e10s
'
]
}
)
    
def
clear_app_data
(
self
)
:
        
LOG
.
info
(
"
clearing
%
s
app
data
"
%
self
.
config
[
'
binary
'
]
)
        
self
.
device
.
shell
(
"
pm
clear
%
s
"
%
self
.
config
[
'
binary
'
]
)
    
def
set_debug_app_flag
(
self
)
:
        
LOG
.
info
(
"
setting
debug
-
app
flag
for
%
s
"
%
self
.
config
[
'
binary
'
]
)
        
self
.
device
.
shell
(
"
am
set
-
debug
-
app
-
-
persistent
%
s
"
%
self
.
config
[
'
binary
'
]
)
    
def
copy_profile_to_device
(
self
)
:
        
"
"
"
Copy
the
profile
to
the
device
and
update
permissions
of
all
files
.
"
"
"
        
if
not
self
.
device
.
is_app_installed
(
self
.
config
[
'
binary
'
]
)
:
            
raise
Exception
(
'
%
s
is
not
installed
'
%
self
.
config
[
'
binary
'
]
)
        
try
:
            
LOG
.
info
(
"
copying
profile
to
device
:
%
s
"
%
self
.
remote_profile
)
            
self
.
device
.
rm
(
self
.
remote_profile
force
=
True
recursive
=
True
)
            
self
.
device
.
push
(
self
.
profile
.
profile
self
.
remote_profile
)
            
self
.
device
.
chmod
(
self
.
remote_profile
recursive
=
True
root
=
True
)
        
except
Exception
:
            
LOG
.
error
(
"
Unable
to
copy
profile
to
device
.
"
)
            
raise
    
def
turn_on_android_app_proxy
(
self
)
:
        
LOG
.
info
(
"
setting
profile
prefs
to
turn
on
the
android
app
proxy
"
)
        
proxy_prefs
=
{
}
        
proxy_prefs
[
"
network
.
proxy
.
type
"
]
=
1
        
proxy_prefs
[
"
network
.
proxy
.
http
"
]
=
self
.
config
[
'
host
'
]
        
proxy_prefs
[
"
network
.
proxy
.
http_port
"
]
=
8080
        
proxy_prefs
[
"
network
.
proxy
.
ssl
"
]
=
self
.
config
[
'
host
'
]
        
proxy_prefs
[
"
network
.
proxy
.
ssl_port
"
]
=
8080
        
proxy_prefs
[
"
network
.
proxy
.
no_proxies_on
"
]
=
self
.
config
[
'
host
'
]
        
self
.
profile
.
set_preferences
(
proxy_prefs
)
    
def
log_android_device_temperature
(
self
)
:
        
try
:
            
thermal_zone0
=
self
.
device
.
shell_output
(
'
cat
sys
/
class
/
thermal
/
thermal_zone0
/
temp
'
)
            
thermal_zone0
=
float
(
thermal_zone0
)
            
zone_type
=
self
.
device
.
shell_output
(
'
cat
sys
/
class
/
thermal
/
thermal_zone0
/
type
'
)
            
LOG
.
info
(
"
(
thermal_zone0
)
device
temperature
:
%
.
3f
zone
type
:
%
s
"
                     
%
(
thermal_zone0
/
1000
zone_type
)
)
        
except
Exception
as
exc
:
            
LOG
.
warning
(
"
Unexpected
error
:
{
}
-
{
}
"
                        
.
format
(
exc
.
__class__
.
__name__
exc
)
)
    
def
write_android_app_config
(
self
)
:
        
if
self
.
config
[
'
app
'
]
=
=
"
fennec
"
:
            
return
        
LOG
.
info
(
"
creating
android
app
config
.
yml
"
)
        
yml_config_data
=
dict
(
            
args
=
[
'
-
-
profile
'
self
.
remote_profile
'
use_multiprocess
'
self
.
config
[
'
e10s
'
]
]
            
env
=
dict
(
                
LOG_VERBOSE
=
1
                
R_LOG_LEVEL
=
6
                
MOZ_WEBRENDER
=
int
(
self
.
config
[
'
enable_webrender
'
]
)
            
)
        
)
        
yml_name
=
'
%
s
-
geckoview
-
config
.
yaml
'
%
self
.
config
[
'
binary
'
]
        
yml_on_host
=
os
.
path
.
join
(
tempfile
.
mkdtemp
(
)
yml_name
)
        
write_yml_file
(
yml_on_host
yml_config_data
)
        
yml_on_device
=
os
.
path
.
join
(
'
/
data
'
'
local
'
'
tmp
'
yml_name
)
        
try
:
            
LOG
.
info
(
"
copying
%
s
to
device
:
%
s
"
%
(
yml_on_host
yml_on_device
)
)
            
self
.
device
.
rm
(
yml_on_device
force
=
True
recursive
=
True
)
            
self
.
device
.
push
(
yml_on_host
yml_on_device
)
        
except
Exception
:
            
LOG
.
critical
(
"
failed
to
push
%
s
to
device
!
"
%
yml_on_device
)
            
raise
    
def
launch_firefox_android_app
(
self
test_name
)
:
        
LOG
.
info
(
"
starting
%
s
"
%
self
.
config
[
'
app
'
]
)
        
extra_args
=
[
"
-
profile
"
self
.
remote_profile
                      
"
-
-
es
"
"
env0
"
"
LOG_VERBOSE
=
1
"
                      
"
-
-
es
"
"
env1
"
"
R_LOG_LEVEL
=
6
"
                      
"
-
-
es
"
"
env2
"
"
MOZ_WEBRENDER
=
%
d
"
%
self
.
config
[
'
enable_webrender
'
]
]
        
try
:
            
self
.
device
.
stop_application
(
self
.
config
[
'
binary
'
]
)
            
if
self
.
config
[
'
app
'
]
=
=
"
fennec
"
:
                
self
.
device
.
launch_fennec
(
self
.
config
[
'
binary
'
]
                                          
extra_args
=
extra_args
                                          
url
=
'
about
:
blank
'
                                          
fail_if_running
=
False
)
            
else
:
                
self
.
device
.
launch_application
(
self
.
config
[
'
binary
'
]
                                               
self
.
config
[
'
activity
'
]
                                               
self
.
config
[
'
intent
'
]
                                               
extras
=
None
                                               
url
=
'
about
:
blank
'
                                               
fail_if_running
=
False
)
            
if
not
self
.
device
.
process_exist
(
self
.
config
[
'
binary
'
]
)
:
                
raise
Exception
(
"
Error
launching
%
s
.
App
did
not
start
properly
!
"
%
                                
self
.
config
[
'
binary
'
]
)
            
self
.
app_launched
=
True
        
except
Exception
as
e
:
            
LOG
.
error
(
"
Exception
launching
%
s
"
%
self
.
config
[
'
binary
'
]
)
            
LOG
.
error
(
"
Exception
:
%
s
%
s
"
%
(
type
(
e
)
.
__name__
str
(
e
)
)
)
            
if
self
.
config
[
'
power_test
'
]
:
                
finish_android_power_test
(
self
test_name
)
            
raise
        
self
.
control_server
.
device
=
self
.
device
        
self
.
control_server
.
app_name
=
self
.
config
[
'
binary
'
]
    
def
copy_cert_db
(
self
source_dir
target_dir
)
:
        
cert_db_files
=
[
'
pkcs11
.
txt
'
'
key4
.
db
'
'
cert9
.
db
'
]
        
for
next_file
in
cert_db_files
:
            
_source
=
os
.
path
.
join
(
source_dir
next_file
)
            
_dest
=
os
.
path
.
join
(
target_dir
next_file
)
            
if
os
.
path
.
exists
(
_source
)
:
                
LOG
.
info
(
"
copying
%
s
to
%
s
"
%
(
_source
_dest
)
)
                
shutil
.
copyfile
(
_source
_dest
)
            
else
:
                
LOG
.
critical
(
"
unable
to
find
ssl
cert
db
file
:
%
s
"
%
_source
)
    
def
run_tests
(
self
tests
test_names
)
:
        
self
.
setup_adb_device
(
)
        
return
super
(
RaptorAndroid
self
)
.
run_tests
(
tests
test_names
)
    
def
run_test_setup
(
self
test
)
:
        
super
(
RaptorAndroid
self
)
.
run_test_setup
(
test
)
        
is_benchmark
=
test
.
get
(
'
type
'
)
=
=
"
benchmark
"
        
self
.
set_reverse_ports
(
is_benchmark
=
is_benchmark
)
    
def
run_test_teardown
(
self
test
)
:
        
LOG
.
info
(
'
removing
reverse
socket
connections
'
)
        
self
.
device
.
remove_socket_connections
(
'
reverse
'
)
        
super
(
RaptorAndroid
self
)
.
run_test_teardown
(
test
)
    
def
run_test
(
self
test
timeout
)
:
        
try
:
            
if
self
.
config
[
'
power_test
'
]
:
                
init_android_power_test
(
self
)
                
LOG
.
info
(
"
Running
OS
baseline
pausing
for
1
minute
.
.
.
"
)
                
time
.
sleep
(
60
)
                
finish_android_power_test
(
self
'
os
-
baseline
'
os_baseline
=
True
)
                
init_android_power_test
(
self
)
            
if
test
.
get
(
'
cold
'
False
)
is
True
:
                
self
.
__run_test_cold
(
test
timeout
)
            
else
:
                
self
.
__run_test_warm
(
test
timeout
)
        
except
SignalHandlerException
:
            
self
.
device
.
stop_application
(
self
.
config
[
'
binary
'
]
)
        
finally
:
            
if
self
.
config
[
'
power_test
'
]
:
                
finish_android_power_test
(
self
test
[
'
name
'
]
)
    
def
__run_test_cold
(
self
test
timeout
)
:
        
'
'
'
        
Run
the
Raptor
test
but
restart
the
entire
browser
app
between
page
-
cycles
.
        
Note
:
For
page
-
load
tests
playback
will
only
be
started
once
-
at
the
beginning
of
all
        
browser
cycles
and
then
stopped
after
all
cycles
are
finished
.
The
proxy
is
set
via
prefs
        
in
the
browser
profile
so
those
will
need
to
be
set
again
in
each
new
profile
/
cycle
.
        
Note
that
instead
of
using
the
certutil
tool
each
time
to
create
a
db
and
import
the
        
mitmproxy
SSL
cert
(
it
'
s
done
in
mozbase
/
mozproxy
)
we
will
simply
copy
the
existing
        
cert
db
from
the
first
cycle
'
s
browser
profile
into
the
new
clean
profile
;
this
way
        
we
don
'
t
have
to
re
-
create
the
cert
db
on
each
browser
cycle
.
        
Since
we
'
re
running
in
cold
-
mode
before
this
point
(
in
manifest
.
py
)
the
        
'
expected
-
browser
-
cycles
'
value
was
already
set
to
the
initial
'
page
-
cycles
'
value
;
        
and
the
'
page
-
cycles
'
value
was
set
to
1
as
we
want
to
perform
one
page
-
cycle
per
        
browser
restart
.
        
The
'
browser
-
cycle
'
value
is
the
current
overall
browser
start
iteration
.
The
control
        
server
will
receive
the
current
'
browser
-
cycle
'
and
the
'
expected
-
browser
-
cycles
'
in
        
each
results
set
received
;
and
will
pass
that
on
as
part
of
the
results
so
that
the
        
results
processing
will
know
results
for
multiple
browser
cycles
are
being
received
.
        
The
default
will
be
to
run
in
warm
mode
;
unless
'
cold
=
true
'
is
set
in
the
test
INI
.
        
'
'
'
        
LOG
.
info
(
"
test
%
s
is
running
in
cold
mode
;
browser
WILL
be
restarted
between
"
                 
"
page
cycles
"
%
test
[
'
name
'
]
)
        
for
test
[
'
browser_cycle
'
]
in
range
(
1
test
[
'
expected_browser_cycles
'
]
+
1
)
:
            
LOG
.
info
(
"
begin
browser
cycle
%
d
of
%
d
for
test
%
s
"
                     
%
(
test
[
'
browser_cycle
'
]
test
[
'
expected_browser_cycles
'
]
test
[
'
name
'
]
)
)
            
self
.
run_test_setup
(
test
)
            
self
.
clear_app_data
(
)
            
self
.
set_debug_app_flag
(
)
            
if
test
[
'
browser_cycle
'
]
=
=
1
:
                
if
test
.
get
(
'
playback
'
)
is
not
None
:
                    
self
.
start_playback
(
test
)
                    
local_cert_db_dir
=
tempfile
.
mkdtemp
(
)
                    
LOG
.
info
(
"
backing
up
browser
ssl
cert
db
that
was
created
via
certutil
"
)
                    
self
.
copy_cert_db
(
self
.
config
[
'
local_profile_dir
'
]
local_cert_db_dir
)
                
if
self
.
config
[
'
host
'
]
not
in
(
'
localhost
'
'
127
.
0
.
0
.
1
'
)
:
                    
self
.
delete_proxy_settings_from_profile
(
)
            
else
:
                
self
.
device
.
stop_application
(
self
.
config
[
'
binary
'
]
)
                
self
.
build_browser_profile
(
)
                
if
test
.
get
(
'
playback
'
)
is
not
None
:
                    
LOG
.
info
(
"
copying
existing
ssl
cert
db
into
new
browser
profile
"
)
                    
self
.
copy_cert_db
(
local_cert_db_dir
self
.
config
[
'
local_profile_dir
'
]
)
                
self
.
run_test_setup
(
test
)
            
if
test
.
get
(
'
playback
'
)
is
not
None
:
                
self
.
turn_on_android_app_proxy
(
)
            
self
.
copy_profile_to_device
(
)
            
self
.
log_android_device_temperature
(
)
            
self
.
write_android_app_config
(
)
            
self
.
launch_firefox_android_app
(
test
[
'
name
'
]
)
            
self
.
control_server
.
_finished
=
False
            
if
self
.
config
[
'
cpu_test
'
]
:
                
self
.
cpu_profiler
=
start_android_cpu_profiler
(
self
)
            
self
.
wait_for_test_finish
(
test
timeout
)
            
if
self
.
debug_mode
and
self
.
config
[
'
run_local
'
]
:
                
LOG
.
info
(
"
*
debug
-
mode
enabled
-
please
shutdown
the
browser
manually
.
.
.
"
)
                
self
.
runner
.
wait
(
timeout
=
None
)
            
if
len
(
self
.
results_handler
.
page_timeout_list
)
>
0
:
                
break
    
def
__run_test_warm
(
self
test
timeout
)
:
        
LOG
.
info
(
"
test
%
s
is
running
in
warm
mode
;
browser
will
NOT
be
restarted
between
"
                 
"
page
cycles
"
%
test
[
'
name
'
]
)
        
self
.
run_test_setup
(
test
)
        
if
test
.
get
(
'
playback
'
)
is
not
None
:
            
self
.
start_playback
(
test
)
        
if
self
.
config
[
'
host
'
]
not
in
(
'
localhost
'
'
127
.
0
.
0
.
1
'
)
:
            
self
.
delete_proxy_settings_from_profile
(
)
        
if
test
.
get
(
'
playback
'
)
is
not
None
:
            
self
.
turn_on_android_app_proxy
(
)
        
self
.
clear_app_data
(
)
        
self
.
set_debug_app_flag
(
)
        
self
.
copy_profile_to_device
(
)
        
self
.
log_android_device_temperature
(
)
        
self
.
write_android_app_config
(
)
        
self
.
launch_firefox_android_app
(
test
[
'
name
'
]
)
        
self
.
control_server
.
_finished
=
False
        
if
self
.
config
[
'
cpu_test
'
]
:
            
self
.
cpu_profiler
=
start_android_cpu_profiler
(
self
)
        
self
.
wait_for_test_finish
(
test
timeout
)
        
if
self
.
debug_mode
and
self
.
config
[
'
run_local
'
]
:
            
LOG
.
info
(
"
*
debug
-
mode
enabled
-
please
shutdown
the
browser
manually
.
.
.
"
)
    
def
check_for_crashes
(
self
)
:
        
super
(
RaptorAndroid
self
)
.
check_for_crashes
(
)
        
if
not
self
.
app_launched
:
            
LOG
.
info
(
"
skipping
check_for_crashes
:
application
has
not
been
launched
"
)
            
return
        
self
.
app_launched
=
False
        
verbose
=
self
.
device
.
_verbose
        
self
.
device
.
_verbose
=
False
        
logcat
=
self
.
device
.
get_logcat
(
)
        
self
.
device
.
_verbose
=
verbose
        
if
logcat
:
            
if
mozcrash
.
check_for_java_exception
(
logcat
"
raptor
"
)
:
                
return
        
try
:
            
dump_dir
=
tempfile
.
mkdtemp
(
)
            
remote_dir
=
posixpath
.
join
(
self
.
remote_profile
'
minidumps
'
)
            
if
not
self
.
device
.
is_dir
(
remote_dir
)
:
                
LOG
.
error
(
"
No
crash
directory
(
%
s
)
found
on
remote
device
"
%
remote_dir
)
                
return
            
self
.
device
.
pull
(
remote_dir
dump_dir
)
            
mozcrash
.
log_crashes
(
LOG
dump_dir
self
.
config
[
'
symbols_path
'
]
)
        
finally
:
            
try
:
                
shutil
.
rmtree
(
dump_dir
)
            
except
Exception
:
                
LOG
.
warning
(
"
unable
to
remove
directory
:
%
s
"
%
dump_dir
)
    
def
clean_up
(
self
)
:
        
LOG
.
info
(
"
removing
test
folder
for
raptor
:
%
s
"
%
self
.
remote_test_root
)
        
self
.
device
.
rm
(
self
.
remote_test_root
force
=
True
recursive
=
True
)
        
super
(
RaptorAndroid
self
)
.
clean_up
(
)
def
main
(
args
=
sys
.
argv
[
1
:
]
)
:
    
args
=
parse_args
(
)
    
commandline
.
setup_logging
(
'
raptor
'
args
{
'
tbpl
'
:
sys
.
stdout
}
)
    
LOG
.
info
(
"
raptor
-
start
"
)
    
if
args
.
debug_mode
:
        
LOG
.
info
(
"
debug
-
mode
enabled
"
)
    
LOG
.
info
(
"
received
command
line
arguments
:
%
s
"
%
str
(
args
)
)
    
raptor_test_list
=
get_raptor_test_list
(
args
mozinfo
.
os
)
    
raptor_test_names
=
[
raptor_test
[
'
name
'
]
for
raptor_test
in
raptor_test_list
]
    
if
len
(
raptor_test_list
)
=
=
0
:
        
LOG
.
critical
(
"
this
test
is
not
targeted
for
{
}
"
.
format
(
args
.
app
)
)
        
sys
.
exit
(
1
)
    
LOG
.
info
(
"
raptor
tests
scheduled
to
run
:
"
)
    
for
next_test
in
raptor_test_list
:
        
LOG
.
info
(
next_test
[
'
name
'
]
)
    
if
not
args
.
browsertime
:
        
if
args
.
app
=
=
"
firefox
"
:
            
raptor_class
=
RaptorDesktopFirefox
        
elif
args
.
app
in
CHROMIUM_DISTROS
:
            
raptor_class
=
RaptorDesktopChrome
        
else
:
            
raptor_class
=
RaptorAndroid
    
else
:
        
def
raptor_class
(
*
inner_args
*
*
inner_kwargs
)
:
            
outer_kwargs
=
vars
(
args
)
            
for
key
in
outer_kwargs
.
keys
(
)
:
                
if
key
.
startswith
(
'
browsertime_
'
)
:
                    
value
=
outer_kwargs
.
pop
(
key
)
                    
inner_kwargs
[
key
]
=
value
            
if
args
.
app
=
=
"
firefox
"
or
args
.
app
in
CHROMIUM_DISTROS
:
                
klass
=
BrowsertimeDesktop
            
else
:
                
klass
=
BrowsertimeAndroid
            
return
klass
(
*
inner_args
*
*
inner_kwargs
)
    
raptor
=
raptor_class
(
args
.
app
                          
args
.
binary
                          
run_local
=
args
.
run_local
                          
noinstall
=
args
.
noinstall
                          
installerpath
=
args
.
installerpath
                          
obj_path
=
args
.
obj_path
                          
gecko_profile
=
args
.
gecko_profile
                          
gecko_profile_interval
=
args
.
gecko_profile_interval
                          
gecko_profile_entries
=
args
.
gecko_profile_entries
                          
symbols_path
=
args
.
symbols_path
                          
host
=
args
.
host
                          
power_test
=
args
.
power_test
                          
cpu_test
=
args
.
cpu_test
                          
memory_test
=
args
.
memory_test
                          
is_release_build
=
args
.
is_release_build
                          
debug_mode
=
args
.
debug_mode
                          
post_startup_delay
=
args
.
post_startup_delay
                          
activity
=
args
.
activity
                          
intent
=
args
.
intent
                          
interrupt_handler
=
SignalHandler
(
)
                          
enable_webrender
=
args
.
enable_webrender
                          
)
    
success
=
raptor
.
run_tests
(
raptor_test_list
raptor_test_names
)
    
if
not
success
:
        
LOG
.
critical
(
"
TEST
-
UNEXPECTED
-
FAIL
:
no
raptor
test
results
were
found
for
%
s
"
%
                     
'
'
.
join
(
raptor_test_names
)
)
        
os
.
sys
.
exit
(
1
)
    
pages_that_timed_out
=
raptor
.
get_page_timeout_list
(
)
    
if
len
(
pages_that_timed_out
)
>
0
:
        
for
_page
in
pages_that_timed_out
:
            
message
=
[
(
"
TEST
-
UNEXPECTED
-
FAIL
"
"
test
'
%
s
'
"
%
_page
[
'
test_name
'
]
)
                       
(
"
timed
out
loading
test
page
"
_page
[
'
url
'
]
)
]
            
if
_page
.
get
(
'
pending_metrics
'
)
is
not
None
:
                
message
.
append
(
(
"
pending
metrics
"
_page
[
'
pending_metrics
'
]
)
)
            
LOG
.
critical
(
"
"
.
join
(
"
%
s
:
%
s
"
%
(
subject
msg
)
for
subject
msg
in
message
)
)
        
os
.
sys
.
exit
(
1
)
    
if
args
.
gecko_profile
and
args
.
run_local
:
        
if
os
.
environ
.
get
(
'
DISABLE_PROFILE_LAUNCH
'
'
0
'
)
=
=
'
1
'
:
            
LOG
.
info
(
"
Not
launching
profiler
.
firefox
.
com
because
DISABLE_PROFILE_LAUNCH
=
1
"
)
        
else
:
            
view_gecko_profile
(
args
.
binary
)
if
__name__
=
=
"
__main__
"
:
    
main
(
)
