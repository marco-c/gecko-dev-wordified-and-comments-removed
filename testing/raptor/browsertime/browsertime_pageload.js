const
fs
=
require
(
"
fs
"
)
;
const
http
=
require
(
"
http
"
)
;
const
URL
=
"
/
secrets
/
v1
/
secret
/
project
/
perftest
/
gecko
/
level
-
"
;
const
SECRET
=
"
/
perftest
-
login
"
;
const
DEFAULT_SERVER
=
"
https
:
/
/
firefox
-
ci
-
tc
.
services
.
mozilla
.
com
"
;
async
function
get_tc_secrets
(
context
)
{
const
MOZ_AUTOMATION
=
process
.
env
.
MOZ_AUTOMATION
;
if
(
!
MOZ_AUTOMATION
)
{
throw
Error
(
"
Not
running
in
CI
.
Set
RAPTOR_LOGINS
to
a
JSON
file
containing
the
logins
.
"
)
;
}
let
TASKCLUSTER_PROXY_URL
=
process
.
env
.
TASKCLUSTER_PROXY_URL
?
process
.
env
.
TASKCLUSTER_PROXY_URL
:
DEFAULT_SERVER
;
let
MOZ_SCM_LEVEL
=
process
.
env
.
MOZ_SCM_LEVEL
?
process
.
env
.
MOZ_SCM_LEVEL
:
1
;
const
url
=
TASKCLUSTER_PROXY_URL
+
URL
+
MOZ_SCM_LEVEL
+
SECRET
;
const
data
=
await
new
Promise
(
(
resolve
reject
)
=
>
{
context
.
log
.
info
(
"
Obtaining
secrets
for
login
.
.
.
"
)
;
http
.
get
(
url
{
headers
:
{
"
Content
-
Type
"
:
"
application
/
json
"
Accept
:
"
application
/
json
"
}
}
res
=
>
{
let
data
=
"
"
;
context
.
log
.
info
(
Secret
status
code
:
{
res
.
statusCode
}
)
;
res
.
on
(
"
data
"
d
=
>
{
data
+
=
d
.
toString
(
)
;
}
)
;
res
.
on
(
"
end
"
(
)
=
>
{
resolve
(
data
)
;
}
)
;
res
.
on
(
"
error
"
error
=
>
{
context
.
log
.
error
(
error
)
;
reject
(
error
)
;
}
)
;
}
)
;
}
)
;
return
JSON
.
parse
(
data
)
;
}
async
function
get_logins
(
context
)
{
let
logins
;
let
RAPTOR_LOGINS
=
process
.
env
.
RAPTOR_LOGINS
;
if
(
RAPTOR_LOGINS
)
{
if
(
!
RAPTOR_LOGINS
.
endsWith
(
"
.
json
"
)
)
{
throw
Error
(
File
given
for
logins
does
not
end
in
'
.
json
'
:
{
RAPTOR_LOGINS
}
)
;
}
let
logins_file
=
null
;
try
{
logins_file
=
await
fs
.
readFileSync
(
RAPTOR_LOGINS
"
utf8
"
)
;
}
catch
(
err
)
{
throw
Error
(
Failed
to
read
the
file
{
RAPTOR_LOGINS
}
:
{
err
}
)
;
}
logins
=
await
JSON
.
parse
(
logins_file
)
;
}
else
{
logins
=
await
get_tc_secrets
(
context
)
;
}
return
logins
;
}
async
function
get_login_type
(
context
commands
)
{
let
input_length
=
await
commands
.
js
.
run
(
return
document
.
querySelectorAll
(
"
input
[
type
=
password
]
[
tabIndex
=
'
0
'
]
:
not
(
[
type
=
hidden
]
)
"
+
"
input
[
type
=
password
]
:
not
(
[
tabIndex
]
)
:
not
(
[
type
=
hidden
]
)
"
)
.
length
;
)
;
if
(
input_length
=
=
0
)
{
context
.
log
.
info
(
"
Found
a
multi
-
page
login
"
)
;
return
multi_page_login
;
}
else
if
(
input_length
=
=
1
)
{
context
.
log
.
info
(
"
Found
a
single
-
page
login
"
)
;
return
single_page_login
;
}
if
(
(
await
commands
.
js
.
run
(
return
document
.
querySelectorAll
(
"
form
"
)
.
length
;
)
)
>
=
1
)
{
context
.
log
.
info
(
"
Found
a
single
-
form
login
"
)
;
return
single_form_login
;
}
return
null
;
}
async
function
single_page_login
(
login_info
context
commands
prefix
=
"
"
)
{
await
commands
.
addText
.
bySelector
(
login_info
.
username
{
prefix
}
input
:
not
(
[
type
=
hidden
]
)
:
not
(
[
type
=
password
]
)
)
;
await
commands
.
addText
.
bySelector
(
login_info
.
password
{
prefix
}
input
[
type
=
password
]
:
not
(
[
type
=
hidden
]
)
)
;
return
undefined
;
}
async
function
single_form_login
(
login_info
context
commands
)
{
return
single_page_login
(
login_info
context
commands
"
form
"
)
;
}
async
function
multi_page_login
(
login_info
context
commands
)
{
const
driver
=
context
.
selenium
.
driver
;
const
webdriver
=
context
.
selenium
.
webdriver
;
const
username_field
=
await
driver
.
findElement
(
webdriver
.
By
.
css
(
input
:
not
(
[
type
=
hidden
]
)
:
not
(
[
type
=
password
]
)
)
)
;
await
username_field
.
sendKeys
(
login_info
.
username
)
;
await
username_field
.
sendKeys
(
webdriver
.
Key
.
ENTER
)
;
await
commands
.
wait
.
byTime
(
5000
)
;
let
password_field
;
try
{
password_field
=
await
driver
.
findElement
(
webdriver
.
By
.
css
(
input
[
type
=
password
]
:
not
(
[
type
=
hidden
]
)
)
)
;
}
catch
(
err
)
{
if
(
err
.
toString
(
)
.
includes
(
"
NoSuchElementError
"
)
)
{
let
name_field
=
await
driver
.
findElement
(
webdriver
.
By
.
css
(
input
:
not
(
[
type
=
hidden
]
)
:
not
(
[
type
=
password
]
)
)
)
;
await
name_field
.
sendKeys
(
login_info
.
suspicious_answer
)
;
await
name_field
.
sendKeys
(
webdriver
.
Key
.
ENTER
)
;
await
commands
.
wait
.
byTime
(
5000
)
;
password_field
=
await
driver
.
findElement
(
webdriver
.
By
.
css
(
input
[
type
=
password
]
:
not
(
[
type
=
hidden
]
)
)
)
;
}
else
{
throw
err
;
}
}
await
password_field
.
sendKeys
(
login_info
.
password
)
;
return
async
function
(
)
{
password_field
.
sendKeys
(
webdriver
.
Key
.
ENTER
)
;
await
commands
.
wait
.
byTime
(
5000
)
;
}
;
}
async
function
setup_login
(
login_info
context
commands
)
{
let
login_func
=
await
get_login_type
(
context
commands
)
;
if
(
!
login_func
)
{
throw
Error
(
"
Could
not
determine
the
type
of
login
page
.
"
)
;
}
try
{
return
await
login_func
(
login_info
context
commands
)
;
}
catch
(
err
)
{
throw
Error
(
Could
not
setup
login
information
:
{
err
}
)
;
}
}
async
function
login
(
context
commands
final_button
)
{
try
{
if
(
!
final_button
)
{
await
commands
.
mouse
.
doubleClick
.
bySelector
(
"
button
[
type
=
submit
]
"
)
;
await
commands
.
wait
.
byTime
(
10000
)
;
}
else
{
await
final_button
(
)
;
}
const
XPATHS
=
[
"
/
/
a
[
contains
(
text
(
)
'
skip
'
)
]
"
"
/
/
button
[
contains
(
text
(
)
'
skip
'
)
]
"
"
/
/
input
[
contains
(
text
(
)
'
skip
'
)
]
"
"
/
/
div
[
contains
(
text
(
)
'
skip
'
)
]
"
]
;
for
(
let
xpath
of
XPATHS
)
{
try
{
await
commands
.
mouse
.
doubleClick
.
byXpath
(
xpath
)
;
}
catch
(
err
)
{
if
(
err
.
toString
(
)
.
includes
(
"
not
double
click
"
)
)
{
context
.
log
.
info
(
Can
'
t
find
a
button
with
the
text
:
{
xpath
}
)
;
}
else
{
throw
err
;
}
}
}
}
catch
(
err
)
{
throw
Error
(
Could
not
login
to
website
as
we
could
not
find
the
submit
button
/
input
:
{
err
}
)
;
}
}
function
get_base_URL
(
fullUrl
)
{
let
pathAsArray
=
fullUrl
.
split
(
"
/
"
)
;
return
pathAsArray
[
0
]
+
"
/
/
"
+
pathAsArray
[
2
]
;
}
async
function
perform_live_login
(
context
commands
)
{
let
testUrl
=
context
.
options
.
browsertime
.
url
;
let
logins
=
await
get_logins
(
context
)
;
const
baseUrl
=
get_base_URL
(
testUrl
)
;
await
commands
.
navigate
(
"
about
:
blank
"
)
;
let
login_info
=
logins
.
secret
[
baseUrl
]
;
try
{
await
commands
.
navigate
(
login_info
.
login_url
)
;
}
catch
(
err
)
{
context
.
log
.
info
(
"
Unable
to
acquire
login
information
"
)
;
throw
err
;
}
await
commands
.
wait
.
byTime
(
10000
)
;
let
final_button
=
await
setup_login
(
login_info
context
commands
)
;
await
login
(
context
commands
final_button
)
;
}
module
.
exports
=
async
function
(
context
commands
)
{
context
.
log
.
info
(
"
Starting
a
browsertime
pageload
"
)
;
let
test_url
=
context
.
options
.
browsertime
.
url
;
let
secondary_url
=
context
.
options
.
browsertime
.
secondary_url
;
let
page_cycles
=
context
.
options
.
browsertime
.
page_cycles
;
let
page_cycle_delay
=
context
.
options
.
browsertime
.
page_cycle_delay
;
let
post_startup_delay
=
context
.
options
.
browsertime
.
post_startup_delay
;
let
chimera_mode
=
context
.
options
.
browsertime
.
chimera
;
let
login_required
=
context
.
options
.
browsertime
.
loginRequired
;
let
live_site
=
context
.
options
.
browsertime
.
liveSite
;
context
.
log
.
info
(
"
Waiting
for
%
d
ms
(
post_startup_delay
)
"
post_startup_delay
)
;
await
commands
.
wait
.
byTime
(
post_startup_delay
)
;
let
cached
=
false
;
if
(
login_required
=
=
"
True
"
&
&
live_site
=
=
"
True
"
)
{
await
perform_live_login
(
context
commands
)
;
}
for
(
let
count
=
0
;
count
<
page_cycles
;
count
+
+
)
{
if
(
count
!
=
=
0
&
&
secondary_url
!
=
=
undefined
)
{
context
.
log
.
info
(
"
Navigating
to
secondary
url
:
"
+
secondary_url
)
;
await
commands
.
navigate
(
secondary_url
)
;
await
commands
.
wait
.
byTime
(
1000
)
;
await
commands
.
js
.
runAndWait
(
(
function
(
)
{
const
white
=
document
.
createElement
(
'
div
'
)
;
white
.
id
=
'
raptor
-
white
'
;
white
.
style
.
position
=
'
absolute
'
;
white
.
style
.
top
=
'
0
'
;
white
.
style
.
left
=
'
0
'
;
white
.
style
.
width
=
Math
.
max
(
document
.
documentElement
.
clientWidth
document
.
body
.
clientWidth
)
+
'
px
'
;
white
.
style
.
height
=
Math
.
max
(
document
.
documentElement
.
clientHeight
document
.
body
.
clientHeight
)
+
'
px
'
;
white
.
style
.
backgroundColor
=
'
white
'
;
white
.
style
.
zIndex
=
'
2147483647
'
;
document
.
body
.
appendChild
(
white
)
;
document
.
body
.
style
.
display
=
'
'
;
}
)
(
)
;
)
;
await
commands
.
wait
.
byTime
(
1000
)
;
}
else
{
context
.
log
.
info
(
"
Navigating
to
about
:
blank
count
:
"
+
count
)
;
await
commands
.
navigate
(
"
about
:
blank
"
)
;
}
context
.
log
.
info
(
"
Navigating
to
primary
url
:
"
+
test_url
)
;
context
.
log
.
info
(
"
Cycle
%
d
waiting
for
%
d
ms
"
count
page_cycle_delay
)
;
await
commands
.
wait
.
byTime
(
page_cycle_delay
)
;
context
.
log
.
info
(
"
Cycle
%
d
starting
the
measure
"
count
)
;
await
commands
.
measure
.
start
(
test_url
)
;
if
(
chimera_mode
&
&
!
cached
)
{
await
commands
.
wait
.
byTime
(
20000
)
;
cached
=
true
;
}
}
context
.
log
.
info
(
"
Browsertime
pageload
ended
.
"
)
;
return
true
;
}
;
