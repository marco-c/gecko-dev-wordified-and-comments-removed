var
postStartupDelay
;
var
pageCycleDelay
=
1000
;
var
newTabDelay
=
1000
;
var
reuseTab
=
false
;
var
browserName
;
var
ext
;
var
testName
=
null
;
var
settingsURL
=
null
;
var
csPort
=
null
;
var
host
=
null
;
var
benchmarkPort
=
null
;
var
testType
;
var
pageCycles
=
0
;
var
pageCycle
=
0
;
var
testURL
;
var
testTabID
=
0
;
var
getHero
=
false
;
var
getFNBPaint
=
false
;
var
getFCP
=
false
;
var
getDCF
=
false
;
var
getTTFI
=
false
;
var
getLoadTime
=
false
;
var
isHeroPending
=
false
;
var
pendingHeroes
=
[
]
;
var
settings
=
{
}
;
var
isFNBPaintPending
=
false
;
var
isFCPPending
=
false
;
var
isDCFPending
=
false
;
var
isTTFIPending
=
false
;
var
isLoadTimePending
=
false
;
var
isBenchmarkPending
=
false
;
var
pageTimeout
=
10000
;
var
geckoProfiling
=
false
;
var
geckoInterval
=
1
;
var
geckoEntries
=
1000000
;
var
webRenderEnabled
=
false
;
var
debugMode
=
0
;
var
screenCapture
=
false
;
var
results
=
{
"
name
"
:
"
"
"
page
"
:
"
"
"
type
"
:
"
"
"
lower_is_better
"
:
true
"
alert_threshold
"
:
2
.
0
"
measurements
"
:
{
}
}
;
function
getTestSettings
(
)
{
console
.
log
(
"
getting
test
settings
from
control
server
"
)
;
return
new
Promise
(
resolve
=
>
{
fetch
(
settingsURL
)
.
then
(
function
(
response
)
{
response
.
text
(
)
.
then
(
function
(
text
)
{
console
.
log
(
text
)
;
settings
=
JSON
.
parse
(
text
)
[
"
raptor
-
options
"
]
;
testType
=
settings
.
type
;
pageCycles
=
settings
.
page_cycles
;
testURL
=
settings
.
test_url
;
if
(
testType
=
=
"
benchmark
"
)
{
testURL
=
testURL
.
replace
(
"
<
port
>
"
benchmarkPort
)
;
}
if
(
host
)
{
testURL
=
testURL
.
replace
(
"
<
host
>
"
host
)
;
}
console
.
log
(
"
testURL
:
"
+
testURL
)
;
results
.
page
=
testURL
;
results
.
type
=
testType
;
results
.
name
=
testName
;
results
.
unit
=
settings
.
unit
;
results
.
subtest_unit
=
settings
.
subtest_unit
;
results
.
lower_is_better
=
settings
.
lower_is_better
=
=
=
true
;
results
.
subtest_lower_is_better
=
settings
.
subtest_lower_is_better
=
=
=
true
;
results
.
alert_threshold
=
settings
.
alert_threshold
;
if
(
settings
.
gecko_profile
!
=
=
undefined
)
{
if
(
settings
.
gecko_profile
=
=
=
true
)
{
geckoProfiling
=
true
;
results
.
extra_options
=
[
"
gecko_profile
"
]
;
if
(
settings
.
gecko_interval
!
=
=
undefined
)
{
geckoInterval
=
settings
.
gecko_interval
;
}
if
(
settings
.
gecko_entries
!
=
=
undefined
)
{
geckoEntries
=
settings
.
gecko_entries
;
}
if
(
settings
.
webrender_enabled
!
=
=
undefined
)
{
webRenderEnabled
=
settings
.
webrender_enabled
;
}
}
}
if
(
settings
.
screen_capture
!
=
=
undefined
)
{
screenCapture
=
settings
.
screen_capture
;
}
if
(
settings
.
newtab_per_cycle
!
=
=
undefined
)
{
reuseTab
=
settings
.
newtab_per_cycle
;
}
if
(
settings
.
page_timeout
!
=
=
undefined
)
{
pageTimeout
=
settings
.
page_timeout
;
}
console
.
log
(
"
using
page
timeout
(
ms
)
:
"
+
pageTimeout
)
;
if
(
testType
=
=
"
pageload
"
)
{
if
(
settings
.
measure
!
=
=
undefined
)
{
if
(
settings
.
measure
.
fnbpaint
!
=
=
undefined
)
{
getFNBPaint
=
settings
.
measure
.
fnbpaint
;
}
if
(
settings
.
measure
.
dcf
!
=
=
undefined
)
{
getDCF
=
settings
.
measure
.
dcf
;
}
if
(
settings
.
measure
.
fcp
!
=
=
undefined
)
{
getFCP
=
settings
.
measure
.
fcp
;
}
if
(
settings
.
measure
.
hero
!
=
=
undefined
)
{
if
(
settings
.
measure
.
hero
.
length
!
=
=
0
)
{
getHero
=
true
;
}
}
if
(
settings
.
measure
.
ttfi
!
=
=
undefined
)
{
getTTFI
=
settings
.
measure
.
ttfi
;
}
if
(
settings
.
measure
.
loadtime
!
=
=
undefined
)
{
getLoadTime
=
settings
.
measure
.
loadtime
;
}
}
else
{
console
.
log
(
"
abort
:
'
measure
'
key
not
found
in
test
settings
"
)
;
cleanUp
(
)
;
}
}
if
(
[
"
firefox
"
"
geckoview
"
]
.
includes
(
browserName
)
)
{
ext
.
storage
.
local
.
clear
(
)
.
then
(
function
(
)
{
ext
.
storage
.
local
.
set
(
{
settings
}
)
.
then
(
function
(
)
{
console
.
log
(
"
wrote
settings
to
ext
local
storage
"
)
;
resolve
(
)
;
}
)
;
}
)
;
}
else
{
ext
.
storage
.
local
.
clear
(
function
(
)
{
ext
.
storage
.
local
.
set
(
{
settings
}
function
(
)
{
console
.
log
(
"
wrote
settings
to
ext
local
storage
"
)
;
resolve
(
)
;
}
)
;
}
)
;
}
}
)
;
}
)
;
}
)
;
}
function
getBrowserInfo
(
)
{
return
new
Promise
(
resolve
=
>
{
if
(
[
"
firefox
"
"
geckoview
"
]
.
includes
(
browserName
)
)
{
ext
=
browser
;
var
gettingInfo
=
browser
.
runtime
.
getBrowserInfo
(
)
;
gettingInfo
.
then
(
function
(
bi
)
{
results
.
browser
=
bi
.
name
+
"
"
+
bi
.
version
+
"
"
+
bi
.
buildID
;
console
.
log
(
"
testing
on
"
+
results
.
browser
)
;
resolve
(
)
;
}
)
;
}
else
{
ext
=
chrome
;
var
browserInfo
=
window
.
navigator
.
userAgent
.
split
(
"
"
)
;
for
(
let
x
in
browserInfo
)
{
if
(
browserInfo
[
x
]
.
indexOf
(
"
Chrome
"
)
>
-
1
)
{
results
.
browser
=
browserInfo
[
x
]
;
break
;
}
}
console
.
log
(
"
testing
on
"
+
results
.
browser
)
;
resolve
(
)
;
}
}
)
;
}
function
testTabCreated
(
tab
)
{
testTabID
=
tab
.
id
;
postToControlServer
(
"
status
"
"
opened
new
empty
tab
"
+
testTabID
)
;
ext
.
browserAction
.
setTitle
(
{
title
:
"
Raptor
RUNNING
"
}
)
;
}
function
testTabRemoved
(
tab
)
{
postToControlServer
(
"
status
"
"
Removed
tab
"
+
testTabID
)
;
testTabID
=
0
;
}
async
function
testTabUpdated
(
tab
)
{
postToControlServer
(
"
status
"
"
test
tab
updated
"
+
testTabID
)
;
await
waitForResult
(
)
;
nextCycle
(
)
;
}
function
waitForResult
(
)
{
console
.
log
(
"
awaiting
results
.
.
.
"
)
;
return
new
Promise
(
resolve
=
>
{
async
function
checkForResult
(
)
{
if
(
testType
=
=
"
pageload
"
)
{
if
(
!
isHeroPending
&
&
!
isFNBPaintPending
&
&
!
isFCPPending
&
&
!
isDCFPending
&
&
!
isTTFIPending
&
&
!
isLoadTimePending
)
{
cancelTimeoutAlarm
(
"
raptor
-
page
-
timeout
"
)
;
postToControlServer
(
"
status
"
"
results
received
"
)
;
if
(
geckoProfiling
)
{
await
getGeckoProfile
(
)
;
}
if
(
screenCapture
)
{
await
getScreenCapture
(
)
;
}
resolve
(
)
;
}
else
{
setTimeout
(
checkForResult
5
)
;
}
}
else
if
(
testType
=
=
"
benchmark
"
)
{
if
(
!
isBenchmarkPending
)
{
cancelTimeoutAlarm
(
"
raptor
-
page
-
timeout
"
)
;
postToControlServer
(
"
status
"
"
results
received
"
)
;
if
(
geckoProfiling
)
{
await
getGeckoProfile
(
)
;
}
resolve
(
)
;
if
(
screenCapture
)
{
await
getScreenCapture
(
)
;
}
}
else
{
setTimeout
(
checkForResult
5
)
;
}
}
}
checkForResult
(
)
;
}
)
;
}
async
function
getScreenCapture
(
)
{
console
.
log
(
"
Capturing
screenshot
.
.
.
"
)
;
var
capturing
;
if
(
[
"
firefox
"
"
geckoview
"
]
.
includes
(
browserName
)
)
{
capturing
=
ext
.
tabs
.
captureVisibleTab
(
)
;
capturing
.
then
(
onCaptured
onError
)
;
await
capturing
;
}
else
{
capturing
=
new
Promise
(
function
(
resolve
reject
)
{
ext
.
tabs
.
captureVisibleTab
(
resolve
)
;
}
)
;
capturing
.
then
(
onCaptured
onError
)
;
await
capturing
;
}
}
function
onCaptured
(
screenshotUri
)
{
console
.
log
(
"
Screenshot
capured
!
"
)
;
postToControlServer
(
"
screenshot
"
[
screenshotUri
testName
pageCycle
]
)
;
}
function
onError
(
error
)
{
console
.
log
(
"
Screenshot
captured
failed
!
"
)
;
console
.
log
(
Error
:
{
error
}
)
;
}
async
function
startGeckoProfiling
(
)
{
var
_threads
;
if
(
webRenderEnabled
)
{
_threads
=
[
"
GeckoMain
"
"
Compositor
"
"
WR
Renderer
"
]
;
}
else
{
_threads
=
[
"
GeckoMain
"
"
Compositor
"
]
;
}
postToControlServer
(
"
status
"
"
starting
gecko
profiling
"
)
;
await
browser
.
geckoProfiler
.
start
(
{
bufferSize
:
geckoEntries
interval
:
geckoInterval
features
:
[
"
js
"
"
leaf
"
"
stackwalk
"
"
threads
"
"
responsiveness
"
]
threads
:
_threads
}
)
;
}
async
function
stopGeckoProfiling
(
)
{
postToControlServer
(
"
status
"
"
stopping
gecko
profiling
"
)
;
await
browser
.
geckoProfiler
.
stop
(
)
;
}
async
function
getGeckoProfile
(
)
{
postToControlServer
(
"
status
"
"
retrieving
gecko
profile
"
)
;
let
arrayBuffer
=
await
browser
.
geckoProfiler
.
getProfileAsArrayBuffer
(
)
;
let
textDecoder
=
new
TextDecoder
(
)
;
let
profile
=
JSON
.
parse
(
textDecoder
.
decode
(
arrayBuffer
)
)
;
console
.
log
(
profile
)
;
postToControlServer
(
"
gecko_profile
"
[
testName
pageCycle
profile
]
)
;
await
stopGeckoProfiling
(
)
;
if
(
pageCycle
+
1
<
=
pageCycles
)
{
await
startGeckoProfiling
(
)
;
}
}
async
function
nextCycle
(
)
{
pageCycle
+
+
;
if
(
pageCycle
=
=
1
)
{
let
text
=
"
running
"
+
pageCycles
+
"
pagecycles
of
"
+
testURL
;
postToControlServer
(
"
status
"
text
)
;
if
(
geckoProfiling
)
{
await
startGeckoProfiling
(
)
;
}
}
if
(
pageCycle
<
=
pageCycles
)
{
setTimeout
(
function
(
)
{
let
text
=
"
begin
pagecycle
"
+
pageCycle
;
postToControlServer
(
"
status
"
text
)
;
setTimeoutAlarm
(
"
raptor
-
page
-
timeout
"
pageTimeout
)
;
if
(
testType
=
=
"
pageload
"
)
{
if
(
getHero
)
{
isHeroPending
=
true
;
pendingHeroes
=
Array
.
from
(
settings
.
measure
.
hero
)
;
}
if
(
getFNBPaint
)
isFNBPaintPending
=
true
;
if
(
getFCP
)
isFCPPending
=
true
;
if
(
getDCF
)
isDCFPending
=
true
;
if
(
getTTFI
)
isTTFIPending
=
true
;
if
(
getLoadTime
)
isLoadTimePending
=
true
;
}
else
if
(
testType
=
=
"
benchmark
"
)
{
isBenchmarkPending
=
true
;
}
if
(
reuseTab
&
&
testTabID
!
=
0
)
{
ext
.
tabs
.
remove
(
testTabID
)
;
postToControlServer
(
"
status
"
"
closing
Tab
"
+
testTabID
)
;
ext
.
tabs
.
create
(
{
url
:
"
about
:
blank
"
}
)
;
postToControlServer
(
"
status
"
"
Open
new
tab
"
)
;
}
setTimeout
(
function
(
)
{
postToControlServer
(
"
status
"
"
update
tab
"
+
testTabID
)
;
ext
.
tabs
.
update
(
testTabID
{
url
:
testURL
}
testTabUpdated
)
;
}
newTabDelay
)
;
}
pageCycleDelay
)
;
}
else
{
verifyResults
(
)
;
}
}
async
function
timeoutAlarmListener
(
)
{
console
.
error
(
"
raptor
-
page
-
timeout
on
%
s
"
%
testURL
)
;
postToControlServer
(
"
raptor
-
page
-
timeout
"
[
testName
testURL
]
)
;
if
(
screenCapture
)
{
await
getScreenCapture
(
)
;
}
cleanUp
(
)
;
}
function
setTimeoutAlarm
(
timeoutName
timeoutMS
)
{
var
now
=
Date
.
now
(
)
;
var
timeout_when
=
now
+
timeoutMS
;
ext
.
alarms
.
create
(
timeoutName
{
when
:
timeout_when
}
)
;
console
.
log
(
"
now
is
"
+
now
+
"
set
raptor
alarm
"
+
timeoutName
+
"
to
expire
at
"
+
timeout_when
)
;
}
function
cancelTimeoutAlarm
(
timeoutName
)
{
if
(
browserName
=
=
=
"
firefox
"
|
|
browserName
=
=
=
"
geckoview
"
)
{
var
clearAlarm
=
ext
.
alarms
.
clear
(
timeoutName
)
;
clearAlarm
.
then
(
function
(
onCleared
)
{
if
(
onCleared
)
{
console
.
log
(
"
cancelled
"
+
timeoutName
)
;
}
else
{
console
.
error
(
"
failed
to
clear
"
+
timeoutName
)
;
}
}
)
;
}
else
{
chrome
.
alarms
.
clear
(
timeoutName
function
(
wasCleared
)
{
if
(
wasCleared
)
{
console
.
log
(
"
cancelled
"
+
timeoutName
)
;
}
else
{
console
.
error
(
"
failed
to
clear
"
+
timeoutName
)
;
}
}
)
;
}
}
function
resultListener
(
request
sender
sendResponse
)
{
console
.
log
(
"
received
message
from
"
+
sender
.
tab
.
url
)
;
if
(
request
.
type
&
&
request
.
value
)
{
console
.
log
(
"
result
:
"
+
request
.
type
+
"
"
+
request
.
value
)
;
sendResponse
(
{
text
:
"
confirmed
"
+
request
.
type
}
)
;
if
(
!
(
request
.
type
in
results
.
measurements
)
)
results
.
measurements
[
request
.
type
]
=
[
]
;
if
(
testType
=
=
"
pageload
"
)
{
if
(
request
.
type
.
indexOf
(
"
hero
"
)
>
-
1
)
{
results
.
measurements
[
request
.
type
]
.
push
(
request
.
value
)
;
var
_found
=
request
.
type
.
split
(
"
hero
:
"
)
[
1
]
;
var
index
=
pendingHeroes
.
indexOf
(
_found
)
;
if
(
index
>
-
1
)
{
pendingHeroes
.
splice
(
index
1
)
;
if
(
pendingHeroes
.
length
=
=
0
)
{
console
.
log
(
"
measured
all
expected
hero
elements
"
)
;
isHeroPending
=
false
;
}
}
}
else
if
(
request
.
type
=
=
"
fnbpaint
"
)
{
results
.
measurements
.
fnbpaint
.
push
(
request
.
value
)
;
isFNBPaintPending
=
false
;
}
else
if
(
request
.
type
=
=
"
dcf
"
)
{
results
.
measurements
.
dcf
.
push
(
request
.
value
)
;
isDCFPending
=
false
;
}
else
if
(
request
.
type
=
=
"
ttfi
"
)
{
results
.
measurements
.
ttfi
.
push
(
request
.
value
)
;
isTTFIPending
=
false
;
}
else
if
(
request
.
type
=
=
"
fcp
"
)
{
results
.
measurements
.
fcp
.
push
(
request
.
value
)
;
isFCPPending
=
false
;
}
else
if
(
request
.
type
=
=
"
loadtime
"
)
{
results
.
measurements
.
loadtime
.
push
(
request
.
value
)
;
isLoadTimePending
=
false
;
}
}
else
if
(
testType
=
=
"
benchmark
"
)
{
console
.
log
(
"
received
results
from
benchmark
"
)
;
results
.
measurements
[
request
.
type
]
.
push
(
request
.
value
)
;
isBenchmarkPending
=
false
;
}
}
else
{
console
.
log
(
"
unknown
message
received
from
content
:
"
+
request
)
;
}
}
function
verifyResults
(
)
{
console
.
log
(
"
\
nVerifying
results
:
"
)
;
console
.
log
(
results
)
;
for
(
var
x
in
results
.
measurements
)
{
let
count
=
results
.
measurements
[
x
]
.
length
;
if
(
count
=
=
pageCycles
)
{
console
.
log
(
"
have
"
+
count
+
"
results
for
"
+
x
+
"
as
expected
"
)
;
}
else
{
console
.
log
(
"
ERROR
:
expected
"
+
pageCycles
+
"
results
for
"
+
x
+
"
but
only
have
"
+
count
)
;
}
}
postToControlServer
(
"
results
"
results
)
;
}
function
postToControlServer
(
msgType
msgData
)
{
if
(
msgType
=
=
"
status
"
)
{
console
.
log
(
"
\
n
"
+
msgData
)
;
}
var
url
=
"
http
:
/
/
"
+
host
+
"
:
"
+
csPort
+
"
/
"
;
var
client
=
new
XMLHttpRequest
(
)
;
client
.
onreadystatechange
=
function
(
)
{
if
(
client
.
readyState
=
=
XMLHttpRequest
.
DONE
&
&
client
.
status
=
=
200
)
{
console
.
log
(
"
post
success
"
)
;
}
}
;
client
.
open
(
"
POST
"
url
true
)
;
client
.
setRequestHeader
(
"
Content
-
Type
"
"
application
/
json
"
)
;
if
(
client
.
readyState
=
=
1
)
{
console
.
log
(
"
posting
to
control
server
"
)
;
console
.
log
(
msgData
)
;
var
data
=
{
"
type
"
:
"
webext_
"
+
msgType
"
data
"
:
msgData
}
;
client
.
send
(
JSON
.
stringify
(
data
)
)
;
}
if
(
msgType
=
=
"
results
"
)
{
cleanUp
(
)
;
}
}
function
cleanUp
(
)
{
if
(
debugMode
!
=
1
)
{
ext
.
tabs
.
remove
(
testTabID
)
;
console
.
log
(
"
closed
tab
"
+
testTabID
)
;
}
else
{
console
.
log
(
"
raptor
debug
-
mode
enabled
leaving
tab
open
"
)
;
}
if
(
testType
=
=
"
pageload
"
)
{
ext
.
runtime
.
onMessage
.
removeListener
(
resultListener
)
;
ext
.
tabs
.
onCreated
.
removeListener
(
testTabCreated
)
;
ext
.
alarms
.
onAlarm
.
removeListener
(
timeoutAlarmListener
)
;
console
.
log
(
"
pageloader
test
finished
"
)
;
}
else
if
(
testType
=
=
"
benchmark
"
)
{
console
.
log
(
"
benchmark
complete
"
)
;
}
if
(
geckoProfiling
)
{
stopGeckoProfiling
(
)
;
}
window
.
onload
=
null
;
postToControlServer
(
"
status
"
"
__raptor_shutdownBrowser
"
)
;
}
function
runner
(
)
{
let
config
=
getTestConfig
(
)
;
console
.
log
(
"
test
name
is
:
"
+
config
.
test_name
)
;
console
.
log
(
"
test
settings
url
is
:
"
+
config
.
test_settings_url
)
;
testName
=
config
.
test_name
;
settingsURL
=
config
.
test_settings_url
;
csPort
=
config
.
cs_port
;
browserName
=
config
.
browser
;
benchmarkPort
=
config
.
benchmark_port
;
postStartupDelay
=
config
.
post_startup_delay
;
host
=
config
.
host
;
debugMode
=
config
.
debug_mode
;
postToControlServer
(
"
status
"
"
raptor
runner
.
js
is
loaded
!
"
)
;
getBrowserInfo
(
)
.
then
(
function
(
)
{
getTestSettings
(
)
.
then
(
function
(
)
{
if
(
testType
=
=
"
benchmark
"
)
{
console
.
log
(
"
benchmark
test
start
"
)
;
}
else
if
(
testType
=
=
"
pageload
"
)
{
console
.
log
(
"
pageloader
test
start
"
)
;
}
ext
.
runtime
.
onMessage
.
addListener
(
resultListener
)
;
ext
.
tabs
.
onCreated
.
addListener
(
testTabCreated
)
;
ext
.
tabs
.
onRemoved
.
addListener
(
testTabRemoved
)
;
ext
.
alarms
.
onAlarm
.
addListener
(
timeoutAlarmListener
)
;
let
text
=
"
*
pausing
"
+
postStartupDelay
/
1000
+
"
seconds
to
let
browser
settle
.
.
.
*
"
;
postToControlServer
(
"
status
"
text
)
;
if
(
config
.
browser
=
=
"
geckoview
"
)
{
setTimeout
(
function
(
)
{
nextCycle
(
)
;
}
postStartupDelay
)
;
}
else
{
setTimeout
(
function
(
)
{
ext
.
tabs
.
create
(
{
url
:
"
about
:
blank
"
}
)
;
nextCycle
(
)
;
}
postStartupDelay
)
;
}
}
)
;
}
)
;
}
window
.
onload
=
runner
(
)
;
