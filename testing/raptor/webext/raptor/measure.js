var
perfData
=
window
.
performance
;
var
gRetryCounter
=
0
;
var
getHero
=
false
;
var
heroesToCapture
=
[
]
;
var
getFNBPaint
=
false
;
var
getFCP
=
false
;
var
getDCF
=
false
;
var
getTTFI
=
false
;
var
getLoadTime
=
false
;
var
startMeasure
=
"
fetchStart
"
;
function
contentHandler
(
)
{
if
(
typeof
(
browser
)
!
=
=
"
undefined
"
)
{
browser
.
storage
.
local
.
get
(
"
settings
"
)
.
then
(
function
(
item
)
{
setup
(
item
.
settings
)
;
}
)
;
}
else
{
chrome
.
storage
.
local
.
get
(
"
settings
"
function
(
item
)
{
setup
(
item
.
settings
)
;
}
)
;
}
}
function
setup
(
settings
)
{
if
(
settings
.
type
!
=
"
pageload
"
)
{
return
;
}
if
(
settings
.
measure
=
=
undefined
)
{
console
.
log
(
"
abort
:
'
measure
'
key
not
found
in
test
settings
"
)
;
return
;
}
if
(
settings
.
measure
.
fnbpaint
!
=
=
undefined
)
{
getFNBPaint
=
settings
.
measure
.
fnbpaint
;
if
(
getFNBPaint
)
{
console
.
log
(
"
will
be
measuring
fnbpaint
"
)
;
measureFNBPaint
(
)
;
}
}
if
(
settings
.
measure
.
dcf
!
=
=
undefined
)
{
getDCF
=
settings
.
measure
.
dcf
;
if
(
getDCF
)
{
console
.
log
(
"
will
be
measuring
dcf
"
)
;
measureDCF
(
)
;
}
}
if
(
settings
.
measure
.
fcp
!
=
=
undefined
)
{
getFCP
=
settings
.
measure
.
fcp
;
if
(
getFCP
)
{
console
.
log
(
"
will
be
measuring
first
-
contentful
-
paint
"
)
;
measureFCP
(
)
;
}
}
if
(
settings
.
measure
.
hero
!
=
=
undefined
)
{
if
(
settings
.
measure
.
hero
.
length
!
=
=
0
)
{
getHero
=
true
;
heroesToCapture
=
settings
.
measure
.
hero
;
console
.
log
(
"
hero
elements
to
measure
:
"
+
heroesToCapture
)
;
measureHero
(
)
;
}
}
if
(
settings
.
measure
.
ttfi
!
=
=
undefined
)
{
getTTFI
=
settings
.
measure
.
ttfi
;
if
(
getTTFI
)
{
console
.
log
(
"
will
be
measuring
ttfi
"
)
;
measureTTFI
(
)
;
}
}
if
(
settings
.
measure
.
loadtime
!
=
=
undefined
)
{
getLoadTime
=
settings
.
measure
.
loadtime
;
if
(
getLoadTime
)
{
console
.
log
(
"
will
be
measuring
loadtime
"
)
;
measureLoadTime
(
)
;
}
}
}
function
measureHero
(
)
{
var
obs
=
null
;
var
heroElementsFound
=
window
.
document
.
querySelectorAll
(
"
[
elementtiming
]
"
)
;
console
.
log
(
"
found
"
+
heroElementsFound
.
length
+
"
hero
elements
in
the
page
"
)
;
if
(
heroElementsFound
)
{
function
callbackHero
(
entries
observer
)
{
entries
.
forEach
(
entry
=
>
{
var
heroFound
=
entry
.
target
.
getAttribute
(
"
elementtiming
"
)
;
perfData
.
mark
(
heroFound
)
;
console
.
log
(
"
found
hero
:
"
+
heroFound
)
;
var
resultType
=
"
hero
:
"
+
heroFound
;
perfData
.
measure
(
name
=
resultType
startMark
=
startMeasure
endMark
=
heroFound
)
;
var
perfResult
=
perfData
.
getEntriesByName
(
resultType
)
;
var
_result
=
Math
.
round
(
perfResult
[
0
]
.
duration
)
;
sendResult
(
resultType
_result
)
;
perfData
.
clearMarks
(
)
;
perfData
.
clearMeasures
(
)
;
obs
.
disconnect
(
)
;
}
)
;
}
var
options
=
{
root
:
null
rootMargin
:
"
0px
"
threshold
:
[
1
]
}
;
try
{
obs
=
new
window
.
IntersectionObserver
(
callbackHero
options
)
;
heroElementsFound
.
forEach
(
function
(
el
)
{
if
(
heroesToCapture
.
indexOf
(
el
.
getAttribute
(
"
elementtiming
"
)
)
>
-
1
)
obs
.
observe
(
el
)
;
}
)
;
}
catch
(
err
)
{
console
.
log
(
err
)
;
}
}
else
{
console
.
log
(
"
couldn
'
t
find
hero
element
"
)
;
}
}
function
measureFNBPaint
(
)
{
var
x
=
window
.
performance
.
timing
.
timeToNonBlankPaint
;
if
(
typeof
(
x
)
=
=
"
undefined
"
)
{
console
.
log
(
"
ERROR
:
timeToNonBlankPaint
is
undefined
;
ensure
the
pref
is
enabled
"
)
;
return
;
}
if
(
x
>
0
)
{
console
.
log
(
"
got
fnbpaint
"
)
;
gRetryCounter
=
0
;
var
startTime
=
perfData
.
timing
.
fetchStart
;
sendResult
(
"
fnbpaint
"
x
-
startTime
)
;
}
else
{
gRetryCounter
+
=
1
;
if
(
gRetryCounter
<
=
10
)
{
console
.
log
(
"
\
nfnbpaint
is
not
yet
available
(
0
)
retry
number
"
+
gRetryCounter
+
"
.
.
.
\
n
"
)
;
window
.
setTimeout
(
measureFNBPaint
100
)
;
}
else
{
console
.
log
(
"
\
nunable
to
get
a
value
for
fnbpaint
after
"
+
gRetryCounter
+
"
retries
\
n
"
)
;
}
}
}
function
measureDCF
(
)
{
var
x
=
window
.
performance
.
timing
.
timeToDOMContentFlushed
;
if
(
typeof
(
x
)
=
=
"
undefined
"
)
{
console
.
log
(
"
ERROR
:
domContentFlushed
is
undefined
;
ensure
the
pref
is
enabled
"
)
;
return
;
}
if
(
x
>
0
)
{
console
.
log
(
"
got
domContentFlushed
:
"
+
x
)
;
gRetryCounter
=
0
;
var
startTime
=
perfData
.
timing
.
fetchStart
;
sendResult
(
"
dcf
"
x
-
startTime
)
;
}
else
{
gRetryCounter
+
=
1
;
if
(
gRetryCounter
<
=
10
)
{
console
.
log
(
"
\
dcf
is
not
yet
available
(
0
)
retry
number
"
+
gRetryCounter
+
"
.
.
.
\
n
"
)
;
window
.
setTimeout
(
measureDCF
100
)
;
}
else
{
console
.
log
(
"
\
nunable
to
get
a
value
for
dcf
after
"
+
gRetryCounter
+
"
retries
\
n
"
)
;
}
}
}
function
measureTTFI
(
)
{
var
x
=
window
.
performance
.
timing
.
timeToFirstInteractive
;
if
(
typeof
(
x
)
=
=
"
undefined
"
)
{
console
.
log
(
"
ERROR
:
timeToFirstInteractive
is
undefined
;
ensure
the
pref
is
enabled
"
)
;
return
;
}
if
(
x
>
0
)
{
console
.
log
(
"
got
timeToFirstInteractive
:
"
+
x
)
;
gRetryCounter
=
0
;
var
startTime
=
perfData
.
timing
.
fetchStart
;
sendResult
(
"
ttfi
"
x
-
startTime
)
;
}
else
{
gRetryCounter
+
=
1
;
if
(
gRetryCounter
<
=
25
*
(
1000
/
200
)
)
{
console
.
log
(
"
TTFI
is
not
yet
available
(
0
)
retry
number
"
+
gRetryCounter
+
"
.
.
.
\
n
"
)
;
window
.
setTimeout
(
measureTTFI
200
)
;
}
else
{
console
.
log
(
"
TTFI
was
not
available
for
this
pageload
"
)
;
sendResult
(
"
ttfi
"
-
1
)
;
}
}
}
function
measureFCP
(
)
{
var
resultType
=
"
fcp
"
;
var
result
;
result
=
window
.
performance
.
timing
.
timeToContentfulPaint
;
if
(
typeof
(
result
)
=
=
"
undefined
"
)
{
result
=
0
;
let
perfEntries
=
perfData
.
getEntriesByType
(
"
paint
"
)
;
if
(
perfEntries
.
length
>
=
2
)
{
if
(
perfEntries
[
1
]
.
name
=
=
"
first
-
contentful
-
paint
"
&
&
perfEntries
[
1
]
.
startTime
!
=
undefined
)
{
result
=
perfEntries
[
1
]
.
startTime
;
}
}
}
if
(
result
>
0
)
{
console
.
log
(
"
got
time
to
first
-
contentful
-
paint
"
)
;
if
(
typeof
(
browser
)
!
=
=
"
undefined
"
)
{
var
startTime
=
perfData
.
timing
.
fetchStart
;
result
=
result
-
startTime
;
}
sendResult
(
resultType
result
)
;
perfData
.
clearMarks
(
)
;
perfData
.
clearMeasures
(
)
;
}
else
{
gRetryCounter
+
=
1
;
if
(
gRetryCounter
<
=
10
)
{
console
.
log
(
"
\
ntime
to
first
-
contentful
-
paint
is
not
yet
available
(
0
)
retry
number
"
+
gRetryCounter
+
"
.
.
.
\
n
"
)
;
window
.
setTimeout
(
measureFCP
100
)
;
}
else
{
console
.
log
(
"
\
nunable
to
get
a
value
for
time
-
to
-
fcp
after
"
+
gRetryCounter
+
"
retries
\
n
"
)
;
}
}
}
function
measureLoadTime
(
)
{
var
x
=
window
.
performance
.
timing
.
loadEventStart
;
if
(
typeof
(
x
)
=
=
"
undefined
"
)
{
console
.
log
(
"
ERROR
:
loadEventStart
is
undefined
"
)
;
return
;
}
if
(
x
>
0
)
{
console
.
log
(
"
got
loadEventStart
:
"
+
x
)
;
gRetryCounter
=
0
;
var
startTime
=
perfData
.
timing
.
fetchStart
;
sendResult
(
"
loadtime
"
x
-
startTime
)
;
}
else
{
gRetryCounter
+
=
1
;
if
(
gRetryCounter
<
=
40
*
(
1000
/
200
)
)
{
console
.
log
(
"
\
loadEventStart
is
not
yet
available
(
0
)
retry
number
"
+
gRetryCounter
+
"
.
.
.
\
n
"
)
;
window
.
setTimeout
(
measureLoadTime
100
)
;
}
else
{
console
.
log
(
"
\
nunable
to
get
a
value
for
loadEventStart
after
"
+
gRetryCounter
+
"
retries
\
n
"
)
;
}
}
}
function
sendResult
(
_type
_value
)
{
console
.
log
(
"
sending
result
back
to
runner
:
"
+
_type
+
"
"
+
_value
)
;
chrome
.
runtime
.
sendMessage
(
{
"
type
"
:
_type
"
value
"
:
_value
}
function
(
response
)
{
if
(
response
!
=
=
undefined
)
{
console
.
log
(
response
.
text
)
;
}
}
)
;
}
window
.
onload
=
contentHandler
(
)
;
