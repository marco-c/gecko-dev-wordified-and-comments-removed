"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TestUtils
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
clearTimeout
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
ConsoleAPIStorage
=
Cc
[
"
mozilla
.
org
/
consoleAPI
-
storage
;
1
"
]
.
getService
(
Ci
.
nsIConsoleAPIStorage
)
;
var
TestUtils
=
{
executeSoon
(
callbackFn
)
{
Services
.
tm
.
dispatchToMainThread
(
callbackFn
)
;
}
waitForTick
(
)
{
return
new
Promise
(
resolve
=
>
this
.
executeSoon
(
resolve
)
)
;
}
consoleMessageObserved
(
checkFn
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
removed
=
false
;
function
observe
(
message
)
{
try
{
if
(
checkFn
&
&
!
checkFn
(
message
)
)
{
return
;
}
ConsoleAPIStorage
.
removeLogEventListener
(
observe
)
;
checkFn
=
null
;
removed
=
true
;
resolve
(
message
)
;
}
catch
(
ex
)
{
ConsoleAPIStorage
.
removeLogEventListener
(
observe
)
;
checkFn
=
null
;
removed
=
true
;
reject
(
ex
)
;
}
}
ConsoleAPIStorage
.
addLogEventListener
(
observe
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
)
;
TestUtils
.
promiseTestFinished
?
.
then
(
(
)
=
>
{
if
(
removed
)
{
return
;
}
ConsoleAPIStorage
.
removeLogEventListener
(
observe
)
;
let
text
=
"
Console
message
observer
not
removed
before
the
end
of
test
"
;
reject
(
text
)
;
}
)
;
}
)
;
}
topicObserved
(
topic
checkFn
)
{
let
startTime
=
Cu
.
now
(
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
removed
=
false
;
function
observer
(
subject
topic
data
)
{
try
{
if
(
checkFn
&
&
!
checkFn
(
subject
data
)
)
{
return
;
}
Services
.
obs
.
removeObserver
(
observer
topic
)
;
checkFn
=
null
;
removed
=
true
;
ChromeUtils
.
addProfilerMarker
(
"
TestUtils
"
{
startTime
category
:
"
Test
"
}
"
topicObserved
:
"
+
topic
)
;
resolve
(
[
subject
data
]
)
;
}
catch
(
ex
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
checkFn
=
null
;
removed
=
true
;
reject
(
ex
)
;
}
}
Services
.
obs
.
addObserver
(
observer
topic
)
;
TestUtils
.
promiseTestFinished
?
.
then
(
(
)
=
>
{
if
(
removed
)
{
return
;
}
Services
.
obs
.
removeObserver
(
observer
topic
)
;
let
text
=
topic
+
"
observer
not
removed
before
the
end
of
test
"
;
reject
(
text
)
;
ChromeUtils
.
addProfilerMarker
(
"
TestUtils
"
{
startTime
category
:
"
Test
"
}
"
topicObserved
:
"
+
text
)
;
}
)
;
}
)
;
}
waitForPrefChange
(
prefName
checkFn
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
Services
.
prefs
.
addObserver
(
prefName
function
observer
(
subject
topic
data
)
{
try
{
let
prefValue
=
null
;
switch
(
Services
.
prefs
.
getPrefType
(
prefName
)
)
{
case
Services
.
prefs
.
PREF_STRING
:
prefValue
=
Services
.
prefs
.
getStringPref
(
prefName
)
;
break
;
case
Services
.
prefs
.
PREF_INT
:
prefValue
=
Services
.
prefs
.
getIntPref
(
prefName
)
;
break
;
case
Services
.
prefs
.
PREF_BOOL
:
prefValue
=
Services
.
prefs
.
getBoolPref
(
prefName
)
;
break
;
}
if
(
checkFn
&
&
!
checkFn
(
prefValue
)
)
{
return
;
}
Services
.
prefs
.
removeObserver
(
prefName
observer
)
;
resolve
(
prefValue
)
;
}
catch
(
ex
)
{
Services
.
prefs
.
removeObserver
(
prefName
observer
)
;
reject
(
ex
)
;
}
}
)
;
}
)
;
}
screenshotArea
(
eltOrRect
win
)
{
if
(
Element
.
isInstance
(
eltOrRect
)
)
{
eltOrRect
=
eltOrRect
.
getBoundingClientRect
(
)
;
}
let
{
left
top
width
height
}
=
eltOrRect
;
let
canvas
=
win
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
let
ratio
=
win
.
devicePixelRatio
;
canvas
.
width
=
width
*
ratio
;
canvas
.
height
=
height
*
ratio
;
ctx
.
scale
(
ratio
ratio
)
;
ctx
.
drawWindow
(
win
left
top
width
height
"
#
fff
"
)
;
return
canvas
.
toDataURL
(
)
;
}
waitForCondition
(
condition
msg
interval
=
100
maxTries
=
50
)
{
let
startTime
=
Cu
.
now
(
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
tries
=
0
;
let
timeoutId
=
0
;
async
function
tryOnce
(
)
{
timeoutId
=
0
;
if
(
tries
>
=
maxTries
)
{
msg
+
=
-
timed
out
after
{
maxTries
}
tries
.
;
ChromeUtils
.
addProfilerMarker
(
"
TestUtils
"
{
startTime
category
:
"
Test
"
}
waitForCondition
-
{
msg
}
)
;
condition
=
null
;
reject
(
msg
)
;
return
;
}
let
conditionPassed
=
false
;
try
{
conditionPassed
=
await
condition
(
)
;
}
catch
(
e
)
{
ChromeUtils
.
addProfilerMarker
(
"
TestUtils
"
{
startTime
category
:
"
Test
"
}
waitForCondition
-
{
msg
}
)
;
msg
+
=
-
threw
exception
:
{
e
}
;
condition
=
null
;
reject
(
msg
)
;
return
;
}
if
(
conditionPassed
)
{
ChromeUtils
.
addProfilerMarker
(
"
TestUtils
"
{
startTime
category
:
"
Test
"
}
waitForCondition
succeeded
after
{
tries
}
retries
-
{
msg
}
)
;
condition
=
null
;
resolve
(
conditionPassed
)
;
return
;
}
tries
+
+
;
timeoutId
=
setTimeout
(
tryOnce
interval
)
;
}
TestUtils
.
promiseTestFinished
?
.
then
(
(
)
=
>
{
if
(
!
timeoutId
)
{
return
;
}
clearTimeout
(
timeoutId
)
;
msg
+
=
"
-
still
pending
at
the
end
of
the
test
"
;
ChromeUtils
.
addProfilerMarker
(
"
TestUtils
"
{
startTime
category
:
"
Test
"
}
waitForCondition
-
{
msg
}
)
;
reject
(
"
waitForCondition
timer
-
"
+
msg
)
;
}
)
;
TestUtils
.
executeSoon
(
tryOnce
)
;
}
)
;
}
shuffle
(
array
)
{
let
results
=
[
]
;
for
(
let
i
=
0
;
i
<
array
.
length
;
+
+
i
)
{
let
randomIndex
=
Math
.
floor
(
Math
.
random
(
)
*
(
i
+
1
)
)
;
results
[
i
]
=
results
[
randomIndex
]
;
results
[
randomIndex
]
=
array
[
i
]
;
}
return
results
;
}
}
;
