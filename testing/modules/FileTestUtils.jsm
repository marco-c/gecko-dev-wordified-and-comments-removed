"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
FileTestUtils
"
]
;
const
{
AsyncShutdown
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
const
{
DownloadPaths
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadPaths
.
jsm
"
)
;
const
{
FileUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Assert
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Assert
.
jsm
"
)
;
let
gFileCounter
=
1
;
let
gPathsToRemove
=
[
]
;
var
FileTestUtils
=
{
getTempFile
(
suggestedName
=
"
test
.
dat
"
)
{
let
[
base
ext
]
=
DownloadPaths
.
splitBaseNameAndExtension
(
suggestedName
)
;
let
leafName
=
base
+
"
-
"
+
gFileCounter
+
ext
;
gFileCounter
+
+
;
let
file
=
this
.
_globalTemporaryDirectory
.
clone
(
)
;
file
.
append
(
leafName
)
;
Assert
.
ok
(
!
file
.
exists
(
)
"
Sanity
check
the
temporary
file
doesn
'
t
exist
.
"
)
;
gPathsToRemove
.
push
(
file
.
path
)
;
return
file
;
}
async
tolerantRemove
(
path
isDir
)
{
try
{
if
(
isDir
=
=
=
undefined
)
{
isDir
=
(
await
OS
.
File
.
stat
(
path
)
)
.
isDir
;
}
if
(
isDir
)
{
await
OS
.
File
.
removeDir
(
path
)
;
}
else
{
await
OS
.
File
.
remove
(
path
)
;
}
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
OS
.
File
.
Error
)
|
|
!
(
ex
.
becauseNoSuchFile
|
|
ex
.
becauseAccessDenied
)
)
{
throw
ex
;
}
}
}
}
;
XPCOMUtils
.
defineLazyGetter
(
FileTestUtils
"
_globalTemporaryDirectory
"
function
(
)
{
let
randomNumber
=
Math
.
floor
(
Math
.
random
(
)
*
1000000
)
;
let
dir
=
FileUtils
.
getFile
(
"
TmpD
"
[
"
testdir
-
"
+
randomNumber
]
)
;
dir
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
Removing
test
files
"
async
(
)
=
>
{
for
(
let
path
of
gPathsToRemove
)
{
await
this
.
tolerantRemove
(
path
)
;
}
if
(
!
(
await
OS
.
File
.
exists
(
dir
.
path
)
)
)
{
return
;
}
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
dir
.
path
)
;
try
{
await
iterator
.
forEach
(
entry
=
>
this
.
tolerantRemove
(
entry
.
path
entry
.
isDir
)
)
;
}
finally
{
iterator
.
close
(
)
;
}
await
OS
.
File
.
removeEmptyDir
(
dir
.
path
)
;
}
)
;
return
dir
;
}
)
;
