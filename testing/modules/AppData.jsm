"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
makeFakeAppDir
"
]
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
Promise
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
gFakeAppDirectoryProvider
;
var
makeFakeAppDir
=
function
(
)
{
let
dirMode
=
OS
.
Constants
.
libc
.
S_IRWXU
;
let
baseFile
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
let
appD
=
baseFile
.
clone
(
)
;
appD
.
append
(
"
UAppData
"
)
;
if
(
gFakeAppDirectoryProvider
)
{
return
Promise
.
resolve
(
appD
.
path
)
;
}
function
makeDir
(
f
)
{
if
(
f
.
exists
(
)
)
{
return
;
}
dump
(
"
Creating
directory
:
"
+
f
.
path
+
"
\
n
"
)
;
f
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
dirMode
)
;
}
makeDir
(
appD
)
;
let
reportsD
=
appD
.
clone
(
)
;
reportsD
.
append
(
"
Crash
Reports
"
)
;
let
pendingD
=
reportsD
.
clone
(
)
;
pendingD
.
append
(
"
pending
"
)
;
let
submittedD
=
reportsD
.
clone
(
)
;
submittedD
.
append
(
"
submitted
"
)
;
makeDir
(
reportsD
)
;
makeDir
(
pendingD
)
;
makeDir
(
submittedD
)
;
let
provider
=
{
getFile
(
prop
persistent
)
{
persistent
.
value
=
true
;
if
(
prop
=
=
"
UAppData
"
)
{
return
appD
.
clone
(
)
;
}
throw
Cr
.
NS_ERROR_FAILURE
;
}
QueryInterace
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIDirectoryServiceProvider
)
|
|
iid
.
equals
(
Ci
.
nsISupports
)
)
{
return
this
;
}
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
}
;
Services
.
dirsvc
.
registerProvider
(
provider
)
;
try
{
Services
.
dirsvc
.
undefine
(
"
UAppData
"
)
;
}
catch
(
ex
)
{
}
gFakeAppDirectoryProvider
=
provider
;
dump
(
"
Successfully
installed
fake
UAppDir
\
n
"
)
;
return
Promise
.
resolve
(
appD
.
path
)
;
}
;
