import
pprint
from
datetime
import
datetime
from
marionette_driver
import
Wait
from
firefox_puppeteer
.
api
.
prefs
import
Preferences
from
firefox_puppeteer
.
api
.
software_update
import
SoftwareUpdate
from
firefox_puppeteer
.
testcases
import
FirefoxTestCase
from
firefox_puppeteer
.
ui
.
update_wizard
import
UpdateWizardDialog
class
UpdateTestCase
(
FirefoxTestCase
)
:
    
TIMEOUT_UPDATE_APPLY
=
300
    
TIMEOUT_UPDATE_CHECK
=
30
    
TIMEOUT_UPDATE_DOWNLOAD
=
360
    
PREF_APP_UPDATE_ALTWINDOWTYPE
=
'
app
.
update
.
altwindowtype
'
    
def
__init__
(
self
*
args
*
*
kwargs
)
:
        
FirefoxTestCase
.
__init__
(
self
*
args
*
*
kwargs
)
        
self
.
target_buildid
=
kwargs
.
pop
(
'
update_target_buildid
'
)
        
self
.
target_version
=
kwargs
.
pop
(
'
update_target_version
'
)
        
self
.
update_channel
=
kwargs
.
pop
(
'
update_channel
'
)
        
self
.
default_update_channel
=
None
        
self
.
update_mar_channels
=
set
(
kwargs
.
pop
(
'
update_mar_channels
'
)
)
        
self
.
default_mar_channels
=
None
        
self
.
updates
=
[
]
    
def
setUp
(
self
is_fallback
=
False
)
:
        
FirefoxTestCase
.
setUp
(
self
)
        
self
.
software_update
=
SoftwareUpdate
(
lambda
:
self
.
marionette
)
        
self
.
download_duration
=
None
        
self
.
current_update_index
=
0
        
self
.
staging_directory
=
self
.
software_update
.
staging_directory
        
if
self
.
update_channel
:
            
self
.
default_update_channel
=
{
                
'
content
'
:
self
.
software_update
.
update_channel
.
file_contents
                
'
path
'
:
self
.
software_update
.
update_channel
.
file_path
            
}
            
self
.
software_update
.
update_channel
.
default_channel
=
self
.
update_channel
        
if
self
.
update_mar_channels
:
            
self
.
default_mar_channels
=
{
                
'
content
'
:
self
.
software_update
.
mar_channels
.
config_file_contents
                
'
path
'
:
self
.
software_update
.
mar_channels
.
config_file_path
            
}
            
self
.
software_update
.
mar_channels
.
add_channels
(
self
.
update_mar_channels
)
        
self
.
restart
(
)
        
self
.
updates
=
[
{
            
'
build_pre
'
:
self
.
software_update
.
build_info
            
'
build_post
'
:
None
            
'
fallback
'
:
is_fallback
            
'
patch
'
:
{
}
            
'
success
'
:
False
        
}
]
        
self
.
assertEqual
(
self
.
software_update
.
update_channel
.
default_channel
                         
self
.
software_update
.
update_channel
.
channel
)
        
self
.
assertTrue
(
self
.
update_mar_channels
.
issubset
(
                        
self
.
software_update
.
mar_channels
.
channels
)
                        
'
Allowed
MAR
channels
have
been
set
:
expected
"
{
}
"
in
"
{
}
"
'
.
format
(
                            
'
'
.
join
(
self
.
update_mar_channels
)
                            
'
'
.
join
(
self
.
software_update
.
mar_channels
.
channels
)
)
)
        
self
.
assertTrue
(
self
.
software_update
.
allowed
                        
'
Current
user
has
permissions
to
update
the
application
.
'
)
    
def
tearDown
(
self
)
:
        
try
:
            
self
.
browser
.
tabbar
.
close_all_tabs
(
[
self
.
browser
.
tabbar
.
selected_tab
]
)
            
output
=
pprint
.
pformat
(
self
.
updates
)
            
self
.
logger
.
info
(
'
Update
test
results
:
\
n
{
}
'
.
format
(
output
)
)
        
finally
:
            
FirefoxTestCase
.
tearDown
(
self
)
            
self
.
restore_config_files
(
)
    
property
    
def
patch_info
(
self
)
:
        
"
"
"
Returns
information
about
the
active
update
in
the
queue
.
        
:
returns
:
A
dictionary
with
information
about
the
active
patch
        
"
"
"
        
patch
=
self
.
software_update
.
patch_info
        
patch
[
'
download_duration
'
]
=
self
.
download_duration
        
return
patch
    
def
check_for_updates
(
self
about_window
timeout
=
TIMEOUT_UPDATE_CHECK
)
:
        
"
"
"
Clicks
on
"
Check
for
Updates
"
button
and
waits
for
check
to
complete
.
        
:
param
about_window
:
Instance
of
:
class
:
AboutWindow
.
        
:
param
timeout
:
How
long
to
wait
for
the
update
check
to
finish
.
Optional
         
defaults
to
60s
.
        
:
returns
:
True
if
an
update
is
available
.
        
"
"
"
        
self
.
assertEqual
(
about_window
.
deck
.
selected_panel
                         
about_window
.
deck
.
check_for_updates
)
        
about_window
.
deck
.
check_for_updates
.
button
.
click
(
)
        
Wait
(
self
.
marionette
timeout
=
self
.
TIMEOUT_UPDATE_CHECK
)
.
until
(
            
lambda
_
:
about_window
.
deck
.
selected_panel
not
in
            
(
about_window
.
deck
.
check_for_updates
about_window
.
deck
.
checking_for_updates
)
            
message
=
'
Check
for
updates
has
been
finished
.
'
)
        
return
about_window
.
deck
.
selected_panel
!
=
about_window
.
deck
.
no_updates_found
    
def
check_update_applied
(
self
)
:
        
self
.
updates
[
self
.
current_update_index
]
[
'
build_post
'
]
=
self
.
software_update
.
build_info
        
about_window
=
self
.
browser
.
open_about_window
(
)
        
try
:
            
update_available
=
self
.
check_for_updates
(
about_window
)
            
if
update_available
:
                
self
.
download_update
(
about_window
wait_for_finish
=
False
)
                
self
.
assertNotEqual
(
self
.
software_update
.
active_update
.
type
                                    
self
.
updates
[
self
.
current_update_index
]
.
type
)
            
update
=
self
.
updates
[
self
.
current_update_index
]
            
check
=
self
.
marionette
.
execute_script
(
"
"
"
              
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
              
return
Services
.
vc
.
compare
(
arguments
[
0
]
arguments
[
1
]
)
;
            
"
"
"
script_args
=
[
update
[
'
build_post
'
]
[
'
version
'
]
update
[
'
build_pre
'
]
[
'
version
'
]
]
)
            
self
.
assertGreaterEqual
(
check
0
                                    
'
The
version
of
the
upgraded
build
is
higher
or
equal
'
)
            
if
self
.
target_version
:
                
self
.
assertEqual
(
update
[
'
build_post
'
]
[
'
version
'
]
self
.
target_version
)
            
self
.
assertEqual
(
update
[
'
build_post
'
]
[
'
buildid
'
]
update
[
'
patch
'
]
[
'
buildid
'
]
)
            
if
self
.
target_buildid
:
                
self
.
assertEqual
(
update
[
'
build_post
'
]
[
'
buildid
'
]
self
.
target_buildid
)
            
self
.
assertEqual
(
update
[
'
build_post
'
]
[
'
locale
'
]
update
[
'
build_pre
'
]
[
'
locale
'
]
)
            
self
.
assertEqual
(
update
[
'
build_post
'
]
[
'
disabled_addons
'
]
                             
update
[
'
build_pre
'
]
[
'
disabled_addons
'
]
)
            
update
[
'
success
'
]
=
True
        
finally
:
            
about_window
.
close
(
)
    
def
download_update
(
self
window
wait_for_finish
=
True
timeout
=
TIMEOUT_UPDATE_DOWNLOAD
)
:
        
"
"
"
Download
the
update
patch
.
        
:
param
window
:
Instance
of
:
class
:
AboutWindow
or
:
class
:
UpdateWizardDialog
.
        
:
param
wait_for_finish
:
If
True
the
function
has
to
wait
for
the
download
to
be
finished
.
         
Optional
default
to
True
.
        
:
param
timeout
:
How
long
to
wait
for
the
download
to
finish
.
Optional
default
to
360s
.
        
"
"
"
        
def
download_via_update_wizard
(
dialog
)
:
            
"
"
"
Download
the
update
via
the
old
update
wizard
dialog
.
            
:
param
dialog
:
Instance
of
:
class
:
UpdateWizardDialog
.
            
"
"
"
            
prefs
=
Preferences
(
lambda
:
self
.
marionette
)
            
prefs
.
set_pref
(
self
.
PREF_APP_UPDATE_ALTWINDOWTYPE
dialog
.
window_type
)
            
try
:
                
if
dialog
.
wizard
.
selected_panel
in
[
dialog
.
wizard
.
updates_found_basic
                                                    
dialog
.
wizard
.
updates_found_billboard
                                                    
dialog
.
wizard
.
error_patching
                                                    
]
:
                    
dialog
.
select_next_page
(
)
                
if
dialog
.
wizard
.
selected_panel
=
=
dialog
.
wizard
.
incompatible_list
:
                    
dialog
.
select_next_page
(
)
                
if
dialog
.
wizard
.
selected_panel
in
[
dialog
.
wizard
.
finished
                                                    
dialog
.
wizard
.
finished_background
                                                    
]
:
                    
pass
                
elif
dialog
.
wizard
.
selected_panel
=
=
dialog
.
wizard
.
downloading
:
                    
if
wait_for_finish
:
                        
start_time
=
datetime
.
now
(
)
                        
self
.
wait_for_download_finished
(
dialog
timeout
)
                        
self
.
download_duration
=
(
datetime
.
now
(
)
-
start_time
)
.
total_seconds
(
)
                        
Wait
(
self
.
marionette
)
.
until
(
lambda
_
:
(
                            
dialog
.
wizard
.
selected_panel
in
[
dialog
.
wizard
.
finished
                                                             
dialog
.
wizard
.
finished_background
                                                             
]
)
                                                    
message
=
'
Final
wizard
page
has
been
selected
.
'
)
                
else
:
                    
raise
Exception
(
'
Invalid
wizard
page
for
downloading
an
update
:
{
}
'
.
format
(
                                    
dialog
.
wizard
.
selected_panel
)
)
            
finally
:
                
prefs
.
restore_pref
(
self
.
PREF_APP_UPDATE_ALTWINDOWTYPE
)
        
if
isinstance
(
window
UpdateWizardDialog
)
:
            
download_via_update_wizard
(
window
)
            
return
        
if
window
.
deck
.
selected_panel
=
=
window
.
deck
.
download_and_install
:
            
window
.
deck
.
download_and_install
.
button
.
click
(
)
            
Wait
(
self
.
marionette
)
.
until
(
lambda
_
:
(
                
window
.
deck
.
selected_panel
!
=
window
.
deck
.
download_and_install
)
)
        
if
window
.
deck
.
selected_panel
=
=
window
.
deck
.
apply_billboard
:
            
dialog
=
self
.
browser
.
open_window
(
                
callback
=
lambda
_
:
window
.
deck
.
update_button
.
click
(
)
                
expected_window_class
=
UpdateWizardDialog
            
)
            
Wait
(
self
.
marionette
)
.
until
(
                
lambda
_
:
dialog
.
wizard
.
selected_panel
=
=
dialog
.
wizard
.
updates_found_basic
)
            
download_via_update_wizard
(
dialog
)
            
dialog
.
close
(
)
            
return
        
if
wait_for_finish
:
            
start_time
=
datetime
.
now
(
)
            
self
.
wait_for_download_finished
(
window
timeout
)
            
self
.
download_duration
=
(
datetime
.
now
(
)
-
start_time
)
.
total_seconds
(
)
    
def
download_and_apply_available_update
(
self
force_fallback
=
False
)
:
        
"
"
"
Checks
downloads
and
applies
an
available
update
.
        
:
param
force_fallback
:
Optional
if
True
invalidate
current
update
status
.
         
Defaults
to
False
.
        
"
"
"
        
about_window
=
self
.
browser
.
open_about_window
(
)
        
try
:
            
update_available
=
self
.
check_for_updates
(
about_window
)
            
self
.
assertTrue
(
update_available
                            
"
Available
update
has
been
found
"
)
            
self
.
download_update
(
about_window
)
            
self
.
wait_for_update_applied
(
about_window
)
        
finally
:
            
self
.
updates
[
self
.
current_update_index
]
[
'
patch
'
]
=
self
.
patch_info
        
if
force_fallback
:
            
self
.
software_update
.
force_fallback
(
)
        
self
.
restart
(
)
    
def
download_and_apply_forced_update
(
self
)
:
        
dialog
=
self
.
windows
.
switch_to
(
lambda
win
:
type
(
win
)
is
UpdateWizardDialog
)
        
if
self
.
updates
[
self
.
current_update_index
]
[
'
patch
'
]
[
'
is_complete
'
]
:
            
about_window
=
None
            
try
:
                
self
.
assertEqual
(
dialog
.
wizard
.
selected_panel
                                 
dialog
.
wizard
.
error
)
                
dialog
.
close
(
)
                
about_window
=
self
.
browser
.
open_about_window
(
)
                
update_available
=
self
.
check_for_updates
(
about_window
)
                
self
.
assertTrue
(
update_available
                                
'
Available
update
has
been
found
'
)
                
self
.
download_update
(
about_window
)
                
self
.
wait_for_update_applied
(
about_window
)
            
finally
:
                
if
about_window
:
                    
self
.
updates
[
self
.
current_update_index
]
[
'
patch
'
]
=
self
.
patch_info
        
else
:
            
try
:
                
self
.
assertEqual
(
dialog
.
wizard
.
selected_panel
                                 
dialog
.
wizard
.
error_patching
)
                
self
.
download_update
(
dialog
)
                
dialog
.
close
(
)
            
finally
:
                
self
.
updates
[
self
.
current_update_index
]
[
'
patch
'
]
=
self
.
patch_info
        
self
.
restart
(
)
    
def
restore_config_files
(
self
)
:
        
try
:
            
if
self
.
default_update_channel
:
                
path
=
self
.
default_update_channel
[
'
path
'
]
                
self
.
logger
.
info
(
'
Restoring
channel
defaults
for
:
{
}
'
.
format
(
path
)
)
                
with
open
(
path
'
w
'
)
as
f
:
                    
f
.
write
(
self
.
default_update_channel
[
'
content
'
]
)
        
except
IOError
:
            
self
.
logger
.
error
(
'
Failed
to
reset
the
default
update
channel
.
'
                              
exc_info
=
True
)
        
try
:
            
if
self
.
default_mar_channels
:
                
path
=
self
.
default_mar_channels
[
'
path
'
]
                
self
.
logger
.
info
(
'
Restoring
mar
channel
defaults
for
:
{
}
'
.
format
(
path
)
)
                
with
open
(
path
'
w
'
)
as
f
:
                    
f
.
write
(
self
.
default_mar_channels
[
'
content
'
]
)
        
except
IOError
:
            
self
.
logger
.
error
(
'
Failed
to
reset
the
default
mar
channels
.
'
                              
exc_info
=
True
)
    
def
wait_for_download_finished
(
self
window
timeout
=
TIMEOUT_UPDATE_DOWNLOAD
)
:
        
"
"
"
Waits
until
download
is
completed
.
        
:
param
window
:
Instance
of
:
class
:
AboutWindow
or
:
class
:
UpdateWizardDialog
.
        
:
param
timeout
:
How
long
to
wait
for
the
download
to
finish
.
Optional
         
default
to
360
seconds
.
        
"
"
"
        
if
isinstance
(
window
UpdateWizardDialog
)
:
            
Wait
(
self
.
marionette
timeout
=
timeout
)
.
until
(
                
lambda
_
:
window
.
wizard
.
selected_panel
!
=
window
.
wizard
.
downloading
                
message
=
'
Download
has
been
completed
.
'
)
            
self
.
assertNotIn
(
window
.
wizard
.
selected_panel
                             
[
window
.
wizard
.
error
window
.
wizard
.
error_extra
]
)
            
return
        
Wait
(
self
.
marionette
timeout
=
timeout
)
.
until
(
            
lambda
_
:
window
.
deck
.
selected_panel
not
in
            
(
window
.
deck
.
download_and_install
window
.
deck
.
downloading
)
            
message
=
'
Download
has
been
completed
.
'
)
        
self
.
assertNotEqual
(
window
.
deck
.
selected_panel
                            
window
.
deck
.
download_failed
)
    
def
wait_for_update_applied
(
self
about_window
timeout
=
TIMEOUT_UPDATE_APPLY
)
:
        
"
"
"
Waits
until
the
downloaded
update
has
been
applied
.
        
:
param
about_window
:
Instance
of
:
class
:
AboutWindow
.
        
:
param
timeout
:
How
long
to
wait
for
the
update
to
apply
.
Optional
         
default
to
300
seconds
        
"
"
"
        
Wait
(
self
.
marionette
timeout
=
timeout
)
.
until
(
            
lambda
_
:
about_window
.
deck
.
selected_panel
=
=
about_window
.
deck
.
apply
            
message
=
'
Final
wizard
page
has
been
selected
.
'
)
        
Wait
(
self
.
marionette
timeout
=
timeout
)
.
until
(
            
lambda
_
:
'
applied
'
in
self
.
software_update
.
active_update
.
state
            
message
=
'
Update
has
been
applied
.
'
)
