var
tags
=
[
"
A
"
"
ABBR
"
"
ACRONYM
"
"
ADDRESS
"
"
APPLET
"
"
AREA
"
"
B
"
"
BASE
"
"
BASEFONT
"
"
BDO
"
"
BIG
"
"
BLOCKQUOTE
"
"
BODY
"
"
BR
"
"
BUTTON
"
"
CAPTION
"
"
CENTER
"
"
CITE
"
"
CODE
"
"
COL
"
"
COLGROUP
"
"
DD
"
"
DEL
"
"
DFN
"
"
DIR
"
"
DIV
"
"
DL
"
"
DT
"
"
EM
"
"
FIELDSET
"
"
FONT
"
"
FORM
"
"
FRAME
"
"
FRAMESET
"
"
H1
"
"
H2
"
"
H3
"
"
H4
"
"
H5
"
"
H6
"
"
HEAD
"
"
HR
"
"
HTML
"
"
I
"
"
IFRAME
"
"
IMG
"
"
INPUT
"
"
INS
"
"
ISINDEX
"
"
KBD
"
"
LABEL
"
"
LEGEND
"
"
LI
"
"
LINK
"
"
MAP
"
"
MENU
"
"
META
"
"
NOFRAMES
"
"
NOSCRIPT
"
"
OBJECT
"
"
OL
"
"
OPTGROUP
"
"
OPTION
"
"
P
"
"
PARAM
"
"
PRE
"
"
Q
"
"
S
"
"
SAMP
"
"
SCRIPT
"
"
SELECT
"
"
SMALL
"
"
SPAN
"
"
STRIKE
"
"
STRONG
"
"
STYLE
"
"
SUB
"
"
SUP
"
"
TABLE
"
"
TBODY
"
"
TD
"
"
TEXTAREA
"
"
TFOOT
"
"
TH
"
"
THEAD
"
"
TITLE
"
"
TR
"
"
TT
"
"
U
"
"
UL
"
"
VAR
"
]
;
function
makeTagFunc
(
tagName
)
{
return
function
(
attrs
)
{
var
startChildren
=
0
;
var
response
=
"
"
;
response
+
=
"
<
"
+
tagName
;
if
(
attrs
&
&
typeof
attrs
=
=
"
object
"
)
{
startChildren
=
1
;
for
(
let
key
in
attrs
)
{
const
value
=
attrs
[
key
]
;
var
val
=
"
"
+
value
;
response
+
=
"
"
+
key
+
'
=
"
'
+
val
.
replace
(
'
"
'
"
&
quot
;
"
)
+
'
"
'
;
}
}
response
+
=
"
>
"
;
for
(
var
i
=
startChildren
;
i
<
arguments
.
length
;
i
+
+
)
{
if
(
typeof
arguments
[
i
]
=
=
"
function
"
)
{
response
+
=
arguments
[
i
]
(
)
;
}
else
{
response
+
=
arguments
[
i
]
;
}
}
response
+
=
"
<
/
"
+
tagName
+
"
>
\
n
"
;
return
response
;
}
;
}
function
makeTags
(
)
{
for
(
let
tag
of
tags
)
{
this
[
tag
]
=
makeTagFunc
(
tag
.
toLowerCase
(
)
)
;
}
}
function
*
dirIter
(
dir
)
{
var
en
=
dir
.
directoryEntries
;
while
(
en
.
hasMoreElements
(
)
)
{
yield
en
.
nextFile
;
}
}
function
list
(
requestPath
directory
recurse
)
{
var
count
=
0
;
var
path
=
requestPath
;
if
(
path
.
charAt
(
path
.
length
-
1
)
!
=
"
/
"
)
{
path
+
=
"
/
"
;
}
var
dir
=
directory
.
QueryInterface
(
Ci
.
nsIFile
)
;
var
links
=
{
}
;
let
files
=
[
]
;
for
(
let
file
of
dirIter
(
dir
)
)
{
if
(
file
.
exists
(
)
&
&
!
file
.
path
.
includes
(
"
SimpleTest
"
)
)
{
files
.
push
(
file
)
;
}
}
function
leafNameComparator
(
first
second
)
{
if
(
first
.
leafName
<
second
.
leafName
)
{
return
-
1
;
}
if
(
first
.
leafName
>
second
.
leafName
)
{
return
1
;
}
return
0
;
}
files
.
sort
(
leafNameComparator
)
;
count
=
files
.
length
;
for
(
let
file
of
files
)
{
var
key
=
path
+
file
.
leafName
;
var
childCount
=
0
;
if
(
file
.
isDirectory
(
)
)
{
key
+
=
"
/
"
;
}
if
(
recurse
&
&
file
.
isDirectory
(
)
)
{
[
links
[
key
]
childCount
]
=
list
(
key
file
recurse
)
;
count
+
=
childCount
;
}
else
if
(
file
.
leafName
.
charAt
(
0
)
!
=
"
.
"
)
{
links
[
key
]
=
{
test
:
{
url
:
key
expected
:
"
pass
"
}
}
;
}
}
return
[
links
count
]
;
}
function
isTest
(
filename
pattern
)
{
if
(
pattern
)
{
return
pattern
.
test
(
filename
)
;
}
var
testPrefix
=
typeof
_TEST_PREFIX
=
=
"
string
"
?
_TEST_PREFIX
:
"
test_
"
;
var
testPattern
=
new
RegExp
(
"
^
"
+
testPrefix
)
;
var
pathPieces
=
filename
.
split
(
"
/
"
)
;
return
(
testPattern
.
test
(
pathPieces
[
pathPieces
.
length
-
1
]
)
&
&
!
filename
.
includes
(
"
.
js
"
)
&
&
!
filename
.
includes
(
"
.
css
"
)
&
&
!
/
\
^
headers
\
^
/
.
test
(
filename
)
)
;
}
function
linksToListItems
(
links
)
{
var
response
=
"
"
;
var
children
=
"
"
;
for
(
let
link
in
links
)
{
const
value
=
links
[
link
]
;
var
classVal
=
!
isTest
(
link
)
&
&
!
(
value
instanceof
Object
)
?
"
non
-
test
invisible
"
:
"
test
"
;
if
(
value
instanceof
Object
)
{
children
=
UL
(
{
class
:
"
testdir
"
}
linksToListItems
(
value
)
)
;
}
else
{
children
=
"
"
;
}
var
bug_title
=
link
.
match
(
/
test_bug
\
S
+
/
)
;
var
bug_num
=
null
;
if
(
bug_title
!
=
null
)
{
bug_num
=
bug_title
[
0
]
.
match
(
/
\
d
+
/
)
;
}
if
(
bug_title
=
=
null
|
|
bug_num
=
=
null
)
{
response
+
=
LI
(
{
class
:
classVal
}
A
(
{
href
:
link
}
link
)
children
)
;
}
else
{
var
bug_url
=
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
"
+
bug_num
;
response
+
=
LI
(
{
class
:
classVal
}
A
(
{
href
:
link
}
link
)
"
-
"
A
(
{
href
:
bug_url
}
"
Bug
"
+
bug_num
)
children
)
;
}
}
return
response
;
}
function
linksToTableRows
(
links
recursionLevel
)
{
var
response
=
"
"
;
for
(
let
link
in
links
)
{
const
value
=
links
[
link
]
;
var
classVal
=
!
isTest
(
link
)
&
&
value
instanceof
Object
&
&
"
test
"
in
value
?
"
non
-
test
invisible
"
:
"
"
;
var
spacer
=
"
padding
-
left
:
"
+
10
*
recursionLevel
+
"
px
"
;
if
(
value
instanceof
Object
&
&
!
(
"
test
"
in
value
)
)
{
response
+
=
TR
(
{
class
:
"
dir
"
id
:
"
tr
-
"
+
link
}
TD
(
{
colspan
:
"
3
"
}
"
&
#
160
;
"
)
TD
(
{
style
:
spacer
}
A
(
{
href
:
link
}
link
)
)
)
;
response
+
=
linksToTableRows
(
value
recursionLevel
+
1
)
;
}
else
{
var
bug_title
=
link
.
match
(
/
test_bug
\
S
+
/
)
;
var
bug_num
=
null
;
if
(
bug_title
!
=
null
)
{
bug_num
=
bug_title
[
0
]
.
match
(
/
\
d
+
/
)
;
}
if
(
bug_title
=
=
null
|
|
bug_num
=
=
null
)
{
response
+
=
TR
(
{
class
:
classVal
id
:
"
tr
-
"
+
link
}
TD
(
"
0
"
)
TD
(
"
0
"
)
TD
(
"
0
"
)
TD
(
{
style
:
spacer
}
A
(
{
href
:
link
}
link
)
)
)
;
}
else
{
var
bug_url
=
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
"
+
bug_num
;
response
+
=
TR
(
{
class
:
classVal
id
:
"
tr
-
"
+
link
}
TD
(
"
0
"
)
TD
(
"
0
"
)
TD
(
"
0
"
)
TD
(
{
style
:
spacer
}
A
(
{
href
:
link
}
link
)
"
-
"
A
(
{
href
:
bug_url
}
"
Bug
"
+
bug_num
)
)
)
;
}
}
}
return
response
;
}
function
arrayOfTestFiles
(
linkArray
fileArray
testPattern
)
{
for
(
let
link
in
linkArray
)
{
const
value
=
linkArray
[
link
]
;
if
(
value
instanceof
Object
&
&
!
(
"
test
"
in
value
)
)
{
arrayOfTestFiles
(
value
fileArray
testPattern
)
;
}
else
if
(
isTest
(
link
testPattern
)
&
&
value
instanceof
Object
)
{
fileArray
.
push
(
value
.
test
)
;
}
}
}
function
jsonArrayOfTestFiles
(
links
)
{
var
testFiles
=
[
]
;
arrayOfTestFiles
(
links
testFiles
)
;
testFiles
=
testFiles
.
map
(
function
(
file
)
{
return
'
"
'
+
file
.
url
+
'
"
'
;
}
)
;
return
"
[
"
+
testFiles
.
join
(
"
\
n
"
)
+
"
]
"
;
}
function
regularListing
(
metadata
response
)
{
var
[
links
]
=
list
(
metadata
.
path
metadata
.
getProperty
(
"
directory
"
)
false
)
;
response
.
write
(
HTML
(
HEAD
(
TITLE
(
"
mochitest
index
"
metadata
.
path
)
)
BODY
(
BR
(
)
A
(
{
href
:
"
.
.
"
}
"
Up
a
level
"
)
UL
(
linksToListItems
(
links
)
)
)
)
)
;
}
