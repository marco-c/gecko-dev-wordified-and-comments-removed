let
protocolHandler
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
let
httpdJSPath
=
PathUtils
.
toFileURI
(
_HTTPD_PATH
)
;
protocolHandler
.
setSubstitution
(
"
httpd
-
server
"
Services
.
io
.
newURI
(
httpdJSPath
)
)
;
const
{
HttpServer
dumpn
setDebuggingStatus
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
httpd
-
server
/
httpd
.
js
"
)
;
protocolHandler
.
setSubstitution
(
"
mochitest
-
server
"
Services
.
io
.
newFileURI
(
__LOCATION__
.
parent
)
)
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
mochitest
-
server
/
mochitestListingsUtils
.
js
"
this
)
;
const
CC
=
Components
.
Constructor
;
const
FileInputStream
=
CC
(
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
"
nsIFileInputStream
"
"
init
"
)
;
const
ConverterInputStream
=
CC
(
"
mozilla
.
org
/
intl
/
converter
-
input
-
stream
;
1
"
"
nsIConverterInputStream
"
"
init
"
)
;
var
ios
=
Cc
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIOService
)
;
ios
.
manageOfflineStatus
=
false
;
ios
.
offline
=
false
;
var
server
;
var
_quitting
=
false
;
function
serverStopped
(
)
{
_quitting
=
true
;
}
runServer
(
)
;
if
(
_quitting
)
{
dumpn
(
"
HTTP
server
stopped
all
pending
requests
complete
"
)
;
quit
(
0
)
;
}
dumpn
(
"
TEST
-
UNEXPECTED
-
FAIL
|
failure
to
correctly
shut
down
HTTP
server
"
)
;
quit
(
1
)
;
var
serverBasePath
;
var
displayResults
=
true
;
var
gServerAddress
;
var
SERVER_PORT
;
function
runServer
(
)
{
serverBasePath
=
__LOCATION__
.
parent
;
server
=
createMochitestServer
(
serverBasePath
)
;
if
(
typeof
_SERVER_ADDR
!
=
"
undefined
"
)
{
if
(
_SERVER_ADDR
=
=
"
localhost
"
)
{
gServerAddress
=
_SERVER_ADDR
;
}
else
{
var
quads
=
_SERVER_ADDR
.
split
(
"
.
"
)
;
if
(
quads
.
length
=
=
4
)
{
var
invalid
=
false
;
for
(
var
i
=
0
;
i
<
4
;
i
+
+
)
{
if
(
quads
[
i
]
<
0
|
|
quads
[
i
]
>
255
)
{
invalid
=
true
;
}
}
if
(
!
invalid
)
{
gServerAddress
=
_SERVER_ADDR
;
}
else
{
throw
new
Error
(
"
invalid
_SERVER_ADDR
please
specify
a
valid
IP
Address
"
)
;
}
}
}
}
else
{
throw
new
Error
(
"
please
define
_SERVER_ADDR
(
as
an
ip
address
)
before
running
server
.
js
"
)
;
}
if
(
typeof
_SERVER_PORT
!
=
"
undefined
"
)
{
if
(
parseInt
(
_SERVER_PORT
)
>
0
&
&
parseInt
(
_SERVER_PORT
)
<
65536
)
{
SERVER_PORT
=
_SERVER_PORT
;
}
}
else
{
throw
new
Error
(
"
please
define
_SERVER_PORT
(
as
a
port
number
)
before
running
server
.
js
"
)
;
}
if
(
typeof
_DISPLAY_RESULTS
!
=
"
undefined
"
)
{
displayResults
=
_DISPLAY_RESULTS
;
}
server
.
_start
(
SERVER_PORT
gServerAddress
)
;
var
foStream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
var
serverAlive
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
if
(
typeof
_PROFILE_PATH
=
=
"
undefined
"
)
{
serverAlive
.
initWithFile
(
serverBasePath
)
;
serverAlive
.
append
(
"
mochitesttestingprofile
"
)
;
}
else
{
serverAlive
.
initWithPath
(
_PROFILE_PATH
)
;
}
if
(
serverAlive
.
exists
(
)
)
{
serverAlive
.
append
(
"
server_alive
.
txt
"
)
;
foStream
.
init
(
serverAlive
0x02
|
0x08
|
0x20
436
0
)
;
var
data
=
"
It
'
s
alive
!
"
;
foStream
.
write
(
data
data
.
length
)
;
foStream
.
close
(
)
;
}
else
{
throw
new
Error
(
"
Failed
to
create
server_alive
.
txt
because
"
+
serverAlive
.
path
+
"
could
not
be
found
.
"
)
;
}
makeTags
(
)
;
var
thread
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
)
.
currentThread
;
while
(
!
server
.
isStopped
(
)
)
{
thread
.
processNextEvent
(
true
)
;
}
while
(
thread
.
hasPendingEvents
(
)
)
{
thread
.
processNextEvent
(
true
)
;
}
}
function
createMochitestServer
(
serverBasePath
)
{
var
server
=
new
HttpServer
(
)
;
server
.
registerDirectory
(
"
/
"
serverBasePath
)
;
server
.
registerPathHandler
(
"
/
server
/
shutdown
"
serverShutdown
)
;
server
.
registerPathHandler
(
"
/
server
/
debug
"
serverDebug
)
;
server
.
registerContentType
(
"
sjs
"
"
sjs
"
)
;
server
.
registerContentType
(
"
jar
"
"
application
/
x
-
jar
"
)
;
server
.
registerContentType
(
"
ogg
"
"
application
/
ogg
"
)
;
server
.
registerContentType
(
"
pdf
"
"
application
/
pdf
"
)
;
server
.
registerContentType
(
"
ogv
"
"
video
/
ogg
"
)
;
server
.
registerContentType
(
"
oga
"
"
audio
/
ogg
"
)
;
server
.
registerContentType
(
"
opus
"
"
audio
/
ogg
;
codecs
=
opus
"
)
;
server
.
registerContentType
(
"
dat
"
"
text
/
plain
;
charset
=
utf
-
8
"
)
;
server
.
registerContentType
(
"
frag
"
"
text
/
plain
"
)
;
server
.
registerContentType
(
"
vert
"
"
text
/
plain
"
)
;
server
.
registerContentType
(
"
wasm
"
"
application
/
wasm
"
)
;
server
.
setIndexHandler
(
defaultDirHandler
)
;
var
serverRoot
=
{
getFile
:
function
getFile
(
path
)
{
var
file
=
serverBasePath
.
clone
(
)
.
QueryInterface
(
Ci
.
nsIFile
)
;
path
.
split
(
"
/
"
)
.
forEach
(
function
(
p
)
{
file
.
appendRelativePath
(
p
)
;
}
)
;
return
file
;
}
QueryInterface
(
aIID
)
{
return
this
;
}
}
;
server
.
setObjectState
(
"
SERVER_ROOT
"
serverRoot
)
;
processLocations
(
server
)
;
return
server
;
}
function
processLocations
(
server
)
{
var
serverLocations
=
serverBasePath
.
clone
(
)
;
serverLocations
.
append
(
"
server
-
locations
.
txt
"
)
;
const
PR_RDONLY
=
0x01
;
var
fis
=
new
FileInputStream
(
serverLocations
PR_RDONLY
292
Ci
.
nsIFileInputStream
.
CLOSE_ON_EOF
)
;
var
lis
=
new
ConverterInputStream
(
fis
"
UTF
-
8
"
1024
0x0
)
;
lis
.
QueryInterface
(
Ci
.
nsIUnicharLineInputStream
)
;
const
LINE_REGEXP
=
new
RegExp
(
"
^
(
[
a
-
z
]
[
-
a
-
z0
-
9
+
.
]
*
)
"
+
"
:
/
/
"
+
"
(
"
+
"
\
\
d
+
\
\
.
\
\
d
+
\
\
.
\
\
d
+
\
\
.
\
\
d
+
"
+
"
|
"
+
"
(
?
:
[
a
-
z0
-
9
]
(
?
:
[
-
a
-
z0
-
9
]
*
[
a
-
z0
-
9
]
)
?
\
\
.
)
*
"
+
"
[
a
-
z
]
(
?
:
[
-
a
-
z0
-
9
]
*
[
a
-
z0
-
9
]
)
?
"
+
"
)
"
+
"
:
"
+
"
(
\
\
d
+
)
"
+
"
(
?
:
"
+
"
\
\
s
+
"
+
"
(
\
\
S
+
(
?
:
\
\
S
+
)
*
)
"
+
"
)
?
"
)
;
var
line
=
{
}
;
var
lineno
=
0
;
var
seenPrimary
=
false
;
do
{
var
more
=
lis
.
readLine
(
line
)
;
lineno
+
+
;
var
lineValue
=
line
.
value
;
if
(
lineValue
.
charAt
(
0
)
=
=
"
#
"
|
|
lineValue
=
=
"
"
)
{
continue
;
}
var
match
=
LINE_REGEXP
.
exec
(
lineValue
)
;
if
(
!
match
)
{
throw
new
Error
(
"
Syntax
error
in
server
-
locations
.
txt
line
"
+
lineno
)
;
}
var
[
scheme
host
port
options
]
=
match
;
if
(
options
)
{
if
(
options
.
split
(
"
"
)
.
includes
(
"
primary
"
)
)
{
if
(
seenPrimary
)
{
throw
new
Error
(
"
Multiple
primary
locations
in
server
-
locations
.
txt
"
+
"
line
"
+
lineno
)
;
}
server
.
identity
.
setPrimary
(
scheme
host
port
)
;
seenPrimary
=
true
;
continue
;
}
}
server
.
identity
.
add
(
scheme
host
port
)
;
}
while
(
more
)
;
}
function
serverShutdown
(
metadata
response
)
{
response
.
setStatusLine
(
"
1
.
1
"
200
"
OK
"
)
;
response
.
setHeader
(
"
Content
-
type
"
"
text
/
plain
"
false
)
;
var
body
=
"
Server
shut
down
.
"
;
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
dumpn
(
"
Server
shutting
down
now
.
.
.
"
)
;
server
.
stop
(
serverStopped
)
;
}
function
serverDebug
(
metadata
response
)
{
response
.
setStatusLine
(
metadata
.
httpVersion
400
"
Bad
debugging
level
"
)
;
if
(
metadata
.
queryString
.
length
!
=
=
1
)
{
return
;
}
var
mode
;
if
(
metadata
.
queryString
=
=
=
"
0
"
)
{
dumpn
(
"
Server
debug
logs
disabled
.
"
)
;
setDebuggingStatus
(
false
false
)
;
mode
=
"
disabled
"
;
}
else
if
(
metadata
.
queryString
=
=
=
"
1
"
)
{
setDebuggingStatus
(
true
false
)
;
mode
=
"
enabled
"
;
}
else
if
(
metadata
.
queryString
=
=
=
"
2
"
)
{
setDebuggingStatus
(
true
true
)
;
mode
=
"
enabled
with
timestamps
"
;
}
else
{
return
;
}
response
.
setStatusLine
(
metadata
.
httpVersion
200
"
OK
"
)
;
response
.
setHeader
(
"
Content
-
type
"
"
text
/
plain
"
false
)
;
var
body
=
"
Server
debug
logs
"
+
mode
+
"
.
"
;
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
dumpn
(
body
)
;
}
function
regularListing
(
metadata
response
)
{
var
[
links
]
=
list
(
metadata
.
path
metadata
.
getProperty
(
"
directory
"
)
false
)
;
response
.
write
(
HTML
(
HEAD
(
TITLE
(
"
mochitest
index
"
metadata
.
path
)
)
BODY
(
BR
(
)
A
(
{
href
:
"
.
.
"
}
"
Up
a
level
"
)
UL
(
linksToListItems
(
links
)
)
)
)
)
;
}
function
convertManifestToTestLinks
(
root
manifest
)
{
const
{
NetUtil
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
)
;
var
manifestFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
manifestFile
.
initWithFile
(
serverBasePath
)
;
manifestFile
.
append
(
manifest
)
;
var
manifestStream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
manifestStream
.
init
(
manifestFile
-
1
0
0
)
;
var
manifestObj
=
JSON
.
parse
(
NetUtil
.
readInputStreamToString
(
manifestStream
manifestStream
.
available
(
)
)
)
;
var
paths
=
manifestObj
.
tests
;
var
pathPrefix
=
"
/
"
+
root
+
"
/
"
;
return
[
paths
.
reduce
(
function
(
t
p
)
{
t
[
pathPrefix
+
p
.
path
]
=
true
;
return
t
;
}
{
}
)
paths
.
length
]
;
}
function
testListing
(
metadata
response
)
{
var
links
=
{
}
;
var
count
=
0
;
if
(
!
metadata
.
queryString
.
includes
(
"
manifestFile
"
)
)
{
[
links
count
]
=
list
(
metadata
.
path
metadata
.
getProperty
(
"
directory
"
)
true
)
;
}
else
if
(
typeof
Components
!
=
"
undefined
"
)
{
var
manifest
=
metadata
.
queryString
.
match
(
/
manifestFile
=
(
[
^
&
]
+
)
/
)
[
1
]
;
[
links
count
]
=
convertManifestToTestLinks
(
metadata
.
path
.
split
(
"
/
"
)
[
1
]
manifest
)
;
}
var
table_class
=
metadata
.
queryString
.
indexOf
(
"
hideResultsTable
=
1
"
)
>
-
1
?
"
invisible
"
:
"
"
;
let
testname
=
metadata
.
queryString
.
indexOf
(
"
testname
=
"
)
>
-
1
?
metadata
.
queryString
.
match
(
/
testname
=
(
[
^
&
]
+
)
/
)
[
1
]
:
"
"
;
dumpn
(
"
count
:
"
+
count
)
;
var
tests
=
testname
?
"
[
'
/
"
+
testname
+
"
'
]
"
:
jsonArrayOfTestFiles
(
links
)
;
response
.
write
(
HTML
(
HEAD
(
TITLE
(
"
MochiTest
|
"
metadata
.
path
)
LINK
(
{
rel
:
"
stylesheet
"
type
:
"
text
/
css
"
href
:
"
/
static
/
harness
.
css
"
}
)
SCRIPT
(
{
type
:
"
text
/
javascript
"
src
:
"
/
tests
/
SimpleTest
/
LogController
.
js
"
}
)
SCRIPT
(
{
type
:
"
text
/
javascript
"
src
:
"
/
tests
/
SimpleTest
/
MemoryStats
.
js
"
}
)
SCRIPT
(
{
type
:
"
text
/
javascript
"
src
:
"
/
tests
/
SimpleTest
/
TestRunner
.
js
"
}
)
SCRIPT
(
{
type
:
"
text
/
javascript
"
src
:
"
/
tests
/
SimpleTest
/
MozillaLogger
.
js
"
}
)
SCRIPT
(
{
type
:
"
text
/
javascript
"
src
:
"
/
chunkifyTests
.
js
"
}
)
SCRIPT
(
{
type
:
"
text
/
javascript
"
src
:
"
/
manifestLibrary
.
js
"
}
)
SCRIPT
(
{
type
:
"
text
/
javascript
"
src
:
"
/
tests
/
SimpleTest
/
setup
.
js
"
}
)
SCRIPT
(
{
type
:
"
text
/
javascript
"
}
"
window
.
onload
=
hookup
;
gTestList
=
"
+
tests
+
"
;
"
)
)
BODY
(
DIV
(
{
class
:
"
container
"
}
H2
(
"
-
-
>
"
A
(
{
href
:
"
#
"
id
:
"
runtests
"
}
"
Run
Tests
"
)
"
<
-
-
"
)
P
(
{
style
:
"
float
:
right
;
"
}
SMALL
(
"
Based
on
the
"
A
(
{
href
:
"
http
:
/
/
www
.
mochikit
.
com
/
"
}
"
MochiKit
"
)
"
unit
tests
.
"
)
)
DIV
(
{
class
:
"
status
"
}
H1
(
{
id
:
"
indicator
"
}
"
Status
"
)
H2
(
{
id
:
"
pass
"
}
"
Passed
:
"
SPAN
(
{
id
:
"
pass
-
count
"
}
"
0
"
)
)
H2
(
{
id
:
"
fail
"
}
"
Failed
:
"
SPAN
(
{
id
:
"
fail
-
count
"
}
"
0
"
)
)
H2
(
{
id
:
"
fail
"
}
"
Todo
:
"
SPAN
(
{
id
:
"
todo
-
count
"
}
"
0
"
)
)
)
DIV
(
{
class
:
"
clear
"
}
)
DIV
(
{
id
:
"
current
-
test
"
}
B
(
"
Currently
Executing
:
"
SPAN
(
{
id
:
"
current
-
test
-
path
"
}
"
_
"
)
)
)
DIV
(
{
class
:
"
clear
"
}
)
DIV
(
{
class
:
"
frameholder
"
}
IFRAME
(
{
scrolling
:
"
no
"
id
:
"
testframe
"
allowfullscreen
:
true
}
)
)
DIV
(
{
class
:
"
clear
"
}
)
DIV
(
{
class
:
"
toggle
"
}
A
(
{
href
:
"
#
"
id
:
"
toggleNonTests
"
}
"
Show
Non
-
Tests
"
)
BR
(
)
)
displayResults
?
TABLE
(
{
cellpadding
:
0
cellspacing
:
0
class
:
table_class
id
:
"
test
-
table
"
}
TR
(
TD
(
"
Passed
"
)
TD
(
"
Failed
"
)
TD
(
"
Todo
"
)
TD
(
"
Test
Files
"
)
)
linksToTableRows
(
links
0
)
)
:
"
"
BR
(
)
TABLE
(
{
cellpadding
:
0
cellspacing
:
0
border
:
1
bordercolor
:
"
red
"
id
:
"
fail
-
table
"
}
)
DIV
(
{
class
:
"
clear
"
}
)
)
)
)
)
;
}
function
defaultDirHandler
(
metadata
response
)
{
response
.
setStatusLine
(
"
1
.
1
"
200
"
OK
"
)
;
response
.
setHeader
(
"
Content
-
type
"
"
text
/
html
;
charset
=
utf
-
8
"
false
)
;
try
{
if
(
metadata
.
path
.
indexOf
(
"
/
tests
"
)
!
=
0
)
{
regularListing
(
metadata
response
)
;
}
else
{
testListing
(
metadata
response
)
;
}
}
catch
(
ex
)
{
response
.
write
(
ex
)
;
}
}
