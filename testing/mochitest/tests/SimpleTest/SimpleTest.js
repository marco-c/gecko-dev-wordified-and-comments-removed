var
SimpleTest
=
{
}
;
var
parentRunner
=
null
;
let
isSameOrigin
=
function
(
w
)
{
try
{
w
.
top
.
TestRunner
;
}
catch
(
e
)
{
if
(
e
instanceof
DOMException
)
{
return
false
;
}
}
return
true
;
}
;
let
isXOrigin
=
!
isSameOrigin
(
window
)
;
function
isErrorObj
(
err
)
{
if
(
!
err
)
{
return
false
;
}
let
glob
=
SpecialPowers
.
Cu
.
getGlobalForObject
(
err
)
;
return
err
instanceof
glob
.
Error
;
}
var
isSingleTestRun
=
parent
=
=
window
&
&
!
(
opener
|
|
(
window
.
arguments
&
&
window
.
arguments
[
0
]
.
SimpleTest
)
)
;
try
{
var
isPrimaryTestWindow
=
(
isXOrigin
&
&
parent
!
=
window
&
&
parent
=
=
top
)
|
|
(
!
isXOrigin
&
&
(
!
!
parent
.
TestRunner
|
|
isSingleTestRun
)
)
;
}
catch
(
e
)
{
dump
(
"
TEST
-
UNEXPECTED
-
FAIL
Exception
caught
:
"
+
e
.
message
+
"
at
:
"
+
e
.
fileName
+
"
(
"
+
e
.
lineNumber
+
"
)
location
:
"
+
window
.
location
.
href
+
"
\
n
"
)
;
}
let
xOriginRunner
=
{
init
(
harnessWindow
)
{
this
.
harnessWindow
=
harnessWindow
;
let
url
=
new
URL
(
document
.
URL
)
;
this
.
testFile
=
url
.
pathname
;
this
.
showTestReport
=
url
.
searchParams
.
get
(
"
showTestReport
"
)
=
=
"
true
"
;
this
.
expected
=
url
.
searchParams
.
get
(
"
expected
"
)
;
}
callHarnessMethod
(
applyOn
command
.
.
.
params
)
{
this
.
harnessWindow
.
postMessage
(
{
harnessType
:
"
SimpleTest
"
applyOn
command
params
}
"
*
"
)
;
}
getParameterInfo
(
)
{
let
url
=
new
URL
(
document
.
URL
)
;
return
{
currentTestURL
:
url
.
searchParams
.
get
(
"
currentTestURL
"
)
testRoot
:
url
.
searchParams
.
get
(
"
testRoot
"
)
}
;
}
addFailedTest
(
test
)
{
this
.
callHarnessMethod
(
"
runner
"
"
addFailedTest
"
test
)
;
}
expectAssertions
(
min
max
)
{
this
.
callHarnessMethod
(
"
runner
"
"
expectAssertions
"
min
max
)
;
}
expectChildProcessCrash
(
)
{
this
.
callHarnessMethod
(
"
runner
"
"
expectChildProcessCrash
"
)
;
}
requestLongerTimeout
(
factor
)
{
this
.
callHarnessMethod
(
"
runner
"
"
requestLongerTimeout
"
factor
)
;
}
_lastAssertionCount
:
0
testFinished
(
tests
)
{
var
newAssertionCount
=
SpecialPowers
.
assertionCount
(
)
;
var
numAsserts
=
newAssertionCount
-
this
.
_lastAssertionCount
;
this
.
_lastAssertionCount
=
newAssertionCount
;
this
.
callHarnessMethod
(
"
runner
"
"
addAssertionCount
"
numAsserts
)
;
this
.
callHarnessMethod
(
"
runner
"
"
testFinished
"
tests
)
;
}
structuredLogger
:
{
info
(
msg
)
{
xOriginRunner
.
callHarnessMethod
(
"
logger
"
"
structuredLogger
.
info
"
msg
)
;
}
warning
(
msg
)
{
xOriginRunner
.
callHarnessMethod
(
"
logger
"
"
structuredLogger
.
warning
"
msg
)
;
}
error
(
msg
)
{
xOriginRunner
.
callHarnessMethod
(
"
logger
"
"
structuredLogger
.
error
"
msg
)
;
}
activateBuffering
(
)
{
xOriginRunner
.
callHarnessMethod
(
"
logger
"
"
structuredLogger
.
activateBuffering
"
)
;
}
deactivateBuffering
(
)
{
xOriginRunner
.
callHarnessMethod
(
"
logger
"
"
structuredLogger
.
deactivateBuffering
"
)
;
}
testStatus
(
url
subtest
status
expected
diagnostic
stack
)
{
xOriginRunner
.
callHarnessMethod
(
"
logger
"
"
structuredLogger
.
testStatus
"
url
subtest
status
expected
diagnostic
stack
)
;
}
}
}
;
(
function
(
)
{
function
ancestor
(
w
)
{
return
w
.
parent
!
=
w
?
w
.
parent
:
w
.
opener
|
|
(
!
isXOrigin
&
&
w
.
arguments
&
&
SpecialPowers
.
wrap
(
Window
)
.
isInstance
(
w
.
arguments
[
0
]
)
&
&
w
.
arguments
[
0
]
)
;
}
var
w
=
ancestor
(
window
)
;
while
(
w
&
&
!
parentRunner
)
{
isXOrigin
=
!
isSameOrigin
(
w
)
;
if
(
isXOrigin
)
{
if
(
w
.
parent
!
=
w
)
{
w
=
w
.
top
;
}
xOriginRunner
.
init
(
w
)
;
parentRunner
=
xOriginRunner
;
}
if
(
!
parentRunner
)
{
parentRunner
=
w
.
TestRunner
;
if
(
!
parentRunner
&
&
w
.
wrappedJSObject
)
{
parentRunner
=
w
.
wrappedJSObject
.
TestRunner
;
}
}
w
=
ancestor
(
w
)
;
}
if
(
parentRunner
)
{
SimpleTest
.
harnessParameters
=
parentRunner
.
getParameterInfo
(
)
;
}
}
)
(
)
;
if
(
typeof
repr
=
=
"
undefined
"
)
{
this
.
repr
=
function
repr
(
o
)
{
if
(
typeof
o
=
=
"
undefined
"
)
{
return
"
undefined
"
;
}
else
if
(
o
=
=
=
null
)
{
return
"
null
"
;
}
try
{
if
(
typeof
o
.
__repr__
=
=
"
function
"
)
{
return
o
.
__repr__
(
)
;
}
else
if
(
typeof
o
.
repr
=
=
"
function
"
&
&
o
.
repr
!
=
repr
)
{
return
o
.
repr
(
)
;
}
}
catch
(
e
)
{
}
try
{
if
(
typeof
o
.
NAME
=
=
"
string
"
&
&
(
o
.
toString
=
=
Function
.
prototype
.
toString
|
|
o
.
toString
=
=
Object
.
prototype
.
toString
)
)
{
return
o
.
NAME
;
}
}
catch
(
e
)
{
}
var
ostring
;
try
{
if
(
o
=
=
=
0
)
{
ostring
=
1
/
o
>
0
?
"
+
0
"
:
"
-
0
"
;
}
else
if
(
typeof
o
=
=
=
"
string
"
)
{
ostring
=
JSON
.
stringify
(
o
)
;
}
else
if
(
Array
.
isArray
(
o
)
)
{
ostring
=
"
[
"
+
o
.
map
(
val
=
>
repr
(
val
)
)
.
join
(
"
"
)
+
"
]
"
;
}
else
{
ostring
=
o
+
"
"
;
}
}
catch
(
e
)
{
return
"
[
"
+
typeof
o
+
"
]
"
;
}
if
(
typeof
o
=
=
"
function
"
)
{
o
=
ostring
.
replace
(
/
^
\
s
+
/
"
"
)
;
var
idx
=
o
.
indexOf
(
"
{
"
)
;
if
(
idx
!
=
-
1
)
{
o
=
o
.
substr
(
0
idx
)
+
"
{
.
.
.
}
"
;
}
}
return
ostring
;
}
;
}
if
(
typeof
partial
=
=
"
undefined
"
)
{
this
.
partial
=
function
(
func
)
{
var
args
=
[
]
;
for
(
let
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
args
.
push
(
arguments
[
i
]
)
;
}
return
function
(
)
{
if
(
arguments
.
length
)
{
for
(
let
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
args
.
push
(
arguments
[
i
]
)
;
}
}
func
(
args
)
;
}
;
}
;
}
if
(
typeof
getElement
=
=
"
undefined
"
)
{
this
.
getElement
=
function
(
id
)
{
return
typeof
id
=
=
"
string
"
?
document
.
getElementById
(
id
)
:
id
;
}
;
this
.
=
this
.
getElement
;
}
SimpleTest
.
_newCallStack
=
function
(
path
)
{
var
rval
=
function
callStackHandler
(
)
{
var
callStack
=
callStackHandler
.
callStack
;
for
(
var
i
=
0
;
i
<
callStack
.
length
;
i
+
+
)
{
if
(
callStack
[
i
]
.
apply
(
this
arguments
)
=
=
=
false
)
{
break
;
}
}
try
{
this
[
path
]
=
null
;
}
catch
(
e
)
{
}
}
;
rval
.
callStack
=
[
]
;
return
rval
;
}
;
if
(
typeof
addLoadEvent
=
=
"
undefined
"
)
{
this
.
addLoadEvent
=
function
(
func
)
{
var
existing
=
window
.
onload
;
var
regfunc
=
existing
;
if
(
!
(
typeof
existing
=
=
"
function
"
&
&
typeof
existing
.
callStack
=
=
"
object
"
&
&
existing
.
callStack
!
=
=
null
)
)
{
regfunc
=
SimpleTest
.
_newCallStack
(
"
onload
"
)
;
if
(
typeof
existing
=
=
"
function
"
)
{
regfunc
.
callStack
.
push
(
existing
)
;
}
window
.
onload
=
regfunc
;
}
regfunc
.
callStack
.
push
(
func
)
;
}
;
}
function
createEl
(
type
attrs
html
)
{
var
el
;
if
(
!
document
.
body
)
{
el
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
type
)
;
}
else
{
el
=
document
.
createElement
(
type
)
;
}
if
(
attrs
!
=
=
null
&
&
attrs
!
=
=
undefined
)
{
for
(
var
k
in
attrs
)
{
el
.
setAttribute
(
k
attrs
[
k
]
)
;
}
}
if
(
html
!
=
=
null
&
&
html
!
=
=
undefined
)
{
el
.
appendChild
(
document
.
createTextNode
(
html
)
)
;
}
return
el
;
}
if
(
typeof
computedStyle
=
=
"
undefined
"
)
{
this
.
computedStyle
=
function
(
elem
cssProperty
)
{
elem
=
getElement
(
elem
)
;
if
(
elem
.
currentStyle
)
{
return
elem
.
currentStyle
[
cssProperty
]
;
}
if
(
typeof
document
.
defaultView
=
=
"
undefined
"
|
|
document
=
=
=
null
)
{
return
undefined
;
}
var
style
=
document
.
defaultView
.
getComputedStyle
(
elem
)
;
if
(
typeof
style
=
=
"
undefined
"
|
|
style
=
=
=
null
)
{
return
undefined
;
}
var
selectorCase
=
cssProperty
.
replace
(
/
(
[
A
-
Z
]
)
/
g
"
-
1
"
)
.
toLowerCase
(
)
;
return
style
.
getPropertyValue
(
selectorCase
)
;
}
;
}
SimpleTest
.
_tests
=
[
]
;
SimpleTest
.
_stopOnLoad
=
true
;
SimpleTest
.
_cleanupFunctions
=
[
]
;
SimpleTest
.
_timeoutFunctions
=
[
]
;
SimpleTest
.
_inChaosMode
=
false
;
SimpleTest
.
expected
=
"
pass
"
;
SimpleTest
.
num_failed
=
0
;
SpecialPowers
.
setAsDefaultAssertHandler
(
)
;
function
usesFailurePatterns
(
)
{
return
Array
.
isArray
(
SimpleTest
.
expected
)
;
}
function
recordIfMatchesFailurePattern
(
name
diag
)
{
let
index
=
SimpleTest
.
expected
.
findIndex
(
(
[
pat
count
]
)
=
>
{
return
(
pat
=
=
null
|
|
(
typeof
name
=
=
"
string
"
&
&
name
.
includes
(
pat
)
)
|
|
(
typeof
diag
=
=
"
string
"
&
&
diag
.
includes
(
pat
)
)
)
;
}
)
;
if
(
index
>
=
0
)
{
SimpleTest
.
num_failed
[
index
]
+
+
;
return
true
;
}
return
false
;
}
SimpleTest
.
setExpected
=
function
(
)
{
if
(
!
parentRunner
)
{
return
;
}
if
(
!
Array
.
isArray
(
parentRunner
.
expected
)
)
{
SimpleTest
.
expected
=
parentRunner
.
expected
;
}
else
{
SimpleTest
.
expected
=
parentRunner
.
expected
.
filter
(
(
[
pat
]
)
=
>
pat
!
=
"
ASSERTION
"
)
;
SimpleTest
.
num_failed
=
new
Array
(
SimpleTest
.
expected
.
length
)
;
SimpleTest
.
num_failed
.
fill
(
0
)
;
}
}
;
SimpleTest
.
setExpected
(
)
;
SimpleTest
.
ok
=
function
(
condition
name
)
{
if
(
arguments
.
length
>
2
)
{
const
diag
=
"
Too
many
arguments
passed
to
ok
(
condition
name
)
"
;
SimpleTest
.
record
(
false
name
diag
)
;
}
else
{
SimpleTest
.
record
(
condition
name
)
;
}
}
;
SimpleTest
.
record
=
function
(
condition
name
diag
stack
expected
)
{
var
test
=
{
result
:
!
!
condition
name
diag
}
;
let
successInfo
;
let
failureInfo
;
if
(
SimpleTest
.
expected
=
=
"
fail
"
)
{
if
(
!
test
.
result
)
{
SimpleTest
.
num_failed
+
+
;
test
.
result
=
true
;
}
successInfo
=
{
status
:
"
PASS
"
expected
:
"
PASS
"
message
:
"
TEST
-
PASS
"
}
;
failureInfo
=
{
status
:
"
FAIL
"
expected
:
"
FAIL
"
message
:
"
TEST
-
KNOWN
-
FAIL
"
}
;
}
else
if
(
!
test
.
result
&
&
usesFailurePatterns
(
)
)
{
if
(
recordIfMatchesFailurePattern
(
name
diag
)
)
{
test
.
result
=
true
;
name
=
"
[
suppressed
]
"
+
name
;
}
successInfo
=
{
status
:
"
FAIL
"
expected
:
"
FAIL
"
message
:
"
TEST
-
KNOWN
-
FAIL
"
}
;
failureInfo
=
{
status
:
"
FAIL
"
expected
:
"
PASS
"
message
:
"
TEST
-
UNEXPECTED
-
FAIL
"
}
;
}
else
if
(
expected
=
=
"
fail
"
)
{
successInfo
=
{
status
:
"
PASS
"
expected
:
"
FAIL
"
message
:
"
TEST
-
UNEXPECTED
-
PASS
"
}
;
failureInfo
=
{
status
:
"
FAIL
"
expected
:
"
FAIL
"
message
:
"
TEST
-
KNOWN
-
FAIL
"
}
;
}
else
{
successInfo
=
{
status
:
"
PASS
"
expected
:
"
PASS
"
message
:
"
TEST
-
PASS
"
}
;
failureInfo
=
{
status
:
"
FAIL
"
expected
:
"
PASS
"
message
:
"
TEST
-
UNEXPECTED
-
FAIL
"
}
;
}
if
(
condition
)
{
stack
=
null
;
}
else
if
(
!
stack
)
{
stack
=
new
Error
(
)
.
stack
.
replace
(
/
^
(
.
*
)
http
:
\
/
\
/
mochi
.
test
:
8888
\
/
tests
\
/
/
gm
"
1
"
)
.
split
(
"
\
n
"
)
;
stack
.
splice
(
0
1
)
;
stack
=
stack
.
join
(
"
\
n
"
)
;
}
SimpleTest
.
_logResult
(
test
successInfo
failureInfo
stack
)
;
SimpleTest
.
_tests
.
push
(
test
)
;
}
;
SimpleTest
.
is
=
function
(
a
b
name
)
{
var
pass
=
Object
.
is
(
a
b
)
;
var
diag
=
pass
?
"
"
:
"
got
"
+
repr
(
a
)
+
"
expected
"
+
repr
(
b
)
;
SimpleTest
.
record
(
pass
name
diag
)
;
}
;
SimpleTest
.
isfuzzy
=
function
(
a
b
epsilon
name
)
{
var
pass
=
a
>
=
b
-
epsilon
&
&
a
<
=
b
+
epsilon
;
var
diag
=
pass
?
"
"
:
"
got
"
+
repr
(
a
)
+
"
expected
"
+
repr
(
b
)
+
"
epsilon
:
+
/
-
"
+
repr
(
epsilon
)
;
SimpleTest
.
record
(
pass
name
diag
)
;
}
;
SimpleTest
.
isnot
=
function
(
a
b
name
)
{
var
pass
=
!
Object
.
is
(
a
b
)
;
var
diag
=
pass
?
"
"
:
"
didn
'
t
expect
"
+
repr
(
a
)
+
"
but
got
it
"
;
SimpleTest
.
record
(
pass
name
diag
)
;
}
;
SimpleTest
.
doesThrow
=
function
(
fn
name
)
{
var
gotException
=
false
;
try
{
fn
(
)
;
}
catch
(
ex
)
{
gotException
=
true
;
}
ok
(
gotException
name
)
;
}
;
SimpleTest
.
todo
=
function
(
condition
name
diag
)
{
var
test
=
{
result
:
!
!
condition
name
diag
todo
:
true
}
;
if
(
test
.
result
&
&
usesFailurePatterns
(
)
&
&
recordIfMatchesFailurePattern
(
name
diag
)
)
{
test
.
result
=
false
;
name
=
"
[
suppressed
]
"
+
name
;
}
var
successInfo
=
{
status
:
"
PASS
"
expected
:
"
FAIL
"
message
:
"
TEST
-
UNEXPECTED
-
PASS
"
}
;
var
failureInfo
=
{
status
:
"
FAIL
"
expected
:
"
FAIL
"
message
:
"
TEST
-
KNOWN
-
FAIL
"
}
;
SimpleTest
.
_logResult
(
test
successInfo
failureInfo
)
;
SimpleTest
.
_tests
.
push
(
test
)
;
}
;
SimpleTest
.
getTestFileURL
=
function
(
path
)
{
var
location
=
window
.
location
;
var
remotePath
=
location
.
pathname
.
replace
(
/
\
/
[
^
\
/
]
+
?
/
"
"
)
;
var
url
=
location
.
origin
+
remotePath
+
"
/
"
+
path
;
return
url
;
}
;
SimpleTest
.
_getCurrentTestURL
=
function
(
)
{
return
(
(
SimpleTest
.
harnessParameters
&
&
SimpleTest
.
harnessParameters
.
currentTestURL
)
|
|
(
parentRunner
&
&
parentRunner
.
currentTestURL
)
|
|
(
typeof
gTestPath
=
=
"
string
"
&
&
gTestPath
)
|
|
"
unknown
test
url
"
)
;
}
;
SimpleTest
.
_forceLogMessageOutput
=
false
;
SimpleTest
.
requestCompleteLog
=
function
(
)
{
if
(
!
parentRunner
|
|
SimpleTest
.
_forceLogMessageOutput
)
{
return
;
}
parentRunner
.
structuredLogger
.
deactivateBuffering
(
)
;
SimpleTest
.
_forceLogMessageOutput
=
true
;
SimpleTest
.
registerCleanupFunction
(
function
(
)
{
parentRunner
.
structuredLogger
.
activateBuffering
(
)
;
SimpleTest
.
_forceLogMessageOutput
=
false
;
}
)
;
}
;
SimpleTest
.
_logResult
=
function
(
test
passInfo
failInfo
stack
)
{
var
url
=
SimpleTest
.
_getCurrentTestURL
(
)
;
var
result
=
test
.
result
?
passInfo
:
failInfo
;
var
diagnostic
=
test
.
diag
|
|
null
;
var
subtest
=
test
.
name
?
String
(
test
.
name
)
:
null
;
var
isError
=
!
test
.
result
=
=
!
test
.
todo
;
if
(
parentRunner
)
{
if
(
!
result
.
status
|
|
!
result
.
expected
)
{
if
(
diagnostic
)
{
parentRunner
.
structuredLogger
.
info
(
diagnostic
)
;
}
return
;
}
if
(
isError
)
{
parentRunner
.
addFailedTest
(
url
)
;
}
parentRunner
.
structuredLogger
.
testStatus
(
url
subtest
result
.
status
result
.
expected
diagnostic
stack
)
;
}
else
if
(
typeof
dump
=
=
=
"
function
"
)
{
var
diagMessage
=
test
.
name
+
(
test
.
diag
?
"
-
"
+
test
.
diag
:
"
"
)
;
var
debugMsg
=
[
result
.
message
url
diagMessage
]
.
join
(
"
|
"
)
;
dump
(
debugMsg
+
"
\
n
"
)
;
}
else
{
}
}
;
SimpleTest
.
info
=
function
(
name
message
)
{
var
log
=
message
?
name
+
"
|
"
+
message
:
name
;
if
(
parentRunner
)
{
parentRunner
.
structuredLogger
.
info
(
log
)
;
}
else
{
dump
(
log
+
"
\
n
"
)
;
}
}
;
SimpleTest
.
todo_is
=
function
(
a
b
name
)
{
var
pass
=
Object
.
is
(
a
b
)
;
var
diag
=
pass
?
repr
(
a
)
+
"
should
equal
"
+
repr
(
b
)
:
"
got
"
+
repr
(
a
)
+
"
expected
"
+
repr
(
b
)
;
SimpleTest
.
todo
(
pass
name
diag
)
;
}
;
SimpleTest
.
todo_isnot
=
function
(
a
b
name
)
{
var
pass
=
!
Object
.
is
(
a
b
)
;
var
diag
=
pass
?
repr
(
a
)
+
"
should
not
equal
"
+
repr
(
b
)
:
"
didn
'
t
expect
"
+
repr
(
a
)
+
"
but
got
it
"
;
SimpleTest
.
todo
(
pass
name
diag
)
;
}
;
SimpleTest
.
report
=
function
(
)
{
var
passed
=
0
;
var
failed
=
0
;
var
todo
=
0
;
var
tallyAndCreateDiv
=
function
(
test
)
{
var
cls
msg
div
;
var
diag
=
test
.
diag
?
"
-
"
+
test
.
diag
:
"
"
;
if
(
test
.
todo
&
&
!
test
.
result
)
{
todo
+
+
;
cls
=
"
test_todo
"
;
msg
=
"
todo
|
"
+
test
.
name
+
diag
;
}
else
if
(
test
.
result
&
&
!
test
.
todo
)
{
passed
+
+
;
cls
=
"
test_ok
"
;
msg
=
"
passed
|
"
+
test
.
name
+
diag
;
}
else
{
failed
+
+
;
cls
=
"
test_not_ok
"
;
msg
=
"
failed
|
"
+
test
.
name
+
diag
;
}
div
=
createEl
(
"
div
"
{
class
:
cls
}
msg
)
;
return
div
;
}
;
var
results
=
[
]
;
for
(
var
d
=
0
;
d
<
SimpleTest
.
_tests
.
length
;
d
+
+
)
{
results
.
push
(
tallyAndCreateDiv
(
SimpleTest
.
_tests
[
d
]
)
)
;
}
var
summary_class
=
failed
!
=
0
?
"
some_fail
"
:
passed
=
=
0
?
"
todo_only
"
:
"
all_pass
"
;
var
div1
=
createEl
(
"
div
"
{
class
:
"
tests_report
"
}
)
;
var
div2
=
createEl
(
"
div
"
{
class
:
"
tests_summary
"
+
summary_class
}
)
;
var
div3
=
createEl
(
"
div
"
{
class
:
"
tests_passed
"
}
"
Passed
:
"
+
passed
)
;
var
div4
=
createEl
(
"
div
"
{
class
:
"
tests_failed
"
}
"
Failed
:
"
+
failed
)
;
var
div5
=
createEl
(
"
div
"
{
class
:
"
tests_todo
"
}
"
Todo
:
"
+
todo
)
;
div2
.
appendChild
(
div3
)
;
div2
.
appendChild
(
div4
)
;
div2
.
appendChild
(
div5
)
;
div1
.
appendChild
(
div2
)
;
for
(
var
t
=
0
;
t
<
results
.
length
;
t
+
+
)
{
div1
.
appendChild
(
results
[
t
]
)
;
}
return
div1
;
}
;
SimpleTest
.
toggle
=
function
(
el
)
{
if
(
computedStyle
(
el
"
display
"
)
=
=
"
block
"
)
{
el
.
style
.
display
=
"
none
"
;
}
else
{
el
.
style
.
display
=
"
block
"
;
}
}
;
SimpleTest
.
toggleByClass
=
function
(
cls
evt
)
{
var
children
=
document
.
getElementsByTagName
(
"
div
"
)
;
var
elements
=
[
]
;
for
(
var
i
=
0
;
i
<
children
.
length
;
i
+
+
)
{
var
child
=
children
[
i
]
;
var
clsName
=
child
.
className
;
if
(
!
clsName
)
{
continue
;
}
var
classNames
=
clsName
.
split
(
"
"
)
;
for
(
var
j
=
0
;
j
<
classNames
.
length
;
j
+
+
)
{
if
(
classNames
[
j
]
=
=
cls
)
{
elements
.
push
(
child
)
;
break
;
}
}
}
for
(
var
t
=
0
;
t
<
elements
.
length
;
t
+
+
)
{
SimpleTest
.
toggle
(
elements
[
t
]
)
;
}
if
(
evt
)
{
evt
.
preventDefault
(
)
;
}
}
;
SimpleTest
.
showReport
=
function
(
)
{
var
togglePassed
=
createEl
(
"
a
"
{
href
:
"
#
"
}
"
Toggle
passed
checks
"
)
;
var
toggleFailed
=
createEl
(
"
a
"
{
href
:
"
#
"
}
"
Toggle
failed
checks
"
)
;
var
toggleTodo
=
createEl
(
"
a
"
{
href
:
"
#
"
}
"
Toggle
todo
checks
"
)
;
togglePassed
.
onclick
=
partial
(
SimpleTest
.
toggleByClass
"
test_ok
"
)
;
toggleFailed
.
onclick
=
partial
(
SimpleTest
.
toggleByClass
"
test_not_ok
"
)
;
toggleTodo
.
onclick
=
partial
(
SimpleTest
.
toggleByClass
"
test_todo
"
)
;
var
body
=
document
.
body
;
if
(
!
body
)
{
body
=
document
.
getElementsByTagNameNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
body
"
)
[
0
]
;
}
var
firstChild
=
body
.
childNodes
[
0
]
;
var
addNode
;
if
(
firstChild
)
{
addNode
=
function
(
el
)
{
body
.
insertBefore
(
el
firstChild
)
;
}
;
}
else
{
addNode
=
function
(
el
)
{
body
.
appendChild
(
el
)
;
}
;
}
addNode
(
togglePassed
)
;
addNode
(
createEl
(
"
span
"
null
"
"
)
)
;
addNode
(
toggleFailed
)
;
addNode
(
createEl
(
"
span
"
null
"
"
)
)
;
addNode
(
toggleTodo
)
;
addNode
(
SimpleTest
.
report
(
)
)
;
addNode
(
createEl
(
"
hr
"
)
)
;
}
;
SimpleTest
.
waitForExplicitFinish
=
function
(
)
{
SimpleTest
.
_stopOnLoad
=
false
;
}
;
SimpleTest
.
requestLongerTimeout
=
function
(
factor
)
{
if
(
parentRunner
)
{
parentRunner
.
requestLongerTimeout
(
factor
)
;
}
else
{
dump
(
"
[
SimpleTest
.
requestLongerTimeout
(
)
]
ignoring
request
maybe
you
meant
to
call
the
global
requestLongerTimeout
instead
?
\
n
"
)
;
}
}
;
SimpleTest
.
expectAssertions
=
function
(
min
max
)
{
if
(
parentRunner
)
{
parentRunner
.
expectAssertions
(
min
max
)
;
}
}
;
SimpleTest
.
_flakyTimeoutIsOK
=
false
;
SimpleTest
.
_originalSetTimeout
=
window
.
setTimeout
;
window
.
setTimeout
=
function
SimpleTest_setTimeoutShim
(
)
{
if
(
parentRunner
)
{
switch
(
SimpleTest
.
harnessParameters
.
testRoot
)
{
case
"
browser
"
:
case
"
chrome
"
:
case
"
a11y
"
:
break
;
default
:
if
(
!
SimpleTest
.
_alreadyFinished
&
&
arguments
.
length
>
1
&
&
arguments
[
1
]
>
0
)
{
if
(
SimpleTest
.
_flakyTimeoutIsOK
)
{
SimpleTest
.
todo
(
false
"
The
author
of
the
test
has
indicated
that
flaky
timeouts
are
expected
.
Reason
:
"
+
SimpleTest
.
_flakyTimeoutReason
)
;
}
else
{
SimpleTest
.
ok
(
false
"
Test
attempted
to
use
a
flaky
timeout
value
"
+
arguments
[
1
]
)
;
}
}
}
}
return
SimpleTest
.
_originalSetTimeout
.
apply
(
window
arguments
)
;
}
;
SimpleTest
.
requestFlakyTimeout
=
function
(
reason
)
{
SimpleTest
.
is
(
typeof
reason
"
string
"
"
A
valid
string
reason
is
expected
"
)
;
SimpleTest
.
isnot
(
reason
"
"
"
Reason
cannot
be
empty
"
)
;
SimpleTest
.
_flakyTimeoutIsOK
=
true
;
SimpleTest
.
_flakyTimeoutReason
=
reason
;
}
;
SimpleTest
.
promiseFocus
=
async
function
(
aObject
aExpectBlankPage
=
false
aBlurSubframe
=
false
)
{
let
browser
;
let
browsingContext
;
let
windowToFocus
;
if
(
!
aObject
)
{
aObject
=
window
;
}
async
function
waitForEvent
(
aTarget
aEventName
)
{
return
new
Promise
(
resolve
=
>
{
aTarget
.
addEventListener
(
aEventName
resolve
{
capture
:
true
once
:
true
}
)
;
}
)
;
}
if
(
SpecialPowers
.
wrap
(
Window
)
.
isInstance
(
aObject
)
)
{
windowToFocus
=
aObject
;
let
isBlank
=
windowToFocus
.
location
.
href
=
=
"
about
:
blank
"
;
if
(
aExpectBlankPage
!
=
isBlank
|
|
windowToFocus
.
document
.
readyState
!
=
"
complete
"
)
{
info
(
"
must
wait
for
load
"
)
;
await
waitForEvent
(
windowToFocus
"
load
"
)
;
}
}
else
{
if
(
SpecialPowers
.
wrap
(
Element
)
.
isInstance
(
aObject
)
)
{
browsingContext
=
aObject
.
browsingContext
;
}
else
{
browsingContext
=
aObject
;
}
browser
=
browsingContext
=
=
aObject
?
aObject
.
top
.
embedderElement
:
aObject
;
windowToFocus
=
browser
.
ownerGlobal
;
}
if
(
!
windowToFocus
.
document
.
hasFocus
(
)
)
{
info
(
"
must
wait
for
focus
"
)
;
let
focusPromise
=
waitForEvent
(
windowToFocus
.
document
"
focus
"
)
;
SpecialPowers
.
focus
(
windowToFocus
)
;
await
focusPromise
;
}
if
(
browser
)
{
if
(
windowToFocus
.
document
.
activeElement
!
=
browser
)
{
browser
.
focus
(
)
;
}
info
(
"
must
wait
for
focus
in
content
"
)
;
await
SpecialPowers
.
ensureFocus
(
browsingContext
aBlurSubframe
)
;
}
else
{
if
(
aBlurSubframe
)
{
SpecialPowers
.
clearFocus
(
windowToFocus
)
;
}
browsingContext
=
windowToFocus
.
browsingContext
;
}
await
new
Promise
(
resolve
=
>
{
SimpleTest
.
executeSoon
(
resolve
)
;
}
)
;
return
browsingContext
;
}
;
SimpleTest
.
waitForFocus
=
function
(
callback
aObject
expectBlankPage
)
{
SimpleTest
.
promiseFocus
(
aObject
expectBlankPage
)
.
then
(
focusedBC
=
>
{
callback
(
focusedBC
?
.
window
)
;
}
)
;
}
;
SimpleTest
.
stripLinebreaksAndWhitespaceAfterTags
=
function
(
aString
)
{
return
aString
.
replace
(
/
(
>
\
s
*
(
\
r
\
n
|
\
n
|
\
r
)
*
\
s
*
)
/
gm
"
>
"
)
;
}
;
const
kPlatformWindows
=
"
Win
"
;
const
kTextHtmlPrefixClipboardDataWindows
=
"
<
html
>
<
body
>
\
n
<
!
-
-
StartFragment
-
-
>
"
;
const
kTextHtmlSuffixClipboardDataWindows
=
"
<
!
-
-
EndFragment
-
-
>
\
n
<
/
body
>
\
n
<
/
html
>
"
;
SimpleTest
.
waitForClipboard
=
function
(
aExpectedStringOrValidatorFn
aSetupFn
aSuccessFn
aFailureFn
aFlavor
aTimeout
aExpectFailure
aDontInitializeClipboardIfExpectFailure
)
{
let
promise
=
SimpleTest
.
promiseClipboardChange
(
aExpectedStringOrValidatorFn
aSetupFn
aFlavor
aTimeout
aExpectFailure
aDontInitializeClipboardIfExpectFailure
)
;
promise
.
then
(
aSuccessFn
)
.
catch
(
aFailureFn
)
;
}
;
SimpleTest
.
promiseClipboardChange
=
async
function
(
aExpectedStringOrValidatorFn
aSetupFn
aFlavor
aTimeout
aExpectFailure
aDontInitializeClipboardIfExpectFailure
)
{
let
requestedFlavor
=
aFlavor
|
|
"
text
/
plain
"
;
let
initialVal
=
"
waitForClipboard
-
known
-
value
-
"
+
Math
.
random
(
)
;
let
preExpectedVal
=
initialVal
;
let
inputValidatorFn
;
if
(
aExpectFailure
)
{
if
(
aExpectedStringOrValidatorFn
!
=
=
null
)
{
SimpleTest
.
ok
(
false
"
When
expecting
failure
aExpectedStringOrValidatorFn
must
be
null
"
)
;
}
inputValidatorFn
=
function
(
aData
)
{
return
aData
!
=
initialVal
;
}
;
}
else
if
(
typeof
aExpectedStringOrValidatorFn
=
=
"
string
"
)
{
if
(
aExpectedStringOrValidatorFn
.
includes
(
"
\
r
"
)
)
{
throw
new
Error
(
"
Use
function
instead
of
string
to
compare
raw
line
breakers
in
clipboard
"
)
;
}
if
(
requestedFlavor
=
=
=
"
text
/
html
"
&
&
navigator
.
platform
.
includes
(
"
Win
"
)
)
{
inputValidatorFn
=
function
(
aData
)
{
return
(
aData
.
replace
(
/
\
r
\
n
?
/
g
"
\
n
"
)
=
=
=
kTextHtmlPrefixClipboardDataWindows
+
aExpectedStringOrValidatorFn
+
kTextHtmlSuffixClipboardDataWindows
)
;
}
;
}
else
{
inputValidatorFn
=
function
(
aData
)
{
return
aData
.
replace
(
/
\
r
\
n
?
/
g
"
\
n
"
)
=
=
=
aExpectedStringOrValidatorFn
;
}
;
}
}
else
{
inputValidatorFn
=
aExpectedStringOrValidatorFn
;
}
let
maxPolls
=
aTimeout
?
aTimeout
/
100
:
50
;
async
function
putAndVerify
(
operationFn
validatorFn
flavor
expectFailure
)
{
await
operationFn
(
)
;
let
data
;
for
(
let
i
=
0
;
i
<
maxPolls
;
i
+
+
)
{
data
=
SpecialPowers
.
getClipboardData
(
flavor
)
;
if
(
validatorFn
(
data
)
)
{
if
(
preExpectedVal
)
{
preExpectedVal
=
null
;
}
else
{
SimpleTest
.
ok
(
!
expectFailure
"
Clipboard
has
the
given
value
:
'
"
+
data
+
"
'
"
)
;
}
return
data
;
}
await
new
Promise
(
resolve
=
>
{
SimpleTest
.
_originalSetTimeout
.
apply
(
window
[
resolve
100
]
)
;
}
)
;
}
let
errorMsg
=
Timed
out
while
polling
clipboard
for
{
preExpectedVal
?
"
initialized
"
:
"
requested
"
}
data
got
:
{
data
}
;
SimpleTest
.
ok
(
expectFailure
errorMsg
)
;
if
(
!
expectFailure
)
{
throw
new
Error
(
errorMsg
)
;
}
return
data
;
}
if
(
!
aExpectFailure
|
|
!
aDontInitializeClipboardIfExpectFailure
)
{
SimpleTest
.
info
(
Initializing
clipboard
with
"
{
preExpectedVal
}
"
.
.
.
)
;
await
putAndVerify
(
function
(
)
{
SpecialPowers
.
clipboardCopyString
(
preExpectedVal
)
;
}
function
(
aData
)
{
return
aData
=
=
preExpectedVal
;
}
"
text
/
plain
"
false
)
;
SimpleTest
.
info
(
"
Succeeded
initializing
clipboard
start
requested
things
.
.
.
"
)
;
}
else
{
preExpectedVal
=
null
;
}
return
putAndVerify
(
aSetupFn
inputValidatorFn
requestedFlavor
aExpectFailure
)
;
}
;
SimpleTest
.
waitForCondition
=
function
(
aCond
aCallback
aErrorMsg
)
{
this
.
promiseWaitForCondition
(
aCond
aErrorMsg
)
.
then
(
(
)
=
>
aCallback
(
)
)
;
}
;
SimpleTest
.
promiseWaitForCondition
=
async
function
(
aCond
aErrorMsg
)
{
for
(
let
tries
=
0
;
tries
<
30
;
+
+
tries
)
{
await
new
Promise
(
resolve
=
>
{
SimpleTest
.
_originalSetTimeout
.
apply
(
window
[
resolve
100
]
)
;
}
)
;
let
conditionPassed
;
try
{
conditionPassed
=
await
aCond
(
)
;
}
catch
(
e
)
{
ok
(
false
{
e
}
\
n
{
e
.
stack
}
)
;
conditionPassed
=
false
;
}
if
(
conditionPassed
)
{
return
;
}
}
ok
(
false
aErrorMsg
)
;
}
;
SimpleTest
.
executeSoon
=
function
(
aFunc
)
{
if
(
"
SpecialPowers
"
in
window
)
{
return
SpecialPowers
.
executeSoon
(
aFunc
window
)
;
}
setTimeout
(
aFunc
0
)
;
return
null
;
}
;
SimpleTest
.
registerCleanupFunction
=
function
(
aFunc
)
{
SimpleTest
.
_cleanupFunctions
.
push
(
aFunc
)
;
}
;
SimpleTest
.
registerTimeoutFunction
=
function
(
aFunc
)
{
SimpleTest
.
_timeoutFunctions
.
push
(
aFunc
)
;
}
;
SimpleTest
.
testInChaosMode
=
function
(
)
{
if
(
SimpleTest
.
_inChaosMode
)
{
return
;
}
SpecialPowers
.
DOMWindowUtils
.
enterChaosMode
(
)
;
SimpleTest
.
_inChaosMode
=
true
;
SimpleTest
.
requestLongerTimeout
(
20
)
;
}
;
SimpleTest
.
timeout
=
async
function
(
)
{
for
(
const
func
of
SimpleTest
.
_timeoutFunctions
)
{
await
func
(
)
;
}
SimpleTest
.
_timeoutFunctions
=
[
]
;
}
;
SimpleTest
.
finishWithFailure
=
function
(
msg
)
{
SimpleTest
.
ok
(
false
msg
)
;
SimpleTest
.
finish
(
)
;
}
;
SimpleTest
.
finish
=
function
(
)
{
if
(
SimpleTest
.
_alreadyFinished
)
{
var
err
=
"
TEST
-
UNEXPECTED
-
FAIL
|
SimpleTest
|
this
test
already
called
finish
!
"
;
if
(
parentRunner
)
{
parentRunner
.
structuredLogger
.
error
(
err
)
;
}
else
{
dump
(
err
+
"
\
n
"
)
;
}
}
if
(
SimpleTest
.
expected
=
=
"
fail
"
&
&
SimpleTest
.
num_failed
<
=
0
)
{
let
msg
=
"
We
expected
at
least
one
failure
"
;
let
test
=
{
result
:
false
name
:
"
fail
-
if
condition
in
manifest
"
diag
:
msg
}
;
let
successInfo
=
{
status
:
"
FAIL
"
expected
:
"
FAIL
"
message
:
"
TEST
-
KNOWN
-
FAIL
"
}
;
let
failureInfo
=
{
status
:
"
PASS
"
expected
:
"
FAIL
"
message
:
"
TEST
-
UNEXPECTED
-
PASS
"
}
;
SimpleTest
.
_logResult
(
test
successInfo
failureInfo
)
;
SimpleTest
.
_tests
.
push
(
test
)
;
}
else
if
(
usesFailurePatterns
(
)
)
{
SimpleTest
.
expected
.
forEach
(
(
[
pat
expected_count
]
i
)
=
>
{
let
count
=
SimpleTest
.
num_failed
[
i
]
;
let
diag
;
if
(
expected_count
=
=
=
null
&
&
count
=
=
0
)
{
diag
=
"
expected
some
failures
but
got
none
"
;
}
else
if
(
expected_count
!
=
=
null
&
&
expected_count
!
=
count
)
{
diag
=
expected
{
expected_count
}
failures
but
got
{
count
}
;
}
else
{
return
;
}
let
name
=
pat
?
failure
pattern
\
{
pat
}
\
in
this
test
:
"
failures
in
this
test
"
;
let
test
=
{
result
:
false
name
diag
}
;
let
successInfo
=
{
status
:
"
PASS
"
expected
:
"
PASS
"
message
:
"
TEST
-
PASS
"
}
;
let
failureInfo
=
{
status
:
"
FAIL
"
expected
:
"
PASS
"
message
:
"
TEST
-
UNEXPECTED
-
FAIL
"
}
;
SimpleTest
.
_logResult
(
test
successInfo
failureInfo
)
;
SimpleTest
.
_tests
.
push
(
test
)
;
}
)
;
}
SimpleTest
.
_timeoutFunctions
=
[
]
;
SimpleTest
.
testsLength
=
SimpleTest
.
_tests
.
length
;
SimpleTest
.
_alreadyFinished
=
true
;
if
(
SimpleTest
.
_inChaosMode
)
{
SpecialPowers
.
DOMWindowUtils
.
leaveChaosMode
(
)
;
SimpleTest
.
_inChaosMode
=
false
;
}
var
afterCleanup
=
async
function
(
)
{
SpecialPowers
.
removeFiles
(
)
;
if
(
SpecialPowers
.
DOMWindowUtils
.
isTestControllingRefreshes
)
{
SimpleTest
.
ok
(
false
"
test
left
refresh
driver
under
test
control
"
)
;
SpecialPowers
.
DOMWindowUtils
.
restoreNormalRefresh
(
)
;
}
if
(
SimpleTest
.
_expectingUncaughtException
)
{
SimpleTest
.
ok
(
false
"
expectUncaughtException
was
called
but
no
uncaught
exception
was
detected
!
"
)
;
}
if
(
!
SimpleTest
.
_tests
.
length
)
{
SimpleTest
.
ok
(
false
"
[
SimpleTest
.
finish
(
)
]
No
checks
actually
run
.
"
+
"
(
You
need
to
call
ok
(
)
is
(
)
or
similar
"
+
"
functions
at
least
once
.
Make
sure
you
use
"
+
"
SimpleTest
.
waitForExplicitFinish
(
)
if
you
need
"
+
"
it
.
)
"
)
;
}
let
workers
=
await
SpecialPowers
.
registeredServiceWorkers
(
)
;
let
promise
=
null
;
if
(
SimpleTest
.
_expectingRegisteredServiceWorker
)
{
if
(
workers
.
length
=
=
=
0
)
{
SimpleTest
.
ok
(
false
"
This
test
is
expected
to
leave
a
service
worker
registered
"
)
;
}
}
else
if
(
workers
.
length
)
{
let
FULL_PROFILE_WORKERS_TO_IGNORE
=
[
]
;
if
(
parentRunner
.
conditionedProfile
)
{
FULL_PROFILE_WORKERS_TO_IGNORE
=
[
"
https
:
/
/
www
.
youtube
.
com
/
sw
.
js
"
]
;
}
else
{
SimpleTest
.
ok
(
false
"
This
test
left
a
service
worker
registered
without
cleaning
it
up
"
)
;
}
for
(
let
worker
of
workers
)
{
if
(
FULL_PROFILE_WORKERS_TO_IGNORE
.
includes
(
worker
.
scriptSpec
)
)
{
continue
;
}
SimpleTest
.
ok
(
false
Left
over
worker
:
{
worker
.
scriptSpec
}
(
scope
:
{
worker
.
scope
}
)
)
;
}
promise
=
SpecialPowers
.
removeAllServiceWorkerData
(
)
;
}
function
finish
(
)
{
if
(
parentRunner
)
{
parentRunner
.
testFinished
(
SimpleTest
.
_tests
)
;
}
if
(
!
parentRunner
|
|
parentRunner
.
showTestReport
)
{
SpecialPowers
.
flushPermissions
(
function
(
)
{
SpecialPowers
.
flushPrefEnv
(
function
(
)
{
SimpleTest
.
showReport
(
)
;
}
)
;
}
)
;
}
}
if
(
promise
)
{
promise
.
then
(
finish
)
;
}
else
{
finish
(
)
;
}
}
;
var
executeCleanupFunction
=
function
(
)
{
var
func
=
SimpleTest
.
_cleanupFunctions
.
pop
(
)
;
if
(
!
func
)
{
afterCleanup
(
)
;
return
;
}
var
ret
;
try
{
ret
=
func
(
)
;
}
catch
(
ex
)
{
SimpleTest
.
ok
(
false
"
Cleanup
function
threw
exception
:
"
+
ex
)
;
}
if
(
ret
&
&
ret
.
constructor
.
name
=
=
"
Promise
"
)
{
ret
.
then
(
executeCleanupFunction
ex
=
>
SimpleTest
.
ok
(
false
"
Cleanup
promise
rejected
:
"
+
ex
)
)
;
}
else
{
executeCleanupFunction
(
)
;
}
}
;
executeCleanupFunction
(
)
;
SpecialPowers
.
notifyObservers
(
null
"
test
-
complete
"
)
;
}
;
SimpleTest
.
monitorConsole
=
function
(
continuation
msgs
forbidUnexpectedMsgs
)
{
if
(
SimpleTest
.
_stopOnLoad
)
{
ok
(
false
"
Console
monitoring
requires
use
of
waitForExplicitFinish
.
"
)
;
}
function
msgMatches
(
msg
pat
)
{
for
(
var
k
in
pat
)
{
if
(
!
(
k
in
msg
)
)
{
return
false
;
}
if
(
pat
[
k
]
instanceof
RegExp
&
&
typeof
msg
[
k
]
=
=
=
"
string
"
)
{
if
(
!
pat
[
k
]
.
test
(
msg
[
k
]
)
)
{
return
false
;
}
}
else
if
(
msg
[
k
]
!
=
=
pat
[
k
]
)
{
return
false
;
}
}
return
true
;
}
var
forbiddenMsgs
=
[
]
;
var
i
=
0
;
while
(
i
<
msgs
.
length
)
{
let
pat
=
msgs
[
i
]
;
if
(
"
forbid
"
in
pat
)
{
var
forbid
=
pat
.
forbid
;
delete
pat
.
forbid
;
if
(
forbid
)
{
forbiddenMsgs
.
push
(
pat
)
;
msgs
.
splice
(
i
1
)
;
continue
;
}
}
i
+
+
;
}
var
counter
=
0
;
var
assertionLabel
=
JSON
.
stringify
(
msgs
)
;
function
listener
(
msg
)
{
if
(
msg
.
message
=
=
=
"
SENTINEL
"
&
&
!
msg
.
isScriptError
)
{
is
(
counter
msgs
.
length
"
monitorConsole
|
number
of
messages
"
+
assertionLabel
)
;
SimpleTest
.
executeSoon
(
continuation
)
;
return
;
}
for
(
let
pat
of
forbiddenMsgs
)
{
if
(
msgMatches
(
msg
pat
)
)
{
ok
(
false
"
monitorConsole
|
observed
forbidden
message
"
+
JSON
.
stringify
(
msg
)
)
;
return
;
}
}
if
(
counter
>
=
msgs
.
length
)
{
var
str
=
"
monitorConsole
|
extra
message
|
"
+
JSON
.
stringify
(
msg
)
;
if
(
forbidUnexpectedMsgs
)
{
ok
(
false
str
)
;
}
else
{
info
(
str
)
;
}
return
;
}
var
matches
=
msgMatches
(
msg
msgs
[
counter
]
)
;
if
(
forbidUnexpectedMsgs
)
{
ok
(
matches
"
monitorConsole
|
[
"
+
counter
+
"
]
must
match
"
+
JSON
.
stringify
(
msg
)
)
;
}
else
{
info
(
"
monitorConsole
|
[
"
+
counter
+
"
]
"
+
(
matches
?
"
matched
"
:
"
did
not
match
"
)
+
JSON
.
stringify
(
msg
)
)
;
}
if
(
matches
)
{
counter
+
+
;
}
}
SpecialPowers
.
registerConsoleListener
(
listener
)
;
}
;
SimpleTest
.
endMonitorConsole
=
function
(
)
{
SpecialPowers
.
postConsoleSentinel
(
)
;
}
;
SimpleTest
.
expectConsoleMessages
=
function
(
testfn
msgs
continuation
)
{
SimpleTest
.
monitorConsole
(
continuation
msgs
)
;
testfn
(
)
;
SimpleTest
.
executeSoon
(
SimpleTest
.
endMonitorConsole
)
;
}
;
SimpleTest
.
runTestExpectingConsoleMessages
=
function
(
testfn
msgs
)
{
SimpleTest
.
waitForExplicitFinish
(
)
;
SimpleTest
.
expectConsoleMessages
(
testfn
msgs
SimpleTest
.
finish
)
;
}
;
SimpleTest
.
expectChildProcessCrash
=
function
(
)
{
if
(
parentRunner
)
{
parentRunner
.
expectChildProcessCrash
(
)
;
}
}
;
SimpleTest
.
expectUncaughtException
=
function
(
aExpecting
)
{
SimpleTest
.
_expectingUncaughtException
=
aExpecting
=
=
=
void
0
|
|
!
!
aExpecting
;
}
;
SimpleTest
.
isExpectingUncaughtException
=
function
(
)
{
return
SimpleTest
.
_expectingUncaughtException
;
}
;
SimpleTest
.
ignoreAllUncaughtExceptions
=
function
(
aIgnoring
)
{
SimpleTest
.
_ignoringAllUncaughtExceptions
=
aIgnoring
=
=
=
void
0
|
|
!
!
aIgnoring
;
}
;
SimpleTest
.
isIgnoringAllUncaughtExceptions
=
function
(
)
{
return
SimpleTest
.
_ignoringAllUncaughtExceptions
;
}
;
SimpleTest
.
expectRegisteredServiceWorker
=
function
(
)
{
SimpleTest
.
_expectingRegisteredServiceWorker
=
true
;
}
;
SimpleTest
.
reset
=
function
(
)
{
SimpleTest
.
_ignoringAllUncaughtExceptions
=
false
;
SimpleTest
.
_expectingUncaughtException
=
false
;
SimpleTest
.
_expectingRegisteredServiceWorker
=
false
;
SimpleTest
.
_bufferedMessages
=
[
]
;
}
;
if
(
isPrimaryTestWindow
)
{
addLoadEvent
(
function
(
)
{
if
(
SimpleTest
.
_stopOnLoad
)
{
SimpleTest
.
finish
(
)
;
}
}
)
;
}
SimpleTest
.
DNE
=
{
dne
:
"
Does
not
exist
"
}
;
SimpleTest
.
LF
=
"
\
r
\
n
"
;
SimpleTest
.
_deepCheck
=
function
(
e1
e2
stack
seen
)
{
var
ok
=
false
;
if
(
Object
.
is
(
e1
e2
)
)
{
ok
=
true
;
}
else
if
(
typeof
e1
!
=
"
object
"
|
|
typeof
e2
!
=
"
object
"
|
|
e1
=
=
=
null
|
|
e2
=
=
=
null
)
{
ok
=
false
;
}
else
if
(
e1
=
=
SimpleTest
.
DNE
|
|
e2
=
=
SimpleTest
.
DNE
)
{
ok
=
false
;
}
else
if
(
SimpleTest
.
isa
(
e1
"
Array
"
)
&
&
SimpleTest
.
isa
(
e2
"
Array
"
)
)
{
ok
=
SimpleTest
.
_eqArray
(
e1
e2
stack
seen
)
;
}
else
{
ok
=
SimpleTest
.
_eqAssoc
(
e1
e2
stack
seen
)
;
}
return
ok
;
}
;
SimpleTest
.
_eqArray
=
function
(
a1
a2
stack
seen
)
{
if
(
a1
=
=
a2
)
{
return
true
;
}
for
(
var
j
=
0
;
j
<
seen
.
length
;
j
+
+
)
{
if
(
seen
[
j
]
[
0
]
=
=
a1
)
{
return
seen
[
j
]
[
1
]
=
=
a2
;
}
}
seen
.
push
(
[
a1
a2
]
)
;
var
ok
=
true
;
var
max
=
Math
.
max
(
a1
.
length
a2
.
length
)
;
if
(
max
=
=
0
)
{
return
SimpleTest
.
_eqAssoc
(
a1
a2
stack
seen
)
;
}
for
(
var
i
=
0
;
i
<
max
;
i
+
+
)
{
var
e1
=
i
<
a1
.
length
?
a1
[
i
]
:
SimpleTest
.
DNE
;
var
e2
=
i
<
a2
.
length
?
a2
[
i
]
:
SimpleTest
.
DNE
;
stack
.
push
(
{
type
:
"
Array
"
idx
:
i
vals
:
[
e1
e2
]
}
)
;
ok
=
SimpleTest
.
_deepCheck
(
e1
e2
stack
seen
)
;
if
(
ok
)
{
stack
.
pop
(
)
;
}
else
{
break
;
}
}
return
ok
;
}
;
SimpleTest
.
_eqAssoc
=
function
(
o1
o2
stack
seen
)
{
if
(
o1
=
=
o2
)
{
return
true
;
}
seen
=
seen
.
slice
(
0
)
;
for
(
let
j
=
0
;
j
<
seen
.
length
;
j
+
+
)
{
if
(
seen
[
j
]
[
0
]
=
=
o1
)
{
return
seen
[
j
]
[
1
]
=
=
o2
;
}
}
seen
.
push
(
[
o1
o2
]
)
;
var
ok
=
true
;
var
o1Size
=
0
;
for
(
let
i
in
o1
)
{
o1Size
+
+
;
}
var
o2Size
=
0
;
for
(
let
i
in
o2
)
{
o2Size
+
+
;
}
var
bigger
=
o1Size
>
o2Size
?
o1
:
o2
;
for
(
let
i
in
bigger
)
{
var
e1
=
i
in
o1
?
o1
[
i
]
:
SimpleTest
.
DNE
;
var
e2
=
i
in
o2
?
o2
[
i
]
:
SimpleTest
.
DNE
;
stack
.
push
(
{
type
:
"
Object
"
idx
:
i
vals
:
[
e1
e2
]
}
)
;
ok
=
SimpleTest
.
_deepCheck
(
e1
e2
stack
seen
)
;
if
(
ok
)
{
stack
.
pop
(
)
;
}
else
{
break
;
}
}
return
ok
;
}
;
SimpleTest
.
_formatStack
=
function
(
stack
)
{
var
variable
=
"
Foo
"
;
for
(
let
i
=
0
;
i
<
stack
.
length
;
i
+
+
)
{
var
entry
=
stack
[
i
]
;
var
type
=
entry
.
type
;
var
idx
=
entry
.
idx
;
if
(
idx
!
=
null
)
{
if
(
type
=
=
"
Array
"
)
{
variable
+
=
"
[
"
+
idx
+
"
]
"
;
}
else
{
idx
=
idx
.
replace
(
"
'
"
"
\
\
'
"
)
;
variable
+
=
"
[
'
"
+
idx
+
"
'
]
"
;
}
}
}
var
vals
=
stack
[
stack
.
length
-
1
]
.
vals
.
slice
(
0
2
)
;
var
vars
=
[
variable
.
replace
(
"
Foo
"
"
got
"
)
variable
.
replace
(
"
Foo
"
"
expected
"
)
]
;
var
out
=
"
Structures
begin
differing
at
:
"
+
SimpleTest
.
LF
;
for
(
let
i
=
0
;
i
<
vals
.
length
;
i
+
+
)
{
var
val
=
vals
[
i
]
;
if
(
val
=
=
=
SimpleTest
.
DNE
)
{
val
=
"
Does
not
exist
"
;
}
else
{
val
=
repr
(
val
)
;
}
out
+
=
vars
[
i
]
+
"
=
"
+
val
+
SimpleTest
.
LF
;
}
return
"
"
+
out
;
}
;
SimpleTest
.
isDeeply
=
function
(
it
as
name
)
{
var
stack
=
[
{
vals
:
[
it
as
]
}
]
;
var
seen
=
[
]
;
if
(
SimpleTest
.
_deepCheck
(
it
as
stack
seen
)
)
{
SimpleTest
.
record
(
true
name
)
;
}
else
{
SimpleTest
.
record
(
false
name
SimpleTest
.
_formatStack
(
stack
)
)
;
}
}
;
SimpleTest
.
typeOf
=
function
(
object
)
{
var
c
=
Object
.
prototype
.
toString
.
apply
(
object
)
;
var
name
=
c
.
substring
(
8
c
.
length
-
1
)
;
if
(
name
!
=
"
Object
"
)
{
return
name
;
}
if
(
/
function
(
[
^
(
\
s
]
+
)
/
.
test
(
Function
.
toString
.
call
(
object
.
constructor
)
)
)
{
return
RegExp
.
1
;
}
return
name
;
}
;
SimpleTest
.
isa
=
function
(
object
clas
)
{
return
SimpleTest
.
typeOf
(
object
)
=
=
clas
;
}
;
var
ok
=
SimpleTest
.
ok
;
var
record
=
SimpleTest
.
record
;
var
is
=
SimpleTest
.
is
;
var
isfuzzy
=
SimpleTest
.
isfuzzy
;
var
isnot
=
SimpleTest
.
isnot
;
var
todo
=
SimpleTest
.
todo
;
var
todo_is
=
SimpleTest
.
todo_is
;
var
todo_isnot
=
SimpleTest
.
todo_isnot
;
var
isDeeply
=
SimpleTest
.
isDeeply
;
var
info
=
SimpleTest
.
info
;
var
gOldOnError
=
window
.
onerror
;
window
.
onerror
=
function
simpletestOnerror
(
errorMsg
url
lineNumber
columnNumber
originalException
)
{
var
isExpected
=
!
!
SimpleTest
.
_expectingUncaughtException
;
var
message
=
(
isExpected
?
"
expected
"
:
"
"
)
+
"
uncaught
exception
"
;
var
error
=
errorMsg
+
"
at
"
;
try
{
error
+
=
originalException
.
stack
;
}
catch
(
e
)
{
error
+
=
url
+
"
:
"
+
lineNumber
+
"
:
"
+
columnNumber
;
}
if
(
!
SimpleTest
.
_ignoringAllUncaughtExceptions
)
{
if
(
!
SimpleTest
.
_alreadyFinished
)
{
SimpleTest
.
record
(
isExpected
message
error
)
;
}
SimpleTest
.
_expectingUncaughtException
=
false
;
}
else
{
SimpleTest
.
todo
(
false
message
+
"
:
"
+
error
)
;
}
if
(
gOldOnError
)
{
try
{
gOldOnError
(
errorMsg
url
lineNumber
)
;
}
catch
(
e
)
{
SimpleTest
.
info
(
"
Exception
thrown
by
gOldOnError
(
)
:
"
+
e
)
;
if
(
e
.
stack
)
{
SimpleTest
.
info
(
"
JavaScript
error
stack
:
\
n
"
+
e
.
stack
)
;
}
}
}
if
(
!
SimpleTest
.
_stopOnLoad
&
&
!
isExpected
&
&
!
SimpleTest
.
_alreadyFinished
)
{
SimpleTest
.
executeSoon
(
SimpleTest
.
finish
)
;
}
}
;
var
gAndroidSdk
=
null
;
function
getAndroidSdk
(
)
{
if
(
gAndroidSdk
=
=
=
null
)
{
var
iframe
=
document
.
documentElement
.
appendChild
(
document
.
createElement
(
"
iframe
"
)
)
;
iframe
.
style
.
display
=
"
none
"
;
var
nav
=
iframe
.
contentWindow
.
navigator
;
if
(
!
nav
.
userAgent
.
includes
(
"
Mobile
"
)
&
&
!
nav
.
userAgent
.
includes
(
"
Tablet
"
)
)
{
gAndroidSdk
=
-
1
;
}
else
{
var
versionString
=
nav
.
userAgent
.
includes
(
"
Android
"
)
?
"
version
"
:
"
sdk_version
"
;
gAndroidSdk
=
SpecialPowers
.
Services
.
sysinfo
.
getProperty
(
versionString
)
;
}
document
.
documentElement
.
removeChild
(
iframe
)
;
}
return
gAndroidSdk
;
}
var
add_task
=
(
function
(
)
{
var
task_list
=
[
]
;
var
run_only_this_task
=
null
;
function
isGenerator
(
value
)
{
return
(
value
&
&
typeof
value
=
=
=
"
object
"
&
&
typeof
value
.
next
=
=
=
"
function
"
)
;
}
return
function
(
generatorFunction
options
=
{
isSetup
:
false
}
)
{
if
(
task_list
.
length
=
=
=
0
)
{
if
(
!
SimpleTest
)
{
throw
new
Error
(
"
SimpleTest
not
available
.
"
)
;
}
SimpleTest
.
waitForExplicitFinish
(
)
;
setTimeout
(
function
nextTick
(
)
{
if
(
typeof
window
!
=
=
"
undefined
"
&
&
typeof
HTMLDocument
!
=
=
"
undefined
"
&
&
window
.
document
instanceof
HTMLDocument
&
&
window
.
document
.
readyState
!
=
=
"
complete
"
)
{
setTimeout
(
nextTick
)
;
return
;
}
(
async
(
)
=
>
{
function
skipTask
(
name
)
{
let
logger
=
parentRunner
&
&
parentRunner
.
structuredLogger
;
if
(
!
logger
)
{
info
(
"
add_task
|
Skipping
test
"
+
name
)
;
return
;
}
logger
.
deactivateBuffering
(
)
;
logger
.
testStatus
(
SimpleTest
.
_getCurrentTestURL
(
)
name
"
SKIP
"
)
;
logger
.
warning
(
"
add_task
|
Skipping
test
"
+
name
)
;
logger
.
activateBuffering
(
)
;
}
try
{
for
(
var
task
of
task_list
)
{
var
name
=
task
.
name
|
|
"
"
;
if
(
task
.
__skipMe
|
|
(
run_only_this_task
&
&
task
!
=
run_only_this_task
)
)
{
skipTask
(
name
)
;
continue
;
}
const
taskInfo
=
action
=
>
info
(
{
task
.
isSetup
?
"
add_setup
"
:
"
add_task
"
}
|
{
action
}
{
name
}
)
;
taskInfo
(
"
Entering
"
)
;
let
result
=
await
task
(
)
;
if
(
isGenerator
(
result
)
)
{
ok
(
false
"
Task
returned
a
generator
"
)
;
}
taskInfo
(
"
Leaving
"
)
;
}
}
catch
(
ex
)
{
try
{
let
serializedEx
;
if
(
isErrorObj
(
ex
)
)
{
serializedEx
=
{
ex
}
;
}
else
{
serializedEx
=
JSON
.
stringify
(
ex
)
;
}
SimpleTest
.
record
(
false
serializedEx
"
Should
not
throw
any
errors
"
ex
.
stack
)
;
}
catch
(
ex2
)
{
SimpleTest
.
record
(
false
"
(
The
exception
cannot
be
converted
to
string
.
)
"
"
Should
not
throw
any
errors
"
ex
.
stack
)
;
}
}
SimpleTest
.
finish
(
)
;
}
)
(
)
;
}
)
;
}
generatorFunction
.
skip
=
(
)
=
>
(
generatorFunction
.
__skipMe
=
true
)
;
generatorFunction
.
only
=
(
)
=
>
(
run_only_this_task
=
generatorFunction
)
;
if
(
options
.
isSetup
)
{
generatorFunction
.
isSetup
=
true
;
let
lastSetupIndex
=
task_list
.
findLastIndex
(
t
=
>
t
.
isSetup
)
+
1
;
task_list
.
splice
(
lastSetupIndex
0
generatorFunction
)
;
}
else
{
task_list
.
push
(
generatorFunction
)
;
}
return
generatorFunction
;
}
;
}
)
(
)
;
function
add_setup
(
generatorFunction
)
{
return
add_task
(
generatorFunction
{
isSetup
:
true
}
)
;
}
if
(
usesFailurePatterns
(
)
)
{
SimpleTest
.
requestCompleteLog
(
)
;
}
addEventListener
(
"
message
"
async
event
=
>
{
if
(
event
.
data
=
=
"
SimpleTest
:
timeout
"
)
{
await
SimpleTest
.
timeout
(
)
;
SimpleTest
.
finish
(
)
;
}
}
)
;
