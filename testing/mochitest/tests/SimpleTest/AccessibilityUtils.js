"
use
strict
"
;
this
.
AccessibilityUtils
=
(
function
(
)
{
const
FORCE_DISABLE_ACCESSIBILITY_PREF
=
"
accessibility
.
force_disabled
"
;
const
{
STATE_FOCUSABLE
STATE_INVISIBLE
STATE_LINKED
STATE_UNAVAILABLE
}
=
Ci
.
nsIAccessibleStates
;
const
CLICK_ACTION
=
"
click
"
;
const
KEYBOARD_FOCUSABLE_ROLES
=
new
Set
(
[
Ci
.
nsIAccessibleRole
.
ROLE_BUTTONMENU
Ci
.
nsIAccessibleRole
.
ROLE_CHECKBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_COMBOBOX
Ci
.
nsIAccessibleRole
.
ROLE_EDITCOMBOBOX
Ci
.
nsIAccessibleRole
.
ROLE_ENTRY
Ci
.
nsIAccessibleRole
.
ROLE_LINK
Ci
.
nsIAccessibleRole
.
ROLE_LISTBOX
Ci
.
nsIAccessibleRole
.
ROLE_PASSWORD_TEXT
Ci
.
nsIAccessibleRole
.
ROLE_PUSHBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_RADIOBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_SLIDER
Ci
.
nsIAccessibleRole
.
ROLE_SPINBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_SUMMARY
Ci
.
nsIAccessibleRole
.
ROLE_SWITCH
Ci
.
nsIAccessibleRole
.
ROLE_TOGGLE_BUTTON
]
)
;
const
INTERACTIVE_ROLES
=
new
Set
(
[
.
.
.
KEYBOARD_FOCUSABLE_ROLES
Ci
.
nsIAccessibleRole
.
ROLE_CHECK_MENU_ITEM
Ci
.
nsIAccessibleRole
.
ROLE_CHECK_RICH_OPTION
Ci
.
nsIAccessibleRole
.
ROLE_COMBOBOX_OPTION
Ci
.
nsIAccessibleRole
.
ROLE_MENUITEM
Ci
.
nsIAccessibleRole
.
ROLE_OPTION
Ci
.
nsIAccessibleRole
.
ROLE_OUTLINE
Ci
.
nsIAccessibleRole
.
ROLE_OUTLINEITEM
Ci
.
nsIAccessibleRole
.
ROLE_PAGETAB
Ci
.
nsIAccessibleRole
.
ROLE_PARENT_MENUITEM
Ci
.
nsIAccessibleRole
.
ROLE_RADIO_MENU_ITEM
Ci
.
nsIAccessibleRole
.
ROLE_RICH_OPTION
]
)
;
const
INTERACTIVE_IF_FOCUSABLE_ROLES
=
new
Set
(
[
Ci
.
nsIAccessibleRole
.
ROLE_ARTICLE
Ci
.
nsIAccessibleRole
.
ROLE_COLUMNHEADER
Ci
.
nsIAccessibleRole
.
ROLE_GRID_CELL
Ci
.
nsIAccessibleRole
.
ROLE_MENUBAR
Ci
.
nsIAccessibleRole
.
ROLE_MENUPOPUP
Ci
.
nsIAccessibleRole
.
ROLE_PAGETABLIST
Ci
.
nsIAccessibleRole
.
ROLE_ROWHEADER
Ci
.
nsIAccessibleRole
.
ROLE_SCROLLBAR
Ci
.
nsIAccessibleRole
.
ROLE_SEPARATOR
Ci
.
nsIAccessibleRole
.
ROLE_TOOLBAR
]
)
;
const
FORM_ROLES
=
new
Set
(
[
Ci
.
nsIAccessibleRole
.
ROLE_CHECKBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_CHECK_RICH_OPTION
Ci
.
nsIAccessibleRole
.
ROLE_COMBOBOX
Ci
.
nsIAccessibleRole
.
ROLE_EDITCOMBOBOX
Ci
.
nsIAccessibleRole
.
ROLE_ENTRY
Ci
.
nsIAccessibleRole
.
ROLE_LISTBOX
Ci
.
nsIAccessibleRole
.
ROLE_PASSWORD_TEXT
Ci
.
nsIAccessibleRole
.
ROLE_PROGRESSBAR
Ci
.
nsIAccessibleRole
.
ROLE_RADIOBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_SLIDER
Ci
.
nsIAccessibleRole
.
ROLE_SPINBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_SWITCH
]
)
;
const
DEFAULT_ENV
=
Object
.
freeze
(
{
actionCountRule
:
true
focusableRule
:
true
ifClickableThenInteractiveRule
:
true
interactiveRule
:
true
labelRule
:
true
mustBeEnabled
:
true
mustHaveAccessibleRule
:
true
nonNegativeTabIndexRule
:
true
}
)
;
let
gA11YChecks
=
false
;
let
gEnv
=
{
.
.
.
DEFAULT_ENV
}
;
function
getAriaRoles
(
accessible
)
{
try
{
return
accessible
.
attributes
.
getStringProperty
(
"
xml
-
roles
"
)
;
}
catch
(
e
)
{
}
return
"
"
;
}
function
getLabels
(
accessible
)
{
const
relation
=
accessible
.
getRelationByType
(
Ci
.
nsIAccessibleRelation
.
RELATION_LABELLED_BY
)
;
return
[
.
.
.
relation
.
getTargets
(
)
.
enumerate
(
Ci
.
nsIAccessible
)
]
;
}
function
hasHiddenAttribute
(
accessible
)
{
let
hidden
=
false
;
try
{
hidden
=
accessible
.
attributes
.
getStringProperty
(
"
hidden
"
)
;
}
catch
(
e
)
{
}
return
hidden
&
&
hidden
=
=
=
"
true
"
;
}
function
isHidden
(
accessible
)
{
if
(
!
accessible
)
{
return
true
;
}
while
(
accessible
)
{
if
(
hasHiddenAttribute
(
accessible
)
)
{
return
true
;
}
accessible
=
accessible
.
parent
;
}
return
false
;
}
function
matchState
(
accessible
stateToMatch
)
{
const
state
=
{
}
;
accessible
.
getState
(
state
{
}
)
;
return
!
!
(
state
.
value
&
stateToMatch
)
;
}
function
isKeyboardFocusableBrowserToolbarButton
(
accessible
)
{
const
node
=
accessible
.
DOMNode
;
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
const
toolbar
=
node
.
closest
(
"
toolbar
"
)
|
|
node
.
flattenedTreeParentNode
.
closest
(
"
toolbar
"
)
;
if
(
!
toolbar
|
|
toolbar
.
getAttribute
(
"
keyNav
"
)
!
=
"
true
"
)
{
return
false
;
}
if
(
node
.
getAttribute
(
"
keyNav
"
)
=
=
"
false
"
)
{
const
ariaRoles
=
getAriaRoles
(
accessible
)
;
return
(
ariaRoles
.
includes
(
"
button
"
)
|
|
accessible
.
role
=
=
Ci
.
nsIAccessibleRole
.
ROLE_PUSHBUTTON
)
;
}
return
node
.
ownerGlobal
.
ToolbarKeyboardNavigator
.
_isButton
(
node
)
;
}
function
isKeyboardFocusableFxviewControlInApplication
(
accessible
)
{
const
node
=
accessible
.
DOMNode
;
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
if
(
!
node
.
className
.
includes
(
"
fxview
-
tab
-
row
-
"
)
|
|
(
accessible
.
role
!
=
Ci
.
nsIAccessibleRole
.
ROLE_PUSHBUTTON
&
&
accessible
.
role
!
=
Ci
.
nsIAccessibleRole
.
ROLE_LINK
)
)
{
return
false
;
}
const
listitemAcc
=
accessible
.
parent
;
const
listAcc
=
listitemAcc
.
parent
;
if
(
(
!
listAcc
|
|
listAcc
.
role
!
=
Ci
.
nsIAccessibleRole
.
ROLE_LIST
)
&
&
(
!
listitemAcc
|
|
listitemAcc
.
role
!
=
Ci
.
nsIAccessibleRole
.
ROLE_LISTITEM
)
)
{
return
false
;
}
if
(
node
.
tabIndex
&
&
matchState
(
accessible
STATE_FOCUSABLE
)
&
&
!
matchState
(
listitemAcc
STATE_FOCUSABLE
)
)
{
const
childCount
=
listAcc
.
childCount
;
let
foundFocusable
=
false
;
for
(
let
c
=
0
;
c
<
childCount
;
c
+
+
)
{
const
listitem
=
listAcc
.
getChildAt
(
c
)
;
const
listitemChildCount
=
listitem
.
childCount
;
for
(
let
i
=
0
;
i
<
listitemChildCount
;
i
+
+
)
{
const
listitemControl
=
listitem
.
getChildAt
(
i
)
;
if
(
listitemControl
.
DOMNode
.
tabIndex
=
=
0
)
{
if
(
foundFocusable
)
{
a11yFail
(
"
Only
one
control
should
be
focusable
in
a
list
"
accessible
)
;
return
false
;
}
foundFocusable
=
true
;
}
}
}
return
foundFocusable
;
}
return
false
;
}
function
isKeyboardFocusableOption
(
accessible
)
{
const
node
=
accessible
.
DOMNode
;
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
const
urlbarListbox
=
node
.
closest
(
"
.
urlbarView
-
results
"
)
;
if
(
!
urlbarListbox
|
|
urlbarListbox
.
getAttribute
(
"
role
"
)
!
=
"
listbox
"
)
{
return
false
;
}
return
node
.
getAttribute
(
"
role
"
)
=
=
"
option
"
;
}
function
isKeyboardFocusablePanelMultiViewControl
(
accessible
)
{
const
node
=
accessible
.
DOMNode
;
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
const
panelview
=
node
.
closest
(
"
panelview
"
)
;
if
(
!
panelview
|
|
panelview
.
hasAttribute
(
"
disablekeynav
"
)
)
{
return
false
;
}
return
(
node
.
ownerGlobal
.
PanelView
.
forNode
(
panelview
)
.
_tabNavigableWalker
.
filter
(
node
)
=
=
NodeFilter
.
FILTER_ACCEPT
)
;
}
function
isKeyboardFocusableTabInTablist
(
accessible
)
{
const
node
=
accessible
.
DOMNode
;
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
if
(
accessible
.
role
!
=
Ci
.
nsIAccessibleRole
.
ROLE_PAGETAB
)
{
return
false
;
}
const
tablist
=
findNonGenericParentAccessible
(
accessible
)
;
if
(
!
tablist
|
|
tablist
.
role
!
=
Ci
.
nsIAccessibleRole
.
ROLE_PAGETABLIST
)
{
return
false
;
}
let
foundFocusable
=
false
;
for
(
const
tab
of
findNonGenericChildrenAccessible
(
tablist
)
)
{
const
isWhitespace
=
tab
.
role
=
=
Ci
.
nsIAccessibleRole
.
ROLE_TEXT_LEAF
&
&
tab
.
DOMNode
.
textContent
.
trim
(
)
.
length
=
=
=
0
;
if
(
tab
.
role
!
=
Ci
.
nsIAccessibleRole
.
ROLE_PAGETAB
&
&
!
isWhitespace
)
{
a11yFail
(
"
Only
tabs
should
be
included
in
a
tablist
"
accessible
)
;
}
if
(
tab
.
DOMNode
.
tabIndex
=
=
0
)
{
if
(
foundFocusable
)
{
a11yFail
(
"
Only
one
tab
should
be
focusable
in
a
tablist
"
accessible
)
;
return
false
;
}
foundFocusable
=
true
;
}
}
return
foundFocusable
;
}
function
isKeyboardFocusableUrlbarButton
(
accessible
)
{
const
node
=
accessible
.
DOMNode
;
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
const
isUrlBar
=
node
.
closest
(
"
.
urlbarView
>
.
search
-
one
-
offs
"
)
?
.
getAttribute
(
"
disabletab
"
)
=
=
"
true
"
;
const
isSearchBar
=
node
.
closest
(
"
#
PopupSearchAutoComplete
>
.
search
-
one
-
offs
"
)
?
.
getAttribute
(
"
is_searchbar
"
)
=
=
"
true
"
;
return
(
(
isUrlBar
|
|
isSearchBar
)
&
&
node
.
getAttribute
(
"
tabindex
"
)
=
=
"
-
1
"
&
&
node
.
tagName
=
=
"
button
"
&
&
node
.
classList
.
contains
(
"
searchbar
-
engine
-
one
-
off
-
item
"
)
)
;
}
function
isKeyboardFocusableXULTab
(
accessible
)
{
const
node
=
accessible
.
DOMNode
;
return
node
&
&
XULElement
.
isInstance
(
node
)
&
&
node
.
tagName
=
=
"
tab
"
;
}
function
isAccessibleGridcell
(
node
)
{
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
const
accessible
=
getAccessible
(
node
)
;
if
(
!
accessible
|
|
accessible
.
role
!
=
Ci
.
nsIAccessibleRole
.
ROLE_GRID_CELL
)
{
return
false
;
}
const
gridRow
=
accessible
.
parent
;
if
(
!
gridRow
|
|
gridRow
.
role
!
=
Ci
.
nsIAccessibleRole
.
ROLE_ROW
)
{
return
false
;
}
let
grid
=
gridRow
.
parent
;
if
(
!
grid
)
{
return
false
;
}
if
(
grid
.
role
=
=
Ci
.
nsIAccessibleRole
.
ROLE_GROUPING
)
{
grid
=
grid
.
parent
;
if
(
!
grid
|
|
grid
.
role
!
=
Ci
.
nsIAccessibleRole
.
ROLE_GRID
)
{
return
false
;
}
}
let
foundFocusable
=
false
;
for
(
const
gridCell
of
grid
.
DOMNode
.
querySelectorAll
(
"
td
[
role
=
gridcell
]
"
)
)
{
if
(
gridCell
.
tabIndex
=
=
0
)
{
if
(
foundFocusable
)
{
a11yFail
(
"
Only
one
grid
cell
should
be
focusable
in
a
grid
"
accessible
)
;
return
false
;
}
foundFocusable
=
true
;
}
}
return
foundFocusable
;
}
function
isInaccessibleXulTreecol
(
node
)
{
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
const
listheader
=
node
.
flattenedTreeParentNode
;
if
(
listheader
.
tagName
!
=
=
"
listheader
"
|
|
node
.
tagName
!
=
=
"
treecol
"
)
{
return
false
;
}
return
true
;
}
function
isUnlabeledUrlBarCombobox
(
node
)
{
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
let
ariaRole
=
node
.
getAttribute
(
"
role
"
)
;
const
isMozInputBox
=
node
.
tagName
=
=
"
moz
-
input
-
box
"
&
&
node
.
classList
.
contains
(
"
urlbar
-
input
-
box
"
)
;
const
isSearchbar
=
node
.
tagName
=
=
"
searchbar
"
&
&
node
.
id
=
=
"
searchbar
"
;
return
(
isMozInputBox
|
|
isSearchbar
)
&
&
ariaRole
=
=
"
combobox
"
;
}
function
isUnlabeledUrlBarOption
(
node
)
{
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
const
role
=
getAccessible
(
node
)
?
.
role
;
const
isOption
=
node
.
tagName
=
=
"
span
"
&
&
node
.
getAttribute
(
"
role
"
)
=
=
"
option
"
&
&
node
.
classList
.
contains
(
"
urlbarView
-
row
-
inner
"
)
;
const
isMenuItem
=
node
.
tagName
=
=
"
menuitem
"
&
&
role
=
=
Ci
.
nsIAccessibleRole
.
ROLE_MENUITEM
&
&
node
.
classList
.
contains
(
"
urlbarView
-
result
-
menuitem
"
)
;
return
isOption
|
|
isMenuItem
;
}
function
isUnlabeledMenuitem
(
node
)
{
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
const
hasLabel
=
node
.
querySelector
(
"
label
description
"
)
;
const
isMenuItem
=
node
.
getAttribute
(
"
role
"
)
=
=
"
menuitem
"
|
|
(
node
.
tagName
=
=
"
richlistitem
"
&
&
node
.
classList
.
contains
(
"
autocomplete
-
richlistitem
"
)
)
|
|
(
node
.
tagName
=
=
"
menuitem
"
&
&
node
.
classList
.
contains
(
"
urlbarView
-
result
-
menuitem
"
)
)
;
let
parentNode
=
node
.
getRootNode
(
)
.
host
?
?
node
.
parentNode
;
const
isParentMenu
=
parentNode
.
getAttribute
(
"
role
"
)
=
=
"
menu
"
|
|
(
parentNode
.
tagName
=
=
"
richlistbox
"
&
&
parentNode
.
classList
.
contains
(
"
autocomplete
-
richlistbox
"
)
)
|
|
(
parentNode
.
tagName
=
=
"
menupopup
"
&
&
parentNode
.
classList
.
contains
(
"
urlbarView
-
result
-
menu
"
)
)
;
return
(
isMenuItem
&
&
isParentMenu
&
&
hasLabel
&
&
(
node
.
hasAttribute
(
"
data
-
l10n
-
id
"
)
|
|
node
.
tagName
=
=
"
richlistitem
"
)
)
;
}
function
isUnlabeledImageButton
(
node
)
{
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
const
isShowAllButton
=
node
.
id
=
=
"
show
-
all
"
;
const
isReplacedImageButton
=
node
.
classList
.
contains
(
"
button
-
add
"
)
|
|
node
.
classList
.
contains
(
"
button
-
delete
"
)
|
|
node
.
classList
.
contains
(
"
button
-
reset
"
)
;
const
isCloseMozMessageBarButton
=
node
.
classList
.
contains
(
"
close
"
)
&
&
node
.
getAttribute
(
"
data
-
l10n
-
id
"
)
=
=
"
moz
-
message
-
bar
-
close
-
button
"
;
return
(
node
.
tagName
.
toLowerCase
(
)
=
=
"
button
"
&
&
node
.
hasAttribute
(
"
data
-
l10n
-
id
"
)
&
&
(
isShowAllButton
|
|
isReplacedImageButton
|
|
isCloseMozMessageBarButton
)
)
;
}
function
isUnlabeledXulButton
(
node
)
{
if
(
!
node
|
|
!
node
.
ownerGlobal
)
{
return
false
;
}
const
hasLabel
=
node
.
querySelector
(
"
label
xul
\
\
:
label
"
)
;
const
isButton
=
node
.
getAttribute
(
"
role
"
)
=
=
"
button
"
|
|
node
.
tagName
=
=
"
button
"
|
|
node
.
tagName
=
=
"
xul
:
button
"
;
return
isButton
&
&
hasLabel
&
&
node
.
hasAttribute
(
"
data
-
l10n
-
id
"
)
;
}
function
shouldIgnoreTabIndex
(
node
)
{
if
(
!
XULElement
.
isInstance
(
node
)
)
{
return
false
;
}
return
node
.
tagName
=
=
"
label
"
&
&
node
.
getAttribute
(
"
is
"
)
=
=
"
text
-
link
"
;
}
function
isKeyboardFocusable
(
accessible
)
{
if
(
isKeyboardFocusableBrowserToolbarButton
(
accessible
)
|
|
isKeyboardFocusableOption
(
accessible
)
|
|
isKeyboardFocusablePanelMultiViewControl
(
accessible
)
|
|
isKeyboardFocusableUrlbarButton
(
accessible
)
|
|
isKeyboardFocusableXULTab
(
accessible
)
|
|
isKeyboardFocusableTabInTablist
(
accessible
)
|
|
isKeyboardFocusableFxviewControlInApplication
(
accessible
)
)
{
return
true
;
}
const
node
=
accessible
.
DOMNode
;
const
role
=
accessible
.
role
;
return
(
matchState
(
accessible
STATE_FOCUSABLE
)
&
&
(
!
gEnv
.
nonNegativeTabIndexRule
|
|
node
.
tabIndex
>
-
1
|
|
node
.
closest
(
'
[
aria
-
activedescendant
]
[
tabindex
=
"
0
"
]
'
)
|
|
(
(
role
=
=
Ci
.
nsIAccessibleRole
.
ROLE_PUSHBUTTON
|
|
role
=
=
Ci
.
nsIAccessibleRole
.
ROLE_TOGGLE_BUTTON
)
&
&
node
.
closest
(
'
[
role
=
"
toolbar
"
]
'
)
)
|
|
(
role
=
=
=
Ci
.
nsIAccessibleRole
.
ROLE_RADIOBUTTON
&
&
node
.
getRootNode
(
)
.
host
?
.
tagName
?
.
toLowerCase
(
)
=
=
=
"
moz
-
radio
"
)
|
|
shouldIgnoreTabIndex
(
node
)
)
)
;
}
function
buildMessage
(
message
DOMNode
)
{
if
(
DOMNode
)
{
const
{
id
tagName
className
}
=
DOMNode
;
message
+
=
:
id
:
{
id
}
tagName
:
{
tagName
}
className
:
{
className
}
;
}
return
message
;
}
function
a11yFail
(
message
{
DOMNode
}
)
{
SpecialPowers
.
SimpleTest
.
ok
(
false
buildMessage
(
message
DOMNode
)
)
;
}
function
a11yWarn
(
message
{
DOMNode
}
)
{
SpecialPowers
.
SimpleTest
.
todo
(
false
buildMessage
(
message
DOMNode
)
)
;
}
function
assertEnabled
(
accessible
)
{
if
(
gEnv
.
mustBeEnabled
&
&
matchState
(
accessible
STATE_UNAVAILABLE
)
)
{
a11yFail
(
"
Node
expected
to
be
enabled
but
is
disabled
via
the
accessibility
API
"
accessible
)
;
}
}
function
assertFocusable
(
accessible
)
{
if
(
gEnv
.
mustBeEnabled
&
&
gEnv
.
focusableRule
&
&
!
isKeyboardFocusable
(
accessible
)
)
{
const
ariaRoles
=
getAriaRoles
(
accessible
)
;
if
(
!
ariaRoles
.
includes
(
"
combobox
"
)
&
&
!
ariaRoles
.
includes
(
"
listbox
"
)
)
{
a11yFail
(
"
Node
is
not
focusable
via
the
accessibility
API
"
accessible
)
;
}
return
;
}
if
(
!
INTERACTIVE_IF_FOCUSABLE_ROLES
.
has
(
accessible
.
role
)
)
{
if
(
accessible
.
role
=
=
=
Ci
.
nsIAccessibleRole
.
ROLE_TABLE
&
&
!
getAriaRoles
(
accessible
)
.
includes
(
"
grid
"
)
)
{
a11yWarn
(
"
Focusable
nodes
should
have
interactive
semantics
"
accessible
)
;
return
;
}
}
if
(
accessible
.
DOMNode
.
tabIndex
>
0
)
{
a11yWarn
(
"
Avoid
using
tabindex
attribute
greater
than
zero
"
accessible
)
;
}
}
function
assertInteractive
(
accessible
)
{
if
(
gEnv
.
mustBeEnabled
&
&
gEnv
.
actionCountRule
&
&
accessible
.
actionCount
=
=
=
0
)
{
a11yFail
(
"
Node
does
not
support
any
accessible
actions
"
accessible
)
;
return
;
}
if
(
gEnv
.
mustBeEnabled
&
&
gEnv
.
interactiveRule
&
&
!
INTERACTIVE_ROLES
.
has
(
accessible
.
role
)
)
{
if
(
(
accessible
.
role
!
=
=
Ci
.
nsIAccessibleRole
.
ROLE_LABEL
|
|
accessible
.
getRelationByType
(
Ci
.
nsIAccessibleRelation
.
RELATION_LABEL_FOR
)
.
targetsCount
=
=
=
0
)
&
&
(
accessible
.
role
!
=
=
Ci
.
nsIAccessibleRole
.
ROLE_GRAPHIC
|
|
!
matchState
(
accessible
STATE_LINKED
)
)
)
{
for
(
let
i
=
0
;
i
<
accessible
.
actionCount
;
i
+
+
)
{
if
(
gEnv
.
ifClickableThenInteractiveRule
&
&
accessible
.
getActionName
(
i
)
=
=
=
CLICK_ACTION
)
{
a11yFail
(
"
Clickable
nodes
must
have
interactive
semantics
"
accessible
)
;
}
}
}
a11yFail
(
"
Node
does
not
have
a
correct
interactive
role
and
may
not
be
"
+
"
manipulated
via
the
accessibility
API
"
accessible
)
;
}
}
function
assertLabelled
(
accessible
allowRecurse
=
true
)
{
const
{
DOMNode
}
=
accessible
;
let
name
=
accessible
.
name
;
if
(
!
name
)
{
forceRefreshDriverTick
(
DOMNode
)
;
try
{
name
=
accessible
.
name
;
}
catch
(
e
)
{
if
(
gEnv
.
labelRule
)
{
if
(
isUnlabeledUrlBarOption
(
DOMNode
)
|
|
isUnlabeledMenuitem
(
DOMNode
)
|
|
isUnlabeledImageButton
(
DOMNode
)
)
{
return
;
}
a11yWarn
(
"
Unlabeled
element
removed
before
l10n
finished
"
{
DOMNode
}
)
;
}
return
;
}
const
doc
=
DOMNode
.
ownerDocument
;
if
(
!
name
&
&
allowRecurse
&
&
gEnv
.
labelRule
&
&
doc
.
hasPendingL10nMutations
)
{
doc
.
addEventListener
(
"
L10nMutationsFinished
"
(
)
=
>
{
try
{
accessible
.
name
;
}
catch
(
e
)
{
if
(
isUnlabeledUrlBarOption
(
DOMNode
)
|
|
isUnlabeledImageButton
(
DOMNode
)
|
|
isUnlabeledXulButton
(
DOMNode
)
)
{
return
;
}
a11yWarn
(
"
Unlabeled
element
removed
before
l10n
finished
"
{
DOMNode
}
)
;
return
;
}
assertLabelled
(
accessible
false
)
;
}
{
once
:
true
}
)
;
return
;
}
}
if
(
name
)
{
name
=
name
.
trim
(
)
;
}
if
(
gEnv
.
labelRule
&
&
!
name
)
{
if
(
isUnlabeledUrlBarCombobox
(
DOMNode
)
|
|
isUnlabeledUrlBarOption
(
DOMNode
)
)
{
return
;
}
a11yFail
(
"
Interactive
elements
must
be
labeled
"
accessible
)
;
return
;
}
if
(
FORM_ROLES
.
has
(
accessible
.
role
)
)
{
const
labels
=
getLabels
(
accessible
)
;
const
hasNameFromVisibleLabel
=
labels
.
some
(
label
=
>
!
matchState
(
label
STATE_INVISIBLE
)
)
;
if
(
!
hasNameFromVisibleLabel
)
{
a11yWarn
(
"
Form
elements
should
have
a
visible
text
label
"
accessible
)
;
}
}
else
if
(
accessible
.
role
=
=
=
Ci
.
nsIAccessibleRole
.
ROLE_LINK
&
&
DOMNode
.
nodeName
=
=
=
"
AREA
"
&
&
DOMNode
.
hasAttribute
(
"
href
"
)
)
{
const
alt
=
DOMNode
.
getAttribute
(
"
alt
"
)
;
if
(
alt
&
&
alt
.
trim
(
)
!
=
=
name
)
{
a11yFail
(
"
Use
alt
attribute
to
label
area
elements
that
have
the
href
attribute
"
accessible
)
;
}
}
}
function
assertVisible
(
accessible
)
{
if
(
isHidden
(
accessible
)
)
{
a11yFail
(
"
Node
is
not
currently
visible
via
the
accessibility
API
and
may
not
"
+
"
be
manipulated
by
it
"
accessible
)
;
}
}
function
forceRefreshDriverTick
(
node
)
{
const
wins
=
[
]
;
let
bc
=
BrowsingContext
.
getFromWindow
(
node
.
ownerDocument
.
defaultView
)
;
while
(
bc
)
{
wins
.
push
(
bc
.
associatedWindow
)
;
bc
=
bc
.
embedderWindowGlobal
?
.
browsingContext
;
}
let
win
=
wins
.
pop
(
)
;
while
(
win
)
{
win
.
windowUtils
.
advanceTimeAndRefresh
(
100
)
;
win
.
windowUtils
.
advanceTimeAndRefresh
(
100
)
;
win
.
windowUtils
.
restoreNormalRefresh
(
)
;
win
=
wins
.
pop
(
)
;
}
}
function
getAccessible
(
node
)
{
const
accessibilityService
=
Cc
[
"
mozilla
.
org
/
accessibilityService
;
1
"
]
.
getService
(
Ci
.
nsIAccessibilityService
)
;
if
(
!
accessibilityService
)
{
return
null
;
}
let
acc
=
accessibilityService
.
getAccessibleFor
(
node
)
;
if
(
acc
)
{
return
acc
;
}
forceRefreshDriverTick
(
node
)
;
return
accessibilityService
.
getAccessibleFor
(
node
)
;
}
function
findInteractiveAccessible
(
node
)
{
let
acc
;
for
(
;
node
&
&
!
acc
;
node
=
node
.
flattenedTreeParentNode
)
{
acc
=
getAccessible
(
node
)
;
}
if
(
!
acc
)
{
return
acc
;
}
for
(
;
acc
;
acc
=
acc
.
parent
)
{
const
relation
=
acc
.
getRelationByType
(
Ci
.
nsIAccessibleRelation
.
RELATION_LABEL_FOR
)
;
if
(
acc
.
role
=
=
=
Ci
.
nsIAccessibleRole
.
ROLE_LABEL
&
&
relation
.
targetsCount
>
0
)
{
const
targetAcc
=
relation
.
getTarget
(
0
)
;
return
targetAcc
;
}
if
(
INTERACTIVE_ROLES
.
has
(
acc
.
role
)
)
{
return
acc
;
}
}
return
null
;
}
function
findNonGenericParentAccessible
(
childAcc
)
{
for
(
let
acc
=
childAcc
.
parent
;
acc
;
acc
=
acc
.
parent
)
{
if
(
acc
.
computedARIARole
!
=
"
generic
"
)
{
return
acc
;
}
}
return
null
;
}
function
*
findNonGenericChildrenAccessible
(
parentAcc
)
{
const
count
=
parentAcc
.
childCount
;
for
(
let
c
=
0
;
c
<
count
;
+
+
c
)
{
const
child
=
parentAcc
.
getChildAt
(
c
)
;
if
(
child
.
computedARIARole
=
=
"
generic
"
)
{
yield
*
findNonGenericChildrenAccessible
(
child
)
;
}
else
{
yield
child
;
}
}
}
function
runIfA11YChecks
(
task
)
{
return
(
.
.
.
args
)
=
>
(
gA11YChecks
?
task
(
.
.
.
args
)
:
null
)
;
}
const
AccessibilityUtils
=
{
assertCanBeClicked
(
node
)
{
const
acc
=
findInteractiveAccessible
(
node
)
;
if
(
!
acc
)
{
if
(
isAccessibleGridcell
(
node
)
|
|
isInaccessibleXulTreecol
(
node
)
)
{
return
;
}
if
(
gEnv
.
mustHaveAccessibleRule
)
{
a11yFail
(
"
Node
is
not
accessible
via
accessibility
API
"
{
DOMNode
:
node
}
)
;
}
return
;
}
assertInteractive
(
acc
)
;
assertFocusable
(
acc
)
;
assertVisible
(
acc
)
;
assertEnabled
(
acc
)
;
assertLabelled
(
acc
)
;
}
setEnv
(
env
=
DEFAULT_ENV
)
{
gEnv
=
{
.
.
.
DEFAULT_ENV
.
.
.
env
}
;
}
resetEnv
(
)
{
gEnv
=
{
.
.
.
DEFAULT_ENV
}
;
}
reset
(
a11yChecks
=
false
testPath
=
"
"
)
{
gA11YChecks
=
a11yChecks
;
const
{
Services
}
=
SpecialPowers
;
if
(
!
gA11YChecks
&
&
Services
.
appinfo
.
accessibilityEnabled
&
&
!
testPath
.
startsWith
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
accessible
/
"
)
)
{
Services
.
prefs
.
setIntPref
(
FORCE_DISABLE_ACCESSIBILITY_PREF
1
)
;
Services
.
prefs
.
clearUserPref
(
FORCE_DISABLE_ACCESSIBILITY_PREF
)
;
}
this
.
resetEnv
(
)
;
}
init
(
)
{
this
.
_shouldHandleClicks
=
true
;
this
.
_handler
?
?
=
window
.
docShell
.
chromeEventHandler
?
?
window
.
docShell
.
domWindow
;
this
.
_handler
.
addEventListener
(
"
click
"
this
true
true
)
;
}
uninit
(
)
{
this
.
_handler
?
.
removeEventListener
(
"
click
"
this
true
)
;
this
.
_handler
=
null
;
}
suppressClickHandling
(
shouldSuppress
)
{
this
.
_shouldHandleClicks
=
!
shouldSuppress
;
}
handleEvent
(
{
composedTarget
}
)
{
if
(
!
this
.
_shouldHandleClicks
)
{
return
;
}
if
(
composedTarget
.
tagName
.
toLowerCase
(
)
=
=
"
slot
"
)
{
composedTarget
=
composedTarget
.
flattenedTreeParentNode
;
}
const
bounds
=
composedTarget
.
ownerGlobal
?
.
windowUtils
?
.
getBoundsWithoutFlushing
(
composedTarget
)
;
if
(
bounds
&
&
(
bounds
.
width
=
=
0
|
|
bounds
.
height
=
=
0
)
)
{
return
;
}
this
.
assertCanBeClicked
(
composedTarget
)
;
}
}
;
AccessibilityUtils
.
assertCanBeClicked
=
runIfA11YChecks
(
AccessibilityUtils
.
assertCanBeClicked
.
bind
(
AccessibilityUtils
)
)
;
AccessibilityUtils
.
setEnv
=
runIfA11YChecks
(
AccessibilityUtils
.
setEnv
.
bind
(
AccessibilityUtils
)
)
;
AccessibilityUtils
.
resetEnv
=
runIfA11YChecks
(
AccessibilityUtils
.
resetEnv
.
bind
(
AccessibilityUtils
)
)
;
return
AccessibilityUtils
;
}
)
(
)
;
