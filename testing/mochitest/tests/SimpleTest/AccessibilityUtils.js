"
use
strict
"
;
this
.
AccessibilityUtils
=
(
function
(
)
{
const
FORCE_DISABLE_ACCESSIBILITY_PREF
=
"
accessibility
.
force_disabled
"
;
const
{
STATE_FOCUSABLE
STATE_INVISIBLE
STATE_LINKED
STATE_UNAVAILABLE
}
=
Ci
.
nsIAccessibleStates
;
const
CLICK_ACTION
=
"
click
"
;
const
KEYBOARD_FOCUSABLE_ROLES
=
new
Set
(
[
Ci
.
nsIAccessibleRole
.
ROLE_BUTTONMENU
Ci
.
nsIAccessibleRole
.
ROLE_CHECKBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_COMBOBOX
Ci
.
nsIAccessibleRole
.
ROLE_EDITCOMBOBOX
Ci
.
nsIAccessibleRole
.
ROLE_ENTRY
Ci
.
nsIAccessibleRole
.
ROLE_LINK
Ci
.
nsIAccessibleRole
.
ROLE_LISTBOX
Ci
.
nsIAccessibleRole
.
ROLE_PASSWORD_TEXT
Ci
.
nsIAccessibleRole
.
ROLE_PUSHBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_RADIOBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_SLIDER
Ci
.
nsIAccessibleRole
.
ROLE_SPINBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_SUMMARY
Ci
.
nsIAccessibleRole
.
ROLE_SWITCH
Ci
.
nsIAccessibleRole
.
ROLE_TOGGLE_BUTTON
]
)
;
const
INTERACTIVE_ROLES
=
new
Set
(
[
.
.
.
KEYBOARD_FOCUSABLE_ROLES
Ci
.
nsIAccessibleRole
.
ROLE_CHECK_MENU_ITEM
Ci
.
nsIAccessibleRole
.
ROLE_CHECK_RICH_OPTION
Ci
.
nsIAccessibleRole
.
ROLE_COMBOBOX_OPTION
Ci
.
nsIAccessibleRole
.
ROLE_MENUITEM
Ci
.
nsIAccessibleRole
.
ROLE_OPTION
Ci
.
nsIAccessibleRole
.
ROLE_OUTLINE
Ci
.
nsIAccessibleRole
.
ROLE_OUTLINEITEM
Ci
.
nsIAccessibleRole
.
ROLE_PAGETAB
Ci
.
nsIAccessibleRole
.
ROLE_PARENT_MENUITEM
Ci
.
nsIAccessibleRole
.
ROLE_RADIO_MENU_ITEM
Ci
.
nsIAccessibleRole
.
ROLE_RICH_OPTION
]
)
;
const
INTERACTIVE_IF_FOCUSABLE_ROLES
=
new
Set
(
[
Ci
.
nsIAccessibleRole
.
ROLE_ARTICLE
Ci
.
nsIAccessibleRole
.
ROLE_COLUMNHEADER
Ci
.
nsIAccessibleRole
.
ROLE_GRID_CELL
Ci
.
nsIAccessibleRole
.
ROLE_MENUBAR
Ci
.
nsIAccessibleRole
.
ROLE_MENUPOPUP
Ci
.
nsIAccessibleRole
.
ROLE_PAGETABLIST
Ci
.
nsIAccessibleRole
.
ROLE_ROWHEADER
Ci
.
nsIAccessibleRole
.
ROLE_SCROLLBAR
Ci
.
nsIAccessibleRole
.
ROLE_SEPARATOR
Ci
.
nsIAccessibleRole
.
ROLE_TOOLBAR
]
)
;
const
FORM_ROLES
=
new
Set
(
[
Ci
.
nsIAccessibleRole
.
ROLE_CHECKBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_CHECK_RICH_OPTION
Ci
.
nsIAccessibleRole
.
ROLE_COMBOBOX
Ci
.
nsIAccessibleRole
.
ROLE_EDITCOMBOBOX
Ci
.
nsIAccessibleRole
.
ROLE_ENTRY
Ci
.
nsIAccessibleRole
.
ROLE_LISTBOX
Ci
.
nsIAccessibleRole
.
ROLE_PASSWORD_TEXT
Ci
.
nsIAccessibleRole
.
ROLE_PROGRESSBAR
Ci
.
nsIAccessibleRole
.
ROLE_RADIOBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_SLIDER
Ci
.
nsIAccessibleRole
.
ROLE_SPINBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_SWITCH
]
)
;
const
DEFAULT_ENV
=
Object
.
freeze
(
{
actionCountRule
:
true
focusableRule
:
true
ifClickableThenInteractiveRule
:
true
interactiveRule
:
true
labelRule
:
true
mustHaveAccessibleRule
:
true
nonNegativeTabIndexRule
:
true
}
)
;
let
gA11YChecks
=
false
;
let
gEnv
=
{
.
.
.
DEFAULT_ENV
}
;
function
getAriaRoles
(
accessible
)
{
try
{
return
accessible
.
attributes
.
getStringProperty
(
"
xml
-
roles
"
)
;
}
catch
(
e
)
{
}
return
"
"
;
}
function
getLabels
(
accessible
)
{
const
relation
=
accessible
.
getRelationByType
(
Ci
.
nsIAccessibleRelation
.
RELATION_LABELLED_BY
)
;
return
[
.
.
.
relation
.
getTargets
(
)
.
enumerate
(
Ci
.
nsIAccessible
)
]
;
}
function
hasHiddenAttribute
(
accessible
)
{
let
hidden
=
false
;
try
{
hidden
=
accessible
.
attributes
.
getStringProperty
(
"
hidden
"
)
;
}
catch
(
e
)
{
}
return
hidden
&
&
hidden
=
=
=
"
true
"
;
}
function
isHidden
(
accessible
)
{
if
(
!
accessible
)
{
return
true
;
}
while
(
accessible
)
{
if
(
hasHiddenAttribute
(
accessible
)
)
{
return
true
;
}
accessible
=
accessible
.
parent
;
}
return
false
;
}
function
matchState
(
accessible
stateToMatch
)
{
const
state
=
{
}
;
accessible
.
getState
(
state
{
}
)
;
return
!
!
(
state
.
value
&
stateToMatch
)
;
}
function
isKeyboardFocusable
(
accessible
)
{
return
(
matchState
(
accessible
STATE_FOCUSABLE
)
&
&
(
!
gEnv
.
nonNegativeTabIndexRule
|
|
accessible
.
DOMNode
.
tabIndex
>
-
1
)
)
;
}
function
buildMessage
(
message
DOMNode
)
{
if
(
DOMNode
)
{
const
{
id
tagName
className
}
=
DOMNode
;
message
+
=
:
id
:
{
id
}
tagName
:
{
tagName
}
className
:
{
className
}
;
}
return
message
;
}
function
a11yFail
(
message
{
DOMNode
}
)
{
SpecialPowers
.
SimpleTest
.
ok
(
false
buildMessage
(
message
DOMNode
)
)
;
}
function
a11yWarn
(
message
{
DOMNode
}
)
{
SpecialPowers
.
SimpleTest
.
todo
(
false
buildMessage
(
message
DOMNode
)
)
;
}
function
assertEnabled
(
accessible
)
{
if
(
matchState
(
accessible
STATE_UNAVAILABLE
)
)
{
a11yFail
(
"
Node
is
enabled
but
disabled
via
the
accessibility
API
"
accessible
)
;
}
}
function
assertFocusable
(
accessible
)
{
if
(
gEnv
.
focusableRule
&
&
!
isKeyboardFocusable
(
accessible
)
)
{
const
ariaRoles
=
getAriaRoles
(
accessible
)
;
if
(
!
ariaRoles
.
includes
(
"
combobox
"
)
&
&
!
ariaRoles
.
includes
(
"
listbox
"
)
)
{
a11yFail
(
"
Node
is
not
focusable
via
the
accessibility
API
"
accessible
)
;
}
return
;
}
if
(
!
INTERACTIVE_IF_FOCUSABLE_ROLES
.
has
(
accessible
.
role
)
)
{
if
(
accessible
.
role
=
=
=
Ci
.
nsIAccessibleRole
.
ROLE_TABLE
&
&
!
getAriaRoles
(
accessible
)
.
includes
(
"
grid
"
)
)
{
a11yWarn
(
"
Focusable
nodes
should
have
interactive
semantics
"
accessible
)
;
return
;
}
}
if
(
accessible
.
DOMNode
.
tabIndex
>
0
)
{
a11yWarn
(
"
Avoid
using
tabindex
attribute
greater
than
zero
"
accessible
)
;
}
}
function
assertInteractive
(
accessible
)
{
if
(
gEnv
.
actionCountRule
&
&
accessible
.
actionCount
=
=
=
0
)
{
a11yFail
(
"
Node
does
not
support
any
accessible
actions
"
accessible
)
;
return
;
}
if
(
gEnv
.
interactiveRule
&
&
!
INTERACTIVE_ROLES
.
has
(
accessible
.
role
)
)
{
if
(
(
accessible
.
role
!
=
=
Ci
.
nsIAccessibleRole
.
ROLE_LABEL
|
|
accessible
.
getRelationByType
(
Ci
.
nsIAccessibleRelation
.
RELATION_LABEL_FOR
)
.
targetsCount
=
=
=
0
)
&
&
(
accessible
.
role
!
=
=
Ci
.
nsIAccessibleRole
.
ROLE_GRAPHIC
|
|
!
matchState
(
accessible
STATE_LINKED
)
)
)
{
for
(
let
i
=
0
;
i
<
accessible
.
actionCount
;
i
+
+
)
{
if
(
gEnv
.
ifClickableThenInteractiveRule
&
&
accessible
.
getActionName
(
i
)
=
=
=
CLICK_ACTION
)
{
a11yFail
(
"
Clickable
nodes
must
have
interactive
semantics
"
accessible
)
;
}
}
}
a11yFail
(
"
Node
does
not
have
a
correct
interactive
role
and
may
not
be
"
+
"
manipulated
via
the
accessibility
API
"
accessible
)
;
}
}
function
assertLabelled
(
accessible
)
{
const
name
=
accessible
.
name
&
&
accessible
.
name
.
trim
(
)
;
if
(
gEnv
.
labelRule
&
&
!
name
)
{
a11yFail
(
"
Interactive
elements
must
be
labeled
"
accessible
)
;
return
;
}
const
{
DOMNode
}
=
accessible
;
if
(
FORM_ROLES
.
has
(
accessible
.
role
)
)
{
const
labels
=
getLabels
(
accessible
)
;
const
hasNameFromVisibleLabel
=
labels
.
some
(
label
=
>
!
matchState
(
label
STATE_INVISIBLE
)
)
;
if
(
!
hasNameFromVisibleLabel
)
{
a11yWarn
(
"
Form
elements
should
have
a
visible
text
label
"
accessible
)
;
}
}
else
if
(
accessible
.
role
=
=
=
Ci
.
nsIAccessibleRole
.
ROLE_LINK
&
&
DOMNode
.
nodeName
=
=
=
"
AREA
"
&
&
DOMNode
.
hasAttribute
(
"
href
"
)
)
{
const
alt
=
DOMNode
.
getAttribute
(
"
alt
"
)
;
if
(
alt
&
&
alt
.
trim
(
)
!
=
=
name
)
{
a11yFail
(
"
Use
alt
attribute
to
label
area
elements
that
have
the
href
attribute
"
accessible
)
;
}
}
}
function
assertVisible
(
accessible
)
{
if
(
isHidden
(
accessible
)
)
{
a11yFail
(
"
Node
is
not
currently
visible
via
the
accessibility
API
and
may
not
"
+
"
be
manipulated
by
it
"
accessible
)
;
}
}
function
forceRefreshDriverTick
(
node
)
{
const
wins
=
[
]
;
let
bc
=
BrowsingContext
.
getFromWindow
(
node
.
ownerDocument
.
defaultView
)
;
while
(
bc
)
{
wins
.
push
(
bc
.
associatedWindow
)
;
bc
=
bc
.
embedderWindowGlobal
?
.
browsingContext
;
}
let
win
=
wins
.
pop
(
)
;
while
(
win
)
{
win
.
windowUtils
.
advanceTimeAndRefresh
(
100
)
;
win
.
windowUtils
.
advanceTimeAndRefresh
(
100
)
;
win
.
windowUtils
.
restoreNormalRefresh
(
)
;
win
=
wins
.
pop
(
)
;
}
}
function
getAccessible
(
node
)
{
const
accessibilityService
=
Cc
[
"
mozilla
.
org
/
accessibilityService
;
1
"
]
.
getService
(
Ci
.
nsIAccessibilityService
)
;
if
(
!
accessibilityService
)
{
return
null
;
}
let
acc
=
accessibilityService
.
getAccessibleFor
(
node
)
;
if
(
acc
)
{
return
acc
;
}
forceRefreshDriverTick
(
node
)
;
return
accessibilityService
.
getAccessibleFor
(
node
)
;
}
function
findInteractiveAccessible
(
node
)
{
let
acc
;
for
(
;
node
&
&
!
acc
;
node
=
node
.
parentNode
)
{
acc
=
getAccessible
(
node
)
;
}
if
(
!
acc
)
{
return
acc
;
}
for
(
;
acc
;
acc
=
acc
.
parent
)
{
if
(
INTERACTIVE_ROLES
.
has
(
acc
.
role
)
)
{
return
acc
;
}
}
return
null
;
}
function
runIfA11YChecks
(
task
)
{
return
(
.
.
.
args
)
=
>
(
gA11YChecks
?
task
(
.
.
.
args
)
:
null
)
;
}
const
AccessibilityUtils
=
{
assertCanBeClicked
(
node
)
{
const
acc
=
findInteractiveAccessible
(
node
)
;
if
(
!
acc
)
{
if
(
gEnv
.
mustHaveAccessibleRule
)
{
a11yFail
(
"
Node
is
not
accessible
via
accessibility
API
"
{
DOMNode
:
node
}
)
;
}
return
;
}
assertInteractive
(
acc
)
;
assertFocusable
(
acc
)
;
assertVisible
(
acc
)
;
assertEnabled
(
acc
)
;
assertLabelled
(
acc
)
;
}
setEnv
(
env
=
DEFAULT_ENV
)
{
gEnv
=
{
.
.
.
DEFAULT_ENV
.
.
.
env
}
;
}
resetEnv
(
)
{
gEnv
=
{
.
.
.
DEFAULT_ENV
}
;
}
reset
(
a11yChecks
=
false
)
{
gA11YChecks
=
a11yChecks
;
const
{
Services
}
=
SpecialPowers
;
if
(
!
gA11YChecks
&
&
Services
.
appinfo
.
accessibilityEnabled
)
{
Services
.
prefs
.
setIntPref
(
FORCE_DISABLE_ACCESSIBILITY_PREF
1
)
;
Services
.
prefs
.
clearUserPref
(
FORCE_DISABLE_ACCESSIBILITY_PREF
)
;
}
this
.
resetEnv
(
)
;
}
init
(
)
{
this
.
_handler
?
?
=
window
.
docShell
.
chromeEventHandler
?
?
window
.
docShell
.
domWindow
;
this
.
_handler
.
addEventListener
(
"
click
"
this
true
true
)
;
}
uninit
(
)
{
this
.
_handler
?
.
removeEventListener
(
"
click
"
this
true
)
;
this
.
_handler
=
null
;
}
handleEvent
(
{
composedTarget
}
)
{
const
bounds
=
composedTarget
.
ownerGlobal
?
.
windowUtils
?
.
getBoundsWithoutFlushing
(
composedTarget
)
;
if
(
bounds
&
&
(
bounds
.
width
=
=
0
|
|
bounds
.
height
=
=
0
)
)
{
return
;
}
this
.
assertCanBeClicked
(
composedTarget
)
;
}
}
;
AccessibilityUtils
.
assertCanBeClicked
=
runIfA11YChecks
(
AccessibilityUtils
.
assertCanBeClicked
.
bind
(
AccessibilityUtils
)
)
;
AccessibilityUtils
.
setEnv
=
runIfA11YChecks
(
AccessibilityUtils
.
setEnv
.
bind
(
AccessibilityUtils
)
)
;
AccessibilityUtils
.
resetEnv
=
runIfA11YChecks
(
AccessibilityUtils
.
resetEnv
.
bind
(
AccessibilityUtils
)
)
;
return
AccessibilityUtils
;
}
)
(
)
;
