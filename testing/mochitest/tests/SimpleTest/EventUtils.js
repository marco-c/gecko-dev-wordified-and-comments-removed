window
.
__defineGetter__
(
"
_EU_Ci
"
function
(
)
{
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
"
Components
"
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
Ci
:
SpecialPowers
.
Ci
;
}
)
;
window
.
__defineGetter__
(
"
_EU_Cc
"
function
(
)
{
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
"
Components
"
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
Cc
:
SpecialPowers
.
Cc
;
}
)
;
window
.
__defineGetter__
(
"
_EU_Cu
"
function
(
)
{
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
"
Components
"
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
Cu
:
SpecialPowers
.
Cu
;
}
)
;
window
.
__defineGetter__
(
"
_EU_ChromeUtils
"
function
(
)
{
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
"
ChromeUtils
"
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
ChromeUtils
:
SpecialPowers
.
ChromeUtils
;
}
)
;
window
.
__defineGetter__
(
"
_EU_OS
"
function
(
)
{
delete
this
.
_EU_OS
;
try
{
this
.
_EU_OS
=
_EU_ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
.
platform
;
}
catch
(
ex
)
{
this
.
_EU_OS
=
null
;
}
return
this
.
_EU_OS
;
}
)
;
function
_EU_isMac
(
aWindow
=
window
)
{
if
(
window
.
_EU_OS
)
{
return
window
.
_EU_OS
=
=
"
macosx
"
;
}
if
(
aWindow
)
{
try
{
return
aWindow
.
navigator
.
platform
.
indexOf
(
"
Mac
"
)
>
-
1
;
}
catch
(
ex
)
{
}
}
return
navigator
.
platform
.
indexOf
(
"
Mac
"
)
>
-
1
;
}
function
_EU_isWin
(
aWindow
=
window
)
{
if
(
window
.
_EU_OS
)
{
return
window
.
_EU_OS
=
=
"
win
"
;
}
if
(
aWindow
)
{
try
{
return
aWindow
.
navigator
.
platform
.
indexOf
(
"
Win
"
)
>
-
1
;
}
catch
(
ex
)
{
}
}
return
navigator
.
platform
.
indexOf
(
"
Win
"
)
>
-
1
;
}
function
_EU_isLinux
(
aWindow
=
window
)
{
if
(
window
.
_EU_OS
)
{
return
window
.
_EU_OS
=
=
"
linux
"
;
}
if
(
aWindow
)
{
try
{
return
aWindow
.
navigator
.
platform
.
startsWith
(
"
Linux
"
)
;
}
catch
(
ex
)
{
}
}
return
navigator
.
platform
.
startsWith
(
"
Linux
"
)
;
}
function
_EU_isAndroid
(
aWindow
=
window
)
{
if
(
window
.
_EU_OS
)
{
return
window
.
_EU_OS
=
=
"
android
"
;
}
if
(
aWindow
)
{
try
{
return
aWindow
.
navigator
.
userAgent
.
includes
(
"
Android
"
)
;
}
catch
(
ex
)
{
}
}
return
navigator
.
userAgent
.
includes
(
"
Android
"
)
;
}
function
_EU_maybeWrap
(
o
)
{
var
haveWrap
=
false
;
try
{
haveWrap
=
SpecialPowers
.
wrap
!
=
undefined
;
}
catch
(
e
)
{
}
if
(
!
haveWrap
)
{
return
o
;
}
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
"
Components
"
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
o
:
SpecialPowers
.
wrap
(
o
)
;
}
function
_EU_maybeUnwrap
(
o
)
{
var
haveWrap
=
false
;
try
{
haveWrap
=
SpecialPowers
.
unwrap
!
=
undefined
;
}
catch
(
e
)
{
}
if
(
!
haveWrap
)
{
return
o
;
}
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
"
Components
"
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
o
:
SpecialPowers
.
unwrap
(
o
)
;
}
function
_EU_getPlatform
(
)
{
if
(
_EU_isWin
(
)
)
{
return
"
windows
"
;
}
if
(
_EU_isMac
(
)
)
{
return
"
mac
"
;
}
if
(
_EU_isAndroid
(
)
)
{
return
"
android
"
;
}
if
(
_EU_isLinux
(
)
)
{
return
"
linux
"
;
}
return
"
unknown
"
;
}
async
function
promiseElementReadyForUserInput
(
aElement
aWindow
=
window
aLogFunc
=
null
)
{
if
(
typeof
aElement
=
=
"
string
"
)
{
aElement
=
aWindow
.
document
.
getElementById
(
aElement
)
;
}
function
waitForMouseMoveForHittest
(
)
{
return
new
Promise
(
resolve
=
>
{
let
timeout
;
const
onHit
=
(
)
=
>
{
if
(
aLogFunc
)
{
aLogFunc
(
"
mousemove
received
"
)
;
}
aWindow
.
clearInterval
(
timeout
)
;
resolve
(
true
)
;
}
;
aElement
.
addEventListener
(
"
mousemove
"
onHit
{
capture
:
true
once
:
true
}
)
;
timeout
=
aWindow
.
setInterval
(
(
)
=
>
{
if
(
aLogFunc
)
{
aLogFunc
(
"
mousemove
not
received
in
this
300ms
"
)
;
}
aElement
.
removeEventListener
(
"
mousemove
"
onHit
{
capture
:
true
}
)
;
resolve
(
false
)
;
}
300
)
;
synthesizeMouseAtCenter
(
aElement
{
type
:
"
mousemove
"
}
aWindow
)
;
}
)
;
}
for
(
let
i
=
0
;
i
<
20
;
i
+
+
)
{
if
(
await
waitForMouseMoveForHittest
(
)
)
{
return
Promise
.
resolve
(
)
;
}
}
throw
new
Error
(
"
The
element
or
the
window
did
not
become
interactive
"
)
;
}
function
getElement
(
id
)
{
return
typeof
id
=
=
"
string
"
?
document
.
getElementById
(
id
)
:
id
;
}
this
.
=
this
.
getElement
;
function
computeButton
(
aEvent
)
{
if
(
typeof
aEvent
.
button
!
=
"
undefined
"
)
{
return
aEvent
.
button
;
}
return
aEvent
.
type
=
=
"
contextmenu
"
?
2
:
0
;
}
function
computeButtons
(
aEvent
utils
)
{
if
(
typeof
aEvent
.
buttons
!
=
"
undefined
"
)
{
return
aEvent
.
buttons
;
}
if
(
typeof
aEvent
.
button
!
=
"
undefined
"
)
{
return
utils
.
MOUSE_BUTTONS_NOT_SPECIFIED
;
}
if
(
typeof
aEvent
.
type
!
=
"
undefined
"
&
&
aEvent
.
type
!
=
"
mousedown
"
)
{
return
utils
.
MOUSE_BUTTONS_NO_BUTTON
;
}
return
utils
.
MOUSE_BUTTONS_NOT_SPECIFIED
;
}
function
sendMouseEvent
(
aEvent
aTarget
aWindow
)
{
if
(
!
[
"
click
"
"
contextmenu
"
"
dblclick
"
"
mousedown
"
"
mouseup
"
"
mouseover
"
"
mouseout
"
]
.
includes
(
aEvent
.
type
)
)
{
throw
new
Error
(
"
sendMouseEvent
doesn
'
t
know
about
event
type
'
"
+
aEvent
.
type
+
"
'
"
)
;
}
if
(
!
aWindow
)
{
aWindow
=
window
;
}
if
(
typeof
aTarget
=
=
"
string
"
)
{
aTarget
=
aWindow
.
document
.
getElementById
(
aTarget
)
;
}
var
event
=
aWindow
.
document
.
createEvent
(
"
MouseEvent
"
)
;
var
typeArg
=
aEvent
.
type
;
var
canBubbleArg
=
true
;
var
cancelableArg
=
true
;
var
viewArg
=
aWindow
;
var
detailArg
=
aEvent
.
detail
|
|
(
aEvent
.
type
=
=
"
click
"
|
|
aEvent
.
type
=
=
"
mousedown
"
|
|
aEvent
.
type
=
=
"
mouseup
"
?
1
:
aEvent
.
type
=
=
"
dblclick
"
?
2
:
0
)
;
var
screenXArg
=
aEvent
.
screenX
|
|
0
;
var
screenYArg
=
aEvent
.
screenY
|
|
0
;
var
clientXArg
=
aEvent
.
clientX
|
|
0
;
var
clientYArg
=
aEvent
.
clientY
|
|
0
;
var
ctrlKeyArg
=
aEvent
.
ctrlKey
|
|
false
;
var
altKeyArg
=
aEvent
.
altKey
|
|
false
;
var
shiftKeyArg
=
aEvent
.
shiftKey
|
|
false
;
var
metaKeyArg
=
aEvent
.
metaKey
|
|
false
;
var
buttonArg
=
computeButton
(
aEvent
)
;
var
relatedTargetArg
=
aEvent
.
relatedTarget
|
|
null
;
event
.
initMouseEvent
(
typeArg
canBubbleArg
cancelableArg
viewArg
detailArg
screenXArg
screenYArg
clientXArg
clientYArg
ctrlKeyArg
altKeyArg
shiftKeyArg
metaKeyArg
buttonArg
relatedTargetArg
)
;
if
(
!
window
.
document
|
|
window
.
document
.
documentURIObject
)
{
return
aTarget
.
dispatchEvent
(
event
)
;
}
return
SpecialPowers
.
dispatchEvent
(
aWindow
aTarget
event
)
;
}
function
isHidden
(
aElement
)
{
var
box
=
aElement
.
getBoundingClientRect
(
)
;
return
box
.
width
=
=
0
&
&
box
.
height
=
=
0
;
}
function
sendDragEvent
(
aEvent
aTarget
aWindow
=
window
)
{
if
(
!
[
"
drag
"
"
dragstart
"
"
dragend
"
"
dragover
"
"
dragenter
"
"
dragleave
"
"
drop
"
]
.
includes
(
aEvent
.
type
)
)
{
throw
new
Error
(
"
sendDragEvent
doesn
'
t
know
about
event
type
'
"
+
aEvent
.
type
+
"
'
"
)
;
}
if
(
typeof
aTarget
=
=
"
string
"
)
{
aTarget
=
aWindow
.
document
.
getElementById
(
aTarget
)
;
}
if
(
aEvent
.
type
!
=
"
dragend
"
&
&
isHidden
(
aTarget
)
)
{
var
targetName
=
aTarget
.
nodeName
;
if
(
"
id
"
in
aTarget
&
&
aTarget
.
id
)
{
targetName
+
=
"
#
"
+
aTarget
.
id
;
}
throw
new
Error
(
{
aEvent
.
type
}
event
target
{
targetName
}
is
hidden
)
;
}
var
event
=
aWindow
.
document
.
createEvent
(
"
DragEvent
"
)
;
var
typeArg
=
aEvent
.
type
;
var
canBubbleArg
=
true
;
var
cancelableArg
=
true
;
var
viewArg
=
aWindow
;
var
detailArg
=
aEvent
.
detail
|
|
0
;
var
screenXArg
=
aEvent
.
screenX
|
|
0
;
var
screenYArg
=
aEvent
.
screenY
|
|
0
;
var
clientXArg
=
aEvent
.
clientX
|
|
0
;
var
clientYArg
=
aEvent
.
clientY
|
|
0
;
var
ctrlKeyArg
=
aEvent
.
ctrlKey
|
|
false
;
var
altKeyArg
=
aEvent
.
altKey
|
|
false
;
var
shiftKeyArg
=
aEvent
.
shiftKey
|
|
false
;
var
metaKeyArg
=
aEvent
.
metaKey
|
|
false
;
var
buttonArg
=
computeButton
(
aEvent
)
;
var
relatedTargetArg
=
aEvent
.
relatedTarget
|
|
null
;
var
dataTransfer
=
aEvent
.
dataTransfer
|
|
null
;
event
.
initDragEvent
(
typeArg
canBubbleArg
cancelableArg
viewArg
detailArg
screenXArg
screenYArg
clientXArg
clientYArg
ctrlKeyArg
altKeyArg
shiftKeyArg
metaKeyArg
buttonArg
relatedTargetArg
dataTransfer
)
;
if
(
aEvent
.
_domDispatchOnly
)
{
return
aTarget
.
dispatchEvent
(
event
)
;
}
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
return
utils
.
dispatchDOMEventViaPresShellForTesting
(
aTarget
event
)
;
}
function
sendChar
(
aChar
aWindow
)
{
var
hasShift
;
switch
(
aChar
)
{
case
"
!
"
:
case
"
"
:
case
"
#
"
:
case
"
"
:
case
"
%
"
:
case
"
^
"
:
case
"
&
"
:
case
"
*
"
:
case
"
(
"
:
case
"
)
"
:
case
"
_
"
:
case
"
+
"
:
case
"
{
"
:
case
"
}
"
:
case
"
:
"
:
case
'
"
'
:
case
"
|
"
:
case
"
<
"
:
case
"
>
"
:
case
"
?
"
:
hasShift
=
true
;
break
;
default
:
hasShift
=
aChar
.
toLowerCase
(
)
!
=
aChar
.
toUpperCase
(
)
&
&
aChar
=
=
aChar
.
toUpperCase
(
)
;
break
;
}
synthesizeKey
(
aChar
{
shiftKey
:
hasShift
}
aWindow
)
;
}
function
sendString
(
aStr
aWindow
)
{
for
(
let
i
=
0
;
i
<
aStr
.
length
;
+
+
i
)
{
if
(
(
aStr
.
charCodeAt
(
i
)
&
0xfc00
)
=
=
0xd800
&
&
i
+
1
<
aStr
.
length
&
&
(
aStr
.
charCodeAt
(
i
+
1
)
&
0xfc00
)
=
=
0xdc00
)
{
sendChar
(
aStr
.
substring
(
i
i
+
2
)
aWindow
)
;
i
+
+
;
}
else
{
sendChar
(
aStr
.
charAt
(
i
)
aWindow
)
;
}
}
}
function
sendKey
(
aKey
aWindow
)
{
var
keyName
=
"
VK_
"
+
aKey
.
toUpperCase
(
)
;
synthesizeKey
(
keyName
{
shiftKey
:
false
}
aWindow
)
;
}
function
_parseModifiers
(
aEvent
aWindow
=
window
)
{
var
nsIDOMWindowUtils
=
_EU_Ci
.
nsIDOMWindowUtils
;
var
mval
=
0
;
if
(
aEvent
.
shiftKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_SHIFT
;
}
if
(
aEvent
.
ctrlKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_CONTROL
;
}
if
(
aEvent
.
altKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_ALT
;
}
if
(
aEvent
.
metaKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_META
;
}
if
(
aEvent
.
accelKey
)
{
mval
|
=
_EU_isMac
(
aWindow
)
?
nsIDOMWindowUtils
.
MODIFIER_META
:
nsIDOMWindowUtils
.
MODIFIER_CONTROL
;
}
if
(
aEvent
.
altGrKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_ALTGRAPH
;
}
if
(
aEvent
.
capsLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_CAPSLOCK
;
}
if
(
aEvent
.
fnKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_FN
;
}
if
(
aEvent
.
fnLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_FNLOCK
;
}
if
(
aEvent
.
numLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_NUMLOCK
;
}
if
(
aEvent
.
scrollLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_SCROLLLOCK
;
}
if
(
aEvent
.
symbolKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_SYMBOL
;
}
if
(
aEvent
.
symbolLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_SYMBOLLOCK
;
}
return
mval
;
}
function
synthesizeMouse
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
return
synthesizeMouseAtPoint
(
rect
.
left
+
aOffsetX
rect
.
top
+
aOffsetY
aEvent
aWindow
)
;
}
function
synthesizeTouch
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
return
synthesizeTouchAtPoint
(
rect
.
left
+
aOffsetX
rect
.
top
+
aOffsetY
aEvent
aWindow
)
;
}
function
getDragService
(
)
{
try
{
return
_EU_Cc
[
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
]
.
getService
(
_EU_Ci
.
nsIDragService
)
;
}
catch
(
e
)
{
return
null
;
}
}
function
_maybeEndDragSession
(
left
top
aEvent
aWindow
)
{
const
dragService
=
getDragService
(
)
;
const
dragSession
=
dragService
?
.
getCurrentSession
(
)
;
if
(
!
dragSession
)
{
return
false
;
}
try
{
dragService
.
endDragSession
(
false
_parseModifiers
(
aEvent
aWindow
)
)
;
}
catch
(
e
)
{
}
return
true
;
}
function
_maybeSynthesizeDragOver
(
left
top
aEvent
aWindow
)
{
const
dragSession
=
getDragService
(
)
?
.
getCurrentSession
(
)
;
if
(
!
dragSession
)
{
return
false
;
}
const
target
=
aWindow
.
document
.
elementFromPoint
(
left
top
)
;
if
(
target
)
{
sendDragEvent
(
createDragEventObject
(
"
dragover
"
target
aWindow
dragSession
.
dataTransfer
{
accelKey
:
aEvent
.
accelKey
altKey
:
aEvent
.
altKey
altGrKey
:
aEvent
.
altGrKey
ctrlKey
:
aEvent
.
ctrlKey
metaKey
:
aEvent
.
metaKey
shiftKey
:
aEvent
.
shiftKey
capsLockKey
:
aEvent
.
capsLockKey
fnKey
:
aEvent
.
fnKey
fnLockKey
:
aEvent
.
fnLockKey
numLockKey
:
aEvent
.
numLockKey
scrollLockKey
:
aEvent
.
scrollLockKey
symbolKey
:
aEvent
.
symbolKey
symbolLockKey
:
aEvent
.
symbolLockKey
}
)
target
aWindow
)
;
}
return
true
;
}
function
synthesizeMouseAtPoint
(
left
top
aEvent
aWindow
=
window
)
{
if
(
aEvent
.
allowToHandleDragDrop
)
{
if
(
aEvent
.
type
=
=
"
mouseup
"
|
|
!
aEvent
.
type
)
{
if
(
_maybeEndDragSession
(
left
top
aEvent
aWindow
)
)
{
return
false
;
}
}
else
if
(
aEvent
.
type
=
=
"
mousemove
"
)
{
if
(
_maybeSynthesizeDragOver
(
left
top
aEvent
aWindow
)
)
{
return
false
;
}
}
}
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
var
defaultPrevented
=
false
;
if
(
utils
)
{
var
button
=
computeButton
(
aEvent
)
;
var
clickCount
=
aEvent
.
clickCount
|
|
1
;
var
modifiers
=
_parseModifiers
(
aEvent
aWindow
)
;
var
pressure
=
"
pressure
"
in
aEvent
?
aEvent
.
pressure
:
0
;
var
MouseEvent
=
_EU_maybeWrap
(
aWindow
)
.
MouseEvent
;
var
inputSource
=
"
inputSource
"
in
aEvent
?
aEvent
.
inputSource
:
MouseEvent
.
MOZ_SOURCE_MOUSE
;
var
id
;
if
(
"
id
"
in
aEvent
)
{
id
=
aEvent
.
id
;
}
else
{
var
isFromPen
=
inputSource
=
=
=
MouseEvent
.
MOZ_SOURCE_PEN
;
id
=
isFromPen
?
utils
.
DEFAULT_PEN_POINTER_ID
:
utils
.
DEFAULT_MOUSE_POINTER_ID
;
}
var
isDOMEventSynthesized
=
"
isSynthesized
"
in
aEvent
?
aEvent
.
isSynthesized
:
true
;
var
isWidgetEventSynthesized
=
"
isWidgetEventSynthesized
"
in
aEvent
?
aEvent
.
isWidgetEventSynthesized
:
false
;
if
(
"
type
"
in
aEvent
&
&
aEvent
.
type
)
{
defaultPrevented
=
utils
.
sendMouseEvent
(
aEvent
.
type
left
top
button
clickCount
modifiers
false
pressure
inputSource
isDOMEventSynthesized
isWidgetEventSynthesized
computeButtons
(
aEvent
utils
)
id
)
;
}
else
{
utils
.
sendMouseEvent
(
"
mousedown
"
left
top
button
clickCount
modifiers
false
pressure
inputSource
isDOMEventSynthesized
isWidgetEventSynthesized
computeButtons
(
Object
.
assign
(
{
type
:
"
mousedown
"
}
aEvent
)
utils
)
id
)
;
utils
.
sendMouseEvent
(
"
mouseup
"
left
top
button
clickCount
modifiers
false
pressure
inputSource
isDOMEventSynthesized
isWidgetEventSynthesized
computeButtons
(
Object
.
assign
(
{
type
:
"
mouseup
"
}
aEvent
)
utils
)
id
)
;
}
}
return
defaultPrevented
;
}
function
synthesizeTouchAtPoint
(
left
top
aEvent
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
let
defaultPrevented
=
false
;
if
(
utils
)
{
var
id
=
aEvent
.
id
|
|
utils
.
DEFAULT_TOUCH_POINTER_ID
;
var
rx
=
aEvent
.
rx
|
|
1
;
var
ry
=
aEvent
.
ry
|
|
1
;
var
angle
=
aEvent
.
angle
|
|
0
;
var
force
=
aEvent
.
force
|
|
(
aEvent
.
type
=
=
=
"
touchend
"
?
0
:
1
)
;
var
tiltX
=
aEvent
.
tiltX
|
|
0
;
var
tiltY
=
aEvent
.
tiltY
|
|
0
;
var
twist
=
aEvent
.
twist
|
|
0
;
var
modifiers
=
_parseModifiers
(
aEvent
aWindow
)
;
if
(
"
type
"
in
aEvent
&
&
aEvent
.
type
)
{
defaultPrevented
=
utils
.
sendTouchEvent
(
aEvent
.
type
[
id
]
[
left
]
[
top
]
[
rx
]
[
ry
]
[
angle
]
[
force
]
[
tiltX
]
[
tiltY
]
[
twist
]
modifiers
)
;
}
else
{
utils
.
sendTouchEvent
(
"
touchstart
"
[
id
]
[
left
]
[
top
]
[
rx
]
[
ry
]
[
angle
]
[
force
]
[
tiltX
]
[
tiltY
]
[
twist
]
modifiers
)
;
utils
.
sendTouchEvent
(
"
touchend
"
[
id
]
[
left
]
[
top
]
[
rx
]
[
ry
]
[
angle
]
[
force
]
[
tiltX
]
[
tiltY
]
[
twist
]
modifiers
)
;
}
}
return
defaultPrevented
;
}
function
synthesizeMouseAtCenter
(
aTarget
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
return
synthesizeMouse
(
aTarget
rect
.
width
/
2
rect
.
height
/
2
aEvent
aWindow
)
;
}
function
synthesizeTouchAtCenter
(
aTarget
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
synthesizeTouchAtPoint
(
rect
.
left
+
rect
.
width
/
2
rect
.
top
+
rect
.
height
/
2
aEvent
aWindow
)
;
}
function
synthesizeWheelAtPoint
(
aLeft
aTop
aEvent
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
;
}
var
modifiers
=
_parseModifiers
(
aEvent
aWindow
)
;
var
options
=
0
;
if
(
aEvent
.
isNoLineOrPageDelta
)
{
options
|
=
utils
.
WHEEL_EVENT_CAUSED_BY_NO_LINE_OR_PAGE_DELTA_DEVICE
;
}
if
(
aEvent
.
isMomentum
)
{
options
|
=
utils
.
WHEEL_EVENT_CAUSED_BY_MOMENTUM
;
}
if
(
aEvent
.
isCustomizedByPrefs
)
{
options
|
=
utils
.
WHEEL_EVENT_CUSTOMIZED_BY_USER_PREFS
;
}
if
(
typeof
aEvent
.
expectedOverflowDeltaX
!
=
=
"
undefined
"
)
{
if
(
aEvent
.
expectedOverflowDeltaX
=
=
=
0
)
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_ZERO
;
}
else
if
(
aEvent
.
expectedOverflowDeltaX
>
0
)
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_POSITIVE
;
}
else
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_NEGATIVE
;
}
}
if
(
typeof
aEvent
.
expectedOverflowDeltaY
!
=
=
"
undefined
"
)
{
if
(
aEvent
.
expectedOverflowDeltaY
=
=
=
0
)
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_ZERO
;
}
else
if
(
aEvent
.
expectedOverflowDeltaY
>
0
)
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_POSITIVE
;
}
else
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_NEGATIVE
;
}
}
if
(
!
aEvent
.
deltaX
)
{
aEvent
.
deltaX
=
0
;
}
if
(
!
aEvent
.
deltaY
)
{
aEvent
.
deltaY
=
0
;
}
if
(
!
aEvent
.
deltaZ
)
{
aEvent
.
deltaZ
=
0
;
}
var
lineOrPageDeltaX
=
aEvent
.
lineOrPageDeltaX
!
=
null
?
aEvent
.
lineOrPageDeltaX
:
aEvent
.
deltaX
>
0
?
Math
.
floor
(
aEvent
.
deltaX
)
:
Math
.
ceil
(
aEvent
.
deltaX
)
;
var
lineOrPageDeltaY
=
aEvent
.
lineOrPageDeltaY
!
=
null
?
aEvent
.
lineOrPageDeltaY
:
aEvent
.
deltaY
>
0
?
Math
.
floor
(
aEvent
.
deltaY
)
:
Math
.
ceil
(
aEvent
.
deltaY
)
;
utils
.
sendWheelEvent
(
aLeft
aTop
aEvent
.
deltaX
aEvent
.
deltaY
aEvent
.
deltaZ
aEvent
.
deltaMode
modifiers
lineOrPageDeltaX
lineOrPageDeltaY
options
)
;
}
function
synthesizeWheel
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
synthesizeWheelAtPoint
(
rect
.
left
+
aOffsetX
rect
.
top
+
aOffsetY
aEvent
aWindow
)
;
}
const
_FlushModes
=
{
FLUSH
:
0
NOFLUSH
:
1
}
;
function
_sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
aFlushMode
=
_FlushModes
.
FLUSH
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
;
}
if
(
utils
.
isMozAfterPaintPending
)
{
aWindow
.
waitForAllPaintsFlushed
(
function
(
)
{
_sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
aFlushMode
aWindow
)
;
}
)
;
return
;
}
var
onwheel
=
function
(
)
{
SpecialPowers
.
removeSystemEventListener
(
window
"
wheel
"
onwheel
)
;
setTimeout
(
function
(
)
{
utils
.
advanceTimeAndRefresh
(
1000
)
;
if
(
!
aCallback
)
{
utils
.
advanceTimeAndRefresh
(
0
)
;
return
;
}
var
waitForPaints
=
function
(
)
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
waitForPaints
"
apz
-
repaints
-
flushed
"
)
;
aWindow
.
waitForAllPaintsFlushed
(
function
(
)
{
utils
.
restoreNormalRefresh
(
)
;
aCallback
(
)
;
}
)
;
}
;
SpecialPowers
.
Services
.
obs
.
addObserver
(
waitForPaints
"
apz
-
repaints
-
flushed
"
)
;
if
(
!
utils
.
flushApzRepaints
(
aWindow
)
)
{
waitForPaints
(
)
;
}
}
0
)
;
}
;
SpecialPowers
.
addSystemEventListener
(
aWindow
"
wheel
"
onwheel
)
;
if
(
aFlushMode
=
=
=
_FlushModes
.
FLUSH
)
{
synthesizeWheel
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
;
}
else
{
synthesizeWheelAtPoint
(
aOffsetX
aOffsetY
aEvent
aWindow
)
;
}
}
function
sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
aWindow
=
window
)
{
_sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
_FlushModes
.
FLUSH
aWindow
)
;
}
function
sendWheelAndPaintNoFlush
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
aWindow
=
window
)
{
_sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
_FlushModes
.
NOFLUSH
aWindow
)
;
}
function
synthesizeNativeTapAtCenter
(
aTarget
aLongTap
=
false
aCallback
=
null
aWindow
=
window
)
{
let
rect
=
aTarget
.
getBoundingClientRect
(
)
;
return
synthesizeNativeTap
(
aTarget
rect
.
width
/
2
rect
.
height
/
2
aLongTap
aCallback
aWindow
)
;
}
function
synthesizeNativeTap
(
aTarget
aOffsetX
aOffsetY
aLongTap
=
false
aCallback
=
null
aWindow
=
window
)
{
let
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
;
}
let
scale
=
aWindow
.
devicePixelRatio
;
let
rect
=
aTarget
.
getBoundingClientRect
(
)
;
let
x
=
(
aWindow
.
mozInnerScreenX
+
rect
.
left
+
aOffsetX
)
*
scale
;
let
y
=
(
aWindow
.
mozInnerScreenY
+
rect
.
top
+
aOffsetY
)
*
scale
;
let
observer
=
{
observe
:
(
subject
topic
data
)
=
>
{
if
(
aCallback
&
&
topic
=
=
"
mouseevent
"
)
{
aCallback
(
data
)
;
}
}
}
;
utils
.
sendNativeTouchTap
(
x
y
aLongTap
observer
)
;
}
function
synthesizeNativeMouseEvent
(
aParams
aCallback
=
null
)
{
const
{
type
target
offsetX
offsetY
atCenter
screenX
screenY
scale
=
"
screenPixelsPerCSSPixel
"
button
=
0
modifiers
=
{
}
win
=
window
elementOnWidget
=
target
}
=
aParams
;
if
(
atCenter
)
{
if
(
offsetX
!
=
undefined
|
|
offsetY
!
=
undefined
)
{
throw
Error
(
atCenter
is
specified
but
offsetX
(
{
offsetX
}
)
and
/
or
offsetY
(
{
offsetY
}
)
are
also
specified
)
;
}
if
(
screenX
!
=
undefined
|
|
screenY
!
=
undefined
)
{
throw
Error
(
atCenter
is
specified
but
screenX
(
{
screenX
}
)
and
/
or
screenY
(
{
screenY
}
)
are
also
specified
)
;
}
if
(
!
target
)
{
throw
Error
(
"
atCenter
is
specified
but
target
is
not
specified
"
)
;
}
}
else
if
(
offsetX
!
=
undefined
&
&
offsetY
!
=
undefined
)
{
if
(
screenX
!
=
undefined
|
|
screenY
!
=
undefined
)
{
throw
Error
(
offsetX
/
Y
are
specified
but
screenX
(
{
screenX
}
)
and
/
or
screenY
(
{
screenY
}
)
are
also
specified
)
;
}
if
(
!
target
)
{
throw
Error
(
"
offsetX
and
offsetY
are
specified
but
target
is
not
specified
"
)
;
}
}
else
if
(
screenX
!
=
undefined
&
&
screenY
!
=
undefined
)
{
if
(
offsetX
!
=
undefined
|
|
offsetY
!
=
undefined
)
{
throw
Error
(
screenX
/
Y
are
specified
but
offsetX
(
{
offsetX
}
)
and
/
or
offsetY
(
{
offsetY
}
)
are
also
specified
)
;
}
}
const
utils
=
_getDOMWindowUtils
(
win
)
;
if
(
!
utils
)
{
return
;
}
const
rect
=
target
?
.
getBoundingClientRect
(
)
;
let
resolution
=
1
.
0
;
try
{
resolution
=
_getDOMWindowUtils
(
win
.
top
)
.
getResolution
(
)
;
}
catch
(
e
)
{
}
const
scaleValue
=
(
(
)
=
>
{
if
(
scale
=
=
=
"
inScreenPixels
"
)
{
return
1
.
0
;
}
if
(
scale
=
=
=
"
screenPixelsPerCSSPixel
"
)
{
return
win
.
devicePixelRatio
;
}
throw
Error
(
invalid
scale
value
(
{
scale
}
)
is
specified
)
;
}
)
(
)
;
const
x
=
(
(
)
=
>
{
if
(
screenX
!
=
undefined
)
{
return
screenX
*
scaleValue
;
}
let
winInnerOffsetX
=
win
.
mozInnerScreenX
;
try
{
winInnerOffsetX
=
win
.
top
.
mozInnerScreenX
+
(
win
.
mozInnerScreenX
-
win
.
top
.
mozInnerScreenX
)
*
resolution
;
}
catch
(
e
)
{
}
return
(
(
(
(
atCenter
?
rect
.
width
/
2
:
offsetX
)
+
rect
.
left
)
*
resolution
+
winInnerOffsetX
)
*
scaleValue
)
;
}
)
(
)
;
const
y
=
(
(
)
=
>
{
if
(
screenY
!
=
undefined
)
{
return
screenY
*
scaleValue
;
}
let
winInnerOffsetY
=
win
.
mozInnerScreenY
;
try
{
winInnerOffsetY
=
win
.
top
.
mozInnerScreenY
+
(
win
.
mozInnerScreenY
-
win
.
top
.
mozInnerScreenY
)
*
resolution
;
}
catch
(
e
)
{
}
return
(
(
(
(
atCenter
?
rect
.
height
/
2
:
offsetY
)
+
rect
.
top
)
*
resolution
+
winInnerOffsetY
)
*
scaleValue
)
;
}
)
(
)
;
const
modifierFlags
=
_parseNativeModifiers
(
modifiers
)
;
const
observer
=
{
observe
:
(
subject
topic
data
)
=
>
{
if
(
aCallback
&
&
topic
=
=
"
mouseevent
"
)
{
aCallback
(
data
)
;
}
}
}
;
if
(
type
=
=
=
"
click
"
)
{
utils
.
sendNativeMouseEvent
(
x
y
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_DOWN
button
modifierFlags
elementOnWidget
function
(
)
{
utils
.
sendNativeMouseEvent
(
x
y
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_UP
button
modifierFlags
elementOnWidget
observer
)
;
}
)
;
return
;
}
utils
.
sendNativeMouseEvent
(
x
y
(
(
)
=
>
{
switch
(
type
)
{
case
"
mousedown
"
:
return
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_DOWN
;
case
"
mouseup
"
:
return
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_UP
;
case
"
mousemove
"
:
return
utils
.
NATIVE_MOUSE_MESSAGE_MOVE
;
default
:
throw
Error
(
Invalid
type
is
specified
:
{
type
}
)
;
}
}
)
(
)
button
modifierFlags
elementOnWidget
observer
)
;
}
function
promiseNativeMouseEvent
(
aParams
)
{
return
new
Promise
(
resolve
=
>
synthesizeNativeMouseEvent
(
aParams
resolve
)
)
;
}
function
synthesizeNativeMouseEventAndWaitForEvent
(
aParams
aCallback
)
{
const
listener
=
aParams
.
eventTargetToListen
|
|
aParams
.
target
;
const
eventType
=
aParams
.
eventTypeToWait
|
|
aParams
.
type
;
listener
.
addEventListener
(
eventType
aCallback
{
capture
:
true
once
:
true
}
)
;
synthesizeNativeMouseEvent
(
aParams
)
;
}
function
promiseNativeMouseEventAndWaitForEvent
(
aParams
)
{
return
new
Promise
(
resolve
=
>
synthesizeNativeMouseEventAndWaitForEvent
(
aParams
resolve
)
)
;
}
function
synthesizeAndWaitNativeMouseMove
(
aTarget
aOffsetX
aOffsetY
aCallback
aWindow
=
window
)
{
let
browser
=
gBrowser
.
selectedTab
.
linkedBrowser
;
let
mm
=
browser
.
messageManager
;
let
{
ContentTask
}
=
_EU_ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ContentTask
.
sys
.
mjs
"
)
;
let
eventRegisteredPromise
=
new
Promise
(
resolve
=
>
{
mm
.
addMessageListener
(
"
Test
:
MouseMoveRegistered
"
function
processed
(
message
)
{
mm
.
removeMessageListener
(
"
Test
:
MouseMoveRegistered
"
processed
)
;
resolve
(
)
;
}
)
;
}
)
;
let
eventReceivedPromise
=
ContentTask
.
spawn
(
browser
[
aOffsetX
aOffsetY
]
(
[
clientX
clientY
]
)
=
>
{
return
new
Promise
(
resolve
=
>
{
addEventListener
(
"
mousemove
"
function
onMouseMoveEvent
(
e
)
{
if
(
e
.
clientX
=
=
clientX
&
&
e
.
clientY
=
=
clientY
)
{
removeEventListener
(
"
mousemove
"
onMouseMoveEvent
)
;
resolve
(
)
;
}
}
)
;
sendAsyncMessage
(
"
Test
:
MouseMoveRegistered
"
)
;
}
)
;
}
)
;
eventRegisteredPromise
.
then
(
(
)
=
>
{
synthesizeNativeMouseEvent
(
{
type
:
"
mousemove
"
target
:
aTarget
offsetX
:
aOffsetX
offsetY
:
aOffsetY
win
:
aWindow
}
)
;
}
)
;
return
eventReceivedPromise
;
}
function
synthesizeKey
(
aKey
aEvent
=
undefined
aWindow
=
window
aCallback
)
{
const
event
=
aEvent
=
=
=
undefined
|
|
aEvent
=
=
=
null
?
{
}
:
aEvent
;
let
dispatchKeydown
=
!
(
"
type
"
in
event
)
|
|
event
.
type
=
=
=
"
keydown
"
|
|
!
event
.
type
;
const
dispatchKeyup
=
!
(
"
type
"
in
event
)
|
|
event
.
type
=
=
=
"
keyup
"
|
|
!
event
.
type
;
if
(
dispatchKeydown
&
&
aKey
=
=
"
KEY_Escape
"
)
{
let
eventForKeydown
=
Object
.
assign
(
{
}
JSON
.
parse
(
JSON
.
stringify
(
event
)
)
)
;
eventForKeydown
.
type
=
"
keydown
"
;
if
(
_maybeEndDragSession
(
0
0
eventForKeydown
aWindow
)
)
{
if
(
!
dispatchKeyup
)
{
return
;
}
dispatchKeydown
=
false
;
}
}
var
TIP
=
_getTIP
(
aWindow
aCallback
)
;
if
(
!
TIP
)
{
return
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
var
modifiers
=
_emulateToActivateModifiers
(
TIP
event
aWindow
)
;
var
keyEventDict
=
_createKeyboardEventDictionary
(
aKey
event
TIP
aWindow
)
;
var
keyEvent
=
new
KeyboardEvent
(
"
"
keyEventDict
.
dictionary
)
;
try
{
if
(
dispatchKeydown
)
{
TIP
.
keydown
(
keyEvent
keyEventDict
.
flags
)
;
if
(
"
repeat
"
in
event
&
&
event
.
repeat
>
1
)
{
keyEventDict
.
dictionary
.
repeat
=
true
;
var
repeatedKeyEvent
=
new
KeyboardEvent
(
"
"
keyEventDict
.
dictionary
)
;
for
(
var
i
=
1
;
i
<
event
.
repeat
;
i
+
+
)
{
TIP
.
keydown
(
repeatedKeyEvent
keyEventDict
.
flags
)
;
}
}
}
if
(
dispatchKeyup
)
{
TIP
.
keyup
(
keyEvent
keyEventDict
.
flags
)
;
}
}
finally
{
_emulateToInactivateModifiers
(
TIP
modifiers
aWindow
)
;
}
}
function
synthesizeAndWaitKey
(
aKey
aEvent
aWindow
=
window
checkBeforeSynthesize
checkAfterSynthesize
)
{
let
browser
=
gBrowser
.
selectedTab
.
linkedBrowser
;
let
mm
=
browser
.
messageManager
;
let
keyCode
=
_createKeyboardEventDictionary
(
aKey
aEvent
null
aWindow
)
.
dictionary
.
keyCode
;
let
{
ContentTask
}
=
_EU_ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ContentTask
.
sys
.
mjs
"
)
;
let
keyRegisteredPromise
=
new
Promise
(
resolve
=
>
{
mm
.
addMessageListener
(
"
Test
:
KeyRegistered
"
function
processed
(
message
)
{
mm
.
removeMessageListener
(
"
Test
:
KeyRegistered
"
processed
)
;
resolve
(
)
;
}
)
;
}
)
;
let
keyReceivedPromise
=
ContentTask
.
spawn
(
browser
keyCode
keyCode
=
>
{
return
new
Promise
(
resolve
=
>
{
addEventListener
(
"
keyup
"
function
onKeyEvent
(
e
)
{
if
(
e
.
keyCode
=
=
keyCode
)
{
removeEventListener
(
"
keyup
"
onKeyEvent
)
;
resolve
(
)
;
}
}
)
;
sendAsyncMessage
(
"
Test
:
KeyRegistered
"
)
;
}
)
;
}
)
;
keyRegisteredPromise
.
then
(
(
)
=
>
{
if
(
checkBeforeSynthesize
)
{
checkBeforeSynthesize
(
)
;
}
synthesizeKey
(
aKey
aEvent
aWindow
)
;
if
(
checkAfterSynthesize
)
{
checkAfterSynthesize
(
)
;
}
}
)
;
return
keyReceivedPromise
;
}
function
_parseNativeModifiers
(
aModifiers
aWindow
=
window
)
{
let
modifiers
=
0
;
if
(
aModifiers
.
capsLockKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CAPS_LOCK
;
}
if
(
aModifiers
.
numLockKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_NUM_LOCK
;
}
if
(
aModifiers
.
shiftKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_SHIFT_LEFT
;
}
if
(
aModifiers
.
shiftRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_SHIFT_RIGHT
;
}
if
(
aModifiers
.
ctrlKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_LEFT
;
}
if
(
aModifiers
.
ctrlRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_RIGHT
;
}
if
(
aModifiers
.
altKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_LEFT
;
}
if
(
aModifiers
.
altRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_RIGHT
;
}
if
(
aModifiers
.
metaKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_LEFT
;
}
if
(
aModifiers
.
metaRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_RIGHT
;
}
if
(
aModifiers
.
helpKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_HELP
;
}
if
(
aModifiers
.
fnKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_FUNCTION
;
}
if
(
aModifiers
.
numericKeyPadKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_NUMERIC_KEY_PAD
;
}
if
(
aModifiers
.
accelKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_LEFT
:
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_LEFT
;
}
if
(
aModifiers
.
accelRightKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_RIGHT
:
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_RIGHT
;
}
if
(
aModifiers
.
altGrKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_LEFT
:
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_GRAPH
;
}
return
modifiers
;
}
const
KEYBOARD_LAYOUT_ARABIC
=
{
name
:
"
Arabic
"
Mac
:
6
Win
:
0x00000401
hasAltGrOnWin
:
false
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_ARABIC
"
KEYBOARD_LAYOUT_ARABIC
)
;
const
KEYBOARD_LAYOUT_ARABIC_PC
=
{
name
:
"
Arabic
-
PC
"
Mac
:
7
Win
:
null
hasAltGrOnWin
:
false
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_ARABIC_PC
"
KEYBOARD_LAYOUT_ARABIC_PC
)
;
const
KEYBOARD_LAYOUT_BRAZILIAN_ABNT
=
{
name
:
"
Brazilian
ABNT
"
Mac
:
null
Win
:
0x00000416
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_BRAZILIAN_ABNT
"
KEYBOARD_LAYOUT_BRAZILIAN_ABNT
)
;
const
KEYBOARD_LAYOUT_DVORAK_QWERTY
=
{
name
:
"
Dvorak
-
QWERTY
"
Mac
:
4
Win
:
null
hasAltGrOnWin
:
false
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_DVORAK_QWERTY
"
KEYBOARD_LAYOUT_DVORAK_QWERTY
)
;
const
KEYBOARD_LAYOUT_EN_US
=
{
name
:
"
US
"
Mac
:
0
Win
:
0x00000409
hasAltGrOnWin
:
false
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_EN_US
"
KEYBOARD_LAYOUT_EN_US
)
;
const
KEYBOARD_LAYOUT_FRENCH
=
{
name
:
"
French
"
Mac
:
8
Win
:
0x0000040c
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_FRENCH
"
KEYBOARD_LAYOUT_FRENCH
)
;
const
KEYBOARD_LAYOUT_FRENCH_PC
=
{
name
:
"
French
-
PC
"
Mac
:
13
Win
:
0x0000040c
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_FRENCH_PC
"
KEYBOARD_LAYOUT_FRENCH_PC
)
;
const
KEYBOARD_LAYOUT_GREEK
=
{
name
:
"
Greek
"
Mac
:
1
Win
:
0x00000408
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_GREEK
"
KEYBOARD_LAYOUT_GREEK
)
;
const
KEYBOARD_LAYOUT_GERMAN
=
{
name
:
"
German
"
Mac
:
2
Win
:
0x00000407
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_GERMAN
"
KEYBOARD_LAYOUT_GERMAN
)
;
const
KEYBOARD_LAYOUT_HEBREW
=
{
name
:
"
Hebrew
"
Mac
:
9
Win
:
0x0000040d
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_HEBREW
"
KEYBOARD_LAYOUT_HEBREW
)
;
const
KEYBOARD_LAYOUT_JAPANESE
=
{
name
:
"
Japanese
"
Mac
:
null
Win
:
0x00000411
hasAltGrOnWin
:
false
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_JAPANESE
"
KEYBOARD_LAYOUT_JAPANESE
)
;
const
KEYBOARD_LAYOUT_KHMER
=
{
name
:
"
Khmer
"
Mac
:
null
Win
:
0x00000453
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_KHMER
"
KEYBOARD_LAYOUT_KHMER
)
;
const
KEYBOARD_LAYOUT_LITHUANIAN
=
{
name
:
"
Lithuanian
"
Mac
:
10
Win
:
0x00010427
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_LITHUANIAN
"
KEYBOARD_LAYOUT_LITHUANIAN
)
;
const
KEYBOARD_LAYOUT_NORWEGIAN
=
{
name
:
"
Norwegian
"
Mac
:
11
Win
:
0x00000414
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_NORWEGIAN
"
KEYBOARD_LAYOUT_NORWEGIAN
)
;
const
KEYBOARD_LAYOUT_RUSSIAN_MNEMONIC
=
{
name
:
"
Russian
-
Mnemonic
"
Mac
:
null
Win
:
0x00020419
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_RUSSIAN_MNEMONIC
"
KEYBOARD_LAYOUT_RUSSIAN_MNEMONIC
)
;
const
KEYBOARD_LAYOUT_SPANISH
=
{
name
:
"
Spanish
"
Mac
:
12
Win
:
0x0000040a
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_SPANISH
"
KEYBOARD_LAYOUT_SPANISH
)
;
const
KEYBOARD_LAYOUT_SWEDISH
=
{
name
:
"
Swedish
"
Mac
:
3
Win
:
0x0000041d
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_SWEDISH
"
KEYBOARD_LAYOUT_SWEDISH
)
;
const
KEYBOARD_LAYOUT_THAI
=
{
name
:
"
Thai
"
Mac
:
5
Win
:
0x0002041e
hasAltGrOnWin
:
false
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_THAI
"
KEYBOARD_LAYOUT_THAI
)
;
function
synthesizeNativeKey
(
aKeyboardLayout
aNativeKeyCode
aModifiers
aChars
aUnmodifiedChars
aCallback
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
false
;
}
var
nativeKeyboardLayout
=
null
;
if
(
_EU_isMac
(
aWindow
)
)
{
nativeKeyboardLayout
=
aKeyboardLayout
.
Mac
;
}
else
if
(
_EU_isWin
(
aWindow
)
)
{
nativeKeyboardLayout
=
aKeyboardLayout
.
Win
;
}
if
(
nativeKeyboardLayout
=
=
=
null
)
{
return
false
;
}
var
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aCallback
&
&
aTopic
=
=
"
keyevent
"
)
{
aCallback
(
aData
)
;
}
}
}
;
utils
.
sendNativeKeyEvent
(
nativeKeyboardLayout
aNativeKeyCode
_parseNativeModifiers
(
aModifiers
aWindow
)
aChars
aUnmodifiedChars
observer
)
;
return
true
;
}
var
_gSeenEvent
=
false
;
function
_expectEvent
(
aExpectedTarget
aExpectedEvent
aTestName
)
{
if
(
!
aExpectedTarget
|
|
!
aExpectedEvent
)
{
return
null
;
}
_gSeenEvent
=
false
;
var
type
=
aExpectedEvent
.
charAt
(
0
)
=
=
"
!
"
?
aExpectedEvent
.
substring
(
1
)
:
aExpectedEvent
;
var
eventHandler
=
function
(
event
)
{
var
epassed
=
!
_gSeenEvent
&
&
event
.
originalTarget
=
=
aExpectedTarget
&
&
event
.
type
=
=
type
;
is
(
epassed
true
aTestName
+
"
"
+
type
+
"
event
target
"
+
(
_gSeenEvent
?
"
twice
"
:
"
"
)
)
;
_gSeenEvent
=
true
;
}
;
aExpectedTarget
.
addEventListener
(
type
eventHandler
)
;
return
eventHandler
;
}
function
_checkExpectedEvent
(
aExpectedTarget
aExpectedEvent
aEventHandler
aTestName
)
{
if
(
aEventHandler
)
{
var
expectEvent
=
aExpectedEvent
.
charAt
(
0
)
!
=
"
!
"
;
var
type
=
expectEvent
?
aExpectedEvent
:
aExpectedEvent
.
substring
(
1
)
;
aExpectedTarget
.
removeEventListener
(
type
aEventHandler
)
;
var
desc
=
type
+
"
event
"
;
if
(
!
expectEvent
)
{
desc
+
=
"
not
"
;
}
is
(
_gSeenEvent
expectEvent
aTestName
+
"
"
+
desc
+
"
fired
"
)
;
}
_gSeenEvent
=
false
;
}
function
synthesizeMouseExpectEvent
(
aTarget
aOffsetX
aOffsetY
aEvent
aExpectedTarget
aExpectedEvent
aTestName
aWindow
)
{
var
eventHandler
=
_expectEvent
(
aExpectedTarget
aExpectedEvent
aTestName
)
;
synthesizeMouse
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
;
_checkExpectedEvent
(
aExpectedTarget
aExpectedEvent
eventHandler
aTestName
)
;
}
function
synthesizeKeyExpectEvent
(
key
aEvent
aExpectedTarget
aExpectedEvent
aTestName
aWindow
)
{
var
eventHandler
=
_expectEvent
(
aExpectedTarget
aExpectedEvent
aTestName
)
;
synthesizeKey
(
key
aEvent
aWindow
)
;
_checkExpectedEvent
(
aExpectedTarget
aExpectedEvent
eventHandler
aTestName
)
;
}
function
disableNonTestMouseEvents
(
aDisable
)
{
var
domutils
=
_getDOMWindowUtils
(
)
;
domutils
.
disableNonTestMouseEvents
(
aDisable
)
;
}
function
_getDOMWindowUtils
(
aWindow
=
window
)
{
if
(
!
aWindow
)
{
aWindow
=
window
;
}
if
(
!
window
.
document
|
|
window
.
document
.
documentURIObject
)
{
return
aWindow
.
windowUtils
;
}
if
(
"
SpecialPowers
"
in
window
&
&
window
.
SpecialPowers
!
=
undefined
)
{
return
SpecialPowers
.
getDOMWindowUtils
(
aWindow
)
;
}
if
(
"
SpecialPowers
"
in
parent
&
&
parent
.
SpecialPowers
!
=
undefined
)
{
return
parent
.
SpecialPowers
.
getDOMWindowUtils
(
aWindow
)
;
}
return
aWindow
.
windowUtils
;
}
function
_defineConstant
(
name
value
)
{
Object
.
defineProperty
(
this
name
{
value
enumerable
:
true
writable
:
false
}
)
;
}
const
COMPOSITION_ATTR_RAW_CLAUSE
=
_EU_Ci
.
nsITextInputProcessor
.
ATTR_RAW_CLAUSE
;
_defineConstant
(
"
COMPOSITION_ATTR_RAW_CLAUSE
"
COMPOSITION_ATTR_RAW_CLAUSE
)
;
const
COMPOSITION_ATTR_SELECTED_RAW_CLAUSE
=
_EU_Ci
.
nsITextInputProcessor
.
ATTR_SELECTED_RAW_CLAUSE
;
_defineConstant
(
"
COMPOSITION_ATTR_SELECTED_RAW_CLAUSE
"
COMPOSITION_ATTR_SELECTED_RAW_CLAUSE
)
;
const
COMPOSITION_ATTR_CONVERTED_CLAUSE
=
_EU_Ci
.
nsITextInputProcessor
.
ATTR_CONVERTED_CLAUSE
;
_defineConstant
(
"
COMPOSITION_ATTR_CONVERTED_CLAUSE
"
COMPOSITION_ATTR_CONVERTED_CLAUSE
)
;
const
COMPOSITION_ATTR_SELECTED_CLAUSE
=
_EU_Ci
.
nsITextInputProcessor
.
ATTR_SELECTED_CLAUSE
;
_defineConstant
(
"
COMPOSITION_ATTR_SELECTED_CLAUSE
"
COMPOSITION_ATTR_SELECTED_CLAUSE
)
;
var
TIPMap
=
new
WeakMap
(
)
;
function
_getTIP
(
aWindow
aCallback
)
{
if
(
!
aWindow
)
{
aWindow
=
window
;
}
var
tip
;
if
(
TIPMap
.
has
(
aWindow
)
)
{
tip
=
TIPMap
.
get
(
aWindow
)
;
}
else
{
tip
=
_EU_Cc
[
"
mozilla
.
org
/
text
-
input
-
processor
;
1
"
]
.
createInstance
(
_EU_Ci
.
nsITextInputProcessor
)
;
TIPMap
.
set
(
aWindow
tip
)
;
}
if
(
!
tip
.
beginInputTransactionForTests
(
aWindow
aCallback
)
)
{
tip
=
null
;
TIPMap
.
delete
(
aWindow
)
;
}
return
tip
;
}
function
_getKeyboardEvent
(
aWindow
=
window
)
{
if
(
typeof
KeyboardEvent
!
=
"
undefined
"
)
{
try
{
new
KeyboardEvent
(
"
"
{
}
)
;
return
KeyboardEvent
;
}
catch
(
ex
)
{
}
}
if
(
typeof
content
!
=
"
undefined
"
&
&
"
KeyboardEvent
"
in
content
)
{
return
content
.
KeyboardEvent
;
}
return
aWindow
.
KeyboardEvent
;
}
function
_guessKeyNameFromKeyCode
(
aKeyCode
aWindow
=
window
)
{
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
switch
(
aKeyCode
)
{
case
KeyboardEvent
.
DOM_VK_CANCEL
:
return
"
Cancel
"
;
case
KeyboardEvent
.
DOM_VK_HELP
:
return
"
Help
"
;
case
KeyboardEvent
.
DOM_VK_BACK_SPACE
:
return
"
Backspace
"
;
case
KeyboardEvent
.
DOM_VK_TAB
:
return
"
Tab
"
;
case
KeyboardEvent
.
DOM_VK_CLEAR
:
return
"
Clear
"
;
case
KeyboardEvent
.
DOM_VK_RETURN
:
return
"
Enter
"
;
case
KeyboardEvent
.
DOM_VK_SHIFT
:
return
"
Shift
"
;
case
KeyboardEvent
.
DOM_VK_CONTROL
:
return
"
Control
"
;
case
KeyboardEvent
.
DOM_VK_ALT
:
return
"
Alt
"
;
case
KeyboardEvent
.
DOM_VK_PAUSE
:
return
"
Pause
"
;
case
KeyboardEvent
.
DOM_VK_EISU
:
return
"
Eisu
"
;
case
KeyboardEvent
.
DOM_VK_ESCAPE
:
return
"
Escape
"
;
case
KeyboardEvent
.
DOM_VK_CONVERT
:
return
"
Convert
"
;
case
KeyboardEvent
.
DOM_VK_NONCONVERT
:
return
"
NonConvert
"
;
case
KeyboardEvent
.
DOM_VK_ACCEPT
:
return
"
Accept
"
;
case
KeyboardEvent
.
DOM_VK_MODECHANGE
:
return
"
ModeChange
"
;
case
KeyboardEvent
.
DOM_VK_PAGE_UP
:
return
"
PageUp
"
;
case
KeyboardEvent
.
DOM_VK_PAGE_DOWN
:
return
"
PageDown
"
;
case
KeyboardEvent
.
DOM_VK_END
:
return
"
End
"
;
case
KeyboardEvent
.
DOM_VK_HOME
:
return
"
Home
"
;
case
KeyboardEvent
.
DOM_VK_LEFT
:
return
"
ArrowLeft
"
;
case
KeyboardEvent
.
DOM_VK_UP
:
return
"
ArrowUp
"
;
case
KeyboardEvent
.
DOM_VK_RIGHT
:
return
"
ArrowRight
"
;
case
KeyboardEvent
.
DOM_VK_DOWN
:
return
"
ArrowDown
"
;
case
KeyboardEvent
.
DOM_VK_SELECT
:
return
"
Select
"
;
case
KeyboardEvent
.
DOM_VK_PRINT
:
return
"
Print
"
;
case
KeyboardEvent
.
DOM_VK_EXECUTE
:
return
"
Execute
"
;
case
KeyboardEvent
.
DOM_VK_PRINTSCREEN
:
return
"
PrintScreen
"
;
case
KeyboardEvent
.
DOM_VK_INSERT
:
return
"
Insert
"
;
case
KeyboardEvent
.
DOM_VK_DELETE
:
return
"
Delete
"
;
case
KeyboardEvent
.
DOM_VK_WIN
:
return
"
OS
"
;
case
KeyboardEvent
.
DOM_VK_CONTEXT_MENU
:
return
"
ContextMenu
"
;
case
KeyboardEvent
.
DOM_VK_SLEEP
:
return
"
Standby
"
;
case
KeyboardEvent
.
DOM_VK_F1
:
return
"
F1
"
;
case
KeyboardEvent
.
DOM_VK_F2
:
return
"
F2
"
;
case
KeyboardEvent
.
DOM_VK_F3
:
return
"
F3
"
;
case
KeyboardEvent
.
DOM_VK_F4
:
return
"
F4
"
;
case
KeyboardEvent
.
DOM_VK_F5
:
return
"
F5
"
;
case
KeyboardEvent
.
DOM_VK_F6
:
return
"
F6
"
;
case
KeyboardEvent
.
DOM_VK_F7
:
return
"
F7
"
;
case
KeyboardEvent
.
DOM_VK_F8
:
return
"
F8
"
;
case
KeyboardEvent
.
DOM_VK_F9
:
return
"
F9
"
;
case
KeyboardEvent
.
DOM_VK_F10
:
return
"
F10
"
;
case
KeyboardEvent
.
DOM_VK_F11
:
return
"
F11
"
;
case
KeyboardEvent
.
DOM_VK_F12
:
return
"
F12
"
;
case
KeyboardEvent
.
DOM_VK_F13
:
return
"
F13
"
;
case
KeyboardEvent
.
DOM_VK_F14
:
return
"
F14
"
;
case
KeyboardEvent
.
DOM_VK_F15
:
return
"
F15
"
;
case
KeyboardEvent
.
DOM_VK_F16
:
return
"
F16
"
;
case
KeyboardEvent
.
DOM_VK_F17
:
return
"
F17
"
;
case
KeyboardEvent
.
DOM_VK_F18
:
return
"
F18
"
;
case
KeyboardEvent
.
DOM_VK_F19
:
return
"
F19
"
;
case
KeyboardEvent
.
DOM_VK_F20
:
return
"
F20
"
;
case
KeyboardEvent
.
DOM_VK_F21
:
return
"
F21
"
;
case
KeyboardEvent
.
DOM_VK_F22
:
return
"
F22
"
;
case
KeyboardEvent
.
DOM_VK_F23
:
return
"
F23
"
;
case
KeyboardEvent
.
DOM_VK_F24
:
return
"
F24
"
;
case
KeyboardEvent
.
DOM_VK_NUM_LOCK
:
return
"
NumLock
"
;
case
KeyboardEvent
.
DOM_VK_SCROLL_LOCK
:
return
"
ScrollLock
"
;
case
KeyboardEvent
.
DOM_VK_VOLUME_MUTE
:
return
"
AudioVolumeMute
"
;
case
KeyboardEvent
.
DOM_VK_VOLUME_DOWN
:
return
"
AudioVolumeDown
"
;
case
KeyboardEvent
.
DOM_VK_VOLUME_UP
:
return
"
AudioVolumeUp
"
;
case
KeyboardEvent
.
DOM_VK_META
:
return
"
Meta
"
;
case
KeyboardEvent
.
DOM_VK_ALTGR
:
return
"
AltGraph
"
;
case
KeyboardEvent
.
DOM_VK_PROCESSKEY
:
return
"
Process
"
;
case
KeyboardEvent
.
DOM_VK_ATTN
:
return
"
Attn
"
;
case
KeyboardEvent
.
DOM_VK_CRSEL
:
return
"
CrSel
"
;
case
KeyboardEvent
.
DOM_VK_EXSEL
:
return
"
ExSel
"
;
case
KeyboardEvent
.
DOM_VK_EREOF
:
return
"
EraseEof
"
;
case
KeyboardEvent
.
DOM_VK_PLAY
:
return
"
Play
"
;
default
:
return
"
Unidentified
"
;
}
}
function
_createKeyboardEventDictionary
(
aKey
aKeyEvent
aTIP
=
null
aWindow
=
window
)
{
var
result
=
{
dictionary
:
null
flags
:
0
}
;
var
keyCodeIsDefined
=
"
keyCode
"
in
aKeyEvent
;
var
keyCode
=
keyCodeIsDefined
&
&
aKeyEvent
.
keyCode
>
=
0
&
&
aKeyEvent
.
keyCode
<
=
255
?
aKeyEvent
.
keyCode
:
0
;
var
keyName
=
"
Unidentified
"
;
var
code
=
aKeyEvent
.
code
;
if
(
!
aTIP
)
{
aTIP
=
_getTIP
(
aWindow
)
;
}
if
(
aKey
.
indexOf
(
"
KEY_
"
)
=
=
0
)
{
keyName
=
aKey
.
substr
(
"
KEY_
"
.
length
)
;
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_NON_PRINTABLE_KEY
;
if
(
code
=
=
=
undefined
)
{
code
=
aTIP
.
computeCodeValueOfNonPrintableKey
(
keyName
aKeyEvent
.
location
)
;
}
}
else
if
(
aKey
.
indexOf
(
"
VK_
"
)
=
=
0
)
{
keyCode
=
_getKeyboardEvent
(
aWindow
)
[
"
DOM_
"
+
aKey
]
;
if
(
!
keyCode
)
{
throw
new
Error
(
"
Unknown
key
:
"
+
aKey
)
;
}
keyName
=
_guessKeyNameFromKeyCode
(
keyCode
aWindow
)
;
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_NON_PRINTABLE_KEY
;
if
(
code
=
=
=
undefined
)
{
code
=
aTIP
.
computeCodeValueOfNonPrintableKey
(
keyName
aKeyEvent
.
location
)
;
}
}
else
if
(
aKey
!
=
"
"
)
{
keyName
=
aKey
;
if
(
!
keyCodeIsDefined
)
{
keyCode
=
aTIP
.
guessKeyCodeValueOfPrintableKeyInUSEnglishKeyboardLayout
(
aKey
aKeyEvent
.
location
)
;
}
if
(
!
keyCode
)
{
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_KEEP_KEYCODE_ZERO
;
}
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_FORCE_PRINTABLE_KEY
;
if
(
code
=
=
=
undefined
)
{
code
=
aTIP
.
guessCodeValueOfPrintableKeyInUSEnglishKeyboardLayout
(
keyName
aKeyEvent
.
location
)
;
}
}
var
locationIsDefined
=
"
location
"
in
aKeyEvent
;
if
(
locationIsDefined
&
&
aKeyEvent
.
location
=
=
=
0
)
{
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_KEEP_KEY_LOCATION_STANDARD
;
}
if
(
aKeyEvent
.
doNotMarkKeydownAsProcessed
)
{
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_DONT_MARK_KEYDOWN_AS_PROCESSED
;
}
if
(
aKeyEvent
.
markKeyupAsProcessed
)
{
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_MARK_KEYUP_AS_PROCESSED
;
}
result
.
dictionary
=
{
key
:
keyName
code
location
:
locationIsDefined
?
aKeyEvent
.
location
:
0
repeat
:
"
repeat
"
in
aKeyEvent
?
aKeyEvent
.
repeat
=
=
=
true
:
false
keyCode
}
;
return
result
;
}
function
_emulateToActivateModifiers
(
aTIP
aKeyEvent
aWindow
=
window
)
{
if
(
!
aKeyEvent
)
{
return
null
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
var
modifiers
=
{
normal
:
[
{
key
:
"
Alt
"
attr
:
"
altKey
"
}
{
key
:
"
AltGraph
"
attr
:
"
altGraphKey
"
}
{
key
:
"
Control
"
attr
:
"
ctrlKey
"
}
{
key
:
"
Fn
"
attr
:
"
fnKey
"
}
{
key
:
"
Meta
"
attr
:
"
metaKey
"
}
{
key
:
"
Shift
"
attr
:
"
shiftKey
"
}
{
key
:
"
Symbol
"
attr
:
"
symbolKey
"
}
{
key
:
_EU_isMac
(
aWindow
)
?
"
Meta
"
:
"
Control
"
attr
:
"
accelKey
"
}
]
lockable
:
[
{
key
:
"
CapsLock
"
attr
:
"
capsLockKey
"
}
{
key
:
"
FnLock
"
attr
:
"
fnLockKey
"
}
{
key
:
"
NumLock
"
attr
:
"
numLockKey
"
}
{
key
:
"
ScrollLock
"
attr
:
"
scrollLockKey
"
}
{
key
:
"
SymbolLock
"
attr
:
"
symbolLockKey
"
}
]
}
;
for
(
let
i
=
0
;
i
<
modifiers
.
normal
.
length
;
i
+
+
)
{
if
(
!
aKeyEvent
[
modifiers
.
normal
[
i
]
.
attr
]
)
{
continue
;
}
if
(
aTIP
.
getModifierState
(
modifiers
.
normal
[
i
]
.
key
)
)
{
continue
;
}
let
event
=
new
KeyboardEvent
(
"
"
{
key
:
modifiers
.
normal
[
i
]
.
key
}
)
;
aTIP
.
keydown
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
modifiers
.
normal
[
i
]
.
activated
=
true
;
}
for
(
let
i
=
0
;
i
<
modifiers
.
lockable
.
length
;
i
+
+
)
{
if
(
!
aKeyEvent
[
modifiers
.
lockable
[
i
]
.
attr
]
)
{
continue
;
}
if
(
aTIP
.
getModifierState
(
modifiers
.
lockable
[
i
]
.
key
)
)
{
continue
;
}
let
event
=
new
KeyboardEvent
(
"
"
{
key
:
modifiers
.
lockable
[
i
]
.
key
}
)
;
aTIP
.
keydown
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
aTIP
.
keyup
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
modifiers
.
lockable
[
i
]
.
activated
=
true
;
}
return
modifiers
;
}
function
_emulateToInactivateModifiers
(
aTIP
aModifiers
aWindow
=
window
)
{
if
(
!
aModifiers
)
{
return
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
for
(
let
i
=
0
;
i
<
aModifiers
.
normal
.
length
;
i
+
+
)
{
if
(
!
aModifiers
.
normal
[
i
]
.
activated
)
{
continue
;
}
let
event
=
new
KeyboardEvent
(
"
"
{
key
:
aModifiers
.
normal
[
i
]
.
key
}
)
;
aTIP
.
keyup
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
}
for
(
let
i
=
0
;
i
<
aModifiers
.
lockable
.
length
;
i
+
+
)
{
if
(
!
aModifiers
.
lockable
[
i
]
.
activated
)
{
continue
;
}
if
(
!
aTIP
.
getModifierState
(
aModifiers
.
lockable
[
i
]
.
key
)
)
{
continue
;
}
let
event
=
new
KeyboardEvent
(
"
"
{
key
:
aModifiers
.
lockable
[
i
]
.
key
}
)
;
aTIP
.
keydown
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
aTIP
.
keyup
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
}
}
function
synthesizeComposition
(
aEvent
aWindow
=
window
aCallback
)
{
var
TIP
=
_getTIP
(
aWindow
aCallback
)
;
if
(
!
TIP
)
{
return
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
var
modifiers
=
_emulateToActivateModifiers
(
TIP
aEvent
.
key
aWindow
)
;
var
keyEventDict
=
{
dictionary
:
null
flags
:
0
}
;
var
keyEvent
=
null
;
if
(
aEvent
.
key
&
&
typeof
aEvent
.
key
.
key
=
=
=
"
string
"
)
{
keyEventDict
=
_createKeyboardEventDictionary
(
aEvent
.
key
.
key
aEvent
.
key
TIP
aWindow
)
;
keyEvent
=
new
KeyboardEvent
(
aEvent
.
key
.
type
=
=
=
"
keydown
"
?
"
keydown
"
:
aEvent
.
key
.
type
=
=
=
"
keyup
"
?
"
keyup
"
:
"
"
keyEventDict
.
dictionary
)
;
}
else
if
(
aEvent
.
key
=
=
=
undefined
)
{
keyEventDict
=
_createKeyboardEventDictionary
(
"
KEY_Process
"
{
}
TIP
aWindow
)
;
keyEvent
=
new
KeyboardEvent
(
"
"
keyEventDict
.
dictionary
)
;
}
try
{
switch
(
aEvent
.
type
)
{
case
"
compositionstart
"
:
TIP
.
startComposition
(
keyEvent
keyEventDict
.
flags
)
;
break
;
case
"
compositioncommitasis
"
:
TIP
.
commitComposition
(
keyEvent
keyEventDict
.
flags
)
;
break
;
case
"
compositioncommit
"
:
TIP
.
commitCompositionWith
(
aEvent
.
data
keyEvent
keyEventDict
.
flags
)
;
break
;
}
}
finally
{
_emulateToInactivateModifiers
(
TIP
modifiers
aWindow
)
;
}
}
function
synthesizeCompositionChange
(
aEvent
aWindow
=
window
aCallback
)
{
var
TIP
=
_getTIP
(
aWindow
aCallback
)
;
if
(
!
TIP
)
{
return
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
if
(
!
aEvent
.
composition
|
|
!
aEvent
.
composition
.
clauses
|
|
!
aEvent
.
composition
.
clauses
[
0
]
)
{
return
;
}
TIP
.
setPendingCompositionString
(
aEvent
.
composition
.
string
)
;
if
(
aEvent
.
composition
.
clauses
[
0
]
.
length
)
{
for
(
var
i
=
0
;
i
<
aEvent
.
composition
.
clauses
.
length
;
i
+
+
)
{
switch
(
aEvent
.
composition
.
clauses
[
i
]
.
attr
)
{
case
TIP
.
ATTR_RAW_CLAUSE
:
case
TIP
.
ATTR_SELECTED_RAW_CLAUSE
:
case
TIP
.
ATTR_CONVERTED_CLAUSE
:
case
TIP
.
ATTR_SELECTED_CLAUSE
:
TIP
.
appendClauseToPendingComposition
(
aEvent
.
composition
.
clauses
[
i
]
.
length
aEvent
.
composition
.
clauses
[
i
]
.
attr
)
;
break
;
case
0
:
break
;
default
:
throw
new
Error
(
"
invalid
clause
attribute
specified
"
)
;
}
}
}
if
(
aEvent
.
caret
)
{
TIP
.
setCaretInPendingComposition
(
aEvent
.
caret
.
start
)
;
}
var
modifiers
=
_emulateToActivateModifiers
(
TIP
aEvent
.
key
aWindow
)
;
try
{
var
keyEventDict
=
{
dictionary
:
null
flags
:
0
}
;
var
keyEvent
=
null
;
if
(
aEvent
.
key
&
&
typeof
aEvent
.
key
.
key
=
=
=
"
string
"
)
{
keyEventDict
=
_createKeyboardEventDictionary
(
aEvent
.
key
.
key
aEvent
.
key
TIP
aWindow
)
;
keyEvent
=
new
KeyboardEvent
(
aEvent
.
key
.
type
=
=
=
"
keydown
"
?
"
keydown
"
:
aEvent
.
key
.
type
=
=
=
"
keyup
"
?
"
keyup
"
:
"
"
keyEventDict
.
dictionary
)
;
}
else
if
(
aEvent
.
key
=
=
=
undefined
)
{
keyEventDict
=
_createKeyboardEventDictionary
(
"
KEY_Process
"
{
}
TIP
aWindow
)
;
keyEvent
=
new
KeyboardEvent
(
"
"
keyEventDict
.
dictionary
)
;
}
TIP
.
flushPendingComposition
(
keyEvent
keyEventDict
.
flags
)
;
}
finally
{
_emulateToInactivateModifiers
(
TIP
modifiers
aWindow
)
;
}
}
const
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
=
0x0000
;
const
QUERY_CONTENT_FLAG_USE_XP_LINE_BREAK
=
0x0001
;
const
QUERY_CONTENT_FLAG_SELECTION_NORMAL
=
0x0000
;
const
QUERY_CONTENT_FLAG_SELECTION_SPELLCHECK
=
0x0002
;
const
QUERY_CONTENT_FLAG_SELECTION_IME_RAWINPUT
=
0x0004
;
const
QUERY_CONTENT_FLAG_SELECTION_IME_SELECTEDRAWTEXT
=
0x0008
;
const
QUERY_CONTENT_FLAG_SELECTION_IME_CONVERTEDTEXT
=
0x0010
;
const
QUERY_CONTENT_FLAG_SELECTION_IME_SELECTEDCONVERTEDTEXT
=
0x0020
;
const
QUERY_CONTENT_FLAG_SELECTION_ACCESSIBILITY
=
0x0040
;
const
QUERY_CONTENT_FLAG_SELECTION_FIND
=
0x0080
;
const
QUERY_CONTENT_FLAG_SELECTION_URLSECONDARY
=
0x0100
;
const
QUERY_CONTENT_FLAG_SELECTION_URLSTRIKEOUT
=
0x0200
;
const
QUERY_CONTENT_FLAG_OFFSET_RELATIVE_TO_INSERTION_POINT
=
0x0400
;
const
SELECTION_SET_FLAG_USE_NATIVE_LINE_BREAK
=
0x0000
;
const
SELECTION_SET_FLAG_USE_XP_LINE_BREAK
=
0x0001
;
const
SELECTION_SET_FLAG_REVERSE
=
0x0002
;
function
synthesizeQueryTextContent
(
aOffset
aLength
aIsRelative
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
null
;
}
var
flags
=
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
;
if
(
aIsRelative
=
=
=
true
)
{
flags
|
=
QUERY_CONTENT_FLAG_OFFSET_RELATIVE_TO_INSERTION_POINT
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_TEXT_CONTENT
aOffset
aLength
0
0
flags
)
;
}
function
synthesizeQuerySelectedText
(
aSelectionType
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
var
flags
=
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
;
if
(
aSelectionType
)
{
flags
|
=
aSelectionType
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_SELECTED_TEXT
0
0
0
0
flags
)
;
}
function
synthesizeQueryCaretRect
(
aOffset
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
null
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_CARET_RECT
aOffset
0
0
0
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
async
function
synthesizeSelectionSet
(
aOffset
aLength
aReverse
aWindow
=
window
)
{
const
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
false
;
}
await
new
Promise
(
resolve
=
>
aWindow
.
requestAnimationFrame
(
(
)
=
>
aWindow
.
requestAnimationFrame
(
resolve
)
)
)
;
const
flags
=
aReverse
?
SELECTION_SET_FLAG_REVERSE
:
0
;
return
utils
.
sendSelectionSetEvent
(
aOffset
aLength
flags
)
;
}
function
synthesizeQueryTextRect
(
aOffset
aLength
aIsRelative
aWindow
)
{
if
(
aIsRelative
!
=
=
undefined
&
&
typeof
aIsRelative
!
=
=
"
boolean
"
)
{
throw
new
Error
(
"
Maybe
you
set
Window
object
to
the
3rd
argument
but
it
should
be
a
boolean
value
"
)
;
}
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
let
flags
=
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
;
if
(
aIsRelative
=
=
=
true
)
{
flags
|
=
QUERY_CONTENT_FLAG_OFFSET_RELATIVE_TO_INSERTION_POINT
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_TEXT_RECT
aOffset
aLength
0
0
flags
)
;
}
function
synthesizeQueryTextRectArray
(
aOffset
aLength
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_TEXT_RECT_ARRAY
aOffset
aLength
0
0
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
function
synthesizeQueryEditorRect
(
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_EDITOR_RECT
0
0
0
0
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
function
synthesizeCharAtPoint
(
aX
aY
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_CHARACTER_AT_POINT
0
0
aX
aY
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
function
createDragEventObject
(
aType
aDestElement
aDestWindow
aDataTransfer
aDragEvent
)
{
var
destRect
=
aDestElement
.
getBoundingClientRect
(
)
;
var
destClientX
=
destRect
.
left
+
destRect
.
width
/
2
;
var
destClientY
=
destRect
.
top
+
destRect
.
height
/
2
;
var
destScreenX
=
aDestWindow
.
mozInnerScreenX
+
destClientX
;
var
destScreenY
=
aDestWindow
.
mozInnerScreenY
+
destClientY
;
if
(
"
clientX
"
in
aDragEvent
&
&
!
(
"
screenX
"
in
aDragEvent
)
)
{
aDragEvent
.
screenX
=
aDestWindow
.
mozInnerScreenX
+
aDragEvent
.
clientX
;
}
if
(
"
clientY
"
in
aDragEvent
&
&
!
(
"
screenY
"
in
aDragEvent
)
)
{
aDragEvent
.
screenY
=
aDestWindow
.
mozInnerScreenY
+
aDragEvent
.
clientY
;
}
let
dataTransfer
;
if
(
aDataTransfer
)
{
dataTransfer
=
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aDataTransfer
)
.
mozCloneForEvent
(
aType
)
)
;
dataTransfer
.
dropEffect
=
aDataTransfer
.
dropEffect
;
}
return
Object
.
assign
(
{
type
:
aType
screenX
:
destScreenX
screenY
:
destScreenY
clientX
:
destClientX
clientY
:
destClientY
dataTransfer
_domDispatchOnly
:
aDragEvent
.
_domDispatchOnly
}
aDragEvent
)
;
}
function
synthesizeDragOver
(
aSrcElement
aDestElement
aDragData
aDropEffect
aWindow
aDestWindow
aDragEvent
=
{
}
)
{
if
(
!
aWindow
)
{
aWindow
=
window
;
}
if
(
!
aDestWindow
)
{
aDestWindow
=
aWindow
;
}
const
obs
=
_EU_Cc
[
"
mozilla
.
org
/
observer
-
service
;
1
"
]
.
getService
(
_EU_Ci
.
nsIObserverService
)
;
const
ds
=
_EU_Cc
[
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
]
.
getService
(
_EU_Ci
.
nsIDragService
)
;
var
sess
=
ds
.
getCurrentSession
(
)
;
function
fillDrag
(
event
)
{
if
(
aDragData
)
{
for
(
var
i
=
0
;
i
<
aDragData
.
length
;
i
+
+
)
{
var
item
=
aDragData
[
i
]
;
for
(
var
j
=
0
;
j
<
item
.
length
;
j
+
+
)
{
_EU_maybeWrap
(
event
.
dataTransfer
)
.
mozSetDataAt
(
item
[
j
]
.
type
item
[
j
]
.
data
i
)
;
}
}
}
event
.
dataTransfer
.
dropEffect
=
aDropEffect
|
|
"
move
"
;
event
.
preventDefault
(
)
;
}
function
trapDrag
(
subject
topic
)
{
if
(
topic
=
=
"
on
-
datatransfer
-
available
"
)
{
sess
.
dataTransfer
=
_EU_maybeUnwrap
(
_EU_maybeWrap
(
subject
)
.
mozCloneForEvent
(
"
drop
"
)
)
;
sess
.
dataTransfer
.
dropEffect
=
subject
.
dropEffect
;
}
}
aWindow
.
addEventListener
(
"
dragstart
"
fillDrag
true
)
;
obs
.
addObserver
(
trapDrag
"
on
-
datatransfer
-
available
"
)
;
synthesizeMouseAtCenter
(
aSrcElement
{
type
:
"
mousedown
"
}
aWindow
)
;
var
rect
=
aSrcElement
.
getBoundingClientRect
(
)
;
var
x
=
rect
.
width
/
2
;
var
y
=
rect
.
height
/
2
;
synthesizeMouse
(
aSrcElement
x
y
{
type
:
"
mousemove
"
}
aWindow
)
;
synthesizeMouse
(
aSrcElement
x
+
10
y
+
10
{
type
:
"
mousemove
"
}
aWindow
)
;
aWindow
.
removeEventListener
(
"
dragstart
"
fillDrag
true
)
;
obs
.
removeObserver
(
trapDrag
"
on
-
datatransfer
-
available
"
)
;
var
dataTransfer
=
sess
.
dataTransfer
;
if
(
!
dataTransfer
)
{
throw
new
Error
(
"
No
data
transfer
object
after
synthesizing
the
mouse
!
"
)
;
}
var
event
=
createDragEventObject
(
"
dragover
"
aDestElement
aDestWindow
dataTransfer
aDragEvent
)
;
var
result
=
sendDragEvent
(
event
aDestElement
aDestWindow
)
;
return
[
result
dataTransfer
]
;
}
function
synthesizeDropAfterDragOver
(
aResult
aDataTransfer
aDestElement
aDestWindow
aDragEvent
=
{
}
)
{
if
(
!
aDestWindow
)
{
aDestWindow
=
window
;
}
var
effect
=
aDataTransfer
.
dropEffect
;
var
event
;
if
(
aResult
)
{
effect
=
"
none
"
;
}
else
if
(
effect
!
=
"
none
"
)
{
event
=
createDragEventObject
(
"
drop
"
aDestElement
aDestWindow
aDataTransfer
aDragEvent
)
;
sendDragEvent
(
event
aDestElement
aDestWindow
)
;
}
this
.
AccessibilityUtils
?
.
suppressClickHandling
(
true
)
;
synthesizeMouse
(
aDestElement
2
2
{
type
:
"
mouseup
"
}
aDestWindow
)
;
this
.
AccessibilityUtils
?
.
suppressClickHandling
(
false
)
;
return
effect
;
}
function
synthesizeDrop
(
aSrcElement
aDestElement
aDragData
aDropEffect
aWindow
aDestWindow
aDragEvent
=
{
}
)
{
if
(
!
aWindow
)
{
aWindow
=
window
;
}
if
(
!
aDestWindow
)
{
aDestWindow
=
aWindow
;
}
var
ds
=
_EU_Cc
[
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
]
.
getService
(
_EU_Ci
.
nsIDragService
)
;
let
dropAction
;
switch
(
aDropEffect
)
{
case
null
:
case
undefined
:
case
"
move
"
:
dropAction
=
_EU_Ci
.
nsIDragService
.
DRAGDROP_ACTION_MOVE
;
break
;
case
"
copy
"
:
dropAction
=
_EU_Ci
.
nsIDragService
.
DRAGDROP_ACTION_COPY
;
break
;
case
"
link
"
:
dropAction
=
_EU_Ci
.
nsIDragService
.
DRAGDROP_ACTION_LINK
;
break
;
default
:
throw
new
Error
(
{
aDropEffect
}
is
an
invalid
drop
effect
value
)
;
}
ds
.
startDragSessionForTests
(
dropAction
)
;
try
{
var
[
result
dataTransfer
]
=
synthesizeDragOver
(
aSrcElement
aDestElement
aDragData
aDropEffect
aWindow
aDestWindow
aDragEvent
)
;
return
synthesizeDropAfterDragOver
(
result
dataTransfer
aDestElement
aDestWindow
aDragEvent
)
;
}
finally
{
ds
.
endDragSession
(
true
_parseModifiers
(
aDragEvent
)
)
;
}
}
function
_getFlattenedTreeParentNode
(
aNode
)
{
return
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aNode
)
.
flattenedTreeParentNode
)
;
}
function
_getInclusiveFlattenedTreeParentElement
(
aNode
)
{
for
(
let
inclusiveAncestor
=
aNode
;
inclusiveAncestor
;
inclusiveAncestor
=
_getFlattenedTreeParentNode
(
inclusiveAncestor
)
)
{
if
(
inclusiveAncestor
.
nodeType
=
=
Node
.
ELEMENT_NODE
)
{
return
inclusiveAncestor
;
}
}
return
null
;
}
function
_nodeIsFlattenedTreeDescendantOf
(
aPossibleDescendant
aPossibleAncestor
)
{
do
{
if
(
aPossibleDescendant
=
=
aPossibleAncestor
)
{
return
true
;
}
aPossibleDescendant
=
_getFlattenedTreeParentNode
(
aPossibleDescendant
)
;
}
while
(
aPossibleDescendant
)
;
return
false
;
}
function
_computeSrcElementFromSrcSelection
(
aSrcSelection
)
{
let
srcElement
=
aSrcSelection
.
focusNode
;
while
(
_EU_maybeWrap
(
srcElement
)
.
isNativeAnonymous
)
{
srcElement
=
_getFlattenedTreeParentNode
(
srcElement
)
;
}
if
(
srcElement
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
srcElement
=
_getInclusiveFlattenedTreeParentElement
(
srcElement
)
;
}
return
srcElement
;
}
async
function
synthesizePlainDragAndDrop
(
aParams
)
{
let
{
dragEvent
=
{
}
srcElement
srcSelection
destElement
srcX
=
2
srcY
=
2
stepX
=
9
stepY
=
9
finalX
=
srcX
+
stepX
*
2
finalY
=
srcY
+
stepY
*
2
id
=
_getDOMWindowUtils
(
window
)
.
DEFAULT_MOUSE_POINTER_ID
srcWindow
=
window
destWindow
=
window
expectCancelDragStart
=
false
expectSrcElementDisconnected
=
false
logFunc
}
=
aParams
;
if
(
aParams
.
dragEvent
!
=
=
undefined
)
{
dragEvent
=
Object
.
assign
(
{
}
aParams
.
dragEvent
)
;
}
function
rectToString
(
aRect
)
{
return
left
:
{
aRect
.
left
}
top
:
{
aRect
.
top
}
right
:
{
aRect
.
right
}
bottom
:
{
aRect
.
bottom
}
;
}
if
(
logFunc
)
{
logFunc
(
"
synthesizePlainDragAndDrop
(
)
-
-
START
"
)
;
}
if
(
srcSelection
)
{
srcElement
=
_computeSrcElementFromSrcSelection
(
srcSelection
)
;
let
srcElementRect
=
srcElement
.
getBoundingClientRect
(
)
;
if
(
logFunc
)
{
logFunc
(
srcElement
.
getBoundingClientRect
(
)
:
{
rectToString
(
srcElementRect
)
}
)
;
}
let
selectionRectList
=
srcSelection
.
getRangeAt
(
0
)
.
getClientRects
(
)
;
let
lastSelectionRect
=
selectionRectList
[
selectionRectList
.
length
-
1
]
;
if
(
logFunc
)
{
logFunc
(
srcSelection
.
getRangeAt
(
0
)
.
getClientRects
(
)
[
{
selectionRectList
.
length
-
1
}
]
:
{
rectToString
(
lastSelectionRect
)
}
)
;
}
srcX
=
Math
.
floor
(
lastSelectionRect
.
left
+
lastSelectionRect
.
width
/
2
)
;
srcY
=
Math
.
floor
(
lastSelectionRect
.
top
+
lastSelectionRect
.
height
/
2
)
;
srcX
=
Math
.
floor
(
srcX
-
srcElementRect
.
left
)
;
srcY
=
Math
.
floor
(
srcY
-
srcElementRect
.
top
)
;
if
(
aParams
.
finalX
=
=
=
undefined
)
{
finalX
=
srcX
+
stepX
*
2
;
}
if
(
aParams
.
finalY
=
=
=
undefined
)
{
finalY
=
srcY
+
stepY
*
2
;
}
}
else
if
(
logFunc
)
{
logFunc
(
srcElement
.
getBoundingClientRect
(
)
:
{
rectToString
(
srcElement
.
getBoundingClientRect
(
)
)
}
)
;
}
const
ds
=
_EU_Cc
[
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
]
.
getService
(
_EU_Ci
.
nsIDragService
)
;
const
editingHost
=
(
(
)
=
>
{
if
(
!
srcElement
.
matches
(
"
:
read
-
write
"
)
)
{
return
null
;
}
let
lastEditableElement
=
srcElement
;
for
(
let
inclusiveAncestor
=
_getInclusiveFlattenedTreeParentElement
(
srcElement
)
;
inclusiveAncestor
;
inclusiveAncestor
=
_getInclusiveFlattenedTreeParentElement
(
_getFlattenedTreeParentNode
(
inclusiveAncestor
)
)
)
{
if
(
inclusiveAncestor
.
matches
(
"
:
read
-
write
"
)
)
{
lastEditableElement
=
inclusiveAncestor
;
if
(
lastEditableElement
=
=
srcElement
.
ownerDocument
.
body
)
{
break
;
}
}
}
return
lastEditableElement
;
}
)
(
)
;
try
{
_getDOMWindowUtils
(
srcWindow
)
.
disableNonTestMouseEvents
(
true
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
let
mouseDownEvent
;
function
onMouseDown
(
aEvent
)
{
mouseDownEvent
=
aEvent
;
if
(
logFunc
)
{
logFunc
(
"
{
aEvent
.
type
}
"
event
is
fired
on
{
aEvent
.
target
}
(
composedTarget
:
{
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aEvent
)
.
composedTarget
)
}
)
;
}
if
(
!
_nodeIsFlattenedTreeDescendantOf
(
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aEvent
)
.
composedTarget
)
srcElement
)
)
{
throw
new
Error
(
'
event
target
of
"
mousedown
"
is
not
srcElement
nor
its
descendant
'
)
;
}
}
try
{
srcWindow
.
addEventListener
(
"
mousedown
"
onMouseDown
{
capture
:
true
}
)
;
synthesizeMouse
(
srcElement
srcX
srcY
{
type
:
"
mousedown
"
id
}
srcWindow
)
;
if
(
logFunc
)
{
logFunc
(
mousedown
at
{
srcX
}
{
srcY
}
)
;
}
if
(
!
mouseDownEvent
)
{
throw
new
Error
(
'
"
mousedown
"
event
is
not
fired
'
)
;
}
}
finally
{
srcWindow
.
removeEventListener
(
"
mousedown
"
onMouseDown
{
capture
:
true
}
)
;
}
let
dragStartEvent
;
function
onDragStart
(
aEvent
)
{
dragStartEvent
=
aEvent
;
if
(
logFunc
)
{
logFunc
(
"
{
aEvent
.
type
}
"
event
is
fired
)
;
}
if
(
!
_nodeIsFlattenedTreeDescendantOf
(
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aEvent
)
.
composedTarget
)
srcElement
)
)
{
throw
new
Error
(
'
event
target
of
"
dragstart
"
is
not
srcElement
nor
its
descendant
'
)
;
}
}
let
dragEnterEvent
;
function
onDragEnterGenerated
(
aEvent
)
{
dragEnterEvent
=
aEvent
;
}
srcWindow
.
addEventListener
(
"
dragstart
"
onDragStart
{
capture
:
true
}
)
;
srcWindow
.
addEventListener
(
"
dragenter
"
onDragEnterGenerated
{
capture
:
true
}
)
;
try
{
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
srcX
+
=
stepX
;
srcY
+
=
stepY
;
synthesizeMouse
(
srcElement
srcX
srcY
{
type
:
"
mousemove
"
id
}
srcWindow
)
;
if
(
logFunc
)
{
logFunc
(
first
mousemove
at
{
srcX
}
{
srcY
}
)
;
}
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
srcX
+
=
stepX
;
srcY
+
=
stepY
;
synthesizeMouse
(
srcElement
srcX
srcY
{
type
:
"
mousemove
"
id
}
srcWindow
)
;
if
(
logFunc
)
{
logFunc
(
second
mousemove
at
{
srcX
}
{
srcY
}
)
;
}
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
if
(
!
dragStartEvent
)
{
throw
new
Error
(
'
"
dragstart
"
event
is
not
fired
'
)
;
}
}
finally
{
srcWindow
.
removeEventListener
(
"
dragstart
"
onDragStart
{
capture
:
true
}
)
;
srcWindow
.
removeEventListener
(
"
dragenter
"
onDragEnterGenerated
{
capture
:
true
}
)
;
}
let
session
=
ds
.
getCurrentSession
(
)
;
if
(
!
session
)
{
if
(
expectCancelDragStart
)
{
synthesizeMouse
(
srcElement
finalX
finalY
{
type
:
"
mouseup
"
id
}
srcWindow
)
;
return
;
}
throw
new
Error
(
"
drag
hasn
'
t
been
started
by
the
operation
"
)
;
}
else
if
(
expectCancelDragStart
)
{
throw
new
Error
(
"
drag
has
been
started
by
the
operation
"
)
;
}
if
(
destElement
)
{
if
(
(
srcElement
!
=
destElement
&
&
!
dragEnterEvent
)
|
|
destElement
!
=
dragEnterEvent
.
target
)
{
if
(
logFunc
)
{
logFunc
(
destElement
.
getBoundingClientRect
(
)
:
{
rectToString
(
destElement
.
getBoundingClientRect
(
)
)
}
)
;
}
function
onDragEnter
(
aEvent
)
{
dragEnterEvent
=
aEvent
;
if
(
logFunc
)
{
logFunc
(
"
{
aEvent
.
type
}
"
event
is
fired
)
;
}
if
(
aEvent
.
target
!
=
destElement
)
{
throw
new
Error
(
'
event
target
of
"
dragenter
"
is
not
destElement
'
)
;
}
}
destWindow
.
addEventListener
(
"
dragenter
"
onDragEnter
{
capture
:
true
}
)
;
try
{
let
event
=
createDragEventObject
(
"
dragenter
"
destElement
destWindow
null
dragEvent
)
;
sendDragEvent
(
event
destElement
destWindow
)
;
if
(
!
dragEnterEvent
&
&
!
destElement
.
disabled
)
{
throw
new
Error
(
'
"
dragenter
"
event
is
not
fired
'
)
;
}
if
(
dragEnterEvent
&
&
destElement
.
disabled
)
{
throw
new
Error
(
'
"
dragenter
"
event
should
not
be
fired
on
disable
element
'
)
;
}
}
finally
{
destWindow
.
removeEventListener
(
"
dragenter
"
onDragEnter
{
capture
:
true
}
)
;
}
}
let
dragOverEvent
;
function
onDragOver
(
aEvent
)
{
dragOverEvent
=
aEvent
;
if
(
logFunc
)
{
logFunc
(
"
{
aEvent
.
type
}
"
event
is
fired
)
;
}
if
(
aEvent
.
target
!
=
destElement
)
{
throw
new
Error
(
'
event
target
of
"
dragover
"
is
not
destElement
'
)
;
}
}
destWindow
.
addEventListener
(
"
dragover
"
onDragOver
{
capture
:
true
}
)
;
try
{
let
event
=
createDragEventObject
(
"
dragover
"
destElement
destWindow
null
dragEvent
)
;
sendDragEvent
(
event
destElement
destWindow
)
;
if
(
!
dragOverEvent
&
&
!
destElement
.
disabled
)
{
throw
new
Error
(
'
"
dragover
"
event
is
not
fired
'
)
;
}
if
(
dragEnterEvent
&
&
destElement
.
disabled
)
{
throw
new
Error
(
'
"
dragover
"
event
should
not
be
fired
on
disable
element
'
)
;
}
}
finally
{
destWindow
.
removeEventListener
(
"
dragover
"
onDragOver
{
capture
:
true
}
)
;
}
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
if
(
session
.
dragAction
!
=
_EU_Ci
.
nsIDragService
.
DRAGDROP_ACTION_NONE
)
{
let
dropEvent
;
function
onDrop
(
aEvent
)
{
dropEvent
=
aEvent
;
if
(
logFunc
)
{
logFunc
(
"
{
aEvent
.
type
}
"
event
is
fired
)
;
}
if
(
!
_nodeIsFlattenedTreeDescendantOf
(
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aEvent
)
.
composedTarget
)
destElement
)
)
{
throw
new
Error
(
'
event
target
of
"
drop
"
is
not
destElement
nor
its
descendant
'
)
;
}
}
destWindow
.
addEventListener
(
"
drop
"
onDrop
{
capture
:
true
}
)
;
try
{
let
event
=
createDragEventObject
(
"
drop
"
destElement
destWindow
null
dragEvent
)
;
sendDragEvent
(
event
destElement
destWindow
)
;
if
(
!
dropEvent
&
&
session
.
canDrop
)
{
throw
new
Error
(
'
"
drop
"
event
is
not
fired
'
)
;
}
}
finally
{
destWindow
.
removeEventListener
(
"
drop
"
onDrop
{
capture
:
true
}
)
;
}
return
;
}
}
dragEvent
.
clientX
=
finalX
;
dragEvent
.
clientY
=
finalY
;
let
event
=
createDragEventObject
(
"
dragend
"
destElement
|
|
srcElement
destElement
?
srcWindow
:
destWindow
null
dragEvent
)
;
session
.
setDragEndPointForTests
(
event
.
screenX
event
.
screenY
)
;
}
finally
{
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
if
(
ds
.
getCurrentSession
(
)
)
{
const
sourceNode
=
ds
.
sourceNode
;
let
dragEndEvent
;
function
onDragEnd
(
aEvent
)
{
dragEndEvent
=
aEvent
;
if
(
logFunc
)
{
logFunc
(
"
{
aEvent
.
type
}
"
event
is
fired
)
;
}
if
(
!
_nodeIsFlattenedTreeDescendantOf
(
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aEvent
)
.
composedTarget
)
srcElement
)
&
&
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aEvent
)
.
composedTarget
)
!
=
editingHost
)
{
throw
new
Error
(
'
event
target
of
"
dragend
"
is
not
srcElement
nor
its
descendant
'
)
;
}
if
(
expectSrcElementDisconnected
)
{
throw
new
Error
(
"
dragend
"
event
shouldn
'
t
be
fired
when
the
source
node
is
disconnected
(
the
source
node
is
{
sourceNode
?
.
isConnected
?
"
connected
"
:
"
null
or
disconnected
"
}
)
)
;
}
}
srcWindow
.
addEventListener
(
"
dragend
"
onDragEnd
{
capture
:
true
}
)
;
try
{
ds
.
endDragSession
(
true
_parseModifiers
(
dragEvent
)
)
;
if
(
!
expectSrcElementDisconnected
&
&
!
dragEndEvent
)
{
throw
new
Error
(
"
dragend
"
event
is
not
fired
by
nsIDragService
.
endDragSession
(
)
{
ds
.
sourceNode
&
&
!
ds
.
sourceNode
.
isConnected
?
"
(
sourceNode
was
disconnected
)
"
:
"
"
}
)
;
}
}
finally
{
srcWindow
.
removeEventListener
(
"
dragend
"
onDragEnd
{
capture
:
true
}
)
;
}
}
_getDOMWindowUtils
(
srcWindow
)
.
disableNonTestMouseEvents
(
false
)
;
if
(
logFunc
)
{
logFunc
(
"
synthesizePlainDragAndDrop
(
)
-
-
END
"
)
;
}
}
}
function
_checkDataTransferItems
(
aDataTransfer
aExpectedDragData
)
{
try
{
let
dataTransfer
=
_EU_maybeWrap
(
aDataTransfer
)
;
if
(
!
dataTransfer
)
{
return
null
;
}
if
(
aExpectedDragData
=
=
null
|
|
dataTransfer
.
mozItemCount
!
=
aExpectedDragData
.
length
)
{
return
dataTransfer
;
}
for
(
let
i
=
0
;
i
<
dataTransfer
.
mozItemCount
;
i
+
+
)
{
let
dtTypes
=
dataTransfer
.
mozTypesAt
(
i
)
;
if
(
dtTypes
.
length
!
=
aExpectedDragData
[
i
]
.
length
)
{
return
dataTransfer
;
}
for
(
let
j
=
0
;
j
<
dtTypes
.
length
;
j
+
+
)
{
if
(
dtTypes
[
j
]
!
=
aExpectedDragData
[
i
]
[
j
]
.
type
)
{
return
dataTransfer
;
}
let
dtData
=
dataTransfer
.
mozGetDataAt
(
dtTypes
[
j
]
i
)
;
if
(
aExpectedDragData
[
i
]
[
j
]
.
eqTest
)
{
if
(
!
aExpectedDragData
[
i
]
[
j
]
.
eqTest
(
dtData
aExpectedDragData
[
i
]
[
j
]
.
data
)
)
{
return
dataTransfer
;
}
}
else
if
(
aExpectedDragData
[
i
]
[
j
]
.
data
!
=
dtData
)
{
return
dataTransfer
;
}
}
}
}
catch
(
ex
)
{
return
ex
;
}
return
true
;
}
async
function
synthesizePlainDragAndCancel
(
aParams
aExpectedDataTransferItems
)
{
let
srcElement
=
aParams
.
srcSelection
?
_computeSrcElementFromSrcSelection
(
aParams
.
srcSelection
)
:
aParams
.
srcElement
;
let
result
;
function
onDragStart
(
aEvent
)
{
aEvent
.
preventDefault
(
)
;
result
=
_checkDataTransferItems
(
aEvent
.
dataTransfer
aExpectedDataTransferItems
)
;
}
SpecialPowers
.
addSystemEventListener
(
srcElement
.
ownerDocument
"
dragstart
"
onDragStart
{
capture
:
true
}
)
;
try
{
aParams
.
expectCancelDragStart
=
true
;
await
synthesizePlainDragAndDrop
(
aParams
)
;
}
finally
{
SpecialPowers
.
removeSystemEventListener
(
srcElement
.
ownerDocument
"
dragstart
"
onDragStart
{
capture
:
true
}
)
;
}
return
result
;
}
class
EventCounter
{
constructor
(
aTarget
aType
aOptions
=
{
}
)
{
this
.
target
=
aTarget
;
this
.
type
=
aType
;
this
.
options
=
aOptions
;
this
.
eventCount
=
0
;
this
.
handleEvent
=
aEvent
=
>
{
this
.
eventCount
+
+
;
}
;
if
(
aOptions
.
mozSystemGroup
)
{
SpecialPowers
.
addSystemEventListener
(
aTarget
aType
this
.
handleEvent
aOptions
.
capture
)
;
}
else
{
aTarget
.
addEventListener
(
aType
this
aOptions
)
;
}
}
unregister
(
)
{
if
(
this
.
options
.
mozSystemGroup
)
{
SpecialPowers
.
removeSystemEventListener
(
this
.
target
this
.
type
this
.
handleEvent
this
.
options
.
capture
)
;
}
else
{
this
.
target
.
removeEventListener
(
this
.
type
this
this
.
options
)
;
}
}
get
count
(
)
{
return
this
.
eventCount
;
}
}
