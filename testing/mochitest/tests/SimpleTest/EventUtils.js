window
.
__defineGetter__
(
'
_EU_Ci
'
function
(
)
{
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
'
Components
'
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
Ci
:
SpecialPowers
.
Ci
;
}
)
;
window
.
__defineGetter__
(
'
_EU_Cc
'
function
(
)
{
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
'
Components
'
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
Cc
:
SpecialPowers
.
Cc
;
}
)
;
window
.
__defineGetter__
(
'
_EU_Cu
'
function
(
)
{
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
'
Components
'
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
Cu
:
SpecialPowers
.
Cu
;
}
)
;
window
.
__defineGetter__
(
"
_EU_OS
"
function
(
)
{
delete
this
.
_EU_OS
;
try
{
this
.
_EU_OS
=
this
.
_EU_Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
{
}
)
.
platform
;
}
catch
(
ex
)
{
this
.
_EU_OS
=
null
;
}
return
this
.
_EU_OS
;
}
)
;
function
_EU_isMac
(
aWindow
=
window
)
{
if
(
window
.
_EU_OS
)
{
return
window
.
_EU_OS
=
=
"
macosx
"
;
}
if
(
aWindow
)
{
try
{
return
aWindow
.
navigator
.
platform
.
indexOf
(
"
Mac
"
)
>
-
1
;
}
catch
(
ex
)
{
}
}
return
navigator
.
platform
.
indexOf
(
"
Mac
"
)
>
-
1
;
}
function
_EU_isWin
(
aWindow
=
window
)
{
if
(
window
.
_EU_OS
)
{
return
window
.
_EU_OS
=
=
"
win
"
;
}
if
(
aWindow
)
{
try
{
return
aWindow
.
navigator
.
platform
.
indexOf
(
"
Win
"
)
>
-
1
;
}
catch
(
ex
)
{
}
}
return
navigator
.
platform
.
indexOf
(
"
Win
"
)
>
-
1
;
}
function
_EU_isLinux
(
aWindow
=
window
)
{
if
(
window
.
_EU_OS
)
{
return
window
.
_EU_OS
=
=
"
linux
"
;
}
if
(
aWindow
)
{
try
{
return
aWindow
.
navigator
.
platform
.
startsWith
(
"
Linux
"
)
;
}
catch
(
ex
)
{
}
}
return
navigator
.
platform
.
startsWith
(
"
Linux
"
)
;
}
function
_EU_isAndroid
(
aWindow
=
window
)
{
if
(
window
.
_EU_OS
)
{
return
window
.
_EU_OS
=
=
"
android
"
;
}
if
(
aWindow
)
{
try
{
return
aWindow
.
navigator
.
userAgent
.
includes
(
"
Android
"
)
;
}
catch
(
ex
)
{
}
}
return
navigator
.
userAgent
.
includes
(
"
Android
"
)
;
}
function
_EU_maybeWrap
(
o
)
{
var
haveWrap
=
false
;
try
{
haveWrap
=
SpecialPowers
.
wrap
!
=
undefined
;
}
catch
(
e
)
{
}
if
(
!
haveWrap
)
{
return
o
;
}
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
'
Components
'
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
o
:
SpecialPowers
.
wrap
(
o
)
;
}
function
_EU_maybeUnwrap
(
o
)
{
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
'
Components
'
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
o
:
SpecialPowers
.
unwrap
(
o
)
;
}
function
getElement
(
id
)
{
return
(
(
typeof
(
id
)
=
=
"
string
"
)
?
document
.
getElementById
(
id
)
:
id
)
;
}
;
this
.
=
this
.
getElement
;
function
computeButton
(
aEvent
)
{
if
(
typeof
aEvent
.
button
!
=
'
undefined
'
)
{
return
aEvent
.
button
;
}
return
aEvent
.
type
=
=
'
contextmenu
'
?
2
:
0
;
}
function
sendMouseEvent
(
aEvent
aTarget
aWindow
)
{
if
(
!
[
'
click
'
'
contextmenu
'
'
dblclick
'
'
mousedown
'
'
mouseup
'
'
mouseover
'
'
mouseout
'
]
.
includes
(
aEvent
.
type
)
)
{
throw
new
Error
(
"
sendMouseEvent
doesn
'
t
know
about
event
type
'
"
+
aEvent
.
type
+
"
'
"
)
;
}
if
(
!
aWindow
)
{
aWindow
=
window
;
}
if
(
typeof
aTarget
=
=
"
string
"
)
{
aTarget
=
aWindow
.
document
.
getElementById
(
aTarget
)
;
}
var
event
=
aWindow
.
document
.
createEvent
(
'
MouseEvent
'
)
;
var
typeArg
=
aEvent
.
type
;
var
canBubbleArg
=
true
;
var
cancelableArg
=
true
;
var
viewArg
=
aWindow
;
var
detailArg
=
aEvent
.
detail
|
|
(
aEvent
.
type
=
=
'
click
'
|
|
aEvent
.
type
=
=
'
mousedown
'
|
|
aEvent
.
type
=
=
'
mouseup
'
?
1
:
aEvent
.
type
=
=
'
dblclick
'
?
2
:
0
)
;
var
screenXArg
=
aEvent
.
screenX
|
|
0
;
var
screenYArg
=
aEvent
.
screenY
|
|
0
;
var
clientXArg
=
aEvent
.
clientX
|
|
0
;
var
clientYArg
=
aEvent
.
clientY
|
|
0
;
var
ctrlKeyArg
=
aEvent
.
ctrlKey
|
|
false
;
var
altKeyArg
=
aEvent
.
altKey
|
|
false
;
var
shiftKeyArg
=
aEvent
.
shiftKey
|
|
false
;
var
metaKeyArg
=
aEvent
.
metaKey
|
|
false
;
var
buttonArg
=
computeButton
(
aEvent
)
;
var
relatedTargetArg
=
aEvent
.
relatedTarget
|
|
null
;
event
.
initMouseEvent
(
typeArg
canBubbleArg
cancelableArg
viewArg
detailArg
screenXArg
screenYArg
clientXArg
clientYArg
ctrlKeyArg
altKeyArg
shiftKeyArg
metaKeyArg
buttonArg
relatedTargetArg
)
;
if
(
!
window
.
document
|
|
window
.
document
.
documentURIObject
)
return
aTarget
.
dispatchEvent
(
event
)
;
return
SpecialPowers
.
dispatchEvent
(
aWindow
aTarget
event
)
;
}
function
isHidden
(
aElement
)
{
var
box
=
aElement
.
getBoundingClientRect
(
)
;
return
box
.
width
=
=
0
&
&
box
.
height
=
=
0
;
}
function
sendDragEvent
(
aEvent
aTarget
aWindow
=
window
)
{
if
(
!
[
'
drag
'
'
dragstart
'
'
dragend
'
'
dragover
'
'
dragenter
'
'
dragleave
'
'
drop
'
]
.
includes
(
aEvent
.
type
)
)
{
throw
new
Error
(
"
sendDragEvent
doesn
'
t
know
about
event
type
'
"
+
aEvent
.
type
+
"
'
"
)
;
}
if
(
typeof
aTarget
=
=
"
string
"
)
{
aTarget
=
aWindow
.
document
.
getElementById
(
aTarget
)
;
}
if
(
aEvent
.
type
!
=
'
dragend
'
&
&
isHidden
(
aTarget
)
)
{
var
targetName
=
aTarget
.
nodeName
;
if
(
"
id
"
in
aTarget
&
&
aTarget
.
id
)
{
targetName
+
=
"
#
"
+
aTarget
.
id
;
}
throw
new
Error
(
{
aEvent
.
type
}
event
target
{
targetName
}
is
hidden
)
;
}
var
event
=
aWindow
.
document
.
createEvent
(
'
DragEvent
'
)
;
var
typeArg
=
aEvent
.
type
;
var
canBubbleArg
=
true
;
var
cancelableArg
=
true
;
var
viewArg
=
aWindow
;
var
detailArg
=
aEvent
.
detail
|
|
0
;
var
screenXArg
=
aEvent
.
screenX
|
|
0
;
var
screenYArg
=
aEvent
.
screenY
|
|
0
;
var
clientXArg
=
aEvent
.
clientX
|
|
0
;
var
clientYArg
=
aEvent
.
clientY
|
|
0
;
var
ctrlKeyArg
=
aEvent
.
ctrlKey
|
|
false
;
var
altKeyArg
=
aEvent
.
altKey
|
|
false
;
var
shiftKeyArg
=
aEvent
.
shiftKey
|
|
false
;
var
metaKeyArg
=
aEvent
.
metaKey
|
|
false
;
var
buttonArg
=
computeButton
(
aEvent
)
;
var
relatedTargetArg
=
aEvent
.
relatedTarget
|
|
null
;
var
dataTransfer
=
aEvent
.
dataTransfer
|
|
null
;
event
.
initDragEvent
(
typeArg
canBubbleArg
cancelableArg
viewArg
detailArg
screenXArg
screenYArg
clientXArg
clientYArg
ctrlKeyArg
altKeyArg
shiftKeyArg
metaKeyArg
buttonArg
relatedTargetArg
dataTransfer
)
;
if
(
aEvent
.
_domDispatchOnly
)
{
return
aTarget
.
dispatchEvent
(
event
)
;
}
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
return
utils
.
dispatchDOMEventViaPresShell
(
aTarget
event
true
)
;
}
function
sendChar
(
aChar
aWindow
)
{
var
hasShift
;
switch
(
aChar
)
{
case
"
!
"
:
case
"
"
:
case
"
#
"
:
case
"
"
:
case
"
%
"
:
case
"
^
"
:
case
"
&
"
:
case
"
*
"
:
case
"
(
"
:
case
"
)
"
:
case
"
_
"
:
case
"
+
"
:
case
"
{
"
:
case
"
}
"
:
case
"
:
"
:
case
"
\
"
"
:
case
"
|
"
:
case
"
<
"
:
case
"
>
"
:
case
"
?
"
:
hasShift
=
true
;
break
;
default
:
hasShift
=
aChar
.
toLowerCase
(
)
!
=
aChar
.
toUpperCase
(
)
&
&
aChar
=
=
aChar
.
toUpperCase
(
)
;
break
;
}
synthesizeKey
(
aChar
{
shiftKey
:
hasShift
}
aWindow
)
;
}
function
sendString
(
aStr
aWindow
)
{
for
(
var
i
=
0
;
i
<
aStr
.
length
;
+
+
i
)
{
sendChar
(
aStr
.
charAt
(
i
)
aWindow
)
;
}
}
function
sendKey
(
aKey
aWindow
)
{
var
keyName
=
"
VK_
"
+
aKey
.
toUpperCase
(
)
;
synthesizeKey
(
keyName
{
shiftKey
:
false
}
aWindow
)
;
}
function
_parseModifiers
(
aEvent
aWindow
=
window
)
{
var
navigator
=
_getNavigator
(
aWindow
)
;
var
nsIDOMWindowUtils
=
_EU_Ci
.
nsIDOMWindowUtils
;
var
mval
=
0
;
if
(
aEvent
.
shiftKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_SHIFT
;
}
if
(
aEvent
.
ctrlKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_CONTROL
;
}
if
(
aEvent
.
altKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_ALT
;
}
if
(
aEvent
.
metaKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_META
;
}
if
(
aEvent
.
accelKey
)
{
mval
|
=
_EU_isMac
(
aWindow
)
?
nsIDOMWindowUtils
.
MODIFIER_META
:
nsIDOMWindowUtils
.
MODIFIER_CONTROL
;
}
if
(
aEvent
.
altGrKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_ALTGRAPH
;
}
if
(
aEvent
.
capsLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_CAPSLOCK
;
}
if
(
aEvent
.
fnKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_FN
;
}
if
(
aEvent
.
fnLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_FNLOCK
;
}
if
(
aEvent
.
numLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_NUMLOCK
;
}
if
(
aEvent
.
scrollLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_SCROLLLOCK
;
}
if
(
aEvent
.
symbolKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_SYMBOL
;
}
if
(
aEvent
.
symbolLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_SYMBOLLOCK
;
}
if
(
aEvent
.
osKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_OS
;
}
return
mval
;
}
function
synthesizeMouse
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
return
synthesizeMouseAtPoint
(
rect
.
left
+
aOffsetX
rect
.
top
+
aOffsetY
aEvent
aWindow
)
;
}
function
synthesizeTouch
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
synthesizeTouchAtPoint
(
rect
.
left
+
aOffsetX
rect
.
top
+
aOffsetY
aEvent
aWindow
)
;
}
function
synthesizeMouseAtPoint
(
left
top
aEvent
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
var
defaultPrevented
=
false
;
if
(
utils
)
{
var
button
=
computeButton
(
aEvent
)
;
var
clickCount
=
aEvent
.
clickCount
|
|
1
;
var
modifiers
=
_parseModifiers
(
aEvent
aWindow
)
;
var
pressure
=
(
"
pressure
"
in
aEvent
)
?
aEvent
.
pressure
:
0
;
var
MouseEvent
=
_EU_maybeWrap
(
aWindow
)
.
MouseEvent
;
var
inputSource
=
(
"
inputSource
"
in
aEvent
)
?
aEvent
.
inputSource
:
MouseEvent
.
MOZ_SOURCE_MOUSE
;
var
id
;
if
(
"
id
"
in
aEvent
)
{
id
=
aEvent
.
id
;
}
else
{
var
isFromPen
=
inputSource
=
=
=
MouseEvent
.
MOZ_SOURCE_PEN
;
id
=
isFromPen
?
utils
.
DEFAULT_PEN_POINTER_ID
:
utils
.
DEFAULT_MOUSE_POINTER_ID
;
}
var
isDOMEventSynthesized
=
(
"
isSynthesized
"
in
aEvent
)
?
aEvent
.
isSynthesized
:
true
;
var
isWidgetEventSynthesized
=
(
"
isWidgetEventSynthesized
"
in
aEvent
)
?
aEvent
.
isWidgetEventSynthesized
:
false
;
var
buttons
=
(
"
buttons
"
in
aEvent
)
?
aEvent
.
buttons
:
utils
.
MOUSE_BUTTONS_NOT_SPECIFIED
;
if
(
(
"
type
"
in
aEvent
)
&
&
aEvent
.
type
)
{
defaultPrevented
=
utils
.
sendMouseEvent
(
aEvent
.
type
left
top
button
clickCount
modifiers
false
pressure
inputSource
isDOMEventSynthesized
isWidgetEventSynthesized
buttons
id
)
;
}
else
{
utils
.
sendMouseEvent
(
"
mousedown
"
left
top
button
clickCount
modifiers
false
pressure
inputSource
isDOMEventSynthesized
isWidgetEventSynthesized
buttons
id
)
;
utils
.
sendMouseEvent
(
"
mouseup
"
left
top
button
clickCount
modifiers
false
pressure
inputSource
isDOMEventSynthesized
isWidgetEventSynthesized
buttons
id
)
;
}
}
return
defaultPrevented
;
}
function
synthesizeTouchAtPoint
(
left
top
aEvent
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
utils
)
{
var
id
=
aEvent
.
id
|
|
utils
.
DEFAULT_TOUCH_POINTER_ID
;
var
rx
=
aEvent
.
rx
|
|
1
;
var
ry
=
aEvent
.
ry
|
|
1
;
var
angle
=
aEvent
.
angle
|
|
0
;
var
force
=
aEvent
.
force
|
|
1
;
var
modifiers
=
_parseModifiers
(
aEvent
aWindow
)
;
if
(
(
"
type
"
in
aEvent
)
&
&
aEvent
.
type
)
{
utils
.
sendTouchEvent
(
aEvent
.
type
[
id
]
[
left
]
[
top
]
[
rx
]
[
ry
]
[
angle
]
[
force
]
1
modifiers
)
;
}
else
{
utils
.
sendTouchEvent
(
"
touchstart
"
[
id
]
[
left
]
[
top
]
[
rx
]
[
ry
]
[
angle
]
[
force
]
1
modifiers
)
;
utils
.
sendTouchEvent
(
"
touchend
"
[
id
]
[
left
]
[
top
]
[
rx
]
[
ry
]
[
angle
]
[
force
]
1
modifiers
)
;
}
}
}
function
synthesizeMouseAtCenter
(
aTarget
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
return
synthesizeMouse
(
aTarget
rect
.
width
/
2
rect
.
height
/
2
aEvent
aWindow
)
;
}
function
synthesizeTouchAtCenter
(
aTarget
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
synthesizeTouch
(
aTarget
rect
.
width
/
2
rect
.
height
/
2
aEvent
aWindow
)
;
}
function
synthesizeWheelAtPoint
(
aLeft
aTop
aEvent
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
;
}
var
modifiers
=
_parseModifiers
(
aEvent
aWindow
)
;
var
options
=
0
;
if
(
aEvent
.
isNoLineOrPageDelta
)
{
options
|
=
utils
.
WHEEL_EVENT_CAUSED_BY_NO_LINE_OR_PAGE_DELTA_DEVICE
;
}
if
(
aEvent
.
isMomentum
)
{
options
|
=
utils
.
WHEEL_EVENT_CAUSED_BY_MOMENTUM
;
}
if
(
aEvent
.
isCustomizedByPrefs
)
{
options
|
=
utils
.
WHEEL_EVENT_CUSTOMIZED_BY_USER_PREFS
;
}
if
(
typeof
aEvent
.
expectedOverflowDeltaX
!
=
=
"
undefined
"
)
{
if
(
aEvent
.
expectedOverflowDeltaX
=
=
=
0
)
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_ZERO
;
}
else
if
(
aEvent
.
expectedOverflowDeltaX
>
0
)
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_POSITIVE
;
}
else
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_NEGATIVE
;
}
}
if
(
typeof
aEvent
.
expectedOverflowDeltaY
!
=
=
"
undefined
"
)
{
if
(
aEvent
.
expectedOverflowDeltaY
=
=
=
0
)
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_ZERO
;
}
else
if
(
aEvent
.
expectedOverflowDeltaY
>
0
)
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_POSITIVE
;
}
else
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_NEGATIVE
;
}
}
var
isNoLineOrPageDelta
=
aEvent
.
isNoLineOrPageDelta
;
if
(
!
aEvent
.
deltaX
)
{
aEvent
.
deltaX
=
0
;
}
if
(
!
aEvent
.
deltaY
)
{
aEvent
.
deltaY
=
0
;
}
if
(
!
aEvent
.
deltaZ
)
{
aEvent
.
deltaZ
=
0
;
}
var
lineOrPageDeltaX
=
aEvent
.
lineOrPageDeltaX
!
=
null
?
aEvent
.
lineOrPageDeltaX
:
aEvent
.
deltaX
>
0
?
Math
.
floor
(
aEvent
.
deltaX
)
:
Math
.
ceil
(
aEvent
.
deltaX
)
;
var
lineOrPageDeltaY
=
aEvent
.
lineOrPageDeltaY
!
=
null
?
aEvent
.
lineOrPageDeltaY
:
aEvent
.
deltaY
>
0
?
Math
.
floor
(
aEvent
.
deltaY
)
:
Math
.
ceil
(
aEvent
.
deltaY
)
;
utils
.
sendWheelEvent
(
aLeft
aTop
aEvent
.
deltaX
aEvent
.
deltaY
aEvent
.
deltaZ
aEvent
.
deltaMode
modifiers
lineOrPageDeltaX
lineOrPageDeltaY
options
)
;
}
function
synthesizeWheel
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
synthesizeWheelAtPoint
(
rect
.
left
+
aOffsetX
rect
.
top
+
aOffsetY
aEvent
aWindow
)
;
}
const
_FlushModes
=
{
FLUSH
:
0
NOFLUSH
:
1
}
;
function
_sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
aFlushMode
=
_FlushModes
.
FLUSH
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
return
;
if
(
utils
.
isMozAfterPaintPending
)
{
aWindow
.
waitForAllPaintsFlushed
(
function
(
)
{
_sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
aFlushMode
aWindow
)
;
}
)
;
return
;
}
var
onwheel
=
function
(
)
{
SpecialPowers
.
removeSystemEventListener
(
window
"
wheel
"
onwheel
)
;
setTimeout
(
function
(
)
{
utils
.
advanceTimeAndRefresh
(
1000
)
;
if
(
!
aCallback
)
{
utils
.
advanceTimeAndRefresh
(
0
)
;
return
;
}
var
waitForPaints
=
function
(
)
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
waitForPaints
"
apz
-
repaints
-
flushed
"
)
;
aWindow
.
waitForAllPaintsFlushed
(
function
(
)
{
utils
.
restoreNormalRefresh
(
)
;
aCallback
(
)
;
}
)
;
}
SpecialPowers
.
Services
.
obs
.
addObserver
(
waitForPaints
"
apz
-
repaints
-
flushed
"
)
;
if
(
!
utils
.
flushApzRepaints
(
aWindow
)
)
{
waitForPaints
(
)
;
}
}
0
)
;
}
;
SpecialPowers
.
addSystemEventListener
(
aWindow
"
wheel
"
onwheel
)
;
if
(
aFlushMode
=
=
=
_FlushModes
.
FLUSH
)
{
synthesizeWheel
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
;
}
else
{
synthesizeWheelAtPoint
(
aOffsetX
aOffsetY
aEvent
aWindow
)
;
}
}
function
sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
aWindow
=
window
)
{
_sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
_FlushModes
.
FLUSH
aWindow
)
;
}
function
sendWheelAndPaintNoFlush
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
aWindow
=
window
)
{
_sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
_FlushModes
.
NOFLUSH
aWindow
)
;
}
function
synthesizeNativeTapAtCenter
(
aTarget
aLongTap
=
false
aCallback
=
null
aWindow
=
window
)
{
let
rect
=
aTarget
.
getBoundingClientRect
(
)
;
return
synthesizeNativeTap
(
aTarget
rect
.
width
/
2
rect
.
height
/
2
aLongTap
aCallback
aWindow
)
;
}
function
synthesizeNativeTap
(
aTarget
aOffsetX
aOffsetY
aLongTap
=
false
aCallback
=
null
aWindow
=
window
)
{
let
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
return
;
let
scale
=
utils
.
screenPixelsPerCSSPixel
;
let
rect
=
aTarget
.
getBoundingClientRect
(
)
;
let
x
=
(
aWindow
.
mozInnerScreenX
+
rect
.
left
+
aOffsetX
)
*
scale
;
let
y
=
(
aWindow
.
mozInnerScreenY
+
rect
.
top
+
aOffsetY
)
*
scale
;
let
observer
=
{
observe
:
(
subject
topic
data
)
=
>
{
if
(
aCallback
&
&
topic
=
=
"
mouseevent
"
)
{
aCallback
(
data
)
;
}
}
}
;
utils
.
sendNativeTouchTap
(
x
y
aLongTap
observer
)
;
}
function
synthesizeNativeMouseMove
(
aTarget
aOffsetX
aOffsetY
aCallback
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
return
;
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
var
x
=
aOffsetX
+
window
.
mozInnerScreenX
+
rect
.
left
;
var
y
=
aOffsetY
+
window
.
mozInnerScreenY
+
rect
.
top
;
var
scale
=
utils
.
screenPixelsPerCSSPixel
;
var
observer
=
{
observe
:
(
subject
topic
data
)
=
>
{
if
(
aCallback
&
&
topic
=
=
"
mouseevent
"
)
{
aCallback
(
data
)
;
}
}
}
;
utils
.
sendNativeMouseMove
(
x
*
scale
y
*
scale
null
observer
)
;
}
function
synthesizeAndWaitNativeMouseMove
(
aTarget
aOffsetX
aOffsetY
aCallback
aWindow
=
window
)
{
let
browser
=
gBrowser
.
selectedTab
.
linkedBrowser
;
let
mm
=
browser
.
messageManager
;
let
ContentTask
=
_EU_Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTask
.
jsm
"
null
)
.
ContentTask
;
let
eventRegisteredPromise
=
new
Promise
(
resolve
=
>
{
mm
.
addMessageListener
(
"
Test
:
MouseMoveRegistered
"
function
processed
(
message
)
{
mm
.
removeMessageListener
(
"
Test
:
MouseMoveRegistered
"
processed
)
;
resolve
(
)
;
}
)
;
}
)
;
let
eventReceivedPromise
=
ContentTask
.
spawn
(
browser
[
aOffsetX
aOffsetY
]
(
[
clientX
clientY
]
)
=
>
{
return
new
Promise
(
resolve
=
>
{
addEventListener
(
"
mousemove
"
function
onMouseMoveEvent
(
e
)
{
if
(
e
.
clientX
=
=
clientX
&
&
e
.
clientY
=
=
clientY
)
{
removeEventListener
(
"
mousemove
"
onMouseMoveEvent
)
;
resolve
(
)
;
}
}
)
;
sendAsyncMessage
(
"
Test
:
MouseMoveRegistered
"
)
;
}
)
;
}
)
;
eventRegisteredPromise
.
then
(
(
)
=
>
{
synthesizeNativeMouseMove
(
aTarget
aOffsetX
aOffsetY
null
aWindow
)
;
}
)
;
return
eventReceivedPromise
;
}
function
_computeKeyCodeFromChar
(
aChar
)
{
if
(
aChar
.
length
!
=
1
)
{
return
0
;
}
var
KeyEvent
=
_getKeyboardEvent
(
)
;
if
(
aChar
>
=
'
a
'
&
&
aChar
<
=
'
z
'
)
{
return
KeyEvent
.
DOM_VK_A
+
aChar
.
charCodeAt
(
0
)
-
'
a
'
.
charCodeAt
(
0
)
;
}
if
(
aChar
>
=
'
A
'
&
&
aChar
<
=
'
Z
'
)
{
return
KeyEvent
.
DOM_VK_A
+
aChar
.
charCodeAt
(
0
)
-
'
A
'
.
charCodeAt
(
0
)
;
}
if
(
aChar
>
=
'
0
'
&
&
aChar
<
=
'
9
'
)
{
return
KeyEvent
.
DOM_VK_0
+
aChar
.
charCodeAt
(
0
)
-
'
0
'
.
charCodeAt
(
0
)
;
}
switch
(
aChar
)
{
case
'
~
'
:
case
'
'
:
return
KeyEvent
.
DOM_VK_BACK_QUOTE
;
case
'
!
'
:
return
KeyEvent
.
DOM_VK_1
;
case
'
'
:
return
KeyEvent
.
DOM_VK_2
;
case
'
#
'
:
return
KeyEvent
.
DOM_VK_3
;
case
'
'
:
return
KeyEvent
.
DOM_VK_4
;
case
'
%
'
:
return
KeyEvent
.
DOM_VK_5
;
case
'
^
'
:
return
KeyEvent
.
DOM_VK_6
;
case
'
&
'
:
return
KeyEvent
.
DOM_VK_7
;
case
'
*
'
:
return
KeyEvent
.
DOM_VK_8
;
case
'
(
'
:
return
KeyEvent
.
DOM_VK_9
;
case
'
)
'
:
return
KeyEvent
.
DOM_VK_0
;
case
'
-
'
:
case
'
_
'
:
return
KeyEvent
.
DOM_VK_SUBTRACT
;
case
'
+
'
:
case
'
=
'
:
return
KeyEvent
.
DOM_VK_EQUALS
;
case
'
{
'
:
case
'
[
'
:
return
KeyEvent
.
DOM_VK_OPEN_BRACKET
;
case
'
}
'
:
case
'
]
'
:
return
KeyEvent
.
DOM_VK_CLOSE_BRACKET
;
case
'
|
'
:
case
'
\
\
'
:
return
KeyEvent
.
DOM_VK_BACK_SLASH
;
case
'
:
'
:
case
'
;
'
:
return
KeyEvent
.
DOM_VK_SEMICOLON
;
case
'
\
'
'
:
case
'
"
'
:
return
KeyEvent
.
DOM_VK_QUOTE
;
case
'
<
'
:
case
'
'
:
return
KeyEvent
.
DOM_VK_COMMA
;
case
'
>
'
:
case
'
.
'
:
return
KeyEvent
.
DOM_VK_PERIOD
;
case
'
?
'
:
case
'
/
'
:
return
KeyEvent
.
DOM_VK_SLASH
;
case
'
\
n
'
:
return
KeyEvent
.
DOM_VK_RETURN
;
case
'
'
:
return
KeyEvent
.
DOM_VK_SPACE
;
default
:
return
0
;
}
}
function
synthesizeKey
(
aKey
aEvent
=
undefined
aWindow
=
window
aCallback
)
{
var
event
=
aEvent
=
=
=
undefined
|
|
aEvent
=
=
=
null
?
{
}
:
aEvent
;
var
TIP
=
_getTIP
(
aWindow
aCallback
)
;
if
(
!
TIP
)
{
return
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
var
modifiers
=
_emulateToActivateModifiers
(
TIP
event
aWindow
)
;
var
keyEventDict
=
_createKeyboardEventDictionary
(
aKey
event
aWindow
)
;
var
keyEvent
=
new
KeyboardEvent
(
"
"
keyEventDict
.
dictionary
)
;
var
dispatchKeydown
=
!
(
"
type
"
in
event
)
|
|
event
.
type
=
=
=
"
keydown
"
|
|
!
event
.
type
;
var
dispatchKeyup
=
!
(
"
type
"
in
event
)
|
|
event
.
type
=
=
=
"
keyup
"
|
|
!
event
.
type
;
try
{
if
(
dispatchKeydown
)
{
TIP
.
keydown
(
keyEvent
keyEventDict
.
flags
)
;
if
(
"
repeat
"
in
event
&
&
event
.
repeat
>
1
)
{
keyEventDict
.
dictionary
.
repeat
=
true
;
var
repeatedKeyEvent
=
new
KeyboardEvent
(
"
"
keyEventDict
.
dictionary
)
;
for
(
var
i
=
1
;
i
<
event
.
repeat
;
i
+
+
)
{
TIP
.
keydown
(
repeatedKeyEvent
keyEventDict
.
flags
)
;
}
}
}
if
(
dispatchKeyup
)
{
TIP
.
keyup
(
keyEvent
keyEventDict
.
flags
)
;
}
}
finally
{
_emulateToInactivateModifiers
(
TIP
modifiers
aWindow
)
;
}
}
function
synthesizeAndWaitKey
(
aKey
aEvent
aWindow
=
window
checkBeforeSynthesize
checkAfterSynthesize
)
{
let
browser
=
gBrowser
.
selectedTab
.
linkedBrowser
;
let
mm
=
browser
.
messageManager
;
let
keyCode
=
_createKeyboardEventDictionary
(
aKey
aEvent
aWindow
)
.
dictionary
.
keyCode
;
let
ContentTask
=
_EU_Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTask
.
jsm
"
null
)
.
ContentTask
;
let
keyRegisteredPromise
=
new
Promise
(
resolve
=
>
{
mm
.
addMessageListener
(
"
Test
:
KeyRegistered
"
function
processed
(
message
)
{
mm
.
removeMessageListener
(
"
Test
:
KeyRegistered
"
processed
)
;
resolve
(
)
;
}
)
;
}
)
;
let
keyReceivedPromise
=
ContentTask
.
spawn
(
browser
keyCode
(
keyCode
)
=
>
{
return
new
Promise
(
resolve
=
>
{
addEventListener
(
"
keyup
"
function
onKeyEvent
(
e
)
{
if
(
e
.
keyCode
=
=
keyCode
)
{
removeEventListener
(
"
keyup
"
onKeyEvent
)
;
resolve
(
)
;
}
}
)
;
sendAsyncMessage
(
"
Test
:
KeyRegistered
"
)
;
}
)
;
}
)
;
keyRegisteredPromise
.
then
(
(
)
=
>
{
if
(
checkBeforeSynthesize
)
{
checkBeforeSynthesize
(
)
;
}
synthesizeKey
(
aKey
aEvent
aWindow
)
;
if
(
checkAfterSynthesize
)
{
checkAfterSynthesize
(
)
;
}
}
)
;
return
keyReceivedPromise
;
}
function
_parseNativeModifiers
(
aModifiers
aWindow
=
window
)
{
var
navigator
=
_getNavigator
(
aWindow
)
;
var
modifiers
;
if
(
aModifiers
.
capsLockKey
)
{
modifiers
|
=
0x00000001
;
}
if
(
aModifiers
.
numLockKey
)
{
modifiers
|
=
0x00000002
;
}
if
(
aModifiers
.
shiftKey
)
{
modifiers
|
=
0x00000100
;
}
if
(
aModifiers
.
shiftRightKey
)
{
modifiers
|
=
0x00000200
;
}
if
(
aModifiers
.
ctrlKey
)
{
modifiers
|
=
0x00000400
;
}
if
(
aModifiers
.
ctrlRightKey
)
{
modifiers
|
=
0x00000800
;
}
if
(
aModifiers
.
altKey
)
{
modifiers
|
=
0x00001000
;
}
if
(
aModifiers
.
altRightKey
)
{
modifiers
|
=
0x00002000
;
}
if
(
aModifiers
.
metaKey
)
{
modifiers
|
=
0x00004000
;
}
if
(
aModifiers
.
metaRightKey
)
{
modifiers
|
=
0x00008000
;
}
if
(
aModifiers
.
helpKey
)
{
modifiers
|
=
0x00010000
;
}
if
(
aModifiers
.
fnKey
)
{
modifiers
|
=
0x00100000
;
}
if
(
aModifiers
.
numericKeyPadKey
)
{
modifiers
|
=
0x01000000
;
}
if
(
aModifiers
.
accelKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
0x00004000
:
0x00000400
;
}
if
(
aModifiers
.
accelRightKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
0x00008000
:
0x00000800
;
}
if
(
aModifiers
.
altGrKey
)
{
modifiers
|
=
_EU_isWin
(
aWindow
)
?
0x00020000
:
0x00001000
;
}
return
modifiers
;
}
const
KEYBOARD_LAYOUT_ARABIC
=
{
name
:
"
Arabic
"
Mac
:
6
Win
:
0x00000401
hasAltGrOnWin
:
false
}
;
const
KEYBOARD_LAYOUT_ARABIC_PC
=
{
name
:
"
Arabic
-
PC
"
Mac
:
7
Win
:
null
hasAltGrOnWin
:
false
}
;
const
KEYBOARD_LAYOUT_BRAZILIAN_ABNT
=
{
name
:
"
Brazilian
ABNT
"
Mac
:
null
Win
:
0x00000416
hasAltGrOnWin
:
true
}
;
const
KEYBOARD_LAYOUT_DVORAK_QWERTY
=
{
name
:
"
Dvorak
-
QWERTY
"
Mac
:
4
Win
:
null
hasAltGrOnWin
:
false
}
;
const
KEYBOARD_LAYOUT_EN_US
=
{
name
:
"
US
"
Mac
:
0
Win
:
0x00000409
hasAltGrOnWin
:
false
}
;
const
KEYBOARD_LAYOUT_FRENCH
=
{
name
:
"
French
"
Mac
:
8
Win
:
0x0000040C
hasAltGrOnWin
:
true
}
;
const
KEYBOARD_LAYOUT_GREEK
=
{
name
:
"
Greek
"
Mac
:
1
Win
:
0x00000408
hasAltGrOnWin
:
true
}
;
const
KEYBOARD_LAYOUT_GERMAN
=
{
name
:
"
German
"
Mac
:
2
Win
:
0x00000407
hasAltGrOnWin
:
true
}
;
const
KEYBOARD_LAYOUT_HEBREW
=
{
name
:
"
Hebrew
"
Mac
:
9
Win
:
0x0000040D
hasAltGrOnWin
:
true
}
;
const
KEYBOARD_LAYOUT_JAPANESE
=
{
name
:
"
Japanese
"
Mac
:
null
Win
:
0x00000411
hasAltGrOnWin
:
false
}
;
const
KEYBOARD_LAYOUT_KHMER
=
{
name
:
"
Khmer
"
Mac
:
null
Win
:
0x00000453
hasAltGrOnWin
:
true
}
;
const
KEYBOARD_LAYOUT_LITHUANIAN
=
{
name
:
"
Lithuanian
"
Mac
:
10
Win
:
0x00010427
hasAltGrOnWin
:
true
}
;
const
KEYBOARD_LAYOUT_NORWEGIAN
=
{
name
:
"
Norwegian
"
Mac
:
11
Win
:
0x00000414
hasAltGrOnWin
:
true
}
;
const
KEYBOARD_LAYOUT_RUSSIAN_MNEMONIC
=
{
name
:
"
Russian
-
Mnemonic
"
Mac
:
null
Win
:
0x00020419
hasAltGrOnWin
:
true
}
;
const
KEYBOARD_LAYOUT_SPANISH
=
{
name
:
"
Spanish
"
Mac
:
12
Win
:
0x0000040A
hasAltGrOnWin
:
true
}
;
const
KEYBOARD_LAYOUT_SWEDISH
=
{
name
:
"
Swedish
"
Mac
:
3
Win
:
0x0000041D
hasAltGrOnWin
:
true
}
;
const
KEYBOARD_LAYOUT_THAI
=
{
name
:
"
Thai
"
Mac
:
5
Win
:
0x0002041E
hasAltGrOnWin
:
false
}
;
function
synthesizeNativeKey
(
aKeyboardLayout
aNativeKeyCode
aModifiers
aChars
aUnmodifiedChars
aCallback
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
false
;
}
var
navigator
=
_getNavigator
(
aWindow
)
;
var
nativeKeyboardLayout
=
null
;
if
(
_EU_isMac
(
aWindow
)
)
{
nativeKeyboardLayout
=
aKeyboardLayout
.
Mac
;
}
else
if
(
_EU_isWin
(
aWindow
)
)
{
nativeKeyboardLayout
=
aKeyboardLayout
.
Win
;
}
if
(
nativeKeyboardLayout
=
=
=
null
)
{
return
false
;
}
var
observer
=
{
observe
:
function
(
aSubject
aTopic
aData
)
{
if
(
aCallback
&
&
aTopic
=
=
"
keyevent
"
)
{
aCallback
(
aData
)
;
}
}
}
;
utils
.
sendNativeKeyEvent
(
nativeKeyboardLayout
aNativeKeyCode
_parseNativeModifiers
(
aModifiers
aWindow
)
aChars
aUnmodifiedChars
observer
)
;
return
true
;
}
var
_gSeenEvent
=
false
;
function
_expectEvent
(
aExpectedTarget
aExpectedEvent
aTestName
)
{
if
(
!
aExpectedTarget
|
|
!
aExpectedEvent
)
return
null
;
_gSeenEvent
=
false
;
var
type
=
(
aExpectedEvent
.
charAt
(
0
)
=
=
"
!
"
)
?
aExpectedEvent
.
substring
(
1
)
:
aExpectedEvent
;
var
eventHandler
=
function
(
event
)
{
var
epassed
=
(
!
_gSeenEvent
&
&
event
.
originalTarget
=
=
aExpectedTarget
&
&
event
.
type
=
=
type
)
;
is
(
epassed
true
aTestName
+
"
"
+
type
+
"
event
target
"
+
(
_gSeenEvent
?
"
twice
"
:
"
"
)
)
;
_gSeenEvent
=
true
;
}
;
aExpectedTarget
.
addEventListener
(
type
eventHandler
)
;
return
eventHandler
;
}
function
_checkExpectedEvent
(
aExpectedTarget
aExpectedEvent
aEventHandler
aTestName
)
{
if
(
aEventHandler
)
{
var
expectEvent
=
(
aExpectedEvent
.
charAt
(
0
)
!
=
"
!
"
)
;
var
type
=
expectEvent
?
aExpectedEvent
:
aExpectedEvent
.
substring
(
1
)
;
aExpectedTarget
.
removeEventListener
(
type
aEventHandler
)
;
var
desc
=
type
+
"
event
"
;
if
(
!
expectEvent
)
desc
+
=
"
not
"
;
is
(
_gSeenEvent
expectEvent
aTestName
+
"
"
+
desc
+
"
fired
"
)
;
}
_gSeenEvent
=
false
;
}
function
synthesizeMouseExpectEvent
(
aTarget
aOffsetX
aOffsetY
aEvent
aExpectedTarget
aExpectedEvent
aTestName
aWindow
)
{
var
eventHandler
=
_expectEvent
(
aExpectedTarget
aExpectedEvent
aTestName
)
;
synthesizeMouse
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
;
_checkExpectedEvent
(
aExpectedTarget
aExpectedEvent
eventHandler
aTestName
)
;
}
function
synthesizeKeyExpectEvent
(
key
aEvent
aExpectedTarget
aExpectedEvent
aTestName
aWindow
)
{
var
eventHandler
=
_expectEvent
(
aExpectedTarget
aExpectedEvent
aTestName
)
;
synthesizeKey
(
key
aEvent
aWindow
)
;
_checkExpectedEvent
(
aExpectedTarget
aExpectedEvent
eventHandler
aTestName
)
;
}
function
disableNonTestMouseEvents
(
aDisable
)
{
var
domutils
=
_getDOMWindowUtils
(
)
;
domutils
.
disableNonTestMouseEvents
(
aDisable
)
;
}
function
_getDOMWindowUtils
(
aWindow
=
window
)
{
if
(
!
aWindow
)
{
aWindow
=
window
;
}
if
(
!
window
.
document
|
|
window
.
document
.
documentURIObject
)
{
return
aWindow
.
windowUtils
;
}
if
(
"
SpecialPowers
"
in
window
&
&
window
.
SpecialPowers
!
=
undefined
)
{
return
SpecialPowers
.
getDOMWindowUtils
(
aWindow
)
;
}
if
(
"
SpecialPowers
"
in
parent
&
&
parent
.
SpecialPowers
!
=
undefined
)
{
return
parent
.
SpecialPowers
.
getDOMWindowUtils
(
aWindow
)
;
}
return
aWindow
.
windowUtils
;
}
function
_defineConstant
(
name
value
)
{
Object
.
defineProperty
(
this
name
{
value
:
value
enumerable
:
true
writable
:
false
}
)
;
}
const
COMPOSITION_ATTR_RAW_CLAUSE
=
_EU_Ci
.
nsITextInputProcessor
.
ATTR_RAW_CLAUSE
;
_defineConstant
(
"
COMPOSITION_ATTR_RAW_CLAUSE
"
COMPOSITION_ATTR_RAW_CLAUSE
)
;
const
COMPOSITION_ATTR_SELECTED_RAW_CLAUSE
=
_EU_Ci
.
nsITextInputProcessor
.
ATTR_SELECTED_RAW_CLAUSE
;
_defineConstant
(
"
COMPOSITION_ATTR_SELECTED_RAW_CLAUSE
"
COMPOSITION_ATTR_SELECTED_RAW_CLAUSE
)
;
const
COMPOSITION_ATTR_CONVERTED_CLAUSE
=
_EU_Ci
.
nsITextInputProcessor
.
ATTR_CONVERTED_CLAUSE
;
_defineConstant
(
"
COMPOSITION_ATTR_CONVERTED_CLAUSE
"
COMPOSITION_ATTR_CONVERTED_CLAUSE
)
;
const
COMPOSITION_ATTR_SELECTED_CLAUSE
=
_EU_Ci
.
nsITextInputProcessor
.
ATTR_SELECTED_CLAUSE
;
_defineConstant
(
"
COMPOSITION_ATTR_SELECTED_CLAUSE
"
COMPOSITION_ATTR_SELECTED_CLAUSE
)
;
var
TIPMap
=
new
WeakMap
(
)
;
function
_getTIP
(
aWindow
aCallback
)
{
if
(
!
aWindow
)
{
aWindow
=
window
;
}
var
tip
;
if
(
TIPMap
.
has
(
aWindow
)
)
{
tip
=
TIPMap
.
get
(
aWindow
)
;
}
else
{
tip
=
_EU_Cc
[
"
mozilla
.
org
/
text
-
input
-
processor
;
1
"
]
.
createInstance
(
_EU_Ci
.
nsITextInputProcessor
)
;
TIPMap
.
set
(
aWindow
tip
)
;
}
if
(
!
tip
.
beginInputTransactionForTests
(
aWindow
aCallback
)
)
{
tip
=
null
;
TIPMap
.
delete
(
aWindow
)
;
}
return
tip
;
}
function
_getKeyboardEvent
(
aWindow
=
window
)
{
if
(
typeof
KeyboardEvent
!
=
"
undefined
"
)
{
try
{
new
KeyboardEvent
(
"
"
{
}
)
;
return
KeyboardEvent
;
}
catch
(
ex
)
{
}
}
if
(
typeof
content
!
=
"
undefined
"
&
&
(
"
KeyboardEvent
"
in
content
)
)
{
return
content
.
KeyboardEvent
;
}
return
aWindow
.
KeyboardEvent
;
}
function
_getNavigator
(
aWindow
=
window
)
{
if
(
typeof
navigator
!
=
"
undefined
"
)
{
return
navigator
;
}
return
aWindow
.
navigator
;
}
function
_guessKeyNameFromKeyCode
(
aKeyCode
aWindow
=
window
)
{
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
switch
(
aKeyCode
)
{
case
KeyboardEvent
.
DOM_VK_CANCEL
:
return
"
Cancel
"
;
case
KeyboardEvent
.
DOM_VK_HELP
:
return
"
Help
"
;
case
KeyboardEvent
.
DOM_VK_BACK_SPACE
:
return
"
Backspace
"
;
case
KeyboardEvent
.
DOM_VK_TAB
:
return
"
Tab
"
;
case
KeyboardEvent
.
DOM_VK_CLEAR
:
return
"
Clear
"
;
case
KeyboardEvent
.
DOM_VK_RETURN
:
return
"
Enter
"
;
case
KeyboardEvent
.
DOM_VK_SHIFT
:
return
"
Shift
"
;
case
KeyboardEvent
.
DOM_VK_CONTROL
:
return
"
Control
"
;
case
KeyboardEvent
.
DOM_VK_ALT
:
return
"
Alt
"
;
case
KeyboardEvent
.
DOM_VK_PAUSE
:
return
"
Pause
"
;
case
KeyboardEvent
.
DOM_VK_EISU
:
return
"
Eisu
"
;
case
KeyboardEvent
.
DOM_VK_ESCAPE
:
return
"
Escape
"
;
case
KeyboardEvent
.
DOM_VK_CONVERT
:
return
"
Convert
"
;
case
KeyboardEvent
.
DOM_VK_NONCONVERT
:
return
"
NonConvert
"
;
case
KeyboardEvent
.
DOM_VK_ACCEPT
:
return
"
Accept
"
;
case
KeyboardEvent
.
DOM_VK_MODECHANGE
:
return
"
ModeChange
"
;
case
KeyboardEvent
.
DOM_VK_PAGE_UP
:
return
"
PageUp
"
;
case
KeyboardEvent
.
DOM_VK_PAGE_DOWN
:
return
"
PageDown
"
;
case
KeyboardEvent
.
DOM_VK_END
:
return
"
End
"
;
case
KeyboardEvent
.
DOM_VK_HOME
:
return
"
Home
"
;
case
KeyboardEvent
.
DOM_VK_LEFT
:
return
"
ArrowLeft
"
;
case
KeyboardEvent
.
DOM_VK_UP
:
return
"
ArrowUp
"
;
case
KeyboardEvent
.
DOM_VK_RIGHT
:
return
"
ArrowRight
"
;
case
KeyboardEvent
.
DOM_VK_DOWN
:
return
"
ArrowDown
"
;
case
KeyboardEvent
.
DOM_VK_SELECT
:
return
"
Select
"
;
case
KeyboardEvent
.
DOM_VK_PRINT
:
return
"
Print
"
;
case
KeyboardEvent
.
DOM_VK_EXECUTE
:
return
"
Execute
"
;
case
KeyboardEvent
.
DOM_VK_PRINTSCREEN
:
return
"
PrintScreen
"
;
case
KeyboardEvent
.
DOM_VK_INSERT
:
return
"
Insert
"
;
case
KeyboardEvent
.
DOM_VK_DELETE
:
return
"
Delete
"
;
case
KeyboardEvent
.
DOM_VK_WIN
:
return
"
OS
"
;
case
KeyboardEvent
.
DOM_VK_CONTEXT_MENU
:
return
"
ContextMenu
"
;
case
KeyboardEvent
.
DOM_VK_SLEEP
:
return
"
Standby
"
;
case
KeyboardEvent
.
DOM_VK_F1
:
return
"
F1
"
;
case
KeyboardEvent
.
DOM_VK_F2
:
return
"
F2
"
;
case
KeyboardEvent
.
DOM_VK_F3
:
return
"
F3
"
;
case
KeyboardEvent
.
DOM_VK_F4
:
return
"
F4
"
;
case
KeyboardEvent
.
DOM_VK_F5
:
return
"
F5
"
;
case
KeyboardEvent
.
DOM_VK_F6
:
return
"
F6
"
;
case
KeyboardEvent
.
DOM_VK_F7
:
return
"
F7
"
;
case
KeyboardEvent
.
DOM_VK_F8
:
return
"
F8
"
;
case
KeyboardEvent
.
DOM_VK_F9
:
return
"
F9
"
;
case
KeyboardEvent
.
DOM_VK_F10
:
return
"
F10
"
;
case
KeyboardEvent
.
DOM_VK_F11
:
return
"
F11
"
;
case
KeyboardEvent
.
DOM_VK_F12
:
return
"
F12
"
;
case
KeyboardEvent
.
DOM_VK_F13
:
return
"
F13
"
;
case
KeyboardEvent
.
DOM_VK_F14
:
return
"
F14
"
;
case
KeyboardEvent
.
DOM_VK_F15
:
return
"
F15
"
;
case
KeyboardEvent
.
DOM_VK_F16
:
return
"
F16
"
;
case
KeyboardEvent
.
DOM_VK_F17
:
return
"
F17
"
;
case
KeyboardEvent
.
DOM_VK_F18
:
return
"
F18
"
;
case
KeyboardEvent
.
DOM_VK_F19
:
return
"
F19
"
;
case
KeyboardEvent
.
DOM_VK_F20
:
return
"
F20
"
;
case
KeyboardEvent
.
DOM_VK_F21
:
return
"
F21
"
;
case
KeyboardEvent
.
DOM_VK_F22
:
return
"
F22
"
;
case
KeyboardEvent
.
DOM_VK_F23
:
return
"
F23
"
;
case
KeyboardEvent
.
DOM_VK_F24
:
return
"
F24
"
;
case
KeyboardEvent
.
DOM_VK_NUM_LOCK
:
return
"
NumLock
"
;
case
KeyboardEvent
.
DOM_VK_SCROLL_LOCK
:
return
"
ScrollLock
"
;
case
KeyboardEvent
.
DOM_VK_VOLUME_MUTE
:
return
"
AudioVolumeMute
"
;
case
KeyboardEvent
.
DOM_VK_VOLUME_DOWN
:
return
"
AudioVolumeDown
"
;
case
KeyboardEvent
.
DOM_VK_VOLUME_UP
:
return
"
AudioVolumeUp
"
;
case
KeyboardEvent
.
DOM_VK_META
:
return
"
Meta
"
;
case
KeyboardEvent
.
DOM_VK_ALTGR
:
return
"
AltGraph
"
;
case
KeyboardEvent
.
DOM_VK_PROCESSKEY
:
return
"
Process
"
;
case
KeyboardEvent
.
DOM_VK_ATTN
:
return
"
Attn
"
;
case
KeyboardEvent
.
DOM_VK_CRSEL
:
return
"
CrSel
"
;
case
KeyboardEvent
.
DOM_VK_EXSEL
:
return
"
ExSel
"
;
case
KeyboardEvent
.
DOM_VK_EREOF
:
return
"
EraseEof
"
;
case
KeyboardEvent
.
DOM_VK_PLAY
:
return
"
Play
"
;
default
:
return
"
Unidentified
"
;
}
}
function
_guessCodeFromKeyName
(
aKeyName
aLocation
aWindow
=
window
)
{
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
if
(
aLocation
=
=
=
KeyboardEvent
.
DOM_KEY_LOCATION_NUMPAD
)
{
switch
(
aKeyName
)
{
case
"
Insert
"
:
return
_EU_isMac
(
aWindow
)
?
"
"
:
"
Numpad0
"
;
case
"
End
"
:
return
_EU_isMac
(
aWindow
)
?
"
"
:
"
Numpad1
"
;
case
"
ArrowDown
"
:
return
_EU_isMac
(
aWindow
)
?
"
"
:
"
Numpad2
"
;
case
"
PageDown
"
:
return
_EU_isMac
(
aWindow
)
?
"
"
:
"
Numpad3
"
;
case
"
ArrowLeft
"
:
return
_EU_isMac
(
aWindow
)
?
"
"
:
"
Numpad4
"
;
case
"
Clear
"
:
return
!
_EU_isWin
(
aWindow
)
?
"
"
:
"
Numpad5
"
;
case
"
ArrowRight
"
:
return
_EU_isMac
(
aWindow
)
?
"
"
:
"
Numpad6
"
;
case
"
Home
"
:
return
_EU_isMac
(
aWindow
)
?
"
"
:
"
Numpad7
"
;
case
"
ArrowUp
"
:
return
_EU_isMac
(
aWindow
)
?
"
"
:
"
Numpad8
"
;
case
"
PageUp
"
:
return
_EU_isMac
(
aWindow
)
?
"
"
:
"
Numpad9
"
;
case
"
Delete
"
:
return
_EU_isMac
(
aWindow
)
?
"
"
:
"
NumpadDecimal
"
;
case
"
Enter
"
:
return
"
NumpadEnter
"
;
case
"
=
"
:
return
"
NumpadEqual
"
;
case
"
+
"
:
return
"
NumpadAdd
"
;
case
"
-
"
:
return
"
NumpadSubtract
"
;
case
"
*
"
:
return
"
NumpadMultiply
"
;
case
"
/
"
:
return
"
NumpadDivide
"
;
case
"
0
"
:
case
"
1
"
:
case
"
2
"
:
case
"
3
"
:
case
"
4
"
:
case
"
5
"
:
case
"
6
"
:
case
"
7
"
:
case
"
8
"
:
case
"
9
"
:
return
"
Numpad
"
+
aKeyName
;
default
:
return
"
"
;
}
}
if
(
aLocation
=
=
=
undefined
|
|
aLocation
=
=
=
KeyboardEvent
.
DOM_KEY_LOCATION_LEFT
|
|
aLocation
=
=
=
KeyboardEvent
.
DOM_KEY_LOCATION_RIGHT
)
{
function
getLeftOrRightCode
(
aKey
)
{
if
(
aLocation
=
=
=
undefined
)
{
return
aKey
+
"
Left
"
;
}
if
(
aLocation
=
=
=
KeyboardEvent
.
DOM_KEY_LOCATION_LEFT
)
{
return
aKey
+
"
Left
"
;
}
if
(
aLocation
=
=
=
KeyboardEvent
.
DOM_KEY_LOCATION_RIGHT
)
{
return
aKey
+
"
Right
"
;
}
return
"
"
;
}
switch
(
aKeyName
)
{
case
"
Alt
"
:
case
"
Control
"
:
case
"
Shift
"
:
return
getLeftOrRightCode
(
aKeyName
)
;
case
"
Meta
"
:
if
(
_EU_isWin
(
aWindow
)
)
{
return
"
"
;
}
if
(
_EU_isAndroid
(
aWindow
)
|
|
_EU_isMac
(
aWindow
)
)
{
return
getLeftOrRightCode
(
"
OS
"
)
;
}
return
getLeftOrRightCode
(
"
Alt
"
)
;
case
"
OS
"
:
if
(
_EU_isAndroid
(
aWindow
)
|
|
_EU_isMac
(
aWindow
)
)
{
return
"
"
;
}
return
getLeftOrRightCode
(
"
OS
"
)
;
}
}
if
(
aLocation
=
=
=
undefined
|
|
aLocation
=
=
=
0
)
{
switch
(
aKeyName
)
{
case
"
ArrowDown
"
:
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
case
"
ArrowUp
"
:
case
"
Backspace
"
:
case
"
CapsLock
"
:
case
"
ContextMenu
"
:
case
"
Delete
"
:
case
"
End
"
:
case
"
Enter
"
:
case
"
Escape
"
:
case
"
F1
"
:
case
"
F2
"
:
case
"
F3
"
:
case
"
F4
"
:
case
"
F5
"
:
case
"
F6
"
:
case
"
F7
"
:
case
"
F8
"
:
case
"
F9
"
:
case
"
F10
"
:
case
"
F11
"
:
case
"
F12
"
:
case
"
F13
"
:
case
"
F14
"
:
case
"
F15
"
:
case
"
F16
"
:
case
"
F17
"
:
case
"
F18
"
:
case
"
F19
"
:
case
"
F20
"
:
case
"
Home
"
:
case
"
PageDown
"
:
case
"
PageUp
"
:
case
"
Tab
"
:
return
aKeyName
;
case
"
BrowserBack
"
:
case
"
BrowserFavorites
"
:
case
"
BrowserForward
"
:
case
"
BrowserRefresh
"
:
case
"
BrowserSearch
"
:
case
"
BrowserStop
"
:
case
"
F21
"
:
case
"
F22
"
:
case
"
F23
"
:
case
"
F24
"
:
case
"
Insert
"
:
case
"
MediaPlayPause
"
:
case
"
MediaStop
"
:
case
"
MediaTrackNext
"
:
case
"
MediaTrackPrevious
"
:
case
"
Pause
"
:
case
"
PrintScreen
"
:
case
"
ScrollLock
"
:
return
_EU_isMac
(
aWindow
)
?
"
"
:
aKeyName
;
case
"
Clear
"
:
case
"
Fn
"
:
return
_EU_isMac
(
aWindow
)
?
aKeyName
:
"
"
;
case
"
Help
"
:
return
_EU_isMac
(
aWindow
)
?
"
"
:
aKeyName
;
case
"
BrowserHome
"
:
return
_EU_isWin
(
aWindow
)
|
|
_EU_isLinux
(
aWindow
)
?
aKeyName
:
"
"
;
case
"
Eject
"
:
case
"
WakeUp
"
:
return
_EU_isLinux
(
aWindow
)
|
|
_EU_isAndroid
(
aWindow
)
?
aKeyName
:
"
"
;
case
"
Break
"
:
return
!
_EU_isMac
(
aWindow
)
?
"
Pause
"
:
"
"
;
case
"
AudioVolumeDown
"
:
case
"
AudioVolumeMute
"
:
case
"
AudioVolumeUp
"
:
return
aKeyName
.
substr
(
"
Audio
"
.
length
)
;
case
"
LaunchApplication1
"
:
return
!
_EU_isMac
(
aWindow
)
?
"
LaunchApp1
"
:
"
"
;
case
"
LaunchApplication2
"
:
return
_EU_isWin
(
aWindow
)
|
|
_EU_isLinux
(
aWindow
)
?
"
LaunchApp2
"
:
"
"
;
default
:
if
(
aKeyName
.
length
!
=
1
)
{
return
"
"
;
}
if
(
aKeyName
.
charCodeAt
(
0
)
>
=
"
A
"
.
charCodeAt
(
0
)
&
&
aKeyName
.
charCodeAt
(
0
)
<
=
"
Z
"
.
charCodeAt
(
0
)
)
{
return
"
Key
"
+
aKeyName
;
}
if
(
aKeyName
.
charCodeAt
(
0
)
>
=
"
a
"
.
charCodeAt
(
0
)
&
&
aKeyName
.
charCodeAt
(
0
)
<
=
"
z
"
.
charCodeAt
(
0
)
)
{
return
"
Key
"
+
aKeyName
.
toUpperCase
(
)
;
}
if
(
aKeyName
.
charCodeAt
(
0
)
>
=
"
0
"
.
charCodeAt
(
0
)
&
&
aKeyName
.
charCodeAt
(
0
)
<
=
"
9
"
.
charCodeAt
(
0
)
)
{
return
"
Digit
"
+
aKeyName
;
}
switch
(
aKeyName
)
{
case
"
"
:
return
"
Space
"
;
case
"
"
:
case
"
~
"
:
return
"
Backquote
"
;
case
"
\
\
"
:
case
"
|
"
:
return
"
Backslash
"
;
case
"
[
"
:
case
"
{
"
:
return
"
BracketLeft
"
;
case
"
]
"
:
case
"
}
"
:
return
"
BracketRight
"
;
case
"
"
:
case
"
<
"
:
return
"
Comma
"
;
case
"
)
"
:
return
"
Digit0
"
;
case
"
!
"
:
return
"
Digit1
"
;
case
"
"
:
return
"
Digit2
"
;
case
"
#
"
:
return
"
Digit3
"
;
case
"
"
:
return
"
Digit4
"
;
case
"
%
"
:
return
"
Digit5
"
;
case
"
^
"
:
return
"
Digit6
"
;
case
"
&
"
:
return
"
Digit7
"
;
case
"
*
"
:
return
"
Digit8
"
;
case
"
(
"
:
return
"
Digit9
"
;
case
"
=
"
:
case
"
+
"
:
return
"
Equal
"
;
case
"
-
"
:
case
"
_
"
:
return
"
Minus
"
;
case
"
.
"
:
case
"
>
"
:
return
"
Period
"
;
case
"
'
"
:
case
"
\
"
"
:
return
"
Quote
"
;
case
"
;
"
:
case
"
:
"
:
return
"
Semicolon
"
;
case
"
/
"
:
case
"
?
"
:
return
"
Slash
"
;
default
:
return
"
"
;
}
}
}
return
"
"
;
}
function
_createKeyboardEventDictionary
(
aKey
aKeyEvent
aWindow
=
window
)
{
var
result
=
{
dictionary
:
null
flags
:
0
}
;
var
keyCodeIsDefined
=
"
keyCode
"
in
aKeyEvent
;
var
keyCode
=
(
keyCodeIsDefined
&
&
aKeyEvent
.
keyCode
>
=
0
&
&
aKeyEvent
.
keyCode
<
=
255
)
?
aKeyEvent
.
keyCode
:
0
;
var
keyName
=
"
Unidentified
"
;
if
(
aKey
.
indexOf
(
"
KEY_
"
)
=
=
0
)
{
keyName
=
aKey
.
substr
(
"
KEY_
"
.
length
)
;
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_NON_PRINTABLE_KEY
;
}
else
if
(
aKey
.
indexOf
(
"
VK_
"
)
=
=
0
)
{
keyCode
=
_getKeyboardEvent
(
aWindow
)
[
"
DOM_
"
+
aKey
]
;
if
(
!
keyCode
)
{
throw
"
Unknown
key
:
"
+
aKey
;
}
keyName
=
_guessKeyNameFromKeyCode
(
keyCode
aWindow
)
;
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_NON_PRINTABLE_KEY
;
}
else
if
(
aKey
!
=
"
"
)
{
keyName
=
aKey
;
if
(
!
keyCodeIsDefined
)
{
keyCode
=
_computeKeyCodeFromChar
(
aKey
.
charAt
(
0
)
)
;
}
if
(
!
keyCode
)
{
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_KEEP_KEYCODE_ZERO
;
}
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_FORCE_PRINTABLE_KEY
;
}
var
code
=
"
code
"
in
aKeyEvent
?
aKeyEvent
.
code
:
_guessCodeFromKeyName
(
keyName
aKeyEvent
.
location
aWindow
)
;
var
locationIsDefined
=
"
location
"
in
aKeyEvent
;
if
(
locationIsDefined
&
&
aKeyEvent
.
location
=
=
=
0
)
{
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_KEEP_KEY_LOCATION_STANDARD
;
}
if
(
aKeyEvent
.
doNotMarkKeydownAsProcessed
)
{
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_DONT_MARK_KEYDOWN_AS_PROCESSED
;
}
if
(
aKeyEvent
.
markKeyupAsProcessed
)
{
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_MARK_KEYUP_AS_PROCESSED
;
}
result
.
dictionary
=
{
key
:
keyName
code
:
code
location
:
locationIsDefined
?
aKeyEvent
.
location
:
0
repeat
:
"
repeat
"
in
aKeyEvent
?
aKeyEvent
.
repeat
=
=
=
true
:
false
keyCode
:
keyCode
}
;
return
result
;
}
function
_emulateToActivateModifiers
(
aTIP
aKeyEvent
aWindow
=
window
)
{
if
(
!
aKeyEvent
)
{
return
null
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
var
navigator
=
_getNavigator
(
aWindow
)
;
var
modifiers
=
{
normal
:
[
{
key
:
"
Alt
"
attr
:
"
altKey
"
}
{
key
:
"
AltGraph
"
attr
:
"
altGraphKey
"
}
{
key
:
"
Control
"
attr
:
"
ctrlKey
"
}
{
key
:
"
Fn
"
attr
:
"
fnKey
"
}
{
key
:
"
Meta
"
attr
:
"
metaKey
"
}
{
key
:
"
OS
"
attr
:
"
osKey
"
}
{
key
:
"
Shift
"
attr
:
"
shiftKey
"
}
{
key
:
"
Symbol
"
attr
:
"
symbolKey
"
}
{
key
:
_EU_isMac
(
aWindow
)
?
"
Meta
"
:
"
Control
"
attr
:
"
accelKey
"
}
]
lockable
:
[
{
key
:
"
CapsLock
"
attr
:
"
capsLockKey
"
}
{
key
:
"
FnLock
"
attr
:
"
fnLockKey
"
}
{
key
:
"
NumLock
"
attr
:
"
numLockKey
"
}
{
key
:
"
ScrollLock
"
attr
:
"
scrollLockKey
"
}
{
key
:
"
SymbolLock
"
attr
:
"
symbolLockKey
"
}
]
}
for
(
var
i
=
0
;
i
<
modifiers
.
normal
.
length
;
i
+
+
)
{
if
(
!
aKeyEvent
[
modifiers
.
normal
[
i
]
.
attr
]
)
{
continue
;
}
if
(
aTIP
.
getModifierState
(
modifiers
.
normal
[
i
]
.
key
)
)
{
continue
;
}
var
event
=
new
KeyboardEvent
(
"
"
{
key
:
modifiers
.
normal
[
i
]
.
key
}
)
;
aTIP
.
keydown
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
modifiers
.
normal
[
i
]
.
activated
=
true
;
}
for
(
var
i
=
0
;
i
<
modifiers
.
lockable
.
length
;
i
+
+
)
{
if
(
!
aKeyEvent
[
modifiers
.
lockable
[
i
]
.
attr
]
)
{
continue
;
}
if
(
aTIP
.
getModifierState
(
modifiers
.
lockable
[
i
]
.
key
)
)
{
continue
;
}
var
event
=
new
KeyboardEvent
(
"
"
{
key
:
modifiers
.
lockable
[
i
]
.
key
}
)
;
aTIP
.
keydown
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
aTIP
.
keyup
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
modifiers
.
lockable
[
i
]
.
activated
=
true
;
}
return
modifiers
;
}
function
_emulateToInactivateModifiers
(
aTIP
aModifiers
aWindow
=
window
)
{
if
(
!
aModifiers
)
{
return
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
for
(
var
i
=
0
;
i
<
aModifiers
.
normal
.
length
;
i
+
+
)
{
if
(
!
aModifiers
.
normal
[
i
]
.
activated
)
{
continue
;
}
var
event
=
new
KeyboardEvent
(
"
"
{
key
:
aModifiers
.
normal
[
i
]
.
key
}
)
;
aTIP
.
keyup
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
}
for
(
var
i
=
0
;
i
<
aModifiers
.
lockable
.
length
;
i
+
+
)
{
if
(
!
aModifiers
.
lockable
[
i
]
.
activated
)
{
continue
;
}
if
(
!
aTIP
.
getModifierState
(
aModifiers
.
lockable
[
i
]
.
key
)
)
{
continue
;
}
var
event
=
new
KeyboardEvent
(
"
"
{
key
:
aModifiers
.
lockable
[
i
]
.
key
}
)
;
aTIP
.
keydown
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
aTIP
.
keyup
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
}
}
function
synthesizeComposition
(
aEvent
aWindow
=
window
aCallback
)
{
var
TIP
=
_getTIP
(
aWindow
aCallback
)
;
if
(
!
TIP
)
{
return
false
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
var
modifiers
=
_emulateToActivateModifiers
(
TIP
aEvent
.
key
aWindow
)
;
var
ret
=
false
;
var
keyEventDict
=
{
dictionary
:
null
flags
:
0
}
;
var
keyEvent
=
null
;
if
(
aEvent
.
key
&
&
typeof
aEvent
.
key
.
key
=
=
=
"
string
"
)
{
keyEventDict
=
_createKeyboardEventDictionary
(
aEvent
.
key
.
key
aEvent
.
key
aWindow
)
;
keyEvent
=
new
KeyboardEvent
(
aEvent
.
key
.
type
=
=
=
"
keydown
"
?
"
keydown
"
:
aEvent
.
key
.
type
=
=
=
"
keyup
"
?
"
keyup
"
:
"
"
keyEventDict
.
dictionary
)
}
else
if
(
aEvent
.
key
=
=
=
undefined
)
{
keyEventDict
=
_createKeyboardEventDictionary
(
"
KEY_Process
"
{
}
aWindow
)
;
keyEvent
=
new
KeyboardEvent
(
"
"
keyEventDict
.
dictionary
)
}
try
{
switch
(
aEvent
.
type
)
{
case
"
compositionstart
"
:
ret
=
TIP
.
startComposition
(
keyEvent
keyEventDict
.
flags
)
;
break
;
case
"
compositioncommitasis
"
:
ret
=
TIP
.
commitComposition
(
keyEvent
keyEventDict
.
flags
)
;
break
;
case
"
compositioncommit
"
:
ret
=
TIP
.
commitCompositionWith
(
aEvent
.
data
keyEvent
keyEventDict
.
flags
)
;
break
;
}
}
finally
{
_emulateToInactivateModifiers
(
TIP
modifiers
aWindow
)
;
}
}
function
synthesizeCompositionChange
(
aEvent
aWindow
=
window
aCallback
)
{
var
TIP
=
_getTIP
(
aWindow
aCallback
)
;
if
(
!
TIP
)
{
return
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
if
(
!
aEvent
.
composition
|
|
!
aEvent
.
composition
.
clauses
|
|
!
aEvent
.
composition
.
clauses
[
0
]
)
{
return
;
}
TIP
.
setPendingCompositionString
(
aEvent
.
composition
.
string
)
;
if
(
aEvent
.
composition
.
clauses
[
0
]
.
length
)
{
for
(
var
i
=
0
;
i
<
aEvent
.
composition
.
clauses
.
length
;
i
+
+
)
{
switch
(
aEvent
.
composition
.
clauses
[
i
]
.
attr
)
{
case
TIP
.
ATTR_RAW_CLAUSE
:
case
TIP
.
ATTR_SELECTED_RAW_CLAUSE
:
case
TIP
.
ATTR_CONVERTED_CLAUSE
:
case
TIP
.
ATTR_SELECTED_CLAUSE
:
TIP
.
appendClauseToPendingComposition
(
aEvent
.
composition
.
clauses
[
i
]
.
length
aEvent
.
composition
.
clauses
[
i
]
.
attr
)
;
break
;
case
0
:
break
;
default
:
throw
new
Error
(
"
invalid
clause
attribute
specified
"
)
;
break
;
}
}
}
if
(
aEvent
.
caret
)
{
TIP
.
setCaretInPendingComposition
(
aEvent
.
caret
.
start
)
;
}
var
modifiers
=
_emulateToActivateModifiers
(
TIP
aEvent
.
key
aWindow
)
;
try
{
var
keyEventDict
=
{
dictionary
:
null
flags
:
0
}
;
var
keyEvent
=
null
;
if
(
aEvent
.
key
&
&
typeof
aEvent
.
key
.
key
=
=
=
"
string
"
)
{
keyEventDict
=
_createKeyboardEventDictionary
(
aEvent
.
key
.
key
aEvent
.
key
aWindow
)
;
keyEvent
=
new
KeyboardEvent
(
aEvent
.
key
.
type
=
=
=
"
keydown
"
?
"
keydown
"
:
aEvent
.
key
.
type
=
=
=
"
keyup
"
?
"
keyup
"
:
"
"
keyEventDict
.
dictionary
)
}
else
if
(
aEvent
.
key
=
=
=
undefined
)
{
keyEventDict
=
_createKeyboardEventDictionary
(
"
KEY_Process
"
{
}
aWindow
)
;
keyEvent
=
new
KeyboardEvent
(
"
"
keyEventDict
.
dictionary
)
}
TIP
.
flushPendingComposition
(
keyEvent
keyEventDict
.
flags
)
;
}
finally
{
_emulateToInactivateModifiers
(
TIP
modifiers
aWindow
)
;
}
}
const
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
=
0x0000
;
const
QUERY_CONTENT_FLAG_USE_XP_LINE_BREAK
=
0x0001
;
const
QUERY_CONTENT_FLAG_SELECTION_NORMAL
=
0x0000
;
const
QUERY_CONTENT_FLAG_SELECTION_SPELLCHECK
=
0x0002
;
const
QUERY_CONTENT_FLAG_SELECTION_IME_RAWINPUT
=
0x0004
;
const
QUERY_CONTENT_FLAG_SELECTION_IME_SELECTEDRAWTEXT
=
0x0008
;
const
QUERY_CONTENT_FLAG_SELECTION_IME_CONVERTEDTEXT
=
0x0010
;
const
QUERY_CONTENT_FLAG_SELECTION_IME_SELECTEDCONVERTEDTEXT
=
0x0020
;
const
QUERY_CONTENT_FLAG_SELECTION_ACCESSIBILITY
=
0x0040
;
const
QUERY_CONTENT_FLAG_SELECTION_FIND
=
0x0080
;
const
QUERY_CONTENT_FLAG_SELECTION_URLSECONDARY
=
0x0100
;
const
QUERY_CONTENT_FLAG_SELECTION_URLSTRIKEOUT
=
0x0200
;
const
QUERY_CONTENT_FLAG_OFFSET_RELATIVE_TO_INSERTION_POINT
=
0x0400
;
const
SELECTION_SET_FLAG_USE_NATIVE_LINE_BREAK
=
0x0000
;
const
SELECTION_SET_FLAG_USE_XP_LINE_BREAK
=
0x0001
;
const
SELECTION_SET_FLAG_REVERSE
=
0x0002
;
function
synthesizeQueryTextContent
(
aOffset
aLength
aIsRelative
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
nullptr
;
}
var
flags
=
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
;
if
(
aIsRelative
=
=
=
true
)
{
flags
|
=
QUERY_CONTENT_FLAG_OFFSET_RELATIVE_TO_INSERTION_POINT
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_TEXT_CONTENT
aOffset
aLength
0
0
flags
)
;
}
function
synthesizeQuerySelectedText
(
aSelectionType
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
null
;
}
var
flags
=
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
;
if
(
aSelectionType
)
{
flags
|
=
aSelectionType
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_SELECTED_TEXT
0
0
0
0
flags
)
;
}
function
synthesizeQueryCaretRect
(
aOffset
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
null
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_CARET_RECT
aOffset
0
0
0
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
function
synthesizeSelectionSet
(
aOffset
aLength
aReverse
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
false
;
}
var
flags
=
aReverse
?
SELECTION_SET_FLAG_REVERSE
:
0
;
return
utils
.
sendSelectionSetEvent
(
aOffset
aLength
flags
)
;
}
function
synthesizeNativeOSXClick
(
x
y
)
{
var
{
ctypes
}
=
_EU_Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
{
}
)
;
var
CoreFoundation
=
ctypes
.
open
(
"
/
System
/
Library
/
Frameworks
/
CoreFoundation
.
framework
/
CoreFoundation
"
)
;
var
CoreGraphics
=
ctypes
.
open
(
"
/
System
/
Library
/
Frameworks
/
CoreGraphics
.
framework
/
CoreGraphics
"
)
;
var
kCGEventLeftMouseDown
=
1
;
var
kCGEventLeftMouseUp
=
2
;
var
kCGEventSourceStateHIDSystemState
=
1
;
var
kCGHIDEventTap
=
0
;
var
kCGMouseButtonLeft
=
0
;
var
kCGMouseEventClickState
=
1
;
var
CGEventField
=
ctypes
.
uint32_t
;
var
CGEventRef
=
ctypes
.
voidptr_t
;
var
CGEventSourceRef
=
ctypes
.
voidptr_t
;
var
CGEventSourceStateID
=
ctypes
.
uint32_t
;
var
CGEventTapLocation
=
ctypes
.
uint32_t
;
var
CGEventType
=
ctypes
.
uint32_t
;
var
CGFloat
=
ctypes
.
voidptr_t
.
size
=
=
4
?
ctypes
.
float
:
ctypes
.
double
;
var
CGMouseButton
=
ctypes
.
uint32_t
;
var
CGPoint
=
new
ctypes
.
StructType
(
"
CGPoint
"
[
{
"
x
"
:
CGFloat
}
{
"
y
"
:
CGFloat
}
]
)
;
var
CGEventSourceCreate
=
CoreGraphics
.
declare
(
"
CGEventSourceCreate
"
ctypes
.
default_abi
CGEventSourceRef
CGEventSourceStateID
)
;
var
CGEventCreateMouseEvent
=
CoreGraphics
.
declare
(
"
CGEventCreateMouseEvent
"
ctypes
.
default_abi
CGEventRef
CGEventSourceRef
CGEventType
CGPoint
CGMouseButton
)
;
var
CGEventSetIntegerValueField
=
CoreGraphics
.
declare
(
"
CGEventSetIntegerValueField
"
ctypes
.
default_abi
ctypes
.
void_t
CGEventRef
CGEventField
ctypes
.
int64_t
)
;
var
CGEventPost
=
CoreGraphics
.
declare
(
"
CGEventPost
"
ctypes
.
default_abi
ctypes
.
void_t
CGEventTapLocation
CGEventRef
)
;
var
CFRelease
=
CoreFoundation
.
declare
(
"
CFRelease
"
ctypes
.
default_abi
ctypes
.
void_t
CGEventRef
)
;
var
source
=
CGEventSourceCreate
(
kCGEventSourceStateHIDSystemState
)
;
if
(
!
source
)
{
throw
new
Error
(
"
CGEventSourceCreate
returns
null
"
)
;
}
var
loc
=
new
CGPoint
(
{
x
:
x
y
:
y
}
)
;
var
event
=
CGEventCreateMouseEvent
(
source
kCGEventLeftMouseDown
loc
kCGMouseButtonLeft
)
;
if
(
!
event
)
{
throw
new
Error
(
"
CGEventCreateMouseEvent
returns
null
"
)
;
}
CGEventSetIntegerValueField
(
event
kCGMouseEventClickState
new
ctypes
.
Int64
(
1
)
)
;
CGEventPost
(
kCGHIDEventTap
event
)
;
CFRelease
(
event
)
;
event
=
CGEventCreateMouseEvent
(
source
kCGEventLeftMouseUp
loc
kCGMouseButtonLeft
)
;
if
(
!
event
)
{
throw
new
Error
(
"
CGEventCreateMouseEvent
returns
null
"
)
;
}
CGEventSetIntegerValueField
(
event
kCGMouseEventClickState
new
ctypes
.
Int64
(
1
)
)
;
CGEventPost
(
kCGHIDEventTap
event
)
;
CFRelease
(
event
)
;
CFRelease
(
source
)
;
CoreFoundation
.
close
(
)
;
CoreGraphics
.
close
(
)
;
}
function
synthesizeDragStart
(
element
expectedDragData
aWindow
x
y
)
{
if
(
!
aWindow
)
aWindow
=
window
;
x
=
x
|
|
2
;
y
=
y
|
|
2
;
const
step
=
9
;
var
result
=
"
trapDrag
was
not
called
"
;
var
trapDrag
=
function
(
event
)
{
try
{
var
dataTransfer
=
_EU_maybeWrap
(
event
.
dataTransfer
)
;
result
=
null
;
if
(
!
dataTransfer
)
throw
"
no
dataTransfer
"
;
if
(
expectedDragData
=
=
null
|
|
dataTransfer
.
mozItemCount
!
=
expectedDragData
.
length
)
throw
dataTransfer
;
for
(
var
i
=
0
;
i
<
dataTransfer
.
mozItemCount
;
i
+
+
)
{
var
dtTypes
=
dataTransfer
.
mozTypesAt
(
i
)
;
if
(
dtTypes
.
length
!
=
expectedDragData
[
i
]
.
length
)
throw
dataTransfer
;
for
(
var
j
=
0
;
j
<
dtTypes
.
length
;
j
+
+
)
{
if
(
dtTypes
[
j
]
!
=
expectedDragData
[
i
]
[
j
]
.
type
)
throw
dataTransfer
;
var
dtData
=
dataTransfer
.
mozGetDataAt
(
dtTypes
[
j
]
i
)
;
if
(
expectedDragData
[
i
]
[
j
]
.
eqTest
)
{
if
(
!
expectedDragData
[
i
]
[
j
]
.
eqTest
(
dtData
expectedDragData
[
i
]
[
j
]
.
data
)
)
throw
dataTransfer
;
}
else
if
(
expectedDragData
[
i
]
[
j
]
.
data
!
=
dtData
)
throw
dataTransfer
;
}
}
}
catch
(
ex
)
{
result
=
ex
;
}
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
aWindow
.
addEventListener
(
"
dragstart
"
trapDrag
)
;
synthesizeMouse
(
element
x
y
{
type
:
"
mousedown
"
}
aWindow
)
;
x
+
=
step
;
y
+
=
step
;
synthesizeMouse
(
element
x
y
{
type
:
"
mousemove
"
}
aWindow
)
;
x
+
=
step
;
y
+
=
step
;
synthesizeMouse
(
element
x
y
{
type
:
"
mousemove
"
}
aWindow
)
;
aWindow
.
removeEventListener
(
"
dragstart
"
trapDrag
)
;
synthesizeMouse
(
element
x
y
{
type
:
"
mouseup
"
}
aWindow
)
;
return
result
;
}
function
synthesizeQueryTextRect
(
aOffset
aLength
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
nullptr
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_TEXT_RECT
aOffset
aLength
0
0
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
function
synthesizeQueryTextRectArray
(
aOffset
aLength
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
nullptr
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_TEXT_RECT_ARRAY
aOffset
aLength
0
0
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
function
synthesizeQueryEditorRect
(
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
nullptr
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_EDITOR_RECT
0
0
0
0
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
function
synthesizeCharAtPoint
(
aX
aY
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
nullptr
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_CHARACTER_AT_POINT
0
0
aX
aY
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
function
createDragEventObject
(
aType
aDestElement
aDestWindow
aDataTransfer
aDragEvent
)
{
var
destRect
=
aDestElement
.
getBoundingClientRect
(
)
;
var
destClientX
=
destRect
.
left
+
destRect
.
width
/
2
;
var
destClientY
=
destRect
.
top
+
destRect
.
height
/
2
;
var
destScreenX
=
aDestWindow
.
mozInnerScreenX
+
destClientX
;
var
destScreenY
=
aDestWindow
.
mozInnerScreenY
+
destClientY
;
if
(
"
clientX
"
in
aDragEvent
&
&
!
(
"
screenX
"
in
aDragEvent
)
)
{
aDragEvent
.
screenX
=
aDestWindow
.
mozInnerScreenX
+
aDragEvent
.
clientX
;
}
if
(
"
clientY
"
in
aDragEvent
&
&
!
(
"
screenY
"
in
aDragEvent
)
)
{
aDragEvent
.
screenY
=
aDestWindow
.
mozInnerScreenY
+
aDragEvent
.
clientY
;
}
let
dataTransfer
=
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aDataTransfer
)
.
mozCloneForEvent
(
aType
)
)
;
dataTransfer
.
dropEffect
=
aDataTransfer
.
dropEffect
;
return
Object
.
assign
(
{
type
:
aType
screenX
:
destScreenX
screenY
:
destScreenY
clientX
:
destClientX
clientY
:
destClientY
dataTransfer
:
dataTransfer
_domDispatchOnly
:
aDragEvent
.
_domDispatchOnly
}
aDragEvent
)
;
}
function
synthesizeDragOver
(
aSrcElement
aDestElement
aDragData
aDropEffect
aWindow
aDestWindow
aDragEvent
=
{
}
)
{
if
(
!
aWindow
)
{
aWindow
=
window
;
}
if
(
!
aDestWindow
)
{
aDestWindow
=
aWindow
;
}
const
obs
=
_EU_Cc
[
"
mozilla
.
org
/
observer
-
service
;
1
"
]
.
getService
(
_EU_Ci
.
nsIObserverService
)
;
const
ds
=
_EU_Cc
[
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
]
.
getService
(
_EU_Ci
.
nsIDragService
)
;
var
sess
=
ds
.
getCurrentSession
(
)
;
function
fillDrag
(
event
)
{
if
(
aDragData
)
{
for
(
var
i
=
0
;
i
<
aDragData
.
length
;
i
+
+
)
{
var
item
=
aDragData
[
i
]
;
for
(
var
j
=
0
;
j
<
item
.
length
;
j
+
+
)
{
event
.
dataTransfer
.
mozSetDataAt
(
item
[
j
]
.
type
item
[
j
]
.
data
i
)
;
}
}
}
event
.
dataTransfer
.
dropEffect
=
aDropEffect
|
|
"
move
"
;
event
.
preventDefault
(
)
;
}
function
trapDrag
(
subject
topic
)
{
if
(
topic
=
=
"
on
-
datatransfer
-
available
"
)
{
sess
.
dataTransfer
=
_EU_maybeUnwrap
(
_EU_maybeWrap
(
subject
)
.
mozCloneForEvent
(
"
drop
"
)
)
;
sess
.
dataTransfer
.
dropEffect
=
subject
.
dropEffect
;
}
}
aWindow
.
addEventListener
(
"
dragstart
"
fillDrag
true
)
;
obs
.
addObserver
(
trapDrag
"
on
-
datatransfer
-
available
"
)
;
synthesizeMouseAtCenter
(
aSrcElement
{
type
:
"
mousedown
"
}
aWindow
)
;
var
rect
=
aSrcElement
.
getBoundingClientRect
(
)
;
var
x
=
rect
.
width
/
2
;
var
y
=
rect
.
height
/
2
;
synthesizeMouse
(
aSrcElement
x
y
{
type
:
"
mousemove
"
}
aWindow
)
;
synthesizeMouse
(
aSrcElement
x
+
10
y
+
10
{
type
:
"
mousemove
"
}
aWindow
)
;
aWindow
.
removeEventListener
(
"
dragstart
"
fillDrag
true
)
;
obs
.
removeObserver
(
trapDrag
"
on
-
datatransfer
-
available
"
)
;
var
dataTransfer
=
sess
.
dataTransfer
;
var
event
=
createDragEventObject
(
"
dragover
"
aDestElement
aDestWindow
dataTransfer
aDragEvent
)
;
var
result
=
sendDragEvent
(
event
aDestElement
aDestWindow
)
;
return
[
result
dataTransfer
]
;
}
function
synthesizeDropAfterDragOver
(
aResult
aDataTransfer
aDestElement
aDestWindow
aDragEvent
=
{
}
)
{
if
(
!
aDestWindow
)
{
aDestWindow
=
window
;
}
var
effect
=
aDataTransfer
.
dropEffect
;
var
event
;
if
(
aResult
)
{
effect
=
"
none
"
;
}
else
if
(
effect
!
=
"
none
"
)
{
event
=
createDragEventObject
(
"
drop
"
aDestElement
aDestWindow
aDataTransfer
aDragEvent
)
;
sendDragEvent
(
event
aDestElement
aDestWindow
)
;
}
synthesizeMouseAtCenter
(
aDestElement
{
type
:
"
mouseup
"
}
aDestWindow
)
;
return
effect
;
}
function
synthesizeDrop
(
aSrcElement
aDestElement
aDragData
aDropEffect
aWindow
aDestWindow
aDragEvent
=
{
}
)
{
if
(
!
aWindow
)
{
aWindow
=
window
;
}
if
(
!
aDestWindow
)
{
aDestWindow
=
aWindow
;
}
var
ds
=
_EU_Cc
[
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
]
.
getService
(
_EU_Ci
.
nsIDragService
)
;
ds
.
startDragSession
(
)
;
try
{
var
[
result
dataTransfer
]
=
synthesizeDragOver
(
aSrcElement
aDestElement
aDragData
aDropEffect
aWindow
aDestWindow
aDragEvent
)
;
return
synthesizeDropAfterDragOver
(
result
dataTransfer
aDestElement
aDestWindow
aDragEvent
)
;
}
finally
{
ds
.
endDragSession
(
true
_parseModifiers
(
aDragEvent
)
)
;
}
}
async
function
synthesizePlainDragAndDrop
(
aParams
)
{
let
{
srcElement
destElement
srcX
=
2
srcY
=
2
stepX
=
9
stepY
=
9
destX
=
2
destY
=
2
srcWindow
=
window
destWindow
=
window
}
=
aParams
;
const
ds
=
_EU_Cc
[
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
]
.
getService
(
_EU_Ci
.
nsIDragService
)
;
ds
.
startDragSession
(
)
;
try
{
let
dataTransfer
=
null
;
function
trapDrag
(
aEvent
)
{
dataTransfer
=
aEvent
.
dataTransfer
;
}
srcElement
.
addEventListener
(
"
dragstart
"
trapDrag
true
)
;
synthesizeMouse
(
srcElement
srcX
srcY
{
type
:
"
mousedown
"
}
srcWindow
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
srcX
+
=
stepX
;
srcY
+
=
stepY
;
synthesizeMouse
(
srcElement
srcX
srcY
{
type
:
"
mousemove
"
}
srcWindow
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
srcX
+
=
stepX
;
srcY
+
=
stepY
;
synthesizeMouse
(
srcElement
srcX
srcY
{
type
:
"
mousemove
"
}
srcWindow
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
srcElement
.
removeEventListener
(
"
dragstart
"
trapDrag
true
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
let
event
=
createDragEventObject
(
"
dragover
"
destElement
destWindow
dataTransfer
{
}
)
;
sendDragEvent
(
event
destElement
destWindow
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
event
=
createDragEventObject
(
"
drop
"
destElement
destWindow
dataTransfer
{
}
)
;
sendDragEvent
(
event
destElement
destWindow
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
synthesizeMouseAtCenter
(
destElement
{
type
:
"
mouseup
"
}
destWindow
)
;
}
finally
{
ds
.
endDragSession
(
true
0
)
;
}
}
var
PluginUtils
=
{
withTestPlugin
:
function
(
callback
)
{
var
ph
=
_EU_Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
_EU_Ci
.
nsIPluginHost
)
;
var
tags
=
ph
.
getPluginTags
(
)
;
for
(
var
i
=
0
;
i
<
tags
.
length
;
i
+
+
)
{
if
(
tags
[
i
]
.
name
=
=
"
Test
Plug
-
in
"
)
{
callback
(
tags
[
i
]
)
;
return
true
;
}
}
todo
(
false
"
Need
a
test
plugin
on
this
platform
"
)
;
return
false
;
}
}
;
