window
.
__defineGetter__
(
"
_EU_Ci
"
function
(
)
{
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
"
Components
"
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
Ci
:
SpecialPowers
.
Ci
;
}
)
;
window
.
__defineGetter__
(
"
_EU_Cc
"
function
(
)
{
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
"
Components
"
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
Cc
:
SpecialPowers
.
Cc
;
}
)
;
window
.
__defineGetter__
(
"
_EU_Cu
"
function
(
)
{
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
"
Components
"
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
Cu
:
SpecialPowers
.
Cu
;
}
)
;
window
.
__defineGetter__
(
"
_EU_ChromeUtils
"
function
(
)
{
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
"
ChromeUtils
"
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
ChromeUtils
:
SpecialPowers
.
ChromeUtils
;
}
)
;
window
.
__defineGetter__
(
"
_EU_OS
"
function
(
)
{
delete
this
.
_EU_OS
;
try
{
this
.
_EU_OS
=
_EU_ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
.
platform
;
}
catch
(
ex
)
{
this
.
_EU_OS
=
null
;
}
return
this
.
_EU_OS
;
}
)
;
function
_EU_isMac
(
aWindow
=
window
)
{
if
(
window
.
_EU_OS
)
{
return
window
.
_EU_OS
=
=
"
macosx
"
;
}
if
(
aWindow
)
{
try
{
return
aWindow
.
navigator
.
platform
.
indexOf
(
"
Mac
"
)
>
-
1
;
}
catch
(
ex
)
{
}
}
return
navigator
.
platform
.
indexOf
(
"
Mac
"
)
>
-
1
;
}
function
_EU_isWin
(
aWindow
=
window
)
{
if
(
window
.
_EU_OS
)
{
return
window
.
_EU_OS
=
=
"
win
"
;
}
if
(
aWindow
)
{
try
{
return
aWindow
.
navigator
.
platform
.
indexOf
(
"
Win
"
)
>
-
1
;
}
catch
(
ex
)
{
}
}
return
navigator
.
platform
.
indexOf
(
"
Win
"
)
>
-
1
;
}
function
_EU_isLinux
(
aWindow
=
window
)
{
if
(
window
.
_EU_OS
)
{
return
window
.
_EU_OS
=
=
"
linux
"
;
}
if
(
aWindow
)
{
try
{
return
aWindow
.
navigator
.
platform
.
startsWith
(
"
Linux
"
)
;
}
catch
(
ex
)
{
}
}
return
navigator
.
platform
.
startsWith
(
"
Linux
"
)
;
}
function
_EU_isAndroid
(
aWindow
=
window
)
{
if
(
window
.
_EU_OS
)
{
return
window
.
_EU_OS
=
=
"
android
"
;
}
if
(
aWindow
)
{
try
{
return
aWindow
.
navigator
.
userAgent
.
includes
(
"
Android
"
)
;
}
catch
(
ex
)
{
}
}
return
navigator
.
userAgent
.
includes
(
"
Android
"
)
;
}
function
_EU_maybeWrap
(
o
)
{
var
haveWrap
=
false
;
try
{
haveWrap
=
SpecialPowers
.
wrap
!
=
undefined
;
}
catch
(
e
)
{
}
if
(
!
haveWrap
)
{
return
o
;
}
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
"
Components
"
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
o
:
SpecialPowers
.
wrap
(
o
)
;
}
function
_EU_maybeUnwrap
(
o
)
{
var
haveWrap
=
false
;
try
{
haveWrap
=
SpecialPowers
.
unwrap
!
=
undefined
;
}
catch
(
e
)
{
}
if
(
!
haveWrap
)
{
return
o
;
}
var
c
=
Object
.
getOwnPropertyDescriptor
(
window
"
Components
"
)
;
return
c
&
&
c
.
value
&
&
!
c
.
writable
?
o
:
SpecialPowers
.
unwrap
(
o
)
;
}
function
_EU_getPlatform
(
)
{
if
(
_EU_isWin
(
)
)
{
return
"
windows
"
;
}
if
(
_EU_isMac
(
)
)
{
return
"
mac
"
;
}
if
(
_EU_isAndroid
(
)
)
{
return
"
android
"
;
}
if
(
_EU_isLinux
(
)
)
{
return
"
linux
"
;
}
return
"
unknown
"
;
}
async
function
promiseElementReadyForUserInput
(
aElement
aWindow
=
window
aLogFunc
=
null
)
{
if
(
typeof
aElement
=
=
"
string
"
)
{
aElement
=
aWindow
.
document
.
getElementById
(
aElement
)
;
}
function
waitForMouseMoveForHittest
(
)
{
return
new
Promise
(
resolve
=
>
{
let
timeout
;
const
onHit
=
(
)
=
>
{
if
(
aLogFunc
)
{
aLogFunc
(
"
mousemove
received
"
)
;
}
aWindow
.
clearInterval
(
timeout
)
;
resolve
(
true
)
;
}
;
aElement
.
addEventListener
(
"
mousemove
"
onHit
{
capture
:
true
once
:
true
}
)
;
timeout
=
aWindow
.
setInterval
(
(
)
=
>
{
if
(
aLogFunc
)
{
aLogFunc
(
"
mousemove
not
received
in
this
300ms
"
)
;
}
aElement
.
removeEventListener
(
"
mousemove
"
onHit
{
capture
:
true
}
)
;
resolve
(
false
)
;
}
300
)
;
synthesizeMouseAtCenter
(
aElement
{
type
:
"
mousemove
"
}
aWindow
)
;
}
)
;
}
for
(
let
i
=
0
;
i
<
20
;
i
+
+
)
{
if
(
await
waitForMouseMoveForHittest
(
)
)
{
return
Promise
.
resolve
(
)
;
}
}
throw
new
Error
(
"
The
element
or
the
window
did
not
become
interactive
"
)
;
}
function
getElement
(
id
)
{
return
typeof
id
=
=
"
string
"
?
document
.
getElementById
(
id
)
:
id
;
}
this
.
=
this
.
getElement
;
function
computeButton
(
aEvent
)
{
if
(
typeof
aEvent
.
button
!
=
"
undefined
"
)
{
return
aEvent
.
button
;
}
return
aEvent
.
type
=
=
"
contextmenu
"
?
2
:
0
;
}
function
computeButtons
(
aEvent
utils
)
{
if
(
typeof
aEvent
.
buttons
!
=
"
undefined
"
)
{
return
aEvent
.
buttons
;
}
if
(
typeof
aEvent
.
button
!
=
"
undefined
"
)
{
return
utils
.
MOUSE_BUTTONS_NOT_SPECIFIED
;
}
if
(
typeof
aEvent
.
type
!
=
"
undefined
"
&
&
aEvent
.
type
!
=
"
mousedown
"
)
{
return
utils
.
MOUSE_BUTTONS_NO_BUTTON
;
}
return
utils
.
MOUSE_BUTTONS_NOT_SPECIFIED
;
}
function
sendMouseEvent
(
aEvent
aTarget
aWindow
)
{
if
(
!
[
"
click
"
"
contextmenu
"
"
dblclick
"
"
mousedown
"
"
mouseup
"
"
mouseover
"
"
mouseout
"
]
.
includes
(
aEvent
.
type
)
)
{
throw
new
Error
(
"
sendMouseEvent
doesn
'
t
know
about
event
type
'
"
+
aEvent
.
type
+
"
'
"
)
;
}
if
(
!
aWindow
)
{
aWindow
=
window
;
}
if
(
typeof
aTarget
=
=
"
string
"
)
{
aTarget
=
aWindow
.
document
.
getElementById
(
aTarget
)
;
}
let
dict
=
{
bubbles
:
true
cancelable
:
true
view
:
aWindow
detail
:
aEvent
.
detail
|
|
(
aEvent
.
type
=
=
"
click
"
|
|
aEvent
.
type
=
=
"
mousedown
"
|
|
aEvent
.
type
=
=
"
mouseup
"
?
1
:
aEvent
.
type
=
=
"
dblclick
"
?
2
:
0
)
screenX
:
aEvent
.
screenX
|
|
0
screenY
:
aEvent
.
screenY
|
|
0
clientX
:
aEvent
.
clientX
|
|
0
clientY
:
aEvent
.
clientY
|
|
0
ctrlKey
:
aEvent
.
ctrlKey
|
|
false
altKey
:
aEvent
.
altKey
|
|
false
shiftKey
:
aEvent
.
shiftKey
|
|
false
metaKey
:
aEvent
.
metaKey
|
|
false
button
:
computeButton
(
aEvent
)
relatedTarget
:
aEvent
.
relatedTarget
|
|
null
}
;
let
event
=
aEvent
.
type
=
=
"
click
"
|
|
aEvent
.
type
=
=
"
contextmenu
"
?
new
aWindow
.
PointerEvent
(
aEvent
.
type
dict
)
:
new
aWindow
.
MouseEvent
(
aEvent
.
type
dict
)
;
if
(
!
window
.
document
|
|
window
.
document
.
documentURIObject
)
{
return
aTarget
.
dispatchEvent
(
event
)
;
}
return
SpecialPowers
.
dispatchEvent
(
aWindow
aTarget
event
)
;
}
function
isHidden
(
aElement
)
{
var
box
=
aElement
.
getBoundingClientRect
(
)
;
return
box
.
width
=
=
0
&
&
box
.
height
=
=
0
;
}
function
sendDragEvent
(
aEvent
aTarget
aWindow
=
window
)
{
if
(
!
[
"
drag
"
"
dragstart
"
"
dragend
"
"
dragover
"
"
dragenter
"
"
dragleave
"
"
drop
"
]
.
includes
(
aEvent
.
type
)
)
{
throw
new
Error
(
"
sendDragEvent
doesn
'
t
know
about
event
type
'
"
+
aEvent
.
type
+
"
'
"
)
;
}
if
(
typeof
aTarget
=
=
"
string
"
)
{
aTarget
=
aWindow
.
document
.
getElementById
(
aTarget
)
;
}
if
(
aEvent
.
type
!
=
"
dragend
"
&
&
isHidden
(
aTarget
)
)
{
var
targetName
=
aTarget
.
nodeName
;
if
(
"
id
"
in
aTarget
&
&
aTarget
.
id
)
{
targetName
+
=
"
#
"
+
aTarget
.
id
;
}
throw
new
Error
(
{
aEvent
.
type
}
event
target
{
targetName
}
is
hidden
)
;
}
var
event
=
aWindow
.
document
.
createEvent
(
"
DragEvent
"
)
;
var
typeArg
=
aEvent
.
type
;
var
canBubbleArg
=
true
;
var
cancelableArg
=
true
;
var
viewArg
=
aWindow
;
var
detailArg
=
aEvent
.
detail
|
|
0
;
var
screenXArg
=
aEvent
.
screenX
|
|
0
;
var
screenYArg
=
aEvent
.
screenY
|
|
0
;
var
clientXArg
=
aEvent
.
clientX
|
|
0
;
var
clientYArg
=
aEvent
.
clientY
|
|
0
;
var
ctrlKeyArg
=
aEvent
.
ctrlKey
|
|
false
;
var
altKeyArg
=
aEvent
.
altKey
|
|
false
;
var
shiftKeyArg
=
aEvent
.
shiftKey
|
|
false
;
var
metaKeyArg
=
aEvent
.
metaKey
|
|
false
;
var
buttonArg
=
computeButton
(
aEvent
)
;
var
relatedTargetArg
=
aEvent
.
relatedTarget
|
|
null
;
var
dataTransfer
=
aEvent
.
dataTransfer
|
|
null
;
event
.
initDragEvent
(
typeArg
canBubbleArg
cancelableArg
viewArg
detailArg
Math
.
round
(
screenXArg
)
Math
.
round
(
screenYArg
)
Math
.
round
(
clientXArg
)
Math
.
round
(
clientYArg
)
ctrlKeyArg
altKeyArg
shiftKeyArg
metaKeyArg
buttonArg
relatedTargetArg
dataTransfer
)
;
if
(
aEvent
.
_domDispatchOnly
)
{
return
aTarget
.
dispatchEvent
(
event
)
;
}
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
return
utils
.
dispatchDOMEventViaPresShellForTesting
(
aTarget
event
)
;
}
function
sendChar
(
aChar
aWindow
)
{
var
hasShift
;
switch
(
aChar
)
{
case
"
!
"
:
case
"
"
:
case
"
#
"
:
case
"
"
:
case
"
%
"
:
case
"
^
"
:
case
"
&
"
:
case
"
*
"
:
case
"
(
"
:
case
"
)
"
:
case
"
_
"
:
case
"
+
"
:
case
"
{
"
:
case
"
}
"
:
case
"
:
"
:
case
'
"
'
:
case
"
|
"
:
case
"
<
"
:
case
"
>
"
:
case
"
?
"
:
hasShift
=
true
;
break
;
default
:
hasShift
=
aChar
.
toLowerCase
(
)
!
=
aChar
.
toUpperCase
(
)
&
&
aChar
=
=
aChar
.
toUpperCase
(
)
;
break
;
}
synthesizeKey
(
aChar
{
shiftKey
:
hasShift
}
aWindow
)
;
}
function
sendString
(
aStr
aWindow
)
{
for
(
let
i
=
0
;
i
<
aStr
.
length
;
+
+
i
)
{
if
(
(
aStr
.
charCodeAt
(
i
)
&
0xfc00
)
=
=
0xd800
&
&
i
+
1
<
aStr
.
length
&
&
(
aStr
.
charCodeAt
(
i
+
1
)
&
0xfc00
)
=
=
0xdc00
)
{
sendChar
(
aStr
.
substring
(
i
i
+
2
)
aWindow
)
;
i
+
+
;
}
else
{
sendChar
(
aStr
.
charAt
(
i
)
aWindow
)
;
}
}
}
function
sendKey
(
aKey
aWindow
)
{
var
keyName
=
"
VK_
"
+
aKey
.
toUpperCase
(
)
;
synthesizeKey
(
keyName
{
shiftKey
:
false
}
aWindow
)
;
}
function
_parseModifiers
(
aEvent
aWindow
=
window
)
{
var
nsIDOMWindowUtils
=
_EU_Ci
.
nsIDOMWindowUtils
;
var
mval
=
0
;
if
(
aEvent
.
shiftKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_SHIFT
;
}
if
(
aEvent
.
ctrlKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_CONTROL
;
}
if
(
aEvent
.
altKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_ALT
;
}
if
(
aEvent
.
metaKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_META
;
}
if
(
aEvent
.
accelKey
)
{
mval
|
=
_EU_isMac
(
aWindow
)
?
nsIDOMWindowUtils
.
MODIFIER_META
:
nsIDOMWindowUtils
.
MODIFIER_CONTROL
;
}
if
(
aEvent
.
altGrKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_ALTGRAPH
;
}
if
(
aEvent
.
capsLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_CAPSLOCK
;
}
if
(
aEvent
.
fnKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_FN
;
}
if
(
aEvent
.
fnLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_FNLOCK
;
}
if
(
aEvent
.
numLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_NUMLOCK
;
}
if
(
aEvent
.
scrollLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_SCROLLLOCK
;
}
if
(
aEvent
.
symbolKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_SYMBOL
;
}
if
(
aEvent
.
symbolLockKey
)
{
mval
|
=
nsIDOMWindowUtils
.
MODIFIER_SYMBOLLOCK
;
}
return
mval
;
}
function
synthesizeMouse
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
return
synthesizeMouseAtPoint
(
rect
.
left
+
aOffsetX
rect
.
top
+
aOffsetY
aEvent
aWindow
)
;
}
function
synthesizeTouch
(
aTarget
aOffsetX
aOffsetY
aEvent
=
{
}
aWindow
=
window
)
{
let
rectX
rectY
;
if
(
Array
.
isArray
(
aTarget
)
)
{
let
lastTarget
lastTargetRect
;
aTarget
.
forEach
(
target
=
>
{
const
rect
=
target
=
=
lastTarget
?
lastTargetRect
:
target
.
getBoundingClientRect
(
)
;
rectX
.
push
(
rect
.
left
)
;
rectY
.
push
(
rect
.
top
)
;
lastTarget
=
target
;
lastTargetRect
=
rect
;
}
)
;
}
else
{
const
rect
=
aTarget
.
getBoundingClientRect
(
)
;
rectX
=
[
rect
.
left
]
;
rectY
=
[
rect
.
top
]
;
}
const
offsetX
=
(
(
)
=
>
{
if
(
Array
.
isArray
(
aOffsetX
)
)
{
let
ret
=
[
]
;
aOffsetX
.
forEach
(
(
value
index
)
=
>
{
ret
.
push
(
value
+
rectX
[
Math
.
min
(
index
rectX
.
length
-
1
)
]
)
;
}
)
;
return
ret
;
}
return
aOffsetX
+
rectX
[
0
]
;
}
)
(
)
;
const
offsetY
=
(
(
)
=
>
{
if
(
Array
.
isArray
(
aOffsetY
)
)
{
let
ret
=
[
]
;
aOffsetY
.
forEach
(
(
value
index
)
=
>
{
ret
.
push
(
value
+
rectY
[
Math
.
min
(
index
rectY
.
length
-
1
)
]
)
;
}
)
;
return
ret
;
}
return
aOffsetY
+
rectY
[
0
]
;
}
)
(
)
;
return
synthesizeTouchAtPoint
(
offsetX
offsetY
aEvent
aWindow
)
;
}
function
getDragService
(
)
{
try
{
return
_EU_Cc
[
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
]
.
getService
(
_EU_Ci
.
nsIDragService
)
;
}
catch
(
e
)
{
return
null
;
}
}
function
_maybeEndDragSession
(
left
top
aEvent
aWindow
)
{
let
utils
=
_getDOMWindowUtils
(
aWindow
)
;
const
dragSession
=
utils
.
dragSession
;
if
(
!
dragSession
)
{
return
false
;
}
try
{
dragSession
.
endDragSession
(
false
_parseModifiers
(
aEvent
aWindow
)
)
;
}
catch
(
e
)
{
}
return
true
;
}
function
_maybeSynthesizeDragOver
(
left
top
aEvent
aWindow
)
{
let
utils
=
_getDOMWindowUtils
(
aWindow
)
;
const
dragSession
=
utils
.
dragSession
;
if
(
!
dragSession
)
{
return
false
;
}
const
target
=
aWindow
.
document
.
elementFromPoint
(
left
top
)
;
if
(
target
)
{
sendDragEvent
(
createDragEventObject
(
"
dragover
"
target
aWindow
dragSession
.
dataTransfer
{
accelKey
:
aEvent
.
accelKey
altKey
:
aEvent
.
altKey
altGrKey
:
aEvent
.
altGrKey
ctrlKey
:
aEvent
.
ctrlKey
metaKey
:
aEvent
.
metaKey
shiftKey
:
aEvent
.
shiftKey
capsLockKey
:
aEvent
.
capsLockKey
fnKey
:
aEvent
.
fnKey
fnLockKey
:
aEvent
.
fnLockKey
numLockKey
:
aEvent
.
numLockKey
scrollLockKey
:
aEvent
.
scrollLockKey
symbolKey
:
aEvent
.
symbolKey
symbolLockKey
:
aEvent
.
symbolLockKey
}
)
target
aWindow
)
;
}
return
true
;
}
function
synthesizeMouseAtPoint
(
left
top
aEvent
aWindow
=
window
)
{
if
(
aEvent
.
allowToHandleDragDrop
)
{
if
(
aEvent
.
type
=
=
"
mouseup
"
|
|
!
aEvent
.
type
)
{
if
(
_maybeEndDragSession
(
left
top
aEvent
aWindow
)
)
{
return
false
;
}
}
else
if
(
aEvent
.
type
=
=
"
mousemove
"
)
{
if
(
_maybeSynthesizeDragOver
(
left
top
aEvent
aWindow
)
)
{
return
false
;
}
}
}
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
var
defaultPrevented
=
false
;
if
(
utils
)
{
var
button
=
computeButton
(
aEvent
)
;
var
clickCount
=
aEvent
.
clickCount
|
|
1
;
var
modifiers
=
_parseModifiers
(
aEvent
aWindow
)
;
var
pressure
=
"
pressure
"
in
aEvent
?
aEvent
.
pressure
:
0
;
var
MouseEvent
=
_EU_maybeWrap
(
aWindow
)
.
MouseEvent
;
var
inputSource
=
"
inputSource
"
in
aEvent
?
aEvent
.
inputSource
:
MouseEvent
.
MOZ_SOURCE_MOUSE
;
var
id
;
if
(
"
id
"
in
aEvent
)
{
id
=
aEvent
.
id
;
}
else
{
var
isFromPen
=
inputSource
=
=
=
MouseEvent
.
MOZ_SOURCE_PEN
;
id
=
isFromPen
?
utils
.
DEFAULT_PEN_POINTER_ID
:
utils
.
DEFAULT_MOUSE_POINTER_ID
;
}
var
isDOMEventSynthesized
=
"
isSynthesized
"
in
aEvent
?
aEvent
.
isSynthesized
:
true
;
var
isWidgetEventSynthesized
=
"
isWidgetEventSynthesized
"
in
aEvent
?
aEvent
.
isWidgetEventSynthesized
:
false
;
if
(
"
type
"
in
aEvent
&
&
aEvent
.
type
)
{
defaultPrevented
=
utils
.
sendMouseEvent
(
aEvent
.
type
left
top
button
clickCount
modifiers
false
pressure
inputSource
isDOMEventSynthesized
isWidgetEventSynthesized
computeButtons
(
aEvent
utils
)
id
)
;
}
else
{
utils
.
sendMouseEvent
(
"
mousedown
"
left
top
button
clickCount
modifiers
false
pressure
inputSource
isDOMEventSynthesized
isWidgetEventSynthesized
computeButtons
(
Object
.
assign
(
{
type
:
"
mousedown
"
}
aEvent
)
utils
)
id
)
;
utils
.
sendMouseEvent
(
"
mouseup
"
left
top
button
clickCount
modifiers
false
pressure
inputSource
isDOMEventSynthesized
isWidgetEventSynthesized
computeButtons
(
Object
.
assign
(
{
type
:
"
mouseup
"
}
aEvent
)
utils
)
id
)
;
}
}
return
defaultPrevented
;
}
function
synthesizeTouchAtPoint
(
aLeft
aTop
aEvent
=
{
}
aWindow
=
window
)
{
let
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
false
;
}
if
(
Array
.
isArray
(
aLeft
)
&
&
Array
.
isArray
(
aTop
)
&
&
aLeft
.
length
!
=
aTop
.
length
)
{
throw
new
Error
(
aLeft
and
aTop
should
be
same
length
array
)
;
}
const
arrayLength
=
Array
.
isArray
(
aLeft
)
?
aLeft
.
length
:
Array
.
isArray
(
aTop
)
?
aTop
.
length
:
1
;
function
throwExceptionIfDifferentLengthArray
(
aArray
aName
)
{
if
(
Array
.
isArray
(
aArray
)
&
&
arrayLength
!
=
=
aArray
.
length
)
{
throw
new
Error
(
{
aName
}
is
different
length
array
)
;
}
}
const
leftArray
=
(
(
)
=
>
{
if
(
Array
.
isArray
(
aLeft
)
)
{
return
aLeft
;
}
return
new
Array
(
arrayLength
)
.
fill
(
aLeft
)
;
}
)
(
)
;
const
topArray
=
(
(
)
=
>
{
if
(
Array
.
isArray
(
aTop
)
)
{
throwExceptionIfDifferentLengthArray
(
aTop
"
aTop
"
)
;
return
aTop
;
}
return
new
Array
(
arrayLength
)
.
fill
(
aTop
)
;
}
)
(
)
;
const
idArray
=
(
(
)
=
>
{
if
(
"
id
"
in
aEvent
&
&
Array
.
isArray
(
aEvent
.
id
)
)
{
throwExceptionIfDifferentLengthArray
(
aEvent
.
id
"
aEvent
.
id
"
)
;
return
aEvent
.
id
;
}
let
id
=
aEvent
.
id
|
|
utils
.
DEFAULT_TOUCH_POINTER_ID
;
let
ret
=
[
]
;
for
(
let
i
=
0
;
i
<
arrayLength
;
i
+
+
)
{
ret
.
push
(
id
+
+
)
;
}
return
ret
;
}
)
(
)
;
function
getSameLengthArrayOfEventProperty
(
aProperty
aDefaultValue
)
{
if
(
aProperty
in
aEvent
&
&
Array
.
isArray
(
aEvent
[
aProperty
]
)
)
{
throwExceptionIfDifferentLengthArray
(
aEvent
.
rx
arrayLength
aEvent
.
{
aProperty
}
)
;
return
aEvent
[
aProperty
]
;
}
return
new
Array
(
arrayLength
)
.
fill
(
aEvent
[
aProperty
]
|
|
aDefaultValue
)
;
}
const
rxArray
=
getSameLengthArrayOfEventProperty
(
"
rx
"
1
)
;
const
ryArray
=
getSameLengthArrayOfEventProperty
(
"
ry
"
1
)
;
const
angleArray
=
getSameLengthArrayOfEventProperty
(
"
angle
"
0
)
;
const
forceArray
=
getSameLengthArrayOfEventProperty
(
"
force
"
aEvent
.
type
=
=
=
"
touchend
"
?
0
:
1
)
;
const
tiltXArray
=
getSameLengthArrayOfEventProperty
(
"
tiltX
"
0
)
;
const
tiltYArray
=
getSameLengthArrayOfEventProperty
(
"
tiltY
"
0
)
;
const
twistArray
=
getSameLengthArrayOfEventProperty
(
"
twist
"
0
)
;
const
modifiers
=
_parseModifiers
(
aEvent
aWindow
)
;
const
args
=
[
idArray
leftArray
topArray
rxArray
ryArray
angleArray
forceArray
tiltXArray
tiltYArray
twistArray
modifiers
]
;
const
sender
=
aEvent
.
mozInputSource
=
=
=
"
pen
"
?
"
sendTouchEventAsPen
"
:
"
sendTouchEvent
"
;
if
(
"
type
"
in
aEvent
&
&
aEvent
.
type
)
{
return
utils
[
sender
]
(
aEvent
.
type
.
.
.
args
)
;
}
utils
[
sender
]
(
"
touchstart
"
.
.
.
args
)
;
utils
[
sender
]
(
"
touchend
"
.
.
.
args
)
;
return
false
;
}
function
synthesizeMouseAtCenter
(
aTarget
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
return
synthesizeMouse
(
aTarget
rect
.
width
/
2
rect
.
height
/
2
aEvent
aWindow
)
;
}
function
synthesizeTouchAtCenter
(
aTarget
aEvent
=
{
}
aWindow
=
window
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
synthesizeTouchAtPoint
(
rect
.
left
+
rect
.
width
/
2
rect
.
top
+
rect
.
height
/
2
aEvent
aWindow
)
;
}
function
synthesizeWheelAtPoint
(
aLeft
aTop
aEvent
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
;
}
var
modifiers
=
_parseModifiers
(
aEvent
aWindow
)
;
var
options
=
0
;
if
(
aEvent
.
isNoLineOrPageDelta
)
{
options
|
=
utils
.
WHEEL_EVENT_CAUSED_BY_NO_LINE_OR_PAGE_DELTA_DEVICE
;
}
if
(
aEvent
.
isMomentum
)
{
options
|
=
utils
.
WHEEL_EVENT_CAUSED_BY_MOMENTUM
;
}
if
(
aEvent
.
isCustomizedByPrefs
)
{
options
|
=
utils
.
WHEEL_EVENT_CUSTOMIZED_BY_USER_PREFS
;
}
if
(
typeof
aEvent
.
expectedOverflowDeltaX
!
=
=
"
undefined
"
)
{
if
(
aEvent
.
expectedOverflowDeltaX
=
=
=
0
)
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_ZERO
;
}
else
if
(
aEvent
.
expectedOverflowDeltaX
>
0
)
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_POSITIVE
;
}
else
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_NEGATIVE
;
}
}
if
(
typeof
aEvent
.
expectedOverflowDeltaY
!
=
=
"
undefined
"
)
{
if
(
aEvent
.
expectedOverflowDeltaY
=
=
=
0
)
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_ZERO
;
}
else
if
(
aEvent
.
expectedOverflowDeltaY
>
0
)
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_POSITIVE
;
}
else
{
options
|
=
utils
.
WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_NEGATIVE
;
}
}
if
(
!
aEvent
.
deltaX
)
{
aEvent
.
deltaX
=
0
;
}
if
(
!
aEvent
.
deltaY
)
{
aEvent
.
deltaY
=
0
;
}
if
(
!
aEvent
.
deltaZ
)
{
aEvent
.
deltaZ
=
0
;
}
var
lineOrPageDeltaX
=
aEvent
.
lineOrPageDeltaX
!
=
null
?
aEvent
.
lineOrPageDeltaX
:
aEvent
.
deltaX
>
0
?
Math
.
floor
(
aEvent
.
deltaX
)
:
Math
.
ceil
(
aEvent
.
deltaX
)
;
var
lineOrPageDeltaY
=
aEvent
.
lineOrPageDeltaY
!
=
null
?
aEvent
.
lineOrPageDeltaY
:
aEvent
.
deltaY
>
0
?
Math
.
floor
(
aEvent
.
deltaY
)
:
Math
.
ceil
(
aEvent
.
deltaY
)
;
utils
.
sendWheelEvent
(
aLeft
aTop
aEvent
.
deltaX
aEvent
.
deltaY
aEvent
.
deltaZ
aEvent
.
deltaMode
modifiers
lineOrPageDeltaX
lineOrPageDeltaY
options
)
;
}
function
synthesizeWheel
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
{
var
rect
=
aTarget
.
getBoundingClientRect
(
)
;
synthesizeWheelAtPoint
(
rect
.
left
+
aOffsetX
rect
.
top
+
aOffsetY
aEvent
aWindow
)
;
}
const
_FlushModes
=
{
FLUSH
:
0
NOFLUSH
:
1
}
;
function
_sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
aFlushMode
=
_FlushModes
.
FLUSH
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
;
}
if
(
utils
.
isMozAfterPaintPending
)
{
aWindow
.
waitForAllPaintsFlushed
(
function
(
)
{
_sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
aFlushMode
aWindow
)
;
}
)
;
return
;
}
var
onwheel
=
function
(
)
{
SpecialPowers
.
wrap
(
window
)
.
removeEventListener
(
"
wheel
"
onwheel
{
mozSystemGroup
:
true
}
)
;
setTimeout
(
function
(
)
{
utils
.
advanceTimeAndRefresh
(
1000
)
;
if
(
!
aCallback
)
{
utils
.
advanceTimeAndRefresh
(
0
)
;
return
;
}
var
waitForPaints
=
function
(
)
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
waitForPaints
"
apz
-
repaints
-
flushed
"
)
;
aWindow
.
waitForAllPaintsFlushed
(
function
(
)
{
utils
.
restoreNormalRefresh
(
)
;
aCallback
(
)
;
}
)
;
}
;
SpecialPowers
.
Services
.
obs
.
addObserver
(
waitForPaints
"
apz
-
repaints
-
flushed
"
)
;
if
(
!
utils
.
flushApzRepaints
(
aWindow
)
)
{
waitForPaints
(
)
;
}
}
0
)
;
}
;
SpecialPowers
.
wrap
(
aWindow
)
.
addEventListener
(
"
wheel
"
onwheel
{
mozSystemGroup
:
true
}
)
;
if
(
aFlushMode
=
=
=
_FlushModes
.
FLUSH
)
{
synthesizeWheel
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
;
}
else
{
synthesizeWheelAtPoint
(
aOffsetX
aOffsetY
aEvent
aWindow
)
;
}
}
function
sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
aWindow
=
window
)
{
_sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
_FlushModes
.
FLUSH
aWindow
)
;
}
function
sendWheelAndPaintNoFlush
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
aWindow
=
window
)
{
_sendWheelAndPaint
(
aTarget
aOffsetX
aOffsetY
aEvent
aCallback
_FlushModes
.
NOFLUSH
aWindow
)
;
}
function
synthesizeNativeTapAtCenter
(
aTarget
aLongTap
=
false
aCallback
=
null
aWindow
=
window
)
{
let
rect
=
aTarget
.
getBoundingClientRect
(
)
;
return
synthesizeNativeTap
(
aTarget
rect
.
width
/
2
rect
.
height
/
2
aLongTap
aCallback
aWindow
)
;
}
function
synthesizeNativeTap
(
aTarget
aOffsetX
aOffsetY
aLongTap
=
false
aCallback
=
null
aWindow
=
window
)
{
let
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
;
}
let
scale
=
aWindow
.
devicePixelRatio
;
let
rect
=
aTarget
.
getBoundingClientRect
(
)
;
let
x
=
(
aWindow
.
mozInnerScreenX
+
rect
.
left
+
aOffsetX
)
*
scale
;
let
y
=
(
aWindow
.
mozInnerScreenY
+
rect
.
top
+
aOffsetY
)
*
scale
;
let
observer
=
{
observe
:
(
subject
topic
data
)
=
>
{
if
(
aCallback
&
&
topic
=
=
"
mouseevent
"
)
{
aCallback
(
data
)
;
}
}
}
;
utils
.
sendNativeTouchTap
(
x
y
aLongTap
observer
)
;
}
function
synthesizeNativeMouseEvent
(
aParams
aCallback
=
null
)
{
const
{
type
target
offsetX
offsetY
atCenter
screenX
screenY
scale
=
"
screenPixelsPerCSSPixel
"
button
=
0
modifiers
=
{
}
win
=
window
elementOnWidget
=
target
}
=
aParams
;
if
(
atCenter
)
{
if
(
offsetX
!
=
undefined
|
|
offsetY
!
=
undefined
)
{
throw
Error
(
atCenter
is
specified
but
offsetX
(
{
offsetX
}
)
and
/
or
offsetY
(
{
offsetY
}
)
are
also
specified
)
;
}
if
(
screenX
!
=
undefined
|
|
screenY
!
=
undefined
)
{
throw
Error
(
atCenter
is
specified
but
screenX
(
{
screenX
}
)
and
/
or
screenY
(
{
screenY
}
)
are
also
specified
)
;
}
if
(
!
target
)
{
throw
Error
(
"
atCenter
is
specified
but
target
is
not
specified
"
)
;
}
}
else
if
(
offsetX
!
=
undefined
&
&
offsetY
!
=
undefined
)
{
if
(
screenX
!
=
undefined
|
|
screenY
!
=
undefined
)
{
throw
Error
(
offsetX
/
Y
are
specified
but
screenX
(
{
screenX
}
)
and
/
or
screenY
(
{
screenY
}
)
are
also
specified
)
;
}
if
(
!
target
)
{
throw
Error
(
"
offsetX
and
offsetY
are
specified
but
target
is
not
specified
"
)
;
}
}
else
if
(
screenX
!
=
undefined
&
&
screenY
!
=
undefined
)
{
if
(
offsetX
!
=
undefined
|
|
offsetY
!
=
undefined
)
{
throw
Error
(
screenX
/
Y
are
specified
but
offsetX
(
{
offsetX
}
)
and
/
or
offsetY
(
{
offsetY
}
)
are
also
specified
)
;
}
}
const
utils
=
_getDOMWindowUtils
(
win
)
;
if
(
!
utils
)
{
return
;
}
const
rect
=
target
?
.
getBoundingClientRect
(
)
;
let
resolution
=
1
.
0
;
try
{
resolution
=
_getDOMWindowUtils
(
win
.
top
)
.
getResolution
(
)
;
}
catch
(
e
)
{
}
const
scaleValue
=
(
(
)
=
>
{
if
(
scale
=
=
=
"
inScreenPixels
"
)
{
return
1
.
0
;
}
if
(
scale
=
=
=
"
screenPixelsPerCSSPixel
"
)
{
return
win
.
devicePixelRatio
;
}
throw
Error
(
invalid
scale
value
(
{
scale
}
)
is
specified
)
;
}
)
(
)
;
const
x
=
(
(
)
=
>
{
if
(
screenX
!
=
undefined
)
{
return
screenX
*
scaleValue
;
}
let
winInnerOffsetX
=
win
.
mozInnerScreenX
;
try
{
winInnerOffsetX
=
win
.
top
.
mozInnerScreenX
+
(
win
.
mozInnerScreenX
-
win
.
top
.
mozInnerScreenX
)
*
resolution
;
}
catch
(
e
)
{
}
return
(
(
(
(
atCenter
?
rect
.
width
/
2
:
offsetX
)
+
rect
.
left
)
*
resolution
+
winInnerOffsetX
)
*
scaleValue
)
;
}
)
(
)
;
const
y
=
(
(
)
=
>
{
if
(
screenY
!
=
undefined
)
{
return
screenY
*
scaleValue
;
}
let
winInnerOffsetY
=
win
.
mozInnerScreenY
;
try
{
winInnerOffsetY
=
win
.
top
.
mozInnerScreenY
+
(
win
.
mozInnerScreenY
-
win
.
top
.
mozInnerScreenY
)
*
resolution
;
}
catch
(
e
)
{
}
return
(
(
(
(
atCenter
?
rect
.
height
/
2
:
offsetY
)
+
rect
.
top
)
*
resolution
+
winInnerOffsetY
)
*
scaleValue
)
;
}
)
(
)
;
const
modifierFlags
=
_parseNativeModifiers
(
modifiers
)
;
const
observer
=
{
observe
:
(
subject
topic
data
)
=
>
{
if
(
aCallback
&
&
topic
=
=
"
mouseevent
"
)
{
aCallback
(
data
)
;
}
}
}
;
if
(
type
=
=
=
"
click
"
)
{
utils
.
sendNativeMouseEvent
(
x
y
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_DOWN
button
modifierFlags
elementOnWidget
function
(
)
{
utils
.
sendNativeMouseEvent
(
x
y
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_UP
button
modifierFlags
elementOnWidget
observer
)
;
}
)
;
return
;
}
utils
.
sendNativeMouseEvent
(
x
y
(
(
)
=
>
{
switch
(
type
)
{
case
"
mousedown
"
:
return
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_DOWN
;
case
"
mouseup
"
:
return
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_UP
;
case
"
mousemove
"
:
return
utils
.
NATIVE_MOUSE_MESSAGE_MOVE
;
default
:
throw
Error
(
Invalid
type
is
specified
:
{
type
}
)
;
}
}
)
(
)
button
modifierFlags
elementOnWidget
observer
)
;
}
function
promiseNativeMouseEvent
(
aParams
)
{
return
new
Promise
(
resolve
=
>
synthesizeNativeMouseEvent
(
aParams
resolve
)
)
;
}
function
synthesizeNativeMouseEventAndWaitForEvent
(
aParams
aCallback
)
{
const
listener
=
aParams
.
eventTargetToListen
|
|
aParams
.
target
;
const
eventType
=
aParams
.
eventTypeToWait
|
|
aParams
.
type
;
listener
.
addEventListener
(
eventType
aCallback
{
capture
:
true
once
:
true
}
)
;
synthesizeNativeMouseEvent
(
aParams
)
;
}
function
promiseNativeMouseEventAndWaitForEvent
(
aParams
)
{
return
new
Promise
(
resolve
=
>
synthesizeNativeMouseEventAndWaitForEvent
(
aParams
resolve
)
)
;
}
function
synthesizeAndWaitNativeMouseMove
(
aTarget
aOffsetX
aOffsetY
aCallback
aWindow
=
window
)
{
let
browser
=
gBrowser
.
selectedTab
.
linkedBrowser
;
let
mm
=
browser
.
messageManager
;
let
{
ContentTask
}
=
_EU_ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ContentTask
.
sys
.
mjs
"
)
;
let
eventRegisteredPromise
=
new
Promise
(
resolve
=
>
{
mm
.
addMessageListener
(
"
Test
:
MouseMoveRegistered
"
function
processed
(
)
{
mm
.
removeMessageListener
(
"
Test
:
MouseMoveRegistered
"
processed
)
;
resolve
(
)
;
}
)
;
}
)
;
let
eventReceivedPromise
=
ContentTask
.
spawn
(
browser
[
aOffsetX
aOffsetY
]
(
[
clientX
clientY
]
)
=
>
{
return
new
Promise
(
resolve
=
>
{
addEventListener
(
"
mousemove
"
function
onMouseMoveEvent
(
e
)
{
if
(
e
.
clientX
=
=
clientX
&
&
e
.
clientY
=
=
clientY
)
{
removeEventListener
(
"
mousemove
"
onMouseMoveEvent
)
;
resolve
(
)
;
}
}
)
;
sendAsyncMessage
(
"
Test
:
MouseMoveRegistered
"
)
;
}
)
;
}
)
;
eventRegisteredPromise
.
then
(
(
)
=
>
{
synthesizeNativeMouseEvent
(
{
type
:
"
mousemove
"
target
:
aTarget
offsetX
:
aOffsetX
offsetY
:
aOffsetY
win
:
aWindow
}
)
;
}
)
;
return
eventReceivedPromise
;
}
function
synthesizeKey
(
aKey
aEvent
=
undefined
aWindow
=
window
aCallback
)
{
const
event
=
aEvent
=
=
=
undefined
|
|
aEvent
=
=
=
null
?
{
}
:
aEvent
;
let
dispatchKeydown
=
!
(
"
type
"
in
event
)
|
|
event
.
type
=
=
=
"
keydown
"
|
|
!
event
.
type
;
const
dispatchKeyup
=
!
(
"
type
"
in
event
)
|
|
event
.
type
=
=
=
"
keyup
"
|
|
!
event
.
type
;
if
(
dispatchKeydown
&
&
aKey
=
=
"
KEY_Escape
"
)
{
let
eventForKeydown
=
Object
.
assign
(
{
}
JSON
.
parse
(
JSON
.
stringify
(
event
)
)
)
;
eventForKeydown
.
type
=
"
keydown
"
;
if
(
_maybeEndDragSession
(
0
0
eventForKeydown
aWindow
)
)
{
if
(
!
dispatchKeyup
)
{
return
;
}
dispatchKeydown
=
false
;
}
}
var
TIP
=
_getTIP
(
aWindow
aCallback
)
;
if
(
!
TIP
)
{
return
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
var
modifiers
=
_emulateToActivateModifiers
(
TIP
event
aWindow
)
;
var
keyEventDict
=
_createKeyboardEventDictionary
(
aKey
event
TIP
aWindow
)
;
var
keyEvent
=
new
KeyboardEvent
(
"
"
keyEventDict
.
dictionary
)
;
try
{
if
(
dispatchKeydown
)
{
TIP
.
keydown
(
keyEvent
keyEventDict
.
flags
)
;
if
(
"
repeat
"
in
event
&
&
event
.
repeat
>
1
)
{
keyEventDict
.
dictionary
.
repeat
=
true
;
var
repeatedKeyEvent
=
new
KeyboardEvent
(
"
"
keyEventDict
.
dictionary
)
;
for
(
var
i
=
1
;
i
<
event
.
repeat
;
i
+
+
)
{
TIP
.
keydown
(
repeatedKeyEvent
keyEventDict
.
flags
)
;
}
}
}
if
(
dispatchKeyup
)
{
TIP
.
keyup
(
keyEvent
keyEventDict
.
flags
)
;
}
}
finally
{
_emulateToInactivateModifiers
(
TIP
modifiers
aWindow
)
;
}
}
function
synthesizeAndWaitKey
(
aKey
aEvent
aWindow
=
window
checkBeforeSynthesize
checkAfterSynthesize
)
{
let
browser
=
gBrowser
.
selectedTab
.
linkedBrowser
;
let
mm
=
browser
.
messageManager
;
let
keyCode
=
_createKeyboardEventDictionary
(
aKey
aEvent
null
aWindow
)
.
dictionary
.
keyCode
;
let
{
ContentTask
}
=
_EU_ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ContentTask
.
sys
.
mjs
"
)
;
let
keyRegisteredPromise
=
new
Promise
(
resolve
=
>
{
mm
.
addMessageListener
(
"
Test
:
KeyRegistered
"
function
processed
(
)
{
mm
.
removeMessageListener
(
"
Test
:
KeyRegistered
"
processed
)
;
resolve
(
)
;
}
)
;
}
)
;
let
keyReceivedPromise
=
ContentTask
.
spawn
(
browser
keyCode
keyCode
=
>
{
return
new
Promise
(
resolve
=
>
{
addEventListener
(
"
keyup
"
function
onKeyEvent
(
e
)
{
if
(
e
.
keyCode
=
=
keyCode
)
{
removeEventListener
(
"
keyup
"
onKeyEvent
)
;
resolve
(
)
;
}
}
)
;
sendAsyncMessage
(
"
Test
:
KeyRegistered
"
)
;
}
)
;
}
)
;
keyRegisteredPromise
.
then
(
(
)
=
>
{
if
(
checkBeforeSynthesize
)
{
checkBeforeSynthesize
(
)
;
}
synthesizeKey
(
aKey
aEvent
aWindow
)
;
if
(
checkAfterSynthesize
)
{
checkAfterSynthesize
(
)
;
}
}
)
;
return
keyReceivedPromise
;
}
function
_parseNativeModifiers
(
aModifiers
aWindow
=
window
)
{
let
modifiers
=
0
;
if
(
aModifiers
.
capsLockKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CAPS_LOCK
;
}
if
(
aModifiers
.
numLockKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_NUM_LOCK
;
}
if
(
aModifiers
.
shiftKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_SHIFT_LEFT
;
}
if
(
aModifiers
.
shiftRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_SHIFT_RIGHT
;
}
if
(
aModifiers
.
ctrlKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_LEFT
;
}
if
(
aModifiers
.
ctrlRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_RIGHT
;
}
if
(
aModifiers
.
altKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_LEFT
;
}
if
(
aModifiers
.
altRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_RIGHT
;
}
if
(
aModifiers
.
metaKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_LEFT
;
}
if
(
aModifiers
.
metaRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_RIGHT
;
}
if
(
aModifiers
.
helpKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_HELP
;
}
if
(
aModifiers
.
fnKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_FUNCTION
;
}
if
(
aModifiers
.
numericKeyPadKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_NUMERIC_KEY_PAD
;
}
if
(
aModifiers
.
accelKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_LEFT
:
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_LEFT
;
}
if
(
aModifiers
.
accelRightKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_RIGHT
:
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_RIGHT
;
}
if
(
aModifiers
.
altGrKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_LEFT
:
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_GRAPH
;
}
return
modifiers
;
}
const
KEYBOARD_LAYOUT_ARABIC
=
{
name
:
"
Arabic
"
Mac
:
6
Win
:
0x00000401
hasAltGrOnWin
:
false
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_ARABIC
"
KEYBOARD_LAYOUT_ARABIC
)
;
const
KEYBOARD_LAYOUT_ARABIC_PC
=
{
name
:
"
Arabic
-
PC
"
Mac
:
7
Win
:
null
hasAltGrOnWin
:
false
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_ARABIC_PC
"
KEYBOARD_LAYOUT_ARABIC_PC
)
;
const
KEYBOARD_LAYOUT_BRAZILIAN_ABNT
=
{
name
:
"
Brazilian
ABNT
"
Mac
:
null
Win
:
0x00000416
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_BRAZILIAN_ABNT
"
KEYBOARD_LAYOUT_BRAZILIAN_ABNT
)
;
const
KEYBOARD_LAYOUT_DVORAK_QWERTY
=
{
name
:
"
Dvorak
-
QWERTY
"
Mac
:
4
Win
:
null
hasAltGrOnWin
:
false
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_DVORAK_QWERTY
"
KEYBOARD_LAYOUT_DVORAK_QWERTY
)
;
const
KEYBOARD_LAYOUT_EN_US
=
{
name
:
"
US
"
Mac
:
0
Win
:
0x00000409
hasAltGrOnWin
:
false
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_EN_US
"
KEYBOARD_LAYOUT_EN_US
)
;
const
KEYBOARD_LAYOUT_FRENCH
=
{
name
:
"
French
"
Mac
:
8
Win
:
0x0000040c
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_FRENCH
"
KEYBOARD_LAYOUT_FRENCH
)
;
const
KEYBOARD_LAYOUT_FRENCH_PC
=
{
name
:
"
French
-
PC
"
Mac
:
13
Win
:
0x0000040c
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_FRENCH_PC
"
KEYBOARD_LAYOUT_FRENCH_PC
)
;
const
KEYBOARD_LAYOUT_GREEK
=
{
name
:
"
Greek
"
Mac
:
1
Win
:
0x00000408
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_GREEK
"
KEYBOARD_LAYOUT_GREEK
)
;
const
KEYBOARD_LAYOUT_GERMAN
=
{
name
:
"
German
"
Mac
:
2
Win
:
0x00000407
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_GERMAN
"
KEYBOARD_LAYOUT_GERMAN
)
;
const
KEYBOARD_LAYOUT_HEBREW
=
{
name
:
"
Hebrew
"
Mac
:
9
Win
:
0x0000040d
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_HEBREW
"
KEYBOARD_LAYOUT_HEBREW
)
;
const
KEYBOARD_LAYOUT_JAPANESE
=
{
name
:
"
Japanese
"
Mac
:
null
Win
:
0x00000411
hasAltGrOnWin
:
false
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_JAPANESE
"
KEYBOARD_LAYOUT_JAPANESE
)
;
const
KEYBOARD_LAYOUT_KHMER
=
{
name
:
"
Khmer
"
Mac
:
null
Win
:
0x00000453
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_KHMER
"
KEYBOARD_LAYOUT_KHMER
)
;
const
KEYBOARD_LAYOUT_LITHUANIAN
=
{
name
:
"
Lithuanian
"
Mac
:
10
Win
:
0x00010427
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_LITHUANIAN
"
KEYBOARD_LAYOUT_LITHUANIAN
)
;
const
KEYBOARD_LAYOUT_NORWEGIAN
=
{
name
:
"
Norwegian
"
Mac
:
11
Win
:
0x00000414
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_NORWEGIAN
"
KEYBOARD_LAYOUT_NORWEGIAN
)
;
const
KEYBOARD_LAYOUT_RUSSIAN
=
{
name
:
"
Russian
"
Mac
:
null
Win
:
0x00000419
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_RUSSIAN
"
KEYBOARD_LAYOUT_RUSSIAN
)
;
const
KEYBOARD_LAYOUT_RUSSIAN_MNEMONIC
=
{
name
:
"
Russian
-
Mnemonic
"
Mac
:
null
Win
:
0x00020419
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_RUSSIAN_MNEMONIC
"
KEYBOARD_LAYOUT_RUSSIAN_MNEMONIC
)
;
const
KEYBOARD_LAYOUT_SPANISH
=
{
name
:
"
Spanish
"
Mac
:
12
Win
:
0x0000040a
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_SPANISH
"
KEYBOARD_LAYOUT_SPANISH
)
;
const
KEYBOARD_LAYOUT_SWEDISH
=
{
name
:
"
Swedish
"
Mac
:
3
Win
:
0x0000041d
hasAltGrOnWin
:
true
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_SWEDISH
"
KEYBOARD_LAYOUT_SWEDISH
)
;
const
KEYBOARD_LAYOUT_THAI
=
{
name
:
"
Thai
"
Mac
:
5
Win
:
0x0002041e
hasAltGrOnWin
:
false
}
;
_defineConstant
(
"
KEYBOARD_LAYOUT_THAI
"
KEYBOARD_LAYOUT_THAI
)
;
function
synthesizeNativeKey
(
aKeyboardLayout
aNativeKeyCode
aModifiers
aChars
aUnmodifiedChars
aCallback
aWindow
=
window
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
false
;
}
var
nativeKeyboardLayout
=
null
;
if
(
_EU_isMac
(
aWindow
)
)
{
nativeKeyboardLayout
=
aKeyboardLayout
.
Mac
;
}
else
if
(
_EU_isWin
(
aWindow
)
)
{
nativeKeyboardLayout
=
aKeyboardLayout
.
Win
;
}
if
(
nativeKeyboardLayout
=
=
=
null
)
{
return
false
;
}
var
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aCallback
&
&
aTopic
=
=
"
keyevent
"
)
{
aCallback
(
aData
)
;
}
}
}
;
utils
.
sendNativeKeyEvent
(
nativeKeyboardLayout
aNativeKeyCode
_parseNativeModifiers
(
aModifiers
aWindow
)
aChars
aUnmodifiedChars
observer
)
;
return
true
;
}
var
_gSeenEvent
=
false
;
function
_expectEvent
(
aExpectedTarget
aExpectedEvent
aTestName
)
{
if
(
!
aExpectedTarget
|
|
!
aExpectedEvent
)
{
return
null
;
}
_gSeenEvent
=
false
;
var
type
=
aExpectedEvent
.
charAt
(
0
)
=
=
"
!
"
?
aExpectedEvent
.
substring
(
1
)
:
aExpectedEvent
;
var
eventHandler
=
function
(
event
)
{
var
epassed
=
!
_gSeenEvent
&
&
event
.
originalTarget
=
=
aExpectedTarget
&
&
event
.
type
=
=
type
;
is
(
epassed
true
aTestName
+
"
"
+
type
+
"
event
target
"
+
(
_gSeenEvent
?
"
twice
"
:
"
"
)
)
;
_gSeenEvent
=
true
;
}
;
aExpectedTarget
.
addEventListener
(
type
eventHandler
)
;
return
eventHandler
;
}
function
_checkExpectedEvent
(
aExpectedTarget
aExpectedEvent
aEventHandler
aTestName
)
{
if
(
aEventHandler
)
{
var
expectEvent
=
aExpectedEvent
.
charAt
(
0
)
!
=
"
!
"
;
var
type
=
expectEvent
?
aExpectedEvent
:
aExpectedEvent
.
substring
(
1
)
;
aExpectedTarget
.
removeEventListener
(
type
aEventHandler
)
;
var
desc
=
type
+
"
event
"
;
if
(
!
expectEvent
)
{
desc
+
=
"
not
"
;
}
is
(
_gSeenEvent
expectEvent
aTestName
+
"
"
+
desc
+
"
fired
"
)
;
}
_gSeenEvent
=
false
;
}
function
synthesizeMouseExpectEvent
(
aTarget
aOffsetX
aOffsetY
aEvent
aExpectedTarget
aExpectedEvent
aTestName
aWindow
)
{
var
eventHandler
=
_expectEvent
(
aExpectedTarget
aExpectedEvent
aTestName
)
;
synthesizeMouse
(
aTarget
aOffsetX
aOffsetY
aEvent
aWindow
)
;
_checkExpectedEvent
(
aExpectedTarget
aExpectedEvent
eventHandler
aTestName
)
;
}
function
synthesizeKeyExpectEvent
(
key
aEvent
aExpectedTarget
aExpectedEvent
aTestName
aWindow
)
{
var
eventHandler
=
_expectEvent
(
aExpectedTarget
aExpectedEvent
aTestName
)
;
synthesizeKey
(
key
aEvent
aWindow
)
;
_checkExpectedEvent
(
aExpectedTarget
aExpectedEvent
eventHandler
aTestName
)
;
}
function
disableNonTestMouseEvents
(
aDisable
)
{
var
domutils
=
_getDOMWindowUtils
(
)
;
domutils
.
disableNonTestMouseEvents
(
aDisable
)
;
}
function
_getDOMWindowUtils
(
aWindow
=
window
)
{
if
(
!
aWindow
)
{
aWindow
=
window
;
}
if
(
!
aWindow
.
document
|
|
aWindow
.
document
.
documentURIObject
)
{
return
aWindow
.
windowUtils
;
}
if
(
"
SpecialPowers
"
in
aWindow
&
&
aWindow
.
SpecialPowers
!
=
undefined
)
{
return
aWindow
.
SpecialPowers
.
getDOMWindowUtils
(
aWindow
)
;
}
if
(
"
SpecialPowers
"
in
aWindow
.
parent
&
&
aWindow
.
parent
.
SpecialPowers
!
=
undefined
)
{
return
aWindow
.
parent
.
SpecialPowers
.
getDOMWindowUtils
(
aWindow
)
;
}
return
aWindow
.
windowUtils
;
}
function
_defineConstant
(
name
value
)
{
Object
.
defineProperty
(
this
name
{
value
enumerable
:
true
writable
:
false
}
)
;
}
const
COMPOSITION_ATTR_RAW_CLAUSE
=
_EU_Ci
.
nsITextInputProcessor
.
ATTR_RAW_CLAUSE
;
_defineConstant
(
"
COMPOSITION_ATTR_RAW_CLAUSE
"
COMPOSITION_ATTR_RAW_CLAUSE
)
;
const
COMPOSITION_ATTR_SELECTED_RAW_CLAUSE
=
_EU_Ci
.
nsITextInputProcessor
.
ATTR_SELECTED_RAW_CLAUSE
;
_defineConstant
(
"
COMPOSITION_ATTR_SELECTED_RAW_CLAUSE
"
COMPOSITION_ATTR_SELECTED_RAW_CLAUSE
)
;
const
COMPOSITION_ATTR_CONVERTED_CLAUSE
=
_EU_Ci
.
nsITextInputProcessor
.
ATTR_CONVERTED_CLAUSE
;
_defineConstant
(
"
COMPOSITION_ATTR_CONVERTED_CLAUSE
"
COMPOSITION_ATTR_CONVERTED_CLAUSE
)
;
const
COMPOSITION_ATTR_SELECTED_CLAUSE
=
_EU_Ci
.
nsITextInputProcessor
.
ATTR_SELECTED_CLAUSE
;
_defineConstant
(
"
COMPOSITION_ATTR_SELECTED_CLAUSE
"
COMPOSITION_ATTR_SELECTED_CLAUSE
)
;
var
TIPMap
=
new
WeakMap
(
)
;
function
_getTIP
(
aWindow
aCallback
)
{
if
(
!
aWindow
)
{
aWindow
=
window
;
}
var
tip
;
if
(
TIPMap
.
has
(
aWindow
)
)
{
tip
=
TIPMap
.
get
(
aWindow
)
;
}
else
{
tip
=
_EU_Cc
[
"
mozilla
.
org
/
text
-
input
-
processor
;
1
"
]
.
createInstance
(
_EU_Ci
.
nsITextInputProcessor
)
;
TIPMap
.
set
(
aWindow
tip
)
;
}
if
(
!
tip
.
beginInputTransactionForTests
(
aWindow
aCallback
)
)
{
tip
=
null
;
TIPMap
.
delete
(
aWindow
)
;
}
return
tip
;
}
function
_getKeyboardEvent
(
aWindow
=
window
)
{
if
(
typeof
KeyboardEvent
!
=
"
undefined
"
)
{
try
{
new
KeyboardEvent
(
"
"
{
}
)
;
return
KeyboardEvent
;
}
catch
(
ex
)
{
}
}
if
(
typeof
content
!
=
"
undefined
"
&
&
"
KeyboardEvent
"
in
content
)
{
return
content
.
KeyboardEvent
;
}
return
aWindow
.
KeyboardEvent
;
}
function
_guessKeyNameFromKeyCode
(
aKeyCode
aWindow
=
window
)
{
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
switch
(
aKeyCode
)
{
case
KeyboardEvent
.
DOM_VK_CANCEL
:
return
"
Cancel
"
;
case
KeyboardEvent
.
DOM_VK_HELP
:
return
"
Help
"
;
case
KeyboardEvent
.
DOM_VK_BACK_SPACE
:
return
"
Backspace
"
;
case
KeyboardEvent
.
DOM_VK_TAB
:
return
"
Tab
"
;
case
KeyboardEvent
.
DOM_VK_CLEAR
:
return
"
Clear
"
;
case
KeyboardEvent
.
DOM_VK_RETURN
:
return
"
Enter
"
;
case
KeyboardEvent
.
DOM_VK_SHIFT
:
return
"
Shift
"
;
case
KeyboardEvent
.
DOM_VK_CONTROL
:
return
"
Control
"
;
case
KeyboardEvent
.
DOM_VK_ALT
:
return
"
Alt
"
;
case
KeyboardEvent
.
DOM_VK_PAUSE
:
return
"
Pause
"
;
case
KeyboardEvent
.
DOM_VK_EISU
:
return
"
Eisu
"
;
case
KeyboardEvent
.
DOM_VK_ESCAPE
:
return
"
Escape
"
;
case
KeyboardEvent
.
DOM_VK_CONVERT
:
return
"
Convert
"
;
case
KeyboardEvent
.
DOM_VK_NONCONVERT
:
return
"
NonConvert
"
;
case
KeyboardEvent
.
DOM_VK_ACCEPT
:
return
"
Accept
"
;
case
KeyboardEvent
.
DOM_VK_MODECHANGE
:
return
"
ModeChange
"
;
case
KeyboardEvent
.
DOM_VK_PAGE_UP
:
return
"
PageUp
"
;
case
KeyboardEvent
.
DOM_VK_PAGE_DOWN
:
return
"
PageDown
"
;
case
KeyboardEvent
.
DOM_VK_END
:
return
"
End
"
;
case
KeyboardEvent
.
DOM_VK_HOME
:
return
"
Home
"
;
case
KeyboardEvent
.
DOM_VK_LEFT
:
return
"
ArrowLeft
"
;
case
KeyboardEvent
.
DOM_VK_UP
:
return
"
ArrowUp
"
;
case
KeyboardEvent
.
DOM_VK_RIGHT
:
return
"
ArrowRight
"
;
case
KeyboardEvent
.
DOM_VK_DOWN
:
return
"
ArrowDown
"
;
case
KeyboardEvent
.
DOM_VK_SELECT
:
return
"
Select
"
;
case
KeyboardEvent
.
DOM_VK_PRINT
:
return
"
Print
"
;
case
KeyboardEvent
.
DOM_VK_EXECUTE
:
return
"
Execute
"
;
case
KeyboardEvent
.
DOM_VK_PRINTSCREEN
:
return
"
PrintScreen
"
;
case
KeyboardEvent
.
DOM_VK_INSERT
:
return
"
Insert
"
;
case
KeyboardEvent
.
DOM_VK_DELETE
:
return
"
Delete
"
;
case
KeyboardEvent
.
DOM_VK_WIN
:
return
"
OS
"
;
case
KeyboardEvent
.
DOM_VK_CONTEXT_MENU
:
return
"
ContextMenu
"
;
case
KeyboardEvent
.
DOM_VK_SLEEP
:
return
"
Standby
"
;
case
KeyboardEvent
.
DOM_VK_F1
:
return
"
F1
"
;
case
KeyboardEvent
.
DOM_VK_F2
:
return
"
F2
"
;
case
KeyboardEvent
.
DOM_VK_F3
:
return
"
F3
"
;
case
KeyboardEvent
.
DOM_VK_F4
:
return
"
F4
"
;
case
KeyboardEvent
.
DOM_VK_F5
:
return
"
F5
"
;
case
KeyboardEvent
.
DOM_VK_F6
:
return
"
F6
"
;
case
KeyboardEvent
.
DOM_VK_F7
:
return
"
F7
"
;
case
KeyboardEvent
.
DOM_VK_F8
:
return
"
F8
"
;
case
KeyboardEvent
.
DOM_VK_F9
:
return
"
F9
"
;
case
KeyboardEvent
.
DOM_VK_F10
:
return
"
F10
"
;
case
KeyboardEvent
.
DOM_VK_F11
:
return
"
F11
"
;
case
KeyboardEvent
.
DOM_VK_F12
:
return
"
F12
"
;
case
KeyboardEvent
.
DOM_VK_F13
:
return
"
F13
"
;
case
KeyboardEvent
.
DOM_VK_F14
:
return
"
F14
"
;
case
KeyboardEvent
.
DOM_VK_F15
:
return
"
F15
"
;
case
KeyboardEvent
.
DOM_VK_F16
:
return
"
F16
"
;
case
KeyboardEvent
.
DOM_VK_F17
:
return
"
F17
"
;
case
KeyboardEvent
.
DOM_VK_F18
:
return
"
F18
"
;
case
KeyboardEvent
.
DOM_VK_F19
:
return
"
F19
"
;
case
KeyboardEvent
.
DOM_VK_F20
:
return
"
F20
"
;
case
KeyboardEvent
.
DOM_VK_F21
:
return
"
F21
"
;
case
KeyboardEvent
.
DOM_VK_F22
:
return
"
F22
"
;
case
KeyboardEvent
.
DOM_VK_F23
:
return
"
F23
"
;
case
KeyboardEvent
.
DOM_VK_F24
:
return
"
F24
"
;
case
KeyboardEvent
.
DOM_VK_NUM_LOCK
:
return
"
NumLock
"
;
case
KeyboardEvent
.
DOM_VK_SCROLL_LOCK
:
return
"
ScrollLock
"
;
case
KeyboardEvent
.
DOM_VK_VOLUME_MUTE
:
return
"
AudioVolumeMute
"
;
case
KeyboardEvent
.
DOM_VK_VOLUME_DOWN
:
return
"
AudioVolumeDown
"
;
case
KeyboardEvent
.
DOM_VK_VOLUME_UP
:
return
"
AudioVolumeUp
"
;
case
KeyboardEvent
.
DOM_VK_META
:
return
"
Meta
"
;
case
KeyboardEvent
.
DOM_VK_ALTGR
:
return
"
AltGraph
"
;
case
KeyboardEvent
.
DOM_VK_PROCESSKEY
:
return
"
Process
"
;
case
KeyboardEvent
.
DOM_VK_ATTN
:
return
"
Attn
"
;
case
KeyboardEvent
.
DOM_VK_CRSEL
:
return
"
CrSel
"
;
case
KeyboardEvent
.
DOM_VK_EXSEL
:
return
"
ExSel
"
;
case
KeyboardEvent
.
DOM_VK_EREOF
:
return
"
EraseEof
"
;
case
KeyboardEvent
.
DOM_VK_PLAY
:
return
"
Play
"
;
default
:
return
"
Unidentified
"
;
}
}
function
_createKeyboardEventDictionary
(
aKey
aKeyEvent
aTIP
=
null
aWindow
=
window
)
{
var
result
=
{
dictionary
:
null
flags
:
0
}
;
var
keyCodeIsDefined
=
"
keyCode
"
in
aKeyEvent
;
var
keyCode
=
keyCodeIsDefined
&
&
aKeyEvent
.
keyCode
>
=
0
&
&
aKeyEvent
.
keyCode
<
=
255
?
aKeyEvent
.
keyCode
:
0
;
var
keyName
=
"
Unidentified
"
;
var
code
=
aKeyEvent
.
code
;
if
(
!
aTIP
)
{
aTIP
=
_getTIP
(
aWindow
)
;
}
if
(
aKey
.
indexOf
(
"
KEY_
"
)
=
=
0
)
{
keyName
=
aKey
.
substr
(
"
KEY_
"
.
length
)
;
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_NON_PRINTABLE_KEY
;
if
(
code
=
=
=
undefined
)
{
code
=
aTIP
.
computeCodeValueOfNonPrintableKey
(
keyName
aKeyEvent
.
location
)
;
}
}
else
if
(
aKey
.
indexOf
(
"
VK_
"
)
=
=
0
)
{
keyCode
=
_getKeyboardEvent
(
aWindow
)
[
"
DOM_
"
+
aKey
]
;
if
(
!
keyCode
)
{
throw
new
Error
(
"
Unknown
key
:
"
+
aKey
)
;
}
keyName
=
_guessKeyNameFromKeyCode
(
keyCode
aWindow
)
;
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_NON_PRINTABLE_KEY
;
if
(
code
=
=
=
undefined
)
{
code
=
aTIP
.
computeCodeValueOfNonPrintableKey
(
keyName
aKeyEvent
.
location
)
;
}
}
else
if
(
aKey
!
=
"
"
)
{
keyName
=
aKey
;
if
(
!
keyCodeIsDefined
)
{
keyCode
=
aTIP
.
guessKeyCodeValueOfPrintableKeyInUSEnglishKeyboardLayout
(
aKey
aKeyEvent
.
location
)
;
}
if
(
!
keyCode
)
{
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_KEEP_KEYCODE_ZERO
;
}
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_FORCE_PRINTABLE_KEY
;
if
(
code
=
=
=
undefined
)
{
code
=
aTIP
.
guessCodeValueOfPrintableKeyInUSEnglishKeyboardLayout
(
keyName
aKeyEvent
.
location
)
;
}
}
var
locationIsDefined
=
"
location
"
in
aKeyEvent
;
if
(
locationIsDefined
&
&
aKeyEvent
.
location
=
=
=
0
)
{
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_KEEP_KEY_LOCATION_STANDARD
;
}
if
(
aKeyEvent
.
doNotMarkKeydownAsProcessed
)
{
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_DONT_MARK_KEYDOWN_AS_PROCESSED
;
}
if
(
aKeyEvent
.
markKeyupAsProcessed
)
{
result
.
flags
|
=
_EU_Ci
.
nsITextInputProcessor
.
KEY_MARK_KEYUP_AS_PROCESSED
;
}
result
.
dictionary
=
{
key
:
keyName
code
location
:
locationIsDefined
?
aKeyEvent
.
location
:
0
repeat
:
"
repeat
"
in
aKeyEvent
?
aKeyEvent
.
repeat
=
=
=
true
:
false
keyCode
}
;
return
result
;
}
function
_emulateToActivateModifiers
(
aTIP
aKeyEvent
aWindow
=
window
)
{
if
(
!
aKeyEvent
)
{
return
null
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
var
modifiers
=
{
normal
:
[
{
key
:
"
Alt
"
attr
:
"
altKey
"
}
{
key
:
"
AltGraph
"
attr
:
"
altGraphKey
"
}
{
key
:
"
Control
"
attr
:
"
ctrlKey
"
}
{
key
:
"
Fn
"
attr
:
"
fnKey
"
}
{
key
:
"
Meta
"
attr
:
"
metaKey
"
}
{
key
:
"
Shift
"
attr
:
"
shiftKey
"
}
{
key
:
"
Symbol
"
attr
:
"
symbolKey
"
}
{
key
:
_EU_isMac
(
aWindow
)
?
"
Meta
"
:
"
Control
"
attr
:
"
accelKey
"
}
]
lockable
:
[
{
key
:
"
CapsLock
"
attr
:
"
capsLockKey
"
}
{
key
:
"
FnLock
"
attr
:
"
fnLockKey
"
}
{
key
:
"
NumLock
"
attr
:
"
numLockKey
"
}
{
key
:
"
ScrollLock
"
attr
:
"
scrollLockKey
"
}
{
key
:
"
SymbolLock
"
attr
:
"
symbolLockKey
"
}
]
}
;
for
(
let
i
=
0
;
i
<
modifiers
.
normal
.
length
;
i
+
+
)
{
if
(
!
aKeyEvent
[
modifiers
.
normal
[
i
]
.
attr
]
)
{
continue
;
}
if
(
aTIP
.
getModifierState
(
modifiers
.
normal
[
i
]
.
key
)
)
{
continue
;
}
let
event
=
new
KeyboardEvent
(
"
"
{
key
:
modifiers
.
normal
[
i
]
.
key
}
)
;
aTIP
.
keydown
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
modifiers
.
normal
[
i
]
.
activated
=
true
;
}
for
(
let
i
=
0
;
i
<
modifiers
.
lockable
.
length
;
i
+
+
)
{
if
(
!
aKeyEvent
[
modifiers
.
lockable
[
i
]
.
attr
]
)
{
continue
;
}
if
(
aTIP
.
getModifierState
(
modifiers
.
lockable
[
i
]
.
key
)
)
{
continue
;
}
let
event
=
new
KeyboardEvent
(
"
"
{
key
:
modifiers
.
lockable
[
i
]
.
key
}
)
;
aTIP
.
keydown
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
aTIP
.
keyup
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
modifiers
.
lockable
[
i
]
.
activated
=
true
;
}
return
modifiers
;
}
function
_emulateToInactivateModifiers
(
aTIP
aModifiers
aWindow
=
window
)
{
if
(
!
aModifiers
)
{
return
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
for
(
let
i
=
0
;
i
<
aModifiers
.
normal
.
length
;
i
+
+
)
{
if
(
!
aModifiers
.
normal
[
i
]
.
activated
)
{
continue
;
}
let
event
=
new
KeyboardEvent
(
"
"
{
key
:
aModifiers
.
normal
[
i
]
.
key
}
)
;
aTIP
.
keyup
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
}
for
(
let
i
=
0
;
i
<
aModifiers
.
lockable
.
length
;
i
+
+
)
{
if
(
!
aModifiers
.
lockable
[
i
]
.
activated
)
{
continue
;
}
if
(
!
aTIP
.
getModifierState
(
aModifiers
.
lockable
[
i
]
.
key
)
)
{
continue
;
}
let
event
=
new
KeyboardEvent
(
"
"
{
key
:
aModifiers
.
lockable
[
i
]
.
key
}
)
;
aTIP
.
keydown
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
aTIP
.
keyup
(
event
aTIP
.
KEY_NON_PRINTABLE_KEY
|
aTIP
.
KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT
)
;
}
}
function
synthesizeComposition
(
aEvent
aWindow
=
window
aCallback
)
{
var
TIP
=
_getTIP
(
aWindow
aCallback
)
;
if
(
!
TIP
)
{
return
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
var
modifiers
=
_emulateToActivateModifiers
(
TIP
aEvent
.
key
aWindow
)
;
var
keyEventDict
=
{
dictionary
:
null
flags
:
0
}
;
var
keyEvent
=
null
;
if
(
aEvent
.
key
&
&
typeof
aEvent
.
key
.
key
=
=
=
"
string
"
)
{
keyEventDict
=
_createKeyboardEventDictionary
(
aEvent
.
key
.
key
aEvent
.
key
TIP
aWindow
)
;
keyEvent
=
new
KeyboardEvent
(
aEvent
.
key
.
type
=
=
=
"
keydown
"
?
"
keydown
"
:
aEvent
.
key
.
type
=
=
=
"
keyup
"
?
"
keyup
"
:
"
"
keyEventDict
.
dictionary
)
;
}
else
if
(
aEvent
.
key
=
=
=
undefined
)
{
keyEventDict
=
_createKeyboardEventDictionary
(
"
KEY_Process
"
{
}
TIP
aWindow
)
;
keyEvent
=
new
KeyboardEvent
(
"
"
keyEventDict
.
dictionary
)
;
}
try
{
switch
(
aEvent
.
type
)
{
case
"
compositionstart
"
:
TIP
.
startComposition
(
keyEvent
keyEventDict
.
flags
)
;
break
;
case
"
compositioncommitasis
"
:
TIP
.
commitComposition
(
keyEvent
keyEventDict
.
flags
)
;
break
;
case
"
compositioncommit
"
:
TIP
.
commitCompositionWith
(
aEvent
.
data
keyEvent
keyEventDict
.
flags
)
;
break
;
}
}
finally
{
_emulateToInactivateModifiers
(
TIP
modifiers
aWindow
)
;
}
}
function
synthesizeCompositionChange
(
aEvent
aWindow
=
window
aCallback
)
{
var
TIP
=
_getTIP
(
aWindow
aCallback
)
;
if
(
!
TIP
)
{
return
;
}
var
KeyboardEvent
=
_getKeyboardEvent
(
aWindow
)
;
if
(
!
aEvent
.
composition
|
|
!
aEvent
.
composition
.
clauses
|
|
!
aEvent
.
composition
.
clauses
[
0
]
)
{
return
;
}
TIP
.
setPendingCompositionString
(
aEvent
.
composition
.
string
)
;
if
(
aEvent
.
composition
.
clauses
[
0
]
.
length
)
{
for
(
var
i
=
0
;
i
<
aEvent
.
composition
.
clauses
.
length
;
i
+
+
)
{
switch
(
aEvent
.
composition
.
clauses
[
i
]
.
attr
)
{
case
TIP
.
ATTR_RAW_CLAUSE
:
case
TIP
.
ATTR_SELECTED_RAW_CLAUSE
:
case
TIP
.
ATTR_CONVERTED_CLAUSE
:
case
TIP
.
ATTR_SELECTED_CLAUSE
:
TIP
.
appendClauseToPendingComposition
(
aEvent
.
composition
.
clauses
[
i
]
.
length
aEvent
.
composition
.
clauses
[
i
]
.
attr
)
;
break
;
case
0
:
break
;
default
:
throw
new
Error
(
"
invalid
clause
attribute
specified
"
)
;
}
}
}
if
(
aEvent
.
caret
)
{
TIP
.
setCaretInPendingComposition
(
aEvent
.
caret
.
start
)
;
}
var
modifiers
=
_emulateToActivateModifiers
(
TIP
aEvent
.
key
aWindow
)
;
try
{
var
keyEventDict
=
{
dictionary
:
null
flags
:
0
}
;
var
keyEvent
=
null
;
if
(
aEvent
.
key
&
&
typeof
aEvent
.
key
.
key
=
=
=
"
string
"
)
{
keyEventDict
=
_createKeyboardEventDictionary
(
aEvent
.
key
.
key
aEvent
.
key
TIP
aWindow
)
;
keyEvent
=
new
KeyboardEvent
(
aEvent
.
key
.
type
=
=
=
"
keydown
"
?
"
keydown
"
:
aEvent
.
key
.
type
=
=
=
"
keyup
"
?
"
keyup
"
:
"
"
keyEventDict
.
dictionary
)
;
}
else
if
(
aEvent
.
key
=
=
=
undefined
)
{
keyEventDict
=
_createKeyboardEventDictionary
(
"
KEY_Process
"
{
}
TIP
aWindow
)
;
keyEvent
=
new
KeyboardEvent
(
"
"
keyEventDict
.
dictionary
)
;
}
TIP
.
flushPendingComposition
(
keyEvent
keyEventDict
.
flags
)
;
}
finally
{
_emulateToInactivateModifiers
(
TIP
modifiers
aWindow
)
;
}
}
const
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
=
0x0000
;
const
QUERY_CONTENT_FLAG_USE_XP_LINE_BREAK
=
0x0001
;
const
QUERY_CONTENT_FLAG_SELECTION_NORMAL
=
0x0000
;
const
QUERY_CONTENT_FLAG_SELECTION_SPELLCHECK
=
0x0002
;
const
QUERY_CONTENT_FLAG_SELECTION_IME_RAWINPUT
=
0x0004
;
const
QUERY_CONTENT_FLAG_SELECTION_IME_SELECTEDRAWTEXT
=
0x0008
;
const
QUERY_CONTENT_FLAG_SELECTION_IME_CONVERTEDTEXT
=
0x0010
;
const
QUERY_CONTENT_FLAG_SELECTION_IME_SELECTEDCONVERTEDTEXT
=
0x0020
;
const
QUERY_CONTENT_FLAG_SELECTION_ACCESSIBILITY
=
0x0040
;
const
QUERY_CONTENT_FLAG_SELECTION_FIND
=
0x0080
;
const
QUERY_CONTENT_FLAG_SELECTION_URLSECONDARY
=
0x0100
;
const
QUERY_CONTENT_FLAG_SELECTION_URLSTRIKEOUT
=
0x0200
;
const
QUERY_CONTENT_FLAG_OFFSET_RELATIVE_TO_INSERTION_POINT
=
0x0400
;
const
SELECTION_SET_FLAG_USE_NATIVE_LINE_BREAK
=
0x0000
;
const
SELECTION_SET_FLAG_USE_XP_LINE_BREAK
=
0x0001
;
const
SELECTION_SET_FLAG_REVERSE
=
0x0002
;
function
synthesizeQueryTextContent
(
aOffset
aLength
aIsRelative
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
null
;
}
var
flags
=
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
;
if
(
aIsRelative
=
=
=
true
)
{
flags
|
=
QUERY_CONTENT_FLAG_OFFSET_RELATIVE_TO_INSERTION_POINT
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_TEXT_CONTENT
aOffset
aLength
0
0
flags
)
;
}
function
synthesizeQuerySelectedText
(
aSelectionType
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
var
flags
=
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
;
if
(
aSelectionType
)
{
flags
|
=
aSelectionType
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_SELECTED_TEXT
0
0
0
0
flags
)
;
}
function
synthesizeQueryCaretRect
(
aOffset
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
null
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_CARET_RECT
aOffset
0
0
0
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
async
function
synthesizeSelectionSet
(
aOffset
aLength
aReverse
aWindow
=
window
)
{
const
utils
=
_getDOMWindowUtils
(
aWindow
)
;
if
(
!
utils
)
{
return
false
;
}
await
new
Promise
(
resolve
=
>
aWindow
.
requestAnimationFrame
(
(
)
=
>
aWindow
.
requestAnimationFrame
(
resolve
)
)
)
;
const
flags
=
aReverse
?
SELECTION_SET_FLAG_REVERSE
:
0
;
return
utils
.
sendSelectionSetEvent
(
aOffset
aLength
flags
)
;
}
function
synthesizeQueryTextRect
(
aOffset
aLength
aIsRelative
aWindow
)
{
if
(
aIsRelative
!
=
=
undefined
&
&
typeof
aIsRelative
!
=
=
"
boolean
"
)
{
throw
new
Error
(
"
Maybe
you
set
Window
object
to
the
3rd
argument
but
it
should
be
a
boolean
value
"
)
;
}
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
let
flags
=
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
;
if
(
aIsRelative
=
=
=
true
)
{
flags
|
=
QUERY_CONTENT_FLAG_OFFSET_RELATIVE_TO_INSERTION_POINT
;
}
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_TEXT_RECT
aOffset
aLength
0
0
flags
)
;
}
function
synthesizeQueryTextRectArray
(
aOffset
aLength
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_TEXT_RECT_ARRAY
aOffset
aLength
0
0
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
function
synthesizeQueryEditorRect
(
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_EDITOR_RECT
0
0
0
0
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
function
synthesizeCharAtPoint
(
aX
aY
aWindow
)
{
var
utils
=
_getDOMWindowUtils
(
aWindow
)
;
return
utils
.
sendQueryContentEvent
(
utils
.
QUERY_CHARACTER_AT_POINT
0
0
aX
aY
QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK
)
;
}
function
createDragEventObject
(
aType
aDestElement
aDestWindow
aDataTransfer
aDragEvent
)
{
var
destRect
=
aDestElement
.
getBoundingClientRect
(
)
;
var
destClientX
=
destRect
.
left
+
destRect
.
width
/
2
;
var
destClientY
=
destRect
.
top
+
destRect
.
height
/
2
;
var
destScreenX
=
aDestWindow
.
mozInnerScreenX
+
destClientX
;
var
destScreenY
=
aDestWindow
.
mozInnerScreenY
+
destClientY
;
if
(
"
clientX
"
in
aDragEvent
&
&
!
(
"
screenX
"
in
aDragEvent
)
)
{
destScreenX
=
aDestWindow
.
mozInnerScreenX
+
aDragEvent
.
clientX
;
}
if
(
"
clientY
"
in
aDragEvent
&
&
!
(
"
screenY
"
in
aDragEvent
)
)
{
destScreenY
=
aDestWindow
.
mozInnerScreenY
+
aDragEvent
.
clientY
;
}
let
dataTransfer
;
if
(
aDataTransfer
)
{
dataTransfer
=
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aDataTransfer
)
.
mozCloneForEvent
(
aType
)
)
;
dataTransfer
.
dropEffect
=
aDataTransfer
.
dropEffect
;
}
return
Object
.
assign
(
{
type
:
aType
screenX
:
destScreenX
screenY
:
destScreenY
clientX
:
destClientX
clientY
:
destClientY
dataTransfer
_domDispatchOnly
:
aDragEvent
.
_domDispatchOnly
}
aDragEvent
)
;
}
function
synthesizeDragOver
(
aSrcElement
aDestElement
aDragData
aDropEffect
aWindow
aDestWindow
aDragEvent
=
{
}
)
{
if
(
!
aWindow
)
{
aWindow
=
window
;
}
if
(
!
aDestWindow
)
{
aDestWindow
=
aWindow
;
}
const
obs
=
_EU_Cc
[
"
mozilla
.
org
/
observer
-
service
;
1
"
]
.
getService
(
_EU_Ci
.
nsIObserverService
)
;
let
utils
=
_getDOMWindowUtils
(
aWindow
)
;
var
sess
=
utils
.
dragSession
;
function
fillDrag
(
event
)
{
if
(
aDragData
)
{
for
(
var
i
=
0
;
i
<
aDragData
.
length
;
i
+
+
)
{
var
item
=
aDragData
[
i
]
;
for
(
var
j
=
0
;
j
<
item
.
length
;
j
+
+
)
{
_EU_maybeWrap
(
event
.
dataTransfer
)
.
mozSetDataAt
(
item
[
j
]
.
type
item
[
j
]
.
data
i
)
;
}
}
}
event
.
dataTransfer
.
dropEffect
=
aDropEffect
|
|
"
move
"
;
event
.
preventDefault
(
)
;
}
function
trapDrag
(
subject
topic
)
{
if
(
topic
=
=
"
on
-
datatransfer
-
available
"
)
{
sess
.
dataTransfer
=
_EU_maybeUnwrap
(
_EU_maybeWrap
(
subject
)
.
mozCloneForEvent
(
"
drop
"
)
)
;
sess
.
dataTransfer
.
dropEffect
=
subject
.
dropEffect
;
}
}
aWindow
.
addEventListener
(
"
dragstart
"
fillDrag
true
)
;
obs
.
addObserver
(
trapDrag
"
on
-
datatransfer
-
available
"
)
;
synthesizeMouseAtCenter
(
aSrcElement
{
type
:
"
mousedown
"
}
aWindow
)
;
var
rect
=
aSrcElement
.
getBoundingClientRect
(
)
;
var
x
=
rect
.
width
/
2
;
var
y
=
rect
.
height
/
2
;
synthesizeMouse
(
aSrcElement
x
y
{
type
:
"
mousemove
"
}
aWindow
)
;
synthesizeMouse
(
aSrcElement
x
+
10
y
+
10
{
type
:
"
mousemove
"
}
aWindow
)
;
aWindow
.
removeEventListener
(
"
dragstart
"
fillDrag
true
)
;
obs
.
removeObserver
(
trapDrag
"
on
-
datatransfer
-
available
"
)
;
var
dataTransfer
=
sess
.
dataTransfer
;
if
(
!
dataTransfer
)
{
throw
new
Error
(
"
No
data
transfer
object
after
synthesizing
the
mouse
!
"
)
;
}
var
event
=
createDragEventObject
(
"
dragover
"
aDestElement
aDestWindow
dataTransfer
aDragEvent
)
;
var
result
=
sendDragEvent
(
event
aDestElement
aDestWindow
)
;
return
[
result
dataTransfer
]
;
}
function
synthesizeDropAfterDragOver
(
aResult
aDataTransfer
aDestElement
aDestWindow
aDragEvent
=
{
}
)
{
if
(
!
aDestWindow
)
{
aDestWindow
=
window
;
}
var
effect
=
aDataTransfer
.
dropEffect
;
var
event
;
if
(
aResult
)
{
effect
=
"
none
"
;
}
else
if
(
effect
!
=
"
none
"
)
{
event
=
createDragEventObject
(
"
drop
"
aDestElement
aDestWindow
aDataTransfer
aDragEvent
)
;
sendDragEvent
(
event
aDestElement
aDestWindow
)
;
}
this
.
AccessibilityUtils
?
.
suppressClickHandling
(
true
)
;
synthesizeMouse
(
aDestElement
2
2
{
type
:
"
mouseup
"
}
aDestWindow
)
;
this
.
AccessibilityUtils
?
.
suppressClickHandling
(
false
)
;
return
effect
;
}
function
synthesizeDrop
(
aSrcElement
aDestElement
aDragData
aDropEffect
aWindow
aDestWindow
aDragEvent
=
{
}
)
{
if
(
!
aWindow
)
{
aWindow
=
window
;
}
if
(
!
aDestWindow
)
{
aDestWindow
=
aWindow
;
}
var
ds
=
_EU_Cc
[
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
]
.
getService
(
_EU_Ci
.
nsIDragService
)
;
let
dropAction
;
switch
(
aDropEffect
)
{
case
null
:
case
undefined
:
case
"
move
"
:
dropAction
=
_EU_Ci
.
nsIDragService
.
DRAGDROP_ACTION_MOVE
;
break
;
case
"
copy
"
:
dropAction
=
_EU_Ci
.
nsIDragService
.
DRAGDROP_ACTION_COPY
;
break
;
case
"
link
"
:
dropAction
=
_EU_Ci
.
nsIDragService
.
DRAGDROP_ACTION_LINK
;
break
;
default
:
throw
new
Error
(
{
aDropEffect
}
is
an
invalid
drop
effect
value
)
;
}
ds
.
startDragSessionForTests
(
aWindow
dropAction
)
;
try
{
var
[
result
dataTransfer
]
=
synthesizeDragOver
(
aSrcElement
aDestElement
aDragData
aDropEffect
aWindow
aDestWindow
aDragEvent
)
;
return
synthesizeDropAfterDragOver
(
result
dataTransfer
aDestElement
aDestWindow
aDragEvent
)
;
}
finally
{
let
srcWindowUtils
=
_getDOMWindowUtils
(
aWindow
)
;
const
srcDragSession
=
srcWindowUtils
.
dragSession
;
srcDragSession
.
endDragSession
(
true
_parseModifiers
(
aDragEvent
)
)
;
}
}
function
_getFlattenedTreeParentNode
(
aNode
)
{
return
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aNode
)
.
flattenedTreeParentNode
)
;
}
function
_getInclusiveFlattenedTreeParentElement
(
aNode
)
{
for
(
let
inclusiveAncestor
=
aNode
;
inclusiveAncestor
;
inclusiveAncestor
=
_getFlattenedTreeParentNode
(
inclusiveAncestor
)
)
{
if
(
inclusiveAncestor
.
nodeType
=
=
Node
.
ELEMENT_NODE
)
{
return
inclusiveAncestor
;
}
}
return
null
;
}
function
_nodeIsFlattenedTreeDescendantOf
(
aPossibleDescendant
aPossibleAncestor
)
{
do
{
if
(
aPossibleDescendant
=
=
aPossibleAncestor
)
{
return
true
;
}
aPossibleDescendant
=
_getFlattenedTreeParentNode
(
aPossibleDescendant
)
;
}
while
(
aPossibleDescendant
)
;
return
false
;
}
function
_computeSrcElementFromSrcSelection
(
aSrcSelection
)
{
let
srcElement
=
aSrcSelection
.
focusNode
;
while
(
_EU_maybeWrap
(
srcElement
)
.
isNativeAnonymous
)
{
srcElement
=
_getFlattenedTreeParentNode
(
srcElement
)
;
}
if
(
srcElement
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
srcElement
=
_getInclusiveFlattenedTreeParentElement
(
srcElement
)
;
}
return
srcElement
;
}
async
function
synthesizePlainDragAndDrop
(
aParams
)
{
let
{
dragEvent
=
{
}
srcElement
srcSelection
destElement
srcX
=
2
srcY
=
2
stepX
=
9
stepY
=
9
finalX
=
srcX
+
stepX
*
2
finalY
=
srcY
+
stepY
*
2
id
=
_getDOMWindowUtils
(
window
)
.
DEFAULT_MOUSE_POINTER_ID
srcWindow
=
window
destWindow
=
window
expectCancelDragStart
=
false
expectSrcElementDisconnected
=
false
logFunc
}
=
aParams
;
if
(
aParams
.
dragEvent
!
=
=
undefined
)
{
dragEvent
=
Object
.
assign
(
{
}
aParams
.
dragEvent
)
;
}
function
rectToString
(
aRect
)
{
return
left
:
{
aRect
.
left
}
top
:
{
aRect
.
top
}
right
:
{
aRect
.
right
}
bottom
:
{
aRect
.
bottom
}
;
}
let
srcWindowUtils
=
_getDOMWindowUtils
(
srcWindow
)
;
let
destWindowUtils
=
_getDOMWindowUtils
(
destWindow
)
;
if
(
logFunc
)
{
logFunc
(
"
synthesizePlainDragAndDrop
(
)
-
-
START
"
)
;
}
if
(
srcSelection
)
{
srcElement
=
_computeSrcElementFromSrcSelection
(
srcSelection
)
;
let
srcElementRect
=
srcElement
.
getBoundingClientRect
(
)
;
if
(
logFunc
)
{
logFunc
(
srcElement
.
getBoundingClientRect
(
)
:
{
rectToString
(
srcElementRect
)
}
)
;
}
let
selectionRectList
=
srcSelection
.
getRangeAt
(
0
)
.
getClientRects
(
)
;
let
lastSelectionRect
=
selectionRectList
[
selectionRectList
.
length
-
1
]
;
if
(
logFunc
)
{
logFunc
(
srcSelection
.
getRangeAt
(
0
)
.
getClientRects
(
)
[
{
selectionRectList
.
length
-
1
}
]
:
{
rectToString
(
lastSelectionRect
)
}
)
;
}
srcX
=
Math
.
floor
(
lastSelectionRect
.
left
+
lastSelectionRect
.
width
/
2
)
;
srcY
=
Math
.
floor
(
lastSelectionRect
.
top
+
lastSelectionRect
.
height
/
2
)
;
srcX
=
Math
.
floor
(
srcX
-
srcElementRect
.
left
)
;
srcY
=
Math
.
floor
(
srcY
-
srcElementRect
.
top
)
;
if
(
aParams
.
finalX
=
=
=
undefined
)
{
finalX
=
srcX
+
stepX
*
2
;
}
if
(
aParams
.
finalY
=
=
=
undefined
)
{
finalY
=
srcY
+
stepY
*
2
;
}
}
else
if
(
logFunc
)
{
logFunc
(
srcElement
.
getBoundingClientRect
(
)
:
{
rectToString
(
srcElement
.
getBoundingClientRect
(
)
)
}
)
;
}
const
editingHost
=
(
(
)
=
>
{
if
(
!
srcElement
.
matches
(
"
:
read
-
write
"
)
)
{
return
null
;
}
let
lastEditableElement
=
srcElement
;
for
(
let
inclusiveAncestor
=
_getInclusiveFlattenedTreeParentElement
(
srcElement
)
;
inclusiveAncestor
;
inclusiveAncestor
=
_getInclusiveFlattenedTreeParentElement
(
_getFlattenedTreeParentNode
(
inclusiveAncestor
)
)
)
{
if
(
inclusiveAncestor
.
matches
(
"
:
read
-
write
"
)
)
{
lastEditableElement
=
inclusiveAncestor
;
if
(
lastEditableElement
=
=
srcElement
.
ownerDocument
.
body
)
{
break
;
}
}
}
return
lastEditableElement
;
}
)
(
)
;
try
{
srcWindowUtils
.
disableNonTestMouseEvents
(
true
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
let
mouseDownEvent
;
function
onMouseDown
(
aEvent
)
{
mouseDownEvent
=
aEvent
;
if
(
logFunc
)
{
logFunc
(
"
{
aEvent
.
type
}
"
event
is
fired
on
{
aEvent
.
target
}
(
composedTarget
:
{
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aEvent
)
.
composedTarget
)
}
)
;
}
if
(
!
_nodeIsFlattenedTreeDescendantOf
(
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aEvent
)
.
composedTarget
)
srcElement
)
)
{
throw
new
Error
(
'
event
target
of
"
mousedown
"
is
not
srcElement
nor
its
descendant
'
)
;
}
}
try
{
srcWindow
.
addEventListener
(
"
mousedown
"
onMouseDown
{
capture
:
true
}
)
;
synthesizeMouse
(
srcElement
srcX
srcY
{
type
:
"
mousedown
"
id
}
srcWindow
)
;
if
(
logFunc
)
{
logFunc
(
mousedown
at
{
srcX
}
{
srcY
}
)
;
}
if
(
!
mouseDownEvent
)
{
throw
new
Error
(
'
"
mousedown
"
event
is
not
fired
'
)
;
}
}
finally
{
srcWindow
.
removeEventListener
(
"
mousedown
"
onMouseDown
{
capture
:
true
}
)
;
}
let
dragStartEvent
;
function
onDragStart
(
aEvent
)
{
dragStartEvent
=
aEvent
;
if
(
logFunc
)
{
logFunc
(
"
{
aEvent
.
type
}
"
event
is
fired
)
;
}
if
(
!
_nodeIsFlattenedTreeDescendantOf
(
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aEvent
)
.
composedTarget
)
srcElement
)
)
{
throw
new
Error
(
'
event
target
of
"
dragstart
"
is
not
srcElement
nor
its
descendant
'
)
;
}
}
let
dragEnterEvent
;
function
onDragEnterGenerated
(
aEvent
)
{
dragEnterEvent
=
aEvent
;
}
srcWindow
.
addEventListener
(
"
dragstart
"
onDragStart
{
capture
:
true
}
)
;
srcWindow
.
addEventListener
(
"
dragenter
"
onDragEnterGenerated
{
capture
:
true
}
)
;
try
{
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
srcX
+
=
stepX
;
srcY
+
=
stepY
;
synthesizeMouse
(
srcElement
srcX
srcY
{
type
:
"
mousemove
"
id
}
srcWindow
)
;
if
(
logFunc
)
{
logFunc
(
first
mousemove
at
{
srcX
}
{
srcY
}
)
;
}
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
srcX
+
=
stepX
;
srcY
+
=
stepY
;
synthesizeMouse
(
srcElement
srcX
srcY
{
type
:
"
mousemove
"
id
}
srcWindow
)
;
if
(
logFunc
)
{
logFunc
(
second
mousemove
at
{
srcX
}
{
srcY
}
)
;
}
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
if
(
!
dragStartEvent
)
{
throw
new
Error
(
'
"
dragstart
"
event
is
not
fired
'
)
;
}
}
finally
{
srcWindow
.
removeEventListener
(
"
dragstart
"
onDragStart
{
capture
:
true
}
)
;
srcWindow
.
removeEventListener
(
"
dragenter
"
onDragEnterGenerated
{
capture
:
true
}
)
;
}
let
srcSession
=
srcWindowUtils
.
dragSession
;
if
(
!
srcSession
)
{
if
(
expectCancelDragStart
)
{
synthesizeMouse
(
srcElement
finalX
finalY
{
type
:
"
mouseup
"
id
}
srcWindow
)
;
return
;
}
throw
new
Error
(
"
drag
hasn
'
t
been
started
by
the
operation
"
)
;
}
else
if
(
expectCancelDragStart
)
{
throw
new
Error
(
"
drag
has
been
started
by
the
operation
"
)
;
}
if
(
destElement
)
{
if
(
(
srcElement
!
=
destElement
&
&
!
dragEnterEvent
)
|
|
destElement
!
=
dragEnterEvent
.
target
)
{
if
(
logFunc
)
{
logFunc
(
destElement
.
getBoundingClientRect
(
)
:
{
rectToString
(
destElement
.
getBoundingClientRect
(
)
)
}
)
;
}
function
onDragEnter
(
aEvent
)
{
dragEnterEvent
=
aEvent
;
if
(
logFunc
)
{
logFunc
(
"
{
aEvent
.
type
}
"
event
is
fired
)
;
}
if
(
aEvent
.
target
!
=
destElement
)
{
throw
new
Error
(
'
event
target
of
"
dragenter
"
is
not
destElement
'
)
;
}
}
destWindow
.
addEventListener
(
"
dragenter
"
onDragEnter
{
capture
:
true
}
)
;
try
{
let
event
=
createDragEventObject
(
"
dragenter
"
destElement
destWindow
null
dragEvent
)
;
sendDragEvent
(
event
destElement
destWindow
)
;
if
(
!
dragEnterEvent
&
&
!
destElement
.
disabled
)
{
throw
new
Error
(
'
"
dragenter
"
event
is
not
fired
'
)
;
}
if
(
dragEnterEvent
&
&
destElement
.
disabled
)
{
throw
new
Error
(
'
"
dragenter
"
event
should
not
be
fired
on
disable
element
'
)
;
}
}
finally
{
destWindow
.
removeEventListener
(
"
dragenter
"
onDragEnter
{
capture
:
true
}
)
;
}
}
let
dragOverEvent
;
function
onDragOver
(
aEvent
)
{
dragOverEvent
=
aEvent
;
if
(
logFunc
)
{
logFunc
(
"
{
aEvent
.
type
}
"
event
is
fired
)
;
}
if
(
aEvent
.
target
!
=
destElement
)
{
throw
new
Error
(
'
event
target
of
"
dragover
"
is
not
destElement
'
)
;
}
}
destWindow
.
addEventListener
(
"
dragover
"
onDragOver
{
capture
:
true
}
)
;
try
{
let
event
=
createDragEventObject
(
"
dragover
"
destElement
destWindow
null
dragEvent
)
;
sendDragEvent
(
event
destElement
destWindow
)
;
if
(
!
dragOverEvent
&
&
!
destElement
.
disabled
)
{
throw
new
Error
(
'
"
dragover
"
event
is
not
fired
'
)
;
}
if
(
dragEnterEvent
&
&
destElement
.
disabled
)
{
throw
new
Error
(
'
"
dragover
"
event
should
not
be
fired
on
disable
element
'
)
;
}
}
finally
{
destWindow
.
removeEventListener
(
"
dragover
"
onDragOver
{
capture
:
true
}
)
;
}
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
let
destSession
=
destWindowUtils
.
dragSession
;
if
(
destSession
.
dragAction
!
=
_EU_Ci
.
nsIDragService
.
DRAGDROP_ACTION_NONE
)
{
let
dropEvent
;
function
onDrop
(
aEvent
)
{
dropEvent
=
aEvent
;
if
(
logFunc
)
{
logFunc
(
"
{
aEvent
.
type
}
"
event
is
fired
)
;
}
if
(
!
_nodeIsFlattenedTreeDescendantOf
(
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aEvent
)
.
composedTarget
)
destElement
)
)
{
throw
new
Error
(
'
event
target
of
"
drop
"
is
not
destElement
nor
its
descendant
'
)
;
}
}
destWindow
.
addEventListener
(
"
drop
"
onDrop
{
capture
:
true
}
)
;
try
{
let
event
=
createDragEventObject
(
"
drop
"
destElement
destWindow
null
dragEvent
)
;
sendDragEvent
(
event
destElement
destWindow
)
;
if
(
!
dropEvent
&
&
destSession
.
canDrop
)
{
throw
new
Error
(
'
"
drop
"
event
is
not
fired
'
)
;
}
}
finally
{
destWindow
.
removeEventListener
(
"
drop
"
onDrop
{
capture
:
true
}
)
;
}
return
;
}
}
dragEvent
.
clientX
=
srcElement
.
getBoundingClientRect
(
)
.
x
+
finalX
;
dragEvent
.
clientY
=
srcElement
.
getBoundingClientRect
(
)
.
y
+
finalY
;
let
event
=
createDragEventObject
(
"
dragend
"
srcElement
srcWindow
null
dragEvent
)
;
srcSession
.
setDragEndPointForTests
(
event
.
screenX
event
.
screenY
)
;
}
finally
{
await
new
Promise
(
r
=
>
setTimeout
(
r
0
)
)
;
if
(
srcWindowUtils
.
dragSession
)
{
const
sourceNode
=
srcWindowUtils
.
dragSession
.
sourceNode
;
let
dragEndEvent
;
function
onDragEnd
(
aEvent
)
{
dragEndEvent
=
aEvent
;
if
(
logFunc
)
{
logFunc
(
"
{
aEvent
.
type
}
"
event
is
fired
)
;
}
if
(
!
_nodeIsFlattenedTreeDescendantOf
(
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aEvent
)
.
composedTarget
)
srcElement
)
&
&
_EU_maybeUnwrap
(
_EU_maybeWrap
(
aEvent
)
.
composedTarget
)
!
=
editingHost
)
{
throw
new
Error
(
'
event
target
of
"
dragend
"
is
not
srcElement
nor
its
descendant
'
)
;
}
if
(
expectSrcElementDisconnected
)
{
throw
new
Error
(
"
dragend
"
event
shouldn
'
t
be
fired
when
the
source
node
is
disconnected
(
the
source
node
is
{
sourceNode
?
.
isConnected
?
"
connected
"
:
"
null
or
disconnected
"
}
)
)
;
}
}
srcWindow
.
addEventListener
(
"
dragend
"
onDragEnd
{
capture
:
true
}
)
;
try
{
srcWindowUtils
.
dragSession
.
endDragSession
(
true
_parseModifiers
(
dragEvent
)
)
;
if
(
!
expectSrcElementDisconnected
&
&
!
dragEndEvent
)
{
throw
new
Error
(
"
dragend
"
event
is
not
fired
by
nsIDragSession
.
endDragSession
(
)
{
srcWindowUtils
.
dragSession
.
sourceNode
&
&
!
srcWindowUtils
.
dragSession
.
sourceNode
.
isConnected
?
"
(
sourceNode
was
disconnected
)
"
:
"
"
}
)
;
}
}
finally
{
srcWindow
.
removeEventListener
(
"
dragend
"
onDragEnd
{
capture
:
true
}
)
;
}
}
srcWindowUtils
.
disableNonTestMouseEvents
(
false
)
;
if
(
logFunc
)
{
logFunc
(
"
synthesizePlainDragAndDrop
(
)
-
-
END
"
)
;
}
}
}
function
_checkDataTransferItems
(
aDataTransfer
aExpectedDragData
)
{
try
{
let
dataTransfer
=
_EU_maybeWrap
(
aDataTransfer
)
;
if
(
!
dataTransfer
)
{
return
null
;
}
if
(
aExpectedDragData
=
=
null
|
|
dataTransfer
.
mozItemCount
!
=
aExpectedDragData
.
length
)
{
return
dataTransfer
;
}
for
(
let
i
=
0
;
i
<
dataTransfer
.
mozItemCount
;
i
+
+
)
{
let
dtTypes
=
dataTransfer
.
mozTypesAt
(
i
)
;
if
(
dtTypes
.
length
!
=
aExpectedDragData
[
i
]
.
length
)
{
return
dataTransfer
;
}
for
(
let
j
=
0
;
j
<
dtTypes
.
length
;
j
+
+
)
{
if
(
dtTypes
[
j
]
!
=
aExpectedDragData
[
i
]
[
j
]
.
type
)
{
return
dataTransfer
;
}
let
dtData
=
dataTransfer
.
mozGetDataAt
(
dtTypes
[
j
]
i
)
;
if
(
aExpectedDragData
[
i
]
[
j
]
.
eqTest
)
{
if
(
!
aExpectedDragData
[
i
]
[
j
]
.
eqTest
(
dtData
aExpectedDragData
[
i
]
[
j
]
.
data
)
)
{
return
dataTransfer
;
}
}
else
if
(
aExpectedDragData
[
i
]
[
j
]
.
data
!
=
dtData
)
{
return
dataTransfer
;
}
}
}
}
catch
(
ex
)
{
return
ex
;
}
return
true
;
}
async
function
synthesizePlainDragAndCancel
(
aParams
aExpectedDataTransferItems
)
{
let
srcElement
=
aParams
.
srcSelection
?
_computeSrcElementFromSrcSelection
(
aParams
.
srcSelection
)
:
aParams
.
srcElement
;
let
result
;
function
onDragStart
(
aEvent
)
{
aEvent
.
preventDefault
(
)
;
result
=
_checkDataTransferItems
(
aEvent
.
dataTransfer
aExpectedDataTransferItems
)
;
}
SpecialPowers
.
wrap
(
srcElement
.
ownerDocument
)
.
addEventListener
(
"
dragstart
"
onDragStart
{
capture
:
true
mozSystemGroup
:
true
}
)
;
try
{
aParams
.
expectCancelDragStart
=
true
;
await
synthesizePlainDragAndDrop
(
aParams
)
;
}
finally
{
SpecialPowers
.
wrap
(
srcElement
.
ownerDocument
)
.
removeEventListener
(
"
dragstart
"
onDragStart
{
capture
:
true
mozSystemGroup
:
true
}
)
;
}
return
result
;
}
async
function
synthesizeMockDragAndDrop
(
aParams
)
{
const
{
srcElement
targetElement
step
=
[
5
5
]
cancel
=
[
0
0
]
sourceBrowsingCxt
targetBrowsingCxt
=
sourceBrowsingCxt
expectCancelDragStart
=
false
expectSrcElementDisconnected
=
false
expectDragLeave
=
false
expectNoDragEvents
=
false
dropPromise
=
Promise
.
resolve
(
undefined
)
contextLabel
=
"
"
throwOnExtraMessage
=
false
}
=
aParams
;
let
{
dragController
=
null
expectNoDragTargetEvents
=
false
}
=
aParams
;
const
prefix
=
contextLabel
?
[
{
contextLabel
}
]
|
:
"
"
;
const
info
=
msg
=
>
{
aParams
.
info
(
{
prefix
}
{
msg
}
)
;
}
;
const
record
=
(
cond
msg
_
stack
)
=
>
{
aParams
.
record
(
cond
{
prefix
}
{
msg
}
null
stack
)
;
}
;
const
ok
=
(
cond
msg
)
=
>
{
record
(
cond
msg
null
Components
.
stack
.
caller
)
;
}
;
info
(
"
synthesizeMockDragAndDrop
(
)
-
-
START
"
)
;
ok
(
sourceBrowsingCxt
"
sourceBrowsingCxt
was
given
"
)
;
ok
(
sourceBrowsingCxt
!
=
targetBrowsingCxt
|
|
srcElement
!
=
targetElement
"
sourceBrowsingCxt
+
Element
cannot
be
the
same
as
targetBrowsingCxt
+
Element
"
)
;
expectNoDragTargetEvents
|
=
expectNoDragEvents
;
let
browsingContextsAreRelated
=
function
(
cxt1
cxt2
)
{
let
cxt
=
cxt1
;
while
(
cxt
)
{
if
(
cxt2
=
=
cxt
)
{
return
true
;
}
cxt
=
cxt
.
parent
;
}
cxt
=
cxt2
.
parent
;
while
(
cxt
)
{
if
(
cxt1
=
=
cxt
)
{
return
true
;
}
cxt
=
cxt
.
parent
;
}
return
false
;
}
;
let
expectProtectedDataTransferAccess
=
!
SpecialPowers
.
getBoolPref
(
"
dom
.
events
.
dataTransfer
.
protected
.
enabled
"
)
&
&
browsingContextsAreRelated
(
targetBrowsingCxt
sourceBrowsingCxt
)
;
let
expectProtectedDataTransferAccessDragendOnly
=
!
SpecialPowers
.
getBoolPref
(
"
dom
.
events
.
dataTransfer
.
protected
.
enabled
"
)
;
info
(
expectProtectedDataTransferAccess
:
{
expectProtectedDataTransferAccess
}
)
;
info
(
expectProtectedDataTransferAccessDragendOnly
:
{
expectProtectedDataTransferAccessDragendOnly
}
)
;
const
{
MockRegistrar
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
sys
.
mjs
"
)
;
let
dragServiceCid
;
let
sourceCxt
;
let
targetCxt
;
try
{
_getDOMWindowUtils
(
sourceBrowsingCxt
.
ownerGlobal
)
.
disableNonTestMouseEvents
(
true
)
;
ok
(
Services
.
appinfo
.
processType
=
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
"
synthesizeMockDragAndDrop
is
only
available
in
the
main
process
"
)
;
if
(
!
dragController
)
{
info
(
"
No
dragController
was
given
so
creating
mock
drag
service
"
)
;
const
oldDragService
=
SpecialPowers
.
Cc
[
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
]
.
getService
(
SpecialPowers
.
Ci
.
nsIDragService
)
;
dragController
=
oldDragService
.
getMockDragController
(
)
;
dragServiceCid
=
MockRegistrar
.
register
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
dragController
.
mockDragService
)
;
ok
(
dragServiceCid
"
MockDragService
was
registered
"
)
;
if
(
!
dragServiceCid
)
{
throw
new
Error
(
"
MockDragService
failed
to
register
"
)
;
}
}
const
srcVars
=
{
expectCancelDragStart
expectSrcElementDisconnected
expectNoDragEvents
expectProtectedDataTransferAccessDragendOnly
dragElementId
:
srcElement
}
;
const
targetVars
=
{
expectDragLeave
expectNoDragTargetEvents
dragElementId
:
targetElement
}
;
const
bothVars
=
{
contextLabel
throwOnExtraMessage
expectProtectedDataTransferAccess
relevantEvents
:
[
"
mousedown
"
"
mouseup
"
"
dragstart
"
"
dragenter
"
"
dragover
"
"
drop
"
"
dragleave
"
"
dragend
"
]
}
;
const
makeDragSourceContext
=
async
(
aBC
aRemoteVars
)
=
>
{
let
{
DragSourceParentContext
}
=
_EU_ChromeUtils
.
importESModule
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
DragSourceParentContext
.
sys
.
mjs
"
)
;
let
ret
=
new
DragSourceParentContext
(
aBC
aRemoteVars
SpecialPowers
)
;
await
ret
.
initialize
(
)
;
return
ret
;
}
;
const
makeDragTargetContext
=
async
(
aBC
aRemoteVars
)
=
>
{
let
{
DragTargetParentContext
}
=
_EU_ChromeUtils
.
importESModule
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
DragTargetParentContext
.
sys
.
mjs
"
)
;
let
ret
=
new
DragTargetParentContext
(
aBC
aRemoteVars
SpecialPowers
)
;
await
ret
.
initialize
(
)
;
return
ret
;
}
;
[
sourceCxt
targetCxt
]
=
await
Promise
.
all
(
[
makeDragSourceContext
(
sourceBrowsingCxt
{
.
.
.
srcVars
.
.
.
bothVars
}
)
makeDragTargetContext
(
targetBrowsingCxt
{
.
.
.
targetVars
.
.
.
bothVars
}
)
]
)
;
let
srcPos
=
await
sourceCxt
.
getElementPositions
(
)
;
let
targetPos
=
await
targetCxt
.
getElementPositions
(
)
;
info
(
screenSrcPos
:
{
srcPos
.
screenPos
}
|
screenTargetPos
:
{
targetPos
.
screenPos
}
)
;
if
(
!
expectNoDragEvents
)
{
sourceCxt
.
expect
(
"
mousedown
"
)
;
}
let
currentSrcScreenPos
=
[
Math
.
ceil
(
srcPos
.
screenPos
[
0
]
)
Math
.
ceil
(
srcPos
.
screenPos
[
1
]
)
]
;
info
(
sending
mousedown
at
{
currentSrcScreenPos
[
0
]
}
{
currentSrcScreenPos
[
1
]
}
)
;
dragController
.
sendEvent
(
sourceBrowsingCxt
Ci
.
nsIMockDragServiceController
.
eMouseDown
currentSrcScreenPos
[
0
]
currentSrcScreenPos
[
1
]
)
;
info
(
mousedown
sent
)
;
await
sourceCxt
.
synchronize
(
)
;
await
sourceCxt
.
checkMouseDown
(
)
;
let
contentInvokedDragPromise
;
info
(
"
setting
up
content
-
invoked
-
drag
observer
and
expecting
dragstart
"
)
;
if
(
!
expectNoDragEvents
)
{
sourceCxt
.
expect
(
"
dragstart
"
)
;
contentInvokedDragPromise
=
new
Promise
(
cb
=
>
{
Services
.
obs
.
addObserver
(
function
observe
(
)
{
info
(
"
content
-
invoked
-
drag
observer
received
message
"
)
;
Services
.
obs
.
removeObserver
(
observe
"
content
-
invoked
-
drag
"
)
;
cb
(
)
;
}
"
content
-
invoked
-
drag
"
)
;
}
)
;
}
currentSrcScreenPos
=
[
currentSrcScreenPos
[
0
]
+
step
[
0
]
currentSrcScreenPos
[
1
]
+
step
[
1
]
]
;
info
(
first
mousemove
at
{
currentSrcScreenPos
[
0
]
}
{
currentSrcScreenPos
[
1
]
}
)
;
dragController
.
sendEvent
(
sourceBrowsingCxt
Ci
.
nsIMockDragServiceController
.
eMouseMove
currentSrcScreenPos
[
0
]
currentSrcScreenPos
[
1
]
)
;
info
(
first
mousemove
sent
)
;
currentSrcScreenPos
=
[
currentSrcScreenPos
[
0
]
+
step
[
0
]
currentSrcScreenPos
[
1
]
+
step
[
1
]
]
;
info
(
second
mousemove
at
{
currentSrcScreenPos
[
0
]
}
{
currentSrcScreenPos
[
1
]
}
)
;
dragController
.
sendEvent
(
sourceBrowsingCxt
Ci
.
nsIMockDragServiceController
.
eMouseMove
currentSrcScreenPos
[
0
]
currentSrcScreenPos
[
1
]
)
;
info
(
second
mousemove
sent
)
;
if
(
!
expectNoDragEvents
)
{
info
(
"
waiting
for
content
-
invoked
-
drag
observable
"
)
;
await
contentInvokedDragPromise
;
ok
(
true
"
content
-
invoked
-
drag
was
received
"
)
;
}
info
(
"
checking
dragstart
"
)
;
await
sourceCxt
.
checkDragStart
(
)
;
if
(
expectNoDragEvents
)
{
ok
(
!
_getDOMWindowUtils
(
sourceBrowsingCxt
.
ownerGlobal
)
.
dragSession
"
Drag
was
properly
blocked
from
starting
.
"
)
;
return
;
}
info
(
Moving
to
target
element
.
)
;
let
currentTargetScreenPos
=
[
Math
.
ceil
(
targetPos
.
screenPos
[
0
]
)
Math
.
ceil
(
targetPos
.
screenPos
[
1
]
)
]
;
dragController
.
sendEvent
(
sourceBrowsingCxt
Ci
.
nsIMockDragServiceController
.
eMouseMove
currentTargetScreenPos
[
0
]
currentTargetScreenPos
[
1
]
)
;
await
sourceCxt
.
checkExpected
(
)
;
ok
(
_getDOMWindowUtils
(
sourceBrowsingCxt
.
ownerGlobal
)
.
dragSession
Parent
process
source
widget
has
drag
session
.
)
;
if
(
expectCancelDragStart
)
{
dragController
.
sendEvent
(
sourceBrowsingCxt
Ci
.
nsIMockDragServiceController
.
eMouseUp
cancel
[
0
]
cancel
[
1
]
)
;
return
;
}
currentTargetScreenPos
=
[
currentTargetScreenPos
[
0
]
+
step
[
0
]
currentTargetScreenPos
[
1
]
+
step
[
1
]
]
;
if
(
sourceBrowsingCxt
.
top
.
embedderElement
!
=
=
targetBrowsingCxt
.
top
.
embedderElement
)
{
info
(
"
synthesizing
dragleave
and
dragenter
to
enter
new
widget
"
)
;
dragController
.
sendEvent
(
sourceBrowsingCxt
Ci
.
nsIMockDragServiceController
.
eDragLeave
currentTargetScreenPos
[
0
]
currentTargetScreenPos
[
1
]
)
;
dragController
.
sendEvent
(
targetBrowsingCxt
Ci
.
nsIMockDragServiceController
.
eDragEnter
currentTargetScreenPos
[
0
]
currentTargetScreenPos
[
1
]
)
;
await
sourceCxt
.
checkExpected
(
)
;
await
targetCxt
.
checkExpected
(
)
;
}
info
(
"
synthesizing
dragover
to
generate
dragenter
in
DOM
"
)
;
if
(
!
expectNoDragTargetEvents
)
{
targetCxt
.
expect
(
"
dragenter
"
)
;
targetCxt
.
expect
(
"
dragover
"
)
;
}
currentTargetScreenPos
=
[
currentTargetScreenPos
[
0
]
+
step
[
0
]
currentTargetScreenPos
[
1
]
+
step
[
1
]
]
;
dragController
.
sendEvent
(
targetBrowsingCxt
Ci
.
nsIMockDragServiceController
.
eDragOver
currentTargetScreenPos
[
0
]
currentTargetScreenPos
[
1
]
)
;
await
targetCxt
.
checkExpected
(
)
;
let
expectedMessage
=
expectDragLeave
?
"
dragleave
"
:
"
drop
"
;
if
(
expectNoDragTargetEvents
)
{
await
targetCxt
.
checkHasDrag
(
false
)
;
}
else
{
await
targetCxt
.
checkSessionHasAction
(
)
;
targetCxt
.
expect
(
expectedMessage
)
;
}
if
(
!
expectSrcElementDisconnected
)
{
await
sourceCxt
.
checkHasDrag
(
true
)
;
sourceCxt
.
expect
(
"
dragend
"
)
;
}
info
(
issuing
drop
event
that
should
be
+
{
!
expectNoDragTargetEvents
?
received
as
a
{
expectedMessage
}
event
:
"
ignored
"
}
followed
by
a
dragend
event
)
;
currentTargetScreenPos
=
[
currentTargetScreenPos
[
0
]
+
step
[
0
]
currentTargetScreenPos
[
1
]
+
step
[
1
]
]
;
dragController
.
sendEvent
(
targetBrowsingCxt
Ci
.
nsIMockDragServiceController
.
eDrop
currentTargetScreenPos
[
0
]
currentTargetScreenPos
[
1
]
)
;
await
dropPromise
;
if
(
!
expectNoDragTargetEvents
)
{
await
targetCxt
.
checkDropOrDragLeave
(
)
;
}
else
{
await
targetCxt
.
checkExpected
(
)
;
}
if
(
!
expectSrcElementDisconnected
)
{
await
sourceCxt
.
checkDragEnd
(
)
;
}
else
{
await
sourceCxt
.
checkExpected
(
)
;
}
ok
(
!
_getDOMWindowUtils
(
sourceBrowsingCxt
.
ownerGlobal
)
.
dragSession
Parent
process
source
widget
does
not
have
a
drag
session
.
)
;
ok
(
!
_getDOMWindowUtils
(
targetBrowsingCxt
.
ownerGlobal
)
.
dragSession
Parent
process
target
widget
does
not
have
a
drag
session
.
)
;
}
catch
(
e
)
{
record
(
false
e
.
toString
(
)
null
e
.
stack
)
;
}
finally
{
if
(
sourceCxt
)
{
await
sourceCxt
.
cleanup
(
)
;
}
if
(
targetCxt
)
{
await
targetCxt
.
cleanup
(
)
;
}
if
(
dragServiceCid
)
{
MockRegistrar
.
unregister
(
dragServiceCid
)
;
}
_getDOMWindowUtils
(
sourceBrowsingCxt
.
ownerGlobal
)
.
disableNonTestMouseEvents
(
false
)
;
info
(
"
synthesizeMockDragAndDrop
(
)
-
-
END
"
)
;
}
}
class
EventCounter
{
constructor
(
aTarget
aType
aOptions
=
{
}
)
{
this
.
target
=
aTarget
;
this
.
type
=
aType
;
this
.
options
=
aOptions
;
this
.
eventCount
=
0
;
this
.
handleEvent
=
(
)
=
>
{
this
.
eventCount
+
+
;
}
;
SpecialPowers
.
wrap
(
aTarget
)
.
addEventListener
(
aType
this
.
handleEvent
aOptions
)
;
}
unregister
(
)
{
SpecialPowers
.
wrap
(
this
.
target
)
.
removeEventListener
(
this
.
type
this
.
handleEvent
this
.
options
)
;
}
get
count
(
)
{
return
this
.
eventCount
;
}
}
