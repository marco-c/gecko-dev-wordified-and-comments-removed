var
spawn_task
=
(
function
(
)
{
var
slice
=
Array
.
prototype
.
slice
;
co
.
wrap
=
function
(
fn
)
{
createPromise
.
__generatorFunction__
=
fn
;
return
createPromise
;
function
createPromise
(
)
{
return
co
.
call
(
this
fn
.
apply
(
this
arguments
)
)
;
}
}
;
function
co
(
gen
)
{
var
ctx
=
this
;
var
args
=
slice
.
call
(
arguments
1
)
return
new
Promise
(
function
(
resolve
reject
)
{
if
(
typeof
gen
=
=
=
'
function
'
)
gen
=
gen
.
apply
(
ctx
args
)
;
if
(
!
gen
|
|
typeof
gen
.
next
!
=
=
'
function
'
)
return
resolve
(
gen
)
;
onFulfilled
(
)
;
function
onFulfilled
(
res
)
{
var
ret
;
try
{
ret
=
gen
.
next
(
res
)
;
}
catch
(
e
)
{
return
reject
(
e
)
;
}
next
(
ret
)
;
}
function
onRejected
(
err
)
{
var
ret
;
try
{
ret
=
gen
.
throw
(
err
)
;
}
catch
(
e
)
{
return
reject
(
e
)
;
}
next
(
ret
)
;
}
function
next
(
ret
)
{
if
(
ret
.
done
)
return
resolve
(
ret
.
value
)
;
var
value
=
toPromise
.
call
(
ctx
ret
.
value
)
;
if
(
value
&
&
isPromise
(
value
)
)
return
value
.
then
(
onFulfilled
onRejected
)
;
return
onRejected
(
new
TypeError
(
'
You
may
only
yield
a
function
promise
generator
array
or
object
'
+
'
but
the
following
object
was
passed
:
"
'
+
String
(
ret
.
value
)
+
'
"
'
)
)
;
}
}
)
;
}
function
toPromise
(
obj
)
{
if
(
!
obj
)
return
obj
;
if
(
isPromise
(
obj
)
)
return
obj
;
if
(
isGeneratorFunction
(
obj
)
|
|
isGenerator
(
obj
)
)
return
co
.
call
(
this
obj
)
;
if
(
'
function
'
=
=
typeof
obj
)
return
thunkToPromise
.
call
(
this
obj
)
;
if
(
Array
.
isArray
(
obj
)
)
return
arrayToPromise
.
call
(
this
obj
)
;
if
(
isObject
(
obj
)
)
return
objectToPromise
.
call
(
this
obj
)
;
return
obj
;
}
function
thunkToPromise
(
fn
)
{
var
ctx
=
this
;
return
new
Promise
(
function
(
resolve
reject
)
{
fn
.
call
(
ctx
function
(
err
res
)
{
if
(
err
)
return
reject
(
err
)
;
if
(
arguments
.
length
>
2
)
res
=
slice
.
call
(
arguments
1
)
;
resolve
(
res
)
;
}
)
;
}
)
;
}
function
arrayToPromise
(
obj
)
{
return
Promise
.
all
(
obj
.
map
(
toPromise
this
)
)
;
}
function
objectToPromise
(
obj
)
{
var
results
=
new
obj
.
constructor
(
)
;
var
keys
=
Object
.
keys
(
obj
)
;
var
promises
=
[
]
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
promise
=
toPromise
.
call
(
this
obj
[
key
]
)
;
if
(
promise
&
&
isPromise
(
promise
)
)
defer
(
promise
key
)
;
else
results
[
key
]
=
obj
[
key
]
;
}
return
Promise
.
all
(
promises
)
.
then
(
function
(
)
{
return
results
;
}
)
;
function
defer
(
promise
key
)
{
results
[
key
]
=
undefined
;
promises
.
push
(
promise
.
then
(
function
(
res
)
{
results
[
key
]
=
res
;
}
)
)
;
}
}
function
isPromise
(
obj
)
{
return
'
function
'
=
=
typeof
obj
.
then
;
}
function
isGenerator
(
obj
)
{
return
'
function
'
=
=
typeof
obj
.
next
&
&
'
function
'
=
=
typeof
obj
.
throw
;
}
function
isGeneratorFunction
(
obj
)
{
var
constructor
=
obj
.
constructor
;
if
(
!
constructor
)
return
false
;
if
(
'
GeneratorFunction
'
=
=
=
constructor
.
name
|
|
'
GeneratorFunction
'
=
=
=
constructor
.
displayName
)
return
true
;
return
isGenerator
(
constructor
.
prototype
)
;
}
function
isObject
(
val
)
{
return
Object
=
=
val
.
constructor
;
}
return
co
;
}
)
(
)
;
var
add_task
=
(
function
(
)
{
var
task_list
=
[
]
;
var
run_only_this_task
=
null
;
return
function
(
generatorFunction
)
{
if
(
task_list
.
length
=
=
=
0
)
{
if
(
!
SimpleTest
)
{
throw
new
Error
(
"
SimpleTest
not
available
.
"
)
;
}
SimpleTest
.
waitForExplicitFinish
(
)
;
setTimeout
(
function
(
)
{
spawn_task
(
function
*
(
)
{
function
skipTask
(
name
)
{
let
logger
=
parentRunner
&
&
parentRunner
.
structuredLogger
;
if
(
!
logger
)
{
info
(
"
SpawnTask
.
js
|
Skipping
test
"
+
name
)
;
return
;
}
logger
.
deactivateBuffering
(
)
;
logger
.
testStatus
(
SimpleTest
.
_getCurrentTestURL
(
)
name
"
SKIP
"
)
;
logger
.
warning
(
"
SpawnTask
.
js
|
Skipping
test
"
+
name
)
;
logger
.
activateBuffering
(
)
;
}
try
{
for
(
var
task
of
task_list
)
{
var
name
=
task
.
name
|
|
"
"
;
if
(
task
.
__skipMe
|
|
(
run_only_this_task
&
&
task
!
=
run_only_this_task
)
)
{
skipTask
(
name
)
;
continue
;
}
info
(
"
SpawnTask
.
js
|
Entering
test
"
+
name
)
;
yield
task
(
)
;
info
(
"
SpawnTask
.
js
|
Leaving
test
"
+
name
)
;
}
}
catch
(
ex
)
{
try
{
ok
(
false
"
"
+
ex
"
Should
not
throw
any
errors
"
ex
.
stack
)
;
}
catch
(
ex2
)
{
ok
(
false
"
(
The
exception
cannot
be
converted
to
string
.
)
"
"
Should
not
throw
any
errors
"
ex
.
stack
)
;
}
}
SimpleTest
.
finish
(
)
;
}
)
;
}
)
;
}
generatorFunction
.
skip
=
(
)
=
>
generatorFunction
.
__skipMe
=
true
;
generatorFunction
.
only
=
(
)
=
>
run_only_this_task
=
generatorFunction
;
task_list
.
push
(
generatorFunction
)
;
return
generatorFunction
;
}
;
}
)
(
)
;
