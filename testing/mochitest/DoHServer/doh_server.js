"
use
strict
"
;
const
fs
=
require
(
"
fs
"
)
;
const
options
=
{
key
:
fs
.
readFileSync
(
__dirname
+
"
/
http2
-
cert
.
key
.
pem
"
)
cert
:
fs
.
readFileSync
(
__dirname
+
"
/
http2
-
cert
.
pem
"
)
}
;
const
http2
=
require
(
"
http2
"
)
;
const
http
=
require
(
"
http
"
)
;
const
url
=
require
(
"
url
"
)
;
const
path
=
require
(
"
path
"
)
;
let
dnsPacket
;
let
libPath
=
path
.
join
(
__dirname
"
.
.
/
.
.
/
xpcshell
/
dns
-
packet
"
)
;
if
(
fs
.
existsSync
(
libPath
)
)
{
dnsPacket
=
require
(
libPath
)
;
}
else
{
dnsPacket
=
require
(
path
.
join
(
__dirname
"
.
/
dns_packet
"
)
)
;
}
let
serverPort
=
parseInt
(
process
.
argv
[
2
]
.
split
(
"
=
"
)
[
1
]
)
;
let
listeningPort
=
parseInt
(
process
.
argv
[
3
]
.
split
(
"
=
"
)
[
1
]
)
;
let
alpn
=
process
.
argv
[
4
]
.
split
(
"
=
"
)
[
1
]
;
let
server
=
http2
.
createSecureServer
(
options
function
handleRequest
(
req
res
)
{
let
method
=
req
.
headers
[
http2
.
constants
.
HTTP2_HEADER_METHOD
]
;
if
(
method
=
=
"
GET
"
)
{
let
searchParams
=
new
URL
(
req
.
url
"
http
:
/
/
example
.
com
"
)
.
searchParams
;
if
(
!
searchParams
.
get
(
"
dns
"
)
)
{
res
.
writeHead
(
400
)
;
res
.
end
(
"
Missing
dns
parameter
"
)
;
return
;
}
let
requestBody
=
Buffer
.
from
(
searchParams
.
get
(
"
dns
"
)
"
base64
"
)
;
processRequest
(
req
res
requestBody
)
;
return
;
}
let
u
=
"
"
;
if
(
req
.
url
!
=
undefined
)
{
u
=
url
.
parse
(
req
.
url
true
)
;
}
if
(
u
.
pathname
=
=
=
"
/
dns
-
query
"
)
{
let
payload
=
Buffer
.
from
(
"
"
)
;
req
.
on
(
"
data
"
function
receiveData
(
chunk
)
{
payload
=
Buffer
.
concat
(
[
payload
chunk
]
)
;
}
)
;
req
.
on
(
"
end
"
function
finishedData
(
)
{
processRequest
(
req
res
payload
)
;
}
)
;
}
function
processRequest
(
req
res
payload
)
{
let
packet
=
dnsPacket
.
decode
(
payload
)
;
let
answers
=
[
]
;
if
(
packet
.
questions
[
0
]
.
type
=
=
=
"
HTTPS
"
)
{
answers
.
push
(
{
name
:
packet
.
questions
[
0
]
.
name
type
:
"
HTTPS
"
ttl
:
55
class
:
"
IN
"
flush
:
false
data
:
{
priority
:
1
name
:
packet
.
questions
[
0
]
.
name
values
:
[
{
key
:
"
alpn
"
value
:
[
alpn
]
}
{
key
:
"
port
"
value
:
serverPort
}
]
}
}
)
;
}
else
if
(
packet
.
questions
[
0
]
.
type
=
=
=
"
A
"
)
{
answers
.
push
(
{
name
:
packet
.
questions
[
0
]
.
name
type
:
"
A
"
ttl
:
55
flush
:
false
data
:
"
127
.
0
.
0
.
1
"
}
)
;
}
let
buf
=
dnsPacket
.
encode
(
{
type
:
"
response
"
id
:
packet
.
id
flags
:
dnsPacket
.
RECURSION_DESIRED
questions
:
packet
.
questions
answers
}
)
;
res
.
setHeader
(
"
Content
-
Type
"
"
application
/
dns
-
message
"
)
;
res
.
setHeader
(
"
Content
-
Length
"
buf
.
length
)
;
res
.
writeHead
(
200
)
;
res
.
write
(
buf
)
;
res
.
end
(
"
"
)
;
}
}
)
;
server
.
listen
(
listeningPort
)
;
console
.
log
(
DoH
server
listening
on
ports
{
server
.
address
(
)
.
port
}
)
;
