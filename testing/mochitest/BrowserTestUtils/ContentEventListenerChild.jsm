"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ContentEventListenerChild
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
class
ContentEventListenerChild
extends
JSWindowActorChild
{
actorCreated
(
)
{
this
.
_contentEvents
=
new
Map
(
)
;
this
.
_shutdown
=
false
;
this
.
_chromeEventHandler
=
null
;
Services
.
cpmm
.
sharedData
.
addEventListener
(
"
change
"
this
)
;
}
willDestroy
(
)
{
this
.
_shutdown
=
true
;
Services
.
cpmm
.
sharedData
.
removeEventListener
(
"
change
"
this
)
;
this
.
_updateContentEventListeners
(
true
)
;
if
(
this
.
_contentEvents
.
size
!
=
0
)
{
throw
new
Error
(
Didn
'
t
expect
content
events
after
willDestroy
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
DOMWindowCreated
"
:
{
this
.
_updateContentEventListeners
(
)
;
break
;
}
case
"
change
"
:
{
if
(
!
event
.
changedKeys
.
includes
(
"
BrowserTestUtils
:
ContentEventListener
"
)
)
{
return
;
}
this
.
_updateContentEventListeners
(
)
;
break
;
}
}
}
_updateContentEventListeners
(
clearListeners
=
false
)
{
if
(
this
.
_shutdown
&
&
!
clearListeners
)
{
throw
new
Error
(
"
Tried
to
update
after
we
shut
down
content
event
listening
"
)
;
}
let
newEventData
;
if
(
!
clearListeners
)
{
newEventData
=
Services
.
cpmm
.
sharedData
.
get
(
"
BrowserTestUtils
:
ContentEventListener
"
)
;
}
if
(
!
newEventData
)
{
newEventData
=
new
Map
(
)
;
}
for
(
let
[
listenerId
{
eventName
listener
listenerOptions
}
]
of
this
.
_contentEvents
.
entries
(
)
)
{
let
newData
=
newEventData
.
get
(
listenerId
)
;
if
(
newData
)
{
if
(
newData
.
eventName
!
=
=
eventName
)
{
throw
new
Error
(
"
Got
new
content
event
listener
that
disagreed
with
existing
data
"
)
;
}
continue
;
}
if
(
!
this
.
_chromeEventHandler
)
{
throw
new
Error
(
"
Trying
to
remove
an
event
listener
for
waitForContentEvent
without
a
cached
event
handler
"
)
;
}
this
.
_chromeEventHandler
.
removeEventListener
(
eventName
listener
listenerOptions
)
;
this
.
_contentEvents
.
delete
(
listenerId
)
;
}
let
actorChild
=
this
;
for
(
let
[
listenerId
{
eventName
listenerOptions
checkFnSource
}
]
of
newEventData
.
entries
(
)
)
{
let
oldData
=
this
.
_contentEvents
.
get
(
listenerId
)
;
if
(
oldData
)
{
continue
;
}
let
checkFn
;
if
(
checkFnSource
)
{
checkFn
=
eval
(
(
(
)
=
>
(
{
unescape
(
checkFnSource
)
}
)
)
(
)
)
;
}
function
listener
(
event
)
{
if
(
checkFn
&
&
!
checkFn
(
event
)
)
{
return
;
}
actorChild
.
sendAsyncMessage
(
"
ContentEventListener
:
Run
"
{
listenerId
}
)
;
}
if
(
!
this
.
_chromeEventHandler
)
{
try
{
this
.
_chromeEventHandler
=
this
.
docShell
.
chromeEventHandler
;
}
catch
(
error
)
{
if
(
error
.
name
=
=
=
"
InvalidStateError
"
)
{
continue
;
}
throw
error
;
}
}
if
(
!
this
.
_chromeEventHandler
)
{
continue
;
}
this
.
_chromeEventHandler
.
addEventListener
(
eventName
listener
listenerOptions
)
;
this
.
_contentEvents
.
set
(
listenerId
{
eventName
listener
listenerOptions
}
)
;
}
if
(
this
.
_contentEvents
.
size
=
=
0
)
{
this
.
_chromeEventHandler
=
null
;
}
}
}
