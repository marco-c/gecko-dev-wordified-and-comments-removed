"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserTestUtils
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
ComponentUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ComponentUtils
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
TestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
ContentTask
:
"
resource
:
/
/
testing
-
common
/
ContentTask
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
lazy
{
ProtocolProxyService
:
[
"
mozilla
.
org
/
network
/
protocol
-
proxy
-
service
;
1
"
"
nsIProtocolProxyService
"
]
}
)
;
const
PROCESSSELECTOR_CONTRACTID
=
"
mozilla
.
org
/
ipc
/
processselector
;
1
"
;
const
OUR_PROCESSSELECTOR_CID
=
Components
.
ID
(
"
{
f9746211
-
3d53
-
4465
-
9aeb
-
ca0d96de0253
}
"
)
;
const
EXISTING_JSID
=
Cc
[
PROCESSSELECTOR_CONTRACTID
]
;
const
DEFAULT_PROCESSSELECTOR_CID
=
EXISTING_JSID
?
Components
.
ID
(
EXISTING_JSID
.
number
)
:
null
;
let
gListenerId
=
0
;
function
NewProcessSelector
(
)
{
}
NewProcessSelector
.
prototype
=
{
classID
:
OUR_PROCESSSELECTOR_CID
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIContentProcessProvider
"
]
)
provideProcess
(
)
{
return
Ci
.
nsIContentProcessProvider
.
NEW_PROCESS
;
}
}
;
let
registrar
=
Components
.
manager
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
let
selectorFactory
=
ComponentUtils
.
_getFactory
(
NewProcessSelector
)
;
registrar
.
registerFactory
(
OUR_PROCESSSELECTOR_CID
"
"
null
selectorFactory
)
;
const
kAboutPageRegistrationContentScript
=
"
chrome
:
/
/
mochikit
/
content
/
tests
/
BrowserTestUtils
/
content
-
about
-
page
-
utils
.
js
"
;
function
registerActors
(
)
{
ChromeUtils
.
registerWindowActor
(
"
BrowserTestUtils
"
{
parent
:
{
moduleURI
:
"
resource
:
/
/
testing
-
common
/
BrowserTestUtilsParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
testing
-
common
/
BrowserTestUtilsChild
.
jsm
"
events
:
{
DOMContentLoaded
:
{
capture
:
true
}
load
:
{
capture
:
true
}
}
}
allFrames
:
true
includeChrome
:
true
}
)
;
ChromeUtils
.
registerWindowActor
(
"
ContentEventListener
"
{
parent
:
{
moduleURI
:
"
resource
:
/
/
testing
-
common
/
ContentEventListenerParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
testing
-
common
/
ContentEventListenerChild
.
jsm
"
events
:
{
DOMWindowCreated
:
{
capture
:
true
}
}
}
allFrames
:
true
}
)
;
}
registerActors
(
)
;
var
BrowserTestUtils
=
{
async
withNewTab
(
options
taskFn
)
{
if
(
typeof
options
=
=
"
string
"
)
{
options
=
{
gBrowser
:
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
.
gBrowser
url
:
options
}
;
}
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
options
)
;
let
originalWindow
=
tab
.
ownerGlobal
;
let
result
=
await
taskFn
(
tab
.
linkedBrowser
)
;
let
finalWindow
=
tab
.
ownerGlobal
;
if
(
originalWindow
=
=
finalWindow
&
&
!
tab
.
closing
&
&
tab
.
linkedBrowser
)
{
await
TestUtils
.
waitForTick
(
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
else
{
Services
.
console
.
logStringMessage
(
"
BrowserTestUtils
.
withNewTab
:
Tab
was
already
closed
before
"
+
"
removeTab
would
have
been
called
"
)
;
}
return
Promise
.
resolve
(
result
)
;
}
openNewForegroundTab
(
tabbrowser
.
.
.
args
)
{
let
startTime
=
Cu
.
now
(
)
;
let
options
;
if
(
tabbrowser
.
ownerGlobal
&
&
tabbrowser
=
=
=
tabbrowser
.
ownerGlobal
.
gBrowser
)
{
let
[
opening
=
"
about
:
blank
"
waitForLoad
=
true
waitForStateStop
=
false
forceNewProcess
=
false
]
=
args
;
options
=
{
opening
waitForLoad
waitForStateStop
forceNewProcess
}
;
}
else
{
if
(
"
url
"
in
tabbrowser
&
&
!
(
"
opening
"
in
tabbrowser
)
)
{
tabbrowser
.
opening
=
tabbrowser
.
url
;
}
let
{
opening
=
"
about
:
blank
"
waitForLoad
=
true
waitForStateStop
=
false
forceNewProcess
=
false
}
=
tabbrowser
;
tabbrowser
=
tabbrowser
.
gBrowser
;
options
=
{
opening
waitForLoad
waitForStateStop
forceNewProcess
}
;
}
let
{
opening
:
opening
waitForLoad
:
aWaitForLoad
waitForStateStop
:
aWaitForStateStop
}
=
options
;
let
promises
tab
;
try
{
if
(
options
.
forceNewProcess
&
&
DEFAULT_PROCESSSELECTOR_CID
)
{
Services
.
ppmm
.
releaseCachedProcesses
(
)
;
registrar
.
registerFactory
(
OUR_PROCESSSELECTOR_CID
"
"
PROCESSSELECTOR_CONTRACTID
null
)
;
}
promises
=
[
BrowserTestUtils
.
switchTab
(
tabbrowser
function
(
)
{
if
(
typeof
opening
=
=
"
function
"
)
{
opening
(
)
;
tab
=
tabbrowser
.
selectedTab
;
}
else
{
tabbrowser
.
selectedTab
=
tab
=
BrowserTestUtils
.
addTab
(
tabbrowser
opening
)
;
}
}
)
]
;
if
(
aWaitForLoad
)
{
promises
.
push
(
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
)
;
}
if
(
aWaitForStateStop
)
{
promises
.
push
(
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
)
)
;
}
}
finally
{
if
(
options
.
forceNewProcess
&
&
DEFAULT_PROCESSSELECTOR_CID
)
{
registrar
.
registerFactory
(
DEFAULT_PROCESSSELECTOR_CID
"
"
PROCESSSELECTOR_CONTRACTID
null
)
;
}
}
return
Promise
.
all
(
promises
)
.
then
(
(
)
=
>
{
let
{
innerWindowId
}
=
tabbrowser
.
ownerGlobal
.
windowGlobalChild
;
ChromeUtils
.
addProfilerMarker
(
"
BrowserTestUtils
"
{
startTime
category
:
"
Test
"
innerWindowId
}
"
openNewForegroundTab
"
)
;
return
tab
;
}
)
;
}
is_hidden
(
element
)
{
var
style
=
element
.
ownerGlobal
.
getComputedStyle
(
element
)
;
if
(
style
.
display
=
=
"
none
"
)
{
return
true
;
}
if
(
style
.
visibility
!
=
"
visible
"
)
{
return
true
;
}
if
(
style
.
display
=
=
"
-
moz
-
popup
"
)
{
return
[
"
hiding
"
"
closed
"
]
.
includes
(
element
.
state
)
;
}
if
(
element
.
parentNode
!
=
element
.
ownerDocument
)
{
return
BrowserTestUtils
.
is_hidden
(
element
.
parentNode
)
;
}
return
false
;
}
is_visible
(
element
)
{
var
style
=
element
.
ownerGlobal
.
getComputedStyle
(
element
)
;
if
(
style
.
display
=
=
"
none
"
)
{
return
false
;
}
if
(
style
.
visibility
!
=
"
visible
"
)
{
return
false
;
}
if
(
style
.
display
=
=
"
-
moz
-
popup
"
&
&
element
.
state
!
=
"
open
"
)
{
return
false
;
}
if
(
element
.
parentNode
!
=
element
.
ownerDocument
)
{
return
BrowserTestUtils
.
is_visible
(
element
.
parentNode
)
;
}
return
true
;
}
getBrowsingContextFrom
(
browser
)
{
if
(
Element
.
isInstance
(
browser
)
)
{
return
browser
.
browsingContext
;
}
return
browser
;
}
switchTab
(
tabbrowser
tab
)
{
let
startTime
=
Cu
.
now
(
)
;
let
{
innerWindowId
}
=
tabbrowser
.
ownerGlobal
.
windowGlobalChild
;
let
promise
=
new
Promise
(
resolve
=
>
{
tabbrowser
.
addEventListener
(
"
TabSwitchDone
"
function
(
)
{
TestUtils
.
executeSoon
(
(
)
=
>
{
ChromeUtils
.
addProfilerMarker
(
"
BrowserTestUtils
"
{
category
:
"
Test
"
startTime
innerWindowId
}
"
switchTab
"
)
;
resolve
(
tabbrowser
.
selectedTab
)
;
}
)
;
}
{
once
:
true
}
)
;
}
)
;
if
(
typeof
tab
=
=
"
function
"
)
{
tab
(
)
;
}
else
{
tabbrowser
.
selectedTab
=
tab
;
}
return
promise
;
}
browserLoaded
(
browser
includeSubFrames
=
false
wantLoad
=
null
maybeErrorPage
=
false
)
{
let
startTime
=
Cu
.
now
(
)
;
let
{
innerWindowId
}
=
browser
.
ownerGlobal
.
windowGlobalChild
;
if
(
includeSubFrames
&
&
typeof
includeSubFrames
!
=
"
boolean
"
)
{
throw
new
Error
(
"
The
second
argument
to
browserLoaded
should
be
a
boolean
.
"
)
;
}
let
tabbrowser
=
browser
.
ownerGlobal
.
gBrowser
;
if
(
tabbrowser
&
&
tabbrowser
.
getTabForBrowser
)
{
let
tab
=
tabbrowser
.
getTabForBrowser
(
browser
)
;
if
(
tab
)
{
tabbrowser
.
_insertBrowser
(
tab
)
;
}
}
function
isWanted
(
url
)
{
if
(
!
wantLoad
)
{
return
true
;
}
else
if
(
typeof
wantLoad
=
=
"
function
"
)
{
return
wantLoad
(
url
)
;
}
if
(
BrowserTestUtils
.
_httpsFirstEnabled
&
&
typeof
wantLoad
=
=
"
string
"
&
&
wantLoad
.
startsWith
(
"
http
:
/
/
"
)
)
{
let
wantLoadHttps
=
wantLoad
.
replace
(
"
http
:
/
/
"
"
https
:
/
/
"
)
;
if
(
wantLoadHttps
=
=
url
)
{
return
true
;
}
}
return
wantLoad
=
=
url
;
}
let
loadEvent
=
maybeErrorPage
?
"
DOMContentLoaded
"
:
"
load
"
;
let
eventName
=
BrowserTestUtils
:
ContentEvent
:
{
loadEvent
}
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
function
listener
(
event
)
{
switch
(
event
.
type
)
{
case
eventName
:
{
let
{
browsingContext
internalURL
visibleURL
}
=
event
.
detail
;
if
(
!
internalURL
)
{
return
;
}
let
subframe
=
browsingContext
!
=
=
browsingContext
.
top
;
if
(
subframe
&
&
!
includeSubFrames
)
{
return
;
}
if
(
!
isWanted
(
maybeErrorPage
?
visibleURL
:
internalURL
)
)
{
return
;
}
ChromeUtils
.
addProfilerMarker
(
"
BrowserTestUtils
"
{
startTime
category
:
"
Test
"
innerWindowId
}
"
browserLoaded
:
"
+
internalURL
)
;
resolve
(
internalURL
)
;
break
;
}
case
"
unload
"
:
reject
(
new
Error
(
"
The
window
unloaded
while
we
were
waiting
for
the
browser
to
load
-
this
should
never
happen
.
"
)
)
;
break
;
default
:
return
;
}
browser
.
removeEventListener
(
eventName
listener
true
)
;
browser
.
ownerGlobal
.
removeEventListener
(
"
unload
"
listener
)
;
}
browser
.
addEventListener
(
eventName
listener
true
)
;
browser
.
ownerGlobal
.
addEventListener
(
"
unload
"
listener
)
;
}
)
;
}
firstBrowserLoaded
(
win
aboutBlank
=
true
checkFn
=
null
)
{
return
this
.
waitForEvent
(
win
"
BrowserTestUtils
:
ContentEvent
:
load
"
true
event
=
>
{
if
(
checkFn
)
{
return
checkFn
(
event
.
target
)
;
}
return
(
win
.
gBrowser
.
selectedBrowser
.
currentURI
.
spec
!
=
=
"
about
:
blank
"
|
|
aboutBlank
)
;
}
)
;
}
_webProgressListeners
:
new
Set
(
)
_contentEventListenerSharedState
:
new
Map
(
)
_contentEventListeners
:
new
Map
(
)
waitForBrowserStateChange
(
browser
expectedURI
checkFn
)
{
return
new
Promise
(
resolve
=
>
{
let
wpl
=
{
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
dump
(
"
Saw
state
"
+
aStateFlags
.
toString
(
16
)
+
"
and
status
"
+
aStatus
.
toString
(
16
)
+
"
\
n
"
)
;
if
(
checkFn
(
aStateFlags
aStatus
)
&
&
aWebProgress
.
isTopLevel
)
{
let
chan
=
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
dump
(
"
Browser
got
expected
state
change
"
+
chan
.
originalURI
.
spec
+
"
\
n
"
)
;
if
(
!
expectedURI
|
|
chan
.
originalURI
.
spec
=
=
expectedURI
)
{
browser
.
removeProgressListener
(
wpl
)
;
BrowserTestUtils
.
_webProgressListeners
.
delete
(
wpl
)
;
resolve
(
)
;
}
}
}
onSecurityChange
(
)
{
}
onStatusChange
(
)
{
}
onLocationChange
(
)
{
}
onContentBlockingEvent
(
)
{
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsIWebProgressListener2
"
"
nsISupportsWeakReference
"
]
)
}
;
browser
.
addProgressListener
(
wpl
)
;
this
.
_webProgressListeners
.
add
(
wpl
)
;
dump
(
"
Waiting
for
browser
state
change
"
+
(
expectedURI
?
"
of
"
+
expectedURI
:
"
"
)
+
"
\
n
"
)
;
}
)
;
}
browserStopped
(
browser
expectedURI
checkAborts
=
false
)
{
let
testFn
=
function
(
aStateFlags
aStatus
)
{
return
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
&
&
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
(
checkAborts
|
|
aStatus
!
=
Cr
.
NS_BINDING_ABORTED
)
)
;
}
;
dump
(
"
Waiting
for
browser
load
"
+
(
expectedURI
?
"
of
"
+
expectedURI
:
"
"
)
+
"
\
n
"
)
;
return
BrowserTestUtils
.
waitForBrowserStateChange
(
browser
expectedURI
testFn
)
;
}
browserStarted
(
browser
expectedURI
)
{
let
testFn
=
function
(
aStateFlags
aStatus
)
{
return
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
&
&
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
;
}
;
dump
(
"
Waiting
for
browser
to
start
load
"
+
(
expectedURI
?
"
of
"
+
expectedURI
:
"
"
)
+
"
\
n
"
)
;
return
BrowserTestUtils
.
waitForBrowserStateChange
(
browser
expectedURI
testFn
)
;
}
waitForNewTab
(
tabbrowser
wantLoad
=
null
waitForLoad
=
false
waitForAnyTab
=
false
)
{
let
urlMatches
;
if
(
wantLoad
&
&
typeof
wantLoad
=
=
"
function
"
)
{
urlMatches
=
wantLoad
;
}
else
if
(
wantLoad
)
{
urlMatches
=
urlToMatch
=
>
urlToMatch
=
=
wantLoad
;
}
else
{
urlMatches
=
urlToMatch
=
>
urlToMatch
!
=
"
about
:
blank
"
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
tabbrowser
.
tabContainer
.
addEventListener
(
"
TabOpen
"
function
tabOpenListener
(
openEvent
)
{
if
(
!
waitForAnyTab
)
{
tabbrowser
.
tabContainer
.
removeEventListener
(
"
TabOpen
"
tabOpenListener
)
;
}
let
newTab
=
openEvent
.
target
;
let
newBrowser
=
newTab
.
linkedBrowser
;
let
result
;
if
(
waitForLoad
)
{
result
=
BrowserTestUtils
.
browserLoaded
(
newBrowser
false
urlMatches
)
.
then
(
(
)
=
>
newTab
)
;
}
else
{
result
=
newTab
;
}
let
progressListener
=
{
onLocationChange
(
aBrowser
)
{
if
(
aBrowser
!
=
newBrowser
)
{
return
;
}
if
(
!
urlMatches
(
aBrowser
.
currentURI
.
spec
)
)
{
return
;
}
if
(
waitForAnyTab
)
{
tabbrowser
.
tabContainer
.
removeEventListener
(
"
TabOpen
"
tabOpenListener
)
;
}
tabbrowser
.
removeTabsProgressListener
(
progressListener
)
;
TestUtils
.
executeSoon
(
(
)
=
>
resolve
(
result
)
)
;
}
}
;
tabbrowser
.
addTabsProgressListener
(
progressListener
)
;
}
)
;
}
)
;
}
waitForLocationChange
(
tabbrowser
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
progressListener
=
{
onLocationChange
(
aBrowser
aWebProgress
aRequest
aLocationURI
aFlags
)
{
if
(
(
url
&
&
aLocationURI
.
spec
!
=
url
)
|
|
(
!
url
&
&
aLocationURI
.
spec
=
=
"
about
:
blank
"
)
)
{
return
;
}
tabbrowser
.
removeTabsProgressListener
(
progressListener
)
;
resolve
(
)
;
}
}
;
tabbrowser
.
addTabsProgressListener
(
progressListener
)
;
}
)
;
}
waitForNewWindow
(
aParams
=
{
}
)
{
let
{
url
=
null
anyWindow
=
false
maybeErrorPage
=
false
}
=
aParams
;
if
(
anyWindow
&
&
!
url
)
{
throw
new
Error
(
"
url
should
be
specified
if
anyWindow
is
true
"
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
observe
=
async
(
win
topic
data
)
=
>
{
if
(
topic
!
=
"
domwindowopened
"
)
{
return
;
}
try
{
if
(
!
anyWindow
)
{
Services
.
ww
.
unregisterNotification
(
observe
)
;
}
let
promises
=
[
this
.
waitForEvent
(
win
"
focus
"
true
)
this
.
waitForEvent
(
win
"
activate
"
)
]
;
if
(
url
)
{
await
this
.
waitForEvent
(
win
"
DOMContentLoaded
"
)
;
if
(
win
.
document
.
documentURI
!
=
AppConstants
.
BROWSER_CHROME_URL
)
{
return
;
}
}
promises
.
push
(
TestUtils
.
topicObserved
(
"
browser
-
delayed
-
startup
-
finished
"
subject
=
>
subject
=
=
win
)
)
;
if
(
url
)
{
let
loadPromise
=
this
.
browserLoaded
(
win
.
gBrowser
.
selectedBrowser
false
url
maybeErrorPage
)
;
promises
.
push
(
loadPromise
)
;
}
await
Promise
.
all
(
promises
)
;
if
(
anyWindow
)
{
Services
.
ww
.
unregisterNotification
(
observe
)
;
}
resolve
(
win
)
;
}
catch
(
err
)
{
if
(
!
anyWindow
)
{
reject
(
err
)
;
}
}
}
;
Services
.
ww
.
registerNotification
(
observe
)
;
}
)
;
}
loadURI
(
browser
uri
)
{
browser
.
loadURI
(
uri
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
async
maybeCreatePreloadedBrowser
(
gBrowser
)
{
let
win
=
gBrowser
.
ownerGlobal
;
win
.
NewTabPagePreloading
.
maybeCreatePreloadedBrowser
(
win
)
;
await
lazy
.
ContentTask
.
spawn
(
gBrowser
.
preloadedBrowser
[
]
async
(
)
=
>
{
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
(
this
.
content
.
document
&
&
this
.
content
.
document
.
readyState
=
=
"
complete
"
)
;
}
)
;
}
)
;
}
domWindowOpened
(
win
checkFn
)
{
return
new
Promise
(
resolve
=
>
{
async
function
observer
(
subject
topic
data
)
{
if
(
topic
=
=
"
domwindowopened
"
&
&
(
!
win
|
|
subject
=
=
=
win
)
)
{
let
observedWindow
=
subject
;
if
(
checkFn
&
&
!
(
await
checkFn
(
observedWindow
)
)
)
{
return
;
}
Services
.
ww
.
unregisterNotification
(
observer
)
;
resolve
(
observedWindow
)
;
}
}
Services
.
ww
.
registerNotification
(
observer
)
;
}
)
;
}
domWindowOpenedAndLoaded
(
win
checkFn
)
{
return
this
.
domWindowOpened
(
win
async
observedWin
=
>
{
await
this
.
waitForEvent
(
observedWin
"
load
"
)
;
if
(
checkFn
&
&
!
(
await
checkFn
(
observedWin
)
)
)
{
return
false
;
}
return
true
;
}
)
;
}
domWindowClosed
(
win
)
{
return
new
Promise
(
resolve
=
>
{
function
observer
(
subject
topic
data
)
{
if
(
topic
=
=
"
domwindowclosed
"
&
&
(
!
win
|
|
subject
=
=
=
win
)
)
{
Services
.
ww
.
unregisterNotification
(
observer
)
;
resolve
(
subject
)
;
}
}
Services
.
ww
.
registerNotification
(
observer
)
;
}
)
;
}
async
openNewWindowWithFlushedCacheForMozSupports
(
options
)
{
ChromeUtils
.
clearStyleSheetCache
(
)
;
return
BrowserTestUtils
.
openNewBrowserWindow
(
options
)
;
}
async
openNewBrowserWindow
(
options
=
{
}
)
{
let
startTime
=
Cu
.
now
(
)
;
let
currentWin
=
lazy
.
BrowserWindowTracker
.
getTopWindow
(
{
private
:
false
}
)
;
if
(
!
currentWin
)
{
throw
new
Error
(
"
Can
'
t
open
a
new
browser
window
from
this
helper
if
no
non
-
private
window
is
open
.
"
)
;
}
let
win
=
currentWin
.
OpenBrowserWindow
(
options
)
;
let
promises
=
[
this
.
waitForEvent
(
win
"
focus
"
true
)
this
.
waitForEvent
(
win
"
activate
"
)
]
;
promises
.
push
(
TestUtils
.
topicObserved
(
"
browser
-
delayed
-
startup
-
finished
"
subject
=
>
subject
=
=
win
)
.
then
(
(
)
=
>
win
)
)
;
promises
.
push
(
this
.
firstBrowserLoaded
(
win
!
options
.
waitForTabURL
browser
=
>
{
return
(
!
options
.
waitForTabURL
|
|
options
.
waitForTabURL
=
=
browser
.
currentURI
.
spec
)
;
}
)
)
;
await
Promise
.
all
(
promises
)
;
ChromeUtils
.
addProfilerMarker
(
"
BrowserTestUtils
"
{
startTime
category
:
"
Test
"
}
"
openNewBrowserWindow
"
)
;
return
win
;
}
closeWindow
(
win
)
{
let
closedPromise
=
BrowserTestUtils
.
windowClosed
(
win
)
;
win
.
close
(
)
;
return
closedPromise
;
}
windowClosed
(
win
)
{
let
domWinClosedPromise
=
BrowserTestUtils
.
domWindowClosed
(
win
)
;
let
promises
=
[
domWinClosedPromise
]
;
let
winType
=
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
let
flushTopic
=
"
sessionstore
-
browser
-
shutdown
-
flush
"
;
if
(
winType
=
=
"
navigator
:
browser
"
)
{
let
finalMsgsPromise
=
new
Promise
(
resolve
=
>
{
let
browserSet
=
new
Set
(
win
.
gBrowser
.
browsers
)
;
browserSet
.
forEach
(
browser
=
>
{
win
.
gBrowser
.
_insertBrowser
(
win
.
gBrowser
.
getTabForBrowser
(
browser
)
)
;
}
)
;
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
browserSet
.
has
(
subject
)
)
{
browserSet
.
delete
(
subject
)
;
}
if
(
!
browserSet
.
size
)
{
Services
.
obs
.
removeObserver
(
observer
flushTopic
)
;
TestUtils
.
executeSoon
(
resolve
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
flushTopic
)
;
}
)
;
promises
.
push
(
finalMsgsPromise
)
;
}
return
Promise
.
all
(
promises
)
;
}
waitForSessionStoreUpdate
(
tab
)
{
return
new
Promise
(
resolve
=
>
{
let
browser
=
tab
.
linkedBrowser
;
let
flushTopic
=
"
sessionstore
-
browser
-
shutdown
-
flush
"
;
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
subject
=
=
=
browser
)
{
Services
.
obs
.
removeObserver
(
observer
flushTopic
)
;
TestUtils
.
executeSoon
(
(
)
=
>
resolve
(
)
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
flushTopic
)
;
}
)
;
}
waitForEvent
(
subject
eventName
capture
checkFn
wantsUntrusted
)
{
let
startTime
=
Cu
.
now
(
)
;
let
innerWindowId
=
subject
.
ownerGlobal
?
.
windowGlobalChild
.
innerWindowId
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
removed
=
false
;
function
listener
(
event
)
{
function
cleanup
(
)
{
removed
=
true
;
subject
=
null
;
checkFn
=
null
;
}
try
{
if
(
checkFn
&
&
!
checkFn
(
event
)
)
{
return
;
}
subject
.
removeEventListener
(
eventName
listener
capture
)
;
cleanup
(
)
;
TestUtils
.
executeSoon
(
(
)
=
>
{
ChromeUtils
.
addProfilerMarker
(
"
BrowserTestUtils
"
{
startTime
category
:
"
Test
"
innerWindowId
}
"
waitForEvent
:
"
+
eventName
)
;
resolve
(
event
)
;
}
)
;
}
catch
(
ex
)
{
try
{
subject
.
removeEventListener
(
eventName
listener
capture
)
;
}
catch
(
ex2
)
{
}
cleanup
(
)
;
TestUtils
.
executeSoon
(
(
)
=
>
reject
(
ex
)
)
;
}
}
subject
.
addEventListener
(
eventName
listener
capture
wantsUntrusted
)
;
TestUtils
.
promiseTestFinished
?
.
then
(
(
)
=
>
{
if
(
removed
)
{
return
;
}
subject
.
removeEventListener
(
eventName
listener
capture
)
;
let
text
=
eventName
+
"
listener
"
;
if
(
subject
.
id
)
{
text
+
=
on
#
{
subject
.
id
}
;
}
text
+
=
"
not
removed
before
the
end
of
test
"
;
reject
(
text
)
;
ChromeUtils
.
addProfilerMarker
(
"
BrowserTestUtils
"
{
startTime
category
:
"
Test
"
innerWindowId
}
"
waitForEvent
:
"
+
text
)
;
}
)
;
}
)
;
}
waitForContentEvent
(
browser
eventName
capture
=
false
checkFn
wantUntrusted
=
false
)
{
return
new
Promise
(
resolve
=
>
{
let
removeEventListener
=
this
.
addContentEventListener
(
browser
eventName
(
)
=
>
{
removeEventListener
(
)
;
resolve
(
eventName
)
;
}
{
capture
wantUntrusted
}
checkFn
)
;
}
)
;
}
waitForPopupEvent
(
popup
eventSuffix
)
{
let
endState
=
{
shown
:
"
open
"
hidden
:
"
closed
"
}
[
eventSuffix
]
;
if
(
popup
.
state
=
=
endState
)
{
return
Promise
.
resolve
(
)
;
}
return
this
.
waitForEvent
(
popup
"
popup
"
+
eventSuffix
)
;
}
async
waitForSelectPopupShown
(
win
)
{
let
getMenulist
=
(
)
=
>
win
.
document
.
getElementById
(
"
ContentSelectDropdown
"
)
;
let
menulist
=
getMenulist
(
)
;
if
(
!
menulist
)
{
await
this
.
waitForMutationCondition
(
win
.
document
{
childList
:
true
subtree
:
true
}
getMenulist
)
;
menulist
=
getMenulist
(
)
;
if
(
menulist
.
menupopup
.
state
=
=
"
open
"
)
{
return
menulist
.
menupopup
;
}
}
await
this
.
waitForEvent
(
menulist
.
menupopup
"
popupshown
"
)
;
return
menulist
.
menupopup
;
}
addContentEventListener
(
browser
eventName
listener
listenerOptions
=
{
}
checkFn
)
{
let
id
=
gListenerId
+
+
;
let
contentEventListeners
=
this
.
_contentEventListeners
;
contentEventListeners
.
set
(
id
{
listener
browserId
:
browser
.
browserId
}
)
;
let
eventListenerState
=
this
.
_contentEventListenerSharedState
;
eventListenerState
.
set
(
id
{
eventName
listenerOptions
checkFnSource
:
checkFn
?
checkFn
.
toSource
(
)
:
"
"
}
)
;
Services
.
ppmm
.
sharedData
.
set
(
"
BrowserTestUtils
:
ContentEventListener
"
eventListenerState
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
let
unregisterFunction
=
function
(
)
{
if
(
!
eventListenerState
.
has
(
id
)
)
{
return
;
}
eventListenerState
.
delete
(
id
)
;
contentEventListeners
.
delete
(
id
)
;
Services
.
ppmm
.
sharedData
.
set
(
"
BrowserTestUtils
:
ContentEventListener
"
eventListenerState
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
}
;
return
unregisterFunction
;
}
_receivedContentEventListener
(
listenerId
browserId
)
{
let
listenerData
=
this
.
_contentEventListeners
.
get
(
listenerId
)
;
if
(
!
listenerData
)
{
return
;
}
if
(
listenerData
.
browserId
!
=
browserId
)
{
return
;
}
listenerData
.
listener
(
)
;
}
_cleanupContentEventListeners
(
)
{
this
.
_contentEventListeners
.
clear
(
)
;
if
(
this
.
_contentEventListenerSharedState
.
size
!
=
0
)
{
this
.
_contentEventListenerSharedState
.
clear
(
)
;
Services
.
ppmm
.
sharedData
.
set
(
"
BrowserTestUtils
:
ContentEventListener
"
this
.
_contentEventListenerSharedState
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
}
if
(
this
.
_contentEventListenerActorRegistered
)
{
this
.
_contentEventListenerActorRegistered
=
false
;
ChromeUtils
.
unregisterWindowActor
(
"
ContentEventListener
"
)
;
}
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
test
-
complete
"
:
this
.
_cleanupContentEventListeners
(
)
;
break
;
}
}
waitForMutationCondition
(
target
options
checkFn
)
{
if
(
checkFn
(
)
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
let
obs
=
new
target
.
ownerGlobal
.
MutationObserver
(
function
(
)
{
if
(
checkFn
(
)
)
{
obs
.
disconnect
(
)
;
resolve
(
)
;
}
}
)
;
obs
.
observe
(
target
options
)
;
}
)
;
}
waitForErrorPage
(
browser
)
{
return
this
.
waitForContentEvent
(
browser
"
AboutNetErrorLoad
"
false
null
true
)
;
}
waitForDocLoadAndStopIt
(
expectedURL
browser
checkFn
)
{
let
isHttp
=
url
=
>
/
^
https
?
:
/
.
test
(
url
)
;
return
new
Promise
(
resolve
=
>
{
let
proxyFilter
;
if
(
!
isHttp
(
expectedURL
)
)
{
proxyFilter
=
{
proxyInfo
:
lazy
.
ProtocolProxyService
.
newProxyInfo
(
"
http
"
"
mochi
.
test
"
8888
"
"
"
"
0
4096
null
)
applyFilter
(
channel
defaultProxyInfo
callback
)
{
callback
.
onProxyFilterResult
(
isHttp
(
channel
.
URI
.
spec
)
?
defaultProxyInfo
:
this
.
proxyInfo
)
;
}
}
;
lazy
.
ProtocolProxyService
.
registerChannelFilter
(
proxyFilter
0
)
;
}
function
observer
(
chan
)
{
chan
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
!
chan
.
originalURI
|
|
chan
.
originalURI
.
spec
!
=
=
expectedURL
)
{
return
;
}
if
(
checkFn
&
&
!
checkFn
(
chan
)
)
{
return
;
}
try
{
chan
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
}
finally
{
if
(
proxyFilter
)
{
lazy
.
ProtocolProxyService
.
unregisterChannelFilter
(
proxyFilter
)
;
}
Services
.
obs
.
removeObserver
(
observer
"
http
-
on
-
before
-
connect
"
)
;
resolve
(
)
;
}
}
Services
.
obs
.
addObserver
(
observer
"
http
-
on
-
before
-
connect
"
)
;
}
)
;
}
synthesizeMouse
(
target
offsetX
offsetY
event
browsingContext
handlingUserInput
)
{
let
targetFn
=
null
;
if
(
typeof
target
=
=
"
function
"
)
{
targetFn
=
target
.
toString
(
)
;
target
=
null
;
}
else
if
(
typeof
target
!
=
"
string
"
&
&
!
Array
.
isArray
(
target
)
)
{
target
=
null
;
}
browsingContext
=
this
.
getBrowsingContextFrom
(
browsingContext
)
;
return
this
.
sendQuery
(
browsingContext
"
Test
:
SynthesizeMouse
"
{
target
targetFn
x
:
offsetX
y
:
offsetY
event
handlingUserInput
}
)
;
}
synthesizeTouch
(
target
offsetX
offsetY
event
browsingContext
)
{
let
targetFn
=
null
;
if
(
typeof
target
=
=
"
function
"
)
{
targetFn
=
target
.
toString
(
)
;
target
=
null
;
}
else
if
(
typeof
target
!
=
"
string
"
&
&
!
Array
.
isArray
(
target
)
)
{
target
=
null
;
}
browsingContext
=
this
.
getBrowsingContextFrom
(
browsingContext
)
;
return
this
.
sendQuery
(
browsingContext
"
Test
:
SynthesizeTouch
"
{
target
targetFn
x
:
offsetX
y
:
offsetY
event
}
)
;
}
waitForMessage
(
messageManager
message
checkFn
)
{
return
new
Promise
(
resolve
=
>
{
messageManager
.
addMessageListener
(
message
function
onMessage
(
msg
)
{
if
(
!
checkFn
|
|
checkFn
(
msg
)
)
{
messageManager
.
removeMessageListener
(
message
onMessage
)
;
resolve
(
msg
.
data
)
;
}
}
)
;
}
)
;
}
synthesizeMouseAtCenter
(
target
event
browsingContext
)
{
event
.
centered
=
true
;
return
BrowserTestUtils
.
synthesizeMouse
(
target
0
0
event
browsingContext
)
;
}
synthesizeMouseAtPoint
(
offsetX
offsetY
event
browsingContext
)
{
return
BrowserTestUtils
.
synthesizeMouse
(
null
offsetX
offsetY
event
browsingContext
)
;
}
removeTab
(
tab
options
=
{
}
)
{
tab
.
ownerGlobal
.
gBrowser
.
removeTab
(
tab
options
)
;
}
waitForTabClosing
(
tab
)
{
return
this
.
waitForEvent
(
tab
"
TabClose
"
)
;
}
reloadTab
(
tab
includeSubFrames
=
false
)
{
const
finished
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
includeSubFrames
)
;
tab
.
ownerGlobal
.
gBrowser
.
reloadTab
(
tab
)
;
return
finished
;
}
async
crashFrame
(
browser
shouldShowTabCrashPage
=
true
shouldClearMinidumps
=
true
browsingContext
options
=
{
}
)
{
let
extra
=
{
}
;
if
(
!
browser
.
isRemoteBrowser
)
{
throw
new
Error
(
"
<
xul
:
browser
>
needs
to
be
remote
in
order
to
crash
"
)
;
}
function
getMinidumpDirectory
(
)
{
let
dir
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
dir
.
append
(
"
minidumps
"
)
;
return
dir
;
}
function
removeFile
(
directory
filename
)
{
let
file
=
directory
.
clone
(
)
;
file
.
append
(
filename
)
;
if
(
file
.
exists
(
)
)
{
file
.
remove
(
false
)
;
}
}
let
expectedPromises
=
[
]
;
let
crashCleanupPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
topic
!
=
"
ipc
:
content
-
shutdown
"
)
{
reject
(
"
Received
incorrect
observer
topic
:
"
+
topic
)
;
return
;
}
if
(
!
(
subject
instanceof
Ci
.
nsIPropertyBag2
)
)
{
reject
(
"
Subject
did
not
implement
nsIPropertyBag2
"
)
;
return
;
}
if
(
!
subject
.
hasKey
(
"
abnormal
"
)
)
{
dump
(
"
\
nThis
is
a
normal
termination
and
isn
'
t
the
one
we
are
looking
for
.
.
.
\
n
"
)
;
return
;
}
Services
.
obs
.
removeObserver
(
observer
"
ipc
:
content
-
shutdown
"
)
;
let
dumpID
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
dumpID
=
subject
.
getPropertyAsAString
(
"
dumpID
"
)
;
if
(
!
dumpID
)
{
reject
(
"
dumpID
was
not
present
despite
crash
reporting
being
enabled
"
)
;
return
;
}
}
let
removalPromise
=
Promise
.
resolve
(
)
;
if
(
dumpID
)
{
removalPromise
=
Services
.
crashmanager
.
ensureCrashIsPresent
(
dumpID
)
.
then
(
async
(
)
=
>
{
let
minidumpDirectory
=
getMinidumpDirectory
(
)
;
let
extrafile
=
minidumpDirectory
.
clone
(
)
;
extrafile
.
append
(
dumpID
+
"
.
extra
"
)
;
if
(
extrafile
.
exists
(
)
)
{
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
let
extradata
=
await
OS
.
File
.
read
(
extrafile
.
path
{
encoding
:
"
utf
-
8
"
}
)
;
extra
=
JSON
.
parse
(
extradata
)
;
}
else
{
dump
(
"
\
nCrashReporter
not
enabled
-
will
not
return
any
extra
data
\
n
"
)
;
}
}
else
{
dump
(
\
nNo
.
extra
file
for
dumpID
:
{
dumpID
}
\
n
)
;
}
if
(
shouldClearMinidumps
)
{
removeFile
(
minidumpDirectory
dumpID
+
"
.
dmp
"
)
;
removeFile
(
minidumpDirectory
dumpID
+
"
.
extra
"
)
;
}
}
)
;
}
removalPromise
.
then
(
(
)
=
>
{
dump
(
"
\
nCrash
cleaned
up
\
n
"
)
;
TestUtils
.
executeSoon
(
(
)
=
>
resolve
(
)
)
;
}
)
;
}
;
Services
.
obs
.
addObserver
(
observer
"
ipc
:
content
-
shutdown
"
)
;
}
)
;
expectedPromises
.
push
(
crashCleanupPromise
)
;
if
(
shouldShowTabCrashPage
)
{
expectedPromises
.
push
(
new
Promise
(
(
resolve
reject
)
=
>
{
browser
.
addEventListener
(
"
AboutTabCrashedReady
"
function
onCrash
(
)
{
browser
.
removeEventListener
(
"
AboutTabCrashedReady
"
onCrash
)
;
dump
(
"
\
nabout
:
tabcrashed
loaded
and
ready
\
n
"
)
;
resolve
(
)
;
}
false
true
)
;
}
)
)
;
}
this
.
sendAsyncMessage
(
browsingContext
|
|
browser
.
browsingContext
"
BrowserTestUtils
:
CrashFrame
"
{
crashType
:
options
.
crashType
|
|
"
"
asyncCrash
:
options
.
asyncCrash
|
|
false
}
)
;
await
Promise
.
all
(
expectedPromises
)
;
if
(
shouldShowTabCrashPage
)
{
let
gBrowser
=
browser
.
ownerGlobal
.
gBrowser
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
tab
.
getAttribute
(
"
crashed
"
)
!
=
"
true
"
)
{
throw
new
Error
(
"
Tab
should
be
marked
as
crashed
"
)
;
}
}
return
extra
;
}
simulateProcessLaunchFail
(
browser
dueToBuildIDMismatch
=
false
)
{
const
NORMAL_CRASH_TOPIC
=
"
ipc
:
content
-
shutdown
"
;
Object
.
defineProperty
(
browser
.
frameLoader
"
childID
"
{
get
:
(
)
=
>
0
}
)
;
let
sawNormalCrash
=
false
;
let
observer
=
(
subject
topic
data
)
=
>
{
sawNormalCrash
=
true
;
}
;
Services
.
obs
.
addObserver
(
observer
NORMAL_CRASH_TOPIC
)
;
Services
.
obs
.
notifyObservers
(
browser
.
frameLoader
"
oop
-
frameloader
-
crashed
"
)
;
let
eventType
=
dueToBuildIDMismatch
?
"
oop
-
browser
-
buildid
-
mismatch
"
:
"
oop
-
browser
-
crashed
"
;
let
event
=
new
browser
.
ownerGlobal
.
CustomEvent
(
eventType
{
bubbles
:
true
}
)
;
event
.
isTopFrame
=
true
;
browser
.
dispatchEvent
(
event
)
;
Services
.
obs
.
removeObserver
(
observer
NORMAL_CRASH_TOPIC
)
;
if
(
sawNormalCrash
)
{
throw
new
Error
(
Unexpectedly
saw
{
NORMAL_CRASH_TOPIC
}
)
;
}
return
new
Promise
(
resolve
=
>
TestUtils
.
executeSoon
(
resolve
)
)
;
}
waitForAttribute
(
attr
element
value
)
{
let
MutationObserver
=
element
.
ownerGlobal
.
MutationObserver
;
return
new
Promise
(
resolve
=
>
{
let
mut
=
new
MutationObserver
(
mutations
=
>
{
if
(
(
!
value
&
&
element
.
hasAttribute
(
attr
)
)
|
|
(
value
&
&
element
.
getAttribute
(
attr
)
=
=
=
value
)
)
{
resolve
(
)
;
mut
.
disconnect
(
)
;
}
}
)
;
mut
.
observe
(
element
{
attributeFilter
:
[
attr
]
}
)
;
}
)
;
}
waitForAttributeRemoval
(
attr
element
)
{
if
(
!
element
.
hasAttribute
(
attr
)
)
{
return
Promise
.
resolve
(
)
;
}
let
MutationObserver
=
element
.
ownerGlobal
.
MutationObserver
;
return
new
Promise
(
resolve
=
>
{
dump
(
"
Waiting
for
removal
\
n
"
)
;
let
mut
=
new
MutationObserver
(
mutations
=
>
{
if
(
!
element
.
hasAttribute
(
attr
)
)
{
resolve
(
)
;
mut
.
disconnect
(
)
;
}
}
)
;
mut
.
observe
(
element
{
attributeFilter
:
[
attr
]
}
)
;
}
)
;
}
sendChar
(
char
browsingContext
)
{
browsingContext
=
this
.
getBrowsingContextFrom
(
browsingContext
)
;
return
this
.
sendQuery
(
browsingContext
"
Test
:
SendChar
"
{
char
}
)
;
}
synthesizeKey
(
key
event
browsingContext
)
{
browsingContext
=
this
.
getBrowsingContextFrom
(
browsingContext
)
;
return
this
.
sendQuery
(
browsingContext
"
Test
:
SynthesizeKey
"
{
key
event
}
)
;
}
synthesizeComposition
(
event
browsingContext
)
{
browsingContext
=
this
.
getBrowsingContextFrom
(
browsingContext
)
;
return
this
.
sendQuery
(
browsingContext
"
Test
:
SynthesizeComposition
"
{
event
}
)
;
}
synthesizeCompositionChange
(
event
browsingContext
)
{
browsingContext
=
this
.
getBrowsingContextFrom
(
browsingContext
)
;
return
this
.
sendQuery
(
browsingContext
"
Test
:
SynthesizeCompositionChange
"
{
event
}
)
;
}
waitForCondition
:
TestUtils
.
waitForCondition
waitForNotificationBar
(
tabbrowser
browser
notificationValue
)
{
let
notificationBox
=
tabbrowser
.
getNotificationBox
(
browser
)
;
return
this
.
waitForNotificationInNotificationBox
(
notificationBox
notificationValue
)
;
}
waitForGlobalNotificationBar
(
win
notificationValue
)
{
return
this
.
waitForNotificationInNotificationBox
(
win
.
gNotificationBox
notificationValue
)
;
}
waitForNotificationInNotificationBox
(
notificationBox
notificationValue
)
{
return
new
Promise
(
resolve
=
>
{
let
check
=
event
=
>
{
return
event
.
target
.
getAttribute
(
"
value
"
)
=
=
notificationValue
;
}
;
BrowserTestUtils
.
waitForEvent
(
notificationBox
.
stack
"
AlertActive
"
false
check
)
.
then
(
event
=
>
{
resolve
(
event
.
originalTarget
)
;
}
)
;
}
)
;
}
waitForTransition
(
element
timeout
=
5000
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
cleanup
=
(
)
=
>
{
element
.
removeEventListener
(
"
transitionrun
"
listener
)
;
element
.
removeEventListener
(
"
transitionend
"
listener
)
;
}
;
let
timer
=
element
.
ownerGlobal
.
setTimeout
(
(
)
=
>
{
cleanup
(
)
;
reject
(
)
;
}
timeout
)
;
let
transitionCount
=
0
;
let
listener
=
event
=
>
{
if
(
event
.
type
=
=
"
transitionrun
"
)
{
transitionCount
+
+
;
}
else
{
transitionCount
-
-
;
if
(
transitionCount
=
=
0
)
{
cleanup
(
)
;
element
.
ownerGlobal
.
clearTimeout
(
timer
)
;
resolve
(
)
;
}
}
}
;
element
.
addEventListener
(
"
transitionrun
"
listener
)
;
element
.
addEventListener
(
"
transitionend
"
listener
)
;
element
.
addEventListener
(
"
transitioncancel
"
listener
)
;
}
)
;
}
_knownAboutPages
:
new
Set
(
)
_loadedAboutContentScript
:
false
registerAboutPage
(
registerCleanupFunction
aboutModule
pageURI
flags
)
{
const
kRegistrationMsgId
=
"
browser
-
test
-
utils
:
about
-
registration
:
registered
"
;
let
rv
=
this
.
waitForMessage
(
Services
.
ppmm
kRegistrationMsgId
msg
=
>
{
return
msg
.
data
=
=
aboutModule
;
}
)
;
if
(
!
this
.
_loadedAboutContentScript
)
{
Services
.
ppmm
.
loadProcessScript
(
kAboutPageRegistrationContentScript
true
)
;
this
.
_loadedAboutContentScript
=
true
;
registerCleanupFunction
(
this
.
_removeAboutPageRegistrations
.
bind
(
this
)
)
;
}
Services
.
ppmm
.
broadcastAsyncMessage
(
"
browser
-
test
-
utils
:
about
-
registration
:
register
"
{
aboutModule
pageURI
flags
}
)
;
return
rv
.
then
(
(
)
=
>
{
this
.
_knownAboutPages
.
add
(
aboutModule
)
;
}
)
;
}
unregisterAboutPage
(
aboutModule
)
{
if
(
!
this
.
_knownAboutPages
.
has
(
aboutModule
)
)
{
return
Promise
.
reject
(
new
Error
(
"
We
don
'
t
think
this
about
page
exists
!
"
)
)
;
}
const
kUnregistrationMsgId
=
"
browser
-
test
-
utils
:
about
-
registration
:
unregistered
"
;
let
rv
=
this
.
waitForMessage
(
Services
.
ppmm
kUnregistrationMsgId
msg
=
>
{
return
msg
.
data
=
=
aboutModule
;
}
)
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
browser
-
test
-
utils
:
about
-
registration
:
unregister
"
aboutModule
)
;
return
rv
.
then
(
(
)
=
>
this
.
_knownAboutPages
.
delete
(
aboutModule
)
)
;
}
async
_removeAboutPageRegistrations
(
)
{
for
(
let
aboutModule
of
this
.
_knownAboutPages
)
{
await
this
.
unregisterAboutPage
(
aboutModule
)
;
}
Services
.
ppmm
.
removeDelayedProcessScript
(
kAboutPageRegistrationContentScript
)
;
}
async
promiseAlertDialogOpen
(
buttonNameOrElementID
uri
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xhtml
"
options
=
{
callback
:
null
isSubDialog
:
false
}
)
{
let
win
;
if
(
uri
=
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xhtml
"
)
{
[
win
]
=
await
TestUtils
.
topicObserved
(
"
common
-
dialog
-
loaded
"
)
;
}
else
if
(
options
.
isSubDialog
)
{
[
win
]
=
await
TestUtils
.
topicObserved
(
"
subdialog
-
loaded
"
)
;
}
else
{
win
=
await
this
.
domWindowOpenedAndLoaded
(
null
win
=
>
{
return
win
.
document
.
documentURI
=
=
=
uri
;
}
)
;
}
if
(
options
.
callback
)
{
await
options
.
callback
(
win
)
;
return
win
;
}
if
(
buttonNameOrElementID
)
{
let
dialog
=
win
.
document
.
querySelector
(
"
dialog
"
)
;
let
element
=
dialog
.
getButton
(
buttonNameOrElementID
)
|
|
win
.
document
.
getElementById
(
buttonNameOrElementID
)
;
element
.
click
(
)
;
}
return
win
;
}
async
promiseAlertDialog
(
buttonNameOrElementID
uri
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xhtml
"
options
=
{
callback
:
null
isSubDialog
:
false
}
)
{
let
win
=
await
this
.
promiseAlertDialogOpen
(
buttonNameOrElementID
uri
options
)
;
if
(
!
win
.
docShell
.
browsingContext
.
embedderElement
)
{
return
this
.
windowClosed
(
win
)
;
}
let
container
=
win
.
top
.
document
.
getElementById
(
"
window
-
modal
-
dialog
"
)
;
return
this
.
waitForEvent
(
container
"
close
"
)
.
then
(
(
)
=
>
{
return
this
.
waitForMutationCondition
(
container
{
childList
:
true
attributes
:
true
}
(
)
=
>
!
container
.
hasChildNodes
(
)
&
&
!
container
.
open
)
;
}
)
;
}
addTab
(
tabbrowser
uri
params
=
{
}
beforeLoadFunc
=
null
)
{
if
(
!
params
.
triggeringPrincipal
)
{
params
.
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
}
if
(
!
params
.
allowInheritPrincipal
)
{
params
.
allowInheritPrincipal
=
true
;
}
if
(
beforeLoadFunc
)
{
let
window
=
tabbrowser
.
ownerGlobal
;
window
.
addEventListener
(
"
TabOpen
"
function
(
e
)
{
beforeLoadFunc
(
e
.
target
)
;
}
{
once
:
true
}
)
;
}
return
tabbrowser
.
addTab
(
uri
params
)
;
}
contentTopicObserved
(
aBrowsingContext
aTopic
aCount
=
1
aFilterFn
=
null
)
{
return
this
.
sendQuery
(
aBrowsingContext
"
BrowserTestUtils
:
ObserveTopic
"
{
topic
:
aTopic
count
:
aCount
filterFunctionSource
:
aFilterFn
?
aFilterFn
.
toSource
(
)
:
null
}
)
;
}
startObservingTopics
(
aBrowsingContext
aTopics
)
{
return
this
.
sendQuery
(
aBrowsingContext
"
BrowserTestUtils
:
StartObservingTopics
"
{
topics
:
aTopics
}
)
;
}
stopObservingTopics
(
aBrowsingContext
aTopics
)
{
return
this
.
sendQuery
(
aBrowsingContext
"
BrowserTestUtils
:
StopObservingTopics
"
{
topics
:
aTopics
}
)
;
}
async
sendAsyncMessage
(
aBrowsingContext
aMessageName
aMessageData
)
{
if
(
!
aBrowsingContext
.
currentWindowGlobal
)
{
await
this
.
waitForCondition
(
(
)
=
>
aBrowsingContext
.
currentWindowGlobal
)
;
}
let
actor
=
aBrowsingContext
.
currentWindowGlobal
.
getActor
(
"
BrowserTestUtils
"
)
;
actor
.
sendAsyncMessage
(
aMessageName
aMessageData
)
;
}
async
sendQuery
(
aBrowsingContext
aMessageName
aMessageData
)
{
let
startTime
=
Cu
.
now
(
)
;
if
(
!
aBrowsingContext
.
currentWindowGlobal
)
{
await
this
.
waitForCondition
(
(
)
=
>
aBrowsingContext
.
currentWindowGlobal
)
;
}
let
actor
=
aBrowsingContext
.
currentWindowGlobal
.
getActor
(
"
BrowserTestUtils
"
)
;
return
actor
.
sendQuery
(
aMessageName
aMessageData
)
.
then
(
val
=
>
{
ChromeUtils
.
addProfilerMarker
(
"
BrowserTestUtils
"
{
startTime
category
:
"
Test
"
}
aMessageName
)
;
return
val
;
}
)
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
BrowserTestUtils
"
_httpsFirstEnabled
"
"
dom
.
security
.
https_first
"
false
)
;
Services
.
obs
.
addObserver
(
BrowserTestUtils
"
test
-
complete
"
)
;
