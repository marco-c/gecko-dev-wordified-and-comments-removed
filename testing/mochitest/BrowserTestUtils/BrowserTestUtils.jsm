"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
BrowserTestUtils
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTask
.
jsm
"
)
;
Cc
[
"
mozilla
.
org
/
globalmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsIMessageListenerManager
)
.
loadFrameScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
BrowserTestUtils
/
content
-
utils
.
js
"
true
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
E10SUtils
"
"
resource
:
/
/
/
modules
/
E10SUtils
.
jsm
"
)
;
Cu
.
permitCPOWsInScope
(
this
)
;
var
gSendCharCount
=
0
;
var
gSynthesizeKeyCount
=
0
;
var
gSynthesizeCompositionCount
=
0
;
var
gSynthesizeCompositionChangeCount
=
0
;
this
.
BrowserTestUtils
=
{
withNewTab
:
Task
.
async
(
function
*
(
options
taskFn
)
{
if
(
typeof
(
options
)
=
=
"
string
"
)
{
options
=
{
gBrowser
:
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
.
gBrowser
url
:
options
}
}
let
tab
=
yield
BrowserTestUtils
.
openNewForegroundTab
(
options
.
gBrowser
options
.
url
)
;
let
originalWindow
=
tab
.
ownerDocument
.
defaultView
;
let
result
=
yield
taskFn
(
tab
.
linkedBrowser
)
;
let
finalWindow
=
tab
.
ownerDocument
.
defaultView
;
if
(
originalWindow
=
=
finalWindow
&
&
!
tab
.
closing
&
&
tab
.
linkedBrowser
)
{
yield
BrowserTestUtils
.
removeTab
(
tab
)
;
}
else
{
Services
.
console
.
logStringMessage
(
"
BrowserTestUtils
.
withNewTab
:
Tab
was
already
closed
before
"
+
"
removeTab
would
have
been
called
"
)
;
}
return
Promise
.
resolve
(
result
)
;
}
)
openNewForegroundTab
(
tabbrowser
opening
=
"
about
:
blank
"
aWaitForLoad
=
true
aWaitForStateStop
=
false
)
{
let
tab
;
let
promises
=
[
BrowserTestUtils
.
switchTab
(
tabbrowser
function
(
)
{
if
(
typeof
opening
=
=
"
function
"
)
{
opening
(
)
;
tab
=
tabbrowser
.
selectedTab
;
}
else
{
tabbrowser
.
selectedTab
=
tab
=
tabbrowser
.
addTab
(
opening
)
;
}
}
)
]
;
if
(
aWaitForLoad
)
{
promises
.
push
(
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
)
;
}
if
(
aWaitForStateStop
)
{
promises
.
push
(
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
)
)
;
}
return
Promise
.
all
(
promises
)
.
then
(
(
)
=
>
tab
)
;
}
switchTab
(
tabbrowser
tab
)
{
let
promise
=
new
Promise
(
resolve
=
>
{
tabbrowser
.
addEventListener
(
"
TabSwitchDone
"
function
onSwitch
(
)
{
tabbrowser
.
removeEventListener
(
"
TabSwitchDone
"
onSwitch
)
;
TestUtils
.
executeSoon
(
(
)
=
>
resolve
(
tabbrowser
.
selectedTab
)
)
;
}
)
;
}
)
;
if
(
typeof
tab
=
=
"
function
"
)
{
tab
(
)
;
}
else
{
tabbrowser
.
selectedTab
=
tab
;
}
return
promise
;
}
browserLoaded
(
browser
includeSubFrames
=
false
wantLoad
=
null
)
{
function
isWanted
(
url
)
{
if
(
!
wantLoad
)
{
return
true
;
}
else
if
(
typeof
(
wantLoad
)
=
=
"
function
"
)
{
return
wantLoad
(
url
)
;
}
else
{
return
wantLoad
=
=
url
;
}
}
return
new
Promise
(
resolve
=
>
{
let
mm
=
browser
.
ownerDocument
.
defaultView
.
messageManager
;
mm
.
addMessageListener
(
"
browser
-
test
-
utils
:
loadEvent
"
function
onLoad
(
msg
)
{
if
(
msg
.
target
=
=
browser
&
&
(
!
msg
.
data
.
subframe
|
|
includeSubFrames
)
&
&
isWanted
(
msg
.
data
.
url
)
)
{
mm
.
removeMessageListener
(
"
browser
-
test
-
utils
:
loadEvent
"
onLoad
)
;
resolve
(
msg
.
data
.
url
)
;
}
}
)
;
}
)
;
}
firstBrowserLoaded
(
win
)
{
let
mm
=
win
.
messageManager
;
return
this
.
waitForMessage
(
mm
"
browser
-
test
-
utils
:
loadEvent
"
(
msg
)
=
>
{
let
selectedBrowser
=
win
.
gBrowser
.
selectedBrowser
;
return
msg
.
target
=
=
selectedBrowser
;
}
)
;
}
browserStopped
(
browser
)
{
return
new
Promise
(
resolve
=
>
{
let
wpl
=
{
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
aWebProgress
.
isTopLevel
)
{
browser
.
webProgress
.
removeProgressListener
(
filter
)
;
filter
.
removeProgressListener
(
wpl
)
;
resolve
(
)
;
}
;
}
onSecurityChange
(
)
{
}
onStatusChange
(
)
{
}
onLocationChange
(
)
{
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsIWebProgressListener2
]
)
}
;
const
filter
=
Cc
[
"
mozilla
.
org
/
appshell
/
component
/
browser
-
status
-
filter
;
1
"
]
.
createInstance
(
Ci
.
nsIWebProgress
)
;
filter
.
addProgressListener
(
wpl
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
browser
.
webProgress
.
addProgressListener
(
filter
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
}
)
;
}
waitForNewTab
(
tabbrowser
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
tabbrowser
.
tabContainer
.
addEventListener
(
"
TabOpen
"
function
onTabOpen
(
openEvent
)
{
tabbrowser
.
tabContainer
.
removeEventListener
(
"
TabOpen
"
onTabOpen
)
;
let
progressListener
=
{
onLocationChange
(
aBrowser
)
{
if
(
aBrowser
!
=
openEvent
.
target
.
linkedBrowser
|
|
(
url
&
&
aBrowser
.
currentURI
.
spec
!
=
url
)
|
|
(
!
url
&
&
aBrowser
.
currentURI
.
spec
=
=
"
about
:
blank
"
)
)
{
return
;
}
tabbrowser
.
removeTabsProgressListener
(
progressListener
)
;
resolve
(
openEvent
.
target
)
;
}
}
;
tabbrowser
.
addTabsProgressListener
(
progressListener
)
;
}
)
;
}
)
;
}
waitForLocationChange
(
tabbrowser
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
progressListener
=
{
onLocationChange
(
aBrowser
)
{
if
(
(
url
&
&
aBrowser
.
currentURI
.
spec
!
=
url
)
|
|
(
!
url
&
&
aBrowser
.
currentURI
.
spec
=
=
"
about
:
blank
"
)
)
{
return
;
}
tabbrowser
.
removeTabsProgressListener
(
progressListener
)
;
resolve
(
)
;
}
}
;
tabbrowser
.
addTabsProgressListener
(
progressListener
)
;
}
)
;
}
waitForNewWindow
:
Task
.
async
(
function
*
(
delayedStartup
=
true
initialBrowserLoaded
=
null
)
{
let
win
=
yield
this
.
domWindowOpened
(
)
;
let
promises
=
[
TestUtils
.
topicObserved
(
"
browser
-
delayed
-
startup
-
finished
"
subject
=
>
subject
=
=
win
)
]
;
if
(
initialBrowserLoaded
)
{
yield
this
.
waitForEvent
(
win
"
DOMContentLoaded
"
)
;
let
browser
=
win
.
gBrowser
.
selectedBrowser
;
let
process
=
browser
.
isRemoteBrowser
?
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
:
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
;
if
(
win
.
gMultiProcessBrowser
&
&
!
E10SUtils
.
canLoadURIInProcess
(
initialBrowserLoaded
process
)
)
{
yield
this
.
waitForEvent
(
browser
"
XULFrameLoaderCreated
"
)
;
}
let
loadPromise
=
this
.
browserLoaded
(
browser
false
initialBrowserLoaded
)
;
promises
.
push
(
loadPromise
)
;
}
yield
Promise
.
all
(
promises
)
;
return
win
;
}
)
loadURI
:
Task
.
async
(
function
*
(
browser
uri
)
{
browser
.
loadURI
(
uri
)
;
if
(
!
browser
.
ownerDocument
.
defaultView
.
gMultiProcessBrowser
)
{
return
;
}
let
process
=
browser
.
isRemoteBrowser
?
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
:
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
;
if
(
!
E10SUtils
.
canLoadURIInProcess
(
uri
process
)
)
{
yield
this
.
waitForEvent
(
browser
"
XULFrameLoaderCreated
"
)
;
}
}
)
domWindowOpened
(
win
checkFn
)
{
return
new
Promise
(
resolve
=
>
{
function
observer
(
subject
topic
data
)
{
if
(
topic
=
=
"
domwindowopened
"
&
&
(
!
win
|
|
subject
=
=
=
win
)
)
{
let
observedWindow
=
subject
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
;
if
(
checkFn
&
&
!
checkFn
(
observedWindow
)
)
{
return
;
}
Services
.
ww
.
unregisterNotification
(
observer
)
;
resolve
(
observedWindow
)
;
}
}
Services
.
ww
.
registerNotification
(
observer
)
;
}
)
;
}
domWindowClosed
(
win
)
{
return
new
Promise
(
(
resolve
)
=
>
{
function
observer
(
subject
topic
data
)
{
if
(
topic
=
=
"
domwindowclosed
"
&
&
(
!
win
|
|
subject
=
=
=
win
)
)
{
Services
.
ww
.
unregisterNotification
(
observer
)
;
resolve
(
subject
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
)
;
}
}
Services
.
ww
.
registerNotification
(
observer
)
;
}
)
;
}
openNewBrowserWindow
:
Task
.
async
(
function
*
(
options
=
{
}
)
{
let
argString
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
argString
.
data
=
"
"
;
let
features
=
"
chrome
dialog
=
no
all
"
;
if
(
options
.
private
)
{
features
+
=
"
private
"
;
}
if
(
options
.
hasOwnProperty
(
"
remote
"
)
)
{
let
remoteState
=
options
.
remote
?
"
remote
"
:
"
non
-
remote
"
;
features
+
=
{
remoteState
}
;
}
let
win
=
Services
.
ww
.
openWindow
(
null
Services
.
prefs
.
getCharPref
(
"
browser
.
chromeURL
"
)
"
_blank
"
features
argString
)
;
let
startupPromise
=
TestUtils
.
topicObserved
(
"
browser
-
delayed
-
startup
-
finished
"
subject
=
>
subject
=
=
win
)
.
then
(
(
)
=
>
win
)
;
let
loadPromise
=
this
.
firstBrowserLoaded
(
win
)
;
yield
startupPromise
;
yield
loadPromise
;
return
win
;
}
)
closeWindow
(
win
)
{
let
closedPromise
=
BrowserTestUtils
.
windowClosed
(
win
)
;
win
.
close
(
)
;
return
closedPromise
;
}
windowClosed
(
win
)
{
let
domWinClosedPromise
=
BrowserTestUtils
.
domWindowClosed
(
win
)
;
let
promises
=
[
domWinClosedPromise
]
;
let
winType
=
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
if
(
winType
=
=
"
navigator
:
browser
"
)
{
let
finalMsgsPromise
=
new
Promise
(
(
resolve
)
=
>
{
let
browserSet
=
new
Set
(
win
.
gBrowser
.
browsers
)
;
let
mm
=
win
.
getGroupMessageManager
(
"
browsers
"
)
;
mm
.
addMessageListener
(
"
SessionStore
:
update
"
function
onMessage
(
msg
)
{
if
(
browserSet
.
has
(
msg
.
target
)
&
&
msg
.
data
.
isFinal
)
{
browserSet
.
delete
(
msg
.
target
)
;
if
(
!
browserSet
.
size
)
{
mm
.
removeMessageListener
(
"
SessionStore
:
update
"
onMessage
)
;
TestUtils
.
executeSoon
(
resolve
)
;
}
}
}
true
)
;
}
)
;
promises
.
push
(
finalMsgsPromise
)
;
}
return
Promise
.
all
(
promises
)
;
}
waitForEvent
(
subject
eventName
capture
checkFn
wantsUntrusted
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
subject
.
addEventListener
(
eventName
function
listener
(
event
)
{
try
{
if
(
checkFn
&
&
!
checkFn
(
event
)
)
{
return
;
}
subject
.
removeEventListener
(
eventName
listener
capture
)
;
resolve
(
event
)
;
}
catch
(
ex
)
{
try
{
subject
.
removeEventListener
(
eventName
listener
capture
)
;
}
catch
(
ex2
)
{
}
reject
(
ex
)
;
}
}
capture
wantsUntrusted
)
;
}
)
;
}
waitForContentEvent
(
browser
eventName
capture
=
false
checkFn
wantsUntrusted
=
false
)
{
let
parameters
=
{
eventName
capture
checkFnSource
:
checkFn
?
checkFn
.
toSource
(
)
:
null
wantsUntrusted
}
;
return
ContentTask
.
spawn
(
browser
parameters
function
(
{
eventName
capture
checkFnSource
wantsUntrusted
}
)
{
let
checkFn
;
if
(
checkFnSource
)
{
checkFn
=
eval
(
(
(
)
=
>
(
{
checkFnSource
}
)
)
(
)
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
addEventListener
(
eventName
function
listener
(
event
)
{
let
completion
=
resolve
;
try
{
if
(
checkFn
&
&
!
checkFn
(
event
)
)
{
return
;
}
}
catch
(
e
)
{
completion
=
(
)
=
>
reject
(
e
)
;
}
removeEventListener
(
eventName
listener
capture
)
;
completion
(
)
;
}
capture
wantsUntrusted
)
;
}
)
;
}
)
;
}
waitForErrorPage
(
browser
)
{
let
waitForLoad
=
(
)
=
>
this
.
waitForContentEvent
(
browser
"
AboutNetErrorLoad
"
false
null
true
)
;
let
win
=
browser
.
ownerDocument
.
defaultView
;
let
tab
=
win
.
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
|
|
browser
.
isRemoteBrowser
|
|
!
win
.
gMultiProcessBrowser
)
{
return
waitForLoad
(
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
tab
.
addEventListener
(
"
TabRemotenessChange
"
function
onTRC
(
)
{
tab
.
removeEventListener
(
"
TabRemotenessChange
"
onTRC
)
;
waitForLoad
(
)
.
then
(
resolve
reject
)
;
}
)
;
}
)
;
}
synthesizeMouse
(
target
offsetX
offsetY
event
browser
)
{
return
new
Promise
(
resolve
=
>
{
let
mm
=
browser
.
messageManager
;
mm
.
addMessageListener
(
"
Test
:
SynthesizeMouseDone
"
function
mouseMsg
(
message
)
{
mm
.
removeMessageListener
(
"
Test
:
SynthesizeMouseDone
"
mouseMsg
)
;
resolve
(
message
.
data
.
defaultPrevented
)
;
}
)
;
let
cpowObject
=
null
;
let
targetFn
=
null
;
if
(
typeof
target
=
=
"
function
"
)
{
targetFn
=
target
.
toString
(
)
;
target
=
null
;
}
else
if
(
typeof
target
!
=
"
string
"
)
{
cpowObject
=
target
;
target
=
null
;
}
mm
.
sendAsyncMessage
(
"
Test
:
SynthesizeMouse
"
{
target
targetFn
x
:
offsetX
y
:
offsetY
event
:
event
}
{
object
:
cpowObject
}
)
;
}
)
;
}
waitForMessage
(
messageManager
message
checkFn
)
{
return
new
Promise
(
resolve
=
>
{
messageManager
.
addMessageListener
(
message
function
onMessage
(
msg
)
{
if
(
!
checkFn
|
|
checkFn
(
msg
)
)
{
messageManager
.
removeMessageListener
(
message
onMessage
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
synthesizeMouseAtCenter
(
target
event
browser
)
{
event
.
centered
=
true
;
return
BrowserTestUtils
.
synthesizeMouse
(
target
0
0
event
browser
)
;
}
synthesizeMouseAtPoint
(
offsetX
offsetY
event
browser
)
{
return
BrowserTestUtils
.
synthesizeMouse
(
null
offsetX
offsetY
event
browser
)
;
}
removeTab
(
tab
options
=
{
}
)
{
let
dontRemove
=
options
&
&
options
.
dontRemove
;
return
new
Promise
(
resolve
=
>
{
let
{
messageManager
:
mm
frameLoader
}
=
tab
.
linkedBrowser
;
mm
.
addMessageListener
(
"
SessionStore
:
update
"
function
onMessage
(
msg
)
{
if
(
msg
.
targetFrameLoader
=
=
frameLoader
&
&
msg
.
data
.
isFinal
)
{
mm
.
removeMessageListener
(
"
SessionStore
:
update
"
onMessage
)
;
resolve
(
)
;
}
}
true
)
;
if
(
!
dontRemove
&
&
!
tab
.
closing
)
{
tab
.
ownerDocument
.
defaultView
.
gBrowser
.
removeTab
(
tab
)
;
}
}
)
;
}
crashBrowser
:
Task
.
async
(
function
*
(
browser
)
{
let
extra
=
{
}
;
let
KeyValueParser
=
{
}
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
KeyValueParser
.
jsm
"
KeyValueParser
)
;
}
if
(
!
browser
.
isRemoteBrowser
)
{
throw
new
Error
(
"
<
xul
:
browser
>
needs
to
be
remote
in
order
to
crash
"
)
;
}
function
getMinidumpDirectory
(
)
{
let
dir
=
Services
.
dirsvc
.
get
(
'
ProfD
'
Ci
.
nsIFile
)
;
dir
.
append
(
"
minidumps
"
)
;
return
dir
;
}
function
removeFile
(
directory
filename
)
{
let
file
=
directory
.
clone
(
)
;
file
.
append
(
filename
)
;
if
(
file
.
exists
(
)
)
{
file
.
remove
(
false
)
;
}
}
let
frame_script
=
(
)
=
>
{
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
let
dies
=
function
(
)
{
privateNoteIntentionalCrash
(
)
;
let
zero
=
new
ctypes
.
intptr_t
(
8
)
;
let
badptr
=
ctypes
.
cast
(
zero
ctypes
.
PointerType
(
ctypes
.
int32_t
)
)
;
badptr
.
contents
}
;
dump
(
"
\
nEt
tu
Brute
?
\
n
"
)
;
dies
(
)
;
}
let
crashCleanupPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
topic
!
=
"
ipc
:
content
-
shutdown
"
)
{
return
reject
(
"
Received
incorrect
observer
topic
:
"
+
topic
)
;
}
if
(
!
(
subject
instanceof
Ci
.
nsIPropertyBag2
)
)
{
return
reject
(
"
Subject
did
not
implement
nsIPropertyBag2
"
)
;
}
if
(
!
subject
.
hasKey
(
"
abnormal
"
)
)
{
dump
(
"
\
nThis
is
a
normal
termination
and
isn
'
t
the
one
we
are
looking
for
.
.
.
\
n
"
)
;
return
;
}
let
dumpID
;
if
(
'
nsICrashReporter
'
in
Ci
)
{
dumpID
=
subject
.
getPropertyAsAString
(
'
dumpID
'
)
;
if
(
!
dumpID
)
{
return
reject
(
"
dumpID
was
not
present
despite
crash
reporting
"
+
"
being
enabled
"
)
;
}
}
if
(
dumpID
)
{
let
minidumpDirectory
=
getMinidumpDirectory
(
)
;
let
extrafile
=
minidumpDirectory
.
clone
(
)
;
extrafile
.
append
(
dumpID
+
'
.
extra
'
)
;
if
(
extrafile
.
exists
(
)
)
{
dump
(
\
nNo
.
extra
file
for
dumpID
:
{
dumpID
}
\
n
)
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
extra
=
KeyValueParser
.
parseKeyValuePairsFromFile
(
extrafile
)
;
}
else
{
dump
(
'
\
nCrashReporter
not
enabled
-
will
not
return
any
extra
data
\
n
'
)
;
}
}
removeFile
(
minidumpDirectory
dumpID
+
'
.
dmp
'
)
;
removeFile
(
minidumpDirectory
dumpID
+
'
.
extra
'
)
;
}
Services
.
obs
.
removeObserver
(
observer
'
ipc
:
content
-
shutdown
'
)
;
dump
(
"
\
nCrash
cleaned
up
\
n
"
)
;
resolve
(
)
;
}
;
Services
.
obs
.
addObserver
(
observer
'
ipc
:
content
-
shutdown
'
false
)
;
}
)
;
let
aboutTabCrashedLoadPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
browser
.
addEventListener
(
"
AboutTabCrashedReady
"
function
onCrash
(
)
{
browser
.
removeEventListener
(
"
AboutTabCrashedReady
"
onCrash
false
)
;
dump
(
"
\
nabout
:
tabcrashed
loaded
and
ready
\
n
"
)
;
resolve
(
)
;
}
false
true
)
;
}
)
;
let
mm
=
browser
.
messageManager
;
mm
.
loadFrameScript
(
"
data
:
(
"
+
frame_script
.
toString
(
)
+
"
)
(
)
;
"
false
)
;
yield
Promise
.
all
(
[
crashCleanupPromise
aboutTabCrashedLoadPromise
]
)
;
let
gBrowser
=
browser
.
ownerDocument
.
defaultView
.
gBrowser
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
tab
.
getAttribute
(
"
crashed
"
)
!
=
"
true
"
)
{
throw
new
Error
(
"
Tab
should
be
marked
as
crashed
"
)
;
}
return
extra
;
}
)
waitForAttribute
(
attr
element
value
)
{
let
MutationObserver
=
element
.
ownerDocument
.
defaultView
.
MutationObserver
;
return
new
Promise
(
resolve
=
>
{
let
mut
=
new
MutationObserver
(
mutations
=
>
{
if
(
(
!
value
&
&
element
.
getAttribute
(
attr
)
)
|
|
(
value
&
&
element
.
getAttribute
(
attr
)
=
=
=
value
)
)
{
resolve
(
)
;
mut
.
disconnect
(
)
;
return
;
}
}
)
;
mut
.
observe
(
element
{
attributeFilter
:
[
attr
]
}
)
;
}
)
;
}
sendChar
(
char
browser
)
{
return
new
Promise
(
resolve
=
>
{
let
seq
=
+
+
gSendCharCount
;
let
mm
=
browser
.
messageManager
;
mm
.
addMessageListener
(
"
Test
:
SendCharDone
"
function
charMsg
(
message
)
{
if
(
message
.
data
.
seq
!
=
seq
)
return
;
mm
.
removeMessageListener
(
"
Test
:
SendCharDone
"
charMsg
)
;
resolve
(
message
.
data
.
result
)
;
}
)
;
mm
.
sendAsyncMessage
(
"
Test
:
SendChar
"
{
char
:
char
seq
:
seq
}
)
;
}
)
;
}
synthesizeKey
(
key
event
browser
)
{
return
new
Promise
(
resolve
=
>
{
let
seq
=
+
+
gSynthesizeKeyCount
;
let
mm
=
browser
.
messageManager
;
mm
.
addMessageListener
(
"
Test
:
SynthesizeKeyDone
"
function
keyMsg
(
message
)
{
if
(
message
.
data
.
seq
!
=
seq
)
return
;
mm
.
removeMessageListener
(
"
Test
:
SynthesizeKeyDone
"
keyMsg
)
;
resolve
(
)
;
}
)
;
mm
.
sendAsyncMessage
(
"
Test
:
SynthesizeKey
"
{
key
event
seq
}
)
;
}
)
;
}
synthesizeComposition
(
event
browser
)
{
return
new
Promise
(
resolve
=
>
{
let
seq
=
+
+
gSynthesizeCompositionCount
;
let
mm
=
browser
.
messageManager
;
mm
.
addMessageListener
(
"
Test
:
SynthesizeCompositionDone
"
function
compMsg
(
message
)
{
if
(
message
.
data
.
seq
!
=
seq
)
return
;
mm
.
removeMessageListener
(
"
Test
:
SynthesizeCompositionDone
"
compMsg
)
;
resolve
(
message
.
data
.
result
)
;
}
)
;
mm
.
sendAsyncMessage
(
"
Test
:
SynthesizeComposition
"
{
event
seq
}
)
;
}
)
;
}
synthesizeCompositionChange
(
event
browser
)
{
return
new
Promise
(
resolve
=
>
{
let
seq
=
+
+
gSynthesizeCompositionChangeCount
;
let
mm
=
browser
.
messageManager
;
mm
.
addMessageListener
(
"
Test
:
SynthesizeCompositionChangeDone
"
function
compMsg
(
message
)
{
if
(
message
.
data
.
seq
!
=
seq
)
return
;
mm
.
removeMessageListener
(
"
Test
:
SynthesizeCompositionChangeDone
"
compMsg
)
;
resolve
(
)
;
}
)
;
mm
.
sendAsyncMessage
(
"
Test
:
SynthesizeCompositionChange
"
{
event
seq
}
)
;
}
)
;
}
waitForCondition
(
condition
msg
interval
=
100
maxTries
=
50
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
tries
=
0
;
let
intervalID
=
setInterval
(
Task
.
async
(
function
*
(
)
{
if
(
tries
>
=
maxTries
)
{
clearInterval
(
intervalID
)
;
msg
+
=
-
timed
out
after
{
maxTries
}
tries
.
;
reject
(
msg
)
;
return
;
}
let
conditionPassed
=
false
;
try
{
conditionPassed
=
yield
condition
(
)
;
}
catch
(
e
)
{
msg
+
=
-
threw
exception
:
{
e
}
;
clearInterval
(
intervalID
)
;
reject
(
msg
)
;
return
;
}
if
(
conditionPassed
)
{
clearInterval
(
intervalID
)
;
resolve
(
)
;
}
tries
+
+
;
}
)
interval
)
;
}
)
;
}
waitForNotificationBar
(
tabbrowser
browser
notificationValue
)
{
let
notificationBox
=
tabbrowser
.
getNotificationBox
(
browser
)
;
return
new
Promise
(
(
resolve
)
=
>
{
let
check
=
(
event
)
=
>
{
return
event
.
target
.
value
=
=
notificationValue
;
}
;
BrowserTestUtils
.
waitForEvent
(
notificationBox
"
AlertActive
"
false
check
)
.
then
(
(
event
)
=
>
{
resolve
(
event
.
originalTarget
)
;
}
)
;
}
)
;
}
contentPainted
(
browser
)
{
return
ContentTask
.
spawn
(
browser
null
function
*
(
)
{
return
new
Promise
(
(
resolve
)
=
>
{
addEventListener
(
"
MozAfterPaint
"
function
onPaint
(
)
{
removeEventListener
(
"
MozAfterPaint
"
onPaint
)
;
resolve
(
)
;
}
)
}
)
;
}
)
;
}
}
;
