"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ContentTaskUtils
"
]
;
const
{
clearInterval
setInterval
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
var
ContentTaskUtils
=
{
is_hidden
(
element
)
{
var
style
=
element
.
ownerGlobal
.
getComputedStyle
(
element
)
;
if
(
style
.
display
=
=
"
none
"
)
return
true
;
if
(
style
.
visibility
!
=
"
visible
"
)
return
true
;
if
(
element
.
parentNode
!
=
element
.
ownerDocument
)
return
ContentTaskUtils
.
is_hidden
(
element
.
parentNode
)
;
return
false
;
}
is_visible
(
element
)
{
var
style
=
element
.
ownerGlobal
.
getComputedStyle
(
element
)
;
if
(
style
.
display
=
=
"
none
"
)
return
false
;
if
(
style
.
visibility
!
=
"
visible
"
)
return
false
;
if
(
element
.
parentNode
!
=
element
.
ownerDocument
)
return
ContentTaskUtils
.
is_visible
(
element
.
parentNode
)
;
return
true
;
}
waitForCondition
(
condition
msg
interval
=
100
maxTries
=
50
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
tries
=
0
;
let
intervalID
=
setInterval
(
(
)
=
>
{
if
(
tries
>
=
maxTries
)
{
clearInterval
(
intervalID
)
;
msg
+
=
-
timed
out
after
{
maxTries
}
tries
.
;
reject
(
msg
)
;
return
;
}
let
conditionPassed
=
false
;
try
{
conditionPassed
=
condition
(
)
;
}
catch
(
e
)
{
msg
+
=
-
threw
exception
:
{
e
}
;
clearInterval
(
intervalID
)
;
reject
(
msg
)
;
return
;
}
if
(
conditionPassed
)
{
clearInterval
(
intervalID
)
;
resolve
(
conditionPassed
)
;
}
tries
+
+
;
}
interval
)
;
}
)
;
}
waitForEvent
(
subject
eventName
capture
checkFn
wantsUntrusted
=
false
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
subject
.
addEventListener
(
eventName
function
listener
(
event
)
{
try
{
if
(
checkFn
&
&
!
checkFn
(
event
)
)
{
return
;
}
subject
.
removeEventListener
(
eventName
listener
capture
)
;
setTimeout
(
(
)
=
>
resolve
(
event
)
0
)
;
}
catch
(
ex
)
{
try
{
subject
.
removeEventListener
(
eventName
listener
capture
)
;
}
catch
(
ex2
)
{
}
setTimeout
(
(
)
=
>
reject
(
ex
)
0
)
;
}
}
capture
wantsUntrusted
)
;
}
)
;
}
}
;
