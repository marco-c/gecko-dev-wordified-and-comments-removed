"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserTestUtilsChild
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
class
BrowserTestUtilsChildObserver
{
constructor
(
)
{
this
.
currentObserverStatus
=
"
"
;
this
.
observerItems
=
[
]
;
}
startObservingTopics
(
aTopics
)
{
for
(
let
topic
of
aTopics
)
{
Services
.
obs
.
addObserver
(
this
topic
)
;
this
.
observerItems
.
push
(
{
topic
}
)
;
}
}
stopObservingTopics
(
aTopics
)
{
if
(
aTopics
)
{
for
(
let
topic
of
aTopics
)
{
let
index
=
this
.
observerItems
.
findIndex
(
item
=
>
item
.
topic
=
=
topic
)
;
if
(
index
>
=
0
)
{
Services
.
obs
.
removeObserver
(
this
topic
)
;
this
.
observerItems
.
splice
(
index
1
)
;
}
}
}
else
{
for
(
let
topic
of
this
.
observerItems
)
{
Services
.
obs
.
removeObserver
(
this
topic
)
;
}
this
.
observerItems
=
[
]
;
}
if
(
this
.
currentObserverStatus
)
{
let
error
=
new
Error
(
this
.
currentObserverStatus
)
;
this
.
currentObserverStatus
=
"
"
;
throw
error
;
}
}
observeTopic
(
topic
count
filterFn
callbackResolver
)
{
let
removeObserver
=
false
;
let
index
=
this
.
observerItems
.
findIndex
(
item
=
>
item
.
topic
=
=
topic
)
;
if
(
index
=
=
-
1
)
{
removeObserver
=
true
;
this
.
startObservingTopics
(
[
topic
]
)
;
}
for
(
let
item
of
this
.
observerItems
)
{
if
(
item
.
topic
=
=
topic
)
{
item
.
count
=
count
|
|
1
;
item
.
filterFn
=
filterFn
;
item
.
promiseResolver
=
(
)
=
>
{
if
(
removeObserver
)
{
this
.
stopObservingTopics
(
[
topic
]
)
;
}
callbackResolver
(
)
;
}
;
break
;
}
}
}
observe
(
aSubject
aTopic
aData
)
{
for
(
let
item
of
this
.
observerItems
)
{
if
(
item
.
topic
!
=
aTopic
)
{
continue
;
}
if
(
item
.
filterFn
&
&
!
item
.
filterFn
(
aSubject
aTopic
aData
)
)
{
break
;
}
if
(
-
-
item
.
count
>
=
0
)
{
if
(
item
.
count
=
=
0
&
&
item
.
promiseResolver
)
{
item
.
promiseResolver
(
)
;
}
return
;
}
}
console
.
log
(
"
Failed
:
Observer
topic
"
+
aTopic
+
"
not
expected
in
content
process
"
)
;
this
.
currentObserverStatus
+
=
"
Topic
"
+
aTopic
+
"
not
expected
in
content
process
\
n
"
;
}
}
BrowserTestUtilsChildObserver
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
;
class
BrowserTestUtilsChild
extends
JSWindowActorChild
{
actorCreated
(
)
{
this
.
_EventUtils
=
null
;
}
get
EventUtils
(
)
{
if
(
!
this
.
_EventUtils
)
{
let
win
=
this
.
contentWindow
;
let
EventUtils
=
{
get
KeyboardEvent
(
)
{
return
win
.
KeyboardEvent
;
}
get
navigator
(
)
{
return
win
.
navigator
;
}
}
;
EventUtils
.
window
=
{
}
;
EventUtils
.
parent
=
EventUtils
.
window
;
EventUtils
.
_EU_Ci
=
Ci
;
EventUtils
.
_EU_Cc
=
Cc
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
EventUtils
)
;
this
.
_EventUtils
=
EventUtils
;
}
return
this
.
_EventUtils
;
}
receiveMessage
(
aMessage
)
{
switch
(
aMessage
.
name
)
{
case
"
Test
:
SynthesizeMouse
"
:
{
return
this
.
synthesizeMouse
(
aMessage
.
data
this
.
contentWindow
)
;
}
case
"
Test
:
SynthesizeTouch
"
:
{
return
this
.
synthesizeTouch
(
aMessage
.
data
this
.
contentWindow
)
;
}
case
"
Test
:
SendChar
"
:
{
return
this
.
EventUtils
.
sendChar
(
aMessage
.
data
.
char
this
.
contentWindow
)
;
}
case
"
Test
:
SynthesizeKey
"
:
this
.
EventUtils
.
synthesizeKey
(
aMessage
.
data
.
key
aMessage
.
data
.
event
|
|
{
}
this
.
contentWindow
)
;
break
;
case
"
Test
:
SynthesizeComposition
"
:
{
return
this
.
EventUtils
.
synthesizeComposition
(
aMessage
.
data
.
event
this
.
contentWindow
)
;
}
case
"
Test
:
SynthesizeCompositionChange
"
:
this
.
EventUtils
.
synthesizeCompositionChange
(
aMessage
.
data
.
event
this
.
contentWindow
)
;
break
;
case
"
BrowserTestUtils
:
StartObservingTopics
"
:
{
this
.
observer
=
new
BrowserTestUtilsChildObserver
(
)
;
this
.
observer
.
startObservingTopics
(
aMessage
.
data
.
topics
)
;
break
;
}
case
"
BrowserTestUtils
:
StopObservingTopics
"
:
{
if
(
this
.
observer
)
{
this
.
observer
.
stopObservingTopics
(
aMessage
.
data
.
topics
)
;
this
.
observer
=
null
;
}
break
;
}
case
"
BrowserTestUtils
:
ObserveTopic
"
:
{
return
new
Promise
(
resolve
=
>
{
let
filterFn
;
if
(
aMessage
.
data
.
filterFunctionSource
)
{
filterFn
=
eval
(
(
(
)
=
>
(
{
aMessage
.
data
.
filterFunctionSource
}
)
)
(
)
)
;
}
let
observer
=
this
.
observer
|
|
new
BrowserTestUtilsChildObserver
(
)
;
observer
.
observeTopic
(
aMessage
.
data
.
topic
aMessage
.
data
.
count
filterFn
resolve
)
;
}
)
;
}
case
"
BrowserTestUtils
:
CrashFrame
"
:
{
const
{
ctypes
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
let
dies
=
function
(
)
{
ChromeUtils
.
privateNoteIntentionalCrash
(
)
;
let
zero
=
new
ctypes
.
intptr_t
(
8
)
;
let
badptr
=
ctypes
.
cast
(
zero
ctypes
.
PointerType
(
ctypes
.
int32_t
)
)
;
badptr
.
contents
;
}
;
dump
(
"
\
nEt
tu
Brute
?
\
n
"
)
;
dies
(
)
;
}
}
return
undefined
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
DOMContentLoaded
"
:
case
"
load
"
:
{
this
.
sendAsyncMessage
(
aEvent
.
type
{
internalURL
:
aEvent
.
target
.
documentURI
visibleURL
:
aEvent
.
target
.
location
.
href
}
)
;
break
;
}
}
}
synthesizeMouse
(
data
window
)
{
let
target
=
data
.
target
;
if
(
typeof
target
=
=
"
string
"
)
{
target
=
this
.
document
.
querySelector
(
target
)
;
}
else
if
(
typeof
data
.
targetFn
=
=
"
string
"
)
{
let
runnablestr
=
(
(
)
=
>
{
return
(
{
data
.
targetFn
}
)
;
}
)
(
)
;
;
target
=
eval
(
runnablestr
)
(
)
;
}
let
left
=
data
.
x
;
let
top
=
data
.
y
;
if
(
target
)
{
if
(
target
.
ownerDocument
!
=
=
this
.
document
)
{
let
cur
=
target
;
do
{
let
frame
=
cur
.
ownerGlobal
.
frameElement
;
let
rect
=
frame
.
getBoundingClientRect
(
)
;
left
+
=
rect
.
left
;
top
+
=
rect
.
top
;
cur
=
frame
;
}
while
(
cur
&
&
cur
.
ownerDocument
!
=
=
this
.
document
)
;
if
(
!
cur
)
{
throw
new
Error
(
"
target
must
be
in
the
main
document
tree
"
)
;
}
}
let
rect
=
target
.
getBoundingClientRect
(
)
;
left
+
=
rect
.
left
;
top
+
=
rect
.
top
;
if
(
data
.
event
.
centered
)
{
left
+
=
rect
.
width
/
2
;
top
+
=
rect
.
height
/
2
;
}
}
let
result
;
if
(
data
.
event
&
&
data
.
event
.
wheel
)
{
this
.
EventUtils
.
synthesizeWheelAtPoint
(
left
top
data
.
event
window
)
;
}
else
{
result
=
this
.
EventUtils
.
synthesizeMouseAtPoint
(
left
top
data
.
event
window
)
;
}
return
result
;
}
synthesizeTouch
(
data
window
)
{
let
target
=
data
.
target
;
if
(
typeof
target
=
=
"
string
"
)
{
target
=
this
.
document
.
querySelector
(
target
)
;
}
else
if
(
typeof
data
.
targetFn
=
=
"
string
"
)
{
let
runnablestr
=
(
(
)
=
>
{
return
(
{
data
.
targetFn
}
)
;
}
)
(
)
;
;
target
=
eval
(
runnablestr
)
(
)
;
}
if
(
target
)
{
if
(
target
.
ownerDocument
!
=
=
this
.
document
)
{
let
cur
=
target
;
do
{
cur
=
cur
.
ownerGlobal
.
frameElement
;
}
while
(
cur
&
&
cur
.
ownerDocument
!
=
=
this
.
document
)
;
if
(
!
cur
)
{
throw
new
Error
(
"
target
must
be
in
the
main
document
tree
"
)
;
}
}
}
return
this
.
EventUtils
.
synthesizeTouch
(
target
data
.
x
data
.
y
data
.
event
window
)
;
}
}
