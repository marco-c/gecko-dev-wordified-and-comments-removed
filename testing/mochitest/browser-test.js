var
gTimeoutSeconds
=
45
;
var
gConfig
;
var
gSaveInstrumentationData
=
null
;
var
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
var
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ContentSearch
"
"
resource
:
/
/
/
modules
/
ContentSearch
.
jsm
"
)
;
const
SIMPLETEST_OVERRIDES
=
[
"
ok
"
"
record
"
"
is
"
"
isnot
"
"
todo
"
"
todo_is
"
"
todo_isnot
"
"
info
"
"
expectAssertions
"
"
requestCompleteLog
"
]
;
setTimeout
(
testInit
0
)
;
var
TabDestroyObserver
=
{
outstanding
:
new
Set
(
)
promiseResolver
:
null
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
close
"
)
;
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
disconnect
"
)
;
}
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
message
-
manager
-
close
"
)
;
Services
.
obs
.
removeObserver
(
this
"
message
-
manager
-
disconnect
"
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
message
-
manager
-
close
"
)
{
this
.
outstanding
.
add
(
subject
)
;
}
else
if
(
topic
=
=
"
message
-
manager
-
disconnect
"
)
{
this
.
outstanding
.
delete
(
subject
)
;
if
(
!
this
.
outstanding
.
size
&
&
this
.
promiseResolver
)
{
this
.
promiseResolver
(
)
;
}
}
}
wait
(
)
{
if
(
!
this
.
outstanding
.
size
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
(
resolve
)
=
>
{
this
.
promiseResolver
=
resolve
;
}
)
;
}
}
;
function
testInit
(
)
{
gConfig
=
readConfig
(
)
;
if
(
gConfig
.
testRoot
=
=
"
browser
"
)
{
var
prefs
=
Services
.
prefs
;
if
(
prefs
.
prefHasUserValue
(
"
testing
.
browserTestHarness
.
running
"
)
)
return
;
prefs
.
setBoolPref
(
"
testing
.
browserTestHarness
.
running
"
true
)
;
if
(
prefs
.
prefHasUserValue
(
"
testing
.
browserTestHarness
.
timeout
"
)
)
gTimeoutSeconds
=
prefs
.
getIntPref
(
"
testing
.
browserTestHarness
.
timeout
"
)
;
var
sstring
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
sstring
.
data
=
location
.
search
;
Services
.
ww
.
openWindow
(
window
"
chrome
:
/
/
mochikit
/
content
/
browser
-
harness
.
xul
"
"
browserTest
"
"
chrome
centerscreen
dialog
=
no
resizable
titlebar
toolbar
=
no
width
=
800
height
=
600
"
sstring
)
;
}
else
{
let
messageHandler
=
function
(
m
)
{
messageManager
.
removeMessageListener
(
"
chromeEvent
"
messageHandler
)
;
var
url
=
m
.
json
.
data
;
var
webNav
=
content
.
window
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
let
loadURIOptions
=
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
;
webNav
.
loadURI
(
url
loadURIOptions
)
;
}
;
var
listener
=
'
data
:
function
doLoad
(
e
)
{
var
data
=
e
.
detail
&
&
e
.
detail
.
data
;
removeEventListener
(
"
contentEvent
"
function
(
e
)
{
doLoad
(
e
)
;
}
false
true
)
;
sendAsyncMessage
(
"
chromeEvent
"
{
"
data
"
:
data
}
)
;
}
;
addEventListener
(
"
contentEvent
"
function
(
e
)
{
doLoad
(
e
)
;
}
false
true
)
;
'
;
messageManager
.
addMessageListener
(
"
chromeEvent
"
messageHandler
)
;
messageManager
.
loadFrameScript
(
listener
true
)
;
}
if
(
gConfig
.
e10s
)
{
e10s_init
(
)
;
let
processCount
=
prefs
.
getIntPref
(
"
dom
.
ipc
.
processCount
"
1
)
;
if
(
processCount
>
1
)
{
prefs
.
setIntPref
(
"
dom
.
ipc
.
keepProcessesAlive
.
web
"
processCount
)
;
}
Services
.
mm
.
loadFrameScript
(
"
chrome
:
/
/
mochikit
/
content
/
shutdown
-
leaks
-
collector
.
js
"
true
)
;
}
else
{
ChromeUtils
.
import
(
"
chrome
:
/
/
mochikit
/
content
/
ShutdownLeaksCollector
.
jsm
"
)
;
}
Services
.
mm
.
loadFrameScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
AsyncUtilsContent
.
js
"
true
)
;
var
testSuite
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
.
get
(
"
TEST_SUITE
"
)
;
if
(
testSuite
=
=
"
browser
-
chrome
-
instrumentation
"
)
{
takeInstrumentation
(
)
;
}
}
function
takeInstrumentation
(
)
{
let
instrumentData
=
{
elements
:
{
}
}
;
function
pad
(
str
length
)
{
if
(
str
.
length
>
=
length
)
return
str
;
return
str
+
"
"
.
repeat
(
length
-
str
.
length
)
;
}
function
byCount
(
a
b
)
{
return
b
[
1
]
-
a
[
1
]
;
}
function
getSummaryText
(
)
{
let
summary
=
[
]
;
let
allData
=
{
}
;
for
(
let
selector
of
Object
.
keys
(
instrumentData
.
elements
)
)
{
allData
[
selector
]
=
instrumentData
.
elements
[
selector
]
;
}
let
selectors
=
Object
.
keys
(
allData
)
;
let
elements
=
selectors
.
map
(
s
=
>
allData
[
s
]
)
;
let
namespaceMap
=
new
Map
(
)
;
let
bindingMap
=
new
Map
(
)
;
for
(
let
element
of
elements
)
{
if
(
!
bindingMap
.
has
(
element
.
binding
)
)
{
bindingMap
.
set
(
element
.
binding
1
)
;
}
else
{
bindingMap
.
set
(
element
.
binding
bindingMap
.
get
(
element
.
binding
)
+
1
)
;
}
if
(
!
namespaceMap
.
has
(
element
.
namespaceURI
)
)
{
namespaceMap
.
set
(
element
.
namespaceURI
new
Map
(
)
)
;
}
let
localNameMap
=
namespaceMap
.
get
(
element
.
namespaceURI
)
;
if
(
!
localNameMap
.
has
(
element
.
localName
)
)
{
localNameMap
.
set
(
element
.
localName
1
)
;
}
else
{
localNameMap
.
set
(
element
.
localName
localNameMap
.
get
(
element
.
localName
)
+
1
)
;
}
}
for
(
let
[
namespace
localNameMap
]
of
namespaceMap
)
{
summary
.
push
(
Elements
in
namespace
{
namespace
}
)
;
let
entries
=
Array
.
from
(
localNameMap
)
;
entries
.
sort
(
byCount
)
;
for
(
let
entry
of
entries
)
{
summary
.
push
(
{
pad
(
entry
[
1
]
+
"
"
5
)
}
{
entry
[
0
]
}
)
;
}
}
summary
.
push
(
"
XBL
bindings
"
)
;
let
bindings
=
Array
.
from
(
bindingMap
)
;
bindings
.
sort
(
byCount
)
;
let
bindingsJSON
=
{
}
;
for
(
let
binding
of
bindings
)
{
summary
.
push
(
{
pad
(
binding
[
1
]
+
"
"
5
)
}
{
binding
[
0
]
}
)
;
if
(
binding
[
0
]
)
{
bindingsJSON
[
binding
[
0
]
.
split
(
"
#
"
)
[
1
]
.
split
(
'
"
'
)
[
0
]
]
=
binding
[
1
]
;
}
}
summary
.
push
(
"
XBL
bindings
as
JSON
"
)
;
summary
.
push
(
JSON
.
stringify
(
bindingsJSON
null
2
)
)
;
return
summary
.
join
(
"
\
n
"
)
;
}
function
saveData
(
)
{
let
path
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
.
get
(
"
MOZ_UPLOAD_DIR
"
)
;
let
encoder
=
new
TextEncoder
(
)
;
let
instrumentPath
=
OS
.
Path
.
join
(
path
"
xulinstrument
.
txt
"
)
;
OS
.
File
.
writeAtomic
(
instrumentPath
encoder
.
encode
(
JSON
.
stringify
(
instrumentData
null
2
)
)
)
;
let
summaryPath
=
OS
.
Path
.
join
(
path
"
xulsummary
.
txt
"
)
;
OS
.
File
.
writeAtomic
(
summaryPath
encoder
.
encode
(
getSummaryText
(
)
)
)
;
}
function
*
elementPath
(
element
)
{
yield
element
;
while
(
(
element
=
element
.
parentNode
)
&
&
(
element
instanceof
Element
)
)
{
yield
element
;
}
}
function
getElementInfo
(
element
)
{
let
style
=
element
.
ownerGlobal
.
getComputedStyle
(
element
)
;
let
binding
=
style
&
&
style
.
getPropertyValue
(
"
-
moz
-
binding
"
)
;
return
{
namespaceURI
:
element
.
namespaceURI
localName
:
element
.
localName
binding
:
(
binding
&
&
binding
!
=
"
none
"
)
?
binding
:
null
}
;
}
function
immediateSelector
(
element
)
{
if
(
element
.
localName
=
=
"
notificationbox
"
&
&
element
.
parentNode
&
&
element
.
parentNode
.
id
=
=
"
tabbrowser
-
tabpanels
"
)
{
return
element
.
localName
;
}
if
(
element
.
localName
=
=
"
tab
"
&
&
element
.
classList
.
contains
(
"
tabbrowser
-
tab
"
)
)
{
return
element
.
localName
;
}
if
(
element
.
id
)
{
return
#
{
element
.
id
}
;
}
let
selector
=
element
.
localName
;
if
(
element
.
classList
.
length
)
{
selector
+
=
.
{
Array
.
from
(
element
.
classList
)
.
join
(
"
.
"
)
}
;
}
for
(
let
attr
of
[
"
src
"
"
label
"
]
)
{
if
(
element
.
hasAttribute
(
attr
)
)
{
selector
+
=
[
{
attr
}
=
{
JSON
.
stringify
(
element
.
getAttribute
(
attr
)
)
}
]
;
}
}
return
selector
;
}
function
elementSelector
(
element
)
{
return
Array
.
from
(
elementPath
(
element
)
)
.
reverse
(
)
.
map
(
immediateSelector
)
.
join
(
"
>
"
)
;
}
function
*
windowElements
(
win
)
{
yield
*
elementDescendants
(
win
.
document
.
documentElement
)
;
}
function
*
elementDescendants
(
element
)
{
let
walker
=
Cc
[
"
mozilla
.
org
/
inspector
/
deep
-
tree
-
walker
;
1
"
]
.
createInstance
(
Ci
.
inIDeepTreeWalker
)
;
walker
.
showAnonymousContent
=
true
;
walker
.
showSubDocuments
=
false
;
walker
.
showDocumentsAsNodes
=
false
;
walker
.
init
(
element
NodeFilter
.
SHOW_ELEMENT
)
;
yield
element
;
while
(
walker
.
nextNode
(
)
)
{
if
(
walker
.
currentNode
instanceof
Element
)
{
yield
walker
.
currentNode
;
}
}
}
function
instrumentElement
(
element
)
{
if
(
element
.
__instrumentSeen
)
{
return
;
}
let
selector
=
elementSelector
(
element
)
;
element
.
__instrumentSeen
=
true
;
if
(
selector
in
instrumentData
.
elements
)
{
return
;
}
instrumentData
.
elements
[
selector
]
=
getElementInfo
(
element
)
;
}
function
scanWindow
(
win
)
{
Array
.
from
(
windowElements
(
win
)
)
.
forEach
(
instrumentElement
)
;
}
function
scanElement
(
element
)
{
Array
.
from
(
elementDescendants
(
element
)
)
.
forEach
(
instrumentElement
)
;
}
function
handleMutation
(
mutation
)
{
if
(
mutation
.
type
!
=
"
childList
"
)
{
return
;
}
for
(
let
node
of
mutation
.
addedNodes
)
{
if
(
node
instanceof
Element
)
{
scanElement
(
node
)
;
}
}
}
function
observeWindow
(
win
)
{
let
observer
=
new
MutationObserver
(
(
mutations
)
=
>
{
mutations
.
forEach
(
handleMutation
)
;
}
)
;
observer
.
observe
(
win
.
document
{
childList
:
true
subtree
:
true
}
)
;
win
.
addEventListener
(
"
unload
"
(
)
=
>
{
observer
.
takeRecords
(
)
.
forEach
(
handleMutation
)
;
}
{
once
:
true
}
)
;
}
scanWindow
(
window
)
;
observeWindow
(
window
)
;
gSaveInstrumentationData
=
saveData
;
Services
.
ww
.
registerNotification
(
(
win
topic
data
)
=
>
{
if
(
topic
!
=
"
domwindowopened
"
)
{
return
;
}
win
.
addEventListener
(
"
load
"
(
)
=
>
{
if
(
win
.
location
.
href
!
=
AppConstants
.
BROWSER_CHROME_URL
)
{
return
;
}
scanWindow
(
win
)
;
observeWindow
(
win
)
;
}
{
once
:
true
}
)
;
}
)
;
}
function
isGenerator
(
value
)
{
return
value
&
&
typeof
value
=
=
=
"
object
"
&
&
typeof
value
.
next
=
=
=
"
function
"
;
}
function
Tester
(
aTests
structuredLogger
aCallback
)
{
this
.
structuredLogger
=
structuredLogger
;
this
.
tests
=
aTests
;
this
.
callback
=
aCallback
;
this
.
_scriptLoader
=
Services
.
scriptloader
;
this
.
EventUtils
=
{
}
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
this
.
EventUtils
)
;
this
.
cpowSandbox
=
Cu
.
Sandbox
(
window
{
freshCompartment
:
true
sandboxPrototype
:
window
}
)
;
Cu
.
permitCPOWsInScope
(
this
.
cpowSandbox
)
;
this
.
cpowEventUtils
=
new
this
.
cpowSandbox
.
Object
(
)
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
this
.
cpowEventUtils
)
;
var
simpleTestScope
=
{
}
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
specialpowersAPI
.
js
"
simpleTestScope
)
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
SpecialPowersObserverAPI
.
js
"
simpleTestScope
)
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
ChromePowers
.
js
"
simpleTestScope
)
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
simpleTestScope
)
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
MemoryStats
.
js
"
simpleTestScope
)
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
chrome
-
harness
.
js
"
simpleTestScope
)
;
this
.
SimpleTest
=
simpleTestScope
.
SimpleTest
;
var
extensionUtilsScope
=
{
registerCleanupFunction
:
(
fn
)
=
>
{
this
.
currentTest
.
scope
.
registerCleanupFunction
(
fn
)
;
}
}
;
extensionUtilsScope
.
SimpleTest
=
this
.
SimpleTest
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
ExtensionTestUtils
.
js
"
extensionUtilsScope
)
;
this
.
ExtensionTestUtils
=
extensionUtilsScope
.
ExtensionTestUtils
;
this
.
SimpleTest
.
harnessParameters
=
gConfig
;
this
.
MemoryStats
=
simpleTestScope
.
MemoryStats
;
this
.
ContentTask
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTask
.
jsm
"
null
)
.
ContentTask
;
this
.
BrowserTestUtils
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
jsm
"
null
)
.
BrowserTestUtils
;
this
.
TestUtils
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
null
)
.
TestUtils
;
this
.
Promise
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
null
)
.
Promise
;
this
.
PromiseTestUtils
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
jsm
"
null
)
.
PromiseTestUtils
;
this
.
Assert
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Assert
.
jsm
"
null
)
.
Assert
;
this
.
PerTestCoverageUtils
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
PerTestCoverageUtils
.
jsm
"
null
)
.
PerTestCoverageUtils
;
this
.
PromiseTestUtils
.
init
(
)
;
this
.
SimpleTestOriginal
=
{
}
;
SIMPLETEST_OVERRIDES
.
forEach
(
m
=
>
{
this
.
SimpleTestOriginal
[
m
]
=
this
.
SimpleTest
[
m
]
;
}
)
;
this
.
_coverageCollector
=
null
;
const
XPCOMUtilsMod
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
null
)
;
XPCOMUtilsMod
.
Services
=
Object
.
create
(
Services
{
scriptloader
:
{
configurable
:
true
writable
:
true
value
:
{
loadSubScript
:
(
url
obj
)
=
>
{
let
before
=
Object
.
keys
(
window
)
;
try
{
return
this
.
_scriptLoader
.
loadSubScript
(
url
obj
)
;
}
finally
{
for
(
let
property
of
Object
.
keys
(
window
)
)
{
if
(
!
before
.
includes
(
property
)
&
&
!
this
.
_globalProperties
.
includes
(
property
)
)
{
this
.
_globalProperties
.
push
(
property
)
;
this
.
SimpleTest
.
info
(
"
Global
property
added
while
loading
"
+
url
+
"
:
"
+
property
)
;
}
}
}
}
loadSubScriptWithOptions
:
this
.
_scriptLoader
.
loadSubScriptWithOptions
.
bind
(
this
.
_scriptLoader
)
}
}
}
)
;
}
Tester
.
prototype
=
{
EventUtils
:
{
}
SimpleTest
:
{
}
ContentTask
:
null
ExtensionTestUtils
:
null
Assert
:
null
repeat
:
0
runUntilFailure
:
false
checker
:
null
currentTestIndex
:
-
1
lastStartTime
:
null
lastAssertionCount
:
0
failuresFromInitialWindowState
:
0
get
currentTest
(
)
{
return
this
.
tests
[
this
.
currentTestIndex
]
;
}
get
done
(
)
{
return
(
this
.
currentTestIndex
=
=
this
.
tests
.
length
-
1
)
&
&
(
this
.
repeat
<
=
0
)
;
}
start
:
function
Tester_start
(
)
{
TabDestroyObserver
.
init
(
)
;
if
(
!
gConfig
)
gConfig
=
readConfig
(
)
;
if
(
gConfig
.
runUntilFailure
)
this
.
runUntilFailure
=
true
;
if
(
gConfig
.
repeat
)
this
.
repeat
=
gConfig
.
repeat
;
if
(
gConfig
.
jscovDirPrefix
)
{
let
coveragePath
=
gConfig
.
jscovDirPrefix
;
let
{
CoverageCollector
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
CoverageUtils
.
jsm
"
)
;
this
.
_coverageCollector
=
new
CoverageCollector
(
coveragePath
)
;
}
this
.
structuredLogger
.
info
(
"
*
*
*
Start
BrowserChrome
Test
Results
*
*
*
"
)
;
Services
.
console
.
registerListener
(
this
)
;
this
.
_globalProperties
=
Object
.
keys
(
window
)
;
this
.
_globalPropertyWhitelist
=
[
"
navigator
"
"
constructor
"
"
top
"
"
Application
"
"
__SS_tabsToRestore
"
"
__SSi
"
"
webConsoleCommandController
"
"
MailMigrator
"
"
SearchIntegration
"
]
;
this
.
PerTestCoverageUtils
.
beforeTestSync
(
)
;
if
(
this
.
tests
.
length
)
{
this
.
waitForWindowsReady
(
)
.
then
(
(
)
=
>
{
this
.
nextTest
(
)
;
}
)
;
}
else
{
this
.
finish
(
)
;
}
}
async
waitForWindowsReady
(
)
{
await
new
Promise
(
resolve
=
>
this
.
waitForGraphicsTestWindowToBeGone
(
resolve
)
)
;
await
this
.
promiseMainWindowReady
(
)
;
}
async
promiseMainWindowReady
(
)
{
if
(
window
.
gBrowserInit
&
&
!
gBrowserInit
.
idleTasksFinished
)
{
await
this
.
TestUtils
.
topicObserved
(
"
browser
-
idle
-
startup
-
tasks
-
finished
"
subject
=
>
subject
=
=
=
window
)
;
}
}
waitForGraphicsTestWindowToBeGone
(
aCallback
)
{
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
if
(
win
!
=
window
&
&
!
win
.
closed
&
&
win
.
document
.
documentURI
=
=
"
chrome
:
/
/
gfxsanity
/
content
/
sanityparent
.
html
"
)
{
this
.
BrowserTestUtils
.
domWindowClosed
(
win
)
.
then
(
aCallback
)
;
return
;
}
}
aCallback
(
)
;
}
waitForWindowsState
:
function
Tester_waitForWindowsState
(
aCallback
)
{
let
timedOut
=
this
.
currentTest
&
&
this
.
currentTest
.
timedOut
;
let
baseMsg
=
timedOut
?
"
Found
a
{
elt
}
after
previous
test
timed
out
"
:
this
.
currentTest
?
"
Found
an
unexpected
{
elt
}
at
the
end
of
test
run
"
:
"
Found
an
unexpected
{
elt
}
"
;
if
(
this
.
currentTest
&
&
window
.
gBrowser
&
&
gBrowser
.
tabs
.
length
>
1
)
{
while
(
gBrowser
.
tabs
.
length
>
1
)
{
let
lastTab
=
gBrowser
.
tabContainer
.
lastElementChild
;
if
(
!
lastTab
.
closing
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
baseMsg
.
replace
(
"
{
elt
}
"
"
tab
"
)
+
"
:
"
+
lastTab
.
linkedBrowser
.
currentURI
.
spec
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
gBrowser
.
removeTab
(
lastTab
)
;
}
}
if
(
window
.
gBrowser
)
{
gBrowser
.
addTab
(
"
about
:
blank
"
{
skipAnimation
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
gBrowser
.
removeTab
(
gBrowser
.
selectedTab
{
skipPermitUnload
:
true
}
)
;
gBrowser
.
stop
(
)
;
}
this
.
structuredLogger
.
info
(
"
checking
window
state
"
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
let
type
=
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
if
(
win
!
=
window
&
&
!
win
.
closed
&
&
win
.
document
.
documentElement
.
getAttribute
(
"
id
"
)
!
=
"
browserTestHarness
"
&
&
type
!
=
"
devtools
:
webconsole
"
)
{
switch
(
type
)
{
case
"
navigator
:
browser
"
:
type
=
"
browser
window
"
;
break
;
case
"
mail
:
3pane
"
:
type
=
"
mail
window
"
;
break
;
case
null
:
type
=
"
unknown
window
with
document
URI
:
"
+
win
.
document
.
documentURI
+
"
and
title
:
"
+
win
.
document
.
title
;
break
;
}
let
msg
=
baseMsg
.
replace
(
"
{
elt
}
"
type
)
;
if
(
this
.
currentTest
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
msg
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
else
{
this
.
failuresFromInitialWindowState
+
+
;
this
.
structuredLogger
.
error
(
"
browser
-
test
.
js
|
"
+
msg
)
;
}
win
.
close
(
)
;
}
}
this
.
SimpleTest
.
waitForFocus
(
aCallback
)
;
}
finish
:
function
Tester_finish
(
aSkipSummary
)
{
var
passCount
=
this
.
tests
.
reduce
(
(
a
f
)
=
>
a
+
f
.
passCount
0
)
;
var
failCount
=
this
.
tests
.
reduce
(
(
a
f
)
=
>
a
+
f
.
failCount
0
)
;
var
todoCount
=
this
.
tests
.
reduce
(
(
a
f
)
=
>
a
+
f
.
todoCount
0
)
;
failCount
+
=
this
.
failuresFromInitialWindowState
;
TabDestroyObserver
.
destroy
(
)
;
Services
.
console
.
unregisterListener
(
this
)
;
this
.
PromiseTestUtils
.
uninit
(
)
;
let
pid
=
Services
.
appinfo
.
processID
;
dump
(
"
Completed
ShutdownLeaks
collections
in
process
"
+
pid
+
"
\
n
"
)
;
this
.
structuredLogger
.
info
(
"
TEST
-
START
|
Shutdown
"
)
;
if
(
this
.
tests
.
length
)
{
let
e10sMode
=
window
.
gMultiProcessBrowser
?
"
e10s
"
:
"
non
-
e10s
"
;
this
.
structuredLogger
.
info
(
"
Browser
Chrome
Test
Summary
"
)
;
this
.
structuredLogger
.
info
(
"
Passed
:
"
+
passCount
)
;
this
.
structuredLogger
.
info
(
"
Failed
:
"
+
failCount
)
;
this
.
structuredLogger
.
info
(
"
Todo
:
"
+
todoCount
)
;
this
.
structuredLogger
.
info
(
"
Mode
:
"
+
e10sMode
)
;
}
else
{
this
.
structuredLogger
.
error
(
"
browser
-
test
.
js
|
No
tests
to
run
.
Did
you
pass
invalid
test_paths
?
"
)
;
}
this
.
structuredLogger
.
info
(
"
*
*
*
End
BrowserChrome
Test
Results
*
*
*
"
)
;
this
.
callback
(
this
.
tests
)
;
this
.
callback
=
null
;
this
.
tests
=
null
;
if
(
gSaveInstrumentationData
)
{
gSaveInstrumentationData
(
)
;
}
}
haltTests
:
function
Tester_haltTests
(
)
{
this
.
currentTestIndex
=
this
.
tests
.
length
-
1
;
this
.
repeat
=
0
;
}
observe
:
function
Tester_observe
(
aSubject
aTopic
aData
)
{
if
(
!
aTopic
)
{
this
.
onConsoleMessage
(
aSubject
)
;
}
}
onConsoleMessage
:
function
Tester_onConsoleMessage
(
aConsoleMessage
)
{
if
(
!
aConsoleMessage
.
message
)
return
;
try
{
var
msg
=
"
Console
message
:
"
+
aConsoleMessage
.
message
;
if
(
this
.
currentTest
)
this
.
currentTest
.
addResult
(
new
testMessage
(
msg
)
)
;
else
this
.
structuredLogger
.
info
(
"
TEST
-
INFO
|
(
browser
-
test
.
js
)
|
"
+
msg
.
replace
(
/
\
n
/
"
"
)
+
"
\
n
"
)
;
}
catch
(
ex
)
{
}
}
async
nextTest
(
)
{
if
(
this
.
currentTest
)
{
if
(
this
.
_coverageCollector
)
{
this
.
_coverageCollector
.
recordTestCoverage
(
this
.
currentTest
.
path
)
;
}
this
.
PerTestCoverageUtils
.
afterTestSync
(
)
;
let
testScope
=
this
.
currentTest
.
scope
;
while
(
testScope
.
__cleanupFunctions
.
length
>
0
)
{
let
func
=
testScope
.
__cleanupFunctions
.
shift
(
)
;
try
{
let
result
=
await
func
.
apply
(
testScope
)
;
if
(
isGenerator
(
result
)
)
{
this
.
SimpleTest
.
ok
(
false
"
Cleanup
function
returned
a
generator
"
)
;
}
}
catch
(
ex
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Cleanup
function
threw
an
exception
"
ex
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
}
if
(
this
.
currentTest
.
passCount
=
=
=
0
&
&
this
.
currentTest
.
failCount
=
=
=
0
&
&
this
.
currentTest
.
todoCount
=
=
=
0
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
This
test
contains
no
passes
no
fails
and
no
todos
.
Maybe
"
+
"
it
threw
a
silent
exception
?
Make
sure
you
use
"
+
"
waitForExplicitFinish
(
)
if
you
need
it
.
"
}
)
)
;
}
let
winUtils
=
window
.
windowUtils
;
if
(
winUtils
.
isTestControllingRefreshes
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
test
left
refresh
driver
under
test
control
"
}
)
)
;
winUtils
.
restoreNormalRefresh
(
)
;
}
if
(
this
.
SimpleTest
.
isExpectingUncaughtException
(
)
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
expectUncaughtException
was
called
but
no
uncaught
"
+
"
exception
was
detected
!
"
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
this
.
PromiseTestUtils
.
ensureDOMPromiseRejectionsProcessed
(
)
;
this
.
PromiseTestUtils
.
assertNoUncaughtRejections
(
)
;
this
.
PromiseTestUtils
.
assertNoMoreExpectedRejections
(
)
;
Object
.
keys
(
window
)
.
forEach
(
function
(
prop
)
{
if
(
parseInt
(
prop
)
=
=
prop
)
{
return
;
}
if
(
!
this
.
_globalProperties
.
includes
(
prop
)
)
{
this
.
_globalProperties
.
push
(
prop
)
;
if
(
!
this
.
_globalPropertyWhitelist
.
includes
(
prop
)
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
test
left
unexpected
property
on
window
:
"
+
prop
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
}
}
this
)
;
document
.
popupNode
=
null
;
await
new
Promise
(
resolve
=
>
SpecialPowers
.
flushPrefEnv
(
resolve
)
)
;
if
(
gConfig
.
cleanupCrashes
)
{
let
gdir
=
Services
.
dirsvc
.
get
(
"
UAppData
"
Ci
.
nsIFile
)
;
gdir
.
append
(
"
Crash
Reports
"
)
;
gdir
.
append
(
"
pending
"
)
;
if
(
gdir
.
exists
(
)
)
{
let
entries
=
gdir
.
directoryEntries
;
while
(
entries
.
hasMoreElements
(
)
)
{
let
entry
=
entries
.
nextFile
;
if
(
entry
.
isFile
(
)
)
{
let
msg
=
"
this
test
left
a
pending
crash
report
;
"
;
try
{
entry
.
remove
(
false
)
;
msg
+
=
"
deleted
"
+
entry
.
path
;
}
catch
(
e
)
{
msg
+
=
"
could
not
delete
"
+
entry
.
path
;
}
this
.
structuredLogger
.
info
(
msg
)
;
}
}
}
}
if
(
this
.
currentTest
.
unexpectedTimeouts
&
&
!
this
.
currentTest
.
timedOut
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
This
test
exceeded
the
timeout
threshold
.
It
should
be
"
+
"
rewritten
or
split
up
.
If
that
'
s
not
possible
use
"
+
"
requestLongerTimeout
(
N
)
but
only
as
a
last
resort
.
"
}
)
)
;
}
let
debugsvc
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
if
(
debugsvc
.
isDebugBuild
)
{
let
newAssertionCount
=
debugsvc
.
assertionCount
;
let
numAsserts
=
newAssertionCount
-
this
.
lastAssertionCount
;
this
.
lastAssertionCount
=
newAssertionCount
;
let
max
=
testScope
.
__expectedMaxAsserts
;
let
min
=
testScope
.
__expectedMinAsserts
;
if
(
numAsserts
>
max
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Assertion
count
"
+
numAsserts
+
"
is
greater
than
expected
range
"
+
min
+
"
-
"
+
max
+
"
assertions
.
"
pass
:
true
todo
:
true
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
else
if
(
numAsserts
<
min
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Assertion
count
"
+
numAsserts
+
"
is
less
than
expected
range
"
+
min
+
"
-
"
+
max
+
"
assertions
.
"
todo
:
true
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
else
if
(
numAsserts
>
0
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Assertion
count
"
+
numAsserts
+
"
is
within
expected
range
"
+
min
+
"
-
"
+
max
+
"
assertions
.
"
pass
:
true
todo
:
true
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
}
if
(
this
.
currentTest
.
allowFailure
)
{
if
(
this
.
currentTest
.
expectedAllowedFailureCount
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Expected
"
+
this
.
currentTest
.
expectedAllowedFailureCount
+
"
failures
in
this
file
got
"
+
this
.
currentTest
.
allowedFailureCount
+
"
.
"
pass
:
this
.
currentTest
.
expectedAllowedFailureCount
=
=
this
.
currentTest
.
allowedFailureCount
}
)
)
;
}
else
if
(
this
.
currentTest
.
allowedFailureCount
=
=
0
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
We
expect
at
least
one
assertion
to
fail
because
this
"
+
"
test
file
is
marked
as
fail
-
if
in
the
manifest
.
"
todo
:
true
}
)
)
;
}
}
if
(
Services
.
appinfo
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
)
{
this
.
MemoryStats
.
dump
(
this
.
currentTestIndex
this
.
currentTest
.
path
gConfig
.
dumpOutputDirectory
gConfig
.
dumpAboutMemoryAfterTest
gConfig
.
dumpDMDAfterTest
)
;
}
let
time
=
Date
.
now
(
)
-
this
.
lastStartTime
;
this
.
structuredLogger
.
testEnd
(
this
.
currentTest
.
path
"
OK
"
undefined
"
finished
in
"
+
time
+
"
ms
"
)
;
this
.
currentTest
.
setDuration
(
time
)
;
if
(
this
.
runUntilFailure
&
&
this
.
currentTest
.
failCount
>
0
)
{
this
.
haltTests
(
)
;
}
SIMPLETEST_OVERRIDES
.
forEach
(
m
=
>
{
this
.
SimpleTest
[
m
]
=
this
.
SimpleTestOriginal
[
m
]
;
}
)
;
this
.
ContentTask
.
setTestScope
(
null
)
;
testScope
.
destroy
(
)
;
this
.
currentTest
.
scope
=
null
;
}
this
.
waitForWindowsState
(
(
)
=
>
{
if
(
this
.
done
)
{
if
(
this
.
_coverageCollector
)
{
this
.
_coverageCollector
.
finalize
(
)
;
}
if
(
gConfig
.
testRoot
=
=
"
browser
"
)
{
if
(
AppConstants
.
MOZ_APP_NAME
!
=
"
seamonkey
"
)
{
let
sidebar
=
document
.
getElementById
(
"
sidebar
"
)
;
if
(
sidebar
)
{
sidebar
.
setAttribute
(
"
src
"
"
data
:
text
/
html
;
charset
=
utf
-
8
"
)
;
sidebar
.
docShell
.
createAboutBlankContentViewer
(
null
)
;
sidebar
.
setAttribute
(
"
src
"
"
about
:
blank
"
)
;
}
}
let
{
BackgroundPageThumbs
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
BackgroundPageThumbs
.
jsm
"
)
;
BackgroundPageThumbs
.
_destroy
(
)
;
if
(
window
.
gBrowser
)
{
gBrowser
.
removePreloadedBrowser
(
)
;
}
}
let
shutdownCleanup
=
aCallback
=
>
{
Cu
.
schedulePreciseShrinkingGC
(
(
)
=
>
{
let
numCycles
=
3
;
for
(
let
i
=
0
;
i
<
numCycles
;
i
+
+
)
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
}
aCallback
(
)
;
}
)
;
}
;
let
{
AsyncShutdown
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
let
barrier
=
new
AsyncShutdown
.
Barrier
(
"
ShutdownLeaks
:
Wait
for
cleanup
to
be
finished
before
checking
for
leaks
"
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
barrier
}
"
shutdown
-
leaks
-
before
-
check
"
)
;
barrier
.
client
.
addBlocker
(
"
ShutdownLeaks
:
Wait
for
tabs
to
finish
closing
"
TabDestroyObserver
.
wait
(
)
)
;
barrier
.
wait
(
)
.
then
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
"
memory
-
pressure
"
"
heap
-
minimize
"
)
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
browser
-
test
:
collect
-
request
"
)
;
shutdownCleanup
(
(
)
=
>
{
setTimeout
(
(
)
=
>
{
shutdownCleanup
(
(
)
=
>
{
this
.
finish
(
)
;
}
)
;
}
1000
)
;
}
)
;
}
)
;
return
;
}
if
(
this
.
repeat
>
0
)
{
-
-
this
.
repeat
;
if
(
this
.
currentTestIndex
<
0
)
{
this
.
currentTestIndex
=
0
;
}
this
.
execTest
(
)
;
}
else
{
this
.
currentTestIndex
+
+
;
if
(
gConfig
.
repeat
)
this
.
repeat
=
gConfig
.
repeat
;
this
.
execTest
(
)
;
}
}
)
;
}
execTest
:
function
Tester_execTest
(
)
{
this
.
structuredLogger
.
testStart
(
this
.
currentTest
.
path
)
;
this
.
SimpleTest
.
reset
(
)
;
let
currentScope
=
this
.
currentTest
.
scope
=
new
testScope
(
this
this
.
currentTest
this
.
currentTest
.
expected
)
;
let
currentTest
=
this
.
currentTest
;
let
{
scope
}
=
this
.
currentTest
;
scope
.
EventUtils
=
this
.
currentTest
.
usesUnsafeCPOWs
?
this
.
cpowEventUtils
:
this
.
EventUtils
;
scope
.
SimpleTest
=
this
.
SimpleTest
;
scope
.
gTestPath
=
this
.
currentTest
.
path
;
scope
.
ContentTask
=
this
.
ContentTask
;
scope
.
BrowserTestUtils
=
this
.
BrowserTestUtils
;
scope
.
TestUtils
=
this
.
TestUtils
;
scope
.
ExtensionTestUtils
=
this
.
ExtensionTestUtils
;
scope
.
Assert
=
new
this
.
Assert
(
function
(
err
message
stack
)
{
currentTest
.
addResult
(
new
testResult
(
err
?
{
name
:
err
.
message
ex
:
err
.
stack
stack
:
err
.
stack
allowFailure
:
currentTest
.
allowFailure
}
:
{
name
:
message
pass
:
true
stack
allowFailure
:
currentTest
.
allowFailure
}
)
)
;
}
true
)
;
this
.
ContentTask
.
setTestScope
(
currentScope
)
;
scope
.
export_assertions
=
function
(
)
{
for
(
let
func
in
this
.
Assert
)
{
this
[
func
]
=
this
.
Assert
[
func
]
.
bind
(
this
.
Assert
)
;
}
}
;
SIMPLETEST_OVERRIDES
.
forEach
(
function
(
m
)
{
this
.
SimpleTest
[
m
]
=
this
[
m
]
;
}
scope
)
;
try
{
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
chrome
-
harness
.
js
"
scope
)
;
}
catch
(
ex
)
{
}
var
currentTestDirPath
=
this
.
currentTest
.
path
.
substr
(
0
this
.
currentTest
.
path
.
lastIndexOf
(
"
/
"
)
)
;
var
headPath
=
currentTestDirPath
+
"
/
head
.
js
"
;
try
{
this
.
_scriptLoader
.
loadSubScript
(
headPath
scope
)
;
}
catch
(
ex
)
{
const
isImportError
=
/
^
Error
opening
input
stream
/
.
test
(
ex
.
toString
(
)
)
;
const
containsHeadPath
=
ex
.
toString
(
)
.
includes
(
headPath
)
;
if
(
!
isImportError
|
|
!
containsHeadPath
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
head
.
js
import
threw
an
exception
"
ex
}
)
)
;
}
}
try
{
this
.
_scriptLoader
.
loadSubScript
(
this
.
currentTest
.
path
scope
)
;
this
.
lastStartTime
=
Date
.
now
(
)
;
if
(
this
.
currentTest
.
scope
.
__tasks
)
{
if
(
"
test
"
in
this
.
currentTest
.
scope
)
{
throw
"
Cannot
run
both
a
add_task
test
and
a
normal
test
at
the
same
time
.
"
;
}
let
PromiseTestUtils
=
this
.
PromiseTestUtils
;
let
skipTask
=
(
task
)
=
>
{
let
logger
=
this
.
structuredLogger
;
logger
.
deactivateBuffering
(
)
;
logger
.
testStatus
(
this
.
currentTest
.
path
task
.
name
"
SKIP
"
)
;
logger
.
warning
(
"
Skipping
test
"
+
task
.
name
)
;
logger
.
activateBuffering
(
)
;
}
;
(
async
function
(
)
{
let
task
;
while
(
(
task
=
this
.
__tasks
.
shift
(
)
)
)
{
if
(
task
.
__skipMe
|
|
(
this
.
__runOnlyThisTask
&
&
task
!
=
this
.
__runOnlyThisTask
)
)
{
skipTask
(
task
)
;
continue
;
}
this
.
SimpleTest
.
info
(
"
Entering
test
"
+
task
.
name
)
;
try
{
let
result
=
await
task
(
)
;
if
(
isGenerator
(
result
)
)
{
this
.
SimpleTest
.
ok
(
false
"
Task
returned
a
generator
"
)
;
}
}
catch
(
ex
)
{
if
(
currentTest
.
timedOut
)
{
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Uncaught
exception
received
from
previously
timed
out
test
"
pass
:
false
ex
stack
:
(
typeof
ex
=
=
"
object
"
&
&
"
stack
"
in
ex
)
?
ex
.
stack
:
null
allowFailure
:
currentTest
.
allowFailure
}
)
)
;
return
;
}
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Uncaught
exception
"
pass
:
this
.
SimpleTest
.
isExpectingUncaughtException
(
)
ex
stack
:
(
typeof
ex
=
=
"
object
"
&
&
"
stack
"
in
ex
)
?
ex
.
stack
:
null
allowFailure
:
currentTest
.
allowFailure
}
)
)
;
}
PromiseTestUtils
.
assertNoUncaughtRejections
(
)
;
this
.
SimpleTest
.
info
(
"
Leaving
test
"
+
task
.
name
)
;
}
this
.
finish
(
)
;
}
)
.
call
(
currentScope
)
;
}
else
if
(
typeof
scope
.
test
=
=
"
function
"
)
{
scope
.
test
(
)
;
}
else
{
throw
"
This
test
didn
'
t
call
add_task
nor
did
it
define
a
generatorTest
(
)
function
nor
did
it
define
a
test
(
)
function
so
we
don
'
t
know
how
to
run
it
.
"
;
}
}
catch
(
ex
)
{
if
(
!
this
.
SimpleTest
.
isIgnoringAllUncaughtExceptions
(
)
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Exception
thrown
"
pass
:
this
.
SimpleTest
.
isExpectingUncaughtException
(
)
ex
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
this
.
SimpleTest
.
expectUncaughtException
(
false
)
;
}
else
{
this
.
currentTest
.
addResult
(
new
testMessage
(
"
Exception
thrown
:
"
+
ex
)
)
;
}
this
.
currentTest
.
scope
.
finish
(
)
;
}
if
(
this
.
currentTest
.
scope
.
__done
)
{
this
.
nextTest
(
)
;
}
else
{
var
self
=
this
;
var
timeoutExpires
=
Date
.
now
(
)
+
gTimeoutSeconds
*
1000
;
var
waitUntilAtLeast
=
timeoutExpires
-
1000
;
this
.
currentTest
.
scope
.
__waitTimer
=
this
.
SimpleTest
.
_originalSetTimeout
.
apply
(
window
[
function
timeoutFn
(
)
{
if
(
Date
.
now
(
)
<
waitUntilAtLeast
)
{
self
.
currentTest
.
scope
.
__waitTimer
=
setTimeout
(
timeoutFn
timeoutExpires
-
Date
.
now
(
)
)
;
return
;
}
if
(
-
-
self
.
currentTest
.
scope
.
__timeoutFactor
>
0
)
{
self
.
currentTest
.
scope
.
info
(
"
Longer
timeout
required
waiting
longer
.
.
.
Remaining
timeouts
:
"
+
self
.
currentTest
.
scope
.
__timeoutFactor
)
;
self
.
currentTest
.
scope
.
__waitTimer
=
setTimeout
(
timeoutFn
gTimeoutSeconds
*
1000
)
;
return
;
}
const
MAX_UNEXPECTED_TIMEOUTS
=
10
;
if
(
Date
.
now
(
)
-
self
.
currentTest
.
lastOutputTime
<
(
gTimeoutSeconds
/
2
)
*
1000
&
&
+
+
self
.
currentTest
.
unexpectedTimeouts
<
=
MAX_UNEXPECTED_TIMEOUTS
)
{
self
.
currentTest
.
scope
.
__waitTimer
=
setTimeout
(
timeoutFn
gTimeoutSeconds
*
1000
)
;
return
;
}
self
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Test
timed
out
"
}
)
)
;
self
.
currentTest
.
timedOut
=
true
;
self
.
currentTest
.
scope
.
__waitTimer
=
null
;
self
.
nextTest
(
)
;
}
gTimeoutSeconds
*
1000
]
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIConsoleListener
"
]
)
}
;
function
testResult
(
{
name
pass
todo
ex
stack
allowFailure
}
)
{
this
.
info
=
false
;
this
.
name
=
name
;
this
.
msg
=
"
"
;
if
(
allowFailure
&
&
!
pass
)
{
this
.
allowedFailure
=
true
;
this
.
pass
=
true
;
this
.
todo
=
true
;
}
else
{
this
.
pass
=
!
!
pass
;
this
.
todo
=
todo
;
}
this
.
expected
=
this
.
todo
?
"
FAIL
"
:
"
PASS
"
;
if
(
this
.
pass
)
{
this
.
status
=
this
.
expected
;
return
;
}
this
.
status
=
this
.
todo
?
"
PASS
"
:
"
FAIL
"
;
if
(
ex
)
{
if
(
typeof
ex
=
=
"
object
"
&
&
"
fileName
"
in
ex
)
{
this
.
msg
+
=
"
at
"
+
ex
.
fileName
+
"
:
"
+
ex
.
lineNumber
+
"
-
"
;
}
this
.
msg
+
=
String
(
ex
)
;
}
if
(
stack
)
{
this
.
msg
+
=
"
\
nStack
trace
:
\
n
"
;
let
normalized
;
if
(
stack
instanceof
Ci
.
nsIStackFrame
)
{
let
frames
=
[
]
;
for
(
let
frame
=
stack
;
frame
;
frame
=
frame
.
asyncCaller
|
|
frame
.
caller
)
{
let
msg
=
{
frame
.
filename
}
:
{
frame
.
name
}
:
{
frame
.
lineNumber
}
;
frames
.
push
(
frame
.
asyncCause
?
{
frame
.
asyncCause
}
*
{
msg
}
:
msg
)
;
}
normalized
=
frames
.
join
(
"
\
n
"
)
;
}
else
{
normalized
=
"
"
+
stack
;
}
this
.
msg
+
=
normalized
;
}
if
(
gConfig
.
debugOnFailure
)
{
debugger
;
}
}
function
testMessage
(
msg
)
{
this
.
msg
=
msg
|
|
"
"
;
this
.
info
=
true
;
}
function
testScope
(
aTester
aTest
expected
)
{
this
.
__tester
=
aTester
;
aTest
.
allowFailure
=
expected
=
=
"
fail
"
;
var
self
=
this
;
this
.
ok
=
function
test_ok
(
condition
name
)
{
if
(
arguments
.
length
>
2
)
{
const
ex
=
"
Too
many
arguments
passed
to
ok
(
condition
name
)
.
"
;
self
.
record
(
false
name
ex
)
;
}
else
{
self
.
record
(
condition
name
)
;
}
}
;
this
.
record
=
function
test_record
(
condition
name
ex
stack
)
{
aTest
.
addResult
(
new
testResult
(
{
name
pass
:
condition
ex
stack
:
stack
|
|
Components
.
stack
.
caller
allowFailure
:
aTest
.
allowFailure
}
)
)
;
}
;
this
.
is
=
function
test_is
(
a
b
name
)
{
self
.
record
(
a
=
=
b
name
"
Got
"
+
a
+
"
expected
"
+
b
false
Components
.
stack
.
caller
)
;
}
;
this
.
isnot
=
function
test_isnot
(
a
b
name
)
{
self
.
record
(
a
!
=
b
name
"
Didn
'
t
expect
"
+
a
+
"
but
got
it
"
false
Components
.
stack
.
caller
)
;
}
;
this
.
todo
=
function
test_todo
(
condition
name
ex
stack
)
{
aTest
.
addResult
(
new
testResult
(
{
name
pass
:
!
condition
todo
:
true
ex
stack
:
stack
|
|
Components
.
stack
.
caller
allowFailure
:
aTest
.
allowFailure
}
)
)
;
}
;
this
.
todo_is
=
function
test_todo_is
(
a
b
name
)
{
self
.
todo
(
a
=
=
b
name
"
Got
"
+
a
+
"
expected
"
+
b
Components
.
stack
.
caller
)
;
}
;
this
.
todo_isnot
=
function
test_todo_isnot
(
a
b
name
)
{
self
.
todo
(
a
!
=
b
name
"
Didn
'
t
expect
"
+
a
+
"
but
got
it
"
Components
.
stack
.
caller
)
;
}
;
this
.
info
=
function
test_info
(
name
)
{
aTest
.
addResult
(
new
testMessage
(
name
)
)
;
}
;
this
.
executeSoon
=
function
test_executeSoon
(
func
)
{
Services
.
tm
.
dispatchToMainThread
(
{
run
(
)
{
func
(
)
;
}
}
)
;
}
;
this
.
waitForExplicitFinish
=
function
test_waitForExplicitFinish
(
)
{
self
.
__done
=
false
;
}
;
this
.
waitForFocus
=
function
test_waitForFocus
(
callback
targetWindow
expectBlankPage
)
{
self
.
SimpleTest
.
waitForFocus
(
callback
targetWindow
expectBlankPage
)
;
}
;
this
.
waitForClipboard
=
function
test_waitForClipboard
(
expected
setup
success
failure
flavor
)
{
self
.
SimpleTest
.
waitForClipboard
(
expected
setup
success
failure
flavor
)
;
}
;
this
.
registerCleanupFunction
=
function
test_registerCleanupFunction
(
aFunction
)
{
self
.
__cleanupFunctions
.
push
(
aFunction
)
;
}
;
this
.
requestLongerTimeout
=
function
test_requestLongerTimeout
(
aFactor
)
{
self
.
__timeoutFactor
=
aFactor
;
}
;
this
.
copyToProfile
=
function
test_copyToProfile
(
filename
)
{
self
.
SimpleTest
.
copyToProfile
(
filename
)
;
}
;
this
.
expectUncaughtException
=
function
test_expectUncaughtException
(
aExpecting
)
{
self
.
SimpleTest
.
expectUncaughtException
(
aExpecting
)
;
}
;
this
.
ignoreAllUncaughtExceptions
=
function
test_ignoreAllUncaughtExceptions
(
aIgnoring
)
{
self
.
SimpleTest
.
ignoreAllUncaughtExceptions
(
aIgnoring
)
;
}
;
this
.
expectAssertions
=
function
test_expectAssertions
(
aMin
aMax
)
{
let
min
=
aMin
;
let
max
=
aMax
;
if
(
typeof
(
max
)
=
=
"
undefined
"
)
{
max
=
min
;
}
if
(
typeof
(
min
)
!
=
"
number
"
|
|
typeof
(
max
)
!
=
"
number
"
|
|
min
<
0
|
|
max
<
min
)
{
throw
"
bad
parameter
to
expectAssertions
"
;
}
self
.
__expectedMinAsserts
=
min
;
self
.
__expectedMaxAsserts
=
max
;
}
;
this
.
setExpectedFailuresForSelfTest
=
function
test_setExpectedFailuresForSelfTest
(
expectedAllowedFailureCount
)
{
aTest
.
allowFailure
=
true
;
aTest
.
expectedAllowedFailureCount
=
expectedAllowedFailureCount
;
}
;
this
.
finish
=
function
test_finish
(
)
{
self
.
__done
=
true
;
if
(
self
.
__waitTimer
)
{
self
.
executeSoon
(
function
(
)
{
if
(
self
.
__done
&
&
self
.
__waitTimer
)
{
clearTimeout
(
self
.
__waitTimer
)
;
self
.
__waitTimer
=
null
;
self
.
__tester
.
nextTest
(
)
;
}
}
)
;
}
}
;
this
.
requestCompleteLog
=
function
test_requestCompleteLog
(
)
{
self
.
__tester
.
structuredLogger
.
deactivateBuffering
(
)
;
self
.
registerCleanupFunction
(
function
(
)
{
self
.
__tester
.
structuredLogger
.
activateBuffering
(
)
;
}
)
;
}
;
if
(
aTest
.
usesUnsafeCPOWs
)
{
let
sandbox
=
this
.
_createSandbox
(
)
;
Cu
.
permitCPOWsInScope
(
sandbox
)
;
return
sandbox
;
}
return
this
;
}
function
decorateTaskFn
(
fn
)
{
fn
=
fn
.
bind
(
this
)
;
fn
.
skip
=
(
)
=
>
fn
.
__skipMe
=
true
;
fn
.
only
=
(
)
=
>
this
.
__runOnlyThisTask
=
fn
;
return
fn
;
}
testScope
.
prototype
=
{
__done
:
true
__tasks
:
null
__runOnlyThisTask
:
null
__waitTimer
:
null
__cleanupFunctions
:
[
]
__timeoutFactor
:
1
__expectedMinAsserts
:
0
__expectedMaxAsserts
:
0
EventUtils
:
{
}
SimpleTest
:
{
}
ContentTask
:
null
BrowserTestUtils
:
null
TestUtils
:
null
ExtensionTestUtils
:
null
Assert
:
null
_createSandbox
(
)
{
let
sandbox
=
Cu
.
Sandbox
(
window
{
freshCompartment
:
true
sandboxPrototype
:
window
}
)
;
for
(
let
prop
in
this
)
{
if
(
typeof
this
[
prop
]
=
=
"
function
"
)
{
sandbox
[
prop
]
=
this
[
prop
]
.
bind
(
this
)
;
}
else
{
Object
.
defineProperty
(
sandbox
prop
{
configurable
:
true
enumerable
:
true
get
:
(
)
=
>
{
return
this
[
prop
]
;
}
set
:
(
value
)
=
>
{
this
[
prop
]
=
value
;
}
}
)
;
}
}
return
sandbox
;
}
add_task
(
aFunction
)
{
if
(
!
this
.
__tasks
)
{
this
.
waitForExplicitFinish
(
)
;
this
.
__tasks
=
[
]
;
}
let
bound
=
decorateTaskFn
.
call
(
this
aFunction
)
;
this
.
__tasks
.
push
(
bound
)
;
return
bound
;
}
destroy
:
function
test_destroy
(
)
{
for
(
let
prop
in
this
)
delete
this
[
prop
]
;
}
}
;
