var
gTimeoutSeconds
=
45
;
var
gConfig
;
var
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
const
SIMPLETEST_OVERRIDES
=
[
"
ok
"
"
record
"
"
is
"
"
isnot
"
"
todo
"
"
todo_is
"
"
todo_isnot
"
"
info
"
"
expectAssertions
"
"
requestCompleteLog
"
]
;
setTimeout
(
testInit
0
)
;
var
TabDestroyObserver
=
{
outstanding
:
new
Set
(
)
promiseResolver
:
null
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
close
"
)
;
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
disconnect
"
)
;
}
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
message
-
manager
-
close
"
)
;
Services
.
obs
.
removeObserver
(
this
"
message
-
manager
-
disconnect
"
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
message
-
manager
-
close
"
)
{
this
.
outstanding
.
add
(
subject
)
;
}
else
if
(
topic
=
=
"
message
-
manager
-
disconnect
"
)
{
this
.
outstanding
.
delete
(
subject
)
;
if
(
!
this
.
outstanding
.
size
&
&
this
.
promiseResolver
)
{
this
.
promiseResolver
(
)
;
}
}
}
wait
(
)
{
if
(
!
this
.
outstanding
.
size
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
this
.
promiseResolver
=
resolve
;
}
)
;
}
}
;
function
testInit
(
)
{
gConfig
=
readConfig
(
)
;
if
(
gConfig
.
testRoot
=
=
"
browser
"
)
{
var
prefs
=
Services
.
prefs
;
if
(
prefs
.
prefHasUserValue
(
"
testing
.
browserTestHarness
.
running
"
)
)
{
return
;
}
prefs
.
setBoolPref
(
"
testing
.
browserTestHarness
.
running
"
true
)
;
if
(
prefs
.
prefHasUserValue
(
"
testing
.
browserTestHarness
.
timeout
"
)
)
{
gTimeoutSeconds
=
prefs
.
getIntPref
(
"
testing
.
browserTestHarness
.
timeout
"
)
;
}
var
sstring
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
sstring
.
data
=
location
.
search
;
Services
.
ww
.
openWindow
(
window
"
chrome
:
/
/
mochikit
/
content
/
browser
-
harness
.
xhtml
"
"
browserTest
"
"
chrome
centerscreen
dialog
=
no
resizable
titlebar
toolbar
=
no
width
=
800
height
=
600
"
sstring
)
;
}
else
{
let
messageHandler
=
function
(
m
)
{
messageManager
.
removeMessageListener
(
"
chromeEvent
"
messageHandler
)
;
var
url
=
m
.
json
.
data
;
var
webNav
=
content
.
window
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
let
loadURIOptions
=
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
;
webNav
.
loadURI
(
url
loadURIOptions
)
;
}
;
var
listener
=
'
data
:
function
doLoad
(
e
)
{
var
data
=
e
.
detail
&
&
e
.
detail
.
data
;
removeEventListener
(
"
contentEvent
"
function
(
e
)
{
doLoad
(
e
)
;
}
false
true
)
;
sendAsyncMessage
(
"
chromeEvent
"
{
"
data
"
:
data
}
)
;
}
;
addEventListener
(
"
contentEvent
"
function
(
e
)
{
doLoad
(
e
)
;
}
false
true
)
;
'
;
messageManager
.
addMessageListener
(
"
chromeEvent
"
messageHandler
)
;
messageManager
.
loadFrameScript
(
listener
true
)
;
}
if
(
gConfig
.
e10s
)
{
e10s_init
(
)
;
let
processCount
=
prefs
.
getIntPref
(
"
dom
.
ipc
.
processCount
"
1
)
;
if
(
processCount
>
1
)
{
prefs
.
setIntPref
(
"
dom
.
ipc
.
keepProcessesAlive
.
web
"
processCount
)
;
}
Services
.
mm
.
loadFrameScript
(
"
chrome
:
/
/
mochikit
/
content
/
shutdown
-
leaks
-
collector
.
js
"
true
)
;
}
else
{
ChromeUtils
.
import
(
"
chrome
:
/
/
mochikit
/
content
/
ShutdownLeaksCollector
.
jsm
"
)
;
}
}
function
isGenerator
(
value
)
{
return
value
&
&
typeof
value
=
=
=
"
object
"
&
&
typeof
value
.
next
=
=
=
"
function
"
;
}
function
Tester
(
aTests
structuredLogger
aCallback
)
{
this
.
structuredLogger
=
structuredLogger
;
this
.
tests
=
aTests
;
this
.
callback
=
aCallback
;
this
.
_scriptLoader
=
Services
.
scriptloader
;
this
.
EventUtils
=
{
}
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
this
.
EventUtils
)
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
AccessibilityUtils
.
js
"
this
.
EventUtils
)
;
this
.
AccessibilityUtils
=
this
.
EventUtils
.
AccessibilityUtils
;
void
window
.
windowGlobalChild
.
getActor
(
"
SpecialPowers
"
)
;
var
simpleTestScope
=
{
}
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
simpleTestScope
)
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
MemoryStats
.
js
"
simpleTestScope
)
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
chrome
-
harness
.
js
"
simpleTestScope
)
;
this
.
SimpleTest
=
simpleTestScope
.
SimpleTest
;
window
.
SpecialPowers
.
SimpleTest
=
this
.
SimpleTest
;
window
.
SpecialPowers
.
setAsDefaultAssertHandler
(
)
;
var
extensionUtilsScope
=
{
registerCleanupFunction
:
fn
=
>
{
this
.
currentTest
.
scope
.
registerCleanupFunction
(
fn
)
;
}
}
;
extensionUtilsScope
.
SimpleTest
=
this
.
SimpleTest
;
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
ExtensionTestUtils
.
js
"
extensionUtilsScope
)
;
this
.
ExtensionTestUtils
=
extensionUtilsScope
.
ExtensionTestUtils
;
this
.
SimpleTest
.
harnessParameters
=
gConfig
;
this
.
MemoryStats
=
simpleTestScope
.
MemoryStats
;
this
.
ContentTask
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTask
.
jsm
"
)
.
ContentTask
;
this
.
BrowserTestUtils
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
jsm
"
)
.
BrowserTestUtils
;
this
.
TestUtils
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
.
TestUtils
;
this
.
PromiseTestUtils
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
jsm
"
)
.
PromiseTestUtils
;
this
.
Assert
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Assert
.
jsm
"
)
.
Assert
;
this
.
PerTestCoverageUtils
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
PerTestCoverageUtils
.
jsm
"
)
.
PerTestCoverageUtils
;
this
.
PromiseTestUtils
.
init
(
)
;
this
.
SimpleTestOriginal
=
{
}
;
SIMPLETEST_OVERRIDES
.
forEach
(
m
=
>
{
this
.
SimpleTestOriginal
[
m
]
=
this
.
SimpleTest
[
m
]
;
}
)
;
this
.
_coverageCollector
=
null
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
XPCOMUtils
.
overrideScriptLoaderForTests
(
{
loadSubScript
:
(
url
obj
)
=
>
{
let
before
=
Object
.
keys
(
window
)
;
try
{
return
this
.
_scriptLoader
.
loadSubScript
(
url
obj
)
;
}
finally
{
for
(
let
property
of
Object
.
keys
(
window
)
)
{
if
(
!
before
.
includes
(
property
)
&
&
!
this
.
_globalProperties
.
includes
(
property
)
)
{
this
.
_globalProperties
.
push
(
property
)
;
this
.
SimpleTest
.
info
(
Global
property
added
while
loading
{
url
}
:
{
property
}
)
;
}
}
}
}
loadSubScriptWithOptions
:
this
.
_scriptLoader
.
loadSubScriptWithOptions
.
bind
(
this
.
_scriptLoader
)
}
)
;
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
if
(
env
.
exists
(
"
MOZ_AUTOMATION
"
)
)
{
this
.
EventUtils
.
synthesizeNativeMouseEvent
(
{
type
:
"
mousemove
"
screenX
:
1000
screenY
:
10
}
)
;
}
}
Tester
.
prototype
=
{
EventUtils
:
{
}
AccessibilityUtils
:
{
}
SimpleTest
:
{
}
ContentTask
:
null
ExtensionTestUtils
:
null
Assert
:
null
repeat
:
0
a11y_checks
:
false
runUntilFailure
:
false
checker
:
null
currentTestIndex
:
-
1
lastStartTime
:
null
lastStartTimestamp
:
null
lastAssertionCount
:
0
failuresFromInitialWindowState
:
0
get
currentTest
(
)
{
return
this
.
tests
[
this
.
currentTestIndex
]
;
}
get
done
(
)
{
return
this
.
currentTestIndex
=
=
this
.
tests
.
length
-
1
&
&
this
.
repeat
<
=
0
;
}
start
:
function
Tester_start
(
)
{
TabDestroyObserver
.
init
(
)
;
if
(
!
gConfig
)
{
gConfig
=
readConfig
(
)
;
}
if
(
gConfig
.
runUntilFailure
)
{
this
.
runUntilFailure
=
true
;
}
if
(
gConfig
.
a11y_checks
!
=
undefined
)
{
this
.
a11y_checks
=
gConfig
.
a11y_checks
;
}
if
(
gConfig
.
repeat
)
{
this
.
repeat
=
gConfig
.
repeat
;
}
if
(
gConfig
.
jscovDirPrefix
)
{
let
coveragePath
=
gConfig
.
jscovDirPrefix
;
let
{
CoverageCollector
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
CoverageUtils
.
jsm
"
)
;
this
.
_coverageCollector
=
new
CoverageCollector
(
coveragePath
)
;
}
this
.
structuredLogger
.
info
(
"
*
*
*
Start
BrowserChrome
Test
Results
*
*
*
"
)
;
Services
.
console
.
registerListener
(
this
)
;
this
.
_globalProperties
=
Object
.
keys
(
window
)
;
this
.
_globalPropertyWhitelist
=
[
"
navigator
"
"
constructor
"
"
top
"
"
Application
"
"
__SS_tabsToRestore
"
"
__SSi
"
"
webConsoleCommandController
"
"
MailMigrator
"
"
SearchIntegration
"
]
;
this
.
PerTestCoverageUtils
.
beforeTestSync
(
)
;
if
(
this
.
tests
.
length
)
{
this
.
waitForWindowsReady
(
)
.
then
(
(
)
=
>
{
this
.
nextTest
(
)
;
}
)
;
}
else
{
this
.
finish
(
)
;
}
}
async
waitForWindowsReady
(
)
{
await
this
.
setupDefaultTheme
(
)
;
await
new
Promise
(
resolve
=
>
this
.
waitForGraphicsTestWindowToBeGone
(
resolve
)
)
;
await
this
.
promiseMainWindowReady
(
)
;
}
async
promiseMainWindowReady
(
)
{
if
(
window
.
gBrowserInit
)
{
await
window
.
gBrowserInit
.
idleTasksFinishedPromise
;
}
}
async
setupDefaultTheme
(
)
{
let
theme
=
await
AddonManager
.
getAddonByID
(
"
default
-
theme
mozilla
.
org
"
)
;
await
theme
.
enable
(
)
;
}
waitForGraphicsTestWindowToBeGone
(
aCallback
)
{
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
if
(
win
!
=
window
&
&
!
win
.
closed
&
&
win
.
document
.
documentURI
=
=
"
chrome
:
/
/
gfxsanity
/
content
/
sanityparent
.
html
"
)
{
this
.
BrowserTestUtils
.
domWindowClosed
(
win
)
.
then
(
aCallback
)
;
return
;
}
}
aCallback
(
)
;
}
waitForWindowsState
:
function
Tester_waitForWindowsState
(
aCallback
)
{
let
timedOut
=
this
.
currentTest
&
&
this
.
currentTest
.
timedOut
;
let
baseMsg
=
timedOut
?
"
Found
a
{
elt
}
after
previous
test
timed
out
"
:
this
.
currentTest
?
"
Found
an
unexpected
{
elt
}
at
the
end
of
test
run
"
:
"
Found
an
unexpected
{
elt
}
"
;
if
(
this
.
currentTest
&
&
window
.
gBrowser
&
&
AppConstants
.
MOZ_APP_NAME
!
=
"
thunderbird
"
&
&
gBrowser
.
tabs
.
length
>
1
)
{
while
(
gBrowser
.
tabs
.
length
>
1
)
{
let
lastTab
=
gBrowser
.
tabs
[
gBrowser
.
tabs
.
length
-
1
]
;
if
(
!
lastTab
.
closing
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
baseMsg
.
replace
(
"
{
elt
}
"
"
tab
"
)
+
"
:
"
+
lastTab
.
linkedBrowser
.
currentURI
.
spec
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
gBrowser
.
removeTab
(
lastTab
)
;
}
}
if
(
window
.
gBrowser
&
&
AppConstants
.
MOZ_APP_NAME
!
=
"
thunderbird
"
)
{
gBrowser
.
addTab
(
"
about
:
blank
"
{
skipAnimation
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
gBrowser
.
removeTab
(
gBrowser
.
selectedTab
{
skipPermitUnload
:
true
}
)
;
gBrowser
.
stop
(
)
;
}
this
.
structuredLogger
.
info
(
"
checking
window
state
"
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
let
type
=
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
if
(
win
!
=
window
&
&
!
win
.
closed
&
&
win
.
document
.
documentElement
.
getAttribute
(
"
id
"
)
!
=
"
browserTestHarness
"
&
&
type
!
=
"
devtools
:
webconsole
"
)
{
switch
(
type
)
{
case
"
navigator
:
browser
"
:
type
=
"
browser
window
"
;
break
;
case
"
mail
:
3pane
"
:
type
=
"
mail
window
"
;
break
;
case
null
:
type
=
"
unknown
window
with
document
URI
:
"
+
win
.
document
.
documentURI
+
"
and
title
:
"
+
win
.
document
.
title
;
break
;
}
let
msg
=
baseMsg
.
replace
(
"
{
elt
}
"
type
)
;
if
(
this
.
currentTest
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
msg
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
else
{
this
.
failuresFromInitialWindowState
+
+
;
this
.
structuredLogger
.
error
(
"
browser
-
test
.
js
|
"
+
msg
)
;
}
win
.
close
(
)
;
}
}
this
.
SimpleTest
.
waitForFocus
(
aCallback
)
;
}
finish
:
function
Tester_finish
(
aSkipSummary
)
{
var
passCount
=
this
.
tests
.
reduce
(
(
a
f
)
=
>
a
+
f
.
passCount
0
)
;
var
failCount
=
this
.
tests
.
reduce
(
(
a
f
)
=
>
a
+
f
.
failCount
0
)
;
var
todoCount
=
this
.
tests
.
reduce
(
(
a
f
)
=
>
a
+
f
.
todoCount
0
)
;
failCount
+
=
this
.
failuresFromInitialWindowState
;
TabDestroyObserver
.
destroy
(
)
;
Services
.
console
.
unregisterListener
(
this
)
;
this
.
PromiseTestUtils
.
uninit
(
)
;
let
pid
=
Services
.
appinfo
.
processID
;
dump
(
"
Completed
ShutdownLeaks
collections
in
process
"
+
pid
+
"
\
n
"
)
;
this
.
structuredLogger
.
info
(
"
TEST
-
START
|
Shutdown
"
)
;
if
(
this
.
tests
.
length
)
{
let
e10sMode
=
window
.
gMultiProcessBrowser
?
"
e10s
"
:
"
non
-
e10s
"
;
this
.
structuredLogger
.
info
(
"
Browser
Chrome
Test
Summary
"
)
;
this
.
structuredLogger
.
info
(
"
Passed
:
"
+
passCount
)
;
this
.
structuredLogger
.
info
(
"
Failed
:
"
+
failCount
)
;
this
.
structuredLogger
.
info
(
"
Todo
:
"
+
todoCount
)
;
this
.
structuredLogger
.
info
(
"
Mode
:
"
+
e10sMode
)
;
}
else
{
this
.
structuredLogger
.
error
(
"
browser
-
test
.
js
|
No
tests
to
run
.
Did
you
pass
invalid
test_paths
?
"
)
;
}
this
.
structuredLogger
.
info
(
"
*
*
*
End
BrowserChrome
Test
Results
*
*
*
"
)
;
this
.
callback
(
this
.
tests
)
;
this
.
accService
=
null
;
this
.
callback
=
null
;
this
.
tests
=
null
;
}
haltTests
:
function
Tester_haltTests
(
)
{
this
.
currentTestIndex
=
this
.
tests
.
length
-
1
;
this
.
repeat
=
0
;
}
observe
:
function
Tester_observe
(
aSubject
aTopic
aData
)
{
if
(
!
aTopic
)
{
this
.
onConsoleMessage
(
aSubject
)
;
}
}
onConsoleMessage
:
function
Tester_onConsoleMessage
(
aConsoleMessage
)
{
if
(
!
aConsoleMessage
.
message
)
{
return
;
}
try
{
var
msg
=
"
Console
message
:
"
+
aConsoleMessage
.
message
;
if
(
this
.
currentTest
)
{
this
.
currentTest
.
addResult
(
new
testMessage
(
msg
)
)
;
}
else
{
this
.
structuredLogger
.
info
(
"
TEST
-
INFO
|
(
browser
-
test
.
js
)
|
"
+
msg
.
replace
(
/
\
n
/
"
"
)
+
"
\
n
"
)
;
}
}
catch
(
ex
)
{
}
}
async
ensureVsyncDisabled
(
)
{
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
if
(
env
.
get
(
"
MOZ_HEADLESS
"
)
)
{
return
;
}
try
{
await
this
.
TestUtils
.
waitForCondition
(
(
)
=
>
!
ChromeUtils
.
vsyncEnabled
(
)
"
waiting
for
vsync
to
be
disabled
"
)
;
}
catch
(
e
)
{
this
.
Assert
.
ok
(
false
e
)
;
this
.
Assert
.
ok
(
false
"
vsync
remained
enabled
at
the
end
of
the
test
.
"
+
"
Is
there
an
animation
still
running
?
"
+
"
Consider
talking
to
the
performance
team
for
tips
to
solve
this
.
"
)
;
}
}
async
nextTest
(
)
{
if
(
this
.
currentTest
)
{
if
(
this
.
_coverageCollector
)
{
this
.
_coverageCollector
.
recordTestCoverage
(
this
.
currentTest
.
path
)
;
}
this
.
PerTestCoverageUtils
.
afterTestSync
(
)
;
let
testScope
=
this
.
currentTest
.
scope
;
while
(
testScope
.
__cleanupFunctions
.
length
)
{
let
func
=
testScope
.
__cleanupFunctions
.
shift
(
)
;
try
{
let
result
=
await
func
.
apply
(
testScope
)
;
if
(
isGenerator
(
result
)
)
{
this
.
SimpleTest
.
ok
(
false
"
Cleanup
function
returned
a
generator
"
)
;
}
}
catch
(
ex
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Cleanup
function
threw
an
exception
"
ex
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
}
if
(
typeof
gReduceMotionOverride
=
=
"
boolean
"
)
{
gReduceMotionOverride
=
null
;
}
Services
.
obs
.
notifyObservers
(
null
"
test
-
complete
"
)
;
if
(
this
.
currentTest
.
passCount
=
=
=
0
&
&
this
.
currentTest
.
failCount
=
=
=
0
&
&
this
.
currentTest
.
todoCount
=
=
=
0
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
This
test
contains
no
passes
no
fails
and
no
todos
.
Maybe
"
+
"
it
threw
a
silent
exception
?
Make
sure
you
use
"
+
"
waitForExplicitFinish
(
)
if
you
need
it
.
"
}
)
)
;
}
let
winUtils
=
window
.
windowUtils
;
if
(
winUtils
.
isTestControllingRefreshes
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
test
left
refresh
driver
under
test
control
"
}
)
)
;
winUtils
.
restoreNormalRefresh
(
)
;
}
if
(
this
.
SimpleTest
.
isExpectingUncaughtException
(
)
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
expectUncaughtException
was
called
but
no
uncaught
"
+
"
exception
was
detected
!
"
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
this
.
resolveFinishTestPromise
(
)
;
this
.
resolveFinishTestPromise
=
null
;
this
.
TestUtils
.
promiseTestFinished
=
null
;
this
.
PromiseTestUtils
.
ensureDOMPromiseRejectionsProcessed
(
)
;
this
.
PromiseTestUtils
.
assertNoUncaughtRejections
(
)
;
this
.
PromiseTestUtils
.
assertNoMoreExpectedRejections
(
)
;
await
this
.
ensureVsyncDisabled
(
)
;
Object
.
keys
(
window
)
.
forEach
(
function
(
prop
)
{
if
(
parseInt
(
prop
)
=
=
prop
)
{
return
;
}
if
(
!
this
.
_globalProperties
.
includes
(
prop
)
)
{
this
.
_globalProperties
.
push
(
prop
)
;
if
(
!
this
.
_globalPropertyWhitelist
.
includes
(
prop
)
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
test
left
unexpected
property
on
window
:
"
+
prop
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
}
}
this
)
;
await
new
Promise
(
resolve
=
>
SpecialPowers
.
flushPrefEnv
(
resolve
)
)
;
if
(
gConfig
.
cleanupCrashes
)
{
let
gdir
=
Services
.
dirsvc
.
get
(
"
UAppData
"
Ci
.
nsIFile
)
;
gdir
.
append
(
"
Crash
Reports
"
)
;
gdir
.
append
(
"
pending
"
)
;
if
(
gdir
.
exists
(
)
)
{
let
entries
=
gdir
.
directoryEntries
;
while
(
entries
.
hasMoreElements
(
)
)
{
let
entry
=
entries
.
nextFile
;
if
(
entry
.
isFile
(
)
)
{
let
msg
=
"
this
test
left
a
pending
crash
report
;
"
;
try
{
entry
.
remove
(
false
)
;
msg
+
=
"
deleted
"
+
entry
.
path
;
}
catch
(
e
)
{
msg
+
=
"
could
not
delete
"
+
entry
.
path
;
}
this
.
structuredLogger
.
info
(
msg
)
;
}
}
}
}
if
(
this
.
currentTest
.
unexpectedTimeouts
&
&
!
this
.
currentTest
.
timedOut
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
This
test
exceeded
the
timeout
threshold
.
It
should
be
"
+
"
rewritten
or
split
up
.
If
that
'
s
not
possible
use
"
+
"
requestLongerTimeout
(
N
)
but
only
as
a
last
resort
.
"
}
)
)
;
}
let
debugsvc
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
if
(
debugsvc
.
isDebugBuild
)
{
let
newAssertionCount
=
debugsvc
.
assertionCount
;
let
numAsserts
=
newAssertionCount
-
this
.
lastAssertionCount
;
this
.
lastAssertionCount
=
newAssertionCount
;
let
max
=
testScope
.
__expectedMaxAsserts
;
let
min
=
testScope
.
__expectedMinAsserts
;
if
(
numAsserts
>
max
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Assertion
count
"
+
numAsserts
+
"
is
greater
than
expected
range
"
+
min
+
"
-
"
+
max
+
"
assertions
.
"
pass
:
true
todo
:
true
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
else
if
(
numAsserts
<
min
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Assertion
count
"
+
numAsserts
+
"
is
less
than
expected
range
"
+
min
+
"
-
"
+
max
+
"
assertions
.
"
todo
:
true
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
else
if
(
numAsserts
>
0
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Assertion
count
"
+
numAsserts
+
"
is
within
expected
range
"
+
min
+
"
-
"
+
max
+
"
assertions
.
"
pass
:
true
todo
:
true
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
}
if
(
this
.
currentTest
.
allowFailure
)
{
if
(
this
.
currentTest
.
expectedAllowedFailureCount
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Expected
"
+
this
.
currentTest
.
expectedAllowedFailureCount
+
"
failures
in
this
file
got
"
+
this
.
currentTest
.
allowedFailureCount
+
"
.
"
pass
:
this
.
currentTest
.
expectedAllowedFailureCount
=
=
this
.
currentTest
.
allowedFailureCount
}
)
)
;
}
else
if
(
this
.
currentTest
.
allowedFailureCount
=
=
0
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
We
expect
at
least
one
assertion
to
fail
because
this
"
+
"
test
file
is
marked
as
fail
-
if
in
the
manifest
.
"
todo
:
true
knownFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
}
}
if
(
Services
.
appinfo
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
)
{
this
.
MemoryStats
.
dump
(
this
.
currentTestIndex
this
.
currentTest
.
path
gConfig
.
dumpOutputDirectory
gConfig
.
dumpAboutMemoryAfterTest
gConfig
.
dumpDMDAfterTest
)
;
}
let
name
=
this
.
currentTest
.
path
;
name
=
name
.
slice
(
name
.
lastIndexOf
(
"
/
"
)
+
1
)
;
ChromeUtils
.
addProfilerMarker
(
"
browser
-
test
"
{
category
:
"
Test
"
startTime
:
this
.
lastStartTimestamp
}
name
)
;
if
(
this
.
currentTest
.
failCount
)
{
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
if
(
env
.
exists
(
"
MOZ_UPLOAD_DIR
"
)
&
&
!
env
.
exists
(
"
MOZ_PROFILER_SHUTDOWN
"
)
&
&
Services
.
profiler
.
IsActive
(
)
)
{
let
filename
=
profile_
{
name
}
.
json
;
let
path
=
env
.
get
(
"
MOZ_UPLOAD_DIR
"
)
;
let
profilePath
=
PathUtils
.
join
(
path
filename
)
;
try
{
let
profileData
=
await
Services
.
profiler
.
getProfileDataAsGzippedArrayBuffer
(
)
;
await
IOUtils
.
write
(
profilePath
new
Uint8Array
(
profileData
)
)
;
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Found
unexpected
failures
during
the
test
;
profile
uploaded
in
"
+
filename
}
)
)
;
}
catch
(
e
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Found
unexpected
failures
during
the
test
;
failed
to
upload
profile
:
"
+
e
}
)
)
;
}
}
}
let
time
=
Date
.
now
(
)
-
this
.
lastStartTime
;
this
.
structuredLogger
.
testEnd
(
this
.
currentTest
.
path
"
OK
"
undefined
"
finished
in
"
+
time
+
"
ms
"
)
;
this
.
currentTest
.
setDuration
(
time
)
;
if
(
this
.
runUntilFailure
&
&
this
.
currentTest
.
failCount
>
0
)
{
this
.
haltTests
(
)
;
}
SIMPLETEST_OVERRIDES
.
forEach
(
m
=
>
{
this
.
SimpleTest
[
m
]
=
this
.
SimpleTestOriginal
[
m
]
;
}
)
;
this
.
ContentTask
.
setTestScope
(
null
)
;
testScope
.
destroy
(
)
;
this
.
currentTest
.
scope
=
null
;
}
this
.
waitForWindowsState
(
(
)
=
>
{
if
(
this
.
done
)
{
if
(
this
.
_coverageCollector
)
{
this
.
_coverageCollector
.
finalize
(
)
;
}
else
if
(
!
AppConstants
.
RELEASE_OR_BETA
&
&
!
AppConstants
.
DEBUG
&
&
!
AppConstants
.
MOZ_CODE_COVERAGE
&
&
!
AppConstants
.
ASAN
&
&
!
AppConstants
.
TSAN
)
{
this
.
finish
(
)
;
return
;
}
if
(
gConfig
.
testRoot
=
=
"
browser
"
)
{
if
(
AppConstants
.
MOZ_APP_NAME
!
=
"
seamonkey
"
)
{
let
sidebar
=
document
.
getElementById
(
"
sidebar
"
)
;
if
(
sidebar
)
{
sidebar
.
setAttribute
(
"
src
"
"
data
:
text
/
html
;
charset
=
utf
-
8
"
)
;
sidebar
.
docShell
.
createAboutBlankContentViewer
(
null
null
)
;
sidebar
.
setAttribute
(
"
src
"
"
about
:
blank
"
)
;
}
}
let
{
BackgroundPageThumbs
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
BackgroundPageThumbs
.
jsm
"
)
;
BackgroundPageThumbs
.
_destroy
(
)
;
if
(
window
.
gBrowser
)
{
NewTabPagePreloading
.
removePreloadedBrowser
(
window
)
;
}
}
let
shutdownCleanup
=
aCallback
=
>
{
Cu
.
schedulePreciseShrinkingGC
(
(
)
=
>
{
let
numCycles
=
3
;
for
(
let
i
=
0
;
i
<
numCycles
;
i
+
+
)
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
}
aCallback
(
)
;
}
)
;
}
;
let
{
AsyncShutdown
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
let
barrier
=
new
AsyncShutdown
.
Barrier
(
"
ShutdownLeaks
:
Wait
for
cleanup
to
be
finished
before
checking
for
leaks
"
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
barrier
}
"
shutdown
-
leaks
-
before
-
check
"
)
;
barrier
.
client
.
addBlocker
(
"
ShutdownLeaks
:
Wait
for
tabs
to
finish
closing
"
TabDestroyObserver
.
wait
(
)
)
;
barrier
.
wait
(
)
.
then
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
"
memory
-
pressure
"
"
heap
-
minimize
"
)
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
browser
-
test
:
collect
-
request
"
)
;
shutdownCleanup
(
(
)
=
>
{
setTimeout
(
(
)
=
>
{
shutdownCleanup
(
(
)
=
>
{
this
.
finish
(
)
;
}
)
;
}
1000
)
;
}
)
;
}
)
;
return
;
}
if
(
this
.
repeat
>
0
)
{
-
-
this
.
repeat
;
if
(
this
.
currentTestIndex
<
0
)
{
this
.
currentTestIndex
=
0
;
}
this
.
execTest
(
)
;
}
else
{
this
.
currentTestIndex
+
+
;
if
(
gConfig
.
repeat
)
{
this
.
repeat
=
gConfig
.
repeat
;
}
this
.
execTest
(
)
;
}
}
)
;
}
async
handleTask
(
task
currentTest
PromiseTestUtils
isSetup
=
false
)
{
let
currentScope
=
currentTest
.
scope
;
let
desc
=
isSetup
?
"
setup
"
:
"
test
"
;
currentScope
.
SimpleTest
.
info
(
Entering
{
desc
}
{
task
.
name
}
)
;
let
startTimestamp
=
performance
.
now
(
)
;
try
{
let
result
=
await
task
(
)
;
if
(
isGenerator
(
result
)
)
{
currentScope
.
SimpleTest
.
ok
(
false
"
Task
returned
a
generator
"
)
;
}
}
catch
(
ex
)
{
if
(
currentTest
.
timedOut
)
{
currentTest
.
addResult
(
new
testResult
(
{
name
:
Uncaught
exception
received
from
previously
timed
out
{
desc
}
pass
:
false
ex
stack
:
typeof
ex
=
=
"
object
"
&
&
"
stack
"
in
ex
?
ex
.
stack
:
null
allowFailure
:
currentTest
.
allowFailure
}
)
)
;
return
;
}
currentTest
.
addResult
(
new
testResult
(
{
name
:
Uncaught
exception
in
{
desc
}
pass
:
currentScope
.
SimpleTest
.
isExpectingUncaughtException
(
)
ex
stack
:
typeof
ex
=
=
"
object
"
&
&
"
stack
"
in
ex
?
ex
.
stack
:
null
allowFailure
:
currentTest
.
allowFailure
}
)
)
;
}
PromiseTestUtils
.
assertNoUncaughtRejections
(
)
;
ChromeUtils
.
addProfilerMarker
(
isSetup
?
"
setup
-
task
"
:
"
task
"
{
category
:
"
Test
"
startTime
:
startTimestamp
}
task
.
name
.
replace
(
/
^
bound
/
"
"
)
|
|
undefined
)
;
currentScope
.
SimpleTest
.
info
(
Leaving
{
desc
}
{
task
.
name
}
)
;
}
async
_runTaskBasedTest
(
currentTest
)
{
let
currentScope
=
currentTest
.
scope
;
let
setupFn
;
while
(
(
setupFn
=
currentScope
.
__setups
.
shift
(
)
)
)
{
await
this
.
handleTask
(
setupFn
currentTest
this
.
PromiseTestUtils
true
)
;
}
let
skipTask
=
task
=
>
{
let
logger
=
this
.
structuredLogger
;
logger
.
deactivateBuffering
(
)
;
logger
.
testStatus
(
this
.
currentTest
.
path
task
.
name
"
SKIP
"
)
;
logger
.
warning
(
"
Skipping
test
"
+
task
.
name
)
;
logger
.
activateBuffering
(
)
;
}
;
let
task
;
while
(
(
task
=
currentScope
.
__tasks
.
shift
(
)
)
)
{
if
(
task
.
__skipMe
|
|
(
currentScope
.
__runOnlyThisTask
&
&
task
!
=
currentScope
.
__runOnlyThisTask
)
)
{
skipTask
(
task
)
;
continue
;
}
await
this
.
handleTask
(
task
currentTest
this
.
PromiseTestUtils
)
;
}
currentScope
.
finish
(
)
;
}
execTest
:
function
Tester_execTest
(
)
{
this
.
structuredLogger
.
testStart
(
this
.
currentTest
.
path
)
;
this
.
SimpleTest
.
reset
(
)
;
this
.
AccessibilityUtils
.
reset
(
this
.
a11y_checks
)
;
let
currentScope
=
(
this
.
currentTest
.
scope
=
new
testScope
(
this
this
.
currentTest
this
.
currentTest
.
expected
)
)
;
let
currentTest
=
this
.
currentTest
;
if
(
currentTest
.
https_first_disabled
)
{
window
.
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
security
.
https_first
"
false
]
]
}
)
;
}
if
(
currentTest
.
allow_xul_xbl
)
{
window
.
SpecialPowers
.
pushPermissions
(
[
{
type
:
"
allowXULXBL
"
allow
:
true
context
:
"
http
:
/
/
mochi
.
test
:
8888
"
}
{
type
:
"
allowXULXBL
"
allow
:
true
context
:
"
http
:
/
/
example
.
org
"
}
]
)
;
}
let
{
scope
}
=
this
.
currentTest
;
scope
.
EventUtils
=
this
.
EventUtils
;
scope
.
AccessibilityUtils
=
this
.
AccessibilityUtils
;
scope
.
SimpleTest
=
this
.
SimpleTest
;
scope
.
gTestPath
=
this
.
currentTest
.
path
;
scope
.
ContentTask
=
this
.
ContentTask
;
scope
.
BrowserTestUtils
=
this
.
BrowserTestUtils
;
scope
.
TestUtils
=
this
.
TestUtils
;
scope
.
ExtensionTestUtils
=
this
.
ExtensionTestUtils
;
scope
.
Assert
=
new
this
.
Assert
(
function
(
err
message
stack
)
{
currentTest
.
addResult
(
new
testResult
(
err
?
{
name
:
err
.
message
ex
:
err
.
stack
stack
:
err
.
stack
allowFailure
:
currentTest
.
allowFailure
}
:
{
name
:
message
pass
:
true
stack
allowFailure
:
currentTest
.
allowFailure
}
)
)
;
}
true
)
;
this
.
ContentTask
.
setTestScope
(
currentScope
)
;
scope
.
export_assertions
=
function
(
)
{
for
(
let
func
in
this
.
Assert
)
{
this
[
func
]
=
this
.
Assert
[
func
]
.
bind
(
this
.
Assert
)
;
}
}
;
SIMPLETEST_OVERRIDES
.
forEach
(
function
(
m
)
{
this
.
SimpleTest
[
m
]
=
this
[
m
]
;
}
scope
)
;
try
{
this
.
_scriptLoader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
chrome
-
harness
.
js
"
scope
)
;
}
catch
(
ex
)
{
}
var
currentTestDirPath
=
this
.
currentTest
.
path
.
substr
(
0
this
.
currentTest
.
path
.
lastIndexOf
(
"
/
"
)
)
;
var
headPath
=
currentTestDirPath
+
"
/
head
.
js
"
;
try
{
this
.
_scriptLoader
.
loadSubScript
(
headPath
scope
)
;
}
catch
(
ex
)
{
const
isImportError
=
/
^
Error
opening
input
stream
/
.
test
(
ex
.
toString
(
)
)
;
const
containsHeadPath
=
ex
.
toString
(
)
.
includes
(
headPath
)
;
if
(
!
isImportError
|
|
!
containsHeadPath
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
head
.
js
import
threw
an
exception
"
ex
}
)
)
;
}
}
try
{
this
.
lastStartTimestamp
=
performance
.
now
(
)
;
this
.
TestUtils
.
promiseTestFinished
=
new
Promise
(
resolve
=
>
{
this
.
resolveFinishTestPromise
=
resolve
;
}
)
;
this
.
_scriptLoader
.
loadSubScript
(
this
.
currentTest
.
path
scope
)
;
this
.
lastStartTime
=
Date
.
now
(
)
;
if
(
this
.
currentTest
.
scope
.
__tasks
)
{
if
(
"
test
"
in
this
.
currentTest
.
scope
)
{
throw
new
Error
(
"
Cannot
run
both
a
add_task
test
and
a
normal
test
at
the
same
time
.
"
)
;
}
this
.
_runTaskBasedTest
(
this
.
currentTest
)
;
}
else
if
(
typeof
scope
.
test
=
=
"
function
"
)
{
scope
.
test
(
)
;
}
else
{
throw
new
Error
(
"
This
test
didn
'
t
call
add_task
nor
did
it
define
a
generatorTest
(
)
function
nor
did
it
define
a
test
(
)
function
so
we
don
'
t
know
how
to
run
it
.
"
)
;
}
}
catch
(
ex
)
{
if
(
!
this
.
SimpleTest
.
isIgnoringAllUncaughtExceptions
(
)
)
{
this
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Exception
thrown
"
pass
:
this
.
SimpleTest
.
isExpectingUncaughtException
(
)
ex
allowFailure
:
this
.
currentTest
.
allowFailure
}
)
)
;
this
.
SimpleTest
.
expectUncaughtException
(
false
)
;
}
else
{
this
.
currentTest
.
addResult
(
new
testMessage
(
"
Exception
thrown
:
"
+
ex
)
)
;
}
this
.
currentTest
.
scope
.
finish
(
)
;
}
if
(
this
.
currentTest
.
scope
.
__done
)
{
this
.
nextTest
(
)
;
}
else
{
var
self
=
this
;
var
timeoutExpires
=
Date
.
now
(
)
+
gTimeoutSeconds
*
1000
;
var
waitUntilAtLeast
=
timeoutExpires
-
1000
;
this
.
currentTest
.
scope
.
__waitTimer
=
this
.
SimpleTest
.
_originalSetTimeout
.
apply
(
window
[
function
timeoutFn
(
)
{
if
(
Date
.
now
(
)
<
waitUntilAtLeast
)
{
self
.
currentTest
.
scope
.
__waitTimer
=
setTimeout
(
timeoutFn
timeoutExpires
-
Date
.
now
(
)
)
;
return
;
}
if
(
-
-
self
.
currentTest
.
scope
.
__timeoutFactor
>
0
)
{
self
.
currentTest
.
scope
.
info
(
"
Longer
timeout
required
waiting
longer
.
.
.
Remaining
timeouts
:
"
+
self
.
currentTest
.
scope
.
__timeoutFactor
)
;
self
.
currentTest
.
scope
.
__waitTimer
=
setTimeout
(
timeoutFn
gTimeoutSeconds
*
1000
)
;
return
;
}
const
MAX_UNEXPECTED_TIMEOUTS
=
10
;
if
(
Date
.
now
(
)
-
self
.
currentTest
.
lastOutputTime
<
(
gTimeoutSeconds
/
2
)
*
1000
&
&
+
+
self
.
currentTest
.
unexpectedTimeouts
<
=
MAX_UNEXPECTED_TIMEOUTS
)
{
self
.
currentTest
.
scope
.
__waitTimer
=
setTimeout
(
timeoutFn
gTimeoutSeconds
*
1000
)
;
return
;
}
let
knownFailure
=
false
;
if
(
gConfig
.
timeoutAsPass
)
{
knownFailure
=
true
;
}
self
.
currentTest
.
addResult
(
new
testResult
(
{
name
:
"
Test
timed
out
"
allowFailure
:
knownFailure
}
)
)
;
self
.
currentTest
.
timedOut
=
true
;
self
.
currentTest
.
scope
.
__waitTimer
=
null
;
self
.
nextTest
(
)
;
}
gTimeoutSeconds
*
1000
]
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIConsoleListener
"
]
)
}
;
function
testResult
(
{
name
pass
todo
ex
stack
allowFailure
}
)
{
this
.
info
=
false
;
this
.
name
=
name
;
this
.
msg
=
"
"
;
if
(
allowFailure
&
&
!
pass
)
{
this
.
allowedFailure
=
true
;
this
.
pass
=
true
;
this
.
todo
=
false
;
}
else
if
(
allowFailure
&
&
pass
)
{
this
.
pass
=
true
;
this
.
todo
=
false
;
}
else
{
this
.
pass
=
!
!
pass
;
this
.
todo
=
todo
;
}
this
.
expected
=
this
.
todo
?
"
FAIL
"
:
"
PASS
"
;
if
(
this
.
pass
)
{
this
.
status
=
this
.
expected
;
return
;
}
this
.
status
=
this
.
todo
?
"
PASS
"
:
"
FAIL
"
;
if
(
ex
)
{
if
(
typeof
ex
=
=
"
object
"
&
&
"
fileName
"
in
ex
)
{
this
.
msg
+
=
"
at
"
+
ex
.
fileName
+
"
:
"
+
ex
.
lineNumber
+
"
-
"
;
}
this
.
msg
+
=
String
(
ex
)
;
}
if
(
stack
)
{
this
.
msg
+
=
"
\
nStack
trace
:
\
n
"
;
let
normalized
;
if
(
stack
instanceof
Ci
.
nsIStackFrame
)
{
let
frames
=
[
]
;
for
(
let
frame
=
stack
;
frame
;
frame
=
frame
.
asyncCaller
|
|
frame
.
caller
)
{
let
msg
=
{
frame
.
filename
}
:
{
frame
.
name
}
:
{
frame
.
lineNumber
}
;
frames
.
push
(
frame
.
asyncCause
?
{
frame
.
asyncCause
}
*
{
msg
}
:
msg
)
;
}
normalized
=
frames
.
join
(
"
\
n
"
)
;
}
else
{
normalized
=
"
"
+
stack
;
}
this
.
msg
+
=
normalized
;
}
if
(
gConfig
.
debugOnFailure
)
{
debugger
;
}
}
function
testMessage
(
msg
)
{
this
.
msg
=
msg
|
|
"
"
;
this
.
info
=
true
;
}
function
testScope
(
aTester
aTest
expected
)
{
this
.
__tester
=
aTester
;
aTest
.
allowFailure
=
expected
=
=
"
fail
"
;
var
self
=
this
;
this
.
ok
=
function
test_ok
(
condition
name
)
{
if
(
arguments
.
length
>
2
)
{
const
ex
=
"
Too
many
arguments
passed
to
ok
(
condition
name
)
.
"
;
self
.
record
(
false
name
ex
)
;
}
else
{
self
.
record
(
condition
name
)
;
}
}
;
this
.
record
=
function
test_record
(
condition
name
ex
stack
expected
)
{
if
(
expected
=
=
"
fail
"
)
{
aTest
.
addResult
(
new
testResult
(
{
name
pass
:
!
condition
todo
:
true
ex
stack
:
stack
|
|
Components
.
stack
.
caller
allowFailure
:
aTest
.
allowFailure
}
)
)
;
}
else
{
aTest
.
addResult
(
new
testResult
(
{
name
pass
:
condition
ex
stack
:
stack
|
|
Components
.
stack
.
caller
allowFailure
:
aTest
.
allowFailure
}
)
)
;
}
}
;
this
.
is
=
function
test_is
(
a
b
name
)
{
self
.
record
(
Object
.
is
(
a
b
)
name
Got
{
self
.
repr
(
a
)
}
expected
{
self
.
repr
(
b
)
}
false
Components
.
stack
.
caller
)
;
}
;
this
.
isfuzzy
=
function
test_isfuzzy
(
a
b
epsilon
name
)
{
self
.
record
(
a
>
=
b
-
epsilon
&
&
a
<
=
b
+
epsilon
name
Got
{
self
.
repr
(
a
)
}
expected
{
self
.
repr
(
b
)
}
epsilon
:
+
/
-
{
self
.
repr
(
epsilon
)
}
false
Components
.
stack
.
caller
)
;
}
;
this
.
isnot
=
function
test_isnot
(
a
b
name
)
{
self
.
record
(
!
Object
.
is
(
a
b
)
name
Didn
'
t
expect
{
self
.
repr
(
a
)
}
but
got
it
false
Components
.
stack
.
caller
)
;
}
;
this
.
todo
=
function
test_todo
(
condition
name
ex
stack
)
{
aTest
.
addResult
(
new
testResult
(
{
name
pass
:
!
condition
todo
:
true
ex
stack
:
stack
|
|
Components
.
stack
.
caller
allowFailure
:
aTest
.
allowFailure
}
)
)
;
}
;
this
.
todo_is
=
function
test_todo_is
(
a
b
name
)
{
self
.
todo
(
Object
.
is
(
a
b
)
name
Got
{
self
.
repr
(
a
)
}
expected
{
self
.
repr
(
b
)
}
Components
.
stack
.
caller
)
;
}
;
this
.
todo_isnot
=
function
test_todo_isnot
(
a
b
name
)
{
self
.
todo
(
!
Object
.
is
(
a
b
)
name
Didn
'
t
expect
{
self
.
repr
(
a
)
}
but
got
it
Components
.
stack
.
caller
)
;
}
;
this
.
info
=
function
test_info
(
name
)
{
aTest
.
addResult
(
new
testMessage
(
name
)
)
;
}
;
this
.
repr
=
function
repr
(
o
)
{
if
(
typeof
o
=
=
"
undefined
"
)
{
return
"
undefined
"
;
}
else
if
(
o
=
=
=
null
)
{
return
"
null
"
;
}
try
{
if
(
typeof
o
.
__repr__
=
=
"
function
"
)
{
return
o
.
__repr__
(
)
;
}
else
if
(
typeof
o
.
repr
=
=
"
function
"
&
&
o
.
repr
!
=
repr
)
{
return
o
.
repr
(
)
;
}
}
catch
(
e
)
{
}
try
{
if
(
typeof
o
.
NAME
=
=
"
string
"
&
&
(
o
.
toString
=
=
Function
.
prototype
.
toString
|
|
o
.
toString
=
=
Object
.
prototype
.
toString
)
)
{
return
o
.
NAME
;
}
}
catch
(
e
)
{
}
var
ostring
;
try
{
if
(
Object
.
is
(
o
+
0
)
)
{
ostring
=
"
+
0
"
;
}
else
if
(
Object
.
is
(
o
-
0
)
)
{
ostring
=
"
-
0
"
;
}
else
if
(
typeof
o
=
=
=
"
string
"
)
{
ostring
=
JSON
.
stringify
(
o
)
;
}
else
if
(
Array
.
isArray
(
o
)
)
{
ostring
=
"
[
"
+
o
.
map
(
val
=
>
repr
(
val
)
)
.
join
(
"
"
)
+
"
]
"
;
}
else
{
ostring
=
String
(
o
)
;
}
}
catch
(
e
)
{
return
[
{
Object
.
prototype
.
toString
.
call
(
o
)
}
]
;
}
if
(
typeof
o
=
=
"
function
"
)
{
ostring
=
ostring
.
replace
(
/
\
)
\
{
[
^
]
*
/
"
)
{
.
.
.
}
"
)
;
}
return
ostring
;
}
;
this
.
executeSoon
=
function
test_executeSoon
(
func
)
{
Services
.
tm
.
dispatchToMainThread
(
{
run
(
)
{
func
(
)
;
}
}
)
;
}
;
this
.
waitForExplicitFinish
=
function
test_waitForExplicitFinish
(
)
{
self
.
__done
=
false
;
}
;
this
.
waitForFocus
=
function
test_waitForFocus
(
callback
targetWindow
expectBlankPage
)
{
self
.
SimpleTest
.
waitForFocus
(
callback
targetWindow
expectBlankPage
)
;
}
;
this
.
waitForClipboard
=
function
test_waitForClipboard
(
expected
setup
success
failure
flavor
)
{
self
.
SimpleTest
.
waitForClipboard
(
expected
setup
success
failure
flavor
)
;
}
;
this
.
registerCleanupFunction
=
function
test_registerCleanupFunction
(
aFunction
)
{
self
.
__cleanupFunctions
.
push
(
aFunction
)
;
}
;
this
.
requestLongerTimeout
=
function
test_requestLongerTimeout
(
aFactor
)
{
self
.
__timeoutFactor
=
aFactor
;
}
;
this
.
copyToProfile
=
function
test_copyToProfile
(
filename
)
{
self
.
SimpleTest
.
copyToProfile
(
filename
)
;
}
;
this
.
expectUncaughtException
=
function
test_expectUncaughtException
(
aExpecting
)
{
self
.
SimpleTest
.
expectUncaughtException
(
aExpecting
)
;
}
;
this
.
ignoreAllUncaughtExceptions
=
function
test_ignoreAllUncaughtExceptions
(
aIgnoring
)
{
self
.
SimpleTest
.
ignoreAllUncaughtExceptions
(
aIgnoring
)
;
}
;
this
.
expectAssertions
=
function
test_expectAssertions
(
aMin
aMax
)
{
let
min
=
aMin
;
let
max
=
aMax
;
if
(
typeof
max
=
=
"
undefined
"
)
{
max
=
min
;
}
if
(
typeof
min
!
=
"
number
"
|
|
typeof
max
!
=
"
number
"
|
|
min
<
0
|
|
max
<
min
)
{
throw
new
Error
(
"
bad
parameter
to
expectAssertions
"
)
;
}
self
.
__expectedMinAsserts
=
min
;
self
.
__expectedMaxAsserts
=
max
;
}
;
this
.
setExpectedFailuresForSelfTest
=
function
test_setExpectedFailuresForSelfTest
(
expectedAllowedFailureCount
)
{
aTest
.
allowFailure
=
true
;
aTest
.
expectedAllowedFailureCount
=
expectedAllowedFailureCount
;
}
;
this
.
finish
=
function
test_finish
(
)
{
self
.
__done
=
true
;
if
(
self
.
__waitTimer
)
{
self
.
executeSoon
(
function
(
)
{
if
(
self
.
__done
&
&
self
.
__waitTimer
)
{
clearTimeout
(
self
.
__waitTimer
)
;
self
.
__waitTimer
=
null
;
self
.
__tester
.
nextTest
(
)
;
}
}
)
;
}
}
;
this
.
requestCompleteLog
=
function
test_requestCompleteLog
(
)
{
self
.
__tester
.
structuredLogger
.
deactivateBuffering
(
)
;
self
.
registerCleanupFunction
(
function
(
)
{
self
.
__tester
.
structuredLogger
.
activateBuffering
(
)
;
}
)
;
}
;
return
this
;
}
function
decorateTaskFn
(
fn
)
{
fn
=
fn
.
bind
(
this
)
;
fn
.
skip
=
(
val
=
true
)
=
>
(
fn
.
__skipMe
=
val
)
;
fn
.
only
=
(
)
=
>
(
this
.
__runOnlyThisTask
=
fn
)
;
return
fn
;
}
testScope
.
prototype
=
{
__done
:
true
__tasks
:
null
__setups
:
[
]
__runOnlyThisTask
:
null
__waitTimer
:
null
__cleanupFunctions
:
[
]
__timeoutFactor
:
1
__expectedMinAsserts
:
0
__expectedMaxAsserts
:
0
EventUtils
:
{
}
AccessibilityUtils
:
{
}
SimpleTest
:
{
}
ContentTask
:
null
BrowserTestUtils
:
null
TestUtils
:
null
ExtensionTestUtils
:
null
Assert
:
null
add_task
(
aFunction
)
{
if
(
!
this
.
__tasks
)
{
this
.
waitForExplicitFinish
(
)
;
this
.
__tasks
=
[
]
;
}
let
bound
=
decorateTaskFn
.
call
(
this
aFunction
)
;
this
.
__tasks
.
push
(
bound
)
;
return
bound
;
}
add_setup
(
aFunction
)
{
if
(
!
this
.
__setups
.
length
)
{
this
.
waitForExplicitFinish
(
)
;
}
let
bound
=
aFunction
.
bind
(
this
)
;
this
.
__setups
.
push
(
bound
)
;
return
bound
;
}
destroy
:
function
test_destroy
(
)
{
for
(
let
prop
in
this
)
{
delete
this
[
prop
]
;
}
}
}
;
