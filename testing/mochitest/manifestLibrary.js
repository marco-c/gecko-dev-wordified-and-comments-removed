function
parseTestManifest
(
testManifest
params
callback
)
{
let
links
=
{
}
;
let
paths
=
[
]
;
if
(
"
runtests
"
in
testManifest
|
|
"
excludetests
"
in
testManifest
)
{
callback
(
testManifest
)
;
return
;
}
for
(
let
obj
of
testManifest
.
tests
)
{
let
path
=
obj
.
path
;
if
(
"
disabled
"
in
obj
)
{
dump
(
"
TEST
-
SKIPPED
|
"
+
path
+
"
|
"
+
obj
.
disabled
+
"
\
n
"
)
;
continue
;
}
if
(
params
.
testRoot
!
=
"
tests
"
&
&
params
.
testRoot
!
=
=
undefined
)
{
let
name
=
params
.
baseurl
+
"
/
"
+
params
.
testRoot
+
"
/
"
+
path
;
links
[
name
]
=
{
test
:
{
url
:
name
expected
:
obj
.
expected
https_first_disabled
:
obj
.
https_first_disabled
allow_xul_xbl
:
obj
.
allow_xul_xbl
}
}
;
}
else
{
let
name
=
params
.
testPrefix
+
path
;
if
(
params
.
xOriginTests
&
&
obj
.
scheme
=
=
"
https
"
)
{
name
=
params
.
httpsBaseUrl
+
path
;
}
paths
.
push
(
{
test
:
{
url
:
name
expected
:
obj
.
expected
https_first_disabled
:
obj
.
https_first_disabled
allow_xul_xbl
:
obj
.
allow_xul_xbl
}
}
)
;
}
}
if
(
paths
.
length
)
{
callback
(
paths
)
;
}
else
{
callback
(
links
)
;
}
}
function
getTestManifest
(
url
params
callback
)
{
let
req
=
new
XMLHttpRequest
(
)
;
req
.
open
(
"
GET
"
url
)
;
req
.
onload
=
function
(
)
{
if
(
req
.
readyState
=
=
4
)
{
if
(
req
.
status
=
=
200
)
{
try
{
parseTestManifest
(
JSON
.
parse
(
req
.
responseText
)
params
callback
)
;
}
catch
(
e
)
{
dump
(
"
TEST
-
UNEXPECTED
-
FAIL
:
manifestLibrary
.
js
|
error
parsing
"
+
url
+
"
(
"
+
e
+
"
)
\
n
"
)
;
throw
e
;
}
}
else
{
dump
(
"
TEST
-
UNEXPECTED
-
FAIL
:
manifestLibrary
.
js
|
error
loading
"
+
url
+
"
(
HTTP
"
+
req
.
status
+
"
)
\
n
"
)
;
callback
(
{
}
)
;
}
}
}
;
req
.
send
(
)
;
}
function
filterTests
(
filter
testList
runOnly
)
{
let
filteredTests
=
[
]
;
let
runtests
=
{
}
;
let
excludetests
=
{
}
;
if
(
filter
=
=
null
)
{
return
testList
;
}
if
(
"
runtests
"
in
filter
)
{
runtests
=
filter
.
runtests
;
}
if
(
"
excludetests
"
in
filter
)
{
excludetests
=
filter
.
excludetests
;
}
if
(
!
(
"
runtests
"
in
filter
)
&
&
!
(
"
excludetests
"
in
filter
)
)
{
if
(
runOnly
=
=
"
true
"
)
{
runtests
=
filter
;
}
else
{
excludetests
=
filter
;
}
}
let
testRoot
=
config
.
testRoot
|
|
"
tests
"
;
if
(
Object
.
keys
(
runtests
)
.
length
)
{
for
(
let
i
=
0
;
i
<
testList
.
length
;
i
+
+
)
{
let
testpath
;
if
(
testList
[
i
]
instanceof
Object
&
&
"
test
"
in
testList
[
i
]
)
{
testpath
=
testList
[
i
]
.
test
.
url
;
}
else
{
testpath
=
testList
[
i
]
;
}
let
tmppath
=
testpath
.
replace
(
/
^
\
/
/
"
"
)
;
for
(
let
f
in
runtests
)
{
let
file
=
f
.
replace
(
/
^
\
/
/
"
"
)
;
file
=
file
.
replace
(
/
^
tests
\
/
/
"
"
)
;
if
(
tmppath
.
match
(
testRoot
+
"
/
"
+
file
)
!
=
null
)
{
filteredTests
.
push
(
testpath
)
;
break
;
}
}
}
}
else
{
filteredTests
=
testList
.
slice
(
0
)
;
}
if
(
!
Object
.
keys
(
excludetests
)
.
length
)
{
return
filteredTests
;
}
let
refilteredTests
=
[
]
;
for
(
let
i
=
0
;
i
<
filteredTests
.
length
;
i
+
+
)
{
let
found
=
false
;
let
testpath
;
if
(
filteredTests
[
i
]
instanceof
Object
&
&
"
test
"
in
filteredTests
[
i
]
)
{
testpath
=
filteredTests
[
i
]
.
test
.
url
;
}
else
{
testpath
=
filteredTests
[
i
]
;
}
let
tmppath
=
testpath
.
replace
(
/
^
\
/
/
"
"
)
;
for
(
let
f
in
excludetests
)
{
let
file
=
f
.
replace
(
/
^
\
/
/
"
"
)
;
file
=
file
.
replace
(
/
^
tests
\
/
/
"
"
)
;
if
(
tmppath
.
match
(
testRoot
+
"
/
"
+
file
)
!
=
null
)
{
found
=
true
;
break
;
}
}
if
(
!
found
)
{
refilteredTests
.
push
(
testpath
)
;
}
}
return
refilteredTests
;
}
