"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
assert
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
event
.
js
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
action
"
]
;
this
.
action
=
{
Pause
:
"
pause
"
KeyDown
:
"
keyDown
"
KeyUp
:
"
keyUp
"
PointerDown
:
"
pointerDown
"
PointerUp
:
"
pointerUp
"
PointerMove
:
"
pointerMove
"
PointerCancel
:
"
pointerCancel
"
}
;
const
ACTIONS
=
{
none
:
new
Set
(
[
action
.
Pause
]
)
key
:
new
Set
(
[
action
.
Pause
action
.
KeyDown
action
.
KeyUp
]
)
pointer
:
new
Set
(
[
action
.
Pause
action
.
PointerDown
action
.
PointerUp
action
.
PointerMove
action
.
PointerCancel
]
)
}
;
const
MODIFIER_NAME_LOOKUP
=
{
"
Alt
"
:
"
alt
"
"
Shift
"
:
"
shift
"
"
Control
"
:
"
ctrl
"
"
Meta
"
:
"
meta
"
}
;
const
NORMALIZED_KEY_LOOKUP
=
{
"
\
uE000
"
:
"
Unidentified
"
"
\
uE001
"
:
"
Cancel
"
"
\
uE002
"
:
"
Help
"
"
\
uE003
"
:
"
Backspace
"
"
\
uE004
"
:
"
Tab
"
"
\
uE005
"
:
"
Clear
"
"
\
uE006
"
:
"
Return
"
"
\
uE007
"
:
"
Enter
"
"
\
uE008
"
:
"
Shift
"
"
\
uE009
"
:
"
Control
"
"
\
uE00A
"
:
"
Alt
"
"
\
uE00B
"
:
"
Pause
"
"
\
uE00C
"
:
"
Escape
"
"
\
uE00D
"
:
"
"
"
\
uE00E
"
:
"
PageUp
"
"
\
uE00F
"
:
"
PageDown
"
"
\
uE010
"
:
"
End
"
"
\
uE011
"
:
"
Home
"
"
\
uE012
"
:
"
ArrowLeft
"
"
\
uE013
"
:
"
ArrowUp
"
"
\
uE014
"
:
"
ArrowRight
"
"
\
uE015
"
:
"
ArrowDown
"
"
\
uE016
"
:
"
Insert
"
"
\
uE017
"
:
"
Delete
"
"
\
uE018
"
:
"
;
"
"
\
uE019
"
:
"
=
"
"
\
uE01A
"
:
"
0
"
"
\
uE01B
"
:
"
1
"
"
\
uE01C
"
:
"
2
"
"
\
uE01D
"
:
"
3
"
"
\
uE01E
"
:
"
4
"
"
\
uE01F
"
:
"
5
"
"
\
uE020
"
:
"
6
"
"
\
uE021
"
:
"
7
"
"
\
uE022
"
:
"
8
"
"
\
uE023
"
:
"
9
"
"
\
uE024
"
:
"
*
"
"
\
uE025
"
:
"
+
"
"
\
uE026
"
:
"
"
"
\
uE027
"
:
"
-
"
"
\
uE028
"
:
"
.
"
"
\
uE029
"
:
"
/
"
"
\
uE031
"
:
"
F1
"
"
\
uE032
"
:
"
F2
"
"
\
uE033
"
:
"
F3
"
"
\
uE034
"
:
"
F4
"
"
\
uE035
"
:
"
F5
"
"
\
uE036
"
:
"
F6
"
"
\
uE037
"
:
"
F7
"
"
\
uE038
"
:
"
F8
"
"
\
uE039
"
:
"
F9
"
"
\
uE03A
"
:
"
F10
"
"
\
uE03B
"
:
"
F11
"
"
\
uE03C
"
:
"
F12
"
"
\
uE03D
"
:
"
Meta
"
"
\
uE040
"
:
"
ZenkakuHankaku
"
"
\
uE050
"
:
"
Shift
"
"
\
uE051
"
:
"
Control
"
"
\
uE052
"
:
"
Alt
"
"
\
uE053
"
:
"
Meta
"
"
\
uE054
"
:
"
PageUp
"
"
\
uE055
"
:
"
PageDown
"
"
\
uE056
"
:
"
End
"
"
\
uE057
"
:
"
Home
"
"
\
uE058
"
:
"
ArrowLeft
"
"
\
uE059
"
:
"
ArrowUp
"
"
\
uE05A
"
:
"
ArrowRight
"
"
\
uE05B
"
:
"
ArrowDown
"
"
\
uE05C
"
:
"
Insert
"
"
\
uE05D
"
:
"
Delete
"
}
;
const
KEY_LOCATION_LOOKUP
=
{
"
\
uE007
"
:
1
"
\
uE008
"
:
1
"
\
uE009
"
:
1
"
\
uE00A
"
:
1
"
\
uE01A
"
:
3
"
\
uE01B
"
:
3
"
\
uE01C
"
:
3
"
\
uE01D
"
:
3
"
\
uE01E
"
:
3
"
\
uE01F
"
:
3
"
\
uE020
"
:
3
"
\
uE021
"
:
3
"
\
uE022
"
:
3
"
\
uE023
"
:
3
"
\
uE024
"
:
3
"
\
uE025
"
:
3
"
\
uE026
"
:
3
"
\
uE027
"
:
3
"
\
uE028
"
:
3
"
\
uE029
"
:
3
"
\
uE03D
"
:
1
"
\
uE050
"
:
2
"
\
uE051
"
:
2
"
\
uE052
"
:
2
"
\
uE053
"
:
2
"
\
uE054
"
:
3
"
\
uE055
"
:
3
"
\
uE056
"
:
3
"
\
uE057
"
:
3
"
\
uE058
"
:
3
"
\
uE059
"
:
3
"
\
uE05A
"
:
3
"
\
uE05B
"
:
3
"
\
uE05C
"
:
3
"
\
uE05D
"
:
3
}
;
const
KEY_CODE_LOOKUP
=
{
"
\
uE00A
"
:
"
AltLeft
"
"
\
uE052
"
:
"
AltRight
"
"
\
uE015
"
:
"
ArrowDown
"
"
\
uE012
"
:
"
ArrowLeft
"
"
\
uE014
"
:
"
ArrowRight
"
"
\
uE013
"
:
"
ArrowUp
"
"
"
:
"
Backquote
"
"
~
"
:
"
Backquote
"
"
\
\
"
:
"
Backslash
"
"
|
"
:
"
Backslash
"
"
\
uE003
"
:
"
Backspace
"
"
[
"
:
"
BracketLeft
"
"
{
"
:
"
BracketLeft
"
"
]
"
:
"
BracketRight
"
"
}
"
:
"
BracketRight
"
"
"
:
"
Comma
"
"
<
"
:
"
Comma
"
"
\
uE009
"
:
"
ControlLeft
"
"
\
uE051
"
:
"
ControlRight
"
"
\
uE017
"
:
"
Delete
"
"
)
"
:
"
Digit0
"
"
0
"
:
"
Digit0
"
"
!
"
:
"
Digit1
"
"
1
"
:
"
Digit1
"
"
2
"
:
"
Digit2
"
"
"
:
"
Digit2
"
"
#
"
:
"
Digit3
"
"
3
"
:
"
Digit3
"
"
"
:
"
Digit4
"
"
4
"
:
"
Digit4
"
"
%
"
:
"
Digit5
"
"
5
"
:
"
Digit5
"
"
6
"
:
"
Digit6
"
"
^
"
:
"
Digit6
"
"
&
"
:
"
Digit7
"
"
7
"
:
"
Digit7
"
"
*
"
:
"
Digit8
"
"
8
"
:
"
Digit8
"
"
(
"
:
"
Digit9
"
"
9
"
:
"
Digit9
"
"
\
uE010
"
:
"
End
"
"
\
uE006
"
:
"
Enter
"
"
+
"
:
"
Equal
"
"
=
"
:
"
Equal
"
"
\
uE00C
"
:
"
Escape
"
"
\
uE031
"
:
"
F1
"
"
\
uE03A
"
:
"
F10
"
"
\
uE03B
"
:
"
F11
"
"
\
uE03C
"
:
"
F12
"
"
\
uE032
"
:
"
F2
"
"
\
uE033
"
:
"
F3
"
"
\
uE034
"
:
"
F4
"
"
\
uE035
"
:
"
F5
"
"
\
uE036
"
:
"
F6
"
"
\
uE037
"
:
"
F7
"
"
\
uE038
"
:
"
F8
"
"
\
uE039
"
:
"
F9
"
"
\
uE002
"
:
"
Help
"
"
\
uE011
"
:
"
Home
"
"
\
uE016
"
:
"
Insert
"
"
<
"
:
"
IntlBackslash
"
"
>
"
:
"
IntlBackslash
"
"
A
"
:
"
KeyA
"
"
a
"
:
"
KeyA
"
"
B
"
:
"
KeyB
"
"
b
"
:
"
KeyB
"
"
C
"
:
"
KeyC
"
"
c
"
:
"
KeyC
"
"
D
"
:
"
KeyD
"
"
d
"
:
"
KeyD
"
"
E
"
:
"
KeyE
"
"
e
"
:
"
KeyE
"
"
F
"
:
"
KeyF
"
"
f
"
:
"
KeyF
"
"
G
"
:
"
KeyG
"
"
g
"
:
"
KeyG
"
"
H
"
:
"
KeyH
"
"
h
"
:
"
KeyH
"
"
I
"
:
"
KeyI
"
"
i
"
:
"
KeyI
"
"
J
"
:
"
KeyJ
"
"
j
"
:
"
KeyJ
"
"
K
"
:
"
KeyK
"
"
k
"
:
"
KeyK
"
"
L
"
:
"
KeyL
"
"
l
"
:
"
KeyL
"
"
M
"
:
"
KeyM
"
"
m
"
:
"
KeyM
"
"
N
"
:
"
KeyN
"
"
n
"
:
"
KeyN
"
"
O
"
:
"
KeyO
"
"
o
"
:
"
KeyO
"
"
P
"
:
"
KeyP
"
"
p
"
:
"
KeyP
"
"
Q
"
:
"
KeyQ
"
"
q
"
:
"
KeyQ
"
"
R
"
:
"
KeyR
"
"
r
"
:
"
KeyR
"
"
S
"
:
"
KeyS
"
"
s
"
:
"
KeyS
"
"
T
"
:
"
KeyT
"
"
t
"
:
"
KeyT
"
"
U
"
:
"
KeyU
"
"
u
"
:
"
KeyU
"
"
V
"
:
"
KeyV
"
"
v
"
:
"
KeyV
"
"
W
"
:
"
KeyW
"
"
w
"
:
"
KeyW
"
"
X
"
:
"
KeyX
"
"
x
"
:
"
KeyX
"
"
Y
"
:
"
KeyY
"
"
y
"
:
"
KeyY
"
"
Z
"
:
"
KeyZ
"
"
z
"
:
"
KeyZ
"
"
-
"
:
"
Minus
"
"
_
"
:
"
Minus
"
"
\
uE01A
"
:
"
Numpad0
"
"
\
uE05C
"
:
"
Numpad0
"
"
\
uE01B
"
:
"
Numpad1
"
"
\
uE056
"
:
"
Numpad1
"
"
\
uE01C
"
:
"
Numpad2
"
"
\
uE05B
"
:
"
Numpad2
"
"
\
uE01D
"
:
"
Numpad3
"
"
\
uE055
"
:
"
Numpad3
"
"
\
uE01E
"
:
"
Numpad4
"
"
\
uE058
"
:
"
Numpad4
"
"
\
uE01F
"
:
"
Numpad5
"
"
\
uE020
"
:
"
Numpad6
"
"
\
uE05A
"
:
"
Numpad6
"
"
\
uE021
"
:
"
Numpad7
"
"
\
uE057
"
:
"
Numpad7
"
"
\
uE022
"
:
"
Numpad8
"
"
\
uE059
"
:
"
Numpad8
"
"
\
uE023
"
:
"
Numpad9
"
"
\
uE054
"
:
"
Numpad9
"
"
\
uE024
"
:
"
NumpadAdd
"
"
\
uE026
"
:
"
NumpadComma
"
"
\
uE028
"
:
"
NumpadDecimal
"
"
\
uE05D
"
:
"
NumpadDecimal
"
"
\
uE029
"
:
"
NumpadDivide
"
"
\
uE007
"
:
"
NumpadEnter
"
"
\
uE024
"
:
"
NumpadMultiply
"
"
\
uE026
"
:
"
NumpadSubtract
"
"
\
uE03D
"
:
"
OSLeft
"
"
\
uE053
"
:
"
OSRight
"
"
\
uE01E
"
:
"
PageDown
"
"
\
uE01F
"
:
"
PageUp
"
"
.
"
:
"
Period
"
"
>
"
:
"
Period
"
"
\
"
"
:
"
Quote
"
"
'
"
:
"
Quote
"
"
:
"
:
"
Semicolon
"
"
;
"
:
"
Semicolon
"
"
\
uE008
"
:
"
ShiftLeft
"
"
\
uE050
"
:
"
ShiftRight
"
"
/
"
:
"
Slash
"
"
?
"
:
"
Slash
"
"
\
uE00D
"
:
"
Space
"
"
"
:
"
Space
"
"
\
uE004
"
:
"
Tab
"
}
;
action
.
PointerType
=
{
Mouse
:
"
mouse
"
Pen
:
"
pen
"
Touch
:
"
touch
"
}
;
action
.
PointerType
.
get
=
function
(
str
)
{
let
name
=
capitalize
(
str
)
;
if
(
!
(
name
in
this
)
)
{
throw
new
InvalidArgumentError
(
Unknown
pointerType
:
{
str
}
)
;
}
return
this
[
name
]
;
}
;
action
.
inputStateMap
=
undefined
;
action
.
inputsToCancel
=
undefined
;
class
InputState
{
constructor
(
)
{
this
.
type
=
this
.
constructor
.
name
.
toLowerCase
(
)
;
}
is
(
other
)
{
if
(
typeof
other
=
=
"
undefined
"
)
{
return
false
;
}
return
this
.
type
=
=
=
other
.
type
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
InputState
]
;
}
static
fromJson
(
obj
)
{
let
type
=
obj
.
type
;
if
(
!
(
type
in
ACTIONS
)
)
{
throw
new
InvalidArgumentError
(
Unknown
action
type
:
{
type
}
)
;
}
let
name
=
type
=
=
"
none
"
?
"
Null
"
:
capitalize
(
type
)
;
return
new
action
.
InputState
[
name
]
(
)
;
}
}
action
.
InputState
=
{
}
;
action
.
InputState
.
Key
=
class
Key
extends
InputState
{
constructor
(
)
{
super
(
)
;
this
.
pressed
=
new
Set
(
)
;
this
.
alt
=
false
;
this
.
shift
=
false
;
this
.
ctrl
=
false
;
this
.
meta
=
false
;
}
setModState
(
key
value
)
{
if
(
key
in
MODIFIER_NAME_LOOKUP
)
{
this
[
MODIFIER_NAME_LOOKUP
[
key
]
]
=
value
;
}
else
{
throw
new
InvalidArgumentError
(
"
Expected
'
key
'
to
be
one
of
"
+
{
Object
.
keys
(
MODIFIER_NAME_LOOKUP
)
}
;
got
:
{
key
}
)
;
}
}
isPressed
(
key
)
{
return
this
.
pressed
.
has
(
key
)
;
}
press
(
key
)
{
return
this
.
pressed
.
add
(
key
)
;
}
release
(
key
)
{
return
this
.
pressed
.
delete
(
key
)
;
}
}
;
action
.
InputState
.
Null
=
class
Null
extends
InputState
{
constructor
(
)
{
super
(
)
;
this
.
type
=
"
none
"
;
}
}
;
action
.
InputState
.
Pointer
=
class
Pointer
extends
InputState
{
constructor
(
subtype
)
{
super
(
)
;
this
.
pressed
=
new
Set
(
)
;
this
.
subtype
=
subtype
;
this
.
x
=
0
;
this
.
y
=
0
;
}
}
;
action
.
Action
=
class
{
constructor
(
id
type
subtype
)
{
if
(
[
id
type
subtype
]
.
includes
(
undefined
)
)
{
throw
new
InvalidArgumentError
(
"
Missing
id
type
or
subtype
"
)
;
}
for
(
let
attr
of
[
id
type
subtype
]
)
{
if
(
typeof
attr
!
=
"
string
"
)
{
throw
new
InvalidArgumentError
(
Expected
string
got
:
{
attr
}
)
;
}
}
this
.
id
=
id
;
this
.
type
=
type
;
this
.
subtype
=
subtype
;
}
;
toString
(
)
{
return
[
action
{
this
.
type
}
]
;
}
static
fromJson
(
actionSequence
actionItem
)
{
let
type
=
actionSequence
.
type
;
let
id
=
actionSequence
.
id
;
let
subtypes
=
ACTIONS
[
type
]
;
if
(
!
subtypes
)
{
throw
new
InvalidArgumentError
(
"
Unknown
type
:
"
+
type
)
;
}
let
subtype
=
actionItem
.
type
;
if
(
!
subtypes
.
has
(
subtype
)
)
{
throw
new
InvalidArgumentError
(
Unknown
subtype
for
{
type
}
action
:
{
subtype
}
)
;
}
let
item
=
new
action
.
Action
(
id
type
subtype
)
;
if
(
type
=
=
=
"
pointer
"
)
{
action
.
processPointerAction
(
id
action
.
PointerParameters
.
fromJson
(
actionSequence
.
parameters
)
item
)
;
}
switch
(
item
.
subtype
)
{
case
action
.
KeyUp
:
case
action
.
KeyDown
:
let
key
=
actionItem
.
value
;
if
(
typeof
key
!
=
"
string
"
)
{
throw
new
InvalidArgumentError
(
"
Expected
'
value
'
to
be
a
string
that
represents
single
code
point
"
+
"
or
grapheme
cluster
got
:
"
+
key
)
;
}
item
.
value
=
key
;
break
;
case
action
.
PointerDown
:
case
action
.
PointerUp
:
assert
.
positiveInteger
(
actionItem
.
button
error
.
pprint
Expected
'
button
'
(
{
actionItem
.
button
}
)
to
be
>
=
0
)
;
item
.
button
=
actionItem
.
button
;
break
;
case
action
.
PointerMove
:
item
.
duration
=
actionItem
.
duration
;
if
(
typeof
item
.
duration
!
=
"
undefined
"
)
{
assert
.
positiveInteger
(
item
.
duration
error
.
pprint
Expected
'
duration
'
(
{
item
.
duration
}
)
to
be
>
=
0
)
;
}
if
(
typeof
actionItem
.
element
!
=
"
undefined
"
&
&
!
element
.
isWebElementReference
(
actionItem
.
element
)
)
{
throw
new
InvalidArgumentError
(
"
Expected
'
actionItem
.
element
'
to
be
a
web
element
reference
"
+
got
:
{
actionItem
.
element
}
)
;
}
item
.
element
=
actionItem
.
element
;
item
.
x
=
actionItem
.
x
;
if
(
typeof
item
.
x
!
=
"
undefined
"
)
{
assert
.
positiveInteger
(
item
.
x
error
.
pprint
Expected
'
x
'
(
{
item
.
x
}
)
to
be
>
=
0
)
;
}
item
.
y
=
actionItem
.
y
;
if
(
typeof
item
.
y
!
=
"
undefined
"
)
{
assert
.
positiveInteger
(
item
.
y
error
.
pprint
Expected
'
y
'
(
{
item
.
y
}
)
to
be
>
=
0
)
;
}
break
;
case
action
.
PointerCancel
:
throw
new
UnsupportedOperationError
(
)
;
break
;
case
action
.
Pause
:
item
.
duration
=
actionItem
.
duration
;
if
(
typeof
item
.
duration
!
=
"
undefined
"
)
{
assert
.
positiveInteger
(
item
.
duration
error
.
pprint
Expected
'
duration
'
(
{
item
.
duration
}
)
to
be
>
=
0
)
;
}
break
;
}
return
item
;
}
}
;
action
.
Chain
=
class
extends
Array
{
toString
(
)
{
return
[
chain
{
super
.
toString
(
)
}
]
;
}
static
fromJson
(
actions
)
{
assert
.
array
(
actions
error
.
pprint
Expected
'
actions
'
to
be
an
Array
got
:
{
actions
}
)
;
let
actionsByTick
=
new
action
.
Chain
(
)
;
for
(
let
actionSequence
of
actions
)
{
let
inputSourceActions
=
action
.
Sequence
.
fromJson
(
actionSequence
)
;
for
(
let
i
=
0
;
i
<
inputSourceActions
.
length
;
i
+
+
)
{
if
(
actionsByTick
.
length
<
(
i
+
1
)
)
{
actionsByTick
.
push
(
[
]
)
;
}
actionsByTick
[
i
]
.
push
(
inputSourceActions
[
i
]
)
;
}
}
return
actionsByTick
;
}
}
;
action
.
Sequence
=
class
extends
Array
{
toString
(
)
{
return
[
sequence
{
super
.
toString
(
)
}
]
;
}
static
fromJson
(
actionSequence
)
{
let
inputSourceState
=
InputState
.
fromJson
(
actionSequence
)
;
let
id
=
actionSequence
.
id
;
assert
.
defined
(
id
"
Expected
'
id
'
to
be
defined
"
)
;
assert
.
string
(
id
error
.
pprint
Expected
'
id
'
to
be
a
string
got
:
{
id
}
)
;
let
actionItems
=
actionSequence
.
actions
;
if
(
!
Array
.
isArray
(
actionItems
)
)
{
throw
new
InvalidArgumentError
(
Expected
'
actionSequence
.
actions
'
to
be
an
Array
got
:
{
actionSequence
.
actions
}
)
;
}
if
(
action
.
inputStateMap
.
has
(
id
)
&
&
!
action
.
inputStateMap
.
get
(
id
)
.
is
(
inputSourceState
)
)
{
throw
new
InvalidArgumentError
(
Expected
{
id
}
to
be
mapped
to
{
inputSourceState
}
+
got
:
{
action
.
inputStateMap
.
get
(
id
)
}
)
;
}
let
actions
=
new
action
.
Sequence
(
)
;
for
(
let
actionItem
of
actionItems
)
{
actions
.
push
(
action
.
Action
.
fromJson
(
actionSequence
actionItem
)
)
;
}
return
actions
;
}
}
;
action
.
PointerParameters
=
class
{
constructor
(
pointerType
=
"
mouse
"
)
{
this
.
pointerType
=
action
.
PointerType
.
get
(
pointerType
)
;
}
toString
(
)
{
return
[
pointerParameters
{
this
.
pointerType
}
]
;
}
static
fromJson
(
parametersData
)
{
if
(
typeof
parametersData
=
=
"
undefined
"
)
{
return
new
action
.
PointerParameters
(
)
;
}
else
{
return
new
action
.
PointerParameters
(
parametersData
.
pointerType
)
;
}
}
}
;
action
.
processPointerAction
=
function
processPointerAction
(
id
pointerParams
act
)
{
let
subtype
=
act
.
subtype
;
if
(
action
.
inputStateMap
.
has
(
id
)
&
&
action
.
inputStateMap
.
get
(
id
)
.
subtype
!
=
=
subtype
)
{
throw
new
InvalidArgumentError
(
Expected
'
id
'
{
id
}
to
be
mapped
to
InputState
whose
subtype
is
+
{
action
.
inputStateMap
.
get
(
id
)
.
subtype
}
got
:
{
subtype
}
)
;
}
act
.
pointerType
=
pointerParams
.
pointerType
;
}
;
action
.
Key
=
class
{
constructor
(
rawKey
)
{
this
.
key
=
NORMALIZED_KEY_LOOKUP
[
rawKey
]
|
|
rawKey
;
this
.
code
=
KEY_CODE_LOOKUP
[
rawKey
]
;
this
.
location
=
KEY_LOCATION_LOOKUP
[
rawKey
]
|
|
0
;
this
.
altKey
=
false
;
this
.
shiftKey
=
false
;
this
.
ctrlKey
=
false
;
this
.
metaKey
=
false
;
this
.
repeat
=
false
;
this
.
isComposing
=
false
;
this
.
keyCode
=
0
;
}
update
(
inputState
)
{
this
.
altKey
=
inputState
.
alt
;
this
.
shiftKey
=
inputState
.
shift
;
this
.
ctrlKey
=
inputState
.
ctrl
;
this
.
metaKey
=
inputState
.
meta
;
}
}
;
action
.
dispatch
=
function
(
chain
seenEls
container
)
{
let
chainEvents
=
Task
.
spawn
(
function
*
(
)
{
for
(
let
tickActions
of
chain
)
{
yield
action
.
dispatchTickActions
(
tickActions
action
.
computeTickDuration
(
tickActions
)
seenEls
container
)
;
}
}
)
;
return
chainEvents
;
}
;
action
.
dispatchTickActions
=
function
(
tickActions
tickDuration
seenEls
container
)
{
let
pendingEvents
=
tickActions
.
map
(
toEvents
(
tickDuration
seenEls
container
)
)
;
return
Promise
.
all
(
pendingEvents
)
.
then
(
(
)
=
>
flushEvents
(
container
)
)
;
}
;
action
.
computeTickDuration
=
function
(
tickActions
)
{
let
max
=
0
;
for
(
let
a
of
tickActions
)
{
let
affectsWallClockTime
=
a
.
subtype
=
=
action
.
Pause
|
|
(
a
.
type
=
=
"
pointer
"
&
&
a
.
subtype
=
=
action
.
PointerMove
)
;
if
(
affectsWallClockTime
&
&
a
.
duration
)
{
max
=
Math
.
max
(
a
.
duration
max
)
;
}
}
return
max
;
}
;
function
toEvents
(
tickDuration
seenEls
container
)
{
return
function
(
a
)
{
if
(
!
action
.
inputStateMap
.
has
(
a
.
id
)
)
{
action
.
inputStateMap
.
set
(
a
.
id
InputState
.
fromJson
(
a
)
)
;
}
let
inputState
=
action
.
inputStateMap
.
get
(
a
.
id
)
;
switch
(
a
.
subtype
)
{
case
action
.
KeyUp
:
return
dispatchKeyUp
(
a
inputState
container
.
frame
)
;
case
action
.
KeyDown
:
return
dispatchKeyDown
(
a
inputState
container
.
frame
)
;
case
action
.
PointerDown
:
case
action
.
PointerUp
:
case
action
.
PointerMove
:
case
action
.
PointerCancel
:
throw
new
UnsupportedOperationError
(
)
;
case
action
.
Pause
:
return
dispatchPause
(
a
tickDuration
)
;
}
}
;
}
function
dispatchKeyDown
(
a
inputState
win
)
{
return
new
Promise
(
resolve
=
>
{
let
keyEvent
=
new
action
.
Key
(
a
.
value
)
;
keyEvent
.
repeat
=
inputState
.
isPressed
(
keyEvent
.
key
)
;
inputState
.
press
(
keyEvent
.
key
)
;
if
(
keyEvent
.
key
in
MODIFIER_NAME_LOOKUP
)
{
inputState
.
setModState
(
keyEvent
.
key
true
)
;
}
action
.
inputsToCancel
.
push
(
Object
.
assign
(
{
}
a
{
subtype
:
action
.
KeyUp
}
)
)
;
keyEvent
.
update
(
inputState
)
;
event
.
sendKeyDown
(
keyEvent
.
key
keyEvent
win
)
;
resolve
(
)
;
}
)
;
}
function
dispatchKeyUp
(
a
inputState
win
)
{
return
new
Promise
(
resolve
=
>
{
let
keyEvent
=
new
action
.
Key
(
a
.
value
)
;
if
(
!
inputState
.
isPressed
(
keyEvent
.
key
)
)
{
resolve
(
)
;
return
;
}
if
(
keyEvent
.
key
in
MODIFIER_NAME_LOOKUP
)
{
inputState
.
setModState
(
keyEvent
.
key
false
)
;
}
inputState
.
release
(
keyEvent
.
key
)
;
keyEvent
.
update
(
inputState
)
;
event
.
sendKeyUp
(
keyEvent
.
key
keyEvent
win
)
;
resolve
(
)
;
}
)
;
}
function
dispatchPause
(
a
tickDuration
)
{
const
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
let
duration
=
typeof
a
.
duration
=
=
"
undefined
"
?
tickDuration
:
a
.
duration
;
return
new
Promise
(
resolve
=
>
timer
.
initWithCallback
(
resolve
duration
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
)
;
}
function
flushEvents
(
container
)
{
return
new
Promise
(
resolve
=
>
container
.
frame
.
requestAnimationFrame
(
resolve
)
)
;
}
function
capitalize
(
str
)
{
if
(
typeof
str
!
=
"
string
"
)
{
throw
new
InvalidArgumentError
(
Expected
string
got
:
{
str
}
)
;
}
return
str
.
charAt
(
0
)
.
toUpperCase
(
)
+
str
.
slice
(
1
)
;
}
