"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
action
"
]
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
this
.
action
=
{
Pause
:
"
pause
"
KeyDown
:
"
keyDown
"
KeyUp
:
"
keyUp
"
PointerDown
:
"
pointerDown
"
PointerUp
:
"
pointerUp
"
PointerMove
:
"
pointerMove
"
PointerCancel
:
"
pointerCancel
"
}
;
const
ACTIONS
=
{
none
:
new
Set
(
[
action
.
Pause
]
)
key
:
new
Set
(
[
action
.
Pause
action
.
KeyDown
action
.
KeyUp
]
)
pointer
:
new
Set
(
[
action
.
Pause
action
.
PointerDown
action
.
PointerUp
action
.
PointerMove
action
.
PointerCancel
]
)
}
;
action
.
PointerType
=
{
Mouse
:
"
mouse
"
Pen
:
"
pen
"
Touch
:
"
touch
"
}
;
action
.
PointerType
.
get
=
function
(
str
)
{
let
name
=
capitalize
(
str
)
;
if
(
!
(
name
in
this
)
)
{
throw
new
InvalidArgumentError
(
Unknown
pointerType
:
{
str
}
)
;
}
return
this
[
name
]
;
}
;
action
.
inputStateMap
=
new
Map
(
)
;
class
InputState
{
constructor
(
)
{
this
.
type
=
this
.
constructor
.
name
.
toLowerCase
(
)
;
}
is
(
other
)
{
if
(
typeof
other
=
=
"
undefined
"
)
{
return
false
;
}
return
this
.
type
=
=
=
other
.
type
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
InputState
]
;
}
static
fromJson
(
actionSequence
)
{
let
type
=
actionSequence
.
type
;
if
(
!
(
type
in
ACTIONS
)
)
{
throw
new
InvalidArgumentError
(
Unknown
action
type
:
{
type
}
)
;
}
let
name
=
type
=
=
"
none
"
?
"
Null
"
:
capitalize
(
type
)
;
return
new
action
.
InputState
[
name
]
(
)
;
}
}
action
.
InputState
=
{
}
;
action
.
InputState
.
Key
=
class
extends
InputState
{
constructor
(
)
{
super
(
)
;
this
.
pressed
=
new
Set
(
)
;
this
.
alt
=
false
;
this
.
shift
=
false
;
this
.
ctrl
=
false
;
this
.
meta
=
false
;
}
}
;
action
.
InputState
.
Null
=
class
extends
InputState
{
constructor
(
)
{
super
(
)
;
this
.
type
=
"
none
"
;
}
}
;
action
.
InputState
.
Pointer
=
class
extends
InputState
{
constructor
(
subtype
primary
)
{
super
(
)
;
this
.
pressed
=
new
Set
(
)
;
this
.
subtype
=
subtype
;
this
.
primary
=
primary
;
this
.
x
=
0
;
this
.
y
=
0
;
}
}
;
action
.
Action
=
class
{
constructor
(
id
type
subtype
)
{
if
(
[
id
type
subtype
]
.
includes
(
undefined
)
)
{
throw
new
InvalidArgumentError
(
"
Missing
id
type
or
subtype
"
)
;
}
for
(
let
attr
of
[
id
type
subtype
]
)
{
if
(
typeof
attr
!
=
"
string
"
)
{
throw
new
InvalidArgumentError
(
Expected
string
got
:
{
attr
}
)
;
}
}
this
.
id
=
id
;
this
.
type
=
type
;
this
.
subtype
=
subtype
;
}
;
toString
(
)
{
return
[
action
{
this
.
type
}
]
;
}
static
fromJson
(
actionSequence
actionItem
)
{
let
type
=
actionSequence
.
type
;
let
id
=
actionSequence
.
id
;
let
subtypes
=
ACTIONS
[
type
]
;
if
(
!
subtypes
)
{
throw
new
InvalidArgumentError
(
"
Unknown
type
:
"
+
type
)
;
}
let
subtype
=
actionItem
.
type
;
if
(
!
subtypes
.
has
(
subtype
)
)
{
throw
new
InvalidArgumentError
(
Unknown
subtype
for
{
type
}
action
:
{
subtype
}
)
;
}
let
item
=
new
action
.
Action
(
id
type
subtype
)
;
if
(
type
=
=
=
"
pointer
"
)
{
action
.
processPointerAction
(
id
action
.
PointerParameters
.
fromJson
(
actionSequence
.
parameters
)
item
)
;
}
switch
(
item
.
subtype
)
{
case
action
.
KeyUp
:
case
action
.
KeyDown
:
let
key
=
actionItem
.
value
;
if
(
typeof
key
!
=
"
string
"
|
|
(
typeof
key
=
=
"
string
"
&
&
key
.
length
!
=
1
)
)
{
throw
new
InvalidArgumentError
(
"
Expected
'
key
'
to
be
a
single
-
character
string
"
+
"
got
:
"
+
key
)
;
}
item
.
value
=
key
;
break
;
case
action
.
PointerDown
:
case
action
.
PointerUp
:
assertPositiveInteger
(
actionItem
.
button
"
button
"
)
;
item
.
button
=
actionItem
.
button
;
break
;
case
action
.
PointerMove
:
item
.
duration
=
actionItem
.
duration
;
if
(
typeof
item
.
duration
!
=
"
undefined
"
)
{
assertPositiveInteger
(
item
.
duration
"
duration
"
)
;
}
if
(
typeof
actionItem
.
element
!
=
"
undefined
"
&
&
!
element
.
isWebElementReference
(
actionItem
.
element
)
)
{
throw
new
InvalidArgumentError
(
"
Expected
'
actionItem
.
element
'
to
be
a
web
element
reference
"
+
got
:
{
actionItem
.
element
}
)
;
}
item
.
element
=
actionItem
.
element
;
item
.
x
=
actionItem
.
x
;
if
(
typeof
item
.
x
!
=
"
undefined
"
)
{
assertPositiveInteger
(
item
.
x
"
x
"
)
;
}
item
.
y
=
actionItem
.
y
;
if
(
typeof
item
.
y
!
=
"
undefined
"
)
{
assertPositiveInteger
(
item
.
y
"
y
"
)
;
}
break
;
case
action
.
PointerCancel
:
throw
new
UnsupportedOperationError
(
)
;
break
;
case
action
.
Pause
:
item
.
duration
=
actionItem
.
duration
;
if
(
typeof
item
.
duration
!
=
"
undefined
"
)
{
assertPositiveInteger
(
item
.
duration
"
duration
"
)
;
}
break
;
}
return
item
;
}
}
;
action
.
Chain
=
class
extends
Array
{
toString
(
)
{
return
[
chain
{
super
.
toString
(
)
}
]
;
}
static
fromJson
(
actions
)
{
if
(
!
Array
.
isArray
(
actions
)
)
{
throw
new
InvalidArgumentError
(
Expected
'
actions
'
to
be
an
Array
got
:
{
actions
}
)
;
}
let
actionsByTick
=
new
action
.
Chain
(
)
;
for
(
let
actionSequence
of
actions
)
{
let
inputSourceActions
=
action
.
Sequence
.
fromJson
(
actionSequence
)
;
for
(
let
i
=
0
;
i
<
inputSourceActions
.
length
;
i
+
+
)
{
if
(
actionsByTick
.
length
<
(
i
+
1
)
)
{
actionsByTick
.
push
(
[
]
)
;
}
actionsByTick
[
i
]
.
push
(
inputSourceActions
[
i
]
)
;
}
}
return
actionsByTick
;
}
}
;
action
.
Sequence
=
class
extends
Array
{
toString
(
)
{
return
[
sequence
{
super
.
toString
(
)
}
]
;
}
static
fromJson
(
actionSequence
)
{
let
inputSourceState
=
InputState
.
fromJson
(
actionSequence
)
;
let
id
=
actionSequence
.
id
;
if
(
typeof
id
=
=
"
undefined
"
)
{
actionSequence
.
id
=
id
=
element
.
generateUUID
(
)
;
}
else
if
(
typeof
id
!
=
"
string
"
)
{
throw
new
InvalidArgumentError
(
Expected
'
id
'
to
be
a
string
got
:
{
id
}
)
;
}
let
actionItems
=
actionSequence
.
actions
;
if
(
!
Array
.
isArray
(
actionItems
)
)
{
throw
new
InvalidArgumentError
(
Expected
'
actionSequence
.
actions
'
to
be
an
Array
got
:
{
actionSequence
.
actions
}
)
;
}
if
(
action
.
inputStateMap
.
has
(
id
)
&
&
!
action
.
inputStateMap
.
get
(
id
)
.
is
(
inputSourceState
)
)
{
throw
new
InvalidArgumentError
(
Expected
{
id
}
to
be
mapped
to
{
inputSourceState
}
+
got
:
{
action
.
inputStateMap
.
get
(
id
)
}
)
;
}
let
actions
=
new
action
.
Sequence
(
)
;
for
(
let
actionItem
of
actionItems
)
{
actions
.
push
(
action
.
Action
.
fromJson
(
actionSequence
actionItem
)
)
;
}
return
actions
;
}
}
;
action
.
PointerParameters
=
class
{
constructor
(
pointerType
=
"
mouse
"
primary
=
true
)
{
this
.
pointerType
=
action
.
PointerType
.
get
(
pointerType
)
;
assertBoolean
(
primary
"
primary
"
)
;
this
.
primary
=
primary
;
}
;
toString
(
)
{
return
[
pointerParameters
{
this
.
pointerType
}
primary
=
{
this
.
primary
}
]
;
}
static
fromJson
(
parametersData
)
{
if
(
typeof
parametersData
=
=
"
undefined
"
)
{
return
new
action
.
PointerParameters
(
)
;
}
else
{
return
new
action
.
PointerParameters
(
parametersData
.
pointerType
parametersData
.
primary
)
;
}
}
}
;
action
.
processPointerAction
=
function
processPointerAction
(
id
pointerParams
act
)
{
let
subtype
=
act
.
subtype
;
if
(
action
.
inputStateMap
.
has
(
id
)
&
&
action
.
inputStateMap
.
get
(
id
)
.
subtype
!
=
=
subtype
)
{
throw
new
InvalidArgumentError
(
Expected
'
id
'
{
id
}
to
be
mapped
to
InputState
whose
subtype
is
+
{
action
.
inputStateMap
.
get
(
id
)
.
subtype
}
got
:
{
subtype
}
)
;
}
act
.
pointerType
=
pointerParams
.
pointerType
;
act
.
primary
=
pointerParams
.
primary
;
}
;
function
assertPositiveInteger
(
value
name
=
undefined
)
{
let
suffix
=
name
?
(
{
name
}
)
:
'
'
;
if
(
!
Number
.
isInteger
(
value
)
|
|
value
<
0
)
{
throw
new
InvalidArgumentError
(
Expected
integer
>
=
0
{
suffix
}
got
:
{
value
}
)
;
}
}
function
assertBoolean
(
value
name
=
undefined
)
{
let
suffix
=
name
?
(
{
name
}
)
:
'
'
;
if
(
typeof
(
value
)
!
=
"
boolean
"
)
{
throw
new
InvalidArgumentError
(
Expected
boolean
{
suffix
}
got
:
{
value
}
)
;
}
}
function
capitalize
(
str
)
{
if
(
typeof
str
!
=
"
string
"
)
{
throw
new
InvalidArgumentError
(
Expected
string
got
:
{
str
}
)
;
}
return
str
.
charAt
(
0
)
.
toUpperCase
(
)
+
str
.
slice
(
1
)
;
}
