"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
InvalidArgumentError
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
log
.
js
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
Log
.
get
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
crypto
"
]
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
capture
"
]
;
const
CONTEXT_2D
=
"
2d
"
;
const
BG_COLOUR
=
"
rgb
(
255
255
255
)
"
;
const
MAX_SKIA_DIMENSIONS
=
32767
;
const
PNG_MIME
=
"
image
/
png
"
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
this
.
capture
=
{
}
;
capture
.
Format
=
{
Base64
:
0
Hash
:
1
}
;
capture
.
element
=
function
(
node
highlights
=
[
]
)
{
let
win
=
node
.
ownerGlobal
;
let
rect
=
node
.
getBoundingClientRect
(
)
;
return
capture
.
canvas
(
win
rect
.
left
rect
.
top
rect
.
width
rect
.
height
{
highlights
}
)
;
}
;
capture
.
viewport
=
function
(
win
highlights
=
[
]
)
{
return
capture
.
canvas
(
win
win
.
pageXOffset
win
.
pageYOffset
win
.
innerWidth
win
.
innerHeight
{
highlights
}
)
;
}
;
capture
.
canvas
=
function
(
win
left
top
width
height
{
highlights
=
[
]
canvas
=
null
flags
=
null
}
=
{
}
)
{
const
scale
=
win
.
devicePixelRatio
;
if
(
canvas
=
=
=
null
)
{
let
canvasWidth
=
width
*
scale
;
let
canvasHeight
=
height
*
scale
;
if
(
canvasWidth
>
MAX_SKIA_DIMENSIONS
)
{
logger
.
warn
(
"
Reducing
screenshot
width
because
it
exceeds
"
+
MAX_SKIA_DIMENSIONS
+
"
pixels
"
)
;
canvasWidth
=
MAX_SKIA_DIMENSIONS
;
}
if
(
canvasHeight
>
MAX_SKIA_DIMENSIONS
)
{
logger
.
warn
(
"
Reducing
screenshot
height
because
it
exceeds
"
+
MAX_SKIA_DIMENSIONS
+
"
pixels
"
)
;
canvasHeight
=
MAX_SKIA_DIMENSIONS
;
}
canvas
=
win
.
document
.
createElementNS
(
XHTML_NS
"
canvas
"
)
;
canvas
.
width
=
canvasWidth
;
canvas
.
height
=
canvasHeight
;
}
let
ctx
=
canvas
.
getContext
(
CONTEXT_2D
)
;
if
(
flags
=
=
=
null
)
{
flags
=
ctx
.
DRAWWINDOW_DRAW_CARET
;
}
ctx
.
scale
(
scale
scale
)
;
ctx
.
drawWindow
(
win
left
top
width
height
BG_COLOUR
flags
)
;
if
(
highlights
.
length
)
{
ctx
=
capture
.
highlight_
(
ctx
highlights
top
left
)
;
}
return
canvas
;
}
;
capture
.
highlight_
=
function
(
context
highlights
top
=
0
left
=
0
)
{
if
(
typeof
highlights
=
=
"
undefined
"
)
{
throw
new
InvalidArgumentError
(
"
Missing
highlights
"
)
;
}
context
.
lineWidth
=
"
2
"
;
context
.
strokeStyle
=
"
red
"
;
context
.
save
(
)
;
for
(
let
el
of
highlights
)
{
let
rect
=
el
.
getBoundingClientRect
(
)
;
let
oy
=
-
top
;
let
ox
=
-
left
;
context
.
strokeRect
(
rect
.
left
+
ox
rect
.
top
+
oy
rect
.
width
rect
.
height
)
;
}
return
context
;
}
;
capture
.
toBase64
=
function
(
canvas
)
{
let
u
=
canvas
.
toDataURL
(
PNG_MIME
)
;
return
u
.
substring
(
u
.
indexOf
(
"
"
)
+
1
)
;
}
;
capture
.
toHash
=
function
(
canvas
)
{
let
u
=
capture
.
toBase64
(
canvas
)
;
let
buffer
=
new
TextEncoder
(
"
utf
-
8
"
)
.
encode
(
u
)
;
return
crypto
.
subtle
.
digest
(
"
SHA
-
256
"
buffer
)
.
then
(
hash
=
>
hex
(
hash
)
)
;
}
;
function
hex
(
buffer
)
{
let
hexCodes
=
[
]
;
let
view
=
new
DataView
(
buffer
)
;
for
(
let
i
=
0
;
i
<
view
.
byteLength
;
i
+
=
4
)
{
let
value
=
view
.
getUint32
(
i
)
;
let
stringValue
=
value
.
toString
(
16
)
;
let
padding
=
"
00000000
"
;
let
paddedValue
=
(
padding
+
stringValue
)
.
slice
(
-
padding
.
length
)
;
hexCodes
.
push
(
paddedValue
)
;
}
return
hexCodes
.
join
(
"
"
)
;
}
