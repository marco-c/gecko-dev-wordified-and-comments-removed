"
use
strict
"
;
const
{
utils
:
Cu
}
=
Components
;
Cu
.
importGlobalProperties
(
[
"
crypto
"
]
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
capture
"
]
;
const
CONTEXT_2D
=
"
2d
"
;
const
BG_COLOUR
=
"
rgb
(
255
255
255
)
"
;
const
PNG_MIME
=
"
image
/
png
"
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
this
.
capture
=
{
}
;
capture
.
element
=
function
(
node
highlights
=
[
]
)
{
let
doc
=
node
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
rect
=
node
.
getBoundingClientRect
(
)
;
return
capture
.
canvas
(
doc
rect
.
left
rect
.
top
rect
.
width
rect
.
height
highlights
)
;
}
;
capture
.
viewport
=
function
(
document
highlights
=
[
]
)
{
let
win
=
document
.
defaultView
;
let
docEl
=
document
.
documentElement
;
return
capture
.
canvas
(
document
win
.
pageXOffset
win
.
pageYOffset
docEl
.
clientWidth
docEl
.
clientHeight
highlights
)
;
}
;
capture
.
canvas
=
function
(
document
left
top
width
height
highlights
=
[
]
)
{
let
win
=
document
.
defaultView
;
let
canvas
=
document
.
createElementNS
(
XHTML_NS
"
canvas
"
)
;
canvas
.
width
=
width
;
canvas
.
height
=
height
;
let
ctx
=
canvas
.
getContext
(
CONTEXT_2D
)
;
ctx
.
drawWindow
(
win
left
top
width
height
BG_COLOUR
)
;
ctx
=
capture
.
highlight_
(
ctx
highlights
top
left
)
;
return
canvas
;
}
;
capture
.
highlight_
=
function
(
context
highlights
top
=
0
left
=
0
)
{
if
(
!
highlights
)
{
return
;
}
context
.
lineWidth
=
"
2
"
;
context
.
strokeStyle
=
"
red
"
;
context
.
save
(
)
;
for
(
let
el
of
highlights
)
{
let
rect
=
el
.
getBoundingClientRect
(
)
;
let
oy
=
-
top
;
let
ox
=
-
left
;
context
.
strokeRect
(
rect
.
left
+
ox
rect
.
top
+
oy
rect
.
width
rect
.
height
)
;
}
return
context
;
}
;
capture
.
toBase64
=
function
(
canvas
)
{
let
u
=
canvas
.
toDataURL
(
PNG_MIME
)
;
return
u
.
substring
(
u
.
indexOf
(
"
"
)
+
1
)
;
}
;
capture
.
toHash
=
function
(
canvas
)
{
let
u
=
capture
.
toBase64
(
canvas
)
;
let
buffer
=
new
TextEncoder
(
"
utf
-
8
"
)
.
encode
(
u
)
;
return
crypto
.
subtle
.
digest
(
"
SHA
-
256
"
buffer
)
.
then
(
hash
=
>
hex
(
hash
)
)
;
}
;
function
hex
(
buffer
)
{
let
hexCodes
=
[
]
;
let
view
=
new
DataView
(
buffer
)
;
for
(
let
i
=
0
;
i
<
view
.
byteLength
;
i
+
=
4
)
{
let
value
=
view
.
getUint32
(
i
)
;
let
stringValue
=
value
.
toString
(
16
)
;
let
padding
=
'
00000000
'
;
let
paddedValue
=
(
padding
+
stringValue
)
.
slice
(
-
padding
.
length
)
;
hexCodes
.
push
(
paddedValue
)
;
}
return
hexCodes
.
join
(
"
"
)
;
}
;
