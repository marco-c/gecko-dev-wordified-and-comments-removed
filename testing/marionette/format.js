"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
truncate
"
]
;
const
MAX_STRING_LENGTH
=
250
;
function
truncate
(
strings
.
.
.
values
)
{
function
walk
(
obj
)
{
const
typ
=
Object
.
prototype
.
toString
.
call
(
obj
)
;
switch
(
typ
)
{
case
"
[
object
Undefined
]
"
:
case
"
[
object
Null
]
"
:
case
"
[
object
Boolean
]
"
:
case
"
[
object
Number
]
"
:
return
obj
;
case
"
[
object
String
]
"
:
if
(
obj
.
length
>
MAX_STRING_LENGTH
)
{
let
s1
=
obj
.
substring
(
0
(
MAX_STRING_LENGTH
/
2
)
)
;
let
s2
=
obj
.
substring
(
obj
.
length
-
(
MAX_STRING_LENGTH
/
2
)
)
;
return
{
s1
}
.
.
.
{
s2
}
;
}
return
obj
;
case
"
[
object
Array
]
"
:
return
obj
.
map
(
walk
)
;
default
:
if
(
Object
.
getOwnPropertyNames
(
obj
)
.
includes
(
"
toString
"
)
&
&
typeof
obj
.
toString
=
=
"
function
"
)
{
return
walk
(
obj
.
toString
(
)
)
;
}
let
rv
=
{
}
;
for
(
let
prop
in
obj
)
{
rv
[
prop
]
=
walk
(
obj
[
prop
]
)
;
}
return
rv
;
}
}
let
res
=
[
]
;
for
(
let
i
=
0
;
i
<
strings
.
length
;
+
+
i
)
{
res
.
push
(
strings
[
i
]
)
;
if
(
i
<
values
.
length
)
{
let
obj
=
walk
(
values
[
i
]
)
;
let
t
=
Object
.
prototype
.
toString
.
call
(
obj
)
;
if
(
t
=
=
"
[
object
Array
]
"
|
|
t
=
=
"
[
object
Object
]
"
)
{
res
.
push
(
JSON
.
stringify
(
obj
)
)
;
}
else
{
res
.
push
(
obj
)
;
}
}
}
return
res
.
join
(
"
"
)
;
}
this
.
truncate
=
truncate
;
