"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
atom
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
element
"
"
ElementManager
"
]
;
const
DOCUMENT_POSITION_DISCONNECTED
=
1
;
const
XMLNS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
uuidGen
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
this
.
element
=
{
}
;
element
.
LegacyKey
=
"
ELEMENT
"
;
element
.
Key
=
"
element
-
6066
-
11e4
-
a52e
-
4f735466cecf
"
;
element
.
Strategy
=
{
ClassName
:
"
class
name
"
Selector
:
"
css
selector
"
ID
:
"
id
"
Name
:
"
name
"
LinkText
:
"
link
text
"
PartialLinkText
:
"
partial
link
text
"
TagName
:
"
tag
name
"
XPath
:
"
xpath
"
Anon
:
"
anon
"
AnonAttribute
:
"
anon
attribute
"
}
;
element
.
Strategies
=
new
Set
(
Object
.
values
(
element
.
Strategy
)
)
;
this
.
ElementManager
=
function
ElementManager
(
unsupportedStrategies
=
[
]
)
{
this
.
seenItems
=
{
}
;
this
.
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
supportedStrategies
=
new
Set
(
element
.
Strategies
)
;
for
(
let
s
of
unsupportedStrategies
)
{
this
.
supportedStrategies
.
delete
(
s
)
;
}
}
;
ElementManager
.
prototype
=
{
reset
:
function
EM_clear
(
)
{
this
.
seenItems
=
{
}
;
}
addToKnownElements
:
function
EM_addToKnownElements
(
el
)
{
for
(
let
i
in
this
.
seenItems
)
{
let
foundEl
=
null
;
try
{
foundEl
=
this
.
seenItems
[
i
]
.
get
(
)
;
}
catch
(
e
)
{
}
if
(
foundEl
)
{
if
(
XPCNativeWrapper
(
foundEl
)
=
=
XPCNativeWrapper
(
el
)
)
{
return
i
;
}
}
else
{
delete
this
.
seenItems
[
i
]
;
}
}
let
id
=
element
.
generateUUID
(
)
;
this
.
seenItems
[
id
]
=
Cu
.
getWeakReference
(
el
)
;
return
id
;
}
getKnownElement
:
function
EM_getKnownElement
(
id
container
)
{
let
el
=
this
.
seenItems
[
id
]
;
if
(
!
el
)
{
throw
new
JavaScriptError
(
Element
has
not
been
seen
before
.
Id
given
was
{
id
}
)
;
}
try
{
el
=
el
.
get
(
)
;
}
catch
(
e
)
{
el
=
null
;
delete
this
.
seenItems
[
id
]
;
}
let
wrappedFrame
=
XPCNativeWrapper
(
container
.
frame
)
;
let
wrappedShadowRoot
;
if
(
container
.
shadowRoot
)
{
wrappedShadowRoot
=
XPCNativeWrapper
(
container
.
shadowRoot
)
;
}
if
(
!
el
|
|
!
(
XPCNativeWrapper
(
el
)
.
ownerDocument
=
=
wrappedFrame
.
document
)
|
|
this
.
isDisconnected
(
XPCNativeWrapper
(
el
)
wrappedShadowRoot
wrappedFrame
)
)
{
throw
new
StaleElementReferenceError
(
"
The
element
reference
is
stale
.
Either
the
element
"
+
"
is
no
longer
attached
to
the
DOM
or
the
page
has
been
refreshed
.
"
)
;
}
return
el
;
}
isDisconnected
:
function
EM_isDisconnected
(
el
shadowRoot
frame
)
{
if
(
shadowRoot
&
&
frame
.
ShadowRoot
)
{
if
(
el
.
compareDocumentPosition
(
shadowRoot
)
&
DOCUMENT_POSITION_DISCONNECTED
)
{
return
true
;
}
let
parent
=
shadowRoot
.
host
;
while
(
parent
&
&
!
(
parent
instanceof
frame
.
ShadowRoot
)
)
{
parent
=
parent
.
parentNode
;
}
return
this
.
isDisconnected
(
shadowRoot
.
host
parent
frame
)
;
}
else
{
return
el
.
compareDocumentPosition
(
frame
.
document
.
documentElement
)
&
DOCUMENT_POSITION_DISCONNECTED
;
}
}
wrapValue
:
function
EM_wrapValue
(
val
)
{
let
result
=
null
;
switch
(
typeof
(
val
)
)
{
case
"
undefined
"
:
result
=
null
;
break
;
case
"
string
"
:
case
"
number
"
:
case
"
boolean
"
:
result
=
val
;
break
;
case
"
object
"
:
let
type
=
Object
.
prototype
.
toString
.
call
(
val
)
;
if
(
type
=
=
"
[
object
Array
]
"
|
|
type
=
=
"
[
object
NodeList
]
"
)
{
result
=
[
]
;
for
(
let
i
=
0
;
i
<
val
.
length
;
+
+
i
)
{
result
.
push
(
this
.
wrapValue
(
val
[
i
]
)
)
;
}
}
else
if
(
val
=
=
null
)
{
result
=
null
;
}
else
if
(
val
.
nodeType
=
=
1
)
{
let
elementId
=
this
.
addToKnownElements
(
val
)
;
result
=
{
[
element
.
LegacyKey
]
:
elementId
[
element
.
Key
]
:
elementId
}
;
}
else
{
result
=
{
}
;
for
(
let
prop
in
val
)
{
try
{
result
[
prop
]
=
this
.
wrapValue
(
val
[
prop
]
)
;
}
catch
(
e
if
(
e
.
result
=
=
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
)
{
logger
.
debug
(
Skipping
{
prop
}
due
to
:
{
e
.
message
}
)
;
}
}
}
break
;
}
return
result
;
}
convertWrappedArguments
:
function
EM_convertWrappedArguments
(
args
container
)
{
let
converted
;
switch
(
typeof
(
args
)
)
{
case
'
number
'
:
case
'
string
'
:
case
'
boolean
'
:
converted
=
args
;
break
;
case
'
object
'
:
if
(
args
=
=
null
)
{
converted
=
null
;
}
else
if
(
Object
.
prototype
.
toString
.
call
(
args
)
=
=
'
[
object
Array
]
'
)
{
converted
=
[
]
;
for
(
let
i
in
args
)
{
converted
.
push
(
this
.
convertWrappedArguments
(
args
[
i
]
container
)
)
;
}
}
else
if
(
(
(
typeof
(
args
[
element
.
LegacyKey
]
)
=
=
=
'
string
'
)
&
&
args
.
hasOwnProperty
(
element
.
LegacyKey
)
)
|
|
(
(
typeof
(
args
[
element
.
Key
]
)
=
=
=
'
string
'
)
&
&
args
.
hasOwnProperty
(
element
.
Key
)
)
)
{
let
elementUniqueIdentifier
=
args
[
element
.
Key
]
?
args
[
element
.
Key
]
:
args
[
element
.
LegacyKey
]
;
converted
=
this
.
getKnownElement
(
elementUniqueIdentifier
container
)
;
if
(
converted
=
=
null
)
{
throw
new
WebDriverError
(
Unknown
element
:
{
elementUniqueIdentifier
}
)
;
}
}
else
{
converted
=
{
}
;
for
(
let
prop
in
args
)
{
converted
[
prop
]
=
this
.
convertWrappedArguments
(
args
[
prop
]
container
)
;
}
}
break
;
}
return
converted
;
}
find
:
function
(
container
strategy
selector
opts
=
{
}
)
{
opts
.
all
=
!
!
opts
.
all
;
opts
.
timeout
=
opts
.
timeout
|
|
0
;
let
searchFn
;
if
(
opts
.
all
)
{
searchFn
=
this
.
findElements
.
bind
(
this
)
;
}
else
{
searchFn
=
this
.
findElement
.
bind
(
this
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
findElements
=
implicitlyWaitFor
(
(
)
=
>
this
.
find_
(
container
strategy
selector
searchFn
opts
)
opts
.
timeout
)
;
findElements
.
then
(
foundEls
=
>
{
if
(
!
opts
.
all
&
&
(
!
foundEls
|
|
foundEls
.
length
=
=
0
)
)
{
let
msg
;
switch
(
strategy
)
{
case
element
.
Strategy
.
AnonAttribute
:
msg
=
"
Unable
to
locate
anonymous
element
:
"
+
JSON
.
stringify
(
selector
)
;
break
;
default
:
msg
=
"
Unable
to
locate
element
:
"
+
selector
;
}
reject
(
new
NoSuchElementError
(
msg
)
)
;
}
let
rv
=
[
]
;
for
(
let
el
of
foundEls
)
{
let
ref
=
this
.
addToKnownElements
(
el
)
;
let
we
=
element
.
makeWebElement
(
ref
)
;
rv
.
push
(
we
)
;
}
if
(
opts
.
all
)
{
resolve
(
rv
)
;
}
resolve
(
rv
[
0
]
)
;
}
reject
)
;
}
)
;
}
find_
:
function
(
container
strategy
selector
searchFn
opts
)
{
let
rootNode
=
container
.
shadowRoot
|
|
container
.
frame
.
document
;
let
startNode
;
if
(
opts
.
startNode
)
{
startNode
=
this
.
getKnownElement
(
opts
.
startNode
container
)
;
}
else
{
startNode
=
rootNode
;
}
if
(
!
this
.
supportedStrategies
.
has
(
strategy
)
)
{
throw
new
InvalidSelectorError
(
"
Strategy
not
supported
:
"
+
strategy
)
;
}
let
res
;
try
{
res
=
searchFn
(
strategy
selector
rootNode
startNode
)
;
}
catch
(
e
)
{
throw
new
InvalidSelectorError
(
Given
{
strategy
}
expression
"
{
selector
}
"
is
invalid
)
;
}
if
(
element
.
isElementCollection
(
res
)
)
{
return
res
;
}
else
if
(
res
)
{
return
[
res
]
;
}
return
[
]
;
}
findByXPath
:
function
EM_findByXPath
(
root
value
node
)
{
return
root
.
evaluate
(
value
node
null
Ci
.
nsIDOMXPathResult
.
FIRST_ORDERED_NODE_TYPE
null
)
.
singleNodeValue
;
}
findByXPathAll
:
function
EM_findByXPathAll
(
root
value
node
)
{
let
values
=
root
.
evaluate
(
value
node
null
Ci
.
nsIDOMXPathResult
.
ORDERED_NODE_ITERATOR_TYPE
null
)
;
let
elements
=
[
]
;
let
element
=
values
.
iterateNext
(
)
;
while
(
element
)
{
elements
.
push
(
element
)
;
element
=
values
.
iterateNext
(
)
;
}
return
elements
;
}
findElement
:
function
(
using
value
rootNode
startNode
)
{
switch
(
using
)
{
case
element
.
Strategy
.
ID
:
if
(
startNode
.
getElementById
)
{
return
startNode
.
getElementById
(
value
)
;
}
return
this
.
findByXPath
(
rootNode
.
/
/
*
[
id
=
"
{
value
}
"
]
startNode
)
;
case
element
.
Strategy
.
Name
:
if
(
startNode
.
getElementsByName
)
{
return
startNode
.
getElementsByName
(
value
)
[
0
]
;
}
return
this
.
findByXPath
(
rootNode
.
/
/
*
[
name
=
"
{
value
}
"
]
startNode
)
;
case
element
.
Strategy
.
ClassName
:
return
startNode
.
getElementsByClassName
(
value
)
[
0
]
;
case
element
.
Strategy
.
TagName
:
return
startNode
.
getElementsByTagName
(
value
)
[
0
]
;
case
element
.
Strategy
.
XPath
:
return
this
.
findByXPath
(
rootNode
value
startNode
)
;
case
element
.
Strategy
.
LinkText
:
case
element
.
Strategy
.
PartialLinkText
:
let
el
;
let
allLinks
=
startNode
.
getElementsByTagName
(
"
A
"
)
;
for
(
let
i
=
0
;
i
<
allLinks
.
length
&
&
!
el
;
i
+
+
)
{
let
text
=
allLinks
[
i
]
.
text
;
if
(
using
=
=
element
.
Strategy
.
PartialLinkText
)
{
if
(
text
.
indexOf
(
value
)
!
=
-
1
)
{
el
=
allLinks
[
i
]
;
}
}
else
if
(
text
=
=
value
)
{
el
=
allLinks
[
i
]
;
}
}
return
el
;
case
element
.
Strategy
.
Selector
:
try
{
return
startNode
.
querySelector
(
value
)
;
}
catch
(
e
)
{
throw
new
InvalidSelectorError
(
{
e
.
message
}
:
"
{
value
}
"
)
;
}
case
element
.
Strategy
.
Anon
:
return
rootNode
.
getAnonymousNodes
(
startNode
)
;
case
element
.
Strategy
.
AnonAttribute
:
let
attr
=
Object
.
keys
(
value
)
[
0
]
;
return
rootNode
.
getAnonymousElementByAttribute
(
startNode
attr
value
[
attr
]
)
;
default
:
throw
new
InvalidSelectorError
(
No
such
strategy
:
{
using
}
)
;
}
}
findElements
:
function
(
using
value
rootNode
startNode
)
{
switch
(
using
)
{
case
element
.
Strategy
.
ID
:
value
=
.
/
/
*
[
id
=
"
{
value
}
"
]
;
case
element
.
Strategy
.
XPath
:
return
this
.
findByXPathAll
(
rootNode
value
startNode
)
;
case
element
.
Strategy
.
Name
:
if
(
startNode
.
getElementsByName
)
{
return
startNode
.
getElementsByName
(
value
)
;
}
return
this
.
findByXPathAll
(
rootNode
.
/
/
*
[
name
=
"
{
value
}
"
]
startNode
)
;
case
element
.
Strategy
.
ClassName
:
return
startNode
.
getElementsByClassName
(
value
)
;
case
element
.
Strategy
.
TagName
:
return
startNode
.
getElementsByTagName
(
value
)
;
case
element
.
Strategy
.
LinkText
:
case
element
.
Strategy
.
PartialLinkText
:
let
els
=
[
]
;
let
allLinks
=
startNode
.
getElementsByTagName
(
"
A
"
)
;
for
(
let
i
=
0
;
i
<
allLinks
.
length
;
i
+
+
)
{
let
text
=
allLinks
[
i
]
.
text
;
if
(
using
=
=
element
.
Strategy
.
PartialLinkText
)
{
if
(
text
.
indexOf
(
value
)
!
=
-
1
)
{
els
.
push
(
allLinks
[
i
]
)
;
}
}
else
if
(
text
=
=
value
)
{
els
.
push
(
allLinks
[
i
]
)
;
}
}
return
els
;
case
element
.
Strategy
.
Selector
:
return
Array
.
slice
(
startNode
.
querySelectorAll
(
value
)
)
;
case
element
.
Strategy
.
Anon
:
return
rootNode
.
getAnonymousNodes
(
startNode
)
;
case
element
.
Strategy
.
AnonAttribute
:
let
attr
=
Object
.
keys
(
value
)
[
0
]
;
let
el
=
rootNode
.
getAnonymousElementByAttribute
(
startNode
attr
value
[
attr
]
)
;
if
(
el
)
{
return
[
el
]
;
}
return
[
]
;
default
:
throw
new
InvalidSelectorError
(
No
such
strategy
:
{
using
}
)
;
}
}
}
;
function
implicitlyWaitFor
(
func
timeout
interval
=
100
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
startTime
=
new
Date
(
)
.
getTime
(
)
;
let
endTime
=
startTime
+
timeout
;
let
elementSearch
=
function
(
)
{
let
res
;
try
{
res
=
func
(
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
let
col
=
element
.
isElementCollection
(
res
)
;
if
(
(
(
col
&
&
res
.
length
>
0
)
|
|
(
!
col
&
&
!
!
res
)
)
|
|
(
startTime
=
=
endTime
|
|
new
Date
(
)
.
getTime
(
)
>
=
endTime
)
)
{
resolve
(
res
)
;
}
}
;
elementSearch
(
)
;
timer
.
init
(
elementSearch
interval
Ci
.
nsITimer
.
TYPE_REPEATING_SLACK
)
;
}
)
.
then
(
res
=
>
{
timer
.
cancel
(
)
;
return
res
;
}
err
=
>
{
timer
.
cancel
(
)
;
throw
err
;
}
)
;
}
element
.
isElementCollection
=
function
(
seq
)
{
if
(
seq
=
=
=
null
)
{
return
false
;
}
const
arrayLike
=
{
"
[
object
Array
]
"
:
0
"
[
object
HTMLCollection
]
"
:
1
"
[
object
NodeList
]
"
:
2
}
;
let
typ
=
Object
.
prototype
.
toString
.
call
(
seq
)
;
return
typ
in
arrayLike
;
}
;
element
.
makeWebElement
=
function
(
uuid
)
{
return
{
[
element
.
Key
]
:
uuid
[
element
.
LegacyKey
]
:
uuid
}
;
}
;
element
.
generateUUID
=
function
(
)
{
let
uuid
=
uuidGen
.
generateUUID
(
)
.
toString
(
)
;
return
uuid
.
substring
(
1
uuid
.
length
-
1
)
;
}
;
element
.
coordinates
=
function
(
node
xOffset
=
undefined
yOffset
=
undefined
)
{
let
box
=
node
.
getBoundingClientRect
(
)
;
if
(
typeof
xOffset
=
=
"
undefined
"
|
|
xOffset
=
=
=
null
)
{
xOffset
=
box
.
width
/
2
.
0
;
}
if
(
typeof
yOffset
=
=
"
undefined
"
|
|
yOffset
=
=
=
null
)
{
yOffset
=
box
.
height
/
2
.
0
;
}
if
(
typeof
yOffset
!
=
"
number
"
|
|
typeof
xOffset
!
=
"
number
"
)
{
throw
new
TypeError
(
"
Offset
must
be
a
number
"
)
;
}
return
{
x
:
box
.
left
+
xOffset
y
:
box
.
top
+
yOffset
}
;
}
;
element
.
inViewport
=
function
(
el
x
=
undefined
y
=
undefined
)
{
let
win
=
el
.
ownerDocument
.
defaultView
;
let
c
=
element
.
coordinates
(
el
x
y
)
;
let
vp
=
{
top
:
win
.
pageYOffset
left
:
win
.
pageXOffset
bottom
:
(
win
.
pageYOffset
+
win
.
innerHeight
)
right
:
(
win
.
pageXOffset
+
win
.
innerWidth
)
}
;
return
(
vp
.
left
<
=
c
.
x
+
win
.
pageXOffset
&
&
c
.
x
+
win
.
pageXOffset
<
=
vp
.
right
&
&
vp
.
top
<
=
c
.
y
+
win
.
pageYOffset
&
&
c
.
y
+
win
.
pageYOffset
<
=
vp
.
bottom
)
;
}
;
element
.
isVisible
=
function
(
el
x
=
undefined
y
=
undefined
)
{
let
win
=
el
.
ownerDocument
.
defaultView
;
if
(
!
element
.
isXULElement
(
el
)
&
&
!
atom
.
isElementDisplayed
(
el
win
)
)
{
return
false
;
}
if
(
el
.
tagName
.
toLowerCase
(
)
=
=
"
body
"
)
{
return
true
;
}
if
(
!
element
.
inViewport
(
el
x
y
)
)
{
if
(
el
.
scrollIntoView
)
{
el
.
scrollIntoView
(
{
block
:
"
start
"
inline
:
"
nearest
"
}
)
;
if
(
!
element
.
inViewport
(
el
)
)
{
return
false
;
}
}
else
{
return
false
;
}
}
return
true
;
}
;
element
.
isInteractable
=
function
(
el
)
{
return
element
.
isPointerInteractable
(
el
)
|
|
element
.
isKeyboardInteractable
(
el
)
;
}
;
element
.
isPointerInteractable
=
function
(
el
)
{
let
tree
=
element
.
getInteractableElementTree
(
el
)
;
return
tree
.
length
>
0
;
}
;
element
.
getInteractableElementTree
=
function
(
el
)
{
let
doc
=
el
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
box
=
el
.
getBoundingClientRect
(
)
;
let
visible
=
{
width
:
Math
.
max
(
box
.
x
box
.
x
+
box
.
width
)
-
win
.
innerWidth
height
:
Math
.
max
(
box
.
y
box
.
y
+
box
.
height
)
-
win
.
innerHeight
}
;
let
offset
=
{
vertical
:
visible
.
width
/
2
.
0
horizontal
:
visible
.
height
/
2
.
0
}
;
let
centre
=
{
x
:
box
.
x
+
offset
.
horizontal
y
:
box
.
y
+
offset
.
vertical
}
;
let
tree
=
doc
.
elementsFromPoint
(
centre
.
x
centre
.
y
)
;
let
rv
=
[
]
;
for
(
let
el
of
tree
)
{
if
(
win
.
getComputedStyle
(
el
)
.
opacity
=
=
=
"
1
"
)
{
rv
.
push
(
el
)
;
}
}
return
rv
;
}
;
element
.
isKeyboardInteractable
=
function
(
el
)
{
return
true
;
}
;
element
.
isXULElement
=
function
(
el
)
{
let
ns
=
atom
.
getElementAttribute
(
el
"
namespaceURI
"
)
;
return
ns
.
indexOf
(
"
there
.
is
.
only
.
xul
"
)
>
=
0
;
}
;
const
boolEls
=
{
audio
:
[
"
autoplay
"
"
controls
"
"
loop
"
"
muted
"
]
button
:
[
"
autofocus
"
"
disabled
"
"
formnovalidate
"
]
details
:
[
"
open
"
]
dialog
:
[
"
open
"
]
fieldset
:
[
"
disabled
"
]
form
:
[
"
novalidate
"
]
iframe
:
[
"
allowfullscreen
"
]
img
:
[
"
ismap
"
]
input
:
[
"
autofocus
"
"
checked
"
"
disabled
"
"
formnovalidate
"
"
multiple
"
"
readonly
"
"
required
"
]
keygen
:
[
"
autofocus
"
"
disabled
"
]
menuitem
:
[
"
checked
"
"
default
"
"
disabled
"
]
object
:
[
"
typemustmatch
"
]
ol
:
[
"
reversed
"
]
optgroup
:
[
"
disabled
"
]
option
:
[
"
disabled
"
"
selected
"
]
script
:
[
"
async
"
"
defer
"
]
select
:
[
"
autofocus
"
"
disabled
"
"
multiple
"
"
required
"
]
textarea
:
[
"
autofocus
"
"
disabled
"
"
readonly
"
"
required
"
]
track
:
[
"
default
"
]
video
:
[
"
autoplay
"
"
controls
"
"
loop
"
"
muted
"
]
}
;
element
.
isBooleanAttribute
=
function
(
el
attr
)
{
if
(
el
.
namespaceURI
!
=
=
XMLNS
)
{
return
false
;
}
if
(
(
attr
=
=
"
hidden
"
|
|
attr
=
=
"
itemscope
"
)
&
&
!
el
.
localName
.
includes
(
"
-
"
)
)
{
return
true
;
}
if
(
!
boolEls
.
hasOwnProperty
(
el
.
localName
)
)
{
return
false
;
}
return
boolEls
[
el
.
localName
]
.
includes
(
attr
)
}
;
