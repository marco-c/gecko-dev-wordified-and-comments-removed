"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
atom
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
element
"
"
ElementManager
"
"
CLASS_NAME
"
"
SELECTOR
"
"
ID
"
"
NAME
"
"
LINK_TEXT
"
"
PARTIAL_LINK_TEXT
"
"
TAG
"
"
XPATH
"
"
ANON
"
"
ANON_ATTRIBUTE
"
]
;
const
DOCUMENT_POSITION_DISCONNECTED
=
1
;
const
uuidGen
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
this
.
CLASS_NAME
=
"
class
name
"
;
this
.
SELECTOR
=
"
css
selector
"
;
this
.
ID
=
"
id
"
;
this
.
NAME
=
"
name
"
;
this
.
LINK_TEXT
=
"
link
text
"
;
this
.
PARTIAL_LINK_TEXT
=
"
partial
link
text
"
;
this
.
TAG
=
"
tag
name
"
;
this
.
XPATH
=
"
xpath
"
;
this
.
ANON
=
"
anon
"
;
this
.
ANON_ATTRIBUTE
=
"
anon
attribute
"
;
this
.
ElementManager
=
function
ElementManager
(
notSupported
)
{
this
.
seenItems
=
{
}
;
this
.
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
elementStrategies
=
[
CLASS_NAME
SELECTOR
ID
NAME
LINK_TEXT
PARTIAL_LINK_TEXT
TAG
XPATH
ANON
ANON_ATTRIBUTE
]
;
for
(
let
i
=
0
;
i
<
notSupported
.
length
;
i
+
+
)
{
this
.
elementStrategies
.
splice
(
this
.
elementStrategies
.
indexOf
(
notSupported
[
i
]
)
1
)
;
}
}
ElementManager
.
prototype
=
{
reset
:
function
EM_clear
(
)
{
this
.
seenItems
=
{
}
;
}
addToKnownElements
:
function
EM_addToKnownElements
(
el
)
{
for
(
let
i
in
this
.
seenItems
)
{
let
foundEl
=
null
;
try
{
foundEl
=
this
.
seenItems
[
i
]
.
get
(
)
;
}
catch
(
e
)
{
}
if
(
foundEl
)
{
if
(
XPCNativeWrapper
(
foundEl
)
=
=
XPCNativeWrapper
(
el
)
)
{
return
i
;
}
}
else
{
delete
this
.
seenItems
[
i
]
;
}
}
let
id
=
element
.
generateUUID
(
)
;
this
.
seenItems
[
id
]
=
Cu
.
getWeakReference
(
el
)
;
return
id
;
}
getKnownElement
:
function
EM_getKnownElement
(
id
container
)
{
let
el
=
this
.
seenItems
[
id
]
;
if
(
!
el
)
{
throw
new
JavaScriptError
(
Element
has
not
been
seen
before
.
Id
given
was
{
id
}
)
;
}
try
{
el
=
el
.
get
(
)
;
}
catch
(
e
)
{
el
=
null
;
delete
this
.
seenItems
[
id
]
;
}
let
wrappedFrame
=
XPCNativeWrapper
(
container
.
frame
)
;
let
wrappedShadowRoot
;
if
(
container
.
shadowRoot
)
{
wrappedShadowRoot
=
XPCNativeWrapper
(
container
.
shadowRoot
)
;
}
if
(
!
el
|
|
!
(
XPCNativeWrapper
(
el
)
.
ownerDocument
=
=
wrappedFrame
.
document
)
|
|
this
.
isDisconnected
(
XPCNativeWrapper
(
el
)
wrappedShadowRoot
wrappedFrame
)
)
{
throw
new
StaleElementReferenceError
(
"
The
element
reference
is
stale
.
Either
the
element
"
+
"
is
no
longer
attached
to
the
DOM
or
the
page
has
been
refreshed
.
"
)
;
}
return
el
;
}
isDisconnected
:
function
EM_isDisconnected
(
el
shadowRoot
frame
)
{
if
(
shadowRoot
&
&
frame
.
ShadowRoot
)
{
if
(
el
.
compareDocumentPosition
(
shadowRoot
)
&
DOCUMENT_POSITION_DISCONNECTED
)
{
return
true
;
}
let
parent
=
shadowRoot
.
host
;
while
(
parent
&
&
!
(
parent
instanceof
frame
.
ShadowRoot
)
)
{
parent
=
parent
.
parentNode
;
}
return
this
.
isDisconnected
(
shadowRoot
.
host
parent
frame
)
;
}
else
{
return
el
.
compareDocumentPosition
(
frame
.
document
.
documentElement
)
&
DOCUMENT_POSITION_DISCONNECTED
;
}
}
wrapValue
:
function
EM_wrapValue
(
val
)
{
let
result
=
null
;
switch
(
typeof
(
val
)
)
{
case
"
undefined
"
:
result
=
null
;
break
;
case
"
string
"
:
case
"
number
"
:
case
"
boolean
"
:
result
=
val
;
break
;
case
"
object
"
:
let
type
=
Object
.
prototype
.
toString
.
call
(
val
)
;
if
(
type
=
=
"
[
object
Array
]
"
|
|
type
=
=
"
[
object
NodeList
]
"
)
{
result
=
[
]
;
for
(
let
i
=
0
;
i
<
val
.
length
;
+
+
i
)
{
result
.
push
(
this
.
wrapValue
(
val
[
i
]
)
)
;
}
}
else
if
(
val
=
=
null
)
{
result
=
null
;
}
else
if
(
val
.
nodeType
=
=
1
)
{
let
elementId
=
this
.
addToKnownElements
(
val
)
;
result
=
{
[
element
.
LegacyKey
]
:
elementId
[
element
.
Key
]
:
elementId
}
;
}
else
{
result
=
{
}
;
for
(
let
prop
in
val
)
{
result
[
prop
]
=
this
.
wrapValue
(
val
[
prop
]
)
;
}
}
break
;
}
return
result
;
}
convertWrappedArguments
:
function
EM_convertWrappedArguments
(
args
container
)
{
let
converted
;
switch
(
typeof
(
args
)
)
{
case
'
number
'
:
case
'
string
'
:
case
'
boolean
'
:
converted
=
args
;
break
;
case
'
object
'
:
if
(
args
=
=
null
)
{
converted
=
null
;
}
else
if
(
Object
.
prototype
.
toString
.
call
(
args
)
=
=
'
[
object
Array
]
'
)
{
converted
=
[
]
;
for
(
let
i
in
args
)
{
converted
.
push
(
this
.
convertWrappedArguments
(
args
[
i
]
container
)
)
;
}
}
else
if
(
(
(
typeof
(
args
[
element
.
LegacyKey
]
)
=
=
=
'
string
'
)
&
&
args
.
hasOwnProperty
(
element
.
LegacyKey
)
)
|
|
(
(
typeof
(
args
[
element
.
Key
]
)
=
=
=
'
string
'
)
&
&
args
.
hasOwnProperty
(
element
.
Key
)
)
)
{
let
elementUniqueIdentifier
=
args
[
element
.
Key
]
?
args
[
element
.
Key
]
:
args
[
element
.
LegacyKey
]
;
converted
=
this
.
getKnownElement
(
elementUniqueIdentifier
container
)
;
if
(
converted
=
=
null
)
{
throw
new
WebDriverError
(
Unknown
element
:
{
elementUniqueIdentifier
}
)
;
}
}
else
{
converted
=
{
}
;
for
(
let
prop
in
args
)
{
converted
[
prop
]
=
this
.
convertWrappedArguments
(
args
[
prop
]
container
)
;
}
}
break
;
}
return
converted
;
}
applyNamedArgs
:
function
EM_applyNamedArgs
(
args
)
{
let
namedArgs
=
{
}
;
args
.
forEach
(
function
(
arg
)
{
if
(
arg
&
&
typeof
(
arg
[
'
__marionetteArgs
'
]
)
=
=
=
'
object
'
)
{
for
(
let
prop
in
arg
[
'
__marionetteArgs
'
]
)
{
namedArgs
[
prop
]
=
arg
[
'
__marionetteArgs
'
]
[
prop
]
;
}
}
}
)
;
return
namedArgs
;
}
find
:
function
(
container
strategy
selector
opts
=
{
}
)
{
opts
.
all
=
!
!
opts
.
all
;
opts
.
timeout
=
opts
.
timeout
|
|
0
;
let
searchFn
;
if
(
opts
.
all
)
{
searchFn
=
this
.
findElements
.
bind
(
this
)
;
}
else
{
searchFn
=
this
.
findElement
.
bind
(
this
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
findElements
=
implicitlyWaitFor
(
(
)
=
>
this
.
find_
(
container
strategy
selector
searchFn
opts
)
opts
.
timeout
)
;
findElements
.
then
(
foundEls
=
>
{
if
(
foundEls
.
length
=
=
0
&
&
!
opts
.
all
)
{
let
msg
;
switch
(
strategy
)
{
case
ANON
:
msg
=
"
Unable
to
locate
anonymous
children
"
;
break
;
case
ANON_ATTRIBUTE
:
msg
=
"
Unable
to
locate
anonymous
element
:
"
+
JSON
.
stringify
(
selector
)
;
break
;
default
:
msg
=
"
Unable
to
locate
element
:
"
+
selector
;
}
reject
(
new
NoSuchElementError
(
msg
)
)
;
}
let
rv
=
[
]
;
for
(
let
el
of
foundEls
)
{
let
ref
=
this
.
addToKnownElements
(
el
)
;
let
we
=
element
.
makeWebElement
(
ref
)
;
rv
.
push
(
we
)
;
}
if
(
opts
.
all
)
{
resolve
(
rv
)
;
}
resolve
(
rv
[
0
]
)
;
}
reject
)
;
}
)
;
}
find_
:
function
(
container
strategy
selector
searchFn
opts
)
{
let
rootNode
=
container
.
shadowRoot
|
|
container
.
frame
.
document
;
let
startNode
;
if
(
opts
.
startNode
)
{
startNode
=
this
.
getKnownElement
(
opts
.
startNode
container
)
;
}
else
{
startNode
=
rootNode
;
}
if
(
strategy
in
element
.
Strategies
)
{
throw
new
InvalidSelectorError
(
"
No
such
strategy
:
"
+
strategy
)
;
}
let
res
;
try
{
res
=
searchFn
(
strategy
selector
rootNode
startNode
)
;
}
catch
(
e
)
{
throw
new
InvalidSelectorError
(
Given
{
strategy
}
expression
"
{
selector
}
"
is
invalid
)
;
}
if
(
element
.
isElementCollection
(
res
)
)
{
return
res
;
}
else
if
(
res
!
=
=
null
)
{
return
[
res
]
;
}
return
[
]
;
}
findByXPath
:
function
EM_findByXPath
(
root
value
node
)
{
return
root
.
evaluate
(
value
node
null
Ci
.
nsIDOMXPathResult
.
FIRST_ORDERED_NODE_TYPE
null
)
.
singleNodeValue
;
}
findByXPathAll
:
function
EM_findByXPathAll
(
root
value
node
)
{
let
values
=
root
.
evaluate
(
value
node
null
Ci
.
nsIDOMXPathResult
.
ORDERED_NODE_ITERATOR_TYPE
null
)
;
let
elements
=
[
]
;
let
element
=
values
.
iterateNext
(
)
;
while
(
element
)
{
elements
.
push
(
element
)
;
element
=
values
.
iterateNext
(
)
;
}
return
elements
;
}
findElement
:
function
EM_findElement
(
using
value
rootNode
startNode
)
{
let
element
;
switch
(
using
)
{
case
ID
:
element
=
startNode
.
getElementById
?
startNode
.
getElementById
(
value
)
:
this
.
findByXPath
(
rootNode
.
/
/
*
[
id
=
"
{
value
}
"
]
startNode
)
;
break
;
case
NAME
:
element
=
startNode
.
getElementsByName
?
startNode
.
getElementsByName
(
value
)
[
0
]
:
this
.
findByXPath
(
rootNode
.
/
/
*
[
name
=
"
{
value
}
"
]
startNode
)
;
break
;
case
CLASS_NAME
:
element
=
startNode
.
getElementsByClassName
(
value
)
[
0
]
;
break
;
case
TAG
:
element
=
startNode
.
getElementsByTagName
(
value
)
[
0
]
;
break
;
case
XPATH
:
element
=
this
.
findByXPath
(
rootNode
value
startNode
)
;
break
;
case
LINK_TEXT
:
case
PARTIAL_LINK_TEXT
:
let
allLinks
=
startNode
.
getElementsByTagName
(
'
A
'
)
;
for
(
let
i
=
0
;
i
<
allLinks
.
length
&
&
!
element
;
i
+
+
)
{
let
text
=
allLinks
[
i
]
.
text
;
if
(
PARTIAL_LINK_TEXT
=
=
using
)
{
if
(
text
.
indexOf
(
value
)
!
=
-
1
)
{
element
=
allLinks
[
i
]
;
}
}
else
if
(
text
=
=
value
)
{
element
=
allLinks
[
i
]
;
}
}
break
;
case
SELECTOR
:
try
{
element
=
startNode
.
querySelector
(
value
)
;
}
catch
(
e
)
{
throw
new
InvalidSelectorError
(
{
e
.
message
}
:
"
{
value
}
"
)
;
}
break
;
case
ANON
:
element
=
rootNode
.
getAnonymousNodes
(
startNode
)
;
if
(
element
!
=
null
)
{
element
=
element
[
0
]
;
}
break
;
case
ANON_ATTRIBUTE
:
let
attr
=
Object
.
keys
(
value
)
[
0
]
;
element
=
rootNode
.
getAnonymousElementByAttribute
(
startNode
attr
value
[
attr
]
)
;
break
;
default
:
throw
new
InvalidSelectorError
(
No
such
strategy
:
{
using
}
)
;
}
return
element
;
}
findElements
:
function
EM_findElements
(
using
value
rootNode
startNode
)
{
let
elements
=
[
]
;
switch
(
using
)
{
case
ID
:
value
=
.
/
/
*
[
id
=
"
{
value
}
"
]
;
case
XPATH
:
elements
=
this
.
findByXPathAll
(
rootNode
value
startNode
)
;
break
;
case
NAME
:
elements
=
startNode
.
getElementsByName
?
startNode
.
getElementsByName
(
value
)
:
this
.
findByXPathAll
(
rootNode
.
/
/
*
[
name
=
"
{
value
}
"
]
startNode
)
;
break
;
case
CLASS_NAME
:
elements
=
startNode
.
getElementsByClassName
(
value
)
;
break
;
case
TAG
:
elements
=
startNode
.
getElementsByTagName
(
value
)
;
break
;
case
LINK_TEXT
:
case
PARTIAL_LINK_TEXT
:
let
allLinks
=
startNode
.
getElementsByTagName
(
'
A
'
)
;
for
(
let
i
=
0
;
i
<
allLinks
.
length
;
i
+
+
)
{
let
text
=
allLinks
[
i
]
.
text
;
if
(
PARTIAL_LINK_TEXT
=
=
using
)
{
if
(
text
.
indexOf
(
value
)
!
=
-
1
)
{
elements
.
push
(
allLinks
[
i
]
)
;
}
}
else
if
(
text
=
=
value
)
{
elements
.
push
(
allLinks
[
i
]
)
;
}
}
break
;
case
SELECTOR
:
elements
=
Array
.
slice
(
startNode
.
querySelectorAll
(
value
)
)
;
break
;
case
ANON
:
elements
=
rootNode
.
getAnonymousNodes
(
startNode
)
|
|
[
]
;
break
;
case
ANON_ATTRIBUTE
:
let
attr
=
Object
.
keys
(
value
)
[
0
]
;
let
el
=
rootNode
.
getAnonymousElementByAttribute
(
startNode
attr
value
[
attr
]
)
;
if
(
el
!
=
null
)
{
elements
=
[
el
]
;
}
break
;
default
:
throw
new
InvalidSelectorError
(
No
such
strategy
:
{
using
}
)
;
}
return
elements
;
}
}
;
function
implicitlyWaitFor
(
func
timeout
interval
=
100
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
startTime
=
new
Date
(
)
.
getTime
(
)
;
let
endTime
=
startTime
+
timeout
;
let
observer
=
function
(
)
{
let
res
;
try
{
res
=
func
(
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
let
col
=
element
.
isElementCollection
(
res
)
;
if
(
(
(
col
&
&
res
.
length
>
0
)
|
|
(
!
col
&
&
!
!
res
)
)
|
|
(
startTime
=
=
endTime
|
|
new
Date
(
)
.
getTime
(
)
>
=
endTime
)
)
{
resolve
(
res
)
;
}
}
;
timer
.
init
(
observer
interval
Ci
.
nsITimer
.
TYPE_REPEATING_SLACK
)
;
}
)
.
then
(
res
=
>
{
timer
.
cancel
(
)
;
return
res
;
}
)
;
}
;
this
.
element
=
{
}
;
element
.
LegacyKey
=
"
ELEMENT
"
;
element
.
Key
=
"
element
-
6066
-
11e4
-
a52e
-
4f735466cecf
"
;
element
.
Strategies
=
{
CLASS_NAME
:
0
SELECTOR
:
1
ID
:
2
NAME
:
3
LINK_TEXT
:
4
PARTIAL_LINK_TEXT
:
5
TAG
:
6
XPATH
:
7
ANON
:
8
ANON_ATTRIBUTE
:
9
}
;
element
.
isElementCollection
=
function
(
seq
)
{
if
(
seq
=
=
=
null
)
{
return
false
;
}
const
arrayLike
=
{
"
[
object
Array
]
"
:
0
"
[
object
HTMLCollection
]
"
:
1
"
[
object
NodeList
]
"
:
2
}
;
let
typ
=
Object
.
prototype
.
toString
.
call
(
seq
)
;
return
typ
in
arrayLike
;
}
;
element
.
makeWebElement
=
function
(
uuid
)
{
return
{
[
element
.
Key
]
:
uuid
[
element
.
LegacyKey
]
:
uuid
}
;
}
;
element
.
generateUUID
=
function
(
)
{
let
uuid
=
uuidGen
.
generateUUID
(
)
.
toString
(
)
;
return
uuid
.
substring
(
1
uuid
.
length
-
1
)
;
}
;
element
.
coordinates
=
function
(
node
x
=
undefined
y
=
undefined
)
{
let
box
=
node
.
getBoundingClientRect
(
)
;
if
(
!
x
)
{
x
=
box
.
width
/
2
.
0
;
}
if
(
!
y
)
{
y
=
box
.
height
/
2
.
0
;
}
return
{
x
:
box
.
left
+
x
y
:
box
.
top
+
y
}
;
}
;
element
.
inViewport
=
function
(
el
x
=
undefined
y
=
undefined
)
{
let
win
=
el
.
ownerDocument
.
defaultView
;
let
c
=
element
.
coordinates
(
el
x
y
)
;
let
vp
=
{
top
:
win
.
pageYOffset
left
:
win
.
pageXOffset
bottom
:
(
win
.
pageYOffset
+
win
.
innerHeight
)
right
:
(
win
.
pageXOffset
+
win
.
innerWidth
)
}
;
return
(
vp
.
left
<
=
c
.
x
+
win
.
pageXOffset
&
&
c
.
x
+
win
.
pageXOffset
<
=
vp
.
right
&
&
vp
.
top
<
=
c
.
y
+
win
.
pageYOffset
&
&
c
.
y
+
win
.
pageYOffset
<
=
vp
.
bottom
)
;
}
;
element
.
isVisible
=
function
(
el
x
=
undefined
y
=
undefined
)
{
let
win
=
el
.
ownerDocument
.
defaultView
;
let
ns
=
atom
.
getElementAttribute
(
el
"
namespaceURI
"
win
)
;
if
(
ns
.
indexOf
(
"
there
.
is
.
only
.
xul
"
)
<
0
&
&
!
atom
.
isElementDisplayed
(
el
win
)
)
{
return
false
;
}
if
(
el
.
tagName
.
toLowerCase
(
)
=
=
"
body
"
)
{
return
true
;
}
if
(
!
element
.
inViewport
(
el
x
y
)
)
{
if
(
el
.
scrollIntoView
)
{
el
.
scrollIntoView
(
false
)
;
if
(
!
element
.
inViewport
(
el
)
)
{
return
false
;
}
}
else
{
return
false
;
}
}
return
true
;
}
;
element
.
isXULElement
=
function
(
el
)
{
let
ns
=
atom
.
getElementAttribute
(
el
"
namespaceURI
"
)
;
return
ns
.
indexOf
(
"
there
.
is
.
only
.
xul
"
)
>
=
0
;
}
;
