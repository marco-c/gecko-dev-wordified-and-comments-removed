"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
atom
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
element
"
]
;
const
DOCUMENT_POSITION_DISCONNECTED
=
1
;
const
XMLNS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
uuidGen
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
this
.
element
=
{
}
;
element
.
Key
=
"
element
-
6066
-
11e4
-
a52e
-
4f735466cecf
"
;
element
.
LegacyKey
=
"
ELEMENT
"
;
element
.
Strategy
=
{
ClassName
:
"
class
name
"
Selector
:
"
css
selector
"
ID
:
"
id
"
Name
:
"
name
"
LinkText
:
"
link
text
"
PartialLinkText
:
"
partial
link
text
"
TagName
:
"
tag
name
"
XPath
:
"
xpath
"
Anon
:
"
anon
"
AnonAttribute
:
"
anon
attribute
"
}
;
element
.
Store
=
class
{
constructor
(
)
{
this
.
els
=
{
}
;
this
.
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
clear
(
)
{
this
.
els
=
{
}
;
}
addAll
(
els
)
{
let
add
=
this
.
add
.
bind
(
this
)
;
return
[
.
.
.
els
]
.
map
(
add
)
;
}
add
(
el
)
{
for
(
let
i
in
this
.
els
)
{
let
foundEl
;
try
{
foundEl
=
this
.
els
[
i
]
.
get
(
)
;
}
catch
(
e
)
{
}
if
(
foundEl
)
{
if
(
new
XPCNativeWrapper
(
foundEl
)
=
=
new
XPCNativeWrapper
(
el
)
)
{
return
i
;
}
}
else
{
delete
this
.
els
[
i
]
;
}
}
let
id
=
element
.
generateUUID
(
)
;
this
.
els
[
id
]
=
Cu
.
getWeakReference
(
el
)
;
return
id
;
}
has
(
uuid
)
{
return
Object
.
keys
(
this
.
els
)
.
includes
(
uuid
)
;
}
get
(
uuid
container
)
{
let
el
=
this
.
els
[
uuid
]
;
if
(
!
el
)
{
throw
new
JavaScriptError
(
Element
reference
not
seen
before
:
{
uuid
}
)
;
}
try
{
el
=
el
.
get
(
)
;
}
catch
(
e
)
{
el
=
null
;
delete
this
.
els
[
id
]
;
}
let
wrappedFrame
=
new
XPCNativeWrapper
(
container
.
frame
)
;
let
wrappedShadowRoot
;
if
(
container
.
shadowRoot
)
{
wrappedShadowRoot
=
new
XPCNativeWrapper
(
container
.
shadowRoot
)
;
}
let
wrappedEl
=
new
XPCNativeWrapper
(
el
)
;
if
(
!
el
|
|
!
(
wrappedEl
.
ownerDocument
=
=
wrappedFrame
.
document
)
|
|
element
.
isDisconnected
(
wrappedEl
wrappedFrame
wrappedShadowRoot
)
)
{
throw
new
StaleElementReferenceError
(
"
The
element
reference
is
stale
.
Either
the
element
"
+
"
is
no
longer
attached
to
the
DOM
or
the
page
has
been
refreshed
.
"
)
;
}
return
el
;
}
}
;
element
.
find
=
function
(
container
strategy
selector
opts
=
{
}
)
{
opts
.
all
=
!
!
opts
.
all
;
opts
.
timeout
=
opts
.
timeout
|
|
0
;
let
searchFn
;
if
(
opts
.
all
)
{
searchFn
=
findElements
.
bind
(
this
)
;
}
else
{
searchFn
=
findElement
.
bind
(
this
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
findElements
=
implicitlyWaitFor
(
(
)
=
>
find_
(
container
strategy
selector
searchFn
opts
)
opts
.
timeout
)
;
findElements
.
then
(
foundEls
=
>
{
if
(
!
opts
.
all
&
&
(
!
foundEls
|
|
foundEls
.
length
=
=
0
)
)
{
let
msg
;
switch
(
strategy
)
{
case
element
.
Strategy
.
AnonAttribute
:
msg
=
"
Unable
to
locate
anonymous
element
:
"
+
JSON
.
stringify
(
selector
)
;
break
;
default
:
msg
=
"
Unable
to
locate
element
:
"
+
selector
;
}
reject
(
new
NoSuchElementError
(
msg
)
)
;
}
if
(
opts
.
all
)
{
resolve
(
foundEls
)
;
}
resolve
(
foundEls
[
0
]
)
;
}
reject
)
;
}
)
;
}
;
function
find_
(
container
strategy
selector
searchFn
opts
)
{
let
rootNode
=
container
.
shadowRoot
|
|
container
.
frame
.
document
;
let
startNode
=
opts
.
startNode
|
|
rootNode
;
let
res
;
try
{
res
=
searchFn
(
strategy
selector
rootNode
startNode
)
;
}
catch
(
e
)
{
throw
new
InvalidSelectorError
(
Given
{
strategy
}
expression
"
{
selector
}
"
is
invalid
:
{
e
}
)
;
}
if
(
res
)
{
if
(
opts
.
all
)
{
return
res
;
}
return
[
res
]
;
}
return
[
]
;
}
element
.
findByXPath
=
function
(
root
startNode
expr
)
{
let
iter
=
root
.
evaluate
(
expr
startNode
null
Ci
.
nsIDOMXPathResult
.
FIRST_ORDERED_NODE_TYPE
null
)
return
iter
.
singleNodeValue
;
}
;
element
.
findByXPathAll
=
function
(
root
startNode
expr
)
{
let
rv
=
[
]
;
let
iter
=
root
.
evaluate
(
expr
startNode
null
Ci
.
nsIDOMXPathResult
.
ORDERED_NODE_ITERATOR_TYPE
null
)
;
let
el
=
iter
.
iterateNext
(
)
;
while
(
el
)
{
rv
.
push
(
el
)
;
el
=
iter
.
iterateNext
(
)
;
}
return
rv
;
}
;
element
.
findByLinkText
=
function
(
node
s
)
{
return
filterLinks
(
node
link
=
>
link
.
text
.
trim
(
)
=
=
=
s
)
;
}
;
element
.
findByPartialLinkText
=
function
(
node
s
)
{
return
filterLinks
(
node
link
=
>
link
.
text
.
indexOf
(
s
)
!
=
-
1
)
;
}
;
function
filterLinks
(
node
predicate
)
{
let
rv
=
[
]
;
for
(
let
link
of
node
.
getElementsByTagName
(
"
a
"
)
)
{
if
(
predicate
(
link
)
)
{
rv
.
push
(
link
)
;
}
}
return
rv
;
}
function
findElement
(
using
value
rootNode
startNode
)
{
switch
(
using
)
{
case
element
.
Strategy
.
ID
:
if
(
startNode
.
getElementById
)
{
return
startNode
.
getElementById
(
value
)
;
}
return
element
.
findByXPath
(
rootNode
startNode
.
/
/
*
[
id
=
"
{
value
}
"
]
)
;
case
element
.
Strategy
.
Name
:
if
(
startNode
.
getElementsByName
)
{
return
startNode
.
getElementsByName
(
value
)
[
0
]
;
}
return
element
.
findByXPath
(
rootNode
startNode
.
/
/
*
[
name
=
"
{
value
}
"
]
)
;
case
element
.
Strategy
.
ClassName
:
return
startNode
.
getElementsByClassName
(
value
)
[
0
]
;
case
element
.
Strategy
.
TagName
:
return
startNode
.
getElementsByTagName
(
value
)
[
0
]
;
case
element
.
Strategy
.
XPath
:
return
element
.
findByXPath
(
rootNode
startNode
value
)
;
case
element
.
Strategy
.
LinkText
:
for
(
let
link
of
startNode
.
getElementsByTagName
(
"
a
"
)
)
{
if
(
link
.
text
.
trim
(
)
=
=
=
value
)
{
return
link
;
}
}
break
;
case
element
.
Strategy
.
PartialLinkText
:
for
(
let
link
of
startNode
.
getElementsByTagName
(
"
a
"
)
)
{
if
(
link
.
text
.
indexOf
(
value
)
!
=
-
1
)
{
return
link
;
}
}
break
;
case
element
.
Strategy
.
Selector
:
try
{
return
startNode
.
querySelector
(
value
)
;
}
catch
(
e
)
{
throw
new
InvalidSelectorError
(
{
e
.
message
}
:
"
{
value
}
"
)
;
}
case
element
.
Strategy
.
Anon
:
return
rootNode
.
getAnonymousNodes
(
startNode
)
;
case
element
.
Strategy
.
AnonAttribute
:
let
attr
=
Object
.
keys
(
value
)
[
0
]
;
return
rootNode
.
getAnonymousElementByAttribute
(
startNode
attr
value
[
attr
]
)
;
default
:
throw
new
InvalidSelectorError
(
No
such
strategy
:
{
using
}
)
;
}
}
;
function
findElements
(
using
value
rootNode
startNode
)
{
switch
(
using
)
{
case
element
.
Strategy
.
ID
:
value
=
.
/
/
*
[
id
=
"
{
value
}
"
]
;
case
element
.
Strategy
.
XPath
:
return
element
.
findByXPathAll
(
rootNode
startNode
value
)
;
case
element
.
Strategy
.
Name
:
if
(
startNode
.
getElementsByName
)
{
return
startNode
.
getElementsByName
(
value
)
;
}
return
element
.
findByXPathAll
(
rootNode
startNode
.
/
/
*
[
name
=
"
{
value
}
"
]
)
;
case
element
.
Strategy
.
ClassName
:
return
startNode
.
getElementsByClassName
(
value
)
;
case
element
.
Strategy
.
TagName
:
return
startNode
.
getElementsByTagName
(
value
)
;
case
element
.
Strategy
.
LinkText
:
return
element
.
findByLinkText
(
startNode
value
)
;
case
element
.
Strategy
.
PartialLinkText
:
return
element
.
findByPartialLinkText
(
startNode
value
)
;
case
element
.
Strategy
.
Selector
:
return
startNode
.
querySelectorAll
(
value
)
;
case
element
.
Strategy
.
Anon
:
return
rootNode
.
getAnonymousNodes
(
startNode
)
;
case
element
.
Strategy
.
AnonAttribute
:
let
attr
=
Object
.
keys
(
value
)
[
0
]
;
let
el
=
rootNode
.
getAnonymousElementByAttribute
(
startNode
attr
value
[
attr
]
)
;
if
(
el
)
{
return
[
el
]
;
}
return
[
]
;
default
:
throw
new
InvalidSelectorError
(
No
such
strategy
:
{
using
}
)
;
}
}
function
implicitlyWaitFor
(
func
timeout
interval
=
100
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
startTime
=
new
Date
(
)
.
getTime
(
)
;
let
endTime
=
startTime
+
timeout
;
let
elementSearch
=
function
(
)
{
let
res
;
try
{
res
=
func
(
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
if
(
(
element
.
isCollection
(
res
)
&
&
res
.
length
>
0
)
|
|
(
!
element
.
isCollection
(
res
)
&
&
!
!
res
)
|
|
startTime
=
=
endTime
|
|
new
Date
(
)
.
getTime
(
)
>
=
endTime
)
{
resolve
(
res
)
;
}
}
;
elementSearch
(
)
;
timer
.
init
(
elementSearch
interval
Ci
.
nsITimer
.
TYPE_REPEATING_SLACK
)
;
}
)
.
then
(
res
=
>
{
timer
.
cancel
(
)
;
return
res
;
}
err
=
>
{
timer
.
cancel
(
)
;
throw
err
;
}
)
;
}
element
.
isCollection
=
function
(
seq
)
{
switch
(
Object
.
prototype
.
toString
.
call
(
seq
)
)
{
case
"
[
object
Arguments
]
"
:
case
"
[
object
Array
]
"
:
case
"
[
object
FileList
]
"
:
case
"
[
object
HTMLAllCollection
]
"
:
case
"
[
object
HTMLCollection
]
"
:
case
"
[
object
HTMLFormControlsCollection
]
"
:
case
"
[
object
HTMLOptionsCollection
]
"
:
case
"
[
object
NodeList
]
"
:
return
true
;
default
:
return
false
;
}
}
;
element
.
makeWebElement
=
function
(
uuid
)
{
return
{
[
element
.
Key
]
:
uuid
[
element
.
LegacyKey
]
:
uuid
}
;
}
;
element
.
generateUUID
=
function
(
)
{
let
uuid
=
uuidGen
.
generateUUID
(
)
.
toString
(
)
;
return
uuid
.
substring
(
1
uuid
.
length
-
1
)
;
}
;
element
.
fromJson
=
function
(
obj
seenEls
win
shadowRoot
=
undefined
)
{
switch
(
typeof
obj
)
{
case
"
boolean
"
:
case
"
number
"
:
case
"
string
"
:
return
obj
;
case
"
object
"
:
if
(
obj
=
=
=
null
)
{
return
obj
;
}
else
if
(
Array
.
isArray
(
obj
)
)
{
return
obj
.
map
(
e
=
>
element
.
fromJson
(
e
seenEls
win
shadowRoot
)
)
;
}
else
if
(
Object
.
keys
(
obj
)
.
includes
(
element
.
Key
)
|
|
Object
.
keys
(
obj
)
.
includes
(
element
.
LegacyKey
)
)
{
let
uuid
=
obj
[
element
.
Key
]
|
|
obj
[
element
.
LegacyKey
]
;
let
el
=
seenEls
.
get
(
uuid
{
frame
:
win
shadowRoot
:
shadowRoot
}
)
;
if
(
!
el
)
{
throw
new
WebDriverError
(
Unknown
element
:
{
uuid
}
)
;
}
return
el
;
}
else
{
let
rv
=
{
}
;
for
(
let
prop
in
obj
)
{
rv
[
prop
]
=
element
.
fromJson
(
obj
[
prop
]
seenEls
win
shadowRoot
)
;
}
return
rv
;
}
}
}
;
element
.
toJson
=
function
(
obj
seenEls
)
{
let
t
=
Object
.
prototype
.
toString
.
call
(
obj
)
;
if
(
t
=
=
"
[
object
Undefined
]
"
|
|
t
=
=
"
[
object
Null
]
"
)
{
return
null
;
}
else
if
(
t
=
=
"
[
object
Boolean
]
"
|
|
t
=
=
"
[
object
Number
]
"
|
|
t
=
=
"
[
object
String
]
"
)
{
return
obj
;
}
else
if
(
element
.
isCollection
(
obj
)
)
{
return
[
.
.
.
obj
]
.
map
(
el
=
>
element
.
toJson
(
el
seenEls
)
)
;
}
else
if
(
"
nodeType
"
in
obj
&
&
obj
.
nodeType
=
=
1
)
{
let
uuid
=
seenEls
.
add
(
obj
)
;
return
{
[
element
.
Key
]
:
uuid
[
element
.
LegacyKey
]
:
uuid
}
;
}
else
{
let
rv
=
{
}
;
for
(
let
prop
in
obj
)
{
try
{
rv
[
prop
]
=
element
.
toJson
(
obj
[
prop
]
seenEls
)
;
}
catch
(
e
if
(
e
.
result
=
=
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
)
{
logger
.
debug
(
Skipping
{
prop
}
:
{
e
.
message
}
)
;
}
}
return
rv
;
}
}
;
element
.
isDisconnected
=
function
(
el
frame
shadowRoot
=
undefined
)
{
if
(
shadowRoot
&
&
frame
.
ShadowRoot
)
{
if
(
el
.
compareDocumentPosition
(
shadowRoot
)
&
DOCUMENT_POSITION_DISCONNECTED
)
{
return
true
;
}
let
parent
=
shadowRoot
.
host
;
while
(
parent
&
&
!
(
parent
instanceof
frame
.
ShadowRoot
)
)
{
parent
=
parent
.
parentNode
;
}
return
element
.
isDisconnected
(
shadowRoot
.
host
frame
parent
)
;
}
else
{
let
docEl
=
frame
.
document
.
documentElement
;
return
el
.
compareDocumentPosition
(
docEl
)
&
DOCUMENT_POSITION_DISCONNECTED
;
}
}
;
element
.
coordinates
=
function
(
node
xOffset
=
undefined
yOffset
=
undefined
)
{
let
box
=
node
.
getBoundingClientRect
(
)
;
if
(
typeof
xOffset
=
=
"
undefined
"
|
|
xOffset
=
=
=
null
)
{
xOffset
=
box
.
width
/
2
.
0
;
}
if
(
typeof
yOffset
=
=
"
undefined
"
|
|
yOffset
=
=
=
null
)
{
yOffset
=
box
.
height
/
2
.
0
;
}
if
(
typeof
yOffset
!
=
"
number
"
|
|
typeof
xOffset
!
=
"
number
"
)
{
throw
new
TypeError
(
"
Offset
must
be
a
number
"
)
;
}
return
{
x
:
box
.
left
+
xOffset
y
:
box
.
top
+
yOffset
}
;
}
;
element
.
inViewport
=
function
(
el
x
=
undefined
y
=
undefined
)
{
let
win
=
el
.
ownerDocument
.
defaultView
;
let
c
=
element
.
coordinates
(
el
x
y
)
;
let
vp
=
{
top
:
win
.
pageYOffset
left
:
win
.
pageXOffset
bottom
:
(
win
.
pageYOffset
+
win
.
innerHeight
)
right
:
(
win
.
pageXOffset
+
win
.
innerWidth
)
}
;
return
(
vp
.
left
<
=
c
.
x
+
win
.
pageXOffset
&
&
c
.
x
+
win
.
pageXOffset
<
=
vp
.
right
&
&
vp
.
top
<
=
c
.
y
+
win
.
pageYOffset
&
&
c
.
y
+
win
.
pageYOffset
<
=
vp
.
bottom
)
;
}
;
element
.
isVisible
=
function
(
el
x
=
undefined
y
=
undefined
)
{
let
win
=
el
.
ownerDocument
.
defaultView
;
if
(
!
element
.
isXULElement
(
el
)
&
&
!
atom
.
isElementDisplayed
(
el
win
)
)
{
return
false
;
}
if
(
el
.
tagName
.
toLowerCase
(
)
=
=
"
body
"
)
{
return
true
;
}
if
(
!
element
.
inViewport
(
el
x
y
)
)
{
if
(
el
.
scrollIntoView
)
{
el
.
scrollIntoView
(
{
block
:
"
start
"
inline
:
"
nearest
"
}
)
;
if
(
!
element
.
inViewport
(
el
)
)
{
return
false
;
}
}
else
{
return
false
;
}
}
return
true
;
}
;
element
.
isInteractable
=
function
(
el
)
{
return
element
.
isPointerInteractable
(
el
)
|
|
element
.
isKeyboardInteractable
(
el
)
;
}
;
element
.
isPointerInteractable
=
function
(
el
)
{
let
tree
=
element
.
getInteractableElementTree
(
el
)
;
return
tree
.
length
>
0
;
}
;
element
.
getInteractableElementTree
=
function
(
el
)
{
let
doc
=
el
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
box
=
el
.
getBoundingClientRect
(
)
;
let
visible
=
{
width
:
Math
.
max
(
box
.
x
box
.
x
+
box
.
width
)
-
win
.
innerWidth
height
:
Math
.
max
(
box
.
y
box
.
y
+
box
.
height
)
-
win
.
innerHeight
}
;
let
offset
=
{
vertical
:
visible
.
width
/
2
.
0
horizontal
:
visible
.
height
/
2
.
0
}
;
let
centre
=
{
x
:
box
.
x
+
offset
.
horizontal
y
:
box
.
y
+
offset
.
vertical
}
;
let
tree
=
doc
.
elementsFromPoint
(
centre
.
x
centre
.
y
)
;
let
rv
=
[
]
;
for
(
let
el
of
tree
)
{
if
(
win
.
getComputedStyle
(
el
)
.
opacity
=
=
=
"
1
"
)
{
rv
.
push
(
el
)
;
}
}
return
rv
;
}
;
element
.
isKeyboardInteractable
=
function
(
el
)
{
return
true
;
}
;
element
.
isXULElement
=
function
(
el
)
{
let
ns
=
atom
.
getElementAttribute
(
el
"
namespaceURI
"
)
;
return
ns
.
indexOf
(
"
there
.
is
.
only
.
xul
"
)
>
=
0
;
}
;
const
boolEls
=
{
audio
:
[
"
autoplay
"
"
controls
"
"
loop
"
"
muted
"
]
button
:
[
"
autofocus
"
"
disabled
"
"
formnovalidate
"
]
details
:
[
"
open
"
]
dialog
:
[
"
open
"
]
fieldset
:
[
"
disabled
"
]
form
:
[
"
novalidate
"
]
iframe
:
[
"
allowfullscreen
"
]
img
:
[
"
ismap
"
]
input
:
[
"
autofocus
"
"
checked
"
"
disabled
"
"
formnovalidate
"
"
multiple
"
"
readonly
"
"
required
"
]
keygen
:
[
"
autofocus
"
"
disabled
"
]
menuitem
:
[
"
checked
"
"
default
"
"
disabled
"
]
object
:
[
"
typemustmatch
"
]
ol
:
[
"
reversed
"
]
optgroup
:
[
"
disabled
"
]
option
:
[
"
disabled
"
"
selected
"
]
script
:
[
"
async
"
"
defer
"
]
select
:
[
"
autofocus
"
"
disabled
"
"
multiple
"
"
required
"
]
textarea
:
[
"
autofocus
"
"
disabled
"
"
readonly
"
"
required
"
]
track
:
[
"
default
"
]
video
:
[
"
autoplay
"
"
controls
"
"
loop
"
"
muted
"
]
}
;
element
.
isBooleanAttribute
=
function
(
el
attr
)
{
if
(
el
.
namespaceURI
!
=
=
XMLNS
)
{
return
false
;
}
if
(
(
attr
=
=
"
hidden
"
|
|
attr
=
=
"
itemscope
"
)
&
&
!
el
.
localName
.
includes
(
"
-
"
)
)
{
return
true
;
}
if
(
!
boolEls
.
hasOwnProperty
(
el
.
localName
)
)
{
return
false
;
}
return
boolEls
[
el
.
localName
]
.
includes
(
attr
)
}
;
