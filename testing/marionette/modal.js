"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
modal
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
Log
:
"
chrome
:
/
/
marionette
/
content
/
log
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
)
)
;
const
COMMON_DIALOG
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xhtml
"
;
this
.
modal
=
{
ACTION_CLOSED
:
"
closed
"
ACTION_OPENED
:
"
opened
"
}
;
modal
.
findModalDialogs
=
function
(
context
)
{
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
if
(
win
.
document
.
documentURI
=
=
=
COMMON_DIALOG
&
&
win
.
opener
&
&
win
.
opener
=
=
=
context
.
window
)
{
logger
.
trace
(
"
Found
open
window
modal
prompt
"
)
;
return
new
modal
.
Dialog
(
(
)
=
>
context
win
)
;
}
}
const
contentBrowser
=
context
.
contentBrowser
;
if
(
context
.
tabBrowser
?
.
getTabDialogBox
)
{
const
tabDialogBox
=
context
.
tabBrowser
.
getTabDialogBox
(
contentBrowser
)
;
let
dialogs
=
tabDialogBox
.
getTabDialogManager
(
)
.
dialogs
;
if
(
dialogs
.
length
)
{
logger
.
trace
(
"
Found
open
tab
modal
prompt
"
)
;
return
new
modal
.
Dialog
(
(
)
=
>
context
dialogs
[
0
]
.
frameContentWindow
)
;
}
dialogs
=
tabDialogBox
.
getContentDialogManager
(
)
.
dialogs
;
if
(
dialogs
.
length
&
&
dialogs
[
0
]
.
frameContentWindow
.
Dialog
)
{
logger
.
trace
(
"
Found
open
content
prompt
"
)
;
return
new
modal
.
Dialog
(
(
)
=
>
context
dialogs
[
0
]
.
frameContentWindow
)
;
}
}
if
(
context
.
tabBrowser
?
.
getTabModalPromptBox
)
{
const
promptBox
=
context
.
tabBrowser
.
getTabModalPromptBox
(
contentBrowser
)
;
const
prompts
=
promptBox
.
listPrompts
(
)
;
if
(
prompts
.
length
)
{
logger
.
trace
(
"
Found
open
old
-
style
content
prompt
"
)
;
return
new
modal
.
Dialog
(
(
)
=
>
context
null
)
;
}
}
return
null
;
}
;
modal
.
DialogObserver
=
class
{
constructor
(
curBrowserFn
)
{
this
.
_curBrowserFn
=
curBrowserFn
;
this
.
callbacks
=
new
Set
(
)
;
this
.
register
(
)
;
}
register
(
)
{
Services
.
obs
.
addObserver
(
this
"
common
-
dialog
-
loaded
"
)
;
Services
.
obs
.
addObserver
(
this
"
tabmodal
-
dialog
-
loaded
"
)
;
Services
.
obs
.
addObserver
(
this
"
toplevel
-
window
-
ready
"
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
win
.
addEventListener
(
"
DOMModalDialogClosed
"
this
)
;
}
}
unregister
(
)
{
Services
.
obs
.
removeObserver
(
this
"
common
-
dialog
-
loaded
"
)
;
Services
.
obs
.
removeObserver
(
this
"
tabmodal
-
dialog
-
loaded
"
)
;
Services
.
obs
.
removeObserver
(
this
"
toplevel
-
window
-
ready
"
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
win
.
removeEventListener
(
"
DOMModalDialogClosed
"
this
)
;
}
}
cleanup
(
)
{
this
.
callbacks
.
clear
(
)
;
this
.
unregister
(
)
;
}
handleEvent
(
event
)
{
logger
.
trace
(
Received
event
{
event
.
type
}
)
;
const
chromeWin
=
event
.
target
.
opener
?
event
.
target
.
opener
.
ownerGlobal
:
event
.
target
.
ownerGlobal
;
if
(
chromeWin
!
=
this
.
_curBrowserFn
(
)
.
window
)
{
return
;
}
this
.
callbacks
.
forEach
(
callback
=
>
{
callback
(
modal
.
ACTION_CLOSED
event
.
target
)
;
}
)
;
}
observe
(
subject
topic
)
{
logger
.
trace
(
Received
observer
notification
{
topic
}
)
;
const
curBrowser
=
this
.
_curBrowserFn
(
)
;
switch
(
topic
)
{
case
"
tabmodal
-
dialog
-
loaded
"
:
const
container
=
curBrowser
.
contentBrowser
.
closest
(
"
.
browserSidebarContainer
"
)
;
if
(
!
container
.
contains
(
subject
)
)
{
return
;
}
this
.
callbacks
.
forEach
(
callback
=
>
callback
(
modal
.
ACTION_OPENED
subject
)
)
;
break
;
case
"
common
-
dialog
-
loaded
"
:
const
modalType
=
subject
.
Dialog
.
args
.
modalType
;
if
(
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_TAB
|
|
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_CONTENT
)
{
const
container
=
curBrowser
.
contentBrowser
.
closest
(
"
.
browserSidebarContainer
"
)
;
if
(
!
container
.
contains
(
subject
.
docShell
.
chromeEventHandler
)
)
{
return
;
}
}
else
if
(
subject
.
ownerGlobal
!
=
curBrowser
.
window
&
&
subject
.
opener
?
.
ownerGlobal
!
=
curBrowser
.
window
)
{
return
;
}
this
.
callbacks
.
forEach
(
callback
=
>
callback
(
modal
.
ACTION_OPENED
subject
)
)
;
break
;
case
"
toplevel
-
window
-
ready
"
:
subject
.
addEventListener
(
"
DOMModalDialogClosed
"
this
)
;
break
;
}
}
add
(
callback
)
{
if
(
this
.
callbacks
.
has
(
callback
)
)
{
return
;
}
this
.
callbacks
.
add
(
callback
)
;
}
remove
(
callback
)
{
if
(
!
this
.
callbacks
.
has
(
callback
)
)
{
return
;
}
this
.
callbacks
.
delete
(
callback
)
;
}
async
dialogClosed
(
)
{
return
new
Promise
(
resolve
=
>
{
const
dialogClosed
=
(
action
dialog
)
=
>
{
if
(
action
=
=
modal
.
ACTION_CLOSED
)
{
this
.
remove
(
dialogClosed
)
;
resolve
(
)
;
}
}
;
this
.
add
(
dialogClosed
)
;
}
)
;
}
}
;
modal
.
Dialog
=
class
{
constructor
(
curBrowserFn
dialog
)
{
this
.
curBrowserFn_
=
curBrowserFn
;
this
.
win_
=
Cu
.
getWeakReference
(
dialog
)
;
}
get
curBrowser_
(
)
{
return
this
.
curBrowserFn_
(
)
;
}
get
window
(
)
{
if
(
this
.
win_
)
{
let
win
=
this
.
win_
.
get
(
)
;
if
(
win
&
&
win
.
parent
)
{
return
win
;
}
}
return
null
;
}
get
tabModal
(
)
{
let
win
=
this
.
window
;
if
(
win
)
{
return
win
.
Dialog
;
}
return
this
.
curBrowser_
.
getTabModal
(
)
;
}
get
args
(
)
{
let
tm
=
this
.
tabModal
;
return
tm
?
tm
.
args
:
null
;
}
get
isWindowModal
(
)
{
return
[
Services
.
prompt
.
MODAL_TYPE_WINDOW
Services
.
prompt
.
MODAL_TYPE_INTERNAL_WINDOW
]
.
includes
(
this
.
args
.
modalType
)
;
}
get
ui
(
)
{
let
tm
=
this
.
tabModal
;
return
tm
?
tm
.
ui
:
null
;
}
}
;
