"
use
strict
"
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
error
stack
TimeoutError
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
const
{
truncate
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
format
.
js
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
log
.
js
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
Log
.
get
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
executeSoon
"
"
DebounceCallback
"
"
IdlePromise
"
"
MessageManagerDestroyedPromise
"
"
PollPromise
"
"
Sleep
"
"
TimedPromise
"
"
waitForEvent
"
"
waitForMessage
"
"
waitForObserverTopic
"
]
;
const
{
TYPE_ONE_SHOT
TYPE_REPEATING_SLACK
}
=
Ci
.
nsITimer
;
const
PROMISE_TIMEOUT
=
AppConstants
.
DEBUG
?
4500
:
1500
;
function
executeSoon
(
func
)
{
if
(
typeof
func
!
=
"
function
"
)
{
throw
new
TypeError
(
)
;
}
Services
.
tm
.
dispatchToMainThread
(
func
)
;
}
function
PollPromise
(
func
{
timeout
=
null
interval
=
10
}
=
{
}
)
{
const
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
if
(
typeof
func
!
=
"
function
"
)
{
throw
new
TypeError
(
)
;
}
if
(
timeout
!
=
null
&
&
typeof
timeout
!
=
"
number
"
)
{
throw
new
TypeError
(
)
;
}
if
(
typeof
interval
!
=
"
number
"
)
{
throw
new
TypeError
(
)
;
}
if
(
(
timeout
&
&
(
!
Number
.
isInteger
(
timeout
)
|
|
timeout
<
0
)
)
|
|
(
!
Number
.
isInteger
(
interval
)
|
|
interval
<
0
)
)
{
throw
new
RangeError
(
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
start
end
;
if
(
Number
.
isInteger
(
timeout
)
)
{
start
=
new
Date
(
)
.
getTime
(
)
;
end
=
start
+
timeout
;
}
let
evalFn
=
(
)
=
>
{
new
Promise
(
func
)
.
then
(
resolve
rejected
=
>
{
if
(
error
.
isError
(
rejected
)
)
{
throw
rejected
;
}
if
(
typeof
end
!
=
"
undefined
"
&
&
(
start
=
=
end
|
|
new
Date
(
)
.
getTime
(
)
>
=
end
)
)
{
resolve
(
rejected
)
;
}
}
)
.
catch
(
reject
)
;
}
;
evalFn
(
)
;
timer
.
init
(
evalFn
interval
TYPE_REPEATING_SLACK
)
;
}
)
.
then
(
res
=
>
{
timer
.
cancel
(
)
;
return
res
;
}
err
=
>
{
timer
.
cancel
(
)
;
throw
err
;
}
)
;
}
function
TimedPromise
(
fn
{
timeout
=
PROMISE_TIMEOUT
throws
=
TimeoutError
}
=
{
}
)
{
const
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
if
(
typeof
fn
!
=
"
function
"
)
{
throw
new
TypeError
(
)
;
}
if
(
typeof
timeout
!
=
"
number
"
)
{
throw
new
TypeError
(
)
;
}
if
(
!
Number
.
isInteger
(
timeout
)
|
|
timeout
<
0
)
{
throw
new
RangeError
(
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
bail
=
(
)
=
>
{
if
(
throws
!
=
=
null
)
{
let
err
=
new
throws
(
)
;
reject
(
err
)
;
}
else
{
log
.
warn
(
TimedPromise
timed
out
after
{
timeout
}
ms
stack
(
)
)
;
resolve
(
)
;
}
}
;
timer
.
initWithCallback
(
{
notify
:
bail
}
timeout
TYPE_ONE_SHOT
)
;
try
{
fn
(
resolve
reject
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
.
then
(
res
=
>
{
timer
.
cancel
(
)
;
return
res
;
}
err
=
>
{
timer
.
cancel
(
)
;
throw
err
;
}
)
;
}
function
Sleep
(
timeout
)
{
if
(
typeof
timeout
!
=
"
number
"
)
{
throw
new
TypeError
(
)
;
}
return
new
TimedPromise
(
(
)
=
>
{
}
{
timeout
throws
:
null
}
)
;
}
function
MessageManagerDestroyedPromise
(
messageManager
)
{
return
new
Promise
(
resolve
=
>
{
function
observe
(
subject
topic
)
{
log
.
trace
(
Received
observer
notification
{
topic
}
)
;
if
(
subject
=
=
messageManager
)
{
Services
.
obs
.
removeObserver
(
this
"
message
-
manager
-
disconnect
"
)
;
resolve
(
)
;
}
}
Services
.
obs
.
addObserver
(
observe
"
message
-
manager
-
disconnect
"
)
;
}
)
;
}
function
IdlePromise
(
win
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
win
.
requestAnimationFrame
(
resolve
)
;
}
)
;
}
)
;
}
class
DebounceCallback
{
constructor
(
fn
{
timeout
=
250
}
=
{
}
)
{
if
(
typeof
fn
!
=
"
function
"
|
|
typeof
timeout
!
=
"
number
"
)
{
throw
new
TypeError
(
)
;
}
if
(
!
Number
.
isInteger
(
timeout
)
|
|
timeout
<
0
)
{
throw
new
RangeError
(
)
;
}
this
.
fn
=
fn
;
this
.
timeout
=
timeout
;
this
.
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
handleEvent
(
ev
)
{
this
.
timer
.
cancel
(
)
;
this
.
timer
.
initWithCallback
(
(
)
=
>
{
this
.
timer
.
cancel
(
)
;
this
.
fn
(
ev
)
;
}
this
.
timeout
TYPE_ONE_SHOT
)
;
}
}
this
.
DebounceCallback
=
DebounceCallback
;
function
waitForEvent
(
subject
eventName
{
capture
=
false
checkFn
=
null
wantsUntrusted
=
false
}
=
{
}
)
{
if
(
subject
=
=
null
|
|
!
(
"
addEventListener
"
in
subject
)
)
{
throw
new
TypeError
(
)
;
}
if
(
typeof
eventName
!
=
"
string
"
)
{
throw
new
TypeError
(
)
;
}
if
(
capture
!
=
null
&
&
typeof
capture
!
=
"
boolean
"
)
{
throw
new
TypeError
(
)
;
}
if
(
checkFn
!
=
null
&
&
typeof
checkFn
!
=
"
function
"
)
{
throw
new
TypeError
(
)
;
}
if
(
wantsUntrusted
!
=
null
&
&
typeof
wantsUntrusted
!
=
"
boolean
"
)
{
throw
new
TypeError
(
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
subject
.
addEventListener
(
eventName
function
listener
(
event
)
{
log
.
trace
(
Received
DOM
event
{
event
.
type
}
for
{
event
.
target
}
)
;
try
{
if
(
checkFn
&
&
!
checkFn
(
event
)
)
{
return
;
}
subject
.
removeEventListener
(
eventName
listener
capture
)
;
executeSoon
(
(
)
=
>
resolve
(
event
)
)
;
}
catch
(
ex
)
{
try
{
subject
.
removeEventListener
(
eventName
listener
capture
)
;
}
catch
(
ex2
)
{
}
executeSoon
(
(
)
=
>
reject
(
ex
)
)
;
}
}
capture
wantsUntrusted
)
;
}
)
;
}
function
waitForMessage
(
messageManager
messageName
{
checkFn
=
undefined
}
=
{
}
)
{
if
(
messageManager
=
=
null
|
|
!
(
"
addMessageListener
"
in
messageManager
)
)
{
throw
new
TypeError
(
)
;
}
if
(
typeof
messageName
!
=
"
string
"
)
{
throw
new
TypeError
(
)
;
}
if
(
checkFn
&
&
typeof
checkFn
!
=
"
function
"
)
{
throw
new
TypeError
(
)
;
}
return
new
Promise
(
resolve
=
>
{
messageManager
.
addMessageListener
(
messageName
function
onMessage
(
msg
)
{
log
.
trace
(
Received
{
messageName
}
for
{
msg
.
target
}
)
;
if
(
checkFn
&
&
!
checkFn
(
msg
)
)
{
return
;
}
messageManager
.
removeMessageListener
(
messageName
onMessage
)
;
resolve
(
msg
.
data
)
;
}
)
;
}
)
;
}
function
waitForObserverTopic
(
topic
{
checkFn
=
null
}
=
{
}
)
{
if
(
typeof
topic
!
=
"
string
"
)
{
throw
new
TypeError
(
)
;
}
if
(
checkFn
!
=
null
&
&
typeof
checkFn
!
=
"
function
"
)
{
throw
new
TypeError
(
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
data
)
{
log
.
trace
(
Received
observer
notification
{
topic
}
)
;
try
{
if
(
checkFn
&
&
!
checkFn
(
subject
data
)
)
{
return
;
}
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
{
subject
data
}
)
;
}
catch
(
ex
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
reject
(
ex
)
;
}
}
topic
)
;
}
)
;
}
