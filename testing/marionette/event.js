"
use
strict
"
;
const
{
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
event
"
]
;
const
COMPOSITION_ATTR_RAWINPUT
=
0x02
;
const
COMPOSITION_ATTR_SELECTEDRAWTEXT
=
0x03
;
const
COMPOSITION_ATTR_CONVERTEDTEXT
=
0x04
;
const
COMPOSITION_ATTR_SELECTEDCONVERTEDTEXT
=
0x05
;
let
seenEvent
=
false
;
function
getDOMWindowUtils
(
win
)
{
if
(
!
win
)
{
win
=
window
;
}
return
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
this
.
event
=
{
}
;
event
.
MouseEvents
=
{
click
:
0
dblclick
:
1
mousedown
:
2
mouseup
:
3
mouseover
:
4
mouseout
:
5
}
;
event
.
Modifiers
=
{
shiftKey
:
0
ctrlKey
:
1
altKey
:
2
metaKey
:
3
}
;
event
.
sendMouseEvent
=
function
(
mouseEvent
target
window
=
undefined
)
{
if
(
event
.
MouseEvents
.
hasOwnProperty
(
mouseEvent
.
type
)
)
{
throw
new
TypeError
(
"
Unsupported
event
type
:
"
+
mouseEvent
.
type
)
;
}
if
(
!
(
target
instanceof
Element
)
)
{
target
=
window
.
document
.
getElementById
(
target
)
;
}
let
ev
=
window
.
document
.
createEvent
(
"
MouseEvent
"
)
;
let
type
=
mouseEvent
.
type
;
let
view
=
window
;
let
detail
=
mouseEvent
.
detail
;
if
(
!
detail
)
{
if
(
mouseEvent
.
type
in
[
"
click
"
"
mousedown
"
"
mouseup
"
]
)
{
detail
=
1
;
}
else
if
(
mouseEvent
.
type
=
=
"
dblclick
"
)
{
detail
=
2
;
}
else
{
detail
=
0
;
}
}
let
screenX
=
mouseEvent
.
screenX
|
|
0
;
let
screenY
=
mouseEvent
.
screenY
|
|
0
;
let
clientX
=
mouseEvent
.
clientX
|
|
0
;
let
clientY
=
mouseEvent
.
clientY
|
|
0
;
let
ctrlKey
=
mouseEvent
.
ctrlKey
|
|
false
;
let
altKey
=
mouseEvent
.
altKey
|
|
false
;
let
shiftKey
=
mouseEvent
.
shiftKey
|
|
false
;
let
metaKey
=
mouseEvent
.
metaKey
|
|
false
;
let
button
=
mouseEvent
.
button
|
|
0
;
let
relatedTarget
=
mouseEvent
.
relatedTarget
|
|
null
;
ev
.
initMouseEvent
(
mouseEvent
.
type
true
true
view
detail
screenX
screenY
clientX
clientY
ctrlKey
altKey
shiftKey
metaKey
button
relatedTarget
)
;
}
;
event
.
sendChar
=
function
(
char
window
=
undefined
)
{
let
hasShift
=
(
char
=
=
char
.
toUpperCase
(
)
)
;
event
.
synthesizeKey
(
char
{
shiftKey
:
hasShift
}
window
)
;
}
;
event
.
sendString
=
function
(
string
window
=
undefined
)
{
for
(
let
i
=
0
;
i
<
string
.
length
;
+
+
i
)
{
event
.
sendChar
(
string
.
charAt
(
i
)
window
)
;
}
}
;
event
.
sendKey
=
function
(
key
window
=
undefined
)
{
let
keyName
=
"
VK_
"
+
key
.
toUpperCase
(
)
;
event
.
synthesizeKey
(
keyName
{
shiftKey
:
false
}
window
)
;
}
;
event
.
parseModifiers_
=
function
(
event
)
{
let
mval
=
0
;
if
(
event
.
shiftKey
)
{
mval
|
=
Ci
.
nsIDOMNSEvent
.
SHIFT_MASK
;
}
if
(
event
.
ctrlKey
)
{
mval
|
=
Ci
.
nsIDOMNSEvent
.
CONTROL_MASK
;
}
if
(
event
.
altKey
)
{
mval
|
=
Ci
.
nsIDOMNSEvent
.
ALT_MASK
;
}
if
(
event
.
metaKey
)
{
mval
|
=
Ci
.
nsIDOMNSEvent
.
META_MASK
;
}
if
(
event
.
accelKey
)
{
if
(
navigator
.
platform
.
indexOf
(
"
Mac
"
)
>
=
0
)
{
mval
|
=
Ci
.
nsIDOMNSEvent
.
META_MASK
;
}
else
{
mval
|
=
Ci
.
nsIDOMNSEvent
.
CONTROL_MASK
;
}
}
return
mval
;
}
;
event
.
synthesizeMouse
=
function
(
element
offsetX
offsetY
opts
window
=
undefined
)
{
let
rect
=
element
.
getBoundingClientRect
(
)
;
event
.
synthesizeMouseAtPoint
(
rect
.
left
+
offsetX
rect
.
top
+
offsetY
opts
window
)
;
}
;
event
.
synthesizeMouseAtPoint
=
function
(
left
top
opts
window
=
undefined
)
{
let
domutils
=
getDOMWindowUtils
(
window
)
;
let
button
=
event
.
button
|
|
0
;
let
clickCount
=
event
.
clickCount
|
|
1
;
let
modifiers
=
event
.
parseModifiers_
(
event
)
;
if
(
(
"
type
"
in
event
)
&
&
event
.
type
)
{
domutils
.
sendMouseEvent
(
event
.
type
left
top
button
clickCount
modifiers
)
;
}
else
{
domutils
.
sendMouseEvent
(
"
mousedown
"
left
top
button
clickCount
modifiers
)
;
domutils
.
sendMouseEvent
(
"
mouseup
"
left
top
button
clickCount
modifiers
)
;
}
}
;
event
.
synthesizeMouseAtCenter
=
function
(
element
event
window
)
{
let
rect
=
element
.
getBoundingClientRect
(
)
;
event
.
synthesizeMouse
(
element
rect
.
width
/
2
rect
.
height
/
2
event
window
)
;
}
;
event
.
synthesizeMouseScroll
=
function
(
target
offsetX
offsetY
ev
window
=
undefined
)
{
let
domutils
=
getDOMWindowUtils
(
window
)
;
const
kIsVertical
=
0x02
;
const
kIsHorizontal
=
0x04
;
const
kHasPixels
=
0x08
;
const
kIsMomentum
=
0x40
;
let
button
=
ev
.
button
|
|
0
;
let
modifiers
=
event
.
parseModifiers_
(
ev
)
;
let
rect
=
target
.
getBoundingClientRect
(
)
;
let
left
=
rect
.
left
;
let
top
=
rect
.
top
;
let
type
=
(
(
"
type
"
in
ev
)
&
&
ev
.
type
)
|
|
"
DOMMouseScroll
"
;
let
axis
=
ev
.
axis
|
|
"
vertical
"
;
let
scrollFlags
=
(
axis
=
=
"
horizontal
"
)
?
kIsHorizontal
:
kIsVertical
;
if
(
ev
.
hasPixels
)
{
scrollFlags
|
=
kHasPixels
;
}
if
(
ev
.
isMomentum
)
{
scrollFlags
|
=
kIsMomentum
;
}
domutils
.
sendMouseScrollEvent
(
type
left
+
offsetX
top
+
offsetY
button
scrollFlags
ev
.
delta
modifiers
)
;
}
;
function
computeKeyCodeFromChar_
(
char
)
{
if
(
char
.
length
!
=
1
)
{
return
0
;
}
if
(
char
>
=
"
a
"
&
&
char
<
=
"
z
"
)
{
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_A
+
char
.
charCodeAt
(
0
)
-
"
a
"
.
charCodeAt
(
0
)
;
}
if
(
char
>
=
"
A
"
&
&
char
<
=
"
Z
"
)
{
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_A
+
char
.
charCodeAt
(
0
)
-
"
A
"
.
charCodeAt
(
0
)
;
}
if
(
char
>
=
"
0
"
&
&
char
<
=
"
9
"
)
{
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_0
+
char
.
charCodeAt
(
0
)
-
"
0
"
.
charCodeAt
(
0
)
;
}
switch
(
char
)
{
case
"
~
"
:
case
"
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_BACK_QUOTE
;
case
"
!
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_1
;
case
"
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_2
;
case
"
#
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_3
;
case
"
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_4
;
case
"
%
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_5
;
case
"
^
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_6
;
case
"
&
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_7
;
case
"
*
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_8
;
case
"
(
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_9
;
case
"
)
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_0
;
case
"
-
"
:
case
"
_
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_SUBTRACT
;
case
"
+
"
:
case
"
=
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_EQUALS
;
case
"
{
"
:
case
"
[
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_OPEN_BRACKET
;
case
"
}
"
:
case
"
]
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_CLOSE_BRACKET
;
case
"
|
"
:
case
"
\
\
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_BACK_SLASH
;
case
"
:
"
:
case
"
;
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_SEMICOLON
;
case
"
'
"
:
case
"
\
"
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_QUOTE
;
case
"
<
"
:
case
"
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_COMMA
;
case
"
>
"
:
case
"
.
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_PERIOD
;
case
"
?
"
:
case
"
/
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_SLASH
;
case
"
\
n
"
:
return
Ci
.
nsIDOMKeyEvent
.
DOM_VK_RETURN
;
default
:
return
0
;
}
}
event
.
isKeypressFiredKey
=
function
(
key
)
{
if
(
typeof
key
=
=
"
string
"
)
{
if
(
key
.
indexOf
(
"
VK_
"
)
=
=
=
0
)
{
key
=
Ci
.
nsIDOMKeyEvent
[
"
DOM_
"
+
key
]
;
if
(
!
key
)
{
throw
new
TypeError
(
"
Unknown
key
:
"
+
key
)
;
}
}
else
{
return
true
;
}
}
switch
(
key
)
{
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_SHIFT
:
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_CONTROL
:
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_ALT
:
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_CAPS_LOCK
:
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_NUM_LOCK
:
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_SCROLL_LOCK
:
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_META
:
return
false
;
default
:
return
true
;
}
}
;
event
.
synthesizeKey
=
function
(
key
ev
window
=
undefined
)
{
let
domutils
=
getDOMWindowUtils
(
window
)
;
let
keyCode
=
0
;
let
charCode
=
0
;
if
(
key
.
indexOf
(
"
VK_
"
)
=
=
=
0
)
{
keyCode
=
Ci
.
nsIDOMKeyEvent
[
"
DOM_
"
+
key
]
;
if
(
!
keyCode
)
{
throw
new
TypeError
(
"
Unknown
key
:
"
+
key
)
;
}
}
else
{
charCode
=
key
.
charCodeAt
(
0
)
;
keyCode
=
computeKeyCodeFromChar_
(
key
.
charAt
(
0
)
)
;
}
let
modifiers
=
event
.
parseModifiers_
(
ev
)
;
if
(
!
(
"
type
"
in
ev
)
|
|
!
ev
.
type
)
{
let
keyDownDefaultHappened
=
domutils
.
sendKeyEvent
(
"
keydown
"
keyCode
0
modifiers
)
;
if
(
event
.
isKeypressFiredKey
(
keyCode
)
)
{
domutils
.
sendKeyEvent
(
"
keypress
"
charCode
?
0
:
keyCode
charCode
modifiers
!
keyDownDefaultHappened
)
;
}
domutils
.
sendKeyEvent
(
"
keyup
"
keyCode
0
modifiers
)
;
}
else
if
(
ev
.
type
=
=
"
keypress
"
)
{
domutils
.
sendKeyEvent
(
ev
.
type
charCode
?
0
:
keyCode
charCode
modifiers
)
;
}
else
{
domutils
.
sendKeyEvent
(
ev
.
type
keyCode
0
modifiers
)
;
}
}
;
function
expectEvent_
(
expectedTarget
expectedEvent
testName
)
{
if
(
!
expectedTarget
|
|
!
expectedEvent
)
{
return
null
;
}
seenEvent
=
false
;
let
type
;
if
(
expectedEvent
.
charAt
(
0
)
=
=
"
!
"
)
{
type
=
expectedEvent
.
substring
(
1
)
;
}
else
{
type
=
expectedEvent
;
}
let
handler
=
ev
=
>
{
let
pass
=
(
!
seenEvent
&
&
ev
.
originalTarget
=
=
expectedTarget
&
&
ev
.
type
=
=
type
)
;
is
(
pass
true
{
testName
}
{
type
}
event
target
{
seenEvent
?
"
twice
"
:
"
"
}
)
;
seenEvent
=
true
;
}
;
expectedTarget
.
addEventListener
(
type
handler
false
)
;
return
handler
;
}
function
checkExpectedEvent_
(
expectedTarget
expectedEvent
eventHandler
testName
)
{
if
(
eventHandler
)
{
let
expectEvent
=
(
expectedEvent
.
charAt
(
0
)
!
=
"
!
"
)
;
let
type
=
expectEvent
;
if
(
!
type
)
{
type
=
expectedEvent
.
substring
(
1
)
;
}
expectedTarget
.
removeEventListener
(
type
eventHandler
false
)
;
let
desc
=
{
type
}
event
;
if
(
!
expectEvent
)
{
desc
+
=
"
not
"
;
}
is
(
seenEvent
expectEvent
{
testName
}
{
desc
}
fired
)
;
}
seenEvent
=
false
;
}
event
.
synthesizeMouseExpectEvent
=
function
(
target
offsetX
offsetY
ev
expectedTarget
expectedEvent
testName
window
=
undefined
)
{
let
eventHandler
=
expectEvent_
(
expectedTarget
expectedEvent
testName
)
;
event
.
synthesizeMouse
(
target
offsetX
offsetY
ev
window
)
;
checkExpectedEvent_
(
expectedTarget
expectedEvent
eventHandler
testName
)
;
}
;
event
.
synthesizeKeyExpectEvent
=
function
(
key
ev
expectedTarget
expectedEvent
testName
window
=
undefined
)
{
let
eventHandler
=
expectEvent_
(
expectedTarget
expectedEvent
testName
)
;
event
.
synthesizeKey
(
key
ev
window
)
;
checkExpectedEvent_
(
expectedTarget
expectedEvent
eventHandler
testName
)
;
}
;
event
.
synthesizeComposition
=
function
(
ev
window
=
undefined
)
{
let
domutils
=
getDOMWindowUtils
(
window
)
;
domutils
.
sendCompositionEvent
(
ev
.
type
ev
.
data
|
|
"
"
ev
.
locale
|
|
"
"
)
;
}
;
event
.
synthesizeText
=
function
(
ev
window
=
undefined
)
{
let
domutils
=
getDOMWindowUtils
(
window
)
;
if
(
!
ev
.
composition
|
|
!
ev
.
composition
.
clauses
|
|
!
ev
.
composition
.
clauses
[
0
]
)
{
return
;
}
let
firstClauseLength
=
ev
.
composition
.
clauses
[
0
]
.
length
;
let
firstClauseAttr
=
ev
.
composition
.
clauses
[
0
]
.
attr
;
let
secondClauseLength
=
0
;
let
secondClauseAttr
=
0
;
let
thirdClauseLength
=
0
;
let
thirdClauseAttr
=
0
;
if
(
ev
.
composition
.
clauses
[
1
]
)
{
secondClauseLength
=
ev
.
composition
.
clauses
[
1
]
.
length
;
secondClauseAttr
=
ev
.
composition
.
clauses
[
1
]
.
attr
;
if
(
event
.
composition
.
clauses
[
2
]
)
{
thirdClauseLength
=
ev
.
composition
.
clauses
[
2
]
.
length
;
thirdClauseAttr
=
ev
.
composition
.
clauses
[
2
]
.
attr
;
}
}
let
caretStart
=
-
1
;
let
caretLength
=
0
;
if
(
event
.
caret
)
{
caretStart
=
ev
.
caret
.
start
;
caretLength
=
ev
.
caret
.
length
;
}
domutils
.
sendTextEvent
(
ev
.
composition
.
string
firstClauseLength
firstClauseAttr
secondClauseLength
secondClauseAttr
thirdClauseLength
thirdClauseAttr
caretStart
caretLength
)
;
}
;
event
.
synthesizeQuerySelectedText
=
function
(
window
=
undefined
)
{
let
domutils
=
getDOMWindowUtils
(
window
)
;
return
domutils
.
sendQueryContentEvent
(
domutils
.
QUERY_SELECTED_TEXT
0
0
0
0
)
;
}
;
event
.
synthesizeSelectionSet
=
function
(
offset
length
reverse
window
=
undefined
)
{
let
domutils
=
getDOMWindowUtils
(
window
)
;
return
domutils
.
sendSelectionSetEvent
(
offset
length
reverse
)
;
}
;
const
KEYCODES_LOOKUP
=
{
"
VK_SHIFT
"
:
"
shiftKey
"
"
VK_CONTROL
"
:
"
ctrlKey
"
"
VK_ALT
"
:
"
altKey
"
"
VK_META
"
:
"
metaKey
"
}
;
const
VIRTUAL_KEYCODE_LOOKUP
=
{
"
\
uE001
"
:
"
VK_CANCEL
"
"
\
uE002
"
:
"
VK_HELP
"
"
\
uE003
"
:
"
VK_BACK_SPACE
"
"
\
uE004
"
:
"
VK_TAB
"
"
\
uE005
"
:
"
VK_CLEAR
"
"
\
uE006
"
:
"
VK_RETURN
"
"
\
uE007
"
:
"
VK_RETURN
"
"
\
uE008
"
:
"
VK_SHIFT
"
"
\
uE009
"
:
"
VK_CONTROL
"
"
\
uE00A
"
:
"
VK_ALT
"
"
\
uE03D
"
:
"
VK_META
"
"
\
uE00B
"
:
"
VK_PAUSE
"
"
\
uE00C
"
:
"
VK_ESCAPE
"
"
\
uE00D
"
:
"
VK_SPACE
"
"
\
uE00E
"
:
"
VK_PAGE_UP
"
"
\
uE00F
"
:
"
VK_PAGE_DOWN
"
"
\
uE010
"
:
"
VK_END
"
"
\
uE011
"
:
"
VK_HOME
"
"
\
uE012
"
:
"
VK_LEFT
"
"
\
uE013
"
:
"
VK_UP
"
"
\
uE014
"
:
"
VK_RIGHT
"
"
\
uE015
"
:
"
VK_DOWN
"
"
\
uE016
"
:
"
VK_INSERT
"
"
\
uE017
"
:
"
VK_DELETE
"
"
\
uE018
"
:
"
VK_SEMICOLON
"
"
\
uE019
"
:
"
VK_EQUALS
"
"
\
uE01A
"
:
"
VK_NUMPAD0
"
"
\
uE01B
"
:
"
VK_NUMPAD1
"
"
\
uE01C
"
:
"
VK_NUMPAD2
"
"
\
uE01D
"
:
"
VK_NUMPAD3
"
"
\
uE01E
"
:
"
VK_NUMPAD4
"
"
\
uE01F
"
:
"
VK_NUMPAD5
"
"
\
uE020
"
:
"
VK_NUMPAD6
"
"
\
uE021
"
:
"
VK_NUMPAD7
"
"
\
uE022
"
:
"
VK_NUMPAD8
"
"
\
uE023
"
:
"
VK_NUMPAD9
"
"
\
uE024
"
:
"
VK_MULTIPLY
"
"
\
uE025
"
:
"
VK_ADD
"
"
\
uE026
"
:
"
VK_SEPARATOR
"
"
\
uE027
"
:
"
VK_SUBTRACT
"
"
\
uE028
"
:
"
VK_DECIMAL
"
"
\
uE029
"
:
"
VK_DIVIDE
"
"
\
uE031
"
:
"
VK_F1
"
"
\
uE032
"
:
"
VK_F2
"
"
\
uE033
"
:
"
VK_F3
"
"
\
uE034
"
:
"
VK_F4
"
"
\
uE035
"
:
"
VK_F5
"
"
\
uE036
"
:
"
VK_F6
"
"
\
uE037
"
:
"
VK_F7
"
"
\
uE038
"
:
"
VK_F8
"
"
\
uE039
"
:
"
VK_F9
"
"
\
uE03A
"
:
"
VK_F10
"
"
\
uE03B
"
:
"
VK_F11
"
"
\
uE03C
"
:
"
VK_F12
"
}
;
function
getKeyCode
(
c
)
{
if
(
c
in
VIRTUAL_KEYCODE_LOOKUP
)
{
return
VIRTUAL_KEYCODE_LOOKUP
[
c
]
;
}
return
c
;
}
event
.
sendKeyDown
=
function
(
keyToSend
modifiers
document
)
{
modifiers
.
type
=
"
keydown
"
;
event
.
sendSingleKey
(
keyToSend
modifiers
document
)
;
if
(
[
"
VK_SHIFT
"
"
VK_CONTROL
"
"
VK_ALT
"
"
VK_META
"
]
.
indexOf
(
getKeyCode
(
keyToSend
)
)
<
0
)
{
modifiers
.
type
=
"
keypress
"
;
event
.
sendSingleKey
(
keyToSend
modifiers
document
)
;
}
delete
modifiers
.
type
;
}
;
event
.
sendKeyUp
=
function
(
keyToSend
modifiers
window
=
undefined
)
{
modifiers
.
type
=
"
keyup
"
;
event
.
sendSingleKey
(
keyToSend
modifiers
window
)
;
delete
modifiers
.
type
;
}
;
event
.
sendSingleKey
=
function
(
keyToSend
modifiers
window
=
undefined
)
{
let
keyCode
=
getKeyCode
(
keyToSend
)
;
if
(
keyCode
in
KEYCODES_LOOKUP
)
{
let
modName
=
KEYCODES_LOOKUP
[
keyCode
]
;
modifiers
[
modName
]
=
!
modifiers
[
modName
]
;
}
else
if
(
modifiers
.
shiftKey
)
{
keyCode
=
keyCode
.
toUpperCase
(
)
;
}
event
.
synthesizeKey
(
keyCode
modifiers
window
)
;
}
;
function
focusElement
(
element
)
{
let
t
=
element
.
type
;
if
(
t
&
&
(
t
=
=
"
text
"
|
|
t
=
=
"
textarea
"
)
)
{
if
(
element
.
selectionEnd
=
=
0
)
{
let
len
=
element
.
value
.
length
;
element
.
setSelectionRange
(
len
len
)
;
}
}
element
.
focus
(
)
;
}
event
.
sendKeysToElement
=
function
(
keySequence
element
opts
=
{
}
window
=
undefined
)
{
if
(
opts
.
ignoreVisibility
|
|
elements
.
checkVisible
(
element
window
)
)
{
focusElement
(
element
)
;
let
modifiers
=
Object
.
create
(
event
.
Modifiers
)
;
for
(
let
modifier
in
event
.
Modifiers
)
{
modifiers
[
modifier
]
=
false
;
}
let
value
=
keySequence
.
join
(
"
"
)
;
for
(
let
i
=
0
;
i
<
value
.
length
;
i
+
+
)
{
let
c
=
value
.
charAt
(
i
)
;
event
.
sendSingleKey
(
c
modifiers
window
)
;
}
}
else
{
throw
new
ElementNotVisibleError
(
"
Element
is
not
visible
"
)
;
}
}
;
