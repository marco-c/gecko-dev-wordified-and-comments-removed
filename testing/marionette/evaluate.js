"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
evaluate
"
]
;
this
.
evaluate
=
{
}
;
evaluate
.
ScriptStorage
=
class
extends
Set
{
concat
(
.
.
.
additional
)
{
let
rv
=
"
"
;
for
(
let
s
of
this
)
{
rv
=
s
+
rv
;
}
for
(
let
s
of
additional
)
{
rv
=
rv
+
s
;
}
return
rv
;
}
toJson
(
)
{
return
Array
.
from
(
this
)
;
}
}
;
evaluate
.
ScriptStorageService
=
class
extends
Map
{
constructor
(
initialStorages
=
[
]
)
{
super
(
initialStorages
.
map
(
name
=
>
[
name
new
evaluate
.
ScriptStorage
(
)
]
)
)
;
}
for
(
context
)
{
return
this
.
get
(
context
)
;
}
processMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
Marionette
:
getImportedScripts
"
:
let
storage
=
this
.
for
.
apply
(
this
msg
.
json
)
;
return
storage
.
toJson
(
)
;
default
:
throw
new
TypeError
(
"
Unknown
message
:
"
+
msg
.
name
)
;
}
}
receiveMessage
(
msg
)
{
try
{
return
this
.
processMessage
(
msg
)
;
}
catch
(
e
)
{
logger
.
error
(
e
)
;
}
}
}
;
evaluate
.
ScriptStorageService
.
prototype
.
QueryInterface
=
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIMessageListener
Ci
.
nsISupportsWeakReference
]
)
;
evaluate
.
ScriptStorageServiceClient
=
class
{
constructor
(
chromeProxy
)
{
this
.
chrome
=
chromeProxy
;
}
for
(
context
)
{
let
scripts
=
this
.
chrome
.
getImportedScripts
(
context
)
[
0
]
;
return
new
evaluate
.
ScriptStorage
(
scripts
)
;
}
}
;
