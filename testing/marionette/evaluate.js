"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
evaluate
"
"
sandbox
"
"
Sandboxes
"
]
;
const
ARGUMENTS
=
"
__webDriverArguments
"
;
const
CALLBACK
=
"
__webDriverCallback
"
;
const
COMPLETE
=
"
__webDriverComplete
"
;
const
DEFAULT_TIMEOUT
=
10000
;
const
FINISH
=
"
finish
"
;
const
MARIONETTE_SCRIPT_FINISHED
=
"
marionetteScriptFinished
"
;
const
ELEMENT_KEY
=
"
element
"
;
const
W3C_ELEMENT_KEY
=
"
element
-
6066
-
11e4
-
a52e
-
4f735466cecf
"
;
this
.
evaluate
=
{
}
;
evaluate
.
sandbox
=
function
(
sb
script
args
=
[
]
opts
=
{
}
)
{
let
timeoutId
timeoutHandler
unloadHandler
;
let
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
sb
[
COMPLETE
]
=
resolve
;
timeoutHandler
=
(
)
=
>
reject
(
new
ScriptTimeoutError
(
"
Timed
out
"
)
)
;
unloadHandler
=
(
)
=
>
reject
(
new
JavaScriptError
(
"
Document
was
unloaded
during
execution
"
)
)
;
if
(
!
opts
.
directInject
)
{
sb
[
CALLBACK
]
=
sb
[
COMPLETE
]
;
sb
[
ARGUMENTS
]
=
Cu
.
cloneInto
(
args
sb
{
wrapReflectors
:
true
}
)
;
script
=
{
ARGUMENTS
}
.
push
(
rv
=
>
{
CALLBACK
}
(
rv
)
)
;
+
(
function
(
)
{
{
script
}
}
)
.
apply
(
null
{
ARGUMENTS
}
)
;
if
(
opts
.
sandboxName
)
{
sb
[
MARIONETTE_SCRIPT_FINISHED
]
=
sb
[
CALLBACK
]
;
}
}
if
(
opts
.
debug
)
{
sb
.
window
.
onerror
=
(
msg
url
line
)
=
>
{
let
err
=
new
JavaScriptError
(
{
msg
}
at
:
{
url
}
line
:
{
line
}
)
;
reject
(
err
)
;
}
;
}
timeoutId
=
setTimeout
(
timeoutHandler
opts
.
timeout
|
|
DEFAULT_TIMEOUT
)
;
sb
.
window
.
addEventListener
(
"
unload
"
unloadHandler
)
;
let
res
;
try
{
res
=
Cu
.
evalInSandbox
(
script
sb
"
1
.
8
"
opts
.
filename
|
|
"
dummy
file
"
0
)
;
}
catch
(
e
)
{
let
err
=
new
JavaScriptError
(
e
"
execute_script
"
opts
.
filename
opts
.
line
script
)
;
reject
(
err
)
;
}
if
(
!
opts
.
async
)
{
resolve
(
res
)
;
}
}
)
;
return
promise
.
then
(
res
=
>
{
sb
.
window
.
clearTimeout
(
timeoutId
)
;
sb
.
window
.
removeEventListener
(
"
unload
"
unloadHandler
)
;
return
res
;
}
)
;
}
;
this
.
sandbox
=
{
}
;
sandbox
.
augment
=
function
(
sb
adapter
)
{
function
*
entries
(
obj
)
{
for
(
let
key
of
Object
.
keys
(
obj
)
)
{
yield
[
key
obj
[
key
]
]
;
}
}
let
funcs
=
adapter
.
exports
|
|
entries
(
adapter
)
;
for
(
let
[
name
func
]
of
funcs
)
{
sb
[
name
]
=
func
;
}
return
sb
;
}
;
sandbox
.
create
=
function
(
window
principal
=
null
opts
=
{
}
)
{
let
p
=
principal
|
|
window
;
opts
=
Object
.
assign
(
{
sameZoneAs
:
window
sandboxPrototype
:
window
wantComponents
:
true
wantXrays
:
true
}
opts
)
;
return
new
Cu
.
Sandbox
(
p
opts
)
;
}
;
sandbox
.
createMutable
=
function
(
window
)
{
let
opts
=
{
wantComponents
:
false
wantXrays
:
false
}
;
return
sandbox
.
create
(
window
null
opts
)
;
}
;
sandbox
.
createSystemPrincipal
=
function
(
window
)
{
let
principal
=
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
;
return
sandbox
.
create
(
window
principal
)
;
}
;
sandbox
.
createSimpleTest
=
function
(
window
harness
)
{
let
sb
=
sandbox
.
create
(
window
)
;
sb
=
sandbox
.
augment
(
sb
harness
)
;
sb
[
FINISH
]
=
(
)
=
>
sb
[
COMPLETE
]
(
harness
.
generate_results
(
)
)
;
return
sb
;
}
;
this
.
Sandboxes
=
class
{
constructor
(
windowFn
)
{
this
.
windowFn_
=
windowFn
;
this
.
boxes_
=
new
Map
(
)
;
}
get
window_
(
)
{
return
this
.
windowFn_
(
)
;
}
get
(
name
=
"
default
"
fresh
=
false
)
{
let
sb
=
this
.
boxes_
.
get
(
name
)
;
if
(
sb
)
{
if
(
fresh
|
|
sb
.
window
!
=
this
.
window_
)
{
this
.
boxes_
.
delete
(
name
)
;
return
this
.
get
(
name
false
)
;
}
}
else
{
if
(
name
=
=
"
system
"
)
{
sb
=
sandbox
.
createSystemPrincipal
(
this
.
window_
)
;
}
else
{
sb
=
sandbox
.
create
(
this
.
window_
)
;
}
this
.
boxes_
.
set
(
name
sb
)
;
}
return
sb
;
}
clear
(
)
{
this
.
boxes_
.
clear
(
)
;
}
}
;
evaluate
.
ScriptStorage
=
class
extends
Set
{
concat
(
.
.
.
additional
)
{
let
rv
=
"
"
;
for
(
let
s
of
this
)
{
rv
=
s
+
rv
;
}
for
(
let
s
of
additional
)
{
rv
=
rv
+
s
;
}
return
rv
;
}
toJson
(
)
{
return
Array
.
from
(
this
)
;
}
}
;
evaluate
.
ScriptStorageService
=
class
extends
Map
{
constructor
(
initialStorages
=
[
]
)
{
super
(
initialStorages
.
map
(
name
=
>
[
name
new
evaluate
.
ScriptStorage
(
)
]
)
)
;
}
for
(
context
)
{
return
this
.
get
(
context
)
;
}
processMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
Marionette
:
getImportedScripts
"
:
let
storage
=
this
.
for
.
apply
(
this
msg
.
json
)
;
return
storage
.
toJson
(
)
;
default
:
throw
new
TypeError
(
"
Unknown
message
:
"
+
msg
.
name
)
;
}
}
receiveMessage
(
msg
)
{
try
{
return
this
.
processMessage
(
msg
)
;
}
catch
(
e
)
{
logger
.
error
(
e
)
;
}
}
}
;
evaluate
.
ScriptStorageService
.
prototype
.
QueryInterface
=
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIMessageListener
Ci
.
nsISupportsWeakReference
]
)
;
evaluate
.
ScriptStorageServiceClient
=
class
{
constructor
(
chromeProxy
)
{
this
.
chrome
=
chromeProxy
;
}
for
(
context
)
{
let
scripts
=
this
.
chrome
.
getImportedScripts
(
context
)
[
0
]
;
return
new
evaluate
.
ScriptStorage
(
scripts
)
;
}
}
;
