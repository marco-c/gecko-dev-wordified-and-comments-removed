"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
)
;
const
{
error
JavaScriptError
ScriptTimeoutError
WebDriverError
}
=
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
{
}
)
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
evaluate
"
"
sandbox
"
"
Sandboxes
"
]
;
const
ARGUMENTS
=
"
__webDriverArguments
"
;
const
CALLBACK
=
"
__webDriverCallback
"
;
const
COMPLETE
=
"
__webDriverComplete
"
;
const
DEFAULT_TIMEOUT
=
10000
;
const
FINISH
=
"
finish
"
;
const
MARIONETTE_SCRIPT_FINISHED
=
"
marionetteScriptFinished
"
;
const
ELEMENT_KEY
=
"
element
"
;
const
W3C_ELEMENT_KEY
=
"
element
-
6066
-
11e4
-
a52e
-
4f735466cecf
"
;
this
.
evaluate
=
{
}
;
evaluate
.
sandbox
=
function
(
sb
script
args
=
[
]
opts
=
{
}
)
{
let
scriptTimeoutID
timeoutHandler
unloadHandler
;
let
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
src
=
"
"
;
sb
[
COMPLETE
]
=
resolve
;
timeoutHandler
=
(
)
=
>
reject
(
new
ScriptTimeoutError
(
"
Timed
out
"
)
)
;
unloadHandler
=
sandbox
.
cloneInto
(
(
)
=
>
reject
(
new
JavaScriptError
(
"
Document
was
unloaded
"
)
)
sb
)
;
if
(
!
opts
.
directInject
)
{
if
(
opts
.
async
)
{
sb
[
CALLBACK
]
=
sb
[
COMPLETE
]
;
}
sb
[
ARGUMENTS
]
=
sandbox
.
cloneInto
(
args
sb
)
;
if
(
opts
.
async
)
{
sb
[
CALLBACK
]
=
sb
[
COMPLETE
]
;
src
+
=
{
ARGUMENTS
}
.
push
(
rv
=
>
{
CALLBACK
}
(
rv
)
)
;
;
}
src
+
=
(
function
(
)
{
{
script
}
}
)
.
apply
(
null
{
ARGUMENTS
}
)
;
if
(
opts
.
sandboxName
)
{
sb
[
MARIONETTE_SCRIPT_FINISHED
]
=
sb
[
CALLBACK
]
;
}
}
if
(
opts
.
debug
)
{
sb
.
window
.
onerror
=
(
msg
url
line
)
=
>
{
let
err
=
new
JavaScriptError
(
{
msg
}
at
{
url
}
:
{
line
}
)
;
reject
(
err
)
;
}
;
}
const
timeout
=
opts
.
timeout
|
|
DEFAULT_TIMEOUT
;
scriptTimeoutID
=
setTimeout
(
timeoutHandler
timeout
)
;
sb
.
window
.
onunload
=
unloadHandler
;
const
file
=
opts
.
filename
|
|
"
dummy
file
"
;
const
line
=
opts
.
line
|
|
0
;
let
res
;
try
{
res
=
Cu
.
evalInSandbox
(
src
sb
"
1
.
8
"
file
0
)
;
}
catch
(
e
)
{
let
err
=
new
JavaScriptError
(
e
{
fnName
:
"
execute_script
"
file
line
script
}
)
;
reject
(
err
)
;
}
if
(
!
opts
.
async
)
{
resolve
(
res
)
;
}
}
)
;
return
promise
.
then
(
res
=
>
{
clearTimeout
(
scriptTimeoutID
)
;
sb
.
window
.
removeEventListener
(
"
unload
"
unloadHandler
)
;
return
res
;
}
)
;
}
;
evaluate
.
fromJSON
=
function
(
obj
seenEls
win
shadowRoot
=
undefined
)
{
switch
(
typeof
obj
)
{
case
"
boolean
"
:
case
"
number
"
:
case
"
string
"
:
default
:
return
obj
;
case
"
object
"
:
if
(
obj
=
=
=
null
)
{
return
obj
;
}
else
if
(
Array
.
isArray
(
obj
)
)
{
return
obj
.
map
(
e
=
>
evaluate
.
fromJSON
(
e
seenEls
win
shadowRoot
)
)
;
}
else
if
(
Object
.
keys
(
obj
)
.
includes
(
element
.
Key
)
|
|
Object
.
keys
(
obj
)
.
includes
(
element
.
LegacyKey
)
)
{
let
uuid
=
obj
[
element
.
Key
]
|
|
obj
[
element
.
LegacyKey
]
;
let
el
=
seenEls
.
get
(
uuid
{
frame
:
win
shadowRoot
:
shadowRoot
}
)
;
if
(
!
el
)
{
throw
new
WebDriverError
(
Unknown
element
:
{
uuid
}
)
;
}
return
el
;
}
let
rv
=
{
}
;
for
(
let
prop
in
obj
)
{
rv
[
prop
]
=
evaluate
.
fromJSON
(
obj
[
prop
]
seenEls
win
shadowRoot
)
;
}
return
rv
;
}
}
;
evaluate
.
toJSON
=
function
(
obj
seenEls
)
{
const
t
=
Object
.
prototype
.
toString
.
call
(
obj
)
;
if
(
t
=
=
"
[
object
Undefined
]
"
|
|
t
=
=
"
[
object
Null
]
"
)
{
return
null
;
}
else
if
(
t
=
=
"
[
object
Boolean
]
"
|
|
t
=
=
"
[
object
Number
]
"
|
|
t
=
=
"
[
object
String
]
"
)
{
return
obj
;
}
else
if
(
element
.
isCollection
(
obj
)
)
{
return
[
.
.
.
obj
]
.
map
(
el
=
>
evaluate
.
toJSON
(
el
seenEls
)
)
;
}
else
if
(
"
nodeType
"
in
obj
&
&
obj
.
nodeType
=
=
obj
.
ELEMENT_NODE
)
{
let
uuid
=
seenEls
.
add
(
obj
)
;
return
element
.
makeWebElement
(
uuid
)
;
}
else
if
(
typeof
obj
[
"
toJSON
"
]
=
=
"
function
"
)
{
let
unsafeJSON
=
obj
.
toJSON
(
)
;
return
evaluate
.
toJSON
(
unsafeJSON
seenEls
)
;
}
let
rv
=
{
}
;
for
(
let
prop
in
obj
)
{
try
{
rv
[
prop
]
=
evaluate
.
toJSON
(
obj
[
prop
]
seenEls
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
{
logger
.
debug
(
Skipping
{
prop
}
:
{
e
.
message
}
)
;
}
else
{
throw
e
;
}
}
}
return
rv
;
}
;
evaluate
.
isDead
=
function
(
obj
prop
)
{
try
{
obj
[
prop
]
;
}
catch
(
e
)
{
if
(
e
.
message
.
includes
(
"
dead
object
"
)
)
{
return
true
;
}
throw
e
;
}
return
false
;
}
;
this
.
sandbox
=
{
}
;
sandbox
.
cloneInto
=
function
(
obj
sb
)
{
return
Cu
.
cloneInto
(
obj
sb
{
cloneFunctions
:
true
wrapReflectors
:
true
}
)
;
}
;
sandbox
.
augment
=
function
(
sb
adapter
)
{
function
*
entries
(
obj
)
{
for
(
let
key
of
Object
.
keys
(
obj
)
)
{
yield
[
key
obj
[
key
]
]
;
}
}
let
funcs
=
adapter
.
exports
|
|
entries
(
adapter
)
;
for
(
let
[
name
func
]
of
funcs
)
{
sb
[
name
]
=
func
;
}
return
sb
;
}
;
sandbox
.
create
=
function
(
window
principal
=
null
opts
=
{
}
)
{
let
p
=
principal
|
|
window
;
opts
=
Object
.
assign
(
{
sameZoneAs
:
window
sandboxPrototype
:
window
wantComponents
:
true
wantXrays
:
true
}
opts
)
;
return
new
Cu
.
Sandbox
(
p
opts
)
;
}
;
sandbox
.
createMutable
=
function
(
window
)
{
let
opts
=
{
wantComponents
:
false
wantXrays
:
false
}
;
return
sandbox
.
create
(
window
null
opts
)
;
}
;
sandbox
.
createSystemPrincipal
=
function
(
window
)
{
let
principal
=
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
;
return
sandbox
.
create
(
window
principal
)
;
}
;
sandbox
.
createSimpleTest
=
function
(
window
harness
)
{
let
sb
=
sandbox
.
create
(
window
)
;
sb
=
sandbox
.
augment
(
sb
harness
)
;
sb
[
FINISH
]
=
(
)
=
>
sb
[
COMPLETE
]
(
harness
.
generate_results
(
)
)
;
return
sb
;
}
;
this
.
Sandboxes
=
class
{
constructor
(
windowFn
)
{
this
.
windowFn_
=
windowFn
;
this
.
boxes_
=
new
Map
(
)
;
}
get
window_
(
)
{
return
this
.
windowFn_
(
)
;
}
get
(
name
=
"
default
"
fresh
=
false
)
{
let
sb
=
this
.
boxes_
.
get
(
name
)
;
if
(
sb
)
{
if
(
fresh
|
|
evaluate
.
isDead
(
sb
"
window
"
)
|
|
sb
.
window
!
=
this
.
window_
)
{
this
.
boxes_
.
delete
(
name
)
;
return
this
.
get
(
name
false
)
;
}
}
else
{
if
(
name
=
=
"
system
"
)
{
sb
=
sandbox
.
createSystemPrincipal
(
this
.
window_
)
;
}
else
{
sb
=
sandbox
.
create
(
this
.
window_
)
;
}
this
.
boxes_
.
set
(
name
sb
)
;
}
return
sb
;
}
clear
(
)
{
this
.
boxes_
.
clear
(
)
;
}
}
;
