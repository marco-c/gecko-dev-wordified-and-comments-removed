"
use
strict
"
;
const
winUtil
=
content
.
windowUtils
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
accessibility
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
accessibility
.
js
"
)
;
const
{
action
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
action
.
js
"
)
;
const
{
atom
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
atom
.
js
"
)
;
const
{
Capabilities
PageLoadStrategy
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
capabilities
.
js
"
)
;
const
{
element
WebElement
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
)
;
const
{
ElementNotInteractableError
InsecureCertificateError
InvalidArgumentError
InvalidSelectorError
NoSuchElementError
NoSuchFrameError
TimeoutError
UnknownError
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
const
{
Sandboxes
evaluate
sandbox
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
evaluate
.
js
"
)
;
const
{
event
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
event
.
js
"
)
;
const
{
ContentEventObserverService
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
dom
.
js
"
)
;
const
{
pprint
truncate
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
format
.
js
"
)
;
const
{
interaction
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
interaction
.
js
"
)
;
const
{
legacyaction
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
legacyaction
.
js
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
log
.
js
"
)
;
const
{
navigate
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
navigate
.
js
"
)
;
const
{
proxy
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
proxy
.
js
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
getWithPrefix
(
contentId
)
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
const
contentId
=
content
.
docShell
.
browsingContext
.
id
;
const
curContainer
=
{
_frame
:
null
shadowRoot
:
null
get
frame
(
)
{
return
this
.
_frame
;
}
set
frame
(
frame
)
{
this
.
_frame
=
frame
;
this
.
id
=
this
.
_frame
.
docShell
.
browsingContext
.
id
;
this
.
shadowRoot
=
null
;
}
}
;
addEventListener
(
"
click
"
event
.
DoubleClickTracker
.
setClick
)
;
addEventListener
(
"
dblclick
"
event
.
DoubleClickTracker
.
resetClick
)
;
addEventListener
(
"
unload
"
event
.
DoubleClickTracker
.
resetClick
true
)
;
const
seenEls
=
new
element
.
Store
(
)
;
const
SUPPORTED_STRATEGIES
=
new
Set
(
[
element
.
Strategy
.
ClassName
element
.
Strategy
.
Selector
element
.
Strategy
.
ID
element
.
Strategy
.
Name
element
.
Strategy
.
LinkText
element
.
Strategy
.
PartialLinkText
element
.
Strategy
.
TagName
element
.
Strategy
.
XPath
]
)
;
Object
.
defineProperty
(
this
"
capabilities
"
{
get
(
)
{
let
payload
=
sendSyncMessage
(
"
Marionette
:
WebDriver
:
GetCapabilities
"
)
;
return
Capabilities
.
fromJSON
(
payload
[
0
]
)
;
}
configurable
:
true
}
)
;
let
legacyactions
=
new
legacyaction
.
Chain
(
)
;
let
multiLast
=
{
}
;
const
sandboxes
=
new
Sandboxes
(
(
)
=
>
curContainer
.
frame
)
;
const
eventObservers
=
new
ContentEventObserverService
(
content
sendAsyncMessage
.
bind
(
this
)
)
;
const
loadListener
=
{
commandID
:
null
seenBeforeUnload
:
false
seenUnload
:
false
timeout
:
null
timerPageLoad
:
null
timerPageUnload
:
null
start
(
commandID
timeout
startTime
waitForUnloaded
=
true
)
{
this
.
commandID
=
commandID
;
this
.
timeout
=
timeout
;
this
.
seenBeforeUnload
=
false
;
this
.
seenUnload
=
false
;
this
.
timerPageLoad
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
timerPageUnload
=
null
;
timeout
=
startTime
+
timeout
-
new
Date
(
)
.
getTime
(
)
;
if
(
timeout
<
=
0
)
{
this
.
notify
(
this
.
timerPageLoad
)
;
return
;
}
if
(
waitForUnloaded
)
{
addEventListener
(
"
beforeunload
"
this
true
)
;
addEventListener
(
"
hashchange
"
this
true
)
;
addEventListener
(
"
pagehide
"
this
true
)
;
addEventListener
(
"
popstate
"
this
true
)
;
addEventListener
(
"
unload
"
this
true
)
;
Services
.
obs
.
addObserver
(
this
"
outer
-
window
-
destroyed
"
)
;
}
else
{
let
readyState
=
content
.
document
.
readyState
;
let
documentURI
=
content
.
document
.
documentURI
;
logger
.
trace
(
truncate
Check
readyState
{
readyState
}
for
{
documentURI
}
)
;
if
(
this
.
handleReadyState
(
readyState
documentURI
)
)
{
return
;
}
addEventListener
(
"
DOMContentLoaded
"
loadListener
true
)
;
addEventListener
(
"
pageshow
"
loadListener
true
)
;
}
this
.
timerPageLoad
.
initWithCallback
(
this
timeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
stop
(
)
{
if
(
this
.
timerPageLoad
)
{
this
.
timerPageLoad
.
cancel
(
)
;
}
if
(
this
.
timerPageUnload
)
{
this
.
timerPageUnload
.
cancel
(
)
;
}
removeEventListener
(
"
beforeunload
"
this
true
)
;
removeEventListener
(
"
hashchange
"
this
true
)
;
removeEventListener
(
"
pagehide
"
this
true
)
;
removeEventListener
(
"
popstate
"
this
true
)
;
removeEventListener
(
"
DOMContentLoaded
"
this
true
)
;
removeEventListener
(
"
pageshow
"
this
true
)
;
removeEventListener
(
"
unload
"
this
true
)
;
try
{
Services
.
obs
.
removeObserver
(
this
"
outer
-
window
-
destroyed
"
)
;
}
catch
(
e
)
{
}
}
handleEvent
(
event
)
{
if
(
event
.
target
!
=
curContainer
.
frame
&
&
event
.
target
!
=
curContainer
.
frame
.
document
)
{
return
;
}
let
location
=
event
.
target
.
documentURI
|
|
event
.
target
.
location
.
href
;
logger
.
trace
(
truncate
Received
DOM
event
{
event
.
type
}
for
{
location
}
)
;
switch
(
event
.
type
)
{
case
"
beforeunload
"
:
this
.
seenBeforeUnload
=
true
;
break
;
case
"
unload
"
:
this
.
seenUnload
=
true
;
break
;
case
"
pagehide
"
:
this
.
seenUnload
=
true
;
removeEventListener
(
"
hashchange
"
this
true
)
;
removeEventListener
(
"
pagehide
"
this
true
)
;
removeEventListener
(
"
popstate
"
this
true
)
;
addEventListener
(
"
DOMContentLoaded
"
this
true
)
;
addEventListener
(
"
pageshow
"
this
true
)
;
break
;
case
"
hashchange
"
:
case
"
popstate
"
:
this
.
stop
(
)
;
sendOk
(
this
.
commandID
)
;
break
;
case
"
DOMContentLoaded
"
:
case
"
pageshow
"
:
this
.
handleReadyState
(
event
.
target
.
readyState
event
.
target
.
documentURI
)
;
break
;
}
}
handleReadyState
(
readyState
documentURI
)
{
let
finished
=
false
;
switch
(
readyState
)
{
case
"
interactive
"
:
if
(
documentURI
.
startsWith
(
"
about
:
certerror
"
)
)
{
this
.
stop
(
)
;
sendError
(
new
InsecureCertificateError
(
)
this
.
commandID
)
;
finished
=
true
;
}
else
if
(
/
about
:
.
*
(
error
)
\
?
/
.
exec
(
documentURI
)
)
{
this
.
stop
(
)
;
sendError
(
new
UnknownError
(
Reached
error
page
:
{
documentURI
}
)
this
.
commandID
)
;
finished
=
true
;
}
else
if
(
(
capabilities
.
get
(
"
pageLoadStrategy
"
)
=
=
=
PageLoadStrategy
.
Eager
&
&
documentURI
!
=
"
about
:
blank
"
)
|
|
/
about
:
blocked
\
?
/
.
exec
(
documentURI
)
)
{
this
.
stop
(
)
;
sendOk
(
this
.
commandID
)
;
finished
=
true
;
}
break
;
case
"
complete
"
:
this
.
stop
(
)
;
sendOk
(
this
.
commandID
)
;
finished
=
true
;
break
;
}
return
finished
;
}
notify
(
timer
)
{
switch
(
timer
)
{
case
this
.
timerPageUnload
:
if
(
this
.
seenBeforeUnload
)
{
this
.
seenBeforeUnload
=
null
;
this
.
timerPageUnload
.
initWithCallback
(
this
5000
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
if
(
!
this
.
seenUnload
)
{
logger
.
debug
(
"
Canceled
page
load
listener
because
no
navigation
"
+
"
has
been
detected
"
)
;
this
.
stop
(
)
;
sendOk
(
this
.
commandID
)
;
}
break
;
case
this
.
timerPageLoad
:
this
.
stop
(
)
;
sendError
(
new
TimeoutError
(
Timeout
loading
page
after
{
this
.
timeout
}
ms
)
this
.
commandID
)
;
break
;
}
}
observe
(
subject
topic
)
{
logger
.
trace
(
Received
observer
notification
{
topic
}
)
;
const
winId
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
;
const
bc
=
BrowsingContext
.
get
(
curContainer
.
id
)
;
switch
(
topic
)
{
case
"
outer
-
window
-
destroyed
"
:
if
(
bc
.
window
.
windowUtils
.
outerWindowID
=
=
winId
)
{
this
.
stop
(
)
;
sendOk
(
this
.
commandID
)
;
}
break
;
}
}
waitForLoadAfterFramescriptReload
(
commandID
timeout
startTime
)
{
this
.
start
(
commandID
timeout
startTime
false
)
;
}
navigate
(
trigger
commandID
timeout
loadEventExpected
=
true
useUnloadTimer
=
false
)
{
loadEventExpected
=
loadEventExpected
&
&
capabilities
.
get
(
"
pageLoadStrategy
"
)
!
=
=
PageLoadStrategy
.
None
;
if
(
loadEventExpected
)
{
let
startTime
=
new
Date
(
)
.
getTime
(
)
;
this
.
start
(
commandID
timeout
startTime
true
)
;
}
return
(
async
(
)
=
>
{
await
trigger
(
)
;
}
)
(
)
.
then
(
(
)
=
>
{
if
(
!
loadEventExpected
)
{
sendOk
(
commandID
)
;
return
;
}
if
(
useUnloadTimer
)
{
this
.
timerPageUnload
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
timerPageUnload
.
initWithCallback
(
this
200
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
}
)
.
catch
(
err
=
>
{
if
(
loadEventExpected
)
{
this
.
stop
(
)
;
}
sendError
(
err
commandID
)
;
}
)
;
}
}
;
function
registerSelf
(
)
{
logger
.
trace
(
"
Frame
script
loaded
"
)
;
curContainer
.
frame
=
content
;
sandboxes
.
clear
(
)
;
legacyactions
.
mouseEventsOnly
=
false
;
action
.
inputStateMap
=
new
Map
(
)
;
action
.
inputsToCancel
=
[
]
;
let
reply
=
sendSyncMessage
(
"
Marionette
:
Register
"
{
frameId
:
contentId
}
)
;
if
(
reply
.
length
=
=
0
)
{
logger
.
error
(
"
No
reply
from
Marionette
:
Register
"
)
;
return
;
}
if
(
reply
[
0
]
.
frameId
=
=
=
contentId
)
{
logger
.
trace
(
"
Frame
script
registered
"
)
;
startListeners
(
)
;
sendAsyncMessage
(
"
Marionette
:
ListenersAttached
"
{
frameId
:
contentId
}
)
;
}
}
function
dispatch
(
fn
)
{
if
(
typeof
fn
!
=
"
function
"
)
{
throw
new
TypeError
(
"
Provided
dispatch
handler
is
not
a
function
"
)
;
}
return
msg
=
>
{
const
id
=
msg
.
json
.
commandID
;
let
req
=
new
Promise
(
resolve
=
>
{
const
args
=
evaluate
.
fromJSON
(
msg
.
json
seenEls
curContainer
.
frame
)
;
let
rv
;
if
(
typeof
args
=
=
"
undefined
"
|
|
args
instanceof
Array
)
{
rv
=
fn
.
apply
(
null
args
)
;
}
else
{
rv
=
fn
(
args
)
;
}
resolve
(
rv
)
;
}
)
;
req
.
then
(
rv
=
>
sendResponse
(
rv
id
)
err
=
>
sendError
(
err
id
)
)
.
catch
(
err
=
>
sendError
(
err
id
)
)
;
}
;
}
let
getActiveElementFn
=
dispatch
(
getActiveElement
)
;
let
getBrowsingContextIdFn
=
dispatch
(
getBrowsingContextId
)
;
let
getElementAttributeFn
=
dispatch
(
getElementAttribute
)
;
let
getElementPropertyFn
=
dispatch
(
getElementProperty
)
;
let
getElementTextFn
=
dispatch
(
getElementText
)
;
let
getElementTagNameFn
=
dispatch
(
getElementTagName
)
;
let
getElementRectFn
=
dispatch
(
getElementRect
)
;
let
getPageSourceFn
=
dispatch
(
getPageSource
)
;
let
getScreenshotRectFn
=
dispatch
(
getScreenshotRect
)
;
let
isElementEnabledFn
=
dispatch
(
isElementEnabled
)
;
let
findElementContentFn
=
dispatch
(
findElementContent
)
;
let
findElementsContentFn
=
dispatch
(
findElementsContent
)
;
let
isElementSelectedFn
=
dispatch
(
isElementSelected
)
;
let
clearElementFn
=
dispatch
(
clearElement
)
;
let
isElementDisplayedFn
=
dispatch
(
isElementDisplayed
)
;
let
getElementValueOfCssPropertyFn
=
dispatch
(
getElementValueOfCssProperty
)
;
let
switchToShadowRootFn
=
dispatch
(
switchToShadowRoot
)
;
let
singleTapFn
=
dispatch
(
singleTap
)
;
let
performActionsFn
=
dispatch
(
performActions
)
;
let
releaseActionsFn
=
dispatch
(
releaseActions
)
;
let
actionChainFn
=
dispatch
(
actionChain
)
;
let
multiActionFn
=
dispatch
(
multiAction
)
;
let
executeFn
=
dispatch
(
execute
)
;
let
executeInSandboxFn
=
dispatch
(
executeInSandbox
)
;
let
sendKeysToElementFn
=
dispatch
(
sendKeysToElement
)
;
let
reftestWaitFn
=
dispatch
(
reftestWait
)
;
function
startListeners
(
)
{
addMessageListener
(
"
Marionette
:
actionChain
"
actionChainFn
)
;
addMessageListener
(
"
Marionette
:
cancelRequest
"
cancelRequest
)
;
addMessageListener
(
"
Marionette
:
clearElement
"
clearElementFn
)
;
addMessageListener
(
"
Marionette
:
clickElement
"
clickElement
)
;
addMessageListener
(
"
Marionette
:
Deregister
"
deregister
)
;
addMessageListener
(
"
Marionette
:
DOM
:
AddEventListener
"
domAddEventListener
)
;
addMessageListener
(
"
Marionette
:
DOM
:
RemoveEventListener
"
domRemoveEventListener
)
;
addMessageListener
(
"
Marionette
:
execute
"
executeFn
)
;
addMessageListener
(
"
Marionette
:
executeInSandbox
"
executeInSandboxFn
)
;
addMessageListener
(
"
Marionette
:
findElementContent
"
findElementContentFn
)
;
addMessageListener
(
"
Marionette
:
findElementsContent
"
findElementsContentFn
)
;
addMessageListener
(
"
Marionette
:
getActiveElement
"
getActiveElementFn
)
;
addMessageListener
(
"
Marionette
:
getBrowsingContextId
"
getBrowsingContextIdFn
)
;
addMessageListener
(
"
Marionette
:
getElementAttribute
"
getElementAttributeFn
)
;
addMessageListener
(
"
Marionette
:
getElementProperty
"
getElementPropertyFn
)
;
addMessageListener
(
"
Marionette
:
getElementRect
"
getElementRectFn
)
;
addMessageListener
(
"
Marionette
:
getElementTagName
"
getElementTagNameFn
)
;
addMessageListener
(
"
Marionette
:
getElementText
"
getElementTextFn
)
;
addMessageListener
(
"
Marionette
:
getElementValueOfCssProperty
"
getElementValueOfCssPropertyFn
)
;
addMessageListener
(
"
Marionette
:
get
"
get
)
;
addMessageListener
(
"
Marionette
:
getPageSource
"
getPageSourceFn
)
;
addMessageListener
(
"
Marionette
:
getScreenshotRect
"
getScreenshotRectFn
)
;
addMessageListener
(
"
Marionette
:
goBack
"
goBack
)
;
addMessageListener
(
"
Marionette
:
goForward
"
goForward
)
;
addMessageListener
(
"
Marionette
:
isElementDisplayed
"
isElementDisplayedFn
)
;
addMessageListener
(
"
Marionette
:
isElementEnabled
"
isElementEnabledFn
)
;
addMessageListener
(
"
Marionette
:
isElementSelected
"
isElementSelectedFn
)
;
addMessageListener
(
"
Marionette
:
multiAction
"
multiActionFn
)
;
addMessageListener
(
"
Marionette
:
performActions
"
performActionsFn
)
;
addMessageListener
(
"
Marionette
:
refresh
"
refresh
)
;
addMessageListener
(
"
Marionette
:
reftestWait
"
reftestWaitFn
)
;
addMessageListener
(
"
Marionette
:
releaseActions
"
releaseActionsFn
)
;
addMessageListener
(
"
Marionette
:
sendKeysToElement
"
sendKeysToElementFn
)
;
addMessageListener
(
"
Marionette
:
Session
:
Delete
"
deleteSession
)
;
addMessageListener
(
"
Marionette
:
singleTap
"
singleTapFn
)
;
addMessageListener
(
"
Marionette
:
switchToFrame
"
switchToFrame
)
;
addMessageListener
(
"
Marionette
:
switchToParentFrame
"
switchToParentFrame
)
;
addMessageListener
(
"
Marionette
:
switchToShadowRoot
"
switchToShadowRootFn
)
;
addMessageListener
(
"
Marionette
:
waitForPageLoaded
"
waitForPageLoaded
)
;
}
function
deregister
(
)
{
removeMessageListener
(
"
Marionette
:
actionChain
"
actionChainFn
)
;
removeMessageListener
(
"
Marionette
:
cancelRequest
"
cancelRequest
)
;
removeMessageListener
(
"
Marionette
:
clearElement
"
clearElementFn
)
;
removeMessageListener
(
"
Marionette
:
clickElement
"
clickElement
)
;
removeMessageListener
(
"
Marionette
:
Deregister
"
deregister
)
;
removeMessageListener
(
"
Marionette
:
execute
"
executeFn
)
;
removeMessageListener
(
"
Marionette
:
executeInSandbox
"
executeInSandboxFn
)
;
removeMessageListener
(
"
Marionette
:
findElementContent
"
findElementContentFn
)
;
removeMessageListener
(
"
Marionette
:
findElementsContent
"
findElementsContentFn
)
;
removeMessageListener
(
"
Marionette
:
getActiveElement
"
getActiveElementFn
)
;
removeMessageListener
(
"
Marionette
:
getBrowsingContextId
"
getBrowsingContextIdFn
)
;
removeMessageListener
(
"
Marionette
:
getElementAttribute
"
getElementAttributeFn
)
;
removeMessageListener
(
"
Marionette
:
getElementProperty
"
getElementPropertyFn
)
;
removeMessageListener
(
"
Marionette
:
getElementRect
"
getElementRectFn
)
;
removeMessageListener
(
"
Marionette
:
getElementTagName
"
getElementTagNameFn
)
;
removeMessageListener
(
"
Marionette
:
getElementText
"
getElementTextFn
)
;
removeMessageListener
(
"
Marionette
:
getElementValueOfCssProperty
"
getElementValueOfCssPropertyFn
)
;
removeMessageListener
(
"
Marionette
:
get
"
get
)
;
removeMessageListener
(
"
Marionette
:
getPageSource
"
getPageSourceFn
)
;
removeMessageListener
(
"
Marionette
:
getScreenshotRect
"
getScreenshotRectFn
)
;
removeMessageListener
(
"
Marionette
:
goBack
"
goBack
)
;
removeMessageListener
(
"
Marionette
:
goForward
"
goForward
)
;
removeMessageListener
(
"
Marionette
:
isElementDisplayed
"
isElementDisplayedFn
)
;
removeMessageListener
(
"
Marionette
:
isElementEnabled
"
isElementEnabledFn
)
;
removeMessageListener
(
"
Marionette
:
isElementSelected
"
isElementSelectedFn
)
;
removeMessageListener
(
"
Marionette
:
multiAction
"
multiActionFn
)
;
removeMessageListener
(
"
Marionette
:
performActions
"
performActionsFn
)
;
removeMessageListener
(
"
Marionette
:
refresh
"
refresh
)
;
removeMessageListener
(
"
Marionette
:
releaseActions
"
releaseActionsFn
)
;
removeMessageListener
(
"
Marionette
:
sendKeysToElement
"
sendKeysToElementFn
)
;
removeMessageListener
(
"
Marionette
:
Session
:
Delete
"
deleteSession
)
;
removeMessageListener
(
"
Marionette
:
singleTap
"
singleTapFn
)
;
removeMessageListener
(
"
Marionette
:
switchToFrame
"
switchToFrame
)
;
removeMessageListener
(
"
Marionette
:
switchToParentFrame
"
switchToParentFrame
)
;
removeMessageListener
(
"
Marionette
:
switchToShadowRoot
"
switchToShadowRootFn
)
;
removeMessageListener
(
"
Marionette
:
waitForPageLoaded
"
waitForPageLoaded
)
;
}
function
deleteSession
(
)
{
seenEls
.
clear
(
)
;
curContainer
.
frame
=
content
;
curContainer
.
frame
.
focus
(
)
;
legacyactions
.
touchIds
=
{
}
;
if
(
action
.
inputStateMap
!
=
=
undefined
)
{
action
.
inputStateMap
.
clear
(
)
;
}
if
(
action
.
inputsToCancel
!
=
=
undefined
)
{
action
.
inputsToCancel
.
length
=
0
;
}
}
let
sendToServer
=
(
uuid
data
=
undefined
)
=
>
{
let
channel
=
new
proxy
.
AsyncMessageChannel
(
sendAsyncMessage
.
bind
(
this
)
)
;
channel
.
reply
(
uuid
data
)
;
}
;
function
sendResponse
(
obj
uuid
)
{
let
payload
=
evaluate
.
toJSON
(
obj
seenEls
)
;
sendToServer
(
uuid
payload
)
;
}
function
sendOk
(
uuid
)
{
sendToServer
(
uuid
)
;
}
function
sendError
(
err
uuid
)
{
sendToServer
(
uuid
err
)
;
}
async
function
execute
(
script
args
opts
)
{
let
sb
=
sandbox
.
createMutable
(
curContainer
.
frame
)
;
return
evaluate
.
sandbox
(
sb
script
args
opts
)
;
}
async
function
executeInSandbox
(
script
args
opts
)
{
let
sb
=
sandboxes
.
get
(
opts
.
sandboxName
opts
.
newSandbox
)
;
return
evaluate
.
sandbox
(
sb
script
args
opts
)
;
}
function
emitTouchEvent
(
type
touch
)
{
logger
.
info
(
Emitting
Touch
event
of
type
{
type
}
+
to
element
with
id
:
{
touch
.
target
.
id
}
+
and
tag
name
:
{
touch
.
target
.
tagName
}
+
at
coordinates
(
{
touch
.
clientX
}
)
+
{
touch
.
clientY
}
)
relative
to
the
viewport
)
;
const
win
=
curContainer
.
frame
;
if
(
win
.
docShell
.
asyncPanZoomEnabled
&
&
legacyactions
.
scrolling
)
{
let
ev
=
{
index
:
0
type
id
:
touch
.
identifier
clientX
:
touch
.
clientX
clientY
:
touch
.
clientY
screenX
:
touch
.
screenX
screenY
:
touch
.
screenY
radiusX
:
touch
.
radiusX
radiusY
:
touch
.
radiusY
rotation
:
touch
.
rotationAngle
force
:
touch
.
force
}
;
sendSyncMessage
(
"
Marionette
:
emitTouchEvent
"
ev
)
;
return
;
}
win
.
windowUtils
.
sendTouchEvent
(
type
[
touch
.
identifier
]
[
touch
.
clientX
]
[
touch
.
clientY
]
[
touch
.
radiusX
]
[
touch
.
radiusY
]
[
touch
.
rotationAngle
]
[
touch
.
force
]
0
)
;
}
async
function
singleTap
(
el
corx
cory
)
{
let
visible
=
element
.
isVisible
(
el
corx
cory
)
;
if
(
!
visible
)
{
throw
new
ElementNotInteractableError
(
"
Element
is
not
currently
visible
and
may
not
be
manipulated
"
)
;
}
let
a11y
=
accessibility
.
get
(
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
let
acc
=
await
a11y
.
getAccessible
(
el
true
)
;
a11y
.
assertVisible
(
acc
el
visible
)
;
a11y
.
assertActionable
(
acc
el
)
;
if
(
!
curContainer
.
frame
.
document
.
createTouch
)
{
legacyactions
.
mouseEventsOnly
=
true
;
}
let
c
=
element
.
coordinates
(
el
corx
cory
)
;
if
(
!
legacyactions
.
mouseEventsOnly
)
{
let
touchId
=
legacyactions
.
nextTouchId
+
+
;
let
touch
=
createATouch
(
el
c
.
x
c
.
y
touchId
)
;
emitTouchEvent
(
"
touchstart
"
touch
)
;
emitTouchEvent
(
"
touchend
"
touch
)
;
}
legacyactions
.
mouseTap
(
el
.
ownerDocument
c
.
x
c
.
y
)
;
}
function
createATouch
(
el
corx
cory
touchId
)
{
let
doc
=
el
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
[
clientX
clientY
pageX
pageY
screenX
screenY
]
=
legacyactions
.
getCoordinateInfo
(
el
corx
cory
)
;
let
atouch
=
doc
.
createTouch
(
win
el
touchId
pageX
pageY
screenX
screenY
clientX
clientY
)
;
return
atouch
;
}
async
function
performActions
(
msg
)
{
let
chain
=
action
.
Chain
.
fromJSON
(
msg
.
actions
)
;
await
action
.
dispatch
(
chain
curContainer
.
frame
!
capabilities
.
get
(
"
moz
:
useNonSpecCompliantPointerOrigin
"
)
)
;
}
async
function
releaseActions
(
)
{
await
action
.
dispatchTickActions
(
action
.
inputsToCancel
.
reverse
(
)
0
curContainer
.
frame
)
;
action
.
inputsToCancel
.
length
=
0
;
action
.
inputStateMap
.
clear
(
)
;
event
.
DoubleClickTracker
.
resetClick
(
)
;
}
function
actionChain
(
chain
touchId
)
{
let
touchProvider
=
{
}
;
touchProvider
.
createATouch
=
createATouch
;
touchProvider
.
emitTouchEvent
=
emitTouchEvent
;
return
legacyactions
.
dispatchActions
(
chain
touchId
curContainer
seenEls
touchProvider
)
;
}
function
emitMultiEvents
(
type
touch
touches
)
{
let
target
=
touch
.
target
;
let
doc
=
target
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
documentTouches
=
doc
.
createTouchList
(
touches
.
filter
(
function
(
t
)
{
return
t
.
target
.
ownerDocument
=
=
=
doc
&
&
type
!
=
"
touchcancel
"
;
}
)
)
;
let
targetTouches
=
doc
.
createTouchList
(
touches
.
filter
(
function
(
t
)
{
return
(
t
.
target
=
=
=
target
&
&
(
type
!
=
"
touchcancel
"
|
|
type
!
=
"
touchend
"
)
)
;
}
)
)
;
let
changedTouches
=
doc
.
createTouchList
(
touch
)
;
let
event
=
doc
.
createEvent
(
"
TouchEvent
"
)
;
event
.
initTouchEvent
(
type
true
true
win
0
false
false
false
false
documentTouches
targetTouches
changedTouches
)
;
target
.
dispatchEvent
(
event
)
;
}
function
setDispatch
(
batches
touches
batchIndex
=
0
)
{
if
(
batchIndex
>
=
batches
.
length
)
{
multiLast
=
{
}
;
return
;
}
let
batch
=
batches
[
batchIndex
]
;
let
pack
;
let
touchId
;
let
command
;
let
el
;
let
touch
;
let
lastTouch
;
let
touchIndex
;
let
waitTime
=
0
;
let
maxTime
=
0
;
let
c
;
batchIndex
+
+
;
for
(
let
i
=
0
;
i
<
batch
.
length
;
i
+
+
)
{
pack
=
batch
[
i
]
;
touchId
=
pack
[
0
]
;
command
=
pack
[
1
]
;
switch
(
command
)
{
case
"
press
"
:
el
=
seenEls
.
get
(
pack
[
2
]
curContainer
.
frame
)
;
c
=
element
.
coordinates
(
el
pack
[
3
]
pack
[
4
]
)
;
touch
=
createATouch
(
el
c
.
x
c
.
y
touchId
)
;
multiLast
[
touchId
]
=
touch
;
touches
.
push
(
touch
)
;
emitMultiEvents
(
"
touchstart
"
touch
touches
)
;
break
;
case
"
release
"
:
touch
=
multiLast
[
touchId
]
;
touchIndex
=
touches
.
indexOf
(
touch
)
;
touches
.
splice
(
touchIndex
1
)
;
emitMultiEvents
(
"
touchend
"
touch
touches
)
;
break
;
case
"
move
"
:
el
=
seenEls
.
get
(
pack
[
2
]
curContainer
.
frame
)
;
c
=
element
.
coordinates
(
el
)
;
touch
=
createATouch
(
multiLast
[
touchId
]
.
target
c
.
x
c
.
y
touchId
)
;
touchIndex
=
touches
.
indexOf
(
lastTouch
)
;
touches
[
touchIndex
]
=
touch
;
multiLast
[
touchId
]
=
touch
;
emitMultiEvents
(
"
touchmove
"
touch
touches
)
;
break
;
case
"
moveByOffset
"
:
el
=
multiLast
[
touchId
]
.
target
;
lastTouch
=
multiLast
[
touchId
]
;
touchIndex
=
touches
.
indexOf
(
lastTouch
)
;
let
doc
=
el
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
clientX
=
lastTouch
.
clientX
+
pack
[
2
]
;
let
clientY
=
lastTouch
.
clientY
+
pack
[
3
]
;
let
pageX
=
clientX
+
win
.
pageXOffset
;
let
pageY
=
clientY
+
win
.
pageYOffset
;
let
screenX
=
clientX
+
win
.
mozInnerScreenX
;
let
screenY
=
clientY
+
win
.
mozInnerScreenY
;
touch
=
doc
.
createTouch
(
win
el
touchId
pageX
pageY
screenX
screenY
clientX
clientY
)
;
touches
[
touchIndex
]
=
touch
;
multiLast
[
touchId
]
=
touch
;
emitMultiEvents
(
"
touchmove
"
touch
touches
)
;
break
;
case
"
wait
"
:
if
(
typeof
pack
[
2
]
!
=
"
undefined
"
)
{
waitTime
=
pack
[
2
]
*
1000
;
if
(
waitTime
>
maxTime
)
{
maxTime
=
waitTime
;
}
}
break
;
}
}
if
(
maxTime
!
=
0
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
function
(
)
{
setDispatch
(
batches
touches
batchIndex
)
;
}
maxTime
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
{
setDispatch
(
batches
touches
batchIndex
)
;
}
}
function
multiAction
(
args
maxLen
)
{
let
commandArray
=
evaluate
.
fromJSON
(
args
seenEls
curContainer
.
frame
)
;
let
concurrentEvent
=
[
]
;
let
temp
;
for
(
let
i
=
0
;
i
<
maxLen
;
i
+
+
)
{
let
row
=
[
]
;
for
(
let
j
=
0
;
j
<
commandArray
.
length
;
j
+
+
)
{
if
(
typeof
commandArray
[
j
]
[
i
]
!
=
"
undefined
"
)
{
temp
=
commandArray
[
j
]
[
i
]
;
temp
.
unshift
(
j
)
;
row
.
push
(
temp
)
;
}
}
concurrentEvent
.
push
(
row
)
;
}
let
pendingTouches
=
[
]
;
setDispatch
(
concurrentEvent
pendingTouches
)
;
}
function
cancelRequest
(
)
{
loadListener
.
stop
(
)
;
}
function
waitForPageLoaded
(
msg
)
{
let
{
commandID
pageTimeout
startTime
}
=
msg
.
json
;
loadListener
.
waitForLoadAfterFramescriptReload
(
commandID
pageTimeout
startTime
)
;
}
function
get
(
msg
)
{
let
{
commandID
pageTimeout
url
loadEventExpected
=
null
}
=
msg
.
json
;
try
{
if
(
typeof
url
=
=
"
string
"
)
{
try
{
if
(
loadEventExpected
=
=
=
null
)
{
loadEventExpected
=
navigate
.
isLoadEventExpected
(
curContainer
.
frame
.
location
url
)
;
}
}
catch
(
e
)
{
let
err
=
new
InvalidArgumentError
(
"
Malformed
URL
:
"
+
e
.
message
)
;
sendError
(
err
commandID
)
;
return
;
}
}
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
loadListener
.
navigate
(
(
)
=
>
{
curContainer
.
frame
.
location
=
url
;
}
commandID
pageTimeout
loadEventExpected
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
}
}
function
goBack
(
msg
)
{
let
{
commandID
pageTimeout
}
=
msg
.
json
;
try
{
loadListener
.
navigate
(
(
)
=
>
{
curContainer
.
frame
.
history
.
back
(
)
;
}
commandID
pageTimeout
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
}
}
function
goForward
(
msg
)
{
let
{
commandID
pageTimeout
}
=
msg
.
json
;
try
{
loadListener
.
navigate
(
(
)
=
>
{
curContainer
.
frame
.
history
.
forward
(
)
;
}
commandID
pageTimeout
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
}
}
function
refresh
(
msg
)
{
let
{
commandID
pageTimeout
}
=
msg
.
json
;
try
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
loadListener
.
navigate
(
(
)
=
>
{
curContainer
.
frame
.
location
.
reload
(
true
)
;
}
commandID
pageTimeout
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
}
}
function
getPageSource
(
)
{
return
curContainer
.
frame
.
document
.
documentElement
.
outerHTML
;
}
async
function
findElementContent
(
strategy
selector
opts
=
{
}
)
{
if
(
!
SUPPORTED_STRATEGIES
.
has
(
strategy
)
)
{
throw
new
InvalidSelectorError
(
"
Strategy
not
supported
:
"
+
strategy
)
;
}
opts
.
all
=
false
;
let
el
=
await
element
.
find
(
curContainer
strategy
selector
opts
)
;
return
seenEls
.
add
(
el
)
;
}
async
function
findElementsContent
(
strategy
selector
opts
=
{
}
)
{
if
(
!
SUPPORTED_STRATEGIES
.
has
(
strategy
)
)
{
throw
new
InvalidSelectorError
(
"
Strategy
not
supported
:
"
+
strategy
)
;
}
opts
.
all
=
true
;
let
els
=
await
element
.
find
(
curContainer
strategy
selector
opts
)
;
let
webEls
=
seenEls
.
addAll
(
els
)
;
return
webEls
;
}
function
getActiveElement
(
)
{
let
el
=
curContainer
.
frame
.
document
.
activeElement
;
if
(
!
el
)
{
throw
new
NoSuchElementError
(
)
;
}
return
evaluate
.
toJSON
(
el
seenEls
)
;
}
function
getBrowsingContextId
(
topContext
=
false
)
{
if
(
topContext
)
{
return
content
.
docShell
.
browsingContext
.
id
;
}
return
curContainer
.
frame
.
docShell
.
browsingContext
.
id
;
}
function
clickElement
(
msg
)
{
let
{
commandID
webElRef
pageTimeout
}
=
msg
.
json
;
try
{
let
webEl
=
WebElement
.
fromJSON
(
webElRef
)
;
let
el
=
seenEls
.
get
(
webEl
curContainer
.
frame
)
;
let
loadEventExpected
=
true
;
let
target
=
getElementAttribute
(
el
"
target
"
)
;
if
(
target
=
=
=
"
_blank
"
)
{
loadEventExpected
=
false
;
}
loadListener
.
navigate
(
(
)
=
>
{
return
interaction
.
clickElement
(
el
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
capabilities
.
get
(
"
moz
:
webdriverClick
"
)
)
;
}
commandID
pageTimeout
loadEventExpected
true
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
}
}
function
getElementAttribute
(
el
name
)
{
if
(
element
.
isBooleanAttribute
(
el
name
)
)
{
if
(
el
.
hasAttribute
(
name
)
)
{
return
"
true
"
;
}
return
null
;
}
return
el
.
getAttribute
(
name
)
;
}
function
getElementProperty
(
el
name
)
{
return
typeof
el
[
name
]
!
=
"
undefined
"
?
el
[
name
]
:
null
;
}
function
getElementText
(
el
)
{
return
atom
.
getElementText
(
el
curContainer
.
frame
)
;
}
function
getElementTagName
(
el
)
{
return
el
.
tagName
.
toLowerCase
(
)
;
}
function
isElementDisplayed
(
el
)
{
return
interaction
.
isElementDisplayed
(
el
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
}
function
getElementValueOfCssProperty
(
el
prop
)
{
let
st
=
curContainer
.
frame
.
document
.
defaultView
.
getComputedStyle
(
el
)
;
return
st
.
getPropertyValue
(
prop
)
;
}
function
getElementRect
(
el
)
{
let
clientRect
=
el
.
getBoundingClientRect
(
)
;
return
{
x
:
clientRect
.
x
+
curContainer
.
frame
.
pageXOffset
y
:
clientRect
.
y
+
curContainer
.
frame
.
pageYOffset
width
:
clientRect
.
width
height
:
clientRect
.
height
}
;
}
function
isElementEnabled
(
el
)
{
return
interaction
.
isElementEnabled
(
el
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
}
function
isElementSelected
(
el
)
{
return
interaction
.
isElementSelected
(
el
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
}
async
function
sendKeysToElement
(
el
val
)
{
let
opts
=
{
strictFileInteractability
:
capabilities
.
get
(
"
strictFileInteractability
"
)
accessibilityChecks
:
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
webdriverClick
:
capabilities
.
get
(
"
moz
:
webdriverClick
"
)
}
;
await
interaction
.
sendKeysToElement
(
el
val
opts
)
;
}
function
clearElement
(
el
)
{
interaction
.
clearElement
(
el
)
;
}
function
switchToShadowRoot
(
el
)
{
if
(
!
element
.
isElement
(
el
)
)
{
if
(
curContainer
.
shadowRoot
)
{
let
parent
;
try
{
parent
=
curContainer
.
shadowRoot
.
host
;
}
catch
(
e
)
{
curContainer
.
shadowRoot
=
null
;
return
;
}
while
(
parent
&
&
!
(
parent
instanceof
curContainer
.
frame
.
ShadowRoot
)
)
{
parent
=
parent
.
parentNode
;
}
curContainer
.
shadowRoot
=
parent
;
}
return
;
}
let
foundShadowRoot
=
el
.
shadowRoot
;
if
(
!
foundShadowRoot
)
{
throw
new
NoSuchElementError
(
pprint
Unable
to
locate
shadow
root
:
{
el
}
)
;
}
curContainer
.
shadowRoot
=
foundShadowRoot
;
}
function
switchToParentFrame
(
msg
)
{
curContainer
.
frame
=
curContainer
.
frame
.
parent
;
let
parentElement
=
seenEls
.
add
(
curContainer
.
frame
)
;
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
parentElement
.
uuid
}
)
;
sendOk
(
msg
.
json
.
commandID
)
;
}
function
switchToFrame
(
msg
)
{
let
commandID
=
msg
.
json
.
commandID
;
let
foundFrame
;
let
frameWebEl
;
let
frames
=
[
]
;
try
{
frames
=
curContainer
.
frame
.
frames
;
}
catch
(
e
)
{
msg
.
json
.
id
=
null
;
msg
.
json
.
element
=
null
;
}
if
(
(
msg
.
json
.
id
=
=
=
null
|
|
msg
.
json
.
id
=
=
=
undefined
)
&
&
msg
.
json
.
element
=
=
null
)
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
if
(
msg
.
json
.
focus
)
{
curContainer
.
frame
.
focus
(
)
;
}
sendOk
(
commandID
)
;
return
;
}
let
webEl
;
if
(
typeof
msg
.
json
.
element
!
=
"
undefined
"
)
{
webEl
=
WebElement
.
fromUUID
(
msg
.
json
.
element
"
content
"
)
;
}
if
(
webEl
)
{
if
(
!
seenEls
.
has
(
webEl
)
)
{
let
err
=
new
NoSuchElementError
(
Unable
to
locate
element
:
{
webEl
}
)
;
sendError
(
err
commandID
)
;
return
;
}
let
wantedFrame
;
try
{
wantedFrame
=
seenEls
.
get
(
webEl
curContainer
.
frame
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
return
;
}
if
(
frames
.
length
>
0
)
{
for
(
let
i
=
0
;
i
<
frames
.
length
;
i
+
+
)
{
let
frameEl
=
frames
[
i
]
.
frameElement
;
let
wrappedItem
=
new
XPCNativeWrapper
(
frameEl
)
;
let
wrappedWanted
=
new
XPCNativeWrapper
(
wantedFrame
)
;
if
(
wrappedItem
=
=
wrappedWanted
)
{
foundFrame
=
frameEl
;
}
}
}
if
(
!
foundFrame
)
{
const
doc
=
curContainer
.
frame
.
document
;
let
iframes
=
doc
.
getElementsByTagName
(
"
iframe
"
)
;
for
(
let
i
=
0
;
i
<
iframes
.
length
;
i
+
+
)
{
let
frameEl
=
iframes
[
i
]
;
let
wrappedEl
=
new
XPCNativeWrapper
(
frameEl
)
;
let
wrappedWanted
=
new
XPCNativeWrapper
(
wantedFrame
)
;
if
(
wrappedEl
=
=
wrappedWanted
)
{
foundFrame
=
iframes
[
i
]
;
}
}
}
}
if
(
!
foundFrame
)
{
if
(
typeof
msg
.
json
.
id
=
=
=
"
number
"
)
{
try
{
if
(
msg
.
json
.
id
>
=
0
&
&
msg
.
json
.
id
<
frames
.
length
)
{
foundFrame
=
frames
[
msg
.
json
.
id
]
.
frameElement
;
if
(
foundFrame
!
=
=
null
)
{
frameWebEl
=
seenEls
.
add
(
foundFrame
.
wrappedJSObject
)
;
}
else
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
if
(
msg
.
json
.
focus
)
{
curContainer
.
frame
.
focus
(
)
;
}
sendOk
(
commandID
)
;
return
;
}
}
}
catch
(
e
)
{
let
doc
=
foundFrame
.
document
;
let
iframes
=
doc
.
getElementsByTagName
(
"
iframe
"
)
;
if
(
msg
.
json
.
id
>
=
0
&
&
msg
.
json
.
id
<
iframes
.
length
)
{
foundFrame
=
iframes
[
msg
.
json
.
id
]
;
}
}
}
}
if
(
!
foundFrame
)
{
let
failedFrame
=
msg
.
json
.
id
|
|
msg
.
json
.
element
;
let
err
=
new
NoSuchFrameError
(
Unable
to
locate
frame
:
{
failedFrame
}
)
;
sendError
(
err
commandID
)
;
return
;
}
if
(
!
frameWebEl
)
{
frameWebEl
=
seenEls
.
add
(
foundFrame
.
wrappedJSObject
)
;
}
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
frameWebEl
.
uuid
}
)
;
curContainer
.
frame
=
foundFrame
.
contentWindow
;
if
(
msg
.
json
.
focus
)
{
curContainer
.
frame
.
focus
(
)
;
}
sendOk
(
commandID
)
;
}
function
getScreenshotRect
(
{
el
full
=
true
scroll
=
true
}
=
{
}
)
{
let
win
=
el
?
curContainer
.
frame
:
content
;
let
rect
;
if
(
el
)
{
if
(
scroll
)
{
element
.
scrollIntoView
(
el
)
;
}
rect
=
getElementRect
(
el
)
;
}
else
if
(
full
)
{
const
docEl
=
win
.
document
.
documentElement
;
rect
=
new
DOMRect
(
0
0
docEl
.
scrollWidth
docEl
.
scrollHeight
)
;
}
else
{
rect
=
new
DOMRect
(
win
.
pageXOffset
win
.
pageYOffset
win
.
innerWidth
win
.
innerHeight
)
;
}
return
rect
;
}
function
flushRendering
(
)
{
let
content
=
curContainer
.
frame
;
let
anyPendingPaintsGeneratedInDescendants
=
false
;
let
windowUtils
=
content
.
windowUtils
;
function
flushWindow
(
win
)
{
let
utils
=
win
.
windowUtils
;
let
afterPaintWasPending
=
utils
.
isMozAfterPaintPending
;
let
root
=
win
.
document
.
documentElement
;
if
(
root
)
{
try
{
root
.
getBoundingClientRect
(
)
;
}
catch
(
e
)
{
logger
.
error
(
"
flushWindow
failed
"
e
)
;
}
}
if
(
!
afterPaintWasPending
&
&
utils
.
isMozAfterPaintPending
)
{
anyPendingPaintsGeneratedInDescendants
=
true
;
}
for
(
let
i
=
0
;
i
<
win
.
frames
.
length
;
+
+
i
)
{
flushWindow
(
win
.
frames
[
i
]
)
;
}
}
flushWindow
(
content
)
;
if
(
anyPendingPaintsGeneratedInDescendants
&
&
!
windowUtils
.
isMozAfterPaintPending
)
{
logger
.
error
(
"
Descendant
frame
generated
a
MozAfterPaint
event
"
+
"
but
the
root
document
doesn
'
t
have
one
!
"
)
;
}
}
async
function
reftestWait
(
url
remote
)
{
let
win
=
curContainer
.
frame
;
let
document
=
curContainer
.
frame
.
document
;
let
reftestWait
;
if
(
document
.
location
.
href
!
=
=
url
|
|
document
.
readyState
!
=
"
complete
"
)
{
reftestWait
=
await
documentLoad
(
win
url
)
;
win
=
curContainer
.
frame
;
document
=
curContainer
.
frame
.
document
;
}
else
{
reftestWait
=
document
.
documentElement
.
classList
.
contains
(
"
reftest
-
wait
"
)
;
}
logger
.
debug
(
"
Waiting
for
event
loop
to
spin
"
)
;
await
new
Promise
(
resolve
=
>
win
.
setTimeout
(
resolve
0
)
)
;
await
paintComplete
(
win
remote
)
;
let
root
=
document
.
documentElement
;
if
(
reftestWait
)
{
let
event
=
new
Event
(
"
TestRendered
"
{
bubbles
:
true
}
)
;
root
.
dispatchEvent
(
event
)
;
logger
.
info
(
"
Emitted
TestRendered
event
"
)
;
await
reftestWaitRemoved
(
win
root
)
;
await
paintComplete
(
win
remote
)
;
}
if
(
win
.
innerWidth
<
document
.
documentElement
.
scrollWidth
|
|
win
.
innerHeight
<
document
.
documentElement
.
scrollHeight
)
{
logger
.
warn
(
{
url
}
overflows
viewport
(
width
:
{
document
.
documentElement
.
scrollWidth
}
height
:
{
document
.
documentElement
.
scrollHeight
}
)
)
;
}
}
function
documentLoad
(
win
url
)
{
logger
.
debug
(
truncate
Waiting
for
page
load
of
{
url
}
)
;
return
new
Promise
(
resolve
=
>
{
let
maybeResolve
=
event
=
>
{
if
(
event
.
target
=
=
=
curContainer
.
frame
.
document
&
&
event
.
target
.
location
.
href
=
=
=
url
)
{
let
reftestWait
=
win
.
document
.
documentElement
.
classList
.
contains
(
"
reftest
-
wait
"
)
;
removeEventListener
(
"
load
"
maybeResolve
{
once
:
true
}
)
;
resolve
(
reftestWait
)
;
}
}
;
addEventListener
(
"
load
"
maybeResolve
true
)
;
}
)
;
}
function
paintComplete
(
win
remote
)
{
logger
.
debug
(
"
Waiting
for
rendering
"
)
;
let
windowUtils
=
content
.
windowUtils
;
return
new
Promise
(
resolve
=
>
{
let
maybeResolve
=
(
)
=
>
{
flushRendering
(
)
;
if
(
remote
)
{
windowUtils
.
updateLayerTree
(
)
;
}
if
(
windowUtils
.
isMozAfterPaintPending
)
{
logger
.
debug
(
reftestWait
:
{
windowUtils
.
isMozAfterPaintPending
}
)
;
win
.
addEventListener
(
"
MozAfterPaint
"
maybeResolve
{
once
:
true
}
)
;
}
else
{
win
.
requestAnimationFrame
(
(
)
=
>
{
win
.
requestAnimationFrame
(
resolve
)
;
}
)
;
}
}
;
maybeResolve
(
)
;
}
)
;
}
function
reftestWaitRemoved
(
win
root
)
{
logger
.
debug
(
"
Waiting
for
reftest
-
wait
removal
"
)
;
return
new
Promise
(
resolve
=
>
{
let
observer
=
new
win
.
MutationObserver
(
(
)
=
>
{
if
(
!
root
.
classList
.
contains
(
"
reftest
-
wait
"
)
)
{
observer
.
disconnect
(
)
;
logger
.
debug
(
"
reftest
-
wait
removed
"
)
;
win
.
setTimeout
(
resolve
0
)
;
}
}
)
;
if
(
root
.
classList
.
contains
(
"
reftest
-
wait
"
)
)
{
observer
.
observe
(
root
{
attributes
:
true
}
)
;
}
else
{
win
.
setTimeout
(
resolve
0
)
;
}
}
)
;
}
function
domAddEventListener
(
msg
)
{
eventObservers
.
add
(
msg
.
json
.
type
)
;
}
function
domRemoveEventListener
(
msg
)
{
eventObservers
.
remove
(
msg
.
json
.
type
)
;
}
registerSelf
(
)
;
