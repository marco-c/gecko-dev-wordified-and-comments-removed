var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
var
uuidGen
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
var
loader
=
Cc
[
"
mozilla
.
org
/
moz
/
jssubscript
-
loader
;
1
"
]
.
getService
(
Ci
.
mozIJSSubScriptLoader
)
;
loader
.
loadSubScript
(
"
chrome
:
/
/
marionette
/
content
/
simpletest
.
js
"
)
;
loader
.
loadSubScript
(
"
chrome
:
/
/
marionette
/
content
/
common
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
actions
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
atoms
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
capture
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
cookies
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
elements
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
event
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
proxy
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
interactions
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
var
marionetteLogObj
=
new
MarionetteLogObj
(
)
;
var
isB2G
=
false
;
var
marionetteTestName
;
var
winUtil
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
var
listenerId
=
null
;
var
curContainer
=
{
frame
:
content
shadowRoot
:
null
}
;
var
isRemoteBrowser
=
(
)
=
>
curContainer
.
frame
.
contentWindow
!
=
=
null
;
var
previousContainer
=
null
;
var
elementManager
=
new
ElementManager
(
[
]
)
;
var
capabilities
=
{
}
;
var
interactions
=
new
Interactions
(
(
)
=
>
capabilities
)
;
var
actions
=
new
actions
.
Chain
(
checkForInterrupted
)
;
var
importedScripts
=
null
;
var
fileInputElement
;
var
sandboxes
=
{
}
;
var
sandboxName
=
'
default
'
;
var
onunload
;
var
asyncTestRunning
=
false
;
var
asyncTestCommandId
;
var
asyncTestTimeoutId
;
var
inactivityTimeoutId
=
null
;
var
heartbeatCallback
=
function
(
)
{
}
;
var
originalOnError
;
var
checkTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
var
readyStateTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
var
navTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
var
onDOMContentLoaded
;
var
EVENT_INTERVAL
=
30
;
var
multiLast
=
{
}
;
var
chrome
=
proxy
.
toChrome
(
sendSyncMessage
.
bind
(
this
)
)
;
var
cookies
=
new
Cookies
(
(
)
=
>
curContainer
.
frame
.
document
chrome
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
var
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
logger
.
debug
(
"
loaded
listener
.
js
"
)
;
var
modalHandler
=
function
(
)
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
storePrevious
:
true
}
)
;
let
isLocal
=
sendSyncMessage
(
"
MarionetteFrame
:
handleModal
"
{
}
)
[
0
]
.
value
;
if
(
isLocal
)
{
previousContainer
=
curContainer
;
}
curContainer
=
{
frame
:
content
shadowRoot
:
null
}
;
}
;
function
registerSelf
(
)
{
let
msg
=
{
value
:
winUtil
.
outerWindowID
}
;
let
register
=
sendSyncMessage
(
"
Marionette
:
register
"
msg
)
;
if
(
register
[
0
]
)
{
let
{
id
remotenessChange
}
=
register
[
0
]
[
0
]
;
capabilities
=
register
[
0
]
[
2
]
;
isB2G
=
capabilities
.
B2G
;
listenerId
=
id
;
if
(
typeof
id
!
=
"
undefined
"
)
{
if
(
register
[
0
]
[
1
]
=
=
true
)
{
addMessageListener
(
"
MarionetteMainListener
:
emitTouchEvent
"
emitTouchEventForIFrame
)
;
}
importedScripts
=
FileUtils
.
getDir
(
'
TmpD
'
[
]
false
)
;
importedScripts
.
append
(
'
marionetteContentScripts
'
)
;
startListeners
(
)
;
let
rv
=
{
}
;
if
(
remotenessChange
)
{
rv
.
listenerId
=
id
;
}
sendAsyncMessage
(
"
Marionette
:
listenersAttached
"
rv
)
;
}
}
}
function
emitTouchEventForIFrame
(
message
)
{
message
=
message
.
json
;
let
identifier
=
actions
.
nextTouchId
;
let
domWindowUtils
=
curContainer
.
frame
.
QueryInterface
(
Components
.
interfaces
.
nsIInterfaceRequestor
)
.
getInterface
(
Components
.
interfaces
.
nsIDOMWindowUtils
)
;
var
ratio
=
domWindowUtils
.
screenPixelsPerCSSPixel
;
var
typeForUtils
;
switch
(
message
.
type
)
{
case
'
touchstart
'
:
typeForUtils
=
domWindowUtils
.
TOUCH_CONTACT
;
break
;
case
'
touchend
'
:
typeForUtils
=
domWindowUtils
.
TOUCH_REMOVE
;
break
;
case
'
touchcancel
'
:
typeForUtils
=
domWindowUtils
.
TOUCH_CANCEL
;
break
;
case
'
touchmove
'
:
typeForUtils
=
domWindowUtils
.
TOUCH_CONTACT
;
break
;
}
domWindowUtils
.
sendNativeTouchPoint
(
identifier
typeForUtils
Math
.
round
(
message
.
screenX
*
ratio
)
Math
.
round
(
message
.
screenY
*
ratio
)
message
.
force
90
)
;
}
function
dispatch
(
fn
)
{
return
function
(
msg
)
{
let
id
=
msg
.
json
.
command_id
;
let
req
=
Task
.
spawn
(
function
*
(
)
{
if
(
typeof
msg
.
json
=
=
"
undefined
"
|
|
msg
.
json
instanceof
Array
)
{
return
yield
fn
.
apply
(
null
msg
.
json
)
;
}
else
{
return
yield
fn
(
msg
.
json
)
;
}
}
)
;
let
okOrValueResponse
=
rv
=
>
{
if
(
typeof
rv
=
=
"
undefined
"
)
{
sendOk
(
id
)
;
}
else
{
sendResponse
(
rv
id
)
;
}
}
;
req
.
then
(
okOrValueResponse
err
=
>
sendError
(
err
id
)
)
.
catch
(
error
.
report
)
;
}
;
}
function
addMessageListenerId
(
messageName
handler
)
{
addMessageListener
(
messageName
+
listenerId
handler
)
;
}
function
removeMessageListenerId
(
messageName
handler
)
{
removeMessageListener
(
messageName
+
listenerId
handler
)
;
}
var
getTitleFn
=
dispatch
(
getTitle
)
;
var
getPageSourceFn
=
dispatch
(
getPageSource
)
;
var
getActiveElementFn
=
dispatch
(
getActiveElement
)
;
var
clickElementFn
=
dispatch
(
clickElement
)
;
var
goBackFn
=
dispatch
(
goBack
)
;
var
getElementAttributeFn
=
dispatch
(
getElementAttribute
)
;
var
getElementTextFn
=
dispatch
(
getElementText
)
;
var
getElementTagNameFn
=
dispatch
(
getElementTagName
)
;
var
getElementRectFn
=
dispatch
(
getElementRect
)
;
var
isElementEnabledFn
=
dispatch
(
isElementEnabled
)
;
var
getCurrentUrlFn
=
dispatch
(
getCurrentUrl
)
;
var
findElementContentFn
=
dispatch
(
findElementContent
)
;
var
findElementsContentFn
=
dispatch
(
findElementsContent
)
;
var
isElementSelectedFn
=
dispatch
(
isElementSelected
)
;
var
clearElementFn
=
dispatch
(
clearElement
)
;
var
isElementDisplayedFn
=
dispatch
(
isElementDisplayed
)
;
var
getElementValueOfCssPropertyFn
=
dispatch
(
getElementValueOfCssProperty
)
;
var
switchToShadowRootFn
=
dispatch
(
switchToShadowRoot
)
;
var
getCookiesFn
=
dispatch
(
getCookies
)
;
var
singleTapFn
=
dispatch
(
singleTap
)
;
var
takeScreenshotFn
=
dispatch
(
takeScreenshot
)
;
var
actionChainFn
=
dispatch
(
actionChain
)
;
var
multiActionFn
=
dispatch
(
multiAction
)
;
var
addCookieFn
=
dispatch
(
addCookie
)
;
var
deleteCookieFn
=
dispatch
(
deleteCookie
)
;
var
deleteAllCookiesFn
=
dispatch
(
deleteAllCookies
)
;
function
startListeners
(
)
{
addMessageListenerId
(
"
Marionette
:
receiveFiles
"
receiveFiles
)
;
addMessageListenerId
(
"
Marionette
:
newSession
"
newSession
)
;
addMessageListenerId
(
"
Marionette
:
executeScript
"
executeScript
)
;
addMessageListenerId
(
"
Marionette
:
executeAsyncScript
"
executeAsyncScript
)
;
addMessageListenerId
(
"
Marionette
:
executeJSScript
"
executeJSScript
)
;
addMessageListenerId
(
"
Marionette
:
singleTap
"
singleTapFn
)
;
addMessageListenerId
(
"
Marionette
:
actionChain
"
actionChainFn
)
;
addMessageListenerId
(
"
Marionette
:
multiAction
"
multiActionFn
)
;
addMessageListenerId
(
"
Marionette
:
get
"
get
)
;
addMessageListenerId
(
"
Marionette
:
pollForReadyState
"
pollForReadyState
)
;
addMessageListenerId
(
"
Marionette
:
cancelRequest
"
cancelRequest
)
;
addMessageListenerId
(
"
Marionette
:
getCurrentUrl
"
getCurrentUrlFn
)
;
addMessageListenerId
(
"
Marionette
:
getTitle
"
getTitleFn
)
;
addMessageListenerId
(
"
Marionette
:
getPageSource
"
getPageSourceFn
)
;
addMessageListenerId
(
"
Marionette
:
goBack
"
goBackFn
)
;
addMessageListenerId
(
"
Marionette
:
goForward
"
goForward
)
;
addMessageListenerId
(
"
Marionette
:
refresh
"
refresh
)
;
addMessageListenerId
(
"
Marionette
:
findElementContent
"
findElementContentFn
)
;
addMessageListenerId
(
"
Marionette
:
findElementsContent
"
findElementsContentFn
)
;
addMessageListenerId
(
"
Marionette
:
getActiveElement
"
getActiveElementFn
)
;
addMessageListenerId
(
"
Marionette
:
clickElement
"
clickElementFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementAttribute
"
getElementAttributeFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementText
"
getElementTextFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementTagName
"
getElementTagNameFn
)
;
addMessageListenerId
(
"
Marionette
:
isElementDisplayed
"
isElementDisplayedFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementValueOfCssProperty
"
getElementValueOfCssPropertyFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementRect
"
getElementRectFn
)
;
addMessageListenerId
(
"
Marionette
:
isElementEnabled
"
isElementEnabledFn
)
;
addMessageListenerId
(
"
Marionette
:
isElementSelected
"
isElementSelectedFn
)
;
addMessageListenerId
(
"
Marionette
:
sendKeysToElement
"
sendKeysToElement
)
;
addMessageListenerId
(
"
Marionette
:
clearElement
"
clearElementFn
)
;
addMessageListenerId
(
"
Marionette
:
switchToFrame
"
switchToFrame
)
;
addMessageListenerId
(
"
Marionette
:
switchToParentFrame
"
switchToParentFrame
)
;
addMessageListenerId
(
"
Marionette
:
switchToShadowRoot
"
switchToShadowRootFn
)
;
addMessageListenerId
(
"
Marionette
:
deleteSession
"
deleteSession
)
;
addMessageListenerId
(
"
Marionette
:
sleepSession
"
sleepSession
)
;
addMessageListenerId
(
"
Marionette
:
emulatorCmdResult
"
emulatorCmdResult
)
;
addMessageListenerId
(
"
Marionette
:
importScript
"
importScript
)
;
addMessageListenerId
(
"
Marionette
:
getAppCacheStatus
"
getAppCacheStatus
)
;
addMessageListenerId
(
"
Marionette
:
setTestName
"
setTestName
)
;
addMessageListenerId
(
"
Marionette
:
takeScreenshot
"
takeScreenshotFn
)
;
addMessageListenerId
(
"
Marionette
:
addCookie
"
addCookieFn
)
;
addMessageListenerId
(
"
Marionette
:
getCookies
"
getCookiesFn
)
;
addMessageListenerId
(
"
Marionette
:
deleteAllCookies
"
deleteAllCookiesFn
)
;
addMessageListenerId
(
"
Marionette
:
deleteCookie
"
deleteCookieFn
)
;
}
function
waitForReady
(
)
{
if
(
content
.
document
.
readyState
=
=
'
complete
'
)
{
readyStateTimer
.
cancel
(
)
;
content
.
addEventListener
(
"
mozbrowsershowmodalprompt
"
modalHandler
false
)
;
content
.
addEventListener
(
"
unload
"
waitForReady
false
)
;
}
else
{
readyStateTimer
.
initWithCallback
(
waitForReady
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
}
function
newSession
(
msg
)
{
capabilities
=
msg
.
json
;
isB2G
=
capabilities
.
B2G
;
resetValues
(
)
;
if
(
isB2G
)
{
readyStateTimer
.
initWithCallback
(
waitForReady
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
actions
.
inputSource
=
Ci
.
nsIDOMMouseEvent
.
MOZ_SOURCE_TOUCH
;
}
}
function
sleepSession
(
msg
)
{
deleteSession
(
)
;
addMessageListener
(
"
Marionette
:
restart
"
restart
)
;
}
function
restart
(
msg
)
{
removeMessageListener
(
"
Marionette
:
restart
"
restart
)
;
if
(
isB2G
)
{
readyStateTimer
.
initWithCallback
(
waitForReady
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
registerSelf
(
)
;
}
function
deleteSession
(
msg
)
{
removeMessageListenerId
(
"
Marionette
:
receiveFiles
"
receiveFiles
)
;
removeMessageListenerId
(
"
Marionette
:
newSession
"
newSession
)
;
removeMessageListenerId
(
"
Marionette
:
executeScript
"
executeScript
)
;
removeMessageListenerId
(
"
Marionette
:
executeAsyncScript
"
executeAsyncScript
)
;
removeMessageListenerId
(
"
Marionette
:
executeJSScript
"
executeJSScript
)
;
removeMessageListenerId
(
"
Marionette
:
singleTap
"
singleTapFn
)
;
removeMessageListenerId
(
"
Marionette
:
actionChain
"
actionChainFn
)
;
removeMessageListenerId
(
"
Marionette
:
multiAction
"
multiActionFn
)
;
removeMessageListenerId
(
"
Marionette
:
get
"
get
)
;
removeMessageListenerId
(
"
Marionette
:
pollForReadyState
"
pollForReadyState
)
;
removeMessageListenerId
(
"
Marionette
:
cancelRequest
"
cancelRequest
)
;
removeMessageListenerId
(
"
Marionette
:
getTitle
"
getTitleFn
)
;
removeMessageListenerId
(
"
Marionette
:
getPageSource
"
getPageSourceFn
)
;
removeMessageListenerId
(
"
Marionette
:
getCurrentUrl
"
getCurrentUrlFn
)
;
removeMessageListenerId
(
"
Marionette
:
goBack
"
goBackFn
)
;
removeMessageListenerId
(
"
Marionette
:
goForward
"
goForward
)
;
removeMessageListenerId
(
"
Marionette
:
refresh
"
refresh
)
;
removeMessageListenerId
(
"
Marionette
:
findElementContent
"
findElementContentFn
)
;
removeMessageListenerId
(
"
Marionette
:
findElementsContent
"
findElementsContentFn
)
;
removeMessageListenerId
(
"
Marionette
:
getActiveElement
"
getActiveElementFn
)
;
removeMessageListenerId
(
"
Marionette
:
clickElement
"
clickElementFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementAttribute
"
getElementAttributeFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementText
"
getElementTextFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementTagName
"
getElementTagNameFn
)
;
removeMessageListenerId
(
"
Marionette
:
isElementDisplayed
"
isElementDisplayedFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementValueOfCssProperty
"
getElementValueOfCssPropertyFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementRect
"
getElementRectFn
)
;
removeMessageListenerId
(
"
Marionette
:
isElementEnabled
"
isElementEnabledFn
)
;
removeMessageListenerId
(
"
Marionette
:
isElementSelected
"
isElementSelectedFn
)
;
removeMessageListenerId
(
"
Marionette
:
sendKeysToElement
"
sendKeysToElement
)
;
removeMessageListenerId
(
"
Marionette
:
clearElement
"
clearElementFn
)
;
removeMessageListenerId
(
"
Marionette
:
switchToFrame
"
switchToFrame
)
;
removeMessageListenerId
(
"
Marionette
:
switchToParentFrame
"
switchToParentFrame
)
;
removeMessageListenerId
(
"
Marionette
:
switchToShadowRoot
"
switchToShadowRootFn
)
;
removeMessageListenerId
(
"
Marionette
:
deleteSession
"
deleteSession
)
;
removeMessageListenerId
(
"
Marionette
:
sleepSession
"
sleepSession
)
;
removeMessageListenerId
(
"
Marionette
:
emulatorCmdResult
"
emulatorCmdResult
)
;
removeMessageListenerId
(
"
Marionette
:
importScript
"
importScript
)
;
removeMessageListenerId
(
"
Marionette
:
getAppCacheStatus
"
getAppCacheStatus
)
;
removeMessageListenerId
(
"
Marionette
:
setTestName
"
setTestName
)
;
removeMessageListenerId
(
"
Marionette
:
takeScreenshot
"
takeScreenshotFn
)
;
removeMessageListenerId
(
"
Marionette
:
addCookie
"
addCookieFn
)
;
removeMessageListenerId
(
"
Marionette
:
getCookies
"
getCookiesFn
)
;
removeMessageListenerId
(
"
Marionette
:
deleteAllCookies
"
deleteAllCookiesFn
)
;
removeMessageListenerId
(
"
Marionette
:
deleteCookie
"
deleteCookieFn
)
;
if
(
isB2G
)
{
content
.
removeEventListener
(
"
mozbrowsershowmodalprompt
"
modalHandler
false
)
;
}
elementManager
.
reset
(
)
;
curContainer
=
{
frame
:
content
shadowRoot
:
null
}
;
curContainer
.
frame
.
focus
(
)
;
actions
.
touchIds
=
{
}
;
}
function
sendToServer
(
uuid
data
=
undefined
)
{
let
channel
=
new
proxy
.
AsyncMessageChannel
(
(
)
=
>
this
sendAsyncMessage
.
bind
(
this
)
)
;
channel
.
reply
(
uuid
data
)
;
}
function
sendResponse
(
obj
id
)
{
sendToServer
(
id
obj
)
;
}
function
sendOk
(
uuid
)
{
sendToServer
(
uuid
)
;
}
function
sendError
(
err
uuid
)
{
sendToServer
(
uuid
err
)
;
}
function
sendLog
(
msg
)
{
sendToServer
(
"
Marionette
:
log
"
{
message
:
msg
}
)
;
}
function
resetValues
(
)
{
sandboxes
=
{
}
;
curContainer
=
{
frame
:
content
shadowRoot
:
null
}
;
actions
.
mouseEventsOnly
=
false
;
}
function
dumpLog
(
logline
)
{
dump
(
Date
.
now
(
)
+
"
Marionette
:
"
+
logline
)
;
}
function
wasInterrupted
(
)
{
if
(
previousContainer
)
{
let
element
=
content
.
document
.
elementFromPoint
(
(
content
.
innerWidth
/
2
)
(
content
.
innerHeight
/
2
)
)
;
if
(
element
.
id
.
indexOf
(
"
modal
-
dialog
"
)
=
=
-
1
)
{
return
true
;
}
else
{
return
false
;
}
}
return
sendSyncMessage
(
"
MarionetteFrame
:
getInterruptedState
"
{
}
)
[
0
]
.
value
;
}
function
checkForInterrupted
(
)
{
if
(
wasInterrupted
(
)
)
{
if
(
previousContainer
)
{
curContainer
=
actions
.
container
=
previousContainer
;
previousContainer
=
null
;
}
else
{
sendSyncMessage
(
"
Marionette
:
switchToModalOrigin
"
)
;
}
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
restorePrevious
:
true
}
)
;
}
}
function
createExecuteContentSandbox
(
win
timeout
)
{
let
mn
=
new
Marionette
(
win
"
content
"
marionetteLogObj
timeout
heartbeatCallback
marionetteTestName
)
;
let
principal
=
win
;
if
(
sandboxName
=
=
"
system
"
)
{
principal
=
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
;
}
let
sandbox
=
new
Cu
.
Sandbox
(
principal
{
sandboxPrototype
:
win
}
)
;
sandbox
.
global
=
sandbox
;
sandbox
.
window
=
win
;
sandbox
.
document
=
sandbox
.
window
.
document
;
sandbox
.
navigator
=
sandbox
.
window
.
navigator
;
sandbox
.
asyncTestCommandId
=
asyncTestCommandId
;
sandbox
.
marionette
=
mn
;
mn
.
exports
.
forEach
(
fn
=
>
{
if
(
typeof
mn
[
fn
]
=
=
"
function
"
)
{
sandbox
[
fn
]
=
mn
[
fn
]
.
bind
(
mn
)
;
}
else
{
sandbox
[
fn
]
=
mn
[
fn
]
;
}
}
)
;
sandbox
.
runEmulatorCmd
=
(
cmd
cb
)
=
>
this
.
runEmulatorCmd
(
cmd
cb
)
;
sandbox
.
runEmulatorShell
=
(
args
cb
)
=
>
this
.
runEmulatorShell
(
args
cb
)
;
sandbox
.
asyncComplete
=
(
obj
id
)
=
>
{
if
(
id
=
=
asyncTestCommandId
)
{
curContainer
.
frame
.
removeEventListener
(
"
unload
"
onunload
false
)
;
curContainer
.
frame
.
clearTimeout
(
asyncTestTimeoutId
)
;
if
(
inactivityTimeoutId
!
=
null
)
{
curContainer
.
frame
.
clearTimeout
(
inactivityTimeoutId
)
;
}
sendSyncMessage
(
"
Marionette
:
shareData
"
{
log
:
elementManager
.
wrapValue
(
marionetteLogObj
.
getLogs
(
)
)
}
)
;
marionetteLogObj
.
clearLogs
(
)
;
if
(
error
.
isError
(
obj
)
)
{
sendError
(
obj
id
)
;
}
else
{
if
(
Object
.
keys
(
_emu_cbs
)
.
length
)
{
_emu_cbs
=
{
}
;
sendError
(
new
WebDriverError
(
"
Emulator
callback
still
pending
when
finish
(
)
called
"
)
id
)
;
}
else
{
sendResponse
(
elementManager
.
wrapValue
(
obj
)
id
)
;
}
}
asyncTestRunning
=
false
;
asyncTestTimeoutId
=
undefined
;
asyncTestCommandId
=
undefined
;
inactivityTimeoutId
=
null
;
}
}
;
sandbox
.
finish
=
function
(
)
{
if
(
asyncTestRunning
)
{
sandbox
.
asyncComplete
(
mn
.
generate_results
(
)
sandbox
.
asyncTestCommandId
)
;
}
else
{
return
mn
.
generate_results
(
)
;
}
}
;
sandbox
.
marionetteScriptFinished
=
val
=
>
sandbox
.
asyncComplete
(
val
sandbox
.
asyncTestCommandId
)
;
sandboxes
[
sandboxName
]
=
sandbox
;
}
function
executeScript
(
msg
directInject
)
{
if
(
msg
.
json
.
inactivityTimeout
)
{
let
setTimer
=
function
(
)
{
inactivityTimeoutId
=
curContainer
.
frame
.
setTimeout
(
function
(
)
{
sendError
(
new
ScriptTimeoutError
(
"
timed
out
due
to
inactivity
"
)
asyncTestCommandId
)
;
}
msg
.
json
.
inactivityTimeout
)
;
}
;
setTimer
(
)
;
heartbeatCallback
=
function
(
)
{
curContainer
.
frame
.
clearTimeout
(
inactivityTimeoutId
)
;
setTimer
(
)
;
}
;
}
asyncTestCommandId
=
msg
.
json
.
command_id
;
let
script
=
msg
.
json
.
script
;
let
filename
=
msg
.
json
.
filename
;
sandboxName
=
msg
.
json
.
sandboxName
;
if
(
msg
.
json
.
newSandbox
|
|
!
(
sandboxName
in
sandboxes
)
|
|
(
sandboxes
[
sandboxName
]
.
window
!
=
curContainer
.
frame
)
)
{
createExecuteContentSandbox
(
curContainer
.
frame
msg
.
json
.
timeout
)
;
if
(
!
sandboxes
[
sandboxName
]
)
{
sendError
(
new
WebDriverError
(
"
Could
not
create
sandbox
!
"
)
asyncTestCommandId
)
;
return
;
}
}
else
{
sandboxes
[
sandboxName
]
.
asyncTestCommandId
=
asyncTestCommandId
;
}
let
sandbox
=
sandboxes
[
sandboxName
]
;
try
{
if
(
directInject
)
{
if
(
importedScripts
.
exists
(
)
)
{
let
stream
=
Components
.
classes
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIFileInputStream
)
;
stream
.
init
(
importedScripts
-
1
0
0
)
;
let
data
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
stream
.
close
(
)
;
script
=
data
+
script
;
}
let
res
=
Cu
.
evalInSandbox
(
script
sandbox
"
1
.
8
"
filename
?
filename
:
"
dummy
file
"
0
)
;
sendSyncMessage
(
"
Marionette
:
shareData
"
{
log
:
elementManager
.
wrapValue
(
marionetteLogObj
.
getLogs
(
)
)
}
)
;
marionetteLogObj
.
clearLogs
(
)
;
if
(
res
=
=
undefined
|
|
res
.
passed
=
=
undefined
)
{
sendError
(
new
JavaScriptError
(
"
Marionette
.
finish
(
)
not
called
"
)
asyncTestCommandId
)
;
}
else
{
sendResponse
(
elementManager
.
wrapValue
(
res
)
asyncTestCommandId
)
;
}
}
else
{
try
{
sandbox
.
__marionetteParams
=
Cu
.
cloneInto
(
elementManager
.
convertWrappedArguments
(
msg
.
json
.
args
curContainer
)
sandbox
{
wrapReflectors
:
true
}
)
;
}
catch
(
e
)
{
sendError
(
e
asyncTestCommandId
)
;
return
;
}
script
=
"
var
__marionetteFunc
=
function
(
)
{
"
+
script
+
"
}
;
"
+
"
__marionetteFunc
.
apply
(
null
__marionetteParams
)
;
"
;
if
(
importedScripts
.
exists
(
)
)
{
let
stream
=
Components
.
classes
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIFileInputStream
)
;
stream
.
init
(
importedScripts
-
1
0
0
)
;
let
data
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
stream
.
close
(
)
;
script
=
data
+
script
;
}
let
res
=
Cu
.
evalInSandbox
(
script
sandbox
"
1
.
8
"
filename
?
filename
:
"
dummy
file
"
0
)
;
sendSyncMessage
(
"
Marionette
:
shareData
"
{
log
:
elementManager
.
wrapValue
(
marionetteLogObj
.
getLogs
(
)
)
}
)
;
marionetteLogObj
.
clearLogs
(
)
;
sendResponse
(
elementManager
.
wrapValue
(
res
)
asyncTestCommandId
)
;
}
}
catch
(
e
)
{
let
err
=
new
JavaScriptError
(
e
"
execute_script
"
msg
.
json
.
filename
msg
.
json
.
line
script
)
;
sendError
(
err
asyncTestCommandId
)
;
}
}
function
setTestName
(
msg
)
{
marionetteTestName
=
msg
.
json
.
value
;
sendOk
(
msg
.
json
.
command_id
)
;
}
function
executeAsyncScript
(
msg
)
{
executeWithCallback
(
msg
)
;
}
function
receiveFiles
(
msg
)
{
if
(
'
error
'
in
msg
.
json
)
{
let
err
=
new
InvalidArgumentError
(
msg
.
json
.
error
)
;
sendError
(
err
msg
.
json
.
command_id
)
;
return
;
}
if
(
!
fileInputElement
)
{
let
err
=
new
InvalidElementStateError
(
"
receiveFiles
called
with
no
valid
fileInputElement
"
)
;
sendError
(
err
msg
.
json
.
command_id
)
;
return
;
}
let
fs
=
Array
.
prototype
.
slice
.
call
(
fileInputElement
.
files
)
;
fs
.
push
(
msg
.
json
.
file
)
;
fileInputElement
.
mozSetFileArray
(
fs
)
;
fileInputElement
=
null
;
sendOk
(
msg
.
json
.
command_id
)
;
}
function
executeJSScript
(
msg
)
{
if
(
msg
.
json
.
async
)
{
executeWithCallback
(
msg
msg
.
json
.
async
)
;
}
else
{
executeScript
(
msg
true
)
;
}
}
function
executeWithCallback
(
msg
useFinish
)
{
if
(
msg
.
json
.
inactivityTimeout
)
{
let
setTimer
=
function
(
)
{
inactivityTimeoutId
=
curContainer
.
frame
.
setTimeout
(
function
(
)
{
sandbox
.
asyncComplete
(
new
ScriptTimeoutError
(
"
timed
out
due
to
inactivity
"
)
asyncTestCommandId
)
;
}
msg
.
json
.
inactivityTimeout
)
;
}
;
setTimer
(
)
;
heartbeatCallback
=
function
(
)
{
curContainer
.
frame
.
clearTimeout
(
inactivityTimeoutId
)
;
setTimer
(
)
;
}
;
}
let
script
=
msg
.
json
.
script
;
let
filename
=
msg
.
json
.
filename
;
asyncTestCommandId
=
msg
.
json
.
command_id
;
sandboxName
=
msg
.
json
.
sandboxName
;
onunload
=
function
(
)
{
sendError
(
new
JavaScriptError
(
"
unload
was
called
"
)
asyncTestCommandId
)
;
}
;
curContainer
.
frame
.
addEventListener
(
"
unload
"
onunload
false
)
;
if
(
msg
.
json
.
newSandbox
|
|
!
(
sandboxName
in
sandboxes
)
|
|
(
sandboxes
[
sandboxName
]
.
window
!
=
curContainer
.
frame
)
)
{
createExecuteContentSandbox
(
curContainer
.
frame
msg
.
json
.
timeout
)
;
if
(
!
sandboxes
[
sandboxName
]
)
{
sendError
(
new
JavaScriptError
(
"
Could
not
create
sandbox
!
"
)
asyncTestCommandId
)
;
return
;
}
}
else
{
sandboxes
[
sandboxName
]
.
asyncTestCommandId
=
asyncTestCommandId
;
}
let
sandbox
=
sandboxes
[
sandboxName
]
;
sandbox
.
tag
=
script
;
asyncTestTimeoutId
=
curContainer
.
frame
.
setTimeout
(
function
(
)
{
sandbox
.
asyncComplete
(
new
ScriptTimeoutError
(
"
timed
out
"
)
asyncTestCommandId
)
;
}
msg
.
json
.
timeout
)
;
originalOnError
=
curContainer
.
frame
.
onerror
;
curContainer
.
frame
.
onerror
=
function
errHandler
(
msg
url
line
)
{
sandbox
.
asyncComplete
(
new
JavaScriptError
(
msg
+
"
"
+
url
+
"
line
"
+
line
)
asyncTestCommandId
)
;
curContainer
.
frame
.
onerror
=
originalOnError
;
}
;
let
scriptSrc
;
if
(
useFinish
)
{
if
(
msg
.
json
.
timeout
=
=
null
|
|
msg
.
json
.
timeout
=
=
0
)
{
sendError
(
new
TimeoutError
(
"
Please
set
a
timeout
"
)
asyncTestCommandId
)
;
}
scriptSrc
=
script
;
}
else
{
try
{
sandbox
.
__marionetteParams
=
Cu
.
cloneInto
(
elementManager
.
convertWrappedArguments
(
msg
.
json
.
args
curContainer
)
sandbox
{
wrapReflectors
:
true
}
)
;
}
catch
(
e
)
{
sendError
(
e
asyncTestCommandId
)
;
return
;
}
scriptSrc
=
"
__marionetteParams
.
push
(
marionetteScriptFinished
)
;
"
+
"
var
__marionetteFunc
=
function
(
)
{
"
+
script
+
"
}
;
"
+
"
__marionetteFunc
.
apply
(
null
__marionetteParams
)
;
"
;
}
try
{
asyncTestRunning
=
true
;
if
(
importedScripts
.
exists
(
)
)
{
let
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
stream
.
init
(
importedScripts
-
1
0
0
)
;
let
data
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
stream
.
close
(
)
;
scriptSrc
=
data
+
scriptSrc
;
}
Cu
.
evalInSandbox
(
scriptSrc
sandbox
"
1
.
8
"
filename
?
filename
:
"
dummy
file
"
0
)
;
}
catch
(
e
)
{
let
err
=
new
JavaScriptError
(
e
"
execute_async_script
"
msg
.
json
.
filename
msg
.
json
.
line
scriptSrc
)
;
sandbox
.
asyncComplete
(
err
asyncTestCommandId
)
;
}
}
function
emitTouchEvent
(
type
touch
)
{
if
(
!
wasInterrupted
(
)
)
{
let
loggingInfo
=
"
emitting
Touch
event
of
type
"
+
type
+
"
to
element
with
id
:
"
+
touch
.
target
.
id
+
"
and
tag
name
:
"
+
touch
.
target
.
tagName
+
"
at
coordinates
(
"
+
touch
.
clientX
+
"
"
+
touch
.
clientY
+
"
)
relative
to
the
viewport
"
;
dumpLog
(
loggingInfo
)
;
var
docShell
=
curContainer
.
frame
.
document
.
defaultView
.
QueryInterface
(
Components
.
interfaces
.
nsIInterfaceRequestor
)
.
getInterface
(
Components
.
interfaces
.
nsIWebNavigation
)
.
QueryInterface
(
Components
.
interfaces
.
nsIDocShell
)
;
if
(
docShell
.
asyncPanZoomEnabled
&
&
actions
.
scrolling
)
{
let
index
=
sendSyncMessage
(
"
MarionetteFrame
:
getCurrentFrameId
"
)
;
if
(
index
!
=
null
)
{
sendSyncMessage
(
"
Marionette
:
emitTouchEvent
"
{
index
:
index
type
:
type
id
:
touch
.
identifier
clientX
:
touch
.
clientX
clientY
:
touch
.
clientY
screenX
:
touch
.
screenX
screenY
:
touch
.
screenY
radiusX
:
touch
.
radiusX
radiusY
:
touch
.
radiusY
rotation
:
touch
.
rotationAngle
force
:
touch
.
force
}
)
;
return
;
}
}
let
domWindowUtils
=
curContainer
.
frame
.
QueryInterface
(
Components
.
interfaces
.
nsIInterfaceRequestor
)
.
getInterface
(
Components
.
interfaces
.
nsIDOMWindowUtils
)
;
domWindowUtils
.
sendTouchEvent
(
type
[
touch
.
identifier
]
[
touch
.
clientX
]
[
touch
.
clientY
]
[
touch
.
radiusX
]
[
touch
.
radiusY
]
[
touch
.
rotationAngle
]
[
touch
.
force
]
1
0
)
;
}
}
function
coordinates
(
target
x
y
)
{
let
box
=
target
.
getBoundingClientRect
(
)
;
if
(
x
=
=
null
)
{
x
=
box
.
width
/
2
;
}
if
(
y
=
=
null
)
{
y
=
box
.
height
/
2
;
}
let
coords
=
{
}
;
coords
.
x
=
box
.
left
+
x
;
coords
.
y
=
box
.
top
+
y
;
return
coords
;
}
function
singleTap
(
id
corx
cory
)
{
let
el
=
elementManager
.
getKnownElement
(
id
curContainer
)
;
let
visible
=
elements
.
checkVisible
(
el
curContainer
.
frame
corx
cory
)
;
if
(
!
visible
)
{
throw
new
ElementNotVisibleError
(
"
Element
is
not
currently
visible
and
may
not
be
manipulated
"
)
;
}
return
interactions
.
accessibility
.
getAccessibleObject
(
el
true
)
.
then
(
acc
=
>
{
interactions
.
accessibility
.
checkVisible
(
acc
el
visible
)
;
interactions
.
accessibility
.
checkActionable
(
acc
el
)
;
if
(
!
curContainer
.
frame
.
document
.
createTouch
)
{
actions
.
mouseEventsOnly
=
true
;
}
let
c
=
coordinates
(
el
corx
cory
)
;
if
(
!
actions
.
mouseEventsOnly
)
{
let
touchId
=
actions
.
nextTouchId
+
+
;
let
touch
=
createATouch
(
el
c
.
x
c
.
y
touchId
)
;
emitTouchEvent
(
'
touchstart
'
touch
)
;
emitTouchEvent
(
'
touchend
'
touch
)
;
}
actions
.
mouseTap
(
el
.
ownerDocument
c
.
x
c
.
y
)
;
}
)
;
}
function
createATouch
(
el
corx
cory
touchId
)
{
let
doc
=
el
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
[
clientX
clientY
pageX
pageY
screenX
screenY
]
=
actions
.
getCoordinateInfo
(
el
corx
cory
)
;
let
atouch
=
doc
.
createTouch
(
win
el
touchId
pageX
pageY
screenX
screenY
clientX
clientY
)
;
return
atouch
;
}
function
actionChain
(
chain
touchId
)
{
let
touchProvider
=
{
}
;
touchProvider
.
createATouch
=
createATouch
;
touchProvider
.
emitTouchEvent
=
emitTouchEvent
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
actions
.
dispatchActions
(
chain
touchId
curContainer
elementManager
{
onSuccess
:
resolve
onError
:
reject
}
touchProvider
)
;
}
)
;
}
function
emitMultiEvents
(
type
touch
touches
)
{
let
target
=
touch
.
target
;
let
doc
=
target
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
documentTouches
=
doc
.
createTouchList
(
touches
.
filter
(
function
(
t
)
{
return
(
(
t
.
target
.
ownerDocument
=
=
=
doc
)
&
&
(
type
!
=
'
touchcancel
'
)
)
;
}
)
)
;
let
targetTouches
=
doc
.
createTouchList
(
touches
.
filter
(
function
(
t
)
{
return
(
(
t
.
target
=
=
=
target
)
&
&
(
(
type
!
=
'
touchcancel
'
)
|
|
(
type
!
=
'
touchend
'
)
)
)
;
}
)
)
;
let
changedTouches
=
doc
.
createTouchList
(
touch
)
;
let
event
=
doc
.
createEvent
(
'
TouchEvent
'
)
;
event
.
initTouchEvent
(
type
true
true
win
0
false
false
false
false
documentTouches
targetTouches
changedTouches
)
;
target
.
dispatchEvent
(
event
)
;
}
function
setDispatch
(
batches
touches
batchIndex
=
0
)
{
if
(
batchIndex
>
=
batches
.
length
)
{
multiLast
=
{
}
;
return
;
}
let
batch
=
batches
[
batchIndex
]
;
let
pack
;
let
touchId
;
let
command
;
let
el
;
let
corx
;
let
cory
;
let
touch
;
let
lastTouch
;
let
touchIndex
;
let
waitTime
=
0
;
let
maxTime
=
0
;
let
c
;
batchIndex
+
+
;
for
(
let
i
=
0
;
i
<
batch
.
length
;
i
+
+
)
{
pack
=
batch
[
i
]
;
touchId
=
pack
[
0
]
;
command
=
pack
[
1
]
;
switch
(
command
)
{
case
"
press
"
:
el
=
elementManager
.
getKnownElement
(
pack
[
2
]
curContainer
)
;
c
=
coordinates
(
el
pack
[
3
]
pack
[
4
]
)
;
touch
=
createATouch
(
el
c
.
x
c
.
y
touchId
)
;
multiLast
[
touchId
]
=
touch
;
touches
.
push
(
touch
)
;
emitMultiEvents
(
"
touchstart
"
touch
touches
)
;
break
;
case
"
release
"
:
touch
=
multiLast
[
touchId
]
;
touchIndex
=
touches
.
indexOf
(
touch
)
;
touches
.
splice
(
touchIndex
1
)
;
emitMultiEvents
(
"
touchend
"
touch
touches
)
;
break
;
case
"
move
"
:
el
=
elementManager
.
getKnownElement
(
pack
[
2
]
curContainer
)
;
c
=
coordinates
(
el
)
;
touch
=
createATouch
(
multiLast
[
touchId
]
.
target
c
.
x
c
.
y
touchId
)
;
touchIndex
=
touches
.
indexOf
(
lastTouch
)
;
touches
[
touchIndex
]
=
touch
;
multiLast
[
touchId
]
=
touch
;
emitMultiEvents
(
"
touchmove
"
touch
touches
)
;
break
;
case
"
moveByOffset
"
:
el
=
multiLast
[
touchId
]
.
target
;
lastTouch
=
multiLast
[
touchId
]
;
touchIndex
=
touches
.
indexOf
(
lastTouch
)
;
let
doc
=
el
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
clientX
=
lastTouch
.
clientX
+
pack
[
2
]
clientY
=
lastTouch
.
clientY
+
pack
[
3
]
;
let
pageX
=
clientX
+
win
.
pageXOffset
pageY
=
clientY
+
win
.
pageYOffset
;
let
screenX
=
clientX
+
win
.
mozInnerScreenX
screenY
=
clientY
+
win
.
mozInnerScreenY
;
touch
=
doc
.
createTouch
(
win
el
touchId
pageX
pageY
screenX
screenY
clientX
clientY
)
;
touches
[
touchIndex
]
=
touch
;
multiLast
[
touchId
]
=
touch
;
emitMultiEvents
(
"
touchmove
"
touch
touches
)
;
break
;
case
"
wait
"
:
if
(
typeof
pack
[
2
]
!
=
"
undefined
"
)
{
waitTime
=
pack
[
2
]
*
1000
;
if
(
waitTime
>
maxTime
)
{
maxTime
=
waitTime
;
}
}
break
;
}
}
if
(
maxTime
!
=
0
)
{
checkTimer
.
initWithCallback
(
function
(
)
{
setDispatch
(
batches
touches
batchIndex
)
;
}
maxTime
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
{
setDispatch
(
batches
touches
batchIndex
)
;
}
}
function
multiAction
(
args
maxLen
)
{
let
commandArray
=
elementManager
.
convertWrappedArguments
(
args
curContainer
)
;
let
concurrentEvent
=
[
]
;
let
temp
;
for
(
let
i
=
0
;
i
<
maxLen
;
i
+
+
)
{
let
row
=
[
]
;
for
(
let
j
=
0
;
j
<
commandArray
.
length
;
j
+
+
)
{
if
(
typeof
commandArray
[
j
]
[
i
]
!
=
"
undefined
"
)
{
temp
=
commandArray
[
j
]
[
i
]
;
temp
.
unshift
(
j
)
;
row
.
push
(
temp
)
;
}
}
concurrentEvent
.
push
(
row
)
;
}
let
pendingTouches
=
[
]
;
setDispatch
(
concurrentEvent
pendingTouches
)
;
}
function
pollForReadyState
(
msg
start
callback
)
{
let
{
pageTimeout
url
command_id
}
=
msg
.
json
;
start
=
start
?
start
:
new
Date
(
)
.
getTime
(
)
;
if
(
!
callback
)
{
callback
=
(
)
=
>
{
}
;
}
let
end
=
null
;
function
checkLoad
(
)
{
navTimer
.
cancel
(
)
;
end
=
new
Date
(
)
.
getTime
(
)
;
let
aboutErrorRegex
=
/
about
:
.
+
(
error
)
\
?
/
;
let
elapse
=
end
-
start
;
let
doc
=
curContainer
.
frame
.
document
;
if
(
pageTimeout
=
=
null
|
|
elapse
<
=
pageTimeout
)
{
if
(
doc
.
readyState
=
=
"
complete
"
)
{
callback
(
)
;
sendOk
(
command_id
)
;
}
else
if
(
doc
.
readyState
=
=
"
interactive
"
&
&
aboutErrorRegex
.
exec
(
doc
.
baseURI
)
&
&
!
doc
.
baseURI
.
startsWith
(
url
)
)
{
callback
(
)
;
sendError
(
new
UnknownError
(
"
Error
loading
page
"
)
command_id
)
;
}
else
if
(
doc
.
readyState
=
=
"
interactive
"
&
&
doc
.
baseURI
.
startsWith
(
"
about
:
"
)
)
{
callback
(
)
;
sendOk
(
command_id
)
;
}
else
{
navTimer
.
initWithCallback
(
checkLoad
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
}
else
{
callback
(
)
;
sendError
(
new
TimeoutError
(
"
Error
loading
page
timed
out
(
checkLoad
)
"
)
command_id
)
;
}
}
checkLoad
(
)
;
}
function
get
(
msg
)
{
let
start
=
new
Date
(
)
.
getTime
(
)
;
onDOMContentLoaded
=
function
onDOMContentLoaded
(
event
)
{
if
(
!
event
.
originalTarget
.
defaultView
.
frameElement
|
|
event
.
originalTarget
.
defaultView
.
frameElement
=
=
curContainer
.
frame
.
frameElement
)
{
pollForReadyState
(
msg
start
(
)
=
>
{
removeEventListener
(
"
DOMContentLoaded
"
onDOMContentLoaded
false
)
;
onDOMContentLoaded
=
null
;
}
)
;
}
}
;
function
timerFunc
(
)
{
removeEventListener
(
"
DOMContentLoaded
"
onDOMContentLoaded
false
)
;
sendError
(
new
TimeoutError
(
"
Error
loading
page
timed
out
(
onDOMContentLoaded
)
"
)
msg
.
json
.
command_id
)
;
}
if
(
msg
.
json
.
pageTimeout
!
=
null
)
{
navTimer
.
initWithCallback
(
timerFunc
msg
.
json
.
pageTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
addEventListener
(
"
DOMContentLoaded
"
onDOMContentLoaded
false
)
;
if
(
isB2G
)
{
curContainer
.
frame
.
location
=
msg
.
json
.
url
;
}
else
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
curContainer
.
frame
.
location
=
msg
.
json
.
url
;
}
}
function
cancelRequest
(
)
{
navTimer
.
cancel
(
)
;
if
(
onDOMContentLoaded
)
{
removeEventListener
(
"
DOMContentLoaded
"
onDOMContentLoaded
false
)
;
}
}
function
getCurrentUrl
(
isB2G
)
{
if
(
isB2G
)
{
return
curContainer
.
frame
.
location
.
href
;
}
else
{
return
content
.
location
.
href
;
}
}
function
getTitle
(
)
{
return
curContainer
.
frame
.
top
.
document
.
title
;
}
function
getPageSource
(
)
{
let
XMLSerializer
=
curContainer
.
frame
.
XMLSerializer
;
let
source
=
new
XMLSerializer
(
)
.
serializeToString
(
curContainer
.
frame
.
document
)
;
return
source
;
}
function
goBack
(
)
{
curContainer
.
frame
.
history
.
back
(
)
;
}
function
goForward
(
msg
)
{
curContainer
.
frame
.
history
.
forward
(
)
;
sendOk
(
msg
.
json
.
command_id
)
;
}
function
refresh
(
msg
)
{
let
command_id
=
msg
.
json
.
command_id
;
curContainer
.
frame
.
location
.
reload
(
true
)
;
let
listen
=
function
(
)
{
removeEventListener
(
"
DOMContentLoaded
"
arguments
.
callee
false
)
;
sendOk
(
command_id
)
;
}
;
addEventListener
(
"
DOMContentLoaded
"
listen
false
)
;
}
function
findElementContent
(
opts
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
elementManager
.
find
(
curContainer
opts
opts
.
searchTimeout
false
resolve
reject
)
;
}
)
;
}
function
findElementsContent
(
opts
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
elementManager
.
find
(
curContainer
opts
opts
.
searchTimeout
true
resolve
reject
)
;
}
)
;
}
function
getActiveElement
(
)
{
let
el
=
curContainer
.
frame
.
document
.
activeElement
;
return
elementManager
.
addToKnownElements
(
el
)
;
}
function
clickElement
(
id
)
{
return
interactions
.
clickElement
(
curContainer
elementManager
id
)
;
}
function
getElementAttribute
(
id
name
)
{
let
el
=
elementManager
.
getKnownElement
(
id
curContainer
)
;
return
atom
.
getElementAttribute
(
el
name
curContainer
.
frame
)
;
}
function
getElementText
(
id
)
{
let
el
=
elementManager
.
getKnownElement
(
id
curContainer
)
;
return
atom
.
getElementText
(
el
curContainer
.
frame
)
;
}
function
getElementTagName
(
id
)
{
let
el
=
elementManager
.
getKnownElement
(
id
curContainer
)
;
return
el
.
tagName
.
toLowerCase
(
)
;
}
function
isElementDisplayed
(
id
)
{
return
interactions
.
isElementDisplayed
(
curContainer
elementManager
id
)
;
}
function
getElementValueOfCssProperty
(
id
prop
)
{
let
el
=
elementManager
.
getKnownElement
(
id
curContainer
)
;
let
st
=
curContainer
.
frame
.
document
.
defaultView
.
getComputedStyle
(
el
null
)
;
return
st
.
getPropertyValue
(
prop
)
;
}
function
getElementRect
(
id
)
{
let
el
=
elementManager
.
getKnownElement
(
id
curContainer
)
;
let
clientRect
=
el
.
getBoundingClientRect
(
)
;
return
{
x
:
clientRect
.
x
+
curContainer
.
frame
.
pageXOffset
y
:
clientRect
.
y
+
curContainer
.
frame
.
pageYOffset
width
:
clientRect
.
width
height
:
clientRect
.
height
}
;
}
function
isElementEnabled
(
id
)
{
return
interactions
.
isElementEnabled
(
curContainer
elementManager
id
)
;
}
function
isElementSelected
(
id
)
{
return
interactions
.
isElementSelected
(
curContainer
elementManager
id
)
;
}
function
sendKeysToElement
(
msg
)
{
let
command_id
=
msg
.
json
.
command_id
;
let
val
=
msg
.
json
.
value
;
let
id
=
msg
.
json
.
id
;
let
el
=
elementManager
.
getKnownElement
(
id
curContainer
)
;
if
(
el
.
type
=
=
"
file
"
)
{
let
p
=
val
.
join
(
"
"
)
;
fileInputElement
=
el
;
sendSyncMessage
(
"
Marionette
:
getFiles
"
{
value
:
p
command_id
:
command_id
}
)
;
}
else
{
interactions
.
sendKeysToElement
(
curContainer
elementManager
id
val
)
.
then
(
(
)
=
>
sendOk
(
command_id
)
)
.
catch
(
e
=
>
sendError
(
e
command_id
)
)
;
}
}
function
clearElement
(
id
)
{
try
{
let
el
=
elementManager
.
getKnownElement
(
id
curContainer
)
;
if
(
el
.
type
=
=
"
file
"
)
{
el
.
value
=
null
;
}
else
{
atom
.
clearElement
(
el
curContainer
.
frame
)
;
}
}
catch
(
e
)
{
if
(
e
.
name
=
=
"
InvalidElementStateError
"
)
{
throw
new
InvalidElementStateError
(
e
.
message
)
;
}
else
{
throw
e
;
}
}
}
function
switchToShadowRoot
(
id
)
{
if
(
!
id
)
{
if
(
curContainer
.
shadowRoot
)
{
let
parent
;
try
{
parent
=
curContainer
.
shadowRoot
.
host
;
}
catch
(
e
)
{
curContainer
.
shadowRoot
=
null
;
return
;
}
while
(
parent
&
&
!
(
parent
instanceof
curContainer
.
frame
.
ShadowRoot
)
)
{
parent
=
parent
.
parentNode
;
}
curContainer
.
shadowRoot
=
parent
;
}
return
;
}
let
foundShadowRoot
;
let
hostEl
=
elementManager
.
getKnownElement
(
id
curContainer
)
;
foundShadowRoot
=
hostEl
.
shadowRoot
;
if
(
!
foundShadowRoot
)
{
throw
new
NoSuchElementError
(
'
Unable
to
locate
shadow
root
:
'
+
id
)
;
}
curContainer
.
shadowRoot
=
foundShadowRoot
;
}
function
switchToParentFrame
(
msg
)
{
let
command_id
=
msg
.
json
.
command_id
;
curContainer
.
frame
=
curContainer
.
frame
.
parent
;
let
parentElement
=
elementManager
.
addToKnownElements
(
curContainer
.
frame
)
;
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
parentElement
}
)
;
sendOk
(
msg
.
json
.
command_id
)
;
}
function
switchToFrame
(
msg
)
{
let
command_id
=
msg
.
json
.
command_id
;
function
checkLoad
(
)
{
let
errorRegex
=
/
about
:
.
+
(
error
)
|
(
blocked
)
\
?
/
;
if
(
curContainer
.
frame
.
document
.
readyState
=
=
"
complete
"
)
{
sendOk
(
command_id
)
;
return
;
}
else
if
(
curContainer
.
frame
.
document
.
readyState
=
=
"
interactive
"
&
&
errorRegex
.
exec
(
curContainer
.
frame
.
document
.
baseURI
)
)
{
sendError
(
new
UnknownError
(
"
Error
loading
page
"
)
command_id
)
;
return
;
}
checkTimer
.
initWithCallback
(
checkLoad
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
let
foundFrame
=
null
;
let
frames
=
[
]
;
let
parWindow
=
null
;
try
{
frames
=
curContainer
.
frame
.
frames
;
parWindow
=
curContainer
.
frame
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
}
catch
(
e
)
{
msg
.
json
.
id
=
null
;
msg
.
json
.
element
=
null
;
}
if
(
(
msg
.
json
.
id
=
=
=
null
|
|
msg
.
json
.
id
=
=
=
undefined
)
&
&
(
msg
.
json
.
element
=
=
null
)
)
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
if
(
msg
.
json
.
focus
=
=
true
)
{
curContainer
.
frame
.
focus
(
)
;
}
checkTimer
.
initWithCallback
(
checkLoad
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
return
;
}
if
(
msg
.
json
.
element
!
=
undefined
)
{
if
(
elementManager
.
seenItems
[
msg
.
json
.
element
]
!
=
undefined
)
{
let
wantedFrame
;
try
{
wantedFrame
=
elementManager
.
getKnownElement
(
msg
.
json
.
element
curContainer
)
;
}
catch
(
e
)
{
sendError
(
e
command_id
)
;
}
if
(
frames
.
length
>
0
)
{
for
(
let
i
=
0
;
i
<
frames
.
length
;
i
+
+
)
{
if
(
XPCNativeWrapper
(
frames
[
i
]
.
frameElement
)
=
=
XPCNativeWrapper
(
wantedFrame
)
)
{
curContainer
.
frame
=
frames
[
i
]
.
frameElement
;
foundFrame
=
i
;
}
}
}
if
(
foundFrame
=
=
=
null
)
{
let
iframes
=
curContainer
.
frame
.
document
.
getElementsByTagName
(
"
iframe
"
)
;
for
(
var
i
=
0
;
i
<
iframes
.
length
;
i
+
+
)
{
if
(
XPCNativeWrapper
(
iframes
[
i
]
)
=
=
XPCNativeWrapper
(
wantedFrame
)
)
{
curContainer
.
frame
=
iframes
[
i
]
;
foundFrame
=
i
;
}
}
}
}
}
if
(
foundFrame
=
=
=
null
)
{
if
(
typeof
(
msg
.
json
.
id
)
=
=
=
'
number
'
)
{
try
{
foundFrame
=
frames
[
msg
.
json
.
id
]
.
frameElement
;
if
(
foundFrame
!
=
=
null
)
{
curContainer
.
frame
=
foundFrame
;
foundFrame
=
elementManager
.
addToKnownElements
(
curContainer
.
frame
)
;
}
else
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
if
(
msg
.
json
.
focus
=
=
true
)
{
curContainer
.
frame
.
focus
(
)
;
}
checkTimer
.
initWithCallback
(
checkLoad
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
return
;
}
}
catch
(
e
)
{
let
iframes
=
curContainer
.
frame
.
document
.
getElementsByTagName
(
"
iframe
"
)
;
if
(
msg
.
json
.
id
>
=
0
&
&
msg
.
json
.
id
<
iframes
.
length
)
{
curContainer
.
frame
=
iframes
[
msg
.
json
.
id
]
;
foundFrame
=
msg
.
json
.
id
;
}
}
}
}
if
(
foundFrame
=
=
=
null
)
{
sendError
(
new
NoSuchFrameError
(
"
Unable
to
locate
frame
:
"
+
(
msg
.
json
.
id
|
|
msg
.
json
.
element
)
)
command_id
)
;
return
true
;
}
let
frameValue
=
elementManager
.
wrapValue
(
curContainer
.
frame
.
wrappedJSObject
)
[
'
ELEMENT
'
]
;
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
frameValue
}
)
;
let
rv
=
null
;
if
(
curContainer
.
frame
.
contentWindow
=
=
=
null
)
{
curContainer
.
frame
=
content
;
rv
=
{
win
:
parWindow
frame
:
foundFrame
}
;
}
else
{
curContainer
.
frame
=
curContainer
.
frame
.
contentWindow
;
if
(
msg
.
json
.
focus
)
curContainer
.
frame
.
focus
(
)
;
checkTimer
.
initWithCallback
(
checkLoad
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
sendResponse
(
rv
command_id
)
;
}
function
addCookie
(
cookie
)
{
cookies
.
add
(
cookie
.
name
cookie
.
value
cookie
)
;
}
function
getCookies
(
)
{
let
rv
=
[
]
;
for
(
let
cookie
of
cookies
)
{
let
expires
=
cookie
.
expires
;
if
(
expires
=
=
0
)
{
expires
=
null
;
}
else
if
(
expires
=
=
1
)
{
expires
=
0
;
}
rv
.
push
(
{
'
name
'
:
cookie
.
name
'
value
'
:
cookie
.
value
'
path
'
:
cookie
.
path
'
domain
'
:
cookie
.
host
'
secure
'
:
cookie
.
isSecure
'
httpOnly
'
:
cookie
.
httpOnly
'
expiry
'
:
expires
}
)
;
}
return
rv
;
}
function
deleteCookie
(
name
)
{
cookies
.
delete
(
name
)
;
}
function
deleteAllCookies
(
)
{
for
(
let
cookie
of
cookies
)
{
cookies
.
delete
(
cookie
)
;
}
}
function
getAppCacheStatus
(
msg
)
{
sendResponse
(
curContainer
.
frame
.
applicationCache
.
status
msg
.
json
.
command_id
)
;
}
var
_emu_cb_id
=
0
;
var
_emu_cbs
=
{
}
;
function
runEmulatorCmd
(
cmd
callback
)
{
if
(
callback
)
{
_emu_cbs
[
_emu_cb_id
]
=
callback
;
}
sendAsyncMessage
(
"
Marionette
:
runEmulatorCmd
"
{
command
:
cmd
id
:
_emu_cb_id
}
)
;
_emu_cb_id
+
=
1
;
}
function
runEmulatorShell
(
args
callback
)
{
if
(
callback
)
{
_emu_cbs
[
_emu_cb_id
]
=
callback
;
}
sendAsyncMessage
(
"
Marionette
:
runEmulatorShell
"
{
arguments
:
args
id
:
_emu_cb_id
}
)
;
_emu_cb_id
+
=
1
;
}
function
emulatorCmdResult
(
msg
)
{
let
{
error
result
id
}
=
msg
.
json
;
if
(
error
)
{
let
err
=
new
JavaScriptError
(
error
)
;
sendError
(
err
id
)
;
return
;
}
if
(
!
sandboxes
[
sandboxName
]
)
{
return
;
}
let
cb
=
_emu_cbs
[
id
]
;
delete
_emu_cbs
[
id
]
;
if
(
!
cb
)
{
return
;
}
try
{
cb
(
result
)
;
}
catch
(
e
)
{
let
err
=
new
JavaScriptError
(
e
)
;
sendError
(
err
id
)
;
}
}
function
importScript
(
msg
)
{
let
command_id
=
msg
.
json
.
command_id
;
let
file
;
if
(
importedScripts
.
exists
(
)
)
{
file
=
FileUtils
.
openFileOutputStream
(
importedScripts
FileUtils
.
MODE_APPEND
|
FileUtils
.
MODE_WRONLY
)
;
}
else
{
importedScripts
.
createUnique
(
Components
.
interfaces
.
nsIFile
.
NORMAL_FILE_TYPE
parseInt
(
"
0666
"
8
)
)
;
file
=
FileUtils
.
openFileOutputStream
(
importedScripts
FileUtils
.
MODE_WRONLY
|
FileUtils
.
MODE_CREATE
)
;
importedScripts
.
permissions
=
parseInt
(
"
0666
"
8
)
;
}
file
.
write
(
msg
.
json
.
script
msg
.
json
.
script
.
length
)
;
file
.
close
(
)
;
sendOk
(
command_id
)
;
}
function
takeScreenshot
(
id
full
=
true
highlights
=
[
]
)
{
let
canvas
;
let
highlightEls
=
[
]
;
for
(
let
h
of
highlights
)
{
let
el
=
elementManager
.
getKnownElement
(
h
curContainer
)
;
highlightEls
.
push
(
el
)
;
}
if
(
!
id
&
&
!
full
)
{
canvas
=
capture
.
viewport
(
curContainer
.
frame
.
document
highlightEls
)
;
}
else
{
let
node
;
if
(
id
)
{
node
=
elementManager
.
getKnownElement
(
id
curContainer
)
;
}
else
{
node
=
curContainer
.
frame
.
document
.
documentElement
;
}
canvas
=
capture
.
element
(
node
highlightEls
)
;
}
return
capture
.
toBase64
(
canvas
)
;
}
registerSelf
(
)
;
