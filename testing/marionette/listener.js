"
use
strict
"
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
var
uuidGen
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
var
loader
=
Cc
[
"
mozilla
.
org
/
moz
/
jssubscript
-
loader
;
1
"
]
.
getService
(
Ci
.
mozIJSSubScriptLoader
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
accessibility
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
action
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
atom
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
capture
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
cookies
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
evaluate
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
event
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
interaction
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
logging
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
navigate
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
proxy
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
simpletest
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
var
contentLog
=
new
logging
.
ContentLogger
(
)
;
var
isB2G
=
false
;
var
marionetteTestName
;
var
winUtil
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
var
listenerId
=
null
;
var
curContainer
=
{
frame
:
content
shadowRoot
:
null
}
;
var
isRemoteBrowser
=
(
)
=
>
curContainer
.
frame
.
contentWindow
!
=
=
null
;
var
previousContainer
=
null
;
var
seenEls
=
new
element
.
Store
(
)
;
var
SUPPORTED_STRATEGIES
=
new
Set
(
[
element
.
Strategy
.
ClassName
element
.
Strategy
.
Selector
element
.
Strategy
.
ID
element
.
Strategy
.
Name
element
.
Strategy
.
LinkText
element
.
Strategy
.
PartialLinkText
element
.
Strategy
.
TagName
element
.
Strategy
.
XPath
]
)
;
var
capabilities
=
{
}
;
var
actions
=
new
action
.
Chain
(
checkForInterrupted
)
;
var
onunload
;
var
asyncTestRunning
=
false
;
var
asyncTestCommandId
;
var
asyncTestTimeoutId
;
var
inactivityTimeoutId
=
null
;
var
originalOnError
;
var
checkTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
var
readyStateTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
var
navTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
var
onDOMContentLoaded
;
var
EVENT_INTERVAL
=
30
;
var
multiLast
=
{
}
;
var
asyncChrome
=
proxy
.
toChromeAsync
(
{
addMessageListener
:
addMessageListenerId
.
bind
(
this
)
removeMessageListener
:
removeMessageListenerId
.
bind
(
this
)
sendAsyncMessage
:
sendAsyncMessage
.
bind
(
this
)
}
)
;
var
syncChrome
=
proxy
.
toChrome
(
sendSyncMessage
.
bind
(
this
)
)
;
var
cookies
=
new
Cookies
(
(
)
=
>
curContainer
.
frame
.
document
syncChrome
)
;
var
importedScripts
=
new
evaluate
.
ScriptStorageServiceClient
(
syncChrome
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
var
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
logger
.
debug
(
"
loaded
listener
.
js
"
)
;
var
modalHandler
=
function
(
)
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
storePrevious
:
true
}
)
;
let
isLocal
=
sendSyncMessage
(
"
MarionetteFrame
:
handleModal
"
{
}
)
[
0
]
.
value
;
if
(
isLocal
)
{
previousContainer
=
curContainer
;
}
curContainer
=
{
frame
:
content
shadowRoot
:
null
}
;
}
;
var
sandboxes
=
new
Sandboxes
(
(
)
=
>
curContainer
.
frame
)
;
var
sandboxName
=
"
default
"
;
function
registerSelf
(
)
{
let
msg
=
{
value
:
winUtil
.
outerWindowID
}
;
let
register
=
sendSyncMessage
(
"
Marionette
:
register
"
msg
)
;
if
(
register
[
0
]
)
{
let
{
id
remotenessChange
}
=
register
[
0
]
[
0
]
;
capabilities
=
register
[
0
]
[
2
]
;
isB2G
=
capabilities
.
platformName
=
=
"
b2g
"
;
listenerId
=
id
;
if
(
typeof
id
!
=
"
undefined
"
)
{
if
(
register
[
0
]
[
1
]
=
=
true
)
{
addMessageListener
(
"
MarionetteMainListener
:
emitTouchEvent
"
emitTouchEventForIFrame
)
;
}
startListeners
(
)
;
let
rv
=
{
}
;
if
(
remotenessChange
)
{
rv
.
listenerId
=
id
;
}
sendAsyncMessage
(
"
Marionette
:
listenersAttached
"
rv
)
;
}
}
}
function
emitTouchEventForIFrame
(
message
)
{
message
=
message
.
json
;
let
identifier
=
actions
.
nextTouchId
;
let
domWindowUtils
=
curContainer
.
frame
.
QueryInterface
(
Components
.
interfaces
.
nsIInterfaceRequestor
)
.
getInterface
(
Components
.
interfaces
.
nsIDOMWindowUtils
)
;
var
ratio
=
domWindowUtils
.
screenPixelsPerCSSPixel
;
var
typeForUtils
;
switch
(
message
.
type
)
{
case
'
touchstart
'
:
typeForUtils
=
domWindowUtils
.
TOUCH_CONTACT
;
break
;
case
'
touchend
'
:
typeForUtils
=
domWindowUtils
.
TOUCH_REMOVE
;
break
;
case
'
touchcancel
'
:
typeForUtils
=
domWindowUtils
.
TOUCH_CANCEL
;
break
;
case
'
touchmove
'
:
typeForUtils
=
domWindowUtils
.
TOUCH_CONTACT
;
break
;
}
domWindowUtils
.
sendNativeTouchPoint
(
identifier
typeForUtils
Math
.
round
(
message
.
screenX
*
ratio
)
Math
.
round
(
message
.
screenY
*
ratio
)
message
.
force
90
)
;
}
function
dispatch
(
fn
)
{
if
(
typeof
fn
!
=
"
function
"
)
{
throw
new
TypeError
(
"
Provided
dispatch
handler
is
not
a
function
"
)
;
}
return
function
(
msg
)
{
let
id
=
msg
.
json
.
command_id
;
let
req
=
Task
.
spawn
(
function
*
(
)
{
if
(
typeof
msg
.
json
=
=
"
undefined
"
|
|
msg
.
json
instanceof
Array
)
{
return
yield
fn
.
apply
(
null
msg
.
json
)
;
}
else
{
return
yield
fn
(
msg
.
json
)
;
}
}
)
;
let
okOrValueResponse
=
rv
=
>
{
if
(
typeof
rv
=
=
"
undefined
"
)
{
sendOk
(
id
)
;
}
else
{
sendResponse
(
rv
id
)
;
}
}
;
req
.
then
(
okOrValueResponse
err
=
>
sendError
(
err
id
)
)
.
catch
(
error
.
report
)
;
}
;
}
function
addMessageListenerId
(
messageName
handler
)
{
addMessageListener
(
messageName
+
listenerId
handler
)
;
}
function
removeMessageListenerId
(
messageName
handler
)
{
removeMessageListener
(
messageName
+
listenerId
handler
)
;
}
var
getTitleFn
=
dispatch
(
getTitle
)
;
var
getPageSourceFn
=
dispatch
(
getPageSource
)
;
var
getActiveElementFn
=
dispatch
(
getActiveElement
)
;
var
clickElementFn
=
dispatch
(
clickElement
)
;
var
goBackFn
=
dispatch
(
goBack
)
;
var
getElementAttributeFn
=
dispatch
(
getElementAttribute
)
;
var
getElementPropertyFn
=
dispatch
(
getElementProperty
)
;
var
getElementTextFn
=
dispatch
(
getElementText
)
;
var
getElementTagNameFn
=
dispatch
(
getElementTagName
)
;
var
getElementRectFn
=
dispatch
(
getElementRect
)
;
var
isElementEnabledFn
=
dispatch
(
isElementEnabled
)
;
var
getCurrentUrlFn
=
dispatch
(
getCurrentUrl
)
;
var
findElementContentFn
=
dispatch
(
findElementContent
)
;
var
findElementsContentFn
=
dispatch
(
findElementsContent
)
;
var
isElementSelectedFn
=
dispatch
(
isElementSelected
)
;
var
clearElementFn
=
dispatch
(
clearElement
)
;
var
isElementDisplayedFn
=
dispatch
(
isElementDisplayed
)
;
var
getElementValueOfCssPropertyFn
=
dispatch
(
getElementValueOfCssProperty
)
;
var
switchToShadowRootFn
=
dispatch
(
switchToShadowRoot
)
;
var
getCookiesFn
=
dispatch
(
getCookies
)
;
var
singleTapFn
=
dispatch
(
singleTap
)
;
var
takeScreenshotFn
=
dispatch
(
takeScreenshot
)
;
var
getScreenshotHashFn
=
dispatch
(
getScreenshotHash
)
;
var
actionChainFn
=
dispatch
(
actionChain
)
;
var
multiActionFn
=
dispatch
(
multiAction
)
;
var
addCookieFn
=
dispatch
(
addCookie
)
;
var
deleteCookieFn
=
dispatch
(
deleteCookie
)
;
var
deleteAllCookiesFn
=
dispatch
(
deleteAllCookies
)
;
var
executeFn
=
dispatch
(
execute
)
;
var
executeInSandboxFn
=
dispatch
(
executeInSandbox
)
;
var
executeSimpleTestFn
=
dispatch
(
executeSimpleTest
)
;
var
sendKeysToElementFn
=
dispatch
(
sendKeysToElement
)
;
function
startListeners
(
)
{
addMessageListenerId
(
"
Marionette
:
newSession
"
newSession
)
;
addMessageListenerId
(
"
Marionette
:
execute
"
executeFn
)
;
addMessageListenerId
(
"
Marionette
:
executeInSandbox
"
executeInSandboxFn
)
;
addMessageListenerId
(
"
Marionette
:
executeSimpleTest
"
executeSimpleTestFn
)
;
addMessageListenerId
(
"
Marionette
:
singleTap
"
singleTapFn
)
;
addMessageListenerId
(
"
Marionette
:
actionChain
"
actionChainFn
)
;
addMessageListenerId
(
"
Marionette
:
multiAction
"
multiActionFn
)
;
addMessageListenerId
(
"
Marionette
:
get
"
get
)
;
addMessageListenerId
(
"
Marionette
:
pollForReadyState
"
pollForReadyState
)
;
addMessageListenerId
(
"
Marionette
:
cancelRequest
"
cancelRequest
)
;
addMessageListenerId
(
"
Marionette
:
getCurrentUrl
"
getCurrentUrlFn
)
;
addMessageListenerId
(
"
Marionette
:
getTitle
"
getTitleFn
)
;
addMessageListenerId
(
"
Marionette
:
getPageSource
"
getPageSourceFn
)
;
addMessageListenerId
(
"
Marionette
:
goBack
"
goBackFn
)
;
addMessageListenerId
(
"
Marionette
:
goForward
"
goForward
)
;
addMessageListenerId
(
"
Marionette
:
refresh
"
refresh
)
;
addMessageListenerId
(
"
Marionette
:
findElementContent
"
findElementContentFn
)
;
addMessageListenerId
(
"
Marionette
:
findElementsContent
"
findElementsContentFn
)
;
addMessageListenerId
(
"
Marionette
:
getActiveElement
"
getActiveElementFn
)
;
addMessageListenerId
(
"
Marionette
:
clickElement
"
clickElementFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementAttribute
"
getElementAttributeFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementProperty
"
getElementPropertyFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementText
"
getElementTextFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementTagName
"
getElementTagNameFn
)
;
addMessageListenerId
(
"
Marionette
:
isElementDisplayed
"
isElementDisplayedFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementValueOfCssProperty
"
getElementValueOfCssPropertyFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementRect
"
getElementRectFn
)
;
addMessageListenerId
(
"
Marionette
:
isElementEnabled
"
isElementEnabledFn
)
;
addMessageListenerId
(
"
Marionette
:
isElementSelected
"
isElementSelectedFn
)
;
addMessageListenerId
(
"
Marionette
:
sendKeysToElement
"
sendKeysToElementFn
)
;
addMessageListenerId
(
"
Marionette
:
clearElement
"
clearElementFn
)
;
addMessageListenerId
(
"
Marionette
:
switchToFrame
"
switchToFrame
)
;
addMessageListenerId
(
"
Marionette
:
switchToParentFrame
"
switchToParentFrame
)
;
addMessageListenerId
(
"
Marionette
:
switchToShadowRoot
"
switchToShadowRootFn
)
;
addMessageListenerId
(
"
Marionette
:
deleteSession
"
deleteSession
)
;
addMessageListenerId
(
"
Marionette
:
sleepSession
"
sleepSession
)
;
addMessageListenerId
(
"
Marionette
:
getAppCacheStatus
"
getAppCacheStatus
)
;
addMessageListenerId
(
"
Marionette
:
setTestName
"
setTestName
)
;
addMessageListenerId
(
"
Marionette
:
takeScreenshot
"
takeScreenshotFn
)
;
addMessageListenerId
(
"
Marionette
:
getScreenshotHash
"
getScreenshotHashFn
)
;
addMessageListenerId
(
"
Marionette
:
addCookie
"
addCookieFn
)
;
addMessageListenerId
(
"
Marionette
:
getCookies
"
getCookiesFn
)
;
addMessageListenerId
(
"
Marionette
:
deleteAllCookies
"
deleteAllCookiesFn
)
;
addMessageListenerId
(
"
Marionette
:
deleteCookie
"
deleteCookieFn
)
;
}
function
waitForReady
(
)
{
if
(
content
.
document
.
readyState
=
=
'
complete
'
)
{
readyStateTimer
.
cancel
(
)
;
content
.
addEventListener
(
"
mozbrowsershowmodalprompt
"
modalHandler
false
)
;
content
.
addEventListener
(
"
unload
"
waitForReady
false
)
;
}
else
{
readyStateTimer
.
initWithCallback
(
waitForReady
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
}
function
newSession
(
msg
)
{
capabilities
=
msg
.
json
;
isB2G
=
capabilities
.
platformName
=
=
"
B2G
"
;
resetValues
(
)
;
if
(
isB2G
)
{
readyStateTimer
.
initWithCallback
(
waitForReady
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
actions
.
inputSource
=
Ci
.
nsIDOMMouseEvent
.
MOZ_SOURCE_TOUCH
;
}
}
function
sleepSession
(
msg
)
{
deleteSession
(
)
;
addMessageListener
(
"
Marionette
:
restart
"
restart
)
;
}
function
restart
(
msg
)
{
removeMessageListener
(
"
Marionette
:
restart
"
restart
)
;
if
(
isB2G
)
{
readyStateTimer
.
initWithCallback
(
waitForReady
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
registerSelf
(
)
;
}
function
deleteSession
(
msg
)
{
removeMessageListenerId
(
"
Marionette
:
newSession
"
newSession
)
;
removeMessageListenerId
(
"
Marionette
:
execute
"
executeFn
)
;
removeMessageListenerId
(
"
Marionette
:
executeInSandbox
"
executeInSandboxFn
)
;
removeMessageListenerId
(
"
Marionette
:
executeSimpleTest
"
executeSimpleTestFn
)
;
removeMessageListenerId
(
"
Marionette
:
singleTap
"
singleTapFn
)
;
removeMessageListenerId
(
"
Marionette
:
actionChain
"
actionChainFn
)
;
removeMessageListenerId
(
"
Marionette
:
multiAction
"
multiActionFn
)
;
removeMessageListenerId
(
"
Marionette
:
get
"
get
)
;
removeMessageListenerId
(
"
Marionette
:
pollForReadyState
"
pollForReadyState
)
;
removeMessageListenerId
(
"
Marionette
:
cancelRequest
"
cancelRequest
)
;
removeMessageListenerId
(
"
Marionette
:
getTitle
"
getTitleFn
)
;
removeMessageListenerId
(
"
Marionette
:
getPageSource
"
getPageSourceFn
)
;
removeMessageListenerId
(
"
Marionette
:
getCurrentUrl
"
getCurrentUrlFn
)
;
removeMessageListenerId
(
"
Marionette
:
goBack
"
goBackFn
)
;
removeMessageListenerId
(
"
Marionette
:
goForward
"
goForward
)
;
removeMessageListenerId
(
"
Marionette
:
refresh
"
refresh
)
;
removeMessageListenerId
(
"
Marionette
:
findElementContent
"
findElementContentFn
)
;
removeMessageListenerId
(
"
Marionette
:
findElementsContent
"
findElementsContentFn
)
;
removeMessageListenerId
(
"
Marionette
:
getActiveElement
"
getActiveElementFn
)
;
removeMessageListenerId
(
"
Marionette
:
clickElement
"
clickElementFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementAttribute
"
getElementAttributeFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementProperty
"
getElementPropertyFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementText
"
getElementTextFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementTagName
"
getElementTagNameFn
)
;
removeMessageListenerId
(
"
Marionette
:
isElementDisplayed
"
isElementDisplayedFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementValueOfCssProperty
"
getElementValueOfCssPropertyFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementRect
"
getElementRectFn
)
;
removeMessageListenerId
(
"
Marionette
:
isElementEnabled
"
isElementEnabledFn
)
;
removeMessageListenerId
(
"
Marionette
:
isElementSelected
"
isElementSelectedFn
)
;
removeMessageListenerId
(
"
Marionette
:
sendKeysToElement
"
sendKeysToElementFn
)
;
removeMessageListenerId
(
"
Marionette
:
clearElement
"
clearElementFn
)
;
removeMessageListenerId
(
"
Marionette
:
switchToFrame
"
switchToFrame
)
;
removeMessageListenerId
(
"
Marionette
:
switchToParentFrame
"
switchToParentFrame
)
;
removeMessageListenerId
(
"
Marionette
:
switchToShadowRoot
"
switchToShadowRootFn
)
;
removeMessageListenerId
(
"
Marionette
:
deleteSession
"
deleteSession
)
;
removeMessageListenerId
(
"
Marionette
:
sleepSession
"
sleepSession
)
;
removeMessageListenerId
(
"
Marionette
:
getAppCacheStatus
"
getAppCacheStatus
)
;
removeMessageListenerId
(
"
Marionette
:
setTestName
"
setTestName
)
;
removeMessageListenerId
(
"
Marionette
:
takeScreenshot
"
takeScreenshotFn
)
;
removeMessageListenerId
(
"
Marionette
:
getScreenshotHash
"
getScreenshotHashFn
)
;
removeMessageListenerId
(
"
Marionette
:
addCookie
"
addCookieFn
)
;
removeMessageListenerId
(
"
Marionette
:
getCookies
"
getCookiesFn
)
;
removeMessageListenerId
(
"
Marionette
:
deleteAllCookies
"
deleteAllCookiesFn
)
;
removeMessageListenerId
(
"
Marionette
:
deleteCookie
"
deleteCookieFn
)
;
if
(
isB2G
)
{
content
.
removeEventListener
(
"
mozbrowsershowmodalprompt
"
modalHandler
false
)
;
}
seenEls
.
clear
(
)
;
curContainer
=
{
frame
:
content
shadowRoot
:
null
}
;
curContainer
.
frame
.
focus
(
)
;
actions
.
touchIds
=
{
}
;
}
function
sendToServer
(
uuid
data
=
undefined
)
{
let
channel
=
new
proxy
.
AsyncMessageChannel
(
(
)
=
>
this
sendAsyncMessage
.
bind
(
this
)
)
;
channel
.
reply
(
uuid
data
)
;
}
function
sendResponse
(
obj
id
)
{
sendToServer
(
id
obj
)
;
}
function
sendOk
(
uuid
)
{
sendToServer
(
uuid
)
;
}
function
sendError
(
err
uuid
)
{
sendToServer
(
uuid
err
)
;
}
function
sendLog
(
msg
)
{
sendToServer
(
"
Marionette
:
log
"
{
message
:
msg
}
)
;
}
function
resetValues
(
)
{
sandboxes
.
clear
(
)
;
curContainer
=
{
frame
:
content
shadowRoot
:
null
}
;
actions
.
mouseEventsOnly
=
false
;
}
function
dumpLog
(
logline
)
{
dump
(
Date
.
now
(
)
+
"
Marionette
:
"
+
logline
)
;
}
function
wasInterrupted
(
)
{
if
(
previousContainer
)
{
let
element
=
content
.
document
.
elementFromPoint
(
(
content
.
innerWidth
/
2
)
(
content
.
innerHeight
/
2
)
)
;
if
(
element
.
id
.
indexOf
(
"
modal
-
dialog
"
)
=
=
-
1
)
{
return
true
;
}
else
{
return
false
;
}
}
return
sendSyncMessage
(
"
MarionetteFrame
:
getInterruptedState
"
{
}
)
[
0
]
.
value
;
}
function
checkForInterrupted
(
)
{
if
(
wasInterrupted
(
)
)
{
if
(
previousContainer
)
{
curContainer
=
actions
.
container
=
previousContainer
;
previousContainer
=
null
;
}
else
{
sendSyncMessage
(
"
Marionette
:
switchToModalOrigin
"
)
;
}
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
restorePrevious
:
true
}
)
;
}
}
function
*
execute
(
script
args
timeout
opts
)
{
opts
.
timeout
=
timeout
;
script
=
importedScripts
.
for
(
"
content
"
)
.
concat
(
script
)
;
let
sb
=
sandbox
.
createMutable
(
curContainer
.
frame
)
;
let
wargs
=
element
.
fromJson
(
args
seenEls
curContainer
.
frame
curContainer
.
shadowRoot
)
;
let
res
=
yield
evaluate
.
sandbox
(
sb
script
wargs
opts
)
;
return
element
.
toJson
(
res
seenEls
)
;
}
function
*
executeInSandbox
(
script
args
timeout
opts
)
{
opts
.
timeout
=
timeout
;
script
=
importedScripts
.
for
(
"
content
"
)
.
concat
(
script
)
;
let
sb
=
sandboxes
.
get
(
opts
.
sandboxName
opts
.
newSandbox
)
;
if
(
opts
.
sandboxName
)
{
sb
=
sandbox
.
augment
(
sb
{
global
:
sb
}
)
;
sb
=
sandbox
.
augment
(
sb
new
logging
.
Adapter
(
contentLog
)
)
;
}
let
wargs
=
element
.
fromJson
(
args
seenEls
curContainer
.
frame
curContainer
.
shadowRoot
)
;
let
evaluatePromise
=
evaluate
.
sandbox
(
sb
script
wargs
opts
)
;
let
res
=
yield
evaluatePromise
;
sendSyncMessage
(
"
Marionette
:
shareData
"
{
log
:
element
.
toJson
(
contentLog
.
get
(
)
seenEls
)
}
)
;
return
element
.
toJson
(
res
seenEls
)
;
}
function
*
executeSimpleTest
(
script
args
timeout
opts
)
{
opts
.
timeout
=
timeout
;
let
win
=
curContainer
.
frame
;
script
=
importedScripts
.
for
(
"
content
"
)
.
concat
(
script
)
;
let
harness
=
new
simpletest
.
Harness
(
win
"
content
"
contentLog
timeout
marionetteTestName
)
;
let
sb
=
sandbox
.
createSimpleTest
(
curContainer
.
frame
harness
)
;
sb
=
sandbox
.
augment
(
sb
new
logging
.
Adapter
(
contentLog
)
)
;
let
wargs
=
element
.
fromJson
(
args
seenEls
curContainer
.
frame
curContainer
.
shadowRoot
)
;
let
evaluatePromise
=
evaluate
.
sandbox
(
sb
script
wargs
opts
)
;
let
res
=
yield
evaluatePromise
;
sendSyncMessage
(
"
Marionette
:
shareData
"
{
log
:
element
.
toJson
(
contentLog
.
get
(
)
seenEls
)
}
)
;
return
element
.
toJson
(
res
seenEls
)
;
}
function
setTestName
(
msg
)
{
marionetteTestName
=
msg
.
json
.
value
;
sendOk
(
msg
.
json
.
command_id
)
;
}
function
emitTouchEvent
(
type
touch
)
{
if
(
!
wasInterrupted
(
)
)
{
let
loggingInfo
=
"
emitting
Touch
event
of
type
"
+
type
+
"
to
element
with
id
:
"
+
touch
.
target
.
id
+
"
and
tag
name
:
"
+
touch
.
target
.
tagName
+
"
at
coordinates
(
"
+
touch
.
clientX
+
"
"
+
touch
.
clientY
+
"
)
relative
to
the
viewport
"
;
dumpLog
(
loggingInfo
)
;
var
docShell
=
curContainer
.
frame
.
document
.
defaultView
.
QueryInterface
(
Components
.
interfaces
.
nsIInterfaceRequestor
)
.
getInterface
(
Components
.
interfaces
.
nsIWebNavigation
)
.
QueryInterface
(
Components
.
interfaces
.
nsIDocShell
)
;
if
(
docShell
.
asyncPanZoomEnabled
&
&
actions
.
scrolling
)
{
let
index
=
sendSyncMessage
(
"
MarionetteFrame
:
getCurrentFrameId
"
)
;
if
(
index
!
=
null
)
{
sendSyncMessage
(
"
Marionette
:
emitTouchEvent
"
{
index
:
index
type
:
type
id
:
touch
.
identifier
clientX
:
touch
.
clientX
clientY
:
touch
.
clientY
screenX
:
touch
.
screenX
screenY
:
touch
.
screenY
radiusX
:
touch
.
radiusX
radiusY
:
touch
.
radiusY
rotation
:
touch
.
rotationAngle
force
:
touch
.
force
}
)
;
return
;
}
}
let
domWindowUtils
=
curContainer
.
frame
.
QueryInterface
(
Components
.
interfaces
.
nsIInterfaceRequestor
)
.
getInterface
(
Components
.
interfaces
.
nsIDOMWindowUtils
)
;
domWindowUtils
.
sendTouchEvent
(
type
[
touch
.
identifier
]
[
touch
.
clientX
]
[
touch
.
clientY
]
[
touch
.
radiusX
]
[
touch
.
radiusY
]
[
touch
.
rotationAngle
]
[
touch
.
force
]
1
0
)
;
}
}
function
singleTap
(
id
corx
cory
)
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
let
visible
=
element
.
isVisible
(
el
corx
cory
)
;
if
(
!
visible
)
{
throw
new
ElementNotVisibleError
(
"
Element
is
not
currently
visible
and
may
not
be
manipulated
"
)
;
}
let
a11y
=
accessibility
.
get
(
capabilities
.
raisesAccessibilityExceptions
)
;
return
a11y
.
getAccessible
(
el
true
)
.
then
(
acc
=
>
{
a11y
.
assertVisible
(
acc
el
visible
)
;
a11y
.
assertActionable
(
acc
el
)
;
if
(
!
curContainer
.
frame
.
document
.
createTouch
)
{
actions
.
mouseEventsOnly
=
true
;
}
let
c
=
element
.
coordinates
(
el
corx
cory
)
;
if
(
!
actions
.
mouseEventsOnly
)
{
let
touchId
=
actions
.
nextTouchId
+
+
;
let
touch
=
createATouch
(
el
c
.
x
c
.
y
touchId
)
;
emitTouchEvent
(
'
touchstart
'
touch
)
;
emitTouchEvent
(
'
touchend
'
touch
)
;
}
actions
.
mouseTap
(
el
.
ownerDocument
c
.
x
c
.
y
)
;
}
)
;
}
function
createATouch
(
el
corx
cory
touchId
)
{
let
doc
=
el
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
[
clientX
clientY
pageX
pageY
screenX
screenY
]
=
actions
.
getCoordinateInfo
(
el
corx
cory
)
;
let
atouch
=
doc
.
createTouch
(
win
el
touchId
pageX
pageY
screenX
screenY
clientX
clientY
)
;
return
atouch
;
}
function
actionChain
(
chain
touchId
)
{
let
touchProvider
=
{
}
;
touchProvider
.
createATouch
=
createATouch
;
touchProvider
.
emitTouchEvent
=
emitTouchEvent
;
return
actions
.
dispatchActions
(
chain
touchId
curContainer
seenEls
touchProvider
)
;
}
function
emitMultiEvents
(
type
touch
touches
)
{
let
target
=
touch
.
target
;
let
doc
=
target
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
documentTouches
=
doc
.
createTouchList
(
touches
.
filter
(
function
(
t
)
{
return
(
(
t
.
target
.
ownerDocument
=
=
=
doc
)
&
&
(
type
!
=
'
touchcancel
'
)
)
;
}
)
)
;
let
targetTouches
=
doc
.
createTouchList
(
touches
.
filter
(
function
(
t
)
{
return
(
(
t
.
target
=
=
=
target
)
&
&
(
(
type
!
=
'
touchcancel
'
)
|
|
(
type
!
=
'
touchend
'
)
)
)
;
}
)
)
;
let
changedTouches
=
doc
.
createTouchList
(
touch
)
;
let
event
=
doc
.
createEvent
(
'
TouchEvent
'
)
;
event
.
initTouchEvent
(
type
true
true
win
0
false
false
false
false
documentTouches
targetTouches
changedTouches
)
;
target
.
dispatchEvent
(
event
)
;
}
function
setDispatch
(
batches
touches
batchIndex
=
0
)
{
if
(
batchIndex
>
=
batches
.
length
)
{
multiLast
=
{
}
;
return
;
}
let
batch
=
batches
[
batchIndex
]
;
let
pack
;
let
touchId
;
let
command
;
let
el
;
let
corx
;
let
cory
;
let
touch
;
let
lastTouch
;
let
touchIndex
;
let
waitTime
=
0
;
let
maxTime
=
0
;
let
c
;
batchIndex
+
+
;
for
(
let
i
=
0
;
i
<
batch
.
length
;
i
+
+
)
{
pack
=
batch
[
i
]
;
touchId
=
pack
[
0
]
;
command
=
pack
[
1
]
;
switch
(
command
)
{
case
"
press
"
:
el
=
seenEls
.
get
(
pack
[
2
]
curContainer
)
;
c
=
element
.
coordinates
(
el
pack
[
3
]
pack
[
4
]
)
;
touch
=
createATouch
(
el
c
.
x
c
.
y
touchId
)
;
multiLast
[
touchId
]
=
touch
;
touches
.
push
(
touch
)
;
emitMultiEvents
(
"
touchstart
"
touch
touches
)
;
break
;
case
"
release
"
:
touch
=
multiLast
[
touchId
]
;
touchIndex
=
touches
.
indexOf
(
touch
)
;
touches
.
splice
(
touchIndex
1
)
;
emitMultiEvents
(
"
touchend
"
touch
touches
)
;
break
;
case
"
move
"
:
el
=
seenEls
.
get
(
pack
[
2
]
curContainer
)
;
c
=
element
.
coordinates
(
el
)
;
touch
=
createATouch
(
multiLast
[
touchId
]
.
target
c
.
x
c
.
y
touchId
)
;
touchIndex
=
touches
.
indexOf
(
lastTouch
)
;
touches
[
touchIndex
]
=
touch
;
multiLast
[
touchId
]
=
touch
;
emitMultiEvents
(
"
touchmove
"
touch
touches
)
;
break
;
case
"
moveByOffset
"
:
el
=
multiLast
[
touchId
]
.
target
;
lastTouch
=
multiLast
[
touchId
]
;
touchIndex
=
touches
.
indexOf
(
lastTouch
)
;
let
doc
=
el
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
clientX
=
lastTouch
.
clientX
+
pack
[
2
]
clientY
=
lastTouch
.
clientY
+
pack
[
3
]
;
let
pageX
=
clientX
+
win
.
pageXOffset
pageY
=
clientY
+
win
.
pageYOffset
;
let
screenX
=
clientX
+
win
.
mozInnerScreenX
screenY
=
clientY
+
win
.
mozInnerScreenY
;
touch
=
doc
.
createTouch
(
win
el
touchId
pageX
pageY
screenX
screenY
clientX
clientY
)
;
touches
[
touchIndex
]
=
touch
;
multiLast
[
touchId
]
=
touch
;
emitMultiEvents
(
"
touchmove
"
touch
touches
)
;
break
;
case
"
wait
"
:
if
(
typeof
pack
[
2
]
!
=
"
undefined
"
)
{
waitTime
=
pack
[
2
]
*
1000
;
if
(
waitTime
>
maxTime
)
{
maxTime
=
waitTime
;
}
}
break
;
}
}
if
(
maxTime
!
=
0
)
{
checkTimer
.
initWithCallback
(
function
(
)
{
setDispatch
(
batches
touches
batchIndex
)
;
}
maxTime
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
{
setDispatch
(
batches
touches
batchIndex
)
;
}
}
function
multiAction
(
args
maxLen
)
{
let
commandArray
=
element
.
fromJson
(
args
seenEls
curContainer
.
frame
curContainer
.
shadowRoot
)
;
let
concurrentEvent
=
[
]
;
let
temp
;
for
(
let
i
=
0
;
i
<
maxLen
;
i
+
+
)
{
let
row
=
[
]
;
for
(
let
j
=
0
;
j
<
commandArray
.
length
;
j
+
+
)
{
if
(
typeof
commandArray
[
j
]
[
i
]
!
=
"
undefined
"
)
{
temp
=
commandArray
[
j
]
[
i
]
;
temp
.
unshift
(
j
)
;
row
.
push
(
temp
)
;
}
}
concurrentEvent
.
push
(
row
)
;
}
let
pendingTouches
=
[
]
;
setDispatch
(
concurrentEvent
pendingTouches
)
;
}
function
pollForReadyState
(
msg
start
=
undefined
callback
=
undefined
)
{
let
{
pageTimeout
url
command_id
}
=
msg
.
json
;
if
(
!
start
)
{
start
=
new
Date
(
)
.
getTime
(
)
;
}
if
(
!
callback
)
{
callback
=
(
)
=
>
{
}
;
}
let
checkLoad
=
function
(
)
{
navTimer
.
cancel
(
)
;
let
doc
=
curContainer
.
frame
.
document
;
let
now
=
new
Date
(
)
.
getTime
(
)
;
if
(
pageTimeout
=
=
null
|
|
(
now
-
start
)
<
=
pageTimeout
)
{
if
(
doc
.
readyState
=
=
"
complete
"
)
{
callback
(
)
;
sendOk
(
command_id
)
;
}
else
if
(
doc
.
readyState
=
=
"
interactive
"
&
&
/
about
:
.
+
(
error
)
\
?
/
.
exec
(
doc
.
baseURI
)
&
&
!
doc
.
baseURI
.
startsWith
(
url
)
)
{
callback
(
)
;
sendError
(
new
UnknownError
(
"
Reached
error
page
:
"
+
doc
.
baseURI
)
command_id
)
;
}
else
if
(
doc
.
readyState
=
=
"
interactive
"
&
&
doc
.
baseURI
.
startsWith
(
"
about
:
"
)
)
{
callback
(
)
;
sendOk
(
command_id
)
;
}
else
{
navTimer
.
initWithCallback
(
checkLoad
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
}
else
{
callback
(
)
;
sendError
(
new
TimeoutError
(
"
Error
loading
page
timed
out
(
checkLoad
)
"
)
command_id
)
;
}
}
;
checkLoad
(
)
;
}
function
get
(
msg
)
{
let
start
=
new
Date
(
)
.
getTime
(
)
;
let
{
pageTimeout
url
command_id
}
=
msg
.
json
;
let
docShell
=
curContainer
.
frame
.
document
.
defaultView
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
let
sawLoad
=
false
;
let
requestedURL
;
let
loadEventExpected
=
false
;
try
{
requestedURL
=
new
URL
(
url
)
.
toString
(
)
;
let
curURL
=
curContainer
.
frame
.
location
;
loadEventExpected
=
navigate
.
isLoadEventExpected
(
curURL
requestedURL
)
;
}
catch
(
e
)
{
sendError
(
new
InvalidArgumentError
(
"
Malformed
URL
:
"
+
e
.
message
)
command_id
)
;
return
;
}
let
loadListener
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
onStateChange
(
webProgress
request
state
status
)
{
if
(
!
(
request
instanceof
Ci
.
nsIChannel
)
)
{
return
;
}
let
isDocument
=
state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_DOCUMENT
;
let
isStart
=
state
&
Ci
.
nsIWebProgressListener
.
STATE_START
;
let
loadedURL
=
request
.
URI
.
spec
;
let
originalURL
=
request
.
originalURI
.
spec
;
let
isRequestedURL
=
loadedURL
=
=
requestedURL
|
|
originalURL
=
=
requestedURL
;
if
(
isDocument
&
&
isStart
&
&
isRequestedURL
)
{
sawLoad
=
true
;
}
}
onLocationChange
(
)
{
}
onProgressChange
(
)
{
}
onStatusChange
(
)
{
}
onSecurityChange
(
)
{
}
}
;
webProgress
.
addProgressListener
(
loadListener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
onDOMContentLoaded
=
function
onDOMContentLoaded
(
event
)
{
let
frameEl
=
event
.
originalTarget
.
defaultView
.
frameElement
;
let
correctFrame
=
!
frameEl
|
|
frameEl
=
=
curContainer
.
frame
.
frameElement
;
if
(
curContainer
.
frame
.
location
=
=
requestedURL
)
{
sawLoad
=
true
;
}
let
loadedNonAboutBlank
=
docShell
.
hasLoadedNonBlankURI
;
if
(
correctFrame
&
&
sawLoad
&
&
loadedNonAboutBlank
)
{
webProgress
.
removeProgressListener
(
loadListener
)
;
pollForReadyState
(
msg
start
(
)
=
>
{
removeEventListener
(
"
DOMContentLoaded
"
onDOMContentLoaded
false
)
;
}
)
;
}
}
;
if
(
typeof
pageTimeout
!
=
"
undefined
"
)
{
let
onTimeout
=
function
(
)
{
if
(
loadEventExpected
)
{
removeEventListener
(
"
DOMContentLoaded
"
onDOMContentLoaded
false
)
;
}
webProgress
.
removeProgressListener
(
loadListener
)
;
sendError
(
new
TimeoutError
(
"
Error
loading
page
timed
out
(
onDOMContentLoaded
)
"
)
command_id
)
;
}
navTimer
.
initWithCallback
(
onTimeout
pageTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
if
(
!
isB2G
)
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
}
if
(
loadEventExpected
)
{
addEventListener
(
"
DOMContentLoaded
"
onDOMContentLoaded
false
)
;
}
curContainer
.
frame
.
location
=
requestedURL
;
if
(
!
loadEventExpected
)
{
sendOk
(
command_id
)
;
}
}
function
cancelRequest
(
)
{
navTimer
.
cancel
(
)
;
if
(
onDOMContentLoaded
)
{
removeEventListener
(
"
DOMContentLoaded
"
onDOMContentLoaded
false
)
;
}
}
function
getCurrentUrl
(
isB2G
)
{
if
(
isB2G
)
{
return
curContainer
.
frame
.
location
.
href
;
}
else
{
return
content
.
location
.
href
;
}
}
function
getTitle
(
)
{
return
curContainer
.
frame
.
top
.
document
.
title
;
}
function
getPageSource
(
)
{
let
XMLSerializer
=
curContainer
.
frame
.
XMLSerializer
;
let
source
=
new
XMLSerializer
(
)
.
serializeToString
(
curContainer
.
frame
.
document
)
;
return
source
;
}
function
goBack
(
)
{
curContainer
.
frame
.
history
.
back
(
)
;
}
function
goForward
(
msg
)
{
curContainer
.
frame
.
history
.
forward
(
)
;
sendOk
(
msg
.
json
.
command_id
)
;
}
function
refresh
(
msg
)
{
let
command_id
=
msg
.
json
.
command_id
;
curContainer
.
frame
.
location
.
reload
(
true
)
;
let
listen
=
function
(
)
{
removeEventListener
(
"
DOMContentLoaded
"
listen
false
)
;
sendOk
(
command_id
)
;
}
;
addEventListener
(
"
DOMContentLoaded
"
listen
false
)
;
}
function
*
findElementContent
(
strategy
selector
opts
=
{
}
)
{
if
(
!
SUPPORTED_STRATEGIES
.
has
(
strategy
)
)
{
throw
new
InvalidSelectorError
(
"
Strategy
not
supported
:
"
+
strategy
)
;
}
opts
.
all
=
false
;
if
(
opts
.
startNode
)
{
opts
.
startNode
=
seenEls
.
get
(
opts
.
startNode
curContainer
)
;
}
let
el
=
yield
element
.
find
(
curContainer
strategy
selector
opts
)
;
let
elRef
=
seenEls
.
add
(
el
)
;
let
webEl
=
element
.
makeWebElement
(
elRef
)
;
return
webEl
;
}
function
*
findElementsContent
(
strategy
selector
opts
=
{
}
)
{
if
(
!
SUPPORTED_STRATEGIES
.
has
(
strategy
)
)
{
throw
new
InvalidSelectorError
(
"
Strategy
not
supported
:
"
+
strategy
)
;
}
opts
.
all
=
true
;
if
(
opts
.
startNode
)
{
opts
.
startNode
=
seenEls
.
get
(
opts
.
startNode
curContainer
)
;
}
let
els
=
yield
element
.
find
(
curContainer
strategy
selector
opts
)
;
let
elRefs
=
seenEls
.
addAll
(
els
)
;
let
webEls
=
elRefs
.
map
(
element
.
makeWebElement
)
;
return
webEls
;
}
function
getActiveElement
(
)
{
let
el
=
curContainer
.
frame
.
document
.
activeElement
;
return
element
.
toJson
(
el
seenEls
)
;
}
function
clickElement
(
id
)
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
return
interaction
.
clickElement
(
el
!
!
capabilities
.
raisesAccessibilityExceptions
capabilities
.
specificationLevel
>
=
1
)
;
}
function
getElementAttribute
(
id
name
)
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
if
(
element
.
isBooleanAttribute
(
el
name
)
)
{
if
(
el
.
hasAttribute
(
name
)
)
{
return
"
true
"
;
}
else
{
return
null
;
}
}
else
{
return
el
.
getAttribute
(
name
)
;
}
}
function
getElementProperty
(
id
name
)
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
return
typeof
el
[
name
]
!
=
"
undefined
"
?
el
[
name
]
:
null
;
}
function
getElementText
(
id
)
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
return
atom
.
getElementText
(
el
curContainer
.
frame
)
;
}
function
getElementTagName
(
id
)
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
return
el
.
tagName
.
toLowerCase
(
)
;
}
function
isElementDisplayed
(
id
)
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
return
interaction
.
isElementDisplayed
(
el
capabilities
.
raisesAccessibilityExceptions
)
;
}
function
getElementValueOfCssProperty
(
id
prop
)
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
let
st
=
curContainer
.
frame
.
document
.
defaultView
.
getComputedStyle
(
el
null
)
;
return
st
.
getPropertyValue
(
prop
)
;
}
function
getElementRect
(
id
)
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
let
clientRect
=
el
.
getBoundingClientRect
(
)
;
return
{
x
:
clientRect
.
x
+
curContainer
.
frame
.
pageXOffset
y
:
clientRect
.
y
+
curContainer
.
frame
.
pageYOffset
width
:
clientRect
.
width
height
:
clientRect
.
height
}
;
}
function
isElementEnabled
(
id
)
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
return
interaction
.
isElementEnabled
(
el
capabilities
.
raisesAccessibilityExceptions
)
;
}
function
isElementSelected
(
id
)
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
return
interaction
.
isElementSelected
(
el
capabilities
.
raisesAccessibilityExceptions
)
;
}
function
*
sendKeysToElement
(
id
val
)
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
if
(
el
.
type
=
=
"
file
"
)
{
let
path
=
val
.
join
(
"
"
)
;
yield
interaction
.
uploadFile
(
el
path
)
;
}
else
{
yield
interaction
.
sendKeysToElement
(
el
val
false
capabilities
.
raisesAccessibilityExceptions
)
;
}
}
function
clearElement
(
id
)
{
try
{
let
el
=
seenEls
.
get
(
id
curContainer
)
;
if
(
el
.
type
=
=
"
file
"
)
{
el
.
value
=
null
;
}
else
{
atom
.
clearElement
(
el
curContainer
.
frame
)
;
}
}
catch
(
e
)
{
if
(
e
.
name
=
=
"
InvalidElementStateError
"
)
{
throw
new
InvalidElementStateError
(
e
.
message
)
;
}
else
{
throw
e
;
}
}
}
function
switchToShadowRoot
(
id
)
{
if
(
!
id
)
{
if
(
curContainer
.
shadowRoot
)
{
let
parent
;
try
{
parent
=
curContainer
.
shadowRoot
.
host
;
}
catch
(
e
)
{
curContainer
.
shadowRoot
=
null
;
return
;
}
while
(
parent
&
&
!
(
parent
instanceof
curContainer
.
frame
.
ShadowRoot
)
)
{
parent
=
parent
.
parentNode
;
}
curContainer
.
shadowRoot
=
parent
;
}
return
;
}
let
foundShadowRoot
;
let
hostEl
=
seenEls
.
get
(
id
curContainer
)
;
foundShadowRoot
=
hostEl
.
shadowRoot
;
if
(
!
foundShadowRoot
)
{
throw
new
NoSuchElementError
(
'
Unable
to
locate
shadow
root
:
'
+
id
)
;
}
curContainer
.
shadowRoot
=
foundShadowRoot
;
}
function
switchToParentFrame
(
msg
)
{
let
command_id
=
msg
.
json
.
command_id
;
curContainer
.
frame
=
curContainer
.
frame
.
parent
;
let
parentElement
=
seenEls
.
add
(
curContainer
.
frame
)
;
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
parentElement
}
)
;
sendOk
(
msg
.
json
.
command_id
)
;
}
function
switchToFrame
(
msg
)
{
let
command_id
=
msg
.
json
.
command_id
;
function
checkLoad
(
)
{
let
errorRegex
=
/
about
:
.
+
(
error
)
|
(
blocked
)
\
?
/
;
if
(
curContainer
.
frame
.
document
.
readyState
=
=
"
complete
"
)
{
sendOk
(
command_id
)
;
return
;
}
else
if
(
curContainer
.
frame
.
document
.
readyState
=
=
"
interactive
"
&
&
errorRegex
.
exec
(
curContainer
.
frame
.
document
.
baseURI
)
)
{
sendError
(
new
UnknownError
(
"
Error
loading
page
"
)
command_id
)
;
return
;
}
checkTimer
.
initWithCallback
(
checkLoad
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
let
foundFrame
=
null
;
let
frames
=
[
]
;
let
parWindow
=
null
;
try
{
frames
=
curContainer
.
frame
.
frames
;
parWindow
=
curContainer
.
frame
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
}
catch
(
e
)
{
msg
.
json
.
id
=
null
;
msg
.
json
.
element
=
null
;
}
if
(
(
msg
.
json
.
id
=
=
=
null
|
|
msg
.
json
.
id
=
=
=
undefined
)
&
&
(
msg
.
json
.
element
=
=
null
)
)
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
if
(
msg
.
json
.
focus
=
=
true
)
{
curContainer
.
frame
.
focus
(
)
;
}
checkTimer
.
initWithCallback
(
checkLoad
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
return
;
}
let
id
=
msg
.
json
.
element
;
if
(
seenEls
.
has
(
id
)
)
{
let
wantedFrame
;
try
{
wantedFrame
=
seenEls
.
get
(
id
curContainer
)
;
}
catch
(
e
)
{
sendError
(
e
command_id
)
;
}
if
(
frames
.
length
>
0
)
{
for
(
let
i
=
0
;
i
<
frames
.
length
;
i
+
+
)
{
if
(
XPCNativeWrapper
(
frames
[
i
]
.
frameElement
)
=
=
XPCNativeWrapper
(
wantedFrame
)
)
{
curContainer
.
frame
=
frames
[
i
]
.
frameElement
;
foundFrame
=
i
;
}
}
}
if
(
foundFrame
=
=
=
null
)
{
let
iframes
=
curContainer
.
frame
.
document
.
getElementsByTagName
(
"
iframe
"
)
;
for
(
var
i
=
0
;
i
<
iframes
.
length
;
i
+
+
)
{
if
(
XPCNativeWrapper
(
iframes
[
i
]
)
=
=
XPCNativeWrapper
(
wantedFrame
)
)
{
curContainer
.
frame
=
iframes
[
i
]
;
foundFrame
=
i
;
}
}
}
}
if
(
foundFrame
=
=
=
null
)
{
if
(
typeof
(
msg
.
json
.
id
)
=
=
=
'
number
'
)
{
try
{
foundFrame
=
frames
[
msg
.
json
.
id
]
.
frameElement
;
if
(
foundFrame
!
=
=
null
)
{
curContainer
.
frame
=
foundFrame
;
foundFrame
=
seenEls
.
add
(
curContainer
.
frame
)
;
}
else
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
if
(
msg
.
json
.
focus
=
=
true
)
{
curContainer
.
frame
.
focus
(
)
;
}
checkTimer
.
initWithCallback
(
checkLoad
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
return
;
}
}
catch
(
e
)
{
let
iframes
=
curContainer
.
frame
.
document
.
getElementsByTagName
(
"
iframe
"
)
;
if
(
msg
.
json
.
id
>
=
0
&
&
msg
.
json
.
id
<
iframes
.
length
)
{
curContainer
.
frame
=
iframes
[
msg
.
json
.
id
]
;
foundFrame
=
msg
.
json
.
id
;
}
}
}
}
if
(
foundFrame
=
=
=
null
)
{
sendError
(
new
NoSuchFrameError
(
"
Unable
to
locate
frame
:
"
+
(
msg
.
json
.
id
|
|
msg
.
json
.
element
)
)
command_id
)
;
return
true
;
}
let
frameValue
=
element
.
toJson
(
curContainer
.
frame
.
wrappedJSObject
seenEls
)
[
element
.
Key
]
;
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
frameValue
}
)
;
let
rv
=
null
;
if
(
curContainer
.
frame
.
contentWindow
=
=
=
null
)
{
curContainer
.
frame
=
content
;
rv
=
{
win
:
parWindow
frame
:
foundFrame
}
;
}
else
{
curContainer
.
frame
=
curContainer
.
frame
.
contentWindow
;
if
(
msg
.
json
.
focus
)
{
curContainer
.
frame
.
focus
(
)
;
}
checkTimer
.
initWithCallback
(
checkLoad
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
sendResponse
(
rv
command_id
)
;
}
function
addCookie
(
cookie
)
{
cookies
.
add
(
cookie
.
name
cookie
.
value
cookie
)
;
}
function
getCookies
(
)
{
let
rv
=
[
]
;
for
(
let
cookie
of
cookies
)
{
let
expires
=
cookie
.
expires
;
if
(
expires
=
=
0
)
{
expires
=
null
;
}
else
if
(
expires
=
=
1
)
{
expires
=
0
;
}
rv
.
push
(
{
'
name
'
:
cookie
.
name
'
value
'
:
cookie
.
value
'
path
'
:
cookie
.
path
'
domain
'
:
cookie
.
host
'
secure
'
:
cookie
.
isSecure
'
httpOnly
'
:
cookie
.
httpOnly
'
expiry
'
:
expires
}
)
;
}
return
rv
;
}
function
deleteCookie
(
name
)
{
cookies
.
delete
(
name
)
;
}
function
deleteAllCookies
(
)
{
for
(
let
cookie
of
cookies
)
{
cookies
.
delete
(
cookie
)
;
}
}
function
getAppCacheStatus
(
msg
)
{
sendResponse
(
curContainer
.
frame
.
applicationCache
.
status
msg
.
json
.
command_id
)
;
}
function
takeScreenshot
(
id
full
=
true
highlights
=
[
]
)
{
let
canvas
=
screenshot
(
id
full
highlights
)
;
return
capture
.
toBase64
(
canvas
)
;
}
function
getScreenshotHash
(
id
full
=
true
highlights
=
[
]
)
{
let
canvas
=
screenshot
(
id
full
highlights
)
;
return
capture
.
toHash
(
canvas
)
;
}
function
screenshot
(
id
full
=
true
highlights
=
[
]
)
{
let
canvas
;
let
highlightEls
=
[
]
;
for
(
let
h
of
highlights
)
{
let
el
=
seenEls
.
get
(
h
curContainer
)
;
highlightEls
.
push
(
el
)
;
}
if
(
!
id
&
&
!
full
)
{
canvas
=
capture
.
viewport
(
curContainer
.
frame
.
document
highlightEls
)
;
}
else
{
let
node
;
if
(
id
)
{
node
=
seenEls
.
get
(
id
curContainer
)
;
}
else
{
node
=
curContainer
.
frame
.
document
.
documentElement
;
}
canvas
=
capture
.
element
(
node
highlightEls
)
;
}
return
canvas
;
}
registerSelf
(
)
;
