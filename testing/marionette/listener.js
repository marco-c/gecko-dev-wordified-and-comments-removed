"
use
strict
"
;
const
winUtil
=
content
.
windowUtils
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
accessibility
:
"
chrome
:
/
/
marionette
/
content
/
accessibility
.
js
"
action
:
"
chrome
:
/
/
marionette
/
content
/
action
.
js
"
atom
:
"
chrome
:
/
/
marionette
/
content
/
atom
.
js
"
Capabilities
:
"
chrome
:
/
/
marionette
/
content
/
capabilities
.
js
"
ContentEventObserverService
:
"
chrome
:
/
/
marionette
/
content
/
dom
.
js
"
element
:
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
error
:
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
evaluate
:
"
chrome
:
/
/
marionette
/
content
/
evaluate
.
js
"
event
:
"
chrome
:
/
/
marionette
/
content
/
event
.
js
"
interaction
:
"
chrome
:
/
/
marionette
/
content
/
interaction
.
js
"
legacyaction
:
"
chrome
:
/
/
marionette
/
content
/
legacyaction
.
js
"
Log
:
"
chrome
:
/
/
marionette
/
content
/
log
.
js
"
navigate
:
"
chrome
:
/
/
marionette
/
content
/
navigate
.
js
"
PageLoadStrategy
:
"
chrome
:
/
/
marionette
/
content
/
capabilities
.
js
"
pprint
:
"
chrome
:
/
/
marionette
/
content
/
format
.
js
"
proxy
:
"
chrome
:
/
/
marionette
/
content
/
proxy
.
js
"
sandbox
:
"
chrome
:
/
/
marionette
/
content
/
evaluate
.
js
"
Sandboxes
:
"
chrome
:
/
/
marionette
/
content
/
evaluate
.
js
"
truncate
:
"
chrome
:
/
/
marionette
/
content
/
format
.
js
"
WebElement
:
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
getWithPrefix
(
contentId
)
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
const
contentFrameMessageManager
=
this
;
const
contentId
=
content
.
docShell
.
browsingContext
.
id
;
const
curContainer
=
{
_frame
:
null
_parentFrame
:
null
shadowRoot
:
null
get
frame
(
)
{
return
this
.
_frame
;
}
set
frame
(
frame
)
{
this
.
_frame
=
frame
;
this
.
_parentFrame
=
frame
.
parent
;
this
.
id
=
frame
.
browsingContext
.
id
;
this
.
shadowRoot
=
null
;
}
get
parentFrame
(
)
{
return
this
.
_parentFrame
;
}
}
;
addEventListener
(
"
click
"
event
.
DoubleClickTracker
.
setClick
)
;
addEventListener
(
"
dblclick
"
event
.
DoubleClickTracker
.
resetClick
)
;
addEventListener
(
"
unload
"
event
.
DoubleClickTracker
.
resetClick
true
)
;
const
seenEls
=
new
element
.
Store
(
)
;
Object
.
defineProperty
(
this
"
capabilities
"
{
get
(
)
{
let
payload
=
sendSyncMessage
(
"
Marionette
:
WebDriver
:
GetCapabilities
"
)
;
return
Capabilities
.
fromJSON
(
payload
[
0
]
)
;
}
configurable
:
true
}
)
;
let
legacyactions
=
new
legacyaction
.
Chain
(
)
;
let
multiLast
=
{
}
;
const
sandboxes
=
new
Sandboxes
(
(
)
=
>
curContainer
.
frame
)
;
const
eventObservers
=
new
ContentEventObserverService
(
content
sendAsyncMessage
.
bind
(
this
)
)
;
function
dispatch
(
fn
)
{
if
(
typeof
fn
!
=
"
function
"
)
{
throw
new
TypeError
(
"
Provided
dispatch
handler
is
not
a
function
"
)
;
}
return
msg
=
>
{
const
id
=
msg
.
json
.
commandID
;
let
req
=
new
Promise
(
resolve
=
>
{
const
args
=
evaluate
.
fromJSON
(
msg
.
json
seenEls
curContainer
.
frame
)
;
let
rv
;
if
(
typeof
args
=
=
"
undefined
"
|
|
args
instanceof
Array
)
{
rv
=
fn
.
apply
(
null
args
)
;
}
else
{
rv
=
fn
(
args
)
;
}
resolve
(
rv
)
;
}
)
;
req
.
then
(
rv
=
>
sendResponse
(
rv
id
)
err
=
>
sendError
(
err
id
)
)
.
catch
(
err
=
>
sendError
(
err
id
)
)
;
}
;
}
let
clickElementFn
=
dispatch
(
clickElement
)
;
let
getActiveElementFn
=
dispatch
(
getActiveElement
)
;
let
getBrowsingContextIdFn
=
dispatch
(
getBrowsingContextId
)
;
let
getCurrentUrlFn
=
dispatch
(
getCurrentUrl
)
;
let
getElementAttributeFn
=
dispatch
(
getElementAttribute
)
;
let
getElementPropertyFn
=
dispatch
(
getElementProperty
)
;
let
getElementTextFn
=
dispatch
(
getElementText
)
;
let
getElementTagNameFn
=
dispatch
(
getElementTagName
)
;
let
getElementRectFn
=
dispatch
(
getElementRect
)
;
let
getPageSourceFn
=
dispatch
(
getPageSource
)
;
let
getScreenshotRectFn
=
dispatch
(
getScreenshotRect
)
;
let
isElementEnabledFn
=
dispatch
(
isElementEnabled
)
;
let
findElementContentFn
=
dispatch
(
findElementContent
)
;
let
findElementsContentFn
=
dispatch
(
findElementsContent
)
;
let
isElementSelectedFn
=
dispatch
(
isElementSelected
)
;
let
clearElementFn
=
dispatch
(
clearElement
)
;
let
isElementDisplayedFn
=
dispatch
(
isElementDisplayed
)
;
let
getElementValueOfCssPropertyFn
=
dispatch
(
getElementValueOfCssProperty
)
;
let
switchToShadowRootFn
=
dispatch
(
switchToShadowRoot
)
;
let
singleTapFn
=
dispatch
(
singleTap
)
;
let
performActionsFn
=
dispatch
(
performActions
)
;
let
releaseActionsFn
=
dispatch
(
releaseActions
)
;
let
actionChainFn
=
dispatch
(
actionChain
)
;
let
multiActionFn
=
dispatch
(
multiAction
)
;
let
executeFn
=
dispatch
(
execute
)
;
let
executeInSandboxFn
=
dispatch
(
executeInSandbox
)
;
let
sendKeysToElementFn
=
dispatch
(
sendKeysToElement
)
;
let
reftestWaitFn
=
dispatch
(
reftestWait
)
;
function
startListeners
(
)
{
eventDispatcher
.
enable
(
)
;
addMessageListener
(
"
Marionette
:
actionChain
"
actionChainFn
)
;
addMessageListener
(
"
Marionette
:
clearElement
"
clearElementFn
)
;
addMessageListener
(
"
Marionette
:
clickElement
"
clickElementFn
)
;
addMessageListener
(
"
Marionette
:
Deregister
"
deregister
)
;
addMessageListener
(
"
Marionette
:
DOM
:
AddEventListener
"
domAddEventListener
)
;
addMessageListener
(
"
Marionette
:
DOM
:
RemoveEventListener
"
domRemoveEventListener
)
;
addMessageListener
(
"
Marionette
:
execute
"
executeFn
)
;
addMessageListener
(
"
Marionette
:
executeInSandbox
"
executeInSandboxFn
)
;
addMessageListener
(
"
Marionette
:
findElementContent
"
findElementContentFn
)
;
addMessageListener
(
"
Marionette
:
findElementsContent
"
findElementsContentFn
)
;
addMessageListener
(
"
Marionette
:
getActiveElement
"
getActiveElementFn
)
;
addMessageListener
(
"
Marionette
:
getBrowsingContextId
"
getBrowsingContextIdFn
)
;
addMessageListener
(
"
Marionette
:
getCurrentUrl
"
getCurrentUrlFn
)
;
addMessageListener
(
"
Marionette
:
getElementAttribute
"
getElementAttributeFn
)
;
addMessageListener
(
"
Marionette
:
getElementProperty
"
getElementPropertyFn
)
;
addMessageListener
(
"
Marionette
:
getElementRect
"
getElementRectFn
)
;
addMessageListener
(
"
Marionette
:
getElementTagName
"
getElementTagNameFn
)
;
addMessageListener
(
"
Marionette
:
getElementText
"
getElementTextFn
)
;
addMessageListener
(
"
Marionette
:
getElementValueOfCssProperty
"
getElementValueOfCssPropertyFn
)
;
addMessageListener
(
"
Marionette
:
getPageSource
"
getPageSourceFn
)
;
addMessageListener
(
"
Marionette
:
getScreenshotRect
"
getScreenshotRectFn
)
;
addMessageListener
(
"
Marionette
:
isElementDisplayed
"
isElementDisplayedFn
)
;
addMessageListener
(
"
Marionette
:
isElementEnabled
"
isElementEnabledFn
)
;
addMessageListener
(
"
Marionette
:
isElementSelected
"
isElementSelectedFn
)
;
addMessageListener
(
"
Marionette
:
multiAction
"
multiActionFn
)
;
addMessageListener
(
"
Marionette
:
performActions
"
performActionsFn
)
;
addMessageListener
(
"
Marionette
:
reftestWait
"
reftestWaitFn
)
;
addMessageListener
(
"
Marionette
:
releaseActions
"
releaseActionsFn
)
;
addMessageListener
(
"
Marionette
:
sendKeysToElement
"
sendKeysToElementFn
)
;
addMessageListener
(
"
Marionette
:
Session
:
Delete
"
deleteSession
)
;
addMessageListener
(
"
Marionette
:
singleTap
"
singleTapFn
)
;
addMessageListener
(
"
Marionette
:
switchToFrame
"
switchToFrame
)
;
addMessageListener
(
"
Marionette
:
switchToParentFrame
"
switchToParentFrame
)
;
addMessageListener
(
"
Marionette
:
switchToShadowRoot
"
switchToShadowRootFn
)
;
}
function
deregister
(
)
{
eventDispatcher
.
disable
(
)
;
removeMessageListener
(
"
Marionette
:
actionChain
"
actionChainFn
)
;
removeMessageListener
(
"
Marionette
:
clearElement
"
clearElementFn
)
;
removeMessageListener
(
"
Marionette
:
clickElement
"
clickElementFn
)
;
removeMessageListener
(
"
Marionette
:
Deregister
"
deregister
)
;
removeMessageListener
(
"
Marionette
:
execute
"
executeFn
)
;
removeMessageListener
(
"
Marionette
:
executeInSandbox
"
executeInSandboxFn
)
;
removeMessageListener
(
"
Marionette
:
findElementContent
"
findElementContentFn
)
;
removeMessageListener
(
"
Marionette
:
findElementsContent
"
findElementsContentFn
)
;
removeMessageListener
(
"
Marionette
:
getActiveElement
"
getActiveElementFn
)
;
removeMessageListener
(
"
Marionette
:
getBrowsingContextId
"
getBrowsingContextIdFn
)
;
removeMessageListener
(
"
Marionette
:
getCurrentUrl
"
getCurrentUrlFn
)
;
removeMessageListener
(
"
Marionette
:
getElementAttribute
"
getElementAttributeFn
)
;
removeMessageListener
(
"
Marionette
:
getElementProperty
"
getElementPropertyFn
)
;
removeMessageListener
(
"
Marionette
:
getElementRect
"
getElementRectFn
)
;
removeMessageListener
(
"
Marionette
:
getElementTagName
"
getElementTagNameFn
)
;
removeMessageListener
(
"
Marionette
:
getElementText
"
getElementTextFn
)
;
removeMessageListener
(
"
Marionette
:
getElementValueOfCssProperty
"
getElementValueOfCssPropertyFn
)
;
removeMessageListener
(
"
Marionette
:
getPageSource
"
getPageSourceFn
)
;
removeMessageListener
(
"
Marionette
:
getScreenshotRect
"
getScreenshotRectFn
)
;
removeMessageListener
(
"
Marionette
:
isElementDisplayed
"
isElementDisplayedFn
)
;
removeMessageListener
(
"
Marionette
:
isElementEnabled
"
isElementEnabledFn
)
;
removeMessageListener
(
"
Marionette
:
isElementSelected
"
isElementSelectedFn
)
;
removeMessageListener
(
"
Marionette
:
multiAction
"
multiActionFn
)
;
removeMessageListener
(
"
Marionette
:
performActions
"
performActionsFn
)
;
removeMessageListener
(
"
Marionette
:
releaseActions
"
releaseActionsFn
)
;
removeMessageListener
(
"
Marionette
:
sendKeysToElement
"
sendKeysToElementFn
)
;
removeMessageListener
(
"
Marionette
:
Session
:
Delete
"
deleteSession
)
;
removeMessageListener
(
"
Marionette
:
singleTap
"
singleTapFn
)
;
removeMessageListener
(
"
Marionette
:
switchToFrame
"
switchToFrame
)
;
removeMessageListener
(
"
Marionette
:
switchToParentFrame
"
switchToParentFrame
)
;
removeMessageListener
(
"
Marionette
:
switchToShadowRoot
"
switchToShadowRootFn
)
;
}
function
deleteSession
(
)
{
seenEls
.
clear
(
)
;
curContainer
.
frame
=
content
;
curContainer
.
frame
.
focus
(
)
;
legacyactions
.
touchIds
=
{
}
;
if
(
action
.
inputStateMap
!
=
=
undefined
)
{
action
.
inputStateMap
.
clear
(
)
;
}
if
(
action
.
inputsToCancel
!
=
=
undefined
)
{
action
.
inputsToCancel
.
length
=
0
;
}
}
let
sendToServer
=
(
uuid
data
=
undefined
)
=
>
{
let
channel
=
new
proxy
.
AsyncMessageChannel
(
sendAsyncMessage
.
bind
(
this
)
)
;
channel
.
reply
(
uuid
data
)
;
}
;
function
sendResponse
(
obj
uuid
)
{
let
payload
=
evaluate
.
toJSON
(
obj
seenEls
)
;
sendToServer
(
uuid
payload
)
;
}
function
sendOk
(
uuid
)
{
sendToServer
(
uuid
)
;
}
function
sendError
(
err
uuid
)
{
sendToServer
(
uuid
err
)
;
}
async
function
execute
(
script
args
opts
)
{
let
sb
=
sandbox
.
createMutable
(
curContainer
.
frame
)
;
return
evaluate
.
sandbox
(
sb
script
args
opts
)
;
}
async
function
executeInSandbox
(
script
args
opts
)
{
let
sb
=
sandboxes
.
get
(
opts
.
sandboxName
opts
.
newSandbox
)
;
return
evaluate
.
sandbox
(
sb
script
args
opts
)
;
}
function
emitTouchEvent
(
type
touch
)
{
logger
.
info
(
Emitting
Touch
event
of
type
{
type
}
+
to
element
with
id
:
{
touch
.
target
.
id
}
+
and
tag
name
:
{
touch
.
target
.
tagName
}
+
at
coordinates
(
{
touch
.
clientX
}
)
+
{
touch
.
clientY
}
)
relative
to
the
viewport
)
;
const
win
=
curContainer
.
frame
;
if
(
win
.
docShell
.
asyncPanZoomEnabled
&
&
legacyactions
.
scrolling
)
{
let
ev
=
{
index
:
0
type
id
:
touch
.
identifier
clientX
:
touch
.
clientX
clientY
:
touch
.
clientY
screenX
:
touch
.
screenX
screenY
:
touch
.
screenY
radiusX
:
touch
.
radiusX
radiusY
:
touch
.
radiusY
rotation
:
touch
.
rotationAngle
force
:
touch
.
force
}
;
sendSyncMessage
(
"
Marionette
:
emitTouchEvent
"
ev
)
;
return
;
}
win
.
windowUtils
.
sendTouchEvent
(
type
[
touch
.
identifier
]
[
touch
.
clientX
]
[
touch
.
clientY
]
[
touch
.
radiusX
]
[
touch
.
radiusY
]
[
touch
.
rotationAngle
]
[
touch
.
force
]
0
)
;
}
async
function
singleTap
(
el
corx
cory
)
{
let
visible
=
element
.
isVisible
(
el
corx
cory
)
;
if
(
!
visible
)
{
throw
new
error
.
ElementNotInteractableError
(
"
Element
is
not
currently
visible
and
may
not
be
manipulated
"
)
;
}
let
a11y
=
accessibility
.
get
(
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
let
acc
=
await
a11y
.
getAccessible
(
el
true
)
;
a11y
.
assertVisible
(
acc
el
visible
)
;
a11y
.
assertActionable
(
acc
el
)
;
if
(
!
curContainer
.
frame
.
document
.
createTouch
)
{
legacyactions
.
mouseEventsOnly
=
true
;
}
let
c
=
element
.
coordinates
(
el
corx
cory
)
;
if
(
!
legacyactions
.
mouseEventsOnly
)
{
let
touchId
=
legacyactions
.
nextTouchId
+
+
;
let
touch
=
createATouch
(
el
c
.
x
c
.
y
touchId
)
;
emitTouchEvent
(
"
touchstart
"
touch
)
;
emitTouchEvent
(
"
touchend
"
touch
)
;
}
legacyactions
.
mouseTap
(
el
.
ownerDocument
c
.
x
c
.
y
)
;
}
function
createATouch
(
el
corx
cory
touchId
)
{
let
doc
=
el
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
[
clientX
clientY
pageX
pageY
screenX
screenY
]
=
legacyactions
.
getCoordinateInfo
(
el
corx
cory
)
;
let
atouch
=
doc
.
createTouch
(
win
el
touchId
pageX
pageY
screenX
screenY
clientX
clientY
)
;
return
atouch
;
}
async
function
performActions
(
msg
)
{
let
chain
=
action
.
Chain
.
fromJSON
(
msg
.
actions
)
;
await
action
.
dispatch
(
chain
curContainer
.
frame
!
capabilities
.
get
(
"
moz
:
useNonSpecCompliantPointerOrigin
"
)
)
;
}
async
function
releaseActions
(
)
{
await
action
.
dispatchTickActions
(
action
.
inputsToCancel
.
reverse
(
)
0
curContainer
.
frame
)
;
action
.
inputsToCancel
.
length
=
0
;
action
.
inputStateMap
.
clear
(
)
;
event
.
DoubleClickTracker
.
resetClick
(
)
;
}
function
actionChain
(
chain
touchId
)
{
let
touchProvider
=
{
}
;
touchProvider
.
createATouch
=
createATouch
;
touchProvider
.
emitTouchEvent
=
emitTouchEvent
;
return
legacyactions
.
dispatchActions
(
chain
touchId
curContainer
seenEls
touchProvider
)
;
}
function
emitMultiEvents
(
type
touch
touches
)
{
let
target
=
touch
.
target
;
let
doc
=
target
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
documentTouches
=
doc
.
createTouchList
(
touches
.
filter
(
function
(
t
)
{
return
t
.
target
.
ownerDocument
=
=
=
doc
&
&
type
!
=
"
touchcancel
"
;
}
)
)
;
let
targetTouches
=
doc
.
createTouchList
(
touches
.
filter
(
function
(
t
)
{
return
(
t
.
target
=
=
=
target
&
&
(
type
!
=
"
touchcancel
"
|
|
type
!
=
"
touchend
"
)
)
;
}
)
)
;
let
changedTouches
=
doc
.
createTouchList
(
touch
)
;
let
event
=
doc
.
createEvent
(
"
TouchEvent
"
)
;
event
.
initTouchEvent
(
type
true
true
win
0
false
false
false
false
documentTouches
targetTouches
changedTouches
)
;
target
.
dispatchEvent
(
event
)
;
}
function
setDispatch
(
batches
touches
batchIndex
=
0
)
{
if
(
batchIndex
>
=
batches
.
length
)
{
multiLast
=
{
}
;
return
;
}
let
batch
=
batches
[
batchIndex
]
;
let
pack
;
let
touchId
;
let
command
;
let
el
;
let
touch
;
let
lastTouch
;
let
touchIndex
;
let
waitTime
=
0
;
let
maxTime
=
0
;
let
c
;
batchIndex
+
+
;
for
(
let
i
=
0
;
i
<
batch
.
length
;
i
+
+
)
{
pack
=
batch
[
i
]
;
touchId
=
pack
[
0
]
;
command
=
pack
[
1
]
;
switch
(
command
)
{
case
"
press
"
:
el
=
seenEls
.
get
(
pack
[
2
]
curContainer
.
frame
)
;
c
=
element
.
coordinates
(
el
pack
[
3
]
pack
[
4
]
)
;
touch
=
createATouch
(
el
c
.
x
c
.
y
touchId
)
;
multiLast
[
touchId
]
=
touch
;
touches
.
push
(
touch
)
;
emitMultiEvents
(
"
touchstart
"
touch
touches
)
;
break
;
case
"
release
"
:
touch
=
multiLast
[
touchId
]
;
touchIndex
=
touches
.
indexOf
(
touch
)
;
touches
.
splice
(
touchIndex
1
)
;
emitMultiEvents
(
"
touchend
"
touch
touches
)
;
break
;
case
"
move
"
:
el
=
seenEls
.
get
(
pack
[
2
]
curContainer
.
frame
)
;
c
=
element
.
coordinates
(
el
)
;
touch
=
createATouch
(
multiLast
[
touchId
]
.
target
c
.
x
c
.
y
touchId
)
;
touchIndex
=
touches
.
indexOf
(
lastTouch
)
;
touches
[
touchIndex
]
=
touch
;
multiLast
[
touchId
]
=
touch
;
emitMultiEvents
(
"
touchmove
"
touch
touches
)
;
break
;
case
"
moveByOffset
"
:
el
=
multiLast
[
touchId
]
.
target
;
lastTouch
=
multiLast
[
touchId
]
;
touchIndex
=
touches
.
indexOf
(
lastTouch
)
;
let
doc
=
el
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
clientX
=
lastTouch
.
clientX
+
pack
[
2
]
;
let
clientY
=
lastTouch
.
clientY
+
pack
[
3
]
;
let
pageX
=
clientX
+
win
.
pageXOffset
;
let
pageY
=
clientY
+
win
.
pageYOffset
;
let
screenX
=
clientX
+
win
.
mozInnerScreenX
;
let
screenY
=
clientY
+
win
.
mozInnerScreenY
;
touch
=
doc
.
createTouch
(
win
el
touchId
pageX
pageY
screenX
screenY
clientX
clientY
)
;
touches
[
touchIndex
]
=
touch
;
multiLast
[
touchId
]
=
touch
;
emitMultiEvents
(
"
touchmove
"
touch
touches
)
;
break
;
case
"
wait
"
:
if
(
typeof
pack
[
2
]
!
=
"
undefined
"
)
{
waitTime
=
pack
[
2
]
*
1000
;
if
(
waitTime
>
maxTime
)
{
maxTime
=
waitTime
;
}
}
break
;
}
}
if
(
maxTime
!
=
0
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
function
(
)
{
setDispatch
(
batches
touches
batchIndex
)
;
}
maxTime
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
{
setDispatch
(
batches
touches
batchIndex
)
;
}
}
function
multiAction
(
args
maxLen
)
{
let
commandArray
=
evaluate
.
fromJSON
(
args
seenEls
curContainer
.
frame
)
;
let
concurrentEvent
=
[
]
;
let
temp
;
for
(
let
i
=
0
;
i
<
maxLen
;
i
+
+
)
{
let
row
=
[
]
;
for
(
let
j
=
0
;
j
<
commandArray
.
length
;
j
+
+
)
{
if
(
typeof
commandArray
[
j
]
[
i
]
!
=
"
undefined
"
)
{
temp
=
commandArray
[
j
]
[
i
]
;
temp
.
unshift
(
j
)
;
row
.
push
(
temp
)
;
}
}
concurrentEvent
.
push
(
row
)
;
}
let
pendingTouches
=
[
]
;
setDispatch
(
concurrentEvent
pendingTouches
)
;
}
function
getPageSource
(
)
{
return
curContainer
.
frame
.
document
.
documentElement
.
outerHTML
;
}
async
function
findElementContent
(
strategy
selector
opts
=
{
}
)
{
opts
.
all
=
false
;
let
el
=
await
element
.
find
(
curContainer
strategy
selector
opts
)
;
return
seenEls
.
add
(
el
)
;
}
async
function
findElementsContent
(
strategy
selector
opts
=
{
}
)
{
opts
.
all
=
true
;
let
els
=
await
element
.
find
(
curContainer
strategy
selector
opts
)
;
let
webEls
=
seenEls
.
addAll
(
els
)
;
return
webEls
;
}
function
getActiveElement
(
)
{
let
el
=
curContainer
.
frame
.
document
.
activeElement
;
if
(
!
el
)
{
throw
new
error
.
NoSuchElementError
(
)
;
}
return
evaluate
.
toJSON
(
el
seenEls
)
;
}
function
getBrowsingContextId
(
topContext
=
false
)
{
const
bc
=
curContainer
.
frame
.
docShell
.
browsingContext
;
return
topContext
?
bc
.
top
.
id
:
bc
.
id
;
}
function
getCurrentUrl
(
)
{
return
content
.
location
.
href
;
}
function
clickElement
(
el
)
{
return
interaction
.
clickElement
(
el
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
capabilities
.
get
(
"
moz
:
webdriverClick
"
)
)
;
}
function
getElementAttribute
(
el
name
)
{
if
(
element
.
isBooleanAttribute
(
el
name
)
)
{
if
(
el
.
hasAttribute
(
name
)
)
{
return
"
true
"
;
}
return
null
;
}
return
el
.
getAttribute
(
name
)
;
}
function
getElementProperty
(
el
name
)
{
return
typeof
el
[
name
]
!
=
"
undefined
"
?
el
[
name
]
:
null
;
}
function
getElementText
(
el
)
{
return
atom
.
getElementText
(
el
curContainer
.
frame
)
;
}
function
getElementTagName
(
el
)
{
return
el
.
tagName
.
toLowerCase
(
)
;
}
function
isElementDisplayed
(
el
)
{
return
interaction
.
isElementDisplayed
(
el
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
}
function
getElementValueOfCssProperty
(
el
prop
)
{
let
st
=
curContainer
.
frame
.
document
.
defaultView
.
getComputedStyle
(
el
)
;
return
st
.
getPropertyValue
(
prop
)
;
}
function
getElementRect
(
el
)
{
let
clientRect
=
el
.
getBoundingClientRect
(
)
;
return
{
x
:
clientRect
.
x
+
curContainer
.
frame
.
pageXOffset
y
:
clientRect
.
y
+
curContainer
.
frame
.
pageYOffset
width
:
clientRect
.
width
height
:
clientRect
.
height
}
;
}
function
isElementEnabled
(
el
)
{
return
interaction
.
isElementEnabled
(
el
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
}
function
isElementSelected
(
el
)
{
return
interaction
.
isElementSelected
(
el
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
}
async
function
sendKeysToElement
(
el
val
)
{
let
opts
=
{
strictFileInteractability
:
capabilities
.
get
(
"
strictFileInteractability
"
)
accessibilityChecks
:
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
webdriverClick
:
capabilities
.
get
(
"
moz
:
webdriverClick
"
)
}
;
await
interaction
.
sendKeysToElement
(
el
val
opts
)
;
}
function
clearElement
(
el
)
{
interaction
.
clearElement
(
el
)
;
}
function
switchToShadowRoot
(
el
)
{
if
(
!
element
.
isElement
(
el
)
)
{
if
(
curContainer
.
shadowRoot
)
{
let
parent
;
try
{
parent
=
curContainer
.
shadowRoot
.
host
;
}
catch
(
e
)
{
curContainer
.
shadowRoot
=
null
;
return
;
}
while
(
parent
&
&
!
(
parent
instanceof
curContainer
.
frame
.
ShadowRoot
)
)
{
parent
=
parent
.
parentNode
;
}
curContainer
.
shadowRoot
=
parent
;
}
return
;
}
let
foundShadowRoot
=
el
.
shadowRoot
;
if
(
!
foundShadowRoot
)
{
throw
new
error
.
NoSuchElementError
(
pprint
Unable
to
locate
shadow
root
:
{
el
}
)
;
}
curContainer
.
shadowRoot
=
foundShadowRoot
;
}
function
switchToParentFrame
(
msg
)
{
curContainer
.
frame
=
curContainer
.
parentFrame
;
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
browsingContextId
:
curContainer
.
id
}
)
;
sendOk
(
msg
.
json
.
commandID
)
;
}
function
switchToFrame
(
{
json
}
)
{
let
{
commandID
element
focus
id
}
=
json
;
let
foundFrame
;
let
wantedFrame
=
null
;
let
frames
=
[
]
;
try
{
frames
=
curContainer
.
frame
.
frames
;
}
catch
(
e
)
{
id
=
null
;
element
=
null
;
}
if
(
id
=
=
null
&
&
!
element
)
{
curContainer
.
frame
=
content
;
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
browsingContextId
:
curContainer
.
id
}
)
;
if
(
focus
)
{
curContainer
.
frame
.
focus
(
)
;
}
sendOk
(
commandID
)
;
return
;
}
let
webEl
;
if
(
typeof
element
!
=
"
undefined
"
)
{
webEl
=
WebElement
.
fromUUID
(
element
"
content
"
)
;
}
if
(
webEl
)
{
if
(
!
seenEls
.
has
(
webEl
)
)
{
let
err
=
new
error
.
NoSuchElementError
(
Unable
to
locate
element
:
{
webEl
}
)
;
sendError
(
err
commandID
)
;
return
;
}
try
{
wantedFrame
=
seenEls
.
get
(
webEl
curContainer
.
frame
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
return
;
}
if
(
frames
.
length
>
0
)
{
let
wrappedWanted
=
new
XPCNativeWrapper
(
wantedFrame
)
;
foundFrame
=
Array
.
prototype
.
find
.
call
(
frames
frame
=
>
{
return
new
XPCNativeWrapper
(
frame
.
frameElement
)
=
=
=
wrappedWanted
;
}
)
;
}
if
(
!
foundFrame
)
{
let
iframes
=
curContainer
.
frame
.
document
.
getElementsByTagName
(
"
iframe
"
)
;
let
wrappedWanted
=
new
XPCNativeWrapper
(
wantedFrame
)
;
foundFrame
=
Array
.
prototype
.
find
.
call
(
iframes
frame
=
>
{
return
new
XPCNativeWrapper
(
frame
)
=
=
=
wrappedWanted
;
}
)
;
}
}
if
(
!
foundFrame
)
{
if
(
typeof
id
=
=
=
"
number
"
)
{
try
{
let
frameEl
;
if
(
id
>
=
0
&
&
id
<
frames
.
length
)
{
frameEl
=
frames
[
id
]
.
frameElement
;
if
(
frameEl
!
=
=
null
)
{
foundFrame
=
frameEl
.
contentWindow
;
}
else
{
curContainer
.
frame
=
content
;
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
browsingContextId
:
curContainer
.
id
}
)
;
if
(
focus
)
{
curContainer
.
frame
.
focus
(
)
;
}
sendOk
(
commandID
)
;
return
;
}
}
}
catch
(
e
)
{
let
iframes
=
foundFrame
.
document
.
getElementsByTagName
(
"
iframe
"
)
;
if
(
id
>
=
0
&
&
id
<
iframes
.
length
)
{
foundFrame
=
iframes
[
id
]
;
}
}
}
}
if
(
!
foundFrame
)
{
let
failedFrame
=
id
|
|
element
;
let
err
=
new
error
.
NoSuchFrameError
(
Unable
to
locate
frame
:
{
failedFrame
}
)
;
sendError
(
err
commandID
)
;
return
;
}
curContainer
.
frame
=
foundFrame
;
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
browsingContextId
:
curContainer
.
id
}
)
;
if
(
focus
)
{
curContainer
.
frame
.
focus
(
)
;
}
sendOk
(
commandID
)
;
}
function
getScreenshotRect
(
{
el
full
=
true
scroll
=
true
}
=
{
}
)
{
let
win
=
el
?
curContainer
.
frame
:
content
;
let
rect
;
if
(
el
)
{
if
(
scroll
)
{
element
.
scrollIntoView
(
el
)
;
}
rect
=
getElementRect
(
el
)
;
}
else
if
(
full
)
{
const
docEl
=
win
.
document
.
documentElement
;
rect
=
new
DOMRect
(
0
0
docEl
.
scrollWidth
docEl
.
scrollHeight
)
;
}
else
{
rect
=
new
DOMRect
(
win
.
pageXOffset
win
.
pageYOffset
win
.
innerWidth
win
.
innerHeight
)
;
}
return
rect
;
}
function
flushRendering
(
)
{
let
content
=
curContainer
.
frame
;
let
anyPendingPaintsGeneratedInDescendants
=
false
;
let
windowUtils
=
content
.
windowUtils
;
function
flushWindow
(
win
)
{
let
utils
=
win
.
windowUtils
;
let
afterPaintWasPending
=
utils
.
isMozAfterPaintPending
;
let
root
=
win
.
document
.
documentElement
;
if
(
root
)
{
try
{
root
.
getBoundingClientRect
(
)
;
}
catch
(
e
)
{
logger
.
error
(
"
flushWindow
failed
"
e
)
;
}
}
if
(
!
afterPaintWasPending
&
&
utils
.
isMozAfterPaintPending
)
{
anyPendingPaintsGeneratedInDescendants
=
true
;
}
for
(
let
i
=
0
;
i
<
win
.
frames
.
length
;
+
+
i
)
{
flushWindow
(
win
.
frames
[
i
]
)
;
}
}
flushWindow
(
content
)
;
if
(
anyPendingPaintsGeneratedInDescendants
&
&
!
windowUtils
.
isMozAfterPaintPending
)
{
logger
.
error
(
"
Descendant
frame
generated
a
MozAfterPaint
event
"
+
"
but
the
root
document
doesn
'
t
have
one
!
"
)
;
}
}
async
function
reftestWait
(
url
remote
)
{
let
win
=
curContainer
.
frame
;
let
document
=
curContainer
.
frame
.
document
;
let
reftestWait
;
if
(
document
.
location
.
href
!
=
=
url
|
|
document
.
readyState
!
=
"
complete
"
)
{
reftestWait
=
await
documentLoad
(
win
url
)
;
win
=
curContainer
.
frame
;
document
=
curContainer
.
frame
.
document
;
}
else
{
reftestWait
=
document
.
documentElement
.
classList
.
contains
(
"
reftest
-
wait
"
)
;
}
logger
.
debug
(
"
Waiting
for
event
loop
to
spin
"
)
;
await
new
Promise
(
resolve
=
>
win
.
setTimeout
(
resolve
0
)
)
;
await
paintComplete
(
win
remote
)
;
let
root
=
document
.
documentElement
;
if
(
reftestWait
)
{
let
event
=
new
Event
(
"
TestRendered
"
{
bubbles
:
true
}
)
;
root
.
dispatchEvent
(
event
)
;
logger
.
info
(
"
Emitted
TestRendered
event
"
)
;
await
reftestWaitRemoved
(
win
root
)
;
await
paintComplete
(
win
remote
)
;
}
if
(
win
.
innerWidth
<
document
.
documentElement
.
scrollWidth
|
|
win
.
innerHeight
<
document
.
documentElement
.
scrollHeight
)
{
logger
.
warn
(
{
url
}
overflows
viewport
(
width
:
{
document
.
documentElement
.
scrollWidth
}
height
:
{
document
.
documentElement
.
scrollHeight
}
)
)
;
}
}
function
documentLoad
(
win
url
)
{
logger
.
debug
(
truncate
Waiting
for
page
load
of
{
url
}
)
;
return
new
Promise
(
resolve
=
>
{
let
maybeResolve
=
event
=
>
{
if
(
event
.
target
=
=
=
curContainer
.
frame
.
document
&
&
event
.
target
.
location
.
href
=
=
=
url
)
{
let
reftestWait
=
win
.
document
.
documentElement
.
classList
.
contains
(
"
reftest
-
wait
"
)
;
removeEventListener
(
"
load
"
maybeResolve
{
once
:
true
}
)
;
resolve
(
reftestWait
)
;
}
}
;
addEventListener
(
"
load
"
maybeResolve
true
)
;
}
)
;
}
function
paintComplete
(
win
remote
)
{
logger
.
debug
(
"
Waiting
for
rendering
"
)
;
let
windowUtils
=
content
.
windowUtils
;
return
new
Promise
(
resolve
=
>
{
let
maybeResolve
=
(
)
=
>
{
flushRendering
(
)
;
if
(
remote
)
{
logger
.
debug
(
"
Force
update
of
layer
tree
"
)
;
windowUtils
.
updateLayerTree
(
)
;
}
if
(
windowUtils
.
isMozAfterPaintPending
)
{
logger
.
debug
(
"
isMozAfterPaintPending
:
true
"
)
;
win
.
addEventListener
(
"
MozAfterPaint
"
maybeResolve
{
once
:
true
}
)
;
}
else
{
logger
.
debug
(
"
isMozAfterPaintPending
:
false
"
)
;
win
.
requestAnimationFrame
(
(
)
=
>
{
win
.
requestAnimationFrame
(
resolve
)
;
}
)
;
}
}
;
maybeResolve
(
)
;
}
)
;
}
function
reftestWaitRemoved
(
win
root
)
{
logger
.
debug
(
"
Waiting
for
reftest
-
wait
removal
"
)
;
return
new
Promise
(
resolve
=
>
{
let
observer
=
new
win
.
MutationObserver
(
(
)
=
>
{
if
(
!
root
.
classList
.
contains
(
"
reftest
-
wait
"
)
)
{
observer
.
disconnect
(
)
;
logger
.
debug
(
"
reftest
-
wait
removed
"
)
;
win
.
setTimeout
(
resolve
0
)
;
}
}
)
;
if
(
root
.
classList
.
contains
(
"
reftest
-
wait
"
)
)
{
observer
.
observe
(
root
{
attributes
:
true
}
)
;
}
else
{
win
.
setTimeout
(
resolve
0
)
;
}
}
)
;
}
function
domAddEventListener
(
msg
)
{
eventObservers
.
add
(
msg
.
json
.
type
)
;
}
function
domRemoveEventListener
(
msg
)
{
eventObservers
.
remove
(
msg
.
json
.
type
)
;
}
const
eventDispatcher
=
{
enabled
:
false
enable
(
)
{
if
(
this
.
enabled
)
{
return
;
}
addEventListener
(
"
unload
"
this
false
)
;
addEventListener
(
"
beforeunload
"
this
true
)
;
addEventListener
(
"
pagehide
"
this
true
)
;
addEventListener
(
"
popstate
"
this
true
)
;
addEventListener
(
"
DOMContentLoaded
"
this
true
)
;
addEventListener
(
"
hashchange
"
this
true
)
;
addEventListener
(
"
pageshow
"
this
true
)
;
Services
.
obs
.
addObserver
(
this
"
webnavigation
-
destroy
"
)
;
this
.
enabled
=
true
;
}
disable
(
)
{
if
(
!
this
.
enabled
)
{
return
;
}
removeEventListener
(
"
unload
"
this
false
)
;
removeEventListener
(
"
beforeunload
"
this
true
)
;
removeEventListener
(
"
pagehide
"
this
true
)
;
removeEventListener
(
"
popstate
"
this
true
)
;
removeEventListener
(
"
DOMContentLoaded
"
this
true
)
;
removeEventListener
(
"
hashchange
"
this
true
)
;
removeEventListener
(
"
pageshow
"
this
true
)
;
try
{
Services
.
obs
.
removeObserver
(
this
"
webnavigation
-
destroy
"
)
;
}
catch
(
e
)
{
}
this
.
enabled
=
false
;
}
handleEvent
(
event
)
{
const
{
target
type
}
=
event
;
if
(
type
=
=
=
"
unload
"
&
&
target
=
=
=
contentFrameMessageManager
)
{
logger
.
trace
(
Frame
script
unloaded
)
;
sendAsyncMessage
(
"
Marionette
:
Unloaded
"
{
browsingContext
:
content
.
docShell
.
browsingContext
}
)
;
return
;
}
if
(
!
[
curContainer
.
frame
curContainer
.
frame
.
document
]
.
includes
(
target
)
)
{
return
;
}
if
(
type
=
=
=
"
pagehide
"
)
{
addEventListener
(
"
DOMContentLoaded
"
this
true
)
;
addEventListener
(
"
pageshow
"
this
true
)
;
}
sendAsyncMessage
(
"
Marionette
:
NavigationEvent
"
{
browsingContext
:
content
.
docShell
.
browsingContext
documentURI
:
target
.
documentURI
readyState
:
target
.
readyState
type
}
)
;
}
observe
(
subject
topic
)
{
subject
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
const
browsingContext
=
subject
.
browsingContext
;
const
isFrame
=
browsingContext
!
=
=
subject
.
browsingContext
.
top
;
if
(
isFrame
&
&
browsingContext
.
id
=
=
=
curContainer
.
id
)
{
logger
.
trace
(
Frame
with
id
{
browsingContext
.
id
}
got
removed
)
;
sendAsyncMessage
(
"
Marionette
:
FrameRemoved
"
{
browsingContextId
:
browsingContext
.
id
}
)
;
}
}
}
;
function
registerSelf
(
)
{
logger
.
trace
(
"
Frame
script
loaded
"
)
;
curContainer
.
frame
=
content
;
sandboxes
.
clear
(
)
;
legacyactions
.
mouseEventsOnly
=
false
;
action
.
inputStateMap
=
new
Map
(
)
;
action
.
inputsToCancel
=
[
]
;
let
reply
=
sendSyncMessage
(
"
Marionette
:
Register
"
{
frameId
:
contentId
}
)
;
if
(
reply
.
length
=
=
0
)
{
logger
.
error
(
"
No
reply
from
Marionette
:
Register
"
)
;
return
;
}
if
(
reply
[
0
]
.
frameId
=
=
=
contentId
)
{
startListeners
(
)
;
sendAsyncMessage
(
"
Marionette
:
ListenersAttached
"
{
frameId
:
contentId
}
)
;
}
}
registerSelf
(
)
;
