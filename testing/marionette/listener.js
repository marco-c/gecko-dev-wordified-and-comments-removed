"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
const
uuidGen
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
const
loader
=
Cc
[
"
mozilla
.
org
/
moz
/
jssubscript
-
loader
;
1
"
]
.
getService
(
Ci
.
mozIJSSubScriptLoader
)
;
const
winUtil
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
accessibility
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
action
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
atom
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
capture
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
)
;
const
{
ElementNotInteractableError
error
InsecureCertificateError
InvalidArgumentError
InvalidElementStateError
InvalidSelectorError
NoSuchElementError
NoSuchFrameError
TimeoutError
UnknownError
}
=
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
{
}
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
evaluate
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
event
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
interaction
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
legacyaction
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
navigate
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
proxy
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
session
.
js
"
)
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
let
marionetteTestName
;
let
listenerId
=
null
;
let
curContainer
=
{
frame
:
content
shadowRoot
:
null
}
;
let
previousContainer
=
null
;
const
seenEls
=
new
element
.
Store
(
)
;
const
SUPPORTED_STRATEGIES
=
new
Set
(
[
element
.
Strategy
.
ClassName
element
.
Strategy
.
Selector
element
.
Strategy
.
ID
element
.
Strategy
.
Name
element
.
Strategy
.
LinkText
element
.
Strategy
.
PartialLinkText
element
.
Strategy
.
TagName
element
.
Strategy
.
XPath
]
)
;
let
capabilities
;
let
legacyactions
=
new
legacyaction
.
Chain
(
checkForInterrupted
)
;
let
onunload
;
let
asyncTestRunning
=
false
;
let
asyncTestCommandId
;
let
asyncTestTimeoutId
;
let
inactivityTimeoutId
=
null
;
let
originalOnError
;
let
EVENT_INTERVAL
=
30
;
let
multiLast
=
{
}
;
const
asyncChrome
=
proxy
.
toChromeAsync
(
{
addMessageListener
:
addMessageListenerId
.
bind
(
this
)
removeMessageListener
:
removeMessageListenerId
.
bind
(
this
)
sendAsyncMessage
:
sendAsyncMessage
.
bind
(
this
)
}
)
;
const
syncChrome
=
proxy
.
toChrome
(
sendSyncMessage
.
bind
(
this
)
)
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
if
(
logger
.
ownAppenders
.
length
=
=
0
)
{
logger
.
addAppender
(
new
Log
.
DumpAppender
(
)
)
;
}
const
modalHandler
=
function
(
)
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
storePrevious
:
true
}
)
;
let
isLocal
=
sendSyncMessage
(
"
MarionetteFrame
:
handleModal
"
{
}
)
[
0
]
.
value
;
if
(
isLocal
)
{
previousContainer
=
curContainer
;
}
curContainer
=
{
frame
:
content
shadowRoot
:
null
}
;
}
;
const
sandboxes
=
new
Sandboxes
(
(
)
=
>
curContainer
.
frame
)
;
let
sandboxName
=
"
default
"
;
const
loadListener
=
{
commandID
:
null
seenBeforeUnload
:
false
seenUnload
:
false
timeout
:
null
timerPageLoad
:
null
timerPageUnload
:
null
start
(
commandID
timeout
startTime
waitForUnloaded
=
true
)
{
this
.
commandID
=
commandID
;
this
.
timeout
=
timeout
;
this
.
seenBeforeUnload
=
false
;
this
.
seenUnload
=
false
;
this
.
timerPageLoad
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
timerPageUnload
=
null
;
timeout
=
startTime
+
timeout
-
new
Date
(
)
.
getTime
(
)
;
if
(
timeout
<
=
0
)
{
this
.
notify
(
this
.
timerPageLoad
)
;
return
;
}
if
(
waitForUnloaded
)
{
addEventListener
(
"
hashchange
"
this
false
)
;
addEventListener
(
"
pagehide
"
this
false
)
;
addEventListener
(
"
popstate
"
this
false
)
;
curContainer
.
frame
.
addEventListener
(
"
beforeunload
"
this
)
;
curContainer
.
frame
.
addEventListener
(
"
unload
"
this
)
;
Services
.
obs
.
addObserver
(
this
"
outer
-
window
-
destroyed
"
)
;
}
else
{
let
readyState
=
content
.
document
.
readyState
;
let
documentURI
=
content
.
document
.
documentURI
;
logger
.
debug
(
Check
readyState
"
{
readyState
}
for
"
{
documentURI
}
"
)
;
if
(
this
.
handleReadyState
(
readyState
documentURI
)
)
{
return
;
}
addEventListener
(
"
DOMContentLoaded
"
loadListener
)
;
addEventListener
(
"
pageshow
"
loadListener
)
;
}
this
.
timerPageLoad
.
initWithCallback
(
this
timeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
stop
(
)
{
if
(
this
.
timerPageLoad
)
{
this
.
timerPageLoad
.
cancel
(
)
;
}
if
(
this
.
timerPageUnload
)
{
this
.
timerPageUnload
.
cancel
(
)
;
}
removeEventListener
(
"
hashchange
"
this
)
;
removeEventListener
(
"
pagehide
"
this
)
;
removeEventListener
(
"
popstate
"
this
)
;
removeEventListener
(
"
DOMContentLoaded
"
this
)
;
removeEventListener
(
"
pageshow
"
this
)
;
try
{
curContainer
.
frame
.
removeEventListener
(
"
beforeunload
"
this
)
;
curContainer
.
frame
.
removeEventListener
(
"
unload
"
this
)
;
}
catch
(
e
)
{
if
(
e
.
name
!
=
"
TypeError
"
)
{
throw
e
;
}
}
try
{
Services
.
obs
.
removeObserver
(
this
"
outer
-
window
-
destroyed
"
)
;
}
catch
(
e
)
{
}
}
handleEvent
(
event
)
{
if
(
event
.
target
!
=
curContainer
.
frame
&
&
event
.
target
!
=
curContainer
.
frame
.
document
)
{
return
;
}
let
location
=
event
.
target
.
documentURI
|
|
event
.
target
.
location
.
href
;
logger
.
debug
(
Received
DOM
event
"
{
event
.
type
}
"
for
"
{
location
}
"
)
;
switch
(
event
.
type
)
{
case
"
beforeunload
"
:
this
.
seenBeforeUnload
=
true
;
break
;
case
"
unload
"
:
this
.
seenUnload
=
true
;
break
;
case
"
pagehide
"
:
this
.
seenUnload
=
true
;
removeEventListener
(
"
hashchange
"
this
)
;
removeEventListener
(
"
pagehide
"
this
)
;
removeEventListener
(
"
popstate
"
this
)
;
addEventListener
(
"
DOMContentLoaded
"
this
false
)
;
addEventListener
(
"
pageshow
"
this
false
)
;
break
;
case
"
hashchange
"
:
case
"
popstate
"
:
this
.
stop
(
)
;
sendOk
(
this
.
commandID
)
;
break
;
case
"
DOMContentLoaded
"
:
case
"
pageshow
"
:
this
.
handleReadyState
(
event
.
target
.
readyState
event
.
target
.
documentURI
)
;
break
;
}
}
handleReadyState
(
readyState
documentURI
)
{
let
finished
=
false
;
switch
(
readyState
)
{
case
"
interactive
"
:
if
(
documentURI
.
startsWith
(
"
about
:
certerror
"
)
)
{
this
.
stop
(
)
;
sendError
(
new
InsecureCertificateError
(
)
this
.
commandID
)
;
finished
=
true
;
}
else
if
(
/
about
:
.
*
(
error
)
\
?
/
.
exec
(
documentURI
)
)
{
this
.
stop
(
)
;
sendError
(
new
UnknownError
(
Reached
error
page
:
{
documentURI
}
)
this
.
commandID
)
;
finished
=
true
;
}
else
if
(
(
capabilities
.
get
(
"
pageLoadStrategy
"
)
=
=
=
session
.
PageLoadStrategy
.
Eager
&
&
documentURI
!
=
"
about
:
blank
"
)
|
|
/
about
:
blocked
\
?
/
.
exec
(
documentURI
)
)
{
this
.
stop
(
)
;
sendOk
(
this
.
commandID
)
;
finished
=
true
;
}
break
;
case
"
complete
"
:
this
.
stop
(
)
;
sendOk
(
this
.
commandID
)
;
finished
=
true
;
break
;
}
return
finished
;
}
notify
(
timer
)
{
switch
(
timer
)
{
case
this
.
timerPageUnload
:
if
(
this
.
seenBeforeUnload
)
{
this
.
seenBeforeUnload
=
null
;
this
.
timerPageUnload
.
initWithCallback
(
this
5000
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
if
(
!
this
.
seenUnload
)
{
logger
.
debug
(
"
Canceled
page
load
listener
because
no
navigation
"
+
"
has
been
detected
"
)
;
this
.
stop
(
)
;
sendOk
(
this
.
commandID
)
;
}
break
;
case
this
.
timerPageLoad
:
this
.
stop
(
)
;
sendError
(
new
TimeoutError
(
Timeout
loading
page
after
{
this
.
timeout
}
ms
)
this
.
commandID
)
;
break
;
}
}
observe
(
subject
topic
data
)
{
const
win
=
curContainer
.
frame
;
const
winID
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
;
const
curWinID
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
logger
.
debug
(
Received
observer
notification
"
{
topic
}
"
for
"
{
winID
}
"
)
;
switch
(
topic
)
{
case
"
outer
-
window
-
destroyed
"
:
if
(
curWinID
=
=
=
winID
)
{
this
.
stop
(
)
;
sendOk
(
this
.
commandID
)
;
}
break
;
}
}
waitForLoadAfterFramescriptReload
(
commandID
timeout
startTime
)
{
this
.
start
(
commandID
timeout
startTime
false
)
;
}
navigate
(
trigger
commandID
timeout
loadEventExpected
=
true
useUnloadTimer
=
false
)
{
loadEventExpected
=
loadEventExpected
&
&
(
capabilities
.
get
(
"
pageLoadStrategy
"
)
!
=
=
session
.
PageLoadStrategy
.
None
)
;
if
(
loadEventExpected
)
{
let
startTime
=
new
Date
(
)
.
getTime
(
)
;
this
.
start
(
commandID
timeout
startTime
true
)
;
}
return
(
async
(
)
=
>
{
await
trigger
(
)
;
}
)
(
)
.
then
(
val
=
>
{
if
(
!
loadEventExpected
)
{
sendOk
(
commandID
)
;
return
;
}
if
(
useUnloadTimer
)
{
this
.
timerPageUnload
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
timerPageUnload
.
initWithCallback
(
this
200
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
}
)
.
catch
(
err
=
>
{
if
(
loadEventExpected
)
{
this
.
stop
(
)
;
}
sendError
(
err
commandID
)
;
}
)
;
}
}
;
function
registerSelf
(
)
{
let
msg
=
{
value
:
winUtil
.
outerWindowID
}
;
logger
.
debug
(
Register
listener
.
js
for
window
{
msg
.
value
}
)
;
let
register
=
sendSyncMessage
(
"
Marionette
:
register
"
msg
)
;
if
(
register
[
0
]
)
{
listenerId
=
register
[
0
]
[
0
]
;
capabilities
=
session
.
Capabilities
.
fromJSON
(
register
[
0
]
[
1
]
)
;
if
(
typeof
listenerId
!
=
"
undefined
"
)
{
startListeners
(
)
;
sendAsyncMessage
(
"
Marionette
:
listenersAttached
"
{
"
listenerId
"
:
listenerId
}
)
;
}
}
}
function
dispatch
(
fn
)
{
if
(
typeof
fn
!
=
"
function
"
)
{
throw
new
TypeError
(
"
Provided
dispatch
handler
is
not
a
function
"
)
;
}
return
function
(
msg
)
{
let
id
=
msg
.
json
.
commandID
;
let
req
=
(
async
(
)
=
>
{
if
(
typeof
msg
.
json
=
=
"
undefined
"
|
|
msg
.
json
instanceof
Array
)
{
return
fn
.
apply
(
null
msg
.
json
)
;
}
return
fn
(
msg
.
json
)
;
}
)
(
)
;
let
okOrValueResponse
=
rv
=
>
{
if
(
typeof
rv
=
=
"
undefined
"
)
{
sendOk
(
id
)
;
}
else
{
sendResponse
(
rv
id
)
;
}
}
;
req
.
then
(
okOrValueResponse
err
=
>
sendError
(
err
id
)
)
.
catch
(
error
.
report
)
;
}
;
}
function
addMessageListenerId
(
messageName
handler
)
{
addMessageListener
(
messageName
+
listenerId
handler
)
;
}
function
removeMessageListenerId
(
messageName
handler
)
{
removeMessageListener
(
messageName
+
listenerId
handler
)
;
}
let
getPageSourceFn
=
dispatch
(
getPageSource
)
;
let
getActiveElementFn
=
dispatch
(
getActiveElement
)
;
let
getElementAttributeFn
=
dispatch
(
getElementAttribute
)
;
let
getElementPropertyFn
=
dispatch
(
getElementProperty
)
;
let
getElementTextFn
=
dispatch
(
getElementText
)
;
let
getElementTagNameFn
=
dispatch
(
getElementTagName
)
;
let
getElementRectFn
=
dispatch
(
getElementRect
)
;
let
isElementEnabledFn
=
dispatch
(
isElementEnabled
)
;
let
findElementContentFn
=
dispatch
(
findElementContent
)
;
let
findElementsContentFn
=
dispatch
(
findElementsContent
)
;
let
isElementSelectedFn
=
dispatch
(
isElementSelected
)
;
let
clearElementFn
=
dispatch
(
clearElement
)
;
let
isElementDisplayedFn
=
dispatch
(
isElementDisplayed
)
;
let
getElementValueOfCssPropertyFn
=
dispatch
(
getElementValueOfCssProperty
)
;
let
switchToShadowRootFn
=
dispatch
(
switchToShadowRoot
)
;
let
singleTapFn
=
dispatch
(
singleTap
)
;
let
takeScreenshotFn
=
dispatch
(
takeScreenshot
)
;
let
performActionsFn
=
dispatch
(
performActions
)
;
let
releaseActionsFn
=
dispatch
(
releaseActions
)
;
let
actionChainFn
=
dispatch
(
actionChain
)
;
let
multiActionFn
=
dispatch
(
multiAction
)
;
let
executeFn
=
dispatch
(
execute
)
;
let
executeInSandboxFn
=
dispatch
(
executeInSandbox
)
;
let
sendKeysToElementFn
=
dispatch
(
sendKeysToElement
)
;
let
reftestWaitFn
=
dispatch
(
reftestWait
)
;
function
startListeners
(
)
{
addMessageListenerId
(
"
Marionette
:
newSession
"
newSession
)
;
addMessageListenerId
(
"
Marionette
:
execute
"
executeFn
)
;
addMessageListenerId
(
"
Marionette
:
executeInSandbox
"
executeInSandboxFn
)
;
addMessageListenerId
(
"
Marionette
:
singleTap
"
singleTapFn
)
;
addMessageListenerId
(
"
Marionette
:
performActions
"
performActionsFn
)
;
addMessageListenerId
(
"
Marionette
:
releaseActions
"
releaseActionsFn
)
;
addMessageListenerId
(
"
Marionette
:
actionChain
"
actionChainFn
)
;
addMessageListenerId
(
"
Marionette
:
multiAction
"
multiActionFn
)
;
addMessageListenerId
(
"
Marionette
:
get
"
get
)
;
addMessageListenerId
(
"
Marionette
:
waitForPageLoaded
"
waitForPageLoaded
)
;
addMessageListenerId
(
"
Marionette
:
cancelRequest
"
cancelRequest
)
;
addMessageListenerId
(
"
Marionette
:
getPageSource
"
getPageSourceFn
)
;
addMessageListenerId
(
"
Marionette
:
goBack
"
goBack
)
;
addMessageListenerId
(
"
Marionette
:
goForward
"
goForward
)
;
addMessageListenerId
(
"
Marionette
:
refresh
"
refresh
)
;
addMessageListenerId
(
"
Marionette
:
findElementContent
"
findElementContentFn
)
;
addMessageListenerId
(
"
Marionette
:
findElementsContent
"
findElementsContentFn
)
;
addMessageListenerId
(
"
Marionette
:
getActiveElement
"
getActiveElementFn
)
;
addMessageListenerId
(
"
Marionette
:
clickElement
"
clickElement
)
;
addMessageListenerId
(
"
Marionette
:
getElementAttribute
"
getElementAttributeFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementProperty
"
getElementPropertyFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementText
"
getElementTextFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementTagName
"
getElementTagNameFn
)
;
addMessageListenerId
(
"
Marionette
:
isElementDisplayed
"
isElementDisplayedFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementValueOfCssProperty
"
getElementValueOfCssPropertyFn
)
;
addMessageListenerId
(
"
Marionette
:
getElementRect
"
getElementRectFn
)
;
addMessageListenerId
(
"
Marionette
:
isElementEnabled
"
isElementEnabledFn
)
;
addMessageListenerId
(
"
Marionette
:
isElementSelected
"
isElementSelectedFn
)
;
addMessageListenerId
(
"
Marionette
:
sendKeysToElement
"
sendKeysToElementFn
)
;
addMessageListenerId
(
"
Marionette
:
clearElement
"
clearElementFn
)
;
addMessageListenerId
(
"
Marionette
:
switchToFrame
"
switchToFrame
)
;
addMessageListenerId
(
"
Marionette
:
switchToParentFrame
"
switchToParentFrame
)
;
addMessageListenerId
(
"
Marionette
:
switchToShadowRoot
"
switchToShadowRootFn
)
;
addMessageListenerId
(
"
Marionette
:
deleteSession
"
deleteSession
)
;
addMessageListenerId
(
"
Marionette
:
sleepSession
"
sleepSession
)
;
addMessageListenerId
(
"
Marionette
:
takeScreenshot
"
takeScreenshotFn
)
;
addMessageListenerId
(
"
Marionette
:
reftestWait
"
reftestWaitFn
)
;
}
function
newSession
(
msg
)
{
capabilities
=
session
.
Capabilities
.
fromJSON
(
msg
.
json
)
;
resetValues
(
)
;
}
function
sleepSession
(
msg
)
{
deleteSession
(
)
;
addMessageListener
(
"
Marionette
:
restart
"
restart
)
;
}
function
restart
(
msg
)
{
removeMessageListener
(
"
Marionette
:
restart
"
restart
)
;
registerSelf
(
)
;
}
function
deleteSession
(
msg
)
{
removeMessageListenerId
(
"
Marionette
:
newSession
"
newSession
)
;
removeMessageListenerId
(
"
Marionette
:
execute
"
executeFn
)
;
removeMessageListenerId
(
"
Marionette
:
executeInSandbox
"
executeInSandboxFn
)
;
removeMessageListenerId
(
"
Marionette
:
singleTap
"
singleTapFn
)
;
removeMessageListenerId
(
"
Marionette
:
performActions
"
performActionsFn
)
;
removeMessageListenerId
(
"
Marionette
:
releaseActions
"
releaseActionsFn
)
;
removeMessageListenerId
(
"
Marionette
:
actionChain
"
actionChainFn
)
;
removeMessageListenerId
(
"
Marionette
:
multiAction
"
multiActionFn
)
;
removeMessageListenerId
(
"
Marionette
:
get
"
get
)
;
removeMessageListenerId
(
"
Marionette
:
waitForPageLoaded
"
waitForPageLoaded
)
;
removeMessageListenerId
(
"
Marionette
:
cancelRequest
"
cancelRequest
)
;
removeMessageListenerId
(
"
Marionette
:
getPageSource
"
getPageSourceFn
)
;
removeMessageListenerId
(
"
Marionette
:
goBack
"
goBack
)
;
removeMessageListenerId
(
"
Marionette
:
goForward
"
goForward
)
;
removeMessageListenerId
(
"
Marionette
:
refresh
"
refresh
)
;
removeMessageListenerId
(
"
Marionette
:
findElementContent
"
findElementContentFn
)
;
removeMessageListenerId
(
"
Marionette
:
findElementsContent
"
findElementsContentFn
)
;
removeMessageListenerId
(
"
Marionette
:
getActiveElement
"
getActiveElementFn
)
;
removeMessageListenerId
(
"
Marionette
:
clickElement
"
clickElement
)
;
removeMessageListenerId
(
"
Marionette
:
getElementAttribute
"
getElementAttributeFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementProperty
"
getElementPropertyFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementText
"
getElementTextFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementTagName
"
getElementTagNameFn
)
;
removeMessageListenerId
(
"
Marionette
:
isElementDisplayed
"
isElementDisplayedFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementValueOfCssProperty
"
getElementValueOfCssPropertyFn
)
;
removeMessageListenerId
(
"
Marionette
:
getElementRect
"
getElementRectFn
)
;
removeMessageListenerId
(
"
Marionette
:
isElementEnabled
"
isElementEnabledFn
)
;
removeMessageListenerId
(
"
Marionette
:
isElementSelected
"
isElementSelectedFn
)
;
removeMessageListenerId
(
"
Marionette
:
sendKeysToElement
"
sendKeysToElementFn
)
;
removeMessageListenerId
(
"
Marionette
:
clearElement
"
clearElementFn
)
;
removeMessageListenerId
(
"
Marionette
:
switchToFrame
"
switchToFrame
)
;
removeMessageListenerId
(
"
Marionette
:
switchToParentFrame
"
switchToParentFrame
)
;
removeMessageListenerId
(
"
Marionette
:
switchToShadowRoot
"
switchToShadowRootFn
)
;
removeMessageListenerId
(
"
Marionette
:
deleteSession
"
deleteSession
)
;
removeMessageListenerId
(
"
Marionette
:
sleepSession
"
sleepSession
)
;
removeMessageListenerId
(
"
Marionette
:
takeScreenshot
"
takeScreenshotFn
)
;
seenEls
.
clear
(
)
;
curContainer
=
{
frame
:
content
shadowRoot
:
null
}
;
curContainer
.
frame
.
focus
(
)
;
legacyactions
.
touchIds
=
{
}
;
if
(
action
.
inputStateMap
!
=
=
undefined
)
{
action
.
inputStateMap
.
clear
(
)
;
}
if
(
action
.
inputsToCancel
!
=
=
undefined
)
{
action
.
inputsToCancel
.
length
=
0
;
}
}
function
sendToServer
(
uuid
data
=
undefined
)
{
let
channel
=
new
proxy
.
AsyncMessageChannel
(
(
)
=
>
this
sendAsyncMessage
.
bind
(
this
)
)
;
channel
.
reply
(
uuid
data
)
;
}
function
sendResponse
(
obj
uuid
)
{
sendToServer
(
uuid
obj
)
;
}
function
sendOk
(
uuid
)
{
sendToServer
(
uuid
)
;
}
function
sendError
(
err
uuid
)
{
sendToServer
(
uuid
err
)
;
}
function
resetValues
(
)
{
sandboxes
.
clear
(
)
;
curContainer
=
{
frame
:
content
shadowRoot
:
null
}
;
legacyactions
.
mouseEventsOnly
=
false
;
action
.
inputStateMap
=
new
Map
(
)
;
action
.
inputsToCancel
=
[
]
;
}
function
wasInterrupted
(
)
{
if
(
previousContainer
)
{
let
element
=
content
.
document
.
elementFromPoint
(
(
content
.
innerWidth
/
2
)
(
content
.
innerHeight
/
2
)
)
;
if
(
element
.
id
.
indexOf
(
"
modal
-
dialog
"
)
=
=
-
1
)
{
return
true
;
}
return
false
;
}
return
sendSyncMessage
(
"
MarionetteFrame
:
getInterruptedState
"
{
}
)
[
0
]
.
value
;
}
function
checkForInterrupted
(
)
{
if
(
wasInterrupted
(
)
)
{
if
(
previousContainer
)
{
curContainer
=
legacyactions
.
container
=
previousContainer
;
previousContainer
=
null
;
}
else
{
sendSyncMessage
(
"
Marionette
:
switchToModalOrigin
"
)
;
}
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
restorePrevious
:
true
}
)
;
}
}
async
function
execute
(
script
args
timeout
opts
)
{
opts
.
timeout
=
timeout
;
let
sb
=
sandbox
.
createMutable
(
curContainer
.
frame
)
;
let
wargs
=
evaluate
.
fromJSON
(
args
seenEls
curContainer
.
frame
curContainer
.
shadowRoot
)
;
let
res
=
await
evaluate
.
sandbox
(
sb
script
wargs
opts
)
;
return
evaluate
.
toJSON
(
res
seenEls
)
;
}
async
function
executeInSandbox
(
script
args
timeout
opts
)
{
opts
.
timeout
=
timeout
;
let
sb
=
sandboxes
.
get
(
opts
.
sandboxName
opts
.
newSandbox
)
;
let
wargs
=
evaluate
.
fromJSON
(
args
seenEls
curContainer
.
frame
curContainer
.
shadowRoot
)
;
let
res
=
await
evaluate
.
sandbox
(
sb
script
wargs
opts
)
;
return
evaluate
.
toJSON
(
res
seenEls
)
;
}
function
emitTouchEvent
(
type
touch
)
{
if
(
!
wasInterrupted
(
)
)
{
logger
.
info
(
Emitting
Touch
event
of
type
{
type
}
+
to
element
with
id
:
{
touch
.
target
.
id
}
+
and
tag
name
:
{
touch
.
target
.
tagName
}
+
at
coordinates
(
{
touch
.
clientX
}
)
+
{
touch
.
clientY
}
)
relative
to
the
viewport
)
;
const
win
=
curContainer
.
frame
;
let
docShell
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
if
(
docShell
.
asyncPanZoomEnabled
&
&
legacyactions
.
scrolling
)
{
let
index
=
sendSyncMessage
(
"
MarionetteFrame
:
getCurrentFrameId
"
)
;
if
(
index
!
=
null
)
{
let
ev
=
{
index
type
id
:
touch
.
identifier
clientX
:
touch
.
clientX
clientY
:
touch
.
clientY
screenX
:
touch
.
screenX
screenY
:
touch
.
screenY
radiusX
:
touch
.
radiusX
radiusY
:
touch
.
radiusY
rotation
:
touch
.
rotationAngle
force
:
touch
.
force
}
;
sendSyncMessage
(
"
Marionette
:
emitTouchEvent
"
ev
)
;
return
;
}
}
let
domWindowUtils
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
domWindowUtils
.
sendTouchEvent
(
type
[
touch
.
identifier
]
[
touch
.
clientX
]
[
touch
.
clientY
]
[
touch
.
radiusX
]
[
touch
.
radiusY
]
[
touch
.
rotationAngle
]
[
touch
.
force
]
1
0
)
;
}
}
async
function
singleTap
(
id
corx
cory
)
{
let
el
=
seenEls
.
get
(
id
)
;
let
visible
=
element
.
isVisible
(
el
corx
cory
)
;
if
(
!
visible
)
{
throw
new
ElementNotInteractableError
(
"
Element
is
not
currently
visible
and
may
not
be
manipulated
"
)
;
}
let
a11y
=
accessibility
.
get
(
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
let
acc
=
await
a11y
.
getAccessible
(
el
true
)
;
a11y
.
assertVisible
(
acc
el
visible
)
;
a11y
.
assertActionable
(
acc
el
)
;
if
(
!
curContainer
.
frame
.
document
.
createTouch
)
{
legacyactions
.
mouseEventsOnly
=
true
;
}
let
c
=
element
.
coordinates
(
el
corx
cory
)
;
if
(
!
legacyactions
.
mouseEventsOnly
)
{
let
touchId
=
legacyactions
.
nextTouchId
+
+
;
let
touch
=
createATouch
(
el
c
.
x
c
.
y
touchId
)
;
emitTouchEvent
(
"
touchstart
"
touch
)
;
emitTouchEvent
(
"
touchend
"
touch
)
;
}
legacyactions
.
mouseTap
(
el
.
ownerDocument
c
.
x
c
.
y
)
;
}
function
createATouch
(
el
corx
cory
touchId
)
{
let
doc
=
el
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
[
clientX
clientY
pageX
pageY
screenX
screenY
]
=
legacyactions
.
getCoordinateInfo
(
el
corx
cory
)
;
let
atouch
=
doc
.
createTouch
(
win
el
touchId
pageX
pageY
screenX
screenY
clientX
clientY
)
;
return
atouch
;
}
async
function
performActions
(
msg
)
{
let
chain
=
action
.
Chain
.
fromJSON
(
msg
.
actions
)
;
await
action
.
dispatch
(
chain
seenEls
curContainer
.
frame
)
;
}
async
function
releaseActions
(
)
{
await
action
.
dispatchTickActions
(
action
.
inputsToCancel
.
reverse
(
)
0
seenEls
curContainer
.
frame
)
;
action
.
inputsToCancel
.
length
=
0
;
action
.
inputStateMap
.
clear
(
)
;
}
function
actionChain
(
chain
touchId
)
{
let
touchProvider
=
{
}
;
touchProvider
.
createATouch
=
createATouch
;
touchProvider
.
emitTouchEvent
=
emitTouchEvent
;
return
legacyactions
.
dispatchActions
(
chain
touchId
curContainer
seenEls
touchProvider
)
;
}
function
emitMultiEvents
(
type
touch
touches
)
{
let
target
=
touch
.
target
;
let
doc
=
target
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
documentTouches
=
doc
.
createTouchList
(
touches
.
filter
(
function
(
t
)
{
return
(
(
t
.
target
.
ownerDocument
=
=
=
doc
)
&
&
(
type
!
=
"
touchcancel
"
)
)
;
}
)
)
;
let
targetTouches
=
doc
.
createTouchList
(
touches
.
filter
(
function
(
t
)
{
return
(
(
t
.
target
=
=
=
target
)
&
&
(
(
type
!
=
"
touchcancel
"
)
|
|
(
type
!
=
"
touchend
"
)
)
)
;
}
)
)
;
let
changedTouches
=
doc
.
createTouchList
(
touch
)
;
let
event
=
doc
.
createEvent
(
"
TouchEvent
"
)
;
event
.
initTouchEvent
(
type
true
true
win
0
false
false
false
false
documentTouches
targetTouches
changedTouches
)
;
target
.
dispatchEvent
(
event
)
;
}
function
setDispatch
(
batches
touches
batchIndex
=
0
)
{
if
(
batchIndex
>
=
batches
.
length
)
{
multiLast
=
{
}
;
return
;
}
let
batch
=
batches
[
batchIndex
]
;
let
pack
;
let
touchId
;
let
command
;
let
el
;
let
touch
;
let
lastTouch
;
let
touchIndex
;
let
waitTime
=
0
;
let
maxTime
=
0
;
let
c
;
batchIndex
+
+
;
for
(
let
i
=
0
;
i
<
batch
.
length
;
i
+
+
)
{
pack
=
batch
[
i
]
;
touchId
=
pack
[
0
]
;
command
=
pack
[
1
]
;
switch
(
command
)
{
case
"
press
"
:
el
=
seenEls
.
get
(
pack
[
2
]
)
;
c
=
element
.
coordinates
(
el
pack
[
3
]
pack
[
4
]
)
;
touch
=
createATouch
(
el
c
.
x
c
.
y
touchId
)
;
multiLast
[
touchId
]
=
touch
;
touches
.
push
(
touch
)
;
emitMultiEvents
(
"
touchstart
"
touch
touches
)
;
break
;
case
"
release
"
:
touch
=
multiLast
[
touchId
]
;
touchIndex
=
touches
.
indexOf
(
touch
)
;
touches
.
splice
(
touchIndex
1
)
;
emitMultiEvents
(
"
touchend
"
touch
touches
)
;
break
;
case
"
move
"
:
el
=
seenEls
.
get
(
pack
[
2
]
)
;
c
=
element
.
coordinates
(
el
)
;
touch
=
createATouch
(
multiLast
[
touchId
]
.
target
c
.
x
c
.
y
touchId
)
;
touchIndex
=
touches
.
indexOf
(
lastTouch
)
;
touches
[
touchIndex
]
=
touch
;
multiLast
[
touchId
]
=
touch
;
emitMultiEvents
(
"
touchmove
"
touch
touches
)
;
break
;
case
"
moveByOffset
"
:
el
=
multiLast
[
touchId
]
.
target
;
lastTouch
=
multiLast
[
touchId
]
;
touchIndex
=
touches
.
indexOf
(
lastTouch
)
;
let
doc
=
el
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
clientX
=
lastTouch
.
clientX
+
pack
[
2
]
;
let
clientY
=
lastTouch
.
clientY
+
pack
[
3
]
;
let
pageX
=
clientX
+
win
.
pageXOffset
;
let
pageY
=
clientY
+
win
.
pageYOffset
;
let
screenX
=
clientX
+
win
.
mozInnerScreenX
;
let
screenY
=
clientY
+
win
.
mozInnerScreenY
;
touch
=
doc
.
createTouch
(
win
el
touchId
pageX
pageY
screenX
screenY
clientX
clientY
)
;
touches
[
touchIndex
]
=
touch
;
multiLast
[
touchId
]
=
touch
;
emitMultiEvents
(
"
touchmove
"
touch
touches
)
;
break
;
case
"
wait
"
:
if
(
typeof
pack
[
2
]
!
=
"
undefined
"
)
{
waitTime
=
pack
[
2
]
*
1000
;
if
(
waitTime
>
maxTime
)
{
maxTime
=
waitTime
;
}
}
break
;
}
}
if
(
maxTime
!
=
0
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
function
(
)
{
setDispatch
(
batches
touches
batchIndex
)
;
}
maxTime
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
{
setDispatch
(
batches
touches
batchIndex
)
;
}
}
function
multiAction
(
args
maxLen
)
{
let
commandArray
=
evaluate
.
fromJSON
(
args
seenEls
curContainer
.
frame
curContainer
.
shadowRoot
)
;
let
concurrentEvent
=
[
]
;
let
temp
;
for
(
let
i
=
0
;
i
<
maxLen
;
i
+
+
)
{
let
row
=
[
]
;
for
(
let
j
=
0
;
j
<
commandArray
.
length
;
j
+
+
)
{
if
(
typeof
commandArray
[
j
]
[
i
]
!
=
"
undefined
"
)
{
temp
=
commandArray
[
j
]
[
i
]
;
temp
.
unshift
(
j
)
;
row
.
push
(
temp
)
;
}
}
concurrentEvent
.
push
(
row
)
;
}
let
pendingTouches
=
[
]
;
setDispatch
(
concurrentEvent
pendingTouches
)
;
}
function
cancelRequest
(
)
{
loadListener
.
stop
(
)
;
}
function
waitForPageLoaded
(
msg
)
{
let
{
commandID
pageTimeout
startTime
}
=
msg
.
json
;
loadListener
.
waitForLoadAfterFramescriptReload
(
commandID
pageTimeout
startTime
)
;
}
function
get
(
msg
)
{
let
{
commandID
pageTimeout
url
loadEventExpected
=
null
}
=
msg
.
json
;
try
{
if
(
typeof
url
=
=
"
string
"
)
{
try
{
if
(
loadEventExpected
=
=
=
null
)
{
loadEventExpected
=
navigate
.
isLoadEventExpected
(
curContainer
.
frame
.
location
url
)
;
}
}
catch
(
e
)
{
let
err
=
new
InvalidArgumentError
(
"
Malformed
URL
:
"
+
e
.
message
)
;
sendError
(
err
commandID
)
;
return
;
}
}
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
loadListener
.
navigate
(
(
)
=
>
{
curContainer
.
frame
.
location
=
url
;
}
commandID
pageTimeout
loadEventExpected
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
}
}
function
goBack
(
msg
)
{
let
{
commandID
pageTimeout
}
=
msg
.
json
;
try
{
loadListener
.
navigate
(
(
)
=
>
{
curContainer
.
frame
.
history
.
back
(
)
;
}
commandID
pageTimeout
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
}
}
function
goForward
(
msg
)
{
let
{
commandID
pageTimeout
}
=
msg
.
json
;
try
{
loadListener
.
navigate
(
(
)
=
>
{
curContainer
.
frame
.
history
.
forward
(
)
;
}
commandID
pageTimeout
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
}
}
function
refresh
(
msg
)
{
let
{
commandID
pageTimeout
}
=
msg
.
json
;
try
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
loadListener
.
navigate
(
(
)
=
>
{
curContainer
.
frame
.
location
.
reload
(
true
)
;
}
commandID
pageTimeout
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
}
}
function
getPageSource
(
)
{
return
curContainer
.
frame
.
document
.
documentElement
.
outerHTML
;
}
async
function
findElementContent
(
strategy
selector
opts
=
{
}
)
{
if
(
!
SUPPORTED_STRATEGIES
.
has
(
strategy
)
)
{
throw
new
InvalidSelectorError
(
"
Strategy
not
supported
:
"
+
strategy
)
;
}
opts
.
all
=
false
;
if
(
opts
.
startNode
)
{
opts
.
startNode
=
seenEls
.
get
(
opts
.
startNode
)
;
}
let
el
=
await
element
.
find
(
curContainer
strategy
selector
opts
)
;
let
elRef
=
seenEls
.
add
(
el
)
;
let
webEl
=
element
.
makeWebElement
(
elRef
)
;
return
webEl
;
}
async
function
findElementsContent
(
strategy
selector
opts
=
{
}
)
{
if
(
!
SUPPORTED_STRATEGIES
.
has
(
strategy
)
)
{
throw
new
InvalidSelectorError
(
"
Strategy
not
supported
:
"
+
strategy
)
;
}
opts
.
all
=
true
;
if
(
opts
.
startNode
)
{
opts
.
startNode
=
seenEls
.
get
(
opts
.
startNode
)
;
}
let
els
=
await
element
.
find
(
curContainer
strategy
selector
opts
)
;
let
elRefs
=
seenEls
.
addAll
(
els
)
;
let
webEls
=
elRefs
.
map
(
element
.
makeWebElement
)
;
return
webEls
;
}
function
getActiveElement
(
)
{
let
el
=
curContainer
.
frame
.
document
.
activeElement
;
return
evaluate
.
toJSON
(
el
seenEls
)
;
}
function
clickElement
(
msg
)
{
let
{
commandID
id
pageTimeout
}
=
msg
.
json
;
try
{
let
loadEventExpected
=
true
;
let
target
=
getElementAttribute
(
id
"
target
"
)
;
if
(
target
=
=
=
"
_blank
"
)
{
loadEventExpected
=
false
;
}
loadListener
.
navigate
(
(
)
=
>
{
return
interaction
.
clickElement
(
seenEls
.
get
(
id
)
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
capabilities
.
get
(
"
specificationLevel
"
)
>
=
1
)
;
}
commandID
pageTimeout
loadEventExpected
true
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
}
}
function
getElementAttribute
(
id
name
)
{
let
el
=
seenEls
.
get
(
id
)
;
if
(
element
.
isBooleanAttribute
(
el
name
)
)
{
if
(
el
.
hasAttribute
(
name
)
)
{
return
"
true
"
;
}
return
null
;
}
return
el
.
getAttribute
(
name
)
;
}
function
getElementProperty
(
id
name
)
{
let
el
=
seenEls
.
get
(
id
)
;
return
typeof
el
[
name
]
!
=
"
undefined
"
?
el
[
name
]
:
null
;
}
function
getElementText
(
id
)
{
let
el
=
seenEls
.
get
(
id
)
;
return
atom
.
getElementText
(
el
curContainer
.
frame
)
;
}
function
getElementTagName
(
id
)
{
let
el
=
seenEls
.
get
(
id
)
;
return
el
.
tagName
.
toLowerCase
(
)
;
}
function
isElementDisplayed
(
id
)
{
let
el
=
seenEls
.
get
(
id
)
;
return
interaction
.
isElementDisplayed
(
el
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
}
function
getElementValueOfCssProperty
(
id
prop
)
{
let
el
=
seenEls
.
get
(
id
)
;
let
st
=
curContainer
.
frame
.
document
.
defaultView
.
getComputedStyle
(
el
)
;
return
st
.
getPropertyValue
(
prop
)
;
}
function
getElementRect
(
id
)
{
let
el
=
seenEls
.
get
(
id
)
;
let
clientRect
=
el
.
getBoundingClientRect
(
)
;
return
{
x
:
clientRect
.
x
+
curContainer
.
frame
.
pageXOffset
y
:
clientRect
.
y
+
curContainer
.
frame
.
pageYOffset
width
:
clientRect
.
width
height
:
clientRect
.
height
}
;
}
function
isElementEnabled
(
id
)
{
let
el
=
seenEls
.
get
(
id
)
;
return
interaction
.
isElementEnabled
(
el
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
}
function
isElementSelected
(
id
)
{
let
el
=
seenEls
.
get
(
id
)
;
return
interaction
.
isElementSelected
(
el
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
}
async
function
sendKeysToElement
(
id
val
)
{
let
el
=
seenEls
.
get
(
id
)
;
if
(
el
.
type
=
=
"
file
"
)
{
await
interaction
.
uploadFile
(
el
val
)
;
}
else
if
(
(
el
.
type
=
=
"
date
"
|
|
el
.
type
=
=
"
time
"
)
&
&
Preferences
.
get
(
"
dom
.
forms
.
datetime
"
)
)
{
interaction
.
setFormControlValue
(
el
val
)
;
}
else
{
await
interaction
.
sendKeysToElement
(
el
val
false
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
)
;
}
}
function
clearElement
(
id
)
{
try
{
let
el
=
seenEls
.
get
(
id
)
;
if
(
el
.
type
=
=
"
file
"
)
{
el
.
value
=
null
;
}
else
{
atom
.
clearElement
(
el
curContainer
.
frame
)
;
}
}
catch
(
e
)
{
if
(
e
.
name
=
=
"
InvalidElementStateError
"
)
{
throw
new
InvalidElementStateError
(
e
.
message
)
;
}
else
{
throw
e
;
}
}
}
function
switchToShadowRoot
(
id
)
{
if
(
!
id
)
{
if
(
curContainer
.
shadowRoot
)
{
let
parent
;
try
{
parent
=
curContainer
.
shadowRoot
.
host
;
}
catch
(
e
)
{
curContainer
.
shadowRoot
=
null
;
return
;
}
while
(
parent
&
&
!
(
parent
instanceof
curContainer
.
frame
.
ShadowRoot
)
)
{
parent
=
parent
.
parentNode
;
}
curContainer
.
shadowRoot
=
parent
;
}
return
;
}
let
foundShadowRoot
;
let
hostEl
=
seenEls
.
get
(
id
)
;
foundShadowRoot
=
hostEl
.
shadowRoot
;
if
(
!
foundShadowRoot
)
{
throw
new
NoSuchElementError
(
"
Unable
to
locate
shadow
root
:
"
+
id
)
;
}
curContainer
.
shadowRoot
=
foundShadowRoot
;
}
function
switchToParentFrame
(
msg
)
{
curContainer
.
frame
=
curContainer
.
frame
.
parent
;
let
parentElement
=
seenEls
.
add
(
curContainer
.
frame
)
;
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
parentElement
}
)
;
sendOk
(
msg
.
json
.
commandID
)
;
}
function
switchToFrame
(
msg
)
{
let
commandID
=
msg
.
json
.
commandID
;
let
foundFrame
=
null
;
let
frames
=
[
]
;
let
parWindow
=
null
;
try
{
frames
=
curContainer
.
frame
.
frames
;
parWindow
=
curContainer
.
frame
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
}
catch
(
e
)
{
msg
.
json
.
id
=
null
;
msg
.
json
.
element
=
null
;
}
if
(
(
msg
.
json
.
id
=
=
=
null
|
|
msg
.
json
.
id
=
=
=
undefined
)
&
&
(
msg
.
json
.
element
=
=
null
)
)
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
if
(
msg
.
json
.
focus
=
=
true
)
{
curContainer
.
frame
.
focus
(
)
;
}
sendOk
(
commandID
)
;
return
;
}
let
id
=
msg
.
json
.
element
;
if
(
seenEls
.
has
(
id
)
)
{
let
wantedFrame
;
try
{
wantedFrame
=
seenEls
.
get
(
id
)
;
}
catch
(
e
)
{
sendError
(
e
commandID
)
;
}
if
(
frames
.
length
>
0
)
{
for
(
let
i
=
0
;
i
<
frames
.
length
;
i
+
+
)
{
let
frameEl
=
frames
[
i
]
.
frameElement
;
let
wrappedItem
=
new
XPCNativeWrapper
(
frameEl
)
;
let
wrappedWanted
=
new
XPCNativeWrapper
(
wantedFrame
)
;
if
(
wrappedItem
=
=
wrappedWanted
)
{
curContainer
.
frame
=
frameEl
;
foundFrame
=
i
;
}
}
}
if
(
foundFrame
=
=
=
null
)
{
const
doc
=
curContainer
.
frame
.
document
;
let
iframes
=
doc
.
getElementsByTagName
(
"
iframe
"
)
;
for
(
let
i
=
0
;
i
<
iframes
.
length
;
i
+
+
)
{
let
frameEl
=
iframes
[
i
]
;
let
wrappedEl
=
new
XPCNativeWrapper
(
frameEl
)
;
let
wrappedWanted
=
new
XPCNativeWrapper
(
wantedFrame
)
;
if
(
wrappedEl
=
=
wrappedWanted
)
{
curContainer
.
frame
=
iframes
[
i
]
;
foundFrame
=
i
;
}
}
}
}
if
(
foundFrame
=
=
=
null
)
{
if
(
typeof
(
msg
.
json
.
id
)
=
=
=
"
number
"
)
{
try
{
foundFrame
=
frames
[
msg
.
json
.
id
]
.
frameElement
;
if
(
foundFrame
!
=
=
null
)
{
curContainer
.
frame
=
foundFrame
;
foundFrame
=
seenEls
.
add
(
curContainer
.
frame
)
;
}
else
{
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
frameValue
:
null
}
)
;
curContainer
.
frame
=
content
;
if
(
msg
.
json
.
focus
=
=
true
)
{
curContainer
.
frame
.
focus
(
)
;
}
sendOk
(
commandID
)
;
return
;
}
}
catch
(
e
)
{
let
doc
=
curContainer
.
frame
.
document
;
let
iframes
=
doc
.
getElementsByTagName
(
"
iframe
"
)
;
if
(
msg
.
json
.
id
>
=
0
&
&
msg
.
json
.
id
<
iframes
.
length
)
{
curContainer
.
frame
=
iframes
[
msg
.
json
.
id
]
;
foundFrame
=
msg
.
json
.
id
;
}
}
}
}
if
(
foundFrame
=
=
=
null
)
{
let
failedFrame
=
msg
.
json
.
id
|
|
msg
.
json
.
element
;
let
err
=
new
NoSuchFrameError
(
Unable
to
locate
frame
:
{
failedFrame
}
)
;
sendError
(
err
commandID
)
;
return
;
}
let
frameValue
=
evaluate
.
toJSON
(
curContainer
.
frame
.
wrappedJSObject
seenEls
)
[
element
.
Key
]
;
sendSyncMessage
(
"
Marionette
:
switchedToFrame
"
{
"
frameValue
"
:
frameValue
}
)
;
if
(
curContainer
.
frame
.
contentWindow
=
=
=
null
)
{
curContainer
.
frame
=
content
;
let
rv
=
{
win
:
parWindow
frame
:
foundFrame
}
;
sendResponse
(
rv
commandID
)
;
}
else
{
curContainer
.
frame
=
curContainer
.
frame
.
contentWindow
;
if
(
msg
.
json
.
focus
)
{
curContainer
.
frame
.
focus
(
)
;
}
sendOk
(
commandID
)
;
}
}
function
takeScreenshot
(
format
opts
=
{
}
)
{
let
id
=
opts
.
id
;
let
full
=
!
!
opts
.
full
;
let
highlights
=
opts
.
highlights
|
|
[
]
;
let
scroll
=
!
!
opts
.
scroll
;
let
highlightEls
=
highlights
.
map
(
ref
=
>
seenEls
.
get
(
ref
)
)
;
let
canvas
;
if
(
!
id
&
&
!
full
)
{
canvas
=
capture
.
viewport
(
curContainer
.
frame
highlightEls
)
;
}
else
{
let
el
;
if
(
id
)
{
el
=
seenEls
.
get
(
id
)
;
if
(
scroll
)
{
element
.
scrollIntoView
(
el
)
;
}
}
else
{
el
=
curContainer
.
frame
.
document
.
documentElement
;
}
canvas
=
capture
.
element
(
el
highlightEls
)
;
}
switch
(
format
)
{
case
capture
.
Format
.
Base64
:
return
capture
.
toBase64
(
canvas
)
;
case
capture
.
Format
.
Hash
:
return
capture
.
toHash
(
canvas
)
;
default
:
throw
new
TypeError
(
"
Unknown
screenshot
format
:
"
+
format
)
;
}
}
function
flushRendering
(
)
{
let
content
=
curContainer
.
frame
;
let
anyPendingPaintsGeneratedInDescendants
=
false
;
let
windowUtils
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
function
flushWindow
(
win
)
{
let
utils
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
let
afterPaintWasPending
=
utils
.
isMozAfterPaintPending
;
let
root
=
win
.
document
.
documentElement
;
if
(
root
)
{
try
{
root
.
getBoundingClientRect
(
)
;
}
catch
(
e
)
{
logger
.
warning
(
flushWindow
failed
:
{
e
}
)
;
}
}
if
(
!
afterPaintWasPending
&
&
utils
.
isMozAfterPaintPending
)
{
anyPendingPaintsGeneratedInDescendants
=
true
;
}
for
(
let
i
=
0
;
i
<
win
.
frames
.
length
;
+
+
i
)
{
flushWindow
(
win
.
frames
[
i
]
)
;
}
}
flushWindow
(
content
)
;
if
(
anyPendingPaintsGeneratedInDescendants
&
&
!
windowUtils
.
isMozAfterPaintPending
)
{
logger
.
error
(
"
Internal
error
:
descendant
frame
generated
a
MozAfterPaint
event
but
the
root
document
doesn
'
t
have
one
!
"
)
;
}
logger
.
debug
(
flushRendering
{
windowUtils
.
isMozAfterPaintPending
}
)
;
return
windowUtils
.
isMozAfterPaintPending
;
}
async
function
reftestWait
(
url
remote
)
{
let
win
=
curContainer
.
frame
;
let
document
=
curContainer
.
frame
.
document
;
let
windowUtils
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
let
reftestWait
=
false
;
if
(
document
.
location
.
href
!
=
=
url
|
|
document
.
readyState
!
=
"
complete
"
)
{
logger
.
debug
(
Waiting
for
page
load
of
{
url
}
)
;
await
new
Promise
(
resolve
=
>
{
let
maybeResolve
=
event
=
>
{
if
(
event
.
target
=
=
=
curContainer
.
frame
.
document
&
&
event
.
target
.
location
.
href
=
=
=
url
)
{
win
=
curContainer
.
frame
;
document
=
curContainer
.
frame
.
document
;
reftestWait
=
document
.
documentElement
.
classList
.
contains
(
"
reftest
-
wait
"
)
;
removeEventListener
(
"
load
"
maybeResolve
{
once
:
true
}
)
;
win
.
setTimeout
(
resolve
0
)
;
}
}
;
addEventListener
(
"
load
"
maybeResolve
true
)
;
}
)
;
}
else
{
reftestWait
=
document
.
documentElement
.
classList
.
contains
(
"
reftest
-
wait
"
)
;
await
new
Promise
(
resolve
=
>
win
.
setTimeout
(
resolve
0
)
)
;
}
let
root
=
document
.
documentElement
;
if
(
reftestWait
)
{
if
(
root
.
classList
.
contains
(
"
reftest
-
wait
"
)
)
{
logger
.
debug
(
"
Waiting
for
reftest
-
wait
removal
"
)
;
await
new
Promise
(
resolve
=
>
{
let
observer
=
new
win
.
MutationObserver
(
(
)
=
>
{
if
(
!
root
.
classList
.
contains
(
"
reftest
-
wait
"
)
)
{
observer
.
disconnect
(
)
;
logger
.
debug
(
"
reftest
-
wait
removed
"
)
;
win
.
setTimeout
(
resolve
0
)
;
}
}
)
;
observer
.
observe
(
root
{
attributes
:
true
}
)
;
}
)
;
}
logger
.
debug
(
"
Waiting
for
rendering
"
)
;
await
new
Promise
(
resolve
=
>
{
let
maybeResolve
=
(
)
=
>
{
if
(
flushRendering
(
)
)
{
win
.
addEventListener
(
"
MozAfterPaint
"
maybeResolve
{
once
:
true
}
)
;
}
else
{
win
.
setTimeout
(
resolve
0
)
;
}
}
;
maybeResolve
(
)
;
}
)
;
}
else
{
flushRendering
(
)
;
}
if
(
remote
)
{
windowUtils
.
updateLayerTree
(
)
;
}
}
registerSelf
(
)
;
