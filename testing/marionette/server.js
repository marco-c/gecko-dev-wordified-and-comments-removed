"
use
strict
"
;
const
{
Constructor
:
CC
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
const
loader
=
Cc
[
"
mozilla
.
org
/
moz
/
jssubscript
-
loader
;
1
"
]
.
getService
(
Ci
.
mozIJSSubScriptLoader
)
;
const
ServerSocket
=
CC
(
"
mozilla
.
org
/
network
/
server
-
socket
;
1
"
"
nsIServerSocket
"
"
initSpecialConnection
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
assert
.
js
"
)
;
const
{
GeckoDriver
}
=
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
driver
.
js
"
{
}
)
;
const
{
error
UnknownCommandError
}
=
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
{
}
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
message
.
js
"
)
;
const
{
DebuggerTransport
}
=
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
transport
.
js
"
{
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
env
"
"
mozilla
.
org
/
process
/
environment
;
1
"
"
nsIEnvironment
"
)
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
const
{
KeepWhenOffline
LoopbackOnly
}
=
Ci
.
nsIServerSocket
;
this
.
EXPORTED_SYMBOLS
=
[
"
server
"
]
;
this
.
server
=
{
}
;
const
PROTOCOL_VERSION
=
3
;
const
ENV_ENABLED
=
"
MOZ_MARIONETTE
"
;
const
PREF_CONTENT_LISTENER
=
"
marionette
.
contentListener
"
;
const
PREF_PORT
=
"
marionette
.
port
"
;
const
PREF_RECOMMENDED
=
"
marionette
.
prefs
.
recommended
"
;
const
NOTIFY_RUNNING
=
"
remote
-
active
"
;
const
RECOMMENDED_PREFS
=
new
Map
(
[
[
"
app
.
update
.
auto
"
false
]
[
"
app
.
update
.
enabled
"
false
]
[
"
apz
.
content_response_timeout
"
60000
]
[
"
browser
.
download
.
panel
.
shown
"
true
]
[
"
browser
.
EULA
.
override
"
true
]
[
"
browser
.
newtabpage
.
enabled
"
false
]
[
"
browser
.
newtabpage
.
introShown
"
true
]
[
"
browser
.
offline
"
false
]
[
"
browser
.
pagethumbnails
.
capturing_disabled
"
true
]
[
"
browser
.
safebrowsing
.
blockedURIs
.
enabled
"
false
]
[
"
browser
.
safebrowsing
.
downloads
.
enabled
"
false
]
[
"
browser
.
safebrowsing
.
malware
.
enabled
"
false
]
[
"
browser
.
safebrowsing
.
phishing
.
enabled
"
false
]
[
"
browser
.
search
.
update
"
false
]
[
"
browser
.
sessionstore
.
resume_from_crash
"
false
]
[
"
browser
.
shell
.
checkDefaultBrowser
"
false
]
[
"
browser
.
startup
.
page
"
0
]
[
"
browser
.
startup
.
homepage_override
.
mstone
"
"
ignore
"
]
[
"
toolkit
.
cosmeticAnimations
.
enabled
"
false
]
[
"
browser
.
tabs
.
disableBackgroundZombification
"
false
]
[
"
browser
.
tabs
.
warnOnCloseOtherTabs
"
false
]
[
"
browser
.
tabs
.
warnOnOpen
"
false
]
[
"
browser
.
usedOnWindows10
.
introURL
"
"
"
]
[
"
browser
.
uitour
.
enabled
"
false
]
[
"
datareporting
.
healthreport
.
about
.
reportUrl
"
"
http
:
/
/
%
(
server
)
s
/
dummy
/
abouthealthreport
/
"
]
[
"
datareporting
.
healthreport
.
documentServerURI
"
"
http
:
/
/
%
(
server
)
s
/
dummy
/
healthreport
/
"
]
[
"
datareporting
.
healthreport
.
logging
.
consoleEnabled
"
false
]
[
"
datareporting
.
healthreport
.
service
.
enabled
"
false
]
[
"
datareporting
.
healthreport
.
service
.
firstRun
"
false
]
[
"
datareporting
.
healthreport
.
uploadEnabled
"
false
]
[
"
datareporting
.
policy
.
dataSubmissionEnabled
"
false
]
[
"
datareporting
.
policy
.
dataSubmissionPolicyAccepted
"
false
]
[
"
datareporting
.
policy
.
dataSubmissionPolicyBypassNotification
"
true
]
[
"
dom
.
disable_open_during_load
"
false
]
[
"
dom
.
ipc
.
reportProcessHangs
"
false
]
[
"
dom
.
max_chrome_script_run_time
"
0
]
[
"
dom
.
max_script_run_time
"
0
]
[
"
extensions
.
autoDisableScopes
"
0
]
[
"
extensions
.
enabledScopes
"
5
]
[
"
extensions
.
e10sBlocksEnabling
"
false
]
[
"
extensions
.
getAddons
.
cache
.
enabled
"
false
]
[
"
extensions
.
installDistroAddons
"
false
]
[
"
extensions
.
showMismatchUI
"
false
]
[
"
extensions
.
update
.
enabled
"
false
]
[
"
extensions
.
update
.
notifyUser
"
false
]
[
"
extensions
.
webservice
.
discoverURL
"
"
http
:
/
/
%
(
server
)
s
/
dummy
/
discoveryURL
"
]
[
"
focusmanager
.
testmode
"
true
]
[
"
general
.
useragent
.
updates
.
enabled
"
false
]
[
"
geo
.
provider
.
testing
"
true
]
[
"
geo
.
wifi
.
scan
"
false
]
[
"
hangmonitor
.
timeout
"
0
]
[
"
javascript
.
options
.
showInConsole
"
true
]
[
"
network
.
http
.
prompt
-
temp
-
redirect
"
false
]
[
"
network
.
http
.
speculative
-
parallel
-
limit
"
0
]
[
"
network
.
manage
-
offline
-
status
"
false
]
[
"
network
.
sntp
.
pools
"
"
%
(
server
)
s
"
]
[
"
security
.
fileuri
.
strict_origin_policy
"
false
]
[
"
security
.
notification_enable_delay
"
0
]
[
"
services
.
settings
.
server
"
"
http
:
/
/
%
(
server
)
s
/
dummy
/
blocklist
/
"
]
[
"
signon
.
autofillForms
"
false
]
[
"
signon
.
rememberSignons
"
false
]
[
"
startup
.
homepage_welcome_url
"
"
about
:
blank
"
]
[
"
startup
.
homepage_welcome_url
.
additional
"
"
"
]
[
"
toolkit
.
startup
.
max_resumed_crashes
"
-
1
]
]
)
;
server
.
TCPListener
=
class
{
constructor
(
port
)
{
this
.
port
=
port
;
this
.
socket
=
null
;
this
.
conns
=
new
Set
(
)
;
this
.
nextConnID
=
0
;
this
.
alive
=
false
;
this
.
_acceptConnections
=
false
;
this
.
alteredPrefs
=
new
Set
(
)
;
}
driverFactory
(
)
{
Preferences
.
set
(
PREF_CONTENT_LISTENER
false
)
;
return
new
GeckoDriver
(
Services
.
appinfo
.
name
this
)
;
}
set
acceptConnections
(
value
)
{
if
(
!
value
)
{
logger
.
info
(
"
New
connections
will
no
longer
be
accepted
"
)
;
}
else
{
logger
.
info
(
"
New
connections
are
accepted
again
"
)
;
}
this
.
_acceptConnections
=
value
;
}
start
(
)
{
if
(
this
.
alive
)
{
return
;
}
Services
.
obs
.
notifyObservers
(
this
NOTIFY_RUNNING
true
)
;
if
(
Preferences
.
get
(
PREF_RECOMMENDED
)
)
{
for
(
let
[
k
v
]
of
RECOMMENDED_PREFS
)
{
if
(
!
Preferences
.
isSet
(
k
)
)
{
logger
.
debug
(
Setting
recommended
pref
{
k
}
to
{
v
}
)
;
Preferences
.
set
(
k
v
)
;
this
.
alteredPrefs
.
add
(
k
)
;
}
}
}
const
flags
=
KeepWhenOffline
|
LoopbackOnly
;
const
backlog
=
1
;
this
.
socket
=
new
ServerSocket
(
this
.
port
flags
backlog
)
;
this
.
socket
.
asyncListen
(
this
)
;
this
.
port
=
this
.
socket
.
port
;
Preferences
.
set
(
PREF_PORT
this
.
port
)
;
this
.
alive
=
true
;
this
.
_acceptConnections
=
true
;
env
.
set
(
ENV_ENABLED
"
1
"
)
;
}
stop
(
)
{
if
(
!
this
.
alive
)
{
return
;
}
this
.
_acceptConnections
=
false
;
this
.
socket
.
close
(
)
;
this
.
socket
=
null
;
for
(
let
k
of
this
.
alteredPrefs
)
{
logger
.
debug
(
Resetting
recommended
pref
{
k
}
)
;
Preferences
.
reset
(
k
)
;
}
this
.
alteredPrefs
.
clear
(
)
;
Services
.
obs
.
notifyObservers
(
this
NOTIFY_RUNNING
)
;
this
.
alive
=
false
;
}
onSocketAccepted
(
serverSocket
clientSocket
)
{
if
(
!
this
.
_acceptConnections
)
{
logger
.
warn
(
"
New
connections
are
currently
not
accepted
"
)
;
return
;
}
let
input
=
clientSocket
.
openInputStream
(
0
0
0
)
;
let
output
=
clientSocket
.
openOutputStream
(
0
0
0
)
;
let
transport
=
new
DebuggerTransport
(
input
output
)
;
let
conn
=
new
server
.
TCPConnection
(
this
.
nextConnID
+
+
transport
this
.
driverFactory
.
bind
(
this
)
)
;
conn
.
onclose
=
this
.
onConnectionClosed
.
bind
(
this
)
;
this
.
conns
.
add
(
conn
)
;
logger
.
debug
(
Accepted
connection
{
conn
.
id
}
+
from
{
clientSocket
.
host
}
:
{
clientSocket
.
port
}
)
;
conn
.
sayHello
(
)
;
transport
.
ready
(
)
;
}
onConnectionClosed
(
conn
)
{
logger
.
debug
(
Closed
connection
{
conn
.
id
}
)
;
this
.
conns
.
delete
(
conn
)
;
}
}
;
server
.
TCPConnection
=
class
{
constructor
(
connID
transport
driverFactory
)
{
this
.
id
=
connID
;
this
.
conn
=
transport
;
this
.
conn
.
hooks
=
this
;
this
.
onclose
=
null
;
this
.
lastID
=
0
;
this
.
driver
=
driverFactory
(
)
;
this
.
commands_
=
new
Map
(
)
;
}
onClosed
(
reason
)
{
this
.
driver
.
deleteSession
(
)
;
if
(
this
.
onclose
)
{
this
.
onclose
(
this
)
;
}
}
onPacket
(
data
)
{
if
(
!
Array
.
isArray
(
data
)
)
{
let
e
=
new
TypeError
(
"
Unable
to
unmarshal
packet
data
:
"
+
JSON
.
stringify
(
data
)
)
;
error
.
report
(
e
)
;
return
;
}
let
msg
;
try
{
msg
=
Message
.
fromMsg
(
data
)
;
msg
.
origin
=
MessageOrigin
.
Client
;
this
.
log_
(
msg
)
;
}
catch
(
e
)
{
let
resp
=
this
.
createResponse
(
data
[
1
]
)
;
resp
.
sendError
(
e
)
;
return
;
}
if
(
msg
instanceof
Response
)
{
let
cmd
=
this
.
commands_
.
get
(
msg
.
id
)
;
this
.
commands_
.
delete
(
msg
.
id
)
;
cmd
.
onresponse
(
msg
)
;
}
else
if
(
msg
instanceof
Command
)
{
(
async
(
)
=
>
{
await
this
.
execute
(
msg
)
;
}
)
(
)
;
}
}
async
execute
(
cmd
)
{
let
resp
=
this
.
createResponse
(
cmd
.
id
)
;
let
sendResponse
=
(
)
=
>
resp
.
sendConditionally
(
resp
=
>
!
resp
.
sent
)
;
let
sendError
=
resp
.
sendError
.
bind
(
resp
)
;
await
this
.
despatch
(
cmd
resp
)
.
then
(
sendResponse
sendError
)
.
catch
(
error
.
report
)
;
}
async
despatch
(
cmd
resp
)
{
let
fn
=
this
.
driver
.
commands
[
cmd
.
name
]
;
if
(
typeof
fn
=
=
"
undefined
"
)
{
throw
new
UnknownCommandError
(
cmd
.
name
)
;
}
if
(
!
[
"
newSession
"
"
WebDriver
:
NewSession
"
]
.
includes
(
cmd
.
name
)
)
{
assert
.
session
(
this
.
driver
)
;
}
let
rv
=
await
fn
.
bind
(
this
.
driver
)
(
cmd
resp
)
;
if
(
typeof
rv
!
=
"
undefined
"
)
{
if
(
typeof
rv
!
=
"
object
"
)
{
resp
.
body
=
{
value
:
rv
}
;
}
else
{
resp
.
body
=
rv
;
}
}
}
createResponse
(
msgID
)
{
if
(
typeof
msgID
!
=
"
number
"
)
{
msgID
=
-
1
;
}
return
new
Response
(
msgID
this
.
send
.
bind
(
this
)
)
;
}
sendError
(
err
cmdID
)
{
let
resp
=
new
Response
(
cmdID
this
.
send
.
bind
(
this
)
)
;
resp
.
sendError
(
err
)
;
}
sayHello
(
)
{
let
whatHo
=
{
applicationType
:
"
gecko
"
marionetteProtocol
:
PROTOCOL_VERSION
}
;
this
.
sendRaw
(
whatHo
)
;
}
send
(
msg
)
{
msg
.
origin
=
MessageOrigin
.
Server
;
if
(
msg
instanceof
Command
)
{
this
.
commands_
.
set
(
msg
.
id
msg
)
;
this
.
sendToEmulator
(
msg
)
;
}
else
if
(
msg
instanceof
Response
)
{
this
.
sendToClient
(
msg
)
;
}
}
sendToClient
(
resp
)
{
this
.
driver
.
responseCompleted
(
)
;
this
.
sendMessage
(
resp
)
;
}
sendMessage
(
msg
)
{
this
.
log_
(
msg
)
;
let
payload
=
msg
.
toMsg
(
)
;
this
.
sendRaw
(
payload
)
;
}
sendRaw
(
payload
)
{
this
.
conn
.
send
(
payload
)
;
}
log_
(
msg
)
{
let
a
=
(
msg
.
origin
=
=
MessageOrigin
.
Client
?
"
-
>
"
:
"
<
-
"
)
;
let
s
=
JSON
.
stringify
(
msg
.
toMsg
(
)
)
;
logger
.
trace
(
this
.
id
+
a
+
s
)
;
}
toString
(
)
{
return
[
object
server
.
TCPConnection
{
this
.
id
}
]
;
}
}
;
