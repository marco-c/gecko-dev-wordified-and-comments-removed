"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
error
WebDriverError
}
=
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
{
}
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
modal
.
js
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
proxy
"
]
;
const
uuidgen
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
var
ownPriorityGetterTrap
=
{
get
:
(
obj
prop
)
=
>
{
if
(
obj
.
hasOwnProperty
(
prop
)
)
{
return
obj
[
prop
]
;
}
return
(
.
.
.
args
)
=
>
obj
.
send
(
prop
args
)
;
}
}
;
this
.
proxy
=
{
}
;
proxy
.
toListener
=
function
(
mmFn
sendAsyncFn
browserFn
)
{
let
sender
=
new
proxy
.
AsyncMessageChannel
(
mmFn
sendAsyncFn
browserFn
)
;
return
new
Proxy
(
sender
ownPriorityGetterTrap
)
;
}
;
proxy
.
AsyncMessageChannel
=
class
{
constructor
(
mmFn
sendAsyncFn
browserFn
)
{
this
.
mmFn_
=
mmFn
;
this
.
sendAsync
=
sendAsyncFn
;
this
.
browserFn_
=
browserFn
;
this
.
activeMessageId
=
null
;
this
.
listeners_
=
new
Map
(
)
;
this
.
dialogueObserver_
=
null
;
this
.
closeHandler
=
null
;
}
get
browser
(
)
{
return
this
.
browserFn_
(
)
;
}
get
mm
(
)
{
return
this
.
mmFn_
(
)
;
}
send
(
name
args
=
[
]
)
{
let
uuid
=
uuidgen
.
generateUUID
(
)
.
toString
(
)
;
this
.
activeMessageId
=
uuid
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
path
=
proxy
.
AsyncMessageChannel
.
makePath
(
uuid
)
;
let
cb
=
msg
=
>
{
this
.
activeMessageId
=
null
;
switch
(
msg
.
json
.
type
)
{
case
proxy
.
AsyncMessageChannel
.
ReplyType
.
Ok
:
case
proxy
.
AsyncMessageChannel
.
ReplyType
.
Value
:
resolve
(
msg
.
json
.
data
)
;
break
;
case
proxy
.
AsyncMessageChannel
.
ReplyType
.
Error
:
let
err
=
WebDriverError
.
fromJSON
(
msg
.
json
.
data
)
;
reject
(
err
)
;
break
;
default
:
throw
new
TypeError
(
Unknown
async
response
type
:
{
msg
.
json
.
type
}
)
;
}
}
;
this
.
closeHandler
=
event
=
>
{
logger
.
debug
(
Received
DOM
event
{
event
.
type
}
for
{
event
.
target
}
)
;
switch
(
event
.
type
)
{
case
"
TabClose
"
:
case
"
unload
"
:
this
.
removeHandlers
(
)
;
resolve
(
)
;
break
;
}
}
;
this
.
dialogueObserver_
=
(
subject
topic
)
=
>
{
logger
.
debug
(
Received
observer
notification
"
{
topic
}
"
)
;
this
.
removeAllListeners_
(
)
;
this
.
sendAsync
(
"
cancelRequest
"
)
;
this
.
removeHandlers
(
)
;
resolve
(
)
;
}
;
this
.
addListener_
(
path
cb
)
;
this
.
addHandlers
(
)
;
this
.
sendAsync
(
name
marshal
(
args
)
uuid
)
;
}
)
;
}
addHandlers
(
)
{
modal
.
addHandler
(
this
.
dialogueObserver_
)
;
if
(
this
.
browser
)
{
this
.
browser
.
window
.
addEventListener
(
"
unload
"
this
.
closeHandler
)
;
if
(
this
.
browser
.
tab
)
{
let
node
=
this
.
browser
.
tab
.
addEventListener
?
this
.
browser
.
tab
:
this
.
browser
.
contentBrowser
;
node
.
addEventListener
(
"
TabClose
"
this
.
closeHandler
)
;
}
}
}
removeHandlers
(
)
{
modal
.
removeHandler
(
this
.
dialogueObserver_
)
;
if
(
this
.
browser
)
{
this
.
browser
.
window
.
removeEventListener
(
"
unload
"
this
.
closeHandler
)
;
if
(
this
.
browser
.
tab
)
{
let
node
=
this
.
browser
.
tab
.
addEventListener
?
this
.
browser
.
tab
:
this
.
browser
.
contentBrowser
;
node
.
removeEventListener
(
"
TabClose
"
this
.
closeHandler
)
;
}
}
}
reply
(
uuid
obj
=
undefined
)
{
if
(
typeof
obj
=
=
"
undefined
"
)
{
this
.
sendReply_
(
uuid
proxy
.
AsyncMessageChannel
.
ReplyType
.
Ok
)
;
}
else
if
(
error
.
isError
(
obj
)
)
{
let
err
=
error
.
wrap
(
obj
)
;
this
.
sendReply_
(
uuid
proxy
.
AsyncMessageChannel
.
ReplyType
.
Error
err
)
;
}
else
{
this
.
sendReply_
(
uuid
proxy
.
AsyncMessageChannel
.
ReplyType
.
Value
obj
)
;
}
}
sendReply_
(
uuid
type
data
=
undefined
)
{
const
path
=
proxy
.
AsyncMessageChannel
.
makePath
(
uuid
)
;
let
payload
;
if
(
data
&
&
typeof
data
.
toJSON
=
=
"
function
"
)
{
payload
=
data
.
toJSON
(
)
;
}
else
{
payload
=
data
;
}
const
msg
=
{
type
data
:
payload
}
;
this
.
sendAsync
(
path
msg
)
;
}
static
makePath
(
uuid
)
{
return
"
Marionette
:
asyncReply
:
"
+
uuid
;
}
addListener_
(
path
callback
)
{
let
autoRemover
=
msg
=
>
{
this
.
removeListener_
(
path
)
;
this
.
removeHandlers
(
)
;
callback
(
msg
)
;
}
;
this
.
mm
.
addMessageListener
(
path
autoRemover
)
;
this
.
listeners_
.
set
(
path
autoRemover
)
;
}
removeListener_
(
path
)
{
if
(
!
this
.
listeners_
.
has
(
path
)
)
{
return
true
;
}
let
l
=
this
.
listeners_
.
get
(
path
)
;
this
.
mm
.
removeMessageListener
(
path
l
[
1
]
)
;
return
this
.
listeners_
.
delete
(
path
)
;
}
removeAllListeners_
(
)
{
let
ok
=
true
;
for
(
let
[
p
]
of
this
.
listeners_
)
{
ok
|
=
this
.
removeListener_
(
p
)
;
}
return
ok
;
}
}
;
proxy
.
AsyncMessageChannel
.
ReplyType
=
{
Ok
:
0
Value
:
1
Error
:
2
}
;
proxy
.
toChromeAsync
=
function
(
frameMessageManager
)
{
let
sender
=
new
AsyncChromeSender
(
frameMessageManager
)
;
return
new
Proxy
(
sender
ownPriorityGetterTrap
)
;
}
;
class
AsyncChromeSender
{
constructor
(
frameMessageManager
)
{
this
.
mm
=
frameMessageManager
;
}
send
(
name
args
)
{
let
uuid
=
uuidgen
.
generateUUID
(
)
.
toString
(
)
;
let
proxy
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
responseListener
=
msg
=
>
{
if
(
msg
.
json
.
id
!
=
uuid
)
{
return
;
}
this
.
mm
.
removeMessageListener
(
"
Marionette
:
listenerResponse
"
responseListener
)
;
if
(
"
value
"
in
msg
.
json
)
{
resolve
(
msg
.
json
.
value
)
;
}
else
if
(
"
error
"
in
msg
.
json
)
{
reject
(
msg
.
json
.
error
)
;
}
else
{
throw
new
TypeError
(
Unexpected
response
:
{
msg
.
name
}
{
JSON
.
stringify
(
msg
.
json
)
}
)
;
}
}
;
let
msg
=
{
arguments
:
marshal
(
args
)
id
:
uuid
}
;
this
.
mm
.
addMessageListener
(
"
Marionette
:
listenerResponse
"
responseListener
)
;
this
.
mm
.
sendAsyncMessage
(
"
Marionette
:
"
+
name
msg
)
;
}
)
;
return
proxy
;
}
}
proxy
.
toChrome
=
function
(
sendSyncMessageFn
)
{
let
sender
=
new
proxy
.
SyncChromeSender
(
sendSyncMessageFn
)
;
return
new
Proxy
(
sender
ownPriorityGetterTrap
)
;
}
;
proxy
.
SyncChromeSender
=
class
{
constructor
(
sendSyncMessage
)
{
this
.
sendSyncMessage_
=
sendSyncMessage
;
}
send
(
func
args
)
{
let
name
=
"
Marionette
:
"
+
func
.
toString
(
)
;
return
this
.
sendSyncMessage_
(
name
marshal
(
args
)
)
;
}
}
;
var
marshal
=
function
(
args
)
{
if
(
args
.
length
=
=
1
&
&
typeof
args
[
0
]
=
=
"
object
"
)
{
return
args
[
0
]
;
}
return
args
;
}
;
