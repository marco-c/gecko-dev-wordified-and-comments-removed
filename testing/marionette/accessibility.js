"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
setInterval
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
clearInterval
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
service
"
(
)
=
>
Cc
[
"
mozilla
.
org
/
accessibilityService
;
1
"
]
.
getService
(
Ci
.
nsIAccessibilityService
)
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
accessibility
"
]
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
const
GET_ACCESSIBLE_ATTEMPTS
=
100
;
const
GET_ACCESSIBLE_ATTEMPT_INTERVAL
=
10
;
this
.
accessibility
=
{
}
;
accessibility
.
State
=
{
Unavailable
:
Ci
.
nsIAccessibleStates
.
STATE_UNAVAILABLE
Focusable
:
Ci
.
nsIAccessibleStates
.
STATE_FOCUSABLE
Selectable
:
Ci
.
nsIAccessibleStates
.
STATE_SELECTABLE
Selected
:
Ci
.
nsIAccessibleStates
.
STATE_SELECTED
}
;
accessibility
.
ActionableRoles
=
new
Set
(
[
"
checkbutton
"
"
check
menu
item
"
"
check
rich
option
"
"
combobox
"
"
combobox
option
"
"
entry
"
"
key
"
"
link
"
"
listbox
option
"
"
listbox
rich
option
"
"
menuitem
"
"
option
"
"
outlineitem
"
"
pagetab
"
"
pushbutton
"
"
radiobutton
"
"
radio
menu
item
"
"
rowheader
"
"
slider
"
"
spinbutton
"
"
switch
"
]
)
;
accessibility
.
get
=
function
(
strict
=
false
)
{
return
new
accessibility
.
Checks
(
!
!
strict
)
;
}
;
accessibility
.
Checks
=
class
{
constructor
(
strict
)
{
this
.
strict
=
strict
;
}
getAccessible
(
element
mustHaveAccessible
=
false
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
acc
=
service
.
getAccessibleFor
(
element
)
;
if
(
acc
|
|
!
mustHaveAccessible
)
{
resolve
(
acc
)
;
}
else
if
(
mustHaveAccessible
&
&
!
this
.
strict
)
{
reject
(
)
;
}
else
{
let
attempts
=
GET_ACCESSIBLE_ATTEMPTS
;
let
intervalId
=
setInterval
(
(
)
=
>
{
let
acc
=
service
.
getAccessibleFor
(
element
)
;
if
(
acc
|
|
-
-
attempts
<
=
0
)
{
clearInterval
(
intervalId
)
;
if
(
acc
)
{
resolve
(
acc
)
;
}
else
{
reject
(
)
;
}
}
}
GET_ACCESSIBLE_ATTEMPT_INTERVAL
)
;
}
}
)
.
catch
(
(
)
=
>
this
.
error
(
"
Element
does
not
have
an
accessible
object
"
element
)
)
;
}
;
isActionableRole
(
accessible
)
{
return
accessibility
.
ActionableRoles
.
has
(
service
.
getStringRole
(
accessible
.
role
)
)
;
}
hasActionCount
(
accessible
)
{
return
accessible
.
actionCount
>
0
;
}
hasValidName
(
accessible
)
{
return
accessible
.
name
&
&
accessible
.
name
.
trim
(
)
;
}
hasHiddenAttribute
(
accessible
)
{
let
hidden
=
false
;
try
{
hidden
=
accessible
.
attributes
.
getStringProperty
(
"
hidden
"
)
;
}
finally
{
return
hidden
&
&
hidden
=
=
=
"
true
"
;
}
}
matchState
(
accessible
stateToMatch
)
{
let
state
=
{
}
;
accessible
.
getState
(
state
{
}
)
;
return
!
!
(
state
.
value
&
stateToMatch
)
;
}
isHidden
(
accessible
)
{
while
(
accessible
)
{
if
(
this
.
hasHiddenAttribute
(
accessible
)
)
{
return
true
;
}
accessible
=
accessible
.
parent
;
}
return
false
;
}
checkVisible
(
accessible
element
visible
)
{
if
(
!
accessible
)
{
return
;
}
let
hiddenAccessibility
=
this
.
isHidden
(
accessible
)
;
let
message
;
if
(
visible
&
&
hiddenAccessibility
)
{
message
=
"
Element
is
not
currently
visible
via
the
accessibility
API
"
+
"
and
may
not
be
manipulated
by
it
"
;
}
else
if
(
!
visible
&
&
!
hiddenAccessibility
)
{
message
=
"
Element
is
currently
only
visible
via
the
accessibility
API
"
+
"
and
can
be
manipulated
by
it
"
;
}
this
.
error
(
message
element
)
;
}
checkEnabled
(
accessible
element
enabled
)
{
if
(
!
accessible
)
{
return
;
}
let
win
=
element
.
ownerDocument
.
defaultView
;
let
disabledAccessibility
=
this
.
matchState
(
accessible
accessibility
.
State
.
Unavailable
)
;
let
explorable
=
win
.
getComputedStyle
(
element
)
.
getPropertyValue
(
"
pointer
-
events
"
)
!
=
=
"
none
"
;
let
message
;
if
(
!
explorable
&
&
!
disabledAccessibility
)
{
message
=
"
Element
is
enabled
but
is
not
explorable
via
the
"
+
"
accessibility
API
"
;
}
else
if
(
enabled
&
&
disabledAccessibility
)
{
message
=
"
Element
is
enabled
but
disabled
via
the
accessibility
API
"
;
}
else
if
(
!
enabled
&
&
!
disabledAccessibility
)
{
message
=
"
Element
is
disabled
but
enabled
via
the
accessibility
API
"
;
}
this
.
error
(
message
element
)
;
}
checkActionable
(
accessible
element
)
{
if
(
!
accessible
)
{
return
;
}
let
message
;
if
(
!
this
.
hasActionCount
(
accessible
)
)
{
message
=
"
Element
does
not
support
any
accessible
actions
"
;
}
else
if
(
!
this
.
isActionableRole
(
accessible
)
)
{
message
=
"
Element
does
not
have
a
correct
accessibility
role
"
+
"
and
may
not
be
manipulated
via
the
accessibility
API
"
;
}
else
if
(
!
this
.
hasValidName
(
accessible
)
)
{
message
=
"
Element
is
missing
an
accessible
name
"
;
}
else
if
(
!
this
.
matchState
(
accessible
accessibility
.
State
.
Focusable
)
)
{
message
=
"
Element
is
not
focusable
via
the
accessibility
API
"
;
}
this
.
error
(
message
element
)
;
}
checkSelected
(
accessible
element
selected
)
{
if
(
!
accessible
)
{
return
;
}
if
(
!
this
.
matchState
(
accessible
accessibility
.
State
.
Selectable
)
)
{
return
;
}
let
selectedAccessibility
=
this
.
matchState
(
accessible
accessibility
.
State
.
Selected
)
;
let
message
;
if
(
selected
&
&
!
selectedAccessibility
)
{
message
=
"
Element
is
selected
but
not
selected
via
the
accessibility
API
"
;
}
else
if
(
!
selected
&
&
selectedAccessibility
)
{
message
=
"
Element
is
not
selected
but
selected
via
the
accessibility
API
"
;
}
this
.
error
(
message
element
)
;
}
error
(
message
element
)
{
if
(
!
message
)
{
return
;
}
if
(
element
)
{
let
{
id
tagName
className
}
=
element
;
message
+
=
:
id
:
{
id
}
tagName
:
{
tagName
}
className
:
{
className
}
;
}
if
(
this
.
strict
)
{
throw
new
ElementNotAccessibleError
(
message
)
;
}
logger
.
debug
(
message
)
;
}
}
;
