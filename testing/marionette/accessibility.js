var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
'
)
;
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
Log
.
jsm
'
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
'
setInterval
'
'
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
'
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
'
clearInterval
'
'
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
'
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
'
ElementNotAccessibleError
'
'
chrome
:
/
/
marionette
/
content
/
error
.
js
'
)
;
this
.
EXPORTED_SYMBOLS
=
[
'
Accessibility
'
]
;
const
states
=
{
unavailable
:
Ci
.
nsIAccessibleStates
.
STATE_UNAVAILABLE
focusable
:
Ci
.
nsIAccessibleStates
.
STATE_FOCUSABLE
selectable
:
Ci
.
nsIAccessibleStates
.
STATE_SELECTABLE
selected
:
Ci
.
nsIAccessibleStates
.
STATE_SELECTED
}
;
var
logger
=
Log
.
repository
.
getLogger
(
'
Marionette
'
)
;
this
.
Accessibility
=
function
Accessibility
(
getCapabilies
=
(
)
=
>
{
}
)
{
Object
.
defineProperty
(
this
'
strict
'
{
configurable
:
true
get
:
function
(
)
{
let
capabilies
=
getCapabilies
(
)
;
return
!
!
capabilies
.
raisesAccessibilityExceptions
;
}
}
)
;
Object
.
defineProperty
(
this
'
retrieval
'
{
configurable
:
true
get
:
function
(
)
{
delete
this
.
retrieval
;
this
.
retrieval
=
Cc
[
'
mozilla
.
org
/
accessibleRetrieval
;
1
'
]
.
getService
(
Ci
.
nsIAccessibleRetrieval
)
;
return
this
.
retrieval
;
}
}
)
;
}
;
Accessibility
.
prototype
=
{
GET_ACCESSIBLE_ATTEMPTS
:
100
GET_ACCESSIBLE_ATTEMPT_INTERVAL
:
10
ACTIONABLE_ROLES
:
new
Set
(
[
'
pushbutton
'
'
checkbutton
'
'
combobox
'
'
key
'
'
link
'
'
menuitem
'
'
check
menu
item
'
'
radio
menu
item
'
'
option
'
'
listbox
option
'
'
listbox
rich
option
'
'
check
rich
option
'
'
combobox
option
'
'
radiobutton
'
'
rowheader
'
'
switch
'
'
slider
'
'
spinbutton
'
'
pagetab
'
'
entry
'
'
outlineitem
'
]
)
getAccessibleObject
(
element
mustHaveAccessible
=
false
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
acc
=
this
.
retrieval
.
getAccessibleFor
(
element
)
;
if
(
acc
|
|
!
mustHaveAccessible
)
{
resolve
(
acc
)
;
}
else
if
(
mustHaveAccessible
&
&
!
this
.
strict
)
{
reject
(
)
;
}
else
{
let
attempts
=
this
.
GET_ACCESSIBLE_ATTEMPTS
;
let
intervalId
=
setInterval
(
(
)
=
>
{
let
acc
=
this
.
retrieval
.
getAccessibleFor
(
element
)
;
if
(
acc
|
|
-
-
attempts
<
=
0
)
{
clearInterval
(
intervalId
)
;
if
(
acc
)
{
resolve
(
acc
)
;
}
else
{
reject
(
)
;
}
}
}
this
.
GET_ACCESSIBLE_ATTEMPT_INTERVAL
)
;
}
}
)
.
catch
(
(
)
=
>
this
.
error
(
'
Element
does
not
have
an
accessible
object
'
element
)
)
;
}
isActionableRole
(
accessible
)
{
return
this
.
ACTIONABLE_ROLES
.
has
(
this
.
retrieval
.
getStringRole
(
accessible
.
role
)
)
;
}
hasActionCount
(
accessible
)
{
return
accessible
.
actionCount
>
0
;
}
hasValidName
(
accessible
)
{
return
accessible
.
name
&
&
accessible
.
name
.
trim
(
)
;
}
hasHiddenAttribute
(
accessible
)
{
let
hidden
=
false
;
try
{
hidden
=
accessible
.
attributes
.
getStringProperty
(
'
hidden
'
)
;
}
finally
{
return
hidden
&
&
hidden
=
=
=
'
true
'
;
}
}
matchState
(
accessible
stateToMatch
)
{
let
state
=
{
}
;
accessible
.
getState
(
state
{
}
)
;
return
!
!
(
state
.
value
&
stateToMatch
)
;
}
isHidden
(
accessible
)
{
while
(
accessible
)
{
if
(
this
.
hasHiddenAttribute
(
accessible
)
)
{
return
true
;
}
accessible
=
accessible
.
parent
;
}
return
false
;
}
error
(
message
element
)
{
if
(
!
message
)
{
return
;
}
if
(
element
)
{
let
{
id
tagName
className
}
=
element
;
message
+
=
:
id
:
{
id
}
tagName
:
{
tagName
}
className
:
{
className
}
;
}
if
(
this
.
strict
)
{
throw
new
ElementNotAccessibleError
(
message
)
;
}
logger
.
debug
(
message
)
;
}
checkVisible
(
accessible
element
visible
)
{
if
(
!
accessible
)
{
return
;
}
let
hiddenAccessibility
=
this
.
isHidden
(
accessible
)
;
let
message
;
if
(
visible
&
&
hiddenAccessibility
)
{
message
=
'
Element
is
not
currently
visible
via
the
accessibility
API
'
+
'
and
may
not
be
manipulated
by
it
'
;
}
else
if
(
!
visible
&
&
!
hiddenAccessibility
)
{
message
=
'
Element
is
currently
only
visible
via
the
accessibility
API
'
+
'
and
can
be
manipulated
by
it
'
;
}
this
.
error
(
message
element
)
;
}
checkEnabled
(
accessible
element
enabled
container
)
{
if
(
!
accessible
)
{
return
;
}
let
disabledAccessibility
=
this
.
matchState
(
accessible
states
.
unavailable
)
;
let
explorable
=
container
.
frame
.
document
.
defaultView
.
getComputedStyle
(
element
)
.
getPropertyValue
(
'
pointer
-
events
'
)
!
=
=
'
none
'
;
let
message
;
if
(
!
explorable
&
&
!
disabledAccessibility
)
{
message
=
'
Element
is
enabled
but
is
not
explorable
via
the
'
+
'
accessibility
API
'
;
}
else
if
(
enabled
&
&
disabledAccessibility
)
{
message
=
'
Element
is
enabled
but
disabled
via
the
accessibility
API
'
;
}
else
if
(
!
enabled
&
&
!
disabledAccessibility
)
{
message
=
'
Element
is
disabled
but
enabled
via
the
accessibility
API
'
;
}
this
.
error
(
message
element
)
;
}
checkActionable
(
accessible
element
)
{
if
(
!
accessible
)
{
return
;
}
let
message
;
if
(
!
this
.
hasActionCount
(
accessible
)
)
{
message
=
'
Element
does
not
support
any
accessible
actions
'
;
}
else
if
(
!
this
.
isActionableRole
(
accessible
)
)
{
message
=
'
Element
does
not
have
a
correct
accessibility
role
'
+
'
and
may
not
be
manipulated
via
the
accessibility
API
'
;
}
else
if
(
!
this
.
hasValidName
(
accessible
)
)
{
message
=
'
Element
is
missing
an
accessible
name
'
;
}
else
if
(
!
this
.
matchState
(
accessible
states
.
focusable
)
)
{
message
=
'
Element
is
not
focusable
via
the
accessibility
API
'
;
}
this
.
error
(
message
element
)
;
}
checkSelected
(
accessible
element
selected
)
{
if
(
!
accessible
)
{
return
;
}
if
(
!
this
.
matchState
(
accessible
states
.
selectable
)
)
{
return
;
}
let
selectedAccessibility
=
this
.
matchState
(
accessible
states
.
selected
)
;
let
message
;
if
(
selected
&
&
!
selectedAccessibility
)
{
message
=
'
Element
is
selected
but
not
selected
via
the
accessibility
API
'
;
}
else
if
(
!
selected
&
&
selectedAccessibility
)
{
message
=
'
Element
is
not
selected
but
selected
via
the
accessibility
API
'
;
}
this
.
error
(
message
element
)
;
}
}
;
