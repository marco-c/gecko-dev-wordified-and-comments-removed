var
{
utils
:
Cu
}
=
Components
;
this
.
EXPORTED_SYMBOLS
=
[
'
Interactions
'
]
;
Cu
.
import
(
'
chrome
:
/
/
marionette
/
content
/
accessibility
.
js
'
)
;
Cu
.
import
(
'
chrome
:
/
/
marionette
/
content
/
error
.
js
'
)
;
const
DISABLED_ATTRIBUTE_SUPPORTED_XUL
=
new
Set
(
[
'
ARROWSCROLLBOX
'
'
BUTTON
'
'
CHECKBOX
'
'
COLORPICKER
'
'
COMMAND
'
'
DATEPICKER
'
'
DESCRIPTION
'
'
KEY
'
'
KEYSET
'
'
LABEL
'
'
LISTBOX
'
'
LISTCELL
'
'
LISTHEAD
'
'
LISTHEADER
'
'
LISTITEM
'
'
MENU
'
'
MENUITEM
'
'
MENULIST
'
'
MENUSEPARATOR
'
'
PREFERENCE
'
'
RADIO
'
'
RADIOGROUP
'
'
RICHLISTBOX
'
'
RICHLISTITEM
'
'
SCALE
'
'
TAB
'
'
TABS
'
'
TEXTBOX
'
'
TIMEPICKER
'
'
TOOLBARBUTTON
'
'
TREE
'
]
)
;
const
CHECKED_PROPERTY_SUPPORTED_XUL
=
new
Set
(
[
'
BUTTON
'
'
CHECKBOX
'
'
LISTITEM
'
'
TOOLBARBUTTON
'
]
)
;
const
SELECTED_PROPERTY_SUPPORTED_XUL
=
new
Set
(
[
'
LISTITEM
'
'
MENU
'
'
MENUITEM
'
'
MENUSEPARATOR
'
'
RADIO
'
'
RICHLISTITEM
'
'
TAB
'
]
)
;
function
coordinates
(
target
x
y
)
{
let
box
=
target
.
getBoundingClientRect
(
)
;
if
(
typeof
x
=
=
=
'
undefined
'
)
{
x
=
box
.
width
/
2
;
}
if
(
typeof
y
=
=
=
'
undefined
'
)
{
y
=
box
.
height
/
2
;
}
return
{
x
:
box
.
left
+
x
y
:
box
.
top
+
y
}
;
}
this
.
Interactions
=
function
(
utils
getCapabilies
)
{
this
.
utils
=
utils
;
this
.
accessibility
=
new
Accessibility
(
getCapabilies
)
;
}
;
Interactions
.
prototype
=
{
clickElement
(
container
elementManager
id
)
{
let
el
=
elementManager
.
getKnownElement
(
id
container
)
;
let
visible
=
this
.
checkVisible
(
container
el
)
;
if
(
!
visible
)
{
throw
new
ElementNotVisibleError
(
'
Element
is
not
visible
'
)
;
}
return
this
.
accessibility
.
getAccessibleObject
(
el
true
)
.
then
(
acc
=
>
{
this
.
accessibility
.
checkVisible
(
acc
el
visible
)
;
if
(
this
.
utils
.
isElementEnabled
(
el
)
)
{
this
.
accessibility
.
checkEnabled
(
acc
el
true
container
)
;
this
.
accessibility
.
checkActionable
(
acc
el
)
;
if
(
this
.
isXULElement
(
el
)
)
{
el
.
click
(
)
;
}
else
{
let
rects
=
el
.
getClientRects
(
)
;
this
.
utils
.
synthesizeMouseAtPoint
(
rects
[
0
]
.
left
+
rects
[
0
]
.
width
/
2
rects
[
0
]
.
top
+
rects
[
0
]
.
height
/
2
{
}
el
.
ownerDocument
.
defaultView
)
;
}
}
else
{
throw
new
InvalidElementStateError
(
'
Element
is
not
enabled
'
)
;
}
}
)
;
}
sendKeysToElement
(
container
elementManager
id
value
ignoreVisibility
)
{
let
el
=
elementManager
.
getKnownElement
(
id
container
)
;
return
this
.
accessibility
.
getAccessibleObject
(
el
true
)
.
then
(
acc
=
>
{
this
.
accessibility
.
checkActionable
(
acc
el
)
;
this
.
utils
.
sendKeysToElement
(
container
.
frame
el
value
ignoreVisibility
)
;
}
)
;
}
isElementDisplayed
(
container
elementManager
id
)
{
let
el
=
elementManager
.
getKnownElement
(
id
container
)
;
let
displayed
=
this
.
utils
.
isElementDisplayed
(
el
)
;
return
this
.
accessibility
.
getAccessibleObject
(
el
)
.
then
(
acc
=
>
{
this
.
accessibility
.
checkVisible
(
acc
el
displayed
)
;
return
displayed
;
}
)
;
}
isElementEnabled
(
container
elementManager
id
)
{
let
el
=
elementManager
.
getKnownElement
(
id
container
)
;
let
enabled
=
true
;
if
(
this
.
isXULElement
(
el
)
)
{
if
(
DISABLED_ATTRIBUTE_SUPPORTED_XUL
.
has
(
el
.
tagName
.
toUpperCase
(
)
)
)
{
let
disabled
=
this
.
utils
.
getElementAttribute
(
el
'
disabled
'
)
;
if
(
disabled
&
&
disabled
=
=
=
'
true
'
)
{
enabled
=
false
;
}
}
}
else
{
enabled
=
this
.
utils
.
isElementEnabled
(
el
)
;
}
return
this
.
accessibility
.
getAccessibleObject
(
el
)
.
then
(
acc
=
>
{
this
.
accessibility
.
checkEnabled
(
acc
el
enabled
container
)
;
return
enabled
;
}
)
;
}
isElementSelected
(
container
elementManager
id
)
{
let
el
=
elementManager
.
getKnownElement
(
id
container
)
;
let
selected
=
true
;
if
(
this
.
isXULElement
(
el
)
)
{
let
tagName
=
el
.
tagName
.
toUpperCase
(
)
;
if
(
CHECKED_PROPERTY_SUPPORTED_XUL
.
has
(
tagName
)
)
{
selected
=
el
.
checked
;
}
if
(
SELECTED_PROPERTY_SUPPORTED_XUL
.
has
(
tagName
)
)
{
selected
=
el
.
selected
;
}
}
else
{
selected
=
this
.
utils
.
isElementSelected
(
el
)
;
}
return
this
.
accessibility
.
getAccessibleObject
(
el
)
.
then
(
acc
=
>
{
this
.
accessibility
.
checkSelected
(
acc
el
selected
)
;
return
selected
;
}
)
;
}
checkVisible
(
container
el
x
y
)
{
if
(
!
this
.
isXULElement
(
el
)
)
{
let
visible
=
this
.
utils
.
isElementDisplayed
(
el
)
;
if
(
!
visible
)
{
return
false
;
}
}
if
(
el
.
tagName
.
toLowerCase
(
)
=
=
=
'
body
'
)
{
return
true
;
}
if
(
!
this
.
elementInViewport
(
container
el
x
y
)
)
{
if
(
el
.
scrollIntoView
)
{
el
.
scrollIntoView
(
false
)
;
if
(
!
this
.
elementInViewport
(
container
el
)
)
{
return
false
;
}
}
else
{
return
false
;
}
}
return
true
;
}
isXULElement
(
el
)
{
return
this
.
utils
.
getElementAttribute
(
el
'
namespaceURI
'
)
.
indexOf
(
'
there
.
is
.
only
.
xul
'
)
>
=
0
;
}
elementInViewport
(
container
el
x
y
)
{
let
c
=
coordinates
(
el
x
y
)
;
let
win
=
container
.
frame
;
let
viewPort
=
{
top
:
win
.
pageYOffset
left
:
win
.
pageXOffset
bottom
:
win
.
pageYOffset
+
win
.
innerHeight
right
:
win
.
pageXOffset
+
win
.
innerWidth
}
;
return
(
viewPort
.
left
<
=
c
.
x
+
win
.
pageXOffset
&
&
c
.
x
+
win
.
pageXOffset
<
=
viewPort
.
right
&
&
viewPort
.
top
<
=
c
.
y
+
win
.
pageYOffset
&
&
c
.
y
+
win
.
pageYOffset
<
=
viewPort
.
bottom
)
;
}
}
;
