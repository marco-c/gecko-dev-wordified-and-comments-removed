"
use
strict
"
;
const
{
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
accessibility
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
atoms
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
elements
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
event
.
js
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
Interactions
"
]
;
const
DISABLED_ATTRIBUTE_SUPPORTED_XUL
=
new
Set
(
[
'
ARROWSCROLLBOX
'
'
BUTTON
'
'
CHECKBOX
'
'
COLORPICKER
'
'
COMMAND
'
'
DATEPICKER
'
'
DESCRIPTION
'
'
KEY
'
'
KEYSET
'
'
LABEL
'
'
LISTBOX
'
'
LISTCELL
'
'
LISTHEAD
'
'
LISTHEADER
'
'
LISTITEM
'
'
MENU
'
'
MENUITEM
'
'
MENULIST
'
'
MENUSEPARATOR
'
'
PREFERENCE
'
'
RADIO
'
'
RADIOGROUP
'
'
RICHLISTBOX
'
'
RICHLISTITEM
'
'
SCALE
'
'
TAB
'
'
TABS
'
'
TEXTBOX
'
'
TIMEPICKER
'
'
TOOLBARBUTTON
'
'
TREE
'
]
)
;
const
CHECKED_PROPERTY_SUPPORTED_XUL
=
new
Set
(
[
'
BUTTON
'
'
CHECKBOX
'
'
LISTITEM
'
'
TOOLBARBUTTON
'
]
)
;
const
SELECTED_PROPERTY_SUPPORTED_XUL
=
new
Set
(
[
'
LISTITEM
'
'
MENU
'
'
MENUITEM
'
'
MENUSEPARATOR
'
'
RADIO
'
'
RICHLISTITEM
'
'
TAB
'
]
)
;
this
.
Interactions
=
function
(
getCapabilies
)
{
this
.
accessibility
=
new
Accessibility
(
getCapabilies
)
;
}
;
Interactions
.
prototype
=
{
clickElement
(
container
elementManager
id
)
{
let
el
=
elementManager
.
getKnownElement
(
id
container
)
;
let
visible
=
elements
.
checkVisible
(
el
container
.
frame
)
;
if
(
!
visible
)
{
throw
new
ElementNotVisibleError
(
'
Element
is
not
visible
'
)
;
}
return
this
.
accessibility
.
getAccessibleObject
(
el
true
)
.
then
(
acc
=
>
{
this
.
accessibility
.
checkVisible
(
acc
el
visible
)
;
if
(
atom
.
isElementEnabled
(
el
)
)
{
this
.
accessibility
.
checkEnabled
(
acc
el
true
container
)
;
this
.
accessibility
.
checkActionable
(
acc
el
)
;
if
(
elements
.
isXULElement
(
el
)
)
{
el
.
click
(
)
;
}
else
{
let
rects
=
el
.
getClientRects
(
)
;
let
win
=
el
.
ownerDocument
.
defaultView
;
event
.
synthesizeMouseAtPoint
(
rects
[
0
]
.
left
+
rects
[
0
]
.
width
/
2
rects
[
0
]
.
top
+
rects
[
0
]
.
height
/
2
{
}
win
)
;
}
}
else
{
throw
new
InvalidElementStateError
(
'
Element
is
not
enabled
'
)
;
}
}
)
;
}
sendKeysToElement
(
container
elementManager
id
value
ignoreVisibility
)
{
let
el
=
elementManager
.
getKnownElement
(
id
container
)
;
return
this
.
accessibility
.
getAccessibleObject
(
el
true
)
.
then
(
acc
=
>
{
this
.
accessibility
.
checkActionable
(
acc
el
)
;
event
.
sendKeysToElement
(
value
el
{
ignoreVisibility
:
false
}
container
.
frame
)
;
}
)
;
}
isElementDisplayed
(
container
elementManager
id
)
{
let
el
=
elementManager
.
getKnownElement
(
id
container
)
;
let
displayed
=
atom
.
isElementDisplayed
(
el
container
.
frame
)
;
return
this
.
accessibility
.
getAccessibleObject
(
el
)
.
then
(
acc
=
>
{
this
.
accessibility
.
checkVisible
(
acc
el
displayed
)
;
return
displayed
;
}
)
;
}
isElementEnabled
(
container
elementManager
id
)
{
let
el
=
elementManager
.
getKnownElement
(
id
container
)
;
let
enabled
=
true
;
if
(
elements
.
isXULElement
(
el
)
)
{
if
(
DISABLED_ATTRIBUTE_SUPPORTED_XUL
.
has
(
el
.
tagName
.
toUpperCase
(
)
)
)
{
let
disabled
=
atom
.
getElementAttribute
(
el
'
disabled
'
container
.
frame
)
;
if
(
disabled
&
&
disabled
=
=
=
'
true
'
)
{
enabled
=
false
;
}
}
}
else
{
enabled
=
atom
.
isElementEnabled
(
el
container
.
frame
)
;
}
return
this
.
accessibility
.
getAccessibleObject
(
el
)
.
then
(
acc
=
>
{
this
.
accessibility
.
checkEnabled
(
acc
el
enabled
container
)
;
return
enabled
;
}
)
;
}
isElementSelected
(
container
elementManager
id
)
{
let
el
=
elementManager
.
getKnownElement
(
id
container
)
;
let
selected
=
true
;
if
(
elements
.
isXULElement
(
el
)
)
{
let
tagName
=
el
.
tagName
.
toUpperCase
(
)
;
if
(
CHECKED_PROPERTY_SUPPORTED_XUL
.
has
(
tagName
)
)
{
selected
=
el
.
checked
;
}
if
(
SELECTED_PROPERTY_SUPPORTED_XUL
.
has
(
tagName
)
)
{
selected
=
el
.
selected
;
}
}
else
{
selected
=
atom
.
isElementSelected
(
el
container
.
frame
)
;
}
return
this
.
accessibility
.
getAccessibleObject
(
el
)
.
then
(
acc
=
>
{
this
.
accessibility
.
checkSelected
(
acc
el
selected
)
;
return
selected
;
}
)
;
}
}
;
