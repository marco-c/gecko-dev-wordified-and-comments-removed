"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
assert
"
]
;
const
isFennec
=
(
)
=
>
AppConstants
.
platform
=
=
"
android
"
;
const
isB2G
=
(
)
=
>
AppConstants
.
MOZ_B2G
;
const
isFirefox
=
(
)
=
>
Services
.
appinfo
.
name
=
=
"
Firefox
"
;
this
.
assert
=
{
}
;
assert
.
session
=
function
(
driver
msg
=
"
"
)
{
assert
.
that
(
sessionID
=
>
sessionID
msg
InvalidSessionIDError
)
(
driver
.
sessionId
)
;
return
driver
.
sessionId
;
}
;
assert
.
firefox
=
function
(
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
Firefox
"
;
assert
.
that
(
isFirefox
msg
UnsupportedOperationError
)
(
)
;
}
;
assert
.
fennec
=
function
(
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
Fennec
"
;
assert
.
that
(
isFennec
msg
UnsupportedOperationError
)
(
)
;
}
;
assert
.
b2g
=
function
(
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
B2G
"
;
assert
.
that
(
isB2G
msg
UnsupportedOperationError
)
(
)
;
}
;
assert
.
content
=
function
(
context
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
content
context
"
;
assert
.
that
(
c
=
>
c
.
toString
(
)
=
=
"
content
"
msg
UnsupportedOperationError
)
(
context
)
;
}
;
assert
.
mobile
=
function
(
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
Fennec
or
B2G
"
;
assert
.
that
(
(
)
=
>
isFennec
(
)
|
|
isB2G
(
)
msg
UnsupportedOperationError
)
(
)
;
}
;
assert
.
window
=
function
(
win
msg
=
"
"
)
{
msg
=
msg
|
|
"
Unable
to
locate
window
"
;
return
assert
.
that
(
w
=
>
{
try
{
return
w
&
&
w
.
document
.
defaultView
;
}
catch
(
e
if
e
.
name
=
=
=
"
TypeError
"
)
{
return
null
;
}
}
msg
NoSuchWindowError
)
(
win
)
;
}
;
assert
.
noUserPrompt
=
function
(
dialog
msg
=
"
"
)
{
assert
.
that
(
d
=
>
d
=
=
=
null
|
|
typeof
d
=
=
"
undefined
"
msg
UnexpectedAlertOpenError
)
(
dialog
)
;
}
;
assert
.
defined
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
error
.
pprint
Expected
{
obj
}
to
be
defined
;
return
assert
.
that
(
o
=
>
typeof
o
!
=
"
undefined
"
msg
)
(
obj
)
;
}
;
assert
.
number
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
error
.
pprint
Expected
{
obj
}
to
be
finite
number
;
return
assert
.
that
(
Number
.
isFinite
msg
)
(
obj
)
;
}
;
assert
.
callable
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
error
.
pprint
{
obj
}
is
not
callable
;
return
assert
.
that
(
o
=
>
typeof
o
=
=
"
function
"
msg
)
(
obj
)
;
}
;
assert
.
integer
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
error
.
pprint
Expected
{
obj
}
to
be
an
integer
;
return
assert
.
that
(
Number
.
isInteger
msg
)
(
obj
)
;
}
;
assert
.
positiveInteger
=
function
(
obj
msg
=
"
"
)
{
assert
.
integer
(
obj
msg
)
;
msg
=
msg
|
|
error
.
pprint
Expected
{
obj
}
to
be
>
=
0
;
return
assert
.
that
(
n
=
>
n
>
=
0
msg
)
(
obj
)
;
}
;
assert
.
boolean
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
error
.
pprint
Expected
{
obj
}
to
be
boolean
;
return
assert
.
that
(
b
=
>
typeof
b
=
=
"
boolean
"
msg
)
(
obj
)
;
}
;
assert
.
string
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
error
.
pprint
Expected
{
obj
}
to
be
a
string
;
return
assert
.
that
(
s
=
>
typeof
s
=
=
"
string
"
msg
)
(
obj
)
;
}
;
assert
.
object
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
error
.
pprint
Expected
{
obj
}
to
be
an
object
;
return
assert
.
that
(
o
=
>
{
let
s
=
Object
.
prototype
.
toString
.
call
(
o
)
;
return
s
=
=
"
[
object
Object
]
"
|
|
s
=
=
"
[
object
nsJSIID
]
"
;
}
)
(
obj
)
;
}
;
assert
.
in
=
function
(
prop
obj
msg
=
"
"
)
{
assert
.
object
(
obj
msg
)
;
msg
=
msg
|
|
error
.
pprint
Expected
{
prop
}
in
{
obj
}
;
assert
.
that
(
p
=
>
obj
.
hasOwnProperty
(
p
)
msg
)
(
prop
)
;
return
obj
[
prop
]
;
}
;
assert
.
array
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
error
.
pprint
Expected
{
obj
}
to
be
an
Array
;
return
assert
.
that
(
Array
.
isArray
msg
)
(
obj
)
;
}
;
assert
.
that
=
function
(
predicate
message
=
"
"
error
=
InvalidArgumentError
)
{
return
obj
=
>
{
if
(
!
predicate
(
obj
)
)
{
throw
new
error
(
message
)
;
}
return
obj
;
}
;
}
;
