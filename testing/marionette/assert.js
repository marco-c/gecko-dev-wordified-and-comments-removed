"
use
strict
"
;
const
{
utils
:
Cu
}
=
Components
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
InvalidArgumentError
InvalidSessionIDError
JavaScriptError
NoSuchWindowError
UnexpectedAlertOpenError
UnsupportedOperationError
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
{
}
)
;
const
{
pprint
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
format
.
js
"
{
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
browser
"
(
)
=
>
{
const
{
browser
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
browser
.
js
"
{
}
)
;
return
browser
;
}
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
assert
"
]
;
const
isFennec
=
(
)
=
>
AppConstants
.
platform
=
=
"
android
"
;
const
isFirefox
=
(
)
=
>
Services
.
appinfo
.
ID
=
=
"
{
ec8030f7
-
c20a
-
464f
-
9b0e
-
13a3a9e97384
}
"
;
this
.
assert
=
{
}
;
assert
.
acyclic
=
function
(
obj
msg
=
"
"
error
=
JavaScriptError
)
{
try
{
JSON
.
stringify
(
obj
)
;
}
catch
(
e
)
{
throw
new
error
(
msg
|
|
e
)
;
}
}
;
assert
.
session
=
function
(
driver
msg
=
"
"
)
{
assert
.
that
(
sessionID
=
>
sessionID
msg
InvalidSessionIDError
)
(
driver
.
sessionID
)
;
return
driver
.
sessionID
;
}
;
assert
.
firefox
=
function
(
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
Firefox
"
;
assert
.
that
(
isFirefox
msg
UnsupportedOperationError
)
(
)
;
}
;
assert
.
fennec
=
function
(
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
Fennec
"
;
assert
.
that
(
isFennec
msg
UnsupportedOperationError
)
(
)
;
}
;
assert
.
content
=
function
(
context
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
content
context
"
;
assert
.
that
(
c
=
>
c
.
toString
(
)
=
=
"
content
"
msg
UnsupportedOperationError
)
(
context
)
;
}
;
assert
.
open
=
function
(
context
msg
=
"
"
)
{
if
(
context
instanceof
browser
.
Context
)
{
assert
.
open
(
context
.
window
)
;
}
msg
=
msg
|
|
"
Browsing
context
has
been
discarded
"
;
return
assert
.
that
(
ctx
=
>
ctx
&
&
!
ctx
.
closed
msg
NoSuchWindowError
)
(
context
)
;
}
;
assert
.
noUserPrompt
=
function
(
dialog
msg
=
"
"
)
{
assert
.
that
(
d
=
>
d
=
=
=
null
|
|
typeof
d
=
=
"
undefined
"
msg
UnexpectedAlertOpenError
)
(
dialog
)
;
}
;
assert
.
defined
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
defined
;
return
assert
.
that
(
o
=
>
typeof
o
!
=
"
undefined
"
msg
)
(
obj
)
;
}
;
assert
.
number
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
finite
number
;
return
assert
.
that
(
Number
.
isFinite
msg
)
(
obj
)
;
}
;
assert
.
callable
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
{
obj
}
is
not
callable
;
return
assert
.
that
(
o
=
>
typeof
o
=
=
"
function
"
msg
)
(
obj
)
;
}
;
assert
.
integer
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
an
integer
;
return
assert
.
that
(
Number
.
isSafeInteger
msg
)
(
obj
)
;
}
;
assert
.
positiveInteger
=
function
(
obj
msg
=
"
"
)
{
assert
.
integer
(
obj
msg
)
;
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
>
=
0
;
return
assert
.
that
(
n
=
>
n
>
=
0
msg
)
(
obj
)
;
}
;
assert
.
boolean
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
boolean
;
return
assert
.
that
(
b
=
>
typeof
b
=
=
"
boolean
"
msg
)
(
obj
)
;
}
;
assert
.
string
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
a
string
;
return
assert
.
that
(
s
=
>
typeof
s
=
=
"
string
"
msg
)
(
obj
)
;
}
;
assert
.
object
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
an
object
;
return
assert
.
that
(
o
=
>
{
let
s
=
Object
.
prototype
.
toString
.
call
(
o
)
;
return
s
=
=
"
[
object
Object
]
"
|
|
s
=
=
"
[
object
nsJSIID
]
"
;
}
msg
)
(
obj
)
;
}
;
assert
.
in
=
function
(
prop
obj
msg
=
"
"
)
{
assert
.
object
(
obj
msg
)
;
msg
=
msg
|
|
pprint
Expected
{
prop
}
in
{
obj
}
;
assert
.
that
(
p
=
>
obj
.
hasOwnProperty
(
p
)
msg
)
(
prop
)
;
return
obj
[
prop
]
;
}
;
assert
.
array
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
an
Array
;
return
assert
.
that
(
Array
.
isArray
msg
)
(
obj
)
;
}
;
assert
.
that
=
function
(
predicate
message
=
"
"
error
=
InvalidArgumentError
)
{
return
obj
=
>
{
if
(
!
predicate
(
obj
)
)
{
throw
new
error
(
message
)
;
}
return
obj
;
}
;
}
;
