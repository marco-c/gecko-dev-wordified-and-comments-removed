"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
assert
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
browser
:
"
chrome
:
/
/
marionette
/
content
/
browser
.
js
"
error
:
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
evaluate
:
"
chrome
:
/
/
marionette
/
content
/
evaluate
.
js
"
pprint
:
"
chrome
:
/
/
marionette
/
content
/
format
.
js
"
}
)
;
const
isFennec
=
(
)
=
>
AppConstants
.
platform
=
=
"
android
"
;
const
isFirefox
=
(
)
=
>
Services
.
appinfo
.
ID
=
=
"
{
ec8030f7
-
c20a
-
464f
-
9b0e
-
13a3a9e97384
}
"
;
const
isThunderbird
=
(
)
=
>
Services
.
appinfo
.
ID
=
=
"
{
3550f703
-
e582
-
4d05
-
9a08
-
453d09bdfdc6
}
"
;
this
.
assert
=
{
}
;
assert
.
acyclic
=
function
(
obj
msg
=
"
"
err
=
error
.
JavaScriptError
)
{
if
(
evaluate
.
isCyclic
(
obj
)
)
{
throw
new
err
(
msg
|
|
"
Cyclic
object
value
"
)
;
}
}
;
assert
.
session
=
function
(
driver
msg
=
"
"
)
{
assert
.
that
(
sessionID
=
>
sessionID
msg
error
.
InvalidSessionIDError
)
(
driver
.
sessionID
)
;
return
driver
.
sessionID
;
}
;
assert
.
firefox
=
function
(
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
Firefox
"
;
assert
.
that
(
isFirefox
msg
error
.
UnsupportedOperationError
)
(
)
;
}
;
assert
.
desktop
=
function
(
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
desktop
applications
"
;
assert
.
that
(
obj
=
>
isFirefox
(
obj
)
|
|
isThunderbird
(
obj
)
msg
error
.
UnsupportedOperationError
)
(
)
;
}
;
assert
.
fennec
=
function
(
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
Fennec
"
;
assert
.
that
(
isFennec
msg
error
.
UnsupportedOperationError
)
(
)
;
}
;
assert
.
content
=
function
(
context
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
content
context
"
;
assert
.
that
(
c
=
>
c
.
toString
(
)
=
=
"
content
"
msg
error
.
UnsupportedOperationError
)
(
context
)
;
}
;
assert
.
open
=
function
(
context
msg
=
"
"
)
{
if
(
context
instanceof
browser
.
Context
)
{
assert
.
open
(
context
.
window
)
;
}
msg
=
msg
|
|
"
Browsing
context
has
been
discarded
"
;
return
assert
.
that
(
ctx
=
>
ctx
&
&
!
ctx
.
closed
msg
error
.
NoSuchWindowError
)
(
context
)
;
}
;
assert
.
noUserPrompt
=
function
(
dialog
msg
=
"
"
)
{
assert
.
that
(
d
=
>
d
=
=
=
null
|
|
typeof
d
=
=
"
undefined
"
msg
error
.
UnexpectedAlertOpenError
)
(
dialog
)
;
}
;
assert
.
defined
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
defined
;
return
assert
.
that
(
o
=
>
typeof
o
!
=
"
undefined
"
msg
)
(
obj
)
;
}
;
assert
.
number
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
finite
number
;
return
assert
.
that
(
Number
.
isFinite
msg
)
(
obj
)
;
}
;
assert
.
positiveNumber
=
function
(
obj
msg
=
"
"
)
{
assert
.
number
(
obj
msg
)
;
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
>
=
0
;
return
assert
.
that
(
n
=
>
n
>
=
0
msg
)
(
obj
)
;
}
;
assert
.
callable
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
{
obj
}
is
not
callable
;
return
assert
.
that
(
o
=
>
typeof
o
=
=
"
function
"
msg
)
(
obj
)
;
}
;
assert
.
unsignedShort
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
>
=
0
and
<
65536
;
return
assert
.
that
(
n
=
>
n
>
=
0
&
&
n
<
65536
msg
)
(
obj
)
;
}
;
assert
.
integer
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
an
integer
;
return
assert
.
that
(
Number
.
isSafeInteger
msg
)
(
obj
)
;
}
;
assert
.
positiveInteger
=
function
(
obj
msg
=
"
"
)
{
assert
.
integer
(
obj
msg
)
;
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
>
=
0
;
return
assert
.
that
(
n
=
>
n
>
=
0
msg
)
(
obj
)
;
}
;
assert
.
boolean
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
boolean
;
return
assert
.
that
(
b
=
>
typeof
b
=
=
"
boolean
"
msg
)
(
obj
)
;
}
;
assert
.
string
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
a
string
;
return
assert
.
that
(
s
=
>
typeof
s
=
=
"
string
"
msg
)
(
obj
)
;
}
;
assert
.
object
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
an
object
;
return
assert
.
that
(
o
=
>
{
let
s
=
Object
.
prototype
.
toString
.
call
(
o
)
;
return
s
=
=
"
[
object
Object
]
"
|
|
s
=
=
"
[
object
nsJSIID
]
"
;
}
msg
)
(
obj
)
;
}
;
assert
.
in
=
function
(
prop
obj
msg
=
"
"
)
{
if
(
Array
.
isArray
(
obj
)
)
{
assert
.
that
(
p
=
>
obj
.
includes
(
p
)
msg
)
(
prop
)
;
return
prop
;
}
assert
.
object
(
obj
msg
)
;
msg
=
msg
|
|
pprint
Expected
{
prop
}
in
{
obj
}
;
assert
.
that
(
p
=
>
obj
.
hasOwnProperty
(
p
)
msg
)
(
prop
)
;
return
obj
[
prop
]
;
}
;
assert
.
array
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
pprint
Expected
{
obj
}
to
be
an
Array
;
return
assert
.
that
(
Array
.
isArray
msg
)
(
obj
)
;
}
;
assert
.
that
=
function
(
predicate
message
=
"
"
err
=
error
.
InvalidArgumentError
)
{
return
obj
=
>
{
if
(
!
predicate
(
obj
)
)
{
throw
new
err
(
message
)
;
}
return
obj
;
}
;
}
;
