"
use
strict
"
;
const
{
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
const
ERRORS
=
new
Set
(
[
"
ElementNotAccessibleError
"
"
ElementNotVisibleError
"
"
InsecureCertificateError
"
"
InvalidArgumentError
"
"
InvalidElementStateError
"
"
InvalidSelectorError
"
"
InvalidSessionIDError
"
"
JavaScriptError
"
"
NoAlertOpenError
"
"
NoSuchElementError
"
"
NoSuchFrameError
"
"
NoSuchWindowError
"
"
ScriptTimeoutError
"
"
SessionNotCreatedError
"
"
StaleElementReferenceError
"
"
TimeoutError
"
"
UnableToSetCookieError
"
"
UnknownCommandError
"
"
UnknownError
"
"
UnsupportedOperationError
"
"
WebDriverError
"
]
)
;
const
BUILTIN_ERRORS
=
new
Set
(
[
"
Error
"
"
EvalError
"
"
InternalError
"
"
RangeError
"
"
ReferenceError
"
"
SyntaxError
"
"
TypeError
"
"
URIError
"
]
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
error
"
]
.
concat
(
Array
.
from
(
ERRORS
)
)
;
this
.
error
=
{
}
;
error
.
isError
=
function
(
val
)
{
if
(
val
=
=
=
null
|
|
typeof
val
!
=
"
object
"
)
{
return
false
;
}
else
if
(
val
instanceof
Ci
.
nsIException
)
{
return
true
;
}
else
{
try
{
let
proto
=
Object
.
getPrototypeOf
(
val
)
;
return
BUILTIN_ERRORS
.
has
(
proto
.
toString
(
)
)
;
}
catch
(
e
)
{
return
false
;
}
}
}
;
error
.
isWebDriverError
=
function
(
obj
)
{
return
error
.
isError
(
obj
)
&
&
(
"
name
"
in
obj
&
&
ERRORS
.
has
(
obj
.
name
)
)
;
}
;
error
.
wrap
=
function
(
err
)
{
if
(
error
.
isWebDriverError
(
err
)
)
{
return
err
;
}
return
new
WebDriverError
(
err
)
;
}
;
error
.
report
=
function
(
err
)
{
let
msg
=
"
Marionette
threw
an
error
:
"
+
error
.
stringify
(
err
)
;
dump
(
msg
+
"
\
n
"
)
;
if
(
Cu
.
reportError
)
{
Cu
.
reportError
(
msg
)
;
}
}
;
error
.
stringify
=
function
(
err
)
{
try
{
let
s
=
err
.
toString
(
)
;
if
(
"
stack
"
in
err
)
{
s
+
=
"
\
n
"
+
err
.
stack
;
}
return
s
;
}
catch
(
e
)
{
return
"
<
unprintable
error
>
"
;
}
}
;
error
.
pprint
=
function
(
strings
.
.
.
values
)
{
let
res
=
[
]
;
for
(
let
i
=
0
;
i
<
strings
.
length
;
i
+
+
)
{
res
.
push
(
strings
[
i
]
)
;
if
(
i
<
values
.
length
)
{
let
val
=
values
[
i
]
;
res
.
push
(
Object
.
prototype
.
toString
.
call
(
val
)
)
;
let
s
=
JSON
.
stringify
(
val
)
;
if
(
s
&
&
s
.
length
>
0
)
{
res
.
push
(
"
"
)
;
res
.
push
(
s
)
;
}
}
}
return
res
.
join
(
"
"
)
;
}
;
class
WebDriverError
extends
Error
{
constructor
(
x
)
{
super
(
x
)
;
this
.
name
=
this
.
constructor
.
name
;
this
.
status
=
"
webdriver
error
"
;
if
(
error
.
isError
(
x
)
)
{
this
.
stack
=
x
.
stack
;
}
}
toJSON
(
)
{
return
{
error
:
this
.
status
message
:
this
.
message
|
|
"
"
stacktrace
:
this
.
stack
|
|
"
"
}
}
static
fromJSON
(
json
)
{
if
(
typeof
json
.
error
=
=
"
undefined
"
)
{
let
s
=
JSON
.
stringify
(
json
)
;
throw
new
TypeError
(
"
Undeserialisable
error
type
:
"
+
s
)
;
}
if
(
!
STATUSES
.
has
(
json
.
error
)
)
{
throw
new
TypeError
(
"
Not
of
WebDriverError
descent
:
"
+
json
.
error
)
;
}
let
cls
=
STATUSES
.
get
(
json
.
error
)
;
let
err
=
new
cls
(
)
;
if
(
"
message
"
in
json
)
{
err
.
message
=
json
.
message
;
}
if
(
"
stacktrace
"
in
json
)
{
err
.
stack
=
json
.
stacktrace
;
}
return
err
;
}
}
class
ElementNotAccessibleError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
element
not
accessible
"
;
}
}
class
ElementNotVisibleError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
element
not
visible
"
;
}
}
class
InsecureCertificateError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
insecure
certificate
"
;
}
}
class
InvalidArgumentError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
invalid
argument
"
;
}
}
class
InvalidElementStateError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
invalid
element
state
"
;
}
}
class
InvalidSelectorError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
invalid
selector
"
;
}
}
class
InvalidSessionIDError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
invalid
session
id
"
;
}
}
class
JavaScriptError
extends
WebDriverError
{
constructor
(
x
fnName
=
undefined
file
=
undefined
line
=
undefined
script
=
undefined
)
{
let
msg
=
String
(
x
)
;
let
trace
=
"
"
;
if
(
fnName
)
{
trace
+
=
fnName
;
if
(
file
)
{
trace
+
=
{
file
}
;
if
(
line
)
{
trace
+
=
line
{
line
}
;
}
}
}
if
(
error
.
isError
(
x
)
)
{
let
jsStack
=
x
.
stack
.
split
(
"
\
n
"
)
;
let
match
=
jsStack
[
0
]
.
match
(
/
:
(
\
d
+
)
:
\
d
+
/
)
;
let
jsLine
=
match
?
parseInt
(
match
[
1
]
)
:
0
;
if
(
script
)
{
let
src
=
script
.
split
(
"
\
n
"
)
[
jsLine
]
;
trace
+
=
"
\
n
"
+
inline
javascript
line
{
jsLine
}
\
n
+
src
:
"
{
src
}
"
;
}
trace
+
=
"
\
nStack
:
\
n
"
+
x
.
stack
;
}
super
(
msg
)
;
this
.
status
=
"
javascript
error
"
;
this
.
stack
=
trace
;
}
}
class
NoAlertOpenError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
no
such
alert
"
;
}
}
class
NoSuchElementError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
no
such
element
"
;
}
}
class
NoSuchFrameError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
no
such
frame
"
;
}
}
class
NoSuchWindowError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
no
such
window
"
;
}
}
class
ScriptTimeoutError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
script
timeout
"
;
}
}
class
SessionNotCreatedError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
session
not
created
"
;
}
}
class
StaleElementReferenceError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
stale
element
reference
"
;
}
}
class
TimeoutError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
timeout
"
;
}
}
class
UnableToSetCookieError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
unable
to
set
cookie
"
;
}
}
class
UnknownCommandError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
unknown
command
"
;
}
}
class
UnknownError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
unknown
error
"
;
}
}
class
UnsupportedOperationError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
unsupported
operation
"
;
}
}
const
STATUSES
=
new
Map
(
[
[
"
element
not
accessible
"
ElementNotAccessibleError
]
[
"
element
not
visible
"
ElementNotVisibleError
]
[
"
insecure
certificate
"
InsecureCertificateError
]
[
"
invalid
argument
"
InvalidArgumentError
]
[
"
invalid
element
state
"
InvalidElementStateError
]
[
"
invalid
selector
"
InvalidSelectorError
]
[
"
invalid
session
id
"
InvalidSessionIDError
]
[
"
javascript
error
"
JavaScriptError
]
[
"
no
alert
open
"
NoAlertOpenError
]
[
"
no
such
element
"
NoSuchElementError
]
[
"
no
such
frame
"
NoSuchFrameError
]
[
"
no
such
window
"
NoSuchWindowError
]
[
"
script
timeout
"
ScriptTimeoutError
]
[
"
session
not
created
"
SessionNotCreatedError
]
[
"
stale
element
reference
"
StaleElementReferenceError
]
[
"
timeout
"
TimeoutError
]
[
"
unable
to
set
cookie
"
UnableToSetCookieError
]
[
"
unknown
command
"
UnknownCommandError
]
[
"
unknown
error
"
UnknownError
]
[
"
unsupported
operation
"
UnsupportedOperationError
]
[
"
webdriver
error
"
WebDriverError
]
]
)
;
