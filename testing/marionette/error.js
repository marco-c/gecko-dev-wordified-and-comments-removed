"
use
strict
"
;
const
{
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
const
ERRORS
=
new
Set
(
[
"
ElementClickInterceptedError
"
"
ElementNotAccessibleError
"
"
ElementNotInteractableError
"
"
InsecureCertificateError
"
"
InvalidArgumentError
"
"
InvalidCookieDomainError
"
"
InvalidElementStateError
"
"
InvalidSelectorError
"
"
InvalidSessionIDError
"
"
JavaScriptError
"
"
MoveTargetOutOfBoundsError
"
"
NoAlertOpenError
"
"
NoSuchElementError
"
"
NoSuchFrameError
"
"
NoSuchWindowError
"
"
ScriptTimeoutError
"
"
SessionNotCreatedError
"
"
StaleElementReferenceError
"
"
TimeoutError
"
"
UnableToSetCookieError
"
"
UnexpectedAlertOpenError
"
"
UnknownCommandError
"
"
UnknownError
"
"
UnsupportedOperationError
"
"
WebDriverError
"
]
)
;
const
BUILTIN_ERRORS
=
new
Set
(
[
"
Error
"
"
EvalError
"
"
InternalError
"
"
RangeError
"
"
ReferenceError
"
"
SyntaxError
"
"
TypeError
"
"
URIError
"
]
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
error
"
"
error
.
pprint
"
]
.
concat
(
Array
.
from
(
ERRORS
)
)
;
this
.
error
=
{
}
;
error
.
isError
=
function
(
val
)
{
if
(
val
=
=
=
null
|
|
typeof
val
!
=
"
object
"
)
{
return
false
;
}
else
if
(
val
instanceof
Ci
.
nsIException
)
{
return
true
;
}
try
{
let
proto
=
Object
.
getPrototypeOf
(
val
)
;
return
BUILTIN_ERRORS
.
has
(
proto
.
toString
(
)
)
;
}
catch
(
e
)
{
return
false
;
}
}
;
error
.
isWebDriverError
=
function
(
obj
)
{
return
error
.
isError
(
obj
)
&
&
(
"
name
"
in
obj
&
&
ERRORS
.
has
(
obj
.
name
)
)
;
}
;
error
.
wrap
=
function
(
err
)
{
if
(
error
.
isWebDriverError
(
err
)
)
{
return
err
;
}
return
new
UnknownError
(
err
)
;
}
;
error
.
report
=
function
(
err
)
{
let
msg
=
"
Marionette
threw
an
error
:
"
+
error
.
stringify
(
err
)
;
dump
(
msg
+
"
\
n
"
)
;
if
(
Cu
.
reportError
)
{
Cu
.
reportError
(
msg
)
;
}
}
;
error
.
stringify
=
function
(
err
)
{
try
{
let
s
=
err
.
toString
(
)
;
if
(
"
stack
"
in
err
)
{
s
+
=
"
\
n
"
+
err
.
stack
;
}
return
s
;
}
catch
(
e
)
{
return
"
<
unprintable
error
>
"
;
}
}
;
error
.
pprint
=
function
(
ss
.
.
.
values
)
{
function
prettyObject
(
obj
)
{
let
proto
=
Object
.
prototype
.
toString
.
call
(
obj
)
;
let
s
=
"
"
;
try
{
s
=
JSON
.
stringify
(
obj
)
;
}
catch
(
e
)
{
if
(
e
instanceof
TypeError
)
{
s
=
<
{
e
.
message
}
>
;
}
else
{
throw
e
;
}
}
return
proto
+
"
"
+
s
;
}
function
prettyElement
(
el
)
{
let
ident
=
[
]
;
if
(
el
.
id
)
{
ident
.
push
(
id
=
"
{
el
.
id
}
"
)
;
}
if
(
el
.
classList
.
length
>
0
)
{
ident
.
push
(
class
=
"
{
el
.
className
}
"
)
;
}
let
idents
=
"
"
;
if
(
ident
.
length
>
0
)
{
idents
=
"
"
+
ident
.
join
(
"
"
)
;
}
return
<
{
el
.
localName
}
{
idents
}
>
;
}
let
res
=
[
]
;
for
(
let
i
=
0
;
i
<
ss
.
length
;
i
+
+
)
{
res
.
push
(
ss
[
i
]
)
;
if
(
i
<
values
.
length
)
{
let
val
=
values
[
i
]
;
let
s
;
try
{
if
(
val
&
&
val
.
nodeType
=
=
=
1
)
{
s
=
prettyElement
(
val
)
;
}
else
{
s
=
prettyObject
(
val
)
;
}
}
catch
(
e
)
{
s
=
typeof
val
;
}
res
.
push
(
s
)
;
}
}
return
res
.
join
(
"
"
)
;
}
;
class
WebDriverError
extends
Error
{
constructor
(
x
)
{
super
(
x
)
;
this
.
name
=
this
.
constructor
.
name
;
this
.
status
=
"
webdriver
error
"
;
if
(
error
.
isError
(
x
)
)
{
this
.
stack
=
x
.
stack
;
}
}
toJSON
(
)
{
return
{
error
:
this
.
status
message
:
this
.
message
|
|
"
"
stacktrace
:
this
.
stack
|
|
"
"
}
}
static
fromJSON
(
json
)
{
if
(
typeof
json
.
error
=
=
"
undefined
"
)
{
let
s
=
JSON
.
stringify
(
json
)
;
throw
new
TypeError
(
"
Undeserialisable
error
type
:
"
+
s
)
;
}
if
(
!
STATUSES
.
has
(
json
.
error
)
)
{
throw
new
TypeError
(
"
Not
of
WebDriverError
descent
:
"
+
json
.
error
)
;
}
let
cls
=
STATUSES
.
get
(
json
.
error
)
;
let
err
=
new
cls
(
)
;
if
(
"
message
"
in
json
)
{
err
.
message
=
json
.
message
;
}
if
(
"
stacktrace
"
in
json
)
{
err
.
stack
=
json
.
stacktrace
;
}
return
err
;
}
}
class
ElementNotAccessibleError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
element
not
accessible
"
;
}
}
class
ElementClickInterceptedError
extends
WebDriverError
{
constructor
(
obscuredEl
=
undefined
coords
=
undefined
)
{
let
msg
=
"
"
;
if
(
obscuredEl
&
&
coords
)
{
const
doc
=
obscuredEl
.
ownerDocument
;
const
overlayingEl
=
doc
.
elementFromPoint
(
coords
.
x
coords
.
y
)
;
switch
(
obscuredEl
.
style
.
pointerEvents
)
{
case
"
none
"
:
msg
=
error
.
pprint
Element
{
obscuredEl
}
is
not
clickable
+
at
point
(
{
coords
.
x
}
{
coords
.
y
}
)
+
because
it
does
not
have
pointer
events
enabled
+
error
.
pprint
and
element
{
overlayingEl
}
+
would
receive
the
click
instead
;
break
;
default
:
msg
=
error
.
pprint
Element
{
obscuredEl
}
is
not
clickable
+
at
point
(
{
coords
.
x
}
{
coords
.
y
}
)
+
error
.
pprint
because
another
element
{
overlayingEl
}
+
obscures
it
;
break
;
}
}
super
(
msg
)
;
this
.
status
=
"
element
click
intercepted
"
;
}
}
class
ElementNotInteractableError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
element
not
interactable
"
;
}
}
class
InsecureCertificateError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
insecure
certificate
"
;
}
}
class
InvalidArgumentError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
invalid
argument
"
;
}
}
class
InvalidCookieDomainError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
invalid
cookie
domain
"
;
}
}
class
InvalidElementStateError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
invalid
element
state
"
;
}
}
class
InvalidSelectorError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
invalid
selector
"
;
}
}
class
InvalidSessionIDError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
invalid
session
id
"
;
}
}
class
JavaScriptError
extends
WebDriverError
{
constructor
(
x
{
fnName
=
null
file
=
null
line
=
null
script
=
null
}
=
{
}
)
{
let
msg
=
String
(
x
)
;
let
trace
=
"
"
;
if
(
fnName
!
=
=
null
)
{
trace
+
=
fnName
;
if
(
file
!
=
=
null
)
{
trace
+
=
{
file
}
;
if
(
line
!
=
=
null
)
{
trace
+
=
line
{
line
}
;
}
}
}
if
(
error
.
isError
(
x
)
)
{
let
jsStack
=
x
.
stack
.
split
(
"
\
n
"
)
;
let
match
=
jsStack
[
0
]
.
match
(
/
:
(
\
d
+
)
:
\
d
+
/
)
;
let
jsLine
=
match
?
parseInt
(
match
[
1
]
)
:
0
;
if
(
script
!
=
=
null
)
{
let
src
=
script
.
split
(
"
\
n
"
)
[
jsLine
]
;
trace
+
=
"
\
n
"
+
inline
javascript
line
{
jsLine
}
\
n
+
src
:
"
{
src
}
"
;
}
trace
+
=
"
\
nStack
:
\
n
"
+
x
.
stack
;
}
super
(
msg
)
;
this
.
status
=
"
javascript
error
"
;
this
.
stack
=
trace
;
}
}
class
MoveTargetOutOfBoundsError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
move
target
out
of
bounds
"
;
}
}
class
NoAlertOpenError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
no
such
alert
"
;
}
}
class
NoSuchElementError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
no
such
element
"
;
}
}
class
NoSuchFrameError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
no
such
frame
"
;
}
}
class
NoSuchWindowError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
no
such
window
"
;
}
}
class
ScriptTimeoutError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
script
timeout
"
;
}
}
class
SessionNotCreatedError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
session
not
created
"
;
}
}
class
StaleElementReferenceError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
stale
element
reference
"
;
}
}
class
TimeoutError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
timeout
"
;
}
}
class
UnableToSetCookieError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
unable
to
set
cookie
"
;
}
}
class
UnexpectedAlertOpenError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
unexpected
alert
open
"
;
}
}
class
UnknownCommandError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
unknown
command
"
;
}
}
class
UnknownError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
unknown
error
"
;
}
}
class
UnsupportedOperationError
extends
WebDriverError
{
constructor
(
message
)
{
super
(
message
)
;
this
.
status
=
"
unsupported
operation
"
;
}
}
const
STATUSES
=
new
Map
(
[
[
"
element
click
intercepted
"
ElementClickInterceptedError
]
[
"
element
not
accessible
"
ElementNotAccessibleError
]
[
"
element
not
interactable
"
ElementNotInteractableError
]
[
"
insecure
certificate
"
InsecureCertificateError
]
[
"
invalid
argument
"
InvalidArgumentError
]
[
"
invalid
cookie
domain
"
InvalidCookieDomainError
]
[
"
invalid
element
state
"
InvalidElementStateError
]
[
"
invalid
selector
"
InvalidSelectorError
]
[
"
invalid
session
id
"
InvalidSessionIDError
]
[
"
javascript
error
"
JavaScriptError
]
[
"
move
target
out
of
bounds
"
MoveTargetOutOfBoundsError
]
[
"
no
alert
open
"
NoAlertOpenError
]
[
"
no
such
element
"
NoSuchElementError
]
[
"
no
such
frame
"
NoSuchFrameError
]
[
"
no
such
window
"
NoSuchWindowError
]
[
"
script
timeout
"
ScriptTimeoutError
]
[
"
session
not
created
"
SessionNotCreatedError
]
[
"
stale
element
reference
"
StaleElementReferenceError
]
[
"
timeout
"
TimeoutError
]
[
"
unable
to
set
cookie
"
UnableToSetCookieError
]
[
"
unexpected
alert
open
"
UnexpectedAlertOpenError
]
[
"
unknown
command
"
UnknownCommandError
]
[
"
unknown
error
"
UnknownError
]
[
"
unsupported
operation
"
UnsupportedOperationError
]
[
"
webdriver
error
"
WebDriverError
]
]
)
;
for
(
let
cls
of
STATUSES
.
values
(
)
)
{
this
[
cls
.
name
]
=
cls
;
}
