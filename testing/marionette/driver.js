"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
GeckoDriver
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
accessibility
:
"
chrome
:
/
/
marionette
/
content
/
accessibility
.
js
"
Addon
:
"
chrome
:
/
/
marionette
/
content
/
addon
.
js
"
allowAllCerts
:
"
chrome
:
/
/
marionette
/
content
/
cert
.
js
"
assert
:
"
chrome
:
/
/
marionette
/
content
/
assert
.
js
"
atom
:
"
chrome
:
/
/
marionette
/
content
/
atom
.
js
"
browser
:
"
chrome
:
/
/
marionette
/
content
/
browser
.
js
"
Capabilities
:
"
chrome
:
/
/
marionette
/
content
/
capabilities
.
js
"
capture
:
"
chrome
:
/
/
marionette
/
content
/
capture
.
js
"
ChromeWebElement
:
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
Context
:
"
chrome
:
/
/
marionette
/
content
/
browser
.
js
"
cookie
:
"
chrome
:
/
/
marionette
/
content
/
cookie
.
js
"
DebounceCallback
:
"
chrome
:
/
/
marionette
/
content
/
sync
.
js
"
element
:
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
error
:
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
evaluate
:
"
chrome
:
/
/
marionette
/
content
/
evaluate
.
js
"
IdlePromise
:
"
chrome
:
/
/
marionette
/
content
/
sync
.
js
"
interaction
:
"
chrome
:
/
/
marionette
/
content
/
interaction
.
js
"
l10n
:
"
chrome
:
/
/
marionette
/
content
/
l10n
.
js
"
legacyaction
:
"
chrome
:
/
/
marionette
/
content
/
legacyaction
.
js
"
Log
:
"
chrome
:
/
/
marionette
/
content
/
log
.
js
"
MarionettePrefs
:
"
chrome
:
/
/
marionette
/
content
/
prefs
.
js
"
modal
:
"
chrome
:
/
/
marionette
/
content
/
modal
.
js
"
navigate
:
"
chrome
:
/
/
marionette
/
content
/
navigate
.
js
"
PollPromise
:
"
chrome
:
/
/
marionette
/
content
/
sync
.
js
"
pprint
:
"
chrome
:
/
/
marionette
/
content
/
format
.
js
"
print
:
"
chrome
:
/
/
marionette
/
content
/
print
.
js
"
proxy
:
"
chrome
:
/
/
marionette
/
content
/
proxy
.
js
"
reftest
:
"
chrome
:
/
/
marionette
/
content
/
reftest
.
js
"
Sandboxes
:
"
chrome
:
/
/
marionette
/
content
/
evaluate
.
js
"
TimedPromise
:
"
chrome
:
/
/
marionette
/
content
/
sync
.
js
"
Timeouts
:
"
chrome
:
/
/
marionette
/
content
/
capabilities
.
js
"
UnhandledPromptBehavior
:
"
chrome
:
/
/
marionette
/
content
/
capabilities
.
js
"
waitForEvent
:
"
chrome
:
/
/
marionette
/
content
/
sync
.
js
"
waitForObserverTopic
:
"
chrome
:
/
/
marionette
/
content
/
sync
.
js
"
WebElement
:
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
WebElementEventTarget
:
"
chrome
:
/
/
marionette
/
content
/
dom
.
js
"
WindowState
:
"
chrome
:
/
/
marionette
/
content
/
browser
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
)
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
const
APP_ID_FIREFOX
=
"
{
ec8030f7
-
c20a
-
464f
-
9b0e
-
13a3a9e97384
}
"
;
const
APP_ID_THUNDERBIRD
=
"
{
3550f703
-
e582
-
4d05
-
9a08
-
453d09bdfdc6
}
"
;
const
FRAME_SCRIPT
=
"
chrome
:
/
/
marionette
/
content
/
listener
.
js
"
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
SUPPORTED_STRATEGIES
=
new
Set
(
[
element
.
Strategy
.
ClassName
element
.
Strategy
.
Selector
element
.
Strategy
.
ID
element
.
Strategy
.
Name
element
.
Strategy
.
LinkText
element
.
Strategy
.
PartialLinkText
element
.
Strategy
.
TagName
element
.
Strategy
.
XPath
]
)
;
const
TIMEOUT_NO_WINDOW_MANAGER
=
5000
;
const
globalMessageManager
=
Services
.
mm
;
this
.
GeckoDriver
=
function
(
server
)
{
this
.
appId
=
Services
.
appinfo
.
ID
;
this
.
appName
=
Services
.
appinfo
.
name
.
toLowerCase
(
)
;
this
.
_server
=
server
;
this
.
sessionID
=
null
;
this
.
wins
=
new
browser
.
Windows
(
)
;
this
.
browsers
=
{
}
;
this
.
_browserIds
=
new
WeakMap
(
)
;
this
.
curBrowser
=
null
;
this
.
mainFrame
=
null
;
this
.
chromeBrowsingContext
=
null
;
this
.
contentBrowsingContext
=
null
;
this
.
context
=
Context
.
Content
;
this
.
sandboxes
=
new
Sandboxes
(
(
)
=
>
this
.
getCurrentWindow
(
)
)
;
this
.
legacyactions
=
new
legacyaction
.
Chain
(
)
;
this
.
capabilities
=
new
Capabilities
(
)
;
this
.
mm
=
globalMessageManager
;
this
.
listener
=
proxy
.
toListener
(
this
.
sendAsync
.
bind
(
this
)
(
)
=
>
this
.
curBrowser
)
;
this
.
dialog
=
null
;
this
.
dialogObserver
=
null
;
}
;
Object
.
defineProperty
(
GeckoDriver
.
prototype
"
a11yChecks
"
{
get
(
)
{
return
this
.
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
;
}
}
)
;
Object
.
defineProperty
(
GeckoDriver
.
prototype
"
context
"
{
get
(
)
{
return
this
.
_context
;
}
set
(
context
)
{
this
.
_context
=
Context
.
fromString
(
context
)
;
}
}
)
;
Object
.
defineProperty
(
GeckoDriver
.
prototype
"
currentURL
"
{
get
(
)
{
const
browsingContext
=
this
.
getBrowsingContext
(
{
top
:
true
}
)
;
return
new
URL
(
browsingContext
.
currentWindowGlobal
.
documentURI
.
spec
)
;
}
}
)
;
Object
.
defineProperty
(
GeckoDriver
.
prototype
"
title
"
{
get
(
)
{
const
browsingContext
=
this
.
getBrowsingContext
(
{
top
:
true
}
)
;
return
browsingContext
.
currentWindowGlobal
.
documentTitle
;
}
}
)
;
Object
.
defineProperty
(
GeckoDriver
.
prototype
"
proxy
"
{
get
(
)
{
return
this
.
capabilities
.
get
(
"
proxy
"
)
;
}
}
)
;
Object
.
defineProperty
(
GeckoDriver
.
prototype
"
secureTLS
"
{
get
(
)
{
return
!
this
.
capabilities
.
get
(
"
acceptInsecureCerts
"
)
;
}
}
)
;
Object
.
defineProperty
(
GeckoDriver
.
prototype
"
timeouts
"
{
get
(
)
{
return
this
.
capabilities
.
get
(
"
timeouts
"
)
;
}
set
(
newTimeouts
)
{
this
.
capabilities
.
set
(
"
timeouts
"
newTimeouts
)
;
}
}
)
;
Object
.
defineProperty
(
GeckoDriver
.
prototype
"
windows
"
{
get
(
)
{
return
Services
.
wm
.
getEnumerator
(
null
)
;
}
}
)
;
Object
.
defineProperty
(
GeckoDriver
.
prototype
"
windowType
"
{
get
(
)
{
return
this
.
curBrowser
.
window
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
}
}
)
;
Object
.
defineProperty
(
GeckoDriver
.
prototype
"
windowHandles
"
{
get
(
)
{
let
hs
=
[
]
;
for
(
let
win
of
this
.
windows
)
{
let
tabBrowser
=
browser
.
getTabBrowser
(
win
)
;
if
(
tabBrowser
&
&
tabBrowser
.
tabs
)
{
for
(
let
tab
of
tabBrowser
.
tabs
)
{
let
winId
=
this
.
getIdForBrowser
(
browser
.
getBrowserForTab
(
tab
)
)
;
if
(
winId
!
=
=
null
)
{
hs
.
push
(
winId
)
;
}
}
}
}
return
hs
;
}
}
)
;
Object
.
defineProperty
(
GeckoDriver
.
prototype
"
chromeWindowHandles
"
{
get
(
)
{
let
hs
=
[
]
;
for
(
let
win
of
this
.
windows
)
{
hs
.
push
(
getWindowId
(
win
)
)
;
}
return
hs
;
}
}
)
;
GeckoDriver
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
;
GeckoDriver
.
prototype
.
init
=
function
(
)
{
this
.
mm
.
addMessageListener
(
"
Marionette
:
ListenersAttached
"
this
)
;
this
.
mm
.
addMessageListener
(
"
Marionette
:
Register
"
this
)
;
this
.
mm
.
addMessageListener
(
"
Marionette
:
switchedToFrame
"
this
)
;
this
.
mm
.
addMessageListener
(
"
Marionette
:
NavigationEvent
"
this
)
;
this
.
mm
.
addMessageListener
(
"
Marionette
:
Unloaded
"
this
true
)
;
}
;
GeckoDriver
.
prototype
.
uninit
=
function
(
)
{
this
.
mm
.
removeMessageListener
(
"
Marionette
:
ListenersAttached
"
this
)
;
this
.
mm
.
removeMessageListener
(
"
Marionette
:
Register
"
this
)
;
this
.
mm
.
removeMessageListener
(
"
Marionette
:
switchedToFrame
"
this
)
;
this
.
mm
.
removeMessageListener
(
"
Marionette
:
NavigationEvent
"
this
)
;
this
.
mm
.
removeMessageListener
(
"
Marionette
:
Unloaded
"
this
)
;
}
;
GeckoDriver
.
prototype
.
handleModalDialog
=
function
(
action
dialog
win
)
{
if
(
win
!
=
=
this
.
curBrowser
.
window
)
{
return
;
}
if
(
action
=
=
=
modal
.
ACTION_OPENED
)
{
this
.
dialog
=
new
modal
.
Dialog
(
(
)
=
>
this
.
curBrowser
dialog
)
;
}
else
if
(
action
=
=
=
modal
.
ACTION_CLOSED
)
{
this
.
dialog
=
null
;
}
}
;
GeckoDriver
.
prototype
.
_getCurrentURL
=
async
function
(
)
{
let
url
;
if
(
MarionettePrefs
.
useActors
)
{
url
=
await
this
.
getActor
(
{
top
:
true
}
)
.
getCurrentUrl
(
)
;
return
new
URL
(
url
)
;
}
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
const
browsingContext
=
this
.
getBrowsingContext
(
{
top
:
true
}
)
;
url
=
browsingContext
.
window
.
location
.
href
;
break
;
case
Context
.
Content
:
url
=
await
this
.
listener
.
getCurrentUrl
(
)
;
break
;
}
return
new
URL
(
url
)
;
}
;
GeckoDriver
.
prototype
.
sendAsync
=
function
(
name
data
commandID
)
{
let
payload
=
evaluate
.
toJSON
(
data
this
.
seenEls
)
;
if
(
payload
=
=
=
null
)
{
payload
=
{
}
;
}
if
(
commandID
)
{
payload
.
commandID
=
commandID
;
}
if
(
this
.
curBrowser
.
curFrameId
)
{
let
target
=
Marionette
:
{
name
}
;
this
.
curBrowser
.
messageManager
.
sendAsyncMessage
(
target
payload
)
;
}
else
{
throw
new
error
.
NoSuchWindowError
(
"
No
such
content
frame
;
perhaps
the
listener
was
not
registered
?
"
)
;
}
}
;
GeckoDriver
.
prototype
.
getActor
=
function
(
options
=
{
}
)
{
const
browsingContext
=
this
.
getBrowsingContext
(
options
)
;
return
browsingContext
.
currentWindowGlobal
.
getActor
(
"
MarionetteFrame
"
)
;
}
;
GeckoDriver
.
prototype
.
getBrowsingContext
=
function
(
options
=
{
}
)
{
const
{
context
=
this
.
context
parent
=
false
top
=
false
}
=
options
;
let
browsingContext
=
null
;
if
(
context
=
=
=
Context
.
Chrome
)
{
browsingContext
=
this
.
chromeBrowsingContext
;
}
else
{
browsingContext
=
this
.
contentBrowsingContext
;
}
if
(
browsingContext
&
&
parent
)
{
browsingContext
=
browsingContext
.
parent
;
}
if
(
browsingContext
&
&
top
)
{
browsingContext
=
browsingContext
.
top
;
}
return
browsingContext
;
}
;
GeckoDriver
.
prototype
.
getCurrentWindow
=
function
(
options
=
{
}
)
{
const
{
context
=
this
.
context
}
=
options
;
let
win
=
null
;
switch
(
context
)
{
case
Context
.
Chrome
:
if
(
this
.
curBrowser
)
{
win
=
this
.
curBrowser
.
window
;
}
break
;
case
Context
.
Content
:
if
(
this
.
curBrowser
&
&
this
.
curBrowser
.
contentBrowser
)
{
win
=
this
.
curBrowser
.
window
;
}
break
;
}
return
win
;
}
;
GeckoDriver
.
prototype
.
isReftestBrowser
=
function
(
element
)
{
return
(
this
.
_reftest
&
&
element
&
&
element
.
tagName
=
=
=
"
xul
:
browser
"
&
&
element
.
parentElement
&
&
element
.
parentElement
.
id
=
=
=
"
reftest
"
)
;
}
;
GeckoDriver
.
prototype
.
addFrameCloseListener
=
function
(
action
)
{
let
win
=
this
.
getCurrentWindow
(
)
;
this
.
mozBrowserClose
=
e
=
>
{
if
(
e
.
target
.
id
=
=
this
.
oopFrameId
)
{
win
.
removeEventListener
(
"
mozbrowserclose
"
this
.
mozBrowserClose
true
)
;
throw
new
error
.
NoSuchWindowError
(
"
The
window
closed
during
action
:
"
+
action
)
;
}
}
;
win
.
addEventListener
(
"
mozbrowserclose
"
this
.
mozBrowserClose
true
)
;
}
;
GeckoDriver
.
prototype
.
addBrowser
=
function
(
win
)
{
let
context
=
new
browser
.
Context
(
win
this
)
;
let
winId
=
getWindowId
(
win
)
;
this
.
browsers
[
winId
]
=
context
;
this
.
curBrowser
=
this
.
browsers
[
winId
]
;
if
(
!
this
.
wins
.
has
(
winId
)
)
{
this
.
wins
.
set
(
winId
win
)
;
}
}
;
GeckoDriver
.
prototype
.
startBrowser
=
function
(
window
isNewSession
=
false
)
{
this
.
mainFrame
=
window
;
this
.
addBrowser
(
window
)
;
this
.
whenBrowserStarted
(
window
isNewSession
)
;
}
;
GeckoDriver
.
prototype
.
whenBrowserStarted
=
function
(
window
isNewSession
)
{
let
mm
=
window
.
messageManager
;
if
(
mm
)
{
if
(
!
isNewSession
)
{
if
(
mm
.
childCount
!
=
=
0
)
{
this
.
curBrowser
.
frameRegsPending
=
0
;
for
(
let
i
=
0
;
i
<
mm
.
childCount
;
i
+
+
)
{
if
(
mm
.
getChildAt
(
i
)
.
childCount
!
=
=
0
)
{
this
.
curBrowser
.
frameRegsPending
+
=
1
;
}
}
}
}
if
(
!
MarionettePrefs
.
contentListener
|
|
!
isNewSession
)
{
mm
.
loadFrameScript
(
FRAME_SCRIPT
true
)
;
MarionettePrefs
.
contentListener
=
true
;
}
}
else
{
logger
.
error
(
"
Unable
to
load
content
frame
script
"
)
;
}
}
;
GeckoDriver
.
prototype
.
getVisibleText
=
function
(
el
lines
)
{
try
{
if
(
atom
.
isElementDisplayed
(
el
this
.
getCurrentWindow
(
)
)
)
{
if
(
el
.
value
)
{
lines
.
push
(
el
.
value
)
;
}
for
(
let
child
in
el
.
childNodes
)
{
this
.
getVisibleText
(
el
.
childNodes
[
child
]
lines
)
;
}
}
}
catch
(
e
)
{
if
(
el
.
nodeName
=
=
"
#
text
"
)
{
lines
.
push
(
el
.
textContent
)
;
}
}
}
;
GeckoDriver
.
prototype
.
registerBrowser
=
function
(
id
be
)
{
if
(
this
.
appId
!
=
APP_ID_FIREFOX
|
|
be
.
namespaceURI
!
=
XUL_NS
|
|
be
.
nodeName
!
=
"
browser
"
|
|
be
.
getTabBrowser
(
)
)
{
this
.
curBrowser
.
register
(
id
be
)
;
}
this
.
wins
.
set
(
id
BrowsingContext
.
get
(
id
)
.
currentWindowGlobal
)
;
return
id
;
}
;
GeckoDriver
.
prototype
.
registerPromise
=
function
(
)
{
const
li
=
"
Marionette
:
Register
"
;
return
new
Promise
(
resolve
=
>
{
let
cb
=
(
{
json
target
}
)
=
>
{
let
{
frameId
}
=
json
;
this
.
registerBrowser
(
frameId
target
)
;
if
(
this
.
curBrowser
.
frameRegsPending
>
0
)
{
this
.
curBrowser
.
frameRegsPending
-
-
;
}
if
(
this
.
curBrowser
.
frameRegsPending
=
=
=
0
)
{
this
.
mm
.
removeMessageListener
(
li
cb
)
;
resolve
(
)
;
}
return
{
frameId
}
;
}
;
this
.
mm
.
addMessageListener
(
li
cb
)
;
}
)
;
}
;
GeckoDriver
.
prototype
.
listeningPromise
=
function
(
)
{
const
li
=
"
Marionette
:
ListenersAttached
"
;
return
new
Promise
(
resolve
=
>
{
let
cb
=
msg
=
>
{
if
(
msg
.
json
.
frameId
=
=
=
this
.
curBrowser
.
curFrameId
)
{
this
.
mm
.
removeMessageListener
(
li
cb
)
;
resolve
(
msg
.
json
.
frameId
)
;
}
}
;
this
.
mm
.
addMessageListener
(
li
cb
)
;
}
)
;
}
;
GeckoDriver
.
prototype
.
newSession
=
async
function
(
cmd
)
{
if
(
this
.
sessionID
)
{
throw
new
error
.
SessionNotCreatedError
(
"
Maximum
number
of
active
sessions
"
)
;
}
this
.
sessionID
=
WebElement
.
generateUUID
(
)
;
try
{
this
.
capabilities
=
Capabilities
.
fromJSON
(
cmd
.
parameters
)
;
if
(
!
this
.
secureTLS
)
{
logger
.
warn
(
"
TLS
certificate
errors
will
be
ignored
for
this
session
"
)
;
allowAllCerts
.
enable
(
)
;
}
if
(
this
.
proxy
.
init
(
)
)
{
logger
.
info
(
"
Proxy
settings
initialised
:
"
+
JSON
.
stringify
(
this
.
proxy
)
)
;
}
}
catch
(
e
)
{
throw
new
error
.
SessionNotCreatedError
(
e
)
;
}
if
(
this
.
a11yChecks
&
&
accessibility
.
service
)
{
logger
.
info
(
"
Preemptively
starting
accessibility
service
in
Chrome
"
)
;
}
let
registerBrowsers
=
this
.
registerPromise
(
)
;
let
browserListening
=
this
.
listeningPromise
(
)
;
let
waitForWindow
=
function
(
)
{
let
windowTypes
;
switch
(
this
.
appId
)
{
case
APP_ID_THUNDERBIRD
:
windowTypes
=
[
"
mail
:
3pane
"
]
;
break
;
default
:
windowTypes
=
[
"
navigator
:
browser
"
"
navigator
:
geckoview
"
]
;
break
;
}
let
win
;
for
(
let
windowType
of
windowTypes
)
{
win
=
Services
.
wm
.
getMostRecentWindow
(
windowType
)
;
if
(
win
)
{
break
;
}
}
if
(
!
win
)
{
let
checkTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
checkTimer
.
initWithCallback
(
waitForWindow
.
bind
(
this
)
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
if
(
win
.
document
.
readyState
!
=
"
complete
"
)
{
let
listener
=
ev
=
>
{
if
(
ev
.
target
!
=
win
.
document
)
{
return
;
}
win
.
removeEventListener
(
"
load
"
listener
)
;
waitForWindow
.
call
(
this
)
;
}
;
win
.
addEventListener
(
"
load
"
listener
true
)
;
}
else
{
if
(
MarionettePrefs
.
clickToStart
)
{
Services
.
prompt
.
alert
(
win
"
"
"
Click
to
start
execution
of
marionette
tests
"
)
;
}
this
.
startBrowser
(
win
true
)
;
}
}
;
if
(
!
MarionettePrefs
.
contentListener
)
{
waitForWindow
.
call
(
this
)
;
}
else
if
(
this
.
appId
!
=
APP_ID_FIREFOX
&
&
this
.
curBrowser
=
=
=
null
)
{
let
win
=
this
.
getCurrentWindow
(
)
;
this
.
addBrowser
(
win
)
;
this
.
whenBrowserStarted
(
win
false
)
;
}
else
{
throw
new
error
.
WebDriverError
(
"
Session
already
running
"
)
;
}
await
registerBrowsers
;
await
browserListening
;
if
(
MarionettePrefs
.
useActors
)
{
ChromeUtils
.
registerWindowActor
(
"
MarionetteFrame
"
{
kind
:
"
JSWindowActor
"
parent
:
{
moduleURI
:
"
chrome
:
/
/
marionette
/
content
/
actors
/
MarionetteFrameParent
.
jsm
"
}
child
:
{
moduleURI
:
"
chrome
:
/
/
marionette
/
content
/
actors
/
MarionetteFrameChild
.
jsm
"
events
:
{
beforeunload
:
{
capture
:
true
}
DOMContentLoaded
:
{
mozSystemGroup
:
true
}
pagehide
:
{
mozSystemGroup
:
true
}
pageshow
:
{
mozSystemGroup
:
true
}
}
}
allFrames
:
true
includeChrome
:
true
}
)
;
}
if
(
this
.
mainFrame
)
{
this
.
chromeBrowsingContext
=
this
.
mainFrame
.
browsingContext
;
this
.
mainFrame
.
focus
(
)
;
}
if
(
this
.
curBrowser
.
tab
)
{
this
.
contentBrowsingContext
=
this
.
curBrowser
.
contentBrowser
.
browsingContext
;
this
.
curBrowser
.
contentBrowser
.
focus
(
)
;
}
this
.
dialogObserver
=
new
modal
.
DialogObserver
(
this
)
;
this
.
dialogObserver
.
add
(
this
.
handleModalDialog
.
bind
(
this
)
)
;
this
.
dialog
=
modal
.
findModalDialogs
(
this
.
curBrowser
)
;
return
{
sessionId
:
this
.
sessionID
capabilities
:
this
.
capabilities
}
;
}
;
GeckoDriver
.
prototype
.
getSessionCapabilities
=
function
(
)
{
return
{
capabilities
:
this
.
capabilities
}
;
}
;
GeckoDriver
.
prototype
.
setContext
=
function
(
cmd
)
{
let
value
=
assert
.
string
(
cmd
.
parameters
.
value
)
;
this
.
context
=
value
;
}
;
GeckoDriver
.
prototype
.
getContext
=
function
(
)
{
return
this
.
context
;
}
;
GeckoDriver
.
prototype
.
executeScript
=
async
function
(
cmd
)
{
let
{
script
args
}
=
cmd
.
parameters
;
let
opts
=
{
script
:
cmd
.
parameters
.
script
args
:
cmd
.
parameters
.
args
sandboxName
:
cmd
.
parameters
.
sandbox
newSandbox
:
cmd
.
parameters
.
newSandbox
file
:
cmd
.
parameters
.
filename
line
:
cmd
.
parameters
.
line
}
;
return
{
value
:
await
this
.
execute_
(
script
args
opts
)
}
;
}
;
GeckoDriver
.
prototype
.
executeAsyncScript
=
async
function
(
cmd
)
{
let
{
script
args
}
=
cmd
.
parameters
;
let
opts
=
{
script
:
cmd
.
parameters
.
script
args
:
cmd
.
parameters
.
args
sandboxName
:
cmd
.
parameters
.
sandbox
newSandbox
:
cmd
.
parameters
.
newSandbox
file
:
cmd
.
parameters
.
filename
line
:
cmd
.
parameters
.
line
async
:
true
}
;
return
{
value
:
await
this
.
execute_
(
script
args
opts
)
}
;
}
;
GeckoDriver
.
prototype
.
execute_
=
async
function
(
script
args
=
[
]
{
sandboxName
=
null
newSandbox
=
false
file
=
"
"
line
=
0
async
=
false
}
=
{
}
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
assert
.
string
(
script
pprint
Expected
"
script
"
to
be
a
string
:
{
script
}
)
;
assert
.
array
(
args
pprint
Expected
script
args
to
be
an
array
:
{
args
}
)
;
if
(
sandboxName
!
=
=
null
)
{
assert
.
string
(
sandboxName
pprint
Expected
sandbox
name
to
be
a
string
:
{
sandboxName
}
)
;
}
assert
.
boolean
(
newSandbox
pprint
Expected
newSandbox
to
be
boolean
:
{
newSandbox
}
)
;
assert
.
string
(
file
pprint
Expected
file
to
be
a
string
:
{
file
}
)
;
assert
.
number
(
line
pprint
Expected
line
to
be
a
number
:
{
line
}
)
;
let
opts
=
{
timeout
:
this
.
timeouts
.
script
sandboxName
newSandbox
file
line
async
}
;
let
res
els
;
switch
(
this
.
context
)
{
case
Context
.
Content
:
if
(
!
sandboxName
)
{
res
=
await
this
.
listener
.
execute
(
script
args
opts
)
;
}
else
{
res
=
await
this
.
listener
.
executeInSandbox
(
script
args
opts
)
;
}
break
;
case
Context
.
Chrome
:
let
sb
=
this
.
sandboxes
.
get
(
sandboxName
newSandbox
)
;
let
wargs
=
evaluate
.
fromJSON
(
args
this
.
curBrowser
.
seenEls
sb
.
window
)
;
res
=
await
evaluate
.
sandbox
(
sb
script
wargs
opts
)
;
els
=
this
.
curBrowser
.
seenEls
;
break
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
return
evaluate
.
toJSON
(
res
els
)
;
}
;
GeckoDriver
.
prototype
.
navigateTo
=
async
function
(
cmd
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
context
:
Context
.
Content
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
validURL
;
try
{
validURL
=
new
URL
(
cmd
.
parameters
.
url
)
;
}
catch
(
e
)
{
throw
new
error
.
InvalidArgumentError
(
Malformed
URL
:
{
e
.
message
}
)
;
}
await
this
.
listener
.
switchToFrame
(
)
;
const
currentURL
=
await
this
.
_getCurrentURL
(
)
;
const
loadEventExpected
=
navigate
.
isLoadEventExpected
(
currentURL
validURL
)
;
const
browsingContext
=
this
.
getBrowsingContext
(
{
context
:
Context
.
Content
}
)
;
await
navigate
.
waitForNavigationCompleted
(
this
(
)
=
>
{
navigate
.
navigateTo
(
browsingContext
validURL
)
;
}
{
loadEventExpected
}
)
;
this
.
curBrowser
.
contentBrowser
.
focus
(
)
;
}
;
GeckoDriver
.
prototype
.
getCurrentUrl
=
async
function
(
)
{
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
const
url
=
await
this
.
_getCurrentURL
(
)
;
return
url
.
href
;
}
;
GeckoDriver
.
prototype
.
getTitle
=
async
function
(
)
{
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
return
this
.
title
;
}
;
GeckoDriver
.
prototype
.
getWindowType
=
function
(
)
{
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
return
this
.
windowType
;
}
;
GeckoDriver
.
prototype
.
getPageSource
=
async
function
(
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
const
win
=
this
.
getCurrentWindow
(
)
;
const
s
=
new
win
.
XMLSerializer
(
)
;
return
s
.
serializeToString
(
win
.
document
)
;
case
Context
.
Content
:
return
this
.
listener
.
getPageSource
(
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
goBack
=
async
function
(
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
const
browsingContext
=
this
.
getBrowsingContext
(
{
context
:
Context
.
Content
}
)
;
if
(
!
browsingContext
.
top
.
embedderElement
?
.
canGoBack
)
{
return
;
}
await
navigate
.
waitForNavigationCompleted
(
this
(
)
=
>
{
browsingContext
.
goBack
(
)
;
}
)
;
}
;
GeckoDriver
.
prototype
.
goForward
=
async
function
(
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
const
browsingContext
=
this
.
getBrowsingContext
(
{
context
:
Context
.
Content
}
)
;
if
(
!
browsingContext
.
top
.
embedderElement
?
.
canGoForward
)
{
return
;
}
await
navigate
.
waitForNavigationCompleted
(
this
(
)
=
>
{
browsingContext
.
goForward
(
)
;
}
)
;
}
;
GeckoDriver
.
prototype
.
refresh
=
async
function
(
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
await
this
.
listener
.
switchToFrame
(
)
;
const
browsingContext
=
this
.
getBrowsingContext
(
{
context
:
Context
.
Content
}
)
;
await
navigate
.
waitForNavigationCompleted
(
this
(
)
=
>
{
navigate
.
refresh
(
browsingContext
)
;
}
)
;
}
;
GeckoDriver
.
prototype
.
updateIdForBrowser
=
function
(
browser
newId
)
{
this
.
_browserIds
.
set
(
browser
.
permanentKey
newId
)
;
}
;
GeckoDriver
.
prototype
.
getIdForBrowser
=
function
(
browser
)
{
if
(
browser
=
=
=
null
)
{
return
null
;
}
let
permKey
=
browser
.
permanentKey
;
if
(
this
.
_browserIds
.
has
(
permKey
)
)
{
return
this
.
_browserIds
.
get
(
permKey
)
;
}
let
winId
=
browser
.
browsingContext
.
id
;
if
(
winId
)
{
this
.
_browserIds
.
set
(
permKey
winId
)
;
return
winId
;
}
return
null
;
}
;
GeckoDriver
.
prototype
.
getWindowHandle
=
function
(
)
{
const
browsingContext
=
assert
.
open
(
this
.
getBrowsingContext
(
{
context
:
Context
.
Content
top
:
true
}
)
)
;
return
browsingContext
.
id
.
toString
(
)
;
}
;
GeckoDriver
.
prototype
.
getWindowHandles
=
function
(
)
{
return
this
.
windowHandles
.
map
(
String
)
;
}
;
GeckoDriver
.
prototype
.
getChromeWindowHandle
=
function
(
)
{
const
browsingContext
=
assert
.
open
(
this
.
getBrowsingContext
(
{
context
:
Context
.
Chrome
top
:
true
}
)
)
;
return
browsingContext
.
id
.
toString
(
)
;
}
;
GeckoDriver
.
prototype
.
getChromeWindowHandles
=
function
(
)
{
return
this
.
chromeWindowHandles
.
map
(
String
)
;
}
;
GeckoDriver
.
prototype
.
getWindowRect
=
async
function
(
)
{
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
return
this
.
curBrowser
.
rect
;
}
;
GeckoDriver
.
prototype
.
setWindowRect
=
async
function
(
cmd
)
{
assert
.
firefox
(
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
{
x
y
width
height
}
=
cmd
.
parameters
;
const
win
=
this
.
getCurrentWindow
(
)
;
switch
(
WindowState
.
from
(
win
.
windowState
)
)
{
case
WindowState
.
Fullscreen
:
await
exitFullscreen
(
win
)
;
break
;
case
WindowState
.
Maximized
:
case
WindowState
.
Minimized
:
await
restoreWindow
(
win
)
;
break
;
}
if
(
width
!
=
null
&
&
height
!
=
null
)
{
assert
.
positiveInteger
(
height
)
;
assert
.
positiveInteger
(
width
)
;
if
(
win
.
outerWidth
!
=
width
|
|
win
.
outerHeight
!
=
height
)
{
win
.
resizeTo
(
width
height
)
;
await
new
IdlePromise
(
win
)
;
}
}
if
(
x
!
=
null
&
&
y
!
=
null
)
{
assert
.
integer
(
x
)
;
assert
.
integer
(
y
)
;
if
(
win
.
screenX
!
=
x
|
|
win
.
screenY
!
=
y
)
{
win
.
moveTo
(
x
y
)
;
await
new
IdlePromise
(
win
)
;
}
}
return
this
.
curBrowser
.
rect
;
}
;
GeckoDriver
.
prototype
.
switchToWindow
=
async
function
(
cmd
)
{
const
{
focus
=
true
handle
}
=
cmd
.
parameters
;
assert
.
string
(
handle
pprint
Expected
"
handle
"
to
be
a
string
got
{
handle
}
)
;
assert
.
boolean
(
focus
pprint
Expected
"
focus
"
to
be
a
boolean
got
{
focus
}
)
;
const
id
=
parseInt
(
handle
)
;
const
found
=
this
.
findWindow
(
this
.
windows
(
win
winId
)
=
>
id
=
=
winId
)
;
let
selected
=
false
;
if
(
found
)
{
try
{
await
this
.
setWindowHandle
(
found
focus
)
;
selected
=
true
;
}
catch
(
e
)
{
logger
.
error
(
e
)
;
}
}
if
(
!
selected
)
{
throw
new
error
.
NoSuchWindowError
(
Unable
to
locate
window
:
{
handle
}
)
;
}
}
;
GeckoDriver
.
prototype
.
findWindow
=
function
(
winIterable
filter
)
{
for
(
const
win
of
winIterable
)
{
const
browsingContext
=
win
.
docShell
.
browsingContext
;
const
tabBrowser
=
browser
.
getTabBrowser
(
win
)
;
if
(
filter
(
win
browsingContext
.
id
)
)
{
return
{
win
id
:
browsingContext
.
id
hasTabBrowser
:
!
!
tabBrowser
}
;
}
else
if
(
tabBrowser
&
&
tabBrowser
.
tabs
)
{
for
(
let
i
=
0
;
i
<
tabBrowser
.
tabs
.
length
;
+
+
i
)
{
let
contentBrowser
=
browser
.
getBrowserForTab
(
tabBrowser
.
tabs
[
i
]
)
;
let
contentWindowId
=
this
.
getIdForBrowser
(
contentBrowser
)
;
if
(
filter
(
win
contentWindowId
)
)
{
return
{
win
id
:
browsingContext
.
id
hasTabBrowser
:
true
tabIndex
:
i
}
;
}
}
}
}
return
null
;
}
;
GeckoDriver
.
prototype
.
setWindowHandle
=
async
function
(
winProperties
focus
=
true
)
{
if
(
!
(
winProperties
.
id
in
this
.
browsers
)
)
{
let
registerBrowsers
browserListening
;
if
(
winProperties
.
hasTabBrowser
)
{
registerBrowsers
=
this
.
registerPromise
(
)
;
browserListening
=
this
.
listeningPromise
(
)
;
}
this
.
startBrowser
(
winProperties
.
win
false
)
;
this
.
chromeBrowsingContext
=
this
.
mainFrame
.
browsingContext
;
if
(
registerBrowsers
&
&
browserListening
)
{
await
registerBrowsers
;
const
id
=
await
browserListening
;
this
.
contentBrowsingContext
=
BrowsingContext
.
get
(
id
)
;
}
else
{
this
.
contentBrowsingContext
=
null
;
}
}
else
{
this
.
curBrowser
=
this
.
browsers
[
winProperties
.
id
]
;
this
.
mainFrame
=
this
.
curBrowser
.
window
;
let
tab
=
null
;
if
(
winProperties
.
hasTabBrowser
)
{
tab
=
await
this
.
curBrowser
.
switchToTab
(
winProperties
.
tabIndex
winProperties
.
win
focus
)
;
}
this
.
chromeBrowsingContext
=
this
.
mainFrame
.
browsingContext
;
this
.
contentBrowsingContext
=
tab
?
.
linkedBrowser
.
browsingContext
;
}
if
(
focus
)
{
await
this
.
curBrowser
.
focusWindow
(
)
;
}
}
;
GeckoDriver
.
prototype
.
switchToParentFrame
=
async
function
(
)
{
let
browsingContext
=
this
.
getBrowsingContext
(
)
;
if
(
browsingContext
&
&
!
browsingContext
.
parent
)
{
return
;
}
browsingContext
=
assert
.
open
(
browsingContext
?
.
parent
)
;
if
(
MarionettePrefs
.
useActors
)
{
this
.
contentBrowsingContext
=
browsingContext
;
return
;
}
await
this
.
listener
.
switchToParentFrame
(
)
;
}
;
GeckoDriver
.
prototype
.
switchToFrame
=
async
function
(
cmd
)
{
const
{
element
:
el
focus
=
false
id
}
=
cmd
.
parameters
;
if
(
typeof
id
=
=
"
number
"
)
{
assert
.
unsignedShort
(
id
Expected
id
to
be
unsigned
short
got
{
id
}
)
;
}
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
id
=
=
null
&
&
el
=
=
null
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
byFrame
;
if
(
typeof
el
=
=
"
string
"
)
{
byFrame
=
WebElement
.
fromUUID
(
el
this
.
context
)
;
}
else
if
(
el
)
{
byFrame
=
WebElement
.
fromJSON
(
el
)
;
}
if
(
MarionettePrefs
.
useActors
)
{
const
{
browsingContext
}
=
await
this
.
getActor
(
)
.
switchToFrame
(
byFrame
|
|
id
)
;
this
.
contentBrowsingContext
=
browsingContext
;
return
;
}
const
checkLoad
=
function
(
win
)
{
const
otherErrorsExpr
=
/
about
:
.
+
(
error
)
|
(
blocked
)
\
?
/
;
return
new
PollPromise
(
resolve
=
>
{
if
(
win
.
document
.
readyState
=
=
"
complete
"
)
{
resolve
(
)
;
}
else
if
(
win
.
document
.
readyState
=
=
"
interactive
"
)
{
let
documentURI
=
win
.
document
.
documentURI
;
if
(
documentURI
.
startsWith
(
"
about
:
certerror
"
)
)
{
throw
new
error
.
InsecureCertificateError
(
)
;
}
else
if
(
otherErrorsExpr
.
exec
(
documentURI
)
)
{
throw
new
error
.
UnknownError
(
"
Reached
error
page
:
"
+
documentURI
)
;
}
}
}
)
;
}
;
if
(
this
.
context
=
=
Context
.
Chrome
)
{
const
childContexts
=
this
.
getBrowsingContext
(
)
.
children
;
let
browsingContext
;
if
(
id
=
=
null
&
&
!
byFrame
)
{
browsingContext
=
this
.
getBrowsingContext
(
{
top
:
true
}
)
;
}
else
if
(
typeof
id
=
=
"
number
"
)
{
if
(
id
<
0
|
|
id
>
=
childContexts
.
length
)
{
throw
new
error
.
NoSuchFrameError
(
Unable
to
locate
frame
with
index
:
{
id
}
)
;
}
browsingContext
=
childContexts
[
id
]
;
}
else
{
const
wantedFrame
=
this
.
curBrowser
.
seenEls
.
get
(
byFrame
)
;
const
context
=
childContexts
.
find
(
context
=
>
{
return
context
.
embedderElement
=
=
=
wantedFrame
;
}
)
;
if
(
!
context
)
{
throw
new
error
.
NoSuchFrameError
(
Unable
to
locate
frame
for
element
:
{
byFrame
}
)
;
}
browsingContext
=
context
;
}
this
.
contentBrowsingContext
=
browsingContext
;
const
frameWindow
=
browsingContext
.
window
;
await
checkLoad
(
frameWindow
)
;
if
(
focus
)
{
frameWindow
.
focus
(
)
;
}
}
else
if
(
this
.
context
=
=
Context
.
Content
)
{
cmd
.
commandID
=
cmd
.
id
;
await
this
.
listener
.
switchToFrame
(
cmd
.
parameters
)
;
}
}
;
GeckoDriver
.
prototype
.
getTimeouts
=
function
(
)
{
return
this
.
timeouts
;
}
;
GeckoDriver
.
prototype
.
setTimeouts
=
function
(
cmd
)
{
let
merged
=
Object
.
assign
(
this
.
timeouts
.
toJSON
(
)
cmd
.
parameters
)
;
this
.
timeouts
=
Timeouts
.
fromJSON
(
merged
)
;
}
;
GeckoDriver
.
prototype
.
singleTap
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
let
{
id
x
y
}
=
cmd
.
parameters
;
let
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
throw
new
error
.
UnsupportedOperationError
(
"
Command
'
singleTap
'
is
not
yet
available
in
chrome
context
"
)
;
case
Context
.
Content
:
await
this
.
listener
.
singleTap
(
webEl
x
y
this
.
capabilities
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
performActions
=
async
function
(
cmd
)
{
assert
.
content
(
this
.
context
"
Command
'
performActions
'
is
not
yet
available
in
chrome
context
"
)
;
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
actions
=
cmd
.
parameters
.
actions
;
await
this
.
listener
.
performActions
(
{
actions
}
this
.
capabilities
)
;
}
;
GeckoDriver
.
prototype
.
releaseActions
=
async
function
(
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
await
this
.
listener
.
releaseActions
(
)
;
}
;
GeckoDriver
.
prototype
.
actionChain
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
{
chain
nextId
}
=
cmd
.
parameters
;
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
assert
.
firefox
(
)
;
return
this
.
legacyactions
.
dispatchActions
(
chain
nextId
{
frame
:
this
.
getCurrentWindow
(
)
}
this
.
curBrowser
.
seenEls
)
;
case
Context
.
Content
:
return
this
.
listener
.
actionChain
(
chain
nextId
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
multiAction
=
async
function
(
cmd
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
{
value
max_length
}
=
cmd
.
parameters
;
await
this
.
listener
.
multiAction
(
value
max_length
)
;
}
;
GeckoDriver
.
prototype
.
findElement
=
async
function
(
cmd
)
{
const
{
element
:
el
using
value
}
=
cmd
.
parameters
;
if
(
!
SUPPORTED_STRATEGIES
.
has
(
using
)
)
{
throw
new
error
.
InvalidSelectorError
(
Strategy
not
supported
:
{
using
}
)
;
}
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
startNode
;
if
(
typeof
el
!
=
"
undefined
"
)
{
startNode
=
WebElement
.
fromUUID
(
el
this
.
context
)
;
}
let
opts
=
{
startNode
timeout
:
this
.
timeouts
.
implicit
all
:
false
}
;
if
(
MarionettePrefs
.
useActors
)
{
return
this
.
getActor
(
)
.
findElement
(
using
value
opts
)
;
}
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
let
container
=
{
frame
:
this
.
getCurrentWindow
(
)
}
;
if
(
opts
.
startNode
)
{
opts
.
startNode
=
this
.
curBrowser
.
seenEls
.
get
(
opts
.
startNode
)
;
}
let
el
=
await
element
.
find
(
container
using
value
opts
)
;
return
this
.
curBrowser
.
seenEls
.
add
(
el
)
;
case
Context
.
Content
:
return
this
.
listener
.
findElementContent
(
using
value
opts
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
findElements
=
async
function
(
cmd
)
{
const
{
element
:
el
using
value
}
=
cmd
.
parameters
;
if
(
!
SUPPORTED_STRATEGIES
.
has
(
using
)
)
{
throw
new
error
.
InvalidSelectorError
(
Strategy
not
supported
:
{
using
}
)
;
}
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
startNode
;
if
(
typeof
el
!
=
"
undefined
"
)
{
startNode
=
WebElement
.
fromUUID
(
el
this
.
context
)
;
}
let
opts
=
{
startNode
timeout
:
this
.
timeouts
.
implicit
all
:
true
}
;
if
(
MarionettePrefs
.
useActors
)
{
return
this
.
getActor
(
)
.
findElements
(
using
value
opts
)
;
}
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
let
container
=
{
frame
:
this
.
getCurrentWindow
(
)
}
;
if
(
startNode
)
{
opts
.
startNode
=
this
.
curBrowser
.
seenEls
.
get
(
opts
.
startNode
)
;
}
let
els
=
await
element
.
find
(
container
using
value
opts
)
;
return
this
.
curBrowser
.
seenEls
.
addAll
(
els
)
;
case
Context
.
Content
:
return
this
.
listener
.
findElementsContent
(
using
value
opts
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
getActiveElement
=
async
function
(
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
return
this
.
listener
.
getActiveElement
(
)
;
}
;
GeckoDriver
.
prototype
.
clickElement
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
id
=
assert
.
string
(
cmd
.
parameters
.
id
)
;
let
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
)
;
await
interaction
.
clickElement
(
el
this
.
a11yChecks
)
;
break
;
case
Context
.
Content
:
const
target
=
await
this
.
listener
.
getElementAttribute
(
webEl
"
target
"
)
;
await
navigate
.
waitForNavigationCompleted
(
this
async
(
)
=
>
{
await
this
.
listener
.
clickElement
(
webEl
this
.
capabilities
)
;
}
{
browsingContext
:
this
.
getBrowsingContext
(
)
requireBeforeUnload
:
false
loadEventExpected
:
target
!
=
=
"
_blank
"
}
)
;
break
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
getElementAttribute
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
const
id
=
assert
.
string
(
cmd
.
parameters
.
id
)
;
const
name
=
assert
.
string
(
cmd
.
parameters
.
name
)
;
const
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
if
(
MarionettePrefs
.
useActors
)
{
return
this
.
getActor
(
)
.
getElementAttribute
(
webEl
name
)
;
}
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
)
;
return
el
.
getAttribute
(
name
)
;
case
Context
.
Content
:
return
this
.
listener
.
getElementAttribute
(
webEl
name
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
getElementProperty
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
const
id
=
assert
.
string
(
cmd
.
parameters
.
id
)
;
const
name
=
assert
.
string
(
cmd
.
parameters
.
name
)
;
const
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
if
(
MarionettePrefs
.
useActors
)
{
return
this
.
getActor
(
)
.
getElementProperty
(
webEl
name
)
;
}
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
)
;
return
evaluate
.
toJSON
(
el
[
name
]
this
.
curBrowser
.
seenEls
)
;
case
Context
.
Content
:
return
this
.
listener
.
getElementProperty
(
webEl
name
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
getElementText
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
id
=
assert
.
string
(
cmd
.
parameters
.
id
)
;
let
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
if
(
MarionettePrefs
.
useActors
)
{
return
this
.
getActor
(
)
.
getElementText
(
webEl
)
;
}
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
)
;
let
lines
=
[
]
;
this
.
getVisibleText
(
el
lines
)
;
return
lines
.
join
(
"
\
n
"
)
;
case
Context
.
Content
:
return
this
.
listener
.
getElementText
(
webEl
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
getElementTagName
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
id
=
assert
.
string
(
cmd
.
parameters
.
id
)
;
let
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
if
(
MarionettePrefs
.
useActors
)
{
return
this
.
getActor
(
)
.
getElementTagName
(
webEl
)
;
}
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
)
;
return
el
.
tagName
.
toLowerCase
(
)
;
case
Context
.
Content
:
return
this
.
listener
.
getElementTagName
(
webEl
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
isElementDisplayed
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
id
=
assert
.
string
(
cmd
.
parameters
.
id
)
;
let
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
)
;
return
interaction
.
isElementDisplayed
(
el
this
.
a11yChecks
)
;
case
Context
.
Content
:
return
this
.
listener
.
isElementDisplayed
(
webEl
this
.
capabilities
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
getElementValueOfCssProperty
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
id
=
assert
.
string
(
cmd
.
parameters
.
id
)
;
let
prop
=
assert
.
string
(
cmd
.
parameters
.
propertyName
)
;
let
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
if
(
MarionettePrefs
.
useActors
)
{
return
this
.
getActor
(
)
.
getElementValueOfCssProperty
(
webEl
prop
)
;
}
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
const
win
=
this
.
getCurrentWindow
(
)
;
const
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
)
;
const
style
=
win
.
document
.
defaultView
.
getComputedStyle
(
el
)
;
return
style
.
getPropertyValue
(
prop
)
;
case
Context
.
Content
:
return
this
.
listener
.
getElementValueOfCssProperty
(
webEl
prop
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
isElementEnabled
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
id
=
assert
.
string
(
cmd
.
parameters
.
id
)
;
let
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
)
;
return
interaction
.
isElementEnabled
(
el
this
.
a11yChecks
)
;
case
Context
.
Content
:
return
this
.
listener
.
isElementEnabled
(
webEl
this
.
capabilities
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
isElementSelected
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
id
=
assert
.
string
(
cmd
.
parameters
.
id
)
;
let
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
)
;
return
interaction
.
isElementSelected
(
el
this
.
a11yChecks
)
;
case
Context
.
Content
:
return
this
.
listener
.
isElementSelected
(
webEl
this
.
capabilities
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
getElementRect
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
id
=
assert
.
string
(
cmd
.
parameters
.
id
)
;
let
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
const
win
=
this
.
getCurrentWindow
(
)
;
const
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
)
;
const
rect
=
el
.
getBoundingClientRect
(
)
;
return
{
x
:
rect
.
x
+
win
.
pageXOffset
y
:
rect
.
y
+
win
.
pageYOffset
width
:
rect
.
width
height
:
rect
.
height
}
;
case
Context
.
Content
:
return
this
.
listener
.
getElementRect
(
webEl
)
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
sendKeysToElement
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
id
=
assert
.
string
(
cmd
.
parameters
.
id
)
;
let
text
=
assert
.
string
(
cmd
.
parameters
.
text
)
;
let
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
)
;
await
interaction
.
sendKeysToElement
(
el
text
{
accessibilityChecks
:
this
.
a11yChecks
}
)
;
break
;
case
Context
.
Content
:
await
this
.
listener
.
sendKeysToElement
(
webEl
text
this
.
capabilities
)
;
break
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
clearElement
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
id
=
assert
.
string
(
cmd
.
parameters
.
id
)
;
let
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
if
(
MarionettePrefs
.
useActors
)
{
await
this
.
getActor
(
)
.
clearElement
(
webEl
)
;
return
;
}
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
)
;
if
(
el
.
nodeName
=
=
"
input
"
&
&
el
.
type
=
=
"
text
"
)
{
el
.
value
=
"
"
;
}
else
if
(
el
.
nodeName
=
=
"
checkbox
"
)
{
el
.
checked
=
false
;
}
break
;
case
Context
.
Content
:
await
this
.
listener
.
clearElement
(
webEl
)
;
break
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
}
;
GeckoDriver
.
prototype
.
switchToShadowRoot
=
async
function
(
cmd
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
let
id
=
cmd
.
parameters
.
id
;
let
webEl
=
null
;
if
(
id
!
=
null
)
{
assert
.
string
(
id
)
;
webEl
=
WebElement
.
fromUUID
(
id
this
.
context
)
;
}
await
this
.
listener
.
switchToShadowRoot
(
webEl
)
;
}
;
GeckoDriver
.
prototype
.
addCookie
=
async
function
(
cmd
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
{
protocol
hostname
}
=
await
this
.
_getCurrentURL
(
)
;
const
networkSchemes
=
[
"
ftp
:
"
"
http
:
"
"
https
:
"
]
;
if
(
!
networkSchemes
.
includes
(
protocol
)
)
{
throw
new
error
.
InvalidCookieDomainError
(
"
Document
is
cookie
-
averse
"
)
;
}
let
newCookie
=
cookie
.
fromJSON
(
cmd
.
parameters
.
cookie
)
;
cookie
.
add
(
newCookie
{
restrictToHost
:
hostname
protocol
}
)
;
}
;
GeckoDriver
.
prototype
.
getCookies
=
async
function
(
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
{
hostname
pathname
}
=
await
this
.
_getCurrentURL
(
)
;
return
[
.
.
.
cookie
.
iter
(
hostname
pathname
)
]
;
}
;
GeckoDriver
.
prototype
.
deleteAllCookies
=
async
function
(
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
{
hostname
pathname
}
=
await
this
.
_getCurrentURL
(
)
;
for
(
let
toDelete
of
cookie
.
iter
(
hostname
pathname
)
)
{
cookie
.
remove
(
toDelete
)
;
}
}
;
GeckoDriver
.
prototype
.
deleteCookie
=
async
function
(
cmd
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
{
hostname
pathname
}
=
await
this
.
_getCurrentURL
(
)
;
let
name
=
assert
.
string
(
cmd
.
parameters
.
name
)
;
for
(
let
c
of
cookie
.
iter
(
hostname
pathname
)
)
{
if
(
c
.
name
=
=
=
name
)
{
cookie
.
remove
(
c
)
;
}
}
}
;
GeckoDriver
.
prototype
.
newWindow
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
focus
=
false
;
if
(
typeof
cmd
.
parameters
.
focus
!
=
"
undefined
"
)
{
focus
=
assert
.
boolean
(
cmd
.
parameters
.
focus
pprint
Expected
"
focus
"
to
be
a
boolean
got
{
cmd
.
parameters
.
focus
}
)
;
}
let
isPrivate
=
false
;
if
(
typeof
cmd
.
parameters
.
private
!
=
"
undefined
"
)
{
isPrivate
=
assert
.
boolean
(
cmd
.
parameters
.
private
pprint
Expected
"
private
"
to
be
a
boolean
got
{
cmd
.
parameters
.
private
}
)
;
}
let
type
;
if
(
typeof
cmd
.
parameters
.
type
!
=
"
undefined
"
)
{
type
=
assert
.
string
(
cmd
.
parameters
.
type
pprint
Expected
"
type
"
to
be
a
string
got
{
cmd
.
parameters
.
type
}
)
;
}
if
(
typeof
type
=
=
"
undefined
"
|
|
!
[
"
tab
"
"
window
"
]
.
includes
(
type
)
)
{
type
=
"
tab
"
;
}
let
contentBrowser
;
switch
(
type
)
{
case
"
window
"
:
let
win
=
await
this
.
curBrowser
.
openBrowserWindow
(
focus
isPrivate
)
;
contentBrowser
=
browser
.
getTabBrowser
(
win
)
.
selectedBrowser
;
break
;
default
:
let
tab
=
await
this
.
curBrowser
.
openTab
(
focus
)
;
contentBrowser
=
browser
.
getBrowserForTab
(
tab
)
;
}
let
windowId
=
await
new
PollPromise
(
(
resolve
reject
)
=
>
{
let
id
=
this
.
getIdForBrowser
(
contentBrowser
)
;
this
.
windowHandles
.
includes
(
id
)
?
resolve
(
id
)
:
reject
(
)
;
}
)
;
return
{
handle
:
windowId
.
toString
(
)
type
}
;
}
;
GeckoDriver
.
prototype
.
close
=
async
function
(
)
{
assert
.
open
(
this
.
getBrowsingContext
(
{
context
:
Context
.
Content
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
nwins
=
0
;
for
(
let
win
of
this
.
windows
)
{
let
tabbrowser
=
browser
.
getTabBrowser
(
win
)
;
if
(
tabbrowser
&
&
tabbrowser
.
tabs
)
{
nwins
+
=
tabbrowser
.
tabs
.
length
;
}
else
{
nwins
+
=
1
;
}
}
if
(
nwins
=
=
=
1
)
{
return
[
]
;
}
await
this
.
curBrowser
.
closeTab
(
)
;
this
.
contentBrowsingContext
=
null
;
return
this
.
windowHandles
.
map
(
String
)
;
}
;
GeckoDriver
.
prototype
.
closeChromeWindow
=
async
function
(
)
{
assert
.
firefox
(
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
context
:
Context
.
Chrome
top
:
true
}
)
)
;
let
nwins
=
0
;
for
(
let
_
of
this
.
windows
)
{
nwins
+
+
;
}
if
(
nwins
=
=
1
)
{
return
[
]
;
}
await
this
.
curBrowser
.
closeWindow
(
)
;
return
this
.
chromeWindowHandles
.
map
(
String
)
;
}
;
GeckoDriver
.
prototype
.
deleteSession
=
function
(
)
{
if
(
this
.
curBrowser
!
=
=
null
)
{
MarionettePrefs
.
contentListener
=
false
;
globalMessageManager
.
broadcastAsyncMessage
(
"
Marionette
:
Session
:
Delete
"
)
;
globalMessageManager
.
broadcastAsyncMessage
(
"
Marionette
:
Deregister
"
)
;
for
(
let
win
of
this
.
windows
)
{
if
(
win
.
messageManager
)
{
win
.
messageManager
.
removeDelayedFrameScript
(
FRAME_SCRIPT
)
;
}
else
{
logger
.
error
(
Could
not
remove
listener
from
page
{
win
.
location
.
href
}
)
;
}
}
}
if
(
MarionettePrefs
.
useActors
)
{
if
(
this
.
getBrowsingContext
(
)
)
{
try
{
this
.
getActor
(
)
.
cleanUp
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_DOM_NOT_FOUND_ERR
)
{
throw
e
;
}
}
}
ChromeUtils
.
unregisterWindowActor
(
"
MarionetteFrame
"
)
;
}
this
.
mainFrame
=
null
;
this
.
chromeBrowsingContext
=
null
;
this
.
contentBrowsingContext
=
null
;
if
(
this
.
dialogObserver
)
{
this
.
dialogObserver
.
cleanup
(
)
;
this
.
dialogObserver
=
null
;
}
this
.
sandboxes
.
clear
(
)
;
allowAllCerts
.
disable
(
)
;
this
.
sessionID
=
null
;
this
.
capabilities
=
new
Capabilities
(
)
;
}
;
GeckoDriver
.
prototype
.
takeScreenshot
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
let
{
id
full
hash
scroll
}
=
cmd
.
parameters
;
let
format
=
hash
?
capture
.
Format
.
Hash
:
capture
.
Format
.
Base64
;
full
=
typeof
full
=
=
"
undefined
"
?
true
:
full
;
scroll
=
typeof
scroll
=
=
"
undefined
"
?
true
:
scroll
;
let
webEl
=
id
?
WebElement
.
fromUUID
(
id
this
.
context
)
:
null
;
full
=
webEl
?
false
:
full
;
const
win
=
this
.
getCurrentWindow
(
)
;
let
rect
;
switch
(
this
.
context
)
{
case
Context
.
Chrome
:
if
(
id
)
{
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
webEl
win
)
;
rect
=
el
.
getBoundingClientRect
(
)
;
}
else
if
(
full
)
{
const
docEl
=
win
.
document
.
documentElement
;
rect
=
new
DOMRect
(
0
0
docEl
.
scrollWidth
docEl
.
scrollHeight
)
;
}
else
{
rect
=
new
win
.
DOMRect
(
win
.
pageXOffset
win
.
pageYOffset
win
.
innerWidth
win
.
innerHeight
)
;
}
break
;
case
Context
.
Content
:
rect
=
await
this
.
listener
.
getScreenshotRect
(
{
el
:
webEl
full
scroll
}
)
;
break
;
}
const
browsingContext
=
this
.
getBrowsingContext
(
{
top
:
!
webEl
}
)
;
let
canvas
=
await
capture
.
canvas
(
win
browsingContext
rect
.
x
rect
.
y
rect
.
width
rect
.
height
)
;
switch
(
format
)
{
case
capture
.
Format
.
Hash
:
return
capture
.
toHash
(
canvas
)
;
case
capture
.
Format
.
Base64
:
return
capture
.
toBase64
(
canvas
)
;
}
throw
new
TypeError
(
Unknown
context
:
{
this
.
context
}
)
;
}
;
GeckoDriver
.
prototype
.
getScreenOrientation
=
function
(
)
{
assert
.
fennec
(
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
const
win
=
this
.
getCurrentWindow
(
)
;
return
win
.
screen
.
mozOrientation
;
}
;
GeckoDriver
.
prototype
.
setScreenOrientation
=
function
(
cmd
)
{
assert
.
fennec
(
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
const
ors
=
[
"
portrait
"
"
landscape
"
"
portrait
-
primary
"
"
landscape
-
primary
"
"
portrait
-
secondary
"
"
landscape
-
secondary
"
]
;
let
or
=
String
(
cmd
.
parameters
.
orientation
)
;
assert
.
string
(
or
)
;
let
mozOr
=
or
.
toLowerCase
(
)
;
if
(
!
ors
.
includes
(
mozOr
)
)
{
throw
new
error
.
InvalidArgumentError
(
Unknown
screen
orientation
:
{
or
}
)
;
}
const
win
=
this
.
getCurrentWindow
(
)
;
if
(
!
win
.
screen
.
mozLockOrientation
(
mozOr
)
)
{
throw
new
error
.
WebDriverError
(
Unable
to
set
screen
orientation
:
{
or
}
)
;
}
}
;
GeckoDriver
.
prototype
.
minimizeWindow
=
async
function
(
)
{
assert
.
firefox
(
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
const
win
=
this
.
getCurrentWindow
(
)
;
switch
(
WindowState
.
from
(
win
.
windowState
)
)
{
case
WindowState
.
Fullscreen
:
await
exitFullscreen
(
win
)
;
break
;
case
WindowState
.
Maximized
:
await
restoreWindow
(
win
)
;
break
;
}
if
(
WindowState
.
from
(
win
.
windowState
)
!
=
WindowState
.
Minimized
)
{
let
cb
;
let
observer
=
new
WebElementEventTarget
(
this
.
curBrowser
.
messageManager
)
;
await
new
TimedPromise
(
resolve
=
>
{
cb
=
new
DebounceCallback
(
resolve
)
;
observer
.
addEventListener
(
"
visibilitychange
"
cb
)
;
win
.
minimize
(
)
;
}
{
throws
:
null
timeout
:
TIMEOUT_NO_WINDOW_MANAGER
}
)
;
observer
.
removeEventListener
(
"
visibilitychange
"
cb
)
;
await
new
IdlePromise
(
win
)
;
}
return
this
.
curBrowser
.
rect
;
}
;
GeckoDriver
.
prototype
.
maximizeWindow
=
async
function
(
)
{
assert
.
firefox
(
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
const
win
=
this
.
getCurrentWindow
(
)
;
switch
(
WindowState
.
from
(
win
.
windowState
)
)
{
case
WindowState
.
Fullscreen
:
await
exitFullscreen
(
win
)
;
break
;
case
WindowState
.
Minimized
:
await
restoreWindow
(
win
)
;
break
;
}
if
(
WindowState
.
from
(
win
.
windowState
)
!
=
WindowState
.
Maximized
)
{
let
cb
;
await
new
TimedPromise
(
resolve
=
>
{
cb
=
new
DebounceCallback
(
resolve
)
;
win
.
addEventListener
(
"
sizemodechange
"
cb
)
;
win
.
maximize
(
)
;
}
{
throws
:
null
timeout
:
TIMEOUT_NO_WINDOW_MANAGER
}
)
;
win
.
removeEventListener
(
"
sizemodechange
"
cb
)
;
await
new
IdlePromise
(
win
)
;
}
return
this
.
curBrowser
.
rect
;
}
;
GeckoDriver
.
prototype
.
fullscreenWindow
=
async
function
(
)
{
assert
.
firefox
(
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
const
win
=
this
.
getCurrentWindow
(
)
;
switch
(
WindowState
.
from
(
win
.
windowState
)
)
{
case
WindowState
.
Maximized
:
case
WindowState
.
Minimized
:
await
restoreWindow
(
win
)
;
break
;
}
if
(
WindowState
.
from
(
win
.
windowState
)
!
=
WindowState
.
Fullscreen
)
{
let
cb
;
await
new
TimedPromise
(
resolve
=
>
{
cb
=
new
DebounceCallback
(
resolve
)
;
win
.
addEventListener
(
"
sizemodechange
"
cb
)
;
win
.
fullScreen
=
true
;
}
{
throws
:
null
timeout
:
TIMEOUT_NO_WINDOW_MANAGER
}
)
;
win
.
removeEventListener
(
"
sizemodechange
"
cb
)
;
}
await
new
IdlePromise
(
win
)
;
return
this
.
curBrowser
.
rect
;
}
;
GeckoDriver
.
prototype
.
dismissDialog
=
async
function
(
)
{
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
this
.
_checkIfAlertIsPresent
(
)
;
const
win
=
this
.
getCurrentWindow
(
)
;
const
dialogClosed
=
waitForEvent
(
win
"
DOMModalDialogClosed
"
)
;
const
{
button0
button1
}
=
this
.
dialog
.
ui
;
(
button1
?
button1
:
button0
)
.
click
(
)
;
await
dialogClosed
;
await
new
IdlePromise
(
win
)
;
}
;
GeckoDriver
.
prototype
.
acceptDialog
=
async
function
(
)
{
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
this
.
_checkIfAlertIsPresent
(
)
;
const
win
=
this
.
getCurrentWindow
(
)
;
const
dialogClosed
=
waitForEvent
(
win
"
DOMModalDialogClosed
"
)
;
const
{
button0
}
=
this
.
dialog
.
ui
;
button0
.
click
(
)
;
await
dialogClosed
;
await
new
IdlePromise
(
win
)
;
}
;
GeckoDriver
.
prototype
.
getTextFromDialog
=
function
(
)
{
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
this
.
_checkIfAlertIsPresent
(
)
;
return
this
.
dialog
.
ui
.
infoBody
.
textContent
;
}
;
GeckoDriver
.
prototype
.
sendKeysToDialog
=
async
function
(
cmd
)
{
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
this
.
_checkIfAlertIsPresent
(
)
;
let
text
=
assert
.
string
(
cmd
.
parameters
.
text
)
;
let
promptType
=
this
.
dialog
.
args
.
promptType
;
switch
(
promptType
)
{
case
"
alert
"
:
case
"
confirm
"
:
throw
new
error
.
ElementNotInteractableError
(
User
prompt
of
type
{
promptType
}
is
not
interactable
)
;
case
"
prompt
"
:
break
;
default
:
await
this
.
dismissDialog
(
)
;
throw
new
error
.
UnsupportedOperationError
(
User
prompt
of
type
{
promptType
}
is
not
supported
)
;
}
let
{
loginTextbox
}
=
this
.
dialog
.
ui
;
loginTextbox
.
value
=
text
;
}
;
GeckoDriver
.
prototype
.
_checkIfAlertIsPresent
=
function
(
)
{
if
(
!
this
.
dialog
|
|
!
this
.
dialog
.
ui
)
{
throw
new
error
.
NoSuchAlertError
(
)
;
}
}
;
GeckoDriver
.
prototype
.
_handleUserPrompts
=
async
function
(
)
{
if
(
!
this
.
dialog
|
|
!
this
.
dialog
.
ui
)
{
return
;
}
let
{
textContent
}
=
this
.
dialog
.
ui
.
infoBody
;
let
behavior
=
this
.
capabilities
.
get
(
"
unhandledPromptBehavior
"
)
;
switch
(
behavior
)
{
case
UnhandledPromptBehavior
.
Accept
:
await
this
.
acceptDialog
(
)
;
break
;
case
UnhandledPromptBehavior
.
AcceptAndNotify
:
await
this
.
acceptDialog
(
)
;
throw
new
error
.
UnexpectedAlertOpenError
(
Accepted
user
prompt
dialog
:
{
textContent
}
)
;
case
UnhandledPromptBehavior
.
Dismiss
:
await
this
.
dismissDialog
(
)
;
break
;
case
UnhandledPromptBehavior
.
DismissAndNotify
:
await
this
.
dismissDialog
(
)
;
throw
new
error
.
UnexpectedAlertOpenError
(
Dismissed
user
prompt
dialog
:
{
textContent
}
)
;
case
UnhandledPromptBehavior
.
Ignore
:
throw
new
error
.
UnexpectedAlertOpenError
(
"
Encountered
unhandled
user
prompt
dialog
"
)
;
default
:
throw
new
TypeError
(
Unknown
unhandledPromptBehavior
"
{
behavior
}
"
)
;
}
}
;
GeckoDriver
.
prototype
.
acceptConnections
=
function
(
cmd
)
{
assert
.
boolean
(
cmd
.
parameters
.
value
)
;
this
.
_server
.
acceptConnections
=
cmd
.
parameters
.
value
;
}
;
GeckoDriver
.
prototype
.
quit
=
async
function
(
cmd
)
{
const
quits
=
[
"
eConsiderQuit
"
"
eAttemptQuit
"
"
eForceQuit
"
]
;
let
flags
=
[
]
;
if
(
typeof
cmd
.
parameters
.
flags
!
=
"
undefined
"
)
{
flags
=
assert
.
array
(
cmd
.
parameters
.
flags
)
;
}
let
quitSeen
;
let
mode
=
0
;
if
(
flags
.
length
>
0
)
{
for
(
let
k
of
flags
)
{
assert
.
in
(
k
Ci
.
nsIAppStartup
)
;
if
(
quits
.
includes
(
k
)
)
{
if
(
quitSeen
)
{
throw
new
error
.
InvalidArgumentError
(
{
k
}
cannot
be
combined
with
{
quitSeen
}
)
;
}
quitSeen
=
k
;
}
mode
|
=
Ci
.
nsIAppStartup
[
k
]
;
}
}
else
{
mode
=
Ci
.
nsIAppStartup
.
eAttemptQuit
;
}
this
.
_server
.
acceptConnections
=
false
;
this
.
deleteSession
(
)
;
let
quitApplication
=
waitForObserverTopic
(
"
quit
-
application
"
)
;
Services
.
startup
.
quit
(
mode
)
;
return
{
cause
:
(
await
quitApplication
)
.
data
}
;
}
;
GeckoDriver
.
prototype
.
installAddon
=
function
(
cmd
)
{
assert
.
desktop
(
)
;
let
path
=
cmd
.
parameters
.
path
;
let
temp
=
cmd
.
parameters
.
temporary
|
|
false
;
if
(
typeof
path
=
=
"
undefined
"
|
|
typeof
path
!
=
"
string
"
|
|
typeof
temp
!
=
"
boolean
"
)
{
throw
new
error
.
InvalidArgumentError
(
)
;
}
return
Addon
.
install
(
path
temp
)
;
}
;
GeckoDriver
.
prototype
.
uninstallAddon
=
function
(
cmd
)
{
assert
.
firefox
(
)
;
let
id
=
cmd
.
parameters
.
id
;
if
(
typeof
id
=
=
"
undefined
"
|
|
typeof
id
!
=
"
string
"
)
{
throw
new
error
.
InvalidArgumentError
(
)
;
}
return
Addon
.
uninstall
(
id
)
;
}
;
GeckoDriver
.
prototype
.
receiveMessage
=
function
(
message
)
{
switch
(
message
.
name
)
{
case
"
Marionette
:
switchedToFrame
"
:
this
.
contentBrowsingContext
=
BrowsingContext
.
get
(
message
.
json
.
browsingContextId
)
;
break
;
case
"
Marionette
:
Register
"
:
let
{
frameId
}
=
message
.
json
;
this
.
registerBrowser
(
frameId
message
.
target
)
;
return
{
frameId
}
;
case
"
Marionette
:
ListenersAttached
"
:
if
(
message
.
json
.
frameId
=
=
=
this
.
curBrowser
.
curFrameId
)
{
const
browsingContext
=
BrowsingContext
.
get
(
message
.
json
.
frameId
)
;
if
(
browsingContext
.
browserId
=
=
this
.
contentBrowsingContext
?
.
browserId
)
{
logger
.
trace
(
"
Detected
remoteness
change
.
New
browsing
context
:
"
+
browsingContext
.
id
)
;
this
.
contentBrowsingContext
=
browsingContext
;
}
}
break
;
}
}
;
GeckoDriver
.
prototype
.
localizeEntity
=
function
(
cmd
)
{
let
{
urls
id
}
=
cmd
.
parameters
;
if
(
!
Array
.
isArray
(
urls
)
)
{
throw
new
error
.
InvalidArgumentError
(
"
Value
of
urls
should
be
of
type
'
Array
'
"
)
;
}
if
(
typeof
id
!
=
"
string
"
)
{
throw
new
error
.
InvalidArgumentError
(
"
Value
of
id
should
be
of
type
'
string
'
"
)
;
}
return
l10n
.
localizeEntity
(
urls
id
)
;
}
;
GeckoDriver
.
prototype
.
localizeProperty
=
function
(
cmd
)
{
let
{
urls
id
}
=
cmd
.
parameters
;
if
(
!
Array
.
isArray
(
urls
)
)
{
throw
new
error
.
InvalidArgumentError
(
"
Value
of
urls
should
be
of
type
'
Array
'
"
)
;
}
if
(
typeof
id
!
=
"
string
"
)
{
throw
new
error
.
InvalidArgumentError
(
"
Value
of
id
should
be
of
type
'
string
'
"
)
;
}
return
l10n
.
localizeProperty
(
urls
id
)
;
}
;
GeckoDriver
.
prototype
.
setupReftest
=
async
function
(
cmd
)
{
if
(
this
.
_reftest
)
{
throw
new
error
.
UnsupportedOperationError
(
"
Called
reftest
:
setup
with
a
reftest
session
already
active
"
)
;
}
let
{
urlCount
=
{
}
screenshot
=
"
unexpected
"
isPrint
=
false
}
=
cmd
.
parameters
;
if
(
!
[
"
always
"
"
fail
"
"
unexpected
"
]
.
includes
(
screenshot
)
)
{
throw
new
error
.
InvalidArgumentError
(
"
Value
of
screenshot
should
be
'
always
'
'
fail
'
or
'
unexpected
'
"
)
;
}
this
.
_reftest
=
new
reftest
.
Runner
(
this
)
;
this
.
_reftest
.
setup
(
urlCount
screenshot
isPrint
)
;
}
;
GeckoDriver
.
prototype
.
runReftest
=
async
function
(
cmd
)
{
let
{
test
references
expected
timeout
width
height
pageRanges
}
=
cmd
.
parameters
;
if
(
!
this
.
_reftest
)
{
throw
new
error
.
UnsupportedOperationError
(
"
Called
reftest
:
run
before
reftest
:
start
"
)
;
}
assert
.
string
(
test
)
;
assert
.
string
(
expected
)
;
assert
.
array
(
references
)
;
return
{
value
:
await
this
.
_reftest
.
run
(
test
references
expected
timeout
pageRanges
width
height
)
}
;
}
;
GeckoDriver
.
prototype
.
teardownReftest
=
function
(
)
{
if
(
!
this
.
_reftest
)
{
throw
new
error
.
UnsupportedOperationError
(
"
Called
reftest
:
teardown
before
reftest
:
start
"
)
;
}
this
.
_reftest
.
abort
(
)
;
this
.
_reftest
=
null
;
}
;
GeckoDriver
.
prototype
.
print
=
async
function
(
cmd
)
{
assert
.
content
(
this
.
context
)
;
assert
.
open
(
this
.
getBrowsingContext
(
{
top
:
true
}
)
)
;
await
this
.
_handleUserPrompts
(
)
;
const
settings
=
print
.
addDefaultSettings
(
cmd
.
parameters
)
;
for
(
let
prop
of
[
"
top
"
"
bottom
"
"
left
"
"
right
"
]
)
{
assert
.
positiveNumber
(
settings
.
margin
[
prop
]
pprint
margin
.
{
prop
}
is
not
a
positive
number
)
;
}
for
(
let
prop
of
[
"
width
"
"
height
"
]
)
{
assert
.
positiveNumber
(
settings
.
page
[
prop
]
pprint
page
.
{
prop
}
is
not
a
positive
number
)
;
}
assert
.
positiveNumber
(
settings
.
scale
scale
{
settings
.
scale
}
is
not
a
positive
number
)
;
assert
.
that
(
s
=
>
s
>
=
print
.
minScaleValue
&
&
settings
.
scale
<
=
print
.
maxScaleValue
scale
{
settings
.
scale
}
is
outside
the
range
{
print
.
minScaleValue
}
-
{
print
.
maxScaleValue
}
)
(
settings
.
scale
)
;
assert
.
boolean
(
settings
.
shrinkToFit
)
;
assert
.
boolean
(
settings
.
landscape
)
;
assert
.
boolean
(
settings
.
printBackground
)
;
const
linkedBrowser
=
this
.
curBrowser
.
tab
.
linkedBrowser
;
const
filePath
=
await
print
.
printToFile
(
linkedBrowser
linkedBrowser
.
outerWindowID
settings
)
;
let
bytes
;
const
file
=
await
OS
.
File
.
open
(
filePath
)
;
try
{
bytes
=
await
file
.
read
(
)
;
}
finally
{
file
.
close
(
)
;
await
OS
.
File
.
remove
(
filePath
)
;
}
return
{
value
:
btoa
(
String
.
fromCharCode
.
apply
(
null
bytes
)
)
}
;
}
;
GeckoDriver
.
prototype
.
commands
=
{
"
Marionette
:
AcceptConnections
"
:
GeckoDriver
.
prototype
.
acceptConnections
"
Marionette
:
GetContext
"
:
GeckoDriver
.
prototype
.
getContext
"
Marionette
:
GetScreenOrientation
"
:
GeckoDriver
.
prototype
.
getScreenOrientation
"
Marionette
:
GetWindowType
"
:
GeckoDriver
.
prototype
.
getWindowType
"
Marionette
:
Quit
"
:
GeckoDriver
.
prototype
.
quit
"
Marionette
:
SetContext
"
:
GeckoDriver
.
prototype
.
setContext
"
Marionette
:
SetScreenOrientation
"
:
GeckoDriver
.
prototype
.
setScreenOrientation
"
Marionette
:
ActionChain
"
:
GeckoDriver
.
prototype
.
actionChain
"
Marionette
:
MultiAction
"
:
GeckoDriver
.
prototype
.
multiAction
"
Marionette
:
SingleTap
"
:
GeckoDriver
.
prototype
.
singleTap
"
Addon
:
Install
"
:
GeckoDriver
.
prototype
.
installAddon
"
Addon
:
Uninstall
"
:
GeckoDriver
.
prototype
.
uninstallAddon
"
L10n
:
LocalizeEntity
"
:
GeckoDriver
.
prototype
.
localizeEntity
"
L10n
:
LocalizeProperty
"
:
GeckoDriver
.
prototype
.
localizeProperty
"
reftest
:
setup
"
:
GeckoDriver
.
prototype
.
setupReftest
"
reftest
:
run
"
:
GeckoDriver
.
prototype
.
runReftest
"
reftest
:
teardown
"
:
GeckoDriver
.
prototype
.
teardownReftest
"
WebDriver
:
AcceptAlert
"
:
GeckoDriver
.
prototype
.
acceptDialog
"
WebDriver
:
AcceptDialog
"
:
GeckoDriver
.
prototype
.
acceptDialog
"
WebDriver
:
AddCookie
"
:
GeckoDriver
.
prototype
.
addCookie
"
WebDriver
:
Back
"
:
GeckoDriver
.
prototype
.
goBack
"
WebDriver
:
CloseChromeWindow
"
:
GeckoDriver
.
prototype
.
closeChromeWindow
"
WebDriver
:
CloseWindow
"
:
GeckoDriver
.
prototype
.
close
"
WebDriver
:
DeleteAllCookies
"
:
GeckoDriver
.
prototype
.
deleteAllCookies
"
WebDriver
:
DeleteCookie
"
:
GeckoDriver
.
prototype
.
deleteCookie
"
WebDriver
:
DeleteSession
"
:
GeckoDriver
.
prototype
.
deleteSession
"
WebDriver
:
DismissAlert
"
:
GeckoDriver
.
prototype
.
dismissDialog
"
WebDriver
:
ElementClear
"
:
GeckoDriver
.
prototype
.
clearElement
"
WebDriver
:
ElementClick
"
:
GeckoDriver
.
prototype
.
clickElement
"
WebDriver
:
ElementSendKeys
"
:
GeckoDriver
.
prototype
.
sendKeysToElement
"
WebDriver
:
ExecuteAsyncScript
"
:
GeckoDriver
.
prototype
.
executeAsyncScript
"
WebDriver
:
ExecuteScript
"
:
GeckoDriver
.
prototype
.
executeScript
"
WebDriver
:
FindElement
"
:
GeckoDriver
.
prototype
.
findElement
"
WebDriver
:
FindElements
"
:
GeckoDriver
.
prototype
.
findElements
"
WebDriver
:
Forward
"
:
GeckoDriver
.
prototype
.
goForward
"
WebDriver
:
FullscreenWindow
"
:
GeckoDriver
.
prototype
.
fullscreenWindow
"
WebDriver
:
GetActiveElement
"
:
GeckoDriver
.
prototype
.
getActiveElement
"
WebDriver
:
GetAlertText
"
:
GeckoDriver
.
prototype
.
getTextFromDialog
"
WebDriver
:
GetCapabilities
"
:
GeckoDriver
.
prototype
.
getSessionCapabilities
"
WebDriver
:
GetChromeWindowHandle
"
:
GeckoDriver
.
prototype
.
getChromeWindowHandle
"
WebDriver
:
GetChromeWindowHandles
"
:
GeckoDriver
.
prototype
.
getChromeWindowHandles
"
WebDriver
:
GetCookies
"
:
GeckoDriver
.
prototype
.
getCookies
"
WebDriver
:
GetCurrentChromeWindowHandle
"
:
GeckoDriver
.
prototype
.
getChromeWindowHandle
"
WebDriver
:
GetCurrentURL
"
:
GeckoDriver
.
prototype
.
getCurrentUrl
"
WebDriver
:
GetElementAttribute
"
:
GeckoDriver
.
prototype
.
getElementAttribute
"
WebDriver
:
GetElementCSSValue
"
:
GeckoDriver
.
prototype
.
getElementValueOfCssProperty
"
WebDriver
:
GetElementProperty
"
:
GeckoDriver
.
prototype
.
getElementProperty
"
WebDriver
:
GetElementRect
"
:
GeckoDriver
.
prototype
.
getElementRect
"
WebDriver
:
GetElementTagName
"
:
GeckoDriver
.
prototype
.
getElementTagName
"
WebDriver
:
GetElementText
"
:
GeckoDriver
.
prototype
.
getElementText
"
WebDriver
:
GetPageSource
"
:
GeckoDriver
.
prototype
.
getPageSource
"
WebDriver
:
GetTimeouts
"
:
GeckoDriver
.
prototype
.
getTimeouts
"
WebDriver
:
GetTitle
"
:
GeckoDriver
.
prototype
.
getTitle
"
WebDriver
:
GetWindowHandle
"
:
GeckoDriver
.
prototype
.
getWindowHandle
"
WebDriver
:
GetWindowHandles
"
:
GeckoDriver
.
prototype
.
getWindowHandles
"
WebDriver
:
GetWindowRect
"
:
GeckoDriver
.
prototype
.
getWindowRect
"
WebDriver
:
IsElementDisplayed
"
:
GeckoDriver
.
prototype
.
isElementDisplayed
"
WebDriver
:
IsElementEnabled
"
:
GeckoDriver
.
prototype
.
isElementEnabled
"
WebDriver
:
IsElementSelected
"
:
GeckoDriver
.
prototype
.
isElementSelected
"
WebDriver
:
MinimizeWindow
"
:
GeckoDriver
.
prototype
.
minimizeWindow
"
WebDriver
:
MaximizeWindow
"
:
GeckoDriver
.
prototype
.
maximizeWindow
"
WebDriver
:
Navigate
"
:
GeckoDriver
.
prototype
.
navigateTo
"
WebDriver
:
NewSession
"
:
GeckoDriver
.
prototype
.
newSession
"
WebDriver
:
NewWindow
"
:
GeckoDriver
.
prototype
.
newWindow
"
WebDriver
:
PerformActions
"
:
GeckoDriver
.
prototype
.
performActions
"
WebDriver
:
Print
"
:
GeckoDriver
.
prototype
.
print
"
WebDriver
:
Refresh
"
:
GeckoDriver
.
prototype
.
refresh
"
WebDriver
:
ReleaseActions
"
:
GeckoDriver
.
prototype
.
releaseActions
"
WebDriver
:
SendAlertText
"
:
GeckoDriver
.
prototype
.
sendKeysToDialog
"
WebDriver
:
SetTimeouts
"
:
GeckoDriver
.
prototype
.
setTimeouts
"
WebDriver
:
SetWindowRect
"
:
GeckoDriver
.
prototype
.
setWindowRect
"
WebDriver
:
SwitchToFrame
"
:
GeckoDriver
.
prototype
.
switchToFrame
"
WebDriver
:
SwitchToParentFrame
"
:
GeckoDriver
.
prototype
.
switchToParentFrame
"
WebDriver
:
SwitchToShadowRoot
"
:
GeckoDriver
.
prototype
.
switchToShadowRoot
"
WebDriver
:
SwitchToWindow
"
:
GeckoDriver
.
prototype
.
switchToWindow
"
WebDriver
:
TakeScreenshot
"
:
GeckoDriver
.
prototype
.
takeScreenshot
}
;
function
getWindowId
(
win
)
{
return
win
.
docShell
.
browsingContext
.
id
;
}
async
function
exitFullscreen
(
win
)
{
let
cb
;
await
new
TimedPromise
(
resolve
=
>
{
cb
=
new
DebounceCallback
(
resolve
)
;
win
.
addEventListener
(
"
sizemodechange
"
cb
)
;
win
.
fullScreen
=
false
;
}
{
throws
:
null
timeout
:
TIMEOUT_NO_WINDOW_MANAGER
}
)
;
win
.
removeEventListener
(
"
sizemodechange
"
cb
)
;
}
async
function
restoreWindow
(
win
)
{
win
.
restore
(
)
;
await
new
PollPromise
(
(
resolve
reject
)
=
>
{
if
(
WindowState
.
from
(
win
.
windowState
)
=
=
WindowState
.
Normal
)
{
resolve
(
)
;
}
else
{
reject
(
)
;
}
}
{
timeout
:
TIMEOUT_NO_WINDOW_MANAGER
}
)
;
}
