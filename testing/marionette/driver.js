"
use
strict
"
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
var
loader
=
Cc
[
"
mozilla
.
org
/
moz
/
jssubscript
-
loader
;
1
"
]
.
getService
(
Ci
.
mozIJSSubScriptLoader
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
cookieManager
"
"
mozilla
.
org
/
cookiemanager
;
1
"
"
nsICookieManager2
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
action
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
atom
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
browser
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
evaluate
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
event
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
interaction
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
logging
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
modal
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
proxy
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
simpletest
.
js
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
GeckoDriver
"
"
Context
"
]
;
var
FRAME_SCRIPT
=
"
chrome
:
/
/
marionette
/
content
/
listener
.
js
"
;
const
BROWSER_STARTUP_FINISHED
=
"
browser
-
delayed
-
startup
-
finished
"
;
const
CLICK_TO_START_PREF
=
"
marionette
.
debugging
.
clicktostart
"
;
const
CONTENT_LISTENER_PREF
=
"
marionette
.
contentListener
"
;
const
SUPPORTED_STRATEGIES
=
new
Set
(
[
element
.
Strategy
.
ClassName
element
.
Strategy
.
Selector
element
.
Strategy
.
ID
element
.
Strategy
.
TagName
element
.
Strategy
.
XPath
element
.
Strategy
.
Anon
element
.
Strategy
.
AnonAttribute
]
)
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
const
globalMessageManager
=
Cc
[
"
mozilla
.
org
/
globalmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsIMessageBroadcaster
)
;
var
systemMessageListenerReady
=
false
;
Services
.
obs
.
addObserver
(
function
(
)
{
systemMessageListenerReady
=
true
;
}
"
system
-
message
-
listener
-
ready
"
false
)
;
var
delayedBrowserStarted
=
false
;
Services
.
obs
.
addObserver
(
function
(
)
{
delayedBrowserStarted
=
true
;
}
BROWSER_STARTUP_FINISHED
false
)
;
this
.
Context
=
{
CHROME
:
"
chrome
"
CONTENT
:
"
content
"
}
;
this
.
Context
.
fromString
=
function
(
s
)
{
s
=
s
.
toUpperCase
(
)
;
if
(
s
in
this
)
{
return
this
[
s
]
;
}
return
null
;
}
;
this
.
GeckoDriver
=
function
(
appName
stopSignal
)
{
this
.
appName
=
appName
;
this
.
stopSignal_
=
stopSignal
;
this
.
sessionId
=
null
;
this
.
wins
=
new
browser
.
Windows
(
)
;
this
.
browsers
=
{
}
;
this
.
curBrowser
=
null
;
this
.
context
=
Context
.
CONTENT
;
this
.
scriptTimeout
=
null
;
this
.
searchTimeout
=
null
;
this
.
pageTimeout
=
null
;
this
.
timer
=
null
;
this
.
inactivityTimer
=
null
;
this
.
marionetteLog
=
new
logging
.
ContentLogger
(
)
;
this
.
mainFrame
=
null
;
this
.
curFrame
=
null
;
this
.
mainContentFrameId
=
null
;
this
.
importedScripts
=
new
evaluate
.
ScriptStorageService
(
[
Context
.
CHROME
Context
.
CONTENT
]
)
;
this
.
currentFrameElement
=
null
;
this
.
testName
=
null
;
this
.
mozBrowserClose
=
null
;
this
.
sandboxes
=
new
Sandboxes
(
(
)
=
>
this
.
getCurrentWindow
(
)
)
;
this
.
oopFrameId
=
null
;
this
.
observing
=
null
;
this
.
_browserIds
=
new
WeakMap
(
)
;
this
.
actions
=
new
action
.
Chain
(
)
;
this
.
sessionCapabilities
=
{
"
browserName
"
:
Services
.
appinfo
.
name
.
toLowerCase
(
)
"
browserVersion
"
:
Services
.
appinfo
.
version
"
platformName
"
:
Services
.
sysinfo
.
getProperty
(
"
name
"
)
.
toLowerCase
(
)
"
platformVersion
"
:
Services
.
sysinfo
.
getProperty
(
"
version
"
)
"
specificationLevel
"
:
0
"
raisesAccessibilityExceptions
"
:
false
"
rotatable
"
:
this
.
appName
=
=
"
B2G
"
"
acceptSslCerts
"
:
false
"
takesElementScreenshot
"
:
true
"
takesScreenshot
"
:
true
"
proxy
"
:
{
}
"
platform
"
:
Services
.
sysinfo
.
getProperty
(
"
name
"
)
.
toUpperCase
(
)
"
XULappId
"
:
Services
.
appinfo
.
ID
"
appBuildId
"
:
Services
.
appinfo
.
appBuildID
"
processId
"
:
Services
.
appinfo
.
processID
"
version
"
:
Services
.
appinfo
.
version
}
;
this
.
mm
=
globalMessageManager
;
this
.
listener
=
proxy
.
toListener
(
(
)
=
>
this
.
mm
this
.
sendAsync
.
bind
(
this
)
)
;
this
.
dialog
=
null
;
let
handleDialog
=
(
subject
topic
)
=
>
{
let
winr
;
if
(
topic
=
=
modal
.
COMMON_DIALOG_LOADED
)
{
winr
=
Cu
.
getWeakReference
(
subject
)
;
}
this
.
dialog
=
new
modal
.
Dialog
(
(
)
=
>
this
.
curBrowser
winr
)
;
}
;
modal
.
addHandler
(
handleDialog
)
;
}
;
GeckoDriver
.
prototype
.
QueryInterface
=
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIMessageListener
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
;
GeckoDriver
.
prototype
.
switchToGlobalMessageManager
=
function
(
)
{
if
(
this
.
curBrowser
&
&
this
.
curBrowser
.
frameManager
.
currentRemoteFrame
!
=
=
null
)
{
this
.
curBrowser
.
frameManager
.
removeMessageManagerListeners
(
this
.
mm
)
;
this
.
sendAsync
(
"
sleepSession
"
)
;
this
.
curBrowser
.
frameManager
.
currentRemoteFrame
=
null
;
}
this
.
mm
=
globalMessageManager
;
}
;
GeckoDriver
.
prototype
.
sendAsync
=
function
(
name
msg
cmdId
)
{
let
curRemoteFrame
=
this
.
curBrowser
.
frameManager
.
currentRemoteFrame
;
name
=
"
Marionette
:
"
+
name
;
if
(
cmdId
)
{
msg
.
command_id
=
cmdId
;
}
if
(
curRemoteFrame
=
=
=
null
)
{
this
.
curBrowser
.
executeWhenReady
(
(
)
=
>
{
if
(
this
.
curBrowser
.
curFrameId
)
{
this
.
mm
.
broadcastAsyncMessage
(
name
+
this
.
curBrowser
.
curFrameId
msg
)
;
}
else
{
throw
new
NoSuchWindowError
(
"
No
such
content
frame
;
perhaps
the
listener
was
not
registered
?
"
)
;
}
}
)
;
}
else
{
let
remoteFrameId
=
curRemoteFrame
.
targetFrameId
;
try
{
this
.
mm
.
sendAsyncMessage
(
name
+
remoteFrameId
msg
)
;
}
catch
(
e
)
{
switch
(
e
.
result
)
{
case
Cr
.
NS_ERROR_FAILURE
:
case
Cr
.
NS_ERROR_NOT_INITIALIZED
:
throw
new
NoSuchWindowError
(
)
;
default
:
throw
new
WebDriverError
(
e
.
toString
(
)
)
;
}
}
}
}
;
GeckoDriver
.
prototype
.
getCurrentWindow
=
function
(
)
{
let
typ
=
null
;
if
(
this
.
curFrame
=
=
=
null
)
{
if
(
this
.
curBrowser
=
=
=
null
)
{
if
(
this
.
context
=
=
Context
.
CONTENT
)
{
typ
=
"
navigator
:
browser
"
;
}
return
Services
.
wm
.
getMostRecentWindow
(
typ
)
;
}
else
{
return
this
.
curBrowser
.
window
;
}
}
else
{
return
this
.
curFrame
;
}
}
;
GeckoDriver
.
prototype
.
addFrameCloseListener
=
function
(
action
)
{
let
win
=
this
.
getCurrentWindow
(
)
;
this
.
mozBrowserClose
=
e
=
>
{
if
(
e
.
target
.
id
=
=
this
.
oopFrameId
)
{
win
.
removeEventListener
(
"
mozbrowserclose
"
this
.
mozBrowserClose
true
)
;
this
.
switchToGlobalMessageManager
(
)
;
throw
new
NoSuchWindowError
(
"
The
window
closed
during
action
:
"
+
action
)
;
}
}
;
win
.
addEventListener
(
"
mozbrowserclose
"
this
.
mozBrowserClose
true
)
;
}
;
GeckoDriver
.
prototype
.
addBrowser
=
function
(
win
)
{
let
bc
=
new
browser
.
Context
(
win
this
)
;
let
winId
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
winId
=
winId
+
(
(
this
.
appName
=
=
"
B2G
"
)
?
"
-
b2g
"
:
"
"
)
;
this
.
browsers
[
winId
]
=
bc
;
this
.
curBrowser
=
this
.
browsers
[
winId
]
;
if
(
!
this
.
wins
.
has
(
winId
)
)
{
this
.
wins
.
set
(
winId
win
)
;
}
}
;
GeckoDriver
.
prototype
.
startBrowser
=
function
(
win
isNewSession
=
false
)
{
this
.
mainFrame
=
win
;
this
.
curFrame
=
null
;
this
.
addBrowser
(
win
)
;
this
.
curBrowser
.
isNewSession
=
isNewSession
;
this
.
curBrowser
.
startSession
(
isNewSession
win
this
.
whenBrowserStarted
.
bind
(
this
)
)
;
}
;
GeckoDriver
.
prototype
.
whenBrowserStarted
=
function
(
win
isNewSession
)
{
let
mm
=
win
.
window
.
messageManager
;
if
(
mm
)
{
if
(
!
isNewSession
)
{
if
(
mm
.
childCount
!
=
=
0
)
{
this
.
curBrowser
.
frameRegsPending
=
0
;
for
(
let
i
=
0
;
i
<
mm
.
childCount
;
i
+
+
)
{
if
(
mm
.
getChildAt
(
i
)
.
childCount
!
=
=
0
)
this
.
curBrowser
.
frameRegsPending
+
=
1
;
}
}
}
if
(
!
Preferences
.
get
(
CONTENT_LISTENER_PREF
)
|
|
!
isNewSession
)
{
mm
.
loadFrameScript
(
FRAME_SCRIPT
true
)
;
Preferences
.
set
(
CONTENT_LISTENER_PREF
true
)
;
}
}
else
{
logger
.
error
(
Could
not
load
listener
into
content
for
page
{
win
.
location
.
href
}
)
;
}
}
;
GeckoDriver
.
prototype
.
getVisibleText
=
function
(
el
lines
)
{
try
{
if
(
atom
.
isElementDisplayed
(
el
this
.
getCurrentWindow
(
)
)
)
{
if
(
el
.
value
)
{
lines
.
push
(
el
.
value
)
;
}
for
(
let
child
in
el
.
childNodes
)
{
this
.
getVisibleText
(
el
.
childNodes
[
child
]
lines
)
;
}
}
}
catch
(
e
)
{
if
(
el
.
nodeName
=
=
"
#
text
"
)
{
lines
.
push
(
el
.
textContent
)
;
}
}
}
;
GeckoDriver
.
prototype
.
registerBrowser
=
function
(
id
be
)
{
let
nullPrevious
=
this
.
curBrowser
.
curFrameId
=
=
=
null
;
let
listenerWindow
=
Services
.
wm
.
getOuterWindowWithId
(
id
)
;
if
(
this
.
curBrowser
.
frameManager
.
currentRemoteFrame
!
=
=
null
&
&
(
!
listenerWindow
|
|
this
.
mm
=
=
this
.
curBrowser
.
frameManager
.
currentRemoteFrame
.
messageManager
.
get
(
)
)
)
{
this
.
curBrowser
.
frameManager
.
currentRemoteFrame
.
targetFrameId
=
this
.
generateFrameId
(
id
)
;
}
let
reg
=
{
}
;
let
mainContent
=
this
.
curBrowser
.
mainContentId
=
=
=
null
;
if
(
be
.
getAttribute
(
"
type
"
)
!
=
"
content
"
)
{
let
uid
=
this
.
generateFrameId
(
id
)
;
reg
.
id
=
uid
;
reg
.
remotenessChange
=
this
.
curBrowser
.
register
(
uid
be
)
;
}
mainContent
=
mainContent
&
&
this
.
curBrowser
.
mainContentId
!
=
=
null
;
if
(
mainContent
)
{
this
.
mainContentFrameId
=
this
.
curBrowser
.
curFrameId
;
}
this
.
wins
.
set
(
reg
.
id
listenerWindow
)
;
if
(
nullPrevious
&
&
(
this
.
curBrowser
.
curFrameId
!
=
=
null
)
)
{
this
.
sendAsync
(
"
newSession
"
this
.
sessionCapabilities
this
.
newSessionCommandId
)
;
if
(
this
.
curBrowser
.
isNewSession
)
{
this
.
newSessionCommandId
=
null
;
}
}
return
[
reg
mainContent
this
.
sessionCapabilities
]
;
}
;
GeckoDriver
.
prototype
.
registerPromise
=
function
(
)
{
const
li
=
"
Marionette
:
register
"
;
return
new
Promise
(
(
resolve
)
=
>
{
let
cb
=
(
msg
)
=
>
{
let
wid
=
msg
.
json
.
value
;
let
be
=
msg
.
target
;
let
rv
=
this
.
registerBrowser
(
wid
be
)
;
if
(
this
.
curBrowser
.
frameRegsPending
>
0
)
{
this
.
curBrowser
.
frameRegsPending
-
-
;
}
if
(
this
.
curBrowser
.
frameRegsPending
=
=
=
0
)
{
this
.
mm
.
removeMessageListener
(
li
cb
)
;
resolve
(
)
;
}
return
rv
;
}
;
this
.
mm
.
addMessageListener
(
li
cb
)
;
}
)
;
}
;
GeckoDriver
.
prototype
.
listeningPromise
=
function
(
)
{
const
li
=
"
Marionette
:
listenersAttached
"
;
return
new
Promise
(
(
resolve
)
=
>
{
let
cb
=
(
)
=
>
{
this
.
mm
.
removeMessageListener
(
li
cb
)
;
resolve
(
)
;
}
;
this
.
mm
.
addMessageListener
(
li
cb
)
;
}
)
;
}
;
GeckoDriver
.
prototype
.
newSession
=
function
*
(
cmd
resp
)
{
if
(
this
.
sessionId
)
{
throw
new
SessionNotCreatedError
(
"
Maximum
number
of
active
sessions
.
"
)
}
this
.
sessionId
=
cmd
.
parameters
.
sessionId
|
|
cmd
.
parameters
.
session_id
|
|
element
.
generateUUID
(
)
;
this
.
newSessionCommandId
=
cmd
.
id
;
this
.
setSessionCapabilities
(
cmd
.
parameters
.
capabilities
)
;
this
.
scriptTimeout
=
10000
;
let
registerBrowsers
=
this
.
registerPromise
(
)
;
let
browserListening
=
this
.
listeningPromise
(
)
;
let
waitForWindow
=
function
(
)
{
let
win
=
this
.
getCurrentWindow
(
)
;
if
(
!
win
)
{
let
checkTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
checkTimer
.
initWithCallback
(
waitForWindow
.
bind
(
this
)
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
if
(
win
.
document
.
readyState
!
=
"
complete
"
)
{
let
listener
=
ev
=
>
{
if
(
ev
.
target
!
=
win
.
document
)
{
return
;
}
win
.
removeEventListener
(
"
load
"
listener
)
;
waitForWindow
.
call
(
this
)
;
}
;
win
.
addEventListener
(
"
load
"
listener
true
)
;
}
else
{
let
clickToStart
=
Preferences
.
get
(
CLICK_TO_START_PREF
)
;
if
(
clickToStart
&
&
(
this
.
appName
!
=
"
B2G
"
)
)
{
let
pService
=
Cc
[
"
mozilla
.
org
/
embedcomp
/
prompt
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPromptService
)
;
pService
.
alert
(
win
"
"
"
Click
to
start
execution
of
marionette
tests
"
)
;
}
this
.
startBrowser
(
win
true
)
;
}
}
;
let
runSessionStart
=
function
(
)
{
if
(
!
Preferences
.
get
(
CONTENT_LISTENER_PREF
)
)
{
waitForWindow
.
call
(
this
)
;
}
else
if
(
this
.
appName
!
=
"
Firefox
"
&
&
this
.
curBrowser
=
=
=
null
)
{
this
.
addBrowser
(
this
.
getCurrentWindow
(
)
)
;
this
.
curBrowser
.
startSession
(
this
.
whenBrowserStarted
.
bind
(
this
)
)
;
this
.
mm
.
broadcastAsyncMessage
(
"
Marionette
:
restart
"
{
}
)
;
}
else
{
throw
new
WebDriverError
(
"
Session
already
running
"
)
;
}
this
.
switchToGlobalMessageManager
(
)
;
}
;
if
(
!
delayedBrowserStarted
&
&
this
.
appName
!
=
"
B2G
"
)
{
let
self
=
this
;
Services
.
obs
.
addObserver
(
function
onStart
(
)
{
Services
.
obs
.
removeObserver
(
onStart
BROWSER_STARTUP_FINISHED
)
;
runSessionStart
.
call
(
self
)
;
}
BROWSER_STARTUP_FINISHED
false
)
;
}
else
{
runSessionStart
.
call
(
this
)
;
}
yield
registerBrowsers
;
yield
browserListening
;
resp
.
body
.
sessionId
=
this
.
sessionId
;
resp
.
body
.
capabilities
=
this
.
sessionCapabilities
;
}
;
GeckoDriver
.
prototype
.
getSessionCapabilities
=
function
(
cmd
resp
)
{
resp
.
body
.
capabilities
=
this
.
sessionCapabilities
;
}
;
GeckoDriver
.
prototype
.
setSessionCapabilities
=
function
(
newCaps
)
{
const
copy
=
(
from
to
=
{
}
)
=
>
{
let
errors
=
[
]
;
if
(
from
!
=
=
null
&
&
from
.
desiredCapabilities
)
{
for
(
let
cap
in
from
.
requiredCapabilities
)
{
if
(
from
.
desiredCapabilities
[
cap
]
)
{
delete
from
.
desiredCapabilities
[
cap
]
;
}
}
for
(
let
cap
in
this
.
sessionCapabilities
)
{
if
(
from
.
desiredCapabilities
&
&
from
.
desiredCapabilities
[
cap
]
)
{
delete
from
.
desiredCapabilities
[
cap
]
;
}
}
}
for
(
let
key
in
from
)
{
switch
(
key
)
{
case
"
desiredCapabilities
"
:
to
=
copy
(
from
[
key
]
to
)
;
break
;
case
"
requiredCapabilities
"
:
if
(
from
[
key
]
.
proxy
)
{
this
.
setUpProxy
(
from
[
key
]
.
proxy
)
;
to
.
proxy
=
from
[
key
]
.
proxy
;
delete
from
[
key
]
.
proxy
;
}
for
(
let
caps
in
from
[
key
]
)
{
if
(
from
[
key
]
[
caps
]
!
=
=
this
.
sessionCapabilities
[
caps
]
)
{
errors
.
push
(
from
[
key
]
[
caps
]
+
"
does
not
equal
"
+
this
.
sessionCapabilities
[
caps
]
)
;
}
}
break
;
default
:
to
[
key
]
=
from
[
key
]
;
}
}
if
(
Object
.
keys
(
errors
)
.
length
=
=
0
)
{
return
to
;
}
throw
new
SessionNotCreatedError
(
Not
all
requiredCapabilities
could
be
met
:
{
JSON
.
stringify
(
errors
)
}
)
;
}
;
let
caps
=
copy
(
this
.
sessionCapabilities
)
;
caps
=
copy
(
newCaps
caps
)
;
logger
.
config
(
"
Changing
capabilities
:
"
+
JSON
.
stringify
(
caps
)
)
;
this
.
sessionCapabilities
=
caps
;
}
;
GeckoDriver
.
prototype
.
setUpProxy
=
function
(
proxy
)
{
logger
.
config
(
"
User
-
provided
proxy
settings
:
"
+
JSON
.
stringify
(
proxy
)
)
;
if
(
typeof
proxy
=
=
"
object
"
&
&
proxy
.
hasOwnProperty
(
"
proxyType
"
)
)
{
switch
(
proxy
.
proxyType
.
toUpperCase
(
)
)
{
case
"
MANUAL
"
:
Preferences
.
set
(
"
network
.
proxy
.
type
"
1
)
;
if
(
proxy
.
httpProxy
&
&
proxy
.
httpProxyPort
)
{
Preferences
.
set
(
"
network
.
proxy
.
http
"
proxy
.
httpProxy
)
;
Preferences
.
set
(
"
network
.
proxy
.
http_port
"
proxy
.
httpProxyPort
)
;
}
if
(
proxy
.
sslProxy
&
&
proxy
.
sslProxyPort
)
{
Preferences
.
set
(
"
network
.
proxy
.
ssl
"
proxy
.
sslProxy
)
;
Preferences
.
set
(
"
network
.
proxy
.
ssl_port
"
proxy
.
sslProxyPort
)
;
}
if
(
proxy
.
ftpProxy
&
&
proxy
.
ftpProxyPort
)
{
Preferences
.
set
(
"
network
.
proxy
.
ftp
"
proxy
.
ftpProxy
)
;
Preferences
.
set
(
"
network
.
proxy
.
ftp_port
"
proxy
.
ftpProxyPort
)
;
}
if
(
proxy
.
socksProxy
)
{
Preferences
.
set
(
"
network
.
proxy
.
socks
"
proxy
.
socksProxy
)
;
Preferences
.
set
(
"
network
.
proxy
.
socks_port
"
proxy
.
socksProxyPort
)
;
if
(
proxy
.
socksVersion
)
{
Preferences
.
set
(
"
network
.
proxy
.
socks_version
"
proxy
.
socksVersion
)
;
}
}
break
;
case
"
PAC
"
:
Preferences
.
set
(
"
network
.
proxy
.
type
"
2
)
;
Preferences
.
set
(
"
network
.
proxy
.
autoconfig_url
"
proxy
.
proxyAutoconfigUrl
)
;
break
;
case
"
AUTODETECT
"
:
Preferences
.
set
(
"
network
.
proxy
.
type
"
4
)
;
break
;
case
"
SYSTEM
"
:
Preferences
.
set
(
"
network
.
proxy
.
type
"
5
)
;
break
;
case
"
NOPROXY
"
:
default
:
Preferences
.
set
(
"
network
.
proxy
.
type
"
0
)
;
break
;
}
}
else
{
throw
new
InvalidArgumentError
(
"
Value
of
'
proxy
'
should
be
an
object
"
)
;
}
}
;
GeckoDriver
.
prototype
.
log
=
function
(
cmd
resp
)
{
this
.
marionetteLog
.
log
(
cmd
.
parameters
.
value
cmd
.
parameters
.
level
|
|
undefined
)
;
}
;
GeckoDriver
.
prototype
.
getLogs
=
function
(
cmd
resp
)
{
resp
.
body
=
this
.
marionetteLog
.
get
(
)
;
}
;
GeckoDriver
.
prototype
.
setContext
=
function
(
cmd
resp
)
{
let
val
=
cmd
.
parameters
.
value
;
let
ctx
=
Context
.
fromString
(
val
)
;
if
(
ctx
=
=
=
null
)
{
throw
new
WebDriverError
(
Invalid
context
:
{
val
}
)
;
}
this
.
context
=
ctx
;
}
;
GeckoDriver
.
prototype
.
getContext
=
function
(
cmd
resp
)
{
resp
.
body
.
value
=
this
.
context
.
toString
(
)
;
}
;
GeckoDriver
.
prototype
.
executeScript
=
function
*
(
cmd
resp
)
{
let
{
script
args
scriptTimeout
}
=
cmd
.
parameters
;
scriptTimeout
=
scriptTimeout
|
|
this
.
scriptTimeout
;
let
opts
=
{
sandboxName
:
cmd
.
parameters
.
sandbox
newSandbox
:
!
!
(
typeof
cmd
.
parameters
.
newSandbox
=
=
"
undefined
"
)
|
|
cmd
.
parameters
.
newSandbox
filename
:
cmd
.
parameters
.
filename
line
:
cmd
.
parameters
.
line
debug
:
cmd
.
parameters
.
debug_script
}
;
resp
.
body
.
value
=
yield
this
.
execute_
(
script
args
scriptTimeout
opts
)
;
}
;
GeckoDriver
.
prototype
.
executeAsyncScript
=
function
(
cmd
resp
)
{
let
{
script
args
scriptTimeout
}
=
cmd
.
parameters
;
scriptTimeout
=
scriptTimeout
|
|
this
.
scriptTimeout
;
let
opts
=
{
sandboxName
:
cmd
.
parameters
.
sandbox
newSandbox
:
!
!
(
typeof
cmd
.
parameters
.
newSandbox
=
=
"
undefined
"
)
|
|
cmd
.
parameters
.
newSandbox
filename
:
cmd
.
parameters
.
filename
line
:
cmd
.
parameters
.
line
debug
:
cmd
.
parameters
.
debug_script
async
:
true
}
;
resp
.
body
.
value
=
yield
this
.
execute_
(
script
args
scriptTimeout
opts
)
;
}
;
GeckoDriver
.
prototype
.
execute_
=
function
(
script
args
timeout
opts
=
{
}
)
{
switch
(
this
.
context
)
{
case
Context
.
CONTENT
:
if
(
!
opts
.
sandboxName
)
{
return
this
.
listener
.
execute
(
script
args
timeout
opts
)
;
}
else
{
return
this
.
listener
.
executeInSandbox
(
script
args
timeout
opts
)
;
}
case
Context
.
CHROME
:
let
sb
=
this
.
sandboxes
.
get
(
opts
.
sandboxName
opts
.
newSandbox
)
;
if
(
opts
.
sandboxName
)
{
sb
=
sandbox
.
augment
(
sb
new
logging
.
Adapter
(
this
.
marionetteLog
)
)
;
sb
=
sandbox
.
augment
(
sb
{
global
:
sb
}
)
;
}
opts
.
timeout
=
timeout
;
script
=
this
.
importedScripts
.
for
(
Context
.
CHROME
)
.
concat
(
script
)
;
let
wargs
=
element
.
fromJson
(
args
this
.
curBrowser
.
seenEls
sb
.
window
)
;
let
evaluatePromise
=
evaluate
.
sandbox
(
sb
script
wargs
opts
)
;
return
evaluatePromise
.
then
(
res
=
>
element
.
toJson
(
res
this
.
curBrowser
.
seenEls
)
)
;
}
}
;
GeckoDriver
.
prototype
.
executeJSScript
=
function
(
cmd
resp
)
{
let
{
script
args
scriptTimeout
}
=
cmd
.
parameters
;
scriptTimeout
=
scriptTimeout
|
|
this
.
scriptTimeout
;
let
opts
=
{
filename
:
cmd
.
parameters
.
filename
line
:
cmd
.
parameters
.
line
async
:
cmd
.
parameters
.
async
}
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
wargs
=
element
.
fromJson
(
args
this
.
curBrowser
.
seenEls
win
)
;
let
harness
=
new
simpletest
.
Harness
(
win
Context
.
CHROME
this
.
marionetteLog
scriptTimeout
function
(
)
{
}
this
.
testName
)
;
let
sb
=
sandbox
.
createSimpleTest
(
win
harness
)
;
sb
=
sandbox
.
augment
(
sb
new
logging
.
Adapter
(
this
.
marionetteLog
)
)
;
let
res
=
yield
evaluate
.
sandbox
(
sb
script
wargs
opts
)
;
resp
.
body
.
value
=
element
.
toJson
(
res
this
.
curBrowser
.
seenEls
)
;
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
yield
this
.
listener
.
executeSimpleTest
(
script
args
scriptTimeout
opts
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
setScriptTimeout
=
function
(
cmd
resp
)
{
let
ms
=
parseInt
(
cmd
.
parameters
.
ms
)
;
if
(
isNaN
(
ms
)
)
{
throw
new
WebDriverError
(
"
Not
a
Number
"
)
;
}
this
.
scriptTimeout
=
ms
;
}
;
GeckoDriver
.
prototype
.
get
=
function
*
(
cmd
resp
)
{
let
url
=
cmd
.
parameters
.
url
;
switch
(
this
.
context
)
{
case
Context
.
CONTENT
:
let
get
=
this
.
listener
.
get
(
{
url
:
url
pageTimeout
:
this
.
pageTimeout
}
)
;
let
id
=
this
.
listener
.
activeMessageId
;
this
.
curBrowser
.
pendingCommands
.
push
(
(
)
=
>
{
cmd
.
parameters
.
command_id
=
id
;
this
.
mm
.
broadcastAsyncMessage
(
"
Marionette
:
pollForReadyState
"
+
this
.
curBrowser
.
curFrameId
cmd
.
parameters
)
;
}
)
;
yield
get
;
break
;
case
Context
.
CHROME
:
if
(
this
.
appName
=
=
"
Firefox
"
)
{
throw
new
UnknownError
(
"
Cannot
navigate
in
chrome
context
"
)
;
}
this
.
getCurrentWindow
(
)
.
location
.
href
=
url
;
yield
this
.
pageLoadPromise
(
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
pageLoadPromise
=
function
(
)
{
let
win
=
this
.
getCurrentWindow
(
)
;
let
timeout
=
this
.
pageTimeout
;
let
checkTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
let
start
=
new
Date
(
)
.
getTime
(
)
;
let
end
=
null
;
return
new
Promise
(
(
resolve
)
=
>
{
let
checkLoad
=
function
(
)
{
end
=
new
Date
(
)
.
getTime
(
)
;
let
elapse
=
end
-
start
;
if
(
timeout
=
=
=
null
|
|
elapse
<
=
timeout
)
{
if
(
win
.
document
.
readyState
=
=
"
complete
"
)
{
resolve
(
)
;
}
else
{
checkTimer
.
initWithCallback
(
checkLoad
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
}
else
{
throw
new
UnknownError
(
"
Error
loading
page
"
)
;
}
}
;
checkTimer
.
initWithCallback
(
checkLoad
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
)
;
}
;
GeckoDriver
.
prototype
.
getCurrentUrl
=
function
(
cmd
)
{
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
return
this
.
getCurrentWindow
(
)
.
location
.
href
;
case
Context
.
CONTENT
:
let
isB2G
=
this
.
appName
=
=
"
B2G
"
;
return
this
.
listener
.
getCurrentUrl
(
isB2G
)
;
}
}
;
GeckoDriver
.
prototype
.
getTitle
=
function
*
(
cmd
resp
)
{
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
resp
.
body
.
value
=
win
.
document
.
documentElement
.
getAttribute
(
"
title
"
)
;
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
yield
this
.
listener
.
getTitle
(
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
getWindowType
=
function
(
cmd
resp
)
{
let
win
=
this
.
getCurrentWindow
(
)
;
resp
.
body
.
value
=
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
}
;
GeckoDriver
.
prototype
.
getPageSource
=
function
*
(
cmd
resp
)
{
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
s
=
new
win
.
XMLSerializer
(
)
;
resp
.
body
.
value
=
s
.
serializeToString
(
win
.
document
)
;
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
yield
this
.
listener
.
getPageSource
(
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
goBack
=
function
*
(
cmd
resp
)
{
yield
this
.
listener
.
goBack
(
)
;
}
;
GeckoDriver
.
prototype
.
goForward
=
function
*
(
cmd
resp
)
{
yield
this
.
listener
.
goForward
(
)
;
}
;
GeckoDriver
.
prototype
.
refresh
=
function
*
(
cmd
resp
)
{
yield
this
.
listener
.
refresh
(
)
;
}
;
GeckoDriver
.
prototype
.
getWindowHandle
=
function
(
cmd
resp
)
{
if
(
this
.
curBrowser
.
curFrameId
&
&
this
.
appName
!
=
"
B2G
"
)
{
resp
.
body
.
value
=
this
.
curBrowser
.
curFrameId
;
return
;
}
for
(
let
i
in
this
.
browsers
)
{
if
(
this
.
curBrowser
=
=
this
.
browsers
[
i
]
)
{
resp
.
body
.
value
=
i
;
return
;
}
}
}
;
GeckoDriver
.
prototype
.
updateIdForBrowser
=
function
(
browser
newId
)
{
this
.
_browserIds
.
set
(
browser
.
permanentKey
newId
)
;
}
;
GeckoDriver
.
prototype
.
getIdForBrowser
=
function
getIdForBrowser
(
browser
)
{
if
(
browser
=
=
=
null
)
{
return
null
;
}
let
permKey
=
browser
.
permanentKey
;
if
(
this
.
_browserIds
.
has
(
permKey
)
)
{
return
this
.
_browserIds
.
get
(
permKey
)
;
}
let
winId
=
browser
.
outerWindowID
;
if
(
winId
)
{
winId
+
=
"
"
;
this
.
_browserIds
.
set
(
permKey
winId
)
;
return
winId
;
}
return
null
;
}
GeckoDriver
.
prototype
.
getWindowHandles
=
function
(
cmd
resp
)
{
let
hs
=
[
]
;
let
winEn
=
Services
.
wm
.
getEnumerator
(
null
)
;
while
(
winEn
.
hasMoreElements
(
)
)
{
let
win
=
winEn
.
getNext
(
)
;
if
(
win
.
gBrowser
&
&
this
.
appName
!
=
"
B2G
"
)
{
let
tabbrowser
=
win
.
gBrowser
;
for
(
let
i
=
0
;
i
<
tabbrowser
.
browsers
.
length
;
+
+
i
)
{
let
winId
=
this
.
getIdForBrowser
(
tabbrowser
.
getBrowserAtIndex
(
i
)
)
;
if
(
winId
!
=
=
null
)
{
hs
.
push
(
winId
)
;
}
}
}
else
{
let
winId
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
winId
+
=
(
this
.
appName
=
=
"
B2G
"
)
?
"
-
b2g
"
:
"
"
;
hs
.
push
(
winId
)
;
}
}
resp
.
body
=
hs
;
}
;
GeckoDriver
.
prototype
.
getChromeWindowHandle
=
function
(
cmd
resp
)
{
for
(
let
i
in
this
.
browsers
)
{
if
(
this
.
curBrowser
=
=
this
.
browsers
[
i
]
)
{
resp
.
body
.
value
=
i
;
return
;
}
}
}
;
GeckoDriver
.
prototype
.
getChromeWindowHandles
=
function
(
cmd
resp
)
{
let
hs
=
[
]
;
let
winEn
=
Services
.
wm
.
getEnumerator
(
null
)
;
while
(
winEn
.
hasMoreElements
(
)
)
{
let
foundWin
=
winEn
.
getNext
(
)
;
let
winId
=
foundWin
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
winId
=
winId
+
(
(
this
.
appName
=
=
"
B2G
"
)
?
"
-
b2g
"
:
"
"
)
;
hs
.
push
(
winId
)
;
}
resp
.
body
=
hs
;
}
;
GeckoDriver
.
prototype
.
getWindowPosition
=
function
(
cmd
resp
)
{
let
win
=
this
.
getCurrentWindow
(
)
;
resp
.
body
.
x
=
win
.
screenX
;
resp
.
body
.
y
=
win
.
screenY
;
}
;
GeckoDriver
.
prototype
.
setWindowPosition
=
function
(
cmd
resp
)
{
if
(
this
.
appName
!
=
"
Firefox
"
)
{
throw
new
WebDriverError
(
"
Unable
to
set
the
window
position
on
mobile
"
)
;
}
let
x
=
parseInt
(
cmd
.
parameters
.
x
)
;
let
y
=
parseInt
(
cmd
.
parameters
.
y
)
;
if
(
isNaN
(
x
)
|
|
isNaN
(
y
)
)
{
throw
new
UnknownError
(
"
x
and
y
arguments
should
be
integers
"
)
;
}
let
win
=
this
.
getCurrentWindow
(
)
;
win
.
moveTo
(
x
y
)
;
}
;
GeckoDriver
.
prototype
.
switchToWindow
=
function
*
(
cmd
resp
)
{
let
switchTo
=
cmd
.
parameters
.
name
;
let
isMobile
=
this
.
appName
=
=
"
Fennec
"
;
let
found
;
let
getOuterWindowId
=
function
(
win
)
{
let
rv
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
return
rv
;
}
;
let
byNameOrId
=
function
(
name
outerId
contentWindowId
)
{
return
switchTo
=
=
name
|
|
switchTo
=
=
contentWindowId
|
|
switchTo
=
=
outerId
;
}
;
let
winEn
=
Services
.
wm
.
getEnumerator
(
null
)
;
while
(
winEn
.
hasMoreElements
(
)
)
{
let
win
=
winEn
.
getNext
(
)
;
let
outerId
=
getOuterWindowId
(
win
)
;
if
(
win
.
gBrowser
&
&
!
isMobile
)
{
let
tabbrowser
=
win
.
gBrowser
;
for
(
let
i
=
0
;
i
<
tabbrowser
.
browsers
.
length
;
+
+
i
)
{
let
browser
=
tabbrowser
.
getBrowserAtIndex
(
i
)
;
let
contentWindowId
=
this
.
getIdForBrowser
(
browser
)
;
if
(
byNameOrId
(
win
.
name
contentWindowId
outerId
)
)
{
found
=
{
win
:
win
outerId
:
outerId
tabIndex
:
i
}
;
break
;
}
}
}
else
{
if
(
byNameOrId
(
win
.
name
outerId
)
)
{
found
=
{
win
:
win
outerId
:
outerId
}
;
break
;
}
}
}
if
(
found
)
{
if
(
!
(
found
.
outerId
in
this
.
browsers
)
)
{
let
registerBrowsers
browserListening
;
if
(
"
tabIndex
"
in
found
)
{
registerBrowsers
=
this
.
registerPromise
(
)
;
browserListening
=
this
.
listeningPromise
(
)
;
}
this
.
startBrowser
(
found
.
win
false
)
;
if
(
registerBrowsers
&
&
browserListening
)
{
yield
registerBrowsers
;
yield
browserListening
;
}
}
else
{
this
.
curBrowser
=
this
.
browsers
[
found
.
outerId
]
;
if
(
"
tabIndex
"
in
found
)
{
this
.
curBrowser
.
switchToTab
(
found
.
tabIndex
found
.
win
)
;
}
}
}
else
{
throw
new
NoSuchWindowError
(
Unable
to
locate
window
:
{
switchTo
}
)
;
}
}
;
GeckoDriver
.
prototype
.
getActiveFrame
=
function
(
cmd
resp
)
{
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
resp
.
body
.
value
=
null
;
if
(
this
.
curFrame
)
{
let
elRef
=
this
.
curBrowser
.
seenEls
.
add
(
this
.
curFrame
.
frameElement
)
;
let
el
=
element
.
makeWebElement
(
elRef
)
;
resp
.
body
.
value
=
el
;
}
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
null
;
if
(
this
.
currentFrameElement
!
=
=
null
)
{
let
el
=
element
.
makeWebElement
(
this
.
currentFrameElement
)
;
resp
.
body
.
value
=
el
;
}
break
;
}
}
;
GeckoDriver
.
prototype
.
switchToParentFrame
=
function
*
(
cmd
resp
)
{
let
res
=
yield
this
.
listener
.
switchToParentFrame
(
)
;
}
;
GeckoDriver
.
prototype
.
switchToFrame
=
function
*
(
cmd
resp
)
{
let
{
id
element
focus
}
=
cmd
.
parameters
;
let
checkTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
let
curWindow
=
this
.
getCurrentWindow
(
)
;
let
checkLoad
=
function
(
)
{
let
errorRegex
=
/
about
:
.
+
(
error
)
|
(
blocked
)
\
?
/
;
let
curWindow
=
this
.
getCurrentWindow
(
)
;
if
(
curWindow
.
document
.
readyState
=
=
"
complete
"
)
{
return
;
}
else
if
(
curWindow
.
document
.
readyState
=
=
"
interactive
"
&
&
errorRegex
.
exec
(
curWindow
.
document
.
baseURI
)
)
{
throw
new
UnknownError
(
"
Error
loading
page
"
)
;
}
checkTimer
.
initWithCallback
(
checkLoad
.
bind
(
this
)
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
;
if
(
this
.
context
=
=
Context
.
CHROME
)
{
let
foundFrame
=
null
;
if
(
typeof
id
=
=
"
undefined
"
&
&
typeof
element
=
=
"
undefined
"
)
{
this
.
curFrame
=
null
;
if
(
focus
)
{
this
.
mainFrame
.
focus
(
)
;
}
checkTimer
.
initWithCallback
(
checkLoad
.
bind
(
this
)
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
return
;
}
if
(
this
.
curBrowser
.
seenEls
.
has
(
element
)
)
{
let
wantedFrame
=
this
.
curBrowser
.
seenEls
.
get
(
element
{
frame
:
curWindow
}
)
;
if
(
wantedFrame
.
tagName
=
=
"
xul
:
browser
"
|
|
wantedFrame
.
tagName
=
=
"
browser
"
)
{
curWindow
=
wantedFrame
.
contentWindow
;
this
.
curFrame
=
curWindow
;
if
(
focus
)
{
this
.
curFrame
.
focus
(
)
;
}
checkTimer
.
initWithCallback
(
checkLoad
.
bind
(
this
)
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
return
;
}
let
parent
=
curWindow
.
document
.
getBindingParent
(
wantedFrame
)
;
if
(
parent
&
&
!
(
parent
.
shadowRoot
&
&
parent
.
shadowRoot
.
contains
(
wantedFrame
)
)
)
{
let
anonNodes
=
[
.
.
.
curWindow
.
document
.
getAnonymousNodes
(
parent
)
|
|
[
]
]
;
if
(
anonNodes
.
length
>
0
)
{
let
el
=
wantedFrame
;
while
(
el
)
{
if
(
anonNodes
.
indexOf
(
el
)
>
-
1
)
{
curWindow
=
wantedFrame
.
contentWindow
;
this
.
curFrame
=
curWindow
;
if
(
focus
)
{
this
.
curFrame
.
focus
(
)
;
}
checkTimer
.
initWithCallback
(
checkLoad
.
bind
(
this
)
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
return
;
}
el
=
el
.
parentNode
;
}
}
}
let
frames
=
curWindow
.
document
.
getElementsByTagName
(
"
iframe
"
)
;
let
numFrames
=
frames
.
length
;
for
(
let
i
=
0
;
i
<
numFrames
;
i
+
+
)
{
if
(
new
XPCNativeWrapper
(
frames
[
i
]
)
=
=
new
XPCNativeWrapper
(
wantedFrame
)
)
{
curWindow
=
frames
[
i
]
.
contentWindow
;
this
.
curFrame
=
curWindow
;
if
(
focus
)
{
this
.
curFrame
.
focus
(
)
;
}
checkTimer
.
initWithCallback
(
checkLoad
.
bind
(
this
)
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
return
;
}
}
}
switch
(
typeof
id
)
{
case
"
string
"
:
let
foundById
=
null
;
let
frames
=
curWindow
.
document
.
getElementsByTagName
(
"
iframe
"
)
;
let
numFrames
=
frames
.
length
;
for
(
let
i
=
0
;
i
<
numFrames
;
i
+
+
)
{
let
frame
=
frames
[
i
]
;
if
(
frame
.
getAttribute
(
"
name
"
)
=
=
id
)
{
foundFrame
=
i
;
curWindow
=
frame
.
contentWindow
;
break
;
}
else
if
(
foundById
=
=
=
null
&
&
frame
.
id
=
=
id
)
{
foundById
=
i
;
}
}
if
(
foundFrame
=
=
=
null
&
&
foundById
!
=
=
null
)
{
foundFrame
=
foundById
;
curWindow
=
frames
[
foundById
]
.
contentWindow
;
}
break
;
case
"
number
"
:
if
(
typeof
curWindow
.
frames
[
id
]
!
=
"
undefined
"
)
{
foundFrame
=
id
;
curWindow
=
curWindow
.
frames
[
foundFrame
]
.
frameElement
.
contentWindow
;
}
break
;
}
if
(
foundFrame
!
=
=
null
)
{
this
.
curFrame
=
curWindow
;
if
(
focus
)
{
this
.
curFrame
.
focus
(
)
;
}
checkTimer
.
initWithCallback
(
checkLoad
.
bind
(
this
)
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
{
throw
new
NoSuchFrameError
(
Unable
to
locate
frame
:
{
id
}
)
;
}
}
else
if
(
this
.
context
=
=
Context
.
CONTENT
)
{
if
(
!
id
&
&
!
element
&
&
this
.
curBrowser
.
frameManager
.
currentRemoteFrame
!
=
=
null
)
{
this
.
switchToGlobalMessageManager
(
)
;
}
cmd
.
command_id
=
cmd
.
id
;
let
res
=
yield
this
.
listener
.
switchToFrame
(
cmd
.
parameters
)
;
if
(
res
)
{
let
{
win
:
winId
frame
:
frameId
}
=
res
;
this
.
mm
=
this
.
curBrowser
.
frameManager
.
getFrameMM
(
winId
frameId
)
;
let
registerBrowsers
=
this
.
registerPromise
(
)
;
let
browserListening
=
this
.
listeningPromise
(
)
;
this
.
oopFrameId
=
this
.
curBrowser
.
frameManager
.
switchToFrame
(
winId
frameId
)
;
yield
registerBrowsers
;
yield
browserListening
;
}
}
}
;
GeckoDriver
.
prototype
.
setSearchTimeout
=
function
(
cmd
resp
)
{
let
ms
=
parseInt
(
cmd
.
parameters
.
ms
)
;
if
(
isNaN
(
ms
)
)
{
throw
new
WebDriverError
(
"
Not
a
Number
"
)
;
}
this
.
searchTimeout
=
ms
;
}
;
GeckoDriver
.
prototype
.
timeouts
=
function
(
cmd
resp
)
{
let
typ
=
cmd
.
parameters
.
type
;
let
ms
=
parseInt
(
cmd
.
parameters
.
ms
)
;
if
(
isNaN
(
ms
)
)
{
throw
new
WebDriverError
(
"
Not
a
Number
"
)
;
}
switch
(
typ
)
{
case
"
implicit
"
:
this
.
setSearchTimeout
(
cmd
resp
)
;
break
;
case
"
script
"
:
this
.
setScriptTimeout
(
cmd
resp
)
;
break
;
default
:
this
.
pageTimeout
=
ms
;
break
;
}
}
;
GeckoDriver
.
prototype
.
singleTap
=
function
*
(
cmd
resp
)
{
let
{
id
x
y
}
=
cmd
.
parameters
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
throw
new
WebDriverError
(
"
Command
'
singleTap
'
is
not
available
in
chrome
context
"
)
;
case
Context
.
CONTENT
:
this
.
addFrameCloseListener
(
"
tap
"
)
;
yield
this
.
listener
.
singleTap
(
id
x
y
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
actionChain
=
function
*
(
cmd
resp
)
{
let
{
chain
nextId
}
=
cmd
.
parameters
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
if
(
this
.
appName
!
=
"
Firefox
"
)
{
throw
new
WebDriverError
(
"
Command
'
actionChain
'
is
not
available
in
chrome
context
"
)
;
}
let
win
=
this
.
getCurrentWindow
(
)
;
resp
.
body
.
value
=
yield
this
.
actions
.
dispatchActions
(
chain
nextId
{
frame
:
win
}
this
.
curBrowser
.
seenEls
)
;
break
;
case
Context
.
CONTENT
:
this
.
addFrameCloseListener
(
"
action
chain
"
)
;
resp
.
body
.
value
=
yield
this
.
listener
.
actionChain
(
chain
nextId
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
multiAction
=
function
*
(
cmd
resp
)
{
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
throw
new
WebDriverError
(
"
Command
'
multiAction
'
is
not
available
in
chrome
context
"
)
;
case
Context
.
CONTENT
:
this
.
addFrameCloseListener
(
"
multi
action
chain
"
)
;
yield
this
.
listener
.
multiAction
(
cmd
.
parameters
.
value
cmd
.
parameters
.
max_length
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
findElement
=
function
*
(
cmd
resp
)
{
let
strategy
=
cmd
.
parameters
.
using
;
let
expr
=
cmd
.
parameters
.
value
;
let
opts
=
{
startNode
:
cmd
.
parameters
.
element
timeout
:
this
.
searchTimeout
all
:
false
}
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
if
(
!
SUPPORTED_STRATEGIES
.
has
(
strategy
)
)
{
throw
new
InvalidSelectorError
(
Strategy
not
supported
:
{
strategy
}
)
;
}
let
container
=
{
frame
:
this
.
getCurrentWindow
(
)
}
;
if
(
opts
.
startNode
)
{
opts
.
startNode
=
this
.
curBrowser
.
seenEls
.
get
(
opts
.
startNode
container
)
;
}
let
el
=
yield
element
.
find
(
container
strategy
expr
opts
)
;
let
elRef
=
this
.
curBrowser
.
seenEls
.
add
(
el
)
;
let
webEl
=
element
.
makeWebElement
(
elRef
)
;
resp
.
body
.
value
=
webEl
;
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
yield
this
.
listener
.
findElementContent
(
strategy
expr
opts
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
findElements
=
function
*
(
cmd
resp
)
{
let
strategy
=
cmd
.
parameters
.
using
;
let
expr
=
cmd
.
parameters
.
value
;
let
opts
=
{
startNode
:
cmd
.
parameters
.
element
timeout
:
this
.
searchTimeout
all
:
true
}
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
if
(
!
SUPPORTED_STRATEGIES
.
has
(
strategy
)
)
{
throw
new
InvalidSelectorError
(
Strategy
not
supported
:
{
strategy
}
)
;
}
let
container
=
{
frame
:
this
.
getCurrentWindow
(
)
}
;
if
(
opts
.
startNode
)
{
opts
.
startNode
=
this
.
curBrowser
.
seenEls
.
get
(
opts
.
startNode
container
)
;
}
let
els
=
yield
element
.
find
(
container
strategy
expr
opts
)
;
let
elRefs
=
this
.
curBrowser
.
seenEls
.
addAll
(
els
)
;
let
webEls
=
elRefs
.
map
(
element
.
makeWebElement
)
;
resp
.
body
=
webEls
;
break
;
case
Context
.
CONTENT
:
resp
.
body
=
yield
this
.
listener
.
findElementsContent
(
cmd
.
parameters
.
using
cmd
.
parameters
.
value
opts
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
getActiveElement
=
function
*
(
cmd
resp
)
{
resp
.
body
.
value
=
yield
this
.
listener
.
getActiveElement
(
)
;
}
;
GeckoDriver
.
prototype
.
clickElement
=
function
*
(
cmd
resp
)
{
let
id
=
cmd
.
parameters
.
id
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
id
{
frame
:
win
}
)
;
yield
interaction
.
clickElement
(
el
this
.
sessionCapabilities
.
raisesAccessibilityExceptions
)
;
break
;
case
Context
.
CONTENT
:
this
.
addFrameCloseListener
(
"
click
"
)
;
yield
this
.
listener
.
clickElement
(
id
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
getElementAttribute
=
function
*
(
cmd
resp
)
{
let
{
id
name
}
=
cmd
.
parameters
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
id
{
frame
:
win
}
)
;
resp
.
body
.
value
=
atom
.
getElementAttribute
(
el
name
this
.
getCurrentWindow
(
)
)
;
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
yield
this
.
listener
.
getElementAttribute
(
id
name
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
getElementProperty
=
function
*
(
cmd
resp
)
{
let
{
id
name
}
=
cmd
.
parameters
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
id
{
frame
:
win
}
)
;
resp
.
body
.
value
=
el
[
name
]
;
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
yield
this
.
listener
.
getElementProperty
(
id
name
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
getElementText
=
function
*
(
cmd
resp
)
{
let
id
=
cmd
.
parameters
.
id
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
id
{
frame
:
win
}
)
;
let
lines
=
[
]
;
this
.
getVisibleText
(
el
lines
)
;
resp
.
body
.
value
=
lines
.
join
(
"
\
n
"
)
;
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
yield
this
.
listener
.
getElementText
(
id
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
getElementTagName
=
function
*
(
cmd
resp
)
{
let
id
=
cmd
.
parameters
.
id
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
id
{
frame
:
win
}
)
;
resp
.
body
.
value
=
el
.
tagName
.
toLowerCase
(
)
;
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
yield
this
.
listener
.
getElementTagName
(
id
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
isElementDisplayed
=
function
*
(
cmd
resp
)
{
let
id
=
cmd
.
parameters
.
id
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
id
{
frame
:
win
}
)
;
resp
.
body
.
value
=
yield
interaction
.
isElementDisplayed
(
el
this
.
sessionCapabilities
.
raisesAccessibilityExceptions
)
;
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
yield
this
.
listener
.
isElementDisplayed
(
id
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
getElementValueOfCssProperty
=
function
*
(
cmd
resp
)
{
let
{
id
propertyName
:
prop
}
=
cmd
.
parameters
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
id
{
frame
:
win
}
)
;
let
sty
=
win
.
document
.
defaultView
.
getComputedStyle
(
el
null
)
;
resp
.
body
.
value
=
sty
.
getPropertyValue
(
prop
)
;
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
yield
this
.
listener
.
getElementValueOfCssProperty
(
id
prop
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
isElementEnabled
=
function
*
(
cmd
resp
)
{
let
id
=
cmd
.
parameters
.
id
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
id
{
frame
:
win
}
)
;
resp
.
body
.
value
=
yield
interaction
.
isElementEnabled
(
el
this
.
sessionCapabilities
.
raisesAccessibilityExceptions
)
;
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
yield
this
.
listener
.
isElementEnabled
(
id
)
;
break
;
}
}
GeckoDriver
.
prototype
.
isElementSelected
=
function
*
(
cmd
resp
)
{
let
id
=
cmd
.
parameters
.
id
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
id
{
frame
:
win
}
)
;
resp
.
body
.
value
=
yield
interaction
.
isElementSelected
(
el
this
.
sessionCapabilities
.
raisesAccessibilityExceptions
)
;
break
;
case
Context
.
CONTENT
:
resp
.
body
.
value
=
yield
this
.
listener
.
isElementSelected
(
id
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
getElementRect
=
function
*
(
cmd
resp
)
{
let
id
=
cmd
.
parameters
.
id
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
id
{
frame
:
win
}
)
;
let
rect
=
el
.
getBoundingClientRect
(
)
;
resp
.
body
=
{
x
:
rect
.
x
+
win
.
pageXOffset
y
:
rect
.
y
+
win
.
pageYOffset
width
:
rect
.
width
height
:
rect
.
height
}
;
break
;
case
Context
.
CONTENT
:
resp
.
body
=
yield
this
.
listener
.
getElementRect
(
id
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
sendKeysToElement
=
function
*
(
cmd
resp
)
{
let
{
id
value
}
=
cmd
.
parameters
;
if
(
!
value
)
{
throw
new
InvalidArgumentError
(
Expected
character
sequence
:
{
value
}
)
;
}
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
id
{
frame
:
win
}
)
;
yield
interaction
.
sendKeysToElement
(
el
value
true
this
.
sessionCapabilities
.
raisesAccessibilityExceptions
)
;
break
;
case
Context
.
CONTENT
:
yield
this
.
listener
.
sendKeysToElement
(
{
id
:
id
value
:
value
}
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
setTestName
=
function
*
(
cmd
resp
)
{
let
val
=
cmd
.
parameters
.
value
;
this
.
testName
=
val
;
yield
this
.
listener
.
setTestName
(
{
value
:
val
}
)
;
}
;
GeckoDriver
.
prototype
.
clearElement
=
function
*
(
cmd
resp
)
{
let
id
=
cmd
.
parameters
.
id
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
el
=
this
.
curBrowser
.
seenEls
.
get
(
id
{
frame
:
win
}
)
;
if
(
el
.
nodeName
=
=
"
textbox
"
)
{
el
.
value
=
"
"
;
}
else
if
(
el
.
nodeName
=
=
"
checkbox
"
)
{
el
.
checked
=
false
;
}
break
;
case
Context
.
CONTENT
:
yield
this
.
listener
.
clearElement
(
id
)
;
break
;
}
}
;
GeckoDriver
.
prototype
.
switchToShadowRoot
=
function
*
(
cmd
resp
)
{
let
id
;
if
(
cmd
.
parameters
)
{
id
=
cmd
.
parameters
.
id
;
}
yield
this
.
listener
.
switchToShadowRoot
(
id
)
;
}
;
GeckoDriver
.
prototype
.
addCookie
=
function
*
(
cmd
resp
)
{
let
cb
=
msg
=
>
{
this
.
mm
.
removeMessageListener
(
"
Marionette
:
addCookie
"
cb
)
;
let
cookie
=
msg
.
json
;
Services
.
cookies
.
add
(
cookie
.
domain
cookie
.
path
cookie
.
name
cookie
.
value
cookie
.
secure
cookie
.
httpOnly
cookie
.
session
cookie
.
expiry
{
}
)
;
return
true
;
}
;
this
.
mm
.
addMessageListener
(
"
Marionette
:
addCookie
"
cb
)
;
yield
this
.
listener
.
addCookie
(
cmd
.
parameters
.
cookie
)
;
}
;
GeckoDriver
.
prototype
.
getCookies
=
function
*
(
cmd
resp
)
{
resp
.
body
=
yield
this
.
listener
.
getCookies
(
)
;
}
;
GeckoDriver
.
prototype
.
deleteAllCookies
=
function
*
(
cmd
resp
)
{
let
cb
=
msg
=
>
{
let
cookie
=
msg
.
json
;
cookieManager
.
remove
(
cookie
.
host
cookie
.
name
cookie
.
path
false
cookie
.
originAttributes
)
;
return
true
;
}
;
this
.
mm
.
addMessageListener
(
"
Marionette
:
deleteCookie
"
cb
)
;
yield
this
.
listener
.
deleteAllCookies
(
)
;
this
.
mm
.
removeMessageListener
(
"
Marionette
:
deleteCookie
"
cb
)
;
}
;
GeckoDriver
.
prototype
.
deleteCookie
=
function
*
(
cmd
resp
)
{
let
cb
=
msg
=
>
{
this
.
mm
.
removeMessageListener
(
"
Marionette
:
deleteCookie
"
cb
)
;
let
cookie
=
msg
.
json
;
cookieManager
.
remove
(
cookie
.
host
cookie
.
name
cookie
.
path
false
cookie
.
originAttributes
)
;
return
true
;
}
;
this
.
mm
.
addMessageListener
(
"
Marionette
:
deleteCookie
"
cb
)
;
yield
this
.
listener
.
deleteCookie
(
cmd
.
parameters
.
name
)
;
}
;
GeckoDriver
.
prototype
.
close
=
function
(
cmd
resp
)
{
if
(
this
.
appName
=
=
"
B2G
"
)
{
return
;
}
let
nwins
=
0
;
let
winEn
=
Services
.
wm
.
getEnumerator
(
null
)
;
while
(
winEn
.
hasMoreElements
(
)
)
{
let
win
=
winEn
.
getNext
(
)
;
if
(
win
.
gBrowser
)
{
nwins
+
=
win
.
gBrowser
.
browsers
.
length
;
}
else
{
nwins
+
+
;
}
}
if
(
nwins
=
=
1
)
{
this
.
sessionTearDown
(
)
;
return
;
}
try
{
if
(
this
.
mm
!
=
globalMessageManager
)
{
this
.
mm
.
removeDelayedFrameScript
(
FRAME_SCRIPT
)
;
}
if
(
this
.
curBrowser
.
tab
)
{
this
.
curBrowser
.
closeTab
(
)
;
}
else
{
this
.
getCurrentWindow
(
)
.
close
(
)
;
}
}
catch
(
e
)
{
throw
new
UnknownError
(
Could
not
close
window
:
{
e
.
message
}
)
;
}
}
;
GeckoDriver
.
prototype
.
closeChromeWindow
=
function
(
cmd
resp
)
{
if
(
this
.
appName
=
=
"
B2G
"
)
{
return
;
}
let
nwins
=
0
;
let
winEn
=
Services
.
wm
.
getEnumerator
(
null
)
;
while
(
winEn
.
hasMoreElements
(
)
)
{
nwins
+
+
;
winEn
.
getNext
(
)
;
}
if
(
nwins
=
=
1
)
{
this
.
sessionTearDown
(
)
;
return
;
}
try
{
this
.
mm
.
removeDelayedFrameScript
(
FRAME_SCRIPT
)
;
this
.
getCurrentWindow
(
)
.
close
(
)
;
}
catch
(
e
)
{
throw
new
UnknownError
(
Could
not
close
window
:
{
e
.
message
}
)
;
}
}
;
GeckoDriver
.
prototype
.
sessionTearDown
=
function
(
cmd
resp
)
{
if
(
this
.
curBrowser
!
=
=
null
)
{
if
(
this
.
appName
=
=
"
B2G
"
)
{
globalMessageManager
.
broadcastAsyncMessage
(
"
Marionette
:
sleepSession
"
+
this
.
curBrowser
.
mainContentId
{
}
)
;
this
.
curBrowser
.
knownFrames
.
splice
(
this
.
curBrowser
.
knownFrames
.
indexOf
(
this
.
curBrowser
.
mainContentId
)
1
)
;
}
else
{
Preferences
.
set
(
CONTENT_LISTENER_PREF
false
)
;
}
for
(
let
win
in
this
.
browsers
)
{
let
browser
=
this
.
browsers
[
win
]
;
for
(
let
i
in
browser
.
knownFrames
)
{
globalMessageManager
.
broadcastAsyncMessage
(
"
Marionette
:
deleteSession
"
+
browser
.
knownFrames
[
i
]
{
}
)
;
}
}
let
winEn
=
Services
.
wm
.
getEnumerator
(
null
)
;
while
(
winEn
.
hasMoreElements
(
)
)
{
let
win
=
winEn
.
getNext
(
)
;
if
(
win
.
messageManager
)
{
win
.
messageManager
.
removeDelayedFrameScript
(
FRAME_SCRIPT
)
;
}
else
{
logger
.
error
(
Could
not
remove
listener
from
page
{
win
.
location
.
href
}
)
;
}
}
this
.
curBrowser
.
frameManager
.
removeMessageManagerListeners
(
globalMessageManager
)
;
}
this
.
switchToGlobalMessageManager
(
)
;
this
.
curFrame
=
null
;
if
(
this
.
mainFrame
)
{
this
.
mainFrame
.
focus
(
)
;
}
this
.
sessionId
=
null
;
if
(
this
.
observing
!
=
=
null
)
{
for
(
let
topic
in
this
.
observing
)
{
Services
.
obs
.
removeObserver
(
this
.
observing
[
topic
]
topic
)
;
}
this
.
observing
=
null
;
}
this
.
sandboxes
.
clear
(
)
;
}
;
GeckoDriver
.
prototype
.
deleteSession
=
function
(
cmd
resp
)
{
this
.
sessionTearDown
(
)
;
}
;
GeckoDriver
.
prototype
.
getAppCacheStatus
=
function
*
(
cmd
resp
)
{
resp
.
body
.
value
=
yield
this
.
listener
.
getAppCacheStatus
(
)
;
}
;
GeckoDriver
.
prototype
.
importScript
=
function
*
(
cmd
resp
)
{
let
script
=
cmd
.
parameters
.
script
;
this
.
importedScripts
.
for
(
this
.
context
)
.
add
(
script
)
;
}
;
GeckoDriver
.
prototype
.
clearImportedScripts
=
function
*
(
cmd
resp
)
{
this
.
importedScripts
.
for
(
this
.
context
)
.
clear
(
)
;
}
;
GeckoDriver
.
prototype
.
takeScreenshot
=
function
(
cmd
resp
)
{
let
{
id
highlights
full
hash
}
=
cmd
.
parameters
;
highlights
=
highlights
|
|
[
]
;
switch
(
this
.
context
)
{
case
Context
.
CHROME
:
let
win
=
this
.
getCurrentWindow
(
)
;
let
canvas
=
win
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
let
doc
;
if
(
this
.
appName
=
=
"
B2G
"
)
{
doc
=
win
.
document
.
body
;
}
else
{
doc
=
win
.
document
.
documentElement
;
}
let
docRect
=
doc
.
getBoundingClientRect
(
)
;
let
width
=
docRect
.
width
;
let
height
=
docRect
.
height
;
let
scale
=
win
.
devicePixelRatio
;
canvas
.
setAttribute
(
"
width
"
Math
.
round
(
width
*
scale
)
)
;
canvas
.
setAttribute
(
"
height
"
Math
.
round
(
height
*
scale
)
)
;
let
context
=
canvas
.
getContext
(
"
2d
"
)
;
let
flags
;
if
(
this
.
appName
=
=
"
B2G
"
)
{
flags
=
context
.
DRAWWINDOW_DRAW_CARET
|
context
.
DRAWWINDOW_DRAW_VIEW
|
context
.
DRAWWINDOW_USE_WIDGET_LAYERS
;
}
else
{
flags
=
context
.
DRAWWINDOW_DRAW_VIEW
|
context
.
DRAWWINDOW_USE_WIDGET_LAYERS
;
}
context
.
scale
(
scale
scale
)
;
context
.
drawWindow
(
win
0
0
width
height
"
rgb
(
255
255
255
)
"
flags
)
;
let
dataUrl
=
canvas
.
toDataURL
(
"
image
/
png
"
"
"
)
;
let
data
=
dataUrl
.
substring
(
dataUrl
.
indexOf
(
"
"
)
+
1
)
;
resp
.
body
.
value
=
data
;
break
;
case
Context
.
CONTENT
:
if
(
hash
)
{
return
this
.
listener
.
getScreenshotHash
(
id
full
highlights
)
;
}
else
{
return
this
.
listener
.
takeScreenshot
(
id
full
highlights
)
;
}
}
}
;
GeckoDriver
.
prototype
.
getScreenOrientation
=
function
(
cmd
resp
)
{
if
(
this
.
appName
=
=
"
Firefox
"
)
{
throw
new
UnsupportedOperationError
(
)
;
}
resp
.
body
.
value
=
this
.
getCurrentWindow
(
)
.
screen
.
mozOrientation
;
}
;
GeckoDriver
.
prototype
.
setScreenOrientation
=
function
(
cmd
resp
)
{
if
(
this
.
appName
=
=
"
Firefox
"
)
{
throw
new
UnsupportedOperationError
(
)
;
}
const
ors
=
[
"
portrait
"
"
landscape
"
"
portrait
-
primary
"
"
landscape
-
primary
"
"
portrait
-
secondary
"
"
landscape
-
secondary
"
]
;
let
or
=
String
(
cmd
.
parameters
.
orientation
)
;
let
mozOr
=
or
.
toLowerCase
(
)
;
if
(
ors
.
indexOf
(
mozOr
)
<
0
)
{
throw
new
InvalidArgumentError
(
Unknown
screen
orientation
:
{
or
}
)
;
}
let
win
=
this
.
getCurrentWindow
(
)
;
if
(
!
win
.
screen
.
mozLockOrientation
(
mozOr
)
)
{
throw
new
WebDriverError
(
Unable
to
set
screen
orientation
:
{
or
}
)
;
}
}
;
GeckoDriver
.
prototype
.
getWindowSize
=
function
(
cmd
resp
)
{
let
win
=
this
.
getCurrentWindow
(
)
;
resp
.
body
.
width
=
win
.
outerWidth
;
resp
.
body
.
height
=
win
.
outerHeight
;
}
;
GeckoDriver
.
prototype
.
setWindowSize
=
function
(
cmd
resp
)
{
if
(
this
.
appName
!
=
"
Firefox
"
)
{
throw
new
UnsupportedOperationError
(
)
;
}
let
{
width
height
}
=
cmd
.
parameters
;
let
win
=
this
.
getCurrentWindow
(
)
;
win
.
resizeTo
(
width
height
)
;
this
.
getWindowSize
(
cmd
resp
)
;
}
;
GeckoDriver
.
prototype
.
maximizeWindow
=
function
(
cmd
resp
)
{
if
(
this
.
appName
!
=
"
Firefox
"
)
{
throw
new
UnsupportedOperationError
(
)
;
}
let
win
=
this
.
getCurrentWindow
(
)
;
win
.
maximize
(
)
}
;
GeckoDriver
.
prototype
.
dismissDialog
=
function
(
cmd
resp
)
{
this
.
_checkIfAlertIsPresent
(
)
;
let
{
button0
button1
}
=
this
.
dialog
.
ui
;
(
button1
?
button1
:
button0
)
.
click
(
)
;
this
.
dialog
=
null
;
}
;
GeckoDriver
.
prototype
.
acceptDialog
=
function
(
cmd
resp
)
{
this
.
_checkIfAlertIsPresent
(
)
;
let
{
button0
}
=
this
.
dialog
.
ui
;
button0
.
click
(
)
;
this
.
dialog
=
null
;
}
;
GeckoDriver
.
prototype
.
getTextFromDialog
=
function
(
cmd
resp
)
{
this
.
_checkIfAlertIsPresent
(
)
;
let
{
infoBody
}
=
this
.
dialog
.
ui
;
resp
.
body
.
value
=
infoBody
.
textContent
;
}
;
GeckoDriver
.
prototype
.
sendKeysToDialog
=
function
(
cmd
resp
)
{
this
.
_checkIfAlertIsPresent
(
)
;
let
{
loginContainer
loginTextbox
}
=
this
.
dialog
.
ui
;
if
(
loginContainer
.
hidden
)
{
throw
new
ElementNotVisibleError
(
"
This
prompt
does
not
accept
text
input
"
)
;
}
let
win
=
this
.
dialog
.
window
?
this
.
dialog
.
window
:
this
.
getCurrentWindow
(
)
;
event
.
sendKeysToElement
(
cmd
.
parameters
.
value
loginTextbox
{
ignoreVisibility
:
true
}
win
)
;
}
;
GeckoDriver
.
prototype
.
_checkIfAlertIsPresent
=
function
(
)
{
if
(
!
this
.
dialog
|
|
!
this
.
dialog
.
ui
)
{
throw
new
NoAlertOpenError
(
"
No
tab
modal
was
open
when
attempting
to
get
the
dialog
text
"
)
;
}
}
;
GeckoDriver
.
prototype
.
quitApplication
=
function
(
cmd
resp
)
{
if
(
this
.
appName
!
=
"
Firefox
"
)
{
throw
new
WebDriverError
(
"
In
app
initiated
quit
only
supported
in
Firefox
"
)
;
}
let
flags
=
Ci
.
nsIAppStartup
.
eAttemptQuit
;
for
(
let
k
of
cmd
.
parameters
.
flags
)
{
flags
|
=
Ci
.
nsIAppStartup
[
k
]
;
}
this
.
stopSignal_
(
)
;
resp
.
send
(
)
;
this
.
sessionTearDown
(
)
;
Services
.
startup
.
quit
(
flags
)
;
}
;
GeckoDriver
.
prototype
.
generateFrameId
=
function
(
id
)
{
let
uid
=
id
+
(
this
.
appName
=
=
"
B2G
"
?
"
-
b2g
"
:
"
"
)
;
return
uid
;
}
;
GeckoDriver
.
prototype
.
receiveMessage
=
function
(
message
)
{
switch
(
message
.
name
)
{
case
"
Marionette
:
ok
"
:
case
"
Marionette
:
done
"
:
case
"
Marionette
:
error
"
:
if
(
this
.
mozBrowserClose
!
=
=
null
)
{
let
win
=
this
.
getCurrentWindow
(
)
;
win
.
removeEventListener
(
"
mozbrowserclose
"
this
.
mozBrowserClose
true
)
;
this
.
mozBrowserClose
=
null
;
}
break
;
case
"
Marionette
:
log
"
:
logger
.
info
(
message
.
json
.
message
)
;
break
;
case
"
Marionette
:
shareData
"
:
if
(
message
.
json
.
log
)
{
this
.
marionetteLog
.
addAll
(
message
.
json
.
log
)
;
}
break
;
case
"
Marionette
:
switchToModalOrigin
"
:
this
.
curBrowser
.
frameManager
.
switchToModalOrigin
(
message
)
;
this
.
mm
=
this
.
curBrowser
.
frameManager
.
currentRemoteFrame
.
messageManager
.
get
(
)
;
break
;
case
"
Marionette
:
switchedToFrame
"
:
if
(
message
.
json
.
restorePrevious
)
{
this
.
currentFrameElement
=
this
.
previousFrameElement
;
}
else
{
if
(
message
.
json
.
storePrevious
)
{
this
.
previousFrameElement
=
this
.
currentFrameElement
;
}
this
.
currentFrameElement
=
message
.
json
.
frameValue
;
}
break
;
case
"
Marionette
:
getVisibleCookies
"
:
let
[
currentPath
host
]
=
message
.
json
;
let
isForCurrentPath
=
path
=
>
currentPath
.
indexOf
(
path
)
!
=
-
1
;
let
results
=
[
]
;
let
en
=
cookieManager
.
getCookiesFromHost
(
host
{
}
)
;
while
(
en
.
hasMoreElements
(
)
)
{
let
cookie
=
en
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsICookie2
)
;
let
hostname
=
host
;
do
{
if
(
(
cookie
.
host
=
=
"
.
"
+
hostname
|
|
cookie
.
host
=
=
hostname
)
&
&
isForCurrentPath
(
cookie
.
path
)
)
{
results
.
push
(
{
"
name
"
:
cookie
.
name
"
value
"
:
cookie
.
value
"
path
"
:
cookie
.
path
"
host
"
:
cookie
.
host
"
secure
"
:
cookie
.
isSecure
"
expiry
"
:
cookie
.
expires
"
httpOnly
"
:
cookie
.
isHttpOnly
"
originAttributes
"
:
cookie
.
originAttributes
}
)
;
break
;
}
hostname
=
hostname
.
replace
(
/
^
.
*
?
\
.
/
"
"
)
;
}
while
(
hostname
.
indexOf
(
"
.
"
)
!
=
-
1
)
;
}
return
results
;
case
"
Marionette
:
getFiles
"
:
let
val
=
message
.
json
.
value
;
let
command_id
=
message
.
json
.
command_id
;
Cu
.
importGlobalProperties
(
[
"
File
"
]
)
;
try
{
let
file
=
new
File
(
val
)
;
this
.
sendAsync
(
"
receiveFiles
"
{
file
:
file
command_id
:
command_id
}
)
;
}
catch
(
e
)
{
let
err
=
File
not
found
:
{
val
}
;
this
.
sendAsync
(
"
receiveFiles
"
{
error
:
err
command_id
:
command_id
}
)
;
}
break
;
case
"
Marionette
:
emitTouchEvent
"
:
globalMessageManager
.
broadcastAsyncMessage
(
"
MarionetteMainListener
:
emitTouchEvent
"
message
.
json
)
;
break
;
case
"
Marionette
:
register
"
:
let
wid
=
message
.
json
.
value
;
let
be
=
message
.
target
;
let
rv
=
this
.
registerBrowser
(
wid
be
)
;
return
rv
;
case
"
Marionette
:
listenersAttached
"
:
if
(
message
.
json
.
listenerId
=
=
=
this
.
curBrowser
.
curFrameId
)
{
this
.
sendAsync
(
"
newSession
"
this
.
sessionCapabilities
)
;
this
.
curBrowser
.
flushPendingCommands
(
)
;
}
break
;
}
}
;
GeckoDriver
.
prototype
.
responseCompleted
=
function
(
)
{
if
(
this
.
curBrowser
!
=
=
null
)
{
this
.
curBrowser
.
pendingCommands
=
[
]
;
}
}
;
GeckoDriver
.
prototype
.
commands
=
{
"
getMarionetteID
"
:
GeckoDriver
.
prototype
.
getMarionetteID
"
sayHello
"
:
GeckoDriver
.
prototype
.
sayHello
"
newSession
"
:
GeckoDriver
.
prototype
.
newSession
"
getSessionCapabilities
"
:
GeckoDriver
.
prototype
.
getSessionCapabilities
"
log
"
:
GeckoDriver
.
prototype
.
log
"
getLogs
"
:
GeckoDriver
.
prototype
.
getLogs
"
setContext
"
:
GeckoDriver
.
prototype
.
setContext
"
getContext
"
:
GeckoDriver
.
prototype
.
getContext
"
executeScript
"
:
GeckoDriver
.
prototype
.
executeScript
"
setScriptTimeout
"
:
GeckoDriver
.
prototype
.
setScriptTimeout
"
timeouts
"
:
GeckoDriver
.
prototype
.
timeouts
"
singleTap
"
:
GeckoDriver
.
prototype
.
singleTap
"
actionChain
"
:
GeckoDriver
.
prototype
.
actionChain
"
multiAction
"
:
GeckoDriver
.
prototype
.
multiAction
"
executeAsyncScript
"
:
GeckoDriver
.
prototype
.
executeAsyncScript
"
executeJSScript
"
:
GeckoDriver
.
prototype
.
executeJSScript
"
setSearchTimeout
"
:
GeckoDriver
.
prototype
.
setSearchTimeout
"
findElement
"
:
GeckoDriver
.
prototype
.
findElement
"
findElements
"
:
GeckoDriver
.
prototype
.
findElements
"
clickElement
"
:
GeckoDriver
.
prototype
.
clickElement
"
getElementAttribute
"
:
GeckoDriver
.
prototype
.
getElementAttribute
"
getElementProperty
"
:
GeckoDriver
.
prototype
.
getElementProperty
"
getElementText
"
:
GeckoDriver
.
prototype
.
getElementText
"
getElementTagName
"
:
GeckoDriver
.
prototype
.
getElementTagName
"
isElementDisplayed
"
:
GeckoDriver
.
prototype
.
isElementDisplayed
"
getElementValueOfCssProperty
"
:
GeckoDriver
.
prototype
.
getElementValueOfCssProperty
"
getElementRect
"
:
GeckoDriver
.
prototype
.
getElementRect
"
isElementEnabled
"
:
GeckoDriver
.
prototype
.
isElementEnabled
"
isElementSelected
"
:
GeckoDriver
.
prototype
.
isElementSelected
"
sendKeysToElement
"
:
GeckoDriver
.
prototype
.
sendKeysToElement
"
clearElement
"
:
GeckoDriver
.
prototype
.
clearElement
"
getTitle
"
:
GeckoDriver
.
prototype
.
getTitle
"
getWindowType
"
:
GeckoDriver
.
prototype
.
getWindowType
"
getPageSource
"
:
GeckoDriver
.
prototype
.
getPageSource
"
get
"
:
GeckoDriver
.
prototype
.
get
"
goUrl
"
:
GeckoDriver
.
prototype
.
get
"
getCurrentUrl
"
:
GeckoDriver
.
prototype
.
getCurrentUrl
"
getUrl
"
:
GeckoDriver
.
prototype
.
getCurrentUrl
"
goBack
"
:
GeckoDriver
.
prototype
.
goBack
"
goForward
"
:
GeckoDriver
.
prototype
.
goForward
"
refresh
"
:
GeckoDriver
.
prototype
.
refresh
"
getWindowHandle
"
:
GeckoDriver
.
prototype
.
getWindowHandle
"
getCurrentWindowHandle
"
:
GeckoDriver
.
prototype
.
getWindowHandle
"
getChromeWindowHandle
"
:
GeckoDriver
.
prototype
.
getChromeWindowHandle
"
getCurrentChromeWindowHandle
"
:
GeckoDriver
.
prototype
.
getChromeWindowHandle
"
getWindow
"
:
GeckoDriver
.
prototype
.
getWindowHandle
"
getWindowHandles
"
:
GeckoDriver
.
prototype
.
getWindowHandles
"
getChromeWindowHandles
"
:
GeckoDriver
.
prototype
.
getChromeWindowHandles
"
getCurrentWindowHandles
"
:
GeckoDriver
.
prototype
.
getWindowHandles
"
getWindows
"
:
GeckoDriver
.
prototype
.
getWindowHandles
"
getWindowPosition
"
:
GeckoDriver
.
prototype
.
getWindowPosition
"
setWindowPosition
"
:
GeckoDriver
.
prototype
.
setWindowPosition
"
getActiveFrame
"
:
GeckoDriver
.
prototype
.
getActiveFrame
"
switchToFrame
"
:
GeckoDriver
.
prototype
.
switchToFrame
"
switchToParentFrame
"
:
GeckoDriver
.
prototype
.
switchToParentFrame
"
switchToWindow
"
:
GeckoDriver
.
prototype
.
switchToWindow
"
switchToShadowRoot
"
:
GeckoDriver
.
prototype
.
switchToShadowRoot
"
deleteSession
"
:
GeckoDriver
.
prototype
.
deleteSession
"
importScript
"
:
GeckoDriver
.
prototype
.
importScript
"
clearImportedScripts
"
:
GeckoDriver
.
prototype
.
clearImportedScripts
"
getAppCacheStatus
"
:
GeckoDriver
.
prototype
.
getAppCacheStatus
"
close
"
:
GeckoDriver
.
prototype
.
close
"
closeWindow
"
:
GeckoDriver
.
prototype
.
close
"
closeChromeWindow
"
:
GeckoDriver
.
prototype
.
closeChromeWindow
"
setTestName
"
:
GeckoDriver
.
prototype
.
setTestName
"
takeScreenshot
"
:
GeckoDriver
.
prototype
.
takeScreenshot
"
screenShot
"
:
GeckoDriver
.
prototype
.
takeScreenshot
"
screenshot
"
:
GeckoDriver
.
prototype
.
takeScreenshot
"
addCookie
"
:
GeckoDriver
.
prototype
.
addCookie
"
getCookies
"
:
GeckoDriver
.
prototype
.
getCookies
"
getAllCookies
"
:
GeckoDriver
.
prototype
.
getCookies
"
deleteAllCookies
"
:
GeckoDriver
.
prototype
.
deleteAllCookies
"
deleteCookie
"
:
GeckoDriver
.
prototype
.
deleteCookie
"
getActiveElement
"
:
GeckoDriver
.
prototype
.
getActiveElement
"
getScreenOrientation
"
:
GeckoDriver
.
prototype
.
getScreenOrientation
"
setScreenOrientation
"
:
GeckoDriver
.
prototype
.
setScreenOrientation
"
getWindowSize
"
:
GeckoDriver
.
prototype
.
getWindowSize
"
setWindowSize
"
:
GeckoDriver
.
prototype
.
setWindowSize
"
maximizeWindow
"
:
GeckoDriver
.
prototype
.
maximizeWindow
"
dismissDialog
"
:
GeckoDriver
.
prototype
.
dismissDialog
"
acceptDialog
"
:
GeckoDriver
.
prototype
.
acceptDialog
"
getTextFromDialog
"
:
GeckoDriver
.
prototype
.
getTextFromDialog
"
sendKeysToDialog
"
:
GeckoDriver
.
prototype
.
sendKeysToDialog
"
quitApplication
"
:
GeckoDriver
.
prototype
.
quitApplication
}
;
