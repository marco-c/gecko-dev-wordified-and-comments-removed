"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
WebElementEventTarget
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
dom
.
js
"
)
;
const
{
element
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
)
;
const
{
NoSuchWindowError
UnsupportedOperationError
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
error
.
js
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
log
.
js
"
)
;
const
{
MessageManagerDestroyedPromise
waitForEvent
waitForObserverTopic
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
sync
.
js
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
Log
.
get
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
browser
"
"
Context
"
"
WindowState
"
]
;
this
.
browser
=
{
}
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
class
Context
{
static
fromString
(
s
)
{
switch
(
s
)
{
case
"
chrome
"
:
return
Context
.
Chrome
;
case
"
content
"
:
return
Context
.
Content
;
default
:
throw
new
TypeError
(
Unknown
context
:
{
s
}
)
;
}
}
}
Context
.
Chrome
=
"
chrome
"
;
Context
.
Content
=
"
content
"
;
this
.
Context
=
Context
;
class
MobileTabBrowser
{
constructor
(
window
)
{
this
.
window
=
window
;
}
get
tabs
(
)
{
return
[
this
.
window
.
tab
]
;
}
get
selectedTab
(
)
{
return
this
.
window
.
tab
;
}
}
browser
.
getBrowserForTab
=
function
(
tab
)
{
if
(
tab
&
&
"
linkedBrowser
"
in
tab
)
{
return
tab
.
linkedBrowser
;
}
return
null
;
}
;
browser
.
getTabBrowser
=
function
(
window
)
{
if
(
"
gBrowser
"
in
window
)
{
return
window
.
gBrowser
;
}
else
if
(
"
browser
"
in
window
)
{
return
new
MobileTabBrowser
(
window
)
;
}
else
if
(
window
.
document
.
getElementById
(
"
tabmail
"
)
)
{
return
window
.
document
.
getElementById
(
"
tabmail
"
)
;
}
return
null
;
}
;
browser
.
Context
=
class
{
constructor
(
window
driver
)
{
this
.
window
=
window
;
this
.
driver
=
driver
;
this
.
tabBrowser
=
browser
.
getTabBrowser
(
this
.
window
)
;
this
.
knownFrames
=
[
]
;
this
.
newSession
=
true
;
this
.
seenEls
=
new
element
.
Store
(
)
;
this
.
tab
=
null
;
this
.
pendingCommands
=
[
]
;
this
.
_needsFlushPendingCommands
=
false
;
this
.
frameRegsPending
=
0
;
this
.
getIdForBrowser
=
driver
.
getIdForBrowser
.
bind
(
driver
)
;
this
.
updateIdForBrowser
=
driver
.
updateIdForBrowser
.
bind
(
driver
)
;
}
get
contentBrowser
(
)
{
if
(
this
.
tab
)
{
return
browser
.
getBrowserForTab
(
this
.
tab
)
;
}
else
if
(
this
.
tabBrowser
&
&
this
.
driver
.
isReftestBrowser
(
this
.
tabBrowser
)
)
{
return
this
.
tabBrowser
;
}
return
null
;
}
get
messageManager
(
)
{
if
(
this
.
contentBrowser
)
{
return
this
.
contentBrowser
.
messageManager
;
}
return
null
;
}
get
closed
(
)
{
return
this
.
contentBrowser
=
=
=
null
;
}
get
curFrameId
(
)
{
let
rv
=
null
;
if
(
this
.
tab
|
|
this
.
driver
.
isReftestBrowser
(
this
.
contentBrowser
)
)
{
rv
=
this
.
getIdForBrowser
(
this
.
contentBrowser
)
;
}
return
rv
;
}
get
currentTitle
(
)
{
if
(
this
.
contentBrowser
)
{
return
this
.
contentBrowser
.
contentTitle
;
}
throw
new
NoSuchWindowError
(
"
Current
window
does
not
have
a
content
browser
"
)
;
}
get
currentURI
(
)
{
if
(
this
.
contentBrowser
)
{
return
this
.
contentBrowser
.
currentURI
;
}
throw
new
NoSuchWindowError
(
"
Current
window
does
not
have
a
content
browser
"
)
;
}
get
rect
(
)
{
return
{
x
:
this
.
window
.
screenX
y
:
this
.
window
.
screenY
width
:
this
.
window
.
outerWidth
height
:
this
.
window
.
outerHeight
}
;
}
getTabModal
(
)
{
let
br
=
this
.
contentBrowser
;
if
(
!
br
.
hasAttribute
(
"
tabmodalPromptShowing
"
)
)
{
return
null
;
}
let
modalElements
=
br
.
parentNode
.
getElementsByTagNameNS
(
XUL_NS
"
tabmodalprompt
"
)
;
return
br
.
tabModalPromptBox
.
getPrompt
(
modalElements
[
0
]
)
;
}
closeWindow
(
)
{
let
destroyed
=
new
MessageManagerDestroyedPromise
(
this
.
window
.
messageManager
)
;
let
unloaded
=
waitForEvent
(
this
.
window
"
unload
"
)
;
this
.
window
.
close
(
)
;
return
Promise
.
all
(
[
destroyed
unloaded
]
)
;
}
async
focusWindow
(
)
{
if
(
Services
.
focus
.
activeWindow
!
=
this
.
window
)
{
let
activated
=
waitForEvent
(
this
.
window
"
activate
"
)
;
let
focused
=
waitForEvent
(
this
.
window
"
focus
"
{
capture
:
true
}
)
;
this
.
window
.
focus
(
)
;
await
Promise
.
all
(
[
activated
focused
]
)
;
}
}
async
openBrowserWindow
(
focus
=
false
isPrivate
=
false
)
{
switch
(
this
.
driver
.
appName
)
{
case
"
firefox
"
:
let
win
=
this
.
window
.
OpenBrowserWindow
(
{
private
:
isPrivate
}
)
;
let
activated
=
waitForEvent
(
win
"
activate
"
)
;
let
focused
=
waitForEvent
(
win
"
focus
"
{
capture
:
true
}
)
;
let
startup
=
waitForObserverTopic
(
"
browser
-
delayed
-
startup
-
finished
"
subject
=
>
subject
=
=
win
)
;
win
.
focus
(
)
;
await
Promise
.
all
(
[
activated
focused
startup
]
)
;
if
(
!
focus
)
{
await
this
.
focusWindow
(
)
;
}
return
win
;
default
:
throw
new
UnsupportedOperationError
(
openWindow
(
)
not
supported
in
{
this
.
driver
.
appName
}
)
;
}
}
closeTab
(
)
{
if
(
!
this
.
tabBrowser
|
|
!
this
.
tabBrowser
.
tabs
|
|
this
.
tabBrowser
.
tabs
.
length
=
=
=
1
|
|
!
this
.
tab
)
{
return
this
.
closeWindow
(
)
;
}
let
destroyed
=
new
MessageManagerDestroyedPromise
(
this
.
messageManager
)
;
let
tabClosed
;
switch
(
this
.
driver
.
appName
)
{
case
"
firefox
"
:
tabClosed
=
waitForEvent
(
this
.
tab
"
TabClose
"
)
;
this
.
tabBrowser
.
removeTab
(
this
.
tab
)
;
break
;
default
:
throw
new
UnsupportedOperationError
(
closeTab
(
)
not
supported
in
{
this
.
driver
.
appName
}
)
;
}
return
Promise
.
all
(
[
destroyed
tabClosed
]
)
;
}
async
openTab
(
focus
=
false
)
{
let
tab
=
null
;
switch
(
this
.
driver
.
appName
)
{
case
"
firefox
"
:
const
loaded
=
[
waitForEvent
(
this
.
window
"
TabOpen
"
)
]
;
this
.
window
.
BrowserOpenTab
(
)
;
tab
=
this
.
tabBrowser
.
selectedTab
;
loaded
.
push
(
new
Promise
(
resolve
=
>
{
let
cb
=
msg
=
>
{
if
(
msg
.
json
.
frameId
=
=
=
tab
.
linkedBrowser
.
browsingContext
.
id
)
{
this
.
driver
.
mm
.
removeMessageListener
(
"
Marionette
:
ListenersAttached
"
cb
)
;
resolve
(
)
;
}
}
;
this
.
driver
.
mm
.
addMessageListener
(
"
Marionette
:
ListenersAttached
"
cb
)
;
}
)
)
;
await
Promise
.
all
(
loaded
)
;
if
(
!
focus
)
{
this
.
tabBrowser
.
selectedTab
=
this
.
tab
;
}
break
;
default
:
throw
new
UnsupportedOperationError
(
openTab
(
)
not
supported
in
{
this
.
driver
.
appName
}
)
;
}
return
tab
;
}
async
switchToTab
(
index
window
=
undefined
focus
=
true
)
{
let
currentTab
=
this
.
tabBrowser
.
selectedTab
;
if
(
window
)
{
this
.
window
=
window
;
this
.
tabBrowser
=
browser
.
getTabBrowser
(
this
.
window
)
;
}
if
(
!
this
.
tabBrowser
)
{
return
;
}
if
(
typeof
index
=
=
"
undefined
"
)
{
this
.
tab
=
this
.
tabBrowser
.
selectedTab
;
}
else
{
this
.
tab
=
this
.
tabBrowser
.
tabs
[
index
]
;
}
if
(
focus
&
&
this
.
tab
!
=
currentTab
)
{
let
tabSelected
=
waitForEvent
(
this
.
window
"
TabSelect
"
)
;
switch
(
this
.
driver
.
appName
)
{
case
"
firefox
"
:
this
.
tabBrowser
.
selectedTab
=
this
.
tab
;
await
tabSelected
;
break
;
default
:
throw
new
UnsupportedOperationError
(
switchToTab
(
)
not
supported
in
{
this
.
driver
.
appName
}
)
;
}
}
this
.
eventObserver
=
new
WebElementEventTarget
(
this
.
messageManager
)
;
}
register
(
uid
target
)
{
if
(
this
.
tabBrowser
)
{
if
(
!
this
.
tab
)
{
this
.
switchToTab
(
)
;
}
if
(
target
=
=
=
this
.
contentBrowser
)
{
this
.
updateIdForBrowser
(
this
.
contentBrowser
uid
)
;
this
.
_needsFlushPendingCommands
=
true
;
}
}
this
.
knownFrames
.
push
(
uid
)
;
}
flushPendingCommands
(
)
{
if
(
!
this
.
_needsFlushPendingCommands
)
{
return
;
}
this
.
pendingCommands
.
forEach
(
cb
=
>
cb
(
)
)
;
this
.
_needsFlushPendingCommands
=
false
;
}
executeWhenReady
(
cb
)
{
if
(
this
.
_needsFlushPendingCommands
)
{
this
.
pendingCommands
.
push
(
cb
)
;
}
else
{
cb
(
)
;
}
}
}
;
browser
.
Windows
=
class
extends
Map
{
set
(
id
win
)
{
let
wref
=
Cu
.
getWeakReference
(
win
)
;
super
.
set
(
id
wref
)
;
return
this
;
}
get
(
id
)
{
let
wref
=
super
.
get
(
id
)
;
if
(
!
wref
)
{
throw
new
RangeError
(
)
;
}
return
wref
.
get
(
)
;
}
}
;
const
WindowState
=
{
Maximized
:
"
maximized
"
Minimized
:
"
minimized
"
Normal
:
"
normal
"
Fullscreen
:
"
fullscreen
"
from
(
windowState
)
{
switch
(
windowState
)
{
case
1
:
return
WindowState
.
Maximized
;
case
2
:
return
WindowState
.
Minimized
;
case
3
:
return
WindowState
.
Normal
;
case
4
:
return
WindowState
.
Fullscreen
;
default
:
throw
new
TypeError
(
Unknown
window
state
:
{
windowState
}
)
;
}
}
}
;
this
.
WindowState
=
WindowState
;
