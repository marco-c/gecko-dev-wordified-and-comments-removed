"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
element
.
js
"
)
;
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
frame
.
js
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
browser
"
]
;
const
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
this
.
browser
=
{
}
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
browser
.
Context
=
class
{
constructor
(
win
driver
)
{
logger
.
info
(
"
Context
ctor
"
)
;
this
.
browser
=
undefined
;
this
.
window
=
win
;
this
.
driver
=
driver
;
this
.
knownFrames
=
[
]
;
this
.
startPage
=
"
about
:
blank
"
;
this
.
mainContentId
=
null
;
this
.
newSession
=
true
;
this
.
elementManager
=
new
ElementManager
(
[
element
.
Strategy
.
Name
element
.
Strategy
.
LinkText
element
.
Strategy
.
PartialLinkText
]
)
;
this
.
setBrowser
(
win
)
;
this
.
tab
=
null
;
this
.
pendingCommands
=
[
]
;
this
.
frameManager
=
new
frame
.
Manager
(
driver
)
;
this
.
frameRegsPending
=
0
;
this
.
frameManager
.
addMessageManagerListeners
(
driver
.
mm
)
;
this
.
getIdForBrowser
=
driver
.
getIdForBrowser
.
bind
(
driver
)
;
this
.
updateIdForBrowser
=
driver
.
updateIdForBrowser
.
bind
(
driver
)
;
this
.
_curFrameId
=
null
;
this
.
_browserWasRemote
=
null
;
this
.
_hasRemotenessChange
=
false
;
}
get
browserForTab
(
)
{
return
this
.
browser
.
getBrowserForTab
(
this
.
tab
)
;
}
get
curFrameId
(
)
{
let
rv
=
null
;
if
(
this
.
driver
.
appName
!
=
"
Firefox
"
)
{
rv
=
this
.
_curFrameId
;
}
else
if
(
this
.
tab
)
{
rv
=
this
.
getIdForBrowser
(
this
.
browserForTab
)
;
}
return
rv
;
}
set
curFrameId
(
id
)
{
if
(
this
.
driver
.
appName
!
=
"
Firefox
"
)
{
this
.
_curFrameId
=
id
;
}
}
getTabModalUI
(
)
{
let
br
=
this
.
browserForTab
;
if
(
!
br
.
hasAttribute
(
"
tabmodalPromptShowing
"
)
)
{
return
null
;
}
let
modals
=
br
.
parentNode
.
getElementsByTagNameNS
(
XUL_NS
"
tabmodalprompt
"
)
;
return
modals
[
0
]
.
ui
;
}
setBrowser
(
win
)
{
switch
(
this
.
driver
.
appName
)
{
case
"
Firefox
"
:
this
.
browser
=
win
.
gBrowser
;
break
;
case
"
Fennec
"
:
this
.
browser
=
win
.
BrowserApp
;
break
;
}
}
startSession
(
newSession
win
callback
)
{
callback
(
win
newSession
)
;
}
closeTab
(
)
{
if
(
this
.
browser
&
&
this
.
browser
.
removeTab
&
&
this
.
tab
!
=
=
null
&
&
(
this
.
driver
.
appName
!
=
"
B2G
"
)
)
{
this
.
browser
.
removeTab
(
this
.
tab
)
;
}
}
addTab
(
uri
)
{
return
this
.
browser
.
addTab
(
uri
true
)
;
}
switchToTab
(
ind
win
)
{
if
(
win
)
{
this
.
window
=
win
;
this
.
setBrowser
(
win
)
;
}
this
.
browser
.
selectTabAtIndex
(
ind
)
;
this
.
tab
=
this
.
browser
.
selectedTab
;
this
.
_browserWasRemote
=
this
.
browserForTab
.
isRemoteBrowser
;
this
.
_hasRemotenessChange
=
false
;
}
register
(
uid
target
)
{
let
remotenessChange
=
this
.
hasRemotenessChange
(
)
;
if
(
this
.
curFrameId
=
=
=
null
|
|
remotenessChange
)
{
if
(
this
.
browser
)
{
if
(
!
this
.
tab
)
{
this
.
switchToTab
(
this
.
browser
.
selectedIndex
)
;
}
if
(
target
=
=
this
.
browserForTab
)
{
this
.
updateIdForBrowser
(
this
.
browserForTab
uid
)
;
this
.
mainContentId
=
uid
;
}
}
else
{
this
.
_curFrameId
=
uid
;
this
.
mainContentId
=
uid
;
}
}
this
.
knownFrames
.
push
(
uid
)
;
return
remotenessChange
;
}
hasRemotenessChange
(
)
{
if
(
this
.
driver
.
appName
!
=
"
Firefox
"
|
|
this
.
tab
=
=
=
null
)
{
return
false
;
}
if
(
this
.
_hasRemotenessChange
)
{
return
true
;
}
let
currentTab
=
this
.
browser
.
selectedTab
;
let
currentIsRemote
=
this
.
browser
.
getBrowserForTab
(
currentTab
)
.
isRemoteBrowser
;
this
.
_hasRemotenessChange
=
this
.
_browserWasRemote
!
=
=
currentIsRemote
;
this
.
_browserWasRemote
=
currentIsRemote
;
return
this
.
_hasRemotenessChange
;
}
flushPendingCommands
(
)
{
if
(
!
this
.
_hasRemotenessChange
)
{
return
;
}
this
.
_hasRemotenessChange
=
false
;
this
.
pendingCommands
.
forEach
(
cb
=
>
cb
(
)
)
;
this
.
pendingCommands
=
[
]
;
}
executeWhenReady
(
cb
)
{
if
(
this
.
hasRemotenessChange
(
)
)
{
this
.
pendingCommands
.
push
(
cb
)
;
}
else
{
cb
(
)
;
}
}
}
;
