"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
env
"
"
mozilla
.
org
/
process
/
environment
;
1
"
"
nsIEnvironment
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
log
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
log
.
addAppender
(
new
Log
.
DumpAppender
(
)
)
;
return
log
;
}
)
;
const
PREF_ENABLED
=
"
marionette
.
enabled
"
;
const
PREF_LOG_LEVEL_FALLBACK
=
"
marionette
.
logging
"
;
const
PREF_LOG_LEVEL
=
"
marionette
.
log
.
level
"
;
const
PREF_PORT_FALLBACK
=
"
marionette
.
defaultPrefs
.
port
"
;
const
PREF_PORT
=
"
marionette
.
port
"
;
const
PREF_RECOMMENDED
=
"
marionette
.
prefs
.
recommended
"
;
const
DEFAULT_LOG_LEVEL
=
"
info
"
;
const
NOTIFY_RUNNING
=
"
remote
-
active
"
;
const
ENV_ENABLED
=
"
MOZ_MARIONETTE
"
;
const
ENV_PRESERVE_PREFS
=
"
MOZ_MARIONETTE_PREF_STATE_ACROSS_RESTARTS
"
;
const
RECOMMENDED_PREFS
=
new
Map
(
[
[
"
app
.
update
.
auto
"
false
]
[
"
app
.
update
.
enabled
"
false
]
[
"
apz
.
content_response_timeout
"
60000
]
[
"
browser
.
download
.
panel
.
shown
"
true
]
[
"
browser
.
EULA
.
override
"
true
]
[
"
browser
.
newtabpage
.
enabled
"
false
]
[
"
browser
.
newtabpage
.
introShown
"
true
]
[
"
browser
.
offline
"
false
]
[
"
browser
.
pagethumbnails
.
capturing_disabled
"
true
]
[
"
browser
.
safebrowsing
.
blockedURIs
.
enabled
"
false
]
[
"
browser
.
safebrowsing
.
downloads
.
enabled
"
false
]
[
"
browser
.
safebrowsing
.
passwords
.
enabled
"
false
]
[
"
browser
.
safebrowsing
.
malware
.
enabled
"
false
]
[
"
browser
.
safebrowsing
.
phishing
.
enabled
"
false
]
[
"
browser
.
search
.
update
"
false
]
[
"
browser
.
sessionstore
.
resume_from_crash
"
false
]
[
"
browser
.
shell
.
checkDefaultBrowser
"
false
]
[
"
browser
.
startup
.
page
"
0
]
[
"
browser
.
startup
.
homepage_override
.
mstone
"
"
ignore
"
]
[
"
toolkit
.
cosmeticAnimations
.
enabled
"
false
]
[
"
browser
.
tabs
.
disableBackgroundZombification
"
false
]
[
"
browser
.
tabs
.
warnOnCloseOtherTabs
"
false
]
[
"
browser
.
tabs
.
warnOnOpen
"
false
]
[
"
browser
.
usedOnWindows10
.
introURL
"
"
"
]
[
"
browser
.
uitour
.
enabled
"
false
]
[
"
browser
.
urlbar
.
suggest
.
searches
"
false
]
[
"
browser
.
urlbar
.
userMadeSearchSuggestionsChoice
"
true
]
[
"
datareporting
.
healthreport
.
documentServerURI
"
"
http
:
/
/
%
(
server
)
s
/
dummy
/
healthreport
/
"
]
[
"
datareporting
.
healthreport
.
logging
.
consoleEnabled
"
false
]
[
"
datareporting
.
healthreport
.
service
.
enabled
"
false
]
[
"
datareporting
.
healthreport
.
service
.
firstRun
"
false
]
[
"
datareporting
.
healthreport
.
uploadEnabled
"
false
]
[
"
datareporting
.
policy
.
dataSubmissionEnabled
"
false
]
[
"
datareporting
.
policy
.
dataSubmissionPolicyAccepted
"
false
]
[
"
datareporting
.
policy
.
dataSubmissionPolicyBypassNotification
"
true
]
[
"
dom
.
disable_open_during_load
"
false
]
[
"
dom
.
file
.
createInChild
"
true
]
[
"
dom
.
ipc
.
reportProcessHangs
"
false
]
[
"
dom
.
max_chrome_script_run_time
"
0
]
[
"
dom
.
max_script_run_time
"
0
]
[
"
extensions
.
autoDisableScopes
"
0
]
[
"
extensions
.
enabledScopes
"
5
]
[
"
extensions
.
getAddons
.
cache
.
enabled
"
false
]
[
"
extensions
.
installDistroAddons
"
false
]
[
"
extensions
.
shield
-
recipe
-
client
.
api_url
"
"
"
]
[
"
extensions
.
showMismatchUI
"
false
]
[
"
extensions
.
update
.
enabled
"
false
]
[
"
extensions
.
update
.
notifyUser
"
false
]
[
"
extensions
.
webservice
.
discoverURL
"
"
http
:
/
/
%
(
server
)
s
/
dummy
/
discoveryURL
"
]
[
"
focusmanager
.
testmode
"
true
]
[
"
general
.
useragent
.
updates
.
enabled
"
false
]
[
"
geo
.
provider
.
testing
"
true
]
[
"
geo
.
wifi
.
scan
"
false
]
[
"
hangmonitor
.
timeout
"
0
]
[
"
javascript
.
options
.
showInConsole
"
true
]
[
"
network
.
http
.
prompt
-
temp
-
redirect
"
false
]
[
"
network
.
http
.
speculative
-
parallel
-
limit
"
0
]
[
"
network
.
manage
-
offline
-
status
"
false
]
[
"
network
.
sntp
.
pools
"
"
%
(
server
)
s
"
]
[
"
security
.
fileuri
.
strict_origin_policy
"
false
]
[
"
security
.
notification_enable_delay
"
0
]
[
"
services
.
settings
.
server
"
"
http
:
/
/
%
(
server
)
s
/
dummy
/
blocklist
/
"
]
[
"
signon
.
autofillForms
"
false
]
[
"
signon
.
rememberSignons
"
false
]
[
"
startup
.
homepage_welcome_url
"
"
about
:
blank
"
]
[
"
startup
.
homepage_welcome_url
.
additional
"
"
"
]
[
"
toolkit
.
startup
.
max_resumed_crashes
"
-
1
]
]
)
;
const
isRemote
=
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
;
const
LogLevel
=
{
get
(
level
)
{
let
levels
=
new
Map
(
[
[
"
fatal
"
Log
.
Level
.
Fatal
]
[
"
error
"
Log
.
Level
.
Error
]
[
"
warn
"
Log
.
Level
.
Warn
]
[
"
info
"
Log
.
Level
.
Info
]
[
"
config
"
Log
.
Level
.
Config
]
[
"
debug
"
Log
.
Level
.
Debug
]
[
"
trace
"
Log
.
Level
.
Trace
]
]
)
;
let
s
=
String
(
level
)
.
toLowerCase
(
)
;
if
(
!
levels
.
has
(
s
)
)
{
return
DEFAULT_LOG_LEVEL
;
}
return
levels
.
get
(
s
)
;
}
}
;
function
getPrefVal
(
pref
)
{
const
{
PREF_STRING
PREF_BOOL
PREF_INT
PREF_INVALID
}
=
Ci
.
nsIPrefBranch
;
let
type
=
Services
.
prefs
.
getPrefType
(
pref
)
;
switch
(
type
)
{
case
PREF_STRING
:
return
Services
.
prefs
.
getStringPref
(
pref
)
;
case
PREF_BOOL
:
return
Services
.
prefs
.
getBoolPref
(
pref
)
;
case
PREF_INT
:
return
Services
.
prefs
.
getIntPref
(
pref
)
;
case
PREF_INVALID
:
return
undefined
;
default
:
throw
new
TypeError
(
Unexpected
preference
type
(
{
type
}
)
for
{
pref
}
)
;
}
}
function
getPref
(
preferred
fallback
)
{
if
(
!
Services
.
prefs
.
prefHasUserValue
(
preferred
)
&
&
Services
.
prefs
.
getPrefType
(
fallback
)
!
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
)
{
return
getPrefVal
(
fallback
getPrefVal
(
preferred
)
)
;
}
return
getPrefVal
(
preferred
)
;
}
const
prefs
=
{
get
port
(
)
{
return
getPref
(
PREF_PORT
PREF_PORT_FALLBACK
)
;
}
get
logLevel
(
)
{
let
s
=
getPref
(
PREF_LOG_LEVEL
PREF_LOG_LEVEL_FALLBACK
)
;
return
LogLevel
.
get
(
s
)
;
}
readFromEnvironment
(
key
)
{
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
if
(
env
.
exists
(
key
)
)
{
let
prefs
;
try
{
prefs
=
JSON
.
parse
(
env
.
get
(
key
)
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Invalid
Marionette
preferences
in
environment
;
"
+
"
preferences
will
not
have
been
applied
"
)
;
Cu
.
reportError
(
e
)
;
}
if
(
prefs
)
{
for
(
let
prefName
of
Object
.
keys
(
prefs
)
)
{
Preferences
.
set
(
prefName
prefs
[
prefName
]
)
;
}
}
}
}
}
;
class
MarionetteMainProcess
{
constructor
(
)
{
this
.
server
=
null
;
this
.
gfxWindow
=
null
;
this
.
finalUIStartup
=
false
;
log
.
level
=
prefs
.
logLevel
;
this
.
enabled
=
env
.
exists
(
ENV_ENABLED
)
;
this
.
alteredPrefs
=
new
Set
(
)
;
Services
.
prefs
.
addObserver
(
PREF_ENABLED
this
)
;
Services
.
ppmm
.
addMessageListener
(
"
Marionette
:
IsRunning
"
this
)
;
}
get
running
(
)
{
return
this
.
server
&
&
this
.
server
.
alive
;
}
set
enabled
(
value
)
{
Services
.
prefs
.
setBoolPref
(
PREF_ENABLED
value
)
;
}
get
enabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_ENABLED
)
;
}
receiveMessage
(
{
name
}
)
{
switch
(
name
)
{
case
"
Marionette
:
IsRunning
"
:
return
this
.
running
;
default
:
log
.
warn
(
"
Unknown
IPC
message
to
main
process
:
"
+
name
)
;
return
null
;
}
}
observe
(
subject
topic
)
{
log
.
debug
(
Received
observer
notification
{
topic
}
)
;
switch
(
topic
)
{
case
"
nsPref
:
changed
"
:
if
(
Services
.
prefs
.
getBoolPref
(
PREF_ENABLED
)
)
{
this
.
init
(
)
;
}
else
{
this
.
uninit
(
)
;
}
break
;
case
"
profile
-
after
-
change
"
:
Services
.
obs
.
addObserver
(
this
"
command
-
line
-
startup
"
)
;
Services
.
obs
.
addObserver
(
this
"
sessionstore
-
windows
-
restored
"
)
;
prefs
.
readFromEnvironment
(
ENV_PRESERVE_PREFS
)
;
break
;
case
"
command
-
line
-
startup
"
:
Services
.
obs
.
removeObserver
(
this
topic
)
;
if
(
!
this
.
enabled
&
&
subject
.
handleFlag
(
"
marionette
"
false
)
)
{
this
.
enabled
=
true
;
}
if
(
this
.
enabled
&
&
Services
.
appinfo
.
inSafeMode
)
{
Services
.
obs
.
addObserver
(
this
"
domwindowopened
"
)
;
}
break
;
case
"
domwindowclosed
"
:
if
(
this
.
gfxWindow
=
=
=
null
|
|
subject
=
=
=
this
.
gfxWindow
)
{
Services
.
obs
.
removeObserver
(
this
topic
)
;
Services
.
obs
.
addObserver
(
this
"
xpcom
-
will
-
shutdown
"
)
;
this
.
finalUIStartup
=
true
;
this
.
init
(
)
;
}
break
;
case
"
domwindowopened
"
:
Services
.
obs
.
removeObserver
(
this
topic
)
;
this
.
suppressSafeModeDialog
(
subject
)
;
break
;
case
"
sessionstore
-
windows
-
restored
"
:
Services
.
obs
.
removeObserver
(
this
topic
)
;
let
winEn
=
Services
.
wm
.
getEnumerator
(
null
)
;
while
(
winEn
.
hasMoreElements
(
)
)
{
let
win
=
winEn
.
getNext
(
)
;
if
(
win
.
document
.
documentURI
=
=
"
chrome
:
/
/
gfxsanity
/
content
/
sanityparent
.
html
"
)
{
this
.
gfxWindow
=
win
;
break
;
}
}
if
(
this
.
gfxWindow
)
{
Services
.
obs
.
addObserver
(
this
"
domwindowclosed
"
)
;
}
else
{
Services
.
obs
.
addObserver
(
this
"
xpcom
-
will
-
shutdown
"
)
;
this
.
finalUIStartup
=
true
;
this
.
init
(
)
;
}
break
;
case
"
xpcom
-
will
-
shutdown
"
:
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
will
-
shutdown
"
)
;
this
.
uninit
(
)
;
break
;
}
}
suppressSafeModeDialog
(
win
)
{
win
.
addEventListener
(
"
load
"
(
)
=
>
{
if
(
win
.
document
.
getElementById
(
"
safeModeDialog
"
)
)
{
log
.
debug
(
"
Safe
mode
detected
supressing
dialog
"
)
;
win
.
setTimeout
(
(
)
=
>
{
win
.
document
.
documentElement
.
getButton
(
"
accept
"
)
.
click
(
)
;
}
)
;
}
}
{
once
:
true
}
)
;
}
init
(
)
{
if
(
this
.
running
|
|
!
this
.
enabled
|
|
!
this
.
finalUIStartup
)
{
return
;
}
Services
.
tm
.
idleDispatchToMainThread
(
async
(
)
=
>
{
let
startupRecorder
=
Promise
.
resolve
(
)
;
if
(
"
mozilla
.
org
/
test
/
startuprecorder
;
1
"
in
Cc
)
{
startupRecorder
=
Cc
[
"
mozilla
.
org
/
test
/
startuprecorder
;
1
"
]
.
getService
(
)
.
wrappedJSObject
.
done
;
}
await
startupRecorder
;
if
(
Preferences
.
get
(
PREF_RECOMMENDED
)
)
{
for
(
let
[
k
v
]
of
RECOMMENDED_PREFS
)
{
if
(
!
Preferences
.
isSet
(
k
)
)
{
log
.
debug
(
Setting
recommended
pref
{
k
}
to
{
v
}
)
;
Preferences
.
set
(
k
v
)
;
this
.
alteredPrefs
.
add
(
k
)
;
}
}
}
try
{
ChromeUtils
.
import
(
"
chrome
:
/
/
marionette
/
content
/
server
.
js
"
)
;
let
listener
=
new
server
.
TCPListener
(
prefs
.
port
)
;
listener
.
start
(
)
;
this
.
server
=
listener
;
}
catch
(
e
)
{
log
.
fatal
(
"
Remote
protocol
server
failed
to
start
"
e
)
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eForceQuit
)
;
}
env
.
set
(
ENV_ENABLED
"
1
"
)
;
Services
.
obs
.
notifyObservers
(
this
NOTIFY_RUNNING
true
)
;
log
.
info
(
Listening
on
port
{
this
.
server
.
port
}
)
;
}
)
;
}
uninit
(
)
{
if
(
this
.
running
)
{
this
.
server
.
stop
(
)
;
for
(
let
k
of
this
.
alteredPrefs
)
{
log
.
debug
(
Resetting
recommended
pref
{
k
}
)
;
Preferences
.
reset
(
k
)
;
}
this
.
alteredPrefs
.
clear
(
)
;
Services
.
obs
.
notifyObservers
(
this
NOTIFY_RUNNING
)
;
}
}
get
QueryInterface
(
)
{
return
XPCOMUtils
.
generateQI
(
[
Ci
.
nsICommandLineHandler
Ci
.
nsIMarionette
Ci
.
nsIObserver
]
)
;
}
}
class
MarionetteContentProcess
{
get
running
(
)
{
let
reply
=
Services
.
cpmm
.
sendSyncMessage
(
"
Marionette
:
IsRunning
"
)
;
if
(
reply
.
length
=
=
0
)
{
log
.
warn
(
"
No
reply
from
main
process
"
)
;
return
false
;
}
return
reply
[
0
]
;
}
get
QueryInterface
(
)
{
return
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIMarionette
]
)
;
}
}
const
MarionetteFactory
=
{
instance_
:
null
createInstance
(
outer
iid
)
{
if
(
outer
)
{
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
}
if
(
!
this
.
instance_
)
{
if
(
isRemote
)
{
this
.
instance_
=
new
MarionetteContentProcess
(
)
;
}
else
{
this
.
instance_
=
new
MarionetteMainProcess
(
)
;
}
}
return
this
.
instance_
.
QueryInterface
(
iid
)
;
}
}
;
function
Marionette
(
)
{
}
Marionette
.
prototype
=
{
classDescription
:
"
Marionette
component
"
classID
:
Components
.
ID
(
"
{
786a1369
-
dca5
-
4adc
-
8486
-
33d23c88010a
}
"
)
contractID
:
"
mozilla
.
org
/
remote
/
marionette
;
1
"
_xpcom_factory
:
MarionetteFactory
_xpcom_categories
:
[
{
category
:
"
command
-
line
-
handler
"
entry
:
"
b
-
marionette
"
}
{
category
:
"
profile
-
after
-
change
"
service
:
true
}
]
helpInfo
:
"
-
-
marionette
Enable
remote
control
server
.
\
n
"
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
Marionette
]
)
;
