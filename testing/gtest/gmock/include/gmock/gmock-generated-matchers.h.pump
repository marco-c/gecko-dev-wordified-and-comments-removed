-
*
-
mode
:
c
+
+
;
-
*
-
This
is
a
Pump
source
file
.
Please
use
Pump
to
convert
it
to
gmock
-
generated
-
matchers
.
h
.
var
n
=
10
The
maximum
arity
we
support
.
}
}
This
line
fixes
auto
-
indentation
of
the
following
code
in
Emacs
.
#
ifndef
GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_
#
define
GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_
#
include
<
iterator
>
#
include
<
sstream
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
gmock
/
gmock
-
matchers
.
h
"
namespace
testing
{
namespace
internal
{
range
i
0
.
.
n
-
1
#
define
GMOCK_FIELD_TYPE_
(
Tuple
i
)
\
typename
:
:
testing
:
:
tuple_element
<
i
Tuple
>
:
:
type
template
<
class
Tuple
for
i
[
[
int
k
i
=
-
1
]
]
>
class
TupleFields
;
template
<
class
Tuple
for
i
[
[
int
k
i
]
]
>
class
TupleFields
{
public
:
typedef
:
:
testing
:
:
tuple
<
for
i
[
[
GMOCK_FIELD_TYPE_
(
Tuple
k
i
)
]
]
>
type
;
static
type
GetSelectedFields
(
const
Tuple
&
t
)
{
return
type
(
for
i
[
[
get
<
k
i
>
(
t
)
]
]
)
;
}
}
;
for
i
[
[
}
}
}
range
j
0
.
.
i
-
1
range
k
0
.
.
n
-
1
template
<
class
Tuple
for
j
[
[
int
k
j
]
]
>
class
TupleFields
<
Tuple
for
k
[
[
if
k
<
i
[
[
k
k
]
]
else
[
[
-
1
]
]
]
]
>
{
public
:
typedef
:
:
testing
:
:
tuple
<
for
j
[
[
GMOCK_FIELD_TYPE_
(
Tuple
k
j
)
]
]
>
type
;
static
type
GetSelectedFields
(
const
Tuple
&
if
i
=
=
0
[
[
]
]
else
[
[
t
]
]
)
{
return
type
(
for
j
[
[
get
<
k
j
>
(
t
)
]
]
)
;
}
}
;
]
]
#
undef
GMOCK_FIELD_TYPE_
var
ks
=
[
[
for
i
[
[
k
i
]
]
]
]
template
<
class
ArgsTuple
for
i
[
[
int
k
i
=
-
1
]
]
>
class
ArgsMatcherImpl
:
public
MatcherInterface
<
ArgsTuple
>
{
public
:
typedef
GTEST_REMOVE_REFERENCE_AND_CONST_
(
ArgsTuple
)
RawArgsTuple
;
typedef
typename
internal
:
:
TupleFields
<
RawArgsTuple
ks
>
:
:
type
SelectedArgs
;
typedef
Matcher
<
const
SelectedArgs
&
>
MonomorphicInnerMatcher
;
template
<
typename
InnerMatcher
>
explicit
ArgsMatcherImpl
(
const
InnerMatcher
&
inner_matcher
)
:
inner_matcher_
(
SafeMatcherCast
<
const
SelectedArgs
&
>
(
inner_matcher
)
)
{
}
virtual
bool
MatchAndExplain
(
ArgsTuple
args
MatchResultListener
*
listener
)
const
{
const
SelectedArgs
&
selected_args
=
GetSelectedArgs
(
args
)
;
if
(
!
listener
-
>
IsInterested
(
)
)
return
inner_matcher_
.
Matches
(
selected_args
)
;
PrintIndices
(
listener
-
>
stream
(
)
)
;
*
listener
<
<
"
are
"
<
<
PrintToString
(
selected_args
)
;
StringMatchResultListener
inner_listener
;
const
bool
match
=
inner_matcher_
.
MatchAndExplain
(
selected_args
&
inner_listener
)
;
PrintIfNotEmpty
(
inner_listener
.
str
(
)
listener
-
>
stream
(
)
)
;
return
match
;
}
virtual
void
DescribeTo
(
:
:
std
:
:
ostream
*
os
)
const
{
*
os
<
<
"
are
a
tuple
"
;
PrintIndices
(
os
)
;
inner_matcher_
.
DescribeTo
(
os
)
;
}
virtual
void
DescribeNegationTo
(
:
:
std
:
:
ostream
*
os
)
const
{
*
os
<
<
"
are
a
tuple
"
;
PrintIndices
(
os
)
;
inner_matcher_
.
DescribeNegationTo
(
os
)
;
}
private
:
static
SelectedArgs
GetSelectedArgs
(
ArgsTuple
args
)
{
return
TupleFields
<
RawArgsTuple
ks
>
:
:
GetSelectedFields
(
args
)
;
}
static
void
PrintIndices
(
:
:
std
:
:
ostream
*
os
)
{
*
os
<
<
"
whose
fields
(
"
;
const
int
indices
[
n
]
=
{
ks
}
;
for
(
int
i
=
0
;
i
<
n
;
i
+
+
)
{
if
(
indices
[
i
]
<
0
)
break
;
if
(
i
>
=
1
)
*
os
<
<
"
"
;
*
os
<
<
"
#
"
<
<
indices
[
i
]
;
}
*
os
<
<
"
)
"
;
}
const
MonomorphicInnerMatcher
inner_matcher_
;
GTEST_DISALLOW_ASSIGN_
(
ArgsMatcherImpl
)
;
}
;
template
<
class
InnerMatcher
for
i
[
[
int
k
i
=
-
1
]
]
>
class
ArgsMatcher
{
public
:
explicit
ArgsMatcher
(
const
InnerMatcher
&
inner_matcher
)
:
inner_matcher_
(
inner_matcher
)
{
}
template
<
typename
ArgsTuple
>
operator
Matcher
<
ArgsTuple
>
(
)
const
{
return
MakeMatcher
(
new
ArgsMatcherImpl
<
ArgsTuple
ks
>
(
inner_matcher_
)
)
;
}
private
:
const
InnerMatcher
inner_matcher_
;
GTEST_DISALLOW_ASSIGN_
(
ArgsMatcher
)
;
}
;
template
<
typename
M1
>
struct
AllOfResult1
{
typedef
M1
type
;
}
;
range
i
1
.
.
n
range
i
2
.
.
n
for
i
[
[
range
j
2
.
.
i
var
m
=
i
/
2
range
k
1
.
.
m
range
t
m
+
1
.
.
i
template
<
typename
M1
for
j
[
[
typename
M
j
]
]
>
struct
AllOfResult
i
{
typedef
BothOfMatcher
<
typename
AllOfResult
m
<
for
k
[
[
M
k
]
]
>
:
:
type
typename
AllOfResult
(
i
-
m
)
<
for
t
[
[
M
t
]
]
>
:
:
type
>
type
;
}
;
]
]
template
<
typename
M1
>
struct
AnyOfResult1
{
typedef
M1
type
;
}
;
range
i
1
.
.
n
range
i
2
.
.
n
for
i
[
[
range
j
2
.
.
i
var
m
=
i
/
2
range
k
1
.
.
m
range
t
m
+
1
.
.
i
template
<
typename
M1
for
j
[
[
typename
M
j
]
]
>
struct
AnyOfResult
i
{
typedef
EitherOfMatcher
<
typename
AnyOfResult
m
<
for
k
[
[
M
k
]
]
>
:
:
type
typename
AnyOfResult
(
i
-
m
)
<
for
t
[
[
M
t
]
]
>
:
:
type
>
type
;
}
;
]
]
}
range
i
0
.
.
n
for
i
[
[
range
j
1
.
.
i
template
<
for
j
[
[
int
k
j
]
]
typename
InnerMatcher
>
inline
internal
:
:
ArgsMatcher
<
InnerMatcher
for
j
[
[
k
j
]
]
>
Args
(
const
InnerMatcher
&
matcher
)
{
return
internal
:
:
ArgsMatcher
<
InnerMatcher
for
j
[
[
k
j
]
]
>
(
matcher
)
;
}
]
]
range
i
0
.
.
n
for
i
[
[
range
j
1
.
.
i
if
i
>
0
[
[
template
<
for
j
[
[
typename
T
j
]
]
>
]
]
inline
internal
:
:
ElementsAreMatcher
<
:
:
testing
:
:
tuple
<
for
j
[
[
typename
internal
:
:
DecayArray
<
T
j
[
[
]
]
>
:
:
type
]
]
>
>
ElementsAre
(
for
j
[
[
const
T
j
&
e
j
]
]
)
{
typedef
:
:
testing
:
:
tuple
<
for
j
[
[
typename
internal
:
:
DecayArray
<
T
j
[
[
]
]
>
:
:
type
]
]
>
Args
;
return
internal
:
:
ElementsAreMatcher
<
Args
>
(
Args
(
for
j
[
[
e
j
]
]
)
)
;
}
]
]
range
i
0
.
.
n
for
i
[
[
range
j
1
.
.
i
if
i
>
0
[
[
template
<
for
j
[
[
typename
T
j
]
]
>
]
]
inline
internal
:
:
UnorderedElementsAreMatcher
<
:
:
testing
:
:
tuple
<
for
j
[
[
typename
internal
:
:
DecayArray
<
T
j
[
[
]
]
>
:
:
type
]
]
>
>
UnorderedElementsAre
(
for
j
[
[
const
T
j
&
e
j
]
]
)
{
typedef
:
:
testing
:
:
tuple
<
for
j
[
[
typename
internal
:
:
DecayArray
<
T
j
[
[
]
]
>
:
:
type
]
]
>
Args
;
return
internal
:
:
UnorderedElementsAreMatcher
<
Args
>
(
Args
(
for
j
[
[
e
j
]
]
)
)
;
}
]
]
range
i
2
.
.
n
for
i
[
[
range
j
1
.
.
i
var
m
=
i
/
2
range
k
1
.
.
m
range
t
m
+
1
.
.
i
template
<
for
j
[
[
typename
M
j
]
]
>
inline
typename
internal
:
:
AllOfResult
i
<
for
j
[
[
M
j
]
]
>
:
:
type
AllOf
(
for
j
[
[
M
j
m
j
]
]
)
{
return
typename
internal
:
:
AllOfResult
i
<
for
j
[
[
M
j
]
]
>
:
:
type
(
if
m
=
=
1
[
[
m1
]
]
else
[
[
:
:
testing
:
:
AllOf
(
for
k
[
[
m
k
]
]
)
]
]
if
m
+
1
=
=
i
[
[
m
i
]
]
else
[
[
:
:
testing
:
:
AllOf
(
for
t
[
[
m
t
]
]
)
]
]
)
;
}
]
]
range
i
2
.
.
n
for
i
[
[
range
j
1
.
.
i
var
m
=
i
/
2
range
k
1
.
.
m
range
t
m
+
1
.
.
i
template
<
for
j
[
[
typename
M
j
]
]
>
inline
typename
internal
:
:
AnyOfResult
i
<
for
j
[
[
M
j
]
]
>
:
:
type
AnyOf
(
for
j
[
[
M
j
m
j
]
]
)
{
return
typename
internal
:
:
AnyOfResult
i
<
for
j
[
[
M
j
]
]
>
:
:
type
(
if
m
=
=
1
[
[
m1
]
]
else
[
[
:
:
testing
:
:
AnyOf
(
for
k
[
[
m
k
]
]
)
]
]
if
m
+
1
=
=
i
[
[
m
i
]
]
else
[
[
:
:
testing
:
:
AnyOf
(
for
t
[
[
m
t
]
]
)
]
]
)
;
}
]
]
}
}
range
i
0
.
.
n
for
i
[
[
var
macro_name
=
[
[
if
i
=
=
0
[
[
MATCHER
]
]
elif
i
=
=
1
[
[
MATCHER_P
]
]
else
[
[
MATCHER_P
i
]
]
]
]
var
class_name
=
[
[
name
#
#
Matcher
[
[
if
i
=
=
0
[
[
]
]
elif
i
=
=
1
[
[
P
]
]
else
[
[
P
i
]
]
]
]
]
]
range
j
0
.
.
i
-
1
var
template
=
[
[
if
i
=
=
0
[
[
]
]
else
[
[
template
<
for
j
[
[
typename
p
j
#
#
_type
]
]
>
\
]
]
]
]
var
ctor_param_list
=
[
[
for
j
[
[
p
j
#
#
_type
gmock_p
j
]
]
]
]
var
impl_ctor_param_list
=
[
[
for
j
[
[
p
j
#
#
_type
gmock_p
j
]
]
]
]
var
impl_inits
=
[
[
if
i
=
=
0
[
[
]
]
else
[
[
:
for
j
[
[
p
j
(
:
:
testing
:
:
internal
:
:
move
(
gmock_p
j
)
)
]
]
]
]
]
]
var
inits
=
[
[
if
i
=
=
0
[
[
]
]
else
[
[
:
for
j
[
[
p
j
(
:
:
testing
:
:
internal
:
:
move
(
gmock_p
j
)
)
]
]
]
]
]
]
var
params
=
[
[
for
j
[
[
p
j
]
]
]
]
var
param_types
=
[
[
if
i
=
=
0
[
[
]
]
else
[
[
<
for
j
[
[
p
j
#
#
_type
]
]
>
]
]
]
]
var
param_types_and_names
=
[
[
for
j
[
[
p
j
#
#
_type
p
j
]
]
]
]
var
param_field_decls
=
[
[
for
j
[
[
p
j
#
#
_type
const
p
j
;
\
]
]
]
]
var
param_field_decls2
=
[
[
for
j
[
[
p
j
#
#
_type
const
p
j
;
\
]
]
]
]
#
define
macro_name
(
name
for
j
[
[
p
j
]
]
description
)
\
template
class
class_name
{
\
public
:
\
template
<
typename
arg_type
>
\
class
gmock_Impl
:
public
:
:
testing
:
:
MatcherInterface
<
\
GTEST_REFERENCE_TO_CONST_
(
arg_type
)
>
{
\
public
:
\
[
[
if
i
=
=
1
[
[
explicit
]
]
]
]
gmock_Impl
(
impl_ctor_param_list
)
\
impl_inits
{
}
\
virtual
bool
MatchAndExplain
(
\
GTEST_REFERENCE_TO_CONST_
(
arg_type
)
arg
\
:
:
testing
:
:
MatchResultListener
*
result_listener
)
const
;
\
virtual
void
DescribeTo
(
:
:
std
:
:
ostream
*
gmock_os
)
const
{
\
*
gmock_os
<
<
FormatDescription
(
false
)
;
\
}
\
virtual
void
DescribeNegationTo
(
:
:
std
:
:
ostream
*
gmock_os
)
const
{
\
*
gmock_os
<
<
FormatDescription
(
true
)
;
\
}
\
param_field_decls
private
:
\
:
:
std
:
:
string
FormatDescription
(
bool
negation
)
const
{
\
:
:
std
:
:
string
gmock_description
=
(
description
)
;
\
if
(
!
gmock_description
.
empty
(
)
)
\
return
gmock_description
;
\
return
:
:
testing
:
:
internal
:
:
FormatMatcherDescription
(
\
negation
#
name
\
:
:
testing
:
:
internal
:
:
UniversalTersePrintTupleFieldsToStrings
(
\
:
:
testing
:
:
tuple
<
for
j
[
[
p
j
#
#
_type
]
]
>
(
for
j
[
[
p
j
]
]
)
)
)
;
\
}
\
}
;
\
template
<
typename
arg_type
>
\
operator
:
:
testing
:
:
Matcher
<
arg_type
>
(
)
const
{
\
return
:
:
testing
:
:
Matcher
<
arg_type
>
(
\
new
gmock_Impl
<
arg_type
>
(
params
)
)
;
\
}
\
[
[
if
i
=
=
1
[
[
explicit
]
]
]
]
class_name
(
ctor_param_list
)
inits
{
\
}
\
param_field_decls2
private
:
\
}
;
\
template
inline
class_name
param_types
name
(
param_types_and_names
)
{
\
return
class_name
param_types
(
params
)
;
\
}
\
template
template
<
typename
arg_type
>
\
bool
class_name
param_types
:
:
gmock_Impl
<
arg_type
>
:
:
MatchAndExplain
(
\
GTEST_REFERENCE_TO_CONST_
(
arg_type
)
arg
\
:
:
testing
:
:
MatchResultListener
*
result_listener
GTEST_ATTRIBUTE_UNUSED_
)
\
const
]
]
#
endif
