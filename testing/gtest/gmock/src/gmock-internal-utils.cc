#
include
"
gmock
/
internal
/
gmock
-
internal
-
utils
.
h
"
#
include
<
ctype
.
h
>
#
include
<
ostream
>
#
include
<
string
>
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gmock
/
internal
/
gmock
-
port
.
h
"
#
include
"
gtest
/
gtest
.
h
"
namespace
testing
{
namespace
internal
{
GTEST_API_
std
:
:
string
JoinAsTuple
(
const
Strings
&
fields
)
{
switch
(
fields
.
size
(
)
)
{
case
0
:
return
"
"
;
case
1
:
return
fields
[
0
]
;
default
:
std
:
:
string
result
=
"
(
"
+
fields
[
0
]
;
for
(
size_t
i
=
1
;
i
<
fields
.
size
(
)
;
i
+
+
)
{
result
+
=
"
"
;
result
+
=
fields
[
i
]
;
}
result
+
=
"
)
"
;
return
result
;
}
}
GTEST_API_
std
:
:
string
ConvertIdentifierNameToWords
(
const
char
*
id_name
)
{
std
:
:
string
result
;
char
prev_char
=
'
\
0
'
;
for
(
const
char
*
p
=
id_name
;
*
p
!
=
'
\
0
'
;
prev_char
=
*
(
p
+
+
)
)
{
const
bool
starts_new_word
=
IsUpper
(
*
p
)
|
|
(
!
IsAlpha
(
prev_char
)
&
&
IsLower
(
*
p
)
)
|
|
(
!
IsDigit
(
prev_char
)
&
&
IsDigit
(
*
p
)
)
;
if
(
IsAlNum
(
*
p
)
)
{
if
(
starts_new_word
&
&
result
!
=
"
"
)
result
+
=
'
'
;
result
+
=
ToLower
(
*
p
)
;
}
}
return
result
;
}
class
GoogleTestFailureReporter
:
public
FailureReporterInterface
{
public
:
virtual
void
ReportFailure
(
FailureType
type
const
char
*
file
int
line
const
std
:
:
string
&
message
)
{
AssertHelper
(
type
=
=
kFatal
?
TestPartResult
:
:
kFatalFailure
:
TestPartResult
:
:
kNonFatalFailure
file
line
message
.
c_str
(
)
)
=
Message
(
)
;
if
(
type
=
=
kFatal
)
{
posix
:
:
Abort
(
)
;
}
}
}
;
GTEST_API_
FailureReporterInterface
*
GetFailureReporter
(
)
{
static
FailureReporterInterface
*
const
failure_reporter
=
new
GoogleTestFailureReporter
(
)
;
return
failure_reporter
;
}
static
GTEST_DEFINE_STATIC_MUTEX_
(
g_log_mutex
)
;
GTEST_API_
bool
LogIsVisible
(
LogSeverity
severity
)
{
if
(
GMOCK_FLAG
(
verbose
)
=
=
kInfoVerbosity
)
{
return
true
;
}
else
if
(
GMOCK_FLAG
(
verbose
)
=
=
kErrorVerbosity
)
{
return
false
;
}
else
{
return
severity
=
=
kWarning
;
}
}
GTEST_API_
void
Log
(
LogSeverity
severity
const
std
:
:
string
&
message
int
stack_frames_to_skip
)
{
if
(
!
LogIsVisible
(
severity
)
)
return
;
MutexLock
l
(
&
g_log_mutex
)
;
if
(
severity
=
=
kWarning
)
{
std
:
:
cout
<
<
"
\
nGMOCK
WARNING
:
"
;
}
if
(
message
.
empty
(
)
|
|
message
[
0
]
!
=
'
\
n
'
)
{
std
:
:
cout
<
<
"
\
n
"
;
}
std
:
:
cout
<
<
message
;
if
(
stack_frames_to_skip
>
=
0
)
{
#
ifdef
NDEBUG
const
int
actual_to_skip
=
0
;
#
else
const
int
actual_to_skip
=
stack_frames_to_skip
+
1
;
#
endif
if
(
!
message
.
empty
(
)
&
&
*
message
.
rbegin
(
)
!
=
'
\
n
'
)
{
std
:
:
cout
<
<
"
\
n
"
;
}
std
:
:
cout
<
<
"
Stack
trace
:
\
n
"
<
<
:
:
testing
:
:
internal
:
:
GetCurrentOsStackTraceExceptTop
(
:
:
testing
:
:
UnitTest
:
:
GetInstance
(
)
actual_to_skip
)
;
}
std
:
:
cout
<
<
:
:
std
:
:
flush
;
}
GTEST_API_
WithoutMatchers
GetWithoutMatchers
(
)
{
return
WithoutMatchers
(
)
;
}
GTEST_API_
void
IllegalDoDefault
(
const
char
*
file
int
line
)
{
internal
:
:
Assert
(
false
file
line
"
You
are
using
DoDefault
(
)
inside
a
composite
action
like
"
"
DoAll
(
)
or
WithArgs
(
)
.
This
is
not
supported
for
technical
"
"
reasons
.
Please
instead
spell
out
the
default
action
or
"
"
assign
the
default
action
to
an
Action
variable
and
use
"
"
the
variable
in
various
places
.
"
)
;
}
}
}
