-
*
-
mode
:
c
+
+
;
-
*
-
var
n
=
10
Maximum
number
of
tuple
fields
we
want
to
support
.
This
meta
comment
fixes
auto
-
indentation
in
Emacs
.
}
}
#
ifndef
GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_
#
define
GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_
#
include
<
utility
>
#
if
defined
(
__SYMBIAN32__
)
|
|
(
defined
(
__SUNPRO_CC
)
&
&
__SUNPRO_CC
<
0x590
)
#
define
GTEST_DECLARE_TUPLE_AS_FRIEND_
public
:
#
else
#
define
GTEST_DECLARE_TUPLE_AS_FRIEND_
\
template
<
GTEST_
(
n
)
_TYPENAMES_
(
U
)
>
friend
class
tuple
;
\
private
:
#
endif
#
if
defined
(
_MSC_VER
)
&
&
_MSC_VER
>
=
1600
#
error
"
gtest
'
s
tuple
doesn
'
t
compile
on
Visual
Studio
2010
or
later
.
\
GTEST_USE_OWN_TR1_TUPLE
must
be
set
to
0
on
those
compilers
.
"
#
endif
range
i
0
.
.
n
-
1
range
j
0
.
.
n
range
k
1
.
.
n
#
define
GTEST_0_TUPLE_
(
T
)
tuple
<
>
for
k
[
[
range
m
0
.
.
k
-
1
range
m2
k
.
.
n
-
1
#
define
GTEST_
(
k
)
_TUPLE_
(
T
)
tuple
<
for
m
[
[
T
#
#
m
]
]
for
m2
[
[
void
]
]
>
]
]
for
j
[
[
range
m
0
.
.
j
-
1
#
define
GTEST_
(
j
)
_TYPENAMES_
(
T
)
for
m
[
[
typename
T
#
#
m
]
]
]
]
namespace
std
{
namespace
tr1
{
template
<
for
i
[
[
typename
T
i
=
void
]
]
>
class
tuple
;
namespace
gtest_internal
{
template
<
typename
T
>
struct
ByRef
{
typedef
const
T
&
type
;
}
;
template
<
typename
T
>
struct
ByRef
<
T
&
>
{
typedef
T
&
type
;
}
;
#
define
GTEST_BY_REF_
(
T
)
typename
:
:
std
:
:
tr1
:
:
gtest_internal
:
:
ByRef
<
T
>
:
:
type
template
<
typename
T
>
struct
AddRef
{
typedef
T
&
type
;
}
;
template
<
typename
T
>
struct
AddRef
<
T
&
>
{
typedef
T
&
type
;
}
;
#
define
GTEST_ADD_REF_
(
T
)
typename
:
:
std
:
:
tr1
:
:
gtest_internal
:
:
AddRef
<
T
>
:
:
type
template
<
int
k
>
class
Get
;
template
<
bool
kIndexValid
int
kIndex
class
Tuple
>
struct
TupleElement
;
for
i
[
[
template
<
GTEST_
(
n
)
_TYPENAMES_
(
T
)
>
struct
TupleElement
<
true
i
GTEST_
(
n
)
_TUPLE_
(
T
)
>
{
typedef
T
i
type
;
}
;
]
]
}
template
<
>
class
tuple
<
>
{
public
:
tuple
(
)
{
}
tuple
(
const
tuple
&
)
{
}
tuple
&
operator
=
(
const
tuple
&
)
{
return
*
this
;
}
}
;
for
k
[
[
range
m
0
.
.
k
-
1
template
<
GTEST_
(
k
)
_TYPENAMES_
(
T
)
>
class
if
k
<
n
[
[
GTEST_
(
k
)
_TUPLE_
(
T
)
]
]
else
[
[
tuple
]
]
{
public
:
template
<
int
k
>
friend
class
gtest_internal
:
:
Get
;
tuple
(
)
:
for
m
[
[
f
(
m
)
_
(
)
]
]
{
}
explicit
tuple
(
for
m
[
[
GTEST_BY_REF_
(
T
m
)
f
m
]
]
)
:
[
[
]
]
for
m
[
[
f
(
m
)
_
(
f
m
)
]
]
{
}
tuple
(
const
tuple
&
t
)
:
for
m
[
[
f
(
m
)
_
(
t
.
f
(
m
)
_
)
]
]
{
}
template
<
GTEST_
(
k
)
_TYPENAMES_
(
U
)
>
tuple
(
const
GTEST_
(
k
)
_TUPLE_
(
U
)
&
t
)
:
for
m
[
[
f
(
m
)
_
(
t
.
f
(
m
)
_
)
]
]
{
}
if
k
=
=
2
[
[
template
<
typename
U0
typename
U1
>
tuple
(
const
:
:
std
:
:
pair
<
U0
U1
>
&
p
)
:
f0_
(
p
.
first
)
f1_
(
p
.
second
)
{
}
]
]
tuple
&
operator
=
(
const
tuple
&
t
)
{
return
CopyFrom
(
t
)
;
}
template
<
GTEST_
(
k
)
_TYPENAMES_
(
U
)
>
tuple
&
operator
=
(
const
GTEST_
(
k
)
_TUPLE_
(
U
)
&
t
)
{
return
CopyFrom
(
t
)
;
}
if
k
=
=
2
[
[
template
<
typename
U0
typename
U1
>
tuple
&
operator
=
(
const
:
:
std
:
:
pair
<
U0
U1
>
&
p
)
{
f0_
=
p
.
first
;
f1_
=
p
.
second
;
return
*
this
;
}
]
]
GTEST_DECLARE_TUPLE_AS_FRIEND_
template
<
GTEST_
(
k
)
_TYPENAMES_
(
U
)
>
tuple
&
CopyFrom
(
const
GTEST_
(
k
)
_TUPLE_
(
U
)
&
t
)
{
for
m
[
[
f
(
m
)
_
=
t
.
f
(
m
)
_
;
]
]
return
*
this
;
}
for
m
[
[
T
m
f
(
m
)
_
;
]
]
}
;
]
]
inline
tuple
<
>
make_tuple
(
)
{
return
tuple
<
>
(
)
;
}
for
k
[
[
range
m
0
.
.
k
-
1
template
<
GTEST_
(
k
)
_TYPENAMES_
(
T
)
>
inline
GTEST_
(
k
)
_TUPLE_
(
T
)
make_tuple
(
for
m
[
[
const
T
m
&
f
m
]
]
)
{
return
GTEST_
(
k
)
_TUPLE_
(
T
)
(
for
m
[
[
f
m
]
]
)
;
}
]
]
template
<
typename
Tuple
>
struct
tuple_size
;
for
j
[
[
template
<
GTEST_
(
j
)
_TYPENAMES_
(
T
)
>
struct
tuple_size
<
GTEST_
(
j
)
_TUPLE_
(
T
)
>
{
static
const
int
value
=
j
;
}
;
]
]
template
<
int
k
class
Tuple
>
struct
tuple_element
{
typedef
typename
gtest_internal
:
:
TupleElement
<
k
<
(
tuple_size
<
Tuple
>
:
:
value
)
k
Tuple
>
:
:
type
type
;
}
;
#
define
GTEST_TUPLE_ELEMENT_
(
k
Tuple
)
typename
tuple_element
<
k
Tuple
>
:
:
type
namespace
gtest_internal
{
for
i
[
[
template
<
>
class
Get
<
i
>
{
public
:
template
<
class
Tuple
>
static
GTEST_ADD_REF_
(
GTEST_TUPLE_ELEMENT_
(
i
Tuple
)
)
Field
(
Tuple
&
t
)
{
return
t
.
f
(
i
)
_
;
}
template
<
class
Tuple
>
static
GTEST_BY_REF_
(
GTEST_TUPLE_ELEMENT_
(
i
Tuple
)
)
ConstField
(
const
Tuple
&
t
)
{
return
t
.
f
(
i
)
_
;
}
}
;
]
]
}
template
<
int
k
GTEST_
(
n
)
_TYPENAMES_
(
T
)
>
GTEST_ADD_REF_
(
GTEST_TUPLE_ELEMENT_
(
k
GTEST_
(
n
)
_TUPLE_
(
T
)
)
)
get
(
GTEST_
(
n
)
_TUPLE_
(
T
)
&
t
)
{
return
gtest_internal
:
:
Get
<
k
>
:
:
Field
(
t
)
;
}
template
<
int
k
GTEST_
(
n
)
_TYPENAMES_
(
T
)
>
GTEST_BY_REF_
(
GTEST_TUPLE_ELEMENT_
(
k
GTEST_
(
n
)
_TUPLE_
(
T
)
)
)
get
(
const
GTEST_
(
n
)
_TUPLE_
(
T
)
&
t
)
{
return
gtest_internal
:
:
Get
<
k
>
:
:
ConstField
(
t
)
;
}
namespace
gtest_internal
{
template
<
int
kSize1
int
kSize2
>
struct
SameSizeTuplePrefixComparator
;
template
<
>
struct
SameSizeTuplePrefixComparator
<
0
0
>
{
template
<
class
Tuple1
class
Tuple2
>
static
bool
Eq
(
const
Tuple1
&
const
Tuple2
&
)
{
return
true
;
}
}
;
template
<
int
k
>
struct
SameSizeTuplePrefixComparator
<
k
k
>
{
template
<
class
Tuple1
class
Tuple2
>
static
bool
Eq
(
const
Tuple1
&
t1
const
Tuple2
&
t2
)
{
return
SameSizeTuplePrefixComparator
<
k
-
1
k
-
1
>
:
:
Eq
(
t1
t2
)
&
&
:
:
std
:
:
tr1
:
:
get
<
k
-
1
>
(
t1
)
=
=
:
:
std
:
:
tr1
:
:
get
<
k
-
1
>
(
t2
)
;
}
}
;
}
template
<
GTEST_
(
n
)
_TYPENAMES_
(
T
)
GTEST_
(
n
)
_TYPENAMES_
(
U
)
>
inline
bool
operator
=
=
(
const
GTEST_
(
n
)
_TUPLE_
(
T
)
&
t
const
GTEST_
(
n
)
_TUPLE_
(
U
)
&
u
)
{
return
gtest_internal
:
:
SameSizeTuplePrefixComparator
<
tuple_size
<
GTEST_
(
n
)
_TUPLE_
(
T
)
>
:
:
value
tuple_size
<
GTEST_
(
n
)
_TUPLE_
(
U
)
>
:
:
value
>
:
:
Eq
(
t
u
)
;
}
template
<
GTEST_
(
n
)
_TYPENAMES_
(
T
)
GTEST_
(
n
)
_TYPENAMES_
(
U
)
>
inline
bool
operator
!
=
(
const
GTEST_
(
n
)
_TUPLE_
(
T
)
&
t
const
GTEST_
(
n
)
_TUPLE_
(
U
)
&
u
)
{
return
!
(
t
=
=
u
)
;
}
}
}
for
j
[
[
#
undef
GTEST_
(
j
)
_TUPLE_
]
]
for
j
[
[
#
undef
GTEST_
(
j
)
_TYPENAMES_
]
]
#
undef
GTEST_DECLARE_TUPLE_AS_FRIEND_
#
undef
GTEST_BY_REF_
#
undef
GTEST_ADD_REF_
#
undef
GTEST_TUPLE_ELEMENT_
#
endif
