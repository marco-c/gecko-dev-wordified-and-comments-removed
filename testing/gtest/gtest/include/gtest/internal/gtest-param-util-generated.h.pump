-
*
-
mode
:
c
+
+
;
-
*
-
var
n
=
50
Maximum
length
of
Values
arguments
we
want
to
support
.
var
maxtuple
=
10
Maximum
number
of
Combine
arguments
we
want
to
support
.
#
ifndef
GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_
#
define
GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_
#
include
"
gtest
/
internal
/
gtest
-
param
-
util
.
h
"
#
include
"
gtest
/
internal
/
gtest
-
port
.
h
"
namespace
testing
{
template
<
typename
ForwardIterator
>
internal
:
:
ParamGenerator
<
typename
:
:
testing
:
:
internal
:
:
IteratorTraits
<
ForwardIterator
>
:
:
value_type
>
ValuesIn
(
ForwardIterator
begin
ForwardIterator
end
)
;
template
<
typename
T
size_t
N
>
internal
:
:
ParamGenerator
<
T
>
ValuesIn
(
const
T
(
&
array
)
[
N
]
)
;
template
<
class
Container
>
internal
:
:
ParamGenerator
<
typename
Container
:
:
value_type
>
ValuesIn
(
const
Container
&
container
)
;
namespace
internal
{
range
i
1
.
.
n
for
i
[
[
range
j
1
.
.
i
template
<
for
j
[
[
typename
T
j
]
]
>
class
ValueArray
i
{
public
:
if
i
=
=
1
[
[
explicit
]
]
ValueArray
i
(
for
j
[
[
T
j
v
j
]
]
)
:
for
j
[
[
v
(
j
)
_
(
v
j
)
]
]
{
}
template
<
typename
T
>
operator
ParamGenerator
<
T
>
(
)
const
{
const
T
array
[
]
=
{
for
j
[
[
static_cast
<
T
>
(
v
(
j
)
_
)
]
]
}
;
return
ValuesIn
(
array
)
;
}
ValueArray
i
(
const
ValueArray
i
&
other
)
:
for
j
[
[
v
(
j
)
_
(
other
.
v
(
j
)
_
)
]
]
{
}
private
:
void
operator
=
(
const
ValueArray
i
&
other
)
;
for
j
[
[
const
T
j
v
(
j
)
_
;
]
]
}
;
]
]
#
if
GTEST_HAS_COMBINE
range
i
2
.
.
maxtuple
for
i
[
[
range
j
1
.
.
i
range
k
2
.
.
i
template
<
for
j
[
[
typename
T
j
]
]
>
class
CartesianProductGenerator
i
:
public
ParamGeneratorInterface
<
:
:
testing
:
:
tuple
<
for
j
[
[
T
j
]
]
>
>
{
public
:
typedef
:
:
testing
:
:
tuple
<
for
j
[
[
T
j
]
]
>
ParamType
;
CartesianProductGenerator
i
(
for
j
[
[
const
ParamGenerator
<
T
j
>
&
g
j
]
]
)
:
for
j
[
[
g
(
j
)
_
(
g
j
)
]
]
{
}
virtual
~
CartesianProductGenerator
i
(
)
{
}
virtual
ParamIteratorInterface
<
ParamType
>
*
Begin
(
)
const
{
return
new
Iterator
(
this
for
j
[
[
g
(
j
)
_
g
(
j
)
_
.
begin
(
)
]
]
)
;
}
virtual
ParamIteratorInterface
<
ParamType
>
*
End
(
)
const
{
return
new
Iterator
(
this
for
j
[
[
g
(
j
)
_
g
(
j
)
_
.
end
(
)
]
]
)
;
}
private
:
class
Iterator
:
public
ParamIteratorInterface
<
ParamType
>
{
public
:
Iterator
(
const
ParamGeneratorInterface
<
ParamType
>
*
base
for
j
[
[
const
ParamGenerator
<
T
j
>
&
g
j
const
typename
ParamGenerator
<
T
j
>
:
:
iterator
&
current
(
j
)
]
]
)
:
base_
(
base
)
for
j
[
[
begin
(
j
)
_
(
g
j
.
begin
(
)
)
end
(
j
)
_
(
g
j
.
end
(
)
)
current
(
j
)
_
(
current
j
)
]
]
{
ComputeCurrentValue
(
)
;
}
virtual
~
Iterator
(
)
{
}
virtual
const
ParamGeneratorInterface
<
ParamType
>
*
BaseGenerator
(
)
const
{
return
base_
;
}
virtual
void
Advance
(
)
{
assert
(
!
AtEnd
(
)
)
;
+
+
current
(
i
)
_
;
for
k
[
[
if
(
current
(
i
+
2
-
k
)
_
=
=
end
(
i
+
2
-
k
)
_
)
{
current
(
i
+
2
-
k
)
_
=
begin
(
i
+
2
-
k
)
_
;
+
+
current
(
i
+
2
-
k
-
1
)
_
;
}
]
]
ComputeCurrentValue
(
)
;
}
virtual
ParamIteratorInterface
<
ParamType
>
*
Clone
(
)
const
{
return
new
Iterator
(
*
this
)
;
}
virtual
const
ParamType
*
Current
(
)
const
{
return
current_value_
.
get
(
)
;
}
virtual
bool
Equals
(
const
ParamIteratorInterface
<
ParamType
>
&
other
)
const
{
GTEST_CHECK_
(
BaseGenerator
(
)
=
=
other
.
BaseGenerator
(
)
)
<
<
"
The
program
attempted
to
compare
iterators
"
<
<
"
from
different
generators
.
"
<
<
std
:
:
endl
;
const
Iterator
*
typed_other
=
CheckedDowncastToActualType
<
const
Iterator
>
(
&
other
)
;
return
(
AtEnd
(
)
&
&
typed_other
-
>
AtEnd
(
)
)
|
|
(
for
j
&
&
[
[
current
(
j
)
_
=
=
typed_other
-
>
current
(
j
)
_
]
]
)
;
}
private
:
Iterator
(
const
Iterator
&
other
)
:
base_
(
other
.
base_
)
for
j
[
[
begin
(
j
)
_
(
other
.
begin
(
j
)
_
)
end
(
j
)
_
(
other
.
end
(
j
)
_
)
current
(
j
)
_
(
other
.
current
(
j
)
_
)
]
]
{
ComputeCurrentValue
(
)
;
}
void
ComputeCurrentValue
(
)
{
if
(
!
AtEnd
(
)
)
current_value_
.
reset
(
new
ParamType
(
for
j
[
[
*
current
(
j
)
_
]
]
)
)
;
}
bool
AtEnd
(
)
const
{
return
for
j
|
|
[
[
current
(
j
)
_
=
=
end
(
j
)
_
]
]
;
}
void
operator
=
(
const
Iterator
&
other
)
;
const
ParamGeneratorInterface
<
ParamType
>
*
const
base_
;
for
j
[
[
const
typename
ParamGenerator
<
T
j
>
:
:
iterator
begin
(
j
)
_
;
const
typename
ParamGenerator
<
T
j
>
:
:
iterator
end
(
j
)
_
;
typename
ParamGenerator
<
T
j
>
:
:
iterator
current
(
j
)
_
;
]
]
linked_ptr
<
ParamType
>
current_value_
;
}
;
void
operator
=
(
const
CartesianProductGenerator
i
&
other
)
;
for
j
[
[
const
ParamGenerator
<
T
j
>
g
(
j
)
_
;
]
]
}
;
]
]
range
i
2
.
.
maxtuple
for
i
[
[
range
j
1
.
.
i
template
<
for
j
[
[
class
Generator
j
]
]
>
class
CartesianProductHolder
i
{
public
:
CartesianProductHolder
i
(
for
j
[
[
const
Generator
j
&
g
j
]
]
)
:
for
j
[
[
g
(
j
)
_
(
g
j
)
]
]
{
}
template
<
for
j
[
[
typename
T
j
]
]
>
operator
ParamGenerator
<
:
:
testing
:
:
tuple
<
for
j
[
[
T
j
]
]
>
>
(
)
const
{
return
ParamGenerator
<
:
:
testing
:
:
tuple
<
for
j
[
[
T
j
]
]
>
>
(
new
CartesianProductGenerator
i
<
for
j
[
[
T
j
]
]
>
(
for
j
[
[
static_cast
<
ParamGenerator
<
T
j
>
>
(
g
(
j
)
_
)
]
]
)
)
;
}
private
:
void
operator
=
(
const
CartesianProductHolder
i
&
other
)
;
for
j
[
[
const
Generator
j
g
(
j
)
_
;
]
]
}
;
]
]
#
endif
}
}
#
endif
