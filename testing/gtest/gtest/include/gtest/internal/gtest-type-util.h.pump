-
*
-
mode
:
c
+
+
;
-
*
-
var
n
=
50
Maximum
length
of
type
lists
we
want
to
support
.
#
ifndef
GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_
#
define
GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_
#
include
"
gtest
/
internal
/
gtest
-
port
.
h
"
#
if
GTEST_HAS_CXXABI_H_
#
include
<
cxxabi
.
h
>
#
elif
defined
(
__HP_aCC
)
#
include
<
acxx_demangle
.
h
>
#
endif
namespace
testing
{
namespace
internal
{
inline
std
:
:
string
CanonicalizeForStdLibVersioning
(
std
:
:
string
s
)
{
static
const
char
prefix
[
]
=
"
std
:
:
__
"
;
if
(
s
.
compare
(
0
strlen
(
prefix
)
prefix
)
=
=
0
)
{
std
:
:
string
:
:
size_type
end
=
s
.
find
(
"
:
:
"
strlen
(
prefix
)
)
;
if
(
end
!
=
s
.
npos
)
{
s
.
erase
(
strlen
(
"
std
"
)
end
-
strlen
(
"
std
"
)
)
;
}
}
return
s
;
}
template
<
typename
T
>
std
:
:
string
GetTypeName
(
)
{
#
if
GTEST_HAS_RTTI
const
char
*
const
name
=
typeid
(
T
)
.
name
(
)
;
#
if
GTEST_HAS_CXXABI_H_
|
|
defined
(
__HP_aCC
)
int
status
=
0
;
#
if
GTEST_HAS_CXXABI_H_
using
abi
:
:
__cxa_demangle
;
#
endif
char
*
const
readable_name
=
__cxa_demangle
(
name
0
0
&
status
)
;
const
std
:
:
string
name_str
(
status
=
=
0
?
readable_name
:
name
)
;
free
(
readable_name
)
;
return
CanonicalizeForStdLibVersioning
(
name_str
)
;
#
else
return
name
;
#
endif
#
else
return
"
<
type
>
"
;
#
endif
}
#
if
GTEST_HAS_TYPED_TEST
|
|
GTEST_HAS_TYPED_TEST_P
template
<
typename
T1
typename
T2
>
struct
AssertTypeEq
;
template
<
typename
T
>
struct
AssertTypeEq
<
T
T
>
{
typedef
bool
type
;
}
;
struct
None
{
}
;
struct
Types0
{
}
;
template
<
typename
T1
>
struct
Types1
{
typedef
T1
Head
;
typedef
Types0
Tail
;
}
;
range
i
2
.
.
n
for
i
[
[
range
j
1
.
.
i
range
k
2
.
.
i
template
<
for
j
[
[
typename
T
j
]
]
>
struct
Types
i
{
typedef
T1
Head
;
typedef
Types
(
i
-
1
)
<
for
k
[
[
T
k
]
]
>
Tail
;
}
;
]
]
}
range
i
1
.
.
n
template
<
for
i
[
[
typename
T
i
=
internal
:
:
None
]
]
>
struct
Types
{
typedef
internal
:
:
Types
n
<
for
i
[
[
T
i
]
]
>
type
;
}
;
template
<
>
struct
Types
<
for
i
[
[
internal
:
:
None
]
]
>
{
typedef
internal
:
:
Types0
type
;
}
;
range
i
1
.
.
n
-
1
for
i
[
[
range
j
1
.
.
i
range
k
i
+
1
.
.
n
template
<
for
j
[
[
typename
T
j
]
]
>
struct
Types
<
for
j
[
[
T
j
]
]
for
k
[
[
internal
:
:
None
]
]
>
{
typedef
internal
:
:
Types
i
<
for
j
[
[
T
j
]
]
>
type
;
}
;
]
]
namespace
internal
{
#
define
GTEST_TEMPLATE_
template
<
typename
T
>
class
template
<
GTEST_TEMPLATE_
Tmpl
>
struct
TemplateSel
{
template
<
typename
T
>
struct
Bind
{
typedef
Tmpl
<
T
>
type
;
}
;
}
;
#
define
GTEST_BIND_
(
TmplSel
T
)
\
TmplSel
:
:
template
Bind
<
T
>
:
:
type
template
<
typename
T
>
struct
NoneT
{
}
;
struct
Templates0
{
}
;
template
<
GTEST_TEMPLATE_
T1
>
struct
Templates1
{
typedef
TemplateSel
<
T1
>
Head
;
typedef
Templates0
Tail
;
}
;
range
i
2
.
.
n
for
i
[
[
range
j
1
.
.
i
range
k
2
.
.
i
template
<
for
j
[
[
GTEST_TEMPLATE_
T
j
]
]
>
struct
Templates
i
{
typedef
TemplateSel
<
T1
>
Head
;
typedef
Templates
(
i
-
1
)
<
for
k
[
[
T
k
]
]
>
Tail
;
}
;
]
]
range
i
1
.
.
n
template
<
for
i
[
[
GTEST_TEMPLATE_
T
i
=
NoneT
]
]
>
struct
Templates
{
typedef
Templates
n
<
for
i
[
[
T
i
]
]
>
type
;
}
;
template
<
>
struct
Templates
<
for
i
[
[
NoneT
]
]
>
{
typedef
Templates0
type
;
}
;
range
i
1
.
.
n
-
1
for
i
[
[
range
j
1
.
.
i
range
k
i
+
1
.
.
n
template
<
for
j
[
[
GTEST_TEMPLATE_
T
j
]
]
>
struct
Templates
<
for
j
[
[
T
j
]
]
for
k
[
[
NoneT
]
]
>
{
typedef
Templates
i
<
for
j
[
[
T
j
]
]
>
type
;
}
;
]
]
template
<
typename
T
>
struct
TypeList
{
typedef
Types1
<
T
>
type
;
}
;
range
i
1
.
.
n
template
<
for
i
[
[
typename
T
i
]
]
>
struct
TypeList
<
Types
<
for
i
[
[
T
i
]
]
>
>
{
typedef
typename
Types
<
for
i
[
[
T
i
]
]
>
:
:
type
type
;
}
;
#
endif
}
}
#
endif
