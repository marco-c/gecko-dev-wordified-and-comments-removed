#
include
"
nsIAppShellService
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsPIWindowWatcher
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
AppWindow
.
h
"
#
include
"
nsWidgetInitData
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIEmbeddingSiteWindow
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsAppShellService
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWindowlessBrowser
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StartupTimeline
.
h
"
#
include
"
mozilla
/
StaticPrefs_fission
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
nsEmbedCID
.
h
"
#
include
"
nsIWebBrowser
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
nsWebBrowser
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
ifdef
MOZ_INSTRUMENT_EVENT_LOOP
#
include
"
EventTracer
.
h
"
#
endif
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
BrowsingContext
;
using
mozilla
:
:
intl
:
:
LocaleService
;
#
define
DEFAULT_HIDDENWINDOW_URL
"
resource
:
/
/
gre
-
resources
/
hiddenWindow
.
html
"
class
nsIAppShell
;
nsAppShellService
:
:
nsAppShellService
(
)
:
mXPCOMWillShutDown
(
false
)
mXPCOMShuttingDown
(
false
)
mModalWindowCount
(
0
)
mApplicationProvidedHiddenWindow
(
false
)
mScreenId
(
0
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
this
"
xpcom
-
will
-
shutdown
"
false
)
;
obs
-
>
AddObserver
(
this
"
xpcom
-
shutdown
"
false
)
;
}
}
nsAppShellService
:
:
~
nsAppShellService
(
)
{
}
NS_IMPL_ISUPPORTS
(
nsAppShellService
nsIAppShellService
nsIObserver
)
NS_IMETHODIMP
nsAppShellService
:
:
SetScreenId
(
uint32_t
aScreenId
)
{
mScreenId
=
aScreenId
;
return
NS_OK
;
}
void
nsAppShellService
:
:
EnsureHiddenWindow
(
)
{
if
(
!
mHiddenWindow
)
{
(
void
)
CreateHiddenWindow
(
)
;
}
}
NS_IMETHODIMP
nsAppShellService
:
:
CreateHiddenWindow
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
if
(
mXPCOMShuttingDown
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mHiddenWindow
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
profileDir
;
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
profileDir
)
)
;
if
(
!
profileDir
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
;
int32_t
initialHeight
=
100
initialWidth
=
100
;
#
ifdef
XP_MACOSX
uint32_t
chromeMask
=
0
;
nsAutoCString
prefVal
;
rv
=
Preferences
:
:
GetCString
(
"
browser
.
hiddenWindowChromeURL
"
prefVal
)
;
const
char
*
hiddenWindowURL
=
NS_SUCCEEDED
(
rv
)
?
prefVal
.
get
(
)
:
DEFAULT_HIDDENWINDOW_URL
;
mApplicationProvidedHiddenWindow
=
prefVal
.
get
(
)
?
true
:
false
;
#
else
static
const
char
hiddenWindowURL
[
]
=
DEFAULT_HIDDENWINDOW_URL
;
uint32_t
chromeMask
=
nsIWebBrowserChrome
:
:
CHROME_ALL
;
#
endif
nsCOMPtr
<
nsIURI
>
url
;
rv
=
NS_NewURI
(
getter_AddRefs
(
url
)
hiddenWindowURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
AppWindow
>
newWindow
;
rv
=
JustCreateTopWindow
(
nullptr
url
chromeMask
initialWidth
initialHeight
true
getter_AddRefs
(
newWindow
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
;
newWindow
-
>
GetDocShell
(
getter_AddRefs
(
docShell
)
)
;
if
(
docShell
)
{
Unused
<
<
docShell
-
>
GetBrowsingContext
(
)
-
>
SetExplicitActive
(
dom
:
:
ExplicitActiveStatus
:
:
Inactive
)
;
}
mHiddenWindow
.
swap
(
newWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsAppShellService
:
:
DestroyHiddenWindow
(
)
{
if
(
mHiddenWindow
)
{
mHiddenWindow
-
>
Destroy
(
)
;
mHiddenWindow
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsAppShellService
:
:
CreateTopLevelWindow
(
nsIAppWindow
*
aParent
nsIURI
*
aUrl
uint32_t
aChromeMask
int32_t
aInitialWidth
int32_t
aInitialHeight
nsIAppWindow
*
*
aResult
)
{
nsresult
rv
;
StartupTimeline
:
:
RecordOnce
(
StartupTimeline
:
:
CREATE_TOP_LEVEL_WINDOW
)
;
RefPtr
<
AppWindow
>
newWindow
;
rv
=
JustCreateTopWindow
(
aParent
aUrl
aChromeMask
aInitialWidth
aInitialHeight
false
getter_AddRefs
(
newWindow
)
)
;
newWindow
.
forget
(
aResult
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
RegisterTopLevelWindow
(
*
aResult
)
;
nsCOMPtr
<
nsIAppWindow
>
parent
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
)
parent
=
aParent
;
(
*
aResult
)
-
>
SetZLevel
(
CalculateWindowZLevel
(
parent
aChromeMask
)
)
;
}
return
rv
;
}
class
WebBrowserChrome2Stub
final
:
public
nsIWebBrowserChrome
public
nsIEmbeddingSiteWindow
public
nsIInterfaceRequestor
public
nsSupportsWeakReference
{
protected
:
nsCOMPtr
<
nsIWebBrowser
>
mBrowser
;
virtual
~
WebBrowserChrome2Stub
(
)
{
}
public
:
void
SetBrowser
(
nsIWebBrowser
*
aBrowser
)
{
mBrowser
=
aBrowser
;
}
NS_DECL_ISUPPORTS
NS_DECL_NSIWEBBROWSERCHROME
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSIEMBEDDINGSITEWINDOW
}
;
NS_INTERFACE_MAP_BEGIN
(
WebBrowserChrome2Stub
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIWebBrowserChrome
)
NS_INTERFACE_MAP_ENTRY
(
nsIWebBrowserChrome
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIEmbeddingSiteWindow
)
NS_INTERFACE_MAP_END
NS_IMPL_ADDREF
(
WebBrowserChrome2Stub
)
NS_IMPL_RELEASE
(
WebBrowserChrome2Stub
)
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
GetChromeFlags
(
uint32_t
*
aChromeFlags
)
{
*
aChromeFlags
=
0
;
return
NS_OK
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
SetChromeFlags
(
uint32_t
aChromeFlags
)
{
MOZ_ASSERT_UNREACHABLE
(
"
WebBrowserChrome2Stub
:
:
SetChromeFlags
is
"
"
not
supported
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
ShowAsModal
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
WebBrowserChrome2Stub
:
:
ShowAsModal
is
not
supported
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
IsWindowModal
(
bool
*
aResult
)
{
*
aResult
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
SetLinkStatus
(
const
nsAString
&
aStatusText
)
{
return
NS_OK
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
return
QueryInterface
(
aIID
aSink
)
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
GetDimensions
(
uint32_t
flags
int32_t
*
x
int32_t
*
y
int32_t
*
cx
int32_t
*
cy
)
{
if
(
x
)
{
*
x
=
0
;
}
if
(
y
)
{
*
y
=
0
;
}
if
(
cx
)
{
*
cx
=
0
;
}
if
(
cy
)
{
*
cy
=
0
;
}
return
NS_OK
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
SetDimensions
(
uint32_t
flags
int32_t
x
int32_t
y
int32_t
cx
int32_t
cy
)
{
nsCOMPtr
<
nsIBaseWindow
>
window
=
do_QueryInterface
(
mBrowser
)
;
NS_ENSURE_TRUE
(
window
NS_ERROR_FAILURE
)
;
window
-
>
SetSize
(
cx
cy
true
)
;
return
NS_OK
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
GetVisibility
(
bool
*
aVisibility
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
SetVisibility
(
bool
aVisibility
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
GetTitle
(
nsAString
&
aTitle
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
SetTitle
(
const
nsAString
&
aTitle
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
GetSiteWindow
(
void
*
*
aSiteWindow
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
WebBrowserChrome2Stub
:
:
Blur
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
class
BrowserDestroyer
final
:
public
Runnable
{
public
:
BrowserDestroyer
(
nsIWebBrowser
*
aBrowser
nsISupports
*
aContainer
)
:
mozilla
:
:
Runnable
(
"
BrowserDestroyer
"
)
mBrowser
(
aBrowser
)
mContainer
(
aContainer
)
{
}
static
nsresult
Destroy
(
nsIWebBrowser
*
aBrowser
)
{
nsCOMPtr
<
nsIBaseWindow
>
window
(
do_QueryInterface
(
aBrowser
)
)
;
return
window
-
>
Destroy
(
)
;
}
NS_IMETHOD
Run
(
)
override
{
return
Destroy
(
mBrowser
)
;
}
protected
:
virtual
~
BrowserDestroyer
(
)
{
}
private
:
nsCOMPtr
<
nsIWebBrowser
>
mBrowser
;
nsCOMPtr
<
nsISupports
>
mContainer
;
}
;
class
WindowlessBrowser
final
:
public
nsIWindowlessBrowser
public
nsIInterfaceRequestor
{
public
:
WindowlessBrowser
(
nsIWebBrowser
*
aBrowser
nsISupports
*
aContainer
)
:
mBrowser
(
aBrowser
)
mContainer
(
aContainer
)
mClosed
(
false
)
{
mWebNavigation
=
do_QueryInterface
(
aBrowser
)
;
mInterfaceRequestor
=
do_QueryInterface
(
aBrowser
)
;
}
NS_DECL_ISUPPORTS
NS_DECL_NSIWINDOWLESSBROWSER
NS_FORWARD_SAFE_NSIWEBNAVIGATION
(
mWebNavigation
)
NS_FORWARD_SAFE_NSIINTERFACEREQUESTOR
(
mInterfaceRequestor
)
private
:
~
WindowlessBrowser
(
)
{
if
(
mClosed
)
{
return
;
}
NS_WARNING
(
"
Windowless
browser
was
not
closed
prior
to
destruction
"
)
;
auto
runnable
=
MakeRefPtr
<
BrowserDestroyer
>
(
mBrowser
mContainer
)
;
nsContentUtils
:
:
AddScriptRunner
(
runnable
.
forget
(
)
)
;
}
nsCOMPtr
<
nsIWebBrowser
>
mBrowser
;
nsCOMPtr
<
nsIWebNavigation
>
mWebNavigation
;
nsCOMPtr
<
nsIInterfaceRequestor
>
mInterfaceRequestor
;
nsCOMPtr
<
nsISupports
>
mContainer
;
bool
mClosed
;
}
;
NS_IMPL_ISUPPORTS
(
WindowlessBrowser
nsIWindowlessBrowser
nsIWebNavigation
nsIInterfaceRequestor
)
NS_IMETHODIMP
WindowlessBrowser
:
:
Close
(
)
{
NS_ENSURE_TRUE
(
!
mClosed
NS_ERROR_UNEXPECTED
)
;
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
WindowlessBrowser
:
:
Close
called
when
not
safe
to
run
scripts
"
)
;
mClosed
=
true
;
mWebNavigation
=
nullptr
;
mInterfaceRequestor
=
nullptr
;
return
BrowserDestroyer
:
:
Destroy
(
mBrowser
)
;
}
NS_IMETHODIMP
WindowlessBrowser
:
:
GetBrowsingContext
(
BrowsingContext
*
*
aBrowsingContext
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellTreeItem
=
do_QueryInterface
(
mBrowser
)
;
if
(
!
docShellTreeItem
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
return
docShellTreeItem
-
>
GetBrowsingContextXPCOM
(
aBrowsingContext
)
;
}
NS_IMETHODIMP
WindowlessBrowser
:
:
GetDocShell
(
nsIDocShell
*
*
aDocShell
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
do_GetInterface
(
mInterfaceRequestor
)
;
if
(
!
docShell
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
docShell
.
forget
(
aDocShell
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsAppShellService
:
:
CreateWindowlessBrowser
(
bool
aIsChrome
uint32_t
aChromeMask
nsIWindowlessBrowser
*
*
aResult
)
{
if
(
aChromeMask
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aIsChrome
"
Got
chrome
flags
for
non
-
chrome
browser
"
)
;
if
(
aChromeMask
&
~
(
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
)
)
{
NS_ERROR
(
"
Received
unexpected
chrome
flags
"
)
;
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
WebBrowserChrome2Stub
>
stub
=
new
WebBrowserChrome2Stub
(
)
;
nsCOMPtr
<
nsIWidget
>
widget
;
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
widget
=
nsIWidget
:
:
CreateHeadlessWidget
(
)
;
}
else
{
widget
=
nsIWidget
:
:
CreatePuppetWidget
(
nullptr
)
;
}
if
(
!
widget
)
{
NS_ERROR
(
"
Couldn
'
t
create
instance
of
stub
widget
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
widget
-
>
Create
(
nullptr
0
LayoutDeviceIntRect
(
0
0
0
0
)
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
BrowsingContext
>
browsingContext
=
BrowsingContext
:
:
CreateIndependent
(
aIsChrome
?
BrowsingContext
:
:
Type
:
:
Chrome
:
BrowsingContext
:
:
Type
:
:
Content
)
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
)
{
browsingContext
-
>
SetRemoteTabs
(
true
)
;
}
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
)
{
browsingContext
-
>
SetRemoteSubframes
(
true
)
;
}
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
)
{
browsingContext
-
>
SetPrivateBrowsing
(
true
)
;
}
nsCOMPtr
<
nsIWebBrowser
>
browser
=
nsWebBrowser
:
:
Create
(
stub
widget
browsingContext
nullptr
)
;
if
(
NS_WARN_IF
(
!
browser
)
)
{
NS_ERROR
(
"
Couldn
'
t
create
instance
of
nsWebBrowser
!
"
)
;
return
NS_ERROR_FAILURE
;
}
stub
-
>
SetBrowser
(
browser
)
;
nsISupports
*
isstub
=
NS_ISUPPORTS_CAST
(
nsIWebBrowserChrome
*
stub
)
;
RefPtr
<
nsIWindowlessBrowser
>
result
=
new
WindowlessBrowser
(
browser
isstub
)
;
nsCOMPtr
<
nsIDocShell
>
docshell
=
do_GetInterface
(
result
)
;
docshell
-
>
SetInvisible
(
true
)
;
result
.
forget
(
aResult
)
;
return
NS_OK
;
}
uint32_t
nsAppShellService
:
:
CalculateWindowZLevel
(
nsIAppWindow
*
aParent
uint32_t
aChromeMask
)
{
uint32_t
zLevel
;
zLevel
=
nsIAppWindow
:
:
normalZ
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RAISED
)
zLevel
=
nsIAppWindow
:
:
raisedZ
;
else
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_LOWERED
)
zLevel
=
nsIAppWindow
:
:
loweredZ
;
#
ifdef
XP_MACOSX
uint32_t
modalDepMask
=
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
;
if
(
aParent
&
&
(
aChromeMask
&
modalDepMask
)
)
{
aParent
-
>
GetZLevel
(
&
zLevel
)
;
}
#
else
if
(
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
)
&
&
aParent
)
aParent
-
>
GetZLevel
(
&
zLevel
)
;
#
endif
return
zLevel
;
}
#
ifdef
XP_WIN
static
bool
CheckForFullscreenWindow
(
)
{
nsCOMPtr
<
nsIWindowMediator
>
wm
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
!
wm
)
return
false
;
nsCOMPtr
<
nsISimpleEnumerator
>
windowList
;
wm
-
>
GetAppWindowEnumerator
(
nullptr
getter_AddRefs
(
windowList
)
)
;
if
(
!
windowList
)
return
false
;
for
(
;
;
)
{
bool
more
=
false
;
windowList
-
>
HasMoreElements
(
&
more
)
;
if
(
!
more
)
return
false
;
nsCOMPtr
<
nsISupports
>
supportsWindow
;
windowList
-
>
GetNext
(
getter_AddRefs
(
supportsWindow
)
)
;
nsCOMPtr
<
nsIBaseWindow
>
baseWin
(
do_QueryInterface
(
supportsWindow
)
)
;
if
(
baseWin
)
{
nsCOMPtr
<
nsIWidget
>
widget
;
baseWin
-
>
GetMainWidget
(
getter_AddRefs
(
widget
)
)
;
if
(
widget
&
&
widget
-
>
SizeMode
(
)
=
=
nsSizeMode_Fullscreen
)
{
return
true
;
}
}
}
return
false
;
}
#
endif
nsresult
nsAppShellService
:
:
JustCreateTopWindow
(
nsIAppWindow
*
aParent
nsIURI
*
aUrl
uint32_t
aChromeMask
int32_t
aInitialWidth
int32_t
aInitialHeight
bool
aIsHiddenWindow
AppWindow
*
*
aResult
)
{
*
aResult
=
nullptr
;
NS_ENSURE_STATE
(
!
mXPCOMWillShutDown
)
;
nsCOMPtr
<
nsIAppWindow
>
parent
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
)
parent
=
aParent
;
RefPtr
<
AppWindow
>
window
=
new
AppWindow
(
aChromeMask
)
;
#
ifdef
XP_WIN
if
(
window
&
&
CheckForFullscreenWindow
(
)
)
window
-
>
IgnoreXULSizeMode
(
true
)
;
#
endif
nsWidgetInitData
widgetInitData
;
if
(
aIsHiddenWindow
)
widgetInitData
.
mWindowType
=
eWindowType_invisible
;
else
widgetInitData
.
mWindowType
=
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
?
eWindowType_dialog
:
eWindowType_toplevel
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_POPUP
)
widgetInitData
.
mWindowType
=
eWindowType_popup
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_SUPPRESS_ANIMATION
)
widgetInitData
.
mIsAnimationSuppressed
=
true
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_ALWAYS_ON_TOP
)
widgetInitData
.
mAlwaysOnTop
=
true
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
)
widgetInitData
.
mHasRemoteContent
=
true
;
#
ifdef
MOZ_WIDGET_GTK
uint32_t
pipMask
=
nsIWebBrowserChrome
:
:
CHROME_ALWAYS_ON_TOP
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
uint32_t
barMask
=
nsIWebBrowserChrome
:
:
CHROME_MENUBAR
|
nsIWebBrowserChrome
:
:
CHROME_TOOLBAR
|
nsIWebBrowserChrome
:
:
CHROME_LOCATIONBAR
|
nsIWebBrowserChrome
:
:
CHROME_STATUSBAR
;
if
(
widgetInitData
.
mWindowType
=
=
eWindowType_toplevel
&
&
(
(
aChromeMask
&
pipMask
)
=
=
pipMask
)
&
&
!
(
aChromeMask
&
barMask
)
)
{
widgetInitData
.
mPIPWindow
=
true
;
}
#
elif
defined
(
XP_WIN
)
uint32_t
pipMask
=
nsIWebBrowserChrome
:
:
CHROME_ALWAYS_ON_TOP
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
uint32_t
barMask
=
nsIWebBrowserChrome
:
:
CHROME_MENUBAR
|
nsIWebBrowserChrome
:
:
CHROME_TOOLBAR
|
nsIWebBrowserChrome
:
:
CHROME_LOCATIONBAR
|
nsIWebBrowserChrome
:
:
CHROME_STATUSBAR
;
if
(
widgetInitData
.
mWindowType
=
=
eWindowType_dialog
&
&
(
(
aChromeMask
&
pipMask
)
=
=
pipMask
)
&
&
!
(
aChromeMask
&
barMask
)
)
{
widgetInitData
.
mPIPWindow
=
true
;
}
#
endif
#
ifdef
XP_MACOSX
uint32_t
sheetMask
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
|
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
if
(
parent
&
&
(
parent
!
=
mHiddenWindow
)
&
&
(
(
aChromeMask
&
sheetMask
)
=
=
sheetMask
)
)
{
widgetInitData
.
mWindowType
=
eWindowType_sheet
;
}
#
endif
#
if
defined
(
XP_WIN
)
if
(
widgetInitData
.
mWindowType
=
=
eWindowType_toplevel
|
|
widgetInitData
.
mWindowType
=
=
eWindowType_dialog
)
widgetInitData
.
mClipChildren
=
true
;
#
endif
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_DEFAULT
)
widgetInitData
.
mBorderStyle
=
eBorderStyle_default
;
else
if
(
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_ALL
)
=
=
nsIWebBrowserChrome
:
:
CHROME_ALL
)
widgetInitData
.
mBorderStyle
=
eBorderStyle_all
;
else
{
widgetInitData
.
mBorderStyle
=
eBorderStyle_none
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_BORDERS
)
widgetInitData
.
mBorderStyle
=
static_cast
<
enum
nsBorderStyle
>
(
widgetInitData
.
mBorderStyle
|
eBorderStyle_border
)
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_TITLEBAR
)
widgetInitData
.
mBorderStyle
=
static_cast
<
enum
nsBorderStyle
>
(
widgetInitData
.
mBorderStyle
|
eBorderStyle_title
)
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_CLOSE
)
widgetInitData
.
mBorderStyle
=
static_cast
<
enum
nsBorderStyle
>
(
widgetInitData
.
mBorderStyle
|
eBorderStyle_close
)
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RESIZE
)
{
widgetInitData
.
mResizable
=
true
;
widgetInitData
.
mBorderStyle
=
static_cast
<
enum
nsBorderStyle
>
(
widgetInitData
.
mBorderStyle
|
eBorderStyle_resizeh
)
;
if
(
!
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
)
)
widgetInitData
.
mBorderStyle
=
static_cast
<
enum
nsBorderStyle
>
(
widgetInitData
.
mBorderStyle
|
eBorderStyle_maximize
)
;
}
if
(
!
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
)
)
widgetInitData
.
mBorderStyle
=
static_cast
<
enum
nsBorderStyle
>
(
widgetInitData
.
mBorderStyle
|
eBorderStyle_minimize
|
eBorderStyle_menu
)
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_MIN
)
{
widgetInitData
.
mBorderStyle
=
static_cast
<
enum
nsBorderStyle
>
(
widgetInitData
.
mBorderStyle
|
eBorderStyle_minimize
)
;
}
}
if
(
aInitialWidth
=
=
nsIAppShellService
:
:
SIZE_TO_CONTENT
|
|
aInitialHeight
=
=
nsIAppShellService
:
:
SIZE_TO_CONTENT
)
{
aInitialWidth
=
1
;
aInitialHeight
=
1
;
window
-
>
SetIntrinsicallySized
(
true
)
;
}
bool
center
=
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_CENTER_SCREEN
;
widgetInitData
.
mRTL
=
LocaleService
:
:
GetInstance
(
)
-
>
IsAppLocaleRTL
(
)
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
)
{
widgetInitData
.
mIsPrivate
=
true
;
}
nsresult
rv
=
window
-
>
Initialize
(
parent
center
?
aParent
:
nullptr
aInitialWidth
aInitialHeight
aIsHiddenWindow
widgetInitData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isPrivateBrowsingWindow
=
Preferences
:
:
GetBool
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
if
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
)
{
isPrivateBrowsingWindow
=
true
;
}
nsCOMPtr
<
mozIDOMWindowProxy
>
domWin
=
do_GetInterface
(
aParent
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
=
do_GetInterface
(
domWin
)
;
nsCOMPtr
<
nsILoadContext
>
parentContext
=
do_QueryInterface
(
webNav
)
;
if
(
!
isPrivateBrowsingWindow
&
&
parentContext
)
{
isPrivateBrowsingWindow
=
parentContext
-
>
UsePrivateBrowsing
(
)
;
}
if
(
nsDocShell
*
docShell
=
window
-
>
GetDocShell
(
)
)
{
MOZ_ASSERT
(
docShell
-
>
GetBrowsingContext
(
)
-
>
IsChrome
(
)
)
;
docShell
-
>
SetPrivateBrowsing
(
isPrivateBrowsingWindow
)
;
docShell
-
>
SetRemoteTabs
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
)
;
docShell
-
>
SetRemoteSubframes
(
aChromeMask
&
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
)
;
if
(
nsContentUtils
:
:
IsInitialized
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
"
Previously
this
method
would
use
the
subject
principal
rather
than
"
"
hardcoding
the
system
principal
"
)
;
rv
=
docShell
-
>
CreateAboutBlankContentViewer
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsContentUtils
:
:
GetSystemPrincipal
(
)
nullptr
nullptr
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
Document
>
doc
=
docShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
!
!
doc
NS_ERROR_FAILURE
)
;
MOZ_ASSERT
(
doc
-
>
IsInitialDocument
(
)
"
Document
should
be
an
initial
document
"
)
;
}
if
(
aUrl
)
{
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
aUrl
)
;
loadState
-
>
SetTriggeringPrincipal
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
loadState
-
>
SetFirstParty
(
true
)
;
rv
=
docShell
-
>
LoadURI
(
loadState
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
window
.
forget
(
aResult
)
;
if
(
parent
)
parent
-
>
AddChildWindow
(
*
aResult
)
;
if
(
center
)
rv
=
(
*
aResult
)
-
>
Center
(
parent
parent
?
false
:
true
false
)
;
return
rv
;
}
NS_IMETHODIMP
nsAppShellService
:
:
GetHiddenWindow
(
nsIAppWindow
*
*
aWindow
)
{
NS_ENSURE_ARG_POINTER
(
aWindow
)
;
EnsureHiddenWindow
(
)
;
*
aWindow
=
mHiddenWindow
;
NS_IF_ADDREF
(
*
aWindow
)
;
return
*
aWindow
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsAppShellService
:
:
GetHiddenDOMWindow
(
mozIDOMWindowProxy
*
*
aWindow
)
{
NS_ENSURE_ARG_POINTER
(
aWindow
)
;
EnsureHiddenWindow
(
)
;
nsresult
rv
;
nsCOMPtr
<
nsIDocShell
>
docShell
;
NS_ENSURE_TRUE
(
mHiddenWindow
NS_ERROR_FAILURE
)
;
rv
=
mHiddenWindow
-
>
GetDocShell
(
getter_AddRefs
(
docShell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
docShell
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
hiddenDOMWindow
(
docShell
-
>
GetWindow
(
)
)
;
hiddenDOMWindow
.
forget
(
aWindow
)
;
return
*
aWindow
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsAppShellService
:
:
GetHasHiddenWindow
(
bool
*
aHasHiddenWindow
)
{
NS_ENSURE_ARG_POINTER
(
aHasHiddenWindow
)
;
*
aHasHiddenWindow
=
!
!
mHiddenWindow
;
return
NS_OK
;
}
NS_IMETHODIMP
nsAppShellService
:
:
GetApplicationProvidedHiddenWindow
(
bool
*
aAPHW
)
{
*
aAPHW
=
mApplicationProvidedHiddenWindow
;
return
NS_OK
;
}
NS_IMETHODIMP
nsAppShellService
:
:
RegisterTopLevelWindow
(
nsIAppWindow
*
aWindow
)
{
NS_ENSURE_ARG_POINTER
(
aWindow
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
;
aWindow
-
>
GetDocShell
(
getter_AddRefs
(
docShell
)
)
;
NS_ENSURE_TRUE
(
docShell
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
(
docShell
-
>
GetWindow
(
)
)
;
NS_ENSURE_TRUE
(
domWindow
NS_ERROR_FAILURE
)
;
MOZ_DIAGNOSTIC_ASSERT
(
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
"
Previously
this
method
would
use
the
subject
principal
rather
than
"
"
hardcoding
the
system
principal
"
)
;
domWindow
-
>
SetInitialPrincipal
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
nullptr
Nothing
(
)
)
;
nsCOMPtr
<
nsIWindowMediator
>
mediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
NS_ASSERTION
(
mediator
"
Couldn
'
t
get
window
mediator
.
"
)
;
if
(
mediator
)
mediator
-
>
RegisterWindow
(
aWindow
)
;
nsCOMPtr
<
nsPIWindowWatcher
>
wwatcher
(
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
)
)
;
NS_ASSERTION
(
wwatcher
"
No
windowwatcher
?
"
)
;
if
(
wwatcher
&
&
domWindow
)
{
wwatcher
-
>
AddWindow
(
domWindow
0
)
;
}
nsCOMPtr
<
nsIObserverService
>
obssvc
=
services
:
:
GetObserverService
(
)
;
NS_ASSERTION
(
obssvc
"
Couldn
'
t
get
observer
service
.
"
)
;
if
(
obssvc
)
{
obssvc
-
>
NotifyObservers
(
aWindow
"
xul
-
window
-
registered
"
nullptr
)
;
AppWindow
*
appWindow
=
static_cast
<
AppWindow
*
>
(
aWindow
)
;
appWindow
-
>
WasRegistered
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsAppShellService
:
:
UnregisterTopLevelWindow
(
nsIAppWindow
*
aWindow
)
{
if
(
mXPCOMShuttingDown
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_ARG_POINTER
(
aWindow
)
;
if
(
aWindow
=
=
mHiddenWindow
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIWindowMediator
>
mediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
NS_ASSERTION
(
mediator
"
Couldn
'
t
get
window
mediator
.
Doing
xpcom
shutdown
?
"
)
;
if
(
mediator
)
mediator
-
>
UnregisterWindow
(
aWindow
)
;
nsCOMPtr
<
nsPIWindowWatcher
>
wwatcher
(
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
)
)
;
NS_ASSERTION
(
wwatcher
"
Couldn
'
t
get
windowwatcher
doing
xpcom
shutdown
?
"
)
;
if
(
wwatcher
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
;
aWindow
-
>
GetDocShell
(
getter_AddRefs
(
docShell
)
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
(
docShell
-
>
GetWindow
(
)
)
;
if
(
domWindow
)
wwatcher
-
>
RemoveWindow
(
domWindow
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsAppShellService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
"
xpcom
-
will
-
shutdown
"
)
)
{
mXPCOMWillShutDown
=
true
;
}
else
if
(
!
strcmp
(
aTopic
"
xpcom
-
shutdown
"
)
)
{
mXPCOMShuttingDown
=
true
;
if
(
mHiddenWindow
)
{
mHiddenWindow
-
>
Destroy
(
)
;
}
}
else
{
NS_ERROR
(
"
Unexpected
observer
topic
!
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsAppShellService
:
:
StartEventLoopLagTracking
(
bool
*
aResult
)
{
#
ifdef
MOZ_INSTRUMENT_EVENT_LOOP
*
aResult
=
mozilla
:
:
InitEventTracing
(
true
)
;
#
endif
return
NS_OK
;
}
NS_IMETHODIMP
nsAppShellService
:
:
StopEventLoopLagTracking
(
)
{
#
ifdef
MOZ_INSTRUMENT_EVENT_LOOP
mozilla
:
:
ShutdownEventTracing
(
)
;
#
endif
return
NS_OK
;
}
