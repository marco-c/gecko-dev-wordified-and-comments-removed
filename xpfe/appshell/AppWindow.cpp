#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
AppWindow
.
h
"
#
include
<
algorithm
>
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsGlobalWindowOuter
.
h
"
#
include
"
nsIAppShell
.
h
"
#
include
"
nsIAppShellService
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsScreen
.
h
"
#
include
"
nsIEmbeddingSiteWindow
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIOpenWindowInfo
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsIScreen
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsAppShellCID
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsXULTooltipListener
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsIDOMWindowUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
dom
/
BarProps
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
BrowserHost
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
LoadURIOptionsBinding
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
PreXULSkeletonUI
.
h
"
#
include
"
nsIWindowsUIUtils
.
h
"
#
endif
#
ifdef
MOZ_NEW_XULSTORE
#
include
"
mozilla
/
XULStore
.
h
"
#
endif
#
include
"
mozilla
/
dom
/
DocumentL10n
.
h
"
#
ifdef
XP_MACOSX
#
include
"
mozilla
/
widget
/
NativeMenuSupport
.
h
"
#
define
USE_NATIVE_MENUS
#
endif
#
define
SIZEMODE_NORMAL
u
"
normal
"
_ns
#
define
SIZEMODE_MAXIMIZED
u
"
maximized
"
_ns
#
define
SIZEMODE_MINIMIZED
u
"
minimized
"
_ns
#
define
SIZEMODE_FULLSCREEN
u
"
fullscreen
"
_ns
#
define
WINDOWTYPE_ATTRIBUTE
u
"
windowtype
"
_ns
#
define
PERSIST_ATTRIBUTE
u
"
persist
"
_ns
#
define
SCREENX_ATTRIBUTE
u
"
screenX
"
_ns
#
define
SCREENY_ATTRIBUTE
u
"
screenY
"
_ns
#
define
WIDTH_ATTRIBUTE
u
"
width
"
_ns
#
define
HEIGHT_ATTRIBUTE
u
"
height
"
_ns
#
define
MODE_ATTRIBUTE
u
"
sizemode
"
_ns
#
define
TILED_ATTRIBUTE
u
"
gtktiledwindow
"
_ns
#
define
ZLEVEL_ATTRIBUTE
u
"
zlevel
"
_ns
#
define
SIZE_PERSISTENCE_TIMEOUT
500
/
/
msec
namespace
mozilla
{
using
dom
:
:
AutoNoJSAPI
;
using
dom
:
:
BrowserHost
;
using
dom
:
:
BrowsingContext
;
using
dom
:
:
Document
;
using
dom
:
:
DocumentL10n
;
using
dom
:
:
Element
;
using
dom
:
:
EventTarget
;
using
dom
:
:
LoadURIOptions
;
using
dom
:
:
Promise
;
AppWindow
:
:
AppWindow
(
uint32_t
aChromeFlags
)
:
mChromeTreeOwner
(
nullptr
)
mContentTreeOwner
(
nullptr
)
mPrimaryContentTreeOwner
(
nullptr
)
mModalStatus
(
NS_OK
)
mFullscreenChangeState
(
FullscreenChangeState
:
:
NotChanging
)
mContinueModalLoop
(
false
)
mDebuting
(
false
)
mChromeLoaded
(
false
)
mSizingShellFromXUL
(
false
)
mShowAfterLoad
(
false
)
mIntrinsicallySized
(
false
)
mCenterAfterLoad
(
false
)
mIsHiddenWindow
(
false
)
mLockedUntilChromeLoad
(
false
)
mIgnoreXULSize
(
false
)
mIgnoreXULPosition
(
false
)
mChromeFlagsFrozen
(
false
)
mIgnoreXULSizeMode
(
false
)
mDestroying
(
false
)
mRegistered
(
false
)
mPersistentAttributesDirty
(
0
)
mPersistentAttributesMask
(
0
)
mChromeFlags
(
aChromeFlags
)
mSPTimerLock
(
"
AppWindow
.
mSPTimerLock
"
)
mWidgetListenerDelegate
(
this
)
{
}
AppWindow
:
:
~
AppWindow
(
)
{
{
MutexAutoLock
lock
(
mSPTimerLock
)
;
if
(
mSPTimer
)
mSPTimer
-
>
Cancel
(
)
;
}
Destroy
(
)
;
}
NS_IMPL_ADDREF
(
AppWindow
)
NS_IMPL_RELEASE
(
AppWindow
)
NS_INTERFACE_MAP_BEGIN
(
AppWindow
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIAppWindow
)
NS_INTERFACE_MAP_ENTRY
(
nsIAppWindow
)
NS_INTERFACE_MAP_ENTRY
(
nsIBaseWindow
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIWebProgressListener
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
AppWindow
)
NS_INTERFACE_MAP_END
nsresult
AppWindow
:
:
Initialize
(
nsIAppWindow
*
aParent
nsIAppWindow
*
aOpener
int32_t
aInitialWidth
int32_t
aInitialHeight
bool
aIsHiddenWindow
nsWidgetInitData
&
widgetInitData
)
{
nsresult
rv
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
mIsHiddenWindow
=
aIsHiddenWindow
;
DesktopIntPoint
initialPos
;
nsCOMPtr
<
nsIBaseWindow
>
base
(
do_QueryInterface
(
aOpener
)
)
;
if
(
base
)
{
LayoutDeviceIntRect
rect
=
base
-
>
GetPositionAndSize
(
)
;
mOpenerScreenRect
=
DesktopIntRect
:
:
Round
(
rect
/
base
-
>
DevicePixelsPerDesktopPixel
(
)
)
;
if
(
!
mOpenerScreenRect
.
IsEmpty
(
)
)
{
initialPos
=
mOpenerScreenRect
.
TopLeft
(
)
;
ConstrainToOpenerScreen
(
&
initialPos
.
x
&
initialPos
.
y
)
;
}
}
DesktopIntRect
deskRect
(
initialPos
DesktopIntSize
(
aInitialWidth
aInitialHeight
)
)
;
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
mWindow
=
nsIWidget
:
:
CreateHeadlessWidget
(
)
;
}
else
{
mWindow
=
nsIWidget
:
:
CreateTopLevelWindow
(
)
;
}
if
(
!
mWindow
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIBaseWindow
>
parentAsWin
(
do_QueryInterface
(
aParent
)
)
;
if
(
parentAsWin
)
{
parentAsWin
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
mParentWindow
=
do_GetWeakReference
(
aParent
)
;
}
mWindow
-
>
SetWidgetListener
(
&
mWidgetListenerDelegate
)
;
rv
=
mWindow
-
>
Create
(
(
nsIWidget
*
)
parentWidget
nullptr
deskRect
&
widgetInitData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LayoutDeviceIntRect
r
=
mWindow
-
>
GetClientBounds
(
)
;
mWindow
-
>
SetBackgroundColor
(
NS_RGB
(
255
255
255
)
)
;
RefPtr
<
BrowsingContext
>
browsingContext
=
BrowsingContext
:
:
CreateIndependent
(
BrowsingContext
:
:
Type
:
:
Chrome
)
;
mDocShell
=
nsDocShell
:
:
Create
(
browsingContext
)
;
NS_ENSURE_TRUE
(
mDocShell
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
EnsureChromeTreeOwner
(
)
NS_ERROR_FAILURE
)
;
mDocShell
-
>
SetTreeOwner
(
mChromeTreeOwner
)
;
r
.
MoveTo
(
0
0
)
;
NS_ENSURE_SUCCESS
(
mDocShell
-
>
InitWindow
(
nullptr
mWindow
r
.
X
(
)
r
.
Y
(
)
r
.
Width
(
)
r
.
Height
(
)
)
NS_ERROR_FAILURE
)
;
mDocShell
-
>
AddProgressListener
(
this
nsIWebProgress
:
:
NOTIFY_STATE_NETWORK
)
;
mWindow
-
>
MaybeDispatchInitialFocusEvent
(
)
;
return
rv
;
}
NS_IMETHODIMP
AppWindow
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
nsresult
rv
;
NS_ENSURE_ARG_POINTER
(
aSink
)
;
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIPrompt
)
)
)
{
rv
=
EnsurePrompter
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
mPrompter
-
>
QueryInterface
(
aIID
aSink
)
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt
)
)
)
{
rv
=
EnsureAuthPrompter
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
mAuthPrompter
-
>
QueryInterface
(
aIID
aSink
)
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
mozIDOMWindowProxy
)
)
)
{
return
GetWindowDOMWindow
(
reinterpret_cast
<
mozIDOMWindowProxy
*
*
>
(
aSink
)
)
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIDOMWindow
)
)
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
window
=
nullptr
;
rv
=
GetWindowDOMWindow
(
getter_AddRefs
(
window
)
)
;
nsCOMPtr
<
nsIDOMWindow
>
domWindow
=
do_QueryInterface
(
window
)
;
domWindow
.
forget
(
aSink
)
;
return
rv
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIWebBrowserChrome
)
)
&
&
NS_SUCCEEDED
(
EnsureContentTreeOwner
(
)
)
&
&
NS_SUCCEEDED
(
mContentTreeOwner
-
>
QueryInterface
(
aIID
aSink
)
)
)
return
NS_OK
;
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIEmbeddingSiteWindow
)
)
&
&
NS_SUCCEEDED
(
EnsureContentTreeOwner
(
)
)
&
&
NS_SUCCEEDED
(
mContentTreeOwner
-
>
QueryInterface
(
aIID
aSink
)
)
)
return
NS_OK
;
return
QueryInterface
(
aIID
aSink
)
;
}
NS_IMETHODIMP
AppWindow
:
:
GetDocShell
(
nsIDocShell
*
*
aDocShell
)
{
NS_ENSURE_ARG_POINTER
(
aDocShell
)
;
*
aDocShell
=
mDocShell
;
NS_IF_ADDREF
(
*
aDocShell
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetZLevel
(
uint32_t
*
outLevel
)
{
nsCOMPtr
<
nsIWindowMediator
>
mediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
mediator
)
mediator
-
>
GetZLevel
(
this
outLevel
)
;
else
*
outLevel
=
normalZ
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetZLevel
(
uint32_t
aLevel
)
{
nsCOMPtr
<
nsIWindowMediator
>
mediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
!
mediator
)
return
NS_ERROR_FAILURE
;
uint32_t
zLevel
;
mediator
-
>
GetZLevel
(
this
&
zLevel
)
;
if
(
zLevel
=
=
aLevel
)
return
NS_OK
;
if
(
aLevel
>
nsIAppWindow
:
:
normalZ
&
&
mWindow
)
{
nsSizeMode
sizeMode
=
mWindow
-
>
SizeMode
(
)
;
if
(
sizeMode
=
=
nsSizeMode_Maximized
|
|
sizeMode
=
=
nsSizeMode_Fullscreen
)
{
return
NS_ERROR_FAILURE
;
}
}
mediator
-
>
SetZLevel
(
this
aLevel
)
;
PersistentAttributesDirty
(
PAD_MISC
)
;
SavePersistentAttributes
(
)
;
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
cv
)
{
RefPtr
<
dom
:
:
Document
>
doc
=
cv
-
>
GetDocument
(
)
;
if
(
doc
)
{
ErrorResult
rv
;
RefPtr
<
dom
:
:
Event
>
event
=
doc
-
>
CreateEvent
(
u
"
Events
"
_ns
dom
:
:
CallerType
:
:
System
rv
)
;
if
(
event
)
{
event
-
>
InitEvent
(
u
"
windowZLevel
"
_ns
true
false
)
;
event
-
>
SetTrusted
(
true
)
;
doc
-
>
DispatchEvent
(
*
event
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetChromeFlags
(
uint32_t
*
aChromeFlags
)
{
NS_ENSURE_ARG_POINTER
(
aChromeFlags
)
;
*
aChromeFlags
=
mChromeFlags
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetChromeFlags
(
uint32_t
aChromeFlags
)
{
NS_ASSERTION
(
!
mChromeFlagsFrozen
"
SetChromeFlags
(
)
after
AssumeChromeFlagsAreFrozen
(
)
!
"
)
;
mChromeFlags
=
aChromeFlags
;
if
(
mChromeLoaded
)
{
ApplyChromeFlags
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
AssumeChromeFlagsAreFrozen
(
)
{
mChromeFlagsFrozen
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetIntrinsicallySized
(
bool
aIntrinsicallySized
)
{
mIntrinsicallySized
=
aIntrinsicallySized
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetIntrinsicallySized
(
bool
*
aIntrinsicallySized
)
{
NS_ENSURE_ARG_POINTER
(
aIntrinsicallySized
)
;
*
aIntrinsicallySized
=
mIntrinsicallySized
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetPrimaryContentShell
(
nsIDocShellTreeItem
*
*
aDocShellTreeItem
)
{
NS_ENSURE_ARG_POINTER
(
aDocShellTreeItem
)
;
NS_IF_ADDREF
(
*
aDocShellTreeItem
=
mPrimaryContentShell
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
RemoteTabAdded
(
nsIRemoteTab
*
aTab
bool
aPrimary
)
{
if
(
aPrimary
)
{
mPrimaryBrowserParent
=
aTab
;
mPrimaryContentShell
=
nullptr
;
}
else
if
(
mPrimaryBrowserParent
=
=
aTab
)
{
mPrimaryBrowserParent
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
RemoteTabRemoved
(
nsIRemoteTab
*
aTab
)
{
if
(
aTab
=
=
mPrimaryBrowserParent
)
{
mPrimaryBrowserParent
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetPrimaryRemoteTab
(
nsIRemoteTab
*
*
aTab
)
{
nsCOMPtr
<
nsIRemoteTab
>
tab
=
mPrimaryBrowserParent
;
tab
.
forget
(
aTab
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetPrimaryContentBrowsingContext
(
mozilla
:
:
dom
:
:
BrowsingContext
*
*
aBc
)
{
if
(
mPrimaryBrowserParent
)
{
return
mPrimaryBrowserParent
-
>
GetBrowsingContext
(
aBc
)
;
}
if
(
mPrimaryContentShell
)
{
return
mPrimaryContentShell
-
>
GetBrowsingContextXPCOM
(
aBc
)
;
}
*
aBc
=
nullptr
;
return
NS_OK
;
}
static
LayoutDeviceIntSize
GetOuterToInnerSizeDifference
(
nsIWidget
*
aWindow
)
{
if
(
!
aWindow
)
{
return
LayoutDeviceIntSize
(
)
;
}
LayoutDeviceIntSize
baseSize
(
200
200
)
;
LayoutDeviceIntSize
windowSize
=
aWindow
-
>
ClientToWindowSize
(
baseSize
)
;
return
windowSize
-
baseSize
;
}
static
CSSIntSize
GetOuterToInnerSizeDifferenceInCSSPixels
(
nsIWidget
*
aWindow
CSSToLayoutDeviceScale
aScale
)
{
LayoutDeviceIntSize
devPixelSize
=
GetOuterToInnerSizeDifference
(
aWindow
)
;
return
RoundedToInt
(
devPixelSize
/
aScale
)
;
}
NS_IMETHODIMP
AppWindow
:
:
GetOuterToInnerHeightDifferenceInCSSPixels
(
uint32_t
*
aResult
)
{
*
aResult
=
GetOuterToInnerSizeDifferenceInCSSPixels
(
mWindow
UnscaledDevicePixelsPerCSSPixel
(
)
)
.
height
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetOuterToInnerWidthDifferenceInCSSPixels
(
uint32_t
*
aResult
)
{
*
aResult
=
GetOuterToInnerSizeDifferenceInCSSPixels
(
mWindow
UnscaledDevicePixelsPerCSSPixel
(
)
)
.
width
;
return
NS_OK
;
}
nsTArray
<
RefPtr
<
mozilla
:
:
LiveResizeListener
>
>
AppWindow
:
:
GetLiveResizeListeners
(
)
{
nsTArray
<
RefPtr
<
mozilla
:
:
LiveResizeListener
>
>
listeners
;
if
(
mPrimaryBrowserParent
)
{
BrowserHost
*
host
=
BrowserHost
:
:
GetFrom
(
mPrimaryBrowserParent
.
get
(
)
)
;
listeners
.
AppendElement
(
host
-
>
GetActor
(
)
)
;
}
return
listeners
;
}
NS_IMETHODIMP
AppWindow
:
:
AddChildWindow
(
nsIAppWindow
*
aChild
)
{
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
RemoveChildWindow
(
nsIAppWindow
*
aChild
)
{
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
ShowModal
(
)
{
AUTO_PROFILER_LABEL
(
"
AppWindow
:
:
ShowModal
"
OTHER
)
;
nsCOMPtr
<
nsIWidget
>
window
=
mWindow
;
nsCOMPtr
<
nsIAppWindow
>
tempRef
=
this
;
window
-
>
SetModal
(
true
)
;
mContinueModalLoop
=
true
;
EnableParent
(
false
)
;
{
AutoNoJSAPI
nojsapi
;
SpinEventLoopUntil
(
"
AppWindow
:
:
ShowModal
"
_ns
[
&
]
(
)
{
return
!
mContinueModalLoop
;
}
)
;
}
mContinueModalLoop
=
false
;
window
-
>
SetModal
(
false
)
;
return
mModalStatus
;
}
NS_IMETHODIMP
AppWindow
:
:
InitWindow
(
nativeWindow
aParentNativeWindow
nsIWidget
*
parentWidget
int32_t
x
int32_t
y
int32_t
cx
int32_t
cy
)
{
NS_ASSERTION
(
false
"
Not
Yet
Implemented
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
Destroy
(
)
{
nsCOMPtr
<
nsIAppWindow
>
kungFuDeathGrip
(
this
)
;
if
(
mDocShell
)
{
mDocShell
-
>
RemoveProgressListener
(
this
)
;
}
{
MutexAutoLock
lock
(
mSPTimerLock
)
;
if
(
mSPTimer
)
{
mSPTimer
-
>
Cancel
(
)
;
SavePersistentAttributes
(
)
;
mSPTimer
=
nullptr
;
}
}
if
(
!
mWindow
)
return
NS_OK
;
if
(
mDestroying
)
return
NS_OK
;
mozilla
:
:
AutoRestore
<
bool
>
guard
(
mDestroying
)
;
mDestroying
=
true
;
nsCOMPtr
<
nsIAppShellService
>
appShell
(
do_GetService
(
NS_APPSHELLSERVICE_CONTRACTID
)
)
;
NS_ASSERTION
(
appShell
"
Couldn
'
t
get
appShell
.
.
.
xpcom
shutdown
?
"
)
;
if
(
appShell
)
appShell
-
>
UnregisterTopLevelWindow
(
static_cast
<
nsIAppWindow
*
>
(
this
)
)
;
nsCOMPtr
<
nsIAppWindow
>
parentWindow
(
do_QueryReferent
(
mParentWindow
)
)
;
if
(
parentWindow
)
parentWindow
-
>
RemoveChildWindow
(
this
)
;
ExitModalLoop
(
NS_OK
)
;
#
ifndef
MOZ_WIDGET_GTK
if
(
mWindow
)
mWindow
-
>
Show
(
false
)
;
#
endif
#
if
defined
(
XP_WIN
)
nsCOMPtr
<
nsIBaseWindow
>
parent
(
do_QueryReferent
(
mParentWindow
)
)
;
if
(
parent
)
{
nsCOMPtr
<
nsIWidget
>
parentWidget
;
parent
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
if
(
parentWidget
&
&
parentWidget
-
>
IsVisible
(
)
)
{
bool
isParentHiddenWindow
=
false
;
if
(
appShell
)
{
bool
hasHiddenWindow
=
false
;
appShell
-
>
GetHasHiddenWindow
(
&
hasHiddenWindow
)
;
if
(
hasHiddenWindow
)
{
nsCOMPtr
<
nsIBaseWindow
>
baseHiddenWindow
;
nsCOMPtr
<
nsIAppWindow
>
hiddenWindow
;
appShell
-
>
GetHiddenWindow
(
getter_AddRefs
(
hiddenWindow
)
)
;
if
(
hiddenWindow
)
{
baseHiddenWindow
=
do_GetInterface
(
hiddenWindow
)
;
isParentHiddenWindow
=
(
baseHiddenWindow
=
=
parent
)
;
}
}
}
if
(
!
isParentHiddenWindow
)
{
parentWidget
-
>
PlaceBehind
(
eZPlacementTop
0
true
)
;
}
}
}
#
endif
RemoveTooltipSupport
(
)
;
mDOMWindow
=
nullptr
;
if
(
mDocShell
)
{
RefPtr
<
BrowsingContext
>
bc
(
mDocShell
-
>
GetBrowsingContext
(
)
)
;
mDocShell
-
>
Destroy
(
)
;
bc
-
>
Detach
(
)
;
mDocShell
=
nullptr
;
}
mPrimaryContentShell
=
nullptr
;
if
(
mContentTreeOwner
)
{
mContentTreeOwner
-
>
AppWindow
(
nullptr
)
;
NS_RELEASE
(
mContentTreeOwner
)
;
}
if
(
mPrimaryContentTreeOwner
)
{
mPrimaryContentTreeOwner
-
>
AppWindow
(
nullptr
)
;
NS_RELEASE
(
mPrimaryContentTreeOwner
)
;
}
if
(
mChromeTreeOwner
)
{
mChromeTreeOwner
-
>
AppWindow
(
nullptr
)
;
NS_RELEASE
(
mChromeTreeOwner
)
;
}
if
(
mWindow
)
{
mWindow
-
>
SetWidgetListener
(
nullptr
)
;
mWindow
-
>
Destroy
(
)
;
mWindow
=
nullptr
;
}
if
(
!
mIsHiddenWindow
&
&
mRegistered
)
{
nsCOMPtr
<
nsIObserverService
>
obssvc
=
services
:
:
GetObserverService
(
)
;
NS_ASSERTION
(
obssvc
"
Couldn
'
t
get
observer
service
?
"
)
;
if
(
obssvc
)
obssvc
-
>
NotifyObservers
(
nullptr
"
xul
-
window
-
destroyed
"
nullptr
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetDevicePixelsPerDesktopPixel
(
double
*
aScale
)
{
*
aScale
=
mWindow
?
mWindow
-
>
GetDesktopToDeviceScale
(
)
.
scale
:
1
.
0
;
return
NS_OK
;
}
double
AppWindow
:
:
GetWidgetCSSToDeviceScale
(
)
{
return
mWindow
?
mWindow
-
>
GetDefaultScale
(
)
.
scale
:
1
.
0
;
}
NS_IMETHODIMP
AppWindow
:
:
SetPositionDesktopPix
(
int32_t
aX
int32_t
aY
)
{
mWindow
-
>
Move
(
aX
aY
)
;
if
(
mSizingShellFromXUL
)
{
return
NS_OK
;
}
if
(
!
mChromeLoaded
)
{
mIgnoreXULPosition
=
true
;
return
NS_OK
;
}
PersistentAttributesDirty
(
PAD_POSITION
)
;
SavePersistentAttributes
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetPosition
(
int32_t
aX
int32_t
aY
)
{
DesktopToLayoutDeviceScale
currScale
=
mWindow
-
>
GetDesktopToDeviceScale
(
)
;
DesktopPoint
pos
=
LayoutDeviceIntPoint
(
aX
aY
)
/
currScale
;
return
SetPositionDesktopPix
(
pos
.
x
pos
.
y
)
;
}
NS_IMETHODIMP
AppWindow
:
:
GetPosition
(
int32_t
*
aX
int32_t
*
aY
)
{
return
GetPositionAndSize
(
aX
aY
nullptr
nullptr
)
;
}
NS_IMETHODIMP
AppWindow
:
:
SetSize
(
int32_t
aCX
int32_t
aCY
bool
aRepaint
)
{
mWindow
-
>
SetSizeMode
(
nsSizeMode_Normal
)
;
mIntrinsicallySized
=
false
;
DesktopToLayoutDeviceScale
scale
=
mWindow
-
>
GetDesktopToDeviceScale
(
)
;
DesktopSize
size
=
LayoutDeviceIntSize
(
aCX
aCY
)
/
scale
;
mWindow
-
>
Resize
(
size
.
width
size
.
height
aRepaint
)
;
if
(
mSizingShellFromXUL
)
{
return
NS_OK
;
}
if
(
!
mChromeLoaded
)
{
mIgnoreXULSize
=
true
;
mIgnoreXULSizeMode
=
true
;
return
NS_OK
;
}
PersistentAttributesDirty
(
PAD_SIZE
)
;
SavePersistentAttributes
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetSize
(
int32_t
*
aCX
int32_t
*
aCY
)
{
return
GetPositionAndSize
(
nullptr
nullptr
aCX
aCY
)
;
}
NS_IMETHODIMP
AppWindow
:
:
SetPositionAndSize
(
int32_t
aX
int32_t
aY
int32_t
aCX
int32_t
aCY
uint32_t
aFlags
)
{
mWindow
-
>
SetSizeMode
(
nsSizeMode_Normal
)
;
mIntrinsicallySized
=
false
;
DesktopToLayoutDeviceScale
scale
=
mWindow
-
>
GetDesktopToDeviceScale
(
)
;
DesktopRect
rect
=
LayoutDeviceIntRect
(
aX
aY
aCX
aCY
)
/
scale
;
mWindow
-
>
Resize
(
rect
.
X
(
)
rect
.
Y
(
)
rect
.
Width
(
)
rect
.
Height
(
)
!
!
(
aFlags
&
nsIBaseWindow
:
:
eRepaint
)
)
;
if
(
mSizingShellFromXUL
)
{
return
NS_OK
;
}
if
(
!
mChromeLoaded
)
{
mIgnoreXULPosition
=
true
;
mIgnoreXULSize
=
true
;
mIgnoreXULSizeMode
=
true
;
return
NS_OK
;
}
PersistentAttributesDirty
(
PAD_POSITION
|
PAD_SIZE
)
;
SavePersistentAttributes
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetPositionAndSize
(
int32_t
*
x
int32_t
*
y
int32_t
*
cx
int32_t
*
cy
)
{
if
(
!
mWindow
)
return
NS_ERROR_FAILURE
;
LayoutDeviceIntRect
rect
=
mWindow
-
>
GetScreenBounds
(
)
;
if
(
x
)
*
x
=
rect
.
X
(
)
;
if
(
y
)
*
y
=
rect
.
Y
(
)
;
if
(
cx
)
*
cx
=
rect
.
Width
(
)
;
if
(
cy
)
*
cy
=
rect
.
Height
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
Center
(
nsIAppWindow
*
aRelative
bool
aScreen
bool
aAlert
)
{
DesktopIntRect
rect
;
bool
screenCoordinates
=
false
windowCoordinates
=
false
;
nsresult
result
;
if
(
!
mChromeLoaded
)
{
mCenterAfterLoad
=
true
;
return
NS_OK
;
}
if
(
!
aScreen
&
&
!
aRelative
)
return
NS_ERROR_INVALID_ARG
;
nsCOMPtr
<
nsIScreenManager
>
screenmgr
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
&
result
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
nsCOMPtr
<
nsIScreen
>
screen
;
if
(
aRelative
)
{
nsCOMPtr
<
nsIBaseWindow
>
base
(
do_QueryInterface
(
aRelative
)
)
;
if
(
base
)
{
rect
=
RoundedToInt
(
base
-
>
GetPositionAndSize
(
)
/
base
-
>
DevicePixelsPerDesktopPixel
(
)
)
;
if
(
aScreen
)
{
screen
=
screenmgr
-
>
ScreenForRect
(
rect
)
;
}
else
{
windowCoordinates
=
true
;
}
}
}
if
(
!
aRelative
)
{
if
(
!
mOpenerScreenRect
.
IsEmpty
(
)
)
{
screen
=
screenmgr
-
>
ScreenForRect
(
mOpenerScreenRect
)
;
}
else
{
screenmgr
-
>
GetPrimaryScreen
(
getter_AddRefs
(
screen
)
)
;
}
}
if
(
aScreen
&
&
screen
)
{
rect
=
screen
-
>
GetAvailRectDisplayPix
(
)
;
screenCoordinates
=
true
;
}
if
(
!
screenCoordinates
&
&
!
windowCoordinates
)
{
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
mWindow
"
what
no
window
?
"
)
;
const
LayoutDeviceIntSize
ourDevSize
=
GetSize
(
)
;
const
DesktopIntSize
ourSize
=
RoundedToInt
(
ourDevSize
/
DevicePixelsPerDesktopPixel
(
)
)
;
rect
.
x
+
=
(
rect
.
width
-
ourSize
.
width
)
/
2
;
rect
.
y
+
=
(
rect
.
height
-
ourSize
.
height
)
/
(
aAlert
?
3
:
2
)
;
if
(
windowCoordinates
)
{
mWindow
-
>
ConstrainPosition
(
false
&
rect
.
x
&
rect
.
y
)
;
}
SetPositionDesktopPix
(
rect
.
x
rect
.
y
)
;
if
(
GetSize
(
)
!
=
ourDevSize
)
{
return
Center
(
aRelative
aScreen
aAlert
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
Repaint
(
bool
aForce
)
{
NS_ASSERTION
(
false
"
Not
Yet
Implemented
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetParentWidget
(
nsIWidget
*
*
aParentWidget
)
{
NS_ENSURE_ARG_POINTER
(
aParentWidget
)
;
NS_ENSURE_STATE
(
mWindow
)
;
NS_IF_ADDREF
(
*
aParentWidget
=
mWindow
-
>
GetParent
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetParentWidget
(
nsIWidget
*
aParentWidget
)
{
NS_ASSERTION
(
false
"
Not
Yet
Implemented
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetParentNativeWindow
(
nativeWindow
*
aParentNativeWindow
)
{
NS_ENSURE_ARG_POINTER
(
aParentNativeWindow
)
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
NS_ENSURE_SUCCESS
(
GetParentWidget
(
getter_AddRefs
(
parentWidget
)
)
NS_ERROR_FAILURE
)
;
if
(
parentWidget
)
{
*
aParentNativeWindow
=
parentWidget
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetParentNativeWindow
(
nativeWindow
aParentNativeWindow
)
{
NS_ASSERTION
(
false
"
Not
Yet
Implemented
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetNativeHandle
(
nsAString
&
aNativeHandle
)
{
nsCOMPtr
<
nsIWidget
>
mainWidget
;
NS_ENSURE_SUCCESS
(
GetMainWidget
(
getter_AddRefs
(
mainWidget
)
)
NS_ERROR_FAILURE
)
;
if
(
mainWidget
)
{
nativeWindow
nativeWindowPtr
=
mainWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
aNativeHandle
=
NS_ConvertASCIItoUTF16
(
nsPrintfCString
(
"
0x
%
p
"
nativeWindowPtr
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetVisibility
(
bool
*
aVisibility
)
{
NS_ENSURE_ARG_POINTER
(
aVisibility
)
;
*
aVisibility
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetVisibility
(
bool
aVisibility
)
{
if
(
!
mChromeLoaded
)
{
mShowAfterLoad
=
aVisibility
;
return
NS_OK
;
}
if
(
mDebuting
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mDocShell
)
;
mDebuting
=
true
;
mDocShell
-
>
SetVisibility
(
aVisibility
)
;
nsCOMPtr
<
nsIWidget
>
window
=
mWindow
;
window
-
>
Show
(
aVisibility
)
;
nsCOMPtr
<
nsIWindowMediator
>
windowMediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
windowMediator
)
windowMediator
-
>
UpdateWindowTimeStamp
(
static_cast
<
nsIAppWindow
*
>
(
this
)
)
;
nsCOMPtr
<
nsIObserverService
>
obssvc
=
services
:
:
GetObserverService
(
)
;
NS_ASSERTION
(
obssvc
"
Couldn
'
t
get
observer
service
.
"
)
;
if
(
obssvc
)
{
obssvc
-
>
NotifyObservers
(
static_cast
<
nsIAppWindow
*
>
(
this
)
"
xul
-
window
-
visible
"
nullptr
)
;
}
mDebuting
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetEnabled
(
bool
*
aEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aEnabled
)
;
if
(
mWindow
)
{
*
aEnabled
=
mWindow
-
>
IsEnabled
(
)
;
return
NS_OK
;
}
*
aEnabled
=
true
;
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
AppWindow
:
:
SetEnabled
(
bool
aEnable
)
{
if
(
mWindow
)
{
mWindow
-
>
Enable
(
aEnable
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
AppWindow
:
:
GetMainWidget
(
nsIWidget
*
*
aMainWidget
)
{
NS_ENSURE_ARG_POINTER
(
aMainWidget
)
;
NS_IF_ADDREF
(
*
aMainWidget
=
mWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetTitle
(
nsAString
&
aTitle
)
{
aTitle
=
mTitle
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetTitle
(
const
nsAString
&
aTitle
)
{
NS_ENSURE_STATE
(
mWindow
)
;
mTitle
.
Assign
(
aTitle
)
;
mTitle
.
StripCRLF
(
)
;
NS_ENSURE_SUCCESS
(
mWindow
-
>
SetTitle
(
mTitle
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
EnsureChromeTreeOwner
(
)
{
if
(
mChromeTreeOwner
)
return
NS_OK
;
mChromeTreeOwner
=
new
nsChromeTreeOwner
(
)
;
NS_ADDREF
(
mChromeTreeOwner
)
;
mChromeTreeOwner
-
>
AppWindow
(
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
EnsureContentTreeOwner
(
)
{
if
(
mContentTreeOwner
)
return
NS_OK
;
mContentTreeOwner
=
new
nsContentTreeOwner
(
false
)
;
NS_ADDREF
(
mContentTreeOwner
)
;
mContentTreeOwner
-
>
AppWindow
(
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
EnsurePrimaryContentTreeOwner
(
)
{
if
(
mPrimaryContentTreeOwner
)
return
NS_OK
;
mPrimaryContentTreeOwner
=
new
nsContentTreeOwner
(
true
)
;
NS_ADDREF
(
mPrimaryContentTreeOwner
)
;
mPrimaryContentTreeOwner
-
>
AppWindow
(
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
EnsurePrompter
(
)
{
if
(
mPrompter
)
return
NS_OK
;
nsCOMPtr
<
mozIDOMWindowProxy
>
ourWindow
;
nsresult
rv
=
GetWindowDOMWindow
(
getter_AddRefs
(
ourWindow
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIWindowWatcher
>
wwatch
=
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
)
;
if
(
wwatch
)
wwatch
-
>
GetNewPrompter
(
ourWindow
getter_AddRefs
(
mPrompter
)
)
;
}
return
mPrompter
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
AppWindow
:
:
EnsureAuthPrompter
(
)
{
if
(
mAuthPrompter
)
return
NS_OK
;
nsCOMPtr
<
mozIDOMWindowProxy
>
ourWindow
;
nsresult
rv
=
GetWindowDOMWindow
(
getter_AddRefs
(
ourWindow
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIWindowWatcher
>
wwatch
(
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
)
)
;
if
(
wwatch
)
wwatch
-
>
GetNewAuthPrompter
(
ourWindow
getter_AddRefs
(
mAuthPrompter
)
)
;
}
return
mAuthPrompter
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
AppWindow
:
:
GetAvailScreenSize
(
int32_t
*
aAvailWidth
int32_t
*
aAvailHeight
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
domWindow
;
GetWindowDOMWindow
(
getter_AddRefs
(
domWindow
)
)
;
NS_ENSURE_STATE
(
domWindow
)
;
auto
*
window
=
nsGlobalWindowOuter
:
:
Cast
(
domWindow
)
;
RefPtr
<
nsScreen
>
screen
=
window
-
>
GetScreen
(
)
;
NS_ENSURE_STATE
(
screen
)
;
ErrorResult
rv
;
*
aAvailWidth
=
screen
-
>
GetAvailWidth
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
*
aAvailHeight
=
screen
-
>
GetAvailHeight
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
ForceRoundedDimensions
(
)
{
if
(
mIsHiddenWindow
)
{
return
NS_OK
;
}
int32_t
availWidthCSS
=
0
;
int32_t
availHeightCSS
=
0
;
int32_t
contentWidthCSS
=
0
;
int32_t
contentHeightCSS
=
0
;
int32_t
windowWidthCSS
=
0
;
int32_t
windowHeightCSS
=
0
;
double
devicePerCSSPixels
=
UnscaledDevicePixelsPerCSSPixel
(
)
.
scale
;
GetAvailScreenSize
(
&
availWidthCSS
&
availHeightCSS
)
;
SetSpecifiedSize
(
availWidthCSS
availHeightCSS
)
;
GetSize
(
&
windowWidthCSS
&
windowHeightCSS
)
;
windowWidthCSS
=
NSToIntRound
(
windowWidthCSS
/
devicePerCSSPixels
)
;
windowHeightCSS
=
NSToIntRound
(
windowHeightCSS
/
devicePerCSSPixels
)
;
GetPrimaryContentSize
(
&
contentWidthCSS
&
contentHeightCSS
)
;
int32_t
chromeWidth
=
0
chromeHeight
=
0
;
chromeWidth
=
windowWidthCSS
-
contentWidthCSS
;
chromeHeight
=
windowHeightCSS
-
contentHeightCSS
;
int32_t
targetContentWidth
=
0
targetContentHeight
=
0
;
nsContentUtils
:
:
CalcRoundedWindowSizeForResistingFingerprinting
(
chromeWidth
chromeHeight
availWidthCSS
availHeightCSS
availWidthCSS
availHeightCSS
false
false
&
targetContentWidth
&
targetContentHeight
)
;
targetContentWidth
=
NSToIntRound
(
targetContentWidth
*
devicePerCSSPixels
)
;
targetContentHeight
=
NSToIntRound
(
targetContentHeight
*
devicePerCSSPixels
)
;
SetPrimaryContentSize
(
targetContentWidth
targetContentHeight
)
;
return
NS_OK
;
}
void
AppWindow
:
:
OnChromeLoaded
(
)
{
nsresult
rv
=
EnsureContentTreeOwner
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mChromeLoaded
=
true
;
ApplyChromeFlags
(
)
;
SyncAttributesToWidget
(
)
;
if
(
mWindow
)
{
SizeShell
(
)
;
if
(
mShowAfterLoad
)
{
SetVisibility
(
true
)
;
}
AddTooltipSupport
(
)
;
}
}
mPersistentAttributesMask
|
=
PAD_POSITION
|
PAD_SIZE
|
PAD_MISC
;
}
bool
AppWindow
:
:
NeedsTooltipListener
(
)
{
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
if
(
!
docShellElement
|
|
docShellElement
-
>
IsXULElement
(
)
)
{
return
false
;
}
return
true
;
}
void
AppWindow
:
:
AddTooltipSupport
(
)
{
if
(
!
NeedsTooltipListener
(
)
)
{
return
;
}
nsXULTooltipListener
*
listener
=
nsXULTooltipListener
:
:
GetInstance
(
)
;
if
(
!
listener
)
{
return
;
}
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
MOZ_ASSERT
(
docShellElement
)
;
listener
-
>
AddTooltipSupport
(
docShellElement
)
;
}
void
AppWindow
:
:
RemoveTooltipSupport
(
)
{
if
(
!
NeedsTooltipListener
(
)
)
{
return
;
}
nsXULTooltipListener
*
listener
=
nsXULTooltipListener
:
:
GetInstance
(
)
;
if
(
!
listener
)
{
return
;
}
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
MOZ_ASSERT
(
docShellElement
)
;
listener
-
>
RemoveTooltipSupport
(
docShellElement
)
;
}
bool
AppWindow
:
:
LoadPositionFromXUL
(
int32_t
aSpecWidth
int32_t
aSpecHeight
)
{
bool
gotPosition
=
false
;
if
(
mIsHiddenWindow
)
return
false
;
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
NS_ENSURE_TRUE
(
windowElement
false
)
;
const
LayoutDeviceIntRect
devRect
=
GetPositionAndSize
(
)
;
const
DesktopIntPoint
curPoint
=
RoundedToInt
(
devRect
.
TopLeft
(
)
/
DevicePixelsPerDesktopPixel
(
)
)
;
CSSIntSize
cssSize
(
aSpecWidth
aSpecHeight
)
;
{
CSSIntSize
currentSize
=
RoundedToInt
(
devRect
.
Size
(
)
/
UnscaledDevicePixelsPerCSSPixel
(
)
)
;
if
(
aSpecHeight
<
=
0
)
{
cssSize
.
height
=
currentSize
.
height
;
}
if
(
aSpecWidth
<
=
0
)
{
cssSize
.
width
=
currentSize
.
width
;
}
}
nsAutoString
posString
;
DesktopIntPoint
specPoint
=
curPoint
;
nsresult
errorCode
;
windowElement
-
>
GetAttribute
(
SCREENX_ATTRIBUTE
posString
)
;
int32_t
temp
=
posString
.
ToInteger
(
&
errorCode
)
;
if
(
NS_SUCCEEDED
(
errorCode
)
)
{
specPoint
.
x
=
temp
;
gotPosition
=
true
;
}
windowElement
-
>
GetAttribute
(
SCREENY_ATTRIBUTE
posString
)
;
temp
=
posString
.
ToInteger
(
&
errorCode
)
;
if
(
NS_SUCCEEDED
(
errorCode
)
)
{
specPoint
.
y
=
temp
;
gotPosition
=
true
;
}
if
(
gotPosition
)
{
nsCOMPtr
<
nsIBaseWindow
>
parent
(
do_QueryReferent
(
mParentWindow
)
)
;
if
(
parent
)
{
const
DesktopIntPoint
parentPos
=
RoundedToInt
(
parent
-
>
GetPosition
(
)
/
parent
-
>
DevicePixelsPerDesktopPixel
(
)
)
;
specPoint
+
=
parentPos
;
}
else
{
StaggerPosition
(
specPoint
.
x
specPoint
.
y
cssSize
.
width
cssSize
.
height
)
;
}
}
mWindow
-
>
ConstrainPosition
(
false
&
specPoint
.
x
&
specPoint
.
y
)
;
if
(
specPoint
!
=
curPoint
)
{
SetPositionDesktopPix
(
specPoint
.
x
specPoint
.
y
)
;
}
return
gotPosition
;
}
static
Maybe
<
int32_t
>
ReadIntAttribute
(
const
Element
&
aElement
nsAtom
*
aAtom
)
{
nsAutoString
attrString
;
if
(
!
aElement
.
GetAttr
(
kNameSpaceID_None
aAtom
attrString
)
)
{
return
Nothing
(
)
;
}
nsresult
res
=
NS_OK
;
int32_t
ret
=
attrString
.
ToInteger
(
&
res
)
;
return
NS_SUCCEEDED
(
res
)
?
Some
(
ret
)
:
Nothing
(
)
;
}
static
Maybe
<
int32_t
>
ReadSize
(
const
Element
&
aElement
nsAtom
*
aAttr
nsAtom
*
aMinAttr
nsAtom
*
aMaxAttr
)
{
Maybe
<
int32_t
>
attr
=
ReadIntAttribute
(
aElement
aAttr
)
;
if
(
!
attr
)
{
return
Nothing
(
)
;
}
int32_t
min
=
std
:
:
max
(
100
ReadIntAttribute
(
aElement
aMinAttr
)
.
valueOr
(
100
)
)
;
int32_t
max
=
ReadIntAttribute
(
aElement
aMaxAttr
)
.
valueOr
(
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
;
return
Some
(
std
:
:
min
(
max
std
:
:
max
(
*
attr
min
)
)
)
;
}
bool
AppWindow
:
:
LoadSizeFromXUL
(
int32_t
&
aSpecWidth
int32_t
&
aSpecHeight
)
{
bool
gotSize
=
false
;
if
(
mIsHiddenWindow
)
{
return
false
;
}
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
NS_ENSURE_TRUE
(
windowElement
false
)
;
aSpecWidth
=
100
;
aSpecHeight
=
100
;
if
(
auto
width
=
ReadSize
(
*
windowElement
nsGkAtoms
:
:
width
nsGkAtoms
:
:
minwidth
nsGkAtoms
:
:
maxwidth
)
)
{
aSpecWidth
=
*
width
;
gotSize
=
true
;
}
if
(
auto
height
=
ReadSize
(
*
windowElement
nsGkAtoms
:
:
height
nsGkAtoms
:
:
minheight
nsGkAtoms
:
:
maxheight
)
)
{
aSpecHeight
=
*
height
;
gotSize
=
true
;
}
return
gotSize
;
}
void
AppWindow
:
:
SetSpecifiedSize
(
int32_t
aSpecWidth
int32_t
aSpecHeight
)
{
{
int32_t
screenWidth
;
int32_t
screenHeight
;
if
(
NS_SUCCEEDED
(
GetAvailScreenSize
(
&
screenWidth
&
screenHeight
)
)
)
{
if
(
aSpecWidth
>
screenWidth
)
{
aSpecWidth
=
screenWidth
;
}
if
(
aSpecHeight
>
screenHeight
)
{
aSpecHeight
=
screenHeight
;
}
}
}
NS_ASSERTION
(
mWindow
"
we
expected
to
have
a
window
already
"
)
;
mIntrinsicallySized
=
false
;
auto
newSize
=
RoundedToInt
(
CSSIntSize
(
aSpecWidth
aSpecHeight
)
*
UnscaledDevicePixelsPerCSSPixel
(
)
)
;
if
(
newSize
!
=
GetSize
(
)
)
{
SetSize
(
newSize
.
width
newSize
.
height
false
)
;
}
}
bool
AppWindow
:
:
UpdateWindowStateFromMiscXULAttributes
(
)
{
bool
gotState
=
false
;
if
(
mIsHiddenWindow
)
return
false
;
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
NS_ENSURE_TRUE
(
windowElement
false
)
;
nsAutoString
stateString
;
nsSizeMode
sizeMode
=
nsSizeMode_Normal
;
if
(
mIgnoreXULSizeMode
)
{
windowElement
-
>
SetAttribute
(
MODE_ATTRIBUTE
SIZEMODE_NORMAL
IgnoreErrors
(
)
)
;
}
else
{
windowElement
-
>
GetAttribute
(
MODE_ATTRIBUTE
stateString
)
;
if
(
(
stateString
.
Equals
(
SIZEMODE_MAXIMIZED
)
|
|
stateString
.
Equals
(
SIZEMODE_FULLSCREEN
)
)
)
{
if
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RESIZE
)
{
mIntrinsicallySized
=
false
;
if
(
stateString
.
Equals
(
SIZEMODE_MAXIMIZED
)
)
sizeMode
=
nsSizeMode_Maximized
;
else
sizeMode
=
nsSizeMode_Fullscreen
;
}
}
}
if
(
sizeMode
=
=
nsSizeMode_Fullscreen
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
ourWindow
;
GetWindowDOMWindow
(
getter_AddRefs
(
ourWindow
)
)
;
auto
*
piWindow
=
nsPIDOMWindowOuter
:
:
From
(
ourWindow
)
;
piWindow
-
>
SetFullScreen
(
true
)
;
}
else
{
if
(
sizeMode
=
=
nsSizeMode_Maximized
)
{
mIgnoreXULSize
=
true
;
mIgnoreXULPosition
=
true
;
}
mWindow
-
>
SetSizeMode
(
sizeMode
)
;
}
gotState
=
true
;
windowElement
-
>
GetAttribute
(
ZLEVEL_ATTRIBUTE
stateString
)
;
if
(
!
stateString
.
IsEmpty
(
)
)
{
nsresult
errorCode
;
int32_t
zLevel
=
stateString
.
ToInteger
(
&
errorCode
)
;
if
(
NS_SUCCEEDED
(
errorCode
)
&
&
zLevel
>
=
lowestZ
&
&
zLevel
<
=
highestZ
)
SetZLevel
(
zLevel
)
;
}
return
gotState
;
}
void
AppWindow
:
:
StaggerPosition
(
int32_t
&
aRequestedX
int32_t
&
aRequestedY
int32_t
aSpecWidth
int32_t
aSpecHeight
)
{
int32_t
kOffset
=
22
;
uint32_t
kSlop
=
4
;
bool
keepTrying
;
int
bouncedX
=
0
bouncedY
=
0
;
nsCOMPtr
<
nsIWindowMediator
>
wm
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
!
wm
)
return
;
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
if
(
!
windowElement
)
return
;
nsCOMPtr
<
nsIAppWindow
>
ourAppWindow
(
this
)
;
nsAutoString
windowType
;
windowElement
-
>
GetAttribute
(
WINDOWTYPE_ATTRIBUTE
windowType
)
;
DesktopIntRect
screenRect
;
bool
gotScreen
=
false
;
{
nsCOMPtr
<
nsIScreenManager
>
screenMgr
(
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
)
;
if
(
screenMgr
)
{
nsCOMPtr
<
nsIScreen
>
ourScreen
;
screenMgr
-
>
ScreenForRect
(
aRequestedX
aRequestedY
aSpecWidth
aSpecHeight
getter_AddRefs
(
ourScreen
)
)
;
if
(
ourScreen
)
{
screenRect
=
ourScreen
-
>
GetAvailRectDisplayPix
(
)
;
auto
scale
=
ourScreen
-
>
GetCSSToDesktopScale
(
)
;
kOffset
=
(
CSSCoord
(
kOffset
)
*
scale
)
.
Rounded
(
)
;
kSlop
=
(
CSSCoord
(
kSlop
)
*
scale
)
.
Rounded
(
)
;
aSpecWidth
=
(
CSSCoord
(
aSpecWidth
)
*
scale
)
.
Rounded
(
)
;
aSpecHeight
=
(
CSSCoord
(
aSpecHeight
)
*
scale
)
.
Rounded
(
)
;
gotScreen
=
true
;
}
}
}
do
{
keepTrying
=
false
;
nsCOMPtr
<
nsISimpleEnumerator
>
windowList
;
wm
-
>
GetAppWindowEnumerator
(
windowType
.
get
(
)
getter_AddRefs
(
windowList
)
)
;
if
(
!
windowList
)
break
;
do
{
bool
more
;
windowList
-
>
HasMoreElements
(
&
more
)
;
if
(
!
more
)
break
;
nsCOMPtr
<
nsISupports
>
supportsWindow
;
windowList
-
>
GetNext
(
getter_AddRefs
(
supportsWindow
)
)
;
nsCOMPtr
<
nsIAppWindow
>
listAppWindow
(
do_QueryInterface
(
supportsWindow
)
)
;
if
(
listAppWindow
!
=
ourAppWindow
)
{
int32_t
listX
listY
;
nsCOMPtr
<
nsIBaseWindow
>
listBaseWindow
(
do_QueryInterface
(
supportsWindow
)
)
;
listBaseWindow
-
>
GetPosition
(
&
listX
&
listY
)
;
double
scale
;
if
(
NS_SUCCEEDED
(
listBaseWindow
-
>
GetDevicePixelsPerDesktopPixel
(
&
scale
)
)
)
{
listX
=
NSToIntRound
(
listX
/
scale
)
;
listY
=
NSToIntRound
(
listY
/
scale
)
;
}
if
(
Abs
(
listX
-
aRequestedX
)
<
=
kSlop
&
&
Abs
(
listY
-
aRequestedY
)
<
=
kSlop
)
{
if
(
bouncedX
&
0x1
)
aRequestedX
-
=
kOffset
;
else
aRequestedX
+
=
kOffset
;
aRequestedY
+
=
kOffset
;
if
(
gotScreen
)
{
if
(
!
(
bouncedX
&
0x1
)
&
&
(
(
aRequestedX
+
aSpecWidth
)
>
screenRect
.
XMost
(
)
)
)
{
aRequestedX
=
screenRect
.
XMost
(
)
-
aSpecWidth
;
+
+
bouncedX
;
}
if
(
(
bouncedX
&
0x1
)
&
&
aRequestedX
<
screenRect
.
X
(
)
)
{
aRequestedX
=
screenRect
.
X
(
)
;
+
+
bouncedX
;
}
if
(
aRequestedY
+
aSpecHeight
>
screenRect
.
YMost
(
)
)
{
aRequestedY
=
screenRect
.
Y
(
)
;
+
+
bouncedY
;
}
}
keepTrying
=
bouncedX
<
2
|
|
bouncedY
=
=
0
;
break
;
}
}
}
while
(
true
)
;
}
while
(
keepTrying
)
;
}
void
AppWindow
:
:
SyncAttributesToWidget
(
)
{
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
if
(
!
windowElement
)
return
;
MOZ_DIAGNOSTIC_ASSERT
(
mWindow
"
No
widget
on
SyncAttributesToWidget
?
"
)
;
nsAutoString
attr
;
if
(
windowElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
hidechrome
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
mWindow
-
>
HideWindowChrome
(
true
)
;
}
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
nsIntMargin
margins
;
windowElement
-
>
GetAttribute
(
u
"
chromemargin
"
_ns
attr
)
;
if
(
nsContentUtils
:
:
ParseIntMarginValue
(
attr
margins
)
)
{
LayoutDeviceIntMargin
tmp
=
LayoutDeviceIntMargin
:
:
FromUnknownMargin
(
margins
)
;
mWindow
-
>
SetNonClientMargins
(
tmp
)
;
}
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
windowElement
-
>
GetAttribute
(
WINDOWTYPE_ATTRIBUTE
attr
)
;
if
(
!
attr
.
IsEmpty
(
)
)
{
mWindow
-
>
SetWindowClass
(
attr
)
;
}
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
windowElement
-
>
GetAttribute
(
u
"
icon
"
_ns
attr
)
;
if
(
!
attr
.
IsEmpty
(
)
)
{
mWindow
-
>
SetIcon
(
attr
)
;
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
}
windowElement
-
>
GetAttribute
(
u
"
drawtitle
"
_ns
attr
)
;
mWindow
-
>
SetDrawsTitle
(
attr
.
LowerCaseEqualsLiteral
(
"
true
"
)
)
;
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
windowElement
-
>
GetAttribute
(
u
"
toggletoolbar
"
_ns
attr
)
;
mWindow
-
>
SetShowsToolbarButton
(
attr
.
LowerCaseEqualsLiteral
(
"
true
"
)
)
;
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
windowElement
-
>
GetAttribute
(
u
"
macnativefullscreen
"
_ns
attr
)
;
mWindow
-
>
SetSupportsNativeFullscreen
(
attr
.
LowerCaseEqualsLiteral
(
"
true
"
)
)
;
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
windowElement
-
>
GetAttribute
(
u
"
macanimationtype
"
_ns
attr
)
;
if
(
attr
.
EqualsLiteral
(
"
document
"
)
)
{
mWindow
-
>
SetWindowAnimationType
(
nsIWidget
:
:
eDocumentWindowAnimation
)
;
}
}
enum
class
ConversionDirection
{
InnerToOuter
OuterToInner
}
;
static
void
ConvertWindowSize
(
nsIAppWindow
*
aWin
const
nsAtom
*
aAttr
ConversionDirection
aDirection
nsAString
&
aInOutString
)
{
MOZ_ASSERT
(
aWin
)
;
MOZ_ASSERT
(
aAttr
=
=
nsGkAtoms
:
:
width
|
|
aAttr
=
=
nsGkAtoms
:
:
height
)
;
nsresult
rv
;
int32_t
size
=
aInOutString
.
ToInteger
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
int32_t
sizeDiff
=
aAttr
=
=
nsGkAtoms
:
:
width
?
aWin
-
>
GetOuterToInnerWidthDifferenceInCSSPixels
(
)
:
aWin
-
>
GetOuterToInnerHeightDifferenceInCSSPixels
(
)
;
if
(
!
sizeDiff
)
{
return
;
}
int32_t
multiplier
=
aDirection
=
=
ConversionDirection
:
:
InnerToOuter
?
1
:
-
1
;
CopyASCIItoUTF16
(
nsPrintfCString
(
"
%
d
"
size
+
multiplier
*
sizeDiff
)
aInOutString
)
;
}
nsresult
AppWindow
:
:
GetPersistentValue
(
const
nsAtom
*
aAttr
nsAString
&
aValue
)
{
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
if
(
!
docShellElement
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
windowElementId
;
docShellElement
-
>
GetId
(
windowElementId
)
;
if
(
windowElementId
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
RefPtr
<
dom
:
:
Document
>
ownerDoc
=
docShellElement
-
>
OwnerDoc
(
)
;
nsIURI
*
docURI
=
ownerDoc
-
>
GetDocumentURI
(
)
;
if
(
!
docURI
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
utf8uri
;
nsresult
rv
=
docURI
-
>
GetSpec
(
utf8uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ConvertUTF8toUTF16
uri
(
utf8uri
)
;
#
ifdef
MOZ_NEW_XULSTORE
nsDependentAtomString
attrString
(
aAttr
)
;
rv
=
XULStore
:
:
GetValue
(
uri
windowElementId
attrString
aValue
)
;
#
else
if
(
!
mLocalStore
)
{
mLocalStore
=
do_GetService
(
"
mozilla
.
org
/
xul
/
xulstore
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mLocalStore
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
}
rv
=
mLocalStore
-
>
GetValue
(
uri
windowElementId
nsDependentAtomString
(
aAttr
)
aValue
)
;
#
endif
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aAttr
=
=
nsGkAtoms
:
:
width
|
|
aAttr
=
=
nsGkAtoms
:
:
height
)
{
ConvertWindowSize
(
this
aAttr
ConversionDirection
:
:
OuterToInner
aValue
)
;
}
return
NS_OK
;
}
nsresult
AppWindow
:
:
GetDocXulStoreKeys
(
nsString
&
aUriSpec
nsString
&
aWindowElementId
)
{
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
if
(
!
docShellElement
)
{
return
NS_ERROR_FAILURE
;
}
docShellElement
-
>
GetId
(
aWindowElementId
)
;
if
(
aWindowElementId
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
RefPtr
<
dom
:
:
Document
>
ownerDoc
=
docShellElement
-
>
OwnerDoc
(
)
;
nsIURI
*
docURI
=
ownerDoc
-
>
GetDocumentURI
(
)
;
if
(
!
docURI
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
utf8uri
;
nsresult
rv
=
docURI
-
>
GetSpec
(
utf8uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aUriSpec
=
NS_ConvertUTF8toUTF16
(
utf8uri
)
;
return
NS_OK
;
}
nsresult
AppWindow
:
:
MaybeSaveEarlyWindowPersistentValues
(
const
LayoutDeviceIntRect
&
aRect
)
{
#
ifdef
XP_WIN
nsAutoString
uri
;
nsAutoString
windowElementId
;
nsresult
rv
=
GetDocXulStoreKeys
(
uri
windowElementId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
windowElementId
.
EqualsLiteral
(
"
main
-
window
"
)
|
|
!
uri
.
EqualsLiteral
(
"
chrome
:
/
/
browser
/
content
/
browser
.
xhtml
"
)
)
{
return
NS_OK
;
}
SkeletonUISettings
settings
;
settings
.
screenX
=
aRect
.
X
(
)
;
settings
.
screenY
=
aRect
.
Y
(
)
;
settings
.
width
=
aRect
.
Width
(
)
;
settings
.
height
=
aRect
.
Height
(
)
;
settings
.
maximized
=
mWindow
-
>
SizeMode
(
)
=
=
nsSizeMode_Maximized
;
settings
.
cssToDevPixelScaling
=
UnscaledDevicePixelsPerCSSPixel
(
)
.
scale
;
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
Document
*
doc
=
windowElement
-
>
GetComposedDoc
(
)
;
Element
*
urlbarEl
=
doc
-
>
GetElementById
(
u
"
urlbar
"
_ns
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocShell
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsIDOMWindowUtils
>
utils
=
nsGlobalWindowOuter
:
:
Cast
(
window
)
-
>
WindowUtils
(
)
;
RefPtr
<
dom
:
:
DOMRect
>
urlbarRect
;
rv
=
utils
-
>
GetBoundsWithoutFlushing
(
urlbarEl
getter_AddRefs
(
urlbarRect
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
double
urlbarX
=
urlbarRect
-
>
X
(
)
;
double
urlbarWidth
=
urlbarRect
-
>
Width
(
)
;
nsAutoString
attributeValue
;
urlbarEl
-
>
GetAttribute
(
u
"
breakout
-
extend
"
_ns
attributeValue
)
;
if
(
attributeValue
.
EqualsLiteral
(
"
true
"
)
)
{
int
urlbarBreakoutExtend
=
2
;
int
urlbarMarginInline
=
5
;
urlbarX
+
=
(
double
)
(
urlbarBreakoutExtend
+
urlbarMarginInline
)
;
urlbarWidth
-
=
(
double
)
(
2
*
(
urlbarBreakoutExtend
+
urlbarMarginInline
)
)
;
}
CSSPixelSpan
urlbar
;
urlbar
.
start
=
urlbarX
;
urlbar
.
end
=
urlbar
.
start
+
urlbarWidth
;
settings
.
urlbarSpan
=
urlbar
;
Element
*
navbar
=
doc
-
>
GetElementById
(
u
"
nav
-
bar
"
_ns
)
;
Element
*
searchbarEl
=
doc
-
>
GetElementById
(
u
"
searchbar
"
_ns
)
;
CSSPixelSpan
searchbar
;
if
(
navbar
-
>
Contains
(
searchbarEl
)
)
{
RefPtr
<
dom
:
:
DOMRect
>
searchbarRect
;
rv
=
utils
-
>
GetBoundsWithoutFlushing
(
searchbarEl
getter_AddRefs
(
searchbarRect
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
searchbar
.
start
=
searchbarRect
-
>
X
(
)
;
searchbar
.
end
=
searchbar
.
start
+
searchbarRect
-
>
Width
(
)
;
}
else
{
searchbar
.
start
=
0
;
searchbar
.
end
=
0
;
}
settings
.
searchbarSpan
=
searchbar
;
nsAutoString
bookmarksVisibility
;
Preferences
:
:
GetString
(
"
browser
.
toolbars
.
bookmarks
.
visibility
"
bookmarksVisibility
)
;
settings
.
bookmarksToolbarShown
=
bookmarksVisibility
.
EqualsLiteral
(
"
always
"
)
|
|
bookmarksVisibility
.
EqualsLiteral
(
"
newtab
"
)
;
Element
*
menubar
=
doc
-
>
GetElementById
(
u
"
toolbar
-
menubar
"
_ns
)
;
menubar
-
>
GetAttribute
(
u
"
autohide
"
_ns
attributeValue
)
;
settings
.
menubarShown
=
attributeValue
.
EqualsLiteral
(
"
false
"
)
;
ErrorResult
err
;
nsCOMPtr
<
nsIHTMLCollection
>
toolbarSprings
=
navbar
-
>
GetElementsByTagNameNS
(
u
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
_ns
u
"
toolbarspring
"
_ns
err
)
;
if
(
err
.
Failed
(
)
)
{
return
NS_ERROR_FAILURE
;
}
mozilla
:
:
Vector
<
CSSPixelSpan
>
springs
;
for
(
size_t
i
=
0
;
i
<
toolbarSprings
-
>
Length
(
)
;
i
+
+
)
{
RefPtr
<
Element
>
springEl
=
toolbarSprings
-
>
Item
(
i
)
;
RefPtr
<
dom
:
:
DOMRect
>
springRect
;
rv
=
utils
-
>
GetBoundsWithoutFlushing
(
springEl
getter_AddRefs
(
springRect
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
CSSPixelSpan
spring
;
spring
.
start
=
springRect
-
>
X
(
)
;
spring
.
end
=
spring
.
start
+
springRect
-
>
Width
(
)
;
if
(
!
settings
.
springs
.
append
(
spring
)
)
{
return
NS_ERROR_FAILURE
;
}
}
settings
.
rtlEnabled
=
intl
:
:
LocaleService
:
:
GetInstance
(
)
-
>
IsAppLocaleRTL
(
)
;
bool
isInTabletMode
=
false
;
bool
autoTouchModePref
=
Preferences
:
:
GetBool
(
"
browser
.
touchmode
.
auto
"
false
)
;
if
(
autoTouchModePref
)
{
nsCOMPtr
<
nsIWindowsUIUtils
>
uiUtils
(
do_GetService
(
"
mozilla
.
org
/
windows
-
ui
-
utils
;
1
"
)
)
;
if
(
!
NS_WARN_IF
(
!
uiUtils
)
)
{
uiUtils
-
>
GetInTabletMode
(
&
isInTabletMode
)
;
}
}
if
(
isInTabletMode
)
{
settings
.
uiDensity
=
SkeletonUIDensity
:
:
Touch
;
}
else
{
int
uiDensityPref
=
Preferences
:
:
GetInt
(
"
browser
.
uidensity
"
0
)
;
switch
(
uiDensityPref
)
{
case
0
:
{
settings
.
uiDensity
=
SkeletonUIDensity
:
:
Default
;
break
;
}
case
1
:
{
settings
.
uiDensity
=
SkeletonUIDensity
:
:
Compact
;
break
;
}
case
2
:
{
settings
.
uiDensity
=
SkeletonUIDensity
:
:
Touch
;
break
;
}
}
}
Unused
<
<
PersistPreXULSkeletonUIValues
(
settings
)
;
#
endif
return
NS_OK
;
}
nsresult
AppWindow
:
:
SetPersistentValue
(
const
nsAtom
*
aAttr
const
nsAString
&
aValue
)
{
nsAutoString
uri
;
nsAutoString
windowElementId
;
nsresult
rv
=
GetDocXulStoreKeys
(
uri
windowElementId
)
;
if
(
NS_FAILED
(
rv
)
|
|
windowElementId
.
IsEmpty
(
)
)
{
return
rv
;
}
nsAutoString
maybeConvertedValue
(
aValue
)
;
if
(
aAttr
=
=
nsGkAtoms
:
:
width
|
|
aAttr
=
=
nsGkAtoms
:
:
height
)
{
ConvertWindowSize
(
this
aAttr
ConversionDirection
:
:
InnerToOuter
maybeConvertedValue
)
;
}
#
ifdef
MOZ_NEW_XULSTORE
nsDependentAtomString
attrString
(
aAttr
)
;
return
XULStore
:
:
SetValue
(
uri
windowElementId
attrString
maybeConvertedValue
)
;
#
else
if
(
!
mLocalStore
)
{
mLocalStore
=
do_GetService
(
"
mozilla
.
org
/
xul
/
xulstore
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mLocalStore
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
}
return
mLocalStore
-
>
SetValue
(
uri
windowElementId
nsDependentAtomString
(
aAttr
)
maybeConvertedValue
)
;
#
endif
}
NS_IMETHODIMP
AppWindow
:
:
SavePersistentAttributes
(
)
{
if
(
!
mDocShell
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
if
(
!
docShellElement
)
return
NS_ERROR_FAILURE
;
nsAutoString
persistString
;
docShellElement
-
>
GetAttribute
(
PERSIST_ATTRIBUTE
persistString
)
;
if
(
persistString
.
IsEmpty
(
)
)
{
mPersistentAttributesDirty
=
0
;
return
NS_OK
;
}
bool
isFullscreen
=
false
;
if
(
nsPIDOMWindowOuter
*
domWindow
=
mDocShell
-
>
GetWindow
(
)
)
{
isFullscreen
=
domWindow
-
>
GetFullScreen
(
)
;
}
LayoutDeviceIntRect
rect
;
bool
gotRestoredBounds
=
NS_SUCCEEDED
(
mWindow
-
>
GetRestoredBounds
(
rect
)
)
;
CSSToLayoutDeviceScale
sizeScale
=
UnscaledDevicePixelsPerCSSPixel
(
)
;
DesktopToLayoutDeviceScale
posScale
=
DevicePixelsPerDesktopPixel
(
)
;
nsCOMPtr
<
nsIBaseWindow
>
parent
(
do_QueryReferent
(
mParentWindow
)
)
;
if
(
parent
&
&
gotRestoredBounds
)
{
int32_t
parentX
parentY
;
if
(
NS_SUCCEEDED
(
parent
-
>
GetPosition
(
&
parentX
&
parentY
)
)
)
{
rect
.
MoveBy
(
-
parentX
-
parentY
)
;
}
}
nsAutoString
sizeString
;
bool
shouldPersist
=
!
isFullscreen
;
ErrorResult
rv
;
if
(
(
mPersistentAttributesDirty
&
PAD_POSITION
)
&
&
gotRestoredBounds
)
{
if
(
persistString
.
Find
(
"
screenX
"
)
>
=
0
)
{
sizeString
.
Truncate
(
)
;
sizeString
.
AppendInt
(
NSToIntRound
(
rect
.
X
(
)
/
posScale
.
scale
)
)
;
docShellElement
-
>
SetAttribute
(
SCREENX_ATTRIBUTE
sizeString
rv
)
;
if
(
shouldPersist
)
{
Unused
<
<
SetPersistentValue
(
nsGkAtoms
:
:
screenX
sizeString
)
;
}
}
if
(
persistString
.
Find
(
"
screenY
"
)
>
=
0
)
{
sizeString
.
Truncate
(
)
;
sizeString
.
AppendInt
(
NSToIntRound
(
rect
.
Y
(
)
/
posScale
.
scale
)
)
;
docShellElement
-
>
SetAttribute
(
SCREENY_ATTRIBUTE
sizeString
rv
)
;
if
(
shouldPersist
)
{
Unused
<
<
SetPersistentValue
(
nsGkAtoms
:
:
screenY
sizeString
)
;
}
}
}
if
(
(
mPersistentAttributesDirty
&
PAD_SIZE
)
&
&
gotRestoredBounds
)
{
LayoutDeviceIntRect
innerRect
=
rect
-
GetOuterToInnerSizeDifference
(
mWindow
)
;
if
(
persistString
.
Find
(
"
width
"
)
>
=
0
)
{
sizeString
.
Truncate
(
)
;
sizeString
.
AppendInt
(
NSToIntRound
(
innerRect
.
Width
(
)
/
sizeScale
.
scale
)
)
;
docShellElement
-
>
SetAttribute
(
WIDTH_ATTRIBUTE
sizeString
rv
)
;
if
(
shouldPersist
)
{
Unused
<
<
SetPersistentValue
(
nsGkAtoms
:
:
width
sizeString
)
;
}
}
if
(
persistString
.
Find
(
"
height
"
)
>
=
0
)
{
sizeString
.
Truncate
(
)
;
sizeString
.
AppendInt
(
NSToIntRound
(
innerRect
.
Height
(
)
/
sizeScale
.
scale
)
)
;
docShellElement
-
>
SetAttribute
(
HEIGHT_ATTRIBUTE
sizeString
rv
)
;
if
(
shouldPersist
)
{
Unused
<
<
SetPersistentValue
(
nsGkAtoms
:
:
height
sizeString
)
;
}
}
}
Unused
<
<
MaybeSaveEarlyWindowPersistentValues
(
rect
)
;
if
(
mPersistentAttributesDirty
&
PAD_MISC
)
{
nsSizeMode
sizeMode
=
mWindow
-
>
SizeMode
(
)
;
if
(
sizeMode
!
=
nsSizeMode_Minimized
)
{
if
(
sizeMode
=
=
nsSizeMode_Maximized
)
sizeString
.
Assign
(
SIZEMODE_MAXIMIZED
)
;
else
if
(
sizeMode
=
=
nsSizeMode_Fullscreen
)
sizeString
.
Assign
(
SIZEMODE_FULLSCREEN
)
;
else
sizeString
.
Assign
(
SIZEMODE_NORMAL
)
;
docShellElement
-
>
SetAttribute
(
MODE_ATTRIBUTE
sizeString
rv
)
;
if
(
shouldPersist
&
&
persistString
.
Find
(
"
sizemode
"
)
>
=
0
)
{
Unused
<
<
SetPersistentValue
(
nsGkAtoms
:
:
sizemode
sizeString
)
;
}
}
bool
tiled
=
mWindow
-
>
IsTiled
(
)
;
if
(
tiled
)
{
sizeString
.
Assign
(
u
"
true
"
_ns
)
;
}
else
{
sizeString
.
Assign
(
u
"
false
"
_ns
)
;
}
docShellElement
-
>
SetAttribute
(
TILED_ATTRIBUTE
sizeString
rv
)
;
if
(
persistString
.
Find
(
"
zlevel
"
)
>
=
0
)
{
uint32_t
zLevel
;
nsCOMPtr
<
nsIWindowMediator
>
mediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
mediator
)
{
mediator
-
>
GetZLevel
(
this
&
zLevel
)
;
sizeString
.
Truncate
(
)
;
sizeString
.
AppendInt
(
zLevel
)
;
docShellElement
-
>
SetAttribute
(
ZLEVEL_ATTRIBUTE
sizeString
rv
)
;
if
(
shouldPersist
)
{
Unused
<
<
SetPersistentValue
(
nsGkAtoms
:
:
zlevel
sizeString
)
;
}
}
}
}
mPersistentAttributesDirty
=
0
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetWindowDOMWindow
(
mozIDOMWindowProxy
*
*
aDOMWindow
)
{
NS_ENSURE_STATE
(
mDocShell
)
;
if
(
!
mDOMWindow
)
mDOMWindow
=
mDocShell
-
>
GetWindow
(
)
;
NS_ENSURE_TRUE
(
mDOMWindow
NS_ERROR_FAILURE
)
;
*
aDOMWindow
=
mDOMWindow
;
NS_ADDREF
(
*
aDOMWindow
)
;
return
NS_OK
;
}
dom
:
:
Element
*
AppWindow
:
:
GetWindowDOMElement
(
)
const
{
NS_ENSURE_TRUE
(
mDocShell
nullptr
)
;
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
NS_ENSURE_TRUE
(
cv
nullptr
)
;
const
dom
:
:
Document
*
document
=
cv
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
document
nullptr
)
;
return
document
-
>
GetRootElement
(
)
;
}
nsresult
AppWindow
:
:
ContentShellAdded
(
nsIDocShellTreeItem
*
aContentShell
bool
aPrimary
)
{
if
(
aPrimary
)
{
NS_ENSURE_SUCCESS
(
EnsurePrimaryContentTreeOwner
(
)
NS_ERROR_FAILURE
)
;
aContentShell
-
>
SetTreeOwner
(
mPrimaryContentTreeOwner
)
;
mPrimaryContentShell
=
aContentShell
;
mPrimaryBrowserParent
=
nullptr
;
}
else
{
NS_ENSURE_SUCCESS
(
EnsureContentTreeOwner
(
)
NS_ERROR_FAILURE
)
;
aContentShell
-
>
SetTreeOwner
(
mContentTreeOwner
)
;
if
(
mPrimaryContentShell
=
=
aContentShell
)
mPrimaryContentShell
=
nullptr
;
}
return
NS_OK
;
}
nsresult
AppWindow
:
:
ContentShellRemoved
(
nsIDocShellTreeItem
*
aContentShell
)
{
if
(
mPrimaryContentShell
=
=
aContentShell
)
{
mPrimaryContentShell
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetPrimaryContentSize
(
int32_t
*
aWidth
int32_t
*
aHeight
)
{
if
(
mPrimaryBrowserParent
)
{
return
GetPrimaryRemoteTabSize
(
aWidth
aHeight
)
;
}
if
(
mPrimaryContentShell
)
{
return
GetPrimaryContentShellSize
(
aWidth
aHeight
)
;
}
return
NS_ERROR_UNEXPECTED
;
}
nsresult
AppWindow
:
:
GetPrimaryRemoteTabSize
(
int32_t
*
aWidth
int32_t
*
aHeight
)
{
BrowserHost
*
host
=
BrowserHost
:
:
GetFrom
(
mPrimaryBrowserParent
.
get
(
)
)
;
RefPtr
<
dom
:
:
Element
>
element
=
host
-
>
GetOwnerElement
(
)
;
NS_ENSURE_STATE
(
element
)
;
*
aWidth
=
element
-
>
ClientWidth
(
)
;
*
aHeight
=
element
-
>
ClientHeight
(
)
;
return
NS_OK
;
}
nsresult
AppWindow
:
:
GetPrimaryContentShellSize
(
int32_t
*
aWidth
int32_t
*
aHeight
)
{
NS_ENSURE_STATE
(
mPrimaryContentShell
)
;
nsCOMPtr
<
nsIBaseWindow
>
shellWindow
(
do_QueryInterface
(
mPrimaryContentShell
)
)
;
NS_ENSURE_STATE
(
shellWindow
)
;
CSSIntSize
size
=
RoundedToInt
(
shellWindow
-
>
GetSize
(
)
/
shellWindow
-
>
UnscaledDevicePixelsPerCSSPixel
(
)
)
;
*
aWidth
=
size
.
width
;
*
aHeight
=
size
.
width
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetPrimaryContentSize
(
int32_t
aWidth
int32_t
aHeight
)
{
if
(
mPrimaryBrowserParent
)
{
return
SetPrimaryRemoteTabSize
(
aWidth
aHeight
)
;
}
else
if
(
mPrimaryContentShell
)
{
return
SizeShellTo
(
mPrimaryContentShell
aWidth
aHeight
)
;
}
return
NS_ERROR_UNEXPECTED
;
}
nsresult
AppWindow
:
:
SetPrimaryRemoteTabSize
(
int32_t
aWidth
int32_t
aHeight
)
{
int32_t
shellWidth
shellHeight
;
GetPrimaryRemoteTabSize
(
&
shellWidth
&
shellHeight
)
;
double
scale
=
UnscaledDevicePixelsPerCSSPixel
(
)
.
scale
;
SizeShellToWithLimit
(
aWidth
aHeight
shellWidth
*
scale
shellHeight
*
scale
)
;
return
NS_OK
;
}
nsresult
AppWindow
:
:
GetRootShellSize
(
int32_t
*
aWidth
int32_t
*
aHeight
)
{
NS_ENSURE_TRUE
(
mDocShell
NS_ERROR_FAILURE
)
;
return
mDocShell
-
>
GetSize
(
aWidth
aHeight
)
;
}
nsresult
AppWindow
:
:
SetRootShellSize
(
int32_t
aWidth
int32_t
aHeight
)
{
return
SizeShellTo
(
mDocShell
aWidth
aHeight
)
;
}
NS_IMETHODIMP
AppWindow
:
:
SizeShellTo
(
nsIDocShellTreeItem
*
aShellItem
int32_t
aCX
int32_t
aCY
)
{
nsCOMPtr
<
nsIBaseWindow
>
shellAsWin
(
do_QueryInterface
(
aShellItem
)
)
;
NS_ENSURE_TRUE
(
shellAsWin
NS_ERROR_FAILURE
)
;
int32_t
width
=
0
;
int32_t
height
=
0
;
shellAsWin
-
>
GetSize
(
&
width
&
height
)
;
SizeShellToWithLimit
(
aCX
aCY
width
height
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
ExitModalLoop
(
nsresult
aStatus
)
{
if
(
mContinueModalLoop
)
EnableParent
(
true
)
;
mContinueModalLoop
=
false
;
mModalStatus
=
aStatus
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
CreateNewWindow
(
int32_t
aChromeFlags
nsIOpenWindowInfo
*
aOpenWindowInfo
nsIAppWindow
*
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
if
(
aChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
)
{
MOZ_RELEASE_ASSERT
(
!
aOpenWindowInfo
"
Unexpected
nsOpenWindowInfo
when
creating
a
new
chrome
window
"
)
;
return
CreateNewChromeWindow
(
aChromeFlags
_retval
)
;
}
return
CreateNewContentWindow
(
aChromeFlags
aOpenWindowInfo
_retval
)
;
}
NS_IMETHODIMP
AppWindow
:
:
CreateNewChromeWindow
(
int32_t
aChromeFlags
nsIAppWindow
*
*
_retval
)
{
nsCOMPtr
<
nsIAppShellService
>
appShell
(
do_GetService
(
NS_APPSHELLSERVICE_CONTRACTID
)
)
;
NS_ENSURE_TRUE
(
appShell
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIAppWindow
>
newWindow
;
appShell
-
>
CreateTopLevelWindow
(
this
nullptr
aChromeFlags
nsIAppShellService
:
:
SIZE_TO_CONTENT
nsIAppShellService
:
:
SIZE_TO_CONTENT
getter_AddRefs
(
newWindow
)
)
;
NS_ENSURE_TRUE
(
newWindow
NS_ERROR_FAILURE
)
;
newWindow
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
CreateNewContentWindow
(
int32_t
aChromeFlags
nsIOpenWindowInfo
*
aOpenWindowInfo
nsIAppWindow
*
*
_retval
)
{
nsCOMPtr
<
nsIAppShellService
>
appShell
(
do_GetService
(
NS_APPSHELLSERVICE_CONTRACTID
)
)
;
NS_ENSURE_TRUE
(
appShell
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsAutoCString
urlStr
;
urlStr
.
AssignLiteral
(
BROWSER_CHROME_URL_QUOTED
)
;
nsCOMPtr
<
nsIIOService
>
service
(
do_GetService
(
NS_IOSERVICE_CONTRACTID
)
)
;
if
(
service
)
{
service
-
>
NewURI
(
urlStr
nullptr
nullptr
getter_AddRefs
(
uri
)
)
;
}
NS_ENSURE_TRUE
(
uri
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIAppWindow
>
newWindow
;
{
AutoNoJSAPI
nojsapi
;
appShell
-
>
CreateTopLevelWindow
(
this
uri
aChromeFlags
615
480
getter_AddRefs
(
newWindow
)
)
;
NS_ENSURE_TRUE
(
newWindow
NS_ERROR_FAILURE
)
;
}
AppWindow
*
appWin
=
static_cast
<
AppWindow
*
>
(
static_cast
<
nsIAppWindow
*
>
(
newWindow
)
)
;
appWin
-
>
mInitialOpenWindowInfo
=
aOpenWindowInfo
;
appWin
-
>
LockUntilChromeLoad
(
)
;
{
AutoNoJSAPI
nojsapi
;
SpinEventLoopUntil
(
"
AppWindow
:
:
CreateNewContentWindow
"
_ns
[
&
]
(
)
{
return
!
appWin
-
>
IsLocked
(
)
;
}
)
;
}
NS_ENSURE_STATE
(
appWin
-
>
mPrimaryContentShell
|
|
appWin
-
>
mPrimaryBrowserParent
)
;
MOZ_ASSERT_IF
(
appWin
-
>
mPrimaryContentShell
!
aOpenWindowInfo
-
>
GetNextRemoteBrowser
(
)
)
;
newWindow
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetHasPrimaryContent
(
bool
*
aResult
)
{
*
aResult
=
mPrimaryBrowserParent
|
|
mPrimaryContentShell
;
return
NS_OK
;
}
void
AppWindow
:
:
EnableParent
(
bool
aEnable
)
{
nsCOMPtr
<
nsIBaseWindow
>
parentWindow
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
parentWindow
=
do_QueryReferent
(
mParentWindow
)
;
if
(
parentWindow
)
parentWindow
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
if
(
parentWidget
)
parentWidget
-
>
Enable
(
aEnable
)
;
}
bool
AppWindow
:
:
ConstrainToZLevel
(
bool
aImmediate
nsWindowZ
*
aPlacement
nsIWidget
*
aReqBelow
nsIWidget
*
*
aActualBelow
)
{
#
if
0
nsCOMPtr
<
nsIBaseWindow
>
parentWindow
=
do_QueryReferent
(
mParentWindow
)
;
if
(
parentWindow
)
return
false
;
#
endif
nsCOMPtr
<
nsIWindowMediator
>
mediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
!
mediator
)
return
false
;
bool
altered
;
uint32_t
position
newPosition
zLevel
;
nsIAppWindow
*
us
=
this
;
altered
=
false
;
mediator
-
>
GetZLevel
(
this
&
zLevel
)
;
position
=
nsIWindowMediator
:
:
zLevelTop
;
if
(
*
aPlacement
=
=
nsWindowZBottom
|
|
zLevel
=
=
nsIAppWindow
:
:
lowestZ
)
position
=
nsIWindowMediator
:
:
zLevelBottom
;
else
if
(
*
aPlacement
=
=
nsWindowZRelative
)
position
=
nsIWindowMediator
:
:
zLevelBelow
;
if
(
NS_SUCCEEDED
(
mediator
-
>
CalculateZPosition
(
us
position
aReqBelow
&
newPosition
aActualBelow
&
altered
)
)
)
{
if
(
altered
&
&
(
position
=
=
nsIWindowMediator
:
:
zLevelTop
|
|
(
position
=
=
nsIWindowMediator
:
:
zLevelBelow
&
&
aReqBelow
=
=
0
)
)
)
PlaceWindowLayersBehind
(
zLevel
+
1
nsIAppWindow
:
:
highestZ
0
)
;
if
(
*
aPlacement
!
=
nsWindowZBottom
&
&
position
=
=
nsIWindowMediator
:
:
zLevelBottom
)
altered
=
true
;
if
(
altered
|
|
aImmediate
)
{
if
(
newPosition
=
=
nsIWindowMediator
:
:
zLevelTop
)
*
aPlacement
=
nsWindowZTop
;
else
if
(
newPosition
=
=
nsIWindowMediator
:
:
zLevelBottom
)
*
aPlacement
=
nsWindowZBottom
;
else
*
aPlacement
=
nsWindowZRelative
;
if
(
aImmediate
)
{
nsCOMPtr
<
nsIBaseWindow
>
ourBase
=
do_QueryObject
(
this
)
;
if
(
ourBase
)
{
nsCOMPtr
<
nsIWidget
>
ourWidget
;
ourBase
-
>
GetMainWidget
(
getter_AddRefs
(
ourWidget
)
)
;
ourWidget
-
>
PlaceBehind
(
*
aPlacement
=
=
nsWindowZBottom
?
eZPlacementBottom
:
eZPlacementBelow
*
aActualBelow
false
)
;
}
}
}
nsCOMPtr
<
nsIAppWindow
>
windowAbove
;
if
(
newPosition
=
=
nsIWindowMediator
:
:
zLevelBelow
&
&
*
aActualBelow
)
{
windowAbove
=
(
*
aActualBelow
)
-
>
GetWidgetListener
(
)
-
>
GetAppWindow
(
)
;
}
mediator
-
>
SetZPosition
(
us
newPosition
windowAbove
)
;
}
return
altered
;
}
void
AppWindow
:
:
PlaceWindowLayersBehind
(
uint32_t
aLowLevel
uint32_t
aHighLevel
nsIAppWindow
*
aBehind
)
{
nsCOMPtr
<
nsIWindowMediator
>
mediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
!
mediator
)
return
;
nsCOMPtr
<
nsISimpleEnumerator
>
windowEnumerator
;
mediator
-
>
GetZOrderAppWindowEnumerator
(
0
true
getter_AddRefs
(
windowEnumerator
)
)
;
if
(
!
windowEnumerator
)
return
;
nsCOMPtr
<
nsIWidget
>
previousHighWidget
;
if
(
aBehind
)
{
nsCOMPtr
<
nsIBaseWindow
>
highBase
(
do_QueryInterface
(
aBehind
)
)
;
if
(
highBase
)
highBase
-
>
GetMainWidget
(
getter_AddRefs
(
previousHighWidget
)
)
;
}
bool
more
;
while
(
NS_SUCCEEDED
(
windowEnumerator
-
>
HasMoreElements
(
&
more
)
)
&
&
more
)
{
uint32_t
nextZ
;
nsCOMPtr
<
nsISupports
>
nextWindow
;
windowEnumerator
-
>
GetNext
(
getter_AddRefs
(
nextWindow
)
)
;
nsCOMPtr
<
nsIAppWindow
>
nextAppWindow
(
do_QueryInterface
(
nextWindow
)
)
;
nextAppWindow
-
>
GetZLevel
(
&
nextZ
)
;
if
(
nextZ
<
aLowLevel
)
break
;
nsCOMPtr
<
nsIBaseWindow
>
nextBase
(
do_QueryInterface
(
nextAppWindow
)
)
;
if
(
nextBase
)
{
nsCOMPtr
<
nsIWidget
>
nextWidget
;
nextBase
-
>
GetMainWidget
(
getter_AddRefs
(
nextWidget
)
)
;
if
(
nextZ
<
=
aHighLevel
)
nextWidget
-
>
PlaceBehind
(
eZPlacementBelow
previousHighWidget
false
)
;
previousHighWidget
=
nextWidget
;
}
}
}
void
AppWindow
:
:
SetContentScrollbarVisibility
(
bool
aVisible
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
contentWin
(
do_GetInterface
(
mPrimaryContentShell
)
)
;
if
(
!
contentWin
)
{
return
;
}
nsContentUtils
:
:
SetScrollbarsVisibility
(
contentWin
-
>
GetDocShell
(
)
aVisible
)
;
}
void
AppWindow
:
:
PersistentAttributesDirty
(
uint32_t
aDirtyFlags
)
{
mPersistentAttributesDirty
|
=
aDirtyFlags
&
mPersistentAttributesMask
;
}
void
AppWindow
:
:
ApplyChromeFlags
(
)
{
nsCOMPtr
<
dom
:
:
Element
>
window
=
GetWindowDOMElement
(
)
;
if
(
!
window
)
{
return
;
}
if
(
mChromeLoaded
)
{
SetContentScrollbarVisibility
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_SCROLLBARS
)
;
}
nsAutoString
newvalue
;
if
(
!
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_MENUBAR
)
)
newvalue
.
AppendLiteral
(
"
menubar
"
)
;
if
(
!
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_TOOLBAR
)
)
newvalue
.
AppendLiteral
(
"
toolbar
"
)
;
if
(
!
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_LOCATIONBAR
)
)
newvalue
.
AppendLiteral
(
"
location
"
)
;
if
(
!
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_PERSONAL_TOOLBAR
)
)
newvalue
.
AppendLiteral
(
"
directories
"
)
;
if
(
!
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_STATUSBAR
)
)
newvalue
.
AppendLiteral
(
"
status
"
)
;
if
(
!
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_EXTRA
)
)
newvalue
.
AppendLiteral
(
"
extrachrome
"
)
;
IgnoredErrorResult
rv
;
window
-
>
SetAttribute
(
u
"
chromehidden
"
_ns
newvalue
rv
)
;
}
NS_IMETHODIMP
AppWindow
:
:
BeforeStartLayout
(
)
{
ApplyChromeFlags
(
)
;
LoadPersistentWindowState
(
)
;
SyncAttributesToWidget
(
)
;
if
(
mWindow
)
{
SizeShell
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
LockAspectRatio
(
bool
aShouldLock
)
{
mWindow
-
>
LockAspectRatio
(
aShouldLock
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
NeedFastSnaphot
(
)
{
MOZ_ASSERT
(
mWindow
)
;
if
(
!
mWindow
)
{
return
NS_ERROR_FAILURE
;
}
mWindow
-
>
SetNeedFastSnaphot
(
)
;
return
NS_OK
;
}
void
AppWindow
:
:
LoadPersistentWindowState
(
)
{
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
if
(
!
docShellElement
)
{
return
;
}
nsAutoString
persist
;
docShellElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
persist
persist
)
;
if
(
persist
.
IsEmpty
(
)
)
{
return
;
}
auto
loadValue
=
[
&
]
(
const
nsAtom
*
aAttr
)
{
nsDependentAtomString
attrString
(
aAttr
)
;
if
(
persist
.
Find
(
attrString
)
>
=
0
)
{
nsAutoString
value
;
nsresult
rv
=
GetPersistentValue
(
aAttr
value
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
get
persistent
state
.
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
value
.
IsEmpty
(
)
)
{
IgnoredErrorResult
err
;
docShellElement
-
>
SetAttribute
(
attrString
value
err
)
;
}
}
}
;
loadValue
(
nsGkAtoms
:
:
screenX
)
;
loadValue
(
nsGkAtoms
:
:
screenY
)
;
loadValue
(
nsGkAtoms
:
:
width
)
;
loadValue
(
nsGkAtoms
:
:
height
)
;
loadValue
(
nsGkAtoms
:
:
sizemode
)
;
}
void
AppWindow
:
:
SizeShell
(
)
{
AutoRestore
<
bool
>
sizingShellFromXUL
(
mSizingShellFromXUL
)
;
mSizingShellFromXUL
=
true
;
int32_t
specWidth
=
-
1
specHeight
=
-
1
;
bool
gotSize
=
false
;
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
nsAutoString
windowType
;
if
(
windowElement
)
{
windowElement
-
>
GetAttribute
(
WINDOWTYPE_ATTRIBUTE
windowType
)
;
}
CSSIntSize
windowDiff
=
GetOuterToInnerSizeDifferenceInCSSPixels
(
mWindow
UnscaledDevicePixelsPerCSSPixel
(
)
)
;
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
"
if
RFP
is
enabled
we
want
to
round
the
dimensions
of
the
new
"
"
new
pop
up
window
regardless
of
their
origin
"
)
&
&
windowType
.
EqualsLiteral
(
"
navigator
:
browser
"
)
)
{
if
(
mPrimaryContentShell
|
|
mPrimaryBrowserParent
)
{
ForceRoundedDimensions
(
)
;
}
mIgnoreXULSize
=
true
;
mIgnoreXULSizeMode
=
true
;
}
else
if
(
!
mIgnoreXULSize
)
{
gotSize
=
LoadSizeFromXUL
(
specWidth
specHeight
)
;
specWidth
+
=
windowDiff
.
width
;
specHeight
+
=
windowDiff
.
height
;
}
bool
positionSet
=
!
mIgnoreXULPosition
;
nsCOMPtr
<
nsIAppWindow
>
parentWindow
(
do_QueryReferent
(
mParentWindow
)
)
;
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
XP_MACOSX
)
if
(
!
parentWindow
)
positionSet
=
false
;
#
endif
if
(
positionSet
)
{
positionSet
=
LoadPositionFromXUL
(
specWidth
specHeight
)
;
}
if
(
gotSize
)
{
SetSpecifiedSize
(
specWidth
specHeight
)
;
}
if
(
mIntrinsicallySized
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
cv
)
{
RefPtr
<
nsDocShell
>
docShell
=
mDocShell
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
docShell
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
if
(
treeOwner
)
{
int32_t
width
=
0
height
=
0
;
if
(
NS_SUCCEEDED
(
cv
-
>
GetContentSize
(
&
width
&
height
)
)
)
{
treeOwner
-
>
SizeShellTo
(
docShell
width
height
)
;
specWidth
=
width
+
windowDiff
.
width
;
specHeight
=
height
+
windowDiff
.
height
;
}
}
}
}
if
(
positionSet
)
{
LoadPositionFromXUL
(
specWidth
specHeight
)
;
}
UpdateWindowStateFromMiscXULAttributes
(
)
;
if
(
mChromeLoaded
&
&
mCenterAfterLoad
&
&
!
positionSet
&
&
mWindow
-
>
SizeMode
(
)
=
=
nsSizeMode_Normal
)
{
Center
(
parentWindow
parentWindow
?
false
:
true
false
)
;
}
}
NS_IMETHODIMP
AppWindow
:
:
GetXULBrowserWindow
(
nsIXULBrowserWindow
*
*
aXULBrowserWindow
)
{
NS_IF_ADDREF
(
*
aXULBrowserWindow
=
mXULBrowserWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetXULBrowserWindow
(
nsIXULBrowserWindow
*
aXULBrowserWindow
)
{
mXULBrowserWindow
=
aXULBrowserWindow
;
return
NS_OK
;
}
void
AppWindow
:
:
SizeShellToWithLimit
(
int32_t
aDesiredWidth
int32_t
aDesiredHeight
int32_t
shellItemWidth
int32_t
shellItemHeight
)
{
int32_t
widthDelta
=
aDesiredWidth
-
shellItemWidth
;
int32_t
heightDelta
=
aDesiredHeight
-
shellItemHeight
;
if
(
widthDelta
|
|
heightDelta
)
{
int32_t
winWidth
=
0
;
int32_t
winHeight
=
0
;
GetSize
(
&
winWidth
&
winHeight
)
;
winWidth
=
std
:
:
max
(
winWidth
+
widthDelta
aDesiredWidth
)
;
winHeight
=
std
:
:
max
(
winHeight
+
heightDelta
aDesiredHeight
)
;
SetSize
(
winWidth
winHeight
true
)
;
}
}
nsresult
AppWindow
:
:
GetTabCount
(
uint32_t
*
aResult
)
{
if
(
mXULBrowserWindow
)
{
return
mXULBrowserWindow
-
>
GetTabCount
(
aResult
)
;
}
*
aResult
=
0
;
return
NS_OK
;
}
nsresult
AppWindow
:
:
GetInitialOpenWindowInfo
(
nsIOpenWindowInfo
*
*
aOpenWindowInfo
)
{
NS_ENSURE_ARG_POINTER
(
aOpenWindowInfo
)
;
*
aOpenWindowInfo
=
do_AddRef
(
mInitialOpenWindowInfo
)
.
take
(
)
;
return
NS_OK
;
}
PresShell
*
AppWindow
:
:
GetPresShell
(
)
{
if
(
!
mDocShell
)
{
return
nullptr
;
}
return
mDocShell
-
>
GetPresShell
(
)
;
}
bool
AppWindow
:
:
WindowMoved
(
nsIWidget
*
aWidget
int32_t
x
int32_t
y
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
pm
-
>
AdjustPopupsOnWindowChange
(
window
)
;
}
if
(
mDocShell
&
&
mDocShell
-
>
GetWindow
(
)
)
{
nsCOMPtr
<
EventTarget
>
eventTarget
=
mDocShell
-
>
GetWindow
(
)
-
>
GetTopWindowRoot
(
)
;
nsContentUtils
:
:
DispatchChromeEvent
(
mDocShell
-
>
GetDocument
(
)
eventTarget
u
"
MozUpdateWindowPos
"
_ns
CanBubble
:
:
eNo
Cancelable
:
:
eNo
nullptr
)
;
}
SetPersistenceTimer
(
PAD_POSITION
)
;
return
false
;
}
bool
AppWindow
:
:
WindowResized
(
nsIWidget
*
aWidget
int32_t
aWidth
int32_t
aHeight
)
{
if
(
mDocShell
)
{
mDocShell
-
>
SetPositionAndSize
(
0
0
aWidth
aHeight
0
)
;
}
if
(
!
IsLocked
(
)
)
SetPersistenceTimer
(
PAD_POSITION
|
PAD_SIZE
|
PAD_MISC
)
;
switch
(
mFullscreenChangeState
)
{
case
FullscreenChangeState
:
:
WillChange
:
mFullscreenChangeState
=
FullscreenChangeState
:
:
WidgetResized
;
break
;
case
FullscreenChangeState
:
:
WidgetEnteredFullscreen
:
FinishFullscreenChange
(
true
)
;
break
;
case
FullscreenChangeState
:
:
WidgetExitedFullscreen
:
FinishFullscreenChange
(
false
)
;
break
;
case
FullscreenChangeState
:
:
WidgetResized
:
case
FullscreenChangeState
:
:
NotChanging
:
break
;
}
return
true
;
}
bool
AppWindow
:
:
RequestWindowClose
(
nsIWidget
*
aWidget
)
{
nsCOMPtr
<
nsIAppWindow
>
appWindow
(
this
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
(
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
)
;
nsCOMPtr
<
EventTarget
>
eventTarget
=
do_QueryInterface
(
window
)
;
RefPtr
<
PresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
mozilla
:
:
DebugOnly
<
bool
>
dying
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
mDocShell
-
>
IsBeingDestroyed
(
&
dying
)
)
&
&
dying
"
No
presShell
but
window
is
not
being
destroyed
"
)
;
}
else
if
(
eventTarget
)
{
RefPtr
<
nsPresContext
>
presContext
=
presShell
-
>
GetPresContext
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eClose
nullptr
WidgetMouseEvent
:
:
eReal
)
;
if
(
NS_SUCCEEDED
(
EventDispatcher
:
:
Dispatch
(
eventTarget
presContext
&
event
nullptr
&
status
)
)
&
&
status
=
=
nsEventStatus_eConsumeNoDefault
)
return
false
;
}
Destroy
(
)
;
return
false
;
}
void
AppWindow
:
:
SizeModeChanged
(
nsSizeMode
sizeMode
)
{
if
(
sizeMode
=
=
nsSizeMode_Maximized
|
|
sizeMode
=
=
nsSizeMode_Fullscreen
)
{
uint32_t
zLevel
;
GetZLevel
(
&
zLevel
)
;
if
(
zLevel
>
nsIAppWindow
:
:
normalZ
)
SetZLevel
(
nsIAppWindow
:
:
normalZ
)
;
}
mWindow
-
>
SetSizeMode
(
sizeMode
)
;
SetPersistenceTimer
(
PAD_MISC
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
if
(
ourWindow
)
{
if
(
sizeMode
=
=
nsSizeMode_Fullscreen
)
{
ourWindow
-
>
SetFullScreen
(
true
)
;
}
else
if
(
sizeMode
!
=
nsSizeMode_Minimized
)
{
if
(
ourWindow
-
>
GetFullScreen
(
)
)
{
ourWindow
-
>
SetFullscreenInternal
(
FullscreenReason
:
:
ForForceExitFullscreen
false
)
;
ourWindow
-
>
SetFullScreen
(
false
)
;
}
}
ourWindow
-
>
DispatchCustomEvent
(
u
"
sizemodechange
"
_ns
)
;
}
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
GetPresContext
(
)
-
>
SizeModeChanged
(
sizeMode
)
;
}
}
void
AppWindow
:
:
UIResolutionChanged
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
if
(
ourWindow
)
{
ourWindow
-
>
DispatchCustomEvent
(
u
"
resolutionchange
"
_ns
ChromeOnlyDispatch
:
:
eYes
)
;
}
}
void
AppWindow
:
:
FullscreenWillChange
(
bool
aInFullscreen
)
{
if
(
mDocShell
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
mDocShell
-
>
GetWindow
(
)
)
{
ourWindow
-
>
FullscreenWillChange
(
aInFullscreen
)
;
}
}
MOZ_ASSERT
(
mFullscreenChangeState
=
=
FullscreenChangeState
:
:
NotChanging
)
;
mFullscreenChangeState
=
FullscreenChangeState
:
:
WillChange
;
}
void
AppWindow
:
:
FullscreenChanged
(
bool
aInFullscreen
)
{
if
(
mFullscreenChangeState
=
=
FullscreenChangeState
:
:
WidgetResized
)
{
FinishFullscreenChange
(
aInFullscreen
)
;
}
else
{
NS_WARNING_ASSERTION
(
mFullscreenChangeState
=
=
FullscreenChangeState
:
:
WillChange
"
Unexpected
fullscreen
change
state
"
)
;
FullscreenChangeState
newState
=
aInFullscreen
?
FullscreenChangeState
:
:
WidgetEnteredFullscreen
:
FullscreenChangeState
:
:
WidgetExitedFullscreen
;
mFullscreenChangeState
=
newState
;
nsCOMPtr
<
nsIAppWindow
>
kungFuDeathGrip
(
this
)
;
NS_DelayedDispatchToCurrentThread
(
NS_NewRunnableFunction
(
"
AppWindow
:
:
FullscreenChanged
"
[
this
kungFuDeathGrip
newState
aInFullscreen
]
(
)
{
if
(
mFullscreenChangeState
=
=
newState
)
{
FinishFullscreenChange
(
aInFullscreen
)
;
}
}
)
80
)
;
}
}
void
AppWindow
:
:
FinishFullscreenChange
(
bool
aInFullscreen
)
{
mFullscreenChangeState
=
FullscreenChangeState
:
:
NotChanging
;
if
(
mDocShell
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
mDocShell
-
>
GetWindow
(
)
)
{
ourWindow
-
>
FinishFullscreenChange
(
aInFullscreen
)
;
}
}
}
void
AppWindow
:
:
MacFullscreenMenubarOverlapChanged
(
mozilla
:
:
DesktopCoord
aOverlapAmount
)
{
if
(
mDocShell
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
mDocShell
-
>
GetWindow
(
)
)
{
ourWindow
-
>
MacFullscreenMenubarOverlapChanged
(
aOverlapAmount
)
;
}
}
}
void
AppWindow
:
:
OcclusionStateChanged
(
bool
aIsFullyOccluded
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
if
(
ourWindow
)
{
ourWindow
-
>
DispatchCustomEvent
(
u
"
occlusionstatechange
"
_ns
ChromeOnlyDispatch
:
:
eYes
)
;
}
}
void
AppWindow
:
:
OSToolbarButtonPressed
(
)
{
nsCOMPtr
<
nsIAppWindow
>
appWindow
(
this
)
;
uint32_t
chromeMask
=
(
nsIWebBrowserChrome
:
:
CHROME_TOOLBAR
|
nsIWebBrowserChrome
:
:
CHROME_LOCATIONBAR
|
nsIWebBrowserChrome
:
:
CHROME_PERSONAL_TOOLBAR
)
;
nsCOMPtr
<
nsIWebBrowserChrome
>
wbc
(
do_GetInterface
(
appWindow
)
)
;
if
(
!
wbc
)
return
;
uint32_t
chromeFlags
newChromeFlags
=
0
;
wbc
-
>
GetChromeFlags
(
&
chromeFlags
)
;
newChromeFlags
=
chromeFlags
&
chromeMask
;
if
(
!
newChromeFlags
)
chromeFlags
|
=
chromeMask
;
else
chromeFlags
&
=
(
~
newChromeFlags
)
;
wbc
-
>
SetChromeFlags
(
chromeFlags
)
;
}
bool
AppWindow
:
:
ZLevelChanged
(
bool
aImmediate
nsWindowZ
*
aPlacement
nsIWidget
*
aRequestBelow
nsIWidget
*
*
aActualBelow
)
{
if
(
aActualBelow
)
*
aActualBelow
=
nullptr
;
return
ConstrainToZLevel
(
aImmediate
aPlacement
aRequestBelow
aActualBelow
)
;
}
void
AppWindow
:
:
WindowActivated
(
)
{
nsCOMPtr
<
nsIAppWindow
>
appWindow
(
this
)
;
if
(
mDocShell
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocShell
-
>
GetWindow
(
)
)
{
if
(
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
fm
-
>
WindowRaised
(
window
nsFocusManager
:
:
GenerateFocusActionId
(
)
)
;
}
}
}
if
(
mChromeLoaded
)
{
PersistentAttributesDirty
(
PAD_POSITION
|
PAD_SIZE
|
PAD_MISC
)
;
SavePersistentAttributes
(
)
;
}
}
void
AppWindow
:
:
WindowDeactivated
(
)
{
nsCOMPtr
<
nsIAppWindow
>
appWindow
(
this
)
;
if
(
mDocShell
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocShell
-
>
GetWindow
(
)
)
{
if
(
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
if
(
!
fm
-
>
IsTestMode
(
)
)
{
fm
-
>
WindowLowered
(
window
nsFocusManager
:
:
GenerateFocusActionId
(
)
)
;
}
}
}
}
}
#
ifdef
USE_NATIVE_MENUS
struct
LoadNativeMenusListener
{
LoadNativeMenusListener
(
Document
*
aDoc
nsIWidget
*
aParentWindow
)
:
mDocument
(
aDoc
)
mParentWindow
(
aParentWindow
)
{
}
RefPtr
<
Document
>
mDocument
;
nsCOMPtr
<
nsIWidget
>
mParentWindow
;
}
;
static
bool
sHiddenWindowLoadedNativeMenus
=
false
;
static
nsTArray
<
LoadNativeMenusListener
>
sLoadNativeMenusListeners
;
static
void
BeginLoadNativeMenus
(
Document
*
aDoc
nsIWidget
*
aParentWindow
)
;
static
void
LoadNativeMenus
(
Document
*
aDoc
nsIWidget
*
aParentWindow
)
{
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
return
;
}
nsCOMPtr
<
nsINodeList
>
menubarElements
=
aDoc
-
>
GetElementsByTagNameNS
(
nsLiteralString
(
u
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
)
u
"
menubar
"
_ns
)
;
nsCOMPtr
<
nsINode
>
menubarNode
;
if
(
menubarElements
)
{
menubarNode
=
menubarElements
-
>
Item
(
0
)
;
}
using
widget
:
:
NativeMenuSupport
;
if
(
menubarNode
)
{
nsCOMPtr
<
Element
>
menubarContent
(
do_QueryInterface
(
menubarNode
)
)
;
NativeMenuSupport
:
:
CreateNativeMenuBar
(
aParentWindow
menubarContent
)
;
}
else
{
NativeMenuSupport
:
:
CreateNativeMenuBar
(
aParentWindow
nullptr
)
;
}
if
(
!
sHiddenWindowLoadedNativeMenus
)
{
sHiddenWindowLoadedNativeMenus
=
true
;
for
(
auto
&
listener
:
sLoadNativeMenusListeners
)
{
BeginLoadNativeMenus
(
listener
.
mDocument
listener
.
mParentWindow
)
;
}
sLoadNativeMenusListeners
.
Clear
(
)
;
}
}
class
L10nReadyPromiseHandler
final
:
public
dom
:
:
PromiseNativeHandler
{
public
:
NS_DECL_ISUPPORTS
L10nReadyPromiseHandler
(
Document
*
aDoc
nsIWidget
*
aParentWindow
)
:
mDocument
(
aDoc
)
mWindow
(
aParentWindow
)
{
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
LoadNativeMenus
(
mDocument
mWindow
)
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
NS_WARNING
(
"
L10nReadyPromiseHandler
rejected
-
loading
fallback
native
"
"
menu
.
"
)
;
LoadNativeMenus
(
mDocument
mWindow
)
;
}
private
:
~
L10nReadyPromiseHandler
(
)
=
default
;
RefPtr
<
Document
>
mDocument
;
nsCOMPtr
<
nsIWidget
>
mWindow
;
}
;
NS_IMPL_ISUPPORTS0
(
L10nReadyPromiseHandler
)
static
void
BeginLoadNativeMenus
(
Document
*
aDoc
nsIWidget
*
aParentWindow
)
{
RefPtr
<
DocumentL10n
>
l10n
=
aDoc
-
>
GetL10n
(
)
;
if
(
l10n
)
{
RefPtr
<
Promise
>
promise
=
l10n
-
>
Ready
(
)
;
MOZ_ASSERT
(
promise
)
;
RefPtr
<
L10nReadyPromiseHandler
>
handler
=
new
L10nReadyPromiseHandler
(
aDoc
aParentWindow
)
;
promise
-
>
AppendNativeHandler
(
handler
)
;
}
else
{
LoadNativeMenus
(
aDoc
aParentWindow
)
;
}
}
#
endif
class
AppWindowTimerCallback
final
:
public
nsITimerCallback
public
nsINamed
{
public
:
explicit
AppWindowTimerCallback
(
AppWindow
*
aWindow
)
:
mWindow
(
aWindow
)
{
}
NS_DECL_THREADSAFE_ISUPPORTS
NS_IMETHOD
Notify
(
nsITimer
*
aTimer
)
override
{
mWindow
-
>
FirePersistenceTimer
(
)
;
return
NS_OK
;
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
AppWindowTimerCallback
"
)
;
return
NS_OK
;
}
private
:
~
AppWindowTimerCallback
(
)
{
}
RefPtr
<
AppWindow
>
mWindow
;
}
;
NS_IMPL_ISUPPORTS
(
AppWindowTimerCallback
nsITimerCallback
nsINamed
)
void
AppWindow
:
:
SetPersistenceTimer
(
uint32_t
aDirtyFlags
)
{
MutexAutoLock
lock
(
mSPTimerLock
)
;
if
(
!
mSPTimer
)
{
mSPTimer
=
NS_NewTimer
(
)
;
if
(
!
mSPTimer
)
{
NS_WARNING
(
"
Couldn
'
t
create
mozilla
.
org
/
timer
;
1
instance
?
"
)
;
return
;
}
}
RefPtr
<
AppWindowTimerCallback
>
callback
=
new
AppWindowTimerCallback
(
this
)
;
mSPTimer
-
>
InitWithCallback
(
callback
SIZE_PERSISTENCE_TIMEOUT
nsITimer
:
:
TYPE_ONE_SHOT
)
;
PersistentAttributesDirty
(
aDirtyFlags
)
;
}
void
AppWindow
:
:
FirePersistenceTimer
(
)
{
MutexAutoLock
lock
(
mSPTimerLock
)
;
SavePersistentAttributes
(
)
;
}
NS_IMETHODIMP
AppWindow
:
:
OnProgressChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
aRequest
int32_t
aCurSelfProgress
int32_t
aMaxSelfProgress
int32_t
aCurTotalProgress
int32_t
aMaxTotalProgress
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
OnStateChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
aRequest
uint32_t
aStateFlags
nsresult
aStatus
)
{
if
(
!
(
aStateFlags
&
nsIWebProgressListener
:
:
STATE_STOP
)
|
|
!
(
aStateFlags
&
nsIWebProgressListener
:
:
STATE_IS_NETWORK
)
)
{
return
NS_OK
;
}
if
(
mChromeLoaded
)
return
NS_OK
;
nsCOMPtr
<
mozIDOMWindowProxy
>
eventWin
;
aProgress
-
>
GetDOMWindow
(
getter_AddRefs
(
eventWin
)
)
;
auto
*
eventPWin
=
nsPIDOMWindowOuter
:
:
From
(
eventWin
)
;
if
(
eventPWin
)
{
nsPIDOMWindowOuter
*
rootPWin
=
eventPWin
-
>
GetPrivateRoot
(
)
;
if
(
eventPWin
!
=
rootPWin
)
return
NS_OK
;
}
mChromeLoaded
=
true
;
mLockedUntilChromeLoad
=
false
;
#
ifdef
USE_NATIVE_MENUS
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
cv
)
{
RefPtr
<
Document
>
menubarDoc
=
cv
-
>
GetDocument
(
)
;
if
(
menubarDoc
)
{
if
(
mIsHiddenWindow
|
|
sHiddenWindowLoadedNativeMenus
)
{
BeginLoadNativeMenus
(
menubarDoc
mWindow
)
;
}
else
{
sLoadNativeMenusListeners
.
EmplaceBack
(
menubarDoc
mWindow
)
;
}
}
}
#
endif
OnChromeLoaded
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
OnLocationChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
aRequest
nsIURI
*
aURI
uint32_t
aFlags
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
OnStatusChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsresult
aStatus
const
char16_t
*
aMessage
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
OnSecurityChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aState
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
OnContentBlockingEvent
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aEvent
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
bool
AppWindow
:
:
ExecuteCloseHandler
(
)
{
nsCOMPtr
<
nsIAppWindow
>
kungFuDeathGrip
(
this
)
;
nsCOMPtr
<
EventTarget
>
eventTarget
;
if
(
mDocShell
)
{
eventTarget
=
do_QueryInterface
(
mDocShell
-
>
GetWindow
(
)
)
;
}
if
(
eventTarget
)
{
nsCOMPtr
<
nsIContentViewer
>
contentViewer
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
contentViewer
)
)
;
if
(
contentViewer
)
{
RefPtr
<
nsPresContext
>
presContext
=
contentViewer
-
>
GetPresContext
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eClose
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsresult
rv
=
EventDispatcher
:
:
Dispatch
(
eventTarget
presContext
&
event
nullptr
&
status
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
status
=
=
nsEventStatus_eConsumeNoDefault
)
return
true
;
}
}
return
false
;
}
void
AppWindow
:
:
ConstrainToOpenerScreen
(
int32_t
*
aX
int32_t
*
aY
)
{
if
(
mOpenerScreenRect
.
IsEmpty
(
)
)
{
*
aX
=
*
aY
=
0
;
return
;
}
int32_t
left
top
width
height
;
nsCOMPtr
<
nsIScreenManager
>
screenmgr
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
if
(
screenmgr
)
{
nsCOMPtr
<
nsIScreen
>
screen
=
screenmgr
-
>
ScreenForRect
(
mOpenerScreenRect
)
;
if
(
screen
)
{
screen
-
>
GetAvailRectDisplayPix
(
&
left
&
top
&
width
&
height
)
;
if
(
*
aX
<
left
|
|
*
aX
>
left
+
width
)
{
*
aX
=
left
;
}
if
(
*
aY
<
top
|
|
*
aY
>
top
+
height
)
{
*
aY
=
top
;
}
}
}
}
nsIAppWindow
*
AppWindow
:
:
WidgetListenerDelegate
:
:
GetAppWindow
(
)
{
return
mAppWindow
-
>
GetAppWindow
(
)
;
}
PresShell
*
AppWindow
:
:
WidgetListenerDelegate
:
:
GetPresShell
(
)
{
return
mAppWindow
-
>
GetPresShell
(
)
;
}
bool
AppWindow
:
:
WidgetListenerDelegate
:
:
WindowMoved
(
nsIWidget
*
aWidget
int32_t
aX
int32_t
aY
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
return
holder
-
>
WindowMoved
(
aWidget
aX
aY
)
;
}
bool
AppWindow
:
:
WidgetListenerDelegate
:
:
WindowResized
(
nsIWidget
*
aWidget
int32_t
aWidth
int32_t
aHeight
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
return
holder
-
>
WindowResized
(
aWidget
aWidth
aHeight
)
;
}
bool
AppWindow
:
:
WidgetListenerDelegate
:
:
RequestWindowClose
(
nsIWidget
*
aWidget
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
return
holder
-
>
RequestWindowClose
(
aWidget
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
SizeModeChanged
(
nsSizeMode
aSizeMode
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
SizeModeChanged
(
aSizeMode
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
UIResolutionChanged
(
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
UIResolutionChanged
(
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
FullscreenWillChange
(
bool
aInFullscreen
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
FullscreenWillChange
(
aInFullscreen
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
FullscreenChanged
(
bool
aInFullscreen
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
FullscreenChanged
(
aInFullscreen
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
MacFullscreenMenubarOverlapChanged
(
DesktopCoord
aOverlapAmount
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
return
holder
-
>
MacFullscreenMenubarOverlapChanged
(
aOverlapAmount
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
OcclusionStateChanged
(
bool
aIsFullyOccluded
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
OcclusionStateChanged
(
aIsFullyOccluded
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
OSToolbarButtonPressed
(
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
OSToolbarButtonPressed
(
)
;
}
bool
AppWindow
:
:
WidgetListenerDelegate
:
:
ZLevelChanged
(
bool
aImmediate
nsWindowZ
*
aPlacement
nsIWidget
*
aRequestBelow
nsIWidget
*
*
aActualBelow
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
return
holder
-
>
ZLevelChanged
(
aImmediate
aPlacement
aRequestBelow
aActualBelow
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
WindowActivated
(
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
WindowActivated
(
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
WindowDeactivated
(
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
WindowDeactivated
(
)
;
}
}
