#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
AppWindow
.
h
"
#
include
<
algorithm
>
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsGlobalWindowOuter
.
h
"
#
include
"
nsIAppShell
.
h
"
#
include
"
nsIAppShellService
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsScreen
.
h
"
#
include
"
nsIEmbeddingSiteWindow
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsIScreen
.
h
"
#
include
"
nsIScrollable
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsAppShellCID
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsXULTooltipListener
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
dom
/
BarProps
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
BrowserHost
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
LoadURIOptionsBinding
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
ifdef
MOZ_NEW_XULSTORE
#
include
"
mozilla
/
XULStore
.
h
"
#
endif
#
ifdef
XP_MACOSX
#
include
"
nsINativeMenuService
.
h
"
#
define
USE_NATIVE_MENUS
#
endif
#
define
SIZEMODE_NORMAL
NS_LITERAL_STRING
(
"
normal
"
)
#
define
SIZEMODE_MAXIMIZED
NS_LITERAL_STRING
(
"
maximized
"
)
#
define
SIZEMODE_MINIMIZED
NS_LITERAL_STRING
(
"
minimized
"
)
#
define
SIZEMODE_FULLSCREEN
NS_LITERAL_STRING
(
"
fullscreen
"
)
#
define
WINDOWTYPE_ATTRIBUTE
NS_LITERAL_STRING
(
"
windowtype
"
)
#
define
PERSIST_ATTRIBUTE
NS_LITERAL_STRING
(
"
persist
"
)
#
define
SCREENX_ATTRIBUTE
NS_LITERAL_STRING
(
"
screenX
"
)
#
define
SCREENY_ATTRIBUTE
NS_LITERAL_STRING
(
"
screenY
"
)
#
define
WIDTH_ATTRIBUTE
NS_LITERAL_STRING
(
"
width
"
)
#
define
HEIGHT_ATTRIBUTE
NS_LITERAL_STRING
(
"
height
"
)
#
define
MODE_ATTRIBUTE
NS_LITERAL_STRING
(
"
sizemode
"
)
#
define
TILED_ATTRIBUTE
NS_LITERAL_STRING
(
"
gtktiledwindow
"
)
#
define
ZLEVEL_ATTRIBUTE
NS_LITERAL_STRING
(
"
zlevel
"
)
#
define
SIZE_PERSISTENCE_TIMEOUT
500
/
/
msec
namespace
mozilla
{
using
dom
:
:
AutoNoJSAPI
;
using
dom
:
:
BrowserHost
;
using
dom
:
:
BrowsingContext
;
using
dom
:
:
Document
;
using
dom
:
:
Element
;
using
dom
:
:
EventTarget
;
using
dom
:
:
LoadURIOptions
;
AppWindow
:
:
AppWindow
(
uint32_t
aChromeFlags
)
:
mChromeTreeOwner
(
nullptr
)
mContentTreeOwner
(
nullptr
)
mPrimaryContentTreeOwner
(
nullptr
)
mModalStatus
(
NS_OK
)
mContinueModalLoop
(
false
)
mDebuting
(
false
)
mChromeLoaded
(
false
)
mSizingShellFromXUL
(
false
)
mShowAfterLoad
(
false
)
mIntrinsicallySized
(
false
)
mCenterAfterLoad
(
false
)
mIsHiddenWindow
(
false
)
mLockedUntilChromeLoad
(
false
)
mIgnoreXULSize
(
false
)
mIgnoreXULPosition
(
false
)
mChromeFlagsFrozen
(
false
)
mIgnoreXULSizeMode
(
false
)
mDestroying
(
false
)
mRegistered
(
false
)
mPersistentAttributesDirty
(
0
)
mPersistentAttributesMask
(
0
)
mChromeFlags
(
aChromeFlags
)
mNextRemoteTabId
(
0
)
mSPTimerLock
(
"
AppWindow
.
mSPTimerLock
"
)
mWidgetListenerDelegate
(
this
)
{
}
AppWindow
:
:
~
AppWindow
(
)
{
{
MutexAutoLock
lock
(
mSPTimerLock
)
;
if
(
mSPTimer
)
mSPTimer
-
>
Cancel
(
)
;
}
Destroy
(
)
;
}
NS_IMPL_ADDREF
(
AppWindow
)
NS_IMPL_RELEASE
(
AppWindow
)
NS_INTERFACE_MAP_BEGIN
(
AppWindow
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIAppWindow
)
NS_INTERFACE_MAP_ENTRY
(
nsIAppWindow
)
NS_INTERFACE_MAP_ENTRY
(
nsIBaseWindow
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIWebProgressListener
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
AppWindow
)
NS_INTERFACE_MAP_END
nsresult
AppWindow
:
:
Initialize
(
nsIAppWindow
*
aParent
nsIAppWindow
*
aOpener
nsIURI
*
aUrl
int32_t
aInitialWidth
int32_t
aInitialHeight
bool
aIsHiddenWindow
nsIRemoteTab
*
aOpeningTab
mozIDOMWindowProxy
*
aOpenerWindow
nsWidgetInitData
&
widgetInitData
)
{
nsresult
rv
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
mIsHiddenWindow
=
aIsHiddenWindow
;
int32_t
initialX
=
0
initialY
=
0
;
nsCOMPtr
<
nsIBaseWindow
>
base
(
do_QueryInterface
(
aOpener
)
)
;
if
(
base
)
{
int32_t
x
y
width
height
;
rv
=
base
-
>
GetPositionAndSize
(
&
x
&
y
&
width
&
height
)
;
if
(
NS_FAILED
(
rv
)
)
{
mOpenerScreenRect
.
SetEmpty
(
)
;
}
else
{
double
scale
;
if
(
NS_SUCCEEDED
(
base
-
>
GetUnscaledDevicePixelsPerCSSPixel
(
&
scale
)
)
)
{
mOpenerScreenRect
.
SetRect
(
NSToIntRound
(
x
/
scale
)
NSToIntRound
(
y
/
scale
)
NSToIntRound
(
width
/
scale
)
NSToIntRound
(
height
/
scale
)
)
;
}
else
{
mOpenerScreenRect
.
SetRect
(
x
y
width
height
)
;
}
initialX
=
mOpenerScreenRect
.
X
(
)
;
initialY
=
mOpenerScreenRect
.
Y
(
)
;
ConstrainToOpenerScreen
(
&
initialX
&
initialY
)
;
}
}
DesktopIntRect
deskRect
(
initialX
initialY
aInitialWidth
aInitialHeight
)
;
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
mWindow
=
nsIWidget
:
:
CreateHeadlessWidget
(
)
;
}
else
{
mWindow
=
nsIWidget
:
:
CreateTopLevelWindow
(
)
;
}
if
(
!
mWindow
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIBaseWindow
>
parentAsWin
(
do_QueryInterface
(
aParent
)
)
;
if
(
parentAsWin
)
{
parentAsWin
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
mParentWindow
=
do_GetWeakReference
(
aParent
)
;
}
mWindow
-
>
SetWidgetListener
(
&
mWidgetListenerDelegate
)
;
rv
=
mWindow
-
>
Create
(
(
nsIWidget
*
)
parentWidget
nullptr
deskRect
&
widgetInitData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LayoutDeviceIntRect
r
=
mWindow
-
>
GetClientBounds
(
)
;
mWindow
-
>
SetBackgroundColor
(
NS_RGB
(
255
255
255
)
)
;
RefPtr
<
BrowsingContext
>
openerContext
=
aOpenerWindow
?
nsPIDOMWindowOuter
:
:
From
(
aOpenerWindow
)
-
>
GetBrowsingContext
(
)
:
nullptr
;
RefPtr
<
BrowsingContext
>
browsingContext
=
BrowsingContext
:
:
Create
(
nullptr
openerContext
EmptyString
(
)
BrowsingContext
:
:
Type
:
:
Chrome
)
;
mDocShell
=
nsDocShell
:
:
Create
(
browsingContext
)
;
NS_ENSURE_TRUE
(
mDocShell
NS_ERROR_FAILURE
)
;
mDocShell
-
>
SetOpener
(
aOpeningTab
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellAsItem
(
mDocShell
)
;
NS_ENSURE_TRUE
(
docShellAsItem
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
EnsureChromeTreeOwner
(
)
NS_ERROR_FAILURE
)
;
docShellAsItem
-
>
SetTreeOwner
(
mChromeTreeOwner
)
;
r
.
MoveTo
(
0
0
)
;
nsCOMPtr
<
nsIBaseWindow
>
docShellAsWin
(
do_QueryInterface
(
mDocShell
)
)
;
NS_ENSURE_SUCCESS
(
docShellAsWin
-
>
InitWindow
(
nullptr
mWindow
r
.
X
(
)
r
.
Y
(
)
r
.
Width
(
)
r
.
Height
(
)
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
docShellAsWin
-
>
Create
(
)
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIWebProgress
>
webProgress
(
do_GetInterface
(
mDocShell
&
rv
)
)
;
if
(
webProgress
)
{
webProgress
-
>
AddProgressListener
(
this
nsIWebProgress
:
:
NOTIFY_STATE_NETWORK
)
;
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
if
(
aOpenerWindow
)
{
BrowsingContext
*
bc
=
mDocShell
-
>
GetBrowsingContext
(
)
;
BrowsingContext
*
openerBC
=
nsPIDOMWindowOuter
:
:
From
(
aOpenerWindow
)
-
>
GetBrowsingContext
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
bc
-
>
GetOpenerId
(
)
=
=
openerBC
-
>
Id
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
bc
-
>
HadOriginalOpener
(
)
)
;
}
#
endif
if
(
nsContentUtils
:
:
IsInitialized
(
)
)
{
MOZ_ASSERT
(
mDocShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
nsContentUtils
:
:
SubjectPrincipalOrSystemIfNativeCaller
(
)
;
if
(
nsContentUtils
:
:
IsExpandedPrincipal
(
principal
)
)
{
principal
=
nullptr
;
}
rv
=
mDocShell
-
>
CreateAboutBlankContentViewer
(
principal
principal
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
Document
>
doc
=
mDocShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
!
!
doc
NS_ERROR_FAILURE
)
;
doc
-
>
SetIsInitialDocument
(
true
)
;
}
if
(
nullptr
!
=
aUrl
)
{
nsCString
tmpStr
;
rv
=
aUrl
-
>
GetSpec
(
tmpStr
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
NS_ConvertUTF8toUTF16
urlString
(
tmpStr
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_QueryInterface
(
mDocShell
)
)
;
NS_ENSURE_TRUE
(
webNav
NS_ERROR_FAILURE
)
;
LoadURIOptions
loadURIOptions
;
loadURIOptions
.
mTriggeringPrincipal
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
rv
=
webNav
-
>
LoadURI
(
urlString
loadURIOptions
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
rv
;
}
NS_IMETHODIMP
AppWindow
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
nsresult
rv
;
NS_ENSURE_ARG_POINTER
(
aSink
)
;
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIPrompt
)
)
)
{
rv
=
EnsurePrompter
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
mPrompter
-
>
QueryInterface
(
aIID
aSink
)
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt
)
)
)
{
rv
=
EnsureAuthPrompter
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
mAuthPrompter
-
>
QueryInterface
(
aIID
aSink
)
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
mozIDOMWindowProxy
)
)
)
{
return
GetWindowDOMWindow
(
reinterpret_cast
<
mozIDOMWindowProxy
*
*
>
(
aSink
)
)
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIDOMWindow
)
)
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
window
=
nullptr
;
rv
=
GetWindowDOMWindow
(
getter_AddRefs
(
window
)
)
;
nsCOMPtr
<
nsIDOMWindow
>
domWindow
=
do_QueryInterface
(
window
)
;
domWindow
.
forget
(
aSink
)
;
return
rv
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIWebBrowserChrome
)
)
&
&
NS_SUCCEEDED
(
EnsureContentTreeOwner
(
)
)
&
&
NS_SUCCEEDED
(
mContentTreeOwner
-
>
QueryInterface
(
aIID
aSink
)
)
)
return
NS_OK
;
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIEmbeddingSiteWindow
)
)
&
&
NS_SUCCEEDED
(
EnsureContentTreeOwner
(
)
)
&
&
NS_SUCCEEDED
(
mContentTreeOwner
-
>
QueryInterface
(
aIID
aSink
)
)
)
return
NS_OK
;
return
QueryInterface
(
aIID
aSink
)
;
}
NS_IMETHODIMP
AppWindow
:
:
GetDocShell
(
nsIDocShell
*
*
aDocShell
)
{
NS_ENSURE_ARG_POINTER
(
aDocShell
)
;
*
aDocShell
=
mDocShell
;
NS_IF_ADDREF
(
*
aDocShell
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetZLevel
(
uint32_t
*
outLevel
)
{
nsCOMPtr
<
nsIWindowMediator
>
mediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
mediator
)
mediator
-
>
GetZLevel
(
this
outLevel
)
;
else
*
outLevel
=
normalZ
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetZLevel
(
uint32_t
aLevel
)
{
nsCOMPtr
<
nsIWindowMediator
>
mediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
!
mediator
)
return
NS_ERROR_FAILURE
;
uint32_t
zLevel
;
mediator
-
>
GetZLevel
(
this
&
zLevel
)
;
if
(
zLevel
=
=
aLevel
)
return
NS_OK
;
if
(
aLevel
>
nsIAppWindow
:
:
normalZ
&
&
mWindow
)
{
nsSizeMode
sizeMode
=
mWindow
-
>
SizeMode
(
)
;
if
(
sizeMode
=
=
nsSizeMode_Maximized
|
|
sizeMode
=
=
nsSizeMode_Fullscreen
)
{
return
NS_ERROR_FAILURE
;
}
}
mediator
-
>
SetZLevel
(
this
aLevel
)
;
PersistentAttributesDirty
(
PAD_MISC
)
;
SavePersistentAttributes
(
)
;
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
cv
)
{
RefPtr
<
dom
:
:
Document
>
doc
=
cv
-
>
GetDocument
(
)
;
if
(
doc
)
{
ErrorResult
rv
;
RefPtr
<
dom
:
:
Event
>
event
=
doc
-
>
CreateEvent
(
NS_LITERAL_STRING
(
"
Events
"
)
dom
:
:
CallerType
:
:
System
rv
)
;
if
(
event
)
{
event
-
>
InitEvent
(
NS_LITERAL_STRING
(
"
windowZLevel
"
)
true
false
)
;
event
-
>
SetTrusted
(
true
)
;
doc
-
>
DispatchEvent
(
*
event
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetChromeFlags
(
uint32_t
*
aChromeFlags
)
{
NS_ENSURE_ARG_POINTER
(
aChromeFlags
)
;
*
aChromeFlags
=
mChromeFlags
;
if
(
!
mChromeLoaded
)
return
NS_OK
;
if
(
GetContentScrollbarVisibility
(
)
)
*
aChromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_SCROLLBARS
;
else
*
aChromeFlags
&
=
~
nsIWebBrowserChrome
:
:
CHROME_SCROLLBARS
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetChromeFlags
(
uint32_t
aChromeFlags
)
{
NS_ASSERTION
(
!
mChromeFlagsFrozen
"
SetChromeFlags
(
)
after
AssumeChromeFlagsAreFrozen
(
)
!
"
)
;
mChromeFlags
=
aChromeFlags
;
if
(
mChromeLoaded
)
{
ApplyChromeFlags
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
AssumeChromeFlagsAreFrozen
(
)
{
mChromeFlagsFrozen
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetIntrinsicallySized
(
bool
aIntrinsicallySized
)
{
mIntrinsicallySized
=
aIntrinsicallySized
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetIntrinsicallySized
(
bool
*
aIntrinsicallySized
)
{
NS_ENSURE_ARG_POINTER
(
aIntrinsicallySized
)
;
*
aIntrinsicallySized
=
mIntrinsicallySized
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetPrimaryContentShell
(
nsIDocShellTreeItem
*
*
aDocShellTreeItem
)
{
NS_ENSURE_ARG_POINTER
(
aDocShellTreeItem
)
;
NS_IF_ADDREF
(
*
aDocShellTreeItem
=
mPrimaryContentShell
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
RemoteTabAdded
(
nsIRemoteTab
*
aTab
bool
aPrimary
)
{
if
(
aPrimary
)
{
mPrimaryBrowserParent
=
aTab
;
mPrimaryContentShell
=
nullptr
;
}
else
if
(
mPrimaryBrowserParent
=
=
aTab
)
{
mPrimaryBrowserParent
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
RemoteTabRemoved
(
nsIRemoteTab
*
aTab
)
{
if
(
aTab
=
=
mPrimaryBrowserParent
)
{
mPrimaryBrowserParent
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetPrimaryRemoteTab
(
nsIRemoteTab
*
*
aTab
)
{
nsCOMPtr
<
nsIRemoteTab
>
tab
=
mPrimaryBrowserParent
;
tab
.
forget
(
aTab
)
;
return
NS_OK
;
}
static
LayoutDeviceIntSize
GetOuterToInnerSizeDifference
(
nsIWidget
*
aWindow
)
{
if
(
!
aWindow
)
{
return
LayoutDeviceIntSize
(
)
;
}
LayoutDeviceIntSize
baseSize
(
200
200
)
;
LayoutDeviceIntSize
windowSize
=
aWindow
-
>
ClientToWindowSize
(
baseSize
)
;
return
windowSize
-
baseSize
;
}
static
CSSIntSize
GetOuterToInnerSizeDifferenceInCSSPixels
(
nsIWidget
*
aWindow
)
{
if
(
!
aWindow
)
{
return
{
}
;
}
LayoutDeviceIntSize
devPixelSize
=
GetOuterToInnerSizeDifference
(
aWindow
)
;
return
RoundedToInt
(
devPixelSize
/
aWindow
-
>
GetDefaultScale
(
)
)
;
}
NS_IMETHODIMP
AppWindow
:
:
GetOuterToInnerHeightDifferenceInCSSPixels
(
uint32_t
*
aResult
)
{
*
aResult
=
GetOuterToInnerSizeDifferenceInCSSPixels
(
mWindow
)
.
height
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetOuterToInnerWidthDifferenceInCSSPixels
(
uint32_t
*
aResult
)
{
*
aResult
=
GetOuterToInnerSizeDifferenceInCSSPixels
(
mWindow
)
.
width
;
return
NS_OK
;
}
nsTArray
<
RefPtr
<
mozilla
:
:
LiveResizeListener
>
>
AppWindow
:
:
GetLiveResizeListeners
(
)
{
nsTArray
<
RefPtr
<
mozilla
:
:
LiveResizeListener
>
>
listeners
;
if
(
mPrimaryBrowserParent
)
{
BrowserHost
*
host
=
BrowserHost
:
:
GetFrom
(
mPrimaryBrowserParent
.
get
(
)
)
;
listeners
.
AppendElement
(
host
-
>
GetActor
(
)
)
;
}
return
listeners
;
}
NS_IMETHODIMP
AppWindow
:
:
AddChildWindow
(
nsIAppWindow
*
aChild
)
{
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
RemoveChildWindow
(
nsIAppWindow
*
aChild
)
{
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
ShowModal
(
)
{
AUTO_PROFILER_LABEL
(
"
AppWindow
:
:
ShowModal
"
OTHER
)
;
nsCOMPtr
<
nsIWidget
>
window
=
mWindow
;
nsCOMPtr
<
nsIAppWindow
>
tempRef
=
this
;
window
-
>
SetModal
(
true
)
;
mContinueModalLoop
=
true
;
EnableParent
(
false
)
;
{
AutoNoJSAPI
nojsapi
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
!
mContinueModalLoop
;
}
)
;
}
mContinueModalLoop
=
false
;
window
-
>
SetModal
(
false
)
;
return
mModalStatus
;
}
NS_IMETHODIMP
AppWindow
:
:
InitWindow
(
nativeWindow
aParentNativeWindow
nsIWidget
*
parentWidget
int32_t
x
int32_t
y
int32_t
cx
int32_t
cy
)
{
NS_ASSERTION
(
false
"
Not
Yet
Implemented
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
Create
(
)
{
NS_ASSERTION
(
false
"
Not
Yet
Implemented
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
Destroy
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIWebProgress
>
webProgress
(
do_GetInterface
(
mDocShell
&
rv
)
)
;
if
(
webProgress
)
{
webProgress
-
>
RemoveProgressListener
(
this
)
;
}
nsCOMPtr
<
nsIAppWindow
>
kungFuDeathGrip
(
this
)
;
{
MutexAutoLock
lock
(
mSPTimerLock
)
;
if
(
mSPTimer
)
{
mSPTimer
-
>
Cancel
(
)
;
SavePersistentAttributes
(
)
;
mSPTimer
=
nullptr
;
}
}
if
(
!
mWindow
)
return
NS_OK
;
if
(
mDestroying
)
return
NS_OK
;
mozilla
:
:
AutoRestore
<
bool
>
guard
(
mDestroying
)
;
mDestroying
=
true
;
nsCOMPtr
<
nsIAppShellService
>
appShell
(
do_GetService
(
NS_APPSHELLSERVICE_CONTRACTID
)
)
;
NS_ASSERTION
(
appShell
"
Couldn
'
t
get
appShell
.
.
.
xpcom
shutdown
?
"
)
;
if
(
appShell
)
appShell
-
>
UnregisterTopLevelWindow
(
static_cast
<
nsIAppWindow
*
>
(
this
)
)
;
nsCOMPtr
<
nsIAppWindow
>
parentWindow
(
do_QueryReferent
(
mParentWindow
)
)
;
if
(
parentWindow
)
parentWindow
-
>
RemoveChildWindow
(
this
)
;
nsCOMPtr
<
nsIAppWindow
>
placeHolder
=
this
;
ExitModalLoop
(
NS_OK
)
;
#
ifndef
MOZ_WIDGET_GTK
if
(
mWindow
)
mWindow
-
>
Show
(
false
)
;
#
endif
#
if
defined
(
XP_WIN
)
nsCOMPtr
<
nsIBaseWindow
>
parent
(
do_QueryReferent
(
mParentWindow
)
)
;
if
(
parent
)
{
nsCOMPtr
<
nsIWidget
>
parentWidget
;
parent
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
if
(
parentWidget
&
&
parentWidget
-
>
IsVisible
(
)
)
{
bool
isParentHiddenWindow
=
false
;
if
(
appShell
)
{
bool
hasHiddenWindow
=
false
;
appShell
-
>
GetHasHiddenWindow
(
&
hasHiddenWindow
)
;
if
(
hasHiddenWindow
)
{
nsCOMPtr
<
nsIBaseWindow
>
baseHiddenWindow
;
nsCOMPtr
<
nsIAppWindow
>
hiddenWindow
;
appShell
-
>
GetHiddenWindow
(
getter_AddRefs
(
hiddenWindow
)
)
;
if
(
hiddenWindow
)
{
baseHiddenWindow
=
do_GetInterface
(
hiddenWindow
)
;
isParentHiddenWindow
=
(
baseHiddenWindow
=
=
parent
)
;
}
}
}
if
(
!
isParentHiddenWindow
)
{
parentWidget
-
>
PlaceBehind
(
eZPlacementTop
0
true
)
;
}
}
}
#
endif
RemoveTooltipSupport
(
)
;
mDOMWindow
=
nullptr
;
if
(
mDocShell
)
{
nsCOMPtr
<
nsIBaseWindow
>
shellAsWin
(
do_QueryInterface
(
mDocShell
)
)
;
shellAsWin
-
>
Destroy
(
)
;
mDocShell
=
nullptr
;
}
mPrimaryContentShell
=
nullptr
;
if
(
mContentTreeOwner
)
{
mContentTreeOwner
-
>
AppWindow
(
nullptr
)
;
NS_RELEASE
(
mContentTreeOwner
)
;
}
if
(
mPrimaryContentTreeOwner
)
{
mPrimaryContentTreeOwner
-
>
AppWindow
(
nullptr
)
;
NS_RELEASE
(
mPrimaryContentTreeOwner
)
;
}
if
(
mChromeTreeOwner
)
{
mChromeTreeOwner
-
>
AppWindow
(
nullptr
)
;
NS_RELEASE
(
mChromeTreeOwner
)
;
}
if
(
mWindow
)
{
mWindow
-
>
SetWidgetListener
(
nullptr
)
;
mWindow
-
>
Destroy
(
)
;
mWindow
=
nullptr
;
}
if
(
!
mIsHiddenWindow
&
&
mRegistered
)
{
nsCOMPtr
<
nsIObserverService
>
obssvc
=
services
:
:
GetObserverService
(
)
;
NS_ASSERTION
(
obssvc
"
Couldn
'
t
get
observer
service
?
"
)
;
if
(
obssvc
)
obssvc
-
>
NotifyObservers
(
nullptr
"
xul
-
window
-
destroyed
"
nullptr
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetDevicePixelsPerDesktopPixel
(
double
*
aScale
)
{
*
aScale
=
mWindow
?
mWindow
-
>
GetDesktopToDeviceScale
(
)
.
scale
:
1
.
0
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetUnscaledDevicePixelsPerCSSPixel
(
double
*
aScale
)
{
*
aScale
=
mWindow
?
mWindow
-
>
GetDefaultScale
(
)
.
scale
:
1
.
0
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetPositionDesktopPix
(
int32_t
aX
int32_t
aY
)
{
mWindow
-
>
Move
(
aX
aY
)
;
if
(
mSizingShellFromXUL
)
{
return
NS_OK
;
}
if
(
!
mChromeLoaded
)
{
mIgnoreXULPosition
=
true
;
return
NS_OK
;
}
PersistentAttributesDirty
(
PAD_POSITION
)
;
SavePersistentAttributes
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetPosition
(
int32_t
aX
int32_t
aY
)
{
DesktopToLayoutDeviceScale
currScale
=
mWindow
-
>
GetDesktopToDeviceScale
(
)
;
DesktopPoint
pos
=
LayoutDeviceIntPoint
(
aX
aY
)
/
currScale
;
return
SetPositionDesktopPix
(
pos
.
x
pos
.
y
)
;
}
NS_IMETHODIMP
AppWindow
:
:
GetPosition
(
int32_t
*
aX
int32_t
*
aY
)
{
return
GetPositionAndSize
(
aX
aY
nullptr
nullptr
)
;
}
NS_IMETHODIMP
AppWindow
:
:
SetSize
(
int32_t
aCX
int32_t
aCY
bool
aRepaint
)
{
mWindow
-
>
SetSizeMode
(
nsSizeMode_Normal
)
;
mIntrinsicallySized
=
false
;
DesktopToLayoutDeviceScale
scale
=
mWindow
-
>
GetDesktopToDeviceScale
(
)
;
DesktopSize
size
=
LayoutDeviceIntSize
(
aCX
aCY
)
/
scale
;
mWindow
-
>
Resize
(
size
.
width
size
.
height
aRepaint
)
;
if
(
mSizingShellFromXUL
)
{
return
NS_OK
;
}
if
(
!
mChromeLoaded
)
{
mIgnoreXULSize
=
true
;
mIgnoreXULSizeMode
=
true
;
return
NS_OK
;
}
PersistentAttributesDirty
(
PAD_SIZE
)
;
SavePersistentAttributes
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetSize
(
int32_t
*
aCX
int32_t
*
aCY
)
{
return
GetPositionAndSize
(
nullptr
nullptr
aCX
aCY
)
;
}
NS_IMETHODIMP
AppWindow
:
:
SetPositionAndSize
(
int32_t
aX
int32_t
aY
int32_t
aCX
int32_t
aCY
uint32_t
aFlags
)
{
mWindow
-
>
SetSizeMode
(
nsSizeMode_Normal
)
;
mIntrinsicallySized
=
false
;
DesktopToLayoutDeviceScale
scale
=
mWindow
-
>
GetDesktopToDeviceScale
(
)
;
DesktopRect
rect
=
LayoutDeviceIntRect
(
aX
aY
aCX
aCY
)
/
scale
;
mWindow
-
>
Resize
(
rect
.
X
(
)
rect
.
Y
(
)
rect
.
Width
(
)
rect
.
Height
(
)
!
!
(
aFlags
&
nsIBaseWindow
:
:
eRepaint
)
)
;
if
(
mSizingShellFromXUL
)
{
return
NS_OK
;
}
if
(
!
mChromeLoaded
)
{
mIgnoreXULPosition
=
true
;
mIgnoreXULSize
=
true
;
mIgnoreXULSizeMode
=
true
;
return
NS_OK
;
}
PersistentAttributesDirty
(
PAD_POSITION
|
PAD_SIZE
)
;
SavePersistentAttributes
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetPositionAndSize
(
int32_t
*
x
int32_t
*
y
int32_t
*
cx
int32_t
*
cy
)
{
if
(
!
mWindow
)
return
NS_ERROR_FAILURE
;
LayoutDeviceIntRect
rect
=
mWindow
-
>
GetScreenBounds
(
)
;
if
(
x
)
*
x
=
rect
.
X
(
)
;
if
(
y
)
*
y
=
rect
.
Y
(
)
;
if
(
cx
)
*
cx
=
rect
.
Width
(
)
;
if
(
cy
)
*
cy
=
rect
.
Height
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
Center
(
nsIAppWindow
*
aRelative
bool
aScreen
bool
aAlert
)
{
int32_t
left
top
width
height
ourWidth
ourHeight
;
bool
screenCoordinates
=
false
windowCoordinates
=
false
;
nsresult
result
;
if
(
!
mChromeLoaded
)
{
mCenterAfterLoad
=
true
;
return
NS_OK
;
}
if
(
!
aScreen
&
&
!
aRelative
)
return
NS_ERROR_INVALID_ARG
;
nsCOMPtr
<
nsIScreenManager
>
screenmgr
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
&
result
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
nsCOMPtr
<
nsIScreen
>
screen
;
if
(
aRelative
)
{
nsCOMPtr
<
nsIBaseWindow
>
base
(
do_QueryInterface
(
aRelative
&
result
)
)
;
if
(
base
)
{
result
=
base
-
>
GetPositionAndSize
(
&
left
&
top
&
width
&
height
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
double
scale
;
if
(
NS_SUCCEEDED
(
base
-
>
GetDevicePixelsPerDesktopPixel
(
&
scale
)
)
)
{
left
=
NSToIntRound
(
left
/
scale
)
;
top
=
NSToIntRound
(
top
/
scale
)
;
width
=
NSToIntRound
(
width
/
scale
)
;
height
=
NSToIntRound
(
height
/
scale
)
;
}
if
(
aScreen
)
screenmgr
-
>
ScreenForRect
(
left
top
width
height
getter_AddRefs
(
screen
)
)
;
else
windowCoordinates
=
true
;
}
else
{
aRelative
=
0
;
aScreen
=
true
;
}
}
}
if
(
!
aRelative
)
{
if
(
!
mOpenerScreenRect
.
IsEmpty
(
)
)
{
screenmgr
-
>
ScreenForRect
(
mOpenerScreenRect
.
X
(
)
mOpenerScreenRect
.
Y
(
)
mOpenerScreenRect
.
Width
(
)
mOpenerScreenRect
.
Height
(
)
getter_AddRefs
(
screen
)
)
;
}
else
{
screenmgr
-
>
GetPrimaryScreen
(
getter_AddRefs
(
screen
)
)
;
}
}
if
(
aScreen
&
&
screen
)
{
screen
-
>
GetAvailRectDisplayPix
(
&
left
&
top
&
width
&
height
)
;
screenCoordinates
=
true
;
}
if
(
screenCoordinates
|
|
windowCoordinates
)
{
NS_ASSERTION
(
mWindow
"
what
no
window
?
"
)
;
double
scale
=
mWindow
-
>
GetDesktopToDeviceScale
(
)
.
scale
;
GetSize
(
&
ourWidth
&
ourHeight
)
;
int32_t
scaledWidth
scaledHeight
;
scaledWidth
=
NSToIntRound
(
ourWidth
/
scale
)
;
scaledHeight
=
NSToIntRound
(
ourHeight
/
scale
)
;
left
+
=
(
width
-
scaledWidth
)
/
2
;
top
+
=
(
height
-
scaledHeight
)
/
(
aAlert
?
3
:
2
)
;
if
(
windowCoordinates
)
{
mWindow
-
>
ConstrainPosition
(
false
&
left
&
top
)
;
}
SetPosition
(
left
*
scale
top
*
scale
)
;
int32_t
newWidth
newHeight
;
GetSize
(
&
newWidth
&
newHeight
)
;
if
(
newWidth
!
=
ourWidth
|
|
newHeight
!
=
ourHeight
)
{
return
Center
(
aRelative
aScreen
aAlert
)
;
}
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
AppWindow
:
:
Repaint
(
bool
aForce
)
{
NS_ASSERTION
(
false
"
Not
Yet
Implemented
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetParentWidget
(
nsIWidget
*
*
aParentWidget
)
{
NS_ENSURE_ARG_POINTER
(
aParentWidget
)
;
NS_ENSURE_STATE
(
mWindow
)
;
NS_IF_ADDREF
(
*
aParentWidget
=
mWindow
-
>
GetParent
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetParentWidget
(
nsIWidget
*
aParentWidget
)
{
NS_ASSERTION
(
false
"
Not
Yet
Implemented
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetParentNativeWindow
(
nativeWindow
*
aParentNativeWindow
)
{
NS_ENSURE_ARG_POINTER
(
aParentNativeWindow
)
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
NS_ENSURE_SUCCESS
(
GetParentWidget
(
getter_AddRefs
(
parentWidget
)
)
NS_ERROR_FAILURE
)
;
if
(
parentWidget
)
{
*
aParentNativeWindow
=
parentWidget
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetParentNativeWindow
(
nativeWindow
aParentNativeWindow
)
{
NS_ASSERTION
(
false
"
Not
Yet
Implemented
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetNativeHandle
(
nsAString
&
aNativeHandle
)
{
nsCOMPtr
<
nsIWidget
>
mainWidget
;
NS_ENSURE_SUCCESS
(
GetMainWidget
(
getter_AddRefs
(
mainWidget
)
)
NS_ERROR_FAILURE
)
;
if
(
mainWidget
)
{
nativeWindow
nativeWindowPtr
=
mainWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
aNativeHandle
=
NS_ConvertASCIItoUTF16
(
nsPrintfCString
(
"
0x
%
p
"
nativeWindowPtr
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetVisibility
(
bool
*
aVisibility
)
{
NS_ENSURE_ARG_POINTER
(
aVisibility
)
;
*
aVisibility
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetVisibility
(
bool
aVisibility
)
{
if
(
!
mChromeLoaded
)
{
mShowAfterLoad
=
aVisibility
;
return
NS_OK
;
}
if
(
mDebuting
)
{
return
NS_OK
;
}
mDebuting
=
true
;
nsCOMPtr
<
nsIBaseWindow
>
shellAsWin
(
do_QueryInterface
(
mDocShell
)
)
;
shellAsWin
-
>
SetVisibility
(
aVisibility
)
;
nsCOMPtr
<
nsIWidget
>
window
=
mWindow
;
window
-
>
Show
(
aVisibility
)
;
nsCOMPtr
<
nsIWindowMediator
>
windowMediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
windowMediator
)
windowMediator
-
>
UpdateWindowTimeStamp
(
static_cast
<
nsIAppWindow
*
>
(
this
)
)
;
nsCOMPtr
<
nsIObserverService
>
obssvc
=
services
:
:
GetObserverService
(
)
;
NS_ASSERTION
(
obssvc
"
Couldn
'
t
get
observer
service
.
"
)
;
if
(
obssvc
)
{
obssvc
-
>
NotifyObservers
(
static_cast
<
nsIAppWindow
*
>
(
this
)
"
xul
-
window
-
visible
"
nullptr
)
;
}
mDebuting
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetEnabled
(
bool
*
aEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aEnabled
)
;
if
(
mWindow
)
{
*
aEnabled
=
mWindow
-
>
IsEnabled
(
)
;
return
NS_OK
;
}
*
aEnabled
=
true
;
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
AppWindow
:
:
SetEnabled
(
bool
aEnable
)
{
if
(
mWindow
)
{
mWindow
-
>
Enable
(
aEnable
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
AppWindow
:
:
GetMainWidget
(
nsIWidget
*
*
aMainWidget
)
{
NS_ENSURE_ARG_POINTER
(
aMainWidget
)
;
*
aMainWidget
=
mWindow
;
NS_IF_ADDREF
(
*
aMainWidget
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetFocus
(
)
{
NS_ASSERTION
(
false
"
Not
Yet
Implemented
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetTitle
(
nsAString
&
aTitle
)
{
aTitle
=
mTitle
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetTitle
(
const
nsAString
&
aTitle
)
{
NS_ENSURE_STATE
(
mWindow
)
;
mTitle
.
Assign
(
aTitle
)
;
mTitle
.
StripCRLF
(
)
;
NS_ENSURE_SUCCESS
(
mWindow
-
>
SetTitle
(
mTitle
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
EnsureChromeTreeOwner
(
)
{
if
(
mChromeTreeOwner
)
return
NS_OK
;
mChromeTreeOwner
=
new
nsChromeTreeOwner
(
)
;
NS_ADDREF
(
mChromeTreeOwner
)
;
mChromeTreeOwner
-
>
AppWindow
(
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
EnsureContentTreeOwner
(
)
{
if
(
mContentTreeOwner
)
return
NS_OK
;
mContentTreeOwner
=
new
nsContentTreeOwner
(
false
)
;
NS_ADDREF
(
mContentTreeOwner
)
;
mContentTreeOwner
-
>
AppWindow
(
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
EnsurePrimaryContentTreeOwner
(
)
{
if
(
mPrimaryContentTreeOwner
)
return
NS_OK
;
mPrimaryContentTreeOwner
=
new
nsContentTreeOwner
(
true
)
;
NS_ADDREF
(
mPrimaryContentTreeOwner
)
;
mPrimaryContentTreeOwner
-
>
AppWindow
(
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
EnsurePrompter
(
)
{
if
(
mPrompter
)
return
NS_OK
;
nsCOMPtr
<
mozIDOMWindowProxy
>
ourWindow
;
nsresult
rv
=
GetWindowDOMWindow
(
getter_AddRefs
(
ourWindow
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIWindowWatcher
>
wwatch
=
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
)
;
if
(
wwatch
)
wwatch
-
>
GetNewPrompter
(
ourWindow
getter_AddRefs
(
mPrompter
)
)
;
}
return
mPrompter
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
AppWindow
:
:
EnsureAuthPrompter
(
)
{
if
(
mAuthPrompter
)
return
NS_OK
;
nsCOMPtr
<
mozIDOMWindowProxy
>
ourWindow
;
nsresult
rv
=
GetWindowDOMWindow
(
getter_AddRefs
(
ourWindow
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIWindowWatcher
>
wwatch
(
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
)
)
;
if
(
wwatch
)
wwatch
-
>
GetNewAuthPrompter
(
ourWindow
getter_AddRefs
(
mAuthPrompter
)
)
;
}
return
mAuthPrompter
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
AppWindow
:
:
GetAvailScreenSize
(
int32_t
*
aAvailWidth
int32_t
*
aAvailHeight
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
domWindow
;
GetWindowDOMWindow
(
getter_AddRefs
(
domWindow
)
)
;
NS_ENSURE_STATE
(
domWindow
)
;
auto
*
window
=
nsGlobalWindowOuter
:
:
Cast
(
domWindow
)
;
RefPtr
<
nsScreen
>
screen
=
window
-
>
GetScreen
(
)
;
NS_ENSURE_STATE
(
screen
)
;
ErrorResult
rv
;
*
aAvailWidth
=
screen
-
>
GetAvailWidth
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
*
aAvailHeight
=
screen
-
>
GetAvailHeight
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
ForceRoundedDimensions
(
)
{
if
(
mIsHiddenWindow
)
{
return
NS_OK
;
}
int32_t
availWidthCSS
=
0
;
int32_t
availHeightCSS
=
0
;
int32_t
contentWidthCSS
=
0
;
int32_t
contentHeightCSS
=
0
;
int32_t
windowWidthCSS
=
0
;
int32_t
windowHeightCSS
=
0
;
double
devicePerCSSPixels
=
1
.
0
;
GetUnscaledDevicePixelsPerCSSPixel
(
&
devicePerCSSPixels
)
;
GetAvailScreenSize
(
&
availWidthCSS
&
availHeightCSS
)
;
SetSpecifiedSize
(
availWidthCSS
availHeightCSS
)
;
GetSize
(
&
windowWidthCSS
&
windowHeightCSS
)
;
windowWidthCSS
=
NSToIntRound
(
windowWidthCSS
/
devicePerCSSPixels
)
;
windowHeightCSS
=
NSToIntRound
(
windowHeightCSS
/
devicePerCSSPixels
)
;
GetPrimaryContentSize
(
&
contentWidthCSS
&
contentHeightCSS
)
;
int32_t
chromeWidth
=
0
chromeHeight
=
0
;
chromeWidth
=
windowWidthCSS
-
contentWidthCSS
;
chromeHeight
=
windowHeightCSS
-
contentHeightCSS
;
int32_t
targetContentWidth
=
0
targetContentHeight
=
0
;
nsContentUtils
:
:
CalcRoundedWindowSizeForResistingFingerprinting
(
chromeWidth
chromeHeight
availWidthCSS
availHeightCSS
availWidthCSS
availHeightCSS
false
false
&
targetContentWidth
&
targetContentHeight
)
;
targetContentWidth
=
NSToIntRound
(
targetContentWidth
*
devicePerCSSPixels
)
;
targetContentHeight
=
NSToIntRound
(
targetContentHeight
*
devicePerCSSPixels
)
;
SetPrimaryContentSize
(
targetContentWidth
targetContentHeight
)
;
return
NS_OK
;
}
void
AppWindow
:
:
OnChromeLoaded
(
)
{
nsresult
rv
=
EnsureContentTreeOwner
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mChromeLoaded
=
true
;
ApplyChromeFlags
(
)
;
SyncAttributesToWidget
(
)
;
if
(
mWindow
)
{
SizeShell
(
)
;
if
(
mShowAfterLoad
)
{
SetVisibility
(
true
)
;
}
AddTooltipSupport
(
)
;
}
}
mPersistentAttributesMask
|
=
PAD_POSITION
|
PAD_SIZE
|
PAD_MISC
;
}
bool
AppWindow
:
:
NeedsTooltipListener
(
)
{
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
if
(
!
docShellElement
|
|
docShellElement
-
>
IsXULElement
(
)
)
{
return
false
;
}
return
true
;
}
void
AppWindow
:
:
AddTooltipSupport
(
)
{
if
(
!
NeedsTooltipListener
(
)
)
{
return
;
}
nsXULTooltipListener
*
listener
=
nsXULTooltipListener
:
:
GetInstance
(
)
;
if
(
!
listener
)
{
return
;
}
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
MOZ_ASSERT
(
docShellElement
)
;
listener
-
>
AddTooltipSupport
(
docShellElement
)
;
}
void
AppWindow
:
:
RemoveTooltipSupport
(
)
{
if
(
!
NeedsTooltipListener
(
)
)
{
return
;
}
nsXULTooltipListener
*
listener
=
nsXULTooltipListener
:
:
GetInstance
(
)
;
if
(
!
listener
)
{
return
;
}
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
MOZ_ASSERT
(
docShellElement
)
;
listener
-
>
RemoveTooltipSupport
(
docShellElement
)
;
}
bool
AppWindow
:
:
LoadPositionFromXUL
(
int32_t
aSpecWidth
int32_t
aSpecHeight
)
{
bool
gotPosition
=
false
;
if
(
mIsHiddenWindow
)
return
false
;
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
NS_ENSURE_TRUE
(
windowElement
false
)
;
int32_t
currX
=
0
;
int32_t
currY
=
0
;
int32_t
currWidth
=
0
;
int32_t
currHeight
=
0
;
nsresult
errorCode
;
int32_t
temp
;
GetPositionAndSize
(
&
currX
&
currY
&
currWidth
&
currHeight
)
;
double
devToDesktopScale
=
1
.
0
/
mWindow
-
>
GetDesktopToDeviceScale
(
)
.
scale
;
currX
=
NSToIntRound
(
currX
*
devToDesktopScale
)
;
currY
=
NSToIntRound
(
currY
*
devToDesktopScale
)
;
double
devToCSSScale
=
1
.
0
/
mWindow
-
>
GetDefaultScale
(
)
.
scale
;
int32_t
cssWidth
=
aSpecWidth
>
0
?
aSpecWidth
:
NSToIntRound
(
currWidth
*
devToCSSScale
)
;
int32_t
cssHeight
=
aSpecHeight
>
0
?
aSpecHeight
:
NSToIntRound
(
currHeight
*
devToCSSScale
)
;
int32_t
specX
=
currX
;
int32_t
specY
=
currY
;
nsAutoString
posString
;
windowElement
-
>
GetAttribute
(
SCREENX_ATTRIBUTE
posString
)
;
temp
=
posString
.
ToInteger
(
&
errorCode
)
;
if
(
NS_SUCCEEDED
(
errorCode
)
)
{
specX
=
temp
;
gotPosition
=
true
;
}
windowElement
-
>
GetAttribute
(
SCREENY_ATTRIBUTE
posString
)
;
temp
=
posString
.
ToInteger
(
&
errorCode
)
;
if
(
NS_SUCCEEDED
(
errorCode
)
)
{
specY
=
temp
;
gotPosition
=
true
;
}
if
(
gotPosition
)
{
nsCOMPtr
<
nsIBaseWindow
>
parent
(
do_QueryReferent
(
mParentWindow
)
)
;
if
(
parent
)
{
int32_t
parentX
parentY
;
if
(
NS_SUCCEEDED
(
parent
-
>
GetPosition
(
&
parentX
&
parentY
)
)
)
{
double
scale
;
if
(
NS_SUCCEEDED
(
parent
-
>
GetDevicePixelsPerDesktopPixel
(
&
scale
)
)
)
{
parentX
=
NSToIntRound
(
parentX
/
scale
)
;
parentY
=
NSToIntRound
(
parentY
/
scale
)
;
}
specX
+
=
parentX
;
specY
+
=
parentY
;
}
}
else
{
StaggerPosition
(
specX
specY
cssWidth
cssHeight
)
;
}
}
mWindow
-
>
ConstrainPosition
(
false
&
specX
&
specY
)
;
if
(
specX
!
=
currX
|
|
specY
!
=
currY
)
{
SetPositionDesktopPix
(
specX
specY
)
;
}
return
gotPosition
;
}
static
Maybe
<
int32_t
>
ReadIntAttribute
(
const
Element
&
aElement
nsAtom
*
aAtom
)
{
nsAutoString
attrString
;
if
(
!
aElement
.
GetAttr
(
kNameSpaceID_None
aAtom
attrString
)
)
{
return
Nothing
(
)
;
}
nsresult
res
=
NS_OK
;
int32_t
ret
=
attrString
.
ToInteger
(
&
res
)
;
return
NS_SUCCEEDED
(
res
)
?
Some
(
ret
)
:
Nothing
(
)
;
}
static
Maybe
<
int32_t
>
ReadSize
(
const
Element
&
aElement
nsAtom
*
aAttr
nsAtom
*
aMinAttr
nsAtom
*
aMaxAttr
)
{
Maybe
<
int32_t
>
attr
=
ReadIntAttribute
(
aElement
aAttr
)
;
if
(
!
attr
)
{
return
Nothing
(
)
;
}
int32_t
min
=
std
:
:
max
(
100
ReadIntAttribute
(
aElement
aMinAttr
)
.
valueOr
(
100
)
)
;
int32_t
max
=
ReadIntAttribute
(
aElement
aMaxAttr
)
.
valueOr
(
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
;
return
Some
(
std
:
:
min
(
max
std
:
:
max
(
*
attr
min
)
)
)
;
}
bool
AppWindow
:
:
LoadSizeFromXUL
(
int32_t
&
aSpecWidth
int32_t
&
aSpecHeight
)
{
bool
gotSize
=
false
;
if
(
mIsHiddenWindow
)
{
return
false
;
}
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
NS_ENSURE_TRUE
(
windowElement
false
)
;
aSpecWidth
=
100
;
aSpecHeight
=
100
;
if
(
auto
width
=
ReadSize
(
*
windowElement
nsGkAtoms
:
:
width
nsGkAtoms
:
:
minwidth
nsGkAtoms
:
:
maxwidth
)
)
{
aSpecWidth
=
*
width
;
gotSize
=
true
;
}
if
(
auto
height
=
ReadSize
(
*
windowElement
nsGkAtoms
:
:
height
nsGkAtoms
:
:
minheight
nsGkAtoms
:
:
maxheight
)
)
{
aSpecHeight
=
*
height
;
gotSize
=
true
;
}
return
gotSize
;
}
void
AppWindow
:
:
SetSpecifiedSize
(
int32_t
aSpecWidth
int32_t
aSpecHeight
)
{
int32_t
screenWidth
;
int32_t
screenHeight
;
if
(
NS_SUCCEEDED
(
GetAvailScreenSize
(
&
screenWidth
&
screenHeight
)
)
)
{
if
(
aSpecWidth
>
screenWidth
)
{
aSpecWidth
=
screenWidth
;
}
if
(
aSpecHeight
>
screenHeight
)
{
aSpecHeight
=
screenHeight
;
}
}
NS_ASSERTION
(
mWindow
"
we
expected
to
have
a
window
already
"
)
;
int32_t
currWidth
=
0
;
int32_t
currHeight
=
0
;
GetSize
(
&
currWidth
&
currHeight
)
;
double
cssToDevPx
=
mWindow
?
mWindow
-
>
GetDefaultScale
(
)
.
scale
:
1
.
0
;
aSpecWidth
=
NSToIntRound
(
aSpecWidth
*
cssToDevPx
)
;
aSpecHeight
=
NSToIntRound
(
aSpecHeight
*
cssToDevPx
)
;
mIntrinsicallySized
=
false
;
if
(
aSpecWidth
!
=
currWidth
|
|
aSpecHeight
!
=
currHeight
)
{
SetSize
(
aSpecWidth
aSpecHeight
false
)
;
}
}
bool
AppWindow
:
:
UpdateWindowStateFromMiscXULAttributes
(
)
{
bool
gotState
=
false
;
if
(
mIsHiddenWindow
)
return
false
;
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
NS_ENSURE_TRUE
(
windowElement
false
)
;
nsAutoString
stateString
;
nsSizeMode
sizeMode
=
nsSizeMode_Normal
;
if
(
mIgnoreXULSizeMode
)
{
windowElement
-
>
SetAttribute
(
MODE_ATTRIBUTE
SIZEMODE_NORMAL
IgnoreErrors
(
)
)
;
}
else
{
windowElement
-
>
GetAttribute
(
MODE_ATTRIBUTE
stateString
)
;
if
(
(
stateString
.
Equals
(
SIZEMODE_MAXIMIZED
)
|
|
stateString
.
Equals
(
SIZEMODE_FULLSCREEN
)
)
)
{
if
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RESIZE
)
{
mIntrinsicallySized
=
false
;
if
(
stateString
.
Equals
(
SIZEMODE_MAXIMIZED
)
)
sizeMode
=
nsSizeMode_Maximized
;
else
sizeMode
=
nsSizeMode_Fullscreen
;
}
}
}
if
(
sizeMode
=
=
nsSizeMode_Fullscreen
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
ourWindow
;
GetWindowDOMWindow
(
getter_AddRefs
(
ourWindow
)
)
;
auto
*
piWindow
=
nsPIDOMWindowOuter
:
:
From
(
ourWindow
)
;
piWindow
-
>
SetFullScreen
(
true
)
;
}
else
{
if
(
sizeMode
=
=
nsSizeMode_Maximized
)
{
mIgnoreXULSize
=
true
;
mIgnoreXULPosition
=
true
;
}
mWindow
-
>
SetSizeMode
(
sizeMode
)
;
}
gotState
=
true
;
windowElement
-
>
GetAttribute
(
ZLEVEL_ATTRIBUTE
stateString
)
;
if
(
!
stateString
.
IsEmpty
(
)
)
{
nsresult
errorCode
;
int32_t
zLevel
=
stateString
.
ToInteger
(
&
errorCode
)
;
if
(
NS_SUCCEEDED
(
errorCode
)
&
&
zLevel
>
=
lowestZ
&
&
zLevel
<
=
highestZ
)
SetZLevel
(
zLevel
)
;
}
return
gotState
;
}
void
AppWindow
:
:
StaggerPosition
(
int32_t
&
aRequestedX
int32_t
&
aRequestedY
int32_t
aSpecWidth
int32_t
aSpecHeight
)
{
int32_t
kOffset
=
22
;
uint32_t
kSlop
=
4
;
bool
keepTrying
;
int
bouncedX
=
0
bouncedY
=
0
;
nsCOMPtr
<
nsIWindowMediator
>
wm
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
!
wm
)
return
;
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
if
(
!
windowElement
)
return
;
nsCOMPtr
<
nsIAppWindow
>
ourAppWindow
(
this
)
;
nsAutoString
windowType
;
windowElement
-
>
GetAttribute
(
WINDOWTYPE_ATTRIBUTE
windowType
)
;
int32_t
screenTop
=
0
screenRight
=
0
screenBottom
=
0
screenLeft
=
0
;
bool
gotScreen
=
false
;
{
nsCOMPtr
<
nsIScreenManager
>
screenMgr
(
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
)
;
if
(
screenMgr
)
{
nsCOMPtr
<
nsIScreen
>
ourScreen
;
screenMgr
-
>
ScreenForRect
(
aRequestedX
aRequestedY
aSpecWidth
aSpecHeight
getter_AddRefs
(
ourScreen
)
)
;
if
(
ourScreen
)
{
int32_t
screenWidth
screenHeight
;
ourScreen
-
>
GetAvailRectDisplayPix
(
&
screenLeft
&
screenTop
&
screenWidth
&
screenHeight
)
;
screenBottom
=
screenTop
+
screenHeight
;
screenRight
=
screenLeft
+
screenWidth
;
double
desktopToDeviceScale
=
1
.
0
cssToDeviceScale
=
1
.
0
;
ourScreen
-
>
GetContentsScaleFactor
(
&
desktopToDeviceScale
)
;
ourScreen
-
>
GetDefaultCSSScaleFactor
(
&
cssToDeviceScale
)
;
double
cssToDesktopFactor
=
cssToDeviceScale
/
desktopToDeviceScale
;
kOffset
=
NSToIntRound
(
kOffset
*
cssToDesktopFactor
)
;
kSlop
=
NSToIntRound
(
kSlop
*
cssToDesktopFactor
)
;
aSpecWidth
=
NSToIntRound
(
aSpecWidth
*
cssToDesktopFactor
)
;
aSpecHeight
=
NSToIntRound
(
aSpecHeight
*
cssToDesktopFactor
)
;
gotScreen
=
true
;
}
}
}
do
{
keepTrying
=
false
;
nsCOMPtr
<
nsISimpleEnumerator
>
windowList
;
wm
-
>
GetAppWindowEnumerator
(
windowType
.
get
(
)
getter_AddRefs
(
windowList
)
)
;
if
(
!
windowList
)
break
;
do
{
bool
more
;
windowList
-
>
HasMoreElements
(
&
more
)
;
if
(
!
more
)
break
;
nsCOMPtr
<
nsISupports
>
supportsWindow
;
windowList
-
>
GetNext
(
getter_AddRefs
(
supportsWindow
)
)
;
nsCOMPtr
<
nsIAppWindow
>
listAppWindow
(
do_QueryInterface
(
supportsWindow
)
)
;
if
(
listAppWindow
!
=
ourAppWindow
)
{
int32_t
listX
listY
;
nsCOMPtr
<
nsIBaseWindow
>
listBaseWindow
(
do_QueryInterface
(
supportsWindow
)
)
;
listBaseWindow
-
>
GetPosition
(
&
listX
&
listY
)
;
double
scale
;
if
(
NS_SUCCEEDED
(
listBaseWindow
-
>
GetDevicePixelsPerDesktopPixel
(
&
scale
)
)
)
{
listX
=
NSToIntRound
(
listX
/
scale
)
;
listY
=
NSToIntRound
(
listY
/
scale
)
;
}
if
(
Abs
(
listX
-
aRequestedX
)
<
=
kSlop
&
&
Abs
(
listY
-
aRequestedY
)
<
=
kSlop
)
{
if
(
bouncedX
&
0x1
)
aRequestedX
-
=
kOffset
;
else
aRequestedX
+
=
kOffset
;
aRequestedY
+
=
kOffset
;
if
(
gotScreen
)
{
if
(
!
(
bouncedX
&
0x1
)
&
&
(
(
aRequestedX
+
aSpecWidth
)
>
screenRight
)
)
{
aRequestedX
=
screenRight
-
aSpecWidth
;
+
+
bouncedX
;
}
if
(
(
bouncedX
&
0x1
)
&
&
aRequestedX
<
screenLeft
)
{
aRequestedX
=
screenLeft
;
+
+
bouncedX
;
}
if
(
aRequestedY
+
aSpecHeight
>
screenBottom
)
{
aRequestedY
=
screenTop
;
+
+
bouncedY
;
}
}
keepTrying
=
bouncedX
<
2
|
|
bouncedY
=
=
0
;
break
;
}
}
}
while
(
1
)
;
}
while
(
keepTrying
)
;
}
void
AppWindow
:
:
SyncAttributesToWidget
(
)
{
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
if
(
!
windowElement
)
return
;
MOZ_DIAGNOSTIC_ASSERT
(
mWindow
"
No
widget
on
SyncAttributesToWidget
?
"
)
;
nsAutoString
attr
;
if
(
windowElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
hidechrome
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
mWindow
-
>
HideWindowChrome
(
true
)
;
}
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
nsIntMargin
margins
;
windowElement
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
chromemargin
"
)
attr
)
;
if
(
nsContentUtils
:
:
ParseIntMarginValue
(
attr
margins
)
)
{
LayoutDeviceIntMargin
tmp
=
LayoutDeviceIntMargin
:
:
FromUnknownMargin
(
margins
)
;
mWindow
-
>
SetNonClientMargins
(
tmp
)
;
}
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
windowElement
-
>
GetAttribute
(
WINDOWTYPE_ATTRIBUTE
attr
)
;
if
(
!
attr
.
IsEmpty
(
)
)
{
mWindow
-
>
SetWindowClass
(
attr
)
;
}
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
windowElement
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
icon
"
)
attr
)
;
if
(
!
attr
.
IsEmpty
(
)
)
{
mWindow
-
>
SetIcon
(
attr
)
;
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
}
windowElement
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
drawtitle
"
)
attr
)
;
mWindow
-
>
SetDrawsTitle
(
attr
.
LowerCaseEqualsLiteral
(
"
true
"
)
)
;
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
windowElement
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
toggletoolbar
"
)
attr
)
;
mWindow
-
>
SetShowsToolbarButton
(
attr
.
LowerCaseEqualsLiteral
(
"
true
"
)
)
;
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
windowElement
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
fullscreenbutton
"
)
attr
)
;
mWindow
-
>
SetShowsFullScreenButton
(
attr
.
LowerCaseEqualsLiteral
(
"
true
"
)
)
;
NS_ENSURE_TRUE_VOID
(
mWindow
)
;
windowElement
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
macanimationtype
"
)
attr
)
;
if
(
attr
.
EqualsLiteral
(
"
document
"
)
)
{
mWindow
-
>
SetWindowAnimationType
(
nsIWidget
:
:
eDocumentWindowAnimation
)
;
}
}
enum
class
ConversionDirection
{
InnerToOuter
OuterToInner
}
;
static
void
ConvertWindowSize
(
nsIAppWindow
*
aWin
const
nsAtom
*
aAttr
ConversionDirection
aDirection
nsAString
&
aInOutString
)
{
MOZ_ASSERT
(
aWin
)
;
MOZ_ASSERT
(
aAttr
=
=
nsGkAtoms
:
:
width
|
|
aAttr
=
=
nsGkAtoms
:
:
height
)
;
nsresult
rv
;
int32_t
size
=
aInOutString
.
ToInteger
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
int32_t
sizeDiff
=
aAttr
=
=
nsGkAtoms
:
:
width
?
aWin
-
>
GetOuterToInnerWidthDifferenceInCSSPixels
(
)
:
aWin
-
>
GetOuterToInnerHeightDifferenceInCSSPixels
(
)
;
if
(
!
sizeDiff
)
{
return
;
}
int32_t
multiplier
=
aDirection
=
=
ConversionDirection
:
:
InnerToOuter
?
1
:
-
1
;
CopyASCIItoUTF16
(
nsPrintfCString
(
"
%
d
"
size
+
multiplier
*
sizeDiff
)
aInOutString
)
;
}
nsresult
AppWindow
:
:
GetPersistentValue
(
const
nsAtom
*
aAttr
nsAString
&
aValue
)
{
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
if
(
!
docShellElement
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
windowElementId
;
docShellElement
-
>
GetId
(
windowElementId
)
;
if
(
windowElementId
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
RefPtr
<
dom
:
:
Document
>
ownerDoc
=
docShellElement
-
>
OwnerDoc
(
)
;
nsIURI
*
docURI
=
ownerDoc
-
>
GetDocumentURI
(
)
;
if
(
!
docURI
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
utf8uri
;
nsresult
rv
=
docURI
-
>
GetSpec
(
utf8uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ConvertUTF8toUTF16
uri
(
utf8uri
)
;
#
ifdef
MOZ_NEW_XULSTORE
nsDependentAtomString
attrString
(
aAttr
)
;
rv
=
XULStore
:
:
GetValue
(
uri
windowElementId
attrString
aValue
)
;
#
else
if
(
!
mLocalStore
)
{
mLocalStore
=
do_GetService
(
"
mozilla
.
org
/
xul
/
xulstore
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mLocalStore
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
}
rv
=
mLocalStore
-
>
GetValue
(
uri
windowElementId
nsDependentAtomString
(
aAttr
)
aValue
)
;
#
endif
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aAttr
=
=
nsGkAtoms
:
:
width
|
|
aAttr
=
=
nsGkAtoms
:
:
height
)
{
ConvertWindowSize
(
this
aAttr
ConversionDirection
:
:
OuterToInner
aValue
)
;
}
return
NS_OK
;
}
nsresult
AppWindow
:
:
SetPersistentValue
(
const
nsAtom
*
aAttr
const
nsAString
&
aValue
)
{
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
if
(
!
docShellElement
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
windowElementId
;
docShellElement
-
>
GetId
(
windowElementId
)
;
if
(
windowElementId
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
RefPtr
<
dom
:
:
Document
>
ownerDoc
=
docShellElement
-
>
OwnerDoc
(
)
;
nsIURI
*
docURI
=
ownerDoc
-
>
GetDocumentURI
(
)
;
if
(
!
docURI
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
utf8uri
;
nsresult
rv
=
docURI
-
>
GetSpec
(
utf8uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
NS_ConvertUTF8toUTF16
uri
(
utf8uri
)
;
nsAutoString
maybeConvertedValue
(
aValue
)
;
if
(
aAttr
=
=
nsGkAtoms
:
:
width
|
|
aAttr
=
=
nsGkAtoms
:
:
height
)
{
ConvertWindowSize
(
this
aAttr
ConversionDirection
:
:
InnerToOuter
maybeConvertedValue
)
;
}
#
ifdef
MOZ_NEW_XULSTORE
nsDependentAtomString
attrString
(
aAttr
)
;
return
XULStore
:
:
SetValue
(
uri
windowElementId
attrString
maybeConvertedValue
)
;
#
else
if
(
!
mLocalStore
)
{
mLocalStore
=
do_GetService
(
"
mozilla
.
org
/
xul
/
xulstore
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mLocalStore
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
}
return
mLocalStore
-
>
SetValue
(
uri
windowElementId
nsDependentAtomString
(
aAttr
)
maybeConvertedValue
)
;
#
endif
}
NS_IMETHODIMP
AppWindow
:
:
SavePersistentAttributes
(
)
{
if
(
!
mDocShell
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
if
(
!
docShellElement
)
return
NS_ERROR_FAILURE
;
nsAutoString
persistString
;
docShellElement
-
>
GetAttribute
(
PERSIST_ATTRIBUTE
persistString
)
;
if
(
persistString
.
IsEmpty
(
)
)
{
mPersistentAttributesDirty
=
0
;
return
NS_OK
;
}
bool
isFullscreen
=
false
;
if
(
nsPIDOMWindowOuter
*
domWindow
=
mDocShell
-
>
GetWindow
(
)
)
{
isFullscreen
=
domWindow
-
>
GetFullScreen
(
)
;
}
LayoutDeviceIntRect
rect
;
bool
gotRestoredBounds
=
NS_SUCCEEDED
(
mWindow
-
>
GetRestoredBounds
(
rect
)
)
;
CSSToLayoutDeviceScale
sizeScale
=
mWindow
-
>
GetDefaultScale
(
)
;
DesktopToLayoutDeviceScale
posScale
=
mWindow
-
>
GetDesktopToDeviceScale
(
)
;
nsCOMPtr
<
nsIBaseWindow
>
parent
(
do_QueryReferent
(
mParentWindow
)
)
;
if
(
parent
&
&
gotRestoredBounds
)
{
int32_t
parentX
parentY
;
if
(
NS_SUCCEEDED
(
parent
-
>
GetPosition
(
&
parentX
&
parentY
)
)
)
{
rect
.
MoveBy
(
-
parentX
-
parentY
)
;
}
}
nsAutoString
sizeString
;
bool
shouldPersist
=
!
isFullscreen
;
ErrorResult
rv
;
if
(
(
mPersistentAttributesDirty
&
PAD_POSITION
)
&
&
gotRestoredBounds
)
{
if
(
persistString
.
Find
(
"
screenX
"
)
>
=
0
)
{
sizeString
.
Truncate
(
)
;
sizeString
.
AppendInt
(
NSToIntRound
(
rect
.
X
(
)
/
posScale
.
scale
)
)
;
docShellElement
-
>
SetAttribute
(
SCREENX_ATTRIBUTE
sizeString
rv
)
;
if
(
shouldPersist
)
{
Unused
<
<
SetPersistentValue
(
nsGkAtoms
:
:
screenX
sizeString
)
;
}
}
if
(
persistString
.
Find
(
"
screenY
"
)
>
=
0
)
{
sizeString
.
Truncate
(
)
;
sizeString
.
AppendInt
(
NSToIntRound
(
rect
.
Y
(
)
/
posScale
.
scale
)
)
;
docShellElement
-
>
SetAttribute
(
SCREENY_ATTRIBUTE
sizeString
rv
)
;
if
(
shouldPersist
)
{
Unused
<
<
SetPersistentValue
(
nsGkAtoms
:
:
screenY
sizeString
)
;
}
}
}
if
(
(
mPersistentAttributesDirty
&
PAD_SIZE
)
&
&
gotRestoredBounds
)
{
LayoutDeviceIntRect
innerRect
=
rect
-
GetOuterToInnerSizeDifference
(
mWindow
)
;
if
(
persistString
.
Find
(
"
width
"
)
>
=
0
)
{
sizeString
.
Truncate
(
)
;
sizeString
.
AppendInt
(
NSToIntRound
(
innerRect
.
Width
(
)
/
sizeScale
.
scale
)
)
;
docShellElement
-
>
SetAttribute
(
WIDTH_ATTRIBUTE
sizeString
rv
)
;
if
(
shouldPersist
)
{
Unused
<
<
SetPersistentValue
(
nsGkAtoms
:
:
width
sizeString
)
;
}
}
if
(
persistString
.
Find
(
"
height
"
)
>
=
0
)
{
sizeString
.
Truncate
(
)
;
sizeString
.
AppendInt
(
NSToIntRound
(
innerRect
.
Height
(
)
/
sizeScale
.
scale
)
)
;
docShellElement
-
>
SetAttribute
(
HEIGHT_ATTRIBUTE
sizeString
rv
)
;
if
(
shouldPersist
)
{
Unused
<
<
SetPersistentValue
(
nsGkAtoms
:
:
height
sizeString
)
;
}
}
}
if
(
mPersistentAttributesDirty
&
PAD_MISC
)
{
nsSizeMode
sizeMode
=
mWindow
-
>
SizeMode
(
)
;
if
(
sizeMode
!
=
nsSizeMode_Minimized
)
{
if
(
sizeMode
=
=
nsSizeMode_Maximized
)
sizeString
.
Assign
(
SIZEMODE_MAXIMIZED
)
;
else
if
(
sizeMode
=
=
nsSizeMode_Fullscreen
)
sizeString
.
Assign
(
SIZEMODE_FULLSCREEN
)
;
else
sizeString
.
Assign
(
SIZEMODE_NORMAL
)
;
docShellElement
-
>
SetAttribute
(
MODE_ATTRIBUTE
sizeString
rv
)
;
if
(
shouldPersist
&
&
persistString
.
Find
(
"
sizemode
"
)
>
=
0
)
{
Unused
<
<
SetPersistentValue
(
nsGkAtoms
:
:
sizemode
sizeString
)
;
}
}
bool
tiled
=
mWindow
-
>
IsTiled
(
)
;
if
(
tiled
)
{
sizeString
.
Assign
(
NS_LITERAL_STRING
(
"
true
"
)
)
;
}
else
{
sizeString
.
Assign
(
NS_LITERAL_STRING
(
"
false
"
)
)
;
}
docShellElement
-
>
SetAttribute
(
TILED_ATTRIBUTE
sizeString
rv
)
;
if
(
persistString
.
Find
(
"
zlevel
"
)
>
=
0
)
{
uint32_t
zLevel
;
nsCOMPtr
<
nsIWindowMediator
>
mediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
mediator
)
{
mediator
-
>
GetZLevel
(
this
&
zLevel
)
;
sizeString
.
Truncate
(
)
;
sizeString
.
AppendInt
(
zLevel
)
;
docShellElement
-
>
SetAttribute
(
ZLEVEL_ATTRIBUTE
sizeString
rv
)
;
if
(
shouldPersist
)
{
Unused
<
<
SetPersistentValue
(
nsGkAtoms
:
:
zlevel
sizeString
)
;
}
}
}
}
mPersistentAttributesDirty
=
0
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetWindowDOMWindow
(
mozIDOMWindowProxy
*
*
aDOMWindow
)
{
NS_ENSURE_STATE
(
mDocShell
)
;
if
(
!
mDOMWindow
)
mDOMWindow
=
mDocShell
-
>
GetWindow
(
)
;
NS_ENSURE_TRUE
(
mDOMWindow
NS_ERROR_FAILURE
)
;
*
aDOMWindow
=
mDOMWindow
;
NS_ADDREF
(
*
aDOMWindow
)
;
return
NS_OK
;
}
dom
:
:
Element
*
AppWindow
:
:
GetWindowDOMElement
(
)
const
{
NS_ENSURE_TRUE
(
mDocShell
nullptr
)
;
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
NS_ENSURE_TRUE
(
cv
nullptr
)
;
const
dom
:
:
Document
*
document
=
cv
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
document
nullptr
)
;
return
document
-
>
GetRootElement
(
)
;
}
nsresult
AppWindow
:
:
ContentShellAdded
(
nsIDocShellTreeItem
*
aContentShell
bool
aPrimary
)
{
if
(
aPrimary
)
{
NS_ENSURE_SUCCESS
(
EnsurePrimaryContentTreeOwner
(
)
NS_ERROR_FAILURE
)
;
aContentShell
-
>
SetTreeOwner
(
mPrimaryContentTreeOwner
)
;
mPrimaryContentShell
=
aContentShell
;
mPrimaryBrowserParent
=
nullptr
;
}
else
{
NS_ENSURE_SUCCESS
(
EnsureContentTreeOwner
(
)
NS_ERROR_FAILURE
)
;
aContentShell
-
>
SetTreeOwner
(
mContentTreeOwner
)
;
if
(
mPrimaryContentShell
=
=
aContentShell
)
mPrimaryContentShell
=
nullptr
;
}
return
NS_OK
;
}
nsresult
AppWindow
:
:
ContentShellRemoved
(
nsIDocShellTreeItem
*
aContentShell
)
{
if
(
mPrimaryContentShell
=
=
aContentShell
)
{
mPrimaryContentShell
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetPrimaryContentSize
(
int32_t
*
aWidth
int32_t
*
aHeight
)
{
if
(
mPrimaryBrowserParent
)
{
return
GetPrimaryRemoteTabSize
(
aWidth
aHeight
)
;
}
else
if
(
mPrimaryContentShell
)
{
return
GetPrimaryContentShellSize
(
aWidth
aHeight
)
;
}
return
NS_ERROR_UNEXPECTED
;
}
nsresult
AppWindow
:
:
GetPrimaryRemoteTabSize
(
int32_t
*
aWidth
int32_t
*
aHeight
)
{
BrowserHost
*
host
=
BrowserHost
:
:
GetFrom
(
mPrimaryBrowserParent
.
get
(
)
)
;
RefPtr
<
dom
:
:
Element
>
element
=
host
-
>
GetOwnerElement
(
)
;
NS_ENSURE_STATE
(
element
)
;
*
aWidth
=
element
-
>
ClientWidth
(
)
;
*
aHeight
=
element
-
>
ClientHeight
(
)
;
return
NS_OK
;
}
nsresult
AppWindow
:
:
GetPrimaryContentShellSize
(
int32_t
*
aWidth
int32_t
*
aHeight
)
{
NS_ENSURE_STATE
(
mPrimaryContentShell
)
;
nsCOMPtr
<
nsIBaseWindow
>
shellWindow
(
do_QueryInterface
(
mPrimaryContentShell
)
)
;
NS_ENSURE_STATE
(
shellWindow
)
;
int32_t
devicePixelWidth
devicePixelHeight
;
double
shellScale
=
1
.
0
;
shellWindow
-
>
GetSize
(
&
devicePixelWidth
&
devicePixelHeight
)
;
shellWindow
-
>
GetUnscaledDevicePixelsPerCSSPixel
(
&
shellScale
)
;
*
aWidth
=
NSToIntRound
(
devicePixelWidth
/
shellScale
)
;
*
aHeight
=
NSToIntRound
(
devicePixelHeight
/
shellScale
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetPrimaryContentSize
(
int32_t
aWidth
int32_t
aHeight
)
{
if
(
mPrimaryBrowserParent
)
{
return
SetPrimaryRemoteTabSize
(
aWidth
aHeight
)
;
}
else
if
(
mPrimaryContentShell
)
{
return
SizeShellTo
(
mPrimaryContentShell
aWidth
aHeight
)
;
}
return
NS_ERROR_UNEXPECTED
;
}
nsresult
AppWindow
:
:
SetPrimaryRemoteTabSize
(
int32_t
aWidth
int32_t
aHeight
)
{
int32_t
shellWidth
shellHeight
;
GetPrimaryRemoteTabSize
(
&
shellWidth
&
shellHeight
)
;
double
scale
=
1
.
0
;
GetUnscaledDevicePixelsPerCSSPixel
(
&
scale
)
;
SizeShellToWithLimit
(
aWidth
aHeight
shellWidth
*
scale
shellHeight
*
scale
)
;
return
NS_OK
;
}
nsresult
AppWindow
:
:
GetRootShellSize
(
int32_t
*
aWidth
int32_t
*
aHeight
)
{
nsCOMPtr
<
nsIBaseWindow
>
shellAsWin
=
do_QueryInterface
(
mDocShell
)
;
NS_ENSURE_TRUE
(
shellAsWin
NS_ERROR_FAILURE
)
;
return
shellAsWin
-
>
GetSize
(
aWidth
aHeight
)
;
}
nsresult
AppWindow
:
:
SetRootShellSize
(
int32_t
aWidth
int32_t
aHeight
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellAsItem
=
mDocShell
;
return
SizeShellTo
(
docShellAsItem
aWidth
aHeight
)
;
}
NS_IMETHODIMP
AppWindow
:
:
SizeShellTo
(
nsIDocShellTreeItem
*
aShellItem
int32_t
aCX
int32_t
aCY
)
{
nsCOMPtr
<
nsIBaseWindow
>
shellAsWin
(
do_QueryInterface
(
aShellItem
)
)
;
NS_ENSURE_TRUE
(
shellAsWin
NS_ERROR_FAILURE
)
;
int32_t
width
=
0
;
int32_t
height
=
0
;
shellAsWin
-
>
GetSize
(
&
width
&
height
)
;
SizeShellToWithLimit
(
aCX
aCY
width
height
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
ExitModalLoop
(
nsresult
aStatus
)
{
if
(
mContinueModalLoop
)
EnableParent
(
true
)
;
mContinueModalLoop
=
false
;
mModalStatus
=
aStatus
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
CreateNewWindow
(
int32_t
aChromeFlags
nsIRemoteTab
*
aOpeningTab
mozIDOMWindowProxy
*
aOpener
uint64_t
aNextRemoteTabId
nsIAppWindow
*
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
if
(
aChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
)
{
MOZ_RELEASE_ASSERT
(
aNextRemoteTabId
=
=
0
"
Unexpected
next
remote
tab
ID
should
never
have
a
non
-
zero
"
"
aNextRemoteTabId
when
creating
a
new
chrome
window
"
)
;
return
CreateNewChromeWindow
(
aChromeFlags
aOpeningTab
aOpener
_retval
)
;
}
return
CreateNewContentWindow
(
aChromeFlags
aOpeningTab
aOpener
aNextRemoteTabId
_retval
)
;
}
NS_IMETHODIMP
AppWindow
:
:
CreateNewChromeWindow
(
int32_t
aChromeFlags
nsIRemoteTab
*
aOpeningTab
mozIDOMWindowProxy
*
aOpener
nsIAppWindow
*
*
_retval
)
{
nsCOMPtr
<
nsIAppShellService
>
appShell
(
do_GetService
(
NS_APPSHELLSERVICE_CONTRACTID
)
)
;
NS_ENSURE_TRUE
(
appShell
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIAppWindow
>
newWindow
;
appShell
-
>
CreateTopLevelWindow
(
this
nullptr
aChromeFlags
nsIAppShellService
:
:
SIZE_TO_CONTENT
nsIAppShellService
:
:
SIZE_TO_CONTENT
aOpeningTab
aOpener
getter_AddRefs
(
newWindow
)
)
;
NS_ENSURE_TRUE
(
newWindow
NS_ERROR_FAILURE
)
;
*
_retval
=
newWindow
;
NS_ADDREF
(
*
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
CreateNewContentWindow
(
int32_t
aChromeFlags
nsIRemoteTab
*
aOpeningTab
mozIDOMWindowProxy
*
aOpener
uint64_t
aNextRemoteTabId
nsIAppWindow
*
*
_retval
)
{
nsCOMPtr
<
nsIAppShellService
>
appShell
(
do_GetService
(
NS_APPSHELLSERVICE_CONTRACTID
)
)
;
NS_ENSURE_TRUE
(
appShell
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsAutoCString
urlStr
;
urlStr
.
AssignLiteral
(
BROWSER_CHROME_URL_QUOTED
)
;
nsCOMPtr
<
nsIIOService
>
service
(
do_GetService
(
NS_IOSERVICE_CONTRACTID
)
)
;
if
(
service
)
{
service
-
>
NewURI
(
urlStr
nullptr
nullptr
getter_AddRefs
(
uri
)
)
;
}
NS_ENSURE_TRUE
(
uri
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIAppWindow
>
newWindow
;
{
AutoNoJSAPI
nojsapi
;
appShell
-
>
CreateTopLevelWindow
(
this
uri
aChromeFlags
615
480
aOpeningTab
nullptr
getter_AddRefs
(
newWindow
)
)
;
NS_ENSURE_TRUE
(
newWindow
NS_ERROR_FAILURE
)
;
}
AppWindow
*
appWin
=
static_cast
<
AppWindow
*
>
(
static_cast
<
nsIAppWindow
*
>
(
newWindow
)
)
;
if
(
aNextRemoteTabId
)
{
appWin
-
>
mNextRemoteTabId
=
aNextRemoteTabId
;
}
if
(
aOpener
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
;
appWin
-
>
GetDocShell
(
getter_AddRefs
(
docShell
)
)
;
MOZ_ASSERT
(
docShell
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
docShell
-
>
GetWindow
(
)
;
MOZ_ASSERT
(
window
)
;
window
-
>
SetOpenerForInitialContentBrowser
(
nsPIDOMWindowOuter
:
:
From
(
aOpener
)
-
>
GetBrowsingContext
(
)
)
;
}
appWin
-
>
LockUntilChromeLoad
(
)
;
{
AutoNoJSAPI
nojsapi
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
!
appWin
-
>
IsLocked
(
)
;
}
)
;
}
NS_ENSURE_STATE
(
appWin
-
>
mPrimaryContentShell
|
|
appWin
-
>
mPrimaryBrowserParent
)
;
MOZ_ASSERT_IF
(
appWin
-
>
mPrimaryContentShell
aNextRemoteTabId
=
=
0
)
;
*
_retval
=
newWindow
;
NS_ADDREF
(
*
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
GetHasPrimaryContent
(
bool
*
aResult
)
{
*
aResult
=
mPrimaryBrowserParent
|
|
mPrimaryContentShell
;
return
NS_OK
;
}
void
AppWindow
:
:
EnableParent
(
bool
aEnable
)
{
nsCOMPtr
<
nsIBaseWindow
>
parentWindow
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
parentWindow
=
do_QueryReferent
(
mParentWindow
)
;
if
(
parentWindow
)
parentWindow
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
if
(
parentWidget
)
parentWidget
-
>
Enable
(
aEnable
)
;
}
bool
AppWindow
:
:
ConstrainToZLevel
(
bool
aImmediate
nsWindowZ
*
aPlacement
nsIWidget
*
aReqBelow
nsIWidget
*
*
aActualBelow
)
{
#
if
0
nsCOMPtr
<
nsIBaseWindow
>
parentWindow
=
do_QueryReferent
(
mParentWindow
)
;
if
(
parentWindow
)
return
false
;
#
endif
nsCOMPtr
<
nsIWindowMediator
>
mediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
!
mediator
)
return
false
;
bool
altered
;
uint32_t
position
newPosition
zLevel
;
nsIAppWindow
*
us
=
this
;
altered
=
false
;
mediator
-
>
GetZLevel
(
this
&
zLevel
)
;
position
=
nsIWindowMediator
:
:
zLevelTop
;
if
(
*
aPlacement
=
=
nsWindowZBottom
|
|
zLevel
=
=
nsIAppWindow
:
:
lowestZ
)
position
=
nsIWindowMediator
:
:
zLevelBottom
;
else
if
(
*
aPlacement
=
=
nsWindowZRelative
)
position
=
nsIWindowMediator
:
:
zLevelBelow
;
if
(
NS_SUCCEEDED
(
mediator
-
>
CalculateZPosition
(
us
position
aReqBelow
&
newPosition
aActualBelow
&
altered
)
)
)
{
if
(
altered
&
&
(
position
=
=
nsIWindowMediator
:
:
zLevelTop
|
|
(
position
=
=
nsIWindowMediator
:
:
zLevelBelow
&
&
aReqBelow
=
=
0
)
)
)
PlaceWindowLayersBehind
(
zLevel
+
1
nsIAppWindow
:
:
highestZ
0
)
;
if
(
*
aPlacement
!
=
nsWindowZBottom
&
&
position
=
=
nsIWindowMediator
:
:
zLevelBottom
)
altered
=
true
;
if
(
altered
|
|
aImmediate
)
{
if
(
newPosition
=
=
nsIWindowMediator
:
:
zLevelTop
)
*
aPlacement
=
nsWindowZTop
;
else
if
(
newPosition
=
=
nsIWindowMediator
:
:
zLevelBottom
)
*
aPlacement
=
nsWindowZBottom
;
else
*
aPlacement
=
nsWindowZRelative
;
if
(
aImmediate
)
{
nsCOMPtr
<
nsIBaseWindow
>
ourBase
=
do_QueryObject
(
this
)
;
if
(
ourBase
)
{
nsCOMPtr
<
nsIWidget
>
ourWidget
;
ourBase
-
>
GetMainWidget
(
getter_AddRefs
(
ourWidget
)
)
;
ourWidget
-
>
PlaceBehind
(
*
aPlacement
=
=
nsWindowZBottom
?
eZPlacementBottom
:
eZPlacementBelow
*
aActualBelow
false
)
;
}
}
}
nsCOMPtr
<
nsIAppWindow
>
windowAbove
;
if
(
newPosition
=
=
nsIWindowMediator
:
:
zLevelBelow
&
&
*
aActualBelow
)
{
windowAbove
=
(
*
aActualBelow
)
-
>
GetWidgetListener
(
)
-
>
GetAppWindow
(
)
;
}
mediator
-
>
SetZPosition
(
us
newPosition
windowAbove
)
;
}
return
altered
;
}
void
AppWindow
:
:
PlaceWindowLayersBehind
(
uint32_t
aLowLevel
uint32_t
aHighLevel
nsIAppWindow
*
aBehind
)
{
nsCOMPtr
<
nsIWindowMediator
>
mediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
!
mediator
)
return
;
nsCOMPtr
<
nsISimpleEnumerator
>
windowEnumerator
;
mediator
-
>
GetZOrderAppWindowEnumerator
(
0
true
getter_AddRefs
(
windowEnumerator
)
)
;
if
(
!
windowEnumerator
)
return
;
nsCOMPtr
<
nsIWidget
>
previousHighWidget
;
if
(
aBehind
)
{
nsCOMPtr
<
nsIBaseWindow
>
highBase
(
do_QueryInterface
(
aBehind
)
)
;
if
(
highBase
)
highBase
-
>
GetMainWidget
(
getter_AddRefs
(
previousHighWidget
)
)
;
}
bool
more
;
while
(
NS_SUCCEEDED
(
windowEnumerator
-
>
HasMoreElements
(
&
more
)
)
&
&
more
)
{
uint32_t
nextZ
;
nsCOMPtr
<
nsISupports
>
nextWindow
;
windowEnumerator
-
>
GetNext
(
getter_AddRefs
(
nextWindow
)
)
;
nsCOMPtr
<
nsIAppWindow
>
nextAppWindow
(
do_QueryInterface
(
nextWindow
)
)
;
nextAppWindow
-
>
GetZLevel
(
&
nextZ
)
;
if
(
nextZ
<
aLowLevel
)
break
;
nsCOMPtr
<
nsIBaseWindow
>
nextBase
(
do_QueryInterface
(
nextAppWindow
)
)
;
if
(
nextBase
)
{
nsCOMPtr
<
nsIWidget
>
nextWidget
;
nextBase
-
>
GetMainWidget
(
getter_AddRefs
(
nextWidget
)
)
;
if
(
nextZ
<
=
aHighLevel
)
nextWidget
-
>
PlaceBehind
(
eZPlacementBelow
previousHighWidget
false
)
;
previousHighWidget
=
nextWidget
;
}
}
}
void
AppWindow
:
:
SetContentScrollbarVisibility
(
bool
aVisible
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
contentWin
(
do_GetInterface
(
mPrimaryContentShell
)
)
;
if
(
!
contentWin
)
{
return
;
}
nsContentUtils
:
:
SetScrollbarsVisibility
(
contentWin
-
>
GetDocShell
(
)
aVisible
)
;
}
bool
AppWindow
:
:
GetContentScrollbarVisibility
(
)
{
nsCOMPtr
<
nsIScrollable
>
scroller
(
do_QueryInterface
(
mPrimaryContentShell
)
)
;
if
(
scroller
)
{
int32_t
prefValue
;
scroller
-
>
GetDefaultScrollbarPreferences
(
nsIScrollable
:
:
ScrollOrientation_Y
&
prefValue
)
;
if
(
prefValue
=
=
nsIScrollable
:
:
Scrollbar_Never
)
scroller
-
>
GetDefaultScrollbarPreferences
(
nsIScrollable
:
:
ScrollOrientation_X
&
prefValue
)
;
if
(
prefValue
=
=
nsIScrollable
:
:
Scrollbar_Never
)
return
false
;
}
return
true
;
}
void
AppWindow
:
:
PersistentAttributesDirty
(
uint32_t
aDirtyFlags
)
{
mPersistentAttributesDirty
|
=
aDirtyFlags
&
mPersistentAttributesMask
;
}
void
AppWindow
:
:
ApplyChromeFlags
(
)
{
nsCOMPtr
<
dom
:
:
Element
>
window
=
GetWindowDOMElement
(
)
;
if
(
!
window
)
{
return
;
}
if
(
mChromeLoaded
)
{
SetContentScrollbarVisibility
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_SCROLLBARS
?
true
:
false
)
;
}
nsAutoString
newvalue
;
if
(
!
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_MENUBAR
)
)
newvalue
.
AppendLiteral
(
"
menubar
"
)
;
if
(
!
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_TOOLBAR
)
)
newvalue
.
AppendLiteral
(
"
toolbar
"
)
;
if
(
!
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_LOCATIONBAR
)
)
newvalue
.
AppendLiteral
(
"
location
"
)
;
if
(
!
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_PERSONAL_TOOLBAR
)
)
newvalue
.
AppendLiteral
(
"
directories
"
)
;
if
(
!
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_STATUSBAR
)
)
newvalue
.
AppendLiteral
(
"
status
"
)
;
if
(
!
(
mChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_EXTRA
)
)
newvalue
.
AppendLiteral
(
"
extrachrome
"
)
;
IgnoredErrorResult
rv
;
window
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
chromehidden
"
)
newvalue
rv
)
;
}
NS_IMETHODIMP
AppWindow
:
:
BeforeStartLayout
(
)
{
ApplyChromeFlags
(
)
;
LoadPersistentWindowState
(
)
;
SyncAttributesToWidget
(
)
;
if
(
mWindow
)
{
SizeShell
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
LockAspectRatio
(
bool
aShouldLock
)
{
mWindow
-
>
LockAspectRatio
(
aShouldLock
)
;
return
NS_OK
;
}
void
AppWindow
:
:
LoadPersistentWindowState
(
)
{
nsCOMPtr
<
dom
:
:
Element
>
docShellElement
=
GetWindowDOMElement
(
)
;
if
(
!
docShellElement
)
{
return
;
}
nsAutoString
persist
;
docShellElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
persist
persist
)
;
if
(
persist
.
IsEmpty
(
)
)
{
return
;
}
auto
loadValue
=
[
&
]
(
const
nsAtom
*
aAttr
)
{
nsDependentAtomString
attrString
(
aAttr
)
;
if
(
persist
.
Find
(
attrString
)
>
=
0
)
{
nsAutoString
value
;
nsresult
rv
=
GetPersistentValue
(
aAttr
value
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
get
persistent
state
.
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
value
.
IsEmpty
(
)
)
{
IgnoredErrorResult
err
;
docShellElement
-
>
SetAttribute
(
attrString
value
err
)
;
}
}
}
;
loadValue
(
nsGkAtoms
:
:
screenX
)
;
loadValue
(
nsGkAtoms
:
:
screenY
)
;
loadValue
(
nsGkAtoms
:
:
width
)
;
loadValue
(
nsGkAtoms
:
:
height
)
;
loadValue
(
nsGkAtoms
:
:
sizemode
)
;
}
void
AppWindow
:
:
SizeShell
(
)
{
AutoRestore
<
bool
>
sizingShellFromXUL
(
mSizingShellFromXUL
)
;
mSizingShellFromXUL
=
true
;
int32_t
specWidth
=
-
1
specHeight
=
-
1
;
bool
gotSize
=
false
;
nsCOMPtr
<
dom
:
:
Element
>
windowElement
=
GetWindowDOMElement
(
)
;
nsAutoString
windowType
;
if
(
windowElement
)
{
windowElement
-
>
GetAttribute
(
WINDOWTYPE_ATTRIBUTE
windowType
)
;
}
CSSIntSize
windowDiff
=
GetOuterToInnerSizeDifferenceInCSSPixels
(
mWindow
)
;
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
&
&
windowType
.
EqualsLiteral
(
"
navigator
:
browser
"
)
)
{
if
(
mPrimaryContentShell
|
|
mPrimaryBrowserParent
)
{
ForceRoundedDimensions
(
)
;
}
mIgnoreXULSize
=
true
;
mIgnoreXULSizeMode
=
true
;
}
else
if
(
!
mIgnoreXULSize
)
{
gotSize
=
LoadSizeFromXUL
(
specWidth
specHeight
)
;
specWidth
+
=
windowDiff
.
width
;
specHeight
+
=
windowDiff
.
height
;
}
bool
positionSet
=
!
mIgnoreXULPosition
;
nsCOMPtr
<
nsIAppWindow
>
parentWindow
(
do_QueryReferent
(
mParentWindow
)
)
;
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
XP_MACOSX
)
if
(
!
parentWindow
)
positionSet
=
false
;
#
endif
if
(
positionSet
)
{
positionSet
=
LoadPositionFromXUL
(
specWidth
specHeight
)
;
}
if
(
gotSize
)
{
SetSpecifiedSize
(
specWidth
specHeight
)
;
}
if
(
mIntrinsicallySized
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
cv
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellAsItem
=
mDocShell
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
docShellAsItem
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
if
(
treeOwner
)
{
int32_t
width
=
0
height
=
0
;
if
(
NS_SUCCEEDED
(
cv
-
>
GetContentSize
(
&
width
&
height
)
)
)
{
treeOwner
-
>
SizeShellTo
(
docShellAsItem
width
height
)
;
specWidth
=
width
+
windowDiff
.
width
;
specHeight
=
height
+
windowDiff
.
height
;
}
}
}
}
if
(
positionSet
)
{
LoadPositionFromXUL
(
specWidth
specHeight
)
;
}
UpdateWindowStateFromMiscXULAttributes
(
)
;
if
(
mChromeLoaded
&
&
mCenterAfterLoad
&
&
!
positionSet
&
&
mWindow
-
>
SizeMode
(
)
=
=
nsSizeMode_Normal
)
{
Center
(
parentWindow
parentWindow
?
false
:
true
false
)
;
}
}
NS_IMETHODIMP
AppWindow
:
:
GetXULBrowserWindow
(
nsIXULBrowserWindow
*
*
aXULBrowserWindow
)
{
NS_IF_ADDREF
(
*
aXULBrowserWindow
=
mXULBrowserWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
SetXULBrowserWindow
(
nsIXULBrowserWindow
*
aXULBrowserWindow
)
{
mXULBrowserWindow
=
aXULBrowserWindow
;
return
NS_OK
;
}
void
AppWindow
:
:
SizeShellToWithLimit
(
int32_t
aDesiredWidth
int32_t
aDesiredHeight
int32_t
shellItemWidth
int32_t
shellItemHeight
)
{
int32_t
widthDelta
=
aDesiredWidth
-
shellItemWidth
;
int32_t
heightDelta
=
aDesiredHeight
-
shellItemHeight
;
if
(
widthDelta
|
|
heightDelta
)
{
int32_t
winWidth
=
0
;
int32_t
winHeight
=
0
;
GetSize
(
&
winWidth
&
winHeight
)
;
winWidth
=
std
:
:
max
(
winWidth
+
widthDelta
aDesiredWidth
)
;
winHeight
=
std
:
:
max
(
winHeight
+
heightDelta
aDesiredHeight
)
;
SetSize
(
winWidth
winHeight
true
)
;
}
}
nsresult
AppWindow
:
:
GetTabCount
(
uint32_t
*
aResult
)
{
if
(
mXULBrowserWindow
)
{
return
mXULBrowserWindow
-
>
GetTabCount
(
aResult
)
;
}
*
aResult
=
0
;
return
NS_OK
;
}
nsresult
AppWindow
:
:
GetNextRemoteTabId
(
uint64_t
*
aNextRemoteTabId
)
{
NS_ENSURE_ARG_POINTER
(
aNextRemoteTabId
)
;
*
aNextRemoteTabId
=
mNextRemoteTabId
;
return
NS_OK
;
}
PresShell
*
AppWindow
:
:
GetPresShell
(
)
{
if
(
!
mDocShell
)
{
return
nullptr
;
}
return
mDocShell
-
>
GetPresShell
(
)
;
}
bool
AppWindow
:
:
WindowMoved
(
nsIWidget
*
aWidget
int32_t
x
int32_t
y
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
pm
-
>
AdjustPopupsOnWindowChange
(
window
)
;
}
if
(
mDocShell
&
&
mDocShell
-
>
GetWindow
(
)
)
{
nsCOMPtr
<
EventTarget
>
eventTarget
=
mDocShell
-
>
GetWindow
(
)
-
>
GetTopWindowRoot
(
)
;
nsContentUtils
:
:
DispatchChromeEvent
(
mDocShell
-
>
GetDocument
(
)
eventTarget
NS_LITERAL_STRING
(
"
MozUpdateWindowPos
"
)
CanBubble
:
:
eNo
Cancelable
:
:
eNo
nullptr
)
;
}
SetPersistenceTimer
(
PAD_POSITION
)
;
return
false
;
}
bool
AppWindow
:
:
WindowResized
(
nsIWidget
*
aWidget
int32_t
aWidth
int32_t
aHeight
)
{
nsCOMPtr
<
nsIBaseWindow
>
shellAsWin
(
do_QueryInterface
(
mDocShell
)
)
;
if
(
shellAsWin
)
{
shellAsWin
-
>
SetPositionAndSize
(
0
0
aWidth
aHeight
0
)
;
}
if
(
!
IsLocked
(
)
)
SetPersistenceTimer
(
PAD_POSITION
|
PAD_SIZE
|
PAD_MISC
)
;
return
true
;
}
bool
AppWindow
:
:
RequestWindowClose
(
nsIWidget
*
aWidget
)
{
nsCOMPtr
<
nsIAppWindow
>
appWindow
(
this
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
(
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
)
;
nsCOMPtr
<
EventTarget
>
eventTarget
=
do_QueryInterface
(
window
)
;
RefPtr
<
PresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
mozilla
:
:
DebugOnly
<
bool
>
dying
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
mDocShell
-
>
IsBeingDestroyed
(
&
dying
)
)
&
&
dying
"
No
presShell
but
window
is
not
being
destroyed
"
)
;
}
else
if
(
eventTarget
)
{
RefPtr
<
nsPresContext
>
presContext
=
presShell
-
>
GetPresContext
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eClose
nullptr
WidgetMouseEvent
:
:
eReal
)
;
if
(
NS_SUCCEEDED
(
EventDispatcher
:
:
Dispatch
(
eventTarget
presContext
&
event
nullptr
&
status
)
)
&
&
status
=
=
nsEventStatus_eConsumeNoDefault
)
return
false
;
}
Destroy
(
)
;
return
false
;
}
void
AppWindow
:
:
SizeModeChanged
(
nsSizeMode
sizeMode
)
{
if
(
sizeMode
=
=
nsSizeMode_Maximized
|
|
sizeMode
=
=
nsSizeMode_Fullscreen
)
{
uint32_t
zLevel
;
GetZLevel
(
&
zLevel
)
;
if
(
zLevel
>
nsIAppWindow
:
:
normalZ
)
SetZLevel
(
nsIAppWindow
:
:
normalZ
)
;
}
mWindow
-
>
SetSizeMode
(
sizeMode
)
;
SetPersistenceTimer
(
PAD_MISC
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
if
(
ourWindow
)
{
if
(
sizeMode
=
=
nsSizeMode_Fullscreen
)
{
ourWindow
-
>
SetFullScreen
(
true
)
;
}
else
if
(
sizeMode
!
=
nsSizeMode_Minimized
)
{
if
(
ourWindow
-
>
GetFullScreen
(
)
)
{
ourWindow
-
>
SetFullscreenInternal
(
FullscreenReason
:
:
ForForceExitFullscreen
false
)
;
ourWindow
-
>
SetFullScreen
(
false
)
;
}
}
ourWindow
-
>
DispatchCustomEvent
(
NS_LITERAL_STRING
(
"
sizemodechange
"
)
)
;
}
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
GetPresContext
(
)
-
>
SizeModeChanged
(
sizeMode
)
;
}
}
void
AppWindow
:
:
UIResolutionChanged
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
if
(
ourWindow
)
{
ourWindow
-
>
DispatchCustomEvent
(
NS_LITERAL_STRING
(
"
resolutionchange
"
)
)
;
}
}
void
AppWindow
:
:
FullscreenWillChange
(
bool
aInFullscreen
)
{
if
(
mDocShell
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
mDocShell
-
>
GetWindow
(
)
)
{
ourWindow
-
>
FullscreenWillChange
(
aInFullscreen
)
;
}
}
}
void
AppWindow
:
:
FullscreenChanged
(
bool
aInFullscreen
)
{
if
(
mDocShell
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
mDocShell
-
>
GetWindow
(
)
)
{
ourWindow
-
>
FinishFullscreenChange
(
aInFullscreen
)
;
}
}
}
void
AppWindow
:
:
OcclusionStateChanged
(
bool
aIsFullyOccluded
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
if
(
ourWindow
)
{
ourWindow
-
>
DispatchCustomEvent
(
NS_LITERAL_STRING
(
"
occlusionstatechange
"
)
)
;
}
}
void
AppWindow
:
:
OSToolbarButtonPressed
(
)
{
nsCOMPtr
<
nsIAppWindow
>
appWindow
(
this
)
;
uint32_t
chromeMask
=
(
nsIWebBrowserChrome
:
:
CHROME_TOOLBAR
|
nsIWebBrowserChrome
:
:
CHROME_LOCATIONBAR
|
nsIWebBrowserChrome
:
:
CHROME_PERSONAL_TOOLBAR
)
;
nsCOMPtr
<
nsIWebBrowserChrome
>
wbc
(
do_GetInterface
(
appWindow
)
)
;
if
(
!
wbc
)
return
;
uint32_t
chromeFlags
newChromeFlags
=
0
;
wbc
-
>
GetChromeFlags
(
&
chromeFlags
)
;
newChromeFlags
=
chromeFlags
&
chromeMask
;
if
(
!
newChromeFlags
)
chromeFlags
|
=
chromeMask
;
else
chromeFlags
&
=
(
~
newChromeFlags
)
;
wbc
-
>
SetChromeFlags
(
chromeFlags
)
;
}
bool
AppWindow
:
:
ZLevelChanged
(
bool
aImmediate
nsWindowZ
*
aPlacement
nsIWidget
*
aRequestBelow
nsIWidget
*
*
aActualBelow
)
{
if
(
aActualBelow
)
*
aActualBelow
=
nullptr
;
return
ConstrainToZLevel
(
aImmediate
aPlacement
aRequestBelow
aActualBelow
)
;
}
void
AppWindow
:
:
WindowActivated
(
)
{
nsCOMPtr
<
nsIAppWindow
>
appWindow
(
this
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
&
&
window
)
fm
-
>
WindowRaised
(
window
)
;
if
(
mChromeLoaded
)
{
PersistentAttributesDirty
(
PAD_POSITION
|
PAD_SIZE
|
PAD_MISC
)
;
SavePersistentAttributes
(
)
;
}
}
void
AppWindow
:
:
WindowDeactivated
(
)
{
nsCOMPtr
<
nsIAppWindow
>
appWindow
(
this
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
&
&
window
&
&
!
fm
-
>
IsTestMode
(
)
)
fm
-
>
WindowLowered
(
window
)
;
}
#
ifdef
USE_NATIVE_MENUS
static
void
LoadNativeMenus
(
Document
*
aDoc
nsIWidget
*
aParentWindow
)
{
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
return
;
}
nsCOMPtr
<
nsINativeMenuService
>
nms
=
do_GetService
(
"
mozilla
.
org
/
widget
/
nativemenuservice
;
1
"
)
;
if
(
!
nms
)
{
return
;
}
nsCOMPtr
<
nsINodeList
>
menubarElements
=
aDoc
-
>
GetElementsByTagNameNS
(
NS_LITERAL_STRING
(
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
)
NS_LITERAL_STRING
(
"
menubar
"
)
)
;
nsCOMPtr
<
nsINode
>
menubarNode
;
if
(
menubarElements
)
{
menubarNode
=
menubarElements
-
>
Item
(
0
)
;
}
if
(
menubarNode
)
{
nsCOMPtr
<
Element
>
menubarContent
(
do_QueryInterface
(
menubarNode
)
)
;
nms
-
>
CreateNativeMenuBar
(
aParentWindow
menubarContent
)
;
}
else
{
nms
-
>
CreateNativeMenuBar
(
aParentWindow
nullptr
)
;
}
}
#
endif
class
AppWindowTimerCallback
final
:
public
nsITimerCallback
public
nsINamed
{
public
:
explicit
AppWindowTimerCallback
(
AppWindow
*
aWindow
)
:
mWindow
(
aWindow
)
{
}
NS_DECL_THREADSAFE_ISUPPORTS
NS_IMETHOD
Notify
(
nsITimer
*
aTimer
)
override
{
mWindow
-
>
FirePersistenceTimer
(
)
;
return
NS_OK
;
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
AppWindowTimerCallback
"
)
;
return
NS_OK
;
}
private
:
~
AppWindowTimerCallback
(
)
{
}
RefPtr
<
AppWindow
>
mWindow
;
}
;
NS_IMPL_ISUPPORTS
(
AppWindowTimerCallback
nsITimerCallback
nsINamed
)
void
AppWindow
:
:
SetPersistenceTimer
(
uint32_t
aDirtyFlags
)
{
MutexAutoLock
lock
(
mSPTimerLock
)
;
if
(
!
mSPTimer
)
{
mSPTimer
=
NS_NewTimer
(
)
;
if
(
!
mSPTimer
)
{
NS_WARNING
(
"
Couldn
'
t
create
mozilla
.
org
/
timer
;
1
instance
?
"
)
;
return
;
}
}
RefPtr
<
AppWindowTimerCallback
>
callback
=
new
AppWindowTimerCallback
(
this
)
;
mSPTimer
-
>
InitWithCallback
(
callback
SIZE_PERSISTENCE_TIMEOUT
nsITimer
:
:
TYPE_ONE_SHOT
)
;
PersistentAttributesDirty
(
aDirtyFlags
)
;
}
void
AppWindow
:
:
FirePersistenceTimer
(
)
{
MutexAutoLock
lock
(
mSPTimerLock
)
;
SavePersistentAttributes
(
)
;
}
NS_IMETHODIMP
AppWindow
:
:
OnProgressChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
aRequest
int32_t
aCurSelfProgress
int32_t
aMaxSelfProgress
int32_t
aCurTotalProgress
int32_t
aMaxTotalProgress
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
OnStateChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
aRequest
uint32_t
aStateFlags
nsresult
aStatus
)
{
if
(
!
(
aStateFlags
&
nsIWebProgressListener
:
:
STATE_STOP
)
|
|
!
(
aStateFlags
&
nsIWebProgressListener
:
:
STATE_IS_NETWORK
)
)
{
return
NS_OK
;
}
if
(
mChromeLoaded
)
return
NS_OK
;
nsCOMPtr
<
mozIDOMWindowProxy
>
eventWin
;
aProgress
-
>
GetDOMWindow
(
getter_AddRefs
(
eventWin
)
)
;
auto
*
eventPWin
=
nsPIDOMWindowOuter
:
:
From
(
eventWin
)
;
if
(
eventPWin
)
{
nsPIDOMWindowOuter
*
rootPWin
=
eventPWin
-
>
GetPrivateRoot
(
)
;
if
(
eventPWin
!
=
rootPWin
)
return
NS_OK
;
}
mChromeLoaded
=
true
;
mLockedUntilChromeLoad
=
false
;
#
ifdef
USE_NATIVE_MENUS
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
cv
)
{
RefPtr
<
Document
>
menubarDoc
=
cv
-
>
GetDocument
(
)
;
if
(
menubarDoc
)
LoadNativeMenus
(
menubarDoc
mWindow
)
;
}
#
endif
OnChromeLoaded
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
OnLocationChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
aRequest
nsIURI
*
aURI
uint32_t
aFlags
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
OnStatusChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsresult
aStatus
const
char16_t
*
aMessage
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
OnSecurityChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aState
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AppWindow
:
:
OnContentBlockingEvent
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aEvent
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
bool
AppWindow
:
:
ExecuteCloseHandler
(
)
{
nsCOMPtr
<
nsIAppWindow
>
kungFuDeathGrip
(
this
)
;
nsCOMPtr
<
EventTarget
>
eventTarget
;
if
(
mDocShell
)
{
eventTarget
=
do_QueryInterface
(
mDocShell
-
>
GetWindow
(
)
)
;
}
if
(
eventTarget
)
{
nsCOMPtr
<
nsIContentViewer
>
contentViewer
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
contentViewer
)
)
;
if
(
contentViewer
)
{
RefPtr
<
nsPresContext
>
presContext
=
contentViewer
-
>
GetPresContext
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eClose
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsresult
rv
=
EventDispatcher
:
:
Dispatch
(
eventTarget
presContext
&
event
nullptr
&
status
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
status
=
=
nsEventStatus_eConsumeNoDefault
)
return
true
;
}
}
return
false
;
}
void
AppWindow
:
:
ConstrainToOpenerScreen
(
int32_t
*
aX
int32_t
*
aY
)
{
if
(
mOpenerScreenRect
.
IsEmpty
(
)
)
{
*
aX
=
*
aY
=
0
;
return
;
}
int32_t
left
top
width
height
;
nsCOMPtr
<
nsIScreenManager
>
screenmgr
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
if
(
screenmgr
)
{
nsCOMPtr
<
nsIScreen
>
screen
;
screenmgr
-
>
ScreenForRect
(
mOpenerScreenRect
.
X
(
)
mOpenerScreenRect
.
Y
(
)
mOpenerScreenRect
.
Width
(
)
mOpenerScreenRect
.
Height
(
)
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
screen
-
>
GetAvailRectDisplayPix
(
&
left
&
top
&
width
&
height
)
;
if
(
*
aX
<
left
|
|
*
aX
>
left
+
width
)
{
*
aX
=
left
;
}
if
(
*
aY
<
top
|
|
*
aY
>
top
+
height
)
{
*
aY
=
top
;
}
}
}
}
nsIAppWindow
*
AppWindow
:
:
WidgetListenerDelegate
:
:
GetAppWindow
(
)
{
return
mAppWindow
-
>
GetAppWindow
(
)
;
}
PresShell
*
AppWindow
:
:
WidgetListenerDelegate
:
:
GetPresShell
(
)
{
return
mAppWindow
-
>
GetPresShell
(
)
;
}
bool
AppWindow
:
:
WidgetListenerDelegate
:
:
WindowMoved
(
nsIWidget
*
aWidget
int32_t
aX
int32_t
aY
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
return
holder
-
>
WindowMoved
(
aWidget
aX
aY
)
;
}
bool
AppWindow
:
:
WidgetListenerDelegate
:
:
WindowResized
(
nsIWidget
*
aWidget
int32_t
aWidth
int32_t
aHeight
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
return
holder
-
>
WindowResized
(
aWidget
aWidth
aHeight
)
;
}
bool
AppWindow
:
:
WidgetListenerDelegate
:
:
RequestWindowClose
(
nsIWidget
*
aWidget
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
return
holder
-
>
RequestWindowClose
(
aWidget
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
SizeModeChanged
(
nsSizeMode
aSizeMode
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
SizeModeChanged
(
aSizeMode
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
UIResolutionChanged
(
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
UIResolutionChanged
(
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
FullscreenWillChange
(
bool
aInFullscreen
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
FullscreenWillChange
(
aInFullscreen
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
FullscreenChanged
(
bool
aInFullscreen
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
FullscreenChanged
(
aInFullscreen
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
OcclusionStateChanged
(
bool
aIsFullyOccluded
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
OcclusionStateChanged
(
aIsFullyOccluded
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
OSToolbarButtonPressed
(
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
OSToolbarButtonPressed
(
)
;
}
bool
AppWindow
:
:
WidgetListenerDelegate
:
:
ZLevelChanged
(
bool
aImmediate
nsWindowZ
*
aPlacement
nsIWidget
*
aRequestBelow
nsIWidget
*
*
aActualBelow
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
return
holder
-
>
ZLevelChanged
(
aImmediate
aPlacement
aRequestBelow
aActualBelow
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
WindowActivated
(
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
WindowActivated
(
)
;
}
void
AppWindow
:
:
WidgetListenerDelegate
:
:
WindowDeactivated
(
)
{
RefPtr
<
AppWindow
>
holder
=
mAppWindow
;
holder
-
>
WindowDeactivated
(
)
;
}
}
