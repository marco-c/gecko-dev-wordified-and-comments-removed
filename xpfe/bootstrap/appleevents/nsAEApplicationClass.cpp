#
include
<
Sound
.
h
>
#
include
<
Scrap
.
h
>
#
include
"
nsAEUtils
.
h
"
#
include
"
nsAETokens
.
h
"
#
include
"
nsAECoreClass
.
h
"
#
include
"
nsAEDocumentClass
.
h
"
#
include
"
nsAEWindowClass
.
h
"
#
include
"
nsAEApplicationClass
.
h
"
#
include
"
nsINativeAppSupport
.
h
"
#
include
"
nsCommandLineServiceMac
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIAppStartup
.
h
"
#
include
"
nsXPFEComponentsCID
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsAppRunner
.
h
"
AEApplicationClass
:
:
AEApplicationClass
(
)
:
AEGenericClass
(
cApplication
typeNull
)
{
}
AEApplicationClass
:
:
~
AEApplicationClass
(
)
{
}
#
pragma
mark
-
void
AEApplicationClass
:
:
GetProperty
(
DescType
desiredClass
const
AEDesc
*
containerToken
DescType
containerClass
DescType
keyForm
const
AEDesc
*
keyData
AEDesc
*
resultToken
)
{
OSErr
err
;
CoreTokenRecord
token
;
DescType
requestedProperty
=
*
*
(
DescType
*
*
)
keyData
-
>
dataHandle
;
token
.
dispatchClass
=
GetClass
(
)
;
token
.
objectClass
=
GetClass
(
)
;
token
.
propertyCode
=
requestedProperty
;
if
(
CanGetProperty
(
requestedProperty
)
|
|
CanSetProperty
(
requestedProperty
)
)
{
err
=
AECreateDesc
(
cProperty
(
Ptr
)
&
token
sizeof
(
CoreTokenRecord
)
resultToken
)
;
ThrowIfOSErr
(
err
)
;
}
else
{
ThrowIfOSErr
(
errAEEventNotHandled
)
;
}
}
void
AEApplicationClass
:
:
GetItemFromContainer
(
DescType
desiredClass
const
AEDesc
*
containerToken
DescType
containerClass
DescType
keyForm
const
AEDesc
*
keyData
AEDesc
*
resultToken
)
{
ThrowIfOSErr
(
errAEEventNotHandled
)
;
}
#
pragma
mark
-
void
AEApplicationClass
:
:
HandleClose
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
OSErr
err
=
noErr
;
StAEDesc
saving
;
StAEDesc
savingIn
;
err
=
AEGetParamDesc
(
appleEvent
keyAESaveOptions
typeWildCard
&
saving
)
;
if
(
err
!
=
errAEDescNotFound
)
ThrowIfOSErr
(
err
)
;
err
=
AEGetParamDesc
(
appleEvent
keyAEFile
typeWildCard
&
savingIn
)
;
if
(
err
!
=
errAEDescNotFound
)
ThrowIfOSErr
(
err
)
;
err
=
CheckForUnusedParameters
(
appleEvent
)
;
ThrowIfOSErr
(
err
)
;
SysBeep
(
2
)
;
}
void
AEApplicationClass
:
:
HandleCount
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
OSErr
err
=
noErr
;
long
numberOfObjects
=
0L
;
DescType
objectClass
;
if
(
!
reply
-
>
dataHandle
)
return
;
err
=
GetObjectClassFromAppleEvent
(
appleEvent
&
objectClass
)
;
ThrowIfOSErr
(
err
)
;
err
=
CheckForUnusedParameters
(
appleEvent
)
;
ThrowIfOSErr
(
err
)
;
numberOfObjects
=
CountApplicationObjects
(
token
objectClass
)
;
err
=
AEPutParamPtr
(
reply
keyAEResult
typeLongInteger
(
Ptr
)
&
numberOfObjects
sizeof
(
long
)
)
;
ThrowIfOSErr
(
err
)
;
}
void
AEApplicationClass
:
:
HandleDataSize
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
OSErr
err
=
noErr
;
StAEDesc
data
;
long
size
=
0L
;
HandleGetData
(
token
appleEvent
reply
)
;
err
=
AEGetKeyDesc
(
reply
keyDirectObject
typeWildCard
&
data
)
;
ThrowIfOSErr
(
err
)
;
size
=
data
.
GetDataSize
(
)
;
err
=
AEPutParamPtr
(
reply
keyAEResult
typeLongInteger
(
Ptr
)
&
size
sizeof
(
long
)
)
;
ThrowIfOSErr
(
err
)
;
}
void
AEApplicationClass
:
:
HandleDelete
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
OSErr
err
=
noErr
;
if
(
AEListUtils
:
:
TokenContainsTokenList
(
token
)
)
{
long
numItems
;
AECountItems
(
token
&
numItems
)
;
if
(
numItems
>
0
)
err
=
errAEEventNotHandled
;
}
ThrowIfOSErr
(
err
)
;
}
void
AEApplicationClass
:
:
HandleDuplicate
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
ThrowIfOSErr
(
errAEEventNotHandled
)
;
}
void
AEApplicationClass
:
:
HandleExists
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
OSErr
err
=
noErr
;
Boolean
foundIt
=
true
;
err
=
AEPutParamPtr
(
reply
keyAEResult
typeBoolean
(
Ptr
)
&
foundIt
sizeof
(
Boolean
)
)
;
ThrowIfOSErr
(
err
)
;
}
void
AEApplicationClass
:
:
HandleMake
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
ThrowIfOSErr
(
errAEEventNotHandled
)
;
}
void
AEApplicationClass
:
:
HandleMove
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
ThrowIfOSErr
(
errAEEventNotHandled
)
;
}
void
AEApplicationClass
:
:
HandleRun
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
OSErr
err
=
noErr
;
err
=
CheckForUnusedParameters
(
appleEvent
)
;
ThrowIfOSErr
(
err
)
;
}
void
AEApplicationClass
:
:
HandleReOpen
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
OSErr
err
=
noErr
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsINativeAppSupport
>
nas
;
nas
=
do_CreateInstance
(
NS_NATIVEAPPSUPPORT_CONTRACTID
)
;
if
(
!
nas
)
ThrowIfOSErr
(
errAEEventNotHandled
)
;
rv
=
nas
-
>
ReOpen
(
)
;
if
(
NS_FAILED
(
rv
)
)
ThrowIfOSErr
(
errAEEventNotHandled
)
;
err
=
CheckForUnusedParameters
(
appleEvent
)
;
ThrowIfOSErr
(
err
)
;
}
void
AEApplicationClass
:
:
HandleOpen
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
OSErr
err
;
err
=
CheckForUnusedParameters
(
appleEvent
)
;
ThrowIfOSErr
(
err
)
;
long
numItems
i
;
Boolean
openedGroups
=
false
;
err
=
:
:
AECountItems
(
token
&
numItems
)
;
ThrowIfOSErr
(
err
)
;
for
(
i
=
1
;
i
<
=
numItems
;
i
+
+
)
{
FSSpec
fSpec
;
FInfo
fndrInfo
;
AEKeyword
keywd
;
DescType
returnedType
;
Size
actualSize
;
err
=
:
:
AEGetNthPtr
(
token
i
typeFSS
&
keywd
&
returnedType
(
Ptr
)
&
fSpec
sizeof
(
fSpec
)
&
actualSize
)
;
ThrowIfOSErr
(
err
)
;
err
=
:
:
FSpGetFInfo
(
&
fSpec
&
fndrInfo
)
;
ThrowIfOSErr
(
err
)
;
nsMacCommandLine
&
cmdLine
=
nsMacCommandLine
:
:
GetMacCommandLine
(
)
;
cmdLine
.
HandleOpenOneDoc
(
fSpec
fndrInfo
.
fdType
)
;
}
}
void
AEApplicationClass
:
:
HandlePrint
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
OSErr
err
=
noErr
;
err
=
CheckForUnusedParameters
(
appleEvent
)
;
ThrowIfOSErr
(
err
)
;
long
numItems
i
;
Boolean
openedGroups
=
false
;
err
=
:
:
AECountItems
(
token
&
numItems
)
;
ThrowIfOSErr
(
err
)
;
for
(
i
=
1
;
i
<
=
numItems
;
i
+
+
)
{
FSSpec
fSpec
;
FInfo
fndrInfo
;
AEKeyword
keywd
;
DescType
returnedType
;
Size
actualSize
;
err
=
:
:
AEGetNthPtr
(
token
i
typeFSS
&
keywd
&
returnedType
(
Ptr
)
&
fSpec
sizeof
(
fSpec
)
&
actualSize
)
;
ThrowIfOSErr
(
err
)
;
err
=
:
:
FSpGetFInfo
(
&
fSpec
&
fndrInfo
)
;
ThrowIfOSErr
(
err
)
;
nsMacCommandLine
&
cmdLine
=
nsMacCommandLine
:
:
GetMacCommandLine
(
)
;
cmdLine
.
HandlePrintOneDoc
(
fSpec
fndrInfo
.
fdType
)
;
}
}
void
AEApplicationClass
:
:
HandleQuit
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
StAEDesc
savingParam
;
TAskSave
askSave
=
eSaveUnspecified
;
OSErr
err
=
:
:
AEGetKeyDesc
(
appleEvent
keyAESaveOptions
typeEnumeration
&
savingParam
)
;
if
(
err
!
=
errAEDescNotFound
)
{
DescType
enumValue
=
savingParam
.
GetEnumType
(
)
;
switch
(
enumValue
)
{
case
'
yes
'
:
askSave
=
eSaveYes
;
break
;
case
'
no
'
:
askSave
=
eSaveNo
;
break
;
case
'
ask
'
:
askSave
=
eSaveAsk
;
break
;
}
}
err
=
CheckForUnusedParameters
(
appleEvent
)
;
ThrowIfOSErr
(
err
)
;
nsMacCommandLine
&
cmdLine
=
nsMacCommandLine
:
:
GetMacCommandLine
(
)
;
err
=
cmdLine
.
Quit
(
askSave
)
;
ThrowIfOSErr
(
err
)
;
}
void
AEApplicationClass
:
:
HandleSave
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
ThrowIfOSErr
(
errAEEventNotHandled
)
;
}
#
if
0
void
AEApplicationClass
:
:
HandleSetData
(
AEDesc
*
token
const
AppleEvent
*
appleEvent
AppleEvent
*
reply
)
{
OSErr
err
=
noErr
;
StAEDesc
tokenData
;
AETokenDesc
tokenDesc
(
token
)
;
DescType
propertyCode
;
if
(
token
-
>
descriptorType
=
=
cProperty
)
{
propertyCode
=
tokenDesc
.
GetPropertyCode
(
)
;
if
(
CanSetProperty
(
propertyCode
)
)
{
switch
(
propertyCode
)
{
case
pClipboard
:
err
=
AEGetKeyDesc
(
appleEvent
keyAEData
typeAEList
&
tokenData
)
;
ThrowIfOSErr
(
err
)
;
SetDataForObject
(
token
&
tokenData
)
;
err
=
AEPutKeyDesc
(
reply
keyDirectObject
&
tokenData
)
;
ThrowIfOSErr
(
err
)
;
break
;
default
:
ThrowIfOSErr
(
errAENotModifiable
)
;
break
;
}
}
else
{
ThrowIfOSErr
(
errAENotModifiable
)
;
}
}
else
{
ThrowIfOSErr
(
errAEEventNotHandled
)
;
}
}
#
endif
#
pragma
mark
-
void
AEApplicationClass
:
:
CountObjects
(
DescType
desiredType
DescType
containerClass
const
AEDesc
*
container
long
*
result
)
{
long
numberOfObjects
=
CountApplicationObjects
(
container
desiredType
)
;
*
result
=
numberOfObjects
;
}
#
pragma
mark
-
void
AEApplicationClass
:
:
GetDataFromObject
(
const
AEDesc
*
token
AEDesc
*
desiredTypes
AEDesc
*
data
)
{
OSErr
err
=
noErr
;
Str255
applicationName
=
"
\
p
"
;
Str255
versionString
;
ConstAETokenDesc
tokenDesc
(
token
)
;
ProcessSerialNumber
applicationProcessNumber
;
ProcessInfoRec
applicationInfo
;
FSSpec
appFSSpec
;
Boolean
isFrontProcess
=
true
;
DescType
aDescType
=
cApplication
;
long
documentNumber
=
0L
;
unsigned
long
elementNumber
=
0L
;
Boolean
usePropertyCode
=
tokenDesc
.
UsePropertyCode
(
)
;
DescType
propertyCode
;
long
free
;
long
contiguous
;
unsigned
long
ticks
;
err
=
GetCurrentProcess
(
&
applicationProcessNumber
)
;
if
(
err
=
=
noErr
)
{
applicationInfo
.
processInfoLength
=
sizeof
(
ProcessInfoRec
)
;
applicationInfo
.
processName
=
applicationName
;
applicationInfo
.
processAppSpec
=
&
appFSSpec
;
err
=
GetProcessInformation
(
&
applicationProcessNumber
&
applicationInfo
)
;
}
GetShortVersionString
(
2
versionString
)
;
PurgeSpace
(
&
free
&
contiguous
)
;
ticks
=
TickCount
(
)
;
propertyCode
=
tokenDesc
.
GetPropertyCode
(
)
;
switch
(
propertyCode
)
{
case
pProperties
:
err
=
AECreateList
(
nil
0
true
data
)
;
ThrowIfOSErr
(
err
)
;
err
=
AEPutKeyPtr
(
data
pObjectType
typeType
&
aDescType
sizeof
(
DescType
)
)
;
err
=
AEPutKeyPtr
(
data
pName
typeChar
&
applicationName
[
1
]
applicationName
[
0
]
)
;
err
=
AEPutKeyPtr
(
data
pVersion
typeChar
&
versionString
[
1
]
versionString
[
0
]
)
;
err
=
AEPutKeyPtr
(
data
pIsFrontProcess
typeBoolean
&
isFrontProcess
sizeof
(
Boolean
)
)
;
err
=
AEPutKeyPtr
(
data
pFreeMemory
typeLongInteger
&
free
sizeof
(
long
)
)
;
err
=
AEPutKeyPtr
(
data
pLargestFreeBlock
typeLongInteger
&
contiguous
sizeof
(
long
)
)
;
err
=
AEPutKeyPtr
(
data
pTicks
typeLongInteger
&
ticks
sizeof
(
long
)
)
;
break
;
case
pBestType
:
case
pClass
:
case
pDefaultType
:
case
pObjectType
:
err
=
AECreateDesc
(
typeType
&
aDescType
sizeof
(
DescType
)
data
)
;
break
;
case
pName
:
err
=
AECreateDesc
(
typeChar
&
applicationName
[
1
]
applicationName
[
0
]
data
)
;
break
;
case
pVersion
:
err
=
AECreateDesc
(
typeChar
&
versionString
[
1
]
versionString
[
0
]
data
)
;
break
;
case
pIsFrontProcess
:
err
=
AECreateDesc
(
typeBoolean
&
isFrontProcess
sizeof
(
Boolean
)
data
)
;
break
;
case
pFreeMemory
:
err
=
AECreateDesc
(
typeLongInteger
&
free
sizeof
(
long
)
data
)
;
break
;
case
pLargestFreeBlock
:
err
=
AECreateDesc
(
typeLongInteger
&
contiguous
sizeof
(
long
)
data
)
;
break
;
case
pTicks
:
err
=
AECreateDesc
(
typeLongInteger
&
ticks
sizeof
(
long
)
data
)
;
break
;
case
pClipboard
:
#
if
!
TARGET_CARBON
{
char
*
scrapPtr
;
char
*
scrapEnd
;
PScrapStuff
scrapInfo
;
OSType
itemType
;
long
itemLength
;
long
index
;
err
=
AECreateList
(
NULL
0
false
data
)
;
ThrowIfOSErr
(
err
)
;
err
=
LoadScrap
(
)
;
ThrowIfOSErr
(
err
)
;
scrapInfo
=
InfoScrap
(
)
;
MoveHHi
(
scrapInfo
-
>
scrapHandle
)
;
HLock
(
scrapInfo
-
>
scrapHandle
)
;
scrapPtr
=
(
char
*
)
*
scrapInfo
-
>
scrapHandle
;
scrapEnd
=
scrapPtr
+
scrapInfo
-
>
scrapSize
;
index
=
1
;
while
(
scrapPtr
<
scrapEnd
)
{
itemType
=
*
(
OSType
*
)
scrapPtr
;
scrapPtr
+
=
sizeof
(
itemType
)
;
itemLength
=
*
(
long
*
)
scrapPtr
;
scrapPtr
+
=
sizeof
(
itemLength
)
;
err
=
AEPutPtr
(
data
index
itemType
scrapPtr
itemLength
)
;
ThrowIfOSErr
(
err
)
;
index
+
+
;
if
(
itemLength
&
1
)
itemLength
+
+
;
scrapPtr
+
=
itemLength
;
}
HUnlock
(
scrapInfo
-
>
scrapHandle
)
;
}
#
endif
break
;
default
:
Inherited
:
:
GetDataFromObject
(
token
desiredTypes
data
)
;
break
;
}
ThrowIfOSErr
(
err
)
;
}
void
AEApplicationClass
:
:
SetDataForObject
(
const
AEDesc
*
token
AEDesc
*
data
)
{
OSErr
err
=
noErr
;
ConstAETokenDesc
tokenDesc
(
token
)
;
Boolean
usePropertyCode
=
tokenDesc
.
UsePropertyCode
(
)
;
DescType
propertyCode
;
if
(
usePropertyCode
)
{
propertyCode
=
tokenDesc
.
GetPropertyCode
(
)
;
#
if
!
TARGET_CARBON
long
numItems
;
#
endif
switch
(
propertyCode
)
{
case
pClipboard
:
#
if
!
TARGET_CARBON
err
=
ZeroScrap
(
)
;
ThrowIfOSErr
(
err
)
;
AECountItems
(
data
&
numItems
)
;
for
(
long
index
=
1
;
index
<
=
numItems
;
index
+
+
)
{
StAEDesc
currentItemDesc
;
AEKeyword
theAEKeyword
;
err
=
AEGetNthDesc
(
data
index
typeWildCard
&
theAEKeyword
&
currentItemDesc
)
;
ThrowIfOSErr
(
err
)
;
HLock
(
currentItemDesc
.
dataHandle
)
;
err
=
PutScrap
(
GetHandleSize
(
currentItemDesc
.
dataHandle
)
currentItemDesc
.
descriptorType
*
currentItemDesc
.
dataHandle
)
;
ThrowIfOSErr
(
err
)
;
}
#
endif
break
;
default
:
ThrowIfOSErr
(
errAENotModifiable
)
;
}
}
}
DescType
AEApplicationClass
:
:
GetKeyEventDataAs
(
DescType
propertyCode
)
{
DescType
returnType
;
switch
(
propertyCode
)
{
case
pClipboard
:
returnType
=
typeAEList
;
break
;
default
:
returnType
=
typeWildCard
;
}
return
returnType
;
}
#
pragma
mark
-
Boolean
AEApplicationClass
:
:
CanSetProperty
(
DescType
propertyCode
)
{
Boolean
result
=
false
;
switch
(
propertyCode
)
{
case
pClipboard
:
result
=
true
;
break
;
case
pBestType
:
case
pClass
:
case
pDefaultType
:
case
pObjectType
:
case
pProperties
:
case
pFreeMemory
:
case
pLargestFreeBlock
:
case
pTicks
:
case
pIsFrontProcess
:
case
pName
:
case
pVersion
:
case
pInsertionLoc
:
case
pSelection
:
case
pUserSelection
:
result
=
false
;
break
;
default
:
result
=
Inherited
:
:
CanSetProperty
(
propertyCode
)
;
break
;
}
return
result
;
}
Boolean
AEApplicationClass
:
:
CanGetProperty
(
DescType
propertyCode
)
{
Boolean
result
=
false
;
switch
(
propertyCode
)
{
case
pBestType
:
case
pClass
:
case
pDefaultType
:
case
pObjectType
:
case
pProperties
:
case
pFreeMemory
:
case
pLargestFreeBlock
:
case
pTicks
:
case
pIsFrontProcess
:
case
pName
:
case
pVersion
:
case
pInsertionLoc
:
case
pSelection
:
case
pUserSelection
:
result
=
true
;
break
;
default
:
result
=
Inherited
:
:
CanGetProperty
(
propertyCode
)
;
break
;
}
return
result
;
}
#
pragma
mark
-
void
AEApplicationClass
:
:
CreateSelfSpecifier
(
const
AEDesc
*
token
AEDesc
*
outSpecifier
)
{
OSErr
err
=
:
:
AECreateDesc
(
typeNull
nil
0
outSpecifier
)
;
ThrowIfOSErr
(
err
)
;
}
#
pragma
mark
-
long
AEApplicationClass
:
:
CountApplicationObjects
(
const
AEDesc
*
token
DescType
desiredType
)
{
long
numberOfObjects
=
0
;
OSErr
err
=
noErr
;
if
(
AEListUtils
:
:
TokenContainsTokenList
(
token
)
)
{
err
=
AECountItems
(
token
&
numberOfObjects
)
;
}
else
{
AEDispatchHandler
*
countHandler
=
AECoreClass
:
:
sAECoreHandler
-
>
GetDispatchHandler
(
desiredType
)
;
if
(
countHandler
=
=
nil
)
ThrowOSErr
(
errAEEventNotHandled
)
;
countHandler
-
>
CountObjects
(
desiredType
typeNull
token
&
numberOfObjects
)
;
}
ThrowIfOSErr
(
err
)
;
return
numberOfObjects
;
}
