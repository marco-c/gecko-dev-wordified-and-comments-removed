use
dom
:
:
bindings
:
:
utils
:
:
Reflectable
;
use
js
:
:
jsapi
:
:
{
JSContext
JSObject
JS_WrapObject
JS_ObjectIsCallable
}
;
use
js
:
:
jsapi
:
:
{
JS_GetProperty
JSTracer
JS_CallTracer
}
;
use
js
:
:
jsval
:
:
JSVal
;
use
js
:
:
JSTRACE_OBJECT
;
use
std
:
:
cast
;
use
std
:
:
libc
;
use
std
:
:
ptr
;
use
extra
:
:
serialize
:
:
{
Encodable
Encoder
}
;
pub
enum
ExceptionHandling
{
eReportExceptions
eRethrowContentExceptions
eRethrowExceptions
}
#
[
deriving
(
Clone
Eq
)
]
pub
struct
CallbackInterface
{
callback
:
*
JSObject
}
impl
<
S
:
Encoder
>
Encodable
<
S
>
for
CallbackInterface
{
fn
encode
(
&
self
s
:
&
mut
S
)
{
unsafe
{
let
tracer
:
*
mut
JSTracer
=
cast
:
:
transmute
(
s
)
;
"
callback
"
.
to_c_str
(
)
.
with_ref
(
|
name
|
{
(
*
tracer
)
.
debugPrinter
=
ptr
:
:
null
(
)
;
(
*
tracer
)
.
debugPrintIndex
=
-
1
;
(
*
tracer
)
.
debugPrintArg
=
name
as
*
libc
:
:
c_void
;
JS_CallTracer
(
tracer
as
*
JSTracer
self
.
callback
JSTRACE_OBJECT
as
u32
)
;
}
)
;
}
}
}
pub
trait
CallbackContainer
{
fn
callback
(
&
self
)
-
>
*
JSObject
;
}
impl
CallbackContainer
for
CallbackInterface
{
fn
callback
(
&
self
)
-
>
*
JSObject
{
self
.
callback
}
}
impl
CallbackInterface
{
pub
fn
new
(
callback
:
*
JSObject
)
-
>
CallbackInterface
{
CallbackInterface
{
callback
:
callback
}
}
pub
fn
GetCallableProperty
(
&
self
cx
:
*
JSContext
name
:
*
libc
:
:
c_char
callable
:
&
mut
JSVal
)
-
>
bool
{
unsafe
{
if
JS_GetProperty
(
cx
self
.
callback
name
&
*
callable
)
=
=
0
{
return
false
;
}
if
!
callable
.
is_object
(
)
|
|
JS_ObjectIsCallable
(
cx
callable
.
to_object
(
)
)
=
=
0
{
return
false
;
}
return
true
;
}
}
}
pub
fn
GetJSObjectFromCallback
<
T
:
CallbackContainer
>
(
callback
:
&
T
)
-
>
*
JSObject
{
callback
.
callback
(
)
}
pub
fn
WrapCallThisObject
<
T
:
'
static
+
CallbackContainer
+
Reflectable
>
(
cx
:
*
JSContext
_scope
:
*
JSObject
p
:
~
T
)
-
>
*
JSObject
{
let
obj
=
GetJSObjectFromCallback
(
p
)
;
assert
!
(
obj
.
is_not_null
(
)
)
;
unsafe
{
if
JS_WrapObject
(
cx
&
obj
)
=
=
0
{
return
ptr
:
:
null
(
)
;
}
}
return
obj
;
}
pub
struct
CallSetup
{
cx
:
*
JSContext
handling
:
ExceptionHandling
}
impl
CallSetup
{
pub
fn
new
(
cx
:
*
JSContext
handling
:
ExceptionHandling
)
-
>
CallSetup
{
CallSetup
{
cx
:
cx
handling
:
handling
}
}
pub
fn
GetContext
(
&
self
)
-
>
*
JSContext
{
self
.
cx
}
}
