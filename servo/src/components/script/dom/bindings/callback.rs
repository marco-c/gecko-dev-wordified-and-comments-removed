use
dom
:
:
bindings
:
:
utils
:
:
Reflectable
;
use
js
:
:
jsapi
:
:
{
JSContext
JSObject
JS_WrapObject
JSVal
JS_ObjectIsCallable
}
;
use
js
:
:
jsapi
:
:
JS_GetProperty
;
use
js
:
:
{
JSVAL_IS_OBJECT
JSVAL_TO_OBJECT
}
;
use
std
:
:
libc
;
use
std
:
:
ptr
;
pub
enum
ExceptionHandling
{
eReportExceptions
eRethrowContentExceptions
eRethrowExceptions
}
#
[
deriving
(
Clone
Eq
)
]
pub
struct
CallbackInterface
{
callback
:
*
JSObject
}
pub
trait
CallbackContainer
{
fn
callback
(
&
self
)
-
>
*
JSObject
;
}
impl
CallbackContainer
for
CallbackInterface
{
fn
callback
(
&
self
)
-
>
*
JSObject
{
self
.
callback
}
}
impl
CallbackInterface
{
pub
fn
new
(
callback
:
*
JSObject
)
-
>
CallbackInterface
{
CallbackInterface
{
callback
:
callback
}
}
#
[
fixed_stack_segment
]
pub
fn
GetCallableProperty
(
&
self
cx
:
*
JSContext
name
:
*
libc
:
:
c_char
callable
:
&
mut
JSVal
)
-
>
bool
{
unsafe
{
if
JS_GetProperty
(
cx
self
.
callback
name
&
*
callable
)
=
=
0
{
return
false
;
}
if
!
JSVAL_IS_OBJECT
(
*
callable
)
|
|
JS_ObjectIsCallable
(
cx
JSVAL_TO_OBJECT
(
*
callable
)
)
=
=
0
{
return
false
;
}
return
true
;
}
}
}
pub
fn
GetJSObjectFromCallback
<
T
:
CallbackContainer
>
(
callback
:
&
T
)
-
>
*
JSObject
{
callback
.
callback
(
)
}
#
[
fixed_stack_segment
]
pub
fn
WrapCallThisObject
<
T
:
'
static
+
CallbackContainer
+
Reflectable
>
(
cx
:
*
JSContext
_scope
:
*
JSObject
p
:
mut
T
)
-
>
*
JSObject
{
let
obj
=
GetJSObjectFromCallback
(
p
)
;
assert
!
(
obj
.
is_not_null
(
)
)
;
unsafe
{
if
JS_WrapObject
(
cx
&
obj
)
=
=
0
{
return
ptr
:
:
null
(
)
;
}
}
return
obj
;
}
pub
struct
CallSetup
{
cx
:
*
JSContext
handling
:
ExceptionHandling
}
impl
CallSetup
{
pub
fn
new
(
cx
:
*
JSContext
handling
:
ExceptionHandling
)
-
>
CallSetup
{
CallSetup
{
cx
:
cx
handling
:
handling
}
}
pub
fn
GetContext
(
&
self
)
-
>
*
JSContext
{
self
.
cx
}
}
