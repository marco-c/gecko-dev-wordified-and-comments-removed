use
dom
:
:
bindings
:
:
utils
:
:
{
Reflector
Reflectable
}
;
use
dom
:
:
window
:
:
Window
;
use
js
:
:
jsapi
:
:
{
JSContext
JSObject
}
;
use
layout_interface
:
:
TrustedNodeAddress
;
use
std
:
:
cast
;
use
std
:
:
cell
:
:
RefCell
;
pub
struct
JS
<
T
>
{
priv
ptr
:
RefCell
<
*
mut
T
>
}
impl
<
T
>
Eq
for
JS
<
T
>
{
fn
eq
(
&
self
other
:
&
JS
<
T
>
)
-
>
bool
{
self
.
ptr
=
=
other
.
ptr
}
}
impl
<
T
>
Clone
for
JS
<
T
>
{
fn
clone
(
&
self
)
-
>
JS
<
T
>
{
JS
{
ptr
:
self
.
ptr
.
clone
(
)
}
}
}
impl
<
T
:
Reflectable
>
JS
<
T
>
{
pub
fn
new
(
mut
obj
:
~
T
window
:
&
JS
<
Window
>
wrap_fn
:
extern
"
Rust
"
fn
(
*
JSContext
&
JS
<
Window
>
~
T
)
-
>
*
JSObject
)
-
>
JS
<
T
>
{
let
cx
=
window
.
get
(
)
.
get_cx
(
)
;
let
raw
:
*
mut
T
=
&
mut
*
obj
;
if
wrap_fn
(
cx
window
obj
)
.
is_null
(
)
{
fail
!
(
"
Could
not
eagerly
wrap
object
"
)
;
}
JS
{
ptr
:
RefCell
:
:
new
(
raw
)
}
}
pub
unsafe
fn
from_raw
(
raw
:
*
mut
T
)
-
>
JS
<
T
>
{
JS
{
ptr
:
RefCell
:
:
new
(
raw
)
}
}
pub
unsafe
fn
from_trusted_node_address
(
inner
:
TrustedNodeAddress
)
-
>
JS
<
T
>
{
JS
{
ptr
:
RefCell
:
:
new
(
inner
as
*
mut
T
)
}
}
}
impl
<
T
:
Reflectable
>
Reflectable
for
JS
<
T
>
{
fn
reflector
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Reflector
{
self
.
get
(
)
.
reflector
(
)
}
fn
mut_reflector
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Reflector
{
self
.
get_mut
(
)
.
mut_reflector
(
)
}
}
impl
<
T
>
JS
<
T
>
{
pub
fn
get
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
T
{
let
borrowed
=
self
.
ptr
.
borrow
(
)
;
unsafe
{
&
(
*
*
borrowed
.
get
(
)
)
}
}
pub
fn
get_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
T
{
let
mut
borrowed
=
self
.
ptr
.
borrow_mut
(
)
;
unsafe
{
&
mut
(
*
*
borrowed
.
get
(
)
)
}
}
pub
unsafe
fn
unsafe_get
(
&
self
)
-
>
*
mut
T
{
cast
:
:
transmute_copy
(
&
self
.
ptr
)
}
}
impl
<
From
To
>
JS
<
From
>
{
pub
unsafe
fn
transmute
(
self
)
-
>
JS
<
To
>
{
cast
:
:
transmute
(
self
)
}
pub
unsafe
fn
transmute_copy
(
&
self
)
-
>
JS
<
To
>
{
cast
:
:
transmute_copy
(
self
)
}
}
