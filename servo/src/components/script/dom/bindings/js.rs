use
dom
:
:
bindings
:
:
utils
:
:
{
Reflector
Reflectable
cx_for_dom_object
}
;
use
dom
:
:
node
:
:
Node
;
use
dom
:
:
xmlhttprequest
:
:
{
XMLHttpRequest
TrustedXHRAddress
}
;
use
js
:
:
jsapi
:
:
{
JSObject
JS_AddObjectRoot
JS_RemoveObjectRoot
}
;
use
layout_interface
:
:
TrustedNodeAddress
;
use
script_task
:
:
StackRoots
;
use
std
:
:
cast
;
use
std
:
:
cell
:
:
{
Cell
RefCell
}
;
use
std
:
:
kinds
:
:
marker
:
:
ContravariantLifetime
;
pub
struct
Temporary
<
T
>
{
inner
:
JS
<
T
>
}
impl
<
T
>
Eq
for
Temporary
<
T
>
{
fn
eq
(
&
self
other
:
&
Temporary
<
T
>
)
-
>
bool
{
self
.
inner
=
=
other
.
inner
}
}
#
[
unsafe_destructor
]
impl
<
T
:
Reflectable
>
Drop
for
Temporary
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
cx
=
cx_for_dom_object
(
&
self
.
inner
)
;
unsafe
{
JS_RemoveObjectRoot
(
cx
self
.
inner
.
mut_reflector
(
)
.
rootable
(
)
)
;
}
}
}
impl
<
T
:
Reflectable
>
Temporary
<
T
>
{
pub
fn
new
(
mut
inner
:
JS
<
T
>
)
-
>
Temporary
<
T
>
{
let
cx
=
cx_for_dom_object
(
&
inner
)
;
unsafe
{
JS_AddObjectRoot
(
cx
inner
.
mut_reflector
(
)
.
rootable
(
)
)
;
}
Temporary
{
inner
:
inner
}
}
pub
fn
from_rooted
<
'
a
>
(
root
:
&
JSRef
<
'
a
T
>
)
-
>
Temporary
<
T
>
{
Temporary
:
:
new
(
root
.
unrooted
(
)
)
}
pub
fn
root
<
'
a
'
b
>
(
self
)
-
>
Root
<
'
a
'
b
T
>
{
let
collection
=
StackRoots
.
get
(
)
.
unwrap
(
)
;
unsafe
{
(
*
*
collection
)
.
new_root
(
&
self
.
inner
)
}
}
unsafe
fn
inner
(
&
self
)
-
>
JS
<
T
>
{
self
.
inner
.
clone
(
)
}
pub
unsafe
fn
transmute
<
To
>
(
self
)
-
>
Temporary
<
To
>
{
cast
:
:
transmute
(
self
)
}
}
pub
struct
JS
<
T
>
{
ptr
:
*
T
}
impl
<
T
>
Eq
for
JS
<
T
>
{
fn
eq
(
&
self
other
:
&
JS
<
T
>
)
-
>
bool
{
self
.
ptr
=
=
other
.
ptr
}
}
impl
<
T
>
Clone
for
JS
<
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
JS
<
T
>
{
JS
{
ptr
:
self
.
ptr
.
clone
(
)
}
}
}
impl
JS
<
Node
>
{
/
/
/
Create
a
new
JS
-
owned
value
wrapped
from
an
address
known
to
be
a
Node
pointer
.
pub
unsafe
fn
from_trusted_node_address
(
inner
:
TrustedNodeAddress
)
-
>
JS
<
Node
>
{
let
TrustedNodeAddress
(
addr
)
=
inner
;
JS
{
ptr
:
addr
as
*
Node
}
}
}
impl
JS
<
XMLHttpRequest
>
{
pub
unsafe
fn
from_trusted_xhr_address
(
inner
:
TrustedXHRAddress
)
-
>
JS
<
XMLHttpRequest
>
{
let
TrustedXHRAddress
(
addr
)
=
inner
;
JS
{
ptr
:
addr
as
*
XMLHttpRequest
}
}
}
impl
<
T
:
Reflectable
>
JS
<
T
>
{
/
/
/
Create
a
new
JS
-
owned
value
wrapped
from
a
raw
Rust
pointer
.
pub
unsafe
fn
from_raw
(
raw
:
*
T
)
-
>
JS
<
T
>
{
JS
{
ptr
:
raw
}
}
/
/
/
Root
this
JS
-
owned
value
to
prevent
its
collection
as
garbage
.
pub
fn
root
<
'
a
'
b
>
(
&
self
)
-
>
Root
<
'
a
'
b
T
>
{
let
collection
=
StackRoots
.
get
(
)
.
unwrap
(
)
;
unsafe
{
(
*
*
collection
)
.
new_root
(
self
)
}
}
}
impl
<
T
:
Assignable
<
U
>
U
:
Reflectable
>
JS
<
U
>
{
pub
fn
from_rooted
(
root
:
T
)
-
>
JS
<
U
>
{
unsafe
{
root
.
get_js
(
)
}
}
}
/
/
XXXjdm
This
is
disappointing
.
This
only
gets
called
from
trace
hooks
in
theory
/
/
so
it
'
s
safe
to
assume
that
self
is
rooted
and
thereby
safe
to
access
.
impl
<
T
:
Reflectable
>
Reflectable
for
JS
<
T
>
{
fn
reflector
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Reflector
{
unsafe
{
(
*
self
.
unsafe_get
(
)
)
.
reflector
(
)
}
}
fn
mut_reflector
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Reflector
{
unsafe
{
(
*
self
.
unsafe_get
(
)
)
.
mut_reflector
(
)
}
}
}
impl
<
T
:
Reflectable
>
JS
<
T
>
{
/
/
/
Returns
an
unsafe
pointer
to
the
interior
of
this
JS
object
without
touching
the
borrow
/
/
/
flags
.
This
is
the
only
method
that
be
safely
accessed
from
layout
.
(
The
fact
that
this
/
/
/
is
unsafe
is
what
necessitates
the
layout
wrappers
.
)
pub
unsafe
fn
unsafe_get
(
&
self
)
-
>
*
mut
T
{
cast
:
:
transmute_copy
(
&
self
.
ptr
)
}
/
/
/
Store
an
unrooted
value
in
this
field
.
This
is
safe
under
the
assumption
that
JS
<
T
>
/
/
/
values
are
only
used
as
fields
in
DOM
types
that
are
reachable
in
the
GC
graph
/
/
/
so
this
unrooted
value
becomes
transitively
rooted
for
the
lifetime
of
its
new
owner
.
pub
fn
assign
(
&
mut
self
val
:
Temporary
<
T
>
)
{
*
self
=
unsafe
{
val
.
inner
(
)
}
;
}
}
impl
<
From
To
>
JS
<
From
>
{
/
/
XXXjdm
It
would
be
lovely
if
this
could
be
private
.
pub
unsafe
fn
transmute
(
self
)
-
>
JS
<
To
>
{
cast
:
:
transmute
(
self
)
}
pub
unsafe
fn
transmute_copy
(
&
self
)
-
>
JS
<
To
>
{
cast
:
:
transmute_copy
(
self
)
}
}
/
/
/
Get
an
Option
<
JSRef
<
T
>
>
out
of
an
Option
<
Root
<
T
>
>
pub
trait
RootedReference
<
T
>
{
fn
root_ref
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
JSRef
<
'
a
T
>
>
;
}
impl
<
'
a
'
b
T
:
Reflectable
>
RootedReference
<
T
>
for
Option
<
Root
<
'
a
'
b
T
>
>
{
fn
root_ref
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
JSRef
<
'
a
T
>
>
{
self
.
as_ref
(
)
.
map
(
|
root
|
root
.
root_ref
(
)
)
}
}
/
/
/
Get
an
Option
<
Option
<
JSRef
<
T
>
>
>
out
of
an
Option
<
Option
<
Root
<
T
>
>
>
pub
trait
OptionalRootedReference
<
T
>
{
fn
root_ref
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
Option
<
JSRef
<
'
a
T
>
>
>
;
}
impl
<
'
a
'
b
T
:
Reflectable
>
OptionalRootedReference
<
T
>
for
Option
<
Option
<
Root
<
'
a
'
b
T
>
>
>
{
fn
root_ref
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
Option
<
JSRef
<
'
a
T
>
>
>
{
self
.
as_ref
(
)
.
map
(
|
inner
|
inner
.
root_ref
(
)
)
}
}
/
/
/
Trait
that
allows
extracting
a
JS
<
T
>
value
from
a
variety
of
rooting
-
related
containers
/
/
/
which
in
general
is
an
unsafe
operation
since
they
can
outlive
the
rooted
lifetime
of
the
/
/
/
original
value
.
/
*
definitely
not
public
*
/
trait
Assignable
<
T
>
{
unsafe
fn
get_js
(
&
self
)
-
>
JS
<
T
>
;
}
impl
<
T
>
Assignable
<
T
>
for
JS
<
T
>
{
unsafe
fn
get_js
(
&
self
)
-
>
JS
<
T
>
{
self
.
clone
(
)
}
}
impl
<
'
a
T
>
Assignable
<
T
>
for
JSRef
<
'
a
T
>
{
unsafe
fn
get_js
(
&
self
)
-
>
JS
<
T
>
{
self
.
unrooted
(
)
}
}
impl
<
T
:
Reflectable
>
Assignable
<
T
>
for
Temporary
<
T
>
{
unsafe
fn
get_js
(
&
self
)
-
>
JS
<
T
>
{
self
.
inner
(
)
}
}
/
/
/
Assign
an
optional
rootable
value
(
either
of
JS
<
T
>
or
Temporary
<
T
>
)
to
an
optional
/
/
/
field
of
a
DOM
type
(
ie
.
Option
<
JS
<
T
>
>
)
pub
trait
OptionalSettable
<
T
>
{
fn
assign
(
&
self
val
:
Option
<
T
>
)
;
}
impl
<
T
:
Assignable
<
U
>
U
:
Reflectable
>
OptionalSettable
<
T
>
for
Cell
<
Option
<
JS
<
U
>
>
>
{
fn
assign
(
&
self
val
:
Option
<
T
>
)
{
self
.
set
(
val
.
map
(
|
val
|
unsafe
{
val
.
get_js
(
)
}
)
)
;
}
}
/
/
/
Root
a
rootable
Option
type
(
used
for
Option
<
Temporary
<
T
>
>
)
pub
trait
OptionalRootable
<
T
>
{
fn
root
<
'
a
'
b
>
(
self
)
-
>
Option
<
Root
<
'
a
'
b
T
>
>
;
}
impl
<
T
:
Reflectable
>
OptionalRootable
<
T
>
for
Option
<
Temporary
<
T
>
>
{
fn
root
<
'
a
'
b
>
(
self
)
-
>
Option
<
Root
<
'
a
'
b
T
>
>
{
self
.
map
(
|
inner
|
inner
.
root
(
)
)
}
}
/
/
/
Return
an
unrooted
type
for
storing
in
optional
DOM
fields
pub
trait
OptionalUnrootable
<
T
>
{
fn
unrooted
(
&
self
)
-
>
Option
<
JS
<
T
>
>
;
}
impl
<
'
a
T
:
Reflectable
>
OptionalUnrootable
<
T
>
for
Option
<
JSRef
<
'
a
T
>
>
{
fn
unrooted
(
&
self
)
-
>
Option
<
JS
<
T
>
>
{
self
.
as_ref
(
)
.
map
(
|
inner
|
inner
.
unrooted
(
)
)
}
}
/
/
/
Root
a
rootable
Option
type
(
used
for
Option
<
JS
<
T
>
>
)
pub
trait
OptionalRootedRootable
<
T
>
{
fn
root
<
'
a
'
b
>
(
&
self
)
-
>
Option
<
Root
<
'
a
'
b
T
>
>
;
}
impl
<
T
:
Reflectable
>
OptionalRootedRootable
<
T
>
for
Option
<
JS
<
T
>
>
{
fn
root
<
'
a
'
b
>
(
&
self
)
-
>
Option
<
Root
<
'
a
'
b
T
>
>
{
self
.
as_ref
(
)
.
map
(
|
inner
|
inner
.
root
(
)
)
}
}
/
/
/
Root
a
rootable
Option
<
Option
>
type
(
used
for
Option
<
Option
<
JS
<
T
>
>
>
)
pub
trait
OptionalOptionalRootedRootable
<
T
>
{
fn
root
<
'
a
'
b
>
(
&
self
)
-
>
Option
<
Option
<
Root
<
'
a
'
b
T
>
>
>
;
}
impl
<
T
:
Reflectable
>
OptionalOptionalRootedRootable
<
T
>
for
Option
<
Option
<
JS
<
T
>
>
>
{
fn
root
<
'
a
'
b
>
(
&
self
)
-
>
Option
<
Option
<
Root
<
'
a
'
b
T
>
>
>
{
self
.
as_ref
(
)
.
map
(
|
inner
|
inner
.
root
(
)
)
}
}
/
/
/
Root
a
rootable
Result
type
(
any
of
Temporary
<
T
>
or
JS
<
T
>
)
pub
trait
ResultRootable
<
T
U
>
{
fn
root
<
'
a
'
b
>
(
self
)
-
>
Result
<
Root
<
'
a
'
b
T
>
U
>
;
}
impl
<
T
:
Reflectable
U
>
ResultRootable
<
T
U
>
for
Result
<
Temporary
<
T
>
U
>
{
fn
root
<
'
a
'
b
>
(
self
)
-
>
Result
<
Root
<
'
a
'
b
T
>
U
>
{
self
.
map
(
|
inner
|
inner
.
root
(
)
)
}
}
impl
<
T
:
Reflectable
U
>
ResultRootable
<
T
U
>
for
Result
<
JS
<
T
>
U
>
{
fn
root
<
'
a
'
b
>
(
self
)
-
>
Result
<
Root
<
'
a
'
b
T
>
U
>
{
self
.
map
(
|
inner
|
inner
.
root
(
)
)
}
}
/
/
/
Provides
a
facility
to
push
unrooted
values
onto
lists
of
rooted
values
.
This
is
safe
/
/
/
under
the
assumption
that
said
lists
are
reachable
via
the
GC
graph
and
therefore
the
/
/
/
new
values
are
transitively
rooted
for
the
lifetime
of
their
new
owner
.
pub
trait
TemporaryPushable
<
T
>
{
fn
push_unrooted
(
&
mut
self
val
:
&
T
)
;
fn
insert_unrooted
(
&
mut
self
index
:
uint
val
:
&
T
)
;
}
impl
<
T
:
Assignable
<
U
>
U
:
Reflectable
>
TemporaryPushable
<
T
>
for
Vec
<
JS
<
U
>
>
{
fn
push_unrooted
(
&
mut
self
val
:
&
T
)
{
self
.
push
(
unsafe
{
val
.
get_js
(
)
}
)
;
}
fn
insert_unrooted
(
&
mut
self
index
:
uint
val
:
&
T
)
{
self
.
insert
(
index
unsafe
{
val
.
get_js
(
)
}
)
;
}
}
/
/
/
An
opaque
LIFO
rooting
mechanism
.
pub
struct
RootCollection
{
roots
:
RefCell
<
Vec
<
*
mut
JSObject
>
>
}
impl
RootCollection
{
/
/
/
Create
an
empty
collection
of
roots
pub
fn
new
(
)
-
>
RootCollection
{
RootCollection
{
roots
:
RefCell
:
:
new
(
vec
!
(
)
)
}
}
/
/
/
Create
a
new
stack
-
bounded
root
that
will
not
outlive
this
collection
fn
new_root
<
'
a
'
b
T
:
Reflectable
>
(
&
'
a
self
unrooted
:
&
JS
<
T
>
)
-
>
Root
<
'
a
'
b
T
>
{
Root
:
:
new
(
self
unrooted
)
}
/
/
/
Track
a
stack
-
based
root
to
ensure
LIFO
root
ordering
fn
root
<
'
a
'
b
T
:
Reflectable
>
(
&
self
untracked
:
&
Root
<
'
a
'
b
T
>
)
{
let
mut
roots
=
self
.
roots
.
borrow_mut
(
)
;
roots
.
push
(
untracked
.
js_ptr
)
;
debug
!
(
"
rooting
{
:
?
}
"
untracked
.
js_ptr
)
;
}
/
/
/
Stop
tracking
a
stack
-
based
root
asserting
if
LIFO
root
ordering
has
been
violated
fn
unroot
<
'
a
'
b
T
:
Reflectable
>
(
&
self
rooted
:
&
Root
<
'
a
'
b
T
>
)
{
let
mut
roots
=
self
.
roots
.
borrow_mut
(
)
;
debug
!
(
"
unrooting
{
:
?
}
(
expecting
{
:
?
}
"
roots
.
last
(
)
.
unwrap
(
)
rooted
.
js_ptr
)
;
assert
!
(
*
roots
.
last
(
)
.
unwrap
(
)
=
=
rooted
.
js_ptr
)
;
roots
.
pop
(
)
.
unwrap
(
)
;
}
}
pub
struct
Root
<
'
a
'
b
T
>
{
root_list
:
&
'
a
RootCollection
jsref
:
JSRef
<
'
b
T
>
ptr
:
*
T
js_ptr
:
*
mut
JSObject
}
impl
<
'
a
'
b
T
:
Reflectable
>
Root
<
'
a
'
b
T
>
{
fn
new
(
roots
:
&
'
a
RootCollection
unrooted
:
&
JS
<
T
>
)
-
>
Root
<
'
a
'
b
T
>
{
let
root
=
Root
{
root_list
:
roots
jsref
:
JSRef
{
ptr
:
unrooted
.
ptr
.
clone
(
)
chain
:
ContravariantLifetime
}
ptr
:
unrooted
.
ptr
.
clone
(
)
js_ptr
:
unrooted
.
reflector
(
)
.
get_jsobject
(
)
}
;
roots
.
root
(
&
root
)
;
root
}
pub
fn
root_ref
<
'
b
>
(
&
'
b
self
)
-
>
JSRef
<
'
b
T
>
{
self
.
jsref
.
clone
(
)
}
}
#
[
unsafe_destructor
]
impl
<
'
a
'
b
T
:
Reflectable
>
Drop
for
Root
<
'
a
'
b
T
>
{
fn
drop
(
&
mut
self
)
{
self
.
root_list
.
unroot
(
self
)
;
}
}
impl
<
'
a
'
b
T
:
Reflectable
>
Deref
<
JSRef
<
'
b
T
>
>
for
Root
<
'
a
'
b
T
>
{
fn
deref
<
'
c
>
(
&
'
c
self
)
-
>
&
'
c
JSRef
<
'
b
T
>
{
&
self
.
jsref
}
}
impl
<
'
a
'
b
T
:
Reflectable
>
DerefMut
<
JSRef
<
'
b
T
>
>
for
Root
<
'
a
'
b
T
>
{
fn
deref_mut
<
'
c
>
(
&
'
c
mut
self
)
-
>
&
'
c
mut
JSRef
<
'
b
T
>
{
&
mut
self
.
jsref
}
}
impl
<
'
a
T
:
Reflectable
>
Deref
<
T
>
for
JSRef
<
'
a
T
>
{
fn
deref
<
'
b
>
(
&
'
b
self
)
-
>
&
'
b
T
{
unsafe
{
&
*
self
.
ptr
}
}
}
impl
<
'
a
T
:
Reflectable
>
DerefMut
<
T
>
for
JSRef
<
'
a
T
>
{
fn
deref_mut
<
'
b
>
(
&
'
b
mut
self
)
-
>
&
'
b
mut
T
{
unsafe
{
&
mut
*
(
self
.
ptr
as
*
mut
T
)
}
}
}
pub
struct
JSRef
<
'
a
T
>
{
ptr
:
*
T
chain
:
ContravariantLifetime
<
'
a
>
}
impl
<
'
a
T
>
Clone
for
JSRef
<
'
a
T
>
{
fn
clone
(
&
self
)
-
>
JSRef
<
'
a
T
>
{
JSRef
{
ptr
:
self
.
ptr
.
clone
(
)
chain
:
self
.
chain
}
}
}
impl
<
'
a
T
>
Eq
for
JSRef
<
'
a
T
>
{
fn
eq
(
&
self
other
:
&
JSRef
<
T
>
)
-
>
bool
{
self
.
ptr
=
=
other
.
ptr
}
}
impl
<
'
a
T
>
JSRef
<
'
a
T
>
{
pub
unsafe
fn
transmute
<
'
b
To
>
(
&
'
b
self
)
-
>
&
'
b
JSRef
<
'
a
To
>
{
cast
:
:
transmute
(
self
)
}
pub
unsafe
fn
transmute_mut
<
'
b
To
>
(
&
'
b
mut
self
)
-
>
&
'
b
mut
JSRef
<
'
a
To
>
{
cast
:
:
transmute
(
self
)
}
pub
fn
unrooted
(
&
self
)
-
>
JS
<
T
>
{
JS
{
ptr
:
self
.
ptr
}
}
}
impl
<
'
a
T
:
Reflectable
>
Reflectable
for
JSRef
<
'
a
T
>
{
fn
reflector
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Reflector
{
self
.
deref
(
)
.
reflector
(
)
}
fn
mut_reflector
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Reflector
{
self
.
deref_mut
(
)
.
mut_reflector
(
)
}
}
