use
std
:
:
collections
:
:
hashmap
:
:
HashMap
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
URLSearchParamsBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
UnionTypes
:
:
StringOrURLSearchParams
:
:
{
StringOrURLSearchParams
eURLSearchParams
eString
}
;
use
dom
:
:
bindings
:
:
error
:
:
{
Fallible
}
;
use
dom
:
:
bindings
:
:
global
:
:
GlobalRef
;
use
dom
:
:
bindings
:
:
js
:
:
{
JSRef
Temporary
}
;
use
dom
:
:
bindings
:
:
trace
:
:
Traceable
;
use
dom
:
:
bindings
:
:
utils
:
:
{
Reflectable
Reflector
reflect_dom_object
}
;
use
encoding
:
:
all
:
:
UTF_8
;
use
encoding
:
:
types
:
:
{
Encoding
EncodeReplace
}
;
use
servo_util
:
:
str
:
:
DOMString
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
num
:
:
ToStrRadix
;
use
std
:
:
ascii
:
:
OwnedStrAsciiExt
;
#
[
deriving
(
Encodable
)
]
pub
struct
URLSearchParams
{
data
:
Traceable
<
RefCell
<
HashMap
<
DOMString
Vec
<
DOMString
>
>
>
>
reflector_
:
Reflector
}
impl
URLSearchParams
{
pub
fn
new_inherited
(
)
-
>
URLSearchParams
{
URLSearchParams
{
data
:
Traceable
:
:
new
(
RefCell
:
:
new
(
HashMap
:
:
new
(
)
)
)
reflector_
:
Reflector
:
:
new
(
)
}
}
pub
fn
new
(
global
:
&
GlobalRef
)
-
>
Temporary
<
URLSearchParams
>
{
reflect_dom_object
(
box
URLSearchParams
:
:
new_inherited
(
)
global
URLSearchParamsBinding
:
:
Wrap
)
}
pub
fn
Constructor
(
global
:
&
GlobalRef
init
:
Option
<
StringOrURLSearchParams
>
)
-
>
Fallible
<
Temporary
<
URLSearchParams
>
>
{
let
usp
=
URLSearchParams
:
:
new
(
global
)
.
root
(
)
;
match
init
{
Some
(
eString
(
_s
)
)
=
>
{
}
Some
(
eURLSearchParams
(
u
)
)
=
>
{
let
u
=
u
.
root
(
)
;
let
mut
map
=
usp
.
deref
(
)
.
data
.
deref
(
)
.
borrow_mut
(
)
;
*
map
=
u
.
data
.
deref
(
)
.
borrow
(
)
.
clone
(
)
;
}
None
=
>
{
}
}
Ok
(
Temporary
:
:
from_rooted
(
&
*
usp
)
)
}
}
pub
trait
URLSearchParamsMethods
{
fn
Append
(
&
self
name
:
DOMString
value
:
DOMString
)
;
fn
Delete
(
&
self
name
:
DOMString
)
;
fn
Get
(
&
self
name
:
DOMString
)
-
>
Option
<
DOMString
>
;
fn
Has
(
&
self
name
:
DOMString
)
-
>
bool
;
fn
Set
(
&
self
name
:
DOMString
value
:
DOMString
)
;
}
impl
<
'
a
>
URLSearchParamsMethods
for
JSRef
<
'
a
URLSearchParams
>
{
fn
Append
(
&
self
name
:
DOMString
value
:
DOMString
)
{
self
.
data
.
deref
(
)
.
borrow_mut
(
)
.
insert_or_update_with
(
name
vec
!
(
value
.
clone
(
)
)
|
_k
v
|
v
.
push
(
value
.
clone
(
)
)
)
;
self
.
update_steps
(
)
;
}
fn
Delete
(
&
self
name
:
DOMString
)
{
self
.
data
.
deref
(
)
.
borrow_mut
(
)
.
remove
(
&
name
)
;
self
.
update_steps
(
)
;
}
fn
Get
(
&
self
name
:
DOMString
)
-
>
Option
<
DOMString
>
{
self
.
data
.
deref
(
)
.
borrow
(
)
.
find_equiv
(
&
name
)
.
map
(
|
v
|
v
.
get
(
0
)
.
clone
(
)
)
}
fn
Has
(
&
self
name
:
DOMString
)
-
>
bool
{
self
.
data
.
deref
(
)
.
borrow
(
)
.
contains_key_equiv
(
&
name
)
}
fn
Set
(
&
self
name
:
DOMString
value
:
DOMString
)
{
self
.
data
.
deref
(
)
.
borrow_mut
(
)
.
insert
(
name
vec
!
(
value
)
)
;
self
.
update_steps
(
)
;
}
}
impl
Reflectable
for
URLSearchParams
{
fn
reflector
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Reflector
{
&
self
.
reflector_
}
}
pub
trait
URLSearchParamsHelpers
{
fn
serialize
(
&
self
encoding
:
Option
<
&
'
static
Encoding
>
)
-
>
Vec
<
u8
>
;
fn
update_steps
(
&
self
)
;
}
impl
URLSearchParamsHelpers
for
URLSearchParams
{
fn
serialize
(
&
self
encoding
:
Option
<
&
'
static
Encoding
>
)
-
>
Vec
<
u8
>
{
fn
serialize_string
(
value
:
&
DOMString
encoding
:
&
'
static
Encoding
)
-
>
Vec
<
u8
>
{
let
value
=
value
.
as_slice
(
)
;
let
value
=
encoding
.
encode
(
value
EncodeReplace
)
.
unwrap
(
)
;
let
mut
buf
=
vec
!
(
)
;
for
i
in
value
.
iter
(
)
{
let
append
=
match
*
i
{
0x20
=
>
vec
!
(
0x2B
)
0x2A
|
0x2D
|
0x2E
|
0x30
.
.
0x39
|
0x41
.
.
0x5A
|
0x5F
|
0x61
.
.
0x7A
=
>
vec
!
(
*
i
)
a
=
>
{
let
mut
encoded
=
vec
!
(
0x25
)
;
encoded
.
push_all
(
a
.
to_str_radix
(
16
)
.
into_ascii_upper
(
)
.
as_bytes
(
)
)
;
encoded
}
}
;
buf
.
push_all
(
append
.
as_slice
(
)
)
;
}
buf
}
let
encoding
=
encoding
.
unwrap_or
(
UTF_8
as
&
'
static
Encoding
)
;
let
mut
buf
=
vec
!
(
)
;
let
mut
first_pair
=
true
;
for
(
k
v
)
in
self
.
data
.
deref
(
)
.
borrow
(
)
.
iter
(
)
{
let
name
=
serialize_string
(
k
encoding
)
;
for
val
in
v
.
iter
(
)
{
let
value
=
serialize_string
(
val
encoding
)
;
if
first_pair
{
first_pair
=
false
;
}
else
{
buf
.
push
(
0x26
)
;
}
buf
.
push_all
(
name
.
as_slice
(
)
)
;
buf
.
push
(
0x3D
)
;
buf
.
push_all
(
value
.
as_slice
(
)
)
}
}
buf
}
fn
update_steps
(
&
self
)
{
}
}
