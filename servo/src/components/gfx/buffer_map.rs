use
collections
:
:
hashmap
:
:
HashMap
;
use
geom
:
:
size
:
:
Size2D
;
use
layers
:
:
platform
:
:
surface
:
:
NativePaintingGraphicsContext
;
use
servo_msg
:
:
compositor_msg
:
:
Tile
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
hash
:
:
sip
:
:
SipState
;
use
std
:
:
mem
;
pub
struct
BufferMap
<
T
>
{
map
:
HashMap
<
BufferKey
BufferValue
<
T
>
>
mem
:
uint
max_mem
:
uint
counter
:
uint
}
struct
BufferKey
(
[
uint
.
.
2
]
)
;
impl
Hash
for
BufferKey
{
fn
hash
(
&
self
state
:
&
mut
SipState
)
{
let
BufferKey
(
ref
bytes
)
=
*
self
;
bytes
.
as_slice
(
)
.
hash
(
state
)
;
}
}
impl
Eq
for
BufferKey
{
fn
eq
(
&
self
other
:
&
BufferKey
)
-
>
bool
{
let
BufferKey
(
s
)
=
*
self
;
let
BufferKey
(
o
)
=
*
other
;
s
[
0
]
=
=
o
[
0
]
&
&
s
[
1
]
=
=
o
[
1
]
}
}
impl
TotalEq
for
BufferKey
{
fn
equals
(
&
self
other
:
&
BufferKey
)
-
>
bool
{
self
.
eq
(
other
)
}
}
/
/
/
Create
a
key
from
a
given
size
impl
BufferKey
{
fn
get
(
input
:
Size2D
<
uint
>
)
-
>
BufferKey
{
BufferKey
(
[
input
.
width
input
.
height
]
)
}
}
/
/
/
A
helper
struct
to
keep
track
of
buffers
in
the
HashMap
struct
BufferValue
<
T
>
{
/
/
/
An
array
of
buffers
all
the
same
size
buffers
:
~
[
T
]
/
/
/
The
counter
when
this
size
was
last
requested
last_action
:
uint
}
impl
<
T
:
Tile
>
BufferMap
<
T
>
{
/
/
Creates
a
new
BufferMap
with
a
given
buffer
limit
.
pub
fn
new
(
max_mem
:
uint
)
-
>
BufferMap
<
T
>
{
BufferMap
{
map
:
HashMap
:
:
new
(
)
mem
:
0u
max_mem
:
max_mem
counter
:
0u
}
}
/
/
/
Insert
a
new
buffer
into
the
map
.
pub
fn
insert
(
&
mut
self
graphics_context
:
&
NativePaintingGraphicsContext
new_buffer
:
T
)
{
let
new_key
=
BufferKey
:
:
get
(
new_buffer
.
get_size_2d
(
)
)
;
/
/
If
all
our
buffers
are
the
same
size
and
we
'
re
already
at
our
/
/
memory
limit
no
need
to
store
this
new
buffer
;
just
let
it
drop
.
if
self
.
mem
+
new_buffer
.
get_mem
(
)
>
self
.
max_mem
&
&
self
.
map
.
len
(
)
=
=
1
&
&
self
.
map
.
contains_key
(
&
new_key
)
{
new_buffer
.
destroy
(
graphics_context
)
;
return
;
}
self
.
mem
+
=
new_buffer
.
get_mem
(
)
;
/
/
use
lazy
insertion
function
to
prevent
unnecessary
allocation
let
counter
=
&
self
.
counter
;
self
.
map
.
find_or_insert_with
(
new_key
|
_
|
BufferValue
{
buffers
:
~
[
]
last_action
:
*
counter
}
)
.
buffers
.
push
(
new_buffer
)
;
let
mut
opt_key
:
Option
<
BufferKey
>
=
None
;
while
self
.
mem
>
self
.
max_mem
{
let
old_key
=
match
opt_key
{
Some
(
key
)
=
>
key
None
=
>
{
match
self
.
map
.
iter
(
)
.
min_by
(
|
&
(
_
x
)
|
x
.
last_action
)
{
Some
(
(
k
_
)
)
=
>
*
k
None
=
>
fail
!
(
"
BufferMap
:
tried
to
delete
with
no
elements
in
map
"
)
}
}
}
;
if
{
let
list
=
&
mut
self
.
map
.
get_mut
(
&
old_key
)
.
buffers
;
let
condemned_buffer
=
list
.
pop
(
)
.
take_unwrap
(
)
;
self
.
mem
-
=
condemned_buffer
.
get_mem
(
)
;
condemned_buffer
.
destroy
(
graphics_context
)
;
list
.
is_empty
(
)
}
{
self
.
map
.
pop
(
&
old_key
)
;
opt_key
=
None
;
}
else
{
opt_key
=
Some
(
old_key
)
;
}
}
}
pub
fn
find
(
&
mut
self
size
:
Size2D
<
uint
>
)
-
>
Option
<
T
>
{
let
mut
flag
=
false
;
let
key
=
BufferKey
:
:
get
(
size
)
;
let
ret
=
match
self
.
map
.
find_mut
(
&
key
)
{
Some
(
ref
mut
buffer_val
)
=
>
{
buffer_val
.
last_action
=
self
.
counter
;
self
.
counter
+
=
1
;
let
buffer
=
buffer_val
.
buffers
.
pop
(
)
.
take_unwrap
(
)
;
self
.
mem
-
=
buffer
.
get_mem
(
)
;
if
buffer_val
.
buffers
.
is_empty
(
)
{
flag
=
true
;
}
Some
(
buffer
)
}
None
=
>
None
}
;
if
flag
{
self
.
map
.
pop
(
&
key
)
;
}
ret
}
pub
fn
clear
(
&
mut
self
graphics_context
:
&
NativePaintingGraphicsContext
)
{
let
map
=
mem
:
:
replace
(
&
mut
self
.
map
HashMap
:
:
new
(
)
)
;
for
(
_
value
)
in
map
.
move_iter
(
)
{
for
tile
in
value
.
buffers
.
move_iter
(
)
{
tile
.
destroy
(
graphics_context
)
}
}
self
.
mem
=
0
}
}
