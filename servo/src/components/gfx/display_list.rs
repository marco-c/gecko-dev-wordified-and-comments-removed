use
color
:
:
Color
;
use
render_context
:
:
RenderContext
;
use
text
:
:
TextRun
;
use
geom
:
:
{
Point2D
Rect
SideOffsets2D
Size2D
}
;
use
libc
:
:
uintptr_t
;
use
servo_net
:
:
image
:
:
base
:
:
Image
;
use
servo_util
:
:
geometry
:
:
Au
;
use
servo_util
:
:
range
:
:
Range
;
use
servo_util
:
:
smallvec
:
:
{
SmallVec
SmallVec0
SmallVecIterator
}
;
use
std
:
:
mem
;
use
std
:
:
slice
:
:
Items
;
use
style
:
:
computed_values
:
:
border_style
;
use
sync
:
:
Arc
;
#
[
deriving
(
Clone
Eq
)
]
pub
struct
OpaqueNode
(
pub
uintptr_t
)
;
impl
OpaqueNode
{
pub
fn
id
(
&
self
)
-
>
uintptr_t
{
let
OpaqueNode
(
pointer
)
=
*
self
;
pointer
}
}
pub
struct
StackingContext
{
pub
background_and_borders
:
DisplayList
pub
block_backgrounds_and_borders
:
DisplayList
pub
floats
:
DisplayList
pub
content
:
DisplayList
pub
positioned_descendants
:
SmallVec0
<
(
int
DisplayList
)
>
}
impl
StackingContext
{
pub
fn
new
(
)
-
>
StackingContext
{
StackingContext
{
background_and_borders
:
DisplayList
:
:
new
(
)
block_backgrounds_and_borders
:
DisplayList
:
:
new
(
)
floats
:
DisplayList
:
:
new
(
)
content
:
DisplayList
:
:
new
(
)
positioned_descendants
:
SmallVec0
:
:
new
(
)
}
}
pub
fn
list_for_background_and_border_level
<
'
a
>
(
&
'
a
mut
self
level
:
BackgroundAndBorderLevel
)
-
>
&
'
a
mut
DisplayList
{
match
level
{
RootOfStackingContextLevel
=
>
&
mut
self
.
background_and_borders
BlockLevel
=
>
&
mut
self
.
block_backgrounds_and_borders
ContentLevel
=
>
&
mut
self
.
content
}
}
pub
fn
flatten
(
self
)
-
>
DisplayList
{
let
StackingContext
{
background_and_borders
:
mut
result
block_backgrounds_and_borders
floats
content
positioned_descendants
:
mut
positioned_descendants
}
=
self
;
for
&
(
ref
mut
z_index
ref
mut
list
)
in
positioned_descendants
.
mut_iter
(
)
{
if
*
z_index
<
0
{
result
.
push_all_move
(
mem
:
:
replace
(
list
DisplayList
:
:
new
(
)
)
)
}
}
result
.
push_all_move
(
block_backgrounds_and_borders
)
;
result
.
push_all_move
(
floats
)
;
result
.
push_all_move
(
content
)
;
for
&
(
ref
mut
z_index
ref
mut
list
)
in
positioned_descendants
.
mut_iter
(
)
{
if
*
z_index
>
=
0
{
result
.
push_all_move
(
mem
:
:
replace
(
list
DisplayList
:
:
new
(
)
)
)
}
}
result
}
}
pub
enum
BackgroundAndBorderLevel
{
RootOfStackingContextLevel
BlockLevel
ContentLevel
}
pub
struct
DisplayList
{
pub
list
:
SmallVec0
<
DisplayItem
>
}
pub
enum
DisplayListIterator
<
'
a
>
{
EmptyDisplayListIterator
ParentDisplayListIterator
(
Items
<
'
a
DisplayList
>
)
}
impl
<
'
a
>
Iterator
<
&
'
a
DisplayList
>
for
DisplayListIterator
<
'
a
>
{
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
DisplayList
>
{
match
*
self
{
EmptyDisplayListIterator
=
>
None
ParentDisplayListIterator
(
ref
mut
subiterator
)
=
>
subiterator
.
next
(
)
}
}
}
impl
DisplayList
{
pub
fn
new
(
)
-
>
DisplayList
{
DisplayList
{
list
:
SmallVec0
:
:
new
(
)
}
}
fn
dump
(
&
self
)
{
for
item
in
self
.
list
.
iter
(
)
{
item
.
debug_with_level
(
0
)
;
}
}
pub
fn
push
(
&
mut
self
item
:
DisplayItem
)
{
self
.
list
.
push
(
item
)
}
pub
fn
push_all_move
(
&
mut
self
other
:
DisplayList
)
{
self
.
list
.
push_all_move
(
other
.
list
)
}
pub
fn
draw_into_context
(
&
self
render_context
:
&
mut
RenderContext
)
{
debug
!
(
"
Beginning
display
list
.
"
)
;
for
item
in
self
.
list
.
iter
(
)
{
item
.
draw_into_context
(
render_context
)
}
debug
!
(
"
Ending
display
list
.
"
)
;
}
pub
fn
iter
<
'
a
>
(
&
'
a
self
)
-
>
DisplayItemIterator
<
'
a
>
{
ParentDisplayItemIterator
(
self
.
list
.
iter
(
)
)
}
}
pub
enum
DisplayItem
{
SolidColorDisplayItemClass
(
~
SolidColorDisplayItem
)
TextDisplayItemClass
(
~
TextDisplayItem
)
ImageDisplayItemClass
(
~
ImageDisplayItem
)
BorderDisplayItemClass
(
~
BorderDisplayItem
)
LineDisplayItemClass
(
~
LineDisplayItem
)
ClipDisplayItemClass
(
~
ClipDisplayItem
)
}
/
/
/
Information
common
to
all
display
items
.
pub
struct
BaseDisplayItem
{
/
/
/
The
boundaries
of
the
display
item
.
/
/
/
/
/
/
TODO
:
Which
coordinate
system
should
this
use
?
pub
bounds
:
Rect
<
Au
>
/
/
/
The
originating
DOM
node
.
pub
node
:
OpaqueNode
}
/
/
/
Renders
a
solid
color
.
pub
struct
SolidColorDisplayItem
{
pub
base
:
BaseDisplayItem
pub
color
:
Color
}
/
/
/
Renders
text
.
pub
struct
TextDisplayItem
{
/
/
/
Fields
common
to
all
display
items
.
pub
base
:
BaseDisplayItem
/
/
/
The
text
run
.
pub
text_run
:
Arc
<
~
TextRun
>
/
/
/
The
range
of
text
within
the
text
run
.
pub
range
:
Range
/
/
/
The
color
of
the
text
.
pub
text_color
:
Color
/
/
/
A
bitfield
of
flags
for
text
display
items
.
pub
flags
:
TextDisplayItemFlags
/
/
/
The
color
of
text
-
decorations
pub
underline_color
:
Color
pub
overline_color
:
Color
pub
line_through_color
:
Color
}
/
/
/
Flags
for
text
display
items
.
pub
struct
TextDisplayItemFlags
(
pub
u8
)
;
impl
TextDisplayItemFlags
{
pub
fn
new
(
)
-
>
TextDisplayItemFlags
{
TextDisplayItemFlags
(
0
)
}
}
/
/
Whether
underlining
is
forced
on
.
bitfield
!
(
TextDisplayItemFlags
override_underline
set_override_underline
0x01
)
/
/
Whether
overlining
is
forced
on
.
bitfield
!
(
TextDisplayItemFlags
override_overline
set_override_overline
0x02
)
/
/
Whether
line
-
through
is
forced
on
.
bitfield
!
(
TextDisplayItemFlags
override_line_through
set_override_line_through
0x04
)
/
/
/
Renders
an
image
.
pub
struct
ImageDisplayItem
{
pub
base
:
BaseDisplayItem
pub
image
:
Arc
<
~
Image
>
/
/
/
The
dimensions
to
which
the
image
display
item
should
be
stretched
.
If
this
is
smaller
than
/
/
/
the
bounds
of
this
display
item
then
the
image
will
be
repeated
in
the
appropriate
/
/
/
direction
to
tile
the
entire
bounds
.
pub
stretch_size
:
Size2D
<
Au
>
}
/
/
/
Renders
a
border
.
pub
struct
BorderDisplayItem
{
pub
base
:
BaseDisplayItem
/
/
/
The
border
widths
pub
border
:
SideOffsets2D
<
Au
>
/
/
/
The
border
colors
.
pub
color
:
SideOffsets2D
<
Color
>
/
/
/
The
border
styles
.
pub
style
:
SideOffsets2D
<
border_style
:
:
T
>
}
/
/
/
Renders
a
line
segment
.
pub
struct
LineDisplayItem
{
pub
base
:
BaseDisplayItem
/
/
/
The
line
segment
color
.
pub
color
:
Color
/
/
/
The
line
segment
style
.
pub
style
:
border_style
:
:
T
}
pub
struct
ClipDisplayItem
{
pub
base
:
BaseDisplayItem
pub
child_list
:
SmallVec0
<
DisplayItem
>
pub
need_clip
:
bool
}
pub
enum
DisplayItemIterator
<
'
a
>
{
EmptyDisplayItemIterator
ParentDisplayItemIterator
(
SmallVecIterator
<
'
a
DisplayItem
>
)
}
impl
<
'
a
>
Iterator
<
&
'
a
DisplayItem
>
for
DisplayItemIterator
<
'
a
>
{
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
DisplayItem
>
{
match
*
self
{
EmptyDisplayItemIterator
=
>
None
ParentDisplayItemIterator
(
ref
mut
subiterator
)
=
>
subiterator
.
next
(
)
}
}
}
impl
DisplayItem
{
/
/
/
Renders
this
display
item
into
the
given
render
context
.
fn
draw_into_context
(
&
self
render_context
:
&
mut
RenderContext
)
{
match
*
self
{
SolidColorDisplayItemClass
(
ref
solid_color
)
=
>
{
render_context
.
draw_solid_color
(
&
solid_color
.
base
.
bounds
solid_color
.
color
)
}
ClipDisplayItemClass
(
ref
clip
)
=
>
{
if
clip
.
need_clip
{
render_context
.
draw_push_clip
(
&
clip
.
base
.
bounds
)
;
}
for
item
in
clip
.
child_list
.
iter
(
)
{
(
*
item
)
.
draw_into_context
(
render_context
)
;
}
if
clip
.
need_clip
{
render_context
.
draw_pop_clip
(
)
;
}
}
TextDisplayItemClass
(
ref
text
)
=
>
{
debug
!
(
"
Drawing
text
at
{
:
?
}
.
"
text
.
base
.
bounds
)
;
/
/
FIXME
(
pcwalton
)
:
Allocating
?
Why
?
let
text_run
=
text
.
text_run
.
clone
(
)
;
let
font
=
render_context
.
font_ctx
.
get_font_by_descriptor
(
&
text_run
.
font_descriptor
)
.
unwrap
(
)
;
let
font_metrics
=
{
font
.
borrow
(
)
.
metrics
.
clone
(
)
}
;
let
origin
=
text
.
base
.
bounds
.
origin
;
let
baseline_origin
=
Point2D
(
origin
.
x
origin
.
y
+
font_metrics
.
ascent
)
;
{
font
.
borrow_mut
(
)
.
draw_text_into_context
(
render_context
&
*
text
.
text_run
&
text
.
range
baseline_origin
text
.
text_color
)
;
}
let
width
=
text
.
base
.
bounds
.
size
.
width
;
let
underline_size
=
font_metrics
.
underline_size
;
let
underline_offset
=
font_metrics
.
underline_offset
;
let
strikeout_size
=
font_metrics
.
strikeout_size
;
let
strikeout_offset
=
font_metrics
.
strikeout_offset
;
if
text_run
.
decoration
.
underline
|
|
text
.
flags
.
override_underline
(
)
{
let
underline_y
=
baseline_origin
.
y
-
underline_offset
;
let
underline_bounds
=
Rect
(
Point2D
(
baseline_origin
.
x
underline_y
)
Size2D
(
width
underline_size
)
)
;
render_context
.
draw_solid_color
(
&
underline_bounds
text
.
underline_color
)
;
}
if
text_run
.
decoration
.
overline
|
|
text
.
flags
.
override_overline
(
)
{
let
overline_bounds
=
Rect
(
Point2D
(
baseline_origin
.
x
origin
.
y
)
Size2D
(
width
underline_size
)
)
;
render_context
.
draw_solid_color
(
&
overline_bounds
text
.
overline_color
)
;
}
if
text_run
.
decoration
.
line_through
|
|
text
.
flags
.
override_line_through
(
)
{
let
strikeout_y
=
baseline_origin
.
y
-
strikeout_offset
;
let
strikeout_bounds
=
Rect
(
Point2D
(
baseline_origin
.
x
strikeout_y
)
Size2D
(
width
strikeout_size
)
)
;
render_context
.
draw_solid_color
(
&
strikeout_bounds
text
.
line_through_color
)
;
}
}
ImageDisplayItemClass
(
ref
image_item
)
=
>
{
debug
!
(
"
Drawing
image
at
{
:
?
}
.
"
image_item
.
base
.
bounds
)
;
let
mut
y_offset
=
Au
(
0
)
;
while
y_offset
<
image_item
.
base
.
bounds
.
size
.
height
{
let
mut
x_offset
=
Au
(
0
)
;
while
x_offset
<
image_item
.
base
.
bounds
.
size
.
width
{
let
mut
bounds
=
image_item
.
base
.
bounds
;
bounds
.
origin
.
x
=
bounds
.
origin
.
x
+
x_offset
;
bounds
.
origin
.
y
=
bounds
.
origin
.
y
+
y_offset
;
bounds
.
size
=
image_item
.
stretch_size
;
render_context
.
draw_image
(
bounds
image_item
.
image
.
clone
(
)
)
;
x_offset
=
x_offset
+
image_item
.
stretch_size
.
width
;
}
y_offset
=
y_offset
+
image_item
.
stretch_size
.
height
;
}
}
BorderDisplayItemClass
(
ref
border
)
=
>
{
render_context
.
draw_border
(
&
border
.
base
.
bounds
border
.
border
border
.
color
border
.
style
)
}
LineDisplayItemClass
(
ref
line
)
=
>
{
render_context
.
draw_line
(
&
line
.
base
.
bounds
line
.
color
line
.
style
)
}
}
}
pub
fn
base
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
BaseDisplayItem
{
match
*
self
{
SolidColorDisplayItemClass
(
ref
solid_color
)
=
>
&
solid_color
.
base
TextDisplayItemClass
(
ref
text
)
=
>
&
text
.
base
ImageDisplayItemClass
(
ref
image_item
)
=
>
&
image_item
.
base
BorderDisplayItemClass
(
ref
border
)
=
>
&
border
.
base
LineDisplayItemClass
(
ref
line
)
=
>
&
line
.
base
ClipDisplayItemClass
(
ref
clip
)
=
>
&
clip
.
base
}
}
pub
fn
bounds
(
&
self
)
-
>
Rect
<
Au
>
{
self
.
base
(
)
.
bounds
}
pub
fn
children
<
'
a
>
(
&
'
a
self
)
-
>
DisplayItemIterator
<
'
a
>
{
match
*
self
{
ClipDisplayItemClass
(
ref
clip
)
=
>
ParentDisplayItemIterator
(
clip
.
child_list
.
iter
(
)
)
SolidColorDisplayItemClass
(
.
.
)
|
TextDisplayItemClass
(
.
.
)
|
ImageDisplayItemClass
(
.
.
)
|
BorderDisplayItemClass
(
.
.
)
|
LineDisplayItemClass
(
.
.
)
=
>
EmptyDisplayItemIterator
}
}
pub
fn
debug_with_level
(
&
self
level
:
uint
)
{
let
mut
indent
=
~
"
"
;
for
_
in
range
(
0
level
)
{
indent
.
push_str
(
"
|
"
)
}
debug
!
(
"
{
}
+
{
}
"
indent
self
.
debug_str
(
)
)
;
for
child
in
self
.
children
(
)
{
child
.
debug_with_level
(
level
+
1
)
;
}
}
pub
fn
debug_str
(
&
self
)
-
>
~
str
{
let
class
=
match
*
self
{
SolidColorDisplayItemClass
(
_
)
=
>
"
SolidColor
"
TextDisplayItemClass
(
_
)
=
>
"
Text
"
ImageDisplayItemClass
(
_
)
=
>
"
Image
"
BorderDisplayItemClass
(
_
)
=
>
"
Border
"
LineDisplayItemClass
(
_
)
=
>
"
Line
"
ClipDisplayItemClass
(
_
)
=
>
"
Clip
"
}
;
format
!
(
"
{
}
{
:
?
}
"
class
self
.
base
(
)
.
bounds
)
}
}
