use
compositor_task
:
:
LayerProperties
;
use
events
;
use
pipeline
:
:
CompositionPipeline
;
use
azure
:
:
azure_hl
:
:
Color
;
use
geom
:
:
matrix
:
:
identity
;
use
geom
:
:
point
:
:
{
Point2D
TypedPoint2D
}
;
use
geom
:
:
rect
:
:
Rect
;
use
geom
:
:
size
:
:
{
Size2D
TypedSize2D
}
;
use
gfx
:
:
render_task
:
:
{
ReRenderMsg
UnusedBufferMsg
}
;
use
layers
:
:
layers
:
:
{
Layer
Flip
LayerBuffer
LayerBufferSet
NoFlip
TextureLayer
}
;
use
layers
:
:
quadtree
:
:
{
Tile
Normal
Hidden
}
;
use
layers
:
:
platform
:
:
surface
:
:
{
NativeCompositingGraphicsContext
NativeSurfaceMethods
}
;
use
layers
:
:
texturegl
:
:
{
Texture
TextureTarget
}
;
use
servo_msg
:
:
compositor_msg
:
:
{
Epoch
FixedPosition
LayerId
}
;
use
servo_msg
:
:
compositor_msg
:
:
ScrollPolicy
;
use
servo_msg
:
:
constellation_msg
:
:
PipelineId
;
use
servo_util
:
:
geometry
:
:
PagePx
;
use
std
:
:
rc
:
:
Rc
;
#
[
cfg
(
target_os
=
"
macos
"
)
]
#
[
cfg
(
target_os
=
"
android
"
)
]
use
layers
:
:
layers
:
:
VerticalFlip
;
#
[
cfg
(
not
(
target_os
=
"
macos
"
)
)
]
use
layers
:
:
texturegl
:
:
TextureTarget2D
;
#
[
cfg
(
target_os
=
"
macos
"
)
]
use
layers
:
:
texturegl
:
:
TextureTargetRectangle
;
pub
struct
CompositorData
{
pub
pipeline
:
CompositionPipeline
pub
id
:
LayerId
pub
scroll_offset
:
TypedPoint2D
<
PagePx
f32
>
pub
bounds
:
Rect
<
f32
>
pub
page_size
:
Option
<
Size2D
<
f32
>
>
pub
hidden
:
bool
pub
wants_scroll_events
:
WantsScrollEventsFlag
pub
scroll_policy
:
ScrollPolicy
pub
cpu_painting
:
bool
pub
unrendered_color
:
Color
pub
scissor
:
Option
<
Rect
<
f32
>
>
pub
epoch
:
Epoch
}
#
[
deriving
(
PartialEq
Clone
)
]
pub
enum
WantsScrollEventsFlag
{
WantsScrollEvents
DoesntWantScrollEvents
}
impl
CompositorData
{
pub
fn
new
(
pipeline
:
CompositionPipeline
layer_id
:
LayerId
epoch
:
Epoch
bounds
:
Rect
<
f32
>
page_size
:
Option
<
Size2D
<
f32
>
>
cpu_painting
:
bool
wants_scroll_events
:
WantsScrollEventsFlag
scroll_policy
:
ScrollPolicy
unrendered_color
:
Color
)
-
>
CompositorData
{
CompositorData
{
pipeline
:
pipeline
id
:
layer_id
scroll_offset
:
TypedPoint2D
(
0f32
0f32
)
bounds
:
bounds
page_size
:
page_size
hidden
:
false
wants_scroll_events
:
wants_scroll_events
scroll_policy
:
scroll_policy
cpu_painting
:
cpu_painting
unrendered_color
:
unrendered_color
scissor
:
None
epoch
:
epoch
}
}
pub
fn
new_root
(
pipeline
:
CompositionPipeline
epoch
:
Epoch
page_size
:
Size2D
<
f32
>
cpu_painting
:
bool
unrendered_color
:
Color
)
-
>
CompositorData
{
CompositorData
:
:
new
(
pipeline
LayerId
:
:
null
(
)
epoch
Rect
(
Point2D
(
0f32
0f32
)
page_size
)
Some
(
page_size
)
cpu_painting
WantsScrollEvents
FixedPosition
unrendered_color
)
}
pub
fn
add_child
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
layer_properties
:
LayerProperties
page_size
:
Size2D
<
f32
>
)
{
let
new_compositor_data
=
CompositorData
:
:
new
(
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
clone
(
)
layer_properties
.
id
layer_properties
.
epoch
layer_properties
.
rect
Some
(
page_size
)
layer
.
extra_data
.
borrow
(
)
.
cpu_painting
DoesntWantScrollEvents
layer_properties
.
scroll_policy
layer_properties
.
background_color
)
;
let
new_kid
=
Rc
:
:
new
(
Layer
:
:
new
(
page_size
Layer
:
:
tile_size
(
layer
.
clone
(
)
)
new_compositor_data
)
)
;
new_kid
.
extra_data
.
borrow_mut
(
)
.
scissor
=
Some
(
layer_properties
.
rect
)
;
*
new_kid
.
origin
.
borrow_mut
(
)
=
layer_properties
.
rect
.
origin
;
Layer
:
:
add_child
(
layer
.
clone
(
)
new_kid
.
clone
(
)
)
;
}
pub
fn
send_buffer_requests_recursively
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
graphics_context
:
&
NativeCompositingGraphicsContext
window_rect
:
Rect
<
f32
>
scale
:
f32
)
-
>
bool
{
let
(
request
unused
)
=
Layer
:
:
get_tile_rects_page
(
layer
.
clone
(
)
window_rect
scale
)
;
let
redisplay
=
!
unused
.
is_empty
(
)
;
if
redisplay
{
let
msg
=
UnusedBufferMsg
(
unused
)
;
let
_
=
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
render_chan
.
send_opt
(
msg
)
;
}
if
!
request
.
is_empty
(
)
{
let
msg
=
ReRenderMsg
(
request
scale
layer
.
extra_data
.
borrow
(
)
.
id
layer
.
extra_data
.
borrow
(
)
.
epoch
)
;
let
_
=
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
render_chan
.
send_opt
(
msg
)
;
}
if
redisplay
{
CompositorData
:
:
build_layer_tree
(
layer
.
clone
(
)
graphics_context
)
;
}
let
send_child_buffer_request
=
|
kid
:
&
Rc
<
Layer
<
CompositorData
>
>
|
-
>
bool
{
match
kid
.
extra_data
.
borrow
(
)
.
scissor
{
Some
(
scissor
)
=
>
{
let
mut
new_rect
=
window_rect
;
let
offset
=
kid
.
extra_data
.
borrow
(
)
.
scroll_offset
.
to_untyped
(
)
;
new_rect
.
origin
.
x
=
new_rect
.
origin
.
x
-
offset
.
x
;
new_rect
.
origin
.
y
=
new_rect
.
origin
.
y
-
offset
.
y
;
match
new_rect
.
intersection
(
&
scissor
)
{
Some
(
new_rect
)
=
>
{
let
child_rect
=
Rect
(
new_rect
.
origin
.
sub
(
&
scissor
.
origin
)
new_rect
.
size
)
;
CompositorData
:
:
send_buffer_requests_recursively
(
kid
.
clone
(
)
graphics_context
child_rect
scale
)
}
None
=
>
{
false
}
}
}
None
=
>
fail
!
(
"
child
layer
not
clipped
!
"
)
}
}
;
layer
.
children
(
)
.
iter
(
)
.
filter
(
|
x
|
!
x
.
extra_data
.
borrow
(
)
.
hidden
)
.
map
(
send_child_buffer_request
)
.
any
(
|
b
|
b
)
|
|
redisplay
}
pub
fn
set_clipping_rect
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
pipeline_id
:
PipelineId
layer_id
:
LayerId
new_rect
:
Rect
<
f32
>
)
-
>
bool
{
debug
!
(
"
compositor_data
:
starting
set_clipping_rect
(
)
"
)
;
match
CompositorData
:
:
find_child_with_pipeline_and_layer_id
(
layer
.
clone
(
)
pipeline_id
layer_id
)
{
Some
(
child_node
)
=
>
{
debug
!
(
"
compositor_data
:
node
found
for
set_clipping_rect
(
)
"
)
;
*
child_node
.
origin
.
borrow_mut
(
)
=
new_rect
.
origin
;
let
old_rect
=
child_node
.
extra_data
.
borrow
(
)
.
scissor
.
clone
(
)
;
child_node
.
extra_data
.
borrow_mut
(
)
.
scissor
=
Some
(
new_rect
)
;
match
old_rect
{
Some
(
old_rect
)
=
>
{
Layer
:
:
set_status_page
(
layer
.
clone
(
)
old_rect
Normal
false
)
;
}
None
=
>
{
}
}
Layer
:
:
set_status_page
(
layer
.
clone
(
)
new_rect
Hidden
false
)
;
let
mut
child_data
=
child_node
.
extra_data
.
borrow_mut
(
)
;
if
child_data
.
hidden
&
&
child_data
.
page_size
.
is_some
(
)
{
child_data
.
hidden
=
false
;
}
true
}
None
=
>
{
layer
.
children
(
)
.
iter
(
)
.
any
(
|
kid
|
CompositorData
:
:
set_clipping_rect
(
kid
.
clone
(
)
pipeline_id
layer_id
new_rect
)
)
}
}
}
pub
fn
update_layer
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
layer_properties
:
LayerProperties
)
{
layer
.
extra_data
.
borrow_mut
(
)
.
epoch
=
layer_properties
.
epoch
;
layer
.
extra_data
.
borrow_mut
(
)
.
unrendered_color
=
layer_properties
.
background_color
;
CompositorData
:
:
resize
(
layer
.
clone
(
)
layer_properties
.
rect
.
size
)
;
}
fn
resize
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
new_size
:
Size2D
<
f32
>
)
{
debug
!
(
"
compositor_data
:
starting
resize_helper
(
)
"
)
;
debug
!
(
"
compositor_data
:
layer
found
for
resize_helper
(
)
"
)
;
layer
.
extra_data
.
borrow_mut
(
)
.
page_size
=
Some
(
new_size
)
;
let
unused_buffers
=
Layer
:
:
resize
(
layer
.
clone
(
)
new_size
)
;
if
!
unused_buffers
.
is_empty
(
)
{
let
msg
=
UnusedBufferMsg
(
unused_buffers
)
;
let
_
=
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
render_chan
.
send_opt
(
msg
)
;
}
let
scissor_clone
=
layer
.
extra_data
.
borrow
(
)
.
scissor
.
clone
(
)
;
match
scissor_clone
{
Some
(
scissor
)
=
>
{
let
size
:
TypedSize2D
<
PagePx
f32
>
=
Size2D
:
:
from_untyped
(
&
scissor
.
size
)
;
events
:
:
handle_scroll_event
(
layer
.
clone
(
)
TypedPoint2D
(
0f32
0f32
)
TypedPoint2D
(
-
1f32
-
1f32
)
size
)
;
layer
.
extra_data
.
borrow_mut
(
)
.
hidden
=
false
;
}
None
=
>
{
}
}
CompositorData
:
:
set_occlusions
(
layer
.
clone
(
)
)
;
}
#
[
cfg
(
target_os
=
"
macos
"
)
]
fn
texture_flip_and_target
(
cpu_painting
:
bool
size
:
Size2D
<
uint
>
)
-
>
(
Flip
TextureTarget
)
{
let
flip
=
if
cpu_painting
{
NoFlip
}
else
{
VerticalFlip
}
;
(
flip
TextureTargetRectangle
(
size
)
)
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
texture_flip_and_target
(
cpu_painting
:
bool
size
:
Size2D
<
uint
>
)
-
>
(
Flip
TextureTarget
)
{
let
flip
=
if
cpu_painting
{
NoFlip
}
else
{
VerticalFlip
}
;
(
flip
TextureTarget2D
)
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
texture_flip_and_target
(
_
:
bool
_
:
Size2D
<
uint
>
)
-
>
(
Flip
TextureTarget
)
{
(
NoFlip
TextureTarget2D
)
}
fn
find_child_with_pipeline_and_layer_id
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
pipeline_id
:
PipelineId
layer_id
:
LayerId
)
-
>
Option
<
Rc
<
Layer
<
CompositorData
>
>
>
{
for
kid
in
layer
.
children
(
)
.
iter
(
)
{
if
pipeline_id
=
=
kid
.
extra_data
.
borrow
(
)
.
pipeline
.
id
&
&
layer_id
=
=
kid
.
extra_data
.
borrow
(
)
.
id
{
return
Some
(
kid
.
clone
(
)
)
;
}
}
return
None
}
pub
fn
find_layer_with_pipeline_and_layer_id
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
pipeline_id
:
PipelineId
layer_id
:
LayerId
)
-
>
Option
<
Rc
<
Layer
<
CompositorData
>
>
>
{
if
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
id
=
=
pipeline_id
&
&
layer
.
extra_data
.
borrow
(
)
.
id
=
=
layer_id
{
return
Some
(
layer
.
clone
(
)
)
;
}
for
kid
in
layer
.
children
(
)
.
iter
(
)
{
match
CompositorData
:
:
find_layer_with_pipeline_and_layer_id
(
kid
.
clone
(
)
pipeline_id
layer_id
)
{
v
Some
(
_
)
=
>
{
return
v
;
}
None
=
>
{
}
}
}
return
None
;
}
pub
fn
build_layer_tree
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
graphics_context
:
&
NativeCompositingGraphicsContext
)
{
layer
.
tiles
.
borrow_mut
(
)
.
clear
(
)
;
Layer
:
:
do_for_all_tiles
(
layer
.
clone
(
)
|
buffer
:
&
Box
<
LayerBuffer
>
|
{
debug
!
(
"
osmain
:
compositing
buffer
rect
{
}
"
buffer
.
rect
)
;
let
size
=
Size2D
(
buffer
.
screen_pos
.
size
.
width
as
int
buffer
.
screen_pos
.
size
.
height
as
int
)
;
debug
!
(
"
osmain
:
adding
new
texture
layer
"
)
;
let
(
flip
target
)
=
CompositorData
:
:
texture_flip_and_target
(
layer
.
extra_data
.
borrow
(
)
.
cpu_painting
buffer
.
screen_pos
.
size
)
;
let
texture
=
Texture
:
:
new
(
target
)
;
debug
!
(
"
COMPOSITOR
binding
to
native
surface
{
:
d
}
"
buffer
.
native_surface
.
get_id
(
)
as
int
)
;
buffer
.
native_surface
.
bind_to_texture
(
graphics_context
&
texture
size
)
;
let
rect
=
buffer
.
rect
;
let
transform
=
identity
(
)
.
translate
(
rect
.
origin
.
x
rect
.
origin
.
y
0
.
0
)
;
let
transform
=
transform
.
scale
(
rect
.
size
.
width
rect
.
size
.
height
1
.
0
)
;
let
texture_layer
=
Rc
:
:
new
(
TextureLayer
:
:
new
(
texture
buffer
.
screen_pos
.
size
flip
transform
)
)
;
layer
.
tiles
.
borrow_mut
(
)
.
push
(
texture_layer
)
;
}
)
;
}
pub
fn
add_buffers
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
graphics_context
:
&
NativeCompositingGraphicsContext
new_buffers
:
Box
<
LayerBufferSet
>
epoch
:
Epoch
)
-
>
bool
{
if
layer
.
extra_data
.
borrow
(
)
.
epoch
!
=
epoch
{
debug
!
(
"
add_buffers
:
compositor
epoch
mismatch
:
{
:
?
}
!
=
{
:
?
}
id
:
{
:
?
}
"
layer
.
extra_data
.
borrow
(
)
.
epoch
epoch
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
id
)
;
let
msg
=
UnusedBufferMsg
(
new_buffers
.
buffers
)
;
let
_
=
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
render_chan
.
send_opt
(
msg
)
;
return
false
;
}
{
let
mut
unused_tiles
=
vec
!
(
)
;
for
buffer
in
new_buffers
.
buffers
.
move_iter
(
)
.
rev
(
)
{
unused_tiles
.
push_all_move
(
Layer
:
:
add_tile_pixel
(
layer
.
clone
(
)
buffer
)
)
;
}
if
!
unused_tiles
.
is_empty
(
)
{
let
msg
=
UnusedBufferMsg
(
unused_tiles
)
;
let
_
=
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
render_chan
.
send_opt
(
msg
)
;
}
}
CompositorData
:
:
build_layer_tree
(
layer
.
clone
(
)
graphics_context
)
;
return
true
;
}
fn
set_occlusions
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
)
{
for
kid
in
layer
.
children
(
)
.
iter
(
)
{
if
!
kid
.
extra_data
.
borrow
(
)
.
hidden
{
match
kid
.
extra_data
.
borrow
(
)
.
scissor
{
None
=
>
{
}
Some
(
rect
)
=
>
{
Layer
:
:
set_status_page
(
layer
.
clone
(
)
rect
Hidden
false
)
;
}
}
}
}
for
kid
in
layer
.
children
(
)
.
iter
(
)
{
if
!
kid
.
extra_data
.
borrow
(
)
.
hidden
{
CompositorData
:
:
set_occlusions
(
kid
.
clone
(
)
)
;
}
}
}
fn
clear
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
)
{
let
mut
tiles
=
Layer
:
:
collect_tiles
(
layer
.
clone
(
)
)
;
if
!
tiles
.
is_empty
(
)
{
for
tile
in
tiles
.
mut_iter
(
)
{
tile
.
mark_wont_leak
(
)
}
let
_
=
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
render_chan
.
send_opt
(
UnusedBufferMsg
(
tiles
)
)
;
}
}
pub
fn
clear_all_tiles
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
)
{
CompositorData
:
:
clear
(
layer
.
clone
(
)
)
;
for
kid
in
layer
.
children
(
)
.
iter
(
)
{
CompositorData
:
:
clear_all_tiles
(
kid
.
clone
(
)
)
;
}
}
pub
fn
forget_all_tiles
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
)
{
let
tiles
=
Layer
:
:
collect_tiles
(
layer
.
clone
(
)
)
;
for
tile
in
tiles
.
move_iter
(
)
{
let
mut
tile
=
tile
;
tile
.
mark_wont_leak
(
)
}
for
kid
in
layer
.
children
(
)
.
iter
(
)
{
CompositorData
:
:
forget_all_tiles
(
kid
.
clone
(
)
)
;
}
}
}
