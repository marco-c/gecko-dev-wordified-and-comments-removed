use
azure
:
:
azure_hl
:
:
Color
;
use
geom
:
:
point
:
:
Point2D
;
use
geom
:
:
rect
:
:
Rect
;
use
geom
:
:
size
:
:
Size2D
;
use
layers
:
:
platform
:
:
surface
:
:
{
NativeGraphicsMetadata
NativePaintingGraphicsContext
}
;
use
layers
:
:
platform
:
:
surface
:
:
{
NativeSurface
NativeSurfaceMethods
}
;
use
serialize
:
:
{
Encoder
Encodable
}
;
use
std
:
:
fmt
:
:
{
Formatter
Show
}
;
use
std
:
:
fmt
;
use
constellation_msg
:
:
PipelineId
;
pub
struct
LayerBuffer
{
native_surface
:
NativeSurface
rect
:
Rect
<
f32
>
screen_pos
:
Rect
<
uint
>
resolution
:
f32
stride
:
uint
}
pub
struct
LayerBufferSet
{
buffers
:
~
[
~
LayerBuffer
]
}
impl
LayerBufferSet
{
/
/
/
Notes
all
buffer
surfaces
will
leak
if
not
destroyed
via
a
call
to
destroy
.
pub
fn
mark_will_leak
(
&
mut
self
)
{
for
buffer
in
self
.
buffers
.
mut_iter
(
)
{
buffer
.
native_surface
.
mark_will_leak
(
)
}
}
}
/
/
/
The
status
of
the
renderer
.
#
[
deriving
(
Eq
Clone
)
]
pub
enum
RenderState
{
IdleRenderState
RenderingRenderState
}
#
[
deriving
(
Eq
Clone
)
]
pub
enum
ReadyState
{
/
/
/
Informs
the
compositor
that
nothing
has
been
done
yet
.
Used
for
setting
status
Blank
/
/
/
Informs
the
compositor
that
a
page
is
loading
.
Used
for
setting
status
Loading
/
/
/
Informs
the
compositor
that
a
page
is
performing
layout
.
Used
for
setting
status
PerformingLayout
/
/
/
Informs
the
compositor
that
a
page
is
finished
loading
.
Used
for
setting
status
FinishedLoading
}
/
/
/
A
newtype
struct
for
denoting
the
age
of
messages
;
prevents
race
conditions
.
#
[
deriving
(
Eq
)
]
pub
struct
Epoch
(
uint
)
;
impl
Epoch
{
pub
fn
next
(
&
mut
self
)
{
let
Epoch
(
ref
mut
u
)
=
*
self
;
*
u
+
=
1
;
}
}
#
[
deriving
(
Clone
Eq
)
]
pub
struct
LayerId
(
uint
uint
)
;
impl
Show
for
LayerId
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
let
LayerId
(
a
b
)
=
*
self
;
write
!
(
f
.
buf
"
Layer
(
{
}
{
}
)
"
a
b
)
;
Ok
(
(
)
)
}
}
impl
LayerId
{
pub
fn
null
(
)
-
>
LayerId
{
LayerId
(
0
0
)
}
}
#
[
deriving
(
Eq
)
]
pub
enum
ScrollPolicy
{
Scrollable
FixedPosition
}
pub
struct
LayerMetadata
{
id
:
LayerId
position
:
Rect
<
uint
>
background_color
:
Color
scroll_policy
:
ScrollPolicy
}
pub
trait
RenderListener
{
fn
get_graphics_metadata
(
&
self
)
-
>
Option
<
NativeGraphicsMetadata
>
;
fn
initialize_layers_for_pipeline
(
&
self
pipeline_id
:
PipelineId
metadata
:
~
[
LayerMetadata
]
epoch
:
Epoch
)
;
fn
set_layer_clip_rect
(
&
self
pipeline_id
:
PipelineId
layer_id
:
LayerId
new_rect
:
Rect
<
uint
>
)
;
fn
delete_layer_group
(
&
self
PipelineId
)
;
fn
paint
(
&
self
pipeline_id
:
PipelineId
layer_id
:
LayerId
layer_buffer_set
:
~
LayerBufferSet
epoch
:
Epoch
)
;
fn
set_render_state
(
&
self
render_state
:
RenderState
)
;
}
pub
trait
ScriptListener
:
Clone
{
fn
set_ready_state
(
&
self
ReadyState
)
;
fn
scroll_fragment_point
(
&
self
pipeline_id
:
PipelineId
layer_id
:
LayerId
point
:
Point2D
<
f32
>
)
;
fn
close
(
&
self
)
;
fn
dup
(
&
self
)
-
>
~
ScriptListener
;
}
impl
<
S
:
Encoder
>
Encodable
<
S
>
for
~
ScriptListener
{
fn
encode
(
&
self
_s
:
&
mut
S
)
{
}
}
pub
trait
Tile
{
fn
get_mem
(
&
self
)
-
>
uint
;
fn
is_valid
(
&
self
f32
)
-
>
bool
;
fn
get_size_2d
(
&
self
)
-
>
Size2D
<
uint
>
;
fn
mark_wont_leak
(
&
mut
self
)
;
fn
destroy
(
self
graphics_context
:
&
NativePaintingGraphicsContext
)
;
}
impl
Tile
for
~
LayerBuffer
{
fn
get_mem
(
&
self
)
-
>
uint
{
self
.
screen_pos
.
size
.
width
*
self
.
screen_pos
.
size
.
height
}
fn
is_valid
(
&
self
scale
:
f32
)
-
>
bool
{
(
self
.
resolution
-
scale
)
.
abs
(
)
<
1
.
0e
-
6
}
fn
get_size_2d
(
&
self
)
-
>
Size2D
<
uint
>
{
self
.
screen_pos
.
size
}
fn
mark_wont_leak
(
&
mut
self
)
{
self
.
native_surface
.
mark_wont_leak
(
)
}
fn
destroy
(
self
graphics_context
:
&
NativePaintingGraphicsContext
)
{
let
mut
this
=
self
;
this
.
native_surface
.
destroy
(
graphics_context
)
}
}
