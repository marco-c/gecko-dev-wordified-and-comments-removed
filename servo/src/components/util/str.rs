use
std
:
:
iter
:
:
Filter
;
use
std
:
:
str
:
:
CharSplits
;
pub
type
DOMString
=
String
;
pub
type
StaticCharVec
=
&
'
static
[
char
]
;
pub
type
StaticStringVec
=
&
'
static
[
&
'
static
str
]
;
pub
fn
null_str_as_empty
(
s
:
&
Option
<
DOMString
>
)
-
>
DOMString
{
match
*
s
{
Some
(
ref
s
)
=
>
s
.
clone
(
)
None
=
>
"
"
.
to_string
(
)
}
}
pub
fn
null_str_as_empty_ref
<
'
a
>
(
s
:
&
'
a
Option
<
DOMString
>
)
-
>
&
'
a
str
{
match
*
s
{
Some
(
ref
s
)
=
>
s
.
as_slice
(
)
None
=
>
"
"
}
}
pub
fn
is_whitespace
(
s
:
&
str
)
-
>
bool
{
s
.
chars
(
)
.
all
(
|
c
|
match
c
{
'
\
u0020
'
|
'
\
u0009
'
|
'
\
u000D
'
|
'
\
u000A
'
=
>
true
_
=
>
false
}
)
}
pub
static
HTML_SPACE_CHARACTERS
:
StaticCharVec
=
&
[
'
\
u0020
'
'
\
u0009
'
'
\
u000a
'
'
\
u000c
'
'
\
u000d
'
]
;
pub
fn
split_html_space_chars
<
'
a
>
(
s
:
&
'
a
str
)
-
>
Filter
<
'
a
&
'
a
str
CharSplits
<
'
a
StaticCharVec
>
>
{
s
.
split
(
HTML_SPACE_CHARACTERS
)
.
filter
(
|
&
split
|
!
split
.
is_empty
(
)
)
}
fn
do_parse_integer
<
T
:
Iterator
<
char
>
>
(
input
:
T
)
-
>
Option
<
i64
>
{
fn
as_ascii_digit
(
c
:
char
)
-
>
Option
<
i64
>
{
match
c
{
'
0
'
.
.
'
9
'
=
>
Some
(
c
as
i64
-
'
0
'
as
i64
)
_
=
>
None
}
}
let
mut
input
=
input
.
skip_while
(
|
c
|
{
HTML_SPACE_CHARACTERS
.
iter
(
)
.
any
(
|
s
|
s
=
=
c
)
}
)
.
peekable
(
)
;
let
sign
=
match
input
.
peek
(
)
{
None
=
>
return
None
Some
(
&
'
-
'
)
=
>
{
input
.
next
(
)
;
-
1
}
Some
(
&
'
+
'
)
=
>
{
input
.
next
(
)
;
1
}
Some
(
_
)
=
>
1
}
;
match
input
.
peek
(
)
{
Some
(
&
c
)
if
as_ascii_digit
(
c
)
.
is_some
(
)
=
>
(
)
_
=
>
return
None
}
let
value
=
input
.
filter_map
(
as_ascii_digit
)
.
fuse
(
)
.
fold
(
Some
(
0i64
)
|
accumulator
d
|
{
accumulator
.
and_then
(
|
accumulator
|
{
accumulator
.
checked_mul
(
&
10
)
}
)
.
and_then
(
|
accumulator
|
{
accumulator
.
checked_add
(
&
d
)
}
)
}
)
;
return
value
.
and_then
(
|
value
|
value
.
checked_mul
(
&
sign
)
)
;
}
pub
fn
parse_integer
<
T
:
Iterator
<
char
>
>
(
input
:
T
)
-
>
Option
<
i32
>
{
do_parse_integer
(
input
)
.
and_then
(
|
result
|
{
result
.
to_i32
(
)
}
)
}
pub
fn
parse_unsigned_integer
<
T
:
Iterator
<
char
>
>
(
input
:
T
)
-
>
Option
<
u32
>
{
do_parse_integer
(
input
)
.
and_then
(
|
result
|
{
result
.
to_u32
(
)
}
)
}
