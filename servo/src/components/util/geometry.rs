use
geom
:
:
length
:
:
Length
;
use
geom
:
:
point
:
:
Point2D
;
use
geom
:
:
rect
:
:
Rect
;
use
geom
:
:
size
:
:
Size2D
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
num
:
:
{
NumCast
One
Zero
}
;
use
std
:
:
fmt
;
#
[
deriving
(
Encodable
)
]
pub
enum
DevicePixel
{
}
pub
enum
ScreenPx
{
}
#
[
deriving
(
Encodable
)
]
pub
enum
ViewportPx
{
}
#
[
deriving
(
Encodable
)
]
pub
enum
PagePx
{
}
#
[
deriving
(
Clone
PartialEq
PartialOrd
Eq
Ord
Zero
)
]
pub
struct
Au
(
pub
i32
)
;
impl
Default
for
Au
{
#
[
inline
]
fn
default
(
)
-
>
Au
{
Au
(
0
)
}
}
impl
fmt
:
:
Show
for
Au
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
px
"
to_frac_px
(
*
self
)
)
}
}
impl
Add
<
Au
Au
>
for
Au
{
#
[
inline
]
fn
add
(
&
self
other
:
&
Au
)
-
>
Au
{
let
Au
(
s
)
=
*
self
;
let
Au
(
o
)
=
*
other
;
Au
(
s
+
o
)
}
}
impl
Sub
<
Au
Au
>
for
Au
{
#
[
inline
]
fn
sub
(
&
self
other
:
&
Au
)
-
>
Au
{
let
Au
(
s
)
=
*
self
;
let
Au
(
o
)
=
*
other
;
Au
(
s
-
o
)
}
}
impl
Mul
<
Au
Au
>
for
Au
{
#
[
inline
]
fn
mul
(
&
self
other
:
&
Au
)
-
>
Au
{
let
Au
(
s
)
=
*
self
;
let
Au
(
o
)
=
*
other
;
Au
(
s
*
o
)
}
}
impl
Div
<
Au
Au
>
for
Au
{
#
[
inline
]
fn
div
(
&
self
other
:
&
Au
)
-
>
Au
{
let
Au
(
s
)
=
*
self
;
let
Au
(
o
)
=
*
other
;
Au
(
s
/
o
)
}
}
impl
Rem
<
Au
Au
>
for
Au
{
#
[
inline
]
fn
rem
(
&
self
other
:
&
Au
)
-
>
Au
{
let
Au
(
s
)
=
*
self
;
let
Au
(
o
)
=
*
other
;
Au
(
s
%
o
)
}
}
impl
Neg
<
Au
>
for
Au
{
#
[
inline
]
fn
neg
(
&
self
)
-
>
Au
{
let
Au
(
s
)
=
*
self
;
Au
(
-
s
)
}
}
impl
One
for
Au
{
#
[
inline
]
fn
one
(
)
-
>
Au
{
Au
(
1
)
}
}
impl
Num
for
Au
{
}
#
[
inline
]
pub
fn
min
(
x
:
Au
y
:
Au
)
-
>
Au
{
if
x
<
y
{
x
}
else
{
y
}
}
#
[
inline
]
pub
fn
max
(
x
:
Au
y
:
Au
)
-
>
Au
{
if
x
>
y
{
x
}
else
{
y
}
}
impl
NumCast
for
Au
{
#
[
inline
]
fn
from
<
T
:
ToPrimitive
>
(
n
:
T
)
-
>
Option
<
Au
>
{
Some
(
Au
(
n
.
to_i32
(
)
.
unwrap
(
)
)
)
}
}
impl
ToPrimitive
for
Au
{
#
[
inline
]
fn
to_i64
(
&
self
)
-
>
Option
<
i64
>
{
let
Au
(
s
)
=
*
self
;
Some
(
s
as
i64
)
}
#
[
inline
]
fn
to_u64
(
&
self
)
-
>
Option
<
u64
>
{
let
Au
(
s
)
=
*
self
;
Some
(
s
as
u64
)
}
#
[
inline
]
fn
to_f32
(
&
self
)
-
>
Option
<
f32
>
{
let
Au
(
s
)
=
*
self
;
s
.
to_f32
(
)
}
#
[
inline
]
fn
to_f64
(
&
self
)
-
>
Option
<
f64
>
{
let
Au
(
s
)
=
*
self
;
s
.
to_f64
(
)
}
}
impl
Au
{
#
[
inline
]
pub
fn
new
(
value
:
i32
)
-
>
Au
{
Au
(
value
)
}
#
[
inline
]
pub
fn
scale_by
(
self
factor
:
f64
)
-
>
Au
{
let
Au
(
s
)
=
self
;
Au
(
(
(
s
as
f64
)
*
factor
)
as
i32
)
}
#
[
inline
]
pub
fn
from_px
(
px
:
int
)
-
>
Au
{
NumCast
:
:
from
(
px
*
60
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
from_page_px
(
px
:
Length
<
PagePx
f32
>
)
-
>
Au
{
NumCast
:
:
from
(
px
.
get
(
)
*
60f32
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
to_nearest_px
(
&
self
)
-
>
int
{
let
Au
(
s
)
=
*
self
;
(
(
s
as
f64
)
/
60f64
)
.
round
(
)
as
int
}
#
[
inline
]
pub
fn
to_snapped
(
&
self
)
-
>
Au
{
let
Au
(
s
)
=
*
self
;
let
res
=
s
%
60i32
;
return
if
res
>
=
30i32
{
return
Au
(
s
-
res
+
60i32
)
}
else
{
return
Au
(
s
-
res
)
}
;
}
#
[
inline
]
pub
fn
from_frac32_px
(
px
:
f32
)
-
>
Au
{
Au
(
(
px
*
60f32
)
as
i32
)
}
#
[
inline
]
pub
fn
from_pt
(
pt
:
f64
)
-
>
Au
{
from_px
(
pt_to_px
(
pt
)
as
int
)
}
#
[
inline
]
pub
fn
from_frac_px
(
px
:
f64
)
-
>
Au
{
Au
(
(
px
*
60f64
)
as
i32
)
}
#
[
inline
]
pub
fn
min
(
x
:
Au
y
:
Au
)
-
>
Au
{
let
Au
(
xi
)
=
x
;
let
Au
(
yi
)
=
y
;
if
xi
<
yi
{
x
}
else
{
y
}
}
#
[
inline
]
pub
fn
max
(
x
:
Au
y
:
Au
)
-
>
Au
{
let
Au
(
xi
)
=
x
;
let
Au
(
yi
)
=
y
;
if
xi
>
yi
{
x
}
else
{
y
}
}
}
pub
fn
pt_to_px
(
pt
:
f64
)
-
>
f64
{
pt
/
72f64
*
96f64
}
pub
fn
px_to_pt
(
px
:
f64
)
-
>
f64
{
px
/
96f64
*
72f64
}
pub
fn
from_frac_px
(
px
:
f64
)
-
>
Au
{
Au
(
(
px
*
60f64
)
as
i32
)
}
pub
fn
from_px
(
px
:
int
)
-
>
Au
{
NumCast
:
:
from
(
px
*
60
)
.
unwrap
(
)
}
pub
fn
to_px
(
au
:
Au
)
-
>
int
{
let
Au
(
a
)
=
au
;
(
a
/
60
)
as
int
}
pub
fn
to_frac_px
(
au
:
Au
)
-
>
f64
{
let
Au
(
a
)
=
au
;
(
a
as
f64
)
/
60f64
}
pub
fn
from_pt
(
pt
:
f64
)
-
>
Au
{
from_px
(
(
pt
/
72f64
*
96f64
)
as
int
)
}
pub
fn
to_pt
(
au
:
Au
)
-
>
f64
{
let
Au
(
a
)
=
au
;
(
a
as
f64
)
/
60f64
*
72f64
/
96f64
}
pub
fn
rect_contains_point
<
T
:
PartialOrd
+
Add
<
T
T
>
>
(
rect
:
Rect
<
T
>
point
:
Point2D
<
T
>
)
-
>
bool
{
point
.
x
>
=
rect
.
origin
.
x
&
&
point
.
x
<
rect
.
origin
.
x
+
rect
.
size
.
width
&
&
point
.
y
>
=
rect
.
origin
.
y
&
&
point
.
y
<
rect
.
origin
.
y
+
rect
.
size
.
height
}
pub
fn
f32_rect_to_au_rect
(
rect
:
Rect
<
f32
>
)
-
>
Rect
<
Au
>
{
Rect
(
Point2D
(
Au
:
:
from_frac32_px
(
rect
.
origin
.
x
)
Au
:
:
from_frac32_px
(
rect
.
origin
.
y
)
)
Size2D
(
Au
:
:
from_frac32_px
(
rect
.
size
.
width
)
Au
:
:
from_frac32_px
(
rect
.
size
.
height
)
)
)
}
