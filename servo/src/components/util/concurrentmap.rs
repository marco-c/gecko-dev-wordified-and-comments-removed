use
rand
;
use
rand
:
:
Rng
;
use
std
:
:
cast
;
use
std
:
:
hash
:
:
{
Hash
sip
}
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
atomics
:
:
{
AtomicUint
Relaxed
SeqCst
}
;
use
std
:
:
unstable
:
:
mutex
:
:
StaticNativeMutex
;
use
std
:
:
mem
;
static
LOAD_NUMERATOR
:
uint
=
3
;
static
LOAD_DENOMINATOR
:
uint
=
4
;
struct
Bucket
<
K
V
>
{
next
:
Option
<
Box
<
Bucket
<
K
V
>
>
>
key
:
K
value
:
V
}
pub
struct
ConcurrentHashMap
<
K
V
>
{
k0
:
u64
k1
:
u64
size
:
AtomicUint
locks
:
Vec
<
StaticNativeMutex
>
buckets
:
Vec
<
Option
<
Bucket
<
K
V
>
>
>
}
impl
<
K
:
Hash
+
Eq
V
>
ConcurrentHashMap
<
K
V
>
{
pub
fn
new
(
)
-
>
ConcurrentHashMap
<
K
V
>
{
ConcurrentHashMap
:
:
with_locks_and_buckets
(
16
4
)
}
pub
fn
with_locks_and_buckets
(
lock_count
:
uint
buckets_per_lock
:
uint
)
-
>
ConcurrentHashMap
<
K
V
>
{
let
mut
rand
=
rand
:
:
task_rng
(
)
;
ConcurrentHashMap
{
k0
:
rand
.
gen
(
)
k1
:
rand
.
gen
(
)
size
:
AtomicUint
:
:
new
(
0
)
locks
:
Vec
:
:
from_fn
(
lock_count
|
_
|
{
unsafe
{
StaticNativeMutex
:
:
new
(
)
}
}
)
buckets
:
Vec
:
:
from_fn
(
lock_count
*
buckets_per_lock
|
_
|
None
)
}
}
pub
fn
insert
(
&
self
key
:
K
value
:
V
)
{
unsafe
{
let
this
:
&
mut
ConcurrentHashMap
<
K
V
>
=
cast
:
:
transmute_mut
(
self
)
;
loop
{
let
(
bucket_index
lock_index
)
=
self
.
bucket_and_lock_indices
(
&
key
)
;
if
this
.
overloaded
(
)
{
this
.
locks
.
get
(
lock_index
)
.
unlock_noguard
(
)
;
this
.
try_resize
(
self
.
buckets_per_lock
(
)
*
2
)
;
continue
}
this
.
insert_unlocked
(
key
value
Some
(
bucket_index
)
)
;
this
.
locks
.
get
(
lock_index
)
.
unlock_noguard
(
)
;
break
}
}
}
#
[
inline
(
always
)
]
unsafe
fn
insert_unlocked
(
&
self
key
:
K
value
:
V
opt_bucket_index
:
Option
<
uint
>
)
{
let
this
:
&
mut
ConcurrentHashMap
<
K
V
>
=
cast
:
:
transmute_mut
(
self
)
;
let
bucket_index
=
match
opt_bucket_index
{
Some
(
bucket_index
)
=
>
bucket_index
None
=
>
self
.
bucket_index_unlocked
(
&
key
)
}
;
match
this
.
buckets
.
get_mut
(
bucket_index
)
{
&
None
=
>
{
}
&
Some
(
ref
mut
bucket
)
=
>
{
let
mut
bucket
:
*
mut
Bucket
<
K
V
>
=
bucket
;
loop
{
if
(
*
bucket
)
.
key
=
=
key
{
(
*
bucket
)
.
value
=
value
;
break
}
match
(
*
bucket
)
.
next
{
None
=
>
{
}
Some
(
ref
mut
next_bucket
)
=
>
{
bucket
=
&
mut
*
*
next_bucket
as
*
mut
Bucket
<
K
V
>
;
continue
}
}
(
*
bucket
)
.
next
=
Some
(
box
Bucket
{
next
:
None
key
:
key
value
:
value
}
)
;
drop
(
this
.
size
.
fetch_add
(
1
SeqCst
)
)
;
break
}
return
;
}
}
*
this
.
buckets
.
get_mut
(
bucket_index
)
=
Some
(
Bucket
{
next
:
None
key
:
key
value
:
value
}
)
;
drop
(
this
.
size
.
fetch_add
(
1
SeqCst
)
)
;
}
pub
fn
remove
(
&
self
key
:
&
K
)
{
let
this
:
&
mut
ConcurrentHashMap
<
K
V
>
=
unsafe
{
cast
:
:
transmute_mut
(
self
)
}
;
let
(
bucket_index
lock_index
)
=
self
.
bucket_and_lock_indices
(
key
)
;
let
mut
nuke_bucket
=
false
;
match
this
.
buckets
.
get_mut
(
bucket_index
)
{
&
None
=
>
{
}
&
Some
(
ref
mut
bucket
)
if
bucket
.
key
=
=
*
key
=
>
{
let
next_opt
=
mem
:
:
replace
(
&
mut
bucket
.
next
None
)
;
match
next_opt
{
None
=
>
nuke_bucket
=
true
Some
(
box
next
)
=
>
*
bucket
=
next
}
drop
(
this
.
size
.
fetch_sub
(
1
SeqCst
)
)
}
&
Some
(
ref
mut
bucket
)
=
>
{
let
mut
prev
:
*
mut
Bucket
<
K
V
>
=
bucket
;
unsafe
{
loop
{
match
(
*
prev
)
.
next
{
None
=
>
break
Some
(
ref
mut
bucket
)
=
>
{
if
bucket
.
key
!
=
*
key
{
prev
=
&
mut
*
*
bucket
as
*
mut
Bucket
<
K
V
>
;
continue
}
}
}
let
box
Bucket
{
next
:
next_next
.
.
}
=
(
*
prev
)
.
next
.
take_unwrap
(
)
;
(
*
prev
)
.
next
=
next_next
;
drop
(
this
.
size
.
fetch_sub
(
1
SeqCst
)
)
;
break
}
}
}
}
if
nuke_bucket
{
*
this
.
buckets
.
get_mut
(
bucket_index
)
=
None
}
unsafe
{
this
.
locks
.
get
(
lock_index
)
.
unlock_noguard
(
)
}
}
pub
fn
iter
<
'
a
>
(
&
'
a
self
)
-
>
ConcurrentHashMapIterator
<
'
a
K
V
>
{
ConcurrentHashMapIterator
{
map
:
self
bucket_index
:
-
1
current_bucket
:
ptr
:
:
null
(
)
}
}
pub
fn
contains_key
(
&
self
key
:
&
K
)
-
>
bool
{
let
this
:
&
mut
ConcurrentHashMap
<
K
V
>
=
unsafe
{
cast
:
:
transmute_mut
(
self
)
}
;
let
(
bucket_index
lock_index
)
=
this
.
bucket_and_lock_indices
(
key
)
;
let
result
;
match
this
.
buckets
.
get
(
bucket_index
)
{
&
None
=
>
result
=
false
&
Some
(
ref
bucket
)
=
>
{
let
mut
bucket
=
bucket
;
loop
{
if
bucket
.
key
=
=
*
key
{
result
=
true
;
break
}
match
bucket
.
next
{
None
=
>
{
result
=
false
;
break
}
Some
(
ref
next_bucket
)
=
>
bucket
=
&
*
*
next_bucket
}
}
}
}
unsafe
{
this
.
locks
.
get
(
lock_index
)
.
unlock_noguard
(
)
}
result
}
pub
fn
clear
(
&
self
)
{
let
this
:
&
mut
ConcurrentHashMap
<
K
V
>
=
unsafe
{
cast
:
:
transmute_mut
(
self
)
}
;
let
(
bucket_count
lock_count
)
=
(
this
.
buckets
.
len
(
)
this
.
locks
.
len
(
)
)
;
let
buckets_per_lock
=
bucket_count
/
lock_count
;
let
(
mut
lock_index
mut
stripe_index
)
=
(
0
0
)
;
for
bucket
in
this
.
buckets
.
mut_iter
(
)
{
stripe_index
+
=
1
;
if
stripe_index
=
=
buckets_per_lock
{
unsafe
{
this
.
locks
.
get
(
lock_index
)
.
unlock_noguard
(
)
;
}
stripe_index
=
0
;
lock_index
+
=
1
}
if
stripe_index
=
=
0
{
unsafe
{
this
.
locks
.
get
(
lock_index
)
.
lock_noguard
(
)
}
}
*
bucket
=
None
}
}
fn
try_resize
(
&
self
new_buckets_per_lock
:
uint
)
{
let
this
:
&
mut
ConcurrentHashMap
<
K
V
>
=
unsafe
{
cast
:
:
transmute_mut
(
self
)
}
;
for
lock
in
this
.
locks
.
mut_iter
(
)
{
unsafe
{
lock
.
lock_noguard
(
)
}
}
let
lock_count
=
this
.
locks
.
len
(
)
;
let
new_bucket_count
=
lock_count
*
new_buckets_per_lock
;
if
new_bucket_count
>
this
.
buckets
.
len
(
)
{
let
mut
buckets
=
Vec
:
:
from_fn
(
new_bucket_count
|
_
|
None
)
;
mem
:
:
swap
(
&
mut
this
.
buckets
&
mut
buckets
)
;
this
.
size
.
store
(
0
Relaxed
)
;
for
bucket
in
buckets
.
move_iter
(
)
{
match
bucket
{
None
=
>
continue
Some
(
Bucket
{
key
:
key
value
:
value
next
:
mut
bucket
}
)
=
>
{
unsafe
{
this
.
insert_unlocked
(
key
value
None
)
}
loop
{
match
bucket
{
None
=
>
break
Some
(
box
Bucket
{
key
:
key
value
:
value
next
:
next
}
)
=
>
{
unsafe
{
this
.
insert_unlocked
(
key
value
None
)
}
bucket
=
next
}
}
}
}
}
}
}
for
lock
in
this
.
locks
.
mut_iter
(
)
{
unsafe
{
lock
.
unlock_noguard
(
)
}
}
}
#
[
inline
]
fn
bucket_and_lock_indices
(
&
self
key
:
&
K
)
-
>
(
uint
uint
)
{
let
this
:
&
mut
ConcurrentHashMap
<
K
V
>
=
unsafe
{
cast
:
:
transmute_mut
(
cast
:
:
transmute_lifetime
(
self
)
)
}
;
let
hash
=
sip
:
:
hash_with_keys
(
self
.
k0
self
.
k1
key
)
;
let
lock_count
=
this
.
locks
.
len
(
)
;
let
mut
bucket_index
;
let
mut
lock_index
;
loop
{
let
bucket_count
=
this
.
buckets
.
len
(
)
;
let
buckets_per_lock
=
bucket_count
/
lock_count
;
bucket_index
=
hash
as
uint
%
bucket_count
;
lock_index
=
bucket_index
/
buckets_per_lock
;
unsafe
{
this
.
locks
.
get
(
lock_index
)
.
lock_noguard
(
)
;
}
let
new_bucket_count
=
this
.
buckets
.
len
(
)
;
if
bucket_count
=
=
new_bucket_count
{
break
}
unsafe
{
this
.
locks
.
get
(
lock_index
)
.
unlock_noguard
(
)
}
}
(
bucket_index
lock_index
)
}
#
[
inline
]
unsafe
fn
bucket_index_unlocked
(
&
self
key
:
&
K
)
-
>
uint
{
let
hash
=
sip
:
:
hash_with_keys
(
self
.
k0
self
.
k1
key
)
;
hash
as
uint
%
self
.
buckets
.
len
(
)
}
#
[
inline
]
fn
overloaded
(
&
self
)
-
>
bool
{
self
.
size
.
load
(
SeqCst
)
>
=
(
self
.
buckets
.
len
(
)
*
LOAD_NUMERATOR
/
LOAD_DENOMINATOR
)
}
#
[
inline
]
fn
buckets_per_lock
(
&
self
)
-
>
uint
{
self
.
buckets
.
len
(
)
/
self
.
locks
.
len
(
)
}
#
[
inline
]
pub
fn
size
(
&
self
)
-
>
uint
{
self
.
size
.
load
(
SeqCst
)
}
}
pub
struct
ConcurrentHashMapIterator
<
'
a
K
V
>
{
map
:
&
'
a
ConcurrentHashMap
<
K
V
>
bucket_index
:
int
current_bucket
:
*
Bucket
<
K
V
>
}
impl
<
'
a
K
V
>
Iterator
<
(
&
'
a
K
&
'
a
V
)
>
for
ConcurrentHashMapIterator
<
'
a
K
V
>
{
fn
next
(
&
mut
self
)
-
>
Option
<
(
&
'
a
K
&
'
a
V
)
>
{
let
map
:
&
'
a
mut
ConcurrentHashMap
<
K
V
>
=
unsafe
{
cast
:
:
transmute_mut
(
self
.
map
)
}
;
let
(
bucket_count
lock_count
)
=
(
map
.
buckets
.
len
(
)
map
.
locks
.
len
(
)
)
;
let
buckets_per_lock
=
bucket_count
/
lock_count
;
if
self
.
current_bucket
!
=
ptr
:
:
null
(
)
{
unsafe
{
self
.
current_bucket
=
match
(
*
self
.
current_bucket
)
.
next
{
None
=
>
ptr
:
:
null
(
)
Some
(
ref
bucket
)
=
>
{
let
bucket
:
*
Bucket
<
K
V
>
=
&
*
*
bucket
;
bucket
}
}
}
}
while
self
.
current_bucket
=
=
ptr
:
:
null
(
)
{
let
bucket_index
=
self
.
bucket_index
;
let
lock_index
=
if
bucket_index
<
0
{
-
1
}
else
{
bucket_index
/
(
buckets_per_lock
as
int
)
}
;
if
bucket_index
<
0
|
|
bucket_index
%
(
buckets_per_lock
as
int
)
=
=
(
buckets_per_lock
as
int
)
-
1
{
if
bucket_index
!
=
-
1
{
unsafe
{
map
.
locks
.
get
(
lock_index
as
uint
)
.
unlock_noguard
(
)
}
}
if
bucket_index
!
=
(
bucket_count
as
int
)
-
1
{
unsafe
{
map
.
locks
.
get
(
(
lock_index
+
1
)
as
uint
)
.
lock_noguard
(
)
}
}
}
if
self
.
bucket_index
=
=
(
bucket_count
as
int
)
-
1
{
return
None
}
self
.
bucket_index
+
=
1
;
self
.
current_bucket
=
match
map
.
buckets
.
get
(
self
.
bucket_index
as
uint
)
{
&
None
=
>
ptr
:
:
null
(
)
&
Some
(
ref
bucket
)
=
>
{
let
bucket
:
*
Bucket
<
K
V
>
=
bucket
;
bucket
}
}
}
unsafe
{
Some
(
(
cast
:
:
transmute
(
&
(
*
self
.
current_bucket
)
.
key
)
cast
:
:
transmute
(
&
(
*
self
.
current_bucket
)
.
value
)
)
)
}
}
}
#
[
cfg
(
test
)
]
pub
mod
test
{
use
sync
:
:
Arc
;
use
native
;
use
std
:
:
comm
;
use
concurrentmap
:
:
ConcurrentHashMap
;
#
[
test
]
pub
fn
smoke
(
)
{
let
m
=
Arc
:
:
new
(
ConcurrentHashMap
:
:
new
(
)
)
;
let
(
chan
port
)
=
comm
:
:
channel
(
)
;
for
i
in
range
(
0
5
)
{
let
m
=
m
.
clone
(
)
;
let
chan
=
chan
.
clone
(
)
;
native
:
:
task
:
:
spawn
(
proc
(
)
{
for
j
in
range
(
i
*
20
(
i
*
20
)
+
20
)
{
m
.
insert
(
j
j
*
j
)
;
}
chan
.
send
(
(
)
)
;
}
)
}
for
_
in
range
(
0
5
)
{
port
.
recv
(
)
;
}
let
mut
count
=
0
;
for
(
&
k
&
v
)
in
m
.
iter
(
)
{
assert_eq
!
(
k
*
k
v
)
count
+
=
1
;
}
assert_eq
!
(
count
100
)
}
}
