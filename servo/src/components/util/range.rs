use
std
:
:
cmp
:
:
{
max
min
}
;
use
std
:
:
iter
;
use
std
:
:
fmt
;
use
std
:
:
num
;
use
std
:
:
num
:
:
{
Bounded
Zero
}
;
pub
trait
RangeIndex
:
Copy
+
Clone
+
fmt
:
:
Show
+
Eq
+
Ord
+
TotalEq
+
TotalOrd
+
Add
<
Self
Self
>
+
Sub
<
Self
Self
>
+
Neg
<
Self
>
+
Zero
{
}
pub
trait
IntRangeIndex
<
T
>
:
RangeIndex
+
Copy
{
fn
new
(
x
:
T
)
-
>
Self
;
fn
get
(
self
)
-
>
T
;
}
impl
RangeIndex
for
int
{
}
impl
IntRangeIndex
<
int
>
for
int
{
#
[
inline
]
fn
new
(
x
:
int
)
-
>
int
{
x
}
#
[
inline
]
fn
get
(
self
)
-
>
int
{
self
}
}
#
[
macro_export
]
macro_rules
!
int_range_index
{
(
(
#
[
attr
:
meta
]
)
*
struct
Self
:
ident
(
T
:
ty
)
)
=
>
(
#
[
deriving
(
Clone
Eq
Ord
TotalEq
TotalOrd
Show
Zero
)
]
(
#
[
attr
]
)
*
pub
struct
Self
(
pub
T
)
;
impl
Self
{
#
[
inline
]
pub
fn
to_uint
(
self
)
-
>
uint
{
self
.
get
(
)
as
uint
}
}
impl
RangeIndex
for
Self
{
}
impl
IntRangeIndex
<
T
>
for
Self
{
#
[
inline
]
fn
new
(
x
:
T
)
-
>
Self
{
Self
(
x
)
}
#
[
inline
]
fn
get
(
self
)
-
>
T
{
match
self
{
Self
(
x
)
=
>
x
}
}
}
impl
Add
<
Self
Self
>
for
Self
{
#
[
inline
]
fn
add
(
&
self
other
:
&
Self
)
-
>
Self
{
Self
(
self
.
get
(
)
+
other
.
get
(
)
)
}
}
impl
Sub
<
Self
Self
>
for
Self
{
#
[
inline
]
fn
sub
(
&
self
other
:
&
Self
)
-
>
Self
{
Self
(
self
.
get
(
)
-
other
.
get
(
)
)
}
}
impl
Neg
<
Self
>
for
Self
{
#
[
inline
]
fn
neg
(
&
self
)
-
>
Self
{
Self
(
-
self
.
get
(
)
)
}
}
)
}
#
[
deriving
(
Show
)
]
pub
enum
RangeRelation
<
I
>
{
OverlapsBegin
(
I
)
OverlapsEnd
(
I
)
ContainedBy
Contains
Coincides
EntirelyBefore
EntirelyAfter
}
#
[
deriving
(
Clone
)
]
pub
struct
Range
<
I
>
{
begin
:
I
length
:
I
}
impl
<
I
:
RangeIndex
>
fmt
:
:
Show
for
Range
<
I
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
.
buf
"
[
{
}
.
.
{
}
)
"
self
.
begin
(
)
self
.
end
(
)
)
}
}
pub
struct
EachIndex
<
T
I
>
{
it
:
iter
:
:
Range
<
T
>
}
pub
fn
each_index
<
T
:
Int
I
:
IntRangeIndex
<
T
>
>
(
start
:
I
stop
:
I
)
-
>
EachIndex
<
T
I
>
{
EachIndex
{
it
:
iter
:
:
range
(
start
.
get
(
)
stop
.
get
(
)
)
}
}
impl
<
T
:
Int
I
:
IntRangeIndex
<
T
>
>
Iterator
<
I
>
for
EachIndex
<
T
I
>
{
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
I
>
{
self
.
it
.
next
(
)
.
map
(
|
i
|
IntRangeIndex
:
:
new
(
i
)
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
uint
Option
<
uint
>
)
{
self
.
it
.
size_hint
(
)
}
}
impl
<
I
:
RangeIndex
>
Range
<
I
>
{
#
[
inline
]
pub
fn
new
(
begin
:
I
length
:
I
)
-
>
Range
<
I
>
{
Range
{
begin
:
begin
length
:
length
}
}
#
[
inline
]
pub
fn
empty
(
)
-
>
Range
<
I
>
{
Range
:
:
new
(
num
:
:
zero
(
)
num
:
:
zero
(
)
)
}
#
[
inline
]
pub
fn
begin
(
&
self
)
-
>
I
{
self
.
begin
}
#
[
inline
]
pub
fn
length
(
&
self
)
-
>
I
{
self
.
length
}
#
[
inline
]
pub
fn
end
(
&
self
)
-
>
I
{
self
.
begin
+
self
.
length
}
#
[
inline
]
pub
fn
contains
(
&
self
i
:
I
)
-
>
bool
{
i
>
=
self
.
begin
(
)
&
&
i
<
self
.
end
(
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
length
(
)
.
is_zero
(
)
}
#
[
inline
]
pub
fn
shift_by
(
&
mut
self
delta
:
I
)
{
self
.
begin
=
self
.
begin
+
delta
;
}
#
[
inline
]
pub
fn
extend_by
(
&
mut
self
delta
:
I
)
{
self
.
length
=
self
.
length
+
delta
;
}
#
[
inline
]
pub
fn
extend_to
(
&
mut
self
target
:
I
)
{
self
.
length
=
target
-
self
.
begin
;
}
#
[
inline
]
pub
fn
adjust_by
(
&
mut
self
begin_delta
:
I
length_delta
:
I
)
{
self
.
begin
=
self
.
begin
+
begin_delta
;
self
.
length
=
self
.
length
+
length_delta
;
}
#
[
inline
]
pub
fn
reset
(
&
mut
self
begin
:
I
length
:
I
)
{
self
.
begin
=
begin
;
self
.
length
=
length
;
}
#
[
inline
]
pub
fn
intersect
(
&
self
other
:
&
Range
<
I
>
)
-
>
Range
<
I
>
{
let
begin
=
max
(
self
.
begin
(
)
other
.
begin
(
)
)
;
let
end
=
min
(
self
.
end
(
)
other
.
end
(
)
)
;
if
end
<
begin
{
Range
:
:
empty
(
)
}
else
{
Range
:
:
new
(
begin
end
-
begin
)
}
}
#
[
inline
]
pub
fn
relation_to_range
(
&
self
other
:
&
Range
<
I
>
)
-
>
RangeRelation
<
I
>
{
if
other
.
begin
(
)
>
self
.
end
(
)
{
return
EntirelyBefore
;
}
if
self
.
begin
(
)
>
other
.
end
(
)
{
return
EntirelyAfter
;
}
if
self
.
begin
(
)
=
=
other
.
begin
(
)
&
&
self
.
end
(
)
=
=
other
.
end
(
)
{
return
Coincides
;
}
if
self
.
begin
(
)
<
=
other
.
begin
(
)
&
&
self
.
end
(
)
>
=
other
.
end
(
)
{
return
Contains
;
}
if
self
.
begin
(
)
>
=
other
.
begin
(
)
&
&
self
.
end
(
)
<
=
other
.
end
(
)
{
return
ContainedBy
;
}
if
self
.
begin
(
)
<
other
.
begin
(
)
&
&
self
.
end
(
)
<
other
.
end
(
)
{
let
overlap
=
self
.
end
(
)
-
other
.
begin
(
)
;
return
OverlapsBegin
(
overlap
)
;
}
if
self
.
begin
(
)
>
other
.
begin
(
)
&
&
self
.
end
(
)
>
other
.
end
(
)
{
let
overlap
=
other
.
end
(
)
-
self
.
begin
(
)
;
return
OverlapsEnd
(
overlap
)
;
}
fail
!
(
"
relation_to_range
(
)
:
didn
'
t
classify
self
=
{
}
other
=
{
}
"
self
other
)
;
}
}
impl
<
T
:
Int
I
:
IntRangeIndex
<
T
>
>
Range
<
I
>
{
#
[
inline
]
pub
fn
each_index
(
&
self
)
-
>
EachIndex
<
T
I
>
{
each_index
(
self
.
begin
(
)
self
.
end
(
)
)
}
#
[
inline
]
pub
fn
is_valid_for_string
(
&
self
s
:
&
str
)
-
>
bool
{
let
s_len
=
s
.
len
(
)
;
match
num
:
:
cast
:
:
<
uint
T
>
(
s_len
)
{
Some
(
len
)
=
>
{
let
len
=
IntRangeIndex
:
:
new
(
len
)
;
self
.
begin
(
)
<
len
&
&
self
.
end
(
)
<
=
len
&
&
self
.
length
(
)
<
=
len
}
None
=
>
{
debug
!
(
"
Range
<
T
>
:
:
is_valid_for_string
:
string
length
(
len
=
{
}
)
is
longer
than
the
\
max
value
for
the
range
index
(
max
=
{
}
)
"
s_len
{
let
max
:
T
=
Bounded
:
:
max_value
(
)
;
let
val
:
I
=
IntRangeIndex
:
:
new
(
max
)
;
val
}
)
;
false
}
}
}
#
[
inline
]
pub
fn
repair_after_coalesced_range
(
&
mut
self
other
:
&
Range
<
I
>
)
{
let
relation
=
self
.
relation_to_range
(
other
)
;
debug
!
(
"
repair_after_coalesced_range
:
possibly
repairing
range
{
}
"
*
self
)
;
debug
!
(
"
repair_after_coalesced_range
:
relation
of
original
range
and
coalesced
range
{
}
:
{
}
"
*
other
relation
)
;
let
_1
:
I
=
IntRangeIndex
:
:
new
(
num
:
:
one
:
:
<
T
>
(
)
)
;
match
relation
{
EntirelyBefore
=
>
{
}
EntirelyAfter
=
>
{
self
.
shift_by
(
-
other
.
length
(
)
)
;
}
Coincides
|
ContainedBy
=
>
{
self
.
reset
(
other
.
begin
(
)
_1
)
;
}
Contains
=
>
{
self
.
extend_by
(
-
other
.
length
(
)
)
;
}
OverlapsBegin
(
overlap
)
=
>
{
self
.
extend_by
(
_1
-
overlap
)
;
}
OverlapsEnd
(
overlap
)
=
>
{
let
len
=
self
.
length
(
)
-
overlap
+
_1
;
self
.
reset
(
other
.
begin
(
)
len
)
;
}
}
;
debug
!
(
"
repair_after_coalesced_range
:
new
range
:
-
-
-
-
{
}
"
*
self
)
;
}
}
