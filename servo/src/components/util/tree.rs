macro_rules
!
get
(
(
node
:
expr
fun
:
ident
)
=
>
(
{
let
val
:
Option
<
Self
>
=
TreeNodeRef
:
:
<
Node
>
:
:
fun
(
node
)
;
val
}
)
)
macro_rules
!
set
(
(
node
:
expr
fun
:
ident
val
:
expr
)
=
>
(
{
let
val
:
Option
<
Self
>
=
val
;
TreeNodeRef
:
:
<
Node
>
:
:
fun
(
node
val
)
}
)
)
pub
struct
ChildIterator
<
Ref
>
{
priv
current
:
Option
<
Ref
>
}
impl
<
Node
Ref
:
TreeNodeRef
<
Node
>
>
Iterator
<
Ref
>
for
ChildIterator
<
Ref
>
{
fn
next
(
&
mut
self
)
-
>
Option
<
Ref
>
{
if
self
.
current
.
is_none
(
)
{
return
None
;
}
let
x
=
self
.
current
.
get_ref
(
)
.
clone
(
)
;
self
.
current
=
TreeNodeRef
:
:
<
Node
>
:
:
next_sibling
(
x
.
node
(
)
)
;
Some
(
x
.
clone
(
)
)
}
}
pub
struct
AncestorIterator
<
Ref
>
{
priv
current
:
Option
<
Ref
>
}
impl
<
Node
Ref
:
TreeNodeRef
<
Node
>
>
Iterator
<
Ref
>
for
AncestorIterator
<
Ref
>
{
fn
next
(
&
mut
self
)
-
>
Option
<
Ref
>
{
if
self
.
current
.
is_none
(
)
{
return
None
;
}
let
x
=
self
.
current
.
get_ref
(
)
.
clone
(
)
;
self
.
current
=
TreeNodeRef
:
:
<
Node
>
:
:
parent_node
(
x
.
node
(
)
)
;
Some
(
x
.
clone
(
)
)
}
}
pub
struct
TreeIterator
<
Ref
>
{
priv
nodes
:
~
[
Ref
]
priv
index
:
uint
}
impl
<
Ref
>
TreeIterator
<
Ref
>
{
fn
new
(
nodes
:
~
[
Ref
]
)
-
>
TreeIterator
<
Ref
>
{
TreeIterator
{
nodes
:
nodes
index
:
0
}
}
}
impl
<
Ref
:
Clone
>
Iterator
<
Ref
>
for
TreeIterator
<
Ref
>
{
fn
next
(
&
mut
self
)
-
>
Option
<
Ref
>
{
if
self
.
index
>
=
self
.
nodes
.
len
(
)
{
None
}
else
{
let
v
=
self
.
nodes
[
self
.
index
]
.
clone
(
)
;
self
.
index
+
=
1
;
Some
(
v
)
}
}
}
pub
trait
TreeNodeRef
<
Node
>
:
Clone
{
fn
node
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Node
;
fn
mut_node
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
mut
Node
;
fn
parent_node
(
node
:
&
Node
)
-
>
Option
<
Self
>
;
fn
first_child
(
node
:
&
Node
)
-
>
Option
<
Self
>
;
fn
last_child
(
node
:
&
Node
)
-
>
Option
<
Self
>
;
fn
prev_sibling
(
node
:
&
Node
)
-
>
Option
<
Self
>
;
fn
next_sibling
(
node
:
&
Node
)
-
>
Option
<
Self
>
;
fn
set_parent_node
(
node
:
&
mut
Node
new_parent
:
Option
<
Self
>
)
;
fn
set_first_child
(
node
:
&
mut
Node
new_first_child
:
Option
<
Self
>
)
;
fn
set_last_child
(
node
:
&
mut
Node
new_last_child
:
Option
<
Self
>
)
;
fn
set_prev_sibling
(
node
:
&
mut
Node
new_prev_sibling
:
Option
<
Self
>
)
;
fn
set_next_sibling
(
node
:
&
mut
Node
new_next_sibling
:
Option
<
Self
>
)
;
fn
is_leaf
(
&
self
)
-
>
bool
{
(
get
!
(
self
.
node
(
)
first_child
)
)
.
is_none
(
)
}
fn
add_child
(
&
self
new_child
:
Self
before
:
Option
<
Self
>
)
{
let
this_node
=
self
.
mut_node
(
)
;
let
new_child_node
=
new_child
.
mut_node
(
)
;
assert
!
(
(
get
!
(
new_child_node
parent_node
)
)
.
is_none
(
)
)
;
assert
!
(
(
get
!
(
new_child_node
prev_sibling
)
)
.
is_none
(
)
)
;
assert
!
(
(
get
!
(
new_child_node
next_sibling
)
)
.
is_none
(
)
)
;
match
before
{
Some
(
before
)
=
>
{
let
before_node
=
before
.
mut_node
(
)
;
assert
!
(
(
get
!
(
before_node
parent_node
)
)
.
is_some
(
)
)
;
set
!
(
before_node
set_prev_sibling
Some
(
new_child
.
clone
(
)
)
)
;
set
!
(
new_child_node
set_next_sibling
Some
(
before
.
clone
(
)
)
)
;
match
get
!
(
before_node
prev_sibling
)
{
None
=
>
{
set
!
(
this_node
set_first_child
Some
(
new_child
.
clone
(
)
)
)
;
}
Some
(
prev_sibling
)
=
>
{
let
prev_sibling_node
=
prev_sibling
.
mut_node
(
)
;
set
!
(
prev_sibling_node
set_next_sibling
Some
(
new_child
.
clone
(
)
)
)
;
set
!
(
new_child_node
set_prev_sibling
Some
(
prev_sibling
.
clone
(
)
)
)
;
}
}
}
None
=
>
{
match
get
!
(
this_node
last_child
)
{
None
=
>
set
!
(
this_node
set_first_child
Some
(
new_child
.
clone
(
)
)
)
Some
(
last_child
)
=
>
{
let
last_child_node
=
last_child
.
mut_node
(
)
;
assert
!
(
(
get
!
(
last_child_node
next_sibling
)
)
.
is_none
(
)
)
;
set
!
(
last_child_node
set_next_sibling
Some
(
new_child
.
clone
(
)
)
)
;
set
!
(
new_child_node
set_prev_sibling
Some
(
last_child
.
clone
(
)
)
)
;
}
}
set
!
(
this_node
set_last_child
Some
(
new_child
.
clone
(
)
)
)
;
}
}
set
!
(
new_child_node
set_parent_node
Some
(
(
*
self
)
.
clone
(
)
)
)
;
}
fn
remove_child
(
&
self
child
:
Self
)
{
let
this_node
=
self
.
mut_node
(
)
;
let
child_node
=
child
.
mut_node
(
)
;
assert
!
(
(
get
!
(
child_node
parent_node
)
)
.
is_some
(
)
)
;
match
get
!
(
child_node
prev_sibling
)
{
None
=
>
set
!
(
this_node
set_first_child
get
!
(
child_node
next_sibling
)
)
Some
(
prev_sibling
)
=
>
{
let
prev_sibling_node
=
prev_sibling
.
mut_node
(
)
;
set
!
(
prev_sibling_node
set_next_sibling
get
!
(
child_node
next_sibling
)
)
;
}
}
match
get
!
(
child_node
next_sibling
)
{
None
=
>
set
!
(
this_node
set_last_child
get
!
(
child_node
prev_sibling
)
)
Some
(
next_sibling
)
=
>
{
let
next_sibling_node
=
next_sibling
.
mut_node
(
)
;
set
!
(
next_sibling_node
set_prev_sibling
get
!
(
child_node
prev_sibling
)
)
;
}
}
set
!
(
child_node
set_prev_sibling
None
)
;
set
!
(
child_node
set_next_sibling
None
)
;
set
!
(
child_node
set_parent_node
None
)
;
}
fn
children
(
&
self
)
-
>
ChildIterator
<
Self
>
{
ChildIterator
{
current
:
get
!
(
self
.
node
(
)
first_child
)
}
}
fn
ancestors
(
&
self
)
-
>
AncestorIterator
<
Self
>
{
AncestorIterator
{
current
:
get
!
(
self
.
node
(
)
parent_node
)
}
}
fn
traverse_preorder
(
&
self
)
-
>
TreeIterator
<
Self
>
{
self
.
traverse_preorder_prune
(
|
_
|
false
)
}
fn
traverse_postorder
(
&
self
)
-
>
TreeIterator
<
Self
>
{
self
.
traverse_postorder_prune
(
|
_
|
false
)
}
fn
traverse_preorder_prune
(
&
self
prune
:
&
fn
(
&
Self
)
-
>
bool
)
-
>
TreeIterator
<
Self
>
{
let
mut
nodes
=
~
[
]
;
gather
(
self
&
mut
nodes
false
prune
)
;
TreeIterator
:
:
new
(
nodes
)
}
fn
traverse_postorder_prune
(
&
self
prune
:
&
fn
(
&
Self
)
-
>
bool
)
-
>
TreeIterator
<
Self
>
{
let
mut
nodes
=
~
[
]
;
gather
(
self
&
mut
nodes
true
prune
)
;
TreeIterator
:
:
new
(
nodes
)
}
fn
is_element
(
&
self
)
-
>
bool
;
fn
is_root
(
&
self
)
-
>
bool
;
}
pub
trait
TreeNodeRefAsElement
<
Node
E
:
ElementLike
>
:
TreeNodeRef
<
Node
>
{
fn
with_imm_element_like
<
R
>
(
&
self
f
:
&
fn
(
&
E
)
-
>
R
)
-
>
R
;
}
fn
gather
<
Node
Ref
:
TreeNodeRef
<
Node
>
>
(
cur
:
&
Ref
refs
:
&
mut
~
[
Ref
]
postorder
:
bool
prune
:
&
fn
(
&
Ref
)
-
>
bool
)
{
if
prune
(
cur
)
{
return
;
}
if
!
postorder
{
refs
.
push
(
cur
.
clone
(
)
)
;
}
for
kid
in
cur
.
children
(
)
{
gather
(
&
kid
refs
postorder
|
a
|
prune
(
a
)
)
}
if
postorder
{
refs
.
push
(
cur
.
clone
(
)
)
;
}
}
pub
trait
TreeNode
<
Ref
:
TreeNodeRef
<
Self
>
>
{
fn
parent_node
(
&
self
)
-
>
Option
<
Ref
>
{
TreeNodeRef
:
:
<
Self
>
:
:
parent_node
(
self
)
}
fn
first_child
(
&
self
)
-
>
Option
<
Ref
>
{
TreeNodeRef
:
:
<
Self
>
:
:
first_child
(
self
)
}
fn
last_child
(
&
self
)
-
>
Option
<
Ref
>
{
TreeNodeRef
:
:
<
Self
>
:
:
last_child
(
self
)
}
fn
prev_sibling
(
&
self
)
-
>
Option
<
Ref
>
{
TreeNodeRef
:
:
<
Self
>
:
:
prev_sibling
(
self
)
}
fn
next_sibling
(
&
self
)
-
>
Option
<
Ref
>
{
TreeNodeRef
:
:
<
Self
>
:
:
next_sibling
(
self
)
}
fn
set_parent_node
(
&
mut
self
new_parent
:
Option
<
Ref
>
)
{
TreeNodeRef
:
:
<
Self
>
:
:
set_parent_node
(
self
new_parent
)
}
fn
set_first_child
(
&
mut
self
new_first_child
:
Option
<
Ref
>
)
{
TreeNodeRef
:
:
<
Self
>
:
:
set_first_child
(
self
new_first_child
)
}
fn
set_last_child
(
&
mut
self
new_last_child
:
Option
<
Ref
>
)
{
TreeNodeRef
:
:
<
Self
>
:
:
set_last_child
(
self
new_last_child
)
}
fn
set_prev_sibling
(
&
mut
self
new_prev_sibling
:
Option
<
Ref
>
)
{
TreeNodeRef
:
:
<
Self
>
:
:
set_prev_sibling
(
self
new_prev_sibling
)
}
fn
set_next_sibling
(
&
mut
self
new_next_sibling
:
Option
<
Ref
>
)
{
TreeNodeRef
:
:
<
Self
>
:
:
set_next_sibling
(
self
new_next_sibling
)
}
}
pub
trait
ElementLike
{
fn
get_local_name
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
str
;
fn
get_attr
(
&
self
name
:
&
str
)
-
>
Option
<
~
str
>
;
fn
get_link
(
&
self
)
-
>
Option
<
~
str
>
;
}
