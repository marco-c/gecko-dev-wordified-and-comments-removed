use
extra
:
:
time
:
:
precise_time_ns
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
comm
:
:
{
Port
SharedChan
}
;
use
extra
:
:
sort
:
:
tim_sort
;
#
[
deriving
(
Clone
)
]
pub
struct
ProfilerChan
{
chan
:
SharedChan
<
ProfilerMsg
>
}
impl
ProfilerChan
{
pub
fn
new
(
chan
:
Chan
<
ProfilerMsg
>
)
-
>
ProfilerChan
{
ProfilerChan
{
chan
:
SharedChan
:
:
new
(
chan
)
}
}
pub
fn
send
(
&
self
msg
:
ProfilerMsg
)
{
self
.
chan
.
send
(
msg
)
;
}
}
#
[
deriving
(
Eq
)
]
pub
enum
ProfilerCategory
{
CompositingCategory
LayoutQueryCategory
LayoutPerformCategory
LayoutAuxInitCategory
LayoutSelectorMatchCategory
LayoutTreeBuilderCategory
LayoutMainCategory
LayoutShapingCategory
LayoutDispListBuildCategory
GfxRegenAvailableFontsCategory
RenderingDrawingCategory
RenderingPrepBuffCategory
RenderingCategory
NUM_BUCKETS
}
static
BUCKETS
:
uint
=
13
;
pub
enum
ProfilerMsg
{
TimeMsg
(
ProfilerCategory
f64
)
PrintMsg
}
pub
struct
Profiler
{
port
:
Port
<
ProfilerMsg
>
buckets
:
~
[
(
ProfilerCategory
~
[
f64
]
)
]
last_msg
:
Option
<
ProfilerMsg
>
}
impl
ProfilerCategory
{
/
/
convenience
function
to
not
have
to
cast
every
time
pub
fn
num_buckets
(
)
-
>
uint
{
NUM_BUCKETS
as
uint
}
/
/
enumeration
of
all
ProfilerCategory
types
/
/
FIXME
(
tkuehn
)
:
this
is
ugly
and
error
-
prone
/
/
but
currently
we
lack
better
alternatives
without
an
enum
enumeration
priv
fn
empty_buckets
(
)
-
>
~
[
(
ProfilerCategory
~
[
f64
]
)
]
{
let
mut
vec
=
~
[
]
;
vec
.
push
(
(
CompositingCategory
~
[
]
)
)
;
vec
.
push
(
(
LayoutQueryCategory
~
[
]
)
)
;
vec
.
push
(
(
LayoutPerformCategory
~
[
]
)
)
;
vec
.
push
(
(
LayoutAuxInitCategory
~
[
]
)
)
;
vec
.
push
(
(
LayoutSelectorMatchCategory
~
[
]
)
)
;
vec
.
push
(
(
LayoutTreeBuilderCategory
~
[
]
)
)
;
vec
.
push
(
(
LayoutMainCategory
~
[
]
)
)
;
vec
.
push
(
(
LayoutShapingCategory
~
[
]
)
)
;
vec
.
push
(
(
LayoutDispListBuildCategory
~
[
]
)
)
;
vec
.
push
(
(
GfxRegenAvailableFontsCategory
~
[
]
)
)
;
vec
.
push
(
(
RenderingDrawingCategory
~
[
]
)
)
;
vec
.
push
(
(
RenderingPrepBuffCategory
~
[
]
)
)
;
vec
.
push
(
(
RenderingCategory
~
[
]
)
)
;
ProfilerCategory
:
:
check_order
(
vec
)
;
vec
}
priv
fn
check_order
(
vec
:
&
[
(
ProfilerCategory
~
[
f64
]
)
]
)
{
for
vec
.
iter
(
)
.
advance
|
&
(
category
_
)
|
{
if
category
!
=
vec
[
category
as
uint
]
.
first
(
)
{
fail
!
(
"
Enum
category
does
not
match
bucket
index
.
This
is
a
bug
.
"
)
;
}
}
}
/
/
some
categories
are
subcategories
of
LayoutPerformCategory
/
/
and
should
be
printed
to
indicate
this
pub
fn
format
(
self
)
-
>
~
str
{
let
padding
=
match
self
{
LayoutAuxInitCategory
|
LayoutSelectorMatchCategory
|
LayoutTreeBuilderCategory
|
LayoutMainCategory
|
LayoutDispListBuildCategory
|
LayoutShapingCategory
=
>
"
-
"
_
=
>
"
"
}
;
fmt
!
(
"
%
s
%
?
"
padding
self
)
}
}
impl
Profiler
{
pub
fn
create
(
port
:
Port
<
ProfilerMsg
>
)
{
let
port
=
Cell
:
:
new
(
port
)
;
do
spawn
{
let
mut
profiler
=
Profiler
:
:
new
(
port
.
take
(
)
)
;
profiler
.
start
(
)
;
}
}
pub
fn
new
(
port
:
Port
<
ProfilerMsg
>
)
-
>
Profiler
{
Profiler
{
port
:
port
buckets
:
ProfilerCategory
:
:
empty_buckets
(
)
last_msg
:
None
}
}
pub
fn
start
(
&
mut
self
)
{
loop
{
let
msg
=
self
.
port
.
recv
(
)
;
self
.
handle_msg
(
msg
)
;
}
}
priv
fn
handle_msg
(
&
mut
self
msg
:
ProfilerMsg
)
{
match
msg
{
TimeMsg
(
category
t
)
=
>
match
self
.
buckets
[
category
as
uint
]
{
/
/
FIXME
(
#
3874
)
:
this
should
be
a
let
(
cat
ref
mut
bucket
)
=
.
.
.
/
/
not
a
match
(
_
ref
mut
data
)
=
>
{
data
.
push
(
t
)
;
}
}
PrintMsg
=
>
match
self
.
last_msg
{
Some
(
TimeMsg
(
*
)
)
=
>
self
.
print_buckets
(
)
_
=
>
{
}
}
}
;
self
.
last_msg
=
Some
(
msg
)
;
}
priv
fn
print_buckets
(
&
mut
self
)
{
println
(
fmt
!
(
"
%
31s
%
15s
%
15s
%
15s
%
15s
%
15s
"
"
_category_
"
"
_mean
(
ms
)
_
"
"
_median
(
ms
)
_
"
"
_min
(
ms
)
_
"
"
_max
(
ms
)
_
"
"
_bucket
size_
"
)
)
;
for
self
.
buckets
.
mut_iter
(
)
.
advance
|
bucket
|
{
match
*
bucket
{
(
category
ref
mut
data
)
=
>
{
tim_sort
(
*
data
)
;
let
data_len
=
data
.
len
(
)
;
if
data_len
>
0
{
let
(
mean
median
min
max
)
=
(
data
.
iter
(
)
.
fold
(
0f64
|
a
b
|
a
+
*
b
)
/
(
data_len
as
f64
)
data
[
data_len
/
2
]
data
.
iter
(
)
.
min
(
)
data
.
iter
(
)
.
max
(
)
)
;
println
(
fmt
!
(
"
%
-
30s
:
%
15
.
4
?
%
15
.
4
?
%
15
.
4
?
%
15
.
4
?
%
15u
"
category
.
format
(
)
mean
median
min
max
data_len
)
)
;
}
}
}
}
println
(
"
"
)
;
}
}
pub
fn
profile
<
T
>
(
category
:
ProfilerCategory
profiler_chan
:
ProfilerChan
callback
:
&
fn
(
)
-
>
T
)
-
>
T
{
let
start_time
=
precise_time_ns
(
)
;
let
val
=
callback
(
)
;
let
end_time
=
precise_time_ns
(
)
;
let
ms
=
(
(
end_time
-
start_time
)
as
f64
/
1000000f64
)
;
profiler_chan
.
send
(
TimeMsg
(
category
ms
)
)
;
return
val
;
}
pub
fn
time
<
T
>
(
msg
:
&
str
callback
:
&
fn
(
)
-
>
T
)
-
>
T
{
let
start_time
=
precise_time_ns
(
)
;
let
val
=
callback
(
)
;
let
end_time
=
precise_time_ns
(
)
;
let
ms
=
(
(
end_time
-
start_time
)
as
f64
/
1000000f64
)
;
if
ms
>
=
5f64
{
debug
!
(
"
%
s
took
%
?
ms
"
msg
ms
)
;
}
return
val
;
}
