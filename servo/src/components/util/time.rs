use
std_time
:
:
precise_time_ns
;
use
collections
:
:
treemap
:
:
TreeMap
;
use
std
:
:
comm
:
:
{
Sender
channel
Receiver
}
;
use
std
:
:
f64
;
use
std
:
:
iter
:
:
AdditiveIterator
;
use
std
:
:
io
:
:
timer
:
:
sleep
;
use
task
:
:
{
spawn_named
}
;
#
[
deriving
(
Clone
)
]
pub
struct
ProfilerChan
(
pub
Sender
<
ProfilerMsg
>
)
;
impl
ProfilerChan
{
pub
fn
send
(
&
self
msg
:
ProfilerMsg
)
{
let
ProfilerChan
(
ref
c
)
=
*
self
;
c
.
send
(
msg
)
;
}
}
pub
enum
ProfilerMsg
{
TimeMsg
(
ProfilerCategory
f64
)
PrintMsg
ExitMsg
}
#
[
repr
(
u32
)
]
#
[
deriving
(
Eq
Clone
Ord
TotalEq
TotalOrd
)
]
pub
enum
ProfilerCategory
{
CompositingCategory
LayoutQueryCategory
LayoutPerformCategory
LayoutStyleRecalcCategory
LayoutSelectorMatchCategory
LayoutTreeBuilderCategory
LayoutDamagePropagateCategory
LayoutMainCategory
LayoutParallelWarmupCategory
LayoutShapingCategory
LayoutDispListBuildCategory
GfxRegenAvailableFontsCategory
RenderingDrawingCategory
RenderingPrepBuffCategory
RenderingCategory
NumBuckets
}
impl
ProfilerCategory
{
pub
fn
num_buckets
(
)
-
>
uint
{
NumBuckets
as
uint
}
fn
empty_buckets
(
)
-
>
ProfilerBuckets
{
let
mut
buckets
=
TreeMap
:
:
new
(
)
;
buckets
.
insert
(
CompositingCategory
vec
!
(
)
)
;
buckets
.
insert
(
LayoutQueryCategory
vec
!
(
)
)
;
buckets
.
insert
(
LayoutPerformCategory
vec
!
(
)
)
;
buckets
.
insert
(
LayoutStyleRecalcCategory
vec
!
(
)
)
;
buckets
.
insert
(
LayoutSelectorMatchCategory
vec
!
(
)
)
;
buckets
.
insert
(
LayoutTreeBuilderCategory
vec
!
(
)
)
;
buckets
.
insert
(
LayoutMainCategory
vec
!
(
)
)
;
buckets
.
insert
(
LayoutParallelWarmupCategory
vec
!
(
)
)
;
buckets
.
insert
(
LayoutShapingCategory
vec
!
(
)
)
;
buckets
.
insert
(
LayoutDamagePropagateCategory
vec
!
(
)
)
;
buckets
.
insert
(
LayoutDispListBuildCategory
vec
!
(
)
)
;
buckets
.
insert
(
GfxRegenAvailableFontsCategory
vec
!
(
)
)
;
buckets
.
insert
(
RenderingDrawingCategory
vec
!
(
)
)
;
buckets
.
insert
(
RenderingPrepBuffCategory
vec
!
(
)
)
;
buckets
.
insert
(
RenderingCategory
vec
!
(
)
)
;
buckets
}
pub
fn
format
(
self
)
-
>
~
str
{
let
padding
=
match
self
{
LayoutStyleRecalcCategory
|
LayoutMainCategory
|
LayoutDispListBuildCategory
|
LayoutShapingCategory
|
LayoutDamagePropagateCategory
=
>
"
+
"
LayoutParallelWarmupCategory
|
LayoutSelectorMatchCategory
|
LayoutTreeBuilderCategory
=
>
"
|
+
"
_
=
>
"
"
}
;
format
!
(
"
{
:
s
}
{
:
?
}
"
padding
self
)
}
}
type
ProfilerBuckets
=
TreeMap
<
ProfilerCategory
Vec
<
f64
>
>
;
/
/
back
end
of
the
profiler
that
handles
data
aggregation
and
performance
metrics
pub
struct
Profiler
{
pub
port
:
Receiver
<
ProfilerMsg
>
buckets
:
ProfilerBuckets
pub
last_msg
:
Option
<
ProfilerMsg
>
}
impl
Profiler
{
pub
fn
create
(
period
:
Option
<
f64
>
)
-
>
ProfilerChan
{
let
(
chan
port
)
=
channel
(
)
;
match
period
{
Some
(
period
)
=
>
{
let
period
=
(
period
*
1000f64
)
as
u64
;
let
chan
=
chan
.
clone
(
)
;
spawn_named
(
"
Profiler
timer
"
proc
(
)
{
loop
{
sleep
(
period
)
;
if
!
chan
.
try_send
(
PrintMsg
)
{
break
;
}
}
}
)
;
/
/
Spawn
the
profiler
spawn_named
(
"
Profiler
"
proc
(
)
{
let
mut
profiler
=
Profiler
:
:
new
(
port
)
;
profiler
.
start
(
)
;
}
)
;
}
None
=
>
{
/
/
no
-
op
to
handle
profiler
messages
when
the
profiler
is
inactive
spawn_named
(
"
Profiler
"
proc
(
)
{
loop
{
match
port
.
recv_opt
(
)
{
None
|
Some
(
ExitMsg
)
=
>
break
_
=
>
{
}
}
}
}
)
;
}
}
ProfilerChan
(
chan
)
}
pub
fn
new
(
port
:
Receiver
<
ProfilerMsg
>
)
-
>
Profiler
{
Profiler
{
port
:
port
buckets
:
ProfilerCategory
:
:
empty_buckets
(
)
last_msg
:
None
}
}
pub
fn
start
(
&
mut
self
)
{
loop
{
let
msg
=
self
.
port
.
recv_opt
(
)
;
match
msg
{
Some
(
msg
)
=
>
{
if
!
self
.
handle_msg
(
msg
)
{
break
}
}
None
=
>
break
}
}
}
fn
handle_msg
(
&
mut
self
msg
:
ProfilerMsg
)
-
>
bool
{
match
msg
{
TimeMsg
(
category
t
)
=
>
self
.
buckets
.
find_mut
(
&
category
)
.
unwrap
(
)
.
push
(
t
)
PrintMsg
=
>
match
self
.
last_msg
{
/
/
only
print
if
more
data
has
arrived
since
the
last
printout
Some
(
TimeMsg
(
.
.
)
)
=
>
self
.
print_buckets
(
)
_
=
>
(
)
}
ExitMsg
=
>
return
false
}
;
self
.
last_msg
=
Some
(
msg
)
;
true
}
fn
print_buckets
(
&
mut
self
)
{
println
!
(
"
{
:
39s
}
{
:
15s
}
{
:
15s
}
{
:
15s
}
{
:
15s
}
{
:
15s
}
"
"
_category_
"
"
_mean
(
ms
)
_
"
"
_median
(
ms
)
_
"
"
_min
(
ms
)
_
"
"
_max
(
ms
)
_
"
"
_bucket
size_
"
)
;
for
(
category
data
)
in
self
.
buckets
.
iter
(
)
{
/
/
FIXME
(
XXX
)
:
TreeMap
currently
lacks
mut_iter
(
)
let
mut
data
=
data
.
clone
(
)
;
data
.
sort_by
(
|
a
b
|
{
if
a
<
b
{
Less
}
else
{
Greater
}
}
)
;
let
data_len
=
data
.
len
(
)
;
if
data_len
>
0
{
let
(
mean
median
min
max
)
=
(
data
.
iter
(
)
.
map
(
|
&
x
|
x
)
.
sum
(
)
/
(
data_len
as
f64
)
*
data
.
get
(
data_len
/
2
)
data
.
iter
(
)
.
fold
(
f64
:
:
INFINITY
|
a
&
b
|
a
.
min
(
b
)
)
data
.
iter
(
)
.
fold
(
-
f64
:
:
INFINITY
|
a
&
b
|
a
.
max
(
b
)
)
)
;
println
!
(
"
{
:
-
35s
}
:
{
:
15
.
4f
}
{
:
15
.
4f
}
{
:
15
.
4f
}
{
:
15
.
4f
}
{
:
15u
}
"
category
.
format
(
)
mean
median
min
max
data_len
)
;
}
}
println
!
(
"
"
)
;
}
}
pub
fn
profile
<
T
>
(
category
:
ProfilerCategory
profiler_chan
:
ProfilerChan
callback
:
|
|
-
>
T
)
-
>
T
{
let
start_time
=
precise_time_ns
(
)
;
let
val
=
callback
(
)
;
let
end_time
=
precise_time_ns
(
)
;
let
ms
=
(
end_time
-
start_time
)
as
f64
/
1000000f64
;
profiler_chan
.
send
(
TimeMsg
(
category
ms
)
)
;
return
val
;
}
pub
fn
time
<
T
>
(
msg
:
&
str
callback
:
|
|
-
>
T
)
-
>
T
{
let
start_time
=
precise_time_ns
(
)
;
let
val
=
callback
(
)
;
let
end_time
=
precise_time_ns
(
)
;
let
ms
=
(
end_time
-
start_time
)
as
f64
/
1000000f64
;
if
ms
>
=
5f64
{
debug
!
(
"
{
:
s
}
took
{
}
ms
"
msg
ms
)
;
}
return
val
;
}
#
[
test
]
fn
check_order
(
)
{
let
buckets
=
ProfilerCategory
:
:
empty_buckets
(
)
;
assert
!
(
buckets
.
len
(
)
=
=
NumBuckets
as
uint
)
;
}
