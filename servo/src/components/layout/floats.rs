use
geom
:
:
point
:
:
Point2D
;
use
geom
:
:
rect
:
:
Rect
;
use
geom
:
:
size
:
:
Size2D
;
use
servo_util
:
:
geometry
:
:
{
Au
max
min
}
;
use
std
:
:
i32
;
use
std
:
:
fmt
;
use
style
:
:
computed_values
:
:
float
;
use
sync
:
:
Arc
;
#
[
deriving
(
Clone
)
]
pub
enum
FloatKind
{
FloatLeft
FloatRight
}
impl
FloatKind
{
pub
fn
from_property
(
property
:
float
:
:
T
)
-
>
FloatKind
{
match
property
{
float
:
:
none
=
>
fail
!
(
"
can
'
t
create
a
float
type
from
an
unfloated
property
"
)
float
:
:
left
=
>
FloatLeft
float
:
:
right
=
>
FloatRight
}
}
}
pub
enum
ClearType
{
ClearLeft
ClearRight
ClearBoth
}
#
[
deriving
(
Clone
)
]
struct
Float
{
bounds
:
Rect
<
Au
>
kind
:
FloatKind
}
impl
fmt
:
:
Show
for
Float
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
bounds
=
{
}
kind
=
{
:
?
}
"
self
.
bounds
self
.
kind
)
}
}
#
[
deriving
(
Clone
)
]
struct
FloatList
{
floats
:
Vec
<
Float
>
max_top
:
Au
}
impl
FloatList
{
fn
new
(
)
-
>
FloatList
{
FloatList
{
floats
:
vec
!
(
)
max_top
:
Au
(
0
)
}
}
}
impl
fmt
:
:
Show
for
FloatList
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
max_top
=
{
}
floats
=
{
:
?
}
"
self
.
max_top
self
.
floats
)
}
}
#
[
deriving
(
Clone
)
]
struct
FloatListRef
{
list
:
Option
<
Arc
<
FloatList
>
>
}
impl
FloatListRef
{
fn
new
(
)
-
>
FloatListRef
{
FloatListRef
{
list
:
None
}
}
fn
is_present
(
&
self
)
-
>
bool
{
self
.
list
.
is_some
(
)
}
#
[
inline
]
fn
get
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
&
'
a
FloatList
>
{
match
self
.
list
{
None
=
>
None
Some
(
ref
list
)
=
>
Some
(
&
*
*
list
)
}
}
#
[
allow
(
experimental
)
]
#
[
inline
]
fn
get_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
FloatList
{
if
self
.
list
.
is_none
(
)
{
self
.
list
=
Some
(
Arc
:
:
new
(
FloatList
:
:
new
(
)
)
)
}
self
.
list
.
as_mut
(
)
.
unwrap
(
)
.
make_unique
(
)
}
}
pub
struct
PlacementInfo
{
pub
size
:
Size2D
<
Au
>
pub
ceiling
:
Au
pub
max_width
:
Au
pub
kind
:
FloatKind
}
impl
fmt
:
:
Show
for
PlacementInfo
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
size
=
{
}
ceiling
=
{
}
max_width
=
{
}
kind
=
{
:
?
}
"
self
.
size
self
.
ceiling
self
.
max_width
self
.
kind
)
}
}
fn
range_intersect
(
top_1
:
Au
bottom_1
:
Au
top_2
:
Au
bottom_2
:
Au
)
-
>
(
Au
Au
)
{
(
max
(
top_1
top_2
)
min
(
bottom_1
bottom_2
)
)
}
#
[
deriving
(
Clone
)
]
pub
struct
Floats
{
list
:
FloatListRef
offset
:
Point2D
<
Au
>
}
impl
fmt
:
:
Show
for
Floats
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
.
list
.
get
(
)
{
None
=
>
{
write
!
(
f
"
[
empty
]
"
)
}
Some
(
list
)
=
>
{
write
!
(
f
"
offset
=
{
}
floats
=
{
}
"
self
.
offset
list
)
}
}
}
}
impl
Floats
{
pub
fn
new
(
)
-
>
Floats
{
Floats
{
list
:
FloatListRef
:
:
new
(
)
offset
:
Point2D
(
Au
(
0
)
Au
(
0
)
)
}
}
pub
fn
translate
(
&
mut
self
delta
:
Point2D
<
Au
>
)
{
self
.
offset
=
self
.
offset
+
delta
}
pub
fn
last_float_pos
(
&
self
)
-
>
Option
<
Point2D
<
Au
>
>
{
match
self
.
list
.
get
(
)
{
None
=
>
None
Some
(
list
)
=
>
{
match
list
.
floats
.
last
(
)
{
None
=
>
None
Some
(
float
)
=
>
Some
(
float
.
bounds
.
origin
+
self
.
offset
)
}
}
}
}
pub
fn
available_rect
(
&
self
top
:
Au
height
:
Au
max_x
:
Au
)
-
>
Option
<
Rect
<
Au
>
>
{
let
list
=
match
self
.
list
.
get
(
)
{
None
=
>
return
None
Some
(
list
)
=
>
list
}
;
let
top
=
top
-
self
.
offset
.
y
;
debug
!
(
"
available_rect
:
trying
to
find
space
at
{
}
"
top
)
;
let
mut
max_left
=
Au
(
0
)
-
self
.
offset
.
x
;
let
mut
l_top
=
None
;
let
mut
l_bottom
=
None
;
let
mut
min_right
=
max_x
-
self
.
offset
.
x
;
let
mut
r_top
=
None
;
let
mut
r_bottom
=
None
;
for
float
in
list
.
floats
.
iter
(
)
{
debug
!
(
"
available_rect
:
Checking
for
collision
against
float
"
)
;
let
float_pos
=
float
.
bounds
.
origin
;
let
float_size
=
float
.
bounds
.
size
;
debug
!
(
"
float_pos
:
{
}
float_size
:
{
}
"
float_pos
float_size
)
;
match
float
.
kind
{
FloatLeft
if
float_pos
.
x
+
float_size
.
width
>
max_left
&
&
float_pos
.
y
+
float_size
.
height
>
top
&
&
float_pos
.
y
<
top
+
height
=
>
{
max_left
=
float_pos
.
x
+
float_size
.
width
;
l_top
=
Some
(
float_pos
.
y
)
;
l_bottom
=
Some
(
float_pos
.
y
+
float_size
.
height
)
;
debug
!
(
"
available_rect
:
collision
with
left
float
:
new
max_left
is
{
}
"
max_left
)
;
}
FloatRight
if
float_pos
.
x
<
min_right
&
&
float_pos
.
y
+
float_size
.
height
>
top
&
&
float_pos
.
y
<
top
+
height
=
>
{
min_right
=
float_pos
.
x
;
r_top
=
Some
(
float_pos
.
y
)
;
r_bottom
=
Some
(
float_pos
.
y
+
float_size
.
height
)
;
debug
!
(
"
available_rect
:
collision
with
right
float
:
new
min_right
is
{
}
"
min_right
)
;
}
FloatLeft
|
FloatRight
=
>
{
}
}
}
let
(
top
bottom
)
=
match
(
r_top
r_bottom
l_top
l_bottom
)
{
(
Some
(
r_top
)
Some
(
r_bottom
)
Some
(
l_top
)
Some
(
l_bottom
)
)
=
>
range_intersect
(
max
(
top
r_top
)
r_bottom
max
(
top
l_top
)
l_bottom
)
(
None
None
Some
(
l_top
)
Some
(
l_bottom
)
)
=
>
(
max
(
top
l_top
)
l_bottom
)
(
Some
(
r_top
)
Some
(
r_bottom
)
None
None
)
=
>
(
max
(
top
r_top
)
r_bottom
)
(
None
None
None
None
)
=
>
return
None
_
=
>
fail
!
(
"
Reached
unreachable
state
when
computing
float
area
"
)
}
;
assert
!
(
top
<
=
bottom
"
Float
position
error
"
)
;
Some
(
Rect
{
origin
:
Point2D
(
max_left
top
)
+
self
.
offset
size
:
Size2D
(
min_right
-
max_left
bottom
-
top
)
}
)
}
pub
fn
add_float
(
&
mut
self
info
:
&
PlacementInfo
)
{
let
new_info
;
{
let
list
=
self
.
list
.
get_mut
(
)
;
new_info
=
PlacementInfo
{
size
:
info
.
size
ceiling
:
max
(
info
.
ceiling
list
.
max_top
+
self
.
offset
.
y
)
max_width
:
info
.
max_width
kind
:
info
.
kind
}
}
debug
!
(
"
add_float
:
added
float
with
info
{
:
?
}
"
new_info
)
;
let
new_float
=
Float
{
bounds
:
Rect
{
origin
:
self
.
place_between_floats
(
&
new_info
)
.
origin
-
self
.
offset
size
:
info
.
size
}
kind
:
info
.
kind
}
;
let
list
=
self
.
list
.
get_mut
(
)
;
list
.
floats
.
push
(
new_float
)
;
list
.
max_top
=
max
(
list
.
max_top
new_float
.
bounds
.
origin
.
y
)
;
}
fn
max_height_for_bounds
(
&
self
left
:
Au
top
:
Au
width
:
Au
)
-
>
Option
<
Au
>
{
let
list
=
match
self
.
list
.
get
(
)
{
None
=
>
return
None
Some
(
list
)
=
>
list
}
;
let
top
=
top
-
self
.
offset
.
y
;
let
left
=
left
-
self
.
offset
.
x
;
let
mut
max_height
=
None
;
for
float
in
list
.
floats
.
iter
(
)
{
if
float
.
bounds
.
origin
.
y
+
float
.
bounds
.
size
.
height
>
top
&
&
float
.
bounds
.
origin
.
x
+
float
.
bounds
.
size
.
width
>
left
&
&
float
.
bounds
.
origin
.
x
<
left
+
width
{
let
new_y
=
float
.
bounds
.
origin
.
y
;
max_height
=
Some
(
min
(
max_height
.
unwrap_or
(
new_y
)
new_y
)
)
;
}
}
max_height
.
map
(
|
h
|
h
+
self
.
offset
.
y
)
}
pub
fn
place_between_floats
(
&
self
info
:
&
PlacementInfo
)
-
>
Rect
<
Au
>
{
debug
!
(
"
place_between_floats
:
Placing
object
with
width
{
}
and
height
{
}
"
info
.
size
.
width
info
.
size
.
height
)
;
if
!
self
.
list
.
is_present
(
)
{
match
info
.
kind
{
FloatLeft
=
>
{
return
Rect
(
Point2D
(
Au
(
0
)
info
.
ceiling
)
Size2D
(
info
.
max_width
Au
(
i32
:
:
MAX
)
)
)
}
FloatRight
=
>
{
return
Rect
(
Point2D
(
info
.
max_width
-
info
.
size
.
width
info
.
ceiling
)
Size2D
(
info
.
max_width
Au
(
i32
:
:
MAX
)
)
)
}
}
}
let
mut
float_y
=
info
.
ceiling
;
loop
{
let
maybe_location
=
self
.
available_rect
(
float_y
info
.
size
.
height
info
.
max_width
)
;
debug
!
(
"
place_float
:
Got
available
rect
:
{
:
?
}
for
y
-
pos
:
{
}
"
maybe_location
float_y
)
;
match
maybe_location
{
None
=
>
{
return
match
info
.
kind
{
FloatLeft
=
>
{
Rect
(
Point2D
(
Au
(
0
)
float_y
)
Size2D
(
info
.
max_width
Au
(
i32
:
:
MAX
)
)
)
}
FloatRight
=
>
{
Rect
(
Point2D
(
info
.
max_width
-
info
.
size
.
width
float_y
)
Size2D
(
info
.
max_width
Au
(
i32
:
:
MAX
)
)
)
}
}
}
Some
(
rect
)
=
>
{
assert
!
(
rect
.
origin
.
y
+
rect
.
size
.
height
!
=
float_y
"
Non
-
terminating
float
placement
"
)
;
if
rect
.
size
.
width
>
=
info
.
size
.
width
{
let
height
=
self
.
max_height_for_bounds
(
rect
.
origin
.
x
rect
.
origin
.
y
rect
.
size
.
width
)
;
let
height
=
height
.
unwrap_or
(
Au
(
i32
:
:
MAX
)
)
;
return
match
info
.
kind
{
FloatLeft
=
>
{
Rect
(
Point2D
(
rect
.
origin
.
x
float_y
)
Size2D
(
rect
.
size
.
width
height
)
)
}
FloatRight
=
>
{
Rect
(
Point2D
(
rect
.
origin
.
x
+
rect
.
size
.
width
-
info
.
size
.
width
float_y
)
Size2D
(
rect
.
size
.
width
height
)
)
}
}
}
float_y
=
rect
.
origin
.
y
+
rect
.
size
.
height
;
}
}
}
}
pub
fn
clearance
(
&
self
clear
:
ClearType
)
-
>
Au
{
let
list
=
match
self
.
list
.
get
(
)
{
None
=
>
return
Au
(
0
)
Some
(
list
)
=
>
list
}
;
let
mut
clearance
=
Au
(
0
)
;
for
float
in
list
.
floats
.
iter
(
)
{
match
(
clear
float
.
kind
)
{
(
ClearLeft
FloatLeft
)
|
(
ClearRight
FloatRight
)
|
(
ClearBoth
_
)
=
>
{
let
y
=
self
.
offset
.
y
+
float
.
bounds
.
origin
.
y
+
float
.
bounds
.
size
.
height
;
clearance
=
max
(
clearance
y
)
;
}
_
=
>
{
}
}
}
clearance
}
}
