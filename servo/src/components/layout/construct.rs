#
!
[
deny
(
unsafe_block
)
]
use
css
:
:
node_style
:
:
StyledNode
;
use
block
:
:
BlockFlow
;
use
context
:
:
LayoutContext
;
use
floats
:
:
FloatKind
;
use
flow
:
:
{
Flow
ImmutableFlowUtils
MutableOwnedFlowUtils
}
;
use
flow
:
:
{
Descendants
AbsDescendants
}
;
use
flow
;
use
flow_ref
:
:
FlowRef
;
use
fragment
:
:
{
Fragment
GenericFragment
IframeFragment
IframeFragmentInfo
}
;
use
fragment
:
:
{
ImageFragment
ImageFragmentInfo
SpecificFragmentInfo
TableFragment
}
;
use
fragment
:
:
{
TableCellFragment
TableColumnFragment
TableColumnFragmentInfo
}
;
use
fragment
:
:
{
TableRowFragment
TableWrapperFragment
UnscannedTextFragment
}
;
use
fragment
:
:
{
UnscannedTextFragmentInfo
}
;
use
inline
:
:
{
FragmentIndex
InlineFragments
InlineFlow
}
;
use
parallel
;
use
table_wrapper
:
:
TableWrapperFlow
;
use
table
:
:
TableFlow
;
use
table_caption
:
:
TableCaptionFlow
;
use
table_colgroup
:
:
TableColGroupFlow
;
use
table_rowgroup
:
:
TableRowGroupFlow
;
use
table_row
:
:
TableRowFlow
;
use
table_cell
:
:
TableCellFlow
;
use
text
:
:
TextRunScanner
;
use
util
:
:
{
LayoutDataAccess
OpaqueNodeMethods
}
;
use
wrapper
:
:
{
PostorderNodeMutTraversal
TLayoutNode
ThreadSafeLayoutNode
}
;
use
wrapper
:
:
{
Before
BeforeBlock
After
AfterBlock
Normal
}
;
use
gfx
:
:
display_list
:
:
OpaqueNode
;
use
gfx
:
:
font_context
:
:
FontContext
;
use
script
:
:
dom
:
:
element
:
:
{
HTMLIFrameElementTypeId
HTMLImageElementTypeId
}
;
use
script
:
:
dom
:
:
element
:
:
{
HTMLObjectElementTypeId
}
;
use
script
:
:
dom
:
:
element
:
:
{
HTMLTableColElementTypeId
HTMLTableDataCellElementTypeId
}
;
use
script
:
:
dom
:
:
element
:
:
{
HTMLTableElementTypeId
HTMLTableHeaderCellElementTypeId
}
;
use
script
:
:
dom
:
:
element
:
:
{
HTMLTableRowElementTypeId
HTMLTableSectionElementTypeId
}
;
use
script
:
:
dom
:
:
node
:
:
{
CommentNodeTypeId
DoctypeNodeTypeId
DocumentFragmentNodeTypeId
}
;
use
script
:
:
dom
:
:
node
:
:
{
DocumentNodeTypeId
ElementNodeTypeId
ProcessingInstructionNodeTypeId
}
;
use
script
:
:
dom
:
:
node
:
:
{
TextNodeTypeId
}
;
use
servo_util
:
:
namespace
;
use
servo_util
:
:
range
:
:
Range
;
use
servo_util
:
:
url
:
:
{
is_image_data
parse_url
}
;
use
std
:
:
mem
;
use
std
:
:
sync
:
:
atomics
:
:
Relaxed
;
use
style
:
:
ComputedValues
;
use
style
:
:
computed_values
:
:
{
display
position
float
}
;
use
sync
:
:
Arc
;
use
url
:
:
Url
;
pub
enum
ConstructionResult
{
NoConstructionResult
FlowConstructionResult
(
FlowRef
AbsDescendants
)
ConstructionItemConstructionResult
(
ConstructionItem
)
}
pub
enum
ConstructionItem
{
InlineFragmentsConstructionItem
(
InlineFragmentsConstructionResult
)
WhitespaceConstructionItem
(
OpaqueNode
Arc
<
ComputedValues
>
)
TableColumnFragmentConstructionItem
(
Fragment
)
}
pub
struct
InlineFragmentsConstructionResult
{
pub
splits
:
Vec
<
InlineBlockSplit
>
pub
fragments
:
InlineFragments
pub
abs_descendants
:
AbsDescendants
}
pub
struct
InlineBlockSplit
{
pub
predecessors
:
InlineFragments
pub
flow
:
FlowRef
}
struct
InlineFragmentsAccumulator
{
fragments
:
InlineFragments
has_enclosing_range
:
bool
}
impl
InlineFragmentsAccumulator
{
fn
new
(
)
-
>
InlineFragmentsAccumulator
{
InlineFragmentsAccumulator
{
fragments
:
InlineFragments
:
:
new
(
)
has_enclosing_range
:
false
}
}
fn
from_inline_node
(
node
:
&
ThreadSafeLayoutNode
)
-
>
InlineFragmentsAccumulator
{
let
mut
fragments
=
InlineFragments
:
:
new
(
)
;
fragments
.
push_range
(
node
.
style
(
)
.
clone
(
)
Range
:
:
empty
(
)
)
;
InlineFragmentsAccumulator
{
fragments
:
fragments
has_enclosing_range
:
true
}
}
fn
finish
(
self
)
-
>
InlineFragments
{
let
InlineFragmentsAccumulator
{
fragments
:
mut
fragments
has_enclosing_range
}
=
self
;
if
has_enclosing_range
{
let
len
=
FragmentIndex
(
fragments
.
len
(
)
as
int
)
;
fragments
.
get_mut_range
(
FragmentIndex
(
0
)
)
.
range
.
extend_to
(
len
)
;
}
fragments
}
}
enum
WhitespaceStrippingMode
{
NoWhitespaceStripping
StripWhitespaceFromStart
StripWhitespaceFromEnd
}
pub
struct
FlowConstructor
<
'
a
>
{
pub
layout_context
:
&
'
a
mut
LayoutContext
pub
font_context
:
Option
<
Box
<
FontContext
>
>
}
impl
<
'
a
>
FlowConstructor
<
'
a
>
{
pub
fn
new
(
layout_context
:
&
'
a
mut
LayoutContext
font_context
:
Option
<
Box
<
FontContext
>
>
)
-
>
FlowConstructor
<
'
a
>
{
FlowConstructor
{
layout_context
:
layout_context
font_context
:
font_context
}
}
fn
font_context
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
FontContext
{
match
self
.
font_context
{
Some
(
ref
mut
font_context
)
=
>
{
let
font_context
:
&
mut
FontContext
=
*
font_context
;
font_context
}
None
=
>
self
.
layout_context
.
font_context
(
)
}
}
pub
fn
unwrap_font_context
(
self
)
-
>
Option
<
Box
<
FontContext
>
>
{
let
FlowConstructor
{
font_context
.
.
}
=
self
;
font_context
}
fn
build_fragment_info_for_image
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
url
:
Option
<
Url
>
)
-
>
SpecificFragmentInfo
{
match
url
{
None
=
>
GenericFragment
Some
(
url
)
=
>
{
ImageFragment
(
ImageFragmentInfo
:
:
new
(
node
url
self
.
layout_context
.
image_cache
.
clone
(
)
)
)
}
}
}
pub
fn
build_specific_fragment_info_for_node
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
SpecificFragmentInfo
{
match
node
.
type_id
(
)
{
Some
(
ElementNodeTypeId
(
HTMLImageElementTypeId
)
)
=
>
{
self
.
build_fragment_info_for_image
(
node
node
.
image_url
(
)
)
}
Some
(
ElementNodeTypeId
(
HTMLIFrameElementTypeId
)
)
=
>
{
IframeFragment
(
IframeFragmentInfo
:
:
new
(
node
)
)
}
Some
(
ElementNodeTypeId
(
HTMLObjectElementTypeId
)
)
=
>
{
let
data
=
node
.
get_object_data
(
&
self
.
layout_context
.
url
)
;
self
.
build_fragment_info_for_image
(
node
data
)
}
Some
(
ElementNodeTypeId
(
HTMLTableElementTypeId
)
)
=
>
TableWrapperFragment
Some
(
ElementNodeTypeId
(
HTMLTableColElementTypeId
)
)
=
>
{
TableColumnFragment
(
TableColumnFragmentInfo
:
:
new
(
node
)
)
}
Some
(
ElementNodeTypeId
(
HTMLTableDataCellElementTypeId
)
)
|
Some
(
ElementNodeTypeId
(
HTMLTableHeaderCellElementTypeId
)
)
=
>
TableCellFragment
Some
(
ElementNodeTypeId
(
HTMLTableRowElementTypeId
)
)
|
Some
(
ElementNodeTypeId
(
HTMLTableSectionElementTypeId
)
)
=
>
TableRowFragment
None
|
Some
(
TextNodeTypeId
)
=
>
UnscannedTextFragment
(
UnscannedTextFragmentInfo
:
:
new
(
node
)
)
_
=
>
GenericFragment
}
}
#
[
inline
(
always
)
]
fn
flush_inline_fragments_to_flow_or_list
(
&
mut
self
fragment_accumulator
:
InlineFragmentsAccumulator
flow
:
&
mut
FlowRef
flow_list
:
&
mut
Vec
<
FlowRef
>
whitespace_stripping
:
WhitespaceStrippingMode
node
:
&
ThreadSafeLayoutNode
)
{
let
mut
fragments
=
fragment_accumulator
.
finish
(
)
;
if
fragments
.
is_empty
(
)
{
return
}
;
match
whitespace_stripping
{
NoWhitespaceStripping
=
>
{
}
StripWhitespaceFromStart
=
>
{
fragments
.
strip_ignorable_whitespace_from_start
(
)
;
if
fragments
.
is_empty
(
)
{
return
}
;
}
StripWhitespaceFromEnd
=
>
{
fragments
.
strip_ignorable_whitespace_from_end
(
)
;
if
fragments
.
is_empty
(
)
{
return
}
;
}
}
let
mut
inline_flow
=
box
InlineFlow
:
:
from_fragments
(
(
*
node
)
.
clone
(
)
fragments
)
;
let
(
ascent
descent
)
=
inline_flow
.
compute_minimum_ascent_and_descent
(
self
.
font_context
(
)
&
*
*
node
.
style
(
)
)
;
inline_flow
.
minimum_height_above_baseline
=
ascent
;
inline_flow
.
minimum_depth_below_baseline
=
descent
;
let
mut
inline_flow
=
inline_flow
as
Box
<
Flow
>
;
TextRunScanner
:
:
new
(
)
.
scan_for_runs
(
self
.
font_context
(
)
inline_flow
)
;
let
mut
inline_flow
=
FlowRef
:
:
new
(
inline_flow
)
;
inline_flow
.
finish
(
self
.
layout_context
)
;
if
flow
.
get
(
)
.
need_anonymous_flow
(
inline_flow
.
get
(
)
)
{
flow_list
.
push
(
inline_flow
)
}
else
{
flow
.
add_new_child
(
inline_flow
)
}
}
fn
build_block_flow_using_children_construction_result
(
&
mut
self
flow
:
&
mut
FlowRef
consecutive_siblings
:
&
mut
Vec
<
FlowRef
>
node
:
&
ThreadSafeLayoutNode
kid
:
ThreadSafeLayoutNode
inline_fragment_accumulator
:
&
mut
InlineFragmentsAccumulator
abs_descendants
:
&
mut
Descendants
first_fragment
:
&
mut
bool
)
{
match
kid
.
swap_out_construction_result
(
)
{
NoConstructionResult
=
>
{
}
FlowConstructionResult
(
kid_flow
kid_abs_descendants
)
=
>
{
if
flow
.
get
(
)
.
is_table
(
)
&
&
kid_flow
.
get
(
)
.
is_table_caption
(
)
{
kid
.
set_flow_construction_result
(
FlowConstructionResult
(
kid_flow
Descendants
:
:
new
(
)
)
)
}
else
if
flow
.
get
(
)
.
need_anonymous_flow
(
kid_flow
.
get
(
)
)
{
consecutive_siblings
.
push
(
kid_flow
)
}
else
{
let
whitespace_stripping
=
if
flow
.
get
(
)
.
is_table_kind
(
)
|
|
*
first_fragment
{
*
first_fragment
=
false
;
StripWhitespaceFromStart
}
else
{
NoWhitespaceStripping
}
;
debug
!
(
"
flushing
{
}
inline
box
(
es
)
to
flow
A
"
inline_fragment_accumulator
.
fragments
.
len
(
)
)
;
self
.
flush_inline_fragments_to_flow_or_list
(
mem
:
:
replace
(
inline_fragment_accumulator
InlineFragmentsAccumulator
:
:
new
(
)
)
flow
consecutive_siblings
whitespace_stripping
node
)
;
if
!
consecutive_siblings
.
is_empty
(
)
{
let
consecutive_siblings
=
mem
:
:
replace
(
consecutive_siblings
vec
!
(
)
)
;
self
.
generate_anonymous_missing_child
(
consecutive_siblings
flow
node
)
;
}
flow
.
add_new_child
(
kid_flow
)
;
}
abs_descendants
.
push_descendants
(
kid_abs_descendants
)
;
}
ConstructionItemConstructionResult
(
InlineFragmentsConstructionItem
(
InlineFragmentsConstructionResult
{
splits
:
splits
fragments
:
successor_fragments
abs_descendants
:
kid_abs_descendants
}
)
)
=
>
{
for
split
in
splits
.
move_iter
(
)
{
let
InlineBlockSplit
{
predecessors
:
predecessors
flow
:
kid_flow
}
=
split
;
inline_fragment_accumulator
.
fragments
.
push_all
(
predecessors
)
;
let
whitespace_stripping
=
if
*
first_fragment
{
*
first_fragment
=
false
;
StripWhitespaceFromStart
}
else
{
NoWhitespaceStripping
}
;
debug
!
(
"
flushing
{
}
inline
box
(
es
)
to
flow
A
"
inline_fragment_accumulator
.
fragments
.
len
(
)
)
;
self
.
flush_inline_fragments_to_flow_or_list
(
mem
:
:
replace
(
inline_fragment_accumulator
InlineFragmentsAccumulator
:
:
new
(
)
)
flow
consecutive_siblings
whitespace_stripping
node
)
;
if
flow
.
get
(
)
.
need_anonymous_flow
(
kid_flow
.
get
(
)
)
{
consecutive_siblings
.
push
(
kid_flow
)
}
else
{
flow
.
add_new_child
(
kid_flow
)
}
}
inline_fragment_accumulator
.
fragments
.
push_all
(
successor_fragments
)
;
abs_descendants
.
push_descendants
(
kid_abs_descendants
)
;
}
ConstructionItemConstructionResult
(
WhitespaceConstructionItem
(
.
.
)
)
=
>
{
}
ConstructionItemConstructionResult
(
TableColumnFragmentConstructionItem
(
_
)
)
=
>
{
}
}
}
fn
build_flow_using_children
(
&
mut
self
mut
flow
:
FlowRef
node
:
&
ThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
mut
inline_fragment_accumulator
=
InlineFragmentsAccumulator
:
:
new
(
)
;
let
mut
consecutive_siblings
=
vec
!
(
)
;
let
mut
first_fragment
=
true
;
let
mut
abs_descendants
=
Descendants
:
:
new
(
)
;
for
kid
in
node
.
children
(
)
{
if
kid
.
get_pseudo_element_type
(
)
!
=
Normal
{
self
.
process
(
&
kid
)
;
}
self
.
build_block_flow_using_children_construction_result
(
&
mut
flow
&
mut
consecutive_siblings
node
kid
&
mut
inline_fragment_accumulator
&
mut
abs_descendants
&
mut
first_fragment
)
;
}
self
.
flush_inline_fragments_to_flow_or_list
(
inline_fragment_accumulator
&
mut
flow
&
mut
consecutive_siblings
StripWhitespaceFromEnd
node
)
;
if
!
consecutive_siblings
.
is_empty
(
)
{
self
.
generate_anonymous_missing_child
(
consecutive_siblings
&
mut
flow
node
)
;
}
flow
.
finish
(
self
.
layout_context
)
;
let
is_positioned
=
flow
.
get_mut
(
)
.
as_block
(
)
.
is_positioned
(
)
;
let
is_fixed_positioned
=
flow
.
get_mut
(
)
.
as_block
(
)
.
is_fixed
(
)
;
let
is_absolutely_positioned
=
flow
.
get_mut
(
)
.
as_block
(
)
.
is_absolutely_positioned
(
)
;
if
is_positioned
{
flow
.
set_abs_descendants
(
abs_descendants
)
;
abs_descendants
=
Descendants
:
:
new
(
)
;
if
is_fixed_positioned
|
|
is_absolutely_positioned
{
abs_descendants
.
push
(
flow
.
clone
(
)
)
;
}
}
FlowConstructionResult
(
flow
abs_descendants
)
}
fn
build_flow_for_block
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
flow
=
box
BlockFlow
:
:
from_node
(
self
node
)
as
Box
<
Flow
>
;
self
.
build_flow_using_children
(
FlowRef
:
:
new
(
flow
)
node
)
}
fn
build_flow_for_floated_block
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
float_kind
:
FloatKind
)
-
>
ConstructionResult
{
let
flow
=
box
BlockFlow
:
:
float_from_node
(
self
node
float_kind
)
as
Box
<
Flow
>
;
self
.
build_flow_using_children
(
FlowRef
:
:
new
(
flow
)
node
)
}
fn
build_fragments_for_nonreplaced_inline_content
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
mut
opt_inline_block_splits
:
Vec
<
InlineBlockSplit
>
=
Vec
:
:
new
(
)
;
let
mut
fragment_accumulator
=
InlineFragmentsAccumulator
:
:
from_inline_node
(
node
)
;
let
mut
abs_descendants
=
Descendants
:
:
new
(
)
;
for
kid
in
node
.
children
(
)
{
if
kid
.
get_pseudo_element_type
(
)
!
=
Normal
{
self
.
process
(
&
kid
)
;
}
match
kid
.
swap_out_construction_result
(
)
{
NoConstructionResult
=
>
{
}
FlowConstructionResult
(
flow
kid_abs_descendants
)
=
>
{
let
split
=
InlineBlockSplit
{
predecessors
:
mem
:
:
replace
(
&
mut
fragment_accumulator
InlineFragmentsAccumulator
:
:
from_inline_node
(
node
)
)
.
finish
(
)
flow
:
flow
}
;
opt_inline_block_splits
.
push
(
split
)
;
abs_descendants
.
push_descendants
(
kid_abs_descendants
)
;
}
ConstructionItemConstructionResult
(
InlineFragmentsConstructionItem
(
InlineFragmentsConstructionResult
{
splits
:
splits
fragments
:
successors
abs_descendants
:
kid_abs_descendants
}
)
)
=
>
{
for
split
in
splits
.
move_iter
(
)
{
let
InlineBlockSplit
{
predecessors
:
predecessors
flow
:
kid_flow
}
=
split
;
fragment_accumulator
.
fragments
.
push_all
(
predecessors
)
;
let
split
=
InlineBlockSplit
{
predecessors
:
mem
:
:
replace
(
&
mut
fragment_accumulator
InlineFragmentsAccumulator
:
:
from_inline_node
(
node
)
)
.
finish
(
)
flow
:
kid_flow
}
;
opt_inline_block_splits
.
push
(
split
)
}
fragment_accumulator
.
fragments
.
push_all
(
successors
)
;
abs_descendants
.
push_descendants
(
kid_abs_descendants
)
;
}
ConstructionItemConstructionResult
(
WhitespaceConstructionItem
(
whitespace_node
whitespace_style
)
)
=
>
{
let
fragment_info
=
UnscannedTextFragment
(
UnscannedTextFragmentInfo
:
:
from_text
(
"
"
.
to_string
(
)
)
)
;
let
fragment
=
Fragment
:
:
from_opaque_node_and_style
(
whitespace_node
whitespace_style
.
clone
(
)
fragment_info
)
;
fragment_accumulator
.
fragments
.
push
(
fragment
whitespace_style
)
}
ConstructionItemConstructionResult
(
TableColumnFragmentConstructionItem
(
_
)
)
=
>
{
}
}
}
if
opt_inline_block_splits
.
len
(
)
>
0
|
|
fragment_accumulator
.
fragments
.
len
(
)
>
0
|
|
abs_descendants
.
len
(
)
>
0
{
let
construction_item
=
InlineFragmentsConstructionItem
(
InlineFragmentsConstructionResult
{
splits
:
opt_inline_block_splits
fragments
:
fragment_accumulator
.
finish
(
)
abs_descendants
:
abs_descendants
}
)
;
ConstructionItemConstructionResult
(
construction_item
)
}
else
{
NoConstructionResult
}
}
fn
build_fragments_for_replaced_inline_content
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
ConstructionResult
{
for
kid
in
node
.
children
(
)
{
kid
.
set_flow_construction_result
(
NoConstructionResult
)
}
if
node
.
is_ignorable_whitespace
(
)
{
let
opaque_node
=
OpaqueNodeMethods
:
:
from_thread_safe_layout_node
(
node
)
;
return
ConstructionItemConstructionResult
(
WhitespaceConstructionItem
(
opaque_node
node
.
style
(
)
.
clone
(
)
)
)
}
let
mut
fragments
=
InlineFragments
:
:
new
(
)
;
fragments
.
push
(
Fragment
:
:
new
(
self
node
)
node
.
style
(
)
.
clone
(
)
)
;
let
construction_item
=
InlineFragmentsConstructionItem
(
InlineFragmentsConstructionResult
{
splits
:
Vec
:
:
new
(
)
fragments
:
fragments
abs_descendants
:
Descendants
:
:
new
(
)
}
)
;
ConstructionItemConstructionResult
(
construction_item
)
}
fn
build_fragments_for_inline
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
ConstructionResult
{
if
!
node
.
is_replaced_content
(
)
{
self
.
build_fragments_for_nonreplaced_inline_content
(
node
)
}
else
{
self
.
build_fragments_for_replaced_inline_content
(
node
)
}
}
fn
place_table_caption_under_table_wrapper
(
&
mut
self
table_wrapper_flow
:
&
mut
FlowRef
node
:
&
ThreadSafeLayoutNode
)
{
for
kid
in
node
.
children
(
)
{
match
kid
.
swap_out_construction_result
(
)
{
NoConstructionResult
|
ConstructionItemConstructionResult
(
_
)
=
>
{
}
FlowConstructionResult
(
kid_flow
_
)
=
>
{
assert
!
(
kid_flow
.
get
(
)
.
is_table_caption
(
)
)
;
table_wrapper_flow
.
add_new_child
(
kid_flow
)
;
}
}
}
}
fn
generate_anonymous_missing_child
(
&
mut
self
child_flows
:
Vec
<
FlowRef
>
flow
:
&
mut
FlowRef
node
:
&
ThreadSafeLayoutNode
)
{
let
mut
anonymous_flow
=
flow
.
get
(
)
.
generate_missing_child_flow
(
node
)
;
let
mut
consecutive_siblings
=
vec
!
(
)
;
for
kid_flow
in
child_flows
.
move_iter
(
)
{
if
anonymous_flow
.
get
(
)
.
need_anonymous_flow
(
kid_flow
.
get
(
)
)
{
consecutive_siblings
.
push
(
kid_flow
)
;
continue
;
}
if
!
consecutive_siblings
.
is_empty
(
)
{
self
.
generate_anonymous_missing_child
(
consecutive_siblings
&
mut
anonymous_flow
node
)
;
consecutive_siblings
=
vec
!
(
)
;
}
anonymous_flow
.
add_new_child
(
kid_flow
)
;
}
if
!
consecutive_siblings
.
is_empty
(
)
{
self
.
generate_anonymous_missing_child
(
consecutive_siblings
&
mut
anonymous_flow
node
)
;
}
anonymous_flow
.
finish
(
self
.
layout_context
)
;
flow
.
add_new_child
(
anonymous_flow
)
;
}
fn
build_flow_for_table_wrapper
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
fragment
=
Fragment
:
:
new_from_specific_info
(
node
TableWrapperFragment
)
;
let
wrapper_flow
=
box
TableWrapperFlow
:
:
from_node_and_fragment
(
node
fragment
)
;
let
mut
wrapper_flow
=
FlowRef
:
:
new
(
wrapper_flow
as
Box
<
Flow
>
)
;
let
table_fragment
=
Fragment
:
:
new_from_specific_info
(
node
TableFragment
)
;
let
table_flow
=
box
TableFlow
:
:
from_node_and_fragment
(
node
table_fragment
)
;
let
table_flow
=
FlowRef
:
:
new
(
table_flow
as
Box
<
Flow
>
)
;
let
construction_result
=
self
.
build_flow_using_children
(
table_flow
node
)
;
self
.
place_table_caption_under_table_wrapper
(
&
mut
wrapper_flow
node
)
;
let
mut
abs_descendants
=
Descendants
:
:
new
(
)
;
let
mut
fixed_descendants
=
Descendants
:
:
new
(
)
;
match
construction_result
{
FlowConstructionResult
(
table_flow
table_abs_descendants
)
=
>
{
wrapper_flow
.
add_new_child
(
table_flow
)
;
abs_descendants
.
push_descendants
(
table_abs_descendants
)
;
}
_
=
>
{
}
}
wrapper_flow
.
finish
(
self
.
layout_context
)
;
let
is_positioned
=
wrapper_flow
.
get_mut
(
)
.
as_block
(
)
.
is_positioned
(
)
;
let
is_fixed_positioned
=
wrapper_flow
.
get_mut
(
)
.
as_block
(
)
.
is_fixed
(
)
;
let
is_absolutely_positioned
=
wrapper_flow
.
get_mut
(
)
.
as_block
(
)
.
is_absolutely_positioned
(
)
;
if
is_positioned
{
wrapper_flow
.
set_abs_descendants
(
abs_descendants
)
;
abs_descendants
=
Descendants
:
:
new
(
)
;
if
is_fixed_positioned
{
fixed_descendants
.
push
(
wrapper_flow
.
clone
(
)
)
;
}
else
if
is_absolutely_positioned
{
abs_descendants
.
push
(
wrapper_flow
.
clone
(
)
)
;
}
}
FlowConstructionResult
(
wrapper_flow
abs_descendants
)
}
fn
build_flow_for_table_caption
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
flow
=
box
TableCaptionFlow
:
:
from_node
(
self
node
)
as
Box
<
Flow
>
;
self
.
build_flow_using_children
(
FlowRef
:
:
new
(
flow
)
node
)
}
fn
build_flow_for_table_rowgroup
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
fragment
=
Fragment
:
:
new_from_specific_info
(
node
TableRowFragment
)
;
let
flow
=
box
TableRowGroupFlow
:
:
from_node_and_fragment
(
node
fragment
)
;
let
flow
=
flow
as
Box
<
Flow
>
;
self
.
build_flow_using_children
(
FlowRef
:
:
new
(
flow
)
node
)
}
fn
build_flow_for_table_row
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
fragment
=
Fragment
:
:
new_from_specific_info
(
node
TableRowFragment
)
;
let
flow
=
box
TableRowFlow
:
:
from_node_and_fragment
(
node
fragment
)
as
Box
<
Flow
>
;
self
.
build_flow_using_children
(
FlowRef
:
:
new
(
flow
)
node
)
}
fn
build_flow_for_table_cell
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
fragment
=
Fragment
:
:
new_from_specific_info
(
node
TableCellFragment
)
;
let
flow
=
box
TableCellFlow
:
:
from_node_and_fragment
(
node
fragment
)
as
Box
<
Flow
>
;
self
.
build_flow_using_children
(
FlowRef
:
:
new
(
flow
)
node
)
}
fn
build_fragments_for_table_column
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
ConstructionResult
{
for
kid
in
node
.
children
(
)
{
kid
.
set_flow_construction_result
(
NoConstructionResult
)
}
let
specific
=
TableColumnFragment
(
TableColumnFragmentInfo
:
:
new
(
node
)
)
;
let
construction_item
=
TableColumnFragmentConstructionItem
(
Fragment
:
:
new_from_specific_info
(
node
specific
)
)
;
ConstructionItemConstructionResult
(
construction_item
)
}
fn
build_flow_for_table_colgroup
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
fragment
=
Fragment
:
:
new_from_specific_info
(
node
TableColumnFragment
(
TableColumnFragmentInfo
:
:
new
(
node
)
)
)
;
let
mut
col_fragments
=
vec
!
(
)
;
for
kid
in
node
.
children
(
)
{
match
kid
.
swap_out_construction_result
(
)
{
ConstructionItemConstructionResult
(
TableColumnFragmentConstructionItem
(
fragment
)
)
=
>
{
col_fragments
.
push
(
fragment
)
;
}
_
=
>
{
}
}
}
if
col_fragments
.
is_empty
(
)
{
debug
!
(
"
add
TableColumnFragment
for
empty
colgroup
"
)
;
let
specific
=
TableColumnFragment
(
TableColumnFragmentInfo
:
:
new
(
node
)
)
;
col_fragments
.
push
(
Fragment
:
:
new_from_specific_info
(
node
specific
)
)
;
}
let
flow
=
box
TableColGroupFlow
:
:
from_node_and_fragments
(
node
fragment
col_fragments
)
;
let
mut
flow
=
FlowRef
:
:
new
(
flow
as
Box
<
Flow
>
)
;
flow
.
finish
(
self
.
layout_context
)
;
FlowConstructionResult
(
flow
Descendants
:
:
new
(
)
)
}
}
impl
<
'
a
>
PostorderNodeMutTraversal
for
FlowConstructor
<
'
a
>
{
#
[
inline
(
always
)
]
fn
process
(
&
mut
self
node
:
&
ThreadSafeLayoutNode
)
-
>
bool
{
let
(
display
float
positioning
)
=
match
node
.
type_id
(
)
{
None
=
>
{
let
style
=
node
.
style
(
)
;
(
display
:
:
inline
style
.
get_box
(
)
.
float
style
.
get_box
(
)
.
position
)
}
Some
(
ElementNodeTypeId
(
_
)
)
=
>
{
let
style
=
node
.
style
(
)
;
(
style
.
get_box
(
)
.
display
style
.
get_box
(
)
.
float
style
.
get_box
(
)
.
position
)
}
Some
(
TextNodeTypeId
)
=
>
(
display
:
:
inline
float
:
:
none
position
:
:
static_
)
Some
(
CommentNodeTypeId
)
|
Some
(
DoctypeNodeTypeId
)
|
Some
(
DocumentFragmentNodeTypeId
)
|
Some
(
DocumentNodeTypeId
)
|
Some
(
ProcessingInstructionNodeTypeId
)
=
>
{
(
display
:
:
none
float
:
:
none
position
:
:
static_
)
}
}
;
debug
!
(
"
building
flow
for
node
:
{
:
?
}
{
:
?
}
"
display
float
)
;
match
(
display
float
positioning
)
{
(
display
:
:
none
_
_
)
=
>
{
for
child
in
node
.
children
(
)
{
drop
(
child
.
swap_out_construction_result
(
)
)
}
}
(
display
:
:
table
_
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_table_wrapper
(
node
)
;
node
.
set_flow_construction_result
(
construction_result
)
}
(
display
:
:
block
_
position
:
:
absolute
)
|
(
_
_
position
:
:
fixed
)
=
>
{
node
.
set_flow_construction_result
(
self
.
build_flow_for_block
(
node
)
)
}
(
display
:
:
inline
float
:
:
none
_
)
=
>
{
let
construction_result
=
self
.
build_fragments_for_inline
(
node
)
;
node
.
set_flow_construction_result
(
construction_result
)
}
(
display
:
:
table_caption
_
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_table_caption
(
node
)
;
node
.
set_flow_construction_result
(
construction_result
)
}
(
display
:
:
table_column_group
_
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_table_colgroup
(
node
)
;
node
.
set_flow_construction_result
(
construction_result
)
}
(
display
:
:
table_column
_
_
)
=
>
{
let
construction_result
=
self
.
build_fragments_for_table_column
(
node
)
;
node
.
set_flow_construction_result
(
construction_result
)
}
(
display
:
:
table_row_group
_
_
)
|
(
display
:
:
table_header_group
_
_
)
|
(
display
:
:
table_footer_group
_
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_table_rowgroup
(
node
)
;
node
.
set_flow_construction_result
(
construction_result
)
}
(
display
:
:
table_row
_
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_table_row
(
node
)
;
node
.
set_flow_construction_result
(
construction_result
)
}
(
display
:
:
table_cell
_
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_table_cell
(
node
)
;
node
.
set_flow_construction_result
(
construction_result
)
}
(
_
float
:
:
none
_
)
=
>
{
node
.
set_flow_construction_result
(
self
.
build_flow_for_block
(
node
)
)
}
(
_
float_value
_
)
=
>
{
let
float_kind
=
FloatKind
:
:
from_property
(
float_value
)
;
node
.
set_flow_construction_result
(
self
.
build_flow_for_floated_block
(
node
float_kind
)
)
}
}
true
}
}
trait
NodeUtils
{
fn
is_replaced_content
(
&
self
)
-
>
bool
;
fn
set_flow_construction_result
(
&
self
result
:
ConstructionResult
)
;
fn
swap_out_construction_result
(
&
self
)
-
>
ConstructionResult
;
}
impl
<
'
ln
>
NodeUtils
for
ThreadSafeLayoutNode
<
'
ln
>
{
fn
is_replaced_content
(
&
self
)
-
>
bool
{
match
self
.
type_id
(
)
{
Some
(
TextNodeTypeId
)
|
Some
(
ProcessingInstructionNodeTypeId
)
|
Some
(
CommentNodeTypeId
)
|
Some
(
DoctypeNodeTypeId
)
|
Some
(
DocumentFragmentNodeTypeId
)
|
Some
(
DocumentNodeTypeId
)
|
None
|
Some
(
ElementNodeTypeId
(
HTMLImageElementTypeId
)
)
=
>
true
Some
(
ElementNodeTypeId
(
HTMLObjectElementTypeId
)
)
=
>
self
.
has_object_data
(
)
Some
(
ElementNodeTypeId
(
_
)
)
=
>
false
}
}
#
[
inline
(
always
)
]
fn
set_flow_construction_result
(
&
self
result
:
ConstructionResult
)
{
let
mut
layout_data_ref
=
self
.
mutate_layout_data
(
)
;
match
&
mut
*
layout_data_ref
{
&
Some
(
ref
mut
layout_data
)
=
>
{
match
self
.
get_pseudo_element_type
(
)
{
Before
|
BeforeBlock
=
>
{
layout_data
.
data
.
before_flow_construction_result
=
result
}
After
|
AfterBlock
=
>
{
layout_data
.
data
.
after_flow_construction_result
=
result
}
Normal
=
>
layout_data
.
data
.
flow_construction_result
=
result
}
}
&
None
=
>
fail
!
(
"
no
layout
data
"
)
}
}
#
[
inline
(
always
)
]
fn
swap_out_construction_result
(
&
self
)
-
>
ConstructionResult
{
let
mut
layout_data_ref
=
self
.
mutate_layout_data
(
)
;
match
&
mut
*
layout_data_ref
{
&
Some
(
ref
mut
layout_data
)
=
>
{
match
self
.
get_pseudo_element_type
(
)
{
Before
|
BeforeBlock
=
>
{
mem
:
:
replace
(
&
mut
layout_data
.
data
.
before_flow_construction_result
NoConstructionResult
)
}
After
|
AfterBlock
=
>
{
mem
:
:
replace
(
&
mut
layout_data
.
data
.
after_flow_construction_result
NoConstructionResult
)
}
Normal
=
>
{
mem
:
:
replace
(
&
mut
layout_data
.
data
.
flow_construction_result
NoConstructionResult
)
}
}
}
&
None
=
>
fail
!
(
"
no
layout
data
"
)
}
}
}
trait
ObjectElement
{
fn
get_type_and_data
(
&
self
)
-
>
(
Option
<
&
'
static
str
>
Option
<
&
'
static
str
>
)
;
fn
has_object_data
(
&
self
)
-
>
bool
;
fn
get_object_data
(
&
self
base_url
:
&
Url
)
-
>
Option
<
Url
>
;
}
impl
<
'
ln
>
ObjectElement
for
ThreadSafeLayoutNode
<
'
ln
>
{
fn
get_type_and_data
(
&
self
)
-
>
(
Option
<
&
'
static
str
>
Option
<
&
'
static
str
>
)
{
let
elem
=
self
.
as_element
(
)
;
(
elem
.
get_attr
(
&
namespace
:
:
Null
"
type
"
)
elem
.
get_attr
(
&
namespace
:
:
Null
"
data
"
)
)
}
fn
has_object_data
(
&
self
)
-
>
bool
{
match
self
.
get_type_and_data
(
)
{
(
None
Some
(
uri
)
)
=
>
is_image_data
(
uri
)
_
=
>
false
}
}
fn
get_object_data
(
&
self
base_url
:
&
Url
)
-
>
Option
<
Url
>
{
match
self
.
get_type_and_data
(
)
{
(
None
Some
(
uri
)
)
if
is_image_data
(
uri
)
=
>
Some
(
parse_url
(
uri
Some
(
base_url
.
clone
(
)
)
)
)
_
=
>
None
}
}
}
pub
trait
FlowConstructionUtils
{
fn
add_new_child
(
&
mut
self
new_child
:
FlowRef
)
;
fn
finish
(
&
mut
self
context
:
&
mut
LayoutContext
)
;
}
impl
FlowConstructionUtils
for
FlowRef
{
fn
add_new_child
(
&
mut
self
mut
new_child
:
FlowRef
)
{
{
let
kid_base
=
flow
:
:
mut_base
(
new_child
.
get_mut
(
)
)
;
kid_base
.
parallel
.
parent
=
parallel
:
:
mut_owned_flow_to_unsafe_flow
(
self
)
;
}
let
base
=
flow
:
:
mut_base
(
self
.
get_mut
(
)
)
;
base
.
children
.
push_back
(
new_child
)
;
let
_
=
base
.
parallel
.
children_count
.
fetch_add
(
1
Relaxed
)
;
let
_
=
base
.
parallel
.
children_and_absolute_descendant_count
.
fetch_add
(
1
Relaxed
)
;
}
fn
finish
(
&
mut
self
context
:
&
mut
LayoutContext
)
{
if
!
context
.
opts
.
bubble_widths_separately
{
self
.
get_mut
(
)
.
bubble_widths
(
context
)
}
}
}
