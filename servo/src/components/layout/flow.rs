use
css
:
:
node_style
:
:
StyledNode
;
use
block
:
:
BlockFlow
;
use
context
:
:
LayoutContext
;
use
floats
:
:
Floats
;
use
flow_list
:
:
{
FlowList
Link
FlowListIterator
MutFlowListIterator
}
;
use
flow_ref
:
:
FlowRef
;
use
fragment
:
:
{
Fragment
TableRowFragment
TableCellFragment
}
;
use
incremental
:
:
RestyleDamage
;
use
inline
:
:
InlineFlow
;
use
model
:
:
{
CollapsibleMargins
IntrinsicWidths
MarginCollapseInfo
}
;
use
parallel
:
:
FlowParallelInfo
;
use
table_wrapper
:
:
TableWrapperFlow
;
use
table
:
:
TableFlow
;
use
table_colgroup
:
:
TableColGroupFlow
;
use
table_rowgroup
:
:
TableRowGroupFlow
;
use
table_row
:
:
TableRowFlow
;
use
table_caption
:
:
TableCaptionFlow
;
use
table_cell
:
:
TableCellFlow
;
use
wrapper
:
:
ThreadSafeLayoutNode
;
use
collections
:
:
dlist
:
:
DList
;
use
geom
:
:
point
:
:
Point2D
;
use
geom
:
:
rect
:
:
Rect
;
use
geom
:
:
size
:
:
Size2D
;
use
gfx
:
:
display_list
:
:
DisplayList
;
use
gfx
:
:
render_task
:
:
RenderLayer
;
use
servo_msg
:
:
compositor_msg
:
:
LayerId
;
use
servo_util
:
:
geometry
:
:
Au
;
use
std
:
:
mem
;
use
std
:
:
fmt
;
use
std
:
:
iter
:
:
Zip
;
use
std
:
:
num
:
:
Zero
;
use
std
:
:
sync
:
:
atomics
:
:
{
AtomicUint
Relaxed
SeqCst
}
;
use
std
:
:
slice
:
:
MutItems
;
use
style
:
:
computed_values
:
:
{
clear
position
text_align
}
;
pub
trait
Flow
:
fmt
:
:
Show
+
ToStr
+
Share
{
fn
class
(
&
self
)
-
>
FlowClass
;
fn
as_block
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
BlockFlow
{
debug
!
(
"
called
as_block
(
)
on
a
flow
of
type
{
}
"
self
.
class
(
)
)
;
fail
!
(
"
called
as_block
(
)
on
a
non
-
block
flow
"
)
}
fn
as_immutable_inline
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
InlineFlow
{
fail
!
(
"
called
as_immutable_inline
(
)
on
a
non
-
inline
flow
"
)
}
fn
as_inline
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
InlineFlow
{
fail
!
(
"
called
as_inline
(
)
on
a
non
-
inline
flow
"
)
}
fn
as_table_wrapper
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableWrapperFlow
{
fail
!
(
"
called
as_table_wrapper
(
)
on
a
non
-
tablewrapper
flow
"
)
}
fn
as_table
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableFlow
{
fail
!
(
"
called
as_table
(
)
on
a
non
-
table
flow
"
)
}
fn
as_table_colgroup
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableColGroupFlow
{
fail
!
(
"
called
as_table_colgroup
(
)
on
a
non
-
tablecolgroup
flow
"
)
}
fn
as_table_rowgroup
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableRowGroupFlow
{
fail
!
(
"
called
as_table_rowgroup
(
)
on
a
non
-
tablerowgroup
flow
"
)
}
fn
as_table_row
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableRowFlow
{
fail
!
(
"
called
as_table_row
(
)
on
a
non
-
tablerow
flow
"
)
}
fn
as_table_caption
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableCaptionFlow
{
fail
!
(
"
called
as_table_caption
(
)
on
a
non
-
tablecaption
flow
"
)
}
fn
as_table_cell
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableCellFlow
{
fail
!
(
"
called
as_table_cell
(
)
on
a
non
-
tablecell
flow
"
)
}
fn
col_widths
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Vec
<
Au
>
{
fail
!
(
"
called
col_widths
(
)
on
an
other
flow
than
table
-
row
/
table
-
rowgroup
/
table
"
)
}
fn
col_min_widths
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Vec
<
Au
>
{
fail
!
(
"
called
col_min_widths
(
)
on
an
other
flow
than
table
-
row
/
table
-
rowgroup
/
table
"
)
}
fn
col_pref_widths
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Vec
<
Au
>
{
fail
!
(
"
called
col_pref_widths
(
)
on
an
other
flow
than
table
-
row
/
table
-
rowgroup
/
table
"
)
}
fn
bubble_widths
(
&
mut
self
_ctx
:
&
mut
LayoutContext
)
{
fail
!
(
"
bubble_widths
not
yet
implemented
"
)
}
fn
assign_widths
(
&
mut
self
_ctx
:
&
mut
LayoutContext
)
{
fail
!
(
"
assign_widths
not
yet
implemented
"
)
}
fn
assign_height
(
&
mut
self
_ctx
:
&
mut
LayoutContext
)
{
fail
!
(
"
assign_height
not
yet
implemented
"
)
}
fn
assign_height_for_inorder_child_if_necessary
(
&
mut
self
layout_context
:
&
mut
LayoutContext
)
-
>
bool
{
let
impacted
=
base
(
&
*
self
)
.
flags
.
impacted_by_floats
(
)
;
if
impacted
{
self
.
assign_height
(
layout_context
)
;
}
impacted
}
fn
compute_absolute_position
(
&
mut
self
)
{
}
fn
float_clearance
(
&
self
)
-
>
clear
:
:
T
{
clear
:
:
none
}
fn
is_block_formatting_context
(
&
self
_only_impactable_by_floats
:
bool
)
-
>
bool
{
false
}
fn
compute_collapsible_top_margin
(
&
mut
self
_layout_context
:
&
mut
LayoutContext
_margin_collapse_info
:
&
mut
MarginCollapseInfo
)
{
}
fn
mark_as_root
(
&
mut
self
)
{
}
fn
is_store_overflow_delayed
(
&
mut
self
)
-
>
bool
{
false
}
fn
is_root
(
&
self
)
-
>
bool
{
false
}
fn
is_float
(
&
self
)
-
>
bool
{
false
}
fn
positioning
(
&
self
)
-
>
position
:
:
T
{
position
:
:
static_
}
fn
is_fixed
(
&
self
)
-
>
bool
{
self
.
positioning
(
)
=
=
position
:
:
fixed
}
fn
is_positioned
(
&
self
)
-
>
bool
{
self
.
is_relatively_positioned
(
)
|
|
self
.
is_absolutely_positioned
(
)
}
fn
is_relatively_positioned
(
&
self
)
-
>
bool
{
self
.
positioning
(
)
=
=
position
:
:
relative
}
fn
is_absolutely_positioned
(
&
self
)
-
>
bool
{
self
.
positioning
(
)
=
=
position
:
:
absolute
|
|
self
.
is_fixed
(
)
}
fn
is_root_of_absolute_flow_tree
(
&
self
)
-
>
bool
{
false
}
fn
is_absolute_containing_block
(
&
self
)
-
>
bool
{
false
}
fn
generated_containing_block_rect
(
&
self
)
-
>
Rect
<
Au
>
{
fail
!
(
"
generated_containing_block_position
not
yet
implemented
for
this
flow
"
)
}
fn
layer_id
(
&
self
fragment_id
:
uint
)
-
>
LayerId
{
unsafe
{
let
pointer
:
uint
=
mem
:
:
transmute
(
self
)
;
LayerId
(
pointer
fragment_id
)
}
}
}
#
[
inline
(
always
)
]
pub
fn
base
<
'
a
>
(
this
:
&
'
a
Flow
)
-
>
&
'
a
BaseFlow
{
unsafe
{
let
(
_
ptr
)
:
(
uint
&
BaseFlow
)
=
mem
:
:
transmute
(
this
)
;
ptr
}
}
pub
fn
imm_child_iter
<
'
a
>
(
flow
:
&
'
a
Flow
)
-
>
FlowListIterator
<
'
a
>
{
base
(
flow
)
.
children
.
iter
(
)
}
#
[
inline
(
always
)
]
pub
fn
mut_base
<
'
a
>
(
this
:
&
'
a
mut
Flow
)
-
>
&
'
a
mut
BaseFlow
{
unsafe
{
let
(
_
ptr
)
:
(
uint
&
mut
BaseFlow
)
=
mem
:
:
transmute
(
this
)
;
ptr
}
}
pub
fn
child_iter
<
'
a
>
(
flow
:
&
'
a
mut
Flow
)
-
>
MutFlowListIterator
<
'
a
>
{
mut_base
(
flow
)
.
children
.
mut_iter
(
)
}
pub
trait
ImmutableFlowUtils
{
fn
is_block_like
(
self
)
-
>
bool
;
fn
is_table
(
self
)
-
>
bool
;
fn
is_table_caption
(
self
)
-
>
bool
;
fn
is_proper_table_child
(
self
)
-
>
bool
;
fn
is_table_row
(
self
)
-
>
bool
;
fn
is_table_cell
(
self
)
-
>
bool
;
fn
is_table_colgroup
(
self
)
-
>
bool
;
fn
is_table_rowgroup
(
self
)
-
>
bool
;
fn
is_table_kind
(
self
)
-
>
bool
;
fn
need_anonymous_flow
(
self
child
:
&
Flow
)
-
>
bool
;
fn
generate_missing_child_flow
(
self
node
:
&
ThreadSafeLayoutNode
)
-
>
FlowRef
;
fn
is_leaf
(
self
)
-
>
bool
;
fn
child_count
(
self
)
-
>
uint
;
fn
is_block_container
(
self
)
-
>
bool
;
fn
is_block_flow
(
self
)
-
>
bool
;
fn
is_inline_flow
(
self
)
-
>
bool
;
fn
dump
(
self
)
;
fn
dump_with_level
(
self
level
:
uint
)
;
}
pub
trait
MutableFlowUtils
{
fn
traverse_preorder
<
T
:
PreorderFlowTraversal
>
(
self
traversal
:
&
mut
T
)
-
>
bool
;
fn
traverse_postorder
<
T
:
PostorderFlowTraversal
>
(
self
traversal
:
&
mut
T
)
-
>
bool
;
fn
store_overflow
(
self
_
:
&
mut
LayoutContext
)
;
fn
build_display_list
(
self
layout_context
:
&
LayoutContext
)
;
}
pub
trait
MutableOwnedFlowUtils
{
fn
set_abs_descendants
(
&
mut
self
abs_descendants
:
AbsDescendants
)
;
}
#
[
deriving
(
PartialEq
Show
)
]
pub
enum
FlowClass
{
BlockFlowClass
InlineFlowClass
TableWrapperFlowClass
TableFlowClass
TableColGroupFlowClass
TableRowGroupFlowClass
TableRowFlowClass
TableCaptionFlowClass
TableCellFlowClass
}
pub
trait
PreorderFlowTraversal
{
fn
process
(
&
mut
self
flow
:
&
mut
Flow
)
-
>
bool
;
fn
should_prune
(
&
mut
self
_flow
:
&
mut
Flow
)
-
>
bool
{
false
}
}
pub
trait
PostorderFlowTraversal
{
fn
process
(
&
mut
self
flow
:
&
mut
Flow
)
-
>
bool
;
fn
should_process
(
&
mut
self
_flow
:
&
mut
Flow
)
-
>
bool
{
true
}
fn
should_prune
(
&
mut
self
_flow
:
&
mut
Flow
)
-
>
bool
{
false
}
}
#
[
deriving
(
Clone
)
]
pub
struct
FlowFlags
(
pub
u8
)
;
static
HAS_FLOATED_DESCENDANTS_BITMASK
:
u8
=
0b0000_0011
;
bitfield
!
(
FlowFlags
has_left_floated_descendants
set_has_left_floated_descendants
0b0000_0001
)
bitfield
!
(
FlowFlags
has_right_floated_descendants
set_has_right_floated_descendants
0b0000_0010
)
bitfield
!
(
FlowFlags
impacted_by_left_floats
set_impacted_by_left_floats
0b0000_0100
)
bitfield
!
(
FlowFlags
impacted_by_right_floats
set_impacted_by_right_floats
0b0000_1000
)
static
TEXT_ALIGN_BITMASK
:
u8
=
0b0011_0000
;
static
TEXT_ALIGN_SHIFT
:
u8
=
4
;
bitfield
!
(
FlowFlags
layers_needed_for_descendants
set_layers_needed_for_descendants
0b0100_0000
)
bitfield
!
(
FlowFlags
needs_layer
set_needs_layer
0b1000_0000
)
impl
FlowFlags
{
pub
fn
new
(
)
-
>
FlowFlags
{
FlowFlags
(
0
)
}
pub
fn
propagate_text_alignment_from_parent
(
&
mut
self
parent_flags
:
FlowFlags
)
{
self
.
set_text_align_override
(
parent_flags
)
;
}
#
[
inline
]
pub
fn
text_align
(
self
)
-
>
text_align
:
:
T
{
let
FlowFlags
(
ff
)
=
self
;
FromPrimitive
:
:
from_u8
(
(
ff
&
TEXT_ALIGN_BITMASK
)
>
>
TEXT_ALIGN_SHIFT
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
set_text_align
(
&
mut
self
value
:
text_align
:
:
T
)
{
let
FlowFlags
(
ff
)
=
*
self
;
*
self
=
FlowFlags
(
(
ff
&
!
TEXT_ALIGN_BITMASK
)
|
(
(
value
as
u8
)
<
<
TEXT_ALIGN_SHIFT
)
)
}
#
[
inline
]
pub
fn
set_text_align_override
(
&
mut
self
parent
:
FlowFlags
)
{
let
FlowFlags
(
ff
)
=
*
self
;
let
FlowFlags
(
pff
)
=
parent
;
*
self
=
FlowFlags
(
ff
|
(
pff
&
TEXT_ALIGN_BITMASK
)
)
}
#
[
inline
]
pub
fn
union_floated_descendants_flags
(
&
mut
self
other
:
FlowFlags
)
{
let
FlowFlags
(
my_flags
)
=
*
self
;
let
FlowFlags
(
other_flags
)
=
other
;
*
self
=
FlowFlags
(
my_flags
|
(
other_flags
&
HAS_FLOATED_DESCENDANTS_BITMASK
)
)
}
#
[
inline
]
pub
fn
impacted_by_floats
(
&
self
)
-
>
bool
{
self
.
impacted_by_left_floats
(
)
|
|
self
.
impacted_by_right_floats
(
)
}
}
pub
struct
Descendants
{
descendant_links
:
Vec
<
FlowRef
>
pub
static_y_offsets
:
Vec
<
Au
>
}
impl
Descendants
{
pub
fn
new
(
)
-
>
Descendants
{
Descendants
{
descendant_links
:
Vec
:
:
new
(
)
static_y_offsets
:
Vec
:
:
new
(
)
}
}
pub
fn
len
(
&
self
)
-
>
uint
{
self
.
descendant_links
.
len
(
)
}
pub
fn
push
(
&
mut
self
given_descendant
:
FlowRef
)
{
self
.
descendant_links
.
push
(
given_descendant
)
;
}
pub
fn
push_descendants
(
&
mut
self
given_descendants
:
Descendants
)
{
for
elem
in
given_descendants
.
descendant_links
.
move_iter
(
)
{
self
.
descendant_links
.
push
(
elem
)
;
}
}
pub
fn
iter
<
'
a
>
(
&
'
a
mut
self
)
-
>
DescendantIter
<
'
a
>
{
DescendantIter
{
iter
:
self
.
descendant_links
.
mut_slice_from
(
0
)
.
mut_iter
(
)
}
}
pub
fn
iter_with_offset
<
'
a
>
(
&
'
a
mut
self
)
-
>
DescendantOffsetIter
<
'
a
>
{
let
descendant_iter
=
DescendantIter
{
iter
:
self
.
descendant_links
.
mut_slice_from
(
0
)
.
mut_iter
(
)
}
;
descendant_iter
.
zip
(
self
.
static_y_offsets
.
mut_slice_from
(
0
)
.
mut_iter
(
)
)
}
}
pub
type
AbsDescendants
=
Descendants
;
pub
struct
DescendantIter
<
'
a
>
{
iter
:
MutItems
<
'
a
FlowRef
>
}
impl
<
'
a
>
Iterator
<
&
'
a
mut
Flow
>
for
DescendantIter
<
'
a
>
{
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
mut
Flow
>
{
match
self
.
iter
.
next
(
)
{
None
=
>
None
Some
(
ref
mut
flow
)
=
>
{
unsafe
{
let
result
:
&
'
a
mut
Flow
=
mem
:
:
transmute
(
flow
.
get_mut
(
)
)
;
Some
(
result
)
}
}
}
}
}
pub
type
DescendantOffsetIter
<
'
a
>
=
Zip
<
DescendantIter
<
'
a
>
MutItems
<
'
a
Au
>
>
;
pub
struct
AbsolutePositionInfo
{
pub
relative_containing_block_size
:
Size2D
<
Au
>
pub
absolute_containing_block_position
:
Point2D
<
Au
>
pub
layers_needed_for_positioned_flows
:
bool
}
impl
AbsolutePositionInfo
{
pub
fn
new
(
)
-
>
AbsolutePositionInfo
{
AbsolutePositionInfo
{
relative_containing_block_size
:
Size2D
:
:
zero
(
)
absolute_containing_block_position
:
Zero
:
:
zero
(
)
layers_needed_for_positioned_flows
:
false
}
}
}
pub
struct
BaseFlow
{
ref_count
:
AtomicUint
pub
restyle_damage
:
RestyleDamage
pub
children
:
FlowList
pub
next_sibling
:
Link
pub
prev_sibling
:
Link
pub
intrinsic_widths
:
IntrinsicWidths
pub
position
:
Rect
<
Au
>
pub
overflow
:
Rect
<
Au
>
pub
parallel
:
FlowParallelInfo
pub
floats
:
Floats
pub
collapsible_margins
:
CollapsibleMargins
pub
abs_position
:
Point2D
<
Au
>
pub
abs_descendants
:
AbsDescendants
pub
absolute_static_x_offset
:
Au
pub
fixed_static_x_offset
:
Au
pub
absolute_cb
:
ContainingBlockLink
pub
absolute_position_info
:
AbsolutePositionInfo
pub
display_list
:
DisplayList
pub
layers
:
DList
<
RenderLayer
>
pub
flags
:
FlowFlags
}
#
[
unsafe_destructor
]
impl
Drop
for
BaseFlow
{
fn
drop
(
&
mut
self
)
{
if
self
.
ref_count
.
load
(
SeqCst
)
!
=
0
{
fail
!
(
"
Flow
destroyed
before
its
ref
count
hit
zero
this
is
unsafe
!
"
)
}
}
}
impl
BaseFlow
{
#
[
inline
]
pub
fn
new
(
node
:
ThreadSafeLayoutNode
)
-
>
BaseFlow
{
BaseFlow
{
ref_count
:
AtomicUint
:
:
new
(
1
)
restyle_damage
:
node
.
restyle_damage
(
)
children
:
FlowList
:
:
new
(
)
next_sibling
:
None
prev_sibling
:
None
intrinsic_widths
:
IntrinsicWidths
:
:
new
(
)
position
:
Rect
:
:
zero
(
)
overflow
:
Rect
:
:
zero
(
)
parallel
:
FlowParallelInfo
:
:
new
(
)
floats
:
Floats
:
:
new
(
)
collapsible_margins
:
CollapsibleMargins
:
:
new
(
)
abs_position
:
Point2D
(
Au
:
:
new
(
0
)
Au
:
:
new
(
0
)
)
abs_descendants
:
Descendants
:
:
new
(
)
absolute_static_x_offset
:
Au
:
:
new
(
0
)
fixed_static_x_offset
:
Au
:
:
new
(
0
)
absolute_cb
:
ContainingBlockLink
:
:
new
(
)
display_list
:
DisplayList
:
:
new
(
)
layers
:
DList
:
:
new
(
)
absolute_position_info
:
AbsolutePositionInfo
:
:
new
(
)
flags
:
FlowFlags
:
:
new
(
)
}
}
pub
fn
child_iter
<
'
a
>
(
&
'
a
mut
self
)
-
>
MutFlowListIterator
<
'
a
>
{
self
.
children
.
mut_iter
(
)
}
pub
unsafe
fn
ref_count
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
AtomicUint
{
&
self
.
ref_count
}
}
impl
<
'
a
>
ImmutableFlowUtils
for
&
'
a
Flow
{
fn
is_block_like
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
BlockFlowClass
=
>
true
_
=
>
false
}
}
fn
is_proper_table_child
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableRowFlowClass
|
TableRowGroupFlowClass
|
TableColGroupFlowClass
|
TableCaptionFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table_row
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableRowFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table_cell
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableCellFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table_colgroup
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableColGroupFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table_caption
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableCaptionFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table_rowgroup
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableRowGroupFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table_kind
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableWrapperFlowClass
|
TableFlowClass
|
TableColGroupFlowClass
|
TableRowGroupFlowClass
|
TableRowFlowClass
|
TableCaptionFlowClass
|
TableCellFlowClass
=
>
true
_
=
>
false
}
}
fn
need_anonymous_flow
(
self
child
:
&
Flow
)
-
>
bool
{
match
self
.
class
(
)
{
TableFlowClass
=
>
!
child
.
is_proper_table_child
(
)
TableRowGroupFlowClass
=
>
!
child
.
is_table_row
(
)
TableRowFlowClass
=
>
!
child
.
is_table_cell
(
)
_
=
>
false
}
}
fn
generate_missing_child_flow
(
self
node
:
&
ThreadSafeLayoutNode
)
-
>
FlowRef
{
let
flow
=
match
self
.
class
(
)
{
TableFlowClass
|
TableRowGroupFlowClass
=
>
{
let
fragment
=
Fragment
:
:
new_anonymous_table_fragment
(
node
TableRowFragment
)
;
box
TableRowFlow
:
:
from_node_and_fragment
(
node
fragment
)
as
Box
<
Flow
>
}
TableRowFlowClass
=
>
{
let
fragment
=
Fragment
:
:
new_anonymous_table_fragment
(
node
TableCellFragment
)
;
box
TableCellFlow
:
:
from_node_and_fragment
(
node
fragment
)
as
Box
<
Flow
>
}
_
=
>
{
fail
!
(
"
no
need
to
generate
a
missing
child
"
)
}
}
;
FlowRef
:
:
new
(
flow
)
}
fn
is_leaf
(
self
)
-
>
bool
{
base
(
self
)
.
children
.
len
(
)
=
=
0
}
fn
child_count
(
self
)
-
>
uint
{
base
(
self
)
.
children
.
len
(
)
}
fn
is_block_container
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
BlockFlowClass
|
TableCaptionFlowClass
|
TableCellFlowClass
=
>
{
self
.
child_count
(
)
!
=
0
}
_
=
>
false
}
}
fn
is_block_flow
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
BlockFlowClass
=
>
true
_
=
>
false
}
}
fn
is_inline_flow
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
InlineFlowClass
=
>
true
_
=
>
false
}
}
fn
dump
(
self
)
{
self
.
dump_with_level
(
0
)
}
fn
dump_with_level
(
self
level
:
uint
)
{
let
mut
indent
=
String
:
:
new
(
)
;
for
_
in
range
(
0
level
)
{
indent
.
push_str
(
"
|
"
)
}
debug
!
(
"
{
}
+
{
}
"
indent
self
.
to_str
(
)
)
;
for
kid
in
imm_child_iter
(
self
)
{
kid
.
dump_with_level
(
level
+
1
)
}
}
}
impl
<
'
a
>
MutableFlowUtils
for
&
'
a
mut
Flow
{
fn
traverse_preorder
<
T
:
PreorderFlowTraversal
>
(
self
traversal
:
&
mut
T
)
-
>
bool
{
if
traversal
.
should_prune
(
self
)
{
return
true
}
if
!
traversal
.
process
(
self
)
{
return
false
}
for
kid
in
child_iter
(
self
)
{
if
!
kid
.
traverse_preorder
(
traversal
)
{
return
false
}
}
true
}
fn
traverse_postorder
<
T
:
PostorderFlowTraversal
>
(
self
traversal
:
&
mut
T
)
-
>
bool
{
if
traversal
.
should_prune
(
self
)
{
return
true
}
for
kid
in
child_iter
(
self
)
{
if
!
kid
.
traverse_postorder
(
traversal
)
{
return
false
}
}
if
!
traversal
.
should_process
(
self
)
{
return
true
}
traversal
.
process
(
self
)
}
fn
store_overflow
(
self
_
:
&
mut
LayoutContext
)
{
let
my_position
=
mut_base
(
self
)
.
position
;
let
mut
overflow
=
my_position
;
if
self
.
is_block_container
(
)
{
for
kid
in
child_iter
(
self
)
{
if
kid
.
is_store_overflow_delayed
(
)
{
continue
;
}
let
mut
kid_overflow
=
base
(
kid
)
.
overflow
;
kid_overflow
=
kid_overflow
.
translate
(
&
my_position
.
origin
)
;
overflow
=
overflow
.
union
(
&
kid_overflow
)
}
for
descendant_link
in
mut_base
(
self
)
.
abs_descendants
.
iter
(
)
{
let
mut
kid_overflow
=
base
(
descendant_link
)
.
overflow
;
kid_overflow
=
kid_overflow
.
translate
(
&
my_position
.
origin
)
;
overflow
=
overflow
.
union
(
&
kid_overflow
)
}
}
mut_base
(
self
)
.
overflow
=
overflow
;
}
fn
build_display_list
(
self
layout_context
:
&
LayoutContext
)
{
debug
!
(
"
Flow
:
building
display
list
"
)
;
match
self
.
class
(
)
{
BlockFlowClass
=
>
self
.
as_block
(
)
.
build_display_list_block
(
layout_context
)
InlineFlowClass
=
>
self
.
as_inline
(
)
.
build_display_list_inline
(
layout_context
)
TableWrapperFlowClass
=
>
{
self
.
as_table_wrapper
(
)
.
build_display_list_table_wrapper
(
layout_context
)
}
TableFlowClass
=
>
self
.
as_table
(
)
.
build_display_list_table
(
layout_context
)
TableRowGroupFlowClass
=
>
{
self
.
as_table_rowgroup
(
)
.
build_display_list_table_rowgroup
(
layout_context
)
}
TableRowFlowClass
=
>
self
.
as_table_row
(
)
.
build_display_list_table_row
(
layout_context
)
TableCaptionFlowClass
=
>
{
self
.
as_table_caption
(
)
.
build_display_list_table_caption
(
layout_context
)
}
TableCellFlowClass
=
>
{
self
.
as_table_cell
(
)
.
build_display_list_table_cell
(
layout_context
)
}
TableColGroupFlowClass
=
>
{
}
}
}
}
impl
MutableOwnedFlowUtils
for
FlowRef
{
fn
set_abs_descendants
(
&
mut
self
abs_descendants
:
AbsDescendants
)
{
let
this
=
self
.
clone
(
)
;
let
block
=
self
.
get_mut
(
)
.
as_block
(
)
;
block
.
base
.
abs_descendants
=
abs_descendants
;
block
.
base
.
parallel
.
children_and_absolute_descendant_count
.
fetch_add
(
block
.
base
.
abs_descendants
.
len
(
)
as
int
Relaxed
)
;
for
descendant_link
in
block
.
base
.
abs_descendants
.
iter
(
)
{
let
base
=
mut_base
(
descendant_link
)
;
base
.
absolute_cb
.
set
(
this
.
clone
(
)
)
;
}
}
}
pub
struct
ContainingBlockLink
{
link
:
Option
<
FlowRef
>
}
impl
ContainingBlockLink
{
fn
new
(
)
-
>
ContainingBlockLink
{
ContainingBlockLink
{
link
:
None
}
}
fn
set
(
&
mut
self
link
:
FlowRef
)
{
self
.
link
=
Some
(
link
)
}
pub
unsafe
fn
get
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Option
<
FlowRef
>
{
&
mut
self
.
link
}
#
[
inline
]
pub
fn
generated_containing_block_rect
(
&
mut
self
)
-
>
Rect
<
Au
>
{
match
self
.
link
{
None
=
>
fail
!
(
"
haven
'
t
done
it
"
)
Some
(
ref
mut
link
)
=
>
link
.
get_mut
(
)
.
generated_containing_block_rect
(
)
}
}
}
