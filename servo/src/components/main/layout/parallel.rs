use
layout
:
:
context
:
:
LayoutContext
;
use
layout
:
:
flow
:
:
{
Flow
LeafSet
PostorderFlowTraversal
}
;
use
layout
:
:
flow
;
use
layout
:
:
layout_task
:
:
{
AssignHeightsAndStoreOverflowTraversal
BubbleWidthsTraversal
}
;
use
extra
:
:
arc
:
:
MutexArc
;
use
servo_util
:
:
time
:
:
{
ProfilerChan
profile
}
;
use
servo_util
:
:
time
;
use
servo_util
:
:
workqueue
:
:
{
WorkQueue
WorkUnit
WorkerProxy
}
;
use
std
:
:
cast
;
use
std
:
:
sync
:
:
atomics
:
:
{
AtomicInt
Relaxed
SeqCst
}
;
pub
enum
TraversalKind
{
BubbleWidthsTraversalKind
AssignHeightsAndStoreOverflowTraversalKind
}
pub
type
UnsafeFlow
=
(
uint
uint
)
;
fn
null_unsafe_flow
(
)
-
>
UnsafeFlow
{
(
0
0
)
}
pub
fn
owned_flow_to_unsafe_flow
(
flow
:
*
~
Flow
)
-
>
UnsafeFlow
{
unsafe
{
cast
:
:
transmute_copy
(
&
*
flow
)
}
}
pub
fn
mut_owned_flow_to_unsafe_flow
(
flow
:
*
mut
~
Flow
)
-
>
UnsafeFlow
{
unsafe
{
cast
:
:
transmute_copy
(
&
*
flow
)
}
}
pub
struct
FlowParallelInfo
{
children_count
:
AtomicInt
parent
:
UnsafeFlow
}
impl
FlowParallelInfo
{
pub
fn
new
(
)
-
>
FlowParallelInfo
{
FlowParallelInfo
{
children_count
:
AtomicInt
:
:
new
(
0
)
parent
:
null_unsafe_flow
(
)
}
}
}
trait
ParallelPostorderFlowTraversal
:
PostorderFlowTraversal
{
fn
run_parallel
(
&
mut
self
mut
unsafe_flow
:
UnsafeFlow
)
{
loop
{
unsafe
{
let
flow
:
&
mut
~
Flow
=
cast
:
:
transmute
(
&
unsafe_flow
)
;
if
self
.
should_process
(
*
flow
)
{
self
.
process
(
*
flow
)
;
}
let
base
=
flow
:
:
mut_base
(
*
flow
)
;
base
.
parallel
.
children_count
.
store
(
base
.
children
.
len
(
)
as
int
Relaxed
)
;
let
unsafe_parent
=
base
.
parallel
.
parent
;
if
unsafe_parent
=
=
null_unsafe_flow
(
)
{
break
}
let
parent
:
&
mut
~
Flow
=
cast
:
:
transmute
(
&
unsafe_parent
)
;
let
parent_base
=
flow
:
:
mut_base
(
*
parent
)
;
if
parent_base
.
parallel
.
children_count
.
fetch_sub
(
1
SeqCst
)
=
=
1
{
unsafe_flow
=
unsafe_parent
}
else
{
break
}
}
}
}
}
impl
<
'
a
>
ParallelPostorderFlowTraversal
for
BubbleWidthsTraversal
<
'
a
>
{
}
impl
<
'
a
>
ParallelPostorderFlowTraversal
for
AssignHeightsAndStoreOverflowTraversal
<
'
a
>
{
}
fn
bubble_widths
(
unsafe_flow
:
UnsafeFlow
proxy
:
&
mut
WorkerProxy
<
*
mut
LayoutContext
UnsafeFlow
>
)
{
let
layout_context
:
&
mut
LayoutContext
=
unsafe
{
cast
:
:
transmute
(
*
proxy
.
user_data
(
)
)
}
;
let
mut
bubble_widths_traversal
=
BubbleWidthsTraversal
{
layout_context
:
layout_context
}
;
bubble_widths_traversal
.
run_parallel
(
unsafe_flow
)
}
fn
assign_heights_and_store_overflow
(
unsafe_flow
:
UnsafeFlow
proxy
:
&
mut
WorkerProxy
<
*
mut
LayoutContext
UnsafeFlow
>
)
{
let
layout_context
:
&
mut
LayoutContext
=
unsafe
{
cast
:
:
transmute
(
*
proxy
.
user_data
(
)
)
}
;
let
mut
assign_heights_traversal
=
AssignHeightsAndStoreOverflowTraversal
{
layout_context
:
layout_context
}
;
assign_heights_traversal
.
run_parallel
(
unsafe_flow
)
}
pub
fn
traverse_flow_tree
(
kind
:
TraversalKind
leaf_set
:
&
MutexArc
<
LeafSet
>
profiler_chan
:
ProfilerChan
layout_context
:
&
mut
LayoutContext
queue
:
&
mut
WorkQueue
<
*
mut
LayoutContext
UnsafeFlow
>
)
{
unsafe
{
queue
.
data
=
cast
:
:
transmute
(
layout_context
)
}
let
fun
=
match
kind
{
BubbleWidthsTraversalKind
=
>
bubble_widths
AssignHeightsAndStoreOverflowTraversalKind
=
>
assign_heights_and_store_overflow
}
;
profile
(
time
:
:
LayoutParallelWarmupCategory
profiler_chan
|
|
{
leaf_set
.
access
(
|
leaf_set
|
{
for
&
flow
in
leaf_set
.
iter
(
)
{
queue
.
push
(
WorkUnit
{
fun
:
fun
data
:
flow
}
)
}
}
)
}
)
;
queue
.
run
(
)
}
