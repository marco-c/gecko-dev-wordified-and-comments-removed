use
extra
:
:
arc
:
:
MutexArc
;
use
green
:
:
task
:
:
GreenTask
;
use
layout
:
:
flow
:
:
FlowLeafSet
;
use
layout
:
:
util
:
:
OpaqueNode
;
use
layout
:
:
wrapper
:
:
DomLeafSet
;
use
std
:
:
cast
;
use
std
:
:
ptr
;
use
std
:
:
rt
:
:
Runtime
;
use
std
:
:
rt
:
:
local
:
:
Local
;
use
std
:
:
rt
:
:
task
:
:
Task
;
use
geom
:
:
size
:
:
Size2D
;
use
gfx
:
:
font_context
:
:
{
FontContext
FontContextInfo
}
;
use
script
:
:
layout_interface
:
:
LayoutChan
;
use
servo_msg
:
:
constellation_msg
:
:
ConstellationChan
;
use
servo_net
:
:
local_image_cache
:
:
LocalImageCache
;
use
servo_util
:
:
geometry
:
:
Au
;
use
style
:
:
Stylist
;
#
[
thread_local
]
static
mut
FONT_CONTEXT
:
*
mut
FontContext
=
0
as
*
mut
FontContext
;
#
[
deriving
(
Clone
)
]
pub
struct
LayoutContext
{
image_cache
:
MutexArc
<
LocalImageCache
>
screen_size
:
Size2D
<
Au
>
constellation_chan
:
ConstellationChan
dom_leaf_set
:
MutexArc
<
DomLeafSet
>
layout_chan
:
LayoutChan
flow_leaf_set
:
MutexArc
<
FlowLeafSet
>
font_context_info
:
FontContextInfo
stylist
:
*
Stylist
/
/
/
The
root
node
at
which
we
'
re
starting
the
layout
.
reflow_root
:
OpaqueNode
}
impl
LayoutContext
{
pub
fn
font_context
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
FontContext
{
/
/
Sanity
check
.
let
mut
task
=
Local
:
:
borrow
(
None
:
:
<
Task
>
)
;
match
task
.
get
(
)
.
maybe_take_runtime
:
:
<
GreenTask
>
(
)
{
Some
(
green
)
=
>
{
task
.
get
(
)
.
put_runtime
(
green
as
~
Runtime
)
;
fail
!
(
"
can
'
t
call
this
on
a
green
task
!
"
)
}
None
=
>
{
}
}
unsafe
{
if
FONT_CONTEXT
=
=
ptr
:
:
mut_null
(
)
{
let
context
=
~
FontContext
:
:
new
(
self
.
font_context_info
.
clone
(
)
)
;
FONT_CONTEXT
=
cast
:
:
transmute
(
context
)
}
cast
:
:
transmute
(
FONT_CONTEXT
)
}
}
}
