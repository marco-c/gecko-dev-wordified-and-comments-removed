use
css
:
:
node_style
:
:
StyledNode
;
use
layout
:
:
box_
:
:
{
Box
CannotSplit
GenericBox
IframeBox
ImageBox
ScannedTextBox
}
;
use
layout
:
:
box_
:
:
{
SplitDidFit
SplitDidNotFit
TableBox
TableCellBox
TableColumnBox
}
;
use
layout
:
:
box_
:
:
{
TableRowBox
TableWrapperBox
UnscannedTextBox
}
;
use
layout
:
:
context
:
:
LayoutContext
;
use
layout
:
:
display_list_builder
:
:
{
DisplayListBuilder
DisplayListBuildingInfo
}
;
use
layout
:
:
floats
:
:
{
FloatLeft
Floats
PlacementInfo
}
;
use
layout
:
:
flow
:
:
{
BaseFlow
FlowClass
Flow
InlineFlowClass
}
;
use
layout
:
:
flow
;
use
layout
:
:
model
:
:
IntrinsicWidths
;
use
layout
:
:
model
;
use
layout
:
:
wrapper
:
:
ThreadSafeLayoutNode
;
use
collections
:
:
{
Deque
RingBuf
}
;
use
geom
:
:
{
Point2D
Rect
SideOffsets2D
Size2D
}
;
use
gfx
:
:
display_list
:
:
{
ContentLevel
StackingContext
}
;
use
servo_util
:
:
geometry
:
:
Au
;
use
servo_util
:
:
geometry
;
use
servo_util
:
:
range
:
:
Range
;
use
servo_util
:
:
smallvec
:
:
{
SmallVec
SmallVec0
}
;
use
std
:
:
iter
:
:
Enumerate
;
use
std
:
:
mem
;
use
std
:
:
slice
:
:
{
Items
MutItems
}
;
use
std
:
:
u16
;
use
style
:
:
computed_values
:
:
{
text_align
vertical_align
white_space
}
;
use
style
:
:
ComputedValues
;
use
sync
:
:
Arc
;
pub
struct
LineBox
{
pub
range
:
Range
pub
bounds
:
Rect
<
Au
>
pub
green_zone
:
Size2D
<
Au
>
}
struct
LineboxScanner
{
pub
floats
:
Floats
pub
new_boxes
:
SmallVec0
<
Box
>
pub
work_list
:
RingBuf
<
Box
>
pub
pending_line
:
LineBox
pub
lines
:
SmallVec0
<
LineBox
>
pub
cur_y
:
Au
}
impl
LineboxScanner
{
pub
fn
new
(
float_ctx
:
Floats
)
-
>
LineboxScanner
{
LineboxScanner
{
floats
:
float_ctx
new_boxes
:
SmallVec0
:
:
new
(
)
work_list
:
RingBuf
:
:
new
(
)
pending_line
:
LineBox
{
range
:
Range
:
:
empty
(
)
bounds
:
Rect
(
Point2D
(
Au
:
:
new
(
0
)
Au
:
:
new
(
0
)
)
Size2D
(
Au
:
:
new
(
0
)
Au
:
:
new
(
0
)
)
)
green_zone
:
Size2D
(
Au
:
:
new
(
0
)
Au
:
:
new
(
0
)
)
}
lines
:
SmallVec0
:
:
new
(
)
cur_y
:
Au
:
:
new
(
0
)
}
}
pub
fn
floats
(
&
mut
self
)
-
>
Floats
{
self
.
floats
.
clone
(
)
}
fn
reset_scanner
(
&
mut
self
)
{
debug
!
(
"
Resetting
line
box
scanner
'
s
state
for
flow
.
"
)
;
self
.
lines
=
SmallVec0
:
:
new
(
)
;
self
.
new_boxes
=
SmallVec0
:
:
new
(
)
;
self
.
cur_y
=
Au
(
0
)
;
self
.
reset_linebox
(
)
;
}
fn
reset_linebox
(
&
mut
self
)
{
self
.
pending_line
.
range
.
reset
(
0
0
)
;
self
.
pending_line
.
bounds
=
Rect
(
Point2D
(
Au
:
:
new
(
0
)
self
.
cur_y
)
Size2D
(
Au
:
:
new
(
0
)
Au
:
:
new
(
0
)
)
)
;
self
.
pending_line
.
green_zone
=
Size2D
(
Au
:
:
new
(
0
)
Au
:
:
new
(
0
)
)
}
pub
fn
scan_for_lines
(
&
mut
self
flow
:
&
mut
InlineFlow
)
{
self
.
reset_scanner
(
)
;
let
InlineBoxes
{
boxes
:
old_boxes
map
:
mut
map
}
=
mem
:
:
replace
(
&
mut
flow
.
boxes
InlineBoxes
:
:
new
(
)
)
;
let
mut
old_box_iter
=
old_boxes
.
iter
(
)
;
loop
{
let
cur_box
=
if
self
.
work_list
.
is_empty
(
)
{
match
old_box_iter
.
next
(
)
{
None
=
>
break
Some
(
fragment
)
=
>
{
debug
!
(
"
LineboxScanner
:
Working
with
fragment
from
flow
:
b
{
}
"
fragment
.
debug_id
(
)
)
;
(
*
fragment
)
.
clone
(
)
}
}
}
else
{
let
fragment
=
self
.
work_list
.
pop_front
(
)
.
unwrap
(
)
;
debug
!
(
"
LineboxScanner
:
Working
with
box
from
work
list
:
b
{
}
"
fragment
.
debug_id
(
)
)
;
fragment
}
;
let
box_was_appended
=
match
cur_box
.
white_space
(
)
{
white_space
:
:
normal
=
>
self
.
try_append_to_line
(
cur_box
flow
)
white_space
:
:
pre
=
>
self
.
try_append_to_line_by_new_line
(
cur_box
)
}
;
if
!
box_was_appended
{
debug
!
(
"
LineboxScanner
:
Box
wasn
'
t
appended
because
line
{
:
u
}
was
full
.
"
self
.
lines
.
len
(
)
)
;
self
.
flush_current_line
(
)
;
}
else
{
debug
!
(
"
LineboxScanner
:
appended
a
box
to
line
{
:
u
}
"
self
.
lines
.
len
(
)
)
;
}
}
if
self
.
pending_line
.
range
.
length
(
)
>
0
{
debug
!
(
"
LineboxScanner
:
Partially
full
linebox
{
:
u
}
left
at
end
of
scanning
.
"
self
.
lines
.
len
(
)
)
;
self
.
flush_current_line
(
)
;
}
map
.
fixup
(
old_boxes
.
as_slice
(
)
self
.
new_boxes
.
as_slice
(
)
)
;
flow
.
boxes
=
InlineBoxes
{
boxes
:
mem
:
:
replace
(
&
mut
self
.
new_boxes
SmallVec0
:
:
new
(
)
)
map
:
map
}
;
flow
.
lines
=
mem
:
:
replace
(
&
mut
self
.
lines
SmallVec0
:
:
new
(
)
)
;
}
fn
flush_current_line
(
&
mut
self
)
{
debug
!
(
"
LineboxScanner
:
Flushing
line
{
:
u
}
:
{
:
?
}
"
self
.
lines
.
len
(
)
self
.
pending_line
)
;
debug
!
(
"
LineboxScanner
:
Saving
information
for
flushed
line
{
:
u
}
.
"
self
.
lines
.
len
(
)
)
;
self
.
lines
.
push
(
self
.
pending_line
)
;
self
.
cur_y
=
self
.
pending_line
.
bounds
.
origin
.
y
+
self
.
pending_line
.
bounds
.
size
.
height
;
self
.
reset_linebox
(
)
;
}
fn
new_height_for_line
(
&
self
new_box
:
&
Box
)
-
>
Au
{
let
box_height
=
new_box
.
content_height
(
)
;
if
box_height
>
self
.
pending_line
.
bounds
.
size
.
height
{
box_height
}
else
{
self
.
pending_line
.
bounds
.
size
.
height
}
}
fn
initial_line_placement
(
&
self
first_box
:
&
Box
ceiling
:
Au
flow
:
&
mut
InlineFlow
)
-
>
(
Rect
<
Au
>
Au
)
{
debug
!
(
"
LineboxScanner
:
Trying
to
place
first
box
of
line
{
}
"
self
.
lines
.
len
(
)
)
;
let
first_box_size
=
first_box
.
border_box
.
size
;
let
splittable
=
first_box
.
can_split
(
)
;
debug
!
(
"
LineboxScanner
:
box
size
:
{
}
splittable
:
{
}
"
first_box_size
splittable
)
;
let
line_is_empty
:
bool
=
self
.
pending_line
.
range
.
length
(
)
=
=
0
;
let
placement_width
=
if
splittable
{
Au
:
:
new
(
0
)
}
else
{
first_box_size
.
width
}
;
let
mut
info
=
PlacementInfo
{
size
:
Size2D
(
placement_width
first_box_size
.
height
)
ceiling
:
ceiling
max_width
:
flow
.
base
.
position
.
size
.
width
kind
:
FloatLeft
}
;
let
line_bounds
=
self
.
floats
.
place_between_floats
(
&
info
)
;
debug
!
(
"
LineboxScanner
:
found
position
for
line
:
{
}
using
placement_info
:
{
:
?
}
"
line_bounds
info
)
;
if
line_bounds
.
size
.
width
>
first_box_size
.
width
{
debug
!
(
"
LineboxScanner
:
case
=
box
fits
"
)
;
return
(
line_bounds
first_box_size
.
width
)
;
}
if
!
splittable
{
debug
!
(
"
LineboxScanner
:
case
=
line
doesn
'
t
fit
but
is
unsplittable
"
)
;
return
(
line_bounds
first_box_size
.
width
)
;
}
match
first_box
.
split_to_width
(
line_bounds
.
size
.
width
line_is_empty
)
{
CannotSplit
=
>
{
error
!
(
"
LineboxScanner
:
Tried
to
split
unsplittable
render
box
!
{
:
s
}
"
first_box
.
debug_str
(
)
)
;
return
(
line_bounds
first_box_size
.
width
)
;
}
SplitDidFit
(
left
right
)
=
>
{
debug
!
(
"
LineboxScanner
:
case
=
box
split
and
fit
"
)
;
let
actual_box_width
=
match
(
left
right
)
{
(
Some
(
l_box
)
Some
(
_
)
)
=
>
l_box
.
border_box
.
size
.
width
(
Some
(
l_box
)
None
)
=
>
l_box
.
border_box
.
size
.
width
(
None
Some
(
r_box
)
)
=
>
r_box
.
border_box
.
size
.
width
(
None
None
)
=
>
fail
!
(
"
This
case
makes
no
sense
.
"
)
}
;
return
(
line_bounds
actual_box_width
)
;
}
SplitDidNotFit
(
left
right
)
=
>
{
debug
!
(
"
LineboxScanner
:
case
=
box
split
and
fit
didn
'
t
fit
;
trying
to
push
it
down
"
)
;
let
actual_box_width
=
match
(
left
right
)
{
(
Some
(
l_box
)
Some
(
_
)
)
=
>
l_box
.
border_box
.
size
.
width
(
Some
(
l_box
)
None
)
=
>
l_box
.
border_box
.
size
.
width
(
None
Some
(
r_box
)
)
=
>
r_box
.
border_box
.
size
.
width
(
None
None
)
=
>
fail
!
(
"
This
case
makes
no
sense
.
"
)
}
;
info
.
size
.
width
=
actual_box_width
;
let
new_bounds
=
self
.
floats
.
place_between_floats
(
&
info
)
;
debug
!
(
"
LineboxScanner
:
case
=
new
line
position
:
{
}
"
new_bounds
)
;
return
(
new_bounds
actual_box_width
)
;
}
}
}
fn
avoid_floats
(
&
mut
self
in_box
:
Box
flow
:
&
mut
InlineFlow
new_height
:
Au
line_is_empty
:
bool
)
-
>
bool
{
debug
!
(
"
LineboxScanner
:
entering
float
collision
avoider
!
"
)
;
let
this_line_y
=
self
.
pending_line
.
bounds
.
origin
.
y
;
let
(
next_line
first_box_width
)
=
self
.
initial_line_placement
(
&
in_box
this_line_y
flow
)
;
let
next_green_zone
=
next_line
.
size
;
let
new_width
=
self
.
pending_line
.
bounds
.
size
.
width
+
first_box_width
;
if
next_green_zone
.
width
>
=
new_width
&
&
next_green_zone
.
height
>
=
new_height
{
debug
!
(
"
LineboxScanner
:
case
=
adding
box
collides
vertically
with
floats
:
moving
line
"
)
;
self
.
pending_line
.
bounds
.
origin
=
next_line
.
origin
;
self
.
pending_line
.
green_zone
=
next_green_zone
;
assert
!
(
!
line_is_empty
"
Non
-
terminating
line
breaking
"
)
;
self
.
work_list
.
push_front
(
in_box
)
;
return
true
}
debug
!
(
"
LineboxScanner
:
case
=
adding
box
collides
vertically
with
floats
:
breaking
line
"
)
;
self
.
work_list
.
push_front
(
in_box
)
;
false
}
fn
try_append_to_line_by_new_line
(
&
mut
self
in_box
:
Box
)
-
>
bool
{
if
in_box
.
new_line_pos
.
len
(
)
=
=
0
{
self
.
push_box_to_line
(
in_box
)
;
true
}
else
{
match
in_box
.
split_by_new_line
(
)
{
SplitDidFit
(
left
right
)
=
>
{
match
(
left
right
)
{
(
Some
(
left_box
)
Some
(
right_box
)
)
=
>
{
self
.
push_box_to_line
(
left_box
)
;
self
.
work_list
.
push_front
(
right_box
)
;
}
(
Some
(
left_box
)
None
)
=
>
{
self
.
push_box_to_line
(
left_box
)
;
}
_
=
>
error
!
(
"
LineboxScanner
:
This
split
case
makes
no
sense
!
"
)
}
}
_
=
>
{
}
}
false
}
}
fn
try_append_to_line
(
&
mut
self
in_box
:
Box
flow
:
&
mut
InlineFlow
)
-
>
bool
{
let
line_is_empty
=
self
.
pending_line
.
range
.
length
(
)
=
=
0
;
if
line_is_empty
{
let
(
line_bounds
_
)
=
self
.
initial_line_placement
(
&
in_box
self
.
cur_y
flow
)
;
self
.
pending_line
.
bounds
.
origin
=
line_bounds
.
origin
;
self
.
pending_line
.
green_zone
=
line_bounds
.
size
;
}
debug
!
(
"
LineboxScanner
:
Trying
to
append
box
to
line
{
:
u
}
(
box
size
:
{
}
green
zone
:
\
{
}
)
:
{
:
s
}
"
self
.
lines
.
len
(
)
in_box
.
border_box
.
size
self
.
pending_line
.
green_zone
in_box
.
debug_str
(
)
)
;
let
green_zone
=
self
.
pending_line
.
green_zone
;
let
new_height
=
self
.
new_height_for_line
(
&
in_box
)
;
if
new_height
>
green_zone
.
height
{
return
self
.
avoid_floats
(
in_box
flow
new_height
line_is_empty
)
}
let
new_width
=
self
.
pending_line
.
bounds
.
size
.
width
+
in_box
.
border_box
.
size
.
width
;
if
new_width
<
=
green_zone
.
width
{
debug
!
(
"
LineboxScanner
:
case
=
box
fits
without
splitting
"
)
;
self
.
push_box_to_line
(
in_box
)
;
return
true
}
if
!
in_box
.
can_split
(
)
{
if
line_is_empty
{
debug
!
(
"
LineboxScanner
:
case
=
box
can
'
t
split
and
line
{
:
u
}
is
empty
so
\
overflowing
.
"
self
.
lines
.
len
(
)
)
;
self
.
push_box_to_line
(
in_box
)
;
return
true
}
}
let
available_width
=
green_zone
.
width
-
self
.
pending_line
.
bounds
.
size
.
width
;
let
split
=
in_box
.
split_to_width
(
available_width
line_is_empty
)
;
let
(
left
right
)
=
match
(
split
line_is_empty
)
{
(
CannotSplit
_
)
=
>
{
debug
!
(
"
LineboxScanner
:
Tried
to
split
unsplittable
render
box
!
{
:
s
}
"
in_box
.
debug_str
(
)
)
;
self
.
work_list
.
push_front
(
in_box
)
;
return
false
}
(
SplitDidNotFit
(
_
_
)
false
)
=
>
{
debug
!
(
"
LineboxScanner
:
case
=
split
box
didn
'
t
fit
not
appending
and
deferring
\
original
box
.
"
)
;
self
.
work_list
.
push_front
(
in_box
)
;
return
false
}
(
SplitDidFit
(
left
right
)
_
)
=
>
{
debug
!
(
"
LineboxScanner
:
case
=
split
box
did
fit
;
deferring
remainder
box
.
"
)
;
(
left
right
)
}
(
SplitDidNotFit
(
left
right
)
true
)
=
>
{
debug
!
(
"
LineboxScanner
:
case
=
split
box
didn
'
t
fit
and
line
{
:
u
}
is
empty
so
\
overflowing
and
deferring
remainder
box
.
"
self
.
lines
.
len
(
)
)
;
(
left
right
)
}
}
;
match
(
left
right
)
{
(
Some
(
left_box
)
Some
(
right_box
)
)
=
>
{
self
.
push_box_to_line
(
left_box
)
;
self
.
work_list
.
push_front
(
right_box
)
;
}
(
Some
(
left_box
)
None
)
=
>
self
.
push_box_to_line
(
left_box
)
(
None
Some
(
right_box
)
)
=
>
self
.
push_box_to_line
(
right_box
)
(
None
None
)
=
>
error
!
(
"
LineboxScanner
:
This
split
case
makes
no
sense
!
"
)
}
true
}
fn
push_box_to_line
(
&
mut
self
box_
:
Box
)
{
debug
!
(
"
LineboxScanner
:
Pushing
box
{
}
to
line
{
:
u
}
"
box_
.
debug_id
(
)
self
.
lines
.
len
(
)
)
;
if
self
.
pending_line
.
range
.
length
(
)
=
=
0
{
assert
!
(
self
.
new_boxes
.
len
(
)
<
=
(
u16
:
:
MAX
as
uint
)
)
;
self
.
pending_line
.
range
.
reset
(
self
.
new_boxes
.
len
(
)
0
)
;
}
self
.
pending_line
.
range
.
extend_by
(
1
)
;
self
.
pending_line
.
bounds
.
size
.
width
=
self
.
pending_line
.
bounds
.
size
.
width
+
box_
.
border_box
.
size
.
width
;
self
.
pending_line
.
bounds
.
size
.
height
=
Au
:
:
max
(
self
.
pending_line
.
bounds
.
size
.
height
box_
.
border_box
.
size
.
height
)
;
self
.
new_boxes
.
push
(
box_
)
;
}
}
pub
struct
BoxIterator
<
'
a
>
{
iter
:
Enumerate
<
Items
<
'
a
Box
>
>
map
:
&
'
a
FragmentMap
}
impl
<
'
a
>
Iterator
<
(
&
'
a
Box
InlineFragmentContext
<
'
a
>
)
>
for
BoxIterator
<
'
a
>
{
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
(
&
'
a
Box
InlineFragmentContext
<
'
a
>
)
>
{
match
self
.
iter
.
next
(
)
{
None
=
>
None
Some
(
(
i
fragment
)
)
=
>
Some
(
(
fragment
InlineFragmentContext
:
:
new
(
self
.
map
i
)
)
)
}
}
}
pub
struct
MutBoxIterator
<
'
a
>
{
iter
:
Enumerate
<
MutItems
<
'
a
Box
>
>
map
:
&
'
a
FragmentMap
}
impl
<
'
a
>
Iterator
<
(
&
'
a
mut
Box
InlineFragmentContext
<
'
a
>
)
>
for
MutBoxIterator
<
'
a
>
{
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
(
&
'
a
mut
Box
InlineFragmentContext
<
'
a
>
)
>
{
match
self
.
iter
.
next
(
)
{
None
=
>
None
Some
(
(
i
fragment
)
)
=
>
Some
(
(
fragment
InlineFragmentContext
:
:
new
(
self
.
map
i
)
)
)
}
}
}
pub
struct
InlineBoxes
{
pub
boxes
:
SmallVec0
<
Box
>
pub
map
:
FragmentMap
}
impl
InlineBoxes
{
pub
fn
new
(
)
-
>
InlineBoxes
{
InlineBoxes
{
boxes
:
SmallVec0
:
:
new
(
)
map
:
FragmentMap
:
:
new
(
)
}
}
pub
fn
len
(
&
self
)
-
>
uint
{
self
.
boxes
.
len
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
0
}
pub
fn
push
(
&
mut
self
fragment
:
Box
style
:
Arc
<
ComputedValues
>
)
{
self
.
map
.
push
(
style
Range
:
:
new
(
self
.
boxes
.
len
(
)
1
)
)
;
self
.
boxes
.
push
(
fragment
)
}
pub
fn
push_all
(
&
mut
self
other
:
InlineBoxes
)
{
let
InlineBoxes
{
boxes
:
other_boxes
map
:
other_map
}
=
other
;
let
adjustment
=
self
.
boxes
.
len
(
)
;
self
.
map
.
push_all
(
other_map
adjustment
)
;
self
.
boxes
.
push_all_move
(
other_boxes
)
;
}
pub
fn
iter
<
'
a
>
(
&
'
a
self
)
-
>
BoxIterator
<
'
a
>
{
BoxIterator
{
iter
:
self
.
boxes
.
as_slice
(
)
.
iter
(
)
.
enumerate
(
)
map
:
&
self
.
map
}
}
pub
fn
mut_iter
<
'
a
>
(
&
'
a
mut
self
)
-
>
MutBoxIterator
<
'
a
>
{
MutBoxIterator
{
iter
:
self
.
boxes
.
as_mut_slice
(
)
.
mut_iter
(
)
.
enumerate
(
)
map
:
&
self
.
map
}
}
pub
fn
get
<
'
a
>
(
&
'
a
self
index
:
uint
)
-
>
&
'
a
Box
{
self
.
boxes
.
get
(
index
)
}
pub
fn
get_mut
<
'
a
>
(
&
'
a
mut
self
index
:
uint
)
-
>
&
'
a
mut
Box
{
self
.
boxes
.
get_mut
(
index
)
}
}
pub
struct
InlineFlow
{
pub
base
:
BaseFlow
pub
boxes
:
InlineBoxes
pub
lines
:
SmallVec0
<
LineBox
>
}
impl
InlineFlow
{
pub
fn
from_boxes
(
node
:
ThreadSafeLayoutNode
boxes
:
InlineBoxes
)
-
>
InlineFlow
{
InlineFlow
{
base
:
BaseFlow
:
:
new
(
node
)
boxes
:
boxes
lines
:
SmallVec0
:
:
new
(
)
}
}
pub
fn
teardown
(
&
mut
self
)
{
for
(
fragment
_
)
in
self
.
boxes
.
iter
(
)
{
fragment
.
teardown
(
)
;
}
self
.
boxes
=
InlineBoxes
:
:
new
(
)
;
}
pub
fn
build_display_list_inline
(
&
mut
self
stacking_context
:
&
mut
StackingContext
builder
:
&
DisplayListBuilder
info
:
&
DisplayListBuildingInfo
)
{
let
abs_rect
=
Rect
(
self
.
base
.
abs_position
self
.
base
.
position
.
size
)
;
if
!
abs_rect
.
intersects
(
&
builder
.
dirty
)
{
return
}
debug
!
(
"
Flow
:
building
display
list
for
{
:
u
}
inline
boxes
"
self
.
boxes
.
len
(
)
)
;
for
(
fragment
context
)
in
self
.
boxes
.
mut_iter
(
)
{
let
rel_offset
=
fragment
.
relative_position
(
&
info
.
relative_containing_block_size
Some
(
context
)
)
;
fragment
.
build_display_list
(
stacking_context
builder
info
self
.
base
.
abs_position
+
rel_offset
ContentLevel
Some
(
context
)
)
;
}
}
fn
relative_offset_from_baseline
(
cur_box
:
&
Box
ascent
:
Au
parent_text_top
:
Au
parent_text_bottom
:
Au
top_from_base
:
&
mut
Au
bottom_from_base
:
&
mut
Au
biggest_top
:
&
mut
Au
biggest_bottom
:
&
mut
Au
)
-
>
(
Au
bool
)
{
match
cur_box
.
vertical_align
(
)
{
vertical_align
:
:
baseline
=
>
(
-
ascent
false
)
vertical_align
:
:
middle
=
>
{
let
xheight
=
Au
:
:
new
(
0
)
;
(
-
(
xheight
+
cur_box
.
content_height
(
)
)
.
scale_by
(
0
.
5
)
false
)
}
vertical_align
:
:
sub
=
>
{
let
sub_offset
=
Au
:
:
new
(
0
)
;
(
sub_offset
-
ascent
false
)
}
vertical_align
:
:
super_
=
>
{
let
super_offset
=
Au
:
:
new
(
0
)
;
(
-
super_offset
-
ascent
false
)
}
vertical_align
:
:
text_top
=
>
{
let
box_height
=
*
top_from_base
+
*
bottom_from_base
;
let
prev_bottom_from_base
=
*
bottom_from_base
;
*
top_from_base
=
parent_text_top
;
*
bottom_from_base
=
box_height
-
*
top_from_base
;
(
*
bottom_from_base
-
prev_bottom_from_base
-
ascent
false
)
}
vertical_align
:
:
text_bottom
=
>
{
let
box_height
=
*
top_from_base
+
*
bottom_from_base
;
let
prev_bottom_from_base
=
*
bottom_from_base
;
*
bottom_from_base
=
parent_text_bottom
;
*
top_from_base
=
box_height
-
*
bottom_from_base
;
(
*
bottom_from_base
-
prev_bottom_from_base
-
ascent
false
)
}
vertical_align
:
:
top
=
>
{
if
*
biggest_top
<
(
*
top_from_base
+
*
bottom_from_base
)
{
*
biggest_top
=
*
top_from_base
+
*
bottom_from_base
;
}
let
offset_top
=
*
top_from_base
-
ascent
;
(
offset_top
true
)
}
vertical_align
:
:
bottom
=
>
{
if
*
biggest_bottom
<
(
*
top_from_base
+
*
bottom_from_base
)
{
*
biggest_bottom
=
*
top_from_base
+
*
bottom_from_base
;
}
let
offset_bottom
=
-
(
*
bottom_from_base
+
ascent
)
;
(
offset_bottom
true
)
}
vertical_align
:
:
Length
(
length
)
=
>
(
-
(
length
+
ascent
)
false
)
vertical_align
:
:
Percentage
(
p
)
=
>
{
let
pt_size
=
cur_box
.
font_style
(
)
.
pt_size
;
let
line_height
=
cur_box
.
calculate_line_height
(
Au
:
:
from_pt
(
pt_size
)
)
;
let
percent_offset
=
line_height
.
scale_by
(
p
)
;
(
-
(
percent_offset
+
ascent
)
false
)
}
}
}
fn
set_horizontal_box_positions
(
boxes
:
&
mut
InlineBoxes
line
:
&
LineBox
linebox_align
:
text_align
:
:
T
)
{
let
slack_width
=
Au
:
:
max
(
Au
(
0
)
line
.
green_zone
.
width
-
line
.
bounds
.
size
.
width
)
;
let
mut
offset_x
=
line
.
bounds
.
origin
.
x
;
offset_x
=
offset_x
+
match
linebox_align
{
text_align
:
:
left
|
text_align
:
:
justify
=
>
Au
(
0
)
text_align
:
:
center
=
>
slack_width
.
scale_by
(
0
.
5
)
text_align
:
:
right
=
>
slack_width
}
;
for
i
in
line
.
range
.
eachi
(
)
{
let
box_
=
boxes
.
get_mut
(
i
)
;
let
size
=
box_
.
border_box
.
size
;
box_
.
border_box
=
Rect
(
Point2D
(
offset_x
box_
.
border_box
.
origin
.
y
)
size
)
;
offset_x
=
offset_x
+
size
.
width
;
}
}
}
impl
Flow
for
InlineFlow
{
fn
class
(
&
self
)
-
>
FlowClass
{
InlineFlowClass
}
fn
as_immutable_inline
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
InlineFlow
{
self
}
fn
as_inline
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
InlineFlow
{
self
}
fn
bubble_widths
(
&
mut
self
_
:
&
mut
LayoutContext
)
{
let
mut
num_floats
=
0
;
for
kid
in
self
.
base
.
child_iter
(
)
{
let
child_base
=
flow
:
:
mut_base
(
kid
)
;
num_floats
+
=
child_base
.
num_floats
;
child_base
.
floats
=
Floats
:
:
new
(
)
;
}
let
mut
intrinsic_widths
=
IntrinsicWidths
:
:
new
(
)
;
for
(
fragment
context
)
in
self
.
boxes
.
mut_iter
(
)
{
debug
!
(
"
Flow
:
measuring
{
:
s
}
"
fragment
.
debug_str
(
)
)
;
let
box_intrinsic_widths
=
fragment
.
intrinsic_widths
(
Some
(
context
)
)
;
intrinsic_widths
.
minimum_width
=
geometry
:
:
max
(
intrinsic_widths
.
minimum_width
box_intrinsic_widths
.
minimum_width
)
;
intrinsic_widths
.
preferred_width
=
geometry
:
:
max
(
intrinsic_widths
.
preferred_width
box_intrinsic_widths
.
preferred_width
)
;
}
self
.
base
.
intrinsic_widths
=
intrinsic_widths
;
self
.
base
.
num_floats
=
num_floats
;
}
fn
assign_widths
(
&
mut
self
_
:
&
mut
LayoutContext
)
{
debug
!
(
"
InlineFlow
:
:
assign_widths
:
floats
in
:
{
:
?
}
"
self
.
base
.
floats
)
;
{
let
this
=
&
mut
*
self
;
for
(
fragment
context
)
in
this
.
boxes
.
mut_iter
(
)
{
fragment
.
assign_replaced_width_if_necessary
(
self
.
base
.
position
.
size
.
width
Some
(
context
)
)
}
}
assert
!
(
self
.
base
.
children
.
len
(
)
=
=
0
"
InlineFlow
:
should
not
have
children
flows
in
the
current
layout
implementation
.
"
)
;
}
fn
assign_height_inorder
(
&
mut
self
ctx
:
&
mut
LayoutContext
)
{
for
kid
in
self
.
base
.
child_iter
(
)
{
kid
.
assign_height_inorder
(
ctx
)
;
}
self
.
assign_height
(
ctx
)
;
}
fn
assign_height
(
&
mut
self
_
:
&
mut
LayoutContext
)
{
debug
!
(
"
assign_height_inline
:
assigning
height
for
flow
"
)
;
debug
!
(
"
assign_height_inline
:
floats
in
:
{
:
?
}
"
self
.
base
.
floats
)
;
for
(
fragment
_
)
in
self
.
boxes
.
mut_iter
(
)
{
fragment
.
assign_replaced_height_if_necessary
(
)
;
}
let
scanner_floats
=
self
.
base
.
floats
.
clone
(
)
;
let
mut
scanner
=
LineboxScanner
:
:
new
(
scanner_floats
)
;
scanner
.
scan_for_lines
(
self
)
;
let
mut
line_height_offset
=
Au
:
:
new
(
0
)
;
let
text_align
=
self
.
base
.
flags
.
text_align
(
)
;
for
line
in
self
.
lines
.
mut_iter
(
)
{
InlineFlow
:
:
set_horizontal_box_positions
(
&
mut
self
.
boxes
line
text_align
)
;
line
.
bounds
.
origin
.
y
=
line
.
bounds
.
origin
.
y
+
line_height_offset
;
let
(
mut
topmost
mut
bottommost
)
=
(
Au
(
0
)
Au
(
0
)
)
;
let
(
mut
biggest_top
mut
biggest_bottom
)
=
(
Au
(
0
)
Au
(
0
)
)
;
for
box_i
in
line
.
range
.
eachi
(
)
{
let
cur_box
=
self
.
boxes
.
boxes
.
get_mut
(
box_i
)
;
let
top
=
cur_box
.
border_padding
.
top
;
let
(
top_from_base
bottom_from_base
ascent
)
=
match
cur_box
.
specific
{
ImageBox
(
_
)
=
>
{
let
mut
height
=
cur_box
.
content_height
(
)
;
let
bottom
=
cur_box
.
border_padding
.
bottom
;
let
noncontent_height
=
top
+
bottom
;
height
=
height
+
noncontent_height
;
let
ascent
=
height
+
bottom
;
(
height
Au
:
:
new
(
0
)
ascent
)
}
ScannedTextBox
(
ref
text_box
)
=
>
{
let
range
=
&
text_box
.
range
;
let
run
=
&
text_box
.
run
;
let
text_bounds
=
run
.
metrics_for_range
(
range
)
.
bounding_box
;
let
em_size
=
text_bounds
.
size
.
height
;
let
line_height
=
cur_box
.
calculate_line_height
(
em_size
)
;
let
text_ascent
=
text_box
.
run
.
font_metrics
.
ascent
;
let
text_offset
=
text_ascent
+
(
line_height
-
em_size
)
.
scale_by
(
0
.
5
)
;
text_bounds
.
translate
(
&
Point2D
(
cur_box
.
border_box
.
origin
.
x
Au
(
0
)
)
)
;
(
text_offset
line_height
-
text_offset
text_ascent
)
}
GenericBox
|
IframeBox
(
_
)
|
TableBox
|
TableCellBox
|
TableRowBox
|
TableWrapperBox
=
>
{
let
height
=
cur_box
.
border_box
.
size
.
height
;
(
height
Au
:
:
new
(
0
)
height
)
}
TableColumnBox
(
_
)
=
>
fail
!
(
"
Table
column
boxes
do
not
have
height
"
)
UnscannedTextBox
(
_
)
=
>
{
fail
!
(
"
Unscanned
text
boxes
should
have
been
scanned
by
now
.
"
)
}
}
;
let
mut
top_from_base
=
top_from_base
;
let
mut
bottom_from_base
=
bottom_from_base
;
let
parent_text_top
=
cur_box
.
style
(
)
.
Font
.
get
(
)
.
font_size
;
let
parent_text_bottom
=
Au
:
:
new
(
0
)
;
let
(
offset
no_update_flag
)
=
InlineFlow
:
:
relative_offset_from_baseline
(
cur_box
ascent
parent_text_top
parent_text_bottom
&
mut
top_from_base
&
mut
bottom_from_base
&
mut
biggest_top
&
mut
biggest_bottom
)
;
if
!
no_update_flag
&
&
top_from_base
>
topmost
{
topmost
=
top_from_base
;
}
if
!
no_update_flag
&
&
bottom_from_base
>
bottommost
{
bottommost
=
bottom_from_base
;
}
cur_box
.
border_box
.
origin
.
y
=
line
.
bounds
.
origin
.
y
+
offset
+
top
;
}
let
topmost_of_bottom
=
biggest_bottom
-
bottommost
;
if
topmost_of_bottom
>
topmost
{
topmost
=
topmost_of_bottom
;
}
let
bottommost_of_top
=
biggest_top
-
topmost
;
if
bottommost_of_top
>
bottommost
{
bottommost
=
bottommost_of_top
;
}
let
baseline_offset
=
topmost
;
for
box_i
in
line
.
range
.
eachi
(
)
{
let
cur_box
=
self
.
boxes
.
get_mut
(
box_i
)
;
let
adjust_offset
=
match
cur_box
.
vertical_align
(
)
{
vertical_align
:
:
top
=
>
Au
:
:
new
(
0
)
vertical_align
:
:
bottom
=
>
baseline_offset
+
bottommost
_
=
>
baseline_offset
}
;
cur_box
.
border_box
.
origin
.
y
=
cur_box
.
border_box
.
origin
.
y
+
adjust_offset
;
}
line_height_offset
=
line_height_offset
+
topmost
+
bottommost
-
line
.
bounds
.
size
.
height
;
line
.
bounds
.
size
.
height
=
topmost
+
bottommost
;
}
self
.
base
.
position
.
size
.
height
=
if
self
.
lines
.
len
(
)
>
0
{
self
.
lines
.
as_slice
(
)
.
last
(
)
.
get_ref
(
)
.
bounds
.
origin
.
y
+
self
.
lines
.
as_slice
(
)
.
last
(
)
.
get_ref
(
)
.
bounds
.
size
.
height
}
else
{
Au
:
:
new
(
0
)
}
;
self
.
base
.
floats
=
scanner
.
floats
(
)
;
self
.
base
.
floats
.
translate
(
Point2D
(
Au
:
:
new
(
0
)
-
self
.
base
.
position
.
size
.
height
)
)
;
}
fn
debug_str
(
&
self
)
-
>
~
str
{
let
mut
string
=
"
InlineFlow
:
"
.
to_str
(
)
;
for
(
i
(
fragment
_
)
)
in
self
.
boxes
.
iter
(
)
.
enumerate
(
)
{
if
i
!
=
0
{
string
.
push_str
(
"
"
)
}
string
.
push_str
(
fragment
.
debug_str
(
)
)
}
string
}
}
pub
struct
FragmentRange
{
pub
style
:
Arc
<
ComputedValues
>
pub
range
:
Range
}
impl
FragmentRange
{
fn
new
(
style
:
Arc
<
ComputedValues
>
range
:
Range
)
-
>
FragmentRange
{
FragmentRange
{
style
:
style
range
:
range
}
}
pub
fn
border
(
&
self
)
-
>
SideOffsets2D
<
Au
>
{
model
:
:
border_from_style
(
&
*
self
.
style
)
}
pub
fn
padding
(
&
self
)
-
>
SideOffsets2D
<
Au
>
{
model
:
:
padding_from_style
(
&
*
self
.
style
Au
(
0
)
)
}
}
struct
FragmentFixupWorkItem
{
style
:
Arc
<
ComputedValues
>
new_start_index
:
uint
old_end_index
:
uint
}
pub
struct
RangeIterator
<
'
a
>
{
iter
:
Items
<
'
a
FragmentRange
>
index
:
uint
seen_first
:
bool
}
impl
<
'
a
>
Iterator
<
&
'
a
FragmentRange
>
for
RangeIterator
<
'
a
>
{
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
FragmentRange
>
{
if
self
.
seen_first
{
match
self
.
iter
.
next
(
)
{
Some
(
fragment_range
)
if
fragment_range
.
range
.
contains
(
self
.
index
)
=
>
{
return
Some
(
fragment_range
)
}
Some
(
_
)
|
None
=
>
return
None
}
}
loop
{
match
self
.
iter
.
next
(
)
{
None
=
>
return
None
Some
(
fragment_range
)
if
fragment_range
.
range
.
contains
(
self
.
index
)
=
>
{
self
.
seen_first
=
true
;
return
Some
(
fragment_range
)
}
Some
(
_
)
=
>
{
}
}
}
}
}
pub
struct
FragmentMap
{
list
:
SmallVec0
<
FragmentRange
>
}
impl
FragmentMap
{
pub
fn
new
(
)
-
>
FragmentMap
{
FragmentMap
{
list
:
SmallVec0
:
:
new
(
)
}
}
pub
fn
push
(
&
mut
self
style
:
Arc
<
ComputedValues
>
range
:
Range
)
{
self
.
list
.
push
(
FragmentRange
:
:
new
(
style
range
)
)
}
fn
push_all
(
&
mut
self
other
:
FragmentMap
adjustment
:
uint
)
{
let
FragmentMap
{
list
:
mut
other_list
}
=
other
;
for
other_range
in
other_list
.
move_iter
(
)
{
let
FragmentRange
{
style
:
other_style
range
:
mut
other_range
}
=
other_range
;
other_range
.
shift_by
(
adjustment
as
int
)
;
self
.
push
(
other_style
other_range
)
}
}
pub
fn
get_mut
<
'
a
>
(
&
'
a
mut
self
index
:
uint
)
-
>
&
'
a
mut
FragmentRange
{
&
mut
self
.
list
.
as_mut_slice
(
)
[
index
]
}
#
[
inline
(
always
)
]
fn
ranges_for_index
<
'
a
>
(
&
'
a
self
index
:
uint
)
-
>
RangeIterator
<
'
a
>
{
RangeIterator
{
iter
:
self
.
list
.
as_slice
(
)
.
iter
(
)
index
:
index
seen_first
:
false
}
}
pub
fn
fixup
(
&
mut
self
old_fragments
:
&
[
Box
]
new_fragments
:
&
[
Box
]
)
{
let
mut
old_list
=
mem
:
:
replace
(
&
mut
self
.
list
SmallVec0
:
:
new
(
)
)
;
let
mut
worklist
=
SmallVec0
:
:
new
(
)
;
let
mut
old_list_iter
=
old_list
.
move_iter
(
)
.
peekable
(
)
;
let
mut
new_fragments_iter
=
new_fragments
.
iter
(
)
.
enumerate
(
)
.
peekable
(
)
;
for
(
old_fragment_index
old_fragment
)
in
old_fragments
.
iter
(
)
.
enumerate
(
)
{
let
new_fragment_start
=
match
new_fragments_iter
.
peek
(
)
{
Some
(
&
(
index
new_fragment
)
)
if
new_fragment
.
node
=
=
old_fragment
.
node
=
>
{
index
}
Some
(
_
)
|
None
=
>
{
continue
}
}
;
drop
(
new_fragments_iter
.
next
(
)
)
;
loop
{
match
new_fragments_iter
.
peek
(
)
{
Some
(
&
(
_
new_fragment
)
)
if
new_fragment
.
node
=
=
old_fragment
.
node
=
>
{
}
Some
(
_
)
|
None
=
>
break
}
drop
(
new_fragments_iter
.
next
(
)
)
;
}
loop
{
match
old_list_iter
.
peek
(
)
{
None
=
>
break
Some
(
fragment_range
)
=
>
{
if
fragment_range
.
range
.
begin
(
)
>
old_fragment_index
{
break
}
}
}
;
let
FragmentRange
{
style
:
style
range
:
old_range
}
=
old_list_iter
.
next
(
)
.
unwrap
(
)
;
worklist
.
push
(
FragmentFixupWorkItem
{
style
:
style
new_start_index
:
new_fragment_start
old_end_index
:
old_range
.
end
(
)
}
)
;
}
loop
{
match
worklist
.
as_slice
(
)
.
last
(
)
{
None
=
>
break
Some
(
last_work_item
)
=
>
{
if
last_work_item
.
old_end_index
>
old_fragment_index
+
1
{
break
}
}
}
let
new_last_index
=
match
new_fragments_iter
.
peek
(
)
{
None
=
>
{
new_fragments
.
len
(
)
}
Some
(
&
(
index
_
)
)
=
>
index
}
;
let
FragmentFixupWorkItem
{
style
new_start_index
.
.
}
=
worklist
.
pop
(
)
.
unwrap
(
)
;
let
range
=
Range
:
:
new
(
new_start_index
new_last_index
-
new_start_index
)
;
self
.
list
.
push
(
FragmentRange
:
:
new
(
style
range
)
)
}
}
}
}
pub
struct
InlineFragmentContext
<
'
a
>
{
map
:
&
'
a
FragmentMap
index
:
uint
}
impl
<
'
a
>
InlineFragmentContext
<
'
a
>
{
pub
fn
new
<
'
a
>
(
map
:
&
'
a
FragmentMap
index
:
uint
)
-
>
InlineFragmentContext
<
'
a
>
{
InlineFragmentContext
{
map
:
map
index
:
index
}
}
pub
fn
ranges
(
&
self
)
-
>
RangeIterator
<
'
a
>
{
self
.
map
.
ranges_for_index
(
self
.
index
)
}
}
