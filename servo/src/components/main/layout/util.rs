use
layout
:
:
construct
:
:
{
ConstructionResult
NoConstructionResult
}
;
use
layout
:
:
incremental
:
:
RestyleDamage
;
use
layout
:
:
parallel
:
:
DomParallelInfo
;
use
layout
:
:
wrapper
:
:
{
LayoutNode
TLayoutNode
ThreadSafeLayoutNode
}
;
use
gfx
:
:
display_list
:
:
OpaqueNode
;
use
gfx
;
use
libc
:
:
uintptr_t
;
use
script
:
:
dom
:
:
bindings
:
:
js
:
:
JS
;
use
script
:
:
dom
:
:
bindings
:
:
utils
:
:
Reflectable
;
use
script
:
:
dom
:
:
node
:
:
{
Node
SharedLayoutData
}
;
use
script
:
:
layout_interface
:
:
{
LayoutChan
UntrustedNodeAddress
TrustedNodeAddress
}
;
use
std
:
:
mem
;
use
std
:
:
cell
:
:
{
Ref
RefMut
}
;
use
style
:
:
ComputedValues
;
use
style
;
use
sync
:
:
Arc
;
pub
struct
PrivateLayoutData
{
pub
before_style
:
Option
<
Arc
<
ComputedValues
>
>
pub
after_style
:
Option
<
Arc
<
ComputedValues
>
>
pub
restyle_damage
:
Option
<
RestyleDamage
>
pub
flow_construction_result
:
ConstructionResult
pub
before_flow_construction_result
:
ConstructionResult
pub
after_flow_construction_result
:
ConstructionResult
pub
parallel
:
DomParallelInfo
}
impl
PrivateLayoutData
{
pub
fn
new
(
)
-
>
PrivateLayoutData
{
PrivateLayoutData
{
before_style
:
None
after_style
:
None
restyle_damage
:
None
flow_construction_result
:
NoConstructionResult
before_flow_construction_result
:
NoConstructionResult
after_flow_construction_result
:
NoConstructionResult
parallel
:
DomParallelInfo
:
:
new
(
)
}
}
}
pub
struct
LayoutDataWrapper
{
pub
chan
:
Option
<
LayoutChan
>
pub
shared_data
:
SharedLayoutData
pub
data
:
Box
<
PrivateLayoutData
>
}
pub
trait
LayoutDataAccess
{
unsafe
fn
borrow_layout_data_unchecked
(
&
self
)
-
>
*
Option
<
LayoutDataWrapper
>
;
fn
borrow_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
Option
<
LayoutDataWrapper
>
>
;
fn
mutate_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
Option
<
LayoutDataWrapper
>
>
;
}
impl
<
'
ln
>
LayoutDataAccess
for
LayoutNode
<
'
ln
>
{
#
[
inline
(
always
)
]
unsafe
fn
borrow_layout_data_unchecked
(
&
self
)
-
>
*
Option
<
LayoutDataWrapper
>
{
mem
:
:
transmute
(
self
.
get
(
)
.
layout_data
.
borrow_unchecked
(
)
)
}
#
[
inline
(
always
)
]
fn
borrow_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
Option
<
LayoutDataWrapper
>
>
{
unsafe
{
mem
:
:
transmute
(
self
.
get
(
)
.
layout_data
.
borrow
(
)
)
}
}
#
[
inline
(
always
)
]
fn
mutate_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
Option
<
LayoutDataWrapper
>
>
{
unsafe
{
mem
:
:
transmute
(
self
.
get
(
)
.
layout_data
.
borrow_mut
(
)
)
}
}
}
pub
trait
OpaqueNodeMethods
{
fn
from_layout_node
(
node
:
&
LayoutNode
)
-
>
Self
;
fn
from_thread_safe_layout_node
(
node
:
&
ThreadSafeLayoutNode
)
-
>
Self
;
fn
from_script_node
(
node
:
TrustedNodeAddress
)
-
>
Self
;
fn
from_jsmanaged
(
node
:
&
JS
<
Node
>
)
-
>
Self
;
fn
to_untrusted_node_address
(
&
self
)
-
>
UntrustedNodeAddress
;
}
impl
OpaqueNodeMethods
for
OpaqueNode
{
fn
from_layout_node
(
node
:
&
LayoutNode
)
-
>
OpaqueNode
{
unsafe
{
OpaqueNodeMethods
:
:
from_jsmanaged
(
node
.
get_jsmanaged
(
)
)
}
}
fn
from_thread_safe_layout_node
(
node
:
&
ThreadSafeLayoutNode
)
-
>
OpaqueNode
{
unsafe
{
let
abstract_node
=
node
.
get_jsmanaged
(
)
;
let
ptr
:
uintptr_t
=
abstract_node
.
reflector
(
)
.
get_jsobject
(
)
as
uint
;
OpaqueNode
(
ptr
)
}
}
fn
from_script_node
(
node
:
TrustedNodeAddress
)
-
>
OpaqueNode
{
unsafe
{
OpaqueNodeMethods
:
:
from_jsmanaged
(
&
JS
:
:
from_trusted_node_address
(
node
)
)
}
}
fn
from_jsmanaged
(
node
:
&
JS
<
Node
>
)
-
>
OpaqueNode
{
unsafe
{
let
ptr
:
uintptr_t
=
mem
:
:
transmute
(
node
.
reflector
(
)
.
get_jsobject
(
)
)
;
OpaqueNode
(
ptr
)
}
}
fn
to_untrusted_node_address
(
&
self
)
-
>
UntrustedNodeAddress
{
unsafe
{
let
OpaqueNode
(
addr
)
=
*
self
;
let
addr
:
UntrustedNodeAddress
=
mem
:
:
transmute
(
addr
)
;
addr
}
}
}
pub
trait
ToGfxColor
{
fn
to_gfx_color
(
&
self
)
-
>
gfx
:
:
color
:
:
Color
;
}
impl
ToGfxColor
for
style
:
:
computed_values
:
:
RGBA
{
fn
to_gfx_color
(
&
self
)
-
>
gfx
:
:
color
:
:
Color
{
gfx
:
:
color
:
:
rgba
(
self
.
red
self
.
green
self
.
blue
self
.
alpha
)
}
}
