use
layout
:
:
box_
:
:
Box
;
use
layout
:
:
construct
:
:
{
ConstructionResult
NoConstructionResult
}
;
use
layout
:
:
wrapper
:
:
LayoutNode
;
use
extra
:
:
arc
:
:
Arc
;
use
script
:
:
dom
:
:
node
:
:
AbstractNode
;
use
script
:
:
layout_interface
:
:
LayoutChan
;
use
servo_util
:
:
range
:
:
Range
;
use
std
:
:
cast
;
use
std
:
:
cell
:
:
{
Ref
RefMut
}
;
use
std
:
:
iter
:
:
Enumerate
;
use
std
:
:
libc
:
:
uintptr_t
;
use
std
:
:
vec
:
:
VecIterator
;
use
style
:
:
{
ComputedValues
PropertyDeclaration
}
;
pub
struct
NodeRange
{
node
:
OpaqueNode
range
:
Range
}
impl
NodeRange
{
pub
fn
new
(
node
:
OpaqueNode
range
:
&
Range
)
-
>
NodeRange
{
NodeRange
{
node
:
node
range
:
(
*
range
)
.
clone
(
)
}
}
}
pub
struct
ElementMapping
{
priv
entries
:
~
[
NodeRange
]
}
impl
ElementMapping
{
pub
fn
new
(
)
-
>
ElementMapping
{
ElementMapping
{
entries
:
~
[
]
}
}
pub
fn
add_mapping
(
&
mut
self
node
:
OpaqueNode
range
:
&
Range
)
{
self
.
entries
.
push
(
NodeRange
:
:
new
(
node
range
)
)
}
pub
fn
each
(
&
self
callback
:
|
nr
:
&
NodeRange
|
-
>
bool
)
-
>
bool
{
for
nr
in
self
.
entries
.
iter
(
)
{
if
!
callback
(
nr
)
{
break
}
}
true
}
pub
fn
eachi
<
'
a
>
(
&
'
a
self
)
-
>
Enumerate
<
VecIterator
<
'
a
NodeRange
>
>
{
self
.
entries
.
iter
(
)
.
enumerate
(
)
}
pub
fn
repair_for_box_changes
(
&
mut
self
old_boxes
:
&
[
Box
]
new_boxes
:
&
[
Box
]
)
{
let
entries
=
&
mut
self
.
entries
;
debug
!
(
"
-
-
-
Old
boxes
:
-
-
-
"
)
;
for
(
i
box_
)
in
old_boxes
.
iter
(
)
.
enumerate
(
)
{
debug
!
(
"
{
:
u
}
-
-
>
{
:
s
}
"
i
box_
.
debug_str
(
)
)
;
}
debug
!
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
)
;
debug
!
(
"
-
-
-
New
boxes
:
-
-
-
"
)
;
for
(
i
box_
)
in
new_boxes
.
iter
(
)
.
enumerate
(
)
{
debug
!
(
"
{
:
u
}
-
-
>
{
:
s
}
"
i
box_
.
debug_str
(
)
)
;
}
debug
!
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
)
;
debug
!
(
"
-
-
-
Elem
ranges
before
repair
:
-
-
-
"
)
;
for
(
i
nr
)
in
entries
.
iter
(
)
.
enumerate
(
)
{
debug
!
(
"
{
:
u
}
:
{
}
-
-
>
{
:
?
}
"
i
nr
.
range
nr
.
node
.
id
(
)
)
;
}
debug
!
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
)
;
let
mut
old_i
=
0
;
let
mut
new_j
=
0
;
struct
WorkItem
{
begin_idx
:
uint
entry_idx
:
uint
}
;
let
mut
repair_stack
:
~
[
WorkItem
]
=
~
[
]
;
/
/
index
into
entries
let
mut
entries_k
=
0
;
while
old_i
<
old_boxes
.
len
(
)
{
debug
!
(
"
repair_for_box_changes
:
Considering
old
box
{
:
u
}
"
old_i
)
;
/
/
possibly
push
several
items
while
entries_k
<
entries
.
len
(
)
&
&
old_i
=
=
entries
[
entries_k
]
.
range
.
begin
(
)
{
let
item
=
WorkItem
{
begin_idx
:
new_j
entry_idx
:
entries_k
}
;
debug
!
(
"
repair_for_box_changes
:
Push
work
item
for
elem
{
:
u
}
:
{
:
?
}
"
entries_k
item
)
;
repair_stack
.
push
(
item
)
;
entries_k
+
=
1
;
}
while
new_j
<
new_boxes
.
len
(
)
&
&
old_boxes
[
old_i
]
.
node
!
=
new_boxes
[
new_j
]
.
node
{
debug
!
(
"
repair_for_box_changes
:
Slide
through
new
box
{
:
u
}
"
new_j
)
;
new_j
+
=
1
;
}
old_i
+
=
1
;
/
/
possibly
pop
several
items
while
repair_stack
.
len
(
)
>
0
&
&
old_i
=
=
entries
[
repair_stack
.
last
(
)
.
entry_idx
]
.
range
.
end
(
)
{
let
item
=
repair_stack
.
pop
(
)
;
debug
!
(
"
repair_for_box_changes
:
Set
range
for
{
:
u
}
to
{
}
"
item
.
entry_idx
Range
:
:
new
(
item
.
begin_idx
new_j
-
item
.
begin_idx
)
)
;
entries
[
item
.
entry_idx
]
.
range
=
Range
:
:
new
(
item
.
begin_idx
new_j
-
item
.
begin_idx
)
;
}
}
debug
!
(
"
-
-
-
Elem
ranges
after
repair
:
-
-
-
"
)
;
for
(
i
nr
)
in
entries
.
iter
(
)
.
enumerate
(
)
{
debug
!
(
"
{
:
u
}
:
{
}
-
-
>
{
:
?
}
"
i
nr
.
range
nr
.
node
.
id
(
)
)
;
}
debug
!
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
)
;
}
}
pub
struct
PrivateLayoutData
{
before_applicable_declarations
:
~
[
Arc
<
~
[
PropertyDeclaration
]
>
]
applicable_declarations
:
~
[
Arc
<
~
[
PropertyDeclaration
]
>
]
after_applicable_declarations
:
~
[
Arc
<
~
[
PropertyDeclaration
]
>
]
before_style
:
Option
<
Arc
<
ComputedValues
>
>
style
:
Option
<
Arc
<
ComputedValues
>
>
after_style
:
Option
<
Arc
<
ComputedValues
>
>
restyle_damage
:
Option
<
int
>
flow_construction_result
:
ConstructionResult
}
impl
PrivateLayoutData
{
pub
fn
new
(
)
-
>
PrivateLayoutData
{
PrivateLayoutData
{
applicable_declarations
:
~
[
]
before_applicable_declarations
:
~
[
]
after_applicable_declarations
:
~
[
]
before_style
:
None
style
:
None
after_style
:
None
restyle_damage
:
None
flow_construction_result
:
NoConstructionResult
}
}
}
pub
struct
LayoutDataWrapper
{
chan
:
Option
<
LayoutChan
>
data
:
~
PrivateLayoutData
}
pub
trait
LayoutDataAccess
{
fn
borrow_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
Option
<
LayoutDataWrapper
>
>
;
fn
mutate_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
Option
<
LayoutDataWrapper
>
>
;
}
impl
<
'
ln
>
LayoutDataAccess
for
LayoutNode
<
'
ln
>
{
#
[
inline
(
always
)
]
fn
borrow_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
Option
<
LayoutDataWrapper
>
>
{
unsafe
{
cast
:
:
transmute
(
self
.
get
(
)
.
layout_data
.
borrow
(
)
)
}
}
#
[
inline
(
always
)
]
fn
mutate_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
Option
<
LayoutDataWrapper
>
>
{
unsafe
{
cast
:
:
transmute
(
self
.
get
(
)
.
layout_data
.
borrow_mut
(
)
)
}
}
}
#
[
deriving
(
Clone
Eq
)
]
pub
struct
OpaqueNode
(
uintptr_t
)
;
impl
OpaqueNode
{
pub
fn
from_layout_node
(
node
:
&
LayoutNode
)
-
>
OpaqueNode
{
unsafe
{
OpaqueNode
(
cast
:
:
transmute_copy
(
node
)
)
}
}
pub
fn
from_script_node
(
node
:
&
AbstractNode
)
-
>
OpaqueNode
{
unsafe
{
OpaqueNode
(
cast
:
:
transmute_copy
(
node
)
)
}
}
pub
unsafe
fn
to_script_node
(
&
self
)
-
>
AbstractNode
{
cast
:
:
transmute
(
*
*
self
)
}
pub
fn
id
(
&
self
)
-
>
uintptr_t
{
unsafe
{
cast
:
:
transmute_copy
(
self
)
}
}
}
