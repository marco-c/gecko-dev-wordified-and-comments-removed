use
layout
:
:
context
:
:
LayoutContext
;
use
layout
:
:
flow
:
:
{
BaseFlow
TableColGroupFlowClass
FlowClass
Flow
}
;
use
layout
:
:
fragment
:
:
{
Fragment
TableColumnFragment
}
;
use
layout
:
:
model
:
:
{
MaybeAuto
}
;
use
layout
:
:
wrapper
:
:
ThreadSafeLayoutNode
;
use
servo_util
:
:
geometry
:
:
Au
;
use
std
:
:
fmt
;
pub
struct
TableColGroupFlow
{
pub
base
:
BaseFlow
pub
fragment
:
Option
<
Fragment
>
pub
cols
:
Vec
<
Fragment
>
pub
widths
:
Vec
<
Au
>
}
impl
TableColGroupFlow
{
pub
fn
from_node_and_fragments
(
node
:
&
ThreadSafeLayoutNode
fragment
:
Fragment
fragments
:
Vec
<
Fragment
>
)
-
>
TableColGroupFlow
{
TableColGroupFlow
{
base
:
BaseFlow
:
:
new
(
(
*
node
)
.
clone
(
)
)
fragment
:
Some
(
fragment
)
cols
:
fragments
widths
:
vec
!
(
)
}
}
}
impl
Flow
for
TableColGroupFlow
{
fn
class
(
&
self
)
-
>
FlowClass
{
TableColGroupFlowClass
}
fn
as_table_colgroup
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableColGroupFlow
{
self
}
fn
bubble_widths
(
&
mut
self
_
:
&
mut
LayoutContext
)
{
for
fragment
in
self
.
cols
.
iter
(
)
{
let
width
=
MaybeAuto
:
:
from_style
(
fragment
.
style
(
)
.
get_box
(
)
.
width
Au
:
:
new
(
0
)
)
.
specified_or_zero
(
)
;
let
span
:
int
=
match
fragment
.
specific
{
TableColumnFragment
(
col_fragment
)
=
>
col_fragment
.
span
.
unwrap_or
(
1
)
_
=
>
fail
!
(
"
Other
fragment
come
out
in
TableColGroupFlow
.
{
:
?
}
"
fragment
.
specific
)
}
;
for
_
in
range
(
0
span
)
{
self
.
widths
.
push
(
width
)
;
}
}
}
fn
assign_widths
(
&
mut
self
_ctx
:
&
mut
LayoutContext
)
{
}
fn
assign_height
(
&
mut
self
_ctx
:
&
mut
LayoutContext
)
{
}
}
impl
fmt
:
:
Show
for
TableColGroupFlow
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
.
fragment
{
Some
(
ref
rb
)
=
>
write
!
(
f
.
buf
"
TableColGroupFlow
:
{
}
"
rb
)
None
=
>
write
!
(
f
.
buf
"
TableColGroupFlow
"
)
}
}
}
