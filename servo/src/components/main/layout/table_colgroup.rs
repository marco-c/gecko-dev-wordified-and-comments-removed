use
layout
:
:
box_
:
:
{
Box
TableColumnBox
}
;
use
layout
:
:
context
:
:
LayoutContext
;
use
layout
:
:
flow
:
:
{
BaseFlow
TableColGroupFlowClass
FlowClass
Flow
}
;
use
layout
:
:
model
:
:
{
MaybeAuto
}
;
use
layout
:
:
wrapper
:
:
ThreadSafeLayoutNode
;
use
servo_util
:
:
geometry
:
:
Au
;
pub
struct
TableColGroupFlow
{
pub
base
:
BaseFlow
pub
box_
:
Option
<
Box
>
pub
cols
:
Vec
<
Box
>
pub
widths
:
Vec
<
Au
>
}
impl
TableColGroupFlow
{
pub
fn
from_node_and_boxes
(
node
:
&
ThreadSafeLayoutNode
box_
:
Box
boxes
:
Vec
<
Box
>
)
-
>
TableColGroupFlow
{
TableColGroupFlow
{
base
:
BaseFlow
:
:
new
(
(
*
node
)
.
clone
(
)
)
box_
:
Some
(
box_
)
cols
:
boxes
widths
:
vec
!
(
)
}
}
pub
fn
teardown
(
&
mut
self
)
{
for
box_
in
self
.
box_
.
iter
(
)
{
box_
.
teardown
(
)
;
}
self
.
box_
=
None
;
self
.
cols
=
vec
!
(
)
;
self
.
widths
=
vec
!
(
)
;
}
}
impl
Flow
for
TableColGroupFlow
{
fn
class
(
&
self
)
-
>
FlowClass
{
TableColGroupFlowClass
}
fn
as_table_colgroup
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableColGroupFlow
{
self
}
fn
bubble_widths
(
&
mut
self
_
:
&
mut
LayoutContext
)
{
for
box_
in
self
.
cols
.
iter
(
)
{
let
width
=
MaybeAuto
:
:
from_style
(
box_
.
style
(
)
.
Box
.
get
(
)
.
width
Au
:
:
new
(
0
)
)
.
specified_or_zero
(
)
;
let
span
:
int
=
match
box_
.
specific
{
TableColumnBox
(
col_box
)
=
>
col_box
.
span
.
unwrap_or
(
1
)
_
=
>
fail
!
(
"
Other
box
come
out
in
TableColGroupFlow
.
{
:
?
}
"
box_
.
specific
)
}
;
for
_
in
range
(
0
span
)
{
self
.
widths
.
push
(
width
)
;
}
}
}
fn
assign_widths
(
&
mut
self
_ctx
:
&
mut
LayoutContext
)
{
}
fn
assign_height
(
&
mut
self
_ctx
:
&
mut
LayoutContext
)
{
}
fn
debug_str
(
&
self
)
-
>
~
str
{
let
txt
=
"
TableColGroupFlow
:
"
.
to_owned
(
)
;
txt
.
append
(
match
self
.
box_
{
Some
(
ref
rb
)
=
>
rb
.
debug_str
(
)
None
=
>
"
"
.
to_owned
(
)
}
)
}
}
