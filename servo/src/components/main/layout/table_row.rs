use
layout
:
:
box_
:
:
Box
;
use
layout
:
:
block
:
:
BlockFlow
;
use
layout
:
:
block
:
:
WidthAndMarginsComputer
;
use
layout
:
:
construct
:
:
FlowConstructor
;
use
layout
:
:
context
:
:
LayoutContext
;
use
layout
:
:
flow
:
:
{
TableRowFlowClass
FlowClass
Flow
ImmutableFlowUtils
}
;
use
layout
:
:
flow
;
use
layout
:
:
table
:
:
InternalTable
;
use
layout
:
:
model
:
:
{
MaybeAuto
Specified
Auto
}
;
use
layout
:
:
wrapper
:
:
ThreadSafeLayoutNode
;
use
servo_util
:
:
geometry
:
:
Au
;
use
servo_util
:
:
geometry
;
use
std
:
:
fmt
;
pub
struct
TableRowFlow
{
pub
block_flow
:
BlockFlow
pub
col_widths
:
Vec
<
Au
>
pub
col_min_widths
:
Vec
<
Au
>
pub
col_pref_widths
:
Vec
<
Au
>
}
impl
TableRowFlow
{
pub
fn
from_node_and_box
(
node
:
&
ThreadSafeLayoutNode
box_
:
Box
)
-
>
TableRowFlow
{
TableRowFlow
{
block_flow
:
BlockFlow
:
:
from_node_and_box
(
node
box_
)
col_widths
:
vec
!
(
)
col_min_widths
:
vec
!
(
)
col_pref_widths
:
vec
!
(
)
}
}
pub
fn
from_node
(
constructor
:
&
mut
FlowConstructor
node
:
&
ThreadSafeLayoutNode
)
-
>
TableRowFlow
{
TableRowFlow
{
block_flow
:
BlockFlow
:
:
from_node
(
constructor
node
)
col_widths
:
vec
!
(
)
col_min_widths
:
vec
!
(
)
col_pref_widths
:
vec
!
(
)
}
}
pub
fn
box_
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
Box
{
&
self
.
block_flow
.
box_
}
fn
initialize_offsets
(
&
mut
self
)
-
>
(
Au
Au
Au
)
{
(
Au
(
0
)
Au
(
0
)
Au
(
0
)
)
}
#
[
inline
(
always
)
]
fn
assign_height_table_row_base
(
&
mut
self
layout_context
:
&
mut
LayoutContext
)
{
let
(
top_offset
_
_
)
=
self
.
initialize_offsets
(
)
;
let
cur_y
=
top_offset
;
let
mut
max_y
=
Au
:
:
new
(
0
)
;
for
kid
in
self
.
block_flow
.
base
.
child_iter
(
)
{
kid
.
assign_height_for_inorder_child_if_necessary
(
layout_context
)
;
{
let
child_box
=
kid
.
as_table_cell
(
)
.
box_
(
)
;
let
child_specified_height
=
MaybeAuto
:
:
from_style
(
child_box
.
style
(
)
.
Box
.
get
(
)
.
height
Au
:
:
new
(
0
)
)
.
specified_or_zero
(
)
;
max_y
=
geometry
:
:
max
(
max_y
child_specified_height
+
child_box
.
border_padding
.
vertical
(
)
)
;
}
let
child_node
=
flow
:
:
mut_base
(
kid
)
;
child_node
.
position
.
origin
.
y
=
cur_y
;
max_y
=
geometry
:
:
max
(
max_y
child_node
.
position
.
size
.
height
)
;
}
let
mut
height
=
max_y
;
height
=
match
MaybeAuto
:
:
from_style
(
self
.
block_flow
.
box_
.
style
(
)
.
Box
.
get
(
)
.
height
Au
(
0
)
)
{
Auto
=
>
height
Specified
(
value
)
=
>
geometry
:
:
max
(
value
height
)
}
;
let
mut
position
=
self
.
block_flow
.
box_
.
border_box
;
position
.
size
.
height
=
height
;
self
.
block_flow
.
box_
.
border_box
=
position
;
self
.
block_flow
.
base
.
position
.
size
.
height
=
height
;
for
kid
in
self
.
block_flow
.
base
.
child_iter
(
)
{
{
let
kid_box_
=
kid
.
as_table_cell
(
)
.
mut_box
(
)
;
let
mut
position
=
kid_box_
.
border_box
;
position
.
size
.
height
=
height
;
kid_box_
.
border_box
=
position
;
}
let
child_node
=
flow
:
:
mut_base
(
kid
)
;
child_node
.
position
.
size
.
height
=
height
;
}
}
pub
fn
build_display_list_table_row
(
&
mut
self
layout_context
:
&
LayoutContext
)
{
debug
!
(
"
build_display_list_table_row
:
same
process
as
block
flow
"
)
;
self
.
block_flow
.
build_display_list_block
(
layout_context
)
}
}
impl
Flow
for
TableRowFlow
{
fn
class
(
&
self
)
-
>
FlowClass
{
TableRowFlowClass
}
fn
as_table_row
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableRowFlow
{
self
}
fn
as_block
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
BlockFlow
{
&
mut
self
.
block_flow
}
fn
col_widths
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Vec
<
Au
>
{
&
mut
self
.
col_widths
}
fn
col_min_widths
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Vec
<
Au
>
{
&
self
.
col_min_widths
}
fn
col_pref_widths
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Vec
<
Au
>
{
&
self
.
col_pref_widths
}
fn
bubble_widths
(
&
mut
self
_
:
&
mut
LayoutContext
)
{
let
mut
min_width
=
Au
(
0
)
;
let
mut
pref_width
=
Au
(
0
)
;
for
kid
in
self
.
block_flow
.
base
.
child_iter
(
)
{
assert
!
(
kid
.
is_table_cell
(
)
)
;
{
let
child_box
=
kid
.
as_table_cell
(
)
.
box_
(
)
;
let
child_specified_width
=
MaybeAuto
:
:
from_style
(
child_box
.
style
(
)
.
Box
.
get
(
)
.
width
Au
:
:
new
(
0
)
)
.
specified_or_zero
(
)
;
self
.
col_widths
.
push
(
child_specified_width
)
;
}
let
child_base
=
flow
:
:
mut_base
(
kid
)
;
self
.
col_min_widths
.
push
(
child_base
.
intrinsic_widths
.
minimum_width
)
;
self
.
col_pref_widths
.
push
(
child_base
.
intrinsic_widths
.
preferred_width
)
;
min_width
=
min_width
+
child_base
.
intrinsic_widths
.
minimum_width
;
pref_width
=
pref_width
+
child_base
.
intrinsic_widths
.
preferred_width
;
}
self
.
block_flow
.
base
.
intrinsic_widths
.
minimum_width
=
min_width
;
self
.
block_flow
.
base
.
intrinsic_widths
.
preferred_width
=
geometry
:
:
max
(
min_width
pref_width
)
;
}
fn
assign_widths
(
&
mut
self
ctx
:
&
mut
LayoutContext
)
{
debug
!
(
"
assign_widths
(
{
}
)
:
assigning
width
for
flow
"
"
table_row
"
)
;
let
containing_block_width
=
self
.
block_flow
.
base
.
position
.
size
.
width
;
let
left_content_edge
=
Au
:
:
new
(
0
)
;
let
width_computer
=
InternalTable
;
width_computer
.
compute_used_width
(
&
mut
self
.
block_flow
ctx
containing_block_width
)
;
self
.
block_flow
.
propagate_assigned_width_to_children
(
left_content_edge
Au
(
0
)
Some
(
self
.
col_widths
.
clone
(
)
)
)
;
}
fn
assign_height
(
&
mut
self
ctx
:
&
mut
LayoutContext
)
{
debug
!
(
"
assign_height
:
assigning
height
for
table_row
"
)
;
self
.
assign_height_table_row_base
(
ctx
)
;
}
fn
compute_absolute_position
(
&
mut
self
)
{
self
.
block_flow
.
compute_absolute_position
(
)
}
}
impl
fmt
:
:
Show
for
TableRowFlow
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
.
buf
"
TableRowFlow
:
{
}
"
self
.
block_flow
.
box_
)
}
}
