use
layout
:
:
incremental
:
:
RestyleDamage
;
use
gfx
:
:
display_list
:
:
DisplayList
;
use
servo_util
:
:
range
:
:
Range
;
use
extra
:
:
arc
:
:
Arc
;
use
newcss
:
:
complete
:
:
CompleteSelectResults
;
use
script
:
:
dom
:
:
node
:
:
{
AbstractNode
LayoutView
}
;
use
servo_util
:
:
tree
:
:
TreeNodeRef
;
pub
struct
DisplayBoxes
{
display_list
:
Option
<
Arc
<
DisplayList
<
AbstractNode
<
(
)
>
>
>
>
range
:
Option
<
Range
>
}
pub
struct
LayoutData
{
style
:
Option
<
CompleteSelectResults
>
restyle_damage
:
Option
<
RestyleDamage
>
boxes
:
DisplayBoxes
}
impl
LayoutData
{
pub
fn
new
(
)
-
>
LayoutData
{
LayoutData
{
style
:
None
restyle_damage
:
None
boxes
:
DisplayBoxes
{
display_list
:
None
range
:
None
}
}
}
}
pub
trait
LayoutAuxMethods
{
fn
layout_data
(
self
)
-
>
mut
LayoutData
;
fn
has_layout_data
(
self
)
-
>
bool
;
fn
set_layout_data
(
self
data
:
mut
LayoutData
)
;
fn
initialize_layout_data
(
self
)
-
>
Option
<
mut
LayoutData
>
;
fn
initialize_style_for_subtree
(
self
refs
:
&
mut
~
[
mut
LayoutData
]
)
;
}
impl
LayoutAuxMethods
for
AbstractNode
<
LayoutView
>
{
fn
layout_data
(
self
)
-
>
mut
LayoutData
{
unsafe
{
self
.
unsafe_layout_data
(
)
}
}
fn
has_layout_data
(
self
)
-
>
bool
{
unsafe
{
self
.
unsafe_has_layout_data
(
)
}
}
fn
set_layout_data
(
self
data
:
mut
LayoutData
)
{
unsafe
{
self
.
unsafe_set_layout_data
(
data
)
}
}
fn
initialize_layout_data
(
self
)
-
>
Option
<
mut
LayoutData
>
{
if
self
.
has_layout_data
(
)
{
self
.
layout_data
(
)
.
boxes
.
display_list
=
None
;
self
.
layout_data
(
)
.
boxes
.
range
=
None
;
None
}
else
{
let
data
=
mut
LayoutData
:
:
new
(
)
;
self
.
set_layout_data
(
data
)
;
Some
(
data
)
}
}
fn
initialize_style_for_subtree
(
self
refs
:
&
mut
~
[
mut
LayoutData
]
)
{
let
_
=
for
n
in
self
.
traverse_preorder
(
)
{
match
n
.
initialize_layout_data
(
)
{
Some
(
r
)
=
>
refs
.
push
(
r
)
None
=
>
{
}
}
}
;
}
}
