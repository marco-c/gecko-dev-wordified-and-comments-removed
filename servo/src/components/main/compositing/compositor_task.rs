pub
use
windowing
;
use
constellation
:
:
SendableFrameTree
;
use
windowing
:
:
{
ApplicationMethods
WindowMethods
}
;
use
platform
:
:
Application
;
use
azure
:
:
azure_hl
:
:
{
SourceSurfaceMethods
Color
}
;
use
geom
:
:
point
:
:
Point2D
;
use
geom
:
:
rect
:
:
Rect
;
use
geom
:
:
size
:
:
Size2D
;
use
layers
:
:
platform
:
:
surface
:
:
{
NativeCompositingGraphicsContext
NativeGraphicsMetadata
}
;
use
servo_msg
:
:
compositor_msg
:
:
{
Epoch
LayerBufferSet
LayerId
LayerMetadata
ReadyState
}
;
use
servo_msg
:
:
compositor_msg
:
:
{
RenderListener
RenderState
ScriptListener
ScrollPolicy
}
;
use
servo_msg
:
:
constellation_msg
:
:
{
ConstellationChan
PipelineId
}
;
use
servo_util
:
:
opts
:
:
Opts
;
use
servo_util
:
:
time
:
:
ProfilerChan
;
use
std
:
:
comm
:
:
{
channel
Sender
Receiver
}
;
use
url
:
:
Url
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
use
azure
:
:
azure_hl
;
mod
quadtree
;
mod
compositor_layer
;
mod
compositor
;
mod
headless
;
#
[
deriving
(
Clone
)
]
pub
struct
CompositorChan
{
pub
chan
:
Sender
<
Msg
>
}
impl
ScriptListener
for
CompositorChan
{
fn
set_ready_state
(
&
self
ready_state
:
ReadyState
)
{
let
msg
=
ChangeReadyState
(
ready_state
)
;
self
.
chan
.
send
(
msg
)
;
}
fn
scroll_fragment_point
(
&
self
pipeline_id
:
PipelineId
layer_id
:
LayerId
point
:
Point2D
<
f32
>
)
{
self
.
chan
.
send
(
ScrollFragmentPoint
(
pipeline_id
layer_id
point
)
)
;
}
fn
close
(
&
self
)
{
let
(
chan
port
)
=
channel
(
)
;
self
.
chan
.
send
(
Exit
(
chan
)
)
;
port
.
recv
(
)
;
}
fn
dup
(
&
self
)
-
>
Box
<
ScriptListener
>
{
box
self
.
clone
(
)
as
Box
<
ScriptListener
>
}
}
impl
RenderListener
for
CompositorChan
{
fn
get_graphics_metadata
(
&
self
)
-
>
Option
<
NativeGraphicsMetadata
>
{
let
(
chan
port
)
=
channel
(
)
;
self
.
chan
.
send
(
GetGraphicsMetadata
(
chan
)
)
;
port
.
recv
(
)
}
fn
paint
(
&
self
pipeline_id
:
PipelineId
layer_id
:
LayerId
layer_buffer_set
:
Box
<
LayerBufferSet
>
epoch
:
Epoch
)
{
self
.
chan
.
send
(
Paint
(
pipeline_id
layer_id
layer_buffer_set
epoch
)
)
}
fn
initialize_layers_for_pipeline
(
&
self
pipeline_id
:
PipelineId
metadata
:
Vec
<
LayerMetadata
>
epoch
:
Epoch
)
{
let
mut
first
=
true
;
for
metadata
in
metadata
.
iter
(
)
{
let
origin
=
Point2D
(
metadata
.
position
.
origin
.
x
as
f32
metadata
.
position
.
origin
.
y
as
f32
)
;
let
size
=
Size2D
(
metadata
.
position
.
size
.
width
as
f32
metadata
.
position
.
size
.
height
as
f32
)
;
let
rect
=
Rect
(
origin
size
)
;
if
first
{
self
.
chan
.
send
(
CreateRootCompositorLayerIfNecessary
(
pipeline_id
metadata
.
id
size
metadata
.
background_color
)
)
;
first
=
false
}
else
{
self
.
chan
.
send
(
CreateDescendantCompositorLayerIfNecessary
(
pipeline_id
metadata
.
id
rect
metadata
.
scroll_policy
)
)
;
}
self
.
chan
.
send
(
SetUnRenderedColor
(
pipeline_id
metadata
.
id
metadata
.
background_color
)
)
;
self
.
chan
.
send
(
SetLayerPageSize
(
pipeline_id
metadata
.
id
size
epoch
)
)
;
self
.
chan
.
send
(
SetLayerClipRect
(
pipeline_id
metadata
.
id
rect
)
)
;
}
}
fn
set_layer_clip_rect
(
&
self
pipeline_id
:
PipelineId
layer_id
:
LayerId
new_rect
:
Rect
<
uint
>
)
{
let
new_rect
=
Rect
(
Point2D
(
new_rect
.
origin
.
x
as
f32
new_rect
.
origin
.
y
as
f32
)
Size2D
(
new_rect
.
size
.
width
as
f32
new_rect
.
size
.
height
as
f32
)
)
;
self
.
chan
.
send
(
SetLayerClipRect
(
pipeline_id
layer_id
new_rect
)
)
}
fn
delete_layer_group
(
&
self
id
:
PipelineId
)
{
self
.
chan
.
send
(
DeleteLayerGroup
(
id
)
)
}
fn
set_render_state
(
&
self
render_state
:
RenderState
)
{
self
.
chan
.
send
(
ChangeRenderState
(
render_state
)
)
}
}
impl
CompositorChan
{
pub
fn
new
(
)
-
>
(
Receiver
<
Msg
>
CompositorChan
)
{
let
(
chan
port
)
=
channel
(
)
;
let
compositor_chan
=
CompositorChan
{
chan
:
chan
}
;
(
port
compositor_chan
)
}
pub
fn
send
(
&
self
msg
:
Msg
)
{
self
.
chan
.
send
(
msg
)
;
}
}
pub
enum
Msg
{
Exit
(
Sender
<
(
)
>
)
ShutdownComplete
GetGraphicsMetadata
(
Sender
<
Option
<
NativeGraphicsMetadata
>
>
)
CreateRootCompositorLayerIfNecessary
(
PipelineId
LayerId
Size2D
<
f32
>
Color
)
CreateDescendantCompositorLayerIfNecessary
(
PipelineId
LayerId
Rect
<
f32
>
ScrollPolicy
)
SetLayerPageSize
(
PipelineId
LayerId
Size2D
<
f32
>
Epoch
)
SetLayerClipRect
(
PipelineId
LayerId
Rect
<
f32
>
)
DeleteLayerGroup
(
PipelineId
)
ScrollFragmentPoint
(
PipelineId
LayerId
Point2D
<
f32
>
)
Paint
(
PipelineId
LayerId
Box
<
LayerBufferSet
>
Epoch
)
ChangeReadyState
(
ReadyState
)
ChangeRenderState
(
RenderState
)
SetIds
(
SendableFrameTree
Sender
<
(
)
>
ConstellationChan
)
SetUnRenderedColor
(
PipelineId
LayerId
Color
)
LoadComplete
(
PipelineId
Url
)
}
pub
enum
CompositorMode
{
Windowed
(
Application
)
Headless
}
pub
struct
CompositorTask
{
pub
mode
:
CompositorMode
}
impl
CompositorTask
{
fn
new
(
is_headless
:
bool
)
-
>
CompositorTask
{
let
mode
:
CompositorMode
=
if
is_headless
{
Headless
}
else
{
Windowed
(
ApplicationMethods
:
:
new
(
)
)
}
;
CompositorTask
{
mode
:
mode
}
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
create_graphics_context
(
)
-
>
NativeCompositingGraphicsContext
{
NativeCompositingGraphicsContext
:
:
from_display
(
azure_hl
:
:
current_display
(
)
)
}
#
[
cfg
(
not
(
target_os
=
"
linux
"
)
)
]
fn
create_graphics_context
(
)
-
>
NativeCompositingGraphicsContext
{
NativeCompositingGraphicsContext
:
:
new
(
)
}
pub
fn
create
(
opts
:
Opts
port
:
Receiver
<
Msg
>
constellation_chan
:
ConstellationChan
profiler_chan
:
ProfilerChan
)
{
let
compositor
=
CompositorTask
:
:
new
(
opts
.
headless
)
;
match
compositor
.
mode
{
Windowed
(
ref
app
)
=
>
{
compositor
:
:
IOCompositor
:
:
create
(
app
opts
port
constellation_chan
.
clone
(
)
profiler_chan
)
}
Headless
=
>
{
headless
:
:
NullCompositor
:
:
create
(
port
constellation_chan
.
clone
(
)
profiler_chan
)
}
}
;
}
}
