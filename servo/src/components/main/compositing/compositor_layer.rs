use
compositing
:
:
quadtree
:
:
{
Quadtree
Normal
Hidden
}
;
use
pipeline
:
:
CompositionPipeline
;
use
windowing
:
:
{
MouseWindowEvent
MouseWindowClickEvent
MouseWindowMouseDownEvent
}
;
use
windowing
:
:
{
MouseWindowMouseUpEvent
}
;
use
azure
:
:
azure_hl
:
:
Color
;
use
geom
:
:
length
:
:
Length
;
use
geom
:
:
matrix
:
:
identity
;
use
geom
:
:
point
:
:
{
Point2D
TypedPoint2D
}
;
use
geom
:
:
rect
:
:
{
Rect
TypedRect
}
;
use
geom
:
:
size
:
:
{
Size2D
TypedSize2D
}
;
use
gfx
:
:
render_task
:
:
{
ReRenderMsg
UnusedBufferMsg
}
;
use
gfx
;
use
layers
:
:
layers
:
:
{
ContainerLayerKind
ContainerLayer
Flip
NoFlip
TextureLayer
}
;
use
layers
:
:
layers
:
:
TextureLayerKind
;
use
layers
:
:
platform
:
:
surface
:
:
{
NativeCompositingGraphicsContext
NativeSurfaceMethods
}
;
use
layers
:
:
texturegl
:
:
{
Texture
TextureTarget
}
;
use
script
:
:
dom
:
:
event
:
:
{
ClickEvent
MouseDownEvent
MouseMoveEvent
MouseUpEvent
}
;
use
script
:
:
script_task
:
:
{
ScriptChan
SendEventMsg
}
;
use
servo_msg
:
:
compositor_msg
:
:
{
Epoch
FixedPosition
LayerBuffer
LayerBufferSet
LayerId
}
;
use
servo_msg
:
:
compositor_msg
:
:
{
ScrollPolicy
Tile
}
;
use
servo_msg
:
:
constellation_msg
:
:
PipelineId
;
use
servo_util
:
:
geometry
:
:
PagePx
;
use
std
:
:
rc
:
:
Rc
;
#
[
cfg
(
target_os
=
"
macos
"
)
]
#
[
cfg
(
target_os
=
"
android
"
)
]
use
layers
:
:
layers
:
:
VerticalFlip
;
#
[
cfg
(
not
(
target_os
=
"
macos
"
)
)
]
use
layers
:
:
texturegl
:
:
TextureTarget2D
;
#
[
cfg
(
target_os
=
"
macos
"
)
]
use
layers
:
:
texturegl
:
:
TextureTargetRectangle
;
static
MAX_TILE_MEMORY_PER_LAYER
:
uint
=
10000000
;
pub
struct
CompositorLayer
{
pub
pipeline
:
CompositionPipeline
pub
id
:
LayerId
pub
bounds
:
Rect
<
f32
>
pub
page_size
:
Option
<
Size2D
<
f32
>
>
pub
scroll_offset
:
TypedPoint2D
<
PagePx
f32
>
pub
children
:
Vec
<
CompositorLayerChild
>
pub
quadtree
:
MaybeQuadtree
pub
root_layer
:
Rc
<
ContainerLayer
>
pub
hidden
:
bool
pub
epoch
:
Epoch
pub
wants_scroll_events
:
WantsScrollEventsFlag
pub
scroll_policy
:
ScrollPolicy
pub
cpu_painting
:
bool
pub
unrendered_color
:
Color
}
pub
struct
CompositorLayerChild
{
pub
child
:
Box
<
CompositorLayer
>
pub
container
:
Rc
<
ContainerLayer
>
}
enum
MaybeQuadtree
{
Tree
(
Quadtree
<
Box
<
LayerBuffer
>
>
)
NoTree
(
uint
Option
<
uint
>
)
}
impl
MaybeQuadtree
{
fn
tile_size
(
&
self
)
-
>
uint
{
match
*
self
{
Tree
(
ref
quadtree
)
=
>
quadtree
.
max_tile_size
NoTree
(
tile_size
_
)
=
>
tile_size
}
}
}
#
[
deriving
(
PartialEq
Clone
)
]
pub
enum
WantsScrollEventsFlag
{
WantsScrollEvents
DoesntWantScrollEvents
}
fn
create_container_layer_from_rect
(
rect
:
Rect
<
f32
>
)
-
>
Rc
<
ContainerLayer
>
{
let
container
=
Rc
:
:
new
(
ContainerLayer
(
)
)
;
*
container
.
scissor
.
borrow_mut
(
)
=
Some
(
rect
)
;
container
.
common
.
borrow_mut
(
)
.
transform
=
identity
(
)
.
translate
(
rect
.
origin
.
x
rect
.
origin
.
y
0f32
)
;
container
}
trait
Clampable
{
fn
clamp
(
&
self
mn
:
&
Self
mx
:
&
Self
)
-
>
Self
;
}
impl
Clampable
for
f32
{
#
[
inline
]
fn
clamp
(
&
self
mn
:
&
f32
mx
:
&
f32
)
-
>
f32
{
match
(
)
{
_
if
self
.
is_nan
(
)
=
>
*
self
_
if
!
(
*
self
<
=
*
mx
)
=
>
*
mx
_
if
!
(
*
self
>
=
*
mn
)
=
>
*
mn
_
=
>
*
self
}
}
}
impl
CompositorLayer
{
fn
new
(
pipeline
:
CompositionPipeline
layer_id
:
LayerId
bounds
:
Rect
<
f32
>
page_size
:
Option
<
Size2D
<
f32
>
>
tile_size
:
uint
cpu_painting
:
bool
wants_scroll_events
:
WantsScrollEventsFlag
scroll_policy
:
ScrollPolicy
)
-
>
CompositorLayer
{
CompositorLayer
{
pipeline
:
pipeline
id
:
layer_id
bounds
:
bounds
page_size
:
page_size
scroll_offset
:
TypedPoint2D
(
0f32
0f32
)
children
:
vec
!
(
)
quadtree
:
match
page_size
{
None
=
>
NoTree
(
tile_size
Some
(
MAX_TILE_MEMORY_PER_LAYER
)
)
Some
(
page_size
)
=
>
{
Tree
(
Quadtree
:
:
new
(
Size2D
(
page_size
.
width
as
uint
page_size
.
height
as
uint
)
tile_size
Some
(
MAX_TILE_MEMORY_PER_LAYER
)
)
)
}
}
root_layer
:
Rc
:
:
new
(
ContainerLayer
(
)
)
hidden
:
true
epoch
:
Epoch
(
0
)
wants_scroll_events
:
wants_scroll_events
scroll_policy
:
scroll_policy
cpu_painting
:
cpu_painting
unrendered_color
:
gfx
:
:
color
:
:
rgba
(
0
.
0
0
.
0
0
.
0
0
.
0
)
}
}
pub
fn
new_root
(
pipeline
:
CompositionPipeline
page_size
:
Size2D
<
f32
>
tile_size
:
uint
cpu_painting
:
bool
)
-
>
CompositorLayer
{
CompositorLayer
{
pipeline
:
pipeline
id
:
LayerId
:
:
null
(
)
bounds
:
Rect
(
Point2D
(
0f32
0f32
)
page_size
)
page_size
:
Some
(
page_size
)
scroll_offset
:
TypedPoint2D
(
0f32
0f32
)
children
:
vec
!
(
)
quadtree
:
NoTree
(
tile_size
Some
(
MAX_TILE_MEMORY_PER_LAYER
)
)
root_layer
:
Rc
:
:
new
(
ContainerLayer
(
)
)
hidden
:
false
epoch
:
Epoch
(
0
)
wants_scroll_events
:
WantsScrollEvents
scroll_policy
:
FixedPosition
cpu_painting
:
cpu_painting
unrendered_color
:
gfx
:
:
color
:
:
rgba
(
0
.
0
0
.
0
0
.
0
0
.
0
)
}
}
pub
fn
add_child_if_necessary
(
&
mut
self
container_layer
:
Rc
<
ContainerLayer
>
pipeline_id
:
PipelineId
parent_layer_id
:
LayerId
child_layer_id
:
LayerId
rect
:
Rect
<
f32
>
page_size
:
Size2D
<
f32
>
scroll_policy
:
ScrollPolicy
)
-
>
bool
{
if
self
.
pipeline
.
id
!
=
pipeline_id
|
|
self
.
id
!
=
parent_layer_id
{
return
self
.
children
.
mut_iter
(
)
.
any
(
|
kid_holder
|
{
kid_holder
.
child
.
add_child_if_necessary
(
kid_holder
.
container
.
clone
(
)
pipeline_id
parent_layer_id
child_layer_id
rect
page_size
scroll_policy
)
}
)
}
if
self
.
children
.
iter
(
)
.
any
(
|
kid_holder
|
{
kid_holder
.
child
.
pipeline
.
id
=
=
pipeline_id
&
&
kid_holder
.
child
.
id
=
=
child_layer_id
}
)
{
return
true
}
let
mut
kid
=
box
CompositorLayer
:
:
new
(
self
.
pipeline
.
clone
(
)
child_layer_id
rect
Some
(
page_size
)
self
.
quadtree
.
tile_size
(
)
self
.
cpu_painting
DoesntWantScrollEvents
scroll_policy
)
;
kid
.
hidden
=
false
;
let
kid_container
=
create_container_layer_from_rect
(
rect
)
;
ContainerLayer
:
:
add_child_start
(
kid_container
.
clone
(
)
ContainerLayerKind
(
kid
.
root_layer
.
clone
(
)
)
)
;
ContainerLayer
:
:
add_child_end
(
container_layer
ContainerLayerKind
(
kid_container
.
clone
(
)
)
)
;
self
.
children
.
push
(
CompositorLayerChild
{
child
:
kid
container
:
kid_container
}
)
;
true
}
pub
fn
handle_scroll_event
(
&
mut
self
delta
:
TypedPoint2D
<
PagePx
f32
>
cursor
:
TypedPoint2D
<
PagePx
f32
>
window_size
:
TypedSize2D
<
PagePx
f32
>
)
-
>
bool
{
if
self
.
hidden
{
return
false
}
if
self
.
wants_scroll_events
!
=
WantsScrollEvents
{
return
false
}
let
cursor
=
cursor
-
self
.
scroll_offset
;
for
child
in
self
.
children
.
mut_iter
(
)
{
match
*
child
.
container
.
scissor
.
borrow
(
)
{
None
=
>
{
error
!
(
"
CompositorLayer
:
unable
to
perform
cursor
hit
test
for
layer
"
)
;
}
Some
(
rect
)
=
>
{
let
rect
:
TypedRect
<
PagePx
f32
>
=
Rect
:
:
from_untyped
(
&
rect
)
;
if
cursor
.
x
>
=
rect
.
origin
.
x
&
&
cursor
.
x
<
rect
.
origin
.
x
+
rect
.
size
.
width
&
&
cursor
.
y
>
=
rect
.
origin
.
y
&
&
cursor
.
y
<
rect
.
origin
.
y
+
rect
.
size
.
height
&
&
child
.
child
.
handle_scroll_event
(
delta
cursor
-
rect
.
origin
rect
.
size
)
{
return
true
}
}
}
}
let
old_origin
=
self
.
scroll_offset
;
self
.
scroll_offset
=
self
.
scroll_offset
+
delta
;
let
page_size
=
match
self
.
page_size
{
Some
(
size
)
=
>
size
None
=
>
fail
!
(
"
CompositorLayer
:
tried
to
scroll
with
no
page
size
set
"
)
}
;
let
window_size
=
window_size
.
to_untyped
(
)
;
let
scroll_offset
=
self
.
scroll_offset
.
to_untyped
(
)
;
let
min_x
=
(
window_size
.
width
-
page_size
.
width
)
.
min
(
0
.
0
)
;
self
.
scroll_offset
.
x
=
Length
(
scroll_offset
.
x
.
clamp
(
&
min_x
&
0
.
0
)
)
;
let
min_y
=
(
window_size
.
height
-
page_size
.
height
)
.
min
(
0
.
0
)
;
self
.
scroll_offset
.
y
=
Length
(
scroll_offset
.
y
.
clamp
(
&
min_y
&
0
.
0
)
)
;
if
old_origin
-
self
.
scroll_offset
=
=
TypedPoint2D
(
0f32
0f32
)
{
return
false
}
let
offset
=
self
.
scroll_offset
;
self
.
scroll
(
offset
)
}
#
[
allow
(
dead_code
)
]
fn
dump_layer_tree
(
&
self
layer
:
Rc
<
ContainerLayer
>
indent
:
String
)
{
println
!
(
"
{
}
scissor
{
:
?
}
"
indent
layer
.
scissor
.
borrow
(
)
)
;
for
kid
in
layer
.
children
(
)
{
match
kid
{
ContainerLayerKind
(
ref
container_layer
)
=
>
{
self
.
dump_layer_tree
(
(
*
container_layer
)
.
clone
(
)
format
!
(
"
{
}
"
indent
)
)
;
}
TextureLayerKind
(
_
)
=
>
{
println
!
(
"
{
}
(
texture
layer
)
"
indent
)
;
}
}
}
}
fn
scroll
(
&
mut
self
scroll_offset
:
TypedPoint2D
<
PagePx
f32
>
)
-
>
bool
{
let
mut
result
=
false
;
if
self
.
scroll_policy
!
=
FixedPosition
{
self
.
scroll_offset
=
scroll_offset
;
self
.
root_layer
.
common
.
borrow_mut
(
)
.
set_transform
(
identity
(
)
.
translate
(
self
.
scroll_offset
.
x
.
get
(
)
self
.
scroll_offset
.
y
.
get
(
)
0
.
0
)
)
;
result
=
true
}
for
kid_holder
in
self
.
children
.
mut_iter
(
)
{
result
=
kid_holder
.
child
.
scroll
(
scroll_offset
)
|
|
result
;
}
result
}
pub
fn
send_mouse_event
(
&
self
event
:
MouseWindowEvent
cursor
:
TypedPoint2D
<
PagePx
f32
>
)
{
let
cursor
=
cursor
-
self
.
scroll_offset
;
for
child
in
self
.
children
.
iter
(
)
.
filter
(
|
&
x
|
!
x
.
child
.
hidden
)
{
match
*
child
.
container
.
scissor
.
borrow
(
)
{
None
=
>
{
error
!
(
"
CompositorLayer
:
unable
to
perform
cursor
hit
test
for
layer
"
)
;
}
Some
(
rect
)
=
>
{
let
rect
:
TypedRect
<
PagePx
f32
>
=
Rect
:
:
from_untyped
(
&
rect
)
;
if
cursor
.
x
>
=
rect
.
origin
.
x
&
&
cursor
.
x
<
rect
.
origin
.
x
+
rect
.
size
.
width
&
&
cursor
.
y
>
=
rect
.
origin
.
y
&
&
cursor
.
y
<
rect
.
origin
.
y
+
rect
.
size
.
height
{
child
.
child
.
send_mouse_event
(
event
cursor
-
rect
.
origin
)
;
return
;
}
}
}
}
let
message
=
match
event
{
MouseWindowClickEvent
(
button
_
)
=
>
ClickEvent
(
button
cursor
.
to_untyped
(
)
)
MouseWindowMouseDownEvent
(
button
_
)
=
>
MouseDownEvent
(
button
cursor
.
to_untyped
(
)
)
MouseWindowMouseUpEvent
(
button
_
)
=
>
MouseUpEvent
(
button
cursor
.
to_untyped
(
)
)
}
;
let
ScriptChan
(
ref
chan
)
=
self
.
pipeline
.
script_chan
;
let
_
=
chan
.
send_opt
(
SendEventMsg
(
self
.
pipeline
.
id
.
clone
(
)
message
)
)
;
}
pub
fn
send_mouse_move_event
(
&
self
cursor
:
TypedPoint2D
<
PagePx
f32
>
)
{
let
message
=
MouseMoveEvent
(
cursor
.
to_untyped
(
)
)
;
let
ScriptChan
(
ref
chan
)
=
self
.
pipeline
.
script_chan
;
let
_
=
chan
.
send_opt
(
SendEventMsg
(
self
.
pipeline
.
id
.
clone
(
)
message
)
)
;
}
pub
fn
get_buffer_request
(
&
mut
self
graphics_context
:
&
NativeCompositingGraphicsContext
window_rect
:
Rect
<
f32
>
scale
:
f32
)
-
>
bool
{
let
mut
redisplay
=
false
;
match
self
.
quadtree
{
NoTree
(
.
.
)
=
>
{
}
Tree
(
ref
mut
quadtree
)
=
>
{
let
(
request
unused
)
=
quadtree
.
get_tile_rects_page
(
window_rect
scale
)
;
redisplay
=
!
unused
.
is_empty
(
)
;
if
redisplay
{
let
_
=
self
.
pipeline
.
render_chan
.
send_opt
(
UnusedBufferMsg
(
unused
)
)
;
}
if
!
request
.
is_empty
(
)
{
let
msg
=
ReRenderMsg
(
request
scale
self
.
id
self
.
epoch
)
;
let
_
=
self
.
pipeline
.
render_chan
.
send_opt
(
msg
)
;
}
}
}
;
if
redisplay
{
self
.
build_layer_tree
(
graphics_context
)
;
}
let
transform
=
|
x
:
&
mut
CompositorLayerChild
|
-
>
bool
{
match
*
x
.
container
.
scissor
.
borrow
(
)
{
Some
(
scissor
)
=
>
{
let
mut
new_rect
=
window_rect
;
let
offset
=
x
.
child
.
scroll_offset
.
to_untyped
(
)
;
new_rect
.
origin
.
x
=
new_rect
.
origin
.
x
-
offset
.
x
;
new_rect
.
origin
.
y
=
new_rect
.
origin
.
y
-
offset
.
y
;
match
new_rect
.
intersection
(
&
scissor
)
{
Some
(
new_rect
)
=
>
{
let
child_rect
=
Rect
(
new_rect
.
origin
.
sub
(
&
scissor
.
origin
)
new_rect
.
size
)
;
x
.
child
.
get_buffer_request
(
graphics_context
child_rect
scale
)
}
None
=
>
{
false
}
}
}
None
=
>
fail
!
(
"
child
layer
not
clipped
!
"
)
}
}
;
self
.
children
.
mut_iter
(
)
.
filter
(
|
x
|
!
x
.
child
.
hidden
)
.
map
(
transform
)
.
fold
(
false
|
a
b
|
a
|
|
b
)
|
|
redisplay
}
pub
fn
set_clipping_rect
(
&
mut
self
pipeline_id
:
PipelineId
layer_id
:
LayerId
new_rect
:
Rect
<
f32
>
)
-
>
bool
{
debug
!
(
"
compositor_layer
:
starting
set_clipping_rect
(
)
"
)
;
match
self
.
children
.
iter
(
)
.
position
(
|
kid_holder
|
{
pipeline_id
=
=
kid_holder
.
child
.
pipeline
.
id
&
&
layer_id
=
=
kid_holder
.
child
.
id
}
)
{
Some
(
i
)
=
>
{
debug
!
(
"
compositor_layer
:
node
found
for
set_clipping_rect
(
)
"
)
;
let
child_node
=
self
.
children
.
get_mut
(
i
)
;
child_node
.
container
.
common
.
borrow_mut
(
)
.
set_transform
(
identity
(
)
.
translate
(
new_rect
.
origin
.
x
new_rect
.
origin
.
y
0
.
0
)
)
;
let
old_rect
=
child_node
.
container
.
scissor
.
borrow
(
)
.
clone
(
)
;
*
child_node
.
container
.
scissor
.
borrow_mut
(
)
=
Some
(
new_rect
)
;
match
self
.
quadtree
{
NoTree
(
.
.
)
=
>
{
}
Tree
(
ref
mut
quadtree
)
=
>
{
match
old_rect
{
Some
(
old_rect
)
=
>
{
quadtree
.
set_status_page
(
old_rect
Normal
false
)
;
}
None
=
>
{
}
}
quadtree
.
set_status_page
(
new_rect
Hidden
false
)
;
}
}
if
child_node
.
child
.
hidden
&
&
child_node
.
child
.
page_size
.
is_some
(
)
{
child_node
.
child
.
hidden
=
false
;
}
true
}
None
=
>
{
self
.
children
.
mut_iter
(
)
.
map
(
|
kid_holder
|
&
mut
kid_holder
.
child
)
.
any
(
|
kid
|
kid
.
set_clipping_rect
(
pipeline_id
layer_id
new_rect
)
)
}
}
}
pub
fn
resize
(
&
mut
self
pipeline_id
:
PipelineId
layer_id
:
LayerId
new_size
:
Size2D
<
f32
>
window_size
:
TypedSize2D
<
PagePx
f32
>
epoch
:
Epoch
)
-
>
bool
{
debug
!
(
"
compositor_layer
:
starting
resize
(
)
"
)
;
if
self
.
pipeline
.
id
!
=
pipeline_id
|
|
self
.
id
!
=
layer_id
{
return
self
.
resize_helper
(
pipeline_id
layer_id
new_size
epoch
)
}
debug
!
(
"
compositor_layer
:
layer
found
for
resize
(
)
"
)
;
self
.
epoch
=
epoch
;
self
.
page_size
=
Some
(
new_size
)
;
match
self
.
quadtree
{
Tree
(
ref
mut
quadtree
)
=
>
{
let
_
=
self
.
pipeline
.
render_chan
.
send_opt
(
UnusedBufferMsg
(
quadtree
.
resize
(
new_size
.
width
as
uint
new_size
.
height
as
uint
)
)
)
;
}
NoTree
(
tile_size
max_mem
)
=
>
{
self
.
quadtree
=
Tree
(
Quadtree
:
:
new
(
Size2D
(
new_size
.
width
as
uint
new_size
.
height
as
uint
)
tile_size
max_mem
)
)
}
}
self
.
handle_scroll_event
(
TypedPoint2D
(
0f32
0f32
)
TypedPoint2D
(
-
1f32
-
1f32
)
window_size
)
;
self
.
hidden
=
false
;
self
.
set_occlusions
(
)
;
true
}
pub
fn
move
(
&
mut
self
pipeline_id
:
PipelineId
layer_id
:
LayerId
origin
:
Point2D
<
f32
>
window_size
:
TypedSize2D
<
PagePx
f32
>
)
-
>
bool
{
if
self
.
pipeline
.
id
!
=
pipeline_id
|
|
self
.
id
!
=
layer_id
{
return
self
.
children
.
mut_iter
(
)
.
any
(
|
kid_holder
|
{
kid_holder
.
child
.
move
(
pipeline_id
layer_id
origin
window_size
)
}
)
}
if
self
.
wants_scroll_events
!
=
WantsScrollEvents
{
return
false
}
let
old_origin
=
self
.
scroll_offset
;
self
.
scroll_offset
=
Point2D
:
:
from_untyped
(
&
(
origin
*
-
1
.
0
)
)
;
let
page_size
=
match
self
.
page_size
{
Some
(
size
)
=
>
size
None
=
>
fail
!
(
"
CompositorLayer
:
tried
to
scroll
with
no
page
size
set
"
)
}
;
let
window_size
=
window_size
.
to_untyped
(
)
;
let
scroll_offset
=
self
.
scroll_offset
.
to_untyped
(
)
;
let
min_x
=
(
window_size
.
width
-
page_size
.
width
)
.
min
(
0
.
0
)
;
self
.
scroll_offset
.
x
=
Length
(
scroll_offset
.
x
.
clamp
(
&
min_x
&
0
.
0
)
)
;
let
min_y
=
(
window_size
.
height
-
page_size
.
height
)
.
min
(
0
.
0
)
;
self
.
scroll_offset
.
y
=
Length
(
scroll_offset
.
y
.
clamp
(
&
min_y
&
0
.
0
)
)
;
if
old_origin
-
self
.
scroll_offset
=
=
TypedPoint2D
(
0f32
0f32
)
{
return
false
;
}
let
offset
=
self
.
scroll_offset
;
self
.
scroll
(
offset
)
}
#
[
cfg
(
target_os
=
"
macos
"
)
]
fn
texture_flip_and_target
(
cpu_painting
:
bool
size
:
Size2D
<
uint
>
)
-
>
(
Flip
TextureTarget
)
{
let
flip
=
if
cpu_painting
{
NoFlip
}
else
{
VerticalFlip
}
;
(
flip
TextureTargetRectangle
(
size
)
)
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
texture_flip_and_target
(
cpu_painting
:
bool
size
:
Size2D
<
uint
>
)
-
>
(
Flip
TextureTarget
)
{
let
flip
=
if
cpu_painting
{
NoFlip
}
else
{
VerticalFlip
}
;
(
flip
TextureTarget2D
)
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
texture_flip_and_target
(
_
:
bool
_
:
Size2D
<
uint
>
)
-
>
(
Flip
TextureTarget
)
{
(
NoFlip
TextureTarget2D
)
}
fn
resize_helper
(
&
mut
self
pipeline_id
:
PipelineId
layer_id
:
LayerId
new_size
:
Size2D
<
f32
>
epoch
:
Epoch
)
-
>
bool
{
debug
!
(
"
compositor_layer
:
starting
resize_helper
(
)
"
)
;
let
found
=
match
self
.
children
.
iter
(
)
.
position
(
|
kid_holder
|
{
pipeline_id
=
=
kid_holder
.
child
.
pipeline
.
id
&
&
layer_id
=
=
kid_holder
.
child
.
id
}
)
{
Some
(
i
)
=
>
{
debug
!
(
"
compositor_layer
:
layer
found
for
resize_helper
(
)
"
)
;
let
child_node
=
self
.
children
.
get_mut
(
i
)
;
let
child
=
&
mut
child_node
.
child
;
child
.
epoch
=
epoch
;
child
.
page_size
=
Some
(
new_size
)
;
match
child
.
quadtree
{
Tree
(
ref
mut
quadtree
)
=
>
{
let
_
=
child
.
pipeline
.
render_chan
.
send_opt
(
UnusedBufferMsg
(
quadtree
.
resize
(
new_size
.
width
as
uint
new_size
.
height
as
uint
)
)
)
;
}
NoTree
(
tile_size
max_mem
)
=
>
{
child
.
quadtree
=
Tree
(
Quadtree
:
:
new
(
Size2D
(
new_size
.
width
as
uint
new_size
.
height
as
uint
)
tile_size
max_mem
)
)
}
}
match
*
child_node
.
container
.
scissor
.
borrow
(
)
{
Some
(
scissor
)
=
>
{
let
size
:
TypedSize2D
<
PagePx
f32
>
=
Size2D
:
:
from_untyped
(
&
scissor
.
size
)
;
child
.
handle_scroll_event
(
TypedPoint2D
(
0f32
0f32
)
TypedPoint2D
(
-
1f32
-
1f32
)
size
)
;
child
.
hidden
=
false
;
}
None
=
>
{
}
}
true
}
None
=
>
false
}
;
if
found
{
self
.
set_occlusions
(
)
;
return
true
}
self
.
children
.
mut_iter
(
)
.
map
(
|
kid_holder
|
&
mut
kid_holder
.
child
)
.
any
(
|
kid_holder
|
kid_holder
.
resize_helper
(
pipeline_id
layer_id
new_size
epoch
)
)
}
pub
fn
build_layer_tree
(
&
mut
self
graphics_context
:
&
NativeCompositingGraphicsContext
)
{
let
mut
current_layer_child
=
self
.
root_layer
.
first_child
.
borrow
(
)
.
clone
(
)
;
while
current_layer_child
.
is_some
(
)
{
let
trash
=
current_layer_child
.
clone
(
)
.
unwrap
(
)
;
current_layer_child
.
clone
(
)
.
unwrap
(
)
.
with_common
(
|
common
|
{
current_layer_child
=
common
.
next_sibling
.
clone
(
)
;
}
)
;
ContainerLayer
:
:
remove_child
(
self
.
root_layer
.
clone
(
)
trash
)
;
}
let
quadtree
=
match
self
.
quadtree
{
NoTree
(
.
.
)
=
>
fail
!
(
"
CompositorLayer
:
cannot
build
layer
tree
for
{
:
?
}
no
quadtree
initialized
"
self
.
pipeline
.
id
)
Tree
(
ref
mut
quadtree
)
=
>
quadtree
}
;
let
all_tiles
=
quadtree
.
get_all_tiles
(
)
;
for
buffer
in
all_tiles
.
iter
(
)
{
debug
!
(
"
osmain
:
compositing
buffer
rect
{
}
"
buffer
.
rect
)
;
let
size
=
Size2D
(
buffer
.
screen_pos
.
size
.
width
as
int
buffer
.
screen_pos
.
size
.
height
as
int
)
;
let
texture_layer
;
current_layer_child
=
match
current_layer_child
.
clone
(
)
{
None
=
>
{
debug
!
(
"
osmain
:
adding
new
texture
layer
"
)
;
let
(
flip
target
)
=
CompositorLayer
:
:
texture_flip_and_target
(
self
.
cpu_painting
buffer
.
screen_pos
.
size
)
;
let
texture
=
Texture
:
:
new
(
target
)
;
debug
!
(
"
COMPOSITOR
binding
to
native
surface
{
:
d
}
"
buffer
.
native_surface
.
get_id
(
)
as
int
)
;
buffer
.
native_surface
.
bind_to_texture
(
graphics_context
&
texture
size
)
;
texture_layer
=
Rc
:
:
new
(
TextureLayer
:
:
new
(
texture
buffer
.
screen_pos
.
size
flip
)
)
;
ContainerLayer
:
:
add_child_end
(
self
.
root_layer
.
clone
(
)
TextureLayerKind
(
texture_layer
.
clone
(
)
)
)
;
None
}
Some
(
TextureLayerKind
(
existing_texture_layer
)
)
=
>
{
texture_layer
=
existing_texture_layer
.
clone
(
)
;
let
texture
=
&
existing_texture_layer
.
texture
;
buffer
.
native_surface
.
bind_to_texture
(
graphics_context
texture
size
)
;
current_layer_child
.
unwrap
(
)
.
with_common
(
|
common
|
{
common
.
next_sibling
.
clone
(
)
}
)
}
Some
(
_
)
=
>
fail
!
(
"
found
unexpected
layer
kind
"
)
}
;
let
rect
=
buffer
.
rect
;
let
transform
=
identity
(
)
.
translate
(
rect
.
origin
.
x
rect
.
origin
.
y
0
.
0
)
;
let
transform
=
transform
.
scale
(
rect
.
size
.
width
rect
.
size
.
height
1
.
0
)
;
texture_layer
.
common
.
borrow_mut
(
)
.
set_transform
(
transform
)
;
}
for
child
in
self
.
children
.
mut_iter
(
)
.
filter
(
|
x
|
!
x
.
child
.
hidden
)
{
current_layer_child
=
match
current_layer_child
{
None
=
>
{
{
let
mut
common
=
child
.
container
.
common
.
borrow_mut
(
)
;
(
*
common
)
.
parent
=
None
;
common
.
prev_sibling
=
None
;
common
.
next_sibling
=
None
;
}
ContainerLayer
:
:
add_child_end
(
self
.
root_layer
.
clone
(
)
ContainerLayerKind
(
child
.
container
.
clone
(
)
)
)
;
None
}
Some
(
_
)
=
>
{
fail
!
(
"
CompositorLayer
:
Layer
tree
failed
to
delete
"
)
;
}
}
;
}
}
pub
fn
add_buffers
(
&
mut
self
graphics_context
:
&
NativeCompositingGraphicsContext
pipeline_id
:
PipelineId
layer_id
:
LayerId
mut
new_buffers
:
Box
<
LayerBufferSet
>
epoch
:
Epoch
)
-
>
Option
<
Box
<
LayerBufferSet
>
>
{
debug
!
(
"
compositor_layer
:
starting
add_buffers
(
)
"
)
;
if
self
.
pipeline
.
id
!
=
pipeline_id
|
|
self
.
id
!
=
layer_id
{
for
child_layer
in
self
.
children
.
mut_iter
(
)
{
match
child_layer
.
child
.
add_buffers
(
graphics_context
pipeline_id
layer_id
new_buffers
epoch
)
{
None
=
>
return
None
Some
(
buffers
)
=
>
new_buffers
=
buffers
}
}
return
Some
(
new_buffers
)
}
debug
!
(
"
compositor_layer
:
layers
found
for
add_buffers
(
)
"
)
;
if
self
.
epoch
!
=
epoch
{
debug
!
(
"
add_buffers
:
compositor
epoch
mismatch
:
{
:
?
}
!
=
{
:
?
}
id
:
{
:
?
}
"
self
.
epoch
epoch
self
.
pipeline
.
id
)
;
let
_
=
self
.
pipeline
.
render_chan
.
send_opt
(
UnusedBufferMsg
(
new_buffers
.
buffers
)
)
;
return
None
}
{
let
quadtree
=
match
self
.
quadtree
{
NoTree
(
.
.
)
=
>
{
fail
!
(
"
CompositorLayer
:
cannot
add
buffers
no
quadtree
initialized
"
)
}
Tree
(
ref
mut
quadtree
)
=
>
quadtree
}
;
let
mut
unused_tiles
=
vec
!
(
)
;
for
buffer
in
new_buffers
.
buffers
.
move_iter
(
)
.
rev
(
)
{
unused_tiles
.
push_all_move
(
quadtree
.
add_tile_pixel
(
buffer
.
screen_pos
.
origin
.
x
buffer
.
screen_pos
.
origin
.
y
buffer
.
resolution
buffer
)
)
;
}
if
!
unused_tiles
.
is_empty
(
)
{
let
_
=
self
.
pipeline
.
render_chan
.
send_opt
(
UnusedBufferMsg
(
unused_tiles
)
)
;
}
}
self
.
build_layer_tree
(
graphics_context
)
;
return
None
}
fn
set_occlusions
(
&
mut
self
)
{
let
quadtree
=
match
self
.
quadtree
{
NoTree
(
.
.
)
=
>
return
Tree
(
ref
mut
quadtree
)
=
>
quadtree
}
;
for
child
in
self
.
children
.
iter
(
)
.
filter
(
|
x
|
!
x
.
child
.
hidden
)
{
match
*
child
.
container
.
scissor
.
borrow
(
)
{
None
=
>
{
}
Some
(
rect
)
=
>
{
quadtree
.
set_status_page
(
rect
Hidden
false
)
;
}
}
}
for
child
in
self
.
children
.
mut_iter
(
)
.
filter
(
|
x
|
!
x
.
child
.
hidden
)
{
child
.
child
.
set_occlusions
(
)
;
}
}
fn
clear
(
&
mut
self
)
{
match
self
.
quadtree
{
NoTree
(
.
.
)
=
>
{
}
Tree
(
ref
mut
quadtree
)
=
>
{
let
mut
tiles
=
quadtree
.
collect_tiles
(
)
;
for
tile
in
tiles
.
mut_iter
(
)
{
tile
.
mark_wont_leak
(
)
}
let
_
=
self
.
pipeline
.
render_chan
.
send_opt
(
UnusedBufferMsg
(
tiles
)
)
;
}
}
}
pub
fn
clear_all_tiles
(
&
mut
self
)
{
self
.
clear
(
)
;
for
kid
in
self
.
children
.
mut_iter
(
)
{
kid
.
child
.
clear_all_tiles
(
)
;
}
}
pub
fn
forget_all_tiles
(
&
mut
self
)
{
match
self
.
quadtree
{
NoTree
(
.
.
)
=
>
{
}
Tree
(
ref
mut
quadtree
)
=
>
{
let
tiles
=
quadtree
.
collect_tiles
(
)
;
for
tile
in
tiles
.
move_iter
(
)
{
let
mut
tile
=
tile
;
tile
.
mark_wont_leak
(
)
}
}
}
for
kid
in
self
.
children
.
mut_iter
(
)
{
kid
.
child
.
forget_all_tiles
(
)
;
}
}
pub
fn
id_of_first_child
(
&
self
)
-
>
LayerId
{
self
.
children
.
iter
(
)
.
next
(
)
.
expect
(
"
no
first
child
!
"
)
.
child
.
id
}
pub
fn
set_unrendered_color
(
&
mut
self
pipeline_id
:
PipelineId
layer_id
:
LayerId
color
:
Color
)
-
>
bool
{
if
self
.
pipeline
.
id
!
=
pipeline_id
|
|
self
.
id
!
=
layer_id
{
for
child_layer
in
self
.
children
.
mut_iter
(
)
{
if
child_layer
.
child
.
set_unrendered_color
(
pipeline_id
layer_id
color
)
{
return
true
;
}
}
return
false
;
}
self
.
unrendered_color
=
color
;
return
true
;
}
}
