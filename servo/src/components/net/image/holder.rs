use
image
:
:
base
:
:
Image
;
use
image_cache_task
:
:
{
ImageReady
ImageNotReady
ImageFailed
}
;
use
local_image_cache
:
:
LocalImageCache
;
use
sync
:
:
{
Arc
MutexArc
}
;
use
extra
:
:
url
:
:
Url
;
use
geom
:
:
size
:
:
Size2D
;
use
std
:
:
mem
;
#
[
deriving
(
Clone
)
]
pub
struct
ImageHolder
{
url
:
Url
image
:
Option
<
Arc
<
~
Image
>
>
cached_size
:
Size2D
<
int
>
local_image_cache
:
MutexArc
<
LocalImageCache
>
}
impl
ImageHolder
{
pub
fn
new
(
url
:
Url
local_image_cache
:
MutexArc
<
LocalImageCache
>
)
-
>
ImageHolder
{
debug
!
(
"
ImageHolder
:
:
new
(
)
{
}
"
url
.
to_str
(
)
)
;
let
holder
=
ImageHolder
{
url
:
url
image
:
None
cached_size
:
Size2D
(
0
0
)
local_image_cache
:
local_image_cache
.
clone
(
)
}
;
/
/
Tell
the
image
cache
we
'
re
going
to
be
interested
in
this
url
/
/
FIXME
:
These
two
messages
must
be
sent
to
prep
an
image
for
use
/
/
but
they
are
intended
to
be
spread
out
in
time
.
Ideally
prefetch
/
/
should
be
done
as
early
as
possible
and
decode
only
once
we
/
/
are
sure
that
the
image
will
be
used
.
holder
.
local_image_cache
.
access
(
|
local_image_cache
|
{
local_image_cache
.
prefetch
(
&
holder
.
url
)
;
local_image_cache
.
decode
(
&
holder
.
url
)
;
}
)
;
holder
}
/
/
/
This
version
doesn
'
t
perform
any
computation
but
may
be
stale
w
.
r
.
t
.
newly
-
available
image
/
/
/
data
that
determines
size
.
/
/
/
/
/
/
The
intent
is
that
the
impure
version
is
used
during
layout
when
dimensions
are
used
for
/
/
/
computing
layout
.
pub
fn
size
(
&
self
)
-
>
Size2D
<
int
>
{
self
.
cached_size
}
/
/
/
Query
and
update
the
current
image
size
.
pub
fn
get_size
(
&
mut
self
)
-
>
Option
<
Size2D
<
int
>
>
{
debug
!
(
"
get_size
(
)
{
}
"
self
.
url
.
to_str
(
)
)
;
self
.
get_image
(
)
.
map
(
|
img
|
{
let
img_ref
=
img
.
get
(
)
;
self
.
cached_size
=
Size2D
(
img_ref
.
width
as
int
img_ref
.
height
as
int
)
;
self
.
cached_size
.
clone
(
)
}
)
}
pub
fn
get_image
(
&
mut
self
)
-
>
Option
<
Arc
<
~
Image
>
>
{
debug
!
(
"
get_image
(
)
{
}
"
self
.
url
.
to_str
(
)
)
;
/
/
If
this
is
the
first
time
we
'
ve
called
this
function
load
/
/
the
image
and
store
it
for
the
future
if
self
.
image
.
is_none
(
)
{
let
port
=
self
.
local_image_cache
.
access
(
|
local_image_cache
|
{
local_image_cache
.
get_image
(
&
self
.
url
)
}
)
;
match
port
.
recv
(
)
{
ImageReady
(
image
)
=
>
{
self
.
image
=
Some
(
image
)
;
}
ImageNotReady
=
>
{
debug
!
(
"
image
not
ready
for
{
:
s
}
"
self
.
url
.
to_str
(
)
)
;
}
ImageFailed
=
>
{
debug
!
(
"
image
decoding
failed
for
{
:
s
}
"
self
.
url
.
to_str
(
)
)
;
}
}
}
let
image
=
mem
:
:
replace
(
&
mut
self
.
image
None
)
;
let
result
=
image
.
clone
(
)
;
mem
:
:
replace
(
&
mut
self
.
image
image
)
;
return
result
;
}
}
