use
std
:
:
net
:
:
url
:
:
Url
;
use
pipes
:
:
{
Port
Chan
stream
}
;
use
image_cache_task
:
:
{
ImageCacheTask
ImageResponseMsg
Prefetch
Decode
GetImage
WaitForImage
}
;
pub
fn
LocalImageCache
(
image_cache_task
:
ImageCacheTask
)
-
>
LocalImageCache
{
LocalImageCache
{
image_cache_task
:
image_cache_task
round_number
:
0
mut
on_image_available
:
None
}
}
pub
struct
LocalImageCache
{
priv
image_cache_task
:
ImageCacheTask
priv
mut
round_number
:
uint
priv
mut
on_image_available
:
Option
<
~
fn
(
ImageResponseMsg
)
>
}
pub
impl
LocalImageCache
{
fn
next_round
(
on_image_available
:
~
fn
(
ImageResponseMsg
)
)
{
self
.
round_number
+
=
1
;
self
.
on_image_available
=
Some
(
move
on_image_available
)
;
}
fn
prefetch
(
url
:
&
Url
)
{
self
.
image_cache_task
.
send
(
Prefetch
(
copy
*
url
)
)
;
}
fn
decode
(
url
:
&
Url
)
{
self
.
image_cache_task
.
send
(
Decode
(
copy
*
url
)
)
;
}
fn
get_image
(
url
:
&
Url
)
-
>
Port
<
ImageResponseMsg
>
{
let
(
response_chan
response_port
)
=
pipes
:
:
stream
(
)
;
self
.
image_cache_task
.
send
(
image_cache_task
:
:
GetImage
(
copy
*
url
response_chan
)
)
;
let
response
=
response_port
.
recv
(
)
;
match
response
{
image_cache_task
:
:
ImageNotReady
=
>
{
let
image_cache_task
=
self
.
image_cache_task
.
clone
(
)
;
assert
self
.
on_image_available
.
is_some
(
)
;
let
on_image_available
=
{
copy
*
self
.
on_image_available
.
get_ref
(
)
}
;
let
url
=
copy
*
url
;
do
task
:
:
spawn
|
move
url
move
on_image_available
|
{
let
(
response_chan
response_port
)
=
pipes
:
:
stream
(
)
;
image_cache_task
.
send
(
image_cache_task
:
:
WaitForImage
(
copy
url
response_chan
)
)
;
on_image_available
(
response_port
.
recv
(
)
)
;
}
}
_
=
>
(
)
}
let
(
chan
port
)
=
pipes
:
:
stream
(
)
;
chan
.
send
(
response
)
;
return
port
;
}
}
