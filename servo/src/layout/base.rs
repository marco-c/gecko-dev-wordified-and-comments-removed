import
dom
:
:
rcu
;
import
dom
:
:
rcu
:
:
methods
;
import
util
:
:
{
tree
geom
}
;
import
geom
:
:
{
size
rect
point
au
}
;
enum
box
=
{
tree
:
tree
:
:
fields
<
box
>
node
:
node
mut
bounds
:
geom
:
:
rect
<
au
>
}
;
enum
node_data
=
{
tree
:
tree
:
:
fields
<
node
>
kind
:
node_kind
mut
linfo
:
option
<
box
>
}
;
enum
node_kind
{
nk_div
nk_img
(
size
<
au
>
)
}
type
node
=
rcu
:
:
handle
<
node_data
>
;
impl
of
tree
:
:
tree
for
box
{
fn
tree_fields
(
)
-
>
tree
:
:
fields
<
box
>
{
ret
self
.
tree
;
}
}
impl
of
tree
:
:
tree
for
node
{
fn
tree_fields
(
)
-
>
tree
:
:
fields
<
node
>
{
ret
self
.
get
(
)
.
tree
;
}
}
fn
new_node
(
+
k
:
node_kind
)
-
>
node
{
rcu
:
:
handle
(
node_data
(
{
tree
:
tree
:
:
empty
(
)
kind
:
k
mut
linfo
:
none
}
)
)
}
fn
new_box
(
n
:
node
)
-
>
box
{
box
(
{
tree
:
tree
:
:
empty
(
)
node
:
n
mut
bounds
:
geom
:
:
zero_rect_au
(
)
}
)
}
fn
reflow_block
(
root
:
box
available_width
:
au
)
{
alt
root
.
node
.
get
(
)
.
kind
{
nk_img
(
size
)
{
root
.
bounds
.
size
=
size
;
ret
;
}
nk_div
{
}
}
let
mut
current_height
=
0
;
for
tree
:
:
each_child
(
root
)
{
|
c
|
let
mut
blk_available_width
=
available_width
;
c
.
bounds
.
origin
=
{
x
:
au
(
0
)
y
:
au
(
current_height
)
}
;
reflow_block
(
c
blk_available_width
)
;
current_height
+
=
*
c
.
bounds
.
size
.
height
;
}
root
.
bounds
.
size
=
{
width
:
available_width
height
:
au
(
current_height
)
}
;
}
