use
clone_arc
=
std
:
:
arc
:
:
clone
;
use
std
:
:
net
:
:
url
:
:
Url
;
use
pipes
:
:
{
Port
Chan
stream
}
;
use
resource
:
:
image_cache_task
:
:
{
ImageCacheTask
ImageResponseMsg
Prefetch
Decode
GetImage
}
;
use
resource
:
:
image_cache_task
:
:
{
WaitForImage
ImageReady
ImageNotReady
ImageFailed
}
;
use
util
:
:
url
:
:
{
UrlMap
url_map
}
;
pub
fn
LocalImageCache
(
image_cache_task
:
ImageCacheTask
)
-
>
LocalImageCache
{
LocalImageCache
{
image_cache_task
:
image_cache_task
round_number
:
1
mut
on_image_available
:
None
state_map
:
url_map
(
)
}
}
pub
struct
LocalImageCache
{
priv
image_cache_task
:
ImageCacheTask
priv
mut
round_number
:
uint
priv
mut
on_image_available
:
Option
<
fn
(
)
-
>
~
fn
(
ImageResponseMsg
)
>
priv
state_map
:
UrlMap
<
ImageState
>
}
priv
struct
ImageState
{
mut
prefetched
:
bool
mut
decoded
:
bool
mut
last_request_round
:
uint
mut
last_response
:
ImageResponseMsg
}
#
[
allow
(
non_implicitly_copyable_typarams
)
]
pub
impl
LocalImageCache
{
fn
next_round
(
on_image_available
:
fn
(
)
-
>
~
fn
(
ImageResponseMsg
)
)
{
self
.
round_number
+
=
1
;
self
.
on_image_available
=
Some
(
on_image_available
)
;
}
pub
fn
prefetch
(
url
:
&
Url
)
{
let
state
=
self
.
get_state
(
url
)
;
if
!
state
.
prefetched
{
self
.
image_cache_task
.
send
(
Prefetch
(
copy
*
url
)
)
;
state
.
prefetched
=
true
;
}
}
pub
fn
decode
(
url
:
&
Url
)
{
let
state
=
self
.
get_state
(
url
)
;
if
!
state
.
decoded
{
self
.
image_cache_task
.
send
(
Decode
(
copy
*
url
)
)
;
state
.
decoded
=
true
;
}
}
pub
fn
get_image
(
url
:
&
Url
)
-
>
Port
<
ImageResponseMsg
>
{
let
state
=
self
.
get_state
(
url
)
;
let
last_round
=
state
.
last_request_round
;
state
.
last_request_round
=
self
.
round_number
;
match
state
.
last_response
{
ImageReady
(
ref
image
)
=
>
{
unsafe
{
let
(
port
chan
)
=
pipes
:
:
stream
(
)
;
chan
.
send
(
ImageReady
(
clone_arc
(
image
)
)
)
;
return
port
;
}
}
ImageNotReady
=
>
{
if
last_round
=
=
self
.
round_number
{
let
(
port
chan
)
=
pipes
:
:
stream
(
)
;
chan
.
send
(
ImageNotReady
)
;
return
port
;
}
else
{
}
}
ImageFailed
=
>
{
let
(
port
chan
)
=
pipes
:
:
stream
(
)
;
chan
.
send
(
ImageFailed
)
;
return
port
;
}
}
let
(
response_port
response_chan
)
=
pipes
:
:
stream
(
)
;
self
.
image_cache_task
.
send
(
GetImage
(
copy
*
url
response_chan
)
)
;
let
response
=
response_port
.
recv
(
)
;
match
response
{
ImageNotReady
=
>
{
let
image_cache_task
=
self
.
image_cache_task
.
clone
(
)
;
assert
self
.
on_image_available
.
is_some
(
)
;
let
on_image_available
=
self
.
on_image_available
.
get
(
)
(
)
;
let
url
=
copy
*
url
;
do
task
:
:
spawn
{
let
(
response_port
response_chan
)
=
pipes
:
:
stream
(
)
;
image_cache_task
.
send
(
WaitForImage
(
copy
url
response_chan
)
)
;
on_image_available
(
response_port
.
recv
(
)
)
;
}
}
_
=
>
(
)
}
let
response_copy
=
match
response
{
ImageReady
(
ref
image
)
=
>
ImageReady
(
clone_arc
(
image
)
)
ImageNotReady
=
>
ImageNotReady
ImageFailed
=
>
ImageFailed
}
;
state
.
last_response
=
response_copy
;
let
(
port
chan
)
=
pipes
:
:
stream
(
)
;
chan
.
send
(
response
)
;
return
port
;
}
priv
fn
get_state
(
url
:
&
Url
)
-
>
ImageState
{
match
self
.
state_map
.
find
(
url
)
{
Some
(
state
)
=
>
state
None
=
>
{
let
new_state
=
ImageState
{
prefetched
:
false
decoded
:
false
last_request_round
:
0
last_response
:
ImageNotReady
}
;
self
.
state_map
.
insert
(
copy
*
url
new_state
)
;
self
.
get_state
(
url
)
}
}
}
}
