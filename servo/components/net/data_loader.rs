use
net_traits
:
:
{
LoadData
Metadata
ResponseSenders
}
;
use
net_traits
:
:
ProgressMsg
:
:
{
Payload
Done
}
;
use
mime_classifier
:
:
MIMEClassifier
;
use
resource_task
:
:
start_sending
;
use
rustc_serialize
:
:
base64
:
:
FromBase64
;
use
hyper
:
:
mime
:
:
Mime
;
use
std
:
:
sync
:
:
Arc
;
use
url
:
:
{
percent_decode
SchemeData
}
;
pub
fn
factory
(
load_data
:
LoadData
senders
:
ResponseSenders
_classifier
:
Arc
<
MIMEClassifier
>
)
{
load
(
load_data
senders
)
}
pub
fn
load
(
load_data
:
LoadData
start_chan
:
ResponseSenders
)
{
let
url
=
load_data
.
url
;
assert
!
(
&
*
url
.
scheme
=
=
"
data
"
)
;
let
mut
metadata
=
Metadata
:
:
default
(
url
.
clone
(
)
)
;
let
mut
scheme_data
=
match
url
.
scheme_data
{
SchemeData
:
:
NonRelative
(
scheme_data
)
=
>
scheme_data
_
=
>
panic
!
(
"
Expected
a
non
-
relative
scheme
URL
.
"
)
}
;
match
url
.
query
{
Some
(
query
)
=
>
{
scheme_data
.
push_str
(
"
?
"
)
;
scheme_data
.
push_str
(
&
query
)
;
}
None
=
>
(
)
}
let
parts
:
Vec
<
&
str
>
=
scheme_data
.
splitn
(
1
'
'
)
.
collect
(
)
;
if
parts
.
len
(
)
!
=
2
{
start_sending
(
start_chan
metadata
)
.
send
(
Done
(
Err
(
"
invalid
data
uri
"
.
to_string
(
)
)
)
)
.
unwrap
(
)
;
return
;
}
let
mut
is_base64
=
false
;
let
mut
ct_str
=
parts
[
0
]
;
if
ct_str
.
ends_with
(
"
;
base64
"
)
{
is_base64
=
true
;
ct_str
=
&
ct_str
[
.
.
ct_str
.
as_bytes
(
)
.
len
(
)
-
7
]
;
}
let
content_type
:
Option
<
Mime
>
=
ct_str
.
parse
(
)
.
ok
(
)
;
metadata
.
set_content_type
(
content_type
.
as_ref
(
)
)
;
let
progress_chan
=
start_sending
(
start_chan
metadata
)
;
let
bytes
=
percent_decode
(
parts
[
1
]
.
as_bytes
(
)
)
;
if
is_base64
{
let
bytes
=
bytes
.
into_iter
(
)
.
filter
(
|
&
b
|
b
!
=
'
'
as
u8
)
.
collect
:
:
<
Vec
<
u8
>
>
(
)
;
match
bytes
.
from_base64
(
)
{
Err
(
.
.
)
=
>
{
progress_chan
.
send
(
Done
(
Err
(
"
non
-
base64
data
uri
"
.
to_string
(
)
)
)
)
.
unwrap
(
)
;
}
Ok
(
data
)
=
>
{
progress_chan
.
send
(
Payload
(
data
)
)
.
unwrap
(
)
;
progress_chan
.
send
(
Done
(
Ok
(
(
)
)
)
)
.
unwrap
(
)
;
}
}
}
else
{
progress_chan
.
send
(
Payload
(
bytes
)
)
.
unwrap
(
)
;
progress_chan
.
send
(
Done
(
Ok
(
(
)
)
)
)
.
unwrap
(
)
;
}
}
