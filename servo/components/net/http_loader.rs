use
brotli
:
:
Decompressor
;
use
connector
:
:
{
Connector
create_http_connector
}
;
use
cookie
;
use
cookie_storage
:
:
CookieStorage
;
use
devtools_traits
:
:
{
ChromeToDevtoolsControlMsg
DevtoolsControlMsg
HttpRequest
as
DevtoolsHttpRequest
}
;
use
devtools_traits
:
:
{
HttpResponse
as
DevtoolsHttpResponse
NetworkEvent
}
;
use
fetch
:
:
cors_cache
:
:
CorsCache
;
use
fetch
:
:
methods
:
:
{
Data
DoneChannel
FetchContext
Target
}
;
use
fetch
:
:
methods
:
:
{
is_cors_safelisted_request_header
is_cors_safelisted_method
main_fetch
}
;
use
flate2
:
:
read
:
:
{
DeflateDecoder
GzDecoder
}
;
use
hsts
:
:
HstsList
;
use
http_cache
:
:
HttpCache
;
use
hyper
:
:
Error
as
HttpError
;
use
hyper
:
:
LanguageTag
;
use
hyper
:
:
client
:
:
{
Pool
Request
as
HyperRequest
Response
as
HyperResponse
}
;
use
hyper
:
:
header
:
:
{
Accept
AccessControlAllowCredentials
AccessControlAllowHeaders
}
;
use
hyper
:
:
header
:
:
{
AccessControlAllowMethods
AccessControlAllowOrigin
}
;
use
hyper
:
:
header
:
:
{
AccessControlMaxAge
AccessControlRequestHeaders
}
;
use
hyper
:
:
header
:
:
{
AccessControlRequestMethod
AcceptEncoding
AcceptLanguage
}
;
use
hyper
:
:
header
:
:
{
Authorization
Basic
CacheControl
CacheDirective
}
;
use
hyper
:
:
header
:
:
{
ContentEncoding
ContentLength
Encoding
Header
Headers
}
;
use
hyper
:
:
header
:
:
{
Host
HttpDate
Origin
as
HyperOrigin
IfMatch
IfRange
}
;
use
hyper
:
:
header
:
:
{
IfUnmodifiedSince
IfModifiedSince
IfNoneMatch
Location
}
;
use
hyper
:
:
header
:
:
{
Pragma
Quality
QualityItem
Referer
SetCookie
}
;
use
hyper
:
:
header
:
:
{
UserAgent
q
qitem
}
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
status
:
:
StatusCode
;
use
hyper_openssl
:
:
OpensslClient
;
use
hyper_serde
:
:
Serde
;
use
log
;
use
msg
:
:
constellation_msg
:
:
PipelineId
;
use
net_traits
:
:
{
CookieSource
FetchMetadata
NetworkError
ReferrerPolicy
}
;
use
net_traits
:
:
request
:
:
{
CacheMode
CredentialsMode
Destination
Origin
}
;
use
net_traits
:
:
request
:
:
{
RedirectMode
Referrer
Request
RequestMode
}
;
use
net_traits
:
:
request
:
:
{
ResponseTainting
ServiceWorkersMode
}
;
use
net_traits
:
:
response
:
:
{
HttpsState
Response
ResponseBody
ResponseType
}
;
use
resource_thread
:
:
AuthCache
;
use
servo_url
:
:
{
ImmutableOrigin
ServoUrl
}
;
use
std
:
:
collections
:
:
HashSet
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
io
:
:
{
self
Read
Write
}
;
use
std
:
:
iter
:
:
FromIterator
;
use
std
:
:
mem
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
str
:
:
FromStr
;
use
std
:
:
sync
:
:
RwLock
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Sender
}
;
use
std
:
:
thread
;
use
time
;
use
time
:
:
Tm
;
use
unicase
:
:
UniCase
;
use
uuid
;
fn
read_block
<
R
:
Read
>
(
reader
:
&
mut
R
)
-
>
Result
<
Data
(
)
>
{
let
mut
buf
=
vec
!
[
0
;
32768
]
;
match
reader
.
read
(
&
mut
buf
)
{
Ok
(
len
)
if
len
>
0
=
>
{
buf
.
truncate
(
len
)
;
Ok
(
Data
:
:
Payload
(
buf
)
)
}
Ok
(
_
)
=
>
Ok
(
Data
:
:
Done
)
Err
(
_
)
=
>
Err
(
(
)
)
}
}
pub
struct
HttpState
{
pub
hsts_list
:
RwLock
<
HstsList
>
pub
cookie_jar
:
RwLock
<
CookieStorage
>
pub
http_cache
:
RwLock
<
HttpCache
>
pub
auth_cache
:
RwLock
<
AuthCache
>
pub
ssl_client
:
OpensslClient
pub
connector
:
Pool
<
Connector
>
}
impl
HttpState
{
pub
fn
new
(
ssl_client
:
OpensslClient
)
-
>
HttpState
{
HttpState
{
hsts_list
:
RwLock
:
:
new
(
HstsList
:
:
new
(
)
)
cookie_jar
:
RwLock
:
:
new
(
CookieStorage
:
:
new
(
150
)
)
auth_cache
:
RwLock
:
:
new
(
AuthCache
:
:
new
(
)
)
http_cache
:
RwLock
:
:
new
(
HttpCache
:
:
new
(
)
)
ssl_client
:
ssl_client
.
clone
(
)
connector
:
create_http_connector
(
ssl_client
)
}
}
}
fn
precise_time_ms
(
)
-
>
u64
{
time
:
:
precise_time_ns
(
)
/
(
1000
*
1000
)
}
pub
fn
set_default_accept
(
destination
:
Destination
headers
:
&
mut
Headers
)
{
if
headers
.
has
:
:
<
Accept
>
(
)
{
return
;
}
let
value
=
match
destination
{
Destination
:
:
Document
=
>
{
vec
!
[
qitem
(
mime
!
(
Text
/
Html
)
)
qitem
(
mime
!
(
Application
/
(
"
xhtml
+
xml
"
)
)
)
QualityItem
:
:
new
(
mime
!
(
Application
/
Xml
)
q
(
0
.
9
)
)
QualityItem
:
:
new
(
mime
!
(
_
/
_
)
q
(
0
.
8
)
)
]
}
Destination
:
:
Image
=
>
{
vec
!
[
qitem
(
mime
!
(
Image
/
Png
)
)
qitem
(
mime
!
(
Image
/
(
"
svg
+
xml
"
)
)
)
QualityItem
:
:
new
(
mime
!
(
Image
/
_
)
q
(
0
.
8
)
)
QualityItem
:
:
new
(
mime
!
(
_
/
_
)
q
(
0
.
5
)
)
]
}
Destination
:
:
Style
=
>
{
vec
!
[
qitem
(
mime
!
(
Text
/
Css
)
)
QualityItem
:
:
new
(
mime
!
(
_
/
_
)
q
(
0
.
1
)
)
]
}
_
=
>
{
vec
!
[
qitem
(
mime
!
(
_
/
_
)
)
]
}
}
;
headers
.
set
(
Accept
(
value
)
)
;
}
fn
set_default_accept_encoding
(
headers
:
&
mut
Headers
)
{
if
headers
.
has
:
:
<
AcceptEncoding
>
(
)
{
return
}
headers
.
set
(
AcceptEncoding
(
vec
!
[
qitem
(
Encoding
:
:
Gzip
)
qitem
(
Encoding
:
:
Deflate
)
qitem
(
Encoding
:
:
EncodingExt
(
"
br
"
.
to_owned
(
)
)
)
]
)
)
;
}
pub
fn
set_default_accept_language
(
headers
:
&
mut
Headers
)
{
if
headers
.
has
:
:
<
AcceptLanguage
>
(
)
{
return
;
}
let
mut
en_us
:
LanguageTag
=
Default
:
:
default
(
)
;
en_us
.
language
=
Some
(
"
en
"
.
to_owned
(
)
)
;
en_us
.
region
=
Some
(
"
US
"
.
to_owned
(
)
)
;
let
mut
en
:
LanguageTag
=
Default
:
:
default
(
)
;
en
.
language
=
Some
(
"
en
"
.
to_owned
(
)
)
;
headers
.
set
(
AcceptLanguage
(
vec
!
[
qitem
(
en_us
)
QualityItem
:
:
new
(
en
Quality
(
500
)
)
]
)
)
;
}
fn
no_referrer_when_downgrade_header
(
referrer_url
:
ServoUrl
url
:
ServoUrl
)
-
>
Option
<
ServoUrl
>
{
if
referrer_url
.
scheme
(
)
=
=
"
https
"
&
&
url
.
scheme
(
)
!
=
"
https
"
{
return
None
;
}
return
strip_url
(
referrer_url
false
)
;
}
fn
strict_origin
(
referrer_url
:
ServoUrl
url
:
ServoUrl
)
-
>
Option
<
ServoUrl
>
{
if
referrer_url
.
scheme
(
)
=
=
"
https
"
&
&
url
.
scheme
(
)
!
=
"
https
"
{
return
None
;
}
strip_url
(
referrer_url
true
)
}
fn
strict_origin_when_cross_origin
(
referrer_url
:
ServoUrl
url
:
ServoUrl
)
-
>
Option
<
ServoUrl
>
{
if
referrer_url
.
scheme
(
)
=
=
"
https
"
&
&
url
.
scheme
(
)
!
=
"
https
"
{
return
None
;
}
let
cross_origin
=
referrer_url
.
origin
(
)
!
=
url
.
origin
(
)
;
strip_url
(
referrer_url
cross_origin
)
}
fn
strip_url
(
mut
referrer_url
:
ServoUrl
origin_only
:
bool
)
-
>
Option
<
ServoUrl
>
{
if
referrer_url
.
scheme
(
)
=
=
"
https
"
|
|
referrer_url
.
scheme
(
)
=
=
"
http
"
{
{
let
referrer
=
referrer_url
.
as_mut_url
(
)
;
referrer
.
set_username
(
"
"
)
.
unwrap
(
)
;
referrer
.
set_password
(
None
)
.
unwrap
(
)
;
referrer
.
set_fragment
(
None
)
;
if
origin_only
{
referrer
.
set_path
(
"
"
)
;
referrer
.
set_query
(
None
)
;
}
}
return
Some
(
referrer_url
)
;
}
return
None
;
}
pub
fn
determine_request_referrer
(
headers
:
&
mut
Headers
referrer_policy
:
ReferrerPolicy
referrer_source
:
ServoUrl
current_url
:
ServoUrl
)
-
>
Option
<
ServoUrl
>
{
assert
!
(
!
headers
.
has
:
:
<
Referer
>
(
)
)
;
let
cross_origin
=
referrer_source
.
origin
(
)
!
=
current_url
.
origin
(
)
;
match
referrer_policy
{
ReferrerPolicy
:
:
NoReferrer
=
>
None
ReferrerPolicy
:
:
Origin
=
>
strip_url
(
referrer_source
true
)
ReferrerPolicy
:
:
SameOrigin
=
>
if
cross_origin
{
None
}
else
{
strip_url
(
referrer_source
false
)
}
ReferrerPolicy
:
:
UnsafeUrl
=
>
strip_url
(
referrer_source
false
)
ReferrerPolicy
:
:
OriginWhenCrossOrigin
=
>
strip_url
(
referrer_source
cross_origin
)
ReferrerPolicy
:
:
StrictOrigin
=
>
strict_origin
(
referrer_source
current_url
)
ReferrerPolicy
:
:
StrictOriginWhenCrossOrigin
=
>
strict_origin_when_cross_origin
(
referrer_source
current_url
)
ReferrerPolicy
:
:
NoReferrerWhenDowngrade
=
>
no_referrer_when_downgrade_header
(
referrer_source
current_url
)
}
}
pub
fn
set_request_cookies
(
url
:
&
ServoUrl
headers
:
&
mut
Headers
cookie_jar
:
&
RwLock
<
CookieStorage
>
)
{
let
mut
cookie_jar
=
cookie_jar
.
write
(
)
.
unwrap
(
)
;
if
let
Some
(
cookie_list
)
=
cookie_jar
.
cookies_for_url
(
url
CookieSource
:
:
HTTP
)
{
let
mut
v
=
Vec
:
:
new
(
)
;
v
.
push
(
cookie_list
.
into_bytes
(
)
)
;
headers
.
set_raw
(
"
Cookie
"
.
to_owned
(
)
v
)
;
}
}
fn
set_cookie_for_url
(
cookie_jar
:
&
RwLock
<
CookieStorage
>
request
:
&
ServoUrl
cookie_val
:
String
)
{
let
mut
cookie_jar
=
cookie_jar
.
write
(
)
.
unwrap
(
)
;
let
source
=
CookieSource
:
:
HTTP
;
let
header
=
Header
:
:
parse_header
(
&
[
cookie_val
.
into_bytes
(
)
]
)
;
if
let
Ok
(
SetCookie
(
cookies
)
)
=
header
{
for
cookie
in
cookies
{
if
let
Some
(
cookie
)
=
cookie
:
:
Cookie
:
:
from_cookie_string
(
cookie
request
source
)
{
cookie_jar
.
push
(
cookie
request
source
)
;
}
}
}
}
fn
set_cookies_from_headers
(
url
:
&
ServoUrl
headers
:
&
Headers
cookie_jar
:
&
RwLock
<
CookieStorage
>
)
{
if
let
Some
(
cookies
)
=
headers
.
get_raw
(
"
set
-
cookie
"
)
{
for
cookie
in
cookies
.
iter
(
)
{
if
let
Ok
(
cookie_value
)
=
String
:
:
from_utf8
(
cookie
.
clone
(
)
)
{
set_cookie_for_url
(
&
cookie_jar
&
url
cookie_value
)
;
}
}
}
}
struct
StreamedResponse
{
decoder
:
Decoder
}
impl
Read
for
StreamedResponse
{
#
[
inline
]
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
match
self
.
decoder
{
Decoder
:
:
Gzip
(
ref
mut
d
)
=
>
d
.
read
(
buf
)
Decoder
:
:
Deflate
(
ref
mut
d
)
=
>
d
.
read
(
buf
)
Decoder
:
:
Brotli
(
ref
mut
d
)
=
>
d
.
read
(
buf
)
Decoder
:
:
Plain
(
ref
mut
d
)
=
>
d
.
read
(
buf
)
}
}
}
impl
StreamedResponse
{
fn
from_http_response
(
response
:
HyperResponse
)
-
>
io
:
:
Result
<
StreamedResponse
>
{
let
decoder
=
{
if
let
Some
(
ref
encoding
)
=
response
.
headers
.
get
:
:
<
ContentEncoding
>
(
)
.
cloned
(
)
{
if
encoding
.
contains
(
&
Encoding
:
:
Gzip
)
{
Decoder
:
:
Gzip
(
GzDecoder
:
:
new
(
response
)
?
)
}
else
if
encoding
.
contains
(
&
Encoding
:
:
Deflate
)
{
Decoder
:
:
Deflate
(
DeflateDecoder
:
:
new
(
response
)
)
}
else
if
encoding
.
contains
(
&
Encoding
:
:
EncodingExt
(
"
br
"
.
to_owned
(
)
)
)
{
Decoder
:
:
Brotli
(
Decompressor
:
:
new
(
response
1024
)
)
}
else
{
Decoder
:
:
Plain
(
response
)
}
}
else
{
Decoder
:
:
Plain
(
response
)
}
}
;
Ok
(
StreamedResponse
{
decoder
:
decoder
}
)
}
}
enum
Decoder
{
Gzip
(
GzDecoder
<
HyperResponse
>
)
Deflate
(
DeflateDecoder
<
HyperResponse
>
)
Brotli
(
Decompressor
<
HyperResponse
>
)
Plain
(
HyperResponse
)
}
fn
prepare_devtools_request
(
request_id
:
String
url
:
ServoUrl
method
:
Method
headers
:
Headers
body
:
Option
<
Vec
<
u8
>
>
pipeline_id
:
PipelineId
now
:
Tm
connect_time
:
u64
send_time
:
u64
is_xhr
:
bool
)
-
>
ChromeToDevtoolsControlMsg
{
let
request
=
DevtoolsHttpRequest
{
url
:
url
method
:
method
headers
:
headers
body
:
body
pipeline_id
:
pipeline_id
startedDateTime
:
now
timeStamp
:
now
.
to_timespec
(
)
.
sec
connect_time
:
connect_time
send_time
:
send_time
is_xhr
:
is_xhr
}
;
let
net_event
=
NetworkEvent
:
:
HttpRequest
(
request
)
;
ChromeToDevtoolsControlMsg
:
:
NetworkEvent
(
request_id
net_event
)
}
fn
send_request_to_devtools
(
msg
:
ChromeToDevtoolsControlMsg
devtools_chan
:
&
Sender
<
DevtoolsControlMsg
>
)
{
devtools_chan
.
send
(
DevtoolsControlMsg
:
:
FromChrome
(
msg
)
)
.
unwrap
(
)
;
}
fn
send_response_to_devtools
(
devtools_chan
:
&
Sender
<
DevtoolsControlMsg
>
request_id
:
String
headers
:
Option
<
Headers
>
status
:
Option
<
(
u16
Vec
<
u8
>
)
>
pipeline_id
:
PipelineId
)
{
let
response
=
DevtoolsHttpResponse
{
headers
:
headers
status
:
status
body
:
None
pipeline_id
:
pipeline_id
}
;
let
net_event_response
=
NetworkEvent
:
:
HttpResponse
(
response
)
;
let
msg
=
ChromeToDevtoolsControlMsg
:
:
NetworkEvent
(
request_id
net_event_response
)
;
let
_
=
devtools_chan
.
send
(
DevtoolsControlMsg
:
:
FromChrome
(
msg
)
)
;
}
fn
auth_from_cache
(
auth_cache
:
&
RwLock
<
AuthCache
>
origin
:
&
ImmutableOrigin
)
-
>
Option
<
Basic
>
{
if
let
Some
(
ref
auth_entry
)
=
auth_cache
.
read
(
)
.
unwrap
(
)
.
entries
.
get
(
&
origin
.
ascii_serialization
(
)
)
{
let
user_name
=
auth_entry
.
user_name
.
clone
(
)
;
let
password
=
Some
(
auth_entry
.
password
.
clone
(
)
)
;
Some
(
Basic
{
username
:
user_name
password
:
password
}
)
}
else
{
None
}
}
fn
obtain_response
(
connector
:
&
Pool
<
Connector
>
url
:
&
ServoUrl
method
:
&
Method
request_headers
:
&
Headers
data
:
&
Option
<
Vec
<
u8
>
>
load_data_method
:
&
Method
pipeline_id
:
&
Option
<
PipelineId
>
iters
:
u32
request_id
:
Option
<
&
str
>
is_xhr
:
bool
)
-
>
Result
<
(
HyperResponse
Option
<
ChromeToDevtoolsControlMsg
>
)
NetworkError
>
{
let
null_data
=
None
;
loop
{
let
mut
headers
=
request_headers
.
clone
(
)
;
let
is_redirected_request
=
iters
!
=
1
;
let
request_body
;
match
data
{
&
Some
(
ref
d
)
if
!
is_redirected_request
=
>
{
headers
.
set
(
ContentLength
(
d
.
len
(
)
as
u64
)
)
;
request_body
=
data
;
}
_
=
>
{
if
*
load_data_method
!
=
Method
:
:
Get
&
&
*
load_data_method
!
=
Method
:
:
Head
{
headers
.
set
(
ContentLength
(
0
)
)
}
request_body
=
&
null_data
;
}
}
if
log_enabled
!
(
log
:
:
LogLevel
:
:
Info
)
{
info
!
(
"
{
}
{
}
"
method
url
)
;
for
header
in
headers
.
iter
(
)
{
info
!
(
"
-
{
}
"
header
)
;
}
info
!
(
"
{
:
?
}
"
data
)
;
}
let
connect_start
=
precise_time_ms
(
)
;
let
request
=
HyperRequest
:
:
with_connector
(
method
.
clone
(
)
url
.
clone
(
)
.
into_url
(
)
&
*
connector
)
;
let
mut
request
=
match
request
{
Ok
(
request
)
=
>
request
Err
(
e
)
=
>
return
Err
(
NetworkError
:
:
from_hyper_error
(
&
url
e
)
)
}
;
*
request
.
headers_mut
(
)
=
headers
.
clone
(
)
;
let
connect_end
=
precise_time_ms
(
)
;
let
send_start
=
precise_time_ms
(
)
;
let
mut
request_writer
=
match
request
.
start
(
)
{
Ok
(
streaming
)
=
>
streaming
Err
(
e
)
=
>
return
Err
(
NetworkError
:
:
Internal
(
e
.
description
(
)
.
to_owned
(
)
)
)
}
;
if
let
Some
(
ref
data
)
=
*
request_body
{
if
let
Err
(
e
)
=
request_writer
.
write_all
(
&
data
)
{
return
Err
(
NetworkError
:
:
Internal
(
e
.
description
(
)
.
to_owned
(
)
)
)
}
}
let
response
=
match
request_writer
.
send
(
)
{
Ok
(
w
)
=
>
w
Err
(
HttpError
:
:
Io
(
ref
io_error
)
)
if
io_error
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
ConnectionAborted
|
|
io_error
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
ConnectionReset
=
>
{
debug
!
(
"
connection
aborted
(
{
:
?
}
)
possibly
stale
trying
new
connection
"
io_error
.
description
(
)
)
;
continue
;
}
Err
(
e
)
=
>
return
Err
(
NetworkError
:
:
Internal
(
e
.
description
(
)
.
to_owned
(
)
)
)
}
;
let
send_end
=
precise_time_ms
(
)
;
let
msg
=
if
let
Some
(
request_id
)
=
request_id
{
if
let
Some
(
pipeline_id
)
=
*
pipeline_id
{
Some
(
prepare_devtools_request
(
request_id
.
into
(
)
url
.
clone
(
)
method
.
clone
(
)
headers
request_body
.
clone
(
)
pipeline_id
time
:
:
now
(
)
connect_end
-
connect_start
send_end
-
send_start
is_xhr
)
)
}
else
{
debug
!
(
"
Not
notifying
devtools
(
no
pipeline_id
)
"
)
;
None
}
}
else
{
debug
!
(
"
Not
notifying
devtools
(
no
request_id
)
"
)
;
None
}
;
return
Ok
(
(
response
msg
)
)
;
}
}
pub
fn
http_fetch
(
request
:
&
mut
Request
cache
:
&
mut
CorsCache
cors_flag
:
bool
cors_preflight_flag
:
bool
authentication_fetch_flag
:
bool
target
:
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
*
done_chan
=
None
;
let
mut
response
:
Option
<
Response
>
=
None
;
if
request
.
service_workers_mode
!
=
ServiceWorkersMode
:
:
None
{
if
request
.
service_workers_mode
=
=
ServiceWorkersMode
:
:
All
{
}
if
response
.
is_none
(
)
&
&
request
.
is_subresource_request
(
)
&
&
match
request
.
origin
{
Origin
:
:
Origin
(
ref
origin
)
=
>
*
origin
=
=
request
.
url
(
)
.
origin
(
)
_
=
>
false
}
{
}
if
let
Some
(
ref
res
)
=
response
{
if
(
res
.
response_type
=
=
ResponseType
:
:
Opaque
&
&
request
.
mode
!
=
RequestMode
:
:
NoCors
)
|
|
(
res
.
response_type
=
=
ResponseType
:
:
OpaqueRedirect
&
&
request
.
redirect_mode
!
=
RedirectMode
:
:
Manual
)
|
|
(
res
.
url_list
.
len
(
)
>
1
&
&
request
.
redirect_mode
!
=
RedirectMode
:
:
Follow
)
|
|
res
.
is_network_error
(
)
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Request
failed
"
.
into
(
)
)
)
;
}
}
}
if
response
.
is_none
(
)
{
if
cors_preflight_flag
{
let
method_cache_match
=
cache
.
match_method
(
&
*
request
request
.
method
.
clone
(
)
)
;
let
method_mismatch
=
!
method_cache_match
&
&
(
!
is_cors_safelisted_method
(
&
request
.
method
)
|
|
request
.
use_cors_preflight
)
;
let
header_mismatch
=
request
.
headers
.
iter
(
)
.
any
(
|
view
|
!
cache
.
match_header
(
&
*
request
view
.
name
(
)
)
&
&
!
is_cors_safelisted_request_header
(
&
view
)
)
;
if
method_mismatch
|
|
header_mismatch
{
let
preflight_result
=
cors_preflight_fetch
(
&
request
cache
context
)
;
if
let
Some
(
e
)
=
preflight_result
.
get_network_error
(
)
{
return
Response
:
:
network_error
(
e
.
clone
(
)
)
;
}
}
}
if
request
.
redirect_mode
=
=
RedirectMode
:
:
Follow
{
request
.
service_workers_mode
=
ServiceWorkersMode
:
:
Foreign
;
}
let
mut
fetch_result
=
http_network_or_cache_fetch
(
request
authentication_fetch_flag
cors_flag
done_chan
context
)
;
if
cors_flag
&
&
cors_check
(
&
request
&
fetch_result
)
.
is_err
(
)
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
check
failed
"
.
into
(
)
)
)
;
}
fetch_result
.
return_internal
=
false
;
response
=
Some
(
fetch_result
)
;
}
let
mut
response
=
response
.
unwrap
(
)
;
if
response
.
actual_response
(
)
.
status
.
map_or
(
false
is_redirect_status
)
{
if
response
.
actual_response
(
)
.
status
.
map_or
(
true
|
s
|
s
!
=
StatusCode
:
:
SeeOther
)
{
}
let
location
=
response
.
actual_response
(
)
.
headers
.
get
:
:
<
Location
>
(
)
.
map
(
|
l
|
ServoUrl
:
:
parse_with_base
(
response
.
actual_response
(
)
.
url
(
)
l
)
.
map_err
(
|
err
|
err
.
description
(
)
.
into
(
)
)
)
;
response
.
actual_response_mut
(
)
.
location_url
=
location
;
response
=
match
request
.
redirect_mode
{
RedirectMode
:
:
Error
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Redirect
mode
error
"
.
into
(
)
)
)
RedirectMode
:
:
Manual
=
>
{
response
.
to_filtered
(
ResponseType
:
:
OpaqueRedirect
)
}
RedirectMode
:
:
Follow
=
>
{
response
.
return_internal
=
true
;
http_redirect_fetch
(
request
cache
response
cors_flag
target
done_chan
context
)
}
}
;
}
response
.
return_internal
=
true
;
response
}
pub
fn
http_redirect_fetch
(
request
:
&
mut
Request
cache
:
&
mut
CorsCache
response
:
Response
cors_flag
:
bool
target
:
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
assert
!
(
response
.
return_internal
)
;
let
location_url
=
response
.
actual_response
(
)
.
location_url
.
clone
(
)
;
let
location_url
=
match
location_url
{
None
=
>
return
response
Some
(
Err
(
err
)
)
=
>
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Location
URL
parse
failure
:
"
.
to_owned
(
)
+
&
err
)
)
Some
(
Ok
(
ref
url
)
)
if
!
matches
!
(
url
.
scheme
(
)
"
http
"
|
"
https
"
)
=
>
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Location
URL
not
an
HTTP
(
S
)
scheme
"
.
into
(
)
)
)
Some
(
Ok
(
url
)
)
=
>
url
}
;
if
request
.
redirect_count
>
=
20
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Too
many
redirects
"
.
into
(
)
)
)
;
}
request
.
redirect_count
+
=
1
;
let
same_origin
=
match
request
.
origin
{
Origin
:
:
Origin
(
ref
origin
)
=
>
*
origin
=
=
location_url
.
origin
(
)
Origin
:
:
Client
=
>
panic
!
(
"
Request
origin
should
not
be
client
for
{
}
"
request
.
current_url
(
)
)
}
;
let
has_credentials
=
has_credentials
(
&
location_url
)
;
if
request
.
mode
=
=
RequestMode
:
:
CorsMode
&
&
!
same_origin
&
&
has_credentials
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Cross
-
origin
credentials
check
failed
"
.
into
(
)
)
)
;
}
if
cors_flag
&
&
has_credentials
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Credentials
check
failed
"
.
into
(
)
)
)
;
}
if
response
.
actual_response
(
)
.
status
.
map_or
(
true
|
s
|
s
!
=
StatusCode
:
:
SeeOther
)
&
&
request
.
body
.
as_ref
(
)
.
map_or
(
false
|
b
|
b
.
is_empty
(
)
)
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Request
body
is
not
done
"
.
into
(
)
)
)
;
}
if
cors_flag
&
&
location_url
.
origin
(
)
!
=
request
.
current_url
(
)
.
origin
(
)
{
request
.
origin
=
Origin
:
:
Origin
(
ImmutableOrigin
:
:
new_opaque
(
)
)
;
}
if
response
.
actual_response
(
)
.
status
.
map_or
(
false
|
code
|
(
(
code
=
=
StatusCode
:
:
MovedPermanently
|
|
code
=
=
StatusCode
:
:
Found
)
&
&
request
.
method
=
=
Method
:
:
Post
)
|
|
code
=
=
StatusCode
:
:
SeeOther
)
{
request
.
method
=
Method
:
:
Get
;
request
.
body
=
None
;
}
if
let
Some
(
_
)
=
request
.
body
{
}
request
.
url_list
.
push
(
location_url
)
;
let
recursive_flag
=
request
.
redirect_mode
!
=
RedirectMode
:
:
Manual
;
main_fetch
(
request
cache
cors_flag
recursive_flag
target
done_chan
context
)
}
fn
try_immutable_origin_to_hyper_origin
(
url_origin
:
&
ImmutableOrigin
)
-
>
Option
<
HyperOrigin
>
{
match
*
url_origin
{
ImmutableOrigin
:
:
Opaque
(
_
)
=
>
None
ImmutableOrigin
:
:
Tuple
(
ref
scheme
ref
host
ref
port
)
=
>
Some
(
HyperOrigin
:
:
new
(
scheme
.
clone
(
)
host
.
to_string
(
)
Some
(
port
.
clone
(
)
)
)
)
}
}
fn
http_network_or_cache_fetch
(
request
:
&
mut
Request
authentication_fetch_flag
:
bool
cors_flag
:
bool
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
request_has_no_window
=
true
;
let
mut
http_request
;
let
http_request
=
if
request_has_no_window
&
&
request
.
redirect_mode
=
=
RedirectMode
:
:
Error
{
request
}
else
{
http_request
=
request
.
clone
(
)
;
&
mut
http_request
}
;
let
credentials_flag
=
match
http_request
.
credentials_mode
{
CredentialsMode
:
:
Include
=
>
true
CredentialsMode
:
:
CredentialsSameOrigin
if
http_request
.
response_tainting
=
=
ResponseTainting
:
:
Basic
=
>
true
_
=
>
false
}
;
let
content_length_value
=
match
http_request
.
body
{
None
=
>
match
http_request
.
method
{
Method
:
:
Post
|
Method
:
:
Put
=
>
Some
(
0
)
_
=
>
None
}
Some
(
ref
http_request_body
)
=
>
Some
(
http_request_body
.
len
(
)
as
u64
)
}
;
if
let
Some
(
content_length_value
)
=
content_length_value
{
http_request
.
headers
.
set
(
ContentLength
(
content_length_value
)
)
;
if
http_request
.
keep_alive
{
}
}
match
http_request
.
referrer
{
Referrer
:
:
NoReferrer
=
>
(
)
Referrer
:
:
ReferrerUrl
(
ref
http_request_referrer
)
=
>
http_request
.
headers
.
set
(
Referer
(
http_request_referrer
.
to_string
(
)
)
)
Referrer
:
:
Client
=
>
unreachable
!
(
)
}
;
if
cors_flag
|
|
(
http_request
.
method
!
=
Method
:
:
Get
&
&
http_request
.
method
!
=
Method
:
:
Head
)
{
debug_assert
!
(
http_request
.
origin
!
=
Origin
:
:
Client
)
;
if
let
Origin
:
:
Origin
(
ref
url_origin
)
=
http_request
.
origin
{
if
let
Some
(
hyper_origin
)
=
try_immutable_origin_to_hyper_origin
(
url_origin
)
{
http_request
.
headers
.
set
(
hyper_origin
)
}
}
}
if
!
http_request
.
headers
.
has
:
:
<
UserAgent
>
(
)
{
let
user_agent
=
context
.
user_agent
.
clone
(
)
.
into_owned
(
)
;
http_request
.
headers
.
set
(
UserAgent
(
user_agent
)
)
;
}
match
http_request
.
cache_mode
{
CacheMode
:
:
Default
if
is_no_store_cache
(
&
http_request
.
headers
)
=
>
{
http_request
.
cache_mode
=
CacheMode
:
:
NoStore
;
}
CacheMode
:
:
NoCache
if
!
http_request
.
headers
.
has
:
:
<
CacheControl
>
(
)
=
>
{
http_request
.
headers
.
set
(
CacheControl
(
vec
!
[
CacheDirective
:
:
MaxAge
(
0
)
]
)
)
;
}
CacheMode
:
:
Reload
|
CacheMode
:
:
NoStore
=
>
{
if
!
http_request
.
headers
.
has
:
:
<
Pragma
>
(
)
{
http_request
.
headers
.
set
(
Pragma
:
:
NoCache
)
;
}
if
!
http_request
.
headers
.
has
:
:
<
CacheControl
>
(
)
{
http_request
.
headers
.
set
(
CacheControl
(
vec
!
[
CacheDirective
:
:
NoCache
]
)
)
;
}
}
_
=
>
{
}
}
let
current_url
=
http_request
.
current_url
(
)
;
let
host
=
Host
{
hostname
:
current_url
.
host_str
(
)
.
unwrap
(
)
.
to_owned
(
)
port
:
current_url
.
port
(
)
}
;
http_request
.
headers
.
set
(
host
)
;
set_default_accept_encoding
(
&
mut
http_request
.
headers
)
;
if
credentials_flag
{
set_request_cookies
(
&
current_url
&
mut
http_request
.
headers
&
context
.
state
.
cookie_jar
)
;
if
!
http_request
.
headers
.
has
:
:
<
Authorization
<
String
>
>
(
)
{
let
mut
authorization_value
=
None
;
if
let
Some
(
basic
)
=
auth_from_cache
(
&
context
.
state
.
auth_cache
&
current_url
.
origin
(
)
)
{
if
!
http_request
.
use_url_credentials
|
|
!
has_credentials
(
&
current_url
)
{
authorization_value
=
Some
(
basic
)
;
}
}
if
authentication_fetch_flag
&
&
authorization_value
.
is_none
(
)
{
if
has_credentials
(
&
current_url
)
{
authorization_value
=
Some
(
Basic
{
username
:
current_url
.
username
(
)
.
to_owned
(
)
password
:
current_url
.
password
(
)
.
map
(
str
:
:
to_owned
)
}
)
}
}
if
let
Some
(
basic
)
=
authorization_value
{
http_request
.
headers
.
set
(
Authorization
(
basic
)
)
;
}
}
}
let
mut
response
:
Option
<
Response
>
=
None
;
let
mut
revalidating_flag
=
false
;
if
let
Ok
(
http_cache
)
=
context
.
state
.
http_cache
.
read
(
)
{
if
let
Some
(
response_from_cache
)
=
http_cache
.
construct_response
(
&
http_request
)
{
let
response_headers
=
response_from_cache
.
response
.
headers
.
clone
(
)
;
let
(
cached_response
needs_revalidation
)
=
match
(
http_request
.
cache_mode
&
http_request
.
mode
)
{
(
CacheMode
:
:
ForceCache
_
)
=
>
(
Some
(
response_from_cache
.
response
)
false
)
(
CacheMode
:
:
OnlyIfCached
&
RequestMode
:
:
SameOrigin
)
=
>
(
Some
(
response_from_cache
.
response
)
false
)
(
CacheMode
:
:
OnlyIfCached
_
)
|
(
CacheMode
:
:
NoStore
_
)
|
(
CacheMode
:
:
Reload
_
)
=
>
(
None
false
)
(
_
_
)
=
>
(
Some
(
response_from_cache
.
response
)
response_from_cache
.
needs_validation
)
}
;
if
needs_revalidation
{
revalidating_flag
=
true
;
if
let
Some
(
date_slice
)
=
response_headers
.
get_raw
(
"
Last
-
Modified
"
)
{
let
date_string
=
String
:
:
from_utf8_lossy
(
&
date_slice
[
0
]
)
;
if
let
Ok
(
http_date
)
=
HttpDate
:
:
from_str
(
&
date_string
)
{
http_request
.
headers
.
set
(
IfModifiedSince
(
http_date
)
)
;
}
}
if
let
Some
(
entity_tag
)
=
response_headers
.
get_raw
(
"
ETag
"
)
{
http_request
.
headers
.
set_raw
(
"
If
-
None
-
Match
"
entity_tag
.
to_vec
(
)
)
;
}
}
else
{
response
=
cached_response
;
}
}
}
if
response
.
is_none
(
)
{
if
http_request
.
cache_mode
=
=
CacheMode
:
:
OnlyIfCached
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Couldn
'
t
find
response
in
cache
"
.
into
(
)
)
)
}
}
if
response
.
is_none
(
)
{
let
forward_response
=
http_network_fetch
(
http_request
credentials_flag
done_chan
context
)
;
if
let
Some
(
(
200
.
.
.
399
_
)
)
=
forward_response
.
raw_status
{
if
!
http_request
.
method
.
safe
(
)
{
if
let
Ok
(
mut
http_cache
)
=
context
.
state
.
http_cache
.
write
(
)
{
http_cache
.
invalidate
(
&
http_request
&
forward_response
)
;
}
}
}
if
revalidating_flag
&
&
forward_response
.
status
.
map_or
(
false
|
s
|
s
=
=
StatusCode
:
:
NotModified
)
{
if
let
Ok
(
mut
http_cache
)
=
context
.
state
.
http_cache
.
write
(
)
{
response
=
http_cache
.
refresh
(
&
http_request
forward_response
.
clone
(
)
done_chan
)
;
}
}
if
response
.
is_none
(
)
{
if
http_request
.
cache_mode
!
=
CacheMode
:
:
NoStore
{
if
let
Ok
(
mut
http_cache
)
=
context
.
state
.
http_cache
.
write
(
)
{
http_cache
.
store
(
&
http_request
&
forward_response
)
;
}
}
response
=
Some
(
forward_response
)
;
}
}
let
mut
response
=
response
.
unwrap
(
)
;
if
let
(
Some
(
StatusCode
:
:
Unauthorized
)
false
true
)
=
(
response
.
status
cors_flag
credentials_flag
)
{
if
http_request
.
body
.
is_some
(
)
{
}
if
!
http_request
.
use_url_credentials
|
|
authentication_fetch_flag
{
return
response
;
}
response
=
http_network_or_cache_fetch
(
http_request
true
cors_flag
done_chan
context
)
;
}
if
let
Some
(
StatusCode
:
:
ProxyAuthenticationRequired
)
=
response
.
status
{
if
request_has_no_window
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Can
'
t
find
Window
object
"
.
into
(
)
)
)
;
}
return
response
;
}
if
authentication_fetch_flag
{
}
response
}
fn
http_network_fetch
(
request
:
&
Request
credentials_flag
:
bool
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
url
=
request
.
current_url
(
)
;
let
request_id
=
context
.
devtools_chan
.
as_ref
(
)
.
map
(
|
_
|
{
uuid
:
:
Uuid
:
:
new_v4
(
)
.
simple
(
)
.
to_string
(
)
}
)
;
let
is_xhr
=
request
.
destination
=
=
Destination
:
:
None
;
let
wrapped_response
=
obtain_response
(
&
context
.
state
.
connector
&
url
&
request
.
method
&
request
.
headers
&
request
.
body
&
request
.
method
&
request
.
pipeline_id
request
.
redirect_count
+
1
request_id
.
as_ref
(
)
.
map
(
Deref
:
:
deref
)
is_xhr
)
;
let
pipeline_id
=
request
.
pipeline_id
;
let
(
res
msg
)
=
match
wrapped_response
{
Ok
(
wrapped_response
)
=
>
wrapped_response
Err
(
error
)
=
>
return
Response
:
:
network_error
(
error
)
}
;
if
log_enabled
!
(
log
:
:
LogLevel
:
:
Info
)
{
info
!
(
"
response
for
{
}
"
url
)
;
for
header
in
res
.
headers
.
iter
(
)
{
info
!
(
"
-
{
}
"
header
)
;
}
}
let
mut
response
=
Response
:
:
new
(
url
.
clone
(
)
)
;
response
.
status
=
Some
(
res
.
status
)
;
response
.
raw_status
=
Some
(
(
res
.
status_raw
(
)
.
0
res
.
status_raw
(
)
.
1
.
as_bytes
(
)
.
to_vec
(
)
)
)
;
response
.
headers
=
res
.
headers
.
clone
(
)
;
response
.
referrer
=
request
.
referrer
.
to_url
(
)
.
cloned
(
)
;
response
.
referrer_policy
=
request
.
referrer_policy
.
clone
(
)
;
let
res_body
=
response
.
body
.
clone
(
)
;
let
(
done_sender
done_receiver
)
=
channel
(
)
;
*
done_chan
=
Some
(
(
done_sender
.
clone
(
)
done_receiver
)
)
;
let
meta
=
match
response
.
metadata
(
)
.
expect
(
"
Response
metadata
should
exist
at
this
stage
"
)
{
FetchMetadata
:
:
Unfiltered
(
m
)
=
>
m
FetchMetadata
:
:
Filtered
{
unsafe_
.
.
}
=
>
unsafe_
}
;
let
devtools_sender
=
context
.
devtools_chan
.
clone
(
)
;
let
meta_status
=
meta
.
status
.
clone
(
)
;
let
meta_headers
=
meta
.
headers
.
clone
(
)
;
let
cancellation_listener
=
context
.
cancellation_listener
.
clone
(
)
;
if
cancellation_listener
.
lock
(
)
.
unwrap
(
)
.
cancelled
(
)
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Fetch
aborted
"
.
into
(
)
)
)
}
thread
:
:
Builder
:
:
new
(
)
.
name
(
format
!
(
"
fetch
worker
thread
"
)
)
.
spawn
(
move
|
|
{
match
StreamedResponse
:
:
from_http_response
(
res
)
{
Ok
(
mut
res
)
=
>
{
*
res_body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Receiving
(
vec
!
[
]
)
;
if
let
Some
(
ref
sender
)
=
devtools_sender
{
if
let
Some
(
m
)
=
msg
{
send_request_to_devtools
(
m
&
sender
)
;
}
if
let
Some
(
pipeline_id
)
=
pipeline_id
{
send_response_to_devtools
(
&
sender
request_id
.
unwrap
(
)
meta_headers
.
map
(
Serde
:
:
into_inner
)
meta_status
pipeline_id
)
;
}
}
loop
{
if
cancellation_listener
.
lock
(
)
.
unwrap
(
)
.
cancelled
(
)
{
*
res_body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
vec
!
[
]
)
;
let
_
=
done_sender
.
send
(
Data
:
:
Cancelled
)
;
return
;
}
match
read_block
(
&
mut
res
)
{
Ok
(
Data
:
:
Payload
(
chunk
)
)
=
>
{
if
let
ResponseBody
:
:
Receiving
(
ref
mut
body
)
=
*
res_body
.
lock
(
)
.
unwrap
(
)
{
body
.
extend_from_slice
(
&
chunk
)
;
let
_
=
done_sender
.
send
(
Data
:
:
Payload
(
chunk
)
)
;
}
}
Ok
(
Data
:
:
Done
)
|
Err
(
_
)
=
>
{
let
mut
body
=
res_body
.
lock
(
)
.
unwrap
(
)
;
let
completed_body
=
match
*
body
{
ResponseBody
:
:
Receiving
(
ref
mut
body
)
=
>
{
mem
:
:
replace
(
body
vec
!
[
]
)
}
_
=
>
vec
!
[
]
}
;
*
body
=
ResponseBody
:
:
Done
(
completed_body
)
;
let
_
=
done_sender
.
send
(
Data
:
:
Done
)
;
break
;
}
Ok
(
Data
:
:
Cancelled
)
=
>
unreachable
!
(
)
}
}
}
Err
(
_
)
=
>
{
*
res_body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
vec
!
[
]
)
;
let
_
=
done_sender
.
send
(
Data
:
:
Done
)
;
}
}
}
)
.
expect
(
"
Thread
spawning
failed
"
)
;
response
.
https_state
=
HttpsState
:
:
None
;
if
let
Some
(
encoding
)
=
response
.
headers
.
get
:
:
<
ContentEncoding
>
(
)
{
if
encoding
.
contains
(
&
Encoding
:
:
Gzip
)
{
}
else
if
encoding
.
contains
(
&
Encoding
:
:
Compress
)
{
}
}
;
if
!
response
.
is_network_error
(
)
&
&
request
.
cache_mode
!
=
CacheMode
:
:
NoStore
{
if
let
Ok
(
mut
http_cache
)
=
context
.
state
.
http_cache
.
write
(
)
{
http_cache
.
store
(
&
request
&
response
)
;
}
}
if
credentials_flag
{
set_cookies_from_headers
(
&
url
&
response
.
headers
&
context
.
state
.
cookie_jar
)
;
}
response
}
fn
cors_preflight_fetch
(
request
:
&
Request
cache
:
&
mut
CorsCache
context
:
&
FetchContext
)
-
>
Response
{
let
mut
preflight
=
Request
:
:
new
(
request
.
current_url
(
)
Some
(
request
.
origin
.
clone
(
)
)
request
.
pipeline_id
)
;
preflight
.
method
=
Method
:
:
Options
;
preflight
.
initiator
=
request
.
initiator
.
clone
(
)
;
preflight
.
destination
=
request
.
destination
.
clone
(
)
;
preflight
.
origin
=
request
.
origin
.
clone
(
)
;
preflight
.
referrer
=
request
.
referrer
.
clone
(
)
;
preflight
.
referrer_policy
=
request
.
referrer_policy
;
preflight
.
headers
.
set
:
:
<
AccessControlRequestMethod
>
(
AccessControlRequestMethod
(
request
.
method
.
clone
(
)
)
)
;
let
mut
headers
=
request
.
headers
.
iter
(
)
.
filter
(
|
view
|
!
is_cors_safelisted_request_header
(
view
)
)
.
map
(
|
view
|
UniCase
(
view
.
name
(
)
.
to_ascii_lowercase
(
)
.
to_owned
(
)
)
)
.
collect
:
:
<
Vec
<
UniCase
<
String
>
>
>
(
)
;
headers
.
sort
(
)
;
if
!
headers
.
is_empty
(
)
{
preflight
.
headers
.
set
:
:
<
AccessControlRequestHeaders
>
(
AccessControlRequestHeaders
(
headers
)
)
;
}
let
response
=
http_network_or_cache_fetch
(
&
mut
preflight
false
false
&
mut
None
context
)
;
if
cors_check
(
&
request
&
response
)
.
is_ok
(
)
&
&
response
.
status
.
map_or
(
false
|
status
|
status
.
is_success
(
)
)
{
let
mut
methods
=
if
response
.
headers
.
has
:
:
<
AccessControlAllowMethods
>
(
)
{
match
response
.
headers
.
get
:
:
<
AccessControlAllowMethods
>
(
)
{
Some
(
&
AccessControlAllowMethods
(
ref
m
)
)
=
>
m
.
clone
(
)
None
=
>
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
ACAM
check
failed
"
.
into
(
)
)
)
}
}
else
{
vec
!
[
]
}
;
let
header_names
=
if
response
.
headers
.
has
:
:
<
AccessControlAllowHeaders
>
(
)
{
match
response
.
headers
.
get
:
:
<
AccessControlAllowHeaders
>
(
)
{
Some
(
&
AccessControlAllowHeaders
(
ref
hn
)
)
=
>
hn
.
clone
(
)
None
=
>
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
ACAH
check
failed
"
.
into
(
)
)
)
}
}
else
{
vec
!
[
]
}
;
if
(
methods
.
iter
(
)
.
any
(
|
m
|
m
.
as_ref
(
)
=
=
"
*
"
)
|
|
header_names
.
iter
(
)
.
any
(
|
hn
|
&
*
*
hn
=
=
"
*
"
)
)
&
&
request
.
credentials_mode
=
=
CredentialsMode
:
:
Include
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
ACAH
/
ACAM
and
request
credentials
mode
mismatch
"
.
into
(
)
)
)
;
}
if
methods
.
is_empty
(
)
&
&
request
.
use_cors_preflight
{
methods
=
vec
!
[
request
.
method
.
clone
(
)
]
;
}
debug
!
(
"
CORS
check
:
Allowed
methods
:
{
:
?
}
current
method
:
{
:
?
}
"
methods
request
.
method
)
;
if
methods
.
iter
(
)
.
all
(
|
method
|
*
method
!
=
request
.
method
)
&
&
!
is_cors_safelisted_method
(
&
request
.
method
)
&
&
methods
.
iter
(
)
.
all
(
|
m
|
m
.
as_ref
(
)
!
=
"
*
"
)
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
method
check
failed
"
.
into
(
)
)
)
;
}
if
request
.
headers
.
iter
(
)
.
any
(
|
header
|
header
.
name
(
)
=
=
"
authorization
"
&
&
header_names
.
iter
(
)
.
all
(
|
hn
|
*
hn
!
=
UniCase
(
header
.
name
(
)
)
)
)
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
authorization
check
failed
"
.
into
(
)
)
)
;
}
debug
!
(
"
CORS
check
:
Allowed
headers
:
{
:
?
}
current
headers
:
{
:
?
}
"
header_names
request
.
headers
)
;
let
set
:
HashSet
<
&
UniCase
<
String
>
>
=
HashSet
:
:
from_iter
(
header_names
.
iter
(
)
)
;
if
request
.
headers
.
iter
(
)
.
any
(
|
ref
hv
|
!
set
.
contains
(
&
UniCase
(
hv
.
name
(
)
.
to_owned
(
)
)
)
&
&
!
is_cors_safelisted_request_header
(
hv
)
)
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
headers
check
failed
"
.
into
(
)
)
)
;
}
let
max_age
=
response
.
headers
.
get
:
:
<
AccessControlMaxAge
>
(
)
.
map
(
|
acma
|
acma
.
0
)
.
unwrap_or
(
0
)
;
for
method
in
&
methods
{
cache
.
match_method_and_update
(
&
*
request
method
.
clone
(
)
max_age
)
;
}
for
header_name
in
&
header_names
{
cache
.
match_header_and_update
(
&
*
request
&
*
header_name
max_age
)
;
}
return
response
;
}
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
check
failed
"
.
into
(
)
)
)
}
fn
cors_check
(
request
:
&
Request
response
:
&
Response
)
-
>
Result
<
(
)
(
)
>
{
let
origin
=
response
.
headers
.
get
:
:
<
AccessControlAllowOrigin
>
(
)
.
cloned
(
)
;
let
origin
=
origin
.
ok_or
(
(
)
)
?
;
if
request
.
credentials_mode
!
=
CredentialsMode
:
:
Include
&
&
origin
=
=
AccessControlAllowOrigin
:
:
Any
{
return
Ok
(
(
)
)
;
}
let
origin
=
match
origin
{
AccessControlAllowOrigin
:
:
Value
(
origin
)
=
>
origin
_
=
>
return
Err
(
(
)
)
}
;
match
request
.
origin
{
Origin
:
:
Origin
(
ref
o
)
if
o
.
ascii_serialization
(
)
=
=
origin
.
trim
(
)
=
>
{
}
_
=
>
return
Err
(
(
)
)
}
if
request
.
credentials_mode
!
=
CredentialsMode
:
:
Include
{
return
Ok
(
(
)
)
;
}
let
credentials
=
response
.
headers
.
get
:
:
<
AccessControlAllowCredentials
>
(
)
.
cloned
(
)
;
if
credentials
.
is_some
(
)
{
return
Ok
(
(
)
)
;
}
Err
(
(
)
)
}
fn
has_credentials
(
url
:
&
ServoUrl
)
-
>
bool
{
!
url
.
username
(
)
.
is_empty
(
)
|
|
url
.
password
(
)
.
is_some
(
)
}
fn
is_no_store_cache
(
headers
:
&
Headers
)
-
>
bool
{
headers
.
has
:
:
<
IfModifiedSince
>
(
)
|
headers
.
has
:
:
<
IfNoneMatch
>
(
)
|
headers
.
has
:
:
<
IfUnmodifiedSince
>
(
)
|
headers
.
has
:
:
<
IfMatch
>
(
)
|
headers
.
has
:
:
<
IfRange
>
(
)
}
pub
fn
is_redirect_status
(
status
:
StatusCode
)
-
>
bool
{
match
status
{
StatusCode
:
:
MovedPermanently
|
StatusCode
:
:
Found
|
StatusCode
:
:
SeeOther
|
StatusCode
:
:
TemporaryRedirect
|
StatusCode
:
:
PermanentRedirect
=
>
true
_
=
>
false
}
}
