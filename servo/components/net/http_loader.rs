use
brotli
:
:
Decompressor
;
use
connector
:
:
{
Connector
create_http_connector
create_ssl_context
}
;
use
cookie
;
use
cookie_storage
:
:
CookieStorage
;
use
devtools_traits
:
:
{
ChromeToDevtoolsControlMsg
DevtoolsControlMsg
HttpRequest
as
DevtoolsHttpRequest
}
;
use
devtools_traits
:
:
{
HttpResponse
as
DevtoolsHttpResponse
NetworkEvent
}
;
use
fetch
:
:
cors_cache
:
:
CorsCache
;
use
fetch
:
:
methods
:
:
{
Data
DoneChannel
FetchContext
Target
is_simple_header
is_simple_method
main_fetch
}
;
use
flate2
:
:
read
:
:
{
DeflateDecoder
GzDecoder
}
;
use
hsts
:
:
HstsList
;
use
hyper
:
:
Error
as
HttpError
;
use
hyper
:
:
LanguageTag
;
use
hyper
:
:
client
:
:
{
Pool
Request
as
HyperRequest
Response
as
HyperResponse
}
;
use
hyper
:
:
client
:
:
pool
:
:
PooledStream
;
use
hyper
:
:
header
:
:
{
AcceptEncoding
AcceptLanguage
AccessControlAllowCredentials
}
;
use
hyper
:
:
header
:
:
{
AccessControlAllowOrigin
AccessControlAllowHeaders
AccessControlAllowMethods
}
;
use
hyper
:
:
header
:
:
{
AccessControlRequestHeaders
AccessControlMaxAge
AccessControlRequestMethod
}
;
use
hyper
:
:
header
:
:
{
Authorization
Basic
CacheControl
CacheDirective
ContentEncoding
}
;
use
hyper
:
:
header
:
:
{
ContentLength
Encoding
Header
Headers
Host
IfMatch
IfRange
}
;
use
hyper
:
:
header
:
:
{
IfUnmodifiedSince
IfModifiedSince
IfNoneMatch
Location
Pragma
Quality
}
;
use
hyper
:
:
header
:
:
{
QualityItem
Referer
SetCookie
UserAgent
qitem
}
;
use
hyper
:
:
header
:
:
Origin
as
HyperOrigin
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
net
:
:
{
Fresh
HttpStream
HttpsStream
NetworkConnector
}
;
use
hyper
:
:
status
:
:
StatusCode
;
use
hyper_serde
:
:
Serde
;
use
log
;
use
msg
:
:
constellation_msg
:
:
PipelineId
;
use
net_traits
:
:
{
CookieSource
FetchMetadata
NetworkError
ReferrerPolicy
}
;
use
net_traits
:
:
hosts
:
:
replace_host
;
use
net_traits
:
:
request
:
:
{
CacheMode
CredentialsMode
Destination
Origin
}
;
use
net_traits
:
:
request
:
:
{
RedirectMode
Referrer
Request
RequestMode
ResponseTainting
}
;
use
net_traits
:
:
response
:
:
{
HttpsState
Response
ResponseBody
ResponseType
}
;
use
openssl
;
use
openssl
:
:
ssl
:
:
SslStream
;
use
openssl
:
:
ssl
:
:
error
:
:
{
OpensslError
SslError
}
;
use
resource_thread
:
:
AuthCache
;
use
servo_url
:
:
{
ImmutableOrigin
ServoUrl
}
;
use
std
:
:
collections
:
:
HashSet
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
io
:
:
{
self
Read
Write
}
;
use
std
:
:
iter
:
:
FromIterator
;
use
std
:
:
mem
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
{
Arc
RwLock
}
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Sender
}
;
use
std
:
:
thread
;
use
time
;
use
time
:
:
Tm
;
use
unicase
:
:
UniCase
;
use
uuid
;
fn
read_block
<
R
:
Read
>
(
reader
:
&
mut
R
)
-
>
Result
<
Data
(
)
>
{
let
mut
buf
=
vec
!
[
0
;
1024
]
;
match
reader
.
read
(
&
mut
buf
)
{
Ok
(
len
)
if
len
>
0
=
>
{
buf
.
truncate
(
len
)
;
Ok
(
Data
:
:
Payload
(
buf
)
)
}
Ok
(
_
)
=
>
Ok
(
Data
:
:
Done
)
Err
(
_
)
=
>
Err
(
(
)
)
}
}
pub
struct
HttpState
{
pub
hsts_list
:
Arc
<
RwLock
<
HstsList
>
>
pub
cookie_jar
:
Arc
<
RwLock
<
CookieStorage
>
>
pub
auth_cache
:
Arc
<
RwLock
<
AuthCache
>
>
pub
connector_pool
:
Arc
<
Pool
<
Connector
>
>
}
impl
HttpState
{
pub
fn
new
(
certificate_path
:
&
str
)
-
>
HttpState
{
let
ssl_context
=
create_ssl_context
(
certificate_path
)
;
HttpState
{
hsts_list
:
Arc
:
:
new
(
RwLock
:
:
new
(
HstsList
:
:
new
(
)
)
)
cookie_jar
:
Arc
:
:
new
(
RwLock
:
:
new
(
CookieStorage
:
:
new
(
150
)
)
)
auth_cache
:
Arc
:
:
new
(
RwLock
:
:
new
(
AuthCache
:
:
new
(
)
)
)
connector_pool
:
create_http_connector
(
ssl_context
)
}
}
}
fn
precise_time_ms
(
)
-
>
u64
{
time
:
:
precise_time_ns
(
)
/
(
1000
*
1000
)
}
pub
struct
WrappedHttpResponse
{
pub
response
:
HyperResponse
}
impl
Read
for
WrappedHttpResponse
{
#
[
inline
]
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
response
.
read
(
buf
)
}
}
impl
WrappedHttpResponse
{
fn
headers
(
&
self
)
-
>
&
Headers
{
&
self
.
response
.
headers
}
fn
content_encoding
(
&
self
)
-
>
Option
<
Encoding
>
{
let
encodings
=
match
self
.
headers
(
)
.
get
:
:
<
ContentEncoding
>
(
)
{
Some
(
&
ContentEncoding
(
ref
encodings
)
)
=
>
encodings
None
=
>
return
None
}
;
if
encodings
.
contains
(
&
Encoding
:
:
Gzip
)
{
Some
(
Encoding
:
:
Gzip
)
}
else
if
encodings
.
contains
(
&
Encoding
:
:
Deflate
)
{
Some
(
Encoding
:
:
Deflate
)
}
else
if
encodings
.
contains
(
&
Encoding
:
:
EncodingExt
(
"
br
"
.
to_owned
(
)
)
)
{
Some
(
Encoding
:
:
EncodingExt
(
"
br
"
.
to_owned
(
)
)
)
}
else
{
None
}
}
}
struct
NetworkHttpRequestFactory
{
pub
connector
:
Arc
<
Pool
<
Connector
>
>
}
impl
NetworkConnector
for
NetworkHttpRequestFactory
{
type
Stream
=
PooledStream
<
HttpsStream
<
SslStream
<
HttpStream
>
>
>
;
fn
connect
(
&
self
host
:
&
str
port
:
u16
scheme
:
&
str
)
-
>
Result
<
Self
:
:
Stream
HttpError
>
{
self
.
connector
.
connect
(
&
replace_host
(
host
)
port
scheme
)
}
}
impl
NetworkHttpRequestFactory
{
fn
create
(
&
self
url
:
ServoUrl
method
:
Method
headers
:
Headers
)
-
>
Result
<
HyperRequest
<
Fresh
>
NetworkError
>
{
let
connection
=
HyperRequest
:
:
with_connector
(
method
url
.
clone
(
)
.
into_url
(
)
self
)
;
if
let
Err
(
HttpError
:
:
Ssl
(
ref
error
)
)
=
connection
{
let
error
:
&
(
Error
+
Send
+
'
static
)
=
&
*
*
error
;
if
let
Some
(
&
SslError
:
:
OpenSslErrors
(
ref
errors
)
)
=
error
.
downcast_ref
:
:
<
SslError
>
(
)
{
if
errors
.
iter
(
)
.
any
(
is_cert_verify_error
)
{
let
mut
error_report
=
vec
!
[
format
!
(
"
ssl
error
(
{
}
)
:
"
openssl
:
:
version
:
:
version
(
)
)
]
;
let
mut
suggestion
=
None
;
for
err
in
errors
{
if
is_unknown_message_digest_err
(
err
)
{
suggestion
=
Some
(
"
<
b
>
Servo
recommends
upgrading
to
a
newer
OpenSSL
version
.
<
/
b
>
"
)
;
}
error_report
.
push
(
format_ssl_error
(
err
)
)
;
}
if
let
Some
(
suggestion
)
=
suggestion
{
error_report
.
push
(
suggestion
.
to_owned
(
)
)
;
}
let
error_report
=
error_report
.
join
(
"
<
br
>
\
n
"
)
;
return
Err
(
NetworkError
:
:
SslValidation
(
url
error_report
)
)
;
}
}
}
let
mut
request
=
match
connection
{
Ok
(
req
)
=
>
req
Err
(
e
)
=
>
return
Err
(
NetworkError
:
:
Internal
(
e
.
description
(
)
.
to_owned
(
)
)
)
}
;
*
request
.
headers_mut
(
)
=
headers
;
Ok
(
request
)
}
}
fn
set_default_accept_encoding
(
headers
:
&
mut
Headers
)
{
if
headers
.
has
:
:
<
AcceptEncoding
>
(
)
{
return
}
headers
.
set
(
AcceptEncoding
(
vec
!
[
qitem
(
Encoding
:
:
Gzip
)
qitem
(
Encoding
:
:
Deflate
)
qitem
(
Encoding
:
:
EncodingExt
(
"
br
"
.
to_owned
(
)
)
)
]
)
)
;
}
pub
fn
set_default_accept_language
(
headers
:
&
mut
Headers
)
{
if
headers
.
has
:
:
<
AcceptLanguage
>
(
)
{
return
;
}
let
mut
en_us
:
LanguageTag
=
Default
:
:
default
(
)
;
en_us
.
language
=
Some
(
"
en
"
.
to_owned
(
)
)
;
en_us
.
region
=
Some
(
"
US
"
.
to_owned
(
)
)
;
let
mut
en
:
LanguageTag
=
Default
:
:
default
(
)
;
en
.
language
=
Some
(
"
en
"
.
to_owned
(
)
)
;
headers
.
set
(
AcceptLanguage
(
vec
!
[
qitem
(
en_us
)
QualityItem
:
:
new
(
en
Quality
(
500
)
)
]
)
)
;
}
fn
no_referrer_when_downgrade_header
(
referrer_url
:
ServoUrl
url
:
ServoUrl
)
-
>
Option
<
ServoUrl
>
{
if
referrer_url
.
scheme
(
)
=
=
"
https
"
&
&
url
.
scheme
(
)
!
=
"
https
"
{
return
None
;
}
return
strip_url
(
referrer_url
false
)
;
}
fn
strict_origin
(
referrer_url
:
ServoUrl
url
:
ServoUrl
)
-
>
Option
<
ServoUrl
>
{
if
referrer_url
.
scheme
(
)
=
=
"
https
"
&
&
url
.
scheme
(
)
!
=
"
https
"
{
return
None
;
}
strip_url
(
referrer_url
true
)
}
fn
strict_origin_when_cross_origin
(
referrer_url
:
ServoUrl
url
:
ServoUrl
)
-
>
Option
<
ServoUrl
>
{
if
referrer_url
.
scheme
(
)
=
=
"
https
"
&
&
url
.
scheme
(
)
!
=
"
https
"
{
return
None
;
}
let
cross_origin
=
referrer_url
.
origin
(
)
!
=
url
.
origin
(
)
;
strip_url
(
referrer_url
cross_origin
)
}
fn
strip_url
(
mut
referrer_url
:
ServoUrl
origin_only
:
bool
)
-
>
Option
<
ServoUrl
>
{
if
referrer_url
.
scheme
(
)
=
=
"
https
"
|
|
referrer_url
.
scheme
(
)
=
=
"
http
"
{
{
let
referrer
=
referrer_url
.
as_mut_url
(
)
;
referrer
.
set_username
(
"
"
)
.
unwrap
(
)
;
referrer
.
set_password
(
None
)
.
unwrap
(
)
;
referrer
.
set_fragment
(
None
)
;
if
origin_only
{
referrer
.
set_path
(
"
"
)
;
referrer
.
set_query
(
None
)
;
}
}
return
Some
(
referrer_url
)
;
}
return
None
;
}
pub
fn
determine_request_referrer
(
headers
:
&
mut
Headers
referrer_policy
:
ReferrerPolicy
referrer_source
:
ServoUrl
current_url
:
ServoUrl
)
-
>
Option
<
ServoUrl
>
{
assert
!
(
!
headers
.
has
:
:
<
Referer
>
(
)
)
;
let
cross_origin
=
referrer_source
.
origin
(
)
!
=
current_url
.
origin
(
)
;
match
referrer_policy
{
ReferrerPolicy
:
:
NoReferrer
=
>
None
ReferrerPolicy
:
:
Origin
=
>
strip_url
(
referrer_source
true
)
ReferrerPolicy
:
:
SameOrigin
=
>
if
cross_origin
{
None
}
else
{
strip_url
(
referrer_source
false
)
}
ReferrerPolicy
:
:
UnsafeUrl
=
>
strip_url
(
referrer_source
false
)
ReferrerPolicy
:
:
OriginWhenCrossOrigin
=
>
strip_url
(
referrer_source
cross_origin
)
ReferrerPolicy
:
:
StrictOrigin
=
>
strict_origin
(
referrer_source
current_url
)
ReferrerPolicy
:
:
StrictOriginWhenCrossOrigin
=
>
strict_origin_when_cross_origin
(
referrer_source
current_url
)
ReferrerPolicy
:
:
NoReferrerWhenDowngrade
=
>
no_referrer_when_downgrade_header
(
referrer_source
current_url
)
}
}
pub
fn
set_request_cookies
(
url
:
&
ServoUrl
headers
:
&
mut
Headers
cookie_jar
:
&
Arc
<
RwLock
<
CookieStorage
>
>
)
{
let
mut
cookie_jar
=
cookie_jar
.
write
(
)
.
unwrap
(
)
;
if
let
Some
(
cookie_list
)
=
cookie_jar
.
cookies_for_url
(
url
CookieSource
:
:
HTTP
)
{
let
mut
v
=
Vec
:
:
new
(
)
;
v
.
push
(
cookie_list
.
into_bytes
(
)
)
;
headers
.
set_raw
(
"
Cookie
"
.
to_owned
(
)
v
)
;
}
}
fn
set_cookie_for_url
(
cookie_jar
:
&
Arc
<
RwLock
<
CookieStorage
>
>
request
:
&
ServoUrl
cookie_val
:
String
)
{
let
mut
cookie_jar
=
cookie_jar
.
write
(
)
.
unwrap
(
)
;
let
source
=
CookieSource
:
:
HTTP
;
let
header
=
Header
:
:
parse_header
(
&
[
cookie_val
.
into_bytes
(
)
]
)
;
if
let
Ok
(
SetCookie
(
cookies
)
)
=
header
{
for
bare_cookie
in
cookies
{
if
let
Some
(
cookie
)
=
cookie
:
:
Cookie
:
:
new_wrapped
(
bare_cookie
request
source
)
{
cookie_jar
.
push
(
cookie
request
source
)
;
}
}
}
}
fn
set_cookies_from_headers
(
url
:
&
ServoUrl
headers
:
&
Headers
cookie_jar
:
&
Arc
<
RwLock
<
CookieStorage
>
>
)
{
if
let
Some
(
cookies
)
=
headers
.
get_raw
(
"
set
-
cookie
"
)
{
for
cookie
in
cookies
.
iter
(
)
{
if
let
Ok
(
cookie_value
)
=
String
:
:
from_utf8
(
cookie
.
clone
(
)
)
{
set_cookie_for_url
(
&
cookie_jar
&
url
cookie_value
)
;
}
}
}
}
struct
StreamedResponse
{
decoder
:
Decoder
}
impl
Read
for
StreamedResponse
{
#
[
inline
]
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
match
self
.
decoder
{
Decoder
:
:
Gzip
(
ref
mut
d
)
=
>
d
.
read
(
buf
)
Decoder
:
:
Deflate
(
ref
mut
d
)
=
>
d
.
read
(
buf
)
Decoder
:
:
Brotli
(
ref
mut
d
)
=
>
d
.
read
(
buf
)
Decoder
:
:
Plain
(
ref
mut
d
)
=
>
d
.
read
(
buf
)
}
}
}
impl
StreamedResponse
{
fn
from_http_response
(
response
:
WrappedHttpResponse
)
-
>
io
:
:
Result
<
StreamedResponse
>
{
let
decoder
=
match
response
.
content_encoding
(
)
{
Some
(
Encoding
:
:
Gzip
)
=
>
{
Decoder
:
:
Gzip
(
try
!
(
GzDecoder
:
:
new
(
response
)
)
)
}
Some
(
Encoding
:
:
Deflate
)
=
>
{
Decoder
:
:
Deflate
(
DeflateDecoder
:
:
new
(
response
)
)
}
Some
(
Encoding
:
:
EncodingExt
(
ref
ext
)
)
if
ext
=
=
"
br
"
=
>
{
Decoder
:
:
Brotli
(
Decompressor
:
:
new
(
response
1024
)
)
}
_
=
>
{
Decoder
:
:
Plain
(
response
)
}
}
;
Ok
(
StreamedResponse
{
decoder
:
decoder
}
)
}
}
enum
Decoder
{
Gzip
(
GzDecoder
<
WrappedHttpResponse
>
)
Deflate
(
DeflateDecoder
<
WrappedHttpResponse
>
)
Brotli
(
Decompressor
<
WrappedHttpResponse
>
)
Plain
(
WrappedHttpResponse
)
}
fn
prepare_devtools_request
(
request_id
:
String
url
:
ServoUrl
method
:
Method
headers
:
Headers
body
:
Option
<
Vec
<
u8
>
>
pipeline_id
:
PipelineId
now
:
Tm
connect_time
:
u64
send_time
:
u64
is_xhr
:
bool
)
-
>
ChromeToDevtoolsControlMsg
{
let
request
=
DevtoolsHttpRequest
{
url
:
url
method
:
method
headers
:
headers
body
:
body
pipeline_id
:
pipeline_id
startedDateTime
:
now
timeStamp
:
now
.
to_timespec
(
)
.
sec
connect_time
:
connect_time
send_time
:
send_time
is_xhr
:
is_xhr
}
;
let
net_event
=
NetworkEvent
:
:
HttpRequest
(
request
)
;
ChromeToDevtoolsControlMsg
:
:
NetworkEvent
(
request_id
net_event
)
}
fn
send_request_to_devtools
(
msg
:
ChromeToDevtoolsControlMsg
devtools_chan
:
&
Sender
<
DevtoolsControlMsg
>
)
{
devtools_chan
.
send
(
DevtoolsControlMsg
:
:
FromChrome
(
msg
)
)
.
unwrap
(
)
;
}
fn
send_response_to_devtools
(
devtools_chan
:
&
Sender
<
DevtoolsControlMsg
>
request_id
:
String
headers
:
Option
<
Headers
>
status
:
Option
<
(
u16
Vec
<
u8
>
)
>
pipeline_id
:
PipelineId
)
{
let
response
=
DevtoolsHttpResponse
{
headers
:
headers
status
:
status
body
:
None
pipeline_id
:
pipeline_id
}
;
let
net_event_response
=
NetworkEvent
:
:
HttpResponse
(
response
)
;
let
msg
=
ChromeToDevtoolsControlMsg
:
:
NetworkEvent
(
request_id
net_event_response
)
;
let
_
=
devtools_chan
.
send
(
DevtoolsControlMsg
:
:
FromChrome
(
msg
)
)
;
}
fn
auth_from_cache
(
auth_cache
:
&
Arc
<
RwLock
<
AuthCache
>
>
origin
:
&
ImmutableOrigin
)
-
>
Option
<
Basic
>
{
if
let
Some
(
ref
auth_entry
)
=
auth_cache
.
read
(
)
.
unwrap
(
)
.
entries
.
get
(
&
origin
.
ascii_serialization
(
)
)
{
let
user_name
=
auth_entry
.
user_name
.
clone
(
)
;
let
password
=
Some
(
auth_entry
.
password
.
clone
(
)
)
;
Some
(
Basic
{
username
:
user_name
password
:
password
}
)
}
else
{
None
}
}
fn
obtain_response
(
request_factory
:
&
NetworkHttpRequestFactory
url
:
&
ServoUrl
method
:
&
Method
request_headers
:
&
Headers
data
:
&
Option
<
Vec
<
u8
>
>
load_data_method
:
&
Method
pipeline_id
:
&
Option
<
PipelineId
>
iters
:
u32
request_id
:
Option
<
&
str
>
is_xhr
:
bool
)
-
>
Result
<
(
WrappedHttpResponse
Option
<
ChromeToDevtoolsControlMsg
>
)
NetworkError
>
{
let
null_data
=
None
;
loop
{
let
mut
headers
=
request_headers
.
clone
(
)
;
let
is_redirected_request
=
iters
!
=
1
;
let
request_body
;
match
data
{
&
Some
(
ref
d
)
if
!
is_redirected_request
=
>
{
headers
.
set
(
ContentLength
(
d
.
len
(
)
as
u64
)
)
;
request_body
=
data
;
}
_
=
>
{
if
*
load_data_method
!
=
Method
:
:
Get
&
&
*
load_data_method
!
=
Method
:
:
Head
{
headers
.
set
(
ContentLength
(
0
)
)
}
request_body
=
&
null_data
;
}
}
if
log_enabled
!
(
log
:
:
LogLevel
:
:
Info
)
{
info
!
(
"
{
}
{
}
"
method
url
)
;
for
header
in
headers
.
iter
(
)
{
info
!
(
"
-
{
}
"
header
)
;
}
info
!
(
"
{
:
?
}
"
data
)
;
}
let
connect_start
=
precise_time_ms
(
)
;
let
request
=
try
!
(
request_factory
.
create
(
url
.
clone
(
)
method
.
clone
(
)
headers
.
clone
(
)
)
)
;
let
connect_end
=
precise_time_ms
(
)
;
let
send_start
=
precise_time_ms
(
)
;
let
mut
request_writer
=
match
request
.
start
(
)
{
Ok
(
streaming
)
=
>
streaming
Err
(
e
)
=
>
return
Err
(
NetworkError
:
:
Internal
(
e
.
description
(
)
.
to_owned
(
)
)
)
}
;
if
let
Some
(
ref
data
)
=
*
request_body
{
if
let
Err
(
e
)
=
request_writer
.
write_all
(
&
data
)
{
return
Err
(
NetworkError
:
:
Internal
(
e
.
description
(
)
.
to_owned
(
)
)
)
}
}
let
response
=
match
request_writer
.
send
(
)
{
Ok
(
w
)
=
>
w
Err
(
HttpError
:
:
Io
(
ref
io_error
)
)
if
io_error
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
ConnectionAborted
=
>
{
debug
!
(
"
connection
aborted
(
{
:
?
}
)
possibly
stale
trying
new
connection
"
io_error
.
description
(
)
)
;
continue
;
}
Err
(
e
)
=
>
return
Err
(
NetworkError
:
:
Internal
(
e
.
description
(
)
.
to_owned
(
)
)
)
}
;
let
send_end
=
precise_time_ms
(
)
;
let
msg
=
if
let
Some
(
request_id
)
=
request_id
{
if
let
Some
(
pipeline_id
)
=
*
pipeline_id
{
Some
(
prepare_devtools_request
(
request_id
.
into
(
)
url
.
clone
(
)
method
.
clone
(
)
headers
request_body
.
clone
(
)
pipeline_id
time
:
:
now
(
)
connect_end
-
connect_start
send_end
-
send_start
is_xhr
)
)
}
else
{
debug
!
(
"
Not
notifying
devtools
(
no
pipeline_id
)
"
)
;
None
}
}
else
{
debug
!
(
"
Not
notifying
devtools
(
no
request_id
)
"
)
;
None
}
;
return
Ok
(
(
WrappedHttpResponse
{
response
:
response
}
msg
)
)
;
}
}
fn
is_cert_verify_error
(
error
:
&
OpensslError
)
-
>
bool
{
match
error
{
&
OpensslError
:
:
UnknownError
{
ref
library
ref
function
ref
reason
}
=
>
{
library
=
=
"
SSL
routines
"
&
&
function
.
to_uppercase
(
)
=
=
"
SSL3_GET_SERVER_CERTIFICATE
"
&
&
reason
=
=
"
certificate
verify
failed
"
}
}
}
fn
is_unknown_message_digest_err
(
error
:
&
OpensslError
)
-
>
bool
{
match
error
{
&
OpensslError
:
:
UnknownError
{
ref
library
ref
function
ref
reason
}
=
>
{
library
=
=
"
asn1
encoding
routines
"
&
&
function
=
=
"
ASN1_item_verify
"
&
&
reason
=
=
"
unknown
message
digest
algorithm
"
}
}
}
fn
format_ssl_error
(
error
:
&
OpensslError
)
-
>
String
{
match
error
{
&
OpensslError
:
:
UnknownError
{
ref
library
ref
function
ref
reason
}
=
>
{
format
!
(
"
{
}
:
{
}
-
{
}
"
library
function
reason
)
}
}
}
pub
fn
http_fetch
(
request
:
Rc
<
Request
>
cache
:
&
mut
CorsCache
cors_flag
:
bool
cors_preflight_flag
:
bool
authentication_fetch_flag
:
bool
target
:
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
*
done_chan
=
None
;
let
mut
response
:
Option
<
Response
>
=
None
;
if
!
request
.
skip_service_worker
.
get
(
)
&
&
!
request
.
is_service_worker_global_scope
{
if
let
Some
(
ref
res
)
=
response
{
if
(
res
.
response_type
=
=
ResponseType
:
:
Opaque
&
&
request
.
mode
!
=
RequestMode
:
:
NoCors
)
|
|
(
res
.
response_type
=
=
ResponseType
:
:
OpaqueRedirect
&
&
request
.
redirect_mode
.
get
(
)
!
=
RedirectMode
:
:
Manual
)
|
|
(
res
.
url_list
.
borrow
(
)
.
len
(
)
>
1
&
&
request
.
redirect_mode
.
get
(
)
!
=
RedirectMode
:
:
Follow
)
|
|
res
.
is_network_error
(
)
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Request
failed
"
.
into
(
)
)
)
;
}
}
}
let
credentials
=
match
request
.
credentials_mode
{
CredentialsMode
:
:
Include
=
>
true
CredentialsMode
:
:
CredentialsSameOrigin
if
request
.
response_tainting
.
get
(
)
=
=
ResponseTainting
:
:
Basic
=
>
true
_
=
>
false
}
;
if
response
.
is_none
(
)
{
if
cors_preflight_flag
{
let
method_cache_match
=
cache
.
match_method
(
&
*
request
request
.
method
.
borrow
(
)
.
clone
(
)
)
;
let
method_mismatch
=
!
method_cache_match
&
&
(
!
is_simple_method
(
&
request
.
method
.
borrow
(
)
)
|
|
request
.
use_cors_preflight
)
;
let
header_mismatch
=
request
.
headers
.
borrow
(
)
.
iter
(
)
.
any
(
|
view
|
!
cache
.
match_header
(
&
*
request
view
.
name
(
)
)
&
&
!
is_simple_header
(
&
view
)
)
;
if
method_mismatch
|
|
header_mismatch
{
let
preflight_result
=
cors_preflight_fetch
(
request
.
clone
(
)
cache
context
)
;
if
let
Some
(
e
)
=
preflight_result
.
get_network_error
(
)
{
return
Response
:
:
network_error
(
e
.
clone
(
)
)
;
}
}
}
request
.
skip_service_worker
.
set
(
true
)
;
let
fetch_result
=
http_network_or_cache_fetch
(
request
.
clone
(
)
authentication_fetch_flag
cors_flag
done_chan
context
)
;
if
cors_flag
&
&
cors_check
(
request
.
clone
(
)
&
fetch_result
)
.
is_err
(
)
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
check
failed
"
.
into
(
)
)
)
;
}
fetch_result
.
return_internal
.
set
(
false
)
;
response
=
Some
(
fetch_result
)
;
}
let
mut
response
=
response
.
unwrap
(
)
;
match
response
.
actual_response
(
)
.
status
{
status
if
status
.
map_or
(
false
is_redirect_status
)
=
>
{
response
=
match
request
.
redirect_mode
.
get
(
)
{
RedirectMode
:
:
Error
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Redirect
mode
error
"
.
into
(
)
)
)
RedirectMode
:
:
Manual
=
>
{
response
.
to_filtered
(
ResponseType
:
:
OpaqueRedirect
)
}
RedirectMode
:
:
Follow
=
>
{
response
.
return_internal
.
set
(
true
)
;
http_redirect_fetch
(
request
cache
response
cors_flag
target
done_chan
context
)
}
}
}
Some
(
StatusCode
:
:
Unauthorized
)
=
>
{
if
cors_flag
|
|
!
credentials
{
return
response
;
}
if
!
request
.
use_url_credentials
|
|
authentication_fetch_flag
{
return
response
;
}
return
http_fetch
(
request
cache
cors_flag
cors_preflight_flag
true
target
done_chan
context
)
;
}
Some
(
StatusCode
:
:
ProxyAuthenticationRequired
)
=
>
{
return
response
;
}
_
=
>
{
}
}
if
authentication_fetch_flag
{
}
response
.
return_internal
.
set
(
true
)
;
response
}
fn
http_redirect_fetch
(
request
:
Rc
<
Request
>
cache
:
&
mut
CorsCache
response
:
Response
cors_flag
:
bool
target
:
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
assert_eq
!
(
response
.
return_internal
.
get
(
)
true
)
;
if
!
response
.
actual_response
(
)
.
headers
.
has
:
:
<
Location
>
(
)
{
return
response
;
}
let
location
=
match
response
.
actual_response
(
)
.
headers
.
get
:
:
<
Location
>
(
)
{
Some
(
&
Location
(
ref
location
)
)
=
>
location
.
clone
(
)
_
=
>
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Location
header
parsing
failure
"
.
into
(
)
)
)
}
;
let
response_url
=
response
.
actual_response
(
)
.
url
(
)
.
unwrap
(
)
;
let
location_url
=
response_url
.
join
(
&
*
location
)
;
let
location_url
=
match
location_url
{
Ok
(
url
)
=
>
url
_
=
>
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Location
URL
parsing
failure
"
.
into
(
)
)
)
}
;
match
location_url
.
scheme
(
)
{
"
http
"
|
"
https
"
=
>
{
}
_
=
>
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Not
an
HTTP
(
S
)
Scheme
"
.
into
(
)
)
)
}
if
request
.
redirect_count
.
get
(
)
>
=
20
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Too
many
redirects
"
.
into
(
)
)
)
;
}
request
.
redirect_count
.
set
(
request
.
redirect_count
.
get
(
)
+
1
)
;
let
same_origin
=
location_url
.
origin
(
)
=
=
request
.
current_url
(
)
.
origin
(
)
;
let
has_credentials
=
has_credentials
(
&
location_url
)
;
if
request
.
mode
=
=
RequestMode
:
:
CorsMode
&
&
!
same_origin
&
&
has_credentials
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Cross
-
origin
credentials
check
failed
"
.
into
(
)
)
)
;
}
if
cors_flag
&
&
has_credentials
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Credentials
check
failed
"
.
into
(
)
)
)
;
}
if
cors_flag
&
&
!
same_origin
{
*
request
.
origin
.
borrow_mut
(
)
=
Origin
:
:
Origin
(
ImmutableOrigin
:
:
new_opaque
(
)
)
;
}
let
status_code
=
response
.
actual_response
(
)
.
status
.
unwrap
(
)
;
if
(
(
status_code
=
=
StatusCode
:
:
MovedPermanently
|
|
status_code
=
=
StatusCode
:
:
Found
)
&
&
*
request
.
method
.
borrow
(
)
=
=
Method
:
:
Post
)
|
|
status_code
=
=
StatusCode
:
:
SeeOther
{
*
request
.
method
.
borrow_mut
(
)
=
Method
:
:
Get
;
*
request
.
body
.
borrow_mut
(
)
=
None
;
}
request
.
url_list
.
borrow_mut
(
)
.
push
(
location_url
)
;
main_fetch
(
request
cache
cors_flag
true
target
done_chan
context
)
}
fn
try_immutable_origin_to_hyper_origin
(
url_origin
:
&
ImmutableOrigin
)
-
>
Option
<
HyperOrigin
>
{
match
*
url_origin
{
ImmutableOrigin
:
:
Opaque
(
_
)
=
>
None
ImmutableOrigin
:
:
Tuple
(
ref
scheme
ref
host
ref
port
)
=
>
Some
(
HyperOrigin
:
:
new
(
scheme
.
clone
(
)
host
.
to_string
(
)
Some
(
port
.
clone
(
)
)
)
)
}
}
fn
http_network_or_cache_fetch
(
request
:
Rc
<
Request
>
authentication_fetch_flag
:
bool
cors_flag
:
bool
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
request_has_no_window
=
true
;
let
http_request
=
if
request_has_no_window
&
&
request
.
redirect_mode
.
get
(
)
=
=
RedirectMode
:
:
Error
{
request
}
else
{
Rc
:
:
new
(
(
*
request
)
.
clone
(
)
)
}
;
let
credentials_flag
=
match
http_request
.
credentials_mode
{
CredentialsMode
:
:
Include
=
>
true
CredentialsMode
:
:
CredentialsSameOrigin
if
http_request
.
response_tainting
.
get
(
)
=
=
ResponseTainting
:
:
Basic
=
>
true
_
=
>
false
}
;
let
content_length_value
=
match
*
http_request
.
body
.
borrow
(
)
{
None
=
>
match
*
http_request
.
method
.
borrow
(
)
{
Method
:
:
Post
|
Method
:
:
Put
=
>
Some
(
0
)
_
=
>
None
}
Some
(
ref
http_request_body
)
=
>
Some
(
http_request_body
.
len
(
)
as
u64
)
}
;
if
let
Some
(
content_length_value
)
=
content_length_value
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
ContentLength
(
content_length_value
)
)
;
}
match
*
http_request
.
referrer
.
borrow
(
)
{
Referrer
:
:
NoReferrer
=
>
(
)
Referrer
:
:
ReferrerUrl
(
ref
http_request_referrer
)
=
>
http_request
.
headers
.
borrow_mut
(
)
.
set
(
Referer
(
http_request_referrer
.
to_string
(
)
)
)
Referrer
:
:
Client
=
>
unreachable
!
(
)
}
;
if
!
http_request
.
omit_origin_header
.
get
(
)
{
let
method
=
http_request
.
method
.
borrow
(
)
;
if
cors_flag
|
|
(
*
method
!
=
Method
:
:
Get
&
&
*
method
!
=
Method
:
:
Head
)
{
debug_assert
!
(
*
http_request
.
origin
.
borrow
(
)
!
=
Origin
:
:
Client
)
;
if
let
Origin
:
:
Origin
(
ref
url_origin
)
=
*
http_request
.
origin
.
borrow
(
)
{
if
let
Some
(
hyper_origin
)
=
try_immutable_origin_to_hyper_origin
(
url_origin
)
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
hyper_origin
)
}
}
}
}
if
!
http_request
.
headers
.
borrow
(
)
.
has
:
:
<
UserAgent
>
(
)
{
let
user_agent
=
context
.
user_agent
.
clone
(
)
.
into_owned
(
)
;
http_request
.
headers
.
borrow_mut
(
)
.
set
(
UserAgent
(
user_agent
)
)
;
}
match
http_request
.
cache_mode
.
get
(
)
{
CacheMode
:
:
Default
if
is_no_store_cache
(
&
http_request
.
headers
.
borrow
(
)
)
=
>
{
http_request
.
cache_mode
.
set
(
CacheMode
:
:
NoStore
)
;
}
CacheMode
:
:
NoCache
if
!
http_request
.
headers
.
borrow
(
)
.
has
:
:
<
CacheControl
>
(
)
=
>
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
CacheControl
(
vec
!
[
CacheDirective
:
:
MaxAge
(
0
)
]
)
)
;
}
CacheMode
:
:
Reload
|
CacheMode
:
:
NoStore
=
>
{
if
!
http_request
.
headers
.
borrow
(
)
.
has
:
:
<
Pragma
>
(
)
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
Pragma
:
:
NoCache
)
;
}
if
!
http_request
.
headers
.
borrow
(
)
.
has
:
:
<
CacheControl
>
(
)
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
CacheControl
(
vec
!
[
CacheDirective
:
:
NoCache
]
)
)
;
}
}
_
=
>
{
}
}
let
current_url
=
http_request
.
current_url
(
)
;
{
let
headers
=
&
mut
*
http_request
.
headers
.
borrow_mut
(
)
;
let
host
=
Host
{
hostname
:
current_url
.
host_str
(
)
.
unwrap
(
)
.
to_owned
(
)
port
:
current_url
.
port
(
)
}
;
headers
.
set
(
host
)
;
set_default_accept_encoding
(
headers
)
;
}
if
credentials_flag
{
set_request_cookies
(
&
current_url
&
mut
*
http_request
.
headers
.
borrow_mut
(
)
&
context
.
state
.
cookie_jar
)
;
if
!
http_request
.
headers
.
borrow
(
)
.
has
:
:
<
Authorization
<
String
>
>
(
)
{
let
mut
authorization_value
=
None
;
if
let
Some
(
basic
)
=
auth_from_cache
(
&
context
.
state
.
auth_cache
&
current_url
.
origin
(
)
)
{
if
!
http_request
.
use_url_credentials
|
|
!
has_credentials
(
&
current_url
)
{
authorization_value
=
Some
(
basic
)
;
}
}
if
authentication_fetch_flag
&
&
authorization_value
.
is_none
(
)
{
if
has_credentials
(
&
current_url
)
{
authorization_value
=
Some
(
Basic
{
username
:
current_url
.
username
(
)
.
to_owned
(
)
password
:
current_url
.
password
(
)
.
map
(
str
:
:
to_owned
)
}
)
}
}
if
let
Some
(
basic
)
=
authorization_value
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
Authorization
(
basic
)
)
;
}
}
}
let
mut
response
:
Option
<
Response
>
=
None
;
let
complete_http_response_from_cache
:
Option
<
Response
>
=
None
;
if
http_request
.
cache_mode
.
get
(
)
!
=
CacheMode
:
:
NoStore
&
&
http_request
.
cache_mode
.
get
(
)
!
=
CacheMode
:
:
Reload
&
&
complete_http_response_from_cache
.
is_some
(
)
{
if
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
ForceCache
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
OnlyIfCached
{
}
let
revalidation_needed
=
match
response
{
Some
(
ref
response
)
=
>
response_needs_revalidation
(
&
response
)
_
=
>
false
}
;
if
!
revalidation_needed
&
&
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
{
}
if
revalidation_needed
&
&
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
NoCache
{
}
}
else
if
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
ForceCache
{
}
if
response
.
is_none
(
)
{
if
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
OnlyIfCached
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Couldn
'
t
find
response
in
cache
"
.
into
(
)
)
)
}
response
=
Some
(
http_network_fetch
(
http_request
.
clone
(
)
credentials_flag
done_chan
context
)
)
;
}
let
response
=
response
.
unwrap
(
)
;
if
let
Some
(
status
)
=
response
.
status
{
match
status
{
StatusCode
:
:
NotModified
=
>
{
if
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
NoCache
{
}
}
StatusCode
:
:
Unauthorized
=
>
{
if
cors_flag
&
&
!
credentials_flag
{
return
response
;
}
if
!
http_request
.
use_url_credentials
|
|
authentication_fetch_flag
{
return
response
;
}
return
http_network_or_cache_fetch
(
http_request
true
cors_flag
done_chan
context
)
;
}
StatusCode
:
:
ProxyAuthenticationRequired
=
>
{
return
response
;
}
_
=
>
{
}
}
}
if
authentication_fetch_flag
{
}
response
}
fn
http_network_fetch
(
request
:
Rc
<
Request
>
credentials_flag
:
bool
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
factory
=
NetworkHttpRequestFactory
{
connector
:
context
.
state
.
connector_pool
.
clone
(
)
}
;
let
url
=
request
.
current_url
(
)
;
let
request_id
=
context
.
devtools_chan
.
as_ref
(
)
.
map
(
|
_
|
{
uuid
:
:
Uuid
:
:
new_v4
(
)
.
simple
(
)
.
to_string
(
)
}
)
;
let
is_xhr
=
request
.
destination
=
=
Destination
:
:
None
;
let
wrapped_response
=
obtain_response
(
&
factory
&
url
&
request
.
method
.
borrow
(
)
&
request
.
headers
.
borrow
(
)
&
request
.
body
.
borrow
(
)
&
request
.
method
.
borrow
(
)
&
request
.
pipeline_id
.
get
(
)
request
.
redirect_count
.
get
(
)
+
1
request_id
.
as_ref
(
)
.
map
(
Deref
:
:
deref
)
is_xhr
)
;
let
pipeline_id
=
request
.
pipeline_id
.
get
(
)
;
let
(
res
msg
)
=
match
wrapped_response
{
Ok
(
wrapped_response
)
=
>
wrapped_response
Err
(
error
)
=
>
return
Response
:
:
network_error
(
error
)
}
;
let
mut
response
=
Response
:
:
new
(
url
.
clone
(
)
)
;
response
.
status
=
Some
(
res
.
response
.
status
)
;
response
.
raw_status
=
Some
(
(
res
.
response
.
status_raw
(
)
.
0
res
.
response
.
status_raw
(
)
.
1
.
as_bytes
(
)
.
to_vec
(
)
)
)
;
response
.
headers
=
res
.
response
.
headers
.
clone
(
)
;
response
.
referrer
=
request
.
referrer
.
borrow
(
)
.
to_url
(
)
.
cloned
(
)
;
let
res_body
=
response
.
body
.
clone
(
)
;
let
(
done_sender
done_receiver
)
=
channel
(
)
;
*
done_chan
=
Some
(
(
done_sender
.
clone
(
)
done_receiver
)
)
;
let
meta
=
match
response
.
metadata
(
)
.
expect
(
"
Response
metadata
should
exist
at
this
stage
"
)
{
FetchMetadata
:
:
Unfiltered
(
m
)
=
>
m
FetchMetadata
:
:
Filtered
{
unsafe_
.
.
}
=
>
unsafe_
}
;
let
devtools_sender
=
context
.
devtools_chan
.
clone
(
)
;
let
meta_status
=
meta
.
status
.
clone
(
)
;
let
meta_headers
=
meta
.
headers
.
clone
(
)
;
thread
:
:
Builder
:
:
new
(
)
.
name
(
format
!
(
"
fetch
worker
thread
"
)
)
.
spawn
(
move
|
|
{
match
StreamedResponse
:
:
from_http_response
(
res
)
{
Ok
(
mut
res
)
=
>
{
*
res_body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Receiving
(
vec
!
[
]
)
;
if
let
Some
(
ref
sender
)
=
devtools_sender
{
if
let
Some
(
m
)
=
msg
{
send_request_to_devtools
(
m
&
sender
)
;
}
if
let
Some
(
pipeline_id
)
=
pipeline_id
{
send_response_to_devtools
(
&
sender
request_id
.
unwrap
(
)
meta_headers
.
map
(
Serde
:
:
into_inner
)
meta_status
pipeline_id
)
;
}
}
loop
{
match
read_block
(
&
mut
res
)
{
Ok
(
Data
:
:
Payload
(
chunk
)
)
=
>
{
if
let
ResponseBody
:
:
Receiving
(
ref
mut
body
)
=
*
res_body
.
lock
(
)
.
unwrap
(
)
{
body
.
extend_from_slice
(
&
chunk
)
;
let
_
=
done_sender
.
send
(
Data
:
:
Payload
(
chunk
)
)
;
}
}
Ok
(
Data
:
:
Done
)
|
Err
(
_
)
=
>
{
let
mut
body
=
res_body
.
lock
(
)
.
unwrap
(
)
;
let
completed_body
=
match
*
body
{
ResponseBody
:
:
Receiving
(
ref
mut
body
)
=
>
{
mem
:
:
replace
(
body
vec
!
[
]
)
}
_
=
>
vec
!
[
]
}
;
*
body
=
ResponseBody
:
:
Done
(
completed_body
)
;
let
_
=
done_sender
.
send
(
Data
:
:
Done
)
;
break
;
}
}
}
}
Err
(
_
)
=
>
{
*
res_body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
vec
!
[
]
)
;
let
_
=
done_sender
.
send
(
Data
:
:
Done
)
;
}
}
}
)
.
expect
(
"
Thread
spawning
failed
"
)
;
response
.
https_state
=
HttpsState
:
:
None
;
if
let
Some
(
encoding
)
=
response
.
headers
.
get
:
:
<
ContentEncoding
>
(
)
{
if
encoding
.
contains
(
&
Encoding
:
:
Gzip
)
{
}
else
if
encoding
.
contains
(
&
Encoding
:
:
Compress
)
{
}
}
;
if
response
.
is_network_error
(
)
&
&
request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
NoStore
{
}
if
credentials_flag
{
set_cookies_from_headers
(
&
url
&
response
.
headers
&
context
.
state
.
cookie_jar
)
;
}
response
}
fn
cors_preflight_fetch
(
request
:
Rc
<
Request
>
cache
:
&
mut
CorsCache
context
:
&
FetchContext
)
-
>
Response
{
let
mut
preflight
=
Request
:
:
new
(
request
.
current_url
(
)
Some
(
request
.
origin
.
borrow
(
)
.
clone
(
)
)
request
.
is_service_worker_global_scope
request
.
pipeline_id
.
get
(
)
)
;
*
preflight
.
method
.
borrow_mut
(
)
=
Method
:
:
Options
;
preflight
.
initiator
=
request
.
initiator
.
clone
(
)
;
preflight
.
type_
=
request
.
type_
.
clone
(
)
;
preflight
.
destination
=
request
.
destination
.
clone
(
)
;
*
preflight
.
referrer
.
borrow_mut
(
)
=
request
.
referrer
.
borrow
(
)
.
clone
(
)
;
preflight
.
referrer_policy
.
set
(
request
.
referrer_policy
.
get
(
)
)
;
preflight
.
headers
.
borrow_mut
(
)
.
set
:
:
<
AccessControlRequestMethod
>
(
AccessControlRequestMethod
(
request
.
method
.
borrow
(
)
.
clone
(
)
)
)
;
let
mut
value
=
request
.
headers
.
borrow
(
)
.
iter
(
)
.
filter
(
|
view
|
!
is_simple_header
(
view
)
)
.
map
(
|
view
|
UniCase
(
view
.
name
(
)
.
to_owned
(
)
)
)
.
collect
:
:
<
Vec
<
UniCase
<
String
>
>
>
(
)
;
value
.
sort
(
)
;
preflight
.
headers
.
borrow_mut
(
)
.
set
:
:
<
AccessControlRequestHeaders
>
(
AccessControlRequestHeaders
(
value
)
)
;
let
preflight
=
Rc
:
:
new
(
preflight
)
;
let
response
=
http_network_or_cache_fetch
(
preflight
.
clone
(
)
false
false
&
mut
None
context
)
;
if
cors_check
(
request
.
clone
(
)
&
response
)
.
is_ok
(
)
&
&
response
.
status
.
map_or
(
false
|
status
|
status
.
is_success
(
)
)
{
let
mut
methods
=
if
response
.
headers
.
has
:
:
<
AccessControlAllowMethods
>
(
)
{
match
response
.
headers
.
get
:
:
<
AccessControlAllowMethods
>
(
)
{
Some
(
&
AccessControlAllowMethods
(
ref
m
)
)
=
>
m
.
clone
(
)
None
=
>
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
ACAM
check
failed
"
.
into
(
)
)
)
}
}
else
{
vec
!
[
]
}
;
let
header_names
=
if
response
.
headers
.
has
:
:
<
AccessControlAllowHeaders
>
(
)
{
match
response
.
headers
.
get
:
:
<
AccessControlAllowHeaders
>
(
)
{
Some
(
&
AccessControlAllowHeaders
(
ref
hn
)
)
=
>
hn
.
clone
(
)
None
=
>
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
ACAH
check
failed
"
.
into
(
)
)
)
}
}
else
{
vec
!
[
]
}
;
if
methods
.
is_empty
(
)
&
&
request
.
use_cors_preflight
{
methods
=
vec
!
[
request
.
method
.
borrow
(
)
.
clone
(
)
]
;
}
debug
!
(
"
CORS
check
:
Allowed
methods
:
{
:
?
}
current
method
:
{
:
?
}
"
methods
request
.
method
.
borrow
(
)
)
;
if
methods
.
iter
(
)
.
all
(
|
method
|
*
method
!
=
*
request
.
method
.
borrow
(
)
)
&
&
!
is_simple_method
(
&
*
request
.
method
.
borrow
(
)
)
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
method
check
failed
"
.
into
(
)
)
)
;
}
debug
!
(
"
CORS
check
:
Allowed
headers
:
{
:
?
}
current
headers
:
{
:
?
}
"
header_names
request
.
headers
.
borrow
(
)
)
;
let
set
:
HashSet
<
&
UniCase
<
String
>
>
=
HashSet
:
:
from_iter
(
header_names
.
iter
(
)
)
;
if
request
.
headers
.
borrow
(
)
.
iter
(
)
.
any
(
|
ref
hv
|
!
set
.
contains
(
&
UniCase
(
hv
.
name
(
)
.
to_owned
(
)
)
)
&
&
!
is_simple_header
(
hv
)
)
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
headers
check
failed
"
.
into
(
)
)
)
;
}
let
max_age
=
response
.
headers
.
get
:
:
<
AccessControlMaxAge
>
(
)
.
map
(
|
acma
|
acma
.
0
)
.
unwrap_or
(
0
)
;
for
method
in
&
methods
{
cache
.
match_method_and_update
(
&
*
request
method
.
clone
(
)
max_age
)
;
}
for
header_name
in
&
header_names
{
cache
.
match_header_and_update
(
&
*
request
&
*
header_name
max_age
)
;
}
return
response
;
}
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
CORS
check
failed
"
.
into
(
)
)
)
}
fn
cors_check
(
request
:
Rc
<
Request
>
response
:
&
Response
)
-
>
Result
<
(
)
(
)
>
{
let
origin
=
response
.
headers
.
get
:
:
<
AccessControlAllowOrigin
>
(
)
.
cloned
(
)
;
let
origin
=
try
!
(
origin
.
ok_or
(
(
)
)
)
;
if
request
.
credentials_mode
!
=
CredentialsMode
:
:
Include
&
&
origin
=
=
AccessControlAllowOrigin
:
:
Any
{
return
Ok
(
(
)
)
;
}
let
origin
=
match
origin
{
AccessControlAllowOrigin
:
:
Value
(
origin
)
=
>
origin
_
=
>
return
Err
(
(
)
)
}
;
match
*
request
.
origin
.
borrow
(
)
{
Origin
:
:
Origin
(
ref
o
)
if
o
.
ascii_serialization
(
)
=
=
origin
=
>
{
}
_
=
>
return
Err
(
(
)
)
}
if
request
.
credentials_mode
!
=
CredentialsMode
:
:
Include
{
return
Ok
(
(
)
)
;
}
let
credentials
=
response
.
headers
.
get
:
:
<
AccessControlAllowCredentials
>
(
)
.
cloned
(
)
;
if
credentials
.
is_some
(
)
{
return
Ok
(
(
)
)
;
}
Err
(
(
)
)
}
fn
has_credentials
(
url
:
&
ServoUrl
)
-
>
bool
{
!
url
.
username
(
)
.
is_empty
(
)
|
|
url
.
password
(
)
.
is_some
(
)
}
fn
is_no_store_cache
(
headers
:
&
Headers
)
-
>
bool
{
headers
.
has
:
:
<
IfModifiedSince
>
(
)
|
headers
.
has
:
:
<
IfNoneMatch
>
(
)
|
headers
.
has
:
:
<
IfUnmodifiedSince
>
(
)
|
headers
.
has
:
:
<
IfMatch
>
(
)
|
headers
.
has
:
:
<
IfRange
>
(
)
}
fn
response_needs_revalidation
(
_response
:
&
Response
)
-
>
bool
{
false
}
fn
is_redirect_status
(
status
:
StatusCode
)
-
>
bool
{
match
status
{
StatusCode
:
:
MovedPermanently
|
StatusCode
:
:
Found
|
StatusCode
:
:
SeeOther
|
StatusCode
:
:
TemporaryRedirect
|
StatusCode
:
:
PermanentRedirect
=
>
true
_
=
>
false
}
}
