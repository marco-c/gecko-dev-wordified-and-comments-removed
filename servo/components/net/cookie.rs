use
cookie_rs
;
use
net_traits
:
:
CookieSource
;
use
net_traits
:
:
pub_domains
:
:
is_pub_domain
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
net
:
:
{
Ipv4Addr
Ipv6Addr
}
;
use
time
:
:
{
Tm
now
at
Duration
}
;
#
[
derive
(
Clone
Debug
RustcDecodable
RustcEncodable
)
]
pub
struct
Cookie
{
pub
cookie
:
cookie_rs
:
:
Cookie
pub
host_only
:
bool
pub
persistent
:
bool
pub
creation_time
:
Tm
pub
last_access
:
Tm
pub
expiry_time
:
Option
<
Tm
>
}
impl
Cookie
{
pub
fn
new_wrapped
(
mut
cookie
:
cookie_rs
:
:
Cookie
request
:
&
ServoUrl
source
:
CookieSource
)
-
>
Option
<
Cookie
>
{
let
(
persistent
expiry_time
)
=
match
(
&
cookie
.
max_age
&
cookie
.
expires
)
{
(
&
Some
(
max_age
)
_
)
=
>
{
(
true
Some
(
at
(
now
(
)
.
to_timespec
(
)
+
Duration
:
:
seconds
(
max_age
as
i64
)
)
)
)
}
(
_
&
Some
(
expires
)
)
=
>
(
true
Some
(
expires
)
)
_
=
>
(
false
None
)
}
;
let
url_host
=
request
.
host_str
(
)
.
unwrap_or
(
"
"
)
.
to_owned
(
)
;
let
mut
domain
=
cookie
.
domain
.
clone
(
)
.
unwrap_or
(
"
"
.
to_owned
(
)
)
;
if
is_pub_domain
(
&
domain
)
{
if
domain
=
=
url_host
{
domain
=
"
"
.
to_owned
(
)
;
}
else
{
return
None
}
}
let
host_only
=
if
!
domain
.
is_empty
(
)
{
if
!
Cookie
:
:
domain_match
(
&
url_host
&
domain
)
{
return
None
;
}
else
{
cookie
.
domain
=
Some
(
domain
)
;
false
}
}
else
{
cookie
.
domain
=
Some
(
url_host
)
;
true
}
;
let
mut
path
=
cookie
.
path
.
unwrap_or
(
"
"
.
to_owned
(
)
)
;
if
path
.
chars
(
)
.
next
(
)
!
=
Some
(
'
/
'
)
{
path
=
Cookie
:
:
default_path
(
request
.
path
(
)
)
.
to_owned
(
)
;
}
cookie
.
path
=
Some
(
path
)
;
if
cookie
.
httponly
&
&
source
!
=
CookieSource
:
:
HTTP
{
return
None
;
}
Some
(
Cookie
{
cookie
:
cookie
host_only
:
host_only
persistent
:
persistent
creation_time
:
now
(
)
last_access
:
now
(
)
expiry_time
:
expiry_time
}
)
}
pub
fn
touch
(
&
mut
self
)
{
self
.
last_access
=
now
(
)
;
}
pub
fn
default_path
(
request_path
:
&
str
)
-
>
&
str
{
if
request_path
.
chars
(
)
.
next
(
)
!
=
Some
(
'
/
'
)
{
return
"
/
"
;
}
let
rightmost_slash_idx
=
request_path
.
rfind
(
"
/
"
)
.
unwrap
(
)
;
if
rightmost_slash_idx
=
=
0
{
return
"
/
"
;
}
&
request_path
[
.
.
rightmost_slash_idx
]
}
pub
fn
path_match
(
request_path
:
&
str
cookie_path
:
&
str
)
-
>
bool
{
request_path
=
=
cookie_path
|
|
(
request_path
.
starts_with
(
cookie_path
)
&
&
(
cookie_path
.
ends_with
(
"
/
"
)
|
|
request_path
[
cookie_path
.
len
(
)
.
.
]
.
starts_with
(
"
/
"
)
)
)
}
pub
fn
domain_match
(
string
:
&
str
domain_string
:
&
str
)
-
>
bool
{
if
string
=
=
domain_string
{
return
true
;
}
if
string
.
ends_with
(
domain_string
)
&
&
string
.
as_bytes
(
)
[
string
.
len
(
)
-
domain_string
.
len
(
)
-
1
]
=
=
b
'
.
'
&
&
string
.
parse
:
:
<
Ipv4Addr
>
(
)
.
is_err
(
)
&
&
string
.
parse
:
:
<
Ipv6Addr
>
(
)
.
is_err
(
)
{
return
true
;
}
false
}
pub
fn
appropriate_for_url
(
&
self
url
:
&
ServoUrl
source
:
CookieSource
)
-
>
bool
{
let
domain
=
url
.
host_str
(
)
;
if
self
.
host_only
{
if
self
.
cookie
.
domain
.
as_ref
(
)
.
map
(
String
:
:
as_str
)
!
=
domain
{
return
false
;
}
}
else
{
if
let
(
Some
(
domain
)
&
Some
(
ref
cookie_domain
)
)
=
(
domain
&
self
.
cookie
.
domain
)
{
if
!
Cookie
:
:
domain_match
(
domain
cookie_domain
)
{
return
false
;
}
}
}
if
let
Some
(
ref
cookie_path
)
=
self
.
cookie
.
path
{
if
!
Cookie
:
:
path_match
(
url
.
path
(
)
cookie_path
)
{
return
false
;
}
}
if
self
.
cookie
.
secure
&
&
url
.
scheme
(
)
!
=
"
https
"
{
return
false
;
}
if
self
.
cookie
.
httponly
&
&
source
=
=
CookieSource
:
:
NonHTTP
{
return
false
;
}
true
}
}
