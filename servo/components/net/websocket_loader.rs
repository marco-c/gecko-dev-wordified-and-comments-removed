use
cookie
:
:
Cookie
;
use
fetch
:
:
methods
:
:
{
should_be_blocked_due_to_bad_port
should_be_blocked_due_to_nosniff
}
;
use
hosts
:
:
replace_host
;
use
http_loader
:
:
{
HttpState
is_redirect_status
set_default_accept
}
;
use
http_loader
:
:
{
set_default_accept_language
set_request_cookies
}
;
use
hyper
:
:
buffer
:
:
BufReader
;
use
hyper
:
:
header
:
:
{
CacheControl
CacheDirective
Connection
ConnectionOption
}
;
use
hyper
:
:
header
:
:
{
Headers
Host
SetCookie
Pragma
Protocol
ProtocolName
Upgrade
}
;
use
hyper
:
:
http
:
:
h1
:
:
{
LINE_ENDING
parse_response
}
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
net
:
:
HttpStream
;
use
hyper
:
:
status
:
:
StatusCode
;
use
hyper
:
:
version
:
:
HttpVersion
;
use
net_traits
:
:
{
CookieSource
MessageData
NetworkError
WebSocketCommunicate
WebSocketConnectData
}
;
use
net_traits
:
:
{
WebSocketDomAction
WebSocketNetworkEvent
}
;
use
net_traits
:
:
request
:
:
{
Destination
Type
}
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
std
:
:
net
:
:
TcpStream
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
std
:
:
thread
;
use
url
:
:
Position
;
use
websocket
:
:
{
Message
Receiver
as
WSReceiver
Sender
as
WSSender
}
;
use
websocket
:
:
header
:
:
{
Origin
WebSocketAccept
WebSocketKey
WebSocketProtocol
WebSocketVersion
}
;
use
websocket
:
:
message
:
:
Type
as
MessageType
;
use
websocket
:
:
receiver
:
:
Receiver
;
use
websocket
:
:
sender
:
:
Sender
;
pub
fn
init
(
connect
:
WebSocketCommunicate
connect_data
:
WebSocketConnectData
http_state
:
Arc
<
HttpState
>
)
{
thread
:
:
Builder
:
:
new
(
)
.
name
(
format
!
(
"
WebSocket
connection
to
{
}
"
connect_data
.
resource_url
)
)
.
spawn
(
move
|
|
{
let
channel
=
establish_a_websocket_connection
(
connect_data
.
resource_url
connect_data
.
origin
connect_data
.
protocols
&
http_state
)
;
let
(
ws_sender
mut
receiver
)
=
match
channel
{
Ok
(
(
protocol_in_use
sender
receiver
)
)
=
>
{
let
_
=
connect
.
event_sender
.
send
(
WebSocketNetworkEvent
:
:
ConnectionEstablished
{
protocol_in_use
}
)
;
(
sender
receiver
)
}
Err
(
e
)
=
>
{
debug
!
(
"
Failed
to
establish
a
WebSocket
connection
:
{
:
?
}
"
e
)
;
let
_
=
connect
.
event_sender
.
send
(
WebSocketNetworkEvent
:
:
Fail
)
;
return
;
}
}
;
let
initiated_close
=
Arc
:
:
new
(
AtomicBool
:
:
new
(
false
)
)
;
let
ws_sender
=
Arc
:
:
new
(
Mutex
:
:
new
(
ws_sender
)
)
;
let
initiated_close_incoming
=
initiated_close
.
clone
(
)
;
let
ws_sender_incoming
=
ws_sender
.
clone
(
)
;
let
resource_event_sender
=
connect
.
event_sender
;
thread
:
:
spawn
(
move
|
|
{
for
message
in
receiver
.
incoming_messages
(
)
{
let
message
:
Message
=
match
message
{
Ok
(
m
)
=
>
m
Err
(
e
)
=
>
{
debug
!
(
"
Error
receiving
incoming
WebSocket
message
:
{
:
?
}
"
e
)
;
let
_
=
resource_event_sender
.
send
(
WebSocketNetworkEvent
:
:
Fail
)
;
break
;
}
}
;
let
message
=
match
message
.
opcode
{
MessageType
:
:
Text
=
>
MessageData
:
:
Text
(
String
:
:
from_utf8_lossy
(
&
message
.
payload
)
.
into_owned
(
)
)
MessageType
:
:
Binary
=
>
MessageData
:
:
Binary
(
message
.
payload
.
into_owned
(
)
)
MessageType
:
:
Ping
=
>
{
let
pong
=
Message
:
:
pong
(
message
.
payload
)
;
ws_sender_incoming
.
lock
(
)
.
unwrap
(
)
.
send_message
(
&
pong
)
.
unwrap
(
)
;
continue
;
}
MessageType
:
:
Pong
=
>
continue
MessageType
:
:
Close
=
>
{
if
!
initiated_close_incoming
.
fetch_or
(
true
Ordering
:
:
SeqCst
)
{
ws_sender_incoming
.
lock
(
)
.
unwrap
(
)
.
send_message
(
&
message
)
.
unwrap
(
)
;
}
let
code
=
message
.
cd_status_code
;
let
reason
=
String
:
:
from_utf8_lossy
(
&
message
.
payload
)
.
into_owned
(
)
;
let
_
=
resource_event_sender
.
send
(
WebSocketNetworkEvent
:
:
Close
(
code
reason
)
)
;
break
;
}
}
;
let
_
=
resource_event_sender
.
send
(
WebSocketNetworkEvent
:
:
MessageReceived
(
message
)
)
;
}
}
)
;
while
let
Ok
(
dom_action
)
=
connect
.
action_receiver
.
recv
(
)
{
match
dom_action
{
WebSocketDomAction
:
:
SendMessage
(
MessageData
:
:
Text
(
data
)
)
=
>
{
ws_sender
.
lock
(
)
.
unwrap
(
)
.
send_message
(
&
Message
:
:
text
(
data
)
)
.
unwrap
(
)
;
}
WebSocketDomAction
:
:
SendMessage
(
MessageData
:
:
Binary
(
data
)
)
=
>
{
ws_sender
.
lock
(
)
.
unwrap
(
)
.
send_message
(
&
Message
:
:
binary
(
data
)
)
.
unwrap
(
)
;
}
WebSocketDomAction
:
:
Close
(
code
reason
)
=
>
{
if
!
initiated_close
.
fetch_or
(
true
Ordering
:
:
SeqCst
)
{
let
message
=
match
code
{
Some
(
code
)
=
>
Message
:
:
close_because
(
code
reason
.
unwrap_or
(
"
"
.
to_owned
(
)
)
)
None
=
>
Message
:
:
close
(
)
}
;
ws_sender
.
lock
(
)
.
unwrap
(
)
.
send_message
(
&
message
)
.
unwrap
(
)
;
}
}
}
}
}
)
.
expect
(
"
Thread
spawning
failed
"
)
;
}
type
Stream
=
HttpStream
;
fn
obtain_a_websocket_connection
(
url
:
&
ServoUrl
)
-
>
Result
<
Stream
NetworkError
>
{
let
host
=
url
.
host_str
(
)
.
unwrap
(
)
;
let
port
=
url
.
port_or_known_default
(
)
.
unwrap
(
)
;
let
secure
=
match
url
.
scheme
(
)
{
"
ws
"
=
>
false
"
wss
"
=
>
true
_
=
>
panic
!
(
"
URL
'
s
scheme
should
be
ws
or
wss
"
)
}
;
if
secure
{
return
Err
(
NetworkError
:
:
Internal
(
"
WSS
is
disabled
for
now
.
"
.
into
(
)
)
)
;
}
let
host
=
replace_host
(
host
)
;
let
tcp_stream
=
TcpStream
:
:
connect
(
(
&
*
host
port
)
)
.
map_err
(
|
e
|
{
NetworkError
:
:
Internal
(
format
!
(
"
Could
not
connect
to
host
:
{
}
"
e
)
)
}
)
?
;
Ok
(
HttpStream
(
tcp_stream
)
)
}
fn
establish_a_websocket_connection
(
resource_url
:
ServoUrl
origin
:
String
protocols
:
Vec
<
String
>
http_state
:
&
HttpState
)
-
>
Result
<
(
Option
<
String
>
Sender
<
Stream
>
Receiver
<
Stream
>
)
NetworkError
>
{
let
mut
headers
=
Headers
:
:
new
(
)
;
headers
.
set
(
Upgrade
(
vec
!
[
Protocol
:
:
new
(
ProtocolName
:
:
WebSocket
None
)
]
)
)
;
headers
.
set
(
Connection
(
vec
!
[
ConnectionOption
:
:
ConnectionHeader
(
"
upgrade
"
.
into
(
)
)
]
)
)
;
let
key_value
=
WebSocketKey
:
:
new
(
)
;
headers
.
set
(
key_value
)
;
headers
.
set
(
WebSocketVersion
:
:
WebSocket13
)
;
if
!
protocols
.
is_empty
(
)
{
headers
.
set
(
WebSocketProtocol
(
protocols
.
clone
(
)
)
)
;
}
let
response
=
fetch
(
resource_url
origin
headers
http_state
)
?
;
if
response
.
status
!
=
StatusCode
:
:
SwitchingProtocols
{
return
Err
(
NetworkError
:
:
Internal
(
"
Response
'
s
status
should
be
101
.
"
.
into
(
)
)
)
;
}
if
!
protocols
.
is_empty
(
)
{
if
response
.
headers
.
get
:
:
<
WebSocketProtocol
>
(
)
.
map_or
(
true
|
protocols
|
protocols
.
is_empty
(
)
)
{
return
Err
(
NetworkError
:
:
Internal
(
"
Response
'
s
Sec
-
WebSocket
-
Protocol
header
is
missing
malformed
or
empty
.
"
.
into
(
)
)
)
;
}
}
let
upgrade_header
=
response
.
headers
.
get
:
:
<
Upgrade
>
(
)
.
ok_or_else
(
|
|
{
NetworkError
:
:
Internal
(
"
Response
should
have
an
Upgrade
header
.
"
.
into
(
)
)
}
)
?
;
if
upgrade_header
.
len
(
)
!
=
1
{
return
Err
(
NetworkError
:
:
Internal
(
"
Response
'
s
Upgrade
header
should
have
only
one
value
.
"
.
into
(
)
)
)
;
}
if
upgrade_header
[
0
]
.
name
!
=
ProtocolName
:
:
WebSocket
{
return
Err
(
NetworkError
:
:
Internal
(
"
Response
'
s
Upgrade
header
value
should
be
\
"
websocket
\
"
.
"
.
into
(
)
)
)
;
}
let
connection_header
=
response
.
headers
.
get
:
:
<
Connection
>
(
)
.
ok_or_else
(
|
|
{
NetworkError
:
:
Internal
(
"
Response
should
have
a
Connection
header
.
"
.
into
(
)
)
}
)
?
;
let
connection_includes_upgrade
=
connection_header
.
iter
(
)
.
any
(
|
option
|
{
match
*
option
{
ConnectionOption
:
:
ConnectionHeader
(
ref
option
)
=
>
*
option
=
=
"
upgrade
"
_
=
>
false
}
}
)
;
if
!
connection_includes_upgrade
{
return
Err
(
NetworkError
:
:
Internal
(
"
Response
'
s
Connection
header
value
should
include
\
"
upgrade
\
"
.
"
.
into
(
)
)
)
;
}
let
accept_header
=
response
.
headers
.
get
:
:
<
WebSocketAccept
>
(
)
.
ok_or_else
(
|
|
{
NetworkError
:
:
Internal
(
"
Response
should
have
a
Sec
-
Websocket
-
Accept
header
.
"
.
into
(
)
)
}
)
?
;
if
*
accept_header
!
=
WebSocketAccept
:
:
new
(
&
key_value
)
{
return
Err
(
NetworkError
:
:
Internal
(
"
Response
'
s
Sec
-
WebSocket
-
Accept
header
value
did
not
match
the
sent
key
.
"
.
into
(
)
)
)
;
}
if
response
.
headers
.
get_raw
(
"
Sec
-
WebSocket
-
Extensions
"
)
.
is_some
(
)
{
return
Err
(
NetworkError
:
:
Internal
(
"
Response
'
s
Sec
-
WebSocket
-
Extensions
header
value
included
unsupported
extensions
.
"
.
into
(
)
)
)
;
}
let
protocol_in_use
=
if
let
Some
(
response_protocols
)
=
response
.
headers
.
get
:
:
<
WebSocketProtocol
>
(
)
{
for
replied
in
&
*
*
response_protocols
{
if
!
protocols
.
iter
(
)
.
any
(
|
requested
|
requested
.
eq_ignore_ascii_case
(
replied
)
)
{
return
Err
(
NetworkError
:
:
Internal
(
"
Response
'
s
Sec
-
WebSocket
-
Protocols
contain
values
that
were
not
requested
.
"
.
into
(
)
)
)
;
}
}
response_protocols
.
first
(
)
.
cloned
(
)
}
else
{
None
}
;
let
sender
=
Sender
:
:
new
(
response
.
writer
true
)
;
let
receiver
=
Receiver
:
:
new
(
response
.
reader
false
)
;
Ok
(
(
protocol_in_use
sender
receiver
)
)
}
struct
Response
{
status
:
StatusCode
headers
:
Headers
reader
:
BufReader
<
Stream
>
writer
:
Stream
}
fn
fetch
(
url
:
ServoUrl
origin
:
String
mut
headers
:
Headers
http_state
:
&
HttpState
)
-
>
Result
<
Response
NetworkError
>
{
set_default_accept
(
Type
:
:
None
Destination
:
:
None
&
mut
headers
)
;
set_default_accept_language
(
&
mut
headers
)
;
{
}
main_fetch
(
url
origin
headers
http_state
)
}
fn
main_fetch
(
url
:
ServoUrl
origin
:
String
mut
headers
:
Headers
http_state
:
&
HttpState
)
-
>
Result
<
Response
NetworkError
>
{
let
mut
response
=
None
;
if
should_be_blocked_due_to_bad_port
(
&
url
)
{
response
=
Some
(
Err
(
NetworkError
:
:
Internal
(
"
Request
should
be
blocked
due
to
bad
port
.
"
.
into
(
)
)
)
)
;
}
let
mut
response
=
response
.
unwrap_or_else
(
|
|
{
scheme_fetch
(
&
url
origin
&
mut
headers
http_state
)
}
)
;
if
response
.
is_ok
(
)
{
if
should_be_blocked_due_to_nosniff
(
Type
:
:
None
&
headers
)
{
response
=
Err
(
NetworkError
:
:
Internal
(
"
Request
should
be
blocked
due
to
nosniff
.
"
.
into
(
)
)
)
;
}
}
response
}
fn
scheme_fetch
(
url
:
&
ServoUrl
origin
:
String
headers
:
&
mut
Headers
http_state
:
&
HttpState
)
-
>
Result
<
Response
NetworkError
>
{
http_fetch
(
url
origin
headers
http_state
)
}
fn
http_fetch
(
url
:
&
ServoUrl
origin
:
String
headers
:
&
mut
Headers
http_state
:
&
HttpState
)
-
>
Result
<
Response
NetworkError
>
{
let
mut
response
=
{
let
response
=
http_network_or_cache_fetch
(
url
origin
headers
http_state
)
;
response
}
;
if
response
.
as_ref
(
)
.
ok
(
)
.
map_or
(
false
|
response
|
is_redirect_status
(
response
.
status
)
)
{
response
=
Err
(
NetworkError
:
:
Internal
(
"
Response
should
not
be
a
redirection
.
"
.
into
(
)
)
)
;
}
response
}
fn
http_network_or_cache_fetch
(
url
:
&
ServoUrl
origin
:
String
headers
:
&
mut
Headers
http_state
:
&
HttpState
)
-
>
Result
<
Response
NetworkError
>
{
headers
.
set
(
Origin
(
origin
)
)
;
{
headers
.
set
(
Pragma
:
:
NoCache
)
;
headers
.
set
(
CacheControl
(
vec
!
[
CacheDirective
:
:
NoCache
]
)
)
;
}
headers
.
set
(
Host
{
hostname
:
url
.
host_str
(
)
.
unwrap
(
)
.
to_owned
(
)
port
:
url
.
port
(
)
}
)
;
{
set_request_cookies
(
&
url
headers
&
http_state
.
cookie_jar
)
;
}
let
response
=
{
let
forward_response
=
http_network_fetch
(
url
headers
http_state
)
;
forward_response
}
;
response
}
fn
http_network_fetch
(
url
:
&
ServoUrl
headers
:
&
Headers
http_state
:
&
HttpState
)
-
>
Result
<
Response
NetworkError
>
{
let
connection
=
obtain_a_websocket_connection
(
url
)
?
;
let
response
=
make_request
(
connection
url
headers
)
?
;
if
let
Some
(
cookies
)
=
response
.
headers
.
get
:
:
<
SetCookie
>
(
)
{
let
mut
jar
=
http_state
.
cookie_jar
.
write
(
)
.
unwrap
(
)
;
for
cookie
in
&
*
*
cookies
{
if
let
Some
(
cookie
)
=
Cookie
:
:
from_cookie_string
(
cookie
.
clone
(
)
url
CookieSource
:
:
HTTP
)
{
jar
.
push
(
cookie
url
CookieSource
:
:
HTTP
)
;
}
}
}
Ok
(
response
)
}
fn
make_request
(
mut
stream
:
Stream
url
:
&
ServoUrl
headers
:
&
Headers
)
-
>
Result
<
Response
NetworkError
>
{
write_request
(
&
mut
stream
url
headers
)
.
map_err
(
|
e
|
{
NetworkError
:
:
Internal
(
format
!
(
"
Request
could
not
be
sent
:
{
}
"
e
)
)
}
)
?
;
let
writer
=
stream
.
clone
(
)
;
let
mut
reader
=
BufReader
:
:
new
(
stream
)
;
let
head
=
parse_response
(
&
mut
reader
)
.
map_err
(
|
e
|
{
NetworkError
:
:
Internal
(
format
!
(
"
Response
could
not
be
read
:
{
}
"
e
)
)
}
)
?
;
if
head
.
version
!
=
HttpVersion
:
:
Http11
{
return
Err
(
NetworkError
:
:
Internal
(
"
Response
'
s
HTTP
version
should
be
HTTP
/
1
.
1
.
"
.
into
(
)
)
)
;
}
let
status
=
StatusCode
:
:
from_u16
(
head
.
subject
.
0
)
;
Ok
(
Response
{
status
:
status
headers
:
head
.
headers
reader
:
reader
writer
:
writer
}
)
}
fn
write_request
(
stream
:
&
mut
Stream
url
:
&
ServoUrl
headers
:
&
Headers
)
-
>
io
:
:
Result
<
(
)
>
{
let
method
=
Method
:
:
Get
;
let
request_uri
=
&
url
.
as_url
(
)
[
Position
:
:
BeforePath
.
.
Position
:
:
AfterQuery
]
;
let
version
=
HttpVersion
:
:
Http11
;
write
!
(
stream
"
{
}
{
}
{
}
{
}
"
method
request_uri
version
LINE_ENDING
)
?
;
write
!
(
stream
"
{
}
{
}
"
headers
LINE_ENDING
)
}
