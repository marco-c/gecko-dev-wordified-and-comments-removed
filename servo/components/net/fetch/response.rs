use
url
:
:
Url
;
use
http
:
:
status
:
:
{
Status
UnregisteredStatus
}
;
use
http
:
:
status
:
:
Ok
as
StatusOk
;
use
http
:
:
headers
:
:
HeaderEnum
;
use
http
:
:
headers
:
:
response
:
:
HeaderCollection
;
use
std
:
:
ascii
:
:
OwnedAsciiExt
;
use
std
:
:
comm
:
:
Receiver
;
#
[
deriving
(
Clone
PartialEq
)
]
pub
enum
ResponseType
{
Basic
CORS
Default
Error
Opaque
}
#
[
deriving
(
Clone
)
]
pub
enum
TerminationReason
{
EndUserAbort
Fatal
Timeout
}
#
[
unstable
=
"
I
haven
'
t
yet
decided
exactly
how
the
interface
for
this
will
be
"
]
#
[
deriving
(
Clone
)
]
pub
enum
ResponseBody
{
Empty
Receiving
(
Vec
<
u8
>
)
Done
(
Vec
<
u8
>
)
}
#
[
unstable
=
"
I
haven
'
t
yet
decided
exactly
how
the
interface
for
this
will
be
"
]
pub
enum
ResponseMsg
{
Chunk
(
Vec
<
u8
>
)
Finished
Errored
}
#
[
unstable
=
"
I
haven
'
t
yet
decided
exactly
how
the
interface
for
this
will
be
"
]
pub
struct
ResponseLoader
{
response
:
Response
chan
:
Receiver
<
ResponseMsg
>
}
#
[
deriving
(
Clone
)
]
pub
struct
Response
{
pub
response_type
:
ResponseType
pub
termination_reason
:
Option
<
TerminationReason
>
pub
url
:
Option
<
Url
>
pub
status
:
Status
pub
headers
:
HeaderCollection
pub
body
:
ResponseBody
pub
internal_response
:
Option
<
Box
<
Response
>
>
}
impl
Response
{
pub
fn
new
(
)
-
>
Response
{
Response
{
response_type
:
Default
termination_reason
:
None
url
:
None
status
:
StatusOk
headers
:
HeaderCollection
:
:
new
(
)
body
:
Empty
internal_response
:
None
}
}
pub
fn
network_error
(
)
-
>
Response
{
Response
{
response_type
:
Error
termination_reason
:
None
url
:
None
status
:
UnregisteredStatus
(
0
"
"
.
to_string
(
)
)
headers
:
HeaderCollection
:
:
new
(
)
body
:
Empty
internal_response
:
None
}
}
pub
fn
is_network_error
(
&
self
)
-
>
bool
{
match
self
.
response_type
{
Error
=
>
true
_
=
>
false
}
}
pub
fn
to_filtered
(
self
filter_type
:
ResponseType
)
-
>
Response
{
assert
!
(
filter_type
!
=
Error
)
;
assert
!
(
filter_type
!
=
Default
)
;
if
self
.
is_network_error
(
)
{
return
self
;
}
let
old_headers
=
self
.
headers
.
clone
(
)
;
let
mut
response
=
self
.
clone
(
)
;
response
.
internal_response
=
Some
(
box
self
)
;
match
filter_type
{
Default
|
Error
=
>
unreachable
!
(
)
Basic
=
>
{
let
mut
headers
=
HeaderCollection
:
:
new
(
)
;
for
h
in
old_headers
.
iter
(
)
{
match
h
.
header_name
(
)
.
into_ascii_lower
(
)
.
as_slice
(
)
{
"
set
-
cookie
"
|
"
set
-
cookie2
"
=
>
{
}
_
=
>
headers
.
insert
(
h
)
}
}
response
.
headers
=
headers
;
response
.
response_type
=
filter_type
;
}
CORS
=
>
{
let
mut
headers
=
HeaderCollection
:
:
new
(
)
;
for
h
in
old_headers
.
iter
(
)
{
match
h
.
header_name
(
)
.
into_ascii_lower
(
)
.
as_slice
(
)
{
"
cache
-
control
"
|
"
content
-
language
"
|
"
content
-
type
"
|
"
expires
"
|
"
last
-
modified
"
|
"
Pragma
"
=
>
{
}
/
/
XXXManishearth
handle
Access
-
Control
-
Expose
-
Headers
_
=
>
headers
.
insert
(
h
)
}
}
response
.
headers
=
headers
;
response
.
response_type
=
filter_type
;
}
Opaque
=
>
{
response
.
headers
=
HeaderCollection
:
:
new
(
)
;
response
.
status
=
UnregisteredStatus
(
0
"
"
.
to_string
(
)
)
;
response
.
body
=
Empty
;
}
}
response
}
}
