use
url
:
:
Url
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
mime
:
:
{
Mime
TopLevel
SubLevel
Attr
Value
}
;
use
hyper
:
:
header
:
:
{
Headers
ContentType
IfModifiedSince
IfNoneMatch
Accept
}
;
use
hyper
:
:
header
:
:
{
IfUnmodifiedSince
IfMatch
IfRange
Location
HeaderView
}
;
use
hyper
:
:
header
:
:
{
AcceptLanguage
ContentLanguage
}
;
use
hyper
:
:
status
:
:
StatusCode
;
use
fetch
:
:
cors_cache
:
:
{
CORSCache
CacheRequestDetails
}
;
use
fetch
:
:
response
:
:
{
Response
ResponseType
}
;
use
std
:
:
ascii
:
:
AsciiExt
;
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
Context
{
Audio
Beacon
CSPreport
Download
Embed
Eventsource
Favicon
Fetch
Font
Form
Frame
Hyperlink
IFrame
Image
ImageSet
Import
Internal
Location
Manifest
Object
Ping
Plugin
Prefetch
Script
ServiceWorker
SharedWorker
Subresource
Style
Track
Video
Worker
XMLHttpRequest
XSLT
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
ContextFrameType
{
Auxiliary
TopLevel
Nested
ContextNone
}
pub
enum
Referer
{
RefererNone
Client
RefererUrl
(
Url
)
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
RequestMode
{
SameOrigin
NoCORS
CORSMode
ForcedPreflightMode
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
CredentialsMode
{
Omit
CredentialsSameOrigin
Include
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
CacheMode
{
Default
NoStore
Reload
NoCache
ForceCache
OnlyIfCached
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
RedirectMode
{
Follow
Error
Manual
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
ResponseTainting
{
Basic
CORSTainting
Opaque
}
pub
struct
Request
{
pub
method
:
Method
pub
url
:
Url
pub
headers
:
Headers
pub
unsafe_request
:
bool
pub
body
:
Option
<
Vec
<
u8
>
>
pub
preserve_content_codings
:
bool
pub
is_service_worker_global_scope
:
bool
pub
skip_service_worker
:
bool
pub
context
:
Context
pub
context_frame_type
:
ContextFrameType
pub
origin
:
Option
<
Url
>
pub
force_origin_header
:
bool
pub
same_origin_data
:
bool
pub
referer
:
Referer
pub
authentication
:
bool
pub
sync
:
bool
pub
mode
:
RequestMode
pub
credentials_mode
:
CredentialsMode
pub
use_url_credentials
:
bool
pub
cache_mode
:
CacheMode
pub
redirect_mode
:
RedirectMode
pub
redirect_count
:
usize
pub
response_tainting
:
ResponseTainting
pub
cache
:
Option
<
Box
<
CORSCache
+
'
static
>
>
}
impl
Request
{
pub
fn
new
(
url
:
Url
context
:
Context
isServiceWorkerGlobalScope
:
bool
)
-
>
Request
{
Request
{
method
:
Method
:
:
Get
url
:
url
headers
:
Headers
:
:
new
(
)
unsafe_request
:
false
body
:
None
preserve_content_codings
:
false
is_service_worker_global_scope
:
isServiceWorkerGlobalScope
skip_service_worker
:
false
context
:
context
context_frame_type
:
ContextFrameType
:
:
ContextNone
origin
:
None
force_origin_header
:
false
same_origin_data
:
false
referer
:
Referer
:
:
Client
authentication
:
false
sync
:
false
mode
:
RequestMode
:
:
NoCORS
credentials_mode
:
CredentialsMode
:
:
Omit
use_url_credentials
:
false
cache_mode
:
CacheMode
:
:
Default
redirect_mode
:
RedirectMode
:
:
Follow
redirect_count
:
0
response_tainting
:
ResponseTainting
:
:
Basic
cache
:
None
}
}
pub
fn
fetch
(
&
mut
self
_cors_flag
:
bool
)
-
>
Response
{
Response
:
:
network_error
(
)
}
pub
fn
basic_fetch
(
&
mut
self
)
-
>
Response
{
match
&
*
self
.
url
.
scheme
{
"
about
"
=
>
match
self
.
url
.
non_relative_scheme_data
(
)
{
Some
(
s
)
if
&
*
s
=
=
"
blank
"
=
>
{
let
mut
response
=
Response
:
:
new
(
)
;
response
.
headers
.
set
(
ContentType
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Html
vec
!
[
(
Attr
:
:
Charset
Value
:
:
Utf8
)
]
)
)
)
;
response
}
_
=
>
Response
:
:
network_error
(
)
}
"
http
"
|
"
https
"
=
>
{
self
.
http_fetch
(
false
false
false
)
}
"
blob
"
|
"
data
"
|
"
file
"
|
"
ftp
"
=
>
{
panic
!
(
"
Unimplemented
scheme
for
Fetch
"
)
}
_
=
>
Response
:
:
network_error
(
)
}
}
pub
fn
http_fetch
(
&
mut
self
cors_flag
:
bool
cors_preflight_flag
:
bool
authentication_fetch_flag
:
bool
)
-
>
Response
{
let
mut
response
:
Option
<
Response
>
=
None
;
if
!
self
.
skip_service_worker
&
&
!
self
.
is_service_worker_global_scope
{
if
let
Some
(
ref
res
)
=
response
{
if
(
res
.
response_type
=
=
ResponseType
:
:
Opaque
&
&
self
.
mode
!
=
RequestMode
:
:
NoCORS
)
|
|
res
.
response_type
=
=
ResponseType
:
:
Error
{
return
Response
:
:
network_error
(
)
;
}
}
}
if
response
.
is_none
(
)
{
if
cors_preflight_flag
{
let
mut
method_mismatch
=
false
;
let
mut
header_mismatch
=
false
;
if
let
Some
(
ref
mut
cache
)
=
self
.
cache
{
let
origin
=
self
.
origin
.
clone
(
)
.
unwrap_or
(
Url
:
:
parse
(
"
"
)
.
unwrap
(
)
)
;
let
url
=
self
.
url
.
clone
(
)
;
let
credentials
=
self
.
credentials_mode
=
=
CredentialsMode
:
:
Include
;
let
method_cache_match
=
cache
.
match_method
(
CacheRequestDetails
{
origin
:
origin
.
clone
(
)
destination
:
url
.
clone
(
)
credentials
:
credentials
}
self
.
method
.
clone
(
)
)
;
method_mismatch
=
!
method_cache_match
&
&
(
!
is_simple_method
(
&
self
.
method
)
|
|
self
.
mode
=
=
RequestMode
:
:
ForcedPreflightMode
)
;
header_mismatch
=
self
.
headers
.
iter
(
)
.
any
(
|
view
|
!
cache
.
match_header
(
CacheRequestDetails
{
origin
:
origin
.
clone
(
)
destination
:
url
.
clone
(
)
credentials
:
credentials
}
view
.
name
(
)
)
&
&
!
is_simple_header
(
&
view
)
)
;
}
if
method_mismatch
|
|
header_mismatch
{
let
preflight_result
=
self
.
preflight_fetch
(
)
;
if
preflight_result
.
response_type
=
=
ResponseType
:
:
Error
{
return
Response
:
:
network_error
(
)
;
}
response
=
Some
(
preflight_result
)
;
}
}
self
.
skip_service_worker
=
true
;
let
credentials
=
match
self
.
credentials_mode
{
CredentialsMode
:
:
Include
=
>
true
CredentialsMode
:
:
CredentialsSameOrigin
if
!
cors_flag
=
>
true
_
=
>
false
}
;
if
self
.
cache_mode
=
=
CacheMode
:
:
Default
&
&
is_no_store_cache
(
&
self
.
headers
)
{
self
.
cache_mode
=
CacheMode
:
:
NoStore
;
}
let
fetch_result
=
self
.
http_network_or_cache_fetch
(
credentials
authentication_fetch_flag
)
;
if
cors_flag
&
&
self
.
cors_check
(
&
fetch_result
)
.
is_err
(
)
{
return
Response
:
:
network_error
(
)
;
}
response
=
Some
(
fetch_result
)
;
}
let
mut
response
=
response
.
unwrap
(
)
;
match
response
.
status
.
unwrap
(
)
{
StatusCode
:
:
NotModified
=
>
match
self
.
cache_mode
{
CacheMode
:
:
Default
|
CacheMode
:
:
NoCache
=
>
{
}
_
=
>
{
}
}
StatusCode
:
:
MovedPermanently
|
StatusCode
:
:
Found
|
StatusCode
:
:
SeeOther
|
StatusCode
:
:
TemporaryRedirect
|
StatusCode
:
:
PermanentRedirect
=
>
{
if
self
.
redirect_mode
=
=
RedirectMode
:
:
Error
{
return
Response
:
:
network_error
(
)
;
}
if
!
response
.
headers
.
has
:
:
<
Location
>
(
)
{
return
response
;
}
let
location
=
response
.
headers
.
get
:
:
<
Location
>
(
)
;
if
location
.
is_none
(
)
{
return
Response
:
:
network_error
(
)
;
}
let
locationUrl
=
Url
:
:
parse
(
location
.
unwrap
(
)
)
;
let
locationUrl
=
match
locationUrl
{
Ok
(
url
)
=
>
url
Err
(
_
)
=
>
return
Response
:
:
network_error
(
)
}
;
if
self
.
redirect_count
=
=
20
{
return
Response
:
:
network_error
(
)
;
}
self
.
redirect_count
+
=
1
;
self
.
same_origin_data
=
false
;
if
self
.
redirect_mode
=
=
RedirectMode
:
:
Follow
{
if
cors_flag
&
&
(
!
locationUrl
.
username
(
)
.
unwrap_or
(
"
"
)
.
is_empty
(
)
|
|
locationUrl
.
password
(
)
.
is_some
(
)
)
{
return
Response
:
:
network_error
(
)
;
}
if
response
.
status
.
unwrap
(
)
=
=
StatusCode
:
:
MovedPermanently
|
|
response
.
status
.
unwrap
(
)
=
=
StatusCode
:
:
SeeOther
|
|
(
response
.
status
.
unwrap
(
)
=
=
StatusCode
:
:
Found
&
&
self
.
method
=
=
Method
:
:
Post
)
{
self
.
method
=
Method
:
:
Get
;
}
self
.
url
=
locationUrl
;
return
self
.
fetch
(
cors_flag
)
;
}
}
StatusCode
:
:
Unauthorized
=
>
{
if
!
self
.
authentication
|
|
cors_flag
{
return
response
;
}
if
!
self
.
use_url_credentials
|
|
authentication_fetch_flag
{
}
return
self
.
http_fetch
(
cors_flag
cors_preflight_flag
true
)
;
}
StatusCode
:
:
ProxyAuthenticationRequired
=
>
{
return
self
.
http_fetch
(
cors_flag
cors_preflight_flag
authentication_fetch_flag
)
;
}
_
=
>
{
}
}
if
authentication_fetch_flag
{
}
response
}
pub
fn
http_network_or_cache_fetch
(
&
mut
self
_credentials_flag
:
bool
_authentication_fetch_flag
:
bool
)
-
>
Response
{
Response
:
:
network_error
(
)
}
pub
fn
preflight_fetch
(
&
mut
self
)
-
>
Response
{
Response
:
:
network_error
(
)
}
pub
fn
cors_check
(
&
mut
self
response
:
&
Response
)
-
>
Result
<
(
)
(
)
>
{
Err
(
(
)
)
}
}
fn
is_no_store_cache
(
headers
:
&
Headers
)
-
>
bool
{
headers
.
has
:
:
<
IfModifiedSince
>
(
)
|
headers
.
has
:
:
<
IfNoneMatch
>
(
)
|
headers
.
has
:
:
<
IfUnmodifiedSince
>
(
)
|
headers
.
has
:
:
<
IfMatch
>
(
)
|
headers
.
has
:
:
<
IfRange
>
(
)
}
fn
is_simple_header
(
h
:
&
HeaderView
)
-
>
bool
{
if
h
.
is
:
:
<
ContentType
>
(
)
{
match
h
.
value
(
)
{
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Plain
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
WwwFormUrlEncoded
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Multipart
SubLevel
:
:
FormData
_
)
)
)
=
>
true
_
=
>
false
}
}
else
{
h
.
is
:
:
<
Accept
>
(
)
|
|
h
.
is
:
:
<
AcceptLanguage
>
(
)
|
|
h
.
is
:
:
<
ContentLanguage
>
(
)
}
}
fn
is_simple_method
(
m
:
&
Method
)
-
>
bool
{
match
*
m
{
Method
:
:
Get
|
Method
:
:
Head
|
Method
:
:
Post
=
>
true
_
=
>
false
}
}
