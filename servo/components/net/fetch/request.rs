use
fetch
:
:
cors_cache
:
:
{
BasicCORSCache
CORSCache
CacheRequestDetails
}
;
use
fetch
:
:
response
:
:
ResponseMethods
;
use
http_loader
:
:
{
NetworkHttpRequestFactory
WrappedHttpResponse
}
;
use
http_loader
:
:
{
create_http_connector
obtain_response
}
;
use
hyper
:
:
client
:
:
response
:
:
Response
as
HyperResponse
;
use
hyper
:
:
header
:
:
{
Accept
IfMatch
IfRange
IfUnmodifiedSince
Location
}
;
use
hyper
:
:
header
:
:
{
AcceptLanguage
ContentLength
ContentLanguage
HeaderView
}
;
use
hyper
:
:
header
:
:
{
Authorization
Basic
ContentEncoding
Encoding
}
;
use
hyper
:
:
header
:
:
{
ContentType
Header
Headers
IfModifiedSince
IfNoneMatch
}
;
use
hyper
:
:
header
:
:
{
QualityItem
q
qitem
Referer
as
RefererHeader
UserAgent
}
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
mime
:
:
{
Attr
Mime
SubLevel
TopLevel
Value
}
;
use
hyper
:
:
status
:
:
StatusCode
;
use
net_traits
:
:
response
:
:
{
CacheState
HttpsState
Response
ResponseType
TerminationReason
}
;
use
net_traits
:
:
{
AsyncFetchListener
Metadata
}
;
use
resource_thread
:
:
CancellationListener
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
cell
:
:
{
Cell
RefCell
}
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
str
:
:
FromStr
;
use
std
:
:
thread
;
use
url
:
:
{
Origin
Url
UrlParser
}
;
use
util
:
:
thread
:
:
spawn_named
;
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
Context
{
Audio
Beacon
CSPreport
Download
Embed
Eventsource
Favicon
Fetch
Font
Form
Frame
Hyperlink
IFrame
Image
ImageSet
Import
Internal
Location
Manifest
MetaRefresh
Object
Ping
Plugin
Prefetch
PreRender
Script
ServiceWorker
SharedWorker
Subresource
Style
Track
Video
Worker
XMLHttpRequest
XSLT
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
ContextFrameType
{
Auxiliary
TopLevel
Nested
ContextNone
}
#
[
derive
(
Clone
PartialEq
)
]
pub
enum
Referer
{
NoReferer
Client
RefererUrl
(
Url
)
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
RequestMode
{
SameOrigin
NoCORS
CORSMode
ForcedPreflightMode
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
CredentialsMode
{
Omit
CredentialsSameOrigin
Include
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
CacheMode
{
Default
NoStore
Reload
NoCache
ForceCache
OnlyIfCached
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
RedirectMode
{
Follow
Error
Manual
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
ResponseTainting
{
Basic
CORSTainting
Opaque
}
#
[
derive
(
Clone
)
]
pub
struct
Request
{
pub
method
:
RefCell
<
Method
>
pub
url_list
:
RefCell
<
Vec
<
Url
>
>
pub
headers
:
RefCell
<
Headers
>
pub
unsafe_request
:
bool
pub
body
:
Option
<
Vec
<
u8
>
>
pub
preserve_content_codings
:
bool
pub
is_service_worker_global_scope
:
bool
pub
skip_service_worker
:
Cell
<
bool
>
pub
context
:
Context
pub
context_frame_type
:
ContextFrameType
pub
origin
:
Option
<
Url
>
pub
force_origin_header
:
bool
pub
omit_origin_header
:
bool
pub
same_origin_data
:
bool
pub
referer
:
Referer
pub
authentication
:
bool
pub
sync
:
bool
pub
mode
:
RequestMode
pub
credentials_mode
:
CredentialsMode
pub
use_url_credentials
:
bool
pub
cache_mode
:
Cell
<
CacheMode
>
pub
redirect_mode
:
RedirectMode
pub
redirect_count
:
Cell
<
u32
>
pub
response_tainting
:
ResponseTainting
}
impl
Request
{
pub
fn
new
(
url
:
Url
context
:
Context
is_service_worker_global_scope
:
bool
)
-
>
Request
{
Request
{
method
:
RefCell
:
:
new
(
Method
:
:
Get
)
url_list
:
RefCell
:
:
new
(
vec
!
[
url
]
)
headers
:
RefCell
:
:
new
(
Headers
:
:
new
(
)
)
unsafe_request
:
false
body
:
None
preserve_content_codings
:
false
is_service_worker_global_scope
:
is_service_worker_global_scope
skip_service_worker
:
Cell
:
:
new
(
false
)
context
:
context
context_frame_type
:
ContextFrameType
:
:
ContextNone
origin
:
None
force_origin_header
:
false
omit_origin_header
:
false
same_origin_data
:
false
referer
:
Referer
:
:
Client
authentication
:
false
sync
:
false
mode
:
RequestMode
:
:
NoCORS
credentials_mode
:
CredentialsMode
:
:
Omit
use_url_credentials
:
false
cache_mode
:
Cell
:
:
new
(
CacheMode
:
:
Default
)
redirect_mode
:
RedirectMode
:
:
Follow
redirect_count
:
Cell
:
:
new
(
0
)
response_tainting
:
ResponseTainting
:
:
Basic
}
}
fn
get_last_url_string
(
&
self
)
-
>
String
{
self
.
url_list
.
borrow
(
)
.
last
(
)
.
unwrap
(
)
.
serialize
(
)
}
fn
current_url
(
&
self
)
-
>
Url
{
self
.
url_list
.
borrow
(
)
.
last
(
)
.
unwrap
(
)
.
clone
(
)
}
}
pub
fn
fetch_async
(
request
:
Request
cors_flag
:
bool
listener
:
Box
<
AsyncFetchListener
+
Send
>
)
{
spawn_named
(
format
!
(
"
fetch
for
{
:
?
}
"
request
.
get_last_url_string
(
)
)
move
|
|
{
let
request
=
Rc
:
:
new
(
request
)
;
let
res
=
fetch
(
request
cors_flag
)
;
listener
.
response_available
(
res
)
;
}
)
}
pub
fn
fetch
(
request
:
Rc
<
Request
>
cors_flag
:
bool
)
-
>
Response
{
if
request
.
context
!
=
Context
:
:
Fetch
&
&
!
request
.
headers
.
borrow
(
)
.
has
:
:
<
Accept
>
(
)
{
let
value
=
match
request
.
context
{
Context
:
:
Favicon
|
Context
:
:
Image
|
Context
:
:
ImageSet
=
>
vec
!
[
qitem
(
Mime
(
TopLevel
:
:
Image
SubLevel
:
:
Png
vec
!
[
]
)
)
/
/
FIXME
:
This
should
properly
generate
a
MimeType
that
has
a
/
/
SubLevel
of
svg
+
xml
(
https
:
/
/
github
.
com
/
hyperium
/
mime
.
rs
/
issues
/
22
)
qitem
(
Mime
(
TopLevel
:
:
Image
SubLevel
:
:
Ext
(
"
svg
+
xml
"
.
to_owned
(
)
)
vec
!
[
]
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Image
SubLevel
:
:
Star
vec
!
[
]
)
q
(
0
.
8
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Star
SubLevel
:
:
Star
vec
!
[
]
)
q
(
0
.
5
)
)
]
Context
:
:
Form
|
Context
:
:
Frame
|
Context
:
:
Hyperlink
|
Context
:
:
IFrame
|
Context
:
:
Location
|
Context
:
:
MetaRefresh
|
Context
:
:
PreRender
=
>
vec
!
[
qitem
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Html
vec
!
[
]
)
)
/
/
FIXME
:
This
should
properly
generate
a
MimeType
that
has
a
/
/
SubLevel
of
xhtml
+
xml
(
https
:
/
/
github
.
com
/
hyperium
/
mime
.
rs
/
issues
/
22
)
qitem
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
Ext
(
"
xhtml
+
xml
"
.
to_owned
(
)
)
vec
!
[
]
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
Xml
vec
!
[
]
)
q
(
0
.
9
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Star
SubLevel
:
:
Star
vec
!
[
]
)
q
(
0
.
8
)
)
]
Context
:
:
Internal
if
request
.
context_frame_type
!
=
ContextFrameType
:
:
ContextNone
=
>
vec
!
[
qitem
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Html
vec
!
[
]
)
)
/
/
FIXME
:
This
should
properly
generate
a
MimeType
that
has
a
/
/
SubLevel
of
xhtml
+
xml
(
https
:
/
/
github
.
com
/
hyperium
/
mime
.
rs
/
issues
/
22
)
qitem
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
Ext
(
"
xhtml
+
xml
"
.
to_owned
(
)
)
vec
!
[
]
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
Xml
vec
!
[
]
)
q
(
0
.
9
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Star
SubLevel
:
:
Star
vec
!
[
]
)
q
(
0
.
8
)
)
]
Context
:
:
Style
=
>
vec
!
[
qitem
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Css
vec
!
[
]
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Star
SubLevel
:
:
Star
vec
!
[
]
)
q
(
0
.
1
)
)
]
_
=
>
vec
!
[
qitem
(
Mime
(
TopLevel
:
:
Star
SubLevel
:
:
Star
vec
!
[
]
)
)
]
}
;
request
.
headers
.
borrow_mut
(
)
.
set
(
Accept
(
value
)
)
;
}
if
request
.
context
!
=
Context
:
:
Fetch
&
&
!
request
.
headers
.
borrow
(
)
.
has
:
:
<
AcceptLanguage
>
(
)
{
request
.
headers
.
borrow_mut
(
)
.
set
(
AcceptLanguage
(
vec
!
[
qitem
(
"
en
-
US
"
.
parse
(
)
.
unwrap
(
)
)
]
)
)
;
}
main_fetch
(
request
cors_flag
)
}
fn
main_fetch
(
request
:
Rc
<
Request
>
_cors_flag
:
bool
)
-
>
Response
{
let
_
=
basic_fetch
(
request
)
;
Response
:
:
network_error
(
)
}
fn
basic_fetch
(
request
:
Rc
<
Request
>
)
-
>
Response
{
let
url
=
request
.
current_url
(
)
;
let
scheme
=
url
.
scheme
.
clone
(
)
;
match
&
*
scheme
{
"
about
"
=
>
{
match
url
.
non_relative_scheme_data
(
)
{
Some
(
s
)
if
&
*
s
=
=
"
blank
"
=
>
{
let
mut
response
=
Response
:
:
new
(
)
;
response
.
headers
.
set
(
ContentType
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Html
vec
!
[
(
Attr
:
:
Charset
Value
:
:
Utf8
)
]
)
)
)
;
response
}
_
=
>
Response
:
:
network_error
(
)
}
}
"
http
"
|
"
https
"
=
>
{
http_fetch
(
request
.
clone
(
)
BasicCORSCache
:
:
new
(
)
false
false
false
)
}
"
blob
"
|
"
data
"
|
"
file
"
|
"
ftp
"
=
>
{
panic
!
(
"
Unimplemented
scheme
for
Fetch
"
)
}
_
=
>
Response
:
:
network_error
(
)
}
}
fn
http_fetch_async
(
request
:
Request
cors_flag
:
bool
cors_preflight_flag
:
bool
authentication_fetch_flag
:
bool
listener
:
Box
<
AsyncFetchListener
+
Send
>
)
{
spawn_named
(
format
!
(
"
http_fetch
for
{
:
?
}
"
request
.
get_last_url_string
(
)
)
move
|
|
{
let
request
=
Rc
:
:
new
(
request
)
;
let
res
=
http_fetch
(
request
BasicCORSCache
:
:
new
(
)
cors_flag
cors_preflight_flag
authentication_fetch_flag
)
;
listener
.
response_available
(
res
)
;
}
)
;
}
fn
http_fetch
(
request
:
Rc
<
Request
>
mut
cache
:
BasicCORSCache
cors_flag
:
bool
cors_preflight_flag
:
bool
authentication_fetch_flag
:
bool
)
-
>
Response
{
let
mut
response
:
Option
<
Rc
<
Response
>
>
=
None
;
let
mut
actual_response
:
Option
<
Rc
<
Response
>
>
=
None
;
if
!
request
.
skip_service_worker
.
get
(
)
&
&
!
request
.
is_service_worker_global_scope
{
if
let
Some
(
ref
res
)
=
response
{
actual_response
=
match
res
.
internal_response
{
Some
(
ref
internal_res
)
=
>
Some
(
internal_res
.
clone
(
)
)
None
=
>
Some
(
res
.
clone
(
)
)
}
;
if
(
res
.
response_type
=
=
ResponseType
:
:
Opaque
&
&
request
.
mode
!
=
RequestMode
:
:
NoCORS
)
|
|
(
res
.
response_type
=
=
ResponseType
:
:
OpaqueRedirect
&
&
request
.
redirect_mode
!
=
RedirectMode
:
:
Manual
)
|
|
res
.
response_type
=
=
ResponseType
:
:
Error
{
return
Response
:
:
network_error
(
)
;
}
}
if
let
Some
(
ref
res
)
=
actual_response
{
if
res
.
url_list
.
borrow
(
)
.
is_empty
(
)
{
*
res
.
url_list
.
borrow_mut
(
)
=
request
.
url_list
.
borrow
(
)
.
clone
(
)
;
}
}
}
if
response
.
is_none
(
)
{
if
cors_preflight_flag
{
let
mut
method_mismatch
=
false
;
let
mut
header_mismatch
=
false
;
let
origin
=
request
.
origin
.
clone
(
)
.
unwrap_or
(
Url
:
:
parse
(
"
"
)
.
unwrap
(
)
)
;
let
url
=
request
.
current_url
(
)
;
let
credentials
=
request
.
credentials_mode
=
=
CredentialsMode
:
:
Include
;
let
method_cache_match
=
cache
.
match_method
(
CacheRequestDetails
{
origin
:
origin
.
clone
(
)
destination
:
url
.
clone
(
)
credentials
:
credentials
}
request
.
method
.
borrow
(
)
.
clone
(
)
)
;
method_mismatch
=
!
method_cache_match
&
&
(
!
is_simple_method
(
&
request
.
method
.
borrow
(
)
)
|
|
request
.
mode
=
=
RequestMode
:
:
ForcedPreflightMode
)
;
header_mismatch
=
request
.
headers
.
borrow
(
)
.
iter
(
)
.
any
(
|
view
|
!
cache
.
match_header
(
CacheRequestDetails
{
origin
:
origin
.
clone
(
)
destination
:
url
.
clone
(
)
credentials
:
credentials
}
view
.
name
(
)
)
&
&
!
is_simple_header
(
&
view
)
)
;
if
method_mismatch
|
|
header_mismatch
{
let
preflight_result
=
preflight_fetch
(
request
.
clone
(
)
)
;
if
preflight_result
.
response_type
=
=
ResponseType
:
:
Error
{
return
Response
:
:
network_error
(
)
;
}
response
=
Some
(
Rc
:
:
new
(
preflight_result
)
)
;
}
}
request
.
skip_service_worker
.
set
(
true
)
;
let
credentials
=
match
request
.
credentials_mode
{
CredentialsMode
:
:
Include
=
>
true
CredentialsMode
:
:
CredentialsSameOrigin
if
(
!
cors_flag
|
|
request
.
response_tainting
=
=
ResponseTainting
:
:
Opaque
)
=
>
true
_
=
>
false
}
;
let
fetch_result
=
http_network_or_cache_fetch
(
request
.
clone
(
)
credentials
authentication_fetch_flag
)
;
if
cors_flag
&
&
cors_check
(
request
.
clone
(
)
&
fetch_result
)
.
is_err
(
)
{
return
Response
:
:
network_error
(
)
;
}
response
=
Some
(
Rc
:
:
new
(
fetch_result
)
)
;
actual_response
=
response
.
clone
(
)
;
}
let
actual_response
=
Rc
:
:
try_unwrap
(
actual_response
.
unwrap
(
)
)
.
ok
(
)
.
unwrap
(
)
;
let
mut
response
=
Rc
:
:
try_unwrap
(
response
.
unwrap
(
)
)
.
ok
(
)
.
unwrap
(
)
;
match
actual_response
.
status
.
unwrap
(
)
{
StatusCode
:
:
MovedPermanently
|
StatusCode
:
:
Found
|
StatusCode
:
:
SeeOther
|
StatusCode
:
:
TemporaryRedirect
|
StatusCode
:
:
PermanentRedirect
=
>
{
if
request
.
redirect_mode
=
=
RedirectMode
:
:
Error
{
return
Response
:
:
network_error
(
)
;
}
if
!
actual_response
.
headers
.
has
:
:
<
Location
>
(
)
{
return
actual_response
;
}
let
location
=
match
actual_response
.
headers
.
get
:
:
<
Location
>
(
)
{
Some
(
&
Location
(
ref
location
)
)
=
>
location
.
clone
(
)
_
=
>
return
Response
:
:
network_error
(
)
}
;
let
location_url
=
UrlParser
:
:
new
(
)
.
base_url
(
&
request
.
current_url
(
)
)
.
parse
(
&
*
location
)
;
let
location_url
=
match
location_url
{
Ok
(
ref
url
)
if
url
.
scheme
=
=
"
data
"
=
>
{
return
Response
:
:
network_error
(
)
;
}
Ok
(
url
)
=
>
url
_
=
>
{
return
Response
:
:
network_error
(
)
;
}
}
;
if
request
.
redirect_count
.
get
(
)
=
=
20
{
return
Response
:
:
network_error
(
)
;
}
request
.
redirect_count
.
set
(
request
.
redirect_count
.
get
(
)
+
1
)
;
match
request
.
redirect_mode
{
RedirectMode
:
:
Manual
=
>
{
response
=
actual_response
.
to_filtered
(
ResponseType
:
:
Opaque
)
;
}
RedirectMode
:
:
Follow
=
>
{
if
cors_flag
&
&
has_credentials
(
&
location_url
)
{
return
Response
:
:
network_error
(
)
;
}
if
actual_response
.
status
.
unwrap
(
)
=
=
StatusCode
:
:
SeeOther
|
|
(
(
actual_response
.
status
.
unwrap
(
)
=
=
StatusCode
:
:
MovedPermanently
|
|
actual_response
.
status
.
unwrap
(
)
=
=
StatusCode
:
:
Found
)
&
&
*
request
.
method
.
borrow
(
)
=
=
Method
:
:
Post
)
{
*
request
.
method
.
borrow_mut
(
)
=
Method
:
:
Get
;
}
request
.
url_list
.
borrow_mut
(
)
.
push
(
location_url
)
;
return
main_fetch
(
request
.
clone
(
)
cors_flag
)
;
}
RedirectMode
:
:
Error
=
>
{
panic
!
(
"
RedirectMode
is
Error
after
step
8
"
)
}
}
}
StatusCode
:
:
Unauthorized
=
>
{
if
cors_flag
{
return
response
;
}
if
!
request
.
use_url_credentials
|
|
authentication_fetch_flag
{
}
return
http_fetch
(
request
BasicCORSCache
:
:
new
(
)
cors_flag
cors_preflight_flag
true
)
;
}
StatusCode
:
:
ProxyAuthenticationRequired
=
>
{
return
http_fetch
(
request
BasicCORSCache
:
:
new
(
)
cors_flag
cors_preflight_flag
authentication_fetch_flag
)
;
}
_
=
>
{
}
}
if
authentication_fetch_flag
{
}
response
}
fn
http_network_or_cache_fetch
(
request
:
Rc
<
Request
>
credentials_flag
:
bool
authentication_fetch_flag
:
bool
)
-
>
Response
{
let
request_has_no_window
=
true
;
let
http_request
=
if
request_has_no_window
&
&
request
.
redirect_mode
!
=
RedirectMode
:
:
Follow
{
request
.
clone
(
)
}
else
{
Rc
:
:
new
(
(
*
request
)
.
clone
(
)
)
}
;
let
content_length_value
=
match
http_request
.
body
{
None
=
>
match
*
http_request
.
method
.
borrow
(
)
{
Method
:
:
Head
|
Method
:
:
Post
|
Method
:
:
Put
=
>
Some
(
0
)
_
=
>
None
}
Some
(
ref
http_request_body
)
=
>
Some
(
http_request_body
.
len
(
)
as
u64
)
}
;
if
let
Some
(
content_length_value
)
=
content_length_value
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
ContentLength
(
content_length_value
)
)
;
}
match
http_request
.
referer
{
Referer
:
:
NoReferer
=
>
http_request
.
headers
.
borrow_mut
(
)
.
set
(
RefererHeader
(
"
"
.
to_owned
(
)
)
)
Referer
:
:
RefererUrl
(
ref
http_request_referer
)
=
>
http_request
.
headers
.
borrow_mut
(
)
.
set
(
RefererHeader
(
http_request_referer
.
serialize
(
)
)
)
Referer
:
:
Client
=
>
unreachable
!
(
)
}
;
if
http_request
.
omit_origin_header
=
=
false
{
if
let
Some
(
ref
_origin
)
=
http_request
.
origin
{
}
}
if
!
http_request
.
headers
.
borrow
(
)
.
has
:
:
<
UserAgent
>
(
)
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
UserAgent
(
global_user_agent
(
)
.
to_owned
(
)
)
)
;
}
if
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
&
&
is_no_store_cache
(
&
http_request
.
headers
.
borrow
(
)
)
{
http_request
.
cache_mode
.
set
(
CacheMode
:
:
NoStore
)
;
}
if
credentials_flag
{
let
mut
authorization_value
=
None
;
if
authentication_fetch_flag
{
let
current_url
=
http_request
.
current_url
(
)
;
authorization_value
=
if
includes_credentials
(
&
current_url
)
{
Some
(
Basic
{
username
:
current_url
.
username
(
)
.
unwrap_or
(
"
"
)
.
to_owned
(
)
password
:
current_url
.
password
(
)
.
map
(
str
:
:
to_owned
)
}
)
}
else
{
None
}
}
if
let
Some
(
basic
)
=
authorization_value
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
Authorization
(
basic
)
)
;
}
}
let
mut
response
:
Option
<
Response
>
=
None
;
let
complete_http_response_from_cache
:
Option
<
Response
>
=
None
;
if
http_request
.
cache_mode
.
get
(
)
!
=
CacheMode
:
:
NoStore
&
&
http_request
.
cache_mode
.
get
(
)
!
=
CacheMode
:
:
Reload
&
&
complete_http_response_from_cache
.
is_some
(
)
{
if
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
ForceCache
{
}
let
revalidation_needed
=
match
response
{
Some
(
ref
response
)
=
>
response_needs_revalidation
(
&
response
)
_
=
>
false
}
;
if
!
revalidation_needed
&
&
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
{
}
if
revalidation_needed
&
&
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
NoCache
{
}
}
else
if
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
ForceCache
{
}
if
response
.
is_none
(
)
{
response
=
Some
(
http_network_fetch
(
request
.
clone
(
)
http_request
.
clone
(
)
credentials_flag
)
)
;
}
let
response
=
response
.
unwrap
(
)
;
if
let
Some
(
status
)
=
response
.
status
{
if
status
=
=
StatusCode
:
:
NotModified
&
&
(
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
NoCache
)
{
let
cached_response
:
Option
<
Response
>
=
None
;
if
cached_response
.
is_none
(
)
{
return
Response
:
:
network_error
(
)
;
}
}
}
response
}
fn
http_network_fetch
(
request
:
Rc
<
Request
>
http_request
:
Rc
<
Request
>
credentials_flag
:
bool
)
-
>
Response
{
let
connection
=
create_http_connector
(
)
;
let
factory
=
NetworkHttpRequestFactory
{
connector
:
connection
}
;
let
url
=
request
.
current_url
(
)
;
let
cancellation_listener
=
CancellationListener
:
:
new
(
None
)
;
let
wrapped_response
=
obtain_response
(
&
factory
&
url
&
request
.
method
.
borrow
(
)
&
mut
*
request
.
headers
.
borrow_mut
(
)
&
cancellation_listener
&
None
&
request
.
method
.
borrow
(
)
&
None
request
.
redirect_count
.
get
(
)
&
None
"
"
)
;
let
mut
response
=
Response
:
:
new
(
)
;
match
wrapped_response
{
Ok
(
res
)
=
>
{
response
.
url
=
Some
(
res
.
response
.
url
.
clone
(
)
)
;
response
.
status
=
Some
(
res
.
response
.
status
)
;
response
.
headers
=
res
.
response
.
headers
.
clone
(
)
;
}
Err
(
e
)
=
>
response
.
termination_reason
=
Some
(
TerminationReason
:
:
Fatal
)
}
;
response
.
https_state
=
HttpsState
:
:
None
;
if
let
Some
(
encoding
)
=
response
.
headers
.
get
:
:
<
ContentEncoding
>
(
)
{
if
encoding
.
contains
(
&
Encoding
:
:
Gzip
)
{
}
else
if
encoding
.
contains
(
&
Encoding
:
:
Compress
)
{
}
}
;
*
response
.
url_list
.
borrow_mut
(
)
=
request
.
url_list
.
borrow
(
)
.
clone
(
)
;
response
}
fn
preflight_fetch
(
request
:
Rc
<
Request
>
)
-
>
Response
{
Response
:
:
network_error
(
)
}
fn
cors_check
(
request
:
Rc
<
Request
>
response
:
&
Response
)
-
>
Result
<
(
)
(
)
>
{
Err
(
(
)
)
}
fn
global_user_agent
(
)
-
>
String
{
const
USER_AGENT_STRING
:
&
'
static
str
=
"
Servo
"
;
USER_AGENT_STRING
.
to_owned
(
)
}
fn
has_credentials
(
url
:
&
Url
)
-
>
bool
{
!
url
.
username
(
)
.
unwrap_or
(
"
"
)
.
is_empty
(
)
|
|
url
.
password
(
)
.
is_some
(
)
}
fn
is_no_store_cache
(
headers
:
&
Headers
)
-
>
bool
{
headers
.
has
:
:
<
IfModifiedSince
>
(
)
|
headers
.
has
:
:
<
IfNoneMatch
>
(
)
|
headers
.
has
:
:
<
IfUnmodifiedSince
>
(
)
|
headers
.
has
:
:
<
IfMatch
>
(
)
|
headers
.
has
:
:
<
IfRange
>
(
)
}
fn
is_simple_header
(
h
:
&
HeaderView
)
-
>
bool
{
if
h
.
is
:
:
<
ContentType
>
(
)
{
match
h
.
value
(
)
{
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Plain
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
WwwFormUrlEncoded
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Multipart
SubLevel
:
:
FormData
_
)
)
)
=
>
true
_
=
>
false
}
}
else
{
h
.
is
:
:
<
Accept
>
(
)
|
|
h
.
is
:
:
<
AcceptLanguage
>
(
)
|
|
h
.
is
:
:
<
ContentLanguage
>
(
)
}
}
fn
is_simple_method
(
m
:
&
Method
)
-
>
bool
{
match
*
m
{
Method
:
:
Get
|
Method
:
:
Head
|
Method
:
:
Post
=
>
true
_
=
>
false
}
}
fn
includes_credentials
(
url
:
&
Url
)
-
>
bool
{
if
url
.
password
(
)
.
is_some
(
)
{
return
true
}
if
let
Some
(
name
)
=
url
.
username
(
)
{
return
name
.
len
(
)
>
0
}
false
}
fn
response_needs_revalidation
(
response
:
&
Response
)
-
>
bool
{
false
}
