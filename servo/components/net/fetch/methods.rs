use
blob_loader
:
:
load_blob_sync
;
use
data_loader
:
:
decode
;
use
devtools_traits
:
:
DevtoolsControlMsg
;
use
fetch
:
:
cors_cache
:
:
CorsCache
;
use
filemanager_thread
:
:
FileManager
;
use
http_loader
:
:
{
HttpState
determine_request_referrer
http_fetch
set_default_accept_language
}
;
use
hyper
:
:
Error
;
use
hyper
:
:
error
:
:
Result
as
HyperResult
;
use
hyper
:
:
header
:
:
{
Accept
AcceptLanguage
ContentLanguage
ContentType
}
;
use
hyper
:
:
header
:
:
{
Header
HeaderFormat
HeaderView
Headers
QualityItem
}
;
use
hyper
:
:
header
:
:
{
Referer
as
RefererHeader
q
qitem
}
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
mime
:
:
{
Mime
SubLevel
TopLevel
}
;
use
hyper
:
:
status
:
:
StatusCode
;
use
mime_guess
:
:
guess_mime_type
;
use
net_traits
:
:
{
FetchTaskTarget
NetworkError
ReferrerPolicy
}
;
use
net_traits
:
:
request
:
:
{
Referrer
Request
RequestMode
ResponseTainting
}
;
use
net_traits
:
:
request
:
:
{
Type
Origin
Window
}
;
use
net_traits
:
:
response
:
:
{
Response
ResponseBody
ResponseType
}
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
fmt
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
mem
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
str
;
use
std
:
:
sync
:
:
mpsc
:
:
{
Sender
Receiver
}
;
use
subresource_integrity
:
:
is_response_integrity_valid
;
pub
type
Target
<
'
a
>
=
&
'
a
mut
(
FetchTaskTarget
+
Send
)
;
pub
enum
Data
{
Payload
(
Vec
<
u8
>
)
Done
}
pub
struct
FetchContext
{
pub
state
:
HttpState
pub
user_agent
:
Cow
<
'
static
str
>
pub
devtools_chan
:
Option
<
Sender
<
DevtoolsControlMsg
>
>
pub
filemanager
:
FileManager
}
pub
type
DoneChannel
=
Option
<
(
Sender
<
Data
>
Receiver
<
Data
>
)
>
;
pub
fn
fetch
(
request
:
Rc
<
Request
>
target
:
Target
context
:
&
FetchContext
)
{
fetch_with_cors_cache
(
request
&
mut
CorsCache
:
:
new
(
)
target
context
)
;
}
pub
fn
fetch_with_cors_cache
(
request
:
Rc
<
Request
>
cache
:
&
mut
CorsCache
target
:
Target
context
:
&
FetchContext
)
{
if
request
.
window
.
get
(
)
=
=
Window
:
:
Client
{
}
else
{
request
.
window
.
set
(
Window
:
:
NoWindow
)
;
}
if
*
request
.
origin
.
borrow
(
)
=
=
Origin
:
:
Client
{
unimplemented
!
(
)
}
if
!
request
.
headers
.
borrow
(
)
.
has
:
:
<
Accept
>
(
)
{
let
value
=
match
request
.
type_
{
_
if
request
.
is_navigation_request
(
)
=
>
vec
!
[
qitem
(
mime
!
(
Text
/
Html
)
)
/
/
FIXME
:
This
should
properly
generate
a
MimeType
that
has
a
/
/
SubLevel
of
xhtml
+
xml
(
https
:
/
/
github
.
com
/
hyperium
/
mime
.
rs
/
issues
/
22
)
qitem
(
mime
!
(
Application
/
(
"
xhtml
+
xml
"
)
)
)
QualityItem
:
:
new
(
mime
!
(
Application
/
Xml
)
q
(
0
.
9
)
)
QualityItem
:
:
new
(
mime
!
(
_
/
_
)
q
(
0
.
8
)
)
]
Type
:
:
Image
=
>
vec
!
[
qitem
(
mime
!
(
Image
/
Png
)
)
/
/
FIXME
:
This
should
properly
generate
a
MimeType
that
has
a
/
/
SubLevel
of
svg
+
xml
(
https
:
/
/
github
.
com
/
hyperium
/
mime
.
rs
/
issues
/
22
)
qitem
(
mime
!
(
Image
/
(
"
svg
+
xml
"
)
)
)
QualityItem
:
:
new
(
mime
!
(
Image
/
_
)
q
(
0
.
8
)
)
QualityItem
:
:
new
(
mime
!
(
_
/
_
)
q
(
0
.
5
)
)
]
Type
:
:
Style
=
>
vec
!
[
qitem
(
mime
!
(
Text
/
Css
)
)
QualityItem
:
:
new
(
mime
!
(
_
/
_
)
q
(
0
.
1
)
)
]
_
=
>
vec
!
[
qitem
(
mime
!
(
_
/
_
)
)
]
}
;
request
.
headers
.
borrow_mut
(
)
.
set
(
Accept
(
value
)
)
;
}
set_default_accept_language
(
&
mut
request
.
headers
.
borrow_mut
(
)
)
;
if
request
.
is_subresource_request
(
)
{
}
main_fetch
(
request
cache
false
false
target
&
mut
None
&
context
)
;
}
pub
fn
main_fetch
(
request
:
Rc
<
Request
>
cache
:
&
mut
CorsCache
cors_flag
:
bool
recursive_flag
:
bool
target
:
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
mut
response
=
None
;
if
request
.
local_urls_only
{
match
request
.
current_url
(
)
.
scheme
(
)
{
"
about
"
|
"
blob
"
|
"
data
"
|
"
filesystem
"
=
>
(
)
_
=
>
response
=
Some
(
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Non
-
local
scheme
"
.
into
(
)
)
)
)
}
}
if
should_be_blocked_due_to_bad_port
(
&
request
.
url
(
)
)
{
response
=
Some
(
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Request
attempted
on
bad
port
"
.
into
(
)
)
)
)
;
}
let
referrer_policy
=
request
.
referrer_policy
.
get
(
)
.
unwrap_or
(
ReferrerPolicy
:
:
NoReferrerWhenDowngrade
)
;
request
.
referrer_policy
.
set
(
Some
(
referrer_policy
)
)
;
{
let
mut
referrer
=
request
.
referrer
.
borrow_mut
(
)
;
let
referrer_url
=
match
mem
:
:
replace
(
&
mut
*
referrer
Referrer
:
:
NoReferrer
)
{
Referrer
:
:
NoReferrer
=
>
None
Referrer
:
:
Client
=
>
{
request
.
headers
.
borrow_mut
(
)
.
remove
:
:
<
RefererHeader
>
(
)
;
None
}
Referrer
:
:
ReferrerUrl
(
url
)
=
>
{
request
.
headers
.
borrow_mut
(
)
.
remove
:
:
<
RefererHeader
>
(
)
;
determine_request_referrer
(
&
mut
*
request
.
headers
.
borrow_mut
(
)
referrer_policy
url
request
.
current_url
(
)
.
clone
(
)
)
}
}
;
if
let
Some
(
referrer_url
)
=
referrer_url
{
*
referrer
=
Referrer
:
:
ReferrerUrl
(
referrer_url
)
;
}
}
if
!
request
.
current_url
(
)
.
is_secure_scheme
(
)
&
&
request
.
current_url
(
)
.
domain
(
)
.
is_some
(
)
{
if
context
.
state
.
hsts_list
.
read
(
)
.
unwrap
(
)
.
is_host_secure
(
request
.
current_url
(
)
.
domain
(
)
.
unwrap
(
)
)
{
request
.
url_list
.
borrow_mut
(
)
.
last_mut
(
)
.
unwrap
(
)
.
as_mut_url
(
)
.
set_scheme
(
"
https
"
)
.
unwrap
(
)
;
}
}
let
response
=
match
response
{
Some
(
response
)
=
>
response
None
=
>
{
let
current_url
=
request
.
current_url
(
)
;
let
same_origin
=
if
let
Origin
:
:
Origin
(
ref
origin
)
=
*
request
.
origin
.
borrow
(
)
{
*
origin
=
=
current_url
.
origin
(
)
}
else
{
false
}
;
if
(
same_origin
&
&
!
cors_flag
)
|
|
current_url
.
scheme
(
)
=
=
"
data
"
|
|
current_url
.
scheme
(
)
=
=
"
file
"
|
|
current_url
.
scheme
(
)
=
=
"
about
"
|
|
request
.
mode
=
=
RequestMode
:
:
Navigate
{
basic_fetch
(
request
.
clone
(
)
cache
target
done_chan
context
)
}
else
if
request
.
mode
=
=
RequestMode
:
:
SameOrigin
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Cross
-
origin
response
"
.
into
(
)
)
)
}
else
if
request
.
mode
=
=
RequestMode
:
:
NoCors
{
request
.
response_tainting
.
set
(
ResponseTainting
:
:
Opaque
)
;
basic_fetch
(
request
.
clone
(
)
cache
target
done_chan
context
)
}
else
if
!
matches
!
(
current_url
.
scheme
(
)
"
http
"
|
"
https
"
)
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Non
-
http
scheme
"
.
into
(
)
)
)
}
else
if
request
.
use_cors_preflight
|
|
(
request
.
unsafe_request
&
&
(
!
is_simple_method
(
&
request
.
method
.
borrow
(
)
)
|
|
request
.
headers
.
borrow
(
)
.
iter
(
)
.
any
(
|
h
|
!
is_simple_header
(
&
h
)
)
)
)
{
request
.
response_tainting
.
set
(
ResponseTainting
:
:
CorsTainting
)
;
let
response
=
http_fetch
(
request
.
clone
(
)
cache
true
true
false
target
done_chan
context
)
;
if
response
.
is_network_error
(
)
{
}
response
}
else
{
request
.
response_tainting
.
set
(
ResponseTainting
:
:
CorsTainting
)
;
http_fetch
(
request
.
clone
(
)
cache
true
false
false
target
done_chan
context
)
}
}
}
;
if
recursive_flag
{
return
response
;
}
let
response
=
if
response
.
response_type
=
=
ResponseType
:
:
Default
{
let
response_type
=
match
request
.
response_tainting
.
get
(
)
{
ResponseTainting
:
:
Basic
=
>
ResponseType
:
:
Basic
ResponseTainting
:
:
CorsTainting
=
>
ResponseType
:
:
Cors
ResponseTainting
:
:
Opaque
=
>
ResponseType
:
:
Opaque
}
;
response
.
to_filtered
(
response_type
)
}
else
{
response
}
;
let
internal_error
=
{
let
network_error_response
;
let
internal_response
=
if
let
Some
(
error
)
=
response
.
get_network_error
(
)
{
network_error_response
=
Response
:
:
network_error
(
error
.
clone
(
)
)
;
&
network_error_response
}
else
{
response
.
actual_response
(
)
}
;
if
internal_response
.
url_list
.
borrow
(
)
.
is_empty
(
)
{
*
internal_response
.
url_list
.
borrow_mut
(
)
=
request
.
url_list
.
borrow
(
)
.
clone
(
)
;
}
let
blocked_error_response
;
let
internal_response
=
if
!
response
.
is_network_error
(
)
&
&
should_be_blocked_due_to_nosniff
(
request
.
type_
&
response
.
headers
)
{
blocked_error_response
=
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Blocked
by
nosniff
"
.
into
(
)
)
)
;
&
blocked_error_response
}
else
{
internal_response
}
;
let
not_network_error
=
!
response
.
is_network_error
(
)
&
&
!
internal_response
.
is_network_error
(
)
;
if
not_network_error
&
&
(
is_null_body_status
(
&
internal_response
.
status
)
|
|
match
*
request
.
method
.
borrow
(
)
{
Method
:
:
Head
|
Method
:
:
Connect
=
>
true
_
=
>
false
}
)
{
let
mut
body
=
internal_response
.
body
.
lock
(
)
.
unwrap
(
)
;
*
body
=
ResponseBody
:
:
Empty
;
}
internal_response
.
get_network_error
(
)
.
map
(
|
e
|
e
.
clone
(
)
)
}
;
let
response
=
if
let
Some
(
error
)
=
internal_error
{
Response
:
:
network_error
(
error
)
}
else
{
response
}
;
let
mut
response_loaded
=
false
;
let
response
=
if
!
response
.
is_network_error
(
)
&
&
*
request
.
integrity_metadata
.
borrow
(
)
!
=
"
"
{
wait_for_response
(
&
response
target
done_chan
)
;
response_loaded
=
true
;
let
ref
integrity_metadata
=
*
request
.
integrity_metadata
.
borrow
(
)
;
if
response
.
termination_reason
.
is_none
(
)
&
&
!
is_response_integrity_valid
(
integrity_metadata
&
response
)
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Subresource
integrity
validation
failed
"
.
into
(
)
)
)
}
else
{
response
}
}
else
{
response
}
;
if
request
.
synchronous
{
target
.
process_response
(
&
response
)
;
if
!
response_loaded
{
wait_for_response
(
&
response
target
done_chan
)
;
}
target
.
process_response_eof
(
&
response
)
;
return
response
;
}
if
request
.
body
.
borrow
(
)
.
is_some
(
)
&
&
matches
!
(
request
.
current_url
(
)
.
scheme
(
)
"
http
"
|
"
https
"
)
{
target
.
process_request_body
(
&
request
)
;
target
.
process_request_eof
(
&
request
)
;
}
target
.
process_response
(
&
response
)
;
if
!
response_loaded
{
wait_for_response
(
&
response
target
done_chan
)
;
}
target
.
process_response_eof
(
&
response
)
;
return
response
;
}
fn
wait_for_response
(
response
:
&
Response
target
:
Target
done_chan
:
&
mut
DoneChannel
)
{
if
let
Some
(
ref
ch
)
=
*
done_chan
{
loop
{
match
ch
.
1
.
recv
(
)
.
expect
(
"
fetch
worker
should
always
send
Done
before
terminating
"
)
{
Data
:
:
Payload
(
vec
)
=
>
{
target
.
process_response_chunk
(
vec
)
;
}
Data
:
:
Done
=
>
break
}
}
}
else
{
let
body
=
response
.
body
.
lock
(
)
.
unwrap
(
)
;
if
let
ResponseBody
:
:
Done
(
ref
vec
)
=
*
body
{
target
.
process_response_chunk
(
vec
.
clone
(
)
)
;
}
else
{
assert
!
(
*
body
=
=
ResponseBody
:
:
Empty
)
}
}
}
fn
basic_fetch
(
request
:
Rc
<
Request
>
cache
:
&
mut
CorsCache
target
:
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
url
=
request
.
current_url
(
)
;
match
url
.
scheme
(
)
{
"
about
"
if
url
.
path
(
)
=
=
"
blank
"
=
>
{
let
mut
response
=
Response
:
:
new
(
url
)
;
response
.
headers
.
set
(
ContentType
(
mime
!
(
Text
/
Html
;
Charset
=
Utf8
)
)
)
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
vec
!
[
]
)
;
response
}
"
http
"
|
"
https
"
=
>
{
http_fetch
(
request
.
clone
(
)
cache
false
false
false
target
done_chan
context
)
}
"
data
"
=
>
{
if
*
request
.
method
.
borrow
(
)
=
=
Method
:
:
Get
{
match
decode
(
&
url
)
{
Ok
(
(
mime
bytes
)
)
=
>
{
let
mut
response
=
Response
:
:
new
(
url
)
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
bytes
)
;
response
.
headers
.
set
(
ContentType
(
mime
)
)
;
response
}
Err
(
_
)
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Decoding
data
URL
failed
"
.
into
(
)
)
)
}
}
else
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
method
for
data
"
.
into
(
)
)
)
}
}
"
file
"
=
>
{
if
*
request
.
method
.
borrow
(
)
=
=
Method
:
:
Get
{
match
url
.
to_file_path
(
)
{
Ok
(
file_path
)
=
>
{
match
File
:
:
open
(
file_path
.
clone
(
)
)
{
Ok
(
mut
file
)
=
>
{
let
mut
bytes
=
vec
!
[
]
;
let
_
=
file
.
read_to_end
(
&
mut
bytes
)
;
let
mime
=
guess_mime_type
(
file_path
)
;
let
mut
response
=
Response
:
:
new
(
url
)
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
bytes
)
;
response
.
headers
.
set
(
ContentType
(
mime
)
)
;
response
}
_
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Opening
file
failed
"
.
into
(
)
)
)
}
}
_
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Constructing
file
path
failed
"
.
into
(
)
)
)
}
}
else
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
method
for
file
"
.
into
(
)
)
)
}
}
"
blob
"
=
>
{
println
!
(
"
Loading
blob
{
}
"
url
.
as_str
(
)
)
;
if
*
request
.
method
.
borrow
(
)
!
=
Method
:
:
Get
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
method
for
blob
"
.
into
(
)
)
)
;
}
match
load_blob_sync
(
url
.
clone
(
)
context
.
filemanager
.
clone
(
)
)
{
Ok
(
(
headers
bytes
)
)
=
>
{
let
mut
response
=
Response
:
:
new
(
url
)
;
response
.
headers
=
headers
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
bytes
)
;
response
}
Err
(
e
)
=
>
{
debug
!
(
"
Failed
to
load
{
}
:
{
:
?
}
"
url
e
)
;
Response
:
:
network_error
(
e
)
}
}
}
"
ftp
"
=
>
{
debug
!
(
"
ftp
is
not
implemented
"
)
;
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
scheme
"
.
into
(
)
)
)
}
_
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
scheme
"
.
into
(
)
)
)
}
}
pub
fn
is_simple_header
(
h
:
&
HeaderView
)
-
>
bool
{
if
h
.
is
:
:
<
ContentType
>
(
)
{
match
h
.
value
(
)
{
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Plain
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
WwwFormUrlEncoded
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Multipart
SubLevel
:
:
FormData
_
)
)
)
=
>
true
_
=
>
false
}
}
else
{
h
.
is
:
:
<
Accept
>
(
)
|
|
h
.
is
:
:
<
AcceptLanguage
>
(
)
|
|
h
.
is
:
:
<
ContentLanguage
>
(
)
}
}
pub
fn
is_simple_method
(
m
:
&
Method
)
-
>
bool
{
match
*
m
{
Method
:
:
Get
|
Method
:
:
Head
|
Method
:
:
Post
=
>
true
_
=
>
false
}
}
fn
is_null_body_status
(
status
:
&
Option
<
StatusCode
>
)
-
>
bool
{
match
*
status
{
Some
(
status
)
=
>
match
status
{
StatusCode
:
:
SwitchingProtocols
|
StatusCode
:
:
NoContent
|
StatusCode
:
:
ResetContent
|
StatusCode
:
:
NotModified
=
>
true
_
=
>
false
}
_
=
>
false
}
}
fn
should_be_blocked_due_to_nosniff
(
request_type
:
Type
response_headers
:
&
Headers
)
-
>
bool
{
#
[
derive
(
Debug
Clone
Copy
)
]
struct
XContentTypeOptions
;
impl
Header
for
XContentTypeOptions
{
fn
header_name
(
)
-
>
&
'
static
str
{
"
X
-
Content
-
Type
-
Options
"
}
fn
parse_header
(
raw
:
&
[
Vec
<
u8
>
]
)
-
>
HyperResult
<
Self
>
{
raw
.
first
(
)
.
and_then
(
|
v
|
str
:
:
from_utf8
(
v
)
.
ok
(
)
)
.
and_then
(
|
s
|
match
s
.
trim
(
)
.
to_lowercase
(
)
.
as_str
(
)
{
"
nosniff
"
=
>
Some
(
XContentTypeOptions
)
_
=
>
None
}
)
.
ok_or
(
Error
:
:
Header
)
}
}
impl
HeaderFormat
for
XContentTypeOptions
{
fn
fmt_header
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
nosniff
"
)
}
}
if
response_headers
.
get
:
:
<
XContentTypeOptions
>
(
)
.
is_none
(
)
{
return
false
;
}
let
content_type_header
=
response_headers
.
get
:
:
<
ContentType
>
(
)
;
#
[
inline
]
fn
is_javascript_mime_type
(
mime_type
:
&
Mime
)
-
>
bool
{
let
javascript_mime_types
:
[
Mime
;
16
]
=
[
mime
!
(
Application
/
(
"
ecmascript
"
)
)
mime
!
(
Application
/
(
"
javascript
"
)
)
mime
!
(
Application
/
(
"
x
-
ecmascript
"
)
)
mime
!
(
Application
/
(
"
x
-
javascript
"
)
)
mime
!
(
Text
/
(
"
ecmascript
"
)
)
mime
!
(
Text
/
(
"
javascript
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
0
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
1
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
2
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
3
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
4
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
5
"
)
)
mime
!
(
Text
/
(
"
jscript
"
)
)
mime
!
(
Text
/
(
"
livescript
"
)
)
mime
!
(
Text
/
(
"
x
-
ecmascript
"
)
)
mime
!
(
Text
/
(
"
x
-
javascript
"
)
)
]
;
javascript_mime_types
.
contains
(
mime_type
)
}
let
text_css
:
Mime
=
mime
!
(
Text
/
Css
)
;
return
match
request_type
{
Type
:
:
Script
=
>
{
match
content_type_header
{
Some
(
&
ContentType
(
ref
mime_type
)
)
=
>
!
is_javascript_mime_type
(
&
mime_type
)
None
=
>
true
}
}
Type
:
:
Style
=
>
{
match
content_type_header
{
Some
(
&
ContentType
(
ref
mime_type
)
)
=
>
mime_type
!
=
&
text_css
None
=
>
true
}
}
_
=
>
false
}
;
}
pub
fn
should_be_blocked_due_to_bad_port
(
url
:
&
ServoUrl
)
-
>
bool
{
let
scheme
=
url
.
scheme
(
)
;
let
port
=
if
let
Some
(
port
)
=
url
.
port
(
)
{
port
}
else
{
return
false
}
;
if
scheme
=
=
"
ftp
"
&
&
(
port
=
=
20
|
|
port
=
=
21
)
{
return
false
;
}
if
is_network_scheme
(
scheme
)
&
&
is_bad_port
(
port
)
{
return
true
;
}
false
}
fn
is_network_scheme
(
scheme
:
&
str
)
-
>
bool
{
scheme
=
=
"
ftp
"
|
|
scheme
=
=
"
http
"
|
|
scheme
=
=
"
https
"
}
fn
is_bad_port
(
port
:
u16
)
-
>
bool
{
static
BAD_PORTS
:
[
u16
;
64
]
=
[
1
7
9
11
13
15
17
19
20
21
22
23
25
37
42
43
53
77
79
87
95
101
102
103
104
109
110
111
113
115
117
119
123
135
139
143
179
389
465
512
513
514
515
526
530
531
532
540
556
563
587
601
636
993
995
2049
3659
4045
6000
6665
6666
6667
6668
6669
]
;
BAD_PORTS
.
binary_search
(
&
port
)
.
is_ok
(
)
}
