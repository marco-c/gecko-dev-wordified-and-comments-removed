use
connector
:
:
create_http_connector
;
use
data_loader
:
:
decode
;
use
devtools_traits
:
:
DevtoolsControlMsg
;
use
fetch
:
:
cors_cache
:
:
CORSCache
;
use
http_loader
:
:
{
HttpState
set_default_accept_encoding
set_request_cookies
}
;
use
http_loader
:
:
{
NetworkHttpRequestFactory
ReadResult
StreamedResponse
obtain_response
read_block
}
;
use
http_loader
:
:
{
auth_from_cache
determine_request_referrer
}
;
use
http_loader
:
:
{
send_response_to_devtools
send_request_to_devtools
}
;
use
hyper
:
:
header
:
:
{
Accept
AcceptLanguage
Authorization
AccessControlAllowCredentials
}
;
use
hyper
:
:
header
:
:
{
AccessControlAllowOrigin
AccessControlAllowHeaders
AccessControlAllowMethods
}
;
use
hyper
:
:
header
:
:
{
AccessControlRequestHeaders
AccessControlMaxAge
AccessControlRequestMethod
Basic
}
;
use
hyper
:
:
header
:
:
{
CacheControl
CacheDirective
ContentEncoding
ContentLength
ContentLanguage
ContentType
}
;
use
hyper
:
:
header
:
:
{
Encoding
HeaderView
Headers
Host
IfMatch
IfRange
IfUnmodifiedSince
IfModifiedSince
}
;
use
hyper
:
:
header
:
:
{
IfNoneMatch
Pragma
Location
QualityItem
Referer
as
RefererHeader
UserAgent
q
qitem
}
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
mime
:
:
{
Mime
SubLevel
TopLevel
}
;
use
hyper
:
:
status
:
:
StatusCode
;
use
hyper_serde
:
:
Serde
;
use
mime_guess
:
:
guess_mime_type
;
use
msg
:
:
constellation_msg
:
:
ReferrerPolicy
;
use
net_traits
:
:
FetchTaskTarget
;
use
net_traits
:
:
request
:
:
{
CacheMode
CredentialsMode
Destination
}
;
use
net_traits
:
:
request
:
:
{
RedirectMode
Referer
Request
RequestMode
ResponseTainting
}
;
use
net_traits
:
:
request
:
:
{
Type
Origin
Window
}
;
use
net_traits
:
:
response
:
:
{
HttpsState
TerminationReason
}
;
use
net_traits
:
:
response
:
:
{
Response
ResponseBody
ResponseType
}
;
use
resource_thread
:
:
CancellationListener
;
use
std
:
:
collections
:
:
HashSet
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
iter
:
:
FromIterator
;
use
std
:
:
mem
:
:
swap
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Sender
Receiver
}
;
use
unicase
:
:
UniCase
;
use
url
:
:
{
Origin
as
UrlOrigin
Url
}
;
use
util
:
:
thread
:
:
spawn_named
;
use
uuid
;
pub
type
Target
=
Option
<
Box
<
FetchTaskTarget
+
Send
>
>
;
enum
Data
{
Payload
(
Vec
<
u8
>
)
Done
}
pub
struct
FetchContext
{
pub
state
:
HttpState
pub
user_agent
:
String
pub
devtools_chan
:
Option
<
Sender
<
DevtoolsControlMsg
>
>
}
type
DoneChannel
=
Option
<
(
Sender
<
Data
>
Receiver
<
Data
>
)
>
;
pub
fn
fetch
(
request
:
Rc
<
Request
>
target
:
&
mut
Target
context
:
FetchContext
)
-
>
Response
{
fetch_with_cors_cache
(
request
&
mut
CORSCache
:
:
new
(
)
target
context
)
}
pub
fn
fetch_with_cors_cache
(
request
:
Rc
<
Request
>
cache
:
&
mut
CORSCache
target
:
&
mut
Target
context
:
FetchContext
)
-
>
Response
{
if
request
.
window
.
get
(
)
=
=
Window
:
:
Client
{
}
else
{
request
.
window
.
set
(
Window
:
:
NoWindow
)
;
}
if
*
request
.
origin
.
borrow
(
)
=
=
Origin
:
:
Client
{
unimplemented
!
(
)
}
if
!
request
.
headers
.
borrow
(
)
.
has
:
:
<
Accept
>
(
)
{
let
value
=
match
request
.
type_
{
_
if
request
.
is_navigation_request
(
)
=
>
vec
!
[
qitem
(
mime
!
(
Text
/
Html
)
)
/
/
FIXME
:
This
should
properly
generate
a
MimeType
that
has
a
/
/
SubLevel
of
xhtml
+
xml
(
https
:
/
/
github
.
com
/
hyperium
/
mime
.
rs
/
issues
/
22
)
qitem
(
mime
!
(
Application
/
(
"
xhtml
+
xml
"
)
)
)
QualityItem
:
:
new
(
mime
!
(
Application
/
Xml
)
q
(
0
.
9
)
)
QualityItem
:
:
new
(
mime
!
(
_
/
_
)
q
(
0
.
8
)
)
]
Type
:
:
Image
=
>
vec
!
[
qitem
(
mime
!
(
Image
/
Png
)
)
/
/
FIXME
:
This
should
properly
generate
a
MimeType
that
has
a
/
/
SubLevel
of
svg
+
xml
(
https
:
/
/
github
.
com
/
hyperium
/
mime
.
rs
/
issues
/
22
)
qitem
(
mime
!
(
Image
/
(
"
svg
+
xml
"
)
)
)
QualityItem
:
:
new
(
mime
!
(
Image
/
_
)
q
(
0
.
8
)
)
QualityItem
:
:
new
(
mime
!
(
_
/
_
)
q
(
0
.
5
)
)
]
Type
:
:
Style
=
>
vec
!
[
qitem
(
mime
!
(
Text
/
Css
)
)
QualityItem
:
:
new
(
mime
!
(
_
/
_
)
q
(
0
.
1
)
)
]
_
=
>
vec
!
[
qitem
(
mime
!
(
_
/
_
)
)
]
}
;
request
.
headers
.
borrow_mut
(
)
.
set
(
Accept
(
value
)
)
;
}
if
!
request
.
headers
.
borrow
(
)
.
has
:
:
<
AcceptLanguage
>
(
)
{
request
.
headers
.
borrow_mut
(
)
.
set
(
AcceptLanguage
(
vec
!
[
qitem
(
"
en
-
US
"
.
parse
(
)
.
unwrap
(
)
)
]
)
)
;
}
if
request
.
is_subresource_request
(
)
{
}
main_fetch
(
request
cache
false
false
target
&
mut
None
&
context
)
}
fn
main_fetch
(
request
:
Rc
<
Request
>
cache
:
&
mut
CORSCache
cors_flag
:
bool
recursive_flag
:
bool
target
:
&
mut
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
mut
response
=
None
;
if
request
.
local_urls_only
{
match
request
.
current_url
(
)
.
scheme
(
)
{
"
about
"
|
"
blob
"
|
"
data
"
|
"
filesystem
"
=
>
(
)
_
=
>
response
=
Some
(
Response
:
:
network_error
(
)
)
}
}
if
request
.
referrer_policy
.
get
(
)
.
is_none
(
)
{
request
.
referrer_policy
.
set
(
Some
(
ReferrerPolicy
:
:
NoReferrerWhenDowngrade
)
)
;
}
if
*
request
.
referer
.
borrow
(
)
!
=
Referer
:
:
NoReferer
{
request
.
headers
.
borrow_mut
(
)
.
remove
:
:
<
RefererHeader
>
(
)
;
let
referrer_url
=
determine_request_referrer
(
&
mut
*
request
.
headers
.
borrow_mut
(
)
request
.
referrer_policy
.
get
(
)
request
.
referer
.
borrow_mut
(
)
.
take
(
)
request
.
current_url
(
)
.
clone
(
)
)
;
*
request
.
referer
.
borrow_mut
(
)
=
Referer
:
:
from_url
(
referrer_url
)
;
}
let
response
=
match
response
{
Some
(
response
)
=
>
response
None
=
>
{
let
current_url
=
request
.
current_url
(
)
;
let
same_origin
=
if
let
Origin
:
:
Origin
(
ref
origin
)
=
*
request
.
origin
.
borrow
(
)
{
*
origin
=
=
current_url
.
origin
(
)
}
else
{
false
}
;
if
(
same_origin
&
&
!
cors_flag
)
|
|
(
current_url
.
scheme
(
)
=
=
"
data
"
&
&
request
.
same_origin_data
.
get
(
)
)
|
|
(
current_url
.
scheme
(
)
=
=
"
file
"
&
&
request
.
same_origin_data
.
get
(
)
)
|
|
current_url
.
scheme
(
)
=
=
"
about
"
|
|
request
.
mode
=
=
RequestMode
:
:
Navigate
{
basic_fetch
(
request
.
clone
(
)
cache
target
done_chan
context
)
}
else
if
request
.
mode
=
=
RequestMode
:
:
SameOrigin
{
Response
:
:
network_error
(
)
}
else
if
request
.
mode
=
=
RequestMode
:
:
NoCORS
{
request
.
response_tainting
.
set
(
ResponseTainting
:
:
Opaque
)
;
basic_fetch
(
request
.
clone
(
)
cache
target
done_chan
context
)
}
else
if
!
matches
!
(
current_url
.
scheme
(
)
"
http
"
|
"
https
"
)
{
Response
:
:
network_error
(
)
}
else
if
request
.
use_cors_preflight
|
|
(
request
.
unsafe_request
&
&
(
!
is_simple_method
(
&
request
.
method
.
borrow
(
)
)
|
|
request
.
headers
.
borrow
(
)
.
iter
(
)
.
any
(
|
h
|
!
is_simple_header
(
&
h
)
)
)
)
{
request
.
response_tainting
.
set
(
ResponseTainting
:
:
CORSTainting
)
;
request
.
redirect_mode
.
set
(
RedirectMode
:
:
Error
)
;
let
response
=
http_fetch
(
request
.
clone
(
)
cache
true
true
false
target
done_chan
context
)
;
if
response
.
is_network_error
(
)
{
}
response
}
else
{
request
.
response_tainting
.
set
(
ResponseTainting
:
:
CORSTainting
)
;
http_fetch
(
request
.
clone
(
)
cache
true
false
false
target
done_chan
context
)
}
}
}
;
if
recursive_flag
{
return
response
;
}
let
response
=
if
response
.
response_type
=
=
ResponseType
:
:
Default
{
let
response_type
=
match
request
.
response_tainting
.
get
(
)
{
ResponseTainting
:
:
Basic
=
>
ResponseType
:
:
Basic
ResponseTainting
:
:
CORSTainting
=
>
ResponseType
:
:
CORS
ResponseTainting
:
:
Opaque
=
>
ResponseType
:
:
Opaque
}
;
response
.
to_filtered
(
response_type
)
}
else
{
response
}
;
{
let
network_error_res
=
Response
:
:
network_error
(
)
;
let
internal_response
=
if
response
.
is_network_error
(
)
{
&
network_error_res
}
else
{
response
.
actual_response
(
)
}
;
if
internal_response
.
url_list
.
borrow
(
)
.
is_empty
(
)
{
*
internal_response
.
url_list
.
borrow_mut
(
)
=
request
.
url_list
.
borrow
(
)
.
clone
(
)
;
}
if
!
response
.
is_network_error
(
)
&
&
(
is_null_body_status
(
&
internal_response
.
status
)
|
|
match
*
request
.
method
.
borrow
(
)
{
Method
:
:
Head
|
Method
:
:
Connect
=
>
true
_
=
>
false
}
)
{
let
mut
body
=
internal_response
.
body
.
lock
(
)
.
unwrap
(
)
;
*
body
=
ResponseBody
:
:
Empty
;
}
}
if
request
.
synchronous
{
if
let
Some
(
ref
mut
target
)
=
*
target
{
target
.
process_response
(
&
response
)
;
}
if
let
Some
(
ref
ch
)
=
*
done_chan
{
loop
{
match
ch
.
1
.
recv
(
)
.
expect
(
"
fetch
worker
should
always
send
Done
before
terminating
"
)
{
Data
:
:
Payload
(
vec
)
=
>
{
if
let
Some
(
ref
mut
target
)
=
*
target
{
target
.
process_response_chunk
(
vec
)
;
}
}
Data
:
:
Done
=
>
break
}
}
}
else
if
let
ResponseBody
:
:
Done
(
ref
vec
)
=
*
response
.
body
.
lock
(
)
.
unwrap
(
)
{
if
let
Some
(
ref
mut
target
)
=
*
target
{
target
.
process_response_chunk
(
vec
.
clone
(
)
)
;
}
}
else
{
assert
!
(
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
=
ResponseBody
:
:
Empty
)
}
if
let
Some
(
ref
mut
target
)
=
*
target
{
target
.
process_response_eof
(
&
response
)
;
}
return
response
;
}
if
request
.
body
.
borrow
(
)
.
is_some
(
)
&
&
matches
!
(
request
.
current_url
(
)
.
scheme
(
)
"
http
"
|
"
https
"
)
{
if
let
Some
(
ref
mut
target
)
=
*
target
{
target
.
process_request_body
(
&
request
)
;
target
.
process_request_eof
(
&
request
)
;
}
}
if
let
Some
(
ref
mut
target
)
=
*
target
{
target
.
process_response
(
&
response
)
;
}
if
let
Some
(
ref
ch
)
=
*
done_chan
{
loop
{
match
ch
.
1
.
recv
(
)
.
expect
(
"
fetch
worker
should
always
send
Done
before
terminating
"
)
{
Data
:
:
Payload
(
vec
)
=
>
{
if
let
Some
(
ref
mut
target
)
=
*
target
{
target
.
process_response_chunk
(
vec
)
;
}
}
Data
:
:
Done
=
>
break
}
}
}
else
if
let
Some
(
ref
mut
target
)
=
*
target
{
if
let
ResponseBody
:
:
Done
(
ref
vec
)
=
*
response
.
body
.
lock
(
)
.
unwrap
(
)
{
target
.
process_response_chunk
(
vec
.
clone
(
)
)
;
}
else
{
assert
!
(
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
=
ResponseBody
:
:
Empty
)
}
}
request
.
done
.
set
(
true
)
;
if
let
Some
(
ref
mut
target
)
=
*
target
{
target
.
process_response_eof
(
&
response
)
;
}
return
response
;
}
fn
basic_fetch
(
request
:
Rc
<
Request
>
cache
:
&
mut
CORSCache
target
:
&
mut
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
url
=
request
.
current_url
(
)
;
match
url
.
scheme
(
)
{
"
about
"
if
url
.
path
(
)
=
=
"
blank
"
=
>
{
let
mut
response
=
Response
:
:
new
(
)
;
response
.
url
=
Some
(
url
)
;
response
.
headers
.
set
(
ContentType
(
mime
!
(
Text
/
Html
;
Charset
=
Utf8
)
)
)
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
vec
!
[
]
)
;
response
}
"
http
"
|
"
https
"
=
>
{
http_fetch
(
request
.
clone
(
)
cache
false
false
false
target
done_chan
context
)
}
"
data
"
=
>
{
if
*
request
.
method
.
borrow
(
)
=
=
Method
:
:
Get
{
match
decode
(
&
url
)
{
Ok
(
(
mime
bytes
)
)
=
>
{
let
mut
response
=
Response
:
:
new
(
)
;
response
.
url
=
Some
(
url
.
clone
(
)
)
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
bytes
)
;
response
.
headers
.
set
(
ContentType
(
mime
)
)
;
response
}
Err
(
_
)
=
>
Response
:
:
network_error
(
)
}
}
else
{
Response
:
:
network_error
(
)
}
}
"
file
"
=
>
{
if
*
request
.
method
.
borrow
(
)
=
=
Method
:
:
Get
{
match
url
.
to_file_path
(
)
{
Ok
(
file_path
)
=
>
{
File
:
:
open
(
file_path
.
clone
(
)
)
.
ok
(
)
.
map_or
(
Response
:
:
network_error
(
)
|
mut
file
|
{
let
mut
bytes
=
vec
!
[
]
;
let
_
=
file
.
read_to_end
(
&
mut
bytes
)
;
let
mime
=
guess_mime_type
(
file_path
)
;
let
mut
response
=
Response
:
:
new
(
)
;
response
.
url
=
Some
(
url
.
clone
(
)
)
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
bytes
)
;
response
.
headers
.
set
(
ContentType
(
mime
)
)
;
response
}
)
}
_
=
>
Response
:
:
network_error
(
)
}
}
else
{
Response
:
:
network_error
(
)
}
}
"
blob
"
|
"
ftp
"
=
>
{
panic
!
(
"
Unimplemented
scheme
for
Fetch
"
)
}
_
=
>
Response
:
:
network_error
(
)
}
}
fn
http_fetch
(
request
:
Rc
<
Request
>
cache
:
&
mut
CORSCache
cors_flag
:
bool
cors_preflight_flag
:
bool
authentication_fetch_flag
:
bool
target
:
&
mut
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
*
done_chan
=
None
;
let
mut
response
:
Option
<
Response
>
=
None
;
if
!
request
.
skip_service_worker
.
get
(
)
&
&
!
request
.
is_service_worker_global_scope
{
if
let
Some
(
ref
res
)
=
response
{
if
(
res
.
response_type
=
=
ResponseType
:
:
Opaque
&
&
request
.
mode
!
=
RequestMode
:
:
NoCORS
)
|
|
(
res
.
response_type
=
=
ResponseType
:
:
OpaqueRedirect
&
&
request
.
redirect_mode
.
get
(
)
!
=
RedirectMode
:
:
Manual
)
|
|
(
res
.
url_list
.
borrow
(
)
.
len
(
)
>
1
&
&
request
.
redirect_mode
.
get
(
)
!
=
RedirectMode
:
:
Follow
)
|
|
res
.
response_type
=
=
ResponseType
:
:
Error
{
return
Response
:
:
network_error
(
)
;
}
}
}
let
credentials
=
match
request
.
credentials_mode
{
CredentialsMode
:
:
Include
=
>
true
CredentialsMode
:
:
CredentialsSameOrigin
if
request
.
response_tainting
.
get
(
)
=
=
ResponseTainting
:
:
Basic
=
>
true
_
=
>
false
}
;
if
response
.
is_none
(
)
{
if
cors_preflight_flag
{
let
method_cache_match
=
cache
.
match_method
(
&
*
request
request
.
method
.
borrow
(
)
.
clone
(
)
)
;
let
method_mismatch
=
!
method_cache_match
&
&
(
!
is_simple_method
(
&
request
.
method
.
borrow
(
)
)
|
|
request
.
use_cors_preflight
)
;
let
header_mismatch
=
request
.
headers
.
borrow
(
)
.
iter
(
)
.
any
(
|
view
|
!
cache
.
match_header
(
&
*
request
view
.
name
(
)
)
&
&
!
is_simple_header
(
&
view
)
)
;
if
method_mismatch
|
|
header_mismatch
{
let
preflight_result
=
cors_preflight_fetch
(
request
.
clone
(
)
cache
context
)
;
if
preflight_result
.
response_type
=
=
ResponseType
:
:
Error
{
return
Response
:
:
network_error
(
)
;
}
}
}
request
.
skip_service_worker
.
set
(
true
)
;
let
fetch_result
=
http_network_or_cache_fetch
(
request
.
clone
(
)
credentials
authentication_fetch_flag
done_chan
context
)
;
if
cors_flag
&
&
cors_check
(
request
.
clone
(
)
&
fetch_result
)
.
is_err
(
)
{
return
Response
:
:
network_error
(
)
;
}
fetch_result
.
return_internal
.
set
(
false
)
;
response
=
Some
(
fetch_result
)
;
}
let
mut
response
=
response
.
unwrap
(
)
;
match
response
.
actual_response
(
)
.
status
.
unwrap
(
)
{
StatusCode
:
:
MovedPermanently
|
StatusCode
:
:
Found
|
StatusCode
:
:
SeeOther
|
StatusCode
:
:
TemporaryRedirect
|
StatusCode
:
:
PermanentRedirect
=
>
{
response
=
match
request
.
redirect_mode
.
get
(
)
{
RedirectMode
:
:
Error
=
>
Response
:
:
network_error
(
)
RedirectMode
:
:
Manual
=
>
{
response
.
to_filtered
(
ResponseType
:
:
OpaqueRedirect
)
}
RedirectMode
:
:
Follow
=
>
{
response
.
return_internal
.
set
(
true
)
;
http_redirect_fetch
(
request
cache
Rc
:
:
new
(
response
)
cors_flag
target
done_chan
context
)
}
}
}
StatusCode
:
:
Unauthorized
=
>
{
if
cors_flag
|
|
!
credentials
{
return
response
;
}
if
!
request
.
use_url_credentials
|
|
authentication_fetch_flag
{
return
response
;
}
return
http_fetch
(
request
cache
cors_flag
cors_preflight_flag
true
target
done_chan
context
)
;
}
StatusCode
:
:
ProxyAuthenticationRequired
=
>
{
return
response
;
}
_
=
>
{
}
}
if
authentication_fetch_flag
{
}
response
.
return_internal
.
set
(
true
)
;
response
}
fn
http_redirect_fetch
(
request
:
Rc
<
Request
>
cache
:
&
mut
CORSCache
response
:
Rc
<
Response
>
cors_flag
:
bool
target
:
&
mut
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
assert_eq
!
(
response
.
return_internal
.
get
(
)
true
)
;
if
!
response
.
actual_response
(
)
.
headers
.
has
:
:
<
Location
>
(
)
{
return
Rc
:
:
try_unwrap
(
response
)
.
ok
(
)
.
unwrap
(
)
;
}
let
location
=
match
response
.
actual_response
(
)
.
headers
.
get
:
:
<
Location
>
(
)
{
Some
(
&
Location
(
ref
location
)
)
=
>
location
.
clone
(
)
_
=
>
return
Response
:
:
network_error
(
)
}
;
let
response_url
=
response
.
actual_response
(
)
.
url
.
as_ref
(
)
.
unwrap
(
)
;
let
location_url
=
response_url
.
join
(
&
*
location
)
;
let
location_url
=
match
location_url
{
Ok
(
url
)
=
>
url
_
=
>
return
Response
:
:
network_error
(
)
}
;
if
request
.
redirect_count
.
get
(
)
>
=
20
{
return
Response
:
:
network_error
(
)
;
}
request
.
redirect_count
.
set
(
request
.
redirect_count
.
get
(
)
+
1
)
;
request
.
same_origin_data
.
set
(
false
)
;
let
same_origin
=
if
let
Origin
:
:
Origin
(
ref
origin
)
=
*
request
.
origin
.
borrow
(
)
{
*
origin
=
=
request
.
current_url
(
)
.
origin
(
)
}
else
{
false
}
;
let
has_credentials
=
has_credentials
(
&
location_url
)
;
if
request
.
mode
=
=
RequestMode
:
:
CORSMode
&
&
!
same_origin
&
&
has_credentials
{
return
Response
:
:
network_error
(
)
;
}
if
cors_flag
&
&
has_credentials
{
return
Response
:
:
network_error
(
)
;
}
if
cors_flag
&
&
!
same_origin
{
*
request
.
origin
.
borrow_mut
(
)
=
Origin
:
:
Origin
(
UrlOrigin
:
:
new_opaque
(
)
)
;
}
let
status_code
=
response
.
actual_response
(
)
.
status
.
unwrap
(
)
;
if
(
(
status_code
=
=
StatusCode
:
:
MovedPermanently
|
|
status_code
=
=
StatusCode
:
:
Found
)
&
&
*
request
.
method
.
borrow
(
)
=
=
Method
:
:
Post
)
|
|
status_code
=
=
StatusCode
:
:
SeeOther
{
*
request
.
method
.
borrow_mut
(
)
=
Method
:
:
Get
;
*
request
.
body
.
borrow_mut
(
)
=
None
;
}
request
.
url_list
.
borrow_mut
(
)
.
push
(
location_url
)
;
main_fetch
(
request
cache
cors_flag
true
target
done_chan
context
)
}
fn
http_network_or_cache_fetch
(
request
:
Rc
<
Request
>
credentials_flag
:
bool
authentication_fetch_flag
:
bool
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
request_has_no_window
=
true
;
let
http_request
=
if
request_has_no_window
&
&
request
.
redirect_mode
.
get
(
)
=
=
RedirectMode
:
:
Error
{
request
}
else
{
Rc
:
:
new
(
(
*
request
)
.
clone
(
)
)
}
;
let
content_length_value
=
match
*
http_request
.
body
.
borrow
(
)
{
None
=
>
match
*
http_request
.
method
.
borrow
(
)
{
Method
:
:
Head
|
Method
:
:
Post
|
Method
:
:
Put
=
>
Some
(
0
)
_
=
>
None
}
Some
(
ref
http_request_body
)
=
>
Some
(
http_request_body
.
len
(
)
as
u64
)
}
;
if
let
Some
(
content_length_value
)
=
content_length_value
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
ContentLength
(
content_length_value
)
)
;
}
match
*
http_request
.
referer
.
borrow
(
)
{
Referer
:
:
NoReferer
=
>
(
)
Referer
:
:
RefererUrl
(
ref
http_request_referer
)
=
>
http_request
.
headers
.
borrow_mut
(
)
.
set
(
RefererHeader
(
http_request_referer
.
to_string
(
)
)
)
Referer
:
:
Client
=
>
unreachable
!
(
)
}
;
if
http_request
.
omit_origin_header
.
get
(
)
=
=
false
{
}
if
!
http_request
.
headers
.
borrow
(
)
.
has
:
:
<
UserAgent
>
(
)
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
UserAgent
(
context
.
user_agent
.
clone
(
)
)
)
;
}
match
http_request
.
cache_mode
.
get
(
)
{
CacheMode
:
:
Default
if
is_no_store_cache
(
&
http_request
.
headers
.
borrow
(
)
)
=
>
{
http_request
.
cache_mode
.
set
(
CacheMode
:
:
NoStore
)
;
}
CacheMode
:
:
NoCache
if
!
http_request
.
headers
.
borrow
(
)
.
has
:
:
<
CacheControl
>
(
)
=
>
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
CacheControl
(
vec
!
[
CacheDirective
:
:
MaxAge
(
0
)
]
)
)
;
}
CacheMode
:
:
Reload
=
>
{
if
!
http_request
.
headers
.
borrow
(
)
.
has
:
:
<
Pragma
>
(
)
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
Pragma
:
:
NoCache
)
;
}
if
!
http_request
.
headers
.
borrow
(
)
.
has
:
:
<
CacheControl
>
(
)
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
CacheControl
(
vec
!
[
CacheDirective
:
:
NoCache
]
)
)
;
}
}
_
=
>
{
}
}
let
current_url
=
http_request
.
current_url
(
)
;
{
let
headers
=
&
mut
*
http_request
.
headers
.
borrow_mut
(
)
;
let
host
=
Host
{
hostname
:
current_url
.
host_str
(
)
.
unwrap
(
)
.
to_owned
(
)
port
:
current_url
.
port_or_known_default
(
)
}
;
headers
.
set
(
host
)
;
set_default_accept_encoding
(
headers
)
;
}
if
credentials_flag
{
set_request_cookies
(
&
current_url
&
mut
*
http_request
.
headers
.
borrow_mut
(
)
&
context
.
state
.
cookie_jar
)
;
if
!
http_request
.
headers
.
borrow
(
)
.
has
:
:
<
Authorization
<
String
>
>
(
)
{
let
mut
authorization_value
=
None
;
if
let
Some
(
basic
)
=
auth_from_cache
(
&
context
.
state
.
auth_cache
&
current_url
)
{
if
!
http_request
.
use_url_credentials
|
|
!
has_credentials
(
&
current_url
)
{
authorization_value
=
Some
(
basic
)
;
}
}
if
authentication_fetch_flag
&
&
authorization_value
.
is_none
(
)
{
if
has_credentials
(
&
current_url
)
{
authorization_value
=
Some
(
Basic
{
username
:
current_url
.
username
(
)
.
to_owned
(
)
password
:
current_url
.
password
(
)
.
map
(
str
:
:
to_owned
)
}
)
}
}
if
let
Some
(
basic
)
=
authorization_value
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
Authorization
(
basic
)
)
;
}
}
}
let
mut
response
:
Option
<
Response
>
=
None
;
let
complete_http_response_from_cache
:
Option
<
Response
>
=
None
;
if
http_request
.
cache_mode
.
get
(
)
!
=
CacheMode
:
:
NoStore
&
&
http_request
.
cache_mode
.
get
(
)
!
=
CacheMode
:
:
Reload
&
&
complete_http_response_from_cache
.
is_some
(
)
{
if
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
ForceCache
{
}
let
revalidation_needed
=
match
response
{
Some
(
ref
response
)
=
>
response_needs_revalidation
(
&
response
)
_
=
>
false
}
;
if
!
revalidation_needed
&
&
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
{
}
if
revalidation_needed
&
&
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
NoCache
{
}
}
else
if
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
ForceCache
{
}
if
response
.
is_none
(
)
{
response
=
Some
(
http_network_fetch
(
http_request
.
clone
(
)
credentials_flag
done_chan
context
.
devtools_chan
.
clone
(
)
)
)
;
}
let
response
=
response
.
unwrap
(
)
;
if
let
Some
(
status
)
=
response
.
status
{
if
status
=
=
StatusCode
:
:
NotModified
&
&
(
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
NoCache
)
{
}
}
response
}
fn
http_network_fetch
(
request
:
Rc
<
Request
>
_credentials_flag
:
bool
done_chan
:
&
mut
DoneChannel
devtools_chan
:
Option
<
Sender
<
DevtoolsControlMsg
>
>
)
-
>
Response
{
let
connection
=
create_http_connector
(
)
;
let
factory
=
NetworkHttpRequestFactory
{
connector
:
connection
}
;
let
url
=
request
.
current_url
(
)
;
let
cancellation_listener
=
CancellationListener
:
:
new
(
None
)
;
let
request_id
=
devtools_chan
.
as_ref
(
)
.
map
(
|
_
|
{
uuid
:
:
Uuid
:
:
new_v4
(
)
.
simple
(
)
.
to_string
(
)
}
)
;
let
is_xhr
=
request
.
destination
=
=
Destination
:
:
None
;
let
wrapped_response
=
obtain_response
(
&
factory
&
url
&
request
.
method
.
borrow
(
)
&
request
.
headers
.
borrow
(
)
&
cancellation_listener
&
request
.
body
.
borrow
(
)
&
request
.
method
.
borrow
(
)
&
request
.
pipeline_id
.
get
(
)
request
.
redirect_count
.
get
(
)
+
1
request_id
.
as_ref
(
)
.
map
(
Deref
:
:
deref
)
is_xhr
)
;
let
pipeline_id
=
request
.
pipeline_id
.
get
(
)
;
let
mut
response
=
Response
:
:
new
(
)
;
match
wrapped_response
{
Ok
(
(
res
msg
)
)
=
>
{
response
.
url
=
Some
(
url
.
clone
(
)
)
;
response
.
status
=
Some
(
res
.
response
.
status
)
;
response
.
raw_status
=
Some
(
(
res
.
response
.
status_raw
(
)
.
0
res
.
response
.
status_raw
(
)
.
1
.
as_bytes
(
)
.
to_vec
(
)
)
)
;
response
.
headers
=
res
.
response
.
headers
.
clone
(
)
;
let
res_body
=
response
.
body
.
clone
(
)
;
*
done_chan
=
Some
(
channel
(
)
)
;
let
meta
=
response
.
metadata
(
)
.
expect
(
"
Response
metadata
should
exist
at
this
stage
"
)
;
let
done_sender
=
done_chan
.
as_ref
(
)
.
map
(
|
ch
|
ch
.
0
.
clone
(
)
)
;
let
devtools_sender
=
devtools_chan
.
clone
(
)
;
let
meta_status
=
meta
.
status
.
clone
(
)
;
let
meta_headers
=
meta
.
headers
.
clone
(
)
;
spawn_named
(
format
!
(
"
fetch
worker
thread
"
)
move
|
|
{
match
StreamedResponse
:
:
from_http_response
(
box
res
meta
)
{
Ok
(
mut
res
)
=
>
{
*
res_body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Receiving
(
vec
!
[
]
)
;
if
let
Some
(
ref
sender
)
=
devtools_sender
{
if
let
Some
(
m
)
=
msg
{
send_request_to_devtools
(
m
&
sender
)
;
}
/
/
-
-
-
Tell
devtools
that
we
got
a
response
/
/
Send
an
HttpResponse
message
to
devtools
with
the
corresponding
request_id
if
let
Some
(
pipeline_id
)
=
pipeline_id
{
send_response_to_devtools
(
&
sender
request_id
.
unwrap
(
)
meta_headers
.
map
(
Serde
:
:
into_inner
)
meta_status
pipeline_id
)
;
}
}
loop
{
match
read_block
(
&
mut
res
)
{
Ok
(
ReadResult
:
:
Payload
(
chunk
)
)
=
>
{
if
let
ResponseBody
:
:
Receiving
(
ref
mut
body
)
=
*
res_body
.
lock
(
)
.
unwrap
(
)
{
body
.
extend_from_slice
(
&
chunk
)
;
if
let
Some
(
ref
sender
)
=
done_sender
{
let
_
=
sender
.
send
(
Data
:
:
Payload
(
chunk
)
)
;
}
}
}
Ok
(
ReadResult
:
:
EOF
)
|
Err
(
_
)
=
>
{
let
mut
empty_vec
=
Vec
:
:
new
(
)
;
let
completed_body
=
match
*
res_body
.
lock
(
)
.
unwrap
(
)
{
ResponseBody
:
:
Receiving
(
ref
mut
body
)
=
>
{
/
/
avoid
cloning
the
body
swap
(
body
&
mut
empty_vec
)
;
empty_vec
}
_
=
>
empty_vec
}
;
*
res_body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
completed_body
)
;
if
let
Some
(
ref
sender
)
=
done_sender
{
let
_
=
sender
.
send
(
Data
:
:
Done
)
;
}
break
;
}
}
}
}
Err
(
_
)
=
>
{
/
/
XXXManishearth
we
should
propagate
this
error
somehow
*
res_body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
vec
!
[
]
)
;
if
let
Some
(
ref
sender
)
=
done_sender
{
let
_
=
sender
.
send
(
Data
:
:
Done
)
;
}
}
}
}
)
;
}
Err
(
_
)
=
>
{
response
.
termination_reason
=
Some
(
TerminationReason
:
:
Fatal
)
;
}
}
;
/
/
TODO
these
substeps
aren
'
t
possible
yet
/
/
Substep
1
/
/
Substep
2
/
/
TODO
Determine
if
response
was
retrieved
over
HTTPS
/
/
TODO
Servo
needs
to
decide
what
ciphers
are
to
be
treated
as
"
deprecated
"
response
.
https_state
=
HttpsState
:
:
None
;
/
/
TODO
Read
request
/
/
Step
5
-
9
/
/
(
needs
stream
bodies
)
/
/
Step
10
/
/
TODO
when
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1030660
/
/
is
resolved
this
step
will
become
uneccesary
/
/
TODO
this
step
if
let
Some
(
encoding
)
=
response
.
headers
.
get
:
:
<
ContentEncoding
>
(
)
{
if
encoding
.
contains
(
&
Encoding
:
:
Gzip
)
{
}
else
if
encoding
.
contains
(
&
Encoding
:
:
Compress
)
{
}
}
;
/
/
Step
11
/
/
TODO
this
step
isn
'
t
possible
yet
(
CSP
)
/
/
Step
12
if
response
.
is_network_error
(
)
&
&
request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
NoStore
{
/
/
TODO
update
response
in
the
HTTP
cache
for
request
}
/
/
TODO
this
step
isn
'
t
possible
yet
/
/
Step
13
/
/
TODO
these
steps
/
/
Step
14
/
/
Substep
1
/
/
Substep
2
/
/
Sub
-
substep
1
/
/
Sub
-
substep
2
/
/
Sub
-
substep
3
/
/
Sub
-
substep
4
/
/
Substep
3
/
/
Step
15
response
}
/
/
/
[
CORS
preflight
fetch
]
(
https
:
/
/
fetch
.
spec
.
whatwg
.
org
#
cors
-
preflight
-
fetch
)
fn
cors_preflight_fetch
(
request
:
Rc
<
Request
>
cache
:
&
mut
CORSCache
context
:
&
FetchContext
)
-
>
Response
{
/
/
Step
1
let
mut
preflight
=
Request
:
:
new
(
request
.
current_url
(
)
Some
(
request
.
origin
.
borrow
(
)
.
clone
(
)
)
request
.
is_service_worker_global_scope
request
.
pipeline_id
.
get
(
)
)
;
*
preflight
.
method
.
borrow_mut
(
)
=
Method
:
:
Options
;
preflight
.
initiator
=
request
.
initiator
.
clone
(
)
;
preflight
.
type_
=
request
.
type_
.
clone
(
)
;
preflight
.
destination
=
request
.
destination
.
clone
(
)
;
*
preflight
.
referer
.
borrow_mut
(
)
=
request
.
referer
.
borrow
(
)
.
clone
(
)
;
preflight
.
referrer_policy
.
set
(
request
.
referrer_policy
.
get
(
)
)
;
/
/
Step
2
preflight
.
headers
.
borrow_mut
(
)
.
set
:
:
<
AccessControlRequestMethod
>
(
AccessControlRequestMethod
(
request
.
method
.
borrow
(
)
.
clone
(
)
)
)
;
/
/
Step
3
4
let
mut
value
=
request
.
headers
.
borrow
(
)
.
iter
(
)
.
filter_map
(
|
ref
view
|
if
is_simple_header
(
view
)
{
None
}
else
{
Some
(
UniCase
(
view
.
name
(
)
.
to_owned
(
)
)
)
}
)
.
collect
:
:
<
Vec
<
UniCase
<
String
>
>
>
(
)
;
value
.
sort
(
)
;
/
/
Step
5
preflight
.
headers
.
borrow_mut
(
)
.
set
:
:
<
AccessControlRequestHeaders
>
(
AccessControlRequestHeaders
(
value
)
)
;
/
/
Step
6
let
preflight
=
Rc
:
:
new
(
preflight
)
;
let
response
=
http_network_or_cache_fetch
(
preflight
.
clone
(
)
false
false
&
mut
None
context
)
;
/
/
Step
7
if
cors_check
(
request
.
clone
(
)
&
response
)
.
is_ok
(
)
&
&
response
.
status
.
map_or
(
false
|
status
|
status
.
is_success
(
)
)
{
/
/
Substep
1
let
mut
methods
=
if
response
.
headers
.
has
:
:
<
AccessControlAllowMethods
>
(
)
{
match
response
.
headers
.
get
:
:
<
AccessControlAllowMethods
>
(
)
{
Some
(
&
AccessControlAllowMethods
(
ref
m
)
)
=
>
m
.
clone
(
)
/
/
Substep
3
None
=
>
return
Response
:
:
network_error
(
)
}
}
else
{
vec
!
[
]
}
;
/
/
Substep
2
let
header_names
=
if
response
.
headers
.
has
:
:
<
AccessControlAllowHeaders
>
(
)
{
match
response
.
headers
.
get
:
:
<
AccessControlAllowHeaders
>
(
)
{
Some
(
&
AccessControlAllowHeaders
(
ref
hn
)
)
=
>
hn
.
clone
(
)
/
/
Substep
3
None
=
>
return
Response
:
:
network_error
(
)
}
}
else
{
vec
!
[
]
}
;
/
/
Substep
4
if
methods
.
is_empty
(
)
&
&
request
.
use_cors_preflight
{
methods
=
vec
!
[
request
.
method
.
borrow
(
)
.
clone
(
)
]
;
}
/
/
Substep
5
debug
!
(
"
CORS
check
:
Allowed
methods
:
{
:
?
}
current
method
:
{
:
?
}
"
methods
request
.
method
.
borrow
(
)
)
;
if
methods
.
iter
(
)
.
all
(
|
method
|
*
method
!
=
*
request
.
method
.
borrow
(
)
)
&
&
!
is_simple_method
(
&
*
request
.
method
.
borrow
(
)
)
{
return
Response
:
:
network_error
(
)
;
}
/
/
Substep
6
debug
!
(
"
CORS
check
:
Allowed
headers
:
{
:
?
}
current
headers
:
{
:
?
}
"
header_names
request
.
headers
.
borrow
(
)
)
;
let
set
:
HashSet
<
&
UniCase
<
String
>
>
=
HashSet
:
:
from_iter
(
header_names
.
iter
(
)
)
;
if
request
.
headers
.
borrow
(
)
.
iter
(
)
.
any
(
|
ref
hv
|
!
set
.
contains
(
&
UniCase
(
hv
.
name
(
)
.
to_owned
(
)
)
)
&
&
!
is_simple_header
(
hv
)
)
{
return
Response
:
:
network_error
(
)
;
}
let
max_age
=
response
.
headers
.
get
:
:
<
AccessControlMaxAge
>
(
)
.
map
(
|
acma
|
acma
.
0
)
.
unwrap_or
(
0
)
;
for
method
in
&
methods
{
cache
.
match_method_and_update
(
&
*
request
method
.
clone
(
)
max_age
)
;
}
for
header_name
in
&
header_names
{
cache
.
match_header_and_update
(
&
*
request
&
*
header_name
max_age
)
;
}
return
response
;
}
Response
:
:
network_error
(
)
}
fn
cors_check
(
request
:
Rc
<
Request
>
response
:
&
Response
)
-
>
Result
<
(
)
(
)
>
{
let
origin
=
response
.
headers
.
get
:
:
<
AccessControlAllowOrigin
>
(
)
.
cloned
(
)
;
let
origin
=
try
!
(
origin
.
ok_or
(
(
)
)
)
;
if
request
.
credentials_mode
!
=
CredentialsMode
:
:
Include
&
&
origin
=
=
AccessControlAllowOrigin
:
:
Any
{
return
Ok
(
(
)
)
;
}
let
origin
=
match
origin
{
AccessControlAllowOrigin
:
:
Value
(
origin
)
=
>
origin
_
=
>
return
Err
(
(
)
)
}
;
match
*
request
.
origin
.
borrow
(
)
{
Origin
:
:
Origin
(
ref
o
)
if
o
.
ascii_serialization
(
)
=
=
origin
=
>
{
}
_
=
>
return
Err
(
(
)
)
}
if
request
.
credentials_mode
!
=
CredentialsMode
:
:
Include
{
return
Ok
(
(
)
)
;
}
let
credentials
=
request
.
headers
.
borrow
(
)
.
get
:
:
<
AccessControlAllowCredentials
>
(
)
.
cloned
(
)
;
if
credentials
.
is_some
(
)
{
return
Ok
(
(
)
)
;
}
Err
(
(
)
)
}
fn
has_credentials
(
url
:
&
Url
)
-
>
bool
{
!
url
.
username
(
)
.
is_empty
(
)
|
|
url
.
password
(
)
.
is_some
(
)
}
fn
is_no_store_cache
(
headers
:
&
Headers
)
-
>
bool
{
headers
.
has
:
:
<
IfModifiedSince
>
(
)
|
headers
.
has
:
:
<
IfNoneMatch
>
(
)
|
headers
.
has
:
:
<
IfUnmodifiedSince
>
(
)
|
headers
.
has
:
:
<
IfMatch
>
(
)
|
headers
.
has
:
:
<
IfRange
>
(
)
}
fn
is_simple_header
(
h
:
&
HeaderView
)
-
>
bool
{
if
h
.
is
:
:
<
ContentType
>
(
)
{
match
h
.
value
(
)
{
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Plain
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
WwwFormUrlEncoded
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Multipart
SubLevel
:
:
FormData
_
)
)
)
=
>
true
_
=
>
false
}
}
else
{
h
.
is
:
:
<
Accept
>
(
)
|
|
h
.
is
:
:
<
AcceptLanguage
>
(
)
|
|
h
.
is
:
:
<
ContentLanguage
>
(
)
}
}
fn
is_simple_method
(
m
:
&
Method
)
-
>
bool
{
match
*
m
{
Method
:
:
Get
|
Method
:
:
Head
|
Method
:
:
Post
=
>
true
_
=
>
false
}
}
fn
response_needs_revalidation
(
_response
:
&
Response
)
-
>
bool
{
false
}
fn
is_null_body_status
(
status
:
&
Option
<
StatusCode
>
)
-
>
bool
{
match
*
status
{
Some
(
status
)
=
>
match
status
{
StatusCode
:
:
SwitchingProtocols
|
StatusCode
:
:
NoContent
|
StatusCode
:
:
ResetContent
|
StatusCode
:
:
NotModified
=
>
true
_
=
>
false
}
_
=
>
false
}
}
