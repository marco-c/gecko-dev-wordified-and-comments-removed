use
fetch
:
:
cors_cache
:
:
{
BasicCORSCache
CORSCache
CacheRequestDetails
}
;
use
fetch
:
:
response
:
:
ResponseMethods
;
use
http_loader
:
:
{
NetworkHttpRequestFactory
WrappedHttpResponse
}
;
use
http_loader
:
:
{
create_http_connector
obtain_response
}
;
use
hyper
:
:
client
:
:
response
:
:
Response
as
HyperResponse
;
use
hyper
:
:
header
:
:
{
Accept
IfMatch
IfRange
IfUnmodifiedSince
Location
}
;
use
hyper
:
:
header
:
:
{
AcceptLanguage
ContentLength
ContentLanguage
HeaderView
}
;
use
hyper
:
:
header
:
:
{
AccessControlAllowCredentials
AccessControlAllowOrigin
}
;
use
hyper
:
:
header
:
:
{
Authorization
Basic
ContentEncoding
Encoding
}
;
use
hyper
:
:
header
:
:
{
ContentType
Header
Headers
IfModifiedSince
IfNoneMatch
}
;
use
hyper
:
:
header
:
:
{
QualityItem
q
qitem
Referer
as
RefererHeader
UserAgent
}
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
mime
:
:
{
Attr
Mime
SubLevel
TopLevel
Value
}
;
use
hyper
:
:
status
:
:
StatusCode
;
use
net_traits
:
:
request
:
:
{
CacheMode
Context
ContextFrameType
CredentialsMode
}
;
use
net_traits
:
:
request
:
:
{
RedirectMode
Referer
Request
RequestMode
ResponseTainting
}
;
use
net_traits
:
:
response
:
:
{
CacheState
HttpsState
TerminationReason
}
;
use
net_traits
:
:
response
:
:
{
Response
ResponseBody
ResponseType
}
;
use
net_traits
:
:
{
AsyncFetchListener
Metadata
}
;
use
resource_thread
:
:
CancellationListener
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
str
:
:
FromStr
;
use
std
:
:
thread
;
use
url
:
:
idna
:
:
domain_to_ascii
;
use
url
:
:
{
Origin
Url
UrlParser
whatwg_scheme_type_mapper
}
;
use
util
:
:
thread
:
:
spawn_named
;
pub
fn
fetch_async
(
request
:
Request
cors_flag
:
bool
listener
:
Box
<
AsyncFetchListener
+
Send
>
)
{
spawn_named
(
format
!
(
"
fetch
for
{
:
?
}
"
request
.
get_last_url_string
(
)
)
move
|
|
{
let
request
=
Rc
:
:
new
(
request
)
;
let
res
=
fetch
(
request
cors_flag
)
;
listener
.
response_available
(
res
)
;
}
)
}
pub
fn
fetch
(
request
:
Rc
<
Request
>
cors_flag
:
bool
)
-
>
Response
{
if
request
.
context
!
=
Context
:
:
Fetch
&
&
!
request
.
headers
.
borrow
(
)
.
has
:
:
<
Accept
>
(
)
{
let
value
=
match
request
.
context
{
Context
:
:
Favicon
|
Context
:
:
Image
|
Context
:
:
ImageSet
=
>
vec
!
[
qitem
(
Mime
(
TopLevel
:
:
Image
SubLevel
:
:
Png
vec
!
[
]
)
)
/
/
FIXME
:
This
should
properly
generate
a
MimeType
that
has
a
/
/
SubLevel
of
svg
+
xml
(
https
:
/
/
github
.
com
/
hyperium
/
mime
.
rs
/
issues
/
22
)
qitem
(
Mime
(
TopLevel
:
:
Image
SubLevel
:
:
Ext
(
"
svg
+
xml
"
.
to_owned
(
)
)
vec
!
[
]
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Image
SubLevel
:
:
Star
vec
!
[
]
)
q
(
0
.
8
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Star
SubLevel
:
:
Star
vec
!
[
]
)
q
(
0
.
5
)
)
]
Context
:
:
Form
|
Context
:
:
Frame
|
Context
:
:
Hyperlink
|
Context
:
:
IFrame
|
Context
:
:
Location
|
Context
:
:
MetaRefresh
|
Context
:
:
PreRender
=
>
vec
!
[
qitem
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Html
vec
!
[
]
)
)
/
/
FIXME
:
This
should
properly
generate
a
MimeType
that
has
a
/
/
SubLevel
of
xhtml
+
xml
(
https
:
/
/
github
.
com
/
hyperium
/
mime
.
rs
/
issues
/
22
)
qitem
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
Ext
(
"
xhtml
+
xml
"
.
to_owned
(
)
)
vec
!
[
]
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
Xml
vec
!
[
]
)
q
(
0
.
9
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Star
SubLevel
:
:
Star
vec
!
[
]
)
q
(
0
.
8
)
)
]
Context
:
:
Internal
if
request
.
context_frame_type
!
=
ContextFrameType
:
:
ContextNone
=
>
vec
!
[
qitem
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Html
vec
!
[
]
)
)
/
/
FIXME
:
This
should
properly
generate
a
MimeType
that
has
a
/
/
SubLevel
of
xhtml
+
xml
(
https
:
/
/
github
.
com
/
hyperium
/
mime
.
rs
/
issues
/
22
)
qitem
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
Ext
(
"
xhtml
+
xml
"
.
to_owned
(
)
)
vec
!
[
]
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
Xml
vec
!
[
]
)
q
(
0
.
9
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Star
SubLevel
:
:
Star
vec
!
[
]
)
q
(
0
.
8
)
)
]
Context
:
:
Style
=
>
vec
!
[
qitem
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Css
vec
!
[
]
)
)
QualityItem
:
:
new
(
Mime
(
TopLevel
:
:
Star
SubLevel
:
:
Star
vec
!
[
]
)
q
(
0
.
1
)
)
]
_
=
>
vec
!
[
qitem
(
Mime
(
TopLevel
:
:
Star
SubLevel
:
:
Star
vec
!
[
]
)
)
]
}
;
request
.
headers
.
borrow_mut
(
)
.
set
(
Accept
(
value
)
)
;
}
if
request
.
context
!
=
Context
:
:
Fetch
&
&
!
request
.
headers
.
borrow
(
)
.
has
:
:
<
AcceptLanguage
>
(
)
{
request
.
headers
.
borrow_mut
(
)
.
set
(
AcceptLanguage
(
vec
!
[
qitem
(
"
en
-
US
"
.
parse
(
)
.
unwrap
(
)
)
]
)
)
;
}
main_fetch
(
request
cors_flag
false
)
}
fn
main_fetch
(
request
:
Rc
<
Request
>
cors_flag
:
bool
recursive_flag
:
bool
)
-
>
Response
{
let
mut
response
=
None
;
if
request
.
local_urls_only
{
match
&
*
request
.
current_url
(
)
.
scheme
{
"
about
"
|
"
blob
"
|
"
data
"
|
"
filesystem
"
=
>
response
=
Some
(
Response
:
:
network_error
(
)
)
_
=
>
{
}
}
;
}
if
request
.
referer
!
=
Referer
:
:
NoReferer
{
}
if
!
request
.
synchronous
&
&
!
recursive_flag
{
}
let
mut
response
=
if
response
.
is_none
(
)
{
let
current_url
=
request
.
current_url
(
)
;
let
origin_match
=
request
.
origin
=
=
current_url
.
origin
(
)
;
if
(
!
cors_flag
&
&
origin_match
)
|
|
(
current_url
.
scheme
=
=
"
data
"
&
&
request
.
same_origin_data
.
get
(
)
)
|
|
current_url
.
scheme
=
=
"
about
"
|
|
request
.
mode
=
=
RequestMode
:
:
Navigate
{
basic_fetch
(
request
.
clone
(
)
)
}
else
if
request
.
mode
=
=
RequestMode
:
:
SameOrigin
{
Response
:
:
network_error
(
)
}
else
if
request
.
mode
=
=
RequestMode
:
:
NoCORS
{
request
.
response_tainting
.
set
(
ResponseTainting
:
:
Opaque
)
;
basic_fetch
(
request
.
clone
(
)
)
}
else
if
current_url
.
scheme
!
=
"
http
"
&
&
current_url
.
scheme
!
=
"
https
"
{
Response
:
:
network_error
(
)
}
else
if
request
.
use_cors_preflight
|
|
(
request
.
unsafe_request
&
&
(
!
is_simple_method
(
&
request
.
method
.
borrow
(
)
)
|
|
request
.
headers
.
borrow
(
)
.
iter
(
)
.
any
(
|
h
|
!
is_simple_header
(
&
h
)
)
)
)
{
request
.
response_tainting
.
set
(
ResponseTainting
:
:
CORSTainting
)
;
request
.
redirect_mode
.
set
(
RedirectMode
:
:
Error
)
;
let
response
=
http_fetch
(
request
.
clone
(
)
BasicCORSCache
:
:
new
(
)
true
true
false
)
;
if
Response
:
:
is_network_error
(
&
response
)
{
}
response
}
else
{
request
.
response_tainting
.
set
(
ResponseTainting
:
:
CORSTainting
)
;
http_fetch
(
request
.
clone
(
)
BasicCORSCache
:
:
new
(
)
true
false
false
)
}
}
else
{
response
.
unwrap
(
)
}
;
if
recursive_flag
{
return
response
;
}
let
mut
response
=
if
response
.
response_type
=
=
ResponseType
:
:
Default
{
let
old_response
=
Rc
:
:
new
(
response
)
;
let
response_type
=
match
request
.
response_tainting
.
get
(
)
{
ResponseTainting
:
:
Basic
=
>
ResponseType
:
:
Basic
ResponseTainting
:
:
CORSTainting
=
>
ResponseType
:
:
CORS
ResponseTainting
:
:
Opaque
=
>
ResponseType
:
:
Opaque
}
;
Response
:
:
to_filtered
(
old_response
response_type
)
}
else
{
response
}
;
let
mut
internal_response
=
if
Response
:
:
is_network_error
(
&
response
)
{
Rc
:
:
new
(
Response
:
:
network_error
(
)
)
}
else
{
response
.
internal_response
.
clone
(
)
.
unwrap
(
)
}
;
if
!
Response
:
:
is_network_error
(
&
response
)
&
&
(
is_null_body_status
(
&
internal_response
.
status
)
|
|
match
*
request
.
method
.
borrow
(
)
{
Method
:
:
Head
|
Method
:
:
Connect
=
>
true
_
=
>
false
}
)
{
*
internal_response
.
body
.
borrow_mut
(
)
=
ResponseBody
:
:
Empty
;
}
if
request
.
synchronous
{
return
response
;
}
if
request
.
body
.
is_some
(
)
&
&
match
&
*
request
.
current_url
(
)
.
scheme
{
"
http
"
|
"
https
"
=
>
true
_
=
>
false
}
{
}
match
*
internal_response
.
body
.
borrow
(
)
{
ResponseBody
:
:
Empty
=
>
{
}
_
=
>
{
}
}
;
return
response
;
}
fn
basic_fetch
(
request
:
Rc
<
Request
>
)
-
>
Response
{
let
url
=
request
.
current_url
(
)
;
let
scheme
=
url
.
scheme
.
clone
(
)
;
match
&
*
scheme
{
"
about
"
=
>
{
match
url
.
non_relative_scheme_data
(
)
{
Some
(
s
)
if
&
*
s
=
=
"
blank
"
=
>
{
let
mut
response
=
Response
:
:
new
(
)
;
response
.
headers
.
set
(
ContentType
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Html
vec
!
[
(
Attr
:
:
Charset
Value
:
:
Utf8
)
]
)
)
)
;
response
}
_
=
>
Response
:
:
network_error
(
)
}
}
"
http
"
|
"
https
"
=
>
{
http_fetch
(
request
.
clone
(
)
BasicCORSCache
:
:
new
(
)
false
false
false
)
}
"
blob
"
|
"
data
"
|
"
file
"
|
"
ftp
"
=
>
{
panic
!
(
"
Unimplemented
scheme
for
Fetch
"
)
}
_
=
>
Response
:
:
network_error
(
)
}
}
fn
http_fetch_async
(
request
:
Request
cors_flag
:
bool
cors_preflight_flag
:
bool
authentication_fetch_flag
:
bool
listener
:
Box
<
AsyncFetchListener
+
Send
>
)
{
spawn_named
(
format
!
(
"
http_fetch
for
{
:
?
}
"
request
.
get_last_url_string
(
)
)
move
|
|
{
let
request
=
Rc
:
:
new
(
request
)
;
let
res
=
http_fetch
(
request
BasicCORSCache
:
:
new
(
)
cors_flag
cors_preflight_flag
authentication_fetch_flag
)
;
listener
.
response_available
(
res
)
;
}
)
;
}
fn
http_fetch
(
request
:
Rc
<
Request
>
mut
cache
:
BasicCORSCache
cors_flag
:
bool
cors_preflight_flag
:
bool
authentication_fetch_flag
:
bool
)
-
>
Response
{
let
mut
response
:
Option
<
Rc
<
Response
>
>
=
None
;
let
mut
actual_response
:
Option
<
Rc
<
Response
>
>
=
None
;
if
!
request
.
skip_service_worker
.
get
(
)
&
&
!
request
.
is_service_worker_global_scope
{
if
let
Some
(
ref
res
)
=
response
{
actual_response
=
match
res
.
internal_response
{
Some
(
ref
internal_res
)
=
>
Some
(
internal_res
.
clone
(
)
)
None
=
>
Some
(
res
.
clone
(
)
)
}
;
if
(
res
.
response_type
=
=
ResponseType
:
:
Opaque
&
&
request
.
mode
!
=
RequestMode
:
:
NoCORS
)
|
|
(
res
.
response_type
=
=
ResponseType
:
:
OpaqueRedirect
&
&
request
.
redirect_mode
.
get
(
)
!
=
RedirectMode
:
:
Manual
)
|
|
res
.
response_type
=
=
ResponseType
:
:
Error
{
return
Response
:
:
network_error
(
)
;
}
}
if
let
Some
(
ref
res
)
=
actual_response
{
if
res
.
url_list
.
borrow
(
)
.
is_empty
(
)
{
*
res
.
url_list
.
borrow_mut
(
)
=
request
.
url_list
.
borrow
(
)
.
clone
(
)
;
}
}
}
if
response
.
is_none
(
)
{
if
cors_preflight_flag
{
let
mut
method_mismatch
=
false
;
let
mut
header_mismatch
=
false
;
let
origin
=
request
.
origin
.
clone
(
)
;
let
url
=
request
.
current_url
(
)
;
let
credentials
=
request
.
credentials_mode
=
=
CredentialsMode
:
:
Include
;
let
method_cache_match
=
cache
.
match_method
(
CacheRequestDetails
{
origin
:
origin
.
clone
(
)
destination
:
url
.
clone
(
)
credentials
:
credentials
}
request
.
method
.
borrow
(
)
.
clone
(
)
)
;
method_mismatch
=
!
method_cache_match
&
&
(
!
is_simple_method
(
&
request
.
method
.
borrow
(
)
)
|
|
request
.
use_cors_preflight
)
;
header_mismatch
=
request
.
headers
.
borrow
(
)
.
iter
(
)
.
any
(
|
view
|
!
cache
.
match_header
(
CacheRequestDetails
{
origin
:
origin
.
clone
(
)
destination
:
url
.
clone
(
)
credentials
:
credentials
}
view
.
name
(
)
)
&
&
!
is_simple_header
(
&
view
)
)
;
if
method_mismatch
|
|
header_mismatch
{
let
preflight_result
=
preflight_fetch
(
request
.
clone
(
)
)
;
if
preflight_result
.
response_type
=
=
ResponseType
:
:
Error
{
return
Response
:
:
network_error
(
)
;
}
}
}
request
.
skip_service_worker
.
set
(
true
)
;
let
credentials
=
match
request
.
credentials_mode
{
CredentialsMode
:
:
Include
=
>
true
CredentialsMode
:
:
CredentialsSameOrigin
if
(
!
cors_flag
|
|
request
.
response_tainting
.
get
(
)
=
=
ResponseTainting
:
:
Opaque
)
=
>
true
_
=
>
false
}
;
let
fetch_result
=
http_network_or_cache_fetch
(
request
.
clone
(
)
credentials
authentication_fetch_flag
)
;
if
cors_flag
&
&
cors_check
(
request
.
clone
(
)
&
fetch_result
)
.
is_err
(
)
{
return
Response
:
:
network_error
(
)
;
}
response
=
Some
(
Rc
:
:
new
(
fetch_result
)
)
;
actual_response
=
response
.
clone
(
)
;
}
let
mut
response
=
response
.
unwrap
(
)
;
let
actual_response
=
actual_response
.
unwrap
(
)
;
match
actual_response
.
status
.
unwrap
(
)
{
StatusCode
:
:
MovedPermanently
|
StatusCode
:
:
Found
|
StatusCode
:
:
SeeOther
|
StatusCode
:
:
TemporaryRedirect
|
StatusCode
:
:
PermanentRedirect
=
>
{
if
request
.
redirect_mode
.
get
(
)
=
=
RedirectMode
:
:
Error
{
return
Response
:
:
network_error
(
)
;
}
if
!
actual_response
.
headers
.
has
:
:
<
Location
>
(
)
{
drop
(
actual_response
)
;
return
Rc
:
:
try_unwrap
(
response
)
.
ok
(
)
.
unwrap
(
)
;
}
let
location
=
match
actual_response
.
headers
.
get
:
:
<
Location
>
(
)
{
Some
(
&
Location
(
ref
location
)
)
=
>
location
.
clone
(
)
_
=
>
return
Response
:
:
network_error
(
)
}
;
let
location_url
=
UrlParser
:
:
new
(
)
.
base_url
(
&
request
.
current_url
(
)
)
.
parse
(
&
*
location
)
;
let
location_url
=
match
location_url
{
Ok
(
url
)
=
>
url
_
=
>
{
return
Response
:
:
network_error
(
)
;
}
}
;
if
request
.
redirect_count
.
get
(
)
>
=
20
{
return
Response
:
:
network_error
(
)
;
}
request
.
redirect_count
.
set
(
request
.
redirect_count
.
get
(
)
+
1
)
;
request
.
same_origin_data
.
set
(
false
)
;
match
request
.
redirect_mode
.
get
(
)
{
RedirectMode
:
:
Manual
=
>
{
response
=
Rc
:
:
new
(
Response
:
:
to_filtered
(
actual_response
ResponseType
:
:
OpaqueRedirect
)
)
;
}
RedirectMode
:
:
Follow
=
>
{
if
cors_flag
&
&
has_credentials
(
&
location_url
)
{
return
Response
:
:
network_error
(
)
;
}
if
actual_response
.
status
.
unwrap
(
)
=
=
StatusCode
:
:
SeeOther
|
|
(
(
actual_response
.
status
.
unwrap
(
)
=
=
StatusCode
:
:
MovedPermanently
|
|
actual_response
.
status
.
unwrap
(
)
=
=
StatusCode
:
:
Found
)
&
&
*
request
.
method
.
borrow
(
)
=
=
Method
:
:
Post
)
{
*
request
.
method
.
borrow_mut
(
)
=
Method
:
:
Get
;
}
request
.
url_list
.
borrow_mut
(
)
.
push
(
location_url
)
;
return
main_fetch
(
request
.
clone
(
)
cors_flag
true
)
;
}
RedirectMode
:
:
Error
=
>
{
panic
!
(
"
RedirectMode
is
Error
after
step
8
"
)
}
}
}
StatusCode
:
:
Unauthorized
=
>
{
if
cors_flag
{
drop
(
actual_response
)
;
return
Rc
:
:
try_unwrap
(
response
)
.
ok
(
)
.
unwrap
(
)
;
}
if
!
request
.
use_url_credentials
|
|
authentication_fetch_flag
{
}
return
http_fetch
(
request
BasicCORSCache
:
:
new
(
)
cors_flag
cors_preflight_flag
true
)
;
}
StatusCode
:
:
ProxyAuthenticationRequired
=
>
{
return
http_fetch
(
request
BasicCORSCache
:
:
new
(
)
cors_flag
cors_preflight_flag
authentication_fetch_flag
)
;
}
_
=
>
drop
(
actual_response
)
}
if
authentication_fetch_flag
{
}
Rc
:
:
try_unwrap
(
response
)
.
ok
(
)
.
unwrap
(
)
}
fn
http_network_or_cache_fetch
(
request
:
Rc
<
Request
>
credentials_flag
:
bool
authentication_fetch_flag
:
bool
)
-
>
Response
{
let
request_has_no_window
=
true
;
let
http_request
=
if
request_has_no_window
&
&
request
.
redirect_mode
.
get
(
)
!
=
RedirectMode
:
:
Follow
{
request
.
clone
(
)
}
else
{
Rc
:
:
new
(
(
*
request
)
.
clone
(
)
)
}
;
let
content_length_value
=
match
http_request
.
body
{
None
=
>
match
*
http_request
.
method
.
borrow
(
)
{
Method
:
:
Head
|
Method
:
:
Post
|
Method
:
:
Put
=
>
Some
(
0
)
_
=
>
None
}
Some
(
ref
http_request_body
)
=
>
Some
(
http_request_body
.
len
(
)
as
u64
)
}
;
if
let
Some
(
content_length_value
)
=
content_length_value
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
ContentLength
(
content_length_value
)
)
;
}
match
http_request
.
referer
{
Referer
:
:
NoReferer
=
>
http_request
.
headers
.
borrow_mut
(
)
.
set
(
RefererHeader
(
"
"
.
to_owned
(
)
)
)
Referer
:
:
RefererUrl
(
ref
http_request_referer
)
=
>
http_request
.
headers
.
borrow_mut
(
)
.
set
(
RefererHeader
(
http_request_referer
.
serialize
(
)
)
)
Referer
:
:
Client
=
>
unreachable
!
(
)
}
;
if
http_request
.
omit_origin_header
=
=
false
{
}
if
!
http_request
.
headers
.
borrow
(
)
.
has
:
:
<
UserAgent
>
(
)
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
UserAgent
(
global_user_agent
(
)
.
to_owned
(
)
)
)
;
}
if
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
&
&
is_no_store_cache
(
&
http_request
.
headers
.
borrow
(
)
)
{
http_request
.
cache_mode
.
set
(
CacheMode
:
:
NoStore
)
;
}
if
credentials_flag
{
let
mut
authorization_value
=
None
;
if
authentication_fetch_flag
{
let
current_url
=
http_request
.
current_url
(
)
;
authorization_value
=
if
includes_credentials
(
&
current_url
)
{
Some
(
Basic
{
username
:
current_url
.
username
(
)
.
unwrap_or
(
"
"
)
.
to_owned
(
)
password
:
current_url
.
password
(
)
.
map
(
str
:
:
to_owned
)
}
)
}
else
{
None
}
}
if
let
Some
(
basic
)
=
authorization_value
{
http_request
.
headers
.
borrow_mut
(
)
.
set
(
Authorization
(
basic
)
)
;
}
}
let
mut
response
:
Option
<
Response
>
=
None
;
let
complete_http_response_from_cache
:
Option
<
Response
>
=
None
;
if
http_request
.
cache_mode
.
get
(
)
!
=
CacheMode
:
:
NoStore
&
&
http_request
.
cache_mode
.
get
(
)
!
=
CacheMode
:
:
Reload
&
&
complete_http_response_from_cache
.
is_some
(
)
{
if
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
ForceCache
{
}
let
revalidation_needed
=
match
response
{
Some
(
ref
response
)
=
>
response_needs_revalidation
(
&
response
)
_
=
>
false
}
;
if
!
revalidation_needed
&
&
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
{
}
if
revalidation_needed
&
&
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
NoCache
{
}
}
else
if
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
ForceCache
{
}
if
response
.
is_none
(
)
{
response
=
Some
(
http_network_fetch
(
request
.
clone
(
)
http_request
.
clone
(
)
credentials_flag
)
)
;
}
let
response
=
response
.
unwrap
(
)
;
if
let
Some
(
status
)
=
response
.
status
{
if
status
=
=
StatusCode
:
:
NotModified
&
&
(
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
Default
|
|
http_request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
NoCache
)
{
}
}
response
}
fn
http_network_fetch
(
request
:
Rc
<
Request
>
http_request
:
Rc
<
Request
>
credentials_flag
:
bool
)
-
>
Response
{
let
connection
=
create_http_connector
(
)
;
let
factory
=
NetworkHttpRequestFactory
{
connector
:
connection
}
;
let
url
=
request
.
current_url
(
)
;
let
cancellation_listener
=
CancellationListener
:
:
new
(
None
)
;
let
wrapped_response
=
obtain_response
(
&
factory
&
url
&
request
.
method
.
borrow
(
)
&
request
.
headers
.
borrow
(
)
&
cancellation_listener
&
None
&
request
.
method
.
borrow
(
)
&
None
request
.
redirect_count
.
get
(
)
&
None
"
"
)
;
let
mut
response
=
Response
:
:
new
(
)
;
match
wrapped_response
{
Ok
(
mut
res
)
=
>
{
response
.
url
=
Some
(
res
.
response
.
url
.
clone
(
)
)
;
response
.
status
=
Some
(
res
.
response
.
status
)
;
response
.
headers
=
res
.
response
.
headers
.
clone
(
)
;
let
mut
body
=
vec
!
[
]
;
res
.
response
.
read_to_end
(
&
mut
body
)
;
*
response
.
body
.
borrow_mut
(
)
=
ResponseBody
:
:
Done
(
body
)
;
}
Err
(
e
)
=
>
response
.
termination_reason
=
Some
(
TerminationReason
:
:
Fatal
)
}
;
response
.
https_state
=
HttpsState
:
:
None
;
if
let
Some
(
encoding
)
=
response
.
headers
.
get
:
:
<
ContentEncoding
>
(
)
{
if
encoding
.
contains
(
&
Encoding
:
:
Gzip
)
{
}
else
if
encoding
.
contains
(
&
Encoding
:
:
Compress
)
{
}
}
;
*
response
.
url_list
.
borrow_mut
(
)
=
request
.
url_list
.
borrow
(
)
.
clone
(
)
;
if
Response
:
:
is_network_error
(
&
response
)
&
&
request
.
cache_mode
.
get
(
)
=
=
CacheMode
:
:
NoStore
{
}
response
}
fn
preflight_fetch
(
request
:
Rc
<
Request
>
)
-
>
Response
{
Response
:
:
network_error
(
)
}
fn
cors_check
(
request
:
Rc
<
Request
>
response
:
&
Response
)
-
>
Result
<
(
)
(
)
>
{
let
origin
=
response
.
headers
.
get
:
:
<
AccessControlAllowOrigin
>
(
)
.
cloned
(
)
;
let
origin
=
try
!
(
origin
.
ok_or
(
(
)
)
)
;
if
request
.
credentials_mode
!
=
CredentialsMode
:
:
Include
&
&
origin
=
=
AccessControlAllowOrigin
:
:
Any
{
return
Ok
(
(
)
)
;
}
let
origin
=
match
origin
{
AccessControlAllowOrigin
:
:
Value
(
origin
)
=
>
origin
_
=
>
return
Err
(
(
)
)
}
;
match
ascii_serialise_origin
(
&
request
.
origin
)
{
Ok
(
request_origin
)
=
>
{
if
request_origin
!
=
origin
{
return
Err
(
(
)
)
;
}
}
_
=
>
return
Err
(
(
)
)
}
if
request
.
credentials_mode
!
=
CredentialsMode
:
:
Include
{
return
Ok
(
(
)
)
;
}
let
credentials
=
request
.
headers
.
borrow
(
)
.
get
:
:
<
AccessControlAllowCredentials
>
(
)
.
cloned
(
)
;
if
credentials
.
is_some
(
)
{
return
Ok
(
(
)
)
;
}
Err
(
(
)
)
}
fn
ascii_serialise_origin
(
origin
:
&
Origin
)
-
>
Result
<
String
(
)
>
{
let
result
=
match
*
origin
{
Origin
:
:
UID
(
_
)
=
>
"
null
"
.
to_owned
(
)
Origin
:
:
Tuple
(
ref
scheme
ref
host
ref
port
)
=
>
{
let
host
=
try
!
(
domain_to_ascii
(
host
.
serialize
(
)
.
as_str
(
)
)
.
or
(
Err
(
(
)
)
)
)
;
let
default_port
=
whatwg_scheme_type_mapper
(
scheme
)
.
default_port
(
)
;
if
Some
(
*
port
)
=
=
default_port
{
format
!
(
"
{
}
:
/
/
{
}
"
scheme
host
)
}
else
{
format
!
(
"
{
}
:
/
/
{
}
{
}
"
scheme
host
port
)
}
}
}
;
Ok
(
result
)
}
fn
global_user_agent
(
)
-
>
String
{
const
USER_AGENT_STRING
:
&
'
static
str
=
"
Servo
"
;
USER_AGENT_STRING
.
to_owned
(
)
}
fn
has_credentials
(
url
:
&
Url
)
-
>
bool
{
!
url
.
username
(
)
.
unwrap_or
(
"
"
)
.
is_empty
(
)
|
|
url
.
password
(
)
.
is_some
(
)
}
fn
is_no_store_cache
(
headers
:
&
Headers
)
-
>
bool
{
headers
.
has
:
:
<
IfModifiedSince
>
(
)
|
headers
.
has
:
:
<
IfNoneMatch
>
(
)
|
headers
.
has
:
:
<
IfUnmodifiedSince
>
(
)
|
headers
.
has
:
:
<
IfMatch
>
(
)
|
headers
.
has
:
:
<
IfRange
>
(
)
}
fn
is_simple_header
(
h
:
&
HeaderView
)
-
>
bool
{
if
h
.
is
:
:
<
ContentType
>
(
)
{
match
h
.
value
(
)
{
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Plain
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
WwwFormUrlEncoded
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Multipart
SubLevel
:
:
FormData
_
)
)
)
=
>
true
_
=
>
false
}
}
else
{
h
.
is
:
:
<
Accept
>
(
)
|
|
h
.
is
:
:
<
AcceptLanguage
>
(
)
|
|
h
.
is
:
:
<
ContentLanguage
>
(
)
}
}
fn
is_simple_method
(
m
:
&
Method
)
-
>
bool
{
match
*
m
{
Method
:
:
Get
|
Method
:
:
Head
|
Method
:
:
Post
=
>
true
_
=
>
false
}
}
fn
includes_credentials
(
url
:
&
Url
)
-
>
bool
{
if
url
.
password
(
)
.
is_some
(
)
{
return
true
}
if
let
Some
(
name
)
=
url
.
username
(
)
{
return
name
.
len
(
)
>
0
}
false
}
fn
response_needs_revalidation
(
response
:
&
Response
)
-
>
bool
{
false
}
fn
is_null_body_status
(
status
:
&
Option
<
StatusCode
>
)
-
>
bool
{
match
*
status
{
Some
(
status
)
=
>
match
status
{
StatusCode
:
:
SwitchingProtocols
|
StatusCode
:
:
NoContent
|
StatusCode
:
:
ResetContent
|
StatusCode
:
:
NotModified
=
>
true
_
=
>
false
}
_
=
>
false
}
}
