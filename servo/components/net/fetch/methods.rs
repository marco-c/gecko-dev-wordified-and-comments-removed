use
blob_loader
:
:
load_blob_sync
;
use
data_loader
:
:
decode
;
use
devtools_traits
:
:
DevtoolsControlMsg
;
use
fetch
:
:
cors_cache
:
:
CorsCache
;
use
filemanager_thread
:
:
FileManager
;
use
http_loader
:
:
{
HttpState
determine_request_referrer
http_fetch
}
;
use
http_loader
:
:
{
set_default_accept
set_default_accept_language
}
;
use
hyper
:
:
{
Error
Result
as
HyperResult
}
;
use
hyper
:
:
header
:
:
{
Accept
AcceptLanguage
AccessControlExposeHeaders
ContentLanguage
ContentType
}
;
use
hyper
:
:
header
:
:
{
Header
HeaderFormat
HeaderView
Headers
Referer
as
RefererHeader
}
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
mime
:
:
{
Mime
SubLevel
TopLevel
}
;
use
hyper
:
:
status
:
:
StatusCode
;
use
ipc_channel
:
:
ipc
:
:
IpcReceiver
;
use
mime_guess
:
:
guess_mime_type
;
use
net_traits
:
:
{
FetchTaskTarget
NetworkError
ReferrerPolicy
}
;
use
net_traits
:
:
request
:
:
{
CredentialsMode
Destination
Referrer
Request
RequestMode
}
;
use
net_traits
:
:
request
:
:
{
ResponseTainting
Origin
Window
}
;
use
net_traits
:
:
response
:
:
{
Response
ResponseBody
ResponseType
}
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
fmt
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
mem
;
use
std
:
:
str
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
use
std
:
:
sync
:
:
mpsc
:
:
{
Sender
Receiver
}
;
use
subresource_integrity
:
:
is_response_integrity_valid
;
pub
type
Target
<
'
a
>
=
&
'
a
mut
(
FetchTaskTarget
+
Send
)
;
pub
enum
Data
{
Payload
(
Vec
<
u8
>
)
Done
Cancelled
}
pub
struct
FetchContext
{
pub
state
:
Arc
<
HttpState
>
pub
user_agent
:
Cow
<
'
static
str
>
pub
devtools_chan
:
Option
<
Sender
<
DevtoolsControlMsg
>
>
pub
filemanager
:
FileManager
pub
cancellation_listener
:
Arc
<
Mutex
<
CancellationListener
>
>
}
pub
struct
CancellationListener
{
cancel_chan
:
Option
<
IpcReceiver
<
(
)
>
>
cancelled
:
bool
}
impl
CancellationListener
{
pub
fn
new
(
cancel_chan
:
Option
<
IpcReceiver
<
(
)
>
>
)
-
>
Self
{
Self
{
cancel_chan
:
cancel_chan
cancelled
:
false
}
}
pub
fn
cancelled
(
&
mut
self
)
-
>
bool
{
if
let
Some
(
ref
cancel_chan
)
=
self
.
cancel_chan
{
if
self
.
cancelled
{
true
}
else
if
cancel_chan
.
try_recv
(
)
.
is_ok
(
)
{
self
.
cancelled
=
true
;
true
}
else
{
false
}
}
else
{
false
}
}
}
pub
type
DoneChannel
=
Option
<
(
Sender
<
Data
>
Receiver
<
Data
>
)
>
;
pub
fn
fetch
(
request
:
&
mut
Request
target
:
Target
context
:
&
FetchContext
)
{
fetch_with_cors_cache
(
request
&
mut
CorsCache
:
:
new
(
)
target
context
)
;
}
pub
fn
fetch_with_cors_cache
(
request
:
&
mut
Request
cache
:
&
mut
CorsCache
target
:
Target
context
:
&
FetchContext
)
{
if
request
.
window
=
=
Window
:
:
Client
{
}
else
{
request
.
window
=
Window
:
:
NoWindow
;
}
if
request
.
origin
=
=
Origin
:
:
Client
{
unimplemented
!
(
)
}
set_default_accept
(
request
.
destination
&
mut
request
.
headers
)
;
set_default_accept_language
(
&
mut
request
.
headers
)
;
if
request
.
is_subresource_request
(
)
{
}
main_fetch
(
request
cache
false
false
target
&
mut
None
&
context
)
;
}
pub
fn
main_fetch
(
request
:
&
mut
Request
cache
:
&
mut
CorsCache
cors_flag
:
bool
recursive_flag
:
bool
target
:
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
mut
response
=
None
;
if
request
.
local_urls_only
{
if
!
matches
!
(
request
.
current_url
(
)
.
scheme
(
)
"
about
"
|
"
blob
"
|
"
data
"
|
"
filesystem
"
)
{
response
=
Some
(
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Non
-
local
scheme
"
.
into
(
)
)
)
)
;
}
}
if
should_be_blocked_due_to_bad_port
(
&
request
.
current_url
(
)
)
{
response
=
Some
(
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Request
attempted
on
bad
port
"
.
into
(
)
)
)
)
;
}
request
.
referrer_policy
=
request
.
referrer_policy
.
or
(
Some
(
ReferrerPolicy
:
:
NoReferrerWhenDowngrade
)
)
;
{
let
referrer_url
=
match
mem
:
:
replace
(
&
mut
request
.
referrer
Referrer
:
:
NoReferrer
)
{
Referrer
:
:
NoReferrer
=
>
None
Referrer
:
:
Client
=
>
{
request
.
headers
.
remove
:
:
<
RefererHeader
>
(
)
;
None
}
Referrer
:
:
ReferrerUrl
(
url
)
=
>
{
request
.
headers
.
remove
:
:
<
RefererHeader
>
(
)
;
let
current_url
=
request
.
current_url
(
)
.
clone
(
)
;
determine_request_referrer
(
&
mut
request
.
headers
request
.
referrer_policy
.
unwrap
(
)
url
current_url
)
}
}
;
if
let
Some
(
referrer_url
)
=
referrer_url
{
request
.
referrer
=
Referrer
:
:
ReferrerUrl
(
referrer_url
)
;
}
}
context
.
state
.
hsts_list
.
read
(
)
.
unwrap
(
)
.
switch_known_hsts_host_domain_url_to_https
(
request
.
current_url_mut
(
)
)
;
let
mut
response
=
response
.
unwrap_or_else
(
|
|
{
let
current_url
=
request
.
current_url
(
)
;
let
same_origin
=
if
let
Origin
:
:
Origin
(
ref
origin
)
=
request
.
origin
{
*
origin
=
=
current_url
.
origin
(
)
}
else
{
false
}
;
if
(
same_origin
&
&
!
cors_flag
)
|
|
current_url
.
scheme
(
)
=
=
"
data
"
|
|
current_url
.
scheme
(
)
=
=
"
file
"
|
|
current_url
.
scheme
(
)
=
=
"
about
"
|
|
request
.
mode
=
=
RequestMode
:
:
Navigate
{
request
.
response_tainting
=
ResponseTainting
:
:
Basic
;
scheme_fetch
(
request
cache
target
done_chan
context
)
}
else
if
request
.
mode
=
=
RequestMode
:
:
SameOrigin
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Cross
-
origin
response
"
.
into
(
)
)
)
}
else
if
request
.
mode
=
=
RequestMode
:
:
NoCors
{
request
.
response_tainting
=
ResponseTainting
:
:
Opaque
;
scheme_fetch
(
request
cache
target
done_chan
context
)
}
else
if
!
matches
!
(
current_url
.
scheme
(
)
"
http
"
|
"
https
"
)
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Non
-
http
scheme
"
.
into
(
)
)
)
}
else
if
request
.
use_cors_preflight
|
|
(
request
.
unsafe_request
&
&
(
!
is_cors_safelisted_method
(
&
request
.
method
)
|
|
request
.
headers
.
iter
(
)
.
any
(
|
h
|
!
is_cors_safelisted_request_header
(
&
h
)
)
)
)
{
request
.
response_tainting
=
ResponseTainting
:
:
CorsTainting
;
let
response
=
http_fetch
(
request
cache
true
true
false
target
done_chan
context
)
;
if
response
.
is_network_error
(
)
{
}
response
}
else
{
request
.
response_tainting
=
ResponseTainting
:
:
CorsTainting
;
http_fetch
(
request
cache
true
false
false
target
done_chan
context
)
}
}
)
;
if
recursive_flag
{
return
response
;
}
let
mut
response
=
if
!
response
.
is_network_error
(
)
&
&
response
.
internal_response
.
is_none
(
)
{
if
request
.
response_tainting
=
=
ResponseTainting
:
:
CorsTainting
{
let
header_names
=
response
.
headers
.
get
:
:
<
AccessControlExposeHeaders
>
(
)
;
match
header_names
{
Some
(
list
)
if
request
.
credentials_mode
!
=
CredentialsMode
:
:
Include
=
>
{
if
list
.
len
(
)
=
=
1
&
&
list
[
0
]
=
=
"
*
"
{
response
.
cors_exposed_header_name_list
=
response
.
headers
.
iter
(
)
.
map
(
|
h
|
h
.
name
(
)
.
to_owned
(
)
)
.
collect
(
)
;
}
}
Some
(
list
)
=
>
{
response
.
cors_exposed_header_name_list
=
list
.
iter
(
)
.
map
(
|
h
|
(
*
*
h
)
.
clone
(
)
)
.
collect
(
)
;
}
_
=
>
(
)
}
}
let
response_type
=
match
request
.
response_tainting
{
ResponseTainting
:
:
Basic
=
>
ResponseType
:
:
Basic
ResponseTainting
:
:
CorsTainting
=
>
ResponseType
:
:
Cors
ResponseTainting
:
:
Opaque
=
>
ResponseType
:
:
Opaque
}
;
response
.
to_filtered
(
response_type
)
}
else
{
response
}
;
let
internal_error
=
{
let
response_is_network_error
=
response
.
is_network_error
(
)
;
let
should_replace_with_nosniff_error
=
!
response_is_network_error
&
&
should_be_blocked_due_to_nosniff
(
request
.
destination
&
response
.
headers
)
;
let
should_replace_with_mime_type_error
=
!
response_is_network_error
&
&
should_be_blocked_due_to_mime_type
(
request
.
destination
&
response
.
headers
)
;
let
mut
network_error_response
=
response
.
get_network_error
(
)
.
cloned
(
)
.
map
(
Response
:
:
network_error
)
;
let
internal_response
=
if
let
Some
(
error_response
)
=
network_error_response
.
as_mut
(
)
{
error_response
}
else
{
response
.
actual_response_mut
(
)
}
;
if
internal_response
.
url_list
.
is_empty
(
)
{
internal_response
.
url_list
=
request
.
url_list
.
clone
(
)
;
}
let
blocked_error_response
;
let
internal_response
=
if
should_replace_with_nosniff_error
{
blocked_error_response
=
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Blocked
by
nosniff
"
.
into
(
)
)
)
;
&
blocked_error_response
}
else
if
should_replace_with_mime_type_error
{
blocked_error_response
=
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Blocked
by
mime
type
"
.
into
(
)
)
)
;
&
blocked_error_response
}
else
{
internal_response
}
;
let
not_network_error
=
!
response_is_network_error
&
&
!
internal_response
.
is_network_error
(
)
;
if
not_network_error
&
&
(
is_null_body_status
(
&
internal_response
.
status
)
|
|
match
request
.
method
{
Method
:
:
Head
|
Method
:
:
Connect
=
>
true
_
=
>
false
}
)
{
let
mut
body
=
internal_response
.
body
.
lock
(
)
.
unwrap
(
)
;
*
body
=
ResponseBody
:
:
Empty
;
}
internal_response
.
get_network_error
(
)
.
map
(
|
e
|
e
.
clone
(
)
)
}
;
let
mut
response
=
if
let
Some
(
error
)
=
internal_error
{
Response
:
:
network_error
(
error
)
}
else
{
response
}
;
let
mut
response_loaded
=
false
;
let
mut
response
=
if
!
response
.
is_network_error
(
)
&
&
!
request
.
integrity_metadata
.
is_empty
(
)
{
wait_for_response
(
&
mut
response
target
done_chan
)
;
response_loaded
=
true
;
let
ref
integrity_metadata
=
&
request
.
integrity_metadata
;
if
response
.
termination_reason
.
is_none
(
)
&
&
!
is_response_integrity_valid
(
integrity_metadata
&
response
)
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Subresource
integrity
validation
failed
"
.
into
(
)
)
)
}
else
{
response
}
}
else
{
response
}
;
if
request
.
synchronous
{
target
.
process_response
(
&
mut
response
)
;
if
!
response_loaded
{
wait_for_response
(
&
mut
response
target
done_chan
)
;
}
target
.
process_response_eof
(
&
response
)
;
return
response
;
}
if
request
.
body
.
is_some
(
)
&
&
matches
!
(
request
.
current_url
(
)
.
scheme
(
)
"
http
"
|
"
https
"
)
{
target
.
process_request_body
(
&
request
)
;
target
.
process_request_eof
(
&
request
)
;
}
target
.
process_response
(
&
response
)
;
if
!
response_loaded
{
wait_for_response
(
&
mut
response
target
done_chan
)
;
}
target
.
process_response_eof
(
&
response
)
;
if
!
response
.
is_network_error
(
)
{
if
let
Ok
(
mut
http_cache
)
=
context
.
state
.
http_cache
.
write
(
)
{
http_cache
.
update_awaiting_consumers
(
&
request
&
response
)
;
}
}
response
}
fn
wait_for_response
(
response
:
&
mut
Response
target
:
Target
done_chan
:
&
mut
DoneChannel
)
{
if
let
Some
(
ref
ch
)
=
*
done_chan
{
loop
{
match
ch
.
1
.
recv
(
)
.
expect
(
"
fetch
worker
should
always
send
Done
before
terminating
"
)
{
Data
:
:
Payload
(
vec
)
=
>
{
target
.
process_response_chunk
(
vec
)
;
}
Data
:
:
Done
=
>
break
Data
:
:
Cancelled
=
>
{
response
.
aborted
.
store
(
true
Ordering
:
:
Relaxed
)
;
break
;
}
}
}
}
else
{
let
body
=
response
.
body
.
lock
(
)
.
unwrap
(
)
;
if
let
ResponseBody
:
:
Done
(
ref
vec
)
=
*
body
{
target
.
process_response_chunk
(
vec
.
clone
(
)
)
;
}
else
{
assert_eq
!
(
*
body
ResponseBody
:
:
Empty
)
}
}
}
fn
scheme_fetch
(
request
:
&
mut
Request
cache
:
&
mut
CorsCache
target
:
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
url
=
request
.
current_url
(
)
;
match
url
.
scheme
(
)
{
"
about
"
if
url
.
path
(
)
=
=
"
blank
"
=
>
{
let
mut
response
=
Response
:
:
new
(
url
)
;
response
.
headers
.
set
(
ContentType
(
mime
!
(
Text
/
Html
;
Charset
=
Utf8
)
)
)
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
vec
!
[
]
)
;
response
}
"
http
"
|
"
https
"
=
>
{
http_fetch
(
request
cache
false
false
false
target
done_chan
context
)
}
"
data
"
=
>
{
match
decode
(
&
url
)
{
Ok
(
(
mime
bytes
)
)
=
>
{
let
mut
response
=
Response
:
:
new
(
url
)
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
bytes
)
;
response
.
headers
.
set
(
ContentType
(
mime
)
)
;
response
}
Err
(
_
)
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Decoding
data
URL
failed
"
.
into
(
)
)
)
}
}
"
file
"
=
>
{
if
request
.
method
=
=
Method
:
:
Get
{
match
url
.
to_file_path
(
)
{
Ok
(
file_path
)
=
>
{
match
File
:
:
open
(
file_path
.
clone
(
)
)
{
Ok
(
mut
file
)
=
>
{
let
mut
bytes
=
vec
!
[
]
;
let
_
=
file
.
read_to_end
(
&
mut
bytes
)
;
let
mime
=
guess_mime_type
(
file_path
)
;
let
mut
response
=
Response
:
:
new
(
url
)
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
bytes
)
;
response
.
headers
.
set
(
ContentType
(
mime
)
)
;
response
}
_
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Opening
file
failed
"
.
into
(
)
)
)
}
}
_
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Constructing
file
path
failed
"
.
into
(
)
)
)
}
}
else
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
method
for
file
"
.
into
(
)
)
)
}
}
"
blob
"
=
>
{
println
!
(
"
Loading
blob
{
}
"
url
.
as_str
(
)
)
;
if
request
.
method
!
=
Method
:
:
Get
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
method
for
blob
"
.
into
(
)
)
)
;
}
match
load_blob_sync
(
url
.
clone
(
)
context
.
filemanager
.
clone
(
)
)
{
Ok
(
(
headers
bytes
)
)
=
>
{
let
mut
response
=
Response
:
:
new
(
url
)
;
response
.
headers
=
headers
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
bytes
)
;
response
}
Err
(
e
)
=
>
{
debug
!
(
"
Failed
to
load
{
}
:
{
:
?
}
"
url
e
)
;
Response
:
:
network_error
(
e
)
}
}
}
"
ftp
"
=
>
{
debug
!
(
"
ftp
is
not
implemented
"
)
;
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
scheme
"
.
into
(
)
)
)
}
_
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
scheme
"
.
into
(
)
)
)
}
}
pub
fn
is_cors_safelisted_request_header
(
h
:
&
HeaderView
)
-
>
bool
{
if
h
.
is
:
:
<
ContentType
>
(
)
{
match
h
.
value
(
)
{
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Plain
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
WwwFormUrlEncoded
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Multipart
SubLevel
:
:
FormData
_
)
)
)
=
>
true
_
=
>
false
}
}
else
{
h
.
is
:
:
<
Accept
>
(
)
|
|
h
.
is
:
:
<
AcceptLanguage
>
(
)
|
|
h
.
is
:
:
<
ContentLanguage
>
(
)
}
}
pub
fn
is_cors_safelisted_method
(
m
:
&
Method
)
-
>
bool
{
match
*
m
{
Method
:
:
Get
|
Method
:
:
Head
|
Method
:
:
Post
=
>
true
_
=
>
false
}
}
fn
is_null_body_status
(
status
:
&
Option
<
StatusCode
>
)
-
>
bool
{
match
*
status
{
Some
(
status
)
=
>
match
status
{
StatusCode
:
:
SwitchingProtocols
|
StatusCode
:
:
NoContent
|
StatusCode
:
:
ResetContent
|
StatusCode
:
:
NotModified
=
>
true
_
=
>
false
}
_
=
>
false
}
}
pub
fn
should_be_blocked_due_to_nosniff
(
destination
:
Destination
response_headers
:
&
Headers
)
-
>
bool
{
#
[
derive
(
Clone
Copy
Debug
)
]
struct
XContentTypeOptions
;
impl
Header
for
XContentTypeOptions
{
fn
header_name
(
)
-
>
&
'
static
str
{
"
X
-
Content
-
Type
-
Options
"
}
fn
parse_header
(
raw
:
&
[
Vec
<
u8
>
]
)
-
>
HyperResult
<
Self
>
{
raw
.
first
(
)
.
and_then
(
|
v
|
str
:
:
from_utf8
(
v
)
.
ok
(
)
)
.
and_then
(
|
s
|
if
s
.
trim
(
)
.
eq_ignore_ascii_case
(
"
nosniff
"
)
{
Some
(
XContentTypeOptions
)
}
else
{
None
}
)
.
ok_or
(
Error
:
:
Header
)
}
}
impl
HeaderFormat
for
XContentTypeOptions
{
fn
fmt_header
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
nosniff
"
)
}
}
if
response_headers
.
get
:
:
<
XContentTypeOptions
>
(
)
.
is_none
(
)
{
return
false
;
}
let
content_type_header
=
response_headers
.
get
:
:
<
ContentType
>
(
)
;
#
[
inline
]
fn
is_javascript_mime_type
(
mime_type
:
&
Mime
)
-
>
bool
{
let
javascript_mime_types
:
[
Mime
;
16
]
=
[
mime
!
(
Application
/
(
"
ecmascript
"
)
)
mime
!
(
Application
/
(
"
javascript
"
)
)
mime
!
(
Application
/
(
"
x
-
ecmascript
"
)
)
mime
!
(
Application
/
(
"
x
-
javascript
"
)
)
mime
!
(
Text
/
(
"
ecmascript
"
)
)
mime
!
(
Text
/
(
"
javascript
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
0
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
1
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
2
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
3
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
4
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
5
"
)
)
mime
!
(
Text
/
(
"
jscript
"
)
)
mime
!
(
Text
/
(
"
livescript
"
)
)
mime
!
(
Text
/
(
"
x
-
ecmascript
"
)
)
mime
!
(
Text
/
(
"
x
-
javascript
"
)
)
]
;
javascript_mime_types
.
iter
(
)
.
any
(
|
mime
|
mime
.
0
=
=
mime_type
.
0
&
&
mime
.
1
=
=
mime_type
.
1
)
}
match
content_type_header
{
Some
(
&
ContentType
(
ref
mime_type
)
)
if
destination
.
is_script_like
(
)
=
>
!
is_javascript_mime_type
(
mime_type
)
Some
(
&
ContentType
(
Mime
(
ref
tl
ref
sl
_
)
)
)
if
destination
=
=
Destination
:
:
Style
=
>
*
tl
!
=
TopLevel
:
:
Text
&
&
*
sl
!
=
SubLevel
:
:
Css
None
if
destination
=
=
Destination
:
:
Style
|
|
destination
.
is_script_like
(
)
=
>
true
_
=
>
false
}
}
fn
should_be_blocked_due_to_mime_type
(
destination
:
Destination
response_headers
:
&
Headers
)
-
>
bool
{
let
mime_type
=
match
response_headers
.
get
:
:
<
ContentType
>
(
)
{
Some
(
header
)
=
>
header
None
=
>
return
false
}
;
destination
.
is_script_like
(
)
&
&
match
*
mime_type
{
ContentType
(
Mime
(
TopLevel
:
:
Audio
_
_
)
)
|
ContentType
(
Mime
(
TopLevel
:
:
Video
_
_
)
)
|
ContentType
(
Mime
(
TopLevel
:
:
Image
_
_
)
)
=
>
true
ContentType
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Ext
(
ref
ext
)
_
)
)
=
>
ext
=
=
"
csv
"
_
=
>
false
}
}
pub
fn
should_be_blocked_due_to_bad_port
(
url
:
&
ServoUrl
)
-
>
bool
{
let
scheme
=
url
.
scheme
(
)
;
let
port
=
if
let
Some
(
port
)
=
url
.
port
(
)
{
port
}
else
{
return
false
}
;
if
scheme
=
=
"
ftp
"
&
&
(
port
=
=
20
|
|
port
=
=
21
)
{
return
false
;
}
if
is_network_scheme
(
scheme
)
&
&
is_bad_port
(
port
)
{
return
true
;
}
false
}
fn
is_network_scheme
(
scheme
:
&
str
)
-
>
bool
{
scheme
=
=
"
ftp
"
|
|
scheme
=
=
"
http
"
|
|
scheme
=
=
"
https
"
}
fn
is_bad_port
(
port
:
u16
)
-
>
bool
{
static
BAD_PORTS
:
[
u16
;
64
]
=
[
1
7
9
11
13
15
17
19
20
21
22
23
25
37
42
43
53
77
79
87
95
101
102
103
104
109
110
111
113
115
117
119
123
135
139
143
179
389
465
512
513
514
515
526
530
531
532
540
556
563
587
601
636
993
995
2049
3659
4045
6000
6665
6666
6667
6668
6669
]
;
BAD_PORTS
.
binary_search
(
&
port
)
.
is_ok
(
)
}
