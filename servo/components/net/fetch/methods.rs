use
blob_loader
:
:
load_blob_sync
;
use
data_loader
:
:
decode
;
use
devtools_traits
:
:
DevtoolsControlMsg
;
use
fetch
:
:
cors_cache
:
:
CorsCache
;
use
filemanager_thread
:
:
FileManager
;
use
http_loader
:
:
{
HttpState
determine_request_referrer
http_fetch
}
;
use
http_loader
:
:
{
set_default_accept
set_default_accept_language
}
;
use
hyper
:
:
{
Error
Result
as
HyperResult
}
;
use
hyper
:
:
header
:
:
{
Accept
AcceptLanguage
ContentLanguage
ContentType
}
;
use
hyper
:
:
header
:
:
{
Header
HeaderFormat
HeaderView
Headers
Referer
as
RefererHeader
}
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
mime
:
:
{
Mime
SubLevel
TopLevel
}
;
use
hyper
:
:
status
:
:
StatusCode
;
use
mime_guess
:
:
guess_mime_type
;
use
net_traits
:
:
{
FetchTaskTarget
NetworkError
ReferrerPolicy
}
;
use
net_traits
:
:
request
:
:
{
Referrer
Request
RequestMode
ResponseTainting
}
;
use
net_traits
:
:
request
:
:
{
Type
Origin
Window
}
;
use
net_traits
:
:
response
:
:
{
Response
ResponseBody
ResponseType
}
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
fmt
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
mem
;
use
std
:
:
str
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
mpsc
:
:
{
Sender
Receiver
}
;
use
subresource_integrity
:
:
is_response_integrity_valid
;
pub
type
Target
<
'
a
>
=
&
'
a
mut
(
FetchTaskTarget
+
Send
)
;
pub
enum
Data
{
Payload
(
Vec
<
u8
>
)
Done
}
pub
struct
FetchContext
{
pub
state
:
Arc
<
HttpState
>
pub
user_agent
:
Cow
<
'
static
str
>
pub
devtools_chan
:
Option
<
Sender
<
DevtoolsControlMsg
>
>
pub
filemanager
:
FileManager
}
pub
type
DoneChannel
=
Option
<
(
Sender
<
Data
>
Receiver
<
Data
>
)
>
;
pub
fn
fetch
(
request
:
&
mut
Request
target
:
Target
context
:
&
FetchContext
)
{
fetch_with_cors_cache
(
request
&
mut
CorsCache
:
:
new
(
)
target
context
)
;
}
pub
fn
fetch_with_cors_cache
(
request
:
&
mut
Request
cache
:
&
mut
CorsCache
target
:
Target
context
:
&
FetchContext
)
{
if
request
.
window
=
=
Window
:
:
Client
{
}
else
{
request
.
window
=
Window
:
:
NoWindow
;
}
if
request
.
origin
=
=
Origin
:
:
Client
{
unimplemented
!
(
)
}
set_default_accept
(
request
.
type_
request
.
destination
&
mut
request
.
headers
)
;
set_default_accept_language
(
&
mut
request
.
headers
)
;
if
request
.
is_subresource_request
(
)
{
}
main_fetch
(
request
cache
false
false
target
&
mut
None
&
context
)
;
}
pub
fn
main_fetch
(
request
:
&
mut
Request
cache
:
&
mut
CorsCache
cors_flag
:
bool
recursive_flag
:
bool
target
:
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
mut
response
=
None
;
if
request
.
local_urls_only
{
match
request
.
current_url
(
)
.
scheme
(
)
{
"
about
"
|
"
blob
"
|
"
data
"
|
"
filesystem
"
=
>
(
)
_
=
>
response
=
Some
(
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Non
-
local
scheme
"
.
into
(
)
)
)
)
}
}
if
should_be_blocked_due_to_bad_port
(
&
request
.
url
(
)
)
{
response
=
Some
(
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Request
attempted
on
bad
port
"
.
into
(
)
)
)
)
;
}
let
referrer_policy
=
request
.
referrer_policy
.
unwrap_or
(
ReferrerPolicy
:
:
NoReferrerWhenDowngrade
)
;
request
.
referrer_policy
=
Some
(
referrer_policy
)
;
{
let
referrer_url
=
match
mem
:
:
replace
(
&
mut
request
.
referrer
Referrer
:
:
NoReferrer
)
{
Referrer
:
:
NoReferrer
=
>
None
Referrer
:
:
Client
=
>
{
request
.
headers
.
remove
:
:
<
RefererHeader
>
(
)
;
None
}
Referrer
:
:
ReferrerUrl
(
url
)
=
>
{
request
.
headers
.
remove
:
:
<
RefererHeader
>
(
)
;
let
current_url
=
request
.
current_url
(
)
.
clone
(
)
;
determine_request_referrer
(
&
mut
request
.
headers
referrer_policy
url
current_url
)
}
}
;
if
let
Some
(
referrer_url
)
=
referrer_url
{
request
.
referrer
=
Referrer
:
:
ReferrerUrl
(
referrer_url
)
;
}
}
context
.
state
.
hsts_list
.
read
(
)
.
unwrap
(
)
.
switch_known_hsts_host_domain_url_to_https
(
request
.
current_url_mut
(
)
)
;
let
response
=
response
.
unwrap_or_else
(
|
|
{
let
current_url
=
request
.
current_url
(
)
;
let
same_origin
=
if
let
Origin
:
:
Origin
(
ref
origin
)
=
request
.
origin
{
*
origin
=
=
current_url
.
origin
(
)
}
else
{
false
}
;
if
(
same_origin
&
&
!
cors_flag
)
|
|
current_url
.
scheme
(
)
=
=
"
data
"
|
|
current_url
.
scheme
(
)
=
=
"
file
"
|
|
current_url
.
scheme
(
)
=
=
"
about
"
|
|
request
.
mode
=
=
RequestMode
:
:
Navigate
{
basic_fetch
(
request
cache
target
done_chan
context
)
}
else
if
request
.
mode
=
=
RequestMode
:
:
SameOrigin
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Cross
-
origin
response
"
.
into
(
)
)
)
}
else
if
request
.
mode
=
=
RequestMode
:
:
NoCors
{
request
.
response_tainting
=
ResponseTainting
:
:
Opaque
;
basic_fetch
(
request
cache
target
done_chan
context
)
}
else
if
!
matches
!
(
current_url
.
scheme
(
)
"
http
"
|
"
https
"
)
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Non
-
http
scheme
"
.
into
(
)
)
)
}
else
if
request
.
use_cors_preflight
|
|
(
request
.
unsafe_request
&
&
(
!
is_simple_method
(
&
request
.
method
)
|
|
request
.
headers
.
iter
(
)
.
any
(
|
h
|
!
is_simple_header
(
&
h
)
)
)
)
{
request
.
response_tainting
=
ResponseTainting
:
:
CorsTainting
;
let
response
=
http_fetch
(
request
cache
true
true
false
target
done_chan
context
)
;
if
response
.
is_network_error
(
)
{
}
response
}
else
{
request
.
response_tainting
=
ResponseTainting
:
:
CorsTainting
;
http_fetch
(
request
cache
true
false
false
target
done_chan
context
)
}
}
)
;
if
recursive_flag
{
return
response
;
}
let
mut
response
=
if
response
.
response_type
=
=
ResponseType
:
:
Default
{
let
response_type
=
match
request
.
response_tainting
{
ResponseTainting
:
:
Basic
=
>
ResponseType
:
:
Basic
ResponseTainting
:
:
CorsTainting
=
>
ResponseType
:
:
Cors
ResponseTainting
:
:
Opaque
=
>
ResponseType
:
:
Opaque
}
;
response
.
to_filtered
(
response_type
)
}
else
{
response
}
;
let
internal_error
=
{
let
response_is_network_error
=
response
.
is_network_error
(
)
;
let
should_replace_with_nosniff_error
=
!
response_is_network_error
&
&
should_be_blocked_due_to_nosniff
(
request
.
type_
&
response
.
headers
)
;
let
should_replace_with_mime_type_error
=
!
response_is_network_error
&
&
should_be_blocked_due_to_mime_type
(
request
.
type_
&
response
.
headers
)
;
let
mut
network_error_response
=
response
.
get_network_error
(
)
.
cloned
(
)
.
map
(
Response
:
:
network_error
)
;
let
internal_response
=
if
let
Some
(
error_response
)
=
network_error_response
.
as_mut
(
)
{
error_response
}
else
{
response
.
actual_response_mut
(
)
}
;
if
internal_response
.
url_list
.
is_empty
(
)
{
internal_response
.
url_list
=
request
.
url_list
.
clone
(
)
;
}
let
blocked_error_response
;
let
internal_response
=
if
should_replace_with_nosniff_error
{
blocked_error_response
=
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Blocked
by
nosniff
"
.
into
(
)
)
)
;
&
blocked_error_response
}
else
if
should_replace_with_mime_type_error
{
blocked_error_response
=
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Blocked
by
mime
type
"
.
into
(
)
)
)
;
&
blocked_error_response
}
else
{
internal_response
}
;
let
not_network_error
=
!
response_is_network_error
&
&
!
internal_response
.
is_network_error
(
)
;
if
not_network_error
&
&
(
is_null_body_status
(
&
internal_response
.
status
)
|
|
match
request
.
method
{
Method
:
:
Head
|
Method
:
:
Connect
=
>
true
_
=
>
false
}
)
{
let
mut
body
=
internal_response
.
body
.
lock
(
)
.
unwrap
(
)
;
*
body
=
ResponseBody
:
:
Empty
;
}
internal_response
.
get_network_error
(
)
.
map
(
|
e
|
e
.
clone
(
)
)
}
;
let
response
=
if
let
Some
(
error
)
=
internal_error
{
Response
:
:
network_error
(
error
)
}
else
{
response
}
;
let
mut
response_loaded
=
false
;
let
response
=
if
!
response
.
is_network_error
(
)
&
&
!
request
.
integrity_metadata
.
is_empty
(
)
{
wait_for_response
(
&
response
target
done_chan
)
;
response_loaded
=
true
;
let
ref
integrity_metadata
=
&
request
.
integrity_metadata
;
if
response
.
termination_reason
.
is_none
(
)
&
&
!
is_response_integrity_valid
(
integrity_metadata
&
response
)
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Subresource
integrity
validation
failed
"
.
into
(
)
)
)
}
else
{
response
}
}
else
{
response
}
;
if
request
.
synchronous
{
target
.
process_response
(
&
response
)
;
if
!
response_loaded
{
wait_for_response
(
&
response
target
done_chan
)
;
}
target
.
process_response_eof
(
&
response
)
;
return
response
;
}
if
request
.
body
.
is_some
(
)
&
&
matches
!
(
request
.
current_url
(
)
.
scheme
(
)
"
http
"
|
"
https
"
)
{
target
.
process_request_body
(
&
request
)
;
target
.
process_request_eof
(
&
request
)
;
}
target
.
process_response
(
&
response
)
;
if
!
response_loaded
{
wait_for_response
(
&
response
target
done_chan
)
;
}
target
.
process_response_eof
(
&
response
)
;
response
}
fn
wait_for_response
(
response
:
&
Response
target
:
Target
done_chan
:
&
mut
DoneChannel
)
{
if
let
Some
(
ref
ch
)
=
*
done_chan
{
loop
{
match
ch
.
1
.
recv
(
)
.
expect
(
"
fetch
worker
should
always
send
Done
before
terminating
"
)
{
Data
:
:
Payload
(
vec
)
=
>
{
target
.
process_response_chunk
(
vec
)
;
}
Data
:
:
Done
=
>
break
}
}
}
else
{
let
body
=
response
.
body
.
lock
(
)
.
unwrap
(
)
;
if
let
ResponseBody
:
:
Done
(
ref
vec
)
=
*
body
{
target
.
process_response_chunk
(
vec
.
clone
(
)
)
;
}
else
{
assert
!
(
*
body
=
=
ResponseBody
:
:
Empty
)
}
}
}
fn
basic_fetch
(
request
:
&
mut
Request
cache
:
&
mut
CorsCache
target
:
Target
done_chan
:
&
mut
DoneChannel
context
:
&
FetchContext
)
-
>
Response
{
let
url
=
request
.
current_url
(
)
;
match
url
.
scheme
(
)
{
"
about
"
if
url
.
path
(
)
=
=
"
blank
"
=
>
{
let
mut
response
=
Response
:
:
new
(
url
)
;
response
.
headers
.
set
(
ContentType
(
mime
!
(
Text
/
Html
;
Charset
=
Utf8
)
)
)
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
vec
!
[
]
)
;
response
}
"
http
"
|
"
https
"
=
>
{
http_fetch
(
request
cache
false
false
false
target
done_chan
context
)
}
"
data
"
=
>
{
match
decode
(
&
url
)
{
Ok
(
(
mime
bytes
)
)
=
>
{
let
mut
response
=
Response
:
:
new
(
url
)
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
bytes
)
;
response
.
headers
.
set
(
ContentType
(
mime
)
)
;
response
}
Err
(
_
)
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Decoding
data
URL
failed
"
.
into
(
)
)
)
}
}
"
file
"
=
>
{
if
request
.
method
=
=
Method
:
:
Get
{
match
url
.
to_file_path
(
)
{
Ok
(
file_path
)
=
>
{
match
File
:
:
open
(
file_path
.
clone
(
)
)
{
Ok
(
mut
file
)
=
>
{
let
mut
bytes
=
vec
!
[
]
;
let
_
=
file
.
read_to_end
(
&
mut
bytes
)
;
let
mime
=
guess_mime_type
(
file_path
)
;
let
mut
response
=
Response
:
:
new
(
url
)
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
bytes
)
;
response
.
headers
.
set
(
ContentType
(
mime
)
)
;
response
}
_
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Opening
file
failed
"
.
into
(
)
)
)
}
}
_
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Constructing
file
path
failed
"
.
into
(
)
)
)
}
}
else
{
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
method
for
file
"
.
into
(
)
)
)
}
}
"
blob
"
=
>
{
println
!
(
"
Loading
blob
{
}
"
url
.
as_str
(
)
)
;
if
request
.
method
!
=
Method
:
:
Get
{
return
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
method
for
blob
"
.
into
(
)
)
)
;
}
match
load_blob_sync
(
url
.
clone
(
)
context
.
filemanager
.
clone
(
)
)
{
Ok
(
(
headers
bytes
)
)
=
>
{
let
mut
response
=
Response
:
:
new
(
url
)
;
response
.
headers
=
headers
;
*
response
.
body
.
lock
(
)
.
unwrap
(
)
=
ResponseBody
:
:
Done
(
bytes
)
;
response
}
Err
(
e
)
=
>
{
debug
!
(
"
Failed
to
load
{
}
:
{
:
?
}
"
url
e
)
;
Response
:
:
network_error
(
e
)
}
}
}
"
ftp
"
=
>
{
debug
!
(
"
ftp
is
not
implemented
"
)
;
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
scheme
"
.
into
(
)
)
)
}
_
=
>
Response
:
:
network_error
(
NetworkError
:
:
Internal
(
"
Unexpected
scheme
"
.
into
(
)
)
)
}
}
pub
fn
is_simple_header
(
h
:
&
HeaderView
)
-
>
bool
{
if
h
.
is
:
:
<
ContentType
>
(
)
{
match
h
.
value
(
)
{
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Plain
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Application
SubLevel
:
:
WwwFormUrlEncoded
_
)
)
)
|
Some
(
&
ContentType
(
Mime
(
TopLevel
:
:
Multipart
SubLevel
:
:
FormData
_
)
)
)
=
>
true
_
=
>
false
}
}
else
{
h
.
is
:
:
<
Accept
>
(
)
|
|
h
.
is
:
:
<
AcceptLanguage
>
(
)
|
|
h
.
is
:
:
<
ContentLanguage
>
(
)
}
}
pub
fn
is_simple_method
(
m
:
&
Method
)
-
>
bool
{
match
*
m
{
Method
:
:
Get
|
Method
:
:
Head
|
Method
:
:
Post
=
>
true
_
=
>
false
}
}
fn
is_null_body_status
(
status
:
&
Option
<
StatusCode
>
)
-
>
bool
{
match
*
status
{
Some
(
status
)
=
>
match
status
{
StatusCode
:
:
SwitchingProtocols
|
StatusCode
:
:
NoContent
|
StatusCode
:
:
ResetContent
|
StatusCode
:
:
NotModified
=
>
true
_
=
>
false
}
_
=
>
false
}
}
pub
fn
should_be_blocked_due_to_nosniff
(
request_type
:
Type
response_headers
:
&
Headers
)
-
>
bool
{
#
[
derive
(
Debug
Clone
Copy
)
]
struct
XContentTypeOptions
;
impl
Header
for
XContentTypeOptions
{
fn
header_name
(
)
-
>
&
'
static
str
{
"
X
-
Content
-
Type
-
Options
"
}
fn
parse_header
(
raw
:
&
[
Vec
<
u8
>
]
)
-
>
HyperResult
<
Self
>
{
raw
.
first
(
)
.
and_then
(
|
v
|
str
:
:
from_utf8
(
v
)
.
ok
(
)
)
.
and_then
(
|
s
|
match
s
.
trim
(
)
.
to_lowercase
(
)
.
as_str
(
)
{
"
nosniff
"
=
>
Some
(
XContentTypeOptions
)
_
=
>
None
}
)
.
ok_or
(
Error
:
:
Header
)
}
}
impl
HeaderFormat
for
XContentTypeOptions
{
fn
fmt_header
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
nosniff
"
)
}
}
if
response_headers
.
get
:
:
<
XContentTypeOptions
>
(
)
.
is_none
(
)
{
return
false
;
}
let
content_type_header
=
response_headers
.
get
:
:
<
ContentType
>
(
)
;
#
[
inline
]
fn
is_javascript_mime_type
(
mime_type
:
&
Mime
)
-
>
bool
{
let
javascript_mime_types
:
[
Mime
;
16
]
=
[
mime
!
(
Application
/
(
"
ecmascript
"
)
)
mime
!
(
Application
/
(
"
javascript
"
)
)
mime
!
(
Application
/
(
"
x
-
ecmascript
"
)
)
mime
!
(
Application
/
(
"
x
-
javascript
"
)
)
mime
!
(
Text
/
(
"
ecmascript
"
)
)
mime
!
(
Text
/
(
"
javascript
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
0
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
1
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
2
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
3
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
4
"
)
)
mime
!
(
Text
/
(
"
javascript1
.
5
"
)
)
mime
!
(
Text
/
(
"
jscript
"
)
)
mime
!
(
Text
/
(
"
livescript
"
)
)
mime
!
(
Text
/
(
"
x
-
ecmascript
"
)
)
mime
!
(
Text
/
(
"
x
-
javascript
"
)
)
]
;
javascript_mime_types
.
contains
(
mime_type
)
}
let
text_css
:
Mime
=
mime
!
(
Text
/
Css
)
;
return
match
request_type
{
Type
:
:
Script
=
>
{
match
content_type_header
{
Some
(
&
ContentType
(
ref
mime_type
)
)
=
>
!
is_javascript_mime_type
(
&
mime_type
)
None
=
>
true
}
}
Type
:
:
Style
=
>
{
match
content_type_header
{
Some
(
&
ContentType
(
ref
mime_type
)
)
=
>
mime_type
!
=
&
text_css
None
=
>
true
}
}
_
=
>
false
}
;
}
fn
should_be_blocked_due_to_mime_type
(
request_type
:
Type
response_headers
:
&
Headers
)
-
>
bool
{
let
mime_type
=
match
response_headers
.
get
:
:
<
ContentType
>
(
)
{
Some
(
header
)
=
>
header
None
=
>
return
false
}
;
request_type
=
=
Type
:
:
Script
&
&
match
*
mime_type
{
ContentType
(
Mime
(
TopLevel
:
:
Audio
_
_
)
)
|
ContentType
(
Mime
(
TopLevel
:
:
Video
_
_
)
)
|
ContentType
(
Mime
(
TopLevel
:
:
Image
_
_
)
)
=
>
true
ContentType
(
Mime
(
TopLevel
:
:
Text
SubLevel
:
:
Ext
(
ref
ext
)
_
)
)
=
>
ext
=
=
"
csv
"
_
=
>
false
}
}
pub
fn
should_be_blocked_due_to_bad_port
(
url
:
&
ServoUrl
)
-
>
bool
{
let
scheme
=
url
.
scheme
(
)
;
let
port
=
if
let
Some
(
port
)
=
url
.
port
(
)
{
port
}
else
{
return
false
}
;
if
scheme
=
=
"
ftp
"
&
&
(
port
=
=
20
|
|
port
=
=
21
)
{
return
false
;
}
if
is_network_scheme
(
scheme
)
&
&
is_bad_port
(
port
)
{
return
true
;
}
false
}
fn
is_network_scheme
(
scheme
:
&
str
)
-
>
bool
{
scheme
=
=
"
ftp
"
|
|
scheme
=
=
"
http
"
|
|
scheme
=
=
"
https
"
}
fn
is_bad_port
(
port
:
u16
)
-
>
bool
{
static
BAD_PORTS
:
[
u16
;
64
]
=
[
1
7
9
11
13
15
17
19
20
21
22
23
25
37
42
43
53
77
79
87
95
101
102
103
104
109
110
111
113
115
117
119
123
135
139
143
179
389
465
512
513
514
515
526
530
531
532
540
556
563
587
601
636
993
995
2049
3659
4045
6000
6665
6666
6667
6668
6669
]
;
BAD_PORTS
.
binary_search
(
&
port
)
.
is_ok
(
)
}
