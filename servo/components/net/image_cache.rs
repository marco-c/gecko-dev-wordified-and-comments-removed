use
immeta
:
:
load_from_buf
;
use
net_traits
:
:
{
FetchMetadata
FetchResponseMsg
NetworkError
}
;
use
net_traits
:
:
image
:
:
base
:
:
{
Image
ImageMetadata
PixelFormat
load_from_memory
}
;
use
net_traits
:
:
image_cache
:
:
{
CanRequestImages
ImageCache
ImageResponder
}
;
use
net_traits
:
:
image_cache
:
:
{
ImageOrMetadataAvailable
ImageResponse
ImageState
}
;
use
net_traits
:
:
image_cache
:
:
{
PendingImageId
UsePlaceholder
}
;
use
servo_config
:
:
resource_files
:
:
resources_dir_path
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
:
:
{
Occupied
Vacant
}
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
self
Read
}
;
use
std
:
:
mem
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
std
:
:
thread
;
use
webrender_api
;
fn
convert_format
(
format
:
PixelFormat
)
-
>
webrender_api
:
:
ImageFormat
{
match
format
{
PixelFormat
:
:
K8
|
PixelFormat
:
:
KA8
=
>
{
panic
!
(
"
Not
support
by
webrender
yet
"
)
;
}
PixelFormat
:
:
RGB8
=
>
webrender_api
:
:
ImageFormat
:
:
RGB8
PixelFormat
:
:
BGRA8
=
>
webrender_api
:
:
ImageFormat
:
:
BGRA8
}
}
fn
decode_bytes_sync
(
key
:
LoadKey
bytes
:
&
[
u8
]
)
-
>
DecoderMsg
{
let
image
=
load_from_memory
(
bytes
)
;
DecoderMsg
{
key
:
key
image
:
image
}
}
fn
get_placeholder_image
(
webrender_api
:
&
webrender_api
:
:
RenderApi
path
:
&
PathBuf
)
-
>
io
:
:
Result
<
Arc
<
Image
>
>
{
let
mut
file
=
File
:
:
open
(
path
)
?
;
let
mut
image_data
=
vec
!
[
]
;
file
.
read_to_end
(
&
mut
image_data
)
?
;
let
mut
image
=
load_from_memory
(
&
image_data
)
.
unwrap
(
)
;
set_webrender_image_key
(
webrender_api
&
mut
image
)
;
Ok
(
Arc
:
:
new
(
image
)
)
}
fn
set_webrender_image_key
(
webrender_api
:
&
webrender_api
:
:
RenderApi
image
:
&
mut
Image
)
{
if
image
.
id
.
is_some
(
)
{
return
;
}
let
format
=
convert_format
(
image
.
format
)
;
let
mut
bytes
=
Vec
:
:
new
(
)
;
bytes
.
extend_from_slice
(
&
*
image
.
bytes
)
;
if
format
=
=
webrender_api
:
:
ImageFormat
:
:
BGRA8
{
premultiply
(
bytes
.
as_mut_slice
(
)
)
;
}
let
descriptor
=
webrender_api
:
:
ImageDescriptor
{
width
:
image
.
width
height
:
image
.
height
stride
:
None
format
:
format
offset
:
0
is_opaque
:
is_image_opaque
(
format
&
bytes
)
}
;
let
data
=
webrender_api
:
:
ImageData
:
:
new
(
bytes
)
;
let
image_key
=
webrender_api
.
generate_image_key
(
)
;
let
mut
updates
=
webrender_api
:
:
ResourceUpdates
:
:
new
(
)
;
updates
.
add_image
(
image_key
descriptor
data
None
)
;
webrender_api
.
update_resources
(
updates
)
;
image
.
id
=
Some
(
image_key
)
;
}
fn
is_image_opaque
(
format
:
webrender_api
:
:
ImageFormat
bytes
:
&
[
u8
]
)
-
>
bool
{
match
format
{
webrender_api
:
:
ImageFormat
:
:
BGRA8
=
>
{
let
mut
is_opaque
=
true
;
for
i
in
0
.
.
(
bytes
.
len
(
)
/
4
)
{
if
bytes
[
i
*
4
+
3
]
!
=
255
{
is_opaque
=
false
;
break
;
}
}
is_opaque
}
webrender_api
:
:
ImageFormat
:
:
RGB8
=
>
true
webrender_api
:
:
ImageFormat
:
:
RG8
=
>
true
webrender_api
:
:
ImageFormat
:
:
A8
=
>
false
webrender_api
:
:
ImageFormat
:
:
Invalid
|
webrender_api
:
:
ImageFormat
:
:
RGBAF32
=
>
unreachable
!
(
)
}
}
fn
premultiply
(
data
:
&
mut
[
u8
]
)
{
let
length
=
data
.
len
(
)
;
for
i
in
Iterator
:
:
step_by
(
0
.
.
length
4
)
{
let
b
=
data
[
i
+
0
]
as
u32
;
let
g
=
data
[
i
+
1
]
as
u32
;
let
r
=
data
[
i
+
2
]
as
u32
;
let
a
=
data
[
i
+
3
]
as
u32
;
data
[
i
+
0
]
=
(
b
*
a
/
255
)
as
u8
;
data
[
i
+
1
]
=
(
g
*
a
/
255
)
as
u8
;
data
[
i
+
2
]
=
(
r
*
a
/
255
)
as
u8
;
}
}
struct
AllPendingLoads
{
loads
:
HashMap
<
LoadKey
PendingLoad
>
url_to_load_key
:
HashMap
<
ServoUrl
LoadKey
>
keygen
:
LoadKeyGenerator
}
impl
AllPendingLoads
{
fn
new
(
)
-
>
AllPendingLoads
{
AllPendingLoads
{
loads
:
HashMap
:
:
new
(
)
url_to_load_key
:
HashMap
:
:
new
(
)
keygen
:
LoadKeyGenerator
:
:
new
(
)
}
}
fn
get_by_key_mut
(
&
mut
self
key
:
&
LoadKey
)
-
>
Option
<
&
mut
PendingLoad
>
{
self
.
loads
.
get_mut
(
key
)
}
fn
remove
(
&
mut
self
key
:
&
LoadKey
)
-
>
Option
<
PendingLoad
>
{
self
.
loads
.
remove
(
key
)
.
and_then
(
|
pending_load
|
{
self
.
url_to_load_key
.
remove
(
&
pending_load
.
url
)
.
unwrap
(
)
;
Some
(
pending_load
)
}
)
}
fn
get_cached
<
'
a
>
(
&
'
a
mut
self
url
:
ServoUrl
can_request
:
CanRequestImages
)
-
>
CacheResult
<
'
a
>
{
match
self
.
url_to_load_key
.
entry
(
url
.
clone
(
)
)
{
Occupied
(
url_entry
)
=
>
{
let
load_key
=
url_entry
.
get
(
)
;
CacheResult
:
:
Hit
(
*
load_key
self
.
loads
.
get_mut
(
load_key
)
.
unwrap
(
)
)
}
Vacant
(
url_entry
)
=
>
{
if
can_request
=
=
CanRequestImages
:
:
No
{
return
CacheResult
:
:
Miss
(
None
)
;
}
let
load_key
=
self
.
keygen
.
next
(
)
;
url_entry
.
insert
(
load_key
)
;
let
pending_load
=
PendingLoad
:
:
new
(
url
)
;
match
self
.
loads
.
entry
(
load_key
)
{
Occupied
(
_
)
=
>
unreachable
!
(
)
Vacant
(
load_entry
)
=
>
{
let
mut_load
=
load_entry
.
insert
(
pending_load
)
;
CacheResult
:
:
Miss
(
Some
(
(
load_key
mut_load
)
)
)
}
}
}
}
}
}
enum
CacheResult
<
'
a
>
{
Hit
(
LoadKey
&
'
a
mut
PendingLoad
)
Miss
(
Option
<
(
LoadKey
&
'
a
mut
PendingLoad
)
>
)
}
struct
CompletedLoad
{
image_response
:
ImageResponse
id
:
PendingImageId
}
impl
CompletedLoad
{
fn
new
(
image_response
:
ImageResponse
id
:
PendingImageId
)
-
>
CompletedLoad
{
CompletedLoad
{
image_response
:
image_response
id
:
id
}
}
}
struct
DecoderMsg
{
key
:
LoadKey
image
:
Option
<
Image
>
}
enum
ImageBytes
{
InProgress
(
Vec
<
u8
>
)
Complete
(
Arc
<
Vec
<
u8
>
>
)
}
impl
ImageBytes
{
fn
extend_from_slice
(
&
mut
self
data
:
&
[
u8
]
)
{
match
*
self
{
ImageBytes
:
:
InProgress
(
ref
mut
bytes
)
=
>
bytes
.
extend_from_slice
(
data
)
ImageBytes
:
:
Complete
(
_
)
=
>
panic
!
(
"
attempted
modification
of
complete
image
bytes
"
)
}
}
fn
mark_complete
(
&
mut
self
)
-
>
Arc
<
Vec
<
u8
>
>
{
let
bytes
=
{
let
own_bytes
=
match
*
self
{
ImageBytes
:
:
InProgress
(
ref
mut
bytes
)
=
>
bytes
ImageBytes
:
:
Complete
(
_
)
=
>
panic
!
(
"
attempted
modification
of
complete
image
bytes
"
)
}
;
mem
:
:
replace
(
own_bytes
vec
!
[
]
)
}
;
let
bytes
=
Arc
:
:
new
(
bytes
)
;
*
self
=
ImageBytes
:
:
Complete
(
bytes
.
clone
(
)
)
;
bytes
}
fn
as_slice
(
&
self
)
-
>
&
[
u8
]
{
match
*
self
{
ImageBytes
:
:
InProgress
(
ref
bytes
)
=
>
&
bytes
ImageBytes
:
:
Complete
(
ref
bytes
)
=
>
&
*
bytes
}
}
}
type
LoadKey
=
PendingImageId
;
struct
LoadKeyGenerator
{
counter
:
u64
}
impl
LoadKeyGenerator
{
fn
new
(
)
-
>
LoadKeyGenerator
{
LoadKeyGenerator
{
counter
:
0
}
}
fn
next
(
&
mut
self
)
-
>
PendingImageId
{
self
.
counter
+
=
1
;
PendingImageId
(
self
.
counter
)
}
}
enum
LoadResult
{
Loaded
(
Image
)
PlaceholderLoaded
(
Arc
<
Image
>
)
None
}
struct
PendingLoad
{
bytes
:
ImageBytes
metadata
:
Option
<
ImageMetadata
>
result
:
Option
<
Result
<
(
)
NetworkError
>
>
listeners
:
Vec
<
ImageResponder
>
url
:
ServoUrl
final_url
:
Option
<
ServoUrl
>
}
impl
PendingLoad
{
fn
new
(
url
:
ServoUrl
)
-
>
PendingLoad
{
PendingLoad
{
bytes
:
ImageBytes
:
:
InProgress
(
vec
!
(
)
)
metadata
:
None
result
:
None
listeners
:
vec
!
(
)
url
:
url
final_url
:
None
}
}
fn
add_listener
(
&
mut
self
listener
:
ImageResponder
)
{
self
.
listeners
.
push
(
listener
)
;
}
}
struct
ImageCacheStore
{
pending_loads
:
AllPendingLoads
completed_loads
:
HashMap
<
ServoUrl
CompletedLoad
>
placeholder_image
:
Option
<
Arc
<
Image
>
>
placeholder_url
:
ServoUrl
webrender_api
:
webrender_api
:
:
RenderApi
}
impl
ImageCacheStore
{
fn
complete_load
(
&
mut
self
key
:
LoadKey
mut
load_result
:
LoadResult
)
{
let
pending_load
=
match
self
.
pending_loads
.
remove
(
&
key
)
{
Some
(
load
)
=
>
load
None
=
>
return
}
;
match
load_result
{
LoadResult
:
:
Loaded
(
ref
mut
image
)
=
>
set_webrender_image_key
(
&
self
.
webrender_api
image
)
LoadResult
:
:
PlaceholderLoaded
(
.
.
)
|
LoadResult
:
:
None
=
>
{
}
}
let
url
=
pending_load
.
final_url
.
clone
(
)
;
let
image_response
=
match
load_result
{
LoadResult
:
:
Loaded
(
image
)
=
>
ImageResponse
:
:
Loaded
(
Arc
:
:
new
(
image
)
url
.
unwrap
(
)
)
LoadResult
:
:
PlaceholderLoaded
(
image
)
=
>
ImageResponse
:
:
PlaceholderLoaded
(
image
self
.
placeholder_url
.
clone
(
)
)
LoadResult
:
:
None
=
>
ImageResponse
:
:
None
}
;
let
completed_load
=
CompletedLoad
:
:
new
(
image_response
.
clone
(
)
key
)
;
self
.
completed_loads
.
insert
(
pending_load
.
url
.
into
(
)
completed_load
)
;
for
listener
in
pending_load
.
listeners
{
listener
.
respond
(
image_response
.
clone
(
)
)
;
}
}
fn
get_completed_image_if_available
(
&
self
url
:
&
ServoUrl
placeholder
:
UsePlaceholder
)
-
>
Option
<
Result
<
ImageOrMetadataAvailable
ImageState
>
>
{
self
.
completed_loads
.
get
(
url
)
.
map
(
|
completed_load
|
{
match
(
&
completed_load
.
image_response
placeholder
)
{
(
&
ImageResponse
:
:
Loaded
(
ref
image
ref
url
)
_
)
|
(
&
ImageResponse
:
:
PlaceholderLoaded
(
ref
image
ref
url
)
UsePlaceholder
:
:
Yes
)
=
>
{
Ok
(
ImageOrMetadataAvailable
:
:
ImageAvailable
(
image
.
clone
(
)
url
.
clone
(
)
)
)
}
(
&
ImageResponse
:
:
PlaceholderLoaded
(
_
_
)
UsePlaceholder
:
:
No
)
|
(
&
ImageResponse
:
:
None
_
)
|
(
&
ImageResponse
:
:
MetadataLoaded
(
_
)
_
)
=
>
{
Err
(
ImageState
:
:
LoadError
)
}
}
}
)
}
fn
handle_decoder
(
&
mut
self
msg
:
DecoderMsg
)
{
let
image
=
match
msg
.
image
{
None
=
>
LoadResult
:
:
None
Some
(
image
)
=
>
LoadResult
:
:
Loaded
(
image
)
}
;
self
.
complete_load
(
msg
.
key
image
)
;
}
}
pub
struct
ImageCacheImpl
{
store
:
Arc
<
Mutex
<
ImageCacheStore
>
>
}
impl
ImageCache
for
ImageCacheImpl
{
fn
new
(
webrender_api
:
webrender_api
:
:
RenderApi
)
-
>
ImageCacheImpl
{
debug
!
(
"
New
image
cache
"
)
;
let
mut
placeholder_path
=
resources_dir_path
(
)
.
expect
(
"
Can
'
t
figure
out
resources
path
.
"
)
;
placeholder_path
.
push
(
"
rippy
.
png
"
)
;
ImageCacheImpl
{
store
:
Arc
:
:
new
(
Mutex
:
:
new
(
ImageCacheStore
{
pending_loads
:
AllPendingLoads
:
:
new
(
)
completed_loads
:
HashMap
:
:
new
(
)
placeholder_image
:
get_placeholder_image
(
&
webrender_api
&
placeholder_path
)
.
ok
(
)
placeholder_url
:
ServoUrl
:
:
from_file_path
(
&
placeholder_path
)
.
unwrap
(
)
webrender_api
:
webrender_api
}
)
)
}
}
fn
find_image_or_metadata
(
&
self
url
:
ServoUrl
use_placeholder
:
UsePlaceholder
can_request
:
CanRequestImages
)
-
>
Result
<
ImageOrMetadataAvailable
ImageState
>
{
debug
!
(
"
Find
image
or
metadata
for
{
}
"
url
)
;
let
mut
store
=
self
.
store
.
lock
(
)
.
unwrap
(
)
;
if
let
Some
(
result
)
=
store
.
get_completed_image_if_available
(
&
url
use_placeholder
)
{
debug
!
(
"
{
}
is
available
"
url
)
;
return
result
;
}
let
decoded
=
{
let
result
=
store
.
pending_loads
.
get_cached
(
url
.
clone
(
)
can_request
)
;
match
result
{
CacheResult
:
:
Hit
(
key
pl
)
=
>
match
(
&
pl
.
result
&
pl
.
metadata
)
{
(
&
Some
(
Ok
(
_
)
)
_
)
=
>
{
debug
!
(
"
Sync
decoding
{
}
(
{
:
?
}
)
"
url
key
)
;
decode_bytes_sync
(
key
&
pl
.
bytes
.
as_slice
(
)
)
}
(
&
None
&
Some
(
ref
meta
)
)
=
>
{
debug
!
(
"
Metadata
available
for
{
}
(
{
:
?
}
)
"
url
key
)
;
return
Ok
(
ImageOrMetadataAvailable
:
:
MetadataAvailable
(
meta
.
clone
(
)
)
)
}
(
&
Some
(
Err
(
_
)
)
_
)
|
(
&
None
&
None
)
=
>
{
debug
!
(
"
{
}
(
{
:
?
}
)
is
still
pending
"
url
key
)
;
return
Err
(
ImageState
:
:
Pending
(
key
)
)
;
}
}
CacheResult
:
:
Miss
(
Some
(
(
key
_pl
)
)
)
=
>
{
debug
!
(
"
Should
be
requesting
{
}
(
{
:
?
}
)
"
url
key
)
;
return
Err
(
ImageState
:
:
NotRequested
(
key
)
)
;
}
CacheResult
:
:
Miss
(
None
)
=
>
{
debug
!
(
"
Couldn
'
t
find
an
entry
for
{
}
"
url
)
;
return
Err
(
ImageState
:
:
LoadError
)
;
}
}
}
;
store
.
handle_decoder
(
decoded
)
;
match
store
.
get_completed_image_if_available
(
&
url
use_placeholder
)
{
Some
(
result
)
=
>
result
None
=
>
Err
(
ImageState
:
:
LoadError
)
}
}
fn
add_listener
(
&
self
id
:
PendingImageId
listener
:
ImageResponder
)
{
let
mut
store
=
self
.
store
.
lock
(
)
.
unwrap
(
)
;
if
let
Some
(
load
)
=
store
.
pending_loads
.
get_by_key_mut
(
&
id
)
{
if
let
Some
(
ref
metadata
)
=
load
.
metadata
{
listener
.
respond
(
ImageResponse
:
:
MetadataLoaded
(
metadata
.
clone
(
)
)
)
;
}
load
.
add_listener
(
listener
)
;
return
;
}
if
let
Some
(
load
)
=
store
.
completed_loads
.
values
(
)
.
find
(
|
l
|
l
.
id
=
=
id
)
{
listener
.
respond
(
load
.
image_response
.
clone
(
)
)
;
return
;
}
warn
!
(
"
Couldn
'
t
find
cached
entry
for
listener
{
:
?
}
"
id
)
;
}
fn
notify_pending_response
(
&
self
id
:
PendingImageId
action
:
FetchResponseMsg
)
{
match
(
action
id
)
{
(
FetchResponseMsg
:
:
ProcessRequestBody
_
)
|
(
FetchResponseMsg
:
:
ProcessRequestEOF
_
)
=
>
return
(
FetchResponseMsg
:
:
ProcessResponse
(
response
)
_
)
=
>
{
let
mut
store
=
self
.
store
.
lock
(
)
.
unwrap
(
)
;
let
pending_load
=
store
.
pending_loads
.
get_by_key_mut
(
&
id
)
.
unwrap
(
)
;
let
metadata
=
match
response
{
Ok
(
meta
)
=
>
{
Some
(
match
meta
{
FetchMetadata
:
:
Unfiltered
(
m
)
=
>
m
FetchMetadata
:
:
Filtered
{
unsafe_
.
.
}
=
>
unsafe_
}
)
}
Err
(
_
)
=
>
None
}
;
let
final_url
=
metadata
.
as_ref
(
)
.
map
(
|
m
|
m
.
final_url
.
clone
(
)
)
;
pending_load
.
final_url
=
final_url
;
}
(
FetchResponseMsg
:
:
ProcessResponseChunk
(
data
)
_
)
=
>
{
debug
!
(
"
Got
some
data
for
{
:
?
}
"
id
)
;
let
mut
store
=
self
.
store
.
lock
(
)
.
unwrap
(
)
;
let
pending_load
=
store
.
pending_loads
.
get_by_key_mut
(
&
id
)
.
unwrap
(
)
;
pending_load
.
bytes
.
extend_from_slice
(
&
data
)
;
if
let
None
=
pending_load
.
metadata
{
if
let
Ok
(
metadata
)
=
load_from_buf
(
&
pending_load
.
bytes
.
as_slice
(
)
)
{
let
dimensions
=
metadata
.
dimensions
(
)
;
let
img_metadata
=
ImageMetadata
{
width
:
dimensions
.
width
height
:
dimensions
.
height
}
;
for
listener
in
&
pending_load
.
listeners
{
listener
.
respond
(
ImageResponse
:
:
MetadataLoaded
(
img_metadata
.
clone
(
)
)
)
;
}
pending_load
.
metadata
=
Some
(
img_metadata
)
;
}
}
}
(
FetchResponseMsg
:
:
ProcessResponseEOF
(
result
)
key
)
=
>
{
debug
!
(
"
Received
EOF
for
{
:
?
}
"
key
)
;
match
result
{
Ok
(
(
)
)
=
>
{
let
bytes
=
{
let
mut
store
=
self
.
store
.
lock
(
)
.
unwrap
(
)
;
let
pending_load
=
store
.
pending_loads
.
get_by_key_mut
(
&
id
)
.
unwrap
(
)
;
pending_load
.
result
=
Some
(
result
)
;
debug
!
(
"
Async
decoding
{
}
(
{
:
?
}
)
"
pending_load
.
url
key
)
;
pending_load
.
bytes
.
mark_complete
(
)
}
;
let
local_store
=
self
.
store
.
clone
(
)
;
thread
:
:
spawn
(
move
|
|
{
let
msg
=
decode_bytes_sync
(
key
&
*
bytes
)
;
debug
!
(
"
Image
decoded
"
)
;
local_store
.
lock
(
)
.
unwrap
(
)
.
handle_decoder
(
msg
)
;
}
)
;
}
Err
(
_
)
=
>
{
debug
!
(
"
Processing
error
for
{
:
?
}
"
key
)
;
let
mut
store
=
self
.
store
.
lock
(
)
.
unwrap
(
)
;
match
store
.
placeholder_image
.
clone
(
)
{
Some
(
placeholder_image
)
=
>
{
store
.
complete_load
(
id
LoadResult
:
:
PlaceholderLoaded
(
placeholder_image
)
)
}
None
=
>
store
.
complete_load
(
id
LoadResult
:
:
None
)
}
}
}
}
}
}
fn
set_webrender_image_key
(
&
self
image
:
&
mut
Image
)
{
set_webrender_image_key
(
&
self
.
store
.
lock
(
)
.
unwrap
(
)
.
webrender_api
image
)
;
}
}
