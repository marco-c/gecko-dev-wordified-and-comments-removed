#
!
[
feature
(
start
)
]
#
[
cfg
(
target_os
=
"
android
"
)
]
#
[
macro_use
]
extern
crate
android_glue
;
extern
crate
glutin_app
as
app
;
extern
crate
env_logger
;
#
[
cfg
(
target_os
=
"
android
"
)
]
extern
crate
libc
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
servo
;
extern
crate
time
;
extern
crate
gleam
;
extern
crate
offscreen_gl_context
;
use
gleam
:
:
gl
;
use
offscreen_gl_context
:
:
GLContext
;
use
servo
:
:
Browser
;
use
servo
:
:
compositing
:
:
windowing
:
:
WindowEvent
;
use
servo
:
:
net_traits
:
:
hosts
;
use
servo
:
:
util
:
:
opts
;
use
std
:
:
rc
:
:
Rc
;
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
fn
load_gl_when_headless
(
)
{
gl
:
:
load_with
(
|
addr
|
GLContext
:
:
get_proc_address
(
addr
)
as
*
const
_
)
;
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
load_gl_when_headless
(
)
{
}
fn
main
(
)
{
env_logger
:
:
init
(
)
.
unwrap
(
)
;
opts
:
:
from_cmdline_args
(
&
*
args
(
)
)
;
setup_logging
(
)
;
hosts
:
:
global_init
(
)
;
let
window
=
if
opts
:
:
get
(
)
.
headless
{
load_gl_when_headless
(
)
;
None
}
else
{
Some
(
app
:
:
create_window
(
std
:
:
ptr
:
:
null_mut
(
)
)
)
}
;
let
mut
browser
=
BrowserWrapper
{
browser
:
Browser
:
:
new
(
window
.
clone
(
)
)
}
;
maybe_register_glutin_resize_handler
(
&
window
&
mut
browser
)
;
browser
.
browser
.
handle_events
(
vec
!
[
WindowEvent
:
:
InitializeCompositing
]
)
;
loop
{
let
should_continue
=
match
window
{
None
=
>
browser
.
browser
.
handle_events
(
Vec
:
:
new
(
)
)
Some
(
ref
window
)
=
>
browser
.
browser
.
handle_events
(
window
.
wait_events
(
)
)
}
;
if
!
should_continue
{
break
}
}
;
maybe_unregister_glutin_resize_handler
(
&
window
)
;
}
fn
maybe_register_glutin_resize_handler
(
window
:
&
Option
<
Rc
<
app
:
:
window
:
:
Window
>
>
browser
:
&
mut
BrowserWrapper
)
{
match
*
window
{
None
=
>
{
}
Some
(
ref
window
)
=
>
{
unsafe
{
window
.
set_nested_event_loop_listener
(
browser
)
;
}
}
}
}
fn
maybe_unregister_glutin_resize_handler
(
window
:
&
Option
<
Rc
<
app
:
:
window
:
:
Window
>
>
)
{
match
*
window
{
None
=
>
{
}
Some
(
ref
window
)
=
>
{
unsafe
{
window
.
remove_nested_event_loop_listener
(
)
;
}
}
}
}
struct
BrowserWrapper
{
browser
:
Browser
}
impl
app
:
:
NestedEventLoopListener
for
BrowserWrapper
{
fn
handle_event_from_nested_event_loop
(
&
mut
self
event
:
WindowEvent
)
-
>
bool
{
let
is_resize
=
match
event
{
WindowEvent
:
:
Resize
(
.
.
)
=
>
true
_
=
>
false
}
;
if
!
self
.
browser
.
handle_events
(
vec
!
[
event
]
)
{
return
false
}
if
is_resize
{
self
.
browser
.
repaint_synchronously
(
)
}
true
}
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
setup_logging
(
)
{
android
:
:
setup_logging
(
)
;
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
fn
setup_logging
(
)
{
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
args
(
)
-
>
Vec
<
String
>
{
use
std
:
:
error
:
:
Error
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
BufRead
BufReader
}
;
const
PARAMS_FILE
:
&
'
static
str
=
"
/
sdcard
/
servo
/
android_params
"
;
match
File
:
:
open
(
PARAMS_FILE
)
{
Ok
(
f
)
=
>
{
let
mut
vec
=
Vec
:
:
new
(
)
;
let
file
=
BufReader
:
:
new
(
&
f
)
;
for
line
in
file
.
lines
(
)
{
let
l
=
line
.
unwrap
(
)
.
trim
(
)
.
to_owned
(
)
;
match
l
.
is_empty
(
)
|
|
l
.
as_bytes
(
)
[
0
]
=
=
b
'
#
'
{
true
=
>
(
)
false
=
>
vec
.
push
(
l
)
}
}
vec
}
Err
(
e
)
=
>
{
debug
!
(
"
Failed
to
open
params
file
'
{
}
'
:
{
}
"
PARAMS_FILE
Error
:
:
description
(
&
e
)
)
;
vec
!
[
"
servo
"
.
to_owned
(
)
"
http
:
/
/
en
.
wikipedia
.
org
/
wiki
/
Rust
"
.
to_owned
(
)
]
}
}
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
fn
args
(
)
-
>
Vec
<
String
>
{
use
std
:
:
env
;
env
:
:
args
(
)
.
collect
(
)
}
#
[
cfg
(
target_os
=
"
android
"
)
]
extern
{
fn
app_dummy
(
)
-
>
libc
:
:
c_void
;
}
#
[
cfg
(
target_os
=
"
android
"
)
]
android_start
!
(
main
)
;
#
[
cfg
(
target_os
=
"
android
"
)
]
mod
android
{
extern
crate
libc
;
extern
crate
android_glue
;
use
self
:
:
libc
:
:
c_int
;
use
std
:
:
borrow
:
:
ToOwned
;
pub
fn
setup_logging
(
)
{
use
self
:
:
libc
:
:
consts
:
:
os
:
:
posix88
:
:
{
STDERR_FILENO
STDOUT_FILENO
}
;
redirect_output
(
STDERR_FILENO
)
;
redirect_output
(
STDOUT_FILENO
)
;
unsafe
{
super
:
:
app_dummy
(
)
;
}
}
struct
FilePtr
(
*
mut
self
:
:
libc
:
:
types
:
:
common
:
:
c95
:
:
FILE
)
;
unsafe
impl
Send
for
FilePtr
{
}
fn
redirect_output
(
file_no
:
c_int
)
{
use
self
:
:
libc
:
:
funcs
:
:
c95
:
:
stdio
:
:
fgets
;
use
self
:
:
libc
:
:
funcs
:
:
posix88
:
:
stdio
:
:
fdopen
;
use
self
:
:
libc
:
:
funcs
:
:
posix88
:
:
unistd
:
:
{
pipe
dup2
}
;
use
servo
:
:
util
:
:
task
:
:
spawn_named
;
use
std
:
:
ffi
:
:
CStr
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
str
:
:
from_utf8
;
unsafe
{
let
mut
pipes
:
[
c_int
;
2
]
=
[
0
0
]
;
pipe
(
pipes
.
as_mut_ptr
(
)
)
;
dup2
(
pipes
[
1
]
file_no
)
;
let
mode
=
CString
:
:
new
(
"
r
"
)
.
unwrap
(
)
;
let
input_file
=
FilePtr
(
fdopen
(
pipes
[
0
]
mode
.
as_ptr
(
)
)
)
;
spawn_named
(
"
android
-
logger
"
.
to_owned
(
)
move
|
|
{
static
READ_SIZE
:
usize
=
1024
;
let
mut
read_buffer
=
vec
!
[
0
;
READ_SIZE
]
;
let
FilePtr
(
input_file
)
=
input_file
;
loop
{
fgets
(
read_buffer
.
as_mut_ptr
(
)
(
read_buffer
.
len
(
)
as
i32
)
-
1
input_file
)
;
let
c_str
=
CStr
:
:
from_ptr
(
read_buffer
.
as_ptr
(
)
)
;
let
slice
=
from_utf8
(
c_str
.
to_bytes
(
)
)
.
unwrap
(
)
;
android_glue
:
:
write_log
(
slice
)
;
}
}
)
;
}
}
}
