use
:
:
gl_context
:
:
GLContextFactory
;
use
:
:
webgl_thread
:
:
{
WebGLExternalImageApi
WebGLExternalImageHandler
WebGLThreadObserver
WebGLThread
}
;
use
canvas_traits
:
:
webgl
:
:
{
WebGLChan
WebGLContextId
WebGLMsg
WebGLPipeline
WebGLReceiver
}
;
use
canvas_traits
:
:
webgl
:
:
{
WebGLSender
WebVRCommand
WebVRRenderHandler
}
;
use
canvas_traits
:
:
webgl
:
:
DOMToTextureCommand
;
use
canvas_traits
:
:
webgl
:
:
webgl_channel
;
use
euclid
:
:
Size2D
;
use
fnv
:
:
FnvHashMap
;
use
gleam
:
:
gl
;
use
servo_config
:
:
prefs
:
:
PREFS
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
rc
:
:
Rc
;
use
webrender
;
use
webrender_api
;
pub
struct
WebGLThreads
(
WebGLSender
<
WebGLMsg
>
)
;
impl
WebGLThreads
{
pub
fn
new
(
gl_factory
:
GLContextFactory
webrender_gl
:
Rc
<
gl
:
:
Gl
>
webrender_api_sender
:
webrender_api
:
:
RenderApiSender
webvr_compositor
:
Option
<
Box
<
WebVRRenderHandler
>
>
)
-
>
(
WebGLThreads
Box
<
webrender
:
:
ExternalImageHandler
>
Option
<
Box
<
webrender
:
:
OutputImageHandler
>
>
)
{
let
channel
=
WebGLThread
:
:
start
(
gl_factory
webrender_api_sender
webvr_compositor
.
map
(
|
c
|
WebVRRenderWrapper
(
c
)
)
PhantomData
)
;
let
output_handler
=
if
PREFS
.
is_dom_to_texture_enabled
(
)
{
Some
(
Box
:
:
new
(
OutputHandler
:
:
new
(
webrender_gl
.
clone
(
)
channel
.
clone
(
)
)
)
)
}
else
{
None
}
;
let
external
=
WebGLExternalImageHandler
:
:
new
(
WebGLExternalImages
:
:
new
(
webrender_gl
channel
.
clone
(
)
)
)
;
(
WebGLThreads
(
channel
)
Box
:
:
new
(
external
)
output_handler
.
map
(
|
b
|
b
as
Box
<
_
>
)
)
}
pub
fn
pipeline
(
&
self
)
-
>
WebGLPipeline
{
WebGLPipeline
(
WebGLChan
(
self
.
0
.
clone
(
)
)
)
}
pub
fn
exit
(
&
self
)
-
>
Result
<
(
)
&
'
static
str
>
{
self
.
0
.
send
(
WebGLMsg
:
:
Exit
)
.
map_err
(
|
_
|
"
Failed
to
send
Exit
message
"
)
}
}
struct
WebGLExternalImages
{
webrender_gl
:
Rc
<
gl
:
:
Gl
>
webgl_channel
:
WebGLSender
<
WebGLMsg
>
lock_channel
:
(
WebGLSender
<
(
u32
Size2D
<
i32
>
usize
)
>
WebGLReceiver
<
(
u32
Size2D
<
i32
>
usize
)
>
)
}
impl
WebGLExternalImages
{
fn
new
(
webrender_gl
:
Rc
<
gl
:
:
Gl
>
channel
:
WebGLSender
<
WebGLMsg
>
)
-
>
Self
{
Self
{
webrender_gl
webgl_channel
:
channel
lock_channel
:
webgl_channel
(
)
.
unwrap
(
)
}
}
}
impl
WebGLExternalImageApi
for
WebGLExternalImages
{
fn
lock
(
&
mut
self
ctx_id
:
WebGLContextId
)
-
>
(
u32
Size2D
<
i32
>
)
{
self
.
webgl_channel
.
send
(
WebGLMsg
:
:
Lock
(
ctx_id
self
.
lock_channel
.
0
.
clone
(
)
)
)
.
unwrap
(
)
;
let
(
image_id
size
gl_sync
)
=
self
.
lock_channel
.
1
.
recv
(
)
.
unwrap
(
)
;
self
.
webrender_gl
.
wait_sync
(
gl_sync
as
gl
:
:
GLsync
0
gl
:
:
TIMEOUT_IGNORED
)
;
(
image_id
size
)
}
fn
unlock
(
&
mut
self
ctx_id
:
WebGLContextId
)
{
self
.
webgl_channel
.
send
(
WebGLMsg
:
:
Unlock
(
ctx_id
)
)
.
unwrap
(
)
;
}
}
impl
WebGLThreadObserver
for
PhantomData
<
(
)
>
{
fn
on_context_create
(
&
mut
self
ctx_id
:
WebGLContextId
texture_id
:
u32
size
:
Size2D
<
i32
>
)
{
debug
!
(
"
WebGLContext
created
(
ctx_id
:
{
:
?
}
texture_id
:
{
:
?
}
size
:
{
:
?
}
"
ctx_id
texture_id
size
)
;
}
fn
on_context_resize
(
&
mut
self
ctx_id
:
WebGLContextId
texture_id
:
u32
size
:
Size2D
<
i32
>
)
{
debug
!
(
"
WebGLContext
resized
(
ctx_id
:
{
:
?
}
texture_id
:
{
:
?
}
size
:
{
:
?
}
"
ctx_id
texture_id
size
)
;
}
fn
on_context_delete
(
&
mut
self
ctx_id
:
WebGLContextId
)
{
debug
!
(
"
WebGLContext
deleted
(
ctx_id
:
{
:
?
}
)
"
ctx_id
)
;
}
}
struct
WebVRRenderWrapper
(
Box
<
WebVRRenderHandler
>
)
;
impl
WebVRRenderHandler
for
WebVRRenderWrapper
{
fn
handle
(
&
mut
self
command
:
WebVRCommand
texture
:
Option
<
(
u32
Size2D
<
i32
>
)
>
)
{
self
.
0
.
handle
(
command
texture
)
;
}
}
type
OutputHandlerData
=
Option
<
(
u32
Size2D
<
i32
>
)
>
;
struct
OutputHandler
{
webrender_gl
:
Rc
<
gl
:
:
Gl
>
webgl_channel
:
WebGLSender
<
WebGLMsg
>
lock_channel
:
(
WebGLSender
<
OutputHandlerData
>
WebGLReceiver
<
OutputHandlerData
>
)
sync_objects
:
FnvHashMap
<
webrender_api
:
:
PipelineId
gl
:
:
GLsync
>
}
impl
OutputHandler
{
fn
new
(
webrender_gl
:
Rc
<
gl
:
:
Gl
>
channel
:
WebGLSender
<
WebGLMsg
>
)
-
>
Self
{
Self
{
webrender_gl
webgl_channel
:
channel
lock_channel
:
webgl_channel
(
)
.
unwrap
(
)
sync_objects
:
Default
:
:
default
(
)
}
}
}
impl
webrender
:
:
OutputImageHandler
for
OutputHandler
{
fn
lock
(
&
mut
self
id
:
webrender_api
:
:
PipelineId
)
-
>
Option
<
(
u32
webrender_api
:
:
DeviceIntSize
)
>
{
let
gl_sync
=
self
.
webrender_gl
.
fence_sync
(
gl
:
:
SYNC_GPU_COMMANDS_COMPLETE
0
)
;
let
command
=
DOMToTextureCommand
:
:
Lock
(
id
gl_sync
as
usize
self
.
lock_channel
.
0
.
clone
(
)
)
;
self
.
webgl_channel
.
send
(
WebGLMsg
:
:
DOMToTextureCommand
(
command
)
)
.
unwrap
(
)
;
self
.
lock_channel
.
1
.
recv
(
)
.
unwrap
(
)
.
map
(
|
(
tex_id
size
)
|
{
(
tex_id
webrender_api
:
:
DeviceIntSize
:
:
new
(
size
.
width
size
.
height
)
)
}
)
}
fn
unlock
(
&
mut
self
id
:
webrender_api
:
:
PipelineId
)
{
if
let
Some
(
gl_sync
)
=
self
.
sync_objects
.
remove
(
&
id
)
{
self
.
webrender_gl
.
flush
(
)
;
self
.
webrender_gl
.
delete_sync
(
gl_sync
)
;
}
}
}
