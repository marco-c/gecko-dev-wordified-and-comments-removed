use
actor
:
:
{
Actor
ActorMessageStatus
ActorRegistry
}
;
use
actors
:
:
tab
:
:
{
TabActor
TabActorMsg
}
;
use
protocol
:
:
JsonPacketStream
;
use
serde_json
:
:
Value
;
use
std
:
:
collections
:
:
BTreeMap
;
use
std
:
:
net
:
:
TcpStream
;
#
[
derive
(
Serialize
)
]
struct
ActorTraits
{
sources
:
bool
highlightable
:
bool
customHighlighters
:
Vec
<
String
>
}
#
[
derive
(
Serialize
)
]
struct
ListAddonsReply
{
from
:
String
addons
:
Vec
<
AddonMsg
>
}
#
[
derive
(
Serialize
)
]
enum
AddonMsg
{
}
#
[
derive
(
Serialize
)
]
struct
ListTabsReply
{
from
:
String
selected
:
u32
tabs
:
Vec
<
TabActorMsg
>
}
#
[
derive
(
Serialize
)
]
pub
struct
RootActorMsg
{
from
:
String
applicationType
:
String
traits
:
ActorTraits
}
pub
struct
RootActor
{
pub
tabs
:
Vec
<
String
>
}
impl
Actor
for
RootActor
{
fn
name
(
&
self
)
-
>
String
{
"
root
"
.
to_owned
(
)
}
fn
handle_message
(
&
self
registry
:
&
ActorRegistry
msg_type
:
&
str
_msg
:
&
BTreeMap
<
String
Value
>
stream
:
&
mut
TcpStream
)
-
>
Result
<
ActorMessageStatus
(
)
>
{
Ok
(
match
msg_type
{
"
listAddons
"
=
>
{
let
actor
=
ListAddonsReply
{
from
:
"
root
"
.
to_owned
(
)
addons
:
vec
!
[
]
}
;
stream
.
write_json_packet
(
&
actor
)
;
ActorMessageStatus
:
:
Processed
}
"
listTabs
"
=
>
{
let
actor
=
ListTabsReply
{
from
:
"
root
"
.
to_owned
(
)
selected
:
0
tabs
:
self
.
tabs
.
iter
(
)
.
map
(
|
tab
|
{
registry
.
find
:
:
<
TabActor
>
(
tab
)
.
encodable
(
)
}
)
.
collect
(
)
}
;
stream
.
write_json_packet
(
&
actor
)
;
ActorMessageStatus
:
:
Processed
}
_
=
>
ActorMessageStatus
:
:
Ignored
}
)
}
}
impl
RootActor
{
pub
fn
encodable
(
&
self
)
-
>
RootActorMsg
{
RootActorMsg
{
from
:
"
root
"
.
to_owned
(
)
applicationType
:
"
browser
"
.
to_owned
(
)
traits
:
ActorTraits
{
sources
:
true
highlightable
:
true
customHighlighters
:
vec
!
(
"
BoxModelHighlighter
"
.
to_owned
(
)
)
}
}
}
}
