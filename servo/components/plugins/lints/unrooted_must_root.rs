use
rustc
:
:
front
:
:
map
as
ast_map
;
use
rustc
:
:
lint
:
:
{
LateContext
LintPass
LintArray
LateLintPass
LintContext
}
;
use
rustc
:
:
middle
:
:
ty
;
use
rustc_front
:
:
{
hir
visit
}
;
use
syntax
:
:
attr
:
:
AttrMetaMethods
;
use
syntax
:
:
{
ast
codemap
}
;
use
utils
:
:
{
match_def_path
unsafe_context
in_derive_expn
}
;
declare_lint
!
(
UNROOTED_MUST_ROOT
Deny
"
Warn
and
report
usage
of
unrooted
jsmanaged
objects
"
)
;
pub
struct
UnrootedPass
{
in_new_function
:
bool
}
impl
UnrootedPass
{
pub
fn
new
(
)
-
>
UnrootedPass
{
UnrootedPass
{
in_new_function
:
true
}
}
}
fn
is_unrooted_ty
(
cx
:
&
LateContext
ty
:
&
ty
:
:
TyS
in_new_function
:
bool
)
-
>
bool
{
let
mut
ret
=
false
;
ty
.
maybe_walk
(
|
t
|
{
match
t
.
sty
{
ty
:
:
TyStruct
(
did
_
)
|
ty
:
:
TyEnum
(
did
_
)
=
>
{
if
cx
.
tcx
.
has_attr
(
did
.
did
"
must_root
"
)
{
ret
=
true
;
false
}
else
if
cx
.
tcx
.
has_attr
(
did
.
did
"
allow_unrooted_interior
"
)
{
false
}
else
if
match_def_path
(
cx
did
.
did
&
[
"
core
"
"
cell
"
"
Ref
"
]
)
|
|
match_def_path
(
cx
did
.
did
&
[
"
core
"
"
cell
"
"
RefMut
"
]
)
{
false
}
else
{
true
}
}
ty
:
:
TyBox
(
.
.
)
if
in_new_function
=
>
false
ty
:
:
TyRef
(
.
.
)
=
>
false
ty
:
:
TyRawPtr
(
.
.
)
=
>
false
_
=
>
true
}
}
)
;
ret
}
impl
LintPass
for
UnrootedPass
{
fn
get_lints
(
&
self
)
-
>
LintArray
{
lint_array
!
(
UNROOTED_MUST_ROOT
)
}
}
impl
LateLintPass
for
UnrootedPass
{
fn
check_struct_def
(
&
mut
self
cx
:
&
LateContext
def
:
&
hir
:
:
StructDef
_n
:
ast
:
:
Name
_gen
:
&
hir
:
:
Generics
id
:
ast
:
:
NodeId
)
{
let
item
=
match
cx
.
tcx
.
map
.
get
(
id
)
{
ast_map
:
:
Node
:
:
NodeItem
(
item
)
=
>
item
_
=
>
cx
.
tcx
.
map
.
expect_item
(
cx
.
tcx
.
map
.
get_parent
(
id
)
)
}
;
if
item
.
attrs
.
iter
(
)
.
all
(
|
a
|
!
a
.
check_name
(
"
must_root
"
)
)
{
for
ref
field
in
&
def
.
fields
{
if
is_unrooted_ty
(
cx
cx
.
tcx
.
node_id_to_type
(
field
.
node
.
id
)
false
)
{
cx
.
span_lint
(
UNROOTED_MUST_ROOT
field
.
span
"
Type
must
be
rooted
use
#
[
must_root
]
on
the
struct
definition
to
propagate
"
)
}
}
}
}
fn
check_variant
(
&
mut
self
cx
:
&
LateContext
var
:
&
hir
:
:
Variant
_gen
:
&
hir
:
:
Generics
)
{
let
ref
map
=
cx
.
tcx
.
map
;
if
map
.
expect_item
(
map
.
get_parent
(
var
.
node
.
id
)
)
.
attrs
.
iter
(
)
.
all
(
|
a
|
!
a
.
check_name
(
"
must_root
"
)
)
{
match
var
.
node
.
kind
{
hir
:
:
TupleVariantKind
(
ref
vec
)
=
>
{
for
ty
in
vec
{
cx
.
tcx
.
ast_ty_to_ty_cache
.
borrow
(
)
.
get
(
&
ty
.
id
)
.
map
(
|
t
|
{
if
is_unrooted_ty
(
cx
t
false
)
{
cx
.
span_lint
(
UNROOTED_MUST_ROOT
ty
.
ty
.
span
"
Type
must
be
rooted
use
#
[
must_root
]
on
\
the
enum
definition
to
propagate
"
)
}
}
)
;
}
}
_
=
>
(
)
}
}
}
fn
check_fn
(
&
mut
self
cx
:
&
LateContext
kind
:
visit
:
:
FnKind
decl
:
&
hir
:
:
FnDecl
block
:
&
hir
:
:
Block
span
:
codemap
:
:
Span
id
:
ast
:
:
NodeId
)
{
match
kind
{
visit
:
:
FnKind
:
:
ItemFn
(
n
_
_
_
_
_
)
|
visit
:
:
FnKind
:
:
Method
(
n
_
_
)
if
n
.
as_str
(
)
=
=
"
new
"
|
|
n
.
as_str
(
)
.
starts_with
(
"
new_
"
)
=
>
{
self
.
in_new_function
=
true
;
return
;
}
visit
:
:
FnKind
:
:
ItemFn
(
_
_
style
_
_
_
)
=
>
match
style
{
hir
:
:
Unsafety
:
:
Unsafe
=
>
return
_
=
>
(
)
}
_
=
>
(
)
}
self
.
in_new_function
=
false
;
if
unsafe_context
(
&
cx
.
tcx
.
map
id
)
{
return
;
}
match
block
.
rules
{
hir
:
:
DefaultBlock
=
>
{
for
arg
in
&
decl
.
inputs
{
cx
.
tcx
.
ast_ty_to_ty_cache
.
borrow
(
)
.
get
(
&
arg
.
ty
.
id
)
.
map
(
|
t
|
{
if
is_unrooted_ty
(
cx
t
false
)
{
if
in_derive_expn
(
cx
span
)
{
return
;
}
cx
.
span_lint
(
UNROOTED_MUST_ROOT
arg
.
ty
.
span
"
Type
must
be
rooted
"
)
}
}
)
;
}
if
let
hir
:
:
Return
(
ref
ty
)
=
decl
.
output
{
cx
.
tcx
.
ast_ty_to_ty_cache
.
borrow
(
)
.
get
(
&
ty
.
id
)
.
map
(
|
t
|
{
if
is_unrooted_ty
(
cx
t
false
)
{
if
in_derive_expn
(
cx
span
)
{
return
;
}
cx
.
span_lint
(
UNROOTED_MUST_ROOT
ty
.
span
"
Type
must
be
rooted
"
)
}
}
)
;
}
}
_
=
>
(
)
}
}
fn
check_expr
(
&
mut
self
cx
:
&
LateContext
expr
:
&
hir
:
:
Expr
)
{
fn
require_rooted
(
cx
:
&
LateContext
in_new_function
:
bool
subexpr
:
&
hir
:
:
Expr
)
{
let
ty
=
cx
.
tcx
.
expr_ty
(
&
*
subexpr
)
;
if
is_unrooted_ty
(
cx
ty
in_new_function
)
{
cx
.
span_lint
(
UNROOTED_MUST_ROOT
subexpr
.
span
&
format
!
(
"
Expression
of
type
{
:
?
}
must
be
rooted
"
ty
)
)
}
}
;
match
expr
.
node
{
hir
:
:
ExprCast
(
ref
subexpr
_
)
=
>
require_rooted
(
cx
self
.
in_new_function
&
*
subexpr
)
_
=
>
{
}
}
}
fn
check_stmt
(
&
mut
self
cx
:
&
LateContext
s
:
&
hir
:
:
Stmt
)
{
match
s
.
node
{
hir
:
:
StmtDecl
(
_
id
)
|
hir
:
:
StmtExpr
(
_
id
)
|
hir
:
:
StmtSemi
(
_
id
)
if
unsafe_context
(
&
cx
.
tcx
.
map
id
)
=
>
{
return
}
_
=
>
(
)
}
;
let
expr
=
match
s
.
node
{
hir
:
:
StmtDecl
(
ref
decl
_
)
=
>
match
decl
.
node
{
hir
:
:
DeclLocal
(
ref
loc
)
=
>
match
loc
.
init
{
Some
(
ref
e
)
=
>
&
*
*
e
_
=
>
return
}
_
=
>
return
}
hir
:
:
StmtExpr
(
ref
expr
_
)
=
>
match
expr
.
node
{
hir
:
:
ExprAssign
(
_
ref
e
)
|
hir
:
:
ExprMatch
(
ref
e
_
_
)
=
>
&
*
*
e
_
=
>
return
}
_
=
>
return
}
;
let
ty
=
cx
.
tcx
.
expr_ty
(
&
*
expr
)
;
if
is_unrooted_ty
(
cx
ty
self
.
in_new_function
)
{
cx
.
span_lint
(
UNROOTED_MUST_ROOT
expr
.
span
&
format
!
(
"
Expression
of
type
{
:
?
}
must
be
rooted
"
ty
)
)
}
}
}
