use
rustc
:
:
hir
:
:
def_id
:
:
DefId
;
use
rustc
:
:
hir
:
:
{
self
def
}
;
use
rustc
:
:
lint
:
:
{
LateContext
LintContext
}
;
use
syntax
:
:
ast
;
use
syntax
:
:
attr
:
:
mark_used
;
use
syntax
:
:
codemap
:
:
{
ExpnFormat
Span
}
;
use
syntax
:
:
ptr
:
:
P
;
pub
fn
match_ty_unwrap
<
'
a
>
(
ty
:
&
'
a
ast
:
:
Ty
segments
:
&
[
&
str
]
)
-
>
Option
<
&
'
a
[
P
<
ast
:
:
Ty
>
]
>
{
match
ty
.
node
{
ast
:
:
TyKind
:
:
Path
(
_
ast
:
:
Path
{
segments
:
ref
seg
.
.
}
)
=
>
{
if
seg
.
iter
(
)
.
rev
(
)
.
zip
(
segments
.
iter
(
)
.
rev
(
)
)
.
all
(
|
(
a
b
)
|
a
.
identifier
.
name
.
as_str
(
)
=
=
*
b
)
{
match
seg
.
last
(
)
{
Some
(
&
ast
:
:
PathSegment
{
parameters
:
ast
:
:
PathParameters
:
:
AngleBracketed
(
ref
a
)
.
.
}
)
=
>
{
Some
(
&
a
.
types
)
}
_
=
>
None
}
}
else
{
None
}
}
_
=
>
None
}
}
pub
fn
match_lang_ty
(
cx
:
&
LateContext
ty
:
&
hir
:
:
Ty
value
:
&
str
)
-
>
bool
{
match
ty
.
node
{
hir
:
:
TyPath
(
.
.
)
=
>
{
}
_
=
>
return
false
}
let
def
=
match
cx
.
tcx
.
def_map
.
borrow
(
)
.
get
(
&
ty
.
id
)
{
Some
(
&
def
:
:
PathResolution
{
base_def
:
def
.
.
}
)
=
>
def
_
=
>
return
false
}
;
if
let
def
:
:
Def
:
:
PrimTy
(
_
)
=
def
{
return
false
;
}
match_lang_did
(
cx
def
.
def_id
(
)
value
)
}
pub
fn
match_lang_did
(
cx
:
&
LateContext
did
:
DefId
value
:
&
str
)
-
>
bool
{
cx
.
tcx
.
get_attrs
(
did
)
.
iter
(
)
.
any
(
|
attr
|
{
match
attr
.
node
.
value
.
node
{
ast
:
:
MetaItemKind
:
:
NameValue
(
ref
name
ref
val
)
if
&
*
*
name
=
=
"
servo_lang
"
=
>
{
match
val
.
node
{
ast
:
:
LitKind
:
:
Str
(
ref
v
_
)
if
&
*
*
v
=
=
value
=
>
{
mark_used
(
attr
)
;
true
}
_
=
>
false
}
}
_
=
>
false
}
}
)
}
pub
fn
match_def_path
(
cx
:
&
LateContext
def_id
:
DefId
path
:
&
[
&
str
]
)
-
>
bool
{
let
krate
=
&
cx
.
tcx
.
crate_name
(
def_id
.
krate
)
;
if
krate
!
=
&
path
[
0
]
{
return
false
;
}
let
path
=
&
path
[
1
.
.
]
;
let
other
=
cx
.
tcx
.
def_path
(
def_id
)
.
data
;
if
other
.
len
(
)
!
=
path
.
len
(
)
{
return
false
;
}
other
.
into_iter
(
)
.
map
(
|
e
|
e
.
data
)
.
zip
(
path
)
.
all
(
|
(
nm
p
)
|
nm
.
as_interned_str
(
)
=
=
*
p
)
}
pub
fn
in_derive_expn
(
cx
:
&
LateContext
span
:
Span
)
-
>
bool
{
cx
.
sess
(
)
.
codemap
(
)
.
with_expn_info
(
span
.
expn_id
|
info
|
{
if
let
Some
(
i
)
=
info
{
if
let
ExpnFormat
:
:
MacroAttribute
(
n
)
=
i
.
callee
.
format
{
if
n
.
as_str
(
)
.
contains
(
"
derive
"
)
{
true
}
else
{
false
}
}
else
{
false
}
}
else
{
false
}
}
)
}
