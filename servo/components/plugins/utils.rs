use
rustc
:
:
lint
:
:
Context
;
use
rustc
:
:
middle
:
:
{
ty
def
}
;
use
syntax
:
:
ptr
:
:
P
;
use
syntax
:
:
{
ast
ast_map
}
;
use
syntax
:
:
ast
:
:
{
TyPath
Path
AngleBracketedParameters
PathSegment
Ty
}
;
use
syntax
:
:
attr
:
:
mark_used
;
pub
fn
match_ty_unwrap
<
'
a
>
(
ty
:
&
'
a
Ty
segments
:
&
[
&
str
]
)
-
>
Option
<
&
'
a
[
P
<
Ty
>
]
>
{
match
ty
.
node
{
TyPath
(
_
Path
{
segments
:
ref
seg
.
.
}
)
=
>
{
if
seg
.
iter
(
)
.
rev
(
)
.
zip
(
segments
.
iter
(
)
.
rev
(
)
)
.
all
(
|
(
a
b
)
|
a
.
identifier
.
as_str
(
)
=
=
*
b
)
{
match
seg
.
as_slice
(
)
.
last
(
)
{
Some
(
&
PathSegment
{
parameters
:
AngleBracketedParameters
(
ref
a
)
.
.
}
)
=
>
{
Some
(
a
.
types
.
as_slice
(
)
)
}
_
=
>
None
}
}
else
{
None
}
}
_
=
>
None
}
}
pub
fn
match_lang_ty
(
cx
:
&
Context
ty
:
&
Ty
value
:
&
str
)
-
>
bool
{
match
ty
.
node
{
TyPath
(
.
.
)
=
>
{
}
_
=
>
return
false
}
let
def_id
=
match
cx
.
tcx
.
def_map
.
borrow
(
)
.
get
(
&
ty
.
id
)
{
Some
(
&
def
:
:
PathResolution
{
base_def
:
def
:
:
DefTy
(
def_id
_
)
.
.
}
)
=
>
def_id
_
=
>
return
false
}
;
ty
:
:
get_attrs
(
cx
.
tcx
def_id
)
.
iter
(
)
.
any
(
|
attr
|
{
match
attr
.
node
.
value
.
node
{
ast
:
:
MetaNameValue
(
ref
name
ref
val
)
if
&
*
*
name
=
=
"
servo_lang
"
=
>
{
match
val
.
node
{
ast
:
:
LitStr
(
ref
v
_
)
if
&
*
*
v
=
=
value
=
>
{
mark_used
(
attr
)
;
true
}
_
=
>
false
}
}
_
=
>
false
}
}
)
}
pub
fn
unsafe_context
(
map
:
&
ast_map
:
:
Map
id
:
ast
:
:
NodeId
)
-
>
bool
{
match
map
.
find
(
map
.
get_parent
(
id
)
)
{
Some
(
ast_map
:
:
NodeImplItem
(
itm
)
)
=
>
{
match
*
itm
{
ast
:
:
MethodImplItem
(
ref
meth
)
=
>
match
meth
.
node
{
ast
:
:
MethDecl
(
_
_
_
_
style
_
_
_
)
=
>
match
style
{
ast
:
:
Unsafety
:
:
Unsafe
=
>
true
_
=
>
false
}
_
=
>
false
}
_
=
>
false
}
}
Some
(
ast_map
:
:
NodeItem
(
itm
)
)
=
>
{
match
itm
.
node
{
ast
:
:
ItemFn
(
_
style
_
_
_
)
=
>
match
style
{
ast
:
:
Unsafety
:
:
Unsafe
=
>
true
_
=
>
false
}
_
=
>
false
}
}
_
=
>
false
}
}
