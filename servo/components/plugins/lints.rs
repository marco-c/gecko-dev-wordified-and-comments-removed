use
syntax
:
:
{
ast
ast_map
ast_util
codemap
visit
}
;
use
syntax
:
:
ast
:
:
Public
;
use
syntax
:
:
attr
:
:
AttrMetaMethods
;
use
rustc
:
:
lint
:
:
{
Context
LintPass
LintArray
Level
}
;
use
rustc
:
:
middle
:
:
ty
:
:
expr_ty
;
use
rustc
:
:
middle
:
:
{
ty
def
}
;
use
rustc
:
:
middle
:
:
typeck
:
:
astconv
:
:
AstConv
;
use
rustc
:
:
util
:
:
ppaux
:
:
Repr
;
use
utils
:
:
match_lang_ty
;
declare_lint
!
(
TRANSMUTE_TYPE_LINT
Allow
"
Warn
and
report
types
being
transmuted
"
)
declare_lint
!
(
UNROOTED_MUST_ROOT
Deny
"
Warn
and
report
usage
of
unrooted
jsmanaged
objects
"
)
declare_lint
!
(
PRIVATIZE
Deny
"
Allows
to
enforce
private
fields
for
struct
definitions
"
)
declare_lint
!
(
INHERITANCE_INTEGRITY
Deny
"
Ensures
that
struct
fields
are
properly
laid
out
for
inheritance
to
work
"
)
declare_lint
!
(
STR_TO_STRING
Deny
"
Warn
when
a
String
could
use
into_string
(
)
instead
of
to_string
(
)
"
)
pub
struct
TransmutePass
;
pub
struct
UnrootedPass
;
pub
struct
PrivatizePass
;
pub
struct
InheritancePass
;
pub
struct
StrToStringPass
;
impl
LintPass
for
TransmutePass
{
fn
get_lints
(
&
self
)
-
>
LintArray
{
lint_array
!
(
TRANSMUTE_TYPE_LINT
)
}
fn
check_expr
(
&
mut
self
cx
:
&
Context
ex
:
&
ast
:
:
Expr
)
{
match
ex
.
node
{
ast
:
:
ExprCall
(
ref
expr
ref
args
)
=
>
{
match
expr
.
node
{
ast
:
:
ExprPath
(
ref
path
)
=
>
{
if
path
.
segments
.
last
(
)
.
map_or
(
false
|
ref
segment
|
segment
.
identifier
.
name
.
as_str
(
)
=
=
"
transmute
"
)
&
&
args
.
len
(
)
=
=
1
{
let
tcx
=
cx
.
tcx
(
)
;
cx
.
span_lint
(
TRANSMUTE_TYPE_LINT
ex
.
span
format
!
(
"
Transmute
to
{
}
from
{
}
detected
"
expr_ty
(
tcx
ex
)
.
repr
(
tcx
)
expr_ty
(
tcx
&
*
*
args
.
get
(
0
)
.
unwrap
(
)
)
.
repr
(
tcx
)
)
.
as_slice
(
)
)
;
}
}
_
=
>
{
}
}
}
_
=
>
{
}
}
}
}
fn
lint_unrooted_ty
(
cx
:
&
Context
ty
:
&
ast
:
:
Ty
warning
:
&
str
)
{
match
ty
.
node
{
ast
:
:
TyVec
(
ref
t
)
|
ast
:
:
TyFixedLengthVec
(
ref
t
_
)
|
ast
:
:
TyPtr
(
ast
:
:
MutTy
{
ty
:
ref
t
.
.
}
)
|
ast
:
:
TyRptr
(
_
ast
:
:
MutTy
{
ty
:
ref
t
.
.
}
)
=
>
lint_unrooted_ty
(
cx
&
*
*
t
warning
)
ast
:
:
TyPath
(
_
_
id
)
=
>
{
match
cx
.
tcx
.
def_map
.
borrow
(
)
[
id
]
.
clone
(
)
{
def
:
:
DefTy
(
def_id
_
)
=
>
{
if
ty
:
:
has_attr
(
cx
.
tcx
def_id
"
must_root
"
)
{
cx
.
span_lint
(
UNROOTED_MUST_ROOT
ty
.
span
warning
)
;
}
}
_
=
>
(
)
}
}
_
=
>
(
)
}
;
}
fn
unsafe_context
(
map
:
&
ast_map
:
:
Map
id
:
ast
:
:
NodeId
)
-
>
bool
{
match
map
.
find
(
map
.
get_parent
(
id
)
)
{
Some
(
ast_map
:
:
NodeImplItem
(
itm
)
)
=
>
{
match
*
itm
{
ast
:
:
MethodImplItem
(
ref
meth
)
=
>
match
meth
.
node
{
ast
:
:
MethDecl
(
_
_
_
_
style
_
_
_
)
=
>
match
style
{
ast
:
:
UnsafeFn
=
>
true
_
=
>
false
}
_
=
>
false
}
_
=
>
false
}
}
Some
(
ast_map
:
:
NodeItem
(
itm
)
)
=
>
{
match
itm
.
node
{
ast
:
:
ItemFn
(
_
style
_
_
_
)
=
>
match
style
{
ast
:
:
UnsafeFn
=
>
true
_
=
>
false
}
_
=
>
false
}
}
_
=
>
false
}
}
impl
LintPass
for
UnrootedPass
{
fn
get_lints
(
&
self
)
-
>
LintArray
{
lint_array
!
(
UNROOTED_MUST_ROOT
)
}
fn
check_struct_def
(
&
mut
self
cx
:
&
Context
def
:
&
ast
:
:
StructDef
_i
:
ast
:
:
Ident
_gen
:
&
ast
:
:
Generics
id
:
ast
:
:
NodeId
)
{
if
cx
.
tcx
.
map
.
expect_item
(
id
)
.
attrs
.
iter
(
)
.
all
(
|
a
|
!
a
.
check_name
(
"
must_root
"
)
)
{
for
ref
field
in
def
.
fields
.
iter
(
)
{
lint_unrooted_ty
(
cx
&
*
field
.
node
.
ty
"
Type
must
be
rooted
use
#
[
must_root
]
on
the
struct
definition
to
propagate
"
)
;
}
}
}
fn
check_variant
(
&
mut
self
cx
:
&
Context
var
:
&
ast
:
:
Variant
_gen
:
&
ast
:
:
Generics
)
{
let
ref
map
=
cx
.
tcx
.
map
;
if
map
.
expect_item
(
map
.
get_parent
(
var
.
node
.
id
)
)
.
attrs
.
iter
(
)
.
all
(
|
a
|
!
a
.
check_name
(
"
must_root
"
)
)
{
match
var
.
node
.
kind
{
ast
:
:
TupleVariantKind
(
ref
vec
)
=
>
{
for
ty
in
vec
.
iter
(
)
{
lint_unrooted_ty
(
cx
&
*
ty
.
ty
"
Type
must
be
rooted
use
#
[
must_root
]
on
the
enum
definition
to
propagate
"
)
}
}
_
=
>
(
)
}
}
}
fn
check_fn
(
&
mut
self
cx
:
&
Context
kind
:
visit
:
:
FnKind
decl
:
&
ast
:
:
FnDecl
block
:
&
ast
:
:
Block
_span
:
codemap
:
:
Span
id
:
ast
:
:
NodeId
)
{
match
kind
{
visit
:
:
FkItemFn
(
i
_
_
_
)
|
visit
:
:
FkMethod
(
i
_
_
)
if
i
.
as_str
(
)
=
=
"
new
"
|
|
i
.
as_str
(
)
=
=
"
new_inherited
"
=
>
{
return
;
}
visit
:
:
FkItemFn
(
_
_
style
_
)
=
>
match
style
{
ast
:
:
UnsafeFn
=
>
return
_
=
>
(
)
}
_
=
>
(
)
}
if
unsafe_context
(
&
cx
.
tcx
.
map
id
)
{
return
;
}
match
block
.
rules
{
ast
:
:
DefaultBlock
=
>
{
for
arg
in
decl
.
inputs
.
iter
(
)
{
lint_unrooted_ty
(
cx
&
*
arg
.
ty
"
Type
must
be
rooted
"
)
}
}
_
=
>
(
)
}
}
fn
check_stmt
(
&
mut
self
cx
:
&
Context
s
:
&
ast
:
:
Stmt
)
{
match
s
.
node
{
ast
:
:
StmtDecl
(
_
id
)
|
ast
:
:
StmtExpr
(
_
id
)
|
ast
:
:
StmtSemi
(
_
id
)
if
unsafe_context
(
&
cx
.
tcx
.
map
id
)
=
>
{
return
}
_
=
>
(
)
}
;
let
expr
=
match
s
.
node
{
ast
:
:
StmtDecl
(
ref
decl
_
)
=
>
match
decl
.
node
{
ast
:
:
DeclLocal
(
ref
loc
)
=
>
match
loc
.
init
{
Some
(
ref
e
)
=
>
&
*
*
e
_
=
>
return
}
_
=
>
return
}
ast
:
:
StmtExpr
(
ref
expr
_
)
=
>
match
expr
.
node
{
ast
:
:
ExprAssign
(
_
ref
e
)
|
ast
:
:
ExprMatch
(
ref
e
_
_
)
|
ast
:
:
ExprForLoop
(
_
ref
e
_
_
)
=
>
&
*
*
e
_
=
>
return
}
_
=
>
return
}
;
let
t
=
expr_ty
(
cx
.
tcx
&
*
expr
)
;
match
ty
:
:
get
(
t
)
.
sty
{
ty
:
:
ty_struct
(
did
_
)
|
ty
:
:
ty_enum
(
did
_
)
=
>
{
if
ty
:
:
has_attr
(
cx
.
tcx
did
"
must_root
"
)
{
cx
.
span_lint
(
UNROOTED_MUST_ROOT
expr
.
span
format
!
(
"
Expression
of
type
{
}
must
be
rooted
"
t
.
repr
(
cx
.
tcx
)
)
.
as_slice
(
)
)
;
}
}
_
=
>
{
}
}
}
}
impl
LintPass
for
PrivatizePass
{
fn
get_lints
(
&
self
)
-
>
LintArray
{
lint_array
!
(
PRIVATIZE
)
}
fn
check_struct_def
(
&
mut
self
cx
:
&
Context
def
:
&
ast
:
:
StructDef
_i
:
ast
:
:
Ident
_gen
:
&
ast
:
:
Generics
id
:
ast
:
:
NodeId
)
{
if
ty
:
:
has_attr
(
cx
.
tcx
ast_util
:
:
local_def
(
id
)
"
privatize
"
)
{
for
field
in
def
.
fields
.
iter
(
)
{
match
field
.
node
{
ast
:
:
StructField_
{
kind
:
ast
:
:
NamedField
(
ident
visibility
)
.
.
}
if
visibility
=
=
Public
=
>
{
cx
.
span_lint
(
PRIVATIZE
field
.
span
format
!
(
"
Field
{
}
is
public
where
only
private
fields
are
allowed
"
ident
.
name
)
.
as_slice
(
)
)
;
}
_
=
>
{
}
}
}
}
}
}
impl
LintPass
for
InheritancePass
{
fn
get_lints
(
&
self
)
-
>
LintArray
{
lint_array
!
(
INHERITANCE_INTEGRITY
)
}
fn
check_struct_def
(
&
mut
self
cx
:
&
Context
def
:
&
ast
:
:
StructDef
_i
:
ast
:
:
Ident
_gen
:
&
ast
:
:
Generics
id
:
ast
:
:
NodeId
)
{
if
ty
:
:
has_attr
(
cx
.
tcx
ast_util
:
:
local_def
(
id
)
"
_dom_struct_marker
"
)
{
let
reflector_span
=
def
.
fields
.
iter
(
)
.
enumerate
(
)
.
find
(
|
&
(
ctr
f
)
|
{
if
match_lang_ty
(
cx
&
*
f
.
node
.
ty
"
reflector
"
)
{
if
ctr
>
0
{
cx
.
span_lint
(
INHERITANCE_INTEGRITY
f
.
span
"
The
Reflector
should
be
the
first
field
of
the
DOM
struct
"
)
;
}
return
true
;
}
false
}
)
.
map
(
|
(
_
f
)
|
f
.
span
)
;
let
dom_spans
:
Vec
<
_
>
=
def
.
fields
.
iter
(
)
.
enumerate
(
)
.
filter_map
(
|
(
ctr
f
)
|
{
if
let
ast
:
:
TyPath
(
_
_
ty_id
)
=
f
.
node
.
ty
.
node
{
if
let
Some
(
def
:
:
DefTy
(
def_id
_
)
)
=
cx
.
tcx
.
def_map
.
borrow
(
)
.
get
(
&
ty_id
)
.
cloned
(
)
{
if
ty
:
:
has_attr
(
cx
.
tcx
def_id
"
_dom_struct_marker
"
)
{
if
ctr
>
0
{
cx
.
span_lint
(
INHERITANCE_INTEGRITY
f
.
span
"
Bare
DOM
structs
should
only
be
used
as
the
first
field
of
a
\
DOM
struct
.
Consider
using
JS
<
T
>
instead
.
"
)
;
}
return
Some
(
f
.
span
)
}
}
}
None
}
)
.
collect
(
)
;
if
let
Some
(
sp
)
=
reflector_span
{
if
dom_spans
.
len
(
)
>
0
{
cx
.
span_lint
(
INHERITANCE_INTEGRITY
cx
.
tcx
.
map
.
expect_item
(
id
)
.
span
"
This
DOM
struct
has
both
Reflector
and
bare
DOM
struct
members
"
)
;
if
cx
.
current_level
(
INHERITANCE_INTEGRITY
)
!
=
Level
:
:
Allow
{
let
sess
=
cx
.
sess
(
)
;
sess
.
span_note
(
sp
"
Reflector
found
here
"
)
;
for
span
in
dom_spans
.
iter
(
)
{
sess
.
span_note
(
*
span
"
Bare
DOM
struct
found
here
"
)
;
}
}
}
}
else
if
dom_spans
.
len
(
)
>
1
{
cx
.
span_lint
(
INHERITANCE_INTEGRITY
cx
.
tcx
.
map
.
expect_item
(
id
)
.
span
"
This
DOM
struct
has
multiple
DOM
struct
members
only
one
is
allowed
"
)
;
if
cx
.
current_level
(
INHERITANCE_INTEGRITY
)
!
=
Level
:
:
Allow
{
for
span
in
dom_spans
.
iter
(
)
{
cx
.
sess
(
)
.
span_note
(
*
span
"
Bare
DOM
struct
found
here
"
)
;
}
}
}
else
if
dom_spans
.
len
(
)
=
=
0
{
cx
.
span_lint
(
INHERITANCE_INTEGRITY
cx
.
tcx
.
map
.
expect_item
(
id
)
.
span
"
This
DOM
struct
has
no
reflector
or
parent
DOM
struct
"
)
;
}
}
}
}
impl
LintPass
for
StrToStringPass
{
fn
get_lints
(
&
self
)
-
>
LintArray
{
lint_array
!
(
STR_TO_STRING
)
}
fn
check_expr
(
&
mut
self
cx
:
&
Context
expr
:
&
ast
:
:
Expr
)
{
match
expr
.
node
{
ast
:
:
ExprMethodCall
(
ref
method
_
ref
args
)
if
method
.
node
.
as_str
(
)
=
=
"
to_string
"
&
&
is_str
(
cx
&
*
args
[
0
]
)
=
>
{
cx
.
span_lint
(
STR_TO_STRING
expr
.
span
"
str
.
into_string
(
)
is
more
efficient
than
str
.
to_string
(
)
please
use
it
instead
"
)
;
}
_
=
>
(
)
}
fn
is_str
(
cx
:
&
Context
expr
:
&
ast
:
:
Expr
)
-
>
bool
{
fn
walk_ty
<
'
t
>
(
ty
:
ty
:
:
t
)
-
>
ty
:
:
t
{
match
ty
:
:
get
(
ty
)
.
sty
{
ty
:
:
ty_ptr
(
ref
tm
)
|
ty
:
:
ty_rptr
(
_
ref
tm
)
=
>
walk_ty
(
tm
.
ty
)
_
=
>
ty
}
}
match
ty
:
:
get
(
walk_ty
(
expr_ty
(
cx
.
tcx
expr
)
)
)
.
sty
{
ty
:
:
ty_str
=
>
true
_
=
>
false
}
}
}
}
