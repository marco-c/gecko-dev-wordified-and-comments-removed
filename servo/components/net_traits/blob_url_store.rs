use
filemanager_thread
:
:
FileOrigin
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
str
:
:
FromStr
;
use
url
:
:
Url
;
use
uuid
:
:
Uuid
;
#
[
derive
(
Clone
Debug
Serialize
Deserialize
)
]
pub
enum
BlobURLStoreError
{
InvalidFileID
InvalidOrigin
InvalidEntry
External
(
String
)
}
#
[
derive
(
Clone
Debug
Serialize
Deserialize
)
]
pub
struct
BlobBuf
{
pub
filename
:
Option
<
String
>
pub
type_string
:
String
pub
size
:
u64
pub
bytes
:
Vec
<
u8
>
}
pub
fn
parse_blob_url
(
url
:
&
ServoUrl
)
-
>
Result
<
(
Uuid
FileOrigin
Option
<
String
>
)
(
)
>
{
let
url_inner
=
try
!
(
Url
:
:
parse
(
url
.
path
(
)
)
.
map_err
(
|
_
|
(
)
)
)
;
let
fragment
=
url_inner
.
fragment
(
)
.
map
(
|
s
|
s
.
to_string
(
)
)
;
let
id
=
{
let
mut
segs
=
try
!
(
url_inner
.
path_segments
(
)
.
ok_or
(
(
)
)
)
;
let
id
=
try
!
(
segs
.
nth
(
0
)
.
ok_or
(
(
)
)
)
;
try
!
(
Uuid
:
:
from_str
(
id
)
.
map_err
(
|
_
|
(
)
)
)
}
;
Ok
(
(
id
get_blob_origin
(
&
ServoUrl
:
:
from_url
(
url_inner
)
)
fragment
)
)
}
pub
fn
get_blob_origin
(
url
:
&
ServoUrl
)
-
>
FileOrigin
{
if
url
.
scheme
(
)
=
=
"
file
"
{
"
file
:
/
/
"
.
to_string
(
)
}
else
{
url
.
origin
(
)
.
unicode_serialization
(
)
}
}
