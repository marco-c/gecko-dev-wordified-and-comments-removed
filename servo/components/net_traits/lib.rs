#
!
[
feature
(
box_syntax
)
]
#
!
[
feature
(
custom_attribute
)
]
#
!
[
feature
(
custom_derive
)
]
#
!
[
feature
(
plugin
)
]
#
!
[
feature
(
slice_patterns
)
]
#
!
[
feature
(
step_by
)
]
#
!
[
plugin
(
heapsize_plugin
serde_macros
)
]
#
!
[
deny
(
unsafe_code
)
]
extern
crate
cookie
as
cookie_rs
;
extern
crate
heapsize
;
extern
crate
hyper
;
extern
crate
hyper_serde
;
extern
crate
image
as
piston_image
;
extern
crate
ipc_channel
;
#
[
allow
(
unused_extern_crates
)
]
#
[
macro_use
]
extern
crate
lazy_static
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
msg
;
extern
crate
num_traits
;
extern
crate
serde
;
extern
crate
url
;
extern
crate
util
;
extern
crate
uuid
;
extern
crate
websocket
;
use
cookie_rs
:
:
Cookie
;
use
filemanager_thread
:
:
FileManagerThreadMsg
;
use
heapsize
:
:
HeapSizeOf
;
use
hyper
:
:
header
:
:
{
ContentType
Headers
}
;
use
hyper
:
:
http
:
:
RawStatus
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
mime
:
:
{
Attr
Mime
}
;
use
hyper_serde
:
:
Serde
;
use
ipc_channel
:
:
ipc
:
:
{
self
IpcReceiver
IpcSender
}
;
use
msg
:
:
constellation_msg
:
:
{
PipelineId
ReferrerPolicy
}
;
use
request
:
:
{
Request
RequestInit
}
;
use
response
:
:
{
HttpsState
Response
}
;
use
std
:
:
io
:
:
Error
as
IOError
;
use
std
:
:
thread
;
use
storage_thread
:
:
StorageThreadMsg
;
use
url
:
:
Url
;
use
websocket
:
:
header
;
pub
mod
blob_url_store
;
pub
mod
bluetooth_scanfilter
;
pub
mod
bluetooth_thread
;
pub
mod
filemanager_thread
;
pub
mod
hosts
;
pub
mod
image_cache_thread
;
pub
mod
net_error_list
;
pub
mod
request
;
pub
mod
response
;
pub
mod
storage_thread
;
pub
mod
image
{
pub
mod
base
;
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
LoadContext
{
Browsing
Image
AudioVideo
Plugin
Style
Script
Font
TextTrack
CacheManifest
}
#
[
derive
(
Clone
Debug
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
CustomResponse
{
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
#
[
serde
(
deserialize_with
=
"
:
:
hyper_serde
:
:
deserialize
"
serialize_with
=
"
:
:
hyper_serde
:
:
serialize
"
)
]
pub
headers
:
Headers
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
#
[
serde
(
deserialize_with
=
"
:
:
hyper_serde
:
:
deserialize
"
serialize_with
=
"
:
:
hyper_serde
:
:
serialize
"
)
]
pub
raw_status
:
RawStatus
pub
body
:
Vec
<
u8
>
}
impl
CustomResponse
{
pub
fn
new
(
headers
:
Headers
raw_status
:
RawStatus
body
:
Vec
<
u8
>
)
-
>
CustomResponse
{
CustomResponse
{
headers
:
headers
raw_status
:
raw_status
body
:
body
}
}
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
CustomResponseMediator
{
pub
response_chan
:
IpcSender
<
Option
<
CustomResponse
>
>
pub
load_url
:
Url
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
LoadData
{
pub
url
:
Url
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
#
[
serde
(
deserialize_with
=
"
:
:
hyper_serde
:
:
deserialize
"
serialize_with
=
"
:
:
hyper_serde
:
:
serialize
"
)
]
pub
method
:
Method
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
#
[
serde
(
deserialize_with
=
"
:
:
hyper_serde
:
:
deserialize
"
serialize_with
=
"
:
:
hyper_serde
:
:
serialize
"
)
]
pub
headers
:
Headers
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
#
[
serde
(
deserialize_with
=
"
:
:
hyper_serde
:
:
deserialize
"
serialize_with
=
"
:
:
hyper_serde
:
:
serialize
"
)
]
pub
preserved_headers
:
Headers
pub
data
:
Option
<
Vec
<
u8
>
>
pub
cors
:
Option
<
ResourceCORSData
>
pub
pipeline_id
:
Option
<
PipelineId
>
pub
credentials_flag
:
bool
pub
context
:
LoadContext
pub
referrer_policy
:
Option
<
ReferrerPolicy
>
pub
referrer_url
:
Option
<
Url
>
}
impl
LoadData
{
pub
fn
new
(
context
:
LoadContext
url
:
Url
load_origin
:
&
LoadOrigin
)
-
>
LoadData
{
LoadData
{
url
:
url
method
:
Method
:
:
Get
headers
:
Headers
:
:
new
(
)
preserved_headers
:
Headers
:
:
new
(
)
data
:
None
cors
:
None
pipeline_id
:
load_origin
.
pipeline_id
(
)
credentials_flag
:
true
context
:
context
referrer_policy
:
load_origin
.
referrer_policy
(
)
referrer_url
:
load_origin
.
referrer_url
(
)
.
clone
(
)
}
}
}
pub
trait
LoadOrigin
{
fn
referrer_url
(
&
self
)
-
>
Option
<
Url
>
;
fn
referrer_policy
(
&
self
)
-
>
Option
<
ReferrerPolicy
>
;
fn
pipeline_id
(
&
self
)
-
>
Option
<
PipelineId
>
;
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
FetchResponseMsg
{
ProcessRequestBody
ProcessRequestEOF
ProcessResponse
(
Result
<
FetchMetadata
NetworkError
>
)
ProcessResponseChunk
(
Vec
<
u8
>
)
ProcessResponseEOF
(
Result
<
(
)
NetworkError
>
)
}
pub
trait
FetchTaskTarget
{
fn
process_request_body
(
&
mut
self
request
:
&
Request
)
;
fn
process_request_eof
(
&
mut
self
request
:
&
Request
)
;
fn
process_response
(
&
mut
self
response
:
&
Response
)
;
fn
process_response_chunk
(
&
mut
self
chunk
:
Vec
<
u8
>
)
;
fn
process_response_eof
(
&
mut
self
response
:
&
Response
)
;
}
#
[
derive
(
Serialize
Deserialize
)
]
pub
enum
FilteredMetadata
{
Opaque
Transparent
(
Metadata
)
}
#
[
derive
(
Serialize
Deserialize
)
]
pub
enum
FetchMetadata
{
Unfiltered
(
Metadata
)
Filtered
{
filtered
:
FilteredMetadata
unsafe_
:
Metadata
}
}
pub
trait
FetchResponseListener
{
fn
process_request_body
(
&
mut
self
)
;
fn
process_request_eof
(
&
mut
self
)
;
fn
process_response
(
&
mut
self
metadata
:
Result
<
FetchMetadata
NetworkError
>
)
;
fn
process_response_chunk
(
&
mut
self
chunk
:
Vec
<
u8
>
)
;
fn
process_response_eof
(
&
mut
self
response
:
Result
<
(
)
NetworkError
>
)
;
}
impl
FetchTaskTarget
for
IpcSender
<
FetchResponseMsg
>
{
fn
process_request_body
(
&
mut
self
_
:
&
Request
)
{
let
_
=
self
.
send
(
FetchResponseMsg
:
:
ProcessRequestBody
)
;
}
fn
process_request_eof
(
&
mut
self
_
:
&
Request
)
{
let
_
=
self
.
send
(
FetchResponseMsg
:
:
ProcessRequestEOF
)
;
}
fn
process_response
(
&
mut
self
response
:
&
Response
)
{
let
_
=
self
.
send
(
FetchResponseMsg
:
:
ProcessResponse
(
response
.
metadata
(
)
)
)
;
}
fn
process_response_chunk
(
&
mut
self
chunk
:
Vec
<
u8
>
)
{
let
_
=
self
.
send
(
FetchResponseMsg
:
:
ProcessResponseChunk
(
chunk
)
)
;
}
fn
process_response_eof
(
&
mut
self
response
:
&
Response
)
{
if
response
.
is_network_error
(
)
{
let
_
=
self
.
send
(
FetchResponseMsg
:
:
ProcessResponseEOF
(
Err
(
NetworkError
:
:
Internal
(
"
Network
error
"
.
into
(
)
)
)
)
)
;
}
else
{
let
_
=
self
.
send
(
FetchResponseMsg
:
:
ProcessResponseEOF
(
Ok
(
(
)
)
)
)
;
}
}
}
pub
trait
Action
<
Listener
>
{
fn
process
(
self
listener
:
&
mut
Listener
)
;
}
pub
trait
AsyncResponseListener
{
fn
headers_available
(
&
mut
self
metadata
:
Result
<
Metadata
NetworkError
>
)
;
fn
data_available
(
&
mut
self
payload
:
Vec
<
u8
>
)
;
fn
response_complete
(
&
mut
self
status
:
Result
<
(
)
NetworkError
>
)
;
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
ResponseAction
{
HeadersAvailable
(
Result
<
Metadata
NetworkError
>
)
DataAvailable
(
Vec
<
u8
>
)
ResponseComplete
(
Result
<
(
)
NetworkError
>
)
}
impl
<
T
:
AsyncResponseListener
>
Action
<
T
>
for
ResponseAction
{
fn
process
(
self
listener
:
&
mut
T
)
{
match
self
{
ResponseAction
:
:
HeadersAvailable
(
m
)
=
>
listener
.
headers_available
(
m
)
ResponseAction
:
:
DataAvailable
(
d
)
=
>
listener
.
data_available
(
d
)
ResponseAction
:
:
ResponseComplete
(
r
)
=
>
listener
.
response_complete
(
r
)
}
}
}
impl
<
T
:
FetchResponseListener
>
Action
<
T
>
for
FetchResponseMsg
{
fn
process
(
self
listener
:
&
mut
T
)
{
match
self
{
FetchResponseMsg
:
:
ProcessRequestBody
=
>
listener
.
process_request_body
(
)
FetchResponseMsg
:
:
ProcessRequestEOF
=
>
listener
.
process_request_eof
(
)
FetchResponseMsg
:
:
ProcessResponse
(
meta
)
=
>
listener
.
process_response
(
meta
)
FetchResponseMsg
:
:
ProcessResponseChunk
(
data
)
=
>
listener
.
process_response_chunk
(
data
)
FetchResponseMsg
:
:
ProcessResponseEOF
(
data
)
=
>
listener
.
process_response_eof
(
data
)
}
}
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
AsyncResponseTarget
{
pub
sender
:
IpcSender
<
ResponseAction
>
}
impl
AsyncResponseTarget
{
pub
fn
invoke_with_listener
(
&
self
action
:
ResponseAction
)
{
self
.
sender
.
send
(
action
)
.
unwrap
(
)
}
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
LoadConsumer
{
Channel
(
IpcSender
<
LoadResponse
>
)
Listener
(
AsyncResponseTarget
)
}
pub
type
CoreResourceThread
=
IpcSender
<
CoreResourceMsg
>
;
pub
type
IpcSendResult
=
Result
<
(
)
IOError
>
;
pub
trait
IpcSend
<
T
>
where
T
:
serde
:
:
Serialize
+
serde
:
:
Deserialize
{
fn
send
(
&
self
T
)
-
>
IpcSendResult
;
fn
sender
(
&
self
)
-
>
IpcSender
<
T
>
;
}
#
[
derive
(
Clone
Serialize
Deserialize
)
]
pub
struct
ResourceThreads
{
core_thread
:
CoreResourceThread
storage_thread
:
IpcSender
<
StorageThreadMsg
>
}
impl
ResourceThreads
{
pub
fn
new
(
c
:
CoreResourceThread
s
:
IpcSender
<
StorageThreadMsg
>
)
-
>
ResourceThreads
{
ResourceThreads
{
core_thread
:
c
storage_thread
:
s
}
}
}
impl
IpcSend
<
CoreResourceMsg
>
for
ResourceThreads
{
fn
send
(
&
self
msg
:
CoreResourceMsg
)
-
>
IpcSendResult
{
self
.
core_thread
.
send
(
msg
)
}
fn
sender
(
&
self
)
-
>
IpcSender
<
CoreResourceMsg
>
{
self
.
core_thread
.
clone
(
)
}
}
impl
IpcSend
<
StorageThreadMsg
>
for
ResourceThreads
{
fn
send
(
&
self
msg
:
StorageThreadMsg
)
-
>
IpcSendResult
{
self
.
storage_thread
.
send
(
msg
)
}
fn
sender
(
&
self
)
-
>
IpcSender
<
StorageThreadMsg
>
{
self
.
storage_thread
.
clone
(
)
}
}
impl
HeapSizeOf
for
ResourceThreads
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
#
[
derive
(
PartialEq
Copy
Clone
Deserialize
Serialize
)
]
pub
enum
IncludeSubdomains
{
Included
NotIncluded
}
#
[
derive
(
HeapSizeOf
Deserialize
Serialize
)
]
pub
enum
MessageData
{
Text
(
String
)
Binary
(
Vec
<
u8
>
)
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
WebSocketDomAction
{
SendMessage
(
MessageData
)
Close
(
Option
<
u16
>
Option
<
String
>
)
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
WebSocketNetworkEvent
{
ConnectionEstablished
(
#
[
serde
(
deserialize_with
=
"
:
:
hyper_serde
:
:
deserialize
"
serialize_with
=
"
:
:
hyper_serde
:
:
serialize
"
)
]
header
:
:
Headers
Vec
<
String
>
)
MessageReceived
(
MessageData
)
Close
(
Option
<
u16
>
String
)
Fail
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
WebSocketCommunicate
{
pub
event_sender
:
IpcSender
<
WebSocketNetworkEvent
>
pub
action_receiver
:
IpcReceiver
<
WebSocketDomAction
>
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
WebSocketConnectData
{
pub
resource_url
:
Url
pub
origin
:
String
pub
protocols
:
Vec
<
String
>
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
CoreResourceMsg
{
Load
(
LoadData
LoadConsumer
Option
<
IpcSender
<
ResourceId
>
>
)
Fetch
(
RequestInit
IpcSender
<
FetchResponseMsg
>
)
WebsocketConnect
(
WebSocketCommunicate
WebSocketConnectData
)
SetCookiesForUrl
(
Url
String
CookieSource
)
SetCookiesForUrlWithData
(
Url
#
[
serde
(
deserialize_with
=
"
:
:
hyper_serde
:
:
deserialize
"
serialize_with
=
"
:
:
hyper_serde
:
:
serialize
"
)
]
Cookie
CookieSource
)
GetCookiesForUrl
(
Url
IpcSender
<
Option
<
String
>
>
CookieSource
)
GetCookiesDataForUrl
(
Url
IpcSender
<
Vec
<
Serde
<
Cookie
>
>
>
CookieSource
)
Cancel
(
ResourceId
)
Synchronize
(
IpcSender
<
(
)
>
)
NetworkMediator
(
IpcSender
<
CustomResponseMediator
>
)
ToFileManager
(
FileManagerThreadMsg
)
Exit
(
IpcSender
<
(
)
>
)
}
pub
struct
PendingAsyncLoad
{
core_resource_thread
:
CoreResourceThread
url
:
Url
pipeline
:
Option
<
PipelineId
>
guard
:
PendingLoadGuard
context
:
LoadContext
referrer_policy
:
Option
<
ReferrerPolicy
>
referrer_url
:
Option
<
Url
>
}
struct
PendingLoadGuard
{
loaded
:
bool
}
impl
PendingLoadGuard
{
fn
neuter
(
&
mut
self
)
{
self
.
loaded
=
true
;
}
}
impl
Drop
for
PendingLoadGuard
{
fn
drop
(
&
mut
self
)
{
if
!
thread
:
:
panicking
(
)
{
assert
!
(
self
.
loaded
)
}
}
}
impl
LoadOrigin
for
PendingAsyncLoad
{
fn
referrer_url
(
&
self
)
-
>
Option
<
Url
>
{
self
.
referrer_url
.
clone
(
)
}
fn
referrer_policy
(
&
self
)
-
>
Option
<
ReferrerPolicy
>
{
self
.
referrer_policy
.
clone
(
)
}
fn
pipeline_id
(
&
self
)
-
>
Option
<
PipelineId
>
{
self
.
pipeline
}
}
impl
PendingAsyncLoad
{
pub
fn
new
(
context
:
LoadContext
core_resource_thread
:
CoreResourceThread
url
:
Url
pipeline
:
Option
<
PipelineId
>
referrer_policy
:
Option
<
ReferrerPolicy
>
referrer_url
:
Option
<
Url
>
)
-
>
PendingAsyncLoad
{
PendingAsyncLoad
{
core_resource_thread
:
core_resource_thread
url
:
url
pipeline
:
pipeline
guard
:
PendingLoadGuard
{
loaded
:
false
}
context
:
context
referrer_policy
:
referrer_policy
referrer_url
:
referrer_url
}
}
pub
fn
load_async
(
mut
self
listener
:
AsyncResponseTarget
)
{
self
.
guard
.
neuter
(
)
;
let
load_data
=
LoadData
:
:
new
(
self
.
context
.
clone
(
)
self
.
url
.
clone
(
)
&
self
)
;
let
consumer
=
LoadConsumer
:
:
Listener
(
listener
)
;
self
.
core_resource_thread
.
send
(
CoreResourceMsg
:
:
Load
(
load_data
consumer
None
)
)
.
unwrap
(
)
;
}
pub
fn
fetch_async
(
mut
self
request
:
RequestInit
fetch_target
:
IpcSender
<
FetchResponseMsg
>
)
{
self
.
guard
.
neuter
(
)
;
self
.
core_resource_thread
.
send
(
CoreResourceMsg
:
:
Fetch
(
request
fetch_target
)
)
.
unwrap
(
)
;
}
}
#
[
derive
(
Serialize
Deserialize
)
]
pub
struct
LoadResponse
{
pub
metadata
:
Metadata
pub
progress_port
:
IpcReceiver
<
ProgressMsg
>
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
ResourceCORSData
{
pub
preflight
:
bool
pub
origin
:
Url
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
Metadata
{
pub
final_url
:
Url
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
pub
content_type
:
Option
<
Serde
<
ContentType
>
>
pub
charset
:
Option
<
String
>
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
pub
headers
:
Option
<
Serde
<
Headers
>
>
pub
status
:
Option
<
(
u16
Vec
<
u8
>
)
>
pub
https_state
:
HttpsState
pub
referrer
:
Option
<
Url
>
}
impl
Metadata
{
pub
fn
default
(
url
:
Url
)
-
>
Self
{
Metadata
{
final_url
:
url
content_type
:
None
charset
:
None
headers
:
None
status
:
Some
(
(
200
b
"
OK
"
.
to_vec
(
)
)
)
https_state
:
HttpsState
:
:
None
referrer
:
None
}
}
pub
fn
set_content_type
(
&
mut
self
content_type
:
Option
<
&
Mime
>
)
{
match
self
.
headers
{
None
=
>
self
.
headers
=
Some
(
Serde
(
Headers
:
:
new
(
)
)
)
Some
(
_
)
=
>
(
)
}
match
content_type
{
None
=
>
(
)
Some
(
mime
)
=
>
{
if
let
Some
(
headers
)
=
self
.
headers
.
as_mut
(
)
{
headers
.
set
(
ContentType
(
mime
.
clone
(
)
)
)
;
}
self
.
content_type
=
Some
(
Serde
(
ContentType
(
mime
.
clone
(
)
)
)
)
;
let
&
Mime
(
_
_
ref
parameters
)
=
mime
;
for
&
(
ref
k
ref
v
)
in
parameters
{
if
&
Attr
:
:
Charset
=
=
k
{
self
.
charset
=
Some
(
v
.
to_string
(
)
)
;
}
}
}
}
}
}
#
[
derive
(
PartialEq
Copy
Clone
Deserialize
Serialize
)
]
pub
enum
CookieSource
{
HTTP
NonHTTP
}
#
[
derive
(
PartialEq
Debug
Deserialize
Serialize
)
]
pub
enum
ProgressMsg
{
Payload
(
Vec
<
u8
>
)
Done
(
Result
<
(
)
NetworkError
>
)
}
pub
fn
load_whole_resource
(
context
:
LoadContext
core_resource_thread
:
&
CoreResourceThread
url
:
Url
load_origin
:
&
LoadOrigin
)
-
>
Result
<
(
Metadata
Vec
<
u8
>
)
NetworkError
>
{
let
(
start_chan
start_port
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
let
load_data
=
LoadData
:
:
new
(
context
url
load_origin
)
;
core_resource_thread
.
send
(
CoreResourceMsg
:
:
Load
(
load_data
LoadConsumer
:
:
Channel
(
start_chan
)
None
)
)
.
unwrap
(
)
;
let
response
=
start_port
.
recv
(
)
.
unwrap
(
)
;
let
mut
buf
=
vec
!
(
)
;
loop
{
match
response
.
progress_port
.
recv
(
)
.
unwrap
(
)
{
ProgressMsg
:
:
Payload
(
data
)
=
>
buf
.
extend_from_slice
(
&
data
)
ProgressMsg
:
:
Done
(
Ok
(
(
)
)
)
=
>
return
Ok
(
(
response
.
metadata
buf
)
)
ProgressMsg
:
:
Done
(
Err
(
e
)
)
=
>
return
Err
(
e
)
}
}
}
pub
fn
unwrap_websocket_protocol
(
wsp
:
Option
<
&
header
:
:
WebSocketProtocol
>
)
-
>
Option
<
&
str
>
{
wsp
.
and_then
(
|
protocol_list
|
protocol_list
.
get
(
0
)
.
map
(
|
protocol
|
protocol
.
as_ref
(
)
)
)
}
#
[
derive
(
Clone
PartialEq
Eq
Copy
Hash
Debug
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
ResourceId
(
pub
u32
)
;
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
ConstellationMsg
{
IsPrivate
(
PipelineId
IpcSender
<
bool
>
)
}
#
[
derive
(
Clone
PartialEq
Eq
Debug
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
NetworkError
{
Internal
(
String
)
LoadCancelled
SslValidation
(
Url
String
)
}
pub
fn
trim_http_whitespace
(
mut
slice
:
&
[
u8
]
)
-
>
&
[
u8
]
{
const
HTTP_WS_BYTES
:
&
'
static
[
u8
]
=
b
"
\
x09
\
x0A
\
x0D
\
x20
"
;
loop
{
match
slice
.
split_first
(
)
{
Some
(
(
first
remainder
)
)
if
HTTP_WS_BYTES
.
contains
(
first
)
=
>
slice
=
remainder
_
=
>
break
}
}
loop
{
match
slice
.
split_last
(
)
{
Some
(
(
last
remainder
)
)
if
HTTP_WS_BYTES
.
contains
(
last
)
=
>
slice
=
remainder
_
=
>
break
}
}
slice
}
