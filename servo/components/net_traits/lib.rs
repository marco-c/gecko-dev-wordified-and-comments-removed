#
!
[
feature
(
box_syntax
)
]
#
!
[
feature
(
custom_attribute
)
]
#
!
[
feature
(
custom_derive
)
]
#
!
[
feature
(
plugin
)
]
#
!
[
feature
(
slice_patterns
)
]
#
!
[
feature
(
step_by
)
]
#
!
[
feature
(
custom_attribute
)
]
#
!
[
plugin
(
serde_macros
plugins
)
]
extern
crate
euclid
;
extern
crate
hyper
;
extern
crate
image
as
piston_image
;
extern
crate
ipc_channel
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
msg
;
extern
crate
serde
;
extern
crate
stb_image
;
extern
crate
url
;
extern
crate
util
;
extern
crate
websocket
;
use
hyper
:
:
header
:
:
{
ContentType
Headers
}
;
use
hyper
:
:
http
:
:
RawStatus
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
mime
:
:
{
Attr
Mime
}
;
use
hyper
:
:
status
:
:
StatusCode
;
use
ipc_channel
:
:
ipc
:
:
{
self
IpcReceiver
IpcSender
}
;
use
msg
:
:
constellation_msg
:
:
{
PipelineId
}
;
use
serde
:
:
{
Deserializer
Serializer
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
thread
;
use
url
:
:
Url
;
use
util
:
:
mem
:
:
HeapSizeOf
;
use
websocket
:
:
header
;
pub
mod
hosts
;
pub
mod
image_cache_task
;
pub
mod
net_error_list
;
pub
mod
storage_task
;
#
[
derive
(
Clone
PartialEq
Copy
)
]
pub
enum
ResponseType
{
Basic
CORS
Default
Error
Opaque
OpaqueRedirect
}
#
[
derive
(
Clone
Copy
)
]
pub
enum
TerminationReason
{
EndUserAbort
Fatal
Timeout
}
#
[
derive
(
Clone
)
]
pub
enum
ResponseBody
{
Empty
Receiving
(
Vec
<
u8
>
)
Done
(
Vec
<
u8
>
)
}
#
[
derive
(
Clone
)
]
pub
enum
CacheState
{
None
Local
Validated
Partial
}
pub
enum
ResponseMsg
{
Chunk
(
Vec
<
u8
>
)
Finished
Errored
}
#
[
derive
(
Clone
)
]
pub
struct
Response
{
pub
response_type
:
ResponseType
pub
termination_reason
:
Option
<
TerminationReason
>
pub
url
:
Option
<
Url
>
pub
url_list
:
Vec
<
Url
>
pub
status
:
Option
<
StatusCode
>
pub
headers
:
Headers
pub
body
:
ResponseBody
pub
cache_state
:
CacheState
pub
internal_response
:
Option
<
Rc
<
RefCell
<
Response
>
>
>
}
impl
Response
{
pub
fn
network_error
(
)
-
>
Response
{
Response
{
response_type
:
ResponseType
:
:
Error
termination_reason
:
None
url
:
None
url_list
:
vec
!
[
]
status
:
None
headers
:
Headers
:
:
new
(
)
body
:
ResponseBody
:
:
Empty
cache_state
:
CacheState
:
:
None
internal_response
:
None
}
}
pub
fn
is_network_error
(
&
self
)
-
>
bool
{
match
self
.
response_type
{
ResponseType
:
:
Error
=
>
true
_
=
>
false
}
}
}
pub
mod
image
{
pub
mod
base
;
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
LoadContext
{
Browsing
Image
AudioVideo
Plugin
Style
Script
Font
TextTrack
CacheManifest
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
LoadData
{
pub
url
:
Url
pub
method
:
Method
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
pub
headers
:
Headers
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
pub
preserved_headers
:
Headers
pub
data
:
Option
<
Vec
<
u8
>
>
pub
cors
:
Option
<
ResourceCORSData
>
pub
pipeline_id
:
Option
<
PipelineId
>
pub
credentials_flag
:
bool
pub
context
:
LoadContext
}
impl
LoadData
{
pub
fn
new
(
context
:
LoadContext
url
:
Url
id
:
Option
<
PipelineId
>
)
-
>
LoadData
{
LoadData
{
url
:
url
method
:
Method
:
:
Get
headers
:
Headers
:
:
new
(
)
preserved_headers
:
Headers
:
:
new
(
)
data
:
None
cors
:
None
pipeline_id
:
id
credentials_flag
:
true
context
:
context
}
}
}
pub
trait
AsyncFetchListener
{
fn
response_available
(
&
self
response
:
Response
)
;
}
pub
trait
AsyncResponseListener
{
fn
headers_available
(
&
mut
self
metadata
:
Metadata
)
;
fn
data_available
(
&
mut
self
payload
:
Vec
<
u8
>
)
;
fn
response_complete
(
&
mut
self
status
:
Result
<
(
)
String
>
)
;
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
ResponseAction
{
HeadersAvailable
(
Metadata
)
DataAvailable
(
Vec
<
u8
>
)
ResponseComplete
(
Result
<
(
)
String
>
)
}
impl
ResponseAction
{
pub
fn
process
(
self
listener
:
&
mut
AsyncResponseListener
)
{
match
self
{
ResponseAction
:
:
HeadersAvailable
(
m
)
=
>
listener
.
headers_available
(
m
)
ResponseAction
:
:
DataAvailable
(
d
)
=
>
listener
.
data_available
(
d
)
ResponseAction
:
:
ResponseComplete
(
r
)
=
>
listener
.
response_complete
(
r
)
}
}
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
AsyncResponseTarget
{
pub
sender
:
IpcSender
<
ResponseAction
>
}
impl
AsyncResponseTarget
{
pub
fn
invoke_with_listener
(
&
self
action
:
ResponseAction
)
{
self
.
sender
.
send
(
action
)
.
unwrap
(
)
}
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
LoadConsumer
{
Channel
(
IpcSender
<
LoadResponse
>
)
Listener
(
AsyncResponseTarget
)
}
pub
type
ResourceTask
=
IpcSender
<
ControlMsg
>
;
#
[
derive
(
PartialEq
Copy
Clone
Deserialize
Serialize
)
]
pub
enum
IncludeSubdomains
{
Included
NotIncluded
}
#
[
derive
(
HeapSizeOf
Deserialize
Serialize
)
]
pub
enum
MessageData
{
Text
(
String
)
Binary
(
Vec
<
u8
>
)
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
WebSocketDomAction
{
SendMessage
(
MessageData
)
Close
(
u16
String
)
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
WebSocketNetworkEvent
{
ConnectionEstablished
(
header
:
:
Headers
Vec
<
String
>
)
MessageReceived
(
MessageData
)
Close
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
WebSocketCommunicate
{
pub
event_sender
:
IpcSender
<
WebSocketNetworkEvent
>
pub
action_receiver
:
IpcReceiver
<
WebSocketDomAction
>
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
WebSocketConnectData
{
pub
resource_url
:
Url
pub
origin
:
String
pub
protocols
:
Vec
<
String
>
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
ControlMsg
{
Load
(
LoadData
LoadConsumer
Option
<
IpcSender
<
ResourceId
>
>
)
WebsocketConnect
(
WebSocketCommunicate
WebSocketConnectData
)
SetCookiesForUrl
(
Url
String
CookieSource
)
GetCookiesForUrl
(
Url
IpcSender
<
Option
<
String
>
>
CookieSource
)
Cancel
(
ResourceId
)
Synchronize
(
IpcSender
<
(
)
>
)
Exit
}
pub
struct
PendingAsyncLoad
{
resource_task
:
ResourceTask
url
:
Url
pipeline
:
Option
<
PipelineId
>
guard
:
PendingLoadGuard
context
:
LoadContext
}
struct
PendingLoadGuard
{
loaded
:
bool
}
impl
PendingLoadGuard
{
fn
neuter
(
&
mut
self
)
{
self
.
loaded
=
true
;
}
}
impl
Drop
for
PendingLoadGuard
{
fn
drop
(
&
mut
self
)
{
if
!
thread
:
:
panicking
(
)
{
assert
!
(
self
.
loaded
)
}
}
}
impl
PendingAsyncLoad
{
pub
fn
new
(
context
:
LoadContext
resource_task
:
ResourceTask
url
:
Url
pipeline
:
Option
<
PipelineId
>
)
-
>
PendingAsyncLoad
{
PendingAsyncLoad
{
resource_task
:
resource_task
url
:
url
pipeline
:
pipeline
guard
:
PendingLoadGuard
{
loaded
:
false
}
context
:
context
}
}
pub
fn
load_async
(
mut
self
listener
:
AsyncResponseTarget
)
{
self
.
guard
.
neuter
(
)
;
let
load_data
=
LoadData
:
:
new
(
self
.
context
self
.
url
self
.
pipeline
)
;
let
consumer
=
LoadConsumer
:
:
Listener
(
listener
)
;
self
.
resource_task
.
send
(
ControlMsg
:
:
Load
(
load_data
consumer
None
)
)
.
unwrap
(
)
;
}
}
#
[
derive
(
Serialize
Deserialize
)
]
pub
struct
LoadResponse
{
pub
metadata
:
Metadata
pub
progress_port
:
IpcReceiver
<
ProgressMsg
>
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
ResourceCORSData
{
pub
preflight
:
bool
pub
origin
:
Url
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
Metadata
{
pub
final_url
:
Url
pub
content_type
:
Option
<
(
ContentType
)
>
pub
charset
:
Option
<
String
>
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
pub
headers
:
Option
<
Headers
>
pub
status
:
Option
<
RawStatus
>
}
impl
Metadata
{
pub
fn
default
(
url
:
Url
)
-
>
Self
{
Metadata
{
final_url
:
url
content_type
:
None
charset
:
None
headers
:
None
status
:
Some
(
RawStatus
(
200
"
OK
"
.
into
(
)
)
)
}
}
pub
fn
set_content_type
(
&
mut
self
content_type
:
Option
<
&
Mime
>
)
{
match
content_type
{
None
=
>
(
)
Some
(
mime
)
=
>
{
self
.
content_type
=
Some
(
ContentType
(
mime
.
clone
(
)
)
)
;
let
&
Mime
(
_
_
ref
parameters
)
=
mime
;
for
&
(
ref
k
ref
v
)
in
parameters
{
if
&
Attr
:
:
Charset
=
=
k
{
self
.
charset
=
Some
(
v
.
to_string
(
)
)
;
}
}
}
}
}
}
#
[
derive
(
PartialEq
Copy
Clone
Deserialize
Serialize
)
]
pub
enum
CookieSource
{
HTTP
NonHTTP
}
#
[
derive
(
PartialEq
Debug
Deserialize
Serialize
)
]
pub
enum
ProgressMsg
{
Payload
(
Vec
<
u8
>
)
Done
(
Result
<
(
)
String
>
)
}
pub
fn
load_whole_resource
(
context
:
LoadContext
resource_task
:
&
ResourceTask
url
:
Url
pipeline_id
:
Option
<
PipelineId
>
)
-
>
Result
<
(
Metadata
Vec
<
u8
>
)
String
>
{
let
(
start_chan
start_port
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
resource_task
.
send
(
ControlMsg
:
:
Load
(
LoadData
:
:
new
(
context
url
pipeline_id
)
LoadConsumer
:
:
Channel
(
start_chan
)
None
)
)
.
unwrap
(
)
;
let
response
=
start_port
.
recv
(
)
.
unwrap
(
)
;
let
mut
buf
=
vec
!
(
)
;
loop
{
match
response
.
progress_port
.
recv
(
)
.
unwrap
(
)
{
ProgressMsg
:
:
Payload
(
data
)
=
>
buf
.
extend_from_slice
(
&
data
)
ProgressMsg
:
:
Done
(
Ok
(
(
)
)
)
=
>
return
Ok
(
(
response
.
metadata
buf
)
)
ProgressMsg
:
:
Done
(
Err
(
e
)
)
=
>
return
Err
(
e
)
}
}
}
pub
fn
unwrap_websocket_protocol
(
wsp
:
Option
<
&
header
:
:
WebSocketProtocol
>
)
-
>
Option
<
&
str
>
{
wsp
.
and_then
(
|
protocol_list
|
protocol_list
.
get
(
0
)
.
map
(
|
protocol
|
protocol
.
as_ref
(
)
)
)
}
#
[
derive
(
Clone
PartialEq
Eq
Copy
Hash
Debug
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
ResourceId
(
pub
u32
)
;
