#
!
[
deny
(
unsafe_code
)
]
extern
crate
cookie
as
cookie_rs
;
extern
crate
hyper
;
extern
crate
hyper_serde
;
extern
crate
image
as
piston_image
;
extern
crate
ipc_channel
;
#
[
macro_use
]
extern
crate
lazy_static
;
#
[
macro_use
]
extern
crate
log
;
#
[
macro_use
]
extern
crate
malloc_size_of
;
#
[
macro_use
]
extern
crate
malloc_size_of_derive
;
extern
crate
msg
;
extern
crate
num_traits
;
#
[
macro_use
]
extern
crate
serde
;
extern
crate
servo_config
;
extern
crate
servo_url
;
extern
crate
url
;
extern
crate
uuid
;
extern
crate
webrender_api
;
use
cookie_rs
:
:
Cookie
;
use
filemanager_thread
:
:
FileManagerThreadMsg
;
use
hyper
:
:
Error
as
HyperError
;
use
hyper
:
:
header
:
:
{
ContentType
Headers
ReferrerPolicy
as
ReferrerPolicyHeader
}
;
use
hyper
:
:
http
:
:
RawStatus
;
use
hyper
:
:
mime
:
:
{
Attr
Mime
}
;
use
hyper_serde
:
:
Serde
;
use
ipc_channel
:
:
Error
as
IpcError
;
use
ipc_channel
:
:
ipc
:
:
{
self
IpcReceiver
IpcSender
}
;
use
ipc_channel
:
:
router
:
:
ROUTER
;
use
request
:
:
{
Request
RequestInit
}
;
use
response
:
:
{
HttpsState
Response
ResponseInit
}
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
error
:
:
Error
;
use
storage_thread
:
:
StorageThreadMsg
;
pub
mod
blob_url_store
;
pub
mod
filemanager_thread
;
pub
mod
image_cache
;
pub
mod
net_error_list
;
pub
mod
pub_domains
;
pub
mod
request
;
pub
mod
response
;
pub
mod
storage_thread
;
pub
mod
image
{
pub
mod
base
;
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
enum
LoadContext
{
Browsing
Image
AudioVideo
Plugin
Style
Script
Font
TextTrack
CacheManifest
}
#
[
derive
(
Clone
Debug
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
CustomResponse
{
#
[
ignore_malloc_size_of
=
"
Defined
in
hyper
"
]
#
[
serde
(
deserialize_with
=
"
:
:
hyper_serde
:
:
deserialize
"
serialize_with
=
"
:
:
hyper_serde
:
:
serialize
"
)
]
pub
headers
:
Headers
#
[
ignore_malloc_size_of
=
"
Defined
in
hyper
"
]
#
[
serde
(
deserialize_with
=
"
:
:
hyper_serde
:
:
deserialize
"
serialize_with
=
"
:
:
hyper_serde
:
:
serialize
"
)
]
pub
raw_status
:
RawStatus
pub
body
:
Vec
<
u8
>
}
impl
CustomResponse
{
pub
fn
new
(
headers
:
Headers
raw_status
:
RawStatus
body
:
Vec
<
u8
>
)
-
>
CustomResponse
{
CustomResponse
{
headers
:
headers
raw_status
:
raw_status
body
:
body
}
}
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
CustomResponseMediator
{
pub
response_chan
:
IpcSender
<
Option
<
CustomResponse
>
>
pub
load_url
:
ServoUrl
}
#
[
derive
(
Clone
Copy
Debug
Deserialize
MallocSizeOf
Serialize
)
]
pub
enum
ReferrerPolicy
{
NoReferrer
NoReferrerWhenDowngrade
Origin
SameOrigin
OriginWhenCrossOrigin
UnsafeUrl
StrictOrigin
StrictOriginWhenCrossOrigin
}
impl
<
'
a
>
From
<
&
'
a
ReferrerPolicyHeader
>
for
ReferrerPolicy
{
fn
from
(
policy
:
&
'
a
ReferrerPolicyHeader
)
-
>
Self
{
match
*
policy
{
ReferrerPolicyHeader
:
:
NoReferrer
=
>
ReferrerPolicy
:
:
NoReferrer
ReferrerPolicyHeader
:
:
NoReferrerWhenDowngrade
=
>
ReferrerPolicy
:
:
NoReferrerWhenDowngrade
ReferrerPolicyHeader
:
:
SameOrigin
=
>
ReferrerPolicy
:
:
SameOrigin
ReferrerPolicyHeader
:
:
Origin
=
>
ReferrerPolicy
:
:
Origin
ReferrerPolicyHeader
:
:
OriginWhenCrossOrigin
=
>
ReferrerPolicy
:
:
OriginWhenCrossOrigin
ReferrerPolicyHeader
:
:
UnsafeUrl
=
>
ReferrerPolicy
:
:
UnsafeUrl
ReferrerPolicyHeader
:
:
StrictOrigin
=
>
ReferrerPolicy
:
:
StrictOrigin
ReferrerPolicyHeader
:
:
StrictOriginWhenCrossOrigin
=
>
ReferrerPolicy
:
:
StrictOriginWhenCrossOrigin
}
}
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
FetchResponseMsg
{
ProcessRequestBody
ProcessRequestEOF
ProcessResponse
(
Result
<
FetchMetadata
NetworkError
>
)
ProcessResponseChunk
(
Vec
<
u8
>
)
ProcessResponseEOF
(
Result
<
(
)
NetworkError
>
)
}
pub
trait
FetchTaskTarget
{
fn
process_request_body
(
&
mut
self
request
:
&
Request
)
;
fn
process_request_eof
(
&
mut
self
request
:
&
Request
)
;
fn
process_response
(
&
mut
self
response
:
&
Response
)
;
fn
process_response_chunk
(
&
mut
self
chunk
:
Vec
<
u8
>
)
;
fn
process_response_eof
(
&
mut
self
response
:
&
Response
)
;
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
enum
FilteredMetadata
{
Basic
(
Metadata
)
Cors
(
Metadata
)
Opaque
OpaqueRedirect
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
enum
FetchMetadata
{
Unfiltered
(
Metadata
)
Filtered
{
filtered
:
FilteredMetadata
unsafe_
:
Metadata
}
}
pub
trait
FetchResponseListener
{
fn
process_request_body
(
&
mut
self
)
;
fn
process_request_eof
(
&
mut
self
)
;
fn
process_response
(
&
mut
self
metadata
:
Result
<
FetchMetadata
NetworkError
>
)
;
fn
process_response_chunk
(
&
mut
self
chunk
:
Vec
<
u8
>
)
;
fn
process_response_eof
(
&
mut
self
response
:
Result
<
(
)
NetworkError
>
)
;
}
impl
FetchTaskTarget
for
IpcSender
<
FetchResponseMsg
>
{
fn
process_request_body
(
&
mut
self
_
:
&
Request
)
{
let
_
=
self
.
send
(
FetchResponseMsg
:
:
ProcessRequestBody
)
;
}
fn
process_request_eof
(
&
mut
self
_
:
&
Request
)
{
let
_
=
self
.
send
(
FetchResponseMsg
:
:
ProcessRequestEOF
)
;
}
fn
process_response
(
&
mut
self
response
:
&
Response
)
{
let
_
=
self
.
send
(
FetchResponseMsg
:
:
ProcessResponse
(
response
.
metadata
(
)
)
)
;
}
fn
process_response_chunk
(
&
mut
self
chunk
:
Vec
<
u8
>
)
{
let
_
=
self
.
send
(
FetchResponseMsg
:
:
ProcessResponseChunk
(
chunk
)
)
;
}
fn
process_response_eof
(
&
mut
self
response
:
&
Response
)
{
if
let
Some
(
e
)
=
response
.
get_network_error
(
)
{
let
_
=
self
.
send
(
FetchResponseMsg
:
:
ProcessResponseEOF
(
Err
(
e
.
clone
(
)
)
)
)
;
}
else
{
let
_
=
self
.
send
(
FetchResponseMsg
:
:
ProcessResponseEOF
(
Ok
(
(
)
)
)
)
;
}
}
}
pub
trait
Action
<
Listener
>
{
fn
process
(
self
listener
:
&
mut
Listener
)
;
}
impl
<
T
:
FetchResponseListener
>
Action
<
T
>
for
FetchResponseMsg
{
fn
process
(
self
listener
:
&
mut
T
)
{
match
self
{
FetchResponseMsg
:
:
ProcessRequestBody
=
>
listener
.
process_request_body
(
)
FetchResponseMsg
:
:
ProcessRequestEOF
=
>
listener
.
process_request_eof
(
)
FetchResponseMsg
:
:
ProcessResponse
(
meta
)
=
>
listener
.
process_response
(
meta
)
FetchResponseMsg
:
:
ProcessResponseChunk
(
data
)
=
>
listener
.
process_response_chunk
(
data
)
FetchResponseMsg
:
:
ProcessResponseEOF
(
data
)
=
>
listener
.
process_response_eof
(
data
)
}
}
}
pub
type
CoreResourceThread
=
IpcSender
<
CoreResourceMsg
>
;
pub
type
IpcSendResult
=
Result
<
(
)
IpcError
>
;
pub
trait
IpcSend
<
T
>
where
T
:
serde
:
:
Serialize
+
for
<
'
de
>
serde
:
:
Deserialize
<
'
de
>
{
fn
send
(
&
self
T
)
-
>
IpcSendResult
;
fn
sender
(
&
self
)
-
>
IpcSender
<
T
>
;
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
ResourceThreads
{
core_thread
:
CoreResourceThread
storage_thread
:
IpcSender
<
StorageThreadMsg
>
}
impl
ResourceThreads
{
pub
fn
new
(
c
:
CoreResourceThread
s
:
IpcSender
<
StorageThreadMsg
>
)
-
>
ResourceThreads
{
ResourceThreads
{
core_thread
:
c
storage_thread
:
s
}
}
}
impl
IpcSend
<
CoreResourceMsg
>
for
ResourceThreads
{
fn
send
(
&
self
msg
:
CoreResourceMsg
)
-
>
IpcSendResult
{
self
.
core_thread
.
send
(
msg
)
}
fn
sender
(
&
self
)
-
>
IpcSender
<
CoreResourceMsg
>
{
self
.
core_thread
.
clone
(
)
}
}
impl
IpcSend
<
StorageThreadMsg
>
for
ResourceThreads
{
fn
send
(
&
self
msg
:
StorageThreadMsg
)
-
>
IpcSendResult
{
self
.
storage_thread
.
send
(
msg
)
}
fn
sender
(
&
self
)
-
>
IpcSender
<
StorageThreadMsg
>
{
self
.
storage_thread
.
clone
(
)
}
}
malloc_size_of_is_0
!
(
ResourceThreads
)
;
#
[
derive
(
Clone
Copy
Deserialize
PartialEq
Serialize
)
]
pub
enum
IncludeSubdomains
{
Included
NotIncluded
}
#
[
derive
(
Deserialize
MallocSizeOf
Serialize
)
]
pub
enum
MessageData
{
Text
(
String
)
Binary
(
Vec
<
u8
>
)
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
WebSocketDomAction
{
SendMessage
(
MessageData
)
Close
(
Option
<
u16
>
Option
<
String
>
)
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
WebSocketNetworkEvent
{
ConnectionEstablished
{
protocol_in_use
:
Option
<
String
>
}
MessageReceived
(
MessageData
)
Close
(
Option
<
u16
>
String
)
Fail
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
FetchChannels
{
ResponseMsg
(
IpcSender
<
FetchResponseMsg
>
)
WebSocket
{
event_sender
:
IpcSender
<
WebSocketNetworkEvent
>
action_receiver
:
IpcReceiver
<
WebSocketDomAction
>
}
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
CoreResourceMsg
{
Fetch
(
RequestInit
FetchChannels
)
FetchRedirect
(
RequestInit
ResponseInit
IpcSender
<
FetchResponseMsg
>
)
SetCookieForUrl
(
ServoUrl
Serde
<
Cookie
<
'
static
>
>
CookieSource
)
SetCookiesForUrl
(
ServoUrl
Vec
<
Serde
<
Cookie
<
'
static
>
>
>
CookieSource
)
GetCookiesForUrl
(
ServoUrl
IpcSender
<
Option
<
String
>
>
CookieSource
)
GetCookiesDataForUrl
(
ServoUrl
IpcSender
<
Vec
<
Serde
<
Cookie
<
'
static
>
>
>
>
CookieSource
)
Cancel
(
ResourceId
)
Synchronize
(
IpcSender
<
(
)
>
)
NetworkMediator
(
IpcSender
<
CustomResponseMediator
>
)
ToFileManager
(
FileManagerThreadMsg
)
Exit
(
IpcSender
<
(
)
>
)
}
pub
fn
fetch_async
<
F
>
(
request
:
RequestInit
core_resource_thread
:
&
CoreResourceThread
f
:
F
)
where
F
:
Fn
(
FetchResponseMsg
)
+
Send
+
'
static
{
let
(
action_sender
action_receiver
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
ROUTER
.
add_route
(
action_receiver
.
to_opaque
(
)
Box
:
:
new
(
move
|
message
|
f
(
message
.
to
(
)
.
unwrap
(
)
)
)
)
;
core_resource_thread
.
send
(
CoreResourceMsg
:
:
Fetch
(
request
FetchChannels
:
:
ResponseMsg
(
action_sender
)
)
)
.
unwrap
(
)
;
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
ResourceCorsData
{
pub
preflight
:
bool
pub
origin
:
ServoUrl
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
Metadata
{
pub
final_url
:
ServoUrl
pub
location_url
:
Option
<
Result
<
ServoUrl
String
>
>
#
[
ignore_malloc_size_of
=
"
Defined
in
hyper
"
]
pub
content_type
:
Option
<
Serde
<
ContentType
>
>
pub
charset
:
Option
<
String
>
#
[
ignore_malloc_size_of
=
"
Defined
in
hyper
"
]
pub
headers
:
Option
<
Serde
<
Headers
>
>
pub
status
:
Option
<
(
u16
Vec
<
u8
>
)
>
pub
https_state
:
HttpsState
pub
referrer
:
Option
<
ServoUrl
>
pub
referrer_policy
:
Option
<
ReferrerPolicy
>
}
impl
Metadata
{
pub
fn
default
(
url
:
ServoUrl
)
-
>
Self
{
Metadata
{
final_url
:
url
location_url
:
None
content_type
:
None
charset
:
None
headers
:
None
status
:
Some
(
(
200
b
"
OK
"
.
to_vec
(
)
)
)
https_state
:
HttpsState
:
:
None
referrer
:
None
referrer_policy
:
None
}
}
pub
fn
set_content_type
(
&
mut
self
content_type
:
Option
<
&
Mime
>
)
{
if
self
.
headers
.
is_none
(
)
{
self
.
headers
=
Some
(
Serde
(
Headers
:
:
new
(
)
)
)
;
}
if
let
Some
(
mime
)
=
content_type
{
self
.
headers
.
as_mut
(
)
.
unwrap
(
)
.
set
(
ContentType
(
mime
.
clone
(
)
)
)
;
self
.
content_type
=
Some
(
Serde
(
ContentType
(
mime
.
clone
(
)
)
)
)
;
let
Mime
(
_
_
ref
parameters
)
=
*
mime
;
for
&
(
ref
k
ref
v
)
in
parameters
{
if
Attr
:
:
Charset
=
=
*
k
{
self
.
charset
=
Some
(
v
.
to_string
(
)
)
;
}
}
}
}
}
#
[
derive
(
Clone
Copy
Deserialize
PartialEq
Serialize
)
]
pub
enum
CookieSource
{
HTTP
NonHTTP
}
pub
fn
load_whole_resource
(
request
:
RequestInit
core_resource_thread
:
&
CoreResourceThread
)
-
>
Result
<
(
Metadata
Vec
<
u8
>
)
NetworkError
>
{
let
(
action_sender
action_receiver
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
core_resource_thread
.
send
(
CoreResourceMsg
:
:
Fetch
(
request
FetchChannels
:
:
ResponseMsg
(
action_sender
)
)
)
.
unwrap
(
)
;
let
mut
buf
=
vec
!
[
]
;
let
mut
metadata
=
None
;
loop
{
match
action_receiver
.
recv
(
)
.
unwrap
(
)
{
FetchResponseMsg
:
:
ProcessRequestBody
|
FetchResponseMsg
:
:
ProcessRequestEOF
=
>
(
)
FetchResponseMsg
:
:
ProcessResponse
(
Ok
(
m
)
)
=
>
{
metadata
=
Some
(
match
m
{
FetchMetadata
:
:
Unfiltered
(
m
)
=
>
m
FetchMetadata
:
:
Filtered
{
unsafe_
.
.
}
=
>
unsafe_
}
)
}
FetchResponseMsg
:
:
ProcessResponseChunk
(
data
)
=
>
buf
.
extend_from_slice
(
&
data
)
FetchResponseMsg
:
:
ProcessResponseEOF
(
Ok
(
(
)
)
)
=
>
return
Ok
(
(
metadata
.
unwrap
(
)
buf
)
)
FetchResponseMsg
:
:
ProcessResponse
(
Err
(
e
)
)
|
FetchResponseMsg
:
:
ProcessResponseEOF
(
Err
(
e
)
)
=
>
return
Err
(
e
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
Deserialize
Eq
Hash
MallocSizeOf
PartialEq
Serialize
)
]
pub
struct
ResourceId
(
pub
u32
)
;
#
[
derive
(
Clone
Debug
Deserialize
Eq
MallocSizeOf
PartialEq
Serialize
)
]
pub
enum
NetworkError
{
Internal
(
String
)
LoadCancelled
SslValidation
(
ServoUrl
String
)
}
impl
NetworkError
{
pub
fn
from_hyper_error
(
url
:
&
ServoUrl
error
:
HyperError
)
-
>
Self
{
if
let
HyperError
:
:
Ssl
(
ref
ssl_error
)
=
error
{
return
NetworkError
:
:
from_ssl_error
(
url
&
*
*
ssl_error
)
;
}
NetworkError
:
:
Internal
(
error
.
description
(
)
.
to_owned
(
)
)
}
pub
fn
from_ssl_error
(
url
:
&
ServoUrl
error
:
&
Error
)
-
>
Self
{
NetworkError
:
:
SslValidation
(
url
.
clone
(
)
error
.
description
(
)
.
to_owned
(
)
)
}
}
pub
fn
trim_http_whitespace
(
mut
slice
:
&
[
u8
]
)
-
>
&
[
u8
]
{
const
HTTP_WS_BYTES
:
&
'
static
[
u8
]
=
b
"
\
x09
\
x0A
\
x0D
\
x20
"
;
loop
{
match
slice
.
split_first
(
)
{
Some
(
(
first
remainder
)
)
if
HTTP_WS_BYTES
.
contains
(
first
)
=
>
slice
=
remainder
_
=
>
break
}
}
loop
{
match
slice
.
split_last
(
)
{
Some
(
(
last
remainder
)
)
if
HTTP_WS_BYTES
.
contains
(
last
)
=
>
slice
=
remainder
_
=
>
break
}
}
slice
}
