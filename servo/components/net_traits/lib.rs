#
!
[
feature
(
box_syntax
)
]
#
!
[
feature
(
custom_derive
)
]
#
!
[
feature
(
plugin
)
]
#
!
[
feature
(
slice_patterns
)
]
#
!
[
feature
(
step_by
)
]
#
!
[
feature
(
vec_push_all
)
]
#
!
[
plugin
(
serde_macros
)
]
extern
crate
euclid
;
extern
crate
hyper
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
png
;
extern
crate
serde
;
extern
crate
stb_image
;
extern
crate
url
;
extern
crate
util
;
extern
crate
msg
;
use
hyper
:
:
header
:
:
{
ContentType
Headers
}
;
use
hyper
:
:
http
:
:
RawStatus
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
mime
:
:
{
Mime
Attr
}
;
use
msg
:
:
constellation_msg
:
:
{
PipelineId
}
;
use
url
:
:
Url
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Receiver
Sender
}
;
use
std
:
:
thread
;
pub
mod
image_cache_task
;
pub
mod
storage_task
;
pub
mod
image
{
pub
mod
base
;
}
#
[
derive
(
Clone
)
]
pub
struct
LoadData
{
pub
url
:
Url
pub
method
:
Method
pub
headers
:
Headers
pub
preserved_headers
:
Headers
pub
data
:
Option
<
Vec
<
u8
>
>
pub
cors
:
Option
<
ResourceCORSData
>
pub
pipeline_id
:
Option
<
PipelineId
>
}
impl
LoadData
{
pub
fn
new
(
url
:
Url
id
:
Option
<
PipelineId
>
)
-
>
LoadData
{
LoadData
{
url
:
url
method
:
Method
:
:
Get
headers
:
Headers
:
:
new
(
)
preserved_headers
:
Headers
:
:
new
(
)
data
:
None
cors
:
None
pipeline_id
:
id
}
}
}
pub
trait
AsyncResponseListener
{
fn
headers_available
(
&
self
metadata
:
Metadata
)
;
fn
data_available
(
&
self
payload
:
Vec
<
u8
>
)
;
fn
response_complete
(
&
self
status
:
Result
<
(
)
String
>
)
;
}
pub
enum
ResponseAction
{
HeadersAvailable
(
Metadata
)
DataAvailable
(
Vec
<
u8
>
)
ResponseComplete
(
Result
<
(
)
String
>
)
}
impl
ResponseAction
{
pub
fn
process
(
self
listener
:
&
AsyncResponseListener
)
{
match
self
{
ResponseAction
:
:
HeadersAvailable
(
m
)
=
>
listener
.
headers_available
(
m
)
ResponseAction
:
:
DataAvailable
(
d
)
=
>
listener
.
data_available
(
d
)
ResponseAction
:
:
ResponseComplete
(
r
)
=
>
listener
.
response_complete
(
r
)
}
}
}
pub
trait
AsyncResponseTarget
{
fn
invoke_with_listener
(
&
self
action
:
ResponseAction
)
;
}
pub
enum
LoadConsumer
{
Channel
(
Sender
<
LoadResponse
>
)
Listener
(
Box
<
AsyncResponseTarget
+
Send
>
)
}
pub
type
ResourceTask
=
Sender
<
ControlMsg
>
;
pub
enum
ControlMsg
{
Load
(
LoadData
LoadConsumer
)
SetCookiesForUrl
(
Url
String
CookieSource
)
GetCookiesForUrl
(
Url
Sender
<
Option
<
String
>
>
CookieSource
)
Exit
}
pub
struct
PendingAsyncLoad
{
resource_task
:
ResourceTask
url
:
Url
pipeline
:
Option
<
PipelineId
>
guard
:
PendingLoadGuard
}
struct
PendingLoadGuard
{
loaded
:
bool
}
impl
PendingLoadGuard
{
fn
neuter
(
&
mut
self
)
{
self
.
loaded
=
true
;
}
}
impl
Drop
for
PendingLoadGuard
{
fn
drop
(
&
mut
self
)
{
if
!
thread
:
:
panicking
(
)
{
assert
!
(
self
.
loaded
)
}
}
}
impl
PendingAsyncLoad
{
pub
fn
new
(
resource_task
:
ResourceTask
url
:
Url
pipeline
:
Option
<
PipelineId
>
)
-
>
PendingAsyncLoad
{
PendingAsyncLoad
{
resource_task
:
resource_task
url
:
url
pipeline
:
pipeline
guard
:
PendingLoadGuard
{
loaded
:
false
}
}
}
pub
fn
load
(
mut
self
)
-
>
Receiver
<
LoadResponse
>
{
self
.
guard
.
neuter
(
)
;
let
load_data
=
LoadData
:
:
new
(
self
.
url
self
.
pipeline
)
;
let
(
sender
receiver
)
=
channel
(
)
;
let
consumer
=
LoadConsumer
:
:
Channel
(
sender
)
;
self
.
resource_task
.
send
(
ControlMsg
:
:
Load
(
load_data
consumer
)
)
.
unwrap
(
)
;
receiver
}
pub
fn
load_async
(
mut
self
listener
:
Box
<
AsyncResponseTarget
+
Send
>
)
{
self
.
guard
.
neuter
(
)
;
let
load_data
=
LoadData
:
:
new
(
self
.
url
self
.
pipeline
)
;
let
consumer
=
LoadConsumer
:
:
Listener
(
listener
)
;
self
.
resource_task
.
send
(
ControlMsg
:
:
Load
(
load_data
consumer
)
)
.
unwrap
(
)
;
}
}
pub
struct
LoadResponse
{
pub
metadata
:
Metadata
pub
progress_port
:
Receiver
<
ProgressMsg
>
}
#
[
derive
(
Clone
)
]
pub
struct
ResourceCORSData
{
pub
preflight
:
bool
pub
origin
:
Url
}
#
[
derive
(
Clone
)
]
pub
struct
Metadata
{
pub
final_url
:
Url
pub
content_type
:
Option
<
(
ContentType
)
>
pub
charset
:
Option
<
String
>
pub
headers
:
Option
<
Headers
>
pub
status
:
Option
<
RawStatus
>
}
impl
Metadata
{
pub
fn
default
(
url
:
Url
)
-
>
Self
{
Metadata
{
final_url
:
url
content_type
:
None
charset
:
None
headers
:
None
status
:
Some
(
RawStatus
(
200
"
OK
"
.
into
(
)
)
)
}
}
pub
fn
set_content_type
(
&
mut
self
content_type
:
Option
<
&
Mime
>
)
{
match
content_type
{
None
=
>
(
)
Some
(
mime
)
=
>
{
self
.
content_type
=
Some
(
ContentType
(
mime
.
clone
(
)
)
)
;
let
&
Mime
(
_
_
ref
parameters
)
=
mime
;
for
&
(
ref
k
ref
v
)
in
parameters
.
iter
(
)
{
if
&
Attr
:
:
Charset
=
=
k
{
self
.
charset
=
Some
(
v
.
to_string
(
)
)
;
}
}
}
}
}
}
#
[
derive
(
PartialEq
Copy
Clone
)
]
pub
enum
CookieSource
{
HTTP
NonHTTP
}
#
[
derive
(
PartialEq
Debug
)
]
pub
enum
ProgressMsg
{
Payload
(
Vec
<
u8
>
)
Done
(
Result
<
(
)
String
>
)
}
pub
fn
load_whole_resource
(
resource_task
:
&
ResourceTask
url
:
Url
)
-
>
Result
<
(
Metadata
Vec
<
u8
>
)
String
>
{
let
(
start_chan
start_port
)
=
channel
(
)
;
resource_task
.
send
(
ControlMsg
:
:
Load
(
LoadData
:
:
new
(
url
None
)
LoadConsumer
:
:
Channel
(
start_chan
)
)
)
.
unwrap
(
)
;
let
response
=
start_port
.
recv
(
)
.
unwrap
(
)
;
let
mut
buf
=
vec
!
(
)
;
loop
{
match
response
.
progress_port
.
recv
(
)
.
unwrap
(
)
{
ProgressMsg
:
:
Payload
(
data
)
=
>
buf
.
push_all
(
&
data
)
ProgressMsg
:
:
Done
(
Ok
(
(
)
)
)
=
>
return
Ok
(
(
response
.
metadata
buf
)
)
ProgressMsg
:
:
Done
(
Err
(
e
)
)
=
>
return
Err
(
e
)
}
}
}
pub
fn
load_bytes_iter
(
pending
:
PendingAsyncLoad
)
-
>
(
Metadata
ProgressMsgPortIterator
)
{
let
input_port
=
pending
.
load
(
)
;
let
response
=
input_port
.
recv
(
)
.
unwrap
(
)
;
let
iter
=
ProgressMsgPortIterator
{
progress_port
:
response
.
progress_port
}
;
(
response
.
metadata
iter
)
}
pub
struct
ProgressMsgPortIterator
{
progress_port
:
Receiver
<
ProgressMsg
>
}
impl
Iterator
for
ProgressMsgPortIterator
{
type
Item
=
Vec
<
u8
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Vec
<
u8
>
>
{
match
self
.
progress_port
.
recv
(
)
.
unwrap
(
)
{
ProgressMsg
:
:
Payload
(
data
)
=
>
Some
(
data
)
ProgressMsg
:
:
Done
(
Ok
(
(
)
)
)
=
>
None
ProgressMsg
:
:
Done
(
Err
(
e
)
)
=
>
{
error
!
(
"
error
receiving
bytes
:
{
}
"
e
)
;
None
}
}
}
}
