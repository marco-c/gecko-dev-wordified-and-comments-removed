#
!
[
feature
(
box_syntax
)
]
#
!
[
feature
(
custom_attribute
)
]
#
!
[
feature
(
custom_derive
)
]
#
!
[
feature
(
plugin
)
]
#
!
[
feature
(
slice_patterns
)
]
#
!
[
feature
(
step_by
)
]
#
!
[
plugin
(
heapsize_plugin
serde_macros
)
]
#
!
[
deny
(
unsafe_code
)
]
extern
crate
heapsize
;
extern
crate
hyper
;
extern
crate
image
as
piston_image
;
extern
crate
ipc_channel
;
#
[
allow
(
unused_extern_crates
)
]
#
[
macro_use
]
extern
crate
lazy_static
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
msg
;
extern
crate
serde
;
extern
crate
url
;
extern
crate
util
;
extern
crate
uuid
;
extern
crate
websocket
;
use
heapsize
:
:
HeapSizeOf
;
use
hyper
:
:
header
:
:
{
ContentType
Headers
}
;
use
hyper
:
:
http
:
:
RawStatus
;
use
hyper
:
:
method
:
:
Method
;
use
hyper
:
:
mime
:
:
{
Attr
Mime
}
;
use
ipc_channel
:
:
ipc
:
:
{
self
IpcReceiver
IpcSender
}
;
use
msg
:
:
constellation_msg
:
:
{
PipelineId
ReferrerPolicy
}
;
use
std
:
:
io
:
:
Error
as
IOError
;
use
std
:
:
sync
:
:
mpsc
:
:
Sender
;
use
std
:
:
thread
;
use
storage_thread
:
:
StorageThreadMsg
;
use
url
:
:
Url
;
use
websocket
:
:
header
;
pub
mod
bluetooth_scanfilter
;
pub
mod
bluetooth_thread
;
pub
mod
filemanager_thread
;
pub
mod
hosts
;
pub
mod
image_cache_thread
;
pub
mod
net_error_list
;
pub
mod
request
;
pub
mod
response
;
pub
mod
storage_thread
;
pub
mod
image
{
pub
mod
base
;
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
LoadContext
{
Browsing
Image
AudioVideo
Plugin
Style
Script
Font
TextTrack
CacheManifest
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
LoadData
{
pub
url
:
Url
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
pub
method
:
Method
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
pub
headers
:
Headers
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
pub
preserved_headers
:
Headers
pub
data
:
Option
<
Vec
<
u8
>
>
pub
cors
:
Option
<
ResourceCORSData
>
pub
pipeline_id
:
Option
<
PipelineId
>
pub
credentials_flag
:
bool
pub
context
:
LoadContext
pub
referrer_policy
:
Option
<
ReferrerPolicy
>
pub
referrer_url
:
Option
<
Url
>
}
impl
LoadData
{
pub
fn
new
(
context
:
LoadContext
url
:
Url
id
:
Option
<
PipelineId
>
referrer_policy
:
Option
<
ReferrerPolicy
>
referrer_url
:
Option
<
Url
>
)
-
>
LoadData
{
LoadData
{
url
:
url
method
:
Method
:
:
Get
headers
:
Headers
:
:
new
(
)
preserved_headers
:
Headers
:
:
new
(
)
data
:
None
cors
:
None
pipeline_id
:
id
credentials_flag
:
true
context
:
context
referrer_policy
:
referrer_policy
referrer_url
:
referrer_url
}
}
}
pub
trait
AsyncFetchListener
{
fn
response_available
(
&
self
response
:
response
:
:
Response
)
;
}
pub
trait
AsyncResponseListener
{
fn
headers_available
(
&
mut
self
metadata
:
Result
<
Metadata
NetworkError
>
)
;
fn
data_available
(
&
mut
self
payload
:
Vec
<
u8
>
)
;
fn
response_complete
(
&
mut
self
status
:
Result
<
(
)
NetworkError
>
)
;
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
ResponseAction
{
HeadersAvailable
(
Result
<
Metadata
NetworkError
>
)
DataAvailable
(
Vec
<
u8
>
)
ResponseComplete
(
Result
<
(
)
NetworkError
>
)
}
impl
ResponseAction
{
pub
fn
process
(
self
listener
:
&
mut
AsyncResponseListener
)
{
match
self
{
ResponseAction
:
:
HeadersAvailable
(
m
)
=
>
listener
.
headers_available
(
m
)
ResponseAction
:
:
DataAvailable
(
d
)
=
>
listener
.
data_available
(
d
)
ResponseAction
:
:
ResponseComplete
(
r
)
=
>
listener
.
response_complete
(
r
)
}
}
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
AsyncResponseTarget
{
pub
sender
:
IpcSender
<
ResponseAction
>
}
impl
AsyncResponseTarget
{
pub
fn
invoke_with_listener
(
&
self
action
:
ResponseAction
)
{
self
.
sender
.
send
(
action
)
.
unwrap
(
)
}
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
LoadConsumer
{
Channel
(
IpcSender
<
LoadResponse
>
)
Listener
(
AsyncResponseTarget
)
}
pub
type
CoreResourceThread
=
IpcSender
<
CoreResourceMsg
>
;
pub
type
IpcSendResult
=
Result
<
(
)
IOError
>
;
pub
trait
IpcSend
<
T
>
where
T
:
serde
:
:
Serialize
+
serde
:
:
Deserialize
{
fn
send
(
&
self
T
)
-
>
IpcSendResult
;
fn
sender
(
&
self
)
-
>
IpcSender
<
T
>
;
}
#
[
derive
(
Clone
Serialize
Deserialize
)
]
pub
struct
ResourceThreads
{
core_thread
:
CoreResourceThread
storage_thread
:
IpcSender
<
StorageThreadMsg
>
}
impl
ResourceThreads
{
pub
fn
new
(
c
:
CoreResourceThread
s
:
IpcSender
<
StorageThreadMsg
>
)
-
>
ResourceThreads
{
ResourceThreads
{
core_thread
:
c
storage_thread
:
s
}
}
}
impl
IpcSend
<
CoreResourceMsg
>
for
ResourceThreads
{
fn
send
(
&
self
msg
:
CoreResourceMsg
)
-
>
IpcSendResult
{
self
.
core_thread
.
send
(
msg
)
}
fn
sender
(
&
self
)
-
>
IpcSender
<
CoreResourceMsg
>
{
self
.
core_thread
.
clone
(
)
}
}
impl
IpcSend
<
StorageThreadMsg
>
for
ResourceThreads
{
fn
send
(
&
self
msg
:
StorageThreadMsg
)
-
>
IpcSendResult
{
self
.
storage_thread
.
send
(
msg
)
}
fn
sender
(
&
self
)
-
>
IpcSender
<
StorageThreadMsg
>
{
self
.
storage_thread
.
clone
(
)
}
}
impl
HeapSizeOf
for
ResourceThreads
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
#
[
derive
(
PartialEq
Copy
Clone
Deserialize
Serialize
)
]
pub
enum
IncludeSubdomains
{
Included
NotIncluded
}
#
[
derive
(
HeapSizeOf
Deserialize
Serialize
)
]
pub
enum
MessageData
{
Text
(
String
)
Binary
(
Vec
<
u8
>
)
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
WebSocketDomAction
{
SendMessage
(
MessageData
)
Close
(
Option
<
u16
>
Option
<
String
>
)
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
WebSocketNetworkEvent
{
ConnectionEstablished
(
header
:
:
Headers
Vec
<
String
>
)
MessageReceived
(
MessageData
)
Close
(
Option
<
u16
>
String
)
Fail
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
WebSocketCommunicate
{
pub
event_sender
:
IpcSender
<
WebSocketNetworkEvent
>
pub
action_receiver
:
IpcReceiver
<
WebSocketDomAction
>
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
WebSocketConnectData
{
pub
resource_url
:
Url
pub
origin
:
String
pub
protocols
:
Vec
<
String
>
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
CoreResourceMsg
{
Load
(
LoadData
LoadConsumer
Option
<
IpcSender
<
ResourceId
>
>
)
WebsocketConnect
(
WebSocketCommunicate
WebSocketConnectData
)
SetCookiesForUrl
(
Url
String
CookieSource
)
GetCookiesForUrl
(
Url
IpcSender
<
Option
<
String
>
>
CookieSource
)
Cancel
(
ResourceId
)
Synchronize
(
IpcSender
<
(
)
>
)
Exit
}
pub
struct
PendingAsyncLoad
{
core_resource_thread
:
CoreResourceThread
url
:
Url
pipeline
:
Option
<
PipelineId
>
guard
:
PendingLoadGuard
context
:
LoadContext
referrer_policy
:
Option
<
ReferrerPolicy
>
referrer_url
:
Option
<
Url
>
}
struct
PendingLoadGuard
{
loaded
:
bool
}
impl
PendingLoadGuard
{
fn
neuter
(
&
mut
self
)
{
self
.
loaded
=
true
;
}
}
impl
Drop
for
PendingLoadGuard
{
fn
drop
(
&
mut
self
)
{
if
!
thread
:
:
panicking
(
)
{
assert
!
(
self
.
loaded
)
}
}
}
impl
PendingAsyncLoad
{
pub
fn
new
(
context
:
LoadContext
core_resource_thread
:
CoreResourceThread
url
:
Url
pipeline
:
Option
<
PipelineId
>
referrer_policy
:
Option
<
ReferrerPolicy
>
referrer_url
:
Option
<
Url
>
)
-
>
PendingAsyncLoad
{
PendingAsyncLoad
{
core_resource_thread
:
core_resource_thread
url
:
url
pipeline
:
pipeline
guard
:
PendingLoadGuard
{
loaded
:
false
}
context
:
context
referrer_policy
:
referrer_policy
referrer_url
:
referrer_url
}
}
pub
fn
load_async
(
mut
self
listener
:
AsyncResponseTarget
)
{
self
.
guard
.
neuter
(
)
;
let
load_data
=
LoadData
:
:
new
(
self
.
context
self
.
url
self
.
pipeline
self
.
referrer_policy
self
.
referrer_url
)
;
let
consumer
=
LoadConsumer
:
:
Listener
(
listener
)
;
self
.
core_resource_thread
.
send
(
CoreResourceMsg
:
:
Load
(
load_data
consumer
None
)
)
.
unwrap
(
)
;
}
}
#
[
derive
(
Serialize
Deserialize
)
]
pub
struct
LoadResponse
{
pub
metadata
:
Metadata
pub
progress_port
:
IpcReceiver
<
ProgressMsg
>
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
ResourceCORSData
{
pub
preflight
:
bool
pub
origin
:
Url
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
Metadata
{
pub
final_url
:
Url
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
pub
content_type
:
Option
<
(
ContentType
)
>
pub
charset
:
Option
<
String
>
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
pub
headers
:
Option
<
Headers
>
#
[
ignore_heap_size_of
=
"
Defined
in
hyper
"
]
pub
status
:
Option
<
RawStatus
>
pub
https_state
:
response
:
:
HttpsState
}
impl
Metadata
{
pub
fn
default
(
url
:
Url
)
-
>
Self
{
Metadata
{
final_url
:
url
content_type
:
None
charset
:
None
headers
:
None
status
:
Some
(
RawStatus
(
200
"
OK
"
.
into
(
)
)
)
https_state
:
response
:
:
HttpsState
:
:
None
}
}
pub
fn
set_content_type
(
&
mut
self
content_type
:
Option
<
&
Mime
>
)
{
match
self
.
headers
{
None
=
>
self
.
headers
=
Some
(
Headers
:
:
new
(
)
)
Some
(
_
)
=
>
(
)
}
match
content_type
{
None
=
>
(
)
Some
(
mime
)
=
>
{
if
let
Some
(
headers
)
=
self
.
headers
.
as_mut
(
)
{
headers
.
set
(
ContentType
(
mime
.
clone
(
)
)
)
;
}
self
.
content_type
=
Some
(
ContentType
(
mime
.
clone
(
)
)
)
;
let
&
Mime
(
_
_
ref
parameters
)
=
mime
;
for
&
(
ref
k
ref
v
)
in
parameters
{
if
&
Attr
:
:
Charset
=
=
k
{
self
.
charset
=
Some
(
v
.
to_string
(
)
)
;
}
}
}
}
}
}
#
[
derive
(
PartialEq
Copy
Clone
Deserialize
Serialize
)
]
pub
enum
CookieSource
{
HTTP
NonHTTP
}
#
[
derive
(
PartialEq
Debug
Deserialize
Serialize
)
]
pub
enum
ProgressMsg
{
Payload
(
Vec
<
u8
>
)
Done
(
Result
<
(
)
NetworkError
>
)
}
pub
fn
load_whole_resource
(
context
:
LoadContext
core_resource_thread
:
&
CoreResourceThread
url
:
Url
pipeline_id
:
Option
<
PipelineId
>
)
-
>
Result
<
(
Metadata
Vec
<
u8
>
)
NetworkError
>
{
let
(
start_chan
start_port
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
core_resource_thread
.
send
(
CoreResourceMsg
:
:
Load
(
LoadData
:
:
new
(
context
url
pipeline_id
None
None
)
LoadConsumer
:
:
Channel
(
start_chan
)
None
)
)
.
unwrap
(
)
;
let
response
=
start_port
.
recv
(
)
.
unwrap
(
)
;
let
mut
buf
=
vec
!
(
)
;
loop
{
match
response
.
progress_port
.
recv
(
)
.
unwrap
(
)
{
ProgressMsg
:
:
Payload
(
data
)
=
>
buf
.
extend_from_slice
(
&
data
)
ProgressMsg
:
:
Done
(
Ok
(
(
)
)
)
=
>
return
Ok
(
(
response
.
metadata
buf
)
)
ProgressMsg
:
:
Done
(
Err
(
e
)
)
=
>
return
Err
(
e
)
}
}
}
pub
fn
unwrap_websocket_protocol
(
wsp
:
Option
<
&
header
:
:
WebSocketProtocol
>
)
-
>
Option
<
&
str
>
{
wsp
.
and_then
(
|
protocol_list
|
protocol_list
.
get
(
0
)
.
map
(
|
protocol
|
protocol
.
as_ref
(
)
)
)
}
#
[
derive
(
Clone
PartialEq
Eq
Copy
Hash
Debug
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
ResourceId
(
pub
u32
)
;
pub
enum
ConstellationMsg
{
IsPrivate
(
PipelineId
Sender
<
bool
>
)
}
#
[
derive
(
Clone
PartialEq
Eq
Debug
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
NetworkError
{
Internal
(
String
)
LoadCancelled
SslValidation
(
Url
)
}
