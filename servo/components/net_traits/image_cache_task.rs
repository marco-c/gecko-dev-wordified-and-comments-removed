use
image
:
:
base
:
:
Image
;
use
url
:
:
Url
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Sender
}
;
pub
trait
ImageResponder
:
Send
{
fn
respond
(
&
self
Option
<
Arc
<
Image
>
>
)
;
}
#
[
derive
(
PartialEq
Copy
)
]
pub
enum
ImageState
{
Pending
LoadError
NotRequested
}
#
[
derive
(
Clone
)
]
pub
struct
ImageCacheChan
(
pub
Sender
<
ImageCacheResult
>
)
;
pub
struct
ImageCacheResult
{
pub
responder
:
Option
<
Box
<
ImageResponder
>
>
pub
image
:
Option
<
Arc
<
Image
>
>
}
pub
enum
ImageCacheCommand
{
RequestImage
(
Url
ImageCacheChan
Option
<
Box
<
ImageResponder
>
>
)
GetImageIfAvailable
(
Url
Sender
<
Result
<
Arc
<
Image
>
ImageState
>
>
)
Exit
(
Sender
<
(
)
>
)
}
#
[
derive
(
Clone
)
]
pub
struct
ImageCacheTask
{
chan
:
Sender
<
ImageCacheCommand
>
}
impl
ImageCacheTask
{
pub
fn
new
(
chan
:
Sender
<
ImageCacheCommand
>
)
-
>
ImageCacheTask
{
ImageCacheTask
{
chan
:
chan
}
}
pub
fn
request_image
(
&
self
url
:
Url
result_chan
:
ImageCacheChan
responder
:
Option
<
Box
<
ImageResponder
>
>
)
{
let
msg
=
ImageCacheCommand
:
:
RequestImage
(
url
result_chan
responder
)
;
self
.
chan
.
send
(
msg
)
.
unwrap
(
)
;
}
pub
fn
get_image_if_available
(
&
self
url
:
Url
)
-
>
Result
<
Arc
<
Image
>
ImageState
>
{
let
(
sender
receiver
)
=
channel
(
)
;
let
msg
=
ImageCacheCommand
:
:
GetImageIfAvailable
(
url
sender
)
;
self
.
chan
.
send
(
msg
)
.
unwrap
(
)
;
receiver
.
recv
(
)
.
unwrap
(
)
}
pub
fn
exit
(
&
self
)
{
let
(
response_chan
response_port
)
=
channel
(
)
;
self
.
chan
.
send
(
ImageCacheCommand
:
:
Exit
(
response_chan
)
)
.
unwrap
(
)
;
response_port
.
recv
(
)
.
unwrap
(
)
;
}
}
