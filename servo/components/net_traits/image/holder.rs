use
image
:
:
base
:
:
Image
;
use
image_cache_task
:
:
ImageResponseMsg
;
use
local_image_cache
:
:
LocalImageCache
;
use
geom
:
:
size
:
:
Size2D
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
url
:
:
Url
;
#
[
derive
(
Clone
)
]
pub
struct
ImageHolder
<
NodeAddress
>
{
url
:
Url
image
:
Option
<
Arc
<
Image
>
>
cached_size
:
Size2D
<
u32
>
local_image_cache
:
Arc
<
Mutex
<
LocalImageCache
<
NodeAddress
>
>
>
}
impl
<
NodeAddress
:
Send
+
'
static
>
ImageHolder
<
NodeAddress
>
{
pub
fn
new
(
url
:
Url
local_image_cache
:
Arc
<
Mutex
<
LocalImageCache
<
NodeAddress
>
>
>
)
-
>
ImageHolder
<
NodeAddress
>
{
debug
!
(
"
ImageHolder
:
:
new
(
)
{
}
"
url
.
serialize
(
)
)
;
let
holder
=
ImageHolder
{
url
:
url
image
:
None
cached_size
:
Size2D
(
0
0
)
local_image_cache
:
local_image_cache
.
clone
(
)
}
;
{
let
val
=
holder
.
local_image_cache
.
lock
(
)
.
unwrap
(
)
;
let
mut
local_image_cache
=
val
;
local_image_cache
.
prefetch
(
&
holder
.
url
)
;
local_image_cache
.
decode
(
&
holder
.
url
)
;
}
holder
}
pub
fn
size
(
&
self
)
-
>
Size2D
<
u32
>
{
self
.
cached_size
}
pub
fn
get_size
(
&
mut
self
node_address
:
NodeAddress
)
-
>
Option
<
Size2D
<
u32
>
>
{
debug
!
(
"
get_size
(
)
{
}
"
self
.
url
.
serialize
(
)
)
;
self
.
get_image
(
node_address
)
.
map
(
|
img
|
{
self
.
cached_size
=
Size2D
(
img
.
width
img
.
height
)
;
self
.
cached_size
.
clone
(
)
}
)
}
pub
fn
get_image_if_present
(
&
self
)
-
>
Option
<
Arc
<
Image
>
>
{
debug
!
(
"
get_image_if_present
(
)
{
}
"
self
.
url
.
serialize
(
)
)
;
self
.
image
.
clone
(
)
}
pub
fn
get_image
(
&
mut
self
node_address
:
NodeAddress
)
-
>
Option
<
Arc
<
Image
>
>
{
debug
!
(
"
get_image
(
)
{
}
"
self
.
url
.
serialize
(
)
)
;
if
self
.
image
.
is_none
(
)
{
let
port
=
{
let
val
=
self
.
local_image_cache
.
lock
(
)
.
unwrap
(
)
;
let
mut
local_image_cache
=
val
;
local_image_cache
.
get_image
(
node_address
&
self
.
url
)
}
;
match
port
.
recv
(
)
.
unwrap
(
)
{
ImageResponseMsg
:
:
ImageReady
(
image
)
=
>
self
.
image
=
Some
(
image
)
ImageResponseMsg
:
:
ImageNotReady
=
>
debug
!
(
"
image
not
ready
for
{
}
"
self
.
url
.
serialize
(
)
)
ImageResponseMsg
:
:
ImageFailed
=
>
debug
!
(
"
image
decoding
failed
for
{
}
"
self
.
url
.
serialize
(
)
)
}
}
return
self
.
image
.
clone
(
)
;
}
pub
fn
url
(
&
self
)
-
>
&
Url
{
&
self
.
url
}
}
