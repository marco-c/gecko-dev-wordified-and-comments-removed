use
image
:
:
base
:
:
{
Image
ImageMetadata
}
;
use
ipc_channel
:
:
ipc
:
:
{
self
IpcSender
}
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
sync
:
:
Arc
;
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
ImageResponder
{
sender
:
IpcSender
<
ImageResponse
>
}
impl
ImageResponder
{
pub
fn
new
(
sender
:
IpcSender
<
ImageResponse
>
)
-
>
ImageResponder
{
ImageResponder
{
sender
:
sender
}
}
pub
fn
respond
(
&
self
response
:
ImageResponse
)
{
self
.
sender
.
send
(
response
)
.
unwrap
(
)
}
}
#
[
derive
(
PartialEq
Copy
Clone
Deserialize
Serialize
)
]
pub
enum
ImageState
{
Pending
LoadError
NotRequested
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
ImageResponse
{
Loaded
(
Arc
<
Image
>
)
MetadataLoaded
(
ImageMetadata
)
PlaceholderLoaded
(
Arc
<
Image
>
)
None
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
ImageOrMetadataAvailable
{
ImageAvailable
(
Arc
<
Image
>
)
MetadataAvailable
(
ImageMetadata
)
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
ImageCacheChan
(
pub
IpcSender
<
ImageCacheResult
>
)
;
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
ImageCacheResult
{
pub
responder
:
Option
<
ImageResponder
>
pub
image_response
:
ImageResponse
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
ImageCacheCommand
{
RequestImage
(
ServoUrl
ImageCacheChan
Option
<
ImageResponder
>
)
RequestImageAndMetadata
(
ServoUrl
ImageCacheChan
Option
<
ImageResponder
>
)
GetImageIfAvailable
(
ServoUrl
UsePlaceholder
IpcSender
<
Result
<
Arc
<
Image
>
ImageState
>
>
)
GetImageOrMetadataIfAvailable
(
ServoUrl
UsePlaceholder
IpcSender
<
Result
<
ImageOrMetadataAvailable
ImageState
>
>
)
StoreDecodeImage
(
ServoUrl
Vec
<
u8
>
)
Exit
(
IpcSender
<
(
)
>
)
}
#
[
derive
(
Copy
Clone
PartialEq
Hash
Eq
Deserialize
Serialize
)
]
pub
enum
UsePlaceholder
{
No
Yes
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
ImageCacheThread
{
chan
:
IpcSender
<
ImageCacheCommand
>
}
impl
ImageCacheThread
{
pub
fn
new
(
chan
:
IpcSender
<
ImageCacheCommand
>
)
-
>
ImageCacheThread
{
ImageCacheThread
{
chan
:
chan
}
}
pub
fn
request_image
(
&
self
url
:
ServoUrl
result_chan
:
ImageCacheChan
responder
:
Option
<
ImageResponder
>
)
{
let
msg
=
ImageCacheCommand
:
:
RequestImage
(
url
result_chan
responder
)
;
let
_
=
self
.
chan
.
send
(
msg
)
;
}
pub
fn
request_image_and_metadata
(
&
self
url
:
ServoUrl
result_chan
:
ImageCacheChan
responder
:
Option
<
ImageResponder
>
)
{
let
msg
=
ImageCacheCommand
:
:
RequestImageAndMetadata
(
url
result_chan
responder
)
;
let
_
=
self
.
chan
.
send
(
msg
)
;
}
pub
fn
find_image
(
&
self
url
:
ServoUrl
use_placeholder
:
UsePlaceholder
)
-
>
Result
<
Arc
<
Image
>
ImageState
>
{
let
(
sender
receiver
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
let
msg
=
ImageCacheCommand
:
:
GetImageIfAvailable
(
url
use_placeholder
sender
)
;
let
_
=
self
.
chan
.
send
(
msg
)
;
try
!
(
receiver
.
recv
(
)
.
map_err
(
|
_
|
ImageState
:
:
LoadError
)
)
}
pub
fn
find_image_or_metadata
(
&
self
url
:
ServoUrl
use_placeholder
:
UsePlaceholder
)
-
>
Result
<
ImageOrMetadataAvailable
ImageState
>
{
let
(
sender
receiver
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
let
msg
=
ImageCacheCommand
:
:
GetImageOrMetadataIfAvailable
(
url
use_placeholder
sender
)
;
let
_
=
self
.
chan
.
send
(
msg
)
;
try
!
(
receiver
.
recv
(
)
.
map_err
(
|
_
|
ImageState
:
:
LoadError
)
)
}
pub
fn
store_complete_image_bytes
(
&
self
url
:
ServoUrl
image_data
:
Vec
<
u8
>
)
{
let
msg
=
ImageCacheCommand
:
:
StoreDecodeImage
(
url
image_data
)
;
let
_
=
self
.
chan
.
send
(
msg
)
;
}
pub
fn
exit
(
&
self
)
{
let
(
response_chan
response_port
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
let
_
=
self
.
chan
.
send
(
ImageCacheCommand
:
:
Exit
(
response_chan
)
)
;
let
_
=
response_port
.
recv
(
)
;
}
}
