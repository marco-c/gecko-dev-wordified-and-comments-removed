use
FetchResponseMsg
;
use
image
:
:
base
:
:
{
Image
ImageMetadata
}
;
use
ipc_channel
:
:
ipc
:
:
{
self
IpcSender
}
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
sync
:
:
Arc
;
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
ImageResponder
{
id
:
PendingImageId
sender
:
IpcSender
<
PendingImageResponse
>
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
PendingImageResponse
{
pub
response
:
ImageResponse
pub
id
:
PendingImageId
}
impl
ImageResponder
{
pub
fn
new
(
sender
:
IpcSender
<
PendingImageResponse
>
id
:
PendingImageId
)
-
>
ImageResponder
{
ImageResponder
{
sender
:
sender
id
:
id
}
}
pub
fn
respond
(
&
self
response
:
ImageResponse
)
{
let
_
=
self
.
sender
.
send
(
PendingImageResponse
{
response
:
response
id
:
self
.
id
}
)
;
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Deserialize
Serialize
HeapSizeOf
Hash
Debug
)
]
pub
struct
PendingImageId
(
pub
u64
)
;
#
[
derive
(
PartialEq
Copy
Clone
Deserialize
Serialize
)
]
pub
enum
ImageState
{
Pending
(
PendingImageId
)
LoadError
NotRequested
(
PendingImageId
)
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
ImageResponse
{
Loaded
(
Arc
<
Image
>
)
MetadataLoaded
(
ImageMetadata
)
PlaceholderLoaded
(
Arc
<
Image
>
)
None
}
#
[
derive
(
Clone
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
ImageOrMetadataAvailable
{
ImageAvailable
(
Arc
<
Image
>
)
MetadataAvailable
(
ImageMetadata
)
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
ImageCacheCommand
{
GetImageOrMetadataIfAvailable
(
ServoUrl
UsePlaceholder
CanRequestImages
IpcSender
<
Result
<
ImageOrMetadataAvailable
ImageState
>
>
)
AddListener
(
PendingImageId
ImageResponder
)
StoreDecodeImage
(
PendingImageId
FetchResponseMsg
)
Exit
(
IpcSender
<
(
)
>
)
}
#
[
derive
(
Copy
Clone
PartialEq
Hash
Eq
Deserialize
Serialize
)
]
pub
enum
UsePlaceholder
{
No
Yes
}
#
[
derive
(
Copy
Clone
PartialEq
Deserialize
Serialize
)
]
pub
enum
CanRequestImages
{
No
Yes
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
ImageCacheThread
{
chan
:
IpcSender
<
ImageCacheCommand
>
}
impl
ImageCacheThread
{
pub
fn
new
(
chan
:
IpcSender
<
ImageCacheCommand
>
)
-
>
ImageCacheThread
{
ImageCacheThread
{
chan
:
chan
}
}
pub
fn
find_image_or_metadata
(
&
self
url
:
ServoUrl
use_placeholder
:
UsePlaceholder
can_request
:
CanRequestImages
)
-
>
Result
<
ImageOrMetadataAvailable
ImageState
>
{
let
(
sender
receiver
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
let
msg
=
ImageCacheCommand
:
:
GetImageOrMetadataIfAvailable
(
url
use_placeholder
can_request
sender
)
;
let
_
=
self
.
chan
.
send
(
msg
)
;
try
!
(
receiver
.
recv
(
)
.
map_err
(
|
_
|
ImageState
:
:
LoadError
)
)
}
pub
fn
add_listener
(
&
self
id
:
PendingImageId
responder
:
ImageResponder
)
{
let
msg
=
ImageCacheCommand
:
:
AddListener
(
id
responder
)
;
self
.
chan
.
send
(
msg
)
.
expect
(
"
Image
cache
thread
is
not
available
"
)
;
}
pub
fn
notify_pending_response
(
&
self
id
:
PendingImageId
data
:
FetchResponseMsg
)
{
let
msg
=
ImageCacheCommand
:
:
StoreDecodeImage
(
id
data
)
;
self
.
chan
.
send
(
msg
)
.
expect
(
"
Image
cache
thread
is
not
available
"
)
;
}
pub
fn
exit
(
&
self
)
{
let
(
response_chan
response_port
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
let
_
=
self
.
chan
.
send
(
ImageCacheCommand
:
:
Exit
(
response_chan
)
)
;
let
_
=
response_port
.
recv
(
)
;
}
}
