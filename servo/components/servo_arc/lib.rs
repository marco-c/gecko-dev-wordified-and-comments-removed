#
!
[
allow
(
missing_docs
)
]
#
[
cfg
(
feature
=
"
servo
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
use
stable_deref_trait
:
:
{
CloneStableDeref
StableDeref
}
;
use
std
:
:
alloc
:
:
{
self
Layout
}
;
use
std
:
:
borrow
;
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
fmt
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
:
:
{
self
align_of
size_of
}
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
os
:
:
raw
:
:
c_void
;
use
std
:
:
process
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
atomic
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
Acquire
Relaxed
Release
}
;
use
std
:
:
{
isize
usize
}
;
const
MAX_REFCOUNT
:
usize
=
(
isize
:
:
MAX
)
as
usize
;
const
STATIC_REFCOUNT
:
usize
=
usize
:
:
MAX
;
/
/
/
cbindgen
:
derive
-
eq
=
false
/
/
/
cbindgen
:
derive
-
neq
=
false
#
[
repr
(
C
)
]
pub
struct
Arc
<
T
:
?
Sized
>
{
p
:
ptr
:
:
NonNull
<
ArcInner
<
T
>
>
phantom
:
PhantomData
<
T
>
}
pub
struct
UniqueArc
<
T
:
?
Sized
>
(
Arc
<
T
>
)
;
impl
<
T
>
UniqueArc
<
T
>
{
#
[
inline
]
pub
fn
new
(
data
:
T
)
-
>
Self
{
UniqueArc
(
Arc
:
:
new
(
data
)
)
}
#
[
inline
]
pub
fn
new_uninit
(
)
-
>
UniqueArc
<
mem
:
:
MaybeUninit
<
T
>
>
{
unsafe
{
let
layout
=
Layout
:
:
new
:
:
<
ArcInner
<
mem
:
:
MaybeUninit
<
T
>
>
>
(
)
;
let
ptr
=
alloc
:
:
alloc
(
layout
)
;
let
mut
p
=
ptr
:
:
NonNull
:
:
new
(
ptr
)
.
unwrap_or_else
(
|
|
alloc
:
:
handle_alloc_error
(
layout
)
)
.
cast
:
:
<
ArcInner
<
mem
:
:
MaybeUninit
<
T
>
>
>
(
)
;
ptr
:
:
write
(
&
mut
p
.
as_mut
(
)
.
count
atomic
:
:
AtomicUsize
:
:
new
(
1
)
)
;
#
[
cfg
(
feature
=
"
track_alloc_size
"
)
]
ptr
:
:
write
(
&
mut
p
.
as_mut
(
)
.
alloc_size
layout
.
size
(
)
)
;
#
[
cfg
(
feature
=
"
gecko_refcount_logging
"
)
]
{
NS_LogCtor
(
p
.
as_ptr
(
)
as
*
mut
_
b
"
ServoArc
\
0
"
.
as_ptr
(
)
as
*
const
_
8
)
}
UniqueArc
(
Arc
{
p
phantom
:
PhantomData
}
)
}
}
#
[
inline
]
pub
fn
shareable
(
self
)
-
>
Arc
<
T
>
{
self
.
0
}
}
impl
<
T
>
UniqueArc
<
mem
:
:
MaybeUninit
<
T
>
>
{
#
[
inline
]
pub
unsafe
fn
assume_init
(
this
:
Self
)
-
>
UniqueArc
<
T
>
{
UniqueArc
(
Arc
{
p
:
mem
:
:
ManuallyDrop
:
:
new
(
this
)
.
0
.
p
.
cast
(
)
phantom
:
PhantomData
}
)
}
}
impl
<
T
>
Deref
for
UniqueArc
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
&
*
self
.
0
}
}
impl
<
T
>
DerefMut
for
UniqueArc
<
T
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
T
{
unsafe
{
&
mut
(
*
self
.
0
.
ptr
(
)
)
.
data
}
}
}
unsafe
impl
<
T
:
?
Sized
+
Sync
+
Send
>
Send
for
Arc
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Sync
+
Send
>
Sync
for
Arc
<
T
>
{
}
/
/
/
cbindgen
:
derive
-
eq
=
false
/
/
/
cbindgen
:
derive
-
neq
=
false
#
[
repr
(
C
)
]
struct
ArcInner
<
T
:
?
Sized
>
{
count
:
atomic
:
:
AtomicUsize
#
[
cfg
(
feature
=
"
track_alloc_size
"
)
]
alloc_size
:
usize
data
:
T
}
unsafe
impl
<
T
:
?
Sized
+
Sync
+
Send
>
Send
for
ArcInner
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Sync
+
Send
>
Sync
for
ArcInner
<
T
>
{
}
fn
data_offset
<
T
>
(
)
-
>
usize
{
let
size
=
size_of
:
:
<
ArcInner
<
(
)
>
>
(
)
;
let
align
=
align_of
:
:
<
T
>
(
)
;
size
.
wrapping_add
(
align
)
.
wrapping_sub
(
1
)
&
!
align
.
wrapping_sub
(
1
)
}
impl
<
T
>
Arc
<
T
>
{
#
[
inline
]
pub
fn
new
(
data
:
T
)
-
>
Self
{
let
layout
=
Layout
:
:
new
:
:
<
ArcInner
<
T
>
>
(
)
;
let
p
=
unsafe
{
let
ptr
=
ptr
:
:
NonNull
:
:
new
(
alloc
:
:
alloc
(
layout
)
)
.
unwrap_or_else
(
|
|
alloc
:
:
handle_alloc_error
(
layout
)
)
.
cast
:
:
<
ArcInner
<
T
>
>
(
)
;
ptr
:
:
write
(
ptr
.
as_ptr
(
)
ArcInner
{
count
:
atomic
:
:
AtomicUsize
:
:
new
(
1
)
#
[
cfg
(
feature
=
"
track_alloc_size
"
)
]
alloc_size
:
layout
.
size
(
)
data
}
)
;
ptr
}
;
#
[
cfg
(
feature
=
"
gecko_refcount_logging
"
)
]
unsafe
{
NS_LogCtor
(
p
.
as_ptr
(
)
as
*
mut
_
b
"
ServoArc
\
0
"
.
as_ptr
(
)
as
*
const
_
8
)
;
}
Arc
{
p
phantom
:
PhantomData
}
}
#
[
inline
]
pub
fn
new_leaked
(
data
:
T
)
-
>
Self
{
let
arc
=
Self
:
:
new
(
data
)
;
arc
.
mark_as_intentionally_leaked
(
)
;
arc
}
#
[
inline
]
pub
fn
into_raw
(
this
:
Self
)
-
>
*
const
T
{
let
ptr
=
unsafe
{
&
(
(
*
this
.
ptr
(
)
)
.
data
)
as
*
const
_
}
;
mem
:
:
forget
(
this
)
;
ptr
}
#
[
inline
]
pub
unsafe
fn
from_raw
(
ptr
:
*
const
T
)
-
>
Self
{
let
ptr
=
(
ptr
as
*
const
u8
)
.
sub
(
data_offset
:
:
<
T
>
(
)
)
;
Arc
{
p
:
ptr
:
:
NonNull
:
:
new_unchecked
(
ptr
as
*
mut
ArcInner
<
T
>
)
phantom
:
PhantomData
}
}
#
[
inline
]
pub
unsafe
fn
from_raw_addrefed
(
ptr
:
*
const
T
)
-
>
Self
{
let
arc
=
Self
:
:
from_raw
(
ptr
)
;
mem
:
:
forget
(
arc
.
clone
(
)
)
;
arc
}
#
[
inline
]
pub
unsafe
fn
new_static
<
F
>
(
alloc
:
F
data
:
T
)
-
>
Arc
<
T
>
where
F
:
FnOnce
(
Layout
)
-
>
*
mut
u8
{
let
layout
=
Layout
:
:
new
:
:
<
ArcInner
<
T
>
>
(
)
;
let
ptr
=
alloc
(
layout
)
as
*
mut
ArcInner
<
T
>
;
let
x
=
ArcInner
{
count
:
atomic
:
:
AtomicUsize
:
:
new
(
STATIC_REFCOUNT
)
#
[
cfg
(
feature
=
"
track_alloc_size
"
)
]
alloc_size
:
layout
.
size
(
)
data
}
;
ptr
:
:
write
(
ptr
x
)
;
Arc
{
p
:
ptr
:
:
NonNull
:
:
new_unchecked
(
ptr
)
phantom
:
PhantomData
}
}
#
[
inline
]
pub
fn
borrow_arc
<
'
a
>
(
&
'
a
self
)
-
>
ArcBorrow
<
'
a
T
>
{
ArcBorrow
(
&
*
*
self
)
}
pub
fn
heap_ptr
(
&
self
)
-
>
*
const
c_void
{
if
self
.
inner
(
)
.
count
.
load
(
Relaxed
)
=
=
STATIC_REFCOUNT
{
ptr
:
:
null
(
)
}
else
{
self
.
p
.
as_ptr
(
)
as
*
const
ArcInner
<
T
>
as
*
const
c_void
}
}
}
impl
<
T
:
?
Sized
>
Arc
<
T
>
{
#
[
inline
]
fn
inner
(
&
self
)
-
>
&
ArcInner
<
T
>
{
unsafe
{
&
*
self
.
ptr
(
)
}
}
#
[
inline
(
always
)
]
fn
record_drop
(
&
self
)
{
#
[
cfg
(
feature
=
"
gecko_refcount_logging
"
)
]
unsafe
{
NS_LogDtor
(
self
.
ptr
(
)
as
*
mut
_
b
"
ServoArc
\
0
"
.
as_ptr
(
)
as
*
const
_
8
)
;
}
}
#
[
inline
(
always
)
]
pub
fn
mark_as_intentionally_leaked
(
&
self
)
{
self
.
record_drop
(
)
;
}
#
[
inline
(
never
)
]
unsafe
fn
drop_slow
(
&
mut
self
)
{
self
.
record_drop
(
)
;
let
inner
=
self
.
ptr
(
)
;
let
layout
=
Layout
:
:
for_value
(
&
*
inner
)
;
#
[
cfg
(
feature
=
"
track_alloc_size
"
)
]
let
layout
=
Layout
:
:
from_size_align_unchecked
(
(
*
inner
)
.
alloc_size
layout
.
align
(
)
)
;
std
:
:
ptr
:
:
drop_in_place
(
inner
)
;
alloc
:
:
dealloc
(
inner
as
*
mut
_
layout
)
;
}
#
[
inline
]
pub
fn
ptr_eq
(
this
:
&
Self
other
:
&
Self
)
-
>
bool
{
this
.
raw_ptr
(
)
=
=
other
.
raw_ptr
(
)
}
fn
ptr
(
&
self
)
-
>
*
mut
ArcInner
<
T
>
{
self
.
p
.
as_ptr
(
)
}
pub
fn
raw_ptr
(
&
self
)
-
>
ptr
:
:
NonNull
<
(
)
>
{
self
.
p
.
cast
(
)
}
}
#
[
cfg
(
feature
=
"
gecko_refcount_logging
"
)
]
extern
"
C
"
{
fn
NS_LogCtor
(
aPtr
:
*
mut
std
:
:
os
:
:
raw
:
:
c_void
aTypeName
:
*
const
std
:
:
os
:
:
raw
:
:
c_char
aSize
:
u32
)
;
fn
NS_LogDtor
(
aPtr
:
*
mut
std
:
:
os
:
:
raw
:
:
c_void
aTypeName
:
*
const
std
:
:
os
:
:
raw
:
:
c_char
aSize
:
u32
)
;
}
impl
<
T
:
?
Sized
>
Clone
for
Arc
<
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
if
self
.
inner
(
)
.
count
.
load
(
Relaxed
)
!
=
STATIC_REFCOUNT
{
let
old_size
=
self
.
inner
(
)
.
count
.
fetch_add
(
1
Relaxed
)
;
if
old_size
>
MAX_REFCOUNT
{
process
:
:
abort
(
)
;
}
}
unsafe
{
Arc
{
p
:
ptr
:
:
NonNull
:
:
new_unchecked
(
self
.
ptr
(
)
)
phantom
:
PhantomData
}
}
}
}
impl
<
T
:
?
Sized
>
Deref
for
Arc
<
T
>
{
type
Target
=
T
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
T
{
&
self
.
inner
(
)
.
data
}
}
impl
<
T
:
Clone
>
Arc
<
T
>
{
#
[
inline
]
pub
fn
make_mut
(
this
:
&
mut
Self
)
-
>
&
mut
T
{
if
!
this
.
is_unique
(
)
{
*
this
=
Arc
:
:
new
(
(
*
*
this
)
.
clone
(
)
)
;
}
unsafe
{
&
mut
(
*
this
.
ptr
(
)
)
.
data
}
}
}
impl
<
T
:
?
Sized
>
Arc
<
T
>
{
#
[
inline
]
pub
fn
get_mut
(
this
:
&
mut
Self
)
-
>
Option
<
&
mut
T
>
{
if
this
.
is_unique
(
)
{
unsafe
{
Some
(
&
mut
(
*
this
.
ptr
(
)
)
.
data
)
}
}
else
{
None
}
}
#
[
inline
]
pub
fn
is_static
(
&
self
)
-
>
bool
{
self
.
inner
(
)
.
count
.
load
(
Relaxed
)
=
=
STATIC_REFCOUNT
}
#
[
inline
]
pub
fn
is_unique
(
&
self
)
-
>
bool
{
self
.
inner
(
)
.
count
.
load
(
Acquire
)
=
=
1
}
}
impl
<
T
:
?
Sized
>
Drop
for
Arc
<
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
if
self
.
is_static
(
)
{
return
;
}
if
self
.
inner
(
)
.
count
.
fetch_sub
(
1
Release
)
!
=
1
{
return
;
}
self
.
inner
(
)
.
count
.
load
(
Acquire
)
;
unsafe
{
self
.
drop_slow
(
)
;
}
}
}
impl
<
T
:
?
Sized
+
PartialEq
>
PartialEq
for
Arc
<
T
>
{
fn
eq
(
&
self
other
:
&
Arc
<
T
>
)
-
>
bool
{
Self
:
:
ptr_eq
(
self
other
)
|
|
*
(
*
self
)
=
=
*
(
*
other
)
}
fn
ne
(
&
self
other
:
&
Arc
<
T
>
)
-
>
bool
{
!
Self
:
:
ptr_eq
(
self
other
)
&
&
*
(
*
self
)
!
=
*
(
*
other
)
}
}
impl
<
T
:
?
Sized
+
PartialOrd
>
PartialOrd
for
Arc
<
T
>
{
fn
partial_cmp
(
&
self
other
:
&
Arc
<
T
>
)
-
>
Option
<
Ordering
>
{
(
*
*
self
)
.
partial_cmp
(
&
*
*
other
)
}
fn
lt
(
&
self
other
:
&
Arc
<
T
>
)
-
>
bool
{
*
(
*
self
)
<
*
(
*
other
)
}
fn
le
(
&
self
other
:
&
Arc
<
T
>
)
-
>
bool
{
*
(
*
self
)
<
=
*
(
*
other
)
}
fn
gt
(
&
self
other
:
&
Arc
<
T
>
)
-
>
bool
{
*
(
*
self
)
>
*
(
*
other
)
}
fn
ge
(
&
self
other
:
&
Arc
<
T
>
)
-
>
bool
{
*
(
*
self
)
>
=
*
(
*
other
)
}
}
impl
<
T
:
?
Sized
+
Ord
>
Ord
for
Arc
<
T
>
{
fn
cmp
(
&
self
other
:
&
Arc
<
T
>
)
-
>
Ordering
{
(
*
*
self
)
.
cmp
(
&
*
*
other
)
}
}
impl
<
T
:
?
Sized
+
Eq
>
Eq
for
Arc
<
T
>
{
}
impl
<
T
:
?
Sized
+
fmt
:
:
Display
>
fmt
:
:
Display
for
Arc
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
<
T
:
?
Sized
+
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Arc
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
<
T
:
?
Sized
>
fmt
:
:
Pointer
for
Arc
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Pointer
:
:
fmt
(
&
self
.
ptr
(
)
f
)
}
}
impl
<
T
:
Default
>
Default
for
Arc
<
T
>
{
fn
default
(
)
-
>
Arc
<
T
>
{
Arc
:
:
new
(
Default
:
:
default
(
)
)
}
}
impl
<
T
:
?
Sized
+
Hash
>
Hash
for
Arc
<
T
>
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
(
*
*
self
)
.
hash
(
state
)
}
}
impl
<
T
>
From
<
T
>
for
Arc
<
T
>
{
#
[
inline
]
fn
from
(
t
:
T
)
-
>
Self
{
Arc
:
:
new
(
t
)
}
}
impl
<
T
:
?
Sized
>
borrow
:
:
Borrow
<
T
>
for
Arc
<
T
>
{
#
[
inline
]
fn
borrow
(
&
self
)
-
>
&
T
{
&
*
*
self
}
}
impl
<
T
:
?
Sized
>
AsRef
<
T
>
for
Arc
<
T
>
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
T
{
&
*
*
self
}
}
unsafe
impl
<
T
:
?
Sized
>
StableDeref
for
Arc
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
>
CloneStableDeref
for
Arc
<
T
>
{
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
<
'
de
T
:
Deserialize
<
'
de
>
>
Deserialize
<
'
de
>
for
Arc
<
T
>
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Arc
<
T
>
D
:
:
Error
>
where
D
:
:
:
serde
:
:
de
:
:
Deserializer
<
'
de
>
{
T
:
:
deserialize
(
deserializer
)
.
map
(
Arc
:
:
new
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
<
T
:
Serialize
>
Serialize
for
Arc
<
T
>
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
:
:
serde
:
:
ser
:
:
Serializer
{
(
*
*
self
)
.
serialize
(
serializer
)
}
}
/
/
/
cbindgen
:
derive
-
eq
=
false
/
/
/
cbindgen
:
derive
-
neq
=
false
#
[
derive
(
Eq
)
]
#
[
repr
(
C
)
]
pub
struct
HeaderSlice
<
H
T
>
{
pub
header
:
H
len
:
usize
data
:
[
T
;
0
]
}
impl
<
H
:
PartialEq
T
:
PartialEq
>
PartialEq
for
HeaderSlice
<
H
T
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
header
=
=
other
.
header
&
&
self
.
slice
(
)
=
=
other
.
slice
(
)
}
}
impl
<
H
T
>
Drop
for
HeaderSlice
<
H
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
let
mut
ptr
=
self
.
data_mut
(
)
;
for
_
in
0
.
.
self
.
len
{
std
:
:
ptr
:
:
drop_in_place
(
ptr
)
;
ptr
=
ptr
.
offset
(
1
)
;
}
}
}
}
impl
<
H
:
fmt
:
:
Debug
T
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
HeaderSlice
<
H
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
HeaderSlice
"
)
.
field
(
"
header
"
&
self
.
header
)
.
field
(
"
slice
"
&
self
.
slice
(
)
)
.
finish
(
)
}
}
impl
<
H
T
>
HeaderSlice
<
H
T
>
{
#
[
inline
(
always
)
]
pub
fn
slice
(
&
self
)
-
>
&
[
T
]
{
unsafe
{
std
:
:
slice
:
:
from_raw_parts
(
self
.
data
(
)
self
.
len
)
}
}
#
[
inline
(
always
)
]
fn
data
(
&
self
)
-
>
*
const
T
{
std
:
:
ptr
:
:
addr_of
!
(
self
.
data
)
as
*
const
_
}
#
[
inline
(
always
)
]
fn
data_mut
(
&
mut
self
)
-
>
*
mut
T
{
std
:
:
ptr
:
:
addr_of_mut
!
(
self
.
data
)
as
*
mut
_
}
#
[
inline
(
always
)
]
pub
fn
slice_mut
(
&
mut
self
)
-
>
&
mut
[
T
]
{
unsafe
{
std
:
:
slice
:
:
from_raw_parts_mut
(
self
.
data_mut
(
)
self
.
len
)
}
}
#
[
inline
(
always
)
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
len
}
}
impl
<
H
T
>
Arc
<
HeaderSlice
<
H
T
>
>
{
#
[
inline
]
pub
fn
from_header_and_iter_alloc
<
F
I
>
(
alloc
:
F
header
:
H
mut
items
:
I
num_items
:
usize
is_static
:
bool
)
-
>
Self
where
F
:
FnOnce
(
Layout
)
-
>
*
mut
u8
I
:
Iterator
<
Item
=
T
>
{
assert_ne
!
(
size_of
:
:
<
T
>
(
)
0
"
Need
to
think
about
ZST
"
)
;
let
layout
=
Layout
:
:
new
:
:
<
ArcInner
<
HeaderSlice
<
H
T
>
>
>
(
)
;
debug_assert
!
(
layout
.
align
(
)
>
=
align_of
:
:
<
T
>
(
)
)
;
debug_assert
!
(
layout
.
align
(
)
>
=
align_of
:
:
<
usize
>
(
)
)
;
let
array_layout
=
Layout
:
:
array
:
:
<
T
>
(
num_items
)
.
expect
(
"
Overflow
"
)
;
let
(
layout
_offset
)
=
layout
.
extend
(
array_layout
)
.
expect
(
"
Overflow
"
)
;
let
p
=
unsafe
{
let
buffer
=
alloc
(
layout
)
;
let
mut
p
=
ptr
:
:
NonNull
:
:
new
(
buffer
)
.
unwrap_or_else
(
|
|
alloc
:
:
handle_alloc_error
(
layout
)
)
.
cast
:
:
<
ArcInner
<
HeaderSlice
<
H
T
>
>
>
(
)
;
let
count
=
if
is_static
{
atomic
:
:
AtomicUsize
:
:
new
(
STATIC_REFCOUNT
)
}
else
{
atomic
:
:
AtomicUsize
:
:
new
(
1
)
}
;
ptr
:
:
write
(
&
mut
p
.
as_mut
(
)
.
count
count
)
;
#
[
cfg
(
feature
=
"
track_alloc_size
"
)
]
ptr
:
:
write
(
&
mut
p
.
as_mut
(
)
.
alloc_size
layout
.
size
(
)
)
;
ptr
:
:
write
(
&
mut
p
.
as_mut
(
)
.
data
.
header
header
)
;
ptr
:
:
write
(
&
mut
p
.
as_mut
(
)
.
data
.
len
num_items
)
;
if
num_items
!
=
0
{
let
mut
current
=
std
:
:
ptr
:
:
addr_of_mut
!
(
p
.
as_mut
(
)
.
data
.
data
)
as
*
mut
T
;
for
_
in
0
.
.
num_items
{
ptr
:
:
write
(
current
items
.
next
(
)
.
expect
(
"
ExactSizeIterator
over
-
reported
length
"
)
)
;
current
=
current
.
offset
(
1
)
;
}
debug_assert
!
(
(
buffer
.
add
(
layout
.
size
(
)
)
as
usize
-
current
as
*
mut
u8
as
usize
)
<
layout
.
align
(
)
)
;
}
assert
!
(
items
.
next
(
)
.
is_none
(
)
"
ExactSizeIterator
under
-
reported
length
"
)
;
p
}
;
#
[
cfg
(
feature
=
"
gecko_refcount_logging
"
)
]
unsafe
{
if
!
is_static
{
NS_LogCtor
(
p
.
as_ptr
(
)
as
*
mut
_
b
"
ServoArc
\
0
"
.
as_ptr
(
)
as
*
const
_
8
)
}
}
assert_eq
!
(
size_of
:
:
<
Self
>
(
)
size_of
:
:
<
usize
>
(
)
"
The
Arc
should
be
thin
"
)
;
Arc
{
p
phantom
:
PhantomData
}
}
#
[
inline
]
pub
fn
from_header_and_iter_with_size
<
I
>
(
header
:
H
items
:
I
num_items
:
usize
)
-
>
Self
where
I
:
Iterator
<
Item
=
T
>
{
Arc
:
:
from_header_and_iter_alloc
(
|
layout
|
unsafe
{
alloc
:
:
alloc
(
layout
)
}
header
items
num_items
false
)
}
#
[
inline
]
pub
fn
from_header_and_iter
<
I
>
(
header
:
H
items
:
I
)
-
>
Self
where
I
:
Iterator
<
Item
=
T
>
+
ExactSizeIterator
{
let
len
=
items
.
len
(
)
;
Self
:
:
from_header_and_iter_with_size
(
header
items
len
)
}
}
pub
type
ThinArc
<
H
T
>
=
Arc
<
HeaderSlice
<
H
T
>
>
;
pub
type
ThinArcUnion
<
H1
T1
H2
T2
>
=
ArcUnion
<
HeaderSlice
<
H1
T1
>
HeaderSlice
<
H2
T2
>
>
;
impl
<
H
T
>
UniqueArc
<
HeaderSlice
<
H
T
>
>
{
#
[
inline
]
pub
fn
from_header_and_iter
<
I
>
(
header
:
H
items
:
I
)
-
>
Self
where
I
:
Iterator
<
Item
=
T
>
+
ExactSizeIterator
{
Self
(
Arc
:
:
from_header_and_iter
(
header
items
)
)
}
#
[
inline
]
pub
fn
from_header_and_iter_with_size
<
I
>
(
header
:
H
items
:
I
num_items
:
usize
)
-
>
Self
where
I
:
Iterator
<
Item
=
T
>
{
Self
(
Arc
:
:
from_header_and_iter_with_size
(
header
items
num_items
)
)
}
pub
fn
header_mut
(
&
mut
self
)
-
>
&
mut
H
{
unsafe
{
&
mut
(
*
self
.
0
.
ptr
(
)
)
.
data
.
header
}
}
pub
fn
data_mut
(
&
mut
self
)
-
>
&
mut
[
T
]
{
unsafe
{
(
*
self
.
0
.
ptr
(
)
)
.
data
.
slice_mut
(
)
}
}
}
#
[
derive
(
Debug
Eq
PartialEq
)
]
pub
struct
ArcBorrow
<
'
a
T
:
'
a
>
(
&
'
a
T
)
;
impl
<
'
a
T
>
Copy
for
ArcBorrow
<
'
a
T
>
{
}
impl
<
'
a
T
>
Clone
for
ArcBorrow
<
'
a
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
'
a
T
>
ArcBorrow
<
'
a
T
>
{
#
[
inline
]
pub
fn
clone_arc
(
&
self
)
-
>
Arc
<
T
>
{
let
arc
=
unsafe
{
Arc
:
:
from_raw
(
self
.
0
)
}
;
mem
:
:
forget
(
arc
.
clone
(
)
)
;
arc
}
#
[
inline
]
pub
unsafe
fn
from_ref
(
r
:
&
'
a
T
)
-
>
Self
{
ArcBorrow
(
r
)
}
pub
fn
ptr_eq
(
this
:
&
Self
other
:
&
Self
)
-
>
bool
{
this
.
0
as
*
const
T
=
=
other
.
0
as
*
const
T
}
#
[
inline
]
pub
fn
with_arc
<
F
U
>
(
&
self
f
:
F
)
-
>
U
where
F
:
FnOnce
(
&
Arc
<
T
>
)
-
>
U
T
:
'
static
{
let
transient
=
unsafe
{
mem
:
:
ManuallyDrop
:
:
new
(
Arc
:
:
from_raw
(
self
.
0
)
)
}
;
let
result
=
f
(
&
transient
)
;
result
}
#
[
inline
]
pub
fn
get
(
&
self
)
-
>
&
'
a
T
{
self
.
0
}
}
impl
<
'
a
T
>
Deref
for
ArcBorrow
<
'
a
T
>
{
type
Target
=
T
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
T
{
self
.
0
}
}
pub
struct
ArcUnion
<
A
B
>
{
p
:
ptr
:
:
NonNull
<
(
)
>
phantom_a
:
PhantomData
<
A
>
phantom_b
:
PhantomData
<
B
>
}
unsafe
impl
<
A
:
Sync
+
Send
B
:
Send
+
Sync
>
Send
for
ArcUnion
<
A
B
>
{
}
unsafe
impl
<
A
:
Sync
+
Send
B
:
Send
+
Sync
>
Sync
for
ArcUnion
<
A
B
>
{
}
impl
<
A
:
PartialEq
B
:
PartialEq
>
PartialEq
for
ArcUnion
<
A
B
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
use
crate
:
:
ArcUnionBorrow
:
:
*
;
match
(
self
.
borrow
(
)
other
.
borrow
(
)
)
{
(
First
(
x
)
First
(
y
)
)
=
>
x
=
=
y
(
Second
(
x
)
Second
(
y
)
)
=
>
x
=
=
y
(
_
_
)
=
>
false
}
}
}
impl
<
A
:
Eq
B
:
Eq
>
Eq
for
ArcUnion
<
A
B
>
{
}
#
[
derive
(
Debug
)
]
pub
enum
ArcUnionBorrow
<
'
a
A
:
'
a
B
:
'
a
>
{
First
(
ArcBorrow
<
'
a
A
>
)
Second
(
ArcBorrow
<
'
a
B
>
)
}
impl
<
A
B
>
ArcUnion
<
A
B
>
{
unsafe
fn
new
(
ptr
:
*
mut
(
)
)
-
>
Self
{
ArcUnion
{
p
:
ptr
:
:
NonNull
:
:
new_unchecked
(
ptr
)
phantom_a
:
PhantomData
phantom_b
:
PhantomData
}
}
#
[
inline
]
pub
fn
ptr_eq
(
this
:
&
Self
other
:
&
Self
)
-
>
bool
{
this
.
p
=
=
other
.
p
}
#
[
inline
]
pub
fn
ptr
(
&
self
)
-
>
ptr
:
:
NonNull
<
(
)
>
{
self
.
p
}
#
[
inline
]
pub
fn
borrow
(
&
self
)
-
>
ArcUnionBorrow
<
A
B
>
{
if
self
.
is_first
(
)
{
let
ptr
=
self
.
p
.
as_ptr
(
)
as
*
const
ArcInner
<
A
>
;
let
borrow
=
unsafe
{
ArcBorrow
:
:
from_ref
(
&
(
*
ptr
)
.
data
)
}
;
ArcUnionBorrow
:
:
First
(
borrow
)
}
else
{
let
ptr
=
(
(
self
.
p
.
as_ptr
(
)
as
usize
)
&
!
0x1
)
as
*
const
ArcInner
<
B
>
;
let
borrow
=
unsafe
{
ArcBorrow
:
:
from_ref
(
&
(
*
ptr
)
.
data
)
}
;
ArcUnionBorrow
:
:
Second
(
borrow
)
}
}
pub
fn
from_first
(
other
:
Arc
<
A
>
)
-
>
Self
{
let
union
=
unsafe
{
Self
:
:
new
(
other
.
ptr
(
)
as
*
mut
_
)
}
;
mem
:
:
forget
(
other
)
;
union
}
pub
fn
from_second
(
other
:
Arc
<
B
>
)
-
>
Self
{
let
union
=
unsafe
{
Self
:
:
new
(
(
(
other
.
ptr
(
)
as
usize
)
|
0x1
)
as
*
mut
_
)
}
;
mem
:
:
forget
(
other
)
;
union
}
pub
fn
is_first
(
&
self
)
-
>
bool
{
self
.
p
.
as_ptr
(
)
as
usize
&
0x1
=
=
0
}
pub
fn
is_second
(
&
self
)
-
>
bool
{
!
self
.
is_first
(
)
}
pub
fn
as_first
(
&
self
)
-
>
Option
<
ArcBorrow
<
A
>
>
{
match
self
.
borrow
(
)
{
ArcUnionBorrow
:
:
First
(
x
)
=
>
Some
(
x
)
ArcUnionBorrow
:
:
Second
(
_
)
=
>
None
}
}
pub
fn
as_second
(
&
self
)
-
>
Option
<
ArcBorrow
<
B
>
>
{
match
self
.
borrow
(
)
{
ArcUnionBorrow
:
:
First
(
_
)
=
>
None
ArcUnionBorrow
:
:
Second
(
x
)
=
>
Some
(
x
)
}
}
}
impl
<
A
B
>
Clone
for
ArcUnion
<
A
B
>
{
fn
clone
(
&
self
)
-
>
Self
{
match
self
.
borrow
(
)
{
ArcUnionBorrow
:
:
First
(
x
)
=
>
ArcUnion
:
:
from_first
(
x
.
clone_arc
(
)
)
ArcUnionBorrow
:
:
Second
(
x
)
=
>
ArcUnion
:
:
from_second
(
x
.
clone_arc
(
)
)
}
}
}
impl
<
A
B
>
Drop
for
ArcUnion
<
A
B
>
{
fn
drop
(
&
mut
self
)
{
match
self
.
borrow
(
)
{
ArcUnionBorrow
:
:
First
(
x
)
=
>
unsafe
{
let
_
=
Arc
:
:
from_raw
(
&
*
x
)
;
}
ArcUnionBorrow
:
:
Second
(
x
)
=
>
unsafe
{
let
_
=
Arc
:
:
from_raw
(
&
*
x
)
;
}
}
}
}
impl
<
A
:
fmt
:
:
Debug
B
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
ArcUnion
<
A
B
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
self
.
borrow
(
)
f
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
Arc
ThinArc
}
;
use
std
:
:
clone
:
:
Clone
;
use
std
:
:
ops
:
:
Drop
;
use
std
:
:
sync
:
:
atomic
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
Acquire
SeqCst
}
;
#
[
derive
(
PartialEq
)
]
struct
Canary
(
*
mut
atomic
:
:
AtomicUsize
)
;
impl
Drop
for
Canary
{
fn
drop
(
&
mut
self
)
{
unsafe
{
(
*
self
.
0
)
.
fetch_add
(
1
SeqCst
)
;
}
}
}
#
[
test
]
fn
empty_thin
(
)
{
let
x
=
Arc
:
:
from_header_and_iter
(
100u32
std
:
:
iter
:
:
empty
:
:
<
i32
>
(
)
)
;
assert_eq
!
(
x
.
header
100
)
;
assert
!
(
x
.
slice
(
)
.
is_empty
(
)
)
;
}
#
[
test
]
fn
thin_assert_padding
(
)
{
#
[
derive
(
Clone
Default
)
]
#
[
repr
(
C
)
]
struct
Padded
{
i
:
u16
}
let
items
=
vec
!
[
Padded
{
i
:
0xdead
}
Padded
{
i
:
0xbeef
}
]
;
let
a
=
ThinArc
:
:
from_header_and_iter
(
0i32
items
.
into_iter
(
)
)
;
assert_eq
!
(
a
.
len
(
)
2
)
;
assert_eq
!
(
a
.
slice
(
)
[
0
]
.
i
0xdead
)
;
assert_eq
!
(
a
.
slice
(
)
[
1
]
.
i
0xbeef
)
;
}
#
[
test
]
fn
slices_and_thin
(
)
{
let
mut
canary
=
atomic
:
:
AtomicUsize
:
:
new
(
0
)
;
let
c
=
Canary
(
&
mut
canary
as
*
mut
atomic
:
:
AtomicUsize
)
;
let
v
=
vec
!
[
5
6
]
;
{
let
x
=
Arc
:
:
from_header_and_iter
(
c
v
.
into_iter
(
)
)
;
let
_
=
x
.
clone
(
)
;
let
_
=
x
=
=
x
;
}
assert_eq
!
(
canary
.
load
(
Acquire
)
1
)
;
}
}
