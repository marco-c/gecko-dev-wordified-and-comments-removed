use
HTMLCanvasData
;
use
LayoutNodeType
;
use
OpaqueStyleAndLayoutData
;
use
gfx_traits
:
:
{
ByteIndex
LayerId
LayerType
}
;
use
msg
:
:
constellation_msg
:
:
PipelineId
;
use
range
:
:
Range
;
use
restyle_damage
:
:
RestyleDamage
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
sync
:
:
Arc
;
use
string_cache
:
:
{
Atom
Namespace
}
;
use
style
:
:
atomic_refcell
:
:
AtomicRefCell
;
use
style
:
:
computed_values
:
:
display
;
use
style
:
:
context
:
:
SharedStyleContext
;
use
style
:
:
data
:
:
PersistentStyleData
;
use
style
:
:
dom
:
:
{
LayoutIterator
NodeInfo
PresentationalHintsSynthetizer
TNode
}
;
use
style
:
:
dom
:
:
OpaqueNode
;
use
style
:
:
properties
:
:
ServoComputedValues
;
use
style
:
:
selector_impl
:
:
{
PseudoElement
PseudoElementCascadeType
ServoSelectorImpl
}
;
use
url
:
:
Url
;
#
[
derive
(
Copy
PartialEq
Clone
)
]
pub
enum
PseudoElementType
<
T
>
{
Normal
Before
(
T
)
After
(
T
)
DetailsSummary
(
T
)
DetailsContent
(
T
)
}
impl
<
T
>
PseudoElementType
<
T
>
{
pub
fn
is_before
(
&
self
)
-
>
bool
{
match
*
self
{
PseudoElementType
:
:
Before
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
is_replaced_content
(
&
self
)
-
>
bool
{
match
*
self
{
PseudoElementType
:
:
Before
(
_
)
|
PseudoElementType
:
:
After
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
strip
(
&
self
)
-
>
PseudoElementType
<
(
)
>
{
match
*
self
{
PseudoElementType
:
:
Normal
=
>
PseudoElementType
:
:
Normal
PseudoElementType
:
:
Before
(
_
)
=
>
PseudoElementType
:
:
Before
(
(
)
)
PseudoElementType
:
:
After
(
_
)
=
>
PseudoElementType
:
:
After
(
(
)
)
PseudoElementType
:
:
DetailsSummary
(
_
)
=
>
PseudoElementType
:
:
DetailsSummary
(
(
)
)
PseudoElementType
:
:
DetailsContent
(
_
)
=
>
PseudoElementType
:
:
DetailsContent
(
(
)
)
}
}
pub
fn
style_pseudo_element
(
&
self
)
-
>
PseudoElement
{
match
*
self
{
PseudoElementType
:
:
Normal
=
>
unreachable
!
(
"
style_pseudo_element
called
with
PseudoElementType
:
:
Normal
"
)
PseudoElementType
:
:
Before
(
_
)
=
>
PseudoElement
:
:
Before
PseudoElementType
:
:
After
(
_
)
=
>
PseudoElement
:
:
After
PseudoElementType
:
:
DetailsSummary
(
_
)
=
>
PseudoElement
:
:
DetailsSummary
PseudoElementType
:
:
DetailsContent
(
_
)
=
>
PseudoElement
:
:
DetailsContent
}
}
}
pub
trait
LayoutNode
:
TNode
{
type
ConcreteThreadSafeLayoutNode
:
ThreadSafeLayoutNode
;
fn
to_threadsafe
(
&
self
)
-
>
Self
:
:
ConcreteThreadSafeLayoutNode
;
fn
type_id
(
&
self
)
-
>
LayoutNodeType
;
fn
get_style_data
(
&
self
)
-
>
Option
<
&
AtomicRefCell
<
PersistentStyleData
>
>
;
fn
init_style_and_layout_data
(
&
self
data
:
OpaqueStyleAndLayoutData
)
;
fn
get_style_and_layout_data
(
&
self
)
-
>
Option
<
OpaqueStyleAndLayoutData
>
;
fn
rev_children
(
self
)
-
>
LayoutIterator
<
ReverseChildrenIterator
<
Self
>
>
{
LayoutIterator
(
ReverseChildrenIterator
{
current
:
self
.
last_child
(
)
}
)
}
fn
traverse_preorder
(
self
)
-
>
TreeIterator
<
Self
>
{
TreeIterator
:
:
new
(
self
)
}
}
pub
struct
ReverseChildrenIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
current
:
Option
<
ConcreteNode
>
}
impl
<
ConcreteNode
>
Iterator
for
ReverseChildrenIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
type
Item
=
ConcreteNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
ConcreteNode
>
{
let
node
=
self
.
current
;
self
.
current
=
node
.
and_then
(
|
node
|
node
.
prev_sibling
(
)
)
;
node
}
}
pub
struct
TreeIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
stack
:
Vec
<
ConcreteNode
>
}
impl
<
ConcreteNode
>
TreeIterator
<
ConcreteNode
>
where
ConcreteNode
:
LayoutNode
{
fn
new
(
root
:
ConcreteNode
)
-
>
TreeIterator
<
ConcreteNode
>
{
let
mut
stack
=
vec
!
[
]
;
stack
.
push
(
root
)
;
TreeIterator
{
stack
:
stack
}
}
pub
fn
next_skipping_children
(
&
mut
self
)
-
>
Option
<
ConcreteNode
>
{
self
.
stack
.
pop
(
)
}
}
impl
<
ConcreteNode
>
Iterator
for
TreeIterator
<
ConcreteNode
>
where
ConcreteNode
:
LayoutNode
{
type
Item
=
ConcreteNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
ConcreteNode
>
{
let
ret
=
self
.
stack
.
pop
(
)
;
ret
.
map
(
|
node
|
self
.
stack
.
extend
(
node
.
rev_children
(
)
)
)
;
ret
}
}
pub
trait
ThreadSafeLayoutNode
:
Clone
+
Copy
+
NodeInfo
+
PartialEq
+
Sized
{
type
ConcreteThreadSafeLayoutElement
:
ThreadSafeLayoutElement
<
ConcreteThreadSafeLayoutNode
=
Self
>
+
:
:
selectors
:
:
Element
<
Impl
=
ServoSelectorImpl
>
;
type
ChildrenIterator
:
Iterator
<
Item
=
Self
>
+
Sized
;
fn
with_pseudo
(
&
self
pseudo
:
PseudoElementType
<
Option
<
display
:
:
T
>
>
)
-
>
Self
;
fn
opaque
(
&
self
)
-
>
OpaqueNode
;
fn
type_id
(
&
self
)
-
>
Option
<
LayoutNodeType
>
;
fn
type_id_without_excluding_pseudo_elements
(
&
self
)
-
>
LayoutNodeType
;
#
[
inline
]
fn
is_element_or_elements_pseudo
(
&
self
)
-
>
bool
{
match
self
.
type_id_without_excluding_pseudo_elements
(
)
{
LayoutNodeType
:
:
Element
(
.
.
)
=
>
true
_
=
>
false
}
}
fn
debug_id
(
self
)
-
>
usize
;
fn
children
(
&
self
)
-
>
LayoutIterator
<
Self
:
:
ChildrenIterator
>
;
#
[
inline
]
fn
as_element
(
&
self
)
-
>
Self
:
:
ConcreteThreadSafeLayoutElement
;
#
[
inline
]
fn
get_pseudo_element_type
(
&
self
)
-
>
PseudoElementType
<
Option
<
display
:
:
T
>
>
;
#
[
inline
]
fn
get_before_pseudo
(
&
self
)
-
>
Option
<
Self
>
{
if
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
.
per_pseudo
.
contains_key
(
&
PseudoElement
:
:
Before
)
{
Some
(
self
.
with_pseudo
(
PseudoElementType
:
:
Before
(
None
)
)
)
}
else
{
None
}
}
#
[
inline
]
fn
get_after_pseudo
(
&
self
)
-
>
Option
<
Self
>
{
if
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
.
per_pseudo
.
contains_key
(
&
PseudoElement
:
:
After
)
{
Some
(
self
.
with_pseudo
(
PseudoElementType
:
:
After
(
None
)
)
)
}
else
{
None
}
}
#
[
inline
]
fn
get_details_summary_pseudo
(
&
self
)
-
>
Option
<
Self
>
{
if
self
.
is_element
(
)
&
&
self
.
as_element
(
)
.
get_local_name
(
)
=
=
&
atom
!
(
"
details
"
)
&
&
self
.
as_element
(
)
.
get_namespace
(
)
=
=
&
ns
!
(
html
)
{
Some
(
self
.
with_pseudo
(
PseudoElementType
:
:
DetailsSummary
(
None
)
)
)
}
else
{
None
}
}
#
[
inline
]
fn
get_details_content_pseudo
(
&
self
)
-
>
Option
<
Self
>
{
if
self
.
is_element
(
)
&
&
self
.
as_element
(
)
.
get_local_name
(
)
=
=
&
atom
!
(
"
details
"
)
&
&
self
.
as_element
(
)
.
get_namespace
(
)
=
=
&
ns
!
(
html
)
{
let
display
=
if
self
.
as_element
(
)
.
get_attr
(
&
ns
!
(
)
&
atom
!
(
"
open
"
)
)
.
is_some
(
)
{
None
}
else
{
Some
(
display
:
:
T
:
:
none
)
}
;
Some
(
self
.
with_pseudo
(
PseudoElementType
:
:
DetailsContent
(
display
)
)
)
}
else
{
None
}
}
fn
get_style_and_layout_data
(
&
self
)
-
>
Option
<
OpaqueStyleAndLayoutData
>
;
#
[
inline
]
fn
style
(
&
self
context
:
&
SharedStyleContext
)
-
>
Arc
<
ServoComputedValues
>
{
match
self
.
get_pseudo_element_type
(
)
{
PseudoElementType
:
:
Normal
=
>
{
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
.
style
.
as_ref
(
)
.
unwrap
(
)
.
clone
(
)
}
other
=
>
{
let
style_pseudo
=
other
.
style_pseudo_element
(
)
;
match
style_pseudo
.
cascade_type
(
)
{
PseudoElementCascadeType
:
:
Eager
=
>
{
}
PseudoElementCascadeType
:
:
Precomputed
=
>
{
if
!
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
.
per_pseudo
.
contains_key
(
&
style_pseudo
)
{
let
mut
data
=
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow_mut
(
)
;
let
new_style
=
context
.
stylist
.
precomputed_values_for_pseudo
(
&
style_pseudo
data
.
style
.
as_ref
(
)
)
;
data
.
per_pseudo
.
insert
(
style_pseudo
.
clone
(
)
new_style
.
unwrap
(
)
)
;
}
}
PseudoElementCascadeType
:
:
Lazy
=
>
{
debug_assert
!
(
self
.
is_element_or_elements_pseudo
(
)
)
;
if
!
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
.
per_pseudo
.
contains_key
(
&
style_pseudo
)
{
let
mut
data
=
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow_mut
(
)
;
let
new_style
=
context
.
stylist
.
lazily_compute_pseudo_element_style
(
&
self
.
as_element
(
)
&
style_pseudo
data
.
style
.
as_ref
(
)
.
unwrap
(
)
)
;
data
.
per_pseudo
.
insert
(
style_pseudo
.
clone
(
)
new_style
.
unwrap
(
)
)
;
}
}
}
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
.
per_pseudo
.
get
(
&
style_pseudo
)
.
unwrap
(
)
.
clone
(
)
}
}
}
#
[
inline
]
fn
resolved_style
(
&
self
)
-
>
Arc
<
ServoComputedValues
>
{
let
data
=
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
;
match
self
.
get_pseudo_element_type
(
)
{
PseudoElementType
:
:
Normal
=
>
data
.
style
.
as_ref
(
)
.
unwrap
(
)
.
clone
(
)
other
=
>
data
.
per_pseudo
.
get
(
&
other
.
style_pseudo_element
(
)
)
.
unwrap
(
)
.
clone
(
)
}
}
#
[
inline
]
fn
selected_style
(
&
self
_context
:
&
SharedStyleContext
)
-
>
Arc
<
ServoComputedValues
>
{
let
data
=
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
;
data
.
per_pseudo
.
get
(
&
PseudoElement
:
:
Selection
)
.
unwrap_or
(
data
.
style
.
as_ref
(
)
.
unwrap
(
)
)
.
clone
(
)
}
fn
unstyle
(
self
)
{
let
mut
data
=
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow_mut
(
)
;
match
self
.
get_pseudo_element_type
(
)
{
PseudoElementType
:
:
Normal
=
>
{
data
.
style
=
None
;
}
other
=
>
{
data
.
per_pseudo
.
remove
(
&
other
.
style_pseudo_element
(
)
)
;
}
}
;
}
fn
is_ignorable_whitespace
(
&
self
context
:
&
SharedStyleContext
)
-
>
bool
;
fn
restyle_damage
(
self
)
-
>
RestyleDamage
;
fn
set_restyle_damage
(
self
damage
:
RestyleDamage
)
;
fn
is_content
(
&
self
)
-
>
bool
{
match
self
.
type_id
(
)
{
Some
(
LayoutNodeType
:
:
Element
(
.
.
)
)
|
Some
(
LayoutNodeType
:
:
Text
)
=
>
true
_
=
>
false
}
}
fn
can_be_fragmented
(
&
self
)
-
>
bool
;
fn
node_text_content
(
&
self
)
-
>
String
;
fn
selection
(
&
self
)
-
>
Option
<
Range
<
ByteIndex
>
>
;
fn
image_url
(
&
self
)
-
>
Option
<
Url
>
;
fn
canvas_data
(
&
self
)
-
>
Option
<
HTMLCanvasData
>
;
fn
iframe_pipeline_id
(
&
self
)
-
>
PipelineId
;
fn
get_colspan
(
&
self
)
-
>
u32
;
fn
layer_id
(
&
self
)
-
>
LayerId
{
let
layer_type
=
match
self
.
get_pseudo_element_type
(
)
{
PseudoElementType
:
:
Normal
=
>
LayerType
:
:
FragmentBody
PseudoElementType
:
:
Before
(
_
)
=
>
LayerType
:
:
BeforePseudoContent
PseudoElementType
:
:
After
(
_
)
=
>
LayerType
:
:
AfterPseudoContent
PseudoElementType
:
:
DetailsSummary
(
_
)
=
>
LayerType
:
:
FragmentBody
PseudoElementType
:
:
DetailsContent
(
_
)
=
>
LayerType
:
:
FragmentBody
}
;
LayerId
:
:
new_of_type
(
layer_type
self
.
opaque
(
)
.
id
(
)
as
usize
)
}
fn
layer_id_for_overflow_scroll
(
&
self
)
-
>
LayerId
{
LayerId
:
:
new_of_type
(
LayerType
:
:
OverflowScroll
self
.
opaque
(
)
.
id
(
)
as
usize
)
}
fn
get_style_data
(
&
self
)
-
>
Option
<
&
AtomicRefCell
<
PersistentStyleData
>
>
;
}
#
[
allow
(
unsafe_code
)
]
pub
trait
DangerousThreadSafeLayoutNode
:
ThreadSafeLayoutNode
{
unsafe
fn
dangerous_first_child
(
&
self
)
-
>
Option
<
Self
>
;
unsafe
fn
dangerous_next_sibling
(
&
self
)
-
>
Option
<
Self
>
;
}
pub
trait
ThreadSafeLayoutElement
:
Clone
+
Copy
+
Sized
+
Debug
+
:
:
selectors
:
:
Element
<
Impl
=
ServoSelectorImpl
>
+
PresentationalHintsSynthetizer
{
type
ConcreteThreadSafeLayoutNode
:
ThreadSafeLayoutNode
<
ConcreteThreadSafeLayoutElement
=
Self
>
;
#
[
inline
]
fn
get_attr
(
&
self
namespace
:
&
Namespace
name
:
&
Atom
)
-
>
Option
<
&
str
>
;
#
[
inline
]
fn
get_local_name
(
&
self
)
-
>
&
Atom
;
#
[
inline
]
fn
get_namespace
(
&
self
)
-
>
&
Namespace
;
}
