#
!
[
allow
(
unsafe_code
)
]
use
HTMLCanvasData
;
use
LayoutNodeType
;
use
OpaqueStyleAndLayoutData
;
use
SVGSVGData
;
use
gfx_traits
:
:
ByteIndex
;
use
html5ever_atoms
:
:
{
Namespace
LocalName
}
;
use
msg
:
:
constellation_msg
:
:
PipelineId
;
use
range
:
:
Range
;
use
restyle_damage
:
:
RestyleDamage
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
sync
:
:
Arc
;
use
style
:
:
atomic_refcell
:
:
AtomicRefCell
;
use
style
:
:
computed_values
:
:
display
;
use
style
:
:
context
:
:
SharedStyleContext
;
use
style
:
:
data
:
:
ElementData
;
use
style
:
:
dom
:
:
{
LayoutIterator
NodeInfo
PresentationalHintsSynthetizer
TElement
TNode
}
;
use
style
:
:
dom
:
:
OpaqueNode
;
use
style
:
:
properties
:
:
ServoComputedValues
;
use
style
:
:
selector_impl
:
:
{
PseudoElement
PseudoElementCascadeType
ServoSelectorImpl
}
;
use
url
:
:
Url
;
#
[
derive
(
Copy
PartialEq
Clone
Debug
)
]
pub
enum
PseudoElementType
<
T
>
{
Normal
Before
(
T
)
After
(
T
)
DetailsSummary
(
T
)
DetailsContent
(
T
)
}
impl
<
T
>
PseudoElementType
<
T
>
{
pub
fn
is_before
(
&
self
)
-
>
bool
{
match
*
self
{
PseudoElementType
:
:
Before
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
is_replaced_content
(
&
self
)
-
>
bool
{
match
*
self
{
PseudoElementType
:
:
Before
(
_
)
|
PseudoElementType
:
:
After
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
strip
(
&
self
)
-
>
PseudoElementType
<
(
)
>
{
match
*
self
{
PseudoElementType
:
:
Normal
=
>
PseudoElementType
:
:
Normal
PseudoElementType
:
:
Before
(
_
)
=
>
PseudoElementType
:
:
Before
(
(
)
)
PseudoElementType
:
:
After
(
_
)
=
>
PseudoElementType
:
:
After
(
(
)
)
PseudoElementType
:
:
DetailsSummary
(
_
)
=
>
PseudoElementType
:
:
DetailsSummary
(
(
)
)
PseudoElementType
:
:
DetailsContent
(
_
)
=
>
PseudoElementType
:
:
DetailsContent
(
(
)
)
}
}
pub
fn
style_pseudo_element
(
&
self
)
-
>
PseudoElement
{
match
*
self
{
PseudoElementType
:
:
Normal
=
>
unreachable
!
(
"
style_pseudo_element
called
with
PseudoElementType
:
:
Normal
"
)
PseudoElementType
:
:
Before
(
_
)
=
>
PseudoElement
:
:
Before
PseudoElementType
:
:
After
(
_
)
=
>
PseudoElement
:
:
After
PseudoElementType
:
:
DetailsSummary
(
_
)
=
>
PseudoElement
:
:
DetailsSummary
PseudoElementType
:
:
DetailsContent
(
_
)
=
>
PseudoElement
:
:
DetailsContent
}
}
}
pub
trait
GetLayoutData
{
fn
get_style_and_layout_data
(
&
self
)
-
>
Option
<
OpaqueStyleAndLayoutData
>
;
}
pub
trait
LayoutNode
:
GetLayoutData
+
TNode
{
type
ConcreteThreadSafeLayoutNode
:
ThreadSafeLayoutNode
;
fn
to_threadsafe
(
&
self
)
-
>
Self
:
:
ConcreteThreadSafeLayoutNode
;
fn
type_id
(
&
self
)
-
>
LayoutNodeType
;
unsafe
fn
init_style_and_layout_data
(
&
self
data
:
OpaqueStyleAndLayoutData
)
;
unsafe
fn
take_style_and_layout_data
(
&
self
)
-
>
OpaqueStyleAndLayoutData
;
fn
has_changed
(
&
self
)
-
>
bool
;
unsafe
fn
clear_dirty_bits
(
&
self
)
;
fn
rev_children
(
self
)
-
>
LayoutIterator
<
ReverseChildrenIterator
<
Self
>
>
{
LayoutIterator
(
ReverseChildrenIterator
{
current
:
self
.
last_child
(
)
}
)
}
fn
traverse_preorder
(
self
)
-
>
TreeIterator
<
Self
>
{
TreeIterator
:
:
new
(
self
)
}
}
pub
struct
ReverseChildrenIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
current
:
Option
<
ConcreteNode
>
}
impl
<
ConcreteNode
>
Iterator
for
ReverseChildrenIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
type
Item
=
ConcreteNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
ConcreteNode
>
{
let
node
=
self
.
current
;
self
.
current
=
node
.
and_then
(
|
node
|
node
.
prev_sibling
(
)
)
;
node
}
}
pub
struct
TreeIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
stack
:
Vec
<
ConcreteNode
>
}
impl
<
ConcreteNode
>
TreeIterator
<
ConcreteNode
>
where
ConcreteNode
:
LayoutNode
{
fn
new
(
root
:
ConcreteNode
)
-
>
TreeIterator
<
ConcreteNode
>
{
let
mut
stack
=
vec
!
[
]
;
stack
.
push
(
root
)
;
TreeIterator
{
stack
:
stack
}
}
pub
fn
next_skipping_children
(
&
mut
self
)
-
>
Option
<
ConcreteNode
>
{
self
.
stack
.
pop
(
)
}
}
impl
<
ConcreteNode
>
Iterator
for
TreeIterator
<
ConcreteNode
>
where
ConcreteNode
:
LayoutNode
{
type
Item
=
ConcreteNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
ConcreteNode
>
{
let
ret
=
self
.
stack
.
pop
(
)
;
ret
.
map
(
|
node
|
self
.
stack
.
extend
(
node
.
rev_children
(
)
)
)
;
ret
}
}
pub
trait
ThreadSafeLayoutNode
:
Clone
+
Copy
+
GetLayoutData
+
NodeInfo
+
PartialEq
+
Sized
{
type
ConcreteThreadSafeLayoutElement
:
ThreadSafeLayoutElement
<
ConcreteThreadSafeLayoutNode
=
Self
>
+
:
:
selectors
:
:
Element
<
Impl
=
ServoSelectorImpl
>
;
type
ChildrenIterator
:
Iterator
<
Item
=
Self
>
+
Sized
;
fn
opaque
(
&
self
)
-
>
OpaqueNode
;
fn
type_id
(
&
self
)
-
>
Option
<
LayoutNodeType
>
;
fn
type_id_without_excluding_pseudo_elements
(
&
self
)
-
>
LayoutNodeType
;
fn
style_for_text_node
(
&
self
)
-
>
Arc
<
ServoComputedValues
>
;
#
[
inline
]
fn
is_element_or_elements_pseudo
(
&
self
)
-
>
bool
{
match
self
.
type_id_without_excluding_pseudo_elements
(
)
{
LayoutNodeType
:
:
Element
(
.
.
)
=
>
true
_
=
>
false
}
}
fn
get_before_pseudo
(
&
self
)
-
>
Option
<
Self
>
{
self
.
as_element
(
)
.
and_then
(
|
el
|
el
.
get_before_pseudo
(
)
)
.
map
(
|
el
|
el
.
as_node
(
)
)
}
fn
get_after_pseudo
(
&
self
)
-
>
Option
<
Self
>
{
self
.
as_element
(
)
.
and_then
(
|
el
|
el
.
get_after_pseudo
(
)
)
.
map
(
|
el
|
el
.
as_node
(
)
)
}
fn
get_details_summary_pseudo
(
&
self
)
-
>
Option
<
Self
>
{
self
.
as_element
(
)
.
and_then
(
|
el
|
el
.
get_details_summary_pseudo
(
)
)
.
map
(
|
el
|
el
.
as_node
(
)
)
}
fn
get_details_content_pseudo
(
&
self
)
-
>
Option
<
Self
>
{
self
.
as_element
(
)
.
and_then
(
|
el
|
el
.
get_details_content_pseudo
(
)
)
.
map
(
|
el
|
el
.
as_node
(
)
)
}
fn
debug_id
(
self
)
-
>
usize
;
fn
children
(
&
self
)
-
>
LayoutIterator
<
Self
:
:
ChildrenIterator
>
;
#
[
inline
]
fn
as_element
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteThreadSafeLayoutElement
>
;
#
[
inline
]
fn
get_pseudo_element_type
(
&
self
)
-
>
PseudoElementType
<
Option
<
display
:
:
T
>
>
{
self
.
as_element
(
)
.
map_or
(
PseudoElementType
:
:
Normal
|
el
|
el
.
get_pseudo_element_type
(
)
)
}
fn
get_style_and_layout_data
(
&
self
)
-
>
Option
<
OpaqueStyleAndLayoutData
>
;
fn
style
(
&
self
context
:
&
SharedStyleContext
)
-
>
Arc
<
ServoComputedValues
>
{
if
let
Some
(
el
)
=
self
.
as_element
(
)
{
el
.
style
(
context
)
}
else
{
debug_assert
!
(
self
.
is_text_node
(
)
)
;
self
.
style_for_text_node
(
)
}
}
fn
selected_style
(
&
self
)
-
>
Arc
<
ServoComputedValues
>
{
if
let
Some
(
el
)
=
self
.
as_element
(
)
{
el
.
selected_style
(
)
}
else
{
debug_assert
!
(
self
.
is_text_node
(
)
)
;
self
.
style_for_text_node
(
)
}
}
fn
is_ignorable_whitespace
(
&
self
context
:
&
SharedStyleContext
)
-
>
bool
;
fn
restyle_damage
(
self
)
-
>
RestyleDamage
;
fn
clear_restyle_damage
(
self
)
;
fn
is_content
(
&
self
)
-
>
bool
{
self
.
type_id
(
)
.
is_some
(
)
}
fn
can_be_fragmented
(
&
self
)
-
>
bool
;
fn
node_text_content
(
&
self
)
-
>
String
;
fn
selection
(
&
self
)
-
>
Option
<
Range
<
ByteIndex
>
>
;
fn
image_url
(
&
self
)
-
>
Option
<
Url
>
;
fn
canvas_data
(
&
self
)
-
>
Option
<
HTMLCanvasData
>
;
fn
svg_data
(
&
self
)
-
>
Option
<
SVGSVGData
>
;
fn
iframe_pipeline_id
(
&
self
)
-
>
PipelineId
;
fn
get_colspan
(
&
self
)
-
>
u32
;
}
#
[
allow
(
unsafe_code
)
]
pub
trait
DangerousThreadSafeLayoutNode
:
ThreadSafeLayoutNode
{
unsafe
fn
dangerous_first_child
(
&
self
)
-
>
Option
<
Self
>
;
unsafe
fn
dangerous_next_sibling
(
&
self
)
-
>
Option
<
Self
>
;
}
pub
trait
LayoutElement
:
Clone
+
Copy
+
Sized
+
Debug
+
GetLayoutData
+
TElement
{
}
pub
trait
ThreadSafeLayoutElement
:
Clone
+
Copy
+
Sized
+
Debug
+
:
:
selectors
:
:
Element
<
Impl
=
ServoSelectorImpl
>
+
GetLayoutData
+
PresentationalHintsSynthetizer
{
type
ConcreteThreadSafeLayoutNode
:
ThreadSafeLayoutNode
<
ConcreteThreadSafeLayoutElement
=
Self
>
;
fn
as_node
(
&
self
)
-
>
Self
:
:
ConcreteThreadSafeLayoutNode
;
fn
with_pseudo
(
&
self
pseudo
:
PseudoElementType
<
Option
<
display
:
:
T
>
>
)
-
>
Self
;
fn
type_id
(
&
self
)
-
>
Option
<
LayoutNodeType
>
;
#
[
inline
]
fn
get_attr
(
&
self
namespace
:
&
Namespace
name
:
&
LocalName
)
-
>
Option
<
&
str
>
;
fn
get_style_data
(
&
self
)
-
>
Option
<
&
AtomicRefCell
<
ElementData
>
>
;
#
[
inline
]
fn
get_pseudo_element_type
(
&
self
)
-
>
PseudoElementType
<
Option
<
display
:
:
T
>
>
;
#
[
inline
]
fn
get_before_pseudo
(
&
self
)
-
>
Option
<
Self
>
{
if
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
.
current_styles
(
)
.
pseudos
.
contains_key
(
&
PseudoElement
:
:
Before
)
{
Some
(
self
.
with_pseudo
(
PseudoElementType
:
:
Before
(
None
)
)
)
}
else
{
None
}
}
#
[
inline
]
fn
get_after_pseudo
(
&
self
)
-
>
Option
<
Self
>
{
if
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
.
current_styles
(
)
.
pseudos
.
contains_key
(
&
PseudoElement
:
:
After
)
{
Some
(
self
.
with_pseudo
(
PseudoElementType
:
:
After
(
None
)
)
)
}
else
{
None
}
}
#
[
inline
]
fn
get_details_summary_pseudo
(
&
self
)
-
>
Option
<
Self
>
{
if
self
.
get_local_name
(
)
=
=
&
local_name
!
(
"
details
"
)
&
&
self
.
get_namespace
(
)
=
=
&
ns
!
(
html
)
{
Some
(
self
.
with_pseudo
(
PseudoElementType
:
:
DetailsSummary
(
None
)
)
)
}
else
{
None
}
}
#
[
inline
]
fn
get_details_content_pseudo
(
&
self
)
-
>
Option
<
Self
>
{
if
self
.
get_local_name
(
)
=
=
&
local_name
!
(
"
details
"
)
&
&
self
.
get_namespace
(
)
=
=
&
ns
!
(
html
)
{
let
display
=
if
self
.
get_attr
(
&
ns
!
(
)
&
local_name
!
(
"
open
"
)
)
.
is_some
(
)
{
None
}
else
{
Some
(
display
:
:
T
:
:
none
)
}
;
Some
(
self
.
with_pseudo
(
PseudoElementType
:
:
DetailsContent
(
display
)
)
)
}
else
{
None
}
}
#
[
inline
]
fn
style
(
&
self
context
:
&
SharedStyleContext
)
-
>
Arc
<
ServoComputedValues
>
{
match
self
.
get_pseudo_element_type
(
)
{
PseudoElementType
:
:
Normal
=
>
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
.
current_styles
(
)
.
primary
.
clone
(
)
other
=
>
{
let
style_pseudo
=
other
.
style_pseudo_element
(
)
;
match
style_pseudo
.
cascade_type
(
)
{
PseudoElementCascadeType
:
:
Eager
=
>
{
}
PseudoElementCascadeType
:
:
Precomputed
=
>
{
if
!
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
.
current_styles
(
)
.
pseudos
.
contains_key
(
&
style_pseudo
)
{
let
mut
data
=
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow_mut
(
)
;
let
new_style_and_rule_node
=
context
.
stylist
.
precomputed_values_for_pseudo
(
&
style_pseudo
Some
(
&
data
.
current_styles
(
)
.
primary
)
false
)
;
data
.
current_pseudos_mut
(
)
.
insert
(
style_pseudo
.
clone
(
)
new_style_and_rule_node
.
unwrap
(
)
)
;
}
}
PseudoElementCascadeType
:
:
Lazy
=
>
{
if
!
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
.
current_styles
(
)
.
pseudos
.
contains_key
(
&
style_pseudo
)
{
let
mut
data
=
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow_mut
(
)
;
let
new_style
=
context
.
stylist
.
lazily_compute_pseudo_element_style
(
self
&
style_pseudo
&
data
.
current_styles
(
)
.
primary
)
;
data
.
current_pseudos_mut
(
)
.
insert
(
style_pseudo
.
clone
(
)
new_style
.
unwrap
(
)
)
;
}
}
}
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
.
current_styles
(
)
.
pseudos
.
get
(
&
style_pseudo
)
.
unwrap
(
)
.
0
.
clone
(
)
}
}
}
#
[
inline
]
fn
selected_style
(
&
self
)
-
>
Arc
<
ServoComputedValues
>
{
let
data
=
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
;
data
.
current_styles
(
)
.
pseudos
.
get
(
&
PseudoElement
:
:
Selection
)
.
map
(
|
s
|
&
s
.
0
)
.
unwrap_or
(
&
data
.
current_styles
(
)
.
primary
)
.
clone
(
)
}
#
[
inline
]
fn
resolved_style
(
&
self
)
-
>
Arc
<
ServoComputedValues
>
{
let
data
=
self
.
get_style_data
(
)
.
unwrap
(
)
.
borrow
(
)
;
match
self
.
get_pseudo_element_type
(
)
{
PseudoElementType
:
:
Normal
=
>
data
.
current_styles
(
)
.
primary
.
clone
(
)
other
=
>
data
.
current_styles
(
)
.
pseudos
.
get
(
&
other
.
style_pseudo_element
(
)
)
.
unwrap
(
)
.
0
.
clone
(
)
}
}
}
