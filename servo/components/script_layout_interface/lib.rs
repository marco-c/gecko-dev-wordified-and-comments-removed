#
!
[
deny
(
unsafe_code
)
]
extern
crate
app_units
;
extern
crate
atomic_refcell
;
extern
crate
canvas_traits
;
extern
crate
cssparser
;
extern
crate
euclid
;
extern
crate
gfx_traits
;
extern
crate
heapsize
;
#
[
macro_use
]
extern
crate
heapsize_derive
;
#
[
macro_use
]
extern
crate
html5ever
;
extern
crate
ipc_channel
;
extern
crate
libc
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
metrics
;
extern
crate
msg
;
extern
crate
net_traits
;
extern
crate
nonzero
;
extern
crate
profile_traits
;
extern
crate
range
;
extern
crate
script_traits
;
extern
crate
selectors
;
extern
crate
servo_arc
;
extern
crate
servo_atoms
;
extern
crate
servo_url
;
extern
crate
style
;
extern
crate
webrender_api
;
pub
mod
message
;
pub
mod
reporter
;
pub
mod
rpc
;
pub
mod
wrapper_traits
;
use
atomic_refcell
:
:
AtomicRefCell
;
use
canvas_traits
:
:
canvas
:
:
CanvasMsg
;
use
ipc_channel
:
:
ipc
:
:
IpcSender
;
use
libc
:
:
c_void
;
use
net_traits
:
:
image_cache
:
:
PendingImageId
;
use
nonzero
:
:
NonZero
;
use
script_traits
:
:
UntrustedNodeAddress
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicIsize
;
use
style
:
:
data
:
:
ElementData
;
#
[
repr
(
C
)
]
pub
struct
StyleData
{
pub
element_data
:
AtomicRefCell
<
ElementData
>
pub
parallel
:
DomParallelInfo
}
impl
StyleData
{
pub
fn
new
(
)
-
>
Self
{
Self
{
element_data
:
AtomicRefCell
:
:
new
(
ElementData
:
:
default
(
)
)
parallel
:
DomParallelInfo
:
:
new
(
)
}
}
}
#
[
derive
(
Clone
Copy
HeapSizeOf
)
]
pub
struct
OpaqueStyleAndLayoutData
{
#
[
ignore_heap_size_of
=
"
TODO
(
#
6910
)
Box
value
that
should
be
counted
but
\
the
type
lives
in
layout
"
]
pub
ptr
:
NonZero
<
*
mut
StyleData
>
}
#
[
allow
(
unsafe_code
)
]
unsafe
impl
Send
for
OpaqueStyleAndLayoutData
{
}
#
[
derive
(
HeapSizeOf
)
]
pub
struct
DomParallelInfo
{
pub
children_to_process
:
AtomicIsize
}
impl
DomParallelInfo
{
pub
fn
new
(
)
-
>
DomParallelInfo
{
DomParallelInfo
{
children_to_process
:
AtomicIsize
:
:
new
(
0
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
LayoutNodeType
{
Element
(
LayoutElementType
)
Text
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
LayoutElementType
{
Element
HTMLCanvasElement
HTMLIFrameElement
HTMLImageElement
HTMLInputElement
HTMLObjectElement
HTMLTableCellElement
HTMLTableColElement
HTMLTableElement
HTMLTableRowElement
HTMLTableSectionElement
HTMLTextAreaElement
SVGSVGElement
}
pub
enum
HTMLCanvasDataSource
{
WebGL
(
webrender_api
:
:
ImageKey
)
Image
(
Option
<
IpcSender
<
CanvasMsg
>
>
)
}
pub
struct
HTMLCanvasData
{
pub
source
:
HTMLCanvasDataSource
pub
width
:
u32
pub
height
:
u32
}
pub
struct
SVGSVGData
{
pub
width
:
u32
pub
height
:
u32
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
struct
TrustedNodeAddress
(
pub
*
const
c_void
)
;
#
[
allow
(
unsafe_code
)
]
unsafe
impl
Send
for
TrustedNodeAddress
{
}
pub
fn
is_image_data
(
uri
:
&
str
)
-
>
bool
{
static
TYPES
:
&
'
static
[
&
'
static
str
]
=
&
[
"
data
:
image
/
png
"
"
data
:
image
/
gif
"
"
data
:
image
/
jpeg
"
]
;
TYPES
.
iter
(
)
.
any
(
|
&
type_
|
uri
.
starts_with
(
type_
)
)
}
pub
enum
PendingImageState
{
Unrequested
(
ServoUrl
)
PendingResponse
}
pub
struct
PendingImage
{
pub
state
:
PendingImageState
pub
node
:
UntrustedNodeAddress
pub
id
:
PendingImageId
}
