use
ipc_channel
:
:
ipc
:
:
{
self
IpcReceiver
}
;
use
ipc_channel
:
:
router
:
:
ROUTER
;
use
profile_traits
:
:
mem
:
:
{
ProfilerChan
ProfilerMsg
ReportKind
Reporter
ReporterRequest
}
;
use
profile_traits
:
:
mem
:
:
ReportsChan
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
thread
;
use
time
:
:
duration_from_seconds
;
pub
struct
Profiler
{
pub
port
:
IpcReceiver
<
ProfilerMsg
>
reporters
:
HashMap
<
String
Reporter
>
}
const
JEMALLOC_HEAP_ALLOCATED_STR
:
&
'
static
str
=
"
jemalloc
-
heap
-
allocated
"
;
const
SYSTEM_HEAP_ALLOCATED_STR
:
&
'
static
str
=
"
system
-
heap
-
allocated
"
;
impl
Profiler
{
pub
fn
create
(
period
:
Option
<
f64
>
)
-
>
ProfilerChan
{
let
(
chan
port
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
if
let
Some
(
period
)
=
period
{
let
chan
=
chan
.
clone
(
)
;
thread
:
:
Builder
:
:
new
(
)
.
name
(
"
Memory
profiler
timer
"
.
to_owned
(
)
)
.
spawn
(
move
|
|
{
loop
{
thread
:
:
sleep
(
duration_from_seconds
(
period
)
)
;
if
chan
.
send
(
ProfilerMsg
:
:
Print
)
.
is_err
(
)
{
break
;
}
}
}
)
.
expect
(
"
Thread
spawning
failed
"
)
;
}
thread
:
:
Builder
:
:
new
(
)
.
name
(
"
Memory
profiler
"
.
to_owned
(
)
)
.
spawn
(
move
|
|
{
let
mut
mem_profiler
=
Profiler
:
:
new
(
port
)
;
mem_profiler
.
start
(
)
;
}
)
.
expect
(
"
Thread
spawning
failed
"
)
;
let
mem_profiler_chan
=
ProfilerChan
(
chan
)
;
let
(
system_reporter_sender
system_reporter_receiver
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
ROUTER
.
add_route
(
system_reporter_receiver
.
to_opaque
(
)
box
|
message
|
{
let
request
:
ReporterRequest
=
message
.
to
(
)
.
unwrap
(
)
;
system_reporter
:
:
collect_reports
(
request
)
}
)
;
mem_profiler_chan
.
send
(
ProfilerMsg
:
:
RegisterReporter
(
"
system
"
.
to_owned
(
)
Reporter
(
system_reporter_sender
)
)
)
;
mem_profiler_chan
}
pub
fn
new
(
port
:
IpcReceiver
<
ProfilerMsg
>
)
-
>
Profiler
{
Profiler
{
port
:
port
reporters
:
HashMap
:
:
new
(
)
}
}
pub
fn
start
(
&
mut
self
)
{
while
let
Ok
(
msg
)
=
self
.
port
.
recv
(
)
{
if
!
self
.
handle_msg
(
msg
)
{
break
}
}
}
fn
handle_msg
(
&
mut
self
msg
:
ProfilerMsg
)
-
>
bool
{
match
msg
{
ProfilerMsg
:
:
RegisterReporter
(
name
reporter
)
=
>
{
let
name_clone
=
name
.
clone
(
)
;
match
self
.
reporters
.
insert
(
name
reporter
)
{
None
=
>
true
Some
(
_
)
=
>
panic
!
(
format
!
(
"
RegisterReporter
:
'
{
}
'
name
is
already
in
use
"
name_clone
)
)
}
}
ProfilerMsg
:
:
UnregisterReporter
(
name
)
=
>
{
match
self
.
reporters
.
remove
(
&
name
)
{
Some
(
_
)
=
>
true
None
=
>
panic
!
(
format
!
(
"
UnregisterReporter
:
'
{
}
'
name
is
unknown
"
&
name
)
)
}
}
ProfilerMsg
:
:
Print
=
>
{
self
.
handle_print_msg
(
)
;
true
}
ProfilerMsg
:
:
Exit
=
>
false
}
}
fn
handle_print_msg
(
&
self
)
{
println
!
(
"
Begin
memory
reports
"
)
;
println
!
(
"
|
"
)
;
let
mut
forest
=
ReportsForest
:
:
new
(
)
;
let
mut
jemalloc_heap_reported_size
=
0
;
let
mut
system_heap_reported_size
=
0
;
let
mut
jemalloc_heap_allocated_size
:
Option
<
usize
>
=
None
;
let
mut
system_heap_allocated_size
:
Option
<
usize
>
=
None
;
for
reporter
in
self
.
reporters
.
values
(
)
{
let
(
chan
port
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
reporter
.
collect_reports
(
ReportsChan
(
chan
)
)
;
if
let
Ok
(
mut
reports
)
=
port
.
recv
(
)
{
for
report
in
&
mut
reports
{
match
report
.
kind
{
ReportKind
:
:
ExplicitJemallocHeapSize
|
ReportKind
:
:
ExplicitSystemHeapSize
|
ReportKind
:
:
ExplicitNonHeapSize
|
ReportKind
:
:
ExplicitUnknownLocationSize
=
>
report
.
path
.
insert
(
0
String
:
:
from
(
"
explicit
"
)
)
ReportKind
:
:
NonExplicitSize
=
>
{
}
}
match
report
.
kind
{
ReportKind
:
:
ExplicitJemallocHeapSize
=
>
jemalloc_heap_reported_size
+
=
report
.
size
ReportKind
:
:
ExplicitSystemHeapSize
=
>
system_heap_reported_size
+
=
report
.
size
_
=
>
{
}
}
if
report
.
path
.
len
(
)
=
=
1
{
if
report
.
path
[
0
]
=
=
JEMALLOC_HEAP_ALLOCATED_STR
{
assert
!
(
jemalloc_heap_allocated_size
.
is_none
(
)
)
;
jemalloc_heap_allocated_size
=
Some
(
report
.
size
)
;
}
else
if
report
.
path
[
0
]
=
=
SYSTEM_HEAP_ALLOCATED_STR
{
assert
!
(
system_heap_allocated_size
.
is_none
(
)
)
;
system_heap_allocated_size
=
Some
(
report
.
size
)
;
}
}
forest
.
insert
(
&
report
.
path
report
.
size
)
;
}
}
}
if
let
Some
(
jemalloc_heap_allocated_size
)
=
jemalloc_heap_allocated_size
{
forest
.
insert
(
&
path
!
[
"
explicit
"
"
jemalloc
-
heap
-
unclassified
"
]
jemalloc_heap_allocated_size
-
jemalloc_heap_reported_size
)
;
}
if
let
Some
(
system_heap_allocated_size
)
=
system_heap_allocated_size
{
forest
.
insert
(
&
path
!
[
"
explicit
"
"
system
-
heap
-
unclassified
"
]
system_heap_allocated_size
-
system_heap_reported_size
)
;
}
forest
.
print
(
)
;
println
!
(
"
|
"
)
;
println
!
(
"
End
memory
reports
"
)
;
println
!
(
"
"
)
;
}
}
struct
ReportsTree
{
size
:
usize
count
:
u32
path_seg
:
String
children
:
Vec
<
ReportsTree
>
}
impl
ReportsTree
{
fn
new
(
path_seg
:
String
)
-
>
ReportsTree
{
ReportsTree
{
size
:
0
count
:
0
path_seg
:
path_seg
children
:
vec
!
[
]
}
}
fn
find_child
(
&
self
path_seg
:
&
str
)
-
>
Option
<
usize
>
{
for
(
i
child
)
in
self
.
children
.
iter
(
)
.
enumerate
(
)
{
if
child
.
path_seg
=
=
*
path_seg
{
return
Some
(
i
)
;
}
}
None
}
fn
insert
(
&
mut
self
path
:
&
[
String
]
size
:
usize
)
{
let
mut
t
:
&
mut
ReportsTree
=
self
;
for
path_seg
in
path
{
let
i
=
match
t
.
find_child
(
&
path_seg
)
{
Some
(
i
)
=
>
i
None
=
>
{
let
new_t
=
ReportsTree
:
:
new
(
path_seg
.
clone
(
)
)
;
t
.
children
.
push
(
new_t
)
;
t
.
children
.
len
(
)
-
1
}
}
;
let
tmp
=
t
;
t
=
&
mut
tmp
.
children
[
i
]
;
}
t
.
size
+
=
size
;
t
.
count
+
=
1
;
}
fn
compute_interior_node_sizes_and_sort
(
&
mut
self
)
-
>
usize
{
if
!
self
.
children
.
is_empty
(
)
{
if
self
.
size
!
=
0
{
panic
!
(
"
one
report
'
s
path
is
a
sub
-
path
of
another
report
'
s
path
"
)
;
}
for
child
in
&
mut
self
.
children
{
self
.
size
+
=
child
.
compute_interior_node_sizes_and_sort
(
)
;
}
self
.
children
.
sort_by
(
|
t1
t2
|
t2
.
size
.
cmp
(
&
t1
.
size
)
)
;
}
self
.
size
}
fn
print
(
&
self
depth
:
i32
)
{
if
!
self
.
children
.
is_empty
(
)
{
assert_eq
!
(
self
.
count
0
)
;
}
let
mut
indent_str
=
String
:
:
new
(
)
;
for
_
in
0
.
.
depth
{
indent_str
.
push_str
(
"
"
)
;
}
let
mebi
=
1024f64
*
1024f64
;
let
count_str
=
if
self
.
count
>
1
{
format
!
(
"
[
{
}
]
"
self
.
count
)
}
else
{
"
"
.
to_owned
(
)
}
;
println
!
(
"
|
{
}
{
:
8
.
2
}
MiB
-
-
{
}
{
}
"
indent_str
(
self
.
size
as
f64
)
/
mebi
self
.
path_seg
count_str
)
;
for
child
in
&
self
.
children
{
child
.
print
(
depth
+
1
)
;
}
}
}
struct
ReportsForest
{
trees
:
HashMap
<
String
ReportsTree
>
}
impl
ReportsForest
{
fn
new
(
)
-
>
ReportsForest
{
ReportsForest
{
trees
:
HashMap
:
:
new
(
)
}
}
fn
insert
(
&
mut
self
path
:
&
[
String
]
size
:
usize
)
{
let
(
head
tail
)
=
path
.
split_first
(
)
.
unwrap
(
)
;
if
!
self
.
trees
.
contains_key
(
head
)
{
self
.
trees
.
insert
(
head
.
clone
(
)
ReportsTree
:
:
new
(
head
.
clone
(
)
)
)
;
}
let
t
=
self
.
trees
.
get_mut
(
head
)
.
unwrap
(
)
;
t
.
insert
(
tail
size
)
;
}
fn
print
(
&
mut
self
)
{
for
(
_
tree
)
in
&
mut
self
.
trees
{
tree
.
compute_interior_node_sizes_and_sort
(
)
;
}
let
mut
v
=
vec
!
[
]
;
for
(
_
tree
)
in
&
self
.
trees
{
v
.
push
(
tree
)
;
}
v
.
sort_by
(
|
a
b
|
{
if
a
.
children
.
is_empty
(
)
&
&
!
b
.
children
.
is_empty
(
)
{
Ordering
:
:
Greater
}
else
if
!
a
.
children
.
is_empty
(
)
&
&
b
.
children
.
is_empty
(
)
{
Ordering
:
:
Less
}
else
{
a
.
path_seg
.
cmp
(
&
b
.
path_seg
)
}
}
)
;
for
tree
in
&
v
{
tree
.
print
(
0
)
;
if
!
tree
.
children
.
is_empty
(
)
{
println
!
(
"
|
"
)
;
}
}
}
}
mod
system_reporter
{
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
use
libc
:
:
{
c_char
c_int
c_void
size_t
}
;
use
profile_traits
:
:
mem
:
:
{
Report
ReportKind
ReporterRequest
}
;
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
use
std
:
:
ffi
:
:
CString
;
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
use
std
:
:
mem
:
:
size_of
;
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
use
std
:
:
ptr
:
:
null_mut
;
use
super
:
:
{
JEMALLOC_HEAP_ALLOCATED_STR
SYSTEM_HEAP_ALLOCATED_STR
}
;
#
[
cfg
(
target_os
=
"
macos
"
)
]
use
task_info
:
:
task_basic_info
:
:
{
virtual_size
resident_size
}
;
pub
fn
collect_reports
(
request
:
ReporterRequest
)
{
let
mut
reports
=
vec
!
[
]
;
{
let
mut
report
=
|
path
size
|
{
if
let
Some
(
size
)
=
size
{
reports
.
push
(
Report
{
path
:
path
kind
:
ReportKind
:
:
NonExplicitSize
size
:
size
}
)
;
}
}
;
report
(
path
!
[
"
vsize
"
]
vsize
(
)
)
;
report
(
path
!
[
"
resident
"
]
resident
(
)
)
;
for
seg
in
resident_segments
(
)
{
report
(
path
!
[
"
resident
-
according
-
to
-
smaps
"
seg
.
0
]
Some
(
seg
.
1
)
)
;
}
report
(
path
!
[
SYSTEM_HEAP_ALLOCATED_STR
]
system_heap_allocated
(
)
)
;
report
(
path
!
[
JEMALLOC_HEAP_ALLOCATED_STR
]
jemalloc_stat
(
"
stats
.
allocated
"
)
)
;
report
(
path
!
[
"
jemalloc
-
heap
-
active
"
]
jemalloc_stat
(
"
stats
.
active
"
)
)
;
report
(
path
!
[
"
jemalloc
-
heap
-
mapped
"
]
jemalloc_stat
(
"
stats
.
mapped
"
)
)
;
}
request
.
reports_channel
.
send
(
reports
)
;
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
extern
{
fn
mallinfo
(
)
-
>
struct_mallinfo
;
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
#
[
repr
(
C
)
]
pub
struct
struct_mallinfo
{
arena
:
c_int
ordblks
:
c_int
smblks
:
c_int
hblks
:
c_int
hblkhd
:
c_int
usmblks
:
c_int
fsmblks
:
c_int
uordblks
:
c_int
fordblks
:
c_int
keepcost
:
c_int
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
system_heap_allocated
(
)
-
>
Option
<
usize
>
{
let
info
:
struct_mallinfo
=
unsafe
{
mallinfo
(
)
}
;
if
info
.
hblkhd
<
0
|
|
info
.
uordblks
<
0
{
None
}
else
{
Some
(
info
.
hblkhd
as
usize
+
info
.
uordblks
as
usize
)
}
}
#
[
cfg
(
not
(
target_os
=
"
linux
"
)
)
]
fn
system_heap_allocated
(
)
-
>
Option
<
usize
>
{
None
}
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
extern
{
#
[
cfg_attr
(
any
(
target_os
=
"
macos
"
target_os
=
"
android
"
)
link_name
=
"
je_mallctl
"
)
]
fn
mallctl
(
name
:
*
const
c_char
oldp
:
*
mut
c_void
oldlenp
:
*
mut
size_t
newp
:
*
mut
c_void
newlen
:
size_t
)
-
>
c_int
;
}
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
fn
jemalloc_stat
(
value_name
:
&
str
)
-
>
Option
<
usize
>
{
let
epoch_name
=
"
epoch
"
;
let
epoch_c_name
=
CString
:
:
new
(
epoch_name
)
.
unwrap
(
)
;
let
mut
epoch
:
u64
=
0
;
let
epoch_ptr
=
&
mut
epoch
as
*
mut
_
as
*
mut
c_void
;
let
mut
epoch_len
=
size_of
:
:
<
u64
>
(
)
as
size_t
;
let
value_c_name
=
CString
:
:
new
(
value_name
)
.
unwrap
(
)
;
let
mut
value
:
size_t
=
0
;
let
value_ptr
=
&
mut
value
as
*
mut
_
as
*
mut
c_void
;
let
mut
value_len
=
size_of
:
:
<
size_t
>
(
)
as
size_t
;
let
rv
=
unsafe
{
mallctl
(
epoch_c_name
.
as_ptr
(
)
epoch_ptr
&
mut
epoch_len
epoch_ptr
epoch_len
)
}
;
if
rv
!
=
0
{
return
None
;
}
let
rv
=
unsafe
{
mallctl
(
value_c_name
.
as_ptr
(
)
value_ptr
&
mut
value_len
null_mut
(
)
0
)
}
;
if
rv
!
=
0
{
return
None
;
}
Some
(
value
as
usize
)
}
#
[
cfg
(
target_os
=
"
windows
"
)
]
fn
jemalloc_stat
(
_value_name
:
&
str
)
-
>
Option
<
usize
>
{
None
}
macro_rules
!
option_try
(
(
e
:
expr
)
=
>
(
match
e
{
Some
(
e
)
=
>
e
None
=
>
return
None
}
)
)
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
page_size
(
)
-
>
usize
{
unsafe
{
:
:
libc
:
:
sysconf
(
:
:
libc
:
:
_SC_PAGESIZE
)
as
usize
}
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
proc_self_statm_field
(
field
:
usize
)
-
>
Option
<
usize
>
{
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
Read
;
let
mut
f
=
option_try
!
(
File
:
:
open
(
"
/
proc
/
self
/
statm
"
)
.
ok
(
)
)
;
let
mut
contents
=
String
:
:
new
(
)
;
option_try
!
(
f
.
read_to_string
(
&
mut
contents
)
.
ok
(
)
)
;
let
s
=
option_try
!
(
contents
.
split_whitespace
(
)
.
nth
(
field
)
)
;
let
npages
=
option_try
!
(
s
.
parse
:
:
<
usize
>
(
)
.
ok
(
)
)
;
Some
(
npages
*
page_size
(
)
)
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
vsize
(
)
-
>
Option
<
usize
>
{
proc_self_statm_field
(
0
)
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
resident
(
)
-
>
Option
<
usize
>
{
proc_self_statm_field
(
1
)
}
#
[
cfg
(
target_os
=
"
macos
"
)
]
fn
vsize
(
)
-
>
Option
<
usize
>
{
virtual_size
(
)
}
#
[
cfg
(
target_os
=
"
macos
"
)
]
fn
resident
(
)
-
>
Option
<
usize
>
{
resident_size
(
)
}
#
[
cfg
(
not
(
any
(
target_os
=
"
linux
"
target_os
=
"
macos
"
)
)
)
]
fn
vsize
(
)
-
>
Option
<
usize
>
{
None
}
#
[
cfg
(
not
(
any
(
target_os
=
"
linux
"
target_os
=
"
macos
"
)
)
)
]
fn
resident
(
)
-
>
Option
<
usize
>
{
None
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
resident_segments
(
)
-
>
Vec
<
(
String
usize
)
>
{
use
regex
:
:
Regex
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
BufReader
BufRead
}
;
let
f
=
match
File
:
:
open
(
"
/
proc
/
self
/
smaps
"
)
{
Ok
(
f
)
=
>
BufReader
:
:
new
(
f
)
Err
(
_
)
=
>
return
vec
!
[
]
}
;
let
seg_re
=
Regex
:
:
new
(
r
"
^
[
:
xdigit
:
]
+
-
[
:
xdigit
:
]
+
(
.
.
.
.
)
[
:
xdigit
:
]
+
[
:
xdigit
:
]
+
:
[
:
xdigit
:
]
+
\
d
+
+
(
.
*
)
"
)
.
unwrap
(
)
;
let
rss_re
=
Regex
:
:
new
(
r
"
^
Rss
:
+
(
\
d
+
)
kB
"
)
.
unwrap
(
)
;
let
mut
seg_map
:
HashMap
<
String
usize
>
=
HashMap
:
:
new
(
)
;
#
[
derive
(
PartialEq
)
]
enum
LookingFor
{
Segment
Rss
}
let
mut
looking_for
=
LookingFor
:
:
Segment
;
let
mut
curr_seg_name
=
String
:
:
new
(
)
;
for
line
in
f
.
lines
(
)
{
let
line
=
match
line
{
Ok
(
line
)
=
>
line
Err
(
_
)
=
>
continue
}
;
if
looking_for
=
=
LookingFor
:
:
Segment
{
let
cap
=
match
seg_re
.
captures
(
&
line
)
{
Some
(
cap
)
=
>
cap
None
=
>
continue
}
;
let
perms
=
cap
.
at
(
1
)
.
unwrap
(
)
;
let
pathname
=
cap
.
at
(
2
)
.
unwrap
(
)
;
curr_seg_name
.
clear
(
)
;
if
pathname
=
=
"
"
|
|
pathname
.
starts_with
(
"
[
stack
:
"
)
{
curr_seg_name
.
push_str
(
"
anonymous
"
)
;
}
else
{
curr_seg_name
.
push_str
(
pathname
)
;
}
curr_seg_name
.
push_str
(
"
(
"
)
;
curr_seg_name
.
push_str
(
perms
)
;
curr_seg_name
.
push_str
(
"
)
"
)
;
looking_for
=
LookingFor
:
:
Rss
;
}
else
{
let
cap
=
match
rss_re
.
captures
(
&
line
)
{
Some
(
cap
)
=
>
cap
None
=
>
continue
}
;
let
rss
=
cap
.
at
(
1
)
.
unwrap
(
)
.
parse
:
:
<
usize
>
(
)
.
unwrap
(
)
*
1024
;
if
rss
>
0
{
let
seg_name
=
if
rss
<
512
*
1024
{
"
other
"
.
to_owned
(
)
}
else
{
curr_seg_name
.
clone
(
)
}
;
match
seg_map
.
entry
(
seg_name
)
{
Entry
:
:
Vacant
(
entry
)
=
>
{
entry
.
insert
(
rss
)
;
}
Entry
:
:
Occupied
(
mut
entry
)
=
>
*
entry
.
get_mut
(
)
+
=
rss
}
}
looking_for
=
LookingFor
:
:
Segment
;
}
}
seg_map
.
into_iter
(
)
.
collect
(
)
}
#
[
cfg
(
not
(
target_os
=
"
linux
"
)
)
]
fn
resident_segments
(
)
-
>
Vec
<
(
String
usize
)
>
{
vec
!
[
]
}
}
