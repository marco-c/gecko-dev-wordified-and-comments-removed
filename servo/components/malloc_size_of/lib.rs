extern
crate
hashglobe
;
extern
crate
servo_arc
;
extern
crate
smallbitvec
;
extern
crate
smallvec
;
use
hashglobe
:
:
hash_map
:
:
HashMap
;
use
servo_arc
:
:
Arc
;
use
smallbitvec
:
:
SmallBitVec
;
use
smallvec
:
:
{
Array
SmallVec
}
;
use
std
:
:
collections
:
:
HashSet
;
use
std
:
:
hash
:
:
{
BuildHasher
Hash
}
;
use
std
:
:
os
:
:
raw
:
:
c_void
;
type
VoidPtrToSizeFn
=
unsafe
extern
"
C
"
fn
(
ptr
:
*
const
c_void
)
-
>
usize
;
type
VoidPtrToBoolFnMut
=
FnMut
(
*
const
c_void
)
-
>
bool
;
pub
struct
MallocSizeOfOps
{
size_of_op
:
VoidPtrToSizeFn
enclosing_size_of_op
:
Option
<
VoidPtrToSizeFn
>
have_seen_ptr_op
:
Option
<
Box
<
VoidPtrToBoolFnMut
>
>
}
impl
MallocSizeOfOps
{
pub
fn
new
(
size_of
:
VoidPtrToSizeFn
malloc_enclosing_size_of
:
Option
<
VoidPtrToSizeFn
>
have_seen_ptr
:
Option
<
Box
<
VoidPtrToBoolFnMut
>
>
)
-
>
Self
{
MallocSizeOfOps
{
size_of_op
:
size_of
enclosing_size_of_op
:
malloc_enclosing_size_of
have_seen_ptr_op
:
have_seen_ptr
}
}
fn
is_empty
<
T
>
(
ptr
:
*
const
T
)
-
>
bool
{
return
ptr
as
usize
<
=
:
:
std
:
:
mem
:
:
align_of
:
:
<
T
>
(
)
;
}
pub
fn
malloc_size_of
<
T
>
(
&
self
ptr
:
*
const
T
)
-
>
usize
{
if
MallocSizeOfOps
:
:
is_empty
(
ptr
)
{
0
}
else
{
unsafe
{
(
self
.
size_of_op
)
(
ptr
as
*
const
c_void
)
}
}
}
pub
fn
malloc_enclosing_size_of
<
T
>
(
&
self
ptr
:
*
const
T
)
-
>
usize
{
assert
!
(
!
MallocSizeOfOps
:
:
is_empty
(
ptr
)
)
;
let
enclosing_size_of_op
=
self
.
enclosing_size_of_op
.
expect
(
"
missing
enclosing_size_of_op
"
)
;
unsafe
{
enclosing_size_of_op
(
ptr
as
*
const
c_void
)
}
}
pub
fn
have_seen_ptr
<
T
>
(
&
mut
self
ptr
:
*
const
T
)
-
>
bool
{
let
have_seen_ptr_op
=
self
.
have_seen_ptr_op
.
as_mut
(
)
.
expect
(
"
missing
have_seen_ptr_op
"
)
;
have_seen_ptr_op
(
ptr
as
*
const
c_void
)
}
}
pub
trait
MallocSizeOf
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
;
}
pub
trait
MallocShallowSizeOf
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
;
}
pub
trait
MallocUnconditionalSizeOf
{
fn
unconditional_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
;
}
pub
trait
MallocConditionalSizeOf
{
fn
conditional_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
;
}
impl
<
T
>
MallocShallowSizeOf
for
Box
<
T
>
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
ops
.
malloc_size_of
(
&
*
*
self
)
}
}
impl
<
T
:
MallocSizeOf
>
MallocSizeOf
for
Box
<
T
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
shallow_size_of
(
ops
)
+
(
*
*
self
)
.
size_of
(
ops
)
}
}
impl
<
A
:
MallocSizeOf
B
:
MallocSizeOf
>
MallocSizeOf
for
(
A
B
)
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
0
.
size_of
(
ops
)
+
self
.
1
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
>
MallocSizeOf
for
Option
<
T
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
if
let
Some
(
val
)
=
self
.
as_ref
(
)
{
val
.
size_of
(
ops
)
}
else
{
0
}
}
}
impl
<
T
>
MallocShallowSizeOf
for
Vec
<
T
>
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
ops
.
malloc_size_of
(
self
.
as_ptr
(
)
)
}
}
impl
<
T
:
MallocSizeOf
>
MallocSizeOf
for
Vec
<
T
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
shallow_size_of
(
ops
)
;
for
elem
in
self
.
iter
(
)
{
n
+
=
elem
.
size_of
(
ops
)
;
}
n
}
}
impl
<
A
:
Array
>
MallocShallowSizeOf
for
SmallVec
<
A
>
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
if
self
.
spilled
(
)
{
ops
.
malloc_size_of
(
self
.
as_ptr
(
)
)
}
else
{
0
}
}
}
impl
<
A
>
MallocSizeOf
for
SmallVec
<
A
>
where
A
:
Array
A
:
:
Item
:
MallocSizeOf
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
shallow_size_of
(
ops
)
;
for
elem
in
self
.
iter
(
)
{
n
+
=
elem
.
size_of
(
ops
)
;
}
n
}
}
impl
<
T
S
>
MallocShallowSizeOf
for
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
iter
(
)
.
next
(
)
.
map_or
(
0
|
t
|
ops
.
malloc_enclosing_size_of
(
t
)
)
}
}
impl
<
T
S
>
MallocSizeOf
for
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
+
MallocSizeOf
S
:
BuildHasher
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
shallow_size_of
(
ops
)
;
for
t
in
self
.
iter
(
)
{
n
+
=
t
.
size_of
(
ops
)
;
}
n
}
}
impl
<
K
V
S
>
MallocShallowSizeOf
for
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
S
:
BuildHasher
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
values
(
)
.
next
(
)
.
map_or
(
0
|
v
|
ops
.
malloc_enclosing_size_of
(
v
)
)
}
}
impl
<
K
V
S
>
MallocSizeOf
for
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
+
MallocSizeOf
V
:
MallocSizeOf
S
:
BuildHasher
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
shallow_size_of
(
ops
)
;
for
(
k
v
)
in
self
.
iter
(
)
{
n
+
=
k
.
size_of
(
ops
)
;
n
+
=
v
.
size_of
(
ops
)
;
}
n
}
}
impl
<
T
:
MallocSizeOf
>
MallocUnconditionalSizeOf
for
Arc
<
T
>
{
fn
unconditional_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
ops
.
malloc_size_of
(
self
.
heap_ptr
(
)
)
+
(
*
*
self
)
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
>
MallocConditionalSizeOf
for
Arc
<
T
>
{
fn
conditional_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
if
ops
.
have_seen_ptr
(
self
.
heap_ptr
(
)
)
{
0
}
else
{
self
.
unconditional_size_of
(
ops
)
}
}
}
#
[
macro_export
]
macro_rules
!
size_of_is_0
(
(
(
ty
:
ty
)
+
)
=
>
(
(
impl
crate
:
:
MallocSizeOf
for
ty
{
#
[
inline
(
always
)
]
fn
size_of
(
&
self
_
:
&
mut
crate
:
:
MallocSizeOfOps
)
-
>
usize
{
0
}
}
)
+
)
;
(
(
ty
:
ident
<
(
gen
:
ident
)
+
>
)
+
)
=
>
(
(
impl
<
(
gen
:
crate
:
:
MallocSizeOf
)
+
>
crate
:
:
MallocSizeOf
for
ty
<
(
gen
)
+
>
{
#
[
inline
(
always
)
]
fn
size_of
(
&
self
_
:
&
mut
crate
:
:
MallocSizeOfOps
)
-
>
usize
{
0
}
}
)
+
)
;
)
;
size_of_is_0
!
(
char
str
)
;
size_of_is_0
!
(
u8
u16
u32
u64
usize
)
;
size_of_is_0
!
(
i8
i16
i32
i64
isize
)
;
size_of_is_0
!
(
bool
f32
f64
)
;
size_of_is_0
!
(
SmallBitVec
)
;
