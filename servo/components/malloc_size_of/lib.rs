extern
crate
app_units
;
extern
crate
cssparser
;
extern
crate
euclid
;
extern
crate
hashglobe
;
extern
crate
servo_arc
;
extern
crate
smallbitvec
;
extern
crate
smallvec
;
use
std
:
:
hash
:
:
{
BuildHasher
Hash
}
;
use
std
:
:
ops
:
:
Range
;
use
std
:
:
os
:
:
raw
:
:
c_void
;
type
VoidPtrToSizeFn
=
unsafe
extern
"
C
"
fn
(
ptr
:
*
const
c_void
)
-
>
usize
;
type
VoidPtrToBoolFnMut
=
FnMut
(
*
const
c_void
)
-
>
bool
;
pub
struct
MallocSizeOfOps
{
size_of_op
:
VoidPtrToSizeFn
enclosing_size_of_op
:
VoidPtrToSizeFn
have_seen_ptr_op
:
Option
<
Box
<
VoidPtrToBoolFnMut
>
>
}
impl
MallocSizeOfOps
{
pub
fn
new
(
size_of
:
VoidPtrToSizeFn
malloc_enclosing_size_of
:
VoidPtrToSizeFn
have_seen_ptr
:
Option
<
Box
<
VoidPtrToBoolFnMut
>
>
)
-
>
Self
{
MallocSizeOfOps
{
size_of_op
:
size_of
enclosing_size_of_op
:
malloc_enclosing_size_of
have_seen_ptr_op
:
have_seen_ptr
}
}
fn
is_empty
<
T
:
?
Sized
>
(
ptr
:
*
const
T
)
-
>
bool
{
return
ptr
as
*
const
usize
as
usize
<
=
256
}
pub
unsafe
fn
malloc_size_of
<
T
:
?
Sized
>
(
&
self
ptr
:
*
const
T
)
-
>
usize
{
if
MallocSizeOfOps
:
:
is_empty
(
ptr
)
{
0
}
else
{
(
self
.
size_of_op
)
(
ptr
as
*
const
c_void
)
}
}
pub
unsafe
fn
malloc_enclosing_size_of
<
T
>
(
&
self
ptr
:
*
const
T
)
-
>
usize
{
assert
!
(
!
MallocSizeOfOps
:
:
is_empty
(
ptr
)
)
;
(
self
.
enclosing_size_of_op
)
(
ptr
as
*
const
c_void
)
}
pub
fn
have_seen_ptr
<
T
>
(
&
mut
self
ptr
:
*
const
T
)
-
>
bool
{
let
have_seen_ptr_op
=
self
.
have_seen_ptr_op
.
as_mut
(
)
.
expect
(
"
missing
have_seen_ptr_op
"
)
;
have_seen_ptr_op
(
ptr
as
*
const
c_void
)
}
}
pub
trait
MallocSizeOf
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
;
}
pub
trait
MallocShallowSizeOf
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
;
}
pub
trait
MallocUnconditionalSizeOf
{
fn
unconditional_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
;
}
pub
trait
MallocUnconditionalShallowSizeOf
{
fn
unconditional_shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
;
}
pub
trait
MallocConditionalSizeOf
{
fn
conditional_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
;
}
pub
trait
MallocConditionalShallowSizeOf
{
fn
conditional_shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
;
}
impl
MallocSizeOf
for
String
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
unsafe
{
ops
.
malloc_size_of
(
self
.
as_ptr
(
)
)
}
}
}
impl
<
T
:
?
Sized
>
MallocShallowSizeOf
for
Box
<
T
>
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
unsafe
{
ops
.
malloc_size_of
(
&
*
*
self
)
}
}
}
impl
<
T
:
MallocSizeOf
+
?
Sized
>
MallocSizeOf
for
Box
<
T
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
shallow_size_of
(
ops
)
+
(
*
*
self
)
.
size_of
(
ops
)
}
}
impl
<
A
:
MallocSizeOf
B
:
MallocSizeOf
>
MallocSizeOf
for
(
A
B
)
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
0
.
size_of
(
ops
)
+
self
.
1
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
>
MallocSizeOf
for
Option
<
T
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
if
let
Some
(
val
)
=
self
.
as_ref
(
)
{
val
.
size_of
(
ops
)
}
else
{
0
}
}
}
impl
<
T
:
MallocSizeOf
>
MallocSizeOf
for
[
T
]
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
0
;
for
elem
in
self
.
iter
(
)
{
n
+
=
elem
.
size_of
(
ops
)
;
}
n
}
}
impl
<
T
>
MallocShallowSizeOf
for
Vec
<
T
>
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
unsafe
{
ops
.
malloc_size_of
(
self
.
as_ptr
(
)
)
}
}
}
impl
<
T
:
MallocSizeOf
>
MallocSizeOf
for
Vec
<
T
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
shallow_size_of
(
ops
)
;
for
elem
in
self
.
iter
(
)
{
n
+
=
elem
.
size_of
(
ops
)
;
}
n
}
}
impl
<
A
:
smallvec
:
:
Array
>
MallocShallowSizeOf
for
smallvec
:
:
SmallVec
<
A
>
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
if
self
.
spilled
(
)
{
unsafe
{
ops
.
malloc_size_of
(
self
.
as_ptr
(
)
)
}
}
else
{
0
}
}
}
impl
<
A
>
MallocSizeOf
for
smallvec
:
:
SmallVec
<
A
>
where
A
:
smallvec
:
:
Array
A
:
:
Item
:
MallocSizeOf
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
shallow_size_of
(
ops
)
;
for
elem
in
self
.
iter
(
)
{
n
+
=
elem
.
size_of
(
ops
)
;
}
n
}
}
impl
<
T
S
>
MallocShallowSizeOf
for
std
:
:
collections
:
:
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
iter
(
)
.
next
(
)
.
map_or
(
0
|
t
|
unsafe
{
ops
.
malloc_enclosing_size_of
(
t
)
}
)
}
}
impl
<
T
S
>
MallocSizeOf
for
std
:
:
collections
:
:
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
+
MallocSizeOf
S
:
BuildHasher
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
shallow_size_of
(
ops
)
;
for
t
in
self
.
iter
(
)
{
n
+
=
t
.
size_of
(
ops
)
;
}
n
}
}
impl
<
T
S
>
MallocShallowSizeOf
for
hashglobe
:
:
hash_set
:
:
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
iter
(
)
.
next
(
)
.
map_or
(
0
|
t
|
unsafe
{
ops
.
malloc_enclosing_size_of
(
t
)
}
)
}
}
impl
<
T
S
>
MallocSizeOf
for
hashglobe
:
:
hash_set
:
:
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
+
MallocSizeOf
S
:
BuildHasher
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
shallow_size_of
(
ops
)
;
for
t
in
self
.
iter
(
)
{
n
+
=
t
.
size_of
(
ops
)
;
}
n
}
}
impl
<
K
V
S
>
MallocShallowSizeOf
for
hashglobe
:
:
hash_map
:
:
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
S
:
BuildHasher
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
values
(
)
.
next
(
)
.
map_or
(
0
|
v
|
unsafe
{
ops
.
malloc_enclosing_size_of
(
v
)
}
)
}
}
impl
<
K
V
S
>
MallocSizeOf
for
hashglobe
:
:
hash_map
:
:
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
+
MallocSizeOf
V
:
MallocSizeOf
S
:
BuildHasher
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
shallow_size_of
(
ops
)
;
for
(
k
v
)
in
self
.
iter
(
)
{
n
+
=
k
.
size_of
(
ops
)
;
n
+
=
v
.
size_of
(
ops
)
;
}
n
}
}
impl
<
T
>
MallocUnconditionalShallowSizeOf
for
servo_arc
:
:
Arc
<
T
>
{
fn
unconditional_shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
unsafe
{
ops
.
malloc_size_of
(
self
.
heap_ptr
(
)
)
}
}
}
impl
<
T
:
MallocSizeOf
>
MallocUnconditionalSizeOf
for
servo_arc
:
:
Arc
<
T
>
{
fn
unconditional_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
unconditional_shallow_size_of
(
ops
)
+
(
*
*
self
)
.
size_of
(
ops
)
}
}
impl
<
T
>
MallocConditionalShallowSizeOf
for
servo_arc
:
:
Arc
<
T
>
{
fn
conditional_shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
if
ops
.
have_seen_ptr
(
self
.
heap_ptr
(
)
)
{
0
}
else
{
self
.
unconditional_shallow_size_of
(
ops
)
}
}
}
impl
<
T
:
MallocSizeOf
>
MallocConditionalSizeOf
for
servo_arc
:
:
Arc
<
T
>
{
fn
conditional_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
if
ops
.
have_seen_ptr
(
self
.
heap_ptr
(
)
)
{
0
}
else
{
self
.
unconditional_size_of
(
ops
)
}
}
}
impl
MallocSizeOf
for
smallbitvec
:
:
SmallBitVec
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
if
let
Some
(
ptr
)
=
self
.
heap_ptr
(
)
{
unsafe
{
ops
.
malloc_size_of
(
ptr
)
}
}
else
{
0
}
}
}
impl
<
T
:
MallocSizeOf
U
>
MallocSizeOf
for
euclid
:
:
TypedSize2D
<
T
U
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
width
.
size_of
(
ops
)
+
self
.
height
.
size_of
(
ops
)
}
}
#
[
macro_export
]
macro_rules
!
size_of_is_0
(
(
(
ty
:
ty
)
+
)
=
>
(
(
impl
crate
:
:
MallocSizeOf
for
ty
{
#
[
inline
(
always
)
]
fn
size_of
(
&
self
_
:
&
mut
crate
:
:
MallocSizeOfOps
)
-
>
usize
{
0
}
}
)
+
)
;
(
(
ty
:
ident
<
(
gen
:
ident
)
+
>
)
+
)
=
>
(
(
impl
<
(
gen
:
crate
:
:
MallocSizeOf
)
+
>
crate
:
:
MallocSizeOf
for
ty
<
(
gen
)
+
>
{
#
[
inline
(
always
)
]
fn
size_of
(
&
self
_
:
&
mut
crate
:
:
MallocSizeOfOps
)
-
>
usize
{
0
}
}
)
+
)
;
)
;
size_of_is_0
!
(
bool
char
str
)
;
size_of_is_0
!
(
u8
u16
u32
u64
usize
)
;
size_of_is_0
!
(
i8
i16
i32
i64
isize
)
;
size_of_is_0
!
(
f32
f64
)
;
size_of_is_0
!
(
Range
<
u8
>
Range
<
u16
>
Range
<
u32
>
Range
<
u64
>
Range
<
usize
>
)
;
size_of_is_0
!
(
Range
<
i8
>
Range
<
i16
>
Range
<
i32
>
Range
<
i64
>
Range
<
isize
>
)
;
size_of_is_0
!
(
Range
<
f32
>
Range
<
f64
>
)
;
size_of_is_0
!
(
app_units
:
:
Au
)
;
size_of_is_0
!
(
cssparser
:
:
RGBA
cssparser
:
:
TokenSerializationType
)
;
