use
self
:
:
Entry
:
:
*
;
use
self
:
:
VacantEntryState
:
:
*
;
use
std
:
:
borrow
:
:
Borrow
;
use
std
:
:
cmp
:
:
max
;
use
std
:
:
fmt
:
:
{
self
Debug
}
;
#
[
allow
(
deprecated
)
]
use
std
:
:
hash
:
:
{
BuildHasher
Hash
}
;
use
std
:
:
iter
:
:
FromIterator
;
use
std
:
:
mem
:
:
{
self
replace
}
;
use
std
:
:
ops
:
:
{
Deref
Index
}
;
use
super
:
:
table
:
:
BucketState
:
:
{
Empty
Full
}
;
use
super
:
:
table
:
:
{
self
Bucket
EmptyBucket
FullBucket
FullBucketMut
RawTable
SafeHash
}
;
use
crate
:
:
FailedAllocationError
;
const
MIN_NONZERO_RAW_CAPACITY
:
usize
=
32
;
#
[
derive
(
Clone
)
]
struct
DefaultResizePolicy
;
impl
DefaultResizePolicy
{
fn
new
(
)
-
>
DefaultResizePolicy
{
DefaultResizePolicy
}
#
[
inline
]
fn
raw_capacity
(
&
self
len
:
usize
)
-
>
usize
{
if
len
=
=
0
{
0
}
else
{
let
mut
raw_cap
=
len
*
11
/
10
;
assert
!
(
raw_cap
>
=
len
"
raw_cap
overflow
"
)
;
raw_cap
=
raw_cap
.
checked_next_power_of_two
(
)
.
expect
(
"
raw_capacity
overflow
"
)
;
raw_cap
=
max
(
MIN_NONZERO_RAW_CAPACITY
raw_cap
)
;
raw_cap
}
}
#
[
inline
]
fn
capacity
(
&
self
raw_cap
:
usize
)
-
>
usize
{
(
raw_cap
*
10
+
10
-
1
)
/
11
}
}
const
DISPLACEMENT_THRESHOLD
:
usize
=
128
;
#
[
derive
(
Clone
)
]
pub
struct
HashMap
<
K
V
S
=
RandomState
>
{
hash_builder
:
S
table
:
RawTable
<
K
V
>
resize_policy
:
DefaultResizePolicy
}
#
[
inline
]
fn
search_hashed
<
K
V
M
F
>
(
table
:
M
hash
:
SafeHash
mut
is_match
:
F
)
-
>
InternalEntry
<
K
V
M
>
where
M
:
Deref
<
Target
=
RawTable
<
K
V
>
>
F
:
FnMut
(
&
K
)
-
>
bool
{
if
table
.
capacity
(
)
=
=
0
{
return
InternalEntry
:
:
TableIsEmpty
;
}
let
size
=
table
.
size
(
)
;
let
mut
probe
=
Bucket
:
:
new
(
table
hash
)
;
let
mut
displacement
=
0
;
loop
{
let
full
=
match
probe
.
peek
(
)
{
Empty
(
bucket
)
=
>
{
return
InternalEntry
:
:
Vacant
{
hash
elem
:
NoElem
(
bucket
displacement
)
}
;
}
Full
(
bucket
)
=
>
bucket
}
;
let
probe_displacement
=
full
.
displacement
(
)
;
if
probe_displacement
<
displacement
{
return
InternalEntry
:
:
Vacant
{
hash
elem
:
NeqElem
(
full
probe_displacement
)
}
;
}
if
hash
=
=
full
.
hash
(
)
{
if
is_match
(
full
.
read
(
)
.
0
)
{
return
InternalEntry
:
:
Occupied
{
elem
:
full
}
;
}
}
displacement
+
=
1
;
probe
=
full
.
next
(
)
;
debug_assert
!
(
displacement
<
=
size
)
;
}
}
fn
pop_internal
<
K
V
>
(
starting_bucket
:
FullBucketMut
<
K
V
>
)
-
>
(
K
V
&
mut
RawTable
<
K
V
>
)
{
let
(
empty
retkey
retval
)
=
starting_bucket
.
take
(
)
;
let
mut
gap
=
match
empty
.
gap_peek
(
)
{
Ok
(
b
)
=
>
b
Err
(
b
)
=
>
return
(
retkey
retval
b
.
into_table
(
)
)
}
;
while
gap
.
full
(
)
.
displacement
(
)
!
=
0
{
gap
=
match
gap
.
shift
(
)
{
Ok
(
b
)
=
>
b
Err
(
b
)
=
>
{
return
(
retkey
retval
b
.
into_table
(
)
)
;
}
}
;
}
(
retkey
retval
gap
.
into_table
(
)
)
}
fn
robin_hood
<
'
a
K
:
'
a
V
:
'
a
>
(
bucket
:
FullBucketMut
<
'
a
K
V
>
mut
displacement
:
usize
mut
hash
:
SafeHash
mut
key
:
K
mut
val
:
V
)
-
>
FullBucketMut
<
'
a
K
V
>
{
let
size
=
bucket
.
table
(
)
.
size
(
)
;
let
raw_capacity
=
bucket
.
table
(
)
.
capacity
(
)
;
let
idx_end
=
(
bucket
.
index
(
)
+
size
-
bucket
.
displacement
(
)
)
%
raw_capacity
;
let
mut
bucket
=
bucket
.
stash
(
)
;
loop
{
let
(
old_hash
old_key
old_val
)
=
bucket
.
replace
(
hash
key
val
)
;
hash
=
old_hash
;
key
=
old_key
;
val
=
old_val
;
loop
{
displacement
+
=
1
;
let
probe
=
bucket
.
next
(
)
;
debug_assert_ne
!
(
probe
.
index
(
)
idx_end
)
;
let
full_bucket
=
match
probe
.
peek
(
)
{
Empty
(
bucket
)
=
>
{
let
bucket
=
bucket
.
put
(
hash
key
val
)
;
return
bucket
.
into_table
(
)
;
}
Full
(
bucket
)
=
>
bucket
}
;
let
probe_displacement
=
full_bucket
.
displacement
(
)
;
bucket
=
full_bucket
;
if
probe_displacement
<
displacement
{
displacement
=
probe_displacement
;
break
;
}
}
}
}
impl
<
K
V
S
>
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
S
:
BuildHasher
{
fn
make_hash
<
X
:
?
Sized
>
(
&
self
x
:
&
X
)
-
>
SafeHash
where
X
:
Hash
{
table
:
:
make_hash
(
&
self
.
hash_builder
x
)
}
#
[
inline
]
fn
search
<
'
a
Q
:
?
Sized
>
(
&
'
a
self
q
:
&
Q
)
-
>
InternalEntry
<
K
V
&
'
a
RawTable
<
K
V
>
>
where
K
:
Borrow
<
Q
>
Q
:
Eq
+
Hash
{
let
hash
=
self
.
make_hash
(
q
)
;
search_hashed
(
&
self
.
table
hash
|
k
|
q
.
eq
(
k
.
borrow
(
)
)
)
}
#
[
inline
]
fn
search_mut
<
'
a
Q
:
?
Sized
>
(
&
'
a
mut
self
q
:
&
Q
)
-
>
InternalEntry
<
K
V
&
'
a
mut
RawTable
<
K
V
>
>
where
K
:
Borrow
<
Q
>
Q
:
Eq
+
Hash
{
let
hash
=
self
.
make_hash
(
q
)
;
search_hashed
(
&
mut
self
.
table
hash
|
k
|
q
.
eq
(
k
.
borrow
(
)
)
)
}
fn
insert_hashed_ordered
(
&
mut
self
hash
:
SafeHash
k
:
K
v
:
V
)
{
let
mut
buckets
=
Bucket
:
:
new
(
&
mut
self
.
table
hash
)
;
let
start_index
=
buckets
.
index
(
)
;
loop
{
buckets
=
match
buckets
.
peek
(
)
{
Empty
(
empty
)
=
>
{
empty
.
put
(
hash
k
v
)
;
return
;
}
Full
(
b
)
=
>
b
.
into_bucket
(
)
}
;
buckets
.
next
(
)
;
debug_assert_ne
!
(
buckets
.
index
(
)
start_index
)
;
}
}
}
impl
<
K
V
S
>
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
S
:
BuildHasher
{
#
[
inline
]
pub
fn
try_with_hasher
(
hash_builder
:
S
)
-
>
Result
<
HashMap
<
K
V
S
>
FailedAllocationError
>
{
Ok
(
HashMap
{
hash_builder
resize_policy
:
DefaultResizePolicy
:
:
new
(
)
table
:
RawTable
:
:
new
(
0
)
?
}
)
}
#
[
inline
]
pub
fn
with_hasher
(
hash_builder
:
S
)
-
>
HashMap
<
K
V
S
>
{
Self
:
:
try_with_hasher
(
hash_builder
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
try_with_capacity_and_hasher
(
capacity
:
usize
hash_builder
:
S
)
-
>
Result
<
HashMap
<
K
V
S
>
FailedAllocationError
>
{
let
resize_policy
=
DefaultResizePolicy
:
:
new
(
)
;
let
raw_cap
=
resize_policy
.
raw_capacity
(
capacity
)
;
Ok
(
HashMap
{
hash_builder
resize_policy
table
:
RawTable
:
:
new
(
raw_cap
)
?
}
)
}
pub
fn
with_capacity_and_hasher
(
capacity
:
usize
hash_builder
:
S
)
-
>
HashMap
<
K
V
S
>
{
Self
:
:
try_with_capacity_and_hasher
(
capacity
hash_builder
)
.
unwrap
(
)
}
pub
fn
hasher
(
&
self
)
-
>
&
S
{
&
self
.
hash_builder
}
#
[
inline
]
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
resize_policy
.
capacity
(
self
.
raw_capacity
(
)
)
}
#
[
inline
]
fn
raw_capacity
(
&
self
)
-
>
usize
{
self
.
table
.
capacity
(
)
}
pub
fn
reserve
(
&
mut
self
additional
:
usize
)
{
self
.
try_reserve
(
additional
)
.
unwrap
(
)
;
}
#
[
inline
]
pub
fn
try_reserve
(
&
mut
self
additional
:
usize
)
-
>
Result
<
(
)
FailedAllocationError
>
{
let
remaining
=
self
.
capacity
(
)
-
self
.
len
(
)
;
if
remaining
<
additional
{
let
min_cap
=
self
.
len
(
)
.
checked_add
(
additional
)
.
expect
(
"
reserve
overflow
"
)
;
let
raw_cap
=
self
.
resize_policy
.
raw_capacity
(
min_cap
)
;
self
.
try_resize
(
raw_cap
)
?
;
}
else
if
self
.
table
.
tag
(
)
&
&
remaining
<
=
self
.
len
(
)
{
let
new_capacity
=
self
.
table
.
capacity
(
)
*
2
;
self
.
try_resize
(
new_capacity
)
?
;
}
Ok
(
(
)
)
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
try_resize
(
&
mut
self
new_raw_cap
:
usize
)
-
>
Result
<
(
)
FailedAllocationError
>
{
assert
!
(
self
.
table
.
size
(
)
<
=
new_raw_cap
)
;
assert
!
(
new_raw_cap
.
is_power_of_two
(
)
|
|
new_raw_cap
=
=
0
)
;
let
mut
old_table
=
replace
(
&
mut
self
.
table
RawTable
:
:
new
(
new_raw_cap
)
?
)
;
let
old_size
=
old_table
.
size
(
)
;
if
old_table
.
size
(
)
=
=
0
{
return
Ok
(
(
)
)
;
}
let
mut
bucket
=
Bucket
:
:
head_bucket
(
&
mut
old_table
)
;
loop
{
bucket
=
match
bucket
.
peek
(
)
{
Full
(
bucket
)
=
>
{
let
h
=
bucket
.
hash
(
)
;
let
(
b
k
v
)
=
bucket
.
take
(
)
;
self
.
insert_hashed_ordered
(
h
k
v
)
;
if
b
.
table
(
)
.
size
(
)
=
=
0
{
break
;
}
b
.
into_bucket
(
)
}
Empty
(
b
)
=
>
b
.
into_bucket
(
)
}
;
bucket
.
next
(
)
;
}
assert_eq
!
(
self
.
table
.
size
(
)
old_size
)
;
Ok
(
(
)
)
}
pub
fn
shrink_to_fit
(
&
mut
self
)
{
self
.
try_shrink_to_fit
(
)
.
unwrap
(
)
;
}
pub
fn
try_shrink_to_fit
(
&
mut
self
)
-
>
Result
<
(
)
FailedAllocationError
>
{
let
new_raw_cap
=
self
.
resize_policy
.
raw_capacity
(
self
.
len
(
)
)
;
if
self
.
raw_capacity
(
)
!
=
new_raw_cap
{
let
old_table
=
replace
(
&
mut
self
.
table
RawTable
:
:
new
(
new_raw_cap
)
?
)
;
let
old_size
=
old_table
.
size
(
)
;
for
(
h
k
v
)
in
old_table
.
into_iter
(
)
{
self
.
insert_hashed_nocheck
(
h
k
v
)
;
}
debug_assert_eq
!
(
self
.
table
.
size
(
)
old_size
)
;
}
Ok
(
(
)
)
}
fn
insert_hashed_nocheck
(
&
mut
self
hash
:
SafeHash
k
:
K
v
:
V
)
-
>
Option
<
V
>
{
let
entry
=
search_hashed
(
&
mut
self
.
table
hash
|
key
|
*
key
=
=
k
)
.
into_entry
(
k
)
;
match
entry
{
Some
(
Occupied
(
mut
elem
)
)
=
>
Some
(
elem
.
insert
(
v
)
)
Some
(
Vacant
(
elem
)
)
=
>
{
elem
.
insert
(
v
)
;
None
}
None
=
>
unreachable
!
(
)
}
}
pub
fn
keys
(
&
self
)
-
>
Keys
<
K
V
>
{
Keys
{
inner
:
self
.
iter
(
)
}
}
pub
fn
values
(
&
self
)
-
>
Values
<
K
V
>
{
Values
{
inner
:
self
.
iter
(
)
}
}
pub
fn
values_mut
(
&
mut
self
)
-
>
ValuesMut
<
K
V
>
{
ValuesMut
{
inner
:
self
.
iter_mut
(
)
}
}
pub
fn
iter
(
&
self
)
-
>
Iter
<
K
V
>
{
Iter
{
inner
:
self
.
table
.
iter
(
)
}
}
pub
fn
iter_mut
(
&
mut
self
)
-
>
IterMut
<
K
V
>
{
IterMut
{
inner
:
self
.
table
.
iter_mut
(
)
}
}
pub
fn
entry
(
&
mut
self
key
:
K
)
-
>
Entry
<
K
V
>
{
self
.
try_entry
(
key
)
.
unwrap
(
)
}
#
[
inline
(
always
)
]
pub
fn
try_entry
(
&
mut
self
key
:
K
)
-
>
Result
<
Entry
<
K
V
>
FailedAllocationError
>
{
self
.
try_reserve
(
1
)
?
;
let
hash
=
self
.
make_hash
(
&
key
)
;
Ok
(
search_hashed
(
&
mut
self
.
table
hash
|
q
|
q
.
eq
(
&
key
)
)
.
into_entry
(
key
)
.
expect
(
"
unreachable
"
)
)
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
table
.
size
(
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
0
}
#
[
inline
]
pub
fn
drain
(
&
mut
self
)
-
>
Drain
<
K
V
>
where
K
:
'
static
V
:
'
static
{
Drain
{
inner
:
self
.
table
.
drain
(
)
}
}
#
[
inline
]
pub
fn
clear
(
&
mut
self
)
where
K
:
'
static
V
:
'
static
{
self
.
drain
(
)
;
}
pub
fn
get
<
Q
:
?
Sized
>
(
&
self
k
:
&
Q
)
-
>
Option
<
&
V
>
where
K
:
Borrow
<
Q
>
Q
:
Hash
+
Eq
{
self
.
search
(
k
)
.
into_occupied_bucket
(
)
.
map
(
|
bucket
|
bucket
.
into_refs
(
)
.
1
)
}
pub
fn
contains_key
<
Q
:
?
Sized
>
(
&
self
k
:
&
Q
)
-
>
bool
where
K
:
Borrow
<
Q
>
Q
:
Hash
+
Eq
{
self
.
search
(
k
)
.
into_occupied_bucket
(
)
.
is_some
(
)
}
pub
fn
get_mut
<
Q
:
?
Sized
>
(
&
mut
self
k
:
&
Q
)
-
>
Option
<
&
mut
V
>
where
K
:
Borrow
<
Q
>
Q
:
Hash
+
Eq
{
self
.
search_mut
(
k
)
.
into_occupied_bucket
(
)
.
map
(
|
bucket
|
bucket
.
into_mut_refs
(
)
.
1
)
}
pub
fn
insert
(
&
mut
self
k
:
K
v
:
V
)
-
>
Option
<
V
>
{
self
.
try_insert
(
k
v
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
try_insert
(
&
mut
self
k
:
K
v
:
V
)
-
>
Result
<
Option
<
V
>
FailedAllocationError
>
{
let
hash
=
self
.
make_hash
(
&
k
)
;
self
.
try_reserve
(
1
)
?
;
Ok
(
self
.
insert_hashed_nocheck
(
hash
k
v
)
)
}
pub
fn
remove
<
Q
:
?
Sized
>
(
&
mut
self
k
:
&
Q
)
-
>
Option
<
V
>
where
K
:
Borrow
<
Q
>
Q
:
Hash
+
Eq
{
if
self
.
table
.
size
(
)
=
=
0
{
return
None
;
}
self
.
search_mut
(
k
)
.
into_occupied_bucket
(
)
.
map
(
|
bucket
|
pop_internal
(
bucket
)
.
1
)
}
pub
fn
retain
<
F
>
(
&
mut
self
mut
f
:
F
)
where
F
:
FnMut
(
&
K
&
mut
V
)
-
>
bool
{
if
self
.
table
.
size
(
)
=
=
0
{
return
;
}
let
mut
elems_left
=
self
.
table
.
size
(
)
;
let
mut
bucket
=
Bucket
:
:
head_bucket
(
&
mut
self
.
table
)
;
bucket
.
prev
(
)
;
let
start_index
=
bucket
.
index
(
)
;
while
elems_left
!
=
0
{
bucket
=
match
bucket
.
peek
(
)
{
Full
(
mut
full
)
=
>
{
elems_left
-
=
1
;
let
should_remove
=
{
let
(
k
v
)
=
full
.
read_mut
(
)
;
!
f
(
k
v
)
}
;
if
should_remove
{
let
prev_raw
=
full
.
raw
(
)
;
let
(
_
_
t
)
=
pop_internal
(
full
)
;
Bucket
:
:
new_from
(
prev_raw
t
)
}
else
{
full
.
into_bucket
(
)
}
}
Empty
(
b
)
=
>
b
.
into_bucket
(
)
}
;
bucket
.
prev
(
)
;
debug_assert
!
(
elems_left
=
=
0
|
|
bucket
.
index
(
)
!
=
start_index
)
;
}
}
}
impl
<
K
V
S
>
PartialEq
for
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
V
:
PartialEq
S
:
BuildHasher
{
fn
eq
(
&
self
other
:
&
HashMap
<
K
V
S
>
)
-
>
bool
{
if
self
.
len
(
)
!
=
other
.
len
(
)
{
return
false
;
}
self
.
iter
(
)
.
all
(
|
(
key
value
)
|
other
.
get
(
key
)
.
map_or
(
false
|
v
|
*
value
=
=
*
v
)
)
}
}
impl
<
K
V
S
>
Eq
for
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
V
:
Eq
S
:
BuildHasher
{
}
impl
<
K
V
S
>
Debug
for
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
+
Debug
V
:
Debug
S
:
BuildHasher
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_map
(
)
.
entries
(
self
.
iter
(
)
)
.
finish
(
)
}
}
impl
<
K
V
S
>
Default
for
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
S
:
BuildHasher
+
Default
{
fn
default
(
)
-
>
HashMap
<
K
V
S
>
{
HashMap
:
:
with_hasher
(
Default
:
:
default
(
)
)
}
}
impl
<
'
a
K
Q
:
?
Sized
V
S
>
Index
<
&
'
a
Q
>
for
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
+
Borrow
<
Q
>
Q
:
Eq
+
Hash
S
:
BuildHasher
{
type
Output
=
V
;
#
[
inline
]
fn
index
(
&
self
index
:
&
Q
)
-
>
&
V
{
self
.
get
(
index
)
.
expect
(
"
no
entry
found
for
key
"
)
}
}
pub
struct
Iter
<
'
a
K
:
'
a
V
:
'
a
>
{
inner
:
table
:
:
Iter
<
'
a
K
V
>
}
impl
<
'
a
K
V
>
Clone
for
Iter
<
'
a
K
V
>
{
fn
clone
(
&
self
)
-
>
Iter
<
'
a
K
V
>
{
Iter
{
inner
:
self
.
inner
.
clone
(
)
}
}
}
impl
<
'
a
K
:
Debug
V
:
Debug
>
fmt
:
:
Debug
for
Iter
<
'
a
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
pub
struct
IterMut
<
'
a
K
:
'
a
V
:
'
a
>
{
inner
:
table
:
:
IterMut
<
'
a
K
V
>
}
pub
struct
IntoIter
<
K
V
>
{
pub
(
super
)
inner
:
table
:
:
IntoIter
<
K
V
>
}
pub
struct
Keys
<
'
a
K
:
'
a
V
:
'
a
>
{
inner
:
Iter
<
'
a
K
V
>
}
impl
<
'
a
K
V
>
Clone
for
Keys
<
'
a
K
V
>
{
fn
clone
(
&
self
)
-
>
Keys
<
'
a
K
V
>
{
Keys
{
inner
:
self
.
inner
.
clone
(
)
}
}
}
impl
<
'
a
K
:
Debug
V
>
fmt
:
:
Debug
for
Keys
<
'
a
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
pub
struct
Values
<
'
a
K
:
'
a
V
:
'
a
>
{
inner
:
Iter
<
'
a
K
V
>
}
impl
<
'
a
K
V
>
Clone
for
Values
<
'
a
K
V
>
{
fn
clone
(
&
self
)
-
>
Values
<
'
a
K
V
>
{
Values
{
inner
:
self
.
inner
.
clone
(
)
}
}
}
impl
<
'
a
K
V
:
Debug
>
fmt
:
:
Debug
for
Values
<
'
a
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
pub
struct
Drain
<
'
a
K
:
'
static
V
:
'
static
>
{
pub
(
super
)
inner
:
table
:
:
Drain
<
'
a
K
V
>
}
pub
struct
ValuesMut
<
'
a
K
:
'
a
V
:
'
a
>
{
inner
:
IterMut
<
'
a
K
V
>
}
enum
InternalEntry
<
K
V
M
>
{
Occupied
{
elem
:
FullBucket
<
K
V
M
>
}
Vacant
{
hash
:
SafeHash
elem
:
VacantEntryState
<
K
V
M
>
}
TableIsEmpty
}
impl
<
K
V
M
>
InternalEntry
<
K
V
M
>
{
#
[
inline
]
fn
into_occupied_bucket
(
self
)
-
>
Option
<
FullBucket
<
K
V
M
>
>
{
match
self
{
InternalEntry
:
:
Occupied
{
elem
}
=
>
Some
(
elem
)
_
=
>
None
}
}
}
impl
<
'
a
K
V
>
InternalEntry
<
K
V
&
'
a
mut
RawTable
<
K
V
>
>
{
#
[
inline
]
fn
into_entry
(
self
key
:
K
)
-
>
Option
<
Entry
<
'
a
K
V
>
>
{
match
self
{
InternalEntry
:
:
Occupied
{
elem
}
=
>
Some
(
Occupied
(
OccupiedEntry
{
key
:
Some
(
key
)
elem
}
)
)
InternalEntry
:
:
Vacant
{
hash
elem
}
=
>
Some
(
Vacant
(
VacantEntry
{
hash
key
elem
}
)
)
InternalEntry
:
:
TableIsEmpty
=
>
None
}
}
}
pub
enum
Entry
<
'
a
K
:
'
a
V
:
'
a
>
{
Occupied
(
OccupiedEntry
<
'
a
K
V
>
)
Vacant
(
VacantEntry
<
'
a
K
V
>
)
}
impl
<
'
a
K
:
'
a
+
Debug
V
:
'
a
+
Debug
>
Debug
for
Entry
<
'
a
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
Vacant
(
ref
v
)
=
>
f
.
debug_tuple
(
"
Entry
"
)
.
field
(
v
)
.
finish
(
)
Occupied
(
ref
o
)
=
>
f
.
debug_tuple
(
"
Entry
"
)
.
field
(
o
)
.
finish
(
)
}
}
}
pub
struct
OccupiedEntry
<
'
a
K
:
'
a
V
:
'
a
>
{
key
:
Option
<
K
>
elem
:
FullBucket
<
K
V
&
'
a
mut
RawTable
<
K
V
>
>
}
impl
<
'
a
K
:
'
a
+
Debug
V
:
'
a
+
Debug
>
Debug
for
OccupiedEntry
<
'
a
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
OccupiedEntry
"
)
.
field
(
"
key
"
self
.
key
(
)
)
.
field
(
"
value
"
self
.
get
(
)
)
.
finish
(
)
}
}
pub
struct
VacantEntry
<
'
a
K
:
'
a
V
:
'
a
>
{
hash
:
SafeHash
key
:
K
elem
:
VacantEntryState
<
K
V
&
'
a
mut
RawTable
<
K
V
>
>
}
impl
<
'
a
K
:
'
a
+
Debug
V
:
'
a
>
Debug
for
VacantEntry
<
'
a
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
VacantEntry
"
)
.
field
(
self
.
key
(
)
)
.
finish
(
)
}
}
enum
VacantEntryState
<
K
V
M
>
{
NeqElem
(
FullBucket
<
K
V
M
>
usize
)
NoElem
(
EmptyBucket
<
K
V
M
>
usize
)
}
impl
<
'
a
K
V
S
>
IntoIterator
for
&
'
a
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
S
:
BuildHasher
{
type
Item
=
(
&
'
a
K
&
'
a
V
)
;
type
IntoIter
=
Iter
<
'
a
K
V
>
;
fn
into_iter
(
self
)
-
>
Iter
<
'
a
K
V
>
{
self
.
iter
(
)
}
}
impl
<
'
a
K
V
S
>
IntoIterator
for
&
'
a
mut
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
S
:
BuildHasher
{
type
Item
=
(
&
'
a
K
&
'
a
mut
V
)
;
type
IntoIter
=
IterMut
<
'
a
K
V
>
;
fn
into_iter
(
self
)
-
>
IterMut
<
'
a
K
V
>
{
self
.
iter_mut
(
)
}
}
impl
<
K
V
S
>
IntoIterator
for
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
S
:
BuildHasher
{
type
Item
=
(
K
V
)
;
type
IntoIter
=
IntoIter
<
K
V
>
;
fn
into_iter
(
self
)
-
>
IntoIter
<
K
V
>
{
IntoIter
{
inner
:
self
.
table
.
into_iter
(
)
}
}
}
impl
<
'
a
K
V
>
Iterator
for
Iter
<
'
a
K
V
>
{
type
Item
=
(
&
'
a
K
&
'
a
V
)
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
(
&
'
a
K
&
'
a
V
)
>
{
self
.
inner
.
next
(
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
inner
.
size_hint
(
)
}
}
impl
<
'
a
K
V
>
ExactSizeIterator
for
Iter
<
'
a
K
V
>
{
#
[
inline
]
fn
len
(
&
self
)
-
>
usize
{
self
.
inner
.
len
(
)
}
}
impl
<
'
a
K
V
>
Iterator
for
IterMut
<
'
a
K
V
>
{
type
Item
=
(
&
'
a
K
&
'
a
mut
V
)
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
(
&
'
a
K
&
'
a
mut
V
)
>
{
self
.
inner
.
next
(
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
inner
.
size_hint
(
)
}
}
impl
<
'
a
K
V
>
ExactSizeIterator
for
IterMut
<
'
a
K
V
>
{
#
[
inline
]
fn
len
(
&
self
)
-
>
usize
{
self
.
inner
.
len
(
)
}
}
impl
<
'
a
K
V
>
fmt
:
:
Debug
for
IterMut
<
'
a
K
V
>
where
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
inner
.
iter
(
)
)
.
finish
(
)
}
}
impl
<
K
V
>
Iterator
for
IntoIter
<
K
V
>
{
type
Item
=
(
K
V
)
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
(
K
V
)
>
{
self
.
inner
.
next
(
)
.
map
(
|
(
_
k
v
)
|
(
k
v
)
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
inner
.
size_hint
(
)
}
}
impl
<
K
V
>
ExactSizeIterator
for
IntoIter
<
K
V
>
{
#
[
inline
]
fn
len
(
&
self
)
-
>
usize
{
self
.
inner
.
len
(
)
}
}
impl
<
K
:
Debug
V
:
Debug
>
fmt
:
:
Debug
for
IntoIter
<
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
inner
.
iter
(
)
)
.
finish
(
)
}
}
impl
<
'
a
K
V
>
Iterator
for
Keys
<
'
a
K
V
>
{
type
Item
=
&
'
a
K
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
K
>
{
self
.
inner
.
next
(
)
.
map
(
|
(
k
_
)
|
k
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
inner
.
size_hint
(
)
}
}
impl
<
'
a
K
V
>
ExactSizeIterator
for
Keys
<
'
a
K
V
>
{
#
[
inline
]
fn
len
(
&
self
)
-
>
usize
{
self
.
inner
.
len
(
)
}
}
impl
<
'
a
K
V
>
Iterator
for
Values
<
'
a
K
V
>
{
type
Item
=
&
'
a
V
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
V
>
{
self
.
inner
.
next
(
)
.
map
(
|
(
_
v
)
|
v
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
inner
.
size_hint
(
)
}
}
impl
<
'
a
K
V
>
ExactSizeIterator
for
Values
<
'
a
K
V
>
{
#
[
inline
]
fn
len
(
&
self
)
-
>
usize
{
self
.
inner
.
len
(
)
}
}
impl
<
'
a
K
V
>
Iterator
for
ValuesMut
<
'
a
K
V
>
{
type
Item
=
&
'
a
mut
V
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
mut
V
>
{
self
.
inner
.
next
(
)
.
map
(
|
(
_
v
)
|
v
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
inner
.
size_hint
(
)
}
}
impl
<
'
a
K
V
>
ExactSizeIterator
for
ValuesMut
<
'
a
K
V
>
{
#
[
inline
]
fn
len
(
&
self
)
-
>
usize
{
self
.
inner
.
len
(
)
}
}
impl
<
'
a
K
V
>
fmt
:
:
Debug
for
ValuesMut
<
'
a
K
V
>
where
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
inner
.
inner
.
iter
(
)
)
.
finish
(
)
}
}
impl
<
'
a
K
V
>
Iterator
for
Drain
<
'
a
K
V
>
{
type
Item
=
(
K
V
)
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
(
K
V
)
>
{
self
.
inner
.
next
(
)
.
map
(
|
(
_
k
v
)
|
(
k
v
)
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
inner
.
size_hint
(
)
}
}
impl
<
'
a
K
V
>
ExactSizeIterator
for
Drain
<
'
a
K
V
>
{
#
[
inline
]
fn
len
(
&
self
)
-
>
usize
{
self
.
inner
.
len
(
)
}
}
impl
<
'
a
K
V
>
fmt
:
:
Debug
for
Drain
<
'
a
K
V
>
where
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
inner
.
iter
(
)
)
.
finish
(
)
}
}
impl
<
'
a
K
V
>
Entry
<
'
a
K
V
>
{
pub
fn
or_insert
(
self
default
:
V
)
-
>
&
'
a
mut
V
{
match
self
{
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Vacant
(
entry
)
=
>
entry
.
insert
(
default
)
}
}
pub
fn
or_insert_with
<
F
:
FnOnce
(
)
-
>
V
>
(
self
default
:
F
)
-
>
&
'
a
mut
V
{
match
self
{
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Vacant
(
entry
)
=
>
entry
.
insert
(
default
(
)
)
}
}
pub
fn
key
(
&
self
)
-
>
&
K
{
match
*
self
{
Occupied
(
ref
entry
)
=
>
entry
.
key
(
)
Vacant
(
ref
entry
)
=
>
entry
.
key
(
)
}
}
}
impl
<
'
a
K
V
>
OccupiedEntry
<
'
a
K
V
>
{
pub
fn
key
(
&
self
)
-
>
&
K
{
self
.
elem
.
read
(
)
.
0
}
pub
fn
remove_entry
(
self
)
-
>
(
K
V
)
{
let
(
k
v
_
)
=
pop_internal
(
self
.
elem
)
;
(
k
v
)
}
pub
fn
get
(
&
self
)
-
>
&
V
{
self
.
elem
.
read
(
)
.
1
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
V
{
self
.
elem
.
read_mut
(
)
.
1
}
pub
fn
into_mut
(
self
)
-
>
&
'
a
mut
V
{
self
.
elem
.
into_mut_refs
(
)
.
1
}
pub
fn
insert
(
&
mut
self
mut
value
:
V
)
-
>
V
{
let
old_value
=
self
.
get_mut
(
)
;
mem
:
:
swap
(
&
mut
value
old_value
)
;
value
}
pub
fn
remove
(
self
)
-
>
V
{
pop_internal
(
self
.
elem
)
.
1
}
fn
take_key
(
&
mut
self
)
-
>
Option
<
K
>
{
self
.
key
.
take
(
)
}
}
impl
<
'
a
K
:
'
a
V
:
'
a
>
VacantEntry
<
'
a
K
V
>
{
pub
fn
key
(
&
self
)
-
>
&
K
{
&
self
.
key
}
pub
fn
into_key
(
self
)
-
>
K
{
self
.
key
}
pub
fn
insert
(
self
value
:
V
)
-
>
&
'
a
mut
V
{
let
b
=
match
self
.
elem
{
NeqElem
(
mut
bucket
disp
)
=
>
{
if
disp
>
=
DISPLACEMENT_THRESHOLD
{
bucket
.
table_mut
(
)
.
set_tag
(
true
)
;
}
robin_hood
(
bucket
disp
self
.
hash
self
.
key
value
)
}
NoElem
(
mut
bucket
disp
)
=
>
{
if
disp
>
=
DISPLACEMENT_THRESHOLD
{
bucket
.
table_mut
(
)
.
set_tag
(
true
)
;
}
bucket
.
put
(
self
.
hash
self
.
key
value
)
}
}
;
b
.
into_mut_refs
(
)
.
1
}
}
impl
<
K
V
S
>
FromIterator
<
(
K
V
)
>
for
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
S
:
BuildHasher
+
Default
{
fn
from_iter
<
T
:
IntoIterator
<
Item
=
(
K
V
)
>
>
(
iter
:
T
)
-
>
HashMap
<
K
V
S
>
{
let
mut
map
=
HashMap
:
:
with_hasher
(
Default
:
:
default
(
)
)
;
map
.
extend
(
iter
)
;
map
}
}
impl
<
K
V
S
>
Extend
<
(
K
V
)
>
for
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
S
:
BuildHasher
{
fn
extend
<
T
:
IntoIterator
<
Item
=
(
K
V
)
>
>
(
&
mut
self
iter
:
T
)
{
let
iter
=
iter
.
into_iter
(
)
;
let
reserve
=
if
self
.
is_empty
(
)
{
iter
.
size_hint
(
)
.
0
}
else
{
(
iter
.
size_hint
(
)
.
0
+
1
)
/
2
}
;
self
.
reserve
(
reserve
)
;
for
(
k
v
)
in
iter
{
self
.
insert
(
k
v
)
;
}
}
}
impl
<
'
a
K
V
S
>
Extend
<
(
&
'
a
K
&
'
a
V
)
>
for
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
+
Copy
V
:
Copy
S
:
BuildHasher
{
fn
extend
<
T
:
IntoIterator
<
Item
=
(
&
'
a
K
&
'
a
V
)
>
>
(
&
mut
self
iter
:
T
)
{
self
.
extend
(
iter
.
into_iter
(
)
.
map
(
|
(
&
key
&
value
)
|
(
key
value
)
)
)
;
}
}
pub
use
std
:
:
collections
:
:
hash_map
:
:
{
DefaultHasher
RandomState
}
;
impl
<
K
S
Q
:
?
Sized
>
super
:
:
Recover
<
Q
>
for
HashMap
<
K
(
)
S
>
where
K
:
Eq
+
Hash
+
Borrow
<
Q
>
S
:
BuildHasher
Q
:
Eq
+
Hash
{
type
Key
=
K
;
fn
get
(
&
self
key
:
&
Q
)
-
>
Option
<
&
K
>
{
self
.
search
(
key
)
.
into_occupied_bucket
(
)
.
map
(
|
bucket
|
bucket
.
into_refs
(
)
.
0
)
}
fn
take
(
&
mut
self
key
:
&
Q
)
-
>
Option
<
K
>
{
if
self
.
table
.
size
(
)
=
=
0
{
return
None
;
}
self
.
search_mut
(
key
)
.
into_occupied_bucket
(
)
.
map
(
|
bucket
|
pop_internal
(
bucket
)
.
0
)
}
fn
replace
(
&
mut
self
key
:
K
)
-
>
Option
<
K
>
{
self
.
reserve
(
1
)
;
match
self
.
entry
(
key
)
{
Occupied
(
mut
occupied
)
=
>
{
let
key
=
occupied
.
take_key
(
)
.
unwrap
(
)
;
Some
(
mem
:
:
replace
(
occupied
.
elem
.
read_mut
(
)
.
0
key
)
)
}
Vacant
(
vacant
)
=
>
{
vacant
.
insert
(
(
)
)
;
None
}
}
}
}
#
[
allow
(
dead_code
)
]
fn
assert_covariance
(
)
{
fn
map_key
<
'
new
>
(
v
:
HashMap
<
&
'
static
str
u8
>
)
-
>
HashMap
<
&
'
new
str
u8
>
{
v
}
fn
map_val
<
'
new
>
(
v
:
HashMap
<
u8
&
'
static
str
>
)
-
>
HashMap
<
u8
&
'
new
str
>
{
v
}
fn
iter_key
<
'
a
'
new
>
(
v
:
Iter
<
'
a
&
'
static
str
u8
>
)
-
>
Iter
<
'
a
&
'
new
str
u8
>
{
v
}
fn
iter_val
<
'
a
'
new
>
(
v
:
Iter
<
'
a
u8
&
'
static
str
>
)
-
>
Iter
<
'
a
u8
&
'
new
str
>
{
v
}
fn
into_iter_key
<
'
new
>
(
v
:
IntoIter
<
&
'
static
str
u8
>
)
-
>
IntoIter
<
&
'
new
str
u8
>
{
v
}
fn
into_iter_val
<
'
new
>
(
v
:
IntoIter
<
u8
&
'
static
str
>
)
-
>
IntoIter
<
u8
&
'
new
str
>
{
v
}
fn
keys_key
<
'
a
'
new
>
(
v
:
Keys
<
'
a
&
'
static
str
u8
>
)
-
>
Keys
<
'
a
&
'
new
str
u8
>
{
v
}
fn
keys_val
<
'
a
'
new
>
(
v
:
Keys
<
'
a
u8
&
'
static
str
>
)
-
>
Keys
<
'
a
u8
&
'
new
str
>
{
v
}
fn
values_key
<
'
a
'
new
>
(
v
:
Values
<
'
a
&
'
static
str
u8
>
)
-
>
Values
<
'
a
&
'
new
str
u8
>
{
v
}
fn
values_val
<
'
a
'
new
>
(
v
:
Values
<
'
a
u8
&
'
static
str
>
)
-
>
Values
<
'
a
u8
&
'
new
str
>
{
v
}
fn
drain
<
'
new
>
(
d
:
Drain
<
'
static
&
'
static
str
&
'
static
str
>
)
-
>
Drain
<
'
new
&
'
new
str
&
'
new
str
>
{
d
}
}
#
[
cfg
(
test
)
]
mod
test_map
{
extern
crate
rand
;
use
self
:
:
rand
:
:
{
thread_rng
Rng
}
;
use
super
:
:
Entry
:
:
{
Occupied
Vacant
}
;
use
super
:
:
HashMap
;
use
super
:
:
RandomState
;
use
cell
:
:
RefCell
;
#
[
test
]
fn
test_zero_capacities
(
)
{
type
HM
=
HashMap
<
i32
i32
>
;
let
m
=
HM
:
:
new
(
)
;
assert_eq
!
(
m
.
capacity
(
)
0
)
;
let
m
=
HM
:
:
default
(
)
;
assert_eq
!
(
m
.
capacity
(
)
0
)
;
let
m
=
HM
:
:
with_hasher
(
RandomState
:
:
new
(
)
)
;
assert_eq
!
(
m
.
capacity
(
)
0
)
;
let
m
=
HM
:
:
with_capacity
(
0
)
;
assert_eq
!
(
m
.
capacity
(
)
0
)
;
let
m
=
HM
:
:
with_capacity_and_hasher
(
0
RandomState
:
:
new
(
)
)
;
assert_eq
!
(
m
.
capacity
(
)
0
)
;
let
mut
m
=
HM
:
:
new
(
)
;
m
.
insert
(
1
1
)
;
m
.
insert
(
2
2
)
;
m
.
remove
(
&
1
)
;
m
.
remove
(
&
2
)
;
m
.
shrink_to_fit
(
)
;
assert_eq
!
(
m
.
capacity
(
)
0
)
;
let
mut
m
=
HM
:
:
new
(
)
;
m
.
reserve
(
0
)
;
assert_eq
!
(
m
.
capacity
(
)
0
)
;
}
#
[
test
]
fn
test_create_capacity_zero
(
)
{
let
mut
m
=
HashMap
:
:
with_capacity
(
0
)
;
assert
!
(
m
.
insert
(
1
1
)
.
is_none
(
)
)
;
assert
!
(
m
.
contains_key
(
&
1
)
)
;
assert
!
(
!
m
.
contains_key
(
&
0
)
)
;
}
#
[
test
]
fn
test_insert
(
)
{
let
mut
m
=
HashMap
:
:
new
(
)
;
assert_eq
!
(
m
.
len
(
)
0
)
;
assert
!
(
m
.
insert
(
1
2
)
.
is_none
(
)
)
;
assert_eq
!
(
m
.
len
(
)
1
)
;
assert
!
(
m
.
insert
(
2
4
)
.
is_none
(
)
)
;
assert_eq
!
(
m
.
len
(
)
2
)
;
assert_eq
!
(
*
m
.
get
(
&
1
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
*
m
.
get
(
&
2
)
.
unwrap
(
)
4
)
;
}
#
[
test
]
fn
test_clone
(
)
{
let
mut
m
=
HashMap
:
:
new
(
)
;
assert_eq
!
(
m
.
len
(
)
0
)
;
assert
!
(
m
.
insert
(
1
2
)
.
is_none
(
)
)
;
assert_eq
!
(
m
.
len
(
)
1
)
;
assert
!
(
m
.
insert
(
2
4
)
.
is_none
(
)
)
;
assert_eq
!
(
m
.
len
(
)
2
)
;
let
m2
=
m
.
clone
(
)
;
assert_eq
!
(
*
m2
.
get
(
&
1
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
*
m2
.
get
(
&
2
)
.
unwrap
(
)
4
)
;
assert_eq
!
(
m2
.
len
(
)
2
)
;
}
thread_local
!
{
static
DROP_VECTOR
:
RefCell
<
Vec
<
isize
>
>
=
RefCell
:
:
new
(
Vec
:
:
new
(
)
)
}
#
[
derive
(
Hash
PartialEq
Eq
)
]
struct
Dropable
{
k
:
usize
}
impl
Dropable
{
fn
new
(
k
:
usize
)
-
>
Dropable
{
DROP_VECTOR
.
with
(
|
slot
|
{
slot
.
borrow_mut
(
)
[
k
]
+
=
1
;
}
)
;
Dropable
{
k
:
k
}
}
}
impl
Drop
for
Dropable
{
fn
drop
(
&
mut
self
)
{
DROP_VECTOR
.
with
(
|
slot
|
{
slot
.
borrow_mut
(
)
[
self
.
k
]
-
=
1
;
}
)
;
}
}
impl
Clone
for
Dropable
{
fn
clone
(
&
self
)
-
>
Dropable
{
Dropable
:
:
new
(
self
.
k
)
}
}
#
[
test
]
fn
test_drops
(
)
{
DROP_VECTOR
.
with
(
|
slot
|
{
*
slot
.
borrow_mut
(
)
=
vec
!
[
0
;
200
]
;
}
)
;
{
let
mut
m
=
HashMap
:
:
new
(
)
;
DROP_VECTOR
.
with
(
|
v
|
{
for
i
in
0
.
.
200
{
assert_eq
!
(
v
.
borrow
(
)
[
i
]
0
)
;
}
}
)
;
for
i
in
0
.
.
100
{
let
d1
=
Dropable
:
:
new
(
i
)
;
let
d2
=
Dropable
:
:
new
(
i
+
100
)
;
m
.
insert
(
d1
d2
)
;
}
DROP_VECTOR
.
with
(
|
v
|
{
for
i
in
0
.
.
200
{
assert_eq
!
(
v
.
borrow
(
)
[
i
]
1
)
;
}
}
)
;
for
i
in
0
.
.
50
{
let
k
=
Dropable
:
:
new
(
i
)
;
let
v
=
m
.
remove
(
&
k
)
;
assert
!
(
v
.
is_some
(
)
)
;
DROP_VECTOR
.
with
(
|
v
|
{
assert_eq
!
(
v
.
borrow
(
)
[
i
]
1
)
;
assert_eq
!
(
v
.
borrow
(
)
[
i
+
100
]
1
)
;
}
)
;
}
DROP_VECTOR
.
with
(
|
v
|
{
for
i
in
0
.
.
50
{
assert_eq
!
(
v
.
borrow
(
)
[
i
]
0
)
;
assert_eq
!
(
v
.
borrow
(
)
[
i
+
100
]
0
)
;
}
for
i
in
50
.
.
100
{
assert_eq
!
(
v
.
borrow
(
)
[
i
]
1
)
;
assert_eq
!
(
v
.
borrow
(
)
[
i
+
100
]
1
)
;
}
}
)
;
}
DROP_VECTOR
.
with
(
|
v
|
{
for
i
in
0
.
.
200
{
assert_eq
!
(
v
.
borrow
(
)
[
i
]
0
)
;
}
}
)
;
}
#
[
test
]
fn
test_into_iter_drops
(
)
{
DROP_VECTOR
.
with
(
|
v
|
{
*
v
.
borrow_mut
(
)
=
vec
!
[
0
;
200
]
;
}
)
;
let
hm
=
{
let
mut
hm
=
HashMap
:
:
new
(
)
;
DROP_VECTOR
.
with
(
|
v
|
{
for
i
in
0
.
.
200
{
assert_eq
!
(
v
.
borrow
(
)
[
i
]
0
)
;
}
}
)
;
for
i
in
0
.
.
100
{
let
d1
=
Dropable
:
:
new
(
i
)
;
let
d2
=
Dropable
:
:
new
(
i
+
100
)
;
hm
.
insert
(
d1
d2
)
;
}
DROP_VECTOR
.
with
(
|
v
|
{
for
i
in
0
.
.
200
{
assert_eq
!
(
v
.
borrow
(
)
[
i
]
1
)
;
}
}
)
;
hm
}
;
drop
(
hm
.
clone
(
)
)
;
{
let
mut
half
=
hm
.
into_iter
(
)
.
take
(
50
)
;
DROP_VECTOR
.
with
(
|
v
|
{
for
i
in
0
.
.
200
{
assert_eq
!
(
v
.
borrow
(
)
[
i
]
1
)
;
}
}
)
;
for
_
in
half
.
by_ref
(
)
{
}
DROP_VECTOR
.
with
(
|
v
|
{
let
nk
=
(
0
.
.
100
)
.
filter
(
|
&
i
|
v
.
borrow
(
)
[
i
]
=
=
1
)
.
count
(
)
;
let
nv
=
(
0
.
.
100
)
.
filter
(
|
&
i
|
v
.
borrow
(
)
[
i
+
100
]
=
=
1
)
.
count
(
)
;
assert_eq
!
(
nk
50
)
;
assert_eq
!
(
nv
50
)
;
}
)
;
}
;
DROP_VECTOR
.
with
(
|
v
|
{
for
i
in
0
.
.
200
{
assert_eq
!
(
v
.
borrow
(
)
[
i
]
0
)
;
}
}
)
;
}
#
[
test
]
fn
test_empty_remove
(
)
{
let
mut
m
:
HashMap
<
isize
bool
>
=
HashMap
:
:
new
(
)
;
assert_eq
!
(
m
.
remove
(
&
0
)
None
)
;
}
#
[
test
]
fn
test_empty_entry
(
)
{
let
mut
m
:
HashMap
<
isize
bool
>
=
HashMap
:
:
new
(
)
;
match
m
.
entry
(
0
)
{
Occupied
(
_
)
=
>
panic
!
(
)
Vacant
(
_
)
=
>
{
}
}
assert
!
(
*
m
.
entry
(
0
)
.
or_insert
(
true
)
)
;
assert_eq
!
(
m
.
len
(
)
1
)
;
}
#
[
test
]
fn
test_empty_iter
(
)
{
let
mut
m
:
HashMap
<
isize
bool
>
=
HashMap
:
:
new
(
)
;
assert_eq
!
(
m
.
drain
(
)
.
next
(
)
None
)
;
assert_eq
!
(
m
.
keys
(
)
.
next
(
)
None
)
;
assert_eq
!
(
m
.
values
(
)
.
next
(
)
None
)
;
assert_eq
!
(
m
.
values_mut
(
)
.
next
(
)
None
)
;
assert_eq
!
(
m
.
iter
(
)
.
next
(
)
None
)
;
assert_eq
!
(
m
.
iter_mut
(
)
.
next
(
)
None
)
;
assert_eq
!
(
m
.
len
(
)
0
)
;
assert
!
(
m
.
is_empty
(
)
)
;
assert_eq
!
(
m
.
into_iter
(
)
.
next
(
)
None
)
;
}
#
[
test
]
fn
test_lots_of_insertions
(
)
{
let
mut
m
=
HashMap
:
:
new
(
)
;
for
_
in
0
.
.
10
{
assert
!
(
m
.
is_empty
(
)
)
;
for
i
in
1
.
.
1001
{
assert
!
(
m
.
insert
(
i
i
)
.
is_none
(
)
)
;
for
j
in
1
.
.
i
+
1
{
let
r
=
m
.
get
(
&
j
)
;
assert_eq
!
(
r
Some
(
&
j
)
)
;
}
for
j
in
i
+
1
.
.
1001
{
let
r
=
m
.
get
(
&
j
)
;
assert_eq
!
(
r
None
)
;
}
}
for
i
in
1001
.
.
2001
{
assert
!
(
!
m
.
contains_key
(
&
i
)
)
;
}
for
i
in
1
.
.
1001
{
assert
!
(
m
.
remove
(
&
i
)
.
is_some
(
)
)
;
for
j
in
1
.
.
i
+
1
{
assert
!
(
!
m
.
contains_key
(
&
j
)
)
;
}
for
j
in
i
+
1
.
.
1001
{
assert
!
(
m
.
contains_key
(
&
j
)
)
;
}
}
for
i
in
1
.
.
1001
{
assert
!
(
!
m
.
contains_key
(
&
i
)
)
;
}
for
i
in
1
.
.
1001
{
assert
!
(
m
.
insert
(
i
i
)
.
is_none
(
)
)
;
}
for
i
in
(
1
.
.
1001
)
.
rev
(
)
{
assert
!
(
m
.
remove
(
&
i
)
.
is_some
(
)
)
;
for
j
in
i
.
.
1001
{
assert
!
(
!
m
.
contains_key
(
&
j
)
)
;
}
for
j
in
1
.
.
i
{
assert
!
(
m
.
contains_key
(
&
j
)
)
;
}
}
}
}
#
[
test
]
fn
test_find_mut
(
)
{
let
mut
m
=
HashMap
:
:
new
(
)
;
assert
!
(
m
.
insert
(
1
12
)
.
is_none
(
)
)
;
assert
!
(
m
.
insert
(
2
8
)
.
is_none
(
)
)
;
assert
!
(
m
.
insert
(
5
14
)
.
is_none
(
)
)
;
let
new
=
100
;
match
m
.
get_mut
(
&
5
)
{
None
=
>
panic
!
(
)
Some
(
x
)
=
>
*
x
=
new
}
assert_eq
!
(
m
.
get
(
&
5
)
Some
(
&
new
)
)
;
}
#
[
test
]
fn
test_insert_overwrite
(
)
{
let
mut
m
=
HashMap
:
:
new
(
)
;
assert
!
(
m
.
insert
(
1
2
)
.
is_none
(
)
)
;
assert_eq
!
(
*
m
.
get
(
&
1
)
.
unwrap
(
)
2
)
;
assert
!
(
!
m
.
insert
(
1
3
)
.
is_none
(
)
)
;
assert_eq
!
(
*
m
.
get
(
&
1
)
.
unwrap
(
)
3
)
;
}
#
[
test
]
fn
test_insert_conflicts
(
)
{
let
mut
m
=
HashMap
:
:
with_capacity
(
4
)
;
assert
!
(
m
.
insert
(
1
2
)
.
is_none
(
)
)
;
assert
!
(
m
.
insert
(
5
3
)
.
is_none
(
)
)
;
assert
!
(
m
.
insert
(
9
4
)
.
is_none
(
)
)
;
assert_eq
!
(
*
m
.
get
(
&
9
)
.
unwrap
(
)
4
)
;
assert_eq
!
(
*
m
.
get
(
&
5
)
.
unwrap
(
)
3
)
;
assert_eq
!
(
*
m
.
get
(
&
1
)
.
unwrap
(
)
2
)
;
}
#
[
test
]
fn
test_conflict_remove
(
)
{
let
mut
m
=
HashMap
:
:
with_capacity
(
4
)
;
assert
!
(
m
.
insert
(
1
2
)
.
is_none
(
)
)
;
assert_eq
!
(
*
m
.
get
(
&
1
)
.
unwrap
(
)
2
)
;
assert
!
(
m
.
insert
(
5
3
)
.
is_none
(
)
)
;
assert_eq
!
(
*
m
.
get
(
&
1
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
*
m
.
get
(
&
5
)
.
unwrap
(
)
3
)
;
assert
!
(
m
.
insert
(
9
4
)
.
is_none
(
)
)
;
assert_eq
!
(
*
m
.
get
(
&
1
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
*
m
.
get
(
&
5
)
.
unwrap
(
)
3
)
;
assert_eq
!
(
*
m
.
get
(
&
9
)
.
unwrap
(
)
4
)
;
assert
!
(
m
.
remove
(
&
1
)
.
is_some
(
)
)
;
assert_eq
!
(
*
m
.
get
(
&
9
)
.
unwrap
(
)
4
)
;
assert_eq
!
(
*
m
.
get
(
&
5
)
.
unwrap
(
)
3
)
;
}
#
[
test
]
fn
test_is_empty
(
)
{
let
mut
m
=
HashMap
:
:
with_capacity
(
4
)
;
assert
!
(
m
.
insert
(
1
2
)
.
is_none
(
)
)
;
assert
!
(
!
m
.
is_empty
(
)
)
;
assert
!
(
m
.
remove
(
&
1
)
.
is_some
(
)
)
;
assert
!
(
m
.
is_empty
(
)
)
;
}
#
[
test
]
fn
test_pop
(
)
{
let
mut
m
=
HashMap
:
:
new
(
)
;
m
.
insert
(
1
2
)
;
assert_eq
!
(
m
.
remove
(
&
1
)
Some
(
2
)
)
;
assert_eq
!
(
m
.
remove
(
&
1
)
None
)
;
}
#
[
test
]
fn
test_iterate
(
)
{
let
mut
m
=
HashMap
:
:
with_capacity
(
4
)
;
for
i
in
0
.
.
32
{
assert
!
(
m
.
insert
(
i
i
*
2
)
.
is_none
(
)
)
;
}
assert_eq
!
(
m
.
len
(
)
32
)
;
let
mut
observed
:
u32
=
0
;
for
(
k
v
)
in
&
m
{
assert_eq
!
(
*
v
*
k
*
2
)
;
observed
|
=
1
<
<
*
k
;
}
assert_eq
!
(
observed
0xFFFF_FFFF
)
;
}
#
[
test
]
fn
test_keys
(
)
{
let
vec
=
vec
!
[
(
1
'
a
'
)
(
2
'
b
'
)
(
3
'
c
'
)
]
;
let
map
:
HashMap
<
_
_
>
=
vec
.
into_iter
(
)
.
collect
(
)
;
let
keys
:
Vec
<
_
>
=
map
.
keys
(
)
.
cloned
(
)
.
collect
(
)
;
assert_eq
!
(
keys
.
len
(
)
3
)
;
assert
!
(
keys
.
contains
(
&
1
)
)
;
assert
!
(
keys
.
contains
(
&
2
)
)
;
assert
!
(
keys
.
contains
(
&
3
)
)
;
}
#
[
test
]
fn
test_values
(
)
{
let
vec
=
vec
!
[
(
1
'
a
'
)
(
2
'
b
'
)
(
3
'
c
'
)
]
;
let
map
:
HashMap
<
_
_
>
=
vec
.
into_iter
(
)
.
collect
(
)
;
let
values
:
Vec
<
_
>
=
map
.
values
(
)
.
cloned
(
)
.
collect
(
)
;
assert_eq
!
(
values
.
len
(
)
3
)
;
assert
!
(
values
.
contains
(
&
'
a
'
)
)
;
assert
!
(
values
.
contains
(
&
'
b
'
)
)
;
assert
!
(
values
.
contains
(
&
'
c
'
)
)
;
}
#
[
test
]
fn
test_values_mut
(
)
{
let
vec
=
vec
!
[
(
1
1
)
(
2
2
)
(
3
3
)
]
;
let
mut
map
:
HashMap
<
_
_
>
=
vec
.
into_iter
(
)
.
collect
(
)
;
for
value
in
map
.
values_mut
(
)
{
*
value
=
(
*
value
)
*
2
}
let
values
:
Vec
<
_
>
=
map
.
values
(
)
.
cloned
(
)
.
collect
(
)
;
assert_eq
!
(
values
.
len
(
)
3
)
;
assert
!
(
values
.
contains
(
&
2
)
)
;
assert
!
(
values
.
contains
(
&
4
)
)
;
assert
!
(
values
.
contains
(
&
6
)
)
;
}
#
[
test
]
fn
test_find
(
)
{
let
mut
m
=
HashMap
:
:
new
(
)
;
assert
!
(
m
.
get
(
&
1
)
.
is_none
(
)
)
;
m
.
insert
(
1
2
)
;
match
m
.
get
(
&
1
)
{
None
=
>
panic
!
(
)
Some
(
v
)
=
>
assert_eq
!
(
*
v
2
)
}
}
#
[
test
]
fn
test_eq
(
)
{
let
mut
m1
=
HashMap
:
:
new
(
)
;
m1
.
insert
(
1
2
)
;
m1
.
insert
(
2
3
)
;
m1
.
insert
(
3
4
)
;
let
mut
m2
=
HashMap
:
:
new
(
)
;
m2
.
insert
(
1
2
)
;
m2
.
insert
(
2
3
)
;
assert_ne
!
(
m1
m2
)
;
m2
.
insert
(
3
4
)
;
assert_eq
!
(
m1
m2
)
;
}
#
[
test
]
fn
test_show
(
)
{
let
mut
map
=
HashMap
:
:
new
(
)
;
let
empty
:
HashMap
<
i32
i32
>
=
HashMap
:
:
new
(
)
;
map
.
insert
(
1
2
)
;
map
.
insert
(
3
4
)
;
let
map_str
=
format
!
(
"
{
:
?
}
"
map
)
;
assert
!
(
map_str
=
=
"
{
1
:
2
3
:
4
}
"
|
|
map_str
=
=
"
{
3
:
4
1
:
2
}
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
empty
)
"
{
}
"
)
;
}
#
[
test
]
fn
test_expand
(
)
{
let
mut
m
=
HashMap
:
:
new
(
)
;
assert_eq
!
(
m
.
len
(
)
0
)
;
assert
!
(
m
.
is_empty
(
)
)
;
let
mut
i
=
0
;
let
old_raw_cap
=
m
.
raw_capacity
(
)
;
while
old_raw_cap
=
=
m
.
raw_capacity
(
)
{
m
.
insert
(
i
i
)
;
i
+
=
1
;
}
assert_eq
!
(
m
.
len
(
)
i
)
;
assert
!
(
!
m
.
is_empty
(
)
)
;
}
#
[
test
]
fn
test_behavior_resize_policy
(
)
{
let
mut
m
=
HashMap
:
:
new
(
)
;
assert_eq
!
(
m
.
len
(
)
0
)
;
assert_eq
!
(
m
.
raw_capacity
(
)
0
)
;
assert
!
(
m
.
is_empty
(
)
)
;
m
.
insert
(
0
0
)
;
m
.
remove
(
&
0
)
;
assert
!
(
m
.
is_empty
(
)
)
;
let
initial_raw_cap
=
m
.
raw_capacity
(
)
;
m
.
reserve
(
initial_raw_cap
)
;
let
raw_cap
=
m
.
raw_capacity
(
)
;
assert_eq
!
(
raw_cap
initial_raw_cap
*
2
)
;
let
mut
i
=
0
;
for
_
in
0
.
.
raw_cap
*
3
/
4
{
m
.
insert
(
i
i
)
;
i
+
=
1
;
}
assert_eq
!
(
m
.
len
(
)
i
)
;
assert_eq
!
(
m
.
raw_capacity
(
)
raw_cap
)
;
for
_
in
0
.
.
raw_cap
/
4
{
m
.
insert
(
i
i
)
;
i
+
=
1
;
}
let
new_raw_cap
=
m
.
raw_capacity
(
)
;
assert_eq
!
(
new_raw_cap
raw_cap
*
2
)
;
for
_
in
0
.
.
raw_cap
/
2
-
1
{
i
-
=
1
;
m
.
remove
(
&
i
)
;
assert_eq
!
(
m
.
raw_capacity
(
)
new_raw_cap
)
;
}
m
.
shrink_to_fit
(
)
;
assert_eq
!
(
m
.
raw_capacity
(
)
raw_cap
)
;
for
_
in
0
.
.
raw_cap
/
2
-
1
{
i
-
=
1
;
m
.
remove
(
&
i
)
;
}
m
.
shrink_to_fit
(
)
;
assert_eq
!
(
m
.
len
(
)
i
)
;
assert
!
(
!
m
.
is_empty
(
)
)
;
assert_eq
!
(
m
.
raw_capacity
(
)
initial_raw_cap
)
;
}
#
[
test
]
fn
test_reserve_shrink_to_fit
(
)
{
let
mut
m
=
HashMap
:
:
new
(
)
;
m
.
insert
(
0
0
)
;
m
.
remove
(
&
0
)
;
assert
!
(
m
.
capacity
(
)
>
=
m
.
len
(
)
)
;
for
i
in
0
.
.
128
{
m
.
insert
(
i
i
)
;
}
m
.
reserve
(
256
)
;
let
usable_cap
=
m
.
capacity
(
)
;
for
i
in
128
.
.
(
128
+
256
)
{
m
.
insert
(
i
i
)
;
assert_eq
!
(
m
.
capacity
(
)
usable_cap
)
;
}
for
i
in
100
.
.
(
128
+
256
)
{
assert_eq
!
(
m
.
remove
(
&
i
)
Some
(
i
)
)
;
}
m
.
shrink_to_fit
(
)
;
assert_eq
!
(
m
.
len
(
)
100
)
;
assert
!
(
!
m
.
is_empty
(
)
)
;
assert
!
(
m
.
capacity
(
)
>
=
m
.
len
(
)
)
;
for
i
in
0
.
.
100
{
assert_eq
!
(
m
.
remove
(
&
i
)
Some
(
i
)
)
;
}
m
.
shrink_to_fit
(
)
;
m
.
insert
(
0
0
)
;
assert_eq
!
(
m
.
len
(
)
1
)
;
assert
!
(
m
.
capacity
(
)
>
=
m
.
len
(
)
)
;
assert_eq
!
(
m
.
remove
(
&
0
)
Some
(
0
)
)
;
}
#
[
test
]
fn
test_from_iter
(
)
{
let
xs
=
[
(
1
1
)
(
2
2
)
(
3
3
)
(
4
4
)
(
5
5
)
(
6
6
)
]
;
let
map
:
HashMap
<
_
_
>
=
xs
.
iter
(
)
.
cloned
(
)
.
collect
(
)
;
for
&
(
k
v
)
in
&
xs
{
assert_eq
!
(
map
.
get
(
&
k
)
Some
(
&
v
)
)
;
}
}
#
[
test
]
fn
test_size_hint
(
)
{
let
xs
=
[
(
1
1
)
(
2
2
)
(
3
3
)
(
4
4
)
(
5
5
)
(
6
6
)
]
;
let
map
:
HashMap
<
_
_
>
=
xs
.
iter
(
)
.
cloned
(
)
.
collect
(
)
;
let
mut
iter
=
map
.
iter
(
)
;
for
_
in
iter
.
by_ref
(
)
.
take
(
3
)
{
}
assert_eq
!
(
iter
.
size_hint
(
)
(
3
Some
(
3
)
)
)
;
}
#
[
test
]
fn
test_iter_len
(
)
{
let
xs
=
[
(
1
1
)
(
2
2
)
(
3
3
)
(
4
4
)
(
5
5
)
(
6
6
)
]
;
let
map
:
HashMap
<
_
_
>
=
xs
.
iter
(
)
.
cloned
(
)
.
collect
(
)
;
let
mut
iter
=
map
.
iter
(
)
;
for
_
in
iter
.
by_ref
(
)
.
take
(
3
)
{
}
assert_eq
!
(
iter
.
len
(
)
3
)
;
}
#
[
test
]
fn
test_mut_size_hint
(
)
{
let
xs
=
[
(
1
1
)
(
2
2
)
(
3
3
)
(
4
4
)
(
5
5
)
(
6
6
)
]
;
let
mut
map
:
HashMap
<
_
_
>
=
xs
.
iter
(
)
.
cloned
(
)
.
collect
(
)
;
let
mut
iter
=
map
.
iter_mut
(
)
;
for
_
in
iter
.
by_ref
(
)
.
take
(
3
)
{
}
assert_eq
!
(
iter
.
size_hint
(
)
(
3
Some
(
3
)
)
)
;
}
#
[
test
]
fn
test_iter_mut_len
(
)
{
let
xs
=
[
(
1
1
)
(
2
2
)
(
3
3
)
(
4
4
)
(
5
5
)
(
6
6
)
]
;
let
mut
map
:
HashMap
<
_
_
>
=
xs
.
iter
(
)
.
cloned
(
)
.
collect
(
)
;
let
mut
iter
=
map
.
iter_mut
(
)
;
for
_
in
iter
.
by_ref
(
)
.
take
(
3
)
{
}
assert_eq
!
(
iter
.
len
(
)
3
)
;
}
#
[
test
]
fn
test_index
(
)
{
let
mut
map
=
HashMap
:
:
new
(
)
;
map
.
insert
(
1
2
)
;
map
.
insert
(
2
1
)
;
map
.
insert
(
3
4
)
;
assert_eq
!
(
map
[
&
2
]
1
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_index_nonexistent
(
)
{
let
mut
map
=
HashMap
:
:
new
(
)
;
map
.
insert
(
1
2
)
;
map
.
insert
(
2
1
)
;
map
.
insert
(
3
4
)
;
map
[
&
4
]
;
}
#
[
test
]
fn
test_entry
(
)
{
let
xs
=
[
(
1
10
)
(
2
20
)
(
3
30
)
(
4
40
)
(
5
50
)
(
6
60
)
]
;
let
mut
map
:
HashMap
<
_
_
>
=
xs
.
iter
(
)
.
cloned
(
)
.
collect
(
)
;
match
map
.
entry
(
1
)
{
Vacant
(
_
)
=
>
unreachable
!
(
)
Occupied
(
mut
view
)
=
>
{
assert_eq
!
(
view
.
get
(
)
&
10
)
;
assert_eq
!
(
view
.
insert
(
100
)
10
)
;
}
}
assert_eq
!
(
map
.
get
(
&
1
)
.
unwrap
(
)
&
100
)
;
assert_eq
!
(
map
.
len
(
)
6
)
;
match
map
.
entry
(
2
)
{
Vacant
(
_
)
=
>
unreachable
!
(
)
Occupied
(
mut
view
)
=
>
{
let
v
=
view
.
get_mut
(
)
;
let
new_v
=
(
*
v
)
*
10
;
*
v
=
new_v
;
}
}
assert_eq
!
(
map
.
get
(
&
2
)
.
unwrap
(
)
&
200
)
;
assert_eq
!
(
map
.
len
(
)
6
)
;
match
map
.
entry
(
3
)
{
Vacant
(
_
)
=
>
unreachable
!
(
)
Occupied
(
view
)
=
>
{
assert_eq
!
(
view
.
remove
(
)
30
)
;
}
}
assert_eq
!
(
map
.
get
(
&
3
)
None
)
;
assert_eq
!
(
map
.
len
(
)
5
)
;
match
map
.
entry
(
10
)
{
Occupied
(
_
)
=
>
unreachable
!
(
)
Vacant
(
view
)
=
>
{
assert_eq
!
(
*
view
.
insert
(
1000
)
1000
)
;
}
}
assert_eq
!
(
map
.
get
(
&
10
)
.
unwrap
(
)
&
1000
)
;
assert_eq
!
(
map
.
len
(
)
6
)
;
}
#
[
test
]
fn
test_entry_take_doesnt_corrupt
(
)
{
#
!
[
allow
(
deprecated
)
]
fn
check
(
m
:
&
HashMap
<
isize
(
)
>
)
{
for
k
in
m
.
keys
(
)
{
assert
!
(
m
.
contains_key
(
k
)
"
{
}
is
in
keys
(
)
but
not
in
the
map
?
"
k
)
;
}
}
let
mut
m
=
HashMap
:
:
new
(
)
;
let
mut
rng
=
thread_rng
(
)
;
for
_
in
0
.
.
50
{
let
x
=
rng
.
gen_range
(
-
10
10
)
;
m
.
insert
(
x
(
)
)
;
}
for
i
in
0
.
.
1000
{
let
x
=
rng
.
gen_range
(
-
10
10
)
;
match
m
.
entry
(
x
)
{
Vacant
(
_
)
=
>
{
}
Occupied
(
e
)
=
>
{
println
!
(
"
{
}
:
remove
{
}
"
i
x
)
;
e
.
remove
(
)
;
}
}
check
(
&
m
)
;
}
}
#
[
test
]
fn
test_extend_ref
(
)
{
let
mut
a
=
HashMap
:
:
new
(
)
;
a
.
insert
(
1
"
one
"
)
;
let
mut
b
=
HashMap
:
:
new
(
)
;
b
.
insert
(
2
"
two
"
)
;
b
.
insert
(
3
"
three
"
)
;
a
.
extend
(
&
b
)
;
assert_eq
!
(
a
.
len
(
)
3
)
;
assert_eq
!
(
a
[
&
1
]
"
one
"
)
;
assert_eq
!
(
a
[
&
2
]
"
two
"
)
;
assert_eq
!
(
a
[
&
3
]
"
three
"
)
;
}
#
[
test
]
fn
test_capacity_not_less_than_len
(
)
{
let
mut
a
=
HashMap
:
:
new
(
)
;
let
mut
item
=
0
;
for
_
in
0
.
.
116
{
a
.
insert
(
item
0
)
;
item
+
=
1
;
}
assert
!
(
a
.
capacity
(
)
>
a
.
len
(
)
)
;
let
free
=
a
.
capacity
(
)
-
a
.
len
(
)
;
for
_
in
0
.
.
free
{
a
.
insert
(
item
0
)
;
item
+
=
1
;
}
assert_eq
!
(
a
.
len
(
)
a
.
capacity
(
)
)
;
a
.
insert
(
item
0
)
;
assert
!
(
a
.
capacity
(
)
>
a
.
len
(
)
)
;
}
#
[
test
]
fn
test_occupied_entry_key
(
)
{
let
mut
a
=
HashMap
:
:
new
(
)
;
let
key
=
"
hello
there
"
;
let
value
=
"
value
goes
here
"
;
assert
!
(
a
.
is_empty
(
)
)
;
a
.
insert
(
key
.
clone
(
)
value
.
clone
(
)
)
;
assert_eq
!
(
a
.
len
(
)
1
)
;
assert_eq
!
(
a
[
key
]
value
)
;
match
a
.
entry
(
key
.
clone
(
)
)
{
Vacant
(
_
)
=
>
panic
!
(
)
Occupied
(
e
)
=
>
assert_eq
!
(
key
*
e
.
key
(
)
)
}
assert_eq
!
(
a
.
len
(
)
1
)
;
assert_eq
!
(
a
[
key
]
value
)
;
}
#
[
test
]
fn
test_vacant_entry_key
(
)
{
let
mut
a
=
HashMap
:
:
new
(
)
;
let
key
=
"
hello
there
"
;
let
value
=
"
value
goes
here
"
;
assert
!
(
a
.
is_empty
(
)
)
;
match
a
.
entry
(
key
.
clone
(
)
)
{
Occupied
(
_
)
=
>
panic
!
(
)
Vacant
(
e
)
=
>
{
assert_eq
!
(
key
*
e
.
key
(
)
)
;
e
.
insert
(
value
.
clone
(
)
)
;
}
}
assert_eq
!
(
a
.
len
(
)
1
)
;
assert_eq
!
(
a
[
key
]
value
)
;
}
#
[
test
]
fn
test_retain
(
)
{
let
mut
map
:
HashMap
<
isize
isize
>
=
(
0
.
.
100
)
.
map
(
|
x
|
(
x
x
*
10
)
)
.
collect
(
)
;
map
.
retain
(
|
&
k
_
|
k
%
2
=
=
0
)
;
assert_eq
!
(
map
.
len
(
)
50
)
;
assert_eq
!
(
map
[
&
2
]
20
)
;
assert_eq
!
(
map
[
&
4
]
40
)
;
assert_eq
!
(
map
[
&
6
]
60
)
;
}
#
[
test
]
fn
test_adaptive
(
)
{
const
TEST_LEN
:
usize
=
5000
;
let
mut
first
=
HashMap
:
:
new
(
)
;
let
mut
second
=
first
.
clone
(
)
;
first
.
extend
(
(
0
.
.
TEST_LEN
)
.
map
(
|
i
|
(
i
i
)
)
)
;
second
.
extend
(
(
TEST_LEN
.
.
TEST_LEN
*
2
)
.
map
(
|
i
|
(
i
i
)
)
)
;
for
(
&
k
&
v
)
in
&
second
{
let
prev_cap
=
first
.
capacity
(
)
;
let
expect_grow
=
first
.
len
(
)
=
=
prev_cap
;
first
.
insert
(
k
v
)
;
if
!
expect_grow
&
&
first
.
capacity
(
)
!
=
prev_cap
{
return
;
}
}
panic
!
(
"
Adaptive
early
resize
failed
"
)
;
}
}
