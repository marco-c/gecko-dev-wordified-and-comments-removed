use
servo_rand
;
use
servo_rand
:
:
Rng
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
rc
:
:
Rc
;
use
url
:
:
{
Host
Origin
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
url_serde
;
use
uuid
:
:
Uuid
;
#
[
derive
(
PartialEq
Eq
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
Deserialize
Serialize
)
)
]
pub
enum
ImmutableOrigin
{
Opaque
(
OpaqueOrigin
)
Tuple
(
String
#
[
cfg_attr
(
feature
=
"
servo
"
serde
(
deserialize_with
=
"
url_serde
:
:
deserialize
"
serialize_with
=
"
url_serde
:
:
serialize
"
)
)
]
Host
u16
)
}
impl
ImmutableOrigin
{
pub
fn
new
(
origin
:
Origin
)
-
>
ImmutableOrigin
{
match
origin
{
Origin
:
:
Opaque
(
_
)
=
>
ImmutableOrigin
:
:
new_opaque
(
)
Origin
:
:
Tuple
(
scheme
host
port
)
=
>
ImmutableOrigin
:
:
Tuple
(
scheme
host
port
)
}
}
pub
fn
same_origin
(
&
self
other
:
&
MutableOrigin
)
-
>
bool
{
self
=
=
other
.
immutable
(
)
}
pub
fn
same_origin_domain
(
&
self
other
:
&
MutableOrigin
)
-
>
bool
{
!
other
.
has_domain
(
)
&
&
self
=
=
other
.
immutable
(
)
}
pub
fn
new_opaque
(
)
-
>
ImmutableOrigin
{
ImmutableOrigin
:
:
Opaque
(
OpaqueOrigin
(
servo_rand
:
:
thread_rng
(
)
.
gen
(
)
)
)
}
pub
fn
scheme
(
&
self
)
-
>
Option
<
&
str
>
{
match
*
self
{
ImmutableOrigin
:
:
Opaque
(
_
)
=
>
None
ImmutableOrigin
:
:
Tuple
(
ref
scheme
_
_
)
=
>
Some
(
&
*
*
scheme
)
}
}
pub
fn
host
(
&
self
)
-
>
Option
<
&
Host
>
{
match
*
self
{
ImmutableOrigin
:
:
Opaque
(
_
)
=
>
None
ImmutableOrigin
:
:
Tuple
(
_
ref
host
_
)
=
>
Some
(
host
)
}
}
pub
fn
port
(
&
self
)
-
>
Option
<
u16
>
{
match
*
self
{
ImmutableOrigin
:
:
Opaque
(
_
)
=
>
None
ImmutableOrigin
:
:
Tuple
(
_
_
port
)
=
>
Some
(
port
)
}
}
pub
fn
into_url_origin
(
self
)
-
>
Origin
{
match
self
{
ImmutableOrigin
:
:
Opaque
(
_
)
=
>
Origin
:
:
new_opaque
(
)
ImmutableOrigin
:
:
Tuple
(
scheme
host
port
)
=
>
Origin
:
:
Tuple
(
scheme
host
port
)
}
}
pub
fn
is_tuple
(
&
self
)
-
>
bool
{
match
*
self
{
ImmutableOrigin
:
:
Opaque
(
.
.
)
=
>
false
ImmutableOrigin
:
:
Tuple
(
.
.
)
=
>
true
}
}
pub
fn
ascii_serialization
(
&
self
)
-
>
String
{
self
.
clone
(
)
.
into_url_origin
(
)
.
ascii_serialization
(
)
}
pub
fn
unicode_serialization
(
&
self
)
-
>
String
{
self
.
clone
(
)
.
into_url_origin
(
)
.
unicode_serialization
(
)
}
}
#
[
derive
(
Eq
PartialEq
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
pub
struct
OpaqueOrigin
(
Uuid
)
;
#
[
cfg
(
feature
=
"
servo
"
)
]
known_heap_size
!
(
0
OpaqueOrigin
)
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
MutableOrigin
(
Rc
<
(
ImmutableOrigin
RefCell
<
Option
<
Host
>
>
)
>
)
;
#
[
cfg
(
feature
=
"
servo
"
)
]
known_heap_size
!
(
0
MutableOrigin
)
;
impl
MutableOrigin
{
pub
fn
new
(
origin
:
ImmutableOrigin
)
-
>
MutableOrigin
{
MutableOrigin
(
Rc
:
:
new
(
(
origin
RefCell
:
:
new
(
None
)
)
)
)
}
pub
fn
immutable
(
&
self
)
-
>
&
ImmutableOrigin
{
&
(
self
.
0
)
.
0
}
pub
fn
is_tuple
(
&
self
)
-
>
bool
{
self
.
immutable
(
)
.
is_tuple
(
)
}
pub
fn
scheme
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
immutable
(
)
.
scheme
(
)
}
pub
fn
host
(
&
self
)
-
>
Option
<
&
Host
>
{
self
.
immutable
(
)
.
host
(
)
}
pub
fn
port
(
&
self
)
-
>
Option
<
u16
>
{
self
.
immutable
(
)
.
port
(
)
}
pub
fn
same_origin
(
&
self
other
:
&
MutableOrigin
)
-
>
bool
{
self
.
immutable
(
)
=
=
other
.
immutable
(
)
}
pub
fn
same_origin_domain
(
&
self
other
:
&
MutableOrigin
)
-
>
bool
{
if
let
Some
(
ref
self_domain
)
=
*
(
self
.
0
)
.
1
.
borrow
(
)
{
if
let
Some
(
ref
other_domain
)
=
*
(
other
.
0
)
.
1
.
borrow
(
)
{
self_domain
=
=
other_domain
&
&
self
.
immutable
(
)
.
scheme
(
)
=
=
other
.
immutable
(
)
.
scheme
(
)
}
else
{
false
}
}
else
{
self
.
immutable
(
)
.
same_origin_domain
(
other
)
}
}
pub
fn
domain
(
&
self
)
-
>
Option
<
Host
>
{
(
self
.
0
)
.
1
.
borrow
(
)
.
clone
(
)
}
pub
fn
set_domain
(
&
self
domain
:
Host
)
{
*
(
self
.
0
)
.
1
.
borrow_mut
(
)
=
Some
(
domain
)
;
}
pub
fn
has_domain
(
&
self
)
-
>
bool
{
(
self
.
0
)
.
1
.
borrow
(
)
.
is_some
(
)
}
pub
fn
effective_domain
(
&
self
)
-
>
Option
<
Host
>
{
self
.
immutable
(
)
.
host
(
)
.
map
(
|
host
|
self
.
domain
(
)
.
unwrap_or_else
(
|
|
host
.
clone
(
)
)
)
}
}
