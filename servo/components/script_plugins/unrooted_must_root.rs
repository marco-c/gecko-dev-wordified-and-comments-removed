use
rustc
:
:
hir
;
use
rustc
:
:
hir
:
:
intravisit
as
visit
;
use
rustc
:
:
hir
:
:
map
as
ast_map
;
use
rustc
:
:
lint
:
:
{
LateContext
LintPass
LintArray
LateLintPass
LintContext
}
;
use
rustc
:
:
ty
;
use
syntax
:
:
{
ast
codemap
}
;
use
utils
:
:
{
match_def_path
in_derive_expn
}
;
declare_lint
!
(
UNROOTED_MUST_ROOT
Deny
"
Warn
and
report
usage
of
unrooted
jsmanaged
objects
"
)
;
pub
struct
UnrootedPass
;
impl
UnrootedPass
{
pub
fn
new
(
)
-
>
UnrootedPass
{
UnrootedPass
}
}
fn
is_unrooted_ty
(
cx
:
&
LateContext
ty
:
&
ty
:
:
TyS
in_new_function
:
bool
)
-
>
bool
{
let
mut
ret
=
false
;
ty
.
maybe_walk
(
|
t
|
{
match
t
.
sty
{
ty
:
:
TyAdt
(
did
_
)
=
>
{
if
cx
.
tcx
.
has_attr
(
did
.
did
"
must_root
"
)
{
ret
=
true
;
false
}
else
if
cx
.
tcx
.
has_attr
(
did
.
did
"
allow_unrooted_interior
"
)
{
false
}
else
if
match_def_path
(
cx
did
.
did
&
[
"
core
"
"
cell
"
"
Ref
"
]
)
|
|
match_def_path
(
cx
did
.
did
&
[
"
core
"
"
cell
"
"
RefMut
"
]
)
|
|
match_def_path
(
cx
did
.
did
&
[
"
core
"
"
slice
"
"
Iter
"
]
)
|
|
match_def_path
(
cx
did
.
did
&
[
"
std
"
"
collections
"
"
hash
"
"
map
"
"
Entry
"
]
)
|
|
match_def_path
(
cx
did
.
did
&
[
"
std
"
"
collections
"
"
hash
"
"
map
"
"
OccupiedEntry
"
]
)
|
|
match_def_path
(
cx
did
.
did
&
[
"
std
"
"
collections
"
"
hash
"
"
map
"
"
VacantEntry
"
]
)
|
|
match_def_path
(
cx
did
.
did
&
[
"
std
"
"
collections
"
"
hash
"
"
set
"
"
Iter
"
]
)
{
false
}
else
if
did
.
is_box
(
)
&
&
in_new_function
{
false
}
else
{
true
}
}
ty
:
:
TyRef
(
.
.
)
=
>
false
ty
:
:
TyRawPtr
(
.
.
)
=
>
false
ty
:
:
TyFnDef
(
.
.
)
|
ty
:
:
TyFnPtr
(
_
)
=
>
false
_
=
>
true
}
}
)
;
ret
}
impl
LintPass
for
UnrootedPass
{
fn
get_lints
(
&
self
)
-
>
LintArray
{
lint_array
!
(
UNROOTED_MUST_ROOT
)
}
}
impl
<
'
a
'
tcx
>
LateLintPass
<
'
a
'
tcx
>
for
UnrootedPass
{
fn
check_struct_def
(
&
mut
self
cx
:
&
LateContext
def
:
&
hir
:
:
VariantData
_n
:
ast
:
:
Name
_gen
:
&
hir
:
:
Generics
id
:
ast
:
:
NodeId
)
{
let
item
=
match
cx
.
tcx
.
hir
.
get
(
id
)
{
ast_map
:
:
Node
:
:
NodeItem
(
item
)
=
>
item
_
=
>
cx
.
tcx
.
hir
.
expect_item
(
cx
.
tcx
.
hir
.
get_parent
(
id
)
)
}
;
if
item
.
attrs
.
iter
(
)
.
all
(
|
a
|
!
a
.
check_name
(
"
must_root
"
)
)
{
for
ref
field
in
def
.
fields
(
)
{
let
def_id
=
cx
.
tcx
.
hir
.
local_def_id
(
field
.
id
)
;
if
is_unrooted_ty
(
cx
cx
.
tcx
.
type_of
(
def_id
)
false
)
{
cx
.
span_lint
(
UNROOTED_MUST_ROOT
field
.
span
"
Type
must
be
rooted
use
#
[
must_root
]
on
the
struct
definition
to
propagate
"
)
}
}
}
}
fn
check_variant
(
&
mut
self
cx
:
&
LateContext
var
:
&
hir
:
:
Variant
_gen
:
&
hir
:
:
Generics
)
{
let
ref
map
=
cx
.
tcx
.
hir
;
if
map
.
expect_item
(
map
.
get_parent
(
var
.
node
.
data
.
id
(
)
)
)
.
attrs
.
iter
(
)
.
all
(
|
a
|
!
a
.
check_name
(
"
must_root
"
)
)
{
match
var
.
node
.
data
{
hir
:
:
VariantData
:
:
Tuple
(
ref
fields
_
)
=
>
{
for
ref
field
in
fields
{
let
def_id
=
cx
.
tcx
.
hir
.
local_def_id
(
field
.
id
)
;
if
is_unrooted_ty
(
cx
cx
.
tcx
.
type_of
(
def_id
)
false
)
{
cx
.
span_lint
(
UNROOTED_MUST_ROOT
field
.
ty
.
span
"
Type
must
be
rooted
use
#
[
must_root
]
on
\
the
enum
definition
to
propagate
"
)
}
}
}
_
=
>
(
)
}
}
}
fn
check_fn
(
&
mut
self
cx
:
&
LateContext
<
'
a
'
tcx
>
kind
:
visit
:
:
FnKind
decl
:
&
'
tcx
hir
:
:
FnDecl
body
:
&
'
tcx
hir
:
:
Body
span
:
codemap
:
:
Span
id
:
ast
:
:
NodeId
)
{
let
in_new_function
=
match
kind
{
visit
:
:
FnKind
:
:
ItemFn
(
n
_
_
_
_
_
_
)
|
visit
:
:
FnKind
:
:
Method
(
n
_
_
_
)
=
>
{
&
*
n
.
as_str
(
)
=
=
"
new
"
|
|
n
.
as_str
(
)
.
starts_with
(
"
new_
"
)
}
visit
:
:
FnKind
:
:
Closure
(
_
)
=
>
return
}
;
if
!
in_derive_expn
(
span
)
{
let
def_id
=
cx
.
tcx
.
hir
.
local_def_id
(
id
)
;
let
sig
=
cx
.
tcx
.
type_of
(
def_id
)
.
fn_sig
(
)
;
for
(
arg
ty
)
in
decl
.
inputs
.
iter
(
)
.
zip
(
sig
.
inputs
(
)
.
0
.
iter
(
)
)
{
if
is_unrooted_ty
(
cx
ty
false
)
{
cx
.
span_lint
(
UNROOTED_MUST_ROOT
arg
.
span
"
Type
must
be
rooted
"
)
}
}
if
!
in_new_function
{
if
is_unrooted_ty
(
cx
sig
.
output
(
)
.
0
false
)
{
cx
.
span_lint
(
UNROOTED_MUST_ROOT
decl
.
output
.
span
(
)
"
Type
must
be
rooted
"
)
}
}
}
let
mut
visitor
=
FnDefVisitor
{
cx
:
cx
in_new_function
:
in_new_function
}
;
visit
:
:
walk_expr
(
&
mut
visitor
&
body
.
value
)
;
}
}
struct
FnDefVisitor
<
'
a
'
b
:
'
a
'
tcx
:
'
a
+
'
b
>
{
cx
:
&
'
a
LateContext
<
'
b
'
tcx
>
in_new_function
:
bool
}
impl
<
'
a
'
b
'
tcx
>
visit
:
:
Visitor
<
'
tcx
>
for
FnDefVisitor
<
'
a
'
b
'
tcx
>
{
fn
visit_expr
(
&
mut
self
expr
:
&
'
tcx
hir
:
:
Expr
)
{
let
cx
=
self
.
cx
;
fn
require_rooted
(
cx
:
&
LateContext
in_new_function
:
bool
subexpr
:
&
hir
:
:
Expr
)
{
let
ty
=
cx
.
tables
.
expr_ty
(
&
subexpr
)
;
if
is_unrooted_ty
(
cx
ty
in_new_function
)
{
cx
.
span_lint
(
UNROOTED_MUST_ROOT
subexpr
.
span
&
format
!
(
"
Expression
of
type
{
:
?
}
must
be
rooted
"
ty
)
)
}
}
match
expr
.
node
{
hir
:
:
ExprCast
(
ref
subexpr
_
)
=
>
require_rooted
(
cx
self
.
in_new_function
&
*
subexpr
)
_
=
>
{
}
}
visit
:
:
walk_expr
(
self
expr
)
;
}
fn
visit_pat
(
&
mut
self
pat
:
&
'
tcx
hir
:
:
Pat
)
{
let
cx
=
self
.
cx
;
if
let
hir
:
:
PatKind
:
:
Binding
(
hir
:
:
BindingMode
:
:
BindByValue
(
_
)
_
_
_
)
=
pat
.
node
{
let
ty
=
cx
.
tables
.
pat_ty
(
pat
)
;
if
is_unrooted_ty
(
cx
ty
self
.
in_new_function
)
{
cx
.
span_lint
(
UNROOTED_MUST_ROOT
pat
.
span
&
format
!
(
"
Expression
of
type
{
:
?
}
must
be
rooted
"
ty
)
)
}
}
visit
:
:
walk_pat
(
self
pat
)
;
}
fn
visit_ty
(
&
mut
self
_
:
&
'
tcx
hir
:
:
Ty
)
{
}
fn
nested_visit_map
<
'
this
>
(
&
'
this
mut
self
)
-
>
hir
:
:
intravisit
:
:
NestedVisitorMap
<
'
this
'
tcx
>
{
hir
:
:
intravisit
:
:
NestedVisitorMap
:
:
OnlyBodies
(
&
self
.
cx
.
tcx
.
hir
)
}
}
