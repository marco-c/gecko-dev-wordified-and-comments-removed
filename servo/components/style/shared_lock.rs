use
parking_lot
:
:
RwLock
;
use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
Arc
;
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
SharedRwLock
{
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
arc
:
Arc
<
RwLock
<
(
)
>
>
}
impl
fmt
:
:
Debug
for
SharedRwLock
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
SharedRwLock
"
)
}
}
impl
SharedRwLock
{
pub
fn
new
(
)
-
>
Self
{
SharedRwLock
{
arc
:
Arc
:
:
new
(
RwLock
:
:
new
(
(
)
)
)
}
}
pub
fn
wrap
<
T
>
(
&
self
data
:
T
)
-
>
Locked
<
T
>
{
Locked
{
shared_lock
:
self
.
clone
(
)
data
:
UnsafeCell
:
:
new
(
data
)
}
}
pub
fn
read
(
&
self
)
-
>
SharedRwLockReadGuard
{
self
.
arc
.
raw_read
(
)
;
SharedRwLockReadGuard
{
shared_lock
:
self
}
}
pub
fn
write
(
&
self
)
-
>
SharedRwLockWriteGuard
{
self
.
arc
.
raw_write
(
)
;
SharedRwLockWriteGuard
{
shared_lock
:
self
}
}
}
pub
struct
Locked
<
T
>
{
shared_lock
:
SharedRwLock
data
:
UnsafeCell
<
T
>
}
unsafe
impl
<
T
:
Send
>
Send
for
Locked
<
T
>
{
}
unsafe
impl
<
T
:
Send
+
Sync
>
Sync
for
Locked
<
T
>
{
}
impl
<
T
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Locked
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
guard
=
self
.
shared_lock
.
read
(
)
;
self
.
read_with
(
&
guard
)
.
fmt
(
f
)
}
}
impl
<
T
>
Locked
<
T
>
{
fn
same_lock_as
(
&
self
lock
:
&
SharedRwLock
)
-
>
bool
{
:
:
arc_ptr_eq
(
&
self
.
shared_lock
.
arc
&
lock
.
arc
)
}
pub
fn
read_with
<
'
a
>
(
&
'
a
self
guard
:
&
'
a
SharedRwLockReadGuard
)
-
>
&
'
a
T
{
assert
!
(
self
.
same_lock_as
(
&
guard
.
shared_lock
)
"
Locked
:
:
read_with
called
with
a
guard
from
an
unrelated
SharedRwLock
"
)
;
let
ptr
=
self
.
data
.
get
(
)
;
unsafe
{
&
*
ptr
}
}
pub
fn
write_with
<
'
a
>
(
&
'
a
self
guard
:
&
'
a
mut
SharedRwLockWriteGuard
)
-
>
&
'
a
mut
T
{
assert
!
(
self
.
same_lock_as
(
&
guard
.
shared_lock
)
"
Locked
:
:
write_with
called
with
a
guard
from
an
unrelated
SharedRwLock
"
)
;
let
ptr
=
self
.
data
.
get
(
)
;
unsafe
{
&
mut
*
ptr
}
}
}
pub
struct
SharedRwLockReadGuard
<
'
a
>
{
shared_lock
:
&
'
a
SharedRwLock
}
pub
struct
SharedRwLockWriteGuard
<
'
a
>
{
shared_lock
:
&
'
a
SharedRwLock
}
impl
<
'
a
>
Drop
for
SharedRwLockReadGuard
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
shared_lock
.
arc
.
raw_unlock_read
(
)
}
}
}
impl
<
'
a
>
Drop
for
SharedRwLockWriteGuard
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
shared_lock
.
arc
.
raw_unlock_write
(
)
}
}
}
#
[
allow
(
dead_code
)
]
mod
compile_time_assert
{
use
super
:
:
{
SharedRwLockReadGuard
SharedRwLockWriteGuard
}
;
trait
Marker1
{
}
impl
<
T
:
Clone
>
Marker1
for
T
{
}
impl
<
'
a
>
Marker1
for
SharedRwLockReadGuard
<
'
a
>
{
}
impl
<
'
a
>
Marker1
for
SharedRwLockWriteGuard
<
'
a
>
{
}
trait
Marker2
{
}
impl
<
T
:
Copy
>
Marker2
for
T
{
}
impl
<
'
a
>
Marker2
for
SharedRwLockReadGuard
<
'
a
>
{
}
impl
<
'
a
>
Marker2
for
SharedRwLockWriteGuard
<
'
a
>
{
}
}
pub
trait
ToCssWithGuard
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
;
#
[
inline
]
fn
to_css_string
(
&
self
guard
:
&
SharedRwLockReadGuard
)
-
>
String
{
let
mut
s
=
String
:
:
new
(
)
;
self
.
to_css
(
guard
&
mut
s
)
.
unwrap
(
)
;
s
}
}
#
[
derive
(
Clone
)
]
pub
struct
StylesheetGuards
<
'
a
>
{
pub
author
:
&
'
a
SharedRwLockReadGuard
<
'
a
>
pub
ua_or_user
:
&
'
a
SharedRwLockReadGuard
<
'
a
>
}
impl
<
'
a
>
StylesheetGuards
<
'
a
>
{
pub
fn
same
(
guard
:
&
'
a
SharedRwLockReadGuard
<
'
a
>
)
-
>
Self
{
StylesheetGuards
{
author
:
guard
ua_or_user
:
guard
}
}
}
