#
[
cfg
(
feature
=
"
gecko
"
)
]
use
malloc_size_of
:
:
{
MallocShallowSizeOf
MallocSizeOfOps
}
;
use
servo_arc
:
:
{
Arc
RawOffsetArc
}
;
use
shared_lock
:
:
{
DeepCloneParams
DeepCloneWithLock
Locked
}
;
use
shared_lock
:
:
{
SharedRwLock
SharedRwLockReadGuard
ToCssWithGuard
}
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
str
:
:
CssStringWriter
;
use
stylesheets
:
:
{
CssRule
RulesMutateError
}
;
use
stylesheets
:
:
loader
:
:
StylesheetLoader
;
use
stylesheets
:
:
rule_parser
:
:
State
;
use
stylesheets
:
:
stylesheet
:
:
StylesheetContents
;
#
[
derive
(
Debug
)
]
pub
struct
CssRules
(
pub
Vec
<
CssRule
>
)
;
impl
CssRules
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_empty
(
)
}
}
impl
DeepCloneWithLock
for
CssRules
{
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
guard
:
&
SharedRwLockReadGuard
params
:
&
DeepCloneParams
)
-
>
Self
{
CssRules
(
self
.
0
.
iter
(
)
.
map
(
|
x
|
{
x
.
deep_clone_with_lock
(
lock
guard
params
)
}
)
.
collect
(
)
)
}
}
impl
CssRules
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
size_of
(
&
self
guard
:
&
SharedRwLockReadGuard
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
0
.
shallow_size_of
(
ops
)
;
for
rule
in
self
.
0
.
iter
(
)
{
n
+
=
rule
.
size_of
(
guard
ops
)
;
}
n
}
pub
fn
new
(
rules
:
Vec
<
CssRule
>
shared_lock
:
&
SharedRwLock
)
-
>
Arc
<
Locked
<
CssRules
>
>
{
Arc
:
:
new
(
shared_lock
.
wrap
(
CssRules
(
rules
)
)
)
}
fn
only_ns_or_import
(
&
self
)
-
>
bool
{
self
.
0
.
iter
(
)
.
all
(
|
r
|
{
match
*
r
{
CssRule
:
:
Namespace
(
.
.
)
|
CssRule
:
:
Import
(
.
.
)
=
>
true
_
=
>
false
}
}
)
}
pub
fn
remove_rule
(
&
mut
self
index
:
usize
)
-
>
Result
<
(
)
RulesMutateError
>
{
if
index
>
=
self
.
0
.
len
(
)
{
return
Err
(
RulesMutateError
:
:
IndexSize
)
;
}
{
let
ref
rule
=
self
.
0
[
index
]
;
if
let
CssRule
:
:
Namespace
(
.
.
)
=
*
rule
{
if
!
self
.
only_ns_or_import
(
)
{
return
Err
(
RulesMutateError
:
:
InvalidState
)
;
}
}
}
self
.
0
.
remove
(
index
)
;
Ok
(
(
)
)
}
pub
fn
to_css_block
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
CssStringWriter
)
-
>
fmt
:
:
Result
{
dest
.
write_str
(
"
{
"
)
?
;
for
rule
in
self
.
0
.
iter
(
)
{
dest
.
write_str
(
"
\
n
"
)
?
;
rule
.
to_css
(
guard
dest
)
?
;
}
dest
.
write_str
(
"
\
n
}
"
)
}
}
pub
trait
CssRulesHelpers
{
fn
insert_rule
(
&
self
lock
:
&
SharedRwLock
rule
:
&
str
parent_stylesheet_contents
:
&
StylesheetContents
index
:
usize
nested
:
bool
loader
:
Option
<
&
StylesheetLoader
>
)
-
>
Result
<
CssRule
RulesMutateError
>
;
}
impl
CssRulesHelpers
for
RawOffsetArc
<
Locked
<
CssRules
>
>
{
fn
insert_rule
(
&
self
lock
:
&
SharedRwLock
rule
:
&
str
parent_stylesheet_contents
:
&
StylesheetContents
index
:
usize
nested
:
bool
loader
:
Option
<
&
StylesheetLoader
>
)
-
>
Result
<
CssRule
RulesMutateError
>
{
let
state
=
{
let
read_guard
=
lock
.
read
(
)
;
let
rules
=
self
.
read_with
(
&
read_guard
)
;
if
index
>
rules
.
0
.
len
(
)
{
return
Err
(
RulesMutateError
:
:
IndexSize
)
;
}
if
nested
{
None
}
else
if
index
=
=
0
{
Some
(
State
:
:
Start
)
}
else
{
rules
.
0
.
get
(
index
-
1
)
.
map
(
CssRule
:
:
rule_state
)
}
}
;
let
(
new_rule
new_state
)
=
CssRule
:
:
parse
(
&
rule
parent_stylesheet_contents
lock
state
loader
)
?
;
{
let
mut
write_guard
=
lock
.
write
(
)
;
let
rules
=
self
.
write_with
(
&
mut
write_guard
)
;
let
rev_state
=
rules
.
0
.
get
(
index
)
.
map_or
(
State
:
:
Body
CssRule
:
:
rule_state
)
;
if
new_state
>
rev_state
{
return
Err
(
RulesMutateError
:
:
HierarchyRequest
)
;
}
if
let
CssRule
:
:
Namespace
(
.
.
)
=
new_rule
{
if
!
rules
.
only_ns_or_import
(
)
{
return
Err
(
RulesMutateError
:
:
InvalidState
)
;
}
}
rules
.
0
.
insert
(
index
new_rule
.
clone
(
)
)
;
}
Ok
(
new_rule
)
}
}
