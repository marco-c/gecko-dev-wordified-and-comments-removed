use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
properties
:
:
PropertyDeclarationBlock
;
use
crate
:
:
shared_lock
:
:
{
DeepCloneParams
DeepCloneWithLock
Locked
}
;
use
crate
:
:
shared_lock
:
:
{
SharedRwLock
SharedRwLockReadGuard
ToCssWithGuard
}
;
use
crate
:
:
str
:
:
CssStringWriter
;
use
crate
:
:
values
:
:
{
AtomIdent
CustomIdent
}
;
use
style_traits
:
:
{
CssWriter
ParseError
ToCss
}
;
use
cssparser
:
:
{
ToCss
as
CssParserToCss
Parser
SourceLocation
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
malloc_size_of
:
:
{
MallocSizeOf
MallocSizeOfOps
MallocUnconditionalShallowSizeOf
}
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToShmem
)
]
pub
struct
PageSelector
(
pub
AtomIdent
)
;
impl
PageSelector
{
#
[
inline
]
pub
fn
ident_matches
(
&
self
other
:
&
CustomIdent
)
-
>
bool
{
self
.
0
.
0
=
=
other
.
0
}
}
impl
Parse
for
PageSelector
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
s
=
input
.
expect_ident
(
)
?
;
Ok
(
PageSelector
(
AtomIdent
:
:
from
(
&
*
*
s
)
)
)
}
}
impl
ToCss
for
PageSelector
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
(
&
self
.
0
)
.
to_css
(
dest
)
}
}
#
[
derive
(
Clone
Debug
Default
MallocSizeOf
ToCss
ToShmem
)
]
#
[
css
(
comma
)
]
pub
struct
PageSelectors
(
#
[
css
(
iterable
)
]
pub
Box
<
[
PageSelector
]
>
)
;
impl
PageSelectors
{
#
[
inline
]
pub
fn
new
(
s
:
Vec
<
PageSelector
>
)
-
>
Self
{
PageSelectors
(
s
.
into
(
)
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
as_slice
(
)
.
is_empty
(
)
}
#
[
inline
]
pub
fn
as_slice
(
&
self
)
-
>
&
[
PageSelector
]
{
&
*
self
.
0
}
}
impl
Parse
for
PageSelectors
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Ok
(
PageSelectors
:
:
new
(
input
.
parse_comma_separated
(
|
i
|
PageSelector
:
:
parse
(
context
i
)
)
?
)
)
}
}
#
[
derive
(
Clone
Debug
ToShmem
)
]
pub
struct
PageRule
{
pub
selectors
:
PageSelectors
pub
block
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
pub
source_location
:
SourceLocation
}
impl
PageRule
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
size_of
(
&
self
guard
:
&
SharedRwLockReadGuard
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
block
.
unconditional_shallow_size_of
(
ops
)
+
self
.
block
.
read_with
(
guard
)
.
size_of
(
ops
)
+
self
.
selectors
.
size_of
(
ops
)
}
}
impl
ToCssWithGuard
for
PageRule
{
fn
to_css
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
CssStringWriter
)
-
>
fmt
:
:
Result
{
dest
.
write_str
(
"
page
"
)
?
;
if
!
self
.
selectors
.
is_empty
(
)
{
self
.
selectors
.
to_css
(
&
mut
CssWriter
:
:
new
(
dest
)
)
?
;
dest
.
write_char
(
'
'
)
?
;
}
dest
.
write_str
(
"
{
"
)
?
;
let
declaration_block
=
self
.
block
.
read_with
(
guard
)
;
declaration_block
.
to_css
(
dest
)
?
;
if
!
declaration_block
.
declarations
(
)
.
is_empty
(
)
{
dest
.
write_char
(
'
'
)
?
;
}
dest
.
write_char
(
'
}
'
)
}
}
impl
DeepCloneWithLock
for
PageRule
{
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
guard
:
&
SharedRwLockReadGuard
_params
:
&
DeepCloneParams
)
-
>
Self
{
PageRule
{
selectors
:
self
.
selectors
.
clone
(
)
block
:
Arc
:
:
new
(
lock
.
wrap
(
self
.
block
.
read_with
(
&
guard
)
.
clone
(
)
)
)
source_location
:
self
.
source_location
.
clone
(
)
}
}
}
