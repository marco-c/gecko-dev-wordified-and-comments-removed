use
cssparser
:
:
SourceLocation
;
use
properties
:
:
PropertyDeclarationBlock
;
use
selector_parser
:
:
SelectorImpl
;
use
selectors
:
:
SelectorList
;
use
servo_arc
:
:
Arc
;
use
shared_lock
:
:
{
DeepCloneParams
DeepCloneWithLock
Locked
SharedRwLock
SharedRwLockReadGuard
ToCssWithGuard
}
;
use
std
:
:
fmt
;
use
style_traits
:
:
ToCss
;
use
stylesheets
:
:
{
MallocSizeOf
MallocSizeOfFn
MallocSizeOfVec
MallocSizeOfWithGuard
}
;
#
[
derive
(
Debug
)
]
pub
struct
StyleRule
{
pub
selectors
:
SelectorList
<
SelectorImpl
>
pub
block
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
pub
source_location
:
SourceLocation
}
impl
DeepCloneWithLock
for
StyleRule
{
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
guard
:
&
SharedRwLockReadGuard
_params
:
&
DeepCloneParams
)
-
>
StyleRule
{
StyleRule
{
selectors
:
self
.
selectors
.
clone
(
)
block
:
Arc
:
:
new
(
lock
.
wrap
(
self
.
block
.
read_with
(
guard
)
.
clone
(
)
)
)
source_location
:
self
.
source_location
.
clone
(
)
}
}
}
impl
MallocSizeOfWithGuard
for
StyleRule
{
fn
malloc_size_of_children
(
&
self
guard
:
&
SharedRwLockReadGuard
malloc_size_of
:
MallocSizeOfFn
)
-
>
usize
{
let
mut
n
=
0
;
n
+
=
self
.
selectors
.
0
.
malloc_shallow_size_of_vec
(
malloc_size_of
)
;
for
selector
in
self
.
selectors
.
0
.
iter
(
)
{
let
ptr
=
selector
.
thin_arc_heap_ptr
(
)
;
n
+
=
unsafe
{
(
malloc_size_of
.
0
)
(
ptr
)
}
;
}
n
+
=
self
.
block
.
read_with
(
guard
)
.
malloc_size_of_children
(
malloc_size_of
)
;
n
}
}
impl
ToCssWithGuard
for
StyleRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
use
cssparser
:
:
ToCss
;
self
.
selectors
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
{
"
)
?
;
let
declaration_block
=
self
.
block
.
read_with
(
guard
)
;
declaration_block
.
to_css
(
dest
)
?
;
if
!
declaration_block
.
declarations
(
)
.
is_empty
(
)
{
dest
.
write_str
(
"
"
)
?
;
}
dest
.
write_str
(
"
}
"
)
}
}
