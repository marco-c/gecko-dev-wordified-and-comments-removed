use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
ops
:
:
BitOrAssign
;
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
ToShmem
)
]
#
[
repr
(
u8
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
pub
enum
Origin
{
UserAgent
=
1
<
<
0
User
=
1
<
<
1
Author
=
1
<
<
2
}
impl
Origin
{
fn
from_index
(
index
:
i8
)
-
>
Option
<
Self
>
{
Some
(
match
index
{
0
=
>
Origin
:
:
Author
1
=
>
Origin
:
:
User
2
=
>
Origin
:
:
UserAgent
_
=
>
return
None
}
)
}
fn
to_index
(
self
)
-
>
i8
{
match
self
{
Origin
:
:
Author
=
>
0
Origin
:
:
User
=
>
1
Origin
:
:
UserAgent
=
>
2
}
}
#
[
inline
]
pub
fn
following_including
(
self
)
-
>
OriginSetIterator
{
OriginSetIterator
{
set
:
OriginSet
:
:
ORIGIN_USER
|
OriginSet
:
:
ORIGIN_AUTHOR
|
OriginSet
:
:
ORIGIN_USER_AGENT
cur
:
self
.
to_index
(
)
rev
:
true
}
}
}
bitflags
!
{
/
/
/
A
set
of
origins
.
This
is
equivalent
to
Gecko
'
s
OriginFlags
.
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
pub
struct
OriginSet
:
u8
{
/
/
/
<
https
:
/
/
drafts
.
csswg
.
org
/
css
-
cascade
/
#
cascade
-
origin
-
user
-
agent
>
const
ORIGIN_USER_AGENT
=
Origin
:
:
UserAgent
as
u8
;
/
/
/
<
https
:
/
/
drafts
.
csswg
.
org
/
css
-
cascade
/
#
cascade
-
origin
-
user
>
const
ORIGIN_USER
=
Origin
:
:
User
as
u8
;
/
/
/
<
https
:
/
/
drafts
.
csswg
.
org
/
css
-
cascade
/
#
cascade
-
origin
-
author
>
const
ORIGIN_AUTHOR
=
Origin
:
:
Author
as
u8
;
}
}
impl
OriginSet
{
pub
fn
iter
(
&
self
)
-
>
OriginSetIterator
{
OriginSetIterator
{
set
:
*
self
cur
:
0
rev
:
false
}
}
}
impl
From
<
Origin
>
for
OriginSet
{
fn
from
(
origin
:
Origin
)
-
>
Self
{
Self
:
:
from_bits_truncate
(
origin
as
u8
)
}
}
impl
BitOrAssign
<
Origin
>
for
OriginSet
{
fn
bitor_assign
(
&
mut
self
origin
:
Origin
)
{
*
self
|
=
OriginSet
:
:
from
(
origin
)
;
}
}
#
[
derive
(
Clone
)
]
pub
struct
OriginSetIterator
{
set
:
OriginSet
cur
:
i8
rev
:
bool
}
impl
Iterator
for
OriginSetIterator
{
type
Item
=
Origin
;
fn
next
(
&
mut
self
)
-
>
Option
<
Origin
>
{
loop
{
let
origin
=
Origin
:
:
from_index
(
self
.
cur
)
?
;
if
self
.
rev
{
self
.
cur
-
=
1
;
}
else
{
self
.
cur
+
=
1
;
}
if
self
.
set
.
contains
(
origin
.
into
(
)
)
{
return
Some
(
origin
)
;
}
}
}
}
#
[
derive
(
Debug
Default
MallocSizeOf
)
]
pub
struct
PerOrigin
<
T
>
{
pub
user_agent
:
T
pub
user
:
T
pub
author
:
T
}
impl
<
T
>
PerOrigin
<
T
>
{
#
[
inline
]
pub
fn
borrow_for_origin
(
&
self
origin
:
&
Origin
)
-
>
&
T
{
match
*
origin
{
Origin
:
:
UserAgent
=
>
&
self
.
user_agent
Origin
:
:
User
=
>
&
self
.
user
Origin
:
:
Author
=
>
&
self
.
author
}
}
#
[
inline
]
pub
fn
borrow_mut_for_origin
(
&
mut
self
origin
:
&
Origin
)
-
>
&
mut
T
{
match
*
origin
{
Origin
:
:
UserAgent
=
>
&
mut
self
.
user_agent
Origin
:
:
User
=
>
&
mut
self
.
user
Origin
:
:
Author
=
>
&
mut
self
.
author
}
}
pub
fn
iter_origins
(
&
self
)
-
>
PerOriginIter
<
T
>
{
PerOriginIter
{
data
:
&
self
cur
:
0
rev
:
false
}
}
pub
fn
iter_origins_rev
(
&
self
)
-
>
PerOriginIter
<
T
>
{
PerOriginIter
{
data
:
&
self
cur
:
2
rev
:
true
}
}
pub
fn
iter_mut_origins
(
&
mut
self
)
-
>
PerOriginIterMut
<
T
>
{
PerOriginIterMut
{
data
:
self
cur
:
0
_marker
:
PhantomData
}
}
}
pub
struct
PerOriginIter
<
'
a
T
:
'
a
>
{
data
:
&
'
a
PerOrigin
<
T
>
cur
:
i8
rev
:
bool
}
impl
<
'
a
T
>
Iterator
for
PerOriginIter
<
'
a
T
>
where
T
:
'
a
{
type
Item
=
(
&
'
a
T
Origin
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
origin
=
Origin
:
:
from_index
(
self
.
cur
)
?
;
self
.
cur
+
=
if
self
.
rev
{
-
1
}
else
{
1
}
;
Some
(
(
self
.
data
.
borrow_for_origin
(
&
origin
)
origin
)
)
}
}
pub
struct
PerOriginIterMut
<
'
a
T
:
'
a
>
{
data
:
*
mut
PerOrigin
<
T
>
cur
:
i8
_marker
:
PhantomData
<
&
'
a
mut
PerOrigin
<
T
>
>
}
impl
<
'
a
T
>
Iterator
for
PerOriginIterMut
<
'
a
T
>
where
T
:
'
a
{
type
Item
=
(
&
'
a
mut
T
Origin
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
origin
=
Origin
:
:
from_index
(
self
.
cur
)
?
;
self
.
cur
+
=
1
;
Some
(
(
unsafe
{
(
*
self
.
data
)
.
borrow_mut_for_origin
(
&
origin
)
}
origin
)
)
}
}
