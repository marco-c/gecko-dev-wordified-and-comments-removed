use
std
:
:
marker
:
:
PhantomData
;
#
[
derive
(
Clone
PartialEq
Eq
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
Origin
{
UserAgent
User
Author
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Debug
Default
)
]
pub
struct
PerOrigin
<
T
>
{
pub
user_agent
:
T
pub
user
:
T
pub
author
:
T
}
impl
<
T
>
PerOrigin
<
T
>
{
#
[
inline
]
pub
fn
borrow_for_origin
(
&
self
origin
:
&
Origin
)
-
>
&
T
{
match
*
origin
{
Origin
:
:
UserAgent
=
>
&
self
.
user_agent
Origin
:
:
User
=
>
&
self
.
user
Origin
:
:
Author
=
>
&
self
.
author
}
}
#
[
inline
]
pub
fn
borrow_mut_for_origin
(
&
mut
self
origin
:
&
Origin
)
-
>
&
mut
T
{
match
*
origin
{
Origin
:
:
UserAgent
=
>
&
mut
self
.
user_agent
Origin
:
:
User
=
>
&
mut
self
.
user
Origin
:
:
Author
=
>
&
mut
self
.
author
}
}
pub
fn
iter_origins
(
&
self
)
-
>
PerOriginIter
<
T
>
{
PerOriginIter
{
data
:
&
self
cur
:
0
}
}
pub
fn
iter_mut_origins
(
&
mut
self
)
-
>
PerOriginIterMut
<
T
>
{
PerOriginIterMut
{
data
:
self
cur
:
0
_marker
:
PhantomData
}
}
}
pub
trait
PerOriginClear
{
fn
clear
(
&
mut
self
)
;
}
impl
<
T
>
PerOriginClear
for
PerOrigin
<
T
>
where
T
:
PerOriginClear
{
fn
clear
(
&
mut
self
)
{
self
.
user_agent
.
clear
(
)
;
self
.
user
.
clear
(
)
;
self
.
author
.
clear
(
)
;
}
}
pub
struct
PerOriginIter
<
'
a
T
:
'
a
>
{
data
:
&
'
a
PerOrigin
<
T
>
cur
:
usize
}
impl
<
'
a
T
>
Iterator
for
PerOriginIter
<
'
a
T
>
where
T
:
'
a
{
type
Item
=
(
&
'
a
T
Origin
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
result
=
match
self
.
cur
{
0
=
>
(
&
self
.
data
.
author
Origin
:
:
Author
)
1
=
>
(
&
self
.
data
.
user
Origin
:
:
User
)
2
=
>
(
&
self
.
data
.
user_agent
Origin
:
:
UserAgent
)
_
=
>
return
None
}
;
self
.
cur
+
=
1
;
Some
(
result
)
}
}
pub
struct
PerOriginIterMut
<
'
a
T
:
'
a
>
{
data
:
*
mut
PerOrigin
<
T
>
cur
:
usize
_marker
:
PhantomData
<
&
'
a
mut
PerOrigin
<
T
>
>
}
impl
<
'
a
T
>
Iterator
for
PerOriginIterMut
<
'
a
T
>
where
T
:
'
a
{
type
Item
=
(
&
'
a
mut
T
Origin
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
result
=
match
self
.
cur
{
0
=
>
(
unsafe
{
&
mut
(
*
self
.
data
)
.
author
}
Origin
:
:
Author
)
1
=
>
(
unsafe
{
&
mut
(
*
self
.
data
)
.
user
}
Origin
:
:
User
)
2
=
>
(
unsafe
{
&
mut
(
*
self
.
data
)
.
user_agent
}
Origin
:
:
UserAgent
)
_
=
>
return
None
}
;
self
.
cur
+
=
1
;
Some
(
result
)
}
}
