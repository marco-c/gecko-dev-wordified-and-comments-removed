use
crate
:
:
applicable_declarations
:
:
ScopeProximity
;
use
crate
:
:
dom
:
:
TElement
;
use
crate
:
:
parser
:
:
ParserContext
;
use
crate
:
:
selector_parser
:
:
{
SelectorImpl
SelectorParser
}
;
use
crate
:
:
shared_lock
:
:
{
DeepCloneParams
DeepCloneWithLock
Locked
SharedRwLock
SharedRwLockReadGuard
ToCssWithGuard
}
;
use
crate
:
:
str
:
:
CssStringWriter
;
use
crate
:
:
stylesheets
:
:
CssRules
;
use
crate
:
:
simple_buckets_map
:
:
SimpleBucketsMap
;
use
cssparser
:
:
{
Parser
SourceLocation
ToCss
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
malloc_size_of
:
:
{
MallocSizeOfOps
MallocUnconditionalShallowSizeOf
MallocUnconditionalSizeOf
}
;
use
selectors
:
:
context
:
:
{
MatchingContext
QuirksMode
}
;
use
selectors
:
:
matching
:
:
matches_selector
;
use
selectors
:
:
parser
:
:
{
Component
ParseRelative
Selector
SelectorList
}
;
use
selectors
:
:
OpaqueElement
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
CssWriter
;
#
[
derive
(
Debug
ToShmem
)
]
pub
struct
ScopeRule
{
pub
bounds
:
ScopeBounds
pub
rules
:
Arc
<
Locked
<
CssRules
>
>
pub
source_location
:
SourceLocation
}
impl
DeepCloneWithLock
for
ScopeRule
{
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
guard
:
&
SharedRwLockReadGuard
params
:
&
DeepCloneParams
)
-
>
Self
{
let
rules
=
self
.
rules
.
read_with
(
guard
)
;
Self
{
bounds
:
self
.
bounds
.
clone
(
)
rules
:
Arc
:
:
new
(
lock
.
wrap
(
rules
.
deep_clone_with_lock
(
lock
guard
params
)
)
)
source_location
:
self
.
source_location
.
clone
(
)
}
}
}
impl
ToCssWithGuard
for
ScopeRule
{
fn
to_css
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
CssStringWriter
)
-
>
fmt
:
:
Result
{
dest
.
write_str
(
"
scope
"
)
?
;
{
let
mut
writer
=
CssWriter
:
:
new
(
dest
)
;
if
let
Some
(
start
)
=
self
.
bounds
.
start
.
as_ref
(
)
{
writer
.
write_str
(
"
(
"
)
?
;
start
.
to_css
(
&
mut
writer
)
?
;
writer
.
write_char
(
'
)
'
)
?
;
}
if
let
Some
(
end
)
=
self
.
bounds
.
end
.
as_ref
(
)
{
writer
.
write_str
(
"
to
(
"
)
?
;
end
.
to_css
(
&
mut
writer
)
?
;
writer
.
write_char
(
'
)
'
)
?
;
}
}
self
.
rules
.
read_with
(
guard
)
.
to_css_block
(
guard
dest
)
}
}
impl
ScopeRule
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
size_of
(
&
self
guard
:
&
SharedRwLockReadGuard
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
rules
.
unconditional_shallow_size_of
(
ops
)
+
self
.
rules
.
read_with
(
guard
)
.
size_of
(
guard
ops
)
+
self
.
bounds
.
size_of
(
ops
)
}
}
#
[
derive
(
Debug
Clone
ToShmem
)
]
pub
struct
ScopeBounds
{
pub
start
:
Option
<
SelectorList
<
SelectorImpl
>
>
pub
end
:
Option
<
SelectorList
<
SelectorImpl
>
>
}
impl
ScopeBounds
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
fn
bound_size_of
(
bound
:
&
Option
<
SelectorList
<
SelectorImpl
>
>
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
bound
.
as_ref
(
)
.
map
(
|
list
|
list
.
unconditional_size_of
(
ops
)
)
.
unwrap_or
(
0
)
}
bound_size_of
(
&
self
.
start
ops
)
+
bound_size_of
(
&
self
.
end
ops
)
}
}
fn
parse_scope
<
'
a
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
a
'
_
>
in_style_rule
:
bool
for_end
:
bool
)
-
>
Option
<
SelectorList
<
SelectorImpl
>
>
{
input
.
try_parse
(
|
input
|
{
if
for_end
{
input
.
expect_ident_matching
(
"
to
"
)
?
;
}
input
.
expect_parenthesis_block
(
)
?
;
input
.
parse_nested_block
(
|
input
|
{
if
input
.
is_exhausted
(
)
{
return
Ok
(
None
)
;
}
let
selector_parser
=
SelectorParser
{
stylesheet_origin
:
context
.
stylesheet_origin
namespaces
:
&
context
.
namespaces
url_data
:
context
.
url_data
for_supports_rule
:
false
}
;
let
parse_relative
=
if
for_end
{
ParseRelative
:
:
ForScope
}
else
if
in_style_rule
{
ParseRelative
:
:
ForNesting
}
else
{
ParseRelative
:
:
No
}
;
Ok
(
Some
(
SelectorList
:
:
parse_forgiving
(
&
selector_parser
input
parse_relative
)
?
)
)
}
)
}
)
.
ok
(
)
.
flatten
(
)
}
impl
ScopeBounds
{
pub
fn
parse
<
'
a
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
a
'
_
>
in_style_rule
:
bool
)
-
>
Self
{
let
start
=
parse_scope
(
context
input
in_style_rule
false
)
;
let
end
=
parse_scope
(
context
input
in_style_rule
true
)
;
Self
{
start
end
}
}
}
#
[
derive
(
Debug
Clone
MallocSizeOf
)
]
pub
enum
ImplicitScopeRoot
{
InLightTree
(
OpaqueElement
)
InShadowTree
(
OpaqueElement
)
ShadowHost
(
OpaqueElement
)
Constructed
}
impl
ImplicitScopeRoot
{
pub
fn
matches_shadow_host
(
&
self
)
-
>
bool
{
match
self
{
Self
:
:
InLightTree
(
.
.
)
|
Self
:
:
InShadowTree
(
.
.
)
=
>
false
Self
:
:
ShadowHost
(
.
.
)
|
Self
:
:
Constructed
=
>
true
}
}
pub
fn
element
(
&
self
current_host
:
Option
<
OpaqueElement
>
)
-
>
Option
<
OpaqueElement
>
{
match
self
{
Self
:
:
InLightTree
(
e
)
|
Self
:
:
InShadowTree
(
e
)
|
Self
:
:
ShadowHost
(
e
)
=
>
Some
(
*
e
)
Self
:
:
Constructed
=
>
current_host
}
}
}
pub
enum
ScopeTarget
<
'
a
>
{
Selector
(
&
'
a
SelectorList
<
SelectorImpl
>
)
Element
(
OpaqueElement
)
}
impl
<
'
a
>
ScopeTarget
<
'
a
>
{
fn
check
<
E
:
TElement
>
(
&
self
element
:
E
scope
:
Option
<
OpaqueElement
>
scope_subject_map
:
&
ScopeSubjectMap
context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
)
-
>
bool
{
match
self
{
Self
:
:
Selector
(
list
)
=
>
{
context
.
nest_for_scope_condition
(
scope
|
context
|
{
if
scope_subject_map
.
early_reject
(
element
context
.
quirks_mode
(
)
)
{
return
false
;
}
for
selector
in
list
.
slice
(
)
.
iter
(
)
{
if
matches_selector
(
selector
0
None
&
element
context
)
{
return
true
;
}
}
false
}
)
}
Self
:
:
Element
(
e
)
=
>
element
.
opaque
(
)
=
=
*
e
}
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
ScopeRootCandidate
{
pub
root
:
OpaqueElement
pub
proximity
:
ScopeProximity
}
pub
fn
collect_scope_roots
<
E
>
(
element
:
E
ceiling
:
Option
<
OpaqueElement
>
context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
target
:
&
ScopeTarget
matches_shadow_host
:
bool
scope_subject_map
:
&
ScopeSubjectMap
)
-
>
Vec
<
ScopeRootCandidate
>
where
E
:
TElement
{
let
mut
result
=
vec
!
[
]
;
let
mut
parent
=
Some
(
element
)
;
let
mut
proximity
=
0usize
;
while
let
Some
(
p
)
=
parent
{
if
ceiling
=
=
Some
(
p
.
opaque
(
)
)
{
break
;
}
if
target
.
check
(
p
ceiling
scope_subject_map
context
)
{
result
.
push
(
ScopeRootCandidate
{
root
:
p
.
opaque
(
)
proximity
:
ScopeProximity
:
:
new
(
proximity
)
}
)
;
}
parent
=
p
.
parent_element
(
)
;
proximity
+
=
1
;
if
parent
.
is_none
(
)
&
&
matches_shadow_host
{
parent
=
p
.
containing_shadow_host
(
)
;
}
}
result
}
pub
fn
element_is_outside_of_scope
<
E
>
(
selector
:
&
Selector
<
E
:
:
Impl
>
element
:
E
root
:
OpaqueElement
context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
root_may_be_shadow_host
:
bool
)
-
>
bool
where
E
:
TElement
{
let
mut
parent
=
Some
(
element
)
;
context
.
nest_for_scope_condition
(
Some
(
root
)
|
context
|
{
while
let
Some
(
p
)
=
parent
{
if
matches_selector
(
selector
0
None
&
p
context
)
{
return
true
;
}
if
p
.
opaque
(
)
=
=
root
{
break
;
}
parent
=
p
.
parent_element
(
)
;
if
parent
.
is_none
(
)
&
&
root_may_be_shadow_host
{
if
let
Some
(
host
)
=
p
.
containing_shadow_host
(
)
{
return
host
.
opaque
(
)
=
=
root
;
}
}
}
return
false
;
}
)
}
#
[
derive
(
Clone
Debug
Default
MallocSizeOf
)
]
pub
struct
ScopeSubjectMap
{
buckets
:
SimpleBucketsMap
<
(
)
>
any
:
bool
}
impl
ScopeSubjectMap
{
pub
fn
add_bound_start
(
&
mut
self
selectors
:
&
SelectorList
<
SelectorImpl
>
quirks_mode
:
QuirksMode
)
{
if
self
.
add_selector_list
(
selectors
quirks_mode
)
{
self
.
any
=
true
;
}
}
fn
add_selector_list
(
&
mut
self
selectors
:
&
SelectorList
<
SelectorImpl
>
quirks_mode
:
QuirksMode
)
-
>
bool
{
let
mut
is_any
=
false
;
for
selector
in
selectors
.
slice
(
)
.
iter
(
)
{
is_any
=
is_any
|
|
self
.
add_selector
(
selector
quirks_mode
)
;
}
is_any
}
fn
add_selector
(
&
mut
self
selector
:
&
Selector
<
SelectorImpl
>
quirks_mode
:
QuirksMode
)
-
>
bool
{
let
mut
is_any
=
true
;
let
mut
iter
=
selector
.
iter
(
)
;
while
let
Some
(
c
)
=
iter
.
next
(
)
{
let
component_any
=
match
c
{
Component
:
:
Class
(
cls
)
=
>
{
match
self
.
buckets
.
classes
.
try_entry
(
cls
.
0
.
clone
(
)
quirks_mode
)
{
Ok
(
e
)
=
>
{
e
.
or_insert
(
(
)
)
;
false
}
Err
(
_
)
=
>
true
}
}
Component
:
:
ID
(
id
)
=
>
{
match
self
.
buckets
.
ids
.
try_entry
(
id
.
0
.
clone
(
)
quirks_mode
)
{
Ok
(
e
)
=
>
{
e
.
or_insert
(
(
)
)
;
false
}
Err
(
_
)
=
>
true
}
}
Component
:
:
LocalName
(
local_name
)
=
>
{
self
.
buckets
.
local_names
.
insert
(
local_name
.
lower_name
.
clone
(
)
(
)
)
;
false
}
Component
:
:
Is
(
ref
list
)
|
Component
:
:
Where
(
ref
list
)
=
>
{
self
.
add_selector_list
(
list
quirks_mode
)
}
_
=
>
true
}
;
is_any
=
is_any
&
&
component_any
;
}
is_any
}
pub
fn
shrink_if_needed
(
&
mut
self
)
{
self
.
buckets
.
shrink_if_needed
(
)
;
}
pub
fn
clear
(
&
mut
self
)
{
self
.
buckets
.
clear
(
)
;
self
.
any
=
false
;
}
fn
early_reject
<
E
:
TElement
>
(
&
self
element
:
E
quirks_mode
:
QuirksMode
)
-
>
bool
{
if
self
.
any
{
return
false
;
}
if
let
Some
(
id
)
=
element
.
id
(
)
{
if
self
.
buckets
.
ids
.
get
(
id
quirks_mode
)
.
is_some
(
)
{
return
false
;
}
}
let
mut
found
=
false
;
element
.
each_class
(
|
cls
|
{
if
self
.
buckets
.
classes
.
get
(
cls
quirks_mode
)
.
is_some
(
)
{
found
=
true
;
}
}
)
;
if
found
{
return
false
;
}
if
self
.
buckets
.
local_names
.
get
(
element
.
local_name
(
)
)
.
is_some
(
)
{
return
false
;
}
true
}
}
