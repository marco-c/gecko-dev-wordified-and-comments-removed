use
crate
:
:
media_queries
:
:
MediaList
;
use
crate
:
:
shared_lock
:
:
{
DeepCloneParams
DeepCloneWithLock
}
;
use
crate
:
:
shared_lock
:
:
{
SharedRwLock
SharedRwLockReadGuard
ToCssWithGuard
}
;
use
crate
:
:
str
:
:
CssStringWriter
;
use
crate
:
:
stylesheets
:
:
supports_rule
:
:
SupportsCondition
;
use
crate
:
:
stylesheets
:
:
layer_rule
:
:
LayerName
;
use
crate
:
:
stylesheets
:
:
{
CssRule
StylesheetInDocument
}
;
use
crate
:
:
values
:
:
CssUrl
;
use
cssparser
:
:
SourceLocation
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
use
to_shmem
:
:
{
self
SharedMemoryBuilder
ToShmem
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
derive
(
Debug
)
]
pub
enum
ImportSheet
{
Sheet
(
crate
:
:
gecko
:
:
data
:
:
GeckoStyleSheet
)
Pending
Refused
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ImportSheet
{
pub
fn
new
(
sheet
:
crate
:
:
gecko
:
:
data
:
:
GeckoStyleSheet
)
-
>
Self
{
ImportSheet
:
:
Sheet
(
sheet
)
}
pub
fn
new_pending
(
)
-
>
Self
{
ImportSheet
:
:
Pending
}
pub
fn
new_refused
(
)
-
>
Self
{
ImportSheet
:
:
Refused
}
pub
fn
as_sheet
(
&
self
)
-
>
Option
<
&
crate
:
:
gecko
:
:
data
:
:
GeckoStyleSheet
>
{
match
*
self
{
ImportSheet
:
:
Sheet
(
ref
s
)
=
>
{
debug_assert
!
(
!
s
.
hack_is_null
(
)
)
;
if
s
.
hack_is_null
(
)
{
return
None
;
}
Some
(
s
)
}
ImportSheet
:
:
Refused
|
ImportSheet
:
:
Pending
=
>
None
}
}
pub
fn
media
<
'
a
>
(
&
'
a
self
guard
:
&
'
a
SharedRwLockReadGuard
)
-
>
Option
<
&
'
a
MediaList
>
{
self
.
as_sheet
(
)
.
and_then
(
|
s
|
s
.
media
(
guard
)
)
}
pub
fn
rules
<
'
a
>
(
&
'
a
self
guard
:
&
'
a
SharedRwLockReadGuard
)
-
>
&
'
a
[
CssRule
]
{
match
self
.
as_sheet
(
)
{
Some
(
s
)
=
>
s
.
rules
(
guard
)
None
=
>
&
[
]
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
DeepCloneWithLock
for
ImportSheet
{
fn
deep_clone_with_lock
(
&
self
_lock
:
&
SharedRwLock
_guard
:
&
SharedRwLockReadGuard
params
:
&
DeepCloneParams
)
-
>
Self
{
use
crate
:
:
gecko
:
:
data
:
:
GeckoStyleSheet
;
use
crate
:
:
gecko_bindings
:
:
bindings
;
match
*
self
{
ImportSheet
:
:
Sheet
(
ref
s
)
=
>
{
let
clone
=
unsafe
{
bindings
:
:
Gecko_StyleSheet_Clone
(
s
.
raw
(
)
as
*
const
_
params
.
reference_sheet
)
}
;
ImportSheet
:
:
Sheet
(
unsafe
{
GeckoStyleSheet
:
:
from_addrefed
(
clone
)
}
)
}
ImportSheet
:
:
Pending
=
>
ImportSheet
:
:
Pending
ImportSheet
:
:
Refused
=
>
ImportSheet
:
:
Refused
}
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
#
[
derive
(
Debug
)
]
pub
struct
ImportSheet
(
pub
:
:
servo_arc
:
:
Arc
<
crate
:
:
stylesheets
:
:
Stylesheet
>
)
;
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
ImportSheet
{
pub
fn
media
<
'
a
>
(
&
'
a
self
guard
:
&
'
a
SharedRwLockReadGuard
)
-
>
Option
<
&
'
a
MediaList
>
{
self
.
0
.
media
(
guard
)
}
pub
fn
rules
<
'
a
>
(
&
'
a
self
guard
:
&
'
a
SharedRwLockReadGuard
)
-
>
&
'
a
[
CssRule
]
{
self
.
0
.
rules
(
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
DeepCloneWithLock
for
ImportSheet
{
fn
deep_clone_with_lock
(
&
self
_lock
:
&
SharedRwLock
_guard
:
&
SharedRwLockReadGuard
_params
:
&
DeepCloneParams
)
-
>
Self
{
use
servo_arc
:
:
Arc
;
ImportSheet
(
Arc
:
:
new
(
(
&
*
self
.
0
)
.
clone
(
)
)
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ImportLayer
{
pub
name
:
Option
<
LayerName
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ImportSupportsCondition
{
pub
condition
:
SupportsCondition
pub
enabled
:
bool
}
impl
ToCss
for
ImportLayer
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
self
.
name
{
None
=
>
dest
.
write_str
(
"
layer
"
)
Some
(
ref
name
)
=
>
{
dest
.
write_str
(
"
layer
(
"
)
?
;
name
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
)
'
)
}
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
ImportRule
{
pub
url
:
CssUrl
pub
stylesheet
:
ImportSheet
pub
supports
:
Option
<
ImportSupportsCondition
>
pub
layer
:
Option
<
ImportLayer
>
pub
source_location
:
SourceLocation
}
impl
ToShmem
for
ImportRule
{
fn
to_shmem
(
&
self
_builder
:
&
mut
SharedMemoryBuilder
)
-
>
to_shmem
:
:
Result
<
Self
>
{
Err
(
String
:
:
from
(
"
ToShmem
failed
for
ImportRule
:
cannot
handle
imported
style
sheets
"
)
)
}
}
impl
DeepCloneWithLock
for
ImportRule
{
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
guard
:
&
SharedRwLockReadGuard
params
:
&
DeepCloneParams
)
-
>
Self
{
ImportRule
{
url
:
self
.
url
.
clone
(
)
stylesheet
:
self
.
stylesheet
.
deep_clone_with_lock
(
lock
guard
params
)
supports
:
self
.
supports
.
clone
(
)
layer
:
self
.
layer
.
clone
(
)
source_location
:
self
.
source_location
.
clone
(
)
}
}
}
impl
ToCssWithGuard
for
ImportRule
{
fn
to_css
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
CssStringWriter
)
-
>
fmt
:
:
Result
{
dest
.
write_str
(
"
import
"
)
?
;
self
.
url
.
to_css
(
&
mut
CssWriter
:
:
new
(
dest
)
)
?
;
if
let
Some
(
ref
layer
)
=
self
.
layer
{
dest
.
write_char
(
'
'
)
?
;
layer
.
to_css
(
&
mut
CssWriter
:
:
new
(
dest
)
)
?
;
}
if
let
Some
(
ref
supports
)
=
self
.
supports
{
dest
.
write_str
(
"
supports
(
"
)
?
;
supports
.
condition
.
to_css
(
&
mut
CssWriter
:
:
new
(
dest
)
)
?
;
dest
.
write_char
(
'
)
'
)
?
;
}
if
let
Some
(
media
)
=
self
.
stylesheet
.
media
(
guard
)
{
if
!
media
.
is_empty
(
)
{
dest
.
write_char
(
'
'
)
?
;
media
.
to_css
(
&
mut
CssWriter
:
:
new
(
dest
)
)
?
;
}
}
dest
.
write_char
(
'
;
'
)
}
}
