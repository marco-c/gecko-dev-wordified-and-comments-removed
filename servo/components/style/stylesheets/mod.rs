mod
counter_style_rule
;
mod
document_rule
;
mod
font_face_rule
;
pub
mod
font_feature_values_rule
;
pub
mod
import_rule
;
pub
mod
keyframes_rule
;
mod
loader
;
mod
media_rule
;
mod
namespace_rule
;
pub
mod
origin
;
mod
page_rule
;
mod
rule_list
;
mod
rule_parser
;
mod
rules_iterator
;
mod
style_rule
;
mod
stylesheet
;
pub
mod
supports_rule
;
pub
mod
viewport_rule
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
gecko_bindings
:
:
sugar
:
:
refptr
:
:
RefCounted
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
gecko_bindings
:
:
{
bindings
structs
}
;
use
crate
:
:
parser
:
:
ParserContext
;
use
crate
:
:
shared_lock
:
:
{
DeepCloneParams
DeepCloneWithLock
Locked
}
;
use
crate
:
:
shared_lock
:
:
{
SharedRwLock
SharedRwLockReadGuard
ToCssWithGuard
}
;
use
crate
:
:
str
:
:
CssStringWriter
;
use
cssparser
:
:
{
parse_one_rule
Parser
ParserInput
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
malloc_size_of
:
:
{
MallocSizeOfOps
MallocUnconditionalShallowSizeOf
}
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
std
:
:
mem
;
use
style_traits
:
:
ParsingMode
;
pub
use
self
:
:
counter_style_rule
:
:
CounterStyleRule
;
pub
use
self
:
:
document_rule
:
:
DocumentRule
;
pub
use
self
:
:
font_face_rule
:
:
FontFaceRule
;
pub
use
self
:
:
font_feature_values_rule
:
:
FontFeatureValuesRule
;
pub
use
self
:
:
import_rule
:
:
ImportRule
;
pub
use
self
:
:
keyframes_rule
:
:
KeyframesRule
;
pub
use
self
:
:
loader
:
:
StylesheetLoader
;
pub
use
self
:
:
media_rule
:
:
MediaRule
;
pub
use
self
:
:
namespace_rule
:
:
NamespaceRule
;
pub
use
self
:
:
origin
:
:
{
Origin
OriginSet
OriginSetIterator
PerOrigin
PerOriginIter
}
;
pub
use
self
:
:
page_rule
:
:
PageRule
;
pub
use
self
:
:
rule_list
:
:
{
CssRules
CssRulesHelpers
}
;
pub
use
self
:
:
rule_parser
:
:
{
InsertRuleContext
State
TopLevelRuleParser
}
;
pub
use
self
:
:
rules_iterator
:
:
{
AllRules
EffectiveRules
}
;
pub
use
self
:
:
rules_iterator
:
:
{
NestedRuleIterationCondition
RulesIterator
}
;
pub
use
self
:
:
style_rule
:
:
StyleRule
;
pub
use
self
:
:
stylesheet
:
:
{
DocumentStyleSheet
Namespaces
Stylesheet
}
;
pub
use
self
:
:
stylesheet
:
:
{
StylesheetContents
StylesheetInDocument
UserAgentStylesheets
}
;
pub
use
self
:
:
supports_rule
:
:
SupportsRule
;
pub
use
self
:
:
viewport_rule
:
:
ViewportRule
;
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
pub
type
UrlExtraData
=
:
:
servo_url
:
:
ServoUrl
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
derive
(
PartialEq
)
]
pub
struct
UrlExtraData
(
usize
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
Clone
for
UrlExtraData
{
fn
clone
(
&
self
)
-
>
UrlExtraData
{
UrlExtraData
:
:
new
(
self
.
ptr
(
)
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
Drop
for
UrlExtraData
{
fn
drop
(
&
mut
self
)
{
if
self
.
0
&
1
=
=
0
{
unsafe
{
self
.
as_ref
(
)
.
release
(
)
;
}
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
UrlExtraData
{
pub
fn
new
(
ptr
:
*
mut
structs
:
:
URLExtraData
)
-
>
UrlExtraData
{
unsafe
{
(
*
ptr
)
.
addref
(
)
;
}
UrlExtraData
(
ptr
as
usize
)
}
#
[
inline
]
pub
fn
is_chrome
(
&
self
)
-
>
bool
{
self
.
as_ref
(
)
.
mIsChrome
}
#
[
inline
]
pub
unsafe
fn
from_ptr_ref
(
ptr
:
&
*
mut
structs
:
:
URLExtraData
)
-
>
&
Self
{
mem
:
:
transmute
(
ptr
)
}
pub
fn
ptr
(
&
self
)
-
>
*
mut
structs
:
:
URLExtraData
{
if
self
.
0
&
1
=
=
0
{
self
.
0
as
*
mut
structs
:
:
URLExtraData
}
else
{
unsafe
{
let
sheet_id
=
self
.
0
>
>
1
;
structs
:
:
URLExtraData_sShared
[
sheet_id
]
.
mRawPtr
}
}
}
fn
as_ref
(
&
self
)
-
>
&
structs
:
:
URLExtraData
{
unsafe
{
&
*
(
self
.
ptr
(
)
as
*
const
structs
:
:
URLExtraData
)
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
fmt
:
:
Debug
for
UrlExtraData
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
struct
DebugURI
(
*
mut
structs
:
:
nsIURI
)
;
impl
fmt
:
:
Debug
for
DebugURI
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
use
nsstring
:
:
nsCString
;
let
mut
spec
=
nsCString
:
:
new
(
)
;
unsafe
{
bindings
:
:
Gecko_nsIURI_Debug
(
self
.
0
&
mut
spec
)
;
}
spec
.
fmt
(
formatter
)
}
}
formatter
.
debug_struct
(
"
URLExtraData
"
)
.
field
(
"
is_chrome
"
&
self
.
is_chrome
(
)
)
.
field
(
"
base
"
&
DebugURI
(
self
.
as_ref
(
)
.
mBaseURI
.
raw
:
:
<
structs
:
:
nsIURI
>
(
)
)
)
.
field
(
"
referrer
"
&
DebugURI
(
self
.
as_ref
(
)
.
mReferrer
.
raw
:
:
<
structs
:
:
nsIURI
>
(
)
)
)
.
finish
(
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
Eq
for
UrlExtraData
{
}
#
[
derive
(
Clone
Debug
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
CssRule
{
Namespace
(
Arc
<
Locked
<
NamespaceRule
>
>
)
Import
(
Arc
<
Locked
<
ImportRule
>
>
)
Style
(
Arc
<
Locked
<
StyleRule
>
>
)
Media
(
Arc
<
Locked
<
MediaRule
>
>
)
FontFace
(
Arc
<
Locked
<
FontFaceRule
>
>
)
FontFeatureValues
(
Arc
<
Locked
<
FontFeatureValuesRule
>
>
)
CounterStyle
(
Arc
<
Locked
<
CounterStyleRule
>
>
)
Viewport
(
Arc
<
Locked
<
ViewportRule
>
>
)
Keyframes
(
Arc
<
Locked
<
KeyframesRule
>
>
)
Supports
(
Arc
<
Locked
<
SupportsRule
>
>
)
Page
(
Arc
<
Locked
<
PageRule
>
>
)
Document
(
Arc
<
Locked
<
DocumentRule
>
>
)
}
impl
CssRule
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
size_of
(
&
self
guard
:
&
SharedRwLockReadGuard
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
match
*
self
{
CssRule
:
:
Namespace
(
_
)
=
>
0
CssRule
:
:
Import
(
_
)
=
>
0
CssRule
:
:
Style
(
ref
lock
)
=
>
{
lock
.
unconditional_shallow_size_of
(
ops
)
+
lock
.
read_with
(
guard
)
.
size_of
(
guard
ops
)
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
lock
.
unconditional_shallow_size_of
(
ops
)
+
lock
.
read_with
(
guard
)
.
size_of
(
guard
ops
)
}
CssRule
:
:
FontFace
(
_
)
=
>
0
CssRule
:
:
FontFeatureValues
(
_
)
=
>
0
CssRule
:
:
CounterStyle
(
_
)
=
>
0
CssRule
:
:
Viewport
(
_
)
=
>
0
CssRule
:
:
Keyframes
(
_
)
=
>
0
CssRule
:
:
Supports
(
ref
lock
)
=
>
{
lock
.
unconditional_shallow_size_of
(
ops
)
+
lock
.
read_with
(
guard
)
.
size_of
(
guard
ops
)
}
CssRule
:
:
Page
(
ref
lock
)
=
>
{
lock
.
unconditional_shallow_size_of
(
ops
)
+
lock
.
read_with
(
guard
)
.
size_of
(
guard
ops
)
}
CssRule
:
:
Document
(
ref
lock
)
=
>
{
lock
.
unconditional_shallow_size_of
(
ops
)
+
lock
.
read_with
(
guard
)
.
size_of
(
guard
ops
)
}
}
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
CssRuleType
{
Style
=
1
Charset
=
2
Import
=
3
Media
=
4
FontFace
=
5
Page
=
6
Keyframes
=
7
Keyframe
=
8
Margin
=
9
Namespace
=
10
CounterStyle
=
11
Supports
=
12
Document
=
13
FontFeatureValues
=
14
Viewport
=
15
}
#
[
allow
(
missing_docs
)
]
pub
enum
RulesMutateError
{
Syntax
IndexSize
HierarchyRequest
InvalidState
}
impl
CssRule
{
pub
fn
rule_type
(
&
self
)
-
>
CssRuleType
{
match
*
self
{
CssRule
:
:
Style
(
_
)
=
>
CssRuleType
:
:
Style
CssRule
:
:
Import
(
_
)
=
>
CssRuleType
:
:
Import
CssRule
:
:
Media
(
_
)
=
>
CssRuleType
:
:
Media
CssRule
:
:
FontFace
(
_
)
=
>
CssRuleType
:
:
FontFace
CssRule
:
:
FontFeatureValues
(
_
)
=
>
CssRuleType
:
:
FontFeatureValues
CssRule
:
:
CounterStyle
(
_
)
=
>
CssRuleType
:
:
CounterStyle
CssRule
:
:
Keyframes
(
_
)
=
>
CssRuleType
:
:
Keyframes
CssRule
:
:
Namespace
(
_
)
=
>
CssRuleType
:
:
Namespace
CssRule
:
:
Viewport
(
_
)
=
>
CssRuleType
:
:
Viewport
CssRule
:
:
Supports
(
_
)
=
>
CssRuleType
:
:
Supports
CssRule
:
:
Page
(
_
)
=
>
CssRuleType
:
:
Page
CssRule
:
:
Document
(
_
)
=
>
CssRuleType
:
:
Document
}
}
fn
rule_state
(
&
self
)
-
>
State
{
match
*
self
{
CssRule
:
:
Import
(
.
.
)
=
>
State
:
:
Imports
CssRule
:
:
Namespace
(
.
.
)
=
>
State
:
:
Namespaces
_
=
>
State
:
:
Body
}
}
pub
fn
parse
(
css
:
&
str
insert_rule_context
:
InsertRuleContext
parent_stylesheet_contents
:
&
StylesheetContents
shared_lock
:
&
SharedRwLock
state
:
State
loader
:
Option
<
&
StylesheetLoader
>
)
-
>
Result
<
Self
RulesMutateError
>
{
let
url_data
=
parent_stylesheet_contents
.
url_data
.
read
(
)
;
let
context
=
ParserContext
:
:
new
(
parent_stylesheet_contents
.
origin
&
url_data
None
ParsingMode
:
:
DEFAULT
parent_stylesheet_contents
.
quirks_mode
None
None
)
;
let
mut
input
=
ParserInput
:
:
new
(
css
)
;
let
mut
input
=
Parser
:
:
new
(
&
mut
input
)
;
let
mut
guard
=
parent_stylesheet_contents
.
namespaces
.
write
(
)
;
let
mut
rule_parser
=
TopLevelRuleParser
{
context
shared_lock
:
&
shared_lock
loader
state
dom_error
:
None
namespaces
:
&
mut
*
guard
insert_rule_context
:
Some
(
insert_rule_context
)
}
;
parse_one_rule
(
&
mut
input
&
mut
rule_parser
)
.
map_err
(
|
_
|
rule_parser
.
dom_error
.
unwrap_or
(
RulesMutateError
:
:
Syntax
)
)
}
}
impl
DeepCloneWithLock
for
CssRule
{
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
guard
:
&
SharedRwLockReadGuard
params
:
&
DeepCloneParams
)
-
>
CssRule
{
match
*
self
{
CssRule
:
:
Namespace
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
guard
)
;
CssRule
:
:
Namespace
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
clone
(
)
)
)
)
}
CssRule
:
:
Import
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
guard
)
.
deep_clone_with_lock
(
lock
guard
params
)
;
CssRule
:
:
Import
(
Arc
:
:
new
(
lock
.
wrap
(
rule
)
)
)
}
CssRule
:
:
Style
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
guard
)
;
CssRule
:
:
Style
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
deep_clone_with_lock
(
lock
guard
params
)
)
)
)
}
CssRule
:
:
Media
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
guard
)
;
CssRule
:
:
Media
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
deep_clone_with_lock
(
lock
guard
params
)
)
)
)
}
CssRule
:
:
FontFace
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
guard
)
;
CssRule
:
:
FontFace
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
clone
(
)
)
)
)
}
CssRule
:
:
FontFeatureValues
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
guard
)
;
CssRule
:
:
FontFeatureValues
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
clone
(
)
)
)
)
}
CssRule
:
:
CounterStyle
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
guard
)
;
CssRule
:
:
CounterStyle
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
clone
(
)
)
)
)
}
CssRule
:
:
Viewport
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
guard
)
;
CssRule
:
:
Viewport
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
clone
(
)
)
)
)
}
CssRule
:
:
Keyframes
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
guard
)
;
CssRule
:
:
Keyframes
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
deep_clone_with_lock
(
lock
guard
params
)
)
)
)
}
CssRule
:
:
Supports
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
guard
)
;
CssRule
:
:
Supports
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
deep_clone_with_lock
(
lock
guard
params
)
)
)
)
}
CssRule
:
:
Page
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
guard
)
;
CssRule
:
:
Page
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
deep_clone_with_lock
(
lock
guard
params
)
)
)
)
}
CssRule
:
:
Document
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
guard
)
;
CssRule
:
:
Document
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
deep_clone_with_lock
(
lock
guard
params
)
)
)
)
}
}
}
}
impl
ToCssWithGuard
for
CssRule
{
fn
to_css
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
CssStringWriter
)
-
>
fmt
:
:
Result
{
match
*
self
{
CssRule
:
:
Namespace
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Import
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Style
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
FontFace
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
FontFeatureValues
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
CounterStyle
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Viewport
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Keyframes
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Media
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Supports
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Page
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Document
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
}
}
}
