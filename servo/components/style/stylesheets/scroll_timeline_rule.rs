use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
shared_lock
:
:
{
SharedRwLockReadGuard
ToCssWithGuard
}
;
use
crate
:
:
str
:
:
CssStringWriter
;
use
crate
:
:
values
:
:
specified
:
:
{
LengthPercentage
Number
}
;
use
crate
:
:
values
:
:
{
AtomIdent
TimelineName
}
;
use
cssparser
:
:
{
AtRuleParser
CowRcStr
DeclarationParser
Parser
SourceLocation
Token
}
;
use
selectors
:
:
parser
:
:
SelectorParseErrorKind
;
use
std
:
:
fmt
:
:
{
self
Debug
Write
}
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
#
[
derive
(
Clone
Debug
ToShmem
)
]
pub
struct
ScrollTimelineRule
{
pub
name
:
TimelineName
pub
descriptors
:
ScrollTimelineDescriptors
pub
source_location
:
SourceLocation
}
impl
ToCssWithGuard
for
ScrollTimelineRule
{
fn
to_css
(
&
self
_guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
CssStringWriter
)
-
>
fmt
:
:
Result
{
let
mut
dest
=
CssWriter
:
:
new
(
dest
)
;
dest
.
write_str
(
"
scroll
-
timeline
"
)
?
;
self
.
name
.
to_css
(
&
mut
dest
)
?
;
dest
.
write_str
(
"
{
"
)
?
;
self
.
descriptors
.
to_css
(
&
mut
dest
)
?
;
dest
.
write_str
(
"
}
"
)
}
}
#
[
derive
(
Clone
Debug
Default
ToShmem
)
]
pub
struct
ScrollTimelineDescriptors
{
pub
source
:
Option
<
Source
>
pub
orientation
:
Option
<
Orientation
>
pub
offsets
:
Option
<
ScrollOffsets
>
}
impl
Parse
for
ScrollTimelineDescriptors
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
use
crate
:
:
cssparser
:
:
DeclarationListParser
;
use
crate
:
:
error_reporting
:
:
ContextualParseError
;
let
mut
descriptors
=
ScrollTimelineDescriptors
:
:
default
(
)
;
let
parser
=
ScrollTimelineDescriptorsParser
{
context
descriptors
:
&
mut
descriptors
}
;
let
mut
iter
=
DeclarationListParser
:
:
new
(
input
parser
)
;
while
let
Some
(
declaration
)
=
iter
.
next
(
)
{
if
let
Err
(
(
error
slice
)
)
=
declaration
{
let
location
=
error
.
location
;
let
error
=
ContextualParseError
:
:
UnsupportedRule
(
slice
error
)
;
context
.
log_css_error
(
location
error
)
}
}
Ok
(
descriptors
)
}
}
impl
ToCss
for
ScrollTimelineDescriptors
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
let
Some
(
ref
value
)
=
self
.
source
{
dest
.
write_str
(
"
source
:
"
)
?
;
value
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
;
"
)
?
;
}
if
let
Some
(
ref
value
)
=
self
.
orientation
{
dest
.
write_str
(
"
orientation
:
"
)
?
;
value
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
;
"
)
?
;
}
if
let
Some
(
ref
value
)
=
self
.
offsets
{
dest
.
write_str
(
"
scroll
-
offsets
:
"
)
?
;
value
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
;
"
)
?
;
}
Ok
(
(
)
)
}
}
struct
ScrollTimelineDescriptorsParser
<
'
a
'
b
:
'
a
>
{
context
:
&
'
a
ParserContext
<
'
b
>
descriptors
:
&
'
a
mut
ScrollTimelineDescriptors
}
impl
<
'
a
'
b
'
i
>
AtRuleParser
<
'
i
>
for
ScrollTimelineDescriptorsParser
<
'
a
'
b
>
{
type
Prelude
=
(
)
;
type
AtRule
=
(
)
;
type
Error
=
StyleParseErrorKind
<
'
i
>
;
}
impl
<
'
a
'
b
'
i
>
DeclarationParser
<
'
i
>
for
ScrollTimelineDescriptorsParser
<
'
a
'
b
>
{
type
Declaration
=
(
)
;
type
Error
=
StyleParseErrorKind
<
'
i
>
;
fn
parse_value
<
'
t
>
(
&
mut
self
name
:
CowRcStr
<
'
i
>
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
(
)
ParseError
<
'
i
>
>
{
macro_rules
!
parse_descriptor
{
(
(
name
:
tt
/
ident
:
ident
)
*
)
=
>
{
match_ignore_ascii_case
!
{
&
*
name
(
name
=
>
{
let
value
=
input
.
parse_entirely
(
|
i
|
Parse
:
:
parse
(
self
.
context
i
)
)
?
;
self
.
descriptors
.
ident
=
Some
(
value
)
}
)
*
_
=
>
{
return
Err
(
input
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnexpectedIdent
(
name
.
clone
(
)
)
)
)
}
}
}
}
parse_descriptor
!
{
"
source
"
/
source
"
orientation
"
/
orientation
"
scroll
-
offsets
"
/
offsets
}
;
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Debug
Parse
PartialEq
ToCss
ToShmem
)
]
pub
enum
Source
{
Selector
(
ScrollTimelineSelector
)
Auto
None
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
Eq
Parse
PartialEq
PartialOrd
ToCss
ToShmem
)
]
pub
enum
Orientation
{
Auto
Block
Inline
Horizontal
Vertical
}
#
[
derive
(
Clone
Debug
ToCss
ToShmem
)
]
#
[
css
(
comma
)
]
pub
struct
ScrollOffsets
(
#
[
css
(
if_empty
=
"
none
"
iterable
)
]
Box
<
[
ScrollTimelineOffset
]
>
)
;
impl
Parse
for
ScrollOffsets
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
none
"
)
)
.
is_ok
(
)
{
return
Ok
(
ScrollOffsets
(
Box
:
:
new
(
[
]
)
)
)
;
}
Ok
(
ScrollOffsets
(
input
.
parse_comma_separated
(
|
i
|
ScrollTimelineOffset
:
:
parse
(
context
i
)
)
?
.
into_boxed_slice
(
)
)
)
}
}
#
[
derive
(
Clone
Debug
Parse
PartialEq
ToCss
ToShmem
)
]
pub
enum
ScrollTimelineOffset
{
Auto
LengthPercentage
(
LengthPercentage
)
ElementOffset
(
ElementOffset
)
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
Eq
Parse
PartialEq
PartialOrd
ToCss
ToShmem
)
]
pub
enum
ElementOffsetEdge
{
Start
End
}
#
[
derive
(
Clone
Debug
PartialEq
ToCss
ToShmem
)
]
pub
struct
ElementOffset
{
target
:
ScrollTimelineSelector
edge
:
Option
<
ElementOffsetEdge
>
threshold
:
Option
<
Number
>
}
impl
Parse
for
ElementOffset
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
target
=
ScrollTimelineSelector
:
:
parse
(
context
input
)
?
;
let
mut
edge
=
input
.
try_parse
(
ElementOffsetEdge
:
:
parse
)
.
ok
(
)
;
let
threshold
=
input
.
try_parse
(
|
i
|
Number
:
:
parse
(
context
i
)
)
.
ok
(
)
;
if
edge
.
is_none
(
)
{
edge
=
input
.
try_parse
(
ElementOffsetEdge
:
:
parse
)
.
ok
(
)
;
}
Ok
(
ElementOffset
{
target
edge
threshold
}
)
}
}
#
[
derive
(
Clone
Eq
PartialEq
ToShmem
)
]
pub
struct
ScrollTimelineSelector
(
AtomIdent
)
;
impl
Parse
for
ScrollTimelineSelector
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
expect_function_matching
(
"
selector
"
)
?
;
input
.
parse_nested_block
(
|
i
|
match
i
.
next
(
)
?
{
Token
:
:
IDHash
(
id
)
=
>
Ok
(
ScrollTimelineSelector
(
id
.
as_ref
(
)
.
into
(
)
)
)
_
=
>
Err
(
i
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
)
}
}
impl
ToCss
for
ScrollTimelineSelector
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
use
crate
:
:
cssparser
:
:
ToCss
as
CssparserToCss
;
dest
.
write_str
(
"
selector
(
"
)
?
;
dest
.
write_char
(
'
#
'
)
?
;
self
.
0
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
)
'
)
}
}
impl
Debug
for
ScrollTimelineSelector
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
to_css
(
&
mut
CssWriter
:
:
new
(
f
)
)
}
}
