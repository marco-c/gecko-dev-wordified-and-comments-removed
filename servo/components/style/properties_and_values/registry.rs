use
super
:
:
rule
:
:
{
Inherits
InitialValue
PropertyRuleName
}
;
use
super
:
:
syntax
:
:
Descriptor
;
use
crate
:
:
selector_map
:
:
PrecomputedHashMap
;
use
crate
:
:
stylesheets
:
:
UrlExtraData
;
use
crate
:
:
Atom
;
use
cssparser
:
:
SourceLocation
;
#
[
derive
(
Debug
Clone
MallocSizeOf
)
]
pub
struct
PropertyRegistrationData
{
pub
syntax
:
Descriptor
pub
inherits
:
Inherits
#
[
ignore_malloc_size_of
=
"
Arc
"
]
pub
initial_value
:
Option
<
InitialValue
>
}
static
UNREGISTERED
:
PropertyRegistrationData
=
PropertyRegistrationData
{
syntax
:
Descriptor
:
:
universal
(
)
inherits
:
Inherits
:
:
True
initial_value
:
None
}
;
impl
PropertyRegistrationData
{
pub
fn
unregistered
(
)
-
>
&
'
static
Self
{
&
UNREGISTERED
}
#
[
inline
]
pub
fn
inherits
(
&
self
)
-
>
bool
{
self
.
inherits
=
=
Inherits
:
:
True
}
}
#
[
derive
(
Debug
Clone
MallocSizeOf
)
]
pub
struct
PropertyRegistration
{
pub
name
:
PropertyRuleName
pub
data
:
PropertyRegistrationData
pub
url_data
:
UrlExtraData
pub
source_location
:
SourceLocation
}
impl
PropertyRegistration
{
#
[
inline
]
pub
fn
inherits
(
&
self
)
-
>
bool
{
self
.
data
.
inherits
=
=
Inherits
:
:
True
}
}
#
[
derive
(
Default
)
]
pub
struct
ScriptRegistry
{
properties
:
PrecomputedHashMap
<
Atom
PropertyRegistration
>
}
impl
ScriptRegistry
{
#
[
inline
]
pub
fn
get
(
&
self
name
:
&
Atom
)
-
>
Option
<
&
PropertyRegistration
>
{
self
.
properties
.
get
(
name
)
}
#
[
inline
]
pub
fn
properties
(
&
self
)
-
>
&
PrecomputedHashMap
<
Atom
PropertyRegistration
>
{
&
self
.
properties
}
#
[
inline
]
pub
fn
register
(
&
mut
self
registration
:
PropertyRegistration
)
{
let
name
=
registration
.
name
.
0
.
clone
(
)
;
let
old
=
self
.
properties
.
insert
(
name
registration
)
;
debug_assert
!
(
old
.
is_none
(
)
"
Already
registered
?
Should
be
an
error
"
)
;
}
#
[
inline
]
pub
fn
get_all
(
&
self
)
-
>
&
PrecomputedHashMap
<
Atom
PropertyRegistration
>
{
&
self
.
properties
}
}
