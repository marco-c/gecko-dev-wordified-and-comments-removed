use
std
:
:
fmt
:
:
{
self
Write
}
;
use
super
:
:
{
registry
:
:
PropertyRegistration
syntax
:
:
{
data_type
:
:
DataType
Component
as
SyntaxComponent
ComponentName
Descriptor
Multiplier
}
}
;
use
crate
:
:
custom_properties
:
:
ComputedValue
as
ComputedPropertyValue
;
use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
stylesheets
:
:
{
CssRuleType
Origin
UrlExtraData
}
;
use
crate
:
:
values
:
:
{
specified
CustomIdent
}
;
use
cssparser
:
:
{
BasicParseErrorKind
ParseErrorKind
Parser
as
CSSParser
ParserInput
}
;
use
selectors
:
:
matching
:
:
QuirksMode
;
use
servo_arc
:
:
{
Arc
ThinArc
}
;
use
smallvec
:
:
SmallVec
;
use
style_traits
:
:
{
owned_str
:
:
OwnedStr
CssWriter
ParseError
as
StyleParseError
ParsingMode
PropertySyntaxParseError
StyleParseErrorKind
ToCss
}
;
#
[
derive
(
Clone
ToCss
)
]
pub
enum
ValueComponent
{
Length
(
specified
:
:
Length
)
Number
(
specified
:
:
Number
)
Percentage
(
specified
:
:
Percentage
)
LengthPercentage
(
specified
:
:
LengthPercentage
)
Color
(
specified
:
:
Color
)
Image
(
specified
:
:
Image
)
Url
(
specified
:
:
url
:
:
SpecifiedUrl
)
Integer
(
specified
:
:
Integer
)
Angle
(
specified
:
:
Angle
)
Time
(
specified
:
:
Time
)
Resolution
(
specified
:
:
Resolution
)
TransformFunction
(
specified
:
:
Transform
)
CustomIdent
(
CustomIdent
)
TransformList
(
ValueComponentList
)
String
(
OwnedStr
)
}
#
[
derive
(
Clone
)
]
pub
struct
ValueComponentList
(
ThinArc
<
Multiplier
ValueComponent
>
)
;
impl
ToCss
for
ValueComponentList
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
let
mut
iter
=
self
.
0
.
slice
(
)
.
iter
(
)
;
let
Some
(
first
)
=
iter
.
next
(
)
else
{
return
Ok
(
(
)
)
;
}
;
first
.
to_css
(
dest
)
?
;
let
separator
=
match
self
.
0
.
header
{
Multiplier
:
:
Space
=
>
"
"
Multiplier
:
:
Comma
=
>
"
"
}
;
for
component
in
iter
{
dest
.
write_str
(
separator
)
?
;
component
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
impl
ValueComponentList
{
fn
new
<
I
>
(
multiplier
:
Multiplier
values
:
I
)
-
>
Self
where
I
:
Iterator
<
Item
=
ValueComponent
>
+
ExactSizeIterator
{
Self
(
ThinArc
:
:
from_header_and_iter
(
multiplier
values
)
)
}
}
#
[
derive
(
ToCss
)
]
pub
enum
ComputedValue
{
Component
(
ValueComponent
)
Universal
(
Arc
<
ComputedPropertyValue
>
)
List
(
ValueComponentList
)
}
impl
ComputedValue
{
pub
fn
compute
<
'
i
'
t
>
(
input
:
&
mut
CSSParser
<
'
i
'
t
>
registration
:
&
PropertyRegistration
)
-
>
Result
<
Arc
<
ComputedPropertyValue
>
(
)
>
{
let
Ok
(
value
)
=
Self
:
:
parse
(
input
&
registration
.
syntax
&
registration
.
url_data
AllowComputationallyDependent
:
:
Yes
)
else
{
return
Err
(
(
)
)
;
}
;
let
value
=
value
.
to_css_string
(
)
;
let
result
=
{
let
mut
input
=
ParserInput
:
:
new
(
&
value
)
;
let
mut
input
=
CSSParser
:
:
new
(
&
mut
input
)
;
ComputedPropertyValue
:
:
parse
(
&
mut
input
)
}
;
if
let
Ok
(
value
)
=
result
{
Ok
(
value
)
}
else
{
Err
(
(
)
)
}
}
pub
fn
parse
<
'
i
'
t
>
(
mut
input
:
&
mut
CSSParser
<
'
i
'
t
>
syntax
:
&
Descriptor
url_data
:
&
UrlExtraData
allow_computationally_dependent
:
AllowComputationallyDependent
)
-
>
Result
<
Self
StyleParseError
<
'
i
>
>
{
if
syntax
.
is_universal
(
)
{
return
Ok
(
Self
:
:
Universal
(
ComputedPropertyValue
:
:
parse
(
&
mut
input
)
?
)
)
;
}
let
mut
values
=
SmallComponentVec
:
:
new
(
)
;
let
mut
multiplier
=
None
;
{
let
mut
parser
=
Parser
:
:
new
(
syntax
&
mut
values
&
mut
multiplier
)
;
parser
.
parse
(
&
mut
input
url_data
allow_computationally_dependent
)
?
;
}
let
computed_value
=
if
let
Some
(
ref
multiplier
)
=
multiplier
{
Self
:
:
List
(
ValueComponentList
:
:
new
(
*
multiplier
values
.
into_iter
(
)
)
)
}
else
{
Self
:
:
Component
(
values
[
0
]
.
clone
(
)
)
}
;
Ok
(
computed_value
)
}
}
pub
enum
AllowComputationallyDependent
{
No
Yes
}
type
SmallComponentVec
=
SmallVec
<
[
ValueComponent
;
1
]
>
;
struct
Parser
<
'
a
>
{
syntax
:
&
'
a
Descriptor
output
:
&
'
a
mut
SmallComponentVec
output_multiplier
:
&
'
a
mut
Option
<
Multiplier
>
}
impl
<
'
a
>
Parser
<
'
a
>
{
fn
new
(
syntax
:
&
'
a
Descriptor
output
:
&
'
a
mut
SmallComponentVec
output_multiplier
:
&
'
a
mut
Option
<
Multiplier
>
)
-
>
Self
{
Self
{
syntax
output
output_multiplier
}
}
fn
parse
<
'
i
'
t
>
(
&
mut
self
input
:
&
mut
CSSParser
<
'
i
'
t
>
url_data
:
&
UrlExtraData
allow_computationally_dependent
:
AllowComputationallyDependent
)
-
>
Result
<
(
)
StyleParseError
<
'
i
>
>
{
use
self
:
:
AllowComputationallyDependent
:
:
*
;
let
parsing_mode
=
match
allow_computationally_dependent
{
No
=
>
ParsingMode
:
:
DISALLOW_FONT_RELATIVE
Yes
=
>
ParsingMode
:
:
DEFAULT
}
;
let
ref
context
=
ParserContext
:
:
new
(
Origin
:
:
Author
url_data
Some
(
CssRuleType
:
:
Style
)
parsing_mode
QuirksMode
:
:
NoQuirks
Default
:
:
default
(
)
None
None
)
;
for
component
in
self
.
syntax
.
0
.
iter
(
)
{
let
result
=
input
.
try_parse
(
|
input
|
{
input
.
parse_entirely
(
|
input
|
{
Self
:
:
parse_value
(
context
input
&
component
.
unpremultiplied
(
)
)
}
)
}
)
;
let
Ok
(
values
)
=
result
else
{
continue
}
;
self
.
output
.
extend
(
values
)
;
*
self
.
output_multiplier
=
component
.
multiplier
(
)
;
break
;
}
if
self
.
output
.
is_empty
(
)
{
return
Err
(
input
.
new_error
(
BasicParseErrorKind
:
:
EndOfInput
)
)
;
}
Ok
(
(
)
)
}
fn
parse_value
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
CSSParser
<
'
i
'
t
>
component
:
&
SyntaxComponent
)
-
>
Result
<
SmallComponentVec
StyleParseError
<
'
i
>
>
{
let
mut
values
=
SmallComponentVec
:
:
new
(
)
;
values
.
push
(
Self
:
:
parse_component_without_multiplier
(
context
input
component
)
?
)
;
if
let
Some
(
multiplier
)
=
component
.
multiplier
(
)
{
loop
{
let
result
=
Self
:
:
expect_multiplier
(
input
&
multiplier
)
;
if
Self
:
:
expect_multiplier_yielded_eof_error
(
&
result
)
{
break
;
}
result
?
;
values
.
push
(
Self
:
:
parse_component_without_multiplier
(
context
input
component
)
?
)
;
}
}
Ok
(
values
)
}
fn
parse_component_without_multiplier
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
CSSParser
<
'
i
'
t
>
component
:
&
SyntaxComponent
)
-
>
Result
<
ValueComponent
StyleParseError
<
'
i
>
>
{
let
data_type
=
match
component
.
name
(
)
{
ComponentName
:
:
DataType
(
ty
)
=
>
ty
ComponentName
:
:
Ident
(
ref
name
)
=
>
{
let
ident
=
CustomIdent
:
:
parse
(
input
&
[
]
)
?
;
if
ident
!
=
*
name
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
return
Ok
(
ValueComponent
:
:
CustomIdent
(
ident
)
)
;
}
}
;
let
value
=
match
data_type
{
DataType
:
:
Length
=
>
ValueComponent
:
:
Length
(
specified
:
:
Length
:
:
parse
(
context
input
)
?
)
DataType
:
:
Number
=
>
ValueComponent
:
:
Number
(
specified
:
:
Number
:
:
parse
(
context
input
)
?
)
DataType
:
:
Percentage
=
>
{
ValueComponent
:
:
Percentage
(
specified
:
:
Percentage
:
:
parse
(
context
input
)
?
)
}
DataType
:
:
LengthPercentage
=
>
ValueComponent
:
:
LengthPercentage
(
specified
:
:
LengthPercentage
:
:
parse
(
context
input
)
?
)
DataType
:
:
Color
=
>
ValueComponent
:
:
Color
(
specified
:
:
Color
:
:
parse
(
context
input
)
?
)
DataType
:
:
Image
=
>
ValueComponent
:
:
Image
(
specified
:
:
Image
:
:
parse
(
context
input
)
?
)
DataType
:
:
Url
=
>
{
ValueComponent
:
:
Url
(
specified
:
:
url
:
:
SpecifiedUrl
:
:
parse
(
context
input
)
?
)
}
DataType
:
:
Integer
=
>
{
ValueComponent
:
:
Integer
(
specified
:
:
Integer
:
:
parse
(
context
input
)
?
)
}
DataType
:
:
Angle
=
>
ValueComponent
:
:
Angle
(
specified
:
:
Angle
:
:
parse
(
context
input
)
?
)
DataType
:
:
Time
=
>
ValueComponent
:
:
Time
(
specified
:
:
Time
:
:
parse
(
context
input
)
?
)
DataType
:
:
Resolution
=
>
{
ValueComponent
:
:
Resolution
(
specified
:
:
Resolution
:
:
parse
(
context
input
)
?
)
}
DataType
:
:
TransformFunction
=
>
{
ValueComponent
:
:
TransformFunction
(
specified
:
:
Transform
:
:
parse
(
context
input
)
?
)
}
DataType
:
:
CustomIdent
=
>
{
let
name
=
CustomIdent
:
:
parse
(
input
&
[
]
)
?
;
ValueComponent
:
:
CustomIdent
(
name
)
}
DataType
:
:
TransformList
=
>
{
let
mut
values
=
vec
!
[
]
;
let
Some
(
multiplier
)
=
component
.
unpremultiplied
(
)
.
multiplier
(
)
else
{
debug_assert
!
(
false
"
Unpremultiplied
<
transform
-
list
>
had
no
multiplier
?
"
)
;
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
PropertySyntaxField
(
PropertySyntaxParseError
:
:
UnexpectedEOF
)
)
)
;
}
;
debug_assert_matches
!
(
multiplier
Multiplier
:
:
Space
)
;
loop
{
values
.
push
(
ValueComponent
:
:
TransformFunction
(
specified
:
:
Transform
:
:
parse
(
context
input
)
?
)
)
;
let
result
=
Self
:
:
expect_multiplier
(
input
&
multiplier
)
;
if
Self
:
:
expect_multiplier_yielded_eof_error
(
&
result
)
{
break
;
}
result
?
;
}
let
list
=
ValueComponentList
:
:
new
(
multiplier
values
.
into_iter
(
)
)
;
ValueComponent
:
:
TransformList
(
list
)
}
DataType
:
:
String
=
>
{
let
string
=
input
.
expect_string
(
)
?
;
ValueComponent
:
:
String
(
string
.
as_ref
(
)
.
to_owned
(
)
.
into
(
)
)
}
}
;
Ok
(
value
)
}
fn
expect_multiplier_yielded_eof_error
<
'
i
>
(
result
:
&
Result
<
(
)
StyleParseError
<
'
i
>
>
)
-
>
bool
{
matches
!
(
result
Err
(
StyleParseError
{
kind
:
ParseErrorKind
:
:
Basic
(
BasicParseErrorKind
:
:
EndOfInput
)
.
.
}
)
)
}
fn
expect_multiplier
<
'
i
'
t
>
(
input
:
&
mut
CSSParser
<
'
i
'
t
>
multiplier
:
&
Multiplier
)
-
>
Result
<
(
)
StyleParseError
<
'
i
>
>
{
match
multiplier
{
Multiplier
:
:
Space
=
>
{
input
.
expect_whitespace
(
)
?
;
if
input
.
is_exhausted
(
)
{
return
Err
(
input
.
new_error
(
BasicParseErrorKind
:
:
EndOfInput
)
)
;
}
Ok
(
(
)
)
}
Multiplier
:
:
Comma
=
>
Ok
(
input
.
expect_comma
(
)
?
)
}
}
}
