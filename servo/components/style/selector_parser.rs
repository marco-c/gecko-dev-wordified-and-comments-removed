#
!
[
deny
(
missing_docs
)
]
use
cssparser
:
:
{
Parser
as
CssParser
ParserInput
}
;
use
selectors
:
:
parser
:
:
SelectorList
;
use
std
:
:
fmt
:
:
{
self
Debug
Write
}
;
use
style_traits
:
:
{
CssWriter
ParseError
ToCss
}
;
use
stylesheets
:
:
{
Namespaces
Origin
UrlExtraData
}
;
pub
type
AttrValue
=
<
SelectorImpl
as
:
:
selectors
:
:
SelectorImpl
>
:
:
AttrValue
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
use
servo
:
:
selector_parser
:
:
*
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
gecko
:
:
selector_parser
:
:
*
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
use
servo
:
:
selector_parser
:
:
ServoElementSnapshot
as
Snapshot
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
gecko
:
:
snapshot
:
:
GeckoElementSnapshot
as
Snapshot
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
use
servo
:
:
restyle_damage
:
:
ServoRestyleDamage
as
RestyleDamage
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
gecko
:
:
restyle_damage
:
:
GeckoRestyleDamage
as
RestyleDamage
;
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
pub
struct
SelectorParser
<
'
a
>
{
pub
stylesheet_origin
:
Origin
pub
namespaces
:
&
'
a
Namespaces
pub
url_data
:
Option
<
&
'
a
UrlExtraData
>
}
impl
<
'
a
>
SelectorParser
<
'
a
>
{
pub
fn
parse_author_origin_no_namespace
(
input
:
&
str
)
-
>
Result
<
SelectorList
<
SelectorImpl
>
ParseError
>
{
let
namespaces
=
Namespaces
:
:
default
(
)
;
let
parser
=
SelectorParser
{
stylesheet_origin
:
Origin
:
:
Author
namespaces
:
&
namespaces
url_data
:
None
}
;
let
mut
input
=
ParserInput
:
:
new
(
input
)
;
SelectorList
:
:
parse
(
&
parser
&
mut
CssParser
:
:
new
(
&
mut
input
)
)
}
pub
fn
in_user_agent_stylesheet
(
&
self
)
-
>
bool
{
matches
!
(
self
.
stylesheet_origin
Origin
:
:
UserAgent
)
}
pub
fn
chrome_rules_enabled
(
&
self
)
-
>
bool
{
self
.
url_data
.
map_or
(
false
|
d
|
d
.
is_chrome
(
)
)
|
|
self
.
stylesheet_origin
=
=
Origin
:
:
User
}
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
)
]
pub
enum
PseudoElementCascadeType
{
Eager
Lazy
Precomputed
}
#
[
derive
(
MallocSizeOf
)
]
pub
struct
PerPseudoElementMap
<
T
>
{
entries
:
[
Option
<
T
>
;
PSEUDO_COUNT
]
}
impl
<
T
>
Default
for
PerPseudoElementMap
<
T
>
{
fn
default
(
)
-
>
Self
{
Self
{
entries
:
PseudoElement
:
:
pseudo_none_array
(
)
}
}
}
impl
<
T
>
Debug
for
PerPseudoElementMap
<
T
>
where
T
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
[
"
)
?
;
let
mut
first
=
true
;
for
entry
in
self
.
entries
.
iter
(
)
{
if
!
first
{
f
.
write_str
(
"
"
)
?
;
}
first
=
false
;
entry
.
fmt
(
f
)
?
;
}
f
.
write_str
(
"
]
"
)
}
}
impl
<
T
>
PerPseudoElementMap
<
T
>
{
pub
fn
get
(
&
self
pseudo
:
&
PseudoElement
)
-
>
Option
<
&
T
>
{
self
.
entries
[
pseudo
.
index
(
)
]
.
as_ref
(
)
}
pub
fn
clear
(
&
mut
self
)
{
*
self
=
Self
:
:
default
(
)
;
}
pub
fn
set
(
&
mut
self
pseudo
:
&
PseudoElement
value
:
T
)
{
self
.
entries
[
pseudo
.
index
(
)
]
=
Some
(
value
)
;
}
pub
fn
get_or_insert_with
<
F
>
(
&
mut
self
pseudo
:
&
PseudoElement
f
:
F
)
-
>
&
mut
T
where
F
:
FnOnce
(
)
-
>
T
{
let
index
=
pseudo
.
index
(
)
;
if
self
.
entries
[
index
]
.
is_none
(
)
{
self
.
entries
[
index
]
=
Some
(
f
(
)
)
;
}
self
.
entries
[
index
]
.
as_mut
(
)
.
unwrap
(
)
}
pub
fn
iter
(
&
self
)
-
>
:
:
std
:
:
slice
:
:
Iter
<
Option
<
T
>
>
{
self
.
entries
.
iter
(
)
}
}
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
)
]
pub
enum
Direction
{
Ltr
Rtl
Other
(
Box
<
str
>
)
}
impl
Direction
{
pub
fn
parse
<
'
i
'
t
>
(
parser
:
&
mut
CssParser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
ident
=
parser
.
expect_ident
(
)
?
;
Ok
(
match_ignore_ascii_case
!
{
&
ident
"
rtl
"
=
>
Direction
:
:
Rtl
"
ltr
"
=
>
Direction
:
:
Ltr
_
=
>
Direction
:
:
Other
(
Box
:
:
from
(
ident
.
as_ref
(
)
)
)
}
)
}
}
impl
ToCss
for
Direction
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
let
dir_str
=
match
*
self
{
Direction
:
:
Rtl
=
>
"
rtl
"
Direction
:
:
Ltr
=
>
"
ltr
"
Direction
:
:
Other
(
ref
other
)
=
>
other
}
;
dest
.
write_str
(
dir_str
)
}
}
