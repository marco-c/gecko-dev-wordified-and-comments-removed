#
!
[
deny
(
missing_docs
)
]
use
cssparser
:
:
Parser
as
CssParser
;
use
selectors
:
:
Element
;
use
selectors
:
:
parser
:
:
SelectorList
;
use
std
:
:
fmt
:
:
Debug
;
use
stylesheets
:
:
{
Origin
Namespaces
}
;
pub
type
AttrValue
=
<
SelectorImpl
as
:
:
selectors
:
:
SelectorImpl
>
:
:
AttrValue
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
use
servo
:
:
selector_parser
:
:
*
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
gecko
:
:
selector_parser
:
:
*
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
use
servo
:
:
selector_parser
:
:
ServoElementSnapshot
as
Snapshot
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
gecko
:
:
snapshot
:
:
GeckoElementSnapshot
as
Snapshot
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
use
servo
:
:
restyle_damage
:
:
ServoRestyleDamage
as
RestyleDamage
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
gecko
:
:
restyle_damage
:
:
GeckoRestyleDamage
as
RestyleDamage
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
type
PreExistingComputedValues
=
:
:
properties
:
:
ServoComputedValues
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
type
PreExistingComputedValues
=
:
:
gecko_bindings
:
:
structs
:
:
nsStyleContext
;
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
SelectorParser
<
'
a
>
{
pub
stylesheet_origin
:
Origin
pub
namespaces
:
&
'
a
Namespaces
}
impl
<
'
a
>
SelectorParser
<
'
a
>
{
pub
fn
parse_author_origin_no_namespace
(
input
:
&
str
)
-
>
Result
<
SelectorList
<
SelectorImpl
>
(
)
>
{
let
namespaces
=
Namespaces
:
:
default
(
)
;
let
parser
=
SelectorParser
{
stylesheet_origin
:
Origin
:
:
Author
namespaces
:
&
namespaces
}
;
SelectorList
:
:
parse
(
&
parser
&
mut
CssParser
:
:
new
(
input
)
)
}
pub
fn
in_user_agent_stylesheet
(
&
self
)
-
>
bool
{
matches
!
(
self
.
stylesheet_origin
Origin
:
:
UserAgent
)
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
pub
enum
PseudoElementCascadeType
{
Eager
Lazy
Precomputed
}
pub
trait
ElementExt
:
Element
<
Impl
=
SelectorImpl
>
+
Debug
{
fn
is_link
(
&
self
)
-
>
bool
;
fn
matches_user_and_author_rules
(
&
self
)
-
>
bool
;
}
impl
SelectorImpl
{
#
[
inline
]
pub
fn
each_precomputed_pseudo_element
<
F
>
(
mut
fun
:
F
)
where
F
:
FnMut
(
PseudoElement
)
{
Self
:
:
each_pseudo_element
(
|
pseudo
|
{
if
pseudo
.
is_precomputed
(
)
{
fun
(
pseudo
)
}
}
)
}
}
