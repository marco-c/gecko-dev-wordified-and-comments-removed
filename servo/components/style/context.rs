#
[
cfg
(
feature
=
"
servo
"
)
]
use
crate
:
:
animation
:
:
DocumentAnimationSet
;
use
crate
:
:
bloom
:
:
StyleBloom
;
use
crate
:
:
computed_value_flags
:
:
ComputedValueFlags
;
use
crate
:
:
data
:
:
{
EagerPseudoStyles
ElementData
}
;
use
crate
:
:
dom
:
:
{
SendElement
TElement
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
gecko_bindings
:
:
structs
;
use
crate
:
:
parallel
:
:
{
STACK_SAFETY_MARGIN_KB
STYLE_THREAD_STACK_SIZE_KB
}
;
use
crate
:
:
properties
:
:
ComputedValues
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
crate
:
:
properties
:
:
PropertyId
;
use
crate
:
:
rule_cache
:
:
RuleCache
;
use
crate
:
:
rule_tree
:
:
StrongRuleNode
;
use
crate
:
:
selector_parser
:
:
{
SnapshotMap
EAGER_PSEUDO_COUNT
}
;
use
crate
:
:
shared_lock
:
:
StylesheetGuards
;
use
crate
:
:
sharing
:
:
StyleSharingCache
;
use
crate
:
:
stylist
:
:
Stylist
;
use
crate
:
:
thread_state
:
:
{
self
ThreadState
}
;
use
crate
:
:
traversal
:
:
DomTraversal
;
use
crate
:
:
traversal_flags
:
:
TraversalFlags
;
use
app_units
:
:
Au
;
use
euclid
:
:
default
:
:
Size2D
;
use
euclid
:
:
Scale
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
fxhash
:
:
FxHashMap
;
use
selectors
:
:
NthIndexCache
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
servo_arc
:
:
Arc
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
servo_atoms
:
:
Atom
;
use
std
:
:
fmt
;
use
std
:
:
ops
;
use
style_traits
:
:
CSSPixel
;
use
style_traits
:
:
DevicePixel
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
style_traits
:
:
SpeculativePainter
;
use
time
;
pub
use
selectors
:
:
matching
:
:
QuirksMode
;
#
[
derive
(
Clone
)
]
pub
struct
StyleSystemOptions
{
pub
disable_style_sharing_cache
:
bool
pub
dump_style_statistics
:
bool
pub
style_statistics_threshold
:
usize
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
get_env_bool
(
name
:
&
str
)
-
>
bool
{
use
std
:
:
env
;
match
env
:
:
var
(
name
)
{
Ok
(
s
)
=
>
!
s
.
is_empty
(
)
Err
(
_
)
=
>
false
}
}
const
DEFAULT_STATISTICS_THRESHOLD
:
usize
=
50
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
get_env_usize
(
name
:
&
str
)
-
>
Option
<
usize
>
{
use
std
:
:
env
;
env
:
:
var
(
name
)
.
ok
(
)
.
map
(
|
s
|
{
s
.
parse
:
:
<
usize
>
(
)
.
expect
(
"
Couldn
'
t
parse
environmental
variable
as
usize
"
)
}
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
static
DEFAULT_DISABLE_STYLE_SHARING_CACHE
:
std
:
:
sync
:
:
atomic
:
:
AtomicBool
=
std
:
:
sync
:
:
atomic
:
:
AtomicBool
:
:
new
(
false
)
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
static
DEFAULT_DUMP_STYLE_STATISTICS
:
std
:
:
sync
:
:
atomic
:
:
AtomicBool
=
std
:
:
sync
:
:
atomic
:
:
AtomicBool
:
:
new
(
false
)
;
impl
Default
for
StyleSystemOptions
{
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
default
(
)
-
>
Self
{
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
StyleSystemOptions
{
disable_style_sharing_cache
:
DEFAULT_DISABLE_STYLE_SHARING_CACHE
.
load
(
Ordering
:
:
Relaxed
)
dump_style_statistics
:
DEFAULT_DUMP_STYLE_STATISTICS
.
load
(
Ordering
:
:
Relaxed
)
style_statistics_threshold
:
DEFAULT_STATISTICS_THRESHOLD
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
default
(
)
-
>
Self
{
StyleSystemOptions
{
disable_style_sharing_cache
:
get_env_bool
(
"
DISABLE_STYLE_SHARING_CACHE
"
)
dump_style_statistics
:
get_env_bool
(
"
DUMP_STYLE_STATISTICS
"
)
style_statistics_threshold
:
get_env_usize
(
"
STYLE_STATISTICS_THRESHOLD
"
)
.
unwrap_or
(
DEFAULT_STATISTICS_THRESHOLD
)
}
}
}
pub
struct
SharedStyleContext
<
'
a
>
{
pub
stylist
:
&
'
a
Stylist
pub
visited_styles_enabled
:
bool
pub
options
:
StyleSystemOptions
pub
guards
:
StylesheetGuards
<
'
a
>
pub
current_time_for_animations
:
f64
pub
traversal_flags
:
TraversalFlags
pub
snapshot_map
:
&
'
a
SnapshotMap
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
animations
:
DocumentAnimationSet
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
registered_speculative_painters
:
&
'
a
dyn
RegisteredSpeculativePainters
}
impl
<
'
a
>
SharedStyleContext
<
'
a
>
{
pub
fn
viewport_size
(
&
self
)
-
>
Size2D
<
Au
>
{
self
.
stylist
.
device
(
)
.
au_viewport_size
(
)
}
pub
fn
device_pixel_ratio
(
&
self
)
-
>
Scale
<
f32
CSSPixel
DevicePixel
>
{
self
.
stylist
.
device
(
)
.
device_pixel_ratio
(
)
}
pub
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
{
self
.
stylist
.
quirks_mode
(
)
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
CascadeInputs
{
pub
rules
:
Option
<
StrongRuleNode
>
pub
visited_rules
:
Option
<
StrongRuleNode
>
pub
flags
:
ComputedValueFlags
}
impl
CascadeInputs
{
pub
fn
new_from_style
(
style
:
&
ComputedValues
)
-
>
Self
{
Self
{
rules
:
style
.
rules
.
clone
(
)
visited_rules
:
style
.
visited_style
(
)
.
and_then
(
|
v
|
v
.
rules
.
clone
(
)
)
flags
:
style
.
flags
.
for_cascade_inputs
(
)
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
EagerPseudoCascadeInputs
(
Option
<
[
Option
<
CascadeInputs
>
;
EAGER_PSEUDO_COUNT
]
>
)
;
impl
Clone
for
EagerPseudoCascadeInputs
{
fn
clone
(
&
self
)
-
>
Self
{
if
self
.
0
.
is_none
(
)
{
return
EagerPseudoCascadeInputs
(
None
)
;
}
let
self_inputs
=
self
.
0
.
as_ref
(
)
.
unwrap
(
)
;
let
mut
inputs
:
[
Option
<
CascadeInputs
>
;
EAGER_PSEUDO_COUNT
]
=
Default
:
:
default
(
)
;
for
i
in
0
.
.
EAGER_PSEUDO_COUNT
{
inputs
[
i
]
=
self_inputs
[
i
]
.
clone
(
)
;
}
EagerPseudoCascadeInputs
(
Some
(
inputs
)
)
}
}
impl
EagerPseudoCascadeInputs
{
fn
new_from_style
(
styles
:
&
EagerPseudoStyles
)
-
>
Self
{
EagerPseudoCascadeInputs
(
styles
.
as_optional_array
(
)
.
map
(
|
styles
|
{
let
mut
inputs
:
[
Option
<
CascadeInputs
>
;
EAGER_PSEUDO_COUNT
]
=
Default
:
:
default
(
)
;
for
i
in
0
.
.
EAGER_PSEUDO_COUNT
{
inputs
[
i
]
=
styles
[
i
]
.
as_ref
(
)
.
map
(
|
s
|
CascadeInputs
:
:
new_from_style
(
s
)
)
;
}
inputs
}
)
)
}
pub
fn
into_array
(
self
)
-
>
Option
<
[
Option
<
CascadeInputs
>
;
EAGER_PSEUDO_COUNT
]
>
{
self
.
0
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ElementCascadeInputs
{
pub
primary
:
CascadeInputs
pub
pseudos
:
EagerPseudoCascadeInputs
}
impl
ElementCascadeInputs
{
#
[
inline
]
pub
fn
new_from_element_data
(
data
:
&
ElementData
)
-
>
Self
{
debug_assert
!
(
data
.
has_styles
(
)
)
;
ElementCascadeInputs
{
primary
:
CascadeInputs
:
:
new_from_style
(
data
.
styles
.
primary
(
)
)
pseudos
:
EagerPseudoCascadeInputs
:
:
new_from_style
(
&
data
.
styles
.
pseudos
)
}
}
}
#
[
derive
(
AddAssign
Clone
Default
)
]
pub
struct
PerThreadTraversalStatistics
{
pub
elements_traversed
:
u32
pub
elements_styled
:
u32
pub
elements_matched
:
u32
pub
styles_shared
:
u32
pub
styles_reused
:
u32
}
#
[
derive
(
Default
)
]
pub
struct
TraversalStatistics
{
pub
aggregated
:
PerThreadTraversalStatistics
pub
selectors
:
u32
pub
revalidation_selectors
:
u32
pub
dependency_selectors
:
u32
pub
declarations
:
u32
pub
stylist_rebuilds
:
u32
pub
traversal_time_ms
:
f64
pub
is_parallel
:
bool
pub
is_large
:
bool
}
impl
fmt
:
:
Display
for
TraversalStatistics
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
debug_assert
!
(
self
.
traversal_time_ms
!
=
0
.
0
"
should
have
set
traversal
time
"
)
;
writeln
!
(
f
"
[
PERF
]
perf
block
start
"
)
?
;
writeln
!
(
f
"
[
PERF
]
traversal
{
}
"
if
self
.
is_parallel
{
"
parallel
"
}
else
{
"
sequential
"
}
)
?
;
writeln
!
(
f
"
[
PERF
]
elements_traversed
{
}
"
self
.
aggregated
.
elements_traversed
)
?
;
writeln
!
(
f
"
[
PERF
]
elements_styled
{
}
"
self
.
aggregated
.
elements_styled
)
?
;
writeln
!
(
f
"
[
PERF
]
elements_matched
{
}
"
self
.
aggregated
.
elements_matched
)
?
;
writeln
!
(
f
"
[
PERF
]
styles_shared
{
}
"
self
.
aggregated
.
styles_shared
)
?
;
writeln
!
(
f
"
[
PERF
]
styles_reused
{
}
"
self
.
aggregated
.
styles_reused
)
?
;
writeln
!
(
f
"
[
PERF
]
selectors
{
}
"
self
.
selectors
)
?
;
writeln
!
(
f
"
[
PERF
]
revalidation_selectors
{
}
"
self
.
revalidation_selectors
)
?
;
writeln
!
(
f
"
[
PERF
]
dependency_selectors
{
}
"
self
.
dependency_selectors
)
?
;
writeln
!
(
f
"
[
PERF
]
declarations
{
}
"
self
.
declarations
)
?
;
writeln
!
(
f
"
[
PERF
]
stylist_rebuilds
{
}
"
self
.
stylist_rebuilds
)
?
;
writeln
!
(
f
"
[
PERF
]
traversal_time_ms
{
}
"
self
.
traversal_time_ms
)
?
;
writeln
!
(
f
"
[
PERF
]
perf
block
end
"
)
}
}
impl
TraversalStatistics
{
pub
fn
new
<
E
D
>
(
aggregated
:
PerThreadTraversalStatistics
traversal
:
&
D
parallel
:
bool
start
:
f64
)
-
>
TraversalStatistics
where
E
:
TElement
D
:
DomTraversal
<
E
>
{
let
threshold
=
traversal
.
shared_context
(
)
.
options
.
style_statistics_threshold
;
let
stylist
=
traversal
.
shared_context
(
)
.
stylist
;
let
is_large
=
aggregated
.
elements_traversed
as
usize
>
=
threshold
;
TraversalStatistics
{
aggregated
selectors
:
stylist
.
num_selectors
(
)
as
u32
revalidation_selectors
:
stylist
.
num_revalidation_selectors
(
)
as
u32
dependency_selectors
:
stylist
.
num_invalidations
(
)
as
u32
declarations
:
stylist
.
num_declarations
(
)
as
u32
stylist_rebuilds
:
stylist
.
num_rebuilds
(
)
as
u32
traversal_time_ms
:
(
time
:
:
precise_time_s
(
)
-
start
)
*
1000
.
0
is_parallel
:
parallel
is_large
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
bitflags
!
{
/
/
/
Represents
which
tasks
are
performed
in
a
SequentialTask
of
/
/
/
UpdateAnimations
which
is
a
result
of
normal
restyle
.
pub
struct
UpdateAnimationsTasks
:
u8
{
/
/
/
Update
CSS
Animations
.
const
CSS_ANIMATIONS
=
structs
:
:
UpdateAnimationsTasks_CSSAnimations
;
/
/
/
Update
CSS
Transitions
.
const
CSS_TRANSITIONS
=
structs
:
:
UpdateAnimationsTasks_CSSTransitions
;
/
/
/
Update
effect
properties
.
const
EFFECT_PROPERTIES
=
structs
:
:
UpdateAnimationsTasks_EffectProperties
;
/
/
/
Update
animation
cacade
results
for
animations
running
on
the
compositor
.
const
CASCADE_RESULTS
=
structs
:
:
UpdateAnimationsTasks_CascadeResults
;
/
/
/
Display
property
was
changed
from
none
.
/
/
/
Script
animations
keep
alive
on
display
:
none
elements
so
we
need
to
trigger
/
/
/
the
second
animation
restyles
for
the
script
animations
in
the
case
where
/
/
/
the
display
property
was
changed
from
'
none
'
to
others
.
const
DISPLAY_CHANGED_FROM_NONE
=
structs
:
:
UpdateAnimationsTasks_DisplayChangedFromNone
;
/
/
/
Update
CSS
named
scroll
progress
timelines
.
const
SCROLL_TIMELINES
=
structs
:
:
UpdateAnimationsTasks_ScrollTimelines
;
/
/
/
Update
CSS
named
view
progress
timelines
.
const
VIEW_TIMELINES
=
structs
:
:
UpdateAnimationsTasks_ViewTimelines
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
bitflags
!
{
/
/
/
Represents
which
tasks
are
performed
in
a
SequentialTask
as
a
result
of
/
/
/
animation
-
only
restyle
.
pub
struct
PostAnimationTasks
:
u8
{
/
/
/
Display
property
was
changed
from
none
in
animation
-
only
restyle
so
/
/
/
that
we
need
to
resolve
styles
for
descendants
in
a
subsequent
/
/
/
normal
restyle
.
const
DISPLAY_CHANGED_FROM_NONE_FOR_SMIL
=
0x01
;
}
}
pub
enum
SequentialTask
<
E
:
TElement
>
{
Unused
(
SendElement
<
E
>
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
UpdateAnimations
{
el
:
SendElement
<
E
>
before_change_style
:
Option
<
Arc
<
ComputedValues
>
>
tasks
:
UpdateAnimationsTasks
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
PostAnimation
{
el
:
SendElement
<
E
>
tasks
:
PostAnimationTasks
}
}
impl
<
E
:
TElement
>
SequentialTask
<
E
>
{
pub
fn
execute
(
self
)
{
use
self
:
:
SequentialTask
:
:
*
;
debug_assert_eq
!
(
thread_state
:
:
get
(
)
ThreadState
:
:
LAYOUT
)
;
match
self
{
Unused
(
_
)
=
>
unreachable
!
(
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
UpdateAnimations
{
el
before_change_style
tasks
}
=
>
{
el
.
update_animations
(
before_change_style
tasks
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
PostAnimation
{
el
tasks
}
=
>
{
el
.
process_post_animation
(
tasks
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
update_animations
(
el
:
E
before_change_style
:
Option
<
Arc
<
ComputedValues
>
>
tasks
:
UpdateAnimationsTasks
)
-
>
Self
{
use
self
:
:
SequentialTask
:
:
*
;
UpdateAnimations
{
el
:
unsafe
{
SendElement
:
:
new
(
el
)
}
before_change_style
tasks
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
process_post_animation
(
el
:
E
tasks
:
PostAnimationTasks
)
-
>
Self
{
use
self
:
:
SequentialTask
:
:
*
;
PostAnimation
{
el
:
unsafe
{
SendElement
:
:
new
(
el
)
}
tasks
}
}
}
pub
struct
SequentialTaskList
<
E
>
(
Vec
<
SequentialTask
<
E
>
>
)
where
E
:
TElement
;
impl
<
E
>
ops
:
:
Deref
for
SequentialTaskList
<
E
>
where
E
:
TElement
{
type
Target
=
Vec
<
SequentialTask
<
E
>
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
<
E
>
ops
:
:
DerefMut
for
SequentialTaskList
<
E
>
where
E
:
TElement
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
impl
<
E
>
Drop
for
SequentialTaskList
<
E
>
where
E
:
TElement
{
fn
drop
(
&
mut
self
)
{
debug_assert_eq
!
(
thread_state
:
:
get
(
)
ThreadState
:
:
LAYOUT
)
;
for
task
in
self
.
0
.
drain
(
.
.
)
{
task
.
execute
(
)
}
}
}
pub
struct
StackLimitChecker
{
lower_limit
:
usize
}
impl
StackLimitChecker
{
#
[
inline
(
never
)
]
pub
fn
new
(
stack_size_limit
:
usize
)
-
>
Self
{
StackLimitChecker
{
lower_limit
:
StackLimitChecker
:
:
get_sp
(
)
-
stack_size_limit
}
}
#
[
inline
(
never
)
]
pub
fn
limit_exceeded
(
&
self
)
-
>
bool
{
let
curr_sp
=
StackLimitChecker
:
:
get_sp
(
)
;
if
cfg
!
(
debug_assertions
)
{
let
stack_bottom
=
self
.
lower_limit
-
STACK_SAFETY_MARGIN_KB
*
1024
;
debug_assert
!
(
stack_bottom
<
curr_sp
)
;
let
distance_to_stack_bottom
=
curr_sp
-
stack_bottom
;
let
max_allowable_distance
=
(
STYLE_THREAD_STACK_SIZE_KB
+
10
)
*
1024
;
debug_assert
!
(
distance_to_stack_bottom
<
=
max_allowable_distance
)
;
}
curr_sp
<
=
self
.
lower_limit
}
#
[
inline
(
always
)
]
fn
get_sp
(
)
-
>
usize
{
let
mut
foo
:
usize
=
42
;
(
&
mut
foo
as
*
mut
usize
)
as
usize
}
}
pub
struct
ThreadLocalStyleContext
<
E
:
TElement
>
{
pub
sharing_cache
:
StyleSharingCache
<
E
>
pub
rule_cache
:
RuleCache
pub
bloom_filter
:
StyleBloom
<
E
>
pub
tasks
:
SequentialTaskList
<
E
>
pub
statistics
:
PerThreadTraversalStatistics
pub
stack_limit_checker
:
StackLimitChecker
pub
nth_index_cache
:
NthIndexCache
}
impl
<
E
:
TElement
>
ThreadLocalStyleContext
<
E
>
{
pub
fn
new
(
)
-
>
Self
{
ThreadLocalStyleContext
{
sharing_cache
:
StyleSharingCache
:
:
new
(
)
rule_cache
:
RuleCache
:
:
new
(
)
bloom_filter
:
StyleBloom
:
:
new
(
)
tasks
:
SequentialTaskList
(
Vec
:
:
new
(
)
)
statistics
:
PerThreadTraversalStatistics
:
:
default
(
)
stack_limit_checker
:
StackLimitChecker
:
:
new
(
(
STYLE_THREAD_STACK_SIZE_KB
-
STACK_SAFETY_MARGIN_KB
)
*
1024
)
nth_index_cache
:
NthIndexCache
:
:
default
(
)
}
}
}
pub
struct
StyleContext
<
'
a
E
:
TElement
+
'
a
>
{
pub
shared
:
&
'
a
SharedStyleContext
<
'
a
>
pub
thread_local
:
&
'
a
mut
ThreadLocalStyleContext
<
E
>
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
trait
RegisteredSpeculativePainter
:
SpeculativePainter
{
fn
name
(
&
self
)
-
>
Atom
;
fn
properties
(
&
self
)
-
>
&
FxHashMap
<
Atom
PropertyId
>
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
trait
RegisteredSpeculativePainters
:
Sync
{
fn
get
(
&
self
name
:
&
Atom
)
-
>
Option
<
&
dyn
RegisteredSpeculativePainter
>
;
}
