#
!
[
deny
(
missing_docs
)
]
use
animation
:
:
{
Animation
PropertyAnimation
}
;
use
app_units
:
:
Au
;
use
bit_vec
:
:
BitVec
;
use
bloom
:
:
StyleBloom
;
use
data
:
:
ElementData
;
use
dom
:
:
{
OpaqueNode
TNode
TElement
SendElement
}
;
use
error_reporting
:
:
ParseErrorReporter
;
use
euclid
:
:
Size2D
;
use
font_metrics
:
:
FontMetricsProvider
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
structs
;
use
matching
:
:
StyleSharingCandidateCache
;
use
parking_lot
:
:
RwLock
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
selector_parser
:
:
PseudoElement
;
use
selectors
:
:
matching
:
:
ElementSelectorFlags
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
servo_config
:
:
opts
;
use
shared_lock
:
:
StylesheetGuards
;
use
std
:
:
collections
:
:
HashMap
;
#
[
cfg
(
not
(
feature
=
"
servo
"
)
)
]
use
std
:
:
env
;
use
std
:
:
fmt
;
use
std
:
:
ops
:
:
Add
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
std
:
:
sync
:
:
mpsc
:
:
Sender
;
use
stylist
:
:
Stylist
;
use
thread_state
;
use
time
;
use
timer
:
:
Timer
;
use
traversal
:
:
{
DomTraversal
TraversalFlags
}
;
pub
struct
ThreadLocalStyleContextCreationInfo
{
new_animations_sender
:
Sender
<
Animation
>
}
impl
ThreadLocalStyleContextCreationInfo
{
pub
fn
new
(
animations_sender
:
Sender
<
Animation
>
)
-
>
Self
{
ThreadLocalStyleContextCreationInfo
{
new_animations_sender
:
animations_sender
}
}
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
Hash
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
QuirksMode
{
Quirks
LimitedQuirks
NoQuirks
}
#
[
derive
(
Clone
)
]
pub
struct
StyleSystemOptions
{
pub
disable_style_sharing_cache
:
bool
pub
dump_style_statistics
:
bool
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
get_env
(
name
:
&
str
)
-
>
bool
{
match
env
:
:
var
(
name
)
{
Ok
(
s
)
=
>
!
s
.
is_empty
(
)
Err
(
_
)
=
>
false
}
}
impl
Default
for
StyleSystemOptions
{
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
default
(
)
-
>
Self
{
StyleSystemOptions
{
disable_style_sharing_cache
:
opts
:
:
get
(
)
.
disable_share_style_cache
dump_style_statistics
:
opts
:
:
get
(
)
.
style_sharing_stats
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
default
(
)
-
>
Self
{
StyleSystemOptions
{
disable_style_sharing_cache
:
get_env
(
"
DISABLE_STYLE_SHARING_CACHE
"
)
dump_style_statistics
:
get_env
(
"
DUMP_STYLE_STATISTICS
"
)
}
}
}
pub
struct
SharedStyleContext
<
'
a
>
{
pub
stylist
:
Arc
<
Stylist
>
pub
options
:
StyleSystemOptions
pub
guards
:
StylesheetGuards
<
'
a
>
pub
running_animations
:
Arc
<
RwLock
<
HashMap
<
OpaqueNode
Vec
<
Animation
>
>
>
>
pub
expired_animations
:
Arc
<
RwLock
<
HashMap
<
OpaqueNode
Vec
<
Animation
>
>
>
>
pub
error_reporter
:
Box
<
ParseErrorReporter
>
pub
local_context_creation_data
:
Mutex
<
ThreadLocalStyleContextCreationInfo
>
pub
timer
:
Timer
pub
quirks_mode
:
QuirksMode
pub
traversal_flags
:
TraversalFlags
}
impl
<
'
a
>
SharedStyleContext
<
'
a
>
{
pub
fn
viewport_size
(
&
self
)
-
>
Size2D
<
Au
>
{
self
.
stylist
.
device
.
au_viewport_size
(
)
}
}
pub
struct
CurrentElementInfo
{
element
:
OpaqueNode
is_initial_style
:
bool
pub
revalidation_match_results
:
Option
<
BitVec
>
#
[
allow
(
dead_code
)
]
pub
possibly_expired_animations
:
Vec
<
PropertyAnimation
>
}
#
[
derive
(
Default
)
]
pub
struct
TraversalStatistics
{
pub
elements_traversed
:
u32
pub
elements_styled
:
u32
pub
elements_matched
:
u32
pub
styles_shared
:
u32
pub
traversal_time_ms
:
f64
pub
is_parallel
:
Option
<
bool
>
}
impl
<
'
a
>
Add
for
&
'
a
TraversalStatistics
{
type
Output
=
TraversalStatistics
;
fn
add
(
self
other
:
Self
)
-
>
TraversalStatistics
{
debug_assert
!
(
self
.
traversal_time_ms
=
=
0
.
0
&
&
other
.
traversal_time_ms
=
=
0
.
0
"
traversal_time_ms
should
be
set
at
the
end
by
the
caller
"
)
;
TraversalStatistics
{
elements_traversed
:
self
.
elements_traversed
+
other
.
elements_traversed
elements_styled
:
self
.
elements_styled
+
other
.
elements_styled
elements_matched
:
self
.
elements_matched
+
other
.
elements_matched
styles_shared
:
self
.
styles_shared
+
other
.
styles_shared
traversal_time_ms
:
0
.
0
is_parallel
:
None
}
}
}
impl
fmt
:
:
Display
for
TraversalStatistics
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
debug_assert
!
(
self
.
traversal_time_ms
!
=
0
.
0
"
should
have
set
traversal
time
"
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
perf
block
start
"
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
traversal
{
}
"
if
self
.
is_parallel
.
unwrap
(
)
{
"
parallel
"
}
else
{
"
sequential
"
}
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
elements_traversed
{
}
"
self
.
elements_traversed
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
elements_styled
{
}
"
self
.
elements_styled
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
elements_matched
{
}
"
self
.
elements_matched
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
styles_shared
{
}
"
self
.
styles_shared
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
traversal_time_ms
{
}
"
self
.
traversal_time_ms
)
)
;
writeln
!
(
f
"
[
PERF
]
perf
block
end
"
)
}
}
impl
TraversalStatistics
{
pub
fn
finish
<
E
D
>
(
&
mut
self
traversal
:
&
D
start
:
f64
)
where
E
:
TElement
D
:
DomTraversal
<
E
>
{
self
.
is_parallel
=
Some
(
traversal
.
is_parallel
(
)
)
;
self
.
traversal_time_ms
=
(
time
:
:
precise_time_s
(
)
-
start
)
*
1000
.
0
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
bitflags
!
{
/
/
/
Represents
which
tasks
are
performed
in
a
SequentialTask
of
UpdateAnimations
.
pub
flags
UpdateAnimationsTasks
:
u8
{
/
/
/
Update
CSS
Animations
.
const
CSS_ANIMATIONS
=
structs
:
:
UpdateAnimationsTasks_CSSAnimations
/
/
/
Update
CSS
Transitions
.
const
CSS_TRANSITIONS
=
structs
:
:
UpdateAnimationsTasks_CSSTransitions
/
/
/
Update
effect
properties
.
const
EFFECT_PROPERTIES
=
structs
:
:
UpdateAnimationsTasks_EffectProperties
/
/
/
Update
animation
cacade
results
for
animations
running
on
the
compositor
.
const
CASCADE_RESULTS
=
structs
:
:
UpdateAnimationsTasks_CascadeResults
}
}
pub
enum
SequentialTask
<
E
:
TElement
>
{
SetSelectorFlags
(
SendElement
<
E
>
ElementSelectorFlags
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
UpdateAnimations
(
SendElement
<
E
>
Option
<
PseudoElement
>
UpdateAnimationsTasks
)
}
impl
<
E
:
TElement
>
SequentialTask
<
E
>
{
pub
fn
execute
(
self
)
{
use
self
:
:
SequentialTask
:
:
*
;
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
match
self
{
SetSelectorFlags
(
el
flags
)
=
>
{
unsafe
{
el
.
set_selector_flags
(
flags
)
}
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
UpdateAnimations
(
el
pseudo
tasks
)
=
>
{
unsafe
{
el
.
update_animations
(
pseudo
.
as_ref
(
)
tasks
)
}
;
}
}
}
pub
fn
set_selector_flags
(
el
:
E
flags
:
ElementSelectorFlags
)
-
>
Self
{
use
self
:
:
SequentialTask
:
:
*
;
SetSelectorFlags
(
unsafe
{
SendElement
:
:
new
(
el
)
}
flags
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
update_animations
(
el
:
E
pseudo
:
Option
<
PseudoElement
>
tasks
:
UpdateAnimationsTasks
)
-
>
Self
{
use
self
:
:
SequentialTask
:
:
*
;
UpdateAnimations
(
unsafe
{
SendElement
:
:
new
(
el
)
}
pseudo
tasks
)
}
}
pub
struct
ThreadLocalStyleContext
<
E
:
TElement
>
{
pub
style_sharing_candidate_cache
:
StyleSharingCandidateCache
<
E
>
pub
bloom_filter
:
StyleBloom
<
E
>
pub
new_animations_sender
:
Sender
<
Animation
>
pub
tasks
:
Vec
<
SequentialTask
<
E
>
>
pub
statistics
:
TraversalStatistics
pub
current_element_info
:
Option
<
CurrentElementInfo
>
pub
font_metrics_provider
:
E
:
:
FontMetricsProvider
}
impl
<
E
:
TElement
>
ThreadLocalStyleContext
<
E
>
{
pub
fn
new
(
shared
:
&
SharedStyleContext
)
-
>
Self
{
ThreadLocalStyleContext
{
style_sharing_candidate_cache
:
StyleSharingCandidateCache
:
:
new
(
)
bloom_filter
:
StyleBloom
:
:
new
(
)
new_animations_sender
:
shared
.
local_context_creation_data
.
lock
(
)
.
unwrap
(
)
.
new_animations_sender
.
clone
(
)
tasks
:
Vec
:
:
new
(
)
statistics
:
TraversalStatistics
:
:
default
(
)
current_element_info
:
None
font_metrics_provider
:
E
:
:
FontMetricsProvider
:
:
create_from
(
shared
)
}
}
pub
fn
begin_element
(
&
mut
self
element
:
E
data
:
&
ElementData
)
{
debug_assert
!
(
self
.
current_element_info
.
is_none
(
)
)
;
self
.
current_element_info
=
Some
(
CurrentElementInfo
{
element
:
element
.
as_node
(
)
.
opaque
(
)
is_initial_style
:
!
data
.
has_styles
(
)
revalidation_match_results
:
None
possibly_expired_animations
:
Vec
:
:
new
(
)
}
)
;
}
pub
fn
end_element
(
&
mut
self
element
:
E
)
{
debug_assert
!
(
self
.
current_element_info
.
is_some
(
)
)
;
debug_assert
!
(
self
.
current_element_info
.
as_ref
(
)
.
unwrap
(
)
.
element
=
=
element
.
as_node
(
)
.
opaque
(
)
)
;
self
.
current_element_info
=
None
;
}
pub
fn
is_initial_style
(
&
self
)
-
>
bool
{
self
.
current_element_info
.
as_ref
(
)
.
unwrap
(
)
.
is_initial_style
}
}
impl
<
E
:
TElement
>
Drop
for
ThreadLocalStyleContext
<
E
>
{
fn
drop
(
&
mut
self
)
{
debug_assert
!
(
self
.
current_element_info
.
is_none
(
)
)
;
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
for
task
in
self
.
tasks
.
drain
(
.
.
)
{
task
.
execute
(
)
;
}
}
}
pub
struct
StyleContext
<
'
a
E
:
TElement
+
'
a
>
{
pub
shared
:
&
'
a
SharedStyleContext
<
'
a
>
pub
thread_local
:
&
'
a
mut
ThreadLocalStyleContext
<
E
>
}
#
[
derive
(
PartialEq
Copy
Clone
Debug
)
]
pub
enum
ReflowGoal
{
ForDisplay
ForScriptQuery
}
