#
[
cfg
(
feature
=
"
servo
"
)
]
use
animation
:
:
Animation
;
use
animation
:
:
PropertyAnimation
;
use
app_units
:
:
Au
;
use
bit_vec
:
:
BitVec
;
use
bloom
:
:
StyleBloom
;
use
cache
:
:
LRUCache
;
use
data
:
:
ElementData
;
use
dom
:
:
{
OpaqueNode
TNode
TElement
SendElement
}
;
use
error_reporting
:
:
ParseErrorReporter
;
use
euclid
:
:
Size2D
;
use
fnv
:
:
FnvHashMap
;
use
font_metrics
:
:
FontMetricsProvider
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
structs
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
parking_lot
:
:
RwLock
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
properties
:
:
ComputedValues
;
use
selector_parser
:
:
SnapshotMap
;
use
selectors
:
:
matching
:
:
ElementSelectorFlags
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
servo_config
:
:
opts
;
use
shared_lock
:
:
StylesheetGuards
;
use
sharing
:
:
StyleSharingCandidateCache
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
std
:
:
collections
:
:
HashMap
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
std
:
:
env
;
use
std
:
:
fmt
;
use
std
:
:
ops
:
:
Add
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
std
:
:
sync
:
:
Mutex
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
std
:
:
sync
:
:
mpsc
:
:
Sender
;
use
stylearc
:
:
Arc
;
use
stylist
:
:
Stylist
;
use
thread_state
;
use
time
;
use
timer
:
:
Timer
;
use
traversal
:
:
{
DomTraversal
TraversalFlags
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
struct
ThreadLocalStyleContextCreationInfo
{
new_animations_sender
:
Sender
<
Animation
>
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
ThreadLocalStyleContextCreationInfo
{
pub
fn
new
(
animations_sender
:
Sender
<
Animation
>
)
-
>
Self
{
ThreadLocalStyleContextCreationInfo
{
new_animations_sender
:
animations_sender
}
}
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
Hash
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
QuirksMode
{
Quirks
LimitedQuirks
NoQuirks
}
#
[
derive
(
Clone
)
]
pub
struct
StyleSystemOptions
{
pub
disable_style_sharing_cache
:
bool
pub
dump_style_statistics
:
bool
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
get_env
(
name
:
&
str
)
-
>
bool
{
match
env
:
:
var
(
name
)
{
Ok
(
s
)
=
>
!
s
.
is_empty
(
)
Err
(
_
)
=
>
false
}
}
impl
Default
for
StyleSystemOptions
{
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
default
(
)
-
>
Self
{
StyleSystemOptions
{
disable_style_sharing_cache
:
opts
:
:
get
(
)
.
disable_share_style_cache
dump_style_statistics
:
opts
:
:
get
(
)
.
style_sharing_stats
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
default
(
)
-
>
Self
{
StyleSystemOptions
{
disable_style_sharing_cache
:
get_env
(
"
DISABLE_STYLE_SHARING_CACHE
"
)
dump_style_statistics
:
get_env
(
"
DUMP_STYLE_STATISTICS
"
)
}
}
}
pub
struct
SharedStyleContext
<
'
a
>
{
pub
stylist
:
&
'
a
Stylist
pub
options
:
StyleSystemOptions
pub
guards
:
StylesheetGuards
<
'
a
>
pub
error_reporter
:
&
'
a
ParseErrorReporter
pub
timer
:
Timer
pub
quirks_mode
:
QuirksMode
pub
traversal_flags
:
TraversalFlags
pub
snapshot_map
:
&
'
a
SnapshotMap
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
running_animations
:
Arc
<
RwLock
<
HashMap
<
OpaqueNode
Vec
<
Animation
>
>
>
>
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
expired_animations
:
Arc
<
RwLock
<
HashMap
<
OpaqueNode
Vec
<
Animation
>
>
>
>
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
local_context_creation_data
:
Mutex
<
ThreadLocalStyleContextCreationInfo
>
}
impl
<
'
a
>
SharedStyleContext
<
'
a
>
{
pub
fn
viewport_size
(
&
self
)
-
>
Size2D
<
Au
>
{
self
.
stylist
.
device
(
)
.
au_viewport_size
(
)
}
}
pub
struct
CurrentElementInfo
{
element
:
OpaqueNode
is_initial_style
:
bool
pub
revalidation_match_results
:
Option
<
BitVec
>
#
[
allow
(
dead_code
)
]
pub
possibly_expired_animations
:
Vec
<
PropertyAnimation
>
}
#
[
derive
(
Default
)
]
pub
struct
TraversalStatistics
{
pub
elements_traversed
:
u32
pub
elements_styled
:
u32
pub
elements_matched
:
u32
pub
styles_shared
:
u32
pub
selectors
:
u32
pub
revalidation_selectors
:
u32
pub
dependency_selectors
:
u32
pub
declarations
:
u32
pub
stylist_rebuilds
:
u32
pub
traversal_time_ms
:
f64
pub
is_parallel
:
Option
<
bool
>
}
impl
<
'
a
>
Add
for
&
'
a
TraversalStatistics
{
type
Output
=
TraversalStatistics
;
fn
add
(
self
other
:
Self
)
-
>
TraversalStatistics
{
debug_assert
!
(
self
.
traversal_time_ms
=
=
0
.
0
&
&
other
.
traversal_time_ms
=
=
0
.
0
"
traversal_time_ms
should
be
set
at
the
end
by
the
caller
"
)
;
debug_assert
!
(
self
.
selectors
=
=
0
"
set
at
the
end
"
)
;
debug_assert
!
(
self
.
revalidation_selectors
=
=
0
"
set
at
the
end
"
)
;
debug_assert
!
(
self
.
dependency_selectors
=
=
0
"
set
at
the
end
"
)
;
debug_assert
!
(
self
.
declarations
=
=
0
"
set
at
the
end
"
)
;
debug_assert
!
(
self
.
stylist_rebuilds
=
=
0
"
set
at
the
end
"
)
;
TraversalStatistics
{
elements_traversed
:
self
.
elements_traversed
+
other
.
elements_traversed
elements_styled
:
self
.
elements_styled
+
other
.
elements_styled
elements_matched
:
self
.
elements_matched
+
other
.
elements_matched
styles_shared
:
self
.
styles_shared
+
other
.
styles_shared
selectors
:
0
revalidation_selectors
:
0
dependency_selectors
:
0
declarations
:
0
stylist_rebuilds
:
0
traversal_time_ms
:
0
.
0
is_parallel
:
None
}
}
}
impl
fmt
:
:
Display
for
TraversalStatistics
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
debug_assert
!
(
self
.
traversal_time_ms
!
=
0
.
0
"
should
have
set
traversal
time
"
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
perf
block
start
"
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
traversal
{
}
"
if
self
.
is_parallel
.
unwrap
(
)
{
"
parallel
"
}
else
{
"
sequential
"
}
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
elements_traversed
{
}
"
self
.
elements_traversed
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
elements_styled
{
}
"
self
.
elements_styled
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
elements_matched
{
}
"
self
.
elements_matched
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
styles_shared
{
}
"
self
.
styles_shared
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
selectors
{
}
"
self
.
selectors
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
revalidation_selectors
{
}
"
self
.
revalidation_selectors
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
dependency_selectors
{
}
"
self
.
dependency_selectors
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
declarations
{
}
"
self
.
declarations
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
stylist_rebuilds
{
}
"
self
.
stylist_rebuilds
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
traversal_time_ms
{
}
"
self
.
traversal_time_ms
)
)
;
writeln
!
(
f
"
[
PERF
]
perf
block
end
"
)
}
}
impl
TraversalStatistics
{
pub
fn
finish
<
E
D
>
(
&
mut
self
traversal
:
&
D
start
:
f64
)
where
E
:
TElement
D
:
DomTraversal
<
E
>
{
self
.
is_parallel
=
Some
(
traversal
.
is_parallel
(
)
)
;
self
.
traversal_time_ms
=
(
time
:
:
precise_time_s
(
)
-
start
)
*
1000
.
0
;
self
.
selectors
=
traversal
.
shared_context
(
)
.
stylist
.
num_selectors
(
)
as
u32
;
self
.
revalidation_selectors
=
traversal
.
shared_context
(
)
.
stylist
.
num_revalidation_selectors
(
)
as
u32
;
self
.
dependency_selectors
=
traversal
.
shared_context
(
)
.
stylist
.
num_dependencies
(
)
as
u32
;
self
.
declarations
=
traversal
.
shared_context
(
)
.
stylist
.
num_declarations
(
)
as
u32
;
self
.
stylist_rebuilds
=
traversal
.
shared_context
(
)
.
stylist
.
num_rebuilds
(
)
as
u32
;
}
pub
fn
is_large_traversal
(
&
self
)
-
>
bool
{
self
.
elements_traversed
>
=
50
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
bitflags
!
{
/
/
/
Represents
which
tasks
are
performed
in
a
SequentialTask
of
/
/
/
UpdateAnimations
.
pub
flags
UpdateAnimationsTasks
:
u8
{
/
/
/
Update
CSS
Animations
.
const
CSS_ANIMATIONS
=
structs
:
:
UpdateAnimationsTasks_CSSAnimations
/
/
/
Update
CSS
Transitions
.
const
CSS_TRANSITIONS
=
structs
:
:
UpdateAnimationsTasks_CSSTransitions
/
/
/
Update
effect
properties
.
const
EFFECT_PROPERTIES
=
structs
:
:
UpdateAnimationsTasks_EffectProperties
/
/
/
Update
animation
cacade
results
for
animations
running
on
the
compositor
.
const
CASCADE_RESULTS
=
structs
:
:
UpdateAnimationsTasks_CascadeResults
}
}
pub
enum
SequentialTask
<
E
:
TElement
>
{
Unused
(
SendElement
<
E
>
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
UpdateAnimations
{
el
:
SendElement
<
E
>
before_change_style
:
Option
<
Arc
<
ComputedValues
>
>
tasks
:
UpdateAnimationsTasks
}
}
impl
<
E
:
TElement
>
SequentialTask
<
E
>
{
pub
fn
execute
(
self
)
{
use
self
:
:
SequentialTask
:
:
*
;
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
match
self
{
Unused
(
_
)
=
>
unreachable
!
(
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
UpdateAnimations
{
el
before_change_style
tasks
}
=
>
{
unsafe
{
el
.
update_animations
(
before_change_style
tasks
)
}
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
update_animations
(
el
:
E
before_change_style
:
Option
<
Arc
<
ComputedValues
>
>
tasks
:
UpdateAnimationsTasks
)
-
>
Self
{
use
self
:
:
SequentialTask
:
:
*
;
UpdateAnimations
{
el
:
unsafe
{
SendElement
:
:
new
(
el
)
}
before_change_style
:
before_change_style
tasks
:
tasks
}
}
}
pub
struct
SelectorFlagsMap
<
E
:
TElement
>
{
map
:
FnvHashMap
<
SendElement
<
E
>
ElementSelectorFlags
>
cache
:
LRUCache
<
(
SendElement
<
E
>
ElementSelectorFlags
)
>
}
#
[
cfg
(
debug_assertions
)
]
impl
<
E
:
TElement
>
Drop
for
SelectorFlagsMap
<
E
>
{
fn
drop
(
&
mut
self
)
{
debug_assert
!
(
self
.
map
.
is_empty
(
)
)
;
}
}
impl
<
E
:
TElement
>
SelectorFlagsMap
<
E
>
{
pub
fn
new
(
)
-
>
Self
{
SelectorFlagsMap
{
map
:
FnvHashMap
:
:
default
(
)
cache
:
LRUCache
:
:
new
(
4
)
}
}
pub
fn
insert_flags
(
&
mut
self
element
:
E
flags
:
ElementSelectorFlags
)
{
let
el
=
unsafe
{
SendElement
:
:
new
(
element
)
}
;
if
self
.
cache
.
iter
(
)
.
find
(
|
x
|
x
.
0
=
=
el
)
.
map_or
(
ElementSelectorFlags
:
:
empty
(
)
|
x
|
x
.
1
)
.
contains
(
flags
)
{
return
;
}
let
f
=
self
.
map
.
entry
(
el
)
.
or_insert
(
ElementSelectorFlags
:
:
empty
(
)
)
;
*
f
|
=
flags
;
self
.
cache
.
insert
(
(
unsafe
{
SendElement
:
:
new
(
element
)
}
*
f
)
)
}
pub
fn
apply_flags
(
&
mut
self
)
{
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
for
(
el
flags
)
in
self
.
map
.
drain
(
)
{
unsafe
{
el
.
set_selector_flags
(
flags
)
;
}
}
}
}
pub
struct
ThreadLocalStyleContext
<
E
:
TElement
>
{
pub
style_sharing_candidate_cache
:
StyleSharingCandidateCache
<
E
>
pub
bloom_filter
:
StyleBloom
<
E
>
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
new_animations_sender
:
Sender
<
Animation
>
pub
tasks
:
Vec
<
SequentialTask
<
E
>
>
pub
selector_flags
:
SelectorFlagsMap
<
E
>
pub
statistics
:
TraversalStatistics
pub
current_element_info
:
Option
<
CurrentElementInfo
>
pub
font_metrics_provider
:
E
:
:
FontMetricsProvider
}
impl
<
E
:
TElement
>
ThreadLocalStyleContext
<
E
>
{
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
new
(
shared
:
&
SharedStyleContext
)
-
>
Self
{
ThreadLocalStyleContext
{
style_sharing_candidate_cache
:
StyleSharingCandidateCache
:
:
new
(
)
bloom_filter
:
StyleBloom
:
:
new
(
)
new_animations_sender
:
shared
.
local_context_creation_data
.
lock
(
)
.
unwrap
(
)
.
new_animations_sender
.
clone
(
)
tasks
:
Vec
:
:
new
(
)
selector_flags
:
SelectorFlagsMap
:
:
new
(
)
statistics
:
TraversalStatistics
:
:
default
(
)
current_element_info
:
None
font_metrics_provider
:
E
:
:
FontMetricsProvider
:
:
create_from
(
shared
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
new
(
shared
:
&
SharedStyleContext
)
-
>
Self
{
ThreadLocalStyleContext
{
style_sharing_candidate_cache
:
StyleSharingCandidateCache
:
:
new
(
)
bloom_filter
:
StyleBloom
:
:
new
(
)
tasks
:
Vec
:
:
new
(
)
selector_flags
:
SelectorFlagsMap
:
:
new
(
)
statistics
:
TraversalStatistics
:
:
default
(
)
current_element_info
:
None
font_metrics_provider
:
E
:
:
FontMetricsProvider
:
:
create_from
(
shared
)
}
}
pub
fn
begin_element
(
&
mut
self
element
:
E
data
:
&
ElementData
)
{
debug_assert
!
(
self
.
current_element_info
.
is_none
(
)
)
;
self
.
current_element_info
=
Some
(
CurrentElementInfo
{
element
:
element
.
as_node
(
)
.
opaque
(
)
is_initial_style
:
!
data
.
has_styles
(
)
revalidation_match_results
:
None
possibly_expired_animations
:
Vec
:
:
new
(
)
}
)
;
}
pub
fn
end_element
(
&
mut
self
element
:
E
)
{
debug_assert
!
(
self
.
current_element_info
.
is_some
(
)
)
;
debug_assert
!
(
self
.
current_element_info
.
as_ref
(
)
.
unwrap
(
)
.
element
=
=
element
.
as_node
(
)
.
opaque
(
)
)
;
self
.
current_element_info
=
None
;
}
pub
fn
is_initial_style
(
&
self
)
-
>
bool
{
self
.
current_element_info
.
as_ref
(
)
.
unwrap
(
)
.
is_initial_style
}
}
impl
<
E
:
TElement
>
Drop
for
ThreadLocalStyleContext
<
E
>
{
fn
drop
(
&
mut
self
)
{
debug_assert
!
(
self
.
current_element_info
.
is_none
(
)
)
;
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
self
.
selector_flags
.
apply_flags
(
)
;
for
task
in
self
.
tasks
.
drain
(
.
.
)
{
task
.
execute
(
)
;
}
}
}
pub
struct
StyleContext
<
'
a
E
:
TElement
+
'
a
>
{
pub
shared
:
&
'
a
SharedStyleContext
<
'
a
>
pub
thread_local
:
&
'
a
mut
ThreadLocalStyleContext
<
E
>
}
#
[
derive
(
PartialEq
Copy
Clone
Debug
)
]
pub
enum
ReflowGoal
{
ForDisplay
ForScriptQuery
}
