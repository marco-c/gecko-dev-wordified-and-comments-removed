#
[
cfg
(
feature
=
"
servo
"
)
]
use
animation
:
:
Animation
;
use
animation
:
:
PropertyAnimation
;
use
app_units
:
:
Au
;
use
bloom
:
:
StyleBloom
;
use
cache
:
:
LRUCache
;
use
data
:
:
{
EagerPseudoStyles
ElementData
}
;
use
dom
:
:
{
OpaqueNode
TNode
TElement
SendElement
}
;
use
euclid
:
:
ScaleFactor
;
use
euclid
:
:
Size2D
;
use
fnv
:
:
FnvHashMap
;
use
font_metrics
:
:
FontMetricsProvider
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
structs
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
parking_lot
:
:
RwLock
;
use
properties
:
:
ComputedValues
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
properties
:
:
PropertyId
;
use
rule_tree
:
:
StrongRuleNode
;
use
selector_parser
:
:
{
EAGER_PSEUDO_COUNT
SnapshotMap
}
;
use
selectors
:
:
matching
:
:
ElementSelectorFlags
;
use
servo_arc
:
:
Arc
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
servo_atoms
:
:
Atom
;
use
shared_lock
:
:
StylesheetGuards
;
use
sharing
:
:
StyleSharingCandidateCache
;
use
std
:
:
fmt
;
use
std
:
:
ops
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
std
:
:
sync
:
:
Mutex
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
std
:
:
sync
:
:
mpsc
:
:
Sender
;
use
style_traits
:
:
CSSPixel
;
use
style_traits
:
:
DevicePixel
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
style_traits
:
:
SpeculativePainter
;
use
stylist
:
:
Stylist
;
use
thread_state
;
use
time
;
use
timer
:
:
Timer
;
use
traversal
:
:
DomTraversal
;
use
traversal_flags
:
:
TraversalFlags
;
pub
use
selectors
:
:
matching
:
:
QuirksMode
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
struct
ThreadLocalStyleContextCreationInfo
{
new_animations_sender
:
Sender
<
Animation
>
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
ThreadLocalStyleContextCreationInfo
{
pub
fn
new
(
animations_sender
:
Sender
<
Animation
>
)
-
>
Self
{
ThreadLocalStyleContextCreationInfo
{
new_animations_sender
:
animations_sender
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
StyleSystemOptions
{
pub
disable_style_sharing_cache
:
bool
pub
dump_style_statistics
:
bool
pub
style_statistics_threshold
:
usize
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
get_env_bool
(
name
:
&
str
)
-
>
bool
{
use
std
:
:
env
;
match
env
:
:
var
(
name
)
{
Ok
(
s
)
=
>
!
s
.
is_empty
(
)
Err
(
_
)
=
>
false
}
}
const
DEFAULT_STATISTICS_THRESHOLD
:
usize
=
50
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
get_env_usize
(
name
:
&
str
)
-
>
Option
<
usize
>
{
use
std
:
:
env
;
env
:
:
var
(
name
)
.
ok
(
)
.
map
(
|
s
|
{
s
.
parse
:
:
<
usize
>
(
)
.
expect
(
"
Couldn
'
t
parse
environmental
variable
as
usize
"
)
}
)
}
impl
Default
for
StyleSystemOptions
{
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
default
(
)
-
>
Self
{
use
servo_config
:
:
opts
;
StyleSystemOptions
{
disable_style_sharing_cache
:
opts
:
:
get
(
)
.
disable_share_style_cache
dump_style_statistics
:
opts
:
:
get
(
)
.
style_sharing_stats
style_statistics_threshold
:
DEFAULT_STATISTICS_THRESHOLD
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
default
(
)
-
>
Self
{
StyleSystemOptions
{
disable_style_sharing_cache
:
get_env_bool
(
"
DISABLE_STYLE_SHARING_CACHE
"
)
dump_style_statistics
:
get_env_bool
(
"
DUMP_STYLE_STATISTICS
"
)
style_statistics_threshold
:
get_env_usize
(
"
STYLE_STATISTICS_THRESHOLD
"
)
.
unwrap_or
(
DEFAULT_STATISTICS_THRESHOLD
)
}
}
}
pub
struct
SharedStyleContext
<
'
a
>
{
pub
stylist
:
&
'
a
Stylist
pub
visited_styles_enabled
:
bool
pub
options
:
StyleSystemOptions
pub
guards
:
StylesheetGuards
<
'
a
>
pub
timer
:
Timer
pub
quirks_mode
:
QuirksMode
pub
traversal_flags
:
TraversalFlags
pub
snapshot_map
:
&
'
a
SnapshotMap
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
running_animations
:
Arc
<
RwLock
<
FnvHashMap
<
OpaqueNode
Vec
<
Animation
>
>
>
>
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
expired_animations
:
Arc
<
RwLock
<
FnvHashMap
<
OpaqueNode
Vec
<
Animation
>
>
>
>
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
registered_speculative_painters
:
&
'
a
RegisteredSpeculativePainters
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
local_context_creation_data
:
Mutex
<
ThreadLocalStyleContextCreationInfo
>
}
impl
<
'
a
>
SharedStyleContext
<
'
a
>
{
pub
fn
viewport_size
(
&
self
)
-
>
Size2D
<
Au
>
{
self
.
stylist
.
device
(
)
.
au_viewport_size
(
)
}
pub
fn
device_pixel_ratio
(
&
self
)
-
>
ScaleFactor
<
f32
CSSPixel
DevicePixel
>
{
self
.
stylist
.
device
(
)
.
device_pixel_ratio
(
)
}
}
#
[
derive
(
Clone
Default
)
]
pub
struct
CascadeInputs
{
pub
rules
:
Option
<
StrongRuleNode
>
pub
visited_rules
:
Option
<
StrongRuleNode
>
}
impl
CascadeInputs
{
pub
fn
new_from_style
(
style
:
&
ComputedValues
)
-
>
Self
{
CascadeInputs
{
rules
:
style
.
rules
.
clone
(
)
visited_rules
:
style
.
get_visited_style
(
)
.
and_then
(
|
v
|
v
.
rules
.
clone
(
)
)
}
}
}
impl
fmt
:
:
Debug
for
CascadeInputs
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
CascadeInputs
{
{
rules
:
{
:
?
}
visited_rules
:
{
:
?
}
.
.
}
}
"
self
.
rules
self
.
visited_rules
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
EagerPseudoCascadeInputs
(
Option
<
[
Option
<
CascadeInputs
>
;
EAGER_PSEUDO_COUNT
]
>
)
;
impl
Clone
for
EagerPseudoCascadeInputs
{
fn
clone
(
&
self
)
-
>
Self
{
if
self
.
0
.
is_none
(
)
{
return
EagerPseudoCascadeInputs
(
None
)
}
let
self_inputs
=
self
.
0
.
as_ref
(
)
.
unwrap
(
)
;
let
mut
inputs
:
[
Option
<
CascadeInputs
>
;
EAGER_PSEUDO_COUNT
]
=
Default
:
:
default
(
)
;
for
i
in
0
.
.
EAGER_PSEUDO_COUNT
{
inputs
[
i
]
=
self_inputs
[
i
]
.
clone
(
)
;
}
EagerPseudoCascadeInputs
(
Some
(
inputs
)
)
}
}
impl
EagerPseudoCascadeInputs
{
fn
new_from_style
(
styles
:
&
EagerPseudoStyles
)
-
>
Self
{
EagerPseudoCascadeInputs
(
styles
.
as_optional_array
(
)
.
map
(
|
styles
|
{
let
mut
inputs
:
[
Option
<
CascadeInputs
>
;
EAGER_PSEUDO_COUNT
]
=
Default
:
:
default
(
)
;
for
i
in
0
.
.
EAGER_PSEUDO_COUNT
{
inputs
[
i
]
=
styles
[
i
]
.
as_ref
(
)
.
map
(
|
s
|
CascadeInputs
:
:
new_from_style
(
s
)
)
;
}
inputs
}
)
)
}
pub
fn
into_array
(
self
)
-
>
Option
<
[
Option
<
CascadeInputs
>
;
EAGER_PSEUDO_COUNT
]
>
{
self
.
0
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ElementCascadeInputs
{
pub
primary
:
CascadeInputs
pub
pseudos
:
EagerPseudoCascadeInputs
}
impl
ElementCascadeInputs
{
pub
fn
new_from_element_data
(
data
:
&
ElementData
)
-
>
Self
{
debug_assert
!
(
data
.
has_styles
(
)
)
;
ElementCascadeInputs
{
primary
:
CascadeInputs
:
:
new_from_style
(
data
.
styles
.
primary
(
)
)
pseudos
:
EagerPseudoCascadeInputs
:
:
new_from_style
(
&
data
.
styles
.
pseudos
)
}
}
}
pub
struct
CurrentElementInfo
{
element
:
OpaqueNode
is_initial_style
:
bool
#
[
allow
(
dead_code
)
]
pub
possibly_expired_animations
:
Vec
<
PropertyAnimation
>
}
#
[
derive
(
Default
)
]
pub
struct
TraversalStatistics
{
pub
elements_traversed
:
u32
pub
elements_styled
:
u32
pub
elements_matched
:
u32
pub
styles_shared
:
u32
pub
selectors
:
u32
pub
revalidation_selectors
:
u32
pub
dependency_selectors
:
u32
pub
declarations
:
u32
pub
stylist_rebuilds
:
u32
pub
traversal_time_ms
:
f64
pub
is_parallel
:
Option
<
bool
>
pub
is_large
:
Option
<
bool
>
}
impl
<
'
a
>
ops
:
:
Add
for
&
'
a
TraversalStatistics
{
type
Output
=
TraversalStatistics
;
fn
add
(
self
other
:
Self
)
-
>
TraversalStatistics
{
debug_assert
!
(
self
.
traversal_time_ms
=
=
0
.
0
&
&
other
.
traversal_time_ms
=
=
0
.
0
"
traversal_time_ms
should
be
set
at
the
end
by
the
caller
"
)
;
debug_assert
!
(
self
.
selectors
=
=
0
"
set
at
the
end
"
)
;
debug_assert
!
(
self
.
revalidation_selectors
=
=
0
"
set
at
the
end
"
)
;
debug_assert
!
(
self
.
dependency_selectors
=
=
0
"
set
at
the
end
"
)
;
debug_assert
!
(
self
.
declarations
=
=
0
"
set
at
the
end
"
)
;
debug_assert
!
(
self
.
stylist_rebuilds
=
=
0
"
set
at
the
end
"
)
;
TraversalStatistics
{
elements_traversed
:
self
.
elements_traversed
+
other
.
elements_traversed
elements_styled
:
self
.
elements_styled
+
other
.
elements_styled
elements_matched
:
self
.
elements_matched
+
other
.
elements_matched
styles_shared
:
self
.
styles_shared
+
other
.
styles_shared
selectors
:
0
revalidation_selectors
:
0
dependency_selectors
:
0
declarations
:
0
stylist_rebuilds
:
0
traversal_time_ms
:
0
.
0
is_parallel
:
None
is_large
:
None
}
}
}
impl
fmt
:
:
Display
for
TraversalStatistics
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
debug_assert
!
(
self
.
traversal_time_ms
!
=
0
.
0
"
should
have
set
traversal
time
"
)
;
writeln
!
(
f
"
[
PERF
]
perf
block
start
"
)
?
;
writeln
!
(
f
"
[
PERF
]
traversal
{
}
"
if
self
.
is_parallel
.
unwrap
(
)
{
"
parallel
"
}
else
{
"
sequential
"
}
)
?
;
writeln
!
(
f
"
[
PERF
]
elements_traversed
{
}
"
self
.
elements_traversed
)
?
;
writeln
!
(
f
"
[
PERF
]
elements_styled
{
}
"
self
.
elements_styled
)
?
;
writeln
!
(
f
"
[
PERF
]
elements_matched
{
}
"
self
.
elements_matched
)
?
;
writeln
!
(
f
"
[
PERF
]
styles_shared
{
}
"
self
.
styles_shared
)
?
;
writeln
!
(
f
"
[
PERF
]
selectors
{
}
"
self
.
selectors
)
?
;
writeln
!
(
f
"
[
PERF
]
revalidation_selectors
{
}
"
self
.
revalidation_selectors
)
?
;
writeln
!
(
f
"
[
PERF
]
dependency_selectors
{
}
"
self
.
dependency_selectors
)
?
;
writeln
!
(
f
"
[
PERF
]
declarations
{
}
"
self
.
declarations
)
?
;
writeln
!
(
f
"
[
PERF
]
stylist_rebuilds
{
}
"
self
.
stylist_rebuilds
)
?
;
writeln
!
(
f
"
[
PERF
]
traversal_time_ms
{
}
"
self
.
traversal_time_ms
)
?
;
writeln
!
(
f
"
[
PERF
]
perf
block
end
"
)
}
}
impl
TraversalStatistics
{
pub
fn
finish
<
E
D
>
(
&
mut
self
traversal
:
&
D
start
:
f64
)
where
E
:
TElement
D
:
DomTraversal
<
E
>
{
let
threshold
=
traversal
.
shared_context
(
)
.
options
.
style_statistics_threshold
;
self
.
is_parallel
=
Some
(
traversal
.
is_parallel
(
)
)
;
self
.
is_large
=
Some
(
self
.
elements_traversed
as
usize
>
=
threshold
)
;
self
.
traversal_time_ms
=
(
time
:
:
precise_time_s
(
)
-
start
)
*
1000
.
0
;
self
.
selectors
=
traversal
.
shared_context
(
)
.
stylist
.
num_selectors
(
)
as
u32
;
self
.
revalidation_selectors
=
traversal
.
shared_context
(
)
.
stylist
.
num_revalidation_selectors
(
)
as
u32
;
self
.
dependency_selectors
=
traversal
.
shared_context
(
)
.
stylist
.
invalidation_map
(
)
.
len
(
)
as
u32
;
self
.
declarations
=
traversal
.
shared_context
(
)
.
stylist
.
num_declarations
(
)
as
u32
;
self
.
stylist_rebuilds
=
traversal
.
shared_context
(
)
.
stylist
.
num_rebuilds
(
)
as
u32
;
}
pub
fn
is_large_traversal
(
&
self
)
-
>
bool
{
self
.
is_large
.
unwrap
(
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
bitflags
!
{
/
/
/
Represents
which
tasks
are
performed
in
a
SequentialTask
of
/
/
/
UpdateAnimations
which
is
a
result
of
normal
restyle
.
pub
flags
UpdateAnimationsTasks
:
u8
{
/
/
/
Update
CSS
Animations
.
const
CSS_ANIMATIONS
=
structs
:
:
UpdateAnimationsTasks_CSSAnimations
/
/
/
Update
CSS
Transitions
.
const
CSS_TRANSITIONS
=
structs
:
:
UpdateAnimationsTasks_CSSTransitions
/
/
/
Update
effect
properties
.
const
EFFECT_PROPERTIES
=
structs
:
:
UpdateAnimationsTasks_EffectProperties
/
/
/
Update
animation
cacade
results
for
animations
running
on
the
compositor
.
const
CASCADE_RESULTS
=
structs
:
:
UpdateAnimationsTasks_CascadeResults
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
bitflags
!
{
/
/
/
Represents
which
tasks
are
performed
in
a
SequentialTask
as
a
result
of
/
/
/
animation
-
only
restyle
.
pub
flags
PostAnimationTasks
:
u8
{
/
/
/
Display
property
was
changed
from
none
in
animation
-
only
restyle
so
/
/
/
that
we
need
to
resolve
styles
for
descendants
in
a
subsequent
/
/
/
normal
restyle
.
const
DISPLAY_CHANGED_FROM_NONE_FOR_SMIL
=
0x01
}
}
pub
enum
SequentialTask
<
E
:
TElement
>
{
Unused
(
SendElement
<
E
>
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
UpdateAnimations
{
el
:
SendElement
<
E
>
before_change_style
:
Option
<
Arc
<
ComputedValues
>
>
tasks
:
UpdateAnimationsTasks
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
PostAnimation
{
el
:
SendElement
<
E
>
tasks
:
PostAnimationTasks
}
}
impl
<
E
:
TElement
>
SequentialTask
<
E
>
{
pub
fn
execute
(
self
)
{
use
self
:
:
SequentialTask
:
:
*
;
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
match
self
{
Unused
(
_
)
=
>
unreachable
!
(
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
UpdateAnimations
{
el
before_change_style
tasks
}
=
>
{
unsafe
{
el
.
update_animations
(
before_change_style
tasks
)
}
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
PostAnimation
{
el
tasks
}
=
>
{
unsafe
{
el
.
process_post_animation
(
tasks
)
}
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
update_animations
(
el
:
E
before_change_style
:
Option
<
Arc
<
ComputedValues
>
>
tasks
:
UpdateAnimationsTasks
)
-
>
Self
{
use
self
:
:
SequentialTask
:
:
*
;
UpdateAnimations
{
el
:
unsafe
{
SendElement
:
:
new
(
el
)
}
before_change_style
:
before_change_style
tasks
:
tasks
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
process_post_animation
(
el
:
E
tasks
:
PostAnimationTasks
)
-
>
Self
{
use
self
:
:
SequentialTask
:
:
*
;
PostAnimation
{
el
:
unsafe
{
SendElement
:
:
new
(
el
)
}
tasks
:
tasks
}
}
}
pub
struct
SelectorFlagsMap
<
E
:
TElement
>
{
map
:
FnvHashMap
<
SendElement
<
E
>
ElementSelectorFlags
>
cache
:
LRUCache
<
[
(
SendElement
<
E
>
ElementSelectorFlags
)
;
4
+
1
]
>
}
#
[
cfg
(
debug_assertions
)
]
impl
<
E
:
TElement
>
Drop
for
SelectorFlagsMap
<
E
>
{
fn
drop
(
&
mut
self
)
{
debug_assert
!
(
self
.
map
.
is_empty
(
)
)
;
}
}
impl
<
E
:
TElement
>
SelectorFlagsMap
<
E
>
{
pub
fn
new
(
)
-
>
Self
{
SelectorFlagsMap
{
map
:
FnvHashMap
:
:
default
(
)
cache
:
LRUCache
:
:
new
(
)
}
}
pub
fn
insert_flags
(
&
mut
self
element
:
E
flags
:
ElementSelectorFlags
)
{
let
el
=
unsafe
{
SendElement
:
:
new
(
element
)
}
;
if
self
.
cache
.
iter
(
)
.
find
(
|
x
|
x
.
0
=
=
el
)
.
map_or
(
ElementSelectorFlags
:
:
empty
(
)
|
x
|
x
.
1
)
.
contains
(
flags
)
{
return
;
}
let
f
=
self
.
map
.
entry
(
el
)
.
or_insert
(
ElementSelectorFlags
:
:
empty
(
)
)
;
*
f
|
=
flags
;
self
.
cache
.
insert
(
(
unsafe
{
SendElement
:
:
new
(
element
)
}
*
f
)
)
}
pub
fn
apply_flags
(
&
mut
self
)
{
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
for
(
el
flags
)
in
self
.
map
.
drain
(
)
{
unsafe
{
el
.
set_selector_flags
(
flags
)
;
}
}
}
}
pub
struct
SequentialTaskList
<
E
>
(
Vec
<
SequentialTask
<
E
>
>
)
where
E
:
TElement
;
impl
<
E
>
ops
:
:
Deref
for
SequentialTaskList
<
E
>
where
E
:
TElement
{
type
Target
=
Vec
<
SequentialTask
<
E
>
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
<
E
>
ops
:
:
DerefMut
for
SequentialTaskList
<
E
>
where
E
:
TElement
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
impl
<
E
>
Drop
for
SequentialTaskList
<
E
>
where
E
:
TElement
{
fn
drop
(
&
mut
self
)
{
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
for
task
in
self
.
0
.
drain
(
.
.
)
{
task
.
execute
(
)
}
}
}
pub
struct
ThreadLocalStyleContext
<
E
:
TElement
>
{
pub
style_sharing_candidate_cache
:
StyleSharingCandidateCache
<
E
>
pub
bloom_filter
:
StyleBloom
<
E
>
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
new_animations_sender
:
Sender
<
Animation
>
pub
tasks
:
SequentialTaskList
<
E
>
pub
selector_flags
:
SelectorFlagsMap
<
E
>
pub
statistics
:
TraversalStatistics
pub
current_element_info
:
Option
<
CurrentElementInfo
>
pub
font_metrics_provider
:
E
:
:
FontMetricsProvider
}
impl
<
E
:
TElement
>
ThreadLocalStyleContext
<
E
>
{
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
new
(
shared
:
&
SharedStyleContext
)
-
>
Self
{
ThreadLocalStyleContext
{
style_sharing_candidate_cache
:
StyleSharingCandidateCache
:
:
new
(
)
bloom_filter
:
StyleBloom
:
:
new
(
)
new_animations_sender
:
shared
.
local_context_creation_data
.
lock
(
)
.
unwrap
(
)
.
new_animations_sender
.
clone
(
)
tasks
:
SequentialTaskList
(
Vec
:
:
new
(
)
)
selector_flags
:
SelectorFlagsMap
:
:
new
(
)
statistics
:
TraversalStatistics
:
:
default
(
)
current_element_info
:
None
font_metrics_provider
:
E
:
:
FontMetricsProvider
:
:
create_from
(
shared
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
new
(
shared
:
&
SharedStyleContext
)
-
>
Self
{
ThreadLocalStyleContext
{
style_sharing_candidate_cache
:
StyleSharingCandidateCache
:
:
new
(
)
bloom_filter
:
StyleBloom
:
:
new
(
)
tasks
:
SequentialTaskList
(
Vec
:
:
new
(
)
)
selector_flags
:
SelectorFlagsMap
:
:
new
(
)
statistics
:
TraversalStatistics
:
:
default
(
)
current_element_info
:
None
font_metrics_provider
:
E
:
:
FontMetricsProvider
:
:
create_from
(
shared
)
}
}
pub
fn
begin_element
(
&
mut
self
element
:
E
data
:
&
ElementData
)
{
debug_assert
!
(
self
.
current_element_info
.
is_none
(
)
)
;
self
.
current_element_info
=
Some
(
CurrentElementInfo
{
element
:
element
.
as_node
(
)
.
opaque
(
)
is_initial_style
:
!
data
.
has_styles
(
)
possibly_expired_animations
:
Vec
:
:
new
(
)
}
)
;
}
pub
fn
end_element
(
&
mut
self
element
:
E
)
{
debug_assert
!
(
self
.
current_element_info
.
is_some
(
)
)
;
debug_assert
!
(
self
.
current_element_info
.
as_ref
(
)
.
unwrap
(
)
.
element
=
=
element
.
as_node
(
)
.
opaque
(
)
)
;
self
.
current_element_info
=
None
;
}
pub
fn
is_initial_style
(
&
self
)
-
>
bool
{
self
.
current_element_info
.
as_ref
(
)
.
unwrap
(
)
.
is_initial_style
}
}
impl
<
E
:
TElement
>
Drop
for
ThreadLocalStyleContext
<
E
>
{
fn
drop
(
&
mut
self
)
{
debug_assert
!
(
self
.
current_element_info
.
is_none
(
)
)
;
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
self
.
selector_flags
.
apply_flags
(
)
;
}
}
pub
struct
StyleContext
<
'
a
E
:
TElement
+
'
a
>
{
pub
shared
:
&
'
a
SharedStyleContext
<
'
a
>
pub
thread_local
:
&
'
a
mut
ThreadLocalStyleContext
<
E
>
}
#
[
derive
(
PartialEq
Copy
Clone
Debug
)
]
pub
enum
ReflowGoal
{
ForDisplay
ForScriptQuery
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
trait
RegisteredSpeculativePainter
:
SpeculativePainter
{
fn
name
(
&
self
)
-
>
Atom
;
fn
properties
(
&
self
)
-
>
&
FnvHashMap
<
Atom
PropertyId
>
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
trait
RegisteredSpeculativePainters
:
Sync
{
fn
get
(
&
self
name
:
&
Atom
)
-
>
Option
<
&
RegisteredSpeculativePainter
>
;
}
