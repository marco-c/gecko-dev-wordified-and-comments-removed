#
!
[
deny
(
missing_docs
)
]
use
animation
:
:
Animation
;
use
app_units
:
:
Au
;
use
bloom
:
:
StyleBloom
;
use
data
:
:
ElementData
;
use
dom
:
:
{
OpaqueNode
TNode
TElement
SendElement
}
;
use
error_reporting
:
:
ParseErrorReporter
;
use
euclid
:
:
Size2D
;
use
matching
:
:
StyleSharingCandidateCache
;
use
parking_lot
:
:
RwLock
;
use
properties
:
:
ComputedValues
;
use
selectors
:
:
matching
:
:
ElementSelectorFlags
;
use
servo_config
:
:
opts
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
env
;
use
std
:
:
fmt
;
use
std
:
:
ops
:
:
Add
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
std
:
:
sync
:
:
mpsc
:
:
Sender
;
use
stylist
:
:
Stylist
;
use
thread_state
;
use
time
;
use
timer
:
:
Timer
;
pub
struct
ThreadLocalStyleContextCreationInfo
{
new_animations_sender
:
Sender
<
Animation
>
}
impl
ThreadLocalStyleContextCreationInfo
{
pub
fn
new
(
animations_sender
:
Sender
<
Animation
>
)
-
>
Self
{
ThreadLocalStyleContextCreationInfo
{
new_animations_sender
:
animations_sender
}
}
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
Hash
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
QuirksMode
{
Quirks
LimitedQuirks
NoQuirks
}
pub
struct
SharedStyleContext
{
pub
viewport_size
:
Size2D
<
Au
>
pub
screen_size_changed
:
bool
pub
stylist
:
Arc
<
Stylist
>
pub
goal
:
ReflowGoal
pub
running_animations
:
Arc
<
RwLock
<
HashMap
<
OpaqueNode
Vec
<
Animation
>
>
>
>
pub
expired_animations
:
Arc
<
RwLock
<
HashMap
<
OpaqueNode
Vec
<
Animation
>
>
>
>
pub
error_reporter
:
Box
<
ParseErrorReporter
+
Sync
>
pub
local_context_creation_data
:
Mutex
<
ThreadLocalStyleContextCreationInfo
>
pub
timer
:
Timer
pub
quirks_mode
:
QuirksMode
pub
default_computed_values
:
Arc
<
ComputedValues
>
}
struct
CurrentElementInfo
{
element
:
OpaqueNode
is_initial_style
:
bool
}
#
[
derive
(
Default
)
]
pub
struct
TraversalStatistics
{
pub
elements_traversed
:
u32
pub
elements_styled
:
u32
pub
elements_matched
:
u32
pub
styles_shared
:
u32
pub
traversal_time_ms
:
f64
}
impl
<
'
a
>
Add
for
&
'
a
TraversalStatistics
{
type
Output
=
TraversalStatistics
;
fn
add
(
self
other
:
Self
)
-
>
TraversalStatistics
{
debug_assert
!
(
self
.
traversal_time_ms
=
=
0
.
0
&
&
other
.
traversal_time_ms
=
=
0
.
0
"
traversal_time_ms
should
be
set
at
the
end
by
the
caller
"
)
;
TraversalStatistics
{
elements_traversed
:
self
.
elements_traversed
+
other
.
elements_traversed
elements_styled
:
self
.
elements_styled
+
other
.
elements_styled
elements_matched
:
self
.
elements_matched
+
other
.
elements_matched
styles_shared
:
self
.
styles_shared
+
other
.
styles_shared
traversal_time_ms
:
0
.
0
}
}
}
impl
fmt
:
:
Display
for
TraversalStatistics
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
debug_assert
!
(
self
.
traversal_time_ms
!
=
0
.
0
"
should
have
set
traversal
time
"
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
perf
block
start
"
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
elements_traversed
{
}
"
self
.
elements_traversed
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
elements_styled
{
}
"
self
.
elements_styled
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
elements_matched
{
}
"
self
.
elements_matched
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
styles_shared
{
}
"
self
.
styles_shared
)
)
;
try
!
(
writeln
!
(
f
"
[
PERF
]
traversal_time_ms
{
}
"
self
.
traversal_time_ms
)
)
;
writeln
!
(
f
"
[
PERF
]
perf
block
end
"
)
}
}
lazy_static
!
{
/
/
/
Whether
to
dump
style
statistics
computed
statically
.
We
use
an
environmental
/
/
/
variable
so
that
this
is
easy
to
set
for
Gecko
builds
and
matches
the
/
/
/
mechanism
we
use
to
dump
statistics
on
the
Gecko
style
system
.
static
ref
DUMP_STYLE_STATISTICS
:
bool
=
{
match
env
:
:
var
(
"
DUMP_STYLE_STATISTICS
"
)
{
Ok
(
s
)
=
>
!
s
.
is_empty
(
)
Err
(
_
)
=
>
false
}
}
;
}
impl
TraversalStatistics
{
pub
fn
should_dump
(
)
-
>
bool
{
*
DUMP_STYLE_STATISTICS
|
|
opts
:
:
get
(
)
.
style_sharing_stats
}
pub
fn
compute_traversal_time
(
&
mut
self
start
:
f64
)
{
self
.
traversal_time_ms
=
(
time
:
:
precise_time_s
(
)
-
start
)
*
1000
.
0
;
}
}
pub
enum
SequentialTask
<
E
:
TElement
>
{
SetSelectorFlags
(
SendElement
<
E
>
ElementSelectorFlags
)
}
impl
<
E
:
TElement
>
SequentialTask
<
E
>
{
pub
fn
execute
(
self
)
{
use
self
:
:
SequentialTask
:
:
*
;
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
match
self
{
SetSelectorFlags
(
el
flags
)
=
>
{
unsafe
{
el
.
set_selector_flags
(
flags
)
}
;
}
}
}
pub
fn
set_selector_flags
(
el
:
E
flags
:
ElementSelectorFlags
)
-
>
Self
{
use
self
:
:
SequentialTask
:
:
*
;
SetSelectorFlags
(
unsafe
{
SendElement
:
:
new
(
el
)
}
flags
)
}
}
pub
struct
ThreadLocalStyleContext
<
E
:
TElement
>
{
pub
style_sharing_candidate_cache
:
StyleSharingCandidateCache
<
E
>
pub
bloom_filter
:
StyleBloom
<
E
>
pub
new_animations_sender
:
Sender
<
Animation
>
pub
tasks
:
Vec
<
SequentialTask
<
E
>
>
pub
statistics
:
TraversalStatistics
current_element_info
:
Option
<
CurrentElementInfo
>
}
impl
<
E
:
TElement
>
ThreadLocalStyleContext
<
E
>
{
pub
fn
new
(
shared
:
&
SharedStyleContext
)
-
>
Self
{
ThreadLocalStyleContext
{
style_sharing_candidate_cache
:
StyleSharingCandidateCache
:
:
new
(
)
bloom_filter
:
StyleBloom
:
:
new
(
)
new_animations_sender
:
shared
.
local_context_creation_data
.
lock
(
)
.
unwrap
(
)
.
new_animations_sender
.
clone
(
)
tasks
:
Vec
:
:
new
(
)
statistics
:
TraversalStatistics
:
:
default
(
)
current_element_info
:
None
}
}
pub
fn
begin_element
(
&
mut
self
element
:
E
data
:
&
ElementData
)
{
debug_assert
!
(
self
.
current_element_info
.
is_none
(
)
)
;
self
.
current_element_info
=
Some
(
CurrentElementInfo
{
element
:
element
.
as_node
(
)
.
opaque
(
)
is_initial_style
:
!
data
.
has_styles
(
)
}
)
;
}
pub
fn
end_element
(
&
mut
self
element
:
E
)
{
debug_assert
!
(
self
.
current_element_info
.
is_some
(
)
)
;
debug_assert
!
(
self
.
current_element_info
.
as_ref
(
)
.
unwrap
(
)
.
element
=
=
element
.
as_node
(
)
.
opaque
(
)
)
;
self
.
current_element_info
=
None
;
}
pub
fn
is_initial_style
(
&
self
)
-
>
bool
{
self
.
current_element_info
.
as_ref
(
)
.
unwrap
(
)
.
is_initial_style
}
}
impl
<
E
:
TElement
>
Drop
for
ThreadLocalStyleContext
<
E
>
{
fn
drop
(
&
mut
self
)
{
debug_assert
!
(
self
.
current_element_info
.
is_none
(
)
)
;
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
for
task
in
self
.
tasks
.
drain
(
.
.
)
{
task
.
execute
(
)
;
}
}
}
pub
struct
StyleContext
<
'
a
E
:
TElement
+
'
a
>
{
pub
shared
:
&
'
a
SharedStyleContext
pub
thread_local
:
&
'
a
mut
ThreadLocalStyleContext
<
E
>
}
#
[
derive
(
PartialEq
Copy
Clone
Debug
)
]
pub
enum
ReflowGoal
{
ForDisplay
ForScriptQuery
}
