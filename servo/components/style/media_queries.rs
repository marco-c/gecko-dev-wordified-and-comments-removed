use
Atom
;
use
cssparser
:
:
{
Delimiter
Parser
Token
}
;
use
serialize_comma_separated_list
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
fmt
;
use
style_traits
:
:
ToCss
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
use
servo
:
:
media_queries
:
:
{
Device
Expression
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
gecko
:
:
media_queries
:
:
{
Device
Expression
}
;
#
[
derive
(
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
MediaList
{
pub
media_queries
:
Vec
<
MediaQuery
>
}
impl
ToCss
for
MediaList
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
serialize_comma_separated_list
(
dest
&
self
.
media_queries
)
}
}
impl
Default
for
MediaList
{
fn
default
(
)
-
>
MediaList
{
MediaList
{
media_queries
:
vec
!
[
]
}
}
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
Qualifier
{
Only
Not
}
impl
ToCss
for
Qualifier
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
Qualifier
:
:
Not
=
>
write
!
(
dest
"
not
"
)
Qualifier
:
:
Only
=
>
write
!
(
dest
"
only
"
)
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
MediaQuery
{
pub
qualifier
:
Option
<
Qualifier
>
pub
media_type
:
MediaQueryType
pub
expressions
:
Vec
<
Expression
>
}
impl
MediaQuery
{
fn
never_matching
(
)
-
>
Self
{
Self
:
:
new
(
Some
(
Qualifier
:
:
Not
)
MediaQueryType
:
:
All
vec
!
[
]
)
}
pub
fn
new
(
qualifier
:
Option
<
Qualifier
>
media_type
:
MediaQueryType
expressions
:
Vec
<
Expression
>
)
-
>
MediaQuery
{
MediaQuery
{
qualifier
:
qualifier
media_type
:
media_type
expressions
:
expressions
}
}
}
impl
ToCss
for
MediaQuery
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
if
let
Some
(
qual
)
=
self
.
qualifier
{
try
!
(
qual
.
to_css
(
dest
)
)
;
try
!
(
write
!
(
dest
"
"
)
)
;
}
match
self
.
media_type
{
MediaQueryType
:
:
All
=
>
{
if
self
.
qualifier
.
is_some
(
)
|
|
self
.
expressions
.
is_empty
(
)
{
try
!
(
write
!
(
dest
"
all
"
)
)
;
}
}
MediaQueryType
:
:
Known
(
MediaType
:
:
Screen
)
=
>
try
!
(
write
!
(
dest
"
screen
"
)
)
MediaQueryType
:
:
Known
(
MediaType
:
:
Print
)
=
>
try
!
(
write
!
(
dest
"
print
"
)
)
MediaQueryType
:
:
Unknown
(
ref
desc
)
=
>
try
!
(
write
!
(
dest
"
{
}
"
desc
)
)
}
if
self
.
expressions
.
is_empty
(
)
{
return
Ok
(
(
)
)
;
}
if
self
.
media_type
!
=
MediaQueryType
:
:
All
|
|
self
.
qualifier
.
is_some
(
)
{
try
!
(
write
!
(
dest
"
and
"
)
)
;
}
try
!
(
self
.
expressions
[
0
]
.
to_css
(
dest
)
)
;
for
expr
in
self
.
expressions
.
iter
(
)
.
skip
(
1
)
{
try
!
(
write
!
(
dest
"
and
"
)
)
;
try
!
(
expr
.
to_css
(
dest
)
)
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
PartialEq
Eq
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
MediaQueryType
{
All
Known
(
MediaType
)
Unknown
(
Atom
)
}
impl
MediaQueryType
{
fn
parse
(
ident
:
&
str
)
-
>
Self
{
if
ident
.
eq_ignore_ascii_case
(
"
all
"
)
{
return
MediaQueryType
:
:
All
;
}
match
MediaType
:
:
parse
(
ident
)
{
Some
(
media_type
)
=
>
MediaQueryType
:
:
Known
(
media_type
)
None
=
>
MediaQueryType
:
:
Unknown
(
Atom
:
:
from
(
ident
)
)
}
}
fn
matches
(
&
self
other
:
MediaType
)
-
>
bool
{
match
*
self
{
MediaQueryType
:
:
All
=
>
true
MediaQueryType
:
:
Known
(
ref
known_type
)
=
>
*
known_type
=
=
other
MediaQueryType
:
:
Unknown
(
.
.
)
=
>
false
}
}
}
#
[
derive
(
PartialEq
Eq
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
MediaType
{
Screen
Print
}
impl
MediaType
{
fn
parse
(
name
:
&
str
)
-
>
Option
<
Self
>
{
Some
(
match_ignore_ascii_case
!
{
name
"
screen
"
=
>
MediaType
:
:
Screen
"
print
"
=
>
MediaType
:
:
Print
_
=
>
return
None
}
)
}
}
impl
MediaQuery
{
pub
fn
parse
(
input
:
&
mut
Parser
)
-
>
Result
<
MediaQuery
(
)
>
{
let
mut
expressions
=
vec
!
[
]
;
let
qualifier
=
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
only
"
)
)
.
is_ok
(
)
{
Some
(
Qualifier
:
:
Only
)
}
else
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
not
"
)
)
.
is_ok
(
)
{
Some
(
Qualifier
:
:
Not
)
}
else
{
None
}
;
let
media_type
=
match
input
.
try
(
|
input
|
input
.
expect_ident
(
)
)
{
Ok
(
ident
)
=
>
MediaQueryType
:
:
parse
(
&
*
ident
)
Err
(
(
)
)
=
>
{
if
qualifier
.
is_some
(
)
{
return
Err
(
(
)
)
}
expressions
.
push
(
try
!
(
Expression
:
:
parse
(
input
)
)
)
;
MediaQueryType
:
:
All
}
}
;
loop
{
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
and
"
)
)
.
is_err
(
)
{
return
Ok
(
MediaQuery
:
:
new
(
qualifier
media_type
expressions
)
)
}
expressions
.
push
(
try
!
(
Expression
:
:
parse
(
input
)
)
)
}
}
}
pub
fn
parse_media_query_list
(
input
:
&
mut
Parser
)
-
>
MediaList
{
if
input
.
is_exhausted
(
)
{
return
Default
:
:
default
(
)
}
let
mut
media_queries
=
vec
!
[
]
;
let
mut
found_invalid
=
false
;
loop
{
match
input
.
parse_until_before
(
Delimiter
:
:
Comma
MediaQuery
:
:
parse
)
{
Ok
(
mq
)
=
>
if
!
found_invalid
{
media_queries
.
push
(
mq
)
;
}
Err
(
.
.
)
=
>
if
!
found_invalid
{
media_queries
.
clear
(
)
;
media_queries
.
push
(
MediaQuery
:
:
never_matching
(
)
)
;
found_invalid
=
true
;
}
}
match
input
.
next
(
)
{
Ok
(
Token
:
:
Comma
)
=
>
{
}
Ok
(
_
)
=
>
unreachable
!
(
)
Err
(
(
)
)
=
>
break
}
}
debug_assert
!
(
!
found_invalid
|
|
media_queries
.
len
(
)
=
=
1
)
;
MediaList
{
media_queries
:
media_queries
}
}
impl
MediaList
{
pub
fn
evaluate
(
&
self
device
:
&
Device
)
-
>
bool
{
self
.
media_queries
.
is_empty
(
)
|
|
self
.
media_queries
.
iter
(
)
.
any
(
|
mq
|
{
let
media_match
=
mq
.
media_type
.
matches
(
device
.
media_type
(
)
)
;
let
query_match
=
media_match
&
&
mq
.
expressions
.
iter
(
)
.
all
(
|
expression
|
expression
.
matches
(
&
device
)
)
;
match
mq
.
qualifier
{
Some
(
Qualifier
:
:
Not
)
=
>
!
query_match
_
=
>
query_match
}
}
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
media_queries
.
is_empty
(
)
}
}
