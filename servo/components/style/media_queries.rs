use
Atom
;
use
context
:
:
QuirksMode
;
use
cssparser
:
:
{
Delimiter
Parser
Token
ParserInput
}
;
use
parser
:
:
ParserContext
;
use
selectors
:
:
parser
:
:
SelectorParseError
;
use
serialize_comma_separated_list
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
fmt
;
use
style_traits
:
:
{
ToCss
ParseError
StyleParseError
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
use
servo
:
:
media_queries
:
:
{
Device
Expression
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
gecko
:
:
media_queries
:
:
{
Device
Expression
}
;
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
MediaList
{
pub
media_queries
:
Vec
<
MediaQuery
>
}
impl
ToCss
for
MediaList
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
serialize_comma_separated_list
(
dest
&
self
.
media_queries
)
}
}
impl
MediaList
{
pub
fn
empty
(
)
-
>
Self
{
MediaList
{
media_queries
:
vec
!
[
]
}
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
ToCss
)
]
pub
enum
Qualifier
{
Only
Not
}
#
[
derive
(
PartialEq
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
MediaQuery
{
pub
qualifier
:
Option
<
Qualifier
>
pub
media_type
:
MediaQueryType
pub
expressions
:
Vec
<
Expression
>
}
impl
MediaQuery
{
fn
never_matching
(
)
-
>
Self
{
Self
:
:
new
(
Some
(
Qualifier
:
:
Not
)
MediaQueryType
:
:
All
vec
!
[
]
)
}
pub
fn
new
(
qualifier
:
Option
<
Qualifier
>
media_type
:
MediaQueryType
expressions
:
Vec
<
Expression
>
)
-
>
MediaQuery
{
MediaQuery
{
qualifier
:
qualifier
media_type
:
media_type
expressions
:
expressions
}
}
}
impl
ToCss
for
MediaQuery
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
if
let
Some
(
qual
)
=
self
.
qualifier
{
qual
.
to_css
(
dest
)
?
;
write
!
(
dest
"
"
)
?
;
}
match
self
.
media_type
{
MediaQueryType
:
:
All
=
>
{
if
self
.
qualifier
.
is_some
(
)
|
|
self
.
expressions
.
is_empty
(
)
{
write
!
(
dest
"
all
"
)
?
;
}
}
MediaQueryType
:
:
Known
(
MediaType
:
:
Screen
)
=
>
write
!
(
dest
"
screen
"
)
?
MediaQueryType
:
:
Known
(
MediaType
:
:
Print
)
=
>
write
!
(
dest
"
print
"
)
?
MediaQueryType
:
:
Unknown
(
ref
desc
)
=
>
write
!
(
dest
"
{
}
"
desc
)
?
}
if
self
.
expressions
.
is_empty
(
)
{
return
Ok
(
(
)
)
;
}
if
self
.
media_type
!
=
MediaQueryType
:
:
All
|
|
self
.
qualifier
.
is_some
(
)
{
write
!
(
dest
"
and
"
)
?
;
}
self
.
expressions
[
0
]
.
to_css
(
dest
)
?
;
for
expr
in
self
.
expressions
.
iter
(
)
.
skip
(
1
)
{
write
!
(
dest
"
and
"
)
?
;
expr
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
PartialEq
Eq
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
MediaQueryType
{
All
Known
(
MediaType
)
Unknown
(
Atom
)
}
impl
MediaQueryType
{
fn
parse
(
ident
:
&
str
)
-
>
Result
<
Self
(
)
>
{
if
ident
.
eq_ignore_ascii_case
(
"
all
"
)
{
return
Ok
(
MediaQueryType
:
:
All
)
;
}
if
ident
.
eq_ignore_ascii_case
(
"
not
"
)
|
|
ident
.
eq_ignore_ascii_case
(
"
or
"
)
|
|
ident
.
eq_ignore_ascii_case
(
"
and
"
)
|
|
ident
.
eq_ignore_ascii_case
(
"
only
"
)
{
return
Err
(
(
)
)
}
Ok
(
match
MediaType
:
:
parse
(
ident
)
{
Some
(
media_type
)
=
>
MediaQueryType
:
:
Known
(
media_type
)
None
=
>
MediaQueryType
:
:
Unknown
(
Atom
:
:
from
(
ident
)
)
}
)
}
fn
matches
(
&
self
other
:
MediaType
)
-
>
bool
{
match
*
self
{
MediaQueryType
:
:
All
=
>
true
MediaQueryType
:
:
Known
(
ref
known_type
)
=
>
*
known_type
=
=
other
MediaQueryType
:
:
Unknown
(
.
.
)
=
>
false
}
}
}
#
[
derive
(
PartialEq
Eq
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
MediaType
{
Screen
Print
}
impl
MediaType
{
fn
parse
(
name
:
&
str
)
-
>
Option
<
Self
>
{
Some
(
match_ignore_ascii_case
!
{
name
"
screen
"
=
>
MediaType
:
:
Screen
"
print
"
=
>
MediaType
:
:
Print
_
=
>
return
None
}
)
}
}
impl
MediaQuery
{
pub
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
MediaQuery
ParseError
<
'
i
>
>
{
let
mut
expressions
=
vec
!
[
]
;
let
qualifier
=
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
only
"
)
)
.
is_ok
(
)
{
Some
(
Qualifier
:
:
Only
)
}
else
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
not
"
)
)
.
is_ok
(
)
{
Some
(
Qualifier
:
:
Not
)
}
else
{
None
}
;
let
media_type
=
match
input
.
try
(
|
i
|
i
.
expect_ident_cloned
(
)
)
{
Ok
(
ident
)
=
>
{
let
result
:
Result
<
_
ParseError
>
=
MediaQueryType
:
:
parse
(
&
*
ident
)
.
map_err
(
|
(
)
|
SelectorParseError
:
:
UnexpectedIdent
(
ident
.
clone
(
)
)
.
into
(
)
)
;
result
?
}
Err
(
_
)
=
>
{
if
qualifier
.
is_some
(
)
{
return
Err
(
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
expressions
.
push
(
Expression
:
:
parse
(
context
input
)
?
)
;
MediaQueryType
:
:
All
}
}
;
loop
{
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
and
"
)
)
.
is_err
(
)
{
return
Ok
(
MediaQuery
:
:
new
(
qualifier
media_type
expressions
)
)
}
expressions
.
push
(
Expression
:
:
parse
(
context
input
)
?
)
}
}
}
pub
fn
parse_media_query_list
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
MediaList
{
if
input
.
is_exhausted
(
)
{
return
MediaList
:
:
empty
(
)
}
let
mut
media_queries
=
vec
!
[
]
;
loop
{
match
input
.
parse_until_before
(
Delimiter
:
:
Comma
|
i
|
MediaQuery
:
:
parse
(
context
i
)
)
{
Ok
(
mq
)
=
>
{
media_queries
.
push
(
mq
)
;
}
Err
(
.
.
)
=
>
{
media_queries
.
push
(
MediaQuery
:
:
never_matching
(
)
)
;
}
}
match
input
.
next
(
)
{
Ok
(
&
Token
:
:
Comma
)
=
>
{
}
Ok
(
_
)
=
>
unreachable
!
(
)
Err
(
_
)
=
>
break
}
}
MediaList
{
media_queries
:
media_queries
}
}
impl
MediaList
{
pub
fn
evaluate
(
&
self
device
:
&
Device
quirks_mode
:
QuirksMode
)
-
>
bool
{
self
.
media_queries
.
is_empty
(
)
|
|
self
.
media_queries
.
iter
(
)
.
any
(
|
mq
|
{
let
media_match
=
mq
.
media_type
.
matches
(
device
.
media_type
(
)
)
;
let
query_match
=
media_match
&
&
mq
.
expressions
.
iter
(
)
.
all
(
|
expression
|
expression
.
matches
(
&
device
quirks_mode
)
)
;
match
mq
.
qualifier
{
Some
(
Qualifier
:
:
Not
)
=
>
!
query_match
_
=
>
query_match
}
}
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
media_queries
.
is_empty
(
)
}
pub
fn
append_medium
(
&
mut
self
context
:
&
ParserContext
new_medium
:
&
str
)
-
>
bool
{
let
mut
input
=
ParserInput
:
:
new
(
new_medium
)
;
let
mut
parser
=
Parser
:
:
new
(
&
mut
input
)
;
let
new_query
=
match
MediaQuery
:
:
parse
(
&
context
&
mut
parser
)
{
Ok
(
query
)
=
>
query
Err
(
_
)
=
>
{
return
false
;
}
}
;
self
.
media_queries
.
retain
(
|
query
|
query
!
=
&
new_query
)
;
self
.
media_queries
.
push
(
new_query
)
;
true
}
pub
fn
delete_medium
(
&
mut
self
context
:
&
ParserContext
old_medium
:
&
str
)
-
>
bool
{
let
mut
input
=
ParserInput
:
:
new
(
old_medium
)
;
let
mut
parser
=
Parser
:
:
new
(
&
mut
input
)
;
let
old_query
=
match
MediaQuery
:
:
parse
(
context
&
mut
parser
)
{
Ok
(
query
)
=
>
query
Err
(
_
)
=
>
{
return
false
;
}
}
;
let
old_len
=
self
.
media_queries
.
len
(
)
;
self
.
media_queries
.
retain
(
|
query
|
query
!
=
&
old_query
)
;
old_len
!
=
self
.
media_queries
.
len
(
)
}
}
