use
crate
:
:
context
:
:
StyleSystemOptions
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
gecko_bindings
:
:
bindings
;
use
crate
:
:
parallel
:
:
STYLE_THREAD_STACK_SIZE_KB
;
use
crate
:
:
shared_lock
:
:
SharedRwLock
;
use
crate
:
:
thread_state
;
use
parking_lot
:
:
{
Mutex
RwLock
RwLockReadGuard
}
;
#
[
cfg
(
unix
)
]
use
std
:
:
os
:
:
unix
:
:
thread
:
:
{
JoinHandleExt
RawPthread
}
;
#
[
cfg
(
windows
)
]
use
std
:
:
os
:
:
windows
:
:
{
io
:
:
AsRawHandle
prelude
:
:
RawHandle
}
;
use
std
:
:
{
io
thread
}
;
use
thin_vec
:
:
ThinVec
;
#
[
cfg
(
unix
)
]
pub
type
PlatformThreadHandle
=
RawPthread
;
#
[
cfg
(
windows
)
]
pub
type
PlatformThreadHandle
=
RawHandle
;
pub
struct
GlobalStyleData
{
pub
shared_lock
:
SharedRwLock
pub
options
:
StyleSystemOptions
}
pub
struct
StyleThreadPool
{
pub
num_threads
:
Option
<
usize
>
style_thread_pool
:
RwLock
<
Option
<
rayon
:
:
ThreadPool
>
>
}
fn
thread_name
(
index
:
usize
)
-
>
String
{
format
!
(
"
StyleThread
#
{
}
"
index
)
}
lazy_static
!
{
/
/
/
JoinHandles
for
spawned
style
threads
.
These
will
be
joined
during
/
/
/
StyleThreadPool
:
:
shutdown
(
)
after
exiting
the
thread
pool
.
/
/
/
/
/
/
This
would
be
quite
inefficient
if
rayon
destroyed
and
re
-
created
/
/
/
threads
regularly
during
threadpool
operation
in
response
to
demand
/
/
/
however
rayon
actually
never
destroys
its
threads
until
the
entire
/
/
/
thread
pool
is
shut
-
down
so
the
size
of
this
list
is
bounded
.
static
ref
STYLE_THREAD_JOIN_HANDLES
:
Mutex
<
Vec
<
thread
:
:
JoinHandle
<
(
)
>
>
>
=
Mutex
:
:
new
(
Vec
:
:
new
(
)
)
;
}
fn
thread_spawn
(
options
:
rayon
:
:
ThreadBuilder
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
b
=
thread
:
:
Builder
:
:
new
(
)
;
if
let
Some
(
name
)
=
options
.
name
(
)
{
b
=
b
.
name
(
name
.
to_owned
(
)
)
;
}
if
let
Some
(
stack_size
)
=
options
.
stack_size
(
)
{
b
=
b
.
stack_size
(
stack_size
)
;
}
let
join_handle
=
b
.
spawn
(
|
|
options
.
run
(
)
)
?
;
STYLE_THREAD_JOIN_HANDLES
.
lock
(
)
.
push
(
join_handle
)
;
Ok
(
(
)
)
}
fn
thread_startup
(
_index
:
usize
)
{
thread_state
:
:
initialize_layout_worker_thread
(
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
unsafe
{
bindings
:
:
Gecko_SetJemallocThreadLocalArena
(
true
)
;
let
name
=
thread_name
(
_index
)
;
gecko_profiler
:
:
register_thread
(
&
name
)
;
}
}
fn
thread_shutdown
(
_
:
usize
)
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
unsafe
{
gecko_profiler
:
:
unregister_thread
(
)
;
bindings
:
:
Gecko_SetJemallocThreadLocalArena
(
false
)
;
}
}
impl
StyleThreadPool
{
pub
fn
shutdown
(
)
{
if
STYLE_THREAD_JOIN_HANDLES
.
lock
(
)
.
is_empty
(
)
{
return
;
}
{
let
_
=
STYLE_THREAD_POOL
.
style_thread_pool
.
write
(
)
.
take
(
)
;
}
while
let
Some
(
join_handle
)
=
STYLE_THREAD_JOIN_HANDLES
.
lock
(
)
.
pop
(
)
{
let
_
=
join_handle
.
join
(
)
;
}
}
pub
fn
pool
(
&
self
)
-
>
RwLockReadGuard
<
Option
<
rayon
:
:
ThreadPool
>
>
{
self
.
style_thread_pool
.
read
(
)
}
pub
fn
get_thread_handles
(
handles
:
&
mut
ThinVec
<
PlatformThreadHandle
>
)
{
lazy_static
:
:
initialize
(
&
STYLE_THREAD_POOL
)
;
for
join_handle
in
STYLE_THREAD_JOIN_HANDLES
.
lock
(
)
.
iter
(
)
{
#
[
cfg
(
unix
)
]
let
handle
=
join_handle
.
as_pthread_t
(
)
;
#
[
cfg
(
windows
)
]
let
handle
=
join_handle
.
as_raw_handle
(
)
;
handles
.
push
(
handle
)
;
}
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
stylo_threads_pref
(
)
-
>
i32
{
style_config
:
:
get_i32
(
"
layout
.
threads
"
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
stylo_threads_pref
(
)
-
>
i32
{
static_prefs
:
:
pref
!
(
"
layout
.
css
.
stylo
-
threads
"
)
}
pub
(
crate
)
const
STYLO_MAX_THREADS
:
usize
=
6
;
lazy_static
!
{
/
/
/
Global
thread
pool
pub
static
ref
STYLE_THREAD_POOL
:
StyleThreadPool
=
{
use
std
:
:
cmp
;
/
/
We
always
set
this
pref
on
startup
before
layout
or
script
have
had
a
chance
of
/
/
accessing
(
and
thus
creating
)
the
thread
-
pool
.
let
threads_pref
:
i32
=
stylo_threads_pref
(
)
;
let
num_threads
=
if
threads_pref
>
=
0
{
threads_pref
as
usize
}
else
{
/
/
Gecko
may
wish
to
override
the
default
number
of
threads
for
example
on
/
/
systems
with
heterogeneous
CPUs
.
#
[
cfg
(
feature
=
"
gecko
"
)
]
let
num_threads
=
unsafe
{
bindings
:
:
Gecko_GetNumStyleThreads
(
)
}
;
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
let
num_threads
=
-
1
;
if
num_threads
>
=
0
{
num_threads
as
usize
}
else
{
use
num_cpus
;
/
/
The
default
heuristic
is
num_virtual_cores
*
.
75
.
This
gives
us
three
threads
on
a
/
/
hyper
-
threaded
dual
core
and
six
threads
on
a
hyper
-
threaded
quad
core
.
cmp
:
:
max
(
num_cpus
:
:
get
(
)
*
3
/
4
1
)
}
}
;
let
num_threads
=
cmp
:
:
min
(
num_threads
STYLO_MAX_THREADS
)
;
/
/
Since
the
main
-
thread
is
also
part
of
the
pool
having
one
thread
or
less
doesn
'
t
make
/
/
sense
.
let
(
pool
num_threads
)
=
if
num_threads
<
=
1
{
(
None
None
)
}
else
{
let
workers
=
rayon
:
:
ThreadPoolBuilder
:
:
new
(
)
.
spawn_handler
(
thread_spawn
)
.
use_current_thread
(
)
.
num_threads
(
num_threads
)
.
thread_name
(
thread_name
)
.
start_handler
(
thread_startup
)
.
exit_handler
(
thread_shutdown
)
.
stack_size
(
STYLE_THREAD_STACK_SIZE_KB
*
1024
)
.
build
(
)
;
(
workers
.
ok
(
)
Some
(
num_threads
)
)
}
;
StyleThreadPool
{
num_threads
style_thread_pool
:
RwLock
:
:
new
(
pool
)
}
}
;
/
/
/
Global
style
data
pub
static
ref
GLOBAL_STYLE_DATA
:
GlobalStyleData
=
GlobalStyleData
{
shared_lock
:
SharedRwLock
:
:
new_leaked
(
)
options
:
StyleSystemOptions
:
:
default
(
)
}
;
}
