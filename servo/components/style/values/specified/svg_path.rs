use
cssparser
:
:
Parser
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
iter
:
:
{
Cloned
Peekable
}
;
use
std
:
:
slice
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
use
style_traits
:
:
values
:
:
SequenceWriter
;
use
values
:
:
CSSFloat
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
)
]
pub
struct
SVGPathData
(
Box
<
[
PathCommand
]
>
)
;
impl
SVGPathData
{
#
[
inline
]
pub
fn
new
(
cmd
:
Box
<
[
PathCommand
]
>
)
-
>
Self
{
debug_assert
!
(
!
cmd
.
is_empty
(
)
)
;
SVGPathData
(
cmd
)
}
#
[
inline
]
pub
fn
commands
(
&
self
)
-
>
&
[
PathCommand
]
{
debug_assert
!
(
!
self
.
0
.
is_empty
(
)
)
;
&
self
.
0
}
}
impl
ToCss
for
SVGPathData
{
#
[
inline
]
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_char
(
'
"
'
)
?
;
{
let
mut
writer
=
SequenceWriter
:
:
new
(
dest
"
"
)
;
for
command
in
self
.
0
.
iter
(
)
{
writer
.
item
(
command
)
?
;
}
}
dest
.
write_char
(
'
"
'
)
}
}
impl
Parse
for
SVGPathData
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
path_string
=
input
.
expect_string
(
)
?
.
as_ref
(
)
;
if
path_string
.
is_empty
(
)
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
let
mut
path_parser
=
PathParser
:
:
new
(
path_string
)
;
while
skip_wsp
(
&
mut
path_parser
.
chars
)
{
if
path_parser
.
parse_subpath
(
)
.
is_err
(
)
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
}
Ok
(
SVGPathData
:
:
new
(
path_parser
.
path
.
into_boxed_slice
(
)
)
)
}
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
)
]
#
[
allow
(
missing_docs
)
]
#
[
repr
(
C
u8
)
]
pub
enum
PathCommand
{
Unknown
MoveTo
{
point
:
CoordPair
absolute
:
bool
}
LineTo
{
point
:
CoordPair
absolute
:
bool
}
HorizontalLineTo
{
x
:
CSSFloat
absolute
:
bool
}
VerticalLineTo
{
y
:
CSSFloat
absolute
:
bool
}
CurveTo
{
control1
:
CoordPair
control2
:
CoordPair
point
:
CoordPair
absolute
:
bool
}
SmoothCurveTo
{
control2
:
CoordPair
point
:
CoordPair
absolute
:
bool
}
QuadBezierCurveTo
{
control1
:
CoordPair
point
:
CoordPair
absolute
:
bool
}
SmoothQuadBezierCurveTo
{
point
:
CoordPair
absolute
:
bool
}
EllipticalArc
{
rx
:
CSSFloat
ry
:
CSSFloat
angle
:
CSSFloat
large_arc_flag
:
bool
sweep_flag
:
bool
point
:
CoordPair
absolute
:
bool
}
ClosePath
}
impl
ToCss
for
PathCommand
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
use
self
:
:
PathCommand
:
:
*
;
match
*
self
{
Unknown
=
>
dest
.
write_char
(
'
X
'
)
ClosePath
=
>
dest
.
write_char
(
'
Z
'
)
MoveTo
{
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
M
'
}
else
{
'
m
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
LineTo
{
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
L
'
}
else
{
'
l
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
CurveTo
{
control1
control2
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
C
'
}
else
{
'
c
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
control1
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
control2
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
QuadBezierCurveTo
{
control1
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
Q
'
}
else
{
'
q
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
control1
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
EllipticalArc
{
rx
ry
angle
large_arc_flag
sweep_flag
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
A
'
}
else
{
'
a
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
rx
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
ry
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
angle
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
(
large_arc_flag
as
i32
)
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
(
sweep_flag
as
i32
)
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
HorizontalLineTo
{
x
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
H
'
}
else
{
'
h
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
x
.
to_css
(
dest
)
}
VerticalLineTo
{
y
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
V
'
}
else
{
'
v
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
y
.
to_css
(
dest
)
}
SmoothCurveTo
{
control2
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
S
'
}
else
{
'
s
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
control2
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
SmoothQuadBezierCurveTo
{
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
T
'
}
else
{
'
t
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
}
}
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToCss
)
]
#
[
repr
(
C
)
]
pub
struct
CoordPair
(
CSSFloat
CSSFloat
)
;
impl
CoordPair
{
#
[
inline
]
pub
fn
new
(
x
:
CSSFloat
y
:
CSSFloat
)
-
>
Self
{
CoordPair
(
x
y
)
}
}
struct
PathParser
<
'
a
>
{
chars
:
Peekable
<
Cloned
<
slice
:
:
Iter
<
'
a
u8
>
>
>
path
:
Vec
<
PathCommand
>
}
macro_rules
!
parse_arguments
{
(
parser
:
ident
abs
:
ident
enum
:
ident
[
para
:
ident
=
>
func
:
ident
(
other_para
:
ident
=
>
other_func
:
ident
)
*
]
)
=
>
{
{
loop
{
let
para
=
func
(
&
mut
parser
.
chars
)
?
;
(
skip_comma_wsp
(
&
mut
parser
.
chars
)
;
let
other_para
=
other_func
(
&
mut
parser
.
chars
)
?
;
)
*
parser
.
path
.
push
(
PathCommand
:
:
enum
{
para
(
other_para
)
*
abs
}
)
;
/
/
End
of
string
or
the
next
character
is
a
possible
new
command
.
if
!
skip_wsp
(
&
mut
parser
.
chars
)
|
|
parser
.
chars
.
peek
(
)
.
map_or
(
true
|
c
|
c
.
is_ascii_alphabetic
(
)
)
{
break
;
}
skip_comma_wsp
(
&
mut
parser
.
chars
)
;
}
Ok
(
(
)
)
}
}
}
impl
<
'
a
>
PathParser
<
'
a
>
{
#
[
inline
]
fn
new
(
string
:
&
'
a
str
)
-
>
Self
{
PathParser
{
chars
:
string
.
as_bytes
(
)
.
iter
(
)
.
cloned
(
)
.
peekable
(
)
path
:
Vec
:
:
new
(
)
}
}
fn
parse_subpath
(
&
mut
self
)
-
>
Result
<
(
)
(
)
>
{
self
.
parse_moveto
(
)
?
;
loop
{
skip_wsp
(
&
mut
self
.
chars
)
;
if
self
.
chars
.
peek
(
)
.
map_or
(
true
|
&
m
|
m
=
=
b
'
M
'
|
|
m
=
=
b
'
m
'
)
{
break
;
}
match
self
.
chars
.
next
(
)
{
Some
(
command
)
=
>
{
let
abs
=
command
.
is_ascii_uppercase
(
)
;
macro_rules
!
parse_command
{
(
(
(
p
:
pat
)
|
+
=
>
parse_func
:
ident
)
*
)
=
>
{
match
command
{
(
(
p
)
|
+
=
>
{
skip_wsp
(
&
mut
self
.
chars
)
;
self
.
parse_func
(
abs
)
?
;
}
)
*
_
=
>
return
Err
(
(
)
)
}
}
}
parse_command
!
(
b
'
Z
'
|
b
'
z
'
=
>
parse_closepath
b
'
L
'
|
b
'
l
'
=
>
parse_lineto
b
'
H
'
|
b
'
h
'
=
>
parse_h_lineto
b
'
V
'
|
b
'
v
'
=
>
parse_v_lineto
b
'
C
'
|
b
'
c
'
=
>
parse_curveto
b
'
S
'
|
b
'
s
'
=
>
parse_smooth_curveto
b
'
Q
'
|
b
'
q
'
=
>
parse_quadratic_bezier_curveto
b
'
T
'
|
b
'
t
'
=
>
parse_smooth_quadratic_bezier_curveto
b
'
A
'
|
b
'
a
'
=
>
parse_elliprical_arc
)
;
}
_
=
>
break
}
}
Ok
(
(
)
)
}
fn
parse_moveto
(
&
mut
self
)
-
>
Result
<
(
)
(
)
>
{
let
command
=
match
self
.
chars
.
next
(
)
{
Some
(
c
)
if
c
=
=
b
'
M
'
|
|
c
=
=
b
'
m
'
=
>
c
_
=
>
return
Err
(
(
)
)
}
;
skip_wsp
(
&
mut
self
.
chars
)
;
let
point
=
parse_coord
(
&
mut
self
.
chars
)
?
;
let
absolute
=
command
=
=
b
'
M
'
;
self
.
path
.
push
(
PathCommand
:
:
MoveTo
{
point
absolute
}
)
;
if
!
skip_wsp
(
&
mut
self
.
chars
)
|
|
self
.
chars
.
peek
(
)
.
map_or
(
true
|
c
|
c
.
is_ascii_alphabetic
(
)
)
{
return
Ok
(
(
)
)
;
}
skip_comma_wsp
(
&
mut
self
.
chars
)
;
self
.
parse_lineto
(
absolute
)
}
fn
parse_closepath
(
&
mut
self
_absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
self
.
path
.
push
(
PathCommand
:
:
ClosePath
)
;
Ok
(
(
)
)
}
fn
parse_lineto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
parse_arguments
!
(
self
absolute
LineTo
[
point
=
>
parse_coord
]
)
}
fn
parse_h_lineto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
parse_arguments
!
(
self
absolute
HorizontalLineTo
[
x
=
>
parse_number
]
)
}
fn
parse_v_lineto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
parse_arguments
!
(
self
absolute
VerticalLineTo
[
y
=
>
parse_number
]
)
}
fn
parse_curveto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
parse_arguments
!
(
self
absolute
CurveTo
[
control1
=
>
parse_coord
control2
=
>
parse_coord
point
=
>
parse_coord
]
)
}
fn
parse_smooth_curveto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
parse_arguments
!
(
self
absolute
SmoothCurveTo
[
control2
=
>
parse_coord
point
=
>
parse_coord
]
)
}
fn
parse_quadratic_bezier_curveto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
parse_arguments
!
(
self
absolute
QuadBezierCurveTo
[
control1
=
>
parse_coord
point
=
>
parse_coord
]
)
}
fn
parse_smooth_quadratic_bezier_curveto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
parse_arguments
!
(
self
absolute
SmoothQuadBezierCurveTo
[
point
=
>
parse_coord
]
)
}
fn
parse_elliprical_arc
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
let
parse_flag
=
|
iter
:
&
mut
Peekable
<
Cloned
<
slice
:
:
Iter
<
u8
>
>
>
|
-
>
Result
<
bool
(
)
>
{
match
iter
.
next
(
)
{
Some
(
c
)
if
c
=
=
b
'
0
'
|
|
c
=
=
b
'
1
'
=
>
Ok
(
c
=
=
b
'
1
'
)
_
=
>
Err
(
(
)
)
}
}
;
parse_arguments
!
(
self
absolute
EllipticalArc
[
rx
=
>
parse_number
ry
=
>
parse_number
angle
=
>
parse_number
large_arc_flag
=
>
parse_flag
sweep_flag
=
>
parse_flag
point
=
>
parse_coord
]
)
}
}
fn
parse_coord
(
iter
:
&
mut
Peekable
<
Cloned
<
slice
:
:
Iter
<
u8
>
>
>
)
-
>
Result
<
CoordPair
(
)
>
{
let
x
=
parse_number
(
iter
)
?
;
skip_comma_wsp
(
iter
)
;
let
y
=
parse_number
(
iter
)
?
;
Ok
(
CoordPair
:
:
new
(
x
y
)
)
}
fn
parse_number
(
iter
:
&
mut
Peekable
<
Cloned
<
slice
:
:
Iter
<
u8
>
>
>
)
-
>
Result
<
CSSFloat
(
)
>
{
let
sign
=
if
iter
.
peek
(
)
.
map_or
(
false
|
&
sign
|
sign
=
=
b
'
+
'
|
|
sign
=
=
b
'
-
'
)
{
if
iter
.
next
(
)
.
unwrap
(
)
=
=
b
'
-
'
{
-
1
.
}
else
{
1
.
}
}
else
{
1
.
}
;
let
mut
integral_part
:
f64
=
0
.
;
let
got_dot
=
if
!
iter
.
peek
(
)
.
map_or
(
false
|
&
n
|
n
=
=
b
'
.
'
)
{
if
iter
.
peek
(
)
.
map_or
(
true
|
n
|
!
n
.
is_ascii_digit
(
)
)
{
return
Err
(
(
)
)
;
}
while
iter
.
peek
(
)
.
map_or
(
false
|
n
|
n
.
is_ascii_digit
(
)
)
{
integral_part
=
integral_part
*
10
.
+
(
iter
.
next
(
)
.
unwrap
(
)
-
b
'
0
'
)
as
f64
;
}
iter
.
peek
(
)
.
map_or
(
false
|
&
n
|
n
=
=
b
'
.
'
)
}
else
{
true
}
;
let
mut
fractional_part
:
f64
=
0
.
;
if
got_dot
{
iter
.
next
(
)
;
if
iter
.
peek
(
)
.
map_or
(
true
|
n
|
!
n
.
is_ascii_digit
(
)
)
{
return
Err
(
(
)
)
;
}
let
mut
factor
=
0
.
1
;
while
iter
.
peek
(
)
.
map_or
(
false
|
n
|
n
.
is_ascii_digit
(
)
)
{
fractional_part
+
=
(
iter
.
next
(
)
.
unwrap
(
)
-
b
'
0
'
)
as
f64
*
factor
;
factor
*
=
0
.
1
;
}
}
let
mut
value
=
sign
*
(
integral_part
+
fractional_part
)
;
if
iter
.
peek
(
)
.
map_or
(
false
|
&
exp
|
exp
=
=
b
'
E
'
|
|
exp
=
=
b
'
e
'
)
{
iter
.
next
(
)
;
let
exp_sign
=
if
iter
.
peek
(
)
.
map_or
(
false
|
&
sign
|
sign
=
=
b
'
+
'
|
|
sign
=
=
b
'
-
'
)
{
if
iter
.
next
(
)
.
unwrap
(
)
=
=
b
'
-
'
{
-
1
.
}
else
{
1
.
}
}
else
{
1
.
}
;
let
mut
exp
:
f64
=
0
.
;
while
iter
.
peek
(
)
.
map_or
(
false
|
n
|
n
.
is_ascii_digit
(
)
)
{
exp
=
exp
*
10
.
+
(
iter
.
next
(
)
.
unwrap
(
)
-
b
'
0
'
)
as
f64
;
}
value
*
=
f64
:
:
powf
(
10
.
exp
*
exp_sign
)
;
}
if
value
.
is_finite
(
)
{
Ok
(
value
.
min
(
:
:
std
:
:
f32
:
:
MAX
as
f64
)
.
max
(
:
:
std
:
:
f32
:
:
MIN
as
f64
)
as
CSSFloat
)
}
else
{
Err
(
(
)
)
}
}
#
[
inline
]
fn
skip_wsp
(
iter
:
&
mut
Peekable
<
Cloned
<
slice
:
:
Iter
<
u8
>
>
>
)
-
>
bool
{
while
iter
.
peek
(
)
.
map_or
(
false
|
c
|
c
.
is_ascii_whitespace
(
)
)
{
iter
.
next
(
)
;
}
iter
.
peek
(
)
.
is_some
(
)
}
#
[
inline
]
fn
skip_comma_wsp
(
iter
:
&
mut
Peekable
<
Cloned
<
slice
:
:
Iter
<
u8
>
>
>
)
-
>
bool
{
if
!
skip_wsp
(
iter
)
{
return
false
;
}
if
*
iter
.
peek
(
)
.
unwrap
(
)
!
=
b
'
'
{
return
true
;
}
iter
.
next
(
)
;
skip_wsp
(
iter
)
}
