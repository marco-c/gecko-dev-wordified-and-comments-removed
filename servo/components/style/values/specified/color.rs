use
super
:
:
AllowQuirks
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
gecko_bindings
:
:
structs
:
:
nscolor
;
use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
values
:
:
computed
:
:
{
Color
as
ComputedColor
Context
ToComputedValue
}
;
use
crate
:
:
values
:
:
generics
:
:
color
:
:
{
Color
as
GenericColor
ColorOrAuto
as
GenericColorOrAuto
}
;
use
crate
:
:
values
:
:
specified
:
:
calc
:
:
CalcNode
;
use
cssparser
:
:
{
AngleOrNumber
Color
as
CSSParserColor
Parser
Token
RGBA
}
;
use
cssparser
:
:
{
BasicParseErrorKind
NumberOrPercentage
ParseErrorKind
}
;
use
itoa
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
io
:
:
Write
as
IoWrite
;
use
style_traits
:
:
{
CssType
CssWriter
KeywordsCollectFn
ParseError
StyleParseErrorKind
}
;
use
style_traits
:
:
{
SpecifiedValueInfo
ToCss
ValueParseErrorKind
}
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
pub
enum
Color
{
CurrentColor
Numeric
{
parsed
:
RGBA
authored
:
Option
<
Box
<
str
>
>
}
Complex
(
ComputedColor
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
System
(
SystemColor
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
InheritFromBodyQuirk
}
#
[
allow
(
missing_docs
)
]
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
Parse
PartialEq
ToCss
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
SystemColor
{
#
[
css
(
skip
)
]
WindowBackground
#
[
css
(
skip
)
]
WindowForeground
#
[
css
(
skip
)
]
WidgetBackground
#
[
css
(
skip
)
]
WidgetForeground
#
[
css
(
skip
)
]
WidgetSelectBackground
#
[
css
(
skip
)
]
WidgetSelectForeground
#
[
css
(
skip
)
]
Widget3DHighlight
#
[
css
(
skip
)
]
Widget3DShadow
#
[
css
(
skip
)
]
TextBackground
#
[
css
(
skip
)
]
TextForeground
#
[
css
(
skip
)
]
TextSelectBackground
#
[
css
(
skip
)
]
TextSelectForeground
#
[
css
(
skip
)
]
TextSelectForegroundCustom
#
[
css
(
skip
)
]
TextSelectBackgroundDisabled
#
[
css
(
skip
)
]
TextSelectBackgroundAttention
#
[
css
(
skip
)
]
TextHighlightBackground
#
[
css
(
skip
)
]
TextHighlightForeground
#
[
css
(
skip
)
]
IMERawInputBackground
#
[
css
(
skip
)
]
IMERawInputForeground
#
[
css
(
skip
)
]
IMERawInputUnderline
#
[
css
(
skip
)
]
IMESelectedRawTextBackground
#
[
css
(
skip
)
]
IMESelectedRawTextForeground
#
[
css
(
skip
)
]
IMESelectedRawTextUnderline
#
[
css
(
skip
)
]
IMEConvertedTextBackground
#
[
css
(
skip
)
]
IMEConvertedTextForeground
#
[
css
(
skip
)
]
IMEConvertedTextUnderline
#
[
css
(
skip
)
]
IMESelectedConvertedTextBackground
#
[
css
(
skip
)
]
IMESelectedConvertedTextForeground
#
[
css
(
skip
)
]
IMESelectedConvertedTextUnderline
#
[
css
(
skip
)
]
SpellCheckerUnderline
Activeborder
Activecaption
Appworkspace
Background
Buttonface
Buttonhighlight
Buttonshadow
Buttontext
Captiontext
#
[
parse
(
aliases
=
"
-
moz
-
field
"
)
]
Field
#
[
parse
(
aliases
=
"
-
moz
-
fieldtext
"
)
]
Fieldtext
Graytext
Highlight
Highlighttext
Inactiveborder
Inactivecaption
Inactivecaptiontext
Infobackground
Infotext
Menu
Menutext
Scrollbar
Threeddarkshadow
Threedface
Threedhighlight
Threedlightshadow
Threedshadow
Window
Windowframe
Windowtext
MozButtondefault
MozDefaultColor
MozDefaultBackgroundColor
MozDialog
MozDialogtext
MozDragtargetzone
MozCellhighlight
MozCellhighlighttext
MozHtmlCellhighlight
MozHtmlCellhighlighttext
MozButtonhoverface
MozButtonhovertext
MozMenuhover
MozMenuhovertext
MozMenubartext
MozMenubarhovertext
MozEventreerow
MozOddtreerow
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozGtkButtonactivetext
MozMacButtonactivetext
MozMacChromeActive
MozMacChromeInactive
MozMacDefaultbuttontext
MozMacFocusring
MozMacMenuselect
MozMacMenushadow
MozMacMenutextdisable
MozMacMenutextselect
MozMacDisabledtoolbartext
MozMacSecondaryhighlight
MozMacVibrancyLight
MozMacVibrancyDark
MozMacVibrantTitlebarLight
MozMacVibrantTitlebarDark
MozMacMenupopup
MozMacMenuitem
MozMacActiveMenuitem
MozMacSourceList
MozMacSourceListSelection
MozMacActiveSourceListSelection
MozMacTooltip
MozWinAccentcolor
MozWinAccentcolortext
MozWinMediatext
MozWinCommunicationstext
MozNativehyperlinktext
MozHyperlinktext
MozActivehyperlinktext
MozVisitedhyperlinktext
MozComboboxtext
MozCombobox
MozGtkInfoBarText
#
[
css
(
skip
)
]
End
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
SystemColor
{
#
[
inline
]
fn
compute
(
&
self
cx
:
&
Context
)
-
>
ComputedColor
{
use
crate
:
:
gecko_bindings
:
:
bindings
;
let
prefs
=
cx
.
device
(
)
.
pref_sheet_prefs
(
)
;
convert_nscolor_to_computedcolor
(
match
*
self
{
SystemColor
:
:
MozDefaultColor
=
>
prefs
.
mDefaultColor
SystemColor
:
:
MozDefaultBackgroundColor
=
>
prefs
.
mDefaultBackgroundColor
SystemColor
:
:
MozHyperlinktext
=
>
prefs
.
mLinkColor
SystemColor
:
:
MozActivehyperlinktext
=
>
prefs
.
mActiveLinkColor
SystemColor
:
:
MozVisitedhyperlinktext
=
>
prefs
.
mVisitedLinkColor
_
=
>
unsafe
{
bindings
:
:
Gecko_GetLookAndFeelSystemColor
(
*
self
as
i32
cx
.
device
(
)
.
document
(
)
)
}
}
)
}
}
impl
From
<
RGBA
>
for
Color
{
fn
from
(
value
:
RGBA
)
-
>
Self
{
Color
:
:
rgba
(
value
)
}
}
struct
ColorComponentParser
<
'
a
'
b
:
'
a
>
(
&
'
a
ParserContext
<
'
b
>
)
;
impl
<
'
a
'
b
:
'
a
'
i
:
'
a
>
:
:
cssparser
:
:
ColorComponentParser
<
'
i
>
for
ColorComponentParser
<
'
a
'
b
>
{
type
Error
=
StyleParseErrorKind
<
'
i
>
;
fn
parse_angle_or_number
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
AngleOrNumber
ParseError
<
'
i
>
>
{
use
crate
:
:
values
:
:
specified
:
:
Angle
;
let
location
=
input
.
current_source_location
(
)
;
let
token
=
input
.
next
(
)
?
.
clone
(
)
;
match
token
{
Token
:
:
Dimension
{
value
ref
unit
.
.
}
=
>
{
let
angle
=
Angle
:
:
parse_dimension
(
value
unit
false
)
;
let
degrees
=
match
angle
{
Ok
(
angle
)
=
>
angle
.
degrees
(
)
Err
(
(
)
)
=
>
return
Err
(
location
.
new_unexpected_token_error
(
token
.
clone
(
)
)
)
}
;
Ok
(
AngleOrNumber
:
:
Angle
{
degrees
}
)
}
Token
:
:
Number
{
value
.
.
}
=
>
Ok
(
AngleOrNumber
:
:
Number
{
value
}
)
Token
:
:
Function
(
ref
name
)
if
name
.
eq_ignore_ascii_case
(
"
calc
"
)
=
>
{
input
.
parse_nested_block
(
|
i
|
CalcNode
:
:
parse_angle_or_number
(
self
.
0
i
)
)
}
t
=
>
return
Err
(
location
.
new_unexpected_token_error
(
t
)
)
}
}
fn
parse_percentage
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
f32
ParseError
<
'
i
>
>
{
use
crate
:
:
values
:
:
specified
:
:
Percentage
;
Ok
(
Percentage
:
:
parse
(
self
.
0
input
)
?
.
get
(
)
)
}
fn
parse_number
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
f32
ParseError
<
'
i
>
>
{
use
crate
:
:
values
:
:
specified
:
:
Number
;
Ok
(
Number
:
:
parse
(
self
.
0
input
)
?
.
get
(
)
)
}
fn
parse_number_or_percentage
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
NumberOrPercentage
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
match
input
.
next
(
)
?
.
clone
(
)
{
Token
:
:
Number
{
value
.
.
}
=
>
Ok
(
NumberOrPercentage
:
:
Number
{
value
}
)
Token
:
:
Percentage
{
unit_value
.
.
}
=
>
{
Ok
(
NumberOrPercentage
:
:
Percentage
{
unit_value
}
)
}
Token
:
:
Function
(
ref
name
)
if
name
.
eq_ignore_ascii_case
(
"
calc
"
)
=
>
{
input
.
parse_nested_block
(
|
i
|
CalcNode
:
:
parse_number_or_percentage
(
self
.
0
i
)
)
}
t
=
>
return
Err
(
location
.
new_unexpected_token_error
(
t
)
)
}
}
}
impl
Parse
for
Color
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
start
=
input
.
state
(
)
;
let
authored
=
input
.
expect_ident_cloned
(
)
.
ok
(
)
;
input
.
reset
(
&
start
)
;
let
compontent_parser
=
ColorComponentParser
(
&
*
context
)
;
match
input
.
try
(
|
i
|
CSSParserColor
:
:
parse_with
(
&
compontent_parser
i
)
)
{
Ok
(
value
)
=
>
Ok
(
match
value
{
CSSParserColor
:
:
CurrentColor
=
>
Color
:
:
CurrentColor
CSSParserColor
:
:
RGBA
(
rgba
)
=
>
Color
:
:
Numeric
{
parsed
:
rgba
authored
:
authored
.
map
(
|
s
|
s
.
to_ascii_lowercase
(
)
.
into_boxed_str
(
)
)
}
}
)
Err
(
e
)
=
>
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
if
let
Ok
(
system
)
=
input
.
try
(
|
i
|
SystemColor
:
:
parse
(
context
i
)
)
{
return
Ok
(
Color
:
:
System
(
system
)
)
;
}
}
match
e
.
kind
{
ParseErrorKind
:
:
Basic
(
BasicParseErrorKind
:
:
UnexpectedToken
(
t
)
)
=
>
{
Err
(
e
.
location
.
new_custom_error
(
StyleParseErrorKind
:
:
ValueError
(
ValueParseErrorKind
:
:
InvalidColor
(
t
)
)
)
)
}
_
=
>
Err
(
e
)
}
}
}
}
}
impl
ToCss
for
Color
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
*
self
{
Color
:
:
CurrentColor
=
>
CSSParserColor
:
:
CurrentColor
.
to_css
(
dest
)
Color
:
:
Numeric
{
authored
:
Some
(
ref
authored
)
.
.
}
=
>
dest
.
write_str
(
authored
)
Color
:
:
Numeric
{
parsed
:
ref
rgba
.
.
}
=
>
rgba
.
to_css
(
dest
)
Color
:
:
Complex
(
_
)
=
>
Ok
(
(
)
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
System
(
system
)
=
>
system
.
to_css
(
dest
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
InheritFromBodyQuirk
=
>
Ok
(
(
)
)
}
}
}
fn
parse_hash_color
(
value
:
&
[
u8
]
)
-
>
Result
<
RGBA
(
)
>
{
CSSParserColor
:
:
parse_hash
(
value
)
.
map
(
|
color
|
match
color
{
CSSParserColor
:
:
RGBA
(
rgba
)
=
>
rgba
CSSParserColor
:
:
CurrentColor
=
>
unreachable
!
(
"
parse_hash
should
never
return
currentcolor
"
)
}
)
}
impl
Color
{
#
[
inline
]
pub
fn
currentcolor
(
)
-
>
Color
{
Color
:
:
CurrentColor
}
#
[
inline
]
pub
fn
transparent
(
)
-
>
Color
{
Color
:
:
rgba
(
RGBA
:
:
transparent
(
)
)
}
#
[
inline
]
pub
fn
rgba
(
rgba
:
RGBA
)
-
>
Self
{
Color
:
:
Numeric
{
parsed
:
rgba
authored
:
None
}
}
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
try
(
|
i
|
Self
:
:
parse
(
context
i
)
)
.
or_else
(
|
e
|
{
if
!
allow_quirks
.
allowed
(
context
.
quirks_mode
)
{
return
Err
(
e
)
;
}
Color
:
:
parse_quirky_color
(
input
)
.
map
(
Color
:
:
rgba
)
.
map_err
(
|
_
|
e
)
}
)
}
fn
parse_quirky_color
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
RGBA
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
(
value
unit
)
=
match
*
input
.
next
(
)
?
{
Token
:
:
Number
{
int_value
:
Some
(
integer
)
.
.
}
=
>
(
integer
None
)
Token
:
:
Dimension
{
int_value
:
Some
(
integer
)
ref
unit
.
.
}
=
>
(
integer
Some
(
unit
)
)
Token
:
:
Ident
(
ref
ident
)
=
>
{
if
ident
.
len
(
)
!
=
3
&
&
ident
.
len
(
)
!
=
6
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
return
parse_hash_color
(
ident
.
as_bytes
(
)
)
.
map_err
(
|
(
)
|
{
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
}
)
;
}
ref
t
=
>
{
return
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
;
}
}
;
if
value
<
0
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
let
length
=
if
value
<
=
9
{
1
}
else
if
value
<
=
99
{
2
}
else
if
value
<
=
999
{
3
}
else
if
value
<
=
9999
{
4
}
else
if
value
<
=
99999
{
5
}
else
if
value
<
=
999999
{
6
}
else
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
;
let
total
=
length
+
unit
.
as_ref
(
)
.
map_or
(
0
|
d
|
d
.
len
(
)
)
;
if
total
>
6
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
let
mut
serialization
=
[
b
'
0
'
;
6
]
;
let
space_padding
=
6
-
total
;
let
mut
written
=
space_padding
;
written
+
=
itoa
:
:
write
(
&
mut
serialization
[
written
.
.
]
value
)
.
unwrap
(
)
;
if
let
Some
(
unit
)
=
unit
{
written
+
=
(
&
mut
serialization
[
written
.
.
]
)
.
write
(
unit
.
as_bytes
(
)
)
.
unwrap
(
)
;
}
debug_assert_eq
!
(
written
6
)
;
parse_hash_color
(
&
serialization
)
.
map_err
(
|
(
)
|
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
is_transparent
(
&
self
)
-
>
bool
{
match
*
self
{
Color
:
:
Numeric
{
ref
parsed
.
.
}
=
>
parsed
.
alpha
=
=
0
_
=
>
false
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
convert_nscolor_to_computedcolor
(
color
:
nscolor
)
-
>
ComputedColor
{
use
crate
:
:
gecko
:
:
values
:
:
convert_nscolor_to_rgba
;
ComputedColor
:
:
rgba
(
convert_nscolor_to_rgba
(
color
)
)
}
impl
Color
{
pub
fn
to_computed_color
(
&
self
_context
:
Option
<
&
Context
>
)
-
>
Option
<
ComputedColor
>
{
Some
(
match
*
self
{
Color
:
:
CurrentColor
=
>
ComputedColor
:
:
currentcolor
(
)
Color
:
:
Numeric
{
ref
parsed
.
.
}
=
>
ComputedColor
:
:
rgba
(
*
parsed
)
Color
:
:
Complex
(
ref
complex
)
=
>
*
complex
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
System
(
system
)
=
>
system
.
compute
(
_context
?
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
InheritFromBodyQuirk
=
>
{
ComputedColor
:
:
rgba
(
_context
?
.
device
(
)
.
body_text_color
(
)
)
}
}
)
}
}
impl
ToComputedValue
for
Color
{
type
ComputedValue
=
ComputedColor
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
ComputedColor
{
self
.
to_computed_color
(
Some
(
context
)
)
.
unwrap
(
)
}
fn
from_computed_value
(
computed
:
&
ComputedColor
)
-
>
Self
{
match
*
computed
{
GenericColor
:
:
Numeric
(
color
)
=
>
Color
:
:
rgba
(
color
)
GenericColor
:
:
CurrentColor
=
>
Color
:
:
currentcolor
(
)
GenericColor
:
:
Complex
{
.
.
}
=
>
Color
:
:
Complex
(
*
computed
)
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToCss
ToShmem
)
]
pub
struct
MozFontSmoothingBackgroundColor
(
pub
Color
)
;
impl
Parse
for
MozFontSmoothingBackgroundColor
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Color
:
:
parse
(
context
input
)
.
map
(
MozFontSmoothingBackgroundColor
)
}
}
impl
ToComputedValue
for
MozFontSmoothingBackgroundColor
{
type
ComputedValue
=
RGBA
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
RGBA
{
self
.
0
.
to_computed_value
(
context
)
.
to_rgba
(
RGBA
:
:
transparent
(
)
)
}
fn
from_computed_value
(
computed
:
&
RGBA
)
-
>
Self
{
MozFontSmoothingBackgroundColor
(
Color
:
:
rgba
(
*
computed
)
)
}
}
impl
SpecifiedValueInfo
for
Color
{
const
SUPPORTED_TYPES
:
u8
=
CssType
:
:
COLOR
;
fn
collect_completion_keywords
(
f
:
KeywordsCollectFn
)
{
f
(
&
[
"
rgb
"
"
rgba
"
"
hsl
"
"
hsla
"
"
currentColor
"
"
transparent
"
]
)
;
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
SpecifiedValueInfo
ToCss
ToShmem
)
]
pub
struct
ColorPropertyValue
(
pub
Color
)
;
impl
ToComputedValue
for
ColorPropertyValue
{
type
ComputedValue
=
RGBA
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
RGBA
{
self
.
0
.
to_computed_value
(
context
)
.
to_rgba
(
context
.
builder
.
get_parent_inherited_text
(
)
.
clone_color
(
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
RGBA
)
-
>
Self
{
ColorPropertyValue
(
Color
:
:
rgba
(
*
computed
)
.
into
(
)
)
}
}
impl
Parse
for
ColorPropertyValue
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Color
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
Yes
)
.
map
(
ColorPropertyValue
)
}
}
pub
type
ColorOrAuto
=
GenericColorOrAuto
<
Color
>
;
