use
super
:
:
AllowQuirks
;
use
crate
:
:
color
:
:
ColorComponents
;
use
crate
:
:
media_queries
:
:
Device
;
use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
values
:
:
computed
:
:
{
Color
as
ComputedColor
Context
ToComputedValue
}
;
use
crate
:
:
values
:
:
generics
:
:
color
:
:
{
ColorInterpolationMethod
GenericCaretColor
GenericColorMix
GenericColorOrAuto
}
;
use
crate
:
:
values
:
:
specified
:
:
calc
:
:
CalcNode
;
use
crate
:
:
values
:
:
specified
:
:
Percentage
;
use
crate
:
:
values
:
:
CustomIdent
;
use
cssparser
:
:
{
AngleOrNumber
Color
as
CSSParserColor
Parser
Token
RGBA
}
;
use
cssparser
:
:
{
BasicParseErrorKind
NumberOrPercentage
ParseErrorKind
}
;
use
itoa
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
io
:
:
Write
as
IoWrite
;
use
style_traits
:
:
{
CssType
CssWriter
KeywordsCollectFn
ParseError
StyleParseErrorKind
}
;
use
style_traits
:
:
{
SpecifiedValueInfo
ToCss
ValueParseErrorKind
}
;
pub
type
ColorMix
=
GenericColorMix
<
Color
Percentage
>
;
impl
ColorMix
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
preserve_authored
:
PreserveAuthored
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
enabled
=
context
.
chrome_rules_enabled
(
)
|
|
static_prefs
:
:
pref
!
(
"
layout
.
css
.
color
-
mix
.
enabled
"
)
;
if
!
enabled
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
input
.
expect_function_matching
(
"
color
-
mix
"
)
?
;
input
.
parse_nested_block
(
|
input
|
{
let
interpolation
=
ColorInterpolationMethod
:
:
parse
(
context
input
)
?
;
input
.
expect_comma
(
)
?
;
let
try_parse_percentage
=
|
input
:
&
mut
Parser
|
-
>
Option
<
Percentage
>
{
input
.
try_parse
(
|
input
|
Percentage
:
:
parse_zero_to_a_hundred
(
context
input
)
)
.
ok
(
)
}
;
let
mut
left_percentage
=
try_parse_percentage
(
input
)
;
let
left
=
Color
:
:
parse_internal
(
context
input
preserve_authored
)
?
;
if
left_percentage
.
is_none
(
)
{
left_percentage
=
try_parse_percentage
(
input
)
;
}
input
.
expect_comma
(
)
?
;
let
mut
right_percentage
=
try_parse_percentage
(
input
)
;
let
right
=
Color
:
:
parse
(
context
input
)
?
;
if
right_percentage
.
is_none
(
)
{
right_percentage
=
try_parse_percentage
(
input
)
;
}
let
right_percentage
=
right_percentage
.
unwrap_or_else
(
|
|
Percentage
:
:
new
(
1
.
0
-
left_percentage
.
map_or
(
0
.
5
|
p
|
p
.
get
(
)
)
)
)
;
let
left_percentage
=
left_percentage
.
unwrap_or_else
(
|
|
Percentage
:
:
new
(
1
.
0
-
right_percentage
.
get
(
)
)
)
;
if
left_percentage
.
get
(
)
+
right_percentage
.
get
(
)
<
=
0
.
0
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
Ok
(
ColorMix
{
interpolation
left
left_percentage
right
right_percentage
normalize_weights
:
true
}
)
}
)
}
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ColorSpace
{
Lab
Lch
Oklab
Oklch
Srgb
SrgbLinear
DisplayP3
A98Rgb
ProphotoRgb
Rec2020
XyzD50
XyzD65
}
bitflags
!
{
#
[
derive
(
Default
MallocSizeOf
ToShmem
)
]
#
[
repr
(
C
)
]
struct
SerializationFlags
:
u8
{
const
AS_COLOR_FUNCTION
=
0x01
;
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
AbsoluteColor
{
components
:
ColorComponents
alpha
:
f32
color_space
:
ColorSpace
flags
:
SerializationFlags
}
macro_rules
!
color_components_as
{
(
c
:
expr
t
:
ty
)
=
>
{
{
/
/
This
macro
is
not
an
inline
function
because
we
can
'
t
use
the
/
/
generic
type
(
t
)
in
a
constant
expression
as
per
:
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
76560
const_assert_eq
!
(
std
:
:
mem
:
:
size_of
:
:
<
t
>
(
)
std
:
:
mem
:
:
size_of
:
:
<
[
f32
;
4
]
>
(
)
)
;
const_assert_eq
!
(
std
:
:
mem
:
:
align_of
:
:
<
t
>
(
)
std
:
:
mem
:
:
align_of
:
:
<
[
f32
;
4
]
>
(
)
)
;
const_assert
!
(
std
:
:
mem
:
:
size_of
:
:
<
AbsoluteColor
>
(
)
>
=
std
:
:
mem
:
:
size_of
:
:
<
t
>
(
)
)
;
const_assert_eq
!
(
std
:
:
mem
:
:
align_of
:
:
<
AbsoluteColor
>
(
)
std
:
:
mem
:
:
align_of
:
:
<
t
>
(
)
)
;
std
:
:
mem
:
:
transmute
:
:
<
&
ColorComponents
&
t
>
(
&
c
.
components
)
}
}
;
}
impl
AbsoluteColor
{
pub
fn
new
(
color_space
:
ColorSpace
components
:
ColorComponents
alpha
:
f32
)
-
>
Self
{
Self
{
components
alpha
color_space
flags
:
SerializationFlags
:
:
empty
(
)
}
}
pub
fn
from_rgba
(
rgba
:
RGBA
)
-
>
Self
{
let
red
=
rgba
.
red
as
f32
/
255
.
0
;
let
green
=
rgba
.
green
as
f32
/
255
.
0
;
let
blue
=
rgba
.
blue
as
f32
/
255
.
0
;
Self
:
:
new
(
ColorSpace
:
:
Srgb
ColorComponents
(
red
green
blue
)
rgba
.
alpha
)
}
#
[
inline
]
pub
fn
alpha
(
&
self
)
-
>
f32
{
self
.
alpha
}
pub
fn
to_rgba
(
&
self
)
-
>
RGBA
{
let
rgba
=
self
.
to_color_space
(
ColorSpace
:
:
Srgb
)
;
let
red
=
(
rgba
.
components
.
0
*
255
.
0
)
.
round
(
)
as
u8
;
let
green
=
(
rgba
.
components
.
1
*
255
.
0
)
.
round
(
)
as
u8
;
let
blue
=
(
rgba
.
components
.
2
*
255
.
0
)
.
round
(
)
as
u8
;
RGBA
:
:
new
(
red
green
blue
rgba
.
alpha
)
}
pub
fn
to_color_space
(
&
self
color_space
:
ColorSpace
)
-
>
Self
{
use
crate
:
:
color
:
:
convert
;
use
ColorSpace
:
:
*
;
if
self
.
color_space
=
=
color_space
{
return
self
.
clone
(
)
;
}
let
(
xyz
white_point
)
=
match
self
.
color_space
{
Lab
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
Lab
>
(
&
self
.
components
)
Lch
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
Lch
>
(
&
self
.
components
)
Oklab
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
Oklab
>
(
&
self
.
components
)
Oklch
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
Oklch
>
(
&
self
.
components
)
Srgb
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
Srgb
>
(
&
self
.
components
)
SrgbLinear
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
SrgbLinear
>
(
&
self
.
components
)
DisplayP3
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
DisplayP3
>
(
&
self
.
components
)
A98Rgb
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
A98Rgb
>
(
&
self
.
components
)
ProphotoRgb
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
ProphotoRgb
>
(
&
self
.
components
)
Rec2020
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
Rec2020
>
(
&
self
.
components
)
XyzD50
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
XyzD50
>
(
&
self
.
components
)
XyzD65
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
XyzD65
>
(
&
self
.
components
)
}
;
let
result
=
match
color_space
{
Lab
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
Lab
>
(
&
xyz
white_point
)
Lch
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
Lch
>
(
&
xyz
white_point
)
Oklab
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
Oklab
>
(
&
xyz
white_point
)
Oklch
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
Oklch
>
(
&
xyz
white_point
)
Srgb
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
Srgb
>
(
&
xyz
white_point
)
SrgbLinear
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
SrgbLinear
>
(
&
xyz
white_point
)
DisplayP3
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
DisplayP3
>
(
&
xyz
white_point
)
A98Rgb
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
A98Rgb
>
(
&
xyz
white_point
)
ProphotoRgb
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
ProphotoRgb
>
(
&
xyz
white_point
)
Rec2020
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
Rec2020
>
(
&
xyz
white_point
)
XyzD50
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
XyzD50
>
(
&
xyz
white_point
)
XyzD65
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
XyzD65
>
(
&
xyz
white_point
)
}
;
Self
:
:
new
(
color_space
result
self
.
alpha
)
}
}
impl
From
<
cssparser
:
:
PredefinedColorSpace
>
for
ColorSpace
{
fn
from
(
value
:
cssparser
:
:
PredefinedColorSpace
)
-
>
Self
{
match
value
{
cssparser
:
:
PredefinedColorSpace
:
:
Srgb
=
>
ColorSpace
:
:
Srgb
cssparser
:
:
PredefinedColorSpace
:
:
SrgbLinear
=
>
ColorSpace
:
:
SrgbLinear
cssparser
:
:
PredefinedColorSpace
:
:
DisplayP3
=
>
ColorSpace
:
:
DisplayP3
cssparser
:
:
PredefinedColorSpace
:
:
A98Rgb
=
>
ColorSpace
:
:
A98Rgb
cssparser
:
:
PredefinedColorSpace
:
:
ProphotoRgb
=
>
ColorSpace
:
:
ProphotoRgb
cssparser
:
:
PredefinedColorSpace
:
:
Rec2020
=
>
ColorSpace
:
:
Rec2020
cssparser
:
:
PredefinedColorSpace
:
:
XyzD50
=
>
ColorSpace
:
:
XyzD50
cssparser
:
:
PredefinedColorSpace
:
:
XyzD65
=
>
ColorSpace
:
:
XyzD65
}
}
}
impl
From
<
cssparser
:
:
AbsoluteColor
>
for
AbsoluteColor
{
fn
from
(
f
:
cssparser
:
:
AbsoluteColor
)
-
>
Self
{
match
f
{
cssparser
:
:
AbsoluteColor
:
:
Rgba
(
rgba
)
=
>
Self
:
:
from_rgba
(
rgba
)
cssparser
:
:
AbsoluteColor
:
:
Lab
(
lab
)
=
>
Self
:
:
new
(
ColorSpace
:
:
Lab
ColorComponents
(
lab
.
lightness
lab
.
a
lab
.
b
)
lab
.
alpha
)
cssparser
:
:
AbsoluteColor
:
:
Lch
(
lch
)
=
>
Self
:
:
new
(
ColorSpace
:
:
Lch
ColorComponents
(
lch
.
lightness
lch
.
chroma
lch
.
hue
)
lch
.
alpha
)
cssparser
:
:
AbsoluteColor
:
:
Oklab
(
oklab
)
=
>
Self
:
:
new
(
ColorSpace
:
:
Oklab
ColorComponents
(
oklab
.
lightness
oklab
.
a
oklab
.
b
)
oklab
.
alpha
)
cssparser
:
:
AbsoluteColor
:
:
Oklch
(
oklch
)
=
>
Self
:
:
new
(
ColorSpace
:
:
Oklch
ColorComponents
(
oklch
.
lightness
oklch
.
chroma
oklch
.
hue
)
oklch
.
alpha
)
cssparser
:
:
AbsoluteColor
:
:
ColorFunction
(
c
)
=
>
{
let
mut
result
=
AbsoluteColor
:
:
new
(
c
.
color_space
.
into
(
)
ColorComponents
(
c
.
c1
c
.
c2
c
.
c3
)
c
.
alpha
)
;
if
matches
!
(
c
.
color_space
cssparser
:
:
PredefinedColorSpace
:
:
Srgb
)
{
result
.
flags
|
=
SerializationFlags
:
:
AS_COLOR_FUNCTION
;
}
result
}
}
}
}
impl
ToCss
for
AbsoluteColor
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
self
.
color_space
{
ColorSpace
:
:
Srgb
if
!
self
.
flags
.
contains
(
SerializationFlags
:
:
AS_COLOR_FUNCTION
)
=
>
{
cssparser
:
:
ToCss
:
:
to_css
(
&
cssparser
:
:
RGBA
:
:
from_floats
(
self
.
components
.
0
self
.
components
.
1
self
.
components
.
2
self
.
alpha
(
)
)
dest
)
}
ColorSpace
:
:
Lab
=
>
cssparser
:
:
ToCss
:
:
to_css
(
unsafe
{
color_components_as
!
(
self
cssparser
:
:
Lab
)
}
dest
)
ColorSpace
:
:
Lch
=
>
cssparser
:
:
ToCss
:
:
to_css
(
unsafe
{
color_components_as
!
(
self
cssparser
:
:
Lch
)
}
dest
)
ColorSpace
:
:
Oklab
=
>
cssparser
:
:
ToCss
:
:
to_css
(
unsafe
{
color_components_as
!
(
self
cssparser
:
:
Oklab
)
}
dest
)
ColorSpace
:
:
Oklch
=
>
cssparser
:
:
ToCss
:
:
to_css
(
unsafe
{
color_components_as
!
(
self
cssparser
:
:
Oklch
)
}
dest
)
_
=
>
{
let
color_space
=
match
self
.
color_space
{
ColorSpace
:
:
Lab
|
ColorSpace
:
:
Lch
|
ColorSpace
:
:
Oklab
|
ColorSpace
:
:
Oklch
=
>
{
unreachable
!
(
"
Handle
these
in
the
wrapping
match
case
!
!
"
)
}
ColorSpace
:
:
Srgb
=
>
{
debug_assert
!
(
self
.
flags
.
contains
(
SerializationFlags
:
:
AS_COLOR_FUNCTION
)
"
The
case
without
this
flag
should
be
handled
in
the
wrapping
match
case
!
!
"
)
;
cssparser
:
:
PredefinedColorSpace
:
:
Srgb
}
ColorSpace
:
:
SrgbLinear
=
>
cssparser
:
:
PredefinedColorSpace
:
:
SrgbLinear
ColorSpace
:
:
DisplayP3
=
>
cssparser
:
:
PredefinedColorSpace
:
:
DisplayP3
ColorSpace
:
:
A98Rgb
=
>
cssparser
:
:
PredefinedColorSpace
:
:
A98Rgb
ColorSpace
:
:
ProphotoRgb
=
>
cssparser
:
:
PredefinedColorSpace
:
:
ProphotoRgb
ColorSpace
:
:
Rec2020
=
>
cssparser
:
:
PredefinedColorSpace
:
:
Rec2020
ColorSpace
:
:
XyzD50
=
>
cssparser
:
:
PredefinedColorSpace
:
:
XyzD50
ColorSpace
:
:
XyzD65
=
>
cssparser
:
:
PredefinedColorSpace
:
:
XyzD65
}
;
let
color_function
=
cssparser
:
:
ColorFunction
{
color_space
c1
:
self
.
components
.
0
c2
:
self
.
components
.
1
c3
:
self
.
components
.
2
alpha
:
self
.
alpha
}
;
let
color
=
cssparser
:
:
AbsoluteColor
:
:
ColorFunction
(
color_function
)
;
cssparser
:
:
ToCss
:
:
to_css
(
&
color
dest
)
}
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
pub
struct
Absolute
{
pub
color
:
AbsoluteColor
pub
authored
:
Option
<
Box
<
str
>
>
}
impl
ToCss
for
Absolute
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
let
Some
(
ref
authored
)
=
self
.
authored
{
dest
.
write_str
(
authored
)
}
else
{
self
.
color
.
to_css
(
dest
)
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
pub
enum
Color
{
CurrentColor
Absolute
(
Box
<
Absolute
>
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
System
(
SystemColor
)
ColorMix
(
Box
<
ColorMix
>
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
InheritFromBodyQuirk
}
#
[
allow
(
missing_docs
)
]
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
Parse
PartialEq
ToCss
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
SystemColor
{
Activeborder
Activecaption
Appworkspace
Background
Buttonface
Buttonhighlight
Buttonshadow
Buttontext
Buttonborder
Captiontext
#
[
parse
(
aliases
=
"
-
moz
-
field
"
)
]
Field
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozDisabledfield
#
[
parse
(
aliases
=
"
-
moz
-
fieldtext
"
)
]
Fieldtext
Mark
Marktext
MozComboboxtext
MozCombobox
Graytext
Highlight
Highlighttext
Inactiveborder
Inactivecaption
Inactivecaptiontext
Infobackground
Infotext
Menu
Menutext
Scrollbar
Threeddarkshadow
Threedface
Threedhighlight
Threedlightshadow
Threedshadow
Window
Windowframe
Windowtext
MozButtondefault
#
[
parse
(
aliases
=
"
-
moz
-
default
-
color
"
)
]
Canvastext
#
[
parse
(
aliases
=
"
-
moz
-
default
-
background
-
color
"
)
]
Canvas
MozDialog
MozDialogtext
MozDragtargetzone
#
[
parse
(
aliases
=
"
-
moz
-
html
-
cellhighlight
"
)
]
MozCellhighlight
#
[
parse
(
aliases
=
"
-
moz
-
html
-
cellhighlighttext
"
)
]
MozCellhighlighttext
Selecteditem
Selecteditemtext
MozButtonhoverface
MozButtonhovertext
MozMenuhover
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozMenuhoverdisabled
MozMenuhovertext
MozMenubartext
MozMenubarhovertext
MozEventreerow
MozOddtreerow
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozButtonactivetext
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozButtonactiveface
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozButtondisabledface
MozMacChromeActive
MozMacChromeInactive
MozMacDefaultbuttontext
MozMacFocusring
MozMacMenuselect
MozMacMenushadow
MozMacMenutextdisable
MozMacMenutextselect
MozMacDisabledtoolbartext
MozMacSecondaryhighlight
MozMacMenupopup
MozMacMenuitem
MozMacActiveMenuitem
MozMacSourceList
MozMacSourceListSelection
MozMacActiveSourceListSelection
MozMacTooltip
Accentcolor
Accentcolortext
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozAutofillBackground
MozWinMediatext
MozWinCommunicationstext
MozNativehyperlinktext
#
[
css
(
skip
)
]
MozNativevisitedhyperlinktext
#
[
parse
(
aliases
=
"
-
moz
-
hyperlinktext
"
)
]
Linktext
#
[
parse
(
aliases
=
"
-
moz
-
activehyperlinktext
"
)
]
Activetext
#
[
parse
(
aliases
=
"
-
moz
-
visitedhyperlinktext
"
)
]
Visitedtext
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozColheadertext
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozColheaderhovertext
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
TextSelectDisabledBackground
#
[
css
(
skip
)
]
TextSelectAttentionBackground
#
[
css
(
skip
)
]
TextSelectAttentionForeground
#
[
css
(
skip
)
]
TextHighlightBackground
#
[
css
(
skip
)
]
TextHighlightForeground
#
[
css
(
skip
)
]
IMERawInputBackground
#
[
css
(
skip
)
]
IMERawInputForeground
#
[
css
(
skip
)
]
IMERawInputUnderline
#
[
css
(
skip
)
]
IMESelectedRawTextBackground
#
[
css
(
skip
)
]
IMESelectedRawTextForeground
#
[
css
(
skip
)
]
IMESelectedRawTextUnderline
#
[
css
(
skip
)
]
IMEConvertedTextBackground
#
[
css
(
skip
)
]
IMEConvertedTextForeground
#
[
css
(
skip
)
]
IMEConvertedTextUnderline
#
[
css
(
skip
)
]
IMESelectedConvertedTextBackground
#
[
css
(
skip
)
]
IMESelectedConvertedTextForeground
#
[
css
(
skip
)
]
IMESelectedConvertedTextUnderline
#
[
css
(
skip
)
]
SpellCheckerUnderline
#
[
css
(
skip
)
]
ThemedScrollbar
#
[
css
(
skip
)
]
ThemedScrollbarInactive
#
[
css
(
skip
)
]
ThemedScrollbarThumb
#
[
css
(
skip
)
]
ThemedScrollbarThumbHover
#
[
css
(
skip
)
]
ThemedScrollbarThumbActive
#
[
css
(
skip
)
]
ThemedScrollbarThumbInactive
#
[
css
(
skip
)
]
End
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
SystemColor
{
#
[
inline
]
fn
compute
(
&
self
cx
:
&
Context
)
-
>
ComputedColor
{
use
crate
:
:
gecko
:
:
values
:
:
convert_nscolor_to_rgba
;
use
crate
:
:
gecko_bindings
:
:
bindings
;
let
style_color_scheme
=
cx
.
style
(
)
.
get_inherited_ui
(
)
.
clone_color_scheme
(
)
;
let
color
=
cx
.
device
(
)
.
system_nscolor
(
*
self
&
style_color_scheme
)
;
if
color
=
=
bindings
:
:
NS_SAME_AS_FOREGROUND_COLOR
{
return
ComputedColor
:
:
currentcolor
(
)
;
}
ComputedColor
:
:
rgba
(
convert_nscolor_to_rgba
(
color
)
)
}
}
impl
From
<
RGBA
>
for
Color
{
fn
from
(
value
:
RGBA
)
-
>
Self
{
Color
:
:
rgba
(
value
)
}
}
struct
ColorComponentParser
<
'
a
'
b
:
'
a
>
(
&
'
a
ParserContext
<
'
b
>
)
;
impl
<
'
a
'
b
:
'
a
'
i
:
'
a
>
:
:
cssparser
:
:
ColorComponentParser
<
'
i
>
for
ColorComponentParser
<
'
a
'
b
>
{
type
Error
=
StyleParseErrorKind
<
'
i
>
;
fn
parse_angle_or_number
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
AngleOrNumber
ParseError
<
'
i
>
>
{
use
crate
:
:
values
:
:
specified
:
:
Angle
;
let
location
=
input
.
current_source_location
(
)
;
let
token
=
input
.
next
(
)
?
.
clone
(
)
;
match
token
{
Token
:
:
Dimension
{
value
ref
unit
.
.
}
=
>
{
let
angle
=
Angle
:
:
parse_dimension
(
value
unit
false
)
;
let
degrees
=
match
angle
{
Ok
(
angle
)
=
>
angle
.
degrees
(
)
Err
(
(
)
)
=
>
return
Err
(
location
.
new_unexpected_token_error
(
token
.
clone
(
)
)
)
}
;
Ok
(
AngleOrNumber
:
:
Angle
{
degrees
}
)
}
Token
:
:
Number
{
value
.
.
}
=
>
Ok
(
AngleOrNumber
:
:
Number
{
value
}
)
Token
:
:
Function
(
ref
name
)
=
>
{
let
function
=
CalcNode
:
:
math_function
(
name
location
)
?
;
CalcNode
:
:
parse_angle_or_number
(
self
.
0
input
function
)
}
t
=
>
return
Err
(
location
.
new_unexpected_token_error
(
t
)
)
}
}
fn
parse_percentage
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
f32
ParseError
<
'
i
>
>
{
Ok
(
Percentage
:
:
parse
(
self
.
0
input
)
?
.
get
(
)
)
}
fn
parse_number
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
f32
ParseError
<
'
i
>
>
{
use
crate
:
:
values
:
:
specified
:
:
Number
;
Ok
(
Number
:
:
parse
(
self
.
0
input
)
?
.
get
(
)
)
}
fn
parse_number_or_percentage
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
NumberOrPercentage
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
match
*
input
.
next
(
)
?
{
Token
:
:
Number
{
value
.
.
}
=
>
Ok
(
NumberOrPercentage
:
:
Number
{
value
}
)
Token
:
:
Percentage
{
unit_value
.
.
}
=
>
{
Ok
(
NumberOrPercentage
:
:
Percentage
{
unit_value
}
)
}
Token
:
:
Function
(
ref
name
)
=
>
{
let
function
=
CalcNode
:
:
math_function
(
name
location
)
?
;
CalcNode
:
:
parse_number_or_percentage
(
self
.
0
input
function
)
}
ref
t
=
>
return
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
}
}
}
enum
PreserveAuthored
{
No
Yes
}
impl
Parse
for
Color
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
PreserveAuthored
:
:
Yes
)
}
}
impl
Color
{
fn
parse_internal
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
preserve_authored
:
PreserveAuthored
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
authored
=
match
preserve_authored
{
PreserveAuthored
:
:
No
=
>
None
PreserveAuthored
:
:
Yes
=
>
{
let
start
=
input
.
state
(
)
;
let
authored
=
input
.
expect_ident_cloned
(
)
.
ok
(
)
;
input
.
reset
(
&
start
)
;
authored
}
}
;
let
compontent_parser
=
ColorComponentParser
(
&
*
context
)
;
match
input
.
try_parse
(
|
i
|
CSSParserColor
:
:
parse_with
(
&
compontent_parser
i
)
)
{
Ok
(
value
)
=
>
Ok
(
match
value
{
CSSParserColor
:
:
CurrentColor
=
>
Color
:
:
CurrentColor
CSSParserColor
:
:
Absolute
(
absolute
)
=
>
{
let
enabled
=
matches
!
(
absolute
cssparser
:
:
AbsoluteColor
:
:
Rgba
(
_
)
)
|
|
static_prefs
:
:
pref
!
(
"
layout
.
css
.
more_color_4
.
enabled
"
)
;
if
!
enabled
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
Color
:
:
Absolute
(
Box
:
:
new
(
Absolute
{
color
:
absolute
.
into
(
)
authored
:
authored
.
map
(
|
s
|
s
.
to_ascii_lowercase
(
)
.
into_boxed_str
(
)
)
}
)
)
}
}
)
Err
(
e
)
=
>
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
if
let
Ok
(
system
)
=
input
.
try_parse
(
|
i
|
SystemColor
:
:
parse
(
context
i
)
)
{
return
Ok
(
Color
:
:
System
(
system
)
)
;
}
}
if
let
Ok
(
mix
)
=
input
.
try_parse
(
|
i
|
ColorMix
:
:
parse
(
context
i
preserve_authored
)
)
{
return
Ok
(
Color
:
:
ColorMix
(
Box
:
:
new
(
mix
)
)
)
;
}
match
e
.
kind
{
ParseErrorKind
:
:
Basic
(
BasicParseErrorKind
:
:
UnexpectedToken
(
t
)
)
=
>
{
Err
(
e
.
location
.
new_custom_error
(
StyleParseErrorKind
:
:
ValueError
(
ValueParseErrorKind
:
:
InvalidColor
(
t
)
)
)
)
}
_
=
>
Err
(
e
)
}
}
}
}
pub
fn
is_valid
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
bool
{
input
.
parse_entirely
(
|
input
|
Self
:
:
parse_internal
(
context
input
PreserveAuthored
:
:
No
)
)
.
is_ok
(
)
}
pub
fn
parse_and_compute
(
context
:
&
ParserContext
input
:
&
mut
Parser
device
:
Option
<
&
Device
>
)
-
>
Option
<
ComputedColor
>
{
use
crate
:
:
error_reporting
:
:
ContextualParseError
;
let
start
=
input
.
position
(
)
;
let
result
=
input
.
parse_entirely
(
|
input
|
Self
:
:
parse_internal
(
context
input
PreserveAuthored
:
:
No
)
)
;
let
specified
=
match
result
{
Ok
(
s
)
=
>
s
Err
(
e
)
=
>
{
if
!
context
.
error_reporting_enabled
(
)
{
return
None
;
}
if
let
ParseErrorKind
:
:
Custom
(
StyleParseErrorKind
:
:
ValueError
(
.
.
)
)
=
e
.
kind
{
let
location
=
e
.
location
.
clone
(
)
;
let
error
=
ContextualParseError
:
:
UnsupportedValue
(
input
.
slice_from
(
start
)
e
)
;
context
.
log_css_error
(
location
error
)
;
}
return
None
;
}
}
;
match
device
{
Some
(
device
)
=
>
{
Context
:
:
for_media_query_evaluation
(
device
device
.
quirks_mode
(
)
|
context
|
{
specified
.
to_computed_color
(
Some
(
&
context
)
)
}
)
}
None
=
>
specified
.
to_computed_color
(
None
)
}
}
}
impl
ToCss
for
Color
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
*
self
{
Color
:
:
CurrentColor
=
>
cssparser
:
:
ToCss
:
:
to_css
(
&
CSSParserColor
:
:
CurrentColor
dest
)
Color
:
:
Absolute
(
ref
absolute
)
=
>
absolute
.
to_css
(
dest
)
Color
:
:
ColorMix
(
ref
mix
)
=
>
mix
.
to_css
(
dest
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
System
(
system
)
=
>
system
.
to_css
(
dest
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
InheritFromBodyQuirk
=
>
Ok
(
(
)
)
}
}
}
impl
Color
{
pub
fn
honored_in_forced_colors_mode
(
&
self
allow_transparent
:
bool
)
-
>
bool
{
match
*
self
{
Color
:
:
InheritFromBodyQuirk
=
>
false
Color
:
:
CurrentColor
|
Color
:
:
System
(
.
.
)
=
>
true
Color
:
:
Absolute
(
ref
absolute
)
=
>
allow_transparent
&
&
absolute
.
color
.
alpha
(
)
=
=
0
.
0
Color
:
:
ColorMix
(
ref
mix
)
=
>
{
mix
.
left
.
honored_in_forced_colors_mode
(
allow_transparent
)
&
&
mix
.
right
.
honored_in_forced_colors_mode
(
allow_transparent
)
}
}
}
#
[
inline
]
pub
fn
currentcolor
(
)
-
>
Color
{
Color
:
:
CurrentColor
}
#
[
inline
]
pub
fn
transparent
(
)
-
>
Color
{
Color
:
:
rgba
(
RGBA
:
:
transparent
(
)
)
}
#
[
inline
]
pub
fn
rgba
(
rgba
:
RGBA
)
-
>
Self
{
Color
:
:
Absolute
(
Box
:
:
new
(
Absolute
{
color
:
AbsoluteColor
:
:
from_rgba
(
rgba
)
authored
:
None
}
)
)
}
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
try_parse
(
|
i
|
Self
:
:
parse
(
context
i
)
)
.
or_else
(
|
e
|
{
if
!
allow_quirks
.
allowed
(
context
.
quirks_mode
)
{
return
Err
(
e
)
;
}
Color
:
:
parse_quirky_color
(
input
)
.
map
(
Color
:
:
rgba
)
.
map_err
(
|
_
|
e
)
}
)
}
fn
parse_quirky_color
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
RGBA
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
(
value
unit
)
=
match
*
input
.
next
(
)
?
{
Token
:
:
Number
{
int_value
:
Some
(
integer
)
.
.
}
=
>
(
integer
None
)
Token
:
:
Dimension
{
int_value
:
Some
(
integer
)
ref
unit
.
.
}
=
>
(
integer
Some
(
unit
)
)
Token
:
:
Ident
(
ref
ident
)
=
>
{
if
ident
.
len
(
)
!
=
3
&
&
ident
.
len
(
)
!
=
6
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
return
RGBA
:
:
parse_hash
(
ident
.
as_bytes
(
)
)
.
map_err
(
|
(
)
|
{
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
}
)
;
}
ref
t
=
>
{
return
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
;
}
}
;
if
value
<
0
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
let
length
=
if
value
<
=
9
{
1
}
else
if
value
<
=
99
{
2
}
else
if
value
<
=
999
{
3
}
else
if
value
<
=
9999
{
4
}
else
if
value
<
=
99999
{
5
}
else
if
value
<
=
999999
{
6
}
else
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
;
let
total
=
length
+
unit
.
as_ref
(
)
.
map_or
(
0
|
d
|
d
.
len
(
)
)
;
if
total
>
6
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
let
mut
serialization
=
[
b
'
0
'
;
6
]
;
let
space_padding
=
6
-
total
;
let
mut
written
=
space_padding
;
let
mut
buf
=
itoa
:
:
Buffer
:
:
new
(
)
;
let
s
=
buf
.
format
(
value
)
;
(
&
mut
serialization
[
written
.
.
]
)
.
write_all
(
s
.
as_bytes
(
)
)
.
unwrap
(
)
;
written
+
=
s
.
len
(
)
;
if
let
Some
(
unit
)
=
unit
{
written
+
=
(
&
mut
serialization
[
written
.
.
]
)
.
write
(
unit
.
as_bytes
(
)
)
.
unwrap
(
)
;
}
debug_assert_eq
!
(
written
6
)
;
RGBA
:
:
parse_hash
(
&
serialization
)
.
map_err
(
|
(
)
|
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
impl
Color
{
pub
fn
to_computed_color
(
&
self
context
:
Option
<
&
Context
>
)
-
>
Option
<
ComputedColor
>
{
Some
(
match
*
self
{
Color
:
:
CurrentColor
=
>
ComputedColor
:
:
CurrentColor
Color
:
:
Absolute
(
ref
absolute
)
=
>
ComputedColor
:
:
Numeric
(
absolute
.
color
.
to_rgba
(
)
)
Color
:
:
ColorMix
(
ref
mix
)
=
>
{
use
crate
:
:
values
:
:
computed
:
:
percentage
:
:
Percentage
;
let
left
=
mix
.
left
.
to_computed_color
(
context
)
?
;
let
right
=
mix
.
right
.
to_computed_color
(
context
)
?
;
let
mut
color
=
ComputedColor
:
:
ColorMix
(
Box
:
:
new
(
GenericColorMix
{
interpolation
:
mix
.
interpolation
left
left_percentage
:
Percentage
(
mix
.
left_percentage
.
get
(
)
)
right
right_percentage
:
Percentage
(
mix
.
right_percentage
.
get
(
)
)
normalize_weights
:
mix
.
normalize_weights
}
)
)
;
color
.
simplify
(
None
)
;
color
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
System
(
system
)
=
>
system
.
compute
(
context
?
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
InheritFromBodyQuirk
=
>
ComputedColor
:
:
rgba
(
context
?
.
device
(
)
.
body_text_color
(
)
)
}
)
}
}
impl
ToComputedValue
for
Color
{
type
ComputedValue
=
ComputedColor
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
ComputedColor
{
self
.
to_computed_color
(
Some
(
context
)
)
.
unwrap
(
)
}
fn
from_computed_value
(
computed
:
&
ComputedColor
)
-
>
Self
{
match
*
computed
{
ComputedColor
:
:
Numeric
(
ref
color
)
=
>
Color
:
:
rgba
(
*
color
)
ComputedColor
:
:
CurrentColor
=
>
Color
:
:
CurrentColor
ComputedColor
:
:
ColorMix
(
ref
mix
)
=
>
{
Color
:
:
ColorMix
(
Box
:
:
new
(
ToComputedValue
:
:
from_computed_value
(
&
*
*
mix
)
)
)
}
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToCss
ToShmem
)
]
pub
struct
MozFontSmoothingBackgroundColor
(
pub
Color
)
;
impl
Parse
for
MozFontSmoothingBackgroundColor
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Color
:
:
parse
(
context
input
)
.
map
(
MozFontSmoothingBackgroundColor
)
}
}
impl
ToComputedValue
for
MozFontSmoothingBackgroundColor
{
type
ComputedValue
=
RGBA
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
RGBA
{
self
.
0
.
to_computed_value
(
context
)
.
into_rgba
(
RGBA
:
:
transparent
(
)
)
}
fn
from_computed_value
(
computed
:
&
RGBA
)
-
>
Self
{
MozFontSmoothingBackgroundColor
(
Color
:
:
rgba
(
*
computed
)
)
}
}
impl
SpecifiedValueInfo
for
Color
{
const
SUPPORTED_TYPES
:
u8
=
CssType
:
:
COLOR
;
fn
collect_completion_keywords
(
f
:
KeywordsCollectFn
)
{
f
(
&
[
"
rgb
"
"
rgba
"
"
hsl
"
"
hsla
"
"
hwb
"
"
currentColor
"
"
transparent
"
]
)
;
if
static_prefs
:
:
pref
!
(
"
layout
.
css
.
color
-
mix
.
enabled
"
)
{
f
(
&
[
"
color
-
mix
"
]
)
;
}
if
static_prefs
:
:
pref
!
(
"
layout
.
css
.
more_color_4
.
enabled
"
)
{
f
(
&
[
"
color
"
"
lab
"
"
lch
"
"
oklab
"
"
oklch
"
]
)
;
}
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
SpecifiedValueInfo
ToCss
ToShmem
)
]
pub
struct
ColorPropertyValue
(
pub
Color
)
;
impl
ToComputedValue
for
ColorPropertyValue
{
type
ComputedValue
=
RGBA
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
RGBA
{
self
.
0
.
to_computed_value
(
context
)
.
into_rgba
(
context
.
builder
.
get_parent_inherited_text
(
)
.
clone_color
(
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
RGBA
)
-
>
Self
{
ColorPropertyValue
(
Color
:
:
rgba
(
*
computed
)
.
into
(
)
)
}
}
impl
Parse
for
ColorPropertyValue
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Color
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
Yes
)
.
map
(
ColorPropertyValue
)
}
}
pub
type
ColorOrAuto
=
GenericColorOrAuto
<
Color
>
;
pub
type
CaretColor
=
GenericCaretColor
<
Color
>
;
impl
Parse
for
CaretColor
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
ColorOrAuto
:
:
parse
(
context
input
)
.
map
(
GenericCaretColor
)
}
}
bitflags
!
{
/
/
/
Various
flags
to
represent
the
color
-
scheme
property
in
an
efficient
/
/
/
way
.
#
[
derive
(
Default
MallocSizeOf
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
#
[
value_info
(
other_values
=
"
light
dark
only
"
)
]
pub
struct
ColorSchemeFlags
:
u8
{
/
/
/
Whether
the
author
specified
light
.
const
LIGHT
=
1
<
<
0
;
/
/
/
Whether
the
author
specified
dark
.
const
DARK
=
1
<
<
1
;
/
/
/
Whether
the
author
specified
only
.
const
ONLY
=
1
<
<
2
;
}
}
#
[
derive
(
Clone
Debug
Default
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
#
[
value_info
(
other_values
=
"
normal
"
)
]
pub
struct
ColorScheme
{
#
[
ignore_malloc_size_of
=
"
Arc
"
]
idents
:
crate
:
:
ArcSlice
<
CustomIdent
>
bits
:
ColorSchemeFlags
}
impl
ColorScheme
{
pub
fn
normal
(
)
-
>
Self
{
Self
{
idents
:
Default
:
:
default
(
)
bits
:
ColorSchemeFlags
:
:
empty
(
)
}
}
pub
fn
raw_bits
(
&
self
)
-
>
u8
{
self
.
bits
.
bits
}
}
impl
Parse
for
ColorScheme
{
fn
parse
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
idents
=
vec
!
[
]
;
let
mut
bits
=
ColorSchemeFlags
:
:
empty
(
)
;
let
mut
location
=
input
.
current_source_location
(
)
;
while
let
Ok
(
ident
)
=
input
.
try_parse
(
|
i
|
i
.
expect_ident_cloned
(
)
)
{
let
mut
is_only
=
false
;
match_ignore_ascii_case
!
{
&
ident
"
normal
"
=
>
{
if
idents
.
is_empty
(
)
&
&
bits
.
is_empty
(
)
{
return
Ok
(
Self
:
:
normal
(
)
)
;
}
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
"
light
"
=
>
bits
.
insert
(
ColorSchemeFlags
:
:
LIGHT
)
"
dark
"
=
>
bits
.
insert
(
ColorSchemeFlags
:
:
DARK
)
"
only
"
=
>
{
if
bits
.
intersects
(
ColorSchemeFlags
:
:
ONLY
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
bits
.
insert
(
ColorSchemeFlags
:
:
ONLY
)
;
is_only
=
true
;
}
_
=
>
{
}
}
;
if
is_only
{
if
!
idents
.
is_empty
(
)
{
break
;
}
}
else
{
idents
.
push
(
CustomIdent
:
:
from_ident
(
location
&
ident
&
[
]
)
?
)
;
}
location
=
input
.
current_source_location
(
)
;
}
if
idents
.
is_empty
(
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
Ok
(
Self
{
idents
:
crate
:
:
ArcSlice
:
:
from_iter
(
idents
.
into_iter
(
)
)
bits
}
)
}
}
impl
ToCss
for
ColorScheme
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
self
.
idents
.
is_empty
(
)
{
debug_assert
!
(
self
.
bits
.
is_empty
(
)
)
;
return
dest
.
write_str
(
"
normal
"
)
;
}
let
mut
first
=
true
;
for
ident
in
self
.
idents
.
iter
(
)
{
if
!
first
{
dest
.
write_char
(
'
'
)
?
;
}
first
=
false
;
ident
.
to_css
(
dest
)
?
;
}
if
self
.
bits
.
intersects
(
ColorSchemeFlags
:
:
ONLY
)
{
dest
.
write_str
(
"
only
"
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToCss
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
PrintColorAdjust
{
Economy
Exact
}
