use
super
:
:
AllowQuirks
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
gecko_bindings
:
:
structs
:
:
nscolor
;
use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
properties
:
:
longhands
:
:
system_colors
:
:
SystemColor
;
use
crate
:
:
values
:
:
computed
:
:
{
Color
as
ComputedColor
Context
ToComputedValue
}
;
use
crate
:
:
values
:
:
generics
:
:
color
:
:
{
Color
as
GenericColor
ColorOrAuto
as
GenericColorOrAuto
}
;
use
crate
:
:
values
:
:
specified
:
:
calc
:
:
CalcNode
;
use
cssparser
:
:
{
AngleOrNumber
Color
as
CSSParserColor
Parser
Token
RGBA
}
;
use
cssparser
:
:
{
BasicParseErrorKind
NumberOrPercentage
ParseErrorKind
}
;
use
itoa
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
io
:
:
Write
as
IoWrite
;
use
style_traits
:
:
{
CssType
CssWriter
KeywordsCollectFn
ParseError
StyleParseErrorKind
}
;
use
style_traits
:
:
{
SpecifiedValueInfo
ToCss
ValueParseErrorKind
}
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
)
]
pub
enum
Color
{
CurrentColor
Numeric
{
parsed
:
RGBA
authored
:
Option
<
Box
<
str
>
>
}
Complex
(
ComputedColor
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
System
(
SystemColor
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Special
(
gecko
:
:
SpecialColorKeyword
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
InheritFromBodyQuirk
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
mod
gecko
{
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
ToCss
)
]
pub
enum
SpecialColorKeyword
{
MozDefaultColor
MozDefaultBackgroundColor
MozHyperlinktext
MozActivehyperlinktext
MozVisitedhyperlinktext
}
}
impl
From
<
RGBA
>
for
Color
{
fn
from
(
value
:
RGBA
)
-
>
Self
{
Color
:
:
rgba
(
value
)
}
}
struct
ColorComponentParser
<
'
a
'
b
:
'
a
>
(
&
'
a
ParserContext
<
'
b
>
)
;
impl
<
'
a
'
b
:
'
a
'
i
:
'
a
>
:
:
cssparser
:
:
ColorComponentParser
<
'
i
>
for
ColorComponentParser
<
'
a
'
b
>
{
type
Error
=
StyleParseErrorKind
<
'
i
>
;
fn
parse_angle_or_number
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
AngleOrNumber
ParseError
<
'
i
>
>
{
use
crate
:
:
values
:
:
specified
:
:
Angle
;
let
location
=
input
.
current_source_location
(
)
;
let
token
=
input
.
next
(
)
?
.
clone
(
)
;
match
token
{
Token
:
:
Dimension
{
value
ref
unit
.
.
}
=
>
{
let
angle
=
Angle
:
:
parse_dimension
(
value
unit
false
)
;
let
degrees
=
match
angle
{
Ok
(
angle
)
=
>
angle
.
degrees
(
)
Err
(
(
)
)
=
>
return
Err
(
location
.
new_unexpected_token_error
(
token
.
clone
(
)
)
)
}
;
Ok
(
AngleOrNumber
:
:
Angle
{
degrees
}
)
}
Token
:
:
Number
{
value
.
.
}
=
>
Ok
(
AngleOrNumber
:
:
Number
{
value
}
)
Token
:
:
Function
(
ref
name
)
if
name
.
eq_ignore_ascii_case
(
"
calc
"
)
=
>
{
input
.
parse_nested_block
(
|
i
|
CalcNode
:
:
parse_angle_or_number
(
self
.
0
i
)
)
}
t
=
>
return
Err
(
location
.
new_unexpected_token_error
(
t
)
)
}
}
fn
parse_percentage
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
f32
ParseError
<
'
i
>
>
{
use
crate
:
:
values
:
:
specified
:
:
Percentage
;
Ok
(
Percentage
:
:
parse
(
self
.
0
input
)
?
.
get
(
)
)
}
fn
parse_number
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
f32
ParseError
<
'
i
>
>
{
use
crate
:
:
values
:
:
specified
:
:
Number
;
Ok
(
Number
:
:
parse
(
self
.
0
input
)
?
.
get
(
)
)
}
fn
parse_number_or_percentage
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
NumberOrPercentage
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
match
input
.
next
(
)
?
.
clone
(
)
{
Token
:
:
Number
{
value
.
.
}
=
>
Ok
(
NumberOrPercentage
:
:
Number
{
value
}
)
Token
:
:
Percentage
{
unit_value
.
.
}
=
>
{
Ok
(
NumberOrPercentage
:
:
Percentage
{
unit_value
}
)
}
Token
:
:
Function
(
ref
name
)
if
name
.
eq_ignore_ascii_case
(
"
calc
"
)
=
>
{
input
.
parse_nested_block
(
|
i
|
CalcNode
:
:
parse_number_or_percentage
(
self
.
0
i
)
)
}
t
=
>
return
Err
(
location
.
new_unexpected_token_error
(
t
)
)
}
}
}
impl
Parse
for
Color
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
start
=
input
.
state
(
)
;
let
authored
=
input
.
expect_ident_cloned
(
)
.
ok
(
)
;
input
.
reset
(
&
start
)
;
let
compontent_parser
=
ColorComponentParser
(
&
*
context
)
;
match
input
.
try
(
|
i
|
CSSParserColor
:
:
parse_with
(
&
compontent_parser
i
)
)
{
Ok
(
value
)
=
>
Ok
(
match
value
{
CSSParserColor
:
:
CurrentColor
=
>
Color
:
:
CurrentColor
CSSParserColor
:
:
RGBA
(
rgba
)
=
>
Color
:
:
Numeric
{
parsed
:
rgba
authored
:
authored
.
map
(
|
s
|
s
.
to_ascii_lowercase
(
)
.
into_boxed_str
(
)
)
}
}
)
Err
(
e
)
=
>
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
if
let
Ok
(
ident
)
=
input
.
expect_ident
(
)
{
if
let
Ok
(
system
)
=
SystemColor
:
:
from_ident
(
ident
)
{
return
Ok
(
Color
:
:
System
(
system
)
)
;
}
if
let
Ok
(
c
)
=
gecko
:
:
SpecialColorKeyword
:
:
from_ident
(
ident
)
{
return
Ok
(
Color
:
:
Special
(
c
)
)
;
}
}
}
match
e
.
kind
{
ParseErrorKind
:
:
Basic
(
BasicParseErrorKind
:
:
UnexpectedToken
(
t
)
)
=
>
{
Err
(
e
.
location
.
new_custom_error
(
StyleParseErrorKind
:
:
ValueError
(
ValueParseErrorKind
:
:
InvalidColor
(
t
)
)
)
)
}
_
=
>
Err
(
e
)
}
}
}
}
}
impl
ToCss
for
Color
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
*
self
{
Color
:
:
CurrentColor
=
>
CSSParserColor
:
:
CurrentColor
.
to_css
(
dest
)
Color
:
:
Numeric
{
authored
:
Some
(
ref
authored
)
.
.
}
=
>
dest
.
write_str
(
authored
)
Color
:
:
Numeric
{
parsed
:
ref
rgba
.
.
}
=
>
rgba
.
to_css
(
dest
)
Color
:
:
Complex
(
_
)
=
>
Ok
(
(
)
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
System
(
system
)
=
>
system
.
to_css
(
dest
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
Special
(
special
)
=
>
special
.
to_css
(
dest
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
InheritFromBodyQuirk
=
>
Ok
(
(
)
)
}
}
}
fn
parse_hash_color
(
value
:
&
[
u8
]
)
-
>
Result
<
RGBA
(
)
>
{
CSSParserColor
:
:
parse_hash
(
value
)
.
map
(
|
color
|
match
color
{
CSSParserColor
:
:
RGBA
(
rgba
)
=
>
rgba
CSSParserColor
:
:
CurrentColor
=
>
unreachable
!
(
"
parse_hash
should
never
return
currentcolor
"
)
}
)
}
impl
Color
{
#
[
inline
]
pub
fn
currentcolor
(
)
-
>
Color
{
Color
:
:
CurrentColor
}
#
[
inline
]
pub
fn
transparent
(
)
-
>
Color
{
Color
:
:
rgba
(
RGBA
:
:
transparent
(
)
)
}
#
[
inline
]
pub
fn
rgba
(
rgba
:
RGBA
)
-
>
Self
{
Color
:
:
Numeric
{
parsed
:
rgba
authored
:
None
}
}
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
try
(
|
i
|
Self
:
:
parse
(
context
i
)
)
.
or_else
(
|
e
|
{
if
!
allow_quirks
.
allowed
(
context
.
quirks_mode
)
{
return
Err
(
e
)
;
}
Color
:
:
parse_quirky_color
(
input
)
.
map
(
Color
:
:
rgba
)
.
map_err
(
|
_
|
e
)
}
)
}
fn
parse_quirky_color
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
RGBA
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
(
value
unit
)
=
match
*
input
.
next
(
)
?
{
Token
:
:
Number
{
int_value
:
Some
(
integer
)
.
.
}
=
>
(
integer
None
)
Token
:
:
Dimension
{
int_value
:
Some
(
integer
)
ref
unit
.
.
}
=
>
(
integer
Some
(
unit
)
)
Token
:
:
Ident
(
ref
ident
)
=
>
{
if
ident
.
len
(
)
!
=
3
&
&
ident
.
len
(
)
!
=
6
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
return
parse_hash_color
(
ident
.
as_bytes
(
)
)
.
map_err
(
|
(
)
|
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
ref
t
=
>
{
return
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
;
}
}
;
if
value
<
0
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
let
length
=
if
value
<
=
9
{
1
}
else
if
value
<
=
99
{
2
}
else
if
value
<
=
999
{
3
}
else
if
value
<
=
9999
{
4
}
else
if
value
<
=
99999
{
5
}
else
if
value
<
=
999999
{
6
}
else
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
;
let
total
=
length
+
unit
.
as_ref
(
)
.
map_or
(
0
|
d
|
d
.
len
(
)
)
;
if
total
>
6
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
let
mut
serialization
=
[
b
'
0
'
;
6
]
;
let
space_padding
=
6
-
total
;
let
mut
written
=
space_padding
;
written
+
=
itoa
:
:
write
(
&
mut
serialization
[
written
.
.
]
value
)
.
unwrap
(
)
;
if
let
Some
(
unit
)
=
unit
{
written
+
=
(
&
mut
serialization
[
written
.
.
]
)
.
write
(
unit
.
as_bytes
(
)
)
.
unwrap
(
)
;
}
debug_assert_eq
!
(
written
6
)
;
parse_hash_color
(
&
serialization
)
.
map_err
(
|
(
)
|
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
is_transparent
(
&
self
)
-
>
bool
{
match
*
self
{
Color
:
:
Numeric
{
ref
parsed
.
.
}
=
>
parsed
.
alpha
=
=
0
_
=
>
false
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
convert_nscolor_to_computedcolor
(
color
:
nscolor
)
-
>
ComputedColor
{
use
crate
:
:
gecko
:
:
values
:
:
convert_nscolor_to_rgba
;
ComputedColor
:
:
rgba
(
convert_nscolor_to_rgba
(
color
)
)
}
impl
Color
{
pub
fn
to_computed_color
(
&
self
_context
:
Option
<
&
Context
>
)
-
>
Option
<
ComputedColor
>
{
match
*
self
{
Color
:
:
CurrentColor
=
>
Some
(
ComputedColor
:
:
currentcolor
(
)
)
Color
:
:
Numeric
{
ref
parsed
.
.
}
=
>
Some
(
ComputedColor
:
:
rgba
(
*
parsed
)
)
Color
:
:
Complex
(
ref
complex
)
=
>
Some
(
*
complex
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
System
(
system
)
=
>
_context
.
map
(
|
context
|
convert_nscolor_to_computedcolor
(
system
.
to_computed_value
(
context
)
)
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
Special
(
special
)
=
>
{
use
self
:
:
gecko
:
:
SpecialColorKeyword
as
Keyword
;
_context
.
map
(
|
context
|
{
let
pres_context
=
context
.
device
(
)
.
pres_context
(
)
;
convert_nscolor_to_computedcolor
(
match
special
{
Keyword
:
:
MozDefaultColor
=
>
pres_context
.
mDefaultColor
Keyword
:
:
MozDefaultBackgroundColor
=
>
pres_context
.
mBackgroundColor
Keyword
:
:
MozHyperlinktext
=
>
pres_context
.
mLinkColor
Keyword
:
:
MozActivehyperlinktext
=
>
pres_context
.
mActiveLinkColor
Keyword
:
:
MozVisitedhyperlinktext
=
>
pres_context
.
mVisitedLinkColor
}
)
}
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
Color
:
:
InheritFromBodyQuirk
=
>
{
_context
.
map
(
|
context
|
ComputedColor
:
:
rgba
(
context
.
device
(
)
.
body_text_color
(
)
)
)
}
}
}
}
impl
ToComputedValue
for
Color
{
type
ComputedValue
=
ComputedColor
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
ComputedColor
{
let
result
=
self
.
to_computed_color
(
Some
(
context
)
)
.
unwrap
(
)
;
if
!
result
.
is_numeric
(
)
{
if
let
Some
(
longhand
)
=
context
.
for_non_inherited_property
{
if
longhand
.
stores_complex_colors_lossily
(
)
{
context
.
rule_cache_conditions
.
borrow_mut
(
)
.
set_uncacheable
(
)
;
}
}
}
result
}
fn
from_computed_value
(
computed
:
&
ComputedColor
)
-
>
Self
{
match
*
computed
{
GenericColor
:
:
Numeric
(
color
)
=
>
Color
:
:
rgba
(
color
)
GenericColor
:
:
Foreground
=
>
Color
:
:
currentcolor
(
)
GenericColor
:
:
Complex
(
.
.
)
=
>
Color
:
:
Complex
(
*
computed
)
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToCss
)
]
pub
struct
RGBAColor
(
pub
Color
)
;
impl
Parse
for
RGBAColor
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Color
:
:
parse
(
context
input
)
.
map
(
RGBAColor
)
}
}
impl
ToComputedValue
for
RGBAColor
{
type
ComputedValue
=
RGBA
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
RGBA
{
self
.
0
.
to_computed_value
(
context
)
.
to_rgba
(
context
.
style
(
)
.
get_color
(
)
.
clone_color
(
)
)
}
fn
from_computed_value
(
computed
:
&
RGBA
)
-
>
Self
{
RGBAColor
(
Color
:
:
rgba
(
*
computed
)
)
}
}
impl
From
<
Color
>
for
RGBAColor
{
fn
from
(
color
:
Color
)
-
>
RGBAColor
{
RGBAColor
(
color
)
}
}
impl
SpecifiedValueInfo
for
Color
{
const
SUPPORTED_TYPES
:
u8
=
CssType
:
:
COLOR
;
fn
collect_completion_keywords
(
f
:
KeywordsCollectFn
)
{
f
(
&
[
"
rgb
"
"
rgba
"
"
hsl
"
"
hsla
"
"
currentColor
"
"
transparent
"
]
)
;
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
SpecifiedValueInfo
ToCss
)
]
pub
struct
ColorPropertyValue
(
pub
Color
)
;
impl
ToComputedValue
for
ColorPropertyValue
{
type
ComputedValue
=
RGBA
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
RGBA
{
self
.
0
.
to_computed_value
(
context
)
.
to_rgba
(
context
.
builder
.
get_parent_color
(
)
.
clone_color
(
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
RGBA
)
-
>
Self
{
ColorPropertyValue
(
Color
:
:
rgba
(
*
computed
)
.
into
(
)
)
}
}
impl
Parse
for
ColorPropertyValue
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Color
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
Yes
)
.
map
(
ColorPropertyValue
)
}
}
pub
type
ColorOrAuto
=
GenericColorOrAuto
<
Color
>
;
