use
cssparser
:
:
Parser
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
style_traits
:
:
{
CommaWithSpace
ParseError
Separator
StyleParseErrorKind
}
;
use
values
:
:
generics
:
:
svg
as
generic
;
use
values
:
:
specified
:
:
{
LengthOrPercentage
NonNegativeLengthOrPercentage
NonNegativeNumber
}
;
use
values
:
:
specified
:
:
{
Number
Opacity
SpecifiedUrl
}
;
use
values
:
:
specified
:
:
color
:
:
RGBAColor
;
pub
type
SVGPaint
=
generic
:
:
SVGPaint
<
RGBAColor
SpecifiedUrl
>
;
pub
type
SVGPaintKind
=
generic
:
:
SVGPaintKind
<
RGBAColor
SpecifiedUrl
>
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
is_context_value_enabled
(
)
-
>
bool
{
use
gecko_bindings
:
:
structs
:
:
mozilla
;
unsafe
{
mozilla
:
:
StylePrefs_sOpentypeSVGEnabled
}
}
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
fn
is_context_value_enabled
(
)
-
>
bool
{
false
}
fn
parse_context_value
<
'
i
'
t
T
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
value
:
T
)
-
>
Result
<
T
ParseError
<
'
i
>
>
{
if
is_context_value_enabled
(
)
{
if
input
.
expect_ident_matching
(
"
context
-
value
"
)
.
is_ok
(
)
{
return
Ok
(
value
)
;
}
}
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
type
SvgLengthOrPercentageOrNumber
=
generic
:
:
SvgLengthOrPercentageOrNumber
<
LengthOrPercentage
Number
>
;
pub
type
SVGLength
=
generic
:
:
SVGLength
<
SvgLengthOrPercentageOrNumber
>
;
impl
Parse
for
SVGLength
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
try
(
|
i
|
SvgLengthOrPercentageOrNumber
:
:
parse
(
context
i
)
)
.
map
(
Into
:
:
into
)
.
or_else
(
|
_
|
parse_context_value
(
input
generic
:
:
SVGLength
:
:
ContextValue
)
)
}
}
impl
From
<
SvgLengthOrPercentageOrNumber
>
for
SVGLength
{
fn
from
(
length
:
SvgLengthOrPercentageOrNumber
)
-
>
Self
{
generic
:
:
SVGLength
:
:
Length
(
length
)
}
}
pub
type
NonNegativeSvgLengthOrPercentageOrNumber
=
generic
:
:
SvgLengthOrPercentageOrNumber
<
NonNegativeLengthOrPercentage
NonNegativeNumber
>
;
pub
type
SVGWidth
=
generic
:
:
SVGLength
<
NonNegativeSvgLengthOrPercentageOrNumber
>
;
impl
Parse
for
SVGWidth
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
try
(
|
i
|
NonNegativeSvgLengthOrPercentageOrNumber
:
:
parse
(
context
i
)
)
.
map
(
Into
:
:
into
)
.
or_else
(
|
_
|
parse_context_value
(
input
generic
:
:
SVGLength
:
:
ContextValue
)
)
}
}
impl
From
<
NonNegativeSvgLengthOrPercentageOrNumber
>
for
SVGWidth
{
fn
from
(
length
:
NonNegativeSvgLengthOrPercentageOrNumber
)
-
>
Self
{
generic
:
:
SVGLength
:
:
Length
(
length
)
}
}
pub
type
SVGStrokeDashArray
=
generic
:
:
SVGStrokeDashArray
<
NonNegativeSvgLengthOrPercentageOrNumber
>
;
impl
Parse
for
SVGStrokeDashArray
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
values
)
=
input
.
try
(
|
i
|
CommaWithSpace
:
:
parse
(
i
|
i
|
{
NonNegativeSvgLengthOrPercentageOrNumber
:
:
parse
(
context
i
)
}
)
)
{
Ok
(
generic
:
:
SVGStrokeDashArray
:
:
Values
(
values
)
)
}
else
if
let
Ok
(
_
)
=
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
none
"
)
)
{
Ok
(
generic
:
:
SVGStrokeDashArray
:
:
Values
(
vec
!
[
]
)
)
}
else
{
parse_context_value
(
input
generic
:
:
SVGStrokeDashArray
:
:
ContextValue
)
}
}
}
pub
type
SVGOpacity
=
generic
:
:
SVGOpacity
<
Opacity
>
;
impl
Parse
for
SVGOpacity
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
opacity
)
=
input
.
try
(
|
i
|
Opacity
:
:
parse
(
context
i
)
)
{
Ok
(
generic
:
:
SVGOpacity
:
:
Opacity
(
opacity
)
)
}
else
if
is_context_value_enabled
(
)
{
try_match_ident_ignore_ascii_case
!
{
input
"
context
-
fill
-
opacity
"
=
>
Ok
(
generic
:
:
SVGOpacity
:
:
ContextFillOpacity
)
"
context
-
stroke
-
opacity
"
=
>
Ok
(
generic
:
:
SVGOpacity
:
:
ContextStrokeOpacity
)
}
}
else
{
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
}
