use
cssparser
:
:
Parser
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CommaWithSpace
CssWriter
ParseError
Separator
}
;
use
style_traits
:
:
{
StyleParseErrorKind
ToCss
}
;
use
values
:
:
CustomIdent
;
use
values
:
:
generics
:
:
svg
as
generic
;
use
values
:
:
specified
:
:
{
LengthOrPercentage
NonNegativeLengthOrPercentage
NonNegativeNumber
}
;
use
values
:
:
specified
:
:
{
Number
Opacity
}
;
use
values
:
:
specified
:
:
color
:
:
Color
;
use
values
:
:
specified
:
:
url
:
:
SpecifiedUrl
;
pub
type
SVGPaint
=
generic
:
:
SVGPaint
<
Color
SpecifiedUrl
>
;
pub
type
SVGPaintKind
=
generic
:
:
SVGPaintKind
<
Color
SpecifiedUrl
>
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
is_context_value_enabled
(
)
-
>
bool
{
use
gecko_bindings
:
:
structs
:
:
mozilla
;
unsafe
{
mozilla
:
:
StaticPrefs_sVarCache_gfx_font_rendering_opentype_svg_enabled
}
}
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
fn
is_context_value_enabled
(
)
-
>
bool
{
false
}
fn
parse_context_value
<
'
i
'
t
T
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
value
:
T
)
-
>
Result
<
T
ParseError
<
'
i
>
>
{
if
!
is_context_value_enabled
(
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
input
.
expect_ident_matching
(
"
context
-
value
"
)
?
;
Ok
(
value
)
}
pub
type
SvgLengthOrPercentageOrNumber
=
generic
:
:
SvgLengthOrPercentageOrNumber
<
LengthOrPercentage
Number
>
;
pub
type
SVGLength
=
generic
:
:
SVGLength
<
SvgLengthOrPercentageOrNumber
>
;
impl
Parse
for
SVGLength
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
try
(
|
i
|
SvgLengthOrPercentageOrNumber
:
:
parse
(
context
i
)
)
.
map
(
Into
:
:
into
)
.
or_else
(
|
_
|
parse_context_value
(
input
generic
:
:
SVGLength
:
:
ContextValue
)
)
}
}
impl
From
<
SvgLengthOrPercentageOrNumber
>
for
SVGLength
{
fn
from
(
length
:
SvgLengthOrPercentageOrNumber
)
-
>
Self
{
generic
:
:
SVGLength
:
:
Length
(
length
)
}
}
pub
type
NonNegativeSvgLengthOrPercentageOrNumber
=
generic
:
:
SvgLengthOrPercentageOrNumber
<
NonNegativeLengthOrPercentage
NonNegativeNumber
>
;
pub
type
SVGWidth
=
generic
:
:
SVGLength
<
NonNegativeSvgLengthOrPercentageOrNumber
>
;
impl
Parse
for
SVGWidth
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
try
(
|
i
|
NonNegativeSvgLengthOrPercentageOrNumber
:
:
parse
(
context
i
)
)
.
map
(
Into
:
:
into
)
.
or_else
(
|
_
|
parse_context_value
(
input
generic
:
:
SVGLength
:
:
ContextValue
)
)
}
}
impl
From
<
NonNegativeSvgLengthOrPercentageOrNumber
>
for
SVGWidth
{
fn
from
(
length
:
NonNegativeSvgLengthOrPercentageOrNumber
)
-
>
Self
{
generic
:
:
SVGLength
:
:
Length
(
length
)
}
}
pub
type
SVGStrokeDashArray
=
generic
:
:
SVGStrokeDashArray
<
NonNegativeSvgLengthOrPercentageOrNumber
>
;
impl
Parse
for
SVGStrokeDashArray
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
values
)
=
input
.
try
(
|
i
|
{
CommaWithSpace
:
:
parse
(
i
|
i
|
{
NonNegativeSvgLengthOrPercentageOrNumber
:
:
parse
(
context
i
)
}
)
}
)
{
Ok
(
generic
:
:
SVGStrokeDashArray
:
:
Values
(
values
)
)
}
else
if
let
Ok
(
_
)
=
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
none
"
)
)
{
Ok
(
generic
:
:
SVGStrokeDashArray
:
:
Values
(
vec
!
[
]
)
)
}
else
{
parse_context_value
(
input
generic
:
:
SVGStrokeDashArray
:
:
ContextValue
)
}
}
}
pub
type
SVGOpacity
=
generic
:
:
SVGOpacity
<
Opacity
>
;
impl
Parse
for
SVGOpacity
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
opacity
)
=
input
.
try
(
|
i
|
Opacity
:
:
parse
(
context
i
)
)
{
return
Ok
(
generic
:
:
SVGOpacity
:
:
Opacity
(
opacity
)
)
;
}
try_match_ident_ignore_ascii_case
!
{
input
"
context
-
fill
-
opacity
"
=
>
Ok
(
generic
:
:
SVGOpacity
:
:
ContextFillOpacity
)
"
context
-
stroke
-
opacity
"
=
>
Ok
(
generic
:
:
SVGOpacity
:
:
ContextStrokeOpacity
)
}
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Ord
PartialEq
PartialOrd
ToCss
)
]
pub
enum
PaintOrder
{
Normal
=
0
Fill
=
1
Stroke
=
2
Markers
=
3
}
const
PAINT_ORDER_COUNT
:
u8
=
3
;
const
PAINT_ORDER_SHIFT
:
u8
=
2
;
const
PAINT_ORDER_MASK
:
u8
=
0b11
;
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
)
]
pub
struct
SVGPaintOrder
(
pub
u8
)
;
impl
SVGPaintOrder
{
pub
fn
normal
(
)
-
>
Self
{
SVGPaintOrder
(
0
)
}
pub
fn
order_at
(
&
self
pos
:
u8
)
-
>
PaintOrder
{
unsafe
{
:
:
std
:
:
mem
:
:
transmute
(
(
self
.
0
>
>
pos
*
PAINT_ORDER_SHIFT
)
&
PAINT_ORDER_MASK
)
}
}
}
impl
Parse
for
SVGPaintOrder
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
SVGPaintOrder
ParseError
<
'
i
>
>
{
if
let
Ok
(
(
)
)
=
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
normal
"
)
)
{
return
Ok
(
SVGPaintOrder
:
:
normal
(
)
)
;
}
let
mut
value
=
0
;
let
mut
seen
=
0
;
let
mut
pos
=
0
;
loop
{
let
result
:
Result
<
_
ParseError
>
=
input
.
try
(
|
input
|
{
try_match_ident_ignore_ascii_case
!
{
input
"
fill
"
=
>
Ok
(
PaintOrder
:
:
Fill
)
"
stroke
"
=
>
Ok
(
PaintOrder
:
:
Stroke
)
"
markers
"
=
>
Ok
(
PaintOrder
:
:
Markers
)
}
}
)
;
match
result
{
Ok
(
val
)
=
>
{
if
(
seen
&
(
1
<
<
val
as
u8
)
)
!
=
0
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
value
|
=
(
val
as
u8
)
<
<
(
pos
*
PAINT_ORDER_SHIFT
)
;
seen
|
=
1
<
<
(
val
as
u8
)
;
pos
+
=
1
;
}
Err
(
_
)
=
>
break
}
}
if
value
=
=
0
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
for
i
in
pos
.
.
PAINT_ORDER_COUNT
{
for
paint
in
0
.
.
PAINT_ORDER_COUNT
{
if
(
seen
&
(
1
<
<
paint
)
)
=
=
0
{
seen
|
=
1
<
<
paint
;
value
|
=
paint
<
<
(
i
*
PAINT_ORDER_SHIFT
)
;
break
;
}
}
}
Ok
(
SVGPaintOrder
(
value
)
)
}
}
impl
ToCss
for
SVGPaintOrder
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
self
.
0
=
=
0
{
return
dest
.
write_str
(
"
normal
"
)
;
}
let
mut
last_pos_to_serialize
=
0
;
for
i
in
(
1
.
.
PAINT_ORDER_COUNT
)
.
rev
(
)
{
let
component
=
self
.
order_at
(
i
)
;
let
earlier_component
=
self
.
order_at
(
i
-
1
)
;
if
component
<
earlier_component
{
last_pos_to_serialize
=
i
-
1
;
break
;
}
}
for
pos
in
0
.
.
last_pos_to_serialize
+
1
{
if
pos
!
=
0
{
dest
.
write_str
(
"
"
)
?
}
self
.
order_at
(
pos
)
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
struct
MozContextProperties
(
pub
CustomIdent
)
;
impl
Parse
for
MozContextProperties
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
MozContextProperties
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
i
=
input
.
expect_ident
(
)
?
;
Ok
(
MozContextProperties
(
CustomIdent
:
:
from_ident
(
location
i
&
[
"
all
"
"
none
"
"
auto
"
]
)
?
)
)
}
}
