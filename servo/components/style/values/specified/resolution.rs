use
cssparser
:
:
{
Parser
Token
}
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
style_traits
:
:
{
ParseError
StyleParseErrorKind
}
;
use
values
:
:
CSSFloat
;
#
[
derive
(
Clone
Debug
PartialEq
ToCss
)
]
pub
enum
Resolution
{
#
[
css
(
dimension
)
]
Dpi
(
CSSFloat
)
#
[
css
(
dimension
)
]
X
(
CSSFloat
)
#
[
css
(
dimension
)
]
Dppx
(
CSSFloat
)
#
[
css
(
dimension
)
]
Dpcm
(
CSSFloat
)
}
impl
Resolution
{
pub
fn
to_dppx
(
&
self
)
-
>
CSSFloat
{
match
*
self
{
Resolution
:
:
X
(
f
)
|
Resolution
:
:
Dppx
(
f
)
=
>
f
_
=
>
self
.
to_dpi
(
)
/
96
.
0
}
}
pub
fn
to_dpi
(
&
self
)
-
>
CSSFloat
{
match
*
self
{
Resolution
:
:
Dpi
(
f
)
=
>
f
Resolution
:
:
X
(
f
)
|
Resolution
:
:
Dppx
(
f
)
=
>
f
*
96
.
0
Resolution
:
:
Dpcm
(
f
)
=
>
f
*
2
.
54
}
}
}
impl
Parse
for
Resolution
{
fn
parse
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
(
value
unit
)
=
match
*
input
.
next
(
)
?
{
Token
:
:
Dimension
{
value
ref
unit
.
.
}
=
>
(
value
unit
)
ref
t
=
>
return
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
}
;
if
value
<
=
0
.
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
match_ignore_ascii_case
!
{
&
unit
"
dpi
"
=
>
Ok
(
Resolution
:
:
Dpi
(
value
)
)
"
dppx
"
=
>
Ok
(
Resolution
:
:
Dppx
(
value
)
)
"
dpcm
"
=
>
Ok
(
Resolution
:
:
Dpcm
(
value
)
)
"
x
"
=
>
Ok
(
Resolution
:
:
X
(
value
)
)
_
=
>
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnexpectedDimension
(
unit
.
clone
(
)
)
)
)
}
}
}
