use
cssparser
:
:
{
CssStringWriter
Parser
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
sugar
:
:
refptr
:
:
{
GeckoArcPrincipal
GeckoArcURI
}
;
use
parser
:
:
ParserContext
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
parser
:
:
ParserContextExtraData
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
Arc
;
use
style_traits
:
:
ToCss
;
use
url
:
:
Url
;
use
values
:
:
computed
:
:
ComputedValueAsSpecified
;
#
[
derive
(
PartialEq
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
UrlExtraData
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
base
:
GeckoArcURI
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
referrer
:
GeckoArcURI
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
principal
:
GeckoArcPrincipal
}
impl
UrlExtraData
{
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
make_from
(
_
:
&
ParserContext
)
-
>
Option
<
UrlExtraData
>
{
Some
(
UrlExtraData
{
}
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
make_from
(
context
:
&
ParserContext
)
-
>
Option
<
UrlExtraData
>
{
match
context
.
extra_data
{
ParserContextExtraData
{
base
:
Some
(
ref
base
)
referrer
:
Some
(
ref
referrer
)
principal
:
Some
(
ref
principal
)
}
=
>
{
Some
(
UrlExtraData
{
base
:
base
.
clone
(
)
referrer
:
referrer
.
clone
(
)
principal
:
principal
.
clone
(
)
}
)
}
_
=
>
None
}
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
SpecifiedUrl
{
original
:
Option
<
Arc
<
String
>
>
resolved
:
Option
<
Arc
<
Url
>
>
extra_data
:
UrlExtraData
}
impl
SpecifiedUrl
{
pub
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
let
url
=
try
!
(
input
.
expect_url
(
)
)
;
let
extra_data
=
match
UrlExtraData
:
:
make_from
(
context
)
{
Some
(
extra_data
)
=
>
extra_data
None
=
>
{
println
!
(
"
stylo
:
skipping
declaration
without
ParserContextExtraData
"
)
;
return
Err
(
(
)
)
}
}
;
let
serialization
=
Arc
:
:
new
(
url
.
into_owned
(
)
)
;
let
resolved
=
context
.
base_url
.
join
(
&
serialization
)
.
ok
(
)
.
map
(
Arc
:
:
new
)
;
Ok
(
SpecifiedUrl
{
original
:
Some
(
serialization
)
resolved
:
resolved
extra_data
:
extra_data
}
)
}
pub
fn
extra_data
(
&
self
)
-
>
&
UrlExtraData
{
&
self
.
extra_data
}
pub
fn
url
(
&
self
)
-
>
Option
<
&
Arc
<
Url
>
>
{
self
.
resolved
.
as_ref
(
)
}
pub
fn
as_slice_components
(
&
self
)
-
>
(
*
const
u8
usize
)
{
match
self
.
resolved
{
Some
(
ref
url
)
=
>
(
url
.
as_str
(
)
.
as_ptr
(
)
url
.
as_str
(
)
.
len
(
)
)
None
=
>
(
ptr
:
:
null
(
)
0
)
}
}
pub
fn
for_cascade
(
url
:
Option
<
Arc
<
Url
>
>
extra_data
:
UrlExtraData
)
-
>
Self
{
SpecifiedUrl
{
original
:
None
resolved
:
url
extra_data
:
extra_data
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
new_for_testing
(
url
:
&
str
)
-
>
Self
{
SpecifiedUrl
{
original
:
Some
(
Arc
:
:
new
(
url
.
into
(
)
)
)
resolved
:
Url
:
:
parse
(
url
)
.
ok
(
)
.
map
(
Arc
:
:
new
)
extra_data
:
UrlExtraData
{
}
}
}
}
impl
PartialEq
for
SpecifiedUrl
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
resolved
=
=
other
.
resolved
&
&
self
.
extra_data
=
=
other
.
extra_data
}
}
impl
ToCss
for
SpecifiedUrl
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
url
(
\
"
"
)
)
;
let
string
=
match
self
.
original
{
Some
(
ref
original
)
=
>
&
*
*
original
None
=
>
match
self
.
resolved
{
Some
(
ref
url
)
=
>
url
.
as_str
(
)
None
=
>
"
about
:
invalid
"
}
}
;
try
!
(
CssStringWriter
:
:
new
(
dest
)
.
write_str
(
string
)
)
;
dest
.
write_str
(
"
\
"
)
"
)
}
}
impl
ComputedValueAsSpecified
for
SpecifiedUrl
{
}
