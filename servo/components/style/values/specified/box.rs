use
crate
:
:
custom_properties
:
:
Name
as
CustomPropertyName
;
use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
properties
:
:
{
LonghandId
PropertyDeclarationId
}
;
use
crate
:
:
properties
:
:
{
PropertyId
ShorthandId
}
;
use
crate
:
:
values
:
:
generics
:
:
box_
:
:
{
GenericAnimationIterationCount
GenericLineClamp
GenericPerspective
}
;
use
crate
:
:
values
:
:
generics
:
:
box_
:
:
{
GenericContainIntrinsicSize
GenericVerticalAlign
VerticalAlignKeyword
}
;
use
crate
:
:
values
:
:
specified
:
:
length
:
:
{
LengthPercentage
NonNegativeLength
}
;
use
crate
:
:
values
:
:
specified
:
:
{
AllowQuirks
Integer
Number
}
;
use
crate
:
:
values
:
:
{
CustomIdent
KeyframesName
TimelineName
}
;
use
crate
:
:
Atom
;
use
cssparser
:
:
Parser
;
use
num_traits
:
:
FromPrimitive
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
KeywordsCollectFn
ParseError
}
;
use
style_traits
:
:
{
SpecifiedValueInfo
StyleParseErrorKind
ToCss
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
moz_display_values_enabled
(
context
:
&
ParserContext
)
-
>
bool
{
context
.
in_ua_or_chrome_sheet
(
)
}
#
[
cfg
(
not
(
feature
=
"
servo
-
layout
-
2020
"
)
)
]
fn
flexbox_enabled
(
)
-
>
bool
{
true
}
#
[
cfg
(
feature
=
"
servo
-
layout
-
2020
"
)
]
fn
flexbox_enabled
(
)
-
>
bool
{
servo_config
:
:
prefs
:
:
pref_map
(
)
.
get
(
"
layout
.
flexbox
.
enabled
"
)
.
as_bool
(
)
.
unwrap_or
(
false
)
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
FromPrimitive
Hash
MallocSizeOf
PartialEq
ToCss
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
DisplayOutside
{
None
=
0
Inline
Block
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
TableCaption
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
InternalTable
#
[
cfg
(
feature
=
"
gecko
"
)
]
InternalRuby
#
[
cfg
(
feature
=
"
gecko
"
)
]
XUL
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
FromPrimitive
Hash
MallocSizeOf
PartialEq
ToCss
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
DisplayInside
{
None
=
0
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2020
"
feature
=
"
gecko
"
)
)
]
Contents
Flow
FlowRoot
Flex
#
[
cfg
(
feature
=
"
gecko
"
)
]
Grid
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
Table
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
TableRowGroup
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
TableColumn
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
TableColumnGroup
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
TableHeaderGroup
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
TableFooterGroup
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
TableRow
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
TableCell
#
[
cfg
(
feature
=
"
gecko
"
)
]
Ruby
#
[
cfg
(
feature
=
"
gecko
"
)
]
RubyBase
#
[
cfg
(
feature
=
"
gecko
"
)
]
RubyBaseContainer
#
[
cfg
(
feature
=
"
gecko
"
)
]
RubyText
#
[
cfg
(
feature
=
"
gecko
"
)
]
RubyTextContainer
#
[
cfg
(
feature
=
"
gecko
"
)
]
WebkitBox
#
[
cfg
(
feature
=
"
gecko
"
)
]
MozBox
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
FromPrimitive
Hash
MallocSizeOf
PartialEq
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
transparent
)
]
pub
struct
Display
(
u16
)
;
#
[
allow
(
missing_docs
)
]
#
[
allow
(
non_upper_case_globals
)
]
impl
Display
{
const
LIST_ITEM_BIT
:
u16
=
0x8000
;
const
DISPLAY_OUTSIDE_BITS
:
u16
=
7
;
const
DISPLAY_INSIDE_BITS
:
u16
=
8
;
pub
const
None
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
None
DisplayInside
:
:
None
)
;
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2020
"
feature
=
"
gecko
"
)
)
]
pub
const
Contents
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
None
DisplayInside
:
:
Contents
)
;
pub
const
Inline
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Inline
DisplayInside
:
:
Flow
)
;
pub
const
InlineBlock
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Inline
DisplayInside
:
:
FlowRoot
)
;
pub
const
Block
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Block
DisplayInside
:
:
Flow
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
const
FlowRoot
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Block
DisplayInside
:
:
FlowRoot
)
;
pub
const
Flex
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Block
DisplayInside
:
:
Flex
)
;
pub
const
InlineFlex
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Inline
DisplayInside
:
:
Flex
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
const
Grid
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Block
DisplayInside
:
:
Grid
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
const
InlineGrid
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Inline
DisplayInside
:
:
Grid
)
;
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
pub
const
Table
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Block
DisplayInside
:
:
Table
)
;
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
pub
const
InlineTable
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Inline
DisplayInside
:
:
Table
)
;
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
pub
const
TableCaption
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
TableCaption
DisplayInside
:
:
Flow
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
const
Ruby
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Inline
DisplayInside
:
:
Ruby
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
const
WebkitBox
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Block
DisplayInside
:
:
WebkitBox
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
const
WebkitInlineBox
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Inline
DisplayInside
:
:
WebkitBox
)
;
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
pub
const
TableRowGroup
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
InternalTable
DisplayInside
:
:
TableRowGroup
)
;
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
pub
const
TableHeaderGroup
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
InternalTable
DisplayInside
:
:
TableHeaderGroup
)
;
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
pub
const
TableFooterGroup
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
InternalTable
DisplayInside
:
:
TableFooterGroup
)
;
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
pub
const
TableColumn
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
InternalTable
DisplayInside
:
:
TableColumn
)
;
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
pub
const
TableColumnGroup
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
InternalTable
DisplayInside
:
:
TableColumnGroup
)
;
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
pub
const
TableRow
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
InternalTable
DisplayInside
:
:
TableRow
)
;
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
pub
const
TableCell
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
InternalTable
DisplayInside
:
:
TableCell
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
const
RubyBase
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
InternalRuby
DisplayInside
:
:
RubyBase
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
const
RubyBaseContainer
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
InternalRuby
DisplayInside
:
:
RubyBaseContainer
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
const
RubyText
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
InternalRuby
DisplayInside
:
:
RubyText
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
const
RubyTextContainer
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
InternalRuby
DisplayInside
:
:
RubyTextContainer
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
const
MozBox
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Block
DisplayInside
:
:
MozBox
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
const
MozInlineBox
:
Self
=
Self
:
:
new
(
DisplayOutside
:
:
Inline
DisplayInside
:
:
MozBox
)
;
#
[
inline
]
const
fn
new
(
outside
:
DisplayOutside
inside
:
DisplayInside
)
-
>
Self
{
let
o
:
u16
=
(
(
outside
as
u8
)
as
u16
)
<
<
Self
:
:
DISPLAY_INSIDE_BITS
;
let
i
:
u16
=
(
inside
as
u8
)
as
u16
;
Self
(
o
|
i
)
}
#
[
inline
]
fn
from3
(
outside
:
DisplayOutside
inside
:
DisplayInside
list_item
:
bool
)
-
>
Self
{
let
v
=
Self
:
:
new
(
outside
inside
)
;
if
!
list_item
{
return
v
;
}
Self
(
v
.
0
|
Self
:
:
LIST_ITEM_BIT
)
}
#
[
inline
]
pub
fn
inside
(
&
self
)
-
>
DisplayInside
{
DisplayInside
:
:
from_u16
(
self
.
0
&
(
(
1
<
<
Self
:
:
DISPLAY_INSIDE_BITS
)
-
1
)
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
outside
(
&
self
)
-
>
DisplayOutside
{
DisplayOutside
:
:
from_u16
(
(
self
.
0
>
>
Self
:
:
DISPLAY_INSIDE_BITS
)
&
(
(
1
<
<
Self
:
:
DISPLAY_OUTSIDE_BITS
)
-
1
)
)
.
unwrap
(
)
}
#
[
inline
]
pub
const
fn
to_u16
(
&
self
)
-
>
u16
{
self
.
0
}
#
[
inline
]
pub
fn
is_inline_flow
(
&
self
)
-
>
bool
{
self
.
outside
(
)
=
=
DisplayOutside
:
:
Inline
&
&
self
.
inside
(
)
=
=
DisplayInside
:
:
Flow
}
#
[
inline
]
pub
const
fn
is_list_item
(
&
self
)
-
>
bool
{
(
self
.
0
&
Self
:
:
LIST_ITEM_BIT
)
!
=
0
}
pub
fn
is_ruby_level_container
(
&
self
)
-
>
bool
{
match
*
self
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
Display
:
:
RubyBaseContainer
|
Display
:
:
RubyTextContainer
=
>
true
_
=
>
false
}
}
pub
fn
is_ruby_type
(
&
self
)
-
>
bool
{
match
self
.
inside
(
)
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
DisplayInside
:
:
Ruby
|
DisplayInside
:
:
RubyBase
|
DisplayInside
:
:
RubyText
|
DisplayInside
:
:
RubyBaseContainer
|
DisplayInside
:
:
RubyTextContainer
=
>
true
_
=
>
false
}
}
}
#
[
allow
(
non_upper_case_globals
)
]
impl
Display
{
#
[
inline
]
pub
fn
inline
(
)
-
>
Self
{
Display
:
:
Inline
}
#
[
cfg
(
feature
=
"
servo
"
)
]
#
[
inline
]
pub
fn
is_atomic_inline_level
(
&
self
)
-
>
bool
{
match
*
self
{
Display
:
:
InlineBlock
|
Display
:
:
InlineFlex
=
>
true
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
)
)
]
Display
:
:
InlineTable
=
>
true
_
=
>
false
}
}
pub
fn
is_item_container
(
&
self
)
-
>
bool
{
match
self
.
inside
(
)
{
DisplayInside
:
:
Flex
=
>
true
#
[
cfg
(
feature
=
"
gecko
"
)
]
DisplayInside
:
:
Grid
=
>
true
#
[
cfg
(
feature
=
"
gecko
"
)
]
DisplayInside
:
:
MozBox
=
>
true
_
=
>
false
}
}
pub
fn
is_line_participant
(
&
self
)
-
>
bool
{
match
*
self
{
Display
:
:
Inline
=
>
true
#
[
cfg
(
feature
=
"
gecko
"
)
]
Display
:
:
Contents
|
Display
:
:
Ruby
|
Display
:
:
RubyBaseContainer
=
>
true
_
=
>
false
}
}
pub
fn
equivalent_block_display
(
&
self
_is_root_element
:
bool
)
-
>
Self
{
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2020
"
feature
=
"
gecko
"
)
)
]
{
if
_is_root_element
&
&
(
self
.
is_contents
(
)
|
|
self
.
is_list_item
(
)
)
{
return
Display
:
:
Block
;
}
}
match
self
.
outside
(
)
{
DisplayOutside
:
:
Inline
=
>
{
let
inside
=
match
self
.
inside
(
)
{
DisplayInside
:
:
FlowRoot
=
>
DisplayInside
:
:
Flow
inside
=
>
inside
}
;
Display
:
:
from3
(
DisplayOutside
:
:
Block
inside
self
.
is_list_item
(
)
)
}
DisplayOutside
:
:
Block
|
DisplayOutside
:
:
XUL
|
DisplayOutside
:
:
None
=
>
*
self
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
_
=
>
Display
:
:
Block
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
inlinify
(
&
self
)
-
>
Self
{
match
self
.
outside
(
)
{
DisplayOutside
:
:
Block
=
>
{
let
inside
=
match
self
.
inside
(
)
{
DisplayInside
:
:
Flow
=
>
DisplayInside
:
:
FlowRoot
inside
=
>
inside
}
;
Display
:
:
from3
(
DisplayOutside
:
:
Inline
inside
self
.
is_list_item
(
)
)
}
_
=
>
*
self
}
}
#
[
inline
]
pub
fn
is_contents
(
&
self
)
-
>
bool
{
match
*
self
{
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2020
"
feature
=
"
gecko
"
)
)
]
Display
:
:
Contents
=
>
true
_
=
>
false
}
}
#
[
inline
]
pub
fn
is_none
(
&
self
)
-
>
bool
{
*
self
=
=
Display
:
:
None
}
}
impl
ToCss
for
Display
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
let
outside
=
self
.
outside
(
)
;
let
inside
=
self
.
inside
(
)
;
match
*
self
{
Display
:
:
Block
|
Display
:
:
Inline
=
>
outside
.
to_css
(
dest
)
Display
:
:
InlineBlock
=
>
dest
.
write_str
(
"
inline
-
block
"
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Display
:
:
WebkitInlineBox
=
>
dest
.
write_str
(
"
-
webkit
-
inline
-
box
"
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Display
:
:
MozInlineBox
=
>
dest
.
write_str
(
"
-
moz
-
inline
-
box
"
)
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
Display
:
:
TableCaption
=
>
dest
.
write_str
(
"
table
-
caption
"
)
_
=
>
match
(
outside
inside
)
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
(
DisplayOutside
:
:
Inline
DisplayInside
:
:
Grid
)
=
>
dest
.
write_str
(
"
inline
-
grid
"
)
(
DisplayOutside
:
:
Inline
DisplayInside
:
:
Flex
)
=
>
dest
.
write_str
(
"
inline
-
flex
"
)
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
(
DisplayOutside
:
:
Inline
DisplayInside
:
:
Table
)
=
>
dest
.
write_str
(
"
inline
-
table
"
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
(
DisplayOutside
:
:
Block
DisplayInside
:
:
Ruby
)
=
>
dest
.
write_str
(
"
block
ruby
"
)
(
_
inside
)
=
>
{
if
self
.
is_list_item
(
)
{
if
outside
!
=
DisplayOutside
:
:
Block
{
outside
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
}
if
inside
!
=
DisplayInside
:
:
Flow
{
inside
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
}
dest
.
write_str
(
"
list
-
item
"
)
}
else
{
inside
.
to_css
(
dest
)
}
}
}
}
}
}
fn
parse_display_inside
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
DisplayInside
ParseError
<
'
i
>
>
{
Ok
(
try_match_ident_ignore_ascii_case
!
{
input
"
flow
"
=
>
DisplayInside
:
:
Flow
"
flex
"
if
flexbox_enabled
(
)
=
>
DisplayInside
:
:
Flex
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2020
"
feature
=
"
gecko
"
)
)
]
"
flow
-
root
"
=
>
DisplayInside
:
:
FlowRoot
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
"
table
"
=
>
DisplayInside
:
:
Table
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
grid
"
=
>
DisplayInside
:
:
Grid
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
ruby
"
=
>
DisplayInside
:
:
Ruby
}
)
}
fn
parse_display_outside
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
DisplayOutside
ParseError
<
'
i
>
>
{
Ok
(
try_match_ident_ignore_ascii_case
!
{
input
"
block
"
=
>
DisplayOutside
:
:
Block
"
inline
"
=
>
DisplayOutside
:
:
Inline
/
/
FIXME
(
bug
2056
)
:
not
supported
in
layout
yet
:
/
/
"
run
-
in
"
=
>
DisplayOutside
:
:
RunIn
}
)
}
fn
parse_display_inside_for_list_item
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
DisplayInside
ParseError
<
'
i
>
>
{
Ok
(
try_match_ident_ignore_ascii_case
!
{
input
"
flow
"
=
>
DisplayInside
:
:
Flow
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
flow
-
root
"
=
>
DisplayInside
:
:
FlowRoot
}
)
}
fn
is_valid_inside_for_list_item
<
'
i
>
(
inside
:
&
Result
<
DisplayInside
ParseError
<
'
i
>
>
)
-
>
bool
{
match
inside
{
Ok
(
DisplayInside
:
:
Flow
)
=
>
true
#
[
cfg
(
feature
=
"
gecko
"
)
]
Ok
(
DisplayInside
:
:
FlowRoot
)
=
>
true
_
=
>
false
}
}
fn
parse_list_item
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
(
)
ParseError
<
'
i
>
>
{
Ok
(
input
.
expect_ident_matching
(
"
list
-
item
"
)
?
)
}
impl
Parse
for
Display
{
#
[
allow
(
unused
)
]
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Display
ParseError
<
'
i
>
>
{
let
mut
got_list_item
=
input
.
try_parse
(
parse_list_item
)
.
is_ok
(
)
;
let
mut
inside
=
if
got_list_item
{
input
.
try_parse
(
parse_display_inside_for_list_item
)
}
else
{
input
.
try_parse
(
parse_display_inside
)
}
;
if
!
got_list_item
&
&
is_valid_inside_for_list_item
(
&
inside
)
{
got_list_item
=
input
.
try_parse
(
parse_list_item
)
.
is_ok
(
)
;
}
let
outside
=
input
.
try_parse
(
parse_display_outside
)
;
if
outside
.
is_ok
(
)
{
if
!
got_list_item
&
&
(
inside
.
is_err
(
)
|
|
is_valid_inside_for_list_item
(
&
inside
)
)
{
got_list_item
=
input
.
try_parse
(
parse_list_item
)
.
is_ok
(
)
;
}
if
inside
.
is_err
(
)
{
inside
=
if
got_list_item
{
input
.
try_parse
(
parse_display_inside_for_list_item
)
}
else
{
input
.
try_parse
(
parse_display_inside
)
}
;
if
!
got_list_item
&
&
is_valid_inside_for_list_item
(
&
inside
)
{
got_list_item
=
input
.
try_parse
(
parse_list_item
)
.
is_ok
(
)
;
}
}
}
if
got_list_item
|
|
inside
.
is_ok
(
)
|
|
outside
.
is_ok
(
)
{
let
inside
=
inside
.
unwrap_or
(
DisplayInside
:
:
Flow
)
;
let
outside
=
outside
.
unwrap_or
(
match
inside
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
DisplayInside
:
:
Ruby
=
>
DisplayOutside
:
:
Inline
_
=
>
DisplayOutside
:
:
Block
}
)
;
return
Ok
(
Display
:
:
from3
(
outside
inside
got_list_item
)
)
;
}
Ok
(
try_match_ident_ignore_ascii_case
!
{
input
"
none
"
=
>
Display
:
:
None
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2020
"
feature
=
"
gecko
"
)
)
]
"
contents
"
=
>
Display
:
:
Contents
"
inline
-
block
"
=
>
Display
:
:
InlineBlock
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
"
inline
-
table
"
=
>
Display
:
:
InlineTable
"
-
webkit
-
flex
"
if
flexbox_enabled
(
)
=
>
Display
:
:
Flex
"
inline
-
flex
"
|
"
-
webkit
-
inline
-
flex
"
if
flexbox_enabled
(
)
=
>
Display
:
:
InlineFlex
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
inline
-
grid
"
=
>
Display
:
:
InlineGrid
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
"
table
-
caption
"
=
>
Display
:
:
TableCaption
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
"
table
-
row
-
group
"
=
>
Display
:
:
TableRowGroup
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
"
table
-
header
-
group
"
=
>
Display
:
:
TableHeaderGroup
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
"
table
-
footer
-
group
"
=
>
Display
:
:
TableFooterGroup
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
"
table
-
column
"
=
>
Display
:
:
TableColumn
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
"
table
-
column
-
group
"
=
>
Display
:
:
TableColumnGroup
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
"
table
-
row
"
=
>
Display
:
:
TableRow
#
[
cfg
(
any
(
feature
=
"
servo
-
layout
-
2013
"
feature
=
"
gecko
"
)
)
]
"
table
-
cell
"
=
>
Display
:
:
TableCell
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
ruby
-
base
"
=
>
Display
:
:
RubyBase
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
ruby
-
base
-
container
"
=
>
Display
:
:
RubyBaseContainer
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
ruby
-
text
"
=
>
Display
:
:
RubyText
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
ruby
-
text
-
container
"
=
>
Display
:
:
RubyTextContainer
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
-
webkit
-
box
"
=
>
Display
:
:
WebkitBox
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
-
webkit
-
inline
-
box
"
=
>
Display
:
:
WebkitInlineBox
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
-
moz
-
box
"
if
moz_display_values_enabled
(
context
)
=
>
Display
:
:
MozBox
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
-
moz
-
inline
-
box
"
if
moz_display_values_enabled
(
context
)
=
>
Display
:
:
MozInlineBox
}
)
}
}
impl
SpecifiedValueInfo
for
Display
{
fn
collect_completion_keywords
(
f
:
KeywordsCollectFn
)
{
f
(
&
[
"
block
"
"
contents
"
"
flex
"
"
flow
-
root
"
"
flow
-
root
list
-
item
"
"
grid
"
"
inline
"
"
inline
-
block
"
"
inline
-
flex
"
"
inline
-
grid
"
"
inline
-
table
"
"
inline
list
-
item
"
"
inline
flow
-
root
list
-
item
"
"
list
-
item
"
"
none
"
"
block
ruby
"
"
ruby
"
"
ruby
-
base
"
"
ruby
-
base
-
container
"
"
ruby
-
text
"
"
ruby
-
text
-
container
"
"
table
"
"
table
-
caption
"
"
table
-
cell
"
"
table
-
column
"
"
table
-
column
-
group
"
"
table
-
footer
-
group
"
"
table
-
header
-
group
"
"
table
-
row
"
"
table
-
row
-
group
"
"
-
webkit
-
box
"
"
-
webkit
-
inline
-
box
"
]
)
;
}
}
pub
type
ContainIntrinsicSize
=
GenericContainIntrinsicSize
<
NonNegativeLength
>
;
pub
type
LineClamp
=
GenericLineClamp
<
Integer
>
;
pub
type
VerticalAlign
=
GenericVerticalAlign
<
LengthPercentage
>
;
impl
Parse
for
VerticalAlign
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
lp
)
=
input
.
try_parse
(
|
i
|
LengthPercentage
:
:
parse_quirky
(
context
i
AllowQuirks
:
:
Yes
)
)
{
return
Ok
(
GenericVerticalAlign
:
:
Length
(
lp
)
)
;
}
Ok
(
GenericVerticalAlign
:
:
Keyword
(
VerticalAlignKeyword
:
:
parse
(
input
)
?
)
)
}
}
pub
type
AnimationIterationCount
=
GenericAnimationIterationCount
<
Number
>
;
impl
Parse
for
AnimationIterationCount
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
:
:
cssparser
:
:
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
input
.
try_parse
(
|
input
|
input
.
expect_ident_matching
(
"
infinite
"
)
)
.
is_ok
(
)
{
return
Ok
(
GenericAnimationIterationCount
:
:
Infinite
)
;
}
let
number
=
Number
:
:
parse_non_negative
(
context
input
)
?
;
Ok
(
GenericAnimationIterationCount
:
:
Number
(
number
)
)
}
}
impl
AnimationIterationCount
{
#
[
inline
]
pub
fn
one
(
)
-
>
Self
{
GenericAnimationIterationCount
:
:
Number
(
Number
:
:
new
(
1
.
0
)
)
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
value_info
(
other_values
=
"
none
"
)
]
pub
struct
AnimationName
(
pub
KeyframesName
)
;
impl
AnimationName
{
pub
fn
as_atom
(
&
self
)
-
>
Option
<
&
Atom
>
{
if
self
.
is_none
(
)
{
return
None
;
}
Some
(
self
.
0
.
as_atom
(
)
)
}
pub
fn
none
(
)
-
>
Self
{
AnimationName
(
KeyframesName
:
:
none
(
)
)
}
pub
fn
is_none
(
&
self
)
-
>
bool
{
self
.
0
.
is_none
(
)
}
}
impl
Parse
for
AnimationName
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
name
)
=
input
.
try_parse
(
|
input
|
KeyframesName
:
:
parse
(
context
input
)
)
{
return
Ok
(
AnimationName
(
name
)
)
;
}
input
.
expect_ident_matching
(
"
none
"
)
?
;
Ok
(
AnimationName
(
KeyframesName
:
:
none
(
)
)
)
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
Scroller
{
Nearest
Root
}
impl
Default
for
Scroller
{
fn
default
(
)
-
>
Self
{
Self
:
:
Nearest
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ScrollAxis
{
Block
=
0
Inline
=
1
Vertical
=
2
Horizontal
=
3
}
impl
Default
for
ScrollAxis
{
fn
default
(
)
-
>
Self
{
Self
:
:
Block
}
}
#
[
inline
]
fn
is_default
<
T
:
Default
+
PartialEq
>
(
value
:
&
T
)
-
>
bool
{
*
value
=
=
Default
:
:
default
(
)
}
/
/
/
cbindgen
:
private
-
default
-
tagged
-
enum
-
constructor
=
false
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
AnimationTimeline
{
Auto
Timeline
(
TimelineName
)
#
[
css
(
function
)
]
Scroll
(
#
[
css
(
skip_if
=
"
is_default
"
)
]
ScrollAxis
#
[
css
(
skip_if
=
"
is_default
"
)
]
Scroller
)
}
impl
AnimationTimeline
{
pub
fn
auto
(
)
-
>
Self
{
Self
:
:
Auto
}
pub
fn
is_auto
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Auto
)
}
}
impl
Parse
for
AnimationTimeline
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
auto
"
)
)
.
is_ok
(
)
{
return
Ok
(
Self
:
:
Auto
)
;
}
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
none
"
)
)
.
is_ok
(
)
{
return
Ok
(
AnimationTimeline
:
:
Timeline
(
TimelineName
:
:
none
(
)
)
)
;
}
if
input
.
try_parse
(
|
i
|
i
.
expect_function_matching
(
"
scroll
"
)
)
.
is_ok
(
)
{
return
input
.
parse_nested_block
(
|
i
|
{
Ok
(
Self
:
:
Scroll
(
i
.
try_parse
(
ScrollAxis
:
:
parse
)
.
unwrap_or
(
ScrollAxis
:
:
Block
)
i
.
try_parse
(
Scroller
:
:
parse
)
.
unwrap_or
(
Scroller
:
:
Nearest
)
)
)
}
)
;
}
TimelineName
:
:
parse
(
context
input
)
.
map
(
AnimationTimeline
:
:
Timeline
)
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
ScrollTimelineName
(
pub
TimelineName
)
;
impl
ScrollTimelineName
{
pub
fn
none
(
)
-
>
Self
{
Self
(
TimelineName
:
:
none
(
)
)
}
}
impl
Parse
for
ScrollTimelineName
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
name
)
=
input
.
try_parse
(
|
input
|
TimelineName
:
:
parse
(
context
input
)
)
{
return
Ok
(
Self
(
name
)
)
;
}
input
.
expect_ident_matching
(
"
none
"
)
?
;
Ok
(
Self
(
TimelineName
:
:
none
(
)
)
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ScrollSnapAxis
{
X
Y
Block
Inline
Both
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ScrollSnapStrictness
{
#
[
css
(
skip
)
]
None
Mandatory
Proximity
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
ScrollSnapType
{
axis
:
ScrollSnapAxis
strictness
:
ScrollSnapStrictness
}
impl
ScrollSnapType
{
#
[
inline
]
pub
fn
none
(
)
-
>
Self
{
Self
{
axis
:
ScrollSnapAxis
:
:
Both
strictness
:
ScrollSnapStrictness
:
:
None
}
}
}
impl
Parse
for
ScrollSnapType
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
input
.
try_parse
(
|
input
|
input
.
expect_ident_matching
(
"
none
"
)
)
.
is_ok
(
)
{
return
Ok
(
ScrollSnapType
:
:
none
(
)
)
;
}
let
axis
=
ScrollSnapAxis
:
:
parse
(
input
)
?
;
let
strictness
=
input
.
try_parse
(
ScrollSnapStrictness
:
:
parse
)
.
unwrap_or
(
ScrollSnapStrictness
:
:
Proximity
)
;
Ok
(
Self
{
axis
strictness
}
)
}
}
impl
ToCss
for
ScrollSnapType
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
self
.
strictness
=
=
ScrollSnapStrictness
:
:
None
{
return
dest
.
write_str
(
"
none
"
)
;
}
self
.
axis
.
to_css
(
dest
)
?
;
if
self
.
strictness
!
=
ScrollSnapStrictness
:
:
Proximity
{
dest
.
write_str
(
"
"
)
?
;
self
.
strictness
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
FromPrimitive
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ScrollSnapAlignKeyword
{
None
Start
End
Center
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
ScrollSnapAlign
{
block
:
ScrollSnapAlignKeyword
inline
:
ScrollSnapAlignKeyword
}
impl
ScrollSnapAlign
{
#
[
inline
]
pub
fn
none
(
)
-
>
Self
{
ScrollSnapAlign
{
block
:
ScrollSnapAlignKeyword
:
:
None
inline
:
ScrollSnapAlignKeyword
:
:
None
}
}
}
impl
Parse
for
ScrollSnapAlign
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
ScrollSnapAlign
ParseError
<
'
i
>
>
{
let
block
=
ScrollSnapAlignKeyword
:
:
parse
(
input
)
?
;
let
inline
=
input
.
try_parse
(
ScrollSnapAlignKeyword
:
:
parse
)
.
unwrap_or
(
block
)
;
Ok
(
ScrollSnapAlign
{
block
inline
}
)
}
}
impl
ToCss
for
ScrollSnapAlign
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
block
.
to_css
(
dest
)
?
;
if
self
.
block
!
=
self
.
inline
{
dest
.
write_str
(
"
"
)
?
;
self
.
inline
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ScrollSnapStop
{
Normal
Always
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
OverscrollBehavior
{
Auto
Contain
None
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
OverflowAnchor
{
Auto
None
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
OverflowClipBox
{
PaddingBox
ContentBox
}
#
[
derive
(
Clone
Debug
Default
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
css
(
comma
)
]
#
[
repr
(
C
)
]
pub
struct
WillChange
{
#
[
css
(
iterable
if_empty
=
"
auto
"
)
]
features
:
crate
:
:
OwnedSlice
<
CustomIdent
>
#
[
css
(
skip
)
]
bits
:
WillChangeBits
}
impl
WillChange
{
#
[
inline
]
pub
fn
auto
(
)
-
>
Self
{
Self
:
:
default
(
)
}
}
bitflags
!
{
/
/
/
The
change
bits
that
we
care
about
.
#
[
derive
(
Default
MallocSizeOf
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
WillChangeBits
:
u16
{
/
/
/
Whether
a
property
which
can
create
a
stacking
context
*
*
on
any
/
/
/
box
*
*
will
change
.
const
STACKING_CONTEXT_UNCONDITIONAL
=
1
<
<
0
;
/
/
/
Whether
transform
or
related
properties
will
change
.
const
TRANSFORM
=
1
<
<
1
;
/
/
/
Whether
scroll
-
position
will
change
.
const
SCROLL
=
1
<
<
2
;
/
/
/
Whether
contain
will
change
.
const
CONTAIN
=
1
<
<
3
;
/
/
/
Whether
opacity
will
change
.
const
OPACITY
=
1
<
<
4
;
/
/
/
Whether
perspective
will
change
.
const
PERSPECTIVE
=
1
<
<
5
;
/
/
/
Whether
z
-
index
will
change
.
const
Z_INDEX
=
1
<
<
6
;
/
/
/
Whether
any
property
which
creates
a
containing
block
for
non
-
svg
/
/
/
text
frames
will
change
.
const
FIXPOS_CB_NON_SVG
=
1
<
<
7
;
/
/
/
Whether
the
position
property
will
change
.
const
POSITION
=
1
<
<
8
;
}
}
fn
change_bits_for_longhand
(
longhand
:
LonghandId
)
-
>
WillChangeBits
{
match
longhand
{
LonghandId
:
:
Opacity
=
>
WillChangeBits
:
:
OPACITY
LonghandId
:
:
Contain
=
>
WillChangeBits
:
:
CONTAIN
LonghandId
:
:
Perspective
=
>
WillChangeBits
:
:
PERSPECTIVE
LonghandId
:
:
Position
=
>
{
WillChangeBits
:
:
STACKING_CONTEXT_UNCONDITIONAL
|
WillChangeBits
:
:
POSITION
}
LonghandId
:
:
ZIndex
=
>
WillChangeBits
:
:
Z_INDEX
LonghandId
:
:
Transform
|
LonghandId
:
:
TransformStyle
|
LonghandId
:
:
Translate
|
LonghandId
:
:
Rotate
|
LonghandId
:
:
Scale
|
LonghandId
:
:
OffsetPath
=
>
WillChangeBits
:
:
TRANSFORM
LonghandId
:
:
BackdropFilter
|
LonghandId
:
:
Filter
=
>
{
WillChangeBits
:
:
STACKING_CONTEXT_UNCONDITIONAL
|
WillChangeBits
:
:
FIXPOS_CB_NON_SVG
}
LonghandId
:
:
MixBlendMode
|
LonghandId
:
:
Isolation
|
LonghandId
:
:
MaskImage
|
LonghandId
:
:
ClipPath
=
>
WillChangeBits
:
:
STACKING_CONTEXT_UNCONDITIONAL
_
=
>
WillChangeBits
:
:
empty
(
)
}
}
fn
change_bits_for_maybe_property
(
ident
:
&
str
context
:
&
ParserContext
)
-
>
WillChangeBits
{
let
id
=
match
PropertyId
:
:
parse_ignoring_rule_type
(
ident
context
)
{
Ok
(
id
)
=
>
id
Err
(
.
.
)
=
>
return
WillChangeBits
:
:
empty
(
)
}
;
match
id
.
as_shorthand
(
)
{
Ok
(
shorthand
)
=
>
shorthand
.
longhands
(
)
.
fold
(
WillChangeBits
:
:
empty
(
)
|
flags
p
|
{
flags
|
change_bits_for_longhand
(
p
)
}
)
Err
(
PropertyDeclarationId
:
:
Longhand
(
longhand
)
)
=
>
change_bits_for_longhand
(
longhand
)
Err
(
PropertyDeclarationId
:
:
Custom
(
.
.
)
)
=
>
WillChangeBits
:
:
empty
(
)
}
}
impl
Parse
for
WillChange
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
input
.
try_parse
(
|
input
|
input
.
expect_ident_matching
(
"
auto
"
)
)
.
is_ok
(
)
{
return
Ok
(
Self
:
:
default
(
)
)
;
}
let
mut
bits
=
WillChangeBits
:
:
empty
(
)
;
let
custom_idents
=
input
.
parse_comma_separated
(
|
i
|
{
let
location
=
i
.
current_source_location
(
)
;
let
parser_ident
=
i
.
expect_ident
(
)
?
;
let
ident
=
CustomIdent
:
:
from_ident
(
location
parser_ident
&
[
"
will
-
change
"
"
none
"
"
all
"
"
auto
"
]
)
?
;
if
context
.
in_ua_sheet
(
)
&
&
ident
.
0
=
=
atom
!
(
"
-
moz
-
fixed
-
pos
-
containing
-
block
"
)
{
bits
|
=
WillChangeBits
:
:
FIXPOS_CB_NON_SVG
;
}
else
if
ident
.
0
=
=
atom
!
(
"
scroll
-
position
"
)
{
bits
|
=
WillChangeBits
:
:
SCROLL
;
}
else
{
bits
|
=
change_bits_for_maybe_property
(
&
parser_ident
context
)
;
}
Ok
(
ident
)
}
)
?
;
Ok
(
Self
{
features
:
custom_idents
.
into
(
)
bits
}
)
}
}
bitflags
!
{
/
/
/
Values
for
the
touch
-
action
property
.
#
[
derive
(
MallocSizeOf
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
Parse
)
]
#
[
css
(
bitflags
(
single
=
"
none
auto
manipulation
"
mixed
=
"
pan
-
x
pan
-
y
pinch
-
zoom
"
)
)
]
#
[
repr
(
C
)
]
pub
struct
TouchAction
:
u8
{
/
/
/
none
variant
const
NONE
=
1
<
<
0
;
/
/
/
auto
variant
const
AUTO
=
1
<
<
1
;
/
/
/
pan
-
x
variant
const
PAN_X
=
1
<
<
2
;
/
/
/
pan
-
y
variant
const
PAN_Y
=
1
<
<
3
;
/
/
/
manipulation
variant
const
MANIPULATION
=
1
<
<
4
;
/
/
/
pinch
-
zoom
variant
const
PINCH_ZOOM
=
1
<
<
5
;
}
}
impl
TouchAction
{
#
[
inline
]
pub
fn
auto
(
)
-
>
TouchAction
{
TouchAction
:
:
AUTO
}
}
bitflags
!
{
#
[
derive
(
MallocSizeOf
Parse
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
css
(
bitflags
(
single
=
"
none
strict
content
"
mixed
=
"
size
layout
style
paint
inline
-
size
"
overlapping_bits
)
)
]
#
[
repr
(
C
)
]
/
/
/
Constants
for
contain
:
https
:
/
/
drafts
.
csswg
.
org
/
css
-
contain
/
#
contain
-
property
pub
struct
Contain
:
u8
{
/
/
/
none
variant
just
for
convenience
.
const
NONE
=
0
;
/
/
/
inline
-
size
variant
turns
on
single
-
axis
inline
size
containment
const
INLINE_SIZE
=
1
<
<
0
;
/
/
/
block
-
size
variant
turns
on
single
-
axis
block
size
containment
internal
only
const
BLOCK_SIZE
=
1
<
<
1
;
/
/
/
layout
variant
turns
on
layout
containment
const
LAYOUT
=
1
<
<
2
;
/
/
/
style
variant
turns
on
style
containment
const
STYLE
=
1
<
<
3
;
/
/
/
paint
variant
turns
on
paint
containment
const
PAINT
=
1
<
<
4
;
/
/
/
'
size
'
variant
turns
on
size
containment
const
SIZE
=
1
<
<
5
|
Contain
:
:
INLINE_SIZE
.
bits
|
Contain
:
:
BLOCK_SIZE
.
bits
;
/
/
/
content
variant
turns
on
layout
and
paint
containment
const
CONTENT
=
1
<
<
6
|
Contain
:
:
LAYOUT
.
bits
|
Contain
:
:
STYLE
.
bits
|
Contain
:
:
PAINT
.
bits
;
/
/
/
strict
variant
turns
on
all
types
of
containment
const
STRICT
=
1
<
<
7
|
Contain
:
:
LAYOUT
.
bits
|
Contain
:
:
STYLE
.
bits
|
Contain
:
:
PAINT
.
bits
|
Contain
:
:
SIZE
.
bits
;
}
}
impl
Parse
for
ContainIntrinsicSize
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
l
)
=
input
.
try_parse
(
|
i
|
NonNegativeLength
:
:
parse
(
context
i
)
)
{
return
Ok
(
Self
:
:
Length
(
l
)
)
;
}
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
auto
"
)
)
.
is_ok
(
)
{
let
l
=
NonNegativeLength
:
:
parse
(
context
input
)
?
;
return
Ok
(
Self
:
:
AutoLength
(
l
)
)
;
}
input
.
expect_ident_matching
(
"
none
"
)
?
;
Ok
(
Self
:
:
None
)
}
}
impl
Parse
for
LineClamp
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
i
)
=
input
.
try_parse
(
|
i
|
crate
:
:
values
:
:
specified
:
:
PositiveInteger
:
:
parse
(
context
i
)
)
{
return
Ok
(
Self
(
i
.
0
)
)
;
}
input
.
expect_ident_matching
(
"
none
"
)
?
;
Ok
(
Self
:
:
none
(
)
)
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ContentVisibility
{
Auto
Hidden
Visible
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
MallocSizeOf
SpecifiedValueInfo
ToComputedValue
ToCss
Parse
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
ContainerType
{
Normal
InlineSize
Size
}
impl
ContainerType
{
pub
fn
is_normal
(
self
)
-
>
bool
{
self
=
=
Self
:
:
Normal
}
pub
fn
is_size_container_type
(
self
)
-
>
bool
{
!
self
.
is_normal
(
)
}
}
#
[
repr
(
transparent
)
]
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
pub
struct
ContainerName
(
#
[
css
(
iterable
if_empty
=
"
none
"
)
]
pub
crate
:
:
OwnedSlice
<
CustomIdent
>
)
;
impl
ContainerName
{
pub
fn
none
(
)
-
>
Self
{
Self
(
Default
:
:
default
(
)
)
}
pub
fn
is_none
(
&
self
)
-
>
bool
{
self
.
0
.
is_empty
(
)
}
fn
parse_internal
<
'
i
>
(
input
:
&
mut
Parser
<
'
i
'
_
>
for_query
:
bool
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
idents
=
vec
!
[
]
;
let
location
=
input
.
current_source_location
(
)
;
let
first
=
input
.
expect_ident
(
)
?
;
if
!
for_query
&
&
first
.
eq_ignore_ascii_case
(
"
none
"
)
{
return
Ok
(
Self
:
:
none
(
)
)
;
}
const
DISALLOWED_CONTAINER_NAMES
:
&
'
static
[
&
'
static
str
]
=
&
[
"
none
"
"
not
"
"
or
"
"
and
"
]
;
idents
.
push
(
CustomIdent
:
:
from_ident
(
location
first
DISALLOWED_CONTAINER_NAMES
)
?
)
;
if
!
for_query
{
while
let
Ok
(
name
)
=
input
.
try_parse
(
|
input
|
{
let
ident
=
input
.
expect_ident
(
)
?
;
CustomIdent
:
:
from_ident
(
location
&
ident
DISALLOWED_CONTAINER_NAMES
)
}
)
{
idents
.
push
(
name
)
;
}
}
Ok
(
ContainerName
(
idents
.
into
(
)
)
)
}
pub
fn
parse_for_query
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
input
true
)
}
}
impl
Parse
for
ContainerName
{
fn
parse
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
input
false
)
}
}
pub
type
Perspective
=
GenericPerspective
<
NonNegativeLength
>
;
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
PartialEq
ToComputedValue
ToResolvedValue
ToShmem
)
]
pub
enum
TransitionProperty
{
Shorthand
(
ShorthandId
)
Longhand
(
LonghandId
)
Custom
(
CustomPropertyName
)
Unsupported
(
CustomIdent
)
}
impl
ToCss
for
TransitionProperty
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
use
crate
:
:
values
:
:
serialize_atom_name
;
match
*
self
{
TransitionProperty
:
:
Shorthand
(
ref
s
)
=
>
s
.
to_css
(
dest
)
TransitionProperty
:
:
Longhand
(
ref
l
)
=
>
l
.
to_css
(
dest
)
TransitionProperty
:
:
Custom
(
ref
name
)
=
>
{
dest
.
write_str
(
"
-
-
"
)
?
;
serialize_atom_name
(
name
dest
)
}
TransitionProperty
:
:
Unsupported
(
ref
i
)
=
>
i
.
to_css
(
dest
)
}
}
}
impl
Parse
for
TransitionProperty
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
ident
=
input
.
expect_ident
(
)
?
;
let
id
=
match
PropertyId
:
:
parse_ignoring_rule_type
(
&
ident
context
)
{
Ok
(
id
)
=
>
id
Err
(
.
.
)
=
>
{
return
Ok
(
TransitionProperty
:
:
Unsupported
(
CustomIdent
:
:
from_ident
(
location
ident
&
[
"
none
"
]
)
?
)
)
;
}
}
;
Ok
(
match
id
.
as_shorthand
(
)
{
Ok
(
s
)
=
>
TransitionProperty
:
:
Shorthand
(
s
)
Err
(
longhand_or_custom
)
=
>
match
longhand_or_custom
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
TransitionProperty
:
:
Longhand
(
id
)
PropertyDeclarationId
:
:
Custom
(
custom
)
=
>
TransitionProperty
:
:
Custom
(
custom
.
clone
(
)
)
}
}
)
}
}
impl
SpecifiedValueInfo
for
TransitionProperty
{
fn
collect_completion_keywords
(
f
:
KeywordsCollectFn
)
{
f
(
&
[
"
all
"
]
)
;
}
}
impl
TransitionProperty
{
#
[
inline
]
pub
fn
all
(
)
-
>
Self
{
TransitionProperty
:
:
Shorthand
(
ShorthandId
:
:
All
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
to_nscsspropertyid
(
&
self
)
-
>
Result
<
crate
:
:
gecko_bindings
:
:
structs
:
:
nsCSSPropertyID
(
)
>
{
Ok
(
match
*
self
{
TransitionProperty
:
:
Shorthand
(
ShorthandId
:
:
All
)
=
>
{
crate
:
:
gecko_bindings
:
:
structs
:
:
nsCSSPropertyID
:
:
eCSSPropertyExtra_all_properties
}
TransitionProperty
:
:
Shorthand
(
ref
id
)
=
>
id
.
to_nscsspropertyid
(
)
TransitionProperty
:
:
Longhand
(
ref
id
)
=
>
id
.
to_nscsspropertyid
(
)
TransitionProperty
:
:
Custom
(
.
.
)
|
TransitionProperty
:
:
Unsupported
(
.
.
)
=
>
return
Err
(
(
)
)
}
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToCss
ToShmem
)
]
pub
enum
Float
{
Left
Right
None
InlineStart
InlineEnd
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToCss
ToShmem
)
]
pub
enum
Clear
{
None
Left
Right
Both
InlineStart
InlineEnd
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToCss
ToShmem
)
]
pub
enum
Resize
{
None
Both
Horizontal
Vertical
Inline
Block
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToCss
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
Appearance
{
None
Auto
Searchfield
#
[
parse
(
aliases
=
"
textfield
-
multiline
"
)
]
Textarea
Checkbox
Radio
Menulist
Listbox
#
[
parse
(
aliases
=
"
meterbar
"
)
]
Meter
#
[
parse
(
aliases
=
"
progressbar
"
)
]
ProgressBar
Button
Textfield
MenulistButton
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ButtonArrowDown
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ButtonArrowNext
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ButtonArrowPrevious
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ButtonArrowUp
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Dualbutton
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Groupbox
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Menubar
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Menuitem
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Checkmenuitem
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Radiomenuitem
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Menuitemtext
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MenulistText
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Menupopup
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Menucheckbox
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Menuradio
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Menuseparator
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Menuarrow
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Menuimage
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Meterchunk
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozMenulistArrowButton
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
NumberInput
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Progresschunk
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
CheckboxContainer
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
RadioContainer
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
CheckboxLabel
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
RadioLabel
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Range
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
RangeThumb
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Resizerpanel
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Resizer
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ScrollbarHorizontal
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ScrollbarVertical
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ScrollbarbuttonUp
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ScrollbarbuttonDown
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ScrollbarbuttonLeft
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ScrollbarbuttonRight
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ScrollbarthumbHorizontal
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ScrollbarthumbVertical
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ScrollbartrackHorizontal
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ScrollbartrackVertical
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Scrollcorner
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Separator
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Spinner
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
SpinnerUpbutton
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
SpinnerDownbutton
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
SpinnerTextfield
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Splitter
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Statusbar
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Statusbarpanel
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Tab
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Tabpanel
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Tabpanels
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
TabScrollArrowBack
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
TabScrollArrowForward
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Toolbar
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Toolbarbutton
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
ToolbarbuttonDropdown
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Toolbargripper
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Toolbox
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Tooltip
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Treeheader
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Treeheadercell
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Treeheadersortarrow
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Treeitem
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Treeline
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Treetwisty
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Treetwistyopen
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Treeview
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Window
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
Dialog
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWinCommunicationsToolbox
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWinMediaToolbox
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWinBrowsertabbarToolbox
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWinGlass
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWinBorderlessGlass
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWinExcludeGlass
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozMacHelpButton
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWindowButtonBox
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWindowButtonBoxMaximized
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWindowButtonClose
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWindowButtonMaximize
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWindowButtonMinimize
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWindowButtonRestore
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWindowFrameBottom
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWindowFrameLeft
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWindowFrameRight
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWindowTitlebar
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozWindowTitlebarMaximized
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozMacActiveSourceListSelection
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozMacDisclosureButtonClosed
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozMacDisclosureButtonOpen
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozMacSourceList
#
[
parse
(
condition
=
"
ParserContext
:
:
in_ua_or_chrome_sheet
"
)
]
MozMacSourceListSelection
#
[
css
(
skip
)
]
FocusOutline
#
[
css
(
skip
)
]
Count
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToCss
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
BreakBetween
{
Always
Auto
Page
Avoid
Left
Right
}
impl
BreakBetween
{
#
[
inline
]
pub
(
crate
)
fn
parse_legacy
<
'
i
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
_
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
break_value
=
BreakBetween
:
:
parse
(
input
)
?
;
match
break_value
{
BreakBetween
:
:
Always
=
>
Ok
(
BreakBetween
:
:
Page
)
BreakBetween
:
:
Auto
|
BreakBetween
:
:
Avoid
|
BreakBetween
:
:
Left
|
BreakBetween
:
:
Right
=
>
{
Ok
(
break_value
)
}
BreakBetween
:
:
Page
=
>
{
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
}
pub
(
crate
)
fn
to_css_legacy
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
*
self
{
BreakBetween
:
:
Auto
|
BreakBetween
:
:
Avoid
|
BreakBetween
:
:
Left
|
BreakBetween
:
:
Right
=
>
{
self
.
to_css
(
dest
)
}
BreakBetween
:
:
Page
=
>
dest
.
write_str
(
"
always
"
)
BreakBetween
:
:
Always
=
>
Ok
(
(
)
)
}
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToCss
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
BreakWithin
{
Auto
Avoid
AvoidPage
AvoidColumn
}
impl
BreakWithin
{
#
[
inline
]
pub
(
crate
)
fn
parse_legacy
<
'
i
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
_
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
break_value
=
BreakWithin
:
:
parse
(
input
)
?
;
match
break_value
{
BreakWithin
:
:
Auto
|
BreakWithin
:
:
Avoid
=
>
Ok
(
break_value
)
BreakWithin
:
:
AvoidPage
|
BreakWithin
:
:
AvoidColumn
=
>
{
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
}
pub
(
crate
)
fn
to_css_legacy
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
*
self
{
BreakWithin
:
:
Auto
|
BreakWithin
:
:
Avoid
=
>
self
.
to_css
(
dest
)
BreakWithin
:
:
AvoidPage
|
BreakWithin
:
:
AvoidColumn
=
>
Ok
(
(
)
)
}
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToCss
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
Overflow
{
Visible
Hidden
Scroll
Auto
#
[
cfg
(
feature
=
"
gecko
"
)
]
Clip
}
impl
Parse
for
Overflow
{
fn
parse
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Ok
(
try_match_ident_ignore_ascii_case
!
{
input
"
visible
"
=
>
Self
:
:
Visible
"
hidden
"
=
>
Self
:
:
Hidden
"
scroll
"
=
>
Self
:
:
Scroll
"
auto
"
=
>
Self
:
:
Auto
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
clip
"
=
>
Self
:
:
Clip
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
-
moz
-
hidden
-
unscrollable
"
if
static_prefs
:
:
pref
!
(
"
layout
.
css
.
overflow
-
moz
-
hidden
-
unscrollable
.
enabled
"
)
=
>
{
Overflow
:
:
Clip
}
}
)
}
}
impl
Overflow
{
#
[
inline
]
pub
fn
is_scrollable
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Self
:
:
Hidden
|
Self
:
:
Scroll
|
Self
:
:
Auto
)
}
#
[
inline
]
pub
fn
to_scrollable
(
&
self
)
-
>
Self
{
match
*
self
{
Self
:
:
Hidden
|
Self
:
:
Scroll
|
Self
:
:
Auto
=
>
*
self
Self
:
:
Visible
=
>
Self
:
:
Auto
#
[
cfg
(
feature
=
"
gecko
"
)
]
Self
:
:
Clip
=
>
Self
:
:
Hidden
}
}
}
bitflags
!
{
#
[
derive
(
MallocSizeOf
SpecifiedValueInfo
ToCss
ToComputedValue
ToResolvedValue
ToShmem
Parse
)
]
#
[
repr
(
C
)
]
#
[
css
(
bitflags
(
single
=
"
auto
"
mixed
=
"
stable
both
-
edges
"
validate_mixed
=
"
Self
:
:
has_stable
"
)
)
]
/
/
/
Values
for
scrollbar
-
gutter
:
/
/
/
<
https
:
/
/
drafts
.
csswg
.
org
/
css
-
overflow
-
3
/
#
scrollbar
-
gutter
-
property
>
pub
struct
ScrollbarGutter
:
u8
{
/
/
/
auto
variant
.
Just
for
convenience
if
there
is
no
flag
set
.
const
AUTO
=
0
;
/
/
/
stable
variant
.
const
STABLE
=
1
<
<
0
;
/
/
/
both
-
edges
variant
.
const
BOTH_EDGES
=
1
<
<
1
;
}
}
impl
ScrollbarGutter
{
#
[
inline
]
fn
has_stable
(
&
self
)
-
>
bool
{
self
.
intersects
(
Self
:
:
STABLE
)
}
}
