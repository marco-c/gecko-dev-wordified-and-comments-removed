use
cssparser
:
:
{
Parser
Token
serialize_identifier
}
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
std
:
:
{
fmt
mem
usize
}
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
style_traits
:
:
ToCss
;
use
values
:
:
{
CSSFloat
CustomIdent
Either
HasViewportPercentage
}
;
use
values
:
:
computed
:
:
{
self
ComputedValueAsSpecified
Context
ToComputedValue
}
;
use
values
:
:
specified
:
:
{
Integer
LengthOrPercentage
}
;
#
[
derive
(
PartialEq
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
GridLine
{
pub
is_span
:
bool
pub
ident
:
Option
<
String
>
pub
line_num
:
Option
<
Integer
>
}
impl
GridLine
{
pub
fn
is_auto
(
&
self
)
-
>
bool
{
self
.
ident
.
is_none
(
)
&
&
self
.
line_num
.
is_none
(
)
&
&
!
self
.
is_span
}
}
impl
Default
for
GridLine
{
fn
default
(
)
-
>
Self
{
GridLine
{
is_span
:
false
ident
:
None
line_num
:
None
}
}
}
impl
ToCss
for
GridLine
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
if
self
.
is_auto
(
)
{
return
dest
.
write_str
(
"
auto
"
)
}
if
self
.
is_span
{
dest
.
write_str
(
"
span
"
)
?
;
}
if
let
Some
(
i
)
=
self
.
line_num
{
write
!
(
dest
"
{
}
"
i
.
value
)
?
;
}
if
let
Some
(
ref
s
)
=
self
.
ident
{
dest
.
write_str
(
"
"
)
?
;
serialize_identifier
(
s
dest
)
?
;
}
Ok
(
(
)
)
}
}
impl
Parse
for
GridLine
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
let
mut
grid_line
=
Default
:
:
default
(
)
;
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
auto
"
)
)
.
is_ok
(
)
{
return
Ok
(
grid_line
)
}
for
_
in
0
.
.
3
{
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
span
"
)
)
.
is_ok
(
)
{
if
grid_line
.
is_span
|
|
grid_line
.
line_num
.
is_some
(
)
|
|
grid_line
.
ident
.
is_some
(
)
{
return
Err
(
(
)
)
}
grid_line
.
is_span
=
true
;
}
else
if
let
Ok
(
i
)
=
input
.
try
(
|
i
|
Integer
:
:
parse
(
context
i
)
)
{
if
i
.
value
=
=
0
|
|
grid_line
.
line_num
.
is_some
(
)
{
return
Err
(
(
)
)
}
grid_line
.
line_num
=
Some
(
i
)
;
}
else
if
let
Ok
(
name
)
=
input
.
try
(
|
i
|
i
.
expect_ident
(
)
)
{
if
grid_line
.
ident
.
is_some
(
)
|
|
CustomIdent
:
:
from_ident
(
(
&
*
name
)
.
into
(
)
&
[
]
)
.
is_err
(
)
{
return
Err
(
(
)
)
}
grid_line
.
ident
=
Some
(
name
.
into_owned
(
)
)
;
}
else
{
break
}
}
if
grid_line
.
is_auto
(
)
{
return
Err
(
(
)
)
}
if
grid_line
.
is_span
{
if
let
Some
(
i
)
=
grid_line
.
line_num
{
if
i
.
value
<
=
0
{
return
Err
(
(
)
)
}
}
else
if
grid_line
.
ident
.
is_some
(
)
{
grid_line
.
line_num
=
Some
(
Integer
:
:
new
(
1
)
)
;
}
else
{
return
Err
(
(
)
)
}
}
Ok
(
grid_line
)
}
}
impl
ComputedValueAsSpecified
for
GridLine
{
}
no_viewport_percentage
!
(
GridLine
)
;
define_css_keyword_enum
!
{
TrackKeyword
:
"
auto
"
=
>
Auto
"
max
-
content
"
=
>
MaxContent
"
min
-
content
"
=
>
MinContent
}
#
[
derive
(
Clone
PartialEq
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
TrackBreadth
<
L
>
{
Breadth
(
L
)
Flex
(
CSSFloat
)
Keyword
(
TrackKeyword
)
}
impl
<
L
>
TrackBreadth
<
L
>
{
#
[
inline
]
pub
fn
is_fixed
(
&
self
)
-
>
bool
{
match
*
self
{
TrackBreadth
:
:
Breadth
(
ref
_lop
)
=
>
true
_
=
>
false
}
}
}
pub
fn
parse_flex
(
input
:
&
mut
Parser
)
-
>
Result
<
CSSFloat
(
)
>
{
match
input
.
next
(
)
?
{
Token
:
:
Dimension
(
ref
value
ref
unit
)
if
unit
.
eq_ignore_ascii_case
(
"
fr
"
)
&
&
value
.
value
.
is_sign_positive
(
)
=
>
Ok
(
value
.
value
)
_
=
>
Err
(
(
)
)
}
}
impl
Parse
for
TrackBreadth
<
LengthOrPercentage
>
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
if
let
Ok
(
lop
)
=
input
.
try
(
|
i
|
LengthOrPercentage
:
:
parse_non_negative
(
context
i
)
)
{
return
Ok
(
TrackBreadth
:
:
Breadth
(
lop
)
)
}
if
let
Ok
(
f
)
=
input
.
try
(
parse_flex
)
{
return
Ok
(
TrackBreadth
:
:
Flex
(
f
)
)
}
TrackKeyword
:
:
parse
(
input
)
.
map
(
TrackBreadth
:
:
Keyword
)
}
}
impl
<
L
:
ToCss
>
ToCss
for
TrackBreadth
<
L
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
TrackBreadth
:
:
Breadth
(
ref
lop
)
=
>
lop
.
to_css
(
dest
)
TrackBreadth
:
:
Flex
(
ref
value
)
=
>
write
!
(
dest
"
{
}
fr
"
value
)
TrackBreadth
:
:
Keyword
(
ref
k
)
=
>
k
.
to_css
(
dest
)
}
}
}
impl
HasViewportPercentage
for
TrackBreadth
<
LengthOrPercentage
>
{
#
[
inline
]
fn
has_viewport_percentage
(
&
self
)
-
>
bool
{
if
let
TrackBreadth
:
:
Breadth
(
ref
lop
)
=
*
self
{
lop
.
has_viewport_percentage
(
)
}
else
{
false
}
}
}
impl
<
L
:
ToComputedValue
>
ToComputedValue
for
TrackBreadth
<
L
>
{
type
ComputedValue
=
TrackBreadth
<
L
:
:
ComputedValue
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
match
*
self
{
TrackBreadth
:
:
Breadth
(
ref
lop
)
=
>
TrackBreadth
:
:
Breadth
(
lop
.
to_computed_value
(
context
)
)
TrackBreadth
:
:
Flex
(
fr
)
=
>
TrackBreadth
:
:
Flex
(
fr
)
TrackBreadth
:
:
Keyword
(
k
)
=
>
TrackBreadth
:
:
Keyword
(
k
)
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
match
*
computed
{
TrackBreadth
:
:
Breadth
(
ref
lop
)
=
>
TrackBreadth
:
:
Breadth
(
ToComputedValue
:
:
from_computed_value
(
lop
)
)
TrackBreadth
:
:
Flex
(
fr
)
=
>
TrackBreadth
:
:
Flex
(
fr
)
TrackBreadth
:
:
Keyword
(
k
)
=
>
TrackBreadth
:
:
Keyword
(
k
)
}
}
}
#
[
derive
(
Clone
Debug
HasViewportPercentage
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
TrackSize
<
L
>
{
Breadth
(
TrackBreadth
<
L
>
)
MinMax
(
TrackBreadth
<
L
>
TrackBreadth
<
L
>
)
FitContent
(
L
)
}
impl
<
L
>
TrackSize
<
L
>
{
pub
fn
is_fixed
(
&
self
)
-
>
bool
{
match
*
self
{
TrackSize
:
:
Breadth
(
ref
breadth
)
=
>
breadth
.
is_fixed
(
)
TrackSize
:
:
MinMax
(
ref
breadth_1
ref
breadth_2
)
=
>
{
if
breadth_1
.
is_fixed
(
)
{
return
true
}
match
*
breadth_1
{
TrackBreadth
:
:
Flex
(
_
)
=
>
false
_
=
>
breadth_2
.
is_fixed
(
)
}
}
TrackSize
:
:
FitContent
(
_
)
=
>
false
}
}
}
impl
<
L
>
Default
for
TrackSize
<
L
>
{
fn
default
(
)
-
>
Self
{
TrackSize
:
:
Breadth
(
TrackBreadth
:
:
Keyword
(
TrackKeyword
:
:
Auto
)
)
}
}
impl
Parse
for
TrackSize
<
LengthOrPercentage
>
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
if
let
Ok
(
b
)
=
input
.
try
(
|
i
|
TrackBreadth
:
:
parse
(
context
i
)
)
{
return
Ok
(
TrackSize
:
:
Breadth
(
b
)
)
}
if
input
.
try
(
|
i
|
i
.
expect_function_matching
(
"
minmax
"
)
)
.
is_ok
(
)
{
return
input
.
parse_nested_block
(
|
input
|
{
let
inflexible_breadth
=
match
input
.
try
(
|
i
|
LengthOrPercentage
:
:
parse_non_negative
(
context
i
)
)
{
Ok
(
lop
)
=
>
TrackBreadth
:
:
Breadth
(
lop
)
Err
(
.
.
)
=
>
{
let
keyword
=
TrackKeyword
:
:
parse
(
input
)
?
;
TrackBreadth
:
:
Keyword
(
keyword
)
}
}
;
input
.
expect_comma
(
)
?
;
Ok
(
TrackSize
:
:
MinMax
(
inflexible_breadth
TrackBreadth
:
:
parse
(
context
input
)
?
)
)
}
)
;
}
input
.
expect_function_matching
(
"
fit
-
content
"
)
?
;
let
lop
=
input
.
parse_nested_block
(
|
i
|
LengthOrPercentage
:
:
parse_non_negative
(
context
i
)
)
?
;
Ok
(
TrackSize
:
:
FitContent
(
lop
)
)
}
}
impl
<
L
:
ToCss
>
ToCss
for
TrackSize
<
L
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
TrackSize
:
:
Breadth
(
ref
b
)
=
>
b
.
to_css
(
dest
)
TrackSize
:
:
MinMax
(
ref
infexible
ref
flexible
)
=
>
{
dest
.
write_str
(
"
minmax
(
"
)
?
;
infexible
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
flexible
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
TrackSize
:
:
FitContent
(
ref
lop
)
=
>
{
dest
.
write_str
(
"
fit
-
content
(
"
)
?
;
lop
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
}
}
}
impl
<
L
:
ToComputedValue
>
ToComputedValue
for
TrackSize
<
L
>
{
type
ComputedValue
=
TrackSize
<
L
:
:
ComputedValue
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
match
*
self
{
TrackSize
:
:
Breadth
(
ref
b
)
=
>
match
*
b
{
TrackBreadth
:
:
Flex
(
f
)
=
>
TrackSize
:
:
MinMax
(
TrackBreadth
:
:
Keyword
(
TrackKeyword
:
:
Auto
)
TrackBreadth
:
:
Flex
(
f
)
)
_
=
>
TrackSize
:
:
Breadth
(
b
.
to_computed_value
(
context
)
)
}
TrackSize
:
:
MinMax
(
ref
b_1
ref
b_2
)
=
>
TrackSize
:
:
MinMax
(
b_1
.
to_computed_value
(
context
)
b_2
.
to_computed_value
(
context
)
)
TrackSize
:
:
FitContent
(
ref
lop
)
=
>
TrackSize
:
:
FitContent
(
lop
.
to_computed_value
(
context
)
)
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
match
*
computed
{
TrackSize
:
:
Breadth
(
ref
b
)
=
>
TrackSize
:
:
Breadth
(
ToComputedValue
:
:
from_computed_value
(
b
)
)
TrackSize
:
:
MinMax
(
ref
b_1
ref
b_2
)
=
>
TrackSize
:
:
MinMax
(
ToComputedValue
:
:
from_computed_value
(
b_1
)
ToComputedValue
:
:
from_computed_value
(
b_2
)
)
TrackSize
:
:
FitContent
(
ref
lop
)
=
>
TrackSize
:
:
FitContent
(
ToComputedValue
:
:
from_computed_value
(
lop
)
)
}
}
}
pub
fn
parse_line_names
(
input
:
&
mut
Parser
)
-
>
Result
<
Vec
<
String
>
(
)
>
{
input
.
expect_square_bracket_block
(
)
?
;
input
.
parse_nested_block
(
|
input
|
{
let
mut
values
=
vec
!
[
]
;
while
let
Ok
(
ident
)
=
input
.
try
(
|
i
|
i
.
expect_ident
(
)
)
{
if
CustomIdent
:
:
from_ident
(
(
&
*
ident
)
.
into
(
)
&
[
"
span
"
]
)
.
is_err
(
)
{
return
Err
(
(
)
)
}
values
.
push
(
ident
.
into_owned
(
)
)
;
}
Ok
(
values
)
}
)
}
fn
concat_serialize_idents
<
W
>
(
prefix
:
&
str
suffix
:
&
str
slice
:
&
[
String
]
sep
:
&
str
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
if
let
Some
(
(
ref
first
rest
)
)
=
slice
.
split_first
(
)
{
dest
.
write_str
(
prefix
)
?
;
serialize_identifier
(
first
dest
)
?
;
for
thing
in
rest
{
dest
.
write_str
(
sep
)
?
;
serialize_identifier
(
thing
dest
)
?
;
}
dest
.
write_str
(
suffix
)
?
;
}
Ok
(
(
)
)
}
#
[
derive
(
Clone
Copy
PartialEq
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
RepeatCount
{
Number
(
Integer
)
AutoFill
AutoFit
}
impl
Parse
for
RepeatCount
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
if
let
Ok
(
i
)
=
input
.
try
(
|
i
|
Integer
:
:
parse
(
context
i
)
)
{
if
i
.
value
>
0
{
Ok
(
RepeatCount
:
:
Number
(
i
)
)
}
else
{
Err
(
(
)
)
}
}
else
{
match_ignore_ascii_case
!
{
&
input
.
expect_ident
(
)
?
"
auto
-
fill
"
=
>
Ok
(
RepeatCount
:
:
AutoFill
)
"
auto
-
fit
"
=
>
Ok
(
RepeatCount
:
:
AutoFit
)
_
=
>
Err
(
(
)
)
}
}
}
}
impl
ToCss
for
RepeatCount
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
RepeatCount
:
:
Number
(
ref
c
)
=
>
c
.
to_css
(
dest
)
RepeatCount
:
:
AutoFill
=
>
dest
.
write_str
(
"
auto
-
fill
"
)
RepeatCount
:
:
AutoFit
=
>
dest
.
write_str
(
"
auto
-
fit
"
)
}
}
}
impl
ComputedValueAsSpecified
for
RepeatCount
{
}
no_viewport_percentage
!
(
RepeatCount
)
;
#
[
derive
(
Clone
Copy
PartialEq
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
enum
RepeatType
{
Auto
Normal
Fixed
}
#
[
derive
(
Clone
PartialEq
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
TrackRepeat
<
L
>
{
pub
count
:
RepeatCount
pub
line_names
:
Vec
<
Vec
<
String
>
>
pub
track_sizes
:
Vec
<
TrackSize
<
L
>
>
}
impl
TrackRepeat
<
LengthOrPercentage
>
{
fn
parse_with_repeat_type
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
(
TrackRepeat
<
LengthOrPercentage
>
RepeatType
)
(
)
>
{
input
.
try
(
|
i
|
i
.
expect_function_matching
(
"
repeat
"
)
)
.
and_then
(
|
_
|
{
input
.
parse_nested_block
(
|
input
|
{
let
count
=
RepeatCount
:
:
parse
(
context
input
)
?
;
input
.
expect_comma
(
)
?
;
let
is_auto
=
count
=
=
RepeatCount
:
:
AutoFit
|
|
count
=
=
RepeatCount
:
:
AutoFill
;
let
mut
repeat_type
=
if
is_auto
{
RepeatType
:
:
Auto
}
else
{
RepeatType
:
:
Fixed
}
;
let
mut
names
=
vec
!
[
]
;
let
mut
values
=
vec
!
[
]
;
let
mut
current_names
;
loop
{
current_names
=
input
.
try
(
parse_line_names
)
.
unwrap_or
(
vec
!
[
]
)
;
if
let
Ok
(
track_size
)
=
input
.
try
(
|
i
|
TrackSize
:
:
parse
(
context
i
)
)
{
if
!
track_size
.
is_fixed
(
)
{
if
is_auto
{
return
Err
(
(
)
)
}
if
repeat_type
=
=
RepeatType
:
:
Fixed
{
repeat_type
=
RepeatType
:
:
Normal
}
}
values
.
push
(
track_size
)
;
names
.
push
(
current_names
)
;
}
else
{
if
values
.
is_empty
(
)
{
return
Err
(
(
)
)
}
names
.
push
(
current_names
)
;
break
}
}
let
repeat
=
TrackRepeat
{
count
:
count
track_sizes
:
values
line_names
:
names
}
;
Ok
(
(
repeat
repeat_type
)
)
}
)
}
)
}
}
impl
<
L
:
ToCss
>
ToCss
for
TrackRepeat
<
L
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_str
(
"
repeat
(
"
)
?
;
self
.
count
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
let
mut
line_names_iter
=
self
.
line_names
.
iter
(
)
;
for
(
i
(
ref
size
ref
names
)
)
in
self
.
track_sizes
.
iter
(
)
.
zip
(
&
mut
line_names_iter
)
.
enumerate
(
)
{
if
i
>
0
{
dest
.
write_str
(
"
"
)
?
;
}
concat_serialize_idents
(
"
[
"
"
]
"
names
"
"
dest
)
?
;
size
.
to_css
(
dest
)
?
;
}
if
let
Some
(
line_names_last
)
=
line_names_iter
.
next
(
)
{
concat_serialize_idents
(
"
[
"
"
]
"
line_names_last
"
"
dest
)
?
;
}
dest
.
write_str
(
"
)
"
)
?
;
Ok
(
(
)
)
}
}
impl
HasViewportPercentage
for
TrackRepeat
<
LengthOrPercentage
>
{
#
[
inline
]
fn
has_viewport_percentage
(
&
self
)
-
>
bool
{
self
.
track_sizes
.
iter
(
)
.
any
(
|
ref
v
|
v
.
has_viewport_percentage
(
)
)
}
}
impl
<
L
:
ToComputedValue
>
ToComputedValue
for
TrackRepeat
<
L
>
{
type
ComputedValue
=
TrackRepeat
<
L
:
:
ComputedValue
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
if
let
RepeatCount
:
:
Number
(
num
)
=
self
.
count
{
let
mut
line_names
=
vec
!
[
]
;
let
mut
track_sizes
=
vec
!
[
]
;
let
mut
prev_names
=
vec
!
[
]
;
for
_
in
0
.
.
num
.
value
{
let
mut
names_iter
=
self
.
line_names
.
iter
(
)
;
for
(
size
names
)
in
self
.
track_sizes
.
iter
(
)
.
zip
(
&
mut
names_iter
)
{
prev_names
.
extend_from_slice
(
&
names
)
;
line_names
.
push
(
mem
:
:
replace
(
&
mut
prev_names
vec
!
[
]
)
)
;
track_sizes
.
push
(
size
.
to_computed_value
(
context
)
)
;
}
if
let
Some
(
names
)
=
names_iter
.
next
(
)
{
prev_names
.
extend_from_slice
(
&
names
)
;
}
}
line_names
.
push
(
prev_names
)
;
TrackRepeat
{
count
:
self
.
count
track_sizes
:
track_sizes
line_names
:
line_names
}
}
else
{
TrackRepeat
{
count
:
self
.
count
track_sizes
:
self
.
track_sizes
.
iter
(
)
.
map
(
|
l
|
l
.
to_computed_value
(
context
)
)
.
collect
(
)
line_names
:
self
.
line_names
.
clone
(
)
}
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
TrackRepeat
{
count
:
computed
.
count
track_sizes
:
computed
.
track_sizes
.
iter
(
)
.
map
(
ToComputedValue
:
:
from_computed_value
)
.
collect
(
)
line_names
:
computed
.
line_names
.
clone
(
)
}
}
}
#
[
derive
(
Clone
Copy
PartialEq
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
TrackListType
{
Auto
(
u16
)
Normal
Explicit
}
#
[
derive
(
Clone
PartialEq
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
TrackList
<
T
>
{
pub
list_type
:
TrackListType
pub
values
:
Vec
<
T
>
pub
line_names
:
Vec
<
Vec
<
String
>
>
pub
auto_repeat
:
Option
<
TrackRepeat
<
computed
:
:
LengthOrPercentage
>
>
}
pub
type
TrackSizeOrRepeat
=
Either
<
TrackSize
<
LengthOrPercentage
>
TrackRepeat
<
LengthOrPercentage
>
>
;
impl
Parse
for
TrackList
<
TrackSizeOrRepeat
>
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
let
mut
current_names
;
let
mut
names
=
vec
!
[
]
;
let
mut
values
=
vec
!
[
]
;
let
mut
list_type
=
TrackListType
:
:
Explicit
;
let
mut
is_auto
=
false
;
let
mut
atleast_one_not_fixed
=
false
;
loop
{
current_names
=
input
.
try
(
parse_line_names
)
.
unwrap_or
(
vec
!
[
]
)
;
if
let
Ok
(
track_size
)
=
input
.
try
(
|
i
|
TrackSize
:
:
parse
(
context
i
)
)
{
if
!
track_size
.
is_fixed
(
)
{
atleast_one_not_fixed
=
true
;
if
is_auto
{
return
Err
(
(
)
)
}
}
names
.
push
(
current_names
)
;
values
.
push
(
Either
:
:
First
(
track_size
)
)
;
}
else
if
let
Ok
(
(
repeat
type_
)
)
=
input
.
try
(
|
i
|
TrackRepeat
:
:
parse_with_repeat_type
(
context
i
)
)
{
if
list_type
=
=
TrackListType
:
:
Explicit
{
list_type
=
TrackListType
:
:
Normal
;
}
match
type_
{
RepeatType
:
:
Normal
=
>
{
atleast_one_not_fixed
=
true
;
if
is_auto
{
return
Err
(
(
)
)
}
}
RepeatType
:
:
Auto
=
>
{
if
is_auto
|
|
atleast_one_not_fixed
{
return
Err
(
(
)
)
}
is_auto
=
true
;
list_type
=
TrackListType
:
:
Auto
(
values
.
len
(
)
as
u16
)
;
}
RepeatType
:
:
Fixed
=
>
(
)
}
names
.
push
(
current_names
)
;
values
.
push
(
Either
:
:
Second
(
repeat
)
)
;
}
else
{
if
values
.
is_empty
(
)
{
return
Err
(
(
)
)
}
names
.
push
(
current_names
)
;
break
}
}
Ok
(
TrackList
{
list_type
:
list_type
values
:
values
line_names
:
names
auto_repeat
:
None
}
)
}
}
impl
<
T
:
ToCss
>
ToCss
for
TrackList
<
T
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
let
auto_idx
=
match
self
.
list_type
{
TrackListType
:
:
Auto
(
i
)
=
>
i
as
usize
_
=
>
usize
:
:
MAX
}
;
let
mut
values_iter
=
self
.
values
.
iter
(
)
.
peekable
(
)
;
let
mut
line_names_iter
=
self
.
line_names
.
iter
(
)
.
peekable
(
)
;
for
idx
in
0
.
.
{
let
names
=
line_names_iter
.
next
(
)
.
unwrap
(
)
;
concat_serialize_idents
(
"
[
"
"
]
"
names
"
"
dest
)
?
;
match
self
.
auto_repeat
{
Some
(
ref
repeat
)
if
idx
=
=
auto_idx
=
>
{
if
!
names
.
is_empty
(
)
{
dest
.
write_str
(
"
"
)
?
;
}
repeat
.
to_css
(
dest
)
?
;
}
_
=
>
match
values_iter
.
next
(
)
{
Some
(
value
)
=
>
{
if
!
names
.
is_empty
(
)
{
dest
.
write_str
(
"
"
)
?
;
}
value
.
to_css
(
dest
)
?
;
}
None
=
>
break
}
}
if
values_iter
.
peek
(
)
.
is_some
(
)
|
|
line_names_iter
.
peek
(
)
.
map_or
(
false
|
v
|
!
v
.
is_empty
(
)
)
{
dest
.
write_str
(
"
"
)
?
;
}
}
Ok
(
(
)
)
}
}
impl
HasViewportPercentage
for
TrackList
<
TrackSizeOrRepeat
>
{
#
[
inline
]
fn
has_viewport_percentage
(
&
self
)
-
>
bool
{
self
.
values
.
iter
(
)
.
any
(
|
ref
v
|
v
.
has_viewport_percentage
(
)
)
}
}
impl
ToComputedValue
for
TrackList
<
TrackSizeOrRepeat
>
{
type
ComputedValue
=
TrackList
<
TrackSize
<
computed
:
:
LengthOrPercentage
>
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
let
mut
line_names
=
vec
!
[
]
;
let
mut
list_type
=
self
.
list_type
;
let
mut
values
=
vec
!
[
]
;
let
mut
prev_names
=
vec
!
[
]
;
let
mut
auto_repeat
=
None
;
let
mut
names_iter
=
self
.
line_names
.
iter
(
)
;
for
(
size_or_repeat
names
)
in
self
.
values
.
iter
(
)
.
zip
(
&
mut
names_iter
)
{
prev_names
.
extend_from_slice
(
names
)
;
match
*
size_or_repeat
{
Either
:
:
First
(
ref
size
)
=
>
values
.
push
(
size
.
to_computed_value
(
context
)
)
Either
:
:
Second
(
ref
repeat
)
=
>
{
let
mut
computed
=
repeat
.
to_computed_value
(
context
)
;
if
computed
.
count
=
=
RepeatCount
:
:
AutoFit
|
|
computed
.
count
=
=
RepeatCount
:
:
AutoFill
{
line_names
.
push
(
mem
:
:
replace
(
&
mut
prev_names
vec
!
[
]
)
)
;
list_type
=
TrackListType
:
:
Auto
(
values
.
len
(
)
as
u16
)
;
auto_repeat
=
Some
(
computed
)
;
continue
}
let
mut
repeat_names_iter
=
computed
.
line_names
.
drain
(
.
.
)
;
for
(
size
mut
names
)
in
computed
.
track_sizes
.
drain
(
.
.
)
.
zip
(
&
mut
repeat_names_iter
)
{
prev_names
.
append
(
&
mut
names
)
;
line_names
.
push
(
mem
:
:
replace
(
&
mut
prev_names
vec
!
[
]
)
)
;
values
.
push
(
size
)
;
}
if
let
Some
(
mut
names
)
=
repeat_names_iter
.
next
(
)
{
prev_names
.
append
(
&
mut
names
)
;
}
continue
}
}
line_names
.
push
(
mem
:
:
replace
(
&
mut
prev_names
vec
!
[
]
)
)
;
}
if
let
Some
(
names
)
=
names_iter
.
next
(
)
{
prev_names
.
extend_from_slice
(
names
)
;
}
line_names
.
push
(
mem
:
:
replace
(
&
mut
prev_names
vec
!
[
]
)
)
;
TrackList
{
list_type
:
list_type
values
:
values
line_names
:
line_names
auto_repeat
:
auto_repeat
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
let
auto_idx
=
if
let
TrackListType
:
:
Auto
(
idx
)
=
computed
.
list_type
{
idx
as
usize
}
else
{
usize
:
:
MAX
}
;
let
mut
values
=
Vec
:
:
with_capacity
(
computed
.
values
.
len
(
)
+
1
)
;
for
(
i
value
)
in
computed
.
values
.
iter
(
)
.
map
(
ToComputedValue
:
:
from_computed_value
)
.
enumerate
(
)
{
if
i
=
=
auto_idx
{
let
value
=
TrackRepeat
:
:
from_computed_value
(
computed
.
auto_repeat
.
as_ref
(
)
.
unwrap
(
)
)
;
values
.
push
(
Either
:
:
Second
(
value
)
)
;
}
values
.
push
(
Either
:
:
First
(
value
)
)
;
}
TrackList
{
list_type
:
computed
.
list_type
values
:
values
line_names
:
computed
.
line_names
.
clone
(
)
auto_repeat
:
None
}
}
}
