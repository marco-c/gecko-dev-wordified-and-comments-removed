use
cssparser
:
:
Parser
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
iter
:
:
Peekable
;
use
std
:
:
str
:
:
Chars
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
use
style_traits
:
:
values
:
:
SequenceWriter
;
use
values
:
:
CSSFloat
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
enum
OffsetPath
{
#
[
css
(
function
)
]
Path
(
SVGPathData
)
None
}
impl
OffsetPath
{
#
[
inline
]
pub
fn
none
(
)
-
>
Self
{
OffsetPath
:
:
None
}
}
impl
Parse
for
OffsetPath
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
none
"
)
)
.
is_ok
(
)
{
return
Ok
(
OffsetPath
:
:
none
(
)
)
;
}
let
location
=
input
.
current_source_location
(
)
;
let
function
=
input
.
expect_function
(
)
?
.
clone
(
)
;
input
.
parse_nested_block
(
move
|
i
|
{
match_ignore_ascii_case
!
{
&
function
/
/
Bug
1186329
:
Implement
the
parser
for
ray
(
)
<
basic
-
shape
>
<
geometry
-
box
>
/
/
and
<
url
>
.
"
path
"
=
>
SVGPathData
:
:
parse
(
context
i
)
.
map
(
OffsetPath
:
:
Path
)
_
=
>
{
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnexpectedFunction
(
function
.
clone
(
)
)
)
)
}
}
}
)
}
}
struct
PathParser
<
'
a
>
{
chars
:
Peekable
<
Chars
<
'
a
>
>
path
:
Vec
<
PathCommand
>
}
impl
<
'
a
>
PathParser
<
'
a
>
{
fn
parse_subpath
(
&
mut
self
)
-
>
Result
<
(
)
(
)
>
{
self
.
parse_moveto
(
)
?
;
loop
{
skip_wsp
(
&
mut
self
.
chars
)
;
if
self
.
chars
.
peek
(
)
.
map_or
(
true
|
m
|
*
m
=
=
'
M
'
|
|
*
m
=
=
'
m
'
)
{
break
;
}
match
self
.
chars
.
next
(
)
{
Some
(
command
)
=
>
{
let
abs
=
command
.
is_uppercase
(
)
;
match
command
{
'
Z
'
|
'
z
'
=
>
{
self
.
path
.
push
(
PathCommand
:
:
ClosePath
)
;
}
'
L
'
|
'
l
'
=
>
{
skip_wsp
(
&
mut
self
.
chars
)
;
self
.
parse_lineto
(
abs
)
?
;
}
'
H
'
|
'
h
'
=
>
{
skip_wsp
(
&
mut
self
.
chars
)
;
self
.
parse_h_lineto
(
abs
)
?
;
}
'
V
'
|
'
v
'
=
>
{
skip_wsp
(
&
mut
self
.
chars
)
;
self
.
parse_v_lineto
(
abs
)
?
;
}
'
C
'
|
'
c
'
=
>
{
skip_wsp
(
&
mut
self
.
chars
)
;
self
.
parse_curveto
(
abs
)
?
;
}
'
S
'
|
'
s
'
=
>
{
skip_wsp
(
&
mut
self
.
chars
)
;
self
.
parse_smooth_curveto
(
abs
)
?
;
}
'
Q
'
|
'
q
'
=
>
{
skip_wsp
(
&
mut
self
.
chars
)
;
self
.
parse_quadratic_bezier_curveto
(
abs
)
?
;
}
'
T
'
|
'
t
'
=
>
{
skip_wsp
(
&
mut
self
.
chars
)
;
self
.
parse_smooth_quadratic_bezier_curveto
(
abs
)
?
;
}
'
A
'
|
'
a
'
=
>
{
skip_wsp
(
&
mut
self
.
chars
)
;
self
.
parse_elliprical_arc
(
abs
)
?
;
}
_
=
>
return
Err
(
(
)
)
}
}
_
=
>
break
}
}
Ok
(
(
)
)
}
fn
parse_moveto
(
&
mut
self
)
-
>
Result
<
(
)
(
)
>
{
let
command
=
match
self
.
chars
.
next
(
)
{
Some
(
c
)
if
c
=
=
'
M
'
|
|
c
=
=
'
m
'
=
>
c
_
=
>
return
Err
(
(
)
)
}
;
skip_wsp
(
&
mut
self
.
chars
)
;
let
point
=
parse_coord
(
&
mut
self
.
chars
)
?
;
let
absolute
=
command
=
=
'
M
'
;
self
.
path
.
push
(
PathCommand
:
:
MoveTo
{
point
absolute
}
)
;
if
!
skip_wsp
(
&
mut
self
.
chars
)
|
|
self
.
chars
.
peek
(
)
.
map_or
(
true
|
c
|
c
.
is_ascii_alphabetic
(
)
)
{
return
Ok
(
(
)
)
;
}
skip_comma_wsp
(
&
mut
self
.
chars
)
;
self
.
parse_lineto
(
absolute
)
}
fn
parse_lineto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
loop
{
let
point
=
parse_coord
(
&
mut
self
.
chars
)
?
;
self
.
path
.
push
(
PathCommand
:
:
LineTo
{
point
absolute
}
)
;
if
!
skip_wsp
(
&
mut
self
.
chars
)
|
|
self
.
chars
.
peek
(
)
.
map_or
(
true
|
c
|
c
.
is_ascii_alphabetic
(
)
)
{
break
;
}
skip_comma_wsp
(
&
mut
self
.
chars
)
;
}
Ok
(
(
)
)
}
fn
parse_h_lineto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
loop
{
let
x
=
parse_number
(
&
mut
self
.
chars
)
?
;
self
.
path
.
push
(
PathCommand
:
:
HorizontalLineTo
{
x
absolute
}
)
;
if
!
skip_wsp
(
&
mut
self
.
chars
)
|
|
self
.
chars
.
peek
(
)
.
map_or
(
true
|
c
|
c
.
is_ascii_alphabetic
(
)
)
{
break
;
}
skip_comma_wsp
(
&
mut
self
.
chars
)
;
}
Ok
(
(
)
)
}
fn
parse_v_lineto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
loop
{
let
y
=
parse_number
(
&
mut
self
.
chars
)
?
;
self
.
path
.
push
(
PathCommand
:
:
VerticalLineTo
{
y
absolute
}
)
;
if
!
skip_wsp
(
&
mut
self
.
chars
)
|
|
self
.
chars
.
peek
(
)
.
map_or
(
true
|
c
|
c
.
is_ascii_alphabetic
(
)
)
{
break
;
}
skip_comma_wsp
(
&
mut
self
.
chars
)
;
}
Ok
(
(
)
)
}
fn
parse_curveto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
loop
{
let
control1
=
parse_coord
(
&
mut
self
.
chars
)
?
;
skip_comma_wsp
(
&
mut
self
.
chars
)
;
let
control2
=
parse_coord
(
&
mut
self
.
chars
)
?
;
skip_comma_wsp
(
&
mut
self
.
chars
)
;
let
point
=
parse_coord
(
&
mut
self
.
chars
)
?
;
self
.
path
.
push
(
PathCommand
:
:
CurveTo
{
control1
control2
point
absolute
}
)
;
if
!
skip_wsp
(
&
mut
self
.
chars
)
|
|
self
.
chars
.
peek
(
)
.
map_or
(
true
|
c
|
c
.
is_ascii_alphabetic
(
)
)
{
break
;
}
skip_comma_wsp
(
&
mut
self
.
chars
)
;
}
Ok
(
(
)
)
}
fn
parse_smooth_curveto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
loop
{
let
control2
=
parse_coord
(
&
mut
self
.
chars
)
?
;
skip_comma_wsp
(
&
mut
self
.
chars
)
;
let
point
=
parse_coord
(
&
mut
self
.
chars
)
?
;
self
.
path
.
push
(
PathCommand
:
:
SmoothCurveTo
{
control2
point
absolute
}
)
;
if
!
skip_wsp
(
&
mut
self
.
chars
)
|
|
self
.
chars
.
peek
(
)
.
map_or
(
true
|
c
|
c
.
is_ascii_alphabetic
(
)
)
{
break
;
}
skip_comma_wsp
(
&
mut
self
.
chars
)
;
}
Ok
(
(
)
)
}
fn
parse_quadratic_bezier_curveto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
loop
{
let
control1
=
parse_coord
(
&
mut
self
.
chars
)
?
;
skip_comma_wsp
(
&
mut
self
.
chars
)
;
let
point
=
parse_coord
(
&
mut
self
.
chars
)
?
;
self
.
path
.
push
(
PathCommand
:
:
QuadBezierCurveTo
{
control1
point
absolute
}
)
;
if
!
skip_wsp
(
&
mut
self
.
chars
)
|
|
self
.
chars
.
peek
(
)
.
map_or
(
true
|
c
|
c
.
is_ascii_alphabetic
(
)
)
{
break
;
}
skip_comma_wsp
(
&
mut
self
.
chars
)
;
}
Ok
(
(
)
)
}
fn
parse_smooth_quadratic_bezier_curveto
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
loop
{
let
point
=
parse_coord
(
&
mut
self
.
chars
)
?
;
self
.
path
.
push
(
PathCommand
:
:
SmoothQuadBezierCurveTo
{
point
absolute
}
)
;
if
!
skip_wsp
(
&
mut
self
.
chars
)
|
|
self
.
chars
.
peek
(
)
.
map_or
(
true
|
c
|
c
.
is_ascii_alphabetic
(
)
)
{
break
;
}
skip_comma_wsp
(
&
mut
self
.
chars
)
;
}
Ok
(
(
)
)
}
fn
parse_elliprical_arc
(
&
mut
self
absolute
:
bool
)
-
>
Result
<
(
)
(
)
>
{
let
parse_flag
=
|
iter
:
&
mut
Peekable
<
Chars
>
|
-
>
Result
<
bool
(
)
>
{
let
value
=
match
iter
.
peek
(
)
{
Some
(
c
)
if
*
c
=
=
'
0
'
|
|
*
c
=
=
'
1
'
=
>
*
c
=
=
'
1
'
_
=
>
return
Err
(
(
)
)
}
;
iter
.
next
(
)
;
Ok
(
value
)
}
;
loop
{
let
rx
=
parse_number
(
&
mut
self
.
chars
)
?
;
skip_comma_wsp
(
&
mut
self
.
chars
)
;
let
ry
=
parse_number
(
&
mut
self
.
chars
)
?
;
skip_comma_wsp
(
&
mut
self
.
chars
)
;
let
angle
=
parse_number
(
&
mut
self
.
chars
)
?
;
skip_comma_wsp
(
&
mut
self
.
chars
)
;
let
large_arc_flag
=
parse_flag
(
&
mut
self
.
chars
)
?
;
skip_comma_wsp
(
&
mut
self
.
chars
)
;
let
sweep_flag
=
parse_flag
(
&
mut
self
.
chars
)
?
;
skip_comma_wsp
(
&
mut
self
.
chars
)
;
let
point
=
parse_coord
(
&
mut
self
.
chars
)
?
;
self
.
path
.
push
(
PathCommand
:
:
EllipticalArc
{
rx
ry
angle
large_arc_flag
sweep_flag
point
absolute
}
)
;
if
!
skip_wsp
(
&
mut
self
.
chars
)
|
|
self
.
chars
.
peek
(
)
.
map_or
(
true
|
c
|
c
.
is_ascii_alphabetic
(
)
)
{
break
;
}
skip_comma_wsp
(
&
mut
self
.
chars
)
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
)
]
pub
struct
SVGPathData
(
Box
<
[
PathCommand
]
>
)
;
impl
SVGPathData
{
#
[
inline
]
pub
fn
new
(
cmd
:
Box
<
[
PathCommand
]
>
)
-
>
Self
{
debug_assert
!
(
!
cmd
.
is_empty
(
)
)
;
SVGPathData
(
cmd
)
}
#
[
inline
]
pub
fn
commands
(
&
self
)
-
>
&
[
PathCommand
]
{
debug_assert
!
(
!
self
.
0
.
is_empty
(
)
)
;
&
self
.
0
}
}
impl
ToCss
for
SVGPathData
{
#
[
inline
]
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_char
(
'
"
'
)
?
;
{
let
mut
writer
=
SequenceWriter
:
:
new
(
dest
"
"
)
;
for
command
in
self
.
0
.
iter
(
)
{
writer
.
item
(
command
)
?
;
}
}
dest
.
write_char
(
'
"
'
)
}
}
impl
Parse
for
SVGPathData
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
path_string
=
input
.
expect_string
(
)
?
.
as_ref
(
)
;
if
path_string
.
is_empty
(
)
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
let
mut
path_parser
=
PathParser
{
chars
:
path_string
.
chars
(
)
.
peekable
(
)
path
:
Vec
:
:
new
(
)
}
;
while
skip_wsp
(
&
mut
path_parser
.
chars
)
{
if
path_parser
.
parse_subpath
(
)
.
is_err
(
)
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
}
Ok
(
SVGPathData
:
:
new
(
path_parser
.
path
.
into_boxed_slice
(
)
)
)
}
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
)
]
#
[
allow
(
missing_docs
)
]
#
[
repr
(
C
u8
)
]
pub
enum
PathCommand
{
Unknown
MoveTo
{
point
:
CoordPair
absolute
:
bool
}
LineTo
{
point
:
CoordPair
absolute
:
bool
}
HorizontalLineTo
{
x
:
CSSFloat
absolute
:
bool
}
VerticalLineTo
{
y
:
CSSFloat
absolute
:
bool
}
CurveTo
{
control1
:
CoordPair
control2
:
CoordPair
point
:
CoordPair
absolute
:
bool
}
SmoothCurveTo
{
control2
:
CoordPair
point
:
CoordPair
absolute
:
bool
}
QuadBezierCurveTo
{
control1
:
CoordPair
point
:
CoordPair
absolute
:
bool
}
SmoothQuadBezierCurveTo
{
point
:
CoordPair
absolute
:
bool
}
EllipticalArc
{
rx
:
CSSFloat
ry
:
CSSFloat
angle
:
CSSFloat
large_arc_flag
:
bool
sweep_flag
:
bool
point
:
CoordPair
absolute
:
bool
}
ClosePath
}
impl
ToCss
for
PathCommand
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
use
self
:
:
PathCommand
:
:
*
;
match
*
self
{
Unknown
=
>
dest
.
write_str
(
"
X
"
)
ClosePath
=
>
dest
.
write_str
(
"
Z
"
)
MoveTo
{
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
M
'
}
else
{
'
m
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
LineTo
{
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
L
'
}
else
{
'
l
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
CurveTo
{
control1
control2
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
C
'
}
else
{
'
c
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
control1
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
control2
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
QuadBezierCurveTo
{
control1
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
Q
'
}
else
{
'
q
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
control1
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
EllipticalArc
{
rx
ry
angle
large_arc_flag
sweep_flag
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
A
'
}
else
{
'
a
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
rx
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
ry
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
angle
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
(
large_arc_flag
as
i32
)
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
(
sweep_flag
as
i32
)
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
HorizontalLineTo
{
x
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
H
'
}
else
{
'
h
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
x
.
to_css
(
dest
)
}
VerticalLineTo
{
y
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
V
'
}
else
{
'
v
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
y
.
to_css
(
dest
)
}
SmoothCurveTo
{
control2
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
S
'
}
else
{
'
s
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
control2
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
SmoothQuadBezierCurveTo
{
point
absolute
}
=
>
{
dest
.
write_char
(
if
absolute
{
'
T
'
}
else
{
'
t
'
}
)
?
;
dest
.
write_char
(
'
'
)
?
;
point
.
to_css
(
dest
)
}
}
}
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToCss
)
]
#
[
repr
(
C
)
]
pub
struct
CoordPair
(
CSSFloat
CSSFloat
)
;
impl
CoordPair
{
#
[
inline
]
pub
fn
new
(
x
:
CSSFloat
y
:
CSSFloat
)
-
>
Self
{
CoordPair
(
x
y
)
}
}
fn
parse_coord
(
iter
:
&
mut
Peekable
<
Chars
>
)
-
>
Result
<
CoordPair
(
)
>
{
let
x
=
parse_number
(
iter
)
?
;
skip_comma_wsp
(
iter
)
;
let
y
=
parse_number
(
iter
)
?
;
Ok
(
CoordPair
:
:
new
(
x
y
)
)
}
fn
parse_number
(
iter
:
&
mut
Peekable
<
Chars
>
)
-
>
Result
<
CSSFloat
(
)
>
{
let
sign
=
if
iter
.
peek
(
)
.
map_or
(
false
|
&
sign
:
&
char
|
sign
=
=
'
+
'
|
|
sign
=
=
'
-
'
)
{
if
iter
.
next
(
)
.
unwrap
(
)
=
=
'
-
'
{
-
1
.
}
else
{
1
.
}
}
else
{
1
.
}
;
let
mut
integral_part
:
f64
=
0
.
;
let
got_dot
=
if
!
iter
.
peek
(
)
.
map_or
(
false
|
&
n
:
&
char
|
n
=
=
'
.
'
)
{
if
iter
.
peek
(
)
.
map_or
(
true
|
n
:
&
char
|
!
n
.
is_ascii_digit
(
)
)
{
return
Err
(
(
)
)
;
}
while
iter
.
peek
(
)
.
map_or
(
false
|
n
:
&
char
|
n
.
is_ascii_digit
(
)
)
{
integral_part
=
integral_part
*
10
.
+
iter
.
next
(
)
.
unwrap
(
)
.
to_digit
(
10
)
.
unwrap
(
)
as
f64
;
}
iter
.
peek
(
)
.
map_or
(
false
|
&
n
:
&
char
|
n
=
=
'
.
'
)
}
else
{
true
}
;
let
mut
fractional_part
:
f64
=
0
.
;
if
got_dot
{
iter
.
next
(
)
;
if
iter
.
peek
(
)
.
map_or
(
true
|
n
:
&
char
|
!
n
.
is_ascii_digit
(
)
)
{
return
Err
(
(
)
)
;
}
let
mut
factor
=
0
.
1
;
while
iter
.
peek
(
)
.
map_or
(
false
|
n
:
&
char
|
n
.
is_ascii_digit
(
)
)
{
fractional_part
+
=
iter
.
next
(
)
.
unwrap
(
)
.
to_digit
(
10
)
.
unwrap
(
)
as
f64
*
factor
;
factor
*
=
0
.
1
;
}
}
let
mut
value
=
sign
*
(
integral_part
+
fractional_part
)
;
if
iter
.
peek
(
)
.
map_or
(
false
|
&
exp
:
&
char
|
exp
=
=
'
E
'
|
|
exp
=
=
'
e
'
)
{
iter
.
next
(
)
;
let
exp_sign
=
if
iter
.
peek
(
)
.
map_or
(
false
|
&
sign
:
&
char
|
sign
=
=
'
+
'
|
|
sign
=
=
'
-
'
)
{
if
iter
.
next
(
)
.
unwrap
(
)
=
=
'
-
'
{
-
1
.
}
else
{
1
.
}
}
else
{
1
.
}
;
let
mut
exp
:
f64
=
0
.
;
while
iter
.
peek
(
)
.
map_or
(
false
|
n
:
&
char
|
n
.
is_ascii_digit
(
)
)
{
exp
=
exp
*
10
.
+
iter
.
next
(
)
.
unwrap
(
)
.
to_digit
(
10
)
.
unwrap
(
)
as
f64
;
}
value
*
=
f64
:
:
powf
(
10
.
exp
*
exp_sign
)
;
}
if
value
.
is_finite
(
)
{
Ok
(
value
.
min
(
:
:
std
:
:
f32
:
:
MAX
as
f64
)
.
max
(
:
:
std
:
:
f32
:
:
MIN
as
f64
)
as
CSSFloat
)
}
else
{
Err
(
(
)
)
}
}
#
[
inline
]
fn
skip_wsp
(
iter
:
&
mut
Peekable
<
Chars
>
)
-
>
bool
{
while
iter
.
peek
(
)
.
map_or
(
false
|
c
:
&
char
|
c
.
is_ascii_whitespace
(
)
)
{
iter
.
next
(
)
;
}
iter
.
peek
(
)
.
is_some
(
)
}
#
[
inline
]
fn
skip_comma_wsp
(
iter
:
&
mut
Peekable
<
Chars
>
)
-
>
bool
{
if
!
skip_wsp
(
iter
)
{
return
false
;
}
if
*
iter
.
peek
(
)
.
unwrap
(
)
!
=
'
'
{
return
true
;
}
iter
.
next
(
)
;
skip_wsp
(
iter
)
}
