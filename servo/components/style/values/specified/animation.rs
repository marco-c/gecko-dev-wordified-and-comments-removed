use
crate
:
:
custom_properties
:
:
Name
as
CustomPropertyName
;
use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
properties
:
:
{
LonghandId
PropertyDeclarationId
PropertyId
ShorthandId
}
;
use
crate
:
:
values
:
:
generics
:
:
animation
as
generics
;
use
crate
:
:
values
:
:
specified
:
:
{
LengthPercentage
NonNegativeNumber
}
;
use
crate
:
:
values
:
:
{
CustomIdent
KeyframesName
TimelineName
}
;
use
crate
:
:
Atom
;
use
cssparser
:
:
Parser
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
KeywordsCollectFn
ParseError
SpecifiedValueInfo
StyleParseErrorKind
ToCss
}
;
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
PartialEq
ToComputedValue
ToResolvedValue
ToShmem
)
]
pub
enum
TransitionProperty
{
Shorthand
(
ShorthandId
)
Longhand
(
LonghandId
)
Custom
(
CustomPropertyName
)
Unsupported
(
CustomIdent
)
}
impl
ToCss
for
TransitionProperty
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
use
crate
:
:
values
:
:
serialize_atom_name
;
match
*
self
{
TransitionProperty
:
:
Shorthand
(
ref
s
)
=
>
s
.
to_css
(
dest
)
TransitionProperty
:
:
Longhand
(
ref
l
)
=
>
l
.
to_css
(
dest
)
TransitionProperty
:
:
Custom
(
ref
name
)
=
>
{
dest
.
write_str
(
"
-
-
"
)
?
;
serialize_atom_name
(
name
dest
)
}
TransitionProperty
:
:
Unsupported
(
ref
i
)
=
>
i
.
to_css
(
dest
)
}
}
}
impl
Parse
for
TransitionProperty
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
ident
=
input
.
expect_ident
(
)
?
;
let
id
=
match
PropertyId
:
:
parse_ignoring_rule_type
(
&
ident
context
)
{
Ok
(
id
)
=
>
id
Err
(
.
.
)
=
>
{
return
Ok
(
TransitionProperty
:
:
Unsupported
(
CustomIdent
:
:
from_ident
(
location
ident
&
[
"
none
"
]
)
?
)
)
;
}
}
;
Ok
(
match
id
.
as_shorthand
(
)
{
Ok
(
s
)
=
>
TransitionProperty
:
:
Shorthand
(
s
)
Err
(
longhand_or_custom
)
=
>
match
longhand_or_custom
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
TransitionProperty
:
:
Longhand
(
id
)
PropertyDeclarationId
:
:
Custom
(
custom
)
=
>
TransitionProperty
:
:
Custom
(
custom
.
clone
(
)
)
}
}
)
}
}
impl
SpecifiedValueInfo
for
TransitionProperty
{
fn
collect_completion_keywords
(
f
:
KeywordsCollectFn
)
{
f
(
&
[
"
all
"
]
)
;
}
}
impl
TransitionProperty
{
#
[
inline
]
pub
fn
all
(
)
-
>
Self
{
TransitionProperty
:
:
Shorthand
(
ShorthandId
:
:
All
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
to_nscsspropertyid
(
&
self
)
-
>
Result
<
crate
:
:
gecko_bindings
:
:
structs
:
:
nsCSSPropertyID
(
)
>
{
Ok
(
match
*
self
{
TransitionProperty
:
:
Shorthand
(
ShorthandId
:
:
All
)
=
>
{
crate
:
:
gecko_bindings
:
:
structs
:
:
nsCSSPropertyID
:
:
eCSSPropertyExtra_all_properties
}
TransitionProperty
:
:
Shorthand
(
ref
id
)
=
>
id
.
to_nscsspropertyid
(
)
TransitionProperty
:
:
Longhand
(
ref
id
)
=
>
id
.
to_nscsspropertyid
(
)
TransitionProperty
:
:
Custom
(
.
.
)
|
TransitionProperty
:
:
Unsupported
(
.
.
)
=
>
return
Err
(
(
)
)
}
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
Parse
SpecifiedValueInfo
ToCss
ToShmem
)
]
pub
enum
AnimationIterationCount
{
Number
(
NonNegativeNumber
)
Infinite
}
impl
AnimationIterationCount
{
#
[
inline
]
pub
fn
one
(
)
-
>
Self
{
Self
:
:
Number
(
NonNegativeNumber
:
:
new
(
1
.
0
)
)
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
value_info
(
other_values
=
"
none
"
)
]
#
[
repr
(
C
)
]
pub
struct
AnimationName
(
pub
KeyframesName
)
;
impl
AnimationName
{
pub
fn
as_atom
(
&
self
)
-
>
Option
<
&
Atom
>
{
if
self
.
is_none
(
)
{
return
None
;
}
Some
(
self
.
0
.
as_atom
(
)
)
}
pub
fn
none
(
)
-
>
Self
{
AnimationName
(
KeyframesName
:
:
none
(
)
)
}
pub
fn
is_none
(
&
self
)
-
>
bool
{
self
.
0
.
is_none
(
)
}
}
impl
Parse
for
AnimationName
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
name
)
=
input
.
try_parse
(
|
input
|
KeyframesName
:
:
parse
(
context
input
)
)
{
return
Ok
(
AnimationName
(
name
)
)
;
}
input
.
expect_ident_matching
(
"
none
"
)
?
;
Ok
(
AnimationName
(
KeyframesName
:
:
none
(
)
)
)
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
Scroller
{
Nearest
Root
#
[
css
(
keyword
=
"
self
"
)
]
SelfElement
}
impl
Scroller
{
#
[
inline
]
fn
is_default
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Self
:
:
Nearest
)
}
}
impl
Default
for
Scroller
{
fn
default
(
)
-
>
Self
{
Self
:
:
Nearest
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ScrollAxis
{
Block
=
0
Inline
=
1
Vertical
=
2
Horizontal
=
3
}
impl
ScrollAxis
{
#
[
inline
]
pub
fn
is_default
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Self
:
:
Block
)
}
}
impl
Default
for
ScrollAxis
{
fn
default
(
)
-
>
Self
{
Self
:
:
Block
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
css
(
function
=
"
scroll
"
)
]
#
[
repr
(
C
)
]
pub
struct
ScrollFunction
{
#
[
css
(
skip_if
=
"
Scroller
:
:
is_default
"
)
]
pub
scroller
:
Scroller
#
[
css
(
skip_if
=
"
ScrollAxis
:
:
is_default
"
)
]
pub
axis
:
ScrollAxis
}
impl
ScrollFunction
{
fn
parse_arguments
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
scroller
=
None
;
let
mut
axis
=
None
;
loop
{
if
scroller
.
is_none
(
)
{
scroller
=
input
.
try_parse
(
Scroller
:
:
parse
)
.
ok
(
)
;
}
if
axis
.
is_none
(
)
{
axis
=
input
.
try_parse
(
ScrollAxis
:
:
parse
)
.
ok
(
)
;
if
axis
.
is_some
(
)
{
continue
;
}
}
break
;
}
Ok
(
Self
{
scroller
:
scroller
.
unwrap_or_default
(
)
axis
:
axis
.
unwrap_or_default
(
)
}
)
}
}
impl
generics
:
:
ViewFunction
<
LengthPercentage
>
{
fn
parse_arguments
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
axis
=
None
;
let
mut
inset
=
None
;
loop
{
if
axis
.
is_none
(
)
{
axis
=
input
.
try_parse
(
ScrollAxis
:
:
parse
)
.
ok
(
)
;
}
if
inset
.
is_none
(
)
{
inset
=
input
.
try_parse
(
|
i
|
ViewTimelineInset
:
:
parse
(
context
i
)
)
.
ok
(
)
;
if
inset
.
is_some
(
)
{
continue
;
}
}
break
;
}
Ok
(
Self
{
inset
:
inset
.
unwrap_or_default
(
)
axis
:
axis
.
unwrap_or_default
(
)
}
)
}
}
pub
type
AnimationTimeline
=
generics
:
:
GenericAnimationTimeline
<
LengthPercentage
>
;
impl
Parse
for
AnimationTimeline
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
use
crate
:
:
values
:
:
generics
:
:
animation
:
:
ViewFunction
;
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
auto
"
)
)
.
is_ok
(
)
{
return
Ok
(
Self
:
:
Auto
)
;
}
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
none
"
)
)
.
is_ok
(
)
{
return
Ok
(
AnimationTimeline
:
:
Timeline
(
TimelineName
:
:
none
(
)
)
)
;
}
if
let
Ok
(
name
)
=
input
.
try_parse
(
|
i
|
TimelineName
:
:
parse
(
context
i
)
)
{
return
Ok
(
AnimationTimeline
:
:
Timeline
(
name
)
)
;
}
let
location
=
input
.
current_source_location
(
)
;
let
function
=
input
.
expect_function
(
)
?
.
clone
(
)
;
input
.
parse_nested_block
(
move
|
i
|
{
match_ignore_ascii_case
!
{
&
function
"
scroll
"
=
>
ScrollFunction
:
:
parse_arguments
(
i
)
.
map
(
Self
:
:
Scroll
)
"
view
"
=
>
ViewFunction
:
:
parse_arguments
(
context
i
)
.
map
(
Self
:
:
View
)
_
=
>
{
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnexpectedFunction
(
function
.
clone
(
)
)
)
)
}
}
}
)
}
}
pub
type
ScrollTimelineName
=
AnimationName
;
pub
type
ViewTimelineInset
=
generics
:
:
GenericViewTimelineInset
<
LengthPercentage
>
;
impl
Parse
for
ViewTimelineInset
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
use
crate
:
:
values
:
:
specified
:
:
LengthPercentageOrAuto
;
let
start
=
LengthPercentageOrAuto
:
:
parse
(
context
input
)
?
;
let
end
=
match
input
.
try_parse
(
|
input
|
LengthPercentageOrAuto
:
:
parse
(
context
input
)
)
{
Ok
(
end
)
=
>
end
Err
(
_
)
=
>
start
.
clone
(
)
}
;
Ok
(
Self
{
start
end
}
)
}
}
