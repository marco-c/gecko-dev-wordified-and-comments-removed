use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
values
:
:
computed
:
:
angle
:
:
Angle
as
ComputedAngle
;
use
crate
:
:
values
:
:
computed
:
:
{
Context
ToComputedValue
}
;
use
crate
:
:
values
:
:
specified
:
:
calc
:
:
CalcNode
;
use
crate
:
:
values
:
:
CSSFloat
;
use
crate
:
:
Zero
;
use
cssparser
:
:
{
Parser
Token
}
;
use
std
:
:
f32
:
:
consts
:
:
PI
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ParseError
SpecifiedValueInfo
ToCss
}
;
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
PartialOrd
ToCss
ToShmem
)
]
pub
enum
AngleDimension
{
#
[
css
(
dimension
)
]
Deg
(
CSSFloat
)
#
[
css
(
dimension
)
]
Grad
(
CSSFloat
)
#
[
css
(
dimension
)
]
Rad
(
CSSFloat
)
#
[
css
(
dimension
)
]
Turn
(
CSSFloat
)
}
impl
Zero
for
AngleDimension
{
fn
zero
(
)
-
>
Self
{
AngleDimension
:
:
Deg
(
0
.
)
}
fn
is_zero
(
&
self
)
-
>
bool
{
match
*
self
{
AngleDimension
:
:
Deg
(
ref
f
)
|
AngleDimension
:
:
Grad
(
ref
f
)
|
AngleDimension
:
:
Rad
(
ref
f
)
|
AngleDimension
:
:
Turn
(
ref
f
)
=
>
*
f
=
=
0
.
}
}
}
impl
AngleDimension
{
#
[
inline
]
fn
degrees
(
&
self
)
-
>
CSSFloat
{
const
DEG_PER_RAD
:
f32
=
180
.
0
/
PI
;
const
DEG_PER_TURN
:
f32
=
360
.
0
;
const
DEG_PER_GRAD
:
f32
=
180
.
0
/
200
.
0
;
match
*
self
{
AngleDimension
:
:
Deg
(
d
)
=
>
d
AngleDimension
:
:
Rad
(
rad
)
=
>
rad
*
DEG_PER_RAD
AngleDimension
:
:
Turn
(
turns
)
=
>
turns
*
DEG_PER_TURN
AngleDimension
:
:
Grad
(
gradians
)
=
>
gradians
*
DEG_PER_GRAD
}
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
pub
struct
Angle
{
value
:
AngleDimension
was_calc
:
bool
}
impl
Zero
for
Angle
{
fn
zero
(
)
-
>
Self
{
Self
{
value
:
Zero
:
:
zero
(
)
was_calc
:
false
}
}
fn
is_zero
(
&
self
)
-
>
bool
{
self
.
value
.
is_zero
(
)
}
}
impl
ToCss
for
Angle
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
self
.
was_calc
{
dest
.
write_str
(
"
calc
(
"
)
?
;
}
self
.
value
.
to_css
(
dest
)
?
;
if
self
.
was_calc
{
dest
.
write_str
(
"
)
"
)
?
;
}
Ok
(
(
)
)
}
}
impl
ToComputedValue
for
Angle
{
type
ComputedValue
=
ComputedAngle
;
#
[
inline
]
fn
to_computed_value
(
&
self
_context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
ComputedAngle
:
:
from_degrees
(
self
.
degrees
(
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
Angle
{
value
:
AngleDimension
:
:
Deg
(
computed
.
degrees
(
)
)
was_calc
:
false
}
}
}
impl
Angle
{
#
[
inline
]
pub
fn
from_degrees
(
value
:
CSSFloat
was_calc
:
bool
)
-
>
Self
{
Angle
{
value
:
AngleDimension
:
:
Deg
(
value
)
was_calc
}
}
pub
fn
zero
(
)
-
>
Self
{
Self
:
:
from_degrees
(
0
.
0
false
)
}
#
[
inline
]
pub
fn
degrees
(
&
self
)
-
>
CSSFloat
{
self
.
value
.
degrees
(
)
}
#
[
inline
]
pub
fn
was_calc
(
&
self
)
-
>
bool
{
self
.
was_calc
}
pub
fn
from_calc
(
degrees
:
CSSFloat
)
-
>
Self
{
Angle
{
value
:
AngleDimension
:
:
Deg
(
degrees
)
was_calc
:
true
}
}
}
enum
AllowUnitlessZeroAngle
{
Yes
No
}
impl
Parse
for
Angle
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
AllowUnitlessZeroAngle
:
:
No
)
}
}
impl
Angle
{
pub
fn
parse_dimension
(
value
:
CSSFloat
unit
:
&
str
was_calc
:
bool
)
-
>
Result
<
Angle
(
)
>
{
let
value
=
match_ignore_ascii_case
!
{
unit
"
deg
"
=
>
AngleDimension
:
:
Deg
(
value
)
"
grad
"
=
>
AngleDimension
:
:
Grad
(
value
)
"
turn
"
=
>
AngleDimension
:
:
Turn
(
value
)
"
rad
"
=
>
AngleDimension
:
:
Rad
(
value
)
_
=
>
return
Err
(
(
)
)
}
;
Ok
(
Self
{
value
was_calc
}
)
}
#
[
inline
]
pub
fn
parse_with_unitless
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
AllowUnitlessZeroAngle
:
:
Yes
)
}
fn
parse_internal
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_unitless_zero
:
AllowUnitlessZeroAngle
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
t
=
input
.
next
(
)
?
;
match
*
t
{
Token
:
:
Dimension
{
value
ref
unit
.
.
}
=
>
{
match
Angle
:
:
parse_dimension
(
value
unit
false
)
{
Ok
(
angle
)
=
>
Ok
(
angle
)
Err
(
(
)
)
=
>
{
let
t
=
t
.
clone
(
)
;
Err
(
input
.
new_unexpected_token_error
(
t
)
)
}
}
}
Token
:
:
Number
{
value
.
.
}
if
value
=
=
0
.
=
>
match
allow_unitless_zero
{
AllowUnitlessZeroAngle
:
:
Yes
=
>
Ok
(
Angle
:
:
zero
(
)
)
AllowUnitlessZeroAngle
:
:
No
=
>
{
let
t
=
t
.
clone
(
)
;
Err
(
input
.
new_unexpected_token_error
(
t
)
)
}
}
Token
:
:
Function
(
ref
name
)
if
name
.
eq_ignore_ascii_case
(
"
calc
"
)
=
>
{
return
input
.
parse_nested_block
(
|
i
|
CalcNode
:
:
parse_angle
(
context
i
)
)
;
}
ref
t
=
>
{
let
t
=
t
.
clone
(
)
;
Err
(
input
.
new_unexpected_token_error
(
t
)
)
}
}
}
}
impl
SpecifiedValueInfo
for
Angle
{
}
