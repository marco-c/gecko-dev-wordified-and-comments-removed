use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
values
:
:
generics
:
:
ui
as
generics
;
use
crate
:
:
values
:
:
specified
:
:
color
:
:
Color
;
use
crate
:
:
values
:
:
specified
:
:
url
:
:
SpecifiedImageUrl
;
use
crate
:
:
values
:
:
specified
:
:
Number
;
use
cssparser
:
:
Parser
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
pub
type
Cursor
=
generics
:
:
Cursor
<
CursorImage
>
;
pub
type
CursorImage
=
generics
:
:
CursorImage
<
SpecifiedImageUrl
Number
>
;
impl
Parse
for
Cursor
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
images
=
vec
!
[
]
;
loop
{
match
input
.
try
(
|
input
|
CursorImage
:
:
parse
(
context
input
)
)
{
Ok
(
image
)
=
>
images
.
push
(
image
)
Err
(
_
)
=
>
break
}
input
.
expect_comma
(
)
?
;
}
Ok
(
Self
{
images
:
images
.
into_boxed_slice
(
)
keyword
:
CursorKind
:
:
parse
(
input
)
?
}
)
}
}
impl
Parse
for
CursorImage
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Ok
(
Self
{
url
:
SpecifiedImageUrl
:
:
parse
(
context
input
)
?
hotspot
:
match
input
.
try
(
|
input
|
Number
:
:
parse
(
context
input
)
)
{
Ok
(
number
)
=
>
Some
(
(
number
Number
:
:
parse
(
context
input
)
?
)
)
Err
(
_
)
=
>
None
}
}
)
}
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
)
]
pub
struct
MozForceBrokenImageIcon
(
pub
bool
)
;
impl
MozForceBrokenImageIcon
{
#
[
inline
]
pub
fn
false_value
(
)
-
>
MozForceBrokenImageIcon
{
MozForceBrokenImageIcon
(
false
)
}
}
impl
Parse
for
MozForceBrokenImageIcon
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
MozForceBrokenImageIcon
ParseError
<
'
i
>
>
{
match
input
.
expect_integer
(
)
?
{
0
=
>
Ok
(
MozForceBrokenImageIcon
(
false
)
)
1
=
>
Ok
(
MozForceBrokenImageIcon
(
true
)
)
_
=
>
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
}
impl
ToCss
for
MozForceBrokenImageIcon
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
dest
.
write_str
(
if
self
.
0
{
"
1
"
}
else
{
"
0
"
}
)
}
}
impl
From
<
u8
>
for
MozForceBrokenImageIcon
{
fn
from
(
bits
:
u8
)
-
>
MozForceBrokenImageIcon
{
MozForceBrokenImageIcon
(
bits
=
=
1
)
}
}
impl
From
<
MozForceBrokenImageIcon
>
for
u8
{
fn
from
(
v
:
MozForceBrokenImageIcon
)
-
>
u8
{
if
v
.
0
{
1
}
else
{
0
}
}
}
pub
type
ScrollbarColor
=
generics
:
:
ScrollbarColor
<
Color
>
;
impl
Parse
for
ScrollbarColor
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
auto
"
)
)
.
is_ok
(
)
{
return
Ok
(
generics
:
:
ScrollbarColor
:
:
Auto
)
;
}
Ok
(
generics
:
:
ScrollbarColor
:
:
Colors
{
thumb
:
Color
:
:
parse
(
context
input
)
?
track
:
Color
:
:
parse
(
context
input
)
?
}
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
#
[
repr
(
u8
)
]
pub
enum
UserSelect
{
Auto
Text
#
[
parse
(
aliases
=
"
-
moz
-
none
"
)
]
None
All
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
FromPrimitive
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
#
[
repr
(
u8
)
]
pub
enum
CursorKind
{
None
Default
Pointer
ContextMenu
Help
Progress
Wait
Cell
Crosshair
Text
VerticalText
Alias
Copy
Move
NoDrop
NotAllowed
Grab
Grabbing
EResize
NResize
NeResize
NwResize
SResize
SeResize
SwResize
WResize
EwResize
NsResize
NeswResize
NwseResize
ColResize
RowResize
AllScroll
ZoomIn
ZoomOut
Auto
#
[
cfg
(
feature
=
"
gecko
"
)
]
MozGrab
#
[
cfg
(
feature
=
"
gecko
"
)
]
MozGrabbing
#
[
cfg
(
feature
=
"
gecko
"
)
]
MozZoomIn
#
[
cfg
(
feature
=
"
gecko
"
)
]
MozZoomOut
}
