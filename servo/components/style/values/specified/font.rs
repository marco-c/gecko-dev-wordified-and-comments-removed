#
[
cfg
(
feature
=
"
gecko
"
)
]
use
Atom
;
use
app_units
:
:
Au
;
use
cssparser
:
:
Parser
;
use
properties
:
:
longhands
:
:
system_font
:
:
SystemFont
;
use
std
:
:
fmt
;
use
style_traits
:
:
{
ToCss
ParseError
}
;
use
values
:
:
computed
:
:
{
font
as
computed
Context
NonNegativeLength
ToComputedValue
}
;
use
values
:
:
specified
:
:
{
LengthOrPercentage
NoCalcLength
}
;
use
values
:
:
specified
:
:
length
:
:
FontBaseSize
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
pub
enum
FontSize
{
Length
(
LengthOrPercentage
)
Keyword
(
computed
:
:
KeywordInfo
)
Smaller
Larger
System
(
SystemFont
)
}
impl
ToCss
for
FontSize
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
FontSize
:
:
Length
(
ref
lop
)
=
>
lop
.
to_css
(
dest
)
FontSize
:
:
Keyword
(
info
)
=
>
info
.
kw
.
to_css
(
dest
)
FontSize
:
:
Smaller
=
>
dest
.
write_str
(
"
smaller
"
)
FontSize
:
:
Larger
=
>
dest
.
write_str
(
"
larger
"
)
FontSize
:
:
System
(
sys
)
=
>
sys
.
to_css
(
dest
)
}
}
}
impl
From
<
LengthOrPercentage
>
for
FontSize
{
fn
from
(
other
:
LengthOrPercentage
)
-
>
Self
{
FontSize
:
:
Length
(
other
)
}
}
#
[
derive
(
Animate
ComputeSquaredDistance
ToAnimatedValue
ToAnimatedZero
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
KeywordSize
{
XXSmall
=
1
XSmall
Small
Medium
Large
XLarge
XXLarge
XXXLarge
}
impl
KeywordSize
{
pub
fn
parse
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
try_match_ident_ignore_ascii_case
!
{
input
.
expect_ident
(
)
?
"
xx
-
small
"
=
>
Ok
(
KeywordSize
:
:
XXSmall
)
"
x
-
small
"
=
>
Ok
(
KeywordSize
:
:
XSmall
)
"
small
"
=
>
Ok
(
KeywordSize
:
:
Small
)
"
medium
"
=
>
Ok
(
KeywordSize
:
:
Medium
)
"
large
"
=
>
Ok
(
KeywordSize
:
:
Large
)
"
x
-
large
"
=
>
Ok
(
KeywordSize
:
:
XLarge
)
"
xx
-
large
"
=
>
Ok
(
KeywordSize
:
:
XXLarge
)
}
}
pub
fn
html_size
(
&
self
)
-
>
u8
{
match
*
self
{
KeywordSize
:
:
XXSmall
=
>
0
KeywordSize
:
:
XSmall
=
>
1
KeywordSize
:
:
Small
=
>
2
KeywordSize
:
:
Medium
=
>
3
KeywordSize
:
:
Large
=
>
4
KeywordSize
:
:
XLarge
=
>
5
KeywordSize
:
:
XXLarge
=
>
6
KeywordSize
:
:
XXXLarge
=
>
7
}
}
}
impl
Default
for
KeywordSize
{
fn
default
(
)
-
>
Self
{
KeywordSize
:
:
Medium
}
}
impl
ToCss
for
KeywordSize
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_str
(
match
*
self
{
KeywordSize
:
:
XXSmall
=
>
"
xx
-
small
"
KeywordSize
:
:
XSmall
=
>
"
x
-
small
"
KeywordSize
:
:
Small
=
>
"
small
"
KeywordSize
:
:
Medium
=
>
"
medium
"
KeywordSize
:
:
Large
=
>
"
large
"
KeywordSize
:
:
XLarge
=
>
"
x
-
large
"
KeywordSize
:
:
XXLarge
=
>
"
xx
-
large
"
KeywordSize
:
:
XXXLarge
=
>
unreachable
!
(
"
We
should
never
serialize
\
specified
values
set
via
HTML
presentation
attributes
"
)
}
)
}
}
const
LARGER_FONT_SIZE_RATIO
:
f32
=
1
.
2
;
pub
const
FONT_MEDIUM_PX
:
i32
=
16
;
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
ToComputedValue
for
KeywordSize
{
type
ComputedValue
=
NonNegativeLength
;
#
[
inline
]
fn
to_computed_value
(
&
self
_
:
&
Context
)
-
>
NonNegativeLength
{
match
*
self
{
KeywordSize
:
:
XXSmall
=
>
Au
:
:
from_px
(
FONT_MEDIUM_PX
)
*
3
/
5
KeywordSize
:
:
XSmall
=
>
Au
:
:
from_px
(
FONT_MEDIUM_PX
)
*
3
/
4
KeywordSize
:
:
Small
=
>
Au
:
:
from_px
(
FONT_MEDIUM_PX
)
*
8
/
9
KeywordSize
:
:
Medium
=
>
Au
:
:
from_px
(
FONT_MEDIUM_PX
)
KeywordSize
:
:
Large
=
>
Au
:
:
from_px
(
FONT_MEDIUM_PX
)
*
6
/
5
KeywordSize
:
:
XLarge
=
>
Au
:
:
from_px
(
FONT_MEDIUM_PX
)
*
3
/
2
KeywordSize
:
:
XXLarge
=
>
Au
:
:
from_px
(
FONT_MEDIUM_PX
)
*
2
KeywordSize
:
:
XXXLarge
=
>
Au
:
:
from_px
(
FONT_MEDIUM_PX
)
*
3
}
.
into
(
)
}
#
[
inline
]
fn
from_computed_value
(
_
:
&
NonNegativeLength
)
-
>
Self
{
unreachable
!
(
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ToComputedValue
for
KeywordSize
{
type
ComputedValue
=
NonNegativeLength
;
#
[
inline
]
fn
to_computed_value
(
&
self
cx
:
&
Context
)
-
>
NonNegativeLength
{
use
gecko_bindings
:
:
structs
:
:
nsIAtom
;
use
values
:
:
specified
:
:
length
:
:
au_to_int_px
;
static
FONT_SIZE_MAPPING
:
[
[
i32
;
8
]
;
8
]
=
[
[
9
9
9
9
11
14
18
27
]
[
9
9
9
10
12
15
20
30
]
[
9
9
10
11
13
17
22
33
]
[
9
9
10
12
14
18
24
36
]
[
9
10
12
13
16
20
26
39
]
[
9
10
12
14
17
21
28
42
]
[
9
10
13
15
18
23
30
45
]
[
9
10
13
16
18
24
32
48
]
]
;
static
FONT_SIZE_FACTORS
:
[
i32
;
8
]
=
[
60
75
89
100
120
150
200
300
]
;
let
ref
gecko_font
=
cx
.
style
(
)
.
get_font
(
)
.
gecko
(
)
;
let
base_size
=
unsafe
{
Atom
:
:
with
(
gecko_font
.
mLanguage
.
raw
:
:
<
nsIAtom
>
(
)
|
atom
|
{
cx
.
font_metrics_provider
.
get_size
(
atom
gecko_font
.
mGenericID
)
.
0
}
)
}
;
let
base_size_px
=
au_to_int_px
(
base_size
as
f32
)
;
let
html_size
=
self
.
html_size
(
)
as
usize
;
if
base_size_px
>
=
9
&
&
base_size_px
<
=
16
{
Au
:
:
from_px
(
FONT_SIZE_MAPPING
[
(
base_size_px
-
9
)
as
usize
]
[
html_size
]
)
.
into
(
)
}
else
{
Au
(
FONT_SIZE_FACTORS
[
html_size
]
*
base_size
/
100
)
.
into
(
)
}
}
#
[
inline
]
fn
from_computed_value
(
_
:
&
NonNegativeLength
)
-
>
Self
{
unreachable
!
(
)
}
}
impl
FontSize
{
pub
fn
from_html_size
(
size
:
u8
)
-
>
Self
{
FontSize
:
:
Keyword
(
match
size
{
0
|
1
=
>
KeywordSize
:
:
XSmall
2
=
>
KeywordSize
:
:
Small
3
=
>
KeywordSize
:
:
Medium
4
=
>
KeywordSize
:
:
Large
5
=
>
KeywordSize
:
:
XLarge
6
=
>
KeywordSize
:
:
XXLarge
_
=
>
KeywordSize
:
:
XXXLarge
}
.
into
(
)
)
}
pub
fn
to_computed_value_against
(
&
self
context
:
&
Context
base_size
:
FontBaseSize
)
-
>
computed
:
:
FontSize
{
use
values
:
:
specified
:
:
length
:
:
FontRelativeLength
;
let
compose_keyword
=
|
factor
|
{
context
.
style
(
)
.
get_parent_font
(
)
.
clone_font_size
(
)
.
keyword_info
.
map
(
|
i
|
i
.
compose
(
factor
Au
(
0
)
.
into
(
)
)
)
}
;
let
mut
info
=
None
;
let
size
=
match
*
self
{
FontSize
:
:
Length
(
LengthOrPercentage
:
:
Length
(
NoCalcLength
:
:
FontRelative
(
value
)
)
)
=
>
{
if
let
FontRelativeLength
:
:
Em
(
em
)
=
value
{
info
=
compose_keyword
(
em
)
;
}
value
.
to_computed_value
(
context
base_size
)
.
into
(
)
}
FontSize
:
:
Length
(
LengthOrPercentage
:
:
Length
(
NoCalcLength
:
:
ServoCharacterWidth
(
value
)
)
)
=
>
{
value
.
to_computed_value
(
base_size
.
resolve
(
context
)
)
.
into
(
)
}
FontSize
:
:
Length
(
LengthOrPercentage
:
:
Length
(
NoCalcLength
:
:
Absolute
(
ref
l
)
)
)
=
>
{
context
.
maybe_zoom_text
(
l
.
to_computed_value
(
context
)
.
into
(
)
)
}
FontSize
:
:
Length
(
LengthOrPercentage
:
:
Length
(
ref
l
)
)
=
>
{
l
.
to_computed_value
(
context
)
.
into
(
)
}
FontSize
:
:
Length
(
LengthOrPercentage
:
:
Percentage
(
pc
)
)
=
>
{
info
=
compose_keyword
(
pc
.
0
)
;
base_size
.
resolve
(
context
)
.
scale_by
(
pc
.
0
)
.
into
(
)
}
FontSize
:
:
Length
(
LengthOrPercentage
:
:
Calc
(
ref
calc
)
)
=
>
{
let
parent
=
context
.
style
(
)
.
get_parent_font
(
)
.
clone_font_size
(
)
;
if
(
calc
.
em
.
is_some
(
)
|
|
calc
.
percentage
.
is_some
(
)
)
&
&
parent
.
keyword_info
.
is_some
(
)
{
let
ratio
=
calc
.
em
.
unwrap_or
(
0
.
)
+
calc
.
percentage
.
map_or
(
0
.
|
pc
|
pc
.
0
)
;
let
abs
=
calc
.
to_computed_value_zoomed
(
context
FontBaseSize
:
:
Custom
(
Au
(
0
)
.
into
(
)
)
)
.
length_component
(
)
.
into
(
)
;
info
=
parent
.
keyword_info
.
map
(
|
i
|
i
.
compose
(
ratio
abs
)
)
;
}
let
calc
=
calc
.
to_computed_value_zoomed
(
context
base_size
)
;
calc
.
to_used_value
(
Some
(
base_size
.
resolve
(
context
)
)
)
.
unwrap
(
)
.
into
(
)
}
FontSize
:
:
Keyword
(
i
)
=
>
{
info
=
Some
(
i
)
;
context
.
maybe_zoom_text
(
i
.
kw
.
to_computed_value
(
context
)
.
scale_by
(
i
.
factor
)
+
i
.
offset
)
}
FontSize
:
:
Smaller
=
>
{
info
=
compose_keyword
(
1
.
/
LARGER_FONT_SIZE_RATIO
)
;
FontRelativeLength
:
:
Em
(
1
.
/
LARGER_FONT_SIZE_RATIO
)
.
to_computed_value
(
context
base_size
)
.
into
(
)
}
FontSize
:
:
Larger
=
>
{
info
=
compose_keyword
(
LARGER_FONT_SIZE_RATIO
)
;
FontRelativeLength
:
:
Em
(
LARGER_FONT_SIZE_RATIO
)
.
to_computed_value
(
context
base_size
)
.
into
(
)
}
FontSize
:
:
System
(
_
)
=
>
{
#
[
cfg
(
feature
=
"
servo
"
)
]
{
unreachable
!
(
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
context
.
cached_system_font
.
as_ref
(
)
.
unwrap
(
)
.
font_size
.
size
}
}
}
;
computed
:
:
FontSize
{
size
:
size
keyword_info
:
info
}
}
}
impl
ToComputedValue
for
FontSize
{
type
ComputedValue
=
computed
:
:
FontSize
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
computed
:
:
FontSize
{
self
.
to_computed_value_against
(
context
FontBaseSize
:
:
InheritedStyle
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
computed
:
:
FontSize
)
-
>
Self
{
FontSize
:
:
Length
(
LengthOrPercentage
:
:
Length
(
ToComputedValue
:
:
from_computed_value
(
&
computed
.
size
.
0
)
)
)
}
}
impl
FontSize
{
pub
fn
system_font
(
f
:
SystemFont
)
-
>
Self
{
FontSize
:
:
System
(
f
)
}
pub
fn
get_system
(
&
self
)
-
>
Option
<
SystemFont
>
{
if
let
FontSize
:
:
System
(
s
)
=
*
self
{
Some
(
s
)
}
else
{
None
}
}
}
