use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
values
:
:
generics
:
:
CounterStyle
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
values
:
:
CustomIdent
;
use
cssparser
:
:
{
Parser
Token
}
;
use
style_traits
:
:
{
ParseError
StyleParseErrorKind
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
pub
enum
ListStyleType
{
None
CounterStyle
(
CounterStyle
)
String
(
String
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ListStyleType
{
#
[
inline
]
pub
fn
disc
(
)
-
>
Self
{
ListStyleType
:
:
CounterStyle
(
CounterStyle
:
:
disc
(
)
)
}
pub
fn
from_gecko_keyword
(
value
:
u32
)
-
>
Self
{
use
crate
:
:
gecko_bindings
:
:
structs
;
if
value
=
=
structs
:
:
NS_STYLE_LIST_STYLE_NONE
{
return
ListStyleType
:
:
None
;
}
ListStyleType
:
:
CounterStyle
(
CounterStyle
:
:
Name
(
CustomIdent
(
match
value
{
structs
:
:
NS_STYLE_LIST_STYLE_DISC
=
>
atom
!
(
"
disc
"
)
structs
:
:
NS_STYLE_LIST_STYLE_CIRCLE
=
>
atom
!
(
"
circle
"
)
structs
:
:
NS_STYLE_LIST_STYLE_SQUARE
=
>
atom
!
(
"
square
"
)
structs
:
:
NS_STYLE_LIST_STYLE_DECIMAL
=
>
atom
!
(
"
decimal
"
)
structs
:
:
NS_STYLE_LIST_STYLE_LOWER_ROMAN
=
>
atom
!
(
"
lower
-
roman
"
)
structs
:
:
NS_STYLE_LIST_STYLE_UPPER_ROMAN
=
>
atom
!
(
"
upper
-
roman
"
)
structs
:
:
NS_STYLE_LIST_STYLE_LOWER_ALPHA
=
>
atom
!
(
"
lower
-
alpha
"
)
structs
:
:
NS_STYLE_LIST_STYLE_UPPER_ALPHA
=
>
atom
!
(
"
upper
-
alpha
"
)
_
=
>
unreachable
!
(
"
Unknown
counter
style
keyword
value
"
)
}
)
)
)
}
#
[
inline
]
pub
fn
is_bullet
(
&
self
)
-
>
bool
{
match
self
{
ListStyleType
:
:
CounterStyle
(
ref
style
)
=
>
style
.
is_bullet
(
)
_
=
>
false
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
Parse
for
ListStyleType
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
style
)
=
input
.
try_parse
(
|
i
|
CounterStyle
:
:
parse
(
context
i
)
)
{
return
Ok
(
ListStyleType
:
:
CounterStyle
(
style
)
)
;
}
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
none
"
)
)
.
is_ok
(
)
{
return
Ok
(
ListStyleType
:
:
None
)
;
}
Ok
(
ListStyleType
:
:
String
(
input
.
expect_string
(
)
?
.
as_ref
(
)
.
to_owned
(
)
)
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
QuotePair
{
pub
opening
:
crate
:
:
OwnedStr
pub
closing
:
crate
:
:
OwnedStr
}
#
[
derive
(
Clone
Debug
Default
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
transparent
)
]
pub
struct
QuoteList
(
#
[
css
(
iterable
if_empty
=
"
none
"
)
]
#
[
ignore_malloc_size_of
=
"
Arc
"
]
pub
crate
:
:
ArcSlice
<
QuotePair
>
)
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
enum
Quotes
{
QuoteList
(
QuoteList
)
Auto
}
impl
Parse
for
Quotes
{
fn
parse
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Quotes
ParseError
<
'
i
>
>
{
if
input
.
try_parse
(
|
input
|
input
.
expect_ident_matching
(
"
auto
"
)
)
.
is_ok
(
)
{
return
Ok
(
Quotes
:
:
Auto
)
;
}
if
input
.
try_parse
(
|
input
|
input
.
expect_ident_matching
(
"
none
"
)
)
.
is_ok
(
)
{
return
Ok
(
Quotes
:
:
QuoteList
(
QuoteList
:
:
default
(
)
)
)
;
}
let
mut
quotes
=
Vec
:
:
new
(
)
;
loop
{
let
location
=
input
.
current_source_location
(
)
;
let
opening
=
match
input
.
next
(
)
{
Ok
(
&
Token
:
:
QuotedString
(
ref
value
)
)
=
>
value
.
as_ref
(
)
.
to_owned
(
)
.
into
(
)
Ok
(
t
)
=
>
return
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
Err
(
_
)
=
>
break
}
;
let
closing
=
input
.
expect_string
(
)
?
.
as_ref
(
)
.
to_owned
(
)
.
into
(
)
;
quotes
.
push
(
QuotePair
{
opening
closing
}
)
;
}
if
!
quotes
.
is_empty
(
)
{
Ok
(
Quotes
:
:
QuoteList
(
QuoteList
(
crate
:
:
ArcSlice
:
:
from_iter
(
quotes
.
into_iter
(
)
)
)
)
)
}
else
{
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
}
