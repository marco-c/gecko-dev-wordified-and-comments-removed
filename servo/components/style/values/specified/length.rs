use
app_units
:
:
Au
;
use
cssparser
:
:
{
Parser
Token
BasicParseError
}
;
use
euclid
:
:
Size2D
;
use
font_metrics
:
:
FontMetricsQueryResult
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
std
:
:
{
cmp
fmt
mem
}
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
ops
:
:
{
Add
Mul
}
;
use
style_traits
:
:
{
ToCss
ParseError
StyleParseError
}
;
use
style_traits
:
:
values
:
:
specified
:
:
AllowedNumericType
;
use
stylesheets
:
:
CssRuleType
;
use
super
:
:
{
AllowQuirks
Number
ToComputedValue
Percentage
}
;
use
values
:
:
{
Auto
CSSFloat
Either
None_
Normal
}
;
use
values
:
:
{
ExtremumLength
serialize_dimension
}
;
use
values
:
:
computed
:
:
{
self
CSSPixelLength
Context
}
;
use
values
:
:
generics
:
:
NonNegative
;
use
values
:
:
specified
:
:
NonNegativeNumber
;
use
values
:
:
specified
:
:
calc
:
:
CalcNode
;
pub
use
values
:
:
specified
:
:
calc
:
:
CalcLengthOrPercentage
;
pub
use
super
:
:
image
:
:
{
ColorStop
EndingShape
as
GradientEndingShape
Gradient
}
;
pub
use
super
:
:
image
:
:
{
GradientKind
Image
}
;
pub
const
AU_PER_PX
:
CSSFloat
=
60
.
;
pub
const
AU_PER_IN
:
CSSFloat
=
AU_PER_PX
*
96
.
;
pub
const
AU_PER_CM
:
CSSFloat
=
AU_PER_IN
/
2
.
54
;
pub
const
AU_PER_MM
:
CSSFloat
=
AU_PER_IN
/
25
.
4
;
pub
const
AU_PER_Q
:
CSSFloat
=
AU_PER_MM
/
4
.
;
pub
const
AU_PER_PT
:
CSSFloat
=
AU_PER_IN
/
72
.
;
pub
const
AU_PER_PC
:
CSSFloat
=
AU_PER_PT
*
12
.
;
pub
fn
au_to_int_px
(
au
:
f32
)
-
>
i32
{
(
au
/
AU_PER_PX
)
.
round
(
)
as
i32
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
FontRelativeLength
{
Em
(
CSSFloat
)
Ex
(
CSSFloat
)
Ch
(
CSSFloat
)
Rem
(
CSSFloat
)
}
impl
ToCss
for
FontRelativeLength
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
FontRelativeLength
:
:
Em
(
length
)
=
>
serialize_dimension
(
length
"
em
"
dest
)
FontRelativeLength
:
:
Ex
(
length
)
=
>
serialize_dimension
(
length
"
ex
"
dest
)
FontRelativeLength
:
:
Ch
(
length
)
=
>
serialize_dimension
(
length
"
ch
"
dest
)
FontRelativeLength
:
:
Rem
(
length
)
=
>
serialize_dimension
(
length
"
rem
"
dest
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
FontBaseSize
{
CurrentStyle
InheritedStyle
Custom
(
Au
)
}
impl
FontBaseSize
{
pub
fn
resolve
(
&
self
context
:
&
Context
)
-
>
Au
{
match
*
self
{
FontBaseSize
:
:
Custom
(
size
)
=
>
size
FontBaseSize
:
:
CurrentStyle
=
>
context
.
style
(
)
.
get_font
(
)
.
clone_font_size
(
)
.
size
(
)
FontBaseSize
:
:
InheritedStyle
=
>
context
.
style
(
)
.
get_parent_font
(
)
.
clone_font_size
(
)
.
size
(
)
}
}
}
impl
FontRelativeLength
{
pub
fn
to_computed_value
(
&
self
context
:
&
Context
base_size
:
FontBaseSize
)
-
>
CSSPixelLength
{
use
std
:
:
f32
;
let
(
reference_size
length
)
=
self
.
reference_font_size_and_length
(
context
base_size
)
;
let
pixel
=
(
length
*
reference_size
.
to_f32_px
(
)
)
.
min
(
f32
:
:
MAX
)
.
max
(
f32
:
:
MIN
)
;
CSSPixelLength
:
:
new
(
pixel
)
}
fn
reference_font_size_and_length
(
&
self
context
:
&
Context
base_size
:
FontBaseSize
)
-
>
(
Au
CSSFloat
)
{
fn
query_font_metrics
(
context
:
&
Context
reference_font_size
:
Au
)
-
>
FontMetricsQueryResult
{
context
.
font_metrics_provider
.
query
(
context
.
style
(
)
.
get_font
(
)
reference_font_size
context
.
style
(
)
.
writing_mode
context
.
in_media_query
context
.
device
(
)
)
}
let
reference_font_size
=
base_size
.
resolve
(
context
)
;
match
*
self
{
FontRelativeLength
:
:
Em
(
length
)
=
>
{
if
context
.
for_non_inherited_property
.
is_some
(
)
{
if
matches
!
(
base_size
FontBaseSize
:
:
CurrentStyle
)
{
context
.
rule_cache_conditions
.
borrow_mut
(
)
.
set_font_size_dependency
(
reference_font_size
.
into
(
)
)
;
}
}
(
reference_font_size
length
)
}
FontRelativeLength
:
:
Ex
(
length
)
=
>
{
if
context
.
for_non_inherited_property
.
is_some
(
)
{
context
.
rule_cache_conditions
.
borrow_mut
(
)
.
set_uncacheable
(
)
;
}
let
reference_size
=
match
query_font_metrics
(
context
reference_font_size
)
{
FontMetricsQueryResult
:
:
Available
(
metrics
)
=
>
{
metrics
.
x_height
}
FontMetricsQueryResult
:
:
NotAvailable
=
>
{
reference_font_size
.
scale_by
(
0
.
5
)
}
}
;
(
reference_size
length
)
}
FontRelativeLength
:
:
Ch
(
length
)
=
>
{
if
context
.
for_non_inherited_property
.
is_some
(
)
{
context
.
rule_cache_conditions
.
borrow_mut
(
)
.
set_uncacheable
(
)
;
}
let
reference_size
=
match
query_font_metrics
(
context
reference_font_size
)
{
FontMetricsQueryResult
:
:
Available
(
metrics
)
=
>
{
metrics
.
zero_advance_measure
}
FontMetricsQueryResult
:
:
NotAvailable
=
>
{
if
context
.
style
(
)
.
writing_mode
.
is_vertical
(
)
{
reference_font_size
}
else
{
reference_font_size
.
scale_by
(
0
.
5
)
}
}
}
;
(
reference_size
length
)
}
FontRelativeLength
:
:
Rem
(
length
)
=
>
{
let
reference_size
=
if
context
.
is_root_element
{
reference_font_size
}
else
{
context
.
device
(
)
.
root_font_size
(
)
}
;
(
reference_size
length
)
}
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
ViewportPercentageLength
{
Vw
(
CSSFloat
)
Vh
(
CSSFloat
)
Vmin
(
CSSFloat
)
Vmax
(
CSSFloat
)
}
impl
ToCss
for
ViewportPercentageLength
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
ViewportPercentageLength
:
:
Vw
(
length
)
=
>
serialize_dimension
(
length
"
vw
"
dest
)
ViewportPercentageLength
:
:
Vh
(
length
)
=
>
serialize_dimension
(
length
"
vh
"
dest
)
ViewportPercentageLength
:
:
Vmin
(
length
)
=
>
serialize_dimension
(
length
"
vmin
"
dest
)
ViewportPercentageLength
:
:
Vmax
(
length
)
=
>
serialize_dimension
(
length
"
vmax
"
dest
)
}
}
}
impl
ViewportPercentageLength
{
pub
fn
to_computed_value
(
&
self
viewport_size
:
Size2D
<
Au
>
)
-
>
CSSPixelLength
{
let
(
factor
length
)
=
match
*
self
{
ViewportPercentageLength
:
:
Vw
(
length
)
=
>
(
length
viewport_size
.
width
)
ViewportPercentageLength
:
:
Vh
(
length
)
=
>
(
length
viewport_size
.
height
)
ViewportPercentageLength
:
:
Vmin
(
length
)
=
>
(
length
cmp
:
:
min
(
viewport_size
.
width
viewport_size
.
height
)
)
ViewportPercentageLength
:
:
Vmax
(
length
)
=
>
(
length
cmp
:
:
max
(
viewport_size
.
width
viewport_size
.
height
)
)
}
;
let
trunc_scaled
=
(
(
length
.
0
as
f64
)
*
factor
as
f64
/
100
.
)
.
trunc
(
)
;
Au
:
:
from_f64_au
(
trunc_scaled
)
.
into
(
)
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
CharacterWidth
(
pub
i32
)
;
impl
CharacterWidth
{
pub
fn
to_computed_value
(
&
self
reference_font_size
:
Au
)
-
>
CSSPixelLength
{
let
average_advance
=
reference_font_size
.
scale_by
(
0
.
5
)
;
let
max_advance
=
reference_font_size
;
let
au
=
average_advance
.
scale_by
(
self
.
0
as
CSSFloat
-
1
.
0
)
+
max_advance
;
au
.
into
(
)
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
AbsoluteLength
{
Px
(
CSSFloat
)
In
(
CSSFloat
)
Cm
(
CSSFloat
)
Mm
(
CSSFloat
)
Q
(
CSSFloat
)
Pt
(
CSSFloat
)
Pc
(
CSSFloat
)
}
impl
AbsoluteLength
{
fn
is_zero
(
&
self
)
-
>
bool
{
match
*
self
{
AbsoluteLength
:
:
Px
(
v
)
|
AbsoluteLength
:
:
In
(
v
)
|
AbsoluteLength
:
:
Cm
(
v
)
|
AbsoluteLength
:
:
Mm
(
v
)
|
AbsoluteLength
:
:
Q
(
v
)
|
AbsoluteLength
:
:
Pt
(
v
)
|
AbsoluteLength
:
:
Pc
(
v
)
=
>
v
=
=
0
.
}
}
#
[
inline
]
pub
fn
to_px
(
&
self
)
-
>
CSSFloat
{
use
std
:
:
f32
;
let
pixel
=
match
*
self
{
AbsoluteLength
:
:
Px
(
value
)
=
>
value
AbsoluteLength
:
:
In
(
value
)
=
>
value
*
(
AU_PER_IN
/
AU_PER_PX
)
AbsoluteLength
:
:
Cm
(
value
)
=
>
value
*
(
AU_PER_CM
/
AU_PER_PX
)
AbsoluteLength
:
:
Mm
(
value
)
=
>
value
*
(
AU_PER_MM
/
AU_PER_PX
)
AbsoluteLength
:
:
Q
(
value
)
=
>
value
*
(
AU_PER_Q
/
AU_PER_PX
)
AbsoluteLength
:
:
Pt
(
value
)
=
>
value
*
(
AU_PER_PT
/
AU_PER_PX
)
AbsoluteLength
:
:
Pc
(
value
)
=
>
value
*
(
AU_PER_PC
/
AU_PER_PX
)
}
;
pixel
.
min
(
f32
:
:
MAX
)
.
max
(
f32
:
:
MIN
)
}
}
impl
ToComputedValue
for
AbsoluteLength
{
type
ComputedValue
=
CSSPixelLength
;
fn
to_computed_value
(
&
self
_
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
CSSPixelLength
:
:
new
(
self
.
to_px
(
)
)
}
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
AbsoluteLength
:
:
Px
(
computed
.
px
(
)
)
}
}
impl
ToCss
for
AbsoluteLength
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
AbsoluteLength
:
:
Px
(
length
)
=
>
serialize_dimension
(
length
"
px
"
dest
)
AbsoluteLength
:
:
In
(
length
)
=
>
serialize_dimension
(
length
"
in
"
dest
)
AbsoluteLength
:
:
Cm
(
length
)
=
>
serialize_dimension
(
length
"
cm
"
dest
)
AbsoluteLength
:
:
Mm
(
length
)
=
>
serialize_dimension
(
length
"
mm
"
dest
)
AbsoluteLength
:
:
Q
(
length
)
=
>
serialize_dimension
(
length
"
q
"
dest
)
AbsoluteLength
:
:
Pt
(
length
)
=
>
serialize_dimension
(
length
"
pt
"
dest
)
AbsoluteLength
:
:
Pc
(
length
)
=
>
serialize_dimension
(
length
"
pc
"
dest
)
}
}
}
impl
Mul
<
CSSFloat
>
for
AbsoluteLength
{
type
Output
=
AbsoluteLength
;
#
[
inline
]
fn
mul
(
self
scalar
:
CSSFloat
)
-
>
AbsoluteLength
{
match
self
{
AbsoluteLength
:
:
Px
(
v
)
=
>
AbsoluteLength
:
:
Px
(
v
*
scalar
)
AbsoluteLength
:
:
In
(
v
)
=
>
AbsoluteLength
:
:
In
(
v
*
scalar
)
AbsoluteLength
:
:
Cm
(
v
)
=
>
AbsoluteLength
:
:
Cm
(
v
*
scalar
)
AbsoluteLength
:
:
Mm
(
v
)
=
>
AbsoluteLength
:
:
Mm
(
v
*
scalar
)
AbsoluteLength
:
:
Q
(
v
)
=
>
AbsoluteLength
:
:
Q
(
v
*
scalar
)
AbsoluteLength
:
:
Pt
(
v
)
=
>
AbsoluteLength
:
:
Pt
(
v
*
scalar
)
AbsoluteLength
:
:
Pc
(
v
)
=
>
AbsoluteLength
:
:
Pc
(
v
*
scalar
)
}
}
}
impl
Add
<
AbsoluteLength
>
for
AbsoluteLength
{
type
Output
=
Self
;
#
[
inline
]
fn
add
(
self
rhs
:
Self
)
-
>
Self
{
match
(
self
rhs
)
{
(
AbsoluteLength
:
:
Px
(
x
)
AbsoluteLength
:
:
Px
(
y
)
)
=
>
AbsoluteLength
:
:
Px
(
x
+
y
)
(
AbsoluteLength
:
:
In
(
x
)
AbsoluteLength
:
:
In
(
y
)
)
=
>
AbsoluteLength
:
:
In
(
x
+
y
)
(
AbsoluteLength
:
:
Cm
(
x
)
AbsoluteLength
:
:
Cm
(
y
)
)
=
>
AbsoluteLength
:
:
Cm
(
x
+
y
)
(
AbsoluteLength
:
:
Mm
(
x
)
AbsoluteLength
:
:
Mm
(
y
)
)
=
>
AbsoluteLength
:
:
Mm
(
x
+
y
)
(
AbsoluteLength
:
:
Q
(
x
)
AbsoluteLength
:
:
Q
(
y
)
)
=
>
AbsoluteLength
:
:
Q
(
x
+
y
)
(
AbsoluteLength
:
:
Pt
(
x
)
AbsoluteLength
:
:
Pt
(
y
)
)
=
>
AbsoluteLength
:
:
Pt
(
x
+
y
)
(
AbsoluteLength
:
:
Pc
(
x
)
AbsoluteLength
:
:
Pc
(
y
)
)
=
>
AbsoluteLength
:
:
Pc
(
x
+
y
)
_
=
>
AbsoluteLength
:
:
Px
(
self
.
to_px
(
)
+
rhs
.
to_px
(
)
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
PhysicalLength
(
pub
CSSFloat
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
PhysicalLength
{
fn
is_zero
(
&
self
)
-
>
bool
{
self
.
0
=
=
0
.
}
pub
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
CSSPixelLength
{
use
gecko_bindings
:
:
bindings
;
use
std
:
:
f32
;
const
INCH_PER_MM
:
f32
=
1
.
/
25
.
4
;
let
au_per_physical_inch
=
unsafe
{
bindings
:
:
Gecko_GetAppUnitsPerPhysicalInch
(
context
.
device
(
)
.
pres_context
(
)
)
as
f32
}
;
let
px_per_physical_inch
=
au_per_physical_inch
/
AU_PER_PX
;
let
pixel
=
self
.
0
*
px_per_physical_inch
*
INCH_PER_MM
;
CSSPixelLength
:
:
new
(
pixel
.
min
(
f32
:
:
MAX
)
.
max
(
f32
:
:
MIN
)
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ToCss
for
PhysicalLength
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
serialize_dimension
(
self
.
0
"
mozmm
"
dest
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
Mul
<
CSSFloat
>
for
PhysicalLength
{
type
Output
=
PhysicalLength
;
#
[
inline
]
fn
mul
(
self
scalar
:
CSSFloat
)
-
>
PhysicalLength
{
PhysicalLength
(
self
.
0
*
scalar
)
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
NoCalcLength
{
Absolute
(
AbsoluteLength
)
FontRelative
(
FontRelativeLength
)
ViewportPercentage
(
ViewportPercentageLength
)
ServoCharacterWidth
(
CharacterWidth
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Physical
(
PhysicalLength
)
}
impl
ToCss
for
NoCalcLength
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
NoCalcLength
:
:
Absolute
(
length
)
=
>
length
.
to_css
(
dest
)
NoCalcLength
:
:
FontRelative
(
length
)
=
>
length
.
to_css
(
dest
)
NoCalcLength
:
:
ViewportPercentage
(
length
)
=
>
length
.
to_css
(
dest
)
NoCalcLength
:
:
ServoCharacterWidth
(
CharacterWidth
(
i
)
)
=
>
{
dest
.
write_str
(
"
CharWidth
(
"
)
?
;
i
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
)
'
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
NoCalcLength
:
:
Physical
(
length
)
=
>
length
.
to_css
(
dest
)
}
}
}
impl
Mul
<
CSSFloat
>
for
NoCalcLength
{
type
Output
=
NoCalcLength
;
#
[
inline
]
fn
mul
(
self
scalar
:
CSSFloat
)
-
>
NoCalcLength
{
match
self
{
NoCalcLength
:
:
Absolute
(
v
)
=
>
NoCalcLength
:
:
Absolute
(
v
*
scalar
)
NoCalcLength
:
:
FontRelative
(
v
)
=
>
NoCalcLength
:
:
FontRelative
(
v
*
scalar
)
NoCalcLength
:
:
ViewportPercentage
(
v
)
=
>
NoCalcLength
:
:
ViewportPercentage
(
v
*
scalar
)
NoCalcLength
:
:
ServoCharacterWidth
(
_
)
=
>
panic
!
(
"
Can
'
t
multiply
ServoCharacterWidth
!
"
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
NoCalcLength
:
:
Physical
(
v
)
=
>
NoCalcLength
:
:
Physical
(
v
*
scalar
)
}
}
}
impl
NoCalcLength
{
pub
fn
parse_dimension
(
context
:
&
ParserContext
value
:
CSSFloat
unit
:
&
str
)
-
>
Result
<
NoCalcLength
(
)
>
{
let
in_page_rule
=
context
.
rule_type
.
map_or
(
false
|
rule_type
|
rule_type
=
=
CssRuleType
:
:
Page
)
;
match_ignore_ascii_case
!
{
unit
"
px
"
=
>
Ok
(
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Px
(
value
)
)
)
"
in
"
=
>
Ok
(
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
In
(
value
)
)
)
"
cm
"
=
>
Ok
(
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Cm
(
value
)
)
)
"
mm
"
=
>
Ok
(
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Mm
(
value
)
)
)
"
q
"
=
>
Ok
(
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Q
(
value
)
)
)
"
pt
"
=
>
Ok
(
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Pt
(
value
)
)
)
"
pc
"
=
>
Ok
(
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Pc
(
value
)
)
)
/
/
font
-
relative
"
em
"
=
>
Ok
(
NoCalcLength
:
:
FontRelative
(
FontRelativeLength
:
:
Em
(
value
)
)
)
"
ex
"
=
>
Ok
(
NoCalcLength
:
:
FontRelative
(
FontRelativeLength
:
:
Ex
(
value
)
)
)
"
ch
"
=
>
Ok
(
NoCalcLength
:
:
FontRelative
(
FontRelativeLength
:
:
Ch
(
value
)
)
)
"
rem
"
=
>
Ok
(
NoCalcLength
:
:
FontRelative
(
FontRelativeLength
:
:
Rem
(
value
)
)
)
/
/
viewport
percentages
"
vw
"
=
>
{
if
in_page_rule
{
return
Err
(
(
)
)
}
Ok
(
NoCalcLength
:
:
ViewportPercentage
(
ViewportPercentageLength
:
:
Vw
(
value
)
)
)
}
"
vh
"
=
>
{
if
in_page_rule
{
return
Err
(
(
)
)
}
Ok
(
NoCalcLength
:
:
ViewportPercentage
(
ViewportPercentageLength
:
:
Vh
(
value
)
)
)
}
"
vmin
"
=
>
{
if
in_page_rule
{
return
Err
(
(
)
)
}
Ok
(
NoCalcLength
:
:
ViewportPercentage
(
ViewportPercentageLength
:
:
Vmin
(
value
)
)
)
}
"
vmax
"
=
>
{
if
in_page_rule
{
return
Err
(
(
)
)
}
Ok
(
NoCalcLength
:
:
ViewportPercentage
(
ViewportPercentageLength
:
:
Vmax
(
value
)
)
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
"
mozmm
"
=
>
Ok
(
NoCalcLength
:
:
Physical
(
PhysicalLength
(
value
)
)
)
_
=
>
Err
(
(
)
)
}
}
#
[
inline
]
pub
fn
zero
(
)
-
>
NoCalcLength
{
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Px
(
0
.
)
)
}
#
[
inline
]
pub
fn
is_zero
(
&
self
)
-
>
bool
{
match
*
self
{
NoCalcLength
:
:
Absolute
(
length
)
=
>
length
.
is_zero
(
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
NoCalcLength
:
:
Physical
(
length
)
=
>
length
.
is_zero
(
)
_
=
>
false
}
}
#
[
inline
]
pub
fn
from_px
(
px_value
:
CSSFloat
)
-
>
NoCalcLength
{
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Px
(
px_value
)
)
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
ToCss
)
]
pub
enum
Length
{
NoCalc
(
NoCalcLength
)
Calc
(
Box
<
CalcLengthOrPercentage
>
)
}
impl
From
<
NoCalcLength
>
for
Length
{
#
[
inline
]
fn
from
(
len
:
NoCalcLength
)
-
>
Self
{
Length
:
:
NoCalc
(
len
)
}
}
impl
Mul
<
CSSFloat
>
for
Length
{
type
Output
=
Length
;
#
[
inline
]
fn
mul
(
self
scalar
:
CSSFloat
)
-
>
Length
{
match
self
{
Length
:
:
NoCalc
(
inner
)
=
>
Length
:
:
NoCalc
(
inner
*
scalar
)
Length
:
:
Calc
(
.
.
)
=
>
panic
!
(
"
Can
'
t
multiply
Calc
!
"
)
}
}
}
impl
Mul
<
CSSFloat
>
for
FontRelativeLength
{
type
Output
=
FontRelativeLength
;
#
[
inline
]
fn
mul
(
self
scalar
:
CSSFloat
)
-
>
FontRelativeLength
{
match
self
{
FontRelativeLength
:
:
Em
(
v
)
=
>
FontRelativeLength
:
:
Em
(
v
*
scalar
)
FontRelativeLength
:
:
Ex
(
v
)
=
>
FontRelativeLength
:
:
Ex
(
v
*
scalar
)
FontRelativeLength
:
:
Ch
(
v
)
=
>
FontRelativeLength
:
:
Ch
(
v
*
scalar
)
FontRelativeLength
:
:
Rem
(
v
)
=
>
FontRelativeLength
:
:
Rem
(
v
*
scalar
)
}
}
}
impl
Mul
<
CSSFloat
>
for
ViewportPercentageLength
{
type
Output
=
ViewportPercentageLength
;
#
[
inline
]
fn
mul
(
self
scalar
:
CSSFloat
)
-
>
ViewportPercentageLength
{
match
self
{
ViewportPercentageLength
:
:
Vw
(
v
)
=
>
ViewportPercentageLength
:
:
Vw
(
v
*
scalar
)
ViewportPercentageLength
:
:
Vh
(
v
)
=
>
ViewportPercentageLength
:
:
Vh
(
v
*
scalar
)
ViewportPercentageLength
:
:
Vmin
(
v
)
=
>
ViewportPercentageLength
:
:
Vmin
(
v
*
scalar
)
ViewportPercentageLength
:
:
Vmax
(
v
)
=
>
ViewportPercentageLength
:
:
Vmax
(
v
*
scalar
)
}
}
}
impl
Length
{
#
[
inline
]
pub
fn
zero
(
)
-
>
Length
{
Length
:
:
NoCalc
(
NoCalcLength
:
:
zero
(
)
)
}
pub
fn
parse_dimension
(
context
:
&
ParserContext
value
:
CSSFloat
unit
:
&
str
)
-
>
Result
<
Length
(
)
>
{
NoCalcLength
:
:
parse_dimension
(
context
value
unit
)
.
map
(
Length
:
:
NoCalc
)
}
#
[
inline
]
fn
parse_internal
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
num_context
:
AllowedNumericType
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Length
ParseError
<
'
i
>
>
{
{
let
token
=
input
.
next
(
)
?
;
match
*
token
{
Token
:
:
Dimension
{
value
ref
unit
.
.
}
if
num_context
.
is_ok
(
context
.
parsing_mode
value
)
=
>
{
return
Length
:
:
parse_dimension
(
context
value
unit
)
.
map_err
(
|
(
)
|
BasicParseError
:
:
UnexpectedToken
(
token
.
clone
(
)
)
.
into
(
)
)
}
Token
:
:
Number
{
value
.
.
}
if
num_context
.
is_ok
(
context
.
parsing_mode
value
)
=
>
{
if
value
!
=
0
.
&
&
!
context
.
parsing_mode
.
allows_unitless_lengths
(
)
&
&
!
allow_quirks
.
allowed
(
context
.
quirks_mode
)
{
return
Err
(
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
return
Ok
(
Length
:
:
NoCalc
(
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Px
(
value
)
)
)
)
}
Token
:
:
Function
(
ref
name
)
if
name
.
eq_ignore_ascii_case
(
"
calc
"
)
=
>
{
}
ref
token
=
>
return
Err
(
BasicParseError
:
:
UnexpectedToken
(
token
.
clone
(
)
)
.
into
(
)
)
}
}
input
.
parse_nested_block
(
|
input
|
{
CalcNode
:
:
parse_length
(
context
input
num_context
)
.
map
(
|
calc
|
Length
:
:
Calc
(
Box
:
:
new
(
calc
)
)
)
}
)
}
#
[
inline
]
pub
fn
parse_non_negative
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Length
ParseError
<
'
i
>
>
{
Self
:
:
parse_non_negative_quirky
(
context
input
AllowQuirks
:
:
No
)
}
#
[
inline
]
pub
fn
parse_non_negative_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Length
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
AllowedNumericType
:
:
NonNegative
allow_quirks
)
}
#
[
inline
]
pub
fn
from_px
(
px_value
:
CSSFloat
)
-
>
Length
{
Length
:
:
NoCalc
(
NoCalcLength
:
:
from_px
(
px_value
)
)
}
#
[
inline
]
pub
fn
take
(
&
mut
self
)
-
>
Self
{
mem
:
:
replace
(
self
Length
:
:
zero
(
)
)
}
}
impl
Parse
for
Length
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
No
)
}
}
impl
Length
{
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
AllowedNumericType
:
:
All
allow_quirks
)
}
}
impl
<
T
:
Parse
>
Either
<
Length
T
>
{
#
[
inline
]
pub
fn
parse_non_negative_length
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
v
)
=
input
.
try
(
|
input
|
T
:
:
parse
(
context
input
)
)
{
return
Ok
(
Either
:
:
Second
(
v
)
)
;
}
Length
:
:
parse_internal
(
context
input
AllowedNumericType
:
:
NonNegative
AllowQuirks
:
:
No
)
.
map
(
Either
:
:
First
)
}
}
pub
type
NonNegativeLength
=
NonNegative
<
Length
>
;
impl
From
<
NoCalcLength
>
for
NonNegativeLength
{
#
[
inline
]
fn
from
(
len
:
NoCalcLength
)
-
>
Self
{
NonNegative
:
:
<
Length
>
(
Length
:
:
NoCalc
(
len
)
)
}
}
impl
From
<
Length
>
for
NonNegativeLength
{
#
[
inline
]
fn
from
(
len
:
Length
)
-
>
Self
{
NonNegative
:
:
<
Length
>
(
len
)
}
}
impl
<
T
:
Parse
>
Parse
for
Either
<
NonNegativeLength
T
>
{
#
[
inline
]
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
v
)
=
input
.
try
(
|
input
|
T
:
:
parse
(
context
input
)
)
{
return
Ok
(
Either
:
:
Second
(
v
)
)
;
}
Length
:
:
parse_internal
(
context
input
AllowedNumericType
:
:
NonNegative
AllowQuirks
:
:
No
)
.
map
(
NonNegative
:
:
<
Length
>
)
.
map
(
Either
:
:
First
)
}
}
impl
NonNegativeLength
{
#
[
inline
]
pub
fn
zero
(
)
-
>
Self
{
Length
:
:
zero
(
)
.
into
(
)
}
#
[
inline
]
pub
fn
from_px
(
px_value
:
CSSFloat
)
-
>
Self
{
Length
:
:
from_px
(
px_value
.
max
(
0
.
)
)
.
into
(
)
}
}
pub
type
NonNegativeLengthOrNormal
=
Either
<
NonNegativeLength
Normal
>
;
pub
type
NonNegativeLengthOrAuto
=
Either
<
NonNegativeLength
Auto
>
;
pub
type
NonNegativeLengthOrNumber
=
Either
<
NonNegativeLength
NonNegativeNumber
>
;
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
ToCss
)
]
pub
enum
LengthOrPercentage
{
Length
(
NoCalcLength
)
Percentage
(
computed
:
:
Percentage
)
Calc
(
Box
<
CalcLengthOrPercentage
>
)
}
impl
From
<
Length
>
for
LengthOrPercentage
{
fn
from
(
len
:
Length
)
-
>
LengthOrPercentage
{
match
len
{
Length
:
:
NoCalc
(
l
)
=
>
LengthOrPercentage
:
:
Length
(
l
)
Length
:
:
Calc
(
l
)
=
>
LengthOrPercentage
:
:
Calc
(
l
)
}
}
}
impl
From
<
NoCalcLength
>
for
LengthOrPercentage
{
#
[
inline
]
fn
from
(
len
:
NoCalcLength
)
-
>
Self
{
LengthOrPercentage
:
:
Length
(
len
)
}
}
impl
From
<
Percentage
>
for
LengthOrPercentage
{
#
[
inline
]
fn
from
(
pc
:
Percentage
)
-
>
Self
{
if
pc
.
is_calc
(
)
{
LengthOrPercentage
:
:
Calc
(
Box
:
:
new
(
CalcLengthOrPercentage
{
percentage
:
Some
(
computed
:
:
Percentage
(
pc
.
get
(
)
)
)
.
.
Default
:
:
default
(
)
}
)
)
}
else
{
LengthOrPercentage
:
:
Percentage
(
computed
:
:
Percentage
(
pc
.
get
(
)
)
)
}
}
}
impl
From
<
computed
:
:
Percentage
>
for
LengthOrPercentage
{
#
[
inline
]
fn
from
(
pc
:
computed
:
:
Percentage
)
-
>
Self
{
LengthOrPercentage
:
:
Percentage
(
pc
)
}
}
impl
LengthOrPercentage
{
#
[
inline
]
pub
fn
zero
(
)
-
>
LengthOrPercentage
{
LengthOrPercentage
:
:
Length
(
NoCalcLength
:
:
zero
(
)
)
}
fn
parse_internal
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
num_context
:
AllowedNumericType
allow_quirks
:
AllowQuirks
)
-
>
Result
<
LengthOrPercentage
ParseError
<
'
i
>
>
{
{
let
token
=
input
.
next
(
)
?
;
match
*
token
{
Token
:
:
Dimension
{
value
ref
unit
.
.
}
if
num_context
.
is_ok
(
context
.
parsing_mode
value
)
=
>
{
return
NoCalcLength
:
:
parse_dimension
(
context
value
unit
)
.
map
(
LengthOrPercentage
:
:
Length
)
.
map_err
(
|
(
)
|
BasicParseError
:
:
UnexpectedToken
(
token
.
clone
(
)
)
.
into
(
)
)
}
Token
:
:
Percentage
{
unit_value
.
.
}
if
num_context
.
is_ok
(
context
.
parsing_mode
unit_value
)
=
>
{
return
Ok
(
LengthOrPercentage
:
:
Percentage
(
computed
:
:
Percentage
(
unit_value
)
)
)
}
Token
:
:
Number
{
value
.
.
}
if
num_context
.
is_ok
(
context
.
parsing_mode
value
)
=
>
{
if
value
!
=
0
.
&
&
!
context
.
parsing_mode
.
allows_unitless_lengths
(
)
&
&
!
allow_quirks
.
allowed
(
context
.
quirks_mode
)
{
return
Err
(
BasicParseError
:
:
UnexpectedToken
(
token
.
clone
(
)
)
.
into
(
)
)
}
else
{
return
Ok
(
LengthOrPercentage
:
:
Length
(
NoCalcLength
:
:
from_px
(
value
)
)
)
}
}
Token
:
:
Function
(
ref
name
)
if
name
.
eq_ignore_ascii_case
(
"
calc
"
)
=
>
{
}
_
=
>
return
Err
(
BasicParseError
:
:
UnexpectedToken
(
token
.
clone
(
)
)
.
into
(
)
)
}
}
let
calc
=
input
.
parse_nested_block
(
|
i
|
{
CalcNode
:
:
parse_length_or_percentage
(
context
i
num_context
)
}
)
?
;
Ok
(
LengthOrPercentage
:
:
Calc
(
Box
:
:
new
(
calc
)
)
)
}
#
[
inline
]
pub
fn
parse_non_negative
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
LengthOrPercentage
ParseError
<
'
i
>
>
{
Self
:
:
parse_non_negative_quirky
(
context
input
AllowQuirks
:
:
No
)
}
#
[
inline
]
pub
fn
parse_non_negative_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
LengthOrPercentage
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
AllowedNumericType
:
:
NonNegative
allow_quirks
)
}
pub
fn
parse_numbers_are_pixels
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
LengthOrPercentage
ParseError
<
'
i
>
>
{
if
let
Ok
(
lop
)
=
input
.
try
(
|
i
|
Self
:
:
parse
(
context
i
)
)
{
return
Ok
(
lop
)
}
let
num
=
input
.
expect_number
(
)
?
;
Ok
(
LengthOrPercentage
:
:
Length
(
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Px
(
num
)
)
)
)
}
pub
fn
parse_numbers_are_pixels_non_negative
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
LengthOrPercentage
ParseError
<
'
i
>
>
{
if
let
Ok
(
lop
)
=
input
.
try
(
|
i
|
Self
:
:
parse_non_negative
(
context
i
)
)
{
return
Ok
(
lop
)
}
let
num
=
input
.
expect_number
(
)
?
;
if
num
>
=
0
.
{
Ok
(
LengthOrPercentage
:
:
Length
(
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Px
(
num
)
)
)
)
}
else
{
Err
(
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
}
#
[
inline
]
pub
fn
take
(
&
mut
self
)
-
>
Self
{
mem
:
:
replace
(
self
LengthOrPercentage
:
:
zero
(
)
)
}
}
impl
Parse
for
LengthOrPercentage
{
#
[
inline
]
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
No
)
}
}
impl
LengthOrPercentage
{
#
[
inline
]
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
AllowedNumericType
:
:
All
allow_quirks
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
ToCss
)
]
pub
enum
LengthOrPercentageOrAuto
{
Length
(
NoCalcLength
)
Percentage
(
computed
:
:
Percentage
)
Auto
Calc
(
Box
<
CalcLengthOrPercentage
>
)
}
impl
From
<
NoCalcLength
>
for
LengthOrPercentageOrAuto
{
#
[
inline
]
fn
from
(
len
:
NoCalcLength
)
-
>
Self
{
LengthOrPercentageOrAuto
:
:
Length
(
len
)
}
}
impl
From
<
computed
:
:
Percentage
>
for
LengthOrPercentageOrAuto
{
#
[
inline
]
fn
from
(
pc
:
computed
:
:
Percentage
)
-
>
Self
{
LengthOrPercentageOrAuto
:
:
Percentage
(
pc
)
}
}
impl
LengthOrPercentageOrAuto
{
fn
parse_internal
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
num_context
:
AllowedNumericType
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
{
let
token
=
input
.
next
(
)
?
;
match
*
token
{
Token
:
:
Dimension
{
value
ref
unit
.
.
}
if
num_context
.
is_ok
(
context
.
parsing_mode
value
)
=
>
{
return
NoCalcLength
:
:
parse_dimension
(
context
value
unit
)
.
map
(
LengthOrPercentageOrAuto
:
:
Length
)
.
map_err
(
|
(
)
|
BasicParseError
:
:
UnexpectedToken
(
token
.
clone
(
)
)
.
into
(
)
)
}
Token
:
:
Percentage
{
unit_value
.
.
}
if
num_context
.
is_ok
(
context
.
parsing_mode
unit_value
)
=
>
{
return
Ok
(
LengthOrPercentageOrAuto
:
:
Percentage
(
computed
:
:
Percentage
(
unit_value
)
)
)
}
Token
:
:
Number
{
value
.
.
}
if
num_context
.
is_ok
(
context
.
parsing_mode
value
)
=
>
{
if
value
!
=
0
.
&
&
!
context
.
parsing_mode
.
allows_unitless_lengths
(
)
&
&
!
allow_quirks
.
allowed
(
context
.
quirks_mode
)
{
return
Err
(
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
return
Ok
(
LengthOrPercentageOrAuto
:
:
Length
(
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Px
(
value
)
)
)
)
}
Token
:
:
Ident
(
ref
value
)
if
value
.
eq_ignore_ascii_case
(
"
auto
"
)
=
>
{
return
Ok
(
LengthOrPercentageOrAuto
:
:
Auto
)
}
Token
:
:
Function
(
ref
name
)
if
name
.
eq_ignore_ascii_case
(
"
calc
"
)
=
>
{
}
_
=
>
return
Err
(
BasicParseError
:
:
UnexpectedToken
(
token
.
clone
(
)
)
.
into
(
)
)
}
}
let
calc
=
input
.
parse_nested_block
(
|
i
|
{
CalcNode
:
:
parse_length_or_percentage
(
context
i
num_context
)
}
)
?
;
Ok
(
LengthOrPercentageOrAuto
:
:
Calc
(
Box
:
:
new
(
calc
)
)
)
}
#
[
inline
]
pub
fn
parse_non_negative
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
LengthOrPercentageOrAuto
ParseError
<
'
i
>
>
{
Self
:
:
parse_non_negative_quirky
(
context
input
AllowQuirks
:
:
No
)
}
#
[
inline
]
pub
fn
parse_non_negative_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
AllowedNumericType
:
:
NonNegative
allow_quirks
)
}
pub
fn
auto
(
)
-
>
Self
{
LengthOrPercentageOrAuto
:
:
Auto
}
pub
fn
zero
(
)
-
>
Self
{
LengthOrPercentageOrAuto
:
:
Length
(
NoCalcLength
:
:
zero
(
)
)
}
pub
fn
zero_percent
(
)
-
>
Self
{
LengthOrPercentageOrAuto
:
:
Percentage
(
computed
:
:
Percentage
:
:
zero
(
)
)
}
}
impl
Parse
for
LengthOrPercentageOrAuto
{
#
[
inline
]
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
No
)
}
}
impl
LengthOrPercentageOrAuto
{
#
[
inline
]
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
AllowedNumericType
:
:
All
allow_quirks
)
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
ToCss
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
LengthOrPercentageOrNone
{
Length
(
NoCalcLength
)
Percentage
(
computed
:
:
Percentage
)
Calc
(
Box
<
CalcLengthOrPercentage
>
)
None
}
impl
LengthOrPercentageOrNone
{
fn
parse_internal
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
num_context
:
AllowedNumericType
allow_quirks
:
AllowQuirks
)
-
>
Result
<
LengthOrPercentageOrNone
ParseError
<
'
i
>
>
{
{
let
token
=
input
.
next
(
)
?
;
match
*
token
{
Token
:
:
Dimension
{
value
ref
unit
.
.
}
if
num_context
.
is_ok
(
context
.
parsing_mode
value
)
=
>
{
return
NoCalcLength
:
:
parse_dimension
(
context
value
unit
)
.
map
(
LengthOrPercentageOrNone
:
:
Length
)
.
map_err
(
|
(
)
|
BasicParseError
:
:
UnexpectedToken
(
token
.
clone
(
)
)
.
into
(
)
)
}
Token
:
:
Percentage
{
unit_value
.
.
}
if
num_context
.
is_ok
(
context
.
parsing_mode
unit_value
)
=
>
{
return
Ok
(
LengthOrPercentageOrNone
:
:
Percentage
(
computed
:
:
Percentage
(
unit_value
)
)
)
}
Token
:
:
Number
{
value
.
.
}
if
num_context
.
is_ok
(
context
.
parsing_mode
value
)
=
>
{
if
value
!
=
0
.
&
&
!
context
.
parsing_mode
.
allows_unitless_lengths
(
)
&
&
!
allow_quirks
.
allowed
(
context
.
quirks_mode
)
{
return
Err
(
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
return
Ok
(
LengthOrPercentageOrNone
:
:
Length
(
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Px
(
value
)
)
)
)
}
Token
:
:
Function
(
ref
name
)
if
name
.
eq_ignore_ascii_case
(
"
calc
"
)
=
>
{
}
Token
:
:
Ident
(
ref
value
)
if
value
.
eq_ignore_ascii_case
(
"
none
"
)
=
>
{
return
Ok
(
LengthOrPercentageOrNone
:
:
None
)
}
_
=
>
return
Err
(
BasicParseError
:
:
UnexpectedToken
(
token
.
clone
(
)
)
.
into
(
)
)
}
}
let
calc
=
input
.
parse_nested_block
(
|
i
|
{
CalcNode
:
:
parse_length_or_percentage
(
context
i
num_context
)
}
)
?
;
Ok
(
LengthOrPercentageOrNone
:
:
Calc
(
Box
:
:
new
(
calc
)
)
)
}
#
[
inline
]
pub
fn
parse_non_negative
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_non_negative_quirky
(
context
input
AllowQuirks
:
:
No
)
}
#
[
inline
]
pub
fn
parse_non_negative_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
AllowedNumericType
:
:
NonNegative
allow_quirks
)
}
}
impl
Parse
for
LengthOrPercentageOrNone
{
#
[
inline
]
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
AllowedNumericType
:
:
All
AllowQuirks
:
:
No
)
}
}
pub
type
NonNegativeLengthOrPercentage
=
NonNegative
<
LengthOrPercentage
>
;
impl
From
<
NoCalcLength
>
for
NonNegativeLengthOrPercentage
{
#
[
inline
]
fn
from
(
len
:
NoCalcLength
)
-
>
Self
{
NonNegative
:
:
<
LengthOrPercentage
>
(
LengthOrPercentage
:
:
from
(
len
)
)
}
}
impl
Parse
for
NonNegativeLengthOrPercentage
{
#
[
inline
]
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
LengthOrPercentage
:
:
parse_non_negative
(
context
input
)
.
map
(
NonNegative
:
:
<
LengthOrPercentage
>
)
}
}
impl
NonNegativeLengthOrPercentage
{
#
[
inline
]
pub
fn
zero
(
)
-
>
Self
{
NonNegative
:
:
<
LengthOrPercentage
>
(
LengthOrPercentage
:
:
zero
(
)
)
}
#
[
inline
]
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
LengthOrPercentage
:
:
parse_non_negative_quirky
(
context
input
allow_quirks
)
.
map
(
NonNegative
:
:
<
LengthOrPercentage
>
)
}
}
pub
type
LengthOrNone
=
Either
<
Length
None_
>
;
pub
type
LengthOrNormal
=
Either
<
Length
Normal
>
;
pub
type
LengthOrAuto
=
Either
<
Length
Auto
>
;
pub
type
LengthOrNumber
=
Either
<
Length
Number
>
;
impl
LengthOrNumber
{
pub
fn
parse_non_negative
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
v
)
=
input
.
try
(
|
i
|
Number
:
:
parse_non_negative
(
context
i
)
)
{
return
Ok
(
Either
:
:
Second
(
v
)
)
}
Length
:
:
parse_non_negative
(
context
input
)
.
map
(
Either
:
:
First
)
}
#
[
inline
]
pub
fn
zero
(
)
-
>
Self
{
Either
:
:
Second
(
Number
:
:
new
(
0
.
)
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
ToCss
)
]
pub
enum
MozLength
{
LengthOrPercentageOrAuto
(
LengthOrPercentageOrAuto
)
ExtremumLength
(
ExtremumLength
)
}
impl
Parse
for
MozLength
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
MozLength
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
No
)
}
}
impl
MozLength
{
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
try
(
ExtremumLength
:
:
parse
)
.
map
(
MozLength
:
:
ExtremumLength
)
.
or_else
(
|
_
|
input
.
try
(
|
i
|
LengthOrPercentageOrAuto
:
:
parse_non_negative_quirky
(
context
i
allow_quirks
)
)
.
map
(
MozLength
:
:
LengthOrPercentageOrAuto
)
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
ToCss
)
]
pub
enum
MaxLength
{
LengthOrPercentageOrNone
(
LengthOrPercentageOrNone
)
ExtremumLength
(
ExtremumLength
)
}
impl
Parse
for
MaxLength
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
MaxLength
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
No
)
}
}
impl
MaxLength
{
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
try
(
ExtremumLength
:
:
parse
)
.
map
(
MaxLength
:
:
ExtremumLength
)
.
or_else
(
|
_
|
input
.
try
(
|
i
|
LengthOrPercentageOrNone
:
:
parse_non_negative_quirky
(
context
i
allow_quirks
)
)
.
map
(
MaxLength
:
:
LengthOrPercentageOrNone
)
)
}
}
