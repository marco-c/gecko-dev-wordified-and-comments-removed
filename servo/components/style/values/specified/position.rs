use
crate
:
:
derives
:
:
*
;
use
crate
:
:
logical_geometry
:
:
{
LogicalAxis
LogicalSide
PhysicalSide
WritingMode
}
;
use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
selector_map
:
:
PrecomputedHashMap
;
use
crate
:
:
str
:
:
HTML_SPACE_CHARACTERS
;
use
crate
:
:
values
:
:
computed
:
:
LengthPercentage
as
ComputedLengthPercentage
;
use
crate
:
:
values
:
:
computed
:
:
{
Context
Percentage
ToComputedValue
}
;
use
crate
:
:
values
:
:
generics
:
:
length
:
:
GenericAnchorSizeFunction
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
Position
as
GenericPosition
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
PositionComponent
as
GenericPositionComponent
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
PositionOrAuto
as
GenericPositionOrAuto
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
ZIndex
as
GenericZIndex
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
{
AspectRatio
as
GenericAspectRatio
GenericAnchorSide
}
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
{
GenericAnchorFunction
GenericInset
}
;
use
crate
:
:
values
:
:
specified
;
use
crate
:
:
values
:
:
specified
:
:
align
:
:
AlignFlags
;
use
crate
:
:
values
:
:
specified
:
:
{
AllowQuirks
Integer
LengthPercentage
NonNegativeNumber
}
;
use
crate
:
:
values
:
:
DashedIdent
;
use
crate
:
:
{
Atom
Zero
}
;
use
cssparser
:
:
{
match_ignore_ascii_case
Parser
}
;
use
num_traits
:
:
FromPrimitive
;
use
selectors
:
:
parser
:
:
SelectorParseErrorKind
;
use
servo_arc
:
:
Arc
;
use
smallvec
:
:
{
smallvec
SmallVec
}
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
arc_slice
:
:
ArcSlice
;
use
style_traits
:
:
values
:
:
specified
:
:
AllowedNumericType
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
use
thin_vec
:
:
ThinVec
;
pub
type
Position
=
GenericPosition
<
HorizontalPosition
VerticalPosition
>
;
pub
type
PositionOrAuto
=
GenericPositionOrAuto
<
Position
>
;
pub
type
HorizontalPosition
=
PositionComponent
<
HorizontalPositionKeyword
>
;
pub
type
VerticalPosition
=
PositionComponent
<
VerticalPositionKeyword
>
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToCss
ToShmem
)
]
pub
enum
PositionComponent
<
S
>
{
Center
Length
(
LengthPercentage
)
Side
(
S
Option
<
LengthPercentage
>
)
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
allow
(
missing_docs
)
]
#
[
repr
(
u8
)
]
pub
enum
HorizontalPositionKeyword
{
Left
Right
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
allow
(
missing_docs
)
]
#
[
repr
(
u8
)
]
pub
enum
VerticalPositionKeyword
{
Top
Bottom
}
impl
Parse
for
Position
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
position
=
Self
:
:
parse_three_value_quirky
(
context
input
AllowQuirks
:
:
No
)
?
;
if
position
.
is_three_value_syntax
(
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
Ok
(
position
)
}
}
impl
Position
{
pub
fn
parse_three_value_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
match
input
.
try_parse
(
|
i
|
PositionComponent
:
:
parse_quirky
(
context
i
allow_quirks
)
)
{
Ok
(
x_pos
PositionComponent
:
:
Center
)
=
>
{
if
let
Ok
(
y_pos
)
=
input
.
try_parse
(
|
i
|
PositionComponent
:
:
parse_quirky
(
context
i
allow_quirks
)
)
{
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
let
x_pos
=
input
.
try_parse
(
|
i
|
PositionComponent
:
:
parse_quirky
(
context
i
allow_quirks
)
)
.
unwrap_or
(
x_pos
)
;
let
y_pos
=
PositionComponent
:
:
Center
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
Ok
(
PositionComponent
:
:
Side
(
x_keyword
lp
)
)
=
>
{
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
center
"
)
)
.
is_ok
(
)
{
let
x_pos
=
PositionComponent
:
:
Side
(
x_keyword
lp
)
;
let
y_pos
=
PositionComponent
:
:
Center
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
if
let
Ok
(
y_keyword
)
=
input
.
try_parse
(
VerticalPositionKeyword
:
:
parse
)
{
let
y_lp
=
input
.
try_parse
(
|
i
|
LengthPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
.
ok
(
)
;
let
x_pos
=
PositionComponent
:
:
Side
(
x_keyword
lp
)
;
let
y_pos
=
PositionComponent
:
:
Side
(
y_keyword
y_lp
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
let
x_pos
=
PositionComponent
:
:
Side
(
x_keyword
None
)
;
let
y_pos
=
lp
.
map_or
(
PositionComponent
:
:
Center
PositionComponent
:
:
Length
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
Ok
(
x_pos
PositionComponent
:
:
Length
(
_
)
)
=
>
{
if
let
Ok
(
y_keyword
)
=
input
.
try_parse
(
VerticalPositionKeyword
:
:
parse
)
{
let
y_pos
=
PositionComponent
:
:
Side
(
y_keyword
None
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
if
let
Ok
(
y_lp
)
=
input
.
try_parse
(
|
i
|
LengthPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
{
let
y_pos
=
PositionComponent
:
:
Length
(
y_lp
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
let
y_pos
=
PositionComponent
:
:
Center
;
let
_
=
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
center
"
)
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
Err
(
_
)
=
>
{
}
}
let
y_keyword
=
VerticalPositionKeyword
:
:
parse
(
input
)
?
;
let
lp_and_x_pos
:
Result
<
_
ParseError
>
=
input
.
try_parse
(
|
i
|
{
let
y_lp
=
i
.
try_parse
(
|
i
|
LengthPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
.
ok
(
)
;
if
let
Ok
(
x_keyword
)
=
i
.
try_parse
(
HorizontalPositionKeyword
:
:
parse
)
{
let
x_lp
=
i
.
try_parse
(
|
i
|
LengthPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
.
ok
(
)
;
let
x_pos
=
PositionComponent
:
:
Side
(
x_keyword
x_lp
)
;
return
Ok
(
(
y_lp
x_pos
)
)
;
}
;
i
.
expect_ident_matching
(
"
center
"
)
?
;
let
x_pos
=
PositionComponent
:
:
Center
;
Ok
(
(
y_lp
x_pos
)
)
}
)
;
if
let
Ok
(
(
y_lp
x_pos
)
)
=
lp_and_x_pos
{
let
y_pos
=
PositionComponent
:
:
Side
(
y_keyword
y_lp
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
let
x_pos
=
PositionComponent
:
:
Center
;
let
y_pos
=
PositionComponent
:
:
Side
(
y_keyword
None
)
;
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
}
#
[
inline
]
pub
fn
center
(
)
-
>
Self
{
Self
:
:
new
(
PositionComponent
:
:
Center
PositionComponent
:
:
Center
)
}
#
[
inline
]
fn
is_three_value_syntax
(
&
self
)
-
>
bool
{
self
.
horizontal
.
component_count
(
)
!
=
self
.
vertical
.
component_count
(
)
}
}
impl
ToCss
for
Position
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
(
&
self
.
horizontal
&
self
.
vertical
)
{
(
x_pos
&
PositionComponent
:
:
Side
(
_
Some
(
_
)
)
&
PositionComponent
:
:
Length
(
ref
y_lp
)
)
=
>
{
x_pos
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
top
"
)
?
;
y_lp
.
to_css
(
dest
)
}
(
&
PositionComponent
:
:
Length
(
ref
x_lp
)
y_pos
&
PositionComponent
:
:
Side
(
_
Some
(
_
)
)
)
=
>
{
dest
.
write_str
(
"
left
"
)
?
;
x_lp
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
y_pos
.
to_css
(
dest
)
}
(
x_pos
y_pos
)
=
>
{
x_pos
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
y_pos
.
to_css
(
dest
)
}
}
}
}
impl
<
S
:
Parse
>
Parse
for
PositionComponent
<
S
>
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
No
)
}
}
impl
<
S
:
Parse
>
PositionComponent
<
S
>
{
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
center
"
)
)
.
is_ok
(
)
{
return
Ok
(
PositionComponent
:
:
Center
)
;
}
if
let
Ok
(
lp
)
=
input
.
try_parse
(
|
i
|
LengthPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
{
return
Ok
(
PositionComponent
:
:
Length
(
lp
)
)
;
}
let
keyword
=
S
:
:
parse
(
context
input
)
?
;
let
lp
=
input
.
try_parse
(
|
i
|
LengthPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
.
ok
(
)
;
Ok
(
PositionComponent
:
:
Side
(
keyword
lp
)
)
}
}
impl
<
S
>
GenericPositionComponent
for
PositionComponent
<
S
>
{
fn
is_center
(
&
self
)
-
>
bool
{
match
*
self
{
PositionComponent
:
:
Center
=
>
true
PositionComponent
:
:
Length
(
LengthPercentage
:
:
Percentage
(
ref
per
)
)
=
>
per
.
0
=
=
0
.
5
PositionComponent
:
:
Side
(
_
Some
(
LengthPercentage
:
:
Percentage
(
ref
per
)
)
)
=
>
per
.
0
=
=
0
.
5
_
=
>
false
}
}
}
impl
<
S
>
PositionComponent
<
S
>
{
pub
fn
zero
(
)
-
>
Self
{
PositionComponent
:
:
Length
(
LengthPercentage
:
:
Percentage
(
Percentage
:
:
zero
(
)
)
)
}
fn
component_count
(
&
self
)
-
>
usize
{
match
*
self
{
PositionComponent
:
:
Length
(
.
.
)
|
PositionComponent
:
:
Center
=
>
1
PositionComponent
:
:
Side
(
_
ref
lp
)
=
>
{
if
lp
.
is_some
(
)
{
2
}
else
{
1
}
}
}
}
}
impl
<
S
:
Side
>
ToComputedValue
for
PositionComponent
<
S
>
{
type
ComputedValue
=
ComputedLengthPercentage
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
match
*
self
{
PositionComponent
:
:
Center
=
>
ComputedLengthPercentage
:
:
new_percent
(
Percentage
(
0
.
5
)
)
PositionComponent
:
:
Side
(
ref
keyword
None
)
=
>
{
let
p
=
Percentage
(
if
keyword
.
is_start
(
)
{
0
.
}
else
{
1
.
}
)
;
ComputedLengthPercentage
:
:
new_percent
(
p
)
}
PositionComponent
:
:
Side
(
ref
keyword
Some
(
ref
length
)
)
if
!
keyword
.
is_start
(
)
=
>
{
let
length
=
length
.
to_computed_value
(
context
)
;
ComputedLengthPercentage
:
:
hundred_percent_minus
(
length
AllowedNumericType
:
:
All
)
}
PositionComponent
:
:
Side
(
_
Some
(
ref
length
)
)
|
PositionComponent
:
:
Length
(
ref
length
)
=
>
length
.
to_computed_value
(
context
)
}
}
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
PositionComponent
:
:
Length
(
ToComputedValue
:
:
from_computed_value
(
computed
)
)
}
}
impl
<
S
:
Side
>
PositionComponent
<
S
>
{
pub
fn
initial_specified_value
(
)
-
>
Self
{
PositionComponent
:
:
Side
(
S
:
:
start
(
)
None
)
}
}
#
[
repr
(
transparent
)
]
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
ToTyped
)
]
#
[
css
(
comma
)
]
pub
struct
AnchorName
(
#
[
css
(
iterable
if_empty
=
"
none
"
)
]
#
[
ignore_malloc_size_of
=
"
Arc
"
]
pub
crate
:
:
ArcSlice
<
DashedIdent
>
)
;
impl
AnchorName
{
pub
fn
none
(
)
-
>
Self
{
Self
(
Default
:
:
default
(
)
)
}
pub
fn
is_none
(
&
self
)
-
>
bool
{
self
.
0
.
is_empty
(
)
}
}
impl
Parse
for
AnchorName
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
first
=
input
.
expect_ident
(
)
?
;
if
first
.
eq_ignore_ascii_case
(
"
none
"
)
{
return
Ok
(
Self
:
:
none
(
)
)
;
}
let
mut
idents
:
SmallVec
<
[
DashedIdent
;
4
]
>
=
smallvec
!
[
DashedIdent
:
:
from_ident
(
location
first
)
?
]
;
while
input
.
try_parse
(
|
input
|
input
.
expect_comma
(
)
)
.
is_ok
(
)
{
idents
.
push
(
DashedIdent
:
:
parse
(
context
input
)
?
)
;
}
Ok
(
AnchorName
(
ArcSlice
:
:
from_iter
(
idents
.
drain
(
.
.
)
)
)
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
ToTyped
)
]
#
[
repr
(
u8
)
]
pub
enum
AnchorScope
{
None
All
#
[
css
(
comma
)
]
Idents
(
#
[
css
(
iterable
)
]
#
[
ignore_malloc_size_of
=
"
Arc
"
]
crate
:
:
ArcSlice
<
DashedIdent
>
)
}
impl
AnchorScope
{
pub
fn
none
(
)
-
>
Self
{
Self
:
:
None
}
pub
fn
is_none
(
&
self
)
-
>
bool
{
*
self
=
=
Self
:
:
None
}
}
impl
Parse
for
AnchorScope
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
first
=
input
.
expect_ident
(
)
?
;
if
first
.
eq_ignore_ascii_case
(
"
none
"
)
{
return
Ok
(
Self
:
:
None
)
;
}
if
first
.
eq_ignore_ascii_case
(
"
all
"
)
{
return
Ok
(
Self
:
:
All
)
;
}
let
mut
idents
:
SmallVec
<
[
DashedIdent
;
8
]
>
=
smallvec
!
[
DashedIdent
:
:
from_ident
(
location
first
)
?
]
;
while
input
.
try_parse
(
|
input
|
input
.
expect_comma
(
)
)
.
is_ok
(
)
{
idents
.
push
(
DashedIdent
:
:
parse
(
context
input
)
?
)
;
}
Ok
(
AnchorScope
:
:
Idents
(
ArcSlice
:
:
from_iter
(
idents
.
drain
(
.
.
)
)
)
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
ToTyped
)
]
#
[
repr
(
u8
)
]
pub
enum
PositionAnchor
{
None
Auto
Ident
(
DashedIdent
)
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
Serialize
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
PositionTryFallbacksTryTacticKeyword
{
FlipBlock
FlipInline
FlipStart
FlipX
FlipY
}
#
[
derive
(
Clone
Debug
Default
Eq
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
transparent
)
]
pub
struct
PositionTryFallbacksTryTactic
(
#
[
css
(
iterable
)
]
pub
ThinVec
<
PositionTryFallbacksTryTacticKeyword
>
)
;
impl
Parse
for
PositionTryFallbacksTryTactic
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
result
=
ThinVec
:
:
with_capacity
(
5
)
;
for
_
in
0
.
.
5
{
if
let
Ok
(
kw
)
=
input
.
try_parse
(
PositionTryFallbacksTryTacticKeyword
:
:
parse
)
{
if
result
.
contains
(
&
kw
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
result
.
push
(
kw
)
;
}
else
{
break
;
}
}
if
result
.
is_empty
(
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
Ok
(
Self
(
result
)
)
}
}
impl
PositionTryFallbacksTryTactic
{
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_empty
(
)
}
#
[
inline
]
pub
fn
iter
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
PositionTryFallbacksTryTacticKeyword
>
{
self
.
0
.
iter
(
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
DashedIdentAndOrTryTactic
{
pub
ident
:
DashedIdent
pub
try_tactic
:
PositionTryFallbacksTryTactic
}
impl
Parse
for
DashedIdentAndOrTryTactic
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
result
=
Self
{
ident
:
DashedIdent
:
:
empty
(
)
try_tactic
:
PositionTryFallbacksTryTactic
:
:
default
(
)
}
;
loop
{
if
result
.
ident
.
is_empty
(
)
{
if
let
Ok
(
ident
)
=
input
.
try_parse
(
|
i
|
DashedIdent
:
:
parse
(
context
i
)
)
{
result
.
ident
=
ident
;
continue
;
}
}
if
result
.
try_tactic
.
is_empty
(
)
{
if
let
Ok
(
try_tactic
)
=
input
.
try_parse
(
|
i
|
PositionTryFallbacksTryTactic
:
:
parse
(
context
i
)
)
{
result
.
try_tactic
=
try_tactic
;
continue
;
}
}
break
;
}
if
result
.
ident
.
is_empty
(
)
&
&
result
.
try_tactic
.
is_empty
(
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
return
Ok
(
result
)
;
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
PositionTryFallbacksItem
{
IdentAndOrTactic
(
DashedIdentAndOrTryTactic
)
#
[
parse
(
parse_fn
=
"
PositionArea
:
:
parse_except_none
"
)
]
PositionArea
(
PositionArea
)
}
#
[
derive
(
Clone
Debug
Default
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
ToTyped
)
]
#
[
css
(
comma
)
]
#
[
repr
(
C
)
]
pub
struct
PositionTryFallbacks
(
#
[
css
(
iterable
if_empty
=
"
none
"
)
]
#
[
ignore_malloc_size_of
=
"
Arc
"
]
pub
crate
:
:
ArcSlice
<
PositionTryFallbacksItem
>
)
;
impl
PositionTryFallbacks
{
#
[
inline
]
pub
fn
none
(
)
-
>
Self
{
Self
(
Default
:
:
default
(
)
)
}
pub
fn
is_none
(
&
self
)
-
>
bool
{
self
.
0
.
is_empty
(
)
}
}
impl
Parse
for
PositionTryFallbacks
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
none
"
)
)
.
is_ok
(
)
{
return
Ok
(
Self
:
:
none
(
)
)
;
}
let
mut
items
:
SmallVec
<
[
PositionTryFallbacksItem
;
4
]
>
=
smallvec
!
[
PositionTryFallbacksItem
:
:
parse
(
context
input
)
?
]
;
while
input
.
try_parse
(
|
input
|
input
.
expect_comma
(
)
)
.
is_ok
(
)
{
items
.
push
(
PositionTryFallbacksItem
:
:
parse
(
context
input
)
?
)
;
}
Ok
(
Self
(
ArcSlice
:
:
from_iter
(
items
.
drain
(
.
.
)
)
)
)
}
}
#
[
derive
(
Clone
Copy
Debug
Default
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
ToTyped
)
]
#
[
repr
(
u8
)
]
pub
enum
PositionTryOrder
{
#
[
default
]
Normal
MostWidth
MostHeight
MostBlockSize
MostInlineSize
}
impl
PositionTryOrder
{
#
[
inline
]
pub
fn
normal
(
)
-
>
Self
{
Self
:
:
Normal
}
pub
fn
is_normal
(
&
self
)
-
>
bool
{
*
self
=
=
Self
:
:
Normal
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
Serialize
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
ToTyped
)
]
#
[
css
(
bitflags
(
single
=
"
always
"
mixed
=
"
anchors
-
valid
anchors
-
visible
no
-
overflow
"
)
)
]
#
[
repr
(
C
)
]
pub
struct
PositionVisibility
(
u8
)
;
bitflags
!
{
impl
PositionVisibility
:
u8
{
/
/
/
Element
is
displayed
without
regard
for
its
anchors
or
its
overflowing
status
.
const
ALWAYS
=
0
;
/
/
/
anchors
-
valid
const
ANCHORS_VALID
=
1
<
<
0
;
/
/
/
anchors
-
visible
const
ANCHORS_VISIBLE
=
1
<
<
1
;
/
/
/
no
-
overflow
const
NO_OVERFLOW
=
1
<
<
2
;
}
}
impl
Default
for
PositionVisibility
{
fn
default
(
)
-
>
Self
{
Self
:
:
ALWAYS
}
}
impl
PositionVisibility
{
#
[
inline
]
pub
fn
always
(
)
-
>
Self
{
Self
:
:
ALWAYS
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
PositionAreaType
{
Physical
Logical
SelfLogical
Inferred
SelfInferred
Common
None
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
FromPrimitive
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
PositionAreaAxis
{
Horizontal
=
0b000
Vertical
=
0b001
X
=
0b010
Y
=
0b011
Block
=
0b110
Inline
=
0b111
Inferred
=
0b100
None
=
0b101
}
impl
PositionAreaAxis
{
pub
fn
is_physical
(
self
)
-
>
bool
{
(
self
as
u8
&
0b100
)
=
=
0
}
fn
is_flow_relative_direction
(
self
)
-
>
bool
{
self
=
=
Self
:
:
Inferred
|
|
(
self
as
u8
&
0b10
)
!
=
0
}
fn
is_canonically_first
(
self
)
-
>
bool
{
self
!
=
Self
:
:
Inferred
&
&
(
self
as
u8
)
&
1
=
=
0
}
#
[
allow
(
unused
)
]
fn
flip
(
self
)
-
>
Self
{
if
matches
!
(
self
Self
:
:
Inferred
|
Self
:
:
None
)
{
return
self
;
}
Self
:
:
from_u8
(
self
as
u8
^
1u8
)
.
unwrap
(
)
}
fn
to_logical
(
self
wm
:
WritingMode
inferred
:
LogicalAxis
)
-
>
Option
<
LogicalAxis
>
{
Some
(
match
self
{
PositionAreaAxis
:
:
Horizontal
|
PositionAreaAxis
:
:
X
=
>
{
if
wm
.
is_vertical
(
)
{
LogicalAxis
:
:
Block
}
else
{
LogicalAxis
:
:
Inline
}
}
PositionAreaAxis
:
:
Vertical
|
PositionAreaAxis
:
:
Y
=
>
{
if
wm
.
is_vertical
(
)
{
LogicalAxis
:
:
Inline
}
else
{
LogicalAxis
:
:
Block
}
}
PositionAreaAxis
:
:
Block
=
>
LogicalAxis
:
:
Block
PositionAreaAxis
:
:
Inline
=
>
LogicalAxis
:
:
Inline
PositionAreaAxis
:
:
Inferred
=
>
inferred
PositionAreaAxis
:
:
None
=
>
return
None
}
)
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
FromPrimitive
)
]
pub
enum
PositionAreaTrack
{
Start
=
0b001
SpanStart
=
0b011
End
=
0b100
SpanEnd
=
0b110
Center
=
0b010
SpanAll
=
0b111
}
impl
PositionAreaTrack
{
fn
flip
(
self
)
-
>
Self
{
match
self
{
Self
:
:
Start
=
>
Self
:
:
End
Self
:
:
SpanStart
=
>
Self
:
:
SpanEnd
Self
:
:
End
=
>
Self
:
:
Start
Self
:
:
SpanEnd
=
>
Self
:
:
SpanStart
Self
:
:
Center
|
Self
:
:
SpanAll
=
>
self
}
}
fn
start
(
self
)
-
>
bool
{
self
as
u8
&
1
!
=
0
}
}
pub
const
AXIS_SHIFT
:
usize
=
3
;
pub
const
AXIS_MASK
:
u8
=
0b111u8
<
<
AXIS_SHIFT
;
pub
const
TRACK_MASK
:
u8
=
0b111u8
;
pub
const
SELF_WM
:
u8
=
1u8
<
<
6
;
#
[
derive
(
Clone
Copy
Debug
Default
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
FromPrimitive
)
]
#
[
allow
(
missing_docs
)
]
#
[
repr
(
u8
)
]
pub
enum
PositionAreaKeyword
{
#
[
default
]
None
=
(
PositionAreaAxis
:
:
None
as
u8
)
<
<
AXIS_SHIFT
Center
=
(
(
PositionAreaAxis
:
:
None
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
Center
as
u8
SpanAll
=
(
(
PositionAreaAxis
:
:
None
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanAll
as
u8
Start
=
(
(
PositionAreaAxis
:
:
Inferred
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
Start
as
u8
End
=
(
(
PositionAreaAxis
:
:
Inferred
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
End
as
u8
SpanStart
=
(
(
PositionAreaAxis
:
:
Inferred
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanStart
as
u8
SpanEnd
=
(
(
PositionAreaAxis
:
:
Inferred
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanEnd
as
u8
Left
=
(
(
PositionAreaAxis
:
:
Horizontal
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
Start
as
u8
Right
=
(
(
PositionAreaAxis
:
:
Horizontal
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
End
as
u8
Top
=
(
(
PositionAreaAxis
:
:
Vertical
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
Start
as
u8
Bottom
=
(
(
PositionAreaAxis
:
:
Vertical
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
End
as
u8
XStart
=
(
(
PositionAreaAxis
:
:
X
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
Start
as
u8
XEnd
=
(
(
PositionAreaAxis
:
:
X
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
End
as
u8
YStart
=
(
(
PositionAreaAxis
:
:
Y
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
Start
as
u8
YEnd
=
(
(
PositionAreaAxis
:
:
Y
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
End
as
u8
BlockStart
=
(
(
PositionAreaAxis
:
:
Block
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
Start
as
u8
BlockEnd
=
(
(
PositionAreaAxis
:
:
Block
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
End
as
u8
InlineStart
=
(
(
PositionAreaAxis
:
:
Inline
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
Start
as
u8
InlineEnd
=
(
(
PositionAreaAxis
:
:
Inline
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
End
as
u8
SpanLeft
=
(
(
PositionAreaAxis
:
:
Horizontal
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanStart
as
u8
SpanRight
=
(
(
PositionAreaAxis
:
:
Horizontal
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanEnd
as
u8
SpanTop
=
(
(
PositionAreaAxis
:
:
Vertical
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanStart
as
u8
SpanBottom
=
(
(
PositionAreaAxis
:
:
Vertical
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanEnd
as
u8
SpanXStart
=
(
(
PositionAreaAxis
:
:
X
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanStart
as
u8
SpanXEnd
=
(
(
PositionAreaAxis
:
:
X
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanEnd
as
u8
SpanYStart
=
(
(
PositionAreaAxis
:
:
Y
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanStart
as
u8
SpanYEnd
=
(
(
PositionAreaAxis
:
:
Y
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanEnd
as
u8
SpanBlockStart
=
(
(
PositionAreaAxis
:
:
Block
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanStart
as
u8
SpanBlockEnd
=
(
(
PositionAreaAxis
:
:
Block
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanEnd
as
u8
SpanInlineStart
=
(
(
PositionAreaAxis
:
:
Inline
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanStart
as
u8
SpanInlineEnd
=
(
(
PositionAreaAxis
:
:
Inline
as
u8
)
<
<
AXIS_SHIFT
)
|
PositionAreaTrack
:
:
SpanEnd
as
u8
SelfStart
=
SELF_WM
|
(
Self
:
:
Start
as
u8
)
SelfEnd
=
SELF_WM
|
(
Self
:
:
End
as
u8
)
SpanSelfStart
=
SELF_WM
|
(
Self
:
:
SpanStart
as
u8
)
SpanSelfEnd
=
SELF_WM
|
(
Self
:
:
SpanEnd
as
u8
)
SelfXStart
=
SELF_WM
|
(
Self
:
:
XStart
as
u8
)
SelfXEnd
=
SELF_WM
|
(
Self
:
:
XEnd
as
u8
)
SelfYStart
=
SELF_WM
|
(
Self
:
:
YStart
as
u8
)
SelfYEnd
=
SELF_WM
|
(
Self
:
:
YEnd
as
u8
)
SelfBlockStart
=
SELF_WM
|
(
Self
:
:
BlockStart
as
u8
)
SelfBlockEnd
=
SELF_WM
|
(
Self
:
:
BlockEnd
as
u8
)
SelfInlineStart
=
SELF_WM
|
(
Self
:
:
InlineStart
as
u8
)
SelfInlineEnd
=
SELF_WM
|
(
Self
:
:
InlineEnd
as
u8
)
SpanSelfXStart
=
SELF_WM
|
(
Self
:
:
SpanXStart
as
u8
)
SpanSelfXEnd
=
SELF_WM
|
(
Self
:
:
SpanXEnd
as
u8
)
SpanSelfYStart
=
SELF_WM
|
(
Self
:
:
SpanYStart
as
u8
)
SpanSelfYEnd
=
SELF_WM
|
(
Self
:
:
SpanYEnd
as
u8
)
SpanSelfBlockStart
=
SELF_WM
|
(
Self
:
:
SpanBlockStart
as
u8
)
SpanSelfBlockEnd
=
SELF_WM
|
(
Self
:
:
SpanBlockEnd
as
u8
)
SpanSelfInlineStart
=
SELF_WM
|
(
Self
:
:
SpanInlineStart
as
u8
)
SpanSelfInlineEnd
=
SELF_WM
|
(
Self
:
:
SpanInlineEnd
as
u8
)
}
impl
PositionAreaKeyword
{
#
[
inline
]
pub
fn
none
(
)
-
>
Self
{
Self
:
:
None
}
pub
fn
is_none
(
&
self
)
-
>
bool
{
*
self
=
=
Self
:
:
None
}
pub
fn
self_wm
(
self
)
-
>
bool
{
(
self
as
u8
&
SELF_WM
)
!
=
0
}
pub
fn
axis
(
self
)
-
>
PositionAreaAxis
{
PositionAreaAxis
:
:
from_u8
(
(
self
as
u8
>
>
AXIS_SHIFT
)
&
0b111
)
.
unwrap
(
)
}
pub
fn
with_axis
(
self
axis
:
PositionAreaAxis
)
-
>
Self
{
Self
:
:
from_u8
(
(
(
self
as
u8
)
&
!
AXIS_MASK
)
|
(
(
axis
as
u8
)
<
<
AXIS_SHIFT
)
)
.
unwrap
(
)
}
pub
fn
with_inferred_axis
(
self
axis
:
PositionAreaAxis
)
-
>
Self
{
if
self
.
axis
(
)
=
=
PositionAreaAxis
:
:
Inferred
{
self
.
with_axis
(
axis
)
}
else
{
self
}
}
pub
fn
track
(
self
)
-
>
Option
<
PositionAreaTrack
>
{
let
result
=
PositionAreaTrack
:
:
from_u8
(
self
as
u8
&
TRACK_MASK
)
;
debug_assert_eq
!
(
result
.
is_none
(
)
self
.
is_none
(
)
"
Only
the
none
keyword
has
no
track
"
)
;
result
}
fn
group_type
(
self
)
-
>
PositionAreaType
{
let
axis
=
self
.
axis
(
)
;
if
axis
=
=
PositionAreaAxis
:
:
None
{
if
self
.
is_none
(
)
{
return
PositionAreaType
:
:
None
;
}
return
PositionAreaType
:
:
Common
;
}
if
axis
=
=
PositionAreaAxis
:
:
Inferred
{
return
if
self
.
self_wm
(
)
{
PositionAreaType
:
:
SelfInferred
}
else
{
PositionAreaType
:
:
Inferred
}
;
}
if
axis
.
is_physical
(
)
{
return
PositionAreaType
:
:
Physical
;
}
if
self
.
self_wm
(
)
{
PositionAreaType
:
:
SelfLogical
}
else
{
PositionAreaType
:
:
Logical
}
}
fn
to_physical
(
self
cb_wm
:
WritingMode
self_wm
:
WritingMode
inferred_axis
:
LogicalAxis
)
-
>
Self
{
let
wm
=
if
self
.
self_wm
(
)
{
self_wm
}
else
{
cb_wm
}
;
let
axis
=
self
.
axis
(
)
;
if
!
axis
.
is_flow_relative_direction
(
)
{
return
self
;
}
let
Some
(
logical_axis
)
=
axis
.
to_logical
(
wm
inferred_axis
)
else
{
return
self
;
}
;
let
Some
(
track
)
=
self
.
track
(
)
else
{
debug_assert
!
(
false
"
How
did
we
end
up
with
no
track
here
?
{
self
:
?
}
"
)
;
return
self
;
}
;
let
start
=
track
.
start
(
)
;
let
logical_side
=
match
logical_axis
{
LogicalAxis
:
:
Block
=
>
{
if
start
{
LogicalSide
:
:
BlockStart
}
else
{
LogicalSide
:
:
BlockEnd
}
}
LogicalAxis
:
:
Inline
=
>
{
if
start
{
LogicalSide
:
:
InlineStart
}
else
{
LogicalSide
:
:
InlineEnd
}
}
}
;
let
physical_side
=
logical_side
.
to_physical
(
wm
)
;
let
physical_start
=
matches
!
(
physical_side
PhysicalSide
:
:
Top
|
PhysicalSide
:
:
Left
)
;
let
new_track
=
if
physical_start
!
=
start
{
track
.
flip
(
)
}
else
{
track
}
;
let
new_axis
=
if
matches
!
(
physical_side
PhysicalSide
:
:
Top
|
PhysicalSide
:
:
Bottom
)
{
PositionAreaAxis
:
:
Vertical
}
else
{
PositionAreaAxis
:
:
Horizontal
}
;
Self
:
:
from_u8
(
new_track
as
u8
|
(
(
new_axis
as
u8
)
<
<
AXIS_SHIFT
)
)
.
unwrap
(
)
}
fn
flip_track
(
self
)
-
>
Self
{
let
Some
(
old_track
)
=
self
.
track
(
)
else
{
return
self
;
}
;
let
new_track
=
old_track
.
flip
(
)
;
Self
:
:
from_u8
(
(
self
as
u8
&
!
TRACK_MASK
)
|
new_track
as
u8
)
.
unwrap
(
)
}
pub
fn
to_self_alignment
(
self
axis
:
LogicalAxis
cb_wm
:
&
WritingMode
)
-
>
Option
<
AlignFlags
>
{
let
track
=
self
.
track
(
)
?
;
Some
(
match
track
{
PositionAreaTrack
:
:
Center
=
>
AlignFlags
:
:
CENTER
PositionAreaTrack
:
:
SpanAll
=
>
AlignFlags
:
:
ANCHOR_CENTER
_
=
>
{
debug_assert_eq
!
(
self
.
group_type
(
)
PositionAreaType
:
:
Physical
)
;
if
axis
=
=
LogicalAxis
:
:
Inline
{
if
track
.
start
(
)
=
=
cb_wm
.
intersects
(
WritingMode
:
:
INLINE_REVERSED
)
{
AlignFlags
:
:
START
}
else
{
AlignFlags
:
:
END
}
}
else
{
if
track
.
start
(
)
=
=
cb_wm
.
is_vertical_rl
(
)
{
AlignFlags
:
:
START
}
else
{
AlignFlags
:
:
END
}
}
}
}
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToCss
ToResolvedValue
ToShmem
ToTyped
)
]
#
[
repr
(
C
)
]
pub
struct
PositionArea
{
pub
first
:
PositionAreaKeyword
#
[
css
(
skip_if
=
"
PositionAreaKeyword
:
:
is_none
"
)
]
pub
second
:
PositionAreaKeyword
}
impl
PositionArea
{
#
[
inline
]
pub
fn
none
(
)
-
>
Self
{
Self
{
first
:
PositionAreaKeyword
:
:
None
second
:
PositionAreaKeyword
:
:
None
}
}
#
[
inline
]
pub
fn
is_none
(
&
self
)
-
>
bool
{
self
.
first
.
is_none
(
)
}
pub
fn
parse_except_none
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
false
)
}
pub
fn
get_type
(
&
self
)
-
>
PositionAreaType
{
let
first
=
self
.
first
.
group_type
(
)
;
let
second
=
self
.
second
.
group_type
(
)
;
if
matches
!
(
second
PositionAreaType
:
:
None
|
PositionAreaType
:
:
Common
)
{
return
first
;
}
if
first
=
=
PositionAreaType
:
:
Common
{
return
second
;
}
if
first
!
=
second
{
return
PositionAreaType
:
:
None
;
}
let
first_axis
=
self
.
first
.
axis
(
)
;
if
first_axis
!
=
PositionAreaAxis
:
:
Inferred
&
&
first_axis
.
is_canonically_first
(
)
=
=
self
.
second
.
axis
(
)
.
is_canonically_first
(
)
{
return
PositionAreaType
:
:
None
;
}
first
}
fn
parse_internal
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_none
:
bool
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
location
=
input
.
current_source_location
(
)
;
let
mut
first
=
PositionAreaKeyword
:
:
parse
(
input
)
?
;
if
first
.
is_none
(
)
{
if
allow_none
{
return
Ok
(
Self
:
:
none
(
)
)
;
}
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
location
=
input
.
current_source_location
(
)
;
let
second
=
input
.
try_parse
(
PositionAreaKeyword
:
:
parse
)
;
if
let
Ok
(
PositionAreaKeyword
:
:
None
)
=
second
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
let
mut
second
=
second
.
unwrap_or
(
PositionAreaKeyword
:
:
None
)
;
if
second
.
is_none
(
)
{
return
Ok
(
Self
{
first
second
}
)
;
}
let
pair_type
=
Self
{
first
second
}
.
get_type
(
)
;
if
pair_type
=
=
PositionAreaType
:
:
None
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
if
matches
!
(
pair_type
PositionAreaType
:
:
Physical
|
PositionAreaType
:
:
Logical
|
PositionAreaType
:
:
SelfLogical
)
{
if
second
=
=
PositionAreaKeyword
:
:
SpanAll
{
second
=
PositionAreaKeyword
:
:
None
;
}
else
if
first
=
=
PositionAreaKeyword
:
:
SpanAll
{
first
=
second
;
second
=
PositionAreaKeyword
:
:
None
;
}
}
if
first
=
=
second
{
second
=
PositionAreaKeyword
:
:
None
;
}
let
mut
result
=
Self
{
first
second
}
;
result
.
canonicalize_order
(
)
;
Ok
(
result
)
}
fn
canonicalize_order
(
&
mut
self
)
{
let
first_axis
=
self
.
first
.
axis
(
)
;
if
first_axis
.
is_canonically_first
(
)
|
|
self
.
second
.
is_none
(
)
{
return
;
}
let
second_axis
=
self
.
second
.
axis
(
)
;
if
first_axis
=
=
second_axis
{
return
;
}
if
second_axis
.
is_canonically_first
(
)
|
|
(
second_axis
=
=
PositionAreaAxis
:
:
None
&
&
first_axis
!
=
PositionAreaAxis
:
:
Inferred
)
{
std
:
:
mem
:
:
swap
(
&
mut
self
.
first
&
mut
self
.
second
)
;
}
}
fn
make_missing_second_explicit
(
&
mut
self
)
{
if
!
self
.
second
.
is_none
(
)
{
return
;
}
let
axis
=
self
.
first
.
axis
(
)
;
if
matches
!
(
axis
PositionAreaAxis
:
:
Inferred
|
PositionAreaAxis
:
:
None
)
{
self
.
second
=
self
.
first
;
return
;
}
self
.
second
=
PositionAreaKeyword
:
:
SpanAll
;
if
!
axis
.
is_canonically_first
(
)
{
std
:
:
mem
:
:
swap
(
&
mut
self
.
first
&
mut
self
.
second
)
;
}
}
pub
fn
to_physical
(
mut
self
cb_wm
:
WritingMode
self_wm
:
WritingMode
)
-
>
Self
{
self
.
make_missing_second_explicit
(
)
;
if
self
.
first
.
axis
(
)
=
=
PositionAreaAxis
:
:
None
&
&
self
.
second
.
axis
(
)
=
=
PositionAreaAxis
:
:
None
&
&
!
cb_wm
.
is_vertical
(
)
{
std
:
:
mem
:
:
swap
(
&
mut
self
.
first
&
mut
self
.
second
)
;
}
else
{
self
.
first
=
self
.
first
.
to_physical
(
cb_wm
self_wm
LogicalAxis
:
:
Block
)
;
self
.
second
=
self
.
second
.
to_physical
(
cb_wm
self_wm
LogicalAxis
:
:
Inline
)
;
self
.
canonicalize_order
(
)
;
}
self
}
fn
flip_logical_axis
(
&
mut
self
wm
:
WritingMode
axis
:
LogicalAxis
)
{
if
self
.
first
.
axis
(
)
.
to_logical
(
wm
LogicalAxis
:
:
Block
)
=
=
Some
(
axis
)
{
self
.
first
=
self
.
first
.
flip_track
(
)
;
}
else
{
self
.
second
=
self
.
second
.
flip_track
(
)
;
}
}
fn
flip_start
(
&
mut
self
)
{
self
.
first
=
self
.
first
.
with_axis
(
self
.
first
.
axis
(
)
.
flip
(
)
)
;
self
.
second
=
self
.
second
.
with_axis
(
self
.
second
.
axis
(
)
.
flip
(
)
)
;
}
pub
fn
with_tactic
(
mut
self
wm
:
WritingMode
tactic
:
PositionTryFallbacksTryTacticKeyword
)
-
>
Self
{
self
.
make_missing_second_explicit
(
)
;
let
axis_to_flip
=
match
tactic
{
PositionTryFallbacksTryTacticKeyword
:
:
FlipStart
=
>
{
self
.
flip_start
(
)
;
return
self
;
}
PositionTryFallbacksTryTacticKeyword
:
:
FlipBlock
=
>
LogicalAxis
:
:
Block
PositionTryFallbacksTryTacticKeyword
:
:
FlipInline
=
>
LogicalAxis
:
:
Inline
PositionTryFallbacksTryTacticKeyword
:
:
FlipX
=
>
{
if
wm
.
is_horizontal
(
)
{
LogicalAxis
:
:
Inline
}
else
{
LogicalAxis
:
:
Block
}
}
PositionTryFallbacksTryTacticKeyword
:
:
FlipY
=
>
{
if
wm
.
is_vertical
(
)
{
LogicalAxis
:
:
Inline
}
else
{
LogicalAxis
:
:
Block
}
}
}
;
self
.
flip_logical_axis
(
wm
axis_to_flip
)
;
self
}
}
impl
Parse
for
PositionArea
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
true
)
}
}
pub
trait
Side
{
fn
start
(
)
-
>
Self
;
fn
is_start
(
&
self
)
-
>
bool
;
}
impl
Side
for
HorizontalPositionKeyword
{
#
[
inline
]
fn
start
(
)
-
>
Self
{
HorizontalPositionKeyword
:
:
Left
}
#
[
inline
]
fn
is_start
(
&
self
)
-
>
bool
{
*
self
=
=
Self
:
:
start
(
)
}
}
impl
Side
for
VerticalPositionKeyword
{
#
[
inline
]
fn
start
(
)
-
>
Self
{
VerticalPositionKeyword
:
:
Top
}
#
[
inline
]
fn
is_start
(
&
self
)
-
>
bool
{
*
self
=
=
Self
:
:
start
(
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
ToTyped
)
]
#
[
css
(
bitflags
(
mixed
=
"
row
column
dense
"
validate_mixed
=
"
Self
:
:
validate_and_simplify
"
)
)
]
#
[
repr
(
C
)
]
pub
struct
GridAutoFlow
(
u8
)
;
bitflags
!
{
impl
GridAutoFlow
:
u8
{
/
/
/
'
row
'
-
mutually
exclusive
with
'
column
'
const
ROW
=
1
<
<
0
;
/
/
/
'
column
'
-
mutually
exclusive
with
'
row
'
const
COLUMN
=
1
<
<
1
;
/
/
/
'
dense
'
const
DENSE
=
1
<
<
2
;
}
}
impl
GridAutoFlow
{
fn
validate_and_simplify
(
&
mut
self
)
-
>
bool
{
if
self
.
contains
(
Self
:
:
ROW
|
Self
:
:
COLUMN
)
{
return
false
;
}
if
*
self
=
=
Self
:
:
DENSE
{
self
.
insert
(
Self
:
:
ROW
)
;
}
true
}
}
impl
ToCss
for
GridAutoFlow
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
let
dense
=
self
.
intersects
(
Self
:
:
DENSE
)
;
if
self
.
intersects
(
Self
:
:
ROW
)
{
return
if
dense
{
dest
.
write_str
(
"
dense
"
)
}
else
{
dest
.
write_str
(
"
row
"
)
}
;
}
debug_assert
!
(
self
.
intersects
(
Self
:
:
COLUMN
)
)
;
if
dense
{
dest
.
write_str
(
"
column
dense
"
)
}
else
{
dest
.
write_str
(
"
column
"
)
}
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
pub
enum
MasonryPlacement
{
Pack
Next
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
pub
enum
MasonryItemOrder
{
DefiniteFirst
Ordered
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
ToTyped
)
]
#
[
repr
(
C
)
]
pub
struct
MasonryAutoFlow
{
#
[
css
(
contextual_skip_if
=
"
is_pack_with_non_default_order
"
)
]
pub
placement
:
MasonryPlacement
#
[
css
(
skip_if
=
"
is_item_order_definite_first
"
)
]
pub
order
:
MasonryItemOrder
}
#
[
inline
]
fn
is_pack_with_non_default_order
(
placement
:
&
MasonryPlacement
order
:
&
MasonryItemOrder
)
-
>
bool
{
*
placement
=
=
MasonryPlacement
:
:
Pack
&
&
*
order
!
=
MasonryItemOrder
:
:
DefiniteFirst
}
#
[
inline
]
fn
is_item_order_definite_first
(
order
:
&
MasonryItemOrder
)
-
>
bool
{
*
order
=
=
MasonryItemOrder
:
:
DefiniteFirst
}
impl
MasonryAutoFlow
{
#
[
inline
]
pub
fn
initial
(
)
-
>
MasonryAutoFlow
{
MasonryAutoFlow
{
placement
:
MasonryPlacement
:
:
Pack
order
:
MasonryItemOrder
:
:
DefiniteFirst
}
}
}
impl
Parse
for
MasonryAutoFlow
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
MasonryAutoFlow
ParseError
<
'
i
>
>
{
let
mut
value
=
MasonryAutoFlow
:
:
initial
(
)
;
let
mut
got_placement
=
false
;
let
mut
got_order
=
false
;
while
!
input
.
is_exhausted
(
)
{
let
location
=
input
.
current_source_location
(
)
;
let
ident
=
input
.
expect_ident
(
)
?
;
let
success
=
match_ignore_ascii_case
!
{
&
ident
"
pack
"
if
!
got_placement
=
>
{
got_placement
=
true
;
true
}
"
next
"
if
!
got_placement
=
>
{
value
.
placement
=
MasonryPlacement
:
:
Next
;
got_placement
=
true
;
true
}
"
definite
-
first
"
if
!
got_order
=
>
{
got_order
=
true
;
true
}
"
ordered
"
if
!
got_order
=
>
{
value
.
order
=
MasonryItemOrder
:
:
Ordered
;
got_order
=
true
;
true
}
_
=
>
false
}
;
if
!
success
{
return
Err
(
location
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnexpectedIdent
(
ident
.
clone
(
)
)
)
)
;
}
}
if
got_placement
|
|
got_order
{
Ok
(
value
)
}
else
{
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
TemplateAreas
{
#
[
css
(
skip
)
]
pub
areas
:
crate
:
:
OwnedSlice
<
NamedArea
>
#
[
css
(
iterable
)
]
pub
strings
:
crate
:
:
OwnedSlice
<
crate
:
:
OwnedStr
>
#
[
css
(
skip
)
]
pub
width
:
u32
}
#
[
derive
(
Default
)
]
pub
struct
TemplateAreasParser
{
areas
:
Vec
<
NamedArea
>
area_indices
:
PrecomputedHashMap
<
Atom
usize
>
strings
:
Vec
<
crate
:
:
OwnedStr
>
width
:
u32
row
:
u32
}
impl
TemplateAreasParser
{
pub
fn
try_parse_string
<
'
i
>
(
&
mut
self
input
:
&
mut
Parser
<
'
i
'
_
>
)
-
>
Result
<
(
)
ParseError
<
'
i
>
>
{
input
.
try_parse
(
|
input
|
{
self
.
parse_string
(
input
.
expect_string
(
)
?
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
)
}
fn
parse_string
(
&
mut
self
string
:
&
str
)
-
>
Result
<
(
)
(
)
>
{
self
.
row
+
=
1
;
let
mut
simplified_string
=
String
:
:
new
(
)
;
let
mut
current_area_index
:
Option
<
usize
>
=
None
;
let
mut
column
=
0u32
;
for
token
in
TemplateAreasTokenizer
(
string
)
{
column
+
=
1
;
if
column
>
1
{
simplified_string
.
push
(
'
'
)
;
}
let
name
=
if
let
Some
(
token
)
=
token
?
{
simplified_string
.
push_str
(
token
)
;
Atom
:
:
from
(
token
)
}
else
{
if
let
Some
(
index
)
=
current_area_index
.
take
(
)
{
if
self
.
areas
[
index
]
.
columns
.
end
!
=
column
{
return
Err
(
(
)
)
;
}
}
simplified_string
.
push
(
'
.
'
)
;
continue
;
}
;
if
let
Some
(
index
)
=
current_area_index
{
if
self
.
areas
[
index
]
.
name
=
=
name
{
if
self
.
areas
[
index
]
.
rows
.
start
=
=
self
.
row
{
self
.
areas
[
index
]
.
columns
.
end
+
=
1
;
}
continue
;
}
if
self
.
areas
[
index
]
.
columns
.
end
!
=
column
{
return
Err
(
(
)
)
;
}
}
match
self
.
area_indices
.
entry
(
name
)
{
Entry
:
:
Occupied
(
ref
e
)
=
>
{
let
index
=
*
e
.
get
(
)
;
if
self
.
areas
[
index
]
.
columns
.
start
!
=
column
|
|
self
.
areas
[
index
]
.
rows
.
end
!
=
self
.
row
{
return
Err
(
(
)
)
;
}
self
.
areas
[
index
]
.
rows
.
end
+
=
1
;
current_area_index
=
Some
(
index
)
;
}
Entry
:
:
Vacant
(
v
)
=
>
{
let
index
=
self
.
areas
.
len
(
)
;
let
name
=
v
.
key
(
)
.
clone
(
)
;
v
.
insert
(
index
)
;
self
.
areas
.
push
(
NamedArea
{
name
columns
:
UnsignedRange
{
start
:
column
end
:
column
+
1
}
rows
:
UnsignedRange
{
start
:
self
.
row
end
:
self
.
row
+
1
}
}
)
;
current_area_index
=
Some
(
index
)
;
}
}
}
if
column
=
=
0
{
return
Err
(
(
)
)
;
}
if
let
Some
(
index
)
=
current_area_index
{
if
self
.
areas
[
index
]
.
columns
.
end
!
=
column
+
1
{
debug_assert_ne
!
(
self
.
areas
[
index
]
.
rows
.
start
self
.
row
)
;
return
Err
(
(
)
)
;
}
}
if
self
.
row
=
=
1
{
self
.
width
=
column
;
}
else
if
self
.
width
!
=
column
{
return
Err
(
(
)
)
;
}
self
.
strings
.
push
(
simplified_string
.
into
(
)
)
;
Ok
(
(
)
)
}
pub
fn
finish
(
self
)
-
>
Result
<
TemplateAreas
(
)
>
{
if
self
.
strings
.
is_empty
(
)
{
return
Err
(
(
)
)
;
}
Ok
(
TemplateAreas
{
areas
:
self
.
areas
.
into
(
)
strings
:
self
.
strings
.
into
(
)
width
:
self
.
width
}
)
}
}
impl
TemplateAreas
{
fn
parse_internal
(
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
let
mut
parser
=
TemplateAreasParser
:
:
default
(
)
;
while
parser
.
try_parse_string
(
input
)
.
is_ok
(
)
{
}
parser
.
finish
(
)
}
}
impl
Parse
for
TemplateAreas
{
fn
parse
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
input
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
transparent
)
]
pub
struct
TemplateAreasArc
(
#
[
ignore_malloc_size_of
=
"
Arc
"
]
pub
Arc
<
TemplateAreas
>
)
;
impl
Parse
for
TemplateAreasArc
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
parsed
=
TemplateAreas
:
:
parse
(
context
input
)
?
;
Ok
(
TemplateAreasArc
(
Arc
:
:
new
(
parsed
)
)
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
pub
struct
UnsignedRange
{
pub
start
:
u32
pub
end
:
u32
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
NamedArea
{
pub
name
:
Atom
pub
rows
:
UnsignedRange
pub
columns
:
UnsignedRange
}
struct
TemplateAreasTokenizer
<
'
a
>
(
&
'
a
str
)
;
impl
<
'
a
>
Iterator
for
TemplateAreasTokenizer
<
'
a
>
{
type
Item
=
Result
<
Option
<
&
'
a
str
>
(
)
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
rest
=
self
.
0
.
trim_start_matches
(
HTML_SPACE_CHARACTERS
)
;
if
rest
.
is_empty
(
)
{
return
None
;
}
if
rest
.
starts_with
(
'
.
'
)
{
self
.
0
=
&
rest
[
rest
.
find
(
|
c
|
c
!
=
'
.
'
)
.
unwrap_or
(
rest
.
len
(
)
)
.
.
]
;
return
Some
(
Ok
(
None
)
)
;
}
if
!
rest
.
starts_with
(
is_name_code_point
)
{
return
Some
(
Err
(
(
)
)
)
;
}
let
token_len
=
rest
.
find
(
|
c
|
!
is_name_code_point
(
c
)
)
.
unwrap_or
(
rest
.
len
(
)
)
;
let
token
=
&
rest
[
.
.
token_len
]
;
self
.
0
=
&
rest
[
token_len
.
.
]
;
Some
(
Ok
(
Some
(
token
)
)
)
}
}
fn
is_name_code_point
(
c
:
char
)
-
>
bool
{
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
|
|
c
>
=
'
a
'
&
&
c
<
=
'
z
'
|
|
c
>
=
'
\
u
{
80
}
'
|
|
c
=
=
'
_
'
|
|
c
>
=
'
0
'
&
&
c
<
=
'
9
'
|
|
c
=
=
'
-
'
}
#
[
repr
(
C
u8
)
]
#
[
derive
(
Clone
Debug
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
ToTyped
)
]
pub
enum
GridTemplateAreas
{
None
Areas
(
TemplateAreasArc
)
}
impl
GridTemplateAreas
{
#
[
inline
]
pub
fn
none
(
)
-
>
GridTemplateAreas
{
GridTemplateAreas
:
:
None
}
}
pub
type
ZIndex
=
GenericZIndex
<
Integer
>
;
pub
type
AspectRatio
=
GenericAspectRatio
<
NonNegativeNumber
>
;
impl
Parse
for
AspectRatio
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
use
crate
:
:
values
:
:
generics
:
:
position
:
:
PreferredRatio
;
use
crate
:
:
values
:
:
specified
:
:
Ratio
;
let
location
=
input
.
current_source_location
(
)
;
let
mut
auto
=
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
auto
"
)
)
;
let
ratio
=
input
.
try_parse
(
|
i
|
Ratio
:
:
parse
(
context
i
)
)
;
if
auto
.
is_err
(
)
{
auto
=
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
auto
"
)
)
;
}
if
auto
.
is_err
(
)
&
&
ratio
.
is_err
(
)
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
Ok
(
AspectRatio
{
auto
:
auto
.
is_ok
(
)
ratio
:
match
ratio
{
Ok
(
ratio
)
=
>
PreferredRatio
:
:
Ratio
(
ratio
)
Err
(
.
.
)
=
>
PreferredRatio
:
:
None
}
}
)
}
}
impl
AspectRatio
{
pub
fn
from_mapped_ratio
(
w
:
f32
h
:
f32
)
-
>
Self
{
use
crate
:
:
values
:
:
generics
:
:
position
:
:
PreferredRatio
;
use
crate
:
:
values
:
:
generics
:
:
ratio
:
:
Ratio
;
AspectRatio
{
auto
:
true
ratio
:
PreferredRatio
:
:
Ratio
(
Ratio
(
NonNegativeNumber
:
:
new
(
w
)
NonNegativeNumber
:
:
new
(
h
)
)
)
}
}
}
pub
type
Inset
=
GenericInset
<
specified
:
:
Percentage
LengthPercentage
>
;
impl
Inset
{
#
[
inline
]
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
l
)
=
input
.
try_parse
(
|
i
|
LengthPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
{
return
Ok
(
Self
:
:
LengthPercentage
(
l
)
)
;
}
match
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
auto
"
)
)
{
Ok
(
_
)
=
>
return
Ok
(
Self
:
:
Auto
)
Err
(
e
)
if
!
static_prefs
:
:
pref
!
(
"
layout
.
css
.
anchor
-
positioning
.
enabled
"
)
=
>
{
return
Err
(
e
.
into
(
)
)
}
Err
(
_
)
=
>
(
)
}
;
Self
:
:
parse_anchor_functions_quirky
(
context
input
allow_quirks
)
}
fn
parse_as_anchor_function_fallback
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
l
)
=
input
.
try_parse
(
|
i
|
LengthPercentage
:
:
parse_quirky
(
context
i
AllowQuirks
:
:
No
)
)
{
return
Ok
(
Self
:
:
LengthPercentage
(
l
)
)
;
}
Self
:
:
parse_anchor_functions_quirky
(
context
input
AllowQuirks
:
:
No
)
}
fn
parse_anchor_functions_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
debug_assert
!
(
static_prefs
:
:
pref
!
(
"
layout
.
css
.
anchor
-
positioning
.
enabled
"
)
"
How
are
we
parsing
with
pref
off
?
"
)
;
if
let
Ok
(
inner
)
=
input
.
try_parse
(
|
i
|
AnchorFunction
:
:
parse
(
context
i
)
)
{
return
Ok
(
Self
:
:
AnchorFunction
(
Box
:
:
new
(
inner
)
)
)
;
}
if
let
Ok
(
inner
)
=
input
.
try_parse
(
|
i
|
GenericAnchorSizeFunction
:
:
<
Inset
>
:
:
parse
(
context
i
)
)
{
return
Ok
(
Self
:
:
AnchorSizeFunction
(
Box
:
:
new
(
inner
)
)
)
;
}
Ok
(
Self
:
:
AnchorContainingCalcFunction
(
input
.
try_parse
(
|
i
|
LengthPercentage
:
:
parse_quirky_with_anchor_functions
(
context
i
allow_quirks
)
)
?
)
)
}
}
impl
Parse
for
Inset
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
No
)
}
}
pub
type
AnchorFunction
=
GenericAnchorFunction
<
specified
:
:
Percentage
Inset
>
;
impl
Parse
for
AnchorFunction
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
!
static_prefs
:
:
pref
!
(
"
layout
.
css
.
anchor
-
positioning
.
enabled
"
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
input
.
expect_function_matching
(
"
anchor
"
)
?
;
input
.
parse_nested_block
(
|
i
|
{
let
target_element
=
i
.
try_parse
(
|
i
|
DashedIdent
:
:
parse
(
context
i
)
)
.
ok
(
)
;
let
side
=
GenericAnchorSide
:
:
parse
(
context
i
)
?
;
let
target_element
=
if
target_element
.
is_none
(
)
{
i
.
try_parse
(
|
i
|
DashedIdent
:
:
parse
(
context
i
)
)
.
ok
(
)
}
else
{
target_element
}
;
let
fallback
=
i
.
try_parse
(
|
i
|
{
i
.
expect_comma
(
)
?
;
Inset
:
:
parse_as_anchor_function_fallback
(
context
i
)
}
)
.
ok
(
)
;
Ok
(
Self
{
target_element
:
target_element
.
unwrap_or_else
(
DashedIdent
:
:
empty
)
side
fallback
:
fallback
.
into
(
)
}
)
}
)
}
}
