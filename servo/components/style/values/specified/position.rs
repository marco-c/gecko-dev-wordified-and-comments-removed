use
cssparser
:
:
Parser
;
use
hash
:
:
FnvHashMap
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
selectors
:
:
parser
:
:
SelectorParseErrorKind
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
ops
:
:
Range
;
use
str
:
:
HTML_SPACE_CHARACTERS
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
use
values
:
:
{
Either
None_
}
;
use
values
:
:
computed
:
:
{
CalcLengthOrPercentage
LengthOrPercentage
as
ComputedLengthOrPercentage
}
;
use
values
:
:
computed
:
:
{
Context
Percentage
ToComputedValue
}
;
use
values
:
:
generics
:
:
position
:
:
Position
as
GenericPosition
;
use
values
:
:
generics
:
:
position
:
:
ZIndex
as
GenericZIndex
;
use
values
:
:
specified
:
:
{
AllowQuirks
Integer
LengthOrPercentage
}
;
use
values
:
:
specified
:
:
transform
:
:
OriginComponent
;
pub
type
Position
=
GenericPosition
<
HorizontalPosition
VerticalPosition
>
;
pub
type
HorizontalPosition
=
PositionComponent
<
X
>
;
pub
type
VerticalPosition
=
PositionComponent
<
Y
>
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToCss
)
]
pub
enum
PositionComponent
<
S
>
{
Center
Length
(
LengthOrPercentage
)
Side
(
S
Option
<
LengthOrPercentage
>
)
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
X
{
Left
Right
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
Y
{
Top
Bottom
}
impl
Parse
for
Position
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
No
)
}
}
impl
Position
{
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
match
input
.
try
(
|
i
|
PositionComponent
:
:
parse_quirky
(
context
i
allow_quirks
)
)
{
Ok
(
x_pos
PositionComponent
:
:
Center
)
=
>
{
if
let
Ok
(
y_pos
)
=
input
.
try
(
|
i
|
PositionComponent
:
:
parse_quirky
(
context
i
allow_quirks
)
)
{
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
let
x_pos
=
input
.
try
(
|
i
|
PositionComponent
:
:
parse_quirky
(
context
i
allow_quirks
)
)
.
unwrap_or
(
x_pos
)
;
let
y_pos
=
PositionComponent
:
:
Center
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
Ok
(
PositionComponent
:
:
Side
(
x_keyword
lop
)
)
=
>
{
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
center
"
)
)
.
is_ok
(
)
{
let
x_pos
=
PositionComponent
:
:
Side
(
x_keyword
lop
)
;
let
y_pos
=
PositionComponent
:
:
Center
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
if
let
Ok
(
y_keyword
)
=
input
.
try
(
Y
:
:
parse
)
{
let
y_lop
=
input
.
try
(
|
i
|
LengthOrPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
.
ok
(
)
;
let
x_pos
=
PositionComponent
:
:
Side
(
x_keyword
lop
)
;
let
y_pos
=
PositionComponent
:
:
Side
(
y_keyword
y_lop
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
let
x_pos
=
PositionComponent
:
:
Side
(
x_keyword
None
)
;
let
y_pos
=
lop
.
map_or
(
PositionComponent
:
:
Center
PositionComponent
:
:
Length
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
Ok
(
x_pos
PositionComponent
:
:
Length
(
_
)
)
=
>
{
if
let
Ok
(
y_keyword
)
=
input
.
try
(
Y
:
:
parse
)
{
let
y_pos
=
PositionComponent
:
:
Side
(
y_keyword
None
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
if
let
Ok
(
y_lop
)
=
input
.
try
(
|
i
|
LengthOrPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
{
let
y_pos
=
PositionComponent
:
:
Length
(
y_lop
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
let
y_pos
=
PositionComponent
:
:
Center
;
let
_
=
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
center
"
)
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
Err
(
_
)
=
>
{
}
}
let
y_keyword
=
Y
:
:
parse
(
input
)
?
;
let
lop_and_x_pos
:
Result
<
_
ParseError
>
=
input
.
try
(
|
i
|
{
let
y_lop
=
i
.
try
(
|
i
|
LengthOrPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
.
ok
(
)
;
if
let
Ok
(
x_keyword
)
=
i
.
try
(
X
:
:
parse
)
{
let
x_lop
=
i
.
try
(
|
i
|
LengthOrPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
.
ok
(
)
;
let
x_pos
=
PositionComponent
:
:
Side
(
x_keyword
x_lop
)
;
return
Ok
(
(
y_lop
x_pos
)
)
;
}
;
i
.
expect_ident_matching
(
"
center
"
)
?
;
let
x_pos
=
PositionComponent
:
:
Center
;
Ok
(
(
y_lop
x_pos
)
)
}
)
;
if
let
Ok
(
(
y_lop
x_pos
)
)
=
lop_and_x_pos
{
let
y_pos
=
PositionComponent
:
:
Side
(
y_keyword
y_lop
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
let
x_pos
=
PositionComponent
:
:
Center
;
let
y_pos
=
PositionComponent
:
:
Side
(
y_keyword
None
)
;
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
}
#
[
inline
]
pub
fn
center
(
)
-
>
Self
{
Self
:
:
new
(
PositionComponent
:
:
Center
PositionComponent
:
:
Center
)
}
}
impl
ToCss
for
Position
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
(
&
self
.
horizontal
&
self
.
vertical
)
{
(
x_pos
&
PositionComponent
:
:
Side
(
_
Some
(
_
)
)
&
PositionComponent
:
:
Length
(
ref
y_lop
)
)
=
>
{
x_pos
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
top
"
)
?
;
y_lop
.
to_css
(
dest
)
}
(
&
PositionComponent
:
:
Length
(
ref
x_lop
)
y_pos
&
PositionComponent
:
:
Side
(
_
Some
(
_
)
)
)
=
>
{
dest
.
write_str
(
"
left
"
)
?
;
x_lop
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
y_pos
.
to_css
(
dest
)
}
(
x_pos
y_pos
)
=
>
{
x_pos
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
y_pos
.
to_css
(
dest
)
}
}
}
}
impl
<
S
:
Parse
>
Parse
for
PositionComponent
<
S
>
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
No
)
}
}
impl
<
S
:
Parse
>
PositionComponent
<
S
>
{
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
center
"
)
)
.
is_ok
(
)
{
return
Ok
(
PositionComponent
:
:
Center
)
;
}
if
let
Ok
(
lop
)
=
input
.
try
(
|
i
|
LengthOrPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
{
return
Ok
(
PositionComponent
:
:
Length
(
lop
)
)
;
}
let
keyword
=
S
:
:
parse
(
context
input
)
?
;
let
lop
=
input
.
try
(
|
i
|
LengthOrPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
.
ok
(
)
;
Ok
(
PositionComponent
:
:
Side
(
keyword
lop
)
)
}
}
impl
<
S
>
PositionComponent
<
S
>
{
pub
fn
zero
(
)
-
>
Self
{
PositionComponent
:
:
Length
(
LengthOrPercentage
:
:
Percentage
(
Percentage
:
:
zero
(
)
)
)
}
}
impl
<
S
:
Side
>
ToComputedValue
for
PositionComponent
<
S
>
{
type
ComputedValue
=
ComputedLengthOrPercentage
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
match
*
self
{
PositionComponent
:
:
Center
=
>
ComputedLengthOrPercentage
:
:
Percentage
(
Percentage
(
0
.
5
)
)
PositionComponent
:
:
Side
(
ref
keyword
None
)
=
>
{
let
p
=
Percentage
(
if
keyword
.
is_start
(
)
{
0
.
}
else
{
1
.
}
)
;
ComputedLengthOrPercentage
:
:
Percentage
(
p
)
}
PositionComponent
:
:
Side
(
ref
keyword
Some
(
ref
length
)
)
if
!
keyword
.
is_start
(
)
=
>
{
match
length
.
to_computed_value
(
context
)
{
ComputedLengthOrPercentage
:
:
Length
(
length
)
=
>
ComputedLengthOrPercentage
:
:
Calc
(
CalcLengthOrPercentage
:
:
new
(
-
length
Some
(
Percentage
:
:
hundred
(
)
)
)
)
ComputedLengthOrPercentage
:
:
Percentage
(
p
)
=
>
{
ComputedLengthOrPercentage
:
:
Percentage
(
Percentage
(
1
.
0
-
p
.
0
)
)
}
ComputedLengthOrPercentage
:
:
Calc
(
calc
)
=
>
{
let
p
=
Percentage
(
1
.
-
calc
.
percentage
.
map_or
(
0
.
|
p
|
p
.
0
)
)
;
let
l
=
-
calc
.
unclamped_length
(
)
;
ComputedLengthOrPercentage
:
:
Calc
(
CalcLengthOrPercentage
:
:
new
(
l
Some
(
p
)
)
)
}
}
}
PositionComponent
:
:
Side
(
_
Some
(
ref
length
)
)
|
PositionComponent
:
:
Length
(
ref
length
)
=
>
length
.
to_computed_value
(
context
)
}
}
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
PositionComponent
:
:
Length
(
ToComputedValue
:
:
from_computed_value
(
computed
)
)
}
}
impl
<
S
:
Side
>
PositionComponent
<
S
>
{
pub
fn
initial_specified_value
(
)
-
>
Self
{
PositionComponent
:
:
Side
(
S
:
:
start
(
)
None
)
}
}
pub
trait
Side
{
fn
start
(
)
-
>
Self
;
fn
is_start
(
&
self
)
-
>
bool
;
}
impl
Side
for
X
{
#
[
inline
]
fn
start
(
)
-
>
Self
{
X
:
:
Left
}
#
[
inline
]
fn
is_start
(
&
self
)
-
>
bool
{
*
self
=
=
X
:
:
Left
}
}
impl
Side
for
Y
{
#
[
inline
]
fn
start
(
)
-
>
Self
{
Y
:
:
Top
}
#
[
inline
]
fn
is_start
(
&
self
)
-
>
bool
{
*
self
=
=
Y
:
:
Top
}
}
pub
type
LegacyPosition
=
GenericPosition
<
LegacyHPosition
LegacyVPosition
>
;
pub
type
LegacyHPosition
=
OriginComponent
<
X
>
;
pub
type
LegacyVPosition
=
OriginComponent
<
Y
>
;
impl
Parse
for
LegacyPosition
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_quirky
(
context
input
AllowQuirks
:
:
No
)
}
}
impl
LegacyPosition
{
pub
fn
parse_quirky
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_quirks
:
AllowQuirks
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
match
input
.
try
(
|
i
|
OriginComponent
:
:
parse
(
context
i
)
)
{
Ok
(
x_pos
OriginComponent
:
:
Center
)
=
>
{
if
let
Ok
(
y_pos
)
=
input
.
try
(
|
i
|
OriginComponent
:
:
parse
(
context
i
)
)
{
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
let
x_pos
=
input
.
try
(
|
i
|
OriginComponent
:
:
parse
(
context
i
)
)
.
unwrap_or
(
x_pos
)
;
let
y_pos
=
OriginComponent
:
:
Center
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
Ok
(
OriginComponent
:
:
Side
(
x_keyword
)
)
=
>
{
if
let
Ok
(
y_keyword
)
=
input
.
try
(
Y
:
:
parse
)
{
let
x_pos
=
OriginComponent
:
:
Side
(
x_keyword
)
;
let
y_pos
=
OriginComponent
:
:
Side
(
y_keyword
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
let
x_pos
=
OriginComponent
:
:
Side
(
x_keyword
)
;
if
let
Ok
(
y_lop
)
=
input
.
try
(
|
i
|
LengthOrPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
{
return
Ok
(
Self
:
:
new
(
x_pos
OriginComponent
:
:
Length
(
y_lop
)
)
)
;
}
let
_
=
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
center
"
)
)
;
return
Ok
(
Self
:
:
new
(
x_pos
OriginComponent
:
:
Center
)
)
;
}
Ok
(
x_pos
OriginComponent
:
:
Length
(
_
)
)
=
>
{
if
let
Ok
(
y_keyword
)
=
input
.
try
(
Y
:
:
parse
)
{
let
y_pos
=
OriginComponent
:
:
Side
(
y_keyword
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
if
let
Ok
(
y_lop
)
=
input
.
try
(
|
i
|
LengthOrPercentage
:
:
parse_quirky
(
context
i
allow_quirks
)
)
{
let
y_pos
=
OriginComponent
:
:
Length
(
y_lop
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
let
_
=
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
center
"
)
)
;
return
Ok
(
Self
:
:
new
(
x_pos
OriginComponent
:
:
Center
)
)
;
}
Err
(
_
)
=
>
{
}
}
let
y_keyword
=
Y
:
:
parse
(
input
)
?
;
let
x_pos
:
Result
<
_
ParseError
>
=
input
.
try
(
|
i
|
{
if
let
Ok
(
x_keyword
)
=
i
.
try
(
X
:
:
parse
)
{
let
x_pos
=
OriginComponent
:
:
Side
(
x_keyword
)
;
return
Ok
(
x_pos
)
;
}
i
.
expect_ident_matching
(
"
center
"
)
?
;
Ok
(
OriginComponent
:
:
Center
)
}
)
;
if
let
Ok
(
x_pos
)
=
x_pos
{
let
y_pos
=
OriginComponent
:
:
Side
(
y_keyword
)
;
return
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
;
}
let
x_pos
=
OriginComponent
:
:
Center
;
let
y_pos
=
OriginComponent
:
:
Side
(
y_keyword
)
;
Ok
(
Self
:
:
new
(
x_pos
y_pos
)
)
}
#
[
inline
]
pub
fn
center
(
)
-
>
Self
{
Self
:
:
new
(
OriginComponent
:
:
Center
OriginComponent
:
:
Center
)
}
}
impl
ToCss
for
LegacyPosition
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
horizontal
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
self
.
vertical
.
to_css
(
dest
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
enum
AutoFlow
{
Row
Column
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
)
]
pub
struct
GridAutoFlow
{
pub
autoflow
:
AutoFlow
pub
dense
:
bool
}
impl
GridAutoFlow
{
#
[
inline
]
pub
fn
row
(
)
-
>
GridAutoFlow
{
GridAutoFlow
{
autoflow
:
AutoFlow
:
:
Row
dense
:
false
}
}
}
impl
ToCss
for
GridAutoFlow
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
autoflow
.
to_css
(
dest
)
?
;
if
self
.
dense
{
dest
.
write_str
(
"
dense
"
)
?
;
}
Ok
(
(
)
)
}
}
impl
Parse
for
GridAutoFlow
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
GridAutoFlow
ParseError
<
'
i
>
>
{
let
mut
value
=
None
;
let
mut
dense
=
false
;
while
!
input
.
is_exhausted
(
)
{
let
location
=
input
.
current_source_location
(
)
;
let
ident
=
input
.
expect_ident
(
)
?
;
let
success
=
match_ignore_ascii_case
!
{
&
ident
"
row
"
if
value
.
is_none
(
)
=
>
{
value
=
Some
(
AutoFlow
:
:
Row
)
;
true
}
"
column
"
if
value
.
is_none
(
)
=
>
{
value
=
Some
(
AutoFlow
:
:
Column
)
;
true
}
"
dense
"
if
!
dense
=
>
{
dense
=
true
;
true
}
_
=
>
false
}
;
if
!
success
{
return
Err
(
location
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnexpectedIdent
(
ident
.
clone
(
)
)
)
)
;
}
}
if
value
.
is_some
(
)
|
|
dense
{
Ok
(
GridAutoFlow
{
autoflow
:
value
.
unwrap_or
(
AutoFlow
:
:
Row
)
dense
:
dense
}
)
}
else
{
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
u8
>
for
GridAutoFlow
{
fn
from
(
bits
:
u8
)
-
>
GridAutoFlow
{
use
gecko_bindings
:
:
structs
;
GridAutoFlow
{
autoflow
:
if
bits
&
structs
:
:
NS_STYLE_GRID_AUTO_FLOW_ROW
as
u8
!
=
0
{
AutoFlow
:
:
Row
}
else
{
AutoFlow
:
:
Column
}
dense
:
bits
&
structs
:
:
NS_STYLE_GRID_AUTO_FLOW_DENSE
as
u8
!
=
0
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
GridAutoFlow
>
for
u8
{
fn
from
(
v
:
GridAutoFlow
)
-
>
u8
{
use
gecko_bindings
:
:
structs
;
let
mut
result
:
u8
=
match
v
.
autoflow
{
AutoFlow
:
:
Row
=
>
structs
:
:
NS_STYLE_GRID_AUTO_FLOW_ROW
as
u8
AutoFlow
:
:
Column
=
>
structs
:
:
NS_STYLE_GRID_AUTO_FLOW_COLUMN
as
u8
}
;
if
v
.
dense
{
result
|
=
structs
:
:
NS_STYLE_GRID_AUTO_FLOW_DENSE
as
u8
;
}
result
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
struct
TemplateAreas
{
#
[
css
(
skip
)
]
pub
areas
:
Box
<
[
NamedArea
]
>
#
[
css
(
iterable
)
]
pub
strings
:
Box
<
[
Box
<
str
>
]
>
#
[
css
(
skip
)
]
pub
width
:
u32
}
impl
TemplateAreas
{
pub
fn
from_vec
(
strings
:
Vec
<
Box
<
str
>
>
)
-
>
Result
<
TemplateAreas
(
)
>
{
if
strings
.
is_empty
(
)
{
return
Err
(
(
)
)
;
}
let
mut
areas
:
Vec
<
NamedArea
>
=
vec
!
[
]
;
let
mut
width
=
0
;
{
let
mut
row
=
0u32
;
let
mut
area_indices
=
FnvHashMap
:
:
<
&
str
usize
>
:
:
default
(
)
;
for
string
in
&
strings
{
let
mut
current_area_index
:
Option
<
usize
>
=
None
;
row
+
=
1
;
let
mut
column
=
0u32
;
for
token
in
TemplateAreasTokenizer
(
string
)
{
column
+
=
1
;
let
token
=
if
let
Some
(
token
)
=
token
?
{
token
}
else
{
if
let
Some
(
index
)
=
current_area_index
.
take
(
)
{
if
areas
[
index
]
.
columns
.
end
!
=
column
{
return
Err
(
(
)
)
;
}
}
continue
;
}
;
if
let
Some
(
index
)
=
current_area_index
{
if
&
*
areas
[
index
]
.
name
=
=
token
{
if
areas
[
index
]
.
rows
.
start
=
=
row
{
areas
[
index
]
.
columns
.
end
+
=
1
;
}
continue
;
}
if
areas
[
index
]
.
columns
.
end
!
=
column
{
return
Err
(
(
)
)
;
}
}
if
let
Some
(
index
)
=
area_indices
.
get
(
token
)
.
cloned
(
)
{
if
areas
[
index
]
.
columns
.
start
!
=
column
|
|
areas
[
index
]
.
rows
.
end
!
=
row
{
return
Err
(
(
)
)
;
}
areas
[
index
]
.
rows
.
end
+
=
1
;
current_area_index
=
Some
(
index
)
;
continue
;
}
let
index
=
areas
.
len
(
)
;
areas
.
push
(
NamedArea
{
name
:
token
.
to_owned
(
)
.
into_boxed_str
(
)
columns
:
column
.
.
(
column
+
1
)
rows
:
row
.
.
(
row
+
1
)
}
)
;
assert
!
(
area_indices
.
insert
(
token
index
)
.
is_none
(
)
)
;
current_area_index
=
Some
(
index
)
;
}
if
let
Some
(
index
)
=
current_area_index
{
if
areas
[
index
]
.
columns
.
end
!
=
column
+
1
{
assert_ne
!
(
areas
[
index
]
.
rows
.
start
row
)
;
return
Err
(
(
)
)
;
}
}
if
row
=
=
1
{
width
=
column
;
}
else
if
width
!
=
column
{
return
Err
(
(
)
)
;
}
}
}
Ok
(
TemplateAreas
{
areas
:
areas
.
into_boxed_slice
(
)
strings
:
strings
.
into_boxed_slice
(
)
width
:
width
}
)
}
}
impl
Parse
for
TemplateAreas
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
strings
=
vec
!
[
]
;
while
let
Ok
(
string
)
=
input
.
try
(
|
i
|
i
.
expect_string
(
)
.
map
(
|
s
|
s
.
as_ref
(
)
.
into
(
)
)
)
{
strings
.
push
(
string
)
;
}
TemplateAreas
:
:
from_vec
(
strings
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
struct
TemplateAreasArc
(
#
[
ignore_malloc_size_of
=
"
Arc
"
]
pub
Arc
<
TemplateAreas
>
)
;
impl
Parse
for
TemplateAreasArc
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
parsed
=
TemplateAreas
:
:
parse
(
context
input
)
?
;
Ok
(
TemplateAreasArc
(
Arc
:
:
new
(
parsed
)
)
)
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
SpecifiedValueInfo
)
]
pub
struct
NamedArea
{
pub
name
:
Box
<
str
>
pub
rows
:
Range
<
u32
>
pub
columns
:
Range
<
u32
>
}
struct
TemplateAreasTokenizer
<
'
a
>
(
&
'
a
str
)
;
impl
<
'
a
>
Iterator
for
TemplateAreasTokenizer
<
'
a
>
{
type
Item
=
Result
<
Option
<
&
'
a
str
>
(
)
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
rest
=
self
.
0
.
trim_left_matches
(
HTML_SPACE_CHARACTERS
)
;
if
rest
.
is_empty
(
)
{
return
None
;
}
if
rest
.
starts_with
(
'
.
'
)
{
self
.
0
=
&
rest
[
rest
.
find
(
|
c
|
c
!
=
'
.
'
)
.
unwrap_or
(
rest
.
len
(
)
)
.
.
]
;
return
Some
(
Ok
(
None
)
)
;
}
if
!
rest
.
starts_with
(
is_name_code_point
)
{
return
Some
(
Err
(
(
)
)
)
;
}
let
token_len
=
rest
.
find
(
|
c
|
!
is_name_code_point
(
c
)
)
.
unwrap_or
(
rest
.
len
(
)
)
;
let
token
=
&
rest
[
.
.
token_len
]
;
self
.
0
=
&
rest
[
token_len
.
.
]
;
Some
(
Ok
(
Some
(
token
)
)
)
}
}
fn
is_name_code_point
(
c
:
char
)
-
>
bool
{
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
|
|
c
>
=
'
a
'
&
&
c
<
=
'
z
'
|
|
c
>
=
'
\
u
{
80
}
'
|
|
c
=
=
'
_
'
|
|
c
>
=
'
0
'
&
&
c
<
=
'
9
'
|
|
c
=
=
'
-
'
}
pub
type
GridTemplateAreas
=
Either
<
TemplateAreasArc
None_
>
;
impl
GridTemplateAreas
{
#
[
inline
]
pub
fn
none
(
)
-
>
GridTemplateAreas
{
Either
:
:
Second
(
None_
)
}
}
pub
type
ZIndex
=
GenericZIndex
<
Integer
>
;
impl
Parse
for
ZIndex
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
auto
"
)
)
.
is_ok
(
)
{
return
Ok
(
GenericZIndex
:
:
Auto
)
;
}
Ok
(
GenericZIndex
:
:
Integer
(
Integer
:
:
parse
(
context
input
)
?
)
)
}
}
