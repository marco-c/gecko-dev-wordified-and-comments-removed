use
cssparser
:
:
{
Parser
Token
BasicParseError
}
;
use
parser
:
:
ParserContext
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
fmt
;
use
style_traits
:
:
{
ToCss
ParseError
StyleParseError
}
;
use
style_traits
:
:
values
:
:
specified
:
:
AllowedNumericType
;
use
values
:
:
{
CSSInteger
CSSFloat
}
;
use
values
:
:
computed
;
use
values
:
:
specified
:
:
{
Angle
Time
}
;
use
values
:
:
specified
:
:
length
:
:
{
AbsoluteLength
FontRelativeLength
NoCalcLength
}
;
use
values
:
:
specified
:
:
length
:
:
ViewportPercentageLength
;
#
[
derive
(
Clone
Debug
)
]
pub
enum
CalcNode
{
Length
(
NoCalcLength
)
Angle
(
Angle
)
Time
(
Time
)
Percentage
(
CSSFloat
)
Number
(
CSSFloat
)
Sum
(
Box
<
CalcNode
>
Box
<
CalcNode
>
)
Sub
(
Box
<
CalcNode
>
Box
<
CalcNode
>
)
Mul
(
Box
<
CalcNode
>
Box
<
CalcNode
>
)
Div
(
Box
<
CalcNode
>
Box
<
CalcNode
>
)
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
CalcUnit
{
Number
Integer
Length
Percentage
LengthOrPercentage
Angle
Time
}
#
[
derive
(
Clone
Copy
Debug
Default
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
CalcLengthOrPercentage
{
pub
clamping_mode
:
AllowedNumericType
pub
absolute
:
Option
<
AbsoluteLength
>
pub
vw
:
Option
<
CSSFloat
>
pub
vh
:
Option
<
CSSFloat
>
pub
vmin
:
Option
<
CSSFloat
>
pub
vmax
:
Option
<
CSSFloat
>
pub
em
:
Option
<
CSSFloat
>
pub
ex
:
Option
<
CSSFloat
>
pub
ch
:
Option
<
CSSFloat
>
pub
rem
:
Option
<
CSSFloat
>
pub
percentage
:
Option
<
computed
:
:
Percentage
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
mozmm
:
Option
<
CSSFloat
>
}
impl
ToCss
for
CalcLengthOrPercentage
{
#
[
allow
(
unused_assignments
)
]
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
use
num_traits
:
:
Zero
;
let
mut
first_value
=
true
;
macro_rules
!
first_value_check
{
(
val
:
expr
)
=
>
{
if
!
first_value
{
dest
.
write_str
(
if
val
<
Zero
:
:
zero
(
)
{
"
-
"
}
else
{
"
+
"
}
)
?
;
}
else
if
val
<
Zero
:
:
zero
(
)
{
dest
.
write_str
(
"
-
"
)
?
;
}
first_value
=
false
;
}
;
}
macro_rules
!
serialize
{
(
(
val
:
ident
)
*
)
=
>
{
(
if
let
Some
(
val
)
=
self
.
val
{
first_value_check
!
(
val
)
;
val
.
abs
(
)
.
to_css
(
dest
)
?
;
dest
.
write_str
(
stringify
!
(
val
)
)
?
;
}
)
*
}
;
}
macro_rules
!
serialize_abs
{
(
(
val
:
ident
)
+
)
=
>
{
(
if
let
Some
(
AbsoluteLength
:
:
val
(
v
)
)
=
self
.
absolute
{
first_value_check
!
(
v
)
;
AbsoluteLength
:
:
val
(
v
.
abs
(
)
)
.
to_css
(
dest
)
?
;
}
)
+
}
;
}
dest
.
write_str
(
"
calc
(
"
)
?
;
if
let
Some
(
val
)
=
self
.
percentage
{
first_value_check
!
(
val
.
0
)
;
val
.
abs
(
)
.
to_css
(
dest
)
?
;
}
serialize
!
(
ch
)
;
serialize_abs
!
(
Cm
)
;
serialize
!
(
em
ex
)
;
serialize_abs
!
(
In
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
serialize
!
(
mozmm
)
;
}
serialize_abs
!
(
Mm
Pc
Pt
Px
Q
)
;
serialize
!
(
rem
vh
vmax
vmin
vw
)
;
dest
.
write_str
(
"
)
"
)
}
}
impl
CalcNode
{
fn
parse_one
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
expected_unit
:
CalcUnit
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
match
(
input
.
next
(
)
?
expected_unit
)
{
(
&
Token
:
:
Number
{
value
.
.
}
_
)
=
>
return
Ok
(
CalcNode
:
:
Number
(
value
)
)
(
&
Token
:
:
Dimension
{
value
ref
unit
.
.
}
CalcUnit
:
:
Length
)
|
(
&
Token
:
:
Dimension
{
value
ref
unit
.
.
}
CalcUnit
:
:
LengthOrPercentage
)
=
>
{
return
NoCalcLength
:
:
parse_dimension
(
context
value
unit
)
.
map
(
CalcNode
:
:
Length
)
.
map_err
(
|
(
)
|
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
(
&
Token
:
:
Dimension
{
value
ref
unit
.
.
}
CalcUnit
:
:
Angle
)
=
>
{
return
Angle
:
:
parse_dimension
(
value
unit
true
)
.
map
(
CalcNode
:
:
Angle
)
.
map_err
(
|
(
)
|
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
(
&
Token
:
:
Dimension
{
value
ref
unit
.
.
}
CalcUnit
:
:
Time
)
=
>
{
return
Time
:
:
parse_dimension
(
value
unit
true
)
.
map
(
CalcNode
:
:
Time
)
.
map_err
(
|
(
)
|
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
(
&
Token
:
:
Percentage
{
unit_value
.
.
}
CalcUnit
:
:
LengthOrPercentage
)
|
(
&
Token
:
:
Percentage
{
unit_value
.
.
}
CalcUnit
:
:
Percentage
)
=
>
{
return
Ok
(
CalcNode
:
:
Percentage
(
unit_value
)
)
}
(
&
Token
:
:
ParenthesisBlock
_
)
=
>
{
}
(
&
Token
:
:
Function
(
ref
name
)
_
)
if
name
.
eq_ignore_ascii_case
(
"
calc
"
)
=
>
{
}
(
t
_
)
=
>
return
Err
(
BasicParseError
:
:
UnexpectedToken
(
t
.
clone
(
)
)
.
into
(
)
)
}
input
.
parse_nested_block
(
|
i
|
{
CalcNode
:
:
parse
(
context
i
expected_unit
)
}
)
}
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
expected_unit
:
CalcUnit
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
root
=
Self
:
:
parse_product
(
context
input
expected_unit
)
?
;
loop
{
let
start
=
input
.
state
(
)
;
match
input
.
next_including_whitespace
(
)
{
Ok
(
&
Token
:
:
WhiteSpace
(
_
)
)
=
>
{
if
input
.
is_exhausted
(
)
{
break
;
}
match
input
.
next
(
)
?
.
clone
(
)
{
Token
:
:
Delim
(
'
+
'
)
=
>
{
let
rhs
=
Self
:
:
parse_product
(
context
input
expected_unit
)
?
;
let
new_root
=
CalcNode
:
:
Sum
(
Box
:
:
new
(
root
)
Box
:
:
new
(
rhs
)
)
;
root
=
new_root
;
}
Token
:
:
Delim
(
'
-
'
)
=
>
{
let
rhs
=
Self
:
:
parse_product
(
context
input
expected_unit
)
?
;
let
new_root
=
CalcNode
:
:
Sub
(
Box
:
:
new
(
root
)
Box
:
:
new
(
rhs
)
)
;
root
=
new_root
;
}
t
=
>
return
Err
(
BasicParseError
:
:
UnexpectedToken
(
t
)
.
into
(
)
)
}
}
_
=
>
{
input
.
reset
(
&
start
)
;
break
}
}
}
Ok
(
root
)
}
fn
parse_product
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
expected_unit
:
CalcUnit
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
root
=
Self
:
:
parse_one
(
context
input
expected_unit
)
?
;
loop
{
let
start
=
input
.
state
(
)
;
match
input
.
next
(
)
{
Ok
(
&
Token
:
:
Delim
(
'
*
'
)
)
=
>
{
let
rhs
=
Self
:
:
parse_one
(
context
input
expected_unit
)
?
;
let
new_root
=
CalcNode
:
:
Mul
(
Box
:
:
new
(
root
)
Box
:
:
new
(
rhs
)
)
;
root
=
new_root
;
}
Ok
(
&
Token
:
:
Delim
(
'
/
'
)
)
if
expected_unit
!
=
CalcUnit
:
:
Integer
=
>
{
let
rhs
=
Self
:
:
parse_one
(
context
input
expected_unit
)
?
;
let
new_root
=
CalcNode
:
:
Div
(
Box
:
:
new
(
root
)
Box
:
:
new
(
rhs
)
)
;
root
=
new_root
;
}
_
=
>
{
input
.
reset
(
&
start
)
;
break
}
}
}
Ok
(
root
)
}
fn
to_length_or_percentage
(
&
self
clamping_mode
:
AllowedNumericType
)
-
>
Result
<
CalcLengthOrPercentage
(
)
>
{
let
mut
ret
=
CalcLengthOrPercentage
{
clamping_mode
:
clamping_mode
.
.
Default
:
:
default
(
)
}
;
self
.
add_length_or_percentage_to
(
&
mut
ret
1
.
0
)
?
;
Ok
(
ret
)
}
fn
to_percentage
(
&
self
)
-
>
Result
<
CSSFloat
(
)
>
{
Ok
(
match
*
self
{
CalcNode
:
:
Percentage
(
percentage
)
=
>
percentage
CalcNode
:
:
Sub
(
ref
a
ref
b
)
=
>
{
a
.
to_percentage
(
)
?
-
b
.
to_percentage
(
)
?
}
CalcNode
:
:
Sum
(
ref
a
ref
b
)
=
>
{
a
.
to_percentage
(
)
?
+
b
.
to_percentage
(
)
?
}
CalcNode
:
:
Mul
(
ref
a
ref
b
)
=
>
{
match
a
.
to_percentage
(
)
{
Ok
(
lhs
)
=
>
{
let
rhs
=
b
.
to_number
(
)
?
;
lhs
*
rhs
}
Err
(
.
.
)
=
>
{
let
lhs
=
a
.
to_number
(
)
?
;
let
rhs
=
b
.
to_percentage
(
)
?
;
lhs
*
rhs
}
}
}
CalcNode
:
:
Div
(
ref
a
ref
b
)
=
>
{
let
lhs
=
a
.
to_percentage
(
)
?
;
let
rhs
=
b
.
to_number
(
)
?
;
if
rhs
=
=
0
.
{
return
Err
(
(
)
)
}
lhs
/
rhs
}
CalcNode
:
:
Number
(
.
.
)
|
CalcNode
:
:
Length
(
.
.
)
|
CalcNode
:
:
Angle
(
.
.
)
|
CalcNode
:
:
Time
(
.
.
)
=
>
return
Err
(
(
)
)
}
)
}
fn
add_length_or_percentage_to
(
&
self
ret
:
&
mut
CalcLengthOrPercentage
factor
:
CSSFloat
)
-
>
Result
<
(
)
(
)
>
{
match
*
self
{
CalcNode
:
:
Percentage
(
pct
)
=
>
{
ret
.
percentage
=
Some
(
computed
:
:
Percentage
(
ret
.
percentage
.
map_or
(
0
.
|
p
|
p
.
0
)
+
pct
*
factor
)
)
;
}
CalcNode
:
:
Length
(
ref
l
)
=
>
{
match
*
l
{
NoCalcLength
:
:
Absolute
(
abs
)
=
>
{
ret
.
absolute
=
Some
(
match
ret
.
absolute
{
Some
(
value
)
=
>
value
+
abs
*
factor
None
=
>
abs
*
factor
}
)
;
}
NoCalcLength
:
:
FontRelative
(
rel
)
=
>
{
match
rel
{
FontRelativeLength
:
:
Em
(
em
)
=
>
{
ret
.
em
=
Some
(
ret
.
em
.
unwrap_or
(
0
.
)
+
em
*
factor
)
;
}
FontRelativeLength
:
:
Ex
(
ex
)
=
>
{
ret
.
ex
=
Some
(
ret
.
em
.
unwrap_or
(
0
.
)
+
ex
*
factor
)
;
}
FontRelativeLength
:
:
Ch
(
ch
)
=
>
{
ret
.
ch
=
Some
(
ret
.
ch
.
unwrap_or
(
0
.
)
+
ch
*
factor
)
;
}
FontRelativeLength
:
:
Rem
(
rem
)
=
>
{
ret
.
rem
=
Some
(
ret
.
rem
.
unwrap_or
(
0
.
)
+
rem
*
factor
)
;
}
}
}
NoCalcLength
:
:
ViewportPercentage
(
rel
)
=
>
{
match
rel
{
ViewportPercentageLength
:
:
Vh
(
vh
)
=
>
{
ret
.
vh
=
Some
(
ret
.
vh
.
unwrap_or
(
0
.
)
+
vh
*
factor
)
}
ViewportPercentageLength
:
:
Vw
(
vw
)
=
>
{
ret
.
vw
=
Some
(
ret
.
vw
.
unwrap_or
(
0
.
)
+
vw
*
factor
)
}
ViewportPercentageLength
:
:
Vmax
(
vmax
)
=
>
{
ret
.
vmax
=
Some
(
ret
.
vmax
.
unwrap_or
(
0
.
)
+
vmax
*
factor
)
}
ViewportPercentageLength
:
:
Vmin
(
vmin
)
=
>
{
ret
.
vmin
=
Some
(
ret
.
vmin
.
unwrap_or
(
0
.
)
+
vmin
*
factor
)
}
}
}
NoCalcLength
:
:
ServoCharacterWidth
(
.
.
)
=
>
unreachable
!
(
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
NoCalcLength
:
:
Physical
(
physical
)
=
>
{
ret
.
mozmm
=
Some
(
ret
.
mozmm
.
unwrap_or
(
0
.
)
+
physical
.
0
*
factor
)
;
}
}
}
CalcNode
:
:
Sub
(
ref
a
ref
b
)
=
>
{
a
.
add_length_or_percentage_to
(
ret
factor
)
?
;
b
.
add_length_or_percentage_to
(
ret
factor
*
-
1
.
0
)
?
;
}
CalcNode
:
:
Sum
(
ref
a
ref
b
)
=
>
{
a
.
add_length_or_percentage_to
(
ret
factor
)
?
;
b
.
add_length_or_percentage_to
(
ret
factor
)
?
;
}
CalcNode
:
:
Mul
(
ref
a
ref
b
)
=
>
{
match
b
.
to_number
(
)
{
Ok
(
rhs
)
=
>
{
a
.
add_length_or_percentage_to
(
ret
factor
*
rhs
)
?
;
}
Err
(
.
.
)
=
>
{
let
lhs
=
a
.
to_number
(
)
?
;
b
.
add_length_or_percentage_to
(
ret
factor
*
lhs
)
?
;
}
}
}
CalcNode
:
:
Div
(
ref
a
ref
b
)
=
>
{
let
new_factor
=
b
.
to_number
(
)
?
;
if
new_factor
=
=
0
.
{
return
Err
(
(
)
)
;
}
a
.
add_length_or_percentage_to
(
ret
factor
/
new_factor
)
?
;
}
CalcNode
:
:
Angle
(
.
.
)
|
CalcNode
:
:
Time
(
.
.
)
|
CalcNode
:
:
Number
(
.
.
)
=
>
return
Err
(
(
)
)
}
Ok
(
(
)
)
}
fn
to_time
(
&
self
)
-
>
Result
<
Time
(
)
>
{
Ok
(
match
*
self
{
CalcNode
:
:
Time
(
ref
time
)
=
>
time
.
clone
(
)
CalcNode
:
:
Sub
(
ref
a
ref
b
)
=
>
{
let
lhs
=
a
.
to_time
(
)
?
;
let
rhs
=
b
.
to_time
(
)
?
;
Time
:
:
from_calc
(
lhs
.
seconds
(
)
-
rhs
.
seconds
(
)
)
}
CalcNode
:
:
Sum
(
ref
a
ref
b
)
=
>
{
let
lhs
=
a
.
to_time
(
)
?
;
let
rhs
=
b
.
to_time
(
)
?
;
Time
:
:
from_calc
(
lhs
.
seconds
(
)
+
rhs
.
seconds
(
)
)
}
CalcNode
:
:
Mul
(
ref
a
ref
b
)
=
>
{
match
b
.
to_number
(
)
{
Ok
(
rhs
)
=
>
{
let
lhs
=
a
.
to_time
(
)
?
;
Time
:
:
from_calc
(
lhs
.
seconds
(
)
*
rhs
)
}
Err
(
(
)
)
=
>
{
let
lhs
=
a
.
to_number
(
)
?
;
let
rhs
=
b
.
to_time
(
)
?
;
Time
:
:
from_calc
(
lhs
*
rhs
.
seconds
(
)
)
}
}
}
CalcNode
:
:
Div
(
ref
a
ref
b
)
=
>
{
let
lhs
=
a
.
to_time
(
)
?
;
let
rhs
=
b
.
to_number
(
)
?
;
if
rhs
=
=
0
.
{
return
Err
(
(
)
)
}
Time
:
:
from_calc
(
lhs
.
seconds
(
)
/
rhs
)
}
CalcNode
:
:
Number
(
.
.
)
|
CalcNode
:
:
Length
(
.
.
)
|
CalcNode
:
:
Percentage
(
.
.
)
|
CalcNode
:
:
Angle
(
.
.
)
=
>
return
Err
(
(
)
)
}
)
}
fn
to_angle
(
&
self
)
-
>
Result
<
Angle
(
)
>
{
Ok
(
match
*
self
{
CalcNode
:
:
Angle
(
ref
angle
)
=
>
angle
.
clone
(
)
CalcNode
:
:
Sub
(
ref
a
ref
b
)
=
>
{
let
lhs
=
a
.
to_angle
(
)
?
;
let
rhs
=
b
.
to_angle
(
)
?
;
Angle
:
:
from_calc
(
lhs
.
radians
(
)
-
rhs
.
radians
(
)
)
}
CalcNode
:
:
Sum
(
ref
a
ref
b
)
=
>
{
let
lhs
=
a
.
to_angle
(
)
?
;
let
rhs
=
b
.
to_angle
(
)
?
;
Angle
:
:
from_calc
(
lhs
.
radians
(
)
+
rhs
.
radians
(
)
)
}
CalcNode
:
:
Mul
(
ref
a
ref
b
)
=
>
{
match
a
.
to_angle
(
)
{
Ok
(
lhs
)
=
>
{
let
rhs
=
b
.
to_number
(
)
?
;
Angle
:
:
from_calc
(
lhs
.
radians
(
)
*
rhs
)
}
Err
(
.
.
)
=
>
{
let
lhs
=
a
.
to_number
(
)
?
;
let
rhs
=
b
.
to_angle
(
)
?
;
Angle
:
:
from_calc
(
lhs
*
rhs
.
radians
(
)
)
}
}
}
CalcNode
:
:
Div
(
ref
a
ref
b
)
=
>
{
let
lhs
=
a
.
to_angle
(
)
?
;
let
rhs
=
b
.
to_number
(
)
?
;
if
rhs
=
=
0
.
{
return
Err
(
(
)
)
}
Angle
:
:
from_calc
(
lhs
.
radians
(
)
/
rhs
)
}
CalcNode
:
:
Number
(
.
.
)
|
CalcNode
:
:
Length
(
.
.
)
|
CalcNode
:
:
Percentage
(
.
.
)
|
CalcNode
:
:
Time
(
.
.
)
=
>
return
Err
(
(
)
)
}
)
}
fn
to_number
(
&
self
)
-
>
Result
<
CSSFloat
(
)
>
{
Ok
(
match
*
self
{
CalcNode
:
:
Number
(
n
)
=
>
n
CalcNode
:
:
Sum
(
ref
a
ref
b
)
=
>
{
a
.
to_number
(
)
?
+
b
.
to_number
(
)
?
}
CalcNode
:
:
Sub
(
ref
a
ref
b
)
=
>
{
a
.
to_number
(
)
?
-
b
.
to_number
(
)
?
}
CalcNode
:
:
Mul
(
ref
a
ref
b
)
=
>
{
a
.
to_number
(
)
?
*
b
.
to_number
(
)
?
}
CalcNode
:
:
Div
(
ref
a
ref
b
)
=
>
{
let
lhs
=
a
.
to_number
(
)
?
;
let
rhs
=
b
.
to_number
(
)
?
;
if
rhs
=
=
0
.
{
return
Err
(
(
)
)
}
lhs
/
rhs
}
CalcNode
:
:
Length
(
.
.
)
|
CalcNode
:
:
Percentage
(
.
.
)
|
CalcNode
:
:
Angle
(
.
.
)
|
CalcNode
:
:
Time
(
.
.
)
=
>
return
Err
(
(
)
)
}
)
}
pub
fn
parse_integer
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
CSSInteger
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
CalcUnit
:
:
Integer
)
?
.
to_number
(
)
.
map
(
|
n
|
n
as
CSSInteger
)
.
map_err
(
|
(
)
|
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
pub
fn
parse_length_or_percentage
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
clamping_mode
:
AllowedNumericType
)
-
>
Result
<
CalcLengthOrPercentage
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
CalcUnit
:
:
LengthOrPercentage
)
?
.
to_length_or_percentage
(
clamping_mode
)
.
map_err
(
|
(
)
|
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
pub
fn
parse_percentage
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
CSSFloat
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
CalcUnit
:
:
Percentage
)
?
.
to_percentage
(
)
.
map_err
(
|
(
)
|
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
pub
fn
parse_length
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
clamping_mode
:
AllowedNumericType
)
-
>
Result
<
CalcLengthOrPercentage
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
CalcUnit
:
:
Length
)
?
.
to_length_or_percentage
(
clamping_mode
)
.
map_err
(
|
(
)
|
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
pub
fn
parse_number
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
CSSFloat
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
CalcUnit
:
:
Number
)
?
.
to_number
(
)
.
map_err
(
|
(
)
|
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
pub
fn
parse_angle
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Angle
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
CalcUnit
:
:
Angle
)
?
.
to_angle
(
)
.
map_err
(
|
(
)
|
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
pub
fn
parse_time
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Time
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
CalcUnit
:
:
Time
)
?
.
to_time
(
)
.
map_err
(
|
(
)
|
StyleParseError
:
:
UnspecifiedError
.
into
(
)
)
}
}
