use
crate
:
:
parser
:
:
ParserContext
;
use
crate
:
:
values
:
:
computed
;
use
crate
:
:
values
:
:
specified
:
:
length
:
:
ViewportPercentageLength
;
use
crate
:
:
values
:
:
specified
:
:
length
:
:
{
AbsoluteLength
FontRelativeLength
NoCalcLength
}
;
use
crate
:
:
values
:
:
specified
:
:
{
self
Angle
Time
}
;
use
crate
:
:
values
:
:
{
CSSFloat
CSSInteger
}
;
use
cssparser
:
:
{
AngleOrNumber
CowRcStr
NumberOrPercentage
Parser
Token
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
{
cmp
mem
}
;
use
style_traits
:
:
values
:
:
specified
:
:
AllowedNumericType
;
use
style_traits
:
:
{
CssWriter
ParseError
SpecifiedValueInfo
StyleParseErrorKind
ToCss
}
;
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
MathFunction
{
Calc
Min
Max
Clamp
}
#
[
derive
(
Clone
Copy
Debug
Eq
Ord
PartialEq
PartialOrd
)
]
enum
SortKey
{
Number
Percentage
Ch
Deg
Em
Ex
Px
Rem
Sec
Vh
Vmax
Vmin
Vw
Other
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
MinMaxOp
{
Min
Max
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
enum
CalcNode
{
Length
(
NoCalcLength
)
Angle
(
Angle
)
Time
(
Time
)
Percentage
(
CSSFloat
)
Number
(
CSSFloat
)
Sum
(
Box
<
[
CalcNode
]
>
)
MinMax
(
Box
<
[
CalcNode
]
>
MinMaxOp
)
Clamp
{
min
:
Box
<
CalcNode
>
center
:
Box
<
CalcNode
>
max
:
Box
<
CalcNode
>
}
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
CalcUnit
{
Number
Length
Percentage
LengthPercentage
Angle
Time
}
#
[
derive
(
Clone
Copy
Debug
Default
MallocSizeOf
PartialEq
ToShmem
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
CalcLengthPercentage
{
pub
clamping_mode
:
AllowedNumericType
pub
absolute
:
Option
<
AbsoluteLength
>
pub
vw
:
Option
<
CSSFloat
>
pub
vh
:
Option
<
CSSFloat
>
pub
vmin
:
Option
<
CSSFloat
>
pub
vmax
:
Option
<
CSSFloat
>
pub
em
:
Option
<
CSSFloat
>
pub
ex
:
Option
<
CSSFloat
>
pub
ch
:
Option
<
CSSFloat
>
pub
rem
:
Option
<
CSSFloat
>
pub
percentage
:
Option
<
computed
:
:
Percentage
>
}
impl
ToCss
for
CalcLengthPercentage
{
#
[
allow
(
unused_assignments
)
]
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
use
num_traits
:
:
Zero
;
let
mut
first_value
=
true
;
macro_rules
!
first_value_check
{
(
val
:
expr
)
=
>
{
if
!
first_value
{
dest
.
write_str
(
if
val
<
Zero
:
:
zero
(
)
{
"
-
"
}
else
{
"
+
"
}
)
?
;
}
else
if
val
<
Zero
:
:
zero
(
)
{
dest
.
write_str
(
"
-
"
)
?
;
}
first_value
=
false
;
}
;
}
macro_rules
!
serialize
{
(
(
val
:
ident
)
*
)
=
>
{
(
if
let
Some
(
val
)
=
self
.
val
{
first_value_check
!
(
val
)
;
val
.
abs
(
)
.
to_css
(
dest
)
?
;
dest
.
write_str
(
stringify
!
(
val
)
)
?
;
}
)
*
}
;
}
macro_rules
!
serialize_abs
{
(
(
val
:
ident
)
+
)
=
>
{
(
if
let
Some
(
AbsoluteLength
:
:
val
(
v
)
)
=
self
.
absolute
{
first_value_check
!
(
v
)
;
AbsoluteLength
:
:
val
(
v
.
abs
(
)
)
.
to_css
(
dest
)
?
;
}
)
+
}
;
}
dest
.
write_str
(
"
calc
(
"
)
?
;
if
let
Some
(
val
)
=
self
.
percentage
{
first_value_check
!
(
val
.
0
)
;
val
.
abs
(
)
.
to_css
(
dest
)
?
;
}
serialize
!
(
ch
)
;
serialize_abs
!
(
Cm
)
;
serialize
!
(
em
ex
)
;
serialize_abs
!
(
In
Mm
Pc
Pt
Px
Q
)
;
serialize
!
(
rem
vh
vmax
vmin
vw
)
;
dest
.
write_str
(
"
)
"
)
}
}
impl
SpecifiedValueInfo
for
CalcLengthPercentage
{
}
macro_rules
!
impl_generic_to_type
{
(
self
:
ident
self_variant
:
ident
to_self
:
ident
to_float
:
ident
from_float
:
path
)
=
>
{
{
if
let
Self
:
:
self_variant
(
ref
v
)
=
*
self
{
return
Ok
(
v
.
clone
(
)
)
;
}
Ok
(
match
*
self
{
Self
:
:
Sum
(
ref
expressions
)
=
>
{
let
mut
sum
=
0
.
;
for
sub
in
&
*
*
expressions
{
sum
+
=
sub
.
to_self
(
)
?
.
to_float
(
)
;
}
from_float
(
sum
)
}
Self
:
:
Clamp
{
ref
min
ref
center
ref
max
}
=
>
{
let
min
=
min
.
to_self
(
)
?
;
let
center
=
center
.
to_self
(
)
?
;
let
max
=
max
.
to_self
(
)
?
;
/
/
Equivalent
to
cmp
:
:
max
(
min
cmp
:
:
min
(
center
max
)
)
/
/
/
/
But
preserving
units
when
appropriate
.
let
center_float
=
center
.
to_float
(
)
;
let
min_float
=
min
.
to_float
(
)
;
let
max_float
=
max
.
to_float
(
)
;
let
mut
result
=
center
;
let
mut
result_float
=
center_float
;
if
result_float
>
max_float
{
result
=
max
;
result_float
=
max_float
;
}
if
result_float
<
min_float
{
min
}
else
{
result
}
}
Self
:
:
MinMax
(
ref
nodes
op
)
=
>
{
let
mut
result
=
nodes
[
0
]
.
to_self
(
)
?
;
let
mut
result_float
=
result
.
to_float
(
)
;
for
node
in
nodes
.
iter
(
)
.
skip
(
1
)
{
let
candidate
=
node
.
to_self
(
)
?
;
let
candidate_float
=
candidate
.
to_float
(
)
;
let
candidate_wins
=
match
op
{
MinMaxOp
:
:
Min
=
>
candidate_float
<
result_float
MinMaxOp
:
:
Max
=
>
candidate_float
>
result_float
}
;
if
candidate_wins
{
result
=
candidate
;
result_float
=
candidate_float
;
}
}
result
}
Self
:
:
Length
(
.
.
)
|
Self
:
:
Angle
(
.
.
)
|
Self
:
:
Time
(
.
.
)
|
Self
:
:
Percentage
(
.
.
)
|
Self
:
:
Number
(
.
.
)
=
>
return
Err
(
(
)
)
}
)
}
}
;
}
impl
PartialOrd
for
CalcNode
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
cmp
:
:
Ordering
>
{
use
self
:
:
CalcNode
:
:
*
;
match
(
self
other
)
{
(
&
Length
(
ref
one
)
&
Length
(
ref
other
)
)
=
>
one
.
partial_cmp
(
other
)
(
&
Percentage
(
ref
one
)
&
Percentage
(
ref
other
)
)
=
>
one
.
partial_cmp
(
other
)
(
&
Angle
(
ref
one
)
&
Angle
(
ref
other
)
)
=
>
one
.
degrees
(
)
.
partial_cmp
(
&
other
.
degrees
(
)
)
(
&
Time
(
ref
one
)
&
Time
(
ref
other
)
)
=
>
one
.
seconds
(
)
.
partial_cmp
(
&
other
.
seconds
(
)
)
(
&
Number
(
ref
one
)
&
Number
(
ref
other
)
)
=
>
one
.
partial_cmp
(
other
)
_
=
>
None
}
}
}
impl
CalcNode
{
fn
negate
(
&
mut
self
)
{
self
.
mul_by
(
-
1
.
)
;
}
fn
mul_by
(
&
mut
self
scalar
:
f32
)
{
match
*
self
{
Self
:
:
Length
(
ref
mut
l
)
=
>
{
*
l
=
*
l
*
scalar
;
}
Self
:
:
Number
(
ref
mut
n
)
=
>
{
*
n
*
=
scalar
;
}
Self
:
:
Angle
(
ref
mut
a
)
=
>
{
*
a
=
Angle
:
:
from_calc
(
a
.
degrees
(
)
*
scalar
)
;
}
Self
:
:
Time
(
ref
mut
t
)
=
>
{
*
t
=
Time
:
:
from_calc
(
t
.
seconds
(
)
*
scalar
)
;
}
Self
:
:
Percentage
(
ref
mut
p
)
=
>
{
*
p
*
=
scalar
;
}
Self
:
:
Sum
(
ref
mut
children
)
=
>
{
for
node
in
&
mut
*
*
children
{
node
.
mul_by
(
scalar
)
;
}
}
Self
:
:
MinMax
(
ref
mut
children
ref
mut
op
)
=
>
{
for
node
in
&
mut
*
*
children
{
node
.
mul_by
(
scalar
)
;
}
if
scalar
<
0
.
{
*
op
=
match
*
op
{
MinMaxOp
:
:
Min
=
>
MinMaxOp
:
:
Max
MinMaxOp
:
:
Max
=
>
MinMaxOp
:
:
Min
}
}
}
Self
:
:
Clamp
{
ref
mut
min
ref
mut
center
ref
mut
max
}
=
>
{
min
.
mul_by
(
scalar
)
;
center
.
mul_by
(
scalar
)
;
max
.
mul_by
(
scalar
)
;
if
scalar
<
0
.
{
mem
:
:
swap
(
min
max
)
;
}
}
}
}
fn
calc_node_sort_key
(
&
self
)
-
>
SortKey
{
match
*
self
{
Self
:
:
Number
(
.
.
)
=
>
SortKey
:
:
Number
Self
:
:
Percentage
(
.
.
)
=
>
SortKey
:
:
Percentage
Self
:
:
Time
(
.
.
)
=
>
SortKey
:
:
Sec
Self
:
:
Angle
(
.
.
)
=
>
SortKey
:
:
Deg
Self
:
:
Length
(
ref
l
)
=
>
match
*
l
{
NoCalcLength
:
:
Absolute
(
.
.
)
=
>
SortKey
:
:
Px
NoCalcLength
:
:
FontRelative
(
ref
relative
)
=
>
match
*
relative
{
FontRelativeLength
:
:
Ch
(
.
.
)
=
>
SortKey
:
:
Ch
FontRelativeLength
:
:
Em
(
.
.
)
=
>
SortKey
:
:
Em
FontRelativeLength
:
:
Ex
(
.
.
)
=
>
SortKey
:
:
Ex
FontRelativeLength
:
:
Rem
(
.
.
)
=
>
SortKey
:
:
Rem
}
NoCalcLength
:
:
ViewportPercentage
(
ref
vp
)
=
>
match
*
vp
{
ViewportPercentageLength
:
:
Vh
(
.
.
)
=
>
SortKey
:
:
Vh
ViewportPercentageLength
:
:
Vw
(
.
.
)
=
>
SortKey
:
:
Vw
ViewportPercentageLength
:
:
Vmax
(
.
.
)
=
>
SortKey
:
:
Vmax
ViewportPercentageLength
:
:
Vmin
(
.
.
)
=
>
SortKey
:
:
Vmin
}
NoCalcLength
:
:
ServoCharacterWidth
(
.
.
)
=
>
unreachable
!
(
)
}
Self
:
:
Sum
(
.
.
)
|
Self
:
:
MinMax
(
.
.
)
|
Self
:
:
Clamp
{
.
.
}
=
>
SortKey
:
:
Other
}
}
fn
try_sum_in_place
(
&
mut
self
other
:
&
Self
)
-
>
Result
<
(
)
(
)
>
{
use
self
:
:
CalcNode
:
:
*
;
match
(
self
other
)
{
(
&
mut
Number
(
ref
mut
one
)
&
Number
(
ref
other
)
)
|
(
&
mut
Percentage
(
ref
mut
one
)
&
Percentage
(
ref
other
)
)
=
>
{
*
one
+
=
*
other
;
}
(
&
mut
Angle
(
ref
mut
one
)
&
Angle
(
ref
other
)
)
=
>
{
*
one
=
specified
:
:
Angle
:
:
from_calc
(
one
.
degrees
(
)
+
other
.
degrees
(
)
)
;
}
(
&
mut
Time
(
ref
mut
one
)
&
Time
(
ref
other
)
)
=
>
{
*
one
=
specified
:
:
Time
:
:
from_calc
(
one
.
seconds
(
)
+
other
.
seconds
(
)
)
;
}
(
&
mut
Length
(
ref
mut
one
)
&
Length
(
ref
other
)
)
=
>
{
*
one
=
one
.
try_sum
(
other
)
?
;
}
_
=
>
return
Err
(
(
)
)
}
Ok
(
(
)
)
}
fn
simplify_and_sort_children
(
&
mut
self
)
{
macro_rules
!
replace_self_with
{
(
slot
:
expr
)
=
>
{
{
let
result
=
mem
:
:
replace
(
slot
Self
:
:
Number
(
0
.
)
)
;
mem
:
:
replace
(
self
result
)
;
}
}
;
}
match
*
self
{
Self
:
:
Clamp
{
ref
mut
min
ref
mut
center
ref
mut
max
}
=
>
{
min
.
simplify_and_sort_children
(
)
;
center
.
simplify_and_sort_children
(
)
;
max
.
simplify_and_sort_children
(
)
;
let
min_cmp_center
=
match
min
.
partial_cmp
(
&
center
)
{
Some
(
o
)
=
>
o
None
=
>
return
}
;
if
matches
!
(
min_cmp_center
cmp
:
:
Ordering
:
:
Greater
)
{
return
replace_self_with
!
(
&
mut
*
*
min
)
;
}
let
max_cmp_center
=
match
max
.
partial_cmp
(
&
center
)
{
Some
(
o
)
=
>
o
None
=
>
return
}
;
if
matches
!
(
max_cmp_center
cmp
:
:
Ordering
:
:
Less
)
{
let
max_cmp_min
=
match
max
.
partial_cmp
(
&
min
)
{
Some
(
o
)
=
>
o
None
=
>
{
debug_assert
!
(
false
"
We
compared
center
with
min
and
max
how
are
\
min
/
max
not
comparable
with
each
other
?
"
)
;
return
;
}
}
;
if
matches
!
(
max_cmp_min
cmp
:
:
Ordering
:
:
Less
)
{
return
replace_self_with
!
(
&
mut
*
*
min
)
;
}
return
replace_self_with
!
(
&
mut
*
*
max
)
;
}
return
replace_self_with
!
(
&
mut
*
*
center
)
;
}
Self
:
:
MinMax
(
ref
mut
children
op
)
=
>
{
for
child
in
&
mut
*
*
children
{
child
.
simplify_and_sort_children
(
)
;
}
let
winning_order
=
match
op
{
MinMaxOp
:
:
Min
=
>
cmp
:
:
Ordering
:
:
Less
MinMaxOp
:
:
Max
=
>
cmp
:
:
Ordering
:
:
Greater
}
;
let
mut
result
=
0
;
for
i
in
1
.
.
children
.
len
(
)
{
let
o
=
match
children
[
i
]
.
partial_cmp
(
&
children
[
result
]
)
{
None
=
>
return
Some
(
o
)
=
>
o
}
;
if
o
=
=
winning_order
{
result
=
i
;
}
}
replace_self_with
!
(
&
mut
children
[
result
]
)
;
}
Self
:
:
Sum
(
ref
mut
children_slot
)
=
>
{
let
mut
sums_to_merge
=
SmallVec
:
:
<
[
_
;
3
]
>
:
:
new
(
)
;
let
mut
extra_kids
=
0
;
for
(
i
child
)
in
children_slot
.
iter_mut
(
)
.
enumerate
(
)
{
child
.
simplify_and_sort_children
(
)
;
if
let
Self
:
:
Sum
(
ref
mut
children
)
=
*
child
{
extra_kids
+
=
children
.
len
(
)
;
sums_to_merge
.
push
(
i
)
;
}
}
if
children_slot
.
len
(
)
=
=
1
{
return
replace_self_with
!
(
&
mut
children_slot
[
0
]
)
;
}
let
mut
children
=
mem
:
:
replace
(
children_slot
Box
:
:
new
(
[
]
)
)
.
into_vec
(
)
;
if
!
sums_to_merge
.
is_empty
(
)
{
children
.
reserve
(
extra_kids
-
sums_to_merge
.
len
(
)
)
;
for
i
in
sums_to_merge
.
drain
(
.
.
)
.
rev
(
)
{
let
kid_children
=
match
children
.
swap_remove
(
i
)
{
Self
:
:
Sum
(
c
)
=
>
c
_
=
>
unreachable
!
(
)
}
;
children
.
extend
(
kid_children
.
into_vec
(
)
)
;
}
}
debug_assert
!
(
children
.
len
(
)
>
=
2
"
Should
still
have
multiple
kids
!
"
)
;
children
.
sort_unstable_by_key
(
|
c
|
c
.
calc_node_sort_key
(
)
)
;
children
.
dedup_by
(
|
a
b
|
b
.
try_sum_in_place
(
a
)
.
is_ok
(
)
)
;
if
children
.
len
(
)
=
=
1
{
replace_self_with
!
(
&
mut
children
[
0
]
)
;
}
else
{
mem
:
:
replace
(
children_slot
children
.
into_boxed_slice
(
)
)
;
}
}
Self
:
:
Length
(
ref
mut
len
)
=
>
{
if
let
NoCalcLength
:
:
Absolute
(
ref
mut
absolute_length
)
=
*
len
{
*
absolute_length
=
AbsoluteLength
:
:
Px
(
absolute_length
.
to_px
(
)
)
;
}
}
Self
:
:
Percentage
(
.
.
)
|
Self
:
:
Angle
(
.
.
)
|
Self
:
:
Time
(
.
.
)
|
Self
:
:
Number
(
.
.
)
=
>
{
}
}
}
fn
parse_one
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
expected_unit
:
CalcUnit
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
match
(
input
.
next
(
)
?
expected_unit
)
{
(
&
Token
:
:
Number
{
value
.
.
}
_
)
=
>
Ok
(
CalcNode
:
:
Number
(
value
)
)
(
&
Token
:
:
Dimension
{
value
ref
unit
.
.
}
CalcUnit
:
:
Length
)
|
(
&
Token
:
:
Dimension
{
value
ref
unit
.
.
}
CalcUnit
:
:
LengthPercentage
)
=
>
NoCalcLength
:
:
parse_dimension
(
context
value
unit
)
.
map
(
CalcNode
:
:
Length
)
.
map_err
(
|
(
)
|
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
(
&
Token
:
:
Dimension
{
value
ref
unit
.
.
}
CalcUnit
:
:
Angle
)
=
>
{
Angle
:
:
parse_dimension
(
value
unit
true
)
.
map
(
CalcNode
:
:
Angle
)
.
map_err
(
|
(
)
|
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
(
&
Token
:
:
Dimension
{
value
ref
unit
.
.
}
CalcUnit
:
:
Time
)
=
>
{
Time
:
:
parse_dimension
(
value
unit
true
)
.
map
(
CalcNode
:
:
Time
)
.
map_err
(
|
(
)
|
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
(
&
Token
:
:
Percentage
{
unit_value
.
.
}
CalcUnit
:
:
LengthPercentage
)
|
(
&
Token
:
:
Percentage
{
unit_value
.
.
}
CalcUnit
:
:
Percentage
)
=
>
{
Ok
(
CalcNode
:
:
Percentage
(
unit_value
)
)
}
(
&
Token
:
:
ParenthesisBlock
_
)
=
>
input
.
parse_nested_block
(
|
input
|
{
CalcNode
:
:
parse_argument
(
context
input
expected_unit
)
}
)
(
&
Token
:
:
Function
(
ref
name
)
_
)
=
>
{
let
function
=
CalcNode
:
:
math_function
(
name
location
)
?
;
CalcNode
:
:
parse
(
context
input
function
expected_unit
)
}
(
t
_
)
=
>
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
}
}
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
expected_unit
:
CalcUnit
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
parse_nested_block
(
|
input
|
{
match
function
{
MathFunction
:
:
Calc
=
>
Self
:
:
parse_argument
(
context
input
expected_unit
)
MathFunction
:
:
Clamp
=
>
{
let
min
=
Self
:
:
parse_argument
(
context
input
expected_unit
)
?
;
input
.
expect_comma
(
)
?
;
let
center
=
Self
:
:
parse_argument
(
context
input
expected_unit
)
?
;
input
.
expect_comma
(
)
?
;
let
max
=
Self
:
:
parse_argument
(
context
input
expected_unit
)
?
;
Ok
(
Self
:
:
Clamp
{
min
:
Box
:
:
new
(
min
)
center
:
Box
:
:
new
(
center
)
max
:
Box
:
:
new
(
max
)
}
)
}
MathFunction
:
:
Min
|
MathFunction
:
:
Max
=
>
{
let
arguments
=
input
.
parse_comma_separated
(
|
input
|
{
Self
:
:
parse_argument
(
context
input
expected_unit
)
}
)
?
.
into_boxed_slice
(
)
;
let
op
=
match
function
{
MathFunction
:
:
Min
=
>
MinMaxOp
:
:
Min
MathFunction
:
:
Max
=
>
MinMaxOp
:
:
Max
_
=
>
unreachable
!
(
)
}
;
Ok
(
Self
:
:
MinMax
(
arguments
op
)
)
}
}
}
)
}
fn
parse_argument
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
expected_unit
:
CalcUnit
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
sum
=
SmallVec
:
:
<
[
CalcNode
;
1
]
>
:
:
new
(
)
;
sum
.
push
(
Self
:
:
parse_product
(
context
input
expected_unit
)
?
)
;
loop
{
let
start
=
input
.
state
(
)
;
match
input
.
next_including_whitespace
(
)
{
Ok
(
&
Token
:
:
WhiteSpace
(
_
)
)
=
>
{
if
input
.
is_exhausted
(
)
{
break
;
}
match
*
input
.
next
(
)
?
{
Token
:
:
Delim
(
'
+
'
)
=
>
{
sum
.
push
(
Self
:
:
parse_product
(
context
input
expected_unit
)
?
)
;
}
Token
:
:
Delim
(
'
-
'
)
=
>
{
let
mut
rhs
=
Self
:
:
parse_product
(
context
input
expected_unit
)
?
;
rhs
.
negate
(
)
;
sum
.
push
(
rhs
)
;
}
ref
t
=
>
{
let
t
=
t
.
clone
(
)
;
return
Err
(
input
.
new_unexpected_token_error
(
t
)
)
;
}
}
}
_
=
>
{
input
.
reset
(
&
start
)
;
break
;
}
}
}
Ok
(
if
sum
.
len
(
)
=
=
1
{
sum
.
drain
(
.
.
)
.
next
(
)
.
unwrap
(
)
}
else
{
Self
:
:
Sum
(
sum
.
into_boxed_slice
(
)
)
}
)
}
fn
parse_product
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
expected_unit
:
CalcUnit
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
node
=
Self
:
:
parse_one
(
context
input
expected_unit
)
?
;
loop
{
let
start
=
input
.
state
(
)
;
match
input
.
next
(
)
{
Ok
(
&
Token
:
:
Delim
(
'
*
'
)
)
=
>
{
let
rhs
=
Self
:
:
parse_one
(
context
input
expected_unit
)
?
;
if
let
Ok
(
rhs
)
=
rhs
.
to_number
(
)
{
node
.
mul_by
(
rhs
)
;
}
else
if
let
Ok
(
number
)
=
node
.
to_number
(
)
{
node
=
rhs
;
node
.
mul_by
(
number
)
;
}
else
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
}
Ok
(
&
Token
:
:
Delim
(
'
/
'
)
)
=
>
{
let
rhs
=
Self
:
:
parse_one
(
context
input
expected_unit
)
?
;
let
number
=
match
rhs
.
to_number
(
)
{
Ok
(
n
)
if
n
!
=
0
.
=
>
n
_
=
>
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
}
;
node
.
mul_by
(
1
.
/
number
)
;
}
_
=
>
{
input
.
reset
(
&
start
)
;
break
;
}
}
}
Ok
(
node
)
}
fn
to_length_or_percentage
(
&
mut
self
clamping_mode
:
AllowedNumericType
)
-
>
Result
<
CalcLengthPercentage
(
)
>
{
let
mut
ret
=
CalcLengthPercentage
{
clamping_mode
.
.
Default
:
:
default
(
)
}
;
self
.
simplify_and_sort_children
(
)
;
self
.
add_length_or_percentage_to
(
&
mut
ret
1
.
0
)
?
;
Ok
(
ret
)
}
fn
add_length_or_percentage_to
(
&
self
ret
:
&
mut
CalcLengthPercentage
factor
:
CSSFloat
)
-
>
Result
<
(
)
(
)
>
{
match
*
self
{
CalcNode
:
:
Percentage
(
pct
)
=
>
{
ret
.
percentage
=
Some
(
computed
:
:
Percentage
(
ret
.
percentage
.
map_or
(
0
.
|
p
|
p
.
0
)
+
pct
*
factor
)
)
;
}
CalcNode
:
:
Length
(
ref
l
)
=
>
match
*
l
{
NoCalcLength
:
:
Absolute
(
abs
)
=
>
{
ret
.
absolute
=
Some
(
match
ret
.
absolute
{
Some
(
value
)
=
>
value
+
abs
*
factor
None
=
>
abs
*
factor
}
)
;
}
NoCalcLength
:
:
FontRelative
(
rel
)
=
>
match
rel
{
FontRelativeLength
:
:
Em
(
em
)
=
>
{
ret
.
em
=
Some
(
ret
.
em
.
unwrap_or
(
0
.
)
+
em
*
factor
)
;
}
FontRelativeLength
:
:
Ex
(
ex
)
=
>
{
ret
.
ex
=
Some
(
ret
.
ex
.
unwrap_or
(
0
.
)
+
ex
*
factor
)
;
}
FontRelativeLength
:
:
Ch
(
ch
)
=
>
{
ret
.
ch
=
Some
(
ret
.
ch
.
unwrap_or
(
0
.
)
+
ch
*
factor
)
;
}
FontRelativeLength
:
:
Rem
(
rem
)
=
>
{
ret
.
rem
=
Some
(
ret
.
rem
.
unwrap_or
(
0
.
)
+
rem
*
factor
)
;
}
}
NoCalcLength
:
:
ViewportPercentage
(
rel
)
=
>
match
rel
{
ViewportPercentageLength
:
:
Vh
(
vh
)
=
>
{
ret
.
vh
=
Some
(
ret
.
vh
.
unwrap_or
(
0
.
)
+
vh
*
factor
)
}
ViewportPercentageLength
:
:
Vw
(
vw
)
=
>
{
ret
.
vw
=
Some
(
ret
.
vw
.
unwrap_or
(
0
.
)
+
vw
*
factor
)
}
ViewportPercentageLength
:
:
Vmax
(
vmax
)
=
>
{
ret
.
vmax
=
Some
(
ret
.
vmax
.
unwrap_or
(
0
.
)
+
vmax
*
factor
)
}
ViewportPercentageLength
:
:
Vmin
(
vmin
)
=
>
{
ret
.
vmin
=
Some
(
ret
.
vmin
.
unwrap_or
(
0
.
)
+
vmin
*
factor
)
}
}
NoCalcLength
:
:
ServoCharacterWidth
(
.
.
)
=
>
unreachable
!
(
)
}
CalcNode
:
:
Sum
(
ref
children
)
=
>
{
for
child
in
&
*
*
children
{
child
.
add_length_or_percentage_to
(
ret
factor
)
?
;
}
}
CalcNode
:
:
MinMax
(
.
.
)
|
CalcNode
:
:
Clamp
{
.
.
}
=
>
{
return
Err
(
(
)
)
;
}
CalcNode
:
:
Angle
(
.
.
)
|
CalcNode
:
:
Time
(
.
.
)
|
CalcNode
:
:
Number
(
.
.
)
=
>
return
Err
(
(
)
)
}
Ok
(
(
)
)
}
fn
to_time
(
&
self
)
-
>
Result
<
Time
(
)
>
{
impl_generic_to_type
!
(
self
Time
to_time
seconds
Time
:
:
from_calc
)
}
fn
to_angle
(
&
self
)
-
>
Result
<
Angle
(
)
>
{
impl_generic_to_type
!
(
self
Angle
to_angle
degrees
Angle
:
:
from_calc
)
}
fn
to_number
(
&
self
)
-
>
Result
<
CSSFloat
(
)
>
{
impl_generic_to_type
!
(
self
Number
to_number
clone
From
:
:
from
)
}
fn
to_percentage
(
&
self
)
-
>
Result
<
CSSFloat
(
)
>
{
impl_generic_to_type
!
(
self
Percentage
to_percentage
clone
From
:
:
from
)
}
#
[
inline
]
pub
fn
math_function
<
'
i
>
(
name
:
&
CowRcStr
<
'
i
>
location
:
cssparser
:
:
SourceLocation
)
-
>
Result
<
MathFunction
ParseError
<
'
i
>
>
{
if
name
.
eq_ignore_ascii_case
(
"
calc
"
)
{
return
Ok
(
MathFunction
:
:
Calc
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
comparison_functions_enabled
(
)
-
>
bool
{
static_prefs
:
:
pref
!
(
"
layout
.
css
.
comparison
-
functions
.
enabled
"
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
comparison_functions_enabled
(
)
-
>
bool
{
false
}
if
!
comparison_functions_enabled
(
)
{
return
Err
(
location
.
new_unexpected_token_error
(
Token
:
:
Function
(
name
.
clone
(
)
)
)
)
;
}
Ok
(
match_ignore_ascii_case
!
{
&
*
name
"
min
"
=
>
MathFunction
:
:
Min
"
max
"
=
>
MathFunction
:
:
Max
"
clamp
"
=
>
MathFunction
:
:
Clamp
_
=
>
return
Err
(
location
.
new_unexpected_token_error
(
Token
:
:
Function
(
name
.
clone
(
)
)
)
)
}
)
}
pub
fn
parse_integer
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
CSSInteger
ParseError
<
'
i
>
>
{
Self
:
:
parse_number
(
context
input
function
)
.
map
(
|
n
|
n
.
round
(
)
as
CSSInteger
)
}
pub
fn
parse_length_or_percentage
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
clamping_mode
:
AllowedNumericType
function
:
MathFunction
)
-
>
Result
<
CalcLengthPercentage
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
LengthPercentage
)
?
.
to_length_or_percentage
(
clamping_mode
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
parse_percentage
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
CSSFloat
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Percentage
)
?
.
to_percentage
(
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
parse_length
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
clamping_mode
:
AllowedNumericType
function
:
MathFunction
)
-
>
Result
<
CalcLengthPercentage
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Length
)
?
.
to_length_or_percentage
(
clamping_mode
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
parse_number
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
CSSFloat
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Number
)
?
.
to_number
(
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
parse_angle
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
Angle
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Angle
)
?
.
to_angle
(
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
parse_time
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
Time
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Time
)
?
.
to_time
(
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
parse_number_or_percentage
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
NumberOrPercentage
ParseError
<
'
i
>
>
{
let
node
=
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Percentage
)
?
;
if
let
Ok
(
value
)
=
node
.
to_number
(
)
{
return
Ok
(
NumberOrPercentage
:
:
Number
{
value
}
)
;
}
match
node
.
to_percentage
(
)
{
Ok
(
unit_value
)
=
>
Ok
(
NumberOrPercentage
:
:
Percentage
{
unit_value
}
)
Err
(
(
)
)
=
>
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
pub
fn
parse_angle_or_number
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
AngleOrNumber
ParseError
<
'
i
>
>
{
let
node
=
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Angle
)
?
;
if
let
Ok
(
angle
)
=
node
.
to_angle
(
)
{
let
degrees
=
angle
.
degrees
(
)
;
return
Ok
(
AngleOrNumber
:
:
Angle
{
degrees
}
)
;
}
match
node
.
to_number
(
)
{
Ok
(
value
)
=
>
Ok
(
AngleOrNumber
:
:
Number
{
value
}
)
Err
(
(
)
)
=
>
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
}
