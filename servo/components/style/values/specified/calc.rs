use
crate
:
:
parser
:
:
ParserContext
;
use
crate
:
:
values
:
:
generics
:
:
calc
as
generic
;
use
crate
:
:
values
:
:
generics
:
:
calc
:
:
{
MinMaxOp
SortKey
}
;
use
crate
:
:
values
:
:
specified
:
:
length
:
:
ViewportPercentageLength
;
use
crate
:
:
values
:
:
specified
:
:
length
:
:
{
AbsoluteLength
FontRelativeLength
NoCalcLength
}
;
use
crate
:
:
values
:
:
specified
:
:
{
self
Angle
Time
}
;
use
crate
:
:
values
:
:
{
CSSFloat
CSSInteger
}
;
use
cssparser
:
:
{
AngleOrNumber
CowRcStr
NumberOrPercentage
Parser
Token
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
cmp
;
use
style_traits
:
:
values
:
:
specified
:
:
AllowedNumericType
;
use
style_traits
:
:
{
CssWriter
ParseError
SpecifiedValueInfo
StyleParseErrorKind
ToCss
}
;
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
MathFunction
{
Calc
Min
Max
Clamp
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
pub
enum
Leaf
{
Length
(
NoCalcLength
)
Angle
(
Angle
)
Time
(
Time
)
Percentage
(
CSSFloat
)
Number
(
CSSFloat
)
}
impl
ToCss
for
Leaf
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
*
self
{
Self
:
:
Length
(
ref
l
)
=
>
l
.
to_css
(
dest
)
Self
:
:
Number
(
ref
n
)
=
>
n
.
to_css
(
dest
)
Self
:
:
Percentage
(
p
)
=
>
crate
:
:
values
:
:
serialize_percentage
(
p
dest
)
Self
:
:
Angle
(
ref
a
)
=
>
a
.
to_css
(
dest
)
Self
:
:
Time
(
ref
t
)
=
>
t
.
to_css
(
dest
)
}
}
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
enum
CalcUnit
{
Number
Length
Percentage
LengthPercentage
Angle
Time
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToCss
ToShmem
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
CalcLengthPercentage
{
#
[
css
(
skip
)
]
pub
clamping_mode
:
AllowedNumericType
pub
node
:
CalcNode
}
impl
SpecifiedValueInfo
for
CalcLengthPercentage
{
}
impl
PartialOrd
for
Leaf
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
cmp
:
:
Ordering
>
{
use
self
:
:
Leaf
:
:
*
;
if
std
:
:
mem
:
:
discriminant
(
self
)
!
=
std
:
:
mem
:
:
discriminant
(
other
)
{
return
None
;
}
match
(
self
other
)
{
(
&
Length
(
ref
one
)
&
Length
(
ref
other
)
)
=
>
one
.
partial_cmp
(
other
)
(
&
Percentage
(
ref
one
)
&
Percentage
(
ref
other
)
)
=
>
one
.
partial_cmp
(
other
)
(
&
Angle
(
ref
one
)
&
Angle
(
ref
other
)
)
=
>
one
.
degrees
(
)
.
partial_cmp
(
&
other
.
degrees
(
)
)
(
&
Time
(
ref
one
)
&
Time
(
ref
other
)
)
=
>
one
.
seconds
(
)
.
partial_cmp
(
&
other
.
seconds
(
)
)
(
&
Number
(
ref
one
)
&
Number
(
ref
other
)
)
=
>
one
.
partial_cmp
(
other
)
_
=
>
{
match
*
self
{
Length
(
.
.
)
|
Percentage
(
.
.
)
|
Angle
(
.
.
)
|
Time
(
.
.
)
|
Number
(
.
.
)
=
>
{
}
}
unsafe
{
debug_unreachable
!
(
"
Forgot
a
branch
?
"
)
;
}
}
}
}
}
impl
generic
:
:
CalcNodeLeaf
for
Leaf
{
fn
is_negative
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Length
(
ref
l
)
=
>
l
.
is_negative
(
)
Self
:
:
Percentage
(
n
)
|
Self
:
:
Number
(
n
)
=
>
n
<
0
.
Self
:
:
Angle
(
ref
a
)
=
>
a
.
degrees
(
)
<
0
.
Self
:
:
Time
(
ref
t
)
=
>
t
.
seconds
(
)
<
0
.
}
}
fn
mul_by
(
&
mut
self
scalar
:
f32
)
{
match
*
self
{
Self
:
:
Length
(
ref
mut
l
)
=
>
{
*
l
=
*
l
*
scalar
;
}
Self
:
:
Number
(
ref
mut
n
)
=
>
{
*
n
*
=
scalar
;
}
Self
:
:
Angle
(
ref
mut
a
)
=
>
{
*
a
=
Angle
:
:
from_calc
(
a
.
degrees
(
)
*
scalar
)
;
}
Self
:
:
Time
(
ref
mut
t
)
=
>
{
*
t
=
Time
:
:
from_calc
(
t
.
seconds
(
)
*
scalar
)
;
}
Self
:
:
Percentage
(
ref
mut
p
)
=
>
{
*
p
*
=
scalar
;
}
}
}
fn
sort_key
(
&
self
)
-
>
SortKey
{
match
*
self
{
Self
:
:
Number
(
.
.
)
=
>
SortKey
:
:
Number
Self
:
:
Percentage
(
.
.
)
=
>
SortKey
:
:
Percentage
Self
:
:
Time
(
.
.
)
=
>
SortKey
:
:
Sec
Self
:
:
Angle
(
.
.
)
=
>
SortKey
:
:
Deg
Self
:
:
Length
(
ref
l
)
=
>
match
*
l
{
NoCalcLength
:
:
Absolute
(
.
.
)
=
>
SortKey
:
:
Px
NoCalcLength
:
:
FontRelative
(
ref
relative
)
=
>
match
*
relative
{
FontRelativeLength
:
:
Ch
(
.
.
)
=
>
SortKey
:
:
Ch
FontRelativeLength
:
:
Em
(
.
.
)
=
>
SortKey
:
:
Em
FontRelativeLength
:
:
Ex
(
.
.
)
=
>
SortKey
:
:
Ex
FontRelativeLength
:
:
Rem
(
.
.
)
=
>
SortKey
:
:
Rem
}
NoCalcLength
:
:
ViewportPercentage
(
ref
vp
)
=
>
match
*
vp
{
ViewportPercentageLength
:
:
Vh
(
.
.
)
=
>
SortKey
:
:
Vh
ViewportPercentageLength
:
:
Vw
(
.
.
)
=
>
SortKey
:
:
Vw
ViewportPercentageLength
:
:
Vmax
(
.
.
)
=
>
SortKey
:
:
Vmax
ViewportPercentageLength
:
:
Vmin
(
.
.
)
=
>
SortKey
:
:
Vmin
}
NoCalcLength
:
:
ServoCharacterWidth
(
.
.
)
=
>
unreachable
!
(
)
}
}
}
fn
simplify
(
&
mut
self
)
{
if
let
Self
:
:
Length
(
NoCalcLength
:
:
Absolute
(
ref
mut
abs
)
)
=
*
self
{
*
abs
=
AbsoluteLength
:
:
Px
(
abs
.
to_px
(
)
)
;
}
}
fn
try_sum_in_place
(
&
mut
self
other
:
&
Self
)
-
>
Result
<
(
)
(
)
>
{
use
self
:
:
Leaf
:
:
*
;
if
std
:
:
mem
:
:
discriminant
(
self
)
!
=
std
:
:
mem
:
:
discriminant
(
other
)
{
return
Err
(
(
)
)
;
}
match
(
self
other
)
{
(
&
mut
Number
(
ref
mut
one
)
&
Number
(
ref
other
)
)
|
(
&
mut
Percentage
(
ref
mut
one
)
&
Percentage
(
ref
other
)
)
=
>
{
*
one
+
=
*
other
;
}
(
&
mut
Angle
(
ref
mut
one
)
&
Angle
(
ref
other
)
)
=
>
{
*
one
=
specified
:
:
Angle
:
:
from_calc
(
one
.
degrees
(
)
+
other
.
degrees
(
)
)
;
}
(
&
mut
Time
(
ref
mut
one
)
&
Time
(
ref
other
)
)
=
>
{
*
one
=
specified
:
:
Time
:
:
from_calc
(
one
.
seconds
(
)
+
other
.
seconds
(
)
)
;
}
(
&
mut
Length
(
ref
mut
one
)
&
Length
(
ref
other
)
)
=
>
{
*
one
=
one
.
try_sum
(
other
)
?
;
}
_
=
>
{
match
*
other
{
Number
(
.
.
)
|
Percentage
(
.
.
)
|
Angle
(
.
.
)
|
Time
(
.
.
)
|
Length
(
.
.
)
=
>
{
}
}
unsafe
{
debug_unreachable
!
(
)
;
}
}
}
Ok
(
(
)
)
}
}
pub
type
CalcNode
=
generic
:
:
GenericCalcNode
<
Leaf
>
;
impl
CalcNode
{
fn
parse_one
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
expected_unit
:
CalcUnit
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
match
(
input
.
next
(
)
?
expected_unit
)
{
(
&
Token
:
:
Number
{
value
.
.
}
_
)
=
>
Ok
(
CalcNode
:
:
Leaf
(
Leaf
:
:
Number
(
value
)
)
)
(
&
Token
:
:
Dimension
{
value
ref
unit
.
.
}
CalcUnit
:
:
Length
)
|
(
&
Token
:
:
Dimension
{
value
ref
unit
.
.
}
CalcUnit
:
:
LengthPercentage
)
=
>
{
match
NoCalcLength
:
:
parse_dimension
(
context
value
unit
)
{
Ok
(
l
)
=
>
Ok
(
CalcNode
:
:
Leaf
(
Leaf
:
:
Length
(
l
)
)
)
Err
(
(
)
)
=
>
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
(
&
Token
:
:
Dimension
{
value
ref
unit
.
.
}
CalcUnit
:
:
Angle
)
=
>
{
match
Angle
:
:
parse_dimension
(
value
unit
true
)
{
Ok
(
a
)
=
>
Ok
(
CalcNode
:
:
Leaf
(
Leaf
:
:
Angle
(
a
)
)
)
Err
(
(
)
)
=
>
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
(
&
Token
:
:
Dimension
{
value
ref
unit
.
.
}
CalcUnit
:
:
Time
)
=
>
{
match
Time
:
:
parse_dimension
(
value
unit
true
)
{
Ok
(
t
)
=
>
Ok
(
CalcNode
:
:
Leaf
(
Leaf
:
:
Time
(
t
)
)
)
Err
(
(
)
)
=
>
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
(
&
Token
:
:
Percentage
{
unit_value
.
.
}
CalcUnit
:
:
LengthPercentage
)
|
(
&
Token
:
:
Percentage
{
unit_value
.
.
}
CalcUnit
:
:
Percentage
)
=
>
{
Ok
(
CalcNode
:
:
Leaf
(
Leaf
:
:
Percentage
(
unit_value
)
)
)
}
(
&
Token
:
:
ParenthesisBlock
_
)
=
>
input
.
parse_nested_block
(
|
input
|
{
CalcNode
:
:
parse_argument
(
context
input
expected_unit
)
}
)
(
&
Token
:
:
Function
(
ref
name
)
_
)
=
>
{
let
function
=
CalcNode
:
:
math_function
(
name
location
)
?
;
CalcNode
:
:
parse
(
context
input
function
expected_unit
)
}
(
t
_
)
=
>
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
}
}
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
expected_unit
:
CalcUnit
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
parse_nested_block
(
|
input
|
{
match
function
{
MathFunction
:
:
Calc
=
>
Self
:
:
parse_argument
(
context
input
expected_unit
)
MathFunction
:
:
Clamp
=
>
{
let
min
=
Self
:
:
parse_argument
(
context
input
expected_unit
)
?
;
input
.
expect_comma
(
)
?
;
let
center
=
Self
:
:
parse_argument
(
context
input
expected_unit
)
?
;
input
.
expect_comma
(
)
?
;
let
max
=
Self
:
:
parse_argument
(
context
input
expected_unit
)
?
;
Ok
(
Self
:
:
Clamp
{
min
:
Box
:
:
new
(
min
)
center
:
Box
:
:
new
(
center
)
max
:
Box
:
:
new
(
max
)
}
)
}
MathFunction
:
:
Min
|
MathFunction
:
:
Max
=
>
{
let
arguments
=
input
.
parse_comma_separated
(
|
input
|
{
Self
:
:
parse_argument
(
context
input
expected_unit
)
}
)
?
;
let
op
=
match
function
{
MathFunction
:
:
Min
=
>
MinMaxOp
:
:
Min
MathFunction
:
:
Max
=
>
MinMaxOp
:
:
Max
_
=
>
unreachable
!
(
)
}
;
Ok
(
Self
:
:
MinMax
(
arguments
.
into
(
)
op
)
)
}
}
}
)
}
fn
parse_argument
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
expected_unit
:
CalcUnit
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
sum
=
SmallVec
:
:
<
[
CalcNode
;
1
]
>
:
:
new
(
)
;
sum
.
push
(
Self
:
:
parse_product
(
context
input
expected_unit
)
?
)
;
loop
{
let
start
=
input
.
state
(
)
;
match
input
.
next_including_whitespace
(
)
{
Ok
(
&
Token
:
:
WhiteSpace
(
_
)
)
=
>
{
if
input
.
is_exhausted
(
)
{
break
;
}
match
*
input
.
next
(
)
?
{
Token
:
:
Delim
(
'
+
'
)
=
>
{
sum
.
push
(
Self
:
:
parse_product
(
context
input
expected_unit
)
?
)
;
}
Token
:
:
Delim
(
'
-
'
)
=
>
{
let
mut
rhs
=
Self
:
:
parse_product
(
context
input
expected_unit
)
?
;
rhs
.
negate
(
)
;
sum
.
push
(
rhs
)
;
}
ref
t
=
>
{
let
t
=
t
.
clone
(
)
;
return
Err
(
input
.
new_unexpected_token_error
(
t
)
)
;
}
}
}
_
=
>
{
input
.
reset
(
&
start
)
;
break
;
}
}
}
Ok
(
if
sum
.
len
(
)
=
=
1
{
sum
.
drain
(
.
.
)
.
next
(
)
.
unwrap
(
)
}
else
{
Self
:
:
Sum
(
sum
.
into_boxed_slice
(
)
.
into
(
)
)
}
)
}
fn
parse_product
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
expected_unit
:
CalcUnit
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
node
=
Self
:
:
parse_one
(
context
input
expected_unit
)
?
;
loop
{
let
start
=
input
.
state
(
)
;
match
input
.
next
(
)
{
Ok
(
&
Token
:
:
Delim
(
'
*
'
)
)
=
>
{
let
rhs
=
Self
:
:
parse_one
(
context
input
expected_unit
)
?
;
if
let
Ok
(
rhs
)
=
rhs
.
to_number
(
)
{
node
.
mul_by
(
rhs
)
;
}
else
if
let
Ok
(
number
)
=
node
.
to_number
(
)
{
node
=
rhs
;
node
.
mul_by
(
number
)
;
}
else
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
}
Ok
(
&
Token
:
:
Delim
(
'
/
'
)
)
=
>
{
let
rhs
=
Self
:
:
parse_one
(
context
input
expected_unit
)
?
;
let
number
=
match
rhs
.
to_number
(
)
{
Ok
(
n
)
if
n
!
=
0
.
=
>
n
_
=
>
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
}
;
node
.
mul_by
(
1
.
/
number
)
;
}
_
=
>
{
input
.
reset
(
&
start
)
;
break
;
}
}
}
Ok
(
node
)
}
fn
into_length_or_percentage
(
mut
self
clamping_mode
:
AllowedNumericType
)
-
>
Result
<
CalcLengthPercentage
(
)
>
{
self
.
simplify_and_sort_children
(
)
;
Ok
(
CalcLengthPercentage
{
clamping_mode
node
:
self
}
)
}
fn
to_time
(
&
self
)
-
>
Result
<
Time
(
)
>
{
let
seconds
=
self
.
resolve
(
|
leaf
|
{
match
*
leaf
{
Leaf
:
:
Time
(
ref
t
)
=
>
Ok
(
t
.
seconds
(
)
)
_
=
>
Err
(
(
)
)
}
}
)
?
;
Ok
(
Time
:
:
from_calc
(
seconds
)
)
}
fn
to_angle
(
&
self
)
-
>
Result
<
Angle
(
)
>
{
let
degrees
=
self
.
resolve
(
|
leaf
|
{
match
*
leaf
{
Leaf
:
:
Angle
(
ref
angle
)
=
>
Ok
(
angle
.
degrees
(
)
)
_
=
>
Err
(
(
)
)
}
}
)
?
;
Ok
(
Angle
:
:
from_calc
(
degrees
)
)
}
fn
to_number
(
&
self
)
-
>
Result
<
CSSFloat
(
)
>
{
self
.
resolve
(
|
leaf
|
{
match
*
leaf
{
Leaf
:
:
Number
(
n
)
=
>
Ok
(
n
)
_
=
>
Err
(
(
)
)
}
}
)
}
fn
to_percentage
(
&
self
)
-
>
Result
<
CSSFloat
(
)
>
{
self
.
resolve
(
|
leaf
|
{
match
*
leaf
{
Leaf
:
:
Percentage
(
p
)
=
>
Ok
(
p
)
_
=
>
Err
(
(
)
)
}
}
)
}
#
[
inline
]
pub
fn
math_function
<
'
i
>
(
name
:
&
CowRcStr
<
'
i
>
location
:
cssparser
:
:
SourceLocation
)
-
>
Result
<
MathFunction
ParseError
<
'
i
>
>
{
if
name
.
eq_ignore_ascii_case
(
"
calc
"
)
{
return
Ok
(
MathFunction
:
:
Calc
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
comparison_functions_enabled
(
)
-
>
bool
{
static_prefs
:
:
pref
!
(
"
layout
.
css
.
comparison
-
functions
.
enabled
"
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
comparison_functions_enabled
(
)
-
>
bool
{
false
}
if
!
comparison_functions_enabled
(
)
{
return
Err
(
location
.
new_unexpected_token_error
(
Token
:
:
Function
(
name
.
clone
(
)
)
)
)
;
}
Ok
(
match_ignore_ascii_case
!
{
&
*
name
"
min
"
=
>
MathFunction
:
:
Min
"
max
"
=
>
MathFunction
:
:
Max
"
clamp
"
=
>
MathFunction
:
:
Clamp
_
=
>
return
Err
(
location
.
new_unexpected_token_error
(
Token
:
:
Function
(
name
.
clone
(
)
)
)
)
}
)
}
pub
fn
parse_integer
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
CSSInteger
ParseError
<
'
i
>
>
{
Self
:
:
parse_number
(
context
input
function
)
.
map
(
|
n
|
n
.
round
(
)
as
CSSInteger
)
}
pub
fn
parse_length_or_percentage
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
clamping_mode
:
AllowedNumericType
function
:
MathFunction
)
-
>
Result
<
CalcLengthPercentage
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
LengthPercentage
)
?
.
into_length_or_percentage
(
clamping_mode
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
parse_percentage
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
CSSFloat
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Percentage
)
?
.
to_percentage
(
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
parse_length
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
clamping_mode
:
AllowedNumericType
function
:
MathFunction
)
-
>
Result
<
CalcLengthPercentage
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Length
)
?
.
into_length_or_percentage
(
clamping_mode
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
parse_number
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
CSSFloat
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Number
)
?
.
to_number
(
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
parse_angle
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
Angle
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Angle
)
?
.
to_angle
(
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
parse_time
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
Time
ParseError
<
'
i
>
>
{
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Time
)
?
.
to_time
(
)
.
map_err
(
|
(
)
|
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
pub
fn
parse_number_or_percentage
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
NumberOrPercentage
ParseError
<
'
i
>
>
{
let
node
=
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Percentage
)
?
;
if
let
Ok
(
value
)
=
node
.
to_number
(
)
{
return
Ok
(
NumberOrPercentage
:
:
Number
{
value
}
)
;
}
match
node
.
to_percentage
(
)
{
Ok
(
unit_value
)
=
>
Ok
(
NumberOrPercentage
:
:
Percentage
{
unit_value
}
)
Err
(
(
)
)
=
>
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
pub
fn
parse_angle_or_number
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
function
:
MathFunction
)
-
>
Result
<
AngleOrNumber
ParseError
<
'
i
>
>
{
let
node
=
Self
:
:
parse
(
context
input
function
CalcUnit
:
:
Angle
)
?
;
if
let
Ok
(
angle
)
=
node
.
to_angle
(
)
{
let
degrees
=
angle
.
degrees
(
)
;
return
Ok
(
AngleOrNumber
:
:
Angle
{
degrees
}
)
;
}
match
node
.
to_number
(
)
{
Ok
(
value
)
=
>
Ok
(
AngleOrNumber
:
:
Number
{
value
}
)
Err
(
(
)
)
=
>
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
}
