use
counter_style
:
:
{
Symbols
parse_counter_style_name
}
;
use
cssparser
:
:
Parser
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
std
:
:
fmt
;
use
style_traits
:
:
{
OneOrMoreCommaSeparated
ToCss
}
;
use
super
:
:
CustomIdent
;
pub
mod
background
;
pub
mod
basic_shape
;
pub
mod
border
;
pub
mod
grid
;
pub
mod
image
;
pub
mod
position
;
pub
mod
rect
;
pub
mod
transform
;
define_css_keyword_enum
!
{
SymbolsType
:
"
cyclic
"
=
>
Cyclic
"
numeric
"
=
>
Numeric
"
alphabetic
"
=
>
Alphabetic
"
symbolic
"
=
>
Symbolic
"
fixed
"
=
>
Fixed
}
add_impls_for_keyword_enum
!
(
SymbolsType
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
SymbolsType
{
pub
fn
to_gecko_keyword
(
self
)
-
>
u8
{
use
gecko_bindings
:
:
structs
;
match
self
{
SymbolsType
:
:
Cyclic
=
>
structs
:
:
NS_STYLE_COUNTER_SYSTEM_CYCLIC
as
u8
SymbolsType
:
:
Numeric
=
>
structs
:
:
NS_STYLE_COUNTER_SYSTEM_NUMERIC
as
u8
SymbolsType
:
:
Alphabetic
=
>
structs
:
:
NS_STYLE_COUNTER_SYSTEM_ALPHABETIC
as
u8
SymbolsType
:
:
Symbolic
=
>
structs
:
:
NS_STYLE_COUNTER_SYSTEM_SYMBOLIC
as
u8
SymbolsType
:
:
Fixed
=
>
structs
:
:
NS_STYLE_COUNTER_SYSTEM_FIXED
as
u8
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
enum
CounterStyleOrNone
{
None_
Name
(
CustomIdent
)
Symbols
(
SymbolsType
Symbols
)
}
impl
CounterStyleOrNone
{
pub
fn
disc
(
)
-
>
Self
{
CounterStyleOrNone
:
:
Name
(
CustomIdent
(
atom
!
(
"
disc
"
)
)
)
}
pub
fn
decimal
(
)
-
>
Self
{
CounterStyleOrNone
:
:
Name
(
CustomIdent
(
atom
!
(
"
decimal
"
)
)
)
}
}
no_viewport_percentage
!
(
CounterStyleOrNone
)
;
impl
Parse
for
CounterStyleOrNone
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
if
let
Ok
(
name
)
=
input
.
try
(
|
i
|
parse_counter_style_name
(
i
)
)
{
return
Ok
(
CounterStyleOrNone
:
:
Name
(
name
)
)
;
}
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
none
"
)
)
.
is_ok
(
)
{
return
Ok
(
CounterStyleOrNone
:
:
None_
)
;
}
if
input
.
try
(
|
i
|
i
.
expect_function_matching
(
"
symbols
"
)
)
.
is_ok
(
)
{
return
input
.
parse_nested_block
(
|
input
|
{
let
symbols_type
=
input
.
try
(
|
i
|
SymbolsType
:
:
parse
(
i
)
)
.
unwrap_or
(
SymbolsType
:
:
Symbolic
)
;
let
symbols
=
Symbols
:
:
parse
(
context
input
)
?
;
if
(
symbols_type
=
=
SymbolsType
:
:
Alphabetic
|
|
symbols_type
=
=
SymbolsType
:
:
Numeric
)
&
&
symbols
.
0
.
len
(
)
<
2
{
return
Err
(
(
)
)
;
}
if
symbols
.
0
.
iter
(
)
.
any
(
|
sym
|
!
sym
.
is_allowed_in_symbols
(
)
)
{
return
Err
(
(
)
)
;
}
Ok
(
CounterStyleOrNone
:
:
Symbols
(
symbols_type
symbols
)
)
}
)
;
}
Err
(
(
)
)
}
}
impl
ToCss
for
CounterStyleOrNone
{
#
[
inline
]
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
self
{
&
CounterStyleOrNone
:
:
None_
=
>
dest
.
write_str
(
"
none
"
)
&
CounterStyleOrNone
:
:
Name
(
ref
name
)
=
>
name
.
to_css
(
dest
)
&
CounterStyleOrNone
:
:
Symbols
(
ref
symbols_type
ref
symbols
)
=
>
{
dest
.
write_str
(
"
symbols
(
"
)
?
;
symbols_type
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
symbols
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
}
}
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
FontSettingTag
<
T
>
{
pub
tag
:
u32
pub
value
:
T
}
impl
<
T
>
OneOrMoreCommaSeparated
for
FontSettingTag
<
T
>
{
}
impl
<
T
:
ToCss
>
ToCss
for
FontSettingTag
<
T
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
use
byteorder
:
:
{
BigEndian
ByteOrder
}
;
use
cssparser
:
:
serialize_string
;
use
std
:
:
str
;
let
mut
raw
=
[
0u8
;
4
]
;
BigEndian
:
:
write_u32
(
&
mut
raw
self
.
tag
)
;
serialize_string
(
str
:
:
from_utf8
(
&
raw
)
.
unwrap_or_default
(
)
dest
)
?
;
self
.
value
.
to_css
(
dest
)
}
}
impl
<
T
:
Parse
>
Parse
for
FontSettingTag
<
T
>
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
use
byteorder
:
:
{
ReadBytesExt
BigEndian
}
;
use
std
:
:
io
:
:
Cursor
;
let
tag
=
try
!
(
input
.
expect_string
(
)
)
;
if
tag
.
len
(
)
!
=
4
|
|
tag
.
chars
(
)
.
any
(
|
c
|
c
<
'
'
|
|
c
>
'
~
'
)
{
return
Err
(
(
)
)
}
let
mut
raw
=
Cursor
:
:
new
(
tag
.
as_bytes
(
)
)
;
let
u_tag
=
raw
.
read_u32
:
:
<
BigEndian
>
(
)
.
unwrap
(
)
;
Ok
(
FontSettingTag
{
tag
:
u_tag
value
:
T
:
:
parse
(
context
input
)
?
}
)
}
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
FontSettings
<
T
>
{
Normal
Tag
(
Vec
<
FontSettingTag
<
T
>
>
)
}
impl
<
T
:
ToCss
>
ToCss
for
FontSettings
<
T
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
FontSettings
:
:
Normal
=
>
dest
.
write_str
(
"
normal
"
)
FontSettings
:
:
Tag
(
ref
ftvs
)
=
>
ftvs
.
to_css
(
dest
)
}
}
}
impl
<
T
:
Parse
>
Parse
for
FontSettings
<
T
>
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
normal
"
)
)
.
is_ok
(
)
{
return
Ok
(
FontSettings
:
:
Normal
)
;
}
Vec
:
:
parse
(
context
input
)
.
map
(
FontSettings
:
:
Tag
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
FontSettingTagInt
(
pub
u32
)
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
FontSettingTagFloat
(
pub
f32
)
;
impl
ToCss
for
FontSettingTagInt
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
self
.
0
{
1
=
>
Ok
(
(
)
)
0
=
>
dest
.
write_str
(
"
off
"
)
x
=
>
write
!
(
dest
"
{
}
"
x
)
}
}
}
impl
Parse
for
FontSettingTagInt
{
fn
parse
(
_context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
if
let
Ok
(
value
)
=
input
.
try
(
|
input
|
input
.
expect_integer
(
)
)
{
if
value
>
=
0
{
Ok
(
FontSettingTagInt
(
value
as
u32
)
)
}
else
{
Err
(
(
)
)
}
}
else
if
let
Ok
(
_
)
=
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
on
"
)
)
{
Ok
(
FontSettingTagInt
(
1
)
)
}
else
if
let
Ok
(
_
)
=
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
off
"
)
)
{
Ok
(
FontSettingTagInt
(
0
)
)
}
else
{
Ok
(
FontSettingTagInt
(
1
)
)
}
}
}
impl
Parse
for
FontSettingTagFloat
{
fn
parse
(
_
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
input
.
expect_number
(
)
.
map
(
FontSettingTagFloat
)
}
}
impl
ToCss
for
FontSettingTagFloat
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_str
(
"
"
)
?
;
self
.
0
.
to_css
(
dest
)
}
}
