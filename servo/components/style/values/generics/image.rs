use
crate
:
:
custom_properties
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
PositionComponent
;
use
crate
:
:
values
:
:
serialize_atom_identifier
;
use
crate
:
:
Atom
;
use
crate
:
:
Zero
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
#
[
derive
(
Clone
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericImage
<
G
MozImageRect
ImageUrl
>
{
None
Url
(
ImageUrl
)
Gradient
(
Box
<
G
>
)
Rect
(
Box
<
MozImageRect
>
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
css
(
function
=
"
-
moz
-
element
"
)
]
Element
(
Atom
)
#
[
cfg
(
feature
=
"
servo
-
layout
-
2013
"
)
]
PaintWorklet
(
PaintWorklet
)
}
pub
use
self
:
:
GenericImage
as
Image
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
enum
GenericGradient
<
LineDirection
LengthPercentage
NonNegativeLength
NonNegativeLengthPercentage
Position
Angle
AngleOrPercentage
Color
>
{
Linear
{
direction
:
LineDirection
items
:
crate
:
:
OwnedSlice
<
GenericGradientItem
<
Color
LengthPercentage
>
>
repeating
:
bool
compat_mode
:
GradientCompatMode
}
Radial
{
shape
:
GenericEndingShape
<
NonNegativeLength
NonNegativeLengthPercentage
>
position
:
Position
items
:
crate
:
:
OwnedSlice
<
GenericGradientItem
<
Color
LengthPercentage
>
>
repeating
:
bool
compat_mode
:
GradientCompatMode
}
Conic
{
angle
:
Angle
position
:
Position
items
:
crate
:
:
OwnedSlice
<
GenericGradientItem
<
Color
AngleOrPercentage
>
>
repeating
:
bool
}
}
pub
use
self
:
:
GenericGradient
as
Gradient
;
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
GradientCompatMode
{
Modern
WebKit
Moz
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericEndingShape
<
NonNegativeLength
NonNegativeLengthPercentage
>
{
Circle
(
GenericCircle
<
NonNegativeLength
>
)
Ellipse
(
GenericEllipse
<
NonNegativeLengthPercentage
>
)
}
pub
use
self
:
:
GenericEndingShape
as
EndingShape
;
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericCircle
<
NonNegativeLength
>
{
Radius
(
NonNegativeLength
)
Extent
(
ShapeExtent
)
}
pub
use
self
:
:
GenericCircle
as
Circle
;
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericEllipse
<
NonNegativeLengthPercentage
>
{
Radii
(
NonNegativeLengthPercentage
NonNegativeLengthPercentage
)
Extent
(
ShapeExtent
)
}
pub
use
self
:
:
GenericEllipse
as
Ellipse
;
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ShapeExtent
{
ClosestSide
FarthestSide
ClosestCorner
FarthestCorner
Contain
Cover
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericGradientItem
<
Color
T
>
{
SimpleColorStop
(
Color
)
ComplexColorStop
{
color
:
Color
position
:
T
}
InterpolationHint
(
T
)
}
pub
use
self
:
:
GenericGradientItem
as
GradientItem
;
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
pub
struct
ColorStop
<
Color
T
>
{
pub
color
:
Color
pub
position
:
Option
<
T
>
}
impl
<
Color
T
>
ColorStop
<
Color
T
>
{
#
[
inline
]
pub
fn
into_item
(
self
)
-
>
GradientItem
<
Color
T
>
{
match
self
.
position
{
Some
(
position
)
=
>
GradientItem
:
:
ComplexColorStop
{
color
:
self
.
color
position
}
None
=
>
GradientItem
:
:
SimpleColorStop
(
self
.
color
)
}
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
ToComputedValue
ToResolvedValue
ToShmem
)
]
pub
struct
PaintWorklet
{
pub
name
:
Atom
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
Arc
"
)
]
#
[
compute
(
no_field_bound
)
]
#
[
resolve
(
no_field_bound
)
]
pub
arguments
:
Vec
<
Arc
<
custom_properties
:
:
SpecifiedValue
>
>
}
impl
:
:
style_traits
:
:
SpecifiedValueInfo
for
PaintWorklet
{
}
impl
ToCss
for
PaintWorklet
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
dest
.
write_str
(
"
paint
(
"
)
?
;
serialize_atom_identifier
(
&
self
.
name
dest
)
?
;
for
argument
in
&
self
.
arguments
{
dest
.
write_str
(
"
"
)
?
;
argument
.
to_css
(
dest
)
?
;
}
dest
.
write_str
(
"
)
"
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
css
(
comma
function
=
"
-
moz
-
image
-
rect
"
)
]
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
GenericMozImageRect
<
NumberOrPercentage
MozImageRectUrl
>
{
pub
url
:
MozImageRectUrl
pub
top
:
NumberOrPercentage
pub
right
:
NumberOrPercentage
pub
bottom
:
NumberOrPercentage
pub
left
:
NumberOrPercentage
}
pub
use
self
:
:
GenericMozImageRect
as
MozImageRect
;
impl
<
G
R
U
>
fmt
:
:
Debug
for
Image
<
G
R
U
>
where
G
:
ToCss
R
:
ToCss
U
:
ToCss
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
to_css
(
&
mut
CssWriter
:
:
new
(
f
)
)
}
}
impl
<
G
R
U
>
ToCss
for
Image
<
G
R
U
>
where
G
:
ToCss
R
:
ToCss
U
:
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
*
self
{
Image
:
:
None
=
>
dest
.
write_str
(
"
none
"
)
Image
:
:
Url
(
ref
url
)
=
>
url
.
to_css
(
dest
)
Image
:
:
Gradient
(
ref
gradient
)
=
>
gradient
.
to_css
(
dest
)
Image
:
:
Rect
(
ref
rect
)
=
>
rect
.
to_css
(
dest
)
#
[
cfg
(
feature
=
"
servo
-
layout
-
2013
"
)
]
Image
:
:
PaintWorklet
(
ref
paint_worklet
)
=
>
paint_worklet
.
to_css
(
dest
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Image
:
:
Element
(
ref
selector
)
=
>
{
dest
.
write_str
(
"
-
moz
-
element
(
#
"
)
?
;
serialize_atom_identifier
(
selector
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
}
}
}
impl
<
D
LP
NL
NLP
P
A
:
Zero
AoP
C
>
ToCss
for
Gradient
<
D
LP
NL
NLP
P
A
AoP
C
>
where
D
:
LineDirection
LP
:
ToCss
NL
:
ToCss
NLP
:
ToCss
P
:
PositionComponent
+
ToCss
A
:
ToCss
AoP
:
ToCss
C
:
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
let
(
compat_mode
repeating
)
=
match
*
self
{
Gradient
:
:
Linear
{
compat_mode
repeating
.
.
}
=
>
(
compat_mode
repeating
)
Gradient
:
:
Radial
{
compat_mode
repeating
.
.
}
=
>
(
compat_mode
repeating
)
Gradient
:
:
Conic
{
repeating
.
.
}
=
>
(
GradientCompatMode
:
:
Modern
repeating
)
}
;
match
compat_mode
{
GradientCompatMode
:
:
WebKit
=
>
dest
.
write_str
(
"
-
webkit
-
"
)
?
GradientCompatMode
:
:
Moz
=
>
dest
.
write_str
(
"
-
moz
-
"
)
?
_
=
>
{
}
}
if
repeating
{
dest
.
write_str
(
"
repeating
-
"
)
?
;
}
match
*
self
{
Gradient
:
:
Linear
{
ref
direction
ref
items
compat_mode
.
.
}
=
>
{
dest
.
write_str
(
"
linear
-
gradient
(
"
)
?
;
let
mut
skip_comma
=
if
!
direction
.
points_downwards
(
compat_mode
)
{
direction
.
to_css
(
dest
compat_mode
)
?
;
false
}
else
{
true
}
;
for
item
in
&
*
*
items
{
if
!
skip_comma
{
dest
.
write_str
(
"
"
)
?
;
}
skip_comma
=
false
;
item
.
to_css
(
dest
)
?
;
}
}
Gradient
:
:
Radial
{
ref
shape
ref
position
ref
items
compat_mode
.
.
}
=
>
{
dest
.
write_str
(
"
radial
-
gradient
(
"
)
?
;
let
omit_shape
=
match
*
shape
{
EndingShape
:
:
Ellipse
(
Ellipse
:
:
Extent
(
ShapeExtent
:
:
Cover
)
)
|
EndingShape
:
:
Ellipse
(
Ellipse
:
:
Extent
(
ShapeExtent
:
:
FarthestCorner
)
)
=
>
true
_
=
>
false
}
;
let
omit_position
=
position
.
is_center
(
)
;
if
compat_mode
=
=
GradientCompatMode
:
:
Modern
{
if
!
omit_shape
{
shape
.
to_css
(
dest
)
?
;
if
!
omit_position
{
dest
.
write_str
(
"
"
)
?
;
}
}
if
!
omit_position
{
dest
.
write_str
(
"
at
"
)
?
;
position
.
to_css
(
dest
)
?
;
}
}
else
{
if
!
omit_position
{
position
.
to_css
(
dest
)
?
;
if
!
omit_shape
{
dest
.
write_str
(
"
"
)
?
;
}
}
if
!
omit_shape
{
shape
.
to_css
(
dest
)
?
;
}
}
let
mut
skip_comma
=
omit_shape
&
&
omit_position
;
for
item
in
&
*
*
items
{
if
!
skip_comma
{
dest
.
write_str
(
"
"
)
?
;
}
skip_comma
=
false
;
item
.
to_css
(
dest
)
?
;
}
}
Gradient
:
:
Conic
{
ref
angle
ref
position
ref
items
.
.
}
=
>
{
dest
.
write_str
(
"
conic
-
gradient
(
"
)
?
;
let
omit_angle
=
angle
.
is_zero
(
)
;
let
omit_position
=
position
.
is_center
(
)
;
if
!
omit_angle
{
dest
.
write_str
(
"
from
"
)
?
;
angle
.
to_css
(
dest
)
?
;
if
!
omit_position
{
dest
.
write_str
(
"
"
)
?
;
}
}
if
!
omit_position
{
dest
.
write_str
(
"
at
"
)
?
;
position
.
to_css
(
dest
)
?
;
}
let
mut
skip_comma
=
omit_angle
&
&
omit_position
;
for
item
in
&
*
*
items
{
if
!
skip_comma
{
dest
.
write_str
(
"
"
)
?
;
}
skip_comma
=
false
;
item
.
to_css
(
dest
)
?
;
}
}
}
dest
.
write_str
(
"
)
"
)
}
}
pub
trait
LineDirection
{
fn
points_downwards
(
&
self
compat_mode
:
GradientCompatMode
)
-
>
bool
;
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
compat_mode
:
GradientCompatMode
)
-
>
fmt
:
:
Result
where
W
:
Write
;
}
impl
<
L
>
ToCss
for
Circle
<
L
>
where
L
:
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
*
self
{
Circle
:
:
Extent
(
ShapeExtent
:
:
FarthestCorner
)
|
Circle
:
:
Extent
(
ShapeExtent
:
:
Cover
)
=
>
{
dest
.
write_str
(
"
circle
"
)
}
Circle
:
:
Extent
(
keyword
)
=
>
{
dest
.
write_str
(
"
circle
"
)
?
;
keyword
.
to_css
(
dest
)
}
Circle
:
:
Radius
(
ref
length
)
=
>
length
.
to_css
(
dest
)
}
}
}
