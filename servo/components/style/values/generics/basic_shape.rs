use
cssparser
:
:
Parser
;
use
euclid
:
:
size
:
:
Size2D
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
properties
:
:
shorthands
:
:
serialize_four_sides
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
fmt
;
use
style_traits
:
:
{
HasViewportPercentage
ToCss
}
;
use
values
:
:
computed
:
:
ComputedValueAsSpecified
;
use
values
:
:
generics
:
:
BorderRadiusSize
;
use
values
:
:
specified
:
:
url
:
:
SpecifiedUrl
;
#
[
derive
(
Clone
Debug
PartialEq
ToComputedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
BorderRadius
<
L
>
{
pub
top_left
:
BorderRadiusSize
<
L
>
pub
top_right
:
BorderRadiusSize
<
L
>
pub
bottom_right
:
BorderRadiusSize
<
L
>
pub
bottom_left
:
BorderRadiusSize
<
L
>
}
pub
fn
serialize_radius_values
<
L
W
>
(
dest
:
&
mut
W
top_left
:
&
Size2D
<
L
>
top_right
:
&
Size2D
<
L
>
bottom_right
:
&
Size2D
<
L
>
bottom_left
:
&
Size2D
<
L
>
)
-
>
fmt
:
:
Result
where
L
:
ToCss
+
PartialEq
W
:
fmt
:
:
Write
{
if
top_left
.
width
=
=
top_left
.
height
&
&
top_right
.
width
=
=
top_right
.
height
&
&
bottom_right
.
width
=
=
bottom_right
.
height
&
&
bottom_left
.
width
=
=
bottom_left
.
height
{
serialize_four_sides
(
dest
&
top_left
.
width
&
top_right
.
width
&
bottom_right
.
width
&
bottom_left
.
width
)
}
else
{
serialize_four_sides
(
dest
&
top_left
.
width
&
top_right
.
width
&
bottom_right
.
width
&
bottom_left
.
width
)
?
;
dest
.
write_str
(
"
/
"
)
?
;
serialize_four_sides
(
dest
&
top_left
.
height
&
top_right
.
height
&
bottom_right
.
height
&
bottom_left
.
height
)
}
}
impl
<
L
:
ToCss
+
PartialEq
>
ToCss
for
BorderRadius
<
L
>
{
#
[
inline
]
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
serialize_radius_values
(
dest
&
self
.
top_left
.
0
&
self
.
top_right
.
0
&
self
.
bottom_right
.
0
&
self
.
bottom_left
.
0
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
ToComputedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
ShapeRadius
<
L
>
{
Length
(
L
)
ClosestSide
FarthestSide
}
impl
<
L
>
Default
for
ShapeRadius
<
L
>
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
ShapeRadius
:
:
ClosestSide
}
}
impl
<
L
:
ToCss
>
ToCss
for
ShapeRadius
<
L
>
{
#
[
inline
]
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
ShapeRadius
:
:
Length
(
ref
lop
)
=
>
lop
.
to_css
(
dest
)
ShapeRadius
:
:
ClosestSide
=
>
dest
.
write_str
(
"
closest
-
side
"
)
ShapeRadius
:
:
FarthestSide
=
>
dest
.
write_str
(
"
farthest
-
side
"
)
}
}
}
define_css_keyword_enum
!
(
FillRule
:
"
nonzero
"
=
>
NonZero
"
evenodd
"
=
>
EvenOdd
)
;
impl
ComputedValueAsSpecified
for
FillRule
{
}
impl
Default
for
FillRule
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
FillRule
:
:
NonZero
}
}
#
[
derive
(
Clone
Debug
PartialEq
ToComputedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
Polygon
<
L
>
{
pub
fill
:
FillRule
pub
coordinates
:
Vec
<
(
L
L
)
>
}
impl
<
L
:
Parse
>
Polygon
<
L
>
{
pub
fn
parse_function_arguments
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
let
fill
=
input
.
try
(
|
i
|
-
>
Result
<
_
(
)
>
{
let
fill
=
FillRule
:
:
parse
(
i
)
?
;
i
.
expect_comma
(
)
?
;
Ok
(
fill
)
}
)
.
ok
(
)
.
unwrap_or_default
(
)
;
let
buf
=
input
.
parse_comma_separated
(
|
i
|
{
Ok
(
(
L
:
:
parse
(
context
i
)
?
L
:
:
parse
(
context
i
)
?
)
)
}
)
?
;
Ok
(
Polygon
{
fill
:
fill
coordinates
:
buf
}
)
}
}
impl
<
L
:
Parse
>
Parse
for
Polygon
<
L
>
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
match
input
.
expect_function
(
)
{
Ok
(
ref
s
)
if
s
.
eq_ignore_ascii_case
(
"
polygon
"
)
=
>
input
.
parse_nested_block
(
|
i
|
Polygon
:
:
parse_function_arguments
(
context
i
)
)
_
=
>
Err
(
(
)
)
}
}
}
impl
<
L
:
ToCss
>
ToCss
for
Polygon
<
L
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_str
(
"
polygon
(
"
)
?
;
if
self
.
fill
!
=
FillRule
:
:
default
(
)
{
self
.
fill
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
}
for
(
i
coord
)
in
self
.
coordinates
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
dest
.
write_str
(
"
"
)
?
;
}
coord
.
0
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
coord
.
1
.
to_css
(
dest
)
?
;
}
dest
.
write_str
(
"
)
"
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
ToComputedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
InsetRect
<
L
>
{
pub
top
:
L
pub
right
:
L
pub
bottom
:
L
pub
left
:
L
pub
round
:
Option
<
BorderRadius
<
L
>
>
}
impl
<
L
:
ToCss
+
PartialEq
>
ToCss
for
InsetRect
<
L
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_str
(
"
inset
(
"
)
?
;
self
.
top
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
self
.
right
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
self
.
bottom
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
self
.
left
.
to_css
(
dest
)
?
;
if
let
Some
(
ref
radius
)
=
self
.
round
{
dest
.
write_str
(
"
round
"
)
?
;
radius
.
to_css
(
dest
)
?
;
}
dest
.
write_str
(
"
)
"
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
ToComputedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
ShapeSource
<
B
T
>
{
Url
(
SpecifiedUrl
)
Shape
(
B
Option
<
T
>
)
Box
(
T
)
None
}
impl
<
B
T
>
HasViewportPercentage
for
ShapeSource
<
B
T
>
{
#
[
inline
]
fn
has_viewport_percentage
(
&
self
)
-
>
bool
{
false
}
}
impl
<
B
:
ToCss
T
:
ToCss
>
ToCss
for
ShapeSource
<
B
T
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
ShapeSource
:
:
Url
(
ref
url
)
=
>
url
.
to_css
(
dest
)
ShapeSource
:
:
Shape
(
ref
shape
Some
(
ref
ref_box
)
)
=
>
{
shape
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
ref_box
.
to_css
(
dest
)
}
ShapeSource
:
:
Shape
(
ref
shape
None
)
=
>
shape
.
to_css
(
dest
)
ShapeSource
:
:
Box
(
ref
val
)
=
>
val
.
to_css
(
dest
)
ShapeSource
:
:
None
=
>
dest
.
write_str
(
"
none
"
)
}
}
}
impl
<
B
:
Parse
T
:
Parse
>
Parse
for
ShapeSource
<
B
T
>
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
none
"
)
)
.
is_ok
(
)
{
return
Ok
(
ShapeSource
:
:
None
)
}
if
let
Ok
(
url
)
=
input
.
try
(
|
i
|
SpecifiedUrl
:
:
parse
(
context
i
)
)
{
return
Ok
(
ShapeSource
:
:
Url
(
url
)
)
}
fn
parse_component
<
U
:
Parse
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
component
:
&
mut
Option
<
U
>
)
-
>
bool
{
if
component
.
is_some
(
)
{
return
false
}
*
component
=
input
.
try
(
|
i
|
U
:
:
parse
(
context
i
)
)
.
ok
(
)
;
component
.
is_some
(
)
}
let
mut
shape
=
None
;
let
mut
ref_box
=
None
;
while
parse_component
(
context
input
&
mut
shape
)
|
|
parse_component
(
context
input
&
mut
ref_box
)
{
}
if
let
Some
(
shp
)
=
shape
{
return
Ok
(
ShapeSource
:
:
Shape
(
shp
ref_box
)
)
}
ref_box
.
map
(
|
v
|
ShapeSource
:
:
Box
(
v
)
)
.
ok_or
(
(
)
)
}
}
