use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
use
values
:
:
animated
:
:
{
Animate
Procedure
ToAnimatedZero
}
;
use
values
:
:
distance
:
:
{
ComputeSquaredDistance
SquaredDistance
}
;
use
values
:
:
generics
:
:
border
:
:
BorderRadius
;
use
values
:
:
generics
:
:
position
:
:
Position
;
use
values
:
:
generics
:
:
rect
:
:
Rect
;
pub
type
ClippingShape
<
BasicShape
Url
>
=
ShapeSource
<
BasicShape
GeometryBox
Url
>
;
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Animate
Clone
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
enum
GeometryBox
{
FillBox
StrokeBox
ViewBox
ShapeBox
(
ShapeBox
)
}
pub
type
FloatAreaShape
<
BasicShape
Image
>
=
ShapeSource
<
BasicShape
ShapeBox
Image
>
;
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Animate
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
enum
ShapeBox
{
MarginBox
BorderBox
PaddingBox
ContentBox
}
#
[
allow
(
missing_docs
)
]
#
[
animation
(
no_bound
(
ImageOrUrl
)
)
]
#
[
derive
(
Animate
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
enum
ShapeSource
<
BasicShape
ReferenceBox
ImageOrUrl
>
{
#
[
animation
(
error
)
]
ImageOrUrl
(
ImageOrUrl
)
Shape
(
BasicShape
Option
<
ReferenceBox
>
)
#
[
animation
(
error
)
]
Box
(
ReferenceBox
)
#
[
animation
(
error
)
]
None
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
enum
BasicShape
<
H
V
LengthOrPercentage
>
{
Inset
(
#
[
css
(
field_bound
)
]
InsetRect
<
LengthOrPercentage
>
)
Circle
(
#
[
css
(
field_bound
)
]
Circle
<
H
V
LengthOrPercentage
>
)
Ellipse
(
#
[
css
(
field_bound
)
]
Ellipse
<
H
V
LengthOrPercentage
>
)
Polygon
(
Polygon
<
LengthOrPercentage
>
)
}
#
[
allow
(
missing_docs
)
]
#
[
css
(
function
=
"
inset
"
)
]
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
)
]
pub
struct
InsetRect
<
LengthOrPercentage
>
{
pub
rect
:
Rect
<
LengthOrPercentage
>
pub
round
:
Option
<
BorderRadius
<
LengthOrPercentage
>
>
}
#
[
allow
(
missing_docs
)
]
#
[
css
(
function
)
]
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
)
]
pub
struct
Circle
<
H
V
LengthOrPercentage
>
{
pub
position
:
Position
<
H
V
>
pub
radius
:
ShapeRadius
<
LengthOrPercentage
>
}
#
[
allow
(
missing_docs
)
]
#
[
css
(
function
)
]
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
)
]
pub
struct
Ellipse
<
H
V
LengthOrPercentage
>
{
pub
position
:
Position
<
H
V
>
pub
semiaxis_x
:
ShapeRadius
<
LengthOrPercentage
>
pub
semiaxis_y
:
ShapeRadius
<
LengthOrPercentage
>
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
enum
ShapeRadius
<
LengthOrPercentage
>
{
Length
(
LengthOrPercentage
)
#
[
animation
(
error
)
]
ClosestSide
#
[
animation
(
error
)
]
FarthestSide
}
#
[
css
(
comma
function
)
]
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
struct
Polygon
<
LengthOrPercentage
>
{
#
[
css
(
skip_if
=
"
fill_is_default
"
)
]
pub
fill
:
FillRule
#
[
css
(
iterable
)
]
pub
coordinates
:
Vec
<
PolygonCoord
<
LengthOrPercentage
>
>
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
struct
PolygonCoord
<
LengthOrPercentage
>
(
pub
LengthOrPercentage
pub
LengthOrPercentage
)
;
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
)
]
pub
enum
FillRule
{
Nonzero
Evenodd
}
impl
<
B
T
U
>
ComputeSquaredDistance
for
ShapeSource
<
B
T
U
>
where
B
:
ComputeSquaredDistance
T
:
PartialEq
{
fn
compute_squared_distance
(
&
self
other
:
&
Self
)
-
>
Result
<
SquaredDistance
(
)
>
{
match
(
self
other
)
{
(
&
ShapeSource
:
:
Shape
(
ref
this
ref
this_box
)
&
ShapeSource
:
:
Shape
(
ref
other
ref
other_box
)
)
if
this_box
=
=
other_box
=
>
{
this
.
compute_squared_distance
(
other
)
}
_
=
>
Err
(
(
)
)
}
}
}
impl
<
B
T
U
>
ToAnimatedZero
for
ShapeSource
<
B
T
U
>
{
fn
to_animated_zero
(
&
self
)
-
>
Result
<
Self
(
)
>
{
Err
(
(
)
)
}
}
impl
<
L
>
ToCss
for
InsetRect
<
L
>
where
L
:
ToCss
+
PartialEq
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
dest
.
write_str
(
"
inset
(
"
)
?
;
self
.
rect
.
to_css
(
dest
)
?
;
if
let
Some
(
ref
radius
)
=
self
.
round
{
dest
.
write_str
(
"
round
"
)
?
;
radius
.
to_css
(
dest
)
?
;
}
dest
.
write_str
(
"
)
"
)
}
}
impl
<
L
>
Default
for
ShapeRadius
<
L
>
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
ShapeRadius
:
:
ClosestSide
}
}
impl
<
L
>
Animate
for
Polygon
<
L
>
where
L
:
Animate
{
fn
animate
(
&
self
other
:
&
Self
procedure
:
Procedure
)
-
>
Result
<
Self
(
)
>
{
if
self
.
fill
!
=
other
.
fill
{
return
Err
(
(
)
)
;
}
if
self
.
coordinates
.
len
(
)
!
=
other
.
coordinates
.
len
(
)
{
return
Err
(
(
)
)
;
}
let
coordinates
=
self
.
coordinates
.
iter
(
)
.
zip
(
other
.
coordinates
.
iter
(
)
)
.
map
(
|
(
this
other
)
|
{
Ok
(
PolygonCoord
(
this
.
0
.
animate
(
&
other
.
0
procedure
)
?
this
.
1
.
animate
(
&
other
.
1
procedure
)
?
)
)
}
)
.
collect
:
:
<
Result
<
Vec
<
_
>
_
>
>
(
)
?
;
Ok
(
Polygon
{
fill
:
self
.
fill
coordinates
}
)
}
}
impl
<
L
>
ComputeSquaredDistance
for
Polygon
<
L
>
where
L
:
ComputeSquaredDistance
{
fn
compute_squared_distance
(
&
self
other
:
&
Self
)
-
>
Result
<
SquaredDistance
(
)
>
{
if
self
.
fill
!
=
other
.
fill
{
return
Err
(
(
)
)
;
}
if
self
.
coordinates
.
len
(
)
!
=
other
.
coordinates
.
len
(
)
{
return
Err
(
(
)
)
;
}
self
.
coordinates
.
iter
(
)
.
zip
(
other
.
coordinates
.
iter
(
)
)
.
map
(
|
(
this
other
)
|
{
let
d1
=
this
.
0
.
compute_squared_distance
(
&
other
.
0
)
?
;
let
d2
=
this
.
1
.
compute_squared_distance
(
&
other
.
1
)
?
;
Ok
(
d1
+
d2
)
}
)
.
sum
(
)
}
}
impl
Default
for
FillRule
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
FillRule
:
:
Nonzero
}
}
#
[
inline
]
fn
fill_is_default
(
fill
:
&
FillRule
)
-
>
bool
{
*
fill
=
=
FillRule
:
:
default
(
)
}
