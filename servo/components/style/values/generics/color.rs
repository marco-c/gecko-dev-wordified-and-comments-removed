use
crate
:
:
color
:
:
{
mix
:
:
ColorInterpolationMethod
AbsoluteColor
ColorFunction
}
;
use
crate
:
:
values
:
:
{
computed
:
:
ToComputedValue
specified
:
:
percentage
:
:
ToPercentage
ParseError
Parser
}
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToAnimatedValue
ToShmem
ToTyped
)
]
#
[
repr
(
C
)
]
pub
enum
GenericColor
<
Percentage
>
{
Absolute
(
AbsoluteColor
)
ColorFunction
(
Box
<
ColorFunction
<
Self
>
>
)
CurrentColor
ColorMix
(
Box
<
GenericColorMix
<
Self
Percentage
>
>
)
}
#
[
derive
(
Clone
Copy
Debug
Default
MallocSizeOf
PartialEq
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
ColorMixFlags
(
u8
)
;
bitflags
!
{
impl
ColorMixFlags
:
u8
{
/
/
/
Normalize
the
weights
of
the
mix
.
const
NORMALIZE_WEIGHTS
=
1
<
<
0
;
/
/
/
The
result
should
always
be
converted
to
the
modern
color
syntax
.
const
RESULT_IN_MODERN_SYNTAX
=
1
<
<
1
;
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToAnimatedValue
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
allow
(
missing_docs
)
]
#
[
repr
(
C
)
]
pub
struct
GenericColorMix
<
Color
Percentage
>
{
pub
interpolation
:
ColorInterpolationMethod
pub
left
:
Color
pub
left_percentage
:
Percentage
pub
right
:
Color
pub
right_percentage
:
Percentage
pub
flags
:
ColorMixFlags
}
pub
use
self
:
:
GenericColorMix
as
ColorMix
;
impl
<
Color
:
ToCss
Percentage
:
ToCss
+
ToPercentage
>
ToCss
for
ColorMix
<
Color
Percentage
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
fn
can_omit
<
Percentage
:
ToPercentage
>
(
percent
:
&
Percentage
other
:
&
Percentage
is_left
:
bool
)
-
>
bool
{
if
percent
.
is_calc
(
)
{
return
false
;
}
if
percent
.
to_percentage
(
)
=
=
0
.
5
{
return
other
.
to_percentage
(
)
=
=
0
.
5
;
}
if
is_left
{
return
false
;
}
(
1
.
0
-
percent
.
to_percentage
(
)
-
other
.
to_percentage
(
)
)
.
abs
(
)
<
=
f32
:
:
EPSILON
}
dest
.
write_str
(
"
color
-
mix
(
"
)
?
;
self
.
interpolation
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
self
.
left
.
to_css
(
dest
)
?
;
if
!
can_omit
(
&
self
.
left_percentage
&
self
.
right_percentage
true
)
{
dest
.
write_char
(
'
'
)
?
;
self
.
left_percentage
.
to_css
(
dest
)
?
;
}
dest
.
write_str
(
"
"
)
?
;
self
.
right
.
to_css
(
dest
)
?
;
if
!
can_omit
(
&
self
.
right_percentage
&
self
.
left_percentage
false
)
{
dest
.
write_char
(
'
'
)
?
;
self
.
right_percentage
.
to_css
(
dest
)
?
;
}
dest
.
write_char
(
'
)
'
)
}
}
impl
<
Percentage
>
ColorMix
<
GenericColor
<
Percentage
>
Percentage
>
{
pub
fn
mix_to_absolute
(
&
self
)
-
>
Option
<
AbsoluteColor
>
where
Percentage
:
ToPercentage
{
let
left
=
self
.
left
.
as_absolute
(
)
?
;
let
right
=
self
.
right
.
as_absolute
(
)
?
;
Some
(
crate
:
:
color
:
:
mix
:
:
mix
(
self
.
interpolation
&
left
self
.
left_percentage
.
to_percentage
(
)
&
right
self
.
right_percentage
.
to_percentage
(
)
self
.
flags
)
)
}
}
pub
use
self
:
:
GenericColor
as
Color
;
impl
<
Percentage
>
Color
<
Percentage
>
{
pub
fn
as_absolute
(
&
self
)
-
>
Option
<
&
AbsoluteColor
>
{
match
*
self
{
Self
:
:
Absolute
(
ref
absolute
)
=
>
Some
(
absolute
)
_
=
>
None
}
}
pub
fn
currentcolor
(
)
-
>
Self
{
Self
:
:
CurrentColor
}
pub
fn
is_currentcolor
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Self
:
:
CurrentColor
)
}
pub
fn
is_absolute
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Self
:
:
Absolute
(
.
.
)
)
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
Parse
SpecifiedValueInfo
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToResolvedValue
ToCss
ToShmem
ToTyped
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericColorOrAuto
<
C
>
{
Color
(
C
)
Auto
}
pub
use
self
:
:
GenericColorOrAuto
as
ColorOrAuto
;
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToCss
ToShmem
ToTyped
)
]
#
[
repr
(
transparent
)
]
pub
struct
GenericCaretColor
<
C
>
(
pub
GenericColorOrAuto
<
C
>
)
;
impl
<
C
>
GenericCaretColor
<
C
>
{
pub
fn
auto
(
)
-
>
Self
{
GenericCaretColor
(
GenericColorOrAuto
:
:
Auto
)
}
}
pub
use
self
:
:
GenericCaretColor
as
CaretColor
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToShmem
ToCss
ToResolvedValue
)
]
#
[
css
(
function
=
"
light
-
dark
"
comma
)
]
#
[
repr
(
C
)
]
pub
struct
GenericLightDark
<
T
>
{
pub
light
:
T
pub
dark
:
T
}
impl
<
T
>
GenericLightDark
<
T
>
{
pub
fn
parse_args_with
<
'
i
>
(
input
:
&
mut
Parser
<
'
i
'
_
>
mut
parse_one
:
impl
FnMut
(
&
mut
Parser
<
'
i
'
_
>
)
-
>
Result
<
T
ParseError
<
'
i
>
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
light
=
parse_one
(
input
)
?
;
input
.
expect_comma
(
)
?
;
let
dark
=
parse_one
(
input
)
?
;
Ok
(
Self
{
light
dark
}
)
}
pub
fn
parse_with
<
'
i
>
(
input
:
&
mut
Parser
<
'
i
'
_
>
parse_one
:
impl
FnMut
(
&
mut
Parser
<
'
i
'
_
>
)
-
>
Result
<
T
ParseError
<
'
i
>
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
expect_function_matching
(
"
light
-
dark
"
)
?
;
input
.
parse_nested_block
(
|
input
|
Self
:
:
parse_args_with
(
input
parse_one
)
)
}
}
impl
<
T
:
ToComputedValue
>
GenericLightDark
<
T
>
{
pub
fn
compute
(
&
self
cx
:
&
crate
:
:
values
:
:
computed
:
:
Context
)
-
>
T
:
:
ComputedValue
{
let
dark
=
cx
.
device
(
)
.
is_dark_color_scheme
(
cx
.
builder
.
color_scheme
)
;
if
cx
.
for_non_inherited_property
{
cx
.
rule_cache_conditions
.
borrow_mut
(
)
.
set_color_scheme_dependency
(
cx
.
builder
.
color_scheme
)
;
}
let
chosen
=
if
dark
{
&
self
.
dark
}
else
{
&
self
.
light
}
;
chosen
.
to_computed_value
(
cx
)
}
}
