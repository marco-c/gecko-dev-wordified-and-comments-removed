use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ParseError
ToCss
}
;
use
crate
:
:
values
:
:
{
Parse
ParserContext
Parser
}
;
use
crate
:
:
values
:
:
specified
:
:
percentage
:
:
ToPercentage
;
use
crate
:
:
values
:
:
animated
:
:
ToAnimatedValue
;
use
crate
:
:
values
:
:
animated
:
:
color
:
:
AnimatedRGBA
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToAnimatedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
enum
GenericColor
<
RGBA
Percentage
>
{
Numeric
(
RGBA
)
CurrentColor
ColorMix
(
Box
<
GenericColorMix
<
Self
Percentage
>
>
)
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
ToAnimatedValue
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ColorSpace
{
Srgb
LinearSrgb
#
[
parse
(
aliases
=
"
xyz
-
d65
"
)
]
Xyz
XyzD50
Lab
Hsl
Hwb
Lch
}
impl
ColorSpace
{
pub
fn
is_polar
(
self
)
-
>
bool
{
match
self
{
Self
:
:
Srgb
|
Self
:
:
LinearSrgb
|
Self
:
:
Xyz
|
Self
:
:
XyzD50
|
Self
:
:
Lab
=
>
false
Self
:
:
Hsl
|
Self
:
:
Hwb
|
Self
:
:
Lch
=
>
true
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
ToAnimatedValue
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
HueInterpolationMethod
{
Shorter
Longer
Increasing
Decreasing
Specified
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
ToShmem
ToAnimatedValue
ToComputedValue
ToResolvedValue
)
]
#
[
repr
(
C
)
]
pub
struct
ColorInterpolationMethod
{
pub
space
:
ColorSpace
pub
hue
:
HueInterpolationMethod
}
impl
ColorInterpolationMethod
{
pub
fn
srgb
(
)
-
>
Self
{
Self
{
space
:
ColorSpace
:
:
Srgb
hue
:
HueInterpolationMethod
:
:
Shorter
}
}
}
impl
Parse
for
ColorInterpolationMethod
{
fn
parse
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
expect_ident_matching
(
"
in
"
)
?
;
let
space
=
ColorSpace
:
:
parse
(
input
)
?
;
let
hue
=
if
space
.
is_polar
(
)
{
input
.
try_parse
(
|
input
|
-
>
Result
<
_
ParseError
<
'
i
>
>
{
let
hue
=
HueInterpolationMethod
:
:
parse
(
input
)
?
;
input
.
expect_ident_matching
(
"
hue
"
)
?
;
Ok
(
hue
)
}
)
.
unwrap_or
(
HueInterpolationMethod
:
:
Shorter
)
}
else
{
HueInterpolationMethod
:
:
Shorter
}
;
Ok
(
Self
{
space
hue
}
)
}
}
impl
ToCss
for
ColorInterpolationMethod
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
dest
.
write_str
(
"
in
"
)
?
;
self
.
space
.
to_css
(
dest
)
?
;
if
self
.
hue
!
=
HueInterpolationMethod
:
:
Shorter
{
dest
.
write_char
(
'
'
)
?
;
self
.
hue
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
hue
"
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToAnimatedValue
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
allow
(
missing_docs
)
]
#
[
repr
(
C
)
]
pub
struct
GenericColorMix
<
Color
Percentage
>
{
pub
interpolation
:
ColorInterpolationMethod
pub
left
:
Color
pub
left_percentage
:
Percentage
pub
right
:
Color
pub
right_percentage
:
Percentage
pub
normalize_weights
:
bool
}
pub
use
self
:
:
GenericColorMix
as
ColorMix
;
impl
<
Color
:
ToCss
Percentage
:
ToCss
+
ToPercentage
>
ToCss
for
ColorMix
<
Color
Percentage
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
fn
can_omit
<
Percentage
:
ToPercentage
>
(
percent
:
&
Percentage
other
:
&
Percentage
is_left
:
bool
)
-
>
bool
{
if
percent
.
is_calc
(
)
{
return
false
;
}
if
percent
.
to_percentage
(
)
=
=
0
.
5
{
return
other
.
to_percentage
(
)
=
=
0
.
5
;
}
if
is_left
{
return
false
;
}
(
1
.
0
-
percent
.
to_percentage
(
)
-
other
.
to_percentage
(
)
)
.
abs
(
)
<
=
f32
:
:
EPSILON
}
dest
.
write_str
(
"
color
-
mix
(
"
)
?
;
self
.
interpolation
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
self
.
left
.
to_css
(
dest
)
?
;
if
!
can_omit
(
&
self
.
left_percentage
&
self
.
right_percentage
true
)
{
dest
.
write_str
(
"
"
)
?
;
self
.
left_percentage
.
to_css
(
dest
)
?
;
}
dest
.
write_str
(
"
"
)
?
;
self
.
right
.
to_css
(
dest
)
?
;
if
!
can_omit
(
&
self
.
right_percentage
&
self
.
left_percentage
false
)
{
dest
.
write_str
(
"
"
)
?
;
self
.
right_percentage
.
to_css
(
dest
)
?
;
}
dest
.
write_str
(
"
)
"
)
}
}
impl
<
RGBA
Percentage
>
ColorMix
<
GenericColor
<
RGBA
Percentage
>
Percentage
>
{
fn
to_rgba
(
&
self
)
-
>
Option
<
RGBA
>
where
RGBA
:
Clone
+
ToAnimatedValue
<
AnimatedValue
=
AnimatedRGBA
>
Percentage
:
ToPercentage
{
use
crate
:
:
values
:
:
animated
:
:
color
:
:
Color
as
AnimatedColor
;
let
left
=
self
.
left
.
as_numeric
(
)
?
.
clone
(
)
.
to_animated_value
(
)
;
let
right
=
self
.
right
.
as_numeric
(
)
?
.
clone
(
)
.
to_animated_value
(
)
;
Some
(
ToAnimatedValue
:
:
from_animated_value
(
AnimatedColor
:
:
mix
(
&
self
.
interpolation
&
left
self
.
left_percentage
.
to_percentage
(
)
&
right
self
.
right_percentage
.
to_percentage
(
)
self
.
normalize_weights
)
)
)
}
}
pub
use
self
:
:
GenericColor
as
Color
;
impl
<
RGBA
Percentage
>
Color
<
RGBA
Percentage
>
{
pub
fn
as_numeric
(
&
self
)
-
>
Option
<
&
RGBA
>
{
match
*
self
{
Self
:
:
Numeric
(
ref
rgba
)
=
>
Some
(
rgba
)
_
=
>
None
}
}
pub
fn
simplify
(
&
mut
self
current_color
:
Option
<
&
RGBA
>
)
where
RGBA
:
Clone
+
ToAnimatedValue
<
AnimatedValue
=
AnimatedRGBA
>
Percentage
:
ToPercentage
{
match
*
self
{
Self
:
:
Numeric
(
.
.
)
=
>
{
}
Self
:
:
CurrentColor
=
>
{
if
let
Some
(
c
)
=
current_color
{
*
self
=
Self
:
:
Numeric
(
c
.
clone
(
)
)
;
}
}
Self
:
:
ColorMix
(
ref
mut
mix
)
=
>
{
mix
.
left
.
simplify
(
current_color
)
;
mix
.
right
.
simplify
(
current_color
)
;
if
let
Some
(
mix
)
=
mix
.
to_rgba
(
)
{
*
self
=
Self
:
:
Numeric
(
mix
)
;
}
}
}
}
pub
fn
currentcolor
(
)
-
>
Self
{
Self
:
:
CurrentColor
}
pub
fn
rgba
(
color
:
RGBA
)
-
>
Self
{
Self
:
:
Numeric
(
color
)
}
pub
fn
is_currentcolor
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Self
:
:
CurrentColor
)
}
pub
fn
is_numeric
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Self
:
:
Numeric
(
.
.
)
)
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
Parse
SpecifiedValueInfo
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToResolvedValue
ToCss
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericColorOrAuto
<
C
>
{
Color
(
C
)
Auto
}
pub
use
self
:
:
GenericColorOrAuto
as
ColorOrAuto
;
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToCss
ToShmem
)
]
#
[
repr
(
transparent
)
]
pub
struct
GenericCaretColor
<
C
>
(
pub
GenericColorOrAuto
<
C
>
)
;
impl
<
C
>
GenericCaretColor
<
C
>
{
pub
fn
auto
(
)
-
>
Self
{
GenericCaretColor
(
GenericColorOrAuto
:
:
Auto
)
}
}
pub
use
self
:
:
GenericCaretColor
as
CaretColor
;
