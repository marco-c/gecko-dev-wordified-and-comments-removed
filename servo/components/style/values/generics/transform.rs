use
std
:
:
fmt
;
use
style_traits
:
:
{
HasViewportPercentage
ToCss
}
;
use
values
:
:
CSSFloat
;
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
HasViewportPercentage
PartialEq
ToComputedValue
ToCss
)
]
#
[
css
(
comma
function
)
]
pub
struct
Matrix
<
T
U
=
T
>
{
pub
a
:
T
pub
b
:
T
pub
c
:
T
pub
d
:
T
pub
e
:
U
pub
f
:
U
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
ComputeSquaredDistance
Copy
Debug
HasViewportPercentage
PartialEq
ToComputedValue
ToCss
)
]
pub
struct
TransformOrigin
<
H
V
Depth
>
{
pub
horizontal
:
H
pub
vertical
:
V
pub
depth
:
Depth
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
TimingFunction
<
Integer
Number
>
{
Keyword
(
TimingKeyword
)
#
[
allow
(
missing_docs
)
]
CubicBezier
{
x1
:
Number
y1
:
Number
x2
:
Number
y2
:
Number
}
Steps
(
Integer
StepPosition
)
Frames
(
Integer
)
}
define_css_keyword_enum
!
{
TimingKeyword
:
"
linear
"
=
>
Linear
"
ease
"
=
>
Ease
"
ease
-
in
"
=
>
EaseIn
"
ease
-
out
"
=
>
EaseOut
"
ease
-
in
-
out
"
=
>
EaseInOut
}
add_impls_for_keyword_enum
!
(
TimingKeyword
)
;
define_css_keyword_enum
!
{
StepPosition
:
"
start
"
=
>
Start
"
end
"
=
>
End
}
add_impls_for_keyword_enum
!
(
StepPosition
)
;
impl
<
H
V
D
>
TransformOrigin
<
H
V
D
>
{
pub
fn
new
(
horizontal
:
H
vertical
:
V
depth
:
D
)
-
>
Self
{
Self
{
horizontal
:
horizontal
vertical
:
vertical
depth
:
depth
}
}
}
impl
<
I
N
>
HasViewportPercentage
for
TimingFunction
<
I
N
>
{
fn
has_viewport_percentage
(
&
self
)
-
>
bool
{
false
}
}
impl
<
Integer
Number
>
TimingFunction
<
Integer
Number
>
{
#
[
inline
]
pub
fn
ease
(
)
-
>
Self
{
TimingFunction
:
:
Keyword
(
TimingKeyword
:
:
Ease
)
}
}
impl
<
Integer
Number
>
ToCss
for
TimingFunction
<
Integer
Number
>
where
Integer
:
ToCss
Number
:
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
TimingFunction
:
:
Keyword
(
keyword
)
=
>
keyword
.
to_css
(
dest
)
TimingFunction
:
:
CubicBezier
{
ref
x1
ref
y1
ref
x2
ref
y2
}
=
>
{
dest
.
write_str
(
"
cubic
-
bezier
(
"
)
?
;
x1
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
y1
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
x2
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
y2
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
TimingFunction
:
:
Steps
(
ref
intervals
position
)
=
>
{
dest
.
write_str
(
"
steps
(
"
)
?
;
intervals
.
to_css
(
dest
)
?
;
if
position
!
=
StepPosition
:
:
End
{
dest
.
write_str
(
"
"
)
?
;
position
.
to_css
(
dest
)
?
;
}
dest
.
write_str
(
"
)
"
)
}
TimingFunction
:
:
Frames
(
ref
frames
)
=
>
{
dest
.
write_str
(
"
frames
(
"
)
?
;
frames
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
}
}
}
impl
TimingKeyword
{
#
[
inline
]
pub
fn
to_bezier
(
self
)
-
>
(
CSSFloat
CSSFloat
CSSFloat
CSSFloat
)
{
match
self
{
TimingKeyword
:
:
Linear
=
>
(
0
.
0
.
1
.
1
.
)
TimingKeyword
:
:
Ease
=
>
(
0
.
25
0
.
1
0
.
25
1
.
)
TimingKeyword
:
:
EaseIn
=
>
(
0
.
42
0
.
1
.
1
.
)
TimingKeyword
:
:
EaseOut
=
>
(
0
.
0
.
0
.
58
1
.
)
TimingKeyword
:
:
EaseInOut
=
>
(
0
.
42
0
.
0
.
58
1
.
)
}
}
}
