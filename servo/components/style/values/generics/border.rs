use
euclid
:
:
Size2D
;
use
std
:
:
fmt
;
use
style_traits
:
:
ToCss
;
use
values
:
:
generics
:
:
rect
:
:
Rect
;
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
HasViewportPercentage
PartialEq
ToComputedValue
)
]
pub
enum
BorderImageSideWidth
<
LengthOrPercentage
Number
>
{
Length
(
LengthOrPercentage
)
Number
(
Number
)
Auto
}
#
[
derive
(
Clone
Copy
Debug
HasViewportPercentage
PartialEq
ToComputedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
BorderImageSlice
<
NumberOrPercentage
>
{
pub
offsets
:
Rect
<
NumberOrPercentage
>
pub
fill
:
bool
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
HasViewportPercentage
PartialEq
ToComputedValue
)
]
pub
struct
BorderRadius
<
LengthOrPercentage
>
{
pub
top_left
:
BorderCornerRadius
<
LengthOrPercentage
>
pub
top_right
:
BorderCornerRadius
<
LengthOrPercentage
>
pub
bottom_right
:
BorderCornerRadius
<
LengthOrPercentage
>
pub
bottom_left
:
BorderCornerRadius
<
LengthOrPercentage
>
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
HasViewportPercentage
PartialEq
ToComputedValue
)
]
pub
struct
BorderCornerRadius
<
L
>
(
pub
Size2D
<
L
>
)
;
impl
<
L
N
>
ToCss
for
BorderImageSideWidth
<
L
N
>
where
L
:
ToCss
N
:
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
BorderImageSideWidth
:
:
Length
(
ref
length
)
=
>
length
.
to_css
(
dest
)
BorderImageSideWidth
:
:
Number
(
ref
number
)
=
>
number
.
to_css
(
dest
)
BorderImageSideWidth
:
:
Auto
=
>
dest
.
write_str
(
"
auto
"
)
}
}
}
impl
<
N
>
From
<
N
>
for
BorderImageSlice
<
N
>
where
N
:
Clone
{
#
[
inline
]
fn
from
(
value
:
N
)
-
>
Self
{
Self
{
offsets
:
value
.
into
(
)
fill
:
false
}
}
}
impl
<
N
>
ToCss
for
BorderImageSlice
<
N
>
where
N
:
PartialEq
+
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
self
.
offsets
.
to_css
(
dest
)
?
;
if
self
.
fill
{
dest
.
write_str
(
"
fill
"
)
?
;
}
Ok
(
(
)
)
}
}
impl
<
L
>
BorderRadius
<
L
>
{
#
[
inline
]
pub
fn
new
(
tl
:
BorderCornerRadius
<
L
>
tr
:
BorderCornerRadius
<
L
>
br
:
BorderCornerRadius
<
L
>
bl
:
BorderCornerRadius
<
L
>
)
-
>
Self
{
BorderRadius
{
top_left
:
tl
top_right
:
tr
bottom_right
:
br
bottom_left
:
bl
}
}
}
impl
<
L
>
BorderRadius
<
L
>
where
L
:
PartialEq
+
ToCss
{
pub
fn
serialize_rects
<
W
>
(
widths
:
Rect
<
&
L
>
heights
:
Rect
<
&
L
>
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
widths
.
to_css
(
dest
)
?
;
if
widths
.
0
!
=
heights
.
0
|
|
widths
.
1
!
=
heights
.
1
|
|
widths
.
2
!
=
heights
.
2
|
|
widths
.
3
!
=
heights
.
3
{
dest
.
write_str
(
"
/
"
)
?
;
heights
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
impl
<
L
>
ToCss
for
BorderRadius
<
L
>
where
L
:
PartialEq
+
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
let
BorderRadius
{
top_left
:
ref
tl
top_right
:
ref
tr
bottom_right
:
ref
br
bottom_left
:
ref
bl
}
=
*
self
;
let
widths
=
Rect
:
:
new
(
&
tl
.
0
.
width
&
tr
.
0
.
width
&
br
.
0
.
width
&
bl
.
0
.
width
)
;
let
heights
=
Rect
:
:
new
(
&
tl
.
0
.
height
&
tr
.
0
.
height
&
br
.
0
.
height
&
bl
.
0
.
height
)
;
Self
:
:
serialize_rects
(
widths
heights
dest
)
}
}
impl
<
L
>
BorderCornerRadius
<
L
>
{
#
[
inline
]
pub
fn
new
(
width
:
L
height
:
L
)
-
>
BorderCornerRadius
<
L
>
{
BorderCornerRadius
(
Size2D
:
:
new
(
width
height
)
)
}
}
impl
<
L
:
Clone
>
From
<
L
>
for
BorderCornerRadius
<
L
>
{
fn
from
(
radius
:
L
)
-
>
Self
{
Self
:
:
new
(
radius
.
clone
(
)
radius
)
}
}
impl
<
L
>
ToCss
for
BorderCornerRadius
<
L
>
where
L
:
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
self
.
0
.
width
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
self
.
0
.
height
.
to_css
(
dest
)
}
}
