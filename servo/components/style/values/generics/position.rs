use
std
:
:
fmt
:
:
Write
;
use
style_traits
:
:
CssWriter
;
use
style_traits
:
:
SpecifiedValueInfo
;
use
style_traits
:
:
ToCss
;
use
crate
:
:
logical_geometry
:
:
PhysicalSide
;
use
crate
:
:
values
:
:
animated
:
:
ToAnimatedZero
;
use
crate
:
:
values
:
:
generics
:
:
box_
:
:
PositionProperty
;
use
crate
:
:
values
:
:
generics
:
:
length
:
:
GenericAnchorSizeFunction
;
use
crate
:
:
values
:
:
generics
:
:
ratio
:
:
Ratio
;
use
crate
:
:
values
:
:
generics
:
:
Optional
;
use
crate
:
:
values
:
:
DashedIdent
;
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
Deserialize
MallocSizeOf
PartialEq
Serialize
SpecifiedValueInfo
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
GenericPosition
<
H
V
>
{
pub
horizontal
:
H
pub
vertical
:
V
}
impl
<
H
V
>
PositionComponent
for
Position
<
H
V
>
where
H
:
PositionComponent
V
:
PositionComponent
{
#
[
inline
]
fn
is_center
(
&
self
)
-
>
bool
{
self
.
horizontal
.
is_center
(
)
&
&
self
.
vertical
.
is_center
(
)
}
}
pub
use
self
:
:
GenericPosition
as
Position
;
impl
<
H
V
>
Position
<
H
V
>
{
pub
fn
new
(
horizontal
:
H
vertical
:
V
)
-
>
Self
{
Self
{
horizontal
vertical
}
}
}
pub
trait
PositionComponent
{
fn
is_center
(
&
self
)
-
>
bool
;
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
Deserialize
MallocSizeOf
Parse
PartialEq
Serialize
SpecifiedValueInfo
ToAnimatedZero
ToAnimatedValue
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericPositionOrAuto
<
Pos
>
{
Position
(
Pos
)
Auto
}
pub
use
self
:
:
GenericPositionOrAuto
as
PositionOrAuto
;
impl
<
Pos
>
PositionOrAuto
<
Pos
>
{
#
[
inline
]
pub
fn
auto
(
)
-
>
Self
{
PositionOrAuto
:
:
Auto
}
#
[
inline
]
pub
fn
is_auto
(
&
self
)
-
>
bool
{
matches
!
(
self
PositionOrAuto
:
:
Auto
)
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
Parse
SpecifiedValueInfo
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericZIndex
<
I
>
{
Integer
(
I
)
Auto
}
pub
use
self
:
:
GenericZIndex
as
ZIndex
;
impl
<
Integer
>
ZIndex
<
Integer
>
{
#
[
inline
]
pub
fn
auto
(
)
-
>
Self
{
ZIndex
:
:
Auto
}
#
[
inline
]
pub
fn
is_auto
(
self
)
-
>
bool
{
matches
!
(
self
ZIndex
:
:
Auto
)
}
#
[
inline
]
pub
fn
integer_or
(
self
auto
:
Integer
)
-
>
Integer
{
match
self
{
ZIndex
:
:
Integer
(
n
)
=
>
n
ZIndex
:
:
Auto
=
>
auto
}
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToAnimatedValue
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
PreferredRatio
<
N
>
{
#
[
css
(
skip
)
]
None
Ratio
(
#
[
animation
(
field_bound
)
]
#
[
css
(
field_bound
)
]
#
[
distance
(
field_bound
)
]
Ratio
<
N
>
)
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToAnimatedValue
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
GenericAspectRatio
<
N
>
{
#
[
animation
(
constant
)
]
#
[
css
(
represents_keyword
)
]
pub
auto
:
bool
#
[
animation
(
field_bound
)
]
#
[
css
(
field_bound
)
]
#
[
distance
(
field_bound
)
]
pub
ratio
:
PreferredRatio
<
N
>
}
pub
use
self
:
:
GenericAspectRatio
as
AspectRatio
;
impl
<
N
>
AspectRatio
<
N
>
{
#
[
inline
]
pub
fn
auto
(
)
-
>
Self
{
AspectRatio
{
auto
:
true
ratio
:
PreferredRatio
:
:
None
}
}
}
impl
<
N
>
ToAnimatedZero
for
AspectRatio
<
N
>
{
#
[
inline
]
fn
to_animated_zero
(
&
self
)
-
>
Result
<
Self
(
)
>
{
Err
(
(
)
)
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Debug
MallocSizeOf
PartialEq
ToCss
ToShmem
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToResolvedValue
)
]
#
[
repr
(
C
)
]
pub
enum
GenericInset
<
P
LP
>
{
LengthPercentage
(
LP
)
Auto
AnchorFunction
(
Box
<
GenericAnchorFunction
<
P
Self
>
>
)
AnchorSizeFunction
(
#
[
animation
(
field_bound
)
]
#
[
distance
(
field_bound
)
]
Box
<
GenericAnchorSizeFunction
<
LP
>
>
)
AnchorContainingCalcFunction
(
LP
)
}
impl
<
P
LP
>
SpecifiedValueInfo
for
GenericInset
<
P
LP
>
where
LP
:
SpecifiedValueInfo
{
fn
collect_completion_keywords
(
f
:
style_traits
:
:
KeywordsCollectFn
)
{
LP
:
:
collect_completion_keywords
(
f
)
;
f
(
&
[
"
auto
"
]
)
;
if
static_prefs
:
:
pref
!
(
"
layout
.
css
.
anchor
-
positioning
.
enabled
"
)
{
f
(
&
[
"
anchor
"
"
anchor
-
size
"
]
)
;
}
}
}
impl
<
P
LP
>
GenericInset
<
P
LP
>
{
#
[
inline
]
pub
fn
auto
(
)
-
>
Self
{
Self
:
:
Auto
}
#
[
inline
]
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
is_auto
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Auto
)
}
}
pub
use
self
:
:
GenericInset
as
Inset
;
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToShmem
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToResolvedValue
Serialize
Deserialize
)
]
#
[
repr
(
C
)
]
pub
struct
GenericAnchorFunction
<
Percentage
Fallback
>
{
#
[
animation
(
constant
)
]
pub
target_element
:
DashedIdent
pub
side
:
GenericAnchorSide
<
Percentage
>
pub
fallback
:
Optional
<
Fallback
>
}
impl
<
Percentage
Fallback
>
ToCss
for
GenericAnchorFunction
<
Percentage
Fallback
>
where
Percentage
:
ToCss
Fallback
:
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
std
:
:
fmt
:
:
Result
where
W
:
Write
{
dest
.
write_str
(
"
anchor
(
"
)
?
;
if
!
self
.
target_element
.
is_empty
(
)
{
self
.
target_element
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
}
self
.
side
.
to_css
(
dest
)
?
;
if
let
Some
(
f
)
=
self
.
fallback
.
as_ref
(
)
{
dest
.
write_str
(
"
"
)
?
;
f
.
to_css
(
dest
)
?
;
}
dest
.
write_str
(
"
)
"
)
}
}
impl
<
Percentage
Fallback
>
GenericAnchorFunction
<
Percentage
Fallback
>
{
pub
fn
valid_for
(
&
self
side
:
PhysicalSide
position_property
:
PositionProperty
)
-
>
bool
{
position_property
.
is_absolutely_positioned
(
)
&
&
self
.
side
.
valid_for
(
side
)
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToCss
ToShmem
Parse
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToResolvedValue
Serialize
Deserialize
)
]
#
[
repr
(
u8
)
]
pub
enum
AnchorSideKeyword
{
Inside
Outside
Top
Left
Right
Bottom
Start
End
SelfStart
SelfEnd
Center
}
impl
AnchorSideKeyword
{
fn
valid_for
(
&
self
side
:
PhysicalSide
)
-
>
bool
{
match
self
{
Self
:
:
Left
|
Self
:
:
Right
=
>
matches
!
(
side
PhysicalSide
:
:
Left
|
PhysicalSide
:
:
Right
)
Self
:
:
Top
|
Self
:
:
Bottom
=
>
matches
!
(
side
PhysicalSide
:
:
Top
|
PhysicalSide
:
:
Bottom
)
Self
:
:
Inside
|
Self
:
:
Outside
|
Self
:
:
Start
|
Self
:
:
End
|
Self
:
:
SelfStart
|
Self
:
:
SelfEnd
|
Self
:
:
Center
=
>
true
}
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
Parse
SpecifiedValueInfo
ToCss
ToShmem
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToResolvedValue
Serialize
Deserialize
)
]
#
[
repr
(
C
)
]
pub
enum
GenericAnchorSide
<
P
>
{
Keyword
(
AnchorSideKeyword
)
Percentage
(
P
)
}
impl
<
P
>
GenericAnchorSide
<
P
>
{
pub
fn
valid_for
(
&
self
side
:
PhysicalSide
)
-
>
bool
{
match
self
{
Self
:
:
Keyword
(
k
)
=
>
k
.
valid_for
(
side
)
Self
:
:
Percentage
(
_
)
=
>
true
}
}
}
