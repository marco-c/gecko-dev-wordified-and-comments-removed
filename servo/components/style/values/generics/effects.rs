use
std
:
:
fmt
;
use
style_traits
:
:
values
:
:
{
SequenceWriter
ToCss
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
values
:
:
specified
:
:
url
:
:
SpecifiedUrl
;
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Animate
Clone
Debug
PartialEq
)
]
#
[
derive
(
ToAnimatedValue
ToAnimatedZero
)
]
pub
struct
BoxShadow
<
Color
SizeLength
BlurShapeLength
ShapeLength
>
{
pub
base
:
SimpleShadow
<
Color
SizeLength
BlurShapeLength
>
pub
spread
:
ShapeLength
#
[
animation
(
constant
)
]
pub
inset
:
bool
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
HeapSizeOf
Serialize
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
ToAnimatedValue
ToComputedValue
ToCss
)
]
pub
enum
Filter
<
Angle
Factor
Length
DropShadow
>
{
#
[
css
(
function
)
]
Blur
(
Length
)
#
[
css
(
function
)
]
Brightness
(
Factor
)
#
[
css
(
function
)
]
Contrast
(
Factor
)
#
[
css
(
function
)
]
Grayscale
(
Factor
)
#
[
css
(
function
)
]
HueRotate
(
Angle
)
#
[
css
(
function
)
]
Invert
(
Factor
)
#
[
css
(
function
)
]
Opacity
(
Factor
)
#
[
css
(
function
)
]
Saturate
(
Factor
)
#
[
css
(
function
)
]
Sepia
(
Factor
)
#
[
css
(
function
)
]
DropShadow
(
DropShadow
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
Url
(
SpecifiedUrl
)
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Debug
)
]
#
[
derive
(
PartialEq
ToAnimatedValue
ToAnimatedZero
ToCss
)
]
pub
struct
SimpleShadow
<
Color
SizeLength
ShapeLength
>
{
pub
color
:
Color
pub
horizontal
:
SizeLength
pub
vertical
:
SizeLength
pub
blur
:
ShapeLength
}
impl
<
Color
SizeLength
BlurShapeLength
ShapeLength
>
ToCss
for
BoxShadow
<
Color
SizeLength
BlurShapeLength
ShapeLength
>
where
Color
:
ToCss
SizeLength
:
ToCss
BlurShapeLength
:
ToCss
ShapeLength
:
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
{
let
mut
writer
=
SequenceWriter
:
:
new
(
&
mut
*
dest
"
"
)
;
writer
.
item
(
&
self
.
base
)
?
;
writer
.
item
(
&
self
.
spread
)
?
;
}
if
self
.
inset
{
dest
.
write_str
(
"
inset
"
)
?
;
}
Ok
(
(
)
)
}
}
