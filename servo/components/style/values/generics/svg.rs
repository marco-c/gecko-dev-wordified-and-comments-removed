use
cssparser
:
:
Parser
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
std
:
:
fmt
;
use
style_traits
:
:
{
ParseError
StyleParseErrorKind
ToCss
}
;
use
values
:
:
{
Either
None_
}
;
use
values
:
:
computed
:
:
NumberOrPercentage
;
use
values
:
:
computed
:
:
length
:
:
LengthOrPercentage
;
use
values
:
:
distance
:
:
{
ComputeSquaredDistance
SquaredDistance
}
;
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Debug
PartialEq
)
]
#
[
derive
(
ToAnimatedValue
ToComputedValue
ToCss
)
]
pub
struct
SVGPaint
<
ColorType
UrlPaintServer
>
{
pub
kind
:
SVGPaintKind
<
ColorType
UrlPaintServer
>
pub
fallback
:
Option
<
Either
<
ColorType
None_
>
>
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Debug
PartialEq
)
]
#
[
derive
(
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToCss
)
]
pub
enum
SVGPaintKind
<
ColorType
UrlPaintServer
>
{
#
[
animation
(
error
)
]
None
Color
(
ColorType
)
#
[
animation
(
error
)
]
PaintServer
(
UrlPaintServer
)
ContextFill
ContextStroke
}
impl
<
ColorType
UrlPaintServer
>
SVGPaintKind
<
ColorType
UrlPaintServer
>
{
fn
parse_ident
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
try_match_ident_ignore_ascii_case
!
{
input
"
none
"
=
>
Ok
(
SVGPaintKind
:
:
None
)
"
context
-
fill
"
=
>
Ok
(
SVGPaintKind
:
:
ContextFill
)
"
context
-
stroke
"
=
>
Ok
(
SVGPaintKind
:
:
ContextStroke
)
}
}
}
fn
parse_fallback
<
'
i
'
t
ColorType
:
Parse
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Option
<
Either
<
ColorType
None_
>
>
{
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
none
"
)
)
.
is_ok
(
)
{
Some
(
Either
:
:
Second
(
None_
)
)
}
else
{
if
let
Ok
(
color
)
=
input
.
try
(
|
i
|
ColorType
:
:
parse
(
context
i
)
)
{
Some
(
Either
:
:
First
(
color
)
)
}
else
{
None
}
}
}
impl
<
ColorType
:
Parse
UrlPaintServer
:
Parse
>
Parse
for
SVGPaint
<
ColorType
UrlPaintServer
>
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
url
)
=
input
.
try
(
|
i
|
UrlPaintServer
:
:
parse
(
context
i
)
)
{
Ok
(
SVGPaint
{
kind
:
SVGPaintKind
:
:
PaintServer
(
url
)
fallback
:
parse_fallback
(
context
input
)
}
)
}
else
if
let
Ok
(
kind
)
=
input
.
try
(
SVGPaintKind
:
:
parse_ident
)
{
if
let
SVGPaintKind
:
:
None
=
kind
{
Ok
(
SVGPaint
{
kind
:
kind
fallback
:
None
}
)
}
else
{
Ok
(
SVGPaint
{
kind
:
kind
fallback
:
parse_fallback
(
context
input
)
}
)
}
}
else
if
let
Ok
(
color
)
=
input
.
try
(
|
i
|
ColorType
:
:
parse
(
context
i
)
)
{
Ok
(
SVGPaint
{
kind
:
SVGPaintKind
:
:
Color
(
color
)
fallback
:
None
}
)
}
else
{
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
ToAnimatedValue
)
]
#
[
derive
(
ToAnimatedZero
ToComputedValue
ToCss
)
]
pub
enum
SvgLengthOrPercentageOrNumber
<
LengthOrPercentage
Number
>
{
LengthOrPercentage
(
LengthOrPercentage
)
Number
(
Number
)
}
impl
<
L
N
>
ComputeSquaredDistance
for
SvgLengthOrPercentageOrNumber
<
L
N
>
where
L
:
ComputeSquaredDistance
+
Copy
+
Into
<
NumberOrPercentage
>
N
:
ComputeSquaredDistance
+
Copy
+
Into
<
NumberOrPercentage
>
{
#
[
inline
]
fn
compute_squared_distance
(
&
self
other
:
&
Self
)
-
>
Result
<
SquaredDistance
(
)
>
{
match
(
self
other
)
{
(
&
SvgLengthOrPercentageOrNumber
:
:
LengthOrPercentage
(
ref
from
)
&
SvgLengthOrPercentageOrNumber
:
:
LengthOrPercentage
(
ref
to
)
)
=
>
{
from
.
compute_squared_distance
(
to
)
}
(
&
SvgLengthOrPercentageOrNumber
:
:
Number
(
ref
from
)
&
SvgLengthOrPercentageOrNumber
:
:
Number
(
ref
to
)
)
=
>
{
from
.
compute_squared_distance
(
to
)
}
(
&
SvgLengthOrPercentageOrNumber
:
:
LengthOrPercentage
(
from
)
&
SvgLengthOrPercentageOrNumber
:
:
Number
(
to
)
)
=
>
{
from
.
into
(
)
.
compute_squared_distance
(
&
to
.
into
(
)
)
}
(
&
SvgLengthOrPercentageOrNumber
:
:
Number
(
from
)
&
SvgLengthOrPercentageOrNumber
:
:
LengthOrPercentage
(
to
)
)
=
>
{
from
.
into
(
)
.
compute_squared_distance
(
&
to
.
into
(
)
)
}
}
}
}
impl
<
LengthOrPercentageType
NumberType
>
SvgLengthOrPercentageOrNumber
<
LengthOrPercentageType
NumberType
>
where
LengthOrPercentage
:
From
<
LengthOrPercentageType
>
LengthOrPercentageType
:
Copy
{
pub
fn
has_calc
(
&
self
)
-
>
bool
{
match
self
{
&
SvgLengthOrPercentageOrNumber
:
:
LengthOrPercentage
(
lop
)
=
>
{
match
LengthOrPercentage
:
:
from
(
lop
)
{
LengthOrPercentage
:
:
Calc
(
_
)
=
>
true
_
=
>
false
}
}
_
=
>
false
}
}
}
impl
<
LengthOrPercentageType
:
Parse
NumberType
:
Parse
>
Parse
for
SvgLengthOrPercentageOrNumber
<
LengthOrPercentageType
NumberType
>
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
num
)
=
input
.
try
(
|
i
|
NumberType
:
:
parse
(
context
i
)
)
{
return
Ok
(
SvgLengthOrPercentageOrNumber
:
:
Number
(
num
)
)
;
}
if
let
Ok
(
lop
)
=
input
.
try
(
|
i
|
LengthOrPercentageType
:
:
parse
(
context
i
)
)
{
return
Ok
(
SvgLengthOrPercentageOrNumber
:
:
LengthOrPercentage
(
lop
)
)
;
}
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
ComputeSquaredDistance
Copy
Debug
PartialEq
)
]
#
[
derive
(
ToAnimatedValue
ToAnimatedZero
)
]
#
[
derive
(
ToComputedValue
ToCss
)
]
pub
enum
SVGLength
<
LengthType
>
{
Length
(
LengthType
)
ContextValue
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
ComputeSquaredDistance
Debug
PartialEq
ToAnimatedValue
ToComputedValue
)
]
pub
enum
SVGStrokeDashArray
<
LengthType
>
{
Values
(
Vec
<
LengthType
>
)
ContextValue
}
impl
<
LengthType
>
ToCss
for
SVGStrokeDashArray
<
LengthType
>
where
LengthType
:
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
self
{
&
SVGStrokeDashArray
:
:
Values
(
ref
values
)
=
>
{
let
mut
iter
=
values
.
iter
(
)
;
if
let
Some
(
first
)
=
iter
.
next
(
)
{
first
.
to_css
(
dest
)
?
;
for
item
in
iter
{
dest
.
write_str
(
"
"
)
?
;
item
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
else
{
dest
.
write_str
(
"
none
"
)
}
}
&
SVGStrokeDashArray
:
:
ContextValue
=
>
{
dest
.
write_str
(
"
context
-
value
"
)
}
}
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
ComputeSquaredDistance
Copy
Debug
)
]
#
[
derive
(
PartialEq
ToAnimatedZero
ToComputedValue
ToCss
)
]
pub
enum
SVGOpacity
<
OpacityType
>
{
Opacity
(
OpacityType
)
ContextFillOpacity
ContextStrokeOpacity
}
