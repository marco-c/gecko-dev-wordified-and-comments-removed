use
app_units
:
:
Au
;
use
byteorder
:
:
{
ReadBytesExt
BigEndian
}
;
use
cssparser
:
:
Parser
;
use
num_traits
:
:
One
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
io
:
:
Cursor
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
use
values
:
:
distance
:
:
{
ComputeSquaredDistance
SquaredDistance
}
;
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
ToComputedValue
)
]
pub
struct
FeatureTagValue
<
Integer
>
{
pub
tag
:
FontTag
pub
value
:
Integer
}
impl
<
Integer
>
ToCss
for
FeatureTagValue
<
Integer
>
where
Integer
:
One
+
ToCss
+
PartialEq
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
tag
.
to_css
(
dest
)
?
;
if
self
.
value
!
=
Integer
:
:
one
(
)
{
dest
.
write_char
(
'
'
)
?
;
self
.
value
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Animate
Clone
Debug
Eq
MallocSizeOf
PartialEq
ToComputedValue
ToCss
)
]
pub
struct
VariationValue
<
Number
>
{
#
[
animation
(
constant
)
]
pub
tag
:
FontTag
pub
value
:
Number
}
impl
<
Number
>
ComputeSquaredDistance
for
VariationValue
<
Number
>
where
Number
:
ComputeSquaredDistance
{
#
[
inline
]
fn
compute_squared_distance
(
&
self
other
:
&
Self
)
-
>
Result
<
SquaredDistance
(
)
>
{
if
self
.
tag
!
=
other
.
tag
{
return
Err
(
(
)
)
;
}
self
.
value
.
compute_squared_distance
(
&
other
.
value
)
}
}
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
ToComputedValue
)
]
pub
struct
FontSettings
<
T
>
(
pub
Box
<
[
T
]
>
)
;
impl
<
T
>
FontSettings
<
T
>
{
#
[
inline
]
pub
fn
normal
(
)
-
>
Self
{
FontSettings
(
vec
!
[
]
.
into_boxed_slice
(
)
)
}
}
impl
<
T
:
Parse
>
Parse
for
FontSettings
<
T
>
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
normal
"
)
)
.
is_ok
(
)
{
return
Ok
(
Self
:
:
normal
(
)
)
;
}
Ok
(
FontSettings
(
input
.
parse_comma_separated
(
|
i
|
T
:
:
parse
(
context
i
)
)
?
.
into_boxed_slice
(
)
)
)
}
}
impl
<
T
:
ToCss
>
ToCss
for
FontSettings
<
T
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
self
.
0
.
is_empty
(
)
{
return
dest
.
write_str
(
"
normal
"
)
;
}
let
mut
first
=
true
;
for
item
in
self
.
0
.
iter
(
)
{
if
!
first
{
dest
.
write_str
(
"
"
)
?
;
}
first
=
false
;
item
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
ToComputedValue
)
]
pub
struct
FontTag
(
pub
u32
)
;
impl
ToCss
for
FontTag
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
use
byteorder
:
:
{
BigEndian
ByteOrder
}
;
use
std
:
:
str
;
let
mut
raw
=
[
0u8
;
4
]
;
BigEndian
:
:
write_u32
(
&
mut
raw
self
.
0
)
;
str
:
:
from_utf8
(
&
raw
)
.
unwrap_or_default
(
)
.
to_css
(
dest
)
}
}
impl
Parse
for
FontTag
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
tag
=
input
.
expect_string
(
)
?
;
if
tag
.
len
(
)
!
=
4
|
|
tag
.
as_bytes
(
)
.
iter
(
)
.
any
(
|
c
|
*
c
<
b
'
'
|
|
*
c
>
b
'
~
'
)
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
let
mut
raw
=
Cursor
:
:
new
(
tag
.
as_bytes
(
)
)
;
Ok
(
FontTag
(
raw
.
read_u32
:
:
<
BigEndian
>
(
)
.
unwrap
(
)
)
)
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
)
]
#
[
derive
(
PartialEq
ToAnimatedValue
ToAnimatedZero
ToCss
)
]
pub
struct
KeywordInfo
<
Length
>
{
pub
kw
:
KeywordSize
#
[
css
(
skip
)
]
pub
factor
:
f32
#
[
css
(
skip
)
]
pub
offset
:
Length
}
impl
<
L
>
KeywordInfo
<
L
>
where
Au
:
Into
<
L
>
{
pub
fn
medium
(
)
-
>
Self
{
KeywordSize
:
:
Medium
.
into
(
)
}
}
impl
<
L
>
From
<
KeywordSize
>
for
KeywordInfo
<
L
>
where
Au
:
Into
<
L
>
{
fn
from
(
x
:
KeywordSize
)
-
>
Self
{
KeywordInfo
{
kw
:
x
factor
:
1
.
offset
:
Au
(
0
)
.
into
(
)
}
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
)
]
#
[
derive
(
PartialEq
ToAnimatedValue
ToAnimatedZero
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
KeywordSize
{
XXSmall
XSmall
Small
Medium
Large
XLarge
XXLarge
XXXLarge
}
impl
KeywordSize
{
#
[
inline
]
pub
fn
html_size
(
self
)
-
>
u8
{
self
as
u8
}
}
impl
Default
for
KeywordSize
{
fn
default
(
)
-
>
Self
{
KeywordSize
:
:
Medium
}
}
impl
ToCss
for
KeywordSize
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
dest
.
write_str
(
match
*
self
{
KeywordSize
:
:
XXSmall
=
>
"
xx
-
small
"
KeywordSize
:
:
XSmall
=
>
"
x
-
small
"
KeywordSize
:
:
Small
=
>
"
small
"
KeywordSize
:
:
Medium
=
>
"
medium
"
KeywordSize
:
:
Large
=
>
"
large
"
KeywordSize
:
:
XLarge
=
>
"
x
-
large
"
KeywordSize
:
:
XXLarge
=
>
"
xx
-
large
"
KeywordSize
:
:
XXXLarge
=
>
{
debug_assert
!
(
false
"
We
should
never
serialize
specified
values
set
via
HTML
presentation
attributes
"
)
;
"
-
servo
-
xxx
-
large
"
}
}
)
}
}
