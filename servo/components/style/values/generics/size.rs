use
crate
:
:
parser
:
:
ParserContext
;
use
crate
:
:
Zero
;
use
cssparser
:
:
Parser
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ParseError
ToCss
}
;
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
Deserialize
MallocSizeOf
PartialEq
SpecifiedValueInfo
Serialize
ToAnimatedZero
ToAnimatedValue
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
allow
(
missing_docs
)
]
#
[
repr
(
C
)
]
pub
struct
Size2D
<
L
>
{
pub
width
:
L
pub
height
:
L
}
impl
<
L
>
Size2D
<
L
>
{
#
[
inline
]
pub
fn
new
(
width
:
L
height
:
L
)
-
>
Self
{
Self
{
width
height
}
}
pub
fn
width
(
&
self
)
-
>
&
L
{
&
self
.
width
}
pub
fn
height
(
&
self
)
-
>
&
L
{
&
self
.
height
}
pub
fn
parse_with
<
'
i
'
t
F
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
parse_one
:
F
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
where
L
:
Clone
F
:
Fn
(
&
ParserContext
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
L
ParseError
<
'
i
>
>
{
let
first
=
parse_one
(
context
input
)
?
;
let
second
=
input
.
try_parse
(
|
i
|
parse_one
(
context
i
)
)
.
unwrap_or_else
(
|
_
|
first
.
clone
(
)
)
;
Ok
(
Self
:
:
new
(
first
second
)
)
}
}
impl
<
L
>
ToCss
for
Size2D
<
L
>
where
L
:
ToCss
+
PartialEq
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
width
.
to_css
(
dest
)
?
;
if
self
.
height
!
=
self
.
width
{
dest
.
write_char
(
'
'
)
?
;
self
.
height
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
impl
<
L
:
Zero
>
Zero
for
Size2D
<
L
>
{
fn
zero
(
)
-
>
Self
{
Self
:
:
new
(
L
:
:
zero
(
)
L
:
:
zero
(
)
)
}
fn
is_zero
(
&
self
)
-
>
bool
{
self
.
width
.
is_zero
(
)
&
&
self
.
height
.
is_zero
(
)
}
}
