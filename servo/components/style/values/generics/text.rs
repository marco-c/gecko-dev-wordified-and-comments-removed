use
app_units
:
:
Au
;
use
cssparser
:
:
Parser
;
use
parser
:
:
ParserContext
;
use
properties
:
:
animated_properties
:
:
Animatable
;
use
std
:
:
fmt
;
use
style_traits
:
:
{
ToCss
ParseError
}
;
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
HasViewportPercentage
PartialEq
ToComputedValue
)
]
pub
enum
InitialLetter
<
Number
Integer
>
{
Normal
Specified
(
Number
Option
<
Integer
>
)
}
impl
<
N
I
>
InitialLetter
<
N
I
>
{
#
[
inline
]
pub
fn
normal
(
)
-
>
Self
{
InitialLetter
:
:
Normal
}
}
impl
<
N
I
>
ToCss
for
InitialLetter
<
N
I
>
where
N
:
ToCss
I
:
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
InitialLetter
:
:
Normal
=
>
dest
.
write_str
(
"
normal
"
)
InitialLetter
:
:
Specified
(
ref
size
ref
sink
)
=
>
{
size
.
to_css
(
dest
)
?
;
if
let
Some
(
ref
sink
)
=
*
sink
{
dest
.
write_str
(
"
"
)
?
;
sink
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
HasViewportPercentage
PartialEq
ToComputedValue
ToCss
)
]
pub
enum
Spacing
<
Value
>
{
Normal
Value
(
Value
)
}
impl
<
Value
>
Spacing
<
Value
>
{
#
[
inline
]
pub
fn
normal
(
)
-
>
Self
{
Spacing
:
:
Normal
}
#
[
inline
]
pub
fn
parse_with
<
'
i
'
t
F
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
parse
:
F
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
where
F
:
FnOnce
(
&
ParserContext
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Value
ParseError
<
'
i
>
>
{
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
normal
"
)
)
.
is_ok
(
)
{
return
Ok
(
Spacing
:
:
Normal
)
;
}
parse
(
context
input
)
.
map
(
Spacing
:
:
Value
)
}
#
[
inline
]
pub
fn
value
(
&
self
)
-
>
Option
<
&
Value
>
{
match
*
self
{
Spacing
:
:
Normal
=
>
None
Spacing
:
:
Value
(
ref
value
)
=
>
Some
(
value
)
}
}
}
impl
<
Value
>
Animatable
for
Spacing
<
Value
>
where
Value
:
Animatable
+
From
<
Au
>
{
#
[
inline
]
fn
add_weighted
(
&
self
other
:
&
Self
self_portion
:
f64
other_portion
:
f64
)
-
>
Result
<
Self
(
)
>
{
if
let
(
&
Spacing
:
:
Normal
&
Spacing
:
:
Normal
)
=
(
self
other
)
{
return
Ok
(
Spacing
:
:
Normal
)
;
}
let
zero
=
Value
:
:
from
(
Au
(
0
)
)
;
let
this
=
self
.
value
(
)
.
unwrap_or
(
&
zero
)
;
let
other
=
other
.
value
(
)
.
unwrap_or
(
&
zero
)
;
this
.
add_weighted
(
other
self_portion
other_portion
)
.
map
(
Spacing
:
:
Value
)
}
#
[
inline
]
fn
compute_distance
(
&
self
other
:
&
Self
)
-
>
Result
<
f64
(
)
>
{
let
zero
=
Value
:
:
from
(
Au
(
0
)
)
;
let
this
=
self
.
value
(
)
.
unwrap_or
(
&
zero
)
;
let
other
=
other
.
value
(
)
.
unwrap_or
(
&
zero
)
;
this
.
compute_distance
(
other
)
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
HasViewportPercentage
PartialEq
ToCss
)
]
pub
enum
LineHeight
<
Number
LengthOrPercentage
>
{
Normal
#
[
cfg
(
feature
=
"
gecko
"
)
]
MozBlockHeight
Number
(
Number
)
Length
(
LengthOrPercentage
)
}
impl
<
N
L
>
LineHeight
<
N
L
>
{
#
[
inline
]
pub
fn
normal
(
)
-
>
Self
{
LineHeight
:
:
Normal
}
}
