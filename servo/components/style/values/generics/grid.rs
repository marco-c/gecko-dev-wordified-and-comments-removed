use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
values
:
:
specified
;
use
crate
:
:
values
:
:
specified
:
:
grid
:
:
parse_line_names
;
use
crate
:
:
values
:
:
{
CSSFloat
CustomIdent
}
;
use
crate
:
:
{
Atom
Zero
}
;
use
cssparser
:
:
Parser
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
{
cmp
usize
}
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
pub
const
MIN_GRID_LINE
:
i32
=
-
10000
;
pub
const
MAX_GRID_LINE
:
i32
=
10000
;
#
[
derive
(
Clone
Debug
Default
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
GenericGridLine
<
Integer
>
{
pub
ident
:
Atom
pub
line_num
:
Integer
pub
is_span
:
bool
}
pub
use
self
:
:
GenericGridLine
as
GridLine
;
impl
<
Integer
>
GridLine
<
Integer
>
where
Integer
:
PartialEq
+
Zero
{
pub
fn
auto
(
)
-
>
Self
{
Self
{
is_span
:
false
line_num
:
Zero
:
:
zero
(
)
ident
:
atom
!
(
"
"
)
}
}
pub
fn
is_auto
(
&
self
)
-
>
bool
{
self
.
ident
=
=
atom
!
(
"
"
)
&
&
self
.
line_num
.
is_zero
(
)
&
&
!
self
.
is_span
}
pub
fn
is_ident_only
(
&
self
)
-
>
bool
{
self
.
ident
!
=
atom
!
(
"
"
)
&
&
self
.
line_num
.
is_zero
(
)
&
&
!
self
.
is_span
}
pub
fn
can_omit
(
&
self
other
:
&
Self
)
-
>
bool
{
if
self
.
is_ident_only
(
)
{
self
=
=
other
}
else
{
other
.
is_auto
(
)
}
}
}
impl
<
Integer
>
ToCss
for
GridLine
<
Integer
>
where
Integer
:
ToCss
+
PartialEq
+
Zero
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
self
.
is_auto
(
)
{
return
dest
.
write_str
(
"
auto
"
)
;
}
if
self
.
is_span
{
dest
.
write_str
(
"
span
"
)
?
;
}
if
!
self
.
line_num
.
is_zero
(
)
{
if
self
.
is_span
{
dest
.
write_str
(
"
"
)
?
;
}
self
.
line_num
.
to_css
(
dest
)
?
;
}
if
self
.
ident
!
=
atom
!
(
"
"
)
{
if
self
.
is_span
|
|
!
self
.
line_num
.
is_zero
(
)
{
dest
.
write_str
(
"
"
)
?
;
}
CustomIdent
(
self
.
ident
.
clone
(
)
)
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
impl
Parse
for
GridLine
<
specified
:
:
Integer
>
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
mut
grid_line
=
Self
:
:
auto
(
)
;
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
auto
"
)
)
.
is_ok
(
)
{
return
Ok
(
grid_line
)
;
}
let
mut
val_before_span
=
false
;
for
_
in
0
.
.
3
{
let
location
=
input
.
current_source_location
(
)
;
if
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
span
"
)
)
.
is_ok
(
)
{
if
grid_line
.
is_span
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
if
!
grid_line
.
line_num
.
is_zero
(
)
|
|
grid_line
.
ident
!
=
atom
!
(
"
"
)
{
val_before_span
=
true
;
}
grid_line
.
is_span
=
true
;
}
else
if
let
Ok
(
i
)
=
input
.
try
(
|
i
|
specified
:
:
Integer
:
:
parse
(
context
i
)
)
{
let
value
=
i
.
value
(
)
;
if
value
=
=
0
|
|
val_before_span
|
|
!
grid_line
.
line_num
.
is_zero
(
)
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
grid_line
.
line_num
=
specified
:
:
Integer
:
:
new
(
cmp
:
:
max
(
MIN_GRID_LINE
cmp
:
:
min
(
value
MAX_GRID_LINE
)
)
)
;
}
else
if
let
Ok
(
name
)
=
input
.
try
(
|
i
|
i
.
expect_ident_cloned
(
)
)
{
if
val_before_span
|
|
grid_line
.
ident
!
=
atom
!
(
"
"
)
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
grid_line
.
ident
=
CustomIdent
:
:
from_ident
(
location
&
name
&
[
"
auto
"
]
)
?
.
0
;
}
else
{
break
;
}
}
if
grid_line
.
is_auto
(
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
if
grid_line
.
is_span
{
if
!
grid_line
.
line_num
.
is_zero
(
)
{
if
grid_line
.
line_num
.
value
(
)
<
=
0
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
}
else
if
grid_line
.
ident
=
=
atom
!
(
"
"
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
}
Ok
(
grid_line
)
}
}
#
[
derive
(
Animate
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericTrackBreadth
<
L
>
{
Breadth
(
L
)
#
[
css
(
dimension
)
]
Fr
(
CSSFloat
)
Auto
MinContent
MaxContent
}
pub
use
self
:
:
GenericTrackBreadth
as
TrackBreadth
;
impl
<
L
>
TrackBreadth
<
L
>
{
#
[
inline
]
pub
fn
is_fixed
(
&
self
)
-
>
bool
{
matches
!
(
*
self
TrackBreadth
:
:
Breadth
(
.
.
)
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericTrackSize
<
L
>
{
Breadth
(
GenericTrackBreadth
<
L
>
)
#
[
css
(
function
)
]
Minmax
(
GenericTrackBreadth
<
L
>
GenericTrackBreadth
<
L
>
)
#
[
css
(
function
)
]
FitContent
(
GenericTrackBreadth
<
L
>
)
}
pub
use
self
:
:
GenericTrackSize
as
TrackSize
;
impl
<
L
>
TrackSize
<
L
>
{
const
INITIAL_VALUE
:
Self
=
TrackSize
:
:
Breadth
(
TrackBreadth
:
:
Auto
)
;
pub
const
fn
initial_value
(
)
-
>
Self
{
Self
:
:
INITIAL_VALUE
}
pub
fn
is_initial
(
&
self
)
-
>
bool
{
matches
!
(
*
self
TrackSize
:
:
Breadth
(
TrackBreadth
:
:
Auto
)
)
}
pub
fn
is_fixed
(
&
self
)
-
>
bool
{
match
*
self
{
TrackSize
:
:
Breadth
(
ref
breadth
)
=
>
breadth
.
is_fixed
(
)
TrackSize
:
:
Minmax
(
ref
breadth_1
ref
breadth_2
)
=
>
{
if
breadth_1
.
is_fixed
(
)
{
return
true
;
}
match
*
breadth_1
{
TrackBreadth
:
:
Fr
(
_
)
=
>
false
_
=
>
breadth_2
.
is_fixed
(
)
}
}
TrackSize
:
:
FitContent
(
_
)
=
>
false
}
}
}
impl
<
L
>
Default
for
TrackSize
<
L
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
initial_value
(
)
}
}
impl
<
L
:
ToCss
>
ToCss
for
TrackSize
<
L
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
*
self
{
TrackSize
:
:
Breadth
(
ref
breadth
)
=
>
breadth
.
to_css
(
dest
)
TrackSize
:
:
Minmax
(
ref
min
ref
max
)
=
>
{
if
let
TrackBreadth
:
:
Auto
=
*
min
{
if
let
TrackBreadth
:
:
Fr
(
_
)
=
*
max
{
return
max
.
to_css
(
dest
)
;
}
}
dest
.
write_str
(
"
minmax
(
"
)
?
;
min
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
max
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
TrackSize
:
:
FitContent
(
ref
lp
)
=
>
{
dest
.
write_str
(
"
fit
-
content
(
"
)
?
;
lp
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
}
}
}
#
[
derive
(
Clone
Debug
Default
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
transparent
)
]
pub
struct
GenericImplicitGridTracks
<
T
>
(
#
[
css
(
if_empty
=
"
auto
"
iterable
)
]
pub
crate
:
:
OwnedSlice
<
T
>
)
;
pub
use
self
:
:
GenericImplicitGridTracks
as
ImplicitGridTracks
;
impl
<
T
:
fmt
:
:
Debug
+
Default
+
PartialEq
>
ImplicitGridTracks
<
T
>
{
pub
fn
is_initial
(
&
self
)
-
>
bool
{
debug_assert_ne
!
(
*
self
ImplicitGridTracks
(
crate
:
:
OwnedSlice
:
:
from
(
vec
!
[
Default
:
:
default
(
)
]
)
)
)
;
self
.
0
.
is_empty
(
)
}
}
pub
fn
concat_serialize_idents
<
W
>
(
prefix
:
&
str
suffix
:
&
str
slice
:
&
[
CustomIdent
]
sep
:
&
str
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
let
Some
(
(
ref
first
rest
)
)
=
slice
.
split_first
(
)
{
dest
.
write_str
(
prefix
)
?
;
first
.
to_css
(
dest
)
?
;
for
thing
in
rest
{
dest
.
write_str
(
sep
)
?
;
thing
.
to_css
(
dest
)
?
;
}
dest
.
write_str
(
suffix
)
?
;
}
Ok
(
(
)
)
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
RepeatCount
<
Integer
>
{
Number
(
Integer
)
AutoFill
AutoFit
}
impl
Parse
for
RepeatCount
<
specified
:
:
Integer
>
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
mut
i
)
=
input
.
try
(
|
i
|
specified
:
:
Integer
:
:
parse_positive
(
context
i
)
)
{
if
i
.
value
(
)
>
MAX_GRID_LINE
{
i
=
specified
:
:
Integer
:
:
new
(
MAX_GRID_LINE
)
;
}
return
Ok
(
RepeatCount
:
:
Number
(
i
)
)
;
}
try_match_ident_ignore_ascii_case
!
{
input
"
auto
-
fill
"
=
>
Ok
(
RepeatCount
:
:
AutoFill
)
"
auto
-
fit
"
=
>
Ok
(
RepeatCount
:
:
AutoFit
)
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
css
(
function
=
"
repeat
"
)
]
#
[
repr
(
C
)
]
pub
struct
GenericTrackRepeat
<
L
I
>
{
pub
count
:
RepeatCount
<
I
>
pub
line_names
:
crate
:
:
OwnedSlice
<
crate
:
:
OwnedSlice
<
CustomIdent
>
>
pub
track_sizes
:
crate
:
:
OwnedSlice
<
GenericTrackSize
<
L
>
>
}
pub
use
self
:
:
GenericTrackRepeat
as
TrackRepeat
;
impl
<
L
:
ToCss
I
:
ToCss
>
ToCss
for
TrackRepeat
<
L
I
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
dest
.
write_str
(
"
repeat
(
"
)
?
;
self
.
count
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
let
mut
line_names_iter
=
self
.
line_names
.
iter
(
)
;
for
(
i
(
ref
size
ref
names
)
)
in
self
.
track_sizes
.
iter
(
)
.
zip
(
&
mut
line_names_iter
)
.
enumerate
(
)
{
if
i
>
0
{
dest
.
write_str
(
"
"
)
?
;
}
concat_serialize_idents
(
"
[
"
"
]
"
names
"
"
dest
)
?
;
size
.
to_css
(
dest
)
?
;
}
if
let
Some
(
line_names_last
)
=
line_names_iter
.
next
(
)
{
concat_serialize_idents
(
"
[
"
"
]
"
line_names_last
"
"
dest
)
?
;
}
dest
.
write_str
(
"
)
"
)
?
;
Ok
(
(
)
)
}
}
#
[
derive
(
Animate
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericTrackListValue
<
LengthPercentage
Integer
>
{
TrackSize
(
#
[
animation
(
field_bound
)
]
GenericTrackSize
<
LengthPercentage
>
)
TrackRepeat
(
#
[
animation
(
field_bound
)
]
GenericTrackRepeat
<
LengthPercentage
Integer
>
)
}
pub
use
self
:
:
GenericTrackListValue
as
TrackListValue
;
impl
<
L
I
>
TrackListValue
<
L
I
>
{
const
INITIAL_VALUE
:
Self
=
TrackListValue
:
:
TrackSize
(
TrackSize
:
:
Breadth
(
TrackBreadth
:
:
Auto
)
)
;
fn
is_repeat
(
&
self
)
-
>
bool
{
matches
!
(
*
self
TrackListValue
:
:
TrackRepeat
(
.
.
)
)
}
pub
fn
is_initial
(
&
self
)
-
>
bool
{
matches
!
(
*
self
TrackListValue
:
:
TrackSize
(
TrackSize
:
:
Breadth
(
TrackBreadth
:
:
Auto
)
)
)
}
}
impl
<
L
I
>
Default
for
TrackListValue
<
L
I
>
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
:
:
INITIAL_VALUE
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
GenericTrackList
<
LengthPercentage
Integer
>
{
#
[
css
(
skip
)
]
pub
auto_repeat_index
:
usize
pub
values
:
crate
:
:
OwnedSlice
<
GenericTrackListValue
<
LengthPercentage
Integer
>
>
pub
line_names
:
crate
:
:
OwnedSlice
<
crate
:
:
OwnedSlice
<
CustomIdent
>
>
}
pub
use
self
:
:
GenericTrackList
as
TrackList
;
impl
<
L
I
>
TrackList
<
L
I
>
{
pub
fn
is_explicit
(
&
self
)
-
>
bool
{
!
self
.
values
.
iter
(
)
.
any
(
|
v
|
v
.
is_repeat
(
)
)
}
pub
fn
has_auto_repeat
(
&
self
)
-
>
bool
{
self
.
auto_repeat_index
<
self
.
values
.
len
(
)
}
}
impl
<
L
:
ToCss
I
:
ToCss
>
ToCss
for
TrackList
<
L
I
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
let
mut
values_iter
=
self
.
values
.
iter
(
)
.
peekable
(
)
;
let
mut
line_names_iter
=
self
.
line_names
.
iter
(
)
.
peekable
(
)
;
for
idx
in
0
.
.
{
let
names
=
line_names_iter
.
next
(
)
.
unwrap
(
)
;
concat_serialize_idents
(
"
[
"
"
]
"
names
"
"
dest
)
?
;
match
values_iter
.
next
(
)
{
Some
(
value
)
=
>
{
if
!
names
.
is_empty
(
)
{
dest
.
write_str
(
"
"
)
?
;
}
value
.
to_css
(
dest
)
?
;
}
None
=
>
break
}
if
values_iter
.
peek
(
)
.
is_some
(
)
|
|
line_names_iter
.
peek
(
)
.
map_or
(
false
|
v
|
!
v
.
is_empty
(
)
)
|
|
(
idx
+
1
=
=
self
.
auto_repeat_index
)
{
dest
.
write_str
(
"
"
)
?
;
}
}
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Debug
Default
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
LineNameList
{
pub
names
:
crate
:
:
OwnedSlice
<
crate
:
:
OwnedSlice
<
CustomIdent
>
>
pub
fill_idx
:
usize
}
impl
Parse
for
LineNameList
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
expect_ident_matching
(
"
subgrid
"
)
?
;
let
mut
line_names
=
vec
!
[
]
;
let
mut
fill_idx
=
None
;
loop
{
let
repeat_parse_result
=
input
.
try
(
|
input
|
{
input
.
expect_function_matching
(
"
repeat
"
)
?
;
input
.
parse_nested_block
(
|
input
|
{
let
count
=
RepeatCount
:
:
parse
(
context
input
)
?
;
input
.
expect_comma
(
)
?
;
let
mut
names_list
=
vec
!
[
]
;
names_list
.
push
(
parse_line_names
(
input
)
?
)
;
while
let
Ok
(
names
)
=
input
.
try
(
parse_line_names
)
{
names_list
.
push
(
names
)
;
}
Ok
(
(
names_list
count
)
)
}
)
}
)
;
if
let
Ok
(
(
mut
names_list
count
)
)
=
repeat_parse_result
{
match
count
{
RepeatCount
:
:
Number
(
num
)
=
>
line_names
.
extend
(
names_list
.
iter
(
)
.
cloned
(
)
.
cycle
(
)
.
take
(
num
.
value
(
)
as
usize
*
names_list
.
len
(
)
)
)
RepeatCount
:
:
AutoFill
if
fill_idx
.
is_none
(
)
=
>
{
if
names_list
.
len
(
)
!
=
1
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
let
names
=
names_list
.
pop
(
)
.
unwrap
(
)
;
line_names
.
push
(
names
)
;
fill_idx
=
Some
(
line_names
.
len
(
)
-
1
)
;
}
_
=
>
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
else
if
let
Ok
(
names
)
=
input
.
try
(
parse_line_names
)
{
line_names
.
push
(
names
)
;
}
else
{
break
;
}
}
if
line_names
.
len
(
)
>
MAX_GRID_LINE
as
usize
{
line_names
.
truncate
(
MAX_GRID_LINE
as
usize
)
;
}
Ok
(
LineNameList
{
names
:
line_names
.
into
(
)
fill_idx
:
fill_idx
.
unwrap_or
(
usize
:
:
MAX
)
}
)
}
}
impl
ToCss
for
LineNameList
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
dest
.
write_str
(
"
subgrid
"
)
?
;
let
fill_idx
=
self
.
fill_idx
;
for
(
i
names
)
in
self
.
names
.
iter
(
)
.
enumerate
(
)
{
if
i
=
=
fill_idx
{
dest
.
write_str
(
"
repeat
(
auto
-
fill
"
)
?
;
}
dest
.
write_str
(
"
[
"
)
?
;
if
let
Some
(
(
ref
first
rest
)
)
=
names
.
split_first
(
)
{
first
.
to_css
(
dest
)
?
;
for
name
in
rest
{
dest
.
write_str
(
"
"
)
?
;
name
.
to_css
(
dest
)
?
;
}
}
dest
.
write_str
(
"
]
"
)
?
;
if
i
=
=
fill_idx
{
dest
.
write_str
(
"
)
"
)
?
;
}
}
Ok
(
(
)
)
}
}
#
[
derive
(
Animate
Clone
Debug
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
u8
)
]
pub
enum
GenericGridTemplateComponent
<
L
I
>
{
None
TrackList
(
#
[
animation
(
field_bound
)
]
#
[
compute
(
field_bound
)
]
#
[
resolve
(
field_bound
)
]
#
[
shmem
(
field_bound
)
]
Box
<
GenericTrackList
<
L
I
>
>
)
#
[
animation
(
error
)
]
Subgrid
(
Box
<
LineNameList
>
)
}
pub
use
self
:
:
GenericGridTemplateComponent
as
GridTemplateComponent
;
impl
<
L
I
>
GridTemplateComponent
<
L
I
>
{
const
INITIAL_VALUE
:
Self
=
Self
:
:
None
;
pub
fn
track_list_len
(
&
self
)
-
>
usize
{
match
*
self
{
GridTemplateComponent
:
:
TrackList
(
ref
tracklist
)
=
>
tracklist
.
values
.
len
(
)
_
=
>
0
}
}
pub
fn
is_initial
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Self
:
:
None
)
}
}
impl
<
L
I
>
Default
for
GridTemplateComponent
<
L
I
>
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
:
:
INITIAL_VALUE
}
}
