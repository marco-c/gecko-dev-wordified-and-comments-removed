use
app_units
:
:
Au
;
use
euclid
:
:
{
Rect
Transform3D
Vector3D
}
;
use
properties
:
:
longhands
:
:
transform
:
:
computed_value
:
:
{
ComputedOperation
ComputedMatrix
}
;
use
properties
:
:
longhands
:
:
transform
:
:
computed_value
:
:
T
as
TransformList
;
use
std
:
:
f32
;
use
super
:
:
CSSFloat
;
use
values
:
:
computed
:
:
{
Angle
Length
LengthOrPercentage
Number
Percentage
}
;
use
values
:
:
generics
:
:
transform
:
:
TimingFunction
as
GenericTimingFunction
;
use
values
:
:
generics
:
:
transform
:
:
TransformOrigin
as
GenericTransformOrigin
;
pub
type
TransformOrigin
=
GenericTransformOrigin
<
LengthOrPercentage
LengthOrPercentage
Length
>
;
pub
type
TimingFunction
=
GenericTimingFunction
<
u32
Number
>
;
pub
type
DirectionVector
=
Vector3D
<
CSSFloat
>
;
impl
TransformOrigin
{
#
[
inline
]
pub
fn
initial_value
(
)
-
>
Self
{
Self
:
:
new
(
LengthOrPercentage
:
:
Percentage
(
Percentage
(
0
.
5
)
)
LengthOrPercentage
:
:
Percentage
(
Percentage
(
0
.
5
)
)
Length
:
:
new
(
0
.
)
)
}
}
impl
From
<
ComputedMatrix
>
for
Transform3D
<
CSSFloat
>
{
#
[
inline
]
fn
from
(
m
:
ComputedMatrix
)
-
>
Self
{
Transform3D
:
:
row_major
(
m
.
m11
m
.
m12
m
.
m13
m
.
m14
m
.
m21
m
.
m22
m
.
m23
m
.
m24
m
.
m31
m
.
m32
m
.
m33
m
.
m34
m
.
m41
m
.
m42
m
.
m43
m
.
m44
)
}
}
impl
From
<
Transform3D
<
CSSFloat
>
>
for
ComputedMatrix
{
#
[
inline
]
fn
from
(
m
:
Transform3D
<
CSSFloat
>
)
-
>
Self
{
ComputedMatrix
{
m11
:
m
.
m11
m12
:
m
.
m12
m13
:
m
.
m13
m14
:
m
.
m14
m21
:
m
.
m21
m22
:
m
.
m22
m23
:
m
.
m23
m24
:
m
.
m24
m31
:
m
.
m31
m32
:
m
.
m32
m33
:
m
.
m33
m34
:
m
.
m34
m41
:
m
.
m41
m42
:
m
.
m42
m43
:
m
.
m43
m44
:
m
.
m44
}
}
}
impl
TransformList
{
pub
fn
to_transform_3d_matrix
(
&
self
reference_box
:
Option
<
&
Rect
<
Au
>
>
)
-
>
Option
<
Transform3D
<
CSSFloat
>
>
{
let
mut
transform
=
Transform3D
:
:
identity
(
)
;
let
list
=
match
self
.
0
.
as_ref
(
)
{
Some
(
list
)
=
>
list
None
=
>
return
None
}
;
let
extract_pixel_length
=
|
lop
:
&
LengthOrPercentage
|
{
match
*
lop
{
LengthOrPercentage
:
:
Length
(
px
)
=
>
px
.
px
(
)
LengthOrPercentage
:
:
Percentage
(
_
)
=
>
0
.
LengthOrPercentage
:
:
Calc
(
calc
)
=
>
calc
.
length
(
)
.
px
(
)
}
}
;
for
operation
in
list
{
let
matrix
=
match
*
operation
{
ComputedOperation
:
:
RotateX
(
theta
)
=
>
{
let
theta
=
Angle
:
:
from_radians
(
2
.
0f32
*
f32
:
:
consts
:
:
PI
-
theta
.
radians
(
)
)
;
Transform3D
:
:
create_rotation
(
1
.
0
.
0
.
theta
.
into
(
)
)
}
ComputedOperation
:
:
RotateY
(
theta
)
=
>
{
let
theta
=
Angle
:
:
from_radians
(
2
.
0f32
*
f32
:
:
consts
:
:
PI
-
theta
.
radians
(
)
)
;
Transform3D
:
:
create_rotation
(
0
.
1
.
0
.
theta
.
into
(
)
)
}
ComputedOperation
:
:
RotateZ
(
theta
)
=
>
{
let
theta
=
Angle
:
:
from_radians
(
2
.
0f32
*
f32
:
:
consts
:
:
PI
-
theta
.
radians
(
)
)
;
Transform3D
:
:
create_rotation
(
0
.
0
.
1
.
theta
.
into
(
)
)
}
ComputedOperation
:
:
Rotate
(
ax
ay
az
theta
)
=
>
{
let
theta
=
Angle
:
:
from_radians
(
2
.
0f32
*
f32
:
:
consts
:
:
PI
-
theta
.
radians
(
)
)
;
let
(
ax
ay
az
theta
)
=
Self
:
:
get_normalized_vector_and_angle
(
ax
ay
az
theta
)
;
Transform3D
:
:
create_rotation
(
ax
ay
az
theta
.
into
(
)
)
}
ComputedOperation
:
:
Perspective
(
d
)
=
>
{
Self
:
:
create_perspective_matrix
(
d
.
px
(
)
)
}
ComputedOperation
:
:
ScaleX
(
sx
)
=
>
{
Transform3D
:
:
create_scale
(
sx
1
.
1
.
)
}
ComputedOperation
:
:
ScaleY
(
sy
)
=
>
{
Transform3D
:
:
create_scale
(
1
.
sy
1
.
)
}
ComputedOperation
:
:
ScaleZ
(
sz
)
=
>
{
Transform3D
:
:
create_scale
(
1
.
1
.
sz
)
}
ComputedOperation
:
:
Scale
(
sx
sy
sz
)
=
>
{
Transform3D
:
:
create_scale
(
sx
sy
sz
)
}
ComputedOperation
:
:
TranslateX
(
tx
)
=
>
{
let
tx
=
match
reference_box
{
Some
(
relative_border_box
)
=
>
tx
.
to_used_value
(
relative_border_box
.
size
.
width
)
.
to_f32_px
(
)
None
=
>
extract_pixel_length
(
&
tx
)
}
;
Transform3D
:
:
create_translation
(
tx
0
.
0
.
)
}
ComputedOperation
:
:
TranslateY
(
ty
)
=
>
{
let
ty
=
match
reference_box
{
Some
(
relative_border_box
)
=
>
ty
.
to_used_value
(
relative_border_box
.
size
.
height
)
.
to_f32_px
(
)
None
=
>
extract_pixel_length
(
&
ty
)
}
;
Transform3D
:
:
create_translation
(
0
.
ty
0
.
)
}
ComputedOperation
:
:
TranslateZ
(
tz
)
=
>
{
Transform3D
:
:
create_translation
(
0
.
0
.
tz
.
px
(
)
)
}
ComputedOperation
:
:
Translate
(
tx
ty
tz
)
=
>
{
let
(
tx
ty
)
=
match
reference_box
{
Some
(
relative_border_box
)
=
>
{
(
tx
.
to_pixel_length
(
relative_border_box
.
size
.
width
)
.
px
(
)
ty
.
to_pixel_length
(
relative_border_box
.
size
.
height
)
.
px
(
)
)
}
None
=
>
{
(
extract_pixel_length
(
&
tx
)
extract_pixel_length
(
&
ty
)
)
}
}
;
let
tz
=
tz
.
px
(
)
;
Transform3D
:
:
create_translation
(
tx
ty
tz
)
}
ComputedOperation
:
:
Matrix
(
m
)
=
>
{
m
.
into
(
)
}
ComputedOperation
:
:
MatrixWithPercents
(
_
)
=
>
{
unreachable
!
(
)
}
ComputedOperation
:
:
Skew
(
theta_x
theta_y
)
=
>
{
Transform3D
:
:
create_skew
(
theta_x
.
into
(
)
theta_y
.
into
(
)
)
}
ComputedOperation
:
:
InterpolateMatrix
{
.
.
}
|
ComputedOperation
:
:
AccumulateMatrix
{
.
.
}
=
>
{
return
None
;
}
}
;
transform
=
transform
.
pre_mul
(
&
matrix
)
;
}
Some
(
transform
)
}
#
[
inline
]
pub
fn
create_perspective_matrix
(
d
:
CSSFloat
)
-
>
Transform3D
<
f32
>
{
if
d
<
=
0
.
0
{
Transform3D
:
:
identity
(
)
}
else
{
Transform3D
:
:
create_perspective
(
d
)
}
}
pub
fn
get_normalized_vector_and_angle
(
x
:
f32
y
:
f32
z
:
f32
angle
:
Angle
)
-
>
(
f32
f32
f32
Angle
)
{
use
euclid
:
:
approxeq
:
:
ApproxEq
;
use
euclid
:
:
num
:
:
Zero
;
let
vector
=
DirectionVector
:
:
new
(
x
y
z
)
;
if
vector
.
square_length
(
)
.
approx_eq
(
&
f32
:
:
zero
(
)
)
{
(
0
.
0
.
1
.
Angle
:
:
zero
(
)
)
}
else
{
let
vector
=
vector
.
normalize
(
)
;
(
vector
.
x
vector
.
y
vector
.
z
angle
)
}
}
}
