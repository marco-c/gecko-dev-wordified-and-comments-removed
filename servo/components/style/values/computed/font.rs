use
app_units
:
:
Au
;
use
std
:
:
fmt
;
use
style_traits
:
:
ToCss
;
use
values
:
:
CSSFloat
;
use
values
:
:
animated
:
:
{
ToAnimatedValue
ToAnimatedZero
}
;
use
values
:
:
computed
:
:
{
Context
NonNegativeLength
ToComputedValue
}
;
use
values
:
:
specified
:
:
font
as
specified
;
use
values
:
:
specified
:
:
length
:
:
{
FontBaseSize
NoCalcLength
}
;
pub
use
values
:
:
computed
:
:
Length
as
MozScriptMinSize
;
pub
use
values
:
:
specified
:
:
font
:
:
{
XTextZoom
FontSynthesis
}
;
#
[
derive
(
Clone
ComputeSquaredDistance
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
ToCss
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
pub
struct
FontWeight
(
pub
u16
)
;
#
[
derive
(
Animate
ComputeSquaredDistance
MallocSizeOf
ToAnimatedZero
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
struct
FontSize
{
pub
size
:
NonNegativeLength
pub
keyword_info
:
Option
<
KeywordInfo
>
}
#
[
derive
(
Animate
ComputeSquaredDistance
MallocSizeOf
ToAnimatedValue
ToAnimatedZero
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
struct
KeywordInfo
{
pub
kw
:
specified
:
:
KeywordSize
pub
factor
:
f32
pub
offset
:
NonNegativeLength
}
impl
KeywordInfo
{
pub
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
NonNegativeLength
{
let
base
=
context
.
maybe_zoom_text
(
self
.
kw
.
to_computed_value
(
context
)
)
;
base
.
scale_by
(
self
.
factor
)
+
context
.
maybe_zoom_text
(
self
.
offset
)
}
pub
fn
compose
(
self
factor
:
f32
offset
:
NonNegativeLength
)
-
>
Self
{
KeywordInfo
{
kw
:
self
.
kw
factor
:
self
.
factor
*
factor
offset
:
self
.
offset
.
scale_by
(
factor
)
+
offset
}
}
pub
fn
medium
(
)
-
>
Self
{
specified
:
:
KeywordSize
:
:
Medium
.
into
(
)
}
}
impl
From
<
specified
:
:
KeywordSize
>
for
KeywordInfo
{
fn
from
(
x
:
specified
:
:
KeywordSize
)
-
>
Self
{
KeywordInfo
{
kw
:
x
factor
:
1
.
offset
:
Au
(
0
)
.
into
(
)
}
}
}
impl
FontWeight
{
pub
fn
normal
(
)
-
>
Self
{
FontWeight
(
400
)
}
pub
fn
bold
(
)
-
>
Self
{
FontWeight
(
700
)
}
pub
fn
from_int
(
n
:
i32
)
-
>
Result
<
Self
(
)
>
{
if
n
>
=
100
&
&
n
<
=
900
&
&
n
%
100
=
=
0
{
Ok
(
FontWeight
(
n
as
u16
)
)
}
else
{
Err
(
(
)
)
}
}
pub
fn
from_gecko_weight
(
weight
:
u16
)
-
>
Self
{
FontWeight
(
weight
)
}
pub
fn
is_bold
(
&
self
)
-
>
bool
{
self
.
0
>
500
}
pub
fn
bolder
(
self
)
-
>
Self
{
if
self
.
0
<
400
{
FontWeight
(
400
)
}
else
if
self
.
0
<
600
{
FontWeight
(
700
)
}
else
{
FontWeight
(
900
)
}
}
pub
fn
lighter
(
self
)
-
>
Self
{
if
self
.
0
<
600
{
FontWeight
(
100
)
}
else
if
self
.
0
<
800
{
FontWeight
(
400
)
}
else
{
FontWeight
(
700
)
}
}
}
impl
FontSize
{
pub
fn
size
(
self
)
-
>
Au
{
self
.
size
.
into
(
)
}
#
[
inline
]
pub
fn
medium
(
)
-
>
Self
{
Self
{
size
:
Au
:
:
from_px
(
specified
:
:
FONT_MEDIUM_PX
)
.
into
(
)
keyword_info
:
Some
(
KeywordInfo
:
:
medium
(
)
)
}
}
pub
fn
cascade_inherit_font_size
(
context
:
&
mut
Context
)
{
let
kw_inherited_size
=
context
.
builder
.
get_parent_font
(
)
.
clone_font_size
(
)
.
keyword_info
.
map
(
|
info
|
{
specified
:
:
FontSize
:
:
Keyword
(
info
)
.
to_computed_value
(
context
)
.
size
}
)
;
let
mut
font
=
context
.
builder
.
take_font
(
)
;
font
.
inherit_font_size_from
(
context
.
builder
.
get_parent_font
(
)
kw_inherited_size
context
.
builder
.
device
)
;
context
.
builder
.
put_font
(
font
)
;
}
pub
fn
cascade_initial_font_size
(
context
:
&
mut
Context
)
{
let
computed
=
specified
:
:
FontSize
:
:
medium
(
)
.
to_computed_value
(
context
)
;
context
.
builder
.
mutate_font
(
)
.
set_font_size
(
computed
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
let
device
=
context
.
builder
.
device
;
context
.
builder
.
mutate_font
(
)
.
fixup_font_min_size
(
device
)
;
}
}
}
impl
ToCss
for
FontSize
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
self
.
size
.
to_css
(
dest
)
}
}
impl
ToAnimatedValue
for
FontSize
{
type
AnimatedValue
=
NonNegativeLength
;
#
[
inline
]
fn
to_animated_value
(
self
)
-
>
Self
:
:
AnimatedValue
{
self
.
size
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
FontSize
{
size
:
animated
.
clamp
(
)
keyword_info
:
None
}
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
ToCss
)
]
pub
enum
FontSizeAdjust
{
#
[
animation
(
error
)
]
None
Number
(
CSSFloat
)
}
impl
FontSizeAdjust
{
#
[
inline
]
pub
fn
none
(
)
-
>
Self
{
FontSizeAdjust
:
:
None
}
pub
fn
from_gecko_adjust
(
gecko
:
f32
)
-
>
Self
{
if
gecko
=
=
-
1
.
0
{
FontSizeAdjust
:
:
None
}
else
{
FontSizeAdjust
:
:
Number
(
gecko
)
}
}
}
impl
ToAnimatedZero
for
FontSizeAdjust
{
#
[
inline
]
fn
to_animated_zero
(
&
self
)
-
>
Result
<
Self
(
)
>
{
Err
(
(
)
)
}
}
impl
ToAnimatedValue
for
FontSizeAdjust
{
type
AnimatedValue
=
Self
;
#
[
inline
]
fn
to_animated_value
(
self
)
-
>
Self
{
self
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
match
animated
{
FontSizeAdjust
:
:
Number
(
number
)
=
>
FontSizeAdjust
:
:
Number
(
number
.
max
(
0
.
)
)
_
=
>
animated
}
}
}
impl
ToComputedValue
for
specified
:
:
MozScriptMinSize
{
type
ComputedValue
=
MozScriptMinSize
;
fn
to_computed_value
(
&
self
cx
:
&
Context
)
-
>
MozScriptMinSize
{
let
base_size
=
FontBaseSize
:
:
InheritedStyle
;
match
self
.
0
{
NoCalcLength
:
:
FontRelative
(
value
)
=
>
{
value
.
to_computed_value
(
cx
base_size
)
}
NoCalcLength
:
:
ServoCharacterWidth
(
value
)
=
>
{
value
.
to_computed_value
(
base_size
.
resolve
(
cx
)
)
}
ref
l
=
>
{
l
.
to_computed_value
(
cx
)
}
}
}
fn
from_computed_value
(
other
:
&
MozScriptMinSize
)
-
>
Self
{
specified
:
:
MozScriptMinSize
(
ToComputedValue
:
:
from_computed_value
(
other
)
)
}
}
pub
type
MozScriptLevel
=
i8
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ToComputedValue
for
specified
:
:
MozScriptLevel
{
type
ComputedValue
=
MozScriptLevel
;
fn
to_computed_value
(
&
self
cx
:
&
Context
)
-
>
i8
{
use
properties
:
:
longhands
:
:
_moz_math_display
:
:
SpecifiedValue
as
DisplayValue
;
use
std
:
:
{
cmp
i8
}
;
let
int
=
match
*
self
{
specified
:
:
MozScriptLevel
:
:
Auto
=
>
{
let
parent
=
cx
.
builder
.
get_parent_font
(
)
.
clone__moz_script_level
(
)
as
i32
;
let
display
=
cx
.
builder
.
get_parent_font
(
)
.
clone__moz_math_display
(
)
;
if
display
=
=
DisplayValue
:
:
inline
{
parent
+
1
}
else
{
parent
}
}
specified
:
:
MozScriptLevel
:
:
Relative
(
rel
)
=
>
{
let
parent
=
cx
.
builder
.
get_parent_font
(
)
.
clone__moz_script_level
(
)
;
parent
as
i32
+
rel
}
specified
:
:
MozScriptLevel
:
:
Absolute
(
abs
)
=
>
abs
}
;
cmp
:
:
min
(
int
i8
:
:
MAX
as
i32
)
as
i8
}
fn
from_computed_value
(
other
:
&
i8
)
-
>
Self
{
specified
:
:
MozScriptLevel
:
:
Absolute
(
*
other
as
i32
)
}
}
