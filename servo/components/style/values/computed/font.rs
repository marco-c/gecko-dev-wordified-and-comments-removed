#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
gecko_bindings
:
:
{
bindings
structs
}
;
use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
values
:
:
animated
:
:
ToAnimatedValue
;
use
crate
:
:
values
:
:
computed
:
:
{
Angle
Context
Integer
Length
NonNegativeLength
NonNegativeNumber
NonNegativePercentage
}
;
use
crate
:
:
values
:
:
computed
:
:
{
Number
Percentage
ToComputedValue
}
;
use
crate
:
:
values
:
:
generics
:
:
font
:
:
{
FeatureTagValue
FontSettings
VariationValue
}
;
use
crate
:
:
values
:
:
generics
:
:
{
font
as
generics
NonNegative
}
;
use
crate
:
:
values
:
:
specified
:
:
font
:
:
{
self
as
specified
KeywordInfo
MAX_FONT_WEIGHT
MIN_FONT_WEIGHT
}
;
use
crate
:
:
values
:
:
specified
:
:
length
:
:
{
FontBaseSize
NoCalcLength
}
;
use
crate
:
:
values
:
:
CSSFloat
;
use
crate
:
:
Atom
;
use
cssparser
:
:
{
serialize_identifier
CssStringWriter
Parser
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
malloc_size_of
:
:
{
MallocSizeOf
MallocSizeOfOps
}
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
style_traits
:
:
{
CssWriter
ParseError
ToCss
}
;
pub
use
crate
:
:
values
:
:
computed
:
:
Length
as
MozScriptMinSize
;
pub
use
crate
:
:
values
:
:
specified
:
:
font
:
:
{
FontSynthesis
MozScriptSizeMultiplier
}
;
pub
use
crate
:
:
values
:
:
specified
:
:
font
:
:
{
XLang
XTextZoom
}
;
pub
use
crate
:
:
values
:
:
specified
:
:
Integer
as
SpecifiedInteger
;
#
[
derive
(
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
ToCss
ToResolvedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
pub
struct
FontWeight
(
pub
Number
)
;
impl
Hash
for
FontWeight
{
fn
hash
<
H
:
Hasher
>
(
&
self
hasher
:
&
mut
H
)
{
hasher
.
write_u64
(
(
self
.
0
*
10000
.
)
.
trunc
(
)
as
u64
)
;
}
}
impl
ToAnimatedValue
for
FontWeight
{
type
AnimatedValue
=
Number
;
#
[
inline
]
fn
to_animated_value
(
self
)
-
>
Self
:
:
AnimatedValue
{
self
.
0
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
FontWeight
(
animated
.
max
(
MIN_FONT_WEIGHT
)
.
min
(
MAX_FONT_WEIGHT
)
)
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
ToAnimatedZero
ToCss
ToResolvedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
FontSize
{
pub
size
:
NonNegativeLength
#
[
css
(
skip
)
]
pub
keyword_info
:
KeywordInfo
}
impl
FontWeight
{
pub
fn
normal
(
)
-
>
Self
{
FontWeight
(
400
.
)
}
pub
fn
bold
(
)
-
>
Self
{
FontWeight
(
700
.
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
from_gecko_weight
(
weight
:
structs
:
:
FontWeight
)
-
>
Self
{
let
weight
=
unsafe
{
bindings
:
:
Gecko_FontWeight_ToFloat
(
weight
)
}
;
FontWeight
(
weight
)
}
pub
fn
is_bold
(
&
self
)
-
>
bool
{
self
.
0
>
500
.
}
pub
fn
bolder
(
self
)
-
>
Self
{
if
self
.
0
<
350
.
{
FontWeight
(
400
.
)
}
else
if
self
.
0
<
550
.
{
FontWeight
(
700
.
)
}
else
{
FontWeight
(
self
.
0
.
max
(
900
.
)
)
}
}
pub
fn
lighter
(
self
)
-
>
Self
{
if
self
.
0
<
550
.
{
FontWeight
(
self
.
0
.
min
(
100
.
)
)
}
else
if
self
.
0
<
750
.
{
FontWeight
(
400
.
)
}
else
{
FontWeight
(
700
.
)
}
}
}
impl
FontSize
{
#
[
inline
]
pub
fn
size
(
&
self
)
-
>
Length
{
self
.
size
.
0
}
#
[
inline
]
pub
fn
medium
(
)
-
>
Self
{
Self
{
size
:
NonNegative
(
Length
:
:
new
(
specified
:
:
FONT_MEDIUM_PX
)
)
keyword_info
:
KeywordInfo
:
:
medium
(
)
}
}
}
impl
ToAnimatedValue
for
FontSize
{
type
AnimatedValue
=
Length
;
#
[
inline
]
fn
to_animated_value
(
self
)
-
>
Self
:
:
AnimatedValue
{
self
.
size
.
0
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
FontSize
{
size
:
NonNegative
(
animated
.
clamp_to_non_negative
(
)
)
keyword_info
:
KeywordInfo
:
:
none
(
)
}
}
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
ToComputedValue
ToResolvedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Hash
MallocSizeOf
Serialize
Deserialize
)
)
]
#
[
repr
(
C
)
]
pub
struct
FontFamily
{
pub
families
:
FontFamilyList
pub
is_system_font
:
bool
}
macro_rules
!
static_font_family
{
(
ident
:
ident
family
:
expr
)
=
>
{
lazy_static
!
{
static
ref
ident
:
FontFamily
=
FontFamily
{
families
:
FontFamilyList
{
list
:
crate
:
:
ArcSlice
:
:
from_iter_leaked
(
std
:
:
iter
:
:
once
(
family
)
)
fallback
:
GenericFontFamily
:
:
None
}
is_system_font
:
false
}
;
}
}
;
}
impl
FontFamily
{
#
[
inline
]
pub
fn
serif
(
)
-
>
Self
{
Self
:
:
generic
(
GenericFontFamily
:
:
Serif
)
.
clone
(
)
}
pub
(
crate
)
fn
moz_bullet
(
)
-
>
&
'
static
Self
{
static_font_family
!
(
MOZ_BULLET
SingleFontFamily
:
:
FamilyName
(
FamilyName
{
name
:
atom
!
(
"
-
moz
-
bullet
-
font
"
)
syntax
:
FontFamilyNameSyntax
:
:
Identifiers
}
)
)
;
&
*
MOZ_BULLET
}
pub
fn
for_system_font
(
name
:
&
str
)
-
>
Self
{
Self
{
families
:
FontFamilyList
{
list
:
crate
:
:
ArcSlice
:
:
from_iter
(
std
:
:
iter
:
:
once
(
SingleFontFamily
:
:
FamilyName
(
FamilyName
{
name
:
Atom
:
:
from
(
name
)
syntax
:
FontFamilyNameSyntax
:
:
Identifiers
}
)
)
)
fallback
:
GenericFontFamily
:
:
None
}
is_system_font
:
true
}
}
pub
fn
generic
(
generic
:
GenericFontFamily
)
-
>
&
'
static
Self
{
macro_rules
!
generic_font_family
{
(
ident
:
ident
family
:
ident
)
=
>
{
static_font_family
!
(
ident
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
family
)
)
}
}
generic_font_family
!
(
SERIF
Serif
)
;
generic_font_family
!
(
SANS_SERIF
SansSerif
)
;
generic_font_family
!
(
MONOSPACE
Monospace
)
;
generic_font_family
!
(
CURSIVE
Cursive
)
;
generic_font_family
!
(
FANTASY
Fantasy
)
;
generic_font_family
!
(
MOZ_EMOJI
MozEmoji
)
;
generic_font_family
!
(
SYSTEM_UI
SystemUi
)
;
match
generic
{
GenericFontFamily
:
:
None
=
>
{
debug_assert
!
(
false
"
Bogus
caller
!
"
)
;
&
*
SERIF
}
GenericFontFamily
:
:
Serif
=
>
&
*
SERIF
GenericFontFamily
:
:
SansSerif
=
>
&
*
SANS_SERIF
GenericFontFamily
:
:
Monospace
=
>
&
*
MONOSPACE
GenericFontFamily
:
:
Cursive
=
>
&
*
CURSIVE
GenericFontFamily
:
:
Fantasy
=
>
&
*
FANTASY
GenericFontFamily
:
:
MozEmoji
=
>
&
*
MOZ_EMOJI
GenericFontFamily
:
:
SystemUi
=
>
&
*
SYSTEM_UI
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
MallocSizeOf
for
FontFamily
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
use
malloc_size_of
:
:
MallocUnconditionalSizeOf
;
let
shared_font_list
=
&
self
.
families
.
list
;
if
shared_font_list
.
is_unique
(
)
{
shared_font_list
.
unconditional_size_of
(
ops
)
}
else
{
0
}
}
}
impl
ToCss
for
FontFamily
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
let
mut
iter
=
self
.
families
.
iter
(
)
;
match
iter
.
next
(
)
{
Some
(
f
)
=
>
f
.
to_css
(
dest
)
?
None
=
>
return
self
.
families
.
fallback
.
to_css
(
dest
)
}
for
family
in
iter
{
dest
.
write_str
(
"
"
)
?
;
family
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
PartialEq
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
repr
(
C
)
]
pub
struct
FamilyName
{
pub
name
:
Atom
pub
syntax
:
FontFamilyNameSyntax
}
impl
ToCss
for
FamilyName
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
self
.
syntax
{
FontFamilyNameSyntax
:
:
Quoted
=
>
{
dest
.
write_char
(
'
"
'
)
?
;
write
!
(
CssStringWriter
:
:
new
(
dest
)
"
{
}
"
self
.
name
)
?
;
dest
.
write_char
(
'
"
'
)
}
FontFamilyNameSyntax
:
:
Identifiers
=
>
{
let
mut
first
=
true
;
for
ident
in
self
.
name
.
to_string
(
)
.
split
(
'
'
)
{
if
first
{
first
=
false
;
}
else
{
dest
.
write_char
(
'
'
)
?
;
}
debug_assert
!
(
!
ident
.
is_empty
(
)
"
Family
name
with
leading
\
trailing
or
consecutive
white
spaces
should
\
have
been
marked
quoted
by
the
parser
"
)
;
serialize_identifier
(
ident
dest
)
?
;
}
Ok
(
(
)
)
}
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
repr
(
u8
)
]
pub
enum
FontFamilyNameSyntax
{
Quoted
Identifiers
}
/
/
/
cbindgen
:
derive
-
mut
-
casts
=
true
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
ToCss
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
Hash
)
)
]
#
[
repr
(
u8
)
]
pub
enum
SingleFontFamily
{
FamilyName
(
FamilyName
)
Generic
(
GenericFontFamily
)
}
fn
system_ui_enabled
(
_
:
&
ParserContext
)
-
>
bool
{
static_prefs
:
:
pref
!
(
"
layout
.
css
.
system
-
ui
.
enabled
"
)
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
Parse
ToCss
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
repr
(
u32
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
GenericFontFamily
{
#
[
css
(
skip
)
]
None
=
0
Serif
SansSerif
#
[
parse
(
aliases
=
"
-
moz
-
fixed
"
)
]
Monospace
Cursive
Fantasy
#
[
parse
(
condition
=
"
system_ui_enabled
"
)
]
SystemUi
#
[
css
(
skip
)
]
#
[
cfg
(
feature
=
"
gecko
"
)
]
MozEmoji
}
impl
GenericFontFamily
{
pub
(
crate
)
fn
valid_for_user_font_prioritization
(
self
)
-
>
bool
{
match
self
{
Self
:
:
None
|
Self
:
:
Fantasy
|
Self
:
:
Cursive
|
Self
:
:
SystemUi
|
Self
:
:
MozEmoji
=
>
false
Self
:
:
Serif
|
Self
:
:
SansSerif
|
Self
:
:
Monospace
=
>
true
}
}
}
impl
Parse
for
SingleFontFamily
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
value
)
=
input
.
try_parse
(
|
i
|
i
.
expect_string_cloned
(
)
)
{
return
Ok
(
SingleFontFamily
:
:
FamilyName
(
FamilyName
{
name
:
Atom
:
:
from
(
&
*
value
)
syntax
:
FontFamilyNameSyntax
:
:
Quoted
}
)
)
;
}
if
let
Ok
(
generic
)
=
input
.
try_parse
(
|
i
|
GenericFontFamily
:
:
parse
(
context
i
)
)
{
return
Ok
(
SingleFontFamily
:
:
Generic
(
generic
)
)
;
}
let
first_ident
=
input
.
expect_ident_cloned
(
)
?
;
let
reserved
=
match_ignore_ascii_case
!
{
&
first_ident
/
/
https
:
/
/
drafts
.
csswg
.
org
/
css
-
fonts
/
#
propdef
-
font
-
family
/
/
"
Font
family
names
that
happen
to
be
the
same
as
a
keyword
value
/
/
(
inherit
serif
sans
-
serif
monospace
fantasy
and
cursive
)
/
/
must
be
quoted
to
prevent
confusion
with
the
keywords
with
the
same
names
.
/
/
The
keywords
initial
and
default
are
reserved
for
future
use
/
/
and
must
also
be
quoted
when
used
as
font
names
.
/
/
UAs
must
not
consider
these
keywords
as
matching
the
<
family
-
name
>
type
.
"
"
inherit
"
|
"
initial
"
|
"
unset
"
|
"
revert
"
|
"
default
"
=
>
true
_
=
>
false
}
;
let
mut
value
=
first_ident
.
as_ref
(
)
.
to_owned
(
)
;
let
mut
serialize_quoted
=
value
.
contains
(
'
'
)
;
if
reserved
{
let
ident
=
input
.
expect_ident
(
)
?
;
serialize_quoted
=
serialize_quoted
|
|
ident
.
contains
(
'
'
)
;
value
.
push
(
'
'
)
;
value
.
push_str
(
&
ident
)
;
}
while
let
Ok
(
ident
)
=
input
.
try_parse
(
|
i
|
i
.
expect_ident_cloned
(
)
)
{
serialize_quoted
=
serialize_quoted
|
|
ident
.
contains
(
'
'
)
;
value
.
push
(
'
'
)
;
value
.
push_str
(
&
ident
)
;
}
let
syntax
=
if
serialize_quoted
{
FontFamilyNameSyntax
:
:
Quoted
}
else
{
FontFamilyNameSyntax
:
:
Identifiers
}
;
Ok
(
SingleFontFamily
:
:
FamilyName
(
FamilyName
{
name
:
Atom
:
:
from
(
value
)
syntax
}
)
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
SingleFontFamily
{
pub
fn
from_atom
(
input
:
Atom
)
-
>
SingleFontFamily
{
match
input
{
atom
!
(
"
serif
"
)
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Serif
)
atom
!
(
"
sans
-
serif
"
)
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
SansSerif
)
atom
!
(
"
cursive
"
)
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Cursive
)
atom
!
(
"
fantasy
"
)
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Fantasy
)
atom
!
(
"
monospace
"
)
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Monospace
)
_
=
>
{
}
}
match_ignore_ascii_case
!
{
&
input
"
serif
"
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Serif
)
"
sans
-
serif
"
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
SansSerif
)
"
cursive
"
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Cursive
)
"
fantasy
"
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Fantasy
)
"
monospace
"
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Monospace
)
_
=
>
{
}
}
SingleFontFamily
:
:
FamilyName
(
FamilyName
{
name
:
input
syntax
:
FontFamilyNameSyntax
:
:
Quoted
}
)
}
}
#
[
derive
(
Clone
Debug
ToComputedValue
ToResolvedValue
ToShmem
PartialEq
Eq
)
]
#
[
repr
(
C
)
]
pub
struct
FontFamilyList
{
pub
list
:
crate
:
:
ArcSlice
<
SingleFontFamily
>
pub
fallback
:
GenericFontFamily
}
impl
FontFamilyList
{
pub
fn
iter
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
SingleFontFamily
>
{
self
.
list
.
iter
(
)
}
pub
fn
normalize
(
&
mut
self
)
{
if
self
.
fallback
=
=
GenericFontFamily
:
:
None
{
return
;
}
let
mut
new_list
=
self
.
list
.
iter
(
)
.
cloned
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
new_list
.
push
(
SingleFontFamily
:
:
Generic
(
self
.
fallback
)
)
;
self
.
list
=
crate
:
:
ArcSlice
:
:
from_iter
(
new_list
.
into_iter
(
)
)
;
}
pub
(
crate
)
fn
prioritize_first_generic_or_prepend
(
&
mut
self
generic
:
GenericFontFamily
)
{
let
index_of_first_generic
=
self
.
iter
(
)
.
position
(
|
f
|
{
match
*
f
{
SingleFontFamily
:
:
Generic
(
f
)
=
>
f
.
valid_for_user_font_prioritization
(
)
_
=
>
false
}
}
)
;
if
let
Some
(
0
)
=
index_of_first_generic
{
return
;
}
let
mut
new_list
=
self
.
list
.
iter
(
)
.
cloned
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
element_to_prepend
=
match
index_of_first_generic
{
Some
(
i
)
=
>
new_list
.
remove
(
i
)
None
=
>
SingleFontFamily
:
:
Generic
(
generic
)
}
;
new_list
.
insert
(
0
element_to_prepend
)
;
self
.
list
=
crate
:
:
ArcSlice
:
:
from_iter
(
new_list
.
into_iter
(
)
)
;
}
pub
fn
single_generic
(
&
self
)
-
>
Option
<
GenericFontFamily
>
{
let
mut
iter
=
self
.
iter
(
)
;
if
let
Some
(
SingleFontFamily
:
:
Generic
(
f
)
)
=
iter
.
next
(
)
{
if
iter
.
next
(
)
.
is_none
(
)
{
return
Some
(
f
.
clone
(
)
)
;
}
}
None
}
}
pub
type
FontSizeAdjust
=
generics
:
:
GenericFontSizeAdjust
<
NonNegativeNumber
>
;
impl
FontSizeAdjust
{
#
[
inline
]
pub
fn
none
(
)
-
>
Self
{
FontSizeAdjust
:
:
None
}
}
pub
type
FontVariantAlternates
=
specified
:
:
VariantAlternatesList
;
impl
FontVariantAlternates
{
#
[
inline
]
pub
fn
get_initial_value
(
)
-
>
Self
{
Self
:
:
default
(
)
}
}
pub
type
FontVariantEastAsian
=
specified
:
:
VariantEastAsian
;
pub
type
FontVariantLigatures
=
specified
:
:
VariantLigatures
;
pub
type
FontVariantNumeric
=
specified
:
:
VariantNumeric
;
pub
type
FontFeatureSettings
=
FontSettings
<
FeatureTagValue
<
Integer
>
>
;
pub
type
FontVariationSettings
=
FontSettings
<
VariationValue
<
Number
>
>
;
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
ToResolvedValue
)
]
#
[
repr
(
C
)
]
pub
struct
FontLanguageOverride
(
pub
u32
)
;
impl
FontLanguageOverride
{
#
[
inline
]
pub
fn
zero
(
)
-
>
FontLanguageOverride
{
FontLanguageOverride
(
0
)
}
#
[
inline
]
pub
(
crate
)
fn
to_str
(
self
storage
:
&
mut
[
u8
;
4
]
)
-
>
&
str
{
*
storage
=
u32
:
:
to_be_bytes
(
self
.
0
)
;
let
slice
=
if
cfg
!
(
debug_assertions
)
{
std
:
:
str
:
:
from_utf8
(
&
storage
[
.
.
]
)
.
unwrap
(
)
}
else
{
unsafe
{
std
:
:
str
:
:
from_utf8_unchecked
(
&
storage
[
.
.
]
)
}
}
;
slice
.
trim_end
(
)
}
#
[
inline
]
pub
fn
from_str
(
lang
:
&
str
)
-
>
Self
{
if
lang
.
is_empty
(
)
|
|
lang
.
len
(
)
>
4
{
return
Self
:
:
zero
(
)
;
}
let
mut
bytes
=
[
b
'
'
;
4
]
;
for
(
byte
lang_byte
)
in
bytes
.
iter_mut
(
)
.
zip
(
lang
.
as_bytes
(
)
)
{
if
!
lang_byte
.
is_ascii
(
)
{
return
Self
:
:
zero
(
)
;
}
*
byte
=
*
lang_byte
;
}
Self
(
u32
:
:
from_be_bytes
(
bytes
)
)
}
#
[
inline
]
pub
unsafe
fn
from_u32
(
value
:
u32
)
-
>
Self
{
Self
(
value
)
}
}
impl
ToCss
for
FontLanguageOverride
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
if
self
.
0
=
=
0
{
return
dest
.
write_str
(
"
normal
"
)
;
}
self
.
to_str
(
&
mut
[
0
;
4
]
)
.
to_css
(
dest
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
u32
>
for
FontLanguageOverride
{
fn
from
(
v
:
u32
)
-
>
Self
{
unsafe
{
Self
:
:
from_u32
(
v
)
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
FontLanguageOverride
>
for
u32
{
fn
from
(
v
:
FontLanguageOverride
)
-
>
u32
{
v
.
0
}
}
impl
ToComputedValue
for
specified
:
:
MozScriptMinSize
{
type
ComputedValue
=
MozScriptMinSize
;
fn
to_computed_value
(
&
self
cx
:
&
Context
)
-
>
MozScriptMinSize
{
let
base_size
=
FontBaseSize
:
:
InheritedStyle
;
match
self
.
0
{
NoCalcLength
:
:
FontRelative
(
value
)
=
>
value
.
to_computed_value
(
cx
base_size
)
NoCalcLength
:
:
ServoCharacterWidth
(
value
)
=
>
{
value
.
to_computed_value
(
base_size
.
resolve
(
cx
)
)
}
ref
l
=
>
l
.
to_computed_value
(
cx
)
}
}
fn
from_computed_value
(
other
:
&
MozScriptMinSize
)
-
>
Self
{
specified
:
:
MozScriptMinSize
(
ToComputedValue
:
:
from_computed_value
(
other
)
)
}
}
pub
type
MathDepth
=
i8
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ToComputedValue
for
specified
:
:
MathDepth
{
type
ComputedValue
=
MathDepth
;
fn
to_computed_value
(
&
self
cx
:
&
Context
)
-
>
i8
{
use
crate
:
:
properties
:
:
longhands
:
:
math_style
:
:
SpecifiedValue
as
MathStyleValue
;
use
std
:
:
{
cmp
i8
}
;
let
int
=
match
*
self
{
specified
:
:
MathDepth
:
:
AutoAdd
=
>
{
let
parent
=
cx
.
builder
.
get_parent_font
(
)
.
clone_math_depth
(
)
as
i32
;
let
style
=
cx
.
builder
.
get_parent_font
(
)
.
clone_math_style
(
)
;
if
style
=
=
MathStyleValue
:
:
Compact
{
parent
.
saturating_add
(
1
)
}
else
{
parent
}
}
specified
:
:
MathDepth
:
:
Add
(
rel
)
=
>
{
let
parent
=
cx
.
builder
.
get_parent_font
(
)
.
clone_math_depth
(
)
;
(
parent
as
i32
)
.
saturating_add
(
rel
.
to_computed_value
(
cx
)
)
}
specified
:
:
MathDepth
:
:
Absolute
(
abs
)
=
>
abs
.
to_computed_value
(
cx
)
}
;
cmp
:
:
min
(
int
i8
:
:
MAX
as
i32
)
as
i8
}
fn
from_computed_value
(
other
:
&
i8
)
-
>
Self
{
let
computed_value
=
*
other
as
i32
;
specified
:
:
MathDepth
:
:
Absolute
(
SpecifiedInteger
:
:
from_computed_value
(
&
computed_value
)
)
}
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToCss
ToResolvedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
pub
struct
FontStyleAngle
(
pub
Angle
)
;
impl
ToAnimatedValue
for
FontStyleAngle
{
type
AnimatedValue
=
Angle
;
#
[
inline
]
fn
to_animated_value
(
self
)
-
>
Self
:
:
AnimatedValue
{
self
.
0
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
FontStyleAngle
(
Angle
:
:
from_degrees
(
animated
.
degrees
(
)
.
min
(
specified
:
:
FONT_STYLE_OBLIQUE_MAX_ANGLE_DEGREES
)
.
max
(
specified
:
:
FONT_STYLE_OBLIQUE_MIN_ANGLE_DEGREES
)
)
)
}
}
impl
Hash
for
FontStyleAngle
{
fn
hash
<
H
:
Hasher
>
(
&
self
hasher
:
&
mut
H
)
{
hasher
.
write_u64
(
(
self
.
0
.
degrees
(
)
*
10000
.
)
.
trunc
(
)
as
u64
)
;
}
}
pub
type
FontStyle
=
generics
:
:
FontStyle
<
FontStyleAngle
>
;
impl
FontStyle
{
#
[
inline
]
pub
fn
normal
(
)
-
>
Self
{
generics
:
:
FontStyle
:
:
Normal
}
#
[
inline
]
pub
fn
default_angle
(
)
-
>
FontStyleAngle
{
FontStyleAngle
(
Angle
:
:
from_degrees
(
specified
:
:
DEFAULT_FONT_STYLE_OBLIQUE_ANGLE_DEGREES
)
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
from_gecko
(
style
:
structs
:
:
FontSlantStyle
)
-
>
Self
{
let
mut
angle
=
0
.
;
let
mut
italic
=
false
;
let
mut
normal
=
false
;
unsafe
{
bindings
:
:
Gecko_FontSlantStyle_Get
(
style
&
mut
normal
&
mut
italic
&
mut
angle
)
;
}
if
normal
{
return
generics
:
:
FontStyle
:
:
Normal
;
}
if
italic
{
return
generics
:
:
FontStyle
:
:
Italic
;
}
generics
:
:
FontStyle
:
:
Oblique
(
FontStyleAngle
(
Angle
:
:
from_degrees
(
angle
)
)
)
}
}
impl
ToCss
for
FontStyle
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
generics
:
:
FontStyle
:
:
Normal
=
>
dest
.
write_str
(
"
normal
"
)
generics
:
:
FontStyle
:
:
Italic
=
>
dest
.
write_str
(
"
italic
"
)
generics
:
:
FontStyle
:
:
Oblique
(
ref
angle
)
=
>
{
dest
.
write_str
(
"
oblique
"
)
?
;
if
angle
.
0
.
degrees
(
)
!
=
Self
:
:
default_angle
(
)
.
0
.
degrees
(
)
{
dest
.
write_char
(
'
'
)
?
;
angle
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
}
}
#
[
derive
(
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
ToCss
ToResolvedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
pub
struct
FontStretch
(
pub
NonNegativePercentage
)
;
impl
FontStretch
{
pub
fn
hundred
(
)
-
>
Self
{
FontStretch
(
NonNegativePercentage
:
:
hundred
(
)
)
}
#
[
inline
]
pub
fn
value
(
&
self
)
-
>
CSSFloat
{
(
(
self
.
0
)
.
0
)
.
0
}
}
impl
ToAnimatedValue
for
FontStretch
{
type
AnimatedValue
=
Percentage
;
#
[
inline
]
fn
to_animated_value
(
self
)
-
>
Self
:
:
AnimatedValue
{
self
.
0
.
to_animated_value
(
)
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
FontStretch
(
NonNegativePercentage
:
:
from_animated_value
(
animated
)
)
}
}
impl
Hash
for
FontStretch
{
fn
hash
<
H
:
Hasher
>
(
&
self
hasher
:
&
mut
H
)
{
hasher
.
write_u64
(
(
self
.
value
(
)
*
10000
.
)
.
trunc
(
)
as
u64
)
;
}
}
