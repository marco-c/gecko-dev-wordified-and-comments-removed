#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
gecko_bindings
:
:
sugar
:
:
refptr
:
:
RefPtr
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
gecko_bindings
:
:
{
bindings
structs
}
;
use
crate
:
:
values
:
:
animated
:
:
ToAnimatedValue
;
use
crate
:
:
values
:
:
computed
:
:
{
Angle
Context
Integer
Length
NonNegativeLength
NonNegativeNumber
NonNegativePercentage
}
;
use
crate
:
:
values
:
:
computed
:
:
{
Number
Percentage
ToComputedValue
}
;
use
crate
:
:
values
:
:
generics
:
:
font
:
:
{
FeatureTagValue
FontSettings
VariationValue
}
;
use
crate
:
:
values
:
:
generics
:
:
{
font
as
generics
NonNegative
}
;
use
crate
:
:
values
:
:
specified
:
:
font
:
:
{
self
as
specified
KeywordInfo
MAX_FONT_WEIGHT
MIN_FONT_WEIGHT
}
;
use
crate
:
:
values
:
:
specified
:
:
length
:
:
{
FontBaseSize
NoCalcLength
}
;
use
crate
:
:
values
:
:
CSSFloat
;
use
crate
:
:
Atom
;
use
cssparser
:
:
{
serialize_identifier
CssStringWriter
Parser
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
malloc_size_of
:
:
{
MallocSizeOf
MallocSizeOfOps
}
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
std
:
:
mem
:
:
{
self
ManuallyDrop
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
std
:
:
slice
;
use
style_traits
:
:
{
CssWriter
ParseError
ToCss
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
to_shmem
:
:
{
self
SharedMemoryBuilder
ToShmem
}
;
pub
use
crate
:
:
values
:
:
computed
:
:
Length
as
MozScriptMinSize
;
pub
use
crate
:
:
values
:
:
specified
:
:
font
:
:
{
FontSynthesis
MozScriptSizeMultiplier
}
;
pub
use
crate
:
:
values
:
:
specified
:
:
font
:
:
{
XLang
XTextZoom
}
;
pub
use
crate
:
:
values
:
:
specified
:
:
Integer
as
SpecifiedInteger
;
#
[
derive
(
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
ToCss
ToResolvedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
pub
struct
FontWeight
(
pub
Number
)
;
impl
Hash
for
FontWeight
{
fn
hash
<
H
:
Hasher
>
(
&
self
hasher
:
&
mut
H
)
{
hasher
.
write_u64
(
(
self
.
0
*
10000
.
)
.
trunc
(
)
as
u64
)
;
}
}
impl
ToAnimatedValue
for
FontWeight
{
type
AnimatedValue
=
Number
;
#
[
inline
]
fn
to_animated_value
(
self
)
-
>
Self
:
:
AnimatedValue
{
self
.
0
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
FontWeight
(
animated
.
max
(
MIN_FONT_WEIGHT
)
.
min
(
MAX_FONT_WEIGHT
)
)
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
ToAnimatedZero
ToCss
ToResolvedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
FontSize
{
pub
size
:
NonNegativeLength
#
[
css
(
skip
)
]
pub
keyword_info
:
KeywordInfo
}
impl
FontWeight
{
pub
fn
normal
(
)
-
>
Self
{
FontWeight
(
400
.
)
}
pub
fn
bold
(
)
-
>
Self
{
FontWeight
(
700
.
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
from_gecko_weight
(
weight
:
structs
:
:
FontWeight
)
-
>
Self
{
let
weight
=
unsafe
{
bindings
:
:
Gecko_FontWeight_ToFloat
(
weight
)
}
;
FontWeight
(
weight
)
}
pub
fn
is_bold
(
&
self
)
-
>
bool
{
self
.
0
>
500
.
}
pub
fn
bolder
(
self
)
-
>
Self
{
if
self
.
0
<
350
.
{
FontWeight
(
400
.
)
}
else
if
self
.
0
<
550
.
{
FontWeight
(
700
.
)
}
else
{
FontWeight
(
self
.
0
.
max
(
900
.
)
)
}
}
pub
fn
lighter
(
self
)
-
>
Self
{
if
self
.
0
<
550
.
{
FontWeight
(
self
.
0
.
min
(
100
.
)
)
}
else
if
self
.
0
<
750
.
{
FontWeight
(
400
.
)
}
else
{
FontWeight
(
700
.
)
}
}
}
impl
FontSize
{
#
[
inline
]
pub
fn
size
(
&
self
)
-
>
Length
{
self
.
size
.
0
}
#
[
inline
]
pub
fn
medium
(
)
-
>
Self
{
Self
{
size
:
NonNegative
(
Length
:
:
new
(
specified
:
:
FONT_MEDIUM_PX
)
)
keyword_info
:
KeywordInfo
:
:
medium
(
)
}
}
}
impl
ToAnimatedValue
for
FontSize
{
type
AnimatedValue
=
Length
;
#
[
inline
]
fn
to_animated_value
(
self
)
-
>
Self
:
:
AnimatedValue
{
self
.
size
.
0
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
FontSize
{
size
:
NonNegative
(
animated
.
clamp_to_non_negative
(
)
)
keyword_info
:
KeywordInfo
:
:
none
(
)
}
}
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
ToComputedValue
ToResolvedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Hash
MallocSizeOf
Serialize
Deserialize
)
)
]
pub
struct
FontFamily
{
pub
families
:
FontFamilyList
pub
is_system_font
:
bool
}
impl
FontFamily
{
#
[
inline
]
pub
fn
serif
(
)
-
>
Self
{
FontFamily
{
families
:
FontFamilyList
:
:
new
(
Box
:
:
new
(
[
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Serif
)
]
)
)
is_system_font
:
false
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
MallocSizeOf
for
FontFamily
{
fn
size_of
(
&
self
_ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
shared_font_list
=
self
.
families
.
shared_font_list
(
)
.
get
(
)
;
unsafe
{
bindings
:
:
Gecko_SharedFontList_SizeOfIncludingThisIfUnshared
(
shared_font_list
)
}
}
}
impl
ToCss
for
FontFamily
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
let
mut
iter
=
self
.
families
.
iter
(
)
;
iter
.
next
(
)
.
unwrap
(
)
.
to_css
(
dest
)
?
;
for
family
in
iter
{
dest
.
write_str
(
"
"
)
?
;
family
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
PartialEq
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
pub
struct
FamilyName
{
pub
name
:
Atom
pub
syntax
:
FontFamilyNameSyntax
}
impl
ToCss
for
FamilyName
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
self
.
syntax
{
FontFamilyNameSyntax
:
:
Quoted
=
>
{
dest
.
write_char
(
'
"
'
)
?
;
write
!
(
CssStringWriter
:
:
new
(
dest
)
"
{
}
"
self
.
name
)
?
;
dest
.
write_char
(
'
"
'
)
}
FontFamilyNameSyntax
:
:
Identifiers
=
>
{
let
mut
first
=
true
;
for
ident
in
self
.
name
.
to_string
(
)
.
split
(
'
'
)
{
if
first
{
first
=
false
;
}
else
{
dest
.
write_char
(
'
'
)
?
;
}
debug_assert
!
(
!
ident
.
is_empty
(
)
"
Family
name
with
leading
\
trailing
or
consecutive
white
spaces
should
\
have
been
marked
quoted
by
the
parser
"
)
;
serialize_identifier
(
ident
dest
)
?
;
}
Ok
(
(
)
)
}
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
repr
(
u8
)
]
pub
enum
FontFamilyNameSyntax
{
Quoted
Identifiers
}
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
ToCss
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
Hash
)
)
]
pub
enum
SingleFontFamily
{
FamilyName
(
FamilyName
)
Generic
(
GenericFontFamily
)
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
Parse
ToCss
ToComputedValue
ToResolvedValue
ToShmem
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
repr
(
u8
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
GenericFontFamily
{
#
[
css
(
skip
)
]
None
=
0
Serif
SansSerif
#
[
parse
(
aliases
=
"
-
moz
-
fixed
"
)
]
Monospace
Cursive
Fantasy
#
[
css
(
skip
)
]
#
[
cfg
(
feature
=
"
gecko
"
)
]
MozEmoji
}
impl
SingleFontFamily
{
pub
fn
parse
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
if
let
Ok
(
value
)
=
input
.
try_parse
(
|
i
|
i
.
expect_string_cloned
(
)
)
{
return
Ok
(
SingleFontFamily
:
:
FamilyName
(
FamilyName
{
name
:
Atom
:
:
from
(
&
*
value
)
syntax
:
FontFamilyNameSyntax
:
:
Quoted
}
)
)
;
}
let
first_ident
=
input
.
expect_ident_cloned
(
)
?
;
if
let
Ok
(
generic
)
=
GenericFontFamily
:
:
from_ident
(
&
first_ident
)
{
return
Ok
(
SingleFontFamily
:
:
Generic
(
generic
)
)
;
}
let
reserved
=
match_ignore_ascii_case
!
{
&
first_ident
/
/
https
:
/
/
drafts
.
csswg
.
org
/
css
-
fonts
/
#
propdef
-
font
-
family
/
/
"
Font
family
names
that
happen
to
be
the
same
as
a
keyword
value
/
/
(
inherit
serif
sans
-
serif
monospace
fantasy
and
cursive
)
/
/
must
be
quoted
to
prevent
confusion
with
the
keywords
with
the
same
names
.
/
/
The
keywords
initial
and
default
are
reserved
for
future
use
/
/
and
must
also
be
quoted
when
used
as
font
names
.
/
/
UAs
must
not
consider
these
keywords
as
matching
the
<
family
-
name
>
type
.
"
"
inherit
"
|
"
initial
"
|
"
unset
"
|
"
revert
"
|
"
default
"
=
>
true
_
=
>
false
}
;
let
mut
value
=
first_ident
.
as_ref
(
)
.
to_owned
(
)
;
let
mut
serialize_quoted
=
value
.
contains
(
'
'
)
;
if
reserved
{
let
ident
=
input
.
expect_ident
(
)
?
;
serialize_quoted
=
serialize_quoted
|
|
ident
.
contains
(
'
'
)
;
value
.
push
(
'
'
)
;
value
.
push_str
(
&
ident
)
;
}
while
let
Ok
(
ident
)
=
input
.
try_parse
(
|
i
|
i
.
expect_ident_cloned
(
)
)
{
serialize_quoted
=
serialize_quoted
|
|
ident
.
contains
(
'
'
)
;
value
.
push
(
'
'
)
;
value
.
push_str
(
&
ident
)
;
}
let
syntax
=
if
serialize_quoted
{
FontFamilyNameSyntax
:
:
Quoted
}
else
{
FontFamilyNameSyntax
:
:
Identifiers
}
;
Ok
(
SingleFontFamily
:
:
FamilyName
(
FamilyName
{
name
:
Atom
:
:
from
(
value
)
syntax
}
)
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
from_atom
(
input
:
Atom
)
-
>
SingleFontFamily
{
match
input
{
atom
!
(
"
serif
"
)
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Serif
)
atom
!
(
"
sans
-
serif
"
)
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
SansSerif
)
atom
!
(
"
cursive
"
)
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Cursive
)
atom
!
(
"
fantasy
"
)
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Fantasy
)
atom
!
(
"
monospace
"
)
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Monospace
)
_
=
>
{
}
}
match_ignore_ascii_case
!
{
&
input
"
serif
"
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Serif
)
"
sans
-
serif
"
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
SansSerif
)
"
cursive
"
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Cursive
)
"
fantasy
"
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Fantasy
)
"
monospace
"
=
>
return
SingleFontFamily
:
:
Generic
(
GenericFontFamily
:
:
Monospace
)
_
=
>
{
}
}
SingleFontFamily
:
:
FamilyName
(
FamilyName
{
name
:
input
syntax
:
FontFamilyNameSyntax
:
:
Quoted
}
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
from_font_family_name
(
family
:
&
structs
:
:
FontFamilyName
)
-
>
SingleFontFamily
{
if
family
.
mName
.
mRawPtr
.
is_null
(
)
{
debug_assert_ne
!
(
family
.
mGeneric
GenericFontFamily
:
:
None
)
;
return
SingleFontFamily
:
:
Generic
(
family
.
mGeneric
)
;
}
let
name
=
unsafe
{
Atom
:
:
from_raw
(
family
.
mName
.
mRawPtr
)
}
;
SingleFontFamily
:
:
FamilyName
(
FamilyName
{
name
syntax
:
family
.
mSyntax
}
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
#
[
derive
(
Clone
Debug
Deserialize
Eq
Hash
MallocSizeOf
PartialEq
Serialize
ToComputedValue
ToResolvedValue
ToShmem
)
]
pub
struct
FontFamilyList
(
Box
<
[
SingleFontFamily
]
>
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
derive
(
Clone
Debug
ToComputedValue
ToResolvedValue
)
]
pub
enum
FontFamilyList
{
SharedFontList
(
#
[
compute
(
no_field_bound
)
]
#
[
resolve
(
no_field_bound
)
]
RefPtr
<
structs
:
:
SharedFontList
>
)
Generic
(
GenericFontFamily
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ToShmem
for
FontFamilyList
{
fn
to_shmem
(
&
self
_builder
:
&
mut
SharedMemoryBuilder
)
-
>
to_shmem
:
:
Result
<
Self
>
{
Ok
(
ManuallyDrop
:
:
new
(
match
*
self
{
FontFamilyList
:
:
SharedFontList
(
ref
r
)
=
>
{
if
!
(
r
.
mNames
.
len
(
)
=
=
1
&
&
r
.
mNames
[
0
]
.
mName
.
mRawPtr
.
is_null
(
)
)
{
return
Err
(
String
:
:
from
(
"
ToShmem
failed
for
FontFamilyList
:
cannot
handle
non
-
generic
families
"
)
)
;
}
FontFamilyList
:
:
Generic
(
r
.
mNames
[
0
]
.
mGeneric
)
}
FontFamilyList
:
:
Generic
(
t
)
=
>
FontFamilyList
:
:
Generic
(
t
)
}
)
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
PartialEq
for
FontFamilyList
{
fn
eq
(
&
self
other
:
&
FontFamilyList
)
-
>
bool
{
let
self_list
=
self
.
shared_font_list
(
)
;
let
other_list
=
other
.
shared_font_list
(
)
;
if
self_list
.
mNames
.
len
(
)
!
=
other_list
.
mNames
.
len
(
)
{
return
false
;
}
for
(
a
b
)
in
self_list
.
mNames
.
iter
(
)
.
zip
(
other_list
.
mNames
.
iter
(
)
)
{
if
a
.
mSyntax
!
=
b
.
mSyntax
|
|
a
.
mName
.
mRawPtr
!
=
b
.
mName
.
mRawPtr
|
|
a
.
mGeneric
!
=
b
.
mGeneric
{
return
false
;
}
}
true
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
Eq
for
FontFamilyList
{
}
impl
FontFamilyList
{
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
new
(
families
:
Box
<
[
SingleFontFamily
]
>
)
-
>
FontFamilyList
{
FontFamilyList
(
families
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
new
(
families
:
Box
<
[
SingleFontFamily
]
>
)
-
>
FontFamilyList
{
let
fontlist
;
let
names
;
unsafe
{
fontlist
=
bindings
:
:
Gecko_SharedFontList_Create
(
)
;
names
=
&
mut
(
*
fontlist
)
.
mNames
;
names
.
ensure_capacity
(
families
.
len
(
)
)
;
}
;
for
family
in
families
.
iter
(
)
{
match
*
family
{
SingleFontFamily
:
:
FamilyName
(
ref
f
)
=
>
unsafe
{
bindings
:
:
Gecko_nsTArray_FontFamilyName_AppendNamed
(
names
f
.
name
.
as_ptr
(
)
f
.
syntax
)
;
}
SingleFontFamily
:
:
Generic
(
family
)
=
>
unsafe
{
bindings
:
:
Gecko_nsTArray_FontFamilyName_AppendGeneric
(
names
family
)
;
}
}
}
FontFamilyList
:
:
SharedFontList
(
unsafe
{
RefPtr
:
:
from_addrefed
(
fontlist
)
}
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
iter
(
&
self
)
-
>
slice
:
:
Iter
<
SingleFontFamily
>
{
self
.
0
.
iter
(
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
iter
(
&
self
)
-
>
FontFamilyNameIter
{
FontFamilyNameIter
{
names
:
&
self
.
shared_font_list
(
)
.
mNames
cur
:
0
}
}
pub
fn
single_generic
(
&
self
)
-
>
Option
<
GenericFontFamily
>
{
let
mut
iter
=
self
.
iter
(
)
;
if
let
Some
(
SingleFontFamily
:
:
Generic
(
f
)
)
=
iter
.
next
(
)
{
if
iter
.
next
(
)
.
is_none
(
)
{
return
Some
(
f
.
clone
(
)
)
;
}
}
None
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
shared_font_list
(
&
self
)
-
>
&
RefPtr
<
structs
:
:
SharedFontList
>
{
match
*
self
{
FontFamilyList
:
:
SharedFontList
(
ref
r
)
=
>
r
FontFamilyList
:
:
Generic
(
t
)
=
>
{
unsafe
{
let
index
=
t
as
usize
;
mem
:
:
transmute
:
:
<
&
structs
:
:
StaticRefPtr
<
structs
:
:
SharedFontList
>
&
RefPtr
<
structs
:
:
SharedFontList
>
>
(
&
structs
:
:
SharedFontList_sSingleGenerics
[
index
]
)
}
}
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
struct
FontFamilyNameIter
<
'
a
>
{
names
:
&
'
a
structs
:
:
nsTArray
<
structs
:
:
FontFamilyName
>
cur
:
usize
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
<
'
a
>
Iterator
for
FontFamilyNameIter
<
'
a
>
{
type
Item
=
SingleFontFamily
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
cur
<
self
.
names
.
len
(
)
{
let
item
=
SingleFontFamily
:
:
from_font_family_name
(
&
self
.
names
[
self
.
cur
]
)
;
self
.
cur
+
=
1
;
Some
(
item
)
}
else
{
None
}
}
}
pub
type
FontSizeAdjust
=
generics
:
:
GenericFontSizeAdjust
<
NonNegativeNumber
>
;
impl
FontSizeAdjust
{
#
[
inline
]
pub
fn
none
(
)
-
>
Self
{
FontSizeAdjust
:
:
None
}
}
pub
type
FontVariantAlternates
=
specified
:
:
VariantAlternatesList
;
impl
FontVariantAlternates
{
#
[
inline
]
pub
fn
get_initial_value
(
)
-
>
Self
{
Self
:
:
default
(
)
}
}
pub
type
FontVariantEastAsian
=
specified
:
:
VariantEastAsian
;
pub
type
FontVariantLigatures
=
specified
:
:
VariantLigatures
;
pub
type
FontVariantNumeric
=
specified
:
:
VariantNumeric
;
pub
type
FontFeatureSettings
=
FontSettings
<
FeatureTagValue
<
Integer
>
>
;
pub
type
FontVariationSettings
=
FontSettings
<
VariationValue
<
Number
>
>
;
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
ToResolvedValue
)
]
#
[
repr
(
C
)
]
pub
struct
FontLanguageOverride
(
pub
u32
)
;
impl
FontLanguageOverride
{
#
[
inline
]
pub
fn
zero
(
)
-
>
FontLanguageOverride
{
FontLanguageOverride
(
0
)
}
#
[
inline
]
pub
(
crate
)
fn
to_str
(
self
storage
:
&
mut
[
u8
;
4
]
)
-
>
&
str
{
*
storage
=
u32
:
:
to_be_bytes
(
self
.
0
)
;
let
slice
=
if
cfg
!
(
debug_assertions
)
{
std
:
:
str
:
:
from_utf8
(
&
storage
[
.
.
]
)
.
unwrap
(
)
}
else
{
unsafe
{
std
:
:
str
:
:
from_utf8_unchecked
(
&
storage
[
.
.
]
)
}
}
;
slice
.
trim_end
(
)
}
#
[
inline
]
pub
fn
from_str
(
lang
:
&
str
)
-
>
Self
{
if
lang
.
is_empty
(
)
|
|
lang
.
len
(
)
>
4
{
return
Self
:
:
zero
(
)
;
}
let
mut
bytes
=
[
b
'
'
;
4
]
;
for
(
byte
lang_byte
)
in
bytes
.
iter_mut
(
)
.
zip
(
lang
.
as_bytes
(
)
)
{
if
!
lang_byte
.
is_ascii
(
)
{
return
Self
:
:
zero
(
)
;
}
*
byte
=
*
lang_byte
;
}
Self
(
u32
:
:
from_be_bytes
(
bytes
)
)
}
#
[
inline
]
pub
unsafe
fn
from_u32
(
value
:
u32
)
-
>
Self
{
Self
(
value
)
}
}
impl
ToCss
for
FontLanguageOverride
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
if
self
.
0
=
=
0
{
return
dest
.
write_str
(
"
normal
"
)
;
}
self
.
to_str
(
&
mut
[
0
;
4
]
)
.
to_css
(
dest
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
u32
>
for
FontLanguageOverride
{
fn
from
(
v
:
u32
)
-
>
Self
{
unsafe
{
Self
:
:
from_u32
(
v
)
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
FontLanguageOverride
>
for
u32
{
fn
from
(
v
:
FontLanguageOverride
)
-
>
u32
{
v
.
0
}
}
impl
ToComputedValue
for
specified
:
:
MozScriptMinSize
{
type
ComputedValue
=
MozScriptMinSize
;
fn
to_computed_value
(
&
self
cx
:
&
Context
)
-
>
MozScriptMinSize
{
let
base_size
=
FontBaseSize
:
:
InheritedStyle
;
match
self
.
0
{
NoCalcLength
:
:
FontRelative
(
value
)
=
>
value
.
to_computed_value
(
cx
base_size
)
NoCalcLength
:
:
ServoCharacterWidth
(
value
)
=
>
{
value
.
to_computed_value
(
base_size
.
resolve
(
cx
)
)
}
ref
l
=
>
l
.
to_computed_value
(
cx
)
}
}
fn
from_computed_value
(
other
:
&
MozScriptMinSize
)
-
>
Self
{
specified
:
:
MozScriptMinSize
(
ToComputedValue
:
:
from_computed_value
(
other
)
)
}
}
pub
type
MathDepth
=
i8
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ToComputedValue
for
specified
:
:
MathDepth
{
type
ComputedValue
=
MathDepth
;
fn
to_computed_value
(
&
self
cx
:
&
Context
)
-
>
i8
{
use
crate
:
:
properties
:
:
longhands
:
:
math_style
:
:
SpecifiedValue
as
MathStyleValue
;
use
std
:
:
{
cmp
i8
}
;
let
int
=
match
*
self
{
specified
:
:
MathDepth
:
:
AutoAdd
=
>
{
let
parent
=
cx
.
builder
.
get_parent_font
(
)
.
clone_math_depth
(
)
as
i32
;
let
style
=
cx
.
builder
.
get_parent_font
(
)
.
clone_math_style
(
)
;
if
style
=
=
MathStyleValue
:
:
Compact
{
parent
.
saturating_add
(
1
)
}
else
{
parent
}
}
specified
:
:
MathDepth
:
:
Add
(
rel
)
=
>
{
let
parent
=
cx
.
builder
.
get_parent_font
(
)
.
clone_math_depth
(
)
;
(
parent
as
i32
)
.
saturating_add
(
rel
.
to_computed_value
(
cx
)
)
}
specified
:
:
MathDepth
:
:
Absolute
(
abs
)
=
>
abs
.
to_computed_value
(
cx
)
}
;
cmp
:
:
min
(
int
i8
:
:
MAX
as
i32
)
as
i8
}
fn
from_computed_value
(
other
:
&
i8
)
-
>
Self
{
let
computed_value
=
*
other
as
i32
;
specified
:
:
MathDepth
:
:
Absolute
(
SpecifiedInteger
:
:
from_computed_value
(
&
computed_value
)
)
}
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToCss
ToResolvedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
pub
struct
FontStyleAngle
(
pub
Angle
)
;
impl
ToAnimatedValue
for
FontStyleAngle
{
type
AnimatedValue
=
Angle
;
#
[
inline
]
fn
to_animated_value
(
self
)
-
>
Self
:
:
AnimatedValue
{
self
.
0
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
FontStyleAngle
(
Angle
:
:
from_degrees
(
animated
.
degrees
(
)
.
min
(
specified
:
:
FONT_STYLE_OBLIQUE_MAX_ANGLE_DEGREES
)
.
max
(
specified
:
:
FONT_STYLE_OBLIQUE_MIN_ANGLE_DEGREES
)
)
)
}
}
impl
Hash
for
FontStyleAngle
{
fn
hash
<
H
:
Hasher
>
(
&
self
hasher
:
&
mut
H
)
{
hasher
.
write_u64
(
(
self
.
0
.
degrees
(
)
*
10000
.
)
.
trunc
(
)
as
u64
)
;
}
}
pub
type
FontStyle
=
generics
:
:
FontStyle
<
FontStyleAngle
>
;
impl
FontStyle
{
#
[
inline
]
pub
fn
normal
(
)
-
>
Self
{
generics
:
:
FontStyle
:
:
Normal
}
#
[
inline
]
pub
fn
default_angle
(
)
-
>
FontStyleAngle
{
FontStyleAngle
(
Angle
:
:
from_degrees
(
specified
:
:
DEFAULT_FONT_STYLE_OBLIQUE_ANGLE_DEGREES
)
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
from_gecko
(
style
:
structs
:
:
FontSlantStyle
)
-
>
Self
{
let
mut
angle
=
0
.
;
let
mut
italic
=
false
;
let
mut
normal
=
false
;
unsafe
{
bindings
:
:
Gecko_FontSlantStyle_Get
(
style
&
mut
normal
&
mut
italic
&
mut
angle
)
;
}
if
normal
{
return
generics
:
:
FontStyle
:
:
Normal
;
}
if
italic
{
return
generics
:
:
FontStyle
:
:
Italic
;
}
generics
:
:
FontStyle
:
:
Oblique
(
FontStyleAngle
(
Angle
:
:
from_degrees
(
angle
)
)
)
}
}
impl
ToCss
for
FontStyle
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
generics
:
:
FontStyle
:
:
Normal
=
>
dest
.
write_str
(
"
normal
"
)
generics
:
:
FontStyle
:
:
Italic
=
>
dest
.
write_str
(
"
italic
"
)
generics
:
:
FontStyle
:
:
Oblique
(
ref
angle
)
=
>
{
dest
.
write_str
(
"
oblique
"
)
?
;
if
angle
.
0
.
degrees
(
)
!
=
Self
:
:
default_angle
(
)
.
0
.
degrees
(
)
{
dest
.
write_char
(
'
'
)
?
;
angle
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
}
}
#
[
derive
(
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
ToCss
ToResolvedValue
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
pub
struct
FontStretch
(
pub
NonNegativePercentage
)
;
impl
FontStretch
{
pub
fn
hundred
(
)
-
>
Self
{
FontStretch
(
NonNegativePercentage
:
:
hundred
(
)
)
}
#
[
inline
]
pub
fn
value
(
&
self
)
-
>
CSSFloat
{
(
(
self
.
0
)
.
0
)
.
0
}
}
impl
ToAnimatedValue
for
FontStretch
{
type
AnimatedValue
=
Percentage
;
#
[
inline
]
fn
to_animated_value
(
self
)
-
>
Self
:
:
AnimatedValue
{
self
.
0
.
to_animated_value
(
)
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
FontStretch
(
NonNegativePercentage
:
:
from_animated_value
(
animated
)
)
}
}
impl
Hash
for
FontStretch
{
fn
hash
<
H
:
Hasher
>
(
&
self
hasher
:
&
mut
H
)
{
hasher
.
write_u64
(
(
self
.
value
(
)
*
10000
.
)
.
trunc
(
)
as
u64
)
;
}
}
