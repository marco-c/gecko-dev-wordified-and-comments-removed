use
crate
:
:
values
:
:
computed
:
:
{
Context
Integer
LengthPercentage
NonNegativeNumber
Percentage
ToComputedValue
}
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
Position
as
GenericPosition
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
PositionComponent
as
GenericPositionComponent
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
PositionOrAuto
as
GenericPositionOrAuto
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
ZIndex
as
GenericZIndex
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
{
AnchorSideKeyword
GenericAnchorFunction
GenericAnchorSide
}
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
{
AspectRatio
as
GenericAspectRatio
GenericInset
}
;
pub
use
crate
:
:
values
:
:
specified
:
:
position
:
:
{
AnchorName
AnchorScope
DashedIdentAndOrTryTactic
PositionAnchor
PositionArea
PositionAreaAxis
PositionAreaKeyword
PositionAreaType
PositionTryFallbacks
PositionTryOrder
PositionVisibility
}
;
pub
use
crate
:
:
values
:
:
specified
:
:
position
:
:
{
GridAutoFlow
GridTemplateAreas
MasonryAutoFlow
}
;
use
crate
:
:
Zero
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
pub
type
Position
=
GenericPosition
<
HorizontalPosition
VerticalPosition
>
;
pub
type
PositionOrAuto
=
GenericPositionOrAuto
<
Position
>
;
pub
type
HorizontalPosition
=
LengthPercentage
;
pub
type
VerticalPosition
=
LengthPercentage
;
pub
type
AnchorSide
=
GenericAnchorSide
<
Percentage
>
;
impl
AnchorSide
{
pub
fn
keyword_and_percentage
(
&
self
)
-
>
(
AnchorSideKeyword
Percentage
)
{
match
self
{
Self
:
:
Percentage
(
p
)
=
>
(
AnchorSideKeyword
:
:
Start
*
p
)
Self
:
:
Keyword
(
k
)
=
>
{
if
matches
!
(
k
AnchorSideKeyword
:
:
Center
)
{
(
AnchorSideKeyword
:
:
Start
Percentage
(
0
.
5
)
)
}
else
{
(
*
k
Percentage
:
:
zero
(
)
)
}
}
}
}
}
pub
type
AnchorFunction
=
GenericAnchorFunction
<
Percentage
Inset
>
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
{
gecko_bindings
:
:
structs
:
:
AnchorPosOffsetResolutionParams
logical_geometry
:
:
PhysicalSide
values
:
:
{
computed
:
:
Length
DashedIdent
}
}
;
impl
AnchorFunction
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
resolve
(
anchor_name
:
&
DashedIdent
anchor_side
:
&
AnchorSide
prop_side
:
PhysicalSide
params
:
&
AnchorPosOffsetResolutionParams
)
-
>
Result
<
Length
(
)
>
{
use
crate
:
:
gecko_bindings
:
:
structs
:
:
Gecko_GetAnchorPosOffset
;
let
(
keyword
percentage
)
=
anchor_side
.
keyword_and_percentage
(
)
;
let
mut
offset
=
Length
:
:
zero
(
)
;
let
valid
=
unsafe
{
Gecko_GetAnchorPosOffset
(
params
anchor_name
.
0
.
as_ptr
(
)
prop_side
as
u8
keyword
as
u8
percentage
.
0
&
mut
offset
)
}
;
if
!
valid
{
return
Err
(
(
)
)
;
}
Ok
(
offset
)
}
}
pub
type
Inset
=
GenericInset
<
Percentage
LengthPercentage
>
;
impl
Position
{
#
[
inline
]
pub
fn
center
(
)
-
>
Self
{
Self
:
:
new
(
LengthPercentage
:
:
new_percent
(
Percentage
(
0
.
5
)
)
LengthPercentage
:
:
new_percent
(
Percentage
(
0
.
5
)
)
)
}
#
[
inline
]
pub
fn
zero
(
)
-
>
Self
{
Self
:
:
new
(
LengthPercentage
:
:
zero
(
)
LengthPercentage
:
:
zero
(
)
)
}
}
impl
ToCss
for
Position
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
horizontal
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
self
.
vertical
.
to_css
(
dest
)
}
}
impl
GenericPositionComponent
for
LengthPercentage
{
fn
is_center
(
&
self
)
-
>
bool
{
match
self
.
to_percentage
(
)
{
Some
(
Percentage
(
per
)
)
=
>
per
=
=
0
.
5
_
=
>
false
}
}
}
#
[
inline
]
fn
block_or_inline_to_inferred
(
keyword
:
PositionAreaKeyword
)
-
>
PositionAreaKeyword
{
if
matches
!
(
keyword
.
axis
(
)
PositionAreaAxis
:
:
Block
|
PositionAreaAxis
:
:
Inline
)
{
keyword
.
with_axis
(
PositionAreaAxis
:
:
Inferred
)
}
else
{
keyword
}
}
#
[
inline
]
fn
inferred_to_block
(
keyword
:
PositionAreaKeyword
)
-
>
PositionAreaKeyword
{
keyword
.
with_inferred_axis
(
PositionAreaAxis
:
:
Block
)
}
#
[
inline
]
fn
inferred_to_inline
(
keyword
:
PositionAreaKeyword
)
-
>
PositionAreaKeyword
{
keyword
.
with_inferred_axis
(
PositionAreaAxis
:
:
Inline
)
}
impl
ToComputedValue
for
PositionArea
{
type
ComputedValue
=
Self
;
fn
to_computed_value
(
&
self
_context
:
&
Context
)
-
>
Self
{
let
mut
computed
=
self
.
clone
(
)
;
let
pair_type
=
self
.
get_type
(
)
;
if
pair_type
=
=
PositionAreaType
:
:
Logical
|
|
pair_type
=
=
PositionAreaType
:
:
SelfLogical
{
if
computed
.
second
!
=
PositionAreaKeyword
:
:
None
{
computed
.
first
=
block_or_inline_to_inferred
(
computed
.
first
)
;
computed
.
second
=
block_or_inline_to_inferred
(
computed
.
second
)
;
}
}
else
if
pair_type
=
=
PositionAreaType
:
:
Inferred
|
|
pair_type
=
=
PositionAreaType
:
:
SelfInferred
{
if
computed
.
second
=
=
PositionAreaKeyword
:
:
SpanAll
{
computed
.
first
=
inferred_to_block
(
computed
.
first
)
;
computed
.
second
=
PositionAreaKeyword
:
:
None
;
}
else
if
computed
.
first
=
=
PositionAreaKeyword
:
:
SpanAll
{
computed
.
first
=
computed
.
second
;
computed
.
first
=
inferred_to_inline
(
computed
.
first
)
;
computed
.
second
=
PositionAreaKeyword
:
:
None
;
}
}
if
computed
.
first
=
=
computed
.
second
{
computed
.
second
=
PositionAreaKeyword
:
:
None
;
}
computed
}
fn
from_computed_value
(
computed
:
&
Self
)
-
>
Self
{
computed
.
clone
(
)
}
}
pub
type
ZIndex
=
GenericZIndex
<
Integer
>
;
pub
type
AspectRatio
=
GenericAspectRatio
<
NonNegativeNumber
>
;
