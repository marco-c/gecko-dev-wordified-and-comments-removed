use
crate
:
:
values
:
:
computed
:
:
{
Integer
LengthPercentage
NonNegativeNumber
Percentage
}
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
{
AnchorSideKeyword
GenericAnchorFunction
GenericAnchorSide
}
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
Position
as
GenericPosition
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
PositionComponent
as
GenericPositionComponent
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
PositionOrAuto
as
GenericPositionOrAuto
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
ZIndex
as
GenericZIndex
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
{
AspectRatio
as
GenericAspectRatio
GenericInset
}
;
pub
use
crate
:
:
values
:
:
specified
:
:
position
:
:
{
AnchorName
AnchorScope
DashedIdentAndOrTryTactic
PositionAnchor
PositionArea
PositionAreaKeyword
PositionTryFallbacks
PositionTryOrder
PositionVisibility
}
;
pub
use
crate
:
:
values
:
:
specified
:
:
position
:
:
{
GridAutoFlow
GridTemplateAreas
MasonryAutoFlow
}
;
use
crate
:
:
Zero
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
pub
type
Position
=
GenericPosition
<
HorizontalPosition
VerticalPosition
>
;
pub
type
PositionOrAuto
=
GenericPositionOrAuto
<
Position
>
;
pub
type
HorizontalPosition
=
LengthPercentage
;
pub
type
VerticalPosition
=
LengthPercentage
;
pub
type
AnchorSide
=
GenericAnchorSide
<
Percentage
>
;
impl
AnchorSide
{
pub
fn
keyword_and_percentage
(
&
self
)
-
>
(
AnchorSideKeyword
Percentage
)
{
match
self
{
Self
:
:
Percentage
(
p
)
=
>
(
AnchorSideKeyword
:
:
Start
*
p
)
Self
:
:
Keyword
(
k
)
=
>
if
matches
!
(
k
AnchorSideKeyword
:
:
Center
)
{
(
AnchorSideKeyword
:
:
Start
Percentage
(
0
.
5
)
)
}
else
{
(
*
k
Percentage
:
:
hundred
(
)
)
}
}
}
}
pub
type
AnchorFunction
=
GenericAnchorFunction
<
Percentage
LengthPercentage
>
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
{
gecko_bindings
:
:
structs
:
:
AnchorPosResolutionParams
logical_geometry
:
:
PhysicalSide
values
:
:
{
DashedIdent
computed
:
:
Length
}
}
;
impl
AnchorFunction
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
resolve
(
anchor_name
:
&
DashedIdent
anchor_side
:
&
AnchorSide
prop_side
:
PhysicalSide
params
:
&
AnchorPosResolutionParams
)
-
>
Result
<
Length
(
)
>
{
use
crate
:
:
gecko_bindings
:
:
structs
:
:
Gecko_GetAnchorPosOffset
;
let
(
keyword
percentage
)
=
anchor_side
.
keyword_and_percentage
(
)
;
let
mut
offset
=
Length
:
:
zero
(
)
;
let
valid
=
unsafe
{
Gecko_GetAnchorPosOffset
(
params
anchor_name
.
0
.
as_ptr
(
)
prop_side
as
u8
keyword
as
u8
percentage
.
0
&
mut
offset
)
}
;
if
!
valid
{
return
Err
(
(
)
)
;
}
Ok
(
offset
)
}
}
pub
type
Inset
=
GenericInset
<
Percentage
LengthPercentage
>
;
impl
Position
{
#
[
inline
]
pub
fn
center
(
)
-
>
Self
{
Self
:
:
new
(
LengthPercentage
:
:
new_percent
(
Percentage
(
0
.
5
)
)
LengthPercentage
:
:
new_percent
(
Percentage
(
0
.
5
)
)
)
}
#
[
inline
]
pub
fn
zero
(
)
-
>
Self
{
Self
:
:
new
(
LengthPercentage
:
:
zero
(
)
LengthPercentage
:
:
zero
(
)
)
}
}
impl
ToCss
for
Position
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
horizontal
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
self
.
vertical
.
to_css
(
dest
)
}
}
impl
GenericPositionComponent
for
LengthPercentage
{
fn
is_center
(
&
self
)
-
>
bool
{
match
self
.
to_percentage
(
)
{
Some
(
Percentage
(
per
)
)
=
>
per
=
=
0
.
5
_
=
>
false
}
}
}
pub
type
ZIndex
=
GenericZIndex
<
Integer
>
;
pub
type
AspectRatio
=
GenericAspectRatio
<
NonNegativeNumber
>
;
