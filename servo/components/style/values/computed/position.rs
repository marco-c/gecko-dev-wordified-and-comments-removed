use
crate
:
:
values
:
:
computed
:
:
{
Integer
LengthPercentage
NonNegativeNumber
Percentage
}
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
AspectRatio
as
GenericAspectRatio
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
Position
as
GenericPosition
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
PositionComponent
as
GenericPositionComponent
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
PositionOrAuto
as
GenericPositionOrAuto
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
Ratio
as
GenericRatio
;
use
crate
:
:
values
:
:
generics
:
:
position
:
:
ZIndex
as
GenericZIndex
;
pub
use
crate
:
:
values
:
:
specified
:
:
position
:
:
{
GridAutoFlow
GridTemplateAreas
MasonryAutoFlow
}
;
use
crate
:
:
{
One
Zero
}
;
use
std
:
:
cmp
:
:
{
Ordering
PartialOrd
}
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
pub
type
Position
=
GenericPosition
<
HorizontalPosition
VerticalPosition
>
;
pub
type
PositionOrAuto
=
GenericPositionOrAuto
<
Position
>
;
pub
type
HorizontalPosition
=
LengthPercentage
;
pub
type
VerticalPosition
=
LengthPercentage
;
impl
Position
{
#
[
inline
]
pub
fn
center
(
)
-
>
Self
{
Self
:
:
new
(
LengthPercentage
:
:
new_percent
(
Percentage
(
0
.
5
)
)
LengthPercentage
:
:
new_percent
(
Percentage
(
0
.
5
)
)
)
}
#
[
inline
]
pub
fn
zero
(
)
-
>
Self
{
Self
:
:
new
(
LengthPercentage
:
:
zero
(
)
LengthPercentage
:
:
zero
(
)
)
}
}
impl
ToCss
for
Position
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
horizontal
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
self
.
vertical
.
to_css
(
dest
)
}
}
impl
GenericPositionComponent
for
LengthPercentage
{
fn
is_center
(
&
self
)
-
>
bool
{
match
self
.
to_percentage
(
)
{
Some
(
Percentage
(
per
)
)
=
>
per
=
=
0
.
5
_
=
>
false
}
}
}
pub
type
ZIndex
=
GenericZIndex
<
Integer
>
;
pub
type
Ratio
=
GenericRatio
<
NonNegativeNumber
>
;
impl
PartialOrd
for
Ratio
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
f64
:
:
partial_cmp
(
&
(
(
self
.
0
)
.
0
as
f64
*
(
other
.
1
)
.
0
as
f64
)
&
(
(
self
.
1
)
.
0
as
f64
*
(
other
.
0
)
.
0
as
f64
)
)
}
}
impl
Ratio
{
pub
fn
new
(
a
:
f32
b
:
f32
)
-
>
Self
{
GenericRatio
(
a
.
into
(
)
b
.
into
(
)
)
}
pub
fn
used_value
(
self
)
-
>
Self
{
if
self
.
0
.
is_zero
(
)
&
&
self
.
1
.
is_zero
(
)
{
Ratio
:
:
new
(
One
:
:
one
(
)
Zero
:
:
zero
(
)
)
}
else
{
self
}
}
}
pub
type
AspectRatio
=
GenericAspectRatio
<
NonNegativeNumber
>
;
