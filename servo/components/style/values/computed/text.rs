#
[
cfg
(
feature
=
"
servo
"
)
]
use
crate
:
:
properties
:
:
StyleBuilder
;
use
crate
:
:
values
:
:
computed
:
:
length
:
:
{
Length
LengthPercentage
}
;
use
crate
:
:
values
:
:
computed
:
:
{
Context
NonNegativeLength
NonNegativeNumber
ToComputedValue
}
;
use
crate
:
:
values
:
:
generics
:
:
text
:
:
InitialLetter
as
GenericInitialLetter
;
use
crate
:
:
values
:
:
generics
:
:
text
:
:
LineHeight
as
GenericLineHeight
;
use
crate
:
:
values
:
:
generics
:
:
text
:
:
Spacing
;
use
crate
:
:
values
:
:
specified
:
:
text
:
:
{
self
as
specified
TextOverflowSide
}
;
use
crate
:
:
values
:
:
specified
:
:
text
:
:
{
TextEmphasisFillMode
TextEmphasisShapeKeyword
}
;
use
crate
:
:
values
:
:
{
CSSFloat
CSSInteger
}
;
use
crate
:
:
Zero
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
pub
use
crate
:
:
values
:
:
specified
:
:
TextAlignKeyword
as
TextAlign
;
pub
use
crate
:
:
values
:
:
specified
:
:
{
LineBreak
OverflowWrap
WordBreak
}
;
pub
use
crate
:
:
values
:
:
specified
:
:
{
TextDecorationLine
TextEmphasisPosition
}
;
pub
use
crate
:
:
values
:
:
specified
:
:
{
TextDecorationSkipInk
TextTransform
}
;
pub
type
InitialLetter
=
GenericInitialLetter
<
CSSFloat
CSSInteger
>
;
#
[
repr
(
transparent
)
]
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
ToAnimatedValue
ToAnimatedZero
ToResolvedValue
)
]
pub
struct
LetterSpacing
(
pub
Length
)
;
impl
LetterSpacing
{
#
[
inline
]
pub
fn
normal
(
)
-
>
Self
{
LetterSpacing
(
Length
:
:
zero
(
)
)
}
}
impl
ToCss
for
LetterSpacing
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
self
.
0
.
is_zero
(
)
{
return
dest
.
write_str
(
"
normal
"
)
;
}
self
.
0
.
to_css
(
dest
)
}
}
impl
ToComputedValue
for
specified
:
:
LetterSpacing
{
type
ComputedValue
=
LetterSpacing
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
match
*
self
{
Spacing
:
:
Normal
=
>
LetterSpacing
(
Length
:
:
zero
(
)
)
Spacing
:
:
Value
(
ref
v
)
=
>
LetterSpacing
(
v
.
to_computed_value
(
context
)
)
}
}
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
if
computed
.
0
.
is_zero
(
)
{
return
Spacing
:
:
Normal
;
}
Spacing
:
:
Value
(
ToComputedValue
:
:
from_computed_value
(
&
computed
.
0
)
)
}
}
pub
type
WordSpacing
=
LengthPercentage
;
impl
ToComputedValue
for
specified
:
:
WordSpacing
{
type
ComputedValue
=
WordSpacing
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
match
*
self
{
Spacing
:
:
Normal
=
>
LengthPercentage
:
:
zero
(
)
Spacing
:
:
Value
(
ref
v
)
=
>
v
.
to_computed_value
(
context
)
}
}
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
Spacing
:
:
Value
(
ToComputedValue
:
:
from_computed_value
(
computed
)
)
}
}
pub
type
LineHeight
=
GenericLineHeight
<
NonNegativeNumber
NonNegativeLength
>
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToResolvedValue
)
]
#
[
repr
(
C
)
]
pub
struct
TextOverflow
{
pub
first
:
TextOverflowSide
pub
second
:
TextOverflowSide
pub
sides_are_logical
:
bool
}
impl
TextOverflow
{
pub
fn
get_initial_value
(
)
-
>
TextOverflow
{
TextOverflow
{
first
:
TextOverflowSide
:
:
Clip
second
:
TextOverflowSide
:
:
Clip
sides_are_logical
:
true
}
}
}
impl
ToCss
for
TextOverflow
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
self
.
sides_are_logical
{
debug_assert_eq
!
(
self
.
first
TextOverflowSide
:
:
Clip
)
;
self
.
second
.
to_css
(
dest
)
?
;
}
else
{
self
.
first
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
self
.
second
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Copy
Debug
Default
MallocSizeOf
PartialEq
ToResolvedValue
)
]
pub
struct
TextDecorationsInEffect
{
pub
underline
:
bool
pub
overline
:
bool
pub
line_through
:
bool
}
impl
TextDecorationsInEffect
{
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
from_style
(
style
:
&
StyleBuilder
)
-
>
Self
{
use
crate
:
:
values
:
:
computed
:
:
Display
;
let
mut
result
=
match
style
.
get_box
(
)
.
clone_display
(
)
{
Display
:
:
InlineBlock
|
Display
:
:
InlineTable
=
>
Self
:
:
default
(
)
_
=
>
style
.
get_parent_inherited_text
(
)
.
text_decorations_in_effect
.
clone
(
)
}
;
let
line
=
style
.
get_text
(
)
.
clone_text_decoration_line
(
)
;
result
.
underline
|
=
line
.
contains
(
TextDecorationLine
:
:
UNDERLINE
)
;
result
.
overline
|
=
line
.
contains
(
TextDecorationLine
:
:
OVERLINE
)
;
result
.
line_through
|
=
line
.
contains
(
TextDecorationLine
:
:
LINE_THROUGH
)
;
result
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToCss
ToResolvedValue
)
]
pub
enum
TextEmphasisStyle
{
Keyword
(
TextEmphasisKeywordValue
)
None
String
(
String
)
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToCss
ToResolvedValue
)
]
pub
struct
TextEmphasisKeywordValue
{
pub
fill
:
TextEmphasisFillMode
pub
shape
:
TextEmphasisShapeKeyword
}
