use
crate
:
:
values
:
:
distance
:
:
{
ComputeSquaredDistance
SquaredDistance
}
;
use
crate
:
:
values
:
:
CSSFloat
;
use
crate
:
:
Zero
;
use
std
:
:
f64
:
:
consts
:
:
PI
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
{
f32
f64
}
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Add
Animate
Clone
Copy
Debug
MallocSizeOf
PartialEq
PartialOrd
ToAnimatedZero
)
]
pub
struct
Angle
(
CSSFloat
)
;
impl
ToCss
for
Angle
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
degrees
(
)
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
deg
"
)
}
}
const
RAD_PER_DEG
:
f64
=
PI
/
180
.
0
;
impl
Angle
{
pub
fn
from_radians
(
radians
:
CSSFloat
)
-
>
Self
{
Angle
(
radians
/
RAD_PER_DEG
as
f32
)
}
#
[
inline
]
pub
fn
from_degrees
(
degrees
:
CSSFloat
)
-
>
Self
{
Angle
(
degrees
)
}
#
[
inline
]
pub
fn
radians
(
&
self
)
-
>
CSSFloat
{
self
.
radians64
(
)
.
min
(
f32
:
:
MAX
as
f64
)
.
max
(
f32
:
:
MIN
as
f64
)
as
f32
}
#
[
inline
]
pub
fn
radians64
(
&
self
)
-
>
f64
{
self
.
0
as
f64
*
RAD_PER_DEG
}
#
[
inline
]
pub
fn
degrees
(
&
self
)
-
>
CSSFloat
{
self
.
0
}
}
impl
Zero
for
Angle
{
#
[
inline
]
fn
zero
(
)
-
>
Self
{
Angle
(
0
.
0
)
}
#
[
inline
]
fn
is_zero
(
&
self
)
-
>
bool
{
self
.
0
=
=
0
.
}
}
impl
ComputeSquaredDistance
for
Angle
{
#
[
inline
]
fn
compute_squared_distance
(
&
self
other
:
&
Self
)
-
>
Result
<
SquaredDistance
(
)
>
{
self
.
radians64
(
)
.
compute_squared_distance
(
&
other
.
radians64
(
)
)
}
}
