use
super
:
:
{
Context
Number
Percentage
ToComputedValue
}
;
use
crate
:
:
values
:
:
animated
:
:
ToAnimatedValue
;
use
crate
:
:
values
:
:
computed
:
:
NonNegativeNumber
;
use
crate
:
:
values
:
:
distance
:
:
{
ComputeSquaredDistance
SquaredDistance
}
;
use
crate
:
:
values
:
:
generics
:
:
length
as
generics
;
use
crate
:
:
values
:
:
generics
:
:
length
:
:
{
GenericLengthOrNumber
GenericLengthPercentageOrNormal
GenericMaxSize
GenericSize
}
;
use
crate
:
:
values
:
:
generics
:
:
NonNegative
;
use
crate
:
:
values
:
:
specified
:
:
length
:
:
ViewportPercentageLength
;
use
crate
:
:
values
:
:
specified
:
:
length
:
:
{
AbsoluteLength
FontBaseSize
FontRelativeLength
}
;
use
crate
:
:
values
:
:
{
specified
CSSFloat
}
;
use
crate
:
:
Zero
;
use
app_units
:
:
Au
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
ops
:
:
{
Add
AddAssign
Div
Mul
Neg
Sub
}
;
use
style_traits
:
:
values
:
:
specified
:
:
AllowedNumericType
;
use
style_traits
:
:
{
CSSPixel
CssWriter
ToCss
}
;
pub
use
super
:
:
image
:
:
Image
;
pub
use
crate
:
:
values
:
:
specified
:
:
url
:
:
UrlOrNone
;
pub
use
crate
:
:
values
:
:
specified
:
:
{
Angle
BorderStyle
Time
}
;
impl
ToComputedValue
for
specified
:
:
NoCalcLength
{
type
ComputedValue
=
Length
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
match
*
self
{
specified
:
:
NoCalcLength
:
:
Absolute
(
length
)
=
>
length
.
to_computed_value
(
context
)
specified
:
:
NoCalcLength
:
:
FontRelative
(
length
)
=
>
{
length
.
to_computed_value
(
context
FontBaseSize
:
:
CurrentStyle
)
}
specified
:
:
NoCalcLength
:
:
ViewportPercentage
(
length
)
=
>
{
length
.
to_computed_value
(
context
.
viewport_size_for_viewport_unit_resolution
(
)
)
}
specified
:
:
NoCalcLength
:
:
ServoCharacterWidth
(
length
)
=
>
{
length
.
to_computed_value
(
context
.
style
(
)
.
get_font
(
)
.
clone_font_size
(
)
.
size
(
)
)
}
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
specified
:
:
NoCalcLength
:
:
Absolute
(
AbsoluteLength
:
:
Px
(
computed
.
px
(
)
)
)
}
}
impl
ToComputedValue
for
specified
:
:
Length
{
type
ComputedValue
=
Length
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
match
*
self
{
specified
:
:
Length
:
:
NoCalc
(
l
)
=
>
l
.
to_computed_value
(
context
)
specified
:
:
Length
:
:
Calc
(
ref
calc
)
=
>
calc
.
to_computed_value
(
context
)
.
length_component
(
)
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
specified
:
:
Length
:
:
NoCalc
(
specified
:
:
NoCalcLength
:
:
from_computed_value
(
computed
)
)
}
}
/
/
/
cbindgen
:
private
-
default
-
tagged
-
enum
-
constructor
=
false
/
/
/
cbindgen
:
derive
-
mut
-
casts
=
true
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Debug
Deserialize
MallocSizeOf
PartialEq
Serialize
ToAnimatedZero
ToResolvedValue
)
]
#
[
repr
(
u8
)
]
pub
enum
LengthPercentage
{
Length
(
Length
)
Percentage
(
Percentage
)
Calc
(
Box
<
CalcLengthPercentage
>
)
}
#
[
derive
(
Clone
Debug
Deserialize
MallocSizeOf
Serialize
ToAnimatedZero
ToResolvedValue
)
]
#
[
repr
(
C
)
]
pub
struct
CalcLengthPercentage
{
length
:
Length
percentage
:
Percentage
#
[
animation
(
constant
)
]
clamping_mode
:
AllowedNumericType
#
[
animation
(
constant
)
]
pub
has_percentage
:
bool
}
impl
PartialEq
for
CalcLengthPercentage
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
length
=
=
other
.
length
&
&
self
.
percentage
=
=
other
.
percentage
&
&
self
.
has_percentage
=
=
other
.
has_percentage
}
}
impl
ComputeSquaredDistance
for
LengthPercentage
{
#
[
inline
]
fn
compute_squared_distance
(
&
self
other
:
&
Self
)
-
>
Result
<
SquaredDistance
(
)
>
{
Ok
(
self
.
unclamped_length
(
)
.
compute_squared_distance
(
&
other
.
unclamped_length
(
)
)
?
+
self
.
percentage
(
)
.
compute_squared_distance
(
&
other
.
percentage
(
)
)
?
)
}
}
impl
ToCss
for
LengthPercentage
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
specified
:
:
LengthPercentage
:
:
from_computed_value
(
self
)
.
to_css
(
dest
)
}
}
impl
specified
:
:
CalcLengthPercentage
{
fn
to_computed_value_with_zoom
<
F
>
(
&
self
context
:
&
Context
zoom_fn
:
F
base_size
:
FontBaseSize
)
-
>
CalcLengthPercentage
where
F
:
Fn
(
Length
)
-
>
Length
{
use
std
:
:
f32
;
let
mut
length
=
0
.
;
if
let
Some
(
absolute
)
=
self
.
absolute
{
length
+
=
zoom_fn
(
absolute
.
to_computed_value
(
context
)
)
.
px
(
)
;
}
for
val
in
&
[
self
.
vw
.
map
(
ViewportPercentageLength
:
:
Vw
)
self
.
vh
.
map
(
ViewportPercentageLength
:
:
Vh
)
self
.
vmin
.
map
(
ViewportPercentageLength
:
:
Vmin
)
self
.
vmax
.
map
(
ViewportPercentageLength
:
:
Vmax
)
]
{
if
let
Some
(
val
)
=
*
val
{
let
viewport_size
=
context
.
viewport_size_for_viewport_unit_resolution
(
)
;
length
+
=
val
.
to_computed_value
(
viewport_size
)
.
px
(
)
;
}
}
for
val
in
&
[
self
.
ch
.
map
(
FontRelativeLength
:
:
Ch
)
self
.
em
.
map
(
FontRelativeLength
:
:
Em
)
self
.
ex
.
map
(
FontRelativeLength
:
:
Ex
)
self
.
rem
.
map
(
FontRelativeLength
:
:
Rem
)
]
{
if
let
Some
(
val
)
=
*
val
{
length
+
=
val
.
to_computed_value
(
context
base_size
)
.
px
(
)
;
}
}
CalcLengthPercentage
:
:
with_clamping_mode
(
Length
:
:
new
(
length
.
min
(
f32
:
:
MAX
)
.
max
(
f32
:
:
MIN
)
)
self
.
percentage
self
.
clamping_mode
)
}
pub
fn
to_computed_value_zoomed
(
&
self
context
:
&
Context
base_size
:
FontBaseSize
)
-
>
CalcLengthPercentage
{
self
.
to_computed_value_with_zoom
(
context
|
abs
|
context
.
maybe_zoom_text
(
abs
.
into
(
)
)
base_size
)
}
pub
fn
to_computed_pixel_length_without_context
(
&
self
)
-
>
Result
<
CSSFloat
(
)
>
{
if
self
.
vw
.
is_some
(
)
|
|
self
.
vh
.
is_some
(
)
|
|
self
.
vmin
.
is_some
(
)
|
|
self
.
vmax
.
is_some
(
)
|
|
self
.
em
.
is_some
(
)
|
|
self
.
ex
.
is_some
(
)
|
|
self
.
ch
.
is_some
(
)
|
|
self
.
rem
.
is_some
(
)
|
|
self
.
percentage
.
is_some
(
)
{
return
Err
(
(
)
)
;
}
match
self
.
absolute
{
Some
(
abs
)
=
>
Ok
(
abs
.
to_px
(
)
)
None
=
>
{
debug_assert
!
(
false
"
Someone
forgot
to
handle
an
unit
here
:
{
:
?
}
"
self
)
;
Err
(
(
)
)
}
}
}
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
CalcLengthPercentage
{
self
.
to_computed_value_with_zoom
(
context
|
abs
|
abs
FontBaseSize
:
:
CurrentStyle
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
CalcLengthPercentage
)
-
>
Self
{
specified
:
:
CalcLengthPercentage
{
clamping_mode
:
computed
.
clamping_mode
absolute
:
Some
(
AbsoluteLength
:
:
from_computed_value
(
&
computed
.
length
)
)
percentage
:
computed
.
specified_percentage
(
)
.
.
Default
:
:
default
(
)
}
}
}
impl
LengthPercentage
{
#
[
inline
]
pub
fn
one
(
)
-
>
Self
{
Self
:
:
Length
(
Length
:
:
new
(
1
.
)
)
}
#
[
inline
]
pub
fn
new_length
(
l
:
Length
)
-
>
Self
{
Self
:
:
Length
(
l
)
}
#
[
inline
]
pub
fn
new_percent
(
p
:
Percentage
)
-
>
Self
{
Self
:
:
Percentage
(
p
)
}
#
[
inline
]
pub
fn
new_calc
(
l
:
Length
percentage
:
Percentage
)
-
>
Self
{
CalcLengthPercentage
:
:
new
(
l
Some
(
percentage
)
)
.
to_length_percentge
(
)
}
#
[
inline
]
pub
fn
is_definitely_zero
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Length
(
l
)
=
>
l
.
px
(
)
=
=
0
.
0
Self
:
:
Percentage
(
p
)
=
>
p
.
0
=
=
0
.
0
Self
:
:
Calc
(
ref
c
)
=
>
c
.
is_definitely_zero
(
)
}
}
#
[
inline
]
pub
fn
unclamped_length
(
&
self
)
-
>
Length
{
match
*
self
{
Self
:
:
Length
(
l
)
=
>
l
Self
:
:
Percentage
(
.
.
)
=
>
Zero
:
:
zero
(
)
Self
:
:
Calc
(
ref
c
)
=
>
c
.
unclamped_length
(
)
}
}
#
[
inline
]
fn
length
(
&
self
)
-
>
Length
{
debug_assert
!
(
!
self
.
has_percentage
(
)
)
;
self
.
length_component
(
)
}
#
[
inline
]
pub
fn
length_component
(
&
self
)
-
>
Length
{
match
*
self
{
Self
:
:
Length
(
l
)
=
>
l
Self
:
:
Percentage
(
.
.
)
=
>
Zero
:
:
zero
(
)
Self
:
:
Calc
(
ref
c
)
=
>
c
.
length_component
(
)
}
}
#
[
inline
]
pub
fn
percentage
(
&
self
)
-
>
CSSFloat
{
match
*
self
{
Self
:
:
Length
(
.
.
)
=
>
0
.
Self
:
:
Percentage
(
p
)
=
>
p
.
0
Self
:
:
Calc
(
ref
c
)
=
>
c
.
percentage
.
0
}
}
#
[
inline
]
pub
fn
as_percentage
(
&
self
)
-
>
Option
<
Percentage
>
{
match
*
self
{
Self
:
:
Length
(
.
.
)
=
>
None
Self
:
:
Percentage
(
p
)
=
>
Some
(
p
)
Self
:
:
Calc
(
ref
c
)
=
>
c
.
as_percentage
(
)
}
}
#
[
inline
]
pub
fn
resolve
(
&
self
basis
:
Length
)
-
>
Length
{
match
*
self
{
Self
:
:
Length
(
l
)
=
>
l
Self
:
:
Percentage
(
p
)
=
>
Length
:
:
new
(
basis
.
0
*
p
.
0
)
Self
:
:
Calc
(
ref
c
)
=
>
c
.
resolve
(
basis
)
}
}
#
[
inline
]
pub
fn
percentage_relative_to
(
&
self
basis
:
Length
)
-
>
Length
{
self
.
resolve
(
basis
)
}
#
[
inline
]
pub
fn
has_percentage
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Length
(
.
.
)
=
>
false
Self
:
:
Percentage
(
.
.
)
=
>
true
Self
:
:
Calc
(
ref
c
)
=
>
c
.
has_percentage
}
}
#
[
inline
]
pub
fn
specified_percentage
(
&
self
)
-
>
Option
<
Percentage
>
{
match
*
self
{
Self
:
:
Length
(
.
.
)
=
>
None
Self
:
:
Percentage
(
p
)
=
>
Some
(
p
)
Self
:
:
Calc
(
ref
c
)
=
>
c
.
specified_percentage
(
)
}
}
#
[
inline
]
pub
fn
to_used_value
(
&
self
containing_length
:
Au
)
-
>
Au
{
Au
:
:
from
(
self
.
to_pixel_length
(
containing_length
)
)
}
#
[
inline
]
pub
fn
to_pixel_length
(
&
self
containing_length
:
Au
)
-
>
Length
{
self
.
resolve
(
containing_length
.
into
(
)
)
}
#
[
inline
]
fn
maybe_to_used_value
(
&
self
container_len
:
Option
<
Length
>
)
-
>
Option
<
Au
>
{
self
.
maybe_percentage_relative_to
(
container_len
)
.
map
(
Au
:
:
from
)
}
pub
fn
maybe_percentage_relative_to
(
&
self
container_len
:
Option
<
Length
>
)
-
>
Option
<
Length
>
{
if
self
.
has_percentage
(
)
{
return
Some
(
self
.
resolve
(
container_len
?
)
)
;
}
Some
(
self
.
length
(
)
)
}
#
[
inline
]
pub
fn
clamp_to_non_negative
(
self
)
-
>
Self
{
match
self
{
Self
:
:
Length
(
l
)
=
>
Self
:
:
Length
(
l
.
clamp_to_non_negative
(
)
)
Self
:
:
Percentage
(
p
)
=
>
Self
:
:
Percentage
(
p
.
clamp_to_non_negative
(
)
)
Self
:
:
Calc
(
c
)
=
>
c
.
clamp_to_non_negative
(
)
.
to_length_percentge
(
)
}
}
}
impl
CalcLengthPercentage
{
#
[
inline
]
pub
fn
new
(
length
:
Length
percentage
:
Option
<
Percentage
>
)
-
>
Self
{
Self
:
:
with_clamping_mode
(
length
percentage
AllowedNumericType
:
:
All
)
}
#
[
inline
]
pub
fn
to_length_percentge
(
self
)
-
>
LengthPercentage
{
if
!
self
.
has_percentage
{
return
LengthPercentage
:
:
Length
(
self
.
length_component
(
)
)
}
if
self
.
length
.
is_zero
(
)
{
return
LengthPercentage
:
:
Percentage
(
Percentage
(
self
.
clamping_mode
.
clamp
(
self
.
percentage
.
0
)
)
)
;
}
LengthPercentage
:
:
Calc
(
Box
:
:
new
(
self
)
)
}
fn
specified_percentage
(
&
self
)
-
>
Option
<
Percentage
>
{
if
self
.
has_percentage
{
Some
(
self
.
percentage
)
}
else
{
None
}
}
#
[
inline
]
fn
with_clamping_mode
(
length
:
Length
percentage
:
Option
<
Percentage
>
clamping_mode
:
AllowedNumericType
)
-
>
Self
{
Self
{
clamping_mode
length
percentage
:
percentage
.
unwrap_or_default
(
)
has_percentage
:
percentage
.
is_some
(
)
}
}
#
[
inline
]
fn
length_component
(
&
self
)
-
>
CSSPixelLength
{
Length
:
:
new
(
self
.
clamping_mode
.
clamp
(
self
.
length
.
px
(
)
)
)
}
fn
as_percentage
(
&
self
)
-
>
Option
<
Percentage
>
{
if
!
self
.
has_percentage
|
|
self
.
length
.
px
(
)
!
=
0
.
{
return
None
;
}
Some
(
Percentage
(
self
.
clamping_mode
.
clamp
(
self
.
percentage
.
0
)
)
)
}
#
[
inline
]
pub
fn
resolve
(
&
self
basis
:
Length
)
-
>
Length
{
let
length
=
self
.
length
.
0
+
basis
.
0
*
self
.
percentage
.
0
;
Length
:
:
new
(
self
.
clamping_mode
.
clamp
(
length
)
)
}
#
[
inline
]
pub
fn
percentage_relative_to
(
&
self
basis
:
Length
)
-
>
Length
{
self
.
resolve
(
basis
)
}
#
[
inline
]
pub
fn
unclamped_length
(
&
self
)
-
>
Length
{
self
.
length
}
#
[
inline
]
fn
is_definitely_zero
(
&
self
)
-
>
bool
{
self
.
length
.
px
(
)
=
=
0
.
0
&
&
self
.
percentage
.
0
=
=
0
.
0
}
#
[
inline
]
fn
clamp_to_non_negative
(
self
)
-
>
Self
{
if
self
.
has_percentage
{
if
self
.
length
.
is_zero
(
)
{
return
Self
:
:
with_clamping_mode
(
Length
:
:
zero
(
)
Some
(
self
.
percentage
.
clamp_to_non_negative
(
)
)
AllowedNumericType
:
:
NonNegative
)
;
}
return
Self
:
:
with_clamping_mode
(
self
.
length
Some
(
self
.
percentage
)
AllowedNumericType
:
:
NonNegative
)
;
}
Self
:
:
with_clamping_mode
(
self
.
length
.
clamp_to_non_negative
(
)
None
AllowedNumericType
:
:
NonNegative
)
}
}
impl
ToComputedValue
for
specified
:
:
LengthPercentage
{
type
ComputedValue
=
LengthPercentage
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
LengthPercentage
{
match
*
self
{
specified
:
:
LengthPercentage
:
:
Length
(
ref
value
)
=
>
{
LengthPercentage
:
:
Length
(
value
.
to_computed_value
(
context
)
)
}
specified
:
:
LengthPercentage
:
:
Percentage
(
value
)
=
>
{
LengthPercentage
:
:
Percentage
(
value
)
}
specified
:
:
LengthPercentage
:
:
Calc
(
ref
calc
)
=
>
{
(
*
*
calc
)
.
to_computed_value
(
context
)
.
to_length_percentge
(
)
}
}
}
fn
from_computed_value
(
computed
:
&
LengthPercentage
)
-
>
Self
{
match
*
computed
{
LengthPercentage
:
:
Length
(
ref
l
)
=
>
{
specified
:
:
LengthPercentage
:
:
Length
(
ToComputedValue
:
:
from_computed_value
(
l
)
)
}
LengthPercentage
:
:
Percentage
(
p
)
=
>
{
specified
:
:
LengthPercentage
:
:
Percentage
(
p
)
}
LengthPercentage
:
:
Calc
(
ref
c
)
=
>
{
if
let
Some
(
p
)
=
c
.
as_percentage
(
)
{
return
specified
:
:
LengthPercentage
:
:
Percentage
(
p
)
}
if
!
c
.
has_percentage
{
return
specified
:
:
LengthPercentage
:
:
Length
(
ToComputedValue
:
:
from_computed_value
(
&
c
.
length_component
(
)
)
)
}
specified
:
:
LengthPercentage
:
:
Calc
(
Box
:
:
new
(
specified
:
:
CalcLengthPercentage
:
:
from_computed_value
(
c
)
)
)
}
}
}
}
impl
Zero
for
LengthPercentage
{
fn
zero
(
)
-
>
Self
{
LengthPercentage
:
:
Length
(
Length
:
:
zero
(
)
)
}
#
[
inline
]
fn
is_zero
(
&
self
)
-
>
bool
{
self
.
is_definitely_zero
(
)
}
}
macro_rules
!
computed_length_percentage_or_auto
{
(
inner
:
ty
)
=
>
{
/
/
/
Returns
the
used
value
.
#
[
inline
]
pub
fn
to_used_value
(
&
self
percentage_basis
:
Au
)
-
>
Option
<
Au
>
{
match
*
self
{
generics
:
:
GenericLengthPercentageOrAuto
:
:
Auto
=
>
None
generics
:
:
GenericLengthPercentageOrAuto
:
:
LengthPercentage
(
ref
lp
)
=
>
{
Some
(
lp
.
to_used_value
(
percentage_basis
)
)
}
}
}
/
/
/
Returns
true
if
the
computed
value
is
absolute
0
or
0
%
.
#
[
inline
]
pub
fn
is_definitely_zero
(
&
self
)
-
>
bool
{
use
values
:
:
generics
:
:
length
:
:
LengthPercentageOrAuto
:
:
*
;
match
*
self
{
LengthPercentage
(
ref
l
)
=
>
l
.
is_definitely_zero
(
)
Auto
=
>
false
}
}
}
}
pub
type
LengthPercentageOrAuto
=
generics
:
:
GenericLengthPercentageOrAuto
<
LengthPercentage
>
;
impl
LengthPercentageOrAuto
{
pub
fn
clamp_to_non_negative
(
self
)
-
>
Self
{
use
values
:
:
generics
:
:
length
:
:
LengthPercentageOrAuto
:
:
*
;
match
self
{
LengthPercentage
(
l
)
=
>
LengthPercentage
(
l
.
clamp_to_non_negative
(
)
)
Auto
=
>
Auto
}
}
computed_length_percentage_or_auto
!
(
LengthPercentage
)
;
#
[
inline
]
pub
fn
percentage_relative_to
(
&
self
basis
:
Length
)
-
>
LengthOrAuto
{
use
values
:
:
generics
:
:
length
:
:
LengthPercentageOrAuto
:
:
*
;
match
self
{
LengthPercentage
(
length_percentage
)
=
>
{
LengthPercentage
(
length_percentage
.
percentage_relative_to
(
basis
)
)
}
Auto
=
>
Auto
}
}
#
[
inline
]
pub
fn
maybe_percentage_relative_to
(
&
self
basis
:
Option
<
Length
>
)
-
>
LengthOrAuto
{
use
values
:
:
generics
:
:
length
:
:
LengthPercentageOrAuto
:
:
*
;
match
self
{
LengthPercentage
(
length_percentage
)
=
>
length_percentage
.
maybe_percentage_relative_to
(
basis
)
.
map_or
(
Auto
LengthPercentage
)
Auto
=
>
Auto
}
}
}
pub
type
NonNegativeLengthPercentageOrAuto
=
generics
:
:
GenericLengthPercentageOrAuto
<
NonNegativeLengthPercentage
>
;
impl
NonNegativeLengthPercentageOrAuto
{
computed_length_percentage_or_auto
!
(
NonNegativeLengthPercentage
)
;
}
pub
type
NonNegativeLengthPercentage
=
NonNegative
<
LengthPercentage
>
;
impl
ToAnimatedValue
for
NonNegativeLengthPercentage
{
type
AnimatedValue
=
LengthPercentage
;
#
[
inline
]
fn
to_animated_value
(
self
)
-
>
Self
:
:
AnimatedValue
{
self
.
0
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
NonNegative
(
animated
.
clamp_to_non_negative
(
)
)
}
}
impl
From
<
NonNegativeLength
>
for
NonNegativeLengthPercentage
{
#
[
inline
]
fn
from
(
length
:
NonNegativeLength
)
-
>
Self
{
NonNegative
(
LengthPercentage
:
:
new_length
(
length
.
0
)
)
}
}
impl
From
<
LengthPercentage
>
for
NonNegativeLengthPercentage
{
#
[
inline
]
fn
from
(
lp
:
LengthPercentage
)
-
>
Self
{
NonNegative
(
lp
)
}
}
impl
From
<
Au
>
for
LengthPercentage
{
#
[
inline
]
fn
from
(
length
:
Au
)
-
>
Self
{
LengthPercentage
:
:
new_length
(
length
.
into
(
)
)
}
}
impl
NonNegativeLengthPercentage
{
#
[
inline
]
pub
fn
is_definitely_zero
(
&
self
)
-
>
bool
{
self
.
0
.
is_definitely_zero
(
)
}
#
[
inline
]
pub
fn
to_used_value
(
&
self
containing_length
:
Au
)
-
>
Au
{
let
resolved
=
self
.
0
.
to_used_value
(
containing_length
)
;
std
:
:
cmp
:
:
max
(
resolved
Au
(
0
)
)
}
#
[
inline
]
pub
fn
maybe_to_used_value
(
&
self
containing_length
:
Option
<
Au
>
)
-
>
Option
<
Au
>
{
let
resolved
=
self
.
0
.
maybe_to_used_value
(
containing_length
.
map
(
|
v
|
v
.
into
(
)
)
)
?
;
Some
(
std
:
:
cmp
:
:
max
(
resolved
Au
(
0
)
)
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
MaxSize
{
#
[
inline
]
pub
fn
to_used_value
(
&
self
percentage_basis
:
Au
)
-
>
Option
<
Au
>
{
match
*
self
{
GenericMaxSize
:
:
None
=
>
None
GenericMaxSize
:
:
LengthPercentage
(
ref
lp
)
=
>
Some
(
lp
.
to_used_value
(
percentage_basis
)
)
}
}
}
impl
Size
{
#
[
inline
]
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
to_used_value
(
&
self
percentage_basis
:
Au
)
-
>
Option
<
Au
>
{
match
*
self
{
GenericSize
:
:
Auto
=
>
None
GenericSize
:
:
LengthPercentage
(
ref
lp
)
=
>
Some
(
lp
.
to_used_value
(
percentage_basis
)
)
}
}
#
[
inline
]
pub
fn
is_definitely_zero
(
&
self
)
-
>
bool
{
match
*
self
{
GenericSize
:
:
Auto
=
>
false
GenericSize
:
:
LengthPercentage
(
ref
lp
)
=
>
lp
.
is_definitely_zero
(
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
GenericSize
:
:
ExtremumLength
(
.
.
)
=
>
false
}
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
Deserialize
MallocSizeOf
PartialEq
PartialOrd
Serialize
ToAnimatedValue
ToAnimatedZero
ToResolvedValue
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
CSSPixelLength
(
CSSFloat
)
;
impl
fmt
:
:
Debug
for
CSSPixelLength
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
0
.
fmt
(
f
)
?
;
f
.
write_str
(
"
px
"
)
}
}
impl
CSSPixelLength
{
#
[
inline
]
pub
fn
new
(
px
:
CSSFloat
)
-
>
Self
{
CSSPixelLength
(
px
)
}
#
[
inline
]
pub
fn
px
(
self
)
-
>
CSSFloat
{
self
.
0
}
#
[
inline
]
pub
fn
to_i32_au
(
self
)
-
>
i32
{
Au
:
:
from
(
self
)
.
0
}
#
[
inline
]
pub
fn
abs
(
self
)
-
>
Self
{
CSSPixelLength
:
:
new
(
self
.
0
.
abs
(
)
)
}
#
[
inline
]
pub
fn
clamp_to_non_negative
(
self
)
-
>
Self
{
CSSPixelLength
:
:
new
(
self
.
0
.
max
(
0
.
)
)
}
#
[
inline
]
pub
fn
min
(
self
other
:
Self
)
-
>
Self
{
CSSPixelLength
:
:
new
(
self
.
0
.
min
(
other
.
0
)
)
}
#
[
inline
]
pub
fn
max
(
self
other
:
Self
)
-
>
Self
{
CSSPixelLength
:
:
new
(
self
.
0
.
max
(
other
.
0
)
)
}
#
[
inline
]
pub
fn
max_assign
(
&
mut
self
other
:
Self
)
{
*
self
=
self
.
max
(
other
)
;
}
#
[
inline
]
pub
fn
clamp_between_extremums
(
self
min_size
:
Self
max_size
:
Option
<
Self
>
)
-
>
Self
{
self
.
clamp_below_max
(
max_size
)
.
max
(
min_size
)
}
#
[
inline
]
pub
fn
clamp_below_max
(
self
max_size
:
Option
<
Self
>
)
-
>
Self
{
match
max_size
{
None
=
>
self
Some
(
max_size
)
=
>
self
.
min
(
max_size
)
}
}
}
impl
Zero
for
CSSPixelLength
{
fn
zero
(
)
-
>
Self
{
CSSPixelLength
:
:
new
(
0
.
)
}
fn
is_zero
(
&
self
)
-
>
bool
{
self
.
px
(
)
=
=
0
.
}
}
impl
ToCss
for
CSSPixelLength
{
#
[
inline
]
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
0
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
px
"
)
}
}
impl
Add
for
CSSPixelLength
{
type
Output
=
Self
;
#
[
inline
]
fn
add
(
self
other
:
Self
)
-
>
Self
{
Self
:
:
new
(
self
.
px
(
)
+
other
.
px
(
)
)
}
}
impl
AddAssign
for
CSSPixelLength
{
#
[
inline
]
fn
add_assign
(
&
mut
self
other
:
Self
)
{
self
.
0
+
=
other
.
0
;
}
}
impl
Div
<
CSSFloat
>
for
CSSPixelLength
{
type
Output
=
Self
;
#
[
inline
]
fn
div
(
self
other
:
CSSFloat
)
-
>
Self
{
Self
:
:
new
(
self
.
px
(
)
/
other
)
}
}
impl
Mul
<
CSSFloat
>
for
CSSPixelLength
{
type
Output
=
Self
;
#
[
inline
]
fn
mul
(
self
other
:
CSSFloat
)
-
>
Self
{
Self
:
:
new
(
self
.
px
(
)
*
other
)
}
}
impl
Neg
for
CSSPixelLength
{
type
Output
=
Self
;
#
[
inline
]
fn
neg
(
self
)
-
>
Self
{
CSSPixelLength
:
:
new
(
-
self
.
0
)
}
}
impl
Sub
for
CSSPixelLength
{
type
Output
=
Self
;
#
[
inline
]
fn
sub
(
self
other
:
Self
)
-
>
Self
{
Self
:
:
new
(
self
.
px
(
)
-
other
.
px
(
)
)
}
}
impl
From
<
CSSPixelLength
>
for
Au
{
#
[
inline
]
fn
from
(
len
:
CSSPixelLength
)
-
>
Self
{
Au
:
:
from_f32_px
(
len
.
0
)
}
}
impl
From
<
Au
>
for
CSSPixelLength
{
#
[
inline
]
fn
from
(
len
:
Au
)
-
>
Self
{
CSSPixelLength
:
:
new
(
len
.
to_f32_px
(
)
)
}
}
impl
From
<
CSSPixelLength
>
for
euclid
:
:
Length
<
CSSFloat
CSSPixel
>
{
#
[
inline
]
fn
from
(
length
:
CSSPixelLength
)
-
>
Self
{
Self
:
:
new
(
length
.
0
)
}
}
pub
type
Length
=
CSSPixelLength
;
pub
type
LengthOrAuto
=
generics
:
:
GenericLengthPercentageOrAuto
<
Length
>
;
pub
type
NonNegativeLengthOrAuto
=
generics
:
:
GenericLengthPercentageOrAuto
<
NonNegativeLength
>
;
pub
type
LengthOrNumber
=
GenericLengthOrNumber
<
Length
Number
>
;
pub
type
NonNegativeLength
=
NonNegative
<
Length
>
;
impl
ToAnimatedValue
for
NonNegativeLength
{
type
AnimatedValue
=
Length
;
#
[
inline
]
fn
to_animated_value
(
self
)
-
>
Self
:
:
AnimatedValue
{
self
.
0
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
NonNegativeLength
:
:
new
(
animated
.
px
(
)
.
max
(
0
.
)
)
}
}
impl
NonNegativeLength
{
#
[
inline
]
pub
fn
new
(
px
:
CSSFloat
)
-
>
Self
{
NonNegative
(
Length
:
:
new
(
px
.
max
(
0
.
)
)
)
}
#
[
inline
]
pub
fn
px
(
&
self
)
-
>
CSSFloat
{
self
.
0
.
px
(
)
}
#
[
inline
]
pub
fn
clamp
(
self
)
-
>
Self
{
if
(
self
.
0
)
.
0
<
0
.
{
Self
:
:
zero
(
)
}
else
{
self
}
}
}
impl
From
<
Length
>
for
NonNegativeLength
{
#
[
inline
]
fn
from
(
len
:
Length
)
-
>
Self
{
NonNegative
(
len
)
}
}
impl
From
<
Au
>
for
NonNegativeLength
{
#
[
inline
]
fn
from
(
au
:
Au
)
-
>
Self
{
NonNegative
(
au
.
into
(
)
)
}
}
impl
From
<
NonNegativeLength
>
for
Au
{
#
[
inline
]
fn
from
(
non_negative_len
:
NonNegativeLength
)
-
>
Self
{
Au
:
:
from
(
non_negative_len
.
0
)
}
}
pub
type
NonNegativeLengthPercentageOrNormal
=
GenericLengthPercentageOrNormal
<
NonNegativeLengthPercentage
>
;
pub
type
NonNegativeLengthOrNumber
=
GenericLengthOrNumber
<
NonNegativeLength
NonNegativeNumber
>
;
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
FromPrimitive
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToCss
ToResolvedValue
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ExtremumLength
{
#
[
parse
(
aliases
=
"
-
moz
-
max
-
content
"
)
]
MaxContent
#
[
parse
(
aliases
=
"
-
moz
-
min
-
content
"
)
]
MinContent
MozFitContent
MozAvailable
}
pub
type
Size
=
GenericSize
<
NonNegativeLengthPercentage
>
;
pub
type
MaxSize
=
GenericMaxSize
<
NonNegativeLengthPercentage
>
;
