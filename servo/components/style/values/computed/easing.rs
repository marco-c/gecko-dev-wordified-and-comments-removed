use
euclid
:
:
approxeq
:
:
ApproxEq
;
use
crate
:
:
bezier
:
:
Bezier
;
use
crate
:
:
piecewise_linear
:
:
{
PiecewiseLinearFunction
PiecewiseLinearFunctionBuildParameters
}
;
use
crate
:
:
values
:
:
computed
:
:
{
Integer
Number
Percentage
}
;
use
crate
:
:
values
:
:
generics
:
:
easing
:
:
{
self
BeforeFlag
StepPosition
TimingKeyword
}
;
pub
type
ComputedTimingFunction
=
easing
:
:
TimingFunction
<
Integer
Number
Percentage
>
;
pub
type
TimingFunction
=
ComputedTimingFunction
;
pub
type
ComputedLinearStop
=
easing
:
:
LinearStop
<
Number
Percentage
>
;
impl
ComputedLinearStop
{
pub
fn
to_piecewise_linear_build_parameters
(
x
:
&
ComputedLinearStop
)
-
>
PiecewiseLinearFunctionBuildParameters
{
(
x
.
output
x
.
input
.
into_rust
(
)
.
map
(
|
x
|
x
.
0
)
)
}
}
impl
ComputedTimingFunction
{
fn
calculate_step_output
(
steps
:
i32
pos
:
StepPosition
progress
:
f64
before_flag
:
BeforeFlag
)
-
>
f64
{
let
mut
current_step
=
(
progress
*
(
steps
as
f64
)
)
.
floor
(
)
as
i32
;
if
pos
=
=
StepPosition
:
:
Start
|
|
pos
=
=
StepPosition
:
:
JumpStart
|
|
pos
=
=
StepPosition
:
:
JumpBoth
{
current_step
=
current_step
.
checked_add
(
1
)
.
unwrap_or
(
current_step
)
;
}
if
before_flag
=
=
BeforeFlag
:
:
Set
&
&
(
progress
*
steps
as
f64
)
.
rem_euclid
(
1
.
0
)
.
approx_eq
(
&
0
.
0
)
{
current_step
=
current_step
.
checked_sub
(
1
)
.
unwrap_or
(
current_step
)
;
}
if
progress
>
=
0
.
0
&
&
current_step
<
0
{
current_step
=
0
;
}
let
jumps
=
if
pos
=
=
StepPosition
:
:
JumpBoth
{
steps
.
checked_add
(
1
)
.
unwrap_or
(
steps
)
}
else
if
pos
=
=
StepPosition
:
:
JumpNone
{
steps
.
checked_sub
(
1
)
.
unwrap_or
(
steps
)
}
else
{
steps
}
;
if
progress
<
=
1
.
0
&
&
current_step
>
jumps
{
current_step
=
jumps
;
}
(
current_step
as
f64
)
/
(
jumps
as
f64
)
}
pub
fn
calculate_output
(
&
self
progress
:
f64
before_flag
:
BeforeFlag
epsilon
:
f64
)
-
>
f64
{
match
self
{
TimingFunction
:
:
CubicBezier
{
x1
y1
x2
y2
}
=
>
{
Bezier
:
:
new
(
*
x1
*
y1
*
x2
*
y2
)
.
solve
(
progress
epsilon
)
}
TimingFunction
:
:
Steps
(
steps
pos
)
=
>
{
Self
:
:
calculate_step_output
(
*
steps
*
pos
progress
before_flag
)
}
TimingFunction
:
:
LinearFunction
(
elements
)
=
>
{
PiecewiseLinearFunction
:
:
from_iter
(
elements
.
iter
(
)
.
map
(
ComputedLinearStop
:
:
to_piecewise_linear_build_parameters
)
)
.
at
(
progress
as
f32
)
.
into
(
)
}
TimingFunction
:
:
Keyword
(
keyword
)
=
>
{
let
bezier
=
match
keyword
{
TimingKeyword
:
:
Linear
=
>
return
progress
TimingKeyword
:
:
Ease
=
>
Bezier
:
:
new
(
0
.
25
0
.
1
0
.
25
1
.
)
TimingKeyword
:
:
EaseIn
=
>
Bezier
:
:
new
(
0
.
42
0
.
1
.
1
.
)
TimingKeyword
:
:
EaseOut
=
>
Bezier
:
:
new
(
0
.
0
.
0
.
58
1
.
)
TimingKeyword
:
:
EaseInOut
=
>
Bezier
:
:
new
(
0
.
42
0
.
0
.
58
1
.
)
}
;
bezier
.
solve
(
progress
epsilon
)
}
}
}
}
