use
euclid
:
:
approxeq
:
:
ApproxEq
;
use
crate
:
:
bezier
:
:
Bezier
;
use
crate
:
:
piecewise_linear
:
:
PiecewiseLinearFunction
;
use
crate
:
:
values
:
:
computed
:
:
{
Integer
Number
}
;
use
crate
:
:
values
:
:
generics
:
:
easing
:
:
{
self
BeforeFlag
StepPosition
TimingKeyword
}
;
pub
type
ComputedTimingFunction
=
easing
:
:
TimingFunction
<
Integer
Number
PiecewiseLinearFunction
>
;
pub
type
TimingFunction
=
ComputedTimingFunction
;
impl
ComputedTimingFunction
{
fn
calculate_step_output
(
steps
:
i32
pos
:
StepPosition
progress
:
f64
before_flag
:
BeforeFlag
)
-
>
f64
{
let
mut
current_step
=
(
progress
*
(
steps
as
f64
)
)
.
floor
(
)
as
i32
;
if
pos
=
=
StepPosition
:
:
Start
|
|
pos
=
=
StepPosition
:
:
JumpStart
|
|
pos
=
=
StepPosition
:
:
JumpBoth
{
current_step
=
current_step
.
checked_add
(
1
)
.
unwrap_or
(
current_step
)
;
}
if
before_flag
=
=
BeforeFlag
:
:
Set
&
&
(
progress
*
steps
as
f64
)
.
rem_euclid
(
1
.
0
)
.
approx_eq
(
&
0
.
0
)
{
current_step
=
current_step
.
checked_sub
(
1
)
.
unwrap_or
(
current_step
)
;
}
if
progress
>
=
0
.
0
&
&
current_step
<
0
{
current_step
=
0
;
}
let
jumps
=
if
pos
=
=
StepPosition
:
:
JumpBoth
{
steps
.
checked_add
(
1
)
.
unwrap_or
(
steps
)
}
else
if
pos
=
=
StepPosition
:
:
JumpNone
{
steps
.
checked_sub
(
1
)
.
unwrap_or
(
steps
)
}
else
{
steps
}
;
if
progress
<
=
1
.
0
&
&
current_step
>
jumps
{
current_step
=
jumps
;
}
(
current_step
as
f64
)
/
(
jumps
as
f64
)
}
pub
fn
calculate_output
(
&
self
progress
:
f64
before_flag
:
BeforeFlag
epsilon
:
f64
)
-
>
f64
{
match
self
{
TimingFunction
:
:
CubicBezier
{
x1
y1
x2
y2
}
=
>
{
Bezier
:
:
calculate_bezier_output
(
progress
epsilon
*
x1
*
y1
*
x2
*
y2
)
}
TimingFunction
:
:
Steps
(
steps
pos
)
=
>
{
Self
:
:
calculate_step_output
(
*
steps
*
pos
progress
before_flag
)
}
TimingFunction
:
:
LinearFunction
(
function
)
=
>
function
.
at
(
progress
as
f32
)
.
into
(
)
TimingFunction
:
:
Keyword
(
keyword
)
=
>
match
keyword
{
TimingKeyword
:
:
Linear
=
>
return
progress
TimingKeyword
:
:
Ease
=
>
{
Bezier
:
:
calculate_bezier_output
(
progress
epsilon
0
.
25
0
.
1
0
.
25
1
.
)
}
TimingKeyword
:
:
EaseIn
=
>
{
Bezier
:
:
calculate_bezier_output
(
progress
epsilon
0
.
42
0
.
1
.
1
.
)
}
TimingKeyword
:
:
EaseOut
=
>
{
Bezier
:
:
calculate_bezier_output
(
progress
epsilon
0
.
0
.
0
.
58
1
.
)
}
TimingKeyword
:
:
EaseInOut
=
>
{
Bezier
:
:
calculate_bezier_output
(
progress
epsilon
0
.
42
0
.
0
.
58
1
.
)
}
}
}
}
}
