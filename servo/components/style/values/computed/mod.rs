use
app_units
:
:
Au
;
use
euclid
:
:
size
:
:
Size2D
;
use
font_metrics
:
:
FontMetricsProvider
;
use
media_queries
:
:
Device
;
use
properties
:
:
ComputedValues
;
use
std
:
:
fmt
;
use
style_traits
:
:
ToCss
;
use
super
:
:
{
CSSFloat
RGBA
specified
}
;
use
super
:
:
specified
:
:
grid
:
:
{
TrackBreadth
as
GenericTrackBreadth
TrackSize
as
GenericTrackSize
}
;
pub
use
cssparser
:
:
Color
as
CSSColor
;
pub
use
self
:
:
image
:
:
{
AngleOrCorner
EndingShape
as
GradientShape
Gradient
GradientKind
Image
}
;
pub
use
self
:
:
image
:
:
{
LengthOrKeyword
LengthOrPercentageOrKeyword
}
;
pub
use
super
:
:
{
Auto
Either
None_
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
super
:
:
specified
:
:
{
AlignItems
AlignJustifyContent
AlignJustifySelf
JustifyItems
}
;
pub
use
super
:
:
specified
:
:
{
Angle
BorderStyle
GridLine
Time
UrlOrNone
}
;
pub
use
super
:
:
specified
:
:
url
:
:
{
SpecifiedUrl
UrlExtraData
}
;
pub
use
self
:
:
length
:
:
{
CalcLengthOrPercentage
Length
LengthOrNumber
LengthOrPercentage
LengthOrPercentageOrAuto
}
;
pub
use
self
:
:
length
:
:
{
LengthOrPercentageOrAutoOrContent
LengthOrPercentageOrNone
LengthOrNone
}
;
pub
use
self
:
:
length
:
:
{
MaxLength
MinLength
}
;
pub
use
self
:
:
position
:
:
Position
;
pub
mod
basic_shape
;
pub
mod
image
;
pub
mod
length
;
pub
mod
position
;
pub
struct
Context
<
'
a
>
{
pub
is_root_element
:
bool
pub
device
:
&
'
a
Device
pub
inherited_style
:
&
'
a
ComputedValues
pub
layout_parent_style
:
&
'
a
ComputedValues
pub
style
:
ComputedValues
pub
font_metrics_provider
:
Option
<
&
'
a
FontMetricsProvider
>
}
impl
<
'
a
>
Context
<
'
a
>
{
pub
fn
is_root_element
(
&
self
)
-
>
bool
{
self
.
is_root_element
}
pub
fn
viewport_size
(
&
self
)
-
>
Size2D
<
Au
>
{
self
.
device
.
au_viewport_size
(
)
}
pub
fn
inherited_style
(
&
self
)
-
>
&
ComputedValues
{
&
self
.
inherited_style
}
pub
fn
style
(
&
self
)
-
>
&
ComputedValues
{
&
self
.
style
}
pub
fn
mutate_style
(
&
mut
self
)
-
>
&
mut
ComputedValues
{
&
mut
self
.
style
}
}
pub
trait
ToComputedValue
{
type
ComputedValue
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
;
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
;
}
pub
trait
ComputedValueAsSpecified
{
}
impl
<
T
>
ToComputedValue
for
T
where
T
:
ComputedValueAsSpecified
+
Clone
{
type
ComputedValue
=
T
;
#
[
inline
]
fn
to_computed_value
(
&
self
_context
:
&
Context
)
-
>
T
{
self
.
clone
(
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
T
)
-
>
Self
{
computed
.
clone
(
)
}
}
impl
ToComputedValue
for
specified
:
:
Color
{
type
ComputedValue
=
RGBA
;
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
RGBA
{
match
*
self
{
specified
:
:
Color
:
:
RGBA
(
rgba
)
=
>
rgba
specified
:
:
Color
:
:
CurrentColor
=
>
context
.
inherited_style
.
get_color
(
)
.
clone_color
(
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
RGBA
{
use
gecko
:
:
values
:
:
convert_nscolor_to_rgba
as
to_rgba
;
let
pres_context
=
unsafe
{
&
*
context
.
device
.
pres_context
}
;
match
*
self
{
specified
:
:
Color
:
:
RGBA
(
rgba
)
=
>
rgba
specified
:
:
Color
:
:
System
(
system
)
=
>
to_rgba
(
system
.
to_computed_value
(
context
)
)
specified
:
:
Color
:
:
CurrentColor
=
>
context
.
inherited_style
.
get_color
(
)
.
clone_color
(
)
specified
:
:
Color
:
:
MozDefaultColor
=
>
to_rgba
(
pres_context
.
mDefaultColor
)
specified
:
:
Color
:
:
MozDefaultBackgroundColor
=
>
to_rgba
(
pres_context
.
mBackgroundColor
)
specified
:
:
Color
:
:
MozHyperlinktext
=
>
to_rgba
(
pres_context
.
mLinkColor
)
specified
:
:
Color
:
:
MozActiveHyperlinktext
=
>
to_rgba
(
pres_context
.
mActiveLinkColor
)
specified
:
:
Color
:
:
MozVisitedHyperlinktext
=
>
to_rgba
(
pres_context
.
mVisitedLinkColor
)
}
}
fn
from_computed_value
(
computed
:
&
RGBA
)
-
>
Self
{
specified
:
:
Color
:
:
RGBA
(
*
computed
)
}
}
impl
ToComputedValue
for
specified
:
:
CSSColor
{
type
ComputedValue
=
CSSColor
;
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
#
[
inline
]
fn
to_computed_value
(
&
self
_context
:
&
Context
)
-
>
CSSColor
{
self
.
parsed
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
CSSColor
{
match
self
.
parsed
{
specified
:
:
Color
:
:
RGBA
(
rgba
)
=
>
CSSColor
:
:
RGBA
(
rgba
)
specified
:
:
Color
:
:
CurrentColor
=
>
CSSColor
:
:
CurrentColor
non_standard
=
>
CSSColor
:
:
RGBA
(
non_standard
.
to_computed_value
(
context
)
)
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
CSSColor
)
-
>
Self
{
specified
:
:
CSSColor
{
parsed
:
match
*
computed
{
CSSColor
:
:
RGBA
(
rgba
)
=
>
specified
:
:
Color
:
:
RGBA
(
rgba
)
CSSColor
:
:
CurrentColor
=
>
specified
:
:
Color
:
:
CurrentColor
}
authored
:
None
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ToComputedValue
for
specified
:
:
JustifyItems
{
type
ComputedValue
=
JustifyItems
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
JustifyItems
{
use
values
:
:
specified
:
:
align
;
if
self
.
0
=
=
align
:
:
ALIGN_AUTO
{
let
inherited
=
context
.
inherited_style
.
get_position
(
)
.
clone_justify_items
(
)
;
if
inherited
.
0
.
contains
(
align
:
:
ALIGN_LEGACY
)
{
return
inherited
}
}
return
*
self
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
JustifyItems
)
-
>
Self
{
*
computed
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ComputedValueAsSpecified
for
specified
:
:
AlignItems
{
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ComputedValueAsSpecified
for
specified
:
:
AlignJustifyContent
{
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ComputedValueAsSpecified
for
specified
:
:
AlignJustifySelf
{
}
impl
ComputedValueAsSpecified
for
specified
:
:
BorderStyle
{
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
BorderRadiusSize
(
pub
Size2D
<
LengthOrPercentage
>
)
;
impl
BorderRadiusSize
{
#
[
allow
(
missing_docs
)
]
pub
fn
zero
(
)
-
>
BorderRadiusSize
{
BorderRadiusSize
(
Size2D
:
:
new
(
LengthOrPercentage
:
:
Length
(
Au
(
0
)
)
LengthOrPercentage
:
:
Length
(
Au
(
0
)
)
)
)
}
}
impl
ToComputedValue
for
specified
:
:
BorderRadiusSize
{
type
ComputedValue
=
BorderRadiusSize
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
BorderRadiusSize
{
let
w
=
self
.
0
.
width
.
to_computed_value
(
context
)
;
let
h
=
self
.
0
.
height
.
to_computed_value
(
context
)
;
BorderRadiusSize
(
Size2D
:
:
new
(
w
h
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
BorderRadiusSize
)
-
>
Self
{
let
w
=
ToComputedValue
:
:
from_computed_value
(
&
computed
.
0
.
width
)
;
let
h
=
ToComputedValue
:
:
from_computed_value
(
&
computed
.
0
.
height
)
;
specified
:
:
BorderRadiusSize
(
Size2D
:
:
new
(
w
h
)
)
}
}
impl
ToCss
for
BorderRadiusSize
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
self
.
0
.
width
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
/
"
)
)
;
self
.
0
.
height
.
to_css
(
dest
)
}
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
Shadow
{
pub
offset_x
:
Au
pub
offset_y
:
Au
pub
blur_radius
:
Au
pub
spread_radius
:
Au
pub
color
:
CSSColor
pub
inset
:
bool
}
pub
type
Number
=
CSSFloat
;
pub
type
Opacity
=
CSSFloat
;
#
[
derive
(
Debug
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
SVGPaint
{
pub
kind
:
SVGPaintKind
pub
fallback
:
Option
<
CSSColor
>
}
impl
Default
for
SVGPaint
{
fn
default
(
)
-
>
Self
{
SVGPaint
{
kind
:
SVGPaintKind
:
:
None
fallback
:
None
}
}
}
impl
SVGPaint
{
pub
fn
black
(
)
-
>
Self
{
let
rgba
=
RGBA
:
:
from_floats
(
0
.
0
.
0
.
1
.
)
;
SVGPaint
{
kind
:
SVGPaintKind
:
:
Color
(
CSSColor
:
:
RGBA
(
rgba
)
)
fallback
:
None
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
SVGPaintKind
{
None
Color
(
CSSColor
)
PaintServer
(
SpecifiedUrl
)
ContextFill
ContextStroke
}
impl
ToCss
for
SVGPaintKind
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
SVGPaintKind
:
:
None
=
>
dest
.
write_str
(
"
none
"
)
SVGPaintKind
:
:
ContextStroke
=
>
dest
.
write_str
(
"
context
-
stroke
"
)
SVGPaintKind
:
:
ContextFill
=
>
dest
.
write_str
(
"
context
-
fill
"
)
SVGPaintKind
:
:
Color
(
ref
color
)
=
>
color
.
to_css
(
dest
)
SVGPaintKind
:
:
PaintServer
(
ref
server
)
=
>
server
.
to_css
(
dest
)
}
}
}
impl
ToCss
for
SVGPaint
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
self
.
kind
.
to_css
(
dest
)
?
;
if
let
Some
(
ref
fallback
)
=
self
.
fallback
{
fallback
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
pub
type
LoPOrNumber
=
Either
<
LengthOrPercentage
Number
>
;
#
[
derive
(
Clone
PartialEq
Eq
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
ClipRect
{
pub
top
:
Option
<
Au
>
pub
right
:
Option
<
Au
>
pub
bottom
:
Option
<
Au
>
pub
left
:
Option
<
Au
>
}
impl
ToCss
for
ClipRect
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
rect
(
"
)
)
;
if
let
Some
(
top
)
=
self
.
top
{
try
!
(
top
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
"
)
)
;
}
else
{
try
!
(
dest
.
write_str
(
"
auto
"
)
)
;
}
if
let
Some
(
right
)
=
self
.
right
{
try
!
(
right
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
"
)
)
;
}
else
{
try
!
(
dest
.
write_str
(
"
auto
"
)
)
;
}
if
let
Some
(
bottom
)
=
self
.
bottom
{
try
!
(
bottom
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
"
)
)
;
}
else
{
try
!
(
dest
.
write_str
(
"
auto
"
)
)
;
}
if
let
Some
(
left
)
=
self
.
left
{
try
!
(
left
.
to_css
(
dest
)
)
;
}
else
{
try
!
(
dest
.
write_str
(
"
auto
"
)
)
;
}
dest
.
write_str
(
"
)
"
)
}
}
pub
type
ClipRectOrAuto
=
Either
<
ClipRect
Auto
>
;
pub
type
TrackBreadth
=
GenericTrackBreadth
<
LengthOrPercentage
>
;
pub
type
TrackSize
=
GenericTrackSize
<
LengthOrPercentage
>
;
impl
ClipRectOrAuto
{
pub
fn
auto
(
)
-
>
Self
{
Either
:
:
Second
(
Auto
)
}
pub
fn
is_auto
(
&
self
)
-
>
bool
{
match
*
self
{
Either
:
:
Second
(
_
)
=
>
true
_
=
>
false
}
}
}
pub
type
ColorOrAuto
=
Either
<
CSSColor
Auto
>
;
