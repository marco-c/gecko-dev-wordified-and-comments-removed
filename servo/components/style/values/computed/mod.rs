use
Atom
;
use
context
:
:
QuirksMode
;
use
euclid
:
:
Size2D
;
use
font_metrics
:
:
FontMetricsProvider
;
use
media_queries
:
:
Device
;
use
num_traits
:
:
Zero
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
properties
;
use
properties
:
:
{
ComputedValues
StyleBuilder
}
;
use
std
:
:
f32
;
use
std
:
:
f32
:
:
consts
:
:
PI
;
use
std
:
:
fmt
;
use
style_traits
:
:
ToCss
;
use
super
:
:
{
CSSFloat
CSSInteger
RGBA
}
;
use
super
:
:
generics
:
:
grid
:
:
{
TrackBreadth
as
GenericTrackBreadth
TrackSize
as
GenericTrackSize
}
;
use
super
:
:
generics
:
:
grid
:
:
TrackList
as
GenericTrackList
;
use
super
:
:
specified
;
pub
use
app_units
:
:
Au
;
pub
use
properties
:
:
animated_properties
:
:
TransitionProperty
;
pub
use
self
:
:
background
:
:
BackgroundSize
;
pub
use
self
:
:
border
:
:
{
BorderImageSlice
BorderImageWidth
BorderImageSideWidth
}
;
pub
use
self
:
:
border
:
:
{
BorderRadius
BorderCornerRadius
}
;
pub
use
self
:
:
color
:
:
{
Color
RGBAColor
}
;
pub
use
self
:
:
effects
:
:
FilterList
;
pub
use
self
:
:
flex
:
:
FlexBasis
;
pub
use
self
:
:
image
:
:
{
Gradient
GradientItem
ImageLayer
LineDirection
Image
ImageRect
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
self
:
:
gecko
:
:
ScrollSnapPoint
;
pub
use
self
:
:
rect
:
:
LengthOrNumberRect
;
pub
use
super
:
:
{
Auto
Either
None_
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
super
:
:
specified
:
:
{
AlignItems
AlignJustifyContent
AlignJustifySelf
JustifyItems
}
;
pub
use
super
:
:
specified
:
:
{
BorderStyle
Percentage
UrlOrNone
}
;
pub
use
super
:
:
generics
:
:
grid
:
:
GridLine
;
pub
use
super
:
:
specified
:
:
url
:
:
SpecifiedUrl
;
pub
use
self
:
:
length
:
:
{
CalcLengthOrPercentage
Length
LengthOrNone
LengthOrNumber
LengthOrPercentage
}
;
pub
use
self
:
:
length
:
:
{
LengthOrPercentageOrAuto
LengthOrPercentageOrNone
MaxLength
MozLength
}
;
pub
use
self
:
:
position
:
:
Position
;
pub
use
self
:
:
text
:
:
{
InitialLetter
LetterSpacing
LineHeight
WordSpacing
}
;
pub
use
self
:
:
transform
:
:
{
TimingFunction
TransformOrigin
}
;
pub
mod
background
;
pub
mod
basic_shape
;
pub
mod
border
;
pub
mod
color
;
pub
mod
effects
;
pub
mod
flex
;
pub
mod
image
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
mod
gecko
;
pub
mod
length
;
pub
mod
position
;
pub
mod
rect
;
pub
mod
text
;
pub
mod
transform
;
pub
struct
Context
<
'
a
>
{
pub
is_root_element
:
bool
pub
device
:
&
'
a
Device
pub
inherited_style
:
&
'
a
ComputedValues
pub
layout_parent_style
:
&
'
a
ComputedValues
pub
style
:
StyleBuilder
<
'
a
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
cached_system_font
:
Option
<
properties
:
:
longhands
:
:
system_font
:
:
ComputedSystemFont
>
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
cached_system_font
:
Option
<
(
)
>
pub
font_metrics_provider
:
&
'
a
FontMetricsProvider
pub
in_media_query
:
bool
pub
quirks_mode
:
QuirksMode
}
impl
<
'
a
>
Context
<
'
a
>
{
pub
fn
is_root_element
(
&
self
)
-
>
bool
{
self
.
is_root_element
}
pub
fn
viewport_size
(
&
self
)
-
>
Size2D
<
Au
>
{
self
.
device
.
au_viewport_size
(
)
}
pub
fn
inherited_style
(
&
self
)
-
>
&
ComputedValues
{
&
self
.
inherited_style
}
pub
fn
style
(
&
self
)
-
>
&
StyleBuilder
{
&
self
.
style
}
pub
fn
mutate_style
(
&
mut
self
)
-
>
&
mut
StyleBuilder
<
'
a
>
{
&
mut
self
.
style
}
pub
fn
mutate_style_with_device
(
&
mut
self
)
-
>
(
&
mut
StyleBuilder
<
'
a
>
&
Device
)
{
(
&
mut
self
.
style
&
self
.
device
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
ComputedVecIter
<
'
a
'
cx
'
cx_a
:
'
cx
S
:
ToComputedValue
+
'
a
>
{
cx
:
&
'
cx
Context
<
'
cx_a
>
values
:
&
'
a
[
S
]
}
impl
<
'
a
'
cx
'
cx_a
:
'
cx
S
:
ToComputedValue
+
'
a
>
ComputedVecIter
<
'
a
'
cx
'
cx_a
S
>
{
pub
fn
new
(
cx
:
&
'
cx
Context
<
'
cx_a
>
values
:
&
'
a
[
S
]
)
-
>
Self
{
ComputedVecIter
{
cx
:
cx
values
:
values
}
}
}
impl
<
'
a
'
cx
'
cx_a
:
'
cx
S
:
ToComputedValue
+
'
a
>
ExactSizeIterator
for
ComputedVecIter
<
'
a
'
cx
'
cx_a
S
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
values
.
len
(
)
}
}
impl
<
'
a
'
cx
'
cx_a
:
'
cx
S
:
ToComputedValue
+
'
a
>
Iterator
for
ComputedVecIter
<
'
a
'
cx
'
cx_a
S
>
{
type
Item
=
S
:
:
ComputedValue
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
let
Some
(
(
next
rest
)
)
=
self
.
values
.
split_first
(
)
{
let
ret
=
next
.
to_computed_value
(
self
.
cx
)
;
self
.
values
=
rest
;
Some
(
ret
)
}
else
{
None
}
}
}
pub
trait
ToComputedValue
{
type
ComputedValue
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
;
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
;
}
impl
<
A
B
>
ToComputedValue
for
(
A
B
)
where
A
:
ToComputedValue
B
:
ToComputedValue
{
type
ComputedValue
=
(
<
A
as
ToComputedValue
>
:
:
ComputedValue
<
B
as
ToComputedValue
>
:
:
ComputedValue
)
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
(
self
.
0
.
to_computed_value
(
context
)
self
.
1
.
to_computed_value
(
context
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
(
A
:
:
from_computed_value
(
&
computed
.
0
)
B
:
:
from_computed_value
(
&
computed
.
1
)
)
}
}
impl
<
T
>
ToComputedValue
for
Option
<
T
>
where
T
:
ToComputedValue
{
type
ComputedValue
=
Option
<
<
T
as
ToComputedValue
>
:
:
ComputedValue
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
self
.
as_ref
(
)
.
map
(
|
item
|
item
.
to_computed_value
(
context
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
computed
.
as_ref
(
)
.
map
(
T
:
:
from_computed_value
)
}
}
impl
<
T
>
ToComputedValue
for
Size2D
<
T
>
where
T
:
ToComputedValue
{
type
ComputedValue
=
Size2D
<
<
T
as
ToComputedValue
>
:
:
ComputedValue
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
Size2D
:
:
new
(
self
.
width
.
to_computed_value
(
context
)
self
.
height
.
to_computed_value
(
context
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
Size2D
:
:
new
(
T
:
:
from_computed_value
(
&
computed
.
width
)
T
:
:
from_computed_value
(
&
computed
.
height
)
)
}
}
impl
<
T
>
ToComputedValue
for
Vec
<
T
>
where
T
:
ToComputedValue
{
type
ComputedValue
=
Vec
<
<
T
as
ToComputedValue
>
:
:
ComputedValue
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
self
.
iter
(
)
.
map
(
|
item
|
item
.
to_computed_value
(
context
)
)
.
collect
(
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
computed
.
iter
(
)
.
map
(
T
:
:
from_computed_value
)
.
collect
(
)
}
}
impl
<
T
>
ToComputedValue
for
Box
<
[
T
]
>
where
T
:
ToComputedValue
{
type
ComputedValue
=
Box
<
[
<
T
as
ToComputedValue
>
:
:
ComputedValue
]
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
self
.
iter
(
)
.
map
(
|
item
|
item
.
to_computed_value
(
context
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
into_boxed_slice
(
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
computed
.
iter
(
)
.
map
(
T
:
:
from_computed_value
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
into_boxed_slice
(
)
}
}
pub
trait
ComputedValueAsSpecified
{
}
impl
<
T
>
ToComputedValue
for
T
where
T
:
ComputedValueAsSpecified
+
Clone
{
type
ComputedValue
=
T
;
#
[
inline
]
fn
to_computed_value
(
&
self
_context
:
&
Context
)
-
>
T
{
self
.
clone
(
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
T
)
-
>
Self
{
computed
.
clone
(
)
}
}
impl
ComputedValueAsSpecified
for
Atom
{
}
impl
ComputedValueAsSpecified
for
bool
{
}
#
[
derive
(
Clone
Copy
Debug
HasViewportPercentage
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
Deserialize
Serialize
)
)
]
pub
enum
Angle
{
Degree
(
CSSFloat
)
Gradian
(
CSSFloat
)
Radian
(
CSSFloat
)
Turn
(
CSSFloat
)
}
impl
Angle
{
pub
fn
from_radians
(
radians
:
CSSFloat
)
-
>
Self
{
Angle
:
:
Radian
(
radians
)
}
#
[
inline
]
pub
fn
radians
(
&
self
)
-
>
CSSFloat
{
const
RAD_PER_DEG
:
CSSFloat
=
PI
/
180
.
0
;
const
RAD_PER_GRAD
:
CSSFloat
=
PI
/
200
.
0
;
const
RAD_PER_TURN
:
CSSFloat
=
PI
*
2
.
0
;
let
radians
=
match
*
self
{
Angle
:
:
Degree
(
val
)
=
>
val
*
RAD_PER_DEG
Angle
:
:
Gradian
(
val
)
=
>
val
*
RAD_PER_GRAD
Angle
:
:
Turn
(
val
)
=
>
val
*
RAD_PER_TURN
Angle
:
:
Radian
(
val
)
=
>
val
}
;
radians
.
min
(
f32
:
:
MAX
)
.
max
(
f32
:
:
MIN
)
}
pub
fn
zero
(
)
-
>
Self
{
Angle
:
:
Radian
(
0
.
0
)
}
}
impl
ToCss
for
Angle
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
Angle
:
:
Degree
(
val
)
=
>
write
!
(
dest
"
{
}
deg
"
val
)
Angle
:
:
Gradian
(
val
)
=
>
write
!
(
dest
"
{
}
grad
"
val
)
Angle
:
:
Radian
(
val
)
=
>
write
!
(
dest
"
{
}
rad
"
val
)
Angle
:
:
Turn
(
val
)
=
>
write
!
(
dest
"
{
}
turn
"
val
)
}
}
}
#
[
derive
(
Clone
PartialEq
PartialOrd
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
Deserialize
Serialize
)
)
]
pub
struct
Time
{
seconds
:
CSSFloat
}
impl
Time
{
pub
fn
from_seconds
(
seconds
:
CSSFloat
)
-
>
Self
{
Time
{
seconds
:
seconds
}
}
pub
fn
zero
(
)
-
>
Self
{
Self
:
:
from_seconds
(
0
.
0
)
}
#
[
inline
]
pub
fn
seconds
(
&
self
)
-
>
CSSFloat
{
self
.
seconds
}
}
impl
ToCss
for
Time
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
write
!
(
dest
"
{
}
s
"
self
.
seconds
(
)
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ToComputedValue
for
specified
:
:
JustifyItems
{
type
ComputedValue
=
JustifyItems
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
JustifyItems
{
use
values
:
:
specified
:
:
align
;
if
self
.
0
=
=
align
:
:
ALIGN_AUTO
{
let
inherited
=
context
.
inherited_style
.
get_position
(
)
.
clone_justify_items
(
)
;
if
inherited
.
0
.
contains
(
align
:
:
ALIGN_LEGACY
)
{
return
inherited
}
}
return
*
self
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
JustifyItems
)
-
>
Self
{
*
computed
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ComputedValueAsSpecified
for
specified
:
:
AlignItems
{
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ComputedValueAsSpecified
for
specified
:
:
AlignJustifyContent
{
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ComputedValueAsSpecified
for
specified
:
:
AlignJustifySelf
{
}
impl
ComputedValueAsSpecified
for
specified
:
:
BorderStyle
{
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
Shadow
{
pub
offset_x
:
Au
pub
offset_y
:
Au
pub
blur_radius
:
Au
pub
spread_radius
:
Au
pub
color
:
Color
pub
inset
:
bool
}
impl
ToCss
for
Shadow
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
if
self
.
inset
{
dest
.
write_str
(
"
inset
"
)
?
;
}
self
.
offset_x
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
self
.
offset_y
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
self
.
blur_radius
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
if
self
.
spread_radius
!
=
Au
:
:
zero
(
)
{
self
.
spread_radius
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
}
self
.
color
.
to_css
(
dest
)
?
;
Ok
(
(
)
)
}
}
pub
type
Number
=
CSSFloat
;
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
ToCss
)
]
pub
enum
NumberOrPercentage
{
Percentage
(
Percentage
)
Number
(
Number
)
}
impl
ToComputedValue
for
specified
:
:
NumberOrPercentage
{
type
ComputedValue
=
NumberOrPercentage
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
NumberOrPercentage
{
match
*
self
{
specified
:
:
NumberOrPercentage
:
:
Percentage
(
percentage
)
=
>
NumberOrPercentage
:
:
Percentage
(
percentage
.
to_computed_value
(
context
)
)
specified
:
:
NumberOrPercentage
:
:
Number
(
number
)
=
>
NumberOrPercentage
:
:
Number
(
number
.
to_computed_value
(
context
)
)
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
NumberOrPercentage
)
-
>
Self
{
match
*
computed
{
NumberOrPercentage
:
:
Percentage
(
percentage
)
=
>
specified
:
:
NumberOrPercentage
:
:
Percentage
(
ToComputedValue
:
:
from_computed_value
(
&
percentage
)
)
NumberOrPercentage
:
:
Number
(
number
)
=
>
specified
:
:
NumberOrPercentage
:
:
Number
(
ToComputedValue
:
:
from_computed_value
(
&
number
)
)
}
}
}
pub
type
Opacity
=
CSSFloat
;
pub
type
Integer
=
CSSInteger
;
pub
type
IntegerOrAuto
=
Either
<
CSSInteger
Auto
>
;
impl
IntegerOrAuto
{
pub
fn
integer_or
(
&
self
auto_value
:
CSSInteger
)
-
>
CSSInteger
{
match
*
self
{
Either
:
:
First
(
n
)
=
>
n
Either
:
:
Second
(
Auto
)
=
>
auto_value
}
}
}
pub
type
SVGPaint
=
:
:
values
:
:
generics
:
:
SVGPaint
<
RGBA
>
;
pub
type
SVGPaintKind
=
:
:
values
:
:
generics
:
:
SVGPaintKind
<
RGBA
>
;
impl
Default
for
SVGPaint
{
fn
default
(
)
-
>
Self
{
SVGPaint
{
kind
:
:
:
values
:
:
generics
:
:
SVGPaintKind
:
:
None
fallback
:
None
}
}
}
impl
SVGPaint
{
pub
fn
black
(
)
-
>
Self
{
let
rgba
=
RGBA
:
:
from_floats
(
0
.
0
.
0
.
1
.
)
;
SVGPaint
{
kind
:
:
:
values
:
:
generics
:
:
SVGPaintKind
:
:
Color
(
rgba
)
fallback
:
None
}
}
}
pub
type
LengthOrPercentageOrNumber
=
Either
<
Number
LengthOrPercentage
>
;
#
[
derive
(
Clone
PartialEq
Eq
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
ClipRect
{
pub
top
:
Option
<
Au
>
pub
right
:
Option
<
Au
>
pub
bottom
:
Option
<
Au
>
pub
left
:
Option
<
Au
>
}
impl
ToCss
for
ClipRect
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_str
(
"
rect
(
"
)
?
;
if
let
Some
(
top
)
=
self
.
top
{
top
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
}
else
{
dest
.
write_str
(
"
auto
"
)
?
;
}
if
let
Some
(
right
)
=
self
.
right
{
right
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
}
else
{
dest
.
write_str
(
"
auto
"
)
?
;
}
if
let
Some
(
bottom
)
=
self
.
bottom
{
bottom
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
}
else
{
dest
.
write_str
(
"
auto
"
)
?
;
}
if
let
Some
(
left
)
=
self
.
left
{
left
.
to_css
(
dest
)
?
;
}
else
{
dest
.
write_str
(
"
auto
"
)
?
;
}
dest
.
write_str
(
"
)
"
)
}
}
pub
type
ClipRectOrAuto
=
Either
<
ClipRect
Auto
>
;
pub
type
TrackBreadth
=
GenericTrackBreadth
<
LengthOrPercentage
>
;
pub
type
TrackSize
=
GenericTrackSize
<
LengthOrPercentage
>
;
pub
type
TrackList
=
GenericTrackList
<
TrackSize
>
;
pub
type
TrackListOrNone
=
Either
<
TrackList
None_
>
;
impl
ClipRectOrAuto
{
pub
fn
auto
(
)
-
>
Self
{
Either
:
:
Second
(
Auto
)
}
pub
fn
is_auto
(
&
self
)
-
>
bool
{
match
*
self
{
Either
:
:
Second
(
_
)
=
>
true
_
=
>
false
}
}
}
pub
type
ColorOrAuto
=
Either
<
Color
Auto
>
;
