use
{
Atom
Namespace
}
;
use
context
:
:
QuirksMode
;
use
euclid
:
:
Size2D
;
use
font_metrics
:
:
{
FontMetricsProvider
get_metrics_provider_for_product
}
;
use
media_queries
:
:
Device
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
properties
;
use
properties
:
:
{
ComputedValues
LonghandId
StyleBuilder
}
;
use
rule_cache
:
:
RuleCacheConditions
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
servo_url
:
:
ServoUrl
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
f32
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
std
:
:
sync
:
:
Arc
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
use
style_traits
:
:
cursor
:
:
CursorKind
;
use
super
:
:
{
CSSFloat
CSSInteger
}
;
use
super
:
:
generics
:
:
{
GreaterThanOrEqualToOne
NonNegative
}
;
use
super
:
:
generics
:
:
grid
:
:
{
GridLine
as
GenericGridLine
TrackBreadth
as
GenericTrackBreadth
}
;
use
super
:
:
generics
:
:
grid
:
:
{
TrackSize
as
GenericTrackSize
TrackList
as
GenericTrackList
}
;
use
super
:
:
generics
:
:
grid
:
:
GridTemplateComponent
as
GenericGridTemplateComponent
;
use
super
:
:
specified
;
pub
use
app_units
:
:
Au
;
pub
use
properties
:
:
animated_properties
:
:
TransitionProperty
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
self
:
:
align
:
:
{
AlignItems
ContentDistribution
SelfAlignment
JustifyItems
}
;
pub
use
self
:
:
angle
:
:
Angle
;
pub
use
self
:
:
background
:
:
{
BackgroundSize
BackgroundRepeat
}
;
pub
use
self
:
:
border
:
:
{
BorderImageSlice
BorderImageWidth
BorderImageSideWidth
}
;
pub
use
self
:
:
border
:
:
{
BorderRadius
BorderCornerRadius
BorderSpacing
}
;
pub
use
self
:
:
font
:
:
{
FontSize
FontSizeAdjust
FontSynthesis
FontWeight
FontVariantAlternates
}
;
pub
use
self
:
:
font
:
:
{
FontFamily
FontLanguageOverride
FontVariantSettings
FontVariantEastAsian
}
;
pub
use
self
:
:
font
:
:
{
FontVariantLigatures
FontVariantNumeric
FontFeatureSettings
}
;
pub
use
self
:
:
font
:
:
{
MozScriptLevel
MozScriptMinSize
MozScriptSizeMultiplier
XTextZoom
XLang
}
;
pub
use
self
:
:
box_
:
:
{
AnimationIterationCount
AnimationName
Display
OverscrollBehavior
Contain
}
;
pub
use
self
:
:
box_
:
:
{
OverflowClipBox
ScrollSnapType
TouchAction
VerticalAlign
WillChange
}
;
pub
use
self
:
:
color
:
:
{
Color
ColorPropertyValue
RGBAColor
}
;
pub
use
self
:
:
effects
:
:
{
BoxShadow
Filter
SimpleShadow
}
;
pub
use
self
:
:
flex
:
:
FlexBasis
;
pub
use
self
:
:
image
:
:
{
Gradient
GradientItem
Image
ImageLayer
LineDirection
MozImageRect
}
;
pub
use
self
:
:
inherited_box
:
:
{
Orientation
ImageOrientation
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
self
:
:
gecko
:
:
ScrollSnapPoint
;
pub
use
self
:
:
rect
:
:
LengthOrNumberRect
;
pub
use
super
:
:
{
Auto
Either
None_
}
;
pub
use
super
:
:
specified
:
:
{
BorderStyle
TextDecorationLine
}
;
pub
use
self
:
:
length
:
:
{
CalcLengthOrPercentage
Length
LengthOrNone
LengthOrNumber
LengthOrPercentage
}
;
pub
use
self
:
:
length
:
:
{
LengthOrPercentageOrAuto
LengthOrPercentageOrNone
MaxLength
MozLength
}
;
pub
use
self
:
:
length
:
:
{
CSSPixelLength
NonNegativeLength
NonNegativeLengthOrPercentage
}
;
pub
use
self
:
:
list
:
:
{
ListStyleImage
Quotes
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
self
:
:
list
:
:
ListStyleType
;
pub
use
self
:
:
outline
:
:
OutlineStyle
;
pub
use
self
:
:
percentage
:
:
Percentage
;
pub
use
self
:
:
position
:
:
{
Position
GridAutoFlow
GridTemplateAreas
}
;
pub
use
self
:
:
pointing
:
:
Cursor
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
self
:
:
pointing
:
:
CursorImage
;
pub
use
self
:
:
svg
:
:
{
SVGLength
SVGOpacity
SVGPaint
SVGPaintKind
}
;
pub
use
self
:
:
svg
:
:
{
SVGPaintOrder
SVGStrokeDashArray
SVGWidth
}
;
pub
use
self
:
:
svg
:
:
MozContextProperties
;
pub
use
self
:
:
table
:
:
XSpan
;
pub
use
self
:
:
text
:
:
{
InitialLetter
LetterSpacing
LineHeight
TextAlign
TextOverflow
WordSpacing
}
;
pub
use
self
:
:
time
:
:
Time
;
pub
use
self
:
:
transform
:
:
{
TimingFunction
Transform
TransformOperation
TransformOrigin
}
;
pub
use
self
:
:
ui
:
:
MozForceBrokenImageIcon
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
mod
align
;
pub
mod
angle
;
pub
mod
background
;
pub
mod
basic_shape
;
pub
mod
border
;
#
[
path
=
"
box
.
rs
"
]
pub
mod
box_
;
pub
mod
color
;
pub
mod
effects
;
pub
mod
flex
;
pub
mod
font
;
pub
mod
image
;
pub
mod
inherited_box
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
mod
gecko
;
pub
mod
length
;
pub
mod
list
;
pub
mod
outline
;
pub
mod
percentage
;
pub
mod
pointing
;
pub
mod
position
;
pub
mod
rect
;
pub
mod
svg
;
pub
mod
table
;
pub
mod
text
;
pub
mod
time
;
pub
mod
transform
;
pub
mod
ui
;
pub
struct
Context
<
'
a
>
{
pub
is_root_element
:
bool
pub
builder
:
StyleBuilder
<
'
a
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
cached_system_font
:
Option
<
properties
:
:
longhands
:
:
system_font
:
:
ComputedSystemFont
>
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
cached_system_font
:
Option
<
(
)
>
pub
font_metrics_provider
:
&
'
a
FontMetricsProvider
pub
in_media_query
:
bool
pub
quirks_mode
:
QuirksMode
pub
for_smil_animation
:
bool
pub
for_non_inherited_property
:
Option
<
LonghandId
>
pub
rule_cache_conditions
:
RefCell
<
&
'
a
mut
RuleCacheConditions
>
}
impl
<
'
a
>
Context
<
'
a
>
{
pub
fn
for_media_query_evaluation
<
F
R
>
(
device
:
&
Device
quirks_mode
:
QuirksMode
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
Context
)
-
>
R
{
let
mut
conditions
=
RuleCacheConditions
:
:
default
(
)
;
let
default_values
=
device
.
default_computed_values
(
)
;
let
provider
=
get_metrics_provider_for_product
(
)
;
let
context
=
Context
{
is_root_element
:
false
builder
:
StyleBuilder
:
:
for_derived_style
(
device
default_values
None
None
)
font_metrics_provider
:
&
provider
cached_system_font
:
None
in_media_query
:
true
quirks_mode
for_smil_animation
:
false
for_non_inherited_property
:
None
rule_cache_conditions
:
RefCell
:
:
new
(
&
mut
conditions
)
}
;
f
(
&
context
)
}
pub
fn
is_root_element
(
&
self
)
-
>
bool
{
self
.
is_root_element
}
pub
fn
device
(
&
self
)
-
>
&
Device
{
self
.
builder
.
device
}
pub
fn
viewport_size_for_viewport_unit_resolution
(
&
self
)
-
>
Size2D
<
Au
>
{
self
.
builder
.
device
.
au_viewport_size_for_viewport_unit_resolution
(
)
}
pub
fn
default_style
(
&
self
)
-
>
&
ComputedValues
{
self
.
builder
.
default_style
(
)
}
pub
fn
style
(
&
self
)
-
>
&
StyleBuilder
{
&
self
.
builder
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
maybe_zoom_text
(
&
self
size
:
NonNegativeLength
)
-
>
NonNegativeLength
{
if
self
.
style
(
)
.
get_font
(
)
.
gecko
.
mAllowZoom
{
self
.
device
(
)
.
zoom_text
(
Au
:
:
from
(
size
)
)
.
into
(
)
}
else
{
size
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
maybe_zoom_text
(
&
self
size
:
NonNegativeLength
)
-
>
NonNegativeLength
{
size
}
}
#
[
derive
(
Clone
)
]
pub
struct
ComputedVecIter
<
'
a
'
cx
'
cx_a
:
'
cx
S
:
ToComputedValue
+
'
a
>
{
cx
:
&
'
cx
Context
<
'
cx_a
>
values
:
&
'
a
[
S
]
}
impl
<
'
a
'
cx
'
cx_a
:
'
cx
S
:
ToComputedValue
+
'
a
>
ComputedVecIter
<
'
a
'
cx
'
cx_a
S
>
{
pub
fn
new
(
cx
:
&
'
cx
Context
<
'
cx_a
>
values
:
&
'
a
[
S
]
)
-
>
Self
{
ComputedVecIter
{
cx
:
cx
values
:
values
}
}
}
impl
<
'
a
'
cx
'
cx_a
:
'
cx
S
:
ToComputedValue
+
'
a
>
ExactSizeIterator
for
ComputedVecIter
<
'
a
'
cx
'
cx_a
S
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
values
.
len
(
)
}
}
impl
<
'
a
'
cx
'
cx_a
:
'
cx
S
:
ToComputedValue
+
'
a
>
Iterator
for
ComputedVecIter
<
'
a
'
cx
'
cx_a
S
>
{
type
Item
=
S
:
:
ComputedValue
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
let
Some
(
(
next
rest
)
)
=
self
.
values
.
split_first
(
)
{
let
ret
=
next
.
to_computed_value
(
self
.
cx
)
;
self
.
values
=
rest
;
Some
(
ret
)
}
else
{
None
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
(
self
.
values
.
len
(
)
Some
(
self
.
values
.
len
(
)
)
)
}
}
pub
trait
ToComputedValue
{
type
ComputedValue
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
;
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
;
}
impl
<
A
B
>
ToComputedValue
for
(
A
B
)
where
A
:
ToComputedValue
B
:
ToComputedValue
{
type
ComputedValue
=
(
<
A
as
ToComputedValue
>
:
:
ComputedValue
<
B
as
ToComputedValue
>
:
:
ComputedValue
)
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
(
self
.
0
.
to_computed_value
(
context
)
self
.
1
.
to_computed_value
(
context
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
(
A
:
:
from_computed_value
(
&
computed
.
0
)
B
:
:
from_computed_value
(
&
computed
.
1
)
)
}
}
impl
<
T
>
ToComputedValue
for
Option
<
T
>
where
T
:
ToComputedValue
{
type
ComputedValue
=
Option
<
<
T
as
ToComputedValue
>
:
:
ComputedValue
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
self
.
as_ref
(
)
.
map
(
|
item
|
item
.
to_computed_value
(
context
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
computed
.
as_ref
(
)
.
map
(
T
:
:
from_computed_value
)
}
}
impl
<
T
>
ToComputedValue
for
Size2D
<
T
>
where
T
:
ToComputedValue
{
type
ComputedValue
=
Size2D
<
<
T
as
ToComputedValue
>
:
:
ComputedValue
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
Size2D
:
:
new
(
self
.
width
.
to_computed_value
(
context
)
self
.
height
.
to_computed_value
(
context
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
Size2D
:
:
new
(
T
:
:
from_computed_value
(
&
computed
.
width
)
T
:
:
from_computed_value
(
&
computed
.
height
)
)
}
}
impl
<
T
>
ToComputedValue
for
Vec
<
T
>
where
T
:
ToComputedValue
{
type
ComputedValue
=
Vec
<
<
T
as
ToComputedValue
>
:
:
ComputedValue
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
self
.
iter
(
)
.
map
(
|
item
|
item
.
to_computed_value
(
context
)
)
.
collect
(
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
computed
.
iter
(
)
.
map
(
T
:
:
from_computed_value
)
.
collect
(
)
}
}
impl
<
T
>
ToComputedValue
for
Box
<
T
>
where
T
:
ToComputedValue
{
type
ComputedValue
=
Box
<
<
T
as
ToComputedValue
>
:
:
ComputedValue
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
Box
:
:
new
(
T
:
:
to_computed_value
(
self
context
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
Box
:
:
new
(
T
:
:
from_computed_value
(
computed
)
)
}
}
impl
<
T
>
ToComputedValue
for
Box
<
[
T
]
>
where
T
:
ToComputedValue
{
type
ComputedValue
=
Box
<
[
<
T
as
ToComputedValue
>
:
:
ComputedValue
]
>
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
self
.
iter
(
)
.
map
(
|
item
|
item
.
to_computed_value
(
context
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
into_boxed_slice
(
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
computed
.
iter
(
)
.
map
(
T
:
:
from_computed_value
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
into_boxed_slice
(
)
}
}
trivial_to_computed_value
!
(
(
)
)
;
trivial_to_computed_value
!
(
bool
)
;
trivial_to_computed_value
!
(
f32
)
;
trivial_to_computed_value
!
(
i32
)
;
trivial_to_computed_value
!
(
u8
)
;
trivial_to_computed_value
!
(
u16
)
;
trivial_to_computed_value
!
(
u32
)
;
trivial_to_computed_value
!
(
Atom
)
;
trivial_to_computed_value
!
(
BorderStyle
)
;
trivial_to_computed_value
!
(
CursorKind
)
;
trivial_to_computed_value
!
(
Namespace
)
;
trivial_to_computed_value
!
(
String
)
;
trivial_to_computed_value
!
(
Box
<
str
>
)
;
pub
type
Number
=
CSSFloat
;
pub
type
NonNegativeNumber
=
NonNegative
<
CSSFloat
>
;
impl
From
<
CSSFloat
>
for
NonNegativeNumber
{
#
[
inline
]
fn
from
(
number
:
CSSFloat
)
-
>
NonNegativeNumber
{
NonNegative
:
:
<
CSSFloat
>
(
number
)
}
}
impl
From
<
NonNegativeNumber
>
for
CSSFloat
{
#
[
inline
]
fn
from
(
number
:
NonNegativeNumber
)
-
>
CSSFloat
{
number
.
0
}
}
pub
type
GreaterThanOrEqualToOneNumber
=
GreaterThanOrEqualToOne
<
CSSFloat
>
;
impl
From
<
CSSFloat
>
for
GreaterThanOrEqualToOneNumber
{
#
[
inline
]
fn
from
(
number
:
CSSFloat
)
-
>
GreaterThanOrEqualToOneNumber
{
GreaterThanOrEqualToOne
:
:
<
CSSFloat
>
(
number
)
}
}
impl
From
<
GreaterThanOrEqualToOneNumber
>
for
CSSFloat
{
#
[
inline
]
fn
from
(
number
:
GreaterThanOrEqualToOneNumber
)
-
>
CSSFloat
{
number
.
0
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
ComputeSquaredDistance
Copy
Debug
MallocSizeOf
PartialEq
ToCss
)
]
pub
enum
NumberOrPercentage
{
Percentage
(
Percentage
)
Number
(
Number
)
}
impl
ToComputedValue
for
specified
:
:
NumberOrPercentage
{
type
ComputedValue
=
NumberOrPercentage
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
NumberOrPercentage
{
match
*
self
{
specified
:
:
NumberOrPercentage
:
:
Percentage
(
percentage
)
=
>
NumberOrPercentage
:
:
Percentage
(
percentage
.
to_computed_value
(
context
)
)
specified
:
:
NumberOrPercentage
:
:
Number
(
number
)
=
>
NumberOrPercentage
:
:
Number
(
number
.
to_computed_value
(
context
)
)
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
NumberOrPercentage
)
-
>
Self
{
match
*
computed
{
NumberOrPercentage
:
:
Percentage
(
percentage
)
=
>
specified
:
:
NumberOrPercentage
:
:
Percentage
(
ToComputedValue
:
:
from_computed_value
(
&
percentage
)
)
NumberOrPercentage
:
:
Number
(
number
)
=
>
specified
:
:
NumberOrPercentage
:
:
Number
(
ToComputedValue
:
:
from_computed_value
(
&
number
)
)
}
}
}
pub
type
Opacity
=
CSSFloat
;
pub
type
Integer
=
CSSInteger
;
pub
type
IntegerOrAuto
=
Either
<
CSSInteger
Auto
>
;
impl
IntegerOrAuto
{
pub
fn
integer_or
(
&
self
auto_value
:
CSSInteger
)
-
>
CSSInteger
{
match
*
self
{
Either
:
:
First
(
n
)
=
>
n
Either
:
:
Second
(
Auto
)
=
>
auto_value
}
}
}
pub
type
PositiveInteger
=
GreaterThanOrEqualToOne
<
CSSInteger
>
;
impl
From
<
CSSInteger
>
for
PositiveInteger
{
#
[
inline
]
fn
from
(
int
:
CSSInteger
)
-
>
PositiveInteger
{
GreaterThanOrEqualToOne
:
:
<
CSSInteger
>
(
int
)
}
}
pub
type
PositiveIntegerOrAuto
=
Either
<
PositiveInteger
Auto
>
;
pub
type
LengthOrPercentageOrNumber
=
Either
<
Number
LengthOrPercentage
>
;
pub
type
NonNegativeLengthOrPercentageOrNumber
=
Either
<
NonNegativeNumber
NonNegativeLengthOrPercentage
>
;
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
ComputeSquaredDistance
Copy
Debug
PartialEq
)
]
pub
struct
ClipRect
{
pub
top
:
Option
<
Length
>
pub
right
:
Option
<
Length
>
pub
bottom
:
Option
<
Length
>
pub
left
:
Option
<
Length
>
}
impl
ToCss
for
ClipRect
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
dest
.
write_str
(
"
rect
(
"
)
?
;
if
let
Some
(
top
)
=
self
.
top
{
top
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
}
else
{
dest
.
write_str
(
"
auto
"
)
?
;
}
if
let
Some
(
right
)
=
self
.
right
{
right
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
}
else
{
dest
.
write_str
(
"
auto
"
)
?
;
}
if
let
Some
(
bottom
)
=
self
.
bottom
{
bottom
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
}
else
{
dest
.
write_str
(
"
auto
"
)
?
;
}
if
let
Some
(
left
)
=
self
.
left
{
left
.
to_css
(
dest
)
?
;
}
else
{
dest
.
write_str
(
"
auto
"
)
?
;
}
dest
.
write_str
(
"
)
"
)
}
}
pub
type
ClipRectOrAuto
=
Either
<
ClipRect
Auto
>
;
pub
type
TrackBreadth
=
GenericTrackBreadth
<
LengthOrPercentage
>
;
pub
type
TrackSize
=
GenericTrackSize
<
LengthOrPercentage
>
;
pub
type
TrackList
=
GenericTrackList
<
LengthOrPercentage
Integer
>
;
pub
type
GridLine
=
GenericGridLine
<
Integer
>
;
pub
type
GridTemplateComponent
=
GenericGridTemplateComponent
<
LengthOrPercentage
Integer
>
;
impl
ClipRectOrAuto
{
pub
fn
auto
(
)
-
>
Self
{
Either
:
:
Second
(
Auto
)
}
pub
fn
is_auto
(
&
self
)
-
>
bool
{
match
*
self
{
Either
:
:
Second
(
_
)
=
>
true
_
=
>
false
}
}
}
pub
type
ColorOrAuto
=
Either
<
Color
Auto
>
;
#
[
cfg
(
feature
=
"
servo
"
)
]
#
[
derive
(
Clone
Debug
Deserialize
MallocSizeOf
PartialEq
Serialize
)
]
pub
enum
ComputedUrl
{
Invalid
(
#
[
ignore_malloc_size_of
=
"
Arc
"
]
Arc
<
String
>
)
Valid
(
ServoUrl
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
type
ComputedUrl
=
specified
:
:
url
:
:
SpecifiedUrl
;
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
ComputedUrl
{
pub
fn
url
(
&
self
)
-
>
Option
<
&
ServoUrl
>
{
match
*
self
{
ComputedUrl
:
:
Valid
(
ref
url
)
=
>
Some
(
url
)
_
=
>
None
}
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
ToCss
for
ComputedUrl
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
let
string
=
match
*
self
{
ComputedUrl
:
:
Valid
(
ref
url
)
=
>
url
.
as_str
(
)
ComputedUrl
:
:
Invalid
(
ref
invalid_string
)
=
>
invalid_string
}
;
dest
.
write_str
(
"
url
(
"
)
?
;
string
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
}
pub
type
UrlOrNone
=
Either
<
ComputedUrl
None_
>
;
