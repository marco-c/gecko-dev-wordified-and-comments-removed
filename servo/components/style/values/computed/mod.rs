use
context
:
:
QuirksMode
;
use
euclid
:
:
size
:
:
Size2D
;
use
font_metrics
:
:
FontMetricsProvider
;
use
media_queries
:
:
Device
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
properties
;
use
properties
:
:
{
ComputedValues
StyleBuilder
}
;
use
std
:
:
f32
;
use
std
:
:
f32
:
:
consts
:
:
PI
;
use
std
:
:
fmt
;
use
style_traits
:
:
ToCss
;
use
super
:
:
{
CSSFloat
CSSInteger
RGBA
}
;
use
super
:
:
generics
:
:
BorderRadiusSize
as
GenericBorderRadiusSize
;
use
super
:
:
specified
;
use
super
:
:
specified
:
:
grid
:
:
{
TrackBreadth
as
GenericTrackBreadth
TrackSize
as
GenericTrackSize
}
;
pub
use
app_units
:
:
Au
;
pub
use
cssparser
:
:
Color
as
CSSColor
;
pub
use
self
:
:
image
:
:
{
Gradient
GradientItem
ImageLayer
LineDirection
Image
ImageRect
}
;
pub
use
super
:
:
{
Auto
Either
None_
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
super
:
:
specified
:
:
{
AlignItems
AlignJustifyContent
AlignJustifySelf
JustifyItems
}
;
pub
use
super
:
:
specified
:
:
{
BorderStyle
GridLine
Percentage
UrlOrNone
}
;
pub
use
super
:
:
specified
:
:
url
:
:
SpecifiedUrl
;
pub
use
self
:
:
length
:
:
{
CalcLengthOrPercentage
Length
LengthOrNumber
LengthOrPercentage
LengthOrPercentageOrAuto
}
;
pub
use
self
:
:
length
:
:
{
LengthOrPercentageOrAutoOrContent
LengthOrPercentageOrNone
LengthOrNone
}
;
pub
use
self
:
:
length
:
:
{
MaxLength
MinLength
}
;
pub
use
self
:
:
position
:
:
Position
;
pub
mod
basic_shape
;
pub
mod
image
;
pub
mod
length
;
pub
mod
position
;
pub
struct
Context
<
'
a
>
{
pub
is_root_element
:
bool
pub
device
:
&
'
a
Device
pub
inherited_style
:
&
'
a
ComputedValues
pub
layout_parent_style
:
&
'
a
ComputedValues
pub
style
:
StyleBuilder
<
'
a
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
cached_system_font
:
Option
<
properties
:
:
longhands
:
:
system_font
:
:
ComputedSystemFont
>
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
cached_system_font
:
Option
<
(
)
>
pub
font_metrics_provider
:
&
'
a
FontMetricsProvider
pub
in_media_query
:
bool
pub
quirks_mode
:
QuirksMode
}
impl
<
'
a
>
Context
<
'
a
>
{
pub
fn
is_root_element
(
&
self
)
-
>
bool
{
self
.
is_root_element
}
pub
fn
viewport_size
(
&
self
)
-
>
Size2D
<
Au
>
{
self
.
device
.
au_viewport_size
(
)
}
pub
fn
inherited_style
(
&
self
)
-
>
&
ComputedValues
{
&
self
.
inherited_style
}
pub
fn
style
(
&
self
)
-
>
&
StyleBuilder
{
&
self
.
style
}
pub
fn
mutate_style
(
&
mut
self
)
-
>
&
mut
StyleBuilder
<
'
a
>
{
&
mut
self
.
style
}
}
#
[
derive
(
Clone
)
]
pub
struct
ComputedVecIter
<
'
a
'
cx
'
cx_a
:
'
cx
S
:
ToComputedValue
+
'
a
>
{
cx
:
&
'
cx
Context
<
'
cx_a
>
values
:
&
'
a
[
S
]
}
impl
<
'
a
'
cx
'
cx_a
:
'
cx
S
:
ToComputedValue
+
'
a
>
ComputedVecIter
<
'
a
'
cx
'
cx_a
S
>
{
pub
fn
new
(
cx
:
&
'
cx
Context
<
'
cx_a
>
values
:
&
'
a
[
S
]
)
-
>
Self
{
ComputedVecIter
{
cx
:
cx
values
:
values
}
}
}
impl
<
'
a
'
cx
'
cx_a
:
'
cx
S
:
ToComputedValue
+
'
a
>
ExactSizeIterator
for
ComputedVecIter
<
'
a
'
cx
'
cx_a
S
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
values
.
len
(
)
}
}
impl
<
'
a
'
cx
'
cx_a
:
'
cx
S
:
ToComputedValue
+
'
a
>
Iterator
for
ComputedVecIter
<
'
a
'
cx
'
cx_a
S
>
{
type
Item
=
S
:
:
ComputedValue
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
let
Some
(
(
next
rest
)
)
=
self
.
values
.
split_first
(
)
{
let
ret
=
next
.
to_computed_value
(
self
.
cx
)
;
self
.
values
=
rest
;
Some
(
ret
)
}
else
{
None
}
}
}
pub
trait
ToComputedValue
{
type
ComputedValue
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
;
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
;
}
pub
trait
ComputedValueAsSpecified
{
}
impl
<
T
>
ToComputedValue
for
T
where
T
:
ComputedValueAsSpecified
+
Clone
{
type
ComputedValue
=
T
;
#
[
inline
]
fn
to_computed_value
(
&
self
_context
:
&
Context
)
-
>
T
{
self
.
clone
(
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
T
)
-
>
Self
{
computed
.
clone
(
)
}
}
#
[
derive
(
Clone
PartialEq
PartialOrd
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
Deserialize
Serialize
)
)
]
pub
enum
Angle
{
Degree
(
CSSFloat
)
Gradian
(
CSSFloat
)
Radian
(
CSSFloat
)
Turn
(
CSSFloat
)
}
impl
Angle
{
pub
fn
from_radians
(
radians
:
CSSFloat
)
-
>
Self
{
Angle
:
:
Radian
(
radians
)
}
#
[
inline
]
pub
fn
radians
(
&
self
)
-
>
CSSFloat
{
const
RAD_PER_DEG
:
CSSFloat
=
PI
/
180
.
0
;
const
RAD_PER_GRAD
:
CSSFloat
=
PI
/
200
.
0
;
const
RAD_PER_TURN
:
CSSFloat
=
PI
*
2
.
0
;
let
radians
=
match
*
self
{
Angle
:
:
Degree
(
val
)
=
>
val
*
RAD_PER_DEG
Angle
:
:
Gradian
(
val
)
=
>
val
*
RAD_PER_GRAD
Angle
:
:
Turn
(
val
)
=
>
val
*
RAD_PER_TURN
Angle
:
:
Radian
(
val
)
=
>
val
}
;
radians
.
min
(
f32
:
:
MAX
)
.
max
(
f32
:
:
MIN
)
}
pub
fn
zero
(
)
-
>
Self
{
Angle
:
:
Radian
(
0
.
0
)
}
}
impl
ToCss
for
Angle
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
Angle
:
:
Degree
(
val
)
=
>
write
!
(
dest
"
{
}
deg
"
val
)
Angle
:
:
Gradian
(
val
)
=
>
write
!
(
dest
"
{
}
grad
"
val
)
Angle
:
:
Radian
(
val
)
=
>
write
!
(
dest
"
{
}
rad
"
val
)
Angle
:
:
Turn
(
val
)
=
>
write
!
(
dest
"
{
}
turn
"
val
)
}
}
}
#
[
derive
(
Clone
PartialEq
PartialOrd
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
Deserialize
Serialize
)
)
]
pub
struct
Time
{
seconds
:
CSSFloat
}
impl
Time
{
pub
fn
from_seconds
(
seconds
:
CSSFloat
)
-
>
Self
{
Time
{
seconds
:
seconds
}
}
pub
fn
zero
(
)
-
>
Self
{
Self
:
:
from_seconds
(
0
.
0
)
}
#
[
inline
]
pub
fn
seconds
(
&
self
)
-
>
CSSFloat
{
self
.
seconds
}
}
impl
ToCss
for
Time
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
write
!
(
dest
"
{
}
s
"
self
.
seconds
(
)
)
}
}
impl
ToComputedValue
for
specified
:
:
Color
{
type
ComputedValue
=
RGBA
;
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
RGBA
{
match
*
self
{
specified
:
:
Color
:
:
RGBA
(
rgba
)
=
>
rgba
specified
:
:
Color
:
:
CurrentColor
=
>
context
.
inherited_style
.
get_color
(
)
.
clone_color
(
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
RGBA
{
use
gecko
:
:
values
:
:
convert_nscolor_to_rgba
as
to_rgba
;
let
pres_context
=
unsafe
{
&
*
context
.
device
.
pres_context
}
;
match
*
self
{
specified
:
:
Color
:
:
RGBA
(
rgba
)
=
>
rgba
specified
:
:
Color
:
:
System
(
system
)
=
>
to_rgba
(
system
.
to_computed_value
(
context
)
)
specified
:
:
Color
:
:
CurrentColor
=
>
context
.
inherited_style
.
get_color
(
)
.
clone_color
(
)
specified
:
:
Color
:
:
MozDefaultColor
=
>
to_rgba
(
pres_context
.
mDefaultColor
)
specified
:
:
Color
:
:
MozDefaultBackgroundColor
=
>
to_rgba
(
pres_context
.
mBackgroundColor
)
specified
:
:
Color
:
:
MozHyperlinktext
=
>
to_rgba
(
pres_context
.
mLinkColor
)
specified
:
:
Color
:
:
MozActiveHyperlinktext
=
>
to_rgba
(
pres_context
.
mActiveLinkColor
)
specified
:
:
Color
:
:
MozVisitedHyperlinktext
=
>
to_rgba
(
pres_context
.
mVisitedLinkColor
)
specified
:
:
Color
:
:
InheritFromBodyQuirk
=
>
{
use
dom
:
:
TElement
;
use
gecko
:
:
wrapper
:
:
GeckoElement
;
use
gecko_bindings
:
:
bindings
:
:
Gecko_GetBody
;
let
body
=
unsafe
{
Gecko_GetBody
(
pres_context
)
}
;
if
let
Some
(
body
)
=
body
{
let
wrap
=
GeckoElement
(
body
)
;
let
borrow
=
wrap
.
borrow_data
(
)
;
borrow
.
as_ref
(
)
.
unwrap
(
)
.
styles
(
)
.
primary
.
values
(
)
.
get_color
(
)
.
clone_color
(
)
}
else
{
to_rgba
(
pres_context
.
mDefaultColor
)
}
}
}
}
fn
from_computed_value
(
computed
:
&
RGBA
)
-
>
Self
{
specified
:
:
Color
:
:
RGBA
(
*
computed
)
}
}
impl
ToComputedValue
for
specified
:
:
CSSColor
{
type
ComputedValue
=
CSSColor
;
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
#
[
inline
]
fn
to_computed_value
(
&
self
_context
:
&
Context
)
-
>
CSSColor
{
self
.
parsed
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
CSSColor
{
match
self
.
parsed
{
specified
:
:
Color
:
:
RGBA
(
rgba
)
=
>
CSSColor
:
:
RGBA
(
rgba
)
specified
:
:
Color
:
:
CurrentColor
=
>
CSSColor
:
:
CurrentColor
non_standard
=
>
CSSColor
:
:
RGBA
(
non_standard
.
to_computed_value
(
context
)
)
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
CSSColor
)
-
>
Self
{
(
match
*
computed
{
CSSColor
:
:
RGBA
(
rgba
)
=
>
specified
:
:
Color
:
:
RGBA
(
rgba
)
CSSColor
:
:
CurrentColor
=
>
specified
:
:
Color
:
:
CurrentColor
}
)
.
into
(
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ToComputedValue
for
specified
:
:
JustifyItems
{
type
ComputedValue
=
JustifyItems
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
JustifyItems
{
use
values
:
:
specified
:
:
align
;
if
self
.
0
=
=
align
:
:
ALIGN_AUTO
{
let
inherited
=
context
.
inherited_style
.
get_position
(
)
.
clone_justify_items
(
)
;
if
inherited
.
0
.
contains
(
align
:
:
ALIGN_LEGACY
)
{
return
inherited
}
}
return
*
self
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
JustifyItems
)
-
>
Self
{
*
computed
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ComputedValueAsSpecified
for
specified
:
:
AlignItems
{
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ComputedValueAsSpecified
for
specified
:
:
AlignJustifyContent
{
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ComputedValueAsSpecified
for
specified
:
:
AlignJustifySelf
{
}
impl
ComputedValueAsSpecified
for
specified
:
:
BorderStyle
{
}
pub
type
BorderRadiusSize
=
GenericBorderRadiusSize
<
LengthOrPercentage
>
;
impl
BorderRadiusSize
{
#
[
inline
]
pub
fn
zero
(
)
-
>
BorderRadiusSize
{
let
zero
=
LengthOrPercentage
:
:
zero
(
)
;
GenericBorderRadiusSize
(
Size2D
:
:
new
(
zero
.
clone
(
)
zero
)
)
}
}
impl
Copy
for
BorderRadiusSize
{
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
Shadow
{
pub
offset_x
:
Au
pub
offset_y
:
Au
pub
blur_radius
:
Au
pub
spread_radius
:
Au
pub
color
:
CSSColor
pub
inset
:
bool
}
pub
type
Number
=
CSSFloat
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
NumberOrPercentage
{
Percentage
(
Percentage
)
Number
(
Number
)
}
impl
ToComputedValue
for
specified
:
:
NumberOrPercentage
{
type
ComputedValue
=
NumberOrPercentage
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
NumberOrPercentage
{
match
*
self
{
specified
:
:
NumberOrPercentage
:
:
Percentage
(
percentage
)
=
>
NumberOrPercentage
:
:
Percentage
(
percentage
.
to_computed_value
(
context
)
)
specified
:
:
NumberOrPercentage
:
:
Number
(
number
)
=
>
NumberOrPercentage
:
:
Number
(
number
.
to_computed_value
(
context
)
)
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
NumberOrPercentage
)
-
>
Self
{
match
*
computed
{
NumberOrPercentage
:
:
Percentage
(
percentage
)
=
>
specified
:
:
NumberOrPercentage
:
:
Percentage
(
ToComputedValue
:
:
from_computed_value
(
&
percentage
)
)
NumberOrPercentage
:
:
Number
(
number
)
=
>
specified
:
:
NumberOrPercentage
:
:
Number
(
ToComputedValue
:
:
from_computed_value
(
&
number
)
)
}
}
}
impl
ToCss
for
NumberOrPercentage
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
NumberOrPercentage
:
:
Percentage
(
percentage
)
=
>
percentage
.
to_css
(
dest
)
NumberOrPercentage
:
:
Number
(
number
)
=
>
number
.
to_css
(
dest
)
}
}
}
pub
type
Opacity
=
CSSFloat
;
pub
type
Integer
=
CSSInteger
;
pub
type
IntegerOrAuto
=
Either
<
CSSInteger
Auto
>
;
impl
IntegerOrAuto
{
pub
fn
integer_or
(
&
self
auto_value
:
CSSInteger
)
-
>
CSSInteger
{
match
*
self
{
Either
:
:
First
(
n
)
=
>
n
Either
:
:
Second
(
Auto
)
=
>
auto_value
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
SVGPaint
{
pub
kind
:
SVGPaintKind
pub
fallback
:
Option
<
CSSColor
>
}
impl
Default
for
SVGPaint
{
fn
default
(
)
-
>
Self
{
SVGPaint
{
kind
:
SVGPaintKind
:
:
None
fallback
:
None
}
}
}
impl
SVGPaint
{
pub
fn
black
(
)
-
>
Self
{
let
rgba
=
RGBA
:
:
from_floats
(
0
.
0
.
0
.
1
.
)
;
SVGPaint
{
kind
:
SVGPaintKind
:
:
Color
(
CSSColor
:
:
RGBA
(
rgba
)
)
fallback
:
None
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
SVGPaintKind
{
None
Color
(
CSSColor
)
PaintServer
(
SpecifiedUrl
)
ContextFill
ContextStroke
}
impl
ToCss
for
SVGPaintKind
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
SVGPaintKind
:
:
None
=
>
dest
.
write_str
(
"
none
"
)
SVGPaintKind
:
:
ContextStroke
=
>
dest
.
write_str
(
"
context
-
stroke
"
)
SVGPaintKind
:
:
ContextFill
=
>
dest
.
write_str
(
"
context
-
fill
"
)
SVGPaintKind
:
:
Color
(
ref
color
)
=
>
color
.
to_css
(
dest
)
SVGPaintKind
:
:
PaintServer
(
ref
server
)
=
>
server
.
to_css
(
dest
)
}
}
}
impl
ToCss
for
SVGPaint
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
self
.
kind
.
to_css
(
dest
)
?
;
if
let
Some
(
ref
fallback
)
=
self
.
fallback
{
fallback
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
pub
type
LengthOrPercentageOrNumber
=
Either
<
Number
LengthOrPercentage
>
;
#
[
derive
(
Clone
PartialEq
Eq
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
ClipRect
{
pub
top
:
Option
<
Au
>
pub
right
:
Option
<
Au
>
pub
bottom
:
Option
<
Au
>
pub
left
:
Option
<
Au
>
}
impl
ToCss
for
ClipRect
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
rect
(
"
)
)
;
if
let
Some
(
top
)
=
self
.
top
{
try
!
(
top
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
"
)
)
;
}
else
{
try
!
(
dest
.
write_str
(
"
auto
"
)
)
;
}
if
let
Some
(
right
)
=
self
.
right
{
try
!
(
right
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
"
)
)
;
}
else
{
try
!
(
dest
.
write_str
(
"
auto
"
)
)
;
}
if
let
Some
(
bottom
)
=
self
.
bottom
{
try
!
(
bottom
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
"
)
)
;
}
else
{
try
!
(
dest
.
write_str
(
"
auto
"
)
)
;
}
if
let
Some
(
left
)
=
self
.
left
{
try
!
(
left
.
to_css
(
dest
)
)
;
}
else
{
try
!
(
dest
.
write_str
(
"
auto
"
)
)
;
}
dest
.
write_str
(
"
)
"
)
}
}
pub
type
ClipRectOrAuto
=
Either
<
ClipRect
Auto
>
;
pub
type
TrackBreadth
=
GenericTrackBreadth
<
LengthOrPercentage
>
;
pub
type
TrackSize
=
GenericTrackSize
<
LengthOrPercentage
>
;
impl
ClipRectOrAuto
{
pub
fn
auto
(
)
-
>
Self
{
Either
:
:
Second
(
Auto
)
}
pub
fn
is_auto
(
&
self
)
-
>
bool
{
match
*
self
{
Either
:
:
Second
(
_
)
=
>
true
_
=
>
false
}
}
}
pub
type
ColorOrAuto
=
Either
<
CSSColor
Auto
>
;
