use
cssparser
:
:
Color
as
CSSColor
;
use
std
:
:
f32
:
:
consts
:
:
PI
;
use
std
:
:
fmt
;
use
style_traits
:
:
ToCss
;
use
values
:
:
{
Either
None_
}
;
use
values
:
:
computed
:
:
{
Angle
Context
Length
LengthOrPercentage
NumberOrPercentage
ToComputedValue
}
;
use
values
:
:
computed
:
:
position
:
:
Position
;
use
values
:
:
generics
:
:
image
:
:
{
CompatMode
ColorStop
as
GenericColorStop
EndingShape
as
GenericEndingShape
}
;
use
values
:
:
generics
:
:
image
:
:
{
Gradient
as
GenericGradient
GradientItem
as
GenericGradientItem
}
;
use
values
:
:
generics
:
:
image
:
:
{
Image
as
GenericImage
GradientKind
as
GenericGradientKind
}
;
use
values
:
:
generics
:
:
image
:
:
{
ImageRect
as
GenericImageRect
LineDirection
as
GenericLineDirection
}
;
use
values
:
:
specified
:
:
image
:
:
LineDirection
as
SpecifiedLineDirection
;
use
values
:
:
specified
:
:
position
:
:
{
X
Y
}
;
pub
type
ImageLayer
=
Either
<
None_
Image
>
;
pub
type
Image
=
GenericImage
<
Gradient
ImageRect
>
;
pub
type
Gradient
=
GenericGradient
<
LineDirection
Length
LengthOrPercentage
Position
CSSColor
>
;
pub
type
GradientKind
=
GenericGradientKind
<
LineDirection
Length
LengthOrPercentage
Position
>
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
LineDirection
{
Angle
(
Angle
)
Corner
(
X
Y
)
}
pub
type
EndingShape
=
GenericEndingShape
<
Length
LengthOrPercentage
>
;
pub
type
GradientItem
=
GenericGradientItem
<
CSSColor
LengthOrPercentage
>
;
pub
type
ColorStop
=
GenericColorStop
<
CSSColor
LengthOrPercentage
>
;
pub
type
ImageRect
=
GenericImageRect
<
NumberOrPercentage
>
;
impl
GenericLineDirection
for
LineDirection
{
fn
points_downwards
(
&
self
)
-
>
bool
{
match
*
self
{
LineDirection
:
:
Angle
(
angle
)
=
>
angle
.
radians
(
)
=
=
PI
LineDirection
:
:
Corner
(
.
.
)
=
>
false
}
}
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
compat_mode
:
CompatMode
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
LineDirection
:
:
Angle
(
ref
angle
)
=
>
angle
.
to_css
(
dest
)
LineDirection
:
:
Corner
(
x
y
)
=
>
{
if
compat_mode
=
=
CompatMode
:
:
Modern
{
dest
.
write_str
(
"
to
"
)
?
;
}
x
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
y
.
to_css
(
dest
)
}
}
}
}
impl
ToComputedValue
for
SpecifiedLineDirection
{
type
ComputedValue
=
LineDirection
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
match
*
self
{
SpecifiedLineDirection
:
:
Angle
(
ref
angle
)
=
>
{
LineDirection
:
:
Angle
(
angle
.
to_computed_value
(
context
)
)
}
SpecifiedLineDirection
:
:
Horizontal
(
X
:
:
Left
)
=
>
{
LineDirection
:
:
Angle
(
Angle
:
:
Degree
(
270
.
)
)
}
SpecifiedLineDirection
:
:
Horizontal
(
X
:
:
Right
)
=
>
{
LineDirection
:
:
Angle
(
Angle
:
:
Degree
(
90
.
)
)
}
SpecifiedLineDirection
:
:
Vertical
(
Y
:
:
Top
)
=
>
{
LineDirection
:
:
Angle
(
Angle
:
:
Degree
(
0
.
)
)
}
SpecifiedLineDirection
:
:
Vertical
(
Y
:
:
Bottom
)
=
>
{
LineDirection
:
:
Angle
(
Angle
:
:
Degree
(
180
.
)
)
}
SpecifiedLineDirection
:
:
Corner
(
x
y
)
=
>
{
LineDirection
:
:
Corner
(
x
y
)
}
}
}
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
match
*
computed
{
LineDirection
:
:
Angle
(
ref
angle
)
=
>
{
SpecifiedLineDirection
:
:
Angle
(
ToComputedValue
:
:
from_computed_value
(
angle
)
)
}
LineDirection
:
:
Corner
(
x
y
)
=
>
{
SpecifiedLineDirection
:
:
Corner
(
x
y
)
}
}
}
}
