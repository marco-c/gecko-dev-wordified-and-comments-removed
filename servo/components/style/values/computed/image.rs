use
crate
:
:
values
:
:
computed
:
:
position
:
:
Position
;
use
crate
:
:
values
:
:
computed
:
:
url
:
:
ComputedImageUrl
;
use
crate
:
:
values
:
:
computed
:
:
{
Angle
Color
Context
}
;
use
crate
:
:
values
:
:
computed
:
:
{
Length
LengthPercentage
NumberOrPercentage
ToComputedValue
}
;
use
crate
:
:
values
:
:
generics
:
:
image
:
:
{
self
as
generic
CompatMode
}
;
use
crate
:
:
values
:
:
specified
:
:
image
:
:
LineDirection
as
SpecifiedLineDirection
;
use
crate
:
:
values
:
:
specified
:
:
position
:
:
{
X
Y
}
;
use
crate
:
:
values
:
:
{
Either
None_
}
;
use
std
:
:
f32
:
:
consts
:
:
PI
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
pub
type
ImageLayer
=
Either
<
None_
Image
>
;
pub
type
Image
=
generic
:
:
Image
<
Gradient
MozImageRect
ComputedImageUrl
>
;
pub
type
Gradient
=
generic
:
:
Gradient
<
LineDirection
Length
LengthPercentage
Position
Color
>
;
pub
type
GradientKind
=
generic
:
:
GradientKind
<
LineDirection
Length
LengthPercentage
Position
>
;
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToResolvedValue
)
]
pub
enum
LineDirection
{
Angle
(
Angle
)
Horizontal
(
X
)
Vertical
(
Y
)
Corner
(
X
Y
)
}
pub
type
EndingShape
=
generic
:
:
EndingShape
<
Length
LengthPercentage
>
;
pub
type
GradientItem
=
generic
:
:
GenericGradientItem
<
Color
LengthPercentage
>
;
pub
type
ColorStop
=
generic
:
:
ColorStop
<
Color
LengthPercentage
>
;
pub
type
MozImageRect
=
generic
:
:
MozImageRect
<
NumberOrPercentage
ComputedImageUrl
>
;
impl
generic
:
:
LineDirection
for
LineDirection
{
fn
points_downwards
(
&
self
compat_mode
:
CompatMode
)
-
>
bool
{
match
*
self
{
LineDirection
:
:
Angle
(
angle
)
=
>
angle
.
radians
(
)
=
=
PI
LineDirection
:
:
Vertical
(
Y
:
:
Bottom
)
if
compat_mode
=
=
CompatMode
:
:
Modern
=
>
true
LineDirection
:
:
Vertical
(
Y
:
:
Top
)
if
compat_mode
!
=
CompatMode
:
:
Modern
=
>
true
_
=
>
false
}
}
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
compat_mode
:
CompatMode
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
*
self
{
LineDirection
:
:
Angle
(
ref
angle
)
=
>
angle
.
to_css
(
dest
)
LineDirection
:
:
Horizontal
(
x
)
=
>
{
if
compat_mode
=
=
CompatMode
:
:
Modern
{
dest
.
write_str
(
"
to
"
)
?
;
}
x
.
to_css
(
dest
)
}
LineDirection
:
:
Vertical
(
y
)
=
>
{
if
compat_mode
=
=
CompatMode
:
:
Modern
{
dest
.
write_str
(
"
to
"
)
?
;
}
y
.
to_css
(
dest
)
}
LineDirection
:
:
Corner
(
x
y
)
=
>
{
if
compat_mode
=
=
CompatMode
:
:
Modern
{
dest
.
write_str
(
"
to
"
)
?
;
}
x
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
y
.
to_css
(
dest
)
}
}
}
}
impl
ToComputedValue
for
SpecifiedLineDirection
{
type
ComputedValue
=
LineDirection
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
match
*
self
{
SpecifiedLineDirection
:
:
Angle
(
ref
angle
)
=
>
{
LineDirection
:
:
Angle
(
angle
.
to_computed_value
(
context
)
)
}
SpecifiedLineDirection
:
:
Horizontal
(
x
)
=
>
LineDirection
:
:
Horizontal
(
x
)
SpecifiedLineDirection
:
:
Vertical
(
y
)
=
>
LineDirection
:
:
Vertical
(
y
)
SpecifiedLineDirection
:
:
Corner
(
x
y
)
=
>
LineDirection
:
:
Corner
(
x
y
)
}
}
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
match
*
computed
{
LineDirection
:
:
Angle
(
ref
angle
)
=
>
{
SpecifiedLineDirection
:
:
Angle
(
ToComputedValue
:
:
from_computed_value
(
angle
)
)
}
LineDirection
:
:
Horizontal
(
x
)
=
>
SpecifiedLineDirection
:
:
Horizontal
(
x
)
LineDirection
:
:
Vertical
(
y
)
=
>
SpecifiedLineDirection
:
:
Vertical
(
y
)
LineDirection
:
:
Corner
(
x
y
)
=
>
SpecifiedLineDirection
:
:
Corner
(
x
y
)
}
}
}
