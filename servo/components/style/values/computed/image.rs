use
crate
:
:
values
:
:
computed
:
:
position
:
:
Position
;
use
crate
:
:
values
:
:
computed
:
:
url
:
:
ComputedImageUrl
;
use
crate
:
:
values
:
:
computed
:
:
{
Angle
Color
Context
}
;
use
crate
:
:
values
:
:
computed
:
:
{
Length
LengthPercentage
NumberOrPercentage
ToComputedValue
}
;
use
crate
:
:
values
:
:
generics
:
:
image
:
:
{
self
as
generic
CompatMode
}
;
use
crate
:
:
values
:
:
specified
:
:
image
:
:
LineDirection
as
SpecifiedLineDirection
;
use
crate
:
:
values
:
:
specified
:
:
position
:
:
{
X
Y
}
;
use
crate
:
:
values
:
:
{
Either
None_
}
;
use
std
:
:
f32
:
:
consts
:
:
PI
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
pub
type
ImageLayer
=
Either
<
None_
Image
>
;
pub
type
Image
=
generic
:
:
Image
<
Gradient
MozImageRect
ComputedImageUrl
>
;
pub
type
Gradient
=
generic
:
:
Gradient
<
LineDirection
Length
LengthPercentage
Position
Color
Angle
>
;
pub
type
GradientKind
=
generic
:
:
GradientKind
<
LineDirection
Length
LengthPercentage
Position
Angle
>
;
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToResolvedValue
)
]
pub
enum
LineDirection
{
Angle
(
Angle
)
Horizontal
(
X
)
Vertical
(
Y
)
Corner
(
X
Y
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
MozPosition
(
Option
<
Position
>
Option
<
Angle
>
)
}
pub
type
EndingShape
=
generic
:
:
EndingShape
<
Length
LengthPercentage
>
;
pub
type
GradientItem
=
generic
:
:
GradientItem
<
Color
LengthPercentage
>
;
pub
type
ColorStop
=
generic
:
:
ColorStop
<
Color
LengthPercentage
>
;
pub
type
MozImageRect
=
generic
:
:
MozImageRect
<
NumberOrPercentage
ComputedImageUrl
>
;
impl
generic
:
:
LineDirection
for
LineDirection
{
fn
points_downwards
(
&
self
compat_mode
:
CompatMode
)
-
>
bool
{
match
*
self
{
LineDirection
:
:
Angle
(
angle
)
=
>
angle
.
radians
(
)
=
=
PI
LineDirection
:
:
Vertical
(
Y
:
:
Bottom
)
if
compat_mode
=
=
CompatMode
:
:
Modern
=
>
true
LineDirection
:
:
Vertical
(
Y
:
:
Top
)
if
compat_mode
!
=
CompatMode
:
:
Modern
=
>
true
LineDirection
:
:
Corner
(
.
.
)
=
>
false
#
[
cfg
(
feature
=
"
gecko
"
)
]
LineDirection
:
:
MozPosition
(
Some
(
Position
{
ref
vertical
ref
horizontal
}
)
None
)
=
>
{
horizontal
.
as_percentage
(
)
.
map_or
(
false
|
p
|
p
.
0
=
=
0
.
5
)
&
&
vertical
.
as_percentage
(
)
.
map_or
(
false
|
p
|
p
.
0
=
=
0
.
0
)
}
_
=
>
false
}
}
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
compat_mode
:
CompatMode
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
*
self
{
LineDirection
:
:
Angle
(
ref
angle
)
=
>
angle
.
to_css
(
dest
)
LineDirection
:
:
Horizontal
(
x
)
=
>
{
if
compat_mode
=
=
CompatMode
:
:
Modern
{
dest
.
write_str
(
"
to
"
)
?
;
}
x
.
to_css
(
dest
)
}
LineDirection
:
:
Vertical
(
y
)
=
>
{
if
compat_mode
=
=
CompatMode
:
:
Modern
{
dest
.
write_str
(
"
to
"
)
?
;
}
y
.
to_css
(
dest
)
}
LineDirection
:
:
Corner
(
x
y
)
=
>
{
if
compat_mode
=
=
CompatMode
:
:
Modern
{
dest
.
write_str
(
"
to
"
)
?
;
}
x
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
y
.
to_css
(
dest
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
LineDirection
:
:
MozPosition
(
position
angle
)
=
>
{
let
mut
need_space
=
false
;
if
let
Some
(
position
)
=
position
{
position
.
to_css
(
dest
)
?
;
need_space
=
true
;
}
if
let
Some
(
angle
)
=
angle
{
if
need_space
{
dest
.
write_str
(
"
"
)
?
;
}
angle
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
}
}
impl
ToComputedValue
for
SpecifiedLineDirection
{
type
ComputedValue
=
LineDirection
;
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
match
*
self
{
SpecifiedLineDirection
:
:
Angle
(
ref
angle
)
=
>
{
LineDirection
:
:
Angle
(
angle
.
to_computed_value
(
context
)
)
}
SpecifiedLineDirection
:
:
Horizontal
(
x
)
=
>
LineDirection
:
:
Horizontal
(
x
)
SpecifiedLineDirection
:
:
Vertical
(
y
)
=
>
LineDirection
:
:
Vertical
(
y
)
SpecifiedLineDirection
:
:
Corner
(
x
y
)
=
>
LineDirection
:
:
Corner
(
x
y
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
SpecifiedLineDirection
:
:
MozPosition
(
ref
position
ref
angle
)
=
>
{
LineDirection
:
:
MozPosition
(
position
.
to_computed_value
(
context
)
angle
.
to_computed_value
(
context
)
)
}
}
}
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
match
*
computed
{
LineDirection
:
:
Angle
(
ref
angle
)
=
>
{
SpecifiedLineDirection
:
:
Angle
(
ToComputedValue
:
:
from_computed_value
(
angle
)
)
}
LineDirection
:
:
Horizontal
(
x
)
=
>
SpecifiedLineDirection
:
:
Horizontal
(
x
)
LineDirection
:
:
Vertical
(
y
)
=
>
SpecifiedLineDirection
:
:
Vertical
(
y
)
LineDirection
:
:
Corner
(
x
y
)
=
>
SpecifiedLineDirection
:
:
Corner
(
x
y
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
LineDirection
:
:
MozPosition
(
ref
position
ref
angle
)
=
>
{
SpecifiedLineDirection
:
:
MozPosition
(
ToComputedValue
:
:
from_computed_value
(
position
)
ToComputedValue
:
:
from_computed_value
(
angle
)
)
}
}
}
}
