use
values
:
:
computed
:
:
{
Context
Number
ToComputedValue
}
;
use
values
:
:
computed
:
:
length
:
:
{
LengthOrPercentage
NonNegativeLength
}
;
use
values
:
:
generics
:
:
box_
:
:
AnimationIterationCount
as
GenericAnimationIterationCount
;
use
values
:
:
generics
:
:
box_
:
:
Perspective
as
GenericPerspective
;
use
values
:
:
generics
:
:
box_
:
:
VerticalAlign
as
GenericVerticalAlign
;
pub
use
values
:
:
specified
:
:
box_
:
:
{
AnimationName
Contain
Display
OverflowClipBox
}
;
pub
use
values
:
:
specified
:
:
box_
:
:
{
Clear
as
SpecifiedClear
Float
as
SpecifiedFloat
}
;
pub
use
values
:
:
specified
:
:
box_
:
:
{
OverscrollBehavior
ScrollSnapType
TouchAction
TransitionProperty
WillChange
}
;
pub
type
VerticalAlign
=
GenericVerticalAlign
<
LengthOrPercentage
>
;
pub
type
AnimationIterationCount
=
GenericAnimationIterationCount
<
Number
>
;
impl
AnimationIterationCount
{
#
[
inline
]
pub
fn
one
(
)
-
>
Self
{
GenericAnimationIterationCount
:
:
Number
(
1
.
0
)
}
}
pub
type
Perspective
=
GenericPerspective
<
NonNegativeLength
>
;
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToCss
)
]
pub
enum
Float
{
Left
Right
None
}
impl
ToComputedValue
for
SpecifiedFloat
{
type
ComputedValue
=
Float
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
let
ltr
=
context
.
style
(
)
.
writing_mode
.
is_bidi_ltr
(
)
;
match
*
self
{
SpecifiedFloat
:
:
InlineStart
=
>
{
context
.
rule_cache_conditions
.
borrow_mut
(
)
.
set_writing_mode_dependency
(
context
.
builder
.
writing_mode
)
;
if
ltr
{
Float
:
:
Left
}
else
{
Float
:
:
Right
}
}
SpecifiedFloat
:
:
InlineEnd
=
>
{
context
.
rule_cache_conditions
.
borrow_mut
(
)
.
set_writing_mode_dependency
(
context
.
builder
.
writing_mode
)
;
if
ltr
{
Float
:
:
Right
}
else
{
Float
:
:
Left
}
}
SpecifiedFloat
:
:
Left
=
>
Float
:
:
Left
SpecifiedFloat
:
:
Right
=
>
Float
:
:
Right
SpecifiedFloat
:
:
None
=
>
Float
:
:
None
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
SpecifiedFloat
{
match
*
computed
{
Float
:
:
Left
=
>
SpecifiedFloat
:
:
Left
Float
:
:
Right
=
>
SpecifiedFloat
:
:
Right
Float
:
:
None
=
>
SpecifiedFloat
:
:
None
}
}
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Parse
PartialEq
SpecifiedValueInfo
ToCss
)
]
pub
enum
Clear
{
None
Left
Right
Both
}
impl
ToComputedValue
for
SpecifiedClear
{
type
ComputedValue
=
Clear
;
#
[
inline
]
fn
to_computed_value
(
&
self
context
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
let
ltr
=
context
.
style
(
)
.
writing_mode
.
is_bidi_ltr
(
)
;
match
*
self
{
SpecifiedClear
:
:
InlineStart
=
>
{
context
.
rule_cache_conditions
.
borrow_mut
(
)
.
set_writing_mode_dependency
(
context
.
builder
.
writing_mode
)
;
if
ltr
{
Clear
:
:
Left
}
else
{
Clear
:
:
Right
}
}
SpecifiedClear
:
:
InlineEnd
=
>
{
context
.
rule_cache_conditions
.
borrow_mut
(
)
.
set_writing_mode_dependency
(
context
.
builder
.
writing_mode
)
;
if
ltr
{
Clear
:
:
Right
}
else
{
Clear
:
:
Left
}
}
SpecifiedClear
:
:
None
=
>
Clear
:
:
None
SpecifiedClear
:
:
Left
=
>
Clear
:
:
Left
SpecifiedClear
:
:
Right
=
>
Clear
:
:
Right
SpecifiedClear
:
:
Both
=
>
Clear
:
:
Both
}
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
SpecifiedClear
{
match
*
computed
{
Clear
:
:
None
=
>
SpecifiedClear
:
:
None
Clear
:
:
Left
=
>
SpecifiedClear
:
:
Left
Clear
:
:
Right
=
>
SpecifiedClear
:
:
Right
Clear
:
:
Both
=
>
SpecifiedClear
:
:
Both
}
}
}
