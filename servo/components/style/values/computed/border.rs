use
crate
:
:
properties
:
:
{
LogicalGroupId
LonghandId
}
;
use
crate
:
:
values
:
:
animated
:
:
{
Context
as
AnimatedContext
ToAnimatedValue
}
;
use
crate
:
:
values
:
:
computed
:
:
length
:
:
{
CSSPixelLength
NonNegativeLength
NonNegativeLengthPercentage
}
;
use
crate
:
:
values
:
:
computed
:
:
{
NonNegativeNumber
NonNegativeNumberOrPercentage
}
;
use
crate
:
:
values
:
:
generics
:
:
border
:
:
{
GenericBorderCornerRadius
GenericBorderImageSideWidth
GenericBorderImageSlice
GenericBorderRadius
GenericBorderSpacing
}
;
use
crate
:
:
values
:
:
generics
:
:
rect
:
:
Rect
;
use
crate
:
:
values
:
:
generics
:
:
size
:
:
Size2D
;
use
crate
:
:
values
:
:
generics
:
:
NonNegative
;
use
crate
:
:
values
:
:
resolved
:
:
{
Context
as
ResolvedContext
ToResolvedValue
}
;
use
crate
:
:
Zero
;
use
app_units
:
:
Au
;
pub
use
crate
:
:
values
:
:
specified
:
:
border
:
:
BorderImageRepeat
;
pub
type
LineWidth
=
Au
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToCss
ToTyped
From
)
]
#
[
repr
(
transparent
)
]
#
[
typed_value
(
derive_fields
)
]
pub
struct
BorderSideWidth
(
pub
Au
)
;
impl
BorderSideWidth
{
pub
fn
medium
(
)
-
>
Self
{
Self
(
Au
:
:
from_px
(
3
)
)
}
}
impl
ToAnimatedValue
for
BorderSideWidth
{
type
AnimatedValue
=
CSSPixelLength
;
#
[
inline
]
fn
to_animated_value
(
self
context
:
&
AnimatedContext
)
-
>
Self
:
:
AnimatedValue
{
self
.
0
.
to_animated_value
(
context
)
}
#
[
inline
]
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
Self
(
Au
:
:
from_animated_value
(
animated
)
)
}
}
impl
ToResolvedValue
for
BorderSideWidth
{
type
ResolvedValue
=
CSSPixelLength
;
fn
to_resolved_value
(
self
context
:
&
ResolvedContext
)
-
>
Self
:
:
ResolvedValue
{
let
resolved_length
=
CSSPixelLength
:
:
from
(
self
.
0
)
.
to_resolved_value
(
context
)
;
if
!
context
.
current_longhand
.
is_some_and
(
|
l
|
l
.
logical_group
(
)
=
=
Some
(
LogicalGroupId
:
:
BorderWidth
)
)
{
return
resolved_length
;
}
let
style
=
match
context
.
current_longhand
.
unwrap
(
)
{
LonghandId
:
:
BorderTopWidth
=
>
context
.
style
.
clone_border_top_style
(
)
LonghandId
:
:
BorderRightWidth
=
>
context
.
style
.
clone_border_right_style
(
)
LonghandId
:
:
BorderBottomWidth
=
>
context
.
style
.
clone_border_bottom_style
(
)
LonghandId
:
:
BorderLeftWidth
=
>
context
.
style
.
clone_border_left_style
(
)
_
=
>
{
debug_assert
!
(
false
"
Expected
a
physical
longhand
"
)
;
return
resolved_length
;
}
}
;
if
style
.
none_or_hidden
(
)
{
return
CSSPixelLength
:
:
new
(
0
.
0
)
;
}
resolved_length
}
#
[
inline
]
fn
from_resolved_value
(
value
:
Self
:
:
ResolvedValue
)
-
>
Self
{
Self
(
Au
:
:
from_f32_px
(
value
.
px
(
)
)
)
}
}
pub
type
BorderSideOffset
=
Au
;
pub
type
BorderImageWidth
=
Rect
<
BorderImageSideWidth
>
;
pub
type
BorderImageSideWidth
=
GenericBorderImageSideWidth
<
NonNegativeLengthPercentage
NonNegativeNumber
>
;
pub
type
BorderImageSlice
=
GenericBorderImageSlice
<
NonNegativeNumberOrPercentage
>
;
pub
type
BorderRadius
=
GenericBorderRadius
<
NonNegativeLengthPercentage
>
;
pub
type
BorderCornerRadius
=
GenericBorderCornerRadius
<
NonNegativeLengthPercentage
>
;
pub
type
BorderSpacing
=
GenericBorderSpacing
<
NonNegativeLength
>
;
impl
BorderImageSideWidth
{
#
[
inline
]
pub
fn
one
(
)
-
>
Self
{
GenericBorderImageSideWidth
:
:
Number
(
NonNegative
(
1
.
)
)
}
}
impl
BorderImageSlice
{
#
[
inline
]
pub
fn
hundred_percent
(
)
-
>
Self
{
GenericBorderImageSlice
{
offsets
:
Rect
:
:
all
(
NonNegativeNumberOrPercentage
:
:
hundred_percent
(
)
)
fill
:
false
}
}
}
impl
BorderSpacing
{
pub
fn
zero
(
)
-
>
Self
{
GenericBorderSpacing
(
Size2D
:
:
new
(
NonNegativeLength
:
:
zero
(
)
NonNegativeLength
:
:
zero
(
)
)
)
}
pub
fn
horizontal
(
&
self
)
-
>
Au
{
Au
:
:
from
(
*
self
.
0
.
width
(
)
)
}
pub
fn
vertical
(
&
self
)
-
>
Au
{
Au
:
:
from
(
*
self
.
0
.
height
(
)
)
}
}
