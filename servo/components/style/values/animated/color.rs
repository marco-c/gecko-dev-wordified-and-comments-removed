use
crate
:
:
values
:
:
animated
:
:
{
Animate
Procedure
ToAnimatedZero
}
;
use
crate
:
:
values
:
:
distance
:
:
{
ComputeSquaredDistance
SquaredDistance
}
;
use
crate
:
:
values
:
:
generics
:
:
color
:
:
{
Color
as
GenericColor
ComplexColorRatios
}
;
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToAnimatedZero
)
]
pub
struct
RGBA
{
pub
red
:
f32
pub
green
:
f32
pub
blue
:
f32
pub
alpha
:
f32
}
impl
RGBA
{
#
[
inline
]
pub
fn
transparent
(
)
-
>
Self
{
Self
:
:
new
(
0
.
0
.
0
.
0
.
)
}
#
[
inline
]
pub
fn
new
(
red
:
f32
green
:
f32
blue
:
f32
alpha
:
f32
)
-
>
Self
{
RGBA
{
red
:
red
green
:
green
blue
:
blue
alpha
:
alpha
}
}
}
impl
Animate
for
RGBA
{
#
[
inline
]
fn
animate
(
&
self
other
:
&
Self
procedure
:
Procedure
)
-
>
Result
<
Self
(
)
>
{
let
mut
alpha
=
self
.
alpha
.
animate
(
&
other
.
alpha
procedure
)
?
;
if
alpha
<
=
0
.
{
return
Ok
(
RGBA
:
:
transparent
(
)
)
;
}
alpha
=
alpha
.
min
(
1
.
)
;
let
red
=
(
self
.
red
*
self
.
alpha
)
.
animate
(
&
(
other
.
red
*
other
.
alpha
)
procedure
)
?
*
1
.
/
alpha
;
let
green
=
(
self
.
green
*
self
.
alpha
)
.
animate
(
&
(
other
.
green
*
other
.
alpha
)
procedure
)
?
*
1
.
/
alpha
;
let
blue
=
(
self
.
blue
*
self
.
alpha
)
.
animate
(
&
(
other
.
blue
*
other
.
alpha
)
procedure
)
?
*
1
.
/
alpha
;
Ok
(
RGBA
:
:
new
(
red
green
blue
alpha
)
)
}
}
impl
ComputeSquaredDistance
for
RGBA
{
#
[
inline
]
fn
compute_squared_distance
(
&
self
other
:
&
Self
)
-
>
Result
<
SquaredDistance
(
)
>
{
let
start
=
[
self
.
alpha
self
.
red
*
self
.
alpha
self
.
green
*
self
.
alpha
self
.
blue
*
self
.
alpha
]
;
let
end
=
[
other
.
alpha
other
.
red
*
other
.
alpha
other
.
green
*
other
.
alpha
other
.
blue
*
other
.
alpha
]
;
start
.
iter
(
)
.
zip
(
&
end
)
.
map
(
|
(
this
other
)
|
this
.
compute_squared_distance
(
other
)
)
.
sum
(
)
}
}
pub
type
Color
=
GenericColor
<
RGBA
>
;
impl
Color
{
fn
effective_intermediate_rgba
(
&
self
)
-
>
RGBA
{
match
*
self
{
GenericColor
:
:
Numeric
(
color
)
=
>
color
GenericColor
:
:
CurrentColor
=
>
RGBA
:
:
transparent
(
)
GenericColor
:
:
Complex
{
color
ratios
}
=
>
RGBA
{
alpha
:
color
.
alpha
*
ratios
.
bg
.
.
color
.
clone
(
)
}
}
}
fn
effective_ratios
(
&
self
)
-
>
ComplexColorRatios
{
match
*
self
{
GenericColor
:
:
Numeric
(
.
.
)
=
>
ComplexColorRatios
:
:
NUMERIC
GenericColor
:
:
CurrentColor
=
>
ComplexColorRatios
:
:
CURRENT_COLOR
GenericColor
:
:
Complex
{
ratios
.
.
}
=
>
ratios
}
}
}
impl
Animate
for
Color
{
#
[
inline
]
fn
animate
(
&
self
other
:
&
Self
procedure
:
Procedure
)
-
>
Result
<
Self
(
)
>
{
use
self
:
:
GenericColor
:
:
*
;
let
(
this_weight
other_weight
)
=
procedure
.
weights
(
)
;
Ok
(
match
(
*
self
*
other
procedure
)
{
(
CurrentColor
CurrentColor
Procedure
:
:
Interpolate
{
.
.
}
)
=
>
CurrentColor
(
Numeric
(
c1
)
Numeric
(
c2
)
_
)
=
>
Numeric
(
c1
.
animate
(
&
c2
procedure
)
?
)
(
CurrentColor
Numeric
(
color
)
_
)
=
>
Self
:
:
with_ratios
(
color
ComplexColorRatios
{
bg
:
other_weight
as
f32
fg
:
this_weight
as
f32
}
)
(
Numeric
(
color
)
CurrentColor
_
)
=
>
Self
:
:
with_ratios
(
color
ComplexColorRatios
{
bg
:
this_weight
as
f32
fg
:
other_weight
as
f32
}
)
(
CurrentColor
CurrentColor
_
)
=
>
Self
:
:
with_ratios
(
RGBA
:
:
transparent
(
)
ComplexColorRatios
{
bg
:
0
.
fg
:
(
this_weight
+
other_weight
)
as
f32
}
)
_
=
>
{
fn
scaled_rgba
(
color
:
&
Color
)
-
>
RGBA
{
match
*
color
{
GenericColor
:
:
Numeric
(
color
)
=
>
color
GenericColor
:
:
CurrentColor
=
>
RGBA
:
:
transparent
(
)
GenericColor
:
:
Complex
{
color
ratios
}
=
>
RGBA
{
red
:
color
.
red
*
ratios
.
bg
green
:
color
.
green
*
ratios
.
bg
blue
:
color
.
blue
*
ratios
.
bg
alpha
:
color
.
alpha
*
ratios
.
bg
}
}
}
let
bg_color1
=
scaled_rgba
(
self
)
;
let
bg_color2
=
scaled_rgba
(
other
)
;
let
bg_color
=
bg_color1
.
animate
(
&
bg_color2
procedure
)
?
;
let
ComplexColorRatios
{
fg
:
fg1
.
.
}
=
self
.
effective_ratios
(
)
;
let
ComplexColorRatios
{
fg
:
fg2
.
.
}
=
other
.
effective_ratios
(
)
;
let
fg
=
fg1
.
animate
(
&
fg2
procedure
)
?
;
Self
:
:
with_ratios
(
bg_color
ComplexColorRatios
{
bg
:
1
.
fg
}
)
}
}
)
}
}
impl
ComputeSquaredDistance
for
Color
{
#
[
inline
]
fn
compute_squared_distance
(
&
self
other
:
&
Self
)
-
>
Result
<
SquaredDistance
(
)
>
{
use
self
:
:
GenericColor
:
:
*
;
Ok
(
match
(
*
self
*
other
)
{
(
CurrentColor
CurrentColor
)
=
>
SquaredDistance
:
:
from_sqrt
(
0
.
)
(
Numeric
(
c1
)
Numeric
(
c2
)
)
=
>
c1
.
compute_squared_distance
(
&
c2
)
?
(
CurrentColor
Numeric
(
color
)
)
|
(
Numeric
(
color
)
CurrentColor
)
=
>
{
color
.
compute_squared_distance
(
&
RGBA
:
:
transparent
(
)
)
?
+
SquaredDistance
:
:
from_sqrt
(
1
.
)
}
(
_
_
)
=
>
{
let
self_color
=
self
.
effective_intermediate_rgba
(
)
;
let
other_color
=
other
.
effective_intermediate_rgba
(
)
;
let
self_ratios
=
self
.
effective_ratios
(
)
;
let
other_ratios
=
other
.
effective_ratios
(
)
;
self_color
.
compute_squared_distance
(
&
other_color
)
?
+
self_ratios
.
bg
.
compute_squared_distance
(
&
other_ratios
.
bg
)
?
+
self_ratios
.
fg
.
compute_squared_distance
(
&
other_ratios
.
fg
)
?
}
}
)
}
}
impl
ToAnimatedZero
for
Color
{
#
[
inline
]
fn
to_animated_zero
(
&
self
)
-
>
Result
<
Self
(
)
>
{
Ok
(
RGBA
:
:
transparent
(
)
.
into
(
)
)
}
}
