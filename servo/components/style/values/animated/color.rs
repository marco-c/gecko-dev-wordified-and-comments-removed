use
values
:
:
animated
:
:
{
Animate
Procedure
ToAnimatedZero
}
;
use
values
:
:
distance
:
:
{
ComputeSquaredDistance
SquaredDistance
}
;
use
values
:
:
computed
:
:
ComplexColorRatios
;
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
ToAnimatedZero
)
]
pub
struct
RGBA
{
pub
red
:
f32
pub
green
:
f32
pub
blue
:
f32
pub
alpha
:
f32
}
impl
RGBA
{
#
[
inline
]
pub
fn
transparent
(
)
-
>
Self
{
Self
:
:
new
(
0
.
0
.
0
.
0
.
)
}
#
[
inline
]
pub
fn
new
(
red
:
f32
green
:
f32
blue
:
f32
alpha
:
f32
)
-
>
Self
{
RGBA
{
red
:
red
green
:
green
blue
:
blue
alpha
:
alpha
}
}
}
impl
Animate
for
RGBA
{
#
[
inline
]
fn
animate
(
&
self
other
:
&
Self
procedure
:
Procedure
)
-
>
Result
<
Self
(
)
>
{
let
mut
alpha
=
self
.
alpha
.
animate
(
&
other
.
alpha
procedure
)
?
;
if
alpha
<
=
0
.
{
return
Ok
(
RGBA
:
:
transparent
(
)
)
;
}
alpha
=
alpha
.
min
(
1
.
)
;
let
red
=
(
self
.
red
*
self
.
alpha
)
.
animate
(
&
(
other
.
red
*
other
.
alpha
)
procedure
)
?
*
1
.
/
alpha
;
let
green
=
(
self
.
green
*
self
.
alpha
)
.
animate
(
&
(
other
.
green
*
other
.
alpha
)
procedure
)
?
*
1
.
/
alpha
;
let
blue
=
(
self
.
blue
*
self
.
alpha
)
.
animate
(
&
(
other
.
blue
*
other
.
alpha
)
procedure
)
?
*
1
.
/
alpha
;
Ok
(
RGBA
:
:
new
(
red
green
blue
alpha
)
)
}
}
impl
ComputeSquaredDistance
for
RGBA
{
#
[
inline
]
fn
compute_squared_distance
(
&
self
other
:
&
Self
)
-
>
Result
<
SquaredDistance
(
)
>
{
let
start
=
[
self
.
alpha
self
.
red
*
self
.
alpha
self
.
green
*
self
.
alpha
self
.
blue
*
self
.
alpha
]
;
let
end
=
[
other
.
alpha
other
.
red
*
other
.
alpha
other
.
green
*
other
.
alpha
other
.
blue
*
other
.
alpha
]
;
start
.
iter
(
)
.
zip
(
&
end
)
.
map
(
|
(
this
other
)
|
this
.
compute_squared_distance
(
other
)
)
.
sum
(
)
}
}
impl
Animate
for
ComplexColorRatios
{
#
[
inline
]
fn
animate
(
&
self
other
:
&
Self
procedure
:
Procedure
)
-
>
Result
<
Self
(
)
>
{
let
bg
=
self
.
bg
.
animate
(
&
other
.
bg
procedure
)
?
;
let
fg
=
self
.
fg
.
animate
(
&
other
.
fg
procedure
)
?
;
Ok
(
ComplexColorRatios
{
bg
fg
}
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
Color
{
Numeric
(
RGBA
)
Foreground
Complex
(
RGBA
ComplexColorRatios
)
}
impl
Color
{
fn
currentcolor
(
)
-
>
Self
{
Color
:
:
Foreground
}
pub
fn
transparent
(
)
-
>
Self
{
Color
:
:
Numeric
(
RGBA
:
:
transparent
(
)
)
}
fn
effective_intermediate_rgba
(
&
self
)
-
>
RGBA
{
match
*
self
{
Color
:
:
Numeric
(
color
)
=
>
color
Color
:
:
Foreground
=
>
RGBA
:
:
transparent
(
)
Color
:
:
Complex
(
color
ratios
)
=
>
RGBA
{
alpha
:
color
.
alpha
*
ratios
.
bg
.
.
color
.
clone
(
)
}
}
}
fn
effective_ratios
(
&
self
)
-
>
ComplexColorRatios
{
match
*
self
{
Color
:
:
Numeric
(
.
.
)
=
>
ComplexColorRatios
:
:
NUMERIC
Color
:
:
Foreground
=
>
ComplexColorRatios
:
:
FOREGROUND
Color
:
:
Complex
(
.
.
ratios
)
=
>
ratios
}
}
}
impl
Animate
for
Color
{
#
[
inline
]
fn
animate
(
&
self
other
:
&
Self
procedure
:
Procedure
)
-
>
Result
<
Self
(
)
>
{
let
(
this_weight
other_weight
)
=
procedure
.
weights
(
)
;
Ok
(
match
(
*
self
*
other
procedure
)
{
(
Color
:
:
Foreground
Color
:
:
Foreground
Procedure
:
:
Interpolate
{
.
.
}
)
=
>
{
Color
:
:
currentcolor
(
)
}
(
Color
:
:
Numeric
(
c1
)
Color
:
:
Numeric
(
c2
)
_
)
=
>
{
Color
:
:
Numeric
(
c1
.
animate
(
&
c2
procedure
)
?
)
}
(
Color
:
:
Foreground
Color
:
:
Numeric
(
color
)
_
)
=
>
Color
:
:
Complex
(
color
ComplexColorRatios
{
bg
:
other_weight
as
f32
fg
:
this_weight
as
f32
}
)
(
Color
:
:
Numeric
(
color
)
Color
:
:
Foreground
_
)
=
>
Color
:
:
Complex
(
color
ComplexColorRatios
{
bg
:
this_weight
as
f32
fg
:
other_weight
as
f32
}
)
(
Color
:
:
Foreground
Color
:
:
Foreground
_
)
=
>
Color
:
:
Complex
(
RGBA
:
:
transparent
(
)
ComplexColorRatios
{
bg
:
0
.
fg
:
(
this_weight
+
other_weight
)
as
f32
}
)
_
=
>
{
let
self_color
=
self
.
effective_intermediate_rgba
(
)
;
let
other_color
=
other
.
effective_intermediate_rgba
(
)
;
let
color
=
self_color
.
animate
(
&
other_color
procedure
)
?
;
let
self_ratios
=
self
.
effective_ratios
(
)
;
let
other_ratios
=
other
.
effective_ratios
(
)
;
let
ratios
=
self_ratios
.
animate
(
&
other_ratios
procedure
)
?
;
let
alpha
=
color
.
alpha
/
ratios
.
bg
;
let
color
=
RGBA
{
alpha
.
.
color
}
;
if
ratios
=
=
ComplexColorRatios
:
:
NUMERIC
{
Color
:
:
Numeric
(
color
)
}
else
if
ratios
=
=
ComplexColorRatios
:
:
FOREGROUND
{
Color
:
:
Foreground
}
else
{
Color
:
:
Complex
(
color
ratios
)
}
}
}
)
}
}
impl
ComputeSquaredDistance
for
Color
{
#
[
inline
]
fn
compute_squared_distance
(
&
self
other
:
&
Self
)
-
>
Result
<
SquaredDistance
(
)
>
{
Ok
(
match
(
*
self
*
other
)
{
(
Color
:
:
Foreground
Color
:
:
Foreground
)
=
>
SquaredDistance
:
:
from_sqrt
(
0
.
)
(
Color
:
:
Numeric
(
c1
)
Color
:
:
Numeric
(
c2
)
)
=
>
c1
.
compute_squared_distance
(
&
c2
)
?
(
Color
:
:
Foreground
Color
:
:
Numeric
(
color
)
)
|
(
Color
:
:
Numeric
(
color
)
Color
:
:
Foreground
)
=
>
{
color
.
compute_squared_distance
(
&
RGBA
:
:
transparent
(
)
)
?
+
SquaredDistance
:
:
from_sqrt
(
1
.
)
}
(
_
_
)
=
>
{
let
self_color
=
self
.
effective_intermediate_rgba
(
)
;
let
other_color
=
other
.
effective_intermediate_rgba
(
)
;
let
self_ratios
=
self
.
effective_ratios
(
)
;
let
other_ratios
=
other
.
effective_ratios
(
)
;
self_color
.
compute_squared_distance
(
&
other_color
)
?
+
self_ratios
.
bg
.
compute_squared_distance
(
&
other_ratios
.
bg
)
?
+
self_ratios
.
fg
.
compute_squared_distance
(
&
other_ratios
.
fg
)
?
}
}
)
}
}
impl
ToAnimatedZero
for
Color
{
#
[
inline
]
fn
to_animated_zero
(
&
self
)
-
>
Result
<
Self
(
)
>
{
Err
(
(
)
)
}
}
