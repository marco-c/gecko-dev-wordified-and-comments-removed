#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
media_queries
:
:
Device
;
use
crate
:
:
properties
:
:
ComputedValues
;
use
crate
:
:
ArcSlice
;
use
app_units
:
:
Au
;
use
servo_arc
:
:
Arc
;
use
smallvec
:
:
SmallVec
;
mod
animation
;
mod
color
;
mod
counters
;
use
crate
:
:
values
:
:
computed
:
:
{
self
Length
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
struct
ResolvedElementInfo
<
'
a
>
{
pub
element
:
crate
:
:
gecko
:
:
wrapper
:
:
GeckoElement
<
'
a
>
}
pub
struct
Context
<
'
a
>
{
pub
style
:
&
'
a
ComputedValues
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
device
:
&
'
a
Device
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
element_info
:
ResolvedElementInfo
<
'
a
>
}
pub
trait
ToResolvedValue
{
type
ResolvedValue
;
fn
to_resolved_value
(
self
context
:
&
Context
)
-
>
Self
:
:
ResolvedValue
;
fn
from_resolved_value
(
resolved
:
Self
:
:
ResolvedValue
)
-
>
Self
;
}
macro_rules
!
trivial_to_resolved_value
{
(
ty
:
ty
)
=
>
{
impl
crate
:
:
values
:
:
resolved
:
:
ToResolvedValue
for
ty
{
type
ResolvedValue
=
Self
;
#
[
inline
]
fn
to_resolved_value
(
self
_
:
&
Context
)
-
>
Self
{
self
}
#
[
inline
]
fn
from_resolved_value
(
resolved
:
Self
:
:
ResolvedValue
)
-
>
Self
{
resolved
}
}
}
;
}
trivial_to_resolved_value
!
(
(
)
)
;
trivial_to_resolved_value
!
(
bool
)
;
trivial_to_resolved_value
!
(
f32
)
;
trivial_to_resolved_value
!
(
u8
)
;
trivial_to_resolved_value
!
(
i8
)
;
trivial_to_resolved_value
!
(
u16
)
;
trivial_to_resolved_value
!
(
i16
)
;
trivial_to_resolved_value
!
(
u32
)
;
trivial_to_resolved_value
!
(
i32
)
;
trivial_to_resolved_value
!
(
usize
)
;
trivial_to_resolved_value
!
(
String
)
;
trivial_to_resolved_value
!
(
Box
<
str
>
)
;
trivial_to_resolved_value
!
(
crate
:
:
OwnedStr
)
;
trivial_to_resolved_value
!
(
crate
:
:
color
:
:
AbsoluteColor
)
;
trivial_to_resolved_value
!
(
crate
:
:
values
:
:
generics
:
:
color
:
:
ColorMixFlags
)
;
trivial_to_resolved_value
!
(
crate
:
:
Atom
)
;
trivial_to_resolved_value
!
(
crate
:
:
values
:
:
AtomIdent
)
;
trivial_to_resolved_value
!
(
crate
:
:
custom_properties
:
:
VariableValue
)
;
trivial_to_resolved_value
!
(
crate
:
:
stylesheets
:
:
UrlExtraData
)
;
trivial_to_resolved_value
!
(
computed
:
:
url
:
:
ComputedUrl
)
;
#
[
cfg
(
feature
=
"
servo
"
)
]
trivial_to_resolved_value
!
(
crate
:
:
Namespace
)
;
#
[
cfg
(
feature
=
"
servo
"
)
]
trivial_to_resolved_value
!
(
crate
:
:
Prefix
)
;
trivial_to_resolved_value
!
(
style_traits
:
:
values
:
:
specified
:
:
AllowedNumericType
)
;
trivial_to_resolved_value
!
(
computed
:
:
TimingFunction
)
;
impl
ToResolvedValue
for
Au
{
type
ResolvedValue
=
Length
;
#
[
inline
]
fn
to_resolved_value
(
self
context
:
&
Context
)
-
>
Self
:
:
ResolvedValue
{
Length
:
:
new
(
self
.
to_f32_px
(
)
)
.
to_resolved_value
(
context
)
}
#
[
inline
]
fn
from_resolved_value
(
resolved
:
Self
:
:
ResolvedValue
)
-
>
Self
{
Au
:
:
from_f32_px
(
Length
:
:
from_resolved_value
(
resolved
)
.
px
(
)
)
}
}
impl
<
A
B
>
ToResolvedValue
for
(
A
B
)
where
A
:
ToResolvedValue
B
:
ToResolvedValue
{
type
ResolvedValue
=
(
<
A
as
ToResolvedValue
>
:
:
ResolvedValue
<
B
as
ToResolvedValue
>
:
:
ResolvedValue
)
;
#
[
inline
]
fn
to_resolved_value
(
self
context
:
&
Context
)
-
>
Self
:
:
ResolvedValue
{
(
self
.
0
.
to_resolved_value
(
context
)
self
.
1
.
to_resolved_value
(
context
)
)
}
#
[
inline
]
fn
from_resolved_value
(
resolved
:
Self
:
:
ResolvedValue
)
-
>
Self
{
(
A
:
:
from_resolved_value
(
resolved
.
0
)
B
:
:
from_resolved_value
(
resolved
.
1
)
)
}
}
impl
<
T
>
ToResolvedValue
for
Option
<
T
>
where
T
:
ToResolvedValue
{
type
ResolvedValue
=
Option
<
<
T
as
ToResolvedValue
>
:
:
ResolvedValue
>
;
#
[
inline
]
fn
to_resolved_value
(
self
context
:
&
Context
)
-
>
Self
:
:
ResolvedValue
{
self
.
map
(
|
item
|
item
.
to_resolved_value
(
context
)
)
}
#
[
inline
]
fn
from_resolved_value
(
resolved
:
Self
:
:
ResolvedValue
)
-
>
Self
{
resolved
.
map
(
T
:
:
from_resolved_value
)
}
}
impl
<
T
>
ToResolvedValue
for
SmallVec
<
[
T
;
1
]
>
where
T
:
ToResolvedValue
{
type
ResolvedValue
=
SmallVec
<
[
<
T
as
ToResolvedValue
>
:
:
ResolvedValue
;
1
]
>
;
#
[
inline
]
fn
to_resolved_value
(
self
context
:
&
Context
)
-
>
Self
:
:
ResolvedValue
{
self
.
into_iter
(
)
.
map
(
|
item
|
item
.
to_resolved_value
(
context
)
)
.
collect
(
)
}
#
[
inline
]
fn
from_resolved_value
(
resolved
:
Self
:
:
ResolvedValue
)
-
>
Self
{
resolved
.
into_iter
(
)
.
map
(
T
:
:
from_resolved_value
)
.
collect
(
)
}
}
impl
<
T
>
ToResolvedValue
for
Vec
<
T
>
where
T
:
ToResolvedValue
{
type
ResolvedValue
=
Vec
<
<
T
as
ToResolvedValue
>
:
:
ResolvedValue
>
;
#
[
inline
]
fn
to_resolved_value
(
self
context
:
&
Context
)
-
>
Self
:
:
ResolvedValue
{
self
.
into_iter
(
)
.
map
(
|
item
|
item
.
to_resolved_value
(
context
)
)
.
collect
(
)
}
#
[
inline
]
fn
from_resolved_value
(
resolved
:
Self
:
:
ResolvedValue
)
-
>
Self
{
resolved
.
into_iter
(
)
.
map
(
T
:
:
from_resolved_value
)
.
collect
(
)
}
}
impl
<
T
>
ToResolvedValue
for
thin_vec
:
:
ThinVec
<
T
>
where
T
:
ToResolvedValue
{
type
ResolvedValue
=
thin_vec
:
:
ThinVec
<
<
T
as
ToResolvedValue
>
:
:
ResolvedValue
>
;
#
[
inline
]
fn
to_resolved_value
(
self
context
:
&
Context
)
-
>
Self
:
:
ResolvedValue
{
self
.
into_iter
(
)
.
map
(
|
item
|
item
.
to_resolved_value
(
context
)
)
.
collect
(
)
}
#
[
inline
]
fn
from_resolved_value
(
resolved
:
Self
:
:
ResolvedValue
)
-
>
Self
{
resolved
.
into_iter
(
)
.
map
(
T
:
:
from_resolved_value
)
.
collect
(
)
}
}
impl
<
T
>
ToResolvedValue
for
Box
<
T
>
where
T
:
ToResolvedValue
{
type
ResolvedValue
=
Box
<
<
T
as
ToResolvedValue
>
:
:
ResolvedValue
>
;
#
[
inline
]
fn
to_resolved_value
(
self
context
:
&
Context
)
-
>
Self
:
:
ResolvedValue
{
Box
:
:
new
(
T
:
:
to_resolved_value
(
*
self
context
)
)
}
#
[
inline
]
fn
from_resolved_value
(
resolved
:
Self
:
:
ResolvedValue
)
-
>
Self
{
Box
:
:
new
(
T
:
:
from_resolved_value
(
*
resolved
)
)
}
}
impl
<
T
>
ToResolvedValue
for
Box
<
[
T
]
>
where
T
:
ToResolvedValue
{
type
ResolvedValue
=
Box
<
[
<
T
as
ToResolvedValue
>
:
:
ResolvedValue
]
>
;
#
[
inline
]
fn
to_resolved_value
(
self
context
:
&
Context
)
-
>
Self
:
:
ResolvedValue
{
Vec
:
:
from
(
self
)
.
to_resolved_value
(
context
)
.
into_boxed_slice
(
)
}
#
[
inline
]
fn
from_resolved_value
(
resolved
:
Self
:
:
ResolvedValue
)
-
>
Self
{
Vec
:
:
from_resolved_value
(
Vec
:
:
from
(
resolved
)
)
.
into_boxed_slice
(
)
}
}
impl
<
T
>
ToResolvedValue
for
crate
:
:
OwnedSlice
<
T
>
where
T
:
ToResolvedValue
{
type
ResolvedValue
=
crate
:
:
OwnedSlice
<
<
T
as
ToResolvedValue
>
:
:
ResolvedValue
>
;
#
[
inline
]
fn
to_resolved_value
(
self
context
:
&
Context
)
-
>
Self
:
:
ResolvedValue
{
self
.
into_box
(
)
.
to_resolved_value
(
context
)
.
into
(
)
}
#
[
inline
]
fn
from_resolved_value
(
resolved
:
Self
:
:
ResolvedValue
)
-
>
Self
{
Self
:
:
from
(
Box
:
:
from_resolved_value
(
resolved
.
into_box
(
)
)
)
}
}
impl
<
T
>
ToResolvedValue
for
Arc
<
T
>
where
T
:
ToResolvedValue
<
ResolvedValue
=
T
>
{
type
ResolvedValue
=
Self
;
#
[
inline
]
fn
to_resolved_value
(
self
_
:
&
Context
)
-
>
Self
{
self
}
#
[
inline
]
fn
from_resolved_value
(
resolved
:
Self
)
-
>
Self
{
resolved
}
}
impl
<
T
>
ToResolvedValue
for
ArcSlice
<
T
>
where
T
:
ToResolvedValue
<
ResolvedValue
=
T
>
{
type
ResolvedValue
=
Self
;
#
[
inline
]
fn
to_resolved_value
(
self
_
:
&
Context
)
-
>
Self
{
self
}
#
[
inline
]
fn
from_resolved_value
(
resolved
:
Self
)
-
>
Self
{
resolved
}
}
