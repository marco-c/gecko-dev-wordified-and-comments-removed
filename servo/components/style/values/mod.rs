#
!
[
deny
(
missing_docs
)
]
use
Atom
;
pub
use
cssparser
:
:
{
RGBA
Token
Parser
serialize_identifier
CowRcStr
SourceLocation
}
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
selectors
:
:
parser
:
:
SelectorParseErrorKind
;
#
[
allow
(
unused_imports
)
]
use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
fmt
:
:
{
self
Debug
Write
}
;
use
std
:
:
hash
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
use
values
:
:
distance
:
:
{
ComputeSquaredDistance
SquaredDistance
}
;
pub
mod
animated
;
pub
mod
computed
;
pub
mod
distance
;
pub
mod
generics
;
pub
mod
specified
;
pub
type
CSSFloat
=
f32
;
pub
type
CSSInteger
=
i32
;
define_keyword_type
!
(
None_
"
none
"
)
;
define_keyword_type
!
(
Auto
"
auto
"
)
;
define_keyword_type
!
(
Normal
"
normal
"
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
serialize_atom_identifier
<
W
>
(
ident
:
&
Atom
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
Write
{
ident
.
with_str
(
|
s
|
serialize_identifier
(
s
dest
)
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
serialize_atom_identifier
<
Static
W
>
(
ident
:
&
:
:
string_cache
:
:
Atom
<
Static
>
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
Static
:
:
:
string_cache
:
:
StaticAtomSet
W
:
Write
{
serialize_identifier
(
&
ident
dest
)
}
pub
fn
serialize_percentage
<
W
>
(
value
:
CSSFloat
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
(
value
*
100
.
)
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
%
"
)
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
MallocSizeOf
Serialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
ToAnimatedValue
ToComputedValue
ToCss
)
]
pub
enum
Impossible
{
}
impl
ComputeSquaredDistance
for
Impossible
{
#
[
inline
]
fn
compute_squared_distance
(
&
self
_other
:
&
Self
)
-
>
Result
<
SquaredDistance
(
)
>
{
match
*
self
{
}
}
}
impl
Parse
for
Impossible
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
#
[
derive
(
Animate
Clone
ComputeSquaredDistance
Copy
MallocSizeOf
)
]
#
[
derive
(
PartialEq
ToAnimatedValue
ToAnimatedZero
ToComputedValue
ToCss
)
]
pub
enum
Either
<
A
B
>
{
First
(
A
)
Second
(
B
)
}
impl
<
A
:
Debug
B
:
Debug
>
Debug
for
Either
<
A
B
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
Either
:
:
First
(
ref
v
)
=
>
v
.
fmt
(
f
)
Either
:
:
Second
(
ref
v
)
=
>
v
.
fmt
(
f
)
}
}
}
impl
<
A
:
Parse
B
:
Parse
>
Parse
for
Either
<
A
B
>
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Either
<
A
B
>
ParseError
<
'
i
>
>
{
if
let
Ok
(
v
)
=
input
.
try
(
|
i
|
A
:
:
parse
(
context
i
)
)
{
Ok
(
Either
:
:
First
(
v
)
)
}
else
{
B
:
:
parse
(
context
input
)
.
map
(
Either
:
:
Second
)
}
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
PartialEq
ToComputedValue
)
]
pub
struct
CustomIdent
(
pub
Atom
)
;
impl
CustomIdent
{
pub
fn
from_ident
<
'
i
>
(
location
:
SourceLocation
ident
:
&
CowRcStr
<
'
i
>
excluding
:
&
[
&
str
]
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
valid
=
match_ignore_ascii_case
!
{
ident
"
initial
"
|
"
inherit
"
|
"
unset
"
|
"
default
"
=
>
false
_
=
>
true
}
;
if
!
valid
{
return
Err
(
location
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnexpectedIdent
(
ident
.
clone
(
)
)
)
)
;
}
if
excluding
.
iter
(
)
.
any
(
|
s
|
ident
.
eq_ignore_ascii_case
(
s
)
)
{
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
else
{
Ok
(
CustomIdent
(
Atom
:
:
from
(
ident
.
as_ref
(
)
)
)
)
}
}
}
impl
ToCss
for
CustomIdent
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
serialize_atom_identifier
(
&
self
.
0
dest
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
ToComputedValue
)
]
pub
enum
KeyframesName
{
Ident
(
CustomIdent
)
QuotedString
(
Atom
)
}
impl
KeyframesName
{
pub
fn
from_ident
(
value
:
&
str
)
-
>
Self
{
let
location
=
SourceLocation
{
line
:
0
column
:
0
}
;
let
custom_ident
=
CustomIdent
:
:
from_ident
(
location
&
value
.
into
(
)
&
[
"
none
"
]
)
.
ok
(
)
;
match
custom_ident
{
Some
(
ident
)
=
>
KeyframesName
:
:
Ident
(
ident
)
None
=
>
KeyframesName
:
:
QuotedString
(
value
.
into
(
)
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
from_atom
(
atom
:
Atom
)
-
>
Self
{
debug_assert_ne
!
(
atom
atom
!
(
"
"
)
)
;
KeyframesName
:
:
Ident
(
CustomIdent
(
atom
)
)
}
pub
fn
as_atom
(
&
self
)
-
>
&
Atom
{
match
*
self
{
KeyframesName
:
:
Ident
(
ref
ident
)
=
>
&
ident
.
0
KeyframesName
:
:
QuotedString
(
ref
atom
)
=
>
atom
}
}
}
impl
Eq
for
KeyframesName
{
}
impl
PartialEq
for
KeyframesName
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
as_atom
(
)
=
=
other
.
as_atom
(
)
}
}
impl
hash
:
:
Hash
for
KeyframesName
{
fn
hash
<
H
>
(
&
self
state
:
&
mut
H
)
where
H
:
hash
:
:
Hasher
{
self
.
as_atom
(
)
.
hash
(
state
)
}
}
impl
Parse
for
KeyframesName
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
match
*
input
.
next
(
)
?
{
Token
:
:
Ident
(
ref
s
)
=
>
Ok
(
KeyframesName
:
:
Ident
(
CustomIdent
:
:
from_ident
(
location
s
&
[
"
none
"
]
)
?
)
)
Token
:
:
QuotedString
(
ref
s
)
=
>
Ok
(
KeyframesName
:
:
QuotedString
(
Atom
:
:
from
(
s
.
as_ref
(
)
)
)
)
ref
t
=
>
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
}
}
}
impl
ToCss
for
KeyframesName
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
*
self
{
KeyframesName
:
:
Ident
(
ref
ident
)
=
>
ident
.
to_css
(
dest
)
KeyframesName
:
:
QuotedString
(
ref
atom
)
=
>
atom
.
to_string
(
)
.
to_css
(
dest
)
}
}
}
