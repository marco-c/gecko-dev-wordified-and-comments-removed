use
crate
:
:
context
:
:
{
ElementCascadeInputs
SharedStyleContext
StyleContext
}
;
use
crate
:
:
data
:
:
{
ElementData
ElementStyles
}
;
use
crate
:
:
dom
:
:
{
NodeInfo
OpaqueNode
TElement
TNode
}
;
use
crate
:
:
invalidation
:
:
element
:
:
restyle_hints
:
:
RestyleHint
;
use
crate
:
:
matching
:
:
{
ChildCascadeRequirement
MatchMethods
}
;
use
crate
:
:
selector_parser
:
:
PseudoElement
;
use
crate
:
:
sharing
:
:
StyleSharingTarget
;
use
crate
:
:
style_resolver
:
:
{
PseudoElementResolution
StyleResolverForElement
}
;
use
crate
:
:
stylist
:
:
RuleInclusion
;
use
crate
:
:
traversal_flags
:
:
TraversalFlags
;
use
selectors
:
:
NthIndexCache
;
use
smallvec
:
:
SmallVec
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
PerLevelTraversalData
{
pub
current_dom_depth
:
usize
}
pub
struct
PreTraverseToken
<
E
:
TElement
>
(
Option
<
E
>
)
;
impl
<
E
:
TElement
>
PreTraverseToken
<
E
>
{
pub
fn
should_traverse
(
&
self
)
-
>
bool
{
self
.
0
.
is_some
(
)
}
pub
(
crate
)
fn
traversal_root
(
self
)
-
>
Option
<
E
>
{
self
.
0
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
static
IS_SERVO_NONINCREMENTAL_LAYOUT
:
std
:
:
sync
:
:
atomic
:
:
AtomicBool
=
std
:
:
sync
:
:
atomic
:
:
AtomicBool
:
:
new
(
false
)
;
#
[
cfg
(
feature
=
"
servo
"
)
]
#
[
inline
]
fn
is_servo_nonincremental_layout
(
)
-
>
bool
{
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
IS_SERVO_NONINCREMENTAL_LAYOUT
.
load
(
Ordering
:
:
Relaxed
)
}
#
[
cfg
(
not
(
feature
=
"
servo
"
)
)
]
#
[
inline
]
fn
is_servo_nonincremental_layout
(
)
-
>
bool
{
false
}
pub
trait
DomTraversal
<
E
:
TElement
>
:
Sync
{
fn
process_preorder
<
F
>
(
&
self
data
:
&
PerLevelTraversalData
context
:
&
mut
StyleContext
<
E
>
node
:
E
:
:
ConcreteNode
note_child
:
F
)
where
F
:
FnMut
(
E
:
:
ConcreteNode
)
;
fn
process_postorder
(
&
self
contect
:
&
mut
StyleContext
<
E
>
node
:
E
:
:
ConcreteNode
)
;
fn
needs_postorder_traversal
(
)
-
>
bool
{
true
}
fn
handle_postorder_traversal
(
&
self
context
:
&
mut
StyleContext
<
E
>
root
:
OpaqueNode
mut
node
:
E
:
:
ConcreteNode
children_to_process
:
isize
)
{
if
!
Self
:
:
needs_postorder_traversal
(
)
{
return
;
}
if
children_to_process
=
=
0
{
loop
{
self
.
process_postorder
(
context
node
)
;
if
node
.
opaque
(
)
=
=
root
{
break
;
}
let
parent
=
node
.
traversal_parent
(
)
.
unwrap
(
)
;
let
remaining
=
parent
.
did_process_child
(
)
;
if
remaining
!
=
0
{
break
;
}
node
=
parent
.
as_node
(
)
;
}
}
else
{
node
.
as_element
(
)
.
unwrap
(
)
.
store_children_to_process
(
children_to_process
)
;
}
}
fn
pre_traverse
(
root
:
E
shared_context
:
&
SharedStyleContext
)
-
>
PreTraverseToken
<
E
>
{
let
traversal_flags
=
shared_context
.
traversal_flags
;
let
mut
data
=
root
.
mutate_data
(
)
;
let
mut
data
=
data
.
as_mut
(
)
.
map
(
|
d
|
&
mut
*
*
d
)
;
if
let
Some
(
ref
mut
data
)
=
data
{
if
!
traversal_flags
.
for_animation_only
(
)
{
let
invalidation_result
=
data
.
invalidate_style_if_needed
(
root
shared_context
None
&
mut
NthIndexCache
:
:
default
(
)
)
;
if
invalidation_result
.
has_invalidated_siblings
(
)
{
let
actual_root
=
root
.
traversal_parent
(
)
.
expect
(
"
How
in
the
world
can
you
invalidate
\
siblings
without
a
parent
?
"
)
;
unsafe
{
actual_root
.
set_dirty_descendants
(
)
}
return
PreTraverseToken
(
Some
(
actual_root
)
)
;
}
}
}
let
should_traverse
=
Self
:
:
element_needs_traversal
(
root
traversal_flags
data
.
as_mut
(
)
.
map
(
|
d
|
&
*
*
d
)
)
;
if
!
should_traverse
&
&
data
.
is_some
(
)
{
clear_state_after_traversing
(
root
data
.
unwrap
(
)
traversal_flags
)
;
}
PreTraverseToken
(
if
should_traverse
{
Some
(
root
)
}
else
{
None
}
)
}
fn
text_node_needs_traversal
(
node
:
E
:
:
ConcreteNode
_parent_data
:
&
ElementData
)
-
>
bool
{
debug_assert
!
(
node
.
is_text_node
(
)
)
;
false
}
fn
element_needs_traversal
(
el
:
E
traversal_flags
:
TraversalFlags
data
:
Option
<
&
ElementData
>
)
-
>
bool
{
debug
!
(
"
element_needs_traversal
(
{
:
?
}
{
:
?
}
{
:
?
}
)
"
el
traversal_flags
data
)
;
if
traversal_flags
.
for_animation_only
(
)
{
return
data
.
map_or
(
false
|
d
|
d
.
has_styles
(
)
)
&
&
(
el
.
has_animation_only_dirty_descendants
(
)
|
|
data
.
as_ref
(
)
.
unwrap
(
)
.
hint
.
has_animation_hint_or_recascade
(
)
)
;
}
if
is_servo_nonincremental_layout
(
)
{
return
true
;
}
let
data
=
match
data
{
Some
(
d
)
if
d
.
has_styles
(
)
=
>
d
_
=
>
return
true
}
;
if
el
.
has_dirty_descendants
(
)
{
return
true
;
}
if
!
data
.
hint
.
is_empty
(
)
{
return
true
;
}
if
cfg
!
(
feature
=
"
servo
"
)
&
&
!
data
.
damage
.
is_empty
(
)
{
return
true
;
}
trace
!
(
"
{
:
?
}
doesn
'
t
need
traversal
"
el
)
;
false
}
fn
should_cull_subtree
(
&
self
context
:
&
mut
StyleContext
<
E
>
parent
:
E
parent_data
:
&
ElementData
)
-
>
bool
{
debug_assert
!
(
parent
.
has_current_styles_for_traversal
(
parent_data
context
.
shared
.
traversal_flags
)
)
;
if
parent_data
.
styles
.
is_display_none
(
)
{
debug
!
(
"
Parent
{
:
?
}
is
display
:
none
culling
traversal
"
parent
)
;
return
true
;
}
return
false
;
}
fn
shared_context
(
&
self
)
-
>
&
SharedStyleContext
;
}
pub
fn
resolve_style
<
E
>
(
context
:
&
mut
StyleContext
<
E
>
element
:
E
rule_inclusion
:
RuleInclusion
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
ElementStyles
where
E
:
TElement
{
debug_assert
!
(
rule_inclusion
=
=
RuleInclusion
:
:
DefaultOnly
|
|
pseudo
.
map_or
(
false
|
p
|
p
.
is_before_or_after
(
)
)
|
|
element
.
borrow_data
(
)
.
map_or
(
true
|
d
|
!
d
.
has_styles
(
)
)
"
Why
are
we
here
?
"
)
;
let
mut
ancestors_requiring_style_resolution
=
SmallVec
:
:
<
[
E
;
16
]
>
:
:
new
(
)
;
context
.
thread_local
.
bloom_filter
.
clear
(
)
;
let
mut
style
=
None
;
let
mut
ancestor
=
element
.
traversal_parent
(
)
;
while
let
Some
(
current
)
=
ancestor
{
if
rule_inclusion
=
=
RuleInclusion
:
:
All
{
if
let
Some
(
data
)
=
current
.
borrow_data
(
)
{
if
let
Some
(
ancestor_style
)
=
data
.
styles
.
get_primary
(
)
{
style
=
Some
(
ancestor_style
.
clone
(
)
)
;
break
;
}
}
}
ancestors_requiring_style_resolution
.
push
(
current
)
;
ancestor
=
current
.
traversal_parent
(
)
;
}
if
let
Some
(
ancestor
)
=
ancestor
{
context
.
thread_local
.
bloom_filter
.
rebuild
(
ancestor
)
;
context
.
thread_local
.
bloom_filter
.
push
(
ancestor
)
;
}
let
mut
layout_parent_style
=
style
.
clone
(
)
;
while
let
Some
(
style
)
=
layout_parent_style
.
take
(
)
{
if
!
style
.
is_display_contents
(
)
{
layout_parent_style
=
Some
(
style
)
;
break
;
}
ancestor
=
ancestor
.
unwrap
(
)
.
traversal_parent
(
)
;
layout_parent_style
=
ancestor
.
map
(
|
a
|
a
.
borrow_data
(
)
.
unwrap
(
)
.
styles
.
primary
(
)
.
clone
(
)
)
;
}
for
ancestor
in
ancestors_requiring_style_resolution
.
iter
(
)
.
rev
(
)
{
context
.
thread_local
.
bloom_filter
.
assert_complete
(
*
ancestor
)
;
let
primary_style
=
StyleResolverForElement
:
:
new
(
*
ancestor
context
rule_inclusion
PseudoElementResolution
:
:
IfApplicable
)
.
resolve_primary_style
(
style
.
as_ref
(
)
.
map
(
|
s
|
&
*
*
s
)
layout_parent_style
.
as_ref
(
)
.
map
(
|
s
|
&
*
*
s
)
)
;
let
is_display_contents
=
primary_style
.
style
(
)
.
is_display_contents
(
)
;
style
=
Some
(
primary_style
.
style
.
0
)
;
if
!
is_display_contents
{
layout_parent_style
=
style
.
clone
(
)
;
}
context
.
thread_local
.
bloom_filter
.
push
(
*
ancestor
)
;
}
context
.
thread_local
.
bloom_filter
.
assert_complete
(
element
)
;
StyleResolverForElement
:
:
new
(
element
context
rule_inclusion
PseudoElementResolution
:
:
Force
)
.
resolve_style
(
style
.
as_ref
(
)
.
map
(
|
s
|
&
*
*
s
)
layout_parent_style
.
as_ref
(
)
.
map
(
|
s
|
&
*
*
s
)
)
.
into
(
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
pub
fn
recalc_style_at
<
E
D
F
>
(
traversal
:
&
D
traversal_data
:
&
PerLevelTraversalData
context
:
&
mut
StyleContext
<
E
>
element
:
E
data
:
&
mut
ElementData
note_child
:
F
)
where
E
:
TElement
D
:
DomTraversal
<
E
>
F
:
FnMut
(
E
:
:
ConcreteNode
)
{
use
std
:
:
cmp
;
let
flags
=
context
.
shared
.
traversal_flags
;
let
is_initial_style
=
!
data
.
has_styles
(
)
;
context
.
thread_local
.
statistics
.
elements_traversed
+
=
1
;
debug_assert
!
(
flags
.
intersects
(
TraversalFlags
:
:
AnimationOnly
)
|
|
!
element
.
has_snapshot
(
)
|
|
element
.
handled_snapshot
(
)
"
Should
'
ve
handled
snapshots
here
already
"
)
;
let
compute_self
=
!
element
.
has_current_styles_for_traversal
(
data
flags
)
;
debug
!
(
"
recalc_style_at
:
{
:
?
}
(
compute_self
=
{
:
?
}
\
dirty_descendants
=
{
:
?
}
data
=
{
:
?
}
)
"
element
compute_self
element
.
has_dirty_descendants
(
)
data
)
;
let
mut
child_cascade_requirement
=
ChildCascadeRequirement
:
:
CanSkipCascade
;
if
compute_self
{
child_cascade_requirement
=
compute_style
(
traversal_data
context
element
data
)
;
if
element
.
is_in_native_anonymous_subtree
(
)
{
child_cascade_requirement
=
cmp
:
:
max
(
child_cascade_requirement
ChildCascadeRequirement
:
:
MustCascadeChildren
)
;
}
if
data
.
styles
.
is_display_none
(
)
{
debug
!
(
"
{
:
?
}
style
is
display
:
none
-
clearing
data
from
descendants
.
"
element
)
;
unsafe
{
clear_descendant_data
(
element
)
;
}
}
notify_paint_worklet
(
context
data
)
;
}
else
{
debug_assert
!
(
data
.
has_styles
(
)
)
;
data
.
set_traversed_without_styling
(
)
;
}
debug_assert
!
(
flags
.
for_animation_only
(
)
|
|
!
data
.
hint
.
has_animation_hint
(
)
"
animation
restyle
hint
should
be
handled
during
\
animation
-
only
restyles
"
)
;
let
propagated_hint
=
data
.
hint
.
propagate
(
&
flags
)
;
trace
!
(
"
propagated_hint
=
{
:
?
}
cascade_requirement
=
{
:
?
}
\
is_display_none
=
{
:
?
}
implementing_pseudo
=
{
:
?
}
"
propagated_hint
child_cascade_requirement
data
.
styles
.
is_display_none
(
)
element
.
implemented_pseudo_element
(
)
)
;
debug_assert
!
(
element
.
has_current_styles_for_traversal
(
data
flags
)
"
Should
have
computed
style
or
haven
'
t
yet
valid
computed
\
style
in
case
of
animation
-
only
restyle
"
)
;
let
has_dirty_descendants_for_this_restyle
=
if
flags
.
for_animation_only
(
)
{
element
.
has_animation_only_dirty_descendants
(
)
}
else
{
element
.
has_dirty_descendants
(
)
}
;
let
mut
traverse_children
=
has_dirty_descendants_for_this_restyle
|
|
!
propagated_hint
.
is_empty
(
)
|
|
!
child_cascade_requirement
.
can_skip_cascade
(
)
|
|
is_servo_nonincremental_layout
(
)
;
traverse_children
=
traverse_children
&
&
!
traversal
.
should_cull_subtree
(
context
element
&
data
)
;
if
traverse_children
{
note_children
:
:
<
E
D
F
>
(
context
element
data
propagated_hint
child_cascade_requirement
is_initial_style
note_child
)
;
}
if
cfg
!
(
feature
=
"
gecko
"
)
&
&
cfg
!
(
debug_assertions
)
&
&
data
.
styles
.
is_display_none
(
)
{
debug_assert
!
(
!
element
.
has_dirty_descendants
(
)
)
;
debug_assert
!
(
!
element
.
has_animation_only_dirty_descendants
(
)
)
;
}
clear_state_after_traversing
(
element
data
flags
)
;
}
fn
clear_state_after_traversing
<
E
>
(
element
:
E
data
:
&
mut
ElementData
flags
:
TraversalFlags
)
where
E
:
TElement
{
if
flags
.
intersects
(
TraversalFlags
:
:
FinalAnimationTraversal
)
{
debug_assert
!
(
flags
.
for_animation_only
(
)
)
;
data
.
clear_restyle_flags_and_damage
(
)
;
unsafe
{
element
.
unset_animation_only_dirty_descendants
(
)
;
}
}
}
fn
compute_style
<
E
>
(
traversal_data
:
&
PerLevelTraversalData
context
:
&
mut
StyleContext
<
E
>
element
:
E
data
:
&
mut
ElementData
)
-
>
ChildCascadeRequirement
where
E
:
TElement
{
use
crate
:
:
data
:
:
RestyleKind
:
:
*
;
context
.
thread_local
.
statistics
.
elements_styled
+
=
1
;
let
kind
=
data
.
restyle_kind
(
context
.
shared
)
;
debug
!
(
"
compute_style
:
{
:
?
}
(
kind
=
{
:
?
}
)
"
element
kind
)
;
if
data
.
has_styles
(
)
{
data
.
set_restyled
(
)
;
}
let
mut
important_rules_changed
=
false
;
let
new_styles
=
match
kind
{
MatchAndCascade
=
>
{
debug_assert
!
(
!
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
"
MatchAndCascade
shouldn
'
t
be
processed
during
\
animation
-
only
traversal
"
)
;
context
.
thread_local
.
bloom_filter
.
insert_parents_recovering
(
element
traversal_data
.
current_dom_depth
)
;
context
.
thread_local
.
bloom_filter
.
assert_complete
(
element
)
;
debug_assert_eq
!
(
context
.
thread_local
.
bloom_filter
.
matching_depth
(
)
traversal_data
.
current_dom_depth
)
;
important_rules_changed
=
true
;
let
mut
target
=
StyleSharingTarget
:
:
new
(
element
)
;
match
target
.
share_style_if_possible
(
context
)
{
Some
(
shared_styles
)
=
>
{
context
.
thread_local
.
statistics
.
styles_shared
+
=
1
;
shared_styles
}
None
=
>
{
context
.
thread_local
.
statistics
.
elements_matched
+
=
1
;
let
new_styles
=
{
let
mut
resolver
=
StyleResolverForElement
:
:
new
(
element
context
RuleInclusion
:
:
All
PseudoElementResolution
:
:
IfApplicable
)
;
resolver
.
resolve_style_with_default_parents
(
)
}
;
context
.
thread_local
.
sharing_cache
.
insert_if_possible
(
&
element
&
new_styles
.
primary
Some
(
&
mut
target
)
traversal_data
.
current_dom_depth
)
;
new_styles
}
}
}
CascadeWithReplacements
(
flags
)
=
>
{
let
mut
cascade_inputs
=
ElementCascadeInputs
:
:
new_from_element_data
(
data
)
;
important_rules_changed
=
element
.
replace_rules
(
flags
context
&
mut
cascade_inputs
)
;
let
mut
resolver
=
StyleResolverForElement
:
:
new
(
element
context
RuleInclusion
:
:
All
PseudoElementResolution
:
:
IfApplicable
)
;
resolver
.
cascade_styles_with_default_parents
(
cascade_inputs
)
}
CascadeOnly
=
>
{
let
cascade_inputs
=
ElementCascadeInputs
:
:
new_from_element_data
(
data
)
;
let
new_styles
=
{
let
mut
resolver
=
StyleResolverForElement
:
:
new
(
element
context
RuleInclusion
:
:
All
PseudoElementResolution
:
:
IfApplicable
)
;
resolver
.
cascade_styles_with_default_parents
(
cascade_inputs
)
}
;
if
!
new_styles
.
primary
.
reused_via_rule_node
{
context
.
thread_local
.
sharing_cache
.
insert_if_possible
(
&
element
&
new_styles
.
primary
None
traversal_data
.
current_dom_depth
)
;
}
new_styles
}
}
;
element
.
finish_restyle
(
context
data
new_styles
important_rules_changed
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
notify_paint_worklet
<
E
>
(
context
:
&
StyleContext
<
E
>
data
:
&
ElementData
)
where
E
:
TElement
{
use
crate
:
:
values
:
:
generics
:
:
image
:
:
{
GenericImageLayer
Image
}
;
use
style_traits
:
:
ToCss
;
if
let
Some
(
ref
values
)
=
data
.
styles
.
primary
{
for
image
in
&
values
.
get_background
(
)
.
background_image
.
0
{
let
(
name
arguments
)
=
match
*
image
{
GenericImageLayer
:
:
Image
(
Image
:
:
PaintWorklet
(
ref
worklet
)
)
=
>
{
(
&
worklet
.
name
&
worklet
.
arguments
)
}
_
=
>
continue
}
;
let
painter
=
match
context
.
shared
.
registered_speculative_painters
.
get
(
name
)
{
Some
(
painter
)
=
>
painter
None
=
>
continue
}
;
let
properties
=
painter
.
properties
(
)
.
iter
(
)
.
filter_map
(
|
(
name
id
)
|
id
.
as_shorthand
(
)
.
err
(
)
.
map
(
|
id
|
(
name
id
)
)
)
.
map
(
|
(
name
id
)
|
(
name
.
clone
(
)
values
.
computed_value_to_string
(
id
)
)
)
.
collect
(
)
;
let
arguments
=
arguments
.
iter
(
)
.
map
(
|
argument
|
argument
.
to_css_string
(
)
)
.
collect
(
)
;
debug
!
(
"
Notifying
paint
worklet
{
}
.
"
painter
.
name
(
)
)
;
painter
.
speculatively_draw_a_paint_image
(
properties
arguments
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
notify_paint_worklet
<
E
>
(
_context
:
&
StyleContext
<
E
>
_data
:
&
ElementData
)
where
E
:
TElement
{
}
fn
note_children
<
E
D
F
>
(
context
:
&
mut
StyleContext
<
E
>
element
:
E
data
:
&
ElementData
propagated_hint
:
RestyleHint
cascade_requirement
:
ChildCascadeRequirement
is_initial_style
:
bool
mut
note_child
:
F
)
where
E
:
TElement
D
:
DomTraversal
<
E
>
F
:
FnMut
(
E
:
:
ConcreteNode
)
{
trace
!
(
"
note_children
:
{
:
?
}
"
element
)
;
let
flags
=
context
.
shared
.
traversal_flags
;
for
child_node
in
element
.
traversal_children
(
)
{
let
child
=
match
child_node
.
as_element
(
)
{
Some
(
el
)
=
>
el
None
=
>
{
if
is_servo_nonincremental_layout
(
)
|
|
D
:
:
text_node_needs_traversal
(
child_node
data
)
{
note_child
(
child_node
)
;
}
continue
;
}
}
;
let
mut
child_data
=
child
.
mutate_data
(
)
;
let
mut
child_data
=
child_data
.
as_mut
(
)
.
map
(
|
d
|
&
mut
*
*
d
)
;
trace
!
(
"
>
{
:
?
}
-
>
{
:
?
}
+
{
:
?
}
pseudo
:
{
:
?
}
"
child
child_data
.
as_ref
(
)
.
map
(
|
d
|
d
.
hint
)
propagated_hint
child
.
implemented_pseudo_element
(
)
)
;
if
let
Some
(
ref
mut
child_data
)
=
child_data
{
let
mut
child_hint
=
propagated_hint
;
match
cascade_requirement
{
ChildCascadeRequirement
:
:
CanSkipCascade
=
>
{
}
ChildCascadeRequirement
:
:
MustCascadeDescendants
=
>
{
child_hint
|
=
RestyleHint
:
:
RECASCADE_SELF
|
RestyleHint
:
:
RECASCADE_DESCENDANTS
;
}
ChildCascadeRequirement
:
:
MustCascadeChildrenIfInheritResetStyle
=
>
{
use
crate
:
:
properties
:
:
computed_value_flags
:
:
ComputedValueFlags
;
if
child_data
.
styles
.
primary
(
)
.
flags
.
contains
(
ComputedValueFlags
:
:
INHERITS_RESET_STYLE
)
{
child_hint
|
=
RestyleHint
:
:
RECASCADE_SELF
;
}
}
ChildCascadeRequirement
:
:
MustCascadeChildren
=
>
{
child_hint
|
=
RestyleHint
:
:
RECASCADE_SELF
;
}
}
child_data
.
hint
.
insert
(
child_hint
)
;
child_data
.
invalidate_style_if_needed
(
child
&
context
.
shared
Some
(
&
context
.
thread_local
.
stack_limit_checker
)
&
mut
context
.
thread_local
.
nth_index_cache
)
;
}
if
D
:
:
element_needs_traversal
(
child
flags
child_data
.
map
(
|
d
|
&
*
d
)
)
{
note_child
(
child_node
)
;
if
!
is_initial_style
{
if
flags
.
for_animation_only
(
)
{
unsafe
{
element
.
set_animation_only_dirty_descendants
(
)
;
}
}
else
{
unsafe
{
element
.
set_dirty_descendants
(
)
;
}
}
}
}
}
}
pub
unsafe
fn
clear_descendant_data
<
E
>
(
root
:
E
)
where
E
:
TElement
{
let
mut
parents
=
SmallVec
:
:
<
[
E
;
32
]
>
:
:
new
(
)
;
parents
.
push
(
root
)
;
while
let
Some
(
p
)
=
parents
.
pop
(
)
{
for
kid
in
p
.
traversal_children
(
)
{
if
let
Some
(
kid
)
=
kid
.
as_element
(
)
{
if
kid
.
get_data
(
)
.
is_some
(
)
{
kid
.
clear_data
(
)
;
parents
.
push
(
kid
)
;
}
}
}
}
root
.
clear_descendant_bits
(
)
;
}
