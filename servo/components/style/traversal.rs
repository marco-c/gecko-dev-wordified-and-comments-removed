use
atomic_refcell
:
:
{
AtomicRefCell
AtomicRefMut
}
;
use
context
:
:
{
LocalStyleContext
SharedStyleContext
StyleContext
}
;
use
data
:
:
ElementData
;
use
dom
:
:
{
OpaqueNode
StylingMode
TElement
TNode
UnsafeNode
}
;
use
matching
:
:
{
ApplicableDeclarations
MatchMethods
StyleSharingResult
}
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
use
selectors
:
:
matching
:
:
StyleRelations
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
mem
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
ATOMIC_USIZE_INIT
Ordering
}
;
use
tid
:
:
tid
;
use
util
:
:
opts
;
pub
type
Generation
=
u32
;
pub
static
STYLE_SHARING_CACHE_HITS
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
pub
static
STYLE_SHARING_CACHE_MISSES
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
thread_local
!
(
static
STYLE_BLOOM
:
RefCell
<
Option
<
(
Box
<
BloomFilter
>
UnsafeNode
Generation
)
>
>
=
RefCell
:
:
new
(
None
)
)
;
pub
fn
take_thread_local_bloom_filter
<
E
>
(
parent_element
:
Option
<
E
>
root
:
OpaqueNode
context
:
&
SharedStyleContext
)
-
>
Box
<
BloomFilter
>
where
E
:
TElement
{
STYLE_BLOOM
.
with
(
|
style_bloom
|
{
match
(
parent_element
style_bloom
.
borrow_mut
(
)
.
take
(
)
)
{
(
None
_
)
=
>
{
debug
!
(
"
[
{
}
]
No
parent
but
new
bloom
filter
!
"
tid
(
)
)
;
Box
:
:
new
(
BloomFilter
:
:
new
(
)
)
}
(
Some
(
parent
)
None
)
=
>
{
let
mut
bloom_filter
=
Box
:
:
new
(
BloomFilter
:
:
new
(
)
)
;
insert_ancestors_into_bloom_filter
(
&
mut
bloom_filter
parent
root
)
;
bloom_filter
}
(
Some
(
parent
)
Some
(
(
mut
bloom_filter
old_node
old_generation
)
)
)
=
>
{
if
old_node
=
=
parent
.
as_node
(
)
.
to_unsafe
(
)
&
&
old_generation
=
=
context
.
generation
{
debug
!
(
"
[
{
}
]
Parent
matches
(
=
{
}
)
.
Reusing
bloom
filter
.
"
tid
(
)
old_node
.
0
)
;
}
else
{
bloom_filter
.
clear
(
)
;
insert_ancestors_into_bloom_filter
(
&
mut
bloom_filter
parent
root
)
;
}
bloom_filter
}
}
}
)
}
pub
fn
put_thread_local_bloom_filter
(
bf
:
Box
<
BloomFilter
>
unsafe_node
:
&
UnsafeNode
context
:
&
SharedStyleContext
)
{
STYLE_BLOOM
.
with
(
move
|
style_bloom
|
{
assert
!
(
style_bloom
.
borrow
(
)
.
is_none
(
)
"
Putting
into
a
never
-
taken
thread
-
local
bloom
filter
"
)
;
*
style_bloom
.
borrow_mut
(
)
=
Some
(
(
bf
*
unsafe_node
context
.
generation
)
)
;
}
)
}
fn
insert_ancestors_into_bloom_filter
<
E
>
(
bf
:
&
mut
Box
<
BloomFilter
>
mut
el
:
E
root
:
OpaqueNode
)
where
E
:
TElement
{
debug
!
(
"
[
{
}
]
Inserting
ancestors
.
"
tid
(
)
)
;
let
mut
ancestors
=
0
;
loop
{
ancestors
+
=
1
;
el
.
insert_into_bloom_filter
(
&
mut
*
*
bf
)
;
el
=
match
el
.
as_node
(
)
.
layout_parent_element
(
root
)
{
None
=
>
break
Some
(
p
)
=
>
p
}
;
}
debug
!
(
"
[
{
}
]
Inserted
{
}
ancestors
.
"
tid
(
)
ancestors
)
;
}
pub
fn
remove_from_bloom_filter
<
'
a
N
C
>
(
context
:
&
C
root
:
OpaqueNode
node
:
N
)
where
N
:
TNode
C
:
StyleContext
<
'
a
>
{
let
unsafe_layout_node
=
node
.
to_unsafe
(
)
;
let
(
mut
bf
old_node
old_generation
)
=
STYLE_BLOOM
.
with
(
|
style_bloom
|
{
style_bloom
.
borrow_mut
(
)
.
take
(
)
.
expect
(
"
The
bloom
filter
should
have
been
set
by
style
recalc
.
"
)
}
)
;
assert_eq
!
(
old_node
unsafe_layout_node
)
;
assert_eq
!
(
old_generation
context
.
shared_context
(
)
.
generation
)
;
match
node
.
layout_parent_element
(
root
)
{
None
=
>
{
debug
!
(
"
[
{
}
]
-
{
:
X
}
and
deleting
BF
.
"
tid
(
)
unsafe_layout_node
.
0
)
;
}
Some
(
parent
)
=
>
{
node
.
as_element
(
)
.
map
(
|
x
|
x
.
remove_from_bloom_filter
(
&
mut
*
bf
)
)
;
let
unsafe_parent
=
parent
.
as_node
(
)
.
to_unsafe
(
)
;
put_thread_local_bloom_filter
(
bf
&
unsafe_parent
&
context
.
shared_context
(
)
)
;
}
}
;
}
pub
fn
prepare_for_styling
<
E
:
TElement
>
(
element
:
E
data
:
&
AtomicRefCell
<
ElementData
>
)
-
>
AtomicRefMut
<
ElementData
>
{
let
mut
d
=
data
.
borrow_mut
(
)
;
d
.
gather_previous_styles
(
|
|
element
.
get_styles_from_frame
(
)
)
;
if
d
.
previous_styles
(
)
.
is_some
(
)
{
d
.
ensure_restyle_data
(
)
;
}
d
}
pub
trait
DomTraversalContext
<
N
:
TNode
>
{
type
SharedContext
:
Sync
+
'
static
;
fn
new
<
'
a
>
(
&
'
a
Self
:
:
SharedContext
OpaqueNode
)
-
>
Self
;
fn
process_preorder
(
&
self
node
:
N
)
;
fn
process_postorder
(
&
self
node
:
N
)
;
fn
needs_postorder_traversal
(
&
self
)
-
>
bool
{
true
}
fn
should_traverse_child
(
parent
:
N
:
:
ConcreteElement
child
:
N
)
-
>
bool
;
fn
traverse_children
<
F
:
FnMut
(
N
)
>
(
parent
:
N
:
:
ConcreteElement
mut
f
:
F
)
{
let
mut
marked_dirty_descendants
=
false
;
for
kid
in
parent
.
as_node
(
)
.
children
(
)
{
if
Self
:
:
should_traverse_child
(
parent
kid
)
{
if
!
marked_dirty_descendants
{
unsafe
{
parent
.
set_dirty_descendants
(
)
;
}
marked_dirty_descendants
=
true
;
}
f
(
kid
)
;
}
}
}
unsafe
fn
ensure_element_data
(
element
:
&
N
:
:
ConcreteElement
)
-
>
&
AtomicRefCell
<
ElementData
>
;
unsafe
fn
prepare_for_styling
(
element
:
&
N
:
:
ConcreteElement
)
-
>
AtomicRefMut
<
ElementData
>
{
prepare_for_styling
(
*
element
Self
:
:
ensure_element_data
(
element
)
)
}
unsafe
fn
clear_element_data
(
element
:
&
N
:
:
ConcreteElement
)
;
fn
local_context
(
&
self
)
-
>
&
LocalStyleContext
;
}
#
[
inline
]
pub
fn
relations_are_shareable
(
relations
:
&
StyleRelations
)
-
>
bool
{
use
selectors
:
:
matching
:
:
*
;
!
relations
.
intersects
(
AFFECTED_BY_ID_SELECTOR
|
AFFECTED_BY_PSEUDO_ELEMENTS
|
AFFECTED_BY_STATE
|
AFFECTED_BY_NON_COMMON_STYLE_AFFECTING_ATTRIBUTE_SELECTOR
|
AFFECTED_BY_STYLE_ATTRIBUTE
|
AFFECTED_BY_PRESENTATIONAL_HINTS
)
}
pub
fn
ensure_element_styled
<
'
a
E
C
>
(
element
:
E
context
:
&
'
a
C
)
where
E
:
TElement
C
:
StyleContext
<
'
a
>
{
let
mut
display_none
=
false
;
ensure_element_styled_internal
(
element
context
&
mut
display_none
)
;
}
#
[
allow
(
unsafe_code
)
]
fn
ensure_element_styled_internal
<
'
a
E
C
>
(
element
:
E
context
:
&
'
a
C
parents_had_display_none
:
&
mut
bool
)
where
E
:
TElement
C
:
StyleContext
<
'
a
>
{
use
properties
:
:
longhands
:
:
display
:
:
computed_value
as
display
;
let
parent
=
element
.
parent_element
(
)
;
if
let
Some
(
parent
)
=
parent
{
ensure_element_styled_internal
(
parent
context
parents_had_display_none
)
;
}
if
let
Some
(
data
)
=
element
.
borrow_data
(
)
{
if
let
Some
(
style
)
=
data
.
get_current_styles
(
)
.
map
(
|
x
|
&
x
.
primary
)
{
if
!
*
parents_had_display_none
{
*
parents_had_display_none
=
style
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
T
:
:
none
;
return
;
}
}
}
let
mut
applicable_declarations
=
ApplicableDeclarations
:
:
new
(
)
;
let
data
=
prepare_for_styling
(
element
element
.
get_data
(
)
.
unwrap
(
)
)
;
let
stylist
=
&
context
.
shared_context
(
)
.
stylist
;
element
.
match_element
(
&
*
*
stylist
None
&
mut
applicable_declarations
)
;
unsafe
{
element
.
cascade_node
(
context
data
parent
applicable_declarations
)
;
}
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
pub
fn
recalc_style_at
<
'
a
E
C
D
>
(
context
:
&
'
a
C
root
:
OpaqueNode
element
:
E
)
where
E
:
TElement
C
:
StyleContext
<
'
a
>
D
:
DomTraversalContext
<
E
:
:
ConcreteNode
>
{
let
mut
bf
=
take_thread_local_bloom_filter
(
element
.
parent_element
(
)
root
context
.
shared_context
(
)
)
;
let
mode
=
element
.
styling_mode
(
)
;
debug_assert
!
(
mode
!
=
StylingMode
:
:
Stop
"
Parent
should
not
have
enqueued
us
"
)
;
if
mode
!
=
StylingMode
:
:
Traverse
{
let
mut
data
=
unsafe
{
D
:
:
prepare_for_styling
(
&
element
)
}
;
let
style_sharing_candidate_cache
=
&
mut
context
.
local_context
(
)
.
style_sharing_candidate_cache
.
borrow_mut
(
)
;
let
sharing_result
=
if
element
.
parent_element
(
)
.
is_none
(
)
{
StyleSharingResult
:
:
CannotShare
}
else
{
unsafe
{
element
.
share_style_if_possible
(
style_sharing_candidate_cache
context
.
shared_context
(
)
&
mut
data
)
}
}
;
match
sharing_result
{
StyleSharingResult
:
:
CannotShare
=
>
{
let
mut
applicable_declarations
=
ApplicableDeclarations
:
:
new
(
)
;
let
relations
;
let
shareable_element
=
{
if
opts
:
:
get
(
)
.
style_sharing_stats
{
STYLE_SHARING_CACHE_MISSES
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
let
stylist
=
&
context
.
shared_context
(
)
.
stylist
;
relations
=
element
.
match_element
(
&
*
*
stylist
Some
(
&
*
bf
)
&
mut
applicable_declarations
)
;
debug
!
(
"
Result
of
selector
matching
:
{
:
?
}
"
relations
)
;
if
relations_are_shareable
(
&
relations
)
{
Some
(
element
)
}
else
{
None
}
}
;
unsafe
{
element
.
cascade_node
(
context
data
element
.
parent_element
(
)
applicable_declarations
)
;
}
if
let
Some
(
element
)
=
shareable_element
{
style_sharing_candidate_cache
.
insert_if_possible
(
&
element
&
element
.
borrow_data
(
)
.
unwrap
(
)
.
current_styles
(
)
.
primary
relations
)
;
}
}
StyleSharingResult
:
:
StyleWasShared
(
index
damage
)
=
>
{
if
opts
:
:
get
(
)
.
style_sharing_stats
{
STYLE_SHARING_CACHE_HITS
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
style_sharing_candidate_cache
.
touch
(
index
)
;
mem
:
:
drop
(
data
)
;
element
.
set_restyle_damage
(
damage
)
;
}
}
}
if
element
.
is_display_none
(
)
{
fn
clear_descendant_data
<
E
:
TElement
D
:
DomTraversalContext
<
E
:
:
ConcreteNode
>
>
(
el
:
E
)
{
for
kid
in
el
.
as_node
(
)
.
children
(
)
{
if
let
Some
(
kid
)
=
kid
.
as_element
(
)
{
if
kid
.
get_data
(
)
.
is_some
(
)
{
unsafe
{
D
:
:
clear_element_data
(
&
kid
)
}
;
clear_descendant_data
:
:
<
_
D
>
(
kid
)
;
}
}
}
}
;
clear_descendant_data
:
:
<
_
D
>
(
element
)
;
}
else
if
mode
=
=
StylingMode
:
:
Restyle
{
for
kid
in
element
.
as_node
(
)
.
children
(
)
{
if
let
Some
(
kid
)
=
kid
.
as_element
(
)
{
unsafe
{
let
_
=
D
:
:
prepare_for_styling
(
&
kid
)
;
}
}
}
}
let
unsafe_layout_node
=
element
.
as_node
(
)
.
to_unsafe
(
)
;
debug
!
(
"
[
{
}
]
+
{
:
X
}
"
tid
(
)
unsafe_layout_node
.
0
)
;
element
.
insert_into_bloom_filter
(
&
mut
*
bf
)
;
put_thread_local_bloom_filter
(
bf
&
unsafe_layout_node
context
.
shared_context
(
)
)
;
}
