use
context
:
:
{
LocalStyleContext
SharedStyleContext
StyleContext
}
;
use
dom
:
:
{
OpaqueNode
TNode
TRestyleDamage
UnsafeNode
}
;
use
matching
:
:
{
ApplicableDeclarations
ElementMatchMethods
MatchMethods
StyleSharingResult
}
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
mem
;
use
std
:
:
rc
:
:
Rc
;
use
util
:
:
opts
;
use
util
:
:
tid
:
:
tid
;
pub
type
Generation
=
u32
;
thread_local
!
(
pub
static
STYLE_BLOOM
:
RefCell
<
Option
<
(
Box
<
BloomFilter
>
UnsafeNode
Generation
)
>
>
=
RefCell
:
:
new
(
None
)
)
;
fn
take_task_local_bloom_filter
<
'
ln
N
>
(
parent_node
:
Option
<
N
>
root
:
OpaqueNode
context
:
&
SharedStyleContext
)
-
>
Box
<
BloomFilter
>
where
N
:
TNode
<
'
ln
>
{
STYLE_BLOOM
.
with
(
|
style_bloom
|
{
match
(
parent_node
style_bloom
.
borrow_mut
(
)
.
take
(
)
)
{
(
None
_
)
=
>
{
debug
!
(
"
[
{
}
]
No
parent
but
new
bloom
filter
!
"
tid
(
)
)
;
box
BloomFilter
:
:
new
(
)
}
(
Some
(
parent
)
None
)
=
>
{
let
mut
bloom_filter
=
box
BloomFilter
:
:
new
(
)
;
insert_ancestors_into_bloom_filter
(
&
mut
bloom_filter
parent
root
)
;
bloom_filter
}
(
Some
(
parent
)
Some
(
(
mut
bloom_filter
old_node
old_generation
)
)
)
=
>
{
if
old_node
=
=
parent
.
to_unsafe
(
)
&
&
old_generation
=
=
context
.
generation
{
debug
!
(
"
[
{
}
]
Parent
matches
(
=
{
}
)
.
Reusing
bloom
filter
.
"
tid
(
)
old_node
.
0
)
;
}
else
{
bloom_filter
.
clear
(
)
;
insert_ancestors_into_bloom_filter
(
&
mut
bloom_filter
parent
root
)
;
}
bloom_filter
}
}
}
)
}
pub
fn
put_task_local_bloom_filter
(
bf
:
Box
<
BloomFilter
>
unsafe_node
:
&
UnsafeNode
context
:
&
SharedStyleContext
)
{
STYLE_BLOOM
.
with
(
move
|
style_bloom
|
{
assert
!
(
style_bloom
.
borrow
(
)
.
is_none
(
)
"
Putting
into
a
never
-
taken
task
-
local
bloom
filter
"
)
;
*
style_bloom
.
borrow_mut
(
)
=
Some
(
(
bf
*
unsafe_node
context
.
generation
)
)
;
}
)
}
fn
insert_ancestors_into_bloom_filter
<
'
ln
N
>
(
bf
:
&
mut
Box
<
BloomFilter
>
mut
n
:
N
root
:
OpaqueNode
)
where
N
:
TNode
<
'
ln
>
{
debug
!
(
"
[
{
}
]
Inserting
ancestors
.
"
tid
(
)
)
;
let
mut
ancestors
=
0
;
loop
{
ancestors
+
=
1
;
n
.
insert_into_bloom_filter
(
&
mut
*
*
bf
)
;
n
=
match
n
.
layout_parent_node
(
root
)
{
None
=
>
break
Some
(
p
)
=
>
p
}
;
}
debug
!
(
"
[
{
}
]
Inserted
{
}
ancestors
.
"
tid
(
)
ancestors
)
;
}
pub
trait
DomTraversalContext
<
'
ln
N
:
TNode
<
'
ln
>
>
{
type
SharedContext
:
Sync
+
'
static
;
fn
new
<
'
a
>
(
&
'
a
Self
:
:
SharedContext
OpaqueNode
)
-
>
Self
;
fn
process_preorder
(
&
self
node
:
N
)
;
fn
process_postorder
(
&
self
node
:
N
)
;
}
#
[
allow
(
dead_code
)
]
pub
struct
StandaloneStyleContext
<
'
a
>
{
pub
shared
:
&
'
a
SharedStyleContext
cached_local_style_context
:
Rc
<
LocalStyleContext
>
}
impl
<
'
a
>
StandaloneStyleContext
<
'
a
>
{
pub
fn
new
(
_
:
&
'
a
SharedStyleContext
)
-
>
Self
{
panic
!
(
"
Not
implemented
"
)
}
}
impl
<
'
a
>
StyleContext
<
'
a
>
for
StandaloneStyleContext
<
'
a
>
{
fn
shared_context
(
&
self
)
-
>
&
'
a
SharedStyleContext
{
&
self
.
shared
}
fn
local_context
(
&
self
)
-
>
&
LocalStyleContext
{
&
self
.
cached_local_style_context
}
}
#
[
allow
(
dead_code
)
]
pub
struct
RecalcStyleOnly
<
'
lc
>
{
context
:
StandaloneStyleContext
<
'
lc
>
root
:
OpaqueNode
}
impl
<
'
lc
'
ln
N
:
TNode
<
'
ln
>
>
DomTraversalContext
<
'
ln
N
>
for
RecalcStyleOnly
<
'
lc
>
{
type
SharedContext
=
SharedStyleContext
;
#
[
allow
(
unsafe_code
)
]
fn
new
<
'
a
>
(
shared
:
&
'
a
Self
:
:
SharedContext
root
:
OpaqueNode
)
-
>
Self
{
let
shared_lc
:
&
'
lc
SharedStyleContext
=
unsafe
{
mem
:
:
transmute
(
shared
)
}
;
RecalcStyleOnly
{
context
:
StandaloneStyleContext
:
:
new
(
shared_lc
)
root
:
root
}
}
fn
process_preorder
(
&
self
node
:
N
)
{
recalc_style_at
(
&
self
.
context
self
.
root
node
)
;
}
fn
process_postorder
(
&
self
_
:
N
)
{
}
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
pub
fn
recalc_style_at
<
'
a
'
ln
N
:
TNode
<
'
ln
>
C
:
StyleContext
<
'
a
>
>
(
context
:
&
'
a
C
root
:
OpaqueNode
node
:
N
)
{
node
.
initialize_data
(
)
;
let
parent_opt
=
node
.
layout_parent_node
(
root
)
;
let
mut
bf
=
take_task_local_bloom_filter
(
parent_opt
root
context
.
shared_context
(
)
)
;
let
nonincremental_layout
=
opts
:
:
get
(
)
.
nonincremental_layout
;
if
nonincremental_layout
|
|
node
.
is_dirty
(
)
{
if
node
.
has_changed
(
)
{
node
.
unstyle
(
)
;
}
let
style_sharing_candidate_cache
=
&
mut
context
.
local_context
(
)
.
style_sharing_candidate_cache
.
borrow_mut
(
)
;
let
sharing_result
=
match
node
.
as_element
(
)
{
Some
(
element
)
=
>
{
unsafe
{
element
.
share_style_if_possible
(
style_sharing_candidate_cache
parent_opt
.
clone
(
)
)
}
}
None
=
>
StyleSharingResult
:
:
CannotShare
}
;
match
sharing_result
{
StyleSharingResult
:
:
CannotShare
=
>
{
let
mut
applicable_declarations
=
ApplicableDeclarations
:
:
new
(
)
;
let
shareable_element
=
match
node
.
as_element
(
)
{
Some
(
element
)
=
>
{
let
stylist
=
unsafe
{
&
*
context
.
shared_context
(
)
.
stylist
.
0
}
;
if
element
.
match_element
(
stylist
Some
(
&
*
bf
)
&
mut
applicable_declarations
)
{
Some
(
element
)
}
else
{
None
}
}
None
=
>
{
if
node
.
has_changed
(
)
{
node
.
set_restyle_damage
(
N
:
:
ConcreteRestyleDamage
:
:
rebuild_and_reflow
(
)
)
}
None
}
}
;
unsafe
{
node
.
cascade_node
(
&
context
.
shared_context
(
)
parent_opt
&
applicable_declarations
&
mut
context
.
local_context
(
)
.
applicable_declarations_cache
.
borrow_mut
(
)
&
context
.
shared_context
(
)
.
new_animations_sender
)
;
}
if
let
Some
(
element
)
=
shareable_element
{
style_sharing_candidate_cache
.
insert_if_possible
(
&
element
)
;
}
}
StyleSharingResult
:
:
StyleWasShared
(
index
damage
)
=
>
{
style_sharing_candidate_cache
.
touch
(
index
)
;
node
.
set_restyle_damage
(
damage
)
;
}
}
}
let
unsafe_layout_node
=
node
.
to_unsafe
(
)
;
debug
!
(
"
[
{
}
]
+
{
:
X
}
"
tid
(
)
unsafe_layout_node
.
0
)
;
node
.
insert_into_bloom_filter
(
&
mut
*
bf
)
;
put_task_local_bloom_filter
(
bf
&
unsafe_layout_node
context
.
shared_context
(
)
)
;
}
