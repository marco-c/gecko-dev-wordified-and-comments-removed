use
atomic_refcell
:
:
{
AtomicRefCell
AtomicRefMut
}
;
use
bloom
:
:
StyleBloom
;
use
context
:
:
{
SharedStyleContext
StyleContext
ThreadLocalStyleContext
}
;
use
data
:
:
{
ElementData
StoredRestyleHint
}
;
use
dom
:
:
{
OpaqueNode
TElement
TNode
}
;
use
matching
:
:
{
MatchMethods
StyleSharingResult
}
;
use
restyle_hints
:
:
{
RESTYLE_DESCENDANTS
RESTYLE_SELF
}
;
use
selector_parser
:
:
RestyleDamage
;
use
selectors
:
:
Element
;
use
selectors
:
:
matching
:
:
StyleRelations
;
use
servo_config
:
:
opts
;
use
std
:
:
borrow
:
:
Borrow
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
mem
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
ATOMIC_USIZE_INIT
Ordering
}
;
use
stylist
:
:
Stylist
;
pub
type
Generation
=
u32
;
pub
static
STYLE_SHARING_CACHE_HITS
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
pub
static
STYLE_SHARING_CACHE_MISSES
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
thread_local
!
(
static
STYLE_BLOOM
:
RefCell
<
Option
<
StyleBloom
>
>
=
RefCell
:
:
new
(
None
)
)
;
pub
fn
take_thread_local_bloom_filter
(
context
:
&
SharedStyleContext
)
-
>
StyleBloom
{
trace
!
(
"
{
}
taking
bf
"
:
:
tid
:
:
tid
(
)
)
;
STYLE_BLOOM
.
with
(
|
style_bloom
|
{
style_bloom
.
borrow_mut
(
)
.
take
(
)
.
unwrap_or_else
(
|
|
StyleBloom
:
:
new
(
context
.
generation
)
)
}
)
}
pub
fn
put_thread_local_bloom_filter
(
bf
:
StyleBloom
)
{
trace
!
(
"
[
{
}
]
putting
bloom
filter
back
"
:
:
tid
:
:
tid
(
)
)
;
STYLE_BLOOM
.
with
(
move
|
style_bloom
|
{
debug_assert
!
(
style_bloom
.
borrow
(
)
.
is_none
(
)
"
Putting
into
a
never
-
taken
thread
-
local
bloom
filter
"
)
;
*
style_bloom
.
borrow_mut
(
)
=
Some
(
bf
)
;
}
)
}
pub
fn
remove_from_bloom_filter
<
E
:
TElement
>
(
context
:
&
SharedStyleContext
root
:
OpaqueNode
element
:
E
)
{
trace
!
(
"
[
{
}
]
remove_from_bloom_filter
"
:
:
tid
:
:
tid
(
)
)
;
let
bf
=
STYLE_BLOOM
.
with
(
|
style_bloom
|
{
style_bloom
.
borrow_mut
(
)
.
take
(
)
}
)
;
if
let
Some
(
mut
bf
)
=
bf
{
if
context
.
generation
=
=
bf
.
generation
(
)
{
bf
.
maybe_pop
(
element
)
;
if
element
.
as_node
(
)
.
opaque
(
)
!
=
root
{
put_thread_local_bloom_filter
(
bf
)
;
}
}
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
PerLevelTraversalData
{
pub
current_dom_depth
:
Option
<
usize
>
}
pub
struct
PreTraverseToken
{
traverse
:
bool
unstyled_children_only
:
bool
}
impl
PreTraverseToken
{
pub
fn
should_traverse
(
&
self
)
-
>
bool
{
self
.
traverse
}
pub
fn
traverse_unstyled_children_only
(
&
self
)
-
>
bool
{
self
.
unstyled_children_only
}
}
pub
enum
LogBehavior
{
MayLog
DontLog
}
use
self
:
:
LogBehavior
:
:
*
;
impl
LogBehavior
{
fn
allow
(
&
self
)
-
>
bool
{
match
*
self
{
MayLog
=
>
true
DontLog
=
>
false
}
}
}
pub
trait
DomTraversal
<
N
:
TNode
>
:
Sync
{
type
ThreadLocalContext
:
Borrow
<
ThreadLocalStyleContext
>
;
fn
process_preorder
(
&
self
node
:
N
data
:
&
mut
PerLevelTraversalData
)
;
fn
process_postorder
(
&
self
node
:
N
)
;
fn
needs_postorder_traversal
(
)
-
>
bool
{
true
}
fn
pre_traverse
(
root
:
N
:
:
ConcreteElement
stylist
:
&
Stylist
unstyled_children_only
:
bool
)
-
>
PreTraverseToken
{
if
unstyled_children_only
{
return
PreTraverseToken
{
traverse
:
true
unstyled_children_only
:
true
}
;
}
if
let
Some
(
mut
data
)
=
root
.
mutate_data
(
)
{
if
let
Some
(
r
)
=
data
.
as_restyle_mut
(
)
{
debug_assert
!
(
root
.
next_sibling_element
(
)
.
is_none
(
)
)
;
let
_later_siblings
=
r
.
expand_snapshot
(
root
stylist
)
;
}
}
PreTraverseToken
{
traverse
:
Self
:
:
node_needs_traversal
(
root
.
as_node
(
)
)
unstyled_children_only
:
false
}
}
fn
text_node_needs_traversal
(
node
:
N
)
-
>
bool
{
debug_assert
!
(
node
.
is_text_node
(
)
)
;
false
}
fn
node_needs_traversal
(
node
:
N
)
-
>
bool
{
if
cfg
!
(
feature
=
"
servo
"
)
&
&
opts
:
:
get
(
)
.
nonincremental_layout
{
return
true
;
}
match
node
.
as_element
(
)
{
None
=
>
Self
:
:
text_node_needs_traversal
(
node
)
Some
(
el
)
=
>
{
if
el
.
has_dirty_descendants
(
)
{
return
true
;
}
let
data
=
match
el
.
borrow_data
(
)
{
Some
(
d
)
=
>
d
None
=
>
return
true
}
;
let
restyle
=
match
*
data
{
ElementData
:
:
Initial
(
ref
i
)
=
>
return
i
.
is_none
(
)
ElementData
:
:
Persistent
(
_
)
=
>
return
false
ElementData
:
:
Restyle
(
ref
r
)
=
>
r
}
;
debug_assert
!
(
restyle
.
snapshot
.
is_none
(
)
"
Snapshots
should
already
be
expanded
"
)
;
if
!
restyle
.
hint
.
is_empty
(
)
|
|
restyle
.
recascade
{
return
true
;
}
if
cfg
!
(
feature
=
"
servo
"
)
&
&
restyle
.
damage
!
=
RestyleDamage
:
:
empty
(
)
{
return
true
;
}
false
}
}
}
fn
should_traverse_children
(
parent
:
N
:
:
ConcreteElement
parent_data
:
&
ElementData
log
:
LogBehavior
)
-
>
bool
{
debug_assert
!
(
cfg
!
(
feature
=
"
gecko
"
)
|
|
parent_data
.
has_current_styles
(
)
)
;
if
parent_data
.
styles
(
)
.
is_display_none
(
)
{
if
log
.
allow
(
)
{
debug
!
(
"
Parent
{
:
?
}
is
display
:
none
culling
traversal
"
parent
)
;
}
return
false
;
}
if
cfg
!
(
feature
=
"
gecko
"
)
&
&
parent_data
.
is_styled_initial
(
)
&
&
parent_data
.
styles
(
)
.
primary
.
values
.
has_moz_binding
(
)
{
if
log
.
allow
(
)
{
debug
!
(
"
Parent
{
:
?
}
has
XBL
binding
deferring
traversal
"
parent
)
;
}
return
false
;
}
return
true
;
}
fn
traverse_children
<
F
:
FnMut
(
N
)
>
(
parent
:
N
:
:
ConcreteElement
mut
f
:
F
)
{
if
!
Self
:
:
should_traverse_children
(
parent
&
parent
.
borrow_data
(
)
.
unwrap
(
)
MayLog
)
{
return
;
}
for
kid
in
parent
.
as_node
(
)
.
children
(
)
{
if
Self
:
:
node_needs_traversal
(
kid
)
{
let
el
=
kid
.
as_element
(
)
;
if
el
.
as_ref
(
)
.
and_then
(
|
el
|
el
.
borrow_data
(
)
)
.
map_or
(
false
|
d
|
d
.
is_restyle
(
)
)
{
unsafe
{
parent
.
set_dirty_descendants
(
)
;
}
}
f
(
kid
)
;
}
}
}
unsafe
fn
ensure_element_data
(
element
:
&
N
:
:
ConcreteElement
)
-
>
&
AtomicRefCell
<
ElementData
>
;
unsafe
fn
clear_element_data
(
element
:
&
N
:
:
ConcreteElement
)
;
fn
shared_context
(
&
self
)
-
>
&
SharedStyleContext
;
fn
create_or_get_thread_local_context
(
&
self
)
-
>
Rc
<
Self
:
:
ThreadLocalContext
>
;
}
#
[
inline
]
pub
fn
relations_are_shareable
(
relations
:
&
StyleRelations
)
-
>
bool
{
use
selectors
:
:
matching
:
:
*
;
!
relations
.
intersects
(
AFFECTED_BY_ID_SELECTOR
|
AFFECTED_BY_PSEUDO_ELEMENTS
|
AFFECTED_BY_STATE
|
AFFECTED_BY_NON_COMMON_STYLE_AFFECTING_ATTRIBUTE_SELECTOR
|
AFFECTED_BY_STYLE_ATTRIBUTE
|
AFFECTED_BY_PRESENTATIONAL_HINTS
)
}
pub
fn
style_element_in_display_none_subtree
<
E
F
>
(
context
:
&
StyleContext
element
:
E
init_data
:
&
F
)
-
>
E
where
E
:
TElement
F
:
Fn
(
E
)
{
if
element
.
get_data
(
)
.
is_some
(
)
{
debug_assert
!
(
cfg
!
(
feature
=
"
gecko
"
)
|
|
element
.
borrow_data
(
)
.
unwrap
(
)
.
has_current_styles
(
)
)
;
debug_assert
!
(
element
.
borrow_data
(
)
.
unwrap
(
)
.
styles
(
)
.
is_display_none
(
)
)
;
return
element
;
}
let
parent
=
element
.
parent_element
(
)
.
unwrap
(
)
;
let
display_none_root
=
style_element_in_display_none_subtree
(
context
parent
init_data
)
;
init_data
(
element
)
;
let
mut
data
=
element
.
mutate_data
(
)
.
unwrap
(
)
;
let
match_results
=
element
.
match_element
(
context
None
)
;
unsafe
{
let
shareable
=
match_results
.
primary_is_shareable
(
)
;
element
.
cascade_node
(
context
&
mut
data
Some
(
parent
)
match_results
.
primary
match_results
.
per_pseudo
shareable
)
;
}
display_none_root
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
pub
fn
recalc_style_at
<
E
D
>
(
traversal
:
&
D
traversal_data
:
&
mut
PerLevelTraversalData
context
:
&
StyleContext
element
:
E
mut
data
:
&
mut
AtomicRefMut
<
ElementData
>
)
where
E
:
TElement
D
:
DomTraversal
<
E
:
:
ConcreteNode
>
{
debug_assert
!
(
data
.
as_restyle
(
)
.
map_or
(
true
|
r
|
r
.
snapshot
.
is_none
(
)
)
"
Snapshots
should
be
expanded
by
the
caller
"
)
;
let
compute_self
=
!
data
.
has_current_styles
(
)
;
let
mut
inherited_style_changed
=
false
;
debug
!
(
"
recalc_style_at
:
{
:
?
}
(
compute_self
=
{
:
?
}
dirty_descendants
=
{
:
?
}
data
=
{
:
?
}
)
"
element
compute_self
element
.
has_dirty_descendants
(
)
data
)
;
if
compute_self
{
inherited_style_changed
=
compute_style
(
traversal
traversal_data
context
element
&
mut
data
)
;
}
let
empty_hint
=
StoredRestyleHint
:
:
empty
(
)
;
let
propagated_hint
=
match
data
.
as_restyle_mut
(
)
{
None
=
>
empty_hint
Some
(
r
)
=
>
{
r
.
recascade
=
false
;
mem
:
:
replace
(
&
mut
r
.
hint
empty_hint
)
.
propagate
(
)
}
}
;
debug_assert
!
(
data
.
has_current_styles
(
)
)
;
trace
!
(
"
propagated_hint
=
{
:
?
}
inherited_style_changed
=
{
:
?
}
"
propagated_hint
inherited_style_changed
)
;
if
D
:
:
should_traverse_children
(
element
&
data
DontLog
)
&
&
(
element
.
has_dirty_descendants
(
)
|
|
!
propagated_hint
.
is_empty
(
)
|
|
inherited_style_changed
)
{
preprocess_children
(
traversal
element
propagated_hint
inherited_style_changed
)
;
}
}
fn
compute_style
<
E
D
>
(
_traversal
:
&
D
traversal_data
:
&
mut
PerLevelTraversalData
context
:
&
StyleContext
element
:
E
mut
data
:
&
mut
AtomicRefMut
<
ElementData
>
)
-
>
bool
where
E
:
TElement
D
:
DomTraversal
<
E
:
:
ConcreteNode
>
{
let
shared_context
=
context
.
shared
;
let
mut
bf
=
take_thread_local_bloom_filter
(
shared_context
)
;
let
dom_depth
=
bf
.
insert_parents_recovering
(
element
traversal_data
.
current_dom_depth
shared_context
.
generation
)
;
traversal_data
.
current_dom_depth
=
Some
(
dom_depth
)
;
bf
.
assert_complete
(
element
)
;
let
mut
style_sharing_candidate_cache
=
context
.
thread_local
.
style_sharing_candidate_cache
.
borrow_mut
(
)
;
let
sharing_result
=
if
element
.
parent_element
(
)
.
is_none
(
)
{
StyleSharingResult
:
:
CannotShare
}
else
{
unsafe
{
element
.
share_style_if_possible
(
&
mut
style_sharing_candidate_cache
shared_context
&
mut
data
)
}
}
;
match
sharing_result
{
StyleSharingResult
:
:
CannotShare
=
>
{
let
match_results
;
let
shareable_element
=
{
if
opts
:
:
get
(
)
.
style_sharing_stats
{
STYLE_SHARING_CACHE_MISSES
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
match_results
=
element
.
match_element
(
context
Some
(
bf
.
filter
(
)
)
)
;
if
match_results
.
primary_is_shareable
(
)
{
Some
(
element
)
}
else
{
None
}
}
;
let
relations
=
match_results
.
relations
;
unsafe
{
let
shareable
=
match_results
.
primary_is_shareable
(
)
;
element
.
cascade_node
(
context
&
mut
data
element
.
parent_element
(
)
match_results
.
primary
match_results
.
per_pseudo
shareable
)
;
}
if
let
Some
(
element
)
=
shareable_element
{
style_sharing_candidate_cache
.
insert_if_possible
(
&
element
&
data
.
styles
(
)
.
primary
.
values
relations
)
;
}
}
StyleSharingResult
:
:
StyleWasShared
(
index
)
=
>
{
if
opts
:
:
get
(
)
.
style_sharing_stats
{
STYLE_SHARING_CACHE_HITS
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
style_sharing_candidate_cache
.
touch
(
index
)
;
}
}
let
display_none
=
data
.
styles
(
)
.
is_display_none
(
)
;
if
display_none
{
debug
!
(
"
New
element
style
is
display
:
none
-
clearing
data
from
descendants
.
"
)
;
clear_descendant_data
(
element
&
|
e
|
unsafe
{
D
:
:
clear_element_data
(
&
e
)
}
)
;
}
put_thread_local_bloom_filter
(
bf
)
;
let
inherited_styles_changed
=
true
;
inherited_styles_changed
}
fn
preprocess_children
<
E
D
>
(
traversal
:
&
D
element
:
E
mut
propagated_hint
:
StoredRestyleHint
parent_inherited_style_changed
:
bool
)
where
E
:
TElement
D
:
DomTraversal
<
E
:
:
ConcreteNode
>
{
for
child
in
element
.
as_node
(
)
.
children
(
)
{
let
child
=
match
child
.
as_element
(
)
{
Some
(
el
)
=
>
el
None
=
>
continue
}
;
let
mut
child_data
=
unsafe
{
D
:
:
ensure_element_data
(
&
child
)
.
borrow_mut
(
)
}
;
if
child_data
.
is_unstyled_initial
(
)
{
continue
;
}
let
mut
restyle_data
=
match
child_data
.
restyle
(
)
{
Some
(
d
)
=
>
d
None
=
>
continue
}
;
if
!
propagated_hint
.
is_empty
(
)
{
restyle_data
.
hint
.
insert
(
&
propagated_hint
)
;
}
let
stylist
=
&
traversal
.
shared_context
(
)
.
stylist
;
let
later_siblings
=
restyle_data
.
expand_snapshot
(
child
stylist
)
;
if
later_siblings
{
propagated_hint
.
insert
(
&
(
RESTYLE_SELF
|
RESTYLE_DESCENDANTS
)
.
into
(
)
)
;
}
if
parent_inherited_style_changed
{
restyle_data
.
recascade
=
true
;
}
}
}
pub
fn
clear_descendant_data
<
E
:
TElement
F
:
Fn
(
E
)
>
(
el
:
E
clear_data
:
&
F
)
{
for
kid
in
el
.
as_node
(
)
.
children
(
)
{
if
let
Some
(
kid
)
=
kid
.
as_element
(
)
{
if
kid
.
get_data
(
)
.
is_some
(
)
{
clear_data
(
kid
)
;
clear_descendant_data
(
kid
clear_data
)
;
}
}
}
unsafe
{
el
.
unset_dirty_descendants
(
)
;
}
}
