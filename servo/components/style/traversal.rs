#
!
[
deny
(
missing_docs
)
]
use
atomic_refcell
:
:
{
AtomicRefCell
AtomicRefMut
}
;
use
context
:
:
{
SharedStyleContext
StyleContext
ThreadLocalStyleContext
}
;
use
data
:
:
{
ElementData
ElementStyles
StoredRestyleHint
}
;
use
dom
:
:
{
DirtyDescendants
NodeInfo
OpaqueNode
TElement
TNode
}
;
use
matching
:
:
{
MatchMethods
StyleSharingBehavior
}
;
use
restyle_hints
:
:
{
RESTYLE_DESCENDANTS
RESTYLE_SELF
}
;
use
selector_parser
:
:
RestyleDamage
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
servo_config
:
:
opts
;
use
std
:
:
borrow
:
:
BorrowMut
;
use
stylist
:
:
Stylist
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
PerLevelTraversalData
{
pub
current_dom_depth
:
usize
}
bitflags
!
{
/
/
/
Flags
that
control
the
traversal
process
.
pub
flags
TraversalFlags
:
u8
{
/
/
/
Traverse
only
unstyled
children
.
const
UNSTYLED_CHILDREN_ONLY
=
0x01
/
/
/
Traverse
only
elements
for
animation
restyles
.
const
ANIMATION_ONLY
=
0x02
/
/
/
Traverse
without
generating
any
change
hints
.
const
FOR_RECONSTRUCT
=
0x04
}
}
impl
TraversalFlags
{
pub
fn
for_animation_only
(
&
self
)
-
>
bool
{
self
.
contains
(
ANIMATION_ONLY
)
}
pub
fn
for_unstyled_children_only
(
&
self
)
-
>
bool
{
self
.
contains
(
UNSTYLED_CHILDREN_ONLY
)
}
pub
fn
for_reconstruct
(
&
self
)
-
>
bool
{
self
.
contains
(
FOR_RECONSTRUCT
)
}
}
pub
struct
PreTraverseToken
{
traverse
:
bool
unstyled_children_only
:
bool
}
impl
PreTraverseToken
{
pub
fn
should_traverse
(
&
self
)
-
>
bool
{
self
.
traverse
}
pub
fn
traverse_unstyled_children_only
(
&
self
)
-
>
bool
{
self
.
unstyled_children_only
}
}
pub
enum
LogBehavior
{
MayLog
DontLog
}
use
self
:
:
LogBehavior
:
:
*
;
impl
LogBehavior
{
fn
allow
(
&
self
)
-
>
bool
{
matches
!
(
*
self
MayLog
)
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
enum
TraversalDriver
{
Parallel
Sequential
}
impl
TraversalDriver
{
#
[
inline
]
pub
fn
is_parallel
(
&
self
)
-
>
bool
{
matches
!
(
*
self
TraversalDriver
:
:
Parallel
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
is_servo_nonincremental_layout
(
)
-
>
bool
{
opts
:
:
get
(
)
.
nonincremental_layout
}
#
[
cfg
(
not
(
feature
=
"
servo
"
)
)
]
fn
is_servo_nonincremental_layout
(
)
-
>
bool
{
false
}
pub
trait
DomTraversal
<
E
:
TElement
>
:
Sync
{
type
ThreadLocalContext
:
Send
+
BorrowMut
<
ThreadLocalStyleContext
<
E
>
>
;
fn
process_preorder
(
&
self
data
:
&
PerLevelTraversalData
thread_local
:
&
mut
Self
:
:
ThreadLocalContext
node
:
E
:
:
ConcreteNode
)
;
fn
process_postorder
(
&
self
thread_local
:
&
mut
Self
:
:
ThreadLocalContext
node
:
E
:
:
ConcreteNode
)
;
fn
needs_postorder_traversal
(
)
-
>
bool
{
true
}
fn
handle_postorder_traversal
(
&
self
thread_local
:
&
mut
Self
:
:
ThreadLocalContext
root
:
OpaqueNode
mut
node
:
E
:
:
ConcreteNode
children_to_process
:
isize
)
{
if
!
Self
:
:
needs_postorder_traversal
(
)
{
return
;
}
if
children_to_process
=
=
0
{
loop
{
self
.
process_postorder
(
thread_local
node
)
;
if
node
.
opaque
(
)
=
=
root
{
break
;
}
let
parent
=
node
.
parent_element
(
)
.
unwrap
(
)
;
let
remaining
=
parent
.
did_process_child
(
)
;
if
remaining
!
=
0
{
break
}
node
=
parent
.
as_node
(
)
;
}
}
else
{
node
.
as_element
(
)
.
unwrap
(
)
.
store_children_to_process
(
children_to_process
)
;
}
}
fn
pre_traverse
(
root
:
E
stylist
:
&
Stylist
traversal_flags
:
TraversalFlags
)
-
>
PreTraverseToken
{
debug_assert
!
(
!
(
traversal_flags
.
for_reconstruct
(
)
&
&
traversal_flags
.
for_unstyled_children_only
(
)
)
"
must
not
specify
FOR_RECONSTRUCT
in
combination
with
UNSTYLED_CHILDREN_ONLY
"
)
;
if
traversal_flags
.
for_unstyled_children_only
(
)
{
if
root
.
borrow_data
(
)
.
map_or
(
true
|
d
|
d
.
has_styles
(
)
&
&
d
.
styles
(
)
.
is_display_none
(
)
)
{
return
PreTraverseToken
{
traverse
:
false
unstyled_children_only
:
false
}
;
}
return
PreTraverseToken
{
traverse
:
true
unstyled_children_only
:
true
}
;
}
if
let
Some
(
mut
data
)
=
root
.
mutate_data
(
)
{
if
let
Some
(
r
)
=
data
.
get_restyle_mut
(
)
{
let
later_siblings
=
r
.
compute_final_hint
(
root
stylist
)
;
if
later_siblings
{
if
let
Some
(
next
)
=
root
.
next_sibling_element
(
)
{
if
let
Some
(
mut
next_data
)
=
next
.
mutate_data
(
)
{
let
hint
=
StoredRestyleHint
:
:
subtree_and_later_siblings
(
)
;
next_data
.
ensure_restyle
(
)
.
hint
.
insert
(
&
hint
)
;
}
}
}
}
}
PreTraverseToken
{
traverse
:
Self
:
:
node_needs_traversal
(
root
.
as_node
(
)
traversal_flags
)
unstyled_children_only
:
false
}
}
fn
text_node_needs_traversal
(
node
:
E
:
:
ConcreteNode
)
-
>
bool
{
debug_assert
!
(
node
.
is_text_node
(
)
)
;
false
}
fn
node_needs_traversal
(
node
:
E
:
:
ConcreteNode
traversal_flags
:
TraversalFlags
)
-
>
bool
{
if
is_servo_nonincremental_layout
(
)
{
return
true
;
}
if
traversal_flags
.
for_reconstruct
(
)
{
return
true
;
}
match
node
.
as_element
(
)
{
None
=
>
Self
:
:
text_node_needs_traversal
(
node
)
Some
(
el
)
=
>
{
if
el
.
is_native_anonymous
(
)
{
if
let
Some
(
parent
)
=
el
.
parent_element
(
)
{
let
parent_data
=
parent
.
borrow_data
(
)
.
unwrap
(
)
;
if
let
Some
(
r
)
=
parent_data
.
get_restyle
(
)
{
if
(
r
.
damage
|
r
.
damage_handled
(
)
)
.
contains
(
RestyleDamage
:
:
reconstruct
(
)
)
{
debug
!
(
"
Element
{
:
?
}
is
in
doomed
NAC
subtree
-
culling
traversal
"
el
)
;
return
false
;
}
}
}
}
if
traversal_flags
.
for_animation_only
(
)
{
if
el
.
has_animation_only_dirty_descendants
(
)
{
return
true
;
}
let
data
=
match
el
.
borrow_data
(
)
{
Some
(
d
)
=
>
d
None
=
>
return
false
}
;
return
data
.
get_restyle
(
)
.
map_or
(
false
|
r
|
r
.
hint
.
has_animation_hint
(
)
|
|
r
.
recascade
)
;
}
if
el
.
has_dirty_descendants
(
)
{
return
true
;
}
let
data
=
match
el
.
borrow_data
(
)
{
Some
(
d
)
=
>
d
None
=
>
return
true
}
;
if
!
data
.
has_styles
(
)
{
return
true
;
}
if
let
Some
(
r
)
=
data
.
get_restyle
(
)
{
if
!
r
.
hint
.
is_empty
(
)
|
|
r
.
recascade
{
return
true
;
}
}
if
(
cfg
!
(
feature
=
"
servo
"
)
|
|
traversal_flags
.
for_reconstruct
(
)
)
&
&
data
.
get_restyle
(
)
.
map_or
(
false
|
r
|
r
.
damage
!
=
RestyleDamage
:
:
empty
(
)
)
{
return
true
;
}
false
}
}
}
fn
should_traverse_children
(
&
self
thread_local
:
&
mut
ThreadLocalStyleContext
<
E
>
parent
:
E
parent_data
:
&
ElementData
log
:
LogBehavior
)
-
>
bool
{
debug_assert
!
(
cfg
!
(
feature
=
"
gecko
"
)
|
|
parent_data
.
has_current_styles
(
)
)
;
if
parent_data
.
styles
(
)
.
is_display_none
(
)
{
if
log
.
allow
(
)
{
debug
!
(
"
Parent
{
:
?
}
is
display
:
none
culling
traversal
"
parent
)
;
}
return
false
;
}
if
cfg
!
(
feature
=
"
gecko
"
)
&
&
thread_local
.
is_initial_style
(
)
&
&
parent_data
.
styles
(
)
.
primary
.
values
(
)
.
has_moz_binding
(
)
{
if
log
.
allow
(
)
{
debug
!
(
"
Parent
{
:
?
}
has
XBL
binding
deferring
traversal
"
parent
)
;
}
return
false
;
}
return
true
;
}
fn
traverse_children
<
F
>
(
&
self
thread_local
:
&
mut
Self
:
:
ThreadLocalContext
parent
:
E
mut
f
:
F
)
where
F
:
FnMut
(
&
mut
Self
:
:
ThreadLocalContext
E
:
:
ConcreteNode
)
{
let
should_traverse
=
self
.
should_traverse_children
(
thread_local
.
borrow_mut
(
)
parent
&
parent
.
borrow_data
(
)
.
unwrap
(
)
MayLog
)
;
thread_local
.
borrow_mut
(
)
.
end_element
(
parent
)
;
if
!
should_traverse
{
return
;
}
for
kid
in
parent
.
as_node
(
)
.
children
(
)
{
if
Self
:
:
node_needs_traversal
(
kid
self
.
shared_context
(
)
.
traversal_flags
)
{
if
!
self
.
shared_context
(
)
.
traversal_flags
.
for_reconstruct
(
)
{
let
el
=
kid
.
as_element
(
)
;
if
el
.
as_ref
(
)
.
and_then
(
|
el
|
el
.
borrow_data
(
)
)
.
map_or
(
false
|
d
|
d
.
has_styles
(
)
)
{
unsafe
{
parent
.
set_dirty_descendants
(
)
;
}
}
}
f
(
thread_local
kid
)
;
}
}
}
unsafe
fn
ensure_element_data
(
element
:
&
E
)
-
>
&
AtomicRefCell
<
ElementData
>
;
unsafe
fn
clear_element_data
(
element
:
&
E
)
;
fn
shared_context
(
&
self
)
-
>
&
SharedStyleContext
;
fn
create_thread_local_context
(
&
self
)
-
>
Self
:
:
ThreadLocalContext
;
fn
is_parallel
(
&
self
)
-
>
bool
;
}
fn
resolve_style_internal
<
E
F
>
(
context
:
&
mut
StyleContext
<
E
>
element
:
E
ensure_data
:
&
F
)
-
>
Option
<
E
>
where
E
:
TElement
F
:
Fn
(
E
)
{
ensure_data
(
element
)
;
let
mut
data
=
element
.
mutate_data
(
)
.
unwrap
(
)
;
let
mut
display_none_root
=
None
;
if
data
.
get_styles
(
)
.
is_none
(
)
{
let
parent
=
element
.
parent_element
(
)
;
if
let
Some
(
p
)
=
parent
{
display_none_root
=
resolve_style_internal
(
context
p
ensure_data
)
;
}
if
context
.
thread_local
.
bloom_filter
.
is_empty
(
)
{
context
.
thread_local
.
bloom_filter
.
rebuild
(
element
)
;
}
else
{
context
.
thread_local
.
bloom_filter
.
push
(
parent
.
unwrap
(
)
)
;
context
.
thread_local
.
bloom_filter
.
assert_complete
(
element
)
;
}
context
.
thread_local
.
begin_element
(
element
&
data
)
;
element
.
match_and_cascade
(
context
&
mut
data
StyleSharingBehavior
:
:
Disallow
)
;
context
.
thread_local
.
end_element
(
element
)
;
unsafe
{
element
.
note_descendants
:
:
<
DirtyDescendants
>
(
)
}
;
}
if
display_none_root
.
is_none
(
)
&
&
data
.
styles
(
)
.
is_display_none
(
)
{
display_none_root
=
Some
(
element
)
;
}
return
display_none_root
}
pub
fn
resolve_style
<
E
F
G
H
>
(
context
:
&
mut
StyleContext
<
E
>
element
:
E
ensure_data
:
&
F
clear_data
:
&
G
callback
:
H
)
where
E
:
TElement
F
:
Fn
(
E
)
G
:
Fn
(
E
)
H
:
FnOnce
(
&
ElementStyles
)
{
context
.
thread_local
.
bloom_filter
.
clear
(
)
;
let
display_none_root
=
resolve_style_internal
(
context
element
ensure_data
)
;
callback
(
element
.
borrow_data
(
)
.
unwrap
(
)
.
styles
(
)
)
;
let
in_doc
=
element
.
as_node
(
)
.
is_in_doc
(
)
;
if
!
in_doc
|
|
display_none_root
.
is_some
(
)
{
let
mut
curr
=
element
;
loop
{
unsafe
{
curr
.
unset_dirty_descendants
(
)
;
}
if
in_doc
&
&
curr
=
=
display_none_root
.
unwrap
(
)
{
break
;
}
clear_data
(
curr
)
;
curr
=
match
curr
.
parent_element
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
break
}
;
}
}
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
pub
fn
recalc_style_at
<
E
D
>
(
traversal
:
&
D
traversal_data
:
&
PerLevelTraversalData
context
:
&
mut
StyleContext
<
E
>
element
:
E
mut
data
:
&
mut
AtomicRefMut
<
ElementData
>
)
where
E
:
TElement
D
:
DomTraversal
<
E
>
{
context
.
thread_local
.
begin_element
(
element
&
data
)
;
context
.
thread_local
.
statistics
.
elements_traversed
+
=
1
;
debug_assert
!
(
data
.
get_restyle
(
)
.
map_or
(
true
|
r
|
{
r
.
snapshot
.
is_none
(
)
&
&
!
r
.
has_sibling_invalidations
(
)
}
)
"
Should
'
ve
computed
the
final
hint
and
handled
later_siblings
already
"
)
;
let
compute_self
=
!
data
.
has_current_styles
(
)
;
let
mut
inherited_style_changed
=
false
;
debug
!
(
"
recalc_style_at
:
{
:
?
}
(
compute_self
=
{
:
?
}
dirty_descendants
=
{
:
?
}
data
=
{
:
?
}
)
"
element
compute_self
element
.
has_dirty_descendants
(
)
data
)
;
if
compute_self
{
compute_style
(
traversal
traversal_data
context
element
&
mut
data
)
;
let
display_none
=
data
.
styles
(
)
.
is_display_none
(
)
;
if
display_none
{
debug
!
(
"
New
element
style
is
display
:
none
-
clearing
data
from
descendants
.
"
)
;
clear_descendant_data
(
element
&
|
e
|
unsafe
{
D
:
:
clear_element_data
(
&
e
)
}
)
;
}
inherited_style_changed
=
true
;
}
let
propagated_hint
=
match
data
.
get_restyle_mut
(
)
{
None
=
>
StoredRestyleHint
:
:
empty
(
)
Some
(
r
)
=
>
{
debug_assert
!
(
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
|
|
!
r
.
hint
.
has_animation_hint
(
)
"
animation
restyle
hint
should
be
handled
during
\
animation
-
only
restyles
"
)
;
r
.
recascade
=
false
;
r
.
hint
.
propagate
(
)
}
}
;
debug_assert
!
(
data
.
has_current_styles
(
)
|
|
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
"
Should
have
computed
style
or
haven
'
t
yet
valid
computed
style
in
case
of
animation
-
only
restyle
"
)
;
trace
!
(
"
propagated_hint
=
{
:
?
}
inherited_style_changed
=
{
:
?
}
"
propagated_hint
inherited_style_changed
)
;
let
has_dirty_descendants_for_this_restyle
=
if
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
{
element
.
has_animation_only_dirty_descendants
(
)
}
else
{
element
.
has_dirty_descendants
(
)
}
;
if
traversal
.
should_traverse_children
(
&
mut
context
.
thread_local
element
&
data
DontLog
)
&
&
(
has_dirty_descendants_for_this_restyle
|
|
!
propagated_hint
.
is_empty
(
)
|
|
inherited_style_changed
)
{
let
damage_handled
=
data
.
get_restyle
(
)
.
map_or
(
RestyleDamage
:
:
empty
(
)
|
r
|
{
r
.
damage_handled
(
)
|
r
.
damage
.
handled_for_descendants
(
)
}
)
;
preprocess_children
(
traversal
element
propagated_hint
damage_handled
inherited_style_changed
)
;
}
if
context
.
shared
.
traversal_flags
.
for_reconstruct
(
)
{
data
.
clear_restyle
(
)
;
}
if
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
{
unsafe
{
element
.
unset_animation_only_dirty_descendants
(
)
;
}
}
if
data
.
styles
(
)
.
is_display_none
(
)
|
|
context
.
shared
.
traversal_flags
.
for_reconstruct
(
)
{
unsafe
{
element
.
unset_dirty_descendants
(
)
;
}
}
}
fn
compute_style
<
E
D
>
(
_traversal
:
&
D
traversal_data
:
&
PerLevelTraversalData
context
:
&
mut
StyleContext
<
E
>
element
:
E
mut
data
:
&
mut
AtomicRefMut
<
ElementData
>
)
where
E
:
TElement
D
:
DomTraversal
<
E
>
{
use
data
:
:
RestyleKind
:
:
*
;
use
matching
:
:
StyleSharingResult
:
:
*
;
context
.
thread_local
.
statistics
.
elements_styled
+
=
1
;
let
kind
=
data
.
restyle_kind
(
)
;
if
let
MatchAndCascade
=
kind
{
let
sharing_result
=
unsafe
{
element
.
share_style_if_possible
(
context
&
mut
data
)
}
;
if
let
StyleWasShared
(
index
)
=
sharing_result
{
context
.
thread_local
.
statistics
.
styles_shared
+
=
1
;
context
.
thread_local
.
style_sharing_candidate_cache
.
touch
(
index
)
;
return
;
}
}
match
kind
{
MatchAndCascade
=
>
{
context
.
thread_local
.
bloom_filter
.
insert_parents_recovering
(
element
traversal_data
.
current_dom_depth
)
;
context
.
thread_local
.
bloom_filter
.
assert_complete
(
element
)
;
context
.
thread_local
.
statistics
.
elements_matched
+
=
1
;
element
.
match_and_cascade
(
context
&
mut
data
StyleSharingBehavior
:
:
Allow
)
;
}
CascadeWithReplacements
(
hint
)
=
>
{
let
_rule_nodes_changed
=
element
.
replace_rules
(
hint
context
&
mut
data
)
;
element
.
cascade_primary_and_pseudos
(
context
&
mut
data
)
;
}
CascadeOnly
=
>
{
element
.
cascade_primary_and_pseudos
(
context
&
mut
data
)
;
}
}
;
}
fn
preprocess_children
<
E
D
>
(
traversal
:
&
D
element
:
E
mut
propagated_hint
:
StoredRestyleHint
damage_handled
:
RestyleDamage
parent_inherited_style_changed
:
bool
)
where
E
:
TElement
D
:
DomTraversal
<
E
>
{
trace
!
(
"
preprocess_children
:
{
:
?
}
"
element
)
;
for
child
in
element
.
as_node
(
)
.
children
(
)
{
let
child
=
match
child
.
as_element
(
)
{
Some
(
el
)
=
>
el
None
=
>
continue
}
;
let
mut
child_data
=
unsafe
{
D
:
:
ensure_element_data
(
&
child
)
.
borrow_mut
(
)
}
;
if
!
child_data
.
has_styles
(
)
{
continue
;
}
if
propagated_hint
.
is_empty
(
)
&
&
!
parent_inherited_style_changed
&
&
damage_handled
.
is_empty
(
)
&
&
!
child_data
.
has_restyle
(
)
{
continue
;
}
let
mut
restyle_data
=
child_data
.
ensure_restyle
(
)
;
if
!
propagated_hint
.
is_empty
(
)
{
restyle_data
.
hint
.
insert
(
&
propagated_hint
)
;
}
let
stylist
=
&
traversal
.
shared_context
(
)
.
stylist
;
let
later_siblings
=
restyle_data
.
compute_final_hint
(
child
stylist
)
;
trace
!
(
"
>
{
:
?
}
-
>
{
:
?
}
later_siblings
:
{
:
?
}
"
child
restyle_data
.
hint
later_siblings
)
;
if
later_siblings
{
propagated_hint
.
insert
(
&
(
RESTYLE_SELF
|
RESTYLE_DESCENDANTS
)
.
into
(
)
)
;
}
restyle_data
.
set_damage_handled
(
damage_handled
)
;
if
parent_inherited_style_changed
{
restyle_data
.
recascade
=
true
;
}
}
}
pub
fn
clear_descendant_data
<
E
:
TElement
F
:
Fn
(
E
)
>
(
el
:
E
clear_data
:
&
F
)
{
for
kid
in
el
.
as_node
(
)
.
children
(
)
{
if
let
Some
(
kid
)
=
kid
.
as_element
(
)
{
if
kid
.
get_data
(
)
.
is_some
(
)
{
clear_data
(
kid
)
;
clear_descendant_data
(
kid
clear_data
)
;
}
}
}
unsafe
{
el
.
unset_dirty_descendants
(
)
;
}
}
