use
animation
;
use
context
:
:
{
LocalStyleContext
SharedStyleContext
StyleContext
}
;
use
dom
:
:
{
OpaqueNode
TNode
TRestyleDamage
UnsafeNode
}
;
use
matching
:
:
{
ApplicableDeclarations
ElementMatchMethods
MatchMethods
StyleSharingResult
}
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
use
selectors
:
:
matching
:
:
StyleRelations
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
ATOMIC_USIZE_INIT
Ordering
}
;
use
tid
:
:
tid
;
use
util
:
:
opts
;
pub
type
Generation
=
u32
;
pub
enum
RestyleResult
{
Continue
Stop
}
pub
static
STYLE_SHARING_CACHE_HITS
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
pub
static
STYLE_SHARING_CACHE_MISSES
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
thread_local
!
(
static
STYLE_BLOOM
:
RefCell
<
Option
<
(
Box
<
BloomFilter
>
UnsafeNode
Generation
)
>
>
=
RefCell
:
:
new
(
None
)
)
;
fn
take_thread_local_bloom_filter
<
N
>
(
parent_node
:
Option
<
N
>
root
:
OpaqueNode
context
:
&
SharedStyleContext
)
-
>
Box
<
BloomFilter
>
where
N
:
TNode
{
STYLE_BLOOM
.
with
(
|
style_bloom
|
{
match
(
parent_node
style_bloom
.
borrow_mut
(
)
.
take
(
)
)
{
(
None
_
)
=
>
{
debug
!
(
"
[
{
}
]
No
parent
but
new
bloom
filter
!
"
tid
(
)
)
;
Box
:
:
new
(
BloomFilter
:
:
new
(
)
)
}
(
Some
(
parent
)
None
)
=
>
{
let
mut
bloom_filter
=
Box
:
:
new
(
BloomFilter
:
:
new
(
)
)
;
insert_ancestors_into_bloom_filter
(
&
mut
bloom_filter
parent
root
)
;
bloom_filter
}
(
Some
(
parent
)
Some
(
(
mut
bloom_filter
old_node
old_generation
)
)
)
=
>
{
if
old_node
=
=
parent
.
to_unsafe
(
)
&
&
old_generation
=
=
context
.
generation
{
debug
!
(
"
[
{
}
]
Parent
matches
(
=
{
}
)
.
Reusing
bloom
filter
.
"
tid
(
)
old_node
.
0
)
;
}
else
{
bloom_filter
.
clear
(
)
;
insert_ancestors_into_bloom_filter
(
&
mut
bloom_filter
parent
root
)
;
}
bloom_filter
}
}
}
)
}
fn
put_thread_local_bloom_filter
(
bf
:
Box
<
BloomFilter
>
unsafe_node
:
&
UnsafeNode
context
:
&
SharedStyleContext
)
{
STYLE_BLOOM
.
with
(
move
|
style_bloom
|
{
assert
!
(
style_bloom
.
borrow
(
)
.
is_none
(
)
"
Putting
into
a
never
-
taken
thread
-
local
bloom
filter
"
)
;
*
style_bloom
.
borrow_mut
(
)
=
Some
(
(
bf
*
unsafe_node
context
.
generation
)
)
;
}
)
}
fn
insert_ancestors_into_bloom_filter
<
N
>
(
bf
:
&
mut
Box
<
BloomFilter
>
mut
n
:
N
root
:
OpaqueNode
)
where
N
:
TNode
{
debug
!
(
"
[
{
}
]
Inserting
ancestors
.
"
tid
(
)
)
;
let
mut
ancestors
=
0
;
loop
{
ancestors
+
=
1
;
n
.
insert_into_bloom_filter
(
&
mut
*
*
bf
)
;
n
=
match
n
.
layout_parent_node
(
root
)
{
None
=
>
break
Some
(
p
)
=
>
p
}
;
}
debug
!
(
"
[
{
}
]
Inserted
{
}
ancestors
.
"
tid
(
)
ancestors
)
;
}
pub
fn
remove_from_bloom_filter
<
'
a
N
C
>
(
context
:
&
C
root
:
OpaqueNode
node
:
N
)
where
N
:
TNode
C
:
StyleContext
<
'
a
>
{
let
unsafe_layout_node
=
node
.
to_unsafe
(
)
;
let
(
mut
bf
old_node
old_generation
)
=
STYLE_BLOOM
.
with
(
|
style_bloom
|
{
style_bloom
.
borrow_mut
(
)
.
take
(
)
.
expect
(
"
The
bloom
filter
should
have
been
set
by
style
recalc
.
"
)
}
)
;
assert_eq
!
(
old_node
unsafe_layout_node
)
;
assert_eq
!
(
old_generation
context
.
shared_context
(
)
.
generation
)
;
match
node
.
layout_parent_node
(
root
)
{
None
=
>
{
debug
!
(
"
[
{
}
]
-
{
:
X
}
and
deleting
BF
.
"
tid
(
)
unsafe_layout_node
.
0
)
;
}
Some
(
parent
)
=
>
{
node
.
remove_from_bloom_filter
(
&
mut
*
bf
)
;
let
unsafe_parent
=
parent
.
to_unsafe
(
)
;
put_thread_local_bloom_filter
(
bf
&
unsafe_parent
&
context
.
shared_context
(
)
)
;
}
}
;
}
pub
trait
DomTraversalContext
<
N
:
TNode
>
{
type
SharedContext
:
Sync
+
'
static
;
fn
new
<
'
a
>
(
&
'
a
Self
:
:
SharedContext
OpaqueNode
)
-
>
Self
;
fn
process_preorder
(
&
self
node
:
N
)
-
>
RestyleResult
;
fn
process_postorder
(
&
self
node
:
N
)
;
fn
needs_postorder_traversal
(
&
self
)
-
>
bool
{
true
}
fn
should_process
(
&
self
node
:
N
)
-
>
bool
{
node
.
is_dirty
(
)
|
|
node
.
has_dirty_descendants
(
)
}
#
[
allow
(
unsafe_code
)
]
fn
pre_process_child_hook
(
&
self
parent
:
N
kid
:
N
)
{
if
parent
.
is_dirty
(
)
{
unsafe
{
kid
.
set_dirty
(
true
)
;
parent
.
set_dirty_descendants
(
true
)
;
}
}
}
fn
local_context
(
&
self
)
-
>
&
LocalStyleContext
;
}
#
[
inline
]
pub
fn
relations_are_shareable
(
relations
:
&
StyleRelations
)
-
>
bool
{
use
selectors
:
:
matching
:
:
*
;
!
relations
.
intersects
(
AFFECTED_BY_ID_SELECTOR
|
AFFECTED_BY_PSEUDO_ELEMENTS
|
AFFECTED_BY_STATE
|
AFFECTED_BY_NON_COMMON_STYLE_AFFECTING_ATTRIBUTE_SELECTOR
|
AFFECTED_BY_STYLE_ATTRIBUTE
|
AFFECTED_BY_PRESENTATIONAL_HINTS
)
}
pub
fn
ensure_node_styled
<
'
a
N
C
>
(
node
:
N
context
:
&
'
a
C
)
where
N
:
TNode
C
:
StyleContext
<
'
a
>
{
let
mut
display_none
=
false
;
ensure_node_styled_internal
(
node
context
&
mut
display_none
)
;
}
#
[
allow
(
unsafe_code
)
]
fn
ensure_node_styled_internal
<
'
a
N
C
>
(
node
:
N
context
:
&
'
a
C
parents_had_display_none
:
&
mut
bool
)
where
N
:
TNode
C
:
StyleContext
<
'
a
>
{
use
properties
:
:
longhands
:
:
display
:
:
computed_value
as
display
;
debug_assert
!
(
node
.
borrow_data
(
)
.
is_some
(
)
"
Need
to
initialize
the
data
before
calling
ensure_node_styled
"
)
;
let
parent
=
match
node
.
parent_node
(
)
{
Some
(
parent
)
if
parent
.
is_element
(
)
=
>
Some
(
parent
)
_
=
>
None
}
;
if
let
Some
(
parent
)
=
parent
{
ensure_node_styled_internal
(
parent
context
parents_had_display_none
)
;
}
if
let
Some
(
ref
style
)
=
node
.
borrow_data
(
)
.
unwrap
(
)
.
style
{
if
!
*
parents_had_display_none
{
*
parents_had_display_none
=
style
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
T
:
:
none
;
return
;
}
}
let
mut
applicable_declarations
=
ApplicableDeclarations
:
:
new
(
)
;
if
let
Some
(
element
)
=
node
.
as_element
(
)
{
let
stylist
=
&
context
.
shared_context
(
)
.
stylist
;
element
.
match_element
(
&
*
*
stylist
None
&
mut
applicable_declarations
)
;
}
unsafe
{
node
.
cascade_node
(
context
parent
&
applicable_declarations
)
;
}
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
pub
fn
recalc_style_at
<
'
a
N
C
>
(
context
:
&
'
a
C
root
:
OpaqueNode
node
:
N
)
-
>
RestyleResult
where
N
:
TNode
C
:
StyleContext
<
'
a
>
{
let
parent_opt
=
match
node
.
parent_node
(
)
{
Some
(
parent
)
if
parent
.
is_element
(
)
=
>
Some
(
parent
)
_
=
>
None
}
;
let
mut
bf
=
take_thread_local_bloom_filter
(
parent_opt
root
context
.
shared_context
(
)
)
;
let
nonincremental_layout
=
opts
:
:
get
(
)
.
nonincremental_layout
;
let
mut
restyle_result
=
RestyleResult
:
:
Continue
;
if
nonincremental_layout
|
|
node
.
is_dirty
(
)
{
if
node
.
has_changed
(
)
{
node
.
unstyle
(
)
;
}
let
style_sharing_candidate_cache
=
&
mut
context
.
local_context
(
)
.
style_sharing_candidate_cache
.
borrow_mut
(
)
;
let
sharing_result
=
match
node
.
as_element
(
)
{
Some
(
element
)
=
>
{
unsafe
{
element
.
share_style_if_possible
(
style_sharing_candidate_cache
context
.
shared_context
(
)
parent_opt
.
clone
(
)
)
}
}
None
=
>
StyleSharingResult
:
:
CannotShare
}
;
match
sharing_result
{
StyleSharingResult
:
:
CannotShare
=
>
{
let
mut
applicable_declarations
=
ApplicableDeclarations
:
:
new
(
)
;
let
relations
;
let
shareable_element
=
match
node
.
as_element
(
)
{
Some
(
element
)
=
>
{
if
opts
:
:
get
(
)
.
style_sharing_stats
{
STYLE_SHARING_CACHE_MISSES
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
let
stylist
=
&
context
.
shared_context
(
)
.
stylist
;
relations
=
element
.
match_element
(
&
*
*
stylist
Some
(
&
*
bf
)
&
mut
applicable_declarations
)
;
debug
!
(
"
Result
of
selector
matching
:
{
:
?
}
"
relations
)
;
if
relations_are_shareable
(
&
relations
)
{
Some
(
element
)
}
else
{
None
}
}
None
=
>
{
relations
=
StyleRelations
:
:
empty
(
)
;
if
node
.
has_changed
(
)
{
node
.
set_restyle_damage
(
N
:
:
ConcreteRestyleDamage
:
:
rebuild_and_reflow
(
)
)
}
None
}
}
;
unsafe
{
restyle_result
=
node
.
cascade_node
(
context
parent_opt
&
applicable_declarations
)
;
}
if
let
Some
(
element
)
=
shareable_element
{
style_sharing_candidate_cache
.
insert_if_possible
(
&
element
relations
)
;
}
}
StyleSharingResult
:
:
StyleWasShared
(
index
damage
cached_restyle_result
)
=
>
{
restyle_result
=
cached_restyle_result
;
if
opts
:
:
get
(
)
.
style_sharing_stats
{
STYLE_SHARING_CACHE_HITS
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
style_sharing_candidate_cache
.
touch
(
index
)
;
node
.
set_restyle_damage
(
damage
)
;
}
}
}
else
{
animation
:
:
complete_expired_transitions
(
node
.
opaque
(
)
node
.
mutate_data
(
)
.
unwrap
(
)
.
style
.
as_mut
(
)
.
unwrap
(
)
context
.
shared_context
(
)
)
;
}
let
unsafe_layout_node
=
node
.
to_unsafe
(
)
;
debug
!
(
"
[
{
}
]
+
{
:
X
}
"
tid
(
)
unsafe_layout_node
.
0
)
;
node
.
insert_into_bloom_filter
(
&
mut
*
bf
)
;
put_thread_local_bloom_filter
(
bf
&
unsafe_layout_node
context
.
shared_context
(
)
)
;
if
nonincremental_layout
{
RestyleResult
:
:
Continue
}
else
{
restyle_result
}
}
