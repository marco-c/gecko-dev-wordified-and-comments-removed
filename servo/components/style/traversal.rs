use
animation
;
use
context
:
:
{
SharedStyleContext
StyleContext
}
;
use
dom
:
:
{
OpaqueNode
TElement
TNode
TRestyleDamage
UnsafeNode
}
;
use
matching
:
:
{
ApplicableDeclarations
ElementMatchMethods
MatchMethods
StyleSharingResult
}
;
use
selector_impl
:
:
SelectorImplExt
;
use
selectors
:
:
Element
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
sync
:
:
Arc
;
use
tid
:
:
tid
;
use
util
:
:
opts
;
use
values
:
:
HasViewportPercentage
;
pub
type
Generation
=
u32
;
thread_local
!
(
static
STYLE_BLOOM
:
RefCell
<
Option
<
(
Box
<
BloomFilter
>
UnsafeNode
Generation
)
>
>
=
RefCell
:
:
new
(
None
)
)
;
fn
take_thread_local_bloom_filter
<
N
>
(
parent_node
:
Option
<
N
>
root
:
OpaqueNode
context
:
&
SharedStyleContext
)
-
>
Box
<
BloomFilter
>
where
N
:
TNode
{
STYLE_BLOOM
.
with
(
|
style_bloom
|
{
match
(
parent_node
style_bloom
.
borrow_mut
(
)
.
take
(
)
)
{
(
None
_
)
=
>
{
debug
!
(
"
[
{
}
]
No
parent
but
new
bloom
filter
!
"
tid
(
)
)
;
Box
:
:
new
(
BloomFilter
:
:
new
(
)
)
}
(
Some
(
parent
)
None
)
=
>
{
let
mut
bloom_filter
=
Box
:
:
new
(
BloomFilter
:
:
new
(
)
)
;
insert_ancestors_into_bloom_filter
(
&
mut
bloom_filter
parent
root
)
;
bloom_filter
}
(
Some
(
parent
)
Some
(
(
mut
bloom_filter
old_node
old_generation
)
)
)
=
>
{
if
old_node
=
=
parent
.
to_unsafe
(
)
&
&
old_generation
=
=
context
.
generation
{
debug
!
(
"
[
{
}
]
Parent
matches
(
=
{
}
)
.
Reusing
bloom
filter
.
"
tid
(
)
old_node
.
0
)
;
}
else
{
bloom_filter
.
clear
(
)
;
insert_ancestors_into_bloom_filter
(
&
mut
bloom_filter
parent
root
)
;
}
bloom_filter
}
}
}
)
}
fn
put_thread_local_bloom_filter
(
bf
:
Box
<
BloomFilter
>
unsafe_node
:
&
UnsafeNode
context
:
&
SharedStyleContext
)
{
STYLE_BLOOM
.
with
(
move
|
style_bloom
|
{
assert
!
(
style_bloom
.
borrow
(
)
.
is_none
(
)
"
Putting
into
a
never
-
taken
thread
-
local
bloom
filter
"
)
;
*
style_bloom
.
borrow_mut
(
)
=
Some
(
(
bf
*
unsafe_node
context
.
generation
)
)
;
}
)
}
fn
insert_ancestors_into_bloom_filter
<
N
>
(
bf
:
&
mut
Box
<
BloomFilter
>
mut
n
:
N
root
:
OpaqueNode
)
where
N
:
TNode
{
debug
!
(
"
[
{
}
]
Inserting
ancestors
.
"
tid
(
)
)
;
let
mut
ancestors
=
0
;
loop
{
ancestors
+
=
1
;
n
.
insert_into_bloom_filter
(
&
mut
*
*
bf
)
;
n
=
match
n
.
layout_parent_node
(
root
)
{
None
=
>
break
Some
(
p
)
=
>
p
}
;
}
debug
!
(
"
[
{
}
]
Inserted
{
}
ancestors
.
"
tid
(
)
ancestors
)
;
}
pub
fn
remove_from_bloom_filter
<
'
a
N
C
>
(
context
:
&
C
root
:
OpaqueNode
node
:
N
)
where
N
:
TNode
C
:
StyleContext
<
'
a
>
{
let
unsafe_layout_node
=
node
.
to_unsafe
(
)
;
let
(
mut
bf
old_node
old_generation
)
=
STYLE_BLOOM
.
with
(
|
style_bloom
|
{
style_bloom
.
borrow_mut
(
)
.
take
(
)
.
expect
(
"
The
bloom
filter
should
have
been
set
by
style
recalc
.
"
)
}
)
;
assert_eq
!
(
old_node
unsafe_layout_node
)
;
assert_eq
!
(
old_generation
context
.
shared_context
(
)
.
generation
)
;
match
node
.
layout_parent_node
(
root
)
{
None
=
>
{
debug
!
(
"
[
{
}
]
-
{
:
X
}
and
deleting
BF
.
"
tid
(
)
unsafe_layout_node
.
0
)
;
}
Some
(
parent
)
=
>
{
node
.
remove_from_bloom_filter
(
&
mut
*
bf
)
;
let
unsafe_parent
=
parent
.
to_unsafe
(
)
;
put_thread_local_bloom_filter
(
bf
&
unsafe_parent
&
context
.
shared_context
(
)
)
;
}
}
;
}
pub
trait
DomTraversalContext
<
N
:
TNode
>
{
type
SharedContext
:
Sync
+
'
static
;
fn
new
<
'
a
>
(
&
'
a
Self
:
:
SharedContext
OpaqueNode
)
-
>
Self
;
fn
process_preorder
(
&
self
node
:
N
)
;
fn
process_postorder
(
&
self
node
:
N
)
;
fn
should_process
(
&
self
node
:
N
)
-
>
bool
{
node
.
is_dirty
(
)
|
|
node
.
has_dirty_descendants
(
)
}
#
[
allow
(
unsafe_code
)
]
fn
pre_process_child_hook
(
&
self
parent
:
N
kid
:
N
)
{
if
parent
.
is_dirty
(
)
{
unsafe
{
kid
.
set_dirty
(
true
)
;
parent
.
set_dirty_descendants
(
true
)
;
}
}
}
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
pub
fn
recalc_style_at
<
'
a
N
C
>
(
context
:
&
'
a
C
root
:
OpaqueNode
node
:
N
)
where
N
:
TNode
C
:
StyleContext
<
'
a
>
<
N
:
:
ConcreteElement
as
Element
>
:
:
Impl
:
SelectorImplExt
+
'
a
{
let
parent_opt
=
match
node
.
parent_node
(
)
{
Some
(
parent
)
if
parent
.
is_element
(
)
=
>
Some
(
parent
)
_
=
>
None
}
;
let
mut
bf
=
take_thread_local_bloom_filter
(
parent_opt
root
context
.
shared_context
(
)
)
;
let
nonincremental_layout
=
opts
:
:
get
(
)
.
nonincremental_layout
;
if
nonincremental_layout
|
|
node
.
is_dirty
(
)
{
if
node
.
has_changed
(
)
{
node
.
unstyle
(
)
;
}
let
style_sharing_candidate_cache
=
&
mut
context
.
local_context
(
)
.
style_sharing_candidate_cache
.
borrow_mut
(
)
;
let
sharing_result
=
match
node
.
as_element
(
)
{
Some
(
element
)
=
>
{
unsafe
{
element
.
share_style_if_possible
(
style_sharing_candidate_cache
parent_opt
.
clone
(
)
)
}
}
None
=
>
StyleSharingResult
:
:
CannotShare
}
;
match
sharing_result
{
StyleSharingResult
:
:
CannotShare
=
>
{
let
mut
applicable_declarations
=
ApplicableDeclarations
:
:
new
(
)
;
let
shareable_element
=
match
node
.
as_element
(
)
{
Some
(
element
)
=
>
{
let
stylist
=
&
context
.
shared_context
(
)
.
stylist
;
if
element
.
match_element
(
&
*
*
stylist
Some
(
&
*
bf
)
&
mut
applicable_declarations
)
{
Some
(
element
)
}
else
{
None
}
}
None
=
>
{
if
node
.
has_changed
(
)
{
node
.
set_restyle_damage
(
N
:
:
ConcreteRestyleDamage
:
:
rebuild_and_reflow
(
)
)
}
None
}
}
;
unsafe
{
node
.
cascade_node
(
context
parent_opt
&
applicable_declarations
)
;
}
if
let
Some
(
element
)
=
shareable_element
{
style_sharing_candidate_cache
.
insert_if_possible
:
:
<
'
ln
N
>
(
&
element
)
;
}
}
StyleSharingResult
:
:
StyleWasShared
(
index
damage
)
=
>
{
style_sharing_candidate_cache
.
touch
(
index
)
;
node
.
set_restyle_damage
(
damage
)
;
}
}
}
else
{
animation
:
:
complete_expired_transitions
(
node
.
opaque
(
)
node
.
mutate_data
(
)
.
unwrap
(
)
.
style
.
as_mut
(
)
.
unwrap
(
)
context
.
shared_context
(
)
)
;
}
let
unsafe_layout_node
=
node
.
to_unsafe
(
)
;
debug
!
(
"
[
{
}
]
+
{
:
X
}
"
tid
(
)
unsafe_layout_node
.
0
)
;
node
.
insert_into_bloom_filter
(
&
mut
*
bf
)
;
put_thread_local_bloom_filter
(
bf
&
unsafe_layout_node
context
.
shared_context
(
)
)
;
if
!
node
.
needs_dirty_on_viewport_size_changed
(
)
{
if
let
Some
(
element
)
=
node
.
as_element
(
)
{
if
let
Some
(
ref
property_declaration_block
)
=
*
element
.
style_attribute
(
)
{
if
property_declaration_block
.
declarations
(
)
.
any
(
|
d
|
d
.
0
.
has_viewport_percentage
(
)
)
{
unsafe
{
node
.
set_dirty_on_viewport_size_changed
(
)
;
}
}
}
}
}
}
