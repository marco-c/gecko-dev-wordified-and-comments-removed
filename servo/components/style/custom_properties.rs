use
crate
:
:
hash
:
:
map
:
:
Entry
;
use
crate
:
:
properties
:
:
{
CSSWideKeyword
CustomDeclaration
CustomDeclarationValue
}
;
use
crate
:
:
selector_map
:
:
{
PrecomputedHashMap
PrecomputedHashSet
PrecomputedHasher
}
;
use
crate
:
:
stylesheets
:
:
{
Origin
PerOrigin
}
;
use
crate
:
:
Atom
;
use
cssparser
:
:
{
Delimiter
Parser
ParserInput
SourcePosition
Token
TokenSerializationType
}
;
use
indexmap
:
:
IndexMap
;
use
selectors
:
:
parser
:
:
SelectorParseErrorKind
;
use
servo_arc
:
:
Arc
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
cmp
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
hash
:
:
BuildHasherDefault
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
#
[
derive
(
Debug
MallocSizeOf
)
]
pub
struct
CssEnvironment
;
struct
EnvironmentVariable
{
name
:
Atom
value
:
VariableValue
}
macro_rules
!
make_variable
{
(
name
:
expr
value
:
expr
)
=
>
{
{
EnvironmentVariable
{
name
:
name
value
:
{
/
/
TODO
(
emilio
)
:
We
could
make
this
be
more
efficient
(
though
a
/
/
bit
less
convenient
)
.
let
mut
input
=
ParserInput
:
:
new
(
value
)
;
let
mut
input
=
Parser
:
:
new
(
&
mut
input
)
;
let
(
first_token_type
css
last_token_type
)
=
parse_self_contained_declaration_value
(
&
mut
input
None
)
.
unwrap
(
)
;
VariableValue
{
css
:
css
.
into_owned
(
)
first_token_type
last_token_type
references
:
Default
:
:
default
(
)
references_environment
:
false
}
}
}
}
}
;
}
lazy_static
!
{
static
ref
ENVIRONMENT_VARIABLES
:
[
EnvironmentVariable
;
4
]
=
[
make_variable
!
(
atom
!
(
"
safe
-
area
-
inset
-
top
"
)
"
0px
"
)
make_variable
!
(
atom
!
(
"
safe
-
area
-
inset
-
bottom
"
)
"
0px
"
)
make_variable
!
(
atom
!
(
"
safe
-
area
-
inset
-
left
"
)
"
0px
"
)
make_variable
!
(
atom
!
(
"
safe
-
area
-
inset
-
right
"
)
"
0px
"
)
]
;
}
impl
CssEnvironment
{
#
[
inline
]
fn
get
(
&
self
name
:
&
Atom
)
-
>
Option
<
&
VariableValue
>
{
let
var
=
ENVIRONMENT_VARIABLES
.
iter
(
)
.
find
(
|
var
|
var
.
name
=
=
*
name
)
?
;
Some
(
&
var
.
value
)
}
}
pub
type
Name
=
Atom
;
pub
fn
parse_name
(
s
:
&
str
)
-
>
Result
<
&
str
(
)
>
{
if
s
.
starts_with
(
"
-
-
"
)
{
Ok
(
&
s
[
2
.
.
]
)
}
else
{
Err
(
(
)
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
pub
struct
VariableValue
{
css
:
String
first_token_type
:
TokenSerializationType
last_token_type
:
TokenSerializationType
references_environment
:
bool
references
:
Box
<
[
Name
]
>
}
impl
ToCss
for
SpecifiedValue
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
dest
.
write_str
(
&
self
.
css
)
}
}
pub
type
CustomPropertiesMap
=
IndexMap
<
Name
Arc
<
VariableValue
>
BuildHasherDefault
<
PrecomputedHasher
>
>
;
pub
type
SpecifiedValue
=
VariableValue
;
pub
type
ComputedValue
=
VariableValue
;
#
[
derive
(
Default
)
]
struct
VarOrEnvReferences
{
custom_property_references
:
PrecomputedHashSet
<
Name
>
references_environment
:
bool
}
impl
VariableValue
{
fn
empty
(
)
-
>
Self
{
Self
{
css
:
String
:
:
new
(
)
last_token_type
:
TokenSerializationType
:
:
nothing
(
)
first_token_type
:
TokenSerializationType
:
:
nothing
(
)
references
:
Default
:
:
default
(
)
references_environment
:
false
}
}
fn
push
<
'
i
>
(
&
mut
self
input
:
&
Parser
<
'
i
'
_
>
css
:
&
str
css_first_token_type
:
TokenSerializationType
css_last_token_type
:
TokenSerializationType
)
-
>
Result
<
(
)
ParseError
<
'
i
>
>
{
const
MAX_VALUE_LENGTH_IN_BYTES
:
usize
=
1024
*
1024
;
if
self
.
css
.
len
(
)
+
css
.
len
(
)
>
MAX_VALUE_LENGTH_IN_BYTES
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
if
css
.
is_empty
(
)
{
return
Ok
(
(
)
)
;
}
self
.
first_token_type
.
set_if_nothing
(
css_first_token_type
)
;
if
self
.
last_token_type
.
needs_separator_when_before
(
css_first_token_type
)
{
self
.
css
.
push_str
(
"
/
*
*
/
"
)
}
self
.
css
.
push_str
(
css
)
;
self
.
last_token_type
=
css_last_token_type
;
Ok
(
(
)
)
}
fn
push_from
<
'
i
>
(
&
mut
self
input
:
&
Parser
<
'
i
'
_
>
position
:
(
SourcePosition
TokenSerializationType
)
last_token_type
:
TokenSerializationType
)
-
>
Result
<
(
)
ParseError
<
'
i
>
>
{
self
.
push
(
input
input
.
slice_from
(
position
.
0
)
position
.
1
last_token_type
)
}
fn
push_variable
<
'
i
>
(
&
mut
self
input
:
&
Parser
<
'
i
'
_
>
variable
:
&
ComputedValue
)
-
>
Result
<
(
)
ParseError
<
'
i
>
>
{
debug_assert
!
(
variable
.
references
.
is_empty
(
)
)
;
self
.
push
(
input
&
variable
.
css
variable
.
first_token_type
variable
.
last_token_type
)
}
pub
fn
parse
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Arc
<
Self
>
ParseError
<
'
i
>
>
{
let
mut
references
=
VarOrEnvReferences
:
:
default
(
)
;
let
(
first_token_type
css
last_token_type
)
=
parse_self_contained_declaration_value
(
input
Some
(
&
mut
references
)
)
?
;
let
custom_property_references
=
references
.
custom_property_references
.
into_iter
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
into_boxed_slice
(
)
;
Ok
(
Arc
:
:
new
(
VariableValue
{
css
:
css
.
into_owned
(
)
first_token_type
last_token_type
references
:
custom_property_references
references_environment
:
references
.
references_environment
}
)
)
}
}
pub
fn
parse_non_custom_with_var
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
(
TokenSerializationType
Cow
<
'
i
str
>
)
ParseError
<
'
i
>
>
{
let
(
first_token_type
css
_
)
=
parse_self_contained_declaration_value
(
input
None
)
?
;
Ok
(
(
first_token_type
css
)
)
}
fn
parse_self_contained_declaration_value
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
references
:
Option
<
&
mut
VarOrEnvReferences
>
)
-
>
Result
<
(
TokenSerializationType
Cow
<
'
i
str
>
TokenSerializationType
)
ParseError
<
'
i
>
>
{
let
start_position
=
input
.
position
(
)
;
let
mut
missing_closing_characters
=
String
:
:
new
(
)
;
let
(
first
last
)
=
parse_declaration_value
(
input
references
&
mut
missing_closing_characters
)
?
;
let
mut
css
:
Cow
<
str
>
=
input
.
slice_from
(
start_position
)
.
into
(
)
;
if
!
missing_closing_characters
.
is_empty
(
)
{
if
css
.
ends_with
(
"
\
\
"
)
&
&
matches
!
(
missing_closing_characters
.
as_bytes
(
)
[
0
]
b
'
"
'
|
b
'
\
'
'
)
{
css
.
to_mut
(
)
.
pop
(
)
;
}
css
.
to_mut
(
)
.
push_str
(
&
missing_closing_characters
)
;
}
Ok
(
(
first
css
last
)
)
}
fn
parse_declaration_value
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
references
:
Option
<
&
mut
VarOrEnvReferences
>
missing_closing_characters
:
&
mut
String
)
-
>
Result
<
(
TokenSerializationType
TokenSerializationType
)
ParseError
<
'
i
>
>
{
input
.
parse_until_before
(
Delimiter
:
:
Bang
|
Delimiter
:
:
Semicolon
|
input
|
{
let
start
=
input
.
state
(
)
;
input
.
next_including_whitespace
(
)
?
;
input
.
reset
(
&
start
)
;
parse_declaration_value_block
(
input
references
missing_closing_characters
)
}
)
}
fn
parse_declaration_value_block
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
mut
references
:
Option
<
&
mut
VarOrEnvReferences
>
missing_closing_characters
:
&
mut
String
)
-
>
Result
<
(
TokenSerializationType
TokenSerializationType
)
ParseError
<
'
i
>
>
{
let
mut
token_start
=
input
.
position
(
)
;
let
mut
token
=
match
input
.
next_including_whitespace_and_comments
(
)
{
Ok
(
token
)
=
>
token
Err
(
_
)
=
>
{
return
Ok
(
(
TokenSerializationType
:
:
nothing
(
)
TokenSerializationType
:
:
nothing
(
)
)
)
;
}
}
;
let
first_token_type
=
token
.
serialization_type
(
)
;
loop
{
macro_rules
!
nested
{
(
)
=
>
{
input
.
parse_nested_block
(
|
input
|
{
parse_declaration_value_block
(
input
references
.
as_mut
(
)
.
map
(
|
r
|
&
mut
*
*
r
)
missing_closing_characters
)
}
)
?
}
;
}
macro_rules
!
check_closed
{
(
closing
:
expr
)
=
>
{
if
!
input
.
slice_from
(
token_start
)
.
ends_with
(
closing
)
{
missing_closing_characters
.
push_str
(
closing
)
}
}
;
}
let
last_token_type
=
match
*
token
{
Token
:
:
Comment
(
_
)
=
>
{
let
serialization_type
=
token
.
serialization_type
(
)
;
let
token_slice
=
input
.
slice_from
(
token_start
)
;
if
!
token_slice
.
ends_with
(
"
*
/
"
)
{
missing_closing_characters
.
push_str
(
if
token_slice
.
ends_with
(
'
*
'
)
{
"
/
"
}
else
{
"
*
/
"
}
)
}
serialization_type
}
Token
:
:
BadUrl
(
ref
u
)
=
>
{
let
e
=
StyleParseErrorKind
:
:
BadUrlInDeclarationValueBlock
(
u
.
clone
(
)
)
;
return
Err
(
input
.
new_custom_error
(
e
)
)
;
}
Token
:
:
BadString
(
ref
s
)
=
>
{
let
e
=
StyleParseErrorKind
:
:
BadStringInDeclarationValueBlock
(
s
.
clone
(
)
)
;
return
Err
(
input
.
new_custom_error
(
e
)
)
;
}
Token
:
:
CloseParenthesis
=
>
{
let
e
=
StyleParseErrorKind
:
:
UnbalancedCloseParenthesisInDeclarationValueBlock
;
return
Err
(
input
.
new_custom_error
(
e
)
)
;
}
Token
:
:
CloseSquareBracket
=
>
{
let
e
=
StyleParseErrorKind
:
:
UnbalancedCloseSquareBracketInDeclarationValueBlock
;
return
Err
(
input
.
new_custom_error
(
e
)
)
;
}
Token
:
:
CloseCurlyBracket
=
>
{
let
e
=
StyleParseErrorKind
:
:
UnbalancedCloseCurlyBracketInDeclarationValueBlock
;
return
Err
(
input
.
new_custom_error
(
e
)
)
;
}
Token
:
:
Function
(
ref
name
)
=
>
{
if
name
.
eq_ignore_ascii_case
(
"
var
"
)
{
let
args_start
=
input
.
state
(
)
;
input
.
parse_nested_block
(
|
input
|
{
parse_var_function
(
input
references
.
as_mut
(
)
.
map
(
|
r
|
&
mut
*
*
r
)
)
}
)
?
;
input
.
reset
(
&
args_start
)
;
}
else
if
name
.
eq_ignore_ascii_case
(
"
env
"
)
{
let
args_start
=
input
.
state
(
)
;
input
.
parse_nested_block
(
|
input
|
{
parse_env_function
(
input
references
.
as_mut
(
)
.
map
(
|
r
|
&
mut
*
*
r
)
)
}
)
?
;
input
.
reset
(
&
args_start
)
;
}
nested
!
(
)
;
check_closed
!
(
"
)
"
)
;
Token
:
:
CloseParenthesis
.
serialization_type
(
)
}
Token
:
:
ParenthesisBlock
=
>
{
nested
!
(
)
;
check_closed
!
(
"
)
"
)
;
Token
:
:
CloseParenthesis
.
serialization_type
(
)
}
Token
:
:
CurlyBracketBlock
=
>
{
nested
!
(
)
;
check_closed
!
(
"
}
"
)
;
Token
:
:
CloseCurlyBracket
.
serialization_type
(
)
}
Token
:
:
SquareBracketBlock
=
>
{
nested
!
(
)
;
check_closed
!
(
"
]
"
)
;
Token
:
:
CloseSquareBracket
.
serialization_type
(
)
}
Token
:
:
QuotedString
(
_
)
=
>
{
let
serialization_type
=
token
.
serialization_type
(
)
;
let
token_slice
=
input
.
slice_from
(
token_start
)
;
let
quote
=
&
token_slice
[
.
.
1
]
;
debug_assert
!
(
matches
!
(
quote
"
\
"
"
|
"
'
"
)
)
;
if
!
(
token_slice
.
ends_with
(
quote
)
&
&
token_slice
.
len
(
)
>
1
)
{
missing_closing_characters
.
push_str
(
quote
)
}
serialization_type
}
Token
:
:
Ident
(
ref
value
)
|
Token
:
:
AtKeyword
(
ref
value
)
|
Token
:
:
Hash
(
ref
value
)
|
Token
:
:
IDHash
(
ref
value
)
|
Token
:
:
UnquotedUrl
(
ref
value
)
|
Token
:
:
Dimension
{
unit
:
ref
value
.
.
}
=
>
{
let
serialization_type
=
token
.
serialization_type
(
)
;
let
is_unquoted_url
=
matches
!
(
token
Token
:
:
UnquotedUrl
(
_
)
)
;
if
value
.
ends_with
(
"
"
)
&
&
input
.
slice_from
(
token_start
)
.
ends_with
(
"
\
\
"
)
{
missing_closing_characters
.
push_str
(
"
"
)
}
if
is_unquoted_url
{
check_closed
!
(
"
)
"
)
;
}
serialization_type
}
_
=
>
token
.
serialization_type
(
)
}
;
token_start
=
input
.
position
(
)
;
token
=
match
input
.
next_including_whitespace_and_comments
(
)
{
Ok
(
token
)
=
>
token
Err
(
.
.
)
=
>
return
Ok
(
(
first_token_type
last_token_type
)
)
}
;
}
}
fn
parse_fallback
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
(
)
ParseError
<
'
i
>
>
{
input
.
parse_until_before
(
Delimiter
:
:
Bang
|
Delimiter
:
:
Semicolon
|
input
|
{
input
.
next_including_whitespace
(
)
?
;
while
let
Ok
(
_
)
=
input
.
next_including_whitespace_and_comments
(
)
{
}
Ok
(
(
)
)
}
)
}
fn
parse_var_function
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
references
:
Option
<
&
mut
VarOrEnvReferences
>
)
-
>
Result
<
(
)
ParseError
<
'
i
>
>
{
let
name
=
input
.
expect_ident_cloned
(
)
?
;
let
name
=
parse_name
(
&
name
)
.
map_err
(
|
(
)
|
{
input
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnexpectedIdent
(
name
.
clone
(
)
)
)
}
)
?
;
if
input
.
try
(
|
input
|
input
.
expect_comma
(
)
)
.
is_ok
(
)
{
parse_fallback
(
input
)
?
;
}
if
let
Some
(
refs
)
=
references
{
refs
.
custom_property_references
.
insert
(
Atom
:
:
from
(
name
)
)
;
}
Ok
(
(
)
)
}
fn
parse_env_function
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
references
:
Option
<
&
mut
VarOrEnvReferences
>
)
-
>
Result
<
(
)
ParseError
<
'
i
>
>
{
input
.
expect_ident
(
)
?
;
if
input
.
try
(
|
input
|
input
.
expect_comma
(
)
)
.
is_ok
(
)
{
parse_fallback
(
input
)
?
;
}
if
let
Some
(
references
)
=
references
{
references
.
references_environment
=
true
;
}
Ok
(
(
)
)
}
pub
struct
CustomPropertiesBuilder
<
'
a
>
{
seen
:
PrecomputedHashSet
<
&
'
a
Name
>
reverted
:
PerOrigin
<
PrecomputedHashSet
<
&
'
a
Name
>
>
may_have_cycles
:
bool
custom_properties
:
Option
<
CustomPropertiesMap
>
inherited
:
Option
<
&
'
a
Arc
<
CustomPropertiesMap
>
>
environment
:
&
'
a
CssEnvironment
}
impl
<
'
a
>
CustomPropertiesBuilder
<
'
a
>
{
pub
fn
new
(
inherited
:
Option
<
&
'
a
Arc
<
CustomPropertiesMap
>
>
environment
:
&
'
a
CssEnvironment
)
-
>
Self
{
Self
{
seen
:
PrecomputedHashSet
:
:
default
(
)
reverted
:
Default
:
:
default
(
)
may_have_cycles
:
false
custom_properties
:
None
inherited
environment
}
}
pub
fn
cascade
(
&
mut
self
declaration
:
&
'
a
CustomDeclaration
origin
:
Origin
)
{
let
CustomDeclaration
{
ref
name
ref
value
}
=
*
declaration
;
if
self
.
reverted
.
borrow_for_origin
(
&
origin
)
.
contains
(
&
name
)
{
return
;
}
let
was_already_present
=
!
self
.
seen
.
insert
(
name
)
;
if
was_already_present
{
return
;
}
if
!
self
.
value_may_affect_style
(
name
value
)
{
return
;
}
if
self
.
custom_properties
.
is_none
(
)
{
self
.
custom_properties
=
Some
(
match
self
.
inherited
{
Some
(
inherited
)
=
>
(
*
*
inherited
)
.
clone
(
)
None
=
>
CustomPropertiesMap
:
:
default
(
)
}
)
;
}
let
map
=
self
.
custom_properties
.
as_mut
(
)
.
unwrap
(
)
;
match
*
value
{
CustomDeclarationValue
:
:
Value
(
ref
unparsed_value
)
=
>
{
let
has_references
=
!
unparsed_value
.
references
.
is_empty
(
)
;
self
.
may_have_cycles
|
=
has_references
;
let
value
=
if
!
has_references
&
&
unparsed_value
.
references_environment
{
let
result
=
substitute_references_in_value
(
unparsed_value
&
map
&
self
.
environment
)
;
match
result
{
Ok
(
new_value
)
=
>
Arc
:
:
new
(
new_value
)
Err
(
.
.
)
=
>
{
map
.
remove
(
name
)
;
return
;
}
}
}
else
{
(
*
unparsed_value
)
.
clone
(
)
}
;
map
.
insert
(
name
.
clone
(
)
value
)
;
}
CustomDeclarationValue
:
:
CSSWideKeyword
(
keyword
)
=
>
match
keyword
{
CSSWideKeyword
:
:
Revert
=
>
{
self
.
seen
.
remove
(
name
)
;
for
origin
in
origin
.
following_including
(
)
{
self
.
reverted
.
borrow_mut_for_origin
(
&
origin
)
.
insert
(
name
)
;
}
}
CSSWideKeyword
:
:
Initial
=
>
{
map
.
remove
(
name
)
;
}
CSSWideKeyword
:
:
Unset
|
CSSWideKeyword
:
:
Inherit
=
>
unreachable
!
(
)
}
}
}
fn
value_may_affect_style
(
&
self
name
:
&
Name
value
:
&
CustomDeclarationValue
)
-
>
bool
{
match
*
value
{
CustomDeclarationValue
:
:
CSSWideKeyword
(
CSSWideKeyword
:
:
Unset
)
|
CustomDeclarationValue
:
:
CSSWideKeyword
(
CSSWideKeyword
:
:
Inherit
)
=
>
{
return
false
;
}
_
=
>
{
}
}
let
existing_value
=
self
.
custom_properties
.
as_ref
(
)
.
and_then
(
|
m
|
m
.
get
(
name
)
)
.
or_else
(
|
|
self
.
inherited
.
and_then
(
|
m
|
m
.
get
(
name
)
)
)
;
match
(
existing_value
value
)
{
(
None
&
CustomDeclarationValue
:
:
CSSWideKeyword
(
CSSWideKeyword
:
:
Initial
)
)
=
>
{
return
false
;
}
(
Some
(
existing_value
)
&
CustomDeclarationValue
:
:
Value
(
ref
value
)
)
=
>
{
if
existing_value
=
=
value
{
return
false
;
}
}
_
=
>
{
}
}
true
}
pub
fn
build
(
mut
self
)
-
>
Option
<
Arc
<
CustomPropertiesMap
>
>
{
let
mut
map
=
match
self
.
custom_properties
.
take
(
)
{
Some
(
m
)
=
>
m
None
=
>
return
self
.
inherited
.
cloned
(
)
}
;
if
self
.
may_have_cycles
{
substitute_all
(
&
mut
map
self
.
environment
)
;
}
Some
(
Arc
:
:
new
(
map
)
)
}
}
fn
substitute_all
(
custom_properties_map
:
&
mut
CustomPropertiesMap
environment
:
&
CssEnvironment
)
{
#
[
derive
(
Debug
)
]
struct
VarInfo
{
name
:
Option
<
Name
>
lowlink
:
usize
}
#
[
derive
(
Debug
)
]
struct
Context
<
'
a
>
{
count
:
usize
index_map
:
PrecomputedHashMap
<
Name
usize
>
var_info
:
SmallVec
<
[
VarInfo
;
5
]
>
stack
:
SmallVec
<
[
usize
;
5
]
>
map
:
&
'
a
mut
CustomPropertiesMap
environment
:
&
'
a
CssEnvironment
}
fn
traverse
<
'
a
>
(
name
:
Name
context
:
&
mut
Context
<
'
a
>
)
-
>
Option
<
usize
>
{
let
(
name
value
)
=
{
let
value
=
context
.
map
.
get
(
&
name
)
?
;
if
value
.
references
.
is_empty
(
)
{
debug_assert
!
(
!
value
.
references_environment
"
Should
'
ve
been
handled
earlier
"
)
;
return
None
;
}
let
key
;
match
context
.
index_map
.
entry
(
name
)
{
Entry
:
:
Occupied
(
entry
)
=
>
{
return
Some
(
*
entry
.
get
(
)
)
;
}
Entry
:
:
Vacant
(
entry
)
=
>
{
key
=
entry
.
key
(
)
.
clone
(
)
;
entry
.
insert
(
context
.
count
)
;
}
}
(
key
value
.
clone
(
)
)
}
;
let
index
=
context
.
count
;
context
.
count
+
=
1
;
debug_assert_eq
!
(
index
context
.
var_info
.
len
(
)
)
;
context
.
var_info
.
push
(
VarInfo
{
name
:
Some
(
name
)
lowlink
:
index
}
)
;
context
.
stack
.
push
(
index
)
;
let
mut
self_ref
=
false
;
let
mut
lowlink
=
index
;
for
next
in
value
.
references
.
iter
(
)
{
let
next_index
=
match
traverse
(
next
.
clone
(
)
context
)
{
Some
(
index
)
=
>
index
None
=
>
{
continue
;
}
}
;
let
next_info
=
&
context
.
var_info
[
next_index
]
;
if
next_index
>
index
{
lowlink
=
cmp
:
:
min
(
lowlink
next_info
.
lowlink
)
;
}
else
if
next_index
=
=
index
{
self_ref
=
true
;
}
else
if
next_info
.
name
.
is_some
(
)
{
lowlink
=
cmp
:
:
min
(
lowlink
next_index
)
;
}
}
context
.
var_info
[
index
]
.
lowlink
=
lowlink
;
if
lowlink
!
=
index
{
return
Some
(
index
)
;
}
let
mut
in_loop
=
self_ref
;
let
name
;
loop
{
let
var_index
=
context
.
stack
.
pop
(
)
.
expect
(
"
The
current
variable
should
still
be
in
stack
"
)
;
let
var_info
=
&
mut
context
.
var_info
[
var_index
]
;
let
var_name
=
var_info
.
name
.
take
(
)
.
expect
(
"
Variable
should
not
be
poped
from
stack
twice
"
)
;
if
var_index
=
=
index
{
name
=
var_name
;
break
;
}
context
.
map
.
remove
(
&
var_name
)
;
in_loop
=
true
;
}
if
in_loop
{
context
.
map
.
remove
(
&
name
)
;
return
None
;
}
let
result
=
substitute_references_in_value
(
&
value
&
context
.
map
&
context
.
environment
)
;
match
result
{
Ok
(
computed_value
)
=
>
{
context
.
map
.
insert
(
name
Arc
:
:
new
(
computed_value
)
)
;
}
Err
(
.
.
)
=
>
{
context
.
map
.
remove
(
&
name
)
;
}
}
None
}
let
names
:
Vec
<
_
>
=
custom_properties_map
.
keys
(
)
.
cloned
(
)
.
collect
(
)
;
for
name
in
names
.
into_iter
(
)
{
let
mut
context
=
Context
{
count
:
0
index_map
:
PrecomputedHashMap
:
:
default
(
)
stack
:
SmallVec
:
:
new
(
)
var_info
:
SmallVec
:
:
new
(
)
map
:
custom_properties_map
environment
}
;
traverse
(
name
&
mut
context
)
;
}
}
fn
substitute_references_in_value
<
'
i
>
(
value
:
&
'
i
VariableValue
custom_properties
:
&
CustomPropertiesMap
environment
:
&
CssEnvironment
)
-
>
Result
<
ComputedValue
ParseError
<
'
i
>
>
{
debug_assert
!
(
!
value
.
references
.
is_empty
(
)
|
|
value
.
references_environment
)
;
let
mut
input
=
ParserInput
:
:
new
(
&
value
.
css
)
;
let
mut
input
=
Parser
:
:
new
(
&
mut
input
)
;
let
mut
position
=
(
input
.
position
(
)
value
.
first_token_type
)
;
let
mut
computed_value
=
ComputedValue
:
:
empty
(
)
;
let
last_token_type
=
substitute_block
(
&
mut
input
&
mut
position
&
mut
computed_value
custom_properties
environment
)
?
;
computed_value
.
push_from
(
&
input
position
last_token_type
)
?
;
Ok
(
computed_value
)
}
fn
substitute_block
<
'
i
>
(
input
:
&
mut
Parser
<
'
i
'
_
>
position
:
&
mut
(
SourcePosition
TokenSerializationType
)
partial_computed_value
:
&
mut
ComputedValue
custom_properties
:
&
CustomPropertiesMap
env
:
&
CssEnvironment
)
-
>
Result
<
TokenSerializationType
ParseError
<
'
i
>
>
{
let
mut
last_token_type
=
TokenSerializationType
:
:
nothing
(
)
;
let
mut
set_position_at_next_iteration
=
false
;
loop
{
let
before_this_token
=
input
.
position
(
)
;
let
next
=
input
.
next_including_whitespace_and_comments
(
)
;
if
set_position_at_next_iteration
{
*
position
=
(
before_this_token
match
next
{
Ok
(
token
)
=
>
token
.
serialization_type
(
)
Err
(
_
)
=
>
TokenSerializationType
:
:
nothing
(
)
}
)
;
set_position_at_next_iteration
=
false
;
}
let
token
=
match
next
{
Ok
(
token
)
=
>
token
Err
(
.
.
)
=
>
break
}
;
match
token
{
Token
:
:
Function
(
ref
name
)
if
name
.
eq_ignore_ascii_case
(
"
var
"
)
|
|
name
.
eq_ignore_ascii_case
(
"
env
"
)
=
>
{
let
is_env
=
name
.
eq_ignore_ascii_case
(
"
env
"
)
;
partial_computed_value
.
push
(
input
input
.
slice
(
position
.
0
.
.
before_this_token
)
position
.
1
last_token_type
)
?
;
input
.
parse_nested_block
(
|
input
|
{
let
name
=
{
let
name
=
input
.
expect_ident
(
)
.
unwrap
(
)
;
if
is_env
{
Atom
:
:
from
(
&
*
*
name
)
}
else
{
Atom
:
:
from
(
parse_name
(
&
name
)
.
unwrap
(
)
)
}
}
;
let
value
=
if
is_env
{
env
.
get
(
&
name
)
}
else
{
custom_properties
.
get
(
&
name
)
.
map
(
|
v
|
&
*
*
v
)
}
;
if
let
Some
(
v
)
=
value
{
last_token_type
=
v
.
last_token_type
;
partial_computed_value
.
push_variable
(
input
v
)
?
;
while
input
.
next
(
)
.
is_ok
(
)
{
}
}
else
{
input
.
expect_comma
(
)
?
;
let
after_comma
=
input
.
state
(
)
;
let
first_token_type
=
input
.
next_including_whitespace_and_comments
(
)
.
unwrap
(
)
.
serialization_type
(
)
;
input
.
reset
(
&
after_comma
)
;
let
mut
position
=
(
after_comma
.
position
(
)
first_token_type
)
;
last_token_type
=
substitute_block
(
input
&
mut
position
partial_computed_value
custom_properties
env
)
?
;
partial_computed_value
.
push_from
(
input
position
last_token_type
)
?
;
}
Ok
(
(
)
)
}
)
?
;
set_position_at_next_iteration
=
true
}
Token
:
:
Function
(
_
)
|
Token
:
:
ParenthesisBlock
|
Token
:
:
CurlyBracketBlock
|
Token
:
:
SquareBracketBlock
=
>
{
input
.
parse_nested_block
(
|
input
|
{
substitute_block
(
input
position
partial_computed_value
custom_properties
env
)
}
)
?
;
last_token_type
=
Token
:
:
CloseParenthesis
.
serialization_type
(
)
;
}
_
=
>
last_token_type
=
token
.
serialization_type
(
)
}
}
Ok
(
last_token_type
)
}
pub
fn
substitute
<
'
i
>
(
input
:
&
'
i
str
first_token_type
:
TokenSerializationType
computed_values_map
:
Option
<
&
Arc
<
CustomPropertiesMap
>
>
env
:
&
CssEnvironment
)
-
>
Result
<
String
ParseError
<
'
i
>
>
{
let
mut
substituted
=
ComputedValue
:
:
empty
(
)
;
let
mut
input
=
ParserInput
:
:
new
(
input
)
;
let
mut
input
=
Parser
:
:
new
(
&
mut
input
)
;
let
mut
position
=
(
input
.
position
(
)
first_token_type
)
;
let
empty_map
=
CustomPropertiesMap
:
:
default
(
)
;
let
custom_properties
=
match
computed_values_map
{
Some
(
m
)
=
>
&
*
*
m
None
=
>
&
empty_map
}
;
let
last_token_type
=
substitute_block
(
&
mut
input
&
mut
position
&
mut
substituted
&
custom_properties
env
)
?
;
substituted
.
push_from
(
&
input
position
last_token_type
)
?
;
Ok
(
substituted
.
css
)
}
