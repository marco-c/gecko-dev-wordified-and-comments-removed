use
crate
:
:
properties
:
:
PropertyDeclarationBlock
;
use
crate
:
:
rule_tree
:
:
{
CascadeLevel
StyleSource
}
;
use
crate
:
:
shared_lock
:
:
Locked
;
use
crate
:
:
stylesheets
:
:
layer_rule
:
:
LayerOrder
;
use
servo_arc
:
:
Arc
;
use
smallvec
:
:
SmallVec
;
pub
type
ApplicableDeclarationList
=
SmallVec
<
[
ApplicableDeclarationBlock
;
16
]
>
;
const
SOURCE_ORDER_BITS
:
usize
=
24
;
const
SOURCE_ORDER_MAX
:
u32
=
(
1
<
<
SOURCE_ORDER_BITS
)
-
1
;
const
SOURCE_ORDER_MASK
:
u32
=
SOURCE_ORDER_MAX
;
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
)
]
pub
struct
CascadePriority
{
cascade_level
:
CascadeLevel
layer_order
:
LayerOrder
}
#
[
allow
(
dead_code
)
]
fn
size_assert
(
)
{
#
[
allow
(
unsafe_code
)
]
unsafe
{
std
:
:
mem
:
:
transmute
:
:
<
u32
CascadePriority
>
(
0u32
)
}
;
}
impl
PartialOrd
for
CascadePriority
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
std
:
:
cmp
:
:
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
Ord
for
CascadePriority
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
std
:
:
cmp
:
:
Ordering
{
self
.
cascade_level
.
cmp
(
&
other
.
cascade_level
)
.
then_with
(
|
|
{
let
ordering
=
self
.
layer_order
.
cmp
(
&
other
.
layer_order
)
;
if
ordering
=
=
std
:
:
cmp
:
:
Ordering
:
:
Equal
{
return
ordering
;
}
if
self
.
cascade_level
.
is_important
(
)
&
&
!
self
.
layer_order
.
is_style_attribute_layer
(
)
&
&
!
other
.
layer_order
.
is_style_attribute_layer
(
)
{
ordering
.
reverse
(
)
}
else
{
ordering
}
}
)
}
}
impl
CascadePriority
{
pub
fn
new
(
cascade_level
:
CascadeLevel
layer_order
:
LayerOrder
)
-
>
Self
{
Self
{
cascade_level
layer_order
}
}
#
[
inline
]
pub
fn
layer_order
(
&
self
)
-
>
LayerOrder
{
self
.
layer_order
}
#
[
inline
]
pub
fn
cascade_level
(
&
self
)
-
>
CascadeLevel
{
self
.
cascade_level
}
pub
fn
allows_when_reverted
(
&
self
other
:
&
Self
origin_revert
:
bool
)
-
>
bool
{
if
origin_revert
{
other
.
cascade_level
.
origin
(
)
<
self
.
cascade_level
.
origin
(
)
}
else
{
other
.
unimportant
(
)
<
self
.
unimportant
(
)
}
}
pub
fn
unimportant
(
&
self
)
-
>
Self
{
Self
:
:
new
(
self
.
cascade_level
(
)
.
unimportant
(
)
self
.
layer_order
(
)
)
}
pub
fn
important
(
&
self
)
-
>
Self
{
Self
:
:
new
(
self
.
cascade_level
(
)
.
important
(
)
self
.
layer_order
(
)
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
)
]
pub
struct
ApplicableDeclarationBlock
{
#
[
ignore_malloc_size_of
=
"
Arc
"
]
pub
source
:
StyleSource
source_order
:
u32
pub
specificity
:
u32
pub
cascade_priority
:
CascadePriority
}
impl
ApplicableDeclarationBlock
{
#
[
inline
]
pub
fn
from_declarations
(
declarations
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
level
:
CascadeLevel
layer_order
:
LayerOrder
)
-
>
Self
{
ApplicableDeclarationBlock
{
source
:
StyleSource
:
:
from_declarations
(
declarations
)
source_order
:
0
specificity
:
0
cascade_priority
:
CascadePriority
:
:
new
(
level
layer_order
)
}
}
#
[
inline
]
pub
fn
new
(
source
:
StyleSource
source_order
:
u32
level
:
CascadeLevel
specificity
:
u32
layer_order
:
LayerOrder
)
-
>
Self
{
ApplicableDeclarationBlock
{
source
source_order
:
source_order
&
SOURCE_ORDER_MASK
specificity
cascade_priority
:
CascadePriority
:
:
new
(
level
layer_order
)
}
}
#
[
inline
]
pub
fn
source_order
(
&
self
)
-
>
u32
{
self
.
source_order
}
#
[
inline
]
pub
fn
level
(
&
self
)
-
>
CascadeLevel
{
self
.
cascade_priority
.
cascade_level
(
)
}
#
[
inline
]
pub
fn
layer_order
(
&
self
)
-
>
LayerOrder
{
self
.
cascade_priority
.
layer_order
(
)
}
#
[
inline
]
pub
fn
for_rule_tree
(
self
)
-
>
(
StyleSource
CascadePriority
)
{
(
self
.
source
self
.
cascade_priority
)
}
}
