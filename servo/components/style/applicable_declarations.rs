use
properties
:
:
PropertyDeclarationBlock
;
use
rule_tree
:
:
{
CascadeLevel
ShadowCascadeOrder
StyleSource
}
;
use
servo_arc
:
:
Arc
;
use
shared_lock
:
:
Locked
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
fmt
:
:
{
self
Debug
}
;
pub
type
ApplicableDeclarationList
=
SmallVec
<
[
ApplicableDeclarationBlock
;
16
]
>
;
const
SOURCE_ORDER_SHIFT
:
usize
=
0
;
const
SOURCE_ORDER_BITS
:
usize
=
24
;
const
SOURCE_ORDER_MAX
:
u32
=
(
1
<
<
SOURCE_ORDER_BITS
)
-
1
;
const
SOURCE_ORDER_MASK
:
u32
=
SOURCE_ORDER_MAX
<
<
SOURCE_ORDER_SHIFT
;
const
SHADOW_CASCADE_ORDER_SHIFT
:
usize
=
SOURCE_ORDER_BITS
;
const
SHADOW_CASCADE_ORDER_BITS
:
usize
=
4
;
const
SHADOW_CASCADE_ORDER_MAX
:
u8
=
(
1
<
<
SHADOW_CASCADE_ORDER_BITS
)
-
1
;
const
SHADOW_CASCADE_ORDER_MASK
:
u32
=
(
SHADOW_CASCADE_ORDER_MAX
as
u32
)
<
<
SHADOW_CASCADE_ORDER_SHIFT
;
const
CASCADE_LEVEL_SHIFT
:
usize
=
SOURCE_ORDER_BITS
+
SHADOW_CASCADE_ORDER_BITS
;
const
CASCADE_LEVEL_BITS
:
usize
=
4
;
const
CASCADE_LEVEL_MAX
:
u8
=
(
1
<
<
CASCADE_LEVEL_BITS
)
-
1
;
const
CASCADE_LEVEL_MASK
:
u32
=
(
CASCADE_LEVEL_MAX
as
u32
)
<
<
CASCADE_LEVEL_SHIFT
;
#
[
derive
(
Clone
Copy
Eq
MallocSizeOf
PartialEq
)
]
struct
ApplicableDeclarationBits
(
u32
)
;
impl
ApplicableDeclarationBits
{
fn
new
(
source_order
:
u32
cascade_level
:
CascadeLevel
shadow_cascade_order
:
ShadowCascadeOrder
)
-
>
Self
{
debug_assert
!
(
cascade_level
as
u8
<
=
CASCADE_LEVEL_MAX
"
Gotta
find
more
bits
!
"
)
;
let
mut
bits
=
:
:
std
:
:
cmp
:
:
min
(
source_order
SOURCE_ORDER_MAX
)
;
bits
|
=
(
(
shadow_cascade_order
&
SHADOW_CASCADE_ORDER_MAX
)
as
u32
)
<
<
SHADOW_CASCADE_ORDER_SHIFT
;
bits
|
=
(
cascade_level
as
u8
as
u32
)
<
<
CASCADE_LEVEL_SHIFT
;
ApplicableDeclarationBits
(
bits
)
}
fn
source_order
(
&
self
)
-
>
u32
{
(
self
.
0
&
SOURCE_ORDER_MASK
)
>
>
SOURCE_ORDER_SHIFT
}
fn
shadow_cascade_order
(
&
self
)
-
>
ShadowCascadeOrder
{
(
(
self
.
0
&
SHADOW_CASCADE_ORDER_MASK
)
>
>
SHADOW_CASCADE_ORDER_SHIFT
)
as
ShadowCascadeOrder
}
fn
level
(
&
self
)
-
>
CascadeLevel
{
let
byte
=
(
(
self
.
0
&
CASCADE_LEVEL_MASK
)
>
>
CASCADE_LEVEL_SHIFT
)
as
u8
;
unsafe
{
CascadeLevel
:
:
from_byte
(
byte
)
}
}
}
impl
Debug
for
ApplicableDeclarationBits
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
ApplicableDeclarationBits
"
)
.
field
(
"
source_order
"
&
self
.
source_order
(
)
)
.
field
(
"
shadow_cascade_order
"
&
self
.
shadow_cascade_order
(
)
)
.
field
(
"
level
"
&
self
.
level
(
)
)
.
finish
(
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
)
]
pub
struct
ApplicableDeclarationBlock
{
#
[
ignore_malloc_size_of
=
"
Arc
"
]
pub
source
:
StyleSource
bits
:
ApplicableDeclarationBits
pub
specificity
:
u32
}
impl
ApplicableDeclarationBlock
{
#
[
inline
]
pub
fn
from_declarations
(
declarations
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
level
:
CascadeLevel
)
-
>
Self
{
ApplicableDeclarationBlock
{
source
:
StyleSource
:
:
from_declarations
(
declarations
)
bits
:
ApplicableDeclarationBits
:
:
new
(
0
level
0
)
specificity
:
0
}
}
#
[
inline
]
pub
fn
new
(
source
:
StyleSource
order
:
u32
level
:
CascadeLevel
specificity
:
u32
shadow_cascade_order
:
ShadowCascadeOrder
)
-
>
Self
{
ApplicableDeclarationBlock
{
source
bits
:
ApplicableDeclarationBits
:
:
new
(
order
level
shadow_cascade_order
)
specificity
}
}
#
[
inline
]
pub
fn
source_order
(
&
self
)
-
>
u32
{
self
.
bits
.
source_order
(
)
}
#
[
inline
]
pub
fn
level
(
&
self
)
-
>
CascadeLevel
{
self
.
bits
.
level
(
)
}
#
[
inline
]
pub
fn
for_rule_tree
(
self
)
-
>
(
StyleSource
CascadeLevel
ShadowCascadeOrder
)
{
let
level
=
self
.
level
(
)
;
let
cascade_order
=
self
.
bits
.
shadow_cascade_order
(
)
;
(
self
.
source
level
cascade_order
)
}
}
