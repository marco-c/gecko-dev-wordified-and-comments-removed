use
properties
:
:
PropertyDeclarationBlock
;
use
rule_tree
:
:
{
CascadeLevel
StyleSource
}
;
use
shared_lock
:
:
Locked
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
fmt
:
:
{
Debug
self
}
;
use
std
:
:
mem
;
use
stylearc
:
:
Arc
;
pub
type
ApplicableDeclarationList
=
SmallVec
<
[
ApplicableDeclarationBlock
;
16
]
>
;
const
SOURCE_ORDER_BITS
:
usize
=
24
;
const
SOURCE_ORDER_MASK
:
u32
=
(
1
<
<
SOURCE_ORDER_BITS
)
-
1
;
const
SOURCE_ORDER_MAX
:
u32
=
SOURCE_ORDER_MASK
;
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
)
]
struct
SourceOrderAndCascadeLevel
(
u32
)
;
impl
SourceOrderAndCascadeLevel
{
fn
new
(
source_order
:
u32
cascade_level
:
CascadeLevel
)
-
>
SourceOrderAndCascadeLevel
{
let
mut
bits
=
:
:
std
:
:
cmp
:
:
min
(
source_order
SOURCE_ORDER_MAX
)
;
bits
|
=
(
cascade_level
as
u8
as
u32
)
<
<
SOURCE_ORDER_BITS
;
SourceOrderAndCascadeLevel
(
bits
)
}
fn
order
(
&
self
)
-
>
u32
{
self
.
0
&
SOURCE_ORDER_MASK
}
fn
level
(
&
self
)
-
>
CascadeLevel
{
unsafe
{
let
as_bytes
:
[
u8
;
4
]
=
mem
:
:
transmute
(
self
.
0
)
;
CascadeLevel
:
:
from_byte
(
as_bytes
[
3
]
)
}
}
}
impl
Debug
for
SourceOrderAndCascadeLevel
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
SourceOrderAndCascadeLevel
"
)
.
field
(
"
order
"
&
self
.
order
(
)
)
.
field
(
"
level
"
&
self
.
level
(
)
)
.
finish
(
)
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Debug
Clone
PartialEq
)
]
pub
struct
ApplicableDeclarationBlock
{
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
pub
source
:
StyleSource
order_and_level
:
SourceOrderAndCascadeLevel
pub
specificity
:
u32
}
impl
ApplicableDeclarationBlock
{
#
[
inline
]
pub
fn
from_declarations
(
declarations
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
level
:
CascadeLevel
)
-
>
Self
{
ApplicableDeclarationBlock
{
source
:
StyleSource
:
:
Declarations
(
declarations
)
order_and_level
:
SourceOrderAndCascadeLevel
:
:
new
(
0
level
)
specificity
:
0
}
}
#
[
inline
]
pub
fn
new
(
source
:
StyleSource
order
:
u32
level
:
CascadeLevel
specificity
:
u32
)
-
>
Self
{
ApplicableDeclarationBlock
{
source
:
source
order_and_level
:
SourceOrderAndCascadeLevel
:
:
new
(
order
level
)
specificity
:
specificity
}
}
#
[
inline
]
pub
fn
source_order
(
&
self
)
-
>
u32
{
self
.
order_and_level
.
order
(
)
}
#
[
inline
]
pub
fn
level
(
&
self
)
-
>
CascadeLevel
{
self
.
order_and_level
.
level
(
)
}
#
[
inline
]
pub
fn
order_and_level
(
self
)
-
>
(
StyleSource
CascadeLevel
)
{
let
level
=
self
.
level
(
)
;
(
self
.
source
level
)
}
}
