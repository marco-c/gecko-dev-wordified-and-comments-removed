#
!
[
allow
(
missing_docs
)
]
#
[
cfg
(
feature
=
"
servo
"
)
]
use
heapsize
:
:
HeapSizeOf
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
{
isize
usize
}
;
use
std
:
:
borrow
;
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
convert
:
:
From
;
use
std
:
:
fmt
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
mem
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
sync
:
:
atomic
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
Acquire
Relaxed
Release
}
;
macro_rules
!
offset_of
{
(
container
:
path
field
:
ident
)
=
>
{
{
/
/
Make
sure
the
field
actually
exists
.
This
line
ensures
that
a
compile
-
time
error
is
/
/
generated
if
field
is
accessed
through
a
Deref
impl
.
let
container
{
field
:
_
.
.
}
;
/
/
Create
an
(
invalid
)
instance
of
the
container
and
calculate
the
offset
to
its
/
/
field
.
Using
a
null
pointer
might
be
UB
if
&
(
*
(
0
as
*
const
T
)
)
.
field
is
interpreted
to
/
/
be
nullptr
deref
.
let
invalid
:
container
=
:
:
std
:
:
mem
:
:
uninitialized
(
)
;
let
offset
=
&
invalid
.
field
as
*
const
_
as
usize
-
&
invalid
as
*
const
_
as
usize
;
/
/
Do
not
run
destructors
on
the
made
up
invalid
instance
.
:
:
std
:
:
mem
:
:
forget
(
invalid
)
;
offset
as
isize
}
}
;
}
const
MAX_REFCOUNT
:
usize
=
(
isize
:
:
MAX
)
as
usize
;
pub
struct
Arc
<
T
:
?
Sized
>
{
ptr
:
*
mut
ArcInner
<
T
>
}
unsafe
impl
<
T
:
?
Sized
+
Sync
+
Send
>
Send
for
Arc
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Sync
+
Send
>
Sync
for
Arc
<
T
>
{
}
struct
ArcInner
<
T
:
?
Sized
>
{
count
:
atomic
:
:
AtomicUsize
data
:
T
}
unsafe
impl
<
T
:
?
Sized
+
Sync
+
Send
>
Send
for
ArcInner
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Sync
+
Send
>
Sync
for
ArcInner
<
T
>
{
}
impl
<
T
>
Arc
<
T
>
{
#
[
inline
]
pub
fn
new
(
data
:
T
)
-
>
Self
{
let
x
=
Box
:
:
new
(
ArcInner
{
count
:
atomic
:
:
AtomicUsize
:
:
new
(
1
)
data
:
data
}
)
;
Arc
{
ptr
:
Box
:
:
into_raw
(
x
)
}
}
pub
fn
into_raw
(
this
:
Self
)
-
>
*
const
T
{
let
ptr
=
unsafe
{
&
(
(
*
this
.
ptr
)
.
data
)
as
*
const
_
}
;
mem
:
:
forget
(
this
)
;
ptr
}
pub
unsafe
fn
from_raw
(
ptr
:
*
const
T
)
-
>
Self
{
let
ptr
=
(
ptr
as
*
const
u8
)
.
offset
(
-
offset_of
!
(
ArcInner
<
T
>
data
)
)
;
Arc
{
ptr
:
ptr
as
*
mut
ArcInner
<
T
>
}
}
}
impl
<
T
:
?
Sized
>
Arc
<
T
>
{
#
[
inline
]
fn
inner
(
&
self
)
-
>
&
ArcInner
<
T
>
{
unsafe
{
&
*
self
.
ptr
}
}
#
[
inline
(
never
)
]
unsafe
fn
drop_slow
(
&
mut
self
)
{
let
_
=
Box
:
:
from_raw
(
self
.
ptr
)
;
}
#
[
inline
]
pub
fn
ptr_eq
(
this
:
&
Self
other
:
&
Self
)
-
>
bool
{
this
.
ptr
=
=
other
.
ptr
}
}
impl
<
T
:
?
Sized
>
Clone
for
Arc
<
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
let
old_size
=
self
.
inner
(
)
.
count
.
fetch_add
(
1
Relaxed
)
;
if
old_size
>
MAX_REFCOUNT
{
panic
!
(
)
;
}
Arc
{
ptr
:
self
.
ptr
}
}
}
impl
<
T
:
?
Sized
>
Deref
for
Arc
<
T
>
{
type
Target
=
T
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
T
{
&
self
.
inner
(
)
.
data
}
}
impl
<
T
:
Clone
>
Arc
<
T
>
{
#
[
inline
]
pub
fn
make_mut
(
this
:
&
mut
Self
)
-
>
&
mut
T
{
if
!
this
.
is_unique
(
)
{
*
this
=
Arc
:
:
new
(
(
*
*
this
)
.
clone
(
)
)
;
}
unsafe
{
&
mut
(
*
this
.
ptr
)
.
data
}
}
}
impl
<
T
:
?
Sized
>
Arc
<
T
>
{
#
[
inline
]
pub
fn
get_mut
(
this
:
&
mut
Self
)
-
>
Option
<
&
mut
T
>
{
if
this
.
is_unique
(
)
{
unsafe
{
Some
(
&
mut
(
*
this
.
ptr
)
.
data
)
}
}
else
{
None
}
}
#
[
inline
]
fn
is_unique
(
&
self
)
-
>
bool
{
self
.
inner
(
)
.
count
.
load
(
Relaxed
)
=
=
1
}
}
impl
<
T
:
?
Sized
>
Drop
for
Arc
<
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
if
self
.
inner
(
)
.
count
.
fetch_sub
(
1
Release
)
!
=
1
{
return
;
}
self
.
inner
(
)
.
count
.
load
(
Acquire
)
;
unsafe
{
self
.
drop_slow
(
)
;
}
}
}
impl
<
T
:
?
Sized
+
PartialEq
>
PartialEq
for
Arc
<
T
>
{
fn
eq
(
&
self
other
:
&
Arc
<
T
>
)
-
>
bool
{
*
(
*
self
)
=
=
*
(
*
other
)
}
fn
ne
(
&
self
other
:
&
Arc
<
T
>
)
-
>
bool
{
*
(
*
self
)
!
=
*
(
*
other
)
}
}
impl
<
T
:
?
Sized
+
PartialOrd
>
PartialOrd
for
Arc
<
T
>
{
fn
partial_cmp
(
&
self
other
:
&
Arc
<
T
>
)
-
>
Option
<
Ordering
>
{
(
*
*
self
)
.
partial_cmp
(
&
*
*
other
)
}
fn
lt
(
&
self
other
:
&
Arc
<
T
>
)
-
>
bool
{
*
(
*
self
)
<
*
(
*
other
)
}
fn
le
(
&
self
other
:
&
Arc
<
T
>
)
-
>
bool
{
*
(
*
self
)
<
=
*
(
*
other
)
}
fn
gt
(
&
self
other
:
&
Arc
<
T
>
)
-
>
bool
{
*
(
*
self
)
>
*
(
*
other
)
}
fn
ge
(
&
self
other
:
&
Arc
<
T
>
)
-
>
bool
{
*
(
*
self
)
>
=
*
(
*
other
)
}
}
impl
<
T
:
?
Sized
+
Ord
>
Ord
for
Arc
<
T
>
{
fn
cmp
(
&
self
other
:
&
Arc
<
T
>
)
-
>
Ordering
{
(
*
*
self
)
.
cmp
(
&
*
*
other
)
}
}
impl
<
T
:
?
Sized
+
Eq
>
Eq
for
Arc
<
T
>
{
}
impl
<
T
:
?
Sized
+
fmt
:
:
Display
>
fmt
:
:
Display
for
Arc
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
<
T
:
?
Sized
+
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Arc
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
<
T
:
?
Sized
>
fmt
:
:
Pointer
for
Arc
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Pointer
:
:
fmt
(
&
self
.
ptr
f
)
}
}
impl
<
T
:
Default
>
Default
for
Arc
<
T
>
{
fn
default
(
)
-
>
Arc
<
T
>
{
Arc
:
:
new
(
Default
:
:
default
(
)
)
}
}
impl
<
T
:
?
Sized
+
Hash
>
Hash
for
Arc
<
T
>
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
(
*
*
self
)
.
hash
(
state
)
}
}
impl
<
T
>
From
<
T
>
for
Arc
<
T
>
{
fn
from
(
t
:
T
)
-
>
Self
{
Arc
:
:
new
(
t
)
}
}
impl
<
T
:
?
Sized
>
borrow
:
:
Borrow
<
T
>
for
Arc
<
T
>
{
fn
borrow
(
&
self
)
-
>
&
T
{
&
*
*
self
}
}
impl
<
T
:
?
Sized
>
AsRef
<
T
>
for
Arc
<
T
>
{
fn
as_ref
(
&
self
)
-
>
&
T
{
&
*
*
self
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Arc
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
(
*
*
self
)
.
heap_size_of_children
(
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
<
T
:
Deserialize
>
Deserialize
for
Arc
<
T
>
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Arc
<
T
>
D
:
:
Error
>
where
D
:
:
:
serde
:
:
de
:
:
Deserializer
{
T
:
:
deserialize
(
deserializer
)
.
map
(
Arc
:
:
new
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
<
T
:
Serialize
>
Serialize
for
Arc
<
T
>
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
:
:
serde
:
:
ser
:
:
Serializer
{
(
*
*
self
)
.
serialize
(
serializer
)
}
}
