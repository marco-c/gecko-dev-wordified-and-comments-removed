#
!
[
deny
(
missing_docs
)
]
use
std
:
:
collections
:
:
VecDeque
;
use
std
:
:
collections
:
:
vec_deque
;
pub
struct
LRUCache
<
K
>
{
entries
:
VecDeque
<
K
>
cache_size
:
usize
}
pub
type
LRUCacheIterator
<
'
a
K
>
=
vec_deque
:
:
Iter
<
'
a
K
>
;
pub
type
LRUCacheMutIterator
<
'
a
K
>
=
vec_deque
:
:
IterMut
<
'
a
K
>
;
impl
<
K
:
PartialEq
>
LRUCache
<
K
>
{
pub
fn
new
(
size
:
usize
)
-
>
Self
{
LRUCache
{
entries
:
VecDeque
:
:
with_capacity
(
size
)
cache_size
:
size
}
}
pub
fn
num_entries
(
&
self
)
-
>
usize
{
self
.
entries
.
len
(
)
}
#
[
inline
]
pub
fn
touch
(
&
mut
self
pos
:
usize
)
{
let
last_index
=
self
.
entries
.
len
(
)
-
1
;
if
pos
!
=
last_index
{
let
entry
=
self
.
entries
.
remove
(
pos
)
.
unwrap
(
)
;
self
.
entries
.
push_front
(
entry
)
;
}
}
pub
fn
iter
(
&
self
)
-
>
vec_deque
:
:
Iter
<
K
>
{
self
.
entries
.
iter
(
)
}
pub
fn
iter_mut
(
&
mut
self
)
-
>
vec_deque
:
:
IterMut
<
K
>
{
self
.
entries
.
iter_mut
(
)
}
pub
fn
insert
(
&
mut
self
key
:
K
)
{
if
self
.
entries
.
len
(
)
=
=
self
.
cache_size
{
self
.
entries
.
pop_back
(
)
;
}
self
.
entries
.
push_front
(
key
)
;
debug_assert
!
(
self
.
entries
.
len
(
)
<
=
self
.
cache_size
)
;
}
pub
fn
evict_all
(
&
mut
self
)
{
self
.
entries
.
clear
(
)
;
}
}
