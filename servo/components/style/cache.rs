#
!
[
deny
(
missing_docs
)
]
extern
crate
arraydeque
;
use
self
:
:
arraydeque
:
:
Array
;
use
self
:
:
arraydeque
:
:
ArrayDeque
;
pub
struct
LRUCache
<
K
:
Array
>
{
entries
:
ArrayDeque
<
K
>
}
pub
type
LRUCacheIterator
<
'
a
K
>
=
arraydeque
:
:
Iter
<
'
a
K
>
;
pub
type
LRUCacheMutIterator
<
'
a
K
>
=
arraydeque
:
:
IterMut
<
'
a
K
>
;
impl
<
K
:
Array
>
LRUCache
<
K
>
{
pub
fn
new
(
)
-
>
Self
{
LRUCache
{
entries
:
ArrayDeque
:
:
new
(
)
}
}
pub
fn
num_entries
(
&
self
)
-
>
usize
{
self
.
entries
.
len
(
)
}
#
[
inline
]
pub
fn
touch
(
&
mut
self
pos
:
usize
)
{
if
pos
!
=
0
{
let
entry
=
self
.
entries
.
remove
(
pos
)
.
unwrap
(
)
;
self
.
entries
.
push_front
(
entry
)
;
}
}
pub
fn
front
(
&
self
)
-
>
Option
<
&
K
:
:
Item
>
{
self
.
entries
.
get
(
0
)
}
pub
fn
front_mut
(
&
mut
self
)
-
>
Option
<
&
mut
K
:
:
Item
>
{
self
.
entries
.
get_mut
(
0
)
}
pub
fn
iter
(
&
self
)
-
>
arraydeque
:
:
Iter
<
K
:
:
Item
>
{
self
.
entries
.
iter
(
)
}
pub
fn
iter_mut
(
&
mut
self
)
-
>
arraydeque
:
:
IterMut
<
K
:
:
Item
>
{
self
.
entries
.
iter_mut
(
)
}
pub
fn
insert
(
&
mut
self
key
:
K
:
:
Item
)
{
if
self
.
entries
.
len
(
)
=
=
self
.
entries
.
capacity
(
)
{
self
.
entries
.
pop_back
(
)
;
}
self
.
entries
.
push_front
(
key
)
;
debug_assert
!
(
self
.
entries
.
len
(
)
<
=
self
.
entries
.
capacity
(
)
)
;
}
pub
fn
evict_all
(
&
mut
self
)
{
self
.
entries
.
clear
(
)
;
}
}
