#
!
[
deny
(
missing_docs
)
]
use
std
:
:
slice
:
:
{
Iter
IterMut
}
;
pub
struct
LRUCache
<
K
V
>
{
entries
:
Vec
<
(
K
V
)
>
cache_size
:
usize
}
impl
<
K
:
PartialEq
V
:
Clone
>
LRUCache
<
K
V
>
{
pub
fn
new
(
size
:
usize
)
-
>
LRUCache
<
K
V
>
{
LRUCache
{
entries
:
vec
!
[
]
cache_size
:
size
}
}
#
[
inline
]
pub
fn
touch
(
&
mut
self
pos
:
usize
)
-
>
&
V
{
let
last_index
=
self
.
entries
.
len
(
)
-
1
;
if
pos
!
=
last_index
{
let
entry
=
self
.
entries
.
remove
(
pos
)
;
self
.
entries
.
push
(
entry
)
;
}
&
self
.
entries
[
last_index
]
.
1
}
pub
fn
iter
(
&
self
)
-
>
Iter
<
(
K
V
)
>
{
self
.
entries
.
iter
(
)
}
pub
fn
iter_mut
(
&
mut
self
)
-
>
IterMut
<
(
K
V
)
>
{
self
.
entries
.
iter_mut
(
)
}
pub
fn
insert
(
&
mut
self
key
:
K
val
:
V
)
{
if
self
.
entries
.
len
(
)
=
=
self
.
cache_size
{
self
.
entries
.
remove
(
0
)
;
}
self
.
entries
.
push
(
(
key
val
)
)
;
}
pub
fn
find
(
&
mut
self
key
:
&
K
)
-
>
Option
<
V
>
{
match
self
.
entries
.
iter
(
)
.
position
(
|
&
(
ref
k
_
)
|
key
=
=
k
)
{
Some
(
pos
)
=
>
Some
(
self
.
touch
(
pos
)
.
clone
(
)
)
None
=
>
None
}
}
pub
fn
find_or_create
<
F
>
(
&
mut
self
key
:
K
mut
blk
:
F
)
-
>
V
where
F
:
FnMut
(
)
-
>
V
{
match
self
.
entries
.
iter
(
)
.
position
(
|
&
(
ref
k
_
)
|
*
k
=
=
key
)
{
Some
(
pos
)
=
>
self
.
touch
(
pos
)
.
clone
(
)
None
=
>
{
let
val
=
blk
(
)
;
self
.
insert
(
key
val
.
clone
(
)
)
;
val
}
}
}
pub
fn
evict_all
(
&
mut
self
)
{
self
.
entries
.
clear
(
)
;
}
}
