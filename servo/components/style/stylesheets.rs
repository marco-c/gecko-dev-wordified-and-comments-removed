#
!
[
deny
(
missing_docs
)
]
use
{
Atom
Prefix
Namespace
}
;
use
context
:
:
QuirksMode
;
use
counter_style
:
:
{
parse_counter_style_name
parse_counter_style_body
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
counter_style
:
:
CounterStyleRuleData
;
use
cssparser
:
:
{
AtRuleParser
Parser
QualifiedRuleParser
}
;
use
cssparser
:
:
{
AtRuleType
RuleListParser
parse_one_rule
SourceLocation
}
;
use
cssparser
:
:
ToCss
as
ParserToCss
;
use
document_condition
:
:
DocumentCondition
;
use
error_reporting
:
:
{
ParseErrorReporter
NullReporter
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
font_face
:
:
FontFaceRuleData
;
use
font_face
:
:
parse_font_face_block
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
gecko
:
:
rules
:
:
{
CounterStyleRule
FontFaceRule
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
structs
:
:
URLExtraData
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
sugar
:
:
refptr
:
:
RefPtr
;
use
keyframes
:
:
{
Keyframe
KeyframeSelector
parse_keyframe_list
}
;
use
media_queries
:
:
{
Device
MediaList
parse_media_query_list
}
;
use
parking_lot
:
:
RwLock
;
use
parser
:
:
{
PARSING_MODE_DEFAULT
Parse
ParserContext
log_css_error
}
;
use
properties
:
:
{
PropertyDeclarationBlock
parse_property_declaration_list
}
;
use
selector_parser
:
:
{
SelectorImpl
SelectorParser
}
;
use
selectors
:
:
parser
:
:
SelectorList
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
servo_config
:
:
prefs
:
:
PREFS
;
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
use
servo_url
:
:
ServoUrl
;
use
shared_lock
:
:
{
SharedRwLock
Locked
ToCssWithGuard
SharedRwLockReadGuard
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
{
fmt
mem
}
;
use
std
:
:
borrow
:
:
Borrow
;
use
std
:
:
mem
:
:
align_of
;
use
std
:
:
os
:
:
raw
:
:
c_void
;
use
std
:
:
slice
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
str
:
:
starts_with_ignore_ascii_case
;
use
style_traits
:
:
ToCss
;
use
stylearc
:
:
Arc
;
use
stylist
:
:
FnvHashMap
;
use
supports
:
:
SupportsCondition
;
use
values
:
:
{
CustomIdent
KeyframesName
}
;
use
values
:
:
specified
:
:
NamespaceId
;
use
values
:
:
specified
:
:
url
:
:
SpecifiedUrl
;
use
viewport
:
:
ViewportRule
;
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
pub
type
UrlExtraData
=
ServoUrl
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
type
UrlExtraData
=
RefPtr
<
URLExtraData
>
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
UrlExtraData
{
pub
fn
as_str
(
&
self
)
-
>
&
str
{
"
(
stylo
:
not
supported
)
"
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
Eq
for
UrlExtraData
{
}
#
[
derive
(
Clone
PartialEq
Eq
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
Origin
{
UserAgent
Author
User
}
#
[
derive
(
Clone
Default
Debug
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
Namespaces
{
pub
default
:
Option
<
(
Namespace
NamespaceId
)
>
pub
prefixes
:
FnvHashMap
<
Prefix
(
Namespace
NamespaceId
)
>
}
pub
type
MallocSizeOfFn
=
unsafe
extern
"
C
"
fn
(
ptr
:
*
const
c_void
)
-
>
usize
;
pub
unsafe
fn
do_malloc_size_of
<
T
>
(
malloc_size_of
:
MallocSizeOfFn
ptr
:
*
const
T
)
-
>
usize
{
if
ptr
as
usize
<
=
align_of
:
:
<
T
>
(
)
{
0
}
else
{
malloc_size_of
(
ptr
as
*
const
c_void
)
}
}
pub
trait
MallocSizeOf
{
fn
malloc_size_of_children
(
&
self
malloc_size_of
:
MallocSizeOfFn
)
-
>
usize
;
}
pub
trait
MallocSizeOfWithGuard
{
fn
malloc_size_of_children
(
&
self
guard
:
&
SharedRwLockReadGuard
malloc_size_of
:
MallocSizeOfFn
)
-
>
usize
;
}
impl
<
A
:
MallocSizeOf
B
:
MallocSizeOf
>
MallocSizeOf
for
(
A
B
)
{
fn
malloc_size_of_children
(
&
self
malloc_size_of
:
MallocSizeOfFn
)
-
>
usize
{
self
.
0
.
malloc_size_of_children
(
malloc_size_of
)
+
self
.
1
.
malloc_size_of_children
(
malloc_size_of
)
}
}
impl
<
T
:
MallocSizeOf
>
MallocSizeOf
for
Vec
<
T
>
{
fn
malloc_size_of_children
(
&
self
malloc_size_of
:
MallocSizeOfFn
)
-
>
usize
{
self
.
iter
(
)
.
fold
(
unsafe
{
do_malloc_size_of
(
malloc_size_of
self
.
as_ptr
(
)
)
}
|
n
elem
|
n
+
elem
.
malloc_size_of_children
(
malloc_size_of
)
)
}
}
impl
<
T
:
MallocSizeOfWithGuard
>
MallocSizeOfWithGuard
for
Vec
<
T
>
{
fn
malloc_size_of_children
(
&
self
guard
:
&
SharedRwLockReadGuard
malloc_size_of
:
MallocSizeOfFn
)
-
>
usize
{
self
.
iter
(
)
.
fold
(
unsafe
{
do_malloc_size_of
(
malloc_size_of
self
.
as_ptr
(
)
)
}
|
n
elem
|
n
+
elem
.
malloc_size_of_children
(
guard
malloc_size_of
)
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
CssRules
(
pub
Vec
<
CssRule
>
)
;
impl
CssRules
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_empty
(
)
}
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
)
-
>
CssRules
{
CssRules
(
self
.
0
.
iter
(
)
.
map
(
|
ref
x
|
x
.
deep_clone_with_lock
(
lock
)
)
.
collect
(
)
)
}
}
impl
MallocSizeOfWithGuard
for
CssRules
{
fn
malloc_size_of_children
(
&
self
guard
:
&
SharedRwLockReadGuard
malloc_size_of
:
MallocSizeOfFn
)
-
>
usize
{
self
.
0
.
malloc_size_of_children
(
guard
malloc_size_of
)
}
}
#
[
allow
(
missing_docs
)
]
pub
enum
RulesMutateError
{
Syntax
IndexSize
HierarchyRequest
InvalidState
}
impl
From
<
SingleRuleParseError
>
for
RulesMutateError
{
fn
from
(
other
:
SingleRuleParseError
)
-
>
Self
{
match
other
{
SingleRuleParseError
:
:
Syntax
=
>
RulesMutateError
:
:
Syntax
SingleRuleParseError
:
:
Hierarchy
=
>
RulesMutateError
:
:
HierarchyRequest
}
}
}
impl
CssRules
{
#
[
allow
(
missing_docs
)
]
pub
fn
new
(
rules
:
Vec
<
CssRule
>
shared_lock
:
&
SharedRwLock
)
-
>
Arc
<
Locked
<
CssRules
>
>
{
Arc
:
:
new
(
shared_lock
.
wrap
(
CssRules
(
rules
)
)
)
}
fn
only_ns_or_import
(
&
self
)
-
>
bool
{
self
.
0
.
iter
(
)
.
all
(
|
r
|
{
match
*
r
{
CssRule
:
:
Namespace
(
.
.
)
|
CssRule
:
:
Import
(
.
.
)
=
>
true
_
=
>
false
}
}
)
}
pub
fn
remove_rule
(
&
mut
self
index
:
usize
)
-
>
Result
<
(
)
RulesMutateError
>
{
if
index
>
=
self
.
0
.
len
(
)
{
return
Err
(
RulesMutateError
:
:
IndexSize
)
;
}
{
let
ref
rule
=
self
.
0
[
index
]
;
if
let
CssRule
:
:
Namespace
(
.
.
)
=
*
rule
{
if
!
self
.
only_ns_or_import
(
)
{
return
Err
(
RulesMutateError
:
:
InvalidState
)
;
}
}
}
self
.
0
.
remove
(
index
)
;
Ok
(
(
)
)
}
}
pub
trait
CssRulesHelpers
{
fn
insert_rule
(
&
self
lock
:
&
SharedRwLock
rule
:
&
str
parent_stylesheet
:
&
Stylesheet
index
:
usize
nested
:
bool
loader
:
Option
<
&
StylesheetLoader
>
)
-
>
Result
<
CssRule
RulesMutateError
>
;
}
impl
CssRulesHelpers
for
Arc
<
Locked
<
CssRules
>
>
{
fn
insert_rule
(
&
self
lock
:
&
SharedRwLock
rule
:
&
str
parent_stylesheet
:
&
Stylesheet
index
:
usize
nested
:
bool
loader
:
Option
<
&
StylesheetLoader
>
)
-
>
Result
<
CssRule
RulesMutateError
>
{
let
state
=
{
let
read_guard
=
lock
.
read
(
)
;
let
rules
=
self
.
read_with
(
&
read_guard
)
;
if
index
>
rules
.
0
.
len
(
)
{
return
Err
(
RulesMutateError
:
:
IndexSize
)
;
}
if
nested
{
None
}
else
if
index
=
=
0
{
Some
(
State
:
:
Start
)
}
else
{
rules
.
0
.
get
(
index
-
1
)
.
map
(
CssRule
:
:
rule_state
)
}
}
;
let
(
new_rule
new_state
)
=
try
!
(
CssRule
:
:
parse
(
&
rule
parent_stylesheet
state
loader
)
)
;
{
let
mut
write_guard
=
lock
.
write
(
)
;
let
mut
rules
=
self
.
write_with
(
&
mut
write_guard
)
;
let
rev_state
=
rules
.
0
.
get
(
index
)
.
map_or
(
State
:
:
Body
CssRule
:
:
rule_state
)
;
if
new_state
>
rev_state
{
return
Err
(
RulesMutateError
:
:
HierarchyRequest
)
;
}
if
let
CssRule
:
:
Namespace
(
.
.
)
=
new_rule
{
if
!
rules
.
only_ns_or_import
(
)
{
return
Err
(
RulesMutateError
:
:
InvalidState
)
;
}
}
rules
.
0
.
insert
(
index
new_rule
.
clone
(
)
)
;
}
Ok
(
new_rule
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Stylesheet
{
pub
rules
:
Arc
<
Locked
<
CssRules
>
>
pub
media
:
Arc
<
Locked
<
MediaList
>
>
pub
origin
:
Origin
pub
url_data
:
UrlExtraData
pub
shared_lock
:
SharedRwLock
pub
namespaces
:
RwLock
<
Namespaces
>
pub
dirty_on_viewport_size_change
:
AtomicBool
pub
disabled
:
AtomicBool
pub
quirks_mode
:
QuirksMode
}
impl
MallocSizeOfWithGuard
for
Stylesheet
{
fn
malloc_size_of_children
(
&
self
guard
:
&
SharedRwLockReadGuard
malloc_size_of
:
MallocSizeOfFn
)
-
>
usize
{
self
.
rules
.
read_with
(
guard
)
.
malloc_size_of_children
(
guard
malloc_size_of
)
}
}
pub
struct
UserAgentStylesheets
{
pub
shared_lock
:
SharedRwLock
pub
user_or_user_agent_stylesheets
:
Vec
<
Stylesheet
>
pub
quirks_mode_stylesheet
:
Stylesheet
}
#
[
derive
(
Debug
Clone
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
CssRule
{
Namespace
(
Arc
<
Locked
<
NamespaceRule
>
>
)
Import
(
Arc
<
Locked
<
ImportRule
>
>
)
Style
(
Arc
<
Locked
<
StyleRule
>
>
)
Media
(
Arc
<
Locked
<
MediaRule
>
>
)
FontFace
(
Arc
<
Locked
<
FontFaceRule
>
>
)
CounterStyle
(
Arc
<
Locked
<
CounterStyleRule
>
>
)
Viewport
(
Arc
<
Locked
<
ViewportRule
>
>
)
Keyframes
(
Arc
<
Locked
<
KeyframesRule
>
>
)
Supports
(
Arc
<
Locked
<
SupportsRule
>
>
)
Page
(
Arc
<
Locked
<
PageRule
>
>
)
Document
(
Arc
<
Locked
<
DocumentRule
>
>
)
}
impl
MallocSizeOfWithGuard
for
CssRule
{
fn
malloc_size_of_children
(
&
self
guard
:
&
SharedRwLockReadGuard
malloc_size_of
:
MallocSizeOfFn
)
-
>
usize
{
match
*
self
{
CssRule
:
:
Style
(
ref
lock
)
=
>
{
lock
.
read_with
(
guard
)
.
malloc_size_of_children
(
guard
malloc_size_of
)
}
CssRule
:
:
Import
(
_
)
=
>
0
CssRule
:
:
Media
(
_
)
=
>
0
CssRule
:
:
FontFace
(
_
)
=
>
0
CssRule
:
:
CounterStyle
(
_
)
=
>
0
CssRule
:
:
Keyframes
(
_
)
=
>
0
CssRule
:
:
Namespace
(
_
)
=
>
0
CssRule
:
:
Viewport
(
_
)
=
>
0
CssRule
:
:
Supports
(
_
)
=
>
0
CssRule
:
:
Page
(
_
)
=
>
0
CssRule
:
:
Document
(
_
)
=
>
0
}
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
PartialEq
Eq
Copy
Clone
)
]
pub
enum
CssRuleType
{
Style
=
1
Charset
=
2
Import
=
3
Media
=
4
FontFace
=
5
Page
=
6
Keyframes
=
7
Keyframe
=
8
Margin
=
9
Namespace
=
10
CounterStyle
=
11
Supports
=
12
Document
=
13
FontFeatureValues
=
14
Viewport
=
15
}
#
[
allow
(
missing_docs
)
]
pub
enum
SingleRuleParseError
{
Syntax
Hierarchy
}
impl
CssRule
{
#
[
allow
(
missing_docs
)
]
pub
fn
rule_type
(
&
self
)
-
>
CssRuleType
{
match
*
self
{
CssRule
:
:
Style
(
_
)
=
>
CssRuleType
:
:
Style
CssRule
:
:
Import
(
_
)
=
>
CssRuleType
:
:
Import
CssRule
:
:
Media
(
_
)
=
>
CssRuleType
:
:
Media
CssRule
:
:
FontFace
(
_
)
=
>
CssRuleType
:
:
FontFace
CssRule
:
:
CounterStyle
(
_
)
=
>
CssRuleType
:
:
CounterStyle
CssRule
:
:
Keyframes
(
_
)
=
>
CssRuleType
:
:
Keyframes
CssRule
:
:
Namespace
(
_
)
=
>
CssRuleType
:
:
Namespace
CssRule
:
:
Viewport
(
_
)
=
>
CssRuleType
:
:
Viewport
CssRule
:
:
Supports
(
_
)
=
>
CssRuleType
:
:
Supports
CssRule
:
:
Page
(
_
)
=
>
CssRuleType
:
:
Page
CssRule
:
:
Document
(
_
)
=
>
CssRuleType
:
:
Document
}
}
fn
rule_state
(
&
self
)
-
>
State
{
match
*
self
{
CssRule
:
:
Import
(
.
.
)
=
>
State
:
:
Imports
CssRule
:
:
Namespace
(
.
.
)
=
>
State
:
:
Namespaces
_
=
>
State
:
:
Body
}
}
#
[
allow
(
missing_docs
)
]
pub
fn
parse
(
css
:
&
str
parent_stylesheet
:
&
Stylesheet
state
:
Option
<
State
>
loader
:
Option
<
&
StylesheetLoader
>
)
-
>
Result
<
(
Self
State
)
SingleRuleParseError
>
{
let
error_reporter
=
NullReporter
;
let
context
=
ParserContext
:
:
new
(
parent_stylesheet
.
origin
&
parent_stylesheet
.
url_data
&
error_reporter
None
PARSING_MODE_DEFAULT
parent_stylesheet
.
quirks_mode
)
;
let
mut
input
=
Parser
:
:
new
(
css
)
;
let
mut
guard
=
parent_stylesheet
.
namespaces
.
write
(
)
;
let
state
=
state
.
unwrap_or
(
State
:
:
Body
)
;
let
mut
rule_parser
=
TopLevelRuleParser
{
stylesheet_origin
:
parent_stylesheet
.
origin
context
:
context
shared_lock
:
&
parent_stylesheet
.
shared_lock
loader
:
loader
state
:
state
namespaces
:
Some
(
&
mut
*
guard
)
}
;
match
parse_one_rule
(
&
mut
input
&
mut
rule_parser
)
{
Ok
(
result
)
=
>
Ok
(
(
result
rule_parser
.
state
)
)
Err
(
_
)
=
>
{
if
let
State
:
:
Invalid
=
rule_parser
.
state
{
Err
(
SingleRuleParseError
:
:
Hierarchy
)
}
else
{
Err
(
SingleRuleParseError
:
:
Syntax
)
}
}
}
}
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
)
-
>
CssRule
{
let
guard
=
lock
.
read
(
)
;
match
*
self
{
CssRule
:
:
Namespace
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
&
guard
)
;
CssRule
:
:
Namespace
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
clone
(
)
)
)
)
}
CssRule
:
:
Import
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
&
guard
)
;
CssRule
:
:
Import
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
clone
(
)
)
)
)
}
CssRule
:
:
Style
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
&
guard
)
;
CssRule
:
:
Style
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
deep_clone_with_lock
(
lock
)
)
)
)
}
CssRule
:
:
Media
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
&
guard
)
;
CssRule
:
:
Media
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
deep_clone_with_lock
(
lock
)
)
)
)
}
CssRule
:
:
FontFace
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
&
guard
)
;
CssRule
:
:
FontFace
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
clone
(
)
)
)
)
}
CssRule
:
:
CounterStyle
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
&
guard
)
;
CssRule
:
:
CounterStyle
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
clone
(
)
)
)
)
}
CssRule
:
:
Viewport
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
&
guard
)
;
CssRule
:
:
Viewport
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
clone
(
)
)
)
)
}
CssRule
:
:
Keyframes
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
&
guard
)
;
CssRule
:
:
Keyframes
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
deep_clone_with_lock
(
lock
)
)
)
)
}
CssRule
:
:
Supports
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
&
guard
)
;
CssRule
:
:
Supports
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
deep_clone_with_lock
(
lock
)
)
)
)
}
CssRule
:
:
Page
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
&
guard
)
;
CssRule
:
:
Page
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
deep_clone_with_lock
(
lock
)
)
)
)
}
CssRule
:
:
Document
(
ref
arc
)
=
>
{
let
rule
=
arc
.
read_with
(
&
guard
)
;
CssRule
:
:
Document
(
Arc
:
:
new
(
lock
.
wrap
(
rule
.
deep_clone_with_lock
(
lock
)
)
)
)
}
}
}
}
impl
ToCssWithGuard
for
CssRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
CssRule
:
:
Namespace
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Import
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Style
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
FontFace
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
CounterStyle
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Viewport
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Keyframes
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Media
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Supports
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Page
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Document
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
}
}
}
fn
get_location_with_offset
(
location
:
SourceLocation
offset
:
u64
)
-
>
SourceLocation
{
SourceLocation
{
line
:
location
.
line
+
offset
as
usize
-
1
column
:
location
.
column
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
NamespaceRule
{
pub
prefix
:
Option
<
Prefix
>
pub
url
:
Namespace
pub
source_location
:
SourceLocation
}
impl
ToCssWithGuard
for
NamespaceRule
{
fn
to_css
<
W
>
(
&
self
_guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
namespace
"
)
)
;
if
let
Some
(
ref
prefix
)
=
self
.
prefix
{
try
!
(
dest
.
write_str
(
&
*
prefix
.
to_string
(
)
)
)
;
try
!
(
dest
.
write_str
(
"
"
)
)
;
}
try
!
(
dest
.
write_str
(
"
url
(
\
"
"
)
)
;
try
!
(
dest
.
write_str
(
&
*
self
.
url
.
to_string
(
)
)
)
;
dest
.
write_str
(
"
\
"
)
;
"
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
ImportRule
{
pub
url
:
SpecifiedUrl
pub
stylesheet
:
Arc
<
Stylesheet
>
pub
source_location
:
SourceLocation
}
impl
Clone
for
ImportRule
{
fn
clone
(
&
self
)
-
>
ImportRule
{
let
stylesheet
:
&
Stylesheet
=
self
.
stylesheet
.
borrow
(
)
;
ImportRule
{
url
:
self
.
url
.
clone
(
)
stylesheet
:
Arc
:
:
new
(
stylesheet
.
clone
(
)
)
source_location
:
self
.
source_location
.
clone
(
)
}
}
}
impl
ToCssWithGuard
for
ImportRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
import
"
)
)
;
try
!
(
self
.
url
.
to_css
(
dest
)
)
;
let
media
=
self
.
stylesheet
.
media
.
read_with
(
guard
)
;
if
!
media
.
is_empty
(
)
{
try
!
(
dest
.
write_str
(
"
"
)
)
;
try
!
(
media
.
to_css
(
dest
)
)
;
}
dest
.
write_str
(
"
;
"
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
KeyframesRule
{
pub
name
:
KeyframesName
pub
keyframes
:
Vec
<
Arc
<
Locked
<
Keyframe
>
>
>
pub
vendor_prefix
:
Option
<
VendorPrefix
>
pub
source_location
:
SourceLocation
}
impl
ToCssWithGuard
for
KeyframesRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
keyframes
"
)
)
;
try
!
(
self
.
name
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
{
"
)
)
;
let
iter
=
self
.
keyframes
.
iter
(
)
;
for
lock
in
iter
{
try
!
(
dest
.
write_str
(
"
\
n
"
)
)
;
let
keyframe
=
lock
.
read_with
(
&
guard
)
;
try
!
(
keyframe
.
to_css
(
guard
dest
)
)
;
}
dest
.
write_str
(
"
\
n
}
"
)
}
}
impl
KeyframesRule
{
pub
fn
find_rule
(
&
self
guard
:
&
SharedRwLockReadGuard
selector
:
&
str
)
-
>
Option
<
usize
>
{
if
let
Ok
(
selector
)
=
Parser
:
:
new
(
selector
)
.
parse_entirely
(
KeyframeSelector
:
:
parse
)
{
for
(
i
keyframe
)
in
self
.
keyframes
.
iter
(
)
.
enumerate
(
)
.
rev
(
)
{
if
keyframe
.
read_with
(
guard
)
.
selector
=
=
selector
{
return
Some
(
i
)
;
}
}
}
None
}
}
impl
KeyframesRule
{
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
)
-
>
KeyframesRule
{
let
guard
=
lock
.
read
(
)
;
KeyframesRule
{
name
:
self
.
name
.
clone
(
)
keyframes
:
self
.
keyframes
.
iter
(
)
.
map
(
|
ref
x
|
Arc
:
:
new
(
lock
.
wrap
(
x
.
read_with
(
&
guard
)
.
deep_clone_with_lock
(
lock
)
)
)
)
.
collect
(
)
vendor_prefix
:
self
.
vendor_prefix
.
clone
(
)
source_location
:
self
.
source_location
.
clone
(
)
}
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
struct
MediaRule
{
pub
media_queries
:
Arc
<
Locked
<
MediaList
>
>
pub
rules
:
Arc
<
Locked
<
CssRules
>
>
pub
source_location
:
SourceLocation
}
impl
ToCssWithGuard
for
MediaRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
media
"
)
)
;
try
!
(
self
.
media_queries
.
read_with
(
guard
)
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
{
"
)
)
;
for
rule
in
self
.
rules
.
read_with
(
guard
)
.
0
.
iter
(
)
{
try
!
(
dest
.
write_str
(
"
"
)
)
;
try
!
(
rule
.
to_css
(
guard
dest
)
)
;
}
dest
.
write_str
(
"
}
"
)
}
}
impl
MediaRule
{
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
)
-
>
MediaRule
{
let
guard
=
lock
.
read
(
)
;
let
media_queries
=
self
.
media_queries
.
read_with
(
&
guard
)
;
let
rules
=
self
.
rules
.
read_with
(
&
guard
)
;
MediaRule
{
media_queries
:
Arc
:
:
new
(
lock
.
wrap
(
media_queries
.
clone
(
)
)
)
rules
:
Arc
:
:
new
(
lock
.
wrap
(
rules
.
deep_clone_with_lock
(
lock
)
)
)
source_location
:
self
.
source_location
.
clone
(
)
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
SupportsRule
{
pub
condition
:
SupportsCondition
pub
rules
:
Arc
<
Locked
<
CssRules
>
>
pub
enabled
:
bool
pub
source_location
:
SourceLocation
}
impl
ToCssWithGuard
for
SupportsRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
supports
"
)
)
;
try
!
(
self
.
condition
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
{
"
)
)
;
for
rule
in
self
.
rules
.
read_with
(
guard
)
.
0
.
iter
(
)
{
try
!
(
dest
.
write_str
(
"
"
)
)
;
try
!
(
rule
.
to_css
(
guard
dest
)
)
;
}
dest
.
write_str
(
"
}
"
)
}
}
impl
SupportsRule
{
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
)
-
>
SupportsRule
{
let
guard
=
lock
.
read
(
)
;
let
rules
=
self
.
rules
.
read_with
(
&
guard
)
;
SupportsRule
{
condition
:
self
.
condition
.
clone
(
)
rules
:
Arc
:
:
new
(
lock
.
wrap
(
rules
.
deep_clone_with_lock
(
lock
)
)
)
enabled
:
self
.
enabled
source_location
:
self
.
source_location
.
clone
(
)
}
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
struct
PageRule
{
pub
block
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
pub
source_location
:
SourceLocation
}
impl
ToCssWithGuard
for
PageRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_str
(
"
page
{
"
)
?
;
let
declaration_block
=
self
.
block
.
read_with
(
guard
)
;
declaration_block
.
to_css
(
dest
)
?
;
if
declaration_block
.
declarations
(
)
.
len
(
)
>
0
{
write
!
(
dest
"
"
)
?
;
}
dest
.
write_str
(
"
}
"
)
}
}
impl
PageRule
{
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
)
-
>
PageRule
{
let
guard
=
lock
.
read
(
)
;
PageRule
{
block
:
Arc
:
:
new
(
lock
.
wrap
(
self
.
block
.
read_with
(
&
guard
)
.
clone
(
)
)
)
source_location
:
self
.
source_location
.
clone
(
)
}
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
struct
StyleRule
{
pub
selectors
:
SelectorList
<
SelectorImpl
>
pub
block
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
pub
source_location
:
SourceLocation
}
impl
MallocSizeOfWithGuard
for
StyleRule
{
fn
malloc_size_of_children
(
&
self
guard
:
&
SharedRwLockReadGuard
malloc_size_of
:
MallocSizeOfFn
)
-
>
usize
{
self
.
block
.
read_with
(
guard
)
.
malloc_size_of_children
(
malloc_size_of
)
}
}
impl
ToCssWithGuard
for
StyleRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
self
.
selectors
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
{
"
)
)
;
let
declaration_block
=
self
.
block
.
read_with
(
guard
)
;
try
!
(
declaration_block
.
to_css
(
dest
)
)
;
if
declaration_block
.
declarations
(
)
.
len
(
)
>
0
{
try
!
(
write
!
(
dest
"
"
)
)
;
}
try
!
(
dest
.
write_str
(
"
}
"
)
)
;
Ok
(
(
)
)
}
}
impl
StyleRule
{
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
)
-
>
StyleRule
{
let
guard
=
lock
.
read
(
)
;
StyleRule
{
selectors
:
self
.
selectors
.
clone
(
)
block
:
Arc
:
:
new
(
lock
.
wrap
(
self
.
block
.
read_with
(
&
guard
)
.
clone
(
)
)
)
source_location
:
self
.
source_location
.
clone
(
)
}
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
type
FontFaceRule
=
FontFaceRuleData
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
type
CounterStyleRule
=
CounterStyleRuleData
;
#
[
derive
(
Debug
)
]
pub
struct
DocumentRule
{
pub
condition
:
DocumentCondition
pub
rules
:
Arc
<
Locked
<
CssRules
>
>
pub
source_location
:
SourceLocation
}
impl
ToCssWithGuard
for
DocumentRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
-
moz
-
document
"
)
)
;
try
!
(
self
.
condition
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
{
"
)
)
;
for
rule
in
self
.
rules
.
read_with
(
guard
)
.
0
.
iter
(
)
{
try
!
(
dest
.
write_str
(
"
"
)
)
;
try
!
(
rule
.
to_css
(
guard
dest
)
)
;
}
dest
.
write_str
(
"
}
"
)
}
}
impl
DocumentRule
{
fn
deep_clone_with_lock
(
&
self
lock
:
&
SharedRwLock
)
-
>
DocumentRule
{
let
guard
=
lock
.
read
(
)
;
let
rules
=
self
.
rules
.
read_with
(
&
guard
)
;
DocumentRule
{
condition
:
self
.
condition
.
clone
(
)
rules
:
Arc
:
:
new
(
lock
.
wrap
(
rules
.
deep_clone_with_lock
(
lock
)
)
)
source_location
:
self
.
source_location
.
clone
(
)
}
}
}
pub
trait
NestedRuleIterationCondition
{
fn
process_import
(
guard
:
&
SharedRwLockReadGuard
device
:
&
Device
quirks_mode
:
QuirksMode
rule
:
&
ImportRule
)
-
>
bool
;
fn
process_media
(
guard
:
&
SharedRwLockReadGuard
device
:
&
Device
quirks_mode
:
QuirksMode
rule
:
&
MediaRule
)
-
>
bool
;
fn
process_document
(
guard
:
&
SharedRwLockReadGuard
device
:
&
Device
quirks_mode
:
QuirksMode
rule
:
&
DocumentRule
)
-
>
bool
;
fn
process_supports
(
guard
:
&
SharedRwLockReadGuard
device
:
&
Device
quirks_mode
:
QuirksMode
rule
:
&
SupportsRule
)
-
>
bool
;
}
pub
struct
EffectiveRules
;
impl
NestedRuleIterationCondition
for
EffectiveRules
{
fn
process_import
(
guard
:
&
SharedRwLockReadGuard
device
:
&
Device
quirks_mode
:
QuirksMode
rule
:
&
ImportRule
)
-
>
bool
{
rule
.
stylesheet
.
media
.
read_with
(
guard
)
.
evaluate
(
device
quirks_mode
)
}
fn
process_media
(
guard
:
&
SharedRwLockReadGuard
device
:
&
Device
quirks_mode
:
QuirksMode
rule
:
&
MediaRule
)
-
>
bool
{
rule
.
media_queries
.
read_with
(
guard
)
.
evaluate
(
device
quirks_mode
)
}
fn
process_document
(
_
:
&
SharedRwLockReadGuard
device
:
&
Device
_
:
QuirksMode
rule
:
&
DocumentRule
)
-
>
bool
{
rule
.
condition
.
evaluate
(
device
)
}
fn
process_supports
(
_
:
&
SharedRwLockReadGuard
_
:
&
Device
_
:
QuirksMode
rule
:
&
SupportsRule
)
-
>
bool
{
rule
.
enabled
}
}
pub
struct
AllRules
;
impl
NestedRuleIterationCondition
for
AllRules
{
fn
process_import
(
_
:
&
SharedRwLockReadGuard
_
:
&
Device
_
:
QuirksMode
_
:
&
ImportRule
)
-
>
bool
{
true
}
fn
process_media
(
_
:
&
SharedRwLockReadGuard
_
:
&
Device
_
:
QuirksMode
_
:
&
MediaRule
)
-
>
bool
{
true
}
fn
process_document
(
_
:
&
SharedRwLockReadGuard
_
:
&
Device
_
:
QuirksMode
_
:
&
DocumentRule
)
-
>
bool
{
true
}
fn
process_supports
(
_
:
&
SharedRwLockReadGuard
_
:
&
Device
_
:
QuirksMode
_
:
&
SupportsRule
)
-
>
bool
{
true
}
}
pub
type
EffectiveRulesIterator
<
'
a
'
b
>
=
RulesIterator
<
'
a
'
b
EffectiveRules
>
;
pub
struct
RulesIterator
<
'
a
'
b
C
>
where
'
b
:
'
a
C
:
NestedRuleIterationCondition
+
'
static
{
device
:
&
'
a
Device
quirks_mode
:
QuirksMode
guard
:
&
'
a
SharedRwLockReadGuard
<
'
b
>
stack
:
SmallVec
<
[
slice
:
:
Iter
<
'
a
CssRule
>
;
3
]
>
_phantom
:
:
:
std
:
:
marker
:
:
PhantomData
<
C
>
}
impl
<
'
a
'
b
C
>
RulesIterator
<
'
a
'
b
C
>
where
'
b
:
'
a
C
:
NestedRuleIterationCondition
+
'
static
{
pub
fn
new
(
device
:
&
'
a
Device
quirks_mode
:
QuirksMode
guard
:
&
'
a
SharedRwLockReadGuard
<
'
b
>
rules
:
&
'
a
CssRules
)
-
>
Self
{
let
mut
stack
=
SmallVec
:
:
new
(
)
;
stack
.
push
(
rules
.
0
.
iter
(
)
)
;
Self
{
device
:
device
quirks_mode
:
quirks_mode
guard
:
guard
stack
:
stack
_phantom
:
:
:
std
:
:
marker
:
:
PhantomData
}
}
pub
fn
skip_children
(
&
mut
self
)
{
self
.
stack
.
pop
(
)
;
}
}
impl
<
'
a
'
b
C
>
Iterator
for
RulesIterator
<
'
a
'
b
C
>
where
'
b
:
'
a
C
:
NestedRuleIterationCondition
+
'
static
{
type
Item
=
&
'
a
CssRule
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
mut
nested_iter_finished
=
false
;
while
!
self
.
stack
.
is_empty
(
)
{
if
nested_iter_finished
{
self
.
stack
.
pop
(
)
;
nested_iter_finished
=
false
;
continue
;
}
let
rule
;
let
sub_iter
;
{
let
mut
nested_iter
=
self
.
stack
.
last_mut
(
)
.
unwrap
(
)
;
rule
=
match
nested_iter
.
next
(
)
{
Some
(
r
)
=
>
r
None
=
>
{
nested_iter_finished
=
true
;
continue
}
}
;
sub_iter
=
match
*
rule
{
CssRule
:
:
Import
(
ref
import_rule
)
=
>
{
let
import_rule
=
import_rule
.
read_with
(
self
.
guard
)
;
if
!
C
:
:
process_import
(
self
.
guard
self
.
device
self
.
quirks_mode
import_rule
)
{
continue
;
}
Some
(
import_rule
.
stylesheet
.
rules
.
read_with
(
self
.
guard
)
.
0
.
iter
(
)
)
}
CssRule
:
:
Document
(
ref
doc_rule
)
=
>
{
let
doc_rule
=
doc_rule
.
read_with
(
self
.
guard
)
;
if
!
C
:
:
process_document
(
self
.
guard
self
.
device
self
.
quirks_mode
doc_rule
)
{
continue
;
}
Some
(
doc_rule
.
rules
.
read_with
(
self
.
guard
)
.
0
.
iter
(
)
)
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
let
media_rule
=
lock
.
read_with
(
self
.
guard
)
;
if
!
C
:
:
process_media
(
self
.
guard
self
.
device
self
.
quirks_mode
media_rule
)
{
continue
;
}
Some
(
media_rule
.
rules
.
read_with
(
self
.
guard
)
.
0
.
iter
(
)
)
}
CssRule
:
:
Supports
(
ref
lock
)
=
>
{
let
supports_rule
=
lock
.
read_with
(
self
.
guard
)
;
if
!
C
:
:
process_supports
(
self
.
guard
self
.
device
self
.
quirks_mode
supports_rule
)
{
continue
;
}
Some
(
supports_rule
.
rules
.
read_with
(
self
.
guard
)
.
0
.
iter
(
)
)
}
CssRule
:
:
Namespace
(
_
)
|
CssRule
:
:
Style
(
_
)
|
CssRule
:
:
FontFace
(
_
)
|
CssRule
:
:
CounterStyle
(
_
)
|
CssRule
:
:
Viewport
(
_
)
|
CssRule
:
:
Keyframes
(
_
)
|
CssRule
:
:
Page
(
_
)
=
>
None
}
;
}
if
let
Some
(
sub_iter
)
=
sub_iter
{
self
.
stack
.
push
(
sub_iter
)
;
}
return
Some
(
rule
)
;
}
None
}
}
impl
Stylesheet
{
pub
fn
update_from_str
(
existing
:
&
Stylesheet
css
:
&
str
url_data
:
&
UrlExtraData
stylesheet_loader
:
Option
<
&
StylesheetLoader
>
error_reporter
:
&
ParseErrorReporter
line_number_offset
:
u64
)
{
let
namespaces
=
RwLock
:
:
new
(
Namespaces
:
:
default
(
)
)
;
let
(
rules
dirty_on_viewport_size_change
)
=
Stylesheet
:
:
parse_rules
(
css
url_data
existing
.
origin
&
mut
*
namespaces
.
write
(
)
&
existing
.
shared_lock
stylesheet_loader
error_reporter
existing
.
quirks_mode
line_number_offset
)
;
mem
:
:
swap
(
&
mut
*
existing
.
namespaces
.
write
(
)
&
mut
*
namespaces
.
write
(
)
)
;
existing
.
dirty_on_viewport_size_change
.
store
(
dirty_on_viewport_size_change
Ordering
:
:
Release
)
;
let
mut
guard
=
existing
.
shared_lock
.
write
(
)
;
*
existing
.
rules
.
write_with
(
&
mut
guard
)
=
CssRules
(
rules
)
;
}
fn
parse_rules
(
css
:
&
str
url_data
:
&
UrlExtraData
origin
:
Origin
namespaces
:
&
mut
Namespaces
shared_lock
:
&
SharedRwLock
stylesheet_loader
:
Option
<
&
StylesheetLoader
>
error_reporter
:
&
ParseErrorReporter
quirks_mode
:
QuirksMode
line_number_offset
:
u64
)
-
>
(
Vec
<
CssRule
>
bool
)
{
let
mut
rules
=
Vec
:
:
new
(
)
;
let
mut
input
=
Parser
:
:
new
(
css
)
;
let
context
=
ParserContext
:
:
new_with_line_number_offset
(
origin
url_data
error_reporter
line_number_offset
PARSING_MODE_DEFAULT
quirks_mode
)
;
let
rule_parser
=
TopLevelRuleParser
{
stylesheet_origin
:
origin
shared_lock
:
shared_lock
loader
:
stylesheet_loader
context
:
context
state
:
State
:
:
Start
namespaces
:
Some
(
namespaces
)
}
;
input
.
look_for_viewport_percentages
(
)
;
{
let
mut
iter
=
RuleListParser
:
:
new_for_stylesheet
(
&
mut
input
rule_parser
)
;
while
let
Some
(
result
)
=
iter
.
next
(
)
{
match
result
{
Ok
(
rule
)
=
>
rules
.
push
(
rule
)
Err
(
range
)
=
>
{
let
pos
=
range
.
start
;
let
message
=
format
!
(
"
Invalid
rule
:
'
{
}
'
"
iter
.
input
.
slice
(
range
)
)
;
log_css_error
(
iter
.
input
pos
&
*
message
&
iter
.
parser
.
context
)
;
}
}
}
}
(
rules
input
.
seen_viewport_percentages
(
)
)
}
pub
fn
from_str
(
css
:
&
str
url_data
:
UrlExtraData
origin
:
Origin
media
:
Arc
<
Locked
<
MediaList
>
>
shared_lock
:
SharedRwLock
stylesheet_loader
:
Option
<
&
StylesheetLoader
>
error_reporter
:
&
ParseErrorReporter
quirks_mode
:
QuirksMode
line_number_offset
:
u64
)
-
>
Stylesheet
{
let
namespaces
=
RwLock
:
:
new
(
Namespaces
:
:
default
(
)
)
;
let
(
rules
dirty_on_viewport_size_change
)
=
Stylesheet
:
:
parse_rules
(
css
&
url_data
origin
&
mut
*
namespaces
.
write
(
)
&
shared_lock
stylesheet_loader
error_reporter
quirks_mode
line_number_offset
)
;
Stylesheet
{
origin
:
origin
url_data
:
url_data
namespaces
:
namespaces
rules
:
CssRules
:
:
new
(
rules
&
shared_lock
)
media
:
media
shared_lock
:
shared_lock
dirty_on_viewport_size_change
:
AtomicBool
:
:
new
(
dirty_on_viewport_size_change
)
disabled
:
AtomicBool
:
:
new
(
false
)
quirks_mode
:
quirks_mode
}
}
pub
fn
dirty_on_viewport_size_change
(
&
self
)
-
>
bool
{
self
.
dirty_on_viewport_size_change
.
load
(
Ordering
:
:
SeqCst
)
}
pub
fn
inserted_has_viewport_percentages
(
&
self
has_viewport_percentages
:
bool
)
{
self
.
dirty_on_viewport_size_change
.
fetch_or
(
has_viewport_percentages
Ordering
:
:
SeqCst
)
;
}
pub
fn
is_effective_for_device
(
&
self
device
:
&
Device
guard
:
&
SharedRwLockReadGuard
)
-
>
bool
{
self
.
media
.
read_with
(
guard
)
.
evaluate
(
device
self
.
quirks_mode
)
}
#
[
inline
]
pub
fn
effective_rules
<
'
a
'
b
>
(
&
'
a
self
device
:
&
'
a
Device
guard
:
&
'
a
SharedRwLockReadGuard
<
'
b
>
)
-
>
EffectiveRulesIterator
<
'
a
'
b
>
{
self
.
iter_rules
:
:
<
'
a
'
b
EffectiveRules
>
(
device
guard
)
}
#
[
inline
]
pub
fn
iter_rules
<
'
a
'
b
C
>
(
&
'
a
self
device
:
&
'
a
Device
guard
:
&
'
a
SharedRwLockReadGuard
<
'
b
>
)
-
>
RulesIterator
<
'
a
'
b
C
>
where
C
:
NestedRuleIterationCondition
{
RulesIterator
:
:
new
(
device
self
.
quirks_mode
guard
&
self
.
rules
.
read_with
(
guard
)
)
}
pub
fn
disabled
(
&
self
)
-
>
bool
{
self
.
disabled
.
load
(
Ordering
:
:
SeqCst
)
}
pub
fn
set_disabled
(
&
self
disabled
:
bool
)
-
>
bool
{
self
.
disabled
.
swap
(
disabled
Ordering
:
:
SeqCst
)
!
=
disabled
}
}
impl
Clone
for
Stylesheet
{
fn
clone
(
&
self
)
-
>
Stylesheet
{
let
lock
=
self
.
shared_lock
.
clone
(
)
;
let
guard
=
self
.
shared_lock
.
read
(
)
;
let
rules
=
self
.
rules
.
read_with
(
&
guard
)
;
let
cloned_rules
=
rules
.
deep_clone_with_lock
(
&
lock
)
;
let
media
=
self
.
media
.
read_with
(
&
guard
)
;
let
cloned_media
=
media
.
clone
(
)
;
Stylesheet
{
rules
:
Arc
:
:
new
(
lock
.
wrap
(
cloned_rules
)
)
media
:
Arc
:
:
new
(
lock
.
wrap
(
cloned_media
)
)
origin
:
self
.
origin
url_data
:
self
.
url_data
.
clone
(
)
shared_lock
:
lock
namespaces
:
RwLock
:
:
new
(
(
*
self
.
namespaces
.
read
(
)
)
.
clone
(
)
)
dirty_on_viewport_size_change
:
AtomicBool
:
:
new
(
self
.
dirty_on_viewport_size_change
.
load
(
Ordering
:
:
SeqCst
)
)
disabled
:
AtomicBool
:
:
new
(
self
.
disabled
.
load
(
Ordering
:
:
SeqCst
)
)
quirks_mode
:
self
.
quirks_mode
}
}
}
macro_rules
!
rule_filter
{
(
(
method
:
ident
(
variant
:
ident
=
>
rule_type
:
ident
)
)
+
)
=
>
{
impl
Stylesheet
{
(
#
[
allow
(
missing_docs
)
]
pub
fn
method
<
F
>
(
&
self
device
:
&
Device
guard
:
&
SharedRwLockReadGuard
mut
f
:
F
)
where
F
:
FnMut
(
&
rule_type
)
{
for
rule
in
self
.
effective_rules
(
device
guard
)
{
if
let
CssRule
:
:
variant
(
ref
lock
)
=
*
rule
{
let
rule
=
lock
.
read_with
(
guard
)
;
f
(
&
rule
)
}
}
}
)
+
}
}
}
rule_filter
!
{
effective_style_rules
(
Style
=
>
StyleRule
)
effective_media_rules
(
Media
=
>
MediaRule
)
effective_font_face_rules
(
FontFace
=
>
FontFaceRule
)
effective_counter_style_rules
(
CounterStyle
=
>
CounterStyleRule
)
effective_viewport_rules
(
Viewport
=
>
ViewportRule
)
effective_keyframes_rules
(
Keyframes
=
>
KeyframesRule
)
effective_supports_rules
(
Supports
=
>
SupportsRule
)
effective_page_rules
(
Page
=
>
PageRule
)
effective_document_rules
(
Document
=
>
DocumentRule
)
}
pub
trait
StylesheetLoader
{
fn
request_stylesheet
(
&
self
media
:
Arc
<
Locked
<
MediaList
>
>
make_import
:
&
mut
FnMut
(
Arc
<
Locked
<
MediaList
>
>
)
-
>
ImportRule
make_arc
:
&
mut
FnMut
(
ImportRule
)
-
>
Arc
<
Locked
<
ImportRule
>
>
)
-
>
Arc
<
Locked
<
ImportRule
>
>
;
}
struct
NoOpLoader
;
impl
StylesheetLoader
for
NoOpLoader
{
fn
request_stylesheet
(
&
self
media
:
Arc
<
Locked
<
MediaList
>
>
make_import
:
&
mut
FnMut
(
Arc
<
Locked
<
MediaList
>
>
)
-
>
ImportRule
make_arc
:
&
mut
FnMut
(
ImportRule
)
-
>
Arc
<
Locked
<
ImportRule
>
>
)
-
>
Arc
<
Locked
<
ImportRule
>
>
{
make_arc
(
make_import
(
media
)
)
}
}
struct
TopLevelRuleParser
<
'
a
>
{
stylesheet_origin
:
Origin
shared_lock
:
&
'
a
SharedRwLock
loader
:
Option
<
&
'
a
StylesheetLoader
>
context
:
ParserContext
<
'
a
>
state
:
State
namespaces
:
Option
<
&
'
a
mut
Namespaces
>
}
impl
<
'
b
>
TopLevelRuleParser
<
'
b
>
{
fn
nested
<
'
a
:
'
b
>
(
&
'
a
self
)
-
>
NestedRuleParser
<
'
a
'
b
>
{
NestedRuleParser
{
stylesheet_origin
:
self
.
stylesheet_origin
shared_lock
:
self
.
shared_lock
context
:
&
self
.
context
}
}
}
#
[
derive
(
Eq
PartialEq
Ord
PartialOrd
Copy
Clone
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
State
{
Start
=
1
Imports
=
2
Namespaces
=
3
Body
=
4
Invalid
=
5
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
VendorPrefix
{
Moz
WebKit
}
enum
AtRulePrelude
{
FontFace
(
SourceLocation
)
CounterStyle
(
CustomIdent
)
Media
(
Arc
<
Locked
<
MediaList
>
>
SourceLocation
)
Supports
(
SupportsCondition
SourceLocation
)
Viewport
Keyframes
(
KeyframesName
Option
<
VendorPrefix
>
SourceLocation
)
Page
(
SourceLocation
)
Document
(
DocumentCondition
SourceLocation
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
register_namespace
(
ns
:
&
Namespace
)
-
>
Result
<
i32
(
)
>
{
let
id
=
unsafe
{
:
:
gecko_bindings
:
:
bindings
:
:
Gecko_RegisterNamespace
(
ns
.
0
.
as_ptr
(
)
)
}
;
if
id
=
=
-
1
{
Err
(
(
)
)
}
else
{
Ok
(
id
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
register_namespace
(
_
:
&
Namespace
)
-
>
Result
<
(
)
(
)
>
{
Ok
(
(
)
)
}
impl
<
'
a
>
AtRuleParser
for
TopLevelRuleParser
<
'
a
>
{
type
Prelude
=
AtRulePrelude
;
type
AtRule
=
CssRule
;
fn
parse_prelude
(
&
mut
self
name
:
&
str
input
:
&
mut
Parser
)
-
>
Result
<
AtRuleType
<
AtRulePrelude
CssRule
>
(
)
>
{
let
location
=
get_location_with_offset
(
input
.
current_source_location
(
)
self
.
context
.
line_number_offset
)
;
match_ignore_ascii_case
!
{
name
"
import
"
=
>
{
if
self
.
state
>
State
:
:
Imports
{
self
.
state
=
State
:
:
Invalid
;
return
Err
(
(
)
)
/
/
"
import
must
be
before
any
rule
but
charset
"
}
self
.
state
=
State
:
:
Imports
;
let
url_string
=
input
.
expect_url_or_string
(
)
?
;
let
specified_url
=
SpecifiedUrl
:
:
parse_from_string
(
url_string
&
self
.
context
)
?
;
let
media
=
parse_media_query_list
(
&
self
.
context
input
)
;
let
media
=
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
media
)
)
;
let
noop_loader
=
NoOpLoader
;
let
loader
=
if
!
specified_url
.
is_invalid
(
)
{
self
.
loader
.
expect
(
"
Expected
a
stylesheet
loader
for
import
"
)
}
else
{
&
noop_loader
}
;
let
mut
specified_url
=
Some
(
specified_url
)
;
let
arc
=
loader
.
request_stylesheet
(
media
&
mut
|
media
|
{
ImportRule
{
url
:
specified_url
.
take
(
)
.
unwrap
(
)
stylesheet
:
Arc
:
:
new
(
Stylesheet
{
rules
:
CssRules
:
:
new
(
Vec
:
:
new
(
)
self
.
shared_lock
)
media
:
media
shared_lock
:
self
.
shared_lock
.
clone
(
)
origin
:
self
.
context
.
stylesheet_origin
url_data
:
self
.
context
.
url_data
.
clone
(
)
namespaces
:
RwLock
:
:
new
(
Namespaces
:
:
default
(
)
)
dirty_on_viewport_size_change
:
AtomicBool
:
:
new
(
false
)
disabled
:
AtomicBool
:
:
new
(
false
)
quirks_mode
:
self
.
context
.
quirks_mode
}
)
source_location
:
location
}
}
&
mut
|
import_rule
|
{
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
import_rule
)
)
}
)
;
return
Ok
(
AtRuleType
:
:
WithoutBlock
(
CssRule
:
:
Import
(
arc
)
)
)
}
"
namespace
"
=
>
{
if
self
.
state
>
State
:
:
Namespaces
{
self
.
state
=
State
:
:
Invalid
;
return
Err
(
(
)
)
/
/
"
namespace
must
be
before
any
rule
but
charset
and
import
"
}
self
.
state
=
State
:
:
Namespaces
;
let
prefix_result
=
input
.
try
(
|
input
|
input
.
expect_ident
(
)
)
;
let
url
=
Namespace
:
:
from
(
try
!
(
input
.
expect_url_or_string
(
)
)
)
;
let
id
=
register_namespace
(
&
url
)
?
;
let
mut
namespaces
=
self
.
namespaces
.
as_mut
(
)
.
unwrap
(
)
;
let
opt_prefix
=
if
let
Ok
(
prefix
)
=
prefix_result
{
let
prefix
=
Prefix
:
:
from
(
prefix
)
;
namespaces
.
prefixes
.
insert
(
prefix
.
clone
(
)
(
url
.
clone
(
)
id
)
)
;
Some
(
prefix
)
}
else
{
namespaces
.
default
=
Some
(
(
url
.
clone
(
)
id
)
)
;
None
}
;
return
Ok
(
AtRuleType
:
:
WithoutBlock
(
CssRule
:
:
Namespace
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
NamespaceRule
{
prefix
:
opt_prefix
url
:
url
source_location
:
location
}
)
)
)
)
)
}
/
/
charset
is
removed
by
rust
-
cssparser
if
it
s
the
first
rule
in
the
stylesheet
/
/
anything
left
is
invalid
.
"
charset
"
=
>
return
Err
(
(
)
)
/
/
(
insert
appropriate
error
message
)
_
=
>
{
}
}
if
self
.
state
>
State
:
:
Body
{
self
.
state
=
State
:
:
Invalid
;
return
Err
(
(
)
)
;
}
self
.
state
=
State
:
:
Body
;
if
self
.
namespaces
.
is_some
(
)
{
let
namespaces
=
&
*
self
.
namespaces
.
take
(
)
.
unwrap
(
)
;
self
.
context
.
namespaces
=
Some
(
namespaces
)
;
}
AtRuleParser
:
:
parse_prelude
(
&
mut
self
.
nested
(
)
name
input
)
}
#
[
inline
]
fn
parse_block
(
&
mut
self
prelude
:
AtRulePrelude
input
:
&
mut
Parser
)
-
>
Result
<
CssRule
(
)
>
{
AtRuleParser
:
:
parse_block
(
&
mut
self
.
nested
(
)
prelude
input
)
}
}
impl
<
'
a
>
QualifiedRuleParser
for
TopLevelRuleParser
<
'
a
>
{
type
Prelude
=
SelectorList
<
SelectorImpl
>
;
type
QualifiedRule
=
CssRule
;
#
[
inline
]
fn
parse_prelude
(
&
mut
self
input
:
&
mut
Parser
)
-
>
Result
<
SelectorList
<
SelectorImpl
>
(
)
>
{
self
.
state
=
State
:
:
Body
;
if
self
.
namespaces
.
is_some
(
)
{
let
namespaces
=
&
*
self
.
namespaces
.
take
(
)
.
unwrap
(
)
;
self
.
context
.
namespaces
=
Some
(
namespaces
)
;
}
QualifiedRuleParser
:
:
parse_prelude
(
&
mut
self
.
nested
(
)
input
)
}
#
[
inline
]
fn
parse_block
(
&
mut
self
prelude
:
SelectorList
<
SelectorImpl
>
input
:
&
mut
Parser
)
-
>
Result
<
CssRule
(
)
>
{
QualifiedRuleParser
:
:
parse_block
(
&
mut
self
.
nested
(
)
prelude
input
)
}
}
#
[
derive
(
Clone
)
]
struct
NestedRuleParser
<
'
a
'
b
:
'
a
>
{
stylesheet_origin
:
Origin
shared_lock
:
&
'
a
SharedRwLock
context
:
&
'
a
ParserContext
<
'
b
>
}
impl
<
'
a
'
b
>
NestedRuleParser
<
'
a
'
b
>
{
fn
parse_nested_rules
(
&
mut
self
input
:
&
mut
Parser
rule_type
:
CssRuleType
)
-
>
Arc
<
Locked
<
CssRules
>
>
{
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
rule_type
)
)
;
let
nested_parser
=
NestedRuleParser
{
stylesheet_origin
:
self
.
stylesheet_origin
shared_lock
:
self
.
shared_lock
context
:
&
context
}
;
let
mut
iter
=
RuleListParser
:
:
new_for_nested_rule
(
input
nested_parser
)
;
let
mut
rules
=
Vec
:
:
new
(
)
;
while
let
Some
(
result
)
=
iter
.
next
(
)
{
match
result
{
Ok
(
rule
)
=
>
rules
.
push
(
rule
)
Err
(
range
)
=
>
{
let
pos
=
range
.
start
;
let
message
=
format
!
(
"
Unsupported
rule
:
'
{
}
'
"
iter
.
input
.
slice
(
range
)
)
;
log_css_error
(
iter
.
input
pos
&
*
message
self
.
context
)
;
}
}
}
CssRules
:
:
new
(
rules
self
.
shared_lock
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
is_viewport_enabled
(
)
-
>
bool
{
PREFS
.
get
(
"
layout
.
viewport
.
enabled
"
)
.
as_boolean
(
)
.
unwrap_or
(
false
)
}
#
[
cfg
(
not
(
feature
=
"
servo
"
)
)
]
fn
is_viewport_enabled
(
)
-
>
bool
{
false
}
impl
<
'
a
'
b
>
AtRuleParser
for
NestedRuleParser
<
'
a
'
b
>
{
type
Prelude
=
AtRulePrelude
;
type
AtRule
=
CssRule
;
fn
parse_prelude
(
&
mut
self
name
:
&
str
input
:
&
mut
Parser
)
-
>
Result
<
AtRuleType
<
AtRulePrelude
CssRule
>
(
)
>
{
let
location
=
get_location_with_offset
(
input
.
current_source_location
(
)
self
.
context
.
line_number_offset
)
;
match_ignore_ascii_case
!
{
name
"
media
"
=
>
{
let
media_queries
=
parse_media_query_list
(
self
.
context
input
)
;
let
arc
=
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
media_queries
)
)
;
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
Media
(
arc
location
)
)
)
}
"
supports
"
=
>
{
let
cond
=
SupportsCondition
:
:
parse
(
input
)
?
;
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
Supports
(
cond
location
)
)
)
}
"
font
-
face
"
=
>
{
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
FontFace
(
location
)
)
)
}
"
counter
-
style
"
=
>
{
if
!
cfg
!
(
feature
=
"
gecko
"
)
{
/
/
Support
for
this
rule
is
not
fully
implemented
in
Servo
yet
.
return
Err
(
(
)
)
}
let
name
=
parse_counter_style_name
(
input
)
?
;
/
/
ASCII
-
case
-
insensitive
matches
for
"
decimal
"
are
already
lower
-
cased
/
/
by
parse_counter_style_name
so
we
can
use
=
=
here
.
/
/
FIXME
:
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1359323
use
atom
!
(
"
decimal
"
)
if
name
.
0
=
=
Atom
:
:
from
(
"
decimal
"
)
{
return
Err
(
(
)
)
}
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
CounterStyle
(
name
)
)
)
}
"
viewport
"
=
>
{
if
is_viewport_enabled
(
)
{
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
Viewport
)
)
}
else
{
Err
(
(
)
)
}
}
"
keyframes
"
|
"
-
webkit
-
keyframes
"
|
"
-
moz
-
keyframes
"
=
>
{
let
prefix
=
if
starts_with_ignore_ascii_case
(
name
"
-
webkit
-
"
)
{
Some
(
VendorPrefix
:
:
WebKit
)
}
else
if
starts_with_ignore_ascii_case
(
name
"
-
moz
-
"
)
{
Some
(
VendorPrefix
:
:
Moz
)
}
else
{
None
}
;
if
cfg
!
(
feature
=
"
servo
"
)
&
&
prefix
.
as_ref
(
)
.
map_or
(
false
|
p
|
matches
!
(
*
p
VendorPrefix
:
:
Moz
)
)
{
/
/
Servo
should
not
support
-
moz
-
keyframes
.
return
Err
(
(
)
)
}
let
name
=
KeyframesName
:
:
parse
(
self
.
context
input
)
?
;
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
Keyframes
(
name
prefix
location
)
)
)
}
"
page
"
=
>
{
if
cfg
!
(
feature
=
"
gecko
"
)
{
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
Page
(
location
)
)
)
}
else
{
Err
(
(
)
)
}
}
"
-
moz
-
document
"
=
>
{
if
cfg
!
(
feature
=
"
gecko
"
)
{
let
cond
=
DocumentCondition
:
:
parse
(
self
.
context
input
)
?
;
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
Document
(
cond
location
)
)
)
}
else
{
Err
(
(
)
)
}
}
_
=
>
Err
(
(
)
)
}
}
fn
parse_block
(
&
mut
self
prelude
:
AtRulePrelude
input
:
&
mut
Parser
)
-
>
Result
<
CssRule
(
)
>
{
match
prelude
{
AtRulePrelude
:
:
FontFace
(
location
)
=
>
{
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
CssRuleType
:
:
FontFace
)
)
;
Ok
(
CssRule
:
:
FontFace
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
parse_font_face_block
(
&
context
input
location
)
.
into
(
)
)
)
)
)
}
AtRulePrelude
:
:
CounterStyle
(
name
)
=
>
{
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
CssRuleType
:
:
CounterStyle
)
)
;
Ok
(
CssRule
:
:
CounterStyle
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
parse_counter_style_body
(
name
&
context
input
)
?
.
into
(
)
)
)
)
)
}
AtRulePrelude
:
:
Media
(
media_queries
location
)
=
>
{
Ok
(
CssRule
:
:
Media
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
MediaRule
{
media_queries
:
media_queries
rules
:
self
.
parse_nested_rules
(
input
CssRuleType
:
:
Media
)
source_location
:
location
}
)
)
)
)
}
AtRulePrelude
:
:
Supports
(
cond
location
)
=
>
{
let
enabled
=
cond
.
eval
(
self
.
context
)
;
Ok
(
CssRule
:
:
Supports
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
SupportsRule
{
condition
:
cond
rules
:
self
.
parse_nested_rules
(
input
CssRuleType
:
:
Supports
)
enabled
:
enabled
source_location
:
location
}
)
)
)
)
}
AtRulePrelude
:
:
Viewport
=
>
{
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
CssRuleType
:
:
Viewport
)
)
;
Ok
(
CssRule
:
:
Viewport
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
try
!
(
ViewportRule
:
:
parse
(
&
context
input
)
)
)
)
)
)
}
AtRulePrelude
:
:
Keyframes
(
name
prefix
location
)
=
>
{
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
CssRuleType
:
:
Keyframes
)
)
;
Ok
(
CssRule
:
:
Keyframes
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
KeyframesRule
{
name
:
name
keyframes
:
parse_keyframe_list
(
&
context
input
self
.
shared_lock
)
vendor_prefix
:
prefix
source_location
:
location
}
)
)
)
)
}
AtRulePrelude
:
:
Page
(
location
)
=
>
{
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
CssRuleType
:
:
Page
)
)
;
let
declarations
=
parse_property_declaration_list
(
&
context
input
)
;
Ok
(
CssRule
:
:
Page
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
PageRule
{
block
:
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
declarations
)
)
source_location
:
location
}
)
)
)
)
}
AtRulePrelude
:
:
Document
(
cond
location
)
=
>
{
if
cfg
!
(
feature
=
"
gecko
"
)
{
Ok
(
CssRule
:
:
Document
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
DocumentRule
{
condition
:
cond
rules
:
self
.
parse_nested_rules
(
input
CssRuleType
:
:
Document
)
source_location
:
location
}
)
)
)
)
}
else
{
unreachable
!
(
)
}
}
}
}
}
impl
<
'
a
'
b
>
QualifiedRuleParser
for
NestedRuleParser
<
'
a
'
b
>
{
type
Prelude
=
SelectorList
<
SelectorImpl
>
;
type
QualifiedRule
=
CssRule
;
fn
parse_prelude
(
&
mut
self
input
:
&
mut
Parser
)
-
>
Result
<
SelectorList
<
SelectorImpl
>
(
)
>
{
let
selector_parser
=
SelectorParser
{
stylesheet_origin
:
self
.
stylesheet_origin
namespaces
:
self
.
context
.
namespaces
.
unwrap
(
)
}
;
SelectorList
:
:
parse
(
&
selector_parser
input
)
}
fn
parse_block
(
&
mut
self
prelude
:
SelectorList
<
SelectorImpl
>
input
:
&
mut
Parser
)
-
>
Result
<
CssRule
(
)
>
{
let
location
=
get_location_with_offset
(
input
.
current_source_location
(
)
self
.
context
.
line_number_offset
)
;
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
CssRuleType
:
:
Style
)
)
;
let
declarations
=
parse_property_declaration_list
(
&
context
input
)
;
Ok
(
CssRule
:
:
Style
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
StyleRule
{
selectors
:
prelude
block
:
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
declarations
)
)
source_location
:
location
}
)
)
)
)
}
}
