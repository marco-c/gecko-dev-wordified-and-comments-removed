#
!
[
deny
(
missing_docs
)
]
use
{
Atom
Prefix
Namespace
}
;
use
cssparser
:
:
{
AtRuleParser
Parser
QualifiedRuleParser
}
;
use
cssparser
:
:
{
AtRuleType
RuleListParser
SourcePosition
Token
parse_one_rule
}
;
use
cssparser
:
:
ToCss
as
ParserToCss
;
use
error_reporting
:
:
ParseErrorReporter
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
font_face
:
:
FontFaceRuleData
;
use
font_face
:
:
parse_font_face_block
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
gecko
:
:
rules
:
:
FontFaceRule
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
structs
:
:
URLExtraData
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
sugar
:
:
refptr
:
:
RefPtr
;
use
keyframes
:
:
{
Keyframe
parse_keyframe_list
}
;
use
media_queries
:
:
{
Device
MediaList
parse_media_query_list
}
;
use
parking_lot
:
:
RwLock
;
use
parser
:
:
{
LengthParsingMode
Parse
ParserContext
log_css_error
}
;
use
properties
:
:
{
PropertyDeclarationBlock
parse_property_declaration_list
}
;
use
selector_parser
:
:
{
SelectorImpl
SelectorParser
}
;
use
selectors
:
:
parser
:
:
SelectorList
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
servo_config
:
:
prefs
:
:
PREFS
;
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
use
servo_url
:
:
ServoUrl
;
use
shared_lock
:
:
{
SharedRwLock
Locked
ToCssWithGuard
SharedRwLockReadGuard
}
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
str
:
:
starts_with_ignore_ascii_case
;
use
style_traits
:
:
ToCss
;
use
stylist
:
:
FnvHashMap
;
use
supports
:
:
SupportsCondition
;
use
values
:
:
specified
:
:
url
:
:
SpecifiedUrl
;
use
viewport
:
:
ViewportRule
;
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
pub
type
UrlExtraData
=
ServoUrl
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
type
UrlExtraData
=
RefPtr
<
URLExtraData
>
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
UrlExtraData
{
pub
fn
as_str
(
&
self
)
-
>
&
str
{
"
(
stylo
:
not
supported
)
"
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
Eq
for
UrlExtraData
{
}
#
[
derive
(
Clone
PartialEq
Eq
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
Origin
{
UserAgent
Author
User
}
#
[
derive
(
Default
Debug
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
Namespaces
{
pub
default
:
Option
<
Namespace
>
pub
prefixes
:
FnvHashMap
<
Prefix
Namespace
>
}
#
[
derive
(
Debug
)
]
pub
struct
CssRules
(
pub
Vec
<
CssRule
>
)
;
impl
CssRules
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_empty
(
)
}
}
#
[
allow
(
missing_docs
)
]
pub
enum
RulesMutateError
{
Syntax
IndexSize
HierarchyRequest
InvalidState
}
impl
From
<
SingleRuleParseError
>
for
RulesMutateError
{
fn
from
(
other
:
SingleRuleParseError
)
-
>
Self
{
match
other
{
SingleRuleParseError
:
:
Syntax
=
>
RulesMutateError
:
:
Syntax
SingleRuleParseError
:
:
Hierarchy
=
>
RulesMutateError
:
:
HierarchyRequest
}
}
}
impl
CssRules
{
#
[
allow
(
missing_docs
)
]
pub
fn
new
(
rules
:
Vec
<
CssRule
>
shared_lock
:
&
SharedRwLock
)
-
>
Arc
<
Locked
<
CssRules
>
>
{
Arc
:
:
new
(
shared_lock
.
wrap
(
CssRules
(
rules
)
)
)
}
fn
only_ns_or_import
(
&
self
)
-
>
bool
{
self
.
0
.
iter
(
)
.
all
(
|
r
|
{
match
*
r
{
CssRule
:
:
Namespace
(
.
.
)
|
CssRule
:
:
Import
(
.
.
)
=
>
true
_
=
>
false
}
}
)
}
pub
fn
remove_rule
(
&
mut
self
index
:
usize
)
-
>
Result
<
(
)
RulesMutateError
>
{
if
index
>
=
self
.
0
.
len
(
)
{
return
Err
(
RulesMutateError
:
:
IndexSize
)
;
}
{
let
ref
rule
=
self
.
0
[
index
]
;
if
let
CssRule
:
:
Namespace
(
.
.
)
=
*
rule
{
if
!
self
.
only_ns_or_import
(
)
{
return
Err
(
RulesMutateError
:
:
InvalidState
)
;
}
}
}
self
.
0
.
remove
(
index
)
;
Ok
(
(
)
)
}
}
pub
trait
CssRulesHelpers
{
fn
insert_rule
(
&
self
lock
:
&
SharedRwLock
rule
:
&
str
parent_stylesheet
:
&
Stylesheet
index
:
usize
nested
:
bool
loader
:
Option
<
&
StylesheetLoader
>
)
-
>
Result
<
CssRule
RulesMutateError
>
;
}
impl
CssRulesHelpers
for
Arc
<
Locked
<
CssRules
>
>
{
fn
insert_rule
(
&
self
lock
:
&
SharedRwLock
rule
:
&
str
parent_stylesheet
:
&
Stylesheet
index
:
usize
nested
:
bool
loader
:
Option
<
&
StylesheetLoader
>
)
-
>
Result
<
CssRule
RulesMutateError
>
{
let
state
=
{
let
read_guard
=
lock
.
read
(
)
;
let
rules
=
self
.
read_with
(
&
read_guard
)
;
if
index
>
rules
.
0
.
len
(
)
{
return
Err
(
RulesMutateError
:
:
IndexSize
)
;
}
if
nested
{
None
}
else
if
index
=
=
0
{
Some
(
State
:
:
Start
)
}
else
{
rules
.
0
.
get
(
index
-
1
)
.
map
(
CssRule
:
:
rule_state
)
}
}
;
let
(
new_rule
new_state
)
=
try
!
(
CssRule
:
:
parse
(
&
rule
parent_stylesheet
state
loader
)
)
;
{
let
mut
write_guard
=
lock
.
write
(
)
;
let
mut
rules
=
self
.
write_with
(
&
mut
write_guard
)
;
let
rev_state
=
rules
.
0
.
get
(
index
)
.
map_or
(
State
:
:
Body
CssRule
:
:
rule_state
)
;
if
new_state
>
rev_state
{
return
Err
(
RulesMutateError
:
:
HierarchyRequest
)
;
}
if
let
CssRule
:
:
Namespace
(
.
.
)
=
new_rule
{
if
!
rules
.
only_ns_or_import
(
)
{
return
Err
(
RulesMutateError
:
:
InvalidState
)
;
}
}
rules
.
0
.
insert
(
index
new_rule
.
clone
(
)
)
;
}
Ok
(
new_rule
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Stylesheet
{
pub
rules
:
Arc
<
Locked
<
CssRules
>
>
pub
media
:
Arc
<
Locked
<
MediaList
>
>
pub
origin
:
Origin
pub
url_data
:
UrlExtraData
pub
shared_lock
:
SharedRwLock
pub
namespaces
:
RwLock
<
Namespaces
>
pub
dirty_on_viewport_size_change
:
AtomicBool
pub
disabled
:
AtomicBool
}
pub
struct
UserAgentStylesheets
{
pub
shared_lock
:
SharedRwLock
pub
user_or_user_agent_stylesheets
:
Vec
<
Stylesheet
>
pub
quirks_mode_stylesheet
:
Stylesheet
}
#
[
derive
(
Debug
Clone
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
CssRule
{
Namespace
(
Arc
<
Locked
<
NamespaceRule
>
>
)
Import
(
Arc
<
Locked
<
ImportRule
>
>
)
Style
(
Arc
<
Locked
<
StyleRule
>
>
)
Media
(
Arc
<
Locked
<
MediaRule
>
>
)
FontFace
(
Arc
<
Locked
<
FontFaceRule
>
>
)
Viewport
(
Arc
<
Locked
<
ViewportRule
>
>
)
Keyframes
(
Arc
<
Locked
<
KeyframesRule
>
>
)
Supports
(
Arc
<
Locked
<
SupportsRule
>
>
)
Page
(
Arc
<
Locked
<
PageRule
>
>
)
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
PartialEq
Eq
Copy
Clone
)
]
pub
enum
CssRuleType
{
Style
=
1
Charset
=
2
Import
=
3
Media
=
4
FontFace
=
5
Page
=
6
Keyframes
=
7
Keyframe
=
8
Margin
=
9
Namespace
=
10
CounterStyle
=
11
Supports
=
12
FontFeatureValues
=
14
Viewport
=
15
}
pub
struct
MemoryHoleReporter
;
impl
ParseErrorReporter
for
MemoryHoleReporter
{
fn
report_error
(
&
self
_
:
&
mut
Parser
_
:
SourcePosition
_
:
&
str
_
:
&
UrlExtraData
_
:
u64
)
{
}
}
#
[
allow
(
missing_docs
)
]
pub
enum
SingleRuleParseError
{
Syntax
Hierarchy
}
impl
CssRule
{
#
[
allow
(
missing_docs
)
]
pub
fn
rule_type
(
&
self
)
-
>
CssRuleType
{
match
*
self
{
CssRule
:
:
Style
(
_
)
=
>
CssRuleType
:
:
Style
CssRule
:
:
Import
(
_
)
=
>
CssRuleType
:
:
Import
CssRule
:
:
Media
(
_
)
=
>
CssRuleType
:
:
Media
CssRule
:
:
FontFace
(
_
)
=
>
CssRuleType
:
:
FontFace
CssRule
:
:
Keyframes
(
_
)
=
>
CssRuleType
:
:
Keyframes
CssRule
:
:
Namespace
(
_
)
=
>
CssRuleType
:
:
Namespace
CssRule
:
:
Viewport
(
_
)
=
>
CssRuleType
:
:
Viewport
CssRule
:
:
Supports
(
_
)
=
>
CssRuleType
:
:
Supports
CssRule
:
:
Page
(
_
)
=
>
CssRuleType
:
:
Page
}
}
fn
rule_state
(
&
self
)
-
>
State
{
match
*
self
{
CssRule
:
:
Import
(
.
.
)
=
>
State
:
:
Imports
CssRule
:
:
Namespace
(
.
.
)
=
>
State
:
:
Namespaces
_
=
>
State
:
:
Body
}
}
pub
fn
with_nested_rules_and_mq
<
F
R
>
(
&
self
guard
:
&
SharedRwLockReadGuard
mut
f
:
F
)
-
>
R
where
F
:
FnMut
(
&
[
CssRule
]
Option
<
&
MediaList
>
)
-
>
R
{
match
*
self
{
CssRule
:
:
Import
(
ref
lock
)
=
>
{
let
rule
=
lock
.
read_with
(
guard
)
;
let
media
=
rule
.
stylesheet
.
media
.
read_with
(
guard
)
;
let
rules
=
rule
.
stylesheet
.
rules
.
read_with
(
guard
)
;
f
(
&
rules
.
0
Some
(
&
media
)
)
}
CssRule
:
:
Namespace
(
_
)
|
CssRule
:
:
Style
(
_
)
|
CssRule
:
:
FontFace
(
_
)
|
CssRule
:
:
Viewport
(
_
)
|
CssRule
:
:
Keyframes
(
_
)
|
CssRule
:
:
Page
(
_
)
=
>
{
f
(
&
[
]
None
)
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
let
media_rule
=
lock
.
read_with
(
guard
)
;
let
mq
=
media_rule
.
media_queries
.
read_with
(
guard
)
;
let
rules
=
&
media_rule
.
rules
.
read_with
(
guard
)
.
0
;
f
(
rules
Some
(
&
mq
)
)
}
CssRule
:
:
Supports
(
ref
lock
)
=
>
{
let
supports_rule
=
lock
.
read_with
(
guard
)
;
let
enabled
=
supports_rule
.
enabled
;
if
enabled
{
let
rules
=
&
supports_rule
.
rules
.
read_with
(
guard
)
.
0
;
f
(
rules
None
)
}
else
{
f
(
&
[
]
None
)
}
}
}
}
#
[
allow
(
missing_docs
)
]
pub
fn
parse
(
css
:
&
str
parent_stylesheet
:
&
Stylesheet
state
:
Option
<
State
>
loader
:
Option
<
&
StylesheetLoader
>
)
-
>
Result
<
(
Self
State
)
SingleRuleParseError
>
{
let
error_reporter
=
MemoryHoleReporter
;
let
mut
namespaces
=
parent_stylesheet
.
namespaces
.
write
(
)
;
let
context
=
ParserContext
:
:
new
(
parent_stylesheet
.
origin
&
parent_stylesheet
.
url_data
&
error_reporter
None
LengthParsingMode
:
:
Default
)
;
let
mut
input
=
Parser
:
:
new
(
css
)
;
let
state
=
state
.
unwrap_or
(
State
:
:
Body
)
;
let
mut
rule_parser
=
TopLevelRuleParser
{
stylesheet_origin
:
parent_stylesheet
.
origin
context
:
context
shared_lock
:
&
parent_stylesheet
.
shared_lock
loader
:
loader
state
:
Cell
:
:
new
(
state
)
namespaces
:
&
mut
namespaces
}
;
match
parse_one_rule
(
&
mut
input
&
mut
rule_parser
)
{
Ok
(
result
)
=
>
Ok
(
(
result
rule_parser
.
state
.
get
(
)
)
)
Err
(
_
)
=
>
{
if
let
State
:
:
Invalid
=
rule_parser
.
state
.
get
(
)
{
Err
(
SingleRuleParseError
:
:
Hierarchy
)
}
else
{
Err
(
SingleRuleParseError
:
:
Syntax
)
}
}
}
}
}
impl
ToCssWithGuard
for
CssRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
CssRule
:
:
Namespace
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Import
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Style
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
FontFace
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Viewport
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Keyframes
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Media
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Supports
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
CssRule
:
:
Page
(
ref
lock
)
=
>
lock
.
read_with
(
guard
)
.
to_css
(
guard
dest
)
}
}
}
#
[
derive
(
Debug
PartialEq
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
NamespaceRule
{
pub
prefix
:
Option
<
Prefix
>
pub
url
:
Namespace
}
impl
ToCssWithGuard
for
NamespaceRule
{
fn
to_css
<
W
>
(
&
self
_guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
namespace
"
)
)
;
if
let
Some
(
ref
prefix
)
=
self
.
prefix
{
try
!
(
dest
.
write_str
(
&
*
prefix
.
to_string
(
)
)
)
;
try
!
(
dest
.
write_str
(
"
"
)
)
;
}
try
!
(
dest
.
write_str
(
"
url
(
\
"
"
)
)
;
try
!
(
dest
.
write_str
(
&
*
self
.
url
.
to_string
(
)
)
)
;
dest
.
write_str
(
"
\
"
)
;
"
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
ImportRule
{
pub
url
:
SpecifiedUrl
pub
stylesheet
:
Arc
<
Stylesheet
>
}
impl
ToCssWithGuard
for
ImportRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
import
"
)
)
;
try
!
(
self
.
url
.
to_css
(
dest
)
)
;
let
media
=
self
.
stylesheet
.
media
.
read_with
(
guard
)
;
if
!
media
.
is_empty
(
)
{
try
!
(
dest
.
write_str
(
"
"
)
)
;
try
!
(
media
.
to_css
(
dest
)
)
;
}
dest
.
write_str
(
"
;
"
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
KeyframesRule
{
pub
name
:
Atom
pub
keyframes
:
Vec
<
Arc
<
Locked
<
Keyframe
>
>
>
pub
vendor_prefix
:
Option
<
VendorPrefix
>
}
impl
ToCssWithGuard
for
KeyframesRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
keyframes
"
)
)
;
try
!
(
dest
.
write_str
(
&
*
self
.
name
.
to_string
(
)
)
)
;
try
!
(
dest
.
write_str
(
"
{
"
)
)
;
let
iter
=
self
.
keyframes
.
iter
(
)
;
let
mut
first
=
true
;
for
lock
in
iter
{
if
!
first
{
try
!
(
dest
.
write_str
(
"
"
)
)
;
}
first
=
false
;
let
keyframe
=
lock
.
read_with
(
&
guard
)
;
try
!
(
keyframe
.
to_css
(
guard
dest
)
)
;
}
dest
.
write_str
(
"
}
"
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
struct
MediaRule
{
pub
media_queries
:
Arc
<
Locked
<
MediaList
>
>
pub
rules
:
Arc
<
Locked
<
CssRules
>
>
}
impl
ToCssWithGuard
for
MediaRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
media
"
)
)
;
try
!
(
self
.
media_queries
.
read_with
(
guard
)
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
{
"
)
)
;
for
rule
in
self
.
rules
.
read_with
(
guard
)
.
0
.
iter
(
)
{
try
!
(
dest
.
write_str
(
"
"
)
)
;
try
!
(
rule
.
to_css
(
guard
dest
)
)
;
}
dest
.
write_str
(
"
}
"
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
SupportsRule
{
pub
condition
:
SupportsCondition
pub
rules
:
Arc
<
Locked
<
CssRules
>
>
pub
enabled
:
bool
}
impl
ToCssWithGuard
for
SupportsRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
supports
"
)
)
;
try
!
(
self
.
condition
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
{
"
)
)
;
for
rule
in
self
.
rules
.
read_with
(
guard
)
.
0
.
iter
(
)
{
try
!
(
dest
.
write_str
(
"
"
)
)
;
try
!
(
rule
.
to_css
(
guard
dest
)
)
;
}
dest
.
write_str
(
"
}
"
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
PageRule
(
pub
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
)
;
impl
ToCssWithGuard
for
PageRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_str
(
"
page
{
"
)
?
;
let
declaration_block
=
self
.
0
.
read_with
(
guard
)
;
declaration_block
.
to_css
(
dest
)
?
;
if
declaration_block
.
declarations
(
)
.
len
(
)
>
0
{
write
!
(
dest
"
"
)
?
;
}
dest
.
write_str
(
"
}
"
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
struct
StyleRule
{
pub
selectors
:
SelectorList
<
SelectorImpl
>
pub
block
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
}
impl
ToCssWithGuard
for
StyleRule
{
fn
to_css
<
W
>
(
&
self
guard
:
&
SharedRwLockReadGuard
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
self
.
selectors
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
{
"
)
)
;
let
declaration_block
=
self
.
block
.
read_with
(
guard
)
;
try
!
(
declaration_block
.
to_css
(
dest
)
)
;
if
declaration_block
.
declarations
(
)
.
len
(
)
>
0
{
try
!
(
write
!
(
dest
"
"
)
)
;
}
try
!
(
dest
.
write_str
(
"
}
"
)
)
;
Ok
(
(
)
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
type
FontFaceRule
=
FontFaceRuleData
;
impl
Stylesheet
{
pub
fn
update_from_str
(
existing
:
&
Stylesheet
css
:
&
str
url_data
:
&
UrlExtraData
stylesheet_loader
:
Option
<
&
StylesheetLoader
>
error_reporter
:
&
ParseErrorReporter
)
{
let
mut
namespaces
=
Namespaces
:
:
default
(
)
;
let
(
rules
dirty_on_viewport_size_change
)
=
Stylesheet
:
:
parse_rules
(
css
url_data
existing
.
origin
&
mut
namespaces
&
existing
.
shared_lock
stylesheet_loader
error_reporter
0u64
)
;
*
existing
.
namespaces
.
write
(
)
=
namespaces
;
existing
.
dirty_on_viewport_size_change
.
store
(
dirty_on_viewport_size_change
Ordering
:
:
Release
)
;
let
mut
guard
=
existing
.
shared_lock
.
write
(
)
;
*
existing
.
rules
.
write_with
(
&
mut
guard
)
=
CssRules
(
rules
)
;
}
fn
parse_rules
(
css
:
&
str
url_data
:
&
UrlExtraData
origin
:
Origin
namespaces
:
&
mut
Namespaces
shared_lock
:
&
SharedRwLock
stylesheet_loader
:
Option
<
&
StylesheetLoader
>
error_reporter
:
&
ParseErrorReporter
line_number_offset
:
u64
)
-
>
(
Vec
<
CssRule
>
bool
)
{
let
mut
rules
=
Vec
:
:
new
(
)
;
let
mut
input
=
Parser
:
:
new
(
css
)
;
let
rule_parser
=
TopLevelRuleParser
{
stylesheet_origin
:
origin
namespaces
:
namespaces
shared_lock
:
shared_lock
loader
:
stylesheet_loader
context
:
ParserContext
:
:
new_with_line_number_offset
(
origin
url_data
error_reporter
line_number_offset
LengthParsingMode
:
:
Default
)
state
:
Cell
:
:
new
(
State
:
:
Start
)
}
;
input
.
look_for_viewport_percentages
(
)
;
{
let
mut
iter
=
RuleListParser
:
:
new_for_stylesheet
(
&
mut
input
rule_parser
)
;
while
let
Some
(
result
)
=
iter
.
next
(
)
{
match
result
{
Ok
(
rule
)
=
>
rules
.
push
(
rule
)
Err
(
range
)
=
>
{
let
pos
=
range
.
start
;
let
message
=
format
!
(
"
Invalid
rule
:
'
{
}
'
"
iter
.
input
.
slice
(
range
)
)
;
log_css_error
(
iter
.
input
pos
&
*
message
&
iter
.
parser
.
context
)
;
}
}
}
}
(
rules
input
.
seen_viewport_percentages
(
)
)
}
pub
fn
from_str
(
css
:
&
str
url_data
:
UrlExtraData
origin
:
Origin
media
:
Arc
<
Locked
<
MediaList
>
>
shared_lock
:
SharedRwLock
stylesheet_loader
:
Option
<
&
StylesheetLoader
>
error_reporter
:
&
ParseErrorReporter
line_number_offset
:
u64
)
-
>
Stylesheet
{
let
mut
namespaces
=
Namespaces
:
:
default
(
)
;
let
(
rules
dirty_on_viewport_size_change
)
=
Stylesheet
:
:
parse_rules
(
css
&
url_data
origin
&
mut
namespaces
&
shared_lock
stylesheet_loader
error_reporter
line_number_offset
)
;
Stylesheet
{
origin
:
origin
url_data
:
url_data
namespaces
:
RwLock
:
:
new
(
namespaces
)
rules
:
CssRules
:
:
new
(
rules
&
shared_lock
)
media
:
media
shared_lock
:
shared_lock
dirty_on_viewport_size_change
:
AtomicBool
:
:
new
(
dirty_on_viewport_size_change
)
disabled
:
AtomicBool
:
:
new
(
false
)
}
}
pub
fn
dirty_on_viewport_size_change
(
&
self
)
-
>
bool
{
self
.
dirty_on_viewport_size_change
.
load
(
Ordering
:
:
SeqCst
)
}
pub
fn
inserted_has_viewport_percentages
(
&
self
has_viewport_percentages
:
bool
)
{
self
.
dirty_on_viewport_size_change
.
fetch_or
(
has_viewport_percentages
Ordering
:
:
SeqCst
)
;
}
pub
fn
is_effective_for_device
(
&
self
device
:
&
Device
guard
:
&
SharedRwLockReadGuard
)
-
>
bool
{
self
.
media
.
read_with
(
guard
)
.
evaluate
(
device
)
}
#
[
inline
]
pub
fn
effective_rules
<
F
>
(
&
self
device
:
&
Device
guard
:
&
SharedRwLockReadGuard
mut
f
:
F
)
where
F
:
FnMut
(
&
CssRule
)
{
effective_rules
(
&
self
.
rules
.
read_with
(
guard
)
.
0
device
guard
&
mut
f
)
;
}
pub
fn
disabled
(
&
self
)
-
>
bool
{
self
.
disabled
.
load
(
Ordering
:
:
SeqCst
)
}
pub
fn
set_disabled
(
&
self
disabled
:
bool
)
-
>
bool
{
self
.
disabled
.
swap
(
disabled
Ordering
:
:
SeqCst
)
!
=
disabled
}
}
fn
effective_rules
<
F
>
(
rules
:
&
[
CssRule
]
device
:
&
Device
guard
:
&
SharedRwLockReadGuard
f
:
&
mut
F
)
where
F
:
FnMut
(
&
CssRule
)
{
for
rule
in
rules
{
f
(
rule
)
;
rule
.
with_nested_rules_and_mq
(
guard
|
rules
mq
|
{
if
let
Some
(
media_queries
)
=
mq
{
if
!
media_queries
.
evaluate
(
device
)
{
return
}
}
effective_rules
(
rules
device
guard
f
)
}
)
}
}
macro_rules
!
rule_filter
{
(
(
method
:
ident
(
variant
:
ident
=
>
rule_type
:
ident
)
)
+
)
=
>
{
impl
Stylesheet
{
(
#
[
allow
(
missing_docs
)
]
pub
fn
method
<
F
>
(
&
self
device
:
&
Device
guard
:
&
SharedRwLockReadGuard
mut
f
:
F
)
where
F
:
FnMut
(
&
rule_type
)
{
self
.
effective_rules
(
device
guard
|
rule
|
{
if
let
CssRule
:
:
variant
(
ref
lock
)
=
*
rule
{
let
rule
=
lock
.
read_with
(
guard
)
;
f
(
&
rule
)
}
}
)
}
)
+
}
}
}
rule_filter
!
{
effective_style_rules
(
Style
=
>
StyleRule
)
effective_media_rules
(
Media
=
>
MediaRule
)
effective_font_face_rules
(
FontFace
=
>
FontFaceRule
)
effective_viewport_rules
(
Viewport
=
>
ViewportRule
)
effective_keyframes_rules
(
Keyframes
=
>
KeyframesRule
)
effective_supports_rules
(
Supports
=
>
SupportsRule
)
effective_page_rules
(
Page
=
>
PageRule
)
}
pub
trait
StylesheetLoader
{
fn
request_stylesheet
(
&
self
media
:
Arc
<
Locked
<
MediaList
>
>
make_import
:
&
mut
FnMut
(
Arc
<
Locked
<
MediaList
>
>
)
-
>
ImportRule
make_arc
:
&
mut
FnMut
(
ImportRule
)
-
>
Arc
<
Locked
<
ImportRule
>
>
)
-
>
Arc
<
Locked
<
ImportRule
>
>
;
}
struct
NoOpLoader
;
impl
StylesheetLoader
for
NoOpLoader
{
fn
request_stylesheet
(
&
self
media
:
Arc
<
Locked
<
MediaList
>
>
make_import
:
&
mut
FnMut
(
Arc
<
Locked
<
MediaList
>
>
)
-
>
ImportRule
make_arc
:
&
mut
FnMut
(
ImportRule
)
-
>
Arc
<
Locked
<
ImportRule
>
>
)
-
>
Arc
<
Locked
<
ImportRule
>
>
{
make_arc
(
make_import
(
media
)
)
}
}
struct
TopLevelRuleParser
<
'
a
>
{
stylesheet_origin
:
Origin
namespaces
:
&
'
a
mut
Namespaces
shared_lock
:
&
'
a
SharedRwLock
loader
:
Option
<
&
'
a
StylesheetLoader
>
context
:
ParserContext
<
'
a
>
state
:
Cell
<
State
>
}
impl
<
'
b
>
TopLevelRuleParser
<
'
b
>
{
fn
nested
<
'
a
:
'
b
>
(
&
'
a
self
)
-
>
NestedRuleParser
<
'
a
'
b
>
{
NestedRuleParser
{
stylesheet_origin
:
self
.
stylesheet_origin
shared_lock
:
self
.
shared_lock
context
:
&
self
.
context
namespaces
:
self
.
namespaces
}
}
}
#
[
derive
(
Eq
PartialEq
Ord
PartialOrd
Copy
Clone
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
State
{
Start
=
1
Imports
=
2
Namespaces
=
3
Body
=
4
Invalid
=
5
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
VendorPrefix
{
Moz
WebKit
}
enum
AtRulePrelude
{
FontFace
Media
(
Arc
<
Locked
<
MediaList
>
>
)
Supports
(
SupportsCondition
)
Viewport
Keyframes
(
Atom
Option
<
VendorPrefix
>
)
Page
}
impl
<
'
a
>
AtRuleParser
for
TopLevelRuleParser
<
'
a
>
{
type
Prelude
=
AtRulePrelude
;
type
AtRule
=
CssRule
;
fn
parse_prelude
(
&
mut
self
name
:
&
str
input
:
&
mut
Parser
)
-
>
Result
<
AtRuleType
<
AtRulePrelude
CssRule
>
(
)
>
{
match_ignore_ascii_case
!
{
name
"
import
"
=
>
{
if
self
.
state
.
get
(
)
<
=
State
:
:
Imports
{
self
.
state
.
set
(
State
:
:
Imports
)
;
let
url_string
=
input
.
expect_url_or_string
(
)
?
;
let
specified_url
=
SpecifiedUrl
:
:
parse_from_string
(
url_string
&
self
.
context
)
?
;
let
media
=
parse_media_query_list
(
&
self
.
context
input
)
;
let
media
=
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
media
)
)
;
let
noop_loader
=
NoOpLoader
;
let
loader
=
if
!
specified_url
.
is_invalid
(
)
{
self
.
loader
.
expect
(
"
Expected
a
stylesheet
loader
for
import
"
)
}
else
{
&
noop_loader
}
;
let
mut
specified_url
=
Some
(
specified_url
)
;
let
arc
=
loader
.
request_stylesheet
(
media
&
mut
|
media
|
{
ImportRule
{
url
:
specified_url
.
take
(
)
.
unwrap
(
)
stylesheet
:
Arc
:
:
new
(
Stylesheet
{
rules
:
CssRules
:
:
new
(
Vec
:
:
new
(
)
self
.
shared_lock
)
media
:
media
shared_lock
:
self
.
shared_lock
.
clone
(
)
origin
:
self
.
context
.
stylesheet_origin
url_data
:
self
.
context
.
url_data
.
clone
(
)
namespaces
:
RwLock
:
:
new
(
Namespaces
:
:
default
(
)
)
dirty_on_viewport_size_change
:
AtomicBool
:
:
new
(
false
)
disabled
:
AtomicBool
:
:
new
(
false
)
}
)
}
}
&
mut
|
import_rule
|
{
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
import_rule
)
)
}
)
;
return
Ok
(
AtRuleType
:
:
WithoutBlock
(
CssRule
:
:
Import
(
arc
)
)
)
}
else
{
self
.
state
.
set
(
State
:
:
Invalid
)
;
return
Err
(
(
)
)
/
/
"
import
must
be
before
any
rule
but
charset
"
}
}
"
namespace
"
=
>
{
if
self
.
state
.
get
(
)
<
=
State
:
:
Namespaces
{
self
.
state
.
set
(
State
:
:
Namespaces
)
;
let
prefix_result
=
input
.
try
(
|
input
|
input
.
expect_ident
(
)
)
;
let
url
=
Namespace
:
:
from
(
try
!
(
input
.
expect_url_or_string
(
)
)
)
;
let
opt_prefix
=
if
let
Ok
(
prefix
)
=
prefix_result
{
let
prefix
=
Prefix
:
:
from
(
prefix
)
;
self
.
namespaces
.
prefixes
.
insert
(
prefix
.
clone
(
)
url
.
clone
(
)
)
;
Some
(
prefix
)
}
else
{
self
.
namespaces
.
default
=
Some
(
url
.
clone
(
)
)
;
None
}
;
return
Ok
(
AtRuleType
:
:
WithoutBlock
(
CssRule
:
:
Namespace
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
NamespaceRule
{
prefix
:
opt_prefix
url
:
url
}
)
)
)
)
)
}
else
{
self
.
state
.
set
(
State
:
:
Invalid
)
;
return
Err
(
(
)
)
/
/
"
namespace
must
be
before
any
rule
but
charset
and
import
"
}
}
/
/
charset
is
removed
by
rust
-
cssparser
if
it
s
the
first
rule
in
the
stylesheet
/
/
anything
left
is
invalid
.
"
charset
"
=
>
return
Err
(
(
)
)
/
/
(
insert
appropriate
error
message
)
_
=
>
{
}
}
if
self
.
state
.
get
(
)
>
State
:
:
Body
{
self
.
state
.
set
(
State
:
:
Invalid
)
;
return
Err
(
(
)
)
;
}
self
.
state
.
set
(
State
:
:
Body
)
;
AtRuleParser
:
:
parse_prelude
(
&
mut
self
.
nested
(
)
name
input
)
}
#
[
inline
]
fn
parse_block
(
&
mut
self
prelude
:
AtRulePrelude
input
:
&
mut
Parser
)
-
>
Result
<
CssRule
(
)
>
{
AtRuleParser
:
:
parse_block
(
&
mut
self
.
nested
(
)
prelude
input
)
}
}
impl
<
'
a
>
QualifiedRuleParser
for
TopLevelRuleParser
<
'
a
>
{
type
Prelude
=
SelectorList
<
SelectorImpl
>
;
type
QualifiedRule
=
CssRule
;
#
[
inline
]
fn
parse_prelude
(
&
mut
self
input
:
&
mut
Parser
)
-
>
Result
<
SelectorList
<
SelectorImpl
>
(
)
>
{
self
.
state
.
set
(
State
:
:
Body
)
;
QualifiedRuleParser
:
:
parse_prelude
(
&
mut
self
.
nested
(
)
input
)
}
#
[
inline
]
fn
parse_block
(
&
mut
self
prelude
:
SelectorList
<
SelectorImpl
>
input
:
&
mut
Parser
)
-
>
Result
<
CssRule
(
)
>
{
QualifiedRuleParser
:
:
parse_block
(
&
mut
self
.
nested
(
)
prelude
input
)
}
}
#
[
derive
(
Clone
)
]
struct
NestedRuleParser
<
'
a
'
b
:
'
a
>
{
stylesheet_origin
:
Origin
shared_lock
:
&
'
a
SharedRwLock
context
:
&
'
a
ParserContext
<
'
b
>
namespaces
:
&
'
b
Namespaces
}
impl
<
'
a
'
b
>
NestedRuleParser
<
'
a
'
b
>
{
fn
parse_nested_rules
(
&
self
input
:
&
mut
Parser
rule_type
:
CssRuleType
)
-
>
Arc
<
Locked
<
CssRules
>
>
{
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
rule_type
)
)
;
let
nested_parser
=
NestedRuleParser
{
stylesheet_origin
:
self
.
stylesheet_origin
shared_lock
:
self
.
shared_lock
context
:
&
context
namespaces
:
self
.
namespaces
}
;
let
mut
iter
=
RuleListParser
:
:
new_for_nested_rule
(
input
nested_parser
)
;
let
mut
rules
=
Vec
:
:
new
(
)
;
while
let
Some
(
result
)
=
iter
.
next
(
)
{
match
result
{
Ok
(
rule
)
=
>
rules
.
push
(
rule
)
Err
(
range
)
=
>
{
let
pos
=
range
.
start
;
let
message
=
format
!
(
"
Unsupported
rule
:
'
{
}
'
"
iter
.
input
.
slice
(
range
)
)
;
log_css_error
(
iter
.
input
pos
&
*
message
self
.
context
)
;
}
}
}
CssRules
:
:
new
(
rules
self
.
shared_lock
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
is_viewport_enabled
(
)
-
>
bool
{
PREFS
.
get
(
"
layout
.
viewport
.
enabled
"
)
.
as_boolean
(
)
.
unwrap_or
(
false
)
}
#
[
cfg
(
not
(
feature
=
"
servo
"
)
)
]
fn
is_viewport_enabled
(
)
-
>
bool
{
true
}
impl
<
'
a
'
b
>
AtRuleParser
for
NestedRuleParser
<
'
a
'
b
>
{
type
Prelude
=
AtRulePrelude
;
type
AtRule
=
CssRule
;
fn
parse_prelude
(
&
mut
self
name
:
&
str
input
:
&
mut
Parser
)
-
>
Result
<
AtRuleType
<
AtRulePrelude
CssRule
>
(
)
>
{
match_ignore_ascii_case
!
{
name
"
media
"
=
>
{
let
media_queries
=
parse_media_query_list
(
self
.
context
input
)
;
let
arc
=
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
media_queries
)
)
;
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
Media
(
arc
)
)
)
}
"
supports
"
=
>
{
let
cond
=
SupportsCondition
:
:
parse
(
input
)
?
;
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
Supports
(
cond
)
)
)
}
"
font
-
face
"
=
>
{
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
FontFace
)
)
}
"
viewport
"
=
>
{
if
is_viewport_enabled
(
)
{
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
Viewport
)
)
}
else
{
Err
(
(
)
)
}
}
"
keyframes
"
|
"
-
webkit
-
keyframes
"
|
"
-
moz
-
keyframes
"
=
>
{
let
prefix
=
if
starts_with_ignore_ascii_case
(
name
"
-
webkit
-
"
)
{
Some
(
VendorPrefix
:
:
WebKit
)
}
else
if
starts_with_ignore_ascii_case
(
name
"
-
moz
-
"
)
{
Some
(
VendorPrefix
:
:
Moz
)
}
else
{
None
}
;
let
name
=
match
input
.
next
(
)
{
Ok
(
Token
:
:
Ident
(
ref
value
)
)
if
value
!
=
"
none
"
=
>
Atom
:
:
from
(
&
*
*
value
)
Ok
(
Token
:
:
QuotedString
(
value
)
)
=
>
Atom
:
:
from
(
&
*
value
)
_
=
>
return
Err
(
(
)
)
}
;
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
Keyframes
(
Atom
:
:
from
(
name
)
prefix
)
)
)
}
"
page
"
=
>
{
if
cfg
!
(
feature
=
"
gecko
"
)
{
Ok
(
AtRuleType
:
:
WithBlock
(
AtRulePrelude
:
:
Page
)
)
}
else
{
Err
(
(
)
)
}
}
_
=
>
Err
(
(
)
)
}
}
fn
parse_block
(
&
mut
self
prelude
:
AtRulePrelude
input
:
&
mut
Parser
)
-
>
Result
<
CssRule
(
)
>
{
match
prelude
{
AtRulePrelude
:
:
FontFace
=
>
{
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
CssRuleType
:
:
FontFace
)
)
;
Ok
(
CssRule
:
:
FontFace
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
parse_font_face_block
(
&
context
input
)
.
into
(
)
)
)
)
)
}
AtRulePrelude
:
:
Media
(
media_queries
)
=
>
{
Ok
(
CssRule
:
:
Media
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
MediaRule
{
media_queries
:
media_queries
rules
:
self
.
parse_nested_rules
(
input
CssRuleType
:
:
Media
)
}
)
)
)
)
}
AtRulePrelude
:
:
Supports
(
cond
)
=
>
{
let
enabled
=
cond
.
eval
(
self
.
context
)
;
Ok
(
CssRule
:
:
Supports
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
SupportsRule
{
condition
:
cond
rules
:
self
.
parse_nested_rules
(
input
CssRuleType
:
:
Supports
)
enabled
:
enabled
}
)
)
)
)
}
AtRulePrelude
:
:
Viewport
=
>
{
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
CssRuleType
:
:
Viewport
)
)
;
Ok
(
CssRule
:
:
Viewport
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
try
!
(
ViewportRule
:
:
parse
(
&
context
input
)
)
)
)
)
)
}
AtRulePrelude
:
:
Keyframes
(
name
prefix
)
=
>
{
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
CssRuleType
:
:
Keyframes
)
)
;
Ok
(
CssRule
:
:
Keyframes
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
KeyframesRule
{
name
:
name
keyframes
:
parse_keyframe_list
(
&
context
input
self
.
shared_lock
)
vendor_prefix
:
prefix
}
)
)
)
)
}
AtRulePrelude
:
:
Page
=
>
{
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
CssRuleType
:
:
Page
)
)
;
let
declarations
=
parse_property_declaration_list
(
&
context
input
)
;
Ok
(
CssRule
:
:
Page
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
PageRule
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
declarations
)
)
)
)
)
)
)
}
}
}
}
impl
<
'
a
'
b
>
QualifiedRuleParser
for
NestedRuleParser
<
'
a
'
b
>
{
type
Prelude
=
SelectorList
<
SelectorImpl
>
;
type
QualifiedRule
=
CssRule
;
fn
parse_prelude
(
&
mut
self
input
:
&
mut
Parser
)
-
>
Result
<
SelectorList
<
SelectorImpl
>
(
)
>
{
let
selector_parser
=
SelectorParser
{
stylesheet_origin
:
self
.
stylesheet_origin
namespaces
:
self
.
namespaces
}
;
SelectorList
:
:
parse
(
&
selector_parser
input
)
}
fn
parse_block
(
&
mut
self
prelude
:
SelectorList
<
SelectorImpl
>
input
:
&
mut
Parser
)
-
>
Result
<
CssRule
(
)
>
{
let
context
=
ParserContext
:
:
new_with_rule_type
(
self
.
context
Some
(
CssRuleType
:
:
Style
)
)
;
let
declarations
=
parse_property_declaration_list
(
&
context
input
)
;
Ok
(
CssRule
:
:
Style
(
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
StyleRule
{
selectors
:
prelude
block
:
Arc
:
:
new
(
self
.
shared_lock
.
wrap
(
declarations
)
)
}
)
)
)
)
}
}
