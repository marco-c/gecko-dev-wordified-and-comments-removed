use
{
Atom
CaseSensitivityExt
LocalName
Namespace
WeakAtom
}
;
use
dom
:
:
TElement
;
use
element_state
:
:
ElementState
;
use
selector_parser
:
:
{
AttrValue
NonTSPseudoClass
PseudoElement
SelectorImpl
}
;
use
selector_parser
:
:
{
Snapshot
SnapshotMap
}
;
use
selectors
:
:
{
Element
OpaqueElement
}
;
use
selectors
:
:
attr
:
:
{
AttrSelectorOperation
CaseSensitivity
NamespaceConstraint
}
;
use
selectors
:
:
matching
:
:
{
ElementSelectorFlags
MatchingContext
}
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
fmt
;
pub
trait
ElementSnapshot
:
Sized
{
fn
state
(
&
self
)
-
>
Option
<
ElementState
>
;
fn
has_attrs
(
&
self
)
-
>
bool
;
fn
id_attr
(
&
self
)
-
>
Option
<
&
WeakAtom
>
;
fn
has_class
(
&
self
name
:
&
Atom
case_sensitivity
:
CaseSensitivity
)
-
>
bool
;
fn
each_class
<
F
>
(
&
self
F
)
where
F
:
FnMut
(
&
Atom
)
;
fn
lang_attr
(
&
self
)
-
>
Option
<
AttrValue
>
;
}
#
[
derive
(
Clone
)
]
pub
struct
ElementWrapper
<
'
a
E
>
where
E
:
TElement
{
element
:
E
cached_snapshot
:
Cell
<
Option
<
&
'
a
Snapshot
>
>
snapshot_map
:
&
'
a
SnapshotMap
}
impl
<
'
a
E
>
ElementWrapper
<
'
a
E
>
where
E
:
TElement
{
pub
fn
new
(
el
:
E
snapshot_map
:
&
'
a
SnapshotMap
)
-
>
Self
{
ElementWrapper
{
element
:
el
cached_snapshot
:
Cell
:
:
new
(
None
)
snapshot_map
:
snapshot_map
}
}
pub
fn
snapshot
(
&
self
)
-
>
Option
<
&
'
a
Snapshot
>
{
if
!
self
.
element
.
has_snapshot
(
)
{
return
None
;
}
if
let
Some
(
s
)
=
self
.
cached_snapshot
.
get
(
)
{
return
Some
(
s
)
;
}
let
snapshot
=
self
.
snapshot_map
.
get
(
&
self
.
element
)
;
debug_assert
!
(
snapshot
.
is_some
(
)
"
has_snapshot
lied
!
"
)
;
self
.
cached_snapshot
.
set
(
snapshot
)
;
snapshot
}
pub
fn
state_changes
(
&
self
)
-
>
ElementState
{
let
snapshot
=
match
self
.
snapshot
(
)
{
Some
(
s
)
=
>
s
None
=
>
return
ElementState
:
:
empty
(
)
}
;
match
snapshot
.
state
(
)
{
Some
(
state
)
=
>
state
^
self
.
element
.
state
(
)
None
=
>
ElementState
:
:
empty
(
)
}
}
fn
get_lang
(
&
self
)
-
>
Option
<
AttrValue
>
{
let
mut
current
=
self
.
clone
(
)
;
loop
{
let
lang
=
match
self
.
snapshot
(
)
{
Some
(
snapshot
)
if
snapshot
.
has_attrs
(
)
=
>
snapshot
.
lang_attr
(
)
_
=
>
current
.
element
.
lang_attr
(
)
}
;
if
lang
.
is_some
(
)
{
return
lang
;
}
current
=
current
.
parent_element
(
)
?
;
}
}
}
impl
<
'
a
E
>
fmt
:
:
Debug
for
ElementWrapper
<
'
a
E
>
where
E
:
TElement
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
element
.
fmt
(
f
)
}
}
impl
<
'
a
E
>
Element
for
ElementWrapper
<
'
a
E
>
where
E
:
TElement
{
type
Impl
=
SelectorImpl
;
fn
match_non_ts_pseudo_class
<
F
>
(
&
self
pseudo_class
:
&
NonTSPseudoClass
context
:
&
mut
MatchingContext
<
Self
:
:
Impl
>
_setter
:
&
mut
F
)
-
>
bool
where
F
:
FnMut
(
&
Self
ElementSelectorFlags
)
{
match
*
pseudo_class
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
MozAny
(
ref
selectors
)
=
>
{
use
selectors
:
:
matching
:
:
matches_complex_selector
;
return
context
.
nest
(
|
context
|
{
selectors
.
iter
(
)
.
any
(
|
s
|
matches_complex_selector
(
s
.
iter
(
)
self
context
_setter
)
)
}
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
Dir
(
ref
dir
)
=
>
{
use
invalidation
:
:
element
:
:
invalidation_map
:
:
dir_selector_to_state
;
let
selector_flag
=
dir_selector_to_state
(
dir
)
;
if
selector_flag
.
is_empty
(
)
{
return
false
;
}
let
state
=
match
self
.
snapshot
(
)
.
and_then
(
|
s
|
s
.
state
(
)
)
{
Some
(
snapshot_state
)
=
>
snapshot_state
None
=
>
self
.
element
.
state
(
)
}
;
return
state
.
contains
(
selector_flag
)
;
}
NonTSPseudoClass
:
:
Link
=
>
{
return
self
.
is_link
(
)
&
&
context
.
visited_handling
(
)
.
matches_unvisited
(
)
}
NonTSPseudoClass
:
:
Visited
=
>
{
return
self
.
is_link
(
)
&
&
context
.
visited_handling
(
)
.
matches_visited
(
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
MozTableBorderNonzero
=
>
{
if
let
Some
(
snapshot
)
=
self
.
snapshot
(
)
{
if
snapshot
.
has_other_pseudo_class_state
(
)
{
return
snapshot
.
mIsTableBorderNonzero
(
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
MozBrowserFrame
=
>
{
if
let
Some
(
snapshot
)
=
self
.
snapshot
(
)
{
if
snapshot
.
has_other_pseudo_class_state
(
)
{
return
snapshot
.
mIsMozBrowserFrame
(
)
;
}
}
}
NonTSPseudoClass
:
:
Lang
(
ref
lang_arg
)
=
>
{
return
self
.
element
.
match_element_lang
(
Some
(
self
.
get_lang
(
)
)
lang_arg
)
;
}
_
=
>
{
}
}
let
flag
=
pseudo_class
.
state_flag
(
)
;
if
flag
.
is_empty
(
)
{
return
self
.
element
.
match_non_ts_pseudo_class
(
pseudo_class
context
&
mut
|
_
_
|
{
}
)
;
}
match
self
.
snapshot
(
)
.
and_then
(
|
s
|
s
.
state
(
)
)
{
Some
(
snapshot_state
)
=
>
snapshot_state
.
intersects
(
flag
)
None
=
>
self
.
element
.
match_non_ts_pseudo_class
(
pseudo_class
context
&
mut
|
_
_
|
{
}
)
}
}
fn
match_pseudo_element
(
&
self
pseudo_element
:
&
PseudoElement
context
:
&
mut
MatchingContext
<
Self
:
:
Impl
>
)
-
>
bool
{
self
.
element
.
match_pseudo_element
(
pseudo_element
context
)
}
fn
is_link
(
&
self
)
-
>
bool
{
self
.
element
.
is_link
(
)
}
fn
opaque
(
&
self
)
-
>
OpaqueElement
{
self
.
element
.
opaque
(
)
}
fn
parent_element
(
&
self
)
-
>
Option
<
Self
>
{
let
parent
=
self
.
element
.
parent_element
(
)
?
;
Some
(
Self
:
:
new
(
parent
self
.
snapshot_map
)
)
}
fn
parent_node_is_shadow_root
(
&
self
)
-
>
bool
{
self
.
element
.
parent_node_is_shadow_root
(
)
}
fn
containing_shadow_host
(
&
self
)
-
>
Option
<
Self
>
{
let
host
=
self
.
element
.
containing_shadow_host
(
)
?
;
Some
(
Self
:
:
new
(
host
self
.
snapshot_map
)
)
}
fn
first_child_element
(
&
self
)
-
>
Option
<
Self
>
{
let
child
=
self
.
element
.
first_child_element
(
)
?
;
Some
(
Self
:
:
new
(
child
self
.
snapshot_map
)
)
}
fn
last_child_element
(
&
self
)
-
>
Option
<
Self
>
{
let
child
=
self
.
element
.
last_child_element
(
)
?
;
Some
(
Self
:
:
new
(
child
self
.
snapshot_map
)
)
}
fn
prev_sibling_element
(
&
self
)
-
>
Option
<
Self
>
{
let
sibling
=
self
.
element
.
prev_sibling_element
(
)
?
;
Some
(
Self
:
:
new
(
sibling
self
.
snapshot_map
)
)
}
fn
next_sibling_element
(
&
self
)
-
>
Option
<
Self
>
{
let
sibling
=
self
.
element
.
next_sibling_element
(
)
?
;
Some
(
Self
:
:
new
(
sibling
self
.
snapshot_map
)
)
}
#
[
inline
]
fn
is_html_element_in_html_document
(
&
self
)
-
>
bool
{
self
.
element
.
is_html_element_in_html_document
(
)
}
#
[
inline
]
fn
is_html_slot_element
(
&
self
)
-
>
bool
{
self
.
element
.
is_html_slot_element
(
)
}
#
[
inline
]
fn
local_name
(
&
self
)
-
>
&
<
Self
:
:
Impl
as
:
:
selectors
:
:
SelectorImpl
>
:
:
BorrowedLocalName
{
self
.
element
.
local_name
(
)
}
#
[
inline
]
fn
namespace
(
&
self
)
-
>
&
<
Self
:
:
Impl
as
:
:
selectors
:
:
SelectorImpl
>
:
:
BorrowedNamespaceUrl
{
self
.
element
.
namespace
(
)
}
fn
attr_matches
(
&
self
ns
:
&
NamespaceConstraint
<
&
Namespace
>
local_name
:
&
LocalName
operation
:
&
AttrSelectorOperation
<
&
AttrValue
>
)
-
>
bool
{
match
self
.
snapshot
(
)
{
Some
(
snapshot
)
if
snapshot
.
has_attrs
(
)
=
>
{
snapshot
.
attr_matches
(
ns
local_name
operation
)
}
_
=
>
self
.
element
.
attr_matches
(
ns
local_name
operation
)
}
}
fn
has_id
(
&
self
id
:
&
Atom
case_sensitivity
:
CaseSensitivity
)
-
>
bool
{
match
self
.
snapshot
(
)
{
Some
(
snapshot
)
if
snapshot
.
has_attrs
(
)
=
>
snapshot
.
id_attr
(
)
.
map_or
(
false
|
atom
|
case_sensitivity
.
eq_atom
(
&
atom
id
)
)
_
=
>
self
.
element
.
has_id
(
id
case_sensitivity
)
}
}
fn
has_class
(
&
self
name
:
&
Atom
case_sensitivity
:
CaseSensitivity
)
-
>
bool
{
match
self
.
snapshot
(
)
{
Some
(
snapshot
)
if
snapshot
.
has_attrs
(
)
=
>
snapshot
.
has_class
(
name
case_sensitivity
)
_
=
>
self
.
element
.
has_class
(
name
case_sensitivity
)
}
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
element
.
is_empty
(
)
}
fn
is_root
(
&
self
)
-
>
bool
{
self
.
element
.
is_root
(
)
}
fn
pseudo_element_originating_element
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
pseudo_element_originating_element
(
)
.
map
(
|
e
|
ElementWrapper
:
:
new
(
e
self
.
snapshot_map
)
)
}
fn
assigned_slot
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
assigned_slot
(
)
.
map
(
|
e
|
ElementWrapper
:
:
new
(
e
self
.
snapshot_map
)
)
}
}
