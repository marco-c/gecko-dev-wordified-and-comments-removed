use
context
:
:
{
SharedStyleContext
StackLimitChecker
}
;
use
data
:
:
ElementData
;
use
dom
:
:
{
TElement
TNode
}
;
use
selector_parser
:
:
SelectorImpl
;
use
selectors
:
:
NthIndexCache
;
use
selectors
:
:
matching
:
:
{
MatchingContext
MatchingMode
VisitedHandlingMode
}
;
use
selectors
:
:
matching
:
:
CompoundSelectorMatchingResult
;
use
selectors
:
:
matching
:
:
matches_compound_selector
;
use
selectors
:
:
parser
:
:
{
Combinator
Component
Selector
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
fmt
;
pub
trait
InvalidationProcessor
<
E
>
where
E
:
TElement
{
fn
invalidates_on_eager_pseudo_element
(
&
self
)
-
>
bool
{
false
}
fn
collect_invalidations
(
&
mut
self
element
:
E
data
:
Option
<
&
mut
ElementData
>
nth_index_cache
:
Option
<
&
mut
NthIndexCache
>
shared_context
:
&
SharedStyleContext
descendant_invalidations
:
&
mut
InvalidationVector
sibling_invalidations
:
&
mut
InvalidationVector
)
-
>
bool
;
fn
should_process_descendants
(
&
mut
self
element
:
E
data
:
Option
<
&
mut
ElementData
>
)
-
>
bool
;
fn
recursion_limit_exceeded
(
&
mut
self
element
:
E
data
:
Option
<
&
mut
ElementData
>
)
;
fn
invalidated_self
(
&
mut
self
element
:
E
data
:
Option
<
&
mut
ElementData
>
)
;
fn
invalidated_descendants
(
&
mut
self
element
:
E
data
:
Option
<
&
mut
ElementData
>
child
:
E
)
;
}
pub
struct
TreeStyleInvalidator
<
'
a
'
b
:
'
a
E
P
:
'
a
>
where
E
:
TElement
P
:
InvalidationProcessor
<
E
>
{
element
:
E
data
:
Option
<
&
'
a
mut
ElementData
>
shared_context
:
&
'
a
SharedStyleContext
<
'
b
>
stack_limit_checker
:
Option
<
&
'
a
StackLimitChecker
>
nth_index_cache
:
Option
<
&
'
a
mut
NthIndexCache
>
processor
:
&
'
a
mut
P
}
pub
type
InvalidationVector
=
SmallVec
<
[
Invalidation
;
10
]
>
;
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
enum
InvalidationKind
{
Descendant
Sibling
}
#
[
derive
(
Clone
)
]
pub
struct
Invalidation
{
selector
:
Selector
<
SelectorImpl
>
offset
:
usize
matched_by_any_previous
:
bool
}
impl
Invalidation
{
pub
fn
new
(
selector
:
Selector
<
SelectorImpl
>
offset
:
usize
)
-
>
Self
{
Self
{
selector
offset
matched_by_any_previous
:
false
}
}
fn
effective_for_next
(
&
self
)
-
>
bool
{
match
self
.
selector
.
combinator_at_parse_order
(
self
.
offset
-
1
)
{
Combinator
:
:
NextSibling
|
Combinator
:
:
Child
=
>
false
_
=
>
true
}
}
fn
kind
(
&
self
)
-
>
InvalidationKind
{
if
self
.
selector
.
combinator_at_parse_order
(
self
.
offset
-
1
)
.
is_ancestor
(
)
{
InvalidationKind
:
:
Descendant
}
else
{
InvalidationKind
:
:
Sibling
}
}
}
impl
fmt
:
:
Debug
for
Invalidation
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
use
cssparser
:
:
ToCss
;
f
.
write_str
(
"
Invalidation
(
"
)
?
;
for
component
in
self
.
selector
.
iter_raw_parse_order_from
(
self
.
offset
)
{
if
matches
!
(
*
component
Component
:
:
Combinator
(
.
.
)
)
{
break
;
}
component
.
to_css
(
f
)
?
;
}
f
.
write_str
(
"
)
"
)
}
}
struct
SingleInvalidationResult
{
invalidated_self
:
bool
matched
:
bool
}
pub
struct
InvalidationResult
{
invalidated_self
:
bool
invalidated_descendants
:
bool
invalidated_siblings
:
bool
}
impl
InvalidationResult
{
pub
fn
empty
(
)
-
>
Self
{
Self
{
invalidated_self
:
false
invalidated_descendants
:
false
invalidated_siblings
:
false
}
}
pub
fn
has_invalidated_self
(
&
self
)
-
>
bool
{
self
.
invalidated_self
}
pub
fn
has_invalidated_descendants
(
&
self
)
-
>
bool
{
self
.
invalidated_descendants
}
pub
fn
has_invalidated_siblings
(
&
self
)
-
>
bool
{
self
.
invalidated_siblings
}
}
impl
<
'
a
'
b
:
'
a
E
P
:
'
a
>
TreeStyleInvalidator
<
'
a
'
b
E
P
>
where
E
:
TElement
P
:
InvalidationProcessor
<
E
>
{
pub
fn
new
(
element
:
E
data
:
Option
<
&
'
a
mut
ElementData
>
shared_context
:
&
'
a
SharedStyleContext
<
'
b
>
stack_limit_checker
:
Option
<
&
'
a
StackLimitChecker
>
nth_index_cache
:
Option
<
&
'
a
mut
NthIndexCache
>
processor
:
&
'
a
mut
P
)
-
>
Self
{
Self
{
element
data
shared_context
stack_limit_checker
nth_index_cache
processor
}
}
pub
fn
invalidate
(
mut
self
)
-
>
InvalidationResult
{
debug
!
(
"
StyleTreeInvalidator
:
:
invalidate
(
{
:
?
}
)
"
self
.
element
)
;
let
mut
descendant_invalidations
=
InvalidationVector
:
:
new
(
)
;
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
let
invalidated_self
=
self
.
processor
.
collect_invalidations
(
self
.
element
self
.
data
.
as_mut
(
)
.
map
(
|
d
|
&
mut
*
*
d
)
self
.
nth_index_cache
.
as_mut
(
)
.
map
(
|
c
|
&
mut
*
*
c
)
self
.
shared_context
&
mut
descendant_invalidations
&
mut
sibling_invalidations
)
;
debug
!
(
"
Collected
invalidations
(
self
:
{
}
)
:
"
invalidated_self
)
;
debug
!
(
"
>
descendants
:
{
:
?
}
"
descendant_invalidations
)
;
debug
!
(
"
>
siblings
:
{
:
?
}
"
sibling_invalidations
)
;
let
invalidated_descendants
=
self
.
invalidate_descendants
(
&
descendant_invalidations
)
;
let
invalidated_siblings
=
self
.
invalidate_siblings
(
&
mut
sibling_invalidations
)
;
InvalidationResult
{
invalidated_self
invalidated_descendants
invalidated_siblings
}
}
fn
invalidate_siblings
(
&
mut
self
sibling_invalidations
:
&
mut
InvalidationVector
)
-
>
bool
{
if
sibling_invalidations
.
is_empty
(
)
{
return
false
;
}
let
mut
current
=
self
.
element
.
next_sibling_element
(
)
;
let
mut
any_invalidated
=
false
;
while
let
Some
(
sibling
)
=
current
{
let
mut
sibling_data
=
sibling
.
mutate_data
(
)
;
let
mut
sibling_invalidator
=
TreeStyleInvalidator
:
:
new
(
sibling
sibling_data
.
as_mut
(
)
.
map
(
|
d
|
&
mut
*
*
d
)
self
.
shared_context
self
.
stack_limit_checker
self
.
nth_index_cache
.
as_mut
(
)
.
map
(
|
c
|
&
mut
*
*
c
)
self
.
processor
)
;
let
mut
invalidations_for_descendants
=
InvalidationVector
:
:
new
(
)
;
any_invalidated
|
=
sibling_invalidator
.
process_sibling_invalidations
(
&
mut
invalidations_for_descendants
sibling_invalidations
)
;
any_invalidated
|
=
sibling_invalidator
.
invalidate_descendants
(
&
invalidations_for_descendants
)
;
if
sibling_invalidations
.
is_empty
(
)
{
break
;
}
current
=
sibling
.
next_sibling_element
(
)
;
}
any_invalidated
}
fn
invalidate_pseudo_element_or_nac
(
&
mut
self
child
:
E
invalidations
:
&
InvalidationVector
)
-
>
bool
{
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
let
result
=
self
.
invalidate_child
(
child
invalidations
&
mut
sibling_invalidations
)
;
result
}
fn
invalidate_child
(
&
mut
self
child
:
E
invalidations
:
&
InvalidationVector
sibling_invalidations
:
&
mut
InvalidationVector
)
-
>
bool
{
let
mut
invalidations_for_descendants
=
InvalidationVector
:
:
new
(
)
;
let
mut
invalidated_child
=
false
;
let
invalidated_descendants
=
{
let
mut
child_data
=
child
.
mutate_data
(
)
;
let
mut
child_invalidator
=
TreeStyleInvalidator
:
:
new
(
child
child_data
.
as_mut
(
)
.
map
(
|
d
|
&
mut
*
*
d
)
self
.
shared_context
self
.
stack_limit_checker
self
.
nth_index_cache
.
as_mut
(
)
.
map
(
|
c
|
&
mut
*
*
c
)
self
.
processor
)
;
invalidated_child
|
=
child_invalidator
.
process_sibling_invalidations
(
&
mut
invalidations_for_descendants
sibling_invalidations
)
;
invalidated_child
|
=
child_invalidator
.
process_descendant_invalidations
(
invalidations
&
mut
invalidations_for_descendants
sibling_invalidations
)
;
child_invalidator
.
invalidate_descendants
(
&
invalidations_for_descendants
)
}
;
if
invalidated_child
|
|
invalidated_descendants
{
self
.
processor
.
invalidated_descendants
(
self
.
element
self
.
data
.
as_mut
(
)
.
map
(
|
d
|
&
mut
*
*
d
)
child
)
;
}
invalidated_child
|
|
invalidated_descendants
}
fn
invalidate_nac
(
&
mut
self
invalidations
:
&
InvalidationVector
)
-
>
bool
{
let
mut
any_nac_root
=
false
;
let
element
=
self
.
element
;
element
.
each_anonymous_content_child
(
|
nac
|
{
any_nac_root
|
=
self
.
invalidate_pseudo_element_or_nac
(
nac
invalidations
)
;
}
)
;
any_nac_root
}
fn
invalidate_dom_descendants_of
(
&
mut
self
parent
:
E
:
:
ConcreteNode
invalidations
:
&
InvalidationVector
)
-
>
bool
{
let
mut
any_descendant
=
false
;
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
for
child
in
parent
.
children
(
)
{
let
child
=
match
child
.
as_element
(
)
{
Some
(
e
)
=
>
e
None
=
>
continue
}
;
any_descendant
|
=
self
.
invalidate_child
(
child
invalidations
&
mut
sibling_invalidations
)
;
}
any_descendant
}
fn
invalidate_descendants
(
&
mut
self
invalidations
:
&
InvalidationVector
)
-
>
bool
{
if
invalidations
.
is_empty
(
)
{
return
false
;
}
debug
!
(
"
StyleTreeInvalidator
:
:
invalidate_descendants
(
{
:
?
}
)
"
self
.
element
)
;
debug
!
(
"
>
{
:
?
}
"
invalidations
)
;
let
should_process
=
self
.
processor
.
should_process_descendants
(
self
.
element
self
.
data
.
as_mut
(
)
.
map
(
|
d
|
&
mut
*
*
d
)
)
;
if
!
should_process
{
return
false
;
}
if
let
Some
(
checker
)
=
self
.
stack_limit_checker
{
if
checker
.
limit_exceeded
(
)
{
self
.
processor
.
recursion_limit_exceeded
(
self
.
element
self
.
data
.
as_mut
(
)
.
map
(
|
d
|
&
mut
*
*
d
)
)
;
return
true
;
}
}
let
mut
any_descendant
=
false
;
if
let
Some
(
anon_content
)
=
self
.
element
.
xbl_binding_anonymous_content
(
)
{
any_descendant
|
=
self
.
invalidate_dom_descendants_of
(
anon_content
invalidations
)
;
}
if
let
Some
(
before
)
=
self
.
element
.
before_pseudo_element
(
)
{
any_descendant
|
=
self
.
invalidate_pseudo_element_or_nac
(
before
invalidations
)
;
}
let
node
=
self
.
element
.
as_node
(
)
;
any_descendant
|
=
self
.
invalidate_dom_descendants_of
(
node
invalidations
)
;
if
let
Some
(
after
)
=
self
.
element
.
after_pseudo_element
(
)
{
any_descendant
|
=
self
.
invalidate_pseudo_element_or_nac
(
after
invalidations
)
;
}
any_descendant
|
=
self
.
invalidate_nac
(
invalidations
)
;
any_descendant
}
fn
process_sibling_invalidations
(
&
mut
self
descendant_invalidations
:
&
mut
InvalidationVector
sibling_invalidations
:
&
mut
InvalidationVector
)
-
>
bool
{
let
mut
i
=
0
;
let
mut
new_sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
let
mut
invalidated_self
=
false
;
while
i
<
sibling_invalidations
.
len
(
)
{
let
result
=
self
.
process_invalidation
(
&
sibling_invalidations
[
i
]
descendant_invalidations
&
mut
new_sibling_invalidations
InvalidationKind
:
:
Sibling
)
;
invalidated_self
|
=
result
.
invalidated_self
;
sibling_invalidations
[
i
]
.
matched_by_any_previous
|
=
result
.
matched
;
if
sibling_invalidations
[
i
]
.
effective_for_next
(
)
{
i
+
=
1
;
}
else
{
sibling_invalidations
.
remove
(
i
)
;
}
}
sibling_invalidations
.
extend
(
new_sibling_invalidations
.
drain
(
)
)
;
invalidated_self
}
fn
process_descendant_invalidations
(
&
mut
self
invalidations
:
&
InvalidationVector
descendant_invalidations
:
&
mut
InvalidationVector
sibling_invalidations
:
&
mut
InvalidationVector
)
-
>
bool
{
let
mut
invalidated
=
false
;
for
invalidation
in
invalidations
{
let
result
=
self
.
process_invalidation
(
invalidation
descendant_invalidations
sibling_invalidations
InvalidationKind
:
:
Descendant
)
;
invalidated
|
=
result
.
invalidated_self
;
if
invalidation
.
effective_for_next
(
)
{
let
mut
invalidation
=
invalidation
.
clone
(
)
;
invalidation
.
matched_by_any_previous
|
=
result
.
matched
;
descendant_invalidations
.
push
(
invalidation
.
clone
(
)
)
;
}
}
invalidated
}
fn
process_invalidation
(
&
mut
self
invalidation
:
&
Invalidation
descendant_invalidations
:
&
mut
InvalidationVector
sibling_invalidations
:
&
mut
InvalidationVector
invalidation_kind
:
InvalidationKind
)
-
>
SingleInvalidationResult
{
debug
!
(
"
TreeStyleInvalidator
:
:
process_invalidation
(
{
:
?
}
{
:
?
}
{
:
?
}
)
"
self
.
element
invalidation
invalidation_kind
)
;
let
matching_result
=
{
let
mut
context
=
MatchingContext
:
:
new_for_visited
(
MatchingMode
:
:
Normal
None
self
.
nth_index_cache
.
as_mut
(
)
.
map
(
|
c
|
&
mut
*
*
c
)
VisitedHandlingMode
:
:
AllLinksVisitedAndUnvisited
self
.
shared_context
.
quirks_mode
(
)
)
;
matches_compound_selector
(
&
invalidation
.
selector
invalidation
.
offset
&
mut
context
&
self
.
element
)
}
;
let
mut
invalidated_self
=
false
;
let
mut
matched
=
false
;
match
matching_result
{
CompoundSelectorMatchingResult
:
:
FullyMatched
=
>
{
debug
!
(
"
>
Invalidation
matched
completely
"
)
;
matched
=
true
;
invalidated_self
=
true
;
}
CompoundSelectorMatchingResult
:
:
Matched
{
next_combinator_offset
}
=
>
{
let
next_combinator
=
invalidation
.
selector
.
combinator_at_parse_order
(
next_combinator_offset
)
;
matched
=
true
;
if
matches
!
(
next_combinator
Combinator
:
:
PseudoElement
)
{
let
pseudo_selector
=
invalidation
.
selector
.
iter_raw_parse_order_from
(
next_combinator_offset
+
1
)
.
skip_while
(
|
c
|
matches
!
(
*
*
c
Component
:
:
NonTSPseudoClass
(
.
.
)
)
)
.
next
(
)
.
unwrap
(
)
;
let
pseudo
=
match
*
pseudo_selector
{
Component
:
:
PseudoElement
(
ref
pseudo
)
=
>
pseudo
_
=
>
{
unreachable
!
(
"
Someone
seriously
messed
up
selector
parsing
:
\
{
:
?
}
at
offset
{
:
?
}
:
{
:
?
}
"
invalidation
.
selector
next_combinator_offset
pseudo_selector
)
}
}
;
if
self
.
processor
.
invalidates_on_eager_pseudo_element
(
)
&
&
pseudo
.
is_eager
(
)
{
invalidated_self
=
true
;
}
}
let
next_invalidation
=
Invalidation
{
selector
:
invalidation
.
selector
.
clone
(
)
offset
:
next_combinator_offset
+
1
matched_by_any_previous
:
false
}
;
debug
!
(
"
>
Invalidation
matched
next
:
{
:
?
}
(
{
:
?
}
)
"
next_invalidation
next_combinator
)
;
let
next_invalidation_kind
=
next_invalidation
.
kind
(
)
;
let
can_skip_pushing
=
next_invalidation_kind
=
=
invalidation_kind
&
&
invalidation
.
matched_by_any_previous
&
&
next_invalidation
.
effective_for_next
(
)
;
if
can_skip_pushing
{
debug
!
(
"
>
Can
avoid
push
since
the
invalidation
had
\
already
been
matched
before
"
)
;
}
else
{
match
next_invalidation_kind
{
InvalidationKind
:
:
Descendant
=
>
{
descendant_invalidations
.
push
(
next_invalidation
)
;
}
InvalidationKind
:
:
Sibling
=
>
{
sibling_invalidations
.
push
(
next_invalidation
)
;
}
}
}
}
CompoundSelectorMatchingResult
:
:
NotMatched
=
>
{
}
}
if
invalidated_self
{
self
.
processor
.
invalidated_self
(
self
.
element
self
.
data
.
as_mut
(
)
.
map
(
|
d
|
&
mut
*
*
d
)
)
;
}
SingleInvalidationResult
{
invalidated_self
matched
}
}
}
