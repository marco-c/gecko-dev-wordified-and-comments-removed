use
crate
:
:
context
:
:
StackLimitChecker
;
use
crate
:
:
dom
:
:
{
TElement
TNode
TShadowRoot
}
;
use
crate
:
:
invalidation
:
:
element
:
:
invalidation_map
:
:
{
Dependency
DependencyInvalidationKind
NormalDependencyInvalidationKind
RelativeDependencyInvalidationKind
}
;
use
selectors
:
:
matching
:
:
matches_compound_selector_from
;
use
selectors
:
:
matching
:
:
{
CompoundSelectorMatchingResult
MatchingContext
}
;
use
selectors
:
:
parser
:
:
{
Combinator
Component
}
;
use
selectors
:
:
OpaqueElement
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
fmt
;
use
std
:
:
fmt
:
:
Write
;
struct
SiblingInfo
<
E
>
where
E
:
TElement
{
affected
:
E
prev_sibling
:
Option
<
E
>
next_sibling
:
Option
<
E
>
}
pub
struct
SiblingTraversalMap
<
E
>
where
E
:
TElement
{
info
:
Option
<
SiblingInfo
<
E
>
>
}
impl
<
E
>
Default
for
SiblingTraversalMap
<
E
>
where
E
:
TElement
{
fn
default
(
)
-
>
Self
{
Self
{
info
:
None
}
}
}
impl
<
E
>
SiblingTraversalMap
<
E
>
where
E
:
TElement
{
pub
fn
new
(
affected
:
E
prev_sibling
:
Option
<
E
>
next_sibling
:
Option
<
E
>
)
-
>
Self
{
Self
{
info
:
Some
(
SiblingInfo
{
affected
prev_sibling
next_sibling
}
)
}
}
pub
fn
next_sibling_for
(
&
self
element
:
&
E
)
-
>
Option
<
E
>
{
if
let
Some
(
ref
info
)
=
self
.
info
{
if
*
element
=
=
info
.
affected
{
return
info
.
next_sibling
;
}
}
element
.
next_sibling_element
(
)
}
pub
fn
prev_sibling_for
(
&
self
element
:
&
E
)
-
>
Option
<
E
>
{
if
let
Some
(
ref
info
)
=
self
.
info
{
if
*
element
=
=
info
.
affected
{
return
info
.
prev_sibling
;
}
}
element
.
prev_sibling_element
(
)
}
}
pub
trait
InvalidationProcessor
<
'
a
'
b
E
>
where
E
:
TElement
{
fn
invalidates_on_pseudo_element
(
&
self
)
-
>
bool
{
false
}
fn
light_tree_only
(
&
self
)
-
>
bool
{
false
}
fn
check_outer_dependency
(
&
mut
self
dependency
:
&
Dependency
element
:
E
)
-
>
bool
;
fn
matching_context
(
&
mut
self
)
-
>
&
mut
MatchingContext
<
'
b
E
:
:
Impl
>
;
fn
sibling_traversal_map
(
&
self
)
-
>
&
SiblingTraversalMap
<
E
>
;
fn
collect_invalidations
(
&
mut
self
element
:
E
self_invalidations
:
&
mut
InvalidationVector
<
'
a
>
descendant_invalidations
:
&
mut
DescendantInvalidationLists
<
'
a
>
sibling_invalidations
:
&
mut
InvalidationVector
<
'
a
>
)
-
>
bool
;
fn
should_process_descendants
(
&
mut
self
element
:
E
)
-
>
bool
;
fn
recursion_limit_exceeded
(
&
mut
self
element
:
E
)
;
fn
invalidated_self
(
&
mut
self
element
:
E
)
;
fn
invalidated_sibling
(
&
mut
self
sibling
:
E
of
:
E
)
;
fn
invalidated_descendants
(
&
mut
self
element
:
E
child
:
E
)
;
fn
found_relative_selector_invalidation
(
&
mut
self
_element
:
E
_kind
:
RelativeDependencyInvalidationKind
_relative_dependency
:
&
'
a
Dependency
)
{
debug_assert
!
(
false
"
Reached
relative
selector
dependency
"
)
;
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
DescendantInvalidationLists
<
'
a
>
{
pub
dom_descendants
:
InvalidationVector
<
'
a
>
pub
slotted_descendants
:
InvalidationVector
<
'
a
>
pub
parts
:
InvalidationVector
<
'
a
>
}
impl
<
'
a
>
DescendantInvalidationLists
<
'
a
>
{
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
dom_descendants
.
is_empty
(
)
&
&
self
.
slotted_descendants
.
is_empty
(
)
&
&
self
.
parts
.
is_empty
(
)
}
}
pub
struct
TreeStyleInvalidator
<
'
a
'
b
'
c
E
P
:
'
a
>
where
'
b
:
'
a
E
:
TElement
P
:
InvalidationProcessor
<
'
b
'
c
E
>
{
element
:
E
stack_limit_checker
:
Option
<
&
'
a
StackLimitChecker
>
processor
:
&
'
a
mut
P
_marker
:
std
:
:
marker
:
:
PhantomData
<
(
&
'
b
(
)
&
'
c
(
)
)
>
}
pub
type
InvalidationVector
<
'
a
>
=
SmallVec
<
[
Invalidation
<
'
a
>
;
10
]
>
;
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
enum
DescendantInvalidationKind
{
Dom
Slotted
Part
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
enum
InvalidationKind
{
Descendant
(
DescendantInvalidationKind
)
Sibling
}
#
[
derive
(
Clone
)
]
pub
struct
Invalidation
<
'
a
>
{
dependency
:
&
'
a
Dependency
scope
:
Option
<
OpaqueElement
>
offset
:
usize
matched_by_any_previous
:
bool
}
impl
<
'
a
>
Invalidation
<
'
a
>
{
pub
fn
new
(
dependency
:
&
'
a
Dependency
scope
:
Option
<
OpaqueElement
>
)
-
>
Self
{
debug_assert
!
(
dependency
.
selector_offset
=
=
dependency
.
selector
.
len
(
)
+
1
|
|
dependency
.
normal_invalidation_kind
(
)
!
=
NormalDependencyInvalidationKind
:
:
Element
"
No
point
to
this
if
the
dependency
matched
the
element
we
should
just
invalidate
it
"
)
;
Self
{
dependency
scope
offset
:
dependency
.
selector
.
len
(
)
+
1
-
dependency
.
selector_offset
matched_by_any_previous
:
false
}
}
fn
effective_for_next
(
&
self
)
-
>
bool
{
if
self
.
offset
=
=
0
{
return
true
;
}
match
self
.
dependency
.
selector
.
combinator_at_parse_order
(
self
.
offset
-
1
)
{
Combinator
:
:
Descendant
|
Combinator
:
:
LaterSibling
|
Combinator
:
:
PseudoElement
=
>
true
Combinator
:
:
Part
|
Combinator
:
:
SlotAssignment
|
Combinator
:
:
NextSibling
|
Combinator
:
:
Child
=
>
false
}
}
fn
kind
(
&
self
)
-
>
InvalidationKind
{
if
self
.
offset
=
=
0
{
return
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Dom
)
;
}
match
self
.
dependency
.
selector
.
combinator_at_parse_order
(
self
.
offset
-
1
)
{
Combinator
:
:
Child
|
Combinator
:
:
Descendant
|
Combinator
:
:
PseudoElement
=
>
{
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Dom
)
}
Combinator
:
:
Part
=
>
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Part
)
Combinator
:
:
SlotAssignment
=
>
{
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Slotted
)
}
Combinator
:
:
NextSibling
|
Combinator
:
:
LaterSibling
=
>
InvalidationKind
:
:
Sibling
}
}
}
impl
<
'
a
>
fmt
:
:
Debug
for
Invalidation
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
use
cssparser
:
:
ToCss
;
f
.
write_str
(
"
Invalidation
(
"
)
?
;
for
component
in
self
.
dependency
.
selector
.
iter_raw_parse_order_from
(
self
.
offset
)
{
if
matches
!
(
*
component
Component
:
:
Combinator
(
.
.
)
)
{
break
;
}
component
.
to_css
(
f
)
?
;
}
f
.
write_char
(
'
)
'
)
}
}
struct
SingleInvalidationResult
{
invalidated_self
:
bool
matched
:
bool
}
pub
struct
InvalidationResult
{
invalidated_self
:
bool
invalidated_descendants
:
bool
invalidated_siblings
:
bool
}
impl
InvalidationResult
{
pub
fn
empty
(
)
-
>
Self
{
Self
{
invalidated_self
:
false
invalidated_descendants
:
false
invalidated_siblings
:
false
}
}
pub
fn
has_invalidated_self
(
&
self
)
-
>
bool
{
self
.
invalidated_self
}
pub
fn
has_invalidated_descendants
(
&
self
)
-
>
bool
{
self
.
invalidated_descendants
}
pub
fn
has_invalidated_siblings
(
&
self
)
-
>
bool
{
self
.
invalidated_siblings
}
}
impl
<
'
a
'
b
'
c
E
P
:
'
a
>
TreeStyleInvalidator
<
'
a
'
b
'
c
E
P
>
where
'
b
:
'
a
E
:
TElement
P
:
InvalidationProcessor
<
'
b
'
c
E
>
{
pub
fn
new
(
element
:
E
stack_limit_checker
:
Option
<
&
'
a
StackLimitChecker
>
processor
:
&
'
a
mut
P
)
-
>
Self
{
Self
{
element
stack_limit_checker
processor
_marker
:
std
:
:
marker
:
:
PhantomData
}
}
pub
fn
invalidate
(
mut
self
)
-
>
InvalidationResult
{
debug
!
(
"
StyleTreeInvalidator
:
:
invalidate
(
{
:
?
}
)
"
self
.
element
)
;
let
mut
self_invalidations
=
InvalidationVector
:
:
new
(
)
;
let
mut
descendant_invalidations
=
DescendantInvalidationLists
:
:
default
(
)
;
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
let
mut
invalidated_self
=
self
.
processor
.
collect_invalidations
(
self
.
element
&
mut
self_invalidations
&
mut
descendant_invalidations
&
mut
sibling_invalidations
)
;
debug
!
(
"
Collected
invalidations
(
self
:
{
}
)
:
"
invalidated_self
)
;
debug
!
(
"
>
self
:
{
}
{
:
?
}
"
self_invalidations
.
len
(
)
self_invalidations
)
;
debug
!
(
"
>
descendants
:
{
:
?
}
"
descendant_invalidations
)
;
debug
!
(
"
>
siblings
:
{
}
{
:
?
}
"
sibling_invalidations
.
len
(
)
sibling_invalidations
)
;
let
invalidated_self_from_collection
=
invalidated_self
;
invalidated_self
|
=
self
.
process_descendant_invalidations
(
&
self_invalidations
&
mut
descendant_invalidations
&
mut
sibling_invalidations
DescendantInvalidationKind
:
:
Dom
)
;
if
invalidated_self
&
&
!
invalidated_self_from_collection
{
self
.
processor
.
invalidated_self
(
self
.
element
)
;
}
let
invalidated_descendants
=
self
.
invalidate_descendants
(
&
descendant_invalidations
)
;
let
invalidated_siblings
=
self
.
invalidate_siblings
(
&
mut
sibling_invalidations
)
;
InvalidationResult
{
invalidated_self
invalidated_descendants
invalidated_siblings
}
}
fn
invalidate_siblings
(
&
mut
self
sibling_invalidations
:
&
mut
InvalidationVector
<
'
b
>
)
-
>
bool
{
if
sibling_invalidations
.
is_empty
(
)
{
return
false
;
}
let
mut
current
=
self
.
processor
.
sibling_traversal_map
(
)
.
next_sibling_for
(
&
self
.
element
)
;
let
mut
any_invalidated
=
false
;
while
let
Some
(
sibling
)
=
current
{
let
mut
sibling_invalidator
=
TreeStyleInvalidator
:
:
new
(
sibling
self
.
stack_limit_checker
self
.
processor
)
;
let
mut
invalidations_for_descendants
=
DescendantInvalidationLists
:
:
default
(
)
;
let
invalidated_sibling
=
sibling_invalidator
.
process_sibling_invalidations
(
&
mut
invalidations_for_descendants
sibling_invalidations
)
;
if
invalidated_sibling
{
sibling_invalidator
.
processor
.
invalidated_sibling
(
sibling
self
.
element
)
;
}
any_invalidated
|
=
invalidated_sibling
;
any_invalidated
|
=
sibling_invalidator
.
invalidate_descendants
(
&
invalidations_for_descendants
)
;
if
sibling_invalidations
.
is_empty
(
)
{
break
;
}
current
=
self
.
processor
.
sibling_traversal_map
(
)
.
next_sibling_for
(
&
sibling
)
;
}
any_invalidated
}
fn
invalidate_pseudo_element_or_nac
(
&
mut
self
child
:
E
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
let
result
=
self
.
invalidate_child
(
child
invalidations
&
mut
sibling_invalidations
DescendantInvalidationKind
:
:
Dom
)
;
result
}
fn
invalidate_child
(
&
mut
self
child
:
E
invalidations
:
&
[
Invalidation
<
'
b
>
]
sibling_invalidations
:
&
mut
InvalidationVector
<
'
b
>
descendant_invalidation_kind
:
DescendantInvalidationKind
)
-
>
bool
{
let
mut
invalidations_for_descendants
=
DescendantInvalidationLists
:
:
default
(
)
;
let
mut
invalidated_child
=
false
;
let
invalidated_descendants
=
{
let
mut
child_invalidator
=
TreeStyleInvalidator
:
:
new
(
child
self
.
stack_limit_checker
self
.
processor
)
;
invalidated_child
|
=
child_invalidator
.
process_sibling_invalidations
(
&
mut
invalidations_for_descendants
sibling_invalidations
)
;
invalidated_child
|
=
child_invalidator
.
process_descendant_invalidations
(
invalidations
&
mut
invalidations_for_descendants
sibling_invalidations
descendant_invalidation_kind
)
;
if
invalidated_child
{
child_invalidator
.
processor
.
invalidated_self
(
child
)
;
}
child_invalidator
.
invalidate_descendants
(
&
invalidations_for_descendants
)
}
;
if
invalidated_child
|
|
invalidated_descendants
{
self
.
processor
.
invalidated_descendants
(
self
.
element
child
)
;
}
invalidated_child
|
|
invalidated_descendants
}
fn
invalidate_nac
(
&
mut
self
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
let
mut
any_nac_root
=
false
;
let
element
=
self
.
element
;
element
.
each_anonymous_content_child
(
|
nac
|
{
any_nac_root
|
=
self
.
invalidate_pseudo_element_or_nac
(
nac
invalidations
)
;
}
)
;
any_nac_root
}
fn
invalidate_dom_descendants_of
(
&
mut
self
parent
:
E
:
:
ConcreteNode
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
let
mut
any_descendant
=
false
;
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
for
child
in
parent
.
dom_children
(
)
{
let
child
=
match
child
.
as_element
(
)
{
Some
(
e
)
=
>
e
None
=
>
continue
}
;
any_descendant
|
=
self
.
invalidate_child
(
child
invalidations
&
mut
sibling_invalidations
DescendantInvalidationKind
:
:
Dom
)
;
}
any_descendant
}
fn
invalidate_parts_in_shadow_tree
(
&
mut
self
shadow
:
<
E
:
:
ConcreteNode
as
TNode
>
:
:
ConcreteShadowRoot
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
debug_assert
!
(
!
invalidations
.
is_empty
(
)
)
;
let
mut
any
=
false
;
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
for
node
in
shadow
.
as_node
(
)
.
dom_descendants
(
)
{
let
element
=
match
node
.
as_element
(
)
{
Some
(
e
)
=
>
e
None
=
>
continue
}
;
if
element
.
has_part_attr
(
)
{
any
|
=
self
.
invalidate_child
(
element
invalidations
&
mut
sibling_invalidations
DescendantInvalidationKind
:
:
Part
)
;
debug_assert
!
(
sibling_invalidations
.
is_empty
(
)
"
:
:
part
(
)
shouldn
'
t
have
sibling
combinators
to
the
right
\
this
makes
no
sense
!
{
:
?
}
"
sibling_invalidations
)
;
}
if
let
Some
(
shadow
)
=
element
.
shadow_root
(
)
{
if
element
.
exports_any_part
(
)
{
any
|
=
self
.
invalidate_parts_in_shadow_tree
(
shadow
invalidations
)
}
}
}
any
}
fn
invalidate_parts
(
&
mut
self
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
if
invalidations
.
is_empty
(
)
{
return
false
;
}
let
shadow
=
match
self
.
element
.
shadow_root
(
)
{
Some
(
s
)
=
>
s
None
=
>
return
false
}
;
self
.
invalidate_parts_in_shadow_tree
(
shadow
invalidations
)
}
fn
invalidate_slotted_elements
(
&
mut
self
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
if
invalidations
.
is_empty
(
)
{
return
false
;
}
let
slot
=
self
.
element
;
self
.
invalidate_slotted_elements_in_slot
(
slot
invalidations
)
}
fn
invalidate_slotted_elements_in_slot
(
&
mut
self
slot
:
E
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
let
mut
any
=
false
;
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
for
node
in
slot
.
slotted_nodes
(
)
{
let
element
=
match
node
.
as_element
(
)
{
Some
(
e
)
=
>
e
None
=
>
continue
}
;
if
element
.
is_html_slot_element
(
)
{
any
|
=
self
.
invalidate_slotted_elements_in_slot
(
element
invalidations
)
;
}
else
{
any
|
=
self
.
invalidate_child
(
element
invalidations
&
mut
sibling_invalidations
DescendantInvalidationKind
:
:
Slotted
)
;
}
debug_assert
!
(
sibling_invalidations
.
is_empty
(
)
"
:
:
slotted
(
)
shouldn
'
t
have
sibling
combinators
to
the
right
\
this
makes
no
sense
!
{
:
?
}
"
sibling_invalidations
)
;
}
any
}
fn
invalidate_non_slotted_descendants
(
&
mut
self
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
if
invalidations
.
is_empty
(
)
{
return
false
;
}
if
self
.
processor
.
light_tree_only
(
)
{
let
node
=
self
.
element
.
as_node
(
)
;
return
self
.
invalidate_dom_descendants_of
(
node
invalidations
)
;
}
let
mut
any_descendant
=
false
;
if
let
Some
(
root
)
=
self
.
element
.
shadow_root
(
)
{
any_descendant
|
=
self
.
invalidate_dom_descendants_of
(
root
.
as_node
(
)
invalidations
)
;
}
any_descendant
|
=
self
.
invalidate_dom_descendants_of
(
self
.
element
.
as_node
(
)
invalidations
)
;
any_descendant
|
=
self
.
invalidate_nac
(
invalidations
)
;
any_descendant
}
fn
invalidate_descendants
(
&
mut
self
invalidations
:
&
DescendantInvalidationLists
<
'
b
>
)
-
>
bool
{
if
invalidations
.
is_empty
(
)
{
return
false
;
}
debug
!
(
"
StyleTreeInvalidator
:
:
invalidate_descendants
(
{
:
?
}
)
"
self
.
element
)
;
debug
!
(
"
>
{
:
?
}
"
invalidations
)
;
let
should_process
=
self
.
processor
.
should_process_descendants
(
self
.
element
)
;
if
!
should_process
{
return
false
;
}
if
let
Some
(
checker
)
=
self
.
stack_limit_checker
{
if
checker
.
limit_exceeded
(
)
{
self
.
processor
.
recursion_limit_exceeded
(
self
.
element
)
;
return
true
;
}
}
let
mut
any_descendant
=
false
;
any_descendant
|
=
self
.
invalidate_non_slotted_descendants
(
&
invalidations
.
dom_descendants
)
;
any_descendant
|
=
self
.
invalidate_slotted_elements
(
&
invalidations
.
slotted_descendants
)
;
any_descendant
|
=
self
.
invalidate_parts
(
&
invalidations
.
parts
)
;
any_descendant
}
fn
process_sibling_invalidations
(
&
mut
self
descendant_invalidations
:
&
mut
DescendantInvalidationLists
<
'
b
>
sibling_invalidations
:
&
mut
InvalidationVector
<
'
b
>
)
-
>
bool
{
let
mut
i
=
0
;
let
mut
new_sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
let
mut
invalidated_self
=
false
;
while
i
<
sibling_invalidations
.
len
(
)
{
let
result
=
self
.
process_invalidation
(
&
sibling_invalidations
[
i
]
descendant_invalidations
&
mut
new_sibling_invalidations
InvalidationKind
:
:
Sibling
)
;
invalidated_self
|
=
result
.
invalidated_self
;
sibling_invalidations
[
i
]
.
matched_by_any_previous
|
=
result
.
matched
;
if
sibling_invalidations
[
i
]
.
effective_for_next
(
)
{
i
+
=
1
;
}
else
{
sibling_invalidations
.
remove
(
i
)
;
}
}
sibling_invalidations
.
extend
(
new_sibling_invalidations
.
drain
(
.
.
)
)
;
invalidated_self
}
fn
process_descendant_invalidations
(
&
mut
self
invalidations
:
&
[
Invalidation
<
'
b
>
]
descendant_invalidations
:
&
mut
DescendantInvalidationLists
<
'
b
>
sibling_invalidations
:
&
mut
InvalidationVector
<
'
b
>
descendant_invalidation_kind
:
DescendantInvalidationKind
)
-
>
bool
{
let
mut
invalidated
=
false
;
for
invalidation
in
invalidations
{
let
result
=
self
.
process_invalidation
(
invalidation
descendant_invalidations
sibling_invalidations
InvalidationKind
:
:
Descendant
(
descendant_invalidation_kind
)
)
;
invalidated
|
=
result
.
invalidated_self
;
if
invalidation
.
effective_for_next
(
)
{
let
mut
invalidation
=
invalidation
.
clone
(
)
;
invalidation
.
matched_by_any_previous
|
=
result
.
matched
;
debug_assert_eq
!
(
descendant_invalidation_kind
DescendantInvalidationKind
:
:
Dom
"
Slotted
or
part
invalidations
don
'
t
propagate
.
"
)
;
descendant_invalidations
.
dom_descendants
.
push
(
invalidation
)
;
}
}
invalidated
}
fn
process_invalidation
(
&
mut
self
invalidation
:
&
Invalidation
<
'
b
>
descendant_invalidations
:
&
mut
DescendantInvalidationLists
<
'
b
>
sibling_invalidations
:
&
mut
InvalidationVector
<
'
b
>
invalidation_kind
:
InvalidationKind
)
-
>
SingleInvalidationResult
{
debug
!
(
"
TreeStyleInvalidator
:
:
process_invalidation
(
{
:
?
}
{
:
?
}
{
:
?
}
)
"
self
.
element
invalidation
invalidation_kind
)
;
let
matching_result
=
{
let
context
=
self
.
processor
.
matching_context
(
)
;
context
.
current_host
=
invalidation
.
scope
;
matches_compound_selector_from
(
&
invalidation
.
dependency
.
selector
invalidation
.
offset
context
&
self
.
element
)
}
;
let
next_invalidation
=
match
matching_result
{
CompoundSelectorMatchingResult
:
:
NotMatched
=
>
{
return
SingleInvalidationResult
{
invalidated_self
:
false
matched
:
false
}
}
CompoundSelectorMatchingResult
:
:
FullyMatched
=
>
{
debug
!
(
"
>
Invalidation
matched
completely
"
)
;
let
mut
cur_dependency
=
invalidation
.
dependency
;
loop
{
cur_dependency
=
match
cur_dependency
.
next
{
None
=
>
{
return
SingleInvalidationResult
{
invalidated_self
:
true
matched
:
true
}
}
Some
(
ref
deps
)
=
>
{
let
n
=
&
deps
.
as_ref
(
)
.
slice
(
)
[
0
]
;
let
invalidation_kind
=
n
.
invalidation_kind
(
)
;
match
invalidation_kind
{
DependencyInvalidationKind
:
:
FullSelector
=
>
unreachable
!
(
)
DependencyInvalidationKind
:
:
Normal
(
_
)
=
>
n
DependencyInvalidationKind
:
:
Relative
(
kind
)
=
>
{
self
.
processor
.
found_relative_selector_invalidation
(
self
.
element
kind
n
)
;
return
SingleInvalidationResult
{
invalidated_self
:
false
matched
:
true
}
;
}
}
}
}
;
debug
!
(
"
>
Checking
outer
dependency
{
:
?
}
"
cur_dependency
)
;
if
!
self
.
processor
.
check_outer_dependency
(
cur_dependency
self
.
element
)
{
return
SingleInvalidationResult
{
invalidated_self
:
false
matched
:
false
}
;
}
if
cur_dependency
.
normal_invalidation_kind
(
)
=
=
NormalDependencyInvalidationKind
:
:
Element
{
continue
;
}
debug
!
(
"
>
Generating
invalidation
"
)
;
break
Invalidation
:
:
new
(
cur_dependency
invalidation
.
scope
)
;
}
}
CompoundSelectorMatchingResult
:
:
Matched
{
next_combinator_offset
}
=
>
Invalidation
{
dependency
:
invalidation
.
dependency
scope
:
invalidation
.
scope
offset
:
next_combinator_offset
+
1
matched_by_any_previous
:
false
}
}
;
debug_assert_ne
!
(
next_invalidation
.
offset
0
"
Rightmost
selectors
shouldn
'
t
generate
more
invalidations
"
)
;
let
mut
invalidated_self
=
false
;
let
next_combinator
=
next_invalidation
.
dependency
.
selector
.
combinator_at_parse_order
(
next_invalidation
.
offset
-
1
)
;
if
matches
!
(
next_combinator
Combinator
:
:
PseudoElement
)
&
&
self
.
processor
.
invalidates_on_pseudo_element
(
)
{
invalidated_self
=
true
;
}
debug
!
(
"
>
Invalidation
matched
next
:
{
:
?
}
(
{
:
?
}
)
"
next_invalidation
next_combinator
)
;
let
next_invalidation_kind
=
next_invalidation
.
kind
(
)
;
let
can_skip_pushing
=
next_invalidation_kind
=
=
invalidation_kind
&
&
invalidation
.
matched_by_any_previous
&
&
next_invalidation
.
effective_for_next
(
)
;
if
can_skip_pushing
{
debug
!
(
"
>
Can
avoid
push
since
the
invalidation
had
\
already
been
matched
before
"
)
;
}
else
{
match
next_invalidation_kind
{
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Dom
)
=
>
{
descendant_invalidations
.
dom_descendants
.
push
(
next_invalidation
)
;
}
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Part
)
=
>
{
descendant_invalidations
.
parts
.
push
(
next_invalidation
)
;
}
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Slotted
)
=
>
{
descendant_invalidations
.
slotted_descendants
.
push
(
next_invalidation
)
;
}
InvalidationKind
:
:
Sibling
=
>
{
sibling_invalidations
.
push
(
next_invalidation
)
;
}
}
}
SingleInvalidationResult
{
invalidated_self
matched
:
true
}
}
}
