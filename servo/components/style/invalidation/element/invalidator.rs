use
crate
:
:
context
:
:
StackLimitChecker
;
use
crate
:
:
dom
:
:
{
TElement
TNode
TShadowRoot
}
;
use
crate
:
:
selector_parser
:
:
SelectorImpl
;
use
selectors
:
:
OpaqueElement
;
use
selectors
:
:
matching
:
:
matches_compound_selector_from
;
use
selectors
:
:
matching
:
:
{
CompoundSelectorMatchingResult
MatchingContext
}
;
use
selectors
:
:
parser
:
:
{
Combinator
Component
Selector
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
fmt
;
pub
trait
InvalidationProcessor
<
'
a
E
>
where
E
:
TElement
{
fn
invalidates_on_eager_pseudo_element
(
&
self
)
-
>
bool
{
false
}
fn
light_tree_only
(
&
self
)
-
>
bool
{
false
}
fn
matching_context
(
&
mut
self
)
-
>
&
mut
MatchingContext
<
'
a
E
:
:
Impl
>
;
fn
collect_invalidations
(
&
mut
self
element
:
E
self_invalidations
:
&
mut
InvalidationVector
<
'
a
>
descendant_invalidations
:
&
mut
DescendantInvalidationLists
<
'
a
>
sibling_invalidations
:
&
mut
InvalidationVector
<
'
a
>
)
-
>
bool
;
fn
should_process_descendants
(
&
mut
self
element
:
E
)
-
>
bool
;
fn
recursion_limit_exceeded
(
&
mut
self
element
:
E
)
;
fn
invalidated_self
(
&
mut
self
element
:
E
)
;
fn
invalidated_descendants
(
&
mut
self
element
:
E
child
:
E
)
;
}
#
[
derive
(
Debug
Default
)
]
pub
struct
DescendantInvalidationLists
<
'
a
>
{
pub
dom_descendants
:
InvalidationVector
<
'
a
>
pub
slotted_descendants
:
InvalidationVector
<
'
a
>
pub
parts
:
InvalidationVector
<
'
a
>
}
impl
<
'
a
>
DescendantInvalidationLists
<
'
a
>
{
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
dom_descendants
.
is_empty
(
)
&
&
self
.
slotted_descendants
.
is_empty
(
)
&
&
self
.
parts
.
is_empty
(
)
}
}
pub
struct
TreeStyleInvalidator
<
'
a
'
b
E
P
:
'
a
>
where
'
b
:
'
a
E
:
TElement
P
:
InvalidationProcessor
<
'
b
E
>
{
element
:
E
stack_limit_checker
:
Option
<
&
'
a
StackLimitChecker
>
processor
:
&
'
a
mut
P
_marker
:
:
:
std
:
:
marker
:
:
PhantomData
<
&
'
b
(
)
>
}
pub
type
InvalidationVector
<
'
a
>
=
SmallVec
<
[
Invalidation
<
'
a
>
;
10
]
>
;
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
enum
DescendantInvalidationKind
{
Dom
Slotted
Part
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
enum
InvalidationKind
{
Descendant
(
DescendantInvalidationKind
)
Sibling
}
#
[
derive
(
Clone
)
]
pub
struct
Invalidation
<
'
a
>
{
selector
:
&
'
a
Selector
<
SelectorImpl
>
scope
:
Option
<
OpaqueElement
>
offset
:
usize
matched_by_any_previous
:
bool
}
impl
<
'
a
>
Invalidation
<
'
a
>
{
pub
fn
new
(
selector
:
&
'
a
Selector
<
SelectorImpl
>
scope
:
Option
<
OpaqueElement
>
offset
:
usize
)
-
>
Self
{
Self
{
selector
scope
offset
matched_by_any_previous
:
false
}
}
fn
effective_for_next
(
&
self
)
-
>
bool
{
if
self
.
offset
=
=
0
{
return
true
;
}
match
self
.
selector
.
combinator_at_parse_order
(
self
.
offset
-
1
)
{
Combinator
:
:
Descendant
|
Combinator
:
:
LaterSibling
|
Combinator
:
:
PseudoElement
=
>
true
Combinator
:
:
Part
|
Combinator
:
:
SlotAssignment
|
Combinator
:
:
NextSibling
|
Combinator
:
:
Child
=
>
false
}
}
fn
kind
(
&
self
)
-
>
InvalidationKind
{
if
self
.
offset
=
=
0
{
return
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Dom
)
;
}
match
self
.
selector
.
combinator_at_parse_order
(
self
.
offset
-
1
)
{
Combinator
:
:
Child
|
Combinator
:
:
Descendant
|
Combinator
:
:
PseudoElement
=
>
{
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Dom
)
}
Combinator
:
:
Part
=
>
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Part
)
Combinator
:
:
SlotAssignment
=
>
{
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Slotted
)
}
Combinator
:
:
NextSibling
|
Combinator
:
:
LaterSibling
=
>
InvalidationKind
:
:
Sibling
}
}
}
impl
<
'
a
>
fmt
:
:
Debug
for
Invalidation
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
use
cssparser
:
:
ToCss
;
f
.
write_str
(
"
Invalidation
(
"
)
?
;
for
component
in
self
.
selector
.
iter_raw_parse_order_from
(
self
.
offset
)
{
if
matches
!
(
*
component
Component
:
:
Combinator
(
.
.
)
)
{
break
;
}
component
.
to_css
(
f
)
?
;
}
f
.
write_str
(
"
)
"
)
}
}
struct
SingleInvalidationResult
{
invalidated_self
:
bool
matched
:
bool
}
pub
struct
InvalidationResult
{
invalidated_self
:
bool
invalidated_descendants
:
bool
invalidated_siblings
:
bool
}
impl
InvalidationResult
{
pub
fn
empty
(
)
-
>
Self
{
Self
{
invalidated_self
:
false
invalidated_descendants
:
false
invalidated_siblings
:
false
}
}
pub
fn
has_invalidated_self
(
&
self
)
-
>
bool
{
self
.
invalidated_self
}
pub
fn
has_invalidated_descendants
(
&
self
)
-
>
bool
{
self
.
invalidated_descendants
}
pub
fn
has_invalidated_siblings
(
&
self
)
-
>
bool
{
self
.
invalidated_siblings
}
}
impl
<
'
a
'
b
E
P
:
'
a
>
TreeStyleInvalidator
<
'
a
'
b
E
P
>
where
'
b
:
'
a
E
:
TElement
P
:
InvalidationProcessor
<
'
b
E
>
{
pub
fn
new
(
element
:
E
stack_limit_checker
:
Option
<
&
'
a
StackLimitChecker
>
processor
:
&
'
a
mut
P
)
-
>
Self
{
Self
{
element
stack_limit_checker
processor
_marker
:
:
:
std
:
:
marker
:
:
PhantomData
}
}
pub
fn
invalidate
(
mut
self
)
-
>
InvalidationResult
{
debug
!
(
"
StyleTreeInvalidator
:
:
invalidate
(
{
:
?
}
)
"
self
.
element
)
;
let
mut
self_invalidations
=
InvalidationVector
:
:
new
(
)
;
let
mut
descendant_invalidations
=
DescendantInvalidationLists
:
:
default
(
)
;
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
let
mut
invalidated_self
=
self
.
processor
.
collect_invalidations
(
self
.
element
&
mut
self_invalidations
&
mut
descendant_invalidations
&
mut
sibling_invalidations
)
;
debug
!
(
"
Collected
invalidations
(
self
:
{
}
)
:
"
invalidated_self
)
;
debug
!
(
"
>
self
:
{
}
{
:
?
}
"
self_invalidations
.
len
(
)
self_invalidations
)
;
debug
!
(
"
>
descendants
:
{
:
?
}
"
descendant_invalidations
)
;
debug
!
(
"
>
siblings
:
{
}
{
:
?
}
"
sibling_invalidations
.
len
(
)
sibling_invalidations
)
;
let
invalidated_self_from_collection
=
invalidated_self
;
invalidated_self
|
=
self
.
process_descendant_invalidations
(
&
self_invalidations
&
mut
descendant_invalidations
&
mut
sibling_invalidations
DescendantInvalidationKind
:
:
Dom
)
;
if
invalidated_self
&
&
!
invalidated_self_from_collection
{
self
.
processor
.
invalidated_self
(
self
.
element
)
;
}
let
invalidated_descendants
=
self
.
invalidate_descendants
(
&
descendant_invalidations
)
;
let
invalidated_siblings
=
self
.
invalidate_siblings
(
&
mut
sibling_invalidations
)
;
InvalidationResult
{
invalidated_self
invalidated_descendants
invalidated_siblings
}
}
fn
invalidate_siblings
(
&
mut
self
sibling_invalidations
:
&
mut
InvalidationVector
<
'
b
>
)
-
>
bool
{
if
sibling_invalidations
.
is_empty
(
)
{
return
false
;
}
let
mut
current
=
self
.
element
.
next_sibling_element
(
)
;
let
mut
any_invalidated
=
false
;
while
let
Some
(
sibling
)
=
current
{
let
mut
sibling_invalidator
=
TreeStyleInvalidator
:
:
new
(
sibling
self
.
stack_limit_checker
self
.
processor
)
;
let
mut
invalidations_for_descendants
=
DescendantInvalidationLists
:
:
default
(
)
;
let
invalidated_sibling
=
sibling_invalidator
.
process_sibling_invalidations
(
&
mut
invalidations_for_descendants
sibling_invalidations
)
;
if
invalidated_sibling
{
sibling_invalidator
.
processor
.
invalidated_self
(
sibling
)
;
}
any_invalidated
|
=
invalidated_sibling
;
any_invalidated
|
=
sibling_invalidator
.
invalidate_descendants
(
&
invalidations_for_descendants
)
;
if
sibling_invalidations
.
is_empty
(
)
{
break
;
}
current
=
sibling
.
next_sibling_element
(
)
;
}
any_invalidated
}
fn
invalidate_pseudo_element_or_nac
(
&
mut
self
child
:
E
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
let
result
=
self
.
invalidate_child
(
child
invalidations
&
mut
sibling_invalidations
DescendantInvalidationKind
:
:
Dom
)
;
result
}
fn
invalidate_child
(
&
mut
self
child
:
E
invalidations
:
&
[
Invalidation
<
'
b
>
]
sibling_invalidations
:
&
mut
InvalidationVector
<
'
b
>
descendant_invalidation_kind
:
DescendantInvalidationKind
)
-
>
bool
{
let
mut
invalidations_for_descendants
=
DescendantInvalidationLists
:
:
default
(
)
;
let
mut
invalidated_child
=
false
;
let
invalidated_descendants
=
{
let
mut
child_invalidator
=
TreeStyleInvalidator
:
:
new
(
child
self
.
stack_limit_checker
self
.
processor
)
;
invalidated_child
|
=
child_invalidator
.
process_sibling_invalidations
(
&
mut
invalidations_for_descendants
sibling_invalidations
)
;
invalidated_child
|
=
child_invalidator
.
process_descendant_invalidations
(
invalidations
&
mut
invalidations_for_descendants
sibling_invalidations
descendant_invalidation_kind
)
;
if
invalidated_child
{
child_invalidator
.
processor
.
invalidated_self
(
child
)
;
}
child_invalidator
.
invalidate_descendants
(
&
invalidations_for_descendants
)
}
;
if
invalidated_child
|
|
invalidated_descendants
{
self
.
processor
.
invalidated_descendants
(
self
.
element
child
)
;
}
invalidated_child
|
|
invalidated_descendants
}
fn
invalidate_nac
(
&
mut
self
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
let
mut
any_nac_root
=
false
;
let
element
=
self
.
element
;
element
.
each_anonymous_content_child
(
|
nac
|
{
any_nac_root
|
=
self
.
invalidate_pseudo_element_or_nac
(
nac
invalidations
)
;
}
)
;
any_nac_root
}
fn
invalidate_dom_descendants_of
(
&
mut
self
parent
:
E
:
:
ConcreteNode
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
let
mut
any_descendant
=
false
;
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
for
child
in
parent
.
dom_children
(
)
{
let
child
=
match
child
.
as_element
(
)
{
Some
(
e
)
=
>
e
None
=
>
continue
}
;
any_descendant
|
=
self
.
invalidate_child
(
child
invalidations
&
mut
sibling_invalidations
DescendantInvalidationKind
:
:
Dom
)
;
}
any_descendant
}
fn
invalidate_parts_in_shadow_tree
(
&
mut
self
shadow
:
<
E
:
:
ConcreteNode
as
TNode
>
:
:
ConcreteShadowRoot
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
debug_assert
!
(
!
invalidations
.
is_empty
(
)
)
;
let
mut
any
=
false
;
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
for
node
in
shadow
.
as_node
(
)
.
dom_descendants
(
)
{
let
element
=
match
node
.
as_element
(
)
{
Some
(
e
)
=
>
e
None
=
>
continue
}
;
if
element
.
has_part_attr
(
)
{
any
|
=
self
.
invalidate_child
(
element
invalidations
&
mut
sibling_invalidations
DescendantInvalidationKind
:
:
Part
)
;
debug_assert
!
(
sibling_invalidations
.
is_empty
(
)
"
:
:
part
(
)
shouldn
'
t
have
sibling
combinators
to
the
right
\
this
makes
no
sense
!
{
:
?
}
"
sibling_invalidations
)
;
}
if
let
Some
(
shadow
)
=
element
.
shadow_root
(
)
{
if
element
.
exports_any_part
(
)
{
any
|
=
self
.
invalidate_parts_in_shadow_tree
(
shadow
invalidations
)
}
}
}
any
}
fn
invalidate_parts
(
&
mut
self
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
if
invalidations
.
is_empty
(
)
{
return
false
;
}
let
shadow
=
match
self
.
element
.
shadow_root
(
)
{
Some
(
s
)
=
>
s
None
=
>
return
false
}
;
self
.
invalidate_parts_in_shadow_tree
(
shadow
invalidations
)
}
fn
invalidate_slotted_elements
(
&
mut
self
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
if
invalidations
.
is_empty
(
)
{
return
false
;
}
let
slot
=
self
.
element
;
self
.
invalidate_slotted_elements_in_slot
(
slot
invalidations
)
}
fn
invalidate_slotted_elements_in_slot
(
&
mut
self
slot
:
E
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
let
mut
any
=
false
;
let
mut
sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
for
node
in
slot
.
slotted_nodes
(
)
{
let
element
=
match
node
.
as_element
(
)
{
Some
(
e
)
=
>
e
None
=
>
continue
}
;
if
element
.
is_html_slot_element
(
)
{
any
|
=
self
.
invalidate_slotted_elements_in_slot
(
element
invalidations
)
;
}
else
{
any
|
=
self
.
invalidate_child
(
element
invalidations
&
mut
sibling_invalidations
DescendantInvalidationKind
:
:
Slotted
)
;
}
debug_assert
!
(
sibling_invalidations
.
is_empty
(
)
"
:
:
slotted
(
)
shouldn
'
t
have
sibling
combinators
to
the
right
\
this
makes
no
sense
!
{
:
?
}
"
sibling_invalidations
)
;
}
any
}
fn
invalidate_non_slotted_descendants
(
&
mut
self
invalidations
:
&
[
Invalidation
<
'
b
>
]
)
-
>
bool
{
if
invalidations
.
is_empty
(
)
{
return
false
;
}
if
self
.
processor
.
light_tree_only
(
)
{
let
node
=
self
.
element
.
as_node
(
)
;
return
self
.
invalidate_dom_descendants_of
(
node
invalidations
)
;
}
let
mut
any_descendant
=
false
;
if
let
Some
(
root
)
=
self
.
element
.
shadow_root
(
)
{
any_descendant
|
=
self
.
invalidate_dom_descendants_of
(
root
.
as_node
(
)
invalidations
)
;
}
if
let
Some
(
marker
)
=
self
.
element
.
marker_pseudo_element
(
)
{
any_descendant
|
=
self
.
invalidate_pseudo_element_or_nac
(
marker
invalidations
)
;
}
if
let
Some
(
before
)
=
self
.
element
.
before_pseudo_element
(
)
{
any_descendant
|
=
self
.
invalidate_pseudo_element_or_nac
(
before
invalidations
)
;
}
let
node
=
self
.
element
.
as_node
(
)
;
any_descendant
|
=
self
.
invalidate_dom_descendants_of
(
node
invalidations
)
;
if
let
Some
(
after
)
=
self
.
element
.
after_pseudo_element
(
)
{
any_descendant
|
=
self
.
invalidate_pseudo_element_or_nac
(
after
invalidations
)
;
}
any_descendant
|
=
self
.
invalidate_nac
(
invalidations
)
;
any_descendant
}
fn
invalidate_descendants
(
&
mut
self
invalidations
:
&
DescendantInvalidationLists
<
'
b
>
)
-
>
bool
{
if
invalidations
.
is_empty
(
)
{
return
false
;
}
debug
!
(
"
StyleTreeInvalidator
:
:
invalidate_descendants
(
{
:
?
}
)
"
self
.
element
)
;
debug
!
(
"
>
{
:
?
}
"
invalidations
)
;
let
should_process
=
self
.
processor
.
should_process_descendants
(
self
.
element
)
;
if
!
should_process
{
return
false
;
}
if
let
Some
(
checker
)
=
self
.
stack_limit_checker
{
if
checker
.
limit_exceeded
(
)
{
self
.
processor
.
recursion_limit_exceeded
(
self
.
element
)
;
return
true
;
}
}
let
mut
any_descendant
=
false
;
any_descendant
|
=
self
.
invalidate_non_slotted_descendants
(
&
invalidations
.
dom_descendants
)
;
any_descendant
|
=
self
.
invalidate_slotted_elements
(
&
invalidations
.
slotted_descendants
)
;
any_descendant
|
=
self
.
invalidate_parts
(
&
invalidations
.
parts
)
;
any_descendant
}
fn
process_sibling_invalidations
(
&
mut
self
descendant_invalidations
:
&
mut
DescendantInvalidationLists
<
'
b
>
sibling_invalidations
:
&
mut
InvalidationVector
<
'
b
>
)
-
>
bool
{
let
mut
i
=
0
;
let
mut
new_sibling_invalidations
=
InvalidationVector
:
:
new
(
)
;
let
mut
invalidated_self
=
false
;
while
i
<
sibling_invalidations
.
len
(
)
{
let
result
=
self
.
process_invalidation
(
&
sibling_invalidations
[
i
]
descendant_invalidations
&
mut
new_sibling_invalidations
InvalidationKind
:
:
Sibling
)
;
invalidated_self
|
=
result
.
invalidated_self
;
sibling_invalidations
[
i
]
.
matched_by_any_previous
|
=
result
.
matched
;
if
sibling_invalidations
[
i
]
.
effective_for_next
(
)
{
i
+
=
1
;
}
else
{
sibling_invalidations
.
remove
(
i
)
;
}
}
sibling_invalidations
.
extend
(
new_sibling_invalidations
.
drain
(
)
)
;
invalidated_self
}
fn
process_descendant_invalidations
(
&
mut
self
invalidations
:
&
[
Invalidation
<
'
b
>
]
descendant_invalidations
:
&
mut
DescendantInvalidationLists
<
'
b
>
sibling_invalidations
:
&
mut
InvalidationVector
<
'
b
>
descendant_invalidation_kind
:
DescendantInvalidationKind
)
-
>
bool
{
let
mut
invalidated
=
false
;
for
invalidation
in
invalidations
{
let
result
=
self
.
process_invalidation
(
invalidation
descendant_invalidations
sibling_invalidations
InvalidationKind
:
:
Descendant
(
descendant_invalidation_kind
)
)
;
invalidated
|
=
result
.
invalidated_self
;
if
invalidation
.
effective_for_next
(
)
{
let
mut
invalidation
=
invalidation
.
clone
(
)
;
invalidation
.
matched_by_any_previous
|
=
result
.
matched
;
debug_assert_eq
!
(
descendant_invalidation_kind
DescendantInvalidationKind
:
:
Dom
"
Slotted
or
part
invalidations
don
'
t
propagate
.
"
)
;
descendant_invalidations
.
dom_descendants
.
push
(
invalidation
)
;
}
}
invalidated
}
fn
process_invalidation
(
&
mut
self
invalidation
:
&
Invalidation
<
'
b
>
descendant_invalidations
:
&
mut
DescendantInvalidationLists
<
'
b
>
sibling_invalidations
:
&
mut
InvalidationVector
<
'
b
>
invalidation_kind
:
InvalidationKind
)
-
>
SingleInvalidationResult
{
debug
!
(
"
TreeStyleInvalidator
:
:
process_invalidation
(
{
:
?
}
{
:
?
}
{
:
?
}
)
"
self
.
element
invalidation
invalidation_kind
)
;
let
matching_result
=
{
let
context
=
self
.
processor
.
matching_context
(
)
;
context
.
current_host
=
invalidation
.
scope
;
matches_compound_selector_from
(
&
invalidation
.
selector
invalidation
.
offset
context
&
self
.
element
)
}
;
let
mut
invalidated_self
=
false
;
let
mut
matched
=
false
;
match
matching_result
{
CompoundSelectorMatchingResult
:
:
FullyMatched
=
>
{
debug
!
(
"
>
Invalidation
matched
completely
"
)
;
matched
=
true
;
invalidated_self
=
true
;
}
CompoundSelectorMatchingResult
:
:
Matched
{
next_combinator_offset
}
=
>
{
let
next_combinator
=
invalidation
.
selector
.
combinator_at_parse_order
(
next_combinator_offset
)
;
matched
=
true
;
if
matches
!
(
next_combinator
Combinator
:
:
PseudoElement
)
{
let
pseudo_selector
=
invalidation
.
selector
.
iter_raw_parse_order_from
(
next_combinator_offset
+
1
)
.
skip_while
(
|
c
|
matches
!
(
*
*
c
Component
:
:
NonTSPseudoClass
(
.
.
)
)
)
.
next
(
)
.
unwrap
(
)
;
let
pseudo
=
match
*
pseudo_selector
{
Component
:
:
PseudoElement
(
ref
pseudo
)
=
>
pseudo
_
=
>
unreachable
!
(
"
Someone
seriously
messed
up
selector
parsing
:
\
{
:
?
}
at
offset
{
:
?
}
:
{
:
?
}
"
invalidation
.
selector
next_combinator_offset
pseudo_selector
)
}
;
if
self
.
processor
.
invalidates_on_eager_pseudo_element
(
)
{
if
pseudo
.
is_eager
(
)
{
invalidated_self
=
true
;
}
if
pseudo
.
is_marker
(
)
&
&
self
.
element
.
marker_pseudo_element
(
)
.
is_none
(
)
{
invalidated_self
=
true
;
}
if
pseudo
.
is_selection
(
)
{
invalidated_self
=
true
;
}
}
}
let
next_invalidation
=
Invalidation
{
selector
:
invalidation
.
selector
scope
:
invalidation
.
scope
offset
:
next_combinator_offset
+
1
matched_by_any_previous
:
false
}
;
debug
!
(
"
>
Invalidation
matched
next
:
{
:
?
}
(
{
:
?
}
)
"
next_invalidation
next_combinator
)
;
let
next_invalidation_kind
=
next_invalidation
.
kind
(
)
;
let
can_skip_pushing
=
next_invalidation_kind
=
=
invalidation_kind
&
&
invalidation
.
matched_by_any_previous
&
&
next_invalidation
.
effective_for_next
(
)
;
if
can_skip_pushing
{
debug
!
(
"
>
Can
avoid
push
since
the
invalidation
had
\
already
been
matched
before
"
)
;
}
else
{
match
next_invalidation_kind
{
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Dom
)
=
>
{
descendant_invalidations
.
dom_descendants
.
push
(
next_invalidation
)
;
}
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Part
)
=
>
{
descendant_invalidations
.
parts
.
push
(
next_invalidation
)
;
}
InvalidationKind
:
:
Descendant
(
DescendantInvalidationKind
:
:
Slotted
)
=
>
{
descendant_invalidations
.
slotted_descendants
.
push
(
next_invalidation
)
;
}
InvalidationKind
:
:
Sibling
=
>
{
sibling_invalidations
.
push
(
next_invalidation
)
;
}
}
}
}
CompoundSelectorMatchingResult
:
:
NotMatched
=
>
{
}
}
SingleInvalidationResult
{
invalidated_self
matched
}
}
}
