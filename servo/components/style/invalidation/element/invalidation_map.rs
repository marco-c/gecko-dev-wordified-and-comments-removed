use
{
Atom
LocalName
Namespace
}
;
use
context
:
:
QuirksMode
;
use
element_state
:
:
{
DocumentState
ElementState
}
;
use
fallible
:
:
FallibleVec
;
use
hashglobe
:
:
FailedAllocationError
;
use
selector_map
:
:
{
MaybeCaseInsensitiveHashMap
SelectorMap
SelectorMapEntry
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
selector_parser
:
:
Direction
;
use
selector_parser
:
:
SelectorImpl
;
use
selectors
:
:
attr
:
:
NamespaceConstraint
;
use
selectors
:
:
parser
:
:
{
Combinator
Component
}
;
use
selectors
:
:
parser
:
:
{
Selector
SelectorIter
Visit
}
;
use
selectors
:
:
visitor
:
:
SelectorVisitor
;
use
smallvec
:
:
SmallVec
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
dir_selector_to_state
(
dir
:
&
Direction
)
-
>
ElementState
{
match
*
dir
{
Direction
:
:
Ltr
=
>
ElementState
:
:
IN_LTR_STATE
Direction
:
:
Rtl
=
>
ElementState
:
:
IN_RTL_STATE
Direction
:
:
Other
(
_
)
=
>
{
ElementState
:
:
empty
(
)
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
Dependency
{
#
[
cfg_attr
(
feature
=
"
gecko
"
ignore_malloc_size_of
=
"
CssRules
have
primary
refs
we
measure
there
"
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
Arc
"
)
]
pub
selector
:
Selector
<
SelectorImpl
>
pub
selector_offset
:
usize
}
#
[
derive
(
Debug
Eq
PartialEq
)
]
pub
enum
DependencyInvalidationKind
{
Element
ElementAndDescendants
Descendants
Siblings
SlottedElements
}
impl
Dependency
{
pub
fn
combinator
(
&
self
)
-
>
Option
<
Combinator
>
{
if
self
.
selector_offset
=
=
0
{
return
None
;
}
Some
(
self
.
selector
.
combinator_at_match_order
(
self
.
selector_offset
-
1
)
)
}
pub
fn
invalidation_kind
(
&
self
)
-
>
DependencyInvalidationKind
{
match
self
.
combinator
(
)
{
None
=
>
DependencyInvalidationKind
:
:
Element
Some
(
Combinator
:
:
Child
)
|
Some
(
Combinator
:
:
Descendant
)
=
>
DependencyInvalidationKind
:
:
Descendants
Some
(
Combinator
:
:
LaterSibling
)
|
Some
(
Combinator
:
:
NextSibling
)
=
>
DependencyInvalidationKind
:
:
Siblings
Some
(
Combinator
:
:
PseudoElement
)
=
>
DependencyInvalidationKind
:
:
ElementAndDescendants
Some
(
Combinator
:
:
SlotAssignment
)
=
>
DependencyInvalidationKind
:
:
SlottedElements
}
}
}
impl
SelectorMapEntry
for
Dependency
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter_from
(
self
.
selector_offset
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
StateDependency
{
pub
dep
:
Dependency
pub
state
:
ElementState
}
impl
SelectorMapEntry
for
StateDependency
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
dep
.
selector
(
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
DocumentStateDependency
{
#
[
cfg_attr
(
feature
=
"
gecko
"
ignore_malloc_size_of
=
"
CssRules
have
primary
refs
we
measure
there
"
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
Arc
"
)
]
pub
selector
:
Selector
<
SelectorImpl
>
pub
state
:
DocumentState
}
#
[
derive
(
Debug
MallocSizeOf
)
]
pub
struct
InvalidationMap
{
pub
class_to_selector
:
MaybeCaseInsensitiveHashMap
<
Atom
SmallVec
<
[
Dependency
;
1
]
>
>
pub
id_to_selector
:
MaybeCaseInsensitiveHashMap
<
Atom
SmallVec
<
[
Dependency
;
1
]
>
>
pub
state_affecting_selectors
:
SelectorMap
<
StateDependency
>
pub
document_state_selectors
:
Vec
<
DocumentStateDependency
>
pub
other_attribute_affecting_selectors
:
SelectorMap
<
Dependency
>
pub
has_class_attribute_selectors
:
bool
pub
has_id_attribute_selectors
:
bool
}
impl
InvalidationMap
{
pub
fn
new
(
)
-
>
Self
{
Self
{
class_to_selector
:
MaybeCaseInsensitiveHashMap
:
:
new
(
)
id_to_selector
:
MaybeCaseInsensitiveHashMap
:
:
new
(
)
state_affecting_selectors
:
SelectorMap
:
:
new
(
)
document_state_selectors
:
Vec
:
:
new
(
)
other_attribute_affecting_selectors
:
SelectorMap
:
:
new
(
)
has_class_attribute_selectors
:
false
has_id_attribute_selectors
:
false
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
state_affecting_selectors
.
len
(
)
+
self
.
document_state_selectors
.
len
(
)
+
self
.
other_attribute_affecting_selectors
.
len
(
)
+
self
.
id_to_selector
.
iter
(
)
.
fold
(
0
|
accum
(
_
ref
v
)
|
{
accum
+
v
.
len
(
)
}
)
+
self
.
class_to_selector
.
iter
(
)
.
fold
(
0
|
accum
(
_
ref
v
)
|
{
accum
+
v
.
len
(
)
}
)
}
pub
fn
note_selector
(
&
mut
self
selector
:
&
Selector
<
SelectorImpl
>
quirks_mode
:
QuirksMode
)
-
>
Result
<
(
)
FailedAllocationError
>
{
self
.
collect_invalidations_for
(
selector
quirks_mode
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
class_to_selector
.
clear
(
)
;
self
.
id_to_selector
.
clear
(
)
;
self
.
state_affecting_selectors
.
clear
(
)
;
self
.
document_state_selectors
.
clear
(
)
;
self
.
other_attribute_affecting_selectors
.
clear
(
)
;
self
.
has_id_attribute_selectors
=
false
;
self
.
has_class_attribute_selectors
=
false
;
}
fn
collect_invalidations_for
(
&
mut
self
selector
:
&
Selector
<
SelectorImpl
>
quirks_mode
:
QuirksMode
)
-
>
Result
<
(
)
FailedAllocationError
>
{
debug
!
(
"
InvalidationMap
:
:
collect_invalidations_for
(
{
:
?
}
)
"
selector
)
;
let
mut
iter
=
selector
.
iter
(
)
;
let
mut
combinator
;
let
mut
index
=
0
;
let
mut
document_state
=
DocumentState
:
:
empty
(
)
;
loop
{
let
sequence_start
=
index
;
let
mut
compound_visitor
=
CompoundSelectorDependencyCollector
{
classes
:
SmallVec
:
:
new
(
)
ids
:
SmallVec
:
:
new
(
)
state
:
ElementState
:
:
empty
(
)
document_state
:
&
mut
document_state
other_attributes
:
false
has_id_attribute_selectors
:
false
has_class_attribute_selectors
:
false
}
;
for
ss
in
&
mut
iter
{
ss
.
visit
(
&
mut
compound_visitor
)
;
index
+
=
1
;
}
self
.
has_id_attribute_selectors
|
=
compound_visitor
.
has_id_attribute_selectors
;
self
.
has_class_attribute_selectors
|
=
compound_visitor
.
has_class_attribute_selectors
;
for
class
in
compound_visitor
.
classes
{
self
.
class_to_selector
.
try_entry
(
class
quirks_mode
)
?
.
or_insert_with
(
SmallVec
:
:
new
)
.
try_push
(
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
sequence_start
}
)
?
;
}
for
id
in
compound_visitor
.
ids
{
self
.
id_to_selector
.
try_entry
(
id
quirks_mode
)
?
.
or_insert_with
(
SmallVec
:
:
new
)
.
try_push
(
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
sequence_start
}
)
?
;
}
if
!
compound_visitor
.
state
.
is_empty
(
)
{
self
.
state_affecting_selectors
.
insert
(
StateDependency
{
dep
:
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
sequence_start
}
state
:
compound_visitor
.
state
}
quirks_mode
)
?
;
}
if
compound_visitor
.
other_attributes
{
self
.
other_attribute_affecting_selectors
.
insert
(
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
sequence_start
}
quirks_mode
)
?
;
}
combinator
=
iter
.
next_sequence
(
)
;
if
combinator
.
is_none
(
)
{
break
;
}
index
+
=
1
;
}
if
!
document_state
.
is_empty
(
)
{
self
.
document_state_selectors
.
try_push
(
DocumentStateDependency
{
state
:
document_state
selector
:
selector
.
clone
(
)
}
)
?
;
}
Ok
(
(
)
)
}
}
struct
CompoundSelectorDependencyCollector
<
'
a
>
{
state
:
ElementState
document_state
:
&
'
a
mut
DocumentState
classes
:
SmallVec
<
[
Atom
;
5
]
>
ids
:
SmallVec
<
[
Atom
;
5
]
>
other_attributes
:
bool
has_id_attribute_selectors
:
bool
has_class_attribute_selectors
:
bool
}
impl
<
'
a
>
SelectorVisitor
for
CompoundSelectorDependencyCollector
<
'
a
>
{
type
Impl
=
SelectorImpl
;
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
selector_parser
:
:
NonTSPseudoClass
;
match
*
s
{
Component
:
:
ID
(
ref
id
)
=
>
{
self
.
ids
.
push
(
id
.
clone
(
)
)
;
}
Component
:
:
Class
(
ref
class
)
=
>
{
self
.
classes
.
push
(
class
.
clone
(
)
)
;
}
Component
:
:
NonTSPseudoClass
(
ref
pc
)
=
>
{
self
.
other_attributes
|
=
pc
.
is_attr_based
(
)
;
self
.
state
|
=
match
*
pc
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
Dir
(
ref
dir
)
=
>
{
dir_selector_to_state
(
dir
)
}
_
=
>
pc
.
state_flag
(
)
}
;
*
self
.
document_state
|
=
pc
.
document_state_flag
(
)
;
}
_
=
>
{
}
}
true
}
fn
visit_attribute_selector
(
&
mut
self
constraint
:
&
NamespaceConstraint
<
&
Namespace
>
_local_name
:
&
LocalName
local_name_lower
:
&
LocalName
)
-
>
bool
{
self
.
other_attributes
=
true
;
let
may_match_in_no_namespace
=
match
*
constraint
{
NamespaceConstraint
:
:
Any
=
>
true
NamespaceConstraint
:
:
Specific
(
ref
ns
)
=
>
ns
.
is_empty
(
)
}
;
if
may_match_in_no_namespace
{
self
.
has_id_attribute_selectors
|
=
*
local_name_lower
=
=
local_name
!
(
"
id
"
)
;
self
.
has_class_attribute_selectors
|
=
*
local_name_lower
=
=
local_name
!
(
"
class
"
)
;
}
true
}
}
