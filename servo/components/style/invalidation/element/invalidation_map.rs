use
crate
:
:
context
:
:
QuirksMode
;
use
crate
:
:
element_state
:
:
{
DocumentState
ElementState
}
;
use
crate
:
:
selector_map
:
:
{
MaybeCaseInsensitiveHashMap
SelectorMap
SelectorMapEntry
}
;
use
crate
:
:
selector_parser
:
:
SelectorImpl
;
use
crate
:
:
{
Atom
LocalName
Namespace
}
;
use
fallible
:
:
FallibleVec
;
use
hashglobe
:
:
FailedAllocationError
;
use
selectors
:
:
attr
:
:
NamespaceConstraint
;
use
selectors
:
:
parser
:
:
{
Combinator
Component
}
;
use
selectors
:
:
parser
:
:
{
Selector
SelectorIter
Visit
}
;
use
selectors
:
:
visitor
:
:
SelectorVisitor
;
use
smallvec
:
:
SmallVec
;
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
Dependency
{
#
[
cfg_attr
(
feature
=
"
gecko
"
ignore_malloc_size_of
=
"
CssRules
have
primary
refs
we
measure
there
"
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
Arc
"
)
]
pub
selector
:
Selector
<
SelectorImpl
>
pub
selector_offset
:
usize
}
#
[
derive
(
Debug
Eq
PartialEq
)
]
pub
enum
DependencyInvalidationKind
{
Element
ElementAndDescendants
Descendants
Siblings
SlottedElements
Parts
}
impl
Dependency
{
pub
fn
combinator
(
&
self
)
-
>
Option
<
Combinator
>
{
if
self
.
selector_offset
=
=
0
{
return
None
;
}
Some
(
self
.
selector
.
combinator_at_match_order
(
self
.
selector_offset
-
1
)
)
}
pub
fn
invalidation_kind
(
&
self
)
-
>
DependencyInvalidationKind
{
match
self
.
combinator
(
)
{
None
=
>
DependencyInvalidationKind
:
:
Element
Some
(
Combinator
:
:
Child
)
|
Some
(
Combinator
:
:
Descendant
)
=
>
{
DependencyInvalidationKind
:
:
Descendants
}
Some
(
Combinator
:
:
LaterSibling
)
|
Some
(
Combinator
:
:
NextSibling
)
=
>
{
DependencyInvalidationKind
:
:
Siblings
}
Some
(
Combinator
:
:
PseudoElement
)
=
>
DependencyInvalidationKind
:
:
ElementAndDescendants
Some
(
Combinator
:
:
SlotAssignment
)
=
>
DependencyInvalidationKind
:
:
SlottedElements
Some
(
Combinator
:
:
Part
)
=
>
DependencyInvalidationKind
:
:
Parts
}
}
}
impl
SelectorMapEntry
for
Dependency
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter_from
(
self
.
selector_offset
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
StateDependency
{
pub
dep
:
Dependency
pub
state
:
ElementState
}
impl
SelectorMapEntry
for
StateDependency
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
dep
.
selector
(
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
DocumentStateDependency
{
#
[
cfg_attr
(
feature
=
"
gecko
"
ignore_malloc_size_of
=
"
CssRules
have
primary
refs
we
measure
there
"
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
Arc
"
)
]
pub
selector
:
Selector
<
SelectorImpl
>
pub
state
:
DocumentState
}
bitflags
!
{
/
/
/
A
set
of
flags
that
denote
whether
any
invalidations
have
occurred
/
/
/
for
a
particular
attribute
selector
.
#
[
derive
(
MallocSizeOf
)
]
#
[
repr
(
C
)
]
pub
struct
InvalidationMapFlags
:
u8
{
/
/
/
Whether
[
class
]
or
such
is
used
.
const
HAS_CLASS_ATTR_SELECTOR
=
1
<
<
0
;
/
/
/
Whether
[
id
]
or
such
is
used
.
const
HAS_ID_ATTR_SELECTOR
=
1
<
<
1
;
}
}
#
[
derive
(
Debug
MallocSizeOf
)
]
pub
struct
InvalidationMap
{
pub
class_to_selector
:
MaybeCaseInsensitiveHashMap
<
Atom
SmallVec
<
[
Dependency
;
1
]
>
>
pub
id_to_selector
:
MaybeCaseInsensitiveHashMap
<
Atom
SmallVec
<
[
Dependency
;
1
]
>
>
pub
state_affecting_selectors
:
SelectorMap
<
StateDependency
>
pub
document_state_selectors
:
Vec
<
DocumentStateDependency
>
pub
other_attribute_affecting_selectors
:
SelectorMap
<
Dependency
>
pub
flags
:
InvalidationMapFlags
}
impl
InvalidationMap
{
pub
fn
new
(
)
-
>
Self
{
Self
{
class_to_selector
:
MaybeCaseInsensitiveHashMap
:
:
new
(
)
id_to_selector
:
MaybeCaseInsensitiveHashMap
:
:
new
(
)
state_affecting_selectors
:
SelectorMap
:
:
new
(
)
document_state_selectors
:
Vec
:
:
new
(
)
other_attribute_affecting_selectors
:
SelectorMap
:
:
new
(
)
flags
:
InvalidationMapFlags
:
:
empty
(
)
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
state_affecting_selectors
.
len
(
)
+
self
.
document_state_selectors
.
len
(
)
+
self
.
other_attribute_affecting_selectors
.
len
(
)
+
self
.
id_to_selector
.
iter
(
)
.
fold
(
0
|
accum
(
_
ref
v
)
|
accum
+
v
.
len
(
)
)
+
self
.
class_to_selector
.
iter
(
)
.
fold
(
0
|
accum
(
_
ref
v
)
|
accum
+
v
.
len
(
)
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
class_to_selector
.
clear
(
)
;
self
.
id_to_selector
.
clear
(
)
;
self
.
state_affecting_selectors
.
clear
(
)
;
self
.
document_state_selectors
.
clear
(
)
;
self
.
other_attribute_affecting_selectors
.
clear
(
)
;
self
.
flags
=
InvalidationMapFlags
:
:
empty
(
)
;
}
pub
fn
note_selector
(
&
mut
self
selector
:
&
Selector
<
SelectorImpl
>
quirks_mode
:
QuirksMode
)
-
>
Result
<
(
)
FailedAllocationError
>
{
debug
!
(
"
InvalidationMap
:
:
note_selector
(
{
:
?
}
)
"
selector
)
;
let
mut
iter
=
selector
.
iter
(
)
;
let
mut
combinator
;
let
mut
index
=
0
;
let
mut
document_state
=
DocumentState
:
:
empty
(
)
;
loop
{
let
sequence_start
=
index
;
let
mut
compound_visitor
=
CompoundSelectorDependencyCollector
{
classes
:
SmallVec
:
:
new
(
)
ids
:
SmallVec
:
:
new
(
)
state
:
ElementState
:
:
empty
(
)
document_state
:
&
mut
document_state
other_attributes
:
false
flags
:
&
mut
self
.
flags
}
;
for
ss
in
&
mut
iter
{
ss
.
visit
(
&
mut
compound_visitor
)
;
index
+
=
1
;
}
for
class
in
compound_visitor
.
classes
{
self
.
class_to_selector
.
try_entry
(
class
quirks_mode
)
?
.
or_insert_with
(
SmallVec
:
:
new
)
.
try_push
(
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
sequence_start
}
)
?
;
}
for
id
in
compound_visitor
.
ids
{
self
.
id_to_selector
.
try_entry
(
id
quirks_mode
)
?
.
or_insert_with
(
SmallVec
:
:
new
)
.
try_push
(
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
sequence_start
}
)
?
;
}
if
!
compound_visitor
.
state
.
is_empty
(
)
{
self
.
state_affecting_selectors
.
insert
(
StateDependency
{
dep
:
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
sequence_start
}
state
:
compound_visitor
.
state
}
quirks_mode
)
?
;
}
if
compound_visitor
.
other_attributes
{
self
.
other_attribute_affecting_selectors
.
insert
(
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
sequence_start
}
quirks_mode
)
?
;
}
combinator
=
iter
.
next_sequence
(
)
;
if
combinator
.
is_none
(
)
{
break
;
}
index
+
=
1
;
}
if
!
document_state
.
is_empty
(
)
{
self
.
document_state_selectors
.
try_push
(
DocumentStateDependency
{
state
:
document_state
selector
:
selector
.
clone
(
)
}
)
?
;
}
Ok
(
(
)
)
}
}
struct
CompoundSelectorDependencyCollector
<
'
a
>
{
state
:
ElementState
document_state
:
&
'
a
mut
DocumentState
classes
:
SmallVec
<
[
Atom
;
5
]
>
ids
:
SmallVec
<
[
Atom
;
5
]
>
other_attributes
:
bool
flags
:
&
'
a
mut
InvalidationMapFlags
}
impl
<
'
a
>
SelectorVisitor
for
CompoundSelectorDependencyCollector
<
'
a
>
{
type
Impl
=
SelectorImpl
;
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
selector_parser
:
:
NonTSPseudoClass
;
match
*
s
{
Component
:
:
ID
(
ref
id
)
=
>
{
self
.
ids
.
push
(
id
.
clone
(
)
)
;
}
Component
:
:
Class
(
ref
class
)
=
>
{
self
.
classes
.
push
(
class
.
clone
(
)
)
;
}
Component
:
:
NonTSPseudoClass
(
ref
pc
)
=
>
{
self
.
other_attributes
|
=
pc
.
is_attr_based
(
)
;
self
.
state
|
=
match
*
pc
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
Dir
(
ref
dir
)
=
>
dir
.
element_state
(
)
_
=
>
pc
.
state_flag
(
)
}
;
*
self
.
document_state
|
=
pc
.
document_state_flag
(
)
;
}
_
=
>
{
}
}
true
}
fn
visit_attribute_selector
(
&
mut
self
constraint
:
&
NamespaceConstraint
<
&
Namespace
>
_local_name
:
&
LocalName
local_name_lower
:
&
LocalName
)
-
>
bool
{
self
.
other_attributes
=
true
;
let
may_match_in_no_namespace
=
match
*
constraint
{
NamespaceConstraint
:
:
Any
=
>
true
NamespaceConstraint
:
:
Specific
(
ref
ns
)
=
>
ns
.
is_empty
(
)
}
;
if
may_match_in_no_namespace
{
if
*
local_name_lower
=
=
local_name
!
(
"
id
"
)
{
self
.
flags
.
insert
(
InvalidationMapFlags
:
:
HAS_ID_ATTR_SELECTOR
)
}
else
if
*
local_name_lower
=
=
local_name
!
(
"
class
"
)
{
self
.
flags
.
insert
(
InvalidationMapFlags
:
:
HAS_CLASS_ATTR_SELECTOR
)
}
}
true
}
}
