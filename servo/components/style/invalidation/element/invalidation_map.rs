use
crate
:
:
context
:
:
QuirksMode
;
use
crate
:
:
element_state
:
:
{
DocumentState
ElementState
}
;
use
crate
:
:
selector_map
:
:
{
MaybeCaseInsensitiveHashMap
PrecomputedHashMap
SelectorMap
SelectorMapEntry
}
;
use
crate
:
:
selector_parser
:
:
SelectorImpl
;
use
crate
:
:
{
Atom
LocalName
Namespace
}
;
use
fallible
:
:
{
FallibleVec
FallibleHashMap
}
;
use
hashbrown
:
:
CollectionAllocErr
;
use
selectors
:
:
attr
:
:
NamespaceConstraint
;
use
selectors
:
:
parser
:
:
{
Combinator
Component
}
;
use
selectors
:
:
parser
:
:
{
Selector
SelectorIter
}
;
use
selectors
:
:
visitor
:
:
SelectorVisitor
;
use
smallvec
:
:
SmallVec
;
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
Dependency
{
#
[
cfg_attr
(
feature
=
"
gecko
"
ignore_malloc_size_of
=
"
CssRules
have
primary
refs
we
measure
there
"
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
Arc
"
)
]
pub
selector
:
Selector
<
SelectorImpl
>
pub
selector_offset
:
usize
pub
parent
:
Option
<
Box
<
Dependency
>
>
}
#
[
derive
(
Debug
Eq
PartialEq
)
]
pub
enum
DependencyInvalidationKind
{
Element
ElementAndDescendants
Descendants
Siblings
SlottedElements
Parts
}
impl
Dependency
{
pub
fn
for_full_selector_invalidation
(
selector
:
Selector
<
SelectorImpl
>
)
-
>
Self
{
Self
{
selector_offset
:
selector
.
len
(
)
+
1
selector
parent
:
None
}
}
pub
fn
combinator
(
&
self
)
-
>
Option
<
Combinator
>
{
if
self
.
selector_offset
=
=
0
{
return
None
;
}
Some
(
self
.
selector
.
combinator_at_match_order
(
self
.
selector_offset
-
1
)
)
}
pub
fn
invalidation_kind
(
&
self
)
-
>
DependencyInvalidationKind
{
match
self
.
combinator
(
)
{
None
=
>
DependencyInvalidationKind
:
:
Element
Some
(
Combinator
:
:
Child
)
|
Some
(
Combinator
:
:
Descendant
)
=
>
{
DependencyInvalidationKind
:
:
Descendants
}
Some
(
Combinator
:
:
LaterSibling
)
|
Some
(
Combinator
:
:
NextSibling
)
=
>
{
DependencyInvalidationKind
:
:
Siblings
}
Some
(
Combinator
:
:
PseudoElement
)
=
>
DependencyInvalidationKind
:
:
ElementAndDescendants
Some
(
Combinator
:
:
SlotAssignment
)
=
>
DependencyInvalidationKind
:
:
SlottedElements
Some
(
Combinator
:
:
Part
)
=
>
DependencyInvalidationKind
:
:
Parts
}
}
}
impl
SelectorMapEntry
for
Dependency
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter_from
(
self
.
selector_offset
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
StateDependency
{
pub
dep
:
Dependency
pub
state
:
ElementState
}
impl
SelectorMapEntry
for
StateDependency
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
dep
.
selector
(
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
DocumentStateDependency
{
#
[
cfg_attr
(
feature
=
"
gecko
"
ignore_malloc_size_of
=
"
CssRules
have
primary
refs
we
measure
there
"
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
Arc
"
)
]
pub
dependency
:
Dependency
pub
state
:
DocumentState
}
#
[
derive
(
Debug
MallocSizeOf
)
]
pub
struct
InvalidationMap
{
pub
class_to_selector
:
MaybeCaseInsensitiveHashMap
<
Atom
SmallVec
<
[
Dependency
;
1
]
>
>
pub
id_to_selector
:
MaybeCaseInsensitiveHashMap
<
Atom
SmallVec
<
[
Dependency
;
1
]
>
>
pub
state_affecting_selectors
:
SelectorMap
<
StateDependency
>
pub
document_state_selectors
:
Vec
<
DocumentStateDependency
>
pub
other_attribute_affecting_selectors
:
PrecomputedHashMap
<
LocalName
SmallVec
<
[
Dependency
;
1
]
>
>
}
impl
InvalidationMap
{
pub
fn
new
(
)
-
>
Self
{
Self
{
class_to_selector
:
MaybeCaseInsensitiveHashMap
:
:
new
(
)
id_to_selector
:
MaybeCaseInsensitiveHashMap
:
:
new
(
)
state_affecting_selectors
:
SelectorMap
:
:
new
(
)
document_state_selectors
:
Vec
:
:
new
(
)
other_attribute_affecting_selectors
:
PrecomputedHashMap
:
:
default
(
)
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
state_affecting_selectors
.
len
(
)
+
self
.
document_state_selectors
.
len
(
)
+
self
.
other_attribute_affecting_selectors
.
iter
(
)
.
fold
(
0
|
accum
(
_
ref
v
)
|
accum
+
v
.
len
(
)
)
+
self
.
id_to_selector
.
iter
(
)
.
fold
(
0
|
accum
(
_
ref
v
)
|
accum
+
v
.
len
(
)
)
+
self
.
class_to_selector
.
iter
(
)
.
fold
(
0
|
accum
(
_
ref
v
)
|
accum
+
v
.
len
(
)
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
class_to_selector
.
clear
(
)
;
self
.
id_to_selector
.
clear
(
)
;
self
.
state_affecting_selectors
.
clear
(
)
;
self
.
document_state_selectors
.
clear
(
)
;
self
.
other_attribute_affecting_selectors
.
clear
(
)
;
}
pub
fn
note_selector
(
&
mut
self
selector
:
&
Selector
<
SelectorImpl
>
quirks_mode
:
QuirksMode
)
-
>
Result
<
(
)
CollectionAllocErr
>
{
debug
!
(
"
InvalidationMap
:
:
note_selector
(
{
:
?
}
)
"
selector
)
;
let
mut
document_state
=
DocumentState
:
:
empty
(
)
;
{
let
mut
parent_stack
=
SmallVec
:
:
new
(
)
;
let
mut
alloc_error
=
None
;
let
mut
collector
=
SelectorDependencyCollector
{
map
:
self
document_state
:
&
mut
document_state
selector
parent_selectors
:
&
mut
parent_stack
quirks_mode
compound_state
:
PerCompoundState
:
:
new
(
0
)
alloc_error
:
&
mut
alloc_error
}
;
let
visit_result
=
collector
.
visit_whole_selector
(
)
;
debug_assert_eq
!
(
!
visit_result
alloc_error
.
is_some
(
)
)
;
if
let
Some
(
alloc_error
)
=
alloc_error
{
return
Err
(
alloc_error
)
;
}
}
if
!
document_state
.
is_empty
(
)
{
let
dep
=
DocumentStateDependency
{
state
:
document_state
dependency
:
Dependency
:
:
for_full_selector_invalidation
(
selector
.
clone
(
)
)
}
;
self
.
document_state_selectors
.
try_push
(
dep
)
?
;
}
Ok
(
(
)
)
}
}
struct
PerCompoundState
{
offset
:
usize
element_state
:
ElementState
}
impl
PerCompoundState
{
fn
new
(
offset
:
usize
)
-
>
Self
{
Self
{
offset
element_state
:
ElementState
:
:
empty
(
)
}
}
}
struct
SelectorDependencyCollector
<
'
a
>
{
map
:
&
'
a
mut
InvalidationMap
document_state
:
&
'
a
mut
DocumentState
selector
:
&
'
a
Selector
<
SelectorImpl
>
parent_selectors
:
&
'
a
mut
SmallVec
<
[
(
Selector
<
SelectorImpl
>
usize
)
;
5
]
>
quirks_mode
:
QuirksMode
compound_state
:
PerCompoundState
alloc_error
:
&
'
a
mut
Option
<
CollectionAllocErr
>
}
impl
<
'
a
>
SelectorDependencyCollector
<
'
a
>
{
fn
visit_whole_selector
(
&
mut
self
)
-
>
bool
{
let
iter
=
self
.
selector
.
iter
(
)
;
self
.
visit_whole_selector_from
(
iter
0
)
}
fn
visit_whole_selector_from
(
&
mut
self
mut
iter
:
SelectorIter
<
SelectorImpl
>
mut
index
:
usize
)
-
>
bool
{
loop
{
self
.
compound_state
=
PerCompoundState
:
:
new
(
index
)
;
for
ss
in
&
mut
iter
{
if
!
ss
.
visit
(
self
)
{
return
false
;
}
index
+
=
1
;
}
if
!
self
.
compound_state
.
element_state
.
is_empty
(
)
{
let
dependency
=
self
.
dependency
(
)
;
let
result
=
self
.
map
.
state_affecting_selectors
.
insert
(
StateDependency
{
dep
:
dependency
state
:
self
.
compound_state
.
element_state
}
self
.
quirks_mode
)
;
if
let
Err
(
alloc_error
)
=
result
{
*
self
.
alloc_error
=
Some
(
alloc_error
)
;
return
false
;
}
}
let
combinator
=
iter
.
next_sequence
(
)
;
if
combinator
.
is_none
(
)
{
return
true
;
}
index
+
=
1
;
}
}
fn
add_attr_dependency
(
&
mut
self
name
:
LocalName
)
-
>
bool
{
let
dependency
=
self
.
dependency
(
)
;
let
map
=
&
mut
self
.
map
.
other_attribute_affecting_selectors
;
let
entry
=
match
map
.
try_entry
(
name
)
{
Ok
(
entry
)
=
>
entry
Err
(
err
)
=
>
{
*
self
.
alloc_error
=
Some
(
err
)
;
return
false
;
}
}
;
match
entry
.
or_insert_with
(
SmallVec
:
:
new
)
.
try_push
(
dependency
)
{
Ok
(
.
.
)
=
>
true
Err
(
err
)
=
>
{
*
self
.
alloc_error
=
Some
(
err
)
;
return
false
;
}
}
}
fn
dependency
(
&
self
)
-
>
Dependency
{
let
mut
parent
=
None
;
for
&
(
ref
selector
ref
selector_offset
)
in
self
.
parent_selectors
.
iter
(
)
{
debug_assert_ne
!
(
self
.
compound_state
.
offset
0
"
Shouldn
'
t
bother
creating
nested
dependencies
for
the
rightmost
compound
"
)
;
let
new_parent
=
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
*
selector_offset
parent
}
;
parent
=
Some
(
Box
:
:
new
(
new_parent
)
)
;
}
Dependency
{
selector
:
self
.
selector
.
clone
(
)
selector_offset
:
self
.
compound_state
.
offset
parent
}
}
}
impl
<
'
a
>
SelectorVisitor
for
SelectorDependencyCollector
<
'
a
>
{
type
Impl
=
SelectorImpl
;
fn
visit_selector_list
(
&
mut
self
list
:
&
[
Selector
<
SelectorImpl
>
]
)
-
>
bool
{
for
selector
in
list
{
let
mut
iter
=
selector
.
iter
(
)
;
let
mut
index
=
0
;
for
ss
in
&
mut
iter
{
if
!
ss
.
visit
(
self
)
{
return
false
;
}
index
+
=
1
;
}
let
combinator
=
iter
.
next_sequence
(
)
;
if
combinator
.
is_none
(
)
{
continue
;
}
index
+
=
1
;
self
.
parent_selectors
.
push
(
(
self
.
selector
.
clone
(
)
self
.
compound_state
.
offset
)
)
;
let
mut
nested
=
SelectorDependencyCollector
{
map
:
&
mut
*
self
.
map
document_state
:
&
mut
*
self
.
document_state
selector
parent_selectors
:
&
mut
*
self
.
parent_selectors
quirks_mode
:
self
.
quirks_mode
compound_state
:
PerCompoundState
:
:
new
(
index
)
alloc_error
:
&
mut
*
self
.
alloc_error
}
;
if
!
nested
.
visit_whole_selector_from
(
iter
index
)
{
return
false
;
}
self
.
parent_selectors
.
pop
(
)
;
}
true
}
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
use
crate
:
:
selector_parser
:
:
NonTSPseudoClass
;
match
*
s
{
Component
:
:
ID
(
ref
atom
)
|
Component
:
:
Class
(
ref
atom
)
=
>
{
let
dependency
=
self
.
dependency
(
)
;
let
map
=
match
*
s
{
Component
:
:
ID
(
.
.
)
=
>
&
mut
self
.
map
.
id_to_selector
Component
:
:
Class
(
.
.
)
=
>
&
mut
self
.
map
.
class_to_selector
_
=
>
unreachable
!
(
)
}
;
let
entry
=
match
map
.
try_entry
(
atom
.
clone
(
)
self
.
quirks_mode
)
{
Ok
(
entry
)
=
>
entry
Err
(
err
)
=
>
{
*
self
.
alloc_error
=
Some
(
err
)
;
return
false
;
}
}
;
match
entry
.
or_insert_with
(
SmallVec
:
:
new
)
.
try_push
(
dependency
)
{
Ok
(
.
.
)
=
>
true
Err
(
err
)
=
>
{
*
self
.
alloc_error
=
Some
(
err
)
;
return
false
;
}
}
}
Component
:
:
NonTSPseudoClass
(
ref
pc
)
=
>
{
self
.
compound_state
.
element_state
|
=
match
*
pc
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
Dir
(
ref
dir
)
=
>
dir
.
element_state
(
)
_
=
>
pc
.
state_flag
(
)
}
;
*
self
.
document_state
|
=
pc
.
document_state_flag
(
)
;
let
attr_name
=
match
*
pc
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
MozTableBorderNonzero
=
>
local_name
!
(
"
border
"
)
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
MozBrowserFrame
=
>
local_name
!
(
"
mozbrowser
"
)
NonTSPseudoClass
:
:
Lang
(
.
.
)
=
>
local_name
!
(
"
lang
"
)
_
=
>
return
true
}
;
self
.
add_attr_dependency
(
attr_name
)
}
_
=
>
true
}
}
fn
visit_attribute_selector
(
&
mut
self
_
:
&
NamespaceConstraint
<
&
Namespace
>
local_name
:
&
LocalName
local_name_lower
:
&
LocalName
)
-
>
bool
{
if
!
self
.
add_attr_dependency
(
local_name
.
clone
(
)
)
{
return
false
;
}
if
local_name
!
=
local_name_lower
&
&
!
self
.
add_attr_dependency
(
local_name_lower
.
clone
(
)
)
{
return
false
;
}
true
}
}
