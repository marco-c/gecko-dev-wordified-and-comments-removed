use
{
Atom
LocalName
Namespace
}
;
use
context
:
:
QuirksMode
;
use
element_state
:
:
ElementState
;
use
selector_map
:
:
{
MaybeCaseInsensitiveHashMap
SelectorMap
SelectorMapEntry
}
;
use
selector_parser
:
:
SelectorImpl
;
use
selectors
:
:
attr
:
:
NamespaceConstraint
;
use
selectors
:
:
parser
:
:
{
Combinator
Component
}
;
use
selectors
:
:
parser
:
:
{
Selector
SelectorIter
SelectorMethods
}
;
use
selectors
:
:
visitor
:
:
SelectorVisitor
;
use
smallvec
:
:
SmallVec
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
dir_selector_to_state
(
s
:
&
[
u16
]
)
-
>
ElementState
{
use
element_state
:
:
{
IN_LTR_STATE
IN_RTL_STATE
}
;
const
LTR
:
[
u16
;
4
]
=
[
b
'
l
'
as
u16
b
'
t
'
as
u16
b
'
r
'
as
u16
0
]
;
const
RTL
:
[
u16
;
4
]
=
[
b
'
r
'
as
u16
b
'
t
'
as
u16
b
'
l
'
as
u16
0
]
;
if
LTR
=
=
*
s
{
IN_LTR_STATE
}
else
if
RTL
=
=
*
s
{
IN_RTL_STATE
}
else
{
ElementState
:
:
empty
(
)
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
Dependency
{
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
pub
selector
:
Selector
<
SelectorImpl
>
pub
selector_offset
:
usize
}
impl
Dependency
{
pub
fn
combinator
(
&
self
)
-
>
Option
<
Combinator
>
{
if
self
.
selector_offset
=
=
0
{
return
None
;
}
Some
(
self
.
selector
.
combinator_at
(
self
.
selector_offset
)
)
}
pub
fn
affects_self
(
&
self
)
-
>
bool
{
matches
!
(
self
.
combinator
(
)
None
|
Some
(
Combinator
:
:
PseudoElement
)
)
}
pub
fn
affects_descendants
(
&
self
)
-
>
bool
{
matches
!
(
self
.
combinator
(
)
Some
(
Combinator
:
:
PseudoElement
)
|
Some
(
Combinator
:
:
Child
)
|
Some
(
Combinator
:
:
Descendant
)
)
}
pub
fn
affects_later_siblings
(
&
self
)
-
>
bool
{
matches
!
(
self
.
combinator
(
)
Some
(
Combinator
:
:
NextSibling
)
|
Some
(
Combinator
:
:
LaterSibling
)
)
}
}
impl
SelectorMapEntry
for
Dependency
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter_from
(
self
.
selector_offset
)
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
StateDependency
{
pub
dep
:
Dependency
pub
state
:
ElementState
}
impl
SelectorMapEntry
for
StateDependency
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
dep
.
selector
(
)
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
InvalidationMap
{
pub
class_to_selector
:
MaybeCaseInsensitiveHashMap
<
Atom
SelectorMap
<
Dependency
>
>
pub
id_to_selector
:
MaybeCaseInsensitiveHashMap
<
Atom
SelectorMap
<
Dependency
>
>
pub
state_affecting_selectors
:
SelectorMap
<
StateDependency
>
pub
other_attribute_affecting_selectors
:
SelectorMap
<
Dependency
>
pub
has_class_attribute_selectors
:
bool
pub
has_id_attribute_selectors
:
bool
}
impl
InvalidationMap
{
pub
fn
new
(
)
-
>
Self
{
Self
{
class_to_selector
:
MaybeCaseInsensitiveHashMap
:
:
new
(
)
id_to_selector
:
MaybeCaseInsensitiveHashMap
:
:
new
(
)
state_affecting_selectors
:
SelectorMap
:
:
new
(
)
other_attribute_affecting_selectors
:
SelectorMap
:
:
new
(
)
has_class_attribute_selectors
:
false
has_id_attribute_selectors
:
false
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
state_affecting_selectors
.
len
(
)
+
self
.
other_attribute_affecting_selectors
.
len
(
)
+
self
.
id_to_selector
.
iter
(
)
.
fold
(
0
|
accum
(
_
ref
v
)
|
{
accum
+
v
.
len
(
)
}
)
+
self
.
class_to_selector
.
iter
(
)
.
fold
(
0
|
accum
(
_
ref
v
)
|
{
accum
+
v
.
len
(
)
}
)
}
pub
fn
note_selector
(
&
mut
self
selector
:
&
Selector
<
SelectorImpl
>
quirks_mode
:
QuirksMode
)
{
self
.
collect_invalidations_for
(
selector
quirks_mode
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
class_to_selector
.
clear
(
)
;
self
.
id_to_selector
.
clear
(
)
;
self
.
state_affecting_selectors
.
clear
(
)
;
self
.
other_attribute_affecting_selectors
.
clear
(
)
;
self
.
has_id_attribute_selectors
=
false
;
self
.
has_class_attribute_selectors
=
false
;
}
fn
collect_invalidations_for
(
&
mut
self
selector
:
&
Selector
<
SelectorImpl
>
quirks_mode
:
QuirksMode
)
{
debug
!
(
"
InvalidationMap
:
:
collect_invalidations_for
(
{
:
?
}
)
"
selector
)
;
let
mut
iter
=
selector
.
iter
(
)
;
let
mut
combinator
;
let
mut
index
=
0
;
loop
{
let
sequence_start
=
index
;
let
mut
compound_visitor
=
CompoundSelectorDependencyCollector
{
classes
:
SmallVec
:
:
new
(
)
ids
:
SmallVec
:
:
new
(
)
state
:
ElementState
:
:
empty
(
)
other_attributes
:
false
has_id_attribute_selectors
:
false
has_class_attribute_selectors
:
false
}
;
for
ss
in
&
mut
iter
{
ss
.
visit
(
&
mut
compound_visitor
)
;
index
+
=
1
;
}
self
.
has_id_attribute_selectors
|
=
compound_visitor
.
has_id_attribute_selectors
;
self
.
has_class_attribute_selectors
|
=
compound_visitor
.
has_class_attribute_selectors
;
for
class
in
compound_visitor
.
classes
{
self
.
class_to_selector
.
entry
(
class
quirks_mode
)
.
or_insert_with
(
SelectorMap
:
:
new
)
.
insert
(
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
sequence_start
}
quirks_mode
)
;
}
for
id
in
compound_visitor
.
ids
{
self
.
id_to_selector
.
entry
(
id
quirks_mode
)
.
or_insert_with
(
SelectorMap
:
:
new
)
.
insert
(
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
sequence_start
}
quirks_mode
)
;
}
if
!
compound_visitor
.
state
.
is_empty
(
)
{
self
.
state_affecting_selectors
.
insert
(
StateDependency
{
dep
:
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
sequence_start
}
state
:
compound_visitor
.
state
}
quirks_mode
)
;
}
if
compound_visitor
.
other_attributes
{
self
.
other_attribute_affecting_selectors
.
insert
(
Dependency
{
selector
:
selector
.
clone
(
)
selector_offset
:
sequence_start
}
quirks_mode
)
;
}
combinator
=
iter
.
next_sequence
(
)
;
if
combinator
.
is_none
(
)
{
break
;
}
index
+
=
1
;
}
}
}
struct
CompoundSelectorDependencyCollector
{
state
:
ElementState
classes
:
SmallVec
<
[
Atom
;
5
]
>
ids
:
SmallVec
<
[
Atom
;
5
]
>
other_attributes
:
bool
has_id_attribute_selectors
:
bool
has_class_attribute_selectors
:
bool
}
impl
SelectorVisitor
for
CompoundSelectorDependencyCollector
{
type
Impl
=
SelectorImpl
;
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
selector_parser
:
:
NonTSPseudoClass
;
match
*
s
{
Component
:
:
ID
(
ref
id
)
=
>
{
self
.
ids
.
push
(
id
.
clone
(
)
)
;
}
Component
:
:
Class
(
ref
class
)
=
>
{
self
.
classes
.
push
(
class
.
clone
(
)
)
;
}
Component
:
:
NonTSPseudoClass
(
ref
pc
)
=
>
{
self
.
other_attributes
|
=
pc
.
is_attr_based
(
)
;
self
.
state
|
=
match
*
pc
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
Dir
(
ref
s
)
=
>
{
dir_selector_to_state
(
s
)
}
_
=
>
pc
.
state_flag
(
)
}
;
}
_
=
>
{
}
}
true
}
fn
visit_attribute_selector
(
&
mut
self
constraint
:
&
NamespaceConstraint
<
&
Namespace
>
_local_name
:
&
LocalName
local_name_lower
:
&
LocalName
)
-
>
bool
{
self
.
other_attributes
=
true
;
let
may_match_in_no_namespace
=
match
*
constraint
{
NamespaceConstraint
:
:
Any
=
>
true
NamespaceConstraint
:
:
Specific
(
ref
ns
)
=
>
ns
.
is_empty
(
)
}
;
if
may_match_in_no_namespace
{
self
.
has_id_attribute_selectors
|
=
*
local_name_lower
=
=
local_name
!
(
"
id
"
)
;
self
.
has_class_attribute_selectors
|
=
*
local_name_lower
=
=
local_name
!
(
"
class
"
)
;
}
true
}
}
