use
crate
:
:
traversal_flags
:
:
TraversalFlags
;
bitflags
!
{
/
/
/
The
kind
of
restyle
we
need
to
do
for
a
given
element
.
#
[
repr
(
C
)
]
pub
struct
RestyleHint
:
u8
{
/
/
/
Do
a
selector
match
of
the
element
.
const
RESTYLE_SELF
=
1
<
<
0
;
/
/
/
Do
a
selector
match
of
the
element
'
s
descendants
.
const
RESTYLE_DESCENDANTS
=
1
<
<
1
;
/
/
/
Recascade
the
current
element
.
const
RECASCADE_SELF
=
1
<
<
2
;
/
/
/
Recascade
all
descendant
elements
.
const
RECASCADE_DESCENDANTS
=
1
<
<
3
;
/
/
/
Replace
the
style
data
coming
from
CSS
transitions
without
updating
/
/
/
any
other
style
data
.
This
hint
is
only
processed
in
animation
-
only
/
/
/
traversal
which
is
prior
to
normal
traversal
.
const
RESTYLE_CSS_TRANSITIONS
=
1
<
<
4
;
/
/
/
Replace
the
style
data
coming
from
CSS
animations
without
updating
/
/
/
any
other
style
data
.
This
hint
is
only
processed
in
animation
-
only
/
/
/
traversal
which
is
prior
to
normal
traversal
.
const
RESTYLE_CSS_ANIMATIONS
=
1
<
<
5
;
/
/
/
Don
'
t
re
-
run
selector
-
matching
on
the
element
only
the
style
/
/
/
attribute
has
changed
and
this
change
didn
'
t
have
any
other
/
/
/
dependencies
.
const
RESTYLE_STYLE_ATTRIBUTE
=
1
<
<
6
;
/
/
/
Replace
the
style
data
coming
from
SMIL
animations
without
updating
/
/
/
any
other
style
data
.
This
hint
is
only
processed
in
animation
-
only
/
/
/
traversal
which
is
prior
to
normal
traversal
.
const
RESTYLE_SMIL
=
1
<
<
7
;
}
}
impl
RestyleHint
{
pub
fn
restyle_subtree
(
)
-
>
Self
{
RestyleHint
:
:
RESTYLE_SELF
|
RestyleHint
:
:
RESTYLE_DESCENDANTS
}
pub
fn
recascade_subtree
(
)
-
>
Self
{
RestyleHint
:
:
RECASCADE_SELF
|
RestyleHint
:
:
RECASCADE_DESCENDANTS
}
pub
fn
contains_subtree
(
&
self
)
-
>
bool
{
self
.
contains
(
RestyleHint
:
:
RESTYLE_SELF
|
RestyleHint
:
:
RESTYLE_DESCENDANTS
)
}
pub
fn
has_non_animation_invalidations
(
&
self
)
-
>
bool
{
self
.
intersects
(
RestyleHint
:
:
RESTYLE_SELF
|
RestyleHint
:
:
RECASCADE_SELF
|
(
Self
:
:
replacements
(
)
&
!
Self
:
:
for_animations
(
)
)
)
}
pub
fn
propagate
(
&
mut
self
traversal_flags
:
&
TraversalFlags
)
-
>
Self
{
use
std
:
:
mem
;
if
traversal_flags
.
for_animation_only
(
)
{
self
.
remove_animation_hints
(
)
;
return
Self
:
:
empty
(
)
;
}
debug_assert
!
(
!
self
.
has_animation_hint
(
)
"
There
should
not
be
any
animation
restyle
hints
\
during
normal
traversal
"
)
;
mem
:
:
replace
(
self
Self
:
:
empty
(
)
)
.
propagate_for_non_animation_restyle
(
)
}
fn
propagate_for_non_animation_restyle
(
&
self
)
-
>
Self
{
if
self
.
contains
(
RestyleHint
:
:
RESTYLE_DESCENDANTS
)
{
return
Self
:
:
restyle_subtree
(
)
;
}
if
self
.
contains
(
RestyleHint
:
:
RECASCADE_DESCENDANTS
)
{
return
Self
:
:
recascade_subtree
(
)
;
}
Self
:
:
empty
(
)
}
pub
fn
replacements
(
)
-
>
Self
{
RestyleHint
:
:
RESTYLE_STYLE_ATTRIBUTE
|
Self
:
:
for_animations
(
)
}
#
[
inline
]
pub
fn
for_animations
(
)
-
>
Self
{
RestyleHint
:
:
RESTYLE_SMIL
|
RestyleHint
:
:
RESTYLE_CSS_ANIMATIONS
|
RestyleHint
:
:
RESTYLE_CSS_TRANSITIONS
}
pub
fn
has_recascade_self
(
&
self
)
-
>
bool
{
self
.
contains
(
RestyleHint
:
:
RECASCADE_SELF
)
}
#
[
inline
]
pub
fn
has_animation_hint
(
&
self
)
-
>
bool
{
self
.
intersects
(
Self
:
:
for_animations
(
)
)
}
#
[
inline
]
pub
fn
has_animation_hint_or_recascade
(
&
self
)
-
>
bool
{
self
.
intersects
(
Self
:
:
for_animations
(
)
|
RestyleHint
:
:
RECASCADE_SELF
)
}
#
[
inline
]
pub
fn
has_non_animation_hint
(
&
self
)
-
>
bool
{
!
(
*
self
&
!
Self
:
:
for_animations
(
)
)
.
is_empty
(
)
}
#
[
inline
]
pub
fn
match_self
(
&
self
)
-
>
bool
{
self
.
intersects
(
RestyleHint
:
:
RESTYLE_SELF
)
}
#
[
inline
]
pub
fn
has_replacements
(
&
self
)
-
>
bool
{
self
.
intersects
(
Self
:
:
replacements
(
)
)
}
#
[
inline
]
pub
fn
remove_animation_hints
(
&
mut
self
)
{
self
.
remove
(
Self
:
:
for_animations
(
)
)
;
self
.
remove
(
RestyleHint
:
:
RECASCADE_SELF
)
;
}
}
impl
Default
for
RestyleHint
{
fn
default
(
)
-
>
Self
{
Self
:
:
empty
(
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
malloc_size_of_is_0
!
(
RestyleHint
)
;
