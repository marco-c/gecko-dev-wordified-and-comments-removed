#
!
[
deny
(
missing_docs
)
]
use
crate
:
:
context
:
:
{
PerThreadTraversalStatistics
StyleContext
}
;
use
crate
:
:
context
:
:
{
ThreadLocalStyleContext
TraversalStatistics
}
;
use
crate
:
:
dom
:
:
{
SendNode
TElement
TNode
}
;
use
crate
:
:
parallel
;
use
crate
:
:
parallel
:
:
{
work_unit_max
DispatchMode
}
;
use
crate
:
:
scoped_tls
:
:
ScopedTLS
;
use
crate
:
:
traversal
:
:
{
DomTraversal
PerLevelTraversalData
PreTraverseToken
}
;
use
rayon
;
use
std
:
:
collections
:
:
VecDeque
;
use
std
:
:
mem
;
use
time
;
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
should_report_statistics
(
)
-
>
bool
{
false
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
should_report_statistics
(
)
-
>
bool
{
unsafe
{
crate
:
:
gecko_bindings
:
:
structs
:
:
ServoTraversalStatistics_sActive
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
report_statistics
(
_stats
:
&
PerThreadTraversalStatistics
)
{
unreachable
!
(
"
Servo
never
report
stats
"
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
report_statistics
(
stats
:
&
PerThreadTraversalStatistics
)
{
debug_assert
!
(
unsafe
{
crate
:
:
gecko_bindings
:
:
bindings
:
:
Gecko_IsMainThread
(
)
}
)
;
let
gecko_stats
=
unsafe
{
&
mut
crate
:
:
gecko_bindings
:
:
structs
:
:
ServoTraversalStatistics_sSingleton
}
;
gecko_stats
.
mElementsTraversed
+
=
stats
.
elements_traversed
;
gecko_stats
.
mElementsStyled
+
=
stats
.
elements_styled
;
gecko_stats
.
mElementsMatched
+
=
stats
.
elements_matched
;
gecko_stats
.
mStylesShared
+
=
stats
.
styles_shared
;
gecko_stats
.
mStylesReused
+
=
stats
.
styles_reused
;
}
fn
parallelism_threshold
(
)
-
>
usize
{
static_prefs
:
:
pref
!
(
"
layout
.
css
.
stylo
-
parallelism
-
threshold
"
)
as
usize
}
pub
fn
traverse_dom
<
E
D
>
(
traversal
:
&
D
token
:
PreTraverseToken
<
E
>
pool
:
Option
<
&
rayon
:
:
ThreadPool
>
)
-
>
E
where
E
:
TElement
D
:
DomTraversal
<
E
>
{
let
root
=
token
.
traversal_root
(
)
.
expect
(
"
Should
'
ve
ensured
we
needed
to
traverse
"
)
;
let
report_stats
=
should_report_statistics
(
)
;
let
dump_stats
=
traversal
.
shared_context
(
)
.
options
.
dump_style_statistics
;
let
start_time
=
if
dump_stats
{
Some
(
time
:
:
precise_time_s
(
)
)
}
else
{
None
}
;
let
mut
tls_slots
=
None
;
let
mut
tlc
=
ThreadLocalStyleContext
:
:
new
(
)
;
let
mut
context
=
StyleContext
{
shared
:
traversal
.
shared_context
(
)
thread_local
:
&
mut
tlc
}
;
let
work_unit_max
=
work_unit_max
(
)
;
let
parallelism_threshold
=
parallelism_threshold
(
)
;
let
mut
discovered
=
VecDeque
:
:
<
SendNode
<
E
:
:
ConcreteNode
>
>
:
:
with_capacity
(
work_unit_max
*
2
)
;
let
mut
depth
=
root
.
depth
(
)
;
let
mut
nodes_remaining_at_current_depth
=
1
;
discovered
.
push_back
(
unsafe
{
SendNode
:
:
new
(
root
.
as_node
(
)
)
}
)
;
while
let
Some
(
node
)
=
discovered
.
pop_front
(
)
{
let
mut
children_to_process
=
0isize
;
let
traversal_data
=
PerLevelTraversalData
{
current_dom_depth
:
depth
}
;
traversal
.
process_preorder
(
&
traversal_data
&
mut
context
*
node
|
n
|
{
children_to_process
+
=
1
;
discovered
.
push_back
(
unsafe
{
SendNode
:
:
new
(
n
)
}
)
;
}
)
;
traversal
.
handle_postorder_traversal
(
&
mut
context
root
.
as_node
(
)
.
opaque
(
)
*
node
children_to_process
)
;
nodes_remaining_at_current_depth
-
=
1
;
if
nodes_remaining_at_current_depth
!
=
0
{
continue
;
}
depth
+
=
1
;
if
pool
.
is_some
(
)
&
&
discovered
.
len
(
)
>
parallelism_threshold
&
&
parallelism_threshold
>
0
{
let
pool
=
pool
.
unwrap
(
)
;
let
tls
=
ScopedTLS
:
:
<
ThreadLocalStyleContext
<
E
>
>
:
:
new
(
pool
)
;
let
root_opaque
=
root
.
as_node
(
)
.
opaque
(
)
;
pool
.
scope_fifo
(
|
scope
|
{
gecko_profiler_label
!
(
Layout
StyleComputation
)
;
parallel
:
:
traverse_nodes
(
discovered
.
make_contiguous
(
)
DispatchMode
:
:
TailCall
true
root_opaque
PerLevelTraversalData
{
current_dom_depth
:
depth
}
scope
pool
traversal
&
tls
)
;
}
)
;
tls_slots
=
Some
(
tls
.
into_slots
(
)
)
;
break
;
}
nodes_remaining_at_current_depth
=
discovered
.
len
(
)
;
}
if
dump_stats
|
|
report_stats
{
let
mut
aggregate
=
mem
:
:
replace
(
&
mut
context
.
thread_local
.
statistics
Default
:
:
default
(
)
)
;
let
parallel
=
tls_slots
.
is_some
(
)
;
if
let
Some
(
ref
mut
tls
)
=
tls_slots
{
for
slot
in
tls
.
iter_mut
(
)
{
if
let
Some
(
cx
)
=
slot
.
get_mut
(
)
{
aggregate
+
=
cx
.
statistics
.
clone
(
)
;
}
}
}
if
report_stats
{
report_statistics
(
&
aggregate
)
;
}
if
dump_stats
{
let
stats
=
TraversalStatistics
:
:
new
(
aggregate
traversal
parallel
start_time
.
unwrap
(
)
)
;
if
stats
.
is_large
{
println
!
(
"
{
}
"
stats
)
;
}
}
}
root
}
