use
context
:
:
SharedStyleContext
;
use
dom
:
:
TElement
;
use
invalidation
:
:
element
:
:
restyle_hints
:
:
RestyleHint
;
use
properties
:
:
ComputedValues
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
as
display
;
use
rule_tree
:
:
StrongRuleNode
;
use
selector_parser
:
:
{
EAGER_PSEUDO_COUNT
PseudoElement
RestyleDamage
}
;
use
servo_arc
:
:
Arc
;
use
shared_lock
:
:
StylesheetGuards
;
use
std
:
:
fmt
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
stylesheets
:
:
{
MallocSizeOfWithRepeats
SizeOfState
}
;
bitflags
!
{
flags
RestyleFlags
:
u8
{
/
/
/
Whether
the
styles
changed
for
this
restyle
.
const
WAS_RESTYLED
=
1
<
<
0
/
/
/
Whether
we
reframed
/
reconstructed
any
ancestor
or
self
.
const
ANCESTOR_WAS_RECONSTRUCTED
=
1
<
<
1
}
}
#
[
derive
(
Debug
)
]
pub
struct
RestyleData
{
pub
hint
:
RestyleHint
flags
:
RestyleFlags
pub
damage
:
RestyleDamage
}
impl
Default
for
RestyleData
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
RestyleData
{
fn
new
(
)
-
>
Self
{
Self
{
hint
:
RestyleHint
:
:
empty
(
)
flags
:
RestyleFlags
:
:
empty
(
)
damage
:
RestyleDamage
:
:
empty
(
)
}
}
fn
clear
(
&
mut
self
)
{
*
self
=
Self
:
:
new
(
)
;
}
fn
clear_flags_and_damage
(
&
mut
self
)
{
self
.
damage
=
RestyleDamage
:
:
empty
(
)
;
self
.
flags
=
RestyleFlags
:
:
empty
(
)
;
}
pub
fn
reconstructed_self_or_ancestor
(
&
self
)
-
>
bool
{
self
.
reconstructed_ancestor
(
)
|
|
self
.
reconstructed_self
(
)
}
pub
fn
reconstructed_self
(
&
self
)
-
>
bool
{
self
.
damage
.
contains
(
RestyleDamage
:
:
reconstruct
(
)
)
}
fn
reconstructed_ancestor
(
&
self
)
-
>
bool
{
self
.
flags
.
contains
(
ANCESTOR_WAS_RECONSTRUCTED
)
}
pub
fn
set_reconstructed_ancestor
(
&
mut
self
)
{
self
.
flags
.
insert
(
ANCESTOR_WAS_RECONSTRUCTED
)
;
}
pub
fn
set_restyled
(
&
mut
self
)
{
self
.
flags
.
insert
(
WAS_RESTYLED
)
;
}
pub
fn
is_restyle
(
&
self
)
-
>
bool
{
self
.
flags
.
contains
(
WAS_RESTYLED
)
}
pub
fn
contains_restyle_data
(
&
self
)
-
>
bool
{
self
.
is_restyle
(
)
|
|
!
self
.
hint
.
is_empty
(
)
|
|
!
self
.
damage
.
is_empty
(
)
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
EagerPseudoStyles
(
Option
<
Arc
<
EagerPseudoArray
>
>
)
;
#
[
derive
(
Default
)
]
struct
EagerPseudoArray
(
EagerPseudoArrayInner
)
;
type
EagerPseudoArrayInner
=
[
Option
<
Arc
<
ComputedValues
>
>
;
EAGER_PSEUDO_COUNT
]
;
impl
Deref
for
EagerPseudoArray
{
type
Target
=
EagerPseudoArrayInner
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
EagerPseudoArray
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
impl
Clone
for
EagerPseudoArray
{
fn
clone
(
&
self
)
-
>
Self
{
let
mut
clone
=
Self
:
:
default
(
)
;
for
i
in
0
.
.
EAGER_PSEUDO_COUNT
{
clone
[
i
]
=
self
.
0
[
i
]
.
clone
(
)
;
}
clone
}
}
impl
fmt
:
:
Debug
for
EagerPseudoArray
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
EagerPseudoArray
{
{
"
)
?
;
for
i
in
0
.
.
EAGER_PSEUDO_COUNT
{
if
let
Some
(
ref
values
)
=
self
[
i
]
{
write
!
(
f
"
{
:
?
}
:
{
:
?
}
"
PseudoElement
:
:
from_eager_index
(
i
)
&
values
.
rules
)
?
;
}
}
write
!
(
f
"
}
}
"
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
const
EMPTY_PSEUDO_ARRAY
:
&
'
static
EagerPseudoArrayInner
=
&
[
None
None
None
None
]
;
#
[
cfg
(
feature
=
"
servo
"
)
]
const
EMPTY_PSEUDO_ARRAY
:
&
'
static
EagerPseudoArrayInner
=
&
[
None
None
None
]
;
impl
EagerPseudoStyles
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_none
(
)
}
pub
fn
as_optional_array
(
&
self
)
-
>
Option
<
&
EagerPseudoArrayInner
>
{
match
self
.
0
{
None
=
>
None
Some
(
ref
x
)
=
>
Some
(
&
x
.
0
)
}
}
pub
fn
as_array
(
&
self
)
-
>
&
EagerPseudoArrayInner
{
self
.
as_optional_array
(
)
.
unwrap_or
(
EMPTY_PSEUDO_ARRAY
)
}
pub
fn
get
(
&
self
pseudo
:
&
PseudoElement
)
-
>
Option
<
&
Arc
<
ComputedValues
>
>
{
debug_assert
!
(
pseudo
.
is_eager
(
)
)
;
self
.
0
.
as_ref
(
)
.
and_then
(
|
p
|
p
[
pseudo
.
eager_index
(
)
]
.
as_ref
(
)
)
}
pub
fn
set
(
&
mut
self
pseudo
:
&
PseudoElement
value
:
Arc
<
ComputedValues
>
)
{
if
self
.
0
.
is_none
(
)
{
self
.
0
=
Some
(
Arc
:
:
new
(
Default
:
:
default
(
)
)
)
;
}
let
arr
=
Arc
:
:
make_mut
(
self
.
0
.
as_mut
(
)
.
unwrap
(
)
)
;
arr
[
pseudo
.
eager_index
(
)
]
=
Some
(
value
)
;
}
}
#
[
derive
(
Clone
Default
)
]
pub
struct
ElementStyles
{
pub
primary
:
Option
<
Arc
<
ComputedValues
>
>
pub
pseudos
:
EagerPseudoStyles
}
impl
ElementStyles
{
pub
fn
get_primary
(
&
self
)
-
>
Option
<
&
Arc
<
ComputedValues
>
>
{
self
.
primary
.
as_ref
(
)
}
pub
fn
primary
(
&
self
)
-
>
&
Arc
<
ComputedValues
>
{
self
.
primary
.
as_ref
(
)
.
unwrap
(
)
}
pub
fn
is_display_none
(
&
self
)
-
>
bool
{
self
.
primary
(
)
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
T
:
:
none
}
}
impl
fmt
:
:
Debug
for
ElementStyles
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
ElementStyles
{
{
primary
:
{
:
?
}
pseudos
:
{
:
?
}
}
}
"
self
.
primary
.
as_ref
(
)
.
map
(
|
x
|
&
x
.
rules
)
self
.
pseudos
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
MallocSizeOfWithRepeats
for
ElementStyles
{
fn
malloc_size_of_children
(
&
self
state
:
&
mut
SizeOfState
)
-
>
usize
{
let
mut
n
=
0
;
if
let
Some
(
ref
primary
)
=
self
.
primary
{
n
+
=
primary
.
malloc_size_of_children
(
state
)
}
;
n
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
ElementData
{
pub
styles
:
ElementStyles
pub
restyle
:
RestyleData
}
#
[
derive
(
Debug
)
]
pub
enum
RestyleKind
{
MatchAndCascade
CascadeWithReplacements
(
RestyleHint
)
CascadeOnly
}
impl
ElementData
{
pub
fn
invalidate_style_if_needed
<
'
a
E
:
TElement
>
(
&
mut
self
element
:
E
shared_context
:
&
SharedStyleContext
)
{
if
shared_context
.
traversal_flags
.
for_animation_only
(
)
{
return
;
}
use
invalidation
:
:
element
:
:
invalidator
:
:
TreeStyleInvalidator
;
debug
!
(
"
invalidate_style_if_needed
:
{
:
?
}
flags
:
{
:
?
}
has_snapshot
:
{
}
\
handled_snapshot
:
{
}
pseudo
:
{
:
?
}
"
element
shared_context
.
traversal_flags
element
.
has_snapshot
(
)
element
.
handled_snapshot
(
)
element
.
implemented_pseudo_element
(
)
)
;
if
element
.
has_snapshot
(
)
&
&
!
element
.
handled_snapshot
(
)
{
let
invalidator
=
TreeStyleInvalidator
:
:
new
(
element
Some
(
self
)
shared_context
)
;
invalidator
.
invalidate
(
)
;
unsafe
{
element
.
set_handled_snapshot
(
)
}
debug_assert
!
(
element
.
handled_snapshot
(
)
)
;
}
}
pub
fn
has_styles
(
&
self
)
-
>
bool
{
self
.
styles
.
primary
.
is_some
(
)
}
pub
fn
restyle_kind
(
&
self
shared_context
:
&
SharedStyleContext
)
-
>
RestyleKind
{
if
shared_context
.
traversal_flags
.
for_animation_only
(
)
{
return
self
.
restyle_kind_for_animation
(
shared_context
)
;
}
if
!
self
.
has_styles
(
)
{
return
RestyleKind
:
:
MatchAndCascade
;
}
let
hint
=
self
.
restyle
.
hint
;
if
hint
.
match_self
(
)
{
return
RestyleKind
:
:
MatchAndCascade
;
}
if
hint
.
has_replacements
(
)
{
debug_assert
!
(
!
hint
.
has_animation_hint
(
)
"
Animation
only
restyle
hint
should
have
already
processed
"
)
;
return
RestyleKind
:
:
CascadeWithReplacements
(
hint
&
RestyleHint
:
:
replacements
(
)
)
;
}
debug_assert
!
(
hint
.
has_recascade_self
(
)
"
We
definitely
need
to
do
something
:
{
:
?
}
!
"
hint
)
;
return
RestyleKind
:
:
CascadeOnly
;
}
fn
restyle_kind_for_animation
(
&
self
shared_context
:
&
SharedStyleContext
)
-
>
RestyleKind
{
debug_assert
!
(
shared_context
.
traversal_flags
.
for_animation_only
(
)
)
;
debug_assert
!
(
self
.
has_styles
(
)
"
Unstyled
element
shouldn
'
t
be
traversed
during
\
animation
-
only
traversal
"
)
;
let
hint
=
self
.
restyle
.
hint
;
if
hint
.
has_animation_hint
(
)
{
return
RestyleKind
:
:
CascadeWithReplacements
(
hint
&
RestyleHint
:
:
for_animations
(
)
)
;
}
return
RestyleKind
:
:
CascadeOnly
;
}
pub
fn
important_rules_are_different
(
&
self
rules
:
&
StrongRuleNode
guards
:
&
StylesheetGuards
)
-
>
bool
{
debug_assert
!
(
self
.
has_styles
(
)
)
;
let
(
important_rules
_custom
)
=
self
.
styles
.
primary
(
)
.
rules
(
)
.
get_properties_overriding_animations
(
&
guards
)
;
let
(
other_important_rules
_custom
)
=
rules
.
get_properties_overriding_animations
(
&
guards
)
;
important_rules
!
=
other_important_rules
}
pub
fn
clear_restyle_state
(
&
mut
self
)
{
self
.
restyle
.
clear
(
)
;
}
pub
fn
clear_restyle_flags_and_damage
(
&
mut
self
)
{
self
.
restyle
.
clear_flags_and_damage
(
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
MallocSizeOfWithRepeats
for
ElementData
{
fn
malloc_size_of_children
(
&
self
state
:
&
mut
SizeOfState
)
-
>
usize
{
let
n
=
self
.
styles
.
malloc_size_of_children
(
state
)
;
n
}
}
