use
crate
:
:
computed_value_flags
:
:
ComputedValueFlags
;
use
crate
:
:
context
:
:
{
SharedStyleContext
StackLimitChecker
}
;
use
crate
:
:
dom
:
:
TElement
;
use
crate
:
:
invalidation
:
:
element
:
:
invalidator
:
:
InvalidationResult
;
use
crate
:
:
invalidation
:
:
element
:
:
restyle_hints
:
:
RestyleHint
;
use
crate
:
:
properties
:
:
ComputedValues
;
use
crate
:
:
selector_parser
:
:
{
PseudoElement
RestyleDamage
EAGER_PSEUDO_COUNT
}
;
use
crate
:
:
style_resolver
:
:
{
PrimaryStyle
ResolvedElementStyles
ResolvedStyle
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
malloc_size_of
:
:
MallocSizeOfOps
;
use
selectors
:
:
NthIndexCache
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
;
use
std
:
:
mem
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
bitflags
!
{
/
/
/
Various
flags
stored
on
ElementData
.
#
[
derive
(
Default
)
]
pub
struct
ElementDataFlags
:
u8
{
/
/
/
Whether
the
styles
changed
for
this
restyle
.
const
WAS_RESTYLED
=
1
<
<
0
;
/
/
/
Whether
the
last
traversal
of
this
element
did
not
do
/
/
/
any
style
computation
.
This
is
not
true
during
the
initial
/
/
/
styling
pass
nor
is
it
true
when
we
restyle
(
in
which
case
/
/
/
WAS_RESTYLED
is
set
)
.
/
/
/
/
/
/
This
bit
always
corresponds
to
the
last
time
the
element
was
/
/
/
traversed
so
each
traversal
simply
updates
it
with
the
appropriate
/
/
/
value
.
const
TRAVERSED_WITHOUT_STYLING
=
1
<
<
1
;
/
/
/
Whether
the
primary
style
of
this
element
data
was
reused
from
/
/
/
another
element
via
a
rule
node
comparison
.
This
allows
us
to
/
/
/
differentiate
between
elements
that
shared
styles
because
they
met
/
/
/
all
the
criteria
of
the
style
sharing
cache
compared
to
elements
/
/
/
that
reused
style
structs
via
rule
node
identity
.
/
/
/
/
/
/
The
former
gives
us
stronger
transitive
guarantees
that
allows
us
to
/
/
/
apply
the
style
sharing
cache
to
cousins
.
const
PRIMARY_STYLE_REUSED_VIA_RULE_NODE
=
1
<
<
2
;
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
EagerPseudoStyles
(
Option
<
Arc
<
EagerPseudoArray
>
>
)
;
#
[
derive
(
Default
)
]
struct
EagerPseudoArray
(
EagerPseudoArrayInner
)
;
type
EagerPseudoArrayInner
=
[
Option
<
Arc
<
ComputedValues
>
>
;
EAGER_PSEUDO_COUNT
]
;
impl
Deref
for
EagerPseudoArray
{
type
Target
=
EagerPseudoArrayInner
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
EagerPseudoArray
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
impl
Clone
for
EagerPseudoArray
{
fn
clone
(
&
self
)
-
>
Self
{
let
mut
clone
=
Self
:
:
default
(
)
;
for
i
in
0
.
.
EAGER_PSEUDO_COUNT
{
clone
[
i
]
=
self
.
0
[
i
]
.
clone
(
)
;
}
clone
}
}
impl
fmt
:
:
Debug
for
EagerPseudoArray
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
EagerPseudoArray
{
{
"
)
?
;
for
i
in
0
.
.
EAGER_PSEUDO_COUNT
{
if
let
Some
(
ref
values
)
=
self
[
i
]
{
write
!
(
f
"
{
:
?
}
:
{
:
?
}
"
PseudoElement
:
:
from_eager_index
(
i
)
&
values
.
rules
)
?
;
}
}
write
!
(
f
"
}
}
"
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
const
EMPTY_PSEUDO_ARRAY
:
&
'
static
EagerPseudoArrayInner
=
&
[
None
None
None
None
]
;
#
[
cfg
(
feature
=
"
servo
"
)
]
const
EMPTY_PSEUDO_ARRAY
:
&
'
static
EagerPseudoArrayInner
=
&
[
None
None
None
]
;
impl
EagerPseudoStyles
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_none
(
)
}
pub
fn
as_optional_array
(
&
self
)
-
>
Option
<
&
EagerPseudoArrayInner
>
{
match
self
.
0
{
None
=
>
None
Some
(
ref
x
)
=
>
Some
(
&
x
.
0
)
}
}
pub
fn
as_array
(
&
self
)
-
>
&
EagerPseudoArrayInner
{
self
.
as_optional_array
(
)
.
unwrap_or
(
EMPTY_PSEUDO_ARRAY
)
}
pub
fn
get
(
&
self
pseudo
:
&
PseudoElement
)
-
>
Option
<
&
Arc
<
ComputedValues
>
>
{
debug_assert
!
(
pseudo
.
is_eager
(
)
)
;
self
.
0
.
as_ref
(
)
.
and_then
(
|
p
|
p
[
pseudo
.
eager_index
(
)
]
.
as_ref
(
)
)
}
pub
fn
set
(
&
mut
self
pseudo
:
&
PseudoElement
value
:
Arc
<
ComputedValues
>
)
{
if
self
.
0
.
is_none
(
)
{
self
.
0
=
Some
(
Arc
:
:
new
(
Default
:
:
default
(
)
)
)
;
}
let
arr
=
Arc
:
:
make_mut
(
self
.
0
.
as_mut
(
)
.
unwrap
(
)
)
;
arr
[
pseudo
.
eager_index
(
)
]
=
Some
(
value
)
;
}
}
#
[
derive
(
Clone
Default
)
]
pub
struct
ElementStyles
{
pub
primary
:
Option
<
Arc
<
ComputedValues
>
>
pub
pseudos
:
EagerPseudoStyles
}
size_of_test
!
(
ElementStyles
16
)
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
PartialOrd
Ord
)
]
pub
enum
ViewportUnitUsage
{
None
=
0
FromDeclaration
FromQuery
}
impl
ElementStyles
{
pub
fn
get_primary
(
&
self
)
-
>
Option
<
&
Arc
<
ComputedValues
>
>
{
self
.
primary
.
as_ref
(
)
}
pub
fn
primary
(
&
self
)
-
>
&
Arc
<
ComputedValues
>
{
self
.
primary
.
as_ref
(
)
.
unwrap
(
)
}
pub
fn
is_display_none
(
&
self
)
-
>
bool
{
self
.
primary
(
)
.
get_box
(
)
.
clone_display
(
)
.
is_none
(
)
}
pub
fn
viewport_unit_usage
(
&
self
)
-
>
ViewportUnitUsage
{
fn
usage_from_flags
(
flags
:
ComputedValueFlags
)
-
>
ViewportUnitUsage
{
if
flags
.
intersects
(
ComputedValueFlags
:
:
USES_VIEWPORT_UNITS_ON_CONTAINER_QUERIES
)
{
return
ViewportUnitUsage
:
:
FromQuery
;
}
if
flags
.
intersects
(
ComputedValueFlags
:
:
USES_VIEWPORT_UNITS
)
{
return
ViewportUnitUsage
:
:
FromDeclaration
;
}
ViewportUnitUsage
:
:
None
}
let
mut
usage
=
usage_from_flags
(
self
.
primary
(
)
.
flags
)
;
for
pseudo_style
in
self
.
pseudos
.
as_array
(
)
{
if
let
Some
(
ref
pseudo_style
)
=
pseudo_style
{
usage
=
std
:
:
cmp
:
:
max
(
usage
usage_from_flags
(
pseudo_style
.
flags
)
)
;
}
}
usage
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
size_of_excluding_cvs
(
&
self
_ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
0
}
}
impl
fmt
:
:
Debug
for
ElementStyles
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
ElementStyles
{
{
primary
:
{
:
?
}
pseudos
:
{
:
?
}
}
}
"
self
.
primary
.
as_ref
(
)
.
map
(
|
x
|
&
x
.
rules
)
self
.
pseudos
)
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
ElementData
{
pub
styles
:
ElementStyles
pub
damage
:
RestyleDamage
pub
hint
:
RestyleHint
pub
flags
:
ElementDataFlags
}
size_of_test
!
(
ElementData
24
)
;
#
[
derive
(
Debug
)
]
pub
enum
RestyleKind
{
MatchAndCascade
CascadeWithReplacements
(
RestyleHint
)
CascadeOnly
}
impl
ElementData
{
pub
fn
invalidate_style_if_needed
<
'
a
E
:
TElement
>
(
&
mut
self
element
:
E
shared_context
:
&
SharedStyleContext
stack_limit_checker
:
Option
<
&
StackLimitChecker
>
nth_index_cache
:
&
mut
NthIndexCache
)
-
>
InvalidationResult
{
if
shared_context
.
traversal_flags
.
for_animation_only
(
)
{
return
InvalidationResult
:
:
empty
(
)
;
}
use
crate
:
:
invalidation
:
:
element
:
:
invalidator
:
:
TreeStyleInvalidator
;
use
crate
:
:
invalidation
:
:
element
:
:
state_and_attributes
:
:
StateAndAttrInvalidationProcessor
;
debug
!
(
"
invalidate_style_if_needed
:
{
:
?
}
flags
:
{
:
?
}
has_snapshot
:
{
}
\
handled_snapshot
:
{
}
pseudo
:
{
:
?
}
"
element
shared_context
.
traversal_flags
element
.
has_snapshot
(
)
element
.
handled_snapshot
(
)
element
.
implemented_pseudo_element
(
)
)
;
if
!
element
.
has_snapshot
(
)
|
|
element
.
handled_snapshot
(
)
{
return
InvalidationResult
:
:
empty
(
)
;
}
let
mut
processor
=
StateAndAttrInvalidationProcessor
:
:
new
(
shared_context
element
self
nth_index_cache
)
;
let
invalidator
=
TreeStyleInvalidator
:
:
new
(
element
stack_limit_checker
&
mut
processor
)
;
let
result
=
invalidator
.
invalidate
(
)
;
unsafe
{
element
.
set_handled_snapshot
(
)
}
debug_assert
!
(
element
.
handled_snapshot
(
)
)
;
result
}
#
[
inline
]
pub
fn
has_styles
(
&
self
)
-
>
bool
{
self
.
styles
.
primary
.
is_some
(
)
}
pub
fn
share_styles
(
&
self
)
-
>
ResolvedElementStyles
{
ResolvedElementStyles
{
primary
:
self
.
share_primary_style
(
)
pseudos
:
self
.
styles
.
pseudos
.
clone
(
)
}
}
pub
fn
share_primary_style
(
&
self
)
-
>
PrimaryStyle
{
let
reused_via_rule_node
=
self
.
flags
.
contains
(
ElementDataFlags
:
:
PRIMARY_STYLE_REUSED_VIA_RULE_NODE
)
;
PrimaryStyle
{
style
:
ResolvedStyle
(
self
.
styles
.
primary
(
)
.
clone
(
)
)
reused_via_rule_node
}
}
pub
fn
set_styles
(
&
mut
self
new_styles
:
ResolvedElementStyles
)
-
>
ElementStyles
{
if
new_styles
.
primary
.
reused_via_rule_node
{
self
.
flags
.
insert
(
ElementDataFlags
:
:
PRIMARY_STYLE_REUSED_VIA_RULE_NODE
)
;
}
else
{
self
.
flags
.
remove
(
ElementDataFlags
:
:
PRIMARY_STYLE_REUSED_VIA_RULE_NODE
)
;
}
mem
:
:
replace
(
&
mut
self
.
styles
new_styles
.
into
(
)
)
}
pub
fn
restyle_kind
(
&
self
shared_context
:
&
SharedStyleContext
)
-
>
Option
<
RestyleKind
>
{
if
shared_context
.
traversal_flags
.
for_animation_only
(
)
{
return
self
.
restyle_kind_for_animation
(
shared_context
)
;
}
let
style
=
match
self
.
styles
.
primary
{
Some
(
ref
s
)
=
>
s
None
=
>
return
Some
(
RestyleKind
:
:
MatchAndCascade
)
}
;
let
hint
=
self
.
hint
;
if
hint
.
is_empty
(
)
{
return
None
;
}
let
needs_to_match_self
=
hint
.
intersects
(
RestyleHint
:
:
RESTYLE_SELF
)
|
|
(
hint
.
intersects
(
RestyleHint
:
:
RESTYLE_SELF_IF_PSEUDO
)
&
&
style
.
is_pseudo_style
(
)
)
;
if
needs_to_match_self
{
return
Some
(
RestyleKind
:
:
MatchAndCascade
)
;
}
if
hint
.
has_replacements
(
)
{
debug_assert
!
(
!
hint
.
has_animation_hint
(
)
"
Animation
only
restyle
hint
should
have
already
processed
"
)
;
return
Some
(
RestyleKind
:
:
CascadeWithReplacements
(
hint
&
RestyleHint
:
:
replacements
(
)
)
)
;
}
let
needs_to_recascade_self
=
hint
.
intersects
(
RestyleHint
:
:
RECASCADE_SELF
)
|
|
(
hint
.
intersects
(
RestyleHint
:
:
RECASCADE_SELF_IF_INHERIT_RESET_STYLE
)
&
&
style
.
flags
.
contains
(
ComputedValueFlags
:
:
INHERITS_RESET_STYLE
)
)
;
if
needs_to_recascade_self
{
return
Some
(
RestyleKind
:
:
CascadeOnly
)
;
}
None
}
fn
restyle_kind_for_animation
(
&
self
shared_context
:
&
SharedStyleContext
)
-
>
Option
<
RestyleKind
>
{
debug_assert
!
(
shared_context
.
traversal_flags
.
for_animation_only
(
)
)
;
debug_assert
!
(
self
.
has_styles
(
)
"
animation
traversal
doesn
'
t
care
about
unstyled
elements
"
)
;
let
hint
=
self
.
hint
;
if
self
.
styles
.
is_display_none
(
)
&
&
hint
.
intersects
(
RestyleHint
:
:
RESTYLE_SELF
)
{
return
None
;
}
let
style
=
self
.
styles
.
primary
(
)
;
if
hint
.
has_animation_hint
(
)
{
return
Some
(
RestyleKind
:
:
CascadeWithReplacements
(
hint
&
RestyleHint
:
:
for_animations
(
)
)
)
;
}
let
needs_to_recascade_self
=
hint
.
intersects
(
RestyleHint
:
:
RECASCADE_SELF
)
|
|
(
hint
.
intersects
(
RestyleHint
:
:
RECASCADE_SELF_IF_INHERIT_RESET_STYLE
)
&
&
style
.
flags
.
contains
(
ComputedValueFlags
:
:
INHERITS_RESET_STYLE
)
)
;
if
needs_to_recascade_self
{
return
Some
(
RestyleKind
:
:
CascadeOnly
)
;
}
return
None
;
}
#
[
inline
]
pub
fn
clear_restyle_state
(
&
mut
self
)
{
self
.
hint
=
RestyleHint
:
:
empty
(
)
;
self
.
clear_restyle_flags_and_damage
(
)
;
}
#
[
inline
]
pub
fn
clear_restyle_flags_and_damage
(
&
mut
self
)
{
self
.
damage
=
RestyleDamage
:
:
empty
(
)
;
self
.
flags
.
remove
(
ElementDataFlags
:
:
WAS_RESTYLED
)
;
}
pub
fn
set_restyled
(
&
mut
self
)
{
self
.
flags
.
insert
(
ElementDataFlags
:
:
WAS_RESTYLED
)
;
self
.
flags
.
remove
(
ElementDataFlags
:
:
TRAVERSED_WITHOUT_STYLING
)
;
}
#
[
inline
]
pub
fn
is_restyle
(
&
self
)
-
>
bool
{
self
.
flags
.
contains
(
ElementDataFlags
:
:
WAS_RESTYLED
)
}
pub
fn
set_traversed_without_styling
(
&
mut
self
)
{
self
.
flags
.
insert
(
ElementDataFlags
:
:
TRAVERSED_WITHOUT_STYLING
)
;
}
#
[
inline
]
pub
fn
contains_restyle_data
(
&
self
)
-
>
bool
{
self
.
is_restyle
(
)
|
|
!
self
.
hint
.
is_empty
(
)
|
|
!
self
.
damage
.
is_empty
(
)
}
pub
fn
safe_for_cousin_sharing
(
&
self
)
-
>
bool
{
if
self
.
flags
.
intersects
(
ElementDataFlags
:
:
TRAVERSED_WITHOUT_STYLING
|
ElementDataFlags
:
:
PRIMARY_STYLE_REUSED_VIA_RULE_NODE
)
{
return
false
;
}
if
!
self
.
styles
.
primary
(
)
.
get_box
(
)
.
clone_container_type
(
)
.
is_normal
(
)
{
return
false
;
}
true
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
size_of_excluding_cvs
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
n
=
self
.
styles
.
size_of_excluding_cvs
(
ops
)
;
n
}
}
