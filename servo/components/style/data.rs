use
context
:
:
SharedStyleContext
;
use
dom
:
:
TElement
;
use
properties
:
:
{
AnimationRules
ComputedValues
PropertyDeclarationBlock
}
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
as
display
;
use
restyle_hints
:
:
{
HintComputationContext
RestyleReplacements
RestyleHint
}
;
use
rule_tree
:
:
StrongRuleNode
;
use
selector_parser
:
:
{
EAGER_PSEUDO_COUNT
PseudoElement
RestyleDamage
}
;
use
shared_lock
:
:
{
Locked
StylesheetGuards
}
;
use
std
:
:
fmt
;
use
stylearc
:
:
Arc
;
use
traversal
:
:
TraversalFlags
;
#
[
derive
(
Clone
)
]
pub
struct
ComputedStyle
{
pub
rules
:
StrongRuleNode
pub
values
:
Option
<
Arc
<
ComputedValues
>
>
}
impl
ComputedStyle
{
pub
fn
new
(
rules
:
StrongRuleNode
values
:
Arc
<
ComputedValues
>
)
-
>
Self
{
ComputedStyle
{
rules
:
rules
values
:
Some
(
values
)
}
}
pub
fn
new_partial
(
rules
:
StrongRuleNode
)
-
>
Self
{
ComputedStyle
{
rules
:
rules
values
:
None
}
}
pub
fn
values
(
&
self
)
-
>
&
Arc
<
ComputedValues
>
{
self
.
values
.
as_ref
(
)
.
unwrap
(
)
}
pub
fn
values_mut
(
&
mut
self
)
-
>
&
mut
Arc
<
ComputedValues
>
{
self
.
values
.
as_mut
(
)
.
unwrap
(
)
}
}
impl
fmt
:
:
Debug
for
ComputedStyle
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
ComputedStyle
{
{
rules
:
{
:
?
}
values
:
{
{
.
.
}
}
}
}
"
self
.
rules
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
EagerPseudoStyles
(
Option
<
Box
<
[
Option
<
ComputedStyle
>
]
>
>
)
;
impl
EagerPseudoStyles
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_none
(
)
}
pub
fn
get
(
&
self
pseudo
:
&
PseudoElement
)
-
>
Option
<
&
ComputedStyle
>
{
debug_assert
!
(
pseudo
.
is_eager
(
)
)
;
self
.
0
.
as_ref
(
)
.
and_then
(
|
p
|
p
[
pseudo
.
eager_index
(
)
]
.
as_ref
(
)
)
}
pub
fn
get_mut
(
&
mut
self
pseudo
:
&
PseudoElement
)
-
>
Option
<
&
mut
ComputedStyle
>
{
debug_assert
!
(
pseudo
.
is_eager
(
)
)
;
self
.
0
.
as_mut
(
)
.
and_then
(
|
p
|
p
[
pseudo
.
eager_index
(
)
]
.
as_mut
(
)
)
}
pub
fn
has
(
&
self
pseudo
:
&
PseudoElement
)
-
>
bool
{
self
.
get
(
pseudo
)
.
is_some
(
)
}
pub
fn
insert
(
&
mut
self
pseudo
:
&
PseudoElement
style
:
ComputedStyle
)
{
debug_assert
!
(
!
self
.
has
(
pseudo
)
)
;
if
self
.
0
.
is_none
(
)
{
self
.
0
=
Some
(
vec
!
[
None
;
EAGER_PSEUDO_COUNT
]
.
into_boxed_slice
(
)
)
;
}
self
.
0
.
as_mut
(
)
.
unwrap
(
)
[
pseudo
.
eager_index
(
)
]
=
Some
(
style
)
;
}
pub
fn
take
(
&
mut
self
pseudo
:
&
PseudoElement
)
-
>
Option
<
ComputedStyle
>
{
let
result
=
match
self
.
0
.
as_mut
(
)
{
None
=
>
return
None
Some
(
arr
)
=
>
arr
[
pseudo
.
eager_index
(
)
]
.
take
(
)
}
;
let
empty
=
self
.
0
.
as_ref
(
)
.
unwrap
(
)
.
iter
(
)
.
all
(
|
x
|
x
.
is_none
(
)
)
;
if
empty
{
self
.
0
=
None
;
}
result
}
pub
fn
keys
(
&
self
)
-
>
Vec
<
PseudoElement
>
{
let
mut
v
=
Vec
:
:
new
(
)
;
if
let
Some
(
ref
arr
)
=
self
.
0
{
for
i
in
0
.
.
EAGER_PSEUDO_COUNT
{
if
arr
[
i
]
.
is_some
(
)
{
v
.
push
(
PseudoElement
:
:
from_eager_index
(
i
)
)
;
}
}
}
v
}
pub
fn
set_rules
(
&
mut
self
pseudo
:
&
PseudoElement
rules
:
StrongRuleNode
)
-
>
bool
{
debug_assert
!
(
self
.
has
(
pseudo
)
)
;
let
mut
style
=
self
.
get_mut
(
pseudo
)
.
unwrap
(
)
;
let
changed
=
style
.
rules
!
=
rules
;
style
.
rules
=
rules
;
changed
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ElementStyles
{
pub
primary
:
ComputedStyle
pub
pseudos
:
EagerPseudoStyles
}
impl
ElementStyles
{
pub
fn
new
(
primary
:
ComputedStyle
)
-
>
Self
{
ElementStyles
{
primary
:
primary
pseudos
:
EagerPseudoStyles
(
None
)
}
}
pub
fn
is_display_none
(
&
self
)
-
>
bool
{
self
.
primary
.
values
(
)
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
T
:
:
none
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
StoredRestyleHint
(
RestyleHint
)
;
impl
StoredRestyleHint
{
pub
fn
propagate
(
&
mut
self
traversal_flags
:
&
TraversalFlags
)
-
>
Self
{
use
std
:
:
mem
;
if
traversal_flags
.
for_animation_only
(
)
{
self
.
0
.
remove_animation_hints
(
)
;
return
Self
:
:
empty
(
)
;
}
debug_assert
!
(
!
self
.
0
.
has_animation_hint
(
)
"
There
should
not
be
any
animation
restyle
hints
\
during
normal
traversal
"
)
;
let
new_hint
=
mem
:
:
replace
(
&
mut
self
.
0
RestyleHint
:
:
empty
(
)
)
.
propagate_for_non_animation_restyle
(
)
;
StoredRestyleHint
(
new_hint
)
}
pub
fn
empty
(
)
-
>
Self
{
StoredRestyleHint
(
RestyleHint
:
:
empty
(
)
)
}
pub
fn
subtree
(
)
-
>
Self
{
StoredRestyleHint
(
RestyleHint
:
:
subtree
(
)
)
}
pub
fn
subtree_and_later_siblings
(
)
-
>
Self
{
StoredRestyleHint
(
RestyleHint
:
:
subtree_and_later_siblings
(
)
)
}
pub
fn
has_self_invalidations
(
&
self
)
-
>
bool
{
self
.
0
.
affects_self
(
)
}
pub
fn
has_sibling_invalidations
(
&
self
)
-
>
bool
{
self
.
0
.
affects_later_siblings
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_empty
(
)
}
pub
fn
insert
(
&
mut
self
other
:
Self
)
{
self
.
0
.
insert
(
other
.
0
)
}
pub
fn
insert_from
(
&
mut
self
other
:
&
Self
)
{
self
.
0
.
insert_from
(
&
other
.
0
)
}
pub
fn
has_animation_hint
(
&
self
)
-
>
bool
{
self
.
0
.
has_animation_hint
(
)
}
}
impl
Default
for
StoredRestyleHint
{
fn
default
(
)
-
>
Self
{
StoredRestyleHint
:
:
empty
(
)
}
}
impl
From
<
RestyleHint
>
for
StoredRestyleHint
{
fn
from
(
hint
:
RestyleHint
)
-
>
Self
{
StoredRestyleHint
(
hint
)
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
RestyleData
{
pub
hint
:
StoredRestyleHint
pub
recascade
:
bool
pub
damage
:
RestyleDamage
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
damage_handled
:
RestyleDamage
}
impl
RestyleData
{
pub
fn
has_invalidations
(
&
self
)
-
>
bool
{
self
.
hint
.
has_self_invalidations
(
)
|
|
self
.
recascade
}
pub
fn
has_sibling_invalidations
(
&
self
)
-
>
bool
{
self
.
hint
.
has_sibling_invalidations
(
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
damage_handled
(
&
self
)
-
>
RestyleDamage
{
self
.
damage_handled
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
damage_handled
(
&
self
)
-
>
RestyleDamage
{
RestyleDamage
:
:
empty
(
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
set_damage_handled
(
&
mut
self
d
:
RestyleDamage
)
{
self
.
damage_handled
=
d
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
set_damage_handled
(
&
mut
self
_
:
RestyleDamage
)
{
}
}
#
[
derive
(
Debug
)
]
pub
struct
ElementData
{
styles
:
Option
<
ElementStyles
>
restyle
:
Option
<
Box
<
RestyleData
>
>
}
pub
enum
RestyleKind
{
MatchAndCascade
CascadeWithReplacements
(
RestyleReplacements
)
CascadeOnly
}
impl
ElementData
{
pub
fn
compute_final_hint
<
'
a
E
:
TElement
>
(
&
mut
self
element
:
E
shared_context
:
&
SharedStyleContext
hint_context
:
HintComputationContext
<
'
a
E
>
)
-
>
bool
{
debug
!
(
"
compute_final_hint
:
{
:
?
}
{
:
?
}
"
element
shared_context
.
traversal_flags
)
;
let
mut
hint
=
match
self
.
get_restyle
(
)
{
Some
(
r
)
=
>
r
.
hint
.
0
.
clone
(
)
None
=
>
RestyleHint
:
:
empty
(
)
}
;
debug
!
(
"
compute_final_hint
:
{
:
?
}
has_snapshot
:
{
}
handled_snapshot
:
{
}
\
pseudo
:
{
:
?
}
"
element
element
.
has_snapshot
(
)
element
.
handled_snapshot
(
)
element
.
implemented_pseudo_element
(
)
)
;
if
element
.
has_snapshot
(
)
&
&
!
element
.
handled_snapshot
(
)
{
let
snapshot_hint
=
shared_context
.
stylist
.
compute_restyle_hint
(
&
element
shared_context
hint_context
)
;
hint
.
insert
(
snapshot_hint
)
;
unsafe
{
element
.
set_handled_snapshot
(
)
}
debug_assert
!
(
element
.
handled_snapshot
(
)
)
;
}
let
empty_hint
=
hint
.
is_empty
(
)
;
let
later_siblings
=
hint
.
remove_later_siblings_hint
(
)
;
if
!
empty_hint
{
self
.
ensure_restyle
(
)
.
hint
=
hint
.
into
(
)
;
}
later_siblings
}
pub
fn
new
(
existing
:
Option
<
ElementStyles
>
)
-
>
Self
{
ElementData
{
styles
:
existing
restyle
:
None
}
}
pub
fn
has_styles
(
&
self
)
-
>
bool
{
self
.
styles
.
is_some
(
)
}
pub
fn
has_invalidations
(
&
self
)
-
>
bool
{
self
.
restyle
.
as_ref
(
)
.
map_or
(
false
|
r
|
r
.
has_invalidations
(
)
)
}
pub
fn
restyle_kind
(
&
self
)
-
>
RestyleKind
{
debug_assert
!
(
!
self
.
has_styles
(
)
|
|
self
.
has_invalidations
(
)
"
Should
'
ve
stopped
earlier
"
)
;
if
!
self
.
has_styles
(
)
{
return
RestyleKind
:
:
MatchAndCascade
;
}
debug_assert
!
(
self
.
restyle
.
is_some
(
)
)
;
let
restyle_data
=
self
.
restyle
.
as_ref
(
)
.
unwrap
(
)
;
let
hint
=
&
restyle_data
.
hint
.
0
;
if
hint
.
match_self
(
)
{
return
RestyleKind
:
:
MatchAndCascade
;
}
if
!
hint
.
is_empty
(
)
{
return
RestyleKind
:
:
CascadeWithReplacements
(
hint
.
replacements
)
;
}
debug_assert
!
(
restyle_data
.
recascade
"
We
definitely
need
to
do
something
!
"
)
;
return
RestyleKind
:
:
CascadeOnly
;
}
pub
fn
get_styles
(
&
self
)
-
>
Option
<
&
ElementStyles
>
{
self
.
styles
.
as_ref
(
)
}
pub
fn
styles
(
&
self
)
-
>
&
ElementStyles
{
self
.
styles
.
as_ref
(
)
.
expect
(
"
Calling
styles
(
)
on
unstyled
ElementData
"
)
}
pub
fn
get_styles_mut
(
&
mut
self
)
-
>
Option
<
&
mut
ElementStyles
>
{
self
.
styles
.
as_mut
(
)
}
pub
fn
styles_mut
(
&
mut
self
)
-
>
&
mut
ElementStyles
{
self
.
styles
.
as_mut
(
)
.
expect
(
"
Calling
styles_mut
(
)
on
unstyled
ElementData
"
)
}
pub
fn
styles_and_restyle_mut
(
&
mut
self
)
-
>
(
&
mut
ElementStyles
Option
<
&
mut
RestyleData
>
)
{
(
self
.
styles
.
as_mut
(
)
.
unwrap
(
)
self
.
restyle
.
as_mut
(
)
.
map
(
|
r
|
&
mut
*
*
r
)
)
}
pub
fn
set_styles
(
&
mut
self
styles
:
ElementStyles
)
{
self
.
styles
=
Some
(
styles
)
;
}
pub
fn
set_primary_rules
(
&
mut
self
rules
:
StrongRuleNode
)
-
>
bool
{
if
!
self
.
has_styles
(
)
{
self
.
set_styles
(
ElementStyles
:
:
new
(
ComputedStyle
:
:
new_partial
(
rules
)
)
)
;
return
true
;
}
if
self
.
styles
(
)
.
primary
.
rules
=
=
rules
{
return
false
;
}
self
.
styles_mut
(
)
.
primary
.
rules
=
rules
;
true
}
pub
fn
important_rules_are_different
(
&
self
rules
:
&
StrongRuleNode
guards
:
&
StylesheetGuards
)
-
>
bool
{
debug_assert
!
(
self
.
has_styles
(
)
)
;
let
(
important_rules
_custom
)
=
self
.
styles
(
)
.
primary
.
rules
.
get_properties_overriding_animations
(
&
guards
)
;
let
(
other_important_rules
_custom
)
=
rules
.
get_properties_overriding_animations
(
&
guards
)
;
important_rules
!
=
other_important_rules
}
pub
fn
has_restyle
(
&
self
)
-
>
bool
{
self
.
restyle
.
is_some
(
)
}
pub
fn
clear_restyle
(
&
mut
self
)
{
self
.
restyle
=
None
;
}
pub
fn
ensure_restyle
(
&
mut
self
)
-
>
&
mut
RestyleData
{
debug_assert
!
(
self
.
styles
.
is_some
(
)
"
restyling
unstyled
element
"
)
;
if
self
.
restyle
.
is_none
(
)
{
self
.
restyle
=
Some
(
Box
:
:
new
(
RestyleData
:
:
default
(
)
)
)
;
}
self
.
restyle
.
as_mut
(
)
.
unwrap
(
)
}
pub
fn
get_restyle
(
&
self
)
-
>
Option
<
&
RestyleData
>
{
self
.
restyle
.
as_ref
(
)
.
map
(
|
r
|
&
*
*
r
)
}
pub
fn
restyle
(
&
self
)
-
>
&
RestyleData
{
self
.
get_restyle
(
)
.
expect
(
"
Calling
restyle
without
RestyleData
"
)
}
pub
fn
get_restyle_mut
(
&
mut
self
)
-
>
Option
<
&
mut
RestyleData
>
{
self
.
restyle
.
as_mut
(
)
.
map
(
|
r
|
&
mut
*
*
r
)
}
pub
fn
restyle_mut
(
&
mut
self
)
-
>
&
mut
RestyleData
{
self
.
get_restyle_mut
(
)
.
expect
(
"
Calling
restyle_mut
without
RestyleData
"
)
}
pub
fn
get_smil_override
(
&
self
)
-
>
Option
<
&
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
{
if
cfg
!
(
feature
=
"
servo
"
)
{
return
None
;
}
match
self
.
get_styles
(
)
{
Some
(
s
)
=
>
s
.
primary
.
rules
.
get_smil_animation_rule
(
)
None
=
>
None
}
}
pub
fn
get_animation_rules
(
&
self
)
-
>
AnimationRules
{
if
cfg
!
(
feature
=
"
servo
"
)
{
return
AnimationRules
(
None
None
)
}
match
self
.
get_styles
(
)
{
Some
(
s
)
=
>
s
.
primary
.
rules
.
get_animation_rules
(
)
None
=
>
AnimationRules
(
None
None
)
}
}
}
