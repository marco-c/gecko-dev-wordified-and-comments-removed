#
!
[
deny
(
missing_docs
)
]
use
dom
:
:
TElement
;
use
properties
:
:
ComputedValues
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
as
display
;
use
restyle_hints
:
:
{
RESTYLE_DESCENDANTS
RESTYLE_LATER_SIBLINGS
RESTYLE_SELF
RestyleHint
}
;
use
rule_tree
:
:
StrongRuleNode
;
use
selector_parser
:
:
{
EAGER_PSEUDO_COUNT
PseudoElement
RestyleDamage
Snapshot
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
std
:
:
hash
:
:
BuildHasherDefault
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
sync
:
:
Arc
;
use
stylist
:
:
Stylist
;
use
thread_state
;
use
traversal
:
:
TraversalFlags
;
#
[
derive
(
Clone
)
]
pub
struct
ComputedStyle
{
pub
rules
:
StrongRuleNode
pub
values
:
Option
<
Arc
<
ComputedValues
>
>
}
impl
ComputedStyle
{
pub
fn
new
(
rules
:
StrongRuleNode
values
:
Arc
<
ComputedValues
>
)
-
>
Self
{
ComputedStyle
{
rules
:
rules
values
:
Some
(
values
)
}
}
pub
fn
new_partial
(
rules
:
StrongRuleNode
)
-
>
Self
{
ComputedStyle
{
rules
:
rules
values
:
None
}
}
pub
fn
values
(
&
self
)
-
>
&
Arc
<
ComputedValues
>
{
self
.
values
.
as_ref
(
)
.
unwrap
(
)
}
pub
fn
values_mut
(
&
mut
self
)
-
>
&
mut
Arc
<
ComputedValues
>
{
self
.
values
.
as_mut
(
)
.
unwrap
(
)
}
}
impl
fmt
:
:
Debug
for
ComputedStyle
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
ComputedStyle
{
{
rules
:
{
:
?
}
values
:
{
{
.
.
}
}
}
}
"
self
.
rules
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
EagerPseudoStyles
(
Option
<
Box
<
[
Option
<
ComputedStyle
>
]
>
>
)
;
impl
EagerPseudoStyles
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_none
(
)
}
pub
fn
get
(
&
self
pseudo
:
&
PseudoElement
)
-
>
Option
<
&
ComputedStyle
>
{
debug_assert
!
(
pseudo
.
is_eager
(
)
)
;
self
.
0
.
as_ref
(
)
.
and_then
(
|
p
|
p
[
pseudo
.
eager_index
(
)
]
.
as_ref
(
)
)
}
pub
fn
get_mut
(
&
mut
self
pseudo
:
&
PseudoElement
)
-
>
Option
<
&
mut
ComputedStyle
>
{
debug_assert
!
(
pseudo
.
is_eager
(
)
)
;
self
.
0
.
as_mut
(
)
.
and_then
(
|
p
|
p
[
pseudo
.
eager_index
(
)
]
.
as_mut
(
)
)
}
pub
fn
has
(
&
self
pseudo
:
&
PseudoElement
)
-
>
bool
{
self
.
get
(
pseudo
)
.
is_some
(
)
}
pub
fn
insert
(
&
mut
self
pseudo
:
&
PseudoElement
style
:
ComputedStyle
)
{
debug_assert
!
(
!
self
.
has
(
pseudo
)
)
;
if
self
.
0
.
is_none
(
)
{
self
.
0
=
Some
(
vec
!
[
None
;
EAGER_PSEUDO_COUNT
]
.
into_boxed_slice
(
)
)
;
}
self
.
0
.
as_mut
(
)
.
unwrap
(
)
[
pseudo
.
eager_index
(
)
]
=
Some
(
style
)
;
}
pub
fn
take
(
&
mut
self
pseudo
:
&
PseudoElement
)
-
>
Option
<
ComputedStyle
>
{
let
result
=
match
self
.
0
.
as_mut
(
)
{
None
=
>
return
None
Some
(
arr
)
=
>
arr
[
pseudo
.
eager_index
(
)
]
.
take
(
)
}
;
let
empty
=
self
.
0
.
as_ref
(
)
.
unwrap
(
)
.
iter
(
)
.
all
(
|
x
|
x
.
is_none
(
)
)
;
if
empty
{
self
.
0
=
None
;
}
result
}
pub
fn
keys
(
&
self
)
-
>
Vec
<
PseudoElement
>
{
let
mut
v
=
Vec
:
:
new
(
)
;
if
let
Some
(
ref
arr
)
=
self
.
0
{
for
i
in
0
.
.
EAGER_PSEUDO_COUNT
{
if
arr
[
i
]
.
is_some
(
)
{
v
.
push
(
PseudoElement
:
:
from_eager_index
(
i
)
)
;
}
}
}
v
}
pub
fn
set_rules
(
&
mut
self
pseudo
:
&
PseudoElement
rules
:
StrongRuleNode
)
-
>
bool
{
debug_assert
!
(
self
.
has
(
pseudo
)
)
;
let
mut
style
=
self
.
get_mut
(
pseudo
)
.
unwrap
(
)
;
let
changed
=
style
.
rules
!
=
rules
;
style
.
rules
=
rules
;
changed
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
type
PseudoElementCache
=
HashMap
<
PseudoElement
ComputedStyle
BuildHasherDefault
<
:
:
fnv
:
:
FnvHasher
>
>
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
type
PseudoElementCache
=
(
)
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
ElementStyles
{
pub
primary
:
ComputedStyle
pub
pseudos
:
EagerPseudoStyles
pub
cached_pseudos
:
PseudoElementCache
}
impl
ElementStyles
{
pub
fn
new
(
primary
:
ComputedStyle
)
-
>
Self
{
ElementStyles
{
primary
:
primary
pseudos
:
EagerPseudoStyles
(
None
)
cached_pseudos
:
PseudoElementCache
:
:
default
(
)
}
}
pub
fn
is_display_none
(
&
self
)
-
>
bool
{
self
.
primary
.
values
(
)
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
T
:
:
none
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
StoredRestyleHint
(
RestyleHint
)
;
impl
StoredRestyleHint
{
pub
fn
propagate
(
&
mut
self
traversal_flags
:
&
TraversalFlags
)
-
>
Self
{
use
std
:
:
mem
;
if
traversal_flags
.
for_animation_only
(
)
{
if
self
.
0
.
intersects
(
RestyleHint
:
:
for_animations
(
)
)
{
self
.
0
.
remove
(
RestyleHint
:
:
for_animations
(
)
)
;
}
return
Self
:
:
empty
(
)
;
}
debug_assert
!
(
!
self
.
0
.
intersects
(
RestyleHint
:
:
for_animations
(
)
)
"
There
should
not
be
any
animation
restyle
hints
\
during
normal
traversal
"
)
;
let
hint
=
mem
:
:
replace
(
&
mut
self
.
0
RestyleHint
:
:
empty
(
)
)
;
StoredRestyleHint
(
if
hint
.
contains
(
RESTYLE_DESCENDANTS
)
{
RESTYLE_SELF
|
RESTYLE_DESCENDANTS
}
else
{
RestyleHint
:
:
empty
(
)
}
)
}
pub
fn
empty
(
)
-
>
Self
{
StoredRestyleHint
(
RestyleHint
:
:
empty
(
)
)
}
pub
fn
subtree
(
)
-
>
Self
{
StoredRestyleHint
(
RESTYLE_SELF
|
RESTYLE_DESCENDANTS
)
}
pub
fn
subtree_and_later_siblings
(
)
-
>
Self
{
StoredRestyleHint
(
RESTYLE_SELF
|
RESTYLE_DESCENDANTS
|
RESTYLE_LATER_SIBLINGS
)
}
pub
fn
has_self_invalidations
(
&
self
)
-
>
bool
{
self
.
0
.
intersects
(
RestyleHint
:
:
for_self
(
)
)
}
pub
fn
has_sibling_invalidations
(
&
self
)
-
>
bool
{
self
.
0
.
intersects
(
RESTYLE_LATER_SIBLINGS
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_empty
(
)
}
pub
fn
insert
(
&
mut
self
other
:
&
Self
)
{
self
.
0
|
=
other
.
0
}
pub
fn
has_animation_hint
(
&
self
)
-
>
bool
{
self
.
0
.
intersects
(
RestyleHint
:
:
for_animations
(
)
)
}
}
impl
Default
for
StoredRestyleHint
{
fn
default
(
)
-
>
Self
{
StoredRestyleHint
:
:
empty
(
)
}
}
impl
From
<
RestyleHint
>
for
StoredRestyleHint
{
fn
from
(
hint
:
RestyleHint
)
-
>
Self
{
StoredRestyleHint
(
hint
)
}
}
static
NO_SNAPSHOT
:
Option
<
Snapshot
>
=
None
;
#
[
derive
(
Debug
Default
)
]
pub
struct
SnapshotOption
{
snapshot
:
Option
<
Snapshot
>
destroyed
:
bool
}
impl
SnapshotOption
{
pub
fn
empty
(
)
-
>
Self
{
SnapshotOption
{
snapshot
:
None
destroyed
:
false
}
}
pub
fn
destroy
(
&
mut
self
)
{
self
.
destroyed
=
true
;
debug_assert
!
(
self
.
is_none
(
)
)
;
}
pub
fn
ensure
<
F
:
FnOnce
(
)
-
>
Snapshot
>
(
&
mut
self
create
:
F
)
-
>
&
mut
Snapshot
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_layout
(
)
)
;
if
self
.
is_none
(
)
{
self
.
snapshot
=
Some
(
create
(
)
)
;
self
.
destroyed
=
false
;
}
self
.
snapshot
.
as_mut
(
)
.
unwrap
(
)
}
}
impl
Deref
for
SnapshotOption
{
type
Target
=
Option
<
Snapshot
>
;
fn
deref
(
&
self
)
-
>
&
Option
<
Snapshot
>
{
if
self
.
destroyed
{
&
NO_SNAPSHOT
}
else
{
&
self
.
snapshot
}
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
RestyleData
{
pub
hint
:
StoredRestyleHint
pub
recascade
:
bool
pub
damage
:
RestyleDamage
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
damage_handled
:
RestyleDamage
pub
snapshot
:
SnapshotOption
}
impl
RestyleData
{
pub
fn
compute_final_hint
<
E
:
TElement
>
(
&
mut
self
element
:
E
stylist
:
&
Stylist
)
-
>
bool
{
let
mut
hint
=
self
.
hint
.
0
;
if
let
Some
(
snapshot
)
=
self
.
snapshot
.
as_ref
(
)
{
hint
|
=
stylist
.
compute_restyle_hint
(
&
element
snapshot
)
;
}
let
later_siblings
=
hint
.
contains
(
RESTYLE_LATER_SIBLINGS
)
;
hint
.
remove
(
RESTYLE_LATER_SIBLINGS
)
;
self
.
hint
=
hint
.
into
(
)
;
self
.
snapshot
.
destroy
(
)
;
later_siblings
}
pub
fn
has_invalidations
(
&
self
)
-
>
bool
{
self
.
hint
.
has_self_invalidations
(
)
|
|
self
.
recascade
|
|
self
.
snapshot
.
is_some
(
)
}
pub
fn
has_sibling_invalidations
(
&
self
)
-
>
bool
{
self
.
hint
.
has_sibling_invalidations
(
)
|
|
self
.
snapshot
.
is_some
(
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
damage_handled
(
&
self
)
-
>
RestyleDamage
{
self
.
damage_handled
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
damage_handled
(
&
self
)
-
>
RestyleDamage
{
RestyleDamage
:
:
empty
(
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
set_damage_handled
(
&
mut
self
d
:
RestyleDamage
)
{
self
.
damage_handled
=
d
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
set_damage_handled
(
&
mut
self
_
:
RestyleDamage
)
{
}
}
#
[
derive
(
Debug
)
]
pub
struct
ElementData
{
styles
:
Option
<
ElementStyles
>
restyle
:
Option
<
Box
<
RestyleData
>
>
}
pub
enum
RestyleKind
{
MatchAndCascade
CascadeWithReplacements
(
RestyleHint
)
CascadeOnly
}
impl
ElementData
{
pub
fn
new
(
existing
:
Option
<
ElementStyles
>
)
-
>
Self
{
ElementData
{
styles
:
existing
restyle
:
None
}
}
pub
fn
has_styles
(
&
self
)
-
>
bool
{
self
.
styles
.
is_some
(
)
}
pub
fn
has_current_styles
(
&
self
)
-
>
bool
{
self
.
has_styles
(
)
&
&
self
.
restyle
.
as_ref
(
)
.
map_or
(
true
|
r
|
!
r
.
has_invalidations
(
)
)
}
pub
fn
restyle_kind
(
&
self
)
-
>
RestyleKind
{
debug_assert
!
(
!
self
.
has_current_styles
(
)
"
Should
'
ve
stopped
earlier
"
)
;
if
!
self
.
has_styles
(
)
{
return
RestyleKind
:
:
MatchAndCascade
;
}
debug_assert
!
(
self
.
restyle
.
is_some
(
)
)
;
let
restyle_data
=
self
.
restyle
.
as_ref
(
)
.
unwrap
(
)
;
let
hint
=
restyle_data
.
hint
.
0
;
if
hint
.
contains
(
RESTYLE_SELF
)
{
return
RestyleKind
:
:
MatchAndCascade
;
}
if
!
hint
.
is_empty
(
)
{
return
RestyleKind
:
:
CascadeWithReplacements
(
hint
)
;
}
debug_assert
!
(
restyle_data
.
recascade
"
We
definitely
need
to
do
something
!
"
)
;
return
RestyleKind
:
:
CascadeOnly
;
}
pub
fn
get_styles
(
&
self
)
-
>
Option
<
&
ElementStyles
>
{
self
.
styles
.
as_ref
(
)
}
pub
fn
styles
(
&
self
)
-
>
&
ElementStyles
{
self
.
styles
.
as_ref
(
)
.
expect
(
"
Calling
styles
(
)
on
unstyled
ElementData
"
)
}
pub
fn
get_styles_mut
(
&
mut
self
)
-
>
Option
<
&
mut
ElementStyles
>
{
self
.
styles
.
as_mut
(
)
}
pub
fn
styles_mut
(
&
mut
self
)
-
>
&
mut
ElementStyles
{
self
.
styles
.
as_mut
(
)
.
expect
(
"
Calling
styles_mut
(
)
on
unstyled
ElementData
"
)
}
pub
fn
styles_and_restyle_mut
(
&
mut
self
)
-
>
(
&
mut
ElementStyles
Option
<
&
mut
RestyleData
>
)
{
(
self
.
styles
.
as_mut
(
)
.
unwrap
(
)
self
.
restyle
.
as_mut
(
)
.
map
(
|
r
|
&
mut
*
*
r
)
)
}
pub
fn
set_styles
(
&
mut
self
styles
:
ElementStyles
)
{
debug_assert
!
(
self
.
get_restyle
(
)
.
map_or
(
true
|
r
|
r
.
snapshot
.
is_none
(
)
)
"
Traversal
should
have
expanded
snapshots
"
)
;
self
.
styles
=
Some
(
styles
)
;
}
pub
fn
has_restyle
(
&
self
)
-
>
bool
{
self
.
restyle
.
is_some
(
)
}
pub
fn
clear_restyle
(
&
mut
self
)
{
self
.
restyle
=
None
;
}
pub
fn
ensure_restyle
(
&
mut
self
)
-
>
&
mut
RestyleData
{
debug_assert
!
(
self
.
styles
.
is_some
(
)
"
restyling
unstyled
element
"
)
;
if
self
.
restyle
.
is_none
(
)
{
self
.
restyle
=
Some
(
Box
:
:
new
(
RestyleData
:
:
default
(
)
)
)
;
}
self
.
restyle
.
as_mut
(
)
.
unwrap
(
)
}
pub
fn
get_restyle
(
&
self
)
-
>
Option
<
&
RestyleData
>
{
self
.
restyle
.
as_ref
(
)
.
map
(
|
r
|
&
*
*
r
)
}
pub
fn
restyle
(
&
self
)
-
>
&
RestyleData
{
self
.
get_restyle
(
)
.
expect
(
"
Calling
restyle
without
RestyleData
"
)
}
pub
fn
get_restyle_mut
(
&
mut
self
)
-
>
Option
<
&
mut
RestyleData
>
{
self
.
restyle
.
as_mut
(
)
.
map
(
|
r
|
&
mut
*
*
r
)
}
pub
fn
restyle_mut
(
&
mut
self
)
-
>
&
mut
RestyleData
{
self
.
get_restyle_mut
(
)
.
expect
(
"
Calling
restyle_mut
without
RestyleData
"
)
}
}
