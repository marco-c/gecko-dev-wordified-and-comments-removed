use
dom
:
:
TElement
;
use
properties
:
:
ComputedValues
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
as
display
;
use
restyle_hints
:
:
{
RESTYLE_LATER_SIBLINGS
RestyleHint
}
;
use
rule_tree
:
:
StrongRuleNode
;
use
selector_parser
:
:
{
PseudoElement
RestyleDamage
Snapshot
}
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
fmt
;
use
std
:
:
hash
:
:
BuildHasherDefault
;
use
std
:
:
mem
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
sync
:
:
Arc
;
use
stylist
:
:
Stylist
;
use
thread_state
;
#
[
derive
(
Clone
)
]
pub
struct
ComputedStyle
{
pub
rules
:
StrongRuleNode
pub
values
:
Arc
<
ComputedValues
>
}
impl
ComputedStyle
{
pub
fn
new
(
rules
:
StrongRuleNode
values
:
Arc
<
ComputedValues
>
)
-
>
Self
{
ComputedStyle
{
rules
:
rules
values
:
values
}
}
}
impl
fmt
:
:
Debug
for
ComputedStyle
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
ComputedStyle
{
{
rules
:
{
:
?
}
values
:
{
{
.
.
}
}
}
}
"
self
.
rules
)
}
}
type
PseudoStylesInner
=
HashMap
<
PseudoElement
ComputedStyle
BuildHasherDefault
<
:
:
fnv
:
:
FnvHasher
>
>
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
PseudoStyles
(
PseudoStylesInner
)
;
impl
PseudoStyles
{
pub
fn
empty
(
)
-
>
Self
{
PseudoStyles
(
HashMap
:
:
with_hasher
(
Default
:
:
default
(
)
)
)
}
}
impl
Deref
for
PseudoStyles
{
type
Target
=
PseudoStylesInner
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
PseudoStyles
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ElementStyles
{
pub
primary
:
ComputedStyle
pub
pseudos
:
PseudoStyles
}
impl
ElementStyles
{
pub
fn
new
(
primary
:
ComputedStyle
)
-
>
Self
{
ElementStyles
{
primary
:
primary
pseudos
:
PseudoStyles
:
:
empty
(
)
}
}
pub
fn
is_display_none
(
&
self
)
-
>
bool
{
self
.
primary
.
values
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
T
:
:
none
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
DescendantRestyleHint
{
Empty
Children
Descendants
}
impl
DescendantRestyleHint
{
fn
propagate
(
self
)
-
>
Self
{
use
self
:
:
DescendantRestyleHint
:
:
*
;
if
self
=
=
Descendants
{
Descendants
}
else
{
Empty
}
}
fn
union
(
self
other
:
Self
)
-
>
Self
{
use
self
:
:
DescendantRestyleHint
:
:
*
;
if
self
=
=
Descendants
|
|
other
=
=
Descendants
{
Descendants
}
else
if
self
=
=
Children
|
|
other
=
=
Children
{
Children
}
else
{
Empty
}
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
StoredRestyleHint
{
pub
restyle_self
:
bool
pub
descendants
:
DescendantRestyleHint
}
impl
StoredRestyleHint
{
pub
fn
propagate
(
&
self
)
-
>
Self
{
StoredRestyleHint
{
restyle_self
:
self
.
descendants
!
=
DescendantRestyleHint
:
:
Empty
descendants
:
self
.
descendants
.
propagate
(
)
}
}
pub
fn
empty
(
)
-
>
Self
{
StoredRestyleHint
{
restyle_self
:
false
descendants
:
DescendantRestyleHint
:
:
Empty
}
}
pub
fn
subtree
(
)
-
>
Self
{
StoredRestyleHint
{
restyle_self
:
true
descendants
:
DescendantRestyleHint
:
:
Descendants
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
!
self
.
restyle_self
&
&
self
.
descendants
=
=
DescendantRestyleHint
:
:
Empty
}
pub
fn
insert
(
&
mut
self
other
:
&
Self
)
{
self
.
restyle_self
=
self
.
restyle_self
|
|
other
.
restyle_self
;
self
.
descendants
=
self
.
descendants
.
union
(
other
.
descendants
)
;
}
}
impl
Default
for
StoredRestyleHint
{
fn
default
(
)
-
>
Self
{
StoredRestyleHint
{
restyle_self
:
false
descendants
:
DescendantRestyleHint
:
:
Empty
}
}
}
impl
From
<
RestyleHint
>
for
StoredRestyleHint
{
fn
from
(
hint
:
RestyleHint
)
-
>
Self
{
use
restyle_hints
:
:
*
;
use
self
:
:
DescendantRestyleHint
:
:
*
;
debug_assert
!
(
!
hint
.
contains
(
RESTYLE_LATER_SIBLINGS
)
"
Caller
should
apply
sibling
hints
"
)
;
StoredRestyleHint
{
restyle_self
:
hint
.
contains
(
RESTYLE_SELF
)
descendants
:
if
hint
.
contains
(
RESTYLE_DESCENDANTS
)
{
Descendants
}
else
{
Empty
}
}
}
}
static
NO_SNAPSHOT
:
Option
<
Snapshot
>
=
None
;
#
[
derive
(
Debug
)
]
pub
struct
SnapshotOption
{
snapshot
:
Option
<
Snapshot
>
destroyed
:
bool
}
impl
SnapshotOption
{
pub
fn
empty
(
)
-
>
Self
{
SnapshotOption
{
snapshot
:
None
destroyed
:
false
}
}
pub
fn
destroy
(
&
mut
self
)
{
self
.
destroyed
=
true
;
debug_assert
!
(
self
.
is_none
(
)
)
;
}
pub
fn
ensure
<
F
:
FnOnce
(
)
-
>
Snapshot
>
(
&
mut
self
create
:
F
)
-
>
&
mut
Snapshot
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_layout
(
)
)
;
if
self
.
is_none
(
)
{
self
.
snapshot
=
Some
(
create
(
)
)
;
self
.
destroyed
=
false
;
}
self
.
snapshot
.
as_mut
(
)
.
unwrap
(
)
}
}
impl
Deref
for
SnapshotOption
{
type
Target
=
Option
<
Snapshot
>
;
fn
deref
(
&
self
)
-
>
&
Option
<
Snapshot
>
{
if
self
.
destroyed
{
&
NO_SNAPSHOT
}
else
{
&
self
.
snapshot
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
RestyleData
{
pub
styles
:
ElementStyles
pub
hint
:
StoredRestyleHint
pub
recascade
:
bool
pub
damage
:
RestyleDamage
pub
snapshot
:
SnapshotOption
}
impl
RestyleData
{
fn
new
(
styles
:
ElementStyles
)
-
>
Self
{
RestyleData
{
styles
:
styles
hint
:
StoredRestyleHint
:
:
default
(
)
recascade
:
false
damage
:
RestyleDamage
:
:
empty
(
)
snapshot
:
SnapshotOption
:
:
empty
(
)
}
}
pub
fn
expand_snapshot
<
E
:
TElement
>
(
&
mut
self
element
:
E
stylist
:
&
Stylist
)
-
>
bool
{
if
self
.
snapshot
.
is_none
(
)
{
return
false
;
}
let
state
=
element
.
get_state
(
)
;
let
mut
hint
=
stylist
.
compute_restyle_hint
(
&
element
self
.
snapshot
.
as_ref
(
)
.
unwrap
(
)
state
)
;
let
later_siblings
=
hint
.
contains
(
RESTYLE_LATER_SIBLINGS
)
;
hint
.
remove
(
RESTYLE_LATER_SIBLINGS
)
;
self
.
hint
.
insert
(
&
hint
.
into
(
)
)
;
self
.
snapshot
.
destroy
(
)
;
later_siblings
}
pub
fn
has_current_styles
(
&
self
)
-
>
bool
{
!
(
self
.
hint
.
restyle_self
|
|
self
.
recascade
|
|
self
.
snapshot
.
is_some
(
)
)
}
pub
fn
styles
(
&
self
)
-
>
&
ElementStyles
{
&
self
.
styles
}
pub
fn
styles_mut
(
&
mut
self
)
-
>
&
mut
ElementStyles
{
&
mut
self
.
styles
}
fn
finish_styling
(
&
mut
self
styles
:
ElementStyles
damage
:
RestyleDamage
)
{
debug_assert
!
(
!
self
.
has_current_styles
(
)
)
;
debug_assert
!
(
self
.
snapshot
.
is_none
(
)
"
Traversal
should
have
expanded
snapshots
"
)
;
self
.
styles
=
styles
;
self
.
damage
|
=
damage
;
}
}
#
[
derive
(
Debug
)
]
pub
enum
ElementData
{
Initial
(
Option
<
ElementStyles
>
)
Restyle
(
RestyleData
)
Persistent
(
ElementStyles
)
}
impl
ElementData
{
pub
fn
new
(
existing
:
Option
<
ElementStyles
>
)
-
>
Self
{
if
let
Some
(
s
)
=
existing
{
ElementData
:
:
Persistent
(
s
)
}
else
{
ElementData
:
:
Initial
(
None
)
}
}
pub
fn
is_initial
(
&
self
)
-
>
bool
{
match
*
self
{
ElementData
:
:
Initial
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
is_unstyled_initial
(
&
self
)
-
>
bool
{
match
*
self
{
ElementData
:
:
Initial
(
None
)
=
>
true
_
=
>
false
}
}
pub
fn
is_styled_initial
(
&
self
)
-
>
bool
{
match
*
self
{
ElementData
:
:
Initial
(
Some
(
_
)
)
=
>
true
_
=
>
false
}
}
pub
fn
is_restyle
(
&
self
)
-
>
bool
{
match
*
self
{
ElementData
:
:
Restyle
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
as_restyle
(
&
self
)
-
>
Option
<
&
RestyleData
>
{
match
*
self
{
ElementData
:
:
Restyle
(
ref
x
)
=
>
Some
(
x
)
_
=
>
None
}
}
pub
fn
as_restyle_mut
(
&
mut
self
)
-
>
Option
<
&
mut
RestyleData
>
{
match
*
self
{
ElementData
:
:
Restyle
(
ref
mut
x
)
=
>
Some
(
x
)
_
=
>
None
}
}
pub
fn
is_persistent
(
&
self
)
-
>
bool
{
match
*
self
{
ElementData
:
:
Persistent
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
restyle
(
&
mut
self
)
-
>
Option
<
&
mut
RestyleData
>
{
if
self
.
is_unstyled_initial
(
)
{
return
None
;
}
let
damage_override
=
if
self
.
is_styled_initial
(
)
{
RestyleDamage
:
:
rebuild_and_reflow
(
)
}
else
{
RestyleDamage
:
:
empty
(
)
}
;
if
!
self
.
is_restyle
(
)
{
let
old
=
mem
:
:
replace
(
self
ElementData
:
:
new
(
None
)
)
;
let
styles
=
match
old
{
ElementData
:
:
Initial
(
Some
(
s
)
)
=
>
s
ElementData
:
:
Persistent
(
s
)
=
>
s
_
=
>
unreachable
!
(
)
}
;
*
self
=
ElementData
:
:
Restyle
(
RestyleData
:
:
new
(
styles
)
)
;
}
let
restyle
=
self
.
as_restyle_mut
(
)
.
unwrap
(
)
;
restyle
.
damage
|
=
damage_override
;
Some
(
restyle
)
}
pub
fn
persist
(
&
mut
self
)
{
if
self
.
is_persistent
(
)
{
return
;
}
let
old
=
mem
:
:
replace
(
self
ElementData
:
:
new
(
None
)
)
;
let
styles
=
match
old
{
ElementData
:
:
Initial
(
i
)
=
>
i
.
unwrap
(
)
ElementData
:
:
Restyle
(
r
)
=
>
r
.
styles
ElementData
:
:
Persistent
(
_
)
=
>
unreachable
!
(
)
}
;
*
self
=
ElementData
:
:
Persistent
(
styles
)
;
}
pub
fn
damage
(
&
self
)
-
>
RestyleDamage
{
use
self
:
:
ElementData
:
:
*
;
match
*
self
{
Initial
(
ref
s
)
=
>
{
debug_assert
!
(
s
.
is_some
(
)
)
;
RestyleDamage
:
:
rebuild_and_reflow
(
)
}
Restyle
(
ref
r
)
=
>
{
debug_assert
!
(
r
.
has_current_styles
(
)
)
;
r
.
damage
}
Persistent
(
_
)
=
>
RestyleDamage
:
:
empty
(
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
damage_sloppy
(
&
self
)
-
>
RestyleDamage
{
use
self
:
:
ElementData
:
:
*
;
match
*
self
{
Initial
(
ref
s
)
=
>
{
if
s
.
is_none
(
)
{
error
!
(
"
Accessing
damage
on
unstyled
element
"
)
;
}
RestyleDamage
:
:
rebuild_and_reflow
(
)
}
Restyle
(
ref
r
)
=
>
{
if
!
r
.
has_current_styles
(
)
{
error
!
(
"
Accessing
damage
on
dirty
element
"
)
;
}
r
.
damage
}
Persistent
(
_
)
=
>
RestyleDamage
:
:
empty
(
)
}
}
pub
fn
has_current_styles
(
&
self
)
-
>
bool
{
use
self
:
:
ElementData
:
:
*
;
match
*
self
{
Initial
(
ref
x
)
=
>
x
.
is_some
(
)
Restyle
(
ref
x
)
=
>
x
.
has_current_styles
(
)
Persistent
(
_
)
=
>
true
}
}
pub
fn
get_styles
(
&
self
)
-
>
Option
<
&
ElementStyles
>
{
use
self
:
:
ElementData
:
:
*
;
match
*
self
{
Initial
(
ref
x
)
=
>
x
.
as_ref
(
)
Restyle
(
ref
x
)
=
>
Some
(
x
.
styles
(
)
)
Persistent
(
ref
x
)
=
>
Some
(
x
)
}
}
pub
fn
styles
(
&
self
)
-
>
&
ElementStyles
{
self
.
get_styles
(
)
.
expect
(
"
Calling
styles
(
)
on
unstyled
ElementData
"
)
}
pub
fn
get_styles_mut
(
&
mut
self
)
-
>
Option
<
&
mut
ElementStyles
>
{
use
self
:
:
ElementData
:
:
*
;
match
*
self
{
Initial
(
ref
mut
x
)
=
>
x
.
as_mut
(
)
Restyle
(
ref
mut
x
)
=
>
Some
(
x
.
styles_mut
(
)
)
Persistent
(
ref
mut
x
)
=
>
Some
(
x
)
}
}
pub
fn
styles_mut
(
&
mut
self
)
-
>
&
mut
ElementStyles
{
self
.
get_styles_mut
(
)
.
expect
(
"
Calling
styles_mut
(
)
on
unstyled
ElementData
"
)
}
pub
fn
finish_styling
(
&
mut
self
styles
:
ElementStyles
damage
:
RestyleDamage
)
{
use
self
:
:
ElementData
:
:
*
;
match
*
self
{
Initial
(
ref
mut
x
)
=
>
{
debug_assert
!
(
x
.
is_none
(
)
)
;
debug_assert
!
(
damage
=
=
RestyleDamage
:
:
rebuild_and_reflow
(
)
)
;
*
x
=
Some
(
styles
)
;
}
Restyle
(
ref
mut
x
)
=
>
x
.
finish_styling
(
styles
damage
)
Persistent
(
_
)
=
>
panic
!
(
"
Calling
finish_styling
on
Persistent
ElementData
"
)
}
;
}
}
