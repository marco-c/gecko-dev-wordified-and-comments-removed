use
properties
:
:
TComputedValues
;
use
selectors
:
:
parser
:
:
SelectorImpl
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
hash
:
:
BuildHasherDefault
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicIsize
;
pub
struct
PrivateStyleData
<
Impl
:
SelectorImpl
ConcreteComputedValues
:
TComputedValues
>
{
pub
style
:
Option
<
Arc
<
ConcreteComputedValues
>
>
pub
per_pseudo
:
HashMap
<
Impl
:
:
PseudoElement
Arc
<
ConcreteComputedValues
>
BuildHasherDefault
<
:
:
fnv
:
:
FnvHasher
>
>
pub
parallel
:
DomParallelInfo
}
impl
<
Impl
ConcreteComputedValues
>
PrivateStyleData
<
Impl
ConcreteComputedValues
>
where
Impl
:
SelectorImpl
ConcreteComputedValues
:
TComputedValues
{
pub
fn
new
(
)
-
>
PrivateStyleData
<
Impl
ConcreteComputedValues
>
{
PrivateStyleData
{
style
:
None
per_pseudo
:
HashMap
:
:
with_hasher
(
Default
:
:
default
(
)
)
parallel
:
DomParallelInfo
:
:
new
(
)
}
}
}
#
[
derive
(
HeapSizeOf
)
]
pub
struct
DomParallelInfo
{
pub
children_count
:
AtomicIsize
}
impl
DomParallelInfo
{
pub
fn
new
(
)
-
>
DomParallelInfo
{
DomParallelInfo
{
children_count
:
AtomicIsize
:
:
new
(
0
)
}
}
}
