#
!
[
deny
(
missing_docs
)
]
use
dom
:
:
TElement
;
use
properties
:
:
ComputedValues
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
as
display
;
use
restyle_hints
:
:
{
RESTYLE_LATER_SIBLINGS
RestyleHint
}
;
use
rule_tree
:
:
StrongRuleNode
;
use
selector_parser
:
:
{
PseudoElement
RestyleDamage
Snapshot
}
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
fmt
;
use
std
:
:
hash
:
:
BuildHasherDefault
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
sync
:
:
Arc
;
use
stylist
:
:
Stylist
;
use
thread_state
;
#
[
derive
(
Clone
)
]
pub
struct
ComputedStyle
{
pub
rules
:
StrongRuleNode
pub
values
:
Arc
<
ComputedValues
>
}
impl
ComputedStyle
{
pub
fn
new
(
rules
:
StrongRuleNode
values
:
Arc
<
ComputedValues
>
)
-
>
Self
{
ComputedStyle
{
rules
:
rules
values
:
values
}
}
}
impl
fmt
:
:
Debug
for
ComputedStyle
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
ComputedStyle
{
{
rules
:
{
:
?
}
values
:
{
{
.
.
}
}
}
}
"
self
.
rules
)
}
}
type
PseudoStylesInner
=
HashMap
<
PseudoElement
ComputedStyle
BuildHasherDefault
<
:
:
fnv
:
:
FnvHasher
>
>
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
PseudoStyles
(
PseudoStylesInner
)
;
impl
PseudoStyles
{
pub
fn
empty
(
)
-
>
Self
{
PseudoStyles
(
HashMap
:
:
with_hasher
(
Default
:
:
default
(
)
)
)
}
}
impl
Deref
for
PseudoStyles
{
type
Target
=
PseudoStylesInner
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
PseudoStyles
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ElementStyles
{
pub
primary
:
ComputedStyle
pub
pseudos
:
PseudoStyles
}
impl
ElementStyles
{
pub
fn
new
(
primary
:
ComputedStyle
)
-
>
Self
{
ElementStyles
{
primary
:
primary
pseudos
:
PseudoStyles
:
:
empty
(
)
}
}
pub
fn
is_display_none
(
&
self
)
-
>
bool
{
self
.
primary
.
values
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
T
:
:
none
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
DescendantRestyleHint
{
Empty
Children
Descendants
}
impl
DescendantRestyleHint
{
fn
propagate
(
self
)
-
>
Self
{
use
self
:
:
DescendantRestyleHint
:
:
*
;
if
self
=
=
Descendants
{
Descendants
}
else
{
Empty
}
}
fn
union
(
self
other
:
Self
)
-
>
Self
{
use
self
:
:
DescendantRestyleHint
:
:
*
;
if
self
=
=
Descendants
|
|
other
=
=
Descendants
{
Descendants
}
else
if
self
=
=
Children
|
|
other
=
=
Children
{
Children
}
else
{
Empty
}
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
StoredRestyleHint
{
pub
restyle_self
:
bool
pub
descendants
:
DescendantRestyleHint
}
impl
StoredRestyleHint
{
pub
fn
propagate
(
&
self
)
-
>
Self
{
StoredRestyleHint
{
restyle_self
:
self
.
descendants
!
=
DescendantRestyleHint
:
:
Empty
descendants
:
self
.
descendants
.
propagate
(
)
}
}
pub
fn
empty
(
)
-
>
Self
{
StoredRestyleHint
{
restyle_self
:
false
descendants
:
DescendantRestyleHint
:
:
Empty
}
}
pub
fn
subtree
(
)
-
>
Self
{
StoredRestyleHint
{
restyle_self
:
true
descendants
:
DescendantRestyleHint
:
:
Descendants
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
!
self
.
restyle_self
&
&
self
.
descendants
=
=
DescendantRestyleHint
:
:
Empty
}
pub
fn
insert
(
&
mut
self
other
:
&
Self
)
{
self
.
restyle_self
=
self
.
restyle_self
|
|
other
.
restyle_self
;
self
.
descendants
=
self
.
descendants
.
union
(
other
.
descendants
)
;
}
}
impl
Default
for
StoredRestyleHint
{
fn
default
(
)
-
>
Self
{
StoredRestyleHint
{
restyle_self
:
false
descendants
:
DescendantRestyleHint
:
:
Empty
}
}
}
impl
From
<
RestyleHint
>
for
StoredRestyleHint
{
fn
from
(
hint
:
RestyleHint
)
-
>
Self
{
use
restyle_hints
:
:
*
;
use
self
:
:
DescendantRestyleHint
:
:
*
;
debug_assert
!
(
!
hint
.
contains
(
RESTYLE_LATER_SIBLINGS
)
"
Caller
should
apply
sibling
hints
"
)
;
StoredRestyleHint
{
restyle_self
:
hint
.
contains
(
RESTYLE_SELF
)
|
|
hint
.
contains
(
RESTYLE_STYLE_ATTRIBUTE
)
descendants
:
if
hint
.
contains
(
RESTYLE_DESCENDANTS
)
{
Descendants
}
else
{
Empty
}
}
}
}
static
NO_SNAPSHOT
:
Option
<
Snapshot
>
=
None
;
#
[
derive
(
Debug
)
]
pub
struct
SnapshotOption
{
snapshot
:
Option
<
Snapshot
>
destroyed
:
bool
}
impl
SnapshotOption
{
pub
fn
empty
(
)
-
>
Self
{
SnapshotOption
{
snapshot
:
None
destroyed
:
false
}
}
pub
fn
destroy
(
&
mut
self
)
{
self
.
destroyed
=
true
;
debug_assert
!
(
self
.
is_none
(
)
)
;
}
pub
fn
ensure
<
F
:
FnOnce
(
)
-
>
Snapshot
>
(
&
mut
self
create
:
F
)
-
>
&
mut
Snapshot
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_layout
(
)
)
;
if
self
.
is_none
(
)
{
self
.
snapshot
=
Some
(
create
(
)
)
;
self
.
destroyed
=
false
;
}
self
.
snapshot
.
as_mut
(
)
.
unwrap
(
)
}
}
impl
Deref
for
SnapshotOption
{
type
Target
=
Option
<
Snapshot
>
;
fn
deref
(
&
self
)
-
>
&
Option
<
Snapshot
>
{
if
self
.
destroyed
{
&
NO_SNAPSHOT
}
else
{
&
self
.
snapshot
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
RestyleData
{
pub
hint
:
StoredRestyleHint
pub
recascade
:
bool
pub
damage
:
RestyleDamage
pub
snapshot
:
SnapshotOption
}
impl
Default
for
RestyleData
{
fn
default
(
)
-
>
Self
{
RestyleData
{
hint
:
StoredRestyleHint
:
:
default
(
)
recascade
:
false
damage
:
RestyleDamage
:
:
empty
(
)
snapshot
:
SnapshotOption
:
:
empty
(
)
}
}
}
impl
RestyleData
{
pub
fn
expand_snapshot
<
E
:
TElement
>
(
&
mut
self
element
:
E
stylist
:
&
Stylist
)
-
>
bool
{
if
self
.
snapshot
.
is_none
(
)
{
return
false
;
}
let
mut
hint
=
stylist
.
compute_restyle_hint
(
&
element
self
.
snapshot
.
as_ref
(
)
.
unwrap
(
)
)
;
let
later_siblings
=
hint
.
contains
(
RESTYLE_LATER_SIBLINGS
)
;
hint
.
remove
(
RESTYLE_LATER_SIBLINGS
)
;
self
.
hint
.
insert
(
&
hint
.
into
(
)
)
;
self
.
snapshot
.
destroy
(
)
;
later_siblings
}
pub
fn
has_invalidations
(
&
self
)
-
>
bool
{
self
.
hint
.
restyle_self
|
|
self
.
recascade
|
|
self
.
snapshot
.
is_some
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
ElementData
{
styles
:
Option
<
ElementStyles
>
restyle
:
Option
<
Box
<
RestyleData
>
>
}
impl
ElementData
{
pub
fn
new
(
existing
:
Option
<
ElementStyles
>
)
-
>
Self
{
ElementData
{
styles
:
existing
restyle
:
None
}
}
pub
fn
has_styles
(
&
self
)
-
>
bool
{
self
.
styles
.
is_some
(
)
}
pub
fn
has_current_styles
(
&
self
)
-
>
bool
{
self
.
has_styles
(
)
&
&
self
.
restyle
.
as_ref
(
)
.
map_or
(
true
|
r
|
!
r
.
has_invalidations
(
)
)
}
pub
fn
get_styles
(
&
self
)
-
>
Option
<
&
ElementStyles
>
{
self
.
styles
.
as_ref
(
)
}
pub
fn
styles
(
&
self
)
-
>
&
ElementStyles
{
self
.
styles
.
as_ref
(
)
.
expect
(
"
Calling
styles
(
)
on
unstyled
ElementData
"
)
}
pub
fn
get_styles_mut
(
&
mut
self
)
-
>
Option
<
&
mut
ElementStyles
>
{
self
.
styles
.
as_mut
(
)
}
pub
fn
styles_mut
(
&
mut
self
)
-
>
&
mut
ElementStyles
{
self
.
styles
.
as_mut
(
)
.
expect
(
"
Caling
styles_mut
(
)
on
unstyled
ElementData
"
)
}
pub
fn
set_styles
(
&
mut
self
styles
:
ElementStyles
)
{
debug_assert
!
(
self
.
get_restyle
(
)
.
map_or
(
true
|
r
|
r
.
snapshot
.
is_none
(
)
)
"
Traversal
should
have
expanded
snapshots
"
)
;
self
.
styles
=
Some
(
styles
)
;
}
pub
fn
has_restyle
(
&
self
)
-
>
bool
{
self
.
restyle
.
is_some
(
)
}
pub
fn
clear_restyle
(
&
mut
self
)
{
self
.
restyle
=
None
;
}
pub
fn
ensure_restyle
(
&
mut
self
)
-
>
&
mut
RestyleData
{
debug_assert
!
(
self
.
styles
.
is_some
(
)
"
restyling
unstyled
element
"
)
;
if
self
.
restyle
.
is_none
(
)
{
self
.
restyle
=
Some
(
Box
:
:
new
(
RestyleData
:
:
default
(
)
)
)
;
}
self
.
restyle
.
as_mut
(
)
.
unwrap
(
)
}
pub
fn
get_restyle
(
&
self
)
-
>
Option
<
&
RestyleData
>
{
self
.
restyle
.
as_ref
(
)
.
map
(
|
r
|
&
*
*
r
)
}
pub
fn
restyle
(
&
self
)
-
>
&
RestyleData
{
self
.
get_restyle
(
)
.
expect
(
"
Calling
restyle
without
RestyleData
"
)
}
pub
fn
get_restyle_mut
(
&
mut
self
)
-
>
Option
<
&
mut
RestyleData
>
{
self
.
restyle
.
as_mut
(
)
.
map
(
|
r
|
&
mut
*
*
r
)
}
pub
fn
restyle_mut
(
&
mut
self
)
-
>
&
mut
RestyleData
{
self
.
get_restyle_mut
(
)
.
expect
(
"
Calling
restyle_mut
without
RestyleData
"
)
}
}
