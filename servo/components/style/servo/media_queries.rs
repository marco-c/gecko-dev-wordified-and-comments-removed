use
app_units
:
:
Au
;
use
cssparser
:
:
RGBA
;
use
euclid
:
:
{
Size2D
TypedScale
TypedSize2D
}
;
use
media_queries
:
:
MediaType
;
use
properties
:
:
ComputedValues
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
AtomicIsize
Ordering
}
;
use
style_traits
:
:
{
CSSPixel
DevicePixel
}
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
use
values
:
:
KeyframesName
;
use
values
:
:
computed
:
:
CSSPixelLength
;
use
values
:
:
computed
:
:
font
:
:
FontSize
;
use
media_queries
:
:
media_feature
:
:
{
MediaFeatureDescription
Evaluator
}
;
use
media_queries
:
:
media_feature
:
:
{
AllowsRanges
ParsingRequirements
}
;
use
media_queries
:
:
media_feature_expression
:
:
RangeOrOperator
;
#
[
derive
(
Debug
MallocSizeOf
)
]
pub
struct
Device
{
media_type
:
MediaType
viewport_size
:
TypedSize2D
<
f32
CSSPixel
>
device_pixel_ratio
:
TypedScale
<
f32
CSSPixel
DevicePixel
>
#
[
ignore_malloc_size_of
=
"
Pure
stack
type
"
]
root_font_size
:
AtomicIsize
#
[
ignore_malloc_size_of
=
"
Pure
stack
type
"
]
used_root_font_size
:
AtomicBool
#
[
ignore_malloc_size_of
=
"
Pure
stack
type
"
]
used_viewport_units
:
AtomicBool
}
impl
Device
{
pub
fn
new
(
media_type
:
MediaType
viewport_size
:
TypedSize2D
<
f32
CSSPixel
>
device_pixel_ratio
:
TypedScale
<
f32
CSSPixel
DevicePixel
>
)
-
>
Device
{
Device
{
media_type
viewport_size
device_pixel_ratio
root_font_size
:
AtomicIsize
:
:
new
(
FontSize
:
:
medium
(
)
.
size
(
)
.
0
as
isize
)
used_root_font_size
:
AtomicBool
:
:
new
(
false
)
used_viewport_units
:
AtomicBool
:
:
new
(
false
)
}
}
pub
fn
default_computed_values
(
&
self
)
-
>
&
ComputedValues
{
ComputedValues
:
:
initial_values
(
)
}
pub
fn
root_font_size
(
&
self
)
-
>
Au
{
self
.
used_root_font_size
.
store
(
true
Ordering
:
:
Relaxed
)
;
Au
:
:
new
(
self
.
root_font_size
.
load
(
Ordering
:
:
Relaxed
)
as
i32
)
}
pub
fn
set_root_font_size
(
&
self
size
:
Au
)
{
self
.
root_font_size
.
store
(
size
.
0
as
isize
Ordering
:
:
Relaxed
)
}
pub
fn
set_body_text_color
(
&
self
_color
:
RGBA
)
{
}
pub
fn
animation_name_may_be_referenced
(
&
self
_
:
&
KeyframesName
)
-
>
bool
{
true
}
pub
fn
used_root_font_size
(
&
self
)
-
>
bool
{
self
.
used_root_font_size
.
load
(
Ordering
:
:
Relaxed
)
}
#
[
inline
]
pub
fn
au_viewport_size
(
&
self
)
-
>
Size2D
<
Au
>
{
Size2D
:
:
new
(
Au
:
:
from_f32_px
(
self
.
viewport_size
.
width
)
Au
:
:
from_f32_px
(
self
.
viewport_size
.
height
)
)
}
pub
fn
au_viewport_size_for_viewport_unit_resolution
(
&
self
)
-
>
Size2D
<
Au
>
{
self
.
used_viewport_units
.
store
(
true
Ordering
:
:
Relaxed
)
;
self
.
au_viewport_size
(
)
}
pub
fn
used_viewport_units
(
&
self
)
-
>
bool
{
self
.
used_viewport_units
.
load
(
Ordering
:
:
Relaxed
)
}
pub
fn
device_pixel_ratio
(
&
self
)
-
>
TypedScale
<
f32
CSSPixel
DevicePixel
>
{
self
.
device_pixel_ratio
}
pub
fn
account_for_viewport_rule
(
&
mut
self
constraints
:
&
ViewportConstraints
)
{
self
.
viewport_size
=
constraints
.
size
;
}
pub
fn
media_type
(
&
self
)
-
>
MediaType
{
self
.
media_type
.
clone
(
)
}
pub
fn
use_document_colors
(
&
self
)
-
>
bool
{
true
}
pub
fn
default_background_color
(
&
self
)
-
>
RGBA
{
RGBA
:
:
new
(
255
255
255
255
)
}
}
fn
eval_width
(
device
:
&
Device
value
:
Option
<
CSSPixelLength
>
range_or_operator
:
Option
<
RangeOrOperator
>
)
-
>
bool
{
RangeOrOperator
:
:
evaluate
(
range_or_operator
value
.
map
(
Au
:
:
from
)
device
.
au_viewport_size
(
)
.
width
)
}
#
[
derive
(
Debug
Copy
Clone
FromPrimitive
ToCss
Parse
)
]
#
[
repr
(
u8
)
]
enum
Scan
{
Progressive
Interlace
}
fn
eval_scan
(
_
:
&
Device
_
:
Option
<
Scan
>
)
-
>
bool
{
false
}
lazy_static
!
{
/
/
/
A
list
with
all
the
media
features
that
Servo
supports
.
pub
static
ref
MEDIA_FEATURES
:
[
MediaFeatureDescription
;
2
]
=
[
feature
!
(
atom
!
(
"
width
"
)
AllowsRanges
:
:
Yes
Evaluator
:
:
Length
(
eval_width
)
ParsingRequirements
:
:
empty
(
)
)
feature
!
(
atom
!
(
"
scan
"
)
AllowsRanges
:
:
No
keyword_evaluator
!
(
eval_scan
Scan
)
ParsingRequirements
:
:
empty
(
)
)
]
;
}
