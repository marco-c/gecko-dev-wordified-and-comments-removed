use
app_units
:
:
Au
;
use
context
:
:
QuirksMode
;
use
cssparser
:
:
{
Parser
RGBA
}
;
use
euclid
:
:
{
Size2D
TypedSize2D
}
;
use
font_metrics
:
:
ServoMetricsProvider
;
use
media_queries
:
:
MediaType
;
use
parser
:
:
ParserContext
;
use
properties
:
:
{
ComputedValues
StyleBuilder
}
;
use
properties
:
:
longhands
:
:
font_size
;
use
selectors
:
:
parser
:
:
SelectorParseError
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
AtomicIsize
Ordering
}
;
use
style_traits
:
:
{
CSSPixel
ToCss
ParseError
}
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
use
values
:
:
computed
:
:
{
self
ToComputedValue
}
;
use
values
:
:
specified
;
#
[
derive
(
HeapSizeOf
)
]
pub
struct
Device
{
media_type
:
MediaType
viewport_size
:
TypedSize2D
<
f32
CSSPixel
>
#
[
ignore_heap_size_of
=
"
Pure
stack
type
"
]
root_font_size
:
AtomicIsize
#
[
ignore_heap_size_of
=
"
Pure
stack
type
"
]
used_root_font_size
:
AtomicBool
}
impl
Device
{
pub
fn
new
(
media_type
:
MediaType
viewport_size
:
TypedSize2D
<
f32
CSSPixel
>
)
-
>
Device
{
Device
{
media_type
:
media_type
viewport_size
:
viewport_size
root_font_size
:
AtomicIsize
:
:
new
(
font_size
:
:
get_initial_value
(
)
.
0
as
isize
)
used_root_font_size
:
AtomicBool
:
:
new
(
false
)
}
}
pub
fn
default_computed_values
(
&
self
)
-
>
&
ComputedValues
{
ComputedValues
:
:
initial_values
(
)
}
pub
fn
root_font_size
(
&
self
)
-
>
Au
{
self
.
used_root_font_size
.
store
(
true
Ordering
:
:
Relaxed
)
;
Au
:
:
new
(
self
.
root_font_size
.
load
(
Ordering
:
:
Relaxed
)
as
i32
)
}
pub
fn
set_root_font_size
(
&
self
size
:
Au
)
{
self
.
root_font_size
.
store
(
size
.
0
as
isize
Ordering
:
:
Relaxed
)
}
pub
fn
used_root_font_size
(
&
self
)
-
>
bool
{
self
.
used_root_font_size
.
load
(
Ordering
:
:
Relaxed
)
}
#
[
inline
]
pub
fn
au_viewport_size
(
&
self
)
-
>
Size2D
<
Au
>
{
Size2D
:
:
new
(
Au
:
:
from_f32_px
(
self
.
viewport_size
.
width
)
Au
:
:
from_f32_px
(
self
.
viewport_size
.
height
)
)
}
#
[
inline
]
pub
fn
px_viewport_size
(
&
self
)
-
>
TypedSize2D
<
f32
CSSPixel
>
{
self
.
viewport_size
}
pub
fn
account_for_viewport_rule
(
&
mut
self
constraints
:
&
ViewportConstraints
)
{
self
.
viewport_size
=
constraints
.
size
;
}
pub
fn
media_type
(
&
self
)
-
>
MediaType
{
self
.
media_type
.
clone
(
)
}
pub
fn
use_document_colors
(
&
self
)
-
>
bool
{
true
}
pub
fn
default_background_color
(
&
self
)
-
>
RGBA
{
RGBA
:
:
new
(
255
255
255
255
)
}
}
#
[
derive
(
PartialEq
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
ExpressionKind
{
Width
(
Range
<
specified
:
:
Length
>
)
}
#
[
derive
(
PartialEq
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
Expression
(
ExpressionKind
)
;
impl
Expression
{
pub
fn
kind_for_testing
(
&
self
)
-
>
&
ExpressionKind
{
&
self
.
0
}
pub
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
expect_parenthesis_block
(
)
?
;
input
.
parse_nested_block
(
|
input
|
{
let
name
=
input
.
expect_ident
(
)
?
;
input
.
expect_colon
(
)
?
;
Ok
(
Expression
(
match_ignore_ascii_case
!
{
&
name
"
min
-
width
"
=
>
{
ExpressionKind
:
:
Width
(
Range
:
:
Min
(
specified
:
:
Length
:
:
parse_non_negative
(
context
input
)
?
)
)
}
"
max
-
width
"
=
>
{
ExpressionKind
:
:
Width
(
Range
:
:
Max
(
specified
:
:
Length
:
:
parse_non_negative
(
context
input
)
?
)
)
}
"
width
"
=
>
{
ExpressionKind
:
:
Width
(
Range
:
:
Eq
(
specified
:
:
Length
:
:
parse_non_negative
(
context
input
)
?
)
)
}
_
=
>
return
Err
(
SelectorParseError
:
:
UnexpectedIdent
(
name
.
clone
(
)
)
.
into
(
)
)
}
)
)
}
)
}
pub
fn
matches
(
&
self
device
:
&
Device
quirks_mode
:
QuirksMode
)
-
>
bool
{
let
viewport_size
=
device
.
au_viewport_size
(
)
;
let
value
=
viewport_size
.
width
;
match
self
.
0
{
ExpressionKind
:
:
Width
(
ref
range
)
=
>
{
match
range
.
to_computed_range
(
device
quirks_mode
)
{
Range
:
:
Min
(
ref
width
)
=
>
{
value
>
=
*
width
}
Range
:
:
Max
(
ref
width
)
=
>
{
value
<
=
*
width
}
Range
:
:
Eq
(
ref
width
)
=
>
{
value
=
=
*
width
}
}
}
}
}
}
impl
ToCss
for
Expression
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
write
!
(
dest
"
(
"
)
?
;
let
(
mm
l
)
=
match
self
.
0
{
ExpressionKind
:
:
Width
(
Range
:
:
Min
(
ref
l
)
)
=
>
(
"
min
-
"
l
)
ExpressionKind
:
:
Width
(
Range
:
:
Max
(
ref
l
)
)
=
>
(
"
max
-
"
l
)
ExpressionKind
:
:
Width
(
Range
:
:
Eq
(
ref
l
)
)
=
>
(
"
"
l
)
}
;
write
!
(
dest
"
{
}
width
:
"
mm
)
?
;
l
.
to_css
(
dest
)
?
;
write
!
(
dest
"
)
"
)
}
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
Range
<
T
>
{
Min
(
T
)
Max
(
T
)
Eq
(
T
)
}
impl
Range
<
specified
:
:
Length
>
{
fn
to_computed_range
(
&
self
device
:
&
Device
quirks_mode
:
QuirksMode
)
-
>
Range
<
Au
>
{
let
default_values
=
device
.
default_computed_values
(
)
;
let
context
=
computed
:
:
Context
{
is_root_element
:
false
device
:
device
inherited_style
:
default_values
style
:
StyleBuilder
:
:
for_derived_style
(
device
default_values
None
)
font_metrics_provider
:
&
ServoMetricsProvider
in_media_query
:
true
cached_system_font
:
None
quirks_mode
:
quirks_mode
}
;
match
*
self
{
Range
:
:
Min
(
ref
width
)
=
>
Range
:
:
Min
(
width
.
to_computed_value
(
&
context
)
)
Range
:
:
Max
(
ref
width
)
=
>
Range
:
:
Max
(
width
.
to_computed_value
(
&
context
)
)
Range
:
:
Eq
(
ref
width
)
=
>
Range
:
:
Eq
(
width
.
to_computed_value
(
&
context
)
)
}
}
}
