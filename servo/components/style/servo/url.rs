use
cssparser
:
:
Parser
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
sync
:
:
Arc
;
use
style_traits
:
:
{
CssWriter
ParseError
ToCss
}
;
use
values
:
:
computed
:
:
{
Context
ToComputedValue
}
;
#
[
derive
(
Clone
Debug
Deserialize
MallocSizeOf
Serialize
SpecifiedValueInfo
)
]
pub
struct
CssUrl
{
#
[
ignore_malloc_size_of
=
"
Arc
"
]
original
:
Option
<
Arc
<
String
>
>
resolved
:
Option
<
ServoUrl
>
}
impl
CssUrl
{
pub
fn
parse_from_string
(
url
:
String
context
:
&
ParserContext
)
-
>
Self
{
let
serialization
=
Arc
:
:
new
(
url
)
;
let
resolved
=
context
.
url_data
.
join
(
&
serialization
)
.
ok
(
)
;
CssUrl
{
original
:
Some
(
serialization
)
resolved
:
resolved
}
}
pub
fn
is_invalid
(
&
self
)
-
>
bool
{
self
.
resolved
.
is_none
(
)
}
pub
fn
is_fragment
(
&
self
)
-
>
bool
{
error
!
(
"
Can
'
t
determine
whether
the
url
is
a
fragment
.
"
)
;
false
}
pub
fn
url
(
&
self
)
-
>
Option
<
&
ServoUrl
>
{
self
.
resolved
.
as_ref
(
)
}
pub
fn
as_str
(
&
self
)
-
>
&
str
{
match
self
.
resolved
{
Some
(
ref
url
)
=
>
url
.
as_str
(
)
None
=
>
"
"
}
}
pub
fn
for_cascade
(
url
:
ServoUrl
)
-
>
Self
{
CssUrl
{
original
:
None
resolved
:
Some
(
url
)
}
}
pub
fn
new_for_testing
(
url
:
&
str
)
-
>
Self
{
CssUrl
{
original
:
Some
(
Arc
:
:
new
(
url
.
into
(
)
)
)
resolved
:
ServoUrl
:
:
parse
(
url
)
.
ok
(
)
}
}
}
impl
Parse
for
CssUrl
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
url
=
input
.
expect_url
(
)
?
;
Ok
(
Self
:
:
parse_from_string
(
url
.
as_ref
(
)
.
to_owned
(
)
context
)
)
}
}
impl
PartialEq
for
CssUrl
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
resolved
=
=
other
.
resolved
}
}
impl
Eq
for
CssUrl
{
}
impl
ToCss
for
CssUrl
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
let
string
=
match
self
.
original
{
Some
(
ref
original
)
=
>
&
*
*
original
None
=
>
match
self
.
resolved
{
Some
(
ref
url
)
=
>
url
.
as_str
(
)
None
=
>
"
about
:
invalid
"
}
}
;
dest
.
write_str
(
"
url
(
"
)
?
;
string
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
}
pub
type
SpecifiedUrl
=
CssUrl
;
impl
ToComputedValue
for
SpecifiedUrl
{
type
ComputedValue
=
ComputedUrl
;
fn
to_computed_value
(
&
self
_
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
match
self
.
resolved
{
Some
(
ref
url
)
=
>
ComputedUrl
:
:
Valid
(
url
.
clone
(
)
)
None
=
>
match
self
.
original
{
Some
(
ref
url
)
=
>
ComputedUrl
:
:
Invalid
(
url
.
clone
(
)
)
None
=
>
{
unreachable
!
(
"
Found
specified
url
with
neither
resolved
or
original
URI
!
"
)
;
}
}
}
}
fn
from_computed_value
(
computed
:
&
ComputedUrl
)
-
>
Self
{
match
*
computed
{
ComputedUrl
:
:
Valid
(
ref
url
)
=
>
SpecifiedUrl
{
original
:
None
resolved
:
Some
(
url
.
clone
(
)
)
}
ComputedUrl
:
:
Invalid
(
ref
url
)
=
>
SpecifiedUrl
{
original
:
Some
(
url
.
clone
(
)
)
resolved
:
None
}
}
}
}
pub
type
SpecifiedImageUrl
=
CssUrl
;
#
[
derive
(
Clone
Debug
Deserialize
MallocSizeOf
PartialEq
Serialize
)
]
pub
enum
ComputedUrl
{
Invalid
(
#
[
ignore_malloc_size_of
=
"
Arc
"
]
Arc
<
String
>
)
Valid
(
ServoUrl
)
}
impl
ComputedUrl
{
pub
fn
url
(
&
self
)
-
>
Option
<
&
ServoUrl
>
{
match
*
self
{
ComputedUrl
:
:
Valid
(
ref
url
)
=
>
Some
(
url
)
_
=
>
None
}
}
}
impl
ToCss
for
ComputedUrl
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
let
string
=
match
*
self
{
ComputedUrl
:
:
Valid
(
ref
url
)
=
>
url
.
as_str
(
)
ComputedUrl
:
:
Invalid
(
ref
invalid_string
)
=
>
invalid_string
}
;
dest
.
write_str
(
"
url
(
"
)
?
;
string
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
}
pub
type
ComputedImageUrl
=
ComputedUrl
;
