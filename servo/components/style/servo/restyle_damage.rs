use
crate
:
:
computed_values
:
:
display
:
:
T
as
Display
;
use
crate
:
:
matching
:
:
{
StyleChange
StyleDifference
}
;
use
crate
:
:
properties
:
:
ComputedValues
;
use
std
:
:
fmt
;
bitflags
!
{
/
/
/
Individual
layout
actions
that
may
be
necessary
after
restyling
.
pub
struct
ServoRestyleDamage
:
u8
{
/
/
/
Repaint
the
node
itself
.
/
/
/
/
/
/
Currently
unused
;
need
to
decide
how
this
propagates
.
const
REPAINT
=
0x01
;
/
/
/
The
stacking
-
context
-
relative
position
of
this
node
or
its
/
/
/
descendants
has
changed
.
/
/
/
/
/
/
Propagates
both
up
and
down
the
flow
tree
.
const
REPOSITION
=
0x02
;
/
/
/
Recompute
the
overflow
regions
(
bounding
box
of
object
and
all
descendants
)
.
/
/
/
/
/
/
Propagates
down
the
flow
tree
because
the
computation
is
bottom
-
up
.
const
STORE_OVERFLOW
=
0x04
;
/
/
/
Recompute
intrinsic
inline_sizes
(
minimum
and
preferred
)
.
/
/
/
/
/
/
Propagates
down
the
flow
tree
because
the
computation
is
.
/
/
/
bottom
-
up
.
const
BUBBLE_ISIZES
=
0x08
;
/
/
/
Recompute
actual
inline
-
sizes
and
block
-
sizes
only
taking
/
/
/
out
-
of
-
flow
children
into
account
.
/
/
/
/
/
/
Propagates
up
the
flow
tree
because
the
computation
is
top
-
down
.
const
REFLOW_OUT_OF_FLOW
=
0x10
;
/
/
/
Recompute
actual
inline_sizes
and
block_sizes
.
/
/
/
/
/
/
Propagates
up
the
flow
tree
because
the
computation
is
top
-
down
.
const
REFLOW
=
0x20
;
/
/
/
Re
-
resolve
generated
content
.
/
/
/
/
/
/
Propagates
up
the
flow
tree
because
the
computation
is
inorder
.
const
RESOLVE_GENERATED_CONTENT
=
0x40
;
/
/
/
The
entire
flow
needs
to
be
reconstructed
.
const
RECONSTRUCT_FLOW
=
0x80
;
}
}
malloc_size_of_is_0
!
(
ServoRestyleDamage
)
;
impl
ServoRestyleDamage
{
pub
fn
compute_style_difference
(
old
:
&
ComputedValues
new
:
&
ComputedValues
)
-
>
StyleDifference
{
let
damage
=
compute_damage
(
old
new
)
;
let
change
=
if
damage
.
is_empty
(
)
{
StyleChange
:
:
Unchanged
}
else
{
StyleChange
:
:
Changed
{
reset_only
:
false
}
}
;
StyleDifference
{
damage
change
}
}
pub
fn
rebuild_and_reflow
(
)
-
>
ServoRestyleDamage
{
ServoRestyleDamage
:
:
REPAINT
|
ServoRestyleDamage
:
:
REPOSITION
|
ServoRestyleDamage
:
:
STORE_OVERFLOW
|
ServoRestyleDamage
:
:
BUBBLE_ISIZES
|
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
|
ServoRestyleDamage
:
:
RECONSTRUCT_FLOW
}
pub
fn
reconstruct
(
)
-
>
ServoRestyleDamage
{
ServoRestyleDamage
:
:
RECONSTRUCT_FLOW
}
pub
fn
damage_for_parent
(
self
child_is_absolutely_positioned
:
bool
)
-
>
ServoRestyleDamage
{
if
child_is_absolutely_positioned
{
self
&
(
ServoRestyleDamage
:
:
REPAINT
|
ServoRestyleDamage
:
:
REPOSITION
|
ServoRestyleDamage
:
:
STORE_OVERFLOW
|
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
RESOLVE_GENERATED_CONTENT
)
}
else
{
self
&
(
ServoRestyleDamage
:
:
REPAINT
|
ServoRestyleDamage
:
:
REPOSITION
|
ServoRestyleDamage
:
:
STORE_OVERFLOW
|
ServoRestyleDamage
:
:
REFLOW
|
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
RESOLVE_GENERATED_CONTENT
)
}
}
pub
fn
damage_for_child
(
self
parent_is_absolutely_positioned
:
bool
child_is_absolutely_positioned
:
bool
)
-
>
ServoRestyleDamage
{
match
(
parent_is_absolutely_positioned
child_is_absolutely_positioned
)
{
(
false
true
)
=
>
{
self
&
(
ServoRestyleDamage
:
:
REPAINT
|
ServoRestyleDamage
:
:
REPOSITION
)
}
(
true
false
)
=
>
{
if
self
.
contains
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
)
{
self
|
ServoRestyleDamage
:
:
REFLOW
}
else
{
self
}
}
_
=
>
{
self
&
(
ServoRestyleDamage
:
:
REPAINT
|
ServoRestyleDamage
:
:
REPOSITION
|
ServoRestyleDamage
:
:
REFLOW
)
}
}
}
}
impl
Default
for
ServoRestyleDamage
{
fn
default
(
)
-
>
Self
{
Self
:
:
empty
(
)
}
}
impl
fmt
:
:
Display
for
ServoRestyleDamage
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
let
mut
first_elem
=
true
;
let
to_iter
=
[
(
ServoRestyleDamage
:
:
REPAINT
"
Repaint
"
)
(
ServoRestyleDamage
:
:
REPOSITION
"
Reposition
"
)
(
ServoRestyleDamage
:
:
STORE_OVERFLOW
"
StoreOverflow
"
)
(
ServoRestyleDamage
:
:
BUBBLE_ISIZES
"
BubbleISizes
"
)
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
"
ReflowOutOfFlow
"
)
(
ServoRestyleDamage
:
:
REFLOW
"
Reflow
"
)
(
ServoRestyleDamage
:
:
RESOLVE_GENERATED_CONTENT
"
ResolveGeneratedContent
"
)
(
ServoRestyleDamage
:
:
RECONSTRUCT_FLOW
"
ReconstructFlow
"
)
]
;
for
&
(
damage
damage_str
)
in
&
to_iter
{
if
self
.
contains
(
damage
)
{
if
!
first_elem
{
write
!
(
f
"
|
"
)
?
;
}
write
!
(
f
"
{
}
"
damage_str
)
?
;
first_elem
=
false
;
}
}
if
first_elem
{
write
!
(
f
"
NoDamage
"
)
?
;
}
Ok
(
(
)
)
}
}
fn
compute_damage
(
old
:
&
ComputedValues
new
:
&
ComputedValues
)
-
>
ServoRestyleDamage
{
let
mut
damage
=
ServoRestyleDamage
:
:
empty
(
)
;
let
_
=
restyle_damage_rebuild_and_reflow
!
(
old
new
damage
[
ServoRestyleDamage
:
:
REPAINT
ServoRestyleDamage
:
:
REPOSITION
ServoRestyleDamage
:
:
STORE_OVERFLOW
ServoRestyleDamage
:
:
BUBBLE_ISIZES
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
ServoRestyleDamage
:
:
REFLOW
ServoRestyleDamage
:
:
RECONSTRUCT_FLOW
]
)
|
|
(
new
.
get_box
(
)
.
display
=
=
Display
:
:
Inline
&
&
restyle_damage_rebuild_and_reflow_inline
!
(
old
new
damage
[
ServoRestyleDamage
:
:
REPAINT
ServoRestyleDamage
:
:
REPOSITION
ServoRestyleDamage
:
:
STORE_OVERFLOW
ServoRestyleDamage
:
:
BUBBLE_ISIZES
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
ServoRestyleDamage
:
:
REFLOW
ServoRestyleDamage
:
:
RECONSTRUCT_FLOW
]
)
)
|
|
restyle_damage_reflow
!
(
old
new
damage
[
ServoRestyleDamage
:
:
REPAINT
ServoRestyleDamage
:
:
REPOSITION
ServoRestyleDamage
:
:
STORE_OVERFLOW
ServoRestyleDamage
:
:
BUBBLE_ISIZES
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
ServoRestyleDamage
:
:
REFLOW
]
)
|
|
restyle_damage_reflow_out_of_flow
!
(
old
new
damage
[
ServoRestyleDamage
:
:
REPAINT
ServoRestyleDamage
:
:
REPOSITION
ServoRestyleDamage
:
:
STORE_OVERFLOW
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
]
)
|
|
restyle_damage_repaint
!
(
old
new
damage
[
ServoRestyleDamage
:
:
REPAINT
]
)
;
if
old
.
custom_properties
(
)
!
=
new
.
custom_properties
(
)
{
damage
.
insert
(
ServoRestyleDamage
:
:
REPAINT
)
;
}
if
old
.
transform_requires_layer
(
)
!
=
new
.
transform_requires_layer
(
)
{
damage
.
insert
(
ServoRestyleDamage
:
:
rebuild_and_reflow
(
)
)
;
}
damage
}
