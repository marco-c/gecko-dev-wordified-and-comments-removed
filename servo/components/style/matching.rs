#
!
[
allow
(
unsafe_code
)
]
#
!
[
deny
(
missing_docs
)
]
use
crate
:
:
computed_value_flags
:
:
ComputedValueFlags
;
use
crate
:
:
context
:
:
{
ElementCascadeInputs
QuirksMode
}
;
use
crate
:
:
context
:
:
{
SharedStyleContext
StyleContext
}
;
use
crate
:
:
data
:
:
{
ElementData
ElementStyles
}
;
use
crate
:
:
dom
:
:
TElement
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
crate
:
:
dom
:
:
TNode
;
use
crate
:
:
invalidation
:
:
element
:
:
restyle_hints
:
:
RestyleHint
;
use
crate
:
:
properties
:
:
longhands
:
:
display
:
:
computed_value
:
:
T
as
Display
;
use
crate
:
:
properties
:
:
ComputedValues
;
use
crate
:
:
properties
:
:
PropertyDeclarationBlock
;
use
crate
:
:
rule_tree
:
:
{
CascadeLevel
StrongRuleNode
}
;
use
crate
:
:
selector_parser
:
:
{
PseudoElement
RestyleDamage
}
;
use
crate
:
:
shared_lock
:
:
Locked
;
use
crate
:
:
style_resolver
:
:
StyleResolverForElement
;
use
crate
:
:
style_resolver
:
:
{
PseudoElementResolution
ResolvedElementStyles
}
;
use
crate
:
:
stylesheets
:
:
layer_rule
:
:
LayerOrder
;
use
crate
:
:
stylist
:
:
RuleInclusion
;
use
crate
:
:
traversal_flags
:
:
TraversalFlags
;
use
servo_arc
:
:
{
Arc
ArcBorrow
}
;
#
[
derive
(
Debug
)
]
pub
struct
StyleDifference
{
pub
damage
:
RestyleDamage
pub
change
:
StyleChange
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
StyleChange
{
Unchanged
Changed
{
reset_only
:
bool
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Ord
PartialEq
PartialOrd
)
]
pub
enum
ChildRestyleRequirement
{
CanSkipCascade
=
0
MustCascadeChildrenIfInheritResetStyle
=
1
MustCascadeChildren
=
2
MustCascadeDescendants
=
3
MustMatchDescendants
=
4
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
enum
CascadeVisitedMode
{
Unvisited
Visited
}
trait
PrivateMatchMethods
:
TElement
{
fn
replace_single_rule_node
(
context
:
&
SharedStyleContext
level
:
CascadeLevel
layer_order
:
LayerOrder
pdb
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
path
:
&
mut
StrongRuleNode
)
-
>
bool
{
let
stylist
=
&
context
.
stylist
;
let
guards
=
&
context
.
guards
;
let
mut
important_rules_changed
=
false
;
let
new_node
=
stylist
.
rule_tree
(
)
.
update_rule_at_level
(
level
layer_order
pdb
path
guards
&
mut
important_rules_changed
)
;
if
let
Some
(
n
)
=
new_node
{
*
path
=
n
;
}
important_rules_changed
}
fn
replace_rules_internal
(
&
self
replacements
:
RestyleHint
context
:
&
mut
StyleContext
<
Self
>
cascade_visited
:
CascadeVisitedMode
cascade_inputs
:
&
mut
ElementCascadeInputs
)
-
>
bool
{
debug_assert
!
(
replacements
.
intersects
(
RestyleHint
:
:
replacements
(
)
)
&
&
(
replacements
&
!
RestyleHint
:
:
replacements
(
)
)
.
is_empty
(
)
)
;
let
primary_rules
=
match
cascade_visited
{
CascadeVisitedMode
:
:
Unvisited
=
>
cascade_inputs
.
primary
.
rules
.
as_mut
(
)
CascadeVisitedMode
:
:
Visited
=
>
cascade_inputs
.
primary
.
visited_rules
.
as_mut
(
)
}
;
let
primary_rules
=
match
primary_rules
{
Some
(
r
)
=
>
r
None
=
>
return
false
}
;
if
!
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
{
let
mut
result
=
false
;
if
replacements
.
contains
(
RestyleHint
:
:
RESTYLE_STYLE_ATTRIBUTE
)
{
let
style_attribute
=
self
.
style_attribute
(
)
;
result
|
=
Self
:
:
replace_single_rule_node
(
context
.
shared
CascadeLevel
:
:
same_tree_author_normal
(
)
LayerOrder
:
:
style_attribute
(
)
style_attribute
primary_rules
)
;
result
|
=
Self
:
:
replace_single_rule_node
(
context
.
shared
CascadeLevel
:
:
same_tree_author_important
(
)
LayerOrder
:
:
style_attribute
(
)
style_attribute
primary_rules
)
;
self
.
unset_dirty_style_attribute
(
)
;
}
return
result
;
}
if
replacements
.
intersects
(
RestyleHint
:
:
for_animations
(
)
)
{
debug_assert
!
(
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
)
;
if
replacements
.
contains
(
RestyleHint
:
:
RESTYLE_SMIL
)
{
Self
:
:
replace_single_rule_node
(
context
.
shared
CascadeLevel
:
:
SMILOverride
LayerOrder
:
:
root
(
)
self
.
smil_override
(
)
primary_rules
)
;
}
if
replacements
.
contains
(
RestyleHint
:
:
RESTYLE_CSS_TRANSITIONS
)
{
Self
:
:
replace_single_rule_node
(
context
.
shared
CascadeLevel
:
:
Transitions
LayerOrder
:
:
root
(
)
self
.
transition_rule
(
&
context
.
shared
)
.
as_ref
(
)
.
map
(
|
a
|
a
.
borrow_arc
(
)
)
primary_rules
)
;
}
if
replacements
.
contains
(
RestyleHint
:
:
RESTYLE_CSS_ANIMATIONS
)
{
Self
:
:
replace_single_rule_node
(
context
.
shared
CascadeLevel
:
:
Animations
LayerOrder
:
:
root
(
)
self
.
animation_rule
(
&
context
.
shared
)
.
as_ref
(
)
.
map
(
|
a
|
a
.
borrow_arc
(
)
)
primary_rules
)
;
}
}
false
}
fn
after_change_style
(
&
self
context
:
&
mut
StyleContext
<
Self
>
primary_style
:
&
Arc
<
ComputedValues
>
)
-
>
Option
<
Arc
<
ComputedValues
>
>
{
StyleResolverForElement
:
:
new
(
*
self
context
RuleInclusion
:
:
All
PseudoElementResolution
:
:
IfApplicable
)
.
after_change_style
(
primary_style
)
}
fn
needs_animations_update
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_style
:
Option
<
&
ComputedValues
>
new_style
:
&
ComputedValues
pseudo_element
:
Option
<
PseudoElement
>
)
-
>
bool
{
let
new_ui_style
=
new_style
.
get_ui
(
)
;
let
new_style_specifies_animations
=
new_ui_style
.
specifies_animations
(
)
;
let
has_animations
=
self
.
has_css_animations
(
&
context
.
shared
pseudo_element
)
;
if
!
new_style_specifies_animations
&
&
!
has_animations
{
return
false
;
}
let
old_style
=
match
old_style
{
Some
(
old
)
=
>
old
None
=
>
{
return
new_style_specifies_animations
|
|
new_style
.
is_pseudo_style
(
)
;
}
}
;
let
old_ui_style
=
old_style
.
get_ui
(
)
;
let
keyframes_could_have_changed
=
context
.
shared
.
traversal_flags
.
contains
(
TraversalFlags
:
:
ForCSSRuleChanges
)
;
if
keyframes_could_have_changed
{
return
true
;
}
if
!
old_ui_style
.
animations_equals
(
new_ui_style
)
{
return
true
;
}
let
old_display
=
old_style
.
clone_display
(
)
;
let
new_display
=
new_style
.
clone_display
(
)
;
if
old_display
=
=
Display
:
:
None
&
&
new_display
!
=
Display
:
:
None
{
return
new_style_specifies_animations
;
}
if
old_display
!
=
Display
:
:
None
&
&
new_display
=
=
Display
:
:
None
{
return
has_animations
;
}
if
new_style
.
writing_mode
!
=
old_style
.
writing_mode
{
return
has_animations
;
}
false
}
fn
might_need_transitions_update
(
&
self
context
:
&
StyleContext
<
Self
>
old_style
:
Option
<
&
ComputedValues
>
new_style
:
&
ComputedValues
pseudo_element
:
Option
<
PseudoElement
>
)
-
>
bool
{
let
old_style
=
match
old_style
{
Some
(
v
)
=
>
v
None
=
>
return
false
}
;
if
!
self
.
has_css_transitions
(
context
.
shared
pseudo_element
)
&
&
!
new_style
.
get_ui
(
)
.
specifies_transitions
(
)
{
return
false
;
}
if
old_style
.
clone_display
(
)
.
is_none
(
)
{
return
false
;
}
return
true
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
handle_display_change_for_smil_if_needed
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
Option
<
&
ComputedValues
>
new_values
:
&
ComputedValues
restyle_hints
:
RestyleHint
)
{
use
crate
:
:
context
:
:
PostAnimationTasks
;
if
!
restyle_hints
.
intersects
(
RestyleHint
:
:
RESTYLE_SMIL
)
{
return
;
}
if
new_values
.
is_display_property_changed_from_none
(
old_values
)
{
let
task
=
crate
:
:
context
:
:
SequentialTask
:
:
process_post_animation
(
*
self
PostAnimationTasks
:
:
DISPLAY_CHANGED_FROM_NONE_FOR_SMIL
)
;
context
.
thread_local
.
tasks
.
push
(
task
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
maybe_resolve_starting_style
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
Option
<
&
Arc
<
ComputedValues
>
>
new_styles
:
&
ResolvedElementStyles
)
-
>
Option
<
Arc
<
ComputedValues
>
>
{
if
!
new_styles
.
may_have_starting_style
(
)
|
|
!
new_styles
.
primary_style
(
)
.
get_ui
(
)
.
specifies_transitions
(
)
{
return
None
;
}
if
old_values
.
is_some
(
)
&
&
!
new_styles
.
primary_style
(
)
.
is_display_property_changed_from_none
(
old_values
.
map
(
|
s
|
&
*
*
s
)
)
{
return
None
;
}
let
mut
resolver
=
StyleResolverForElement
:
:
new
(
*
self
context
RuleInclusion
:
:
All
PseudoElementResolution
:
:
IfApplicable
)
;
let
starting_style
=
resolver
.
resolve_starting_style
(
)
.
style
;
if
starting_style
.
style
(
)
.
clone_display
(
)
.
is_none
(
)
{
return
None
;
}
Some
(
starting_style
.
0
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
process_transitions
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
Option
<
&
Arc
<
ComputedValues
>
>
new_styles
:
&
mut
ResolvedElementStyles
)
-
>
Option
<
Arc
<
ComputedValues
>
>
{
let
starting_values
=
self
.
maybe_resolve_starting_style
(
context
old_values
new_styles
)
;
let
before_change_or_starting
=
if
starting_values
.
is_some
(
)
{
starting_values
.
as_ref
(
)
}
else
{
old_values
}
;
let
new_values
=
new_styles
.
primary_style_mut
(
)
;
if
!
self
.
might_need_transitions_update
(
context
before_change_or_starting
.
map
(
|
s
|
&
*
*
s
)
new_values
None
)
{
return
None
;
}
let
after_change_style
=
if
self
.
has_css_transitions
(
context
.
shared
None
)
{
self
.
after_change_style
(
context
new_values
)
}
else
{
None
}
;
if
!
self
.
needs_transitions_update
(
before_change_or_starting
.
unwrap
(
)
after_change_style
.
as_ref
(
)
.
unwrap_or
(
&
new_values
)
)
{
return
None
;
}
if
let
Some
(
values_without_transitions
)
=
after_change_style
{
*
new_values
=
values_without_transitions
;
}
if
starting_values
.
is_some
(
)
{
starting_values
}
else
{
old_values
.
cloned
(
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
process_animations
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_styles
:
&
mut
ElementStyles
new_styles
:
&
mut
ResolvedElementStyles
restyle_hint
:
RestyleHint
important_rules_changed
:
bool
)
{
use
crate
:
:
context
:
:
UpdateAnimationsTasks
;
let
old_values
=
&
old_styles
.
primary
;
if
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
{
self
.
handle_display_change_for_smil_if_needed
(
context
old_values
.
as_deref
(
)
new_styles
.
primary_style
(
)
restyle_hint
)
;
return
;
}
let
mut
tasks
=
UpdateAnimationsTasks
:
:
empty
(
)
;
if
old_values
.
as_deref
(
)
.
map_or_else
(
|
|
{
new_styles
.
primary_style
(
)
.
get_ui
(
)
.
specifies_scroll_timelines
(
)
}
|
old
|
{
!
old
.
get_ui
(
)
.
scroll_timelines_equals
(
new_styles
.
primary_style
(
)
.
get_ui
(
)
)
}
)
{
tasks
.
insert
(
UpdateAnimationsTasks
:
:
SCROLL_TIMELINES
)
;
}
if
old_values
.
as_deref
(
)
.
map_or_else
(
|
|
{
new_styles
.
primary_style
(
)
.
get_ui
(
)
.
specifies_view_timelines
(
)
}
|
old
|
{
!
old
.
get_ui
(
)
.
view_timelines_equals
(
new_styles
.
primary_style
(
)
.
get_ui
(
)
)
}
)
{
tasks
.
insert
(
UpdateAnimationsTasks
:
:
VIEW_TIMELINES
)
;
}
if
self
.
needs_animations_update
(
context
old_values
.
as_deref
(
)
new_styles
.
primary_style
(
)
None
)
{
tasks
.
insert
(
UpdateAnimationsTasks
:
:
CSS_ANIMATIONS
)
;
}
let
before_change_style
=
self
.
process_transitions
(
context
old_values
.
as_ref
(
)
new_styles
)
;
if
before_change_style
.
is_some
(
)
{
tasks
.
insert
(
UpdateAnimationsTasks
:
:
CSS_TRANSITIONS
)
;
}
if
self
.
has_animations
(
&
context
.
shared
)
{
tasks
.
insert
(
UpdateAnimationsTasks
:
:
EFFECT_PROPERTIES
)
;
if
important_rules_changed
{
tasks
.
insert
(
UpdateAnimationsTasks
:
:
CASCADE_RESULTS
)
;
}
if
new_styles
.
primary_style
(
)
.
is_display_property_changed_from_none
(
old_values
.
as_deref
(
)
)
{
tasks
.
insert
(
UpdateAnimationsTasks
:
:
DISPLAY_CHANGED_FROM_NONE
)
;
}
}
if
!
tasks
.
is_empty
(
)
{
let
task
=
crate
:
:
context
:
:
SequentialTask
:
:
update_animations
(
*
self
before_change_style
tasks
)
;
context
.
thread_local
.
tasks
.
push
(
task
)
;
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
process_animations
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_styles
:
&
mut
ElementStyles
new_resolved_styles
:
&
mut
ResolvedElementStyles
_restyle_hint
:
RestyleHint
_important_rules_changed
:
bool
)
{
use
crate
:
:
animation
:
:
AnimationSetKey
;
use
crate
:
:
dom
:
:
TDocument
;
let
style_changed
=
self
.
process_animations_for_style
(
context
&
mut
old_styles
.
primary
new_resolved_styles
.
primary_style_mut
(
)
None
)
;
if
style_changed
{
let
mut
rule_node
=
new_resolved_styles
.
primary_style
(
)
.
rules
(
)
.
clone
(
)
;
let
declarations
=
context
.
shared
.
animations
.
get_all_declarations
(
&
AnimationSetKey
:
:
new_for_non_pseudo
(
self
.
as_node
(
)
.
opaque
(
)
)
context
.
shared
.
current_time_for_animations
self
.
as_node
(
)
.
owner_doc
(
)
.
shared_lock
(
)
)
;
Self
:
:
replace_single_rule_node
(
&
context
.
shared
CascadeLevel
:
:
Transitions
declarations
.
transitions
.
as_ref
(
)
.
map
(
|
a
|
a
.
borrow_arc
(
)
)
&
mut
rule_node
)
;
Self
:
:
replace_single_rule_node
(
&
context
.
shared
CascadeLevel
:
:
Animations
declarations
.
animations
.
as_ref
(
)
.
map
(
|
a
|
a
.
borrow_arc
(
)
)
&
mut
rule_node
)
;
if
rule_node
!
=
*
new_resolved_styles
.
primary_style
(
)
.
rules
(
)
{
let
inputs
=
CascadeInputs
{
rules
:
Some
(
rule_node
)
visited_rules
:
new_resolved_styles
.
primary_style
(
)
.
visited_rules
(
)
.
cloned
(
)
}
;
new_resolved_styles
.
primary
.
style
=
StyleResolverForElement
:
:
new
(
*
self
context
RuleInclusion
:
:
All
PseudoElementResolution
:
:
IfApplicable
)
.
cascade_style_and_visited_with_default_parents
(
inputs
)
;
}
}
self
.
process_animations_for_pseudo
(
context
old_styles
new_resolved_styles
PseudoElement
:
:
Before
)
;
self
.
process_animations_for_pseudo
(
context
old_styles
new_resolved_styles
PseudoElement
:
:
After
)
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
process_animations_for_pseudo
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_styles
:
&
mut
ElementStyles
new_resolved_styles
:
&
mut
ResolvedElementStyles
pseudo_element
:
PseudoElement
)
{
use
crate
:
:
animation
:
:
AnimationSetKey
;
use
crate
:
:
dom
:
:
TDocument
;
let
key
=
AnimationSetKey
:
:
new_for_pseudo
(
self
.
as_node
(
)
.
opaque
(
)
pseudo_element
.
clone
(
)
)
;
let
mut
style
=
match
new_resolved_styles
.
pseudos
.
get
(
&
pseudo_element
)
{
Some
(
style
)
=
>
Arc
:
:
clone
(
style
)
None
=
>
{
context
.
shared
.
animations
.
cancel_all_animations_for_key
(
&
key
)
;
return
;
}
}
;
let
mut
old_style
=
old_styles
.
pseudos
.
get
(
&
pseudo_element
)
.
cloned
(
)
;
self
.
process_animations_for_style
(
context
&
mut
old_style
&
mut
style
Some
(
pseudo_element
.
clone
(
)
)
)
;
let
declarations
=
context
.
shared
.
animations
.
get_all_declarations
(
&
key
context
.
shared
.
current_time_for_animations
self
.
as_node
(
)
.
owner_doc
(
)
.
shared_lock
(
)
)
;
if
declarations
.
is_empty
(
)
{
return
;
}
let
mut
rule_node
=
style
.
rules
(
)
.
clone
(
)
;
Self
:
:
replace_single_rule_node
(
&
context
.
shared
CascadeLevel
:
:
Transitions
LayerOrder
:
:
root
(
)
declarations
.
transitions
.
as_ref
(
)
.
map
(
|
a
|
a
.
borrow_arc
(
)
)
&
mut
rule_node
)
;
Self
:
:
replace_single_rule_node
(
&
context
.
shared
CascadeLevel
:
:
Animations
LayerOrder
:
:
root
(
)
declarations
.
animations
.
as_ref
(
)
.
map
(
|
a
|
a
.
borrow_arc
(
)
)
&
mut
rule_node
)
;
if
rule_node
=
=
*
style
.
rules
(
)
{
return
;
}
let
inputs
=
CascadeInputs
{
rules
:
Some
(
rule_node
)
visited_rules
:
style
.
visited_rules
(
)
.
cloned
(
)
}
;
let
new_style
=
StyleResolverForElement
:
:
new
(
*
self
context
RuleInclusion
:
:
All
PseudoElementResolution
:
:
IfApplicable
)
.
cascade_style_and_visited_for_pseudo_with_default_parents
(
inputs
&
pseudo_element
&
new_resolved_styles
.
primary
)
;
new_resolved_styles
.
pseudos
.
set
(
&
pseudo_element
new_style
.
0
)
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
process_animations_for_style
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
&
mut
Option
<
Arc
<
ComputedValues
>
>
new_values
:
&
mut
Arc
<
ComputedValues
>
pseudo_element
:
Option
<
PseudoElement
>
)
-
>
bool
{
use
crate
:
:
animation
:
:
{
AnimationSetKey
AnimationState
}
;
let
needs_animations_update
=
self
.
needs_animations_update
(
context
old_values
.
as_deref
(
)
new_values
pseudo_element
)
;
let
might_need_transitions_update
=
self
.
might_need_transitions_update
(
context
old_values
.
as_deref
(
)
new_values
pseudo_element
)
;
let
mut
after_change_style
=
None
;
if
might_need_transitions_update
{
after_change_style
=
self
.
after_change_style
(
context
new_values
)
;
}
let
key
=
AnimationSetKey
:
:
new
(
self
.
as_node
(
)
.
opaque
(
)
pseudo_element
)
;
let
shared_context
=
context
.
shared
;
let
mut
animation_set
=
shared_context
.
animations
.
sets
.
write
(
)
.
remove
(
&
key
)
.
unwrap_or_default
(
)
;
if
needs_animations_update
{
let
mut
resolver
=
StyleResolverForElement
:
:
new
(
*
self
context
RuleInclusion
:
:
All
PseudoElementResolution
:
:
IfApplicable
)
;
animation_set
.
update_animations_for_new_style
:
:
<
Self
>
(
*
self
&
shared_context
&
new_values
&
mut
resolver
)
;
}
animation_set
.
update_transitions_for_new_style
(
might_need_transitions_update
&
shared_context
old_values
.
as_ref
(
)
after_change_style
.
as_ref
(
)
.
unwrap_or
(
new_values
)
)
;
animation_set
.
transitions
.
retain
(
|
transition
|
transition
.
state
!
=
AnimationState
:
:
Finished
)
;
let
changed_animations
=
animation_set
.
dirty
;
if
!
animation_set
.
is_empty
(
)
{
animation_set
.
dirty
=
false
;
shared_context
.
animations
.
sets
.
write
(
)
.
insert
(
key
animation_set
)
;
}
changed_animations
}
fn
accumulate_damage_for
(
&
self
shared_context
:
&
SharedStyleContext
damage
:
&
mut
RestyleDamage
old_values
:
&
ComputedValues
new_values
:
&
ComputedValues
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
ChildRestyleRequirement
{
debug
!
(
"
accumulate_damage_for
:
{
:
?
}
"
self
)
;
debug_assert
!
(
!
shared_context
.
traversal_flags
.
contains
(
TraversalFlags
:
:
FinalAnimationTraversal
)
)
;
let
difference
=
self
.
compute_style_difference
(
old_values
new_values
pseudo
)
;
*
damage
|
=
difference
.
damage
;
debug
!
(
"
>
style
difference
:
{
:
?
}
"
difference
)
;
if
old_values
.
flags
.
maybe_inherited
(
)
!
=
new_values
.
flags
.
maybe_inherited
(
)
{
debug
!
(
"
>
flags
changed
:
{
:
?
}
!
=
{
:
?
}
"
old_values
.
flags
new_values
.
flags
)
;
return
ChildRestyleRequirement
:
:
MustCascadeChildren
;
}
if
old_values
.
effective_zoom
!
=
new_values
.
effective_zoom
{
debug
!
(
"
>
zoom
changed
:
{
:
?
}
!
=
{
:
?
}
"
old_values
.
effective_zoom
new_values
.
effective_zoom
)
;
return
ChildRestyleRequirement
:
:
MustCascadeChildren
;
}
match
difference
.
change
{
StyleChange
:
:
Unchanged
=
>
return
ChildRestyleRequirement
:
:
CanSkipCascade
StyleChange
:
:
Changed
{
reset_only
}
=
>
{
if
!
reset_only
{
return
ChildRestyleRequirement
:
:
MustCascadeChildren
;
}
}
}
let
old_display
=
old_values
.
clone_display
(
)
;
let
new_display
=
new_values
.
clone_display
(
)
;
if
old_display
!
=
new_display
{
if
old_display
=
=
Display
:
:
None
{
return
ChildRestyleRequirement
:
:
MustCascadeChildren
;
}
if
old_display
.
is_item_container
(
)
!
=
new_display
.
is_item_container
(
)
{
return
ChildRestyleRequirement
:
:
MustCascadeChildren
;
}
if
old_display
.
is_contents
(
)
|
|
new_display
.
is_contents
(
)
{
return
ChildRestyleRequirement
:
:
MustCascadeChildren
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
if
old_display
.
is_ruby_type
(
)
!
=
new_display
.
is_ruby_type
(
)
{
return
ChildRestyleRequirement
:
:
MustCascadeChildren
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
use
crate
:
:
values
:
:
specified
:
:
align
:
:
AlignFlags
;
let
old_justify_items
=
old_values
.
get_position
(
)
.
clone_justify_items
(
)
;
let
new_justify_items
=
new_values
.
get_position
(
)
.
clone_justify_items
(
)
;
let
was_legacy_justify_items
=
old_justify_items
.
computed
.
0
.
contains
(
AlignFlags
:
:
LEGACY
)
;
let
is_legacy_justify_items
=
new_justify_items
.
computed
.
0
.
contains
(
AlignFlags
:
:
LEGACY
)
;
if
is_legacy_justify_items
!
=
was_legacy_justify_items
{
return
ChildRestyleRequirement
:
:
MustCascadeChildren
;
}
if
was_legacy_justify_items
&
&
old_justify_items
.
computed
!
=
new_justify_items
.
computed
{
return
ChildRestyleRequirement
:
:
MustCascadeChildren
;
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
{
if
old_values
.
is_multicol
(
)
!
=
new_values
.
is_multicol
(
)
{
return
ChildRestyleRequirement
:
:
MustCascadeChildren
;
}
}
ChildRestyleRequirement
:
:
MustCascadeChildrenIfInheritResetStyle
}
}
impl
<
E
:
TElement
>
PrivateMatchMethods
for
E
{
}
pub
trait
MatchMethods
:
TElement
{
fn
layout_parent
(
&
self
)
-
>
Self
{
let
mut
current
=
self
.
clone
(
)
;
loop
{
current
=
match
current
.
traversal_parent
(
)
{
Some
(
el
)
=
>
el
None
=
>
return
current
}
;
let
is_display_contents
=
current
.
borrow_data
(
)
.
unwrap
(
)
.
styles
.
primary
(
)
.
is_display_contents
(
)
;
if
!
is_display_contents
{
return
current
;
}
}
}
fn
finish_restyle
(
&
self
context
:
&
mut
StyleContext
<
Self
>
data
:
&
mut
ElementData
mut
new_styles
:
ResolvedElementStyles
important_rules_changed
:
bool
)
-
>
ChildRestyleRequirement
{
use
std
:
:
cmp
;
self
.
process_animations
(
context
&
mut
data
.
styles
&
mut
new_styles
data
.
hint
important_rules_changed
)
;
let
old_styles
=
data
.
set_styles
(
new_styles
)
;
let
new_primary_style
=
data
.
styles
.
primary
.
as_ref
(
)
.
unwrap
(
)
;
let
mut
restyle_requirement
=
ChildRestyleRequirement
:
:
CanSkipCascade
;
let
is_root
=
new_primary_style
.
flags
.
contains
(
ComputedValueFlags
:
:
IS_ROOT_ELEMENT_STYLE
)
;
let
is_container
=
!
new_primary_style
.
get_box
(
)
.
clone_container_type
(
)
.
is_normal
(
)
;
if
is_root
|
|
is_container
{
let
device
=
context
.
shared
.
stylist
.
device
(
)
;
let
old_style
=
old_styles
.
primary
.
as_ref
(
)
;
let
new_font_size
=
new_primary_style
.
get_font
(
)
.
clone_font_size
(
)
;
let
old_font_size
=
old_style
.
map
(
|
s
|
s
.
get_font
(
)
.
clone_font_size
(
)
)
;
if
old_font_size
!
=
Some
(
new_font_size
)
{
if
is_root
{
debug_assert
!
(
self
.
owner_doc_matches_for_testing
(
device
)
)
;
let
size
=
new_font_size
.
computed_size
(
)
;
device
.
set_root_font_size
(
new_primary_style
.
effective_zoom
.
unzoom
(
size
.
px
(
)
)
)
;
if
device
.
used_root_font_size
(
)
{
restyle_requirement
=
ChildRestyleRequirement
:
:
MustCascadeDescendants
;
}
}
if
is_container
&
&
old_font_size
.
is_some
(
)
{
restyle_requirement
=
ChildRestyleRequirement
:
:
MustMatchDescendants
;
}
}
let
new_line_height
=
device
.
calc_line_height
(
&
new_primary_style
.
get_font
(
)
new_primary_style
.
writing_mode
None
)
.
0
;
let
old_line_height
=
old_style
.
map
(
|
s
|
{
device
.
calc_line_height
(
&
s
.
get_font
(
)
s
.
writing_mode
None
)
.
0
}
)
;
if
old_line_height
!
=
Some
(
new_line_height
)
{
if
is_root
{
debug_assert
!
(
self
.
owner_doc_matches_for_testing
(
device
)
)
;
device
.
set_root_line_height
(
new_primary_style
.
effective_zoom
.
unzoom
(
new_line_height
.
px
(
)
)
)
;
if
device
.
used_root_line_height
(
)
{
restyle_requirement
=
std
:
:
cmp
:
:
max
(
restyle_requirement
ChildRestyleRequirement
:
:
MustCascadeDescendants
)
;
}
}
if
is_container
&
&
old_line_height
.
is_some
(
)
{
restyle_requirement
=
ChildRestyleRequirement
:
:
MustMatchDescendants
;
}
}
}
if
context
.
shared
.
stylist
.
quirks_mode
(
)
=
=
QuirksMode
:
:
Quirks
{
if
self
.
is_html_document_body_element
(
)
{
let
device
=
context
.
shared
.
stylist
.
device
(
)
;
let
text_color
=
new_primary_style
.
get_inherited_text
(
)
.
clone_color
(
)
;
device
.
set_body_text_color
(
text_color
)
;
}
}
if
context
.
shared
.
traversal_flags
.
contains
(
TraversalFlags
:
:
FinalAnimationTraversal
)
{
return
ChildRestyleRequirement
:
:
MustCascadeChildren
;
}
let
old_primary_style
=
match
old_styles
.
primary
{
Some
(
s
)
=
>
s
None
=
>
return
ChildRestyleRequirement
:
:
MustCascadeChildren
}
;
let
old_container_type
=
old_primary_style
.
clone_container_type
(
)
;
let
new_container_type
=
new_primary_style
.
clone_container_type
(
)
;
if
old_container_type
!
=
new_container_type
&
&
!
new_container_type
.
is_size_container_type
(
)
{
restyle_requirement
=
ChildRestyleRequirement
:
:
MustMatchDescendants
;
}
else
if
old_container_type
.
is_size_container_type
(
)
&
&
!
old_primary_style
.
is_display_contents
(
)
&
&
new_primary_style
.
is_display_contents
(
)
{
restyle_requirement
=
ChildRestyleRequirement
:
:
MustMatchDescendants
;
}
restyle_requirement
=
cmp
:
:
max
(
restyle_requirement
self
.
accumulate_damage_for
(
context
.
shared
&
mut
data
.
damage
&
old_primary_style
new_primary_style
None
)
)
;
if
data
.
styles
.
pseudos
.
is_empty
(
)
&
&
old_styles
.
pseudos
.
is_empty
(
)
{
return
restyle_requirement
;
}
let
pseudo_styles
=
old_styles
.
pseudos
.
as_array
(
)
.
iter
(
)
.
zip
(
data
.
styles
.
pseudos
.
as_array
(
)
.
iter
(
)
)
;
for
(
i
(
old
new
)
)
in
pseudo_styles
.
enumerate
(
)
{
match
(
old
new
)
{
(
&
Some
(
ref
old
)
&
Some
(
ref
new
)
)
=
>
{
self
.
accumulate_damage_for
(
context
.
shared
&
mut
data
.
damage
old
new
Some
(
&
PseudoElement
:
:
from_eager_index
(
i
)
)
)
;
}
(
&
None
&
None
)
=
>
{
}
_
=
>
{
let
pseudo
=
PseudoElement
:
:
from_eager_index
(
i
)
;
let
new_pseudo_should_exist
=
new
.
as_ref
(
)
.
map_or
(
false
|
s
|
pseudo
.
should_exist
(
s
)
)
;
let
old_pseudo_should_exist
=
old
.
as_ref
(
)
.
map_or
(
false
|
s
|
pseudo
.
should_exist
(
s
)
)
;
if
new_pseudo_should_exist
!
=
old_pseudo_should_exist
{
data
.
damage
|
=
RestyleDamage
:
:
reconstruct
(
)
;
return
restyle_requirement
;
}
}
}
}
restyle_requirement
}
fn
replace_rules
(
&
self
replacements
:
RestyleHint
context
:
&
mut
StyleContext
<
Self
>
cascade_inputs
:
&
mut
ElementCascadeInputs
)
-
>
bool
{
let
mut
result
=
false
;
result
|
=
self
.
replace_rules_internal
(
replacements
context
CascadeVisitedMode
:
:
Unvisited
cascade_inputs
)
;
result
|
=
self
.
replace_rules_internal
(
replacements
context
CascadeVisitedMode
:
:
Visited
cascade_inputs
)
;
result
}
fn
compute_style_difference
(
&
self
old_values
:
&
ComputedValues
new_values
:
&
ComputedValues
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
StyleDifference
{
debug_assert
!
(
pseudo
.
map_or
(
true
|
p
|
p
.
is_eager
(
)
)
)
;
RestyleDamage
:
:
compute_style_difference
(
old_values
new_values
)
}
}
impl
<
E
:
TElement
>
MatchMethods
for
E
{
}
