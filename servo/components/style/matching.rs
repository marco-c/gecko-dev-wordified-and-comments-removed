#
!
[
allow
(
unsafe_code
)
]
use
{
Atom
LocalName
}
;
use
animation
;
use
atomic_refcell
:
:
AtomicRefMut
;
use
cache
:
:
LRUCache
;
use
cascade_info
:
:
CascadeInfo
;
use
context
:
:
{
SharedStyleContext
StyleContext
}
;
use
data
:
:
{
ElementData
ElementStyles
PseudoStyles
}
;
use
dom
:
:
{
TElement
TNode
TRestyleDamage
UnsafeNode
}
;
use
properties
:
:
{
CascadeFlags
ComputedValues
SHAREABLE
cascade
}
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
as
display
;
use
rule_tree
:
:
StrongRuleNode
;
use
selector_impl
:
:
{
TheSelectorImpl
PseudoElement
}
;
use
selector_matching
:
:
{
ApplicableDeclarationBlock
Stylist
}
;
use
selectors
:
:
MatchAttr
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
use
selectors
:
:
matching
:
:
{
AFFECTED_BY_PSEUDO_ELEMENTS
MatchingReason
StyleRelations
}
;
use
sink
:
:
ForgetfulSink
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
hash
:
:
BuildHasherDefault
;
use
std
:
:
mem
;
use
std
:
:
slice
:
:
IterMut
;
use
std
:
:
sync
:
:
Arc
;
use
util
:
:
opts
;
fn
create_common_style_affecting_attributes_from_element
<
E
:
TElement
>
(
element
:
&
E
)
-
>
CommonStyleAffectingAttributes
{
let
mut
flags
=
CommonStyleAffectingAttributes
:
:
empty
(
)
;
for
attribute_info
in
&
common_style_affecting_attributes
(
)
{
match
attribute_info
.
mode
{
CommonStyleAffectingAttributeMode
:
:
IsPresent
(
flag
)
=
>
{
if
element
.
has_attr
(
&
ns
!
(
)
&
attribute_info
.
attr_name
)
{
flags
.
insert
(
flag
)
}
}
CommonStyleAffectingAttributeMode
:
:
IsEqual
(
ref
target_value
flag
)
=
>
{
if
element
.
attr_equals
(
&
ns
!
(
)
&
attribute_info
.
attr_name
target_value
)
{
flags
.
insert
(
flag
)
}
}
}
}
flags
}
pub
struct
ApplicableDeclarations
{
pub
normal
:
Vec
<
ApplicableDeclarationBlock
>
pub
per_pseudo
:
HashMap
<
PseudoElement
Vec
<
ApplicableDeclarationBlock
>
BuildHasherDefault
<
:
:
fnv
:
:
FnvHasher
>
>
pub
normal_shareable
:
bool
}
impl
ApplicableDeclarations
{
pub
fn
new
(
)
-
>
Self
{
let
mut
applicable_declarations
=
ApplicableDeclarations
{
normal
:
Vec
:
:
with_capacity
(
16
)
per_pseudo
:
HashMap
:
:
with_hasher
(
Default
:
:
default
(
)
)
normal_shareable
:
false
}
;
TheSelectorImpl
:
:
each_eagerly_cascaded_pseudo_element
(
|
pseudo
|
{
applicable_declarations
.
per_pseudo
.
insert
(
pseudo
vec
!
[
]
)
;
}
)
;
applicable_declarations
}
}
#
[
derive
(
Debug
)
]
struct
StyleSharingCandidate
{
node
:
UnsafeNode
common_style_affecting_attributes
:
Option
<
CommonStyleAffectingAttributes
>
class_attributes
:
Option
<
Vec
<
Atom
>
>
}
impl
PartialEq
<
StyleSharingCandidate
>
for
StyleSharingCandidate
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
node
=
=
other
.
node
&
&
self
.
common_style_affecting_attributes
=
=
other
.
common_style_affecting_attributes
}
}
pub
struct
StyleSharingCandidateCache
{
cache
:
LRUCache
<
StyleSharingCandidate
(
)
>
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
CacheMiss
{
Parent
LocalName
Namespace
Link
State
IdAttr
StyleAttr
Class
CommonStyleAffectingAttributes
PresHints
SiblingRules
NonCommonAttrRules
}
fn
element_matches_candidate
<
E
:
TElement
>
(
element
:
&
E
candidate
:
&
mut
StyleSharingCandidate
candidate_element
:
&
E
shared_context
:
&
SharedStyleContext
)
-
>
Result
<
(
Arc
<
ComputedValues
>
StrongRuleNode
)
CacheMiss
>
{
macro_rules
!
miss
{
(
miss
:
ident
)
=
>
{
return
Err
(
CacheMiss
:
:
miss
)
;
}
}
if
element
.
parent_element
(
)
!
=
candidate_element
.
parent_element
(
)
{
miss
!
(
Parent
)
}
if
*
element
.
get_local_name
(
)
!
=
*
candidate_element
.
get_local_name
(
)
{
miss
!
(
LocalName
)
}
if
*
element
.
get_namespace
(
)
!
=
*
candidate_element
.
get_namespace
(
)
{
miss
!
(
Namespace
)
}
if
element
.
is_link
(
)
!
=
candidate_element
.
is_link
(
)
{
miss
!
(
Link
)
}
if
element
.
get_state
(
)
!
=
candidate_element
.
get_state
(
)
{
miss
!
(
State
)
}
if
element
.
get_id
(
)
.
is_some
(
)
{
miss
!
(
IdAttr
)
}
if
element
.
style_attribute
(
)
.
is_some
(
)
{
miss
!
(
StyleAttr
)
}
if
!
have_same_class
(
element
candidate
candidate_element
)
{
miss
!
(
Class
)
}
if
!
have_same_common_style_affecting_attributes
(
element
candidate
candidate_element
)
{
miss
!
(
CommonStyleAffectingAttributes
)
}
if
!
have_same_presentational_hints
(
element
candidate_element
)
{
miss
!
(
PresHints
)
}
if
!
match_same_sibling_affecting_rules
(
element
candidate_element
shared_context
)
{
miss
!
(
SiblingRules
)
}
if
!
match_same_not_common_style_affecting_attributes_rules
(
element
candidate_element
shared_context
)
{
miss
!
(
NonCommonAttrRules
)
}
let
data
=
candidate_element
.
borrow_data
(
)
.
unwrap
(
)
;
let
current_styles
=
data
.
get_current_styles
(
)
.
unwrap
(
)
;
Ok
(
(
current_styles
.
primary
.
clone
(
)
current_styles
.
rule_node
.
clone
(
)
)
)
}
fn
have_same_common_style_affecting_attributes
<
E
:
TElement
>
(
element
:
&
E
candidate
:
&
mut
StyleSharingCandidate
candidate_element
:
&
E
)
-
>
bool
{
if
candidate
.
common_style_affecting_attributes
.
is_none
(
)
{
candidate
.
common_style_affecting_attributes
=
Some
(
create_common_style_affecting_attributes_from_element
(
candidate_element
)
)
}
create_common_style_affecting_attributes_from_element
(
element
)
=
=
candidate
.
common_style_affecting_attributes
.
unwrap
(
)
}
fn
have_same_presentational_hints
<
E
:
TElement
>
(
element
:
&
E
candidate
:
&
E
)
-
>
bool
{
let
mut
first
=
ForgetfulSink
:
:
new
(
)
;
element
.
synthesize_presentational_hints_for_legacy_attributes
(
&
mut
first
)
;
if
cfg
!
(
debug_assertions
)
{
let
mut
second
=
vec
!
[
]
;
candidate
.
synthesize_presentational_hints_for_legacy_attributes
(
&
mut
second
)
;
debug_assert
!
(
second
.
is_empty
(
)
"
Should
never
have
inserted
an
element
with
preshints
in
the
cache
!
"
)
;
}
first
.
is_empty
(
)
}
bitflags
!
{
pub
flags
CommonStyleAffectingAttributes
:
u8
{
const
HIDDEN_ATTRIBUTE
=
0x01
const
NO_WRAP_ATTRIBUTE
=
0x02
const
ALIGN_LEFT_ATTRIBUTE
=
0x04
const
ALIGN_CENTER_ATTRIBUTE
=
0x08
const
ALIGN_RIGHT_ATTRIBUTE
=
0x10
}
}
pub
struct
CommonStyleAffectingAttributeInfo
{
pub
attr_name
:
LocalName
pub
mode
:
CommonStyleAffectingAttributeMode
}
#
[
derive
(
Clone
)
]
pub
enum
CommonStyleAffectingAttributeMode
{
IsPresent
(
CommonStyleAffectingAttributes
)
IsEqual
(
Atom
CommonStyleAffectingAttributes
)
}
#
[
inline
]
pub
fn
common_style_affecting_attributes
(
)
-
>
[
CommonStyleAffectingAttributeInfo
;
5
]
{
[
CommonStyleAffectingAttributeInfo
{
attr_name
:
local_name
!
(
"
hidden
"
)
mode
:
CommonStyleAffectingAttributeMode
:
:
IsPresent
(
HIDDEN_ATTRIBUTE
)
}
CommonStyleAffectingAttributeInfo
{
attr_name
:
local_name
!
(
"
nowrap
"
)
mode
:
CommonStyleAffectingAttributeMode
:
:
IsPresent
(
NO_WRAP_ATTRIBUTE
)
}
CommonStyleAffectingAttributeInfo
{
attr_name
:
local_name
!
(
"
align
"
)
mode
:
CommonStyleAffectingAttributeMode
:
:
IsEqual
(
atom
!
(
"
left
"
)
ALIGN_LEFT_ATTRIBUTE
)
}
CommonStyleAffectingAttributeInfo
{
attr_name
:
local_name
!
(
"
align
"
)
mode
:
CommonStyleAffectingAttributeMode
:
:
IsEqual
(
atom
!
(
"
center
"
)
ALIGN_CENTER_ATTRIBUTE
)
}
CommonStyleAffectingAttributeInfo
{
attr_name
:
local_name
!
(
"
align
"
)
mode
:
CommonStyleAffectingAttributeMode
:
:
IsEqual
(
atom
!
(
"
right
"
)
ALIGN_RIGHT_ATTRIBUTE
)
}
]
}
pub
fn
rare_style_affecting_attributes
(
)
-
>
[
LocalName
;
3
]
{
[
local_name
!
(
"
bgcolor
"
)
local_name
!
(
"
border
"
)
local_name
!
(
"
colspan
"
)
]
}
fn
have_same_class
<
E
:
TElement
>
(
element
:
&
E
candidate
:
&
mut
StyleSharingCandidate
candidate_element
:
&
E
)
-
>
bool
{
let
mut
element_class_attributes
=
vec
!
[
]
;
element
.
each_class
(
|
c
|
element_class_attributes
.
push
(
c
.
clone
(
)
)
)
;
if
candidate
.
class_attributes
.
is_none
(
)
{
let
mut
attrs
=
vec
!
[
]
;
candidate_element
.
each_class
(
|
c
|
attrs
.
push
(
c
.
clone
(
)
)
)
;
candidate
.
class_attributes
=
Some
(
attrs
)
}
element_class_attributes
=
=
*
candidate
.
class_attributes
.
as_ref
(
)
.
unwrap
(
)
}
#
[
inline
]
fn
match_same_not_common_style_affecting_attributes_rules
<
E
:
TElement
>
(
element
:
&
E
candidate
:
&
E
ctx
:
&
SharedStyleContext
)
-
>
bool
{
ctx
.
stylist
.
match_same_not_common_style_affecting_attributes_rules
(
element
candidate
)
}
#
[
inline
]
fn
match_same_sibling_affecting_rules
<
E
:
TElement
>
(
element
:
&
E
candidate
:
&
E
ctx
:
&
SharedStyleContext
)
-
>
bool
{
ctx
.
stylist
.
match_same_sibling_affecting_rules
(
element
candidate
)
}
static
STYLE_SHARING_CANDIDATE_CACHE_SIZE
:
usize
=
8
;
impl
StyleSharingCandidateCache
{
pub
fn
new
(
)
-
>
Self
{
StyleSharingCandidateCache
{
cache
:
LRUCache
:
:
new
(
STYLE_SHARING_CANDIDATE_CACHE_SIZE
)
}
}
fn
iter_mut
(
&
mut
self
)
-
>
IterMut
<
(
StyleSharingCandidate
(
)
)
>
{
self
.
cache
.
iter_mut
(
)
}
pub
fn
insert_if_possible
<
E
:
TElement
>
(
&
mut
self
element
:
&
E
style
:
&
Arc
<
ComputedValues
>
relations
:
StyleRelations
)
{
use
traversal
:
:
relations_are_shareable
;
let
parent
=
match
element
.
parent_element
(
)
{
Some
(
element
)
=
>
element
None
=
>
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
no
parent
element
"
)
;
return
;
}
}
;
if
!
relations_are_shareable
(
&
relations
)
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
{
:
?
}
"
relations
)
;
return
;
}
let
box_style
=
style
.
get_box
(
)
;
if
box_style
.
transition_property_count
(
)
>
0
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
transitions
"
)
;
return
;
}
if
box_style
.
animation_name_count
(
)
>
0
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
animations
"
)
;
return
;
}
debug
!
(
"
Inserting
into
cache
:
{
:
?
}
with
parent
{
:
?
}
"
element
.
as_node
(
)
.
to_unsafe
(
)
parent
.
as_node
(
)
.
to_unsafe
(
)
)
;
self
.
cache
.
insert
(
StyleSharingCandidate
{
node
:
element
.
as_node
(
)
.
to_unsafe
(
)
common_style_affecting_attributes
:
None
class_attributes
:
None
}
(
)
)
;
}
pub
fn
touch
(
&
mut
self
index
:
usize
)
{
self
.
cache
.
touch
(
index
)
;
}
pub
fn
clear
(
&
mut
self
)
{
self
.
cache
.
evict_all
(
)
}
}
pub
enum
StyleSharingResult
<
ConcreteRestyleDamage
:
TRestyleDamage
>
{
CannotShare
StyleWasShared
(
usize
ConcreteRestyleDamage
)
}
struct
CascadeBooleans
{
shareable
:
bool
animate
:
bool
}
trait
PrivateMatchMethods
:
TElement
{
fn
cascade_node_pseudo_element
<
'
a
Ctx
>
(
&
self
context
:
&
Ctx
parent_style
:
Option
<
&
Arc
<
ComputedValues
>
>
old_style
:
Option
<
&
Arc
<
ComputedValues
>
>
applicable_declarations
:
&
mut
Vec
<
ApplicableDeclarationBlock
>
booleans
:
CascadeBooleans
)
-
>
(
Arc
<
ComputedValues
>
StrongRuleNode
)
where
Ctx
:
StyleContext
<
'
a
>
{
let
shared_context
=
context
.
shared_context
(
)
;
let
rule_node
=
shared_context
.
stylist
.
rule_tree
.
insert_ordered_rules
(
applicable_declarations
.
drain
(
.
.
)
.
map
(
|
d
|
(
d
.
source
d
.
importance
)
)
)
;
let
mut
cascade_info
=
CascadeInfo
:
:
new
(
)
;
let
mut
cascade_flags
=
CascadeFlags
:
:
empty
(
)
;
if
booleans
.
shareable
{
cascade_flags
.
insert
(
SHAREABLE
)
}
let
this_style
=
match
parent_style
{
Some
(
ref
parent_style
)
=
>
{
cascade
(
shared_context
.
viewport_size
&
rule_node
Some
(
&
*
*
*
parent_style
)
Some
(
&
mut
cascade_info
)
shared_context
.
error_reporter
.
clone
(
)
cascade_flags
)
}
None
=
>
{
cascade
(
shared_context
.
viewport_size
&
rule_node
None
Some
(
&
mut
cascade_info
)
shared_context
.
error_reporter
.
clone
(
)
cascade_flags
)
}
}
;
cascade_info
.
finish
(
&
self
.
as_node
(
)
)
;
let
mut
this_style
=
Arc
:
:
new
(
this_style
)
;
if
booleans
.
animate
{
let
new_animations_sender
=
&
context
.
local_context
(
)
.
new_animations_sender
;
let
this_opaque
=
self
.
as_node
(
)
.
opaque
(
)
;
animation
:
:
maybe_start_animations
(
&
shared_context
new_animations_sender
this_opaque
&
this_style
)
;
if
let
Some
(
ref
style
)
=
old_style
{
animation
:
:
start_transitions_if_applicable
(
new_animations_sender
this_opaque
self
.
as_node
(
)
.
to_unsafe
(
)
&
*
*
style
&
mut
this_style
&
shared_context
.
timer
)
;
}
}
(
this_style
rule_node
)
}
fn
update_animations_for_cascade
(
&
self
context
:
&
SharedStyleContext
style
:
&
mut
Arc
<
ComputedValues
>
)
-
>
bool
{
let
this_opaque
=
self
.
as_node
(
)
.
opaque
(
)
;
let
had_animations_to_expire
=
animation
:
:
complete_expired_transitions
(
this_opaque
style
context
)
;
let
had_running_animations
=
context
.
running_animations
.
read
(
)
.
get
(
&
this_opaque
)
.
is_some
(
)
;
if
had_running_animations
{
let
mut
all_running_animations
=
context
.
running_animations
.
write
(
)
;
for
mut
running_animation
in
all_running_animations
.
get_mut
(
&
this_opaque
)
.
unwrap
(
)
{
if
!
running_animation
.
is_expired
(
)
{
animation
:
:
update_style_for_animation
(
context
running_animation
style
)
;
running_animation
.
mark_as_expired
(
)
;
}
}
}
had_animations_to_expire
|
|
had_running_animations
}
fn
share_style_with_candidate_if_possible
(
&
self
shared_context
:
&
SharedStyleContext
candidate
:
&
mut
StyleSharingCandidate
)
-
>
Result
<
(
Arc
<
ComputedValues
>
StrongRuleNode
)
CacheMiss
>
{
let
candidate_element
=
unsafe
{
Self
:
:
ConcreteNode
:
:
from_unsafe
(
&
candidate
.
node
)
.
as_element
(
)
.
unwrap
(
)
}
;
element_matches_candidate
(
self
candidate
&
candidate_element
shared_context
)
}
}
impl
<
E
:
TElement
>
PrivateMatchMethods
for
E
{
}
pub
trait
MatchMethods
:
TElement
{
fn
match_element
(
&
self
stylist
:
&
Stylist
parent_bf
:
Option
<
&
BloomFilter
>
mut
applicable_declarations
:
&
mut
ApplicableDeclarations
)
-
>
StyleRelations
{
use
traversal
:
:
relations_are_shareable
;
let
style_attribute
=
self
.
style_attribute
(
)
;
let
mut
relations
=
stylist
.
push_applicable_declarations
(
self
parent_bf
style_attribute
None
&
mut
applicable_declarations
.
normal
MatchingReason
:
:
ForStyling
)
;
applicable_declarations
.
normal_shareable
=
relations_are_shareable
(
&
relations
)
;
TheSelectorImpl
:
:
each_eagerly_cascaded_pseudo_element
(
|
pseudo
|
{
stylist
.
push_applicable_declarations
(
self
parent_bf
None
Some
(
&
pseudo
.
clone
(
)
)
applicable_declarations
.
per_pseudo
.
entry
(
pseudo
)
.
or_insert
(
vec
!
[
]
)
MatchingReason
:
:
ForStyling
)
;
}
)
;
let
has_pseudos
=
applicable_declarations
.
per_pseudo
.
values
(
)
.
any
(
|
v
|
!
v
.
is_empty
(
)
)
;
if
has_pseudos
{
relations
|
=
AFFECTED_BY_PSEUDO_ELEMENTS
;
}
relations
}
unsafe
fn
share_style_if_possible
(
&
self
style_sharing_candidate_cache
:
&
mut
StyleSharingCandidateCache
shared_context
:
&
SharedStyleContext
data
:
&
mut
AtomicRefMut
<
ElementData
>
)
-
>
StyleSharingResult
<
Self
:
:
ConcreteRestyleDamage
>
{
if
opts
:
:
get
(
)
.
disable_share_style_cache
{
return
StyleSharingResult
:
:
CannotShare
}
if
self
.
style_attribute
(
)
.
is_some
(
)
{
return
StyleSharingResult
:
:
CannotShare
}
if
self
.
has_attr
(
&
ns
!
(
)
&
local_name
!
(
"
id
"
)
)
{
return
StyleSharingResult
:
:
CannotShare
}
let
mut
should_clear_cache
=
false
;
for
(
i
&
mut
(
ref
mut
candidate
(
)
)
)
in
style_sharing_candidate_cache
.
iter_mut
(
)
.
enumerate
(
)
{
let
sharing_result
=
self
.
share_style_with_candidate_if_possible
(
shared_context
candidate
)
;
match
sharing_result
{
Ok
(
(
shared_style
rule_node
)
)
=
>
{
let
damage
=
match
self
.
existing_style_for_restyle_damage
(
data
.
previous_styles
(
)
.
map
(
|
x
|
&
x
.
primary
)
None
)
{
Some
(
ref
source
)
=
>
{
Self
:
:
ConcreteRestyleDamage
:
:
compute
(
source
&
shared_style
)
}
None
=
>
{
Self
:
:
ConcreteRestyleDamage
:
:
rebuild_and_reflow
(
)
}
}
;
data
.
finish_styling
(
ElementStyles
:
:
new
(
shared_style
rule_node
)
)
;
return
StyleSharingResult
:
:
StyleWasShared
(
i
damage
)
}
Err
(
miss
)
=
>
{
debug
!
(
"
Cache
miss
:
{
:
?
}
"
miss
)
;
match
miss
{
CacheMiss
:
:
Parent
=
>
{
should_clear_cache
=
true
;
break
;
}
CacheMiss
:
:
CommonStyleAffectingAttributes
|
CacheMiss
:
:
PresHints
|
CacheMiss
:
:
SiblingRules
|
CacheMiss
:
:
NonCommonAttrRules
=
>
break
_
=
>
{
}
}
}
}
}
if
should_clear_cache
{
style_sharing_candidate_cache
.
clear
(
)
;
}
StyleSharingResult
:
:
CannotShare
}
fn
insert_into_bloom_filter
(
&
self
bf
:
&
mut
BloomFilter
)
{
bf
.
insert
(
&
*
self
.
get_local_name
(
)
)
;
bf
.
insert
(
&
*
self
.
get_namespace
(
)
)
;
self
.
get_id
(
)
.
map
(
|
id
|
bf
.
insert
(
&
id
)
)
;
self
.
each_class
(
|
class
|
bf
.
insert
(
class
)
)
;
}
fn
remove_from_bloom_filter
(
&
self
bf
:
&
mut
BloomFilter
)
{
bf
.
remove
(
&
*
self
.
get_local_name
(
)
)
;
bf
.
remove
(
&
*
self
.
get_namespace
(
)
)
;
self
.
get_id
(
)
.
map
(
|
id
|
bf
.
remove
(
&
id
)
)
;
self
.
each_class
(
|
class
|
bf
.
remove
(
class
)
)
;
}
fn
compute_restyle_damage
(
&
self
old_style
:
Option
<
&
Arc
<
ComputedValues
>
>
new_style
:
&
Arc
<
ComputedValues
>
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Self
:
:
ConcreteRestyleDamage
{
match
self
.
existing_style_for_restyle_damage
(
old_style
pseudo
)
{
Some
(
ref
source
)
=
>
{
Self
:
:
ConcreteRestyleDamage
:
:
compute
(
source
new_style
)
}
None
=
>
{
debug_assert
!
(
pseudo
.
is_none
(
)
|
|
new_style
.
get_box
(
)
.
clone_display
(
)
!
=
display
:
:
T
:
:
none
)
;
Self
:
:
ConcreteRestyleDamage
:
:
rebuild_and_reflow
(
)
}
}
}
unsafe
fn
cascade_node
<
'
a
Ctx
>
(
&
self
context
:
&
Ctx
mut
data
:
AtomicRefMut
<
ElementData
>
parent
:
Option
<
Self
>
mut
applicable_declarations
:
ApplicableDeclarations
)
where
Ctx
:
StyleContext
<
'
a
>
{
let
parent_data
=
parent
.
as_ref
(
)
.
map
(
|
x
|
x
.
borrow_data
(
)
.
unwrap
(
)
)
;
let
parent_style
=
parent_data
.
as_ref
(
)
.
map
(
|
x
|
&
x
.
current_styles
(
)
.
primary
)
;
let
mut
new_styles
;
let
damage
=
{
let
shareable
=
applicable_declarations
.
normal_shareable
;
let
(
old_primary
old_pseudos
)
=
match
data
.
previous_styles_mut
(
)
{
None
=
>
(
None
None
)
Some
(
previous
)
=
>
{
self
.
update_animations_for_cascade
(
context
.
shared_context
(
)
&
mut
previous
.
primary
)
;
(
Some
(
&
previous
.
primary
)
Some
(
&
mut
previous
.
pseudos
)
)
}
}
;
let
(
new_style
rule_node
)
=
self
.
cascade_node_pseudo_element
(
context
parent_style
old_primary
&
mut
applicable_declarations
.
normal
CascadeBooleans
{
shareable
:
shareable
animate
:
true
}
)
;
new_styles
=
ElementStyles
:
:
new
(
new_style
rule_node
)
;
let
damage
=
self
.
compute_damage_and_cascade_pseudos
(
old_primary
old_pseudos
&
new_styles
.
primary
&
mut
new_styles
.
pseudos
context
&
mut
applicable_declarations
)
;
self
.
as_node
(
)
.
set_can_be_fragmented
(
parent
.
map_or
(
false
|
p
|
{
p
.
as_node
(
)
.
can_be_fragmented
(
)
|
|
parent_style
.
unwrap
(
)
.
is_multicol
(
)
}
)
)
;
damage
}
;
data
.
finish_styling
(
new_styles
)
;
mem
:
:
drop
(
data
)
;
self
.
set_restyle_damage
(
damage
)
;
}
fn
compute_damage_and_cascade_pseudos
<
'
a
Ctx
>
(
&
self
old_primary
:
Option
<
&
Arc
<
ComputedValues
>
>
mut
old_pseudos
:
Option
<
&
mut
PseudoStyles
>
new_primary
:
&
Arc
<
ComputedValues
>
new_pseudos
:
&
mut
PseudoStyles
context
:
&
Ctx
applicable_declarations
:
&
mut
ApplicableDeclarations
)
-
>
Self
:
:
ConcreteRestyleDamage
where
Ctx
:
StyleContext
<
'
a
>
{
let
this_display
=
new_primary
.
get_box
(
)
.
clone_display
(
)
;
if
this_display
=
=
display
:
:
T
:
:
none
{
let
old_display
=
old_primary
.
map
(
|
old
|
{
old
.
get_box
(
)
.
clone_display
(
)
}
)
;
let
damage
=
match
old_display
{
Some
(
display
)
if
display
=
=
this_display
=
>
{
Self
:
:
ConcreteRestyleDamage
:
:
empty
(
)
}
_
=
>
Self
:
:
ConcreteRestyleDamage
:
:
rebuild_and_reflow
(
)
}
;
debug
!
(
"
Short
-
circuiting
traversal
:
{
:
?
}
{
:
?
}
{
:
?
}
"
this_display
old_display
damage
)
;
return
damage
}
let
mut
damage
=
self
.
compute_restyle_damage
(
old_primary
new_primary
None
)
;
if
new_primary
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
T
:
:
none
{
return
damage
;
}
let
rebuild_and_reflow
=
Self
:
:
ConcreteRestyleDamage
:
:
rebuild_and_reflow
(
)
;
debug_assert
!
(
new_pseudos
.
is_empty
(
)
)
;
<
Self
as
MatchAttr
>
:
:
Impl
:
:
each_eagerly_cascaded_pseudo_element
(
|
pseudo
|
{
let
mut
applicable_declarations_for_this_pseudo
=
applicable_declarations
.
per_pseudo
.
get_mut
(
&
pseudo
)
.
unwrap
(
)
;
let
has_declarations
=
!
applicable_declarations_for_this_pseudo
.
is_empty
(
)
;
let
mut
maybe_old_pseudo_style_and_rule_node
=
old_pseudos
.
as_mut
(
)
.
and_then
(
|
x
|
x
.
remove
(
&
pseudo
)
)
;
if
has_declarations
{
let
animate
=
<
Self
as
MatchAttr
>
:
:
Impl
:
:
pseudo_is_before_or_after
(
&
pseudo
)
;
if
animate
{
if
let
Some
(
(
ref
mut
old_pseudo_style
_
)
)
=
maybe_old_pseudo_style_and_rule_node
{
self
.
update_animations_for_cascade
(
context
.
shared_context
(
)
old_pseudo_style
)
;
}
}
let
(
new_pseudo_style
new_rule_node
)
=
self
.
cascade_node_pseudo_element
(
context
Some
(
new_primary
)
maybe_old_pseudo_style_and_rule_node
.
as_ref
(
)
.
map
(
|
s
|
&
s
.
0
)
&
mut
applicable_declarations_for_this_pseudo
CascadeBooleans
{
shareable
:
false
animate
:
animate
}
)
;
if
damage
!
=
rebuild_and_reflow
{
damage
=
damage
|
match
maybe_old_pseudo_style_and_rule_node
{
None
=
>
rebuild_and_reflow
Some
(
(
ref
old
_
)
)
=
>
self
.
compute_restyle_damage
(
Some
(
old
)
&
new_pseudo_style
Some
(
&
pseudo
)
)
}
;
}
let
existing
=
new_pseudos
.
insert
(
pseudo
(
new_pseudo_style
new_rule_node
)
)
;
debug_assert
!
(
existing
.
is_none
(
)
)
;
}
else
{
if
maybe_old_pseudo_style_and_rule_node
.
is_some
(
)
{
damage
=
rebuild_and_reflow
;
}
}
}
)
;
damage
}
}
impl
<
E
:
TElement
>
MatchMethods
for
E
{
}
