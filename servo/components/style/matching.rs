#
!
[
allow
(
unsafe_code
)
]
#
!
[
deny
(
missing_docs
)
]
use
crate
:
:
computed_value_flags
:
:
ComputedValueFlags
;
use
crate
:
:
context
:
:
{
CascadeInputs
ElementCascadeInputs
QuirksMode
SelectorFlagsMap
}
;
use
crate
:
:
context
:
:
{
SharedStyleContext
StyleContext
}
;
use
crate
:
:
data
:
:
ElementData
;
use
crate
:
:
dom
:
:
TElement
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
crate
:
:
dom
:
:
TNode
;
use
crate
:
:
invalidation
:
:
element
:
:
restyle_hints
:
:
RestyleHint
;
use
crate
:
:
properties
:
:
longhands
:
:
display
:
:
computed_value
:
:
T
as
Display
;
use
crate
:
:
properties
:
:
ComputedValues
;
use
crate
:
:
properties
:
:
PropertyDeclarationBlock
;
use
crate
:
:
rule_tree
:
:
{
CascadeLevel
StrongRuleNode
}
;
use
crate
:
:
selector_parser
:
:
{
PseudoElement
RestyleDamage
}
;
use
crate
:
:
shared_lock
:
:
Locked
;
use
crate
:
:
style_resolver
:
:
ResolvedElementStyles
;
use
crate
:
:
style_resolver
:
:
{
PseudoElementResolution
StyleResolverForElement
}
;
use
crate
:
:
stylist
:
:
RuleInclusion
;
use
crate
:
:
traversal_flags
:
:
TraversalFlags
;
use
selectors
:
:
matching
:
:
ElementSelectorFlags
;
use
servo_arc
:
:
{
Arc
ArcBorrow
}
;
#
[
derive
(
Debug
)
]
pub
struct
StyleDifference
{
pub
damage
:
RestyleDamage
pub
change
:
StyleChange
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
StyleChange
{
Unchanged
Changed
{
reset_only
:
bool
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Ord
PartialEq
PartialOrd
)
]
pub
enum
ChildCascadeRequirement
{
CanSkipCascade
=
0
MustCascadeChildrenIfInheritResetStyle
=
1
MustCascadeChildren
=
2
MustCascadeDescendants
=
3
}
impl
ChildCascadeRequirement
{
pub
fn
can_skip_cascade
(
&
self
)
-
>
bool
{
matches
!
(
*
self
ChildCascadeRequirement
:
:
CanSkipCascade
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
enum
CascadeVisitedMode
{
Unvisited
Visited
}
trait
PrivateMatchMethods
:
TElement
{
fn
replace_single_rule_node
(
context
:
&
mut
StyleContext
<
Self
>
level
:
CascadeLevel
pdb
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
path
:
&
mut
StrongRuleNode
)
-
>
bool
{
let
stylist
=
&
context
.
shared
.
stylist
;
let
guards
=
&
context
.
shared
.
guards
;
let
mut
important_rules_changed
=
false
;
let
new_node
=
stylist
.
rule_tree
(
)
.
update_rule_at_level
(
level
pdb
path
guards
&
mut
important_rules_changed
)
;
if
let
Some
(
n
)
=
new_node
{
*
path
=
n
;
}
important_rules_changed
}
fn
replace_rules_internal
(
&
self
replacements
:
RestyleHint
context
:
&
mut
StyleContext
<
Self
>
cascade_visited
:
CascadeVisitedMode
cascade_inputs
:
&
mut
ElementCascadeInputs
)
-
>
bool
{
debug_assert
!
(
replacements
.
intersects
(
RestyleHint
:
:
replacements
(
)
)
&
&
(
replacements
&
!
RestyleHint
:
:
replacements
(
)
)
.
is_empty
(
)
)
;
let
primary_rules
=
match
cascade_visited
{
CascadeVisitedMode
:
:
Unvisited
=
>
cascade_inputs
.
primary
.
rules
.
as_mut
(
)
CascadeVisitedMode
:
:
Visited
=
>
cascade_inputs
.
primary
.
visited_rules
.
as_mut
(
)
}
;
let
primary_rules
=
match
primary_rules
{
Some
(
r
)
=
>
r
None
=
>
return
false
}
;
if
!
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
{
let
mut
result
=
false
;
if
replacements
.
contains
(
RestyleHint
:
:
RESTYLE_STYLE_ATTRIBUTE
)
{
let
style_attribute
=
self
.
style_attribute
(
)
;
result
|
=
Self
:
:
replace_single_rule_node
(
context
CascadeLevel
:
:
same_tree_author_normal
(
)
style_attribute
primary_rules
)
;
result
|
=
Self
:
:
replace_single_rule_node
(
context
CascadeLevel
:
:
same_tree_author_important
(
)
style_attribute
primary_rules
)
;
self
.
unset_dirty_style_attribute
(
)
;
}
return
result
;
}
if
replacements
.
intersects
(
RestyleHint
:
:
for_animations
(
)
)
{
debug_assert
!
(
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
)
;
if
replacements
.
contains
(
RestyleHint
:
:
RESTYLE_SMIL
)
{
Self
:
:
replace_single_rule_node
(
context
CascadeLevel
:
:
SMILOverride
self
.
smil_override
(
)
primary_rules
)
;
}
if
replacements
.
contains
(
RestyleHint
:
:
RESTYLE_CSS_TRANSITIONS
)
{
Self
:
:
replace_single_rule_node
(
context
CascadeLevel
:
:
Transitions
self
.
transition_rule
(
&
context
.
shared
)
.
as_ref
(
)
.
map
(
|
a
|
a
.
borrow_arc
(
)
)
primary_rules
)
;
}
if
replacements
.
contains
(
RestyleHint
:
:
RESTYLE_CSS_ANIMATIONS
)
{
Self
:
:
replace_single_rule_node
(
context
CascadeLevel
:
:
Animations
self
.
animation_rule
(
&
context
.
shared
)
.
as_ref
(
)
.
map
(
|
a
|
a
.
borrow_arc
(
)
)
primary_rules
)
;
}
}
false
}
fn
after_change_style
(
&
self
context
:
&
mut
StyleContext
<
Self
>
primary_style
:
&
Arc
<
ComputedValues
>
)
-
>
Option
<
Arc
<
ComputedValues
>
>
{
let
rule_node
=
primary_style
.
rules
(
)
;
let
without_transition_rules
=
context
.
shared
.
stylist
.
rule_tree
(
)
.
remove_transition_rule_if_applicable
(
rule_node
)
;
if
without_transition_rules
=
=
*
rule_node
{
return
None
;
}
let
inputs
=
CascadeInputs
{
rules
:
Some
(
without_transition_rules
)
visited_rules
:
primary_style
.
visited_rules
(
)
.
cloned
(
)
}
;
let
style
=
StyleResolverForElement
:
:
new
(
*
self
context
RuleInclusion
:
:
All
PseudoElementResolution
:
:
IfApplicable
)
.
cascade_style_and_visited_with_default_parents
(
inputs
)
;
Some
(
style
.
0
)
}
fn
needs_animations_update
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_style
:
Option
<
&
ComputedValues
>
new_style
:
&
ComputedValues
)
-
>
bool
{
let
new_box_style
=
new_style
.
get_box
(
)
;
let
new_style_specifies_animations
=
new_box_style
.
specifies_animations
(
)
;
let
has_animations
=
self
.
has_css_animations
(
&
context
.
shared
)
;
if
!
new_style_specifies_animations
&
&
!
has_animations
{
return
false
;
}
let
old_style
=
match
old_style
{
Some
(
old
)
=
>
old
None
=
>
{
return
new_style_specifies_animations
|
|
new_style
.
is_pseudo_style
(
)
;
}
}
;
let
old_box_style
=
old_style
.
get_box
(
)
;
let
keyframes_could_have_changed
=
context
.
shared
.
traversal_flags
.
contains
(
TraversalFlags
:
:
ForCSSRuleChanges
)
;
if
keyframes_could_have_changed
{
return
true
;
}
if
!
old_box_style
.
animations_equals
(
new_box_style
)
{
return
true
;
}
let
old_display
=
old_box_style
.
clone_display
(
)
;
let
new_display
=
new_box_style
.
clone_display
(
)
;
if
old_display
=
=
Display
:
:
None
&
&
new_display
!
=
Display
:
:
None
{
return
new_style_specifies_animations
;
}
if
old_display
!
=
Display
:
:
None
&
&
new_display
=
=
Display
:
:
None
{
return
has_animations
;
}
if
new_style
.
writing_mode
!
=
old_style
.
writing_mode
{
return
has_animations
;
}
false
}
fn
might_need_transitions_update
(
&
self
context
:
&
StyleContext
<
Self
>
old_style
:
Option
<
&
ComputedValues
>
new_style
:
&
ComputedValues
)
-
>
bool
{
let
old_style
=
match
old_style
{
Some
(
v
)
=
>
v
None
=
>
return
false
}
;
let
new_box_style
=
new_style
.
get_box
(
)
;
if
!
self
.
has_css_transitions
(
context
.
shared
)
&
&
!
new_box_style
.
specifies_transitions
(
)
{
return
false
;
}
if
new_box_style
.
clone_display
(
)
.
is_none
(
)
|
|
old_style
.
clone_display
(
)
.
is_none
(
)
{
return
false
;
}
return
true
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
handle_display_change_for_smil_if_needed
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
Option
<
&
ComputedValues
>
new_values
:
&
ComputedValues
restyle_hints
:
RestyleHint
)
{
use
crate
:
:
context
:
:
PostAnimationTasks
;
if
!
restyle_hints
.
intersects
(
RestyleHint
:
:
RESTYLE_SMIL
)
{
return
;
}
if
new_values
.
is_display_property_changed_from_none
(
old_values
)
{
let
task
=
crate
:
:
context
:
:
SequentialTask
:
:
process_post_animation
(
*
self
PostAnimationTasks
:
:
DISPLAY_CHANGED_FROM_NONE_FOR_SMIL
)
;
context
.
thread_local
.
tasks
.
push
(
task
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
process_animations
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
&
mut
Option
<
Arc
<
ComputedValues
>
>
new_styles
:
&
mut
ResolvedElementStyles
restyle_hint
:
RestyleHint
important_rules_changed
:
bool
)
{
use
crate
:
:
context
:
:
UpdateAnimationsTasks
;
let
new_values
=
new_styles
.
primary_style_mut
(
)
;
if
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
{
self
.
handle_display_change_for_smil_if_needed
(
context
old_values
.
as_ref
(
)
.
map
(
|
v
|
&
*
*
v
)
new_values
restyle_hint
)
;
return
;
}
let
mut
tasks
=
UpdateAnimationsTasks
:
:
empty
(
)
;
if
self
.
needs_animations_update
(
context
old_values
.
as_ref
(
)
.
map
(
|
s
|
&
*
*
s
)
new_values
)
{
tasks
.
insert
(
UpdateAnimationsTasks
:
:
CSS_ANIMATIONS
)
;
}
let
before_change_style
=
if
self
.
might_need_transitions_update
(
context
old_values
.
as_ref
(
)
.
map
(
|
s
|
&
*
*
s
)
new_values
)
{
let
after_change_style
=
if
self
.
has_css_transitions
(
context
.
shared
)
{
self
.
after_change_style
(
context
new_values
)
}
else
{
None
}
;
let
needs_transitions_update
=
{
let
after_change_style_ref
=
after_change_style
.
as_ref
(
)
.
unwrap_or
(
&
new_values
)
;
self
.
needs_transitions_update
(
old_values
.
as_ref
(
)
.
unwrap
(
)
after_change_style_ref
)
}
;
if
needs_transitions_update
{
if
let
Some
(
values_without_transitions
)
=
after_change_style
{
*
new_values
=
values_without_transitions
;
}
tasks
.
insert
(
UpdateAnimationsTasks
:
:
CSS_TRANSITIONS
)
;
old_values
.
clone
(
)
}
else
{
None
}
}
else
{
None
}
;
if
self
.
has_animations
(
)
{
tasks
.
insert
(
UpdateAnimationsTasks
:
:
EFFECT_PROPERTIES
)
;
if
important_rules_changed
{
tasks
.
insert
(
UpdateAnimationsTasks
:
:
CASCADE_RESULTS
)
;
}
if
new_values
.
is_display_property_changed_from_none
(
old_values
.
as_ref
(
)
.
map
(
|
s
|
&
*
*
s
)
)
{
tasks
.
insert
(
UpdateAnimationsTasks
:
:
DISPLAY_CHANGED_FROM_NONE
)
;
}
}
if
!
tasks
.
is_empty
(
)
{
let
task
=
crate
:
:
context
:
:
SequentialTask
:
:
update_animations
(
*
self
before_change_style
tasks
)
;
context
.
thread_local
.
tasks
.
push
(
task
)
;
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
process_animations
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
&
mut
Option
<
Arc
<
ComputedValues
>
>
new_resolved_styles
:
&
mut
ResolvedElementStyles
_restyle_hint
:
RestyleHint
_important_rules_changed
:
bool
)
{
if
!
self
.
process_animations_for_style
(
context
old_values
new_resolved_styles
.
primary_style_mut
(
)
)
{
return
;
}
let
mut
rule_node
=
new_resolved_styles
.
primary_style
(
)
.
rules
(
)
.
clone
(
)
;
Self
:
:
replace_single_rule_node
(
context
CascadeLevel
:
:
Transitions
self
.
transition_rule
(
&
context
.
shared
)
.
as_ref
(
)
.
map
(
|
a
|
a
.
borrow_arc
(
)
)
&
mut
rule_node
)
;
Self
:
:
replace_single_rule_node
(
context
CascadeLevel
:
:
Animations
self
.
animation_rule
(
&
context
.
shared
)
.
as_ref
(
)
.
map
(
|
a
|
a
.
borrow_arc
(
)
)
&
mut
rule_node
)
;
if
rule_node
=
=
*
new_resolved_styles
.
primary_style
(
)
.
rules
(
)
{
return
;
}
let
inputs
=
CascadeInputs
{
rules
:
Some
(
rule_node
)
visited_rules
:
new_resolved_styles
.
primary_style
(
)
.
visited_rules
(
)
.
cloned
(
)
}
;
let
style
=
StyleResolverForElement
:
:
new
(
*
self
context
RuleInclusion
:
:
All
PseudoElementResolution
:
:
IfApplicable
)
.
cascade_style_and_visited_with_default_parents
(
inputs
)
;
new_resolved_styles
.
primary
.
style
=
style
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
process_animations_for_style
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
&
mut
Option
<
Arc
<
ComputedValues
>
>
new_values
:
&
mut
Arc
<
ComputedValues
>
)
-
>
bool
{
use
crate
:
:
animation
:
:
{
AnimationSetKey
AnimationState
}
;
let
needs_animations_update
=
self
.
needs_animations_update
(
context
old_values
.
as_ref
(
)
.
map
(
|
s
|
&
*
*
s
)
new_values
)
;
let
might_need_transitions_update
=
self
.
might_need_transitions_update
(
context
old_values
.
as_ref
(
)
.
map
(
|
s
|
&
*
*
s
)
new_values
)
;
let
mut
after_change_style
=
None
;
if
might_need_transitions_update
{
after_change_style
=
self
.
after_change_style
(
context
new_values
)
;
}
let
key
=
AnimationSetKey
(
self
.
as_node
(
)
.
opaque
(
)
)
;
let
shared_context
=
context
.
shared
;
let
mut
animation_set
=
shared_context
.
animations
.
sets
.
write
(
)
.
remove
(
&
key
)
.
unwrap_or_default
(
)
;
if
needs_animations_update
{
let
mut
resolver
=
StyleResolverForElement
:
:
new
(
*
self
context
RuleInclusion
:
:
All
PseudoElementResolution
:
:
IfApplicable
)
;
animation_set
.
update_animations_for_new_style
:
:
<
Self
>
(
*
self
&
shared_context
&
new_values
&
mut
resolver
)
;
}
animation_set
.
update_transitions_for_new_style
(
might_need_transitions_update
&
shared_context
old_values
.
as_ref
(
)
after_change_style
.
as_ref
(
)
.
unwrap_or
(
new_values
)
)
;
animation_set
.
transitions
.
retain
(
|
transition
|
transition
.
state
!
=
AnimationState
:
:
Finished
)
;
let
changed_animations
=
animation_set
.
dirty
;
if
!
animation_set
.
is_empty
(
)
{
animation_set
.
dirty
=
false
;
shared_context
.
animations
.
sets
.
write
(
)
.
insert
(
key
animation_set
)
;
}
changed_animations
}
fn
accumulate_damage_for
(
&
self
shared_context
:
&
SharedStyleContext
damage
:
&
mut
RestyleDamage
old_values
:
&
ComputedValues
new_values
:
&
ComputedValues
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
ChildCascadeRequirement
{
debug
!
(
"
accumulate_damage_for
:
{
:
?
}
"
self
)
;
debug_assert
!
(
!
shared_context
.
traversal_flags
.
contains
(
TraversalFlags
:
:
FinalAnimationTraversal
)
)
;
let
difference
=
self
.
compute_style_difference
(
old_values
new_values
pseudo
)
;
*
damage
|
=
difference
.
damage
;
debug
!
(
"
>
style
difference
:
{
:
?
}
"
difference
)
;
if
old_values
.
flags
.
maybe_inherited
(
)
!
=
new_values
.
flags
.
maybe_inherited
(
)
{
debug
!
(
"
>
flags
changed
:
{
:
?
}
!
=
{
:
?
}
"
old_values
.
flags
new_values
.
flags
)
;
return
ChildCascadeRequirement
:
:
MustCascadeChildren
;
}
match
difference
.
change
{
StyleChange
:
:
Unchanged
=
>
return
ChildCascadeRequirement
:
:
CanSkipCascade
StyleChange
:
:
Changed
{
reset_only
}
=
>
{
if
!
reset_only
{
return
ChildCascadeRequirement
:
:
MustCascadeChildren
;
}
}
}
let
old_display
=
old_values
.
get_box
(
)
.
clone_display
(
)
;
let
new_display
=
new_values
.
get_box
(
)
.
clone_display
(
)
;
if
old_display
!
=
new_display
{
if
old_display
=
=
Display
:
:
None
{
return
ChildCascadeRequirement
:
:
MustCascadeChildren
;
}
if
old_display
.
is_item_container
(
)
!
=
new_display
.
is_item_container
(
)
{
return
ChildCascadeRequirement
:
:
MustCascadeChildren
;
}
if
old_display
.
is_contents
(
)
|
|
new_display
.
is_contents
(
)
{
return
ChildCascadeRequirement
:
:
MustCascadeChildren
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
if
old_display
.
is_ruby_type
(
)
!
=
new_display
.
is_ruby_type
(
)
{
return
ChildCascadeRequirement
:
:
MustCascadeChildren
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
use
crate
:
:
values
:
:
specified
:
:
align
:
:
AlignFlags
;
let
old_justify_items
=
old_values
.
get_position
(
)
.
clone_justify_items
(
)
;
let
new_justify_items
=
new_values
.
get_position
(
)
.
clone_justify_items
(
)
;
let
was_legacy_justify_items
=
old_justify_items
.
computed
.
0
.
contains
(
AlignFlags
:
:
LEGACY
)
;
let
is_legacy_justify_items
=
new_justify_items
.
computed
.
0
.
contains
(
AlignFlags
:
:
LEGACY
)
;
if
is_legacy_justify_items
!
=
was_legacy_justify_items
{
return
ChildCascadeRequirement
:
:
MustCascadeChildren
;
}
if
was_legacy_justify_items
&
&
old_justify_items
.
computed
!
=
new_justify_items
.
computed
{
return
ChildCascadeRequirement
:
:
MustCascadeChildren
;
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
{
if
old_values
.
is_multicol
(
)
!
=
new_values
.
is_multicol
(
)
{
return
ChildCascadeRequirement
:
:
MustCascadeChildren
;
}
}
ChildCascadeRequirement
:
:
MustCascadeChildrenIfInheritResetStyle
}
}
impl
<
E
:
TElement
>
PrivateMatchMethods
for
E
{
}
pub
trait
MatchMethods
:
TElement
{
fn
layout_parent
(
&
self
)
-
>
Self
{
let
mut
current
=
self
.
clone
(
)
;
loop
{
current
=
match
current
.
traversal_parent
(
)
{
Some
(
el
)
=
>
el
None
=
>
return
current
}
;
let
is_display_contents
=
current
.
borrow_data
(
)
.
unwrap
(
)
.
styles
.
primary
(
)
.
is_display_contents
(
)
;
if
!
is_display_contents
{
return
current
;
}
}
}
fn
finish_restyle
(
&
self
context
:
&
mut
StyleContext
<
Self
>
data
:
&
mut
ElementData
mut
new_styles
:
ResolvedElementStyles
important_rules_changed
:
bool
)
-
>
ChildCascadeRequirement
{
use
std
:
:
cmp
;
self
.
process_animations
(
context
&
mut
data
.
styles
.
primary
&
mut
new_styles
data
.
hint
important_rules_changed
)
;
let
old_styles
=
data
.
set_styles
(
new_styles
)
;
let
new_primary_style
=
data
.
styles
.
primary
.
as_ref
(
)
.
unwrap
(
)
;
let
mut
cascade_requirement
=
ChildCascadeRequirement
:
:
CanSkipCascade
;
if
new_primary_style
.
flags
.
contains
(
ComputedValueFlags
:
:
IS_ROOT_ELEMENT_STYLE
)
{
let
device
=
context
.
shared
.
stylist
.
device
(
)
;
let
new_font_size
=
new_primary_style
.
get_font
(
)
.
clone_font_size
(
)
;
if
old_styles
.
primary
.
as_ref
(
)
.
map_or
(
true
|
s
|
s
.
get_font
(
)
.
clone_font_size
(
)
!
=
new_font_size
)
{
debug_assert
!
(
self
.
owner_doc_matches_for_testing
(
device
)
)
;
device
.
set_root_font_size
(
new_font_size
.
size
(
)
.
into
(
)
)
;
if
device
.
used_root_font_size
(
)
{
cascade_requirement
=
ChildCascadeRequirement
:
:
MustCascadeDescendants
;
}
}
}
if
context
.
shared
.
stylist
.
quirks_mode
(
)
=
=
QuirksMode
:
:
Quirks
{
if
self
.
is_html_document_body_element
(
)
{
let
device
=
context
.
shared
.
stylist
.
device
(
)
;
let
text_color
=
new_primary_style
.
get_inherited_text
(
)
.
clone_color
(
)
;
device
.
set_body_text_color
(
text_color
)
;
}
}
if
context
.
shared
.
traversal_flags
.
contains
(
TraversalFlags
:
:
FinalAnimationTraversal
)
{
return
ChildCascadeRequirement
:
:
MustCascadeChildren
;
}
let
old_primary_style
=
match
old_styles
.
primary
{
Some
(
s
)
=
>
s
None
=
>
return
ChildCascadeRequirement
:
:
MustCascadeChildren
}
;
cascade_requirement
=
cmp
:
:
max
(
cascade_requirement
self
.
accumulate_damage_for
(
context
.
shared
&
mut
data
.
damage
&
old_primary_style
new_primary_style
None
)
)
;
if
data
.
styles
.
pseudos
.
is_empty
(
)
&
&
old_styles
.
pseudos
.
is_empty
(
)
{
return
cascade_requirement
;
}
let
pseudo_styles
=
old_styles
.
pseudos
.
as_array
(
)
.
iter
(
)
.
zip
(
data
.
styles
.
pseudos
.
as_array
(
)
.
iter
(
)
)
;
for
(
i
(
old
new
)
)
in
pseudo_styles
.
enumerate
(
)
{
match
(
old
new
)
{
(
&
Some
(
ref
old
)
&
Some
(
ref
new
)
)
=
>
{
self
.
accumulate_damage_for
(
context
.
shared
&
mut
data
.
damage
old
new
Some
(
&
PseudoElement
:
:
from_eager_index
(
i
)
)
)
;
}
(
&
None
&
None
)
=
>
{
}
_
=
>
{
let
pseudo
=
PseudoElement
:
:
from_eager_index
(
i
)
;
let
new_pseudo_should_exist
=
new
.
as_ref
(
)
.
map_or
(
false
|
s
|
pseudo
.
should_exist
(
s
)
)
;
let
old_pseudo_should_exist
=
old
.
as_ref
(
)
.
map_or
(
false
|
s
|
pseudo
.
should_exist
(
s
)
)
;
if
new_pseudo_should_exist
!
=
old_pseudo_should_exist
{
data
.
damage
|
=
RestyleDamage
:
:
reconstruct
(
)
;
return
cascade_requirement
;
}
}
}
}
cascade_requirement
}
fn
apply_selector_flags
(
&
self
map
:
&
mut
SelectorFlagsMap
<
Self
>
element
:
&
Self
flags
:
ElementSelectorFlags
)
{
let
self_flags
=
flags
.
for_self
(
)
;
if
!
self_flags
.
is_empty
(
)
{
if
element
=
=
self
{
unsafe
{
element
.
set_selector_flags
(
self_flags
)
;
}
}
else
{
if
!
element
.
has_selector_flags
(
self_flags
)
{
map
.
insert_flags
(
*
element
self_flags
)
;
}
}
}
let
parent_flags
=
flags
.
for_parent
(
)
;
if
!
parent_flags
.
is_empty
(
)
{
if
let
Some
(
p
)
=
element
.
parent_element
(
)
{
if
!
p
.
has_selector_flags
(
parent_flags
)
{
map
.
insert_flags
(
p
parent_flags
)
;
}
}
}
}
fn
replace_rules
(
&
self
replacements
:
RestyleHint
context
:
&
mut
StyleContext
<
Self
>
cascade_inputs
:
&
mut
ElementCascadeInputs
)
-
>
bool
{
let
mut
result
=
false
;
result
|
=
self
.
replace_rules_internal
(
replacements
context
CascadeVisitedMode
:
:
Unvisited
cascade_inputs
)
;
result
|
=
self
.
replace_rules_internal
(
replacements
context
CascadeVisitedMode
:
:
Visited
cascade_inputs
)
;
result
}
fn
compute_style_difference
(
&
self
old_values
:
&
ComputedValues
new_values
:
&
ComputedValues
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
StyleDifference
{
debug_assert
!
(
pseudo
.
map_or
(
true
|
p
|
p
.
is_eager
(
)
)
)
;
RestyleDamage
:
:
compute_style_difference
(
old_values
new_values
)
}
}
impl
<
E
:
TElement
>
MatchMethods
for
E
{
}
