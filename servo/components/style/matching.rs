#
!
[
allow
(
unsafe_code
)
]
#
!
[
deny
(
missing_docs
)
]
use
applicable_declarations
:
:
ApplicableDeclarationList
;
use
cascade_info
:
:
CascadeInfo
;
use
context
:
:
{
CascadeInputs
SelectorFlagsMap
SharedStyleContext
StyleContext
}
;
use
data
:
:
{
ElementData
ElementStyles
RestyleData
}
;
use
dom
:
:
{
TElement
TNode
}
;
use
font_metrics
:
:
FontMetricsProvider
;
use
invalidation
:
:
element
:
:
restyle_hints
:
:
{
RESTYLE_CSS_ANIMATIONS
RESTYLE_CSS_TRANSITIONS
}
;
use
invalidation
:
:
element
:
:
restyle_hints
:
:
{
RESTYLE_SMIL
RESTYLE_STYLE_ATTRIBUTE
}
;
use
invalidation
:
:
element
:
:
restyle_hints
:
:
RestyleHint
;
use
log
:
:
LogLevel
:
:
Trace
;
use
properties
:
:
{
AnimationRules
CascadeFlags
ComputedValues
}
;
use
properties
:
:
{
IS_ROOT_ELEMENT
PROHIBIT_DISPLAY_CONTENTS
SKIP_ROOT_AND_ITEM_BASED_DISPLAY_FIXUP
}
;
use
properties
:
:
{
VISITED_DEPENDENT_ONLY
cascade
}
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
as
display
;
use
rule_tree
:
:
{
CascadeLevel
StrongRuleNode
}
;
use
selector_parser
:
:
{
PseudoElement
RestyleDamage
SelectorImpl
}
;
use
selectors
:
:
matching
:
:
{
ElementSelectorFlags
MatchingContext
MatchingMode
StyleRelations
}
;
use
selectors
:
:
matching
:
:
{
VisitedHandlingMode
AFFECTED_BY_PSEUDO_ELEMENTS
}
;
use
sharing
:
:
StyleSharingBehavior
;
use
stylearc
:
:
Arc
;
use
stylist
:
:
RuleInclusion
;
#
[
derive
(
PartialEq
Copy
Clone
Debug
)
]
enum
CascadeTarget
{
Normal
EagerPseudo
}
pub
struct
StyleDifference
{
pub
damage
:
RestyleDamage
pub
change
:
StyleChange
}
impl
StyleDifference
{
pub
fn
new
(
damage
:
RestyleDamage
change
:
StyleChange
)
-
>
Self
{
StyleDifference
{
change
:
change
damage
:
damage
}
}
}
#
[
derive
(
Copy
Clone
)
]
pub
enum
StyleChange
{
Unchanged
Changed
}
pub
enum
ChildCascadeRequirement
{
CanSkipCascade
MustCascadeChildren
MustCascadeDescendants
}
bitflags
!
{
/
/
/
Flags
that
represent
the
result
of
replace_rules
.
pub
flags
RulesChanged
:
u8
{
/
/
/
Normal
rules
are
changed
.
const
NORMAL_RULES_CHANGED
=
0x01
/
/
/
Important
rules
are
changed
.
const
IMPORTANT_RULES_CHANGED
=
0x02
}
}
impl
RulesChanged
{
#
[
inline
]
pub
fn
normal_rules_changed
(
&
self
)
-
>
bool
{
self
.
contains
(
NORMAL_RULES_CHANGED
)
}
#
[
inline
]
pub
fn
important_rules_changed
(
&
self
)
-
>
bool
{
self
.
contains
(
IMPORTANT_RULES_CHANGED
)
}
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
Debug
)
]
pub
enum
CascadeVisitedMode
{
Unvisited
Visited
}
impl
CascadeVisitedMode
{
fn
has_rules
(
&
self
inputs
:
&
CascadeInputs
)
-
>
bool
{
match
*
self
{
CascadeVisitedMode
:
:
Unvisited
=
>
inputs
.
has_rules
(
)
CascadeVisitedMode
:
:
Visited
=
>
inputs
.
has_visited_rules
(
)
}
}
fn
rules
<
'
a
>
(
&
self
inputs
:
&
'
a
CascadeInputs
)
-
>
&
'
a
StrongRuleNode
{
match
*
self
{
CascadeVisitedMode
:
:
Unvisited
=
>
inputs
.
rules
(
)
CascadeVisitedMode
:
:
Visited
=
>
match
inputs
.
get_visited_rules
(
)
{
Some
(
rules
)
=
>
rules
None
=
>
inputs
.
rules
(
)
}
}
}
fn
get_rules_mut
<
'
a
>
(
&
self
inputs
:
&
'
a
mut
CascadeInputs
)
-
>
Option
<
&
'
a
mut
StrongRuleNode
>
{
match
*
self
{
CascadeVisitedMode
:
:
Unvisited
=
>
inputs
.
get_rules_mut
(
)
CascadeVisitedMode
:
:
Visited
=
>
inputs
.
get_visited_rules_mut
(
)
}
}
pub
fn
values
<
'
a
>
(
&
self
values
:
&
'
a
Arc
<
ComputedValues
>
)
-
>
&
'
a
Arc
<
ComputedValues
>
{
if
*
self
=
=
CascadeVisitedMode
:
:
Visited
&
&
values
.
get_visited_style
(
)
.
is_some
(
)
{
return
values
.
visited_style
(
)
;
}
values
}
fn
set_primary_values
(
&
self
styles
:
&
mut
ElementStyles
inputs
:
&
mut
CascadeInputs
values
:
Arc
<
ComputedValues
>
)
{
match
*
self
{
CascadeVisitedMode
:
:
Unvisited
=
>
styles
.
primary
=
Some
(
values
)
CascadeVisitedMode
:
:
Visited
=
>
inputs
.
set_visited_values
(
values
)
}
}
fn
set_pseudo_values
(
&
self
styles
:
&
mut
ElementStyles
inputs
:
&
mut
CascadeInputs
pseudo
:
&
PseudoElement
values
:
Arc
<
ComputedValues
>
)
{
match
*
self
{
CascadeVisitedMode
:
:
Unvisited
=
>
styles
.
pseudos
.
set
(
pseudo
values
)
CascadeVisitedMode
:
:
Visited
=
>
inputs
.
set_visited_values
(
values
)
}
}
fn
take_primary_values
(
&
self
styles
:
&
mut
ElementStyles
inputs
:
&
mut
CascadeInputs
)
-
>
Option
<
Arc
<
ComputedValues
>
>
{
match
*
self
{
CascadeVisitedMode
:
:
Unvisited
=
>
styles
.
primary
.
take
(
)
CascadeVisitedMode
:
:
Visited
=
>
inputs
.
take_visited_values
(
)
}
}
fn
take_pseudo_values
(
&
self
styles
:
&
mut
ElementStyles
inputs
:
&
mut
CascadeInputs
pseudo
:
&
PseudoElement
)
-
>
Option
<
Arc
<
ComputedValues
>
>
{
match
*
self
{
CascadeVisitedMode
:
:
Unvisited
=
>
styles
.
pseudos
.
take
(
pseudo
)
CascadeVisitedMode
:
:
Visited
=
>
inputs
.
take_visited_values
(
)
}
}
fn
visited_values_for_insertion
(
&
self
)
-
>
bool
{
*
self
=
=
CascadeVisitedMode
:
:
Unvisited
}
fn
should_process_animations
(
&
self
)
-
>
bool
{
*
self
=
=
CascadeVisitedMode
:
:
Unvisited
}
fn
should_accumulate_damage
(
&
self
)
-
>
bool
{
*
self
=
=
CascadeVisitedMode
:
:
Unvisited
}
fn
visited_dependent_only
(
&
self
)
-
>
bool
{
*
self
=
=
CascadeVisitedMode
:
:
Visited
}
}
trait
PrivateMatchMethods
:
TElement
{
fn
layout_parent
(
&
self
)
-
>
Self
{
let
mut
current
=
self
.
clone
(
)
;
loop
{
current
=
match
current
.
traversal_parent
(
)
{
Some
(
el
)
=
>
el
None
=
>
return
current
}
;
let
is_display_contents
=
current
.
borrow_data
(
)
.
unwrap
(
)
.
styles
.
primary
(
)
.
is_display_contents
(
)
;
if
!
is_display_contents
{
return
current
;
}
}
}
fn
get_inherited_style_and_parent
(
&
self
)
-
>
ParentElementAndStyle
<
Self
>
{
let
parent_el
=
self
.
inheritance_parent
(
)
;
let
parent_data
=
parent_el
.
as_ref
(
)
.
and_then
(
|
e
|
e
.
borrow_data
(
)
)
;
let
parent_style
=
parent_data
.
as_ref
(
)
.
map
(
|
d
|
{
debug_assert
!
(
cfg
!
(
feature
=
"
gecko
"
)
|
|
parent_el
.
unwrap
(
)
.
has_current_styles
(
d
)
)
;
d
.
styles
.
primary
(
)
}
)
;
ParentElementAndStyle
{
element
:
parent_el
style
:
parent_style
.
cloned
(
)
}
}
fn
cascade_with_rules
(
&
self
shared_context
:
&
SharedStyleContext
font_metrics_provider
:
&
FontMetricsProvider
rule_node
:
&
StrongRuleNode
primary_style
:
Option
<
&
Arc
<
ComputedValues
>
>
cascade_target
:
CascadeTarget
cascade_visited
:
CascadeVisitedMode
parent_info
:
Option
<
&
ParentElementAndStyle
<
Self
>
>
visited_values_to_insert
:
Option
<
Arc
<
ComputedValues
>
>
)
-
>
Arc
<
ComputedValues
>
{
let
mut
cascade_info
=
CascadeInfo
:
:
new
(
)
;
let
mut
cascade_flags
=
CascadeFlags
:
:
empty
(
)
;
if
self
.
skip_root_and_item_based_display_fixup
(
)
{
cascade_flags
.
insert
(
SKIP_ROOT_AND_ITEM_BASED_DISPLAY_FIXUP
)
}
if
cascade_visited
.
visited_dependent_only
(
)
{
cascade_flags
.
insert
(
VISITED_DEPENDENT_ONLY
)
;
}
if
self
.
is_native_anonymous
(
)
|
|
cascade_target
=
=
CascadeTarget
:
:
EagerPseudo
{
cascade_flags
.
insert
(
PROHIBIT_DISPLAY_CONTENTS
)
;
}
else
if
self
.
is_root
(
)
{
debug_assert
!
(
self
.
owner_doc_matches_for_testing
(
shared_context
.
stylist
.
device
(
)
)
)
;
cascade_flags
.
insert
(
IS_ROOT_ELEMENT
)
;
}
let
parent_el
;
let
element_and_style
;
let
style_to_inherit_from
=
match
cascade_target
{
CascadeTarget
:
:
Normal
=
>
{
let
info
=
match
parent_info
{
Some
(
element_and_style
)
=
>
element_and_style
None
=
>
{
element_and_style
=
self
.
get_inherited_style_and_parent
(
)
;
&
element_and_style
}
}
;
parent_el
=
info
.
element
;
info
.
style
.
as_ref
(
)
.
map
(
|
s
|
cascade_visited
.
values
(
s
)
)
}
CascadeTarget
:
:
EagerPseudo
=
>
{
parent_el
=
Some
(
self
.
clone
(
)
)
;
Some
(
cascade_visited
.
values
(
primary_style
.
unwrap
(
)
)
)
}
}
;
let
mut
layout_parent_el
=
parent_el
.
clone
(
)
;
let
layout_parent_data
;
let
mut
layout_parent_style
=
style_to_inherit_from
;
if
style_to_inherit_from
.
map_or
(
false
|
s
|
s
.
is_display_contents
(
)
)
{
layout_parent_el
=
Some
(
layout_parent_el
.
unwrap
(
)
.
layout_parent
(
)
)
;
layout_parent_data
=
layout_parent_el
.
as_ref
(
)
.
unwrap
(
)
.
borrow_data
(
)
.
unwrap
(
)
;
layout_parent_style
=
Some
(
cascade_visited
.
values
(
layout_parent_data
.
styles
.
primary
(
)
)
)
;
}
let
style_to_inherit_from
=
style_to_inherit_from
.
map
(
|
x
|
&
*
*
x
)
;
let
layout_parent_style
=
layout_parent_style
.
map
(
|
x
|
&
*
*
x
)
;
if
let
Some
(
ref
p
)
=
layout_parent_style
{
let
can_be_fragmented
=
p
.
is_multicol
(
)
|
|
layout_parent_el
.
as_ref
(
)
.
unwrap
(
)
.
as_node
(
)
.
can_be_fragmented
(
)
;
unsafe
{
self
.
as_node
(
)
.
set_can_be_fragmented
(
can_be_fragmented
)
;
}
}
let
values
=
Arc
:
:
new
(
cascade
(
shared_context
.
stylist
.
device
(
)
rule_node
&
shared_context
.
guards
style_to_inherit_from
layout_parent_style
visited_values_to_insert
Some
(
&
mut
cascade_info
)
&
*
shared_context
.
error_reporter
font_metrics_provider
cascade_flags
shared_context
.
quirks_mode
)
)
;
cascade_info
.
finish
(
&
self
.
as_node
(
)
)
;
values
}
fn
cascade_internal
(
&
self
context
:
&
StyleContext
<
Self
>
primary_style
:
Option
<
&
Arc
<
ComputedValues
>
>
primary_inputs
:
&
CascadeInputs
eager_pseudo_inputs
:
Option
<
&
CascadeInputs
>
parent_info
:
Option
<
&
ParentElementAndStyle
<
Self
>
>
cascade_visited
:
CascadeVisitedMode
)
-
>
Arc
<
ComputedValues
>
{
if
let
Some
(
pseudo
)
=
self
.
implemented_pseudo_element
(
)
{
debug_assert
!
(
eager_pseudo_inputs
.
is_none
(
)
)
;
let
only_default_rules
=
context
.
shared
.
traversal_flags
.
for_default_styles
(
)
;
if
pseudo
.
is_eager
(
)
&
&
!
only_default_rules
{
debug_assert
!
(
pseudo
.
is_before_or_after
(
)
)
;
let
parent
=
self
.
parent_element
(
)
.
unwrap
(
)
;
if
!
parent
.
may_have_animations
(
)
|
|
primary_inputs
.
rules
(
)
.
get_animation_rules
(
)
.
is_empty
(
)
{
let
parent_data
=
parent
.
borrow_data
(
)
.
unwrap
(
)
;
let
pseudo_style
=
parent_data
.
styles
.
pseudos
.
get
(
&
pseudo
)
.
unwrap
(
)
;
let
values
=
cascade_visited
.
values
(
pseudo_style
)
;
return
values
.
clone
(
)
}
}
}
let
visited_values_to_insert
=
if
cascade_visited
.
visited_values_for_insertion
(
)
{
match
eager_pseudo_inputs
{
Some
(
ref
s
)
=
>
s
.
clone_visited_values
(
)
None
=
>
primary_inputs
.
clone_visited_values
(
)
}
}
else
{
None
}
;
let
inputs
=
eager_pseudo_inputs
.
unwrap_or
(
primary_inputs
)
;
let
rule_node
=
cascade_visited
.
rules
(
inputs
)
;
let
cascade_target
=
if
eager_pseudo_inputs
.
is_some
(
)
{
CascadeTarget
:
:
EagerPseudo
}
else
{
CascadeTarget
:
:
Normal
}
;
self
.
cascade_with_rules
(
context
.
shared
&
context
.
thread_local
.
font_metrics_provider
rule_node
primary_style
cascade_target
cascade_visited
parent_info
visited_values_to_insert
)
}
fn
cascade_primary
(
&
self
context
:
&
mut
StyleContext
<
Self
>
data
:
&
mut
ElementData
important_rules_changed
:
bool
parent_info
:
&
ParentElementAndStyle
<
Self
>
cascade_visited
:
CascadeVisitedMode
)
-
>
ChildCascadeRequirement
{
debug
!
(
"
Cascade
primary
for
{
:
?
}
visited
:
{
:
?
}
"
self
cascade_visited
)
;
let
mut
old_values
=
cascade_visited
.
take_primary_values
(
&
mut
data
.
styles
context
.
cascade_inputs_mut
(
)
.
primary_mut
(
)
)
;
let
mut
new_values
=
{
let
primary_inputs
=
context
.
cascade_inputs
(
)
.
primary
(
)
;
if
!
cascade_visited
.
has_rules
(
primary_inputs
)
&
&
!
parent_info
.
has_visited_style
(
)
{
return
ChildCascadeRequirement
:
:
CanSkipCascade
}
self
.
cascade_internal
(
context
None
primary_inputs
None
None
cascade_visited
)
}
;
if
!
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
&
&
cascade_visited
.
should_process_animations
(
)
{
self
.
process_animations
(
context
&
mut
old_values
&
mut
new_values
important_rules_changed
)
;
}
let
mut
child_cascade_requirement
=
ChildCascadeRequirement
:
:
CanSkipCascade
;
if
cascade_visited
.
should_accumulate_damage
(
)
{
child_cascade_requirement
=
self
.
accumulate_damage
(
&
context
.
shared
&
mut
data
.
restyle
old_values
.
as_ref
(
)
.
map
(
|
v
|
v
.
as_ref
(
)
)
&
new_values
None
)
;
if
self
.
is_root
(
)
&
&
!
self
.
is_native_anonymous
(
)
{
let
device
=
context
.
shared
.
stylist
.
device
(
)
;
let
new_font_size
=
new_values
.
get_font
(
)
.
clone_font_size
(
)
;
if
old_values
.
map_or
(
false
|
v
|
v
.
get_font
(
)
.
clone_font_size
(
)
!
=
new_font_size
)
&
&
device
.
used_root_font_size
(
)
{
child_cascade_requirement
=
ChildCascadeRequirement
:
:
MustCascadeDescendants
;
}
}
}
let
primary_inputs
=
context
.
cascade_inputs_mut
(
)
.
primary_mut
(
)
;
cascade_visited
.
set_primary_values
(
&
mut
data
.
styles
primary_inputs
new_values
)
;
child_cascade_requirement
}
fn
cascade_eager_pseudo
(
&
self
context
:
&
mut
StyleContext
<
Self
>
data
:
&
mut
ElementData
pseudo
:
&
PseudoElement
cascade_visited
:
CascadeVisitedMode
)
{
debug_assert
!
(
pseudo
.
is_eager
(
)
)
;
let
old_values
=
cascade_visited
.
take_pseudo_values
(
&
mut
data
.
styles
context
.
cascade_inputs_mut
(
)
.
pseudos
.
get_mut
(
pseudo
)
.
unwrap
(
)
pseudo
)
;
let
new_values
=
{
let
pseudo_inputs
=
context
.
cascade_inputs
(
)
.
pseudos
.
get
(
pseudo
)
.
unwrap
(
)
;
if
!
cascade_visited
.
has_rules
(
pseudo_inputs
)
{
return
}
let
primary_inputs
=
context
.
cascade_inputs
(
)
.
primary
(
)
;
debug_assert
!
(
cascade_visited
.
has_rules
(
primary_inputs
)
)
;
self
.
cascade_internal
(
context
data
.
styles
.
get_primary
(
)
primary_inputs
Some
(
pseudo_inputs
)
None
cascade_visited
)
}
;
if
cascade_visited
.
should_accumulate_damage
(
)
{
self
.
accumulate_damage
(
&
context
.
shared
&
mut
data
.
restyle
old_values
.
as_ref
(
)
.
map
(
|
v
|
v
.
as_ref
(
)
)
&
new_values
Some
(
pseudo
)
)
;
}
let
pseudo_inputs
=
context
.
cascade_inputs_mut
(
)
.
pseudos
.
get_mut
(
pseudo
)
.
unwrap
(
)
;
cascade_visited
.
set_pseudo_values
(
&
mut
data
.
styles
pseudo_inputs
pseudo
new_values
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
get_after_change_style
(
&
self
context
:
&
mut
StyleContext
<
Self
>
primary_style
:
&
Arc
<
ComputedValues
>
)
-
>
Option
<
Arc
<
ComputedValues
>
>
{
let
rule_node
=
primary_style
.
rules
(
)
;
let
without_transition_rules
=
context
.
shared
.
stylist
.
rule_tree
(
)
.
remove_transition_rule_if_applicable
(
rule_node
)
;
if
without_transition_rules
=
=
*
rule_node
{
return
None
;
}
Some
(
self
.
cascade_with_rules
(
context
.
shared
&
context
.
thread_local
.
font_metrics_provider
&
without_transition_rules
Some
(
primary_style
)
CascadeTarget
:
:
Normal
CascadeVisitedMode
:
:
Unvisited
None
None
)
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
needs_animations_update
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
Option
<
&
Arc
<
ComputedValues
>
>
new_values
:
&
ComputedValues
)
-
>
bool
{
let
new_box_style
=
new_values
.
get_box
(
)
;
let
has_new_animation_style
=
new_box_style
.
animation_name_count
(
)
>
=
1
&
&
new_box_style
.
animation_name_at
(
0
)
.
0
.
is_some
(
)
;
let
has_animations
=
self
.
has_css_animations
(
)
;
old_values
.
map_or
(
has_new_animation_style
|
old
|
{
let
old_box_style
=
old
.
get_box
(
)
;
let
old_display_style
=
old_box_style
.
clone_display
(
)
;
let
new_display_style
=
new_box_style
.
clone_display
(
)
;
(
context
.
shared
.
traversal_flags
.
for_css_rule_changes
(
)
&
&
has_new_animation_style
)
|
|
!
old_box_style
.
animations_equals
(
&
new_box_style
)
|
|
(
old_display_style
=
=
display
:
:
T
:
:
none
&
&
new_display_style
!
=
display
:
:
T
:
:
none
&
&
has_new_animation_style
)
|
|
(
old_display_style
!
=
display
:
:
T
:
:
none
&
&
new_display_style
=
=
display
:
:
T
:
:
none
&
&
has_animations
)
}
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
process_animations
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
&
mut
Option
<
Arc
<
ComputedValues
>
>
new_values
:
&
mut
Arc
<
ComputedValues
>
important_rules_changed
:
bool
)
{
use
context
:
:
{
CASCADE_RESULTS
CSS_ANIMATIONS
CSS_TRANSITIONS
EFFECT_PROPERTIES
}
;
use
context
:
:
UpdateAnimationsTasks
;
let
mut
tasks
=
UpdateAnimationsTasks
:
:
empty
(
)
;
if
self
.
needs_animations_update
(
context
old_values
.
as_ref
(
)
new_values
)
{
tasks
.
insert
(
CSS_ANIMATIONS
)
;
}
let
before_change_style
=
if
self
.
might_need_transitions_update
(
old_values
.
as_ref
(
)
.
map
(
|
s
|
&
*
*
s
)
new_values
)
{
let
after_change_style
=
if
self
.
has_css_transitions
(
)
{
self
.
get_after_change_style
(
context
new_values
)
}
else
{
None
}
;
let
needs_transitions_update
=
{
let
after_change_style_ref
=
after_change_style
.
as_ref
(
)
.
unwrap_or
(
&
new_values
)
;
self
.
needs_transitions_update
(
old_values
.
as_ref
(
)
.
unwrap
(
)
after_change_style_ref
)
}
;
if
needs_transitions_update
{
if
let
Some
(
values_without_transitions
)
=
after_change_style
{
*
new_values
=
values_without_transitions
;
}
tasks
.
insert
(
CSS_TRANSITIONS
)
;
old_values
.
clone
(
)
}
else
{
None
}
}
else
{
None
}
;
if
self
.
has_animations
(
)
{
tasks
.
insert
(
EFFECT_PROPERTIES
)
;
if
important_rules_changed
{
tasks
.
insert
(
CASCADE_RESULTS
)
;
}
}
if
!
tasks
.
is_empty
(
)
{
let
task
=
:
:
context
:
:
SequentialTask
:
:
update_animations
(
*
self
before_change_style
tasks
)
;
context
.
thread_local
.
tasks
.
push
(
task
)
;
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
process_animations
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
&
mut
Option
<
Arc
<
ComputedValues
>
>
new_values
:
&
mut
Arc
<
ComputedValues
>
_important_rules_changed
:
bool
)
{
use
animation
;
let
possibly_expired_animations
=
&
mut
context
.
thread_local
.
current_element_info
.
as_mut
(
)
.
unwrap
(
)
.
possibly_expired_animations
;
let
shared_context
=
context
.
shared
;
if
let
Some
(
ref
mut
old
)
=
*
old_values
{
self
.
update_animations_for_cascade
(
shared_context
old
possibly_expired_animations
&
context
.
thread_local
.
font_metrics_provider
)
;
}
let
new_animations_sender
=
&
context
.
thread_local
.
new_animations_sender
;
let
this_opaque
=
self
.
as_node
(
)
.
opaque
(
)
;
animation
:
:
maybe_start_animations
(
&
shared_context
new_animations_sender
this_opaque
&
new_values
)
;
if
let
Some
(
ref
values
)
=
*
old_values
{
animation
:
:
start_transitions_if_applicable
(
new_animations_sender
this_opaque
&
*
*
values
new_values
&
shared_context
.
timer
&
possibly_expired_animations
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
accumulate_damage_for
(
&
self
shared_context
:
&
SharedStyleContext
restyle
:
&
mut
RestyleData
old_values
:
&
ComputedValues
new_values
:
&
Arc
<
ComputedValues
>
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
ChildCascadeRequirement
{
use
properties
:
:
computed_value_flags
:
:
*
;
if
shared_context
.
traversal_flags
.
for_reconstruct
(
)
{
return
ChildCascadeRequirement
:
:
MustCascadeChildren
;
}
let
skip_applying_damage
=
restyle
.
reconstructed_self_or_ancestor
(
)
;
let
difference
=
self
.
compute_style_difference
(
&
old_values
&
new_values
pseudo
)
;
if
!
skip_applying_damage
{
restyle
.
damage
|
=
difference
.
damage
;
}
match
difference
.
change
{
StyleChange
:
:
Unchanged
=
>
{
if
old_values
.
flags
.
contains
(
HAS_TEXT_DECORATION_LINE
)
!
=
new_values
.
flags
.
contains
(
HAS_TEXT_DECORATION_LINE
)
{
return
ChildCascadeRequirement
:
:
MustCascadeChildren
;
}
ChildCascadeRequirement
:
:
CanSkipCascade
}
StyleChange
:
:
Changed
=
>
ChildCascadeRequirement
:
:
MustCascadeChildren
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
accumulate_damage_for
(
&
self
_shared_context
:
&
SharedStyleContext
restyle
:
&
mut
RestyleData
old_values
:
&
ComputedValues
new_values
:
&
Arc
<
ComputedValues
>
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
ChildCascadeRequirement
{
let
difference
=
self
.
compute_style_difference
(
&
old_values
&
new_values
pseudo
)
;
restyle
.
damage
|
=
difference
.
damage
;
match
difference
.
change
{
StyleChange
:
:
Changed
=
>
ChildCascadeRequirement
:
:
MustCascadeChildren
StyleChange
:
:
Unchanged
=
>
ChildCascadeRequirement
:
:
CanSkipCascade
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
update_animations_for_cascade
(
&
self
context
:
&
SharedStyleContext
style
:
&
mut
Arc
<
ComputedValues
>
possibly_expired_animations
:
&
mut
Vec
<
:
:
animation
:
:
PropertyAnimation
>
font_metrics
:
&
FontMetricsProvider
)
{
use
animation
:
:
{
self
Animation
}
;
let
this_opaque
=
self
.
as_node
(
)
.
opaque
(
)
;
animation
:
:
complete_expired_transitions
(
this_opaque
style
context
)
;
let
had_running_animations
=
context
.
running_animations
.
read
(
)
.
get
(
&
this_opaque
)
.
is_some
(
)
;
if
had_running_animations
{
let
mut
all_running_animations
=
context
.
running_animations
.
write
(
)
;
for
running_animation
in
all_running_animations
.
get_mut
(
&
this_opaque
)
.
unwrap
(
)
{
if
!
running_animation
.
is_expired
(
)
{
animation
:
:
update_style_for_animation
(
context
running_animation
style
font_metrics
)
;
if
let
Animation
:
:
Transition
(
_
_
ref
frame
_
)
=
*
running_animation
{
possibly_expired_animations
.
push
(
frame
.
property_animation
.
clone
(
)
)
}
}
}
}
}
}
impl
<
E
:
TElement
>
PrivateMatchMethods
for
E
{
}
#
[
derive
(
Debug
)
]
struct
ParentElementAndStyle
<
E
:
TElement
>
{
element
:
Option
<
E
>
style
:
Option
<
Arc
<
ComputedValues
>
>
}
impl
<
E
:
TElement
>
ParentElementAndStyle
<
E
>
{
fn
has_visited_style
(
&
self
)
-
>
bool
{
self
.
style
.
as_ref
(
)
.
map_or
(
false
|
v
|
{
v
.
get_visited_style
(
)
.
is_some
(
)
}
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
MatchingResults
{
rules_changed
:
bool
important_rules_overriding_animation_changed
:
bool
relations
:
StyleRelations
relevant_link_found
:
bool
}
impl
MatchingResults
{
fn
new
(
rules_changed
:
bool
important_rules
:
bool
)
-
>
Self
{
Self
{
rules_changed
:
rules_changed
important_rules_overriding_animation_changed
:
important_rules
relations
:
StyleRelations
:
:
default
(
)
relevant_link_found
:
false
}
}
fn
new_from_context
(
rules_changed
:
bool
important_rules
:
bool
context
:
MatchingContext
)
-
>
Self
{
Self
{
rules_changed
:
rules_changed
important_rules_overriding_animation_changed
:
important_rules
relations
:
context
.
relations
relevant_link_found
:
context
.
relevant_link_found
}
}
}
pub
trait
MatchMethods
:
TElement
{
fn
match_and_cascade
(
&
self
context
:
&
mut
StyleContext
<
Self
>
data
:
&
mut
ElementData
sharing
:
StyleSharingBehavior
)
-
>
ChildCascadeRequirement
{
debug
!
(
"
Match
and
cascade
for
{
:
?
}
"
self
)
;
let
mut
primary_results
=
self
.
match_primary
(
context
data
VisitedHandlingMode
:
:
AllLinksUnvisited
)
;
let
important_rules_changed
=
primary_results
.
important_rules_overriding_animation_changed
;
let
relevant_link_found
=
primary_results
.
relevant_link_found
;
if
relevant_link_found
{
self
.
match_primary
(
context
data
VisitedHandlingMode
:
:
RelevantLinkVisited
)
;
}
let
parent_and_styles
=
self
.
get_inherited_style_and_parent
(
)
;
if
relevant_link_found
|
|
parent_and_styles
.
has_visited_style
(
)
{
self
.
cascade_primary
(
context
data
important_rules_changed
&
parent_and_styles
CascadeVisitedMode
:
:
Visited
)
;
}
let
child_cascade_requirement
=
self
.
cascade_primary
(
context
data
important_rules_changed
&
parent_and_styles
CascadeVisitedMode
:
:
Unvisited
)
;
if
!
data
.
styles
.
is_display_none
(
)
{
self
.
match_pseudos
(
context
data
VisitedHandlingMode
:
:
AllLinksUnvisited
)
;
if
relevant_link_found
{
self
.
match_pseudos
(
context
data
VisitedHandlingMode
:
:
RelevantLinkVisited
)
;
self
.
cascade_pseudos
(
context
data
CascadeVisitedMode
:
:
Visited
)
;
}
self
.
cascade_pseudos
(
context
data
CascadeVisitedMode
:
:
Unvisited
)
;
}
if
!
data
.
styles
.
pseudos
.
is_empty
(
)
{
primary_results
.
relations
|
=
AFFECTED_BY_PSEUDO_ELEMENTS
;
}
if
sharing
=
=
StyleSharingBehavior
:
:
Allow
{
let
validation_data
=
context
.
thread_local
.
current_element_info
.
as_mut
(
)
.
unwrap
(
)
.
validation_data
.
take
(
)
;
let
dom_depth
=
context
.
thread_local
.
bloom_filter
.
matching_depth
(
)
;
context
.
thread_local
.
style_sharing_candidate_cache
.
insert_if_possible
(
self
data
.
styles
.
primary
(
)
primary_results
.
relations
validation_data
dom_depth
)
;
}
child_cascade_requirement
}
fn
cascade_primary_and_pseudos
(
&
self
context
:
&
mut
StyleContext
<
Self
>
mut
data
:
&
mut
ElementData
important_rules_changed
:
bool
)
-
>
ChildCascadeRequirement
{
let
parent_and_styles
=
self
.
get_inherited_style_and_parent
(
)
;
self
.
cascade_primary
(
context
&
mut
data
important_rules_changed
&
parent_and_styles
CascadeVisitedMode
:
:
Visited
)
;
let
child_cascade_requirement
=
self
.
cascade_primary
(
context
&
mut
data
important_rules_changed
&
parent_and_styles
CascadeVisitedMode
:
:
Unvisited
)
;
self
.
cascade_pseudos
(
context
&
mut
data
CascadeVisitedMode
:
:
Visited
)
;
self
.
cascade_pseudos
(
context
&
mut
data
CascadeVisitedMode
:
:
Unvisited
)
;
child_cascade_requirement
}
fn
match_primary
(
&
self
context
:
&
mut
StyleContext
<
Self
>
data
:
&
mut
ElementData
visited_handling
:
VisitedHandlingMode
)
-
>
MatchingResults
{
debug
!
(
"
Match
primary
for
{
:
?
}
visited
:
{
:
?
}
"
self
visited_handling
)
;
let
mut
primary_inputs
=
context
.
thread_local
.
current_element_info
.
as_mut
(
)
.
unwrap
(
)
.
cascade_inputs
.
ensure_primary
(
)
;
let
only_default_rules
=
context
.
shared
.
traversal_flags
.
for_default_styles
(
)
;
let
implemented_pseudo
=
self
.
implemented_pseudo_element
(
)
;
if
let
Some
(
ref
pseudo
)
=
implemented_pseudo
{
debug_assert_eq
!
(
*
pseudo
pseudo
.
canonical
(
)
)
;
if
pseudo
.
is_eager
(
)
&
&
!
only_default_rules
{
let
parent
=
self
.
parent_element
(
)
.
unwrap
(
)
;
let
parent_data
=
parent
.
borrow_data
(
)
.
unwrap
(
)
;
let
pseudo_style
=
parent_data
.
styles
.
pseudos
.
get
(
&
pseudo
)
.
unwrap
(
)
;
let
mut
rules
=
pseudo_style
.
rules
(
)
.
clone
(
)
;
if
parent
.
may_have_animations
(
)
{
let
animation_rules
=
data
.
get_animation_rules
(
)
;
if
let
Some
(
animation_rule
)
=
animation_rules
.
0
{
let
animation_rule_node
=
context
.
shared
.
stylist
.
rule_tree
(
)
.
update_rule_at_level
(
CascadeLevel
:
:
Animations
Some
(
&
animation_rule
)
&
mut
rules
&
context
.
shared
.
guards
)
;
if
let
Some
(
node
)
=
animation_rule_node
{
rules
=
node
;
}
}
if
let
Some
(
animation_rule
)
=
animation_rules
.
1
{
let
animation_rule_node
=
context
.
shared
.
stylist
.
rule_tree
(
)
.
update_rule_at_level
(
CascadeLevel
:
:
Transitions
Some
(
&
animation_rule
)
&
mut
rules
&
context
.
shared
.
guards
)
;
if
let
Some
(
node
)
=
animation_rule_node
{
rules
=
node
;
}
}
}
let
important_rules_changed
=
self
.
has_animations
(
)
&
&
data
.
has_styles
(
)
&
&
data
.
important_rules_are_different
(
&
rules
&
context
.
shared
.
guards
)
;
let
rules_changed
=
primary_inputs
.
set_rules
(
visited_handling
rules
)
;
return
MatchingResults
:
:
new
(
rules_changed
important_rules_changed
)
}
}
let
mut
applicable_declarations
=
ApplicableDeclarationList
:
:
new
(
)
;
let
stylist
=
&
context
.
shared
.
stylist
;
let
style_attribute
=
self
.
style_attribute
(
)
;
let
map
=
&
mut
context
.
thread_local
.
selector_flags
;
let
mut
set_selector_flags
=
|
element
:
&
Self
flags
:
ElementSelectorFlags
|
{
self
.
apply_selector_flags
(
map
element
flags
)
;
}
;
let
rule_inclusion
=
if
only_default_rules
{
RuleInclusion
:
:
DefaultOnly
}
else
{
RuleInclusion
:
:
All
}
;
let
bloom_filter
=
context
.
thread_local
.
bloom_filter
.
filter
(
)
;
let
mut
matching_context
=
MatchingContext
:
:
new_for_visited
(
MatchingMode
:
:
Normal
Some
(
bloom_filter
)
visited_handling
context
.
shared
.
quirks_mode
)
;
{
let
smil_override
=
data
.
get_smil_override
(
)
;
let
animation_rules
=
if
self
.
may_have_animations
(
)
{
data
.
get_animation_rules
(
)
}
else
{
AnimationRules
(
None
None
)
}
;
stylist
.
push_applicable_declarations
(
self
implemented_pseudo
.
as_ref
(
)
style_attribute
smil_override
animation_rules
rule_inclusion
&
mut
applicable_declarations
&
mut
matching_context
&
mut
set_selector_flags
)
;
}
self
.
unset_dirty_style_attribute
(
)
;
let
primary_rule_node
=
stylist
.
rule_tree
(
)
.
compute_rule_node
(
&
mut
applicable_declarations
&
context
.
shared
.
guards
)
;
if
log_enabled
!
(
Trace
)
{
trace
!
(
"
Matched
rules
:
"
)
;
for
rn
in
primary_rule_node
.
self_and_ancestors
(
)
{
let
source
=
rn
.
style_source
(
)
;
if
source
.
is_some
(
)
{
trace
!
(
"
>
{
:
?
}
"
source
)
;
}
}
}
let
important_rules_changed
=
self
.
has_animations
(
)
&
&
data
.
has_styles
(
)
&
&
data
.
important_rules_are_different
(
&
primary_rule_node
&
context
.
shared
.
guards
)
;
let
rules_changed
=
primary_inputs
.
set_rules
(
visited_handling
primary_rule_node
)
;
MatchingResults
:
:
new_from_context
(
rules_changed
important_rules_changed
matching_context
)
}
fn
match_pseudos
(
&
self
context
:
&
mut
StyleContext
<
Self
>
data
:
&
mut
ElementData
visited_handling
:
VisitedHandlingMode
)
{
debug
!
(
"
Match
pseudos
for
{
:
?
}
visited
:
{
:
?
}
"
self
visited_handling
)
;
if
self
.
implemented_pseudo_element
(
)
.
is_some
(
)
{
return
;
}
let
mut
applicable_declarations
=
ApplicableDeclarationList
:
:
new
(
)
;
let
stylist
=
&
context
.
shared
.
stylist
;
let
guards
=
&
context
.
shared
.
guards
;
let
rule_inclusion
=
if
context
.
shared
.
traversal_flags
.
for_default_styles
(
)
{
RuleInclusion
:
:
DefaultOnly
}
else
{
RuleInclusion
:
:
All
}
;
let
mut
matches_different_pseudos
=
false
;
SelectorImpl
:
:
each_eagerly_cascaded_pseudo_element
(
|
pseudo
|
{
if
visited_handling
=
=
VisitedHandlingMode
:
:
RelevantLinkVisited
&
&
!
context
.
cascade_inputs
(
)
.
pseudos
.
has
(
&
pseudo
)
{
return
}
if
self
.
may_generate_pseudo
(
&
pseudo
data
.
styles
.
primary
(
)
)
{
let
bloom_filter
=
context
.
thread_local
.
bloom_filter
.
filter
(
)
;
let
mut
matching_context
=
MatchingContext
:
:
new_for_visited
(
MatchingMode
:
:
ForStatelessPseudoElement
Some
(
bloom_filter
)
visited_handling
context
.
shared
.
quirks_mode
)
;
let
map
=
&
mut
context
.
thread_local
.
selector_flags
;
let
mut
set_selector_flags
=
|
element
:
&
Self
flags
:
ElementSelectorFlags
|
{
self
.
apply_selector_flags
(
map
element
flags
)
;
}
;
debug_assert
!
(
applicable_declarations
.
is_empty
(
)
)
;
stylist
.
push_applicable_declarations
(
self
Some
(
&
pseudo
)
None
None
AnimationRules
(
None
None
)
rule_inclusion
&
mut
applicable_declarations
&
mut
matching_context
&
mut
set_selector_flags
)
;
}
let
pseudos
=
&
mut
context
.
thread_local
.
current_element_info
.
as_mut
(
)
.
unwrap
(
)
.
cascade_inputs
.
pseudos
;
if
!
applicable_declarations
.
is_empty
(
)
{
let
rules
=
stylist
.
rule_tree
(
)
.
compute_rule_node
(
&
mut
applicable_declarations
&
guards
)
;
matches_different_pseudos
|
=
!
data
.
styles
.
pseudos
.
has
(
&
pseudo
)
;
pseudos
.
add_rules
(
&
pseudo
visited_handling
rules
)
;
}
else
{
matches_different_pseudos
|
=
data
.
styles
.
pseudos
.
has
(
&
pseudo
)
;
pseudos
.
remove_rules
(
&
pseudo
visited_handling
)
;
data
.
styles
.
pseudos
.
take
(
&
pseudo
)
;
}
}
)
;
if
matches_different_pseudos
&
&
data
.
restyle
.
is_restyle
(
)
{
data
.
restyle
.
damage
|
=
RestyleDamage
:
:
reconstruct
(
)
;
}
}
fn
apply_selector_flags
(
&
self
map
:
&
mut
SelectorFlagsMap
<
Self
>
element
:
&
Self
flags
:
ElementSelectorFlags
)
{
let
self_flags
=
flags
.
for_self
(
)
;
if
!
self_flags
.
is_empty
(
)
{
if
element
=
=
self
{
unsafe
{
element
.
set_selector_flags
(
self_flags
)
;
}
}
else
{
if
!
element
.
has_selector_flags
(
self_flags
)
{
map
.
insert_flags
(
*
element
self_flags
)
;
}
}
}
let
parent_flags
=
flags
.
for_parent
(
)
;
if
!
parent_flags
.
is_empty
(
)
{
if
let
Some
(
p
)
=
element
.
parent_element
(
)
{
if
!
p
.
has_selector_flags
(
parent_flags
)
{
map
.
insert_flags
(
p
parent_flags
)
;
}
}
}
}
fn
accumulate_damage
(
&
self
shared_context
:
&
SharedStyleContext
restyle
:
&
mut
RestyleData
old_values
:
Option
<
&
ComputedValues
>
new_values
:
&
Arc
<
ComputedValues
>
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
ChildCascadeRequirement
{
let
old_values
=
match
old_values
{
Some
(
v
)
=
>
v
None
=
>
return
ChildCascadeRequirement
:
:
MustCascadeChildren
}
;
let
is_existing_before_or_after
=
cfg
!
(
feature
=
"
gecko
"
)
&
&
pseudo
.
map_or
(
false
|
p
|
p
.
is_before_or_after
(
)
)
&
&
self
.
existing_style_for_restyle_damage
(
old_values
pseudo
)
.
is_some
(
)
;
if
is_existing_before_or_after
{
return
ChildCascadeRequirement
:
:
CanSkipCascade
;
}
self
.
accumulate_damage_for
(
shared_context
restyle
old_values
new_values
pseudo
)
}
fn
replace_rules
(
&
self
replacements
:
RestyleHint
context
:
&
mut
StyleContext
<
Self
>
)
-
>
bool
{
let
mut
result
=
false
;
result
|
=
self
.
replace_rules_internal
(
replacements
context
CascadeVisitedMode
:
:
Unvisited
)
;
if
!
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
{
result
|
=
self
.
replace_rules_internal
(
replacements
context
CascadeVisitedMode
:
:
Visited
)
;
}
result
}
fn
replace_rules_internal
(
&
self
replacements
:
RestyleHint
context
:
&
mut
StyleContext
<
Self
>
cascade_visited
:
CascadeVisitedMode
)
-
>
bool
{
use
properties
:
:
PropertyDeclarationBlock
;
use
shared_lock
:
:
Locked
;
debug_assert
!
(
replacements
.
intersects
(
RestyleHint
:
:
replacements
(
)
)
&
&
(
replacements
&
!
RestyleHint
:
:
replacements
(
)
)
.
is_empty
(
)
)
;
let
stylist
=
&
context
.
shared
.
stylist
;
let
guards
=
&
context
.
shared
.
guards
;
let
mut
primary_inputs
=
context
.
cascade_inputs_mut
(
)
.
primary_mut
(
)
;
let
primary_rules
=
match
cascade_visited
.
get_rules_mut
(
primary_inputs
)
{
Some
(
r
)
=
>
r
None
=
>
return
false
}
;
let
replace_rule_node
=
|
level
:
CascadeLevel
pdb
:
Option
<
&
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
path
:
&
mut
StrongRuleNode
|
-
>
bool
{
let
new_node
=
stylist
.
rule_tree
(
)
.
update_rule_at_level
(
level
pdb
path
guards
)
;
match
new_node
{
Some
(
n
)
=
>
{
*
path
=
n
;
level
.
is_important
(
)
}
None
=
>
false
}
}
;
if
!
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
{
let
mut
result
=
false
;
if
replacements
.
contains
(
RESTYLE_STYLE_ATTRIBUTE
)
{
let
style_attribute
=
self
.
style_attribute
(
)
;
result
|
=
replace_rule_node
(
CascadeLevel
:
:
StyleAttributeNormal
style_attribute
primary_rules
)
;
result
|
=
replace_rule_node
(
CascadeLevel
:
:
StyleAttributeImportant
style_attribute
primary_rules
)
;
self
.
unset_dirty_style_attribute
(
)
;
}
return
result
;
}
if
replacements
.
intersects
(
RestyleHint
:
:
for_animations
(
)
)
{
debug_assert
!
(
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
)
;
if
replacements
.
contains
(
RESTYLE_SMIL
)
{
replace_rule_node
(
CascadeLevel
:
:
SMILOverride
self
.
get_smil_override
(
)
primary_rules
)
;
}
let
replace_rule_node_for_animation
=
|
level
:
CascadeLevel
primary_rules
:
&
mut
StrongRuleNode
|
{
let
animation_rule
=
self
.
get_animation_rule_by_cascade
(
level
)
;
replace_rule_node
(
level
animation_rule
.
as_ref
(
)
primary_rules
)
;
}
;
if
replacements
.
contains
(
RESTYLE_CSS_TRANSITIONS
)
{
replace_rule_node_for_animation
(
CascadeLevel
:
:
Transitions
primary_rules
)
;
}
if
replacements
.
contains
(
RESTYLE_CSS_ANIMATIONS
)
{
replace_rule_node_for_animation
(
CascadeLevel
:
:
Animations
primary_rules
)
;
}
}
false
}
fn
compute_style_difference
(
&
self
old_values
:
&
ComputedValues
new_values
:
&
Arc
<
ComputedValues
>
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
StyleDifference
{
debug_assert
!
(
pseudo
.
map_or
(
true
|
p
|
p
.
is_eager
(
)
)
)
;
if
let
Some
(
source
)
=
self
.
existing_style_for_restyle_damage
(
old_values
pseudo
)
{
return
RestyleDamage
:
:
compute_style_difference
(
source
new_values
)
}
let
new_style_is_display_none
=
new_values
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
T
:
:
none
;
let
old_style_is_display_none
=
old_values
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
T
:
:
none
;
if
new_style_is_display_none
&
&
old_style_is_display_none
{
return
StyleDifference
:
:
new
(
RestyleDamage
:
:
empty
(
)
StyleChange
:
:
Unchanged
)
}
if
pseudo
.
map_or
(
false
|
p
|
p
.
is_before_or_after
(
)
)
{
let
old_style_generates_no_pseudo
=
old_style_is_display_none
|
|
old_values
.
ineffective_content_property
(
)
;
let
new_style_generates_no_pseudo
=
new_style_is_display_none
|
|
new_values
.
ineffective_content_property
(
)
;
if
old_style_generates_no_pseudo
!
=
new_style_generates_no_pseudo
{
return
StyleDifference
:
:
new
(
RestyleDamage
:
:
reconstruct
(
)
StyleChange
:
:
Changed
)
}
return
StyleDifference
:
:
new
(
RestyleDamage
:
:
empty
(
)
StyleChange
:
:
Unchanged
)
}
if
pseudo
.
map_or
(
false
|
p
|
p
.
is_first_letter
(
)
)
{
return
StyleDifference
:
:
new
(
RestyleDamage
:
:
empty
(
)
StyleChange
:
:
Unchanged
)
}
warn
!
(
"
Reframing
due
to
lack
of
old
style
source
:
{
:
?
}
pseudo
:
{
:
?
}
"
self
pseudo
)
;
StyleDifference
:
:
new
(
RestyleDamage
:
:
reconstruct
(
)
StyleChange
:
:
Changed
)
}
fn
cascade_pseudos
(
&
self
context
:
&
mut
StyleContext
<
Self
>
mut
data
:
&
mut
ElementData
cascade_visited
:
CascadeVisitedMode
)
{
debug
!
(
"
Cascade
pseudos
for
{
:
?
}
visited
:
{
:
?
}
"
self
cascade_visited
)
;
let
matched_pseudos
=
context
.
cascade_inputs
(
)
.
pseudos
.
keys
(
)
;
for
pseudo
in
matched_pseudos
{
debug
!
(
"
Cascade
pseudo
for
{
:
?
}
{
:
?
}
"
self
pseudo
)
;
self
.
cascade_eager_pseudo
(
context
data
&
pseudo
cascade_visited
)
;
}
}
fn
get_base_style
(
&
self
shared_context
:
&
SharedStyleContext
font_metrics_provider
:
&
FontMetricsProvider
primary_style
:
&
Arc
<
ComputedValues
>
pseudo_style
:
Option
<
&
Arc
<
ComputedValues
>
>
)
-
>
Arc
<
ComputedValues
>
{
let
relevant_style
=
pseudo_style
.
unwrap_or
(
primary_style
)
;
let
rule_node
=
relevant_style
.
rules
(
)
;
let
without_animation_rules
=
shared_context
.
stylist
.
rule_tree
(
)
.
remove_animation_rules
(
rule_node
)
;
if
without_animation_rules
=
=
*
rule_node
{
return
relevant_style
.
clone
(
)
;
}
self
.
cascade_with_rules
(
shared_context
font_metrics_provider
&
without_animation_rules
Some
(
primary_style
)
CascadeTarget
:
:
Normal
CascadeVisitedMode
:
:
Unvisited
None
None
)
}
}
impl
<
E
:
TElement
>
MatchMethods
for
E
{
}
