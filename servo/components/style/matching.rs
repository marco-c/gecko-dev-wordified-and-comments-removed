#
!
[
allow
(
unsafe_code
)
]
#
!
[
deny
(
missing_docs
)
]
use
Atom
;
use
animation
:
:
{
self
Animation
PropertyAnimation
}
;
use
atomic_refcell
:
:
AtomicRefMut
;
use
bit_vec
:
:
BitVec
;
use
cache
:
:
{
LRUCache
LRUCacheMutIterator
}
;
use
cascade_info
:
:
CascadeInfo
;
use
context
:
:
{
CurrentElementInfo
SelectorFlagsMap
SharedStyleContext
StyleContext
}
;
use
data
:
:
{
ComputedStyle
ElementData
ElementStyles
RestyleData
}
;
use
dom
:
:
{
AnimationRules
SendElement
TElement
TNode
}
;
use
font_metrics
:
:
FontMetricsProvider
;
use
properties
:
:
{
CascadeFlags
ComputedValues
SKIP_ROOT_AND_ITEM_BASED_DISPLAY_FIXUP
cascade
}
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
as
display
;
use
restyle_hints
:
:
{
RESTYLE_STYLE_ATTRIBUTE
RESTYLE_CSS_ANIMATIONS
RESTYLE_CSS_TRANSITIONS
RestyleHint
}
;
use
rule_tree
:
:
{
CascadeLevel
RuleTree
StrongRuleNode
}
;
use
selector_parser
:
:
{
PseudoElement
RestyleDamage
SelectorImpl
}
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
use
selectors
:
:
matching
:
:
{
ElementSelectorFlags
StyleRelations
}
;
use
selectors
:
:
matching
:
:
AFFECTED_BY_PSEUDO_ELEMENTS
;
use
sink
:
:
ForgetfulSink
;
use
std
:
:
sync
:
:
Arc
;
use
stylist
:
:
ApplicableDeclarationBlock
;
#
[
inline
]
fn
relations_are_shareable
(
relations
:
&
StyleRelations
)
-
>
bool
{
use
selectors
:
:
matching
:
:
*
;
!
relations
.
intersects
(
AFFECTED_BY_ID_SELECTOR
|
AFFECTED_BY_PSEUDO_ELEMENTS
|
AFFECTED_BY_STYLE_ATTRIBUTE
|
AFFECTED_BY_PRESENTATIONAL_HINTS
)
}
#
[
derive
(
Debug
)
]
struct
StyleSharingCandidate
<
E
:
TElement
>
{
element
:
SendElement
<
E
>
class_attributes
:
Option
<
Vec
<
Atom
>
>
revalidation_match_results
:
Option
<
BitVec
>
}
impl
<
E
:
TElement
>
PartialEq
<
StyleSharingCandidate
<
E
>
>
for
StyleSharingCandidate
<
E
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
element
=
=
other
.
element
}
}
pub
struct
StyleSharingCandidateCache
<
E
:
TElement
>
{
cache
:
LRUCache
<
StyleSharingCandidate
<
E
>
>
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
CacheMiss
{
Parent
LocalName
Namespace
Link
UserAndAuthorRules
State
IdAttr
StyleAttr
Class
PresHints
Revalidation
}
fn
same_computed_values
<
E
:
TElement
>
(
first
:
Option
<
E
>
second
:
Option
<
E
>
)
-
>
bool
{
let
(
a
b
)
=
match
(
first
second
)
{
(
Some
(
f
)
Some
(
s
)
)
=
>
(
f
s
)
_
=
>
return
false
}
;
let
eq
=
:
:
arc_ptr_eq
(
a
.
borrow_data
(
)
.
unwrap
(
)
.
styles
(
)
.
primary
.
values
(
)
b
.
borrow_data
(
)
.
unwrap
(
)
.
styles
(
)
.
primary
.
values
(
)
)
;
eq
}
fn
element_matches_candidate
<
E
:
TElement
>
(
element
:
&
E
candidate
:
&
mut
StyleSharingCandidate
<
E
>
candidate_element
:
&
E
shared
:
&
SharedStyleContext
bloom
:
&
BloomFilter
info
:
&
mut
CurrentElementInfo
selector_flags_map
:
&
mut
SelectorFlagsMap
<
E
>
)
-
>
Result
<
ComputedStyle
CacheMiss
>
{
macro_rules
!
miss
{
(
miss
:
ident
)
=
>
{
return
Err
(
CacheMiss
:
:
miss
)
;
}
}
let
parent
=
element
.
parent_element
(
)
;
let
candidate_parent
=
candidate_element
.
parent_element
(
)
;
if
parent
!
=
candidate_parent
&
&
!
same_computed_values
(
parent
candidate_parent
)
{
miss
!
(
Parent
)
}
if
*
element
.
get_local_name
(
)
!
=
*
candidate_element
.
get_local_name
(
)
{
miss
!
(
LocalName
)
}
if
*
element
.
get_namespace
(
)
!
=
*
candidate_element
.
get_namespace
(
)
{
miss
!
(
Namespace
)
}
if
element
.
is_link
(
)
!
=
candidate_element
.
is_link
(
)
{
miss
!
(
Link
)
}
if
element
.
matches_user_and_author_rules
(
)
!
=
candidate_element
.
matches_user_and_author_rules
(
)
{
miss
!
(
UserAndAuthorRules
)
}
if
element
.
get_state
(
)
!
=
candidate_element
.
get_state
(
)
{
miss
!
(
State
)
}
if
element
.
get_id
(
)
.
is_some
(
)
{
miss
!
(
IdAttr
)
}
if
element
.
style_attribute
(
)
.
is_some
(
)
{
miss
!
(
StyleAttr
)
}
if
!
have_same_class
(
element
candidate
candidate_element
)
{
miss
!
(
Class
)
}
if
has_presentational_hints
(
element
)
{
miss
!
(
PresHints
)
}
if
!
revalidate
(
element
candidate
candidate_element
shared
bloom
info
selector_flags_map
)
{
miss
!
(
Revalidation
)
}
let
data
=
candidate_element
.
borrow_data
(
)
.
unwrap
(
)
;
debug_assert
!
(
data
.
has_current_styles
(
)
)
;
let
current_styles
=
data
.
styles
(
)
;
Ok
(
current_styles
.
primary
.
clone
(
)
)
}
fn
has_presentational_hints
<
E
:
TElement
>
(
element
:
&
E
)
-
>
bool
{
let
mut
hints
=
ForgetfulSink
:
:
new
(
)
;
element
.
synthesize_presentational_hints_for_legacy_attributes
(
&
mut
hints
)
;
!
hints
.
is_empty
(
)
}
fn
have_same_class
<
E
:
TElement
>
(
element
:
&
E
candidate
:
&
mut
StyleSharingCandidate
<
E
>
candidate_element
:
&
E
)
-
>
bool
{
let
mut
element_class_attributes
=
vec
!
[
]
;
element
.
each_class
(
|
c
|
element_class_attributes
.
push
(
c
.
clone
(
)
)
)
;
if
candidate
.
class_attributes
.
is_none
(
)
{
let
mut
attrs
=
vec
!
[
]
;
candidate_element
.
each_class
(
|
c
|
attrs
.
push
(
c
.
clone
(
)
)
)
;
candidate
.
class_attributes
=
Some
(
attrs
)
}
element_class_attributes
=
=
*
candidate
.
class_attributes
.
as_ref
(
)
.
unwrap
(
)
}
#
[
inline
]
fn
revalidate
<
E
:
TElement
>
(
element
:
&
E
candidate
:
&
mut
StyleSharingCandidate
<
E
>
candidate_element
:
&
E
shared
:
&
SharedStyleContext
bloom
:
&
BloomFilter
info
:
&
mut
CurrentElementInfo
selector_flags_map
:
&
mut
SelectorFlagsMap
<
E
>
)
-
>
bool
{
let
stylist
=
&
shared
.
stylist
;
if
info
.
revalidation_match_results
.
is_none
(
)
{
let
mut
set_selector_flags
=
|
el
:
&
E
flags
:
ElementSelectorFlags
|
{
element
.
apply_selector_flags
(
selector_flags_map
el
flags
)
;
}
;
info
.
revalidation_match_results
=
Some
(
stylist
.
match_revalidation_selectors
(
element
bloom
&
mut
set_selector_flags
)
)
;
}
if
candidate
.
revalidation_match_results
.
is_none
(
)
{
candidate
.
revalidation_match_results
=
Some
(
stylist
.
match_revalidation_selectors
(
candidate_element
bloom
&
mut
|
_
_
|
{
}
)
)
;
}
let
for_element
=
info
.
revalidation_match_results
.
as_ref
(
)
.
unwrap
(
)
;
let
for_candidate
=
candidate
.
revalidation_match_results
.
as_ref
(
)
.
unwrap
(
)
;
debug_assert
!
(
for_element
.
len
(
)
=
=
for_candidate
.
len
(
)
)
;
for_element
=
=
for_candidate
}
static
STYLE_SHARING_CANDIDATE_CACHE_SIZE
:
usize
=
8
;
impl
<
E
:
TElement
>
StyleSharingCandidateCache
<
E
>
{
pub
fn
new
(
)
-
>
Self
{
StyleSharingCandidateCache
{
cache
:
LRUCache
:
:
new
(
STYLE_SHARING_CANDIDATE_CACHE_SIZE
)
}
}
pub
fn
num_entries
(
&
self
)
-
>
usize
{
self
.
cache
.
num_entries
(
)
}
fn
iter_mut
(
&
mut
self
)
-
>
LRUCacheMutIterator
<
StyleSharingCandidate
<
E
>
>
{
self
.
cache
.
iter_mut
(
)
}
pub
fn
insert_if_possible
(
&
mut
self
element
:
&
E
style
:
&
Arc
<
ComputedValues
>
relations
:
StyleRelations
revalidation_match_results
:
Option
<
BitVec
>
)
{
let
parent
=
match
element
.
parent_element
(
)
{
Some
(
element
)
=
>
element
None
=
>
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
no
parent
element
"
)
;
return
;
}
}
;
if
!
relations_are_shareable
(
&
relations
)
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
{
:
?
}
"
relations
)
;
return
;
}
if
cfg
!
(
debug_assertions
)
{
let
mut
hints
=
ForgetfulSink
:
:
new
(
)
;
element
.
synthesize_presentational_hints_for_legacy_attributes
(
&
mut
hints
)
;
debug_assert
!
(
hints
.
is_empty
(
)
"
Style
relations
should
not
be
shareable
!
"
)
;
}
let
box_style
=
style
.
get_box
(
)
;
if
box_style
.
specifies_transitions
(
)
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
transitions
"
)
;
return
;
}
if
box_style
.
specifies_animations
(
)
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
animations
"
)
;
return
;
}
debug
!
(
"
Inserting
into
cache
:
{
:
?
}
with
parent
{
:
?
}
"
element
parent
)
;
self
.
cache
.
insert
(
StyleSharingCandidate
{
element
:
unsafe
{
SendElement
:
:
new
(
*
element
)
}
class_attributes
:
None
revalidation_match_results
:
revalidation_match_results
}
)
;
}
pub
fn
touch
(
&
mut
self
index
:
usize
)
{
self
.
cache
.
touch
(
index
)
;
}
pub
fn
clear
(
&
mut
self
)
{
self
.
cache
.
evict_all
(
)
}
}
pub
enum
StyleSharingResult
{
CannotShare
StyleWasShared
(
usize
)
}
trait
PrivateMatchMethods
:
TElement
{
fn
layout_parent
(
&
self
)
-
>
Self
{
let
mut
current
=
self
.
clone
(
)
;
loop
{
current
=
match
current
.
parent_element
(
)
{
Some
(
el
)
=
>
el
None
=
>
return
current
}
;
let
is_display_contents
=
current
.
borrow_data
(
)
.
unwrap
(
)
.
styles
(
)
.
primary
.
values
(
)
.
is_display_contents
(
)
;
if
!
is_display_contents
{
return
current
;
}
}
}
fn
cascade_with_rules
(
&
self
shared_context
:
&
SharedStyleContext
font_metrics_provider
:
&
FontMetricsProvider
rule_node
:
&
StrongRuleNode
primary_style
:
&
ComputedStyle
is_pseudo
:
bool
)
-
>
Arc
<
ComputedValues
>
{
let
mut
cascade_info
=
CascadeInfo
:
:
new
(
)
;
let
mut
cascade_flags
=
CascadeFlags
:
:
empty
(
)
;
if
self
.
skip_root_and_item_based_display_fixup
(
)
{
cascade_flags
.
insert
(
SKIP_ROOT_AND_ITEM_BASED_DISPLAY_FIXUP
)
}
let
parent_el
;
let
parent_data
;
let
style_to_inherit_from
=
if
!
is_pseudo
{
parent_el
=
self
.
parent_element
(
)
;
parent_data
=
parent_el
.
as_ref
(
)
.
and_then
(
|
e
|
e
.
borrow_data
(
)
)
;
let
parent_values
=
parent_data
.
as_ref
(
)
.
map
(
|
d
|
{
debug_assert
!
(
cfg
!
(
feature
=
"
gecko
"
)
|
|
d
.
has_current_styles
(
)
)
;
d
.
styles
(
)
.
primary
.
values
(
)
}
)
;
parent_values
}
else
{
parent_el
=
Some
(
self
.
clone
(
)
)
;
Some
(
primary_style
.
values
(
)
)
}
;
let
mut
layout_parent_el
=
parent_el
.
clone
(
)
;
let
layout_parent_data
;
let
mut
layout_parent_style
=
style_to_inherit_from
;
if
style_to_inherit_from
.
map_or
(
false
|
s
|
s
.
is_display_contents
(
)
)
{
layout_parent_el
=
Some
(
layout_parent_el
.
unwrap
(
)
.
layout_parent
(
)
)
;
layout_parent_data
=
layout_parent_el
.
as_ref
(
)
.
unwrap
(
)
.
borrow_data
(
)
.
unwrap
(
)
;
layout_parent_style
=
Some
(
layout_parent_data
.
styles
(
)
.
primary
.
values
(
)
)
}
let
style_to_inherit_from
=
style_to_inherit_from
.
map
(
|
x
|
&
*
*
x
)
;
let
layout_parent_style
=
layout_parent_style
.
map
(
|
x
|
&
*
*
x
)
;
if
!
is_pseudo
{
if
let
Some
(
ref
p
)
=
layout_parent_style
{
let
can_be_fragmented
=
p
.
is_multicol
(
)
|
|
layout_parent_el
.
as_ref
(
)
.
unwrap
(
)
.
as_node
(
)
.
can_be_fragmented
(
)
;
unsafe
{
self
.
as_node
(
)
.
set_can_be_fragmented
(
can_be_fragmented
)
;
}
}
}
let
values
=
Arc
:
:
new
(
cascade
(
&
shared_context
.
stylist
.
device
rule_node
&
shared_context
.
guards
style_to_inherit_from
layout_parent_style
Some
(
&
mut
cascade_info
)
&
*
shared_context
.
error_reporter
font_metrics_provider
cascade_flags
)
)
;
cascade_info
.
finish
(
&
self
.
as_node
(
)
)
;
values
}
fn
cascade_internal
(
&
self
context
:
&
StyleContext
<
Self
>
primary_style
:
&
ComputedStyle
pseudo_style
:
Option
<
&
ComputedStyle
>
)
-
>
Arc
<
ComputedValues
>
{
let
rule_node
=
&
pseudo_style
.
unwrap_or
(
primary_style
)
.
rules
;
self
.
cascade_with_rules
(
context
.
shared
&
context
.
thread_local
.
font_metrics_provider
rule_node
primary_style
pseudo_style
.
is_some
(
)
)
}
fn
cascade_primary_or_pseudo
(
&
self
context
:
&
mut
StyleContext
<
Self
>
data
:
&
mut
ElementData
pseudo
:
Option
<
&
PseudoElement
>
animate
:
bool
)
{
let
(
mut
styles
restyle
)
=
data
.
styles_and_restyle_mut
(
)
;
let
mut
primary_style
=
&
mut
styles
.
primary
;
let
pseudos
=
&
mut
styles
.
pseudos
;
let
mut
pseudo_style
=
match
pseudo
{
Some
(
p
)
=
>
{
let
style
=
pseudos
.
get_mut
(
p
)
;
debug_assert
!
(
style
.
is_some
(
)
)
;
style
}
None
=
>
None
}
;
let
mut
old_values
=
match
pseudo_style
{
Some
(
ref
mut
s
)
=
>
s
.
values
.
take
(
)
None
=
>
primary_style
.
values
.
take
(
)
}
;
let
mut
new_values
=
self
.
cascade_internal
(
context
primary_style
pseudo_style
.
as_ref
(
)
.
map
(
|
s
|
&
*
*
s
)
)
;
if
animate
&
&
!
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
{
self
.
process_animations
(
context
&
mut
old_values
&
mut
new_values
primary_style
pseudo
pseudo_style
.
as_ref
(
)
.
map
(
|
s
|
&
*
*
s
)
)
;
}
if
let
Some
(
old
)
=
old_values
{
self
.
accumulate_damage
(
&
context
.
shared
restyle
.
unwrap
(
)
&
old
&
new_values
pseudo
)
;
}
let
mut
relevant_style
=
pseudo_style
.
unwrap_or
(
primary_style
)
;
relevant_style
.
values
=
Some
(
new_values
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
get_after_change_style
(
&
self
context
:
&
mut
StyleContext
<
Self
>
primary_style
:
&
ComputedStyle
pseudo_style
:
Option
<
&
ComputedStyle
>
)
-
>
Option
<
Arc
<
ComputedValues
>
>
{
let
relevant_style
=
pseudo_style
.
unwrap_or
(
primary_style
)
;
let
rule_node
=
&
relevant_style
.
rules
;
let
without_transition_rules
=
context
.
shared
.
stylist
.
rule_tree
.
remove_transition_rule_if_applicable
(
rule_node
)
;
if
without_transition_rules
=
=
*
rule_node
{
return
None
;
}
Some
(
self
.
cascade_with_rules
(
context
.
shared
&
context
.
thread_local
.
font_metrics_provider
&
without_transition_rules
primary_style
pseudo_style
.
is_some
(
)
)
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
needs_animations_update
(
&
self
old_values
:
&
Option
<
Arc
<
ComputedValues
>
>
new_values
:
&
Arc
<
ComputedValues
>
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
bool
{
let
ref
new_box_style
=
new_values
.
get_box
(
)
;
let
has_new_animation_style
=
new_box_style
.
animation_name_count
(
)
>
=
1
&
&
new_box_style
.
animation_name_at
(
0
)
.
0
.
len
(
)
!
=
0
;
let
has_animations
=
self
.
has_css_animations
(
pseudo
)
;
old_values
.
as_ref
(
)
.
map_or
(
has_new_animation_style
|
ref
old
|
{
let
ref
old_box_style
=
old
.
get_box
(
)
;
let
old_display_style
=
old_box_style
.
clone_display
(
)
;
let
new_display_style
=
new_box_style
.
clone_display
(
)
;
!
old_box_style
.
animations_equals
(
&
new_box_style
)
|
|
(
old_display_style
=
=
display
:
:
T
:
:
none
&
&
new_display_style
!
=
display
:
:
T
:
:
none
&
&
has_new_animation_style
)
|
|
(
old_display_style
!
=
display
:
:
T
:
:
none
&
&
new_display_style
=
=
display
:
:
T
:
:
none
&
&
has_animations
)
}
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
process_animations
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
&
mut
Option
<
Arc
<
ComputedValues
>
>
new_values
:
&
mut
Arc
<
ComputedValues
>
primary_style
:
&
ComputedStyle
pseudo
:
Option
<
&
PseudoElement
>
pseudo_style
:
Option
<
&
ComputedStyle
>
)
{
use
context
:
:
{
CSS_ANIMATIONS
CSS_TRANSITIONS
EFFECT_PROPERTIES
}
;
use
context
:
:
UpdateAnimationsTasks
;
debug_assert_eq
!
(
pseudo
.
is_some
(
)
pseudo_style
.
is_some
(
)
)
;
let
mut
tasks
=
UpdateAnimationsTasks
:
:
empty
(
)
;
if
self
.
needs_animations_update
(
old_values
new_values
pseudo
)
{
tasks
.
insert
(
CSS_ANIMATIONS
)
;
}
let
before_change_style
=
if
self
.
might_need_transitions_update
(
&
old_values
.
as_ref
(
)
new_values
pseudo
)
{
let
after_change_style
=
if
self
.
has_css_transitions
(
pseudo
)
{
self
.
get_after_change_style
(
context
primary_style
pseudo_style
)
}
else
{
None
}
;
let
needs_transitions_update
=
{
let
after_change_style_ref
=
match
after_change_style
{
Some
(
ref
value
)
=
>
value
None
=
>
&
new_values
}
;
self
.
needs_transitions_update
(
old_values
.
as_ref
(
)
.
unwrap
(
)
after_change_style_ref
pseudo
)
}
;
if
needs_transitions_update
{
if
let
Some
(
values_without_transitions
)
=
after_change_style
{
*
new_values
=
values_without_transitions
;
}
tasks
.
insert
(
CSS_TRANSITIONS
)
;
old_values
.
clone
(
)
}
else
{
None
}
}
else
{
None
}
;
if
self
.
has_animations
(
pseudo
)
{
tasks
.
insert
(
EFFECT_PROPERTIES
)
;
}
if
!
tasks
.
is_empty
(
)
{
let
task
=
:
:
context
:
:
SequentialTask
:
:
update_animations
(
*
self
pseudo
.
cloned
(
)
before_change_style
tasks
)
;
context
.
thread_local
.
tasks
.
push
(
task
)
;
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
process_animations
(
&
self
context
:
&
mut
StyleContext
<
Self
>
old_values
:
&
mut
Option
<
Arc
<
ComputedValues
>
>
new_values
:
&
mut
Arc
<
ComputedValues
>
_primary_style
:
&
ComputedStyle
pseudo
:
Option
<
&
PseudoElement
>
pseudo_style
:
Option
<
&
ComputedStyle
>
)
{
debug_assert_eq
!
(
pseudo
.
is_some
(
)
pseudo_style
.
is_some
(
)
)
;
let
possibly_expired_animations
=
&
mut
context
.
thread_local
.
current_element_info
.
as_mut
(
)
.
unwrap
(
)
.
possibly_expired_animations
;
let
shared_context
=
context
.
shared
;
if
let
Some
(
ref
mut
old
)
=
*
old_values
{
self
.
update_animations_for_cascade
(
shared_context
old
possibly_expired_animations
&
context
.
thread_local
.
font_metrics_provider
)
;
}
let
new_animations_sender
=
&
context
.
thread_local
.
new_animations_sender
;
let
this_opaque
=
self
.
as_node
(
)
.
opaque
(
)
;
animation
:
:
maybe_start_animations
(
&
shared_context
new_animations_sender
this_opaque
&
new_values
)
;
if
let
Some
(
ref
values
)
=
*
old_values
{
animation
:
:
start_transitions_if_applicable
(
new_animations_sender
this_opaque
self
.
as_node
(
)
.
to_unsafe
(
)
&
*
*
values
new_values
&
shared_context
.
timer
&
possibly_expired_animations
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
accumulate_damage
(
&
self
shared_context
:
&
SharedStyleContext
restyle
:
&
mut
RestyleData
old_values
:
&
Arc
<
ComputedValues
>
new_values
:
&
Arc
<
ComputedValues
>
pseudo
:
Option
<
&
PseudoElement
>
)
{
if
shared_context
.
traversal_flags
.
for_reconstruct
(
)
{
return
;
}
if
restyle
.
damage_handled
.
contains
(
RestyleDamage
:
:
reconstruct
(
)
)
{
restyle
.
damage
=
RestyleDamage
:
:
empty
(
)
;
return
;
}
if
!
restyle
.
damage
.
contains
(
RestyleDamage
:
:
reconstruct
(
)
)
{
let
new_damage
=
self
.
compute_restyle_damage
(
&
old_values
&
new_values
pseudo
)
;
if
!
restyle
.
damage_handled
.
contains
(
new_damage
)
{
restyle
.
damage
|
=
new_damage
;
}
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
accumulate_damage
(
&
self
_shared_context
:
&
SharedStyleContext
restyle
:
&
mut
RestyleData
old_values
:
&
Arc
<
ComputedValues
>
new_values
:
&
Arc
<
ComputedValues
>
pseudo
:
Option
<
&
PseudoElement
>
)
{
if
restyle
.
damage
!
=
RestyleDamage
:
:
rebuild_and_reflow
(
)
{
let
d
=
self
.
compute_restyle_damage
(
&
old_values
&
new_values
pseudo
)
;
restyle
.
damage
|
=
d
;
}
}
fn
update_animations_for_cascade
(
&
self
context
:
&
SharedStyleContext
style
:
&
mut
Arc
<
ComputedValues
>
possibly_expired_animations
:
&
mut
Vec
<
PropertyAnimation
>
font_metrics
:
&
FontMetricsProvider
)
{
let
this_opaque
=
self
.
as_node
(
)
.
opaque
(
)
;
animation
:
:
complete_expired_transitions
(
this_opaque
style
context
)
;
let
had_running_animations
=
context
.
running_animations
.
read
(
)
.
get
(
&
this_opaque
)
.
is_some
(
)
;
if
had_running_animations
{
let
mut
all_running_animations
=
context
.
running_animations
.
write
(
)
;
for
running_animation
in
all_running_animations
.
get_mut
(
&
this_opaque
)
.
unwrap
(
)
{
if
!
running_animation
.
is_expired
(
)
{
animation
:
:
update_style_for_animation
(
context
running_animation
style
font_metrics
)
;
if
let
Animation
:
:
Transition
(
_
_
_
ref
frame
_
)
=
*
running_animation
{
possibly_expired_animations
.
push
(
frame
.
property_animation
.
clone
(
)
)
}
}
}
}
}
fn
share_style_with_candidate_if_possible
(
&
self
candidate
:
&
mut
StyleSharingCandidate
<
Self
>
shared
:
&
SharedStyleContext
bloom
:
&
BloomFilter
info
:
&
mut
CurrentElementInfo
selector_flags_map
:
&
mut
SelectorFlagsMap
<
Self
>
)
-
>
Result
<
ComputedStyle
CacheMiss
>
{
let
candidate_element
=
*
candidate
.
element
;
element_matches_candidate
(
self
candidate
&
candidate_element
shared
bloom
info
selector_flags_map
)
}
}
fn
compute_rule_node
<
E
:
TElement
>
(
rule_tree
:
&
RuleTree
applicable_declarations
:
&
mut
Vec
<
ApplicableDeclarationBlock
>
)
-
>
StrongRuleNode
{
let
rules
=
applicable_declarations
.
drain
(
.
.
)
.
map
(
|
d
|
(
d
.
source
d
.
level
)
)
;
let
rule_node
=
rule_tree
.
insert_ordered_rules
(
rules
)
;
rule_node
}
impl
<
E
:
TElement
>
PrivateMatchMethods
for
E
{
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
StyleSharingBehavior
{
Allow
Disallow
}
pub
trait
MatchMethods
:
TElement
{
fn
match_and_cascade
(
&
self
context
:
&
mut
StyleContext
<
Self
>
data
:
&
mut
ElementData
sharing
:
StyleSharingBehavior
)
{
let
mut
primary_relations
=
StyleRelations
:
:
empty
(
)
;
let
_rule_node_changed
=
self
.
match_primary
(
context
data
&
mut
primary_relations
)
;
self
.
cascade_primary
(
context
data
)
;
if
!
data
.
styles
(
)
.
is_display_none
(
)
{
let
_pseudo_rule_nodes_changed
=
self
.
match_pseudos
(
context
data
)
;
self
.
cascade_pseudos
(
context
data
)
;
}
if
!
data
.
styles
(
)
.
pseudos
.
is_empty
(
)
{
primary_relations
|
=
AFFECTED_BY_PSEUDO_ELEMENTS
;
}
if
sharing
=
=
StyleSharingBehavior
:
:
Allow
{
let
revalidation_match_results
=
context
.
thread_local
.
current_element_info
.
as_mut
(
)
.
unwrap
(
)
.
revalidation_match_results
.
take
(
)
;
context
.
thread_local
.
style_sharing_candidate_cache
.
insert_if_possible
(
self
data
.
styles
(
)
.
primary
.
values
(
)
primary_relations
revalidation_match_results
)
;
}
}
fn
cascade_primary_and_pseudos
(
&
self
context
:
&
mut
StyleContext
<
Self
>
mut
data
:
&
mut
ElementData
)
{
self
.
cascade_primary
(
context
&
mut
data
)
;
self
.
cascade_pseudos
(
context
&
mut
data
)
;
}
fn
match_primary
(
&
self
context
:
&
mut
StyleContext
<
Self
>
data
:
&
mut
ElementData
relations
:
&
mut
StyleRelations
)
-
>
bool
{
let
mut
applicable_declarations
=
Vec
:
:
<
ApplicableDeclarationBlock
>
:
:
with_capacity
(
16
)
;
let
stylist
=
&
context
.
shared
.
stylist
;
let
style_attribute
=
self
.
style_attribute
(
)
;
let
animation_rules
=
self
.
get_animation_rules
(
None
)
;
let
mut
rule_nodes_changed
=
false
;
let
bloom
=
context
.
thread_local
.
bloom_filter
.
filter
(
)
;
let
map
=
&
mut
context
.
thread_local
.
selector_flags
;
let
mut
set_selector_flags
=
|
element
:
&
Self
flags
:
ElementSelectorFlags
|
{
self
.
apply_selector_flags
(
map
element
flags
)
;
}
;
*
relations
=
stylist
.
push_applicable_declarations
(
self
Some
(
bloom
)
style_attribute
animation_rules
None
&
context
.
shared
.
guards
&
mut
applicable_declarations
&
mut
set_selector_flags
)
;
let
primary_rule_node
=
compute_rule_node
:
:
<
Self
>
(
&
stylist
.
rule_tree
&
mut
applicable_declarations
)
;
if
!
data
.
has_styles
(
)
{
data
.
set_styles
(
ElementStyles
:
:
new
(
ComputedStyle
:
:
new_partial
(
primary_rule_node
)
)
)
;
rule_nodes_changed
=
true
;
}
else
if
data
.
styles
(
)
.
primary
.
rules
!
=
primary_rule_node
{
data
.
styles_mut
(
)
.
primary
.
rules
=
primary_rule_node
;
rule_nodes_changed
=
true
;
}
rule_nodes_changed
}
fn
match_pseudos
(
&
self
context
:
&
mut
StyleContext
<
Self
>
data
:
&
mut
ElementData
)
-
>
bool
{
let
mut
applicable_declarations
=
Vec
:
:
<
ApplicableDeclarationBlock
>
:
:
with_capacity
(
16
)
;
let
mut
rule_nodes_changed
=
false
;
let
map
=
&
mut
context
.
thread_local
.
selector_flags
;
let
mut
set_selector_flags
=
|
element
:
&
Self
flags
:
ElementSelectorFlags
|
{
self
.
apply_selector_flags
(
map
element
flags
)
;
}
;
let
stylist
=
&
context
.
shared
.
stylist
;
let
guards
=
&
context
.
shared
.
guards
;
let
rule_tree
=
&
stylist
.
rule_tree
;
let
bloom_filter
=
context
.
thread_local
.
bloom_filter
.
filter
(
)
;
let
mut
matches_different_pseudos
=
false
;
SelectorImpl
:
:
each_eagerly_cascaded_pseudo_element
(
|
pseudo
|
{
let
mut
pseudos
=
&
mut
data
.
styles_mut
(
)
.
pseudos
;
debug_assert
!
(
applicable_declarations
.
is_empty
(
)
)
;
let
pseudo_animation_rules
=
if
pseudo
.
is_before_or_after
(
)
{
self
.
get_animation_rules
(
Some
(
&
pseudo
)
)
}
else
{
AnimationRules
(
None
None
)
}
;
stylist
.
push_applicable_declarations
(
self
Some
(
bloom_filter
)
None
pseudo_animation_rules
Some
(
&
pseudo
)
&
guards
&
mut
applicable_declarations
&
mut
set_selector_flags
)
;
if
!
applicable_declarations
.
is_empty
(
)
{
let
new_rules
=
compute_rule_node
:
:
<
Self
>
(
rule_tree
&
mut
applicable_declarations
)
;
if
pseudos
.
has
(
&
pseudo
)
{
rule_nodes_changed
=
pseudos
.
set_rules
(
&
pseudo
new_rules
)
;
}
else
{
pseudos
.
insert
(
&
pseudo
ComputedStyle
:
:
new_partial
(
new_rules
)
)
;
matches_different_pseudos
=
true
;
}
}
else
if
pseudos
.
take
(
&
pseudo
)
.
is_some
(
)
{
matches_different_pseudos
=
true
;
}
}
)
;
if
matches_different_pseudos
{
rule_nodes_changed
=
true
;
if
let
Some
(
r
)
=
data
.
get_restyle_mut
(
)
{
r
.
damage
|
=
RestyleDamage
:
:
reconstruct
(
)
;
}
}
rule_nodes_changed
}
fn
apply_selector_flags
(
&
self
map
:
&
mut
SelectorFlagsMap
<
Self
>
element
:
&
Self
flags
:
ElementSelectorFlags
)
{
let
self_flags
=
flags
.
for_self
(
)
;
if
!
self_flags
.
is_empty
(
)
{
if
element
=
=
self
{
unsafe
{
element
.
set_selector_flags
(
self_flags
)
;
}
}
else
{
if
!
element
.
has_selector_flags
(
self_flags
)
{
map
.
insert_flags
(
*
element
self_flags
)
;
}
}
}
let
parent_flags
=
flags
.
for_parent
(
)
;
if
!
parent_flags
.
is_empty
(
)
{
if
let
Some
(
p
)
=
element
.
parent_element
(
)
{
if
!
p
.
has_selector_flags
(
parent_flags
)
{
map
.
insert_flags
(
p
parent_flags
)
;
}
}
}
}
fn
replace_rules
(
&
self
hint
:
RestyleHint
context
:
&
StyleContext
<
Self
>
data
:
&
mut
AtomicRefMut
<
ElementData
>
)
-
>
bool
{
use
properties
:
:
PropertyDeclarationBlock
;
use
shared_lock
:
:
Locked
;
let
element_styles
=
&
mut
data
.
styles_mut
(
)
;
let
primary_rules
=
&
mut
element_styles
.
primary
.
rules
;
let
mut
rule_node_changed
=
false
;
{
let
mut
replace_rule_node
=
|
level
:
CascadeLevel
pdb
:
Option
<
&
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
path
:
&
mut
StrongRuleNode
|
{
let
new_node
=
context
.
shared
.
stylist
.
rule_tree
.
update_rule_at_level
(
level
pdb
path
&
context
.
shared
.
guards
)
;
if
let
Some
(
n
)
=
new_node
{
*
path
=
n
;
rule_node_changed
=
true
;
}
}
;
if
hint
.
intersects
(
RestyleHint
:
:
for_animations
(
)
)
{
debug_assert
!
(
context
.
shared
.
traversal_flags
.
for_animation_only
(
)
)
;
use
data
:
:
EagerPseudoStyles
;
let
mut
replace_rule_node_for_animation
=
|
level
:
CascadeLevel
primary_rules
:
&
mut
StrongRuleNode
pseudos
:
&
mut
EagerPseudoStyles
|
{
let
animation_rule
=
self
.
get_animation_rule_by_cascade
(
None
level
)
;
replace_rule_node
(
level
animation_rule
.
as_ref
(
)
primary_rules
)
;
for
pseudo
in
pseudos
.
keys
(
)
.
iter
(
)
.
filter
(
|
p
|
p
.
is_before_or_after
(
)
)
{
let
animation_rule
=
self
.
get_animation_rule_by_cascade
(
Some
(
&
pseudo
)
level
)
;
let
pseudo_rules
=
&
mut
pseudos
.
get_mut
(
&
pseudo
)
.
unwrap
(
)
.
rules
;
replace_rule_node
(
level
animation_rule
.
as_ref
(
)
pseudo_rules
)
;
}
}
;
let
pseudos
=
&
mut
element_styles
.
pseudos
;
if
hint
.
contains
(
RESTYLE_CSS_TRANSITIONS
)
{
replace_rule_node_for_animation
(
CascadeLevel
:
:
Transitions
primary_rules
pseudos
)
;
}
if
hint
.
contains
(
RESTYLE_CSS_ANIMATIONS
)
{
replace_rule_node_for_animation
(
CascadeLevel
:
:
Animations
primary_rules
pseudos
)
;
}
}
else
if
hint
.
contains
(
RESTYLE_STYLE_ATTRIBUTE
)
{
let
style_attribute
=
self
.
style_attribute
(
)
;
replace_rule_node
(
CascadeLevel
:
:
StyleAttributeNormal
style_attribute
primary_rules
)
;
replace_rule_node
(
CascadeLevel
:
:
StyleAttributeImportant
style_attribute
primary_rules
)
;
}
}
rule_node_changed
}
unsafe
fn
share_style_if_possible
(
&
self
context
:
&
mut
StyleContext
<
Self
>
data
:
&
mut
AtomicRefMut
<
ElementData
>
)
-
>
StyleSharingResult
{
if
context
.
shared
.
options
.
disable_style_sharing_cache
{
debug
!
(
"
{
:
?
}
Cannot
share
style
:
style
sharing
cache
disabled
"
self
)
;
return
StyleSharingResult
:
:
CannotShare
}
if
self
.
parent_element
(
)
.
is_none
(
)
{
debug
!
(
"
{
:
?
}
Cannot
share
style
:
element
has
style
attribute
"
self
)
;
return
StyleSharingResult
:
:
CannotShare
}
if
self
.
style_attribute
(
)
.
is_some
(
)
{
debug
!
(
"
{
:
?
}
Cannot
share
style
:
element
has
style
attribute
"
self
)
;
return
StyleSharingResult
:
:
CannotShare
}
if
self
.
has_attr
(
&
ns
!
(
)
&
local_name
!
(
"
id
"
)
)
{
debug
!
(
"
{
:
?
}
Cannot
share
style
:
element
has
id
"
self
)
;
return
StyleSharingResult
:
:
CannotShare
}
let
cache
=
&
mut
context
.
thread_local
.
style_sharing_candidate_cache
;
let
current_element_info
=
&
mut
context
.
thread_local
.
current_element_info
.
as_mut
(
)
.
unwrap
(
)
;
let
bloom
=
context
.
thread_local
.
bloom_filter
.
filter
(
)
;
let
selector_flags_map
=
&
mut
context
.
thread_local
.
selector_flags
;
let
mut
should_clear_cache
=
false
;
for
(
i
candidate
)
in
cache
.
iter_mut
(
)
.
enumerate
(
)
{
let
sharing_result
=
self
.
share_style_with_candidate_if_possible
(
candidate
&
context
.
shared
bloom
current_element_info
selector_flags_map
)
;
match
sharing_result
{
Ok
(
shared_style
)
=
>
{
debug_assert_eq
!
(
data
.
has_styles
(
)
data
.
has_restyle
(
)
)
;
let
old_values
=
data
.
get_styles_mut
(
)
.
and_then
(
|
s
|
s
.
primary
.
values
.
take
(
)
)
;
if
let
Some
(
old
)
=
old_values
{
self
.
accumulate_damage
(
&
context
.
shared
data
.
restyle_mut
(
)
&
old
shared_style
.
values
(
)
None
)
;
}
let
styles
=
ElementStyles
:
:
new
(
shared_style
)
;
data
.
set_styles
(
styles
)
;
return
StyleSharingResult
:
:
StyleWasShared
(
i
)
}
Err
(
miss
)
=
>
{
debug
!
(
"
Cache
miss
:
{
:
?
}
"
miss
)
;
match
miss
{
CacheMiss
:
:
Parent
=
>
{
should_clear_cache
=
true
;
break
;
}
CacheMiss
:
:
PresHints
|
CacheMiss
:
:
Revalidation
=
>
break
_
=
>
{
}
}
}
}
}
debug
!
(
"
{
:
?
}
Cannot
share
style
:
{
}
cache
entries
"
self
cache
.
num_entries
(
)
)
;
if
should_clear_cache
{
cache
.
clear
(
)
;
}
StyleSharingResult
:
:
CannotShare
}
fn
insert_into_bloom_filter
(
&
self
bf
:
&
mut
BloomFilter
)
{
bf
.
insert_hash
(
self
.
get_local_name
(
)
.
get_hash
(
)
)
;
bf
.
insert_hash
(
self
.
get_namespace
(
)
.
get_hash
(
)
)
;
if
let
Some
(
id
)
=
self
.
get_id
(
)
{
bf
.
insert_hash
(
id
.
get_hash
(
)
)
;
}
self
.
each_class
(
|
class
|
{
bf
.
insert_hash
(
class
.
get_hash
(
)
)
}
)
;
}
fn
remove_from_bloom_filter
(
&
self
bf
:
&
mut
BloomFilter
)
{
bf
.
remove_hash
(
self
.
get_local_name
(
)
.
get_hash
(
)
)
;
bf
.
remove_hash
(
self
.
get_namespace
(
)
.
get_hash
(
)
)
;
if
let
Some
(
id
)
=
self
.
get_id
(
)
{
bf
.
remove_hash
(
id
.
get_hash
(
)
)
;
}
self
.
each_class
(
|
class
|
{
bf
.
remove_hash
(
class
.
get_hash
(
)
)
}
)
;
}
fn
compute_restyle_damage
(
&
self
old_values
:
&
Arc
<
ComputedValues
>
new_values
:
&
Arc
<
ComputedValues
>
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
RestyleDamage
{
match
self
.
existing_style_for_restyle_damage
(
old_values
pseudo
)
{
Some
(
ref
source
)
=
>
RestyleDamage
:
:
compute
(
source
new_values
)
None
=
>
{
if
new_values
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
T
:
:
none
&
&
old_values
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
T
:
:
none
{
RestyleDamage
:
:
empty
(
)
}
else
{
RestyleDamage
:
:
reconstruct
(
)
}
}
}
}
fn
cascade_primary
(
&
self
context
:
&
mut
StyleContext
<
Self
>
mut
data
:
&
mut
ElementData
)
{
self
.
cascade_primary_or_pseudo
(
context
&
mut
data
None
true
)
;
}
fn
cascade_pseudos
(
&
self
context
:
&
mut
StyleContext
<
Self
>
mut
data
:
&
mut
ElementData
)
{
let
matched_pseudos
=
data
.
styles
(
)
.
pseudos
.
keys
(
)
;
for
pseudo
in
matched_pseudos
{
let
animate
=
pseudo
.
is_before_or_after
(
)
;
self
.
cascade_primary_or_pseudo
(
context
data
Some
(
&
pseudo
)
animate
)
;
}
}
fn
get_base_style
(
&
self
shared_context
:
&
SharedStyleContext
font_metrics_provider
:
&
FontMetricsProvider
primary_style
:
&
ComputedStyle
pseudo_style
:
Option
<
&
ComputedStyle
>
)
-
>
Arc
<
ComputedValues
>
{
let
relevant_style
=
pseudo_style
.
unwrap_or
(
primary_style
)
;
let
rule_node
=
&
relevant_style
.
rules
;
let
without_animation_rules
=
shared_context
.
stylist
.
rule_tree
.
remove_animation_and_transition_rules
(
rule_node
)
;
if
without_animation_rules
=
=
*
rule_node
{
return
relevant_style
.
values
.
as_ref
(
)
.
unwrap
(
)
.
clone
(
)
;
}
self
.
cascade_with_rules
(
shared_context
font_metrics_provider
&
without_animation_rules
primary_style
pseudo_style
.
is_some
(
)
)
}
}
impl
<
E
:
TElement
>
MatchMethods
for
E
{
}
