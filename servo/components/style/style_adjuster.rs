use
crate
:
:
computed_value_flags
:
:
ComputedValueFlags
;
use
crate
:
:
dom
:
:
TElement
;
use
crate
:
:
logical_geometry
:
:
PhysicalSide
;
use
crate
:
:
properties
:
:
longhands
:
:
display
:
:
computed_value
:
:
T
as
Display
;
use
crate
:
:
properties
:
:
longhands
:
:
float
:
:
computed_value
:
:
T
as
Float
;
use
crate
:
:
properties
:
:
longhands
:
:
position
:
:
computed_value
:
:
T
as
Position
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
properties
:
:
longhands
:
:
{
contain
:
:
computed_value
:
:
T
as
Contain
container_type
:
:
computed_value
:
:
T
as
ContainerType
content_visibility
:
:
computed_value
:
:
T
as
ContentVisibility
overflow_x
:
:
computed_value
:
:
T
as
Overflow
}
;
use
crate
:
:
properties
:
:
{
ComputedValues
StyleBuilder
}
;
use
crate
:
:
values
:
:
computed
:
:
position
:
:
{
PositionTryFallbacksTryTactic
PositionTryFallbacksTryTacticKeyword
TryTacticAdjustment
}
;
use
crate
:
:
values
:
:
specified
:
:
align
:
:
AlignFlags
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
selectors
:
:
parser
:
:
PseudoElement
;
pub
struct
StyleAdjuster
<
'
a
'
b
:
'
a
>
{
style
:
&
'
a
mut
StyleBuilder
<
'
b
>
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
is_topmost_svg_svg_element
<
E
>
(
e
:
E
)
-
>
bool
where
E
:
TElement
{
debug_assert
!
(
e
.
is_svg_element
(
)
)
;
if
e
.
local_name
(
)
!
=
&
*
atom
!
(
"
svg
"
)
{
return
false
;
}
let
parent
=
match
e
.
traversal_parent
(
)
{
Some
(
n
)
=
>
n
None
=
>
return
true
}
;
if
!
parent
.
is_svg_element
(
)
{
return
true
;
}
parent
.
local_name
(
)
=
=
&
*
atom
!
(
"
foreignObject
"
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
is_effective_display_none_for_display_contents
<
E
>
(
element
:
E
)
-
>
bool
where
E
:
TElement
{
use
crate
:
:
Atom
;
const
SPECIAL_HTML_ELEMENTS
:
[
Atom
;
16
]
=
[
atom
!
(
"
br
"
)
atom
!
(
"
wbr
"
)
atom
!
(
"
meter
"
)
atom
!
(
"
progress
"
)
atom
!
(
"
canvas
"
)
atom
!
(
"
embed
"
)
atom
!
(
"
object
"
)
atom
!
(
"
audio
"
)
atom
!
(
"
iframe
"
)
atom
!
(
"
img
"
)
atom
!
(
"
video
"
)
atom
!
(
"
frame
"
)
atom
!
(
"
frameset
"
)
atom
!
(
"
input
"
)
atom
!
(
"
textarea
"
)
atom
!
(
"
select
"
)
]
;
const
SPECIAL_SVG_ELEMENTS
:
[
Atom
;
6
]
=
[
atom
!
(
"
svg
"
)
atom
!
(
"
a
"
)
atom
!
(
"
g
"
)
atom
!
(
"
use
"
)
atom
!
(
"
tspan
"
)
atom
!
(
"
textPath
"
)
]
;
if
element
.
is_html_element
(
)
{
let
local_name
=
element
.
local_name
(
)
;
return
SPECIAL_HTML_ELEMENTS
.
iter
(
)
.
any
(
|
name
|
&
*
*
name
=
=
local_name
)
;
}
if
element
.
is_svg_element
(
)
{
if
is_topmost_svg_svg_element
(
element
)
{
return
true
;
}
let
local_name
=
element
.
local_name
(
)
;
return
!
SPECIAL_SVG_ELEMENTS
.
iter
(
)
.
any
(
|
name
|
&
*
*
name
=
=
local_name
)
;
}
if
element
.
is_mathml_element
(
)
{
return
true
;
}
false
}
impl
<
'
a
'
b
:
'
a
>
StyleAdjuster
<
'
a
'
b
>
{
#
[
inline
]
pub
fn
new
(
style
:
&
'
a
mut
StyleBuilder
<
'
b
>
)
-
>
Self
{
StyleAdjuster
{
style
}
}
fn
adjust_for_top_layer
(
&
mut
self
)
{
if
!
self
.
style
.
in_top_layer
(
)
{
return
;
}
if
!
self
.
style
.
is_absolutely_positioned
(
)
{
self
.
style
.
mutate_box
(
)
.
set_position
(
Position
:
:
Absolute
)
;
}
if
self
.
style
.
get_box
(
)
.
clone_display
(
)
.
is_contents
(
)
{
self
.
style
.
mutate_box
(
)
.
set_display
(
Display
:
:
Block
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_webkit_line_clamp
(
&
mut
self
)
{
use
crate
:
:
properties
:
:
longhands
:
:
_moz_box_orient
:
:
computed_value
:
:
T
as
BoxOrient
;
use
crate
:
:
values
:
:
specified
:
:
box_
:
:
{
DisplayInside
DisplayOutside
}
;
let
box_style
=
self
.
style
.
get_box
(
)
;
if
box_style
.
clone__webkit_line_clamp
(
)
.
is_none
(
)
{
return
;
}
let
disp
=
box_style
.
clone_display
(
)
;
if
disp
.
inside
(
)
!
=
DisplayInside
:
:
WebkitBox
{
return
;
}
if
self
.
style
.
get_xul
(
)
.
clone__moz_box_orient
(
)
!
=
BoxOrient
:
:
Vertical
{
return
;
}
let
new_display
=
if
disp
.
outside
(
)
=
=
DisplayOutside
:
:
Block
{
Display
:
:
FlowRoot
}
else
{
debug_assert_eq
!
(
disp
.
outside
(
)
DisplayOutside
:
:
Inline
)
;
Display
:
:
InlineBlock
}
;
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
new_display
false
)
;
}
fn
adjust_for_position
(
&
mut
self
)
{
if
self
.
style
.
is_absolutely_positioned
(
)
&
&
self
.
style
.
is_floating
(
)
{
self
.
style
.
mutate_box
(
)
.
set_float
(
Float
:
:
None
)
;
}
}
fn
skip_item_display_fixup
<
E
>
(
&
self
element
:
Option
<
E
>
)
-
>
bool
where
E
:
TElement
{
if
let
Some
(
pseudo
)
=
self
.
style
.
pseudo
{
return
pseudo
.
skip_item_display_fixup
(
)
;
}
element
.
is_some_and
(
|
e
|
e
.
skip_item_display_fixup
(
)
)
}
fn
blockify_if_necessary
<
E
>
(
&
mut
self
layout_parent_style
:
&
ComputedValues
element
:
Option
<
E
>
)
where
E
:
TElement
{
let
mut
blockify
=
false
;
macro_rules
!
blockify_if
{
(
if_what
:
expr
)
=
>
{
if
!
blockify
{
blockify
=
if_what
;
}
}
;
}
blockify_if
!
(
self
.
style
.
is_root_element
)
;
if
!
self
.
skip_item_display_fixup
(
element
)
{
let
parent_display
=
layout_parent_style
.
get_box
(
)
.
clone_display
(
)
;
blockify_if
!
(
parent_display
.
is_item_container
(
)
)
;
}
let
is_item_or_root
=
blockify
;
blockify_if
!
(
self
.
style
.
is_floating
(
)
)
;
blockify_if
!
(
self
.
style
.
is_absolutely_positioned
(
)
)
;
if
!
blockify
{
return
;
}
let
display
=
self
.
style
.
get_box
(
)
.
clone_display
(
)
;
let
blockified_display
=
display
.
equivalent_block_display
(
self
.
style
.
is_root_element
)
;
if
display
!
=
blockified_display
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
blockified_display
is_item_or_root
)
;
}
}
fn
set_bits
(
&
mut
self
)
{
let
box_style
=
self
.
style
.
get_box
(
)
;
let
display
=
box_style
.
clone_display
(
)
;
if
!
display
.
is_contents
(
)
{
if
!
self
.
style
.
get_text
(
)
.
clone_text_decoration_line
(
)
.
is_empty
(
)
{
self
.
style
.
add_flags
(
ComputedValueFlags
:
:
HAS_TEXT_DECORATION_LINES
)
;
}
if
self
.
style
.
get_effects
(
)
.
clone_opacity
(
)
=
=
0
.
{
self
.
style
.
add_flags
(
ComputedValueFlags
:
:
IS_IN_OPACITY_ZERO_SUBTREE
)
;
}
}
if
self
.
style
.
pseudo
.
is_some_and
(
|
p
|
p
.
is_first_line
(
)
)
{
self
.
style
.
add_flags
(
ComputedValueFlags
:
:
IS_IN_FIRST_LINE_SUBTREE
)
;
}
if
self
.
style
.
is_root_element
{
self
.
style
.
add_flags
(
ComputedValueFlags
:
:
IS_ROOT_ELEMENT_STYLE
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
if
box_style
.
clone_effective_containment
(
)
.
contains
(
Contain
:
:
STYLE
)
{
self
.
style
.
add_flags
(
ComputedValueFlags
:
:
SELF_OR_ANCESTOR_HAS_CONTAIN_STYLE
)
;
}
if
box_style
.
clone_container_type
(
)
.
is_size_container_type
(
)
{
self
.
style
.
add_flags
(
ComputedValueFlags
:
:
SELF_OR_ANCESTOR_HAS_SIZE_CONTAINER_TYPE
)
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
if
self
.
style
.
get_parent_column
(
)
.
is_multicol
(
)
{
self
.
style
.
add_flags
(
ComputedValueFlags
:
:
CAN_BE_FRAGMENTED
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
adjust_for_text
(
&
mut
self
)
{
debug_assert
!
(
!
self
.
style
.
is_root_element
)
;
self
.
adjust_for_text_combine_upright
(
)
;
self
.
adjust_for_text_in_ruby
(
)
;
self
.
set_bits
(
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_text_combine_upright
(
&
mut
self
)
{
use
crate
:
:
computed_values
:
:
text_combine_upright
:
:
T
as
TextCombineUpright
;
use
crate
:
:
computed_values
:
:
writing_mode
:
:
T
as
WritingMode
;
use
crate
:
:
logical_geometry
;
let
writing_mode
=
self
.
style
.
get_inherited_box
(
)
.
clone_writing_mode
(
)
;
let
text_combine_upright
=
self
.
style
.
get_inherited_text
(
)
.
clone_text_combine_upright
(
)
;
if
matches
!
(
writing_mode
WritingMode
:
:
VerticalRl
|
WritingMode
:
:
VerticalLr
)
&
&
text_combine_upright
=
=
TextCombineUpright
:
:
All
{
self
.
style
.
add_flags
(
ComputedValueFlags
:
:
IS_TEXT_COMBINED
)
;
self
.
style
.
mutate_inherited_box
(
)
.
set_writing_mode
(
WritingMode
:
:
HorizontalTb
)
;
self
.
style
.
writing_mode
=
logical_geometry
:
:
WritingMode
:
:
new
(
self
.
style
.
get_inherited_box
(
)
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_text_in_ruby
(
&
mut
self
)
{
let
parent_display
=
self
.
style
.
get_parent_box
(
)
.
clone_display
(
)
;
if
parent_display
.
is_ruby_type
(
)
|
|
self
.
style
.
get_parent_flags
(
)
.
contains
(
ComputedValueFlags
:
:
SHOULD_SUPPRESS_LINEBREAK
)
{
self
.
style
.
add_flags
(
ComputedValueFlags
:
:
SHOULD_SUPPRESS_LINEBREAK
)
;
}
}
fn
adjust_for_writing_mode
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
let
our_writing_mode
=
self
.
style
.
get_inherited_box
(
)
.
clone_writing_mode
(
)
;
let
parent_writing_mode
=
layout_parent_style
.
get_inherited_box
(
)
.
clone_writing_mode
(
)
;
if
our_writing_mode
!
=
parent_writing_mode
&
&
self
.
style
.
get_box
(
)
.
clone_display
(
)
=
=
Display
:
:
Inline
{
if
cfg
!
(
feature
=
"
servo
"
)
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
Display
:
:
InlineBlock
false
)
;
}
else
{
self
.
style
.
mutate_box
(
)
.
set_display
(
Display
:
:
InlineBlock
)
;
}
}
}
fn
adjust_for_overflow
(
&
mut
self
)
{
let
overflow_x
=
self
.
style
.
get_box
(
)
.
clone_overflow_x
(
)
;
let
overflow_y
=
self
.
style
.
get_box
(
)
.
clone_overflow_y
(
)
;
if
overflow_x
=
=
overflow_y
{
return
;
}
if
overflow_x
.
is_scrollable
(
)
!
=
overflow_y
.
is_scrollable
(
)
{
let
box_style
=
self
.
style
.
mutate_box
(
)
;
box_style
.
set_overflow_x
(
overflow_x
.
to_scrollable
(
)
)
;
box_style
.
set_overflow_y
(
overflow_y
.
to_scrollable
(
)
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_contain
(
&
mut
self
)
{
let
box_style
=
self
.
style
.
get_box
(
)
;
let
container_type
=
box_style
.
clone_container_type
(
)
;
let
content_visibility
=
box_style
.
clone_content_visibility
(
)
;
if
!
container_type
.
is_size_container_type
(
)
&
&
content_visibility
=
=
ContentVisibility
:
:
Visible
{
debug_assert_eq
!
(
box_style
.
clone_contain
(
)
box_style
.
clone_effective_containment
(
)
)
;
return
;
}
let
old_contain
=
box_style
.
clone_contain
(
)
;
let
mut
new_contain
=
old_contain
;
match
content_visibility
{
ContentVisibility
:
:
Visible
=
>
{
}
ContentVisibility
:
:
Auto
=
>
{
new_contain
.
insert
(
Contain
:
:
LAYOUT
|
Contain
:
:
PAINT
|
Contain
:
:
STYLE
)
}
ContentVisibility
:
:
Hidden
=
>
new_contain
.
insert
(
Contain
:
:
LAYOUT
|
Contain
:
:
PAINT
|
Contain
:
:
SIZE
|
Contain
:
:
STYLE
)
}
if
container_type
.
intersects
(
ContainerType
:
:
INLINE_SIZE
)
{
new_contain
.
insert
(
Contain
:
:
STYLE
|
Contain
:
:
INLINE_SIZE
)
;
}
else
if
container_type
.
intersects
(
ContainerType
:
:
SIZE
)
{
new_contain
.
insert
(
Contain
:
:
STYLE
|
Contain
:
:
SIZE
)
;
}
if
new_contain
=
=
old_contain
{
debug_assert_eq
!
(
box_style
.
clone_contain
(
)
box_style
.
clone_effective_containment
(
)
)
;
return
;
}
self
.
style
.
mutate_box
(
)
.
set_effective_containment
(
new_contain
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_contain_intrinsic_size
(
&
mut
self
)
{
let
content_visibility
=
self
.
style
.
get_box
(
)
.
clone_content_visibility
(
)
;
if
content_visibility
!
=
ContentVisibility
:
:
Auto
{
return
;
}
let
pos
=
self
.
style
.
get_position
(
)
;
let
new_width
=
pos
.
clone_contain_intrinsic_width
(
)
.
add_auto_if_needed
(
)
;
let
new_height
=
pos
.
clone_contain_intrinsic_height
(
)
.
add_auto_if_needed
(
)
;
if
new_width
.
is_none
(
)
&
&
new_height
.
is_none
(
)
{
return
;
}
let
pos
=
self
.
style
.
mutate_position
(
)
;
if
let
Some
(
width
)
=
new_width
{
pos
.
set_contain_intrinsic_width
(
width
)
;
}
if
let
Some
(
height
)
=
new_height
{
pos
.
set_contain_intrinsic_height
(
height
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_prohibited_display_contents
<
E
>
(
&
mut
self
element
:
Option
<
E
>
)
where
E
:
TElement
{
if
self
.
style
.
get_box
(
)
.
clone_display
(
)
!
=
Display
:
:
Contents
{
return
;
}
if
self
.
style
.
pseudo
.
is_some_and
(
|
p
|
!
p
.
is_element_backed
(
)
)
{
self
.
style
.
mutate_box
(
)
.
set_display
(
Display
:
:
Inline
)
;
return
;
}
let
element
=
match
element
{
Some
(
e
)
=
>
e
None
=
>
return
}
;
if
is_effective_display_none_for_display_contents
(
element
)
{
self
.
style
.
mutate_box
(
)
.
set_display
(
Display
:
:
None
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_text_control_editing_root
(
&
mut
self
)
{
use
crate
:
:
properties
:
:
longhands
:
:
white_space_collapse
:
:
computed_value
:
:
T
as
WhiteSpaceCollapse
;
use
crate
:
:
selector_parser
:
:
PseudoElement
;
if
self
.
style
.
pseudo
!
=
Some
(
&
PseudoElement
:
:
MozTextControlEditingRoot
)
{
return
;
}
let
old_collapse
=
self
.
style
.
get_inherited_text
(
)
.
clone_white_space_collapse
(
)
;
let
new_collapse
=
match
old_collapse
{
WhiteSpaceCollapse
:
:
Preserve
|
WhiteSpaceCollapse
:
:
BreakSpaces
=
>
old_collapse
WhiteSpaceCollapse
:
:
Collapse
|
WhiteSpaceCollapse
:
:
PreserveSpaces
|
WhiteSpaceCollapse
:
:
PreserveBreaks
=
>
WhiteSpaceCollapse
:
:
Preserve
}
;
if
new_collapse
!
=
old_collapse
{
self
.
style
.
mutate_inherited_text
(
)
.
set_white_space_collapse
(
new_collapse
)
;
}
let
box_style
=
self
.
style
.
get_box
(
)
;
let
overflow_x
=
box_style
.
clone_overflow_x
(
)
;
let
overflow_y
=
box_style
.
clone_overflow_y
(
)
;
if
overflow_x
.
is_scrollable
(
)
|
|
overflow_y
.
is_scrollable
(
)
{
return
;
}
let
box_style
=
self
.
style
.
mutate_box
(
)
;
box_style
.
set_overflow_x
(
Overflow
:
:
Auto
)
;
box_style
.
set_overflow_y
(
Overflow
:
:
Auto
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_fieldset_content
(
&
mut
self
)
{
use
crate
:
:
selector_parser
:
:
PseudoElement
;
if
self
.
style
.
pseudo
!
=
Some
(
&
PseudoElement
:
:
FieldsetContent
)
{
return
;
}
let
parent_display
=
self
.
style
.
get_parent_box
(
)
.
clone_display
(
)
;
debug_assert
!
(
!
parent_display
.
is_contents
(
)
"
How
did
we
create
a
fieldset
-
content
box
with
display
:
contents
?
"
)
;
let
new_display
=
match
parent_display
{
Display
:
:
Flex
|
Display
:
:
InlineFlex
=
>
Some
(
Display
:
:
Flex
)
Display
:
:
Grid
|
Display
:
:
InlineGrid
=
>
Some
(
Display
:
:
Grid
)
_
=
>
None
}
;
if
let
Some
(
new_display
)
=
new_display
{
self
.
style
.
mutate_box
(
)
.
set_display
(
new_display
)
;
}
}
fn
adjust_for_table_text_align
(
&
mut
self
)
{
use
crate
:
:
properties
:
:
longhands
:
:
text_align
:
:
computed_value
:
:
T
as
TextAlign
;
if
self
.
style
.
get_box
(
)
.
clone_display
(
)
!
=
Display
:
:
Table
{
return
;
}
match
self
.
style
.
get_inherited_text
(
)
.
clone_text_align
(
)
{
TextAlign
:
:
MozLeft
|
TextAlign
:
:
MozCenter
|
TextAlign
:
:
MozRight
=
>
{
}
_
=
>
return
}
self
.
style
.
mutate_inherited_text
(
)
.
set_text_align
(
TextAlign
:
:
Start
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
should_suppress_linebreak
<
E
>
(
&
self
element
:
Option
<
E
>
)
-
>
bool
where
E
:
TElement
{
if
self
.
style
.
is_floating
(
)
|
|
self
.
style
.
is_absolutely_positioned
(
)
{
return
false
;
}
let
parent_display
=
self
.
style
.
get_parent_box
(
)
.
clone_display
(
)
;
if
self
.
style
.
get_parent_flags
(
)
.
contains
(
ComputedValueFlags
:
:
SHOULD_SUPPRESS_LINEBREAK
)
{
if
parent_display
.
is_line_participant
(
)
|
|
parent_display
.
is_contents
(
)
{
return
true
;
}
}
match
self
.
style
.
get_box
(
)
.
clone_display
(
)
{
Display
:
:
RubyBase
|
Display
:
:
RubyText
=
>
true
Display
:
:
RubyBaseContainer
|
Display
:
:
RubyTextContainer
if
element
.
map_or
(
true
|
e
|
e
.
is_html_element
(
)
)
=
>
{
false
}
_
=
>
parent_display
.
is_ruby_type
(
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_ruby
<
E
>
(
&
mut
self
element
:
Option
<
E
>
)
where
E
:
TElement
{
use
crate
:
:
properties
:
:
longhands
:
:
unicode_bidi
:
:
computed_value
:
:
T
as
UnicodeBidi
;
let
self_display
=
self
.
style
.
get_box
(
)
.
clone_display
(
)
;
if
self
.
should_suppress_linebreak
(
element
)
{
self
.
style
.
add_flags
(
ComputedValueFlags
:
:
SHOULD_SUPPRESS_LINEBREAK
)
;
if
!
self
.
skip_item_display_fixup
(
element
)
{
let
inline_display
=
self_display
.
inlinify
(
)
;
if
self_display
!
=
inline_display
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
inline_display
false
)
;
}
}
}
if
self_display
.
is_ruby_level_container
(
)
{
self
.
style
.
reset_border_struct
(
)
;
self
.
style
.
reset_padding_struct
(
)
;
}
if
self_display
.
is_ruby_type
(
)
{
let
new_value
=
match
self
.
style
.
get_text
(
)
.
clone_unicode_bidi
(
)
{
UnicodeBidi
:
:
Normal
|
UnicodeBidi
:
:
Embed
=
>
Some
(
UnicodeBidi
:
:
Isolate
)
UnicodeBidi
:
:
BidiOverride
=
>
Some
(
UnicodeBidi
:
:
IsolateOverride
)
_
=
>
None
}
;
if
let
Some
(
new_value
)
=
new_value
{
self
.
style
.
mutate_text
(
)
.
set_unicode_bidi
(
new_value
)
;
}
}
}
fn
adjust_for_visited
<
E
>
(
&
mut
self
element
:
Option
<
E
>
)
where
E
:
TElement
{
if
!
self
.
style
.
has_visited_style
(
)
{
return
;
}
let
is_link_element
=
self
.
style
.
pseudo
.
is_none
(
)
&
&
element
.
map_or
(
false
|
e
|
e
.
is_link
(
)
)
;
if
!
is_link_element
{
return
;
}
if
element
.
unwrap
(
)
.
is_visited_link
(
)
{
self
.
style
.
add_flags
(
ComputedValueFlags
:
:
IS_RELEVANT_LINK_VISITED
)
;
}
else
{
self
.
style
.
remove_flags
(
ComputedValueFlags
:
:
IS_RELEVANT_LINK_VISITED
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_justify_items
(
&
mut
self
)
{
use
crate
:
:
values
:
:
specified
:
:
align
;
let
justify_items
=
self
.
style
.
get_position
(
)
.
clone_justify_items
(
)
;
if
justify_items
.
specified
!
=
align
:
:
JustifyItems
:
:
legacy
(
)
{
return
;
}
let
parent_justify_items
=
self
.
style
.
get_parent_position
(
)
.
clone_justify_items
(
)
;
if
!
parent_justify_items
.
computed
.
contains
(
AlignFlags
:
:
LEGACY
)
{
return
;
}
if
parent_justify_items
.
computed
=
=
justify_items
.
computed
{
return
;
}
self
.
style
.
mutate_position
(
)
.
set_computed_justify_items
(
parent_justify_items
.
computed
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_appearance
<
E
>
(
&
mut
self
element
:
Option
<
E
>
)
where
E
:
TElement
{
use
crate
:
:
properties
:
:
longhands
:
:
appearance
:
:
computed_value
:
:
T
as
Appearance
;
use
crate
:
:
properties
:
:
longhands
:
:
line_height
:
:
computed_value
:
:
T
as
LineHeight
;
let
box_
=
self
.
style
.
get_box
(
)
;
let
appearance
=
match
box_
.
clone_appearance
(
)
{
Appearance
:
:
Auto
=
>
box_
.
clone__moz_default_appearance
(
)
a
=
>
a
}
;
if
appearance
=
=
Appearance
:
:
Menulist
{
if
self
.
style
.
get_font
(
)
.
clone_line_height
(
)
=
=
LineHeight
:
:
normal
(
)
{
return
;
}
if
self
.
style
.
pseudo
.
is_some
(
)
{
return
;
}
let
is_html_select_element
=
element
.
map_or
(
false
|
e
|
{
e
.
is_html_element
(
)
&
&
e
.
local_name
(
)
=
=
&
*
atom
!
(
"
select
"
)
}
)
;
if
!
is_html_select_element
{
return
;
}
self
.
style
.
mutate_font
(
)
.
set_line_height
(
LineHeight
:
:
normal
(
)
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_marker_pseudo
(
&
mut
self
)
{
use
crate
:
:
values
:
:
computed
:
:
counters
:
:
Content
;
use
crate
:
:
values
:
:
computed
:
:
font
:
:
{
FontFamily
FontSynthesis
FontSynthesisStyle
}
;
use
crate
:
:
values
:
:
computed
:
:
text
:
:
{
LetterSpacing
WordSpacing
}
;
let
is_legacy_marker
=
self
.
style
.
pseudo
.
map_or
(
false
|
p
|
p
.
is_marker
(
)
)
&
&
self
.
style
.
get_list
(
)
.
clone_list_style_type
(
)
.
is_bullet
(
)
&
&
self
.
style
.
get_counters
(
)
.
clone_content
(
)
=
=
Content
:
:
Normal
;
if
!
is_legacy_marker
{
return
;
}
let
flags
=
self
.
style
.
flags
.
get
(
)
;
if
!
flags
.
contains
(
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_FONT_FAMILY
)
{
self
.
style
.
mutate_font
(
)
.
set_font_family
(
FontFamily
:
:
moz_bullet
(
)
.
clone
(
)
)
;
if
!
flags
.
contains
(
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_FONT_SYNTHESIS_WEIGHT
)
{
self
.
style
.
mutate_font
(
)
.
set_font_synthesis_weight
(
FontSynthesis
:
:
None
)
;
}
if
!
flags
.
contains
(
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_FONT_SYNTHESIS_STYLE
)
{
self
.
style
.
mutate_font
(
)
.
set_font_synthesis_style
(
FontSynthesisStyle
:
:
None
)
;
}
}
if
!
flags
.
contains
(
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_LETTER_SPACING
)
{
self
.
style
.
mutate_inherited_text
(
)
.
set_letter_spacing
(
LetterSpacing
:
:
normal
(
)
)
;
}
if
!
flags
.
contains
(
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_WORD_SPACING
)
{
self
.
style
.
mutate_inherited_text
(
)
.
set_word_spacing
(
WordSpacing
:
:
normal
(
)
)
;
}
}
fn
adjust_for_try_tactic
(
&
mut
self
tactic
:
&
PositionTryFallbacksTryTactic
)
{
debug_assert
!
(
!
tactic
.
is_empty
(
)
)
;
let
wm
=
self
.
style
.
writing_mode
;
for
tactic
in
tactic
.
iter
(
)
{
use
PositionTryFallbacksTryTacticKeyword
:
:
*
;
match
tactic
{
FlipBlock
=
>
{
self
.
flip_self_alignment
(
true
)
;
self
.
flip_insets_and_margins
(
wm
.
is_vertical
(
)
)
;
}
FlipInline
=
>
{
self
.
flip_self_alignment
(
false
)
;
self
.
flip_insets_and_margins
(
wm
.
is_horizontal
(
)
)
;
}
FlipX
=
>
{
self
.
flip_self_alignment
(
wm
.
is_vertical
(
)
)
;
self
.
flip_insets_and_margins
(
true
)
;
}
FlipY
=
>
{
self
.
flip_self_alignment
(
wm
.
is_horizontal
(
)
)
;
self
.
flip_insets_and_margins
(
false
)
;
}
FlipStart
=
>
{
self
.
flip_start
(
)
;
}
}
self
.
apply_position_area_tactic
(
*
tactic
)
;
}
}
fn
apply_position_area_tactic
(
&
mut
self
tactic
:
PositionTryFallbacksTryTacticKeyword
)
{
let
pos
=
self
.
style
.
get_position
(
)
;
let
old
=
pos
.
clone_position_area
(
)
;
let
wm
=
self
.
style
.
writing_mode
;
let
new
=
old
.
with_tactic
(
wm
tactic
)
;
if
new
=
=
old
{
return
;
}
let
pos
=
self
.
style
.
mutate_position
(
)
;
pos
.
set_position_area
(
new
)
;
}
fn
swap_insets
(
&
mut
self
a_side
:
PhysicalSide
b_side
:
PhysicalSide
)
{
debug_assert_ne
!
(
a_side
b_side
)
;
let
pos
=
self
.
style
.
mutate_position
(
)
;
let
mut
a
=
pos
.
get_inset
(
a_side
)
.
clone
(
)
;
a
.
try_tactic_adjustment
(
a_side
b_side
)
;
let
mut
b
=
pos
.
get_inset
(
b_side
)
.
clone
(
)
;
b
.
try_tactic_adjustment
(
b_side
a_side
)
;
pos
.
set_inset
(
a_side
b
)
;
pos
.
set_inset
(
b_side
a
)
;
}
fn
swap_margins
(
&
mut
self
a_side
:
PhysicalSide
b_side
:
PhysicalSide
)
{
debug_assert_ne
!
(
a_side
b_side
)
;
let
margin
=
self
.
style
.
get_margin
(
)
;
let
mut
a
=
margin
.
get_margin
(
a_side
)
.
clone
(
)
;
a
.
try_tactic_adjustment
(
a_side
b_side
)
;
let
mut
b
=
margin
.
get_margin
(
b_side
)
.
clone
(
)
;
b
.
try_tactic_adjustment
(
b_side
a_side
)
;
let
margin
=
self
.
style
.
mutate_margin
(
)
;
margin
.
set_margin
(
a_side
b
)
;
margin
.
set_margin
(
b_side
a
)
;
}
fn
swap_sizes
(
&
mut
self
block_start
:
PhysicalSide
inline_start
:
PhysicalSide
)
{
let
pos
=
self
.
style
.
mutate_position
(
)
;
let
mut
min_width
=
pos
.
clone_min_width
(
)
;
min_width
.
try_tactic_adjustment
(
inline_start
block_start
)
;
let
mut
max_width
=
pos
.
clone_max_width
(
)
;
max_width
.
try_tactic_adjustment
(
inline_start
block_start
)
;
let
mut
width
=
pos
.
clone_width
(
)
;
width
.
try_tactic_adjustment
(
inline_start
block_start
)
;
let
mut
min_height
=
pos
.
clone_min_height
(
)
;
min_height
.
try_tactic_adjustment
(
block_start
inline_start
)
;
let
mut
max_height
=
pos
.
clone_max_height
(
)
;
max_height
.
try_tactic_adjustment
(
block_start
inline_start
)
;
let
mut
height
=
pos
.
clone_height
(
)
;
height
.
try_tactic_adjustment
(
block_start
inline_start
)
;
let
pos
=
self
.
style
.
mutate_position
(
)
;
pos
.
set_width
(
height
)
;
pos
.
set_height
(
width
)
;
pos
.
set_max_width
(
max_height
)
;
pos
.
set_max_height
(
max_width
)
;
pos
.
set_min_width
(
min_height
)
;
pos
.
set_min_height
(
min_width
)
;
}
fn
flip_start
(
&
mut
self
)
{
let
wm
=
self
.
style
.
writing_mode
;
let
bs
=
wm
.
block_start_physical_side
(
)
;
let
is
=
wm
.
inline_start_physical_side
(
)
;
let
be
=
wm
.
block_end_physical_side
(
)
;
let
ie
=
wm
.
inline_end_physical_side
(
)
;
self
.
swap_sizes
(
bs
is
)
;
self
.
swap_insets
(
bs
is
)
;
self
.
swap_insets
(
ie
be
)
;
self
.
swap_margins
(
bs
is
)
;
self
.
swap_margins
(
ie
be
)
;
self
.
flip_alignment_start
(
)
;
}
fn
flip_insets_and_margins
(
&
mut
self
horizontal
:
bool
)
{
if
horizontal
{
self
.
swap_insets
(
PhysicalSide
:
:
Left
PhysicalSide
:
:
Right
)
;
self
.
swap_margins
(
PhysicalSide
:
:
Left
PhysicalSide
:
:
Right
)
;
}
else
{
self
.
swap_insets
(
PhysicalSide
:
:
Top
PhysicalSide
:
:
Bottom
)
;
self
.
swap_margins
(
PhysicalSide
:
:
Top
PhysicalSide
:
:
Bottom
)
;
}
}
fn
flip_alignment_start
(
&
mut
self
)
{
let
pos
=
self
.
style
.
get_position
(
)
;
let
align
=
pos
.
clone_align_self
(
)
;
let
mut
justify
=
pos
.
clone_justify_self
(
)
;
if
align
=
=
justify
{
return
;
}
if
matches
!
(
justify
.
value
(
)
AlignFlags
:
:
LEFT
|
AlignFlags
:
:
RIGHT
)
{
let
left
=
justify
.
value
(
)
=
=
AlignFlags
:
:
LEFT
;
let
ltr
=
self
.
style
.
writing_mode
.
is_bidi_ltr
(
)
;
justify
=
justify
.
with_value
(
if
left
=
=
ltr
{
AlignFlags
:
:
SELF_START
}
else
{
AlignFlags
:
:
SELF_END
}
)
;
}
let
pos
=
self
.
style
.
mutate_position
(
)
;
pos
.
set_align_self
(
justify
)
;
pos
.
set_justify_self
(
align
)
;
}
fn
flip_self_alignment
(
&
mut
self
block
:
bool
)
{
let
pos
=
self
.
style
.
get_position
(
)
;
let
cur
=
if
block
{
pos
.
clone_align_self
(
)
}
else
{
pos
.
clone_justify_self
(
)
}
;
let
flipped
=
cur
.
flip_position
(
)
;
if
flipped
=
=
cur
{
return
;
}
let
pos
=
self
.
style
.
mutate_position
(
)
;
if
block
{
pos
.
set_align_self
(
flipped
)
;
}
else
{
pos
.
set_justify_self
(
flipped
)
;
}
}
pub
fn
adjust
<
E
>
(
&
mut
self
layout_parent_style
:
&
ComputedValues
element
:
Option
<
E
>
try_tactic
:
&
PositionTryFallbacksTryTactic
)
where
E
:
TElement
{
if
cfg
!
(
debug_assertions
)
{
if
let
Some
(
e
)
=
element
{
if
let
Some
(
p
)
=
e
.
implemented_pseudo_element
(
)
{
debug_assert
!
(
self
.
style
.
pseudo
.
is_some
(
)
"
Someone
really
messed
up
(
no
pseudo
style
for
{
e
:
?
}
{
p
:
?
}
)
"
)
;
}
}
}
self
.
adjust_for_visited
(
element
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_prohibited_display_contents
(
element
)
;
self
.
adjust_for_fieldset_content
(
)
;
self
.
adjust_for_text_control_editing_root
(
)
;
}
self
.
adjust_for_top_layer
(
)
;
self
.
blockify_if_necessary
(
layout_parent_style
element
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
self
.
adjust_for_webkit_line_clamp
(
)
;
self
.
adjust_for_position
(
)
;
self
.
adjust_for_overflow
(
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_contain
(
)
;
self
.
adjust_for_contain_intrinsic_size
(
)
;
self
.
adjust_for_justify_items
(
)
;
}
self
.
adjust_for_table_text_align
(
)
;
self
.
adjust_for_writing_mode
(
layout_parent_style
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_ruby
(
element
)
;
self
.
adjust_for_appearance
(
element
)
;
self
.
adjust_for_marker_pseudo
(
)
;
}
if
!
try_tactic
.
is_empty
(
)
{
self
.
adjust_for_try_tactic
(
try_tactic
)
;
}
self
.
set_bits
(
)
;
}
}
