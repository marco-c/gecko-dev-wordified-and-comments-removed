use
app_units
:
:
Au
;
use
dom
:
:
TElement
;
use
properties
:
:
{
self
ComputedValues
StyleBuilder
}
;
use
properties
:
:
computed_value_flags
:
:
ComputedValueFlags
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
:
:
T
as
Display
;
use
properties
:
:
longhands
:
:
float
:
:
computed_value
:
:
T
as
Float
;
use
properties
:
:
longhands
:
:
overflow_x
:
:
computed_value
:
:
T
as
Overflow
;
use
properties
:
:
longhands
:
:
position
:
:
computed_value
:
:
T
as
Position
;
pub
struct
StyleAdjuster
<
'
a
'
b
:
'
a
>
{
style
:
&
'
a
mut
StyleBuilder
<
'
b
>
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
is_topmost_svg_svg_element
<
E
>
(
e
:
E
)
-
>
bool
where
E
:
TElement
{
debug_assert
!
(
e
.
is_svg_element
(
)
)
;
if
e
.
local_name
(
)
!
=
&
*
atom
!
(
"
svg
"
)
{
return
false
;
}
let
parent
=
match
e
.
traversal_parent
(
)
{
Some
(
n
)
=
>
n
None
=
>
return
true
}
;
if
!
parent
.
is_svg_element
(
)
{
return
true
;
}
parent
.
local_name
(
)
=
=
&
*
atom
!
(
"
foreignObject
"
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
is_effective_display_none_for_display_contents
<
E
>
(
element
:
E
)
-
>
bool
where
E
:
TElement
{
use
Atom
;
lazy_static
!
{
static
ref
SPECIAL_HTML_ELEMENTS
:
[
Atom
;
16
]
=
[
atom
!
(
"
br
"
)
atom
!
(
"
wbr
"
)
atom
!
(
"
meter
"
)
atom
!
(
"
progress
"
)
atom
!
(
"
canvas
"
)
atom
!
(
"
embed
"
)
atom
!
(
"
object
"
)
atom
!
(
"
audio
"
)
atom
!
(
"
iframe
"
)
atom
!
(
"
img
"
)
atom
!
(
"
video
"
)
atom
!
(
"
frame
"
)
atom
!
(
"
frameset
"
)
atom
!
(
"
input
"
)
atom
!
(
"
textarea
"
)
atom
!
(
"
select
"
)
]
;
}
lazy_static
!
{
static
ref
SPECIAL_SVG_ELEMENTS
:
[
Atom
;
6
]
=
[
atom
!
(
"
svg
"
)
atom
!
(
"
a
"
)
atom
!
(
"
g
"
)
atom
!
(
"
use
"
)
atom
!
(
"
tspan
"
)
atom
!
(
"
textPath
"
)
]
;
}
if
element
.
is_html_element
(
)
{
let
local_name
=
element
.
local_name
(
)
;
return
SPECIAL_HTML_ELEMENTS
.
iter
(
)
.
any
(
|
name
|
&
*
*
name
=
=
local_name
)
;
}
if
element
.
is_svg_element
(
)
{
if
is_topmost_svg_svg_element
(
element
)
{
return
true
;
}
let
local_name
=
element
.
local_name
(
)
;
return
!
SPECIAL_SVG_ELEMENTS
.
iter
(
)
.
any
(
|
name
|
&
*
*
name
=
=
local_name
)
;
}
if
element
.
is_mathml_element
(
)
|
|
element
.
is_xul_element
(
)
{
return
true
;
}
false
}
impl
<
'
a
'
b
:
'
a
>
StyleAdjuster
<
'
a
'
b
>
{
#
[
inline
]
pub
fn
new
(
style
:
&
'
a
mut
StyleBuilder
<
'
b
>
)
-
>
Self
{
StyleAdjuster
{
style
}
}
fn
adjust_for_top_layer
(
&
mut
self
)
{
if
!
self
.
style
.
out_of_flow_positioned
(
)
&
&
self
.
style
.
in_top_layer
(
)
{
self
.
style
.
mutate_box
(
)
.
set_position
(
Position
:
:
Absolute
)
;
}
}
fn
adjust_for_position
(
&
mut
self
)
{
if
self
.
style
.
out_of_flow_positioned
(
)
&
&
self
.
style
.
floated
(
)
{
self
.
style
.
mutate_box
(
)
.
set_float
(
Float
:
:
None
)
;
}
}
fn
skip_item_display_fixup
<
E
>
(
&
self
element
:
Option
<
E
>
)
-
>
bool
where
E
:
TElement
{
if
let
Some
(
pseudo
)
=
self
.
style
.
pseudo
{
return
pseudo
.
skip_item_display_fixup
(
)
;
}
element
.
map_or
(
false
|
e
|
e
.
skip_item_display_fixup
(
)
)
}
fn
blockify_if_necessary
<
E
>
(
&
mut
self
layout_parent_style
:
&
ComputedValues
element
:
Option
<
E
>
)
where
E
:
TElement
{
let
mut
blockify
=
false
;
macro_rules
!
blockify_if
{
(
if_what
:
expr
)
=
>
{
if
!
blockify
{
blockify
=
if_what
;
}
}
;
}
let
is_root
=
self
.
style
.
pseudo
.
is_none
(
)
&
&
element
.
map_or
(
false
|
e
|
e
.
is_root
(
)
)
;
blockify_if
!
(
is_root
)
;
if
!
self
.
skip_item_display_fixup
(
element
)
{
blockify_if
!
(
layout_parent_style
.
get_box
(
)
.
clone_display
(
)
.
is_item_container
(
)
)
;
}
let
is_item_or_root
=
blockify
;
blockify_if
!
(
self
.
style
.
floated
(
)
)
;
blockify_if
!
(
self
.
style
.
out_of_flow_positioned
(
)
)
;
if
!
blockify
{
return
;
}
let
display
=
self
.
style
.
get_box
(
)
.
clone_display
(
)
;
let
blockified_display
=
display
.
equivalent_block_display
(
is_root
)
;
if
display
!
=
blockified_display
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
blockified_display
is_item_or_root
)
;
}
}
pub
fn
set_bits
(
&
mut
self
)
{
let
display
=
self
.
style
.
get_box
(
)
.
clone_display
(
)
;
if
!
display
.
is_contents
(
)
&
&
!
self
.
style
.
get_text
(
)
.
clone_text_decoration_line
(
)
.
is_empty
(
)
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
HAS_TEXT_DECORATION_LINES
)
;
}
if
self
.
style
.
is_pseudo_element
(
)
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
IS_IN_PSEUDO_ELEMENT_SUBTREE
)
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
{
if
self
.
style
.
get_parent_column
(
)
.
is_multicol
(
)
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
CAN_BE_FRAGMENTED
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
adjust_for_text
(
&
mut
self
)
{
self
.
adjust_for_text_combine_upright
(
)
;
self
.
adjust_for_text_in_ruby
(
)
;
self
.
set_bits
(
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_text_combine_upright
(
&
mut
self
)
{
use
computed_values
:
:
text_combine_upright
:
:
T
as
TextCombineUpright
;
use
computed_values
:
:
writing_mode
:
:
T
as
WritingMode
;
let
writing_mode
=
self
.
style
.
get_inherited_box
(
)
.
clone_writing_mode
(
)
;
let
text_combine_upright
=
self
.
style
.
get_inherited_text
(
)
.
clone_text_combine_upright
(
)
;
if
writing_mode
!
=
WritingMode
:
:
HorizontalTb
&
&
text_combine_upright
=
=
TextCombineUpright
:
:
All
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
IS_TEXT_COMBINED
)
;
self
.
style
.
mutate_inherited_box
(
)
.
set_writing_mode
(
WritingMode
:
:
HorizontalTb
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_text_in_ruby
(
&
mut
self
)
{
let
parent_display
=
self
.
style
.
get_parent_box
(
)
.
clone_display
(
)
;
if
parent_display
.
is_ruby_type
(
)
|
|
self
.
style
.
get_parent_flags
(
)
.
contains
(
ComputedValueFlags
:
:
SHOULD_SUPPRESS_LINEBREAK
)
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
SHOULD_SUPPRESS_LINEBREAK
)
;
}
}
fn
adjust_for_writing_mode
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
let
our_writing_mode
=
self
.
style
.
get_inherited_box
(
)
.
clone_writing_mode
(
)
;
let
parent_writing_mode
=
layout_parent_style
.
get_inherited_box
(
)
.
clone_writing_mode
(
)
;
if
our_writing_mode
!
=
parent_writing_mode
&
&
self
.
style
.
get_box
(
)
.
clone_display
(
)
=
=
Display
:
:
Inline
{
if
cfg
!
(
feature
=
"
servo
"
)
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
Display
:
:
InlineBlock
false
)
;
}
else
{
self
.
style
.
mutate_box
(
)
.
set_display
(
Display
:
:
InlineBlock
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_mathvariant
(
&
mut
self
)
{
use
properties
:
:
longhands
:
:
_moz_math_variant
:
:
computed_value
:
:
T
as
MozMathVariant
;
use
properties
:
:
longhands
:
:
font_weight
:
:
computed_value
:
:
T
as
FontWeight
;
use
values
:
:
generics
:
:
font
:
:
FontStyle
;
if
self
.
style
.
get_font
(
)
.
clone__moz_math_variant
(
)
!
=
MozMathVariant
:
:
None
{
let
font_style
=
self
.
style
.
mutate_font
(
)
;
font_style
.
set_font_weight
(
FontWeight
:
:
normal
(
)
)
;
font_style
.
set_font_style
(
FontStyle
:
:
Normal
)
;
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
adjust_for_alignment
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
use
computed_values
:
:
align_items
:
:
T
as
AlignItems
;
use
computed_values
:
:
align_self
:
:
T
as
AlignSelf
;
if
self
.
style
.
get_position
(
)
.
clone_align_self
(
)
=
=
AlignSelf
:
:
Auto
&
&
!
self
.
style
.
out_of_flow_positioned
(
)
{
let
self_align
=
match
layout_parent_style
.
get_position
(
)
.
clone_align_items
(
)
{
AlignItems
:
:
Stretch
=
>
AlignSelf
:
:
Stretch
AlignItems
:
:
Baseline
=
>
AlignSelf
:
:
Baseline
AlignItems
:
:
FlexStart
=
>
AlignSelf
:
:
FlexStart
AlignItems
:
:
FlexEnd
=
>
AlignSelf
:
:
FlexEnd
AlignItems
:
:
Center
=
>
AlignSelf
:
:
Center
}
;
self
.
style
.
mutate_position
(
)
.
set_align_self
(
self_align
)
;
}
}
fn
adjust_for_border_width
(
&
mut
self
)
{
properties
:
:
adjust_border_width
(
self
.
style
)
;
}
fn
adjust_for_outline
(
&
mut
self
)
{
if
self
.
style
.
get_outline
(
)
.
clone_outline_style
(
)
.
none_or_hidden
(
)
&
&
self
.
style
.
get_outline
(
)
.
outline_has_nonzero_width
(
)
{
self
.
style
.
mutate_outline
(
)
.
set_outline_width
(
Au
(
0
)
.
into
(
)
)
;
}
}
fn
adjust_for_overflow
(
&
mut
self
)
{
let
original_overflow_x
=
self
.
style
.
get_box
(
)
.
clone_overflow_x
(
)
;
let
original_overflow_y
=
self
.
style
.
get_box
(
)
.
clone_overflow_y
(
)
;
let
mut
overflow_x
=
original_overflow_x
;
let
mut
overflow_y
=
original_overflow_y
;
if
overflow_x
=
=
overflow_y
{
return
;
}
if
overflow_x
=
=
Overflow
:
:
Visible
{
overflow_x
=
Overflow
:
:
Auto
;
}
if
overflow_y
=
=
Overflow
:
:
Visible
{
overflow_y
=
Overflow
:
:
Auto
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
if
overflow_x
=
=
Overflow
:
:
MozHiddenUnscrollable
{
overflow_x
=
Overflow
:
:
Hidden
;
}
if
overflow_y
=
=
Overflow
:
:
MozHiddenUnscrollable
{
overflow_y
=
Overflow
:
:
Hidden
;
}
}
if
overflow_x
!
=
original_overflow_x
|
|
overflow_y
!
=
original_overflow_y
{
let
box_style
=
self
.
style
.
mutate_box
(
)
;
box_style
.
set_overflow_x
(
overflow_x
)
;
box_style
.
set_overflow_y
(
overflow_y
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_prohibited_display_contents
<
E
>
(
&
mut
self
element
:
Option
<
E
>
)
where
E
:
TElement
{
if
self
.
style
.
get_box
(
)
.
clone_display
(
)
!
=
Display
:
:
Contents
{
return
;
}
if
self
.
style
.
pseudo
.
is_some
(
)
{
self
.
style
.
mutate_box
(
)
.
set_display
(
Display
:
:
Inline
)
;
return
;
}
let
element
=
match
element
{
Some
(
e
)
=
>
e
None
=
>
return
}
;
if
is_effective_display_none_for_display_contents
(
element
)
{
self
.
style
.
mutate_box
(
)
.
set_display
(
Display
:
:
None
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_fieldset_content
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
match
self
.
style
.
pseudo
{
Some
(
ref
p
)
if
p
.
is_fieldset_content
(
)
=
>
{
}
_
=
>
return
}
debug_assert_eq
!
(
self
.
style
.
get_box
(
)
.
clone_display
(
)
Display
:
:
Block
)
;
let
parent_display
=
layout_parent_style
.
get_box
(
)
.
clone_display
(
)
;
let
new_display
=
match
parent_display
{
Display
:
:
Flex
|
Display
:
:
InlineFlex
=
>
Some
(
Display
:
:
Flex
)
Display
:
:
Grid
|
Display
:
:
InlineGrid
=
>
Some
(
Display
:
:
Grid
)
_
=
>
None
}
;
if
let
Some
(
new_display
)
=
new_display
{
self
.
style
.
mutate_box
(
)
.
set_display
(
new_display
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_table_text_align
(
&
mut
self
)
{
use
properties
:
:
longhands
:
:
text_align
:
:
computed_value
:
:
T
as
TextAlign
;
if
self
.
style
.
get_box
(
)
.
clone_display
(
)
!
=
Display
:
:
Table
{
return
;
}
match
self
.
style
.
get_inherited_text
(
)
.
clone_text_align
(
)
{
TextAlign
:
:
MozLeft
|
TextAlign
:
:
MozCenter
|
TextAlign
:
:
MozRight
=
>
{
}
_
=
>
return
}
self
.
style
.
mutate_inherited_text
(
)
.
set_text_align
(
TextAlign
:
:
Start
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
adjust_for_text_decorations_in_effect
(
&
mut
self
)
{
use
values
:
:
computed
:
:
text
:
:
TextDecorationsInEffect
;
let
decorations_in_effect
=
TextDecorationsInEffect
:
:
from_style
(
&
self
.
style
)
;
if
self
.
style
.
get_inherited_text
(
)
.
text_decorations_in_effect
!
=
decorations_in_effect
{
self
.
style
.
mutate_inherited_text
(
)
.
text_decorations_in_effect
=
decorations_in_effect
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
should_suppress_linebreak
(
&
self
layout_parent_style
:
&
ComputedValues
)
-
>
bool
{
if
self
.
style
.
floated
(
)
|
|
self
.
style
.
out_of_flow_positioned
(
)
{
return
false
;
}
let
parent_display
=
layout_parent_style
.
get_box
(
)
.
clone_display
(
)
;
if
layout_parent_style
.
flags
.
contains
(
ComputedValueFlags
:
:
SHOULD_SUPPRESS_LINEBREAK
)
{
if
parent_display
.
is_line_participant
(
)
{
return
true
;
}
}
match
self
.
style
.
get_box
(
)
.
clone_display
(
)
{
Display
:
:
RubyBase
|
Display
:
:
RubyText
=
>
true
Display
:
:
RubyBaseContainer
|
Display
:
:
RubyTextContainer
=
>
false
_
=
>
parent_display
.
is_ruby_type
(
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_ruby
<
E
>
(
&
mut
self
layout_parent_style
:
&
ComputedValues
element
:
Option
<
E
>
)
where
E
:
TElement
{
use
properties
:
:
longhands
:
:
unicode_bidi
:
:
computed_value
:
:
T
as
UnicodeBidi
;
let
self_display
=
self
.
style
.
get_box
(
)
.
clone_display
(
)
;
if
self
.
should_suppress_linebreak
(
layout_parent_style
)
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
SHOULD_SUPPRESS_LINEBREAK
)
;
if
!
self
.
skip_item_display_fixup
(
element
)
{
let
inline_display
=
self_display
.
inlinify
(
)
;
if
self_display
!
=
inline_display
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
inline_display
false
)
;
}
}
}
if
self_display
.
is_ruby_level_container
(
)
{
self
.
style
.
reset_border_struct
(
)
;
self
.
style
.
reset_padding_struct
(
)
;
}
if
self_display
.
is_ruby_type
(
)
{
let
new_value
=
match
self
.
style
.
get_text
(
)
.
clone_unicode_bidi
(
)
{
UnicodeBidi
:
:
Normal
|
UnicodeBidi
:
:
Embed
=
>
Some
(
UnicodeBidi
:
:
Isolate
)
UnicodeBidi
:
:
BidiOverride
=
>
Some
(
UnicodeBidi
:
:
IsolateOverride
)
_
=
>
None
}
;
if
let
Some
(
new_value
)
=
new_value
{
self
.
style
.
mutate_text
(
)
.
set_unicode_bidi
(
new_value
)
;
}
}
}
fn
adjust_for_visited
<
E
>
(
&
mut
self
element
:
Option
<
E
>
)
where
E
:
TElement
{
if
!
self
.
style
.
has_visited_style
(
)
{
return
;
}
let
is_link_element
=
self
.
style
.
pseudo
.
is_none
(
)
&
&
element
.
map_or
(
false
|
e
|
e
.
is_link
(
)
)
;
if
!
is_link_element
{
return
;
}
if
element
.
unwrap
(
)
.
is_visited_link
(
)
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
IS_RELEVANT_LINK_VISITED
)
;
}
else
{
self
.
style
.
flags
.
remove
(
ComputedValueFlags
:
:
IS_RELEVANT_LINK_VISITED
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_justify_items
(
&
mut
self
)
{
use
values
:
:
specified
:
:
align
;
let
justify_items
=
self
.
style
.
get_position
(
)
.
clone_justify_items
(
)
;
if
justify_items
.
specified
.
0
!
=
align
:
:
AlignFlags
:
:
LEGACY
{
return
;
}
let
parent_justify_items
=
self
.
style
.
get_parent_position
(
)
.
clone_justify_items
(
)
;
if
!
parent_justify_items
.
computed
.
0
.
contains
(
align
:
:
AlignFlags
:
:
LEGACY
)
{
return
;
}
if
parent_justify_items
.
computed
=
=
justify_items
.
computed
{
return
;
}
self
.
style
.
mutate_position
(
)
.
set_computed_justify_items
(
parent_justify_items
.
computed
)
;
}
pub
fn
adjust
<
E
>
(
&
mut
self
layout_parent_style
:
&
ComputedValues
element
:
Option
<
E
>
)
where
E
:
TElement
{
debug_assert
!
(
!
self
.
style
.
flags
.
contains
(
ComputedValueFlags
:
:
IS_STYLE_IF_VISITED
)
"
Adjusting
visited
styles
is
wasted
work
"
)
;
if
cfg
!
(
debug_assertions
)
{
if
element
.
and_then
(
|
e
|
e
.
implemented_pseudo_element
(
)
)
.
is_some
(
)
{
debug_assert
!
(
self
.
style
.
pseudo
.
is_some
(
)
"
Someone
really
messed
up
"
)
;
}
}
self
.
adjust_for_visited
(
element
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_prohibited_display_contents
(
element
)
;
self
.
adjust_for_fieldset_content
(
layout_parent_style
)
;
}
self
.
adjust_for_top_layer
(
)
;
self
.
blockify_if_necessary
(
layout_parent_style
element
)
;
self
.
adjust_for_position
(
)
;
self
.
adjust_for_overflow
(
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_table_text_align
(
)
;
self
.
adjust_for_mathvariant
(
)
;
self
.
adjust_for_justify_items
(
)
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
{
self
.
adjust_for_alignment
(
layout_parent_style
)
;
}
self
.
adjust_for_border_width
(
)
;
self
.
adjust_for_outline
(
)
;
self
.
adjust_for_writing_mode
(
layout_parent_style
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_ruby
(
layout_parent_style
element
)
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
{
self
.
adjust_for_text_decorations_in_effect
(
)
;
}
self
.
set_bits
(
)
;
}
}
