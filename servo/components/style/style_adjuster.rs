use
app_units
:
:
Au
;
use
properties
:
:
{
self
CascadeFlags
ComputedValues
StyleBuilder
}
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
:
:
T
as
Display
;
use
properties
:
:
longhands
:
:
float
:
:
computed_value
:
:
T
as
Float
;
use
properties
:
:
longhands
:
:
overflow_x
:
:
computed_value
:
:
T
as
Overflow
;
use
properties
:
:
longhands
:
:
position
:
:
computed_value
:
:
T
as
Position
;
pub
struct
StyleAdjuster
<
'
a
'
b
:
'
a
>
{
style
:
&
'
a
mut
StyleBuilder
<
'
b
>
}
impl
<
'
a
'
b
:
'
a
>
StyleAdjuster
<
'
a
'
b
>
{
#
[
inline
]
pub
fn
new
(
style
:
&
'
a
mut
StyleBuilder
<
'
b
>
)
-
>
Self
{
StyleAdjuster
{
style
}
}
fn
adjust_for_top_layer
(
&
mut
self
)
{
if
!
self
.
style
.
out_of_flow_positioned
(
)
&
&
self
.
style
.
in_top_layer
(
)
{
self
.
style
.
mutate_box
(
)
.
set_position
(
Position
:
:
Absolute
)
;
}
}
fn
adjust_for_position
(
&
mut
self
)
{
if
self
.
style
.
out_of_flow_positioned
(
)
&
&
self
.
style
.
floated
(
)
{
self
.
style
.
mutate_box
(
)
.
set_float
(
Float
:
:
None
)
;
}
}
fn
blockify_if_necessary
(
&
mut
self
layout_parent_style
:
&
ComputedValues
flags
:
CascadeFlags
)
{
let
mut
blockify
=
false
;
macro_rules
!
blockify_if
{
(
if_what
:
expr
)
=
>
{
if
!
blockify
{
blockify
=
if_what
;
}
}
}
if
!
flags
.
contains
(
CascadeFlags
:
:
SKIP_ROOT_AND_ITEM_BASED_DISPLAY_FIXUP
)
{
blockify_if
!
(
flags
.
contains
(
CascadeFlags
:
:
IS_ROOT_ELEMENT
)
)
;
blockify_if
!
(
layout_parent_style
.
get_box
(
)
.
clone_display
(
)
.
is_item_container
(
)
)
;
}
let
is_item_or_root
=
blockify
;
blockify_if
!
(
self
.
style
.
floated
(
)
)
;
blockify_if
!
(
self
.
style
.
out_of_flow_positioned
(
)
)
;
if
!
blockify
{
return
;
}
let
display
=
self
.
style
.
get_box
(
)
.
clone_display
(
)
;
let
blockified_display
=
display
.
equivalent_block_display
(
flags
.
contains
(
CascadeFlags
:
:
IS_ROOT_ELEMENT
)
)
;
if
display
!
=
blockified_display
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
blockified_display
is_item_or_root
)
;
}
}
pub
fn
set_bits
(
&
mut
self
)
{
use
properties
:
:
computed_value_flags
:
:
ComputedValueFlags
;
if
self
.
style
.
inherited_flags
(
)
.
contains
(
ComputedValueFlags
:
:
IS_IN_DISPLAY_NONE_SUBTREE
)
|
|
self
.
style
.
get_box
(
)
.
clone_display
(
)
=
=
Display
:
:
None
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
IS_IN_DISPLAY_NONE_SUBTREE
)
;
}
if
self
.
style
.
inherited_flags
(
)
.
contains
(
ComputedValueFlags
:
:
IS_IN_PSEUDO_ELEMENT_SUBTREE
)
|
|
self
.
style
.
is_pseudo_element
(
)
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
IS_IN_PSEUDO_ELEMENT_SUBTREE
)
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
{
if
self
.
style
.
inherited_flags
(
)
.
contains
(
ComputedValueFlags
:
:
CAN_BE_FRAGMENTED
)
|
|
self
.
style
.
get_parent_column
(
)
.
is_multicol
(
)
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
CAN_BE_FRAGMENTED
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
adjust_for_text
(
&
mut
self
)
{
self
.
adjust_for_text_combine_upright
(
)
;
self
.
adjust_for_text_in_ruby
(
)
;
self
.
set_bits
(
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_text_combine_upright
(
&
mut
self
)
{
use
computed_values
:
:
text_combine_upright
:
:
T
as
TextCombineUpright
;
use
computed_values
:
:
writing_mode
:
:
T
as
WritingMode
;
use
properties
:
:
computed_value_flags
:
:
ComputedValueFlags
;
let
writing_mode
=
self
.
style
.
get_inheritedbox
(
)
.
clone_writing_mode
(
)
;
let
text_combine_upright
=
self
.
style
.
get_inheritedtext
(
)
.
clone_text_combine_upright
(
)
;
if
writing_mode
!
=
WritingMode
:
:
HorizontalTb
&
&
text_combine_upright
=
=
TextCombineUpright
:
:
All
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
IS_TEXT_COMBINED
)
;
self
.
style
.
mutate_inheritedbox
(
)
.
set_writing_mode
(
WritingMode
:
:
HorizontalTb
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_text_in_ruby
(
&
mut
self
)
{
use
properties
:
:
computed_value_flags
:
:
ComputedValueFlags
;
let
parent_display
=
self
.
style
.
get_parent_box
(
)
.
clone_display
(
)
;
if
parent_display
.
is_ruby_type
(
)
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
SHOULD_SUPPRESS_LINEBREAK
)
;
}
}
fn
adjust_for_writing_mode
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
let
our_writing_mode
=
self
.
style
.
get_inheritedbox
(
)
.
clone_writing_mode
(
)
;
let
parent_writing_mode
=
layout_parent_style
.
get_inheritedbox
(
)
.
clone_writing_mode
(
)
;
if
our_writing_mode
!
=
parent_writing_mode
&
&
self
.
style
.
get_box
(
)
.
clone_display
(
)
=
=
Display
:
:
Inline
{
if
cfg
!
(
feature
=
"
servo
"
)
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
Display
:
:
InlineBlock
false
)
;
}
else
{
self
.
style
.
mutate_box
(
)
.
set_display
(
Display
:
:
InlineBlock
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_contain
(
&
mut
self
)
{
use
properties
:
:
longhands
:
:
contain
:
:
SpecifiedValue
;
let
contain
=
self
.
style
.
get_box
(
)
.
clone_contain
(
)
;
if
!
contain
.
contains
(
SpecifiedValue
:
:
PAINT
)
{
return
;
}
if
self
.
style
.
get_box
(
)
.
clone_display
(
)
=
=
Display
:
:
Inline
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
Display
:
:
InlineBlock
false
)
;
}
if
self
.
style
.
get_box
(
)
.
clone_contain
(
)
.
contains
(
SpecifiedValue
:
:
PAINT
)
{
if
self
.
style
.
get_box
(
)
.
clone_overflow_x
(
)
=
=
Overflow
:
:
Visible
{
let
box_style
=
self
.
style
.
mutate_box
(
)
;
box_style
.
set_overflow_x
(
Overflow
:
:
MozHiddenUnscrollable
)
;
box_style
.
set_overflow_y
(
Overflow
:
:
MozHiddenUnscrollable
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_mathvariant
(
&
mut
self
)
{
use
properties
:
:
longhands
:
:
_moz_math_variant
:
:
computed_value
:
:
T
as
MozMathVariant
;
use
properties
:
:
longhands
:
:
font_style
:
:
computed_value
:
:
T
as
FontStyle
;
use
properties
:
:
longhands
:
:
font_weight
:
:
computed_value
:
:
T
as
FontWeight
;
if
self
.
style
.
get_font
(
)
.
clone__moz_math_variant
(
)
!
=
MozMathVariant
:
:
None
{
let
font_style
=
self
.
style
.
mutate_font
(
)
;
font_style
.
set_font_weight
(
FontWeight
:
:
normal
(
)
)
;
font_style
.
set_font_style
(
FontStyle
:
:
Normal
)
;
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
adjust_for_alignment
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
use
computed_values
:
:
align_items
:
:
T
as
AlignItems
;
use
computed_values
:
:
align_self
:
:
T
as
AlignSelf
;
if
self
.
style
.
get_position
(
)
.
clone_align_self
(
)
=
=
AlignSelf
:
:
Auto
&
&
!
self
.
style
.
out_of_flow_positioned
(
)
{
let
self_align
=
match
layout_parent_style
.
get_position
(
)
.
clone_align_items
(
)
{
AlignItems
:
:
Stretch
=
>
AlignSelf
:
:
Stretch
AlignItems
:
:
Baseline
=
>
AlignSelf
:
:
Baseline
AlignItems
:
:
FlexStart
=
>
AlignSelf
:
:
FlexStart
AlignItems
:
:
FlexEnd
=
>
AlignSelf
:
:
FlexEnd
AlignItems
:
:
Center
=
>
AlignSelf
:
:
Center
}
;
self
.
style
.
mutate_position
(
)
.
set_align_self
(
self_align
)
;
}
}
fn
adjust_for_border_width
(
&
mut
self
)
{
properties
:
:
adjust_border_width
(
self
.
style
)
;
}
fn
adjust_for_outline
(
&
mut
self
)
{
if
self
.
style
.
get_outline
(
)
.
clone_outline_style
(
)
.
none_or_hidden
(
)
&
&
self
.
style
.
get_outline
(
)
.
outline_has_nonzero_width
(
)
{
self
.
style
.
mutate_outline
(
)
.
set_outline_width
(
Au
(
0
)
.
into
(
)
)
;
}
}
fn
adjust_for_overflow
(
&
mut
self
)
{
let
original_overflow_x
=
self
.
style
.
get_box
(
)
.
clone_overflow_x
(
)
;
let
original_overflow_y
=
self
.
style
.
get_box
(
)
.
clone_overflow_y
(
)
;
let
mut
overflow_x
=
original_overflow_x
;
let
mut
overflow_y
=
original_overflow_y
;
if
overflow_x
=
=
overflow_y
{
return
;
}
if
overflow_x
=
=
Overflow
:
:
Visible
{
overflow_x
=
Overflow
:
:
Auto
;
}
if
overflow_y
=
=
Overflow
:
:
Visible
{
overflow_y
=
Overflow
:
:
Auto
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
if
overflow_x
=
=
Overflow
:
:
MozHiddenUnscrollable
{
overflow_x
=
Overflow
:
:
Hidden
;
}
if
overflow_y
=
=
Overflow
:
:
MozHiddenUnscrollable
{
overflow_y
=
Overflow
:
:
Hidden
;
}
}
if
overflow_x
!
=
original_overflow_x
|
|
overflow_y
!
=
original_overflow_y
{
let
box_style
=
self
.
style
.
mutate_box
(
)
;
box_style
.
set_overflow_x
(
overflow_x
)
;
box_style
.
set_overflow_y
(
overflow_y
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_prohibited_display_contents
(
&
mut
self
)
{
if
self
.
style
.
pseudo
.
is_none
(
)
|
|
self
.
style
.
get_box
(
)
.
clone_display
(
)
!
=
Display
:
:
Contents
{
return
;
}
self
.
style
.
mutate_box
(
)
.
set_display
(
Display
:
:
Inline
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_fieldset_content
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
match
self
.
style
.
pseudo
{
Some
(
ref
p
)
if
p
.
is_fieldset_content
(
)
=
>
{
}
_
=
>
return
}
debug_assert_eq
!
(
self
.
style
.
get_box
(
)
.
clone_display
(
)
Display
:
:
Block
)
;
let
parent_display
=
layout_parent_style
.
get_box
(
)
.
clone_display
(
)
;
let
new_display
=
match
parent_display
{
Display
:
:
Flex
|
Display
:
:
InlineFlex
=
>
Some
(
Display
:
:
Flex
)
Display
:
:
Grid
|
Display
:
:
InlineGrid
=
>
Some
(
Display
:
:
Grid
)
_
=
>
None
}
;
if
let
Some
(
new_display
)
=
new_display
{
self
.
style
.
mutate_box
(
)
.
set_display
(
new_display
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_table_text_align
(
&
mut
self
)
{
use
properties
:
:
longhands
:
:
text_align
:
:
computed_value
:
:
T
as
TextAlign
;
if
self
.
style
.
get_box
(
)
.
clone_display
(
)
!
=
Display
:
:
Table
{
return
;
}
match
self
.
style
.
get_inheritedtext
(
)
.
clone_text_align
(
)
{
TextAlign
:
:
MozLeft
|
TextAlign
:
:
MozCenter
|
TextAlign
:
:
MozRight
=
>
{
}
_
=
>
return
}
self
.
style
.
mutate_inheritedtext
(
)
.
set_text_align
(
TextAlign
:
:
Start
)
}
fn
adjust_for_text_decoration_lines
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
use
properties
:
:
computed_value_flags
:
:
ComputedValueFlags
;
if
layout_parent_style
.
flags
.
contains
(
ComputedValueFlags
:
:
HAS_TEXT_DECORATION_LINES
)
|
|
!
self
.
style
.
get_text
(
)
.
clone_text_decoration_line
(
)
.
is_empty
(
)
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
HAS_TEXT_DECORATION_LINES
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
should_suppress_linebreak
(
&
self
layout_parent_style
:
&
ComputedValues
)
-
>
bool
{
use
properties
:
:
computed_value_flags
:
:
ComputedValueFlags
;
if
self
.
style
.
floated
(
)
|
|
self
.
style
.
out_of_flow_positioned
(
)
{
return
false
;
}
let
parent_display
=
layout_parent_style
.
get_box
(
)
.
clone_display
(
)
;
if
layout_parent_style
.
flags
.
contains
(
ComputedValueFlags
:
:
SHOULD_SUPPRESS_LINEBREAK
)
{
if
parent_display
.
is_line_participant
(
)
{
return
true
;
}
}
match
self
.
style
.
get_box
(
)
.
clone_display
(
)
{
Display
:
:
RubyBase
|
Display
:
:
RubyText
=
>
true
Display
:
:
RubyBaseContainer
|
Display
:
:
RubyTextContainer
=
>
false
_
=
>
parent_display
.
is_ruby_type
(
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_ruby
(
&
mut
self
layout_parent_style
:
&
ComputedValues
flags
:
CascadeFlags
)
{
use
properties
:
:
CascadeFlags
;
use
properties
:
:
computed_value_flags
:
:
ComputedValueFlags
;
use
properties
:
:
longhands
:
:
unicode_bidi
:
:
computed_value
:
:
T
as
UnicodeBidi
;
let
self_display
=
self
.
style
.
get_box
(
)
.
clone_display
(
)
;
if
self
.
should_suppress_linebreak
(
layout_parent_style
)
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
SHOULD_SUPPRESS_LINEBREAK
)
;
if
!
flags
.
contains
(
CascadeFlags
:
:
SKIP_ROOT_AND_ITEM_BASED_DISPLAY_FIXUP
)
{
let
inline_display
=
self_display
.
inlinify
(
)
;
if
self_display
!
=
inline_display
{
self
.
style
.
mutate_box
(
)
.
set_display
(
inline_display
)
;
}
}
}
if
self_display
.
is_ruby_level_container
(
)
{
self
.
style
.
reset_border_struct
(
)
;
self
.
style
.
reset_padding_struct
(
)
;
}
if
self_display
.
is_ruby_type
(
)
{
let
new_value
=
match
self
.
style
.
get_text
(
)
.
clone_unicode_bidi
(
)
{
UnicodeBidi
:
:
Normal
|
UnicodeBidi
:
:
Embed
=
>
Some
(
UnicodeBidi
:
:
Isolate
)
UnicodeBidi
:
:
BidiOverride
=
>
Some
(
UnicodeBidi
:
:
IsolateOverride
)
_
=
>
None
}
;
if
let
Some
(
new_value
)
=
new_value
{
self
.
style
.
mutate_text
(
)
.
set_unicode_bidi
(
new_value
)
;
}
}
}
fn
adjust_for_visited
(
&
mut
self
flags
:
CascadeFlags
)
{
use
properties
:
:
CascadeFlags
;
use
properties
:
:
computed_value_flags
:
:
ComputedValueFlags
;
if
!
self
.
style
.
has_visited_style
(
)
{
return
;
}
let
relevant_link_visited
=
if
flags
.
contains
(
CascadeFlags
:
:
IS_LINK
)
{
flags
.
contains
(
CascadeFlags
:
:
IS_VISITED_LINK
)
}
else
{
self
.
style
.
inherited_flags
(
)
.
contains
(
ComputedValueFlags
:
:
IS_RELEVANT_LINK_VISITED
)
}
;
if
relevant_link_visited
{
self
.
style
.
flags
.
insert
(
ComputedValueFlags
:
:
IS_RELEVANT_LINK_VISITED
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_justify_items
(
&
mut
self
)
{
use
values
:
:
specified
:
:
align
;
let
justify_items
=
self
.
style
.
get_position
(
)
.
clone_justify_items
(
)
;
if
justify_items
.
specified
.
0
!
=
align
:
:
AlignFlags
:
:
AUTO
{
return
;
}
let
parent_justify_items
=
self
.
style
.
get_parent_position
(
)
.
clone_justify_items
(
)
;
if
!
parent_justify_items
.
computed
.
0
.
contains
(
align
:
:
AlignFlags
:
:
LEGACY
)
{
return
;
}
if
parent_justify_items
.
computed
=
=
justify_items
.
computed
{
return
;
}
self
.
style
.
mutate_position
(
)
.
set_computed_justify_items
(
parent_justify_items
.
computed
)
;
}
pub
fn
adjust
(
&
mut
self
layout_parent_style
:
&
ComputedValues
flags
:
CascadeFlags
)
{
if
flags
.
contains
(
CascadeFlags
:
:
VISITED_DEPENDENT_ONLY
)
{
return
;
}
self
.
adjust_for_visited
(
flags
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_prohibited_display_contents
(
)
;
self
.
adjust_for_fieldset_content
(
layout_parent_style
)
;
}
self
.
adjust_for_top_layer
(
)
;
self
.
blockify_if_necessary
(
layout_parent_style
flags
)
;
self
.
adjust_for_position
(
)
;
self
.
adjust_for_overflow
(
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_table_text_align
(
)
;
self
.
adjust_for_contain
(
)
;
self
.
adjust_for_mathvariant
(
)
;
self
.
adjust_for_justify_items
(
)
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
{
self
.
adjust_for_alignment
(
layout_parent_style
)
;
}
self
.
adjust_for_border_width
(
)
;
self
.
adjust_for_outline
(
)
;
self
.
adjust_for_writing_mode
(
layout_parent_style
)
;
self
.
adjust_for_text_decoration_lines
(
layout_parent_style
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_ruby
(
layout_parent_style
flags
)
;
}
self
.
set_bits
(
)
;
}
}
