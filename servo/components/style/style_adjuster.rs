use
app_units
:
:
Au
;
use
properties
:
:
{
self
CascadeFlags
ComputedValues
}
;
use
properties
:
:
{
IS_ROOT_ELEMENT
SKIP_ROOT_AND_ITEM_BASED_DISPLAY_FIXUP
StyleBuilder
}
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
:
:
T
as
display
;
use
properties
:
:
longhands
:
:
float
:
:
computed_value
:
:
T
as
float
;
use
properties
:
:
longhands
:
:
overflow_x
:
:
computed_value
:
:
T
as
overflow
;
use
properties
:
:
longhands
:
:
position
:
:
computed_value
:
:
T
as
position
;
pub
struct
StyleAdjuster
<
'
a
'
b
:
'
a
>
{
style
:
&
'
a
mut
StyleBuilder
<
'
b
>
}
impl
<
'
a
'
b
:
'
a
>
StyleAdjuster
<
'
a
'
b
>
{
pub
fn
new
(
style
:
&
'
a
mut
StyleBuilder
<
'
b
>
)
-
>
Self
{
StyleAdjuster
{
style
:
style
}
}
fn
adjust_for_top_layer
(
&
mut
self
)
{
if
!
self
.
style
.
out_of_flow_positioned
(
)
&
&
self
.
style
.
in_top_layer
(
)
{
self
.
style
.
mutate_box
(
)
.
set_position
(
position
:
:
absolute
)
;
}
}
fn
adjust_for_position
(
&
mut
self
)
{
if
self
.
style
.
out_of_flow_positioned
(
)
&
&
self
.
style
.
floated
(
)
{
self
.
style
.
mutate_box
(
)
.
set_float
(
float
:
:
none
)
;
}
}
fn
blockify_if_necessary
(
&
mut
self
layout_parent_style
:
&
ComputedValues
flags
:
CascadeFlags
)
{
let
mut
blockify
=
false
;
macro_rules
!
blockify_if
{
(
if_what
:
expr
)
=
>
{
if
!
blockify
{
blockify
=
if_what
;
}
}
}
if
!
flags
.
contains
(
SKIP_ROOT_AND_ITEM_BASED_DISPLAY_FIXUP
)
{
blockify_if
!
(
flags
.
contains
(
IS_ROOT_ELEMENT
)
)
;
blockify_if
!
(
layout_parent_style
.
get_box
(
)
.
clone_display
(
)
.
is_item_container
(
)
)
;
}
let
is_item_or_root
=
blockify
;
blockify_if
!
(
self
.
style
.
floated
(
)
)
;
blockify_if
!
(
self
.
style
.
out_of_flow_positioned
(
)
)
;
if
!
blockify
{
return
;
}
let
display
=
self
.
style
.
get_box
(
)
.
clone_display
(
)
;
let
blockified_display
=
display
.
equivalent_block_display
(
flags
.
contains
(
IS_ROOT_ELEMENT
)
)
;
if
display
!
=
blockified_display
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
blockified_display
is_item_or_root
)
;
}
}
pub
fn
set_bits
(
&
mut
self
)
{
use
properties
:
:
computed_value_flags
:
:
IS_IN_DISPLAY_NONE_SUBTREE
;
use
properties
:
:
computed_value_flags
:
:
IS_IN_PSEUDO_ELEMENT_SUBTREE
;
if
self
.
style
.
inherited_flags
(
)
.
contains
(
IS_IN_DISPLAY_NONE_SUBTREE
)
|
|
self
.
style
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
none
{
self
.
style
.
flags
.
insert
(
IS_IN_DISPLAY_NONE_SUBTREE
)
;
}
if
self
.
style
.
inherited_flags
(
)
.
contains
(
IS_IN_PSEUDO_ELEMENT_SUBTREE
)
|
|
self
.
style
.
is_pseudo_element
(
)
{
self
.
style
.
flags
.
insert
(
IS_IN_PSEUDO_ELEMENT_SUBTREE
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
adjust_for_text
(
&
mut
self
parent_style
:
&
ComputedValues
)
{
self
.
adjust_for_text_combine_upright
(
)
;
self
.
adjust_for_text_in_ruby
(
parent_style
)
;
self
.
set_bits
(
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_text_combine_upright
(
&
mut
self
)
{
use
computed_values
:
:
text_combine_upright
:
:
T
as
text_combine_upright
;
use
computed_values
:
:
writing_mode
:
:
T
as
writing_mode
;
use
properties
:
:
computed_value_flags
:
:
IS_TEXT_COMBINED
;
let
writing_mode
=
self
.
style
.
get_inheritedbox
(
)
.
clone_writing_mode
(
)
;
let
text_combine_upright
=
self
.
style
.
get_inheritedtext
(
)
.
clone_text_combine_upright
(
)
;
if
writing_mode
!
=
writing_mode
:
:
horizontal_tb
&
&
text_combine_upright
=
=
text_combine_upright
:
:
all
{
self
.
style
.
flags
.
insert
(
IS_TEXT_COMBINED
)
;
self
.
style
.
mutate_inheritedbox
(
)
.
set_writing_mode
(
writing_mode
:
:
horizontal_tb
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_text_in_ruby
(
&
mut
self
parent_style
:
&
ComputedValues
)
{
use
properties
:
:
computed_value_flags
:
:
SHOULD_SUPPRESS_LINEBREAK
;
let
parent_display
=
parent_style
.
get_box
(
)
.
clone_display
(
)
;
if
parent_display
.
is_ruby_type
(
)
{
self
.
style
.
flags
.
insert
(
SHOULD_SUPPRESS_LINEBREAK
)
;
}
}
fn
adjust_for_writing_mode
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
let
our_writing_mode
=
self
.
style
.
get_inheritedbox
(
)
.
clone_writing_mode
(
)
;
let
parent_writing_mode
=
layout_parent_style
.
get_inheritedbox
(
)
.
clone_writing_mode
(
)
;
if
our_writing_mode
!
=
parent_writing_mode
&
&
self
.
style
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
inline
{
self
.
style
.
mutate_box
(
)
.
set_display
(
display
:
:
inline_block
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_contain
(
&
mut
self
)
{
use
properties
:
:
longhands
:
:
contain
;
let
contain
=
self
.
style
.
get_box
(
)
.
clone_contain
(
)
;
if
!
contain
.
contains
(
contain
:
:
PAINT
)
{
return
;
}
if
self
.
style
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
inline
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
display
:
:
inline_block
false
)
;
}
if
self
.
style
.
get_box
(
)
.
clone_contain
(
)
.
contains
(
contain
:
:
PAINT
)
{
if
self
.
style
.
get_box
(
)
.
clone_overflow_x
(
)
=
=
overflow
:
:
visible
{
let
mut
box_style
=
self
.
style
.
mutate_box
(
)
;
box_style
.
set_overflow_x
(
overflow
:
:
_moz_hidden_unscrollable
)
;
box_style
.
set_overflow_y
(
overflow
:
:
_moz_hidden_unscrollable
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_mathvariant
(
&
mut
self
)
{
use
properties
:
:
longhands
:
:
_moz_math_variant
:
:
computed_value
:
:
T
as
moz_math_variant
;
use
properties
:
:
longhands
:
:
font_style
:
:
computed_value
:
:
T
as
font_style
;
use
properties
:
:
longhands
:
:
font_weight
:
:
computed_value
:
:
T
as
font_weight
;
if
self
.
style
.
get_font
(
)
.
clone__moz_math_variant
(
)
!
=
moz_math_variant
:
:
none
{
let
mut
font_style
=
self
.
style
.
mutate_font
(
)
;
font_style
.
set_font_weight
(
font_weight
:
:
normal
(
)
)
;
font_style
.
set_font_style
(
font_style
:
:
normal
)
;
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
adjust_for_alignment
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
use
computed_values
:
:
align_items
:
:
T
as
align_items
;
use
computed_values
:
:
align_self
:
:
T
as
align_self
;
if
self
.
style
.
get_position
(
)
.
clone_align_self
(
)
=
=
align_self
:
:
auto
&
&
!
self
.
style
.
out_of_flow_positioned
(
)
{
let
self_align
=
match
layout_parent_style
.
get_position
(
)
.
clone_align_items
(
)
{
align_items
:
:
stretch
=
>
align_self
:
:
stretch
align_items
:
:
baseline
=
>
align_self
:
:
baseline
align_items
:
:
flex_start
=
>
align_self
:
:
flex_start
align_items
:
:
flex_end
=
>
align_self
:
:
flex_end
align_items
:
:
center
=
>
align_self
:
:
center
}
;
self
.
style
.
mutate_position
(
)
.
set_align_self
(
self_align
)
;
}
}
fn
adjust_for_border_width
(
&
mut
self
)
{
properties
:
:
adjust_border_width
(
self
.
style
)
;
}
fn
adjust_for_outline
(
&
mut
self
)
{
if
self
.
style
.
get_outline
(
)
.
clone_outline_style
(
)
.
none_or_hidden
(
)
&
&
self
.
style
.
get_outline
(
)
.
outline_has_nonzero_width
(
)
{
self
.
style
.
mutate_outline
(
)
.
set_outline_width
(
Au
(
0
)
.
into
(
)
)
;
}
}
fn
adjust_for_overflow
(
&
mut
self
)
{
let
original_overflow_x
=
self
.
style
.
get_box
(
)
.
clone_overflow_x
(
)
;
let
original_overflow_y
=
self
.
style
.
get_box
(
)
.
clone_overflow_y
(
)
;
let
mut
overflow_x
=
original_overflow_x
;
let
mut
overflow_y
=
original_overflow_y
;
if
overflow_x
=
=
overflow_y
{
return
;
}
if
overflow_x
=
=
overflow
:
:
visible
{
overflow_x
=
overflow
:
:
auto
;
}
if
overflow_y
=
=
overflow
:
:
visible
{
overflow_y
=
overflow
:
:
auto
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
if
overflow_x
=
=
overflow
:
:
_moz_hidden_unscrollable
{
overflow_x
=
overflow
:
:
hidden
;
}
if
overflow_y
=
=
overflow
:
:
_moz_hidden_unscrollable
{
overflow_y
=
overflow
:
:
hidden
;
}
}
if
overflow_x
!
=
original_overflow_x
|
|
overflow_y
!
=
original_overflow_y
{
let
mut
box_style
=
self
.
style
.
mutate_box
(
)
;
box_style
.
set_overflow_x
(
overflow_x
)
;
box_style
.
set_overflow_y
(
overflow_y
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_prohibited_display_contents
(
&
mut
self
flags
:
CascadeFlags
)
{
use
properties
:
:
PROHIBIT_DISPLAY_CONTENTS
;
if
!
flags
.
contains
(
PROHIBIT_DISPLAY_CONTENTS
)
|
|
self
.
style
.
get_box
(
)
.
clone_display
(
)
!
=
display
:
:
contents
{
return
;
}
self
.
style
.
mutate_box
(
)
.
set_display
(
display
:
:
inline
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_fieldset_content
(
&
mut
self
layout_parent_style
:
&
ComputedValues
flags
:
CascadeFlags
)
{
use
properties
:
:
IS_FIELDSET_CONTENT
;
if
!
flags
.
contains
(
IS_FIELDSET_CONTENT
)
{
return
;
}
debug_assert_eq
!
(
self
.
style
.
get_box
(
)
.
clone_display
(
)
display
:
:
block
)
;
let
parent_display
=
layout_parent_style
.
get_box
(
)
.
clone_display
(
)
;
let
new_display
=
match
parent_display
{
display
:
:
flex
|
display
:
:
inline_flex
=
>
Some
(
display
:
:
flex
)
display
:
:
grid
|
display
:
:
inline_grid
=
>
Some
(
display
:
:
grid
)
_
=
>
None
}
;
if
let
Some
(
new_display
)
=
new_display
{
self
.
style
.
mutate_box
(
)
.
set_display
(
new_display
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_table_text_align
(
&
mut
self
)
{
use
properties
:
:
longhands
:
:
text_align
:
:
computed_value
:
:
T
as
text_align
;
if
self
.
style
.
get_box
(
)
.
clone_display
(
)
!
=
display
:
:
table
{
return
;
}
match
self
.
style
.
get_inheritedtext
(
)
.
clone_text_align
(
)
{
text_align
:
:
_moz_left
|
text_align
:
:
_moz_center
|
text_align
:
:
_moz_right
=
>
{
}
_
=
>
return
}
self
.
style
.
mutate_inheritedtext
(
)
.
set_text_align
(
text_align
:
:
start
)
;
}
fn
adjust_for_text_decoration_lines
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
use
properties
:
:
computed_value_flags
:
:
HAS_TEXT_DECORATION_LINES
;
if
layout_parent_style
.
flags
.
contains
(
HAS_TEXT_DECORATION_LINES
)
|
|
!
self
.
style
.
get_text
(
)
.
clone_text_decoration_line
(
)
.
is_empty
(
)
{
self
.
style
.
flags
.
insert
(
HAS_TEXT_DECORATION_LINES
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
should_suppress_linebreak
(
&
self
layout_parent_style
:
&
ComputedValues
)
-
>
bool
{
use
properties
:
:
computed_value_flags
:
:
SHOULD_SUPPRESS_LINEBREAK
;
if
self
.
style
.
floated
(
)
|
|
self
.
style
.
out_of_flow_positioned
(
)
{
return
false
;
}
let
parent_display
=
layout_parent_style
.
get_box
(
)
.
clone_display
(
)
;
if
layout_parent_style
.
flags
.
contains
(
SHOULD_SUPPRESS_LINEBREAK
)
{
if
parent_display
.
is_line_participant
(
)
{
return
true
;
}
}
match
self
.
style
.
get_box
(
)
.
clone_display
(
)
{
display
:
:
ruby_base
|
display
:
:
ruby_text
=
>
true
display
:
:
ruby_base_container
|
display
:
:
ruby_text_container
=
>
false
_
=
>
parent_display
.
is_ruby_type
(
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_ruby
(
&
mut
self
layout_parent_style
:
&
ComputedValues
flags
:
CascadeFlags
)
{
use
properties
:
:
SKIP_ROOT_AND_ITEM_BASED_DISPLAY_FIXUP
;
use
properties
:
:
computed_value_flags
:
:
SHOULD_SUPPRESS_LINEBREAK
;
use
properties
:
:
longhands
:
:
unicode_bidi
:
:
computed_value
:
:
T
as
unicode_bidi
;
let
self_display
=
self
.
style
.
get_box
(
)
.
clone_display
(
)
;
if
self
.
should_suppress_linebreak
(
layout_parent_style
)
{
self
.
style
.
flags
.
insert
(
SHOULD_SUPPRESS_LINEBREAK
)
;
if
!
flags
.
contains
(
SKIP_ROOT_AND_ITEM_BASED_DISPLAY_FIXUP
)
{
let
inline_display
=
self_display
.
inlinify
(
)
;
if
self_display
!
=
inline_display
{
self
.
style
.
mutate_box
(
)
.
set_display
(
inline_display
)
;
}
}
}
if
self_display
.
is_ruby_level_container
(
)
{
self
.
style
.
reset_border_struct
(
)
;
self
.
style
.
reset_padding_struct
(
)
;
}
if
self_display
.
is_ruby_type
(
)
{
let
new_value
=
match
self
.
style
.
get_text
(
)
.
clone_unicode_bidi
(
)
{
unicode_bidi
:
:
normal
|
unicode_bidi
:
:
embed
=
>
Some
(
unicode_bidi
:
:
isolate
)
unicode_bidi
:
:
bidi_override
=
>
Some
(
unicode_bidi
:
:
isolate_override
)
_
=
>
None
}
;
if
let
Some
(
new_value
)
=
new_value
{
self
.
style
.
mutate_text
(
)
.
set_unicode_bidi
(
new_value
)
;
}
}
}
fn
adjust_for_visited
(
&
mut
self
flags
:
CascadeFlags
)
{
use
properties
:
:
{
IS_LINK
IS_VISITED_LINK
}
;
use
properties
:
:
computed_value_flags
:
:
IS_RELEVANT_LINK_VISITED
;
if
!
self
.
style
.
has_visited_style
(
)
{
return
;
}
let
relevant_link_visited
=
if
flags
.
contains
(
IS_LINK
)
{
flags
.
contains
(
IS_VISITED_LINK
)
}
else
{
self
.
style
.
inherited_flags
(
)
.
contains
(
IS_RELEVANT_LINK_VISITED
)
}
;
if
relevant_link_visited
{
self
.
style
.
flags
.
insert
(
IS_RELEVANT_LINK_VISITED
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_justify_items
(
&
mut
self
)
{
use
values
:
:
specified
:
:
align
;
let
justify_items
=
self
.
style
.
get_position
(
)
.
clone_justify_items
(
)
;
if
justify_items
.
specified
.
0
!
=
align
:
:
ALIGN_AUTO
{
return
;
}
let
parent_justify_items
=
self
.
style
.
get_parent_position
(
)
.
clone_justify_items
(
)
;
if
!
parent_justify_items
.
computed
.
0
.
contains
(
align
:
:
ALIGN_LEGACY
)
{
return
;
}
if
parent_justify_items
.
computed
=
=
justify_items
.
computed
{
return
;
}
self
.
style
.
mutate_position
(
)
.
set_computed_justify_items
(
parent_justify_items
.
computed
)
;
}
pub
fn
adjust
(
&
mut
self
layout_parent_style
:
&
ComputedValues
flags
:
CascadeFlags
)
{
self
.
adjust_for_visited
(
flags
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_prohibited_display_contents
(
flags
)
;
self
.
adjust_for_fieldset_content
(
layout_parent_style
flags
)
;
}
self
.
adjust_for_top_layer
(
)
;
self
.
blockify_if_necessary
(
layout_parent_style
flags
)
;
self
.
adjust_for_position
(
)
;
self
.
adjust_for_overflow
(
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_table_text_align
(
)
;
self
.
adjust_for_contain
(
)
;
self
.
adjust_for_mathvariant
(
)
;
self
.
adjust_for_justify_items
(
)
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
{
self
.
adjust_for_alignment
(
layout_parent_style
)
;
}
self
.
adjust_for_border_width
(
)
;
self
.
adjust_for_outline
(
)
;
self
.
adjust_for_writing_mode
(
layout_parent_style
)
;
self
.
adjust_for_text_decoration_lines
(
layout_parent_style
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_ruby
(
layout_parent_style
flags
)
;
}
self
.
set_bits
(
)
;
}
}
