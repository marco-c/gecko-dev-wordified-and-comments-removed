use
app_units
:
:
Au
;
use
properties
:
:
{
self
ComputedValues
}
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
:
:
T
as
display
;
use
properties
:
:
longhands
:
:
float
:
:
computed_value
:
:
T
as
float
;
use
properties
:
:
longhands
:
:
overflow_x
:
:
computed_value
:
:
T
as
overflow
;
use
properties
:
:
longhands
:
:
position
:
:
computed_value
:
:
T
as
position
;
pub
struct
StyleAdjuster
<
'
a
>
{
style
:
&
'
a
mut
ComputedValues
is_root_element
:
bool
}
impl
<
'
a
>
StyleAdjuster
<
'
a
>
{
pub
fn
new
(
style
:
&
'
a
mut
ComputedValues
is_root_element
:
bool
)
-
>
Self
{
StyleAdjuster
{
style
:
style
is_root_element
:
is_root_element
}
}
fn
adjust_for_top_layer
(
&
mut
self
)
{
if
!
self
.
style
.
out_of_flow_positioned
(
)
&
&
self
.
style
.
in_top_layer
(
)
{
self
.
style
.
mutate_box
(
)
.
set_position
(
position
:
:
absolute
)
;
}
}
fn
adjust_for_position
(
&
mut
self
)
{
if
self
.
style
.
out_of_flow_positioned
(
)
&
&
self
.
style
.
floated
(
)
{
self
.
style
.
mutate_box
(
)
.
set_float
(
float
:
:
none
)
;
}
}
fn
blockify_if_necessary
(
&
mut
self
layout_parent_style
:
&
ComputedValues
skip_root_and_element_display_fixup
:
bool
)
{
let
mut
blockify
=
false
;
macro_rules
!
blockify_if
{
(
if_what
:
expr
)
=
>
{
if
!
blockify
{
blockify
=
if_what
;
}
}
}
if
!
skip_root_and_element_display_fixup
{
blockify_if
!
(
self
.
is_root_element
)
;
blockify_if
!
(
layout_parent_style
.
get_box
(
)
.
clone_display
(
)
.
is_item_container
(
)
)
;
}
let
is_item_or_root
=
blockify
;
blockify_if
!
(
self
.
style
.
floated
(
)
)
;
blockify_if
!
(
self
.
style
.
out_of_flow_positioned
(
)
)
;
if
!
blockify
{
return
;
}
let
display
=
self
.
style
.
get_box
(
)
.
clone_display
(
)
;
let
blockified_display
=
display
.
equivalent_block_display
(
self
.
is_root_element
)
;
if
display
!
=
blockified_display
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
blockified_display
is_item_or_root
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
adjust_for_text
(
&
mut
self
)
{
self
.
adjust_for_text_combine_upright
(
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_text_combine_upright
(
&
mut
self
)
{
use
computed_values
:
:
text_combine_upright
:
:
T
as
text_combine_upright
;
use
computed_values
:
:
writing_mode
:
:
T
as
writing_mode
;
let
writing_mode
=
self
.
style
.
get_inheritedbox
(
)
.
clone_writing_mode
(
)
;
let
text_combine_upright
=
self
.
style
.
get_inheritedtext
(
)
.
clone_text_combine_upright
(
)
;
if
writing_mode
!
=
writing_mode
:
:
horizontal_tb
&
&
text_combine_upright
=
=
text_combine_upright
:
:
all
{
self
.
style
.
mutate_inheritedbox
(
)
.
set_writing_mode
(
writing_mode
:
:
horizontal_tb
)
;
}
}
fn
adjust_for_writing_mode
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
let
our_writing_mode
=
self
.
style
.
get_inheritedbox
(
)
.
clone_writing_mode
(
)
;
let
parent_writing_mode
=
layout_parent_style
.
get_inheritedbox
(
)
.
clone_writing_mode
(
)
;
if
our_writing_mode
!
=
parent_writing_mode
&
&
self
.
style
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
inline
{
self
.
style
.
mutate_box
(
)
.
set_display
(
display
:
:
inline_block
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
adjust_for_contain
(
&
mut
self
)
{
use
properties
:
:
longhands
:
:
contain
;
let
contain
=
self
.
style
.
get_box
(
)
.
clone_contain
(
)
;
if
!
contain
.
contains
(
contain
:
:
PAINT
)
{
return
;
}
if
self
.
style
.
get_box
(
)
.
clone_display
(
)
=
=
display
:
:
inline
{
self
.
style
.
mutate_box
(
)
.
set_adjusted_display
(
display
:
:
inline_block
false
)
;
}
if
self
.
style
.
get_box
(
)
.
clone_contain
(
)
.
contains
(
contain
:
:
PAINT
)
{
if
self
.
style
.
get_box
(
)
.
clone_overflow_x
(
)
=
=
overflow
:
:
visible
{
let
mut
box_style
=
self
.
style
.
mutate_box
(
)
;
box_style
.
set_overflow_x
(
overflow
:
:
_moz_hidden_unscrollable
)
;
box_style
.
set_overflow_y
(
overflow
:
:
_moz_hidden_unscrollable
)
;
}
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
adjust_for_alignment
(
&
mut
self
layout_parent_style
:
&
ComputedValues
)
{
use
computed_values
:
:
align_items
:
:
T
as
align_items
;
use
computed_values
:
:
align_self
:
:
T
as
align_self
;
if
self
.
style
.
get_position
(
)
.
clone_align_self
(
)
=
=
align_self
:
:
auto
&
&
!
self
.
style
.
out_of_flow_positioned
(
)
{
let
self_align
=
match
layout_parent_style
.
get_position
(
)
.
clone_align_items
(
)
{
align_items
:
:
stretch
=
>
align_self
:
:
stretch
align_items
:
:
baseline
=
>
align_self
:
:
baseline
align_items
:
:
flex_start
=
>
align_self
:
:
flex_start
align_items
:
:
flex_end
=
>
align_self
:
:
flex_end
align_items
:
:
center
=
>
align_self
:
:
center
}
;
self
.
style
.
mutate_position
(
)
.
set_align_self
(
self_align
)
;
}
}
fn
adjust_for_border_width
(
&
mut
self
)
{
properties
:
:
adjust_border_width
(
self
.
style
)
;
}
fn
adjust_for_outline
(
&
mut
self
)
{
if
self
.
style
.
get_outline
(
)
.
clone_outline_style
(
)
.
none_or_hidden
(
)
&
&
self
.
style
.
get_outline
(
)
.
outline_has_nonzero_width
(
)
{
self
.
style
.
mutate_outline
(
)
.
set_outline_width
(
Au
(
0
)
)
;
}
}
fn
adjust_for_overflow
(
&
mut
self
)
{
let
original_overflow_x
=
self
.
style
.
get_box
(
)
.
clone_overflow_x
(
)
;
let
original_overflow_y
=
self
.
style
.
get_box
(
)
.
clone_overflow_y
(
)
;
let
mut
overflow_x
=
original_overflow_x
;
let
mut
overflow_y
=
original_overflow_y
;
if
overflow_x
=
=
overflow_y
{
return
;
}
if
overflow_x
=
=
overflow
:
:
visible
{
overflow_x
=
overflow
:
:
auto
;
}
if
overflow_y
=
=
overflow
:
:
visible
{
overflow_y
=
overflow
:
:
auto
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
if
overflow_x
=
=
overflow
:
:
_moz_hidden_unscrollable
{
overflow_x
=
overflow
:
:
hidden
;
}
if
overflow_y
=
=
overflow
:
:
_moz_hidden_unscrollable
{
overflow_y
=
overflow
:
:
hidden
;
}
}
if
overflow_x
!
=
original_overflow_x
|
|
overflow_y
!
=
original_overflow_y
{
let
mut
box_style
=
self
.
style
.
mutate_box
(
)
;
box_style
.
set_overflow_x
(
overflow_x
)
;
box_style
.
set_overflow_y
(
overflow_y
)
;
}
}
pub
fn
adjust
(
mut
self
layout_parent_style
:
&
ComputedValues
skip_root_and_element_display_fixup
:
bool
)
{
self
.
adjust_for_top_layer
(
)
;
self
.
blockify_if_necessary
(
layout_parent_style
skip_root_and_element_display_fixup
)
;
self
.
adjust_for_position
(
)
;
self
.
adjust_for_overflow
(
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
adjust_for_contain
(
)
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
{
self
.
adjust_for_alignment
(
layout_parent_style
)
;
}
self
.
adjust_for_border_width
(
)
;
self
.
adjust_for_outline
(
)
;
self
.
adjust_for_writing_mode
(
layout_parent_style
)
;
}
}
