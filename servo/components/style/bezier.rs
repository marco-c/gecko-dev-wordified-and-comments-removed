#
!
[
deny
(
missing_docs
)
]
use
euclid
:
:
point
:
:
Point2D
;
const
NEWTON_METHOD_ITERATIONS
:
u8
=
8
;
pub
struct
Bezier
{
ax
:
f64
bx
:
f64
cx
:
f64
ay
:
f64
by
:
f64
cy
:
f64
}
impl
Bezier
{
#
[
inline
]
pub
fn
new
(
p1
:
Point2D
<
f64
>
p2
:
Point2D
<
f64
>
)
-
>
Bezier
{
let
cx
=
3
.
0
*
p1
.
x
;
let
bx
=
3
.
0
*
(
p2
.
x
-
p1
.
x
)
-
cx
;
let
cy
=
3
.
0
*
p1
.
y
;
let
by
=
3
.
0
*
(
p2
.
y
-
p1
.
y
)
-
cy
;
Bezier
{
ax
:
1
.
0
-
cx
-
bx
bx
:
bx
cx
:
cx
ay
:
1
.
0
-
cy
-
by
by
:
by
cy
:
cy
}
}
#
[
inline
]
fn
sample_curve_x
(
&
self
t
:
f64
)
-
>
f64
{
(
(
self
.
ax
*
t
+
self
.
bx
)
*
t
+
self
.
cx
)
*
t
}
#
[
inline
]
fn
sample_curve_y
(
&
self
t
:
f64
)
-
>
f64
{
(
(
self
.
ay
*
t
+
self
.
by
)
*
t
+
self
.
cy
)
*
t
}
#
[
inline
]
fn
sample_curve_derivative_x
(
&
self
t
:
f64
)
-
>
f64
{
(
3
.
0
*
self
.
ax
*
t
+
2
.
0
*
self
.
bx
)
*
t
+
self
.
cx
}
#
[
inline
]
fn
solve_curve_x
(
&
self
x
:
f64
epsilon
:
f64
)
-
>
f64
{
let
mut
t
=
x
;
for
_
in
0
.
.
NEWTON_METHOD_ITERATIONS
{
let
x2
=
self
.
sample_curve_x
(
t
)
;
if
x2
.
approx_eq
(
x
epsilon
)
{
return
t
}
let
dx
=
self
.
sample_curve_derivative_x
(
t
)
;
if
dx
.
approx_eq
(
0
.
0
1e
-
6
)
{
break
}
t
-
=
(
x2
-
x
)
/
dx
;
}
let
(
mut
lo
mut
hi
mut
t
)
=
(
0
.
0
1
.
0
x
)
;
if
t
<
lo
{
return
lo
}
if
t
>
hi
{
return
hi
}
while
lo
<
hi
{
let
x2
=
self
.
sample_curve_x
(
t
)
;
if
x2
.
approx_eq
(
x
epsilon
)
{
return
t
}
if
x
>
x2
{
lo
=
t
}
else
{
hi
=
t
}
t
=
(
hi
-
lo
)
/
2
.
0
+
lo
}
t
}
#
[
inline
]
pub
fn
solve
(
&
self
x
:
f64
epsilon
:
f64
)
-
>
f64
{
self
.
sample_curve_y
(
self
.
solve_curve_x
(
x
epsilon
)
)
}
}
trait
ApproxEq
{
fn
approx_eq
(
self
value
:
Self
epsilon
:
Self
)
-
>
bool
;
}
impl
ApproxEq
for
f64
{
#
[
inline
]
fn
approx_eq
(
self
value
:
f64
epsilon
:
f64
)
-
>
bool
{
(
self
-
value
)
.
abs
(
)
<
epsilon
}
}
