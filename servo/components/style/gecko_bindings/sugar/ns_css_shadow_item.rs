use
app_units
:
:
Au
;
use
gecko
:
:
values
:
:
{
convert_rgba_to_nscolor
convert_nscolor_to_rgba
}
;
use
gecko_bindings
:
:
structs
:
:
nsCSSShadowItem
;
use
values
:
:
computed
:
:
{
Color
Shadow
}
;
use
values
:
:
computed
:
:
effects
:
:
SimpleShadow
;
impl
nsCSSShadowItem
{
pub
fn
set_from_shadow
(
&
mut
self
other
:
Shadow
)
{
self
.
mXOffset
=
other
.
offset_x
.
0
;
self
.
mYOffset
=
other
.
offset_y
.
0
;
self
.
mRadius
=
other
.
blur_radius
.
0
;
self
.
mSpread
=
other
.
spread_radius
.
0
;
self
.
mInset
=
other
.
inset
;
if
other
.
color
.
is_currentcolor
(
)
{
self
.
mHasColor
=
false
;
self
.
mColor
=
0
;
}
else
{
self
.
mHasColor
=
true
;
self
.
mColor
=
convert_rgba_to_nscolor
(
&
other
.
color
.
color
)
;
}
}
pub
fn
to_shadow
(
&
self
)
-
>
Shadow
{
Shadow
{
offset_x
:
Au
(
self
.
mXOffset
)
offset_y
:
Au
(
self
.
mYOffset
)
blur_radius
:
Au
(
self
.
mRadius
)
spread_radius
:
Au
(
self
.
mSpread
)
inset
:
self
.
mInset
color
:
Color
:
:
rgba
(
convert_nscolor_to_rgba
(
self
.
mColor
)
)
}
}
#
[
inline
]
pub
fn
set_from_simple_shadow
(
&
mut
self
shadow
:
SimpleShadow
)
{
self
.
mXOffset
=
shadow
.
horizontal
.
0
;
self
.
mYOffset
=
shadow
.
vertical
.
0
;
self
.
mRadius
=
shadow
.
blur
.
0
;
self
.
mSpread
=
0
;
self
.
mInset
=
false
;
if
shadow
.
color
.
is_currentcolor
(
)
{
self
.
mHasColor
=
false
;
self
.
mColor
=
0
;
}
else
{
self
.
mHasColor
=
true
;
self
.
mColor
=
convert_rgba_to_nscolor
(
&
shadow
.
color
.
color
)
;
}
}
#
[
inline
]
pub
fn
to_simple_shadow
(
&
self
)
-
>
SimpleShadow
{
debug_assert_eq
!
(
self
.
mSpread
0
)
;
debug_assert_eq
!
(
self
.
mInset
false
)
;
SimpleShadow
{
color
:
Color
:
:
rgba
(
convert_nscolor_to_rgba
(
self
.
mColor
)
)
horizontal
:
Au
(
self
.
mXOffset
)
vertical
:
Au
(
self
.
mYOffset
)
blur
:
Au
(
self
.
mRadius
)
}
}
}
