use
gecko_bindings
:
:
bindings
;
use
gecko_bindings
:
:
structs
:
:
{
nsTArray
nsTArrayHeader
}
;
use
std
:
:
mem
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
os
:
:
raw
:
:
c_void
;
use
std
:
:
slice
;
impl
<
T
>
Deref
for
nsTArray
<
T
>
{
type
Target
=
[
T
]
;
fn
deref
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
[
T
]
{
unsafe
{
slice
:
:
from_raw_parts
(
self
.
slice_begin
(
)
self
.
header
(
)
.
mLength
as
usize
)
}
}
}
impl
<
T
>
DerefMut
for
nsTArray
<
T
>
{
fn
deref_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
[
T
]
{
unsafe
{
slice
:
:
from_raw_parts_mut
(
self
.
slice_begin
(
)
self
.
header
(
)
.
mLength
as
usize
)
}
}
}
impl
<
T
>
nsTArray
<
T
>
{
#
[
inline
]
fn
header
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
nsTArrayHeader
{
debug_assert
!
(
!
self
.
mBuffer
.
is_null
(
)
)
;
unsafe
{
mem
:
:
transmute
(
self
.
mBuffer
)
}
}
unsafe
fn
header_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
nsTArrayHeader
{
debug_assert
!
(
!
self
.
mBuffer
.
is_null
(
)
)
;
mem
:
:
transmute
(
self
.
mBuffer
)
}
#
[
inline
]
unsafe
fn
slice_begin
(
&
self
)
-
>
*
mut
T
{
debug_assert
!
(
!
self
.
mBuffer
.
is_null
(
)
)
;
(
self
.
mBuffer
as
*
const
nsTArrayHeader
)
.
offset
(
1
)
as
*
mut
_
}
pub
fn
ensure_capacity
(
&
mut
self
cap
:
usize
)
{
if
cap
>
=
self
.
len
(
)
{
unsafe
{
bindings
:
:
Gecko_EnsureTArrayCapacity
(
self
as
*
mut
nsTArray
<
T
>
as
*
mut
_
cap
mem
:
:
size_of
:
:
<
T
>
(
)
)
}
}
}
#
[
inline
]
pub
unsafe
fn
clear
(
&
mut
self
)
{
if
self
.
len
(
)
!
=
0
{
bindings
:
:
Gecko_ClearPODTArray
(
self
as
*
mut
nsTArray
<
T
>
as
*
mut
_
mem
:
:
size_of
:
:
<
T
>
(
)
mem
:
:
align_of
:
:
<
T
>
(
)
)
;
}
}
#
[
inline
]
pub
fn
clear_pod
(
&
mut
self
)
where
T
:
Copy
{
unsafe
{
self
.
clear
(
)
}
}
pub
unsafe
fn
set_len
(
&
mut
self
len
:
u32
)
{
debug_assert
!
(
len
>
=
self
.
len
(
)
as
u32
)
;
self
.
ensure_capacity
(
len
as
usize
)
;
let
mut
header
=
self
.
header_mut
(
)
;
header
.
mLength
=
len
;
}
}
