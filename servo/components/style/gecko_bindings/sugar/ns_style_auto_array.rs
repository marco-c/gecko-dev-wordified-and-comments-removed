use
gecko_bindings
:
:
bindings
:
:
Gecko_EnsureStyleAnimationArrayLength
;
use
gecko_bindings
:
:
structs
:
:
nsStyleAutoArray
;
use
std
:
:
iter
:
:
{
once
Chain
Once
IntoIterator
}
;
use
std
:
:
ops
:
:
{
Index
IndexMut
}
;
use
std
:
:
slice
:
:
{
Iter
IterMut
}
;
impl
<
T
>
Index
<
usize
>
for
nsStyleAutoArray
<
T
>
{
type
Output
=
T
;
fn
index
(
&
self
index
:
usize
)
-
>
&
T
{
if
index
>
self
.
len
(
)
{
panic
!
(
"
out
of
range
"
)
}
match
index
{
0
=
>
&
self
.
mFirstElement
_
=
>
&
self
.
mOtherElements
[
index
-
1
]
}
}
}
impl
<
T
>
IndexMut
<
usize
>
for
nsStyleAutoArray
<
T
>
{
fn
index_mut
(
&
mut
self
index
:
usize
)
-
>
&
mut
T
{
if
index
>
self
.
len
(
)
{
panic
!
(
"
out
of
range
"
)
}
match
index
{
0
=
>
&
mut
self
.
mFirstElement
_
=
>
&
mut
self
.
mOtherElements
[
index
-
1
]
}
}
}
impl
<
T
>
nsStyleAutoArray
<
T
>
{
pub
fn
iter_mut
(
&
mut
self
)
-
>
Chain
<
Once
<
&
mut
T
>
IterMut
<
T
>
>
{
once
(
&
mut
self
.
mFirstElement
)
.
chain
(
self
.
mOtherElements
.
iter_mut
(
)
)
}
pub
fn
iter
(
&
self
)
-
>
Chain
<
Once
<
&
T
>
Iter
<
T
>
>
{
once
(
&
self
.
mFirstElement
)
.
chain
(
self
.
mOtherElements
.
iter
(
)
)
}
pub
fn
len
(
&
self
)
-
>
usize
{
1
+
self
.
mOtherElements
.
len
(
)
}
pub
fn
ensure_len
(
&
mut
self
len
:
usize
)
{
unsafe
{
Gecko_EnsureStyleAnimationArrayLength
(
self
as
*
mut
nsStyleAutoArray
<
T
>
as
*
mut
_
len
)
;
}
}
}
impl
<
'
a
T
>
IntoIterator
for
&
'
a
mut
nsStyleAutoArray
<
T
>
{
type
Item
=
&
'
a
mut
T
;
type
IntoIter
=
Chain
<
Once
<
&
'
a
mut
T
>
IterMut
<
'
a
T
>
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
iter_mut
(
)
}
}
