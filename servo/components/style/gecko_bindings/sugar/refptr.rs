use
crate
:
:
gecko_bindings
:
:
{
bindings
structs
}
;
use
crate
:
:
Atom
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
:
:
Write
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
{
fmt
mem
ptr
}
;
pub
unsafe
trait
RefCounted
{
fn
addref
(
&
self
)
;
unsafe
fn
release
(
&
self
)
;
}
pub
unsafe
trait
ThreadSafeRefCounted
:
RefCounted
{
}
pub
struct
RefPtr
<
T
:
RefCounted
>
{
ptr
:
*
mut
T
_marker
:
PhantomData
<
T
>
}
impl
<
T
:
RefCounted
>
fmt
:
:
Debug
for
RefPtr
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
RefPtr
{
"
)
?
;
self
.
ptr
.
fmt
(
f
)
?
;
f
.
write_char
(
'
}
'
)
}
}
impl
<
T
:
RefCounted
>
RefPtr
<
T
>
{
pub
unsafe
fn
from_addrefed
(
ptr
:
*
mut
T
)
-
>
Self
{
debug_assert
!
(
!
ptr
.
is_null
(
)
)
;
RefPtr
{
ptr
_marker
:
PhantomData
}
}
pub
fn
is_null
(
&
self
)
-
>
bool
{
self
.
ptr
.
is_null
(
)
}
pub
fn
null
(
)
-
>
Self
{
Self
{
ptr
:
ptr
:
:
null_mut
(
)
_marker
:
PhantomData
}
}
pub
unsafe
fn
new
(
ptr
:
*
mut
T
)
-
>
Self
{
let
ret
=
RefPtr
{
ptr
_marker
:
PhantomData
}
;
ret
.
addref
(
)
;
ret
}
pub
fn
forget
(
self
)
-
>
structs
:
:
RefPtr
<
T
>
{
let
ret
=
structs
:
:
RefPtr
{
mRawPtr
:
self
.
ptr
_phantom_0
:
PhantomData
}
;
mem
:
:
forget
(
self
)
;
ret
}
pub
fn
get
(
&
self
)
-
>
*
mut
T
{
self
.
ptr
}
pub
fn
addref
(
&
self
)
{
if
!
self
.
ptr
.
is_null
(
)
{
unsafe
{
(
*
self
.
ptr
)
.
addref
(
)
;
}
}
}
pub
unsafe
fn
release
(
&
self
)
{
if
!
self
.
ptr
.
is_null
(
)
{
(
*
self
.
ptr
)
.
release
(
)
;
}
}
}
impl
<
T
:
RefCounted
>
Deref
for
RefPtr
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
debug_assert
!
(
!
self
.
ptr
.
is_null
(
)
)
;
unsafe
{
&
*
self
.
ptr
}
}
}
impl
<
T
:
RefCounted
>
structs
:
:
RefPtr
<
T
>
{
pub
unsafe
fn
to_safe
(
&
self
)
-
>
RefPtr
<
T
>
{
let
r
=
RefPtr
{
ptr
:
self
.
mRawPtr
_marker
:
PhantomData
}
;
r
.
addref
(
)
;
r
}
pub
unsafe
fn
into_safe
(
self
)
-
>
RefPtr
<
T
>
{
debug_assert
!
(
!
self
.
mRawPtr
.
is_null
(
)
)
;
RefPtr
{
ptr
:
self
.
mRawPtr
_marker
:
PhantomData
}
}
pub
unsafe
fn
set
(
&
mut
self
other
:
&
Self
)
{
self
.
clear
(
)
;
if
!
other
.
mRawPtr
.
is_null
(
)
{
*
self
=
other
.
to_safe
(
)
.
forget
(
)
;
}
}
pub
unsafe
fn
clear
(
&
mut
self
)
{
if
!
self
.
mRawPtr
.
is_null
(
)
{
(
*
self
.
mRawPtr
)
.
release
(
)
;
self
.
mRawPtr
=
ptr
:
:
null_mut
(
)
;
}
}
pub
fn
set_move
(
&
mut
self
other
:
RefPtr
<
T
>
)
{
if
!
self
.
mRawPtr
.
is_null
(
)
{
unsafe
{
(
*
self
.
mRawPtr
)
.
release
(
)
;
}
}
*
self
=
other
.
forget
(
)
;
}
}
impl
<
T
>
structs
:
:
RefPtr
<
T
>
{
pub
fn
null
(
)
-
>
Self
{
Self
{
mRawPtr
:
ptr
:
:
null_mut
(
)
_phantom_0
:
PhantomData
}
}
pub
fn
from_arc
(
s
:
Arc
<
T
>
)
-
>
Self
{
Self
{
mRawPtr
:
Arc
:
:
into_raw
(
s
)
as
*
mut
_
_phantom_0
:
PhantomData
}
}
pub
fn
set_arc
(
&
mut
self
other
:
Arc
<
T
>
)
{
unsafe
{
if
!
self
.
mRawPtr
.
is_null
(
)
{
let
_
=
Arc
:
:
from_raw
(
self
.
mRawPtr
)
;
}
self
.
mRawPtr
=
Arc
:
:
into_raw
(
other
)
as
*
mut
_
;
}
}
}
impl
<
T
:
RefCounted
>
Drop
for
RefPtr
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
release
(
)
}
}
}
impl
<
T
:
RefCounted
>
Clone
for
RefPtr
<
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
self
.
addref
(
)
;
RefPtr
{
ptr
:
self
.
ptr
_marker
:
PhantomData
}
}
}
impl
<
T
:
RefCounted
>
PartialEq
for
RefPtr
<
T
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
ptr
=
=
other
.
ptr
}
}
unsafe
impl
<
T
:
ThreadSafeRefCounted
>
Send
for
RefPtr
<
T
>
{
}
unsafe
impl
<
T
:
ThreadSafeRefCounted
>
Sync
for
RefPtr
<
T
>
{
}
macro_rules
!
impl_refcount
{
(
t
:
ty
addref
:
path
release
:
path
)
=
>
{
unsafe
impl
RefCounted
for
t
{
#
[
inline
]
fn
addref
(
&
self
)
{
unsafe
{
addref
(
self
as
*
const
_
as
*
mut
_
)
}
}
#
[
inline
]
unsafe
fn
release
(
&
self
)
{
release
(
self
as
*
const
_
as
*
mut
_
)
}
}
}
;
}
macro_rules
!
impl_threadsafe_refcount
{
(
t
:
ty
addref
:
path
release
:
path
)
=
>
{
impl_refcount
!
(
t
addref
release
)
;
unsafe
impl
ThreadSafeRefCounted
for
t
{
}
}
;
}
impl_threadsafe_refcount
!
(
structs
:
:
mozilla
:
:
URLExtraData
bindings
:
:
Gecko_AddRefURLExtraDataArbitraryThread
bindings
:
:
Gecko_ReleaseURLExtraDataArbitraryThread
)
;
impl_threadsafe_refcount
!
(
structs
:
:
nsIURI
bindings
:
:
Gecko_AddRefnsIURIArbitraryThread
bindings
:
:
Gecko_ReleasensIURIArbitraryThread
)
;
impl_threadsafe_refcount
!
(
structs
:
:
SheetLoadDataHolder
bindings
:
:
Gecko_AddRefSheetLoadDataHolderArbitraryThread
bindings
:
:
Gecko_ReleaseSheetLoadDataHolderArbitraryThread
)
;
#
[
inline
]
unsafe
fn
addref_atom
(
atom
:
*
mut
structs
:
:
nsAtom
)
{
mem
:
:
forget
(
Atom
:
:
from_raw
(
atom
)
)
;
}
#
[
inline
]
unsafe
fn
release_atom
(
atom
:
*
mut
structs
:
:
nsAtom
)
{
let
_
=
Atom
:
:
from_addrefed
(
atom
)
;
}
impl_threadsafe_refcount
!
(
structs
:
:
nsAtom
addref_atom
release_atom
)
;
