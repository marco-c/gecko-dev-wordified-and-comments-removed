use
gecko_bindings
:
:
structs
;
use
heapsize
:
:
HeapSizeOf
;
use
std
:
:
{
mem
ptr
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
pub
unsafe
trait
RefCounted
{
fn
addref
(
&
self
)
;
unsafe
fn
release
(
&
self
)
;
}
pub
unsafe
trait
ThreadSafeRefCounted
:
RefCounted
{
}
#
[
derive
(
Debug
)
]
pub
struct
RefPtr
<
T
:
RefCounted
>
{
ptr
:
*
mut
T
_marker
:
PhantomData
<
T
>
}
pub
struct
UniqueRefPtr
<
T
:
RefCounted
>
(
RefPtr
<
T
>
)
;
impl
<
T
:
RefCounted
>
RefPtr
<
T
>
{
pub
unsafe
fn
from_addrefed
(
ptr
:
*
mut
T
)
-
>
Self
{
debug_assert
!
(
!
ptr
.
is_null
(
)
)
;
RefPtr
{
ptr
:
ptr
_marker
:
PhantomData
}
}
pub
unsafe
fn
new
(
ptr
:
*
mut
T
)
-
>
Self
{
debug_assert
!
(
!
ptr
.
is_null
(
)
)
;
let
ret
=
RefPtr
{
ptr
:
ptr
_marker
:
PhantomData
}
;
ret
.
addref
(
)
;
ret
}
pub
fn
forget
(
self
)
-
>
structs
:
:
RefPtr
<
T
>
{
let
ret
=
structs
:
:
RefPtr
{
mRawPtr
:
self
.
ptr
}
;
mem
:
:
forget
(
self
)
;
ret
}
pub
fn
get
(
&
self
)
-
>
*
mut
T
{
self
.
ptr
}
pub
fn
addref
(
&
self
)
{
unsafe
{
(
*
self
.
ptr
)
.
addref
(
)
;
}
}
pub
unsafe
fn
release
(
&
self
)
{
(
*
self
.
ptr
)
.
release
(
)
;
}
}
impl
<
T
:
RefCounted
>
UniqueRefPtr
<
T
>
{
pub
unsafe
fn
from_addrefed
(
ptr
:
*
mut
T
)
-
>
Self
{
UniqueRefPtr
(
RefPtr
:
:
from_addrefed
(
ptr
)
)
}
pub
fn
get
(
self
)
-
>
RefPtr
<
T
>
{
self
.
0
}
}
impl
<
T
:
RefCounted
>
Deref
for
RefPtr
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
&
*
self
.
ptr
}
}
}
impl
<
T
:
RefCounted
>
Deref
for
UniqueRefPtr
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
&
*
self
.
0
.
ptr
}
}
}
impl
<
T
:
RefCounted
>
DerefMut
for
UniqueRefPtr
<
T
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
T
{
unsafe
{
&
mut
*
self
.
0
.
ptr
}
}
}
impl
<
T
:
RefCounted
>
structs
:
:
RefPtr
<
T
>
{
pub
unsafe
fn
to_safe
(
&
self
)
-
>
RefPtr
<
T
>
{
debug_assert
!
(
!
self
.
mRawPtr
.
is_null
(
)
)
;
let
r
=
RefPtr
{
ptr
:
self
.
mRawPtr
_marker
:
PhantomData
}
;
r
.
addref
(
)
;
r
}
pub
unsafe
fn
into_safe
(
self
)
-
>
RefPtr
<
T
>
{
debug_assert
!
(
!
self
.
mRawPtr
.
is_null
(
)
)
;
RefPtr
{
ptr
:
self
.
mRawPtr
_marker
:
PhantomData
}
}
pub
unsafe
fn
set
(
&
mut
self
other
:
&
Self
)
{
self
.
clear
(
)
;
if
!
other
.
mRawPtr
.
is_null
(
)
{
*
self
=
other
.
to_safe
(
)
.
forget
(
)
;
}
}
pub
unsafe
fn
clear
(
&
mut
self
)
{
if
!
self
.
mRawPtr
.
is_null
(
)
{
(
*
self
.
mRawPtr
)
.
release
(
)
;
self
.
mRawPtr
=
ptr
:
:
null_mut
(
)
;
}
}
pub
fn
set_move
(
&
mut
self
other
:
RefPtr
<
T
>
)
{
if
!
self
.
mRawPtr
.
is_null
(
)
{
unsafe
{
(
*
self
.
mRawPtr
)
.
release
(
)
;
}
}
*
self
=
other
.
forget
(
)
;
}
}
impl
<
T
:
RefCounted
>
Drop
for
RefPtr
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
release
(
)
}
}
}
impl
<
T
:
RefCounted
>
Clone
for
RefPtr
<
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
self
.
addref
(
)
;
RefPtr
{
ptr
:
self
.
ptr
_marker
:
PhantomData
}
}
}
impl
<
T
:
RefCounted
>
HeapSizeOf
for
RefPtr
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
impl
<
T
:
RefCounted
>
PartialEq
for
RefPtr
<
T
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
ptr
=
=
other
.
ptr
}
}
unsafe
impl
<
T
:
ThreadSafeRefCounted
>
Send
for
RefPtr
<
T
>
{
}
unsafe
impl
<
T
:
ThreadSafeRefCounted
>
Sync
for
RefPtr
<
T
>
{
}
macro_rules
!
impl_threadsafe_refcount
{
(
t
:
ty
addref
:
ident
release
:
ident
)
=
>
(
unsafe
impl
RefCounted
for
t
{
fn
addref
(
&
self
)
{
unsafe
{
:
:
gecko_bindings
:
:
bindings
:
:
addref
(
self
as
*
const
_
as
*
mut
_
)
}
}
unsafe
fn
release
(
&
self
)
{
:
:
gecko_bindings
:
:
bindings
:
:
release
(
self
as
*
const
_
as
*
mut
_
)
}
}
unsafe
impl
ThreadSafeRefCounted
for
t
{
}
)
;
}
impl_threadsafe_refcount
!
(
:
:
gecko_bindings
:
:
bindings
:
:
ThreadSafePrincipalHolder
Gecko_AddRefPrincipalArbitraryThread
Gecko_ReleasePrincipalArbitraryThread
)
;
impl_threadsafe_refcount
!
(
:
:
gecko_bindings
:
:
bindings
:
:
ThreadSafeURIHolder
Gecko_AddRefURIArbitraryThread
Gecko_ReleaseURIArbitraryThread
)
;
impl_threadsafe_refcount
!
(
:
:
gecko_bindings
:
:
structs
:
:
nsStyleQuoteValues
Gecko_AddRefQuoteValuesArbitraryThread
Gecko_ReleaseQuoteValuesArbitraryThread
)
;
impl_threadsafe_refcount
!
(
:
:
gecko_bindings
:
:
structs
:
:
nsCSSValueSharedList
Gecko_AddRefCSSValueSharedListArbitraryThread
Gecko_ReleaseCSSValueSharedListArbitraryThread
)
;
pub
type
GeckoArcPrincipal
=
RefPtr
<
:
:
gecko_bindings
:
:
bindings
:
:
ThreadSafePrincipalHolder
>
;
pub
type
GeckoArcURI
=
RefPtr
<
:
:
gecko_bindings
:
:
bindings
:
:
ThreadSafeURIHolder
>
;
