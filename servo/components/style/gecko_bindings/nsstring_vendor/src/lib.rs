#
!
[
allow
(
non_camel_case_types
)
]
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
slice
;
use
std
:
:
ptr
;
use
std
:
:
mem
;
use
std
:
:
fmt
;
use
std
:
:
cmp
;
use
std
:
:
str
;
use
std
:
:
u32
;
const
F_NONE
:
u32
=
0
;
const
F_TERMINATED
:
u32
=
1
<
<
0
;
const
F_VOIDED
:
u32
=
1
<
<
1
;
const
F_SHARED
:
u32
=
1
<
<
2
;
const
F_OWNED
:
u32
=
1
<
<
3
;
const
F_FIXED
:
u32
=
1
<
<
4
;
const
F_LITERAL
:
u32
=
1
<
<
5
;
const
F_CLASS_FIXED
:
u32
=
1
<
<
16
;
macro_rules
!
define_string_types
{
{
char_t
=
char_t
:
ty
;
AString
=
AString
:
ident
;
String
=
String
:
ident
;
FixedString
=
FixedString
:
ident
;
StringRepr
=
StringRepr
:
ident
;
FixedStringRepr
=
FixedStringRepr
:
ident
;
AutoStringRepr
=
AutoStringRepr
:
ident
;
}
=
>
{
/
/
/
The
representation
of
a
ns
[
C
]
String
type
in
C
+
+
.
This
type
is
/
/
/
used
internally
by
our
definition
of
ns
[
C
]
String
to
ensure
layout
/
/
/
compatibility
with
the
C
+
+
ns
[
C
]
String
type
.
/
/
/
/
/
/
This
type
may
also
be
used
in
place
of
a
C
+
+
ns
[
C
]
String
inside
of
/
/
/
struct
definitions
which
are
shared
with
C
+
+
as
it
has
identical
/
/
/
layout
to
our
ns
[
C
]
String
type
.
Due
to
drop
flags
our
ns
[
C
]
String
/
/
/
type
does
not
have
identical
layout
.
When
drop
flags
are
removed
/
/
/
this
type
will
likely
be
made
a
private
implementation
detail
and
/
/
/
its
uses
will
be
replaced
with
ns
[
C
]
String
.
/
/
/
/
/
/
This
struct
will
leak
its
data
if
dropped
from
rust
.
See
the
module
/
/
/
documentation
for
more
information
on
this
type
.
#
[
repr
(
C
)
]
#
[
derive
(
Debug
)
]
pub
struct
StringRepr
{
data
:
*
const
char_t
length
:
u32
flags
:
u32
}
impl
Deref
for
StringRepr
{
type
Target
=
AString
;
fn
deref
(
&
self
)
-
>
&
AString
{
unsafe
{
mem
:
:
transmute
(
self
)
}
}
}
impl
DerefMut
for
StringRepr
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
AString
{
unsafe
{
mem
:
:
transmute
(
self
)
}
}
}
/
/
/
The
representation
of
a
nsFixed
[
C
]
String
type
in
C
+
+
.
This
type
is
/
/
/
used
internally
by
our
definition
of
nsFixed
[
C
]
String
to
ensure
layout
/
/
/
compatibility
with
the
C
+
+
nsFixed
[
C
]
String
type
.
#
[
repr
(
C
)
]
#
[
derive
(
Debug
)
]
struct
FixedStringRepr
{
base
:
StringRepr
capacity
:
u32
buffer
:
*
mut
char_t
}
/
/
/
This
type
is
the
abstract
type
which
is
used
for
interacting
with
/
/
/
strings
in
rust
.
Each
string
type
can
derefence
to
an
instance
of
/
/
/
this
type
which
provides
the
useful
operations
on
strings
.
/
/
/
/
/
/
NOTE
:
Rust
thinks
this
type
has
a
size
of
0
because
the
data
/
/
/
associated
with
it
is
not
necessarially
safe
to
move
.
It
is
not
safe
/
/
/
to
construct
a
nsAString
yourself
unless
it
is
received
by
/
/
/
dereferencing
one
of
these
types
.
/
/
/
/
/
/
NOTE
:
The
[
u8
;
0
]
member
is
zero
sized
and
only
exists
to
prevent
/
/
/
the
construction
by
code
outside
of
this
module
.
It
is
used
instead
/
/
/
of
a
private
(
)
member
because
the
improper_ctypes
lint
complains
/
/
/
about
some
ZST
members
in
extern
"
C
"
function
declarations
.
#
[
repr
(
C
)
]
pub
struct
AString
{
_prohibit_constructor
:
[
u8
;
0
]
}
impl
Deref
for
AString
{
type
Target
=
[
char_t
]
;
fn
deref
(
&
self
)
-
>
&
[
char_t
]
{
unsafe
{
/
/
This
is
legal
as
all
AString
values
actually
point
to
a
/
/
StringRepr
let
this
:
&
StringRepr
=
mem
:
:
transmute
(
self
)
;
if
this
.
data
.
is_null
(
)
{
debug_assert
!
(
this
.
length
=
=
0
)
;
/
/
Use
an
arbitrary
non
-
null
value
as
the
pointer
slice
:
:
from_raw_parts
(
0x1
as
*
const
char_t
0
)
}
else
{
slice
:
:
from_raw_parts
(
this
.
data
this
.
length
as
usize
)
}
}
}
}
impl
cmp
:
:
PartialEq
for
AString
{
fn
eq
(
&
self
other
:
&
AString
)
-
>
bool
{
&
self
[
.
.
]
=
=
&
other
[
.
.
]
}
}
impl
cmp
:
:
PartialEq
<
[
char_t
]
>
for
AString
{
fn
eq
(
&
self
other
:
&
[
char_t
]
)
-
>
bool
{
&
self
[
.
.
]
=
=
other
}
}
impl
<
'
a
>
cmp
:
:
PartialEq
<
String
<
'
a
>
>
for
AString
{
fn
eq
(
&
self
other
:
&
String
<
'
a
>
)
-
>
bool
{
self
.
eq
(
&
*
*
other
)
}
}
impl
<
'
a
>
cmp
:
:
PartialEq
<
FixedString
<
'
a
>
>
for
AString
{
fn
eq
(
&
self
other
:
&
FixedString
<
'
a
>
)
-
>
bool
{
self
.
eq
(
&
*
*
other
)
}
}
pub
struct
String
<
'
a
>
{
hdr
:
StringRepr
_marker
:
PhantomData
<
&
'
a
[
char_t
]
>
}
impl
String
<
'
static
>
{
pub
fn
new
(
)
-
>
String
<
'
static
>
{
String
{
hdr
:
StringRepr
{
data
:
ptr
:
:
null
(
)
length
:
0
flags
:
F_NONE
}
_marker
:
PhantomData
}
}
}
impl
<
'
a
>
Deref
for
String
<
'
a
>
{
type
Target
=
AString
;
fn
deref
(
&
self
)
-
>
&
AString
{
&
self
.
hdr
}
}
impl
<
'
a
>
DerefMut
for
String
<
'
a
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
AString
{
&
mut
self
.
hdr
}
}
impl
<
'
a
>
From
<
&
'
a
[
char_t
]
>
for
String
<
'
a
>
{
fn
from
(
s
:
&
'
a
[
char_t
]
)
-
>
String
<
'
a
>
{
assert
!
(
s
.
len
(
)
<
(
u32
:
:
MAX
as
usize
)
)
;
String
{
hdr
:
StringRepr
{
data
:
s
.
as_ptr
(
)
length
:
s
.
len
(
)
as
u32
flags
:
F_NONE
}
_marker
:
PhantomData
}
}
}
impl
From
<
Box
<
[
char_t
]
>
>
for
String
<
'
static
>
{
fn
from
(
s
:
Box
<
[
char_t
]
>
)
-
>
String
<
'
static
>
{
assert
!
(
s
.
len
(
)
<
(
u32
:
:
MAX
as
usize
)
)
;
/
/
SAFETY
NOTE
:
This
method
produces
an
F_OWNED
ns
[
C
]
String
from
/
/
a
Box
<
[
char_t
]
>
.
this
is
only
safe
because
in
the
Gecko
/
/
tree
we
use
the
same
allocator
for
Rust
code
as
for
C
+
+
/
/
code
meaning
that
our
box
can
be
legally
freed
with
/
/
libc
:
:
free
(
)
.
let
length
=
s
.
len
(
)
as
u32
;
let
ptr
=
s
.
as_ptr
(
)
;
mem
:
:
forget
(
s
)
;
String
{
hdr
:
StringRepr
{
data
:
ptr
length
:
length
flags
:
F_OWNED
}
_marker
:
PhantomData
}
}
}
impl
From
<
Vec
<
char_t
>
>
for
String
<
'
static
>
{
fn
from
(
s
:
Vec
<
char_t
>
)
-
>
String
<
'
static
>
{
s
.
into_boxed_slice
(
)
.
into
(
)
}
}
impl
<
'
a
>
From
<
&
'
a
AString
>
for
String
<
'
static
>
{
fn
from
(
s
:
&
'
a
AString
)
-
>
String
<
'
static
>
{
let
mut
string
=
String
:
:
new
(
)
;
string
.
assign
(
s
)
;
string
}
}
impl
<
'
a
>
fmt
:
:
Write
for
String
<
'
a
>
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
AString
:
:
write_str
(
self
s
)
}
}
impl
<
'
a
>
fmt
:
:
Display
for
String
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
<
AString
as
fmt
:
:
Display
>
:
:
fmt
(
self
f
)
}
}
impl
<
'
a
>
fmt
:
:
Debug
for
String
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
<
AString
as
fmt
:
:
Debug
>
:
:
fmt
(
self
f
)
}
}
impl
<
'
a
>
cmp
:
:
PartialEq
for
String
<
'
a
>
{
fn
eq
(
&
self
other
:
&
String
<
'
a
>
)
-
>
bool
{
AString
:
:
eq
(
self
other
)
}
}
impl
<
'
a
>
cmp
:
:
PartialEq
<
[
char_t
]
>
for
String
<
'
a
>
{
fn
eq
(
&
self
other
:
&
[
char_t
]
)
-
>
bool
{
AString
:
:
eq
(
self
other
)
}
}
impl
<
'
a
'
b
>
cmp
:
:
PartialEq
<
&
'
b
[
char_t
]
>
for
String
<
'
a
>
{
fn
eq
(
&
self
other
:
&
&
'
b
[
char_t
]
)
-
>
bool
{
AString
:
:
eq
(
self
*
other
)
}
}
impl
<
'
a
>
cmp
:
:
PartialEq
<
str
>
for
String
<
'
a
>
{
fn
eq
(
&
self
other
:
&
str
)
-
>
bool
{
AString
:
:
eq
(
self
other
)
}
}
impl
<
'
a
'
b
>
cmp
:
:
PartialEq
<
&
'
b
str
>
for
String
<
'
a
>
{
fn
eq
(
&
self
other
:
&
&
'
b
str
)
-
>
bool
{
AString
:
:
eq
(
self
*
other
)
}
}
impl
<
'
a
>
Drop
for
String
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
finalize
(
)
;
}
}
}
/
/
/
A
nsFixed
[
C
]
String
is
a
string
which
uses
a
fixed
size
mutable
/
/
/
backing
buffer
for
storing
strings
which
will
fit
within
that
/
/
/
buffer
rather
than
using
heap
allocations
.
pub
struct
FixedString
<
'
a
>
{
hdr
:
FixedStringRepr
_marker
:
PhantomData
<
&
'
a
mut
[
char_t
]
>
}
impl
<
'
a
>
FixedString
<
'
a
>
{
pub
fn
new
(
buf
:
&
'
a
mut
[
char_t
]
)
-
>
FixedString
<
'
a
>
{
let
len
=
buf
.
len
(
)
;
assert
!
(
len
<
(
u32
:
:
MAX
as
usize
)
)
;
let
buf_ptr
=
buf
.
as_mut_ptr
(
)
;
FixedString
{
hdr
:
FixedStringRepr
{
base
:
StringRepr
{
data
:
ptr
:
:
null
(
)
length
:
0
flags
:
F_CLASS_FIXED
}
capacity
:
len
as
u32
buffer
:
buf_ptr
}
_marker
:
PhantomData
}
}
}
impl
<
'
a
>
Deref
for
FixedString
<
'
a
>
{
type
Target
=
AString
;
fn
deref
(
&
self
)
-
>
&
AString
{
&
self
.
hdr
.
base
}
}
impl
<
'
a
>
DerefMut
for
FixedString
<
'
a
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
AString
{
&
mut
self
.
hdr
.
base
}
}
impl
<
'
a
>
fmt
:
:
Write
for
FixedString
<
'
a
>
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
AString
:
:
write_str
(
self
s
)
}
}
impl
<
'
a
>
fmt
:
:
Display
for
FixedString
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
<
AString
as
fmt
:
:
Display
>
:
:
fmt
(
self
f
)
}
}
impl
<
'
a
>
fmt
:
:
Debug
for
FixedString
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
<
AString
as
fmt
:
:
Debug
>
:
:
fmt
(
self
f
)
}
}
impl
<
'
a
>
cmp
:
:
PartialEq
for
FixedString
<
'
a
>
{
fn
eq
(
&
self
other
:
&
FixedString
<
'
a
>
)
-
>
bool
{
AString
:
:
eq
(
self
other
)
}
}
impl
<
'
a
>
cmp
:
:
PartialEq
<
[
char_t
]
>
for
FixedString
<
'
a
>
{
fn
eq
(
&
self
other
:
&
[
char_t
]
)
-
>
bool
{
AString
:
:
eq
(
self
other
)
}
}
impl
<
'
a
'
b
>
cmp
:
:
PartialEq
<
&
'
b
[
char_t
]
>
for
FixedString
<
'
a
>
{
fn
eq
(
&
self
other
:
&
&
'
b
[
char_t
]
)
-
>
bool
{
AString
:
:
eq
(
self
*
other
)
}
}
impl
<
'
a
>
cmp
:
:
PartialEq
<
str
>
for
FixedString
<
'
a
>
{
fn
eq
(
&
self
other
:
&
str
)
-
>
bool
{
AString
:
:
eq
(
self
other
)
}
}
impl
<
'
a
'
b
>
cmp
:
:
PartialEq
<
&
'
b
str
>
for
FixedString
<
'
a
>
{
fn
eq
(
&
self
other
:
&
&
'
b
str
)
-
>
bool
{
AString
:
:
eq
(
self
*
other
)
}
}
impl
<
'
a
>
Drop
for
FixedString
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
finalize
(
)
;
}
}
}
}
}
define_string_types
!
{
char_t
=
u8
;
AString
=
nsACString
;
String
=
nsCString
;
FixedString
=
nsFixedCString
;
StringRepr
=
nsCStringRepr
;
FixedStringRepr
=
nsFixedCStringRepr
;
AutoStringRepr
=
nsAutoCStringRepr
;
}
impl
nsACString
{
unsafe
fn
finalize
(
&
mut
self
)
{
Gecko_FinalizeCString
(
self
)
;
}
pub
fn
assign
(
&
mut
self
other
:
&
nsACString
)
{
unsafe
{
Gecko_AssignCString
(
self
as
*
mut
_
other
as
*
const
_
)
;
}
}
pub
fn
assign_utf16
(
&
mut
self
other
:
&
nsAString
)
{
self
.
assign
(
&
nsCString
:
:
new
(
)
)
;
self
.
append_utf16
(
other
)
;
}
pub
fn
append
(
&
mut
self
other
:
&
nsACString
)
{
unsafe
{
Gecko_AppendCString
(
self
as
*
mut
_
other
as
*
const
_
)
;
}
}
pub
fn
append_utf16
(
&
mut
self
other
:
&
nsAString
)
{
unsafe
{
Gecko_AppendUTF16toCString
(
self
as
*
mut
_
other
as
*
const
_
)
;
}
}
pub
unsafe
fn
as_str_unchecked
(
&
self
)
-
>
&
str
{
str
:
:
from_utf8_unchecked
(
self
)
}
}
impl
<
'
a
>
From
<
&
'
a
str
>
for
nsCString
<
'
a
>
{
fn
from
(
s
:
&
'
a
str
)
-
>
nsCString
<
'
a
>
{
s
.
as_bytes
(
)
.
into
(
)
}
}
impl
From
<
Box
<
str
>
>
for
nsCString
<
'
static
>
{
fn
from
(
s
:
Box
<
str
>
)
-
>
nsCString
<
'
static
>
{
s
.
into_string
(
)
.
into
(
)
}
}
impl
From
<
String
>
for
nsCString
<
'
static
>
{
fn
from
(
s
:
String
)
-
>
nsCString
<
'
static
>
{
s
.
into_bytes
(
)
.
into
(
)
}
}
impl
fmt
:
:
Write
for
nsACString
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
self
.
append
(
&
nsCString
:
:
from
(
s
)
)
;
Ok
(
(
)
)
}
}
impl
fmt
:
:
Display
for
nsACString
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
fmt
:
:
Display
:
:
fmt
(
&
String
:
:
from_utf8_lossy
(
&
self
[
.
.
]
)
f
)
}
}
impl
fmt
:
:
Debug
for
nsACString
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
fmt
:
:
Debug
:
:
fmt
(
&
String
:
:
from_utf8_lossy
(
&
self
[
.
.
]
)
f
)
}
}
impl
cmp
:
:
PartialEq
<
str
>
for
nsACString
{
fn
eq
(
&
self
other
:
&
str
)
-
>
bool
{
&
self
[
.
.
]
=
=
other
.
as_bytes
(
)
}
}
#
[
macro_export
]
macro_rules
!
ns_auto_cstring
{
(
name
:
ident
)
=
>
{
let
mut
buf
:
[
u8
;
64
]
=
[
0
;
64
]
;
let
mut
name
=
crate
:
:
nsFixedCString
:
:
new
(
&
mut
buf
)
;
}
}
define_string_types
!
{
char_t
=
u16
;
AString
=
nsAString
;
String
=
nsString
;
FixedString
=
nsFixedString
;
StringRepr
=
nsStringRepr
;
FixedStringRepr
=
nsFixedStringRepr
;
AutoStringRepr
=
nsAutoStringRepr
;
}
impl
nsAString
{
unsafe
fn
finalize
(
&
mut
self
)
{
Gecko_FinalizeString
(
self
)
;
}
pub
fn
assign
(
&
mut
self
other
:
&
nsAString
)
{
unsafe
{
Gecko_AssignString
(
self
as
*
mut
_
other
as
*
const
_
)
;
}
}
pub
fn
assign_utf8
(
&
mut
self
other
:
&
nsACString
)
{
self
.
assign
(
&
nsString
:
:
new
(
)
)
;
self
.
append_utf8
(
other
)
;
}
pub
fn
append
(
&
mut
self
other
:
&
nsAString
)
{
unsafe
{
Gecko_AppendString
(
self
as
*
mut
_
other
as
*
const
_
)
;
}
}
pub
fn
append_utf8
(
&
mut
self
other
:
&
nsACString
)
{
unsafe
{
Gecko_AppendUTF8toString
(
self
as
*
mut
_
other
as
*
const
_
)
;
}
}
}
impl
<
'
a
>
From
<
&
'
a
str
>
for
nsString
<
'
static
>
{
fn
from
(
s
:
&
'
a
str
)
-
>
nsString
<
'
static
>
{
s
.
encode_utf16
(
)
.
collect
:
:
<
Vec
<
u16
>
>
(
)
.
into
(
)
}
}
impl
fmt
:
:
Write
for
nsAString
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
self
.
append_utf8
(
&
nsCString
:
:
from
(
s
)
)
;
Ok
(
(
)
)
}
}
impl
fmt
:
:
Display
for
nsAString
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
fmt
:
:
Display
:
:
fmt
(
&
String
:
:
from_utf16_lossy
(
&
self
[
.
.
]
)
f
)
}
}
impl
fmt
:
:
Debug
for
nsAString
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
fmt
:
:
Debug
:
:
fmt
(
&
String
:
:
from_utf16_lossy
(
&
self
[
.
.
]
)
f
)
}
}
impl
cmp
:
:
PartialEq
<
str
>
for
nsAString
{
fn
eq
(
&
self
other
:
&
str
)
-
>
bool
{
other
.
encode_utf16
(
)
.
eq
(
self
.
iter
(
)
.
cloned
(
)
)
}
}
#
[
macro_export
]
macro_rules
!
ns_auto_string
{
(
name
:
ident
)
=
>
{
let
mut
buf
:
[
u16
;
64
]
=
[
0
;
64
]
;
let
mut
name
=
crate
:
:
nsFixedString
:
:
new
(
&
mut
buf
)
;
}
}
extern
"
C
"
{
fn
Gecko_FinalizeCString
(
this
:
*
mut
nsACString
)
;
fn
Gecko_AssignCString
(
this
:
*
mut
nsACString
other
:
*
const
nsACString
)
;
fn
Gecko_AppendCString
(
this
:
*
mut
nsACString
other
:
*
const
nsACString
)
;
fn
Gecko_FinalizeString
(
this
:
*
mut
nsAString
)
;
fn
Gecko_AssignString
(
this
:
*
mut
nsAString
other
:
*
const
nsAString
)
;
fn
Gecko_AppendString
(
this
:
*
mut
nsAString
other
:
*
const
nsAString
)
;
fn
Gecko_AppendUTF16toCString
(
this
:
*
mut
nsACString
other
:
*
const
nsAString
)
;
fn
Gecko_AppendUTF8toString
(
this
:
*
mut
nsAString
other
:
*
const
nsACString
)
;
}
