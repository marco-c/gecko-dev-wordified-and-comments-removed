use
{
Atom
LocalName
}
;
use
dom
:
:
TElement
;
use
fnv
:
:
FnvHashMap
;
use
pdqsort
:
:
sort_by
;
use
rule_tree
:
:
CascadeLevel
;
use
selector_parser
:
:
SelectorImpl
;
use
selectors
:
:
matching
:
:
{
matches_selector
MatchingContext
ElementSelectorFlags
}
;
use
selectors
:
:
parser
:
:
{
Component
Combinator
SelectorInner
}
;
use
selectors
:
:
parser
:
:
LocalName
as
LocalNameSelector
;
use
smallvec
:
:
VecLike
;
use
std
:
:
borrow
:
:
Borrow
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
hash
:
:
Hash
;
use
stylist
:
:
{
ApplicableDeclarationBlock
Rule
}
;
pub
trait
SelectorMapEntry
:
Sized
+
Clone
{
fn
selector
(
&
self
)
-
>
&
SelectorInner
<
SelectorImpl
>
;
}
impl
SelectorMapEntry
for
SelectorInner
<
SelectorImpl
>
{
fn
selector
(
&
self
)
-
>
&
SelectorInner
<
SelectorImpl
>
{
self
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
SelectorMap
<
T
:
SelectorMapEntry
>
{
pub
id_hash
:
FnvHashMap
<
Atom
Vec
<
T
>
>
pub
class_hash
:
FnvHashMap
<
Atom
Vec
<
T
>
>
pub
local_name_hash
:
FnvHashMap
<
LocalName
Vec
<
T
>
>
pub
other
:
Vec
<
T
>
pub
count
:
usize
}
#
[
inline
]
fn
sort_by_key
<
T
F
:
Fn
(
&
T
)
-
>
K
K
:
Ord
>
(
v
:
&
mut
[
T
]
f
:
F
)
{
sort_by
(
v
|
a
b
|
f
(
a
)
.
cmp
(
&
f
(
b
)
)
)
}
impl
<
T
:
SelectorMapEntry
>
SelectorMap
<
T
>
{
pub
fn
new
(
)
-
>
Self
{
SelectorMap
{
id_hash
:
HashMap
:
:
default
(
)
class_hash
:
HashMap
:
:
default
(
)
local_name_hash
:
HashMap
:
:
default
(
)
other
:
Vec
:
:
new
(
)
count
:
0
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
count
=
=
0
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
count
}
}
impl
SelectorMap
<
Rule
>
{
pub
fn
get_all_matching_rules
<
E
V
F
>
(
&
self
element
:
&
E
rule_hash_target
:
&
E
matching_rules_list
:
&
mut
V
context
:
&
mut
MatchingContext
flags_setter
:
&
mut
F
cascade_level
:
CascadeLevel
)
where
E
:
TElement
V
:
VecLike
<
ApplicableDeclarationBlock
>
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
if
self
.
is_empty
(
)
{
return
}
let
init_len
=
matching_rules_list
.
len
(
)
;
if
let
Some
(
id
)
=
rule_hash_target
.
get_id
(
)
{
SelectorMap
:
:
get_matching_rules_from_hash
(
element
&
self
.
id_hash
&
id
matching_rules_list
context
flags_setter
cascade_level
)
}
rule_hash_target
.
each_class
(
|
class
|
{
SelectorMap
:
:
get_matching_rules_from_hash
(
element
&
self
.
class_hash
class
matching_rules_list
context
flags_setter
cascade_level
)
;
}
)
;
SelectorMap
:
:
get_matching_rules_from_hash
(
element
&
self
.
local_name_hash
rule_hash_target
.
get_local_name
(
)
matching_rules_list
context
flags_setter
cascade_level
)
;
SelectorMap
:
:
get_matching_rules
(
element
&
self
.
other
matching_rules_list
context
flags_setter
cascade_level
)
;
sort_by_key
(
&
mut
matching_rules_list
[
init_len
.
.
]
|
block
|
(
block
.
specificity
block
.
source_order
)
)
;
}
#
[
inline
]
pub
fn
has_rules_for_id
(
&
self
id
:
&
Atom
)
-
>
bool
{
self
.
id_hash
.
get
(
id
)
.
is_some
(
)
}
pub
fn
get_universal_rules
(
&
self
cascade_level
:
CascadeLevel
)
-
>
Vec
<
ApplicableDeclarationBlock
>
{
debug_assert
!
(
!
cascade_level
.
is_important
(
)
)
;
if
self
.
is_empty
(
)
{
return
vec
!
[
]
;
}
let
mut
rules_list
=
vec
!
[
]
;
for
rule
in
self
.
other
.
iter
(
)
{
if
rule
.
selector
.
is_universal
(
)
{
rules_list
.
push
(
rule
.
to_applicable_declaration_block
(
cascade_level
)
)
}
}
sort_by_key
(
&
mut
rules_list
|
block
|
(
block
.
specificity
block
.
source_order
)
)
;
rules_list
}
fn
get_matching_rules_from_hash
<
E
Str
BorrowedStr
:
?
Sized
Vector
F
>
(
element
:
&
E
hash
:
&
FnvHashMap
<
Str
Vec
<
Rule
>
>
key
:
&
BorrowedStr
matching_rules
:
&
mut
Vector
context
:
&
mut
MatchingContext
flags_setter
:
&
mut
F
cascade_level
:
CascadeLevel
)
where
E
:
TElement
Str
:
Borrow
<
BorrowedStr
>
+
Eq
+
Hash
BorrowedStr
:
Eq
+
Hash
Vector
:
VecLike
<
ApplicableDeclarationBlock
>
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
if
let
Some
(
rules
)
=
hash
.
get
(
key
)
{
SelectorMap
:
:
get_matching_rules
(
element
rules
matching_rules
context
flags_setter
cascade_level
)
}
}
fn
get_matching_rules
<
E
V
F
>
(
element
:
&
E
rules
:
&
[
Rule
]
matching_rules
:
&
mut
V
context
:
&
mut
MatchingContext
flags_setter
:
&
mut
F
cascade_level
:
CascadeLevel
)
where
E
:
TElement
V
:
VecLike
<
ApplicableDeclarationBlock
>
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
for
rule
in
rules
{
if
matches_selector
(
&
rule
.
selector
.
inner
element
context
flags_setter
)
{
matching_rules
.
push
(
rule
.
to_applicable_declaration_block
(
cascade_level
)
)
;
}
}
}
}
impl
<
T
:
SelectorMapEntry
>
SelectorMap
<
T
>
{
pub
fn
insert
(
&
mut
self
entry
:
T
)
{
self
.
count
+
=
1
;
if
let
Some
(
id_name
)
=
get_id_name
(
entry
.
selector
(
)
)
{
find_push
(
&
mut
self
.
id_hash
id_name
entry
)
;
return
;
}
if
let
Some
(
class_name
)
=
get_class_name
(
entry
.
selector
(
)
)
{
find_push
(
&
mut
self
.
class_hash
class_name
entry
)
;
return
;
}
if
let
Some
(
LocalNameSelector
{
name
lower_name
}
)
=
get_local_name
(
entry
.
selector
(
)
)
{
if
name
!
=
lower_name
{
find_push
(
&
mut
self
.
local_name_hash
lower_name
entry
.
clone
(
)
)
;
}
find_push
(
&
mut
self
.
local_name_hash
name
entry
)
;
return
;
}
self
.
other
.
push
(
entry
)
;
}
#
[
inline
]
pub
fn
lookup
<
E
F
>
(
&
self
element
:
E
f
:
&
mut
F
)
-
>
bool
where
E
:
TElement
F
:
FnMut
(
&
T
)
-
>
bool
{
if
let
Some
(
id
)
=
element
.
get_id
(
)
{
if
let
Some
(
v
)
=
self
.
id_hash
.
get
(
&
id
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
}
}
let
mut
done
=
false
;
element
.
each_class
(
|
class
|
{
if
!
done
{
if
let
Some
(
v
)
=
self
.
class_hash
.
get
(
class
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
done
=
true
;
return
;
}
}
}
}
}
)
;
if
done
{
return
false
;
}
if
let
Some
(
v
)
=
self
.
local_name_hash
.
get
(
element
.
get_local_name
(
)
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
}
for
entry
in
self
.
other
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
true
}
#
[
inline
]
pub
fn
lookup_with_additional
<
E
F
>
(
&
self
element
:
E
additional_id
:
Option
<
Atom
>
additional_classes
:
&
[
Atom
]
f
:
&
mut
F
)
-
>
bool
where
E
:
TElement
F
:
FnMut
(
&
T
)
-
>
bool
{
if
!
self
.
lookup
(
element
f
)
{
return
false
;
}
if
let
Some
(
id
)
=
additional_id
{
if
let
Some
(
v
)
=
self
.
id_hash
.
get
(
&
id
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
}
}
for
class
in
additional_classes
{
if
let
Some
(
v
)
=
self
.
class_hash
.
get
(
class
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
}
}
true
}
}
fn
find_from_right
<
F
R
>
(
selector
:
&
SelectorInner
<
SelectorImpl
>
mut
f
:
F
)
-
>
Option
<
R
>
where
F
:
FnMut
(
&
Component
<
SelectorImpl
>
)
-
>
Option
<
R
>
{
let
mut
iter
=
selector
.
complex
.
iter
(
)
;
for
ss
in
&
mut
iter
{
if
let
Some
(
r
)
=
f
(
ss
)
{
return
Some
(
r
)
}
}
if
iter
.
next_sequence
(
)
=
=
Some
(
Combinator
:
:
PseudoElement
)
{
for
ss
in
&
mut
iter
{
if
let
Some
(
r
)
=
f
(
ss
)
{
return
Some
(
r
)
}
}
}
None
}
pub
fn
get_id_name
(
selector
:
&
SelectorInner
<
SelectorImpl
>
)
-
>
Option
<
Atom
>
{
find_from_right
(
selector
|
ss
|
{
if
let
Component
:
:
ID
(
ref
id
)
=
*
ss
{
return
Some
(
id
.
clone
(
)
)
;
}
None
}
)
}
pub
fn
get_class_name
(
selector
:
&
SelectorInner
<
SelectorImpl
>
)
-
>
Option
<
Atom
>
{
find_from_right
(
selector
|
ss
|
{
if
let
Component
:
:
Class
(
ref
class
)
=
*
ss
{
return
Some
(
class
.
clone
(
)
)
;
}
None
}
)
}
pub
fn
get_local_name
(
selector
:
&
SelectorInner
<
SelectorImpl
>
)
-
>
Option
<
LocalNameSelector
<
SelectorImpl
>
>
{
find_from_right
(
selector
|
ss
|
{
if
let
Component
:
:
LocalName
(
ref
n
)
=
*
ss
{
return
Some
(
LocalNameSelector
{
name
:
n
.
name
.
clone
(
)
lower_name
:
n
.
lower_name
.
clone
(
)
}
)
}
None
}
)
}
#
[
inline
]
fn
find_push
<
Str
:
Eq
+
Hash
V
>
(
map
:
&
mut
FnvHashMap
<
Str
Vec
<
V
>
>
key
:
Str
value
:
V
)
{
map
.
entry
(
key
)
.
or_insert_with
(
Vec
:
:
new
)
.
push
(
value
)
}
