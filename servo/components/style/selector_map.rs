use
{
Atom
LocalName
}
;
use
applicable_declarations
:
:
ApplicableDeclarationBlock
;
use
context
:
:
QuirksMode
;
use
dom
:
:
TElement
;
use
pdqsort
:
:
sort_by
;
use
precomputed_hash
:
:
PrecomputedHash
;
use
rule_tree
:
:
CascadeLevel
;
use
selector_parser
:
:
SelectorImpl
;
use
selectors
:
:
matching
:
:
{
matches_selector
MatchingContext
ElementSelectorFlags
}
;
use
selectors
:
:
parser
:
:
{
Component
Combinator
SelectorIter
}
;
use
selectors
:
:
parser
:
:
LocalName
as
LocalNameSelector
;
use
smallvec
:
:
{
SmallVec
VecLike
}
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
use
std
:
:
collections
:
:
hash_map
;
use
std
:
:
hash
:
:
{
BuildHasherDefault
Hash
Hasher
}
;
use
stylist
:
:
Rule
;
pub
struct
PrecomputedHasher
{
hash
:
Option
<
u32
>
}
impl
Default
for
PrecomputedHasher
{
fn
default
(
)
-
>
Self
{
Self
{
hash
:
None
}
}
}
pub
type
PrecomputedHashMap
<
K
V
>
=
HashMap
<
K
V
BuildHasherDefault
<
PrecomputedHasher
>
>
;
pub
type
PrecomputedHashSet
<
K
>
=
HashSet
<
K
BuildHasherDefault
<
PrecomputedHasher
>
>
;
impl
Hasher
for
PrecomputedHasher
{
#
[
inline
]
fn
write
(
&
mut
self
_
:
&
[
u8
]
)
{
unreachable
!
(
"
Called
into
PrecomputedHasher
with
something
that
isn
'
t
\
a
u32
"
)
}
#
[
inline
]
fn
write_u32
(
&
mut
self
i
:
u32
)
{
debug_assert
!
(
self
.
hash
.
is_none
(
)
)
;
self
.
hash
=
Some
(
i
)
;
}
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
self
.
hash
.
expect
(
"
PrecomputedHasher
wasn
'
t
fed
?
"
)
as
u64
}
}
pub
trait
SelectorMapEntry
:
Sized
+
Clone
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
;
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
SelectorMap
<
T
>
{
pub
id_hash
:
MaybeCaseInsensitiveHashMap
<
Atom
SmallVec
<
[
T
;
1
]
>
>
pub
class_hash
:
MaybeCaseInsensitiveHashMap
<
Atom
SmallVec
<
[
T
;
1
]
>
>
pub
local_name_hash
:
PrecomputedHashMap
<
LocalName
SmallVec
<
[
T
;
1
]
>
>
pub
other
:
Vec
<
T
>
pub
count
:
usize
}
#
[
inline
]
fn
sort_by_key
<
T
F
:
Fn
(
&
T
)
-
>
K
K
:
Ord
>
(
v
:
&
mut
[
T
]
f
:
F
)
{
sort_by
(
v
|
a
b
|
f
(
a
)
.
cmp
(
&
f
(
b
)
)
)
}
impl
<
T
>
SelectorMap
<
T
>
{
pub
fn
new
(
)
-
>
Self
{
SelectorMap
{
id_hash
:
MaybeCaseInsensitiveHashMap
:
:
new
(
)
class_hash
:
MaybeCaseInsensitiveHashMap
:
:
new
(
)
local_name_hash
:
HashMap
:
:
default
(
)
other
:
Vec
:
:
new
(
)
count
:
0
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
count
=
=
0
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
count
}
}
impl
SelectorMap
<
Rule
>
{
pub
fn
get_all_matching_rules
<
E
V
F
>
(
&
self
element
:
&
E
rule_hash_target
:
&
E
matching_rules_list
:
&
mut
V
context
:
&
mut
MatchingContext
quirks_mode
:
QuirksMode
flags_setter
:
&
mut
F
cascade_level
:
CascadeLevel
)
where
E
:
TElement
V
:
VecLike
<
ApplicableDeclarationBlock
>
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
if
self
.
is_empty
(
)
{
return
}
let
init_len
=
matching_rules_list
.
len
(
)
;
if
let
Some
(
id
)
=
rule_hash_target
.
get_id
(
)
{
if
let
Some
(
rules
)
=
self
.
id_hash
.
get
(
&
id
quirks_mode
)
{
SelectorMap
:
:
get_matching_rules
(
element
rules
matching_rules_list
context
flags_setter
cascade_level
)
}
}
rule_hash_target
.
each_class
(
|
class
|
{
if
let
Some
(
rules
)
=
self
.
class_hash
.
get
(
&
class
quirks_mode
)
{
SelectorMap
:
:
get_matching_rules
(
element
rules
matching_rules_list
context
flags_setter
cascade_level
)
}
}
)
;
if
let
Some
(
rules
)
=
self
.
local_name_hash
.
get
(
rule_hash_target
.
get_local_name
(
)
)
{
SelectorMap
:
:
get_matching_rules
(
element
rules
matching_rules_list
context
flags_setter
cascade_level
)
}
SelectorMap
:
:
get_matching_rules
(
element
&
self
.
other
matching_rules_list
context
flags_setter
cascade_level
)
;
sort_by_key
(
&
mut
matching_rules_list
[
init_len
.
.
]
|
block
|
(
block
.
specificity
block
.
source_order
(
)
)
)
;
}
fn
get_matching_rules
<
E
V
F
>
(
element
:
&
E
rules
:
&
[
Rule
]
matching_rules
:
&
mut
V
context
:
&
mut
MatchingContext
flags_setter
:
&
mut
F
cascade_level
:
CascadeLevel
)
where
E
:
TElement
V
:
VecLike
<
ApplicableDeclarationBlock
>
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
for
rule
in
rules
{
if
matches_selector
(
&
rule
.
selector
0
Some
(
&
rule
.
hashes
)
element
context
flags_setter
)
{
matching_rules
.
push
(
rule
.
to_applicable_declaration_block
(
cascade_level
)
)
;
}
}
}
}
impl
<
T
:
SelectorMapEntry
>
SelectorMap
<
T
>
{
pub
fn
insert
(
&
mut
self
entry
:
T
quirks_mode
:
QuirksMode
)
{
self
.
count
+
=
1
;
if
let
Some
(
id_name
)
=
get_id_name
(
entry
.
selector
(
)
)
{
self
.
id_hash
.
entry
(
id_name
quirks_mode
)
.
or_insert_with
(
SmallVec
:
:
new
)
.
push
(
entry
)
;
return
;
}
if
let
Some
(
class_name
)
=
get_class_name
(
entry
.
selector
(
)
)
{
self
.
class_hash
.
entry
(
class_name
quirks_mode
)
.
or_insert_with
(
SmallVec
:
:
new
)
.
push
(
entry
)
;
return
;
}
if
let
Some
(
LocalNameSelector
{
name
lower_name
}
)
=
get_local_name
(
entry
.
selector
(
)
)
{
if
name
!
=
lower_name
{
find_push
(
&
mut
self
.
local_name_hash
lower_name
entry
.
clone
(
)
)
;
}
find_push
(
&
mut
self
.
local_name_hash
name
entry
)
;
return
;
}
self
.
other
.
push
(
entry
)
;
}
#
[
inline
]
pub
fn
lookup
<
E
F
>
(
&
self
element
:
E
quirks_mode
:
QuirksMode
f
:
&
mut
F
)
-
>
bool
where
E
:
TElement
F
:
FnMut
(
&
T
)
-
>
bool
{
if
let
Some
(
id
)
=
element
.
get_id
(
)
{
if
let
Some
(
v
)
=
self
.
id_hash
.
get
(
&
id
quirks_mode
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
}
}
let
mut
done
=
false
;
element
.
each_class
(
|
class
|
{
if
!
done
{
if
let
Some
(
v
)
=
self
.
class_hash
.
get
(
class
quirks_mode
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
done
=
true
;
return
;
}
}
}
}
}
)
;
if
done
{
return
false
;
}
if
let
Some
(
v
)
=
self
.
local_name_hash
.
get
(
element
.
get_local_name
(
)
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
}
for
entry
in
self
.
other
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
true
}
#
[
inline
]
pub
fn
lookup_with_additional
<
E
F
>
(
&
self
element
:
E
quirks_mode
:
QuirksMode
additional_id
:
Option
<
&
Atom
>
additional_classes
:
&
[
Atom
]
f
:
&
mut
F
)
-
>
bool
where
E
:
TElement
F
:
FnMut
(
&
T
)
-
>
bool
{
if
!
self
.
lookup
(
element
quirks_mode
f
)
{
return
false
;
}
if
let
Some
(
id
)
=
additional_id
{
if
let
Some
(
v
)
=
self
.
id_hash
.
get
(
id
quirks_mode
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
}
}
for
class
in
additional_classes
{
if
let
Some
(
v
)
=
self
.
class_hash
.
get
(
class
quirks_mode
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
}
}
true
}
}
#
[
inline
(
always
)
]
fn
find_from_left
<
F
R
>
(
mut
iter
:
SelectorIter
<
SelectorImpl
>
mut
f
:
F
)
-
>
Option
<
R
>
where
F
:
FnMut
(
&
Component
<
SelectorImpl
>
)
-
>
Option
<
R
>
{
for
ss
in
&
mut
iter
{
if
let
Some
(
r
)
=
f
(
ss
)
{
return
Some
(
r
)
}
}
if
iter
.
next_sequence
(
)
=
=
Some
(
Combinator
:
:
PseudoElement
)
{
for
ss
in
&
mut
iter
{
if
let
Some
(
r
)
=
f
(
ss
)
{
return
Some
(
r
)
}
}
}
None
}
#
[
inline
(
always
)
]
pub
fn
get_id_name
(
iter
:
SelectorIter
<
SelectorImpl
>
)
-
>
Option
<
Atom
>
{
find_from_left
(
iter
|
ss
|
{
if
let
Component
:
:
ID
(
ref
id
)
=
*
ss
{
return
Some
(
id
.
clone
(
)
)
;
}
None
}
)
}
#
[
inline
(
always
)
]
pub
fn
get_class_name
(
iter
:
SelectorIter
<
SelectorImpl
>
)
-
>
Option
<
Atom
>
{
find_from_left
(
iter
|
ss
|
{
if
let
Component
:
:
Class
(
ref
class
)
=
*
ss
{
return
Some
(
class
.
clone
(
)
)
;
}
None
}
)
}
#
[
inline
(
always
)
]
pub
fn
get_local_name
(
iter
:
SelectorIter
<
SelectorImpl
>
)
-
>
Option
<
LocalNameSelector
<
SelectorImpl
>
>
{
find_from_left
(
iter
|
ss
|
{
if
let
Component
:
:
LocalName
(
ref
n
)
=
*
ss
{
return
Some
(
LocalNameSelector
{
name
:
n
.
name
.
clone
(
)
lower_name
:
n
.
lower_name
.
clone
(
)
}
)
}
None
}
)
}
#
[
inline
]
fn
find_push
<
Str
:
Eq
+
Hash
V
VL
>
(
map
:
&
mut
PrecomputedHashMap
<
Str
VL
>
key
:
Str
value
:
V
)
where
VL
:
VecLike
<
V
>
+
Default
{
map
.
entry
(
key
)
.
or_insert_with
(
VL
:
:
default
)
.
push
(
value
)
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
MaybeCaseInsensitiveHashMap
<
K
:
PrecomputedHash
+
Hash
+
Eq
V
>
(
PrecomputedHashMap
<
K
V
>
)
;
impl
<
V
>
MaybeCaseInsensitiveHashMap
<
Atom
V
>
{
pub
fn
new
(
)
-
>
Self
{
MaybeCaseInsensitiveHashMap
(
PrecomputedHashMap
:
:
default
(
)
)
}
pub
fn
entry
(
&
mut
self
mut
key
:
Atom
quirks_mode
:
QuirksMode
)
-
>
hash_map
:
:
Entry
<
Atom
V
>
{
if
quirks_mode
=
=
QuirksMode
:
:
Quirks
{
key
=
key
.
to_ascii_lowercase
(
)
}
self
.
0
.
entry
(
key
)
}
pub
fn
iter
(
&
self
)
-
>
hash_map
:
:
Iter
<
Atom
V
>
{
self
.
0
.
iter
(
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
0
.
clear
(
)
}
pub
fn
get
(
&
self
key
:
&
Atom
quirks_mode
:
QuirksMode
)
-
>
Option
<
&
V
>
{
if
quirks_mode
=
=
QuirksMode
:
:
Quirks
{
self
.
0
.
get
(
&
key
.
to_ascii_lowercase
(
)
)
}
else
{
self
.
0
.
get
(
key
)
}
}
}
