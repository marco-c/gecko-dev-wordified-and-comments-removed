use
{
Atom
LocalName
}
;
use
applicable_declarations
:
:
ApplicableDeclarationList
;
use
context
:
:
QuirksMode
;
use
dom
:
:
TElement
;
use
fallible
:
:
FallibleVec
;
use
hash
:
:
{
HashMap
HashSet
}
;
use
hash
:
:
map
as
hash_map
;
use
hashglobe
:
:
FailedAllocationError
;
use
precomputed_hash
:
:
PrecomputedHash
;
use
rule_tree
:
:
CascadeLevel
;
use
selector_parser
:
:
SelectorImpl
;
use
selectors
:
:
matching
:
:
{
matches_selector
MatchingContext
ElementSelectorFlags
}
;
use
selectors
:
:
parser
:
:
{
Component
Combinator
SelectorIter
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
hash
:
:
{
BuildHasherDefault
Hash
Hasher
}
;
use
stylist
:
:
Rule
;
pub
struct
PrecomputedHasher
{
hash
:
Option
<
u32
>
}
impl
Default
for
PrecomputedHasher
{
fn
default
(
)
-
>
Self
{
Self
{
hash
:
None
}
}
}
pub
type
PrecomputedHashMap
<
K
V
>
=
HashMap
<
K
V
BuildHasherDefault
<
PrecomputedHasher
>
>
;
pub
type
PrecomputedHashSet
<
K
>
=
HashSet
<
K
BuildHasherDefault
<
PrecomputedHasher
>
>
;
impl
Hasher
for
PrecomputedHasher
{
#
[
inline
]
fn
write
(
&
mut
self
_
:
&
[
u8
]
)
{
unreachable
!
(
"
Called
into
PrecomputedHasher
with
something
that
isn
'
t
\
a
u32
"
)
}
#
[
inline
]
fn
write_u32
(
&
mut
self
i
:
u32
)
{
debug_assert
!
(
self
.
hash
.
is_none
(
)
)
;
self
.
hash
=
Some
(
i
)
;
}
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
self
.
hash
.
expect
(
"
PrecomputedHasher
wasn
'
t
fed
?
"
)
as
u64
}
}
pub
trait
SelectorMapEntry
:
Sized
+
Clone
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
;
}
#
[
derive
(
Debug
MallocSizeOf
)
]
pub
struct
SelectorMap
<
T
:
'
static
>
{
pub
id_hash
:
MaybeCaseInsensitiveHashMap
<
Atom
SmallVec
<
[
T
;
1
]
>
>
pub
class_hash
:
MaybeCaseInsensitiveHashMap
<
Atom
SmallVec
<
[
T
;
1
]
>
>
pub
local_name_hash
:
PrecomputedHashMap
<
LocalName
SmallVec
<
[
T
;
1
]
>
>
pub
other
:
SmallVec
<
[
T
;
1
]
>
pub
count
:
usize
}
impl
<
T
:
'
static
>
Default
for
SelectorMap
<
T
>
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
T
:
'
static
>
SelectorMap
<
T
>
{
pub
fn
new
(
)
-
>
Self
{
SelectorMap
{
id_hash
:
MaybeCaseInsensitiveHashMap
:
:
new
(
)
class_hash
:
MaybeCaseInsensitiveHashMap
:
:
new
(
)
local_name_hash
:
HashMap
:
:
default
(
)
other
:
SmallVec
:
:
new
(
)
count
:
0
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
id_hash
.
clear
(
)
;
self
.
class_hash
.
clear
(
)
;
self
.
local_name_hash
.
clear
(
)
;
self
.
other
.
clear
(
)
;
self
.
count
=
0
;
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
count
=
=
0
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
count
}
}
impl
SelectorMap
<
Rule
>
{
pub
fn
get_all_matching_rules
<
E
F
>
(
&
self
element
:
E
rule_hash_target
:
E
matching_rules_list
:
&
mut
ApplicableDeclarationList
context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
flags_setter
:
&
mut
F
cascade_level
:
CascadeLevel
)
where
E
:
TElement
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
if
self
.
is_empty
(
)
{
return
}
let
quirks_mode
=
context
.
quirks_mode
(
)
;
let
init_len
=
matching_rules_list
.
len
(
)
;
if
let
Some
(
id
)
=
rule_hash_target
.
get_id
(
)
{
if
let
Some
(
rules
)
=
self
.
id_hash
.
get
(
&
id
quirks_mode
)
{
SelectorMap
:
:
get_matching_rules
(
element
rules
matching_rules_list
context
flags_setter
cascade_level
)
}
}
rule_hash_target
.
each_class
(
|
class
|
{
if
let
Some
(
rules
)
=
self
.
class_hash
.
get
(
&
class
quirks_mode
)
{
SelectorMap
:
:
get_matching_rules
(
element
rules
matching_rules_list
context
flags_setter
cascade_level
)
}
}
)
;
if
let
Some
(
rules
)
=
self
.
local_name_hash
.
get
(
rule_hash_target
.
get_local_name
(
)
)
{
SelectorMap
:
:
get_matching_rules
(
element
rules
matching_rules_list
context
flags_setter
cascade_level
)
}
SelectorMap
:
:
get_matching_rules
(
element
&
self
.
other
matching_rules_list
context
flags_setter
cascade_level
)
;
matching_rules_list
[
init_len
.
.
]
.
sort_unstable_by_key
(
|
block
|
(
block
.
specificity
block
.
source_order
(
)
)
)
;
}
fn
get_matching_rules
<
E
F
>
(
element
:
E
rules
:
&
[
Rule
]
matching_rules
:
&
mut
ApplicableDeclarationList
context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
flags_setter
:
&
mut
F
cascade_level
:
CascadeLevel
)
where
E
:
TElement
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
for
rule
in
rules
{
if
matches_selector
(
&
rule
.
selector
0
Some
(
&
rule
.
hashes
)
&
element
context
flags_setter
)
{
matching_rules
.
push
(
rule
.
to_applicable_declaration_block
(
cascade_level
)
)
;
}
}
}
}
impl
<
T
:
SelectorMapEntry
>
SelectorMap
<
T
>
{
pub
fn
insert
(
&
mut
self
entry
:
T
quirks_mode
:
QuirksMode
)
-
>
Result
<
(
)
FailedAllocationError
>
{
self
.
count
+
=
1
;
let
vector
=
match
find_bucket
(
entry
.
selector
(
)
)
{
Bucket
:
:
ID
(
id
)
=
>
{
self
.
id_hash
.
try_entry
(
id
.
clone
(
)
quirks_mode
)
?
.
or_insert_with
(
SmallVec
:
:
new
)
}
Bucket
:
:
Class
(
class
)
=
>
{
self
.
class_hash
.
try_entry
(
class
.
clone
(
)
quirks_mode
)
?
.
or_insert_with
(
SmallVec
:
:
new
)
}
Bucket
:
:
LocalName
{
name
lower_name
}
=
>
{
if
name
!
=
lower_name
{
self
.
local_name_hash
.
try_entry
(
lower_name
.
clone
(
)
)
?
.
or_insert_with
(
SmallVec
:
:
new
)
.
try_push
(
entry
.
clone
(
)
)
?
;
}
self
.
local_name_hash
.
try_entry
(
name
.
clone
(
)
)
?
.
or_insert_with
(
SmallVec
:
:
new
)
}
Bucket
:
:
Universal
=
>
{
&
mut
self
.
other
}
}
;
vector
.
try_push
(
entry
)
}
#
[
inline
]
pub
fn
lookup
<
'
a
E
F
>
(
&
'
a
self
element
:
E
quirks_mode
:
QuirksMode
mut
f
:
F
)
-
>
bool
where
E
:
TElement
F
:
FnMut
(
&
'
a
T
)
-
>
bool
{
if
let
Some
(
id
)
=
element
.
get_id
(
)
{
if
let
Some
(
v
)
=
self
.
id_hash
.
get
(
&
id
quirks_mode
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
}
}
let
mut
done
=
false
;
element
.
each_class
(
|
class
|
{
if
!
done
{
if
let
Some
(
v
)
=
self
.
class_hash
.
get
(
class
quirks_mode
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
done
=
true
;
return
;
}
}
}
}
}
)
;
if
done
{
return
false
;
}
if
let
Some
(
v
)
=
self
.
local_name_hash
.
get
(
element
.
get_local_name
(
)
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
}
for
entry
in
self
.
other
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
true
}
#
[
inline
]
pub
fn
lookup_with_additional
<
'
a
E
F
>
(
&
'
a
self
element
:
E
quirks_mode
:
QuirksMode
additional_id
:
Option
<
&
Atom
>
additional_classes
:
&
[
Atom
]
mut
f
:
F
)
-
>
bool
where
E
:
TElement
F
:
FnMut
(
&
'
a
T
)
-
>
bool
{
if
!
self
.
lookup
(
element
quirks_mode
|
entry
|
f
(
entry
)
)
{
return
false
;
}
if
let
Some
(
id
)
=
additional_id
{
if
let
Some
(
v
)
=
self
.
id_hash
.
get
(
id
quirks_mode
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
}
}
for
class
in
additional_classes
{
if
let
Some
(
v
)
=
self
.
class_hash
.
get
(
class
quirks_mode
)
{
for
entry
in
v
.
iter
(
)
{
if
!
f
(
&
entry
)
{
return
false
;
}
}
}
}
true
}
}
enum
Bucket
<
'
a
>
{
ID
(
&
'
a
Atom
)
Class
(
&
'
a
Atom
)
LocalName
{
name
:
&
'
a
LocalName
lower_name
:
&
'
a
LocalName
}
Universal
}
fn
specific_bucket_for
<
'
a
>
(
component
:
&
'
a
Component
<
SelectorImpl
>
)
-
>
Bucket
<
'
a
>
{
match
*
component
{
Component
:
:
ID
(
ref
id
)
=
>
Bucket
:
:
ID
(
id
)
Component
:
:
Class
(
ref
class
)
=
>
Bucket
:
:
Class
(
class
)
Component
:
:
LocalName
(
ref
selector
)
=
>
{
Bucket
:
:
LocalName
{
name
:
&
selector
.
name
lower_name
:
&
selector
.
lower_name
}
}
_
=
>
Bucket
:
:
Universal
}
}
#
[
inline
(
always
)
]
fn
find_bucket
<
'
a
>
(
mut
iter
:
SelectorIter
<
'
a
SelectorImpl
>
)
-
>
Bucket
<
'
a
>
{
let
mut
current_bucket
=
Bucket
:
:
Universal
;
loop
{
for
ss
in
&
mut
iter
{
let
new_bucket
=
specific_bucket_for
(
ss
)
;
match
new_bucket
{
Bucket
:
:
ID
(
.
.
)
=
>
return
new_bucket
Bucket
:
:
Class
(
.
.
)
=
>
{
current_bucket
=
new_bucket
;
}
Bucket
:
:
LocalName
{
.
.
}
=
>
{
if
matches
!
(
current_bucket
Bucket
:
:
Universal
)
{
current_bucket
=
new_bucket
;
}
}
Bucket
:
:
Universal
=
>
{
}
}
}
if
iter
.
next_sequence
(
)
!
=
Some
(
Combinator
:
:
PseudoElement
)
{
break
;
}
}
return
current_bucket
}
#
[
derive
(
Debug
MallocSizeOf
)
]
pub
struct
MaybeCaseInsensitiveHashMap
<
K
:
PrecomputedHash
+
Hash
+
Eq
V
:
'
static
>
(
PrecomputedHashMap
<
K
V
>
)
;
impl
<
V
:
'
static
>
MaybeCaseInsensitiveHashMap
<
Atom
V
>
{
pub
fn
new
(
)
-
>
Self
{
MaybeCaseInsensitiveHashMap
(
PrecomputedHashMap
:
:
default
(
)
)
}
pub
fn
try_entry
(
&
mut
self
mut
key
:
Atom
quirks_mode
:
QuirksMode
)
-
>
Result
<
hash_map
:
:
Entry
<
Atom
V
>
FailedAllocationError
>
{
if
quirks_mode
=
=
QuirksMode
:
:
Quirks
{
key
=
key
.
to_ascii_lowercase
(
)
}
self
.
0
.
try_entry
(
key
)
}
pub
fn
iter
(
&
self
)
-
>
hash_map
:
:
Iter
<
Atom
V
>
{
self
.
0
.
iter
(
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
0
.
clear
(
)
}
pub
fn
get
(
&
self
key
:
&
Atom
quirks_mode
:
QuirksMode
)
-
>
Option
<
&
V
>
{
if
quirks_mode
=
=
QuirksMode
:
:
Quirks
{
self
.
0
.
get
(
&
key
.
to_ascii_lowercase
(
)
)
}
else
{
self
.
0
.
get
(
key
)
}
}
}
