use
cssparser
:
:
{
parse_important
Parser
Token
}
;
use
parser
:
:
ParserContext
;
use
properties
:
:
{
PropertyDeclaration
PropertyId
}
;
use
std
:
:
fmt
;
use
style_traits
:
:
ToCss
;
#
[
derive
(
Debug
)
]
pub
enum
SupportsCondition
{
Not
(
Box
<
SupportsCondition
>
)
Parenthesized
(
Box
<
SupportsCondition
>
)
And
(
Vec
<
SupportsCondition
>
)
Or
(
Vec
<
SupportsCondition
>
)
Declaration
(
Declaration
)
FutureSyntax
(
String
)
}
impl
SupportsCondition
{
pub
fn
parse
(
input
:
&
mut
Parser
)
-
>
Result
<
SupportsCondition
(
)
>
{
if
let
Ok
(
_
)
=
input
.
try
(
|
i
|
i
.
expect_ident_matching
(
"
not
"
)
)
{
let
inner
=
SupportsCondition
:
:
parse_in_parens
(
input
)
?
;
return
Ok
(
SupportsCondition
:
:
Not
(
Box
:
:
new
(
inner
)
)
)
;
}
let
in_parens
=
SupportsCondition
:
:
parse_in_parens
(
input
)
?
;
let
(
keyword
wrapper
)
=
match
input
.
next
(
)
{
Err
(
(
)
)
=
>
{
return
Ok
(
in_parens
)
}
Ok
(
Token
:
:
Ident
(
ident
)
)
=
>
{
match_ignore_ascii_case
!
{
ident
"
and
"
=
>
(
"
and
"
SupportsCondition
:
:
And
as
fn
(
_
)
-
>
_
)
"
or
"
=
>
(
"
or
"
SupportsCondition
:
:
Or
as
fn
(
_
)
-
>
_
)
_
=
>
return
Err
(
(
)
)
}
}
_
=
>
return
Err
(
(
)
)
}
;
let
mut
conditions
=
Vec
:
:
with_capacity
(
2
)
;
conditions
.
push
(
in_parens
)
;
loop
{
conditions
.
push
(
SupportsCondition
:
:
parse_in_parens
(
input
)
?
)
;
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
keyword
)
)
.
is_err
(
)
{
return
Ok
(
wrapper
(
conditions
)
)
}
}
}
fn
parse_in_parens
(
input
:
&
mut
Parser
)
-
>
Result
<
SupportsCondition
(
)
>
{
while
input
.
try
(
Parser
:
:
expect_whitespace
)
.
is_ok
(
)
{
}
let
pos
=
input
.
position
(
)
;
match
input
.
next
(
)
?
{
Token
:
:
ParenthesisBlock
=
>
{
input
.
parse_nested_block
(
|
input
|
{
parse_condition_or_declaration
(
input
)
.
or_else
(
|
(
)
|
{
consume_all
(
input
)
;
Ok
(
SupportsCondition
:
:
FutureSyntax
(
input
.
slice_from
(
pos
)
.
to_owned
(
)
)
)
}
)
}
)
}
Token
:
:
Function
(
_
)
=
>
{
input
.
parse_nested_block
(
|
i
|
Ok
(
consume_all
(
i
)
)
)
.
unwrap
(
)
;
Ok
(
SupportsCondition
:
:
FutureSyntax
(
input
.
slice_from
(
pos
)
.
to_owned
(
)
)
)
}
_
=
>
Err
(
(
)
)
}
}
pub
fn
eval
(
&
self
cx
:
&
ParserContext
)
-
>
bool
{
match
*
self
{
SupportsCondition
:
:
Not
(
ref
cond
)
=
>
!
cond
.
eval
(
cx
)
SupportsCondition
:
:
Parenthesized
(
ref
cond
)
=
>
cond
.
eval
(
cx
)
SupportsCondition
:
:
And
(
ref
vec
)
=
>
vec
.
iter
(
)
.
all
(
|
c
|
c
.
eval
(
cx
)
)
SupportsCondition
:
:
Or
(
ref
vec
)
=
>
vec
.
iter
(
)
.
any
(
|
c
|
c
.
eval
(
cx
)
)
SupportsCondition
:
:
Declaration
(
ref
decl
)
=
>
decl
.
eval
(
cx
)
SupportsCondition
:
:
FutureSyntax
(
_
)
=
>
false
}
}
}
pub
fn
parse_condition_or_declaration
(
input
:
&
mut
Parser
)
-
>
Result
<
SupportsCondition
(
)
>
{
if
let
Ok
(
condition
)
=
input
.
try
(
SupportsCondition
:
:
parse
)
{
Ok
(
SupportsCondition
:
:
Parenthesized
(
Box
:
:
new
(
condition
)
)
)
}
else
{
Declaration
:
:
parse
(
input
)
.
map
(
SupportsCondition
:
:
Declaration
)
}
}
impl
ToCss
for
SupportsCondition
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
SupportsCondition
:
:
Not
(
ref
cond
)
=
>
{
dest
.
write_str
(
"
not
"
)
?
;
cond
.
to_css
(
dest
)
}
SupportsCondition
:
:
Parenthesized
(
ref
cond
)
=
>
{
dest
.
write_str
(
"
(
"
)
?
;
cond
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
SupportsCondition
:
:
And
(
ref
vec
)
=
>
{
let
mut
first
=
true
;
for
cond
in
vec
{
if
!
first
{
dest
.
write_str
(
"
and
"
)
?
;
}
first
=
false
;
cond
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
SupportsCondition
:
:
Or
(
ref
vec
)
=
>
{
let
mut
first
=
true
;
for
cond
in
vec
{
if
!
first
{
dest
.
write_str
(
"
or
"
)
?
;
}
first
=
false
;
cond
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
SupportsCondition
:
:
Declaration
(
ref
decl
)
=
>
{
dest
.
write_str
(
"
(
"
)
?
;
decl
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
)
"
)
}
SupportsCondition
:
:
FutureSyntax
(
ref
s
)
=
>
dest
.
write_str
(
&
s
)
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
Declaration
{
pub
prop
:
String
pub
val
:
String
}
impl
ToCss
for
Declaration
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_str
(
&
self
.
prop
)
?
;
dest
.
write_str
(
"
:
"
)
?
;
dest
.
write_str
(
&
self
.
val
)
}
}
fn
parse_anything
(
input
:
&
mut
Parser
)
-
>
String
{
let
pos
=
input
.
position
(
)
;
consume_all
(
input
)
;
input
.
slice_from
(
pos
)
.
to_owned
(
)
}
fn
consume_all
(
input
:
&
mut
Parser
)
{
while
let
Ok
(
_
)
=
input
.
next
(
)
{
}
}
impl
Declaration
{
pub
fn
parse
(
input
:
&
mut
Parser
)
-
>
Result
<
Declaration
(
)
>
{
let
prop
=
input
.
expect_ident
(
)
?
.
into_owned
(
)
;
input
.
expect_colon
(
)
?
;
let
val
=
parse_anything
(
input
)
;
Ok
(
Declaration
{
prop
:
prop
val
:
val
}
)
}
pub
fn
eval
(
&
self
cx
:
&
ParserContext
)
-
>
bool
{
use
properties
:
:
PropertyDeclarationParseResult
:
:
*
;
let
id
=
if
let
Ok
(
id
)
=
PropertyId
:
:
parse
(
(
&
*
self
.
prop
)
.
into
(
)
)
{
id
}
else
{
return
false
}
;
let
mut
input
=
Parser
:
:
new
(
&
self
.
val
)
;
let
mut
list
=
Vec
:
:
new
(
)
;
let
res
=
PropertyDeclaration
:
:
parse
(
id
cx
&
mut
input
&
mut
list
false
)
;
let
_
=
input
.
try
(
parse_important
)
;
if
!
input
.
is_exhausted
(
)
{
return
false
;
}
match
res
{
UnknownProperty
=
>
false
ExperimentalProperty
=
>
false
InvalidValue
=
>
false
AnimationPropertyInKeyframeBlock
=
>
unreachable
!
(
)
ValidOrIgnoredDeclaration
=
>
true
}
}
}
