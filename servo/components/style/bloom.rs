use
dom
:
:
{
TNode
TElement
UnsafeNode
}
;
use
matching
:
:
MatchMethods
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
pub
struct
StyleBloom
{
filter
:
Box
<
BloomFilter
>
elements
:
Vec
<
UnsafeNode
>
generation
:
u32
}
impl
StyleBloom
{
pub
fn
new
(
generation
:
u32
)
-
>
Self
{
StyleBloom
{
filter
:
Box
:
:
new
(
BloomFilter
:
:
new
(
)
)
elements
:
vec
!
[
]
generation
:
generation
}
}
pub
fn
filter
(
&
self
)
-
>
&
BloomFilter
{
&
*
self
.
filter
}
pub
fn
generation
(
&
self
)
-
>
u32
{
self
.
generation
}
pub
fn
maybe_pop
<
E
>
(
&
mut
self
element
:
E
)
where
E
:
TElement
+
MatchMethods
{
if
self
.
elements
.
last
(
)
=
=
Some
(
&
element
.
as_node
(
)
.
to_unsafe
(
)
)
{
self
.
pop
:
:
<
E
>
(
)
.
unwrap
(
)
;
}
}
pub
fn
push
<
E
>
(
&
mut
self
element
:
E
)
where
E
:
TElement
+
MatchMethods
{
if
cfg
!
(
debug_assertions
)
{
if
self
.
elements
.
is_empty
(
)
{
assert
!
(
element
.
parent_element
(
)
.
is_none
(
)
)
;
}
}
element
.
insert_into_bloom_filter
(
&
mut
*
self
.
filter
)
;
self
.
elements
.
push
(
element
.
as_node
(
)
.
to_unsafe
(
)
)
;
}
fn
pop
<
E
>
(
&
mut
self
)
-
>
Option
<
E
>
where
E
:
TElement
+
MatchMethods
{
let
popped
=
self
.
elements
.
pop
(
)
.
map
(
|
unsafe_node
|
{
let
parent
=
unsafe
{
E
:
:
ConcreteNode
:
:
from_unsafe
(
&
unsafe_node
)
}
;
parent
.
as_element
(
)
.
unwrap
(
)
}
)
;
if
let
Some
(
popped
)
=
popped
{
popped
.
remove_from_bloom_filter
(
&
mut
self
.
filter
)
;
}
popped
}
fn
clear
(
&
mut
self
)
{
self
.
filter
.
clear
(
)
;
self
.
elements
.
clear
(
)
;
}
fn
rebuild
<
E
>
(
&
mut
self
mut
element
:
E
)
-
>
usize
where
E
:
TElement
+
MatchMethods
{
self
.
clear
(
)
;
while
let
Some
(
parent
)
=
element
.
parent_element
(
)
{
parent
.
insert_into_bloom_filter
(
&
mut
*
self
.
filter
)
;
self
.
elements
.
push
(
parent
.
as_node
(
)
.
to_unsafe
(
)
)
;
element
=
parent
;
}
self
.
elements
.
reverse
(
)
;
return
self
.
elements
.
len
(
)
;
}
pub
fn
assert_complete
<
E
>
(
&
self
mut
element
:
E
)
where
E
:
TElement
{
if
cfg
!
(
debug_assertions
)
{
let
mut
checked
=
0
;
while
let
Some
(
parent
)
=
element
.
parent_element
(
)
{
assert_eq
!
(
parent
.
as_node
(
)
.
to_unsafe
(
)
self
.
elements
[
self
.
elements
.
len
(
)
-
1
-
checked
]
)
;
element
=
parent
;
checked
+
=
1
;
}
assert_eq
!
(
checked
self
.
elements
.
len
(
)
)
;
}
}
pub
fn
insert_parents_recovering
<
E
>
(
&
mut
self
element
:
E
element_depth
:
Option
<
usize
>
generation
:
u32
)
-
>
usize
where
E
:
TElement
{
if
self
.
generation
!
=
generation
|
|
self
.
elements
.
is_empty
(
)
{
self
.
generation
=
generation
;
return
self
.
rebuild
(
element
)
;
}
let
parent_element
=
match
element
.
parent_element
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
{
self
.
clear
(
)
;
return
0
;
}
}
;
let
unsafe_parent
=
parent_element
.
as_node
(
)
.
to_unsafe
(
)
;
if
self
.
elements
.
last
(
)
=
=
Some
(
&
unsafe_parent
)
{
return
self
.
elements
.
len
(
)
;
}
let
element_depth
=
match
element_depth
{
Some
(
depth
)
=
>
depth
None
=
>
{
return
self
.
rebuild
(
element
)
;
}
}
;
debug_assert
!
(
element_depth
!
=
0
"
We
should
have
already
cleared
the
bloom
filter
"
)
;
debug_assert
!
(
!
self
.
elements
.
is_empty
(
)
"
How
!
We
should
'
ve
just
rebuilt
!
"
)
;
let
mut
current_depth
=
self
.
elements
.
len
(
)
-
1
;
while
current_depth
>
=
element_depth
-
1
{
self
.
pop
:
:
<
E
>
(
)
.
expect
(
"
Emilio
is
bad
at
math
"
)
;
current_depth
-
=
1
;
}
let
mut
common_parent
=
parent_element
;
let
mut
common_parent_depth
=
element_depth
-
1
;
let
mut
parents_to_insert
=
vec
!
[
]
;
while
common_parent_depth
>
current_depth
{
parents_to_insert
.
push
(
common_parent
)
;
common_parent
=
common_parent
.
parent_element
(
)
.
expect
(
"
We
were
lied
"
)
;
common_parent_depth
-
=
1
;
}
debug_assert_eq
!
(
common_parent_depth
current_depth
)
;
while
*
self
.
elements
.
last
(
)
.
unwrap
(
)
!
=
common_parent
.
as_node
(
)
.
to_unsafe
(
)
{
parents_to_insert
.
push
(
common_parent
)
;
common_parent
=
common_parent
.
parent_element
(
)
.
expect
(
"
We
were
lied
again
?
"
)
;
self
.
pop
:
:
<
E
>
(
)
.
unwrap
(
)
;
}
for
parent
in
parents_to_insert
.
into_iter
(
)
.
rev
(
)
{
self
.
push
(
parent
)
;
}
debug_assert_eq
!
(
self
.
elements
.
len
(
)
element_depth
)
;
return
self
.
elements
.
len
(
)
;
}
}
