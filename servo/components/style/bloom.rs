#
!
[
deny
(
missing_docs
)
]
use
dom
:
:
{
SendElement
TElement
}
;
use
matching
:
:
MatchMethods
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
pub
struct
StyleBloom
<
E
:
TElement
>
{
filter
:
Box
<
BloomFilter
>
elements
:
Vec
<
SendElement
<
E
>
>
}
impl
<
E
:
TElement
>
StyleBloom
<
E
>
{
pub
fn
new
(
)
-
>
Self
{
StyleBloom
{
filter
:
Box
:
:
new
(
BloomFilter
:
:
new
(
)
)
elements
:
vec
!
[
]
}
}
pub
fn
filter
(
&
self
)
-
>
&
BloomFilter
{
&
*
self
.
filter
}
pub
fn
push
(
&
mut
self
element
:
E
)
{
if
cfg
!
(
debug_assertions
)
{
if
self
.
elements
.
is_empty
(
)
{
assert
!
(
element
.
parent_element
(
)
.
is_none
(
)
)
;
}
}
element
.
insert_into_bloom_filter
(
&
mut
*
self
.
filter
)
;
self
.
elements
.
push
(
unsafe
{
SendElement
:
:
new
(
element
)
}
)
;
}
fn
pop
(
&
mut
self
)
-
>
Option
<
E
>
{
let
popped
=
self
.
elements
.
pop
(
)
.
map
(
|
el
|
*
el
)
;
if
let
Some
(
popped
)
=
popped
{
popped
.
remove_from_bloom_filter
(
&
mut
self
.
filter
)
;
}
popped
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
elements
.
is_empty
(
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
filter
.
clear
(
)
;
self
.
elements
.
clear
(
)
;
}
pub
fn
rebuild
(
&
mut
self
mut
element
:
E
)
-
>
usize
{
self
.
clear
(
)
;
while
let
Some
(
parent
)
=
element
.
parent_element
(
)
{
parent
.
insert_into_bloom_filter
(
&
mut
*
self
.
filter
)
;
self
.
elements
.
push
(
unsafe
{
SendElement
:
:
new
(
parent
)
}
)
;
element
=
parent
;
}
self
.
elements
.
reverse
(
)
;
return
self
.
elements
.
len
(
)
;
}
pub
fn
assert_complete
(
&
self
mut
element
:
E
)
{
if
cfg
!
(
debug_assertions
)
{
let
mut
checked
=
0
;
while
let
Some
(
parent
)
=
element
.
parent_element
(
)
{
assert_eq
!
(
parent
*
self
.
elements
[
self
.
elements
.
len
(
)
-
1
-
checked
]
)
;
element
=
parent
;
checked
+
=
1
;
}
assert_eq
!
(
checked
self
.
elements
.
len
(
)
)
;
}
}
pub
fn
insert_parents_recovering
(
&
mut
self
element
:
E
element_depth
:
Option
<
usize
>
)
-
>
usize
{
if
self
.
elements
.
is_empty
(
)
{
return
self
.
rebuild
(
element
)
;
}
let
parent_element
=
match
element
.
parent_element
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
{
self
.
clear
(
)
;
return
0
;
}
}
;
if
self
.
elements
.
last
(
)
.
map
(
|
el
|
*
*
el
)
=
=
Some
(
parent_element
)
{
return
self
.
elements
.
len
(
)
;
}
let
element_depth
=
match
element_depth
{
Some
(
depth
)
=
>
depth
None
=
>
{
return
self
.
rebuild
(
element
)
;
}
}
;
debug_assert
!
(
element_depth
!
=
0
"
We
should
have
already
cleared
the
bloom
filter
"
)
;
debug_assert
!
(
!
self
.
elements
.
is_empty
(
)
"
How
!
We
should
'
ve
just
rebuilt
!
"
)
;
let
mut
current_depth
=
self
.
elements
.
len
(
)
-
1
;
while
current_depth
>
element_depth
-
1
{
self
.
pop
(
)
.
expect
(
"
Emilio
is
bad
at
math
"
)
;
current_depth
-
=
1
;
}
let
mut
common_parent
=
parent_element
;
let
mut
common_parent_depth
=
element_depth
-
1
;
let
mut
parents_to_insert
=
vec
!
[
]
;
while
common_parent_depth
>
current_depth
{
parents_to_insert
.
push
(
common_parent
)
;
common_parent
=
common_parent
.
parent_element
(
)
.
expect
(
"
We
were
lied
"
)
;
common_parent_depth
-
=
1
;
}
debug_assert_eq
!
(
common_parent_depth
current_depth
)
;
while
*
*
self
.
elements
.
last
(
)
.
unwrap
(
)
!
=
common_parent
{
parents_to_insert
.
push
(
common_parent
)
;
self
.
pop
(
)
.
unwrap
(
)
;
common_parent
=
match
common_parent
.
parent_element
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
{
debug_assert
!
(
self
.
elements
.
is_empty
(
)
)
;
if
cfg
!
(
feature
=
"
gecko
"
)
{
break
;
}
else
{
panic
!
(
"
should
have
found
a
common
ancestor
"
)
;
}
}
}
}
for
parent
in
parents_to_insert
.
into_iter
(
)
.
rev
(
)
{
self
.
push
(
parent
)
;
}
debug_assert_eq
!
(
self
.
elements
.
len
(
)
element_depth
)
;
return
self
.
elements
.
len
(
)
;
}
}
