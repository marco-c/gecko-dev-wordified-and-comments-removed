#
!
[
deny
(
missing_docs
)
]
use
dom
:
:
{
SendElement
TElement
}
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
pub
struct
StyleBloom
<
E
:
TElement
>
{
filter
:
Box
<
BloomFilter
>
elements
:
Vec
<
SendElement
<
E
>
>
}
fn
each_relevant_element_hash
<
E
F
>
(
element
:
E
mut
f
:
F
)
where
E
:
TElement
F
:
FnMut
(
u32
)
{
f
(
element
.
get_local_name
(
)
.
get_hash
(
)
)
;
f
(
element
.
get_namespace
(
)
.
get_hash
(
)
)
;
if
let
Some
(
id
)
=
element
.
get_id
(
)
{
f
(
id
.
get_hash
(
)
)
;
}
element
.
each_class
(
|
class
|
{
f
(
class
.
get_hash
(
)
)
}
)
;
}
impl
<
E
:
TElement
>
StyleBloom
<
E
>
{
pub
fn
new
(
)
-
>
Self
{
StyleBloom
{
filter
:
Box
:
:
new
(
BloomFilter
:
:
new
(
)
)
elements
:
vec
!
[
]
}
}
pub
fn
filter
(
&
self
)
-
>
&
BloomFilter
{
&
*
self
.
filter
}
pub
fn
push
(
&
mut
self
element
:
E
)
{
if
cfg
!
(
debug_assertions
)
{
if
self
.
elements
.
is_empty
(
)
{
assert
!
(
element
.
parent_element
(
)
.
is_none
(
)
)
;
}
}
self
.
push_internal
(
element
)
;
}
fn
push_internal
(
&
mut
self
element
:
E
)
{
each_relevant_element_hash
(
element
|
hash
|
{
self
.
filter
.
insert_hash
(
hash
)
;
}
)
;
self
.
elements
.
push
(
unsafe
{
SendElement
:
:
new
(
element
)
}
)
;
}
fn
pop
(
&
mut
self
)
-
>
Option
<
E
>
{
let
popped
=
self
.
elements
.
pop
(
)
.
map
(
|
el
|
*
el
)
;
if
let
Some
(
popped
)
=
popped
{
each_relevant_element_hash
(
popped
|
hash
|
{
self
.
filter
.
remove_hash
(
hash
)
;
}
)
}
popped
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
elements
.
is_empty
(
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
filter
.
clear
(
)
;
self
.
elements
.
clear
(
)
;
}
pub
fn
rebuild
(
&
mut
self
mut
element
:
E
)
{
self
.
clear
(
)
;
while
let
Some
(
parent
)
=
element
.
parent_element
(
)
{
self
.
push_internal
(
parent
)
;
element
=
parent
;
}
self
.
elements
.
reverse
(
)
;
}
pub
fn
assert_complete
(
&
self
mut
element
:
E
)
{
if
cfg
!
(
debug_assertions
)
{
let
mut
checked
=
0
;
while
let
Some
(
parent
)
=
element
.
parent_element
(
)
{
assert_eq
!
(
parent
*
self
.
elements
[
self
.
elements
.
len
(
)
-
1
-
checked
]
)
;
element
=
parent
;
checked
+
=
1
;
}
assert_eq
!
(
checked
self
.
elements
.
len
(
)
)
;
}
}
pub
fn
insert_parents_recovering
(
&
mut
self
element
:
E
element_depth
:
usize
)
{
if
self
.
elements
.
is_empty
(
)
{
self
.
rebuild
(
element
)
;
return
;
}
let
parent_element
=
match
element
.
parent_element
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
{
self
.
clear
(
)
;
return
;
}
}
;
if
self
.
elements
.
last
(
)
.
map
(
|
el
|
*
*
el
)
=
=
Some
(
parent_element
)
{
return
;
}
if
element_depth
=
=
0
{
self
.
clear
(
)
;
return
;
}
debug_assert
!
(
element_depth
!
=
0
"
We
should
have
already
cleared
the
bloom
filter
"
)
;
debug_assert
!
(
!
self
.
elements
.
is_empty
(
)
"
How
!
We
should
'
ve
just
rebuilt
!
"
)
;
let
mut
current_depth
=
self
.
elements
.
len
(
)
-
1
;
while
current_depth
>
element_depth
-
1
{
self
.
pop
(
)
.
expect
(
"
Emilio
is
bad
at
math
"
)
;
current_depth
-
=
1
;
}
let
mut
common_parent
=
parent_element
;
let
mut
common_parent_depth
=
element_depth
-
1
;
let
mut
parents_to_insert
=
vec
!
[
]
;
while
common_parent_depth
>
current_depth
{
parents_to_insert
.
push
(
common_parent
)
;
common_parent
=
common_parent
.
parent_element
(
)
.
expect
(
"
We
were
lied
"
)
;
common_parent_depth
-
=
1
;
}
debug_assert_eq
!
(
common_parent_depth
current_depth
)
;
while
*
*
self
.
elements
.
last
(
)
.
unwrap
(
)
!
=
common_parent
{
parents_to_insert
.
push
(
common_parent
)
;
self
.
pop
(
)
.
unwrap
(
)
;
common_parent
=
match
common_parent
.
parent_element
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
{
debug_assert
!
(
self
.
elements
.
is_empty
(
)
)
;
if
cfg
!
(
feature
=
"
gecko
"
)
{
break
;
}
else
{
panic
!
(
"
should
have
found
a
common
ancestor
"
)
;
}
}
}
}
for
parent
in
parents_to_insert
.
into_iter
(
)
.
rev
(
)
{
self
.
push
(
parent
)
;
}
debug_assert_eq
!
(
self
.
elements
.
len
(
)
element_depth
)
;
}
}
