use
euclid
:
:
approxeq
:
:
ApproxEq
;
use
itertools
:
:
Itertools
;
use
crate
:
:
values
:
:
CSSFloat
;
type
ValueType
=
CSSFloat
;
#
[
derive
(
Clone
Copy
)
]
#
[
repr
(
C
)
]
struct
Entry
{
x
:
ValueType
y
:
ValueType
}
#
[
derive
(
Default
)
]
#
[
repr
(
C
)
]
pub
struct
PiecewiseLinearFunction
{
entries
:
crate
:
:
OwnedSlice
<
Entry
>
}
impl
PiecewiseLinearFunction
{
fn
interpolate
(
x
:
ValueType
prev
:
Entry
next
:
Entry
asymptote
:
&
Entry
)
-
>
ValueType
{
if
prev
.
x
.
approx_eq
(
&
next
.
x
)
{
return
asymptote
.
y
;
}
let
slope
=
(
next
.
y
-
prev
.
y
)
/
(
next
.
x
-
prev
.
x
)
;
return
slope
*
(
x
-
asymptote
.
x
)
+
asymptote
.
y
;
}
pub
fn
at
(
&
self
x
:
ValueType
)
-
>
ValueType
{
if
!
x
.
is_finite
(
)
{
return
if
x
>
0
.
0
{
1
.
0
}
else
{
0
.
0
}
;
}
if
self
.
entries
.
is_empty
(
)
{
return
x
;
}
if
self
.
entries
.
len
(
)
=
=
1
{
return
self
.
entries
[
0
]
.
y
;
}
if
x
<
self
.
entries
[
0
]
.
x
{
return
Self
:
:
interpolate
(
x
self
.
entries
[
0
]
self
.
entries
[
1
]
&
self
.
entries
[
0
]
)
;
}
let
mut
rev_iter
=
self
.
entries
.
iter
(
)
.
rev
(
)
;
let
last
=
rev_iter
.
next
(
)
.
unwrap
(
)
;
if
x
>
last
.
x
{
let
second_last
=
rev_iter
.
next
(
)
.
unwrap
(
)
;
return
Self
:
:
interpolate
(
x
*
second_last
*
last
last
)
;
}
for
(
prev
next
)
in
self
.
entries
.
iter
(
)
.
tuple_windows
(
)
{
if
x
>
next
.
x
{
continue
;
}
if
x
.
approx_eq
(
&
prev
.
x
)
{
return
prev
.
y
;
}
if
x
.
approx_eq
(
&
next
.
x
)
{
return
next
.
y
;
}
return
Self
:
:
interpolate
(
x
*
prev
*
next
prev
)
;
}
unreachable
!
(
"
Input
is
supposed
to
be
within
the
entries
'
min
&
max
!
"
)
;
}
}
#
[
derive
(
Clone
Copy
)
]
struct
BuildEntry
{
x
:
Option
<
ValueType
>
y
:
ValueType
}
#
[
derive
(
Default
)
]
pub
struct
PiecewiseLinearFunctionBuilder
{
largest_x
:
Option
<
ValueType
>
smallest_x
:
Option
<
ValueType
>
entries
:
Vec
<
BuildEntry
>
}
impl
PiecewiseLinearFunctionBuilder
{
#
[
allow
(
missing_docs
)
]
pub
fn
new
(
)
-
>
Self
{
PiecewiseLinearFunctionBuilder
:
:
default
(
)
}
fn
create_entry
(
&
mut
self
y
:
ValueType
x
:
Option
<
ValueType
>
)
{
let
x
=
match
x
{
Some
(
x
)
if
x
.
is_finite
(
)
=
>
x
_
=
>
{
self
.
entries
.
push
(
BuildEntry
{
x
:
None
y
}
)
;
return
;
}
}
;
let
x
=
match
self
.
largest_x
{
Some
(
largest_x
)
=
>
x
.
max
(
largest_x
)
None
=
>
x
}
;
self
.
largest_x
=
Some
(
x
)
;
if
self
.
smallest_x
.
is_none
(
)
{
self
.
smallest_x
=
Some
(
x
)
;
}
self
.
entries
.
push
(
BuildEntry
{
x
:
Some
(
x
)
y
}
)
;
}
pub
fn
push
(
mut
self
y
:
CSSFloat
x_start
:
Option
<
CSSFloat
>
x_end
:
Option
<
CSSFloat
>
)
-
>
Self
{
self
.
create_entry
(
y
x_start
)
;
if
x_end
.
is_some
(
)
{
self
.
create_entry
(
y
x_end
.
map
(
|
x
|
x
)
)
;
}
self
}
pub
fn
build
(
mut
self
)
-
>
PiecewiseLinearFunction
{
if
self
.
entries
.
is_empty
(
)
{
return
PiecewiseLinearFunction
:
:
default
(
)
;
}
if
self
.
entries
.
len
(
)
=
=
1
{
return
PiecewiseLinearFunction
{
entries
:
crate
:
:
OwnedSlice
:
:
from_slice
(
&
[
Entry
{
x
:
0
.
y
:
self
.
entries
[
0
]
.
y
}
]
)
}
;
}
self
.
entries
[
0
]
.
x
.
get_or_insert
(
self
.
smallest_x
.
filter
(
|
x
|
x
<
&
0
.
0
)
.
unwrap_or
(
0
.
0
)
)
;
self
.
entries
.
last_mut
(
)
.
unwrap
(
)
.
x
.
get_or_insert
(
self
.
largest_x
.
filter
(
|
x
|
x
>
&
1
.
0
)
.
unwrap_or
(
1
.
0
)
)
;
let
mut
result
=
Vec
:
:
with_capacity
(
self
.
entries
.
len
(
)
)
;
result
.
push
(
Entry
{
x
:
self
.
entries
[
0
]
.
x
.
unwrap
(
)
y
:
self
.
entries
[
0
]
.
y
}
)
;
for
(
i
e
)
in
self
.
entries
.
iter
(
)
.
enumerate
(
)
.
skip
(
1
)
{
if
e
.
x
.
is_none
(
)
{
continue
;
}
let
divisor
=
i
-
result
.
len
(
)
+
1
;
if
divisor
!
=
1
{
let
start_x
=
result
.
last
(
)
.
unwrap
(
)
.
x
;
let
increment
=
(
e
.
x
.
unwrap
(
)
-
start_x
)
/
divisor
as
ValueType
;
result
.
extend
(
self
.
entries
[
result
.
len
(
)
.
.
i
]
.
iter
(
)
.
enumerate
(
)
.
map
(
|
(
j
e
)
|
{
debug_assert
!
(
e
.
x
.
is_none
(
)
"
Expected
an
entry
with
x
undefined
!
"
)
;
Entry
{
x
:
increment
*
(
j
+
1
)
as
ValueType
+
start_x
y
:
e
.
y
}
}
)
)
;
}
result
.
push
(
Entry
{
x
:
e
.
x
.
unwrap
(
)
y
:
e
.
y
}
)
;
}
debug_assert_eq
!
(
result
.
len
(
)
self
.
entries
.
len
(
)
"
Should
'
ve
mapped
one
-
to
-
one
!
"
)
;
PiecewiseLinearFunction
{
entries
:
result
.
into
(
)
}
}
}
