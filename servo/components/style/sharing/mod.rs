use
Atom
;
use
bit_vec
:
:
BitVec
;
use
cache
:
:
{
LRUCache
LRUCacheMutIterator
}
;
use
context
:
:
{
CurrentElementInfo
SelectorFlagsMap
SharedStyleContext
}
;
use
data
:
:
{
ComputedStyle
ElementData
ElementStyles
}
;
use
dom
:
:
{
TElement
SendElement
}
;
use
matching
:
:
{
ChildCascadeRequirement
MatchMethods
}
;
use
properties
:
:
ComputedValues
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
use
selectors
:
:
matching
:
:
StyleRelations
;
use
sink
:
:
ForgetfulSink
;
mod
checks
;
pub
const
STYLE_SHARING_CANDIDATE_CACHE_SIZE
:
usize
=
8
;
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
StyleSharingBehavior
{
Allow
Disallow
}
#
[
derive
(
Debug
)
]
pub
struct
StyleSharingCandidate
<
E
:
TElement
>
{
element
:
SendElement
<
E
>
class_attributes
:
Option
<
Vec
<
Atom
>
>
revalidation_match_results
:
Option
<
BitVec
>
}
impl
<
E
:
TElement
>
PartialEq
<
StyleSharingCandidate
<
E
>
>
for
StyleSharingCandidate
<
E
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
element
=
=
other
.
element
}
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
CacheMiss
{
Parent
NativeAnonymousContent
LocalName
Namespace
Link
UserAndAuthorRules
State
IdAttr
StyleAttr
Class
PresHints
Revalidation
}
pub
enum
StyleSharingResult
{
CannotShare
StyleWasShared
(
usize
ChildCascadeRequirement
)
}
pub
struct
StyleSharingCandidateCache
<
E
:
TElement
>
{
cache
:
LRUCache
<
StyleSharingCandidate
<
E
>
>
}
impl
<
E
:
TElement
>
StyleSharingCandidateCache
<
E
>
{
pub
fn
new
(
)
-
>
Self
{
StyleSharingCandidateCache
{
cache
:
LRUCache
:
:
new
(
STYLE_SHARING_CANDIDATE_CACHE_SIZE
)
}
}
pub
fn
num_entries
(
&
self
)
-
>
usize
{
self
.
cache
.
num_entries
(
)
}
fn
iter_mut
(
&
mut
self
)
-
>
LRUCacheMutIterator
<
StyleSharingCandidate
<
E
>
>
{
self
.
cache
.
iter_mut
(
)
}
pub
fn
insert_if_possible
(
&
mut
self
element
:
&
E
style
:
&
ComputedValues
relations
:
StyleRelations
revalidation_match_results
:
Option
<
BitVec
>
)
{
let
parent
=
match
element
.
parent_element
(
)
{
Some
(
element
)
=
>
element
None
=
>
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
no
parent
element
"
)
;
return
;
}
}
;
if
element
.
is_native_anonymous
(
)
{
debug
!
(
"
Failing
to
insert
into
the
cache
:
NAC
"
)
;
return
;
}
if
!
checks
:
:
relations_are_shareable
(
&
relations
)
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
{
:
?
}
"
relations
)
;
return
;
}
if
cfg
!
(
debug_assertions
)
{
let
mut
hints
=
ForgetfulSink
:
:
new
(
)
;
element
.
synthesize_presentational_hints_for_legacy_attributes
(
&
mut
hints
)
;
debug_assert
!
(
hints
.
is_empty
(
)
"
Style
relations
should
not
be
shareable
!
"
)
;
}
let
box_style
=
style
.
get_box
(
)
;
if
box_style
.
specifies_transitions
(
)
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
transitions
"
)
;
return
;
}
if
box_style
.
specifies_animations
(
)
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
animations
"
)
;
return
;
}
debug
!
(
"
Inserting
into
cache
:
{
:
?
}
with
parent
{
:
?
}
"
element
parent
)
;
self
.
cache
.
insert
(
StyleSharingCandidate
{
element
:
unsafe
{
SendElement
:
:
new
(
*
element
)
}
class_attributes
:
None
revalidation_match_results
:
revalidation_match_results
}
)
;
}
pub
fn
touch
(
&
mut
self
index
:
usize
)
{
self
.
cache
.
touch
(
index
)
;
}
pub
fn
clear
(
&
mut
self
)
{
self
.
cache
.
evict_all
(
)
}
pub
unsafe
fn
share_style_if_possible
(
&
mut
self
shared_context
:
&
SharedStyleContext
current_element_info
:
&
mut
CurrentElementInfo
selector_flags_map
:
&
mut
SelectorFlagsMap
<
E
>
bloom_filter
:
&
BloomFilter
element
:
E
data
:
&
mut
ElementData
)
-
>
StyleSharingResult
{
if
shared_context
.
options
.
disable_style_sharing_cache
{
debug
!
(
"
{
:
?
}
Cannot
share
style
:
style
sharing
cache
disabled
"
element
)
;
return
StyleSharingResult
:
:
CannotShare
}
if
element
.
parent_element
(
)
.
is_none
(
)
{
debug
!
(
"
{
:
?
}
Cannot
share
style
:
element
has
no
parent
"
element
)
;
return
StyleSharingResult
:
:
CannotShare
}
if
element
.
is_native_anonymous
(
)
{
debug
!
(
"
{
:
?
}
Cannot
share
style
:
NAC
"
element
)
;
return
StyleSharingResult
:
:
CannotShare
;
}
if
element
.
style_attribute
(
)
.
is_some
(
)
{
debug
!
(
"
{
:
?
}
Cannot
share
style
:
element
has
style
attribute
"
element
)
;
return
StyleSharingResult
:
:
CannotShare
}
if
element
.
get_id
(
)
.
is_some
(
)
{
debug
!
(
"
{
:
?
}
Cannot
share
style
:
element
has
id
"
element
)
;
return
StyleSharingResult
:
:
CannotShare
}
let
mut
should_clear_cache
=
false
;
for
(
i
candidate
)
in
self
.
iter_mut
(
)
.
enumerate
(
)
{
let
sharing_result
=
Self
:
:
test_candidate
(
element
candidate
&
shared_context
bloom_filter
current_element_info
selector_flags_map
)
;
match
sharing_result
{
Ok
(
shared_style
)
=
>
{
debug_assert_eq
!
(
data
.
has_styles
(
)
data
.
has_restyle
(
)
)
;
let
old_values
=
data
.
get_styles_mut
(
)
.
and_then
(
|
s
|
s
.
primary
.
values
.
take
(
)
)
;
let
child_cascade_requirement
=
element
.
accumulate_damage
(
&
shared_context
data
.
get_restyle_mut
(
)
old_values
.
as_ref
(
)
.
map
(
|
v
|
&
*
*
v
)
shared_style
.
values
(
)
None
)
;
let
styles
=
ElementStyles
:
:
new
(
shared_style
)
;
data
.
set_styles
(
styles
)
;
return
StyleSharingResult
:
:
StyleWasShared
(
i
child_cascade_requirement
)
}
Err
(
miss
)
=
>
{
debug
!
(
"
Cache
miss
:
{
:
?
}
"
miss
)
;
match
miss
{
CacheMiss
:
:
Parent
=
>
{
should_clear_cache
=
true
;
break
;
}
CacheMiss
:
:
PresHints
|
CacheMiss
:
:
Revalidation
=
>
break
_
=
>
{
}
}
}
}
}
debug
!
(
"
{
:
?
}
Cannot
share
style
:
{
}
cache
entries
"
element
self
.
cache
.
num_entries
(
)
)
;
if
should_clear_cache
{
self
.
clear
(
)
;
}
StyleSharingResult
:
:
CannotShare
}
fn
test_candidate
(
element
:
E
candidate
:
&
mut
StyleSharingCandidate
<
E
>
shared
:
&
SharedStyleContext
bloom
:
&
BloomFilter
info
:
&
mut
CurrentElementInfo
selector_flags_map
:
&
mut
SelectorFlagsMap
<
E
>
)
-
>
Result
<
ComputedStyle
CacheMiss
>
{
macro_rules
!
miss
{
(
miss
:
ident
)
=
>
{
return
Err
(
CacheMiss
:
:
miss
)
;
}
}
let
parent
=
element
.
parent_element
(
)
;
let
candidate_parent
=
candidate
.
element
.
parent_element
(
)
;
if
parent
!
=
candidate_parent
&
&
!
checks
:
:
same_computed_values
(
parent
candidate_parent
)
{
miss
!
(
Parent
)
}
if
element
.
is_native_anonymous
(
)
{
debug_assert
!
(
!
candidate
.
element
.
is_native_anonymous
(
)
"
Why
inserting
NAC
into
the
cache
?
"
)
;
miss
!
(
NativeAnonymousContent
)
}
if
*
element
.
get_local_name
(
)
!
=
*
candidate
.
element
.
get_local_name
(
)
{
miss
!
(
LocalName
)
}
if
*
element
.
get_namespace
(
)
!
=
*
candidate
.
element
.
get_namespace
(
)
{
miss
!
(
Namespace
)
}
if
element
.
is_link
(
)
!
=
candidate
.
element
.
is_link
(
)
{
miss
!
(
Link
)
}
if
element
.
matches_user_and_author_rules
(
)
!
=
candidate
.
element
.
matches_user_and_author_rules
(
)
{
miss
!
(
UserAndAuthorRules
)
}
if
element
.
get_state
(
)
!
=
candidate
.
element
.
get_state
(
)
{
miss
!
(
State
)
}
if
element
.
get_id
(
)
!
=
candidate
.
element
.
get_id
(
)
{
miss
!
(
IdAttr
)
}
if
element
.
style_attribute
(
)
.
is_some
(
)
{
miss
!
(
StyleAttr
)
}
if
!
checks
:
:
have_same_class
(
element
candidate
)
{
miss
!
(
Class
)
}
if
checks
:
:
has_presentational_hints
(
element
)
{
miss
!
(
PresHints
)
}
if
!
checks
:
:
revalidate
(
element
candidate
shared
bloom
info
selector_flags_map
)
{
miss
!
(
Revalidation
)
}
let
data
=
candidate
.
element
.
borrow_data
(
)
.
unwrap
(
)
;
debug_assert
!
(
element
.
has_current_styles
(
&
data
)
)
;
debug
!
(
"
Sharing
style
between
{
:
?
}
and
{
:
?
}
"
element
candidate
.
element
)
;
Ok
(
data
.
styles
(
)
.
primary
.
clone
(
)
)
}
}
