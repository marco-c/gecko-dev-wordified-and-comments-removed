use
Atom
;
use
bit_vec
:
:
BitVec
;
use
bloom
:
:
StyleBloom
;
use
cache
:
:
{
LRUCache
LRUCacheMutIterator
}
;
use
context
:
:
{
SelectorFlagsMap
SharedStyleContext
StyleContext
}
;
use
data
:
:
{
ElementData
ElementStyles
}
;
use
dom
:
:
{
TElement
SendElement
}
;
use
matching
:
:
{
ChildCascadeRequirement
MatchMethods
}
;
use
properties
:
:
ComputedValues
;
use
selector_parser
:
:
RestyleDamage
;
use
selectors
:
:
matching
:
:
{
ElementSelectorFlags
VisitedHandlingMode
StyleRelations
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
mem
;
use
std
:
:
ops
:
:
Deref
;
use
stylist
:
:
{
ApplicableDeclarationBlock
Stylist
}
;
mod
checks
;
pub
const
STYLE_SHARING_CANDIDATE_CACHE_SIZE
:
usize
=
31
;
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
StyleSharingBehavior
{
Allow
Disallow
}
#
[
derive
(
Debug
Default
)
]
pub
struct
ValidationData
{
class_list
:
Option
<
SmallVec
<
[
Atom
;
5
]
>
>
pres_hints
:
Option
<
SmallVec
<
[
ApplicableDeclarationBlock
;
5
]
>
>
revalidation_match_results
:
Option
<
BitVec
>
}
impl
ValidationData
{
pub
fn
take
(
&
mut
self
)
-
>
Self
{
mem
:
:
replace
(
self
Self
:
:
default
(
)
)
}
pub
fn
pres_hints
<
E
>
(
&
mut
self
element
:
E
)
-
>
&
[
ApplicableDeclarationBlock
]
where
E
:
TElement
{
if
self
.
pres_hints
.
is_none
(
)
{
let
mut
pres_hints
=
SmallVec
:
:
new
(
)
;
element
.
synthesize_presentational_hints_for_legacy_attributes
(
VisitedHandlingMode
:
:
AllLinksUnvisited
&
mut
pres_hints
)
;
self
.
pres_hints
=
Some
(
pres_hints
)
;
}
&
*
self
.
pres_hints
.
as_ref
(
)
.
unwrap
(
)
}
pub
fn
class_list
<
E
>
(
&
mut
self
element
:
E
)
-
>
&
[
Atom
]
where
E
:
TElement
{
if
self
.
class_list
.
is_none
(
)
{
let
mut
class_list
=
SmallVec
:
:
<
[
Atom
;
5
]
>
:
:
new
(
)
;
element
.
each_class
(
|
c
|
class_list
.
push
(
c
.
clone
(
)
)
)
;
if
!
class_list
.
spilled
(
)
{
class_list
.
sort_by
(
|
a
b
|
a
.
get_hash
(
)
.
cmp
(
&
b
.
get_hash
(
)
)
)
;
}
self
.
class_list
=
Some
(
class_list
)
;
}
&
*
self
.
class_list
.
as_ref
(
)
.
unwrap
(
)
}
#
[
inline
]
fn
revalidation_match_results
<
E
F
>
(
&
mut
self
element
:
E
stylist
:
&
Stylist
bloom
:
&
StyleBloom
<
E
>
bloom_known_valid
:
bool
flags_setter
:
&
mut
F
)
-
>
&
BitVec
where
E
:
TElement
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
if
self
.
revalidation_match_results
.
is_none
(
)
{
let
bloom_to_use
=
if
bloom_known_valid
{
debug_assert_eq
!
(
bloom
.
current_parent
(
)
element
.
traversal_parent
(
)
)
;
Some
(
bloom
.
filter
(
)
)
}
else
{
if
bloom
.
current_parent
(
)
=
=
element
.
traversal_parent
(
)
{
Some
(
bloom
.
filter
(
)
)
}
else
{
None
}
}
;
self
.
revalidation_match_results
=
Some
(
stylist
.
match_revalidation_selectors
(
&
element
bloom_to_use
flags_setter
)
)
;
}
self
.
revalidation_match_results
.
as_ref
(
)
.
unwrap
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
StyleSharingCandidate
<
E
:
TElement
>
{
element
:
SendElement
<
E
>
validation_data
:
ValidationData
}
impl
<
E
:
TElement
>
Deref
for
StyleSharingCandidate
<
E
>
{
type
Target
=
E
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
element
}
}
impl
<
E
:
TElement
>
StyleSharingCandidate
<
E
>
{
fn
class_list
(
&
mut
self
)
-
>
&
[
Atom
]
{
self
.
validation_data
.
class_list
(
*
self
.
element
)
}
fn
pres_hints
(
&
mut
self
)
-
>
&
[
ApplicableDeclarationBlock
]
{
self
.
validation_data
.
pres_hints
(
*
self
.
element
)
}
fn
revalidation_match_results
(
&
mut
self
stylist
:
&
Stylist
bloom
:
&
StyleBloom
<
E
>
)
-
>
&
BitVec
{
self
.
validation_data
.
revalidation_match_results
(
*
self
.
element
stylist
bloom
false
&
mut
|
_
_
|
{
}
)
}
}
impl
<
E
:
TElement
>
PartialEq
<
StyleSharingCandidate
<
E
>
>
for
StyleSharingCandidate
<
E
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
element
=
=
other
.
element
}
}
pub
struct
StyleSharingTarget
<
E
:
TElement
>
{
element
:
E
validation_data
:
ValidationData
}
impl
<
E
:
TElement
>
Deref
for
StyleSharingTarget
<
E
>
{
type
Target
=
E
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
element
}
}
impl
<
E
:
TElement
>
StyleSharingTarget
<
E
>
{
pub
fn
new
(
element
:
E
)
-
>
Self
{
Self
{
element
:
element
validation_data
:
ValidationData
:
:
default
(
)
}
}
fn
class_list
(
&
mut
self
)
-
>
&
[
Atom
]
{
self
.
validation_data
.
class_list
(
self
.
element
)
}
fn
pres_hints
(
&
mut
self
)
-
>
&
[
ApplicableDeclarationBlock
]
{
self
.
validation_data
.
pres_hints
(
self
.
element
)
}
fn
revalidation_match_results
(
&
mut
self
stylist
:
&
Stylist
bloom
:
&
StyleBloom
<
E
>
selector_flags_map
:
&
mut
SelectorFlagsMap
<
E
>
)
-
>
&
BitVec
{
let
element
=
self
.
element
;
let
mut
set_selector_flags
=
|
el
:
&
E
flags
:
ElementSelectorFlags
|
{
element
.
apply_selector_flags
(
selector_flags_map
el
flags
)
;
}
;
self
.
validation_data
.
revalidation_match_results
(
self
.
element
stylist
bloom
true
&
mut
set_selector_flags
)
}
pub
fn
share_style_if_possible
(
mut
self
context
:
&
mut
StyleContext
<
E
>
data
:
&
mut
ElementData
)
-
>
StyleSharingResult
{
let
cache
=
&
mut
context
.
thread_local
.
style_sharing_candidate_cache
;
let
shared_context
=
&
context
.
shared
;
let
selector_flags_map
=
&
mut
context
.
thread_local
.
selector_flags
;
let
bloom_filter
=
&
context
.
thread_local
.
bloom_filter
;
if
cache
.
dom_depth
!
=
bloom_filter
.
matching_depth
(
)
{
debug
!
(
"
Can
'
t
share
style
because
DOM
depth
changed
from
{
:
?
}
to
{
:
?
}
element
:
{
:
?
}
"
cache
.
dom_depth
bloom_filter
.
matching_depth
(
)
self
.
element
)
;
return
StyleSharingResult
:
:
CannotShare
;
}
debug_assert_eq
!
(
bloom_filter
.
current_parent
(
)
self
.
element
.
traversal_parent
(
)
)
;
let
result
=
cache
.
share_style_if_possible
(
shared_context
selector_flags_map
bloom_filter
&
mut
self
data
)
;
context
.
thread_local
.
current_element_info
.
as_mut
(
)
.
unwrap
(
)
.
validation_data
=
self
.
validation_data
.
take
(
)
;
result
}
fn
accumulate_damage_when_sharing
(
&
self
shared_context
:
&
SharedStyleContext
shared_style
:
&
ElementStyles
data
:
&
mut
ElementData
)
-
>
ChildCascadeRequirement
{
if
data
.
has_styles
(
)
{
let
(
styles
restyle_data
)
=
data
.
styles_and_restyle_mut
(
)
;
if
let
Some
(
restyle_data
)
=
restyle_data
{
let
old_pseudos
=
&
styles
.
pseudos
;
let
new_pseudos
=
&
shared_style
.
pseudos
;
if
!
old_pseudos
.
has_same_pseudos_as
(
new_pseudos
)
{
restyle_data
.
damage
|
=
RestyleDamage
:
:
reconstruct
(
)
;
}
else
{
for
pseudo
in
old_pseudos
.
keys
(
)
{
let
old_values
=
old_pseudos
.
get
(
&
pseudo
)
.
unwrap
(
)
.
values
.
as_ref
(
)
.
map
(
|
v
|
&
*
*
v
)
;
let
new_values
=
new_pseudos
.
get
(
&
pseudo
)
.
unwrap
(
)
.
values
(
)
;
self
.
element
.
accumulate_damage
(
&
shared_context
Some
(
restyle_data
)
old_values
new_values
Some
(
&
pseudo
)
)
;
}
}
}
}
let
old_values
=
data
.
get_styles_mut
(
)
.
and_then
(
|
s
|
s
.
primary
.
values
.
take
(
)
)
;
self
.
element
.
accumulate_damage
(
&
shared_context
data
.
get_restyle_mut
(
)
old_values
.
as_ref
(
)
.
map
(
|
v
|
&
*
*
v
)
shared_style
.
primary
.
values
(
)
None
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
CacheMiss
{
Parent
NativeAnonymousContent
LocalName
Namespace
Link
UserAndAuthorRules
State
IdAttr
StyleAttr
Class
PresHints
Revalidation
}
pub
enum
StyleSharingResult
{
CannotShare
StyleWasShared
(
usize
ChildCascadeRequirement
)
}
pub
struct
StyleSharingCandidateCache
<
E
:
TElement
>
{
cache
:
LRUCache
<
[
StyleSharingCandidate
<
E
>
;
STYLE_SHARING_CANDIDATE_CACHE_SIZE
+
1
]
>
dom_depth
:
usize
}
impl
<
E
:
TElement
>
StyleSharingCandidateCache
<
E
>
{
pub
fn
new
(
)
-
>
Self
{
StyleSharingCandidateCache
{
cache
:
LRUCache
:
:
new
(
)
dom_depth
:
0
}
}
pub
fn
num_entries
(
&
self
)
-
>
usize
{
self
.
cache
.
num_entries
(
)
}
fn
iter_mut
(
&
mut
self
)
-
>
LRUCacheMutIterator
<
StyleSharingCandidate
<
E
>
>
{
self
.
cache
.
iter_mut
(
)
}
pub
fn
insert_if_possible
(
&
mut
self
element
:
&
E
style
:
&
ComputedValues
relations
:
StyleRelations
mut
validation_data
:
ValidationData
dom_depth
:
usize
)
{
use
selectors
:
:
matching
:
:
AFFECTED_BY_PRESENTATIONAL_HINTS
;
let
parent
=
match
element
.
traversal_parent
(
)
{
Some
(
element
)
=
>
element
None
=
>
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
no
parent
element
"
)
;
return
;
}
}
;
if
element
.
is_native_anonymous
(
)
{
debug
!
(
"
Failing
to
insert
into
the
cache
:
NAC
"
)
;
return
;
}
let
box_style
=
style
.
get_box
(
)
;
if
box_style
.
specifies_transitions
(
)
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
transitions
"
)
;
return
;
}
if
box_style
.
specifies_animations
(
)
{
debug
!
(
"
Failing
to
insert
to
the
cache
:
animations
"
)
;
return
;
}
if
!
relations
.
intersects
(
AFFECTED_BY_PRESENTATIONAL_HINTS
)
{
debug_assert
!
(
validation_data
.
pres_hints
.
as_ref
(
)
.
map_or
(
true
|
v
|
v
.
is_empty
(
)
)
)
;
validation_data
.
pres_hints
=
Some
(
SmallVec
:
:
new
(
)
)
;
}
debug
!
(
"
Inserting
into
cache
:
{
:
?
}
with
parent
{
:
?
}
"
element
parent
)
;
if
self
.
dom_depth
!
=
dom_depth
{
debug
!
(
"
Clearing
cache
because
depth
changed
from
{
:
?
}
to
{
:
?
}
element
:
{
:
?
}
"
self
.
dom_depth
dom_depth
element
)
;
self
.
clear
(
)
;
self
.
dom_depth
=
dom_depth
;
}
self
.
cache
.
insert
(
StyleSharingCandidate
{
element
:
unsafe
{
SendElement
:
:
new
(
*
element
)
}
validation_data
:
validation_data
}
)
;
}
pub
fn
touch
(
&
mut
self
index
:
usize
)
{
self
.
cache
.
touch
(
index
)
;
}
pub
fn
clear
(
&
mut
self
)
{
self
.
cache
.
evict_all
(
)
}
fn
share_style_if_possible
(
&
mut
self
shared_context
:
&
SharedStyleContext
selector_flags_map
:
&
mut
SelectorFlagsMap
<
E
>
bloom_filter
:
&
StyleBloom
<
E
>
target
:
&
mut
StyleSharingTarget
<
E
>
data
:
&
mut
ElementData
)
-
>
StyleSharingResult
{
if
shared_context
.
options
.
disable_style_sharing_cache
{
debug
!
(
"
{
:
?
}
Cannot
share
style
:
style
sharing
cache
disabled
"
target
.
element
)
;
return
StyleSharingResult
:
:
CannotShare
}
if
target
.
traversal_parent
(
)
.
is_none
(
)
{
debug
!
(
"
{
:
?
}
Cannot
share
style
:
element
has
no
parent
"
target
.
element
)
;
return
StyleSharingResult
:
:
CannotShare
}
if
target
.
is_native_anonymous
(
)
{
debug
!
(
"
{
:
?
}
Cannot
share
style
:
NAC
"
target
.
element
)
;
return
StyleSharingResult
:
:
CannotShare
;
}
for
(
i
candidate
)
in
self
.
iter_mut
(
)
.
enumerate
(
)
{
let
sharing_result
=
Self
:
:
test_candidate
(
target
candidate
&
shared_context
bloom_filter
selector_flags_map
)
;
match
sharing_result
{
Ok
(
shared_style
)
=
>
{
debug_assert_eq
!
(
data
.
has_styles
(
)
data
.
has_restyle
(
)
)
;
let
child_cascade_requirement
=
target
.
accumulate_damage_when_sharing
(
shared_context
&
shared_style
data
)
;
data
.
set_styles
(
shared_style
)
;
return
StyleSharingResult
:
:
StyleWasShared
(
i
child_cascade_requirement
)
}
Err
(
miss
)
=
>
{
debug
!
(
"
Cache
miss
:
{
:
?
}
"
miss
)
;
match
miss
{
CacheMiss
:
:
PresHints
|
CacheMiss
:
:
Revalidation
=
>
break
_
=
>
{
}
}
}
}
}
debug
!
(
"
{
:
?
}
Cannot
share
style
:
{
}
cache
entries
"
target
.
element
self
.
cache
.
num_entries
(
)
)
;
StyleSharingResult
:
:
CannotShare
}
fn
test_candidate
(
target
:
&
mut
StyleSharingTarget
<
E
>
candidate
:
&
mut
StyleSharingCandidate
<
E
>
shared
:
&
SharedStyleContext
bloom
:
&
StyleBloom
<
E
>
selector_flags_map
:
&
mut
SelectorFlagsMap
<
E
>
)
-
>
Result
<
ElementStyles
CacheMiss
>
{
macro_rules
!
miss
{
(
miss
:
ident
)
=
>
{
return
Err
(
CacheMiss
:
:
miss
)
;
}
}
let
parent
=
target
.
traversal_parent
(
)
;
let
candidate_parent
=
candidate
.
element
.
traversal_parent
(
)
;
if
parent
!
=
candidate_parent
&
&
!
checks
:
:
same_computed_values
(
parent
candidate_parent
)
{
miss
!
(
Parent
)
}
if
target
.
is_native_anonymous
(
)
{
debug_assert
!
(
!
candidate
.
element
.
is_native_anonymous
(
)
"
Why
inserting
NAC
into
the
cache
?
"
)
;
miss
!
(
NativeAnonymousContent
)
}
if
*
target
.
get_local_name
(
)
!
=
*
candidate
.
element
.
get_local_name
(
)
{
miss
!
(
LocalName
)
}
if
*
target
.
get_namespace
(
)
!
=
*
candidate
.
element
.
get_namespace
(
)
{
miss
!
(
Namespace
)
}
if
target
.
is_link
(
)
!
=
candidate
.
element
.
is_link
(
)
{
miss
!
(
Link
)
}
if
target
.
matches_user_and_author_rules
(
)
!
=
candidate
.
element
.
matches_user_and_author_rules
(
)
{
miss
!
(
UserAndAuthorRules
)
}
if
!
checks
:
:
have_same_state_ignoring_visitedness
(
target
.
element
candidate
)
{
miss
!
(
State
)
}
let
element_id
=
target
.
element
.
get_id
(
)
;
let
candidate_id
=
candidate
.
element
.
get_id
(
)
;
if
element_id
!
=
candidate_id
{
if
checks
:
:
may_have_rules_for_ids
(
shared
element_id
.
as_ref
(
)
candidate_id
.
as_ref
(
)
)
{
miss
!
(
IdAttr
)
}
}
if
!
checks
:
:
have_same_style_attribute
(
target
candidate
)
{
miss
!
(
StyleAttr
)
}
if
!
checks
:
:
have_same_class
(
target
candidate
)
{
miss
!
(
Class
)
}
if
!
checks
:
:
have_same_presentational_hints
(
target
candidate
)
{
miss
!
(
PresHints
)
}
if
!
checks
:
:
revalidate
(
target
candidate
shared
bloom
selector_flags_map
)
{
miss
!
(
Revalidation
)
}
let
data
=
candidate
.
element
.
borrow_data
(
)
.
unwrap
(
)
;
debug_assert
!
(
target
.
has_current_styles
(
&
data
)
)
;
debug
!
(
"
Sharing
style
between
{
:
?
}
and
{
:
?
}
"
target
.
element
candidate
.
element
)
;
Ok
(
data
.
styles
(
)
.
clone
(
)
)
}
}
