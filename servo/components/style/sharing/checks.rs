use
Atom
;
use
bloom
:
:
StyleBloom
;
use
context
:
:
{
SelectorFlagsMap
SharedStyleContext
}
;
use
dom
:
:
TElement
;
use
servo_arc
:
:
Arc
;
use
sharing
:
:
{
StyleSharingCandidate
StyleSharingTarget
}
;
pub
fn
can_share_style_across_parents
<
E
>
(
first
:
Option
<
E
>
second
:
Option
<
E
>
)
-
>
bool
where
E
:
TElement
{
let
(
first
second
)
=
match
(
first
second
)
{
(
Some
(
f
)
Some
(
s
)
)
=
>
(
f
s
)
_
=
>
return
false
}
;
debug_assert_ne
!
(
first
second
)
;
let
first_data
=
first
.
borrow_data
(
)
.
unwrap
(
)
;
let
second_data
=
second
.
borrow_data
(
)
.
unwrap
(
)
;
if
first_data
.
traversed_without_styling
(
)
|
|
second_data
.
traversed_without_styling
(
)
{
return
false
;
}
let
same_computed_values
=
Arc
:
:
ptr_eq
(
first_data
.
styles
.
primary
(
)
second_data
.
styles
.
primary
(
)
)
;
same_computed_values
}
pub
fn
have_same_style_attribute
<
E
>
(
target
:
&
mut
StyleSharingTarget
<
E
>
candidate
:
&
mut
StyleSharingCandidate
<
E
>
)
-
>
bool
where
E
:
TElement
{
match
(
target
.
style_attribute
(
)
candidate
.
style_attribute
(
)
)
{
(
None
None
)
=
>
true
(
Some
(
_
)
None
)
|
(
None
Some
(
_
)
)
=
>
false
(
Some
(
a
)
Some
(
b
)
)
=
>
&
*
a
as
*
const
_
=
=
&
*
b
as
*
const
_
}
}
pub
fn
have_same_presentational_hints
<
E
>
(
target
:
&
mut
StyleSharingTarget
<
E
>
candidate
:
&
mut
StyleSharingCandidate
<
E
>
)
-
>
bool
where
E
:
TElement
{
target
.
pres_hints
(
)
=
=
candidate
.
pres_hints
(
)
}
pub
fn
have_same_class
<
E
>
(
target
:
&
mut
StyleSharingTarget
<
E
>
candidate
:
&
mut
StyleSharingCandidate
<
E
>
)
-
>
bool
where
E
:
TElement
{
target
.
class_list
(
)
=
=
candidate
.
class_list
(
)
}
#
[
inline
]
pub
fn
revalidate
<
E
>
(
target
:
&
mut
StyleSharingTarget
<
E
>
candidate
:
&
mut
StyleSharingCandidate
<
E
>
shared_context
:
&
SharedStyleContext
bloom
:
&
StyleBloom
<
E
>
selector_flags_map
:
&
mut
SelectorFlagsMap
<
E
>
)
-
>
bool
where
E
:
TElement
{
let
stylist
=
&
shared_context
.
stylist
;
let
for_element
=
target
.
revalidation_match_results
(
stylist
bloom
selector_flags_map
)
;
let
for_candidate
=
candidate
.
revalidation_match_results
(
stylist
bloom
)
;
debug_assert_eq
!
(
for_element
.
len
(
)
for_candidate
.
len
(
)
)
;
for_element
=
=
for_candidate
}
#
[
inline
]
pub
fn
may_have_rules_for_ids
(
shared_context
:
&
SharedStyleContext
element_id
:
Option
<
&
Atom
>
candidate_id
:
Option
<
&
Atom
>
)
-
>
bool
{
debug_assert
!
(
element_id
.
is_some
(
)
|
|
candidate_id
.
is_some
(
)
)
;
let
stylist
=
&
shared_context
.
stylist
;
let
may_have_rules_for_element
=
match
element_id
{
Some
(
id
)
=
>
stylist
.
may_have_rules_for_id
(
id
)
None
=
>
false
}
;
if
may_have_rules_for_element
{
return
true
;
}
match
candidate_id
{
Some
(
id
)
=
>
stylist
.
may_have_rules_for_id
(
id
)
None
=
>
false
}
}
