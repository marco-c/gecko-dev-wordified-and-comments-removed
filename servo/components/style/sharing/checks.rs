use
Atom
;
use
bloom
:
:
StyleBloom
;
use
context
:
:
{
SelectorFlagsMap
SharedStyleContext
}
;
use
dom
:
:
TElement
;
use
element_state
:
:
*
;
use
selectors
:
:
matching
:
:
StyleRelations
;
use
sharing
:
:
{
StyleSharingCandidate
StyleSharingTarget
}
;
use
stylearc
:
:
Arc
;
#
[
inline
]
pub
fn
relations_are_shareable
(
relations
:
&
StyleRelations
)
-
>
bool
{
use
selectors
:
:
matching
:
:
*
;
!
relations
.
intersects
(
AFFECTED_BY_PSEUDO_ELEMENTS
)
}
pub
fn
same_computed_values
<
E
>
(
first
:
Option
<
E
>
second
:
Option
<
E
>
)
-
>
bool
where
E
:
TElement
{
let
(
a
b
)
=
match
(
first
second
)
{
(
Some
(
f
)
Some
(
s
)
)
=
>
(
f
s
)
_
=
>
return
false
}
;
let
eq
=
Arc
:
:
ptr_eq
(
a
.
borrow_data
(
)
.
unwrap
(
)
.
styles
(
)
.
primary
.
values
(
)
b
.
borrow_data
(
)
.
unwrap
(
)
.
styles
(
)
.
primary
.
values
(
)
)
;
eq
}
pub
fn
have_same_style_attribute
<
E
>
(
target
:
&
mut
StyleSharingTarget
<
E
>
candidate
:
&
mut
StyleSharingCandidate
<
E
>
)
-
>
bool
where
E
:
TElement
{
match
(
target
.
style_attribute
(
)
candidate
.
style_attribute
(
)
)
{
(
None
None
)
=
>
true
(
Some
(
_
)
None
)
|
(
None
Some
(
_
)
)
=
>
false
(
Some
(
a
)
Some
(
b
)
)
=
>
Arc
:
:
ptr_eq
(
a
b
)
}
}
pub
fn
have_same_presentational_hints
<
E
>
(
target
:
&
mut
StyleSharingTarget
<
E
>
candidate
:
&
mut
StyleSharingCandidate
<
E
>
)
-
>
bool
where
E
:
TElement
{
target
.
pres_hints
(
)
=
=
candidate
.
pres_hints
(
)
}
pub
fn
have_same_class
<
E
>
(
target
:
&
mut
StyleSharingTarget
<
E
>
candidate
:
&
mut
StyleSharingCandidate
<
E
>
)
-
>
bool
where
E
:
TElement
{
target
.
class_list
(
)
=
=
candidate
.
class_list
(
)
}
pub
fn
have_same_state_ignoring_visitedness
<
E
>
(
element
:
E
candidate
:
&
StyleSharingCandidate
<
E
>
)
-
>
bool
where
E
:
TElement
{
let
state_mask
=
!
IN_VISITED_OR_UNVISITED_STATE
;
let
state
=
element
.
get_state
(
)
&
state_mask
;
let
candidate_state
=
candidate
.
element
.
get_state
(
)
&
state_mask
;
state
=
=
candidate_state
}
#
[
inline
]
pub
fn
revalidate
<
E
>
(
target
:
&
mut
StyleSharingTarget
<
E
>
candidate
:
&
mut
StyleSharingCandidate
<
E
>
shared_context
:
&
SharedStyleContext
bloom
:
&
StyleBloom
<
E
>
selector_flags_map
:
&
mut
SelectorFlagsMap
<
E
>
)
-
>
bool
where
E
:
TElement
{
let
stylist
=
&
shared_context
.
stylist
;
let
for_element
=
target
.
revalidation_match_results
(
stylist
bloom
selector_flags_map
)
;
let
for_candidate
=
candidate
.
revalidation_match_results
(
stylist
bloom
)
;
debug_assert_eq
!
(
for_element
.
len
(
)
for_candidate
.
len
(
)
)
;
for_element
=
=
for_candidate
}
#
[
inline
]
pub
fn
may_have_rules_for_ids
(
shared_context
:
&
SharedStyleContext
element_id
:
Option
<
&
Atom
>
candidate_id
:
Option
<
&
Atom
>
)
-
>
bool
{
debug_assert
!
(
element_id
.
is_some
(
)
|
|
candidate_id
.
is_some
(
)
)
;
let
stylist
=
&
shared_context
.
stylist
;
let
may_have_rules_for_element
=
match
element_id
{
Some
(
id
)
=
>
stylist
.
may_have_rules_for_id
(
id
)
None
=
>
false
}
;
if
may_have_rules_for_element
{
return
true
;
}
match
candidate_id
{
Some
(
id
)
=
>
stylist
.
may_have_rules_for_id
(
id
)
None
=
>
false
}
}
