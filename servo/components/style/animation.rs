use
crate
:
:
bezier
:
:
Bezier
;
use
crate
:
:
context
:
:
SharedStyleContext
;
use
crate
:
:
dom
:
:
{
OpaqueNode
TElement
TNode
}
;
use
crate
:
:
font_metrics
:
:
FontMetricsProvider
;
use
crate
:
:
properties
:
:
animated_properties
:
:
AnimatedProperty
;
use
crate
:
:
properties
:
:
longhands
:
:
animation_direction
:
:
computed_value
:
:
single_value
:
:
T
as
AnimationDirection
;
use
crate
:
:
properties
:
:
longhands
:
:
animation_play_state
:
:
computed_value
:
:
single_value
:
:
T
as
AnimationPlayState
;
use
crate
:
:
properties
:
:
{
self
CascadeMode
ComputedValues
LonghandId
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
crate
:
:
properties
:
:
LonghandIdSet
;
use
crate
:
:
stylesheets
:
:
keyframes_rule
:
:
{
KeyframesAnimation
KeyframesStep
KeyframesStepValue
}
;
use
crate
:
:
stylesheets
:
:
Origin
;
use
crate
:
:
values
:
:
computed
:
:
Time
;
use
crate
:
:
values
:
:
computed
:
:
TimingFunction
;
use
crate
:
:
values
:
:
generics
:
:
box_
:
:
AnimationIterationCount
;
use
crate
:
:
values
:
:
generics
:
:
easing
:
:
{
StepPosition
TimingFunction
as
GenericTimingFunction
}
;
use
crate
:
:
Atom
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
PropertyAnimation
{
property
:
AnimatedProperty
timing_function
:
TimingFunction
pub
duration
:
f64
}
impl
PropertyAnimation
{
pub
fn
property_id
(
&
self
)
-
>
LonghandId
{
self
.
property
.
id
(
)
}
pub
fn
property_name
(
&
self
)
-
>
&
'
static
str
{
self
.
property
.
name
(
)
}
fn
from_longhand
(
longhand
:
LonghandId
timing_function
:
TimingFunction
duration
:
Time
old_style
:
&
ComputedValues
new_style
:
&
ComputedValues
)
-
>
Option
<
PropertyAnimation
>
{
let
animated_property
=
AnimatedProperty
:
:
from_longhand
(
longhand
old_style
new_style
)
?
;
let
property_animation
=
PropertyAnimation
{
property
:
animated_property
timing_function
duration
:
duration
.
seconds
(
)
as
f64
}
;
if
property_animation
.
does_animate
(
)
{
Some
(
property_animation
)
}
else
{
None
}
}
pub
fn
update
(
&
self
style
:
&
mut
ComputedValues
time
:
f64
)
{
let
epsilon
=
1
.
/
(
200
.
*
self
.
duration
)
;
let
progress
=
match
self
.
timing_function
{
GenericTimingFunction
:
:
CubicBezier
{
x1
y1
x2
y2
}
=
>
{
Bezier
:
:
new
(
x1
y1
x2
y2
)
.
solve
(
time
epsilon
)
}
GenericTimingFunction
:
:
Steps
(
steps
pos
)
=
>
{
let
mut
current_step
=
(
time
*
(
steps
as
f64
)
)
.
floor
(
)
as
i32
;
if
pos
=
=
StepPosition
:
:
Start
|
|
pos
=
=
StepPosition
:
:
JumpStart
|
|
pos
=
=
StepPosition
:
:
JumpBoth
{
current_step
=
current_step
+
1
;
}
if
time
>
=
0
.
0
&
&
current_step
<
0
{
current_step
=
0
;
}
let
jumps
=
match
pos
{
StepPosition
:
:
JumpBoth
=
>
steps
+
1
StepPosition
:
:
JumpNone
=
>
steps
-
1
StepPosition
:
:
JumpStart
|
StepPosition
:
:
JumpEnd
|
StepPosition
:
:
Start
|
StepPosition
:
:
End
=
>
steps
}
;
if
time
<
=
1
.
0
&
&
current_step
>
jumps
{
current_step
=
jumps
;
}
(
current_step
as
f64
)
/
(
jumps
as
f64
)
}
GenericTimingFunction
:
:
Keyword
(
keyword
)
=
>
{
let
(
x1
x2
y1
y2
)
=
keyword
.
to_bezier
(
)
;
Bezier
:
:
new
(
x1
x2
y1
y2
)
.
solve
(
time
epsilon
)
}
}
;
self
.
property
.
update
(
style
progress
)
;
}
#
[
inline
]
fn
does_animate
(
&
self
)
-
>
bool
{
self
.
property
.
does_animate
(
)
&
&
self
.
duration
!
=
0
.
0
}
#
[
inline
]
pub
fn
has_the_same_end_value_as
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
property
.
has_the_same_end_value_as
(
&
other
.
property
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
enum
AnimationState
{
Paused
(
f64
)
Running
Finished
Canceled
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
KeyframesIterationState
{
Infinite
Finite
(
f32
f32
)
}
#
[
derive
(
Clone
)
]
pub
struct
Animation
{
pub
node
:
OpaqueNode
pub
name
:
Atom
pub
keyframes_animation
:
KeyframesAnimation
pub
started_at
:
f64
pub
duration
:
f64
pub
delay
:
f64
pub
iteration_state
:
KeyframesIterationState
pub
state
:
AnimationState
pub
direction
:
AnimationDirection
pub
current_direction
:
AnimationDirection
pub
cascade_style
:
Arc
<
ComputedValues
>
pub
is_new
:
bool
}
impl
Animation
{
fn
is_cancelled_in_new_style
(
&
self
new_style
:
&
Arc
<
ComputedValues
>
)
-
>
bool
{
let
index
=
new_style
.
get_box
(
)
.
animation_name_iter
(
)
.
position
(
|
animation_name
|
Some
(
&
self
.
name
)
=
=
animation_name
.
as_atom
(
)
)
;
let
index
=
match
index
{
Some
(
index
)
=
>
index
None
=
>
return
true
}
;
new_style
.
get_box
(
)
.
animation_duration_mod
(
index
)
.
seconds
(
)
=
=
0
.
}
pub
fn
iterate_if_necessary
(
&
mut
self
time
:
f64
)
{
if
!
self
.
iteration_over
(
time
)
{
return
;
}
if
self
.
state
!
=
AnimationState
:
:
Running
{
return
;
}
if
let
KeyframesIterationState
:
:
Finite
(
ref
mut
current
max
)
=
self
.
iteration_state
{
if
(
max
-
*
current
)
<
=
1
.
0
{
return
;
}
*
current
+
=
1
.
0
;
}
self
.
started_at
+
=
self
.
duration
+
self
.
delay
;
match
self
.
direction
{
AnimationDirection
:
:
Alternate
|
AnimationDirection
:
:
AlternateReverse
=
>
{
self
.
current_direction
=
match
self
.
current_direction
{
AnimationDirection
:
:
Normal
=
>
AnimationDirection
:
:
Reverse
AnimationDirection
:
:
Reverse
=
>
AnimationDirection
:
:
Normal
_
=
>
unreachable
!
(
)
}
;
}
_
=
>
{
}
}
}
fn
iteration_over
(
&
self
time
:
f64
)
-
>
bool
{
time
>
(
self
.
started_at
+
self
.
duration
)
}
pub
fn
has_ended
(
&
self
time
:
f64
)
-
>
bool
{
match
self
.
state
{
AnimationState
:
:
Canceled
|
AnimationState
:
:
Paused
(
_
)
=
>
return
false
AnimationState
:
:
Finished
=
>
return
true
AnimationState
:
:
Running
=
>
{
}
}
if
!
self
.
iteration_over
(
time
)
{
return
false
;
}
return
match
self
.
iteration_state
{
KeyframesIterationState
:
:
Finite
(
current
max
)
if
(
max
-
current
)
<
=
1
.
0
=
>
true
KeyframesIterationState
:
:
Finite
(
.
.
)
|
KeyframesIterationState
:
:
Infinite
=
>
false
}
;
}
pub
fn
update_from_other
(
&
mut
self
other
:
&
Self
now
:
f64
)
{
use
self
:
:
AnimationState
:
:
*
;
debug
!
(
"
KeyframesAnimationState
:
:
update_from_other
(
{
:
?
}
{
:
?
}
)
"
self
other
)
;
let
old_started_at
=
self
.
started_at
;
let
old_duration
=
self
.
duration
;
let
old_direction
=
self
.
current_direction
;
let
old_state
=
self
.
state
.
clone
(
)
;
let
old_iteration_state
=
self
.
iteration_state
.
clone
(
)
;
*
self
=
other
.
clone
(
)
;
let
mut
new_started_at
=
old_started_at
;
match
(
&
mut
self
.
state
old_state
)
{
(
&
mut
Running
Paused
(
progress
)
)
=
>
new_started_at
=
now
-
(
self
.
duration
*
progress
)
(
&
mut
Paused
(
ref
mut
new
)
Paused
(
old
)
)
=
>
*
new
=
old
(
&
mut
Paused
(
ref
mut
progress
)
Running
)
=
>
{
*
progress
=
(
now
-
old_started_at
)
/
old_duration
}
(
_
Finished
)
|
(
Finished
_
)
=
>
unreachable
!
(
"
Did
not
expect
Finished
animation
.
"
)
_
=
>
{
}
}
match
(
&
mut
self
.
iteration_state
old_iteration_state
)
{
(
&
mut
KeyframesIterationState
:
:
Finite
(
ref
mut
iters
_
)
KeyframesIterationState
:
:
Finite
(
old_iters
_
)
)
=
>
*
iters
=
old_iters
_
=
>
{
}
}
self
.
current_direction
=
old_direction
;
self
.
started_at
=
new_started_at
;
}
pub
fn
active_duration
(
&
self
)
-
>
f64
{
match
self
.
iteration_state
{
KeyframesIterationState
:
:
Finite
(
_
max
)
=
>
self
.
duration
*
(
max
as
f64
)
KeyframesIterationState
:
:
Infinite
=
>
0
.
}
}
fn
update_style
<
E
>
(
&
self
context
:
&
SharedStyleContext
style
:
&
mut
ComputedValues
font_metrics_provider
:
&
dyn
FontMetricsProvider
)
where
E
:
TElement
{
let
duration
=
self
.
duration
;
let
started_at
=
self
.
started_at
;
let
now
=
match
self
.
state
{
AnimationState
:
:
Running
=
>
context
.
current_time_for_animations
AnimationState
:
:
Paused
(
progress
)
=
>
started_at
+
duration
*
progress
AnimationState
:
:
Canceled
|
AnimationState
:
:
Finished
=
>
return
}
;
debug_assert
!
(
!
self
.
keyframes_animation
.
steps
.
is_empty
(
)
)
;
let
mut
total_progress
=
(
now
-
started_at
)
/
duration
;
if
total_progress
<
0
.
{
warn
!
(
"
Negative
progress
found
for
animation
{
:
?
}
"
self
.
name
)
;
return
;
}
if
total_progress
>
1
.
{
total_progress
=
1
.
;
}
let
last_keyframe_position
;
let
target_keyframe_position
;
match
self
.
current_direction
{
AnimationDirection
:
:
Normal
=
>
{
target_keyframe_position
=
self
.
keyframes_animation
.
steps
.
iter
(
)
.
position
(
|
step
|
total_progress
as
f32
<
=
step
.
start_percentage
.
0
)
;
last_keyframe_position
=
target_keyframe_position
.
and_then
(
|
pos
|
if
pos
!
=
0
{
Some
(
pos
-
1
)
}
else
{
None
}
)
.
unwrap_or
(
0
)
;
}
AnimationDirection
:
:
Reverse
=
>
{
target_keyframe_position
=
self
.
keyframes_animation
.
steps
.
iter
(
)
.
rev
(
)
.
position
(
|
step
|
total_progress
as
f32
<
=
1
.
-
step
.
start_percentage
.
0
)
.
map
(
|
pos
|
self
.
keyframes_animation
.
steps
.
len
(
)
-
pos
-
1
)
;
last_keyframe_position
=
target_keyframe_position
.
and_then
(
|
pos
|
{
if
pos
!
=
self
.
keyframes_animation
.
steps
.
len
(
)
-
1
{
Some
(
pos
+
1
)
}
else
{
None
}
}
)
.
unwrap_or
(
self
.
keyframes_animation
.
steps
.
len
(
)
-
1
)
;
}
_
=
>
unreachable
!
(
)
}
debug
!
(
"
Animation
:
:
update_style
:
keyframe
from
{
:
?
}
to
{
:
?
}
"
last_keyframe_position
target_keyframe_position
)
;
let
target_keyframe
=
match
target_keyframe_position
{
Some
(
target
)
=
>
&
self
.
keyframes_animation
.
steps
[
target
]
None
=
>
return
}
;
let
last_keyframe
=
&
self
.
keyframes_animation
.
steps
[
last_keyframe_position
]
;
let
relative_timespan
=
(
target_keyframe
.
start_percentage
.
0
-
last_keyframe
.
start_percentage
.
0
)
.
abs
(
)
;
let
relative_duration
=
relative_timespan
as
f64
*
duration
;
let
last_keyframe_ended_at
=
match
self
.
current_direction
{
AnimationDirection
:
:
Normal
=
>
{
self
.
started_at
+
(
duration
*
last_keyframe
.
start_percentage
.
0
as
f64
)
}
AnimationDirection
:
:
Reverse
=
>
{
self
.
started_at
+
(
duration
*
(
1
.
-
last_keyframe
.
start_percentage
.
0
as
f64
)
)
}
_
=
>
unreachable
!
(
)
}
;
let
relative_progress
=
(
now
-
last_keyframe_ended_at
)
/
relative_duration
;
let
from_style
=
compute_style_for_animation_step
:
:
<
E
>
(
context
last_keyframe
style
&
self
.
cascade_style
font_metrics_provider
)
;
let
timing_function
=
if
last_keyframe
.
declared_timing_function
{
from_style
.
get_box
(
)
.
animation_timing_function_at
(
0
)
}
else
{
let
index
=
match
style
.
get_box
(
)
.
animation_name_iter
(
)
.
position
(
|
animation_name
|
Some
(
&
self
.
name
)
=
=
animation_name
.
as_atom
(
)
)
{
Some
(
index
)
=
>
index
None
=
>
return
warn
!
(
"
Tried
to
update
a
style
with
a
cancelled
animation
.
"
)
}
;
style
.
get_box
(
)
.
animation_timing_function_mod
(
index
)
}
;
let
target_style
=
compute_style_for_animation_step
:
:
<
E
>
(
context
target_keyframe
&
from_style
&
self
.
cascade_style
font_metrics_provider
)
;
let
mut
new_style
=
(
*
style
)
.
clone
(
)
;
for
property
in
self
.
keyframes_animation
.
properties_changed
.
iter
(
)
{
debug
!
(
"
Animation
:
:
update_style
:
scanning
prop
{
:
?
}
for
animation
\
"
{
}
\
"
"
property
self
.
name
)
;
let
animation
=
PropertyAnimation
:
:
from_longhand
(
property
timing_function
Time
:
:
from_seconds
(
relative_duration
as
f32
)
&
from_style
&
target_style
)
;
match
animation
{
Some
(
property_animation
)
=
>
{
debug
!
(
"
Animation
:
:
update_style
:
got
property
animation
for
prop
{
:
?
}
"
property
)
;
debug
!
(
"
Animation
:
:
update_style
:
{
:
?
}
"
property_animation
)
;
property_animation
.
update
(
&
mut
new_style
relative_progress
)
;
}
None
=
>
{
debug
!
(
"
Animation
:
:
update_style
:
property
animation
{
:
?
}
not
animating
"
property
)
;
}
}
}
debug
!
(
"
Animation
:
:
update_style
:
got
style
change
in
animation
\
"
{
}
\
"
"
self
.
name
)
;
*
style
=
new_style
;
}
}
impl
fmt
:
:
Debug
for
Animation
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Animation
"
)
.
field
(
"
name
"
&
self
.
name
)
.
field
(
"
started_at
"
&
self
.
started_at
)
.
field
(
"
duration
"
&
self
.
duration
)
.
field
(
"
delay
"
&
self
.
delay
)
.
field
(
"
iteration_state
"
&
self
.
iteration_state
)
.
field
(
"
state
"
&
self
.
state
)
.
field
(
"
direction
"
&
self
.
direction
)
.
field
(
"
current_direction
"
&
self
.
current_direction
)
.
field
(
"
cascade_style
"
&
(
)
)
.
finish
(
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Transition
{
pub
node
:
OpaqueNode
pub
start_time
:
f64
pub
property_animation
:
PropertyAnimation
pub
state
:
AnimationState
pub
is_new
:
bool
}
impl
Transition
{
pub
fn
has_ended
(
&
self
time
:
f64
)
-
>
bool
{
time
>
=
self
.
start_time
+
(
self
.
property_animation
.
duration
)
}
#
[
inline
]
fn
has_same_end_value
(
&
self
other_animation
:
&
PropertyAnimation
)
-
>
bool
{
if
self
.
state
=
=
AnimationState
:
:
Canceled
{
return
false
;
}
self
.
property_animation
.
has_the_same_end_value_as
(
other_animation
)
}
fn
update_style
(
&
self
context
:
&
SharedStyleContext
style
:
&
mut
ComputedValues
)
{
if
self
.
state
=
=
AnimationState
:
:
Canceled
{
return
;
}
let
now
=
context
.
current_time_for_animations
;
let
progress
=
(
now
-
self
.
start_time
)
/
(
self
.
property_animation
.
duration
)
;
let
progress
=
progress
.
min
(
1
.
0
)
;
if
progress
>
=
0
.
0
{
self
.
property_animation
.
update
(
style
progress
)
;
}
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
ElementAnimationSet
{
pub
animations
:
Vec
<
Animation
>
pub
transitions
:
Vec
<
Transition
>
}
impl
ElementAnimationSet
{
pub
fn
cancel_all_animations
(
&
mut
self
)
{
for
animation
in
self
.
animations
.
iter_mut
(
)
{
animation
.
state
=
AnimationState
:
:
Canceled
;
}
for
transition
in
self
.
transitions
.
iter_mut
(
)
{
transition
.
state
=
AnimationState
:
:
Canceled
;
}
}
pub
(
crate
)
fn
apply_active_animations
<
E
>
(
&
mut
self
context
:
&
SharedStyleContext
style
:
&
mut
Arc
<
ComputedValues
>
font_metrics
:
&
dyn
crate
:
:
font_metrics
:
:
FontMetricsProvider
)
where
E
:
TElement
{
if
self
.
animations
.
is_empty
(
)
&
&
self
.
transitions
.
is_empty
(
)
{
return
;
}
let
style
=
Arc
:
:
make_mut
(
style
)
;
for
animation
in
&
self
.
animations
{
animation
.
update_style
:
:
<
E
>
(
context
style
font_metrics
)
;
}
for
transition
in
&
self
.
transitions
{
transition
.
update_style
(
context
style
)
;
}
}
pub
(
crate
)
fn
clear_finished_animations
(
&
mut
self
)
{
self
.
animations
.
retain
(
|
animation
|
animation
.
state
!
=
AnimationState
:
:
Finished
)
;
self
.
transitions
.
retain
(
|
animation
|
animation
.
state
!
=
AnimationState
:
:
Finished
)
;
}
pub
fn
clear_canceled_animations
(
&
mut
self
)
{
self
.
animations
.
retain
(
|
animation
|
animation
.
state
!
=
AnimationState
:
:
Canceled
)
;
self
.
transitions
.
retain
(
|
animation
|
animation
.
state
!
=
AnimationState
:
:
Canceled
)
;
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
animations
.
is_empty
(
)
&
&
self
.
transitions
.
is_empty
(
)
}
pub
fn
needs_animation_ticks
(
&
self
)
-
>
bool
{
self
.
animations
.
iter
(
)
.
any
(
|
animation
|
animation
.
state
=
=
AnimationState
:
:
Running
&
&
!
animation
.
is_new
)
|
|
self
.
transitions
.
iter
(
)
.
any
(
|
transition
|
{
transition
.
state
=
=
AnimationState
:
:
Running
&
&
!
transition
.
is_new
}
)
}
pub
fn
running_animation_and_transition_count
(
&
self
)
-
>
usize
{
self
.
animations
.
iter
(
)
.
filter
(
|
animation
|
animation
.
state
=
=
AnimationState
:
:
Running
)
.
count
(
)
+
self
.
transitions
.
iter
(
)
.
filter
(
|
transition
|
transition
.
state
=
=
AnimationState
:
:
Running
)
.
count
(
)
}
fn
has_active_transition_or_animation
(
&
self
)
-
>
bool
{
self
.
animations
.
iter
(
)
.
any
(
|
animation
|
animation
.
state
!
=
AnimationState
:
:
Canceled
)
|
|
self
.
transitions
.
iter
(
)
.
any
(
|
transition
|
transition
.
state
!
=
AnimationState
:
:
Canceled
)
}
pub
fn
update_animations_for_new_style
<
E
>
(
&
mut
self
element
:
E
context
:
&
SharedStyleContext
new_style
:
&
Arc
<
ComputedValues
>
)
where
E
:
TElement
{
for
animation
in
self
.
animations
.
iter_mut
(
)
{
if
animation
.
is_cancelled_in_new_style
(
new_style
)
{
animation
.
state
=
AnimationState
:
:
Canceled
;
}
}
maybe_start_animations
(
element
&
context
&
new_style
self
)
;
for
animation
in
self
.
animations
.
iter_mut
(
)
{
animation
.
iterate_if_necessary
(
context
.
current_time_for_animations
)
;
}
}
pub
fn
update_transitions_for_new_style
<
E
>
(
&
mut
self
context
:
&
SharedStyleContext
opaque_node
:
OpaqueNode
old_style
:
Option
<
&
Arc
<
ComputedValues
>
>
after_change_style
:
&
Arc
<
ComputedValues
>
font_metrics
:
&
dyn
crate
:
:
font_metrics
:
:
FontMetricsProvider
)
where
E
:
TElement
{
let
mut
before_change_style
=
match
old_style
{
Some
(
old_style
)
=
>
Arc
:
:
clone
(
old_style
)
None
=
>
return
}
;
if
self
.
has_active_transition_or_animation
(
)
{
before_change_style
=
before_change_style
.
clone
(
)
;
self
.
apply_active_animations
:
:
<
E
>
(
context
&
mut
before_change_style
font_metrics
)
;
}
let
transitioning_properties
=
start_transitions_if_applicable
(
context
opaque_node
&
before_change_style
after_change_style
self
)
;
for
transition
in
self
.
transitions
.
iter_mut
(
)
{
if
transition
.
state
=
=
AnimationState
:
:
Finished
{
continue
;
}
if
transitioning_properties
.
contains
(
transition
.
property_animation
.
property_id
(
)
)
{
continue
;
}
transition
.
state
=
AnimationState
:
:
Canceled
;
}
}
}
pub
fn
start_transitions_if_applicable
(
context
:
&
SharedStyleContext
opaque_node
:
OpaqueNode
old_style
:
&
ComputedValues
new_style
:
&
Arc
<
ComputedValues
>
animation_state
:
&
mut
ElementAnimationSet
)
-
>
LonghandIdSet
{
if
new_style
.
get_box
(
)
.
clone_display
(
)
.
is_none
(
)
{
return
LonghandIdSet
:
:
new
(
)
;
}
let
mut
properties_that_transition
=
LonghandIdSet
:
:
new
(
)
;
for
transition
in
new_style
.
transition_properties
(
)
{
let
physical_property
=
transition
.
longhand_id
.
to_physical
(
new_style
.
writing_mode
)
;
if
properties_that_transition
.
contains
(
physical_property
)
{
continue
;
}
else
{
properties_that_transition
.
insert
(
physical_property
)
;
}
let
property_animation
=
match
PropertyAnimation
:
:
from_longhand
(
transition
.
longhand_id
new_style
.
get_box
(
)
.
transition_timing_function_mod
(
transition
.
index
)
new_style
.
get_box
(
)
.
transition_duration_mod
(
transition
.
index
)
old_style
new_style
)
{
Some
(
property_animation
)
=
>
property_animation
None
=
>
continue
}
;
if
animation_state
.
transitions
.
iter
(
)
.
any
(
|
transition
|
transition
.
has_same_end_value
(
&
property_animation
)
)
{
continue
;
}
debug
!
(
"
Kicking
off
transition
of
{
:
?
}
"
property_animation
)
;
let
box_style
=
new_style
.
get_box
(
)
;
let
start_time
=
context
.
current_time_for_animations
+
(
box_style
.
transition_delay_mod
(
transition
.
index
)
.
seconds
(
)
as
f64
)
;
animation_state
.
transitions
.
push
(
Transition
{
node
:
opaque_node
start_time
property_animation
state
:
AnimationState
:
:
Running
is_new
:
true
}
)
;
}
properties_that_transition
}
fn
compute_style_for_animation_step
<
E
>
(
context
:
&
SharedStyleContext
step
:
&
KeyframesStep
previous_style
:
&
ComputedValues
style_from_cascade
:
&
Arc
<
ComputedValues
>
font_metrics_provider
:
&
dyn
FontMetricsProvider
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
match
step
.
value
{
KeyframesStepValue
:
:
ComputedValues
=
>
style_from_cascade
.
clone
(
)
KeyframesStepValue
:
:
Declarations
{
block
:
ref
declarations
}
=
>
{
let
guard
=
declarations
.
read_with
(
context
.
guards
.
author
)
;
let
computed
=
properties
:
:
apply_declarations
:
:
<
E
_
>
(
context
.
stylist
.
device
(
)
None
previous_style
.
rules
(
)
&
context
.
guards
guard
.
normal_declaration_iter
(
)
.
filter
(
|
declaration
|
declaration
.
is_animatable
(
)
)
.
map
(
|
decl
|
(
decl
Origin
:
:
Author
)
)
Some
(
previous_style
)
Some
(
previous_style
)
Some
(
previous_style
)
font_metrics_provider
CascadeMode
:
:
Unvisited
{
visited_rules
:
None
}
context
.
quirks_mode
(
)
None
&
mut
Default
:
:
default
(
)
None
)
;
computed
}
}
}
pub
fn
maybe_start_animations
<
E
>
(
element
:
E
context
:
&
SharedStyleContext
new_style
:
&
Arc
<
ComputedValues
>
animation_state
:
&
mut
ElementAnimationSet
)
where
E
:
TElement
{
let
box_style
=
new_style
.
get_box
(
)
;
for
(
i
name
)
in
box_style
.
animation_name_iter
(
)
.
enumerate
(
)
{
let
name
=
match
name
.
as_atom
(
)
{
Some
(
atom
)
=
>
atom
None
=
>
continue
}
;
debug
!
(
"
maybe_start_animations
:
name
=
{
}
"
name
)
;
let
duration
=
box_style
.
animation_duration_mod
(
i
)
.
seconds
(
)
;
if
duration
=
=
0
.
{
continue
;
}
let
anim
=
match
context
.
stylist
.
get_animation
(
name
element
)
{
Some
(
animation
)
=
>
animation
None
=
>
continue
}
;
debug
!
(
"
maybe_start_animations
:
animation
{
}
found
"
name
)
;
if
anim
.
steps
.
is_empty
(
)
{
continue
;
}
let
delay
=
box_style
.
animation_delay_mod
(
i
)
.
seconds
(
)
;
let
animation_start
=
context
.
current_time_for_animations
+
delay
as
f64
;
let
iteration_state
=
match
box_style
.
animation_iteration_count_mod
(
i
)
{
AnimationIterationCount
:
:
Infinite
=
>
KeyframesIterationState
:
:
Infinite
AnimationIterationCount
:
:
Number
(
n
)
=
>
KeyframesIterationState
:
:
Finite
(
0
.
0
n
)
}
;
let
animation_direction
=
box_style
.
animation_direction_mod
(
i
)
;
let
initial_direction
=
match
animation_direction
{
AnimationDirection
:
:
Normal
|
AnimationDirection
:
:
Alternate
=
>
{
AnimationDirection
:
:
Normal
}
AnimationDirection
:
:
Reverse
|
AnimationDirection
:
:
AlternateReverse
=
>
{
AnimationDirection
:
:
Reverse
}
}
;
let
state
=
match
box_style
.
animation_play_state_mod
(
i
)
{
AnimationPlayState
:
:
Paused
=
>
AnimationState
:
:
Paused
(
0
.
)
AnimationPlayState
:
:
Running
=
>
AnimationState
:
:
Running
}
;
let
new_animation
=
Animation
{
node
:
element
.
as_node
(
)
.
opaque
(
)
name
:
name
.
clone
(
)
keyframes_animation
:
anim
.
clone
(
)
started_at
:
animation_start
duration
:
duration
as
f64
delay
:
delay
as
f64
iteration_state
state
direction
:
animation_direction
current_direction
:
initial_direction
cascade_style
:
new_style
.
clone
(
)
is_new
:
true
}
;
for
existing_animation
in
animation_state
.
animations
.
iter_mut
(
)
{
if
existing_animation
.
state
!
=
AnimationState
:
:
Running
{
continue
;
}
if
new_animation
.
name
=
=
existing_animation
.
name
{
existing_animation
.
update_from_other
(
&
new_animation
context
.
current_time_for_animations
)
;
return
;
}
}
animation_state
.
animations
.
push
(
new_animation
)
;
}
}
