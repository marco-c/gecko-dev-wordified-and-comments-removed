use
crate
:
:
bezier
:
:
Bezier
;
use
crate
:
:
context
:
:
SharedStyleContext
;
use
crate
:
:
dom
:
:
{
OpaqueNode
TElement
TNode
}
;
use
crate
:
:
font_metrics
:
:
FontMetricsProvider
;
use
crate
:
:
properties
:
:
animated_properties
:
:
AnimationValue
;
use
crate
:
:
properties
:
:
longhands
:
:
animation_direction
:
:
computed_value
:
:
single_value
:
:
T
as
AnimationDirection
;
use
crate
:
:
properties
:
:
longhands
:
:
animation_fill_mode
:
:
computed_value
:
:
single_value
:
:
T
as
AnimationFillMode
;
use
crate
:
:
properties
:
:
longhands
:
:
animation_play_state
:
:
computed_value
:
:
single_value
:
:
T
as
AnimationPlayState
;
use
crate
:
:
properties
:
:
LonghandIdSet
;
use
crate
:
:
properties
:
:
{
self
CascadeMode
ComputedValues
LonghandId
}
;
use
crate
:
:
stylesheets
:
:
keyframes_rule
:
:
{
KeyframesAnimation
KeyframesStep
KeyframesStepValue
}
;
use
crate
:
:
stylesheets
:
:
Origin
;
use
crate
:
:
values
:
:
animated
:
:
{
Animate
Procedure
}
;
use
crate
:
:
values
:
:
computed
:
:
Time
;
use
crate
:
:
values
:
:
computed
:
:
TimingFunction
;
use
crate
:
:
values
:
:
generics
:
:
box_
:
:
AnimationIterationCount
;
use
crate
:
:
values
:
:
generics
:
:
easing
:
:
{
StepPosition
TimingFunction
as
GenericTimingFunction
}
;
use
crate
:
:
Atom
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
;
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
PropertyAnimation
{
from
:
AnimationValue
to
:
AnimationValue
timing_function
:
TimingFunction
pub
duration
:
f64
}
impl
PropertyAnimation
{
pub
fn
property_id
(
&
self
)
-
>
LonghandId
{
debug_assert_eq
!
(
self
.
from
.
id
(
)
self
.
to
.
id
(
)
)
;
self
.
from
.
id
(
)
}
fn
from_longhand
(
longhand
:
LonghandId
timing_function
:
TimingFunction
duration
:
Time
old_style
:
&
ComputedValues
new_style
:
&
ComputedValues
)
-
>
Option
<
PropertyAnimation
>
{
let
longhand
=
longhand
.
to_physical
(
new_style
.
writing_mode
)
;
let
from
=
AnimationValue
:
:
from_computed_values
(
longhand
old_style
)
?
;
let
to
=
AnimationValue
:
:
from_computed_values
(
longhand
new_style
)
?
;
let
duration
=
duration
.
seconds
(
)
as
f64
;
if
from
=
=
to
|
|
duration
=
=
0
.
0
{
return
None
;
}
Some
(
PropertyAnimation
{
from
to
timing_function
duration
}
)
}
fn
timing_function_output
(
&
self
progress
:
f64
)
-
>
f64
{
let
epsilon
=
1
.
/
(
200
.
*
self
.
duration
)
;
match
self
.
timing_function
{
GenericTimingFunction
:
:
CubicBezier
{
x1
y1
x2
y2
}
=
>
{
Bezier
:
:
new
(
x1
y1
x2
y2
)
.
solve
(
progress
epsilon
)
}
GenericTimingFunction
:
:
Steps
(
steps
pos
)
=
>
{
let
mut
current_step
=
(
progress
*
(
steps
as
f64
)
)
.
floor
(
)
as
i32
;
if
pos
=
=
StepPosition
:
:
Start
|
|
pos
=
=
StepPosition
:
:
JumpStart
|
|
pos
=
=
StepPosition
:
:
JumpBoth
{
current_step
=
current_step
+
1
;
}
if
progress
>
=
0
.
0
&
&
current_step
<
0
{
current_step
=
0
;
}
let
jumps
=
match
pos
{
StepPosition
:
:
JumpBoth
=
>
steps
+
1
StepPosition
:
:
JumpNone
=
>
steps
-
1
StepPosition
:
:
JumpStart
|
StepPosition
:
:
JumpEnd
|
StepPosition
:
:
Start
|
StepPosition
:
:
End
=
>
steps
}
;
if
progress
<
=
1
.
0
&
&
current_step
>
jumps
{
current_step
=
jumps
;
}
(
current_step
as
f64
)
/
(
jumps
as
f64
)
}
GenericTimingFunction
:
:
Keyword
(
keyword
)
=
>
{
let
(
x1
x2
y1
y2
)
=
keyword
.
to_bezier
(
)
;
Bezier
:
:
new
(
x1
x2
y1
y2
)
.
solve
(
progress
epsilon
)
}
}
}
fn
update
(
&
self
style
:
&
mut
ComputedValues
progress
:
f64
)
{
let
procedure
=
Procedure
:
:
Interpolate
{
progress
:
self
.
timing_function_output
(
progress
)
}
;
if
let
Ok
(
new_value
)
=
self
.
from
.
animate
(
&
self
.
to
procedure
)
{
new_value
.
set_in_style_for_servo
(
style
)
;
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
)
]
pub
enum
AnimationState
{
Pending
Running
Paused
(
f64
)
Finished
Canceled
}
impl
AnimationState
{
fn
needs_to_be_ticked
(
&
self
)
-
>
bool
{
*
self
=
=
AnimationState
:
:
Running
|
|
*
self
=
=
AnimationState
:
:
Pending
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
enum
KeyframesIterationState
{
Infinite
(
f64
)
Finite
(
f64
f64
)
}
#
[
derive
(
Clone
MallocSizeOf
)
]
pub
struct
Animation
{
pub
node
:
OpaqueNode
pub
name
:
Atom
pub
keyframes_animation
:
KeyframesAnimation
pub
started_at
:
f64
pub
duration
:
f64
pub
delay
:
f64
pub
fill_mode
:
AnimationFillMode
pub
iteration_state
:
KeyframesIterationState
pub
state
:
AnimationState
pub
direction
:
AnimationDirection
pub
current_direction
:
AnimationDirection
#
[
ignore_malloc_size_of
=
"
ComputedValues
"
]
pub
cascade_style
:
Arc
<
ComputedValues
>
pub
is_new
:
bool
}
impl
Animation
{
fn
is_cancelled_in_new_style
(
&
self
new_style
:
&
Arc
<
ComputedValues
>
)
-
>
bool
{
let
index
=
new_style
.
get_box
(
)
.
animation_name_iter
(
)
.
position
(
|
animation_name
|
Some
(
&
self
.
name
)
=
=
animation_name
.
as_atom
(
)
)
;
let
index
=
match
index
{
Some
(
index
)
=
>
index
None
=
>
return
true
}
;
new_style
.
get_box
(
)
.
animation_duration_mod
(
index
)
.
seconds
(
)
=
=
0
.
}
pub
fn
iterate_if_necessary
(
&
mut
self
time
:
f64
)
-
>
bool
{
if
!
self
.
iteration_over
(
time
)
{
return
false
;
}
if
self
.
state
!
=
AnimationState
:
:
Running
{
return
false
;
}
if
let
KeyframesIterationState
:
:
Finite
(
ref
mut
current
max
)
=
self
.
iteration_state
{
*
current
=
(
*
current
+
1
.
)
.
min
(
max
)
;
if
*
current
=
=
max
{
return
false
;
}
}
self
.
started_at
+
=
self
.
duration
+
self
.
delay
;
match
self
.
direction
{
AnimationDirection
:
:
Alternate
|
AnimationDirection
:
:
AlternateReverse
=
>
{
self
.
current_direction
=
match
self
.
current_direction
{
AnimationDirection
:
:
Normal
=
>
AnimationDirection
:
:
Reverse
AnimationDirection
:
:
Reverse
=
>
AnimationDirection
:
:
Normal
_
=
>
unreachable
!
(
)
}
;
}
_
=
>
{
}
}
true
}
fn
iteration_over
(
&
self
time
:
f64
)
-
>
bool
{
time
>
(
self
.
started_at
+
self
.
duration
)
}
pub
fn
has_ended
(
&
self
time
:
f64
)
-
>
bool
{
match
self
.
state
{
AnimationState
:
:
Running
=
>
{
}
AnimationState
:
:
Finished
=
>
return
true
AnimationState
:
:
Pending
|
AnimationState
:
:
Canceled
|
AnimationState
:
:
Paused
(
_
)
=
>
{
return
false
}
}
if
!
self
.
iteration_over
(
time
)
{
return
false
;
}
return
match
self
.
iteration_state
{
KeyframesIterationState
:
:
Finite
(
current
max
)
=
>
max
=
=
current
KeyframesIterationState
:
:
Infinite
(
.
.
)
=
>
false
}
;
}
pub
fn
update_from_other
(
&
mut
self
other
:
&
Self
now
:
f64
)
{
use
self
:
:
AnimationState
:
:
*
;
debug
!
(
"
KeyframesAnimationState
:
:
update_from_other
(
{
:
?
}
{
:
?
}
)
"
self
other
)
;
let
old_started_at
=
self
.
started_at
;
let
old_duration
=
self
.
duration
;
let
old_direction
=
self
.
current_direction
;
let
old_state
=
self
.
state
.
clone
(
)
;
let
old_iteration_state
=
self
.
iteration_state
.
clone
(
)
;
*
self
=
other
.
clone
(
)
;
self
.
started_at
=
old_started_at
;
self
.
current_direction
=
old_direction
;
match
(
&
mut
self
.
iteration_state
old_iteration_state
)
{
(
&
mut
KeyframesIterationState
:
:
Finite
(
ref
mut
iters
_
)
KeyframesIterationState
:
:
Finite
(
old_iters
_
)
)
=
>
*
iters
=
old_iters
_
=
>
{
}
}
let
new_state
=
std
:
:
mem
:
:
replace
(
&
mut
self
.
state
Running
)
;
if
old_state
=
=
Finished
&
&
self
.
has_ended
(
now
)
{
self
.
state
=
Finished
;
}
else
{
self
.
state
=
new_state
;
}
match
(
&
mut
self
.
state
&
old_state
)
{
(
&
mut
Pending
&
Paused
(
progress
)
)
=
>
{
self
.
started_at
=
now
-
(
self
.
duration
*
progress
)
;
}
(
&
mut
Paused
(
ref
mut
new
)
&
Paused
(
old
)
)
=
>
*
new
=
old
(
&
mut
Paused
(
ref
mut
progress
)
&
Running
)
=
>
{
*
progress
=
(
now
-
old_started_at
)
/
old_duration
}
_
=
>
{
}
}
if
self
.
state
=
=
Pending
&
&
self
.
started_at
<
=
now
&
&
old_state
!
=
Pending
{
self
.
state
=
Running
;
}
}
fn
update_style
<
E
>
(
&
self
context
:
&
SharedStyleContext
style
:
&
mut
Arc
<
ComputedValues
>
font_metrics_provider
:
&
dyn
FontMetricsProvider
)
where
E
:
TElement
{
let
duration
=
self
.
duration
;
let
started_at
=
self
.
started_at
;
let
now
=
match
self
.
state
{
AnimationState
:
:
Running
|
AnimationState
:
:
Pending
|
AnimationState
:
:
Finished
=
>
{
context
.
current_time_for_animations
}
AnimationState
:
:
Paused
(
progress
)
=
>
started_at
+
duration
*
progress
AnimationState
:
:
Canceled
=
>
return
}
;
debug_assert
!
(
!
self
.
keyframes_animation
.
steps
.
is_empty
(
)
)
;
let
mut
total_progress
=
(
now
-
started_at
)
/
duration
;
if
total_progress
<
0
.
&
&
self
.
fill_mode
!
=
AnimationFillMode
:
:
Backwards
&
&
self
.
fill_mode
!
=
AnimationFillMode
:
:
Both
{
return
;
}
if
total_progress
>
1
.
&
&
self
.
fill_mode
!
=
AnimationFillMode
:
:
Forwards
&
&
self
.
fill_mode
!
=
AnimationFillMode
:
:
Both
{
return
;
}
total_progress
=
total_progress
.
min
(
1
.
0
)
.
max
(
0
.
0
)
;
let
next_keyframe_index
;
let
prev_keyframe_index
;
match
self
.
current_direction
{
AnimationDirection
:
:
Normal
=
>
{
next_keyframe_index
=
self
.
keyframes_animation
.
steps
.
iter
(
)
.
position
(
|
step
|
total_progress
as
f32
<
=
step
.
start_percentage
.
0
)
;
prev_keyframe_index
=
next_keyframe_index
.
and_then
(
|
pos
|
if
pos
!
=
0
{
Some
(
pos
-
1
)
}
else
{
None
}
)
.
unwrap_or
(
0
)
;
}
AnimationDirection
:
:
Reverse
=
>
{
next_keyframe_index
=
self
.
keyframes_animation
.
steps
.
iter
(
)
.
rev
(
)
.
position
(
|
step
|
total_progress
as
f32
<
=
1
.
-
step
.
start_percentage
.
0
)
.
map
(
|
pos
|
self
.
keyframes_animation
.
steps
.
len
(
)
-
pos
-
1
)
;
prev_keyframe_index
=
next_keyframe_index
.
and_then
(
|
pos
|
{
if
pos
!
=
self
.
keyframes_animation
.
steps
.
len
(
)
-
1
{
Some
(
pos
+
1
)
}
else
{
None
}
}
)
.
unwrap_or
(
self
.
keyframes_animation
.
steps
.
len
(
)
-
1
)
}
_
=
>
unreachable
!
(
)
}
debug
!
(
"
Animation
:
:
update_style
:
keyframe
from
{
:
?
}
to
{
:
?
}
"
prev_keyframe_index
next_keyframe_index
)
;
let
prev_keyframe
=
&
self
.
keyframes_animation
.
steps
[
prev_keyframe_index
]
;
let
next_keyframe
=
match
next_keyframe_index
{
Some
(
target
)
=
>
&
self
.
keyframes_animation
.
steps
[
target
]
None
=
>
return
}
;
let
update_with_single_keyframe_style
=
|
style
computed_style
:
&
Arc
<
ComputedValues
>
|
{
let
mutable_style
=
Arc
:
:
make_mut
(
style
)
;
for
property
in
self
.
keyframes_animation
.
properties_changed
.
iter
(
)
.
filter_map
(
|
longhand
|
{
AnimationValue
:
:
from_computed_values
(
longhand
&
*
*
computed_style
)
}
)
{
property
.
set_in_style_for_servo
(
mutable_style
)
;
}
}
;
let
prev_keyframe_style
=
compute_style_for_animation_step
:
:
<
E
>
(
context
prev_keyframe
style
&
self
.
cascade_style
font_metrics_provider
)
;
if
total_progress
<
=
0
.
0
{
update_with_single_keyframe_style
(
style
&
prev_keyframe_style
)
;
return
;
}
let
next_keyframe_style
=
compute_style_for_animation_step
:
:
<
E
>
(
context
next_keyframe
&
prev_keyframe_style
&
self
.
cascade_style
font_metrics_provider
)
;
if
total_progress
>
=
1
.
0
{
update_with_single_keyframe_style
(
style
&
next_keyframe_style
)
;
return
;
}
let
relative_timespan
=
(
next_keyframe
.
start_percentage
.
0
-
prev_keyframe
.
start_percentage
.
0
)
.
abs
(
)
;
let
relative_duration
=
relative_timespan
as
f64
*
duration
;
let
last_keyframe_ended_at
=
match
self
.
current_direction
{
AnimationDirection
:
:
Normal
=
>
{
self
.
started_at
+
(
duration
*
prev_keyframe
.
start_percentage
.
0
as
f64
)
}
AnimationDirection
:
:
Reverse
=
>
{
self
.
started_at
+
(
duration
*
(
1
.
-
prev_keyframe
.
start_percentage
.
0
as
f64
)
)
}
_
=
>
unreachable
!
(
)
}
;
let
relative_progress
=
(
now
-
last_keyframe_ended_at
)
/
relative_duration
;
let
timing_function
=
if
prev_keyframe
.
declared_timing_function
{
prev_keyframe_style
.
get_box
(
)
.
animation_timing_function_at
(
0
)
}
else
{
let
index
=
match
style
.
get_box
(
)
.
animation_name_iter
(
)
.
position
(
|
animation_name
|
Some
(
&
self
.
name
)
=
=
animation_name
.
as_atom
(
)
)
{
Some
(
index
)
=
>
index
None
=
>
return
warn
!
(
"
Tried
to
update
a
style
with
a
cancelled
animation
.
"
)
}
;
style
.
get_box
(
)
.
animation_timing_function_mod
(
index
)
}
;
let
mut
new_style
=
(
*
*
style
)
.
clone
(
)
;
let
mut
update_style_for_longhand
=
|
longhand
|
{
let
from
=
AnimationValue
:
:
from_computed_values
(
longhand
&
prev_keyframe_style
)
?
;
let
to
=
AnimationValue
:
:
from_computed_values
(
longhand
&
next_keyframe_style
)
?
;
PropertyAnimation
{
from
to
timing_function
duration
:
relative_duration
as
f64
}
.
update
(
&
mut
new_style
relative_progress
)
;
None
:
:
<
(
)
>
}
;
for
property
in
self
.
keyframes_animation
.
properties_changed
.
iter
(
)
{
update_style_for_longhand
(
property
)
;
}
*
Arc
:
:
make_mut
(
style
)
=
new_style
;
}
}
impl
fmt
:
:
Debug
for
Animation
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Animation
"
)
.
field
(
"
name
"
&
self
.
name
)
.
field
(
"
started_at
"
&
self
.
started_at
)
.
field
(
"
duration
"
&
self
.
duration
)
.
field
(
"
delay
"
&
self
.
delay
)
.
field
(
"
iteration_state
"
&
self
.
iteration_state
)
.
field
(
"
state
"
&
self
.
state
)
.
field
(
"
direction
"
&
self
.
direction
)
.
field
(
"
current_direction
"
&
self
.
current_direction
)
.
field
(
"
cascade_style
"
&
(
)
)
.
finish
(
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
Transition
{
pub
node
:
OpaqueNode
pub
start_time
:
f64
pub
delay
:
f64
pub
property_animation
:
PropertyAnimation
pub
state
:
AnimationState
pub
is_new
:
bool
pub
reversing_adjusted_start_value
:
AnimationValue
pub
reversing_shortening_factor
:
f64
}
impl
Transition
{
fn
update_for_possibly_reversed_transition
(
&
mut
self
replaced_transition
:
&
Transition
delay
:
f64
now
:
f64
)
{
if
replaced_transition
.
reversing_adjusted_start_value
!
=
self
.
property_animation
.
to
{
return
;
}
let
replaced_animation
=
&
replaced_transition
.
property_animation
;
self
.
reversing_adjusted_start_value
=
replaced_animation
.
to
.
clone
(
)
;
let
transition_progress
=
replaced_transition
.
progress
(
now
)
;
let
timing_function_output
=
replaced_animation
.
timing_function_output
(
transition_progress
)
;
let
old_reversing_shortening_factor
=
replaced_transition
.
reversing_shortening_factor
;
self
.
reversing_shortening_factor
=
(
(
timing_function_output
*
old_reversing_shortening_factor
)
+
(
1
.
0
-
old_reversing_shortening_factor
)
)
.
abs
(
)
.
min
(
1
.
0
)
.
max
(
0
.
0
)
;
self
.
start_time
=
if
delay
>
=
0
.
{
now
+
delay
}
else
{
now
+
(
self
.
reversing_shortening_factor
*
delay
)
}
;
self
.
property_animation
.
duration
*
=
self
.
reversing_shortening_factor
;
let
procedure
=
Procedure
:
:
Interpolate
{
progress
:
timing_function_output
}
;
match
replaced_animation
.
from
.
animate
(
&
replaced_animation
.
to
procedure
)
{
Ok
(
new_start
)
=
>
self
.
property_animation
.
from
=
new_start
Err
(
.
.
)
=
>
{
}
}
}
pub
fn
has_ended
(
&
self
time
:
f64
)
-
>
bool
{
time
>
=
self
.
start_time
+
(
self
.
property_animation
.
duration
)
}
#
[
inline
]
fn
progress
(
&
self
now
:
f64
)
-
>
f64
{
let
progress
=
(
now
-
self
.
start_time
)
/
(
self
.
property_animation
.
duration
)
;
progress
.
min
(
1
.
0
)
}
fn
update_style
(
&
self
context
:
&
SharedStyleContext
style
:
&
mut
Arc
<
ComputedValues
>
)
{
if
self
.
state
=
=
AnimationState
:
:
Canceled
{
return
;
}
let
progress
=
self
.
progress
(
context
.
current_time_for_animations
)
;
if
progress
>
=
0
.
0
{
self
.
property_animation
.
update
(
Arc
:
:
make_mut
(
style
)
progress
)
;
}
}
}
#
[
derive
(
Debug
Default
MallocSizeOf
)
]
pub
struct
ElementAnimationSet
{
pub
animations
:
Vec
<
Animation
>
pub
transitions
:
Vec
<
Transition
>
}
impl
ElementAnimationSet
{
pub
fn
cancel_all_animations
(
&
mut
self
)
{
for
animation
in
self
.
animations
.
iter_mut
(
)
{
animation
.
state
=
AnimationState
:
:
Canceled
;
}
for
transition
in
self
.
transitions
.
iter_mut
(
)
{
transition
.
state
=
AnimationState
:
:
Canceled
;
}
}
pub
(
crate
)
fn
apply_active_animations
<
E
>
(
&
mut
self
context
:
&
SharedStyleContext
style
:
&
mut
Arc
<
ComputedValues
>
font_metrics
:
&
dyn
crate
:
:
font_metrics
:
:
FontMetricsProvider
)
where
E
:
TElement
{
for
animation
in
&
self
.
animations
{
animation
.
update_style
:
:
<
E
>
(
context
style
font_metrics
)
;
}
for
transition
in
&
self
.
transitions
{
transition
.
update_style
(
context
style
)
;
}
}
pub
fn
clear_canceled_animations
(
&
mut
self
)
{
self
.
animations
.
retain
(
|
animation
|
animation
.
state
!
=
AnimationState
:
:
Canceled
)
;
self
.
transitions
.
retain
(
|
animation
|
animation
.
state
!
=
AnimationState
:
:
Canceled
)
;
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
animations
.
is_empty
(
)
&
&
self
.
transitions
.
is_empty
(
)
}
pub
fn
needs_animation_ticks
(
&
self
)
-
>
bool
{
self
.
animations
.
iter
(
)
.
any
(
|
animation
|
animation
.
state
.
needs_to_be_ticked
(
)
)
|
|
self
.
transitions
.
iter
(
)
.
any
(
|
transition
|
transition
.
state
.
needs_to_be_ticked
(
)
)
}
pub
fn
running_animation_and_transition_count
(
&
self
)
-
>
usize
{
self
.
animations
.
iter
(
)
.
filter
(
|
animation
|
animation
.
state
.
needs_to_be_ticked
(
)
)
.
count
(
)
+
self
.
transitions
.
iter
(
)
.
filter
(
|
transition
|
transition
.
state
.
needs_to_be_ticked
(
)
)
.
count
(
)
}
fn
has_active_transition_or_animation
(
&
self
)
-
>
bool
{
self
.
animations
.
iter
(
)
.
any
(
|
animation
|
animation
.
state
!
=
AnimationState
:
:
Canceled
)
|
|
self
.
transitions
.
iter
(
)
.
any
(
|
transition
|
transition
.
state
!
=
AnimationState
:
:
Canceled
)
}
pub
fn
update_animations_for_new_style
<
E
>
(
&
mut
self
element
:
E
context
:
&
SharedStyleContext
new_style
:
&
Arc
<
ComputedValues
>
)
where
E
:
TElement
{
for
animation
in
self
.
animations
.
iter_mut
(
)
{
if
animation
.
is_cancelled_in_new_style
(
new_style
)
{
animation
.
state
=
AnimationState
:
:
Canceled
;
}
}
maybe_start_animations
(
element
&
context
&
new_style
self
)
;
}
pub
fn
update_transitions_for_new_style
<
E
>
(
&
mut
self
context
:
&
SharedStyleContext
opaque_node
:
OpaqueNode
old_style
:
Option
<
&
Arc
<
ComputedValues
>
>
after_change_style
:
&
Arc
<
ComputedValues
>
font_metrics
:
&
dyn
crate
:
:
font_metrics
:
:
FontMetricsProvider
)
where
E
:
TElement
{
let
mut
before_change_style
=
match
old_style
{
Some
(
old_style
)
=
>
Arc
:
:
clone
(
old_style
)
None
=
>
return
}
;
if
self
.
has_active_transition_or_animation
(
)
{
before_change_style
=
before_change_style
.
clone
(
)
;
self
.
apply_active_animations
:
:
<
E
>
(
context
&
mut
before_change_style
font_metrics
)
;
}
let
transitioning_properties
=
start_transitions_if_applicable
(
context
opaque_node
&
before_change_style
after_change_style
self
)
;
for
transition
in
self
.
transitions
.
iter_mut
(
)
{
if
transition
.
state
=
=
AnimationState
:
:
Finished
{
continue
;
}
if
transitioning_properties
.
contains
(
transition
.
property_animation
.
property_id
(
)
)
{
continue
;
}
transition
.
state
=
AnimationState
:
:
Canceled
;
}
}
fn
start_transition_if_applicable
(
&
mut
self
context
:
&
SharedStyleContext
opaque_node
:
OpaqueNode
longhand_id
:
LonghandId
index
:
usize
old_style
:
&
ComputedValues
new_style
:
&
Arc
<
ComputedValues
>
)
{
let
box_style
=
new_style
.
get_box
(
)
;
let
timing_function
=
box_style
.
transition_timing_function_mod
(
index
)
;
let
duration
=
box_style
.
transition_duration_mod
(
index
)
;
let
delay
=
box_style
.
transition_delay_mod
(
index
)
.
seconds
(
)
as
f64
;
let
now
=
context
.
current_time_for_animations
;
let
property_animation
=
match
PropertyAnimation
:
:
from_longhand
(
longhand_id
timing_function
duration
old_style
new_style
)
{
Some
(
property_animation
)
=
>
property_animation
None
=
>
return
}
;
if
self
.
transitions
.
iter
(
)
.
filter
(
|
transition
|
transition
.
state
!
=
AnimationState
:
:
Canceled
)
.
any
(
|
transition
|
transition
.
property_animation
.
to
=
=
property_animation
.
to
)
{
return
;
}
let
reversing_adjusted_start_value
=
property_animation
.
from
.
clone
(
)
;
let
mut
new_transition
=
Transition
{
node
:
opaque_node
start_time
:
now
+
delay
delay
property_animation
state
:
AnimationState
:
:
Pending
is_new
:
true
reversing_adjusted_start_value
reversing_shortening_factor
:
1
.
0
}
;
if
let
Some
(
old_transition
)
=
self
.
transitions
.
iter_mut
(
)
.
filter
(
|
transition
|
transition
.
state
=
=
AnimationState
:
:
Running
)
.
find
(
|
transition
|
transition
.
property_animation
.
property_id
(
)
=
=
longhand_id
)
{
old_transition
.
state
=
AnimationState
:
:
Canceled
;
new_transition
.
update_for_possibly_reversed_transition
(
old_transition
delay
now
)
;
}
self
.
transitions
.
push
(
new_transition
)
;
}
}
pub
fn
start_transitions_if_applicable
(
context
:
&
SharedStyleContext
opaque_node
:
OpaqueNode
old_style
:
&
ComputedValues
new_style
:
&
Arc
<
ComputedValues
>
animation_state
:
&
mut
ElementAnimationSet
)
-
>
LonghandIdSet
{
let
box_style
=
new_style
.
get_box
(
)
;
if
box_style
.
clone_display
(
)
.
is_none
(
)
{
return
LonghandIdSet
:
:
new
(
)
;
}
let
mut
properties_that_transition
=
LonghandIdSet
:
:
new
(
)
;
for
transition
in
new_style
.
transition_properties
(
)
{
let
physical_property
=
transition
.
longhand_id
.
to_physical
(
new_style
.
writing_mode
)
;
if
properties_that_transition
.
contains
(
physical_property
)
{
continue
;
}
properties_that_transition
.
insert
(
physical_property
)
;
animation_state
.
start_transition_if_applicable
(
context
opaque_node
physical_property
transition
.
index
old_style
new_style
)
;
}
properties_that_transition
}
fn
compute_style_for_animation_step
<
E
>
(
context
:
&
SharedStyleContext
step
:
&
KeyframesStep
previous_style
:
&
ComputedValues
style_from_cascade
:
&
Arc
<
ComputedValues
>
font_metrics_provider
:
&
dyn
FontMetricsProvider
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
match
step
.
value
{
KeyframesStepValue
:
:
ComputedValues
=
>
style_from_cascade
.
clone
(
)
KeyframesStepValue
:
:
Declarations
{
block
:
ref
declarations
}
=
>
{
let
guard
=
declarations
.
read_with
(
context
.
guards
.
author
)
;
let
iter
=
|
|
{
guard
.
normal_declaration_iter
(
)
.
filter
(
|
declaration
|
declaration
.
is_animatable
(
)
)
.
map
(
|
decl
|
(
decl
Origin
:
:
Author
)
)
}
;
let
computed
=
properties
:
:
apply_declarations
:
:
<
E
_
_
>
(
context
.
stylist
.
device
(
)
None
previous_style
.
rules
(
)
&
context
.
guards
iter
Some
(
previous_style
)
Some
(
previous_style
)
Some
(
previous_style
)
font_metrics_provider
CascadeMode
:
:
Unvisited
{
visited_rules
:
None
}
context
.
quirks_mode
(
)
None
&
mut
Default
:
:
default
(
)
None
)
;
computed
}
}
}
pub
fn
maybe_start_animations
<
E
>
(
element
:
E
context
:
&
SharedStyleContext
new_style
:
&
Arc
<
ComputedValues
>
animation_state
:
&
mut
ElementAnimationSet
)
where
E
:
TElement
{
let
box_style
=
new_style
.
get_box
(
)
;
for
(
i
name
)
in
box_style
.
animation_name_iter
(
)
.
enumerate
(
)
{
let
name
=
match
name
.
as_atom
(
)
{
Some
(
atom
)
=
>
atom
None
=
>
continue
}
;
debug
!
(
"
maybe_start_animations
:
name
=
{
}
"
name
)
;
let
duration
=
box_style
.
animation_duration_mod
(
i
)
.
seconds
(
)
;
if
duration
=
=
0
.
{
continue
;
}
let
anim
=
match
context
.
stylist
.
get_animation
(
name
element
)
{
Some
(
animation
)
=
>
animation
None
=
>
continue
}
;
debug
!
(
"
maybe_start_animations
:
animation
{
}
found
"
name
)
;
if
anim
.
steps
.
is_empty
(
)
{
continue
;
}
let
delay
=
box_style
.
animation_delay_mod
(
i
)
.
seconds
(
)
;
let
animation_start
=
context
.
current_time_for_animations
+
delay
as
f64
;
let
iteration_state
=
match
box_style
.
animation_iteration_count_mod
(
i
)
{
AnimationIterationCount
:
:
Infinite
=
>
KeyframesIterationState
:
:
Infinite
(
0
.
0
)
AnimationIterationCount
:
:
Number
(
n
)
=
>
KeyframesIterationState
:
:
Finite
(
0
.
0
n
.
into
(
)
)
}
;
let
animation_direction
=
box_style
.
animation_direction_mod
(
i
)
;
let
initial_direction
=
match
animation_direction
{
AnimationDirection
:
:
Normal
|
AnimationDirection
:
:
Alternate
=
>
{
AnimationDirection
:
:
Normal
}
AnimationDirection
:
:
Reverse
|
AnimationDirection
:
:
AlternateReverse
=
>
{
AnimationDirection
:
:
Reverse
}
}
;
let
state
=
match
box_style
.
animation_play_state_mod
(
i
)
{
AnimationPlayState
:
:
Paused
=
>
AnimationState
:
:
Paused
(
0
.
)
AnimationPlayState
:
:
Running
=
>
AnimationState
:
:
Pending
}
;
let
new_animation
=
Animation
{
node
:
element
.
as_node
(
)
.
opaque
(
)
name
:
name
.
clone
(
)
keyframes_animation
:
anim
.
clone
(
)
started_at
:
animation_start
duration
:
duration
as
f64
fill_mode
:
box_style
.
animation_fill_mode_mod
(
i
)
delay
:
delay
as
f64
iteration_state
state
direction
:
animation_direction
current_direction
:
initial_direction
cascade_style
:
new_style
.
clone
(
)
is_new
:
true
}
;
for
existing_animation
in
animation_state
.
animations
.
iter_mut
(
)
{
if
existing_animation
.
state
=
=
AnimationState
:
:
Canceled
{
continue
;
}
if
new_animation
.
name
=
=
existing_animation
.
name
{
existing_animation
.
update_from_other
(
&
new_animation
context
.
current_time_for_animations
)
;
return
;
}
}
animation_state
.
animations
.
push
(
new_animation
)
;
}
}
