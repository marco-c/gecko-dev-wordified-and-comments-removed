#
!
[
allow
(
unsafe_code
)
]
use
crate
:
:
counter_style
:
:
{
Symbol
Symbols
}
;
use
crate
:
:
gecko_bindings
:
:
structs
:
:
CounterStylePtr
;
use
crate
:
:
values
:
:
generics
:
:
CounterStyleOrNone
;
use
crate
:
:
values
:
:
Either
;
use
crate
:
:
Atom
;
use
app_units
:
:
Au
;
use
cssparser
:
:
RGBA
;
use
nsstring
:
:
{
nsACString
nsCStr
}
;
use
std
:
:
cmp
:
:
max
;
pub
fn
convert_rgba_to_nscolor
(
rgba
:
&
RGBA
)
-
>
u32
{
(
(
rgba
.
alpha
as
u32
)
<
<
24
)
|
(
(
rgba
.
blue
as
u32
)
<
<
16
)
|
(
(
rgba
.
green
as
u32
)
<
<
8
)
|
(
rgba
.
red
as
u32
)
}
pub
fn
convert_nscolor_to_rgba
(
color
:
u32
)
-
>
RGBA
{
RGBA
:
:
new
(
(
color
&
0xff
)
as
u8
(
color
>
>
8
&
0xff
)
as
u8
(
color
>
>
16
&
0xff
)
as
u8
(
color
>
>
24
&
0xff
)
as
u8
)
}
#
[
inline
]
pub
fn
round_border_to_device_pixels
(
width
:
Au
au_per_device_px
:
Au
)
-
>
Au
{
if
width
=
=
Au
(
0
)
{
Au
(
0
)
}
else
{
max
(
au_per_device_px
Au
(
width
.
0
/
au_per_device_px
.
0
*
au_per_device_px
.
0
)
)
}
}
impl
CounterStyleOrNone
{
pub
fn
to_gecko_value
(
self
gecko_value
:
&
mut
CounterStylePtr
)
{
use
crate
:
:
gecko_bindings
:
:
bindings
:
:
Gecko_SetCounterStyleToName
as
set_name
;
use
crate
:
:
gecko_bindings
:
:
bindings
:
:
Gecko_SetCounterStyleToSymbols
as
set_symbols
;
match
self
{
CounterStyleOrNone
:
:
None
=
>
unsafe
{
set_name
(
gecko_value
atom
!
(
"
none
"
)
.
into_addrefed
(
)
)
;
}
CounterStyleOrNone
:
:
Name
(
name
)
=
>
unsafe
{
set_name
(
gecko_value
name
.
0
.
into_addrefed
(
)
)
;
}
CounterStyleOrNone
:
:
Symbols
(
symbols_type
symbols
)
=
>
{
let
symbols
:
Vec
<
_
>
=
symbols
.
0
.
iter
(
)
.
map
(
|
symbol
|
match
*
symbol
{
Symbol
:
:
String
(
ref
s
)
=
>
nsCStr
:
:
from
(
&
*
*
s
)
Symbol
:
:
Ident
(
_
)
=
>
unreachable
!
(
"
Should
not
have
identifier
in
symbols
(
)
"
)
}
)
.
collect
(
)
;
let
symbols
:
Vec
<
_
>
=
symbols
.
iter
(
)
.
map
(
|
symbol
|
symbol
as
&
nsACString
as
*
const
_
)
.
collect
(
)
;
unsafe
{
set_symbols
(
gecko_value
symbols_type
.
to_gecko_keyword
(
)
symbols
.
as_ptr
(
)
symbols
.
len
(
)
as
u32
)
}
;
}
}
}
pub
fn
from_gecko_value
(
gecko_value
:
&
CounterStylePtr
)
-
>
Either
<
Self
String
>
{
use
crate
:
:
gecko_bindings
:
:
bindings
;
use
crate
:
:
values
:
:
generics
:
:
SymbolsType
;
use
crate
:
:
values
:
:
CustomIdent
;
let
name
=
unsafe
{
bindings
:
:
Gecko_CounterStyle_GetName
(
gecko_value
)
}
;
if
!
name
.
is_null
(
)
{
let
name
=
unsafe
{
Atom
:
:
from_raw
(
name
)
}
;
if
name
=
=
atom
!
(
"
none
"
)
{
Either
:
:
First
(
CounterStyleOrNone
:
:
None
)
}
else
{
Either
:
:
First
(
CounterStyleOrNone
:
:
Name
(
CustomIdent
(
name
)
)
)
}
}
else
{
let
anonymous
=
unsafe
{
bindings
:
:
Gecko_CounterStyle_GetAnonymous
(
gecko_value
)
.
as_ref
(
)
}
.
unwrap
(
)
;
let
symbols
=
&
anonymous
.
mSymbols
;
if
anonymous
.
mSingleString
{
debug_assert_eq
!
(
symbols
.
len
(
)
1
)
;
Either
:
:
Second
(
symbols
[
0
]
.
to_string
(
)
)
}
else
{
let
symbol_type
=
SymbolsType
:
:
from_gecko_keyword
(
anonymous
.
mSystem
as
u32
)
;
let
symbols
=
symbols
.
iter
(
)
.
map
(
|
gecko_symbol
|
Symbol
:
:
String
(
gecko_symbol
.
to_string
(
)
.
into
(
)
)
)
.
collect
(
)
;
Either
:
:
First
(
CounterStyleOrNone
:
:
Symbols
(
symbol_type
Symbols
(
symbols
)
)
)
}
}
}
}
