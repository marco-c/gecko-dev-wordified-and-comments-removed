use
cssparser
:
:
{
ToCss
serialize_identifier
}
;
use
gecko_bindings
:
:
structs
:
:
{
self
CSSPseudoElementType
}
;
use
properties
:
:
{
ComputedValues
PropertyFlags
}
;
use
properties
:
:
longhands
:
:
display
:
:
computed_value
as
display
;
use
selector_parser
:
:
{
NonTSPseudoClass
PseudoElementCascadeType
SelectorImpl
}
;
use
std
:
:
fmt
;
use
string_cache
:
:
Atom
;
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
gecko
/
pseudo_element_definition
.
rs
"
)
)
;
impl
:
:
selectors
:
:
parser
:
:
PseudoElement
for
PseudoElement
{
type
Impl
=
SelectorImpl
;
fn
supports_pseudo_class
(
&
self
pseudo_class
:
&
NonTSPseudoClass
)
-
>
bool
{
if
!
self
.
supports_user_action_state
(
)
{
return
false
;
}
return
pseudo_class
.
is_safe_user_action_state
(
)
;
}
}
impl
PseudoElement
{
pub
fn
cascade_type
(
&
self
)
-
>
PseudoElementCascadeType
{
if
self
.
is_eager
(
)
{
debug_assert
!
(
!
self
.
is_anon_box
(
)
)
;
return
PseudoElementCascadeType
:
:
Eager
}
if
self
.
is_anon_box
(
)
{
return
PseudoElementCascadeType
:
:
Precomputed
}
PseudoElementCascadeType
:
:
Lazy
}
pub
fn
inherits_from_default_values
(
&
self
)
-
>
bool
{
matches
!
(
*
self
PseudoElement
:
:
Backdrop
)
}
#
[
inline
]
pub
fn
eager_index
(
&
self
)
-
>
usize
{
EAGER_PSEUDOS
.
iter
(
)
.
position
(
|
p
|
p
=
=
self
)
.
expect
(
"
Not
an
eager
pseudo
"
)
}
#
[
inline
]
pub
fn
from_eager_index
(
i
:
usize
)
-
>
Self
{
EAGER_PSEUDOS
[
i
]
.
clone
(
)
}
#
[
inline
]
pub
fn
is_before_or_after
(
&
self
)
-
>
bool
{
self
.
is_before
(
)
|
|
self
.
is_after
(
)
}
#
[
inline
]
pub
fn
is_before
(
&
self
)
-
>
bool
{
*
self
=
=
PseudoElement
:
:
Before
}
#
[
inline
]
pub
fn
is_after
(
&
self
)
-
>
bool
{
*
self
=
=
PseudoElement
:
:
After
}
#
[
inline
]
pub
fn
is_first_letter
(
&
self
)
-
>
bool
{
*
self
=
=
PseudoElement
:
:
FirstLetter
}
#
[
inline
]
pub
fn
is_first_line
(
&
self
)
-
>
bool
{
*
self
=
=
PseudoElement
:
:
FirstLine
}
#
[
inline
]
pub
fn
is_fieldset_content
(
&
self
)
-
>
bool
{
*
self
=
=
PseudoElement
:
:
FieldsetContent
}
#
[
inline
]
pub
fn
is_lazy
(
&
self
)
-
>
bool
{
!
self
.
is_eager
(
)
&
&
!
self
.
is_precomputed
(
)
}
pub
fn
exposed_in_non_ua_sheets
(
&
self
)
-
>
bool
{
(
self
.
flags
(
)
&
structs
:
:
CSS_PSEUDO_ELEMENT_UA_SHEET_ONLY
)
=
=
0
}
pub
fn
supports_user_action_state
(
&
self
)
-
>
bool
{
(
self
.
flags
(
)
&
structs
:
:
CSS_PSEUDO_ELEMENT_SUPPORTS_USER_ACTION_STATE
)
!
=
0
}
#
[
inline
]
pub
fn
skip_item_based_display_fixup
(
&
self
)
-
>
bool
{
(
self
.
flags
(
)
&
structs
:
:
CSS_PSEUDO_ELEMENT_IS_FLEX_OR_GRID_ITEM
)
=
=
0
}
#
[
inline
]
pub
fn
is_precomputed
(
&
self
)
-
>
bool
{
self
.
is_anon_box
(
)
}
pub
fn
canonical
(
&
self
)
-
>
PseudoElement
{
match
*
self
{
PseudoElement
:
:
MozPlaceholder
=
>
PseudoElement
:
:
Placeholder
_
=
>
self
.
clone
(
)
}
}
#
[
inline
]
pub
fn
property_restriction
(
&
self
)
-
>
Option
<
PropertyFlags
>
{
match
*
self
{
PseudoElement
:
:
FirstLetter
=
>
Some
(
PropertyFlags
:
:
APPLIES_TO_FIRST_LETTER
)
PseudoElement
:
:
FirstLine
=
>
Some
(
PropertyFlags
:
:
APPLIES_TO_FIRST_LINE
)
PseudoElement
:
:
Placeholder
=
>
Some
(
PropertyFlags
:
:
APPLIES_TO_PLACEHOLDER
)
_
=
>
None
}
}
pub
fn
should_exist
(
&
self
style
:
&
ComputedValues
)
-
>
bool
{
let
display
=
style
.
get_box
(
)
.
clone_display
(
)
;
if
display
=
=
display
:
:
T
:
:
none
{
return
false
;
}
if
self
.
is_before_or_after
(
)
&
&
style
.
ineffective_content_property
(
)
{
return
false
;
}
true
}
}
