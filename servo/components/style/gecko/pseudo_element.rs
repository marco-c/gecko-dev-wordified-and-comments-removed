use
cssparser
:
:
ToCss
;
use
gecko_bindings
:
:
structs
:
:
{
self
CSSPseudoElementType
}
;
use
selector_parser
:
:
PseudoElementCascadeType
;
use
std
:
:
fmt
;
use
string_cache
:
:
Atom
;
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
gecko
/
pseudo_element_definition
.
rs
"
)
)
;
impl
PseudoElement
{
pub
fn
cascade_type
(
&
self
)
-
>
PseudoElementCascadeType
{
if
self
.
is_eager
(
)
{
debug_assert
!
(
!
self
.
is_anon_box
(
)
)
;
return
PseudoElementCascadeType
:
:
Eager
}
if
self
.
is_anon_box
(
)
{
return
PseudoElementCascadeType
:
:
Precomputed
}
PseudoElementCascadeType
:
:
Lazy
}
#
[
inline
]
pub
fn
eager_index
(
&
self
)
-
>
usize
{
EAGER_PSEUDOS
.
iter
(
)
.
position
(
|
p
|
p
=
=
self
)
.
expect
(
"
Not
an
eager
pseudo
"
)
}
#
[
inline
]
pub
fn
from_eager_index
(
i
:
usize
)
-
>
Self
{
EAGER_PSEUDOS
[
i
]
.
clone
(
)
}
#
[
inline
]
pub
fn
is_before_or_after
(
&
self
)
-
>
bool
{
matches
!
(
*
self
PseudoElement
:
:
Before
|
PseudoElement
:
:
After
)
}
#
[
inline
]
pub
fn
is_lazy
(
&
self
)
-
>
bool
{
!
self
.
is_eager
(
)
&
&
!
self
.
is_precomputed
(
)
}
pub
fn
exposed_in_non_ua_sheets
(
&
self
)
-
>
bool
{
if
self
.
is_anon_box
(
)
{
return
false
;
}
(
self
.
flags
(
)
&
structs
:
:
CSS_PSEUDO_ELEMENT_UA_SHEET_ONLY
)
=
=
0
}
pub
fn
supports_user_action_state
(
&
self
)
-
>
bool
{
(
self
.
flags
(
)
&
structs
:
:
CSS_PSEUDO_ELEMENT_SUPPORTS_USER_ACTION_STATE
)
!
=
0
}
#
[
inline
]
pub
fn
is_precomputed
(
&
self
)
-
>
bool
{
self
.
is_anon_box
(
)
}
}
impl
ToCss
for
PseudoElement
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_char
(
'
:
'
)
?
;
dest
.
write_str
(
self
.
as_str
(
)
)
}
}
