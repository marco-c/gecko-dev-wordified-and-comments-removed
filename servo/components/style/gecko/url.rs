use
cssparser
:
:
Parser
;
use
gecko_bindings
:
:
bindings
;
use
gecko_bindings
:
:
structs
:
:
{
ServoBundledURI
URLExtraData
}
;
use
gecko_bindings
:
:
structs
:
:
mozilla
:
:
css
:
:
URLValueData
;
use
gecko_bindings
:
:
structs
:
:
root
:
:
{
nsStyleImageRequest
RustString
}
;
use
gecko_bindings
:
:
structs
:
:
root
:
:
mozilla
:
:
css
:
:
{
ImageValue
URLValue
}
;
use
gecko_bindings
:
:
sugar
:
:
refptr
:
:
RefPtr
;
use
malloc_size_of
:
:
{
MallocSizeOf
MallocSizeOfOps
}
;
use
parser
:
:
{
Parse
ParserContext
}
;
use
servo_arc
:
:
{
Arc
RawOffsetArc
}
;
use
std
:
:
mem
;
use
style_traits
:
:
ParseError
;
#
[
css
(
function
=
"
url
"
)
]
#
[
derive
(
Clone
Debug
PartialEq
ToCss
)
]
pub
struct
CssUrl
{
serialization
:
Arc
<
String
>
#
[
css
(
skip
)
]
pub
extra_data
:
RefPtr
<
URLExtraData
>
}
impl
CssUrl
{
pub
fn
parse_from_string
<
'
a
>
(
url
:
String
context
:
&
ParserContext
)
-
>
Result
<
Self
ParseError
<
'
a
>
>
{
Ok
(
CssUrl
{
serialization
:
Arc
:
:
new
(
url
)
extra_data
:
context
.
url_data
.
clone
(
)
}
)
}
pub
fn
is_invalid
(
&
self
)
-
>
bool
{
false
}
unsafe
fn
from_url_value_data
(
url
:
&
URLValueData
)
-
>
Result
<
Self
(
)
>
{
Ok
(
CssUrl
{
serialization
:
if
url
.
mUsingRustString
{
let
arc_type
=
url
.
mStrings
.
mRustString
.
as_ref
(
)
as
*
const
_
as
*
const
RawOffsetArc
<
String
>
;
Arc
:
:
from_raw_offset
(
(
*
arc_type
)
.
clone
(
)
)
}
else
{
Arc
:
:
new
(
url
.
mStrings
.
mString
.
as_ref
(
)
.
to_string
(
)
)
}
extra_data
:
url
.
mExtraData
.
to_safe
(
)
}
)
}
pub
fn
is_fragment
(
&
self
)
-
>
bool
{
self
.
as_str
(
)
.
chars
(
)
.
next
(
)
.
map_or
(
false
|
c
|
c
=
=
'
#
'
)
}
pub
fn
as_str
(
&
self
)
-
>
&
str
{
&
*
self
.
serialization
}
pub
fn
as_slice_components
(
&
self
)
-
>
(
*
const
u8
usize
)
{
(
self
.
serialization
.
as_str
(
)
.
as_ptr
(
)
self
.
serialization
.
as_str
(
)
.
len
(
)
)
}
pub
fn
for_ffi
(
&
self
)
-
>
ServoBundledURI
{
let
arc_offset
=
Arc
:
:
into_raw_offset
(
self
.
serialization
.
clone
(
)
)
;
ServoBundledURI
{
mURLString
:
unsafe
{
mem
:
:
transmute
:
:
<
_
RawOffsetArc
<
RustString
>
>
(
arc_offset
)
}
mExtraData
:
self
.
extra_data
.
get
(
)
}
}
}
impl
Parse
for
CssUrl
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
url
=
input
.
expect_url
(
)
?
;
Self
:
:
parse_from_string
(
url
.
as_ref
(
)
.
to_owned
(
)
context
)
}
}
impl
Eq
for
CssUrl
{
}
impl
MallocSizeOf
for
CssUrl
{
fn
size_of
(
&
self
_ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
0
}
}
#
[
derive
(
Clone
Debug
ToComputedValue
ToCss
)
]
pub
struct
SpecifiedUrl
{
pub
url
:
CssUrl
#
[
css
(
skip
)
]
pub
url_value
:
RefPtr
<
URLValue
>
}
impl
SpecifiedUrl
{
fn
from_css_url
(
url
:
CssUrl
)
-
>
Self
{
let
url_value
=
unsafe
{
let
ptr
=
bindings
:
:
Gecko_NewURLValue
(
url
.
for_ffi
(
)
)
;
debug_assert
!
(
!
ptr
.
is_null
(
)
)
;
RefPtr
:
:
from_addrefed
(
ptr
)
}
;
SpecifiedUrl
{
url
url_value
}
}
pub
unsafe
fn
from_url_value_data
(
url
:
&
URLValueData
)
-
>
Result
<
Self
(
)
>
{
CssUrl
:
:
from_url_value_data
(
url
)
.
map
(
Self
:
:
from_css_url
)
}
}
impl
PartialEq
for
SpecifiedUrl
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
url
.
eq
(
&
other
.
url
)
}
}
impl
Eq
for
SpecifiedUrl
{
}
impl
Parse
for
SpecifiedUrl
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
CssUrl
:
:
parse
(
context
input
)
.
map
(
Self
:
:
from_css_url
)
}
}
impl
MallocSizeOf
for
SpecifiedUrl
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
url
.
size_of
(
ops
)
;
n
+
=
unsafe
{
bindings
:
:
Gecko_URLValue_SizeOfIncludingThis
(
self
.
url_value
.
get
(
)
)
}
;
n
}
}
#
[
derive
(
Clone
Debug
ToComputedValue
ToCss
)
]
pub
struct
SpecifiedImageUrl
{
pub
url
:
CssUrl
#
[
css
(
skip
)
]
pub
image_value
:
RefPtr
<
ImageValue
>
}
impl
SpecifiedImageUrl
{
fn
from_css_url
(
url
:
CssUrl
)
-
>
Self
{
let
image_value
=
unsafe
{
let
ptr
=
bindings
:
:
Gecko_ImageValue_Create
(
url
.
for_ffi
(
)
)
;
debug_assert
!
(
!
ptr
.
is_null
(
)
)
;
RefPtr
:
:
from_addrefed
(
ptr
)
}
;
SpecifiedImageUrl
{
url
image_value
}
}
pub
fn
parse_from_string
<
'
a
>
(
url
:
String
context
:
&
ParserContext
)
-
>
Result
<
Self
ParseError
<
'
a
>
>
{
CssUrl
:
:
parse_from_string
(
url
context
)
.
map
(
Self
:
:
from_css_url
)
}
pub
unsafe
fn
from_url_value_data
(
url
:
&
URLValueData
)
-
>
Result
<
Self
(
)
>
{
CssUrl
:
:
from_url_value_data
(
url
)
.
map
(
Self
:
:
from_css_url
)
}
pub
unsafe
fn
from_image_request
(
image_request
:
&
nsStyleImageRequest
)
-
>
Result
<
Self
(
)
>
{
if
image_request
.
mImageValue
.
mRawPtr
.
is_null
(
)
{
return
Err
(
(
)
)
;
}
let
image_value
=
image_request
.
mImageValue
.
mRawPtr
.
as_ref
(
)
.
unwrap
(
)
;
let
url_value_data
=
&
image_value
.
_base
;
Self
:
:
from_url_value_data
(
url_value_data
)
}
}
impl
Parse
for
SpecifiedImageUrl
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
CssUrl
:
:
parse
(
context
input
)
.
map
(
Self
:
:
from_css_url
)
}
}
impl
PartialEq
for
SpecifiedImageUrl
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
url
.
eq
(
&
other
.
url
)
}
}
impl
Eq
for
SpecifiedImageUrl
{
}
impl
MallocSizeOf
for
SpecifiedImageUrl
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
url
.
size_of
(
ops
)
;
n
+
=
unsafe
{
bindings
:
:
Gecko_ImageValue_SizeOfIncludingThis
(
self
.
image_value
.
get
(
)
)
}
;
n
}
}
pub
type
ComputedUrl
=
SpecifiedUrl
;
pub
type
ComputedImageUrl
=
SpecifiedImageUrl
;
