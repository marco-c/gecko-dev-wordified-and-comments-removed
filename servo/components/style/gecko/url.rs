use
crate
:
:
gecko_bindings
:
:
bindings
;
use
crate
:
:
gecko_bindings
:
:
structs
:
:
root
:
:
mozilla
:
:
css
:
:
URLValue
;
use
crate
:
:
gecko_bindings
:
:
structs
:
:
root
:
:
mozilla
:
:
CORSMode
;
use
crate
:
:
gecko_bindings
:
:
structs
:
:
root
:
:
nsStyleImageRequest
;
use
crate
:
:
gecko_bindings
:
:
sugar
:
:
ownership
:
:
{
FFIArcHelpers
HasArcFFI
}
;
use
crate
:
:
gecko_bindings
:
:
sugar
:
:
refptr
:
:
RefPtr
;
use
crate
:
:
parser
:
:
{
Parse
ParserContext
}
;
use
crate
:
:
stylesheets
:
:
UrlExtraData
;
use
crate
:
:
values
:
:
computed
:
:
{
Context
ToComputedValue
}
;
use
cssparser
:
:
Parser
;
use
malloc_size_of
:
:
{
MallocSizeOf
MallocSizeOfOps
}
;
use
nsstring
:
:
nsCString
;
use
servo_arc
:
:
Arc
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
sync
:
:
RwLock
;
use
style_traits
:
:
{
CssWriter
ParseError
ToCss
}
;
#
[
css
(
function
=
"
url
"
)
]
#
[
derive
(
Clone
Debug
PartialEq
SpecifiedValueInfo
ToCss
)
]
pub
struct
CssUrl
(
pub
Arc
<
CssUrlData
>
)
;
#
[
derive
(
Clone
Debug
PartialEq
SpecifiedValueInfo
ToCss
)
]
pub
struct
CssUrlData
{
serialization
:
String
#
[
css
(
skip
)
]
pub
extra_data
:
UrlExtraData
}
impl
CssUrl
{
pub
fn
parse_from_string
(
url
:
String
context
:
&
ParserContext
)
-
>
Self
{
CssUrl
(
Arc
:
:
new
(
CssUrlData
{
serialization
:
url
extra_data
:
context
.
url_data
.
clone
(
)
}
)
)
}
pub
fn
is_invalid
(
&
self
)
-
>
bool
{
false
}
#
[
inline
]
pub
fn
is_fragment
(
&
self
)
-
>
bool
{
self
.
0
.
is_fragment
(
)
}
#
[
inline
]
pub
fn
as_str
(
&
self
)
-
>
&
str
{
self
.
0
.
as_str
(
)
}
}
impl
CssUrlData
{
pub
fn
is_fragment
(
&
self
)
-
>
bool
{
self
.
as_str
(
)
.
chars
(
)
.
next
(
)
.
map_or
(
false
|
c
|
c
=
=
'
#
'
)
}
pub
fn
as_str
(
&
self
)
-
>
&
str
{
&
*
self
.
serialization
}
}
#
[
cfg
(
debug_assertions
)
]
impl
Drop
for
CssUrlData
{
fn
drop
(
&
mut
self
)
{
assert
!
(
!
URL_VALUE_TABLE
.
read
(
)
.
unwrap
(
)
.
contains_key
(
&
CssUrlDataKey
(
self
as
*
mut
_
as
*
const
_
)
)
"
All
CssUrlData
objects
used
as
keys
in
URL_VALUE_TABLE
should
be
\
from
shared
memory
style
sheets
and
so
should
never
be
dropped
"
)
;
}
}
impl
Parse
for
CssUrl
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
url
=
input
.
expect_url
(
)
?
;
Ok
(
Self
:
:
parse_from_string
(
url
.
as_ref
(
)
.
to_owned
(
)
context
)
)
}
}
impl
Eq
for
CssUrl
{
}
impl
MallocSizeOf
for
CssUrl
{
fn
size_of
(
&
self
_ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
0
}
}
#
[
derive
(
Hash
PartialEq
Eq
)
]
struct
CssUrlDataKey
(
*
const
CssUrlData
)
;
unsafe
impl
Sync
for
CssUrlDataKey
{
}
unsafe
impl
Send
for
CssUrlDataKey
{
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
URLValueSource
{
URLValue
(
RefPtr
<
URLValue
>
)
CORSMode
(
CORSMode
)
}
#
[
derive
(
Clone
Debug
SpecifiedValueInfo
ToCss
)
]
pub
struct
SpecifiedUrl
{
pub
url
:
CssUrl
#
[
css
(
skip
)
]
url_value
:
Box
<
URLValueSource
>
}
fn
make_url_value
(
url
:
&
CssUrl
cors_mode
:
CORSMode
)
-
>
RefPtr
<
URLValue
>
{
unsafe
{
let
ptr
=
bindings
:
:
Gecko_URLValue_Create
(
url
.
0
.
clone
(
)
.
into_strong
(
)
cors_mode
)
;
debug_assert
!
(
!
ptr
.
is_null
(
)
)
;
RefPtr
:
:
from_addrefed
(
ptr
)
}
}
impl
SpecifiedUrl
{
pub
fn
parse_from_string
(
url
:
String
context
:
&
ParserContext
)
-
>
Self
{
Self
:
:
from_css_url
(
CssUrl
:
:
parse_from_string
(
url
context
)
)
}
fn
from_css_url_with_cors
(
url
:
CssUrl
cors
:
CORSMode
)
-
>
Self
{
let
url_value
=
Box
:
:
new
(
URLValueSource
:
:
URLValue
(
make_url_value
(
&
url
cors
)
)
)
;
Self
{
url
url_value
}
}
fn
from_css_url
(
url
:
CssUrl
)
-
>
Self
{
use
crate
:
:
gecko_bindings
:
:
structs
:
:
root
:
:
mozilla
:
:
CORSMode_CORS_NONE
;
Self
:
:
from_css_url_with_cors
(
url
CORSMode_CORS_NONE
)
}
fn
from_css_url_with_cors_anonymous
(
url
:
CssUrl
)
-
>
Self
{
use
crate
:
:
gecko_bindings
:
:
structs
:
:
root
:
:
mozilla
:
:
CORSMode_CORS_ANONYMOUS
;
Self
:
:
from_css_url_with_cors
(
url
CORSMode_CORS_ANONYMOUS
)
}
fn
with_url_value
<
F
T
>
(
&
self
f
:
F
)
-
>
T
where
F
:
FnOnce
(
&
RefPtr
<
URLValue
>
)
-
>
T
{
match
*
self
.
url_value
{
URLValueSource
:
:
URLValue
(
ref
r
)
=
>
f
(
r
)
URLValueSource
:
:
CORSMode
(
cors_mode
)
=
>
{
{
let
guard
=
URL_VALUE_TABLE
.
read
(
)
.
unwrap
(
)
;
if
let
Some
(
r
)
=
guard
.
get
(
&
(
CssUrlDataKey
(
&
*
self
.
url
.
0
as
*
const
_
)
)
)
{
return
f
(
r
)
;
}
}
let
mut
guard
=
URL_VALUE_TABLE
.
write
(
)
.
unwrap
(
)
;
let
r
=
guard
.
entry
(
CssUrlDataKey
(
&
*
self
.
url
.
0
as
*
const
_
)
)
.
or_insert_with
(
|
|
make_url_value
(
&
self
.
url
cors_mode
)
)
;
f
(
r
)
}
}
}
pub
fn
clone_url_value
(
&
self
)
-
>
RefPtr
<
URLValue
>
{
self
.
with_url_value
(
RefPtr
:
:
clone
)
}
pub
fn
url_value_ptr
(
&
self
)
-
>
*
mut
URLValue
{
self
.
with_url_value
(
RefPtr
:
:
get
)
}
}
pub
fn
shutdown
(
)
{
URL_VALUE_TABLE
.
write
(
)
.
unwrap
(
)
.
clear
(
)
;
}
impl
Parse
for
SpecifiedUrl
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
CssUrl
:
:
parse
(
context
input
)
.
map
(
Self
:
:
from_css_url
)
}
}
impl
PartialEq
for
SpecifiedUrl
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
url
.
eq
(
&
other
.
url
)
}
}
impl
Eq
for
SpecifiedUrl
{
}
impl
MallocSizeOf
for
SpecifiedUrl
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
url
.
size_of
(
ops
)
;
n
+
=
unsafe
{
bindings
:
:
Gecko_URLValue_SizeOfIncludingThis
(
self
.
url_value_ptr
(
)
)
}
;
n
}
}
impl
ToComputedValue
for
SpecifiedUrl
{
type
ComputedValue
=
ComputedUrl
;
#
[
inline
]
fn
to_computed_value
(
&
self
_
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
ComputedUrl
(
self
.
clone
(
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
computed
.
0
.
clone
(
)
}
}
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
SpecifiedValueInfo
ToCss
)
]
pub
struct
SpecifiedImageUrl
(
pub
SpecifiedUrl
)
;
impl
SpecifiedImageUrl
{
pub
fn
parse_from_string
(
url
:
String
context
:
&
ParserContext
)
-
>
Self
{
SpecifiedImageUrl
(
SpecifiedUrl
:
:
parse_from_string
(
url
context
)
)
}
pub
fn
parse_with_cors_anonymous
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
CssUrl
:
:
parse
(
context
input
)
.
map
(
SpecifiedUrl
:
:
from_css_url_with_cors_anonymous
)
.
map
(
SpecifiedImageUrl
)
}
}
impl
Parse
for
SpecifiedImageUrl
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
SpecifiedUrl
:
:
parse
(
context
input
)
.
map
(
SpecifiedImageUrl
)
}
}
impl
ToComputedValue
for
SpecifiedImageUrl
{
type
ComputedValue
=
ComputedImageUrl
;
#
[
inline
]
fn
to_computed_value
(
&
self
_
:
&
Context
)
-
>
Self
:
:
ComputedValue
{
ComputedImageUrl
(
self
.
clone
(
)
)
}
#
[
inline
]
fn
from_computed_value
(
computed
:
&
Self
:
:
ComputedValue
)
-
>
Self
{
computed
.
0
.
clone
(
)
}
}
fn
serialize_computed_url
<
W
>
(
url_value
:
&
URLValue
dest
:
&
mut
CssWriter
<
W
>
get_url
:
unsafe
extern
"
C
"
fn
(
*
const
URLValue
*
mut
nsCString
)
)
-
>
fmt
:
:
Result
where
W
:
Write
{
dest
.
write_str
(
"
url
(
"
)
?
;
unsafe
{
let
mut
string
=
nsCString
:
:
new
(
)
;
get_url
(
url_value
&
mut
string
)
;
string
.
as_str_unchecked
(
)
.
to_css
(
dest
)
?
;
}
dest
.
write_char
(
'
)
'
)
}
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
)
]
pub
struct
ComputedUrl
(
pub
SpecifiedUrl
)
;
impl
ToCss
for
ComputedUrl
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
0
.
with_url_value
(
|
r
|
serialize_computed_url
(
r
dest
bindings
:
:
Gecko_GetComputedURLSpec
)
)
}
}
impl
ComputedUrl
{
pub
unsafe
fn
from_url_value
(
url_value
:
RefPtr
<
URLValue
>
)
-
>
Self
{
let
css_url
=
&
*
url_value
.
mCssUrl
.
mRawPtr
;
let
url
=
CssUrl
(
CssUrlData
:
:
as_arc
(
&
css_url
)
.
clone_arc
(
)
)
;
ComputedUrl
(
SpecifiedUrl
{
url
url_value
:
Box
:
:
new
(
URLValueSource
:
:
URLValue
(
url_value
)
)
}
)
}
pub
fn
clone_url_value
(
&
self
)
-
>
RefPtr
<
URLValue
>
{
self
.
0
.
clone_url_value
(
)
}
pub
fn
url_value_ptr
(
&
self
)
-
>
*
mut
URLValue
{
self
.
0
.
url_value_ptr
(
)
}
}
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
)
]
pub
struct
ComputedImageUrl
(
pub
SpecifiedImageUrl
)
;
impl
ToCss
for
ComputedImageUrl
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
(
self
.
0
)
.
0
.
with_url_value
(
|
r
|
{
serialize_computed_url
(
r
dest
bindings
:
:
Gecko_GetComputedImageURLSpec
)
}
)
}
}
impl
ComputedImageUrl
{
pub
unsafe
fn
from_image_request
(
image_request
:
&
nsStyleImageRequest
)
-
>
Self
{
let
url_value
=
image_request
.
mImageValue
.
to_safe
(
)
;
let
css_url
=
&
*
url_value
.
mCssUrl
.
mRawPtr
;
let
url
=
CssUrl
(
CssUrlData
:
:
as_arc
(
&
css_url
)
.
clone_arc
(
)
)
;
ComputedImageUrl
(
SpecifiedImageUrl
(
SpecifiedUrl
{
url
url_value
:
Box
:
:
new
(
URLValueSource
:
:
URLValue
(
url_value
)
)
}
)
)
}
pub
fn
clone_url_value
(
&
self
)
-
>
RefPtr
<
URLValue
>
{
(
self
.
0
)
.
0
.
clone_url_value
(
)
}
pub
fn
url_value_ptr
(
&
self
)
-
>
*
mut
URLValue
{
(
self
.
0
)
.
0
.
url_value_ptr
(
)
}
}
lazy_static
!
{
/
/
/
A
table
mapping
CssUrlData
objects
to
their
lazily
created
Gecko
/
/
/
URLValue
objects
.
static
ref
URL_VALUE_TABLE
:
RwLock
<
HashMap
<
CssUrlDataKey
RefPtr
<
URLValue
>
>
>
=
{
Default
:
:
default
(
)
}
;
}
