use
cssparser
:
:
CssStringWriter
;
use
gecko_bindings
:
:
structs
:
:
{
ServoBundledURI
URLExtraData
}
;
use
gecko_bindings
:
:
sugar
:
:
refptr
:
:
RefPtr
;
use
parser
:
:
ParserContext
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
sync
:
:
Arc
;
use
style_traits
:
:
ToCss
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
SpecifiedUrl
{
serialization
:
Arc
<
String
>
pub
extra_data
:
RefPtr
<
URLExtraData
>
}
impl
SpecifiedUrl
{
pub
fn
parse_from_string
<
'
a
>
(
url
:
Cow
<
'
a
str
>
context
:
&
ParserContext
)
-
>
Result
<
Self
(
)
>
{
let
extra
=
&
context
.
extra_data
;
if
extra
.
data
.
is_none
(
)
{
warn
!
(
"
stylo
:
skipping
declaration
without
ParserContextExtraData
"
)
;
return
Err
(
(
)
)
}
Ok
(
SpecifiedUrl
{
serialization
:
Arc
:
:
new
(
url
.
into_owned
(
)
)
extra_data
:
extra
.
data
.
as_ref
(
)
.
unwrap
(
)
.
clone
(
)
}
)
}
pub
fn
is_invalid
(
&
self
)
-
>
bool
{
false
}
pub
fn
is_fragment
(
&
self
)
-
>
bool
{
self
.
as_str
(
)
.
chars
(
)
.
next
(
)
.
map_or
(
false
|
c
|
c
=
=
'
#
'
)
}
pub
fn
as_str
(
&
self
)
-
>
&
str
{
&
*
self
.
serialization
}
pub
fn
as_slice_components
(
&
self
)
-
>
(
*
const
u8
usize
)
{
(
self
.
serialization
.
as_str
(
)
.
as_ptr
(
)
self
.
serialization
.
as_str
(
)
.
len
(
)
)
}
pub
fn
for_ffi
(
&
self
)
-
>
ServoBundledURI
{
let
(
ptr
len
)
=
self
.
as_slice_components
(
)
;
ServoBundledURI
{
mURLString
:
ptr
mURLStringLength
:
len
as
u32
mExtraData
:
self
.
extra_data
.
get
(
)
}
}
}
impl
ToCss
for
SpecifiedUrl
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
try
!
(
dest
.
write_str
(
"
url
(
\
"
"
)
)
;
try
!
(
CssStringWriter
:
:
new
(
dest
)
.
write_str
(
&
*
self
.
serialization
)
)
;
dest
.
write_str
(
"
\
"
)
"
)
}
}
