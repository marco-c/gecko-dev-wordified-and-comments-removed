use
app_units
:
:
AU_PER_PX
;
use
app_units
:
:
Au
;
use
cssparser
:
:
RGBA
;
use
euclid
:
:
Size2D
;
use
euclid
:
:
TypedScale
;
use
gecko
:
:
values
:
:
{
convert_nscolor_to_rgba
convert_rgba_to_nscolor
}
;
use
gecko_bindings
:
:
bindings
;
use
gecko_bindings
:
:
structs
;
use
gecko_bindings
:
:
structs
:
:
{
nsPresContext
RawGeckoPresContextBorrowed
}
;
use
media_queries
:
:
MediaType
;
use
properties
:
:
ComputedValues
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
AtomicIsize
AtomicUsize
Ordering
}
;
use
string_cache
:
:
Atom
;
use
style_traits
:
:
{
CSSPixel
DevicePixel
}
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
use
values
:
:
{
CustomIdent
KeyframesName
}
;
use
values
:
:
computed
:
:
font
:
:
FontSize
;
pub
struct
Device
{
pres_context
:
RawGeckoPresContextBorrowed
default_values
:
Arc
<
ComputedValues
>
root_font_size
:
AtomicIsize
body_text_color
:
AtomicUsize
used_root_font_size
:
AtomicBool
used_viewport_size
:
AtomicBool
}
impl
fmt
:
:
Debug
for
Device
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
use
nsstring
:
:
nsCString
;
let
mut
doc_uri
=
nsCString
:
:
new
(
)
;
unsafe
{
bindings
:
:
Gecko_nsIURI_Debug
(
(
*
self
.
document
(
)
)
.
mDocumentURI
.
raw
:
:
<
structs
:
:
nsIURI
>
(
)
&
mut
doc_uri
)
}
;
f
.
debug_struct
(
"
Device
"
)
.
field
(
"
document_url
"
&
doc_uri
)
.
finish
(
)
}
}
unsafe
impl
Sync
for
Device
{
}
unsafe
impl
Send
for
Device
{
}
impl
Device
{
pub
fn
new
(
pres_context
:
RawGeckoPresContextBorrowed
)
-
>
Self
{
assert
!
(
!
pres_context
.
is_null
(
)
)
;
Device
{
pres_context
default_values
:
ComputedValues
:
:
default_values
(
unsafe
{
&
*
pres_context
}
)
root_font_size
:
AtomicIsize
:
:
new
(
FontSize
:
:
medium
(
)
.
size
(
)
.
0
as
isize
)
body_text_color
:
AtomicUsize
:
:
new
(
unsafe
{
&
*
pres_context
}
.
mDefaultColor
as
usize
)
used_root_font_size
:
AtomicBool
:
:
new
(
false
)
used_viewport_size
:
AtomicBool
:
:
new
(
false
)
}
}
pub
fn
account_for_viewport_rule
(
&
mut
self
_constraints
:
&
ViewportConstraints
)
{
unreachable
!
(
"
Gecko
doesn
'
t
support
viewport
"
)
;
}
pub
fn
animation_name_may_be_referenced
(
&
self
name
:
&
KeyframesName
)
-
>
bool
{
unsafe
{
bindings
:
:
Gecko_AnimationNameMayBeReferencedFromStyle
(
self
.
pres_context
(
)
name
.
as_atom
(
)
.
as_ptr
(
)
)
}
}
pub
fn
default_computed_values
(
&
self
)
-
>
&
ComputedValues
{
&
self
.
default_values
}
pub
fn
default_computed_values_arc
(
&
self
)
-
>
&
Arc
<
ComputedValues
>
{
&
self
.
default_values
}
pub
fn
root_font_size
(
&
self
)
-
>
Au
{
self
.
used_root_font_size
.
store
(
true
Ordering
:
:
Relaxed
)
;
Au
:
:
new
(
self
.
root_font_size
.
load
(
Ordering
:
:
Relaxed
)
as
i32
)
}
pub
fn
set_root_font_size
(
&
self
size
:
Au
)
{
self
.
root_font_size
.
store
(
size
.
0
as
isize
Ordering
:
:
Relaxed
)
}
pub
fn
set_body_text_color
(
&
self
color
:
RGBA
)
{
self
.
body_text_color
.
store
(
convert_rgba_to_nscolor
(
&
color
)
as
usize
Ordering
:
:
Relaxed
)
}
pub
fn
body_text_color
(
&
self
)
-
>
RGBA
{
convert_nscolor_to_rgba
(
self
.
body_text_color
.
load
(
Ordering
:
:
Relaxed
)
as
u32
)
}
#
[
inline
]
pub
fn
pres_context
(
&
self
)
-
>
&
nsPresContext
{
unsafe
{
&
*
self
.
pres_context
}
}
#
[
inline
]
pub
fn
document
(
&
self
)
-
>
*
mut
structs
:
:
nsIDocument
{
self
.
pres_context
(
)
.
mDocument
.
raw
:
:
<
structs
:
:
nsIDocument
>
(
)
}
pub
fn
reset_computed_values
(
&
mut
self
)
{
self
.
default_values
=
ComputedValues
:
:
default_values
(
self
.
pres_context
(
)
)
;
}
pub
fn
rebuild_cached_data
(
&
mut
self
)
{
self
.
reset_computed_values
(
)
;
self
.
used_root_font_size
.
store
(
false
Ordering
:
:
Relaxed
)
;
self
.
used_viewport_size
.
store
(
false
Ordering
:
:
Relaxed
)
;
}
pub
fn
used_root_font_size
(
&
self
)
-
>
bool
{
self
.
used_root_font_size
.
load
(
Ordering
:
:
Relaxed
)
}
pub
fn
reset
(
&
mut
self
)
{
self
.
reset_computed_values
(
)
;
}
pub
fn
media_type
(
&
self
)
-
>
MediaType
{
let
context
=
self
.
pres_context
(
)
;
let
medium_to_use
=
if
context
.
mIsEmulatingMedia
(
)
!
=
0
{
context
.
mMediaEmulated
.
mRawPtr
}
else
{
context
.
mMedium
}
;
MediaType
(
CustomIdent
(
unsafe
{
Atom
:
:
from_raw
(
medium_to_use
)
}
)
)
}
pub
fn
au_viewport_size
(
&
self
)
-
>
Size2D
<
Au
>
{
let
area
=
&
self
.
pres_context
(
)
.
mVisibleArea
;
Size2D
:
:
new
(
Au
(
area
.
width
)
Au
(
area
.
height
)
)
}
pub
fn
au_viewport_size_for_viewport_unit_resolution
(
&
self
)
-
>
Size2D
<
Au
>
{
self
.
used_viewport_size
.
store
(
true
Ordering
:
:
Relaxed
)
;
self
.
au_viewport_size
(
)
}
pub
fn
used_viewport_size
(
&
self
)
-
>
bool
{
self
.
used_viewport_size
.
load
(
Ordering
:
:
Relaxed
)
}
pub
fn
device_pixel_ratio
(
&
self
)
-
>
TypedScale
<
f32
CSSPixel
DevicePixel
>
{
let
override_dppx
=
self
.
pres_context
(
)
.
mOverrideDPPX
;
if
override_dppx
>
0
.
0
{
return
TypedScale
:
:
new
(
override_dppx
)
;
}
let
au_per_dpx
=
self
.
pres_context
(
)
.
mCurAppUnitsPerDevPixel
as
f32
;
let
au_per_px
=
AU_PER_PX
as
f32
;
TypedScale
:
:
new
(
au_per_px
/
au_per_dpx
)
}
pub
fn
use_document_colors
(
&
self
)
-
>
bool
{
self
.
pres_context
(
)
.
mUseDocumentColors
(
)
!
=
0
}
pub
fn
default_background_color
(
&
self
)
-
>
RGBA
{
convert_nscolor_to_rgba
(
self
.
pres_context
(
)
.
mBackgroundColor
)
}
#
[
inline
]
pub
fn
zoom_text
(
&
self
size
:
Au
)
-
>
Au
{
size
.
scale_by
(
self
.
pres_context
(
)
.
mEffectiveTextZoom
)
}
#
[
inline
]
pub
fn
unzoom_text
(
&
self
size
:
Au
)
-
>
Au
{
size
.
scale_by
(
1
.
/
self
.
pres_context
(
)
.
mEffectiveTextZoom
)
}
}
