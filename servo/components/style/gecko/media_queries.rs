use
crate
:
:
custom_properties
:
:
CssEnvironment
;
use
crate
:
:
gecko
:
:
values
:
:
{
convert_nscolor_to_rgba
convert_rgba_to_nscolor
}
;
use
crate
:
:
gecko_bindings
:
:
bindings
;
use
crate
:
:
gecko_bindings
:
:
structs
;
use
crate
:
:
media_queries
:
:
MediaType
;
use
crate
:
:
properties
:
:
ComputedValues
;
use
crate
:
:
string_cache
:
:
Atom
;
use
crate
:
:
values
:
:
computed
:
:
Length
;
use
crate
:
:
values
:
:
specified
:
:
font
:
:
FONT_MEDIUM_PX
;
use
crate
:
:
values
:
:
{
CustomIdent
KeyframesName
}
;
use
app_units
:
:
{
Au
AU_PER_PX
}
;
use
cssparser
:
:
RGBA
;
use
euclid
:
:
default
:
:
Size2D
;
use
euclid
:
:
{
Scale
SideOffsets2D
}
;
use
servo_arc
:
:
Arc
;
use
std
:
:
{
cmp
fmt
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
AtomicU32
AtomicUsize
Ordering
}
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
use
style_traits
:
:
{
CSSPixel
DevicePixel
}
;
pub
struct
Device
{
document
:
*
const
structs
:
:
Document
default_values
:
Arc
<
ComputedValues
>
root_font_size
:
AtomicU32
body_text_color
:
AtomicUsize
used_root_font_size
:
AtomicBool
used_viewport_size
:
AtomicBool
environment
:
CssEnvironment
}
impl
fmt
:
:
Debug
for
Device
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
use
nsstring
:
:
nsCString
;
let
mut
doc_uri
=
nsCString
:
:
new
(
)
;
unsafe
{
bindings
:
:
Gecko_nsIURI_Debug
(
(
*
self
.
document
(
)
)
.
mDocumentURI
.
raw
:
:
<
structs
:
:
nsIURI
>
(
)
&
mut
doc_uri
)
}
;
f
.
debug_struct
(
"
Device
"
)
.
field
(
"
document_url
"
&
doc_uri
)
.
finish
(
)
}
}
unsafe
impl
Sync
for
Device
{
}
unsafe
impl
Send
for
Device
{
}
impl
Device
{
pub
fn
new
(
document
:
*
const
structs
:
:
Document
)
-
>
Self
{
assert
!
(
!
document
.
is_null
(
)
)
;
let
doc
=
unsafe
{
&
*
document
}
;
let
prefs
=
unsafe
{
&
*
bindings
:
:
Gecko_GetPrefSheetPrefs
(
doc
)
}
;
Device
{
document
default_values
:
ComputedValues
:
:
default_values
(
doc
)
root_font_size
:
AtomicU32
:
:
new
(
FONT_MEDIUM_PX
.
to_bits
(
)
)
body_text_color
:
AtomicUsize
:
:
new
(
prefs
.
mDefaultColor
as
usize
)
used_root_font_size
:
AtomicBool
:
:
new
(
false
)
used_viewport_size
:
AtomicBool
:
:
new
(
false
)
environment
:
CssEnvironment
}
}
#
[
inline
]
pub
fn
environment
(
&
self
)
-
>
&
CssEnvironment
{
&
self
.
environment
}
pub
fn
account_for_viewport_rule
(
&
mut
self
_constraints
:
&
ViewportConstraints
)
{
unreachable
!
(
"
Gecko
doesn
'
t
support
viewport
"
)
;
}
pub
fn
animation_name_may_be_referenced
(
&
self
name
:
&
KeyframesName
)
-
>
bool
{
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
false
}
;
unsafe
{
bindings
:
:
Gecko_AnimationNameMayBeReferencedFromStyle
(
pc
name
.
as_atom
(
)
.
as_ptr
(
)
)
}
}
pub
fn
default_computed_values
(
&
self
)
-
>
&
ComputedValues
{
&
self
.
default_values
}
pub
fn
default_computed_values_arc
(
&
self
)
-
>
&
Arc
<
ComputedValues
>
{
&
self
.
default_values
}
pub
fn
root_font_size
(
&
self
)
-
>
Length
{
self
.
used_root_font_size
.
store
(
true
Ordering
:
:
Relaxed
)
;
Length
:
:
new
(
f32
:
:
from_bits
(
self
.
root_font_size
.
load
(
Ordering
:
:
Relaxed
)
)
)
}
pub
fn
set_root_font_size
(
&
self
size
:
Length
)
{
self
.
root_font_size
.
store
(
size
.
px
(
)
.
to_bits
(
)
Ordering
:
:
Relaxed
)
}
pub
fn
set_body_text_color
(
&
self
color
:
RGBA
)
{
self
.
body_text_color
.
store
(
convert_rgba_to_nscolor
(
&
color
)
as
usize
Ordering
:
:
Relaxed
)
}
pub
fn
body_text_color
(
&
self
)
-
>
RGBA
{
convert_nscolor_to_rgba
(
self
.
body_text_color
.
load
(
Ordering
:
:
Relaxed
)
as
u32
)
}
#
[
inline
]
pub
fn
document
(
&
self
)
-
>
&
structs
:
:
Document
{
unsafe
{
&
*
self
.
document
}
}
#
[
inline
]
pub
fn
pres_context
(
&
self
)
-
>
Option
<
&
structs
:
:
nsPresContext
>
{
unsafe
{
self
.
document
(
)
.
mPresShell
.
as_ref
(
)
?
.
mPresContext
.
mRawPtr
.
as_ref
(
)
}
}
#
[
inline
]
pub
fn
pref_sheet_prefs
(
&
self
)
-
>
&
structs
:
:
PreferenceSheet_Prefs
{
unsafe
{
&
*
bindings
:
:
Gecko_GetPrefSheetPrefs
(
self
.
document
(
)
)
}
}
pub
fn
reset_computed_values
(
&
mut
self
)
{
self
.
default_values
=
ComputedValues
:
:
default_values
(
self
.
document
(
)
)
;
}
pub
fn
rebuild_cached_data
(
&
mut
self
)
{
self
.
reset_computed_values
(
)
;
self
.
used_root_font_size
.
store
(
false
Ordering
:
:
Relaxed
)
;
self
.
used_viewport_size
.
store
(
false
Ordering
:
:
Relaxed
)
;
}
pub
fn
used_root_font_size
(
&
self
)
-
>
bool
{
self
.
used_root_font_size
.
load
(
Ordering
:
:
Relaxed
)
}
pub
fn
reset
(
&
mut
self
)
{
self
.
reset_computed_values
(
)
;
}
pub
fn
is_print_preview
(
&
self
)
-
>
bool
{
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
false
}
;
pc
.
mType
=
=
structs
:
:
nsPresContext_nsPresContextType_eContext_PrintPreview
}
pub
fn
media_type
(
&
self
)
-
>
MediaType
{
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
MediaType
:
:
screen
(
)
}
;
let
medium_to_use
=
if
!
pc
.
mMediaEmulationData
.
mMedium
.
mRawPtr
.
is_null
(
)
{
pc
.
mMediaEmulationData
.
mMedium
.
mRawPtr
}
else
{
pc
.
mMedium
as
*
const
structs
:
:
nsAtom
as
*
mut
_
}
;
MediaType
(
CustomIdent
(
unsafe
{
Atom
:
:
from_raw
(
medium_to_use
)
}
)
)
}
fn
page_size_minus_default_margin
(
&
self
pc
:
&
structs
:
:
nsPresContext
)
-
>
Size2D
<
Au
>
{
debug_assert
!
(
pc
.
mIsRootPaginatedDocument
(
)
!
=
0
)
;
let
area
=
&
pc
.
mPageSize
;
let
margin
=
&
pc
.
mDefaultPageMargin
;
let
width
=
area
.
width
-
margin
.
left
-
margin
.
right
;
let
height
=
area
.
height
-
margin
.
top
-
margin
.
bottom
;
Size2D
:
:
new
(
Au
(
cmp
:
:
max
(
width
0
)
)
Au
(
cmp
:
:
max
(
height
0
)
)
)
}
pub
fn
au_viewport_size
(
&
self
)
-
>
Size2D
<
Au
>
{
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
Size2D
:
:
new
(
Au
(
0
)
Au
(
0
)
)
}
;
if
pc
.
mIsRootPaginatedDocument
(
)
!
=
0
{
return
self
.
page_size_minus_default_margin
(
pc
)
;
}
let
area
=
&
pc
.
mVisibleArea
;
Size2D
:
:
new
(
Au
(
area
.
width
)
Au
(
area
.
height
)
)
}
pub
fn
au_viewport_size_for_viewport_unit_resolution
(
&
self
)
-
>
Size2D
<
Au
>
{
self
.
used_viewport_size
.
store
(
true
Ordering
:
:
Relaxed
)
;
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
Size2D
:
:
new
(
Au
(
0
)
Au
(
0
)
)
}
;
if
pc
.
mIsRootPaginatedDocument
(
)
!
=
0
{
return
self
.
page_size_minus_default_margin
(
pc
)
}
let
size
=
&
pc
.
mSizeForViewportUnits
;
Size2D
:
:
new
(
Au
(
size
.
width
)
Au
(
size
.
height
)
)
}
pub
fn
used_viewport_size
(
&
self
)
-
>
bool
{
self
.
used_viewport_size
.
load
(
Ordering
:
:
Relaxed
)
}
pub
fn
device_pixel_ratio
(
&
self
)
-
>
Scale
<
f32
CSSPixel
DevicePixel
>
{
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
Scale
:
:
new
(
1
.
)
}
;
if
pc
.
mMediaEmulationData
.
mDPPX
>
0
.
0
{
return
Scale
:
:
new
(
pc
.
mMediaEmulationData
.
mDPPX
)
;
}
let
au_per_dpx
=
pc
.
mCurAppUnitsPerDevPixel
as
f32
;
let
au_per_px
=
AU_PER_PX
as
f32
;
Scale
:
:
new
(
au_per_px
/
au_per_dpx
)
}
#
[
inline
]
pub
fn
use_document_colors
(
&
self
)
-
>
bool
{
let
doc
=
self
.
document
(
)
;
if
doc
.
mIsBeingUsedAsImage
(
)
{
return
true
;
}
self
.
pref_sheet_prefs
(
)
.
mUseDocumentColors
}
pub
fn
default_background_color
(
&
self
)
-
>
RGBA
{
convert_nscolor_to_rgba
(
self
.
pref_sheet_prefs
(
)
.
mDefaultBackgroundColor
)
}
pub
fn
default_color
(
&
self
)
-
>
RGBA
{
convert_nscolor_to_rgba
(
self
.
pref_sheet_prefs
(
)
.
mDefaultColor
)
}
#
[
inline
]
fn
effective_text_zoom
(
&
self
)
-
>
f32
{
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
1
.
}
;
pc
.
mEffectiveTextZoom
}
#
[
inline
]
pub
fn
zoom_text
(
&
self
size
:
Length
)
-
>
Length
{
size
.
scale_by
(
self
.
effective_text_zoom
(
)
)
}
#
[
inline
]
pub
fn
unzoom_text
(
&
self
size
:
Length
)
-
>
Length
{
size
.
scale_by
(
1
.
/
self
.
effective_text_zoom
(
)
)
}
pub
fn
safe_area_insets
(
&
self
)
-
>
SideOffsets2D
<
f32
CSSPixel
>
{
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
SideOffsets2D
:
:
zero
(
)
}
;
let
mut
top
=
0
.
0
;
let
mut
right
=
0
.
0
;
let
mut
bottom
=
0
.
0
;
let
mut
left
=
0
.
0
;
unsafe
{
bindings
:
:
Gecko_GetSafeAreaInsets
(
pc
&
mut
top
&
mut
right
&
mut
bottom
&
mut
left
)
}
;
SideOffsets2D
:
:
new
(
top
right
bottom
left
)
}
}
