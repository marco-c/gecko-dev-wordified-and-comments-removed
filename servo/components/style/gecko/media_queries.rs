use
crate
:
:
custom_properties
:
:
CssEnvironment
;
use
crate
:
:
gecko
:
:
values
:
:
{
convert_nscolor_to_rgba
convert_rgba_to_nscolor
}
;
use
crate
:
:
gecko_bindings
:
:
bindings
;
use
crate
:
:
gecko_bindings
:
:
structs
;
use
crate
:
:
media_queries
:
:
MediaType
;
use
crate
:
:
properties
:
:
ComputedValues
;
use
crate
:
:
string_cache
:
:
Atom
;
use
crate
:
:
values
:
:
computed
:
:
font
:
:
FontSize
;
use
crate
:
:
values
:
:
{
CustomIdent
KeyframesName
}
;
use
app_units
:
:
Au
;
use
app_units
:
:
AU_PER_PX
;
use
cssparser
:
:
RGBA
;
use
euclid
:
:
default
:
:
Size2D
;
use
euclid
:
:
Scale
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
AtomicIsize
AtomicUsize
Ordering
}
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
use
style_traits
:
:
{
CSSPixel
DevicePixel
}
;
pub
struct
Device
{
document
:
*
const
structs
:
:
Document
default_values
:
Arc
<
ComputedValues
>
root_font_size
:
AtomicIsize
body_text_color
:
AtomicUsize
used_root_font_size
:
AtomicBool
used_viewport_size
:
AtomicBool
environment
:
CssEnvironment
}
impl
fmt
:
:
Debug
for
Device
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
use
nsstring
:
:
nsCString
;
let
mut
doc_uri
=
nsCString
:
:
new
(
)
;
unsafe
{
bindings
:
:
Gecko_nsIURI_Debug
(
(
*
self
.
document
(
)
)
.
mDocumentURI
.
raw
:
:
<
structs
:
:
nsIURI
>
(
)
&
mut
doc_uri
)
}
;
f
.
debug_struct
(
"
Device
"
)
.
field
(
"
document_url
"
&
doc_uri
)
.
finish
(
)
}
}
unsafe
impl
Sync
for
Device
{
}
unsafe
impl
Send
for
Device
{
}
impl
Device
{
pub
fn
new
(
document
:
*
const
structs
:
:
Document
)
-
>
Self
{
assert
!
(
!
document
.
is_null
(
)
)
;
let
doc
=
unsafe
{
&
*
document
}
;
let
prefs
=
unsafe
{
&
*
bindings
:
:
Gecko_GetPrefSheetPrefs
(
doc
)
}
;
Device
{
document
default_values
:
ComputedValues
:
:
default_values
(
doc
)
root_font_size
:
AtomicIsize
:
:
new
(
FontSize
:
:
medium
(
)
.
size
(
)
.
0
as
isize
)
body_text_color
:
AtomicUsize
:
:
new
(
prefs
.
mDefaultColor
as
usize
)
used_root_font_size
:
AtomicBool
:
:
new
(
false
)
used_viewport_size
:
AtomicBool
:
:
new
(
false
)
environment
:
CssEnvironment
}
}
#
[
inline
]
pub
fn
environment
(
&
self
)
-
>
&
CssEnvironment
{
&
self
.
environment
}
pub
fn
account_for_viewport_rule
(
&
mut
self
_constraints
:
&
ViewportConstraints
)
{
unreachable
!
(
"
Gecko
doesn
'
t
support
viewport
"
)
;
}
pub
fn
animation_name_may_be_referenced
(
&
self
name
:
&
KeyframesName
)
-
>
bool
{
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
false
}
;
unsafe
{
bindings
:
:
Gecko_AnimationNameMayBeReferencedFromStyle
(
pc
name
.
as_atom
(
)
.
as_ptr
(
)
)
}
}
pub
fn
default_computed_values
(
&
self
)
-
>
&
ComputedValues
{
&
self
.
default_values
}
pub
fn
default_computed_values_arc
(
&
self
)
-
>
&
Arc
<
ComputedValues
>
{
&
self
.
default_values
}
pub
fn
root_font_size
(
&
self
)
-
>
Au
{
self
.
used_root_font_size
.
store
(
true
Ordering
:
:
Relaxed
)
;
Au
:
:
new
(
self
.
root_font_size
.
load
(
Ordering
:
:
Relaxed
)
as
i32
)
}
pub
fn
set_root_font_size
(
&
self
size
:
Au
)
{
self
.
root_font_size
.
store
(
size
.
0
as
isize
Ordering
:
:
Relaxed
)
}
pub
fn
set_body_text_color
(
&
self
color
:
RGBA
)
{
self
.
body_text_color
.
store
(
convert_rgba_to_nscolor
(
&
color
)
as
usize
Ordering
:
:
Relaxed
)
}
pub
fn
body_text_color
(
&
self
)
-
>
RGBA
{
convert_nscolor_to_rgba
(
self
.
body_text_color
.
load
(
Ordering
:
:
Relaxed
)
as
u32
)
}
#
[
inline
]
pub
fn
document
(
&
self
)
-
>
&
structs
:
:
Document
{
unsafe
{
&
*
self
.
document
}
}
#
[
inline
]
pub
fn
pres_context
(
&
self
)
-
>
Option
<
&
structs
:
:
nsPresContext
>
{
unsafe
{
self
.
document
(
)
.
mPresShell
.
as_ref
(
)
?
.
mPresContext
.
mRawPtr
.
as_ref
(
)
}
}
#
[
inline
]
pub
fn
pref_sheet_prefs
(
&
self
)
-
>
&
structs
:
:
PreferenceSheet_Prefs
{
unsafe
{
&
*
bindings
:
:
Gecko_GetPrefSheetPrefs
(
self
.
document
(
)
)
}
}
pub
fn
reset_computed_values
(
&
mut
self
)
{
self
.
default_values
=
ComputedValues
:
:
default_values
(
self
.
document
(
)
)
;
}
pub
fn
rebuild_cached_data
(
&
mut
self
)
{
self
.
reset_computed_values
(
)
;
self
.
used_root_font_size
.
store
(
false
Ordering
:
:
Relaxed
)
;
self
.
used_viewport_size
.
store
(
false
Ordering
:
:
Relaxed
)
;
}
pub
fn
used_root_font_size
(
&
self
)
-
>
bool
{
self
.
used_root_font_size
.
load
(
Ordering
:
:
Relaxed
)
}
pub
fn
reset
(
&
mut
self
)
{
self
.
reset_computed_values
(
)
;
}
pub
fn
media_type
(
&
self
)
-
>
MediaType
{
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
MediaType
:
:
screen
(
)
}
;
let
medium_to_use
=
if
!
pc
.
mMediaEmulationData
.
mMedium
.
mRawPtr
.
is_null
(
)
{
pc
.
mMediaEmulationData
.
mMedium
.
mRawPtr
}
else
{
pc
.
mMedium
as
*
const
structs
:
:
nsAtom
as
*
mut
_
}
;
MediaType
(
CustomIdent
(
unsafe
{
Atom
:
:
from_raw
(
medium_to_use
)
}
)
)
}
pub
fn
au_viewport_size
(
&
self
)
-
>
Size2D
<
Au
>
{
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
Size2D
:
:
new
(
Au
(
0
)
Au
(
0
)
)
}
;
let
area
=
&
pc
.
mVisibleArea
;
Size2D
:
:
new
(
Au
(
area
.
width
)
Au
(
area
.
height
)
)
}
pub
fn
au_viewport_size_for_viewport_unit_resolution
(
&
self
)
-
>
Size2D
<
Au
>
{
self
.
used_viewport_size
.
store
(
true
Ordering
:
:
Relaxed
)
;
self
.
au_viewport_size
(
)
}
pub
fn
used_viewport_size
(
&
self
)
-
>
bool
{
self
.
used_viewport_size
.
load
(
Ordering
:
:
Relaxed
)
}
pub
fn
device_pixel_ratio
(
&
self
)
-
>
Scale
<
f32
CSSPixel
DevicePixel
>
{
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
Scale
:
:
new
(
1
.
)
}
;
if
pc
.
mMediaEmulationData
.
mDPPX
>
0
.
0
{
return
Scale
:
:
new
(
pc
.
mMediaEmulationData
.
mDPPX
)
;
}
let
au_per_dpx
=
pc
.
mCurAppUnitsPerDevPixel
as
f32
;
let
au_per_px
=
AU_PER_PX
as
f32
;
Scale
:
:
new
(
au_per_px
/
au_per_dpx
)
}
#
[
inline
]
pub
fn
use_document_colors
(
&
self
)
-
>
bool
{
let
doc
=
self
.
document
(
)
;
if
doc
.
mIsBeingUsedAsImage
(
)
{
return
true
;
}
let
document_color_use
=
unsafe
{
structs
:
:
StaticPrefs
:
:
sVarCache_browser_display_document_color_use
}
;
let
prefs
=
self
.
pref_sheet_prefs
(
)
;
match
document_color_use
{
1
=
>
true
2
=
>
prefs
.
mIsChrome
_
=
>
!
prefs
.
mUseAccessibilityTheme
}
}
pub
fn
default_background_color
(
&
self
)
-
>
RGBA
{
convert_nscolor_to_rgba
(
self
.
pref_sheet_prefs
(
)
.
mDefaultBackgroundColor
)
}
#
[
inline
]
fn
effective_text_zoom
(
&
self
)
-
>
f32
{
let
pc
=
match
self
.
pres_context
(
)
{
Some
(
pc
)
=
>
pc
None
=
>
return
1
.
}
;
pc
.
mEffectiveTextZoom
}
#
[
inline
]
pub
fn
zoom_text
(
&
self
size
:
Au
)
-
>
Au
{
size
.
scale_by
(
self
.
effective_text_zoom
(
)
)
}
#
[
inline
]
pub
fn
unzoom_text
(
&
self
size
:
Au
)
-
>
Au
{
size
.
scale_by
(
1
.
/
self
.
effective_text_zoom
(
)
)
}
}
