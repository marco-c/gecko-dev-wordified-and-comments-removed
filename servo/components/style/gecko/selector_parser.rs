use
cssparser
:
:
{
Parser
ToCss
}
;
use
element_state
:
:
ElementState
;
use
gecko_bindings
:
:
structs
:
:
CSSPseudoClassType
;
use
gecko_bindings
:
:
structs
:
:
nsIAtom
;
use
selector_parser
:
:
{
SelectorParser
PseudoElementCascadeType
}
;
use
selectors
:
:
parser
:
:
{
ComplexSelector
SelectorMethods
}
;
use
selectors
:
:
visitor
:
:
SelectorVisitor
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
fmt
;
use
std
:
:
ptr
;
use
string_cache
:
:
{
Atom
Namespace
WeakAtom
WeakNamespace
}
;
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
pub
struct
PseudoElement
(
Atom
bool
)
;
macro_rules
!
each_eager_pseudo
{
(
macro_name
:
ident
atom_macro
:
ident
)
=
>
{
macro_name
!
(
atom_macro
!
(
"
:
after
"
)
0
)
;
macro_name
!
(
atom_macro
!
(
"
:
before
"
)
1
)
;
}
}
pub
const
EAGER_PSEUDO_COUNT
:
usize
=
2
;
impl
PseudoElement
{
#
[
inline
]
pub
fn
eager_index
(
&
self
)
-
>
usize
{
macro_rules
!
case
{
(
atom
:
expr
idx
:
expr
)
=
>
{
if
*
self
.
as_atom
(
)
=
=
atom
{
return
idx
;
}
}
}
each_eager_pseudo
!
(
case
atom
)
;
panic
!
(
"
Not
eager
"
)
}
#
[
inline
]
pub
fn
from_eager_index
(
i
:
usize
)
-
>
Self
{
macro_rules
!
case
{
(
atom
:
expr
idx
:
expr
)
=
>
{
if
i
=
=
idx
{
return
PseudoElement
(
atom
false
)
;
}
}
}
each_eager_pseudo
!
(
case
atom
)
;
panic
!
(
"
Not
eager
"
)
}
#
[
inline
]
pub
fn
as_atom
(
&
self
)
-
>
&
Atom
{
&
self
.
0
}
#
[
inline
]
fn
is_anon_box
(
&
self
)
-
>
bool
{
self
.
1
}
#
[
inline
]
pub
fn
is_before_or_after
(
&
self
)
-
>
bool
{
*
self
.
as_atom
(
)
=
=
atom
!
(
"
:
before
"
)
|
|
*
self
.
as_atom
(
)
=
=
atom
!
(
"
:
after
"
)
}
#
[
inline
]
pub
fn
is_eager
(
&
self
)
-
>
bool
{
macro_rules
!
case
{
(
atom
:
expr
idx
:
expr
)
=
>
{
if
*
self
.
as_atom
(
)
=
=
atom
{
return
true
;
}
}
}
each_eager_pseudo
!
(
case
atom
)
;
return
false
;
}
#
[
inline
]
pub
fn
is_lazy
(
&
self
)
-
>
bool
{
!
self
.
is_eager
(
)
&
&
!
self
.
is_precomputed
(
)
}
#
[
inline
]
pub
fn
is_precomputed
(
&
self
)
-
>
bool
{
self
.
is_anon_box
(
)
}
#
[
inline
]
pub
fn
from_atom_unchecked
(
atom
:
Atom
is_anon_box
:
bool
)
-
>
Self
{
if
cfg
!
(
debug_assertions
)
{
match
Self
:
:
from_atom
(
&
*
atom
true
)
{
Some
(
pseudo
)
=
>
{
assert_eq
!
(
pseudo
.
is_anon_box
(
)
is_anon_box
)
;
return
pseudo
;
}
None
=
>
panic
!
(
"
Unknown
pseudo
:
{
:
?
}
"
atom
)
}
}
PseudoElement
(
atom
is_anon_box
)
}
#
[
inline
]
fn
from_atom
(
atom
:
&
WeakAtom
_in_ua
:
bool
)
-
>
Option
<
Self
>
{
macro_rules
!
pseudo_element
{
(
pseudo_str_with_colon
:
expr
atom
:
expr
is_anon_box
:
expr
)
=
>
{
{
if
atom
=
=
&
*
atom
{
return
Some
(
PseudoElement
(
atom
is_anon_box
)
)
;
}
}
}
}
include
!
(
"
generated
/
gecko_pseudo_element_helper
.
rs
"
)
;
None
}
#
[
inline
]
fn
from_slice
(
s
:
&
str
in_ua_stylesheet
:
bool
)
-
>
Option
<
Self
>
{
use
std
:
:
ascii
:
:
AsciiExt
;
macro_rules
!
pseudo_element
{
(
pseudo_str_with_colon
:
expr
atom
:
expr
is_anon_box
:
expr
)
=
>
{
{
if
!
is_anon_box
|
|
in_ua_stylesheet
{
if
s
.
eq_ignore_ascii_case
(
&
pseudo_str_with_colon
[
1
.
.
]
)
{
return
Some
(
PseudoElement
(
atom
is_anon_box
)
)
}
}
}
}
}
include
!
(
"
generated
/
gecko_pseudo_element_helper
.
rs
"
)
;
None
}
#
[
inline
]
pub
fn
ns_atom_or_null_from_opt
(
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
*
mut
nsIAtom
{
pseudo
.
map
(
|
p
|
p
.
as_atom
(
)
.
as_ptr
(
)
)
.
unwrap_or
(
ptr
:
:
null_mut
(
)
)
}
}
impl
ToCss
for
PseudoElement
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
debug_assert
!
(
self
.
0
.
as_slice
(
)
.
starts_with
(
&
[
b
'
:
'
as
u16
]
)
&
&
!
self
.
0
.
as_slice
(
)
.
starts_with
(
&
[
b
'
:
'
as
u16
b
'
:
'
as
u16
]
)
)
;
try
!
(
dest
.
write_char
(
'
:
'
)
)
;
write
!
(
dest
"
{
}
"
self
.
0
)
}
}
bitflags
!
{
flags
NonTSPseudoClassFlag
:
u8
{
/
/
See
NonTSPseudoClass
:
:
is_internal
(
)
const
PSEUDO_CLASS_INTERNAL
=
0x01
}
}
macro_rules
!
pseudo_class_name
{
(
bare
:
[
(
(
css
:
expr
name
:
ident
gecko_type
:
tt
state
:
tt
flags
:
tt
)
)
*
]
string
:
[
(
(
s_css
:
expr
s_name
:
ident
s_gecko_type
:
tt
s_state
:
tt
s_flags
:
tt
)
)
*
]
)
=
>
{
#
[
doc
=
"
Our
representation
of
a
non
tree
-
structural
pseudo
-
class
.
"
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
pub
enum
NonTSPseudoClass
{
(
#
[
doc
=
css
]
name
)
*
(
#
[
doc
=
s_css
]
s_name
(
Box
<
[
u16
]
>
)
)
*
/
/
/
The
non
-
standard
:
-
moz
-
any
pseudo
-
class
.
/
/
/
/
/
/
TODO
(
emilio
)
:
We
disallow
combinators
and
pseudos
here
so
we
/
/
/
should
use
SimpleSelector
instead
MozAny
(
Box
<
[
ComplexSelector
<
SelectorImpl
>
]
>
)
}
}
}
apply_non_ts_list
!
(
pseudo_class_name
)
;
impl
ToCss
for
NonTSPseudoClass
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
use
cssparser
:
:
CssStringWriter
;
use
fmt
:
:
Write
;
macro_rules
!
pseudo_class_serialize
{
(
bare
:
[
(
(
css
:
expr
name
:
ident
gecko_type
:
tt
state
:
tt
flags
:
tt
)
)
*
]
string
:
[
(
(
s_css
:
expr
s_name
:
ident
s_gecko_type
:
tt
s_state
:
tt
s_flags
:
tt
)
)
*
]
)
=
>
{
match
*
self
{
(
NonTSPseudoClass
:
:
name
=
>
concat
!
(
"
:
"
css
)
)
*
(
NonTSPseudoClass
:
:
s_name
(
ref
s
)
=
>
{
write
!
(
dest
"
:
{
}
(
"
s_css
)
?
;
{
let
mut
css
=
CssStringWriter
:
:
new
(
dest
)
;
css
.
write_str
(
&
String
:
:
from_utf16
(
&
s
)
.
unwrap
(
)
)
?
;
}
return
dest
.
write_str
(
"
)
"
)
}
)
*
NonTSPseudoClass
:
:
MozAny
(
ref
selectors
)
=
>
{
dest
.
write_str
(
"
:
-
moz
-
any
(
"
)
?
;
let
mut
iter
=
selectors
.
iter
(
)
;
let
first
=
iter
.
next
(
)
.
expect
(
"
:
-
moz
-
any
must
have
at
least
1
selector
"
)
;
first
.
to_css
(
dest
)
?
;
for
selector
in
iter
{
dest
.
write_str
(
"
"
)
?
;
selector
.
to_css
(
dest
)
?
;
}
return
dest
.
write_str
(
"
)
"
)
}
}
}
}
let
ser
=
apply_non_ts_list
!
(
pseudo_class_serialize
)
;
dest
.
write_str
(
ser
)
}
}
impl
SelectorMethods
for
NonTSPseudoClass
{
type
Impl
=
SelectorImpl
;
fn
visit
<
V
>
(
&
self
visitor
:
&
mut
V
)
-
>
bool
where
V
:
SelectorVisitor
<
Impl
=
Self
:
:
Impl
>
{
if
let
NonTSPseudoClass
:
:
MozAny
(
ref
selectors
)
=
*
self
{
for
selector
in
selectors
.
iter
(
)
{
if
!
selector
.
visit
(
visitor
)
{
return
false
;
}
}
}
true
}
}
impl
NonTSPseudoClass
{
pub
fn
is_internal
(
&
self
)
-
>
bool
{
macro_rules
!
check_flag
{
(
_
)
=
>
(
false
)
;
(
flags
:
expr
)
=
>
(
flags
.
contains
(
PSEUDO_CLASS_INTERNAL
)
)
;
}
macro_rules
!
pseudo_class_check_internal
{
(
bare
:
[
(
(
css
:
expr
name
:
ident
gecko_type
:
tt
state
:
tt
flags
:
tt
)
)
*
]
string
:
[
(
(
s_css
:
expr
s_name
:
ident
s_gecko_type
:
tt
s_state
:
tt
s_flags
:
tt
)
)
*
]
)
=
>
{
match
*
self
{
(
NonTSPseudoClass
:
:
name
=
>
check_flag
!
(
flags
)
)
*
(
NonTSPseudoClass
:
:
s_name
(
.
.
)
=
>
check_flag
!
(
s_flags
)
)
*
NonTSPseudoClass
:
:
MozAny
(
_
)
=
>
false
}
}
}
apply_non_ts_list
!
(
pseudo_class_check_internal
)
}
pub
fn
state_flag
(
&
self
)
-
>
ElementState
{
macro_rules
!
flag
{
(
_
)
=
>
(
ElementState
:
:
empty
(
)
)
;
(
state
:
ident
)
=
>
(
:
:
element_state
:
:
state
)
;
}
macro_rules
!
pseudo_class_state
{
(
bare
:
[
(
(
css
:
expr
name
:
ident
gecko_type
:
tt
state
:
tt
flags
:
tt
)
)
*
]
string
:
[
(
(
s_css
:
expr
s_name
:
ident
s_gecko_type
:
tt
s_state
:
tt
s_flags
:
tt
)
)
*
]
)
=
>
{
match
*
self
{
(
NonTSPseudoClass
:
:
name
=
>
flag
!
(
state
)
)
*
(
NonTSPseudoClass
:
:
s_name
(
.
.
)
=
>
flag
!
(
s_state
)
)
*
NonTSPseudoClass
:
:
MozAny
(
.
.
)
=
>
ElementState
:
:
empty
(
)
}
}
}
apply_non_ts_list
!
(
pseudo_class_state
)
}
pub
fn
to_gecko_pseudoclasstype
(
&
self
)
-
>
Option
<
CSSPseudoClassType
>
{
macro_rules
!
gecko_type
{
(
_
)
=
>
(
None
)
;
(
gecko_type
:
ident
)
=
>
(
Some
(
:
:
gecko_bindings
:
:
structs
:
:
CSSPseudoClassType
:
:
gecko_type
)
)
;
}
macro_rules
!
pseudo_class_geckotype
{
(
bare
:
[
(
(
css
:
expr
name
:
ident
gecko_type
:
tt
state
:
tt
flags
:
tt
)
)
*
]
string
:
[
(
(
s_css
:
expr
s_name
:
ident
s_gecko_type
:
tt
s_state
:
tt
s_flags
:
tt
)
)
*
]
)
=
>
{
match
*
self
{
(
NonTSPseudoClass
:
:
name
=
>
gecko_type
!
(
gecko_type
)
)
*
(
NonTSPseudoClass
:
:
s_name
(
.
.
)
=
>
gecko_type
!
(
s_gecko_type
)
)
*
NonTSPseudoClass
:
:
MozAny
(
_
)
=
>
gecko_type
!
(
any
)
}
}
}
apply_non_ts_list
!
(
pseudo_class_geckotype
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
pub
struct
SelectorImpl
;
impl
:
:
selectors
:
:
SelectorImpl
for
SelectorImpl
{
type
AttrValue
=
Atom
;
type
Identifier
=
Atom
;
type
ClassName
=
Atom
;
type
LocalName
=
Atom
;
type
NamespacePrefix
=
Atom
;
type
NamespaceUrl
=
Namespace
;
type
BorrowedNamespaceUrl
=
WeakNamespace
;
type
BorrowedLocalName
=
WeakAtom
;
type
PseudoElement
=
PseudoElement
;
type
NonTSPseudoClass
=
NonTSPseudoClass
;
}
impl
<
'
a
>
:
:
selectors
:
:
Parser
for
SelectorParser
<
'
a
>
{
type
Impl
=
SelectorImpl
;
fn
parse_non_ts_pseudo_class
(
&
self
name
:
Cow
<
str
>
)
-
>
Result
<
NonTSPseudoClass
(
)
>
{
macro_rules
!
pseudo_class_parse
{
(
bare
:
[
(
(
css
:
expr
name
:
ident
gecko_type
:
tt
state
:
tt
flags
:
tt
)
)
*
]
string
:
[
(
(
s_css
:
expr
s_name
:
ident
s_gecko_type
:
tt
s_state
:
tt
s_flags
:
tt
)
)
*
]
)
=
>
{
match_ignore_ascii_case
!
{
&
name
(
css
=
>
NonTSPseudoClass
:
:
name
)
*
_
=
>
return
Err
(
(
)
)
}
}
}
let
pseudo_class
=
apply_non_ts_list
!
(
pseudo_class_parse
)
;
if
!
pseudo_class
.
is_internal
(
)
|
|
self
.
in_user_agent_stylesheet
(
)
{
Ok
(
pseudo_class
)
}
else
{
Err
(
(
)
)
}
}
fn
parse_non_ts_functional_pseudo_class
(
&
self
name
:
Cow
<
str
>
parser
:
&
mut
Parser
)
-
>
Result
<
NonTSPseudoClass
(
)
>
{
macro_rules
!
pseudo_class_string_parse
{
(
bare
:
[
(
(
css
:
expr
name
:
ident
gecko_type
:
tt
state
:
tt
flags
:
tt
)
)
*
]
string
:
[
(
(
s_css
:
expr
s_name
:
ident
s_gecko_type
:
tt
s_state
:
tt
s_flags
:
tt
)
)
*
]
)
=
>
{
match_ignore_ascii_case
!
{
&
name
(
s_css
=
>
{
let
name
=
parser
.
expect_ident_or_string
(
)
?
;
/
/
convert
to
null
terminated
utf16
string
/
/
since
that
'
s
what
Gecko
deals
with
let
utf16
:
Vec
<
u16
>
=
name
.
encode_utf16
(
)
.
chain
(
Some
(
0u16
)
)
.
collect
(
)
;
NonTSPseudoClass
:
:
s_name
(
utf16
.
into_boxed_slice
(
)
)
}
)
*
"
-
moz
-
any
"
=
>
{
let
selectors
=
parser
.
parse_comma_separated
(
|
input
|
{
ComplexSelector
:
:
parse
(
self
input
)
}
)
?
;
/
/
Selectors
inside
:
-
moz
-
any
may
not
include
combinators
.
if
selectors
.
iter
(
)
.
flat_map
(
|
x
|
x
.
iter_raw
(
)
)
.
any
(
|
s
|
s
.
is_combinator
(
)
)
{
return
Err
(
(
)
)
}
NonTSPseudoClass
:
:
MozAny
(
selectors
.
into_boxed_slice
(
)
)
}
_
=
>
return
Err
(
(
)
)
}
}
}
let
pseudo_class
=
apply_non_ts_list
!
(
pseudo_class_string_parse
)
;
if
!
pseudo_class
.
is_internal
(
)
|
|
self
.
in_user_agent_stylesheet
(
)
{
Ok
(
pseudo_class
)
}
else
{
Err
(
(
)
)
}
}
fn
parse_pseudo_element
(
&
self
name
:
Cow
<
str
>
)
-
>
Result
<
PseudoElement
(
)
>
{
match
PseudoElement
:
:
from_slice
(
&
name
self
.
in_user_agent_stylesheet
(
)
)
{
Some
(
pseudo
)
=
>
Ok
(
pseudo
)
None
=
>
Err
(
(
)
)
}
}
fn
default_namespace
(
&
self
)
-
>
Option
<
Namespace
>
{
self
.
namespaces
.
default
.
clone
(
)
}
fn
namespace_for_prefix
(
&
self
prefix
:
&
Atom
)
-
>
Option
<
Namespace
>
{
self
.
namespaces
.
prefixes
.
get
(
prefix
)
.
cloned
(
)
}
}
impl
SelectorImpl
{
#
[
inline
]
pub
fn
pseudo_element_cascade_type
(
pseudo
:
&
PseudoElement
)
-
>
PseudoElementCascadeType
{
if
pseudo
.
is_eager
(
)
{
debug_assert
!
(
!
pseudo
.
is_anon_box
(
)
)
;
return
PseudoElementCascadeType
:
:
Eager
}
if
pseudo
.
is_anon_box
(
)
{
return
PseudoElementCascadeType
:
:
Precomputed
}
PseudoElementCascadeType
:
:
Lazy
}
#
[
inline
]
pub
fn
each_eagerly_cascaded_pseudo_element
<
F
>
(
mut
fun
:
F
)
where
F
:
FnMut
(
PseudoElement
)
{
macro_rules
!
case
{
(
atom
:
expr
idx
:
expr
)
=
>
{
fun
(
PseudoElement
(
atom
false
)
)
;
}
}
each_eager_pseudo
!
(
case
atom
)
;
}
#
[
inline
]
pub
fn
each_pseudo_element
<
F
>
(
mut
fun
:
F
)
where
F
:
FnMut
(
PseudoElement
)
{
macro_rules
!
pseudo_element
{
(
pseudo_str_with_colon
:
expr
atom
:
expr
is_anon_box
:
expr
)
=
>
{
{
fun
(
PseudoElement
(
atom
is_anon_box
)
)
;
}
}
}
include
!
(
"
generated
/
gecko_pseudo_element_helper
.
rs
"
)
}
#
[
inline
]
pub
fn
pseudo_class_state_flag
(
pc
:
&
NonTSPseudoClass
)
-
>
ElementState
{
pc
.
state_flag
(
)
}
}
