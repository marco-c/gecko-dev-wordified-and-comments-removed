use
gecko_bindings
:
:
structs
:
:
nsAtom
;
use
selectors
:
:
attr
:
:
CaseSensitivity
;
use
std
:
:
{
ptr
slice
}
;
use
string_cache
:
:
Atom
;
pub
type
ClassOrClassList
<
T
>
=
unsafe
extern
"
C
"
fn
(
T
*
mut
*
mut
nsAtom
*
mut
*
mut
*
mut
nsAtom
)
-
>
u32
;
pub
type
HasClass
<
T
>
=
unsafe
extern
"
C
"
fn
(
T
*
mut
nsAtom
bool
)
-
>
bool
;
#
[
inline
(
always
)
]
pub
fn
has_class
<
T
>
(
item
:
T
name
:
&
Atom
case_sensitivity
:
CaseSensitivity
getter
:
HasClass
<
T
>
)
-
>
bool
{
let
ignore_case
=
match
case_sensitivity
{
CaseSensitivity
:
:
CaseSensitive
=
>
false
CaseSensitivity
:
:
AsciiCaseInsensitive
=
>
true
}
;
unsafe
{
getter
(
item
name
.
as_ptr
(
)
ignore_case
)
}
}
pub
fn
each_class
<
F
T
>
(
item
:
T
mut
callback
:
F
getter
:
ClassOrClassList
<
T
>
)
where
F
:
FnMut
(
&
Atom
)
{
unsafe
{
let
mut
class
:
*
mut
nsAtom
=
ptr
:
:
null_mut
(
)
;
let
mut
list
:
*
mut
*
mut
nsAtom
=
ptr
:
:
null_mut
(
)
;
let
length
=
getter
(
item
&
mut
class
&
mut
list
)
;
match
length
{
0
=
>
{
}
1
=
>
Atom
:
:
with
(
class
callback
)
n
=
>
{
let
classes
=
slice
:
:
from_raw_parts
(
list
n
as
usize
)
;
for
c
in
classes
{
Atom
:
:
with
(
*
c
&
mut
callback
)
}
}
}
}
}
