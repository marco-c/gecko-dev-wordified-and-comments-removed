use
crate
:
:
derives
:
:
*
;
use
crate
:
:
dom
:
:
TElement
;
use
crate
:
:
gecko_bindings
:
:
bindings
;
use
crate
:
:
gecko_bindings
:
:
structs
:
:
{
self
ServoStyleSetSizes
StyleSheet
as
DomStyleSheet
StyleSheetInfo
}
;
use
crate
:
:
media_queries
:
:
{
Device
MediaList
}
;
use
crate
:
:
properties
:
:
ComputedValues
;
use
crate
:
:
selector_parser
:
:
SnapshotMap
;
use
crate
:
:
shared_lock
:
:
{
SharedRwLockReadGuard
StylesheetGuards
}
;
use
crate
:
:
stylesheets
:
:
scope_rule
:
:
ImplicitScopeRoot
;
use
crate
:
:
stylesheets
:
:
{
StylesheetContents
StylesheetInDocument
}
;
use
crate
:
:
stylist
:
:
{
DocumentFlushResult
Stylist
}
;
use
atomic_refcell
:
:
{
AtomicRef
AtomicRefCell
AtomicRefMut
}
;
use
malloc_size_of
:
:
MallocSizeOfOps
;
use
selectors
:
:
Element
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
;
use
super
:
:
wrapper
:
:
GeckoElement
;
#
[
derive
(
Eq
PartialEq
)
]
pub
struct
GeckoStyleSheet
(
*
const
DomStyleSheet
)
;
unsafe
impl
Send
for
GeckoStyleSheet
{
}
unsafe
impl
Sync
for
GeckoStyleSheet
{
}
impl
fmt
:
:
Debug
for
GeckoStyleSheet
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
contents
=
self
.
raw_contents
(
)
;
formatter
.
debug_struct
(
"
GeckoStyleSheet
"
)
.
field
(
"
origin
"
&
contents
.
origin
)
.
field
(
"
url_data
"
&
contents
.
url_data
)
.
finish
(
)
}
}
impl
GeckoStyleSheet
{
#
[
inline
]
pub
unsafe
fn
new
(
s
:
*
const
DomStyleSheet
)
-
>
Self
{
debug_assert
!
(
!
s
.
is_null
(
)
)
;
bindings
:
:
Gecko_StyleSheet_AddRef
(
s
)
;
Self
:
:
from_addrefed
(
s
)
}
#
[
inline
]
pub
unsafe
fn
from_addrefed
(
s
:
*
const
DomStyleSheet
)
-
>
Self
{
assert
!
(
!
s
.
is_null
(
)
)
;
GeckoStyleSheet
(
s
)
}
#
[
inline
]
pub
fn
hack_is_null
(
&
self
)
-
>
bool
{
self
.
0
.
is_null
(
)
}
pub
fn
raw
(
&
self
)
-
>
&
DomStyleSheet
{
unsafe
{
&
*
self
.
0
}
}
fn
inner
(
&
self
)
-
>
&
StyleSheetInfo
{
unsafe
{
&
*
(
self
.
raw
(
)
.
mInner
as
*
const
StyleSheetInfo
)
}
}
fn
raw_contents
(
&
self
)
-
>
&
StylesheetContents
{
debug_assert
!
(
!
self
.
inner
(
)
.
mContents
.
mRawPtr
.
is_null
(
)
)
;
unsafe
{
&
*
self
.
inner
(
)
.
mContents
.
mRawPtr
}
}
}
impl
Drop
for
GeckoStyleSheet
{
fn
drop
(
&
mut
self
)
{
unsafe
{
bindings
:
:
Gecko_StyleSheet_Release
(
self
.
0
)
}
;
}
}
impl
Clone
for
GeckoStyleSheet
{
fn
clone
(
&
self
)
-
>
Self
{
unsafe
{
bindings
:
:
Gecko_StyleSheet_AddRef
(
self
.
0
)
}
;
GeckoStyleSheet
(
self
.
0
)
}
}
impl
StylesheetInDocument
for
GeckoStyleSheet
{
fn
media
<
'
a
>
(
&
'
a
self
guard
:
&
'
a
SharedRwLockReadGuard
)
-
>
Option
<
&
'
a
MediaList
>
{
use
crate
:
:
gecko_bindings
:
:
structs
:
:
mozilla
:
:
dom
:
:
MediaList
as
DomMediaList
;
unsafe
{
let
dom_media_list
=
self
.
raw
(
)
.
mMedia
.
mRawPtr
as
*
const
DomMediaList
;
if
dom_media_list
.
is_null
(
)
{
return
None
;
}
let
list
=
&
*
(
*
dom_media_list
)
.
mRawList
.
mRawPtr
;
Some
(
list
.
read_with
(
guard
)
)
}
}
#
[
inline
]
fn
enabled
(
&
self
)
-
>
bool
{
true
}
#
[
inline
]
fn
contents
<
'
a
>
(
&
'
a
self
_
:
&
'
a
SharedRwLockReadGuard
)
-
>
&
'
a
StylesheetContents
{
self
.
raw_contents
(
)
}
fn
implicit_scope_root
(
&
self
)
-
>
Option
<
ImplicitScopeRoot
>
{
unsafe
{
let
result
=
bindings
:
:
Gecko_StyleSheet_ImplicitScopeRoot
(
self
.
0
)
;
if
result
.
mRoot
.
is_null
(
)
{
return
if
result
.
mConstructed
{
Some
(
ImplicitScopeRoot
:
:
Constructed
)
}
else
{
None
}
;
}
let
root
=
GeckoElement
(
result
.
mRoot
.
as_ref
(
)
.
unwrap
(
)
)
.
opaque
(
)
;
Some
(
if
!
result
.
mHost
.
is_null
(
)
{
let
host
=
GeckoElement
(
result
.
mHost
.
as_ref
(
)
.
unwrap
(
)
)
.
opaque
(
)
;
if
host
=
=
root
{
ImplicitScopeRoot
:
:
ShadowHost
(
root
)
}
else
{
ImplicitScopeRoot
:
:
InShadowTree
(
root
)
}
}
else
{
ImplicitScopeRoot
:
:
InLightTree
(
root
)
}
)
}
}
}
pub
struct
PerDocumentStyleDataImpl
{
pub
stylist
:
Stylist
pub
undisplayed_style_cache
:
crate
:
:
traversal
:
:
UndisplayedStyleCache
pub
undisplayed_style_cache_generation
:
u64
}
#
[
derive
(
Deref
)
]
pub
struct
PerDocumentStyleData
(
AtomicRefCell
<
PerDocumentStyleDataImpl
>
)
;
impl
PerDocumentStyleData
{
pub
fn
new
(
document
:
*
const
structs
:
:
Document
)
-
>
Self
{
let
device
=
Device
:
:
new
(
document
)
;
let
quirks_mode
=
device
.
document
(
)
.
mCompatMode
;
PerDocumentStyleData
(
AtomicRefCell
:
:
new
(
PerDocumentStyleDataImpl
{
stylist
:
Stylist
:
:
new
(
device
quirks_mode
.
into
(
)
)
undisplayed_style_cache
:
Default
:
:
default
(
)
undisplayed_style_cache_generation
:
0
}
)
)
}
pub
fn
borrow
(
&
self
)
-
>
AtomicRef
<
'
_
PerDocumentStyleDataImpl
>
{
self
.
0
.
borrow
(
)
}
pub
fn
borrow_mut
(
&
self
)
-
>
AtomicRefMut
<
'
_
PerDocumentStyleDataImpl
>
{
self
.
0
.
borrow_mut
(
)
}
}
impl
PerDocumentStyleDataImpl
{
pub
fn
flush_stylesheets
<
E
>
(
&
mut
self
guard
:
&
SharedRwLockReadGuard
document_element
:
Option
<
E
>
snapshots
:
Option
<
&
SnapshotMap
>
)
-
>
DocumentFlushResult
where
E
:
TElement
{
self
.
stylist
.
flush
(
&
StylesheetGuards
:
:
same
(
guard
)
document_element
snapshots
)
}
pub
fn
default_computed_values
(
&
self
)
-
>
&
Arc
<
ComputedValues
>
{
self
.
stylist
.
device
(
)
.
default_computed_values_arc
(
)
}
pub
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
stylist
.
add_size_of
(
ops
sizes
)
;
}
}
pub
type
AuthorStyles
=
crate
:
:
author_styles
:
:
AuthorStyles
<
GeckoStyleSheet
>
;
