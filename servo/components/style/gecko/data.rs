use
atomic_refcell
:
:
{
AtomicRef
AtomicRefCell
AtomicRefMut
}
;
use
context
:
:
QuirksMode
;
use
dom
:
:
TElement
;
use
gecko_bindings
:
:
bindings
:
:
{
self
RawServoStyleSet
}
;
use
gecko_bindings
:
:
structs
:
:
{
self
RawGeckoPresContextOwned
ServoStyleSetSizes
StyleSheet
as
DomStyleSheet
}
;
use
gecko_bindings
:
:
structs
:
:
{
StyleSheetInfo
nsIDocument
}
;
use
gecko_bindings
:
:
sugar
:
:
ownership
:
:
{
HasArcFFI
HasBoxFFI
HasFFI
HasSimpleFFI
}
;
use
invalidation
:
:
media_queries
:
:
{
MediaListKey
ToMediaListKey
}
;
use
malloc_size_of
:
:
MallocSizeOfOps
;
use
media_queries
:
:
{
Device
MediaList
}
;
use
properties
:
:
ComputedValues
;
use
selector_parser
:
:
SnapshotMap
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
;
use
shared_lock
:
:
{
Locked
SharedRwLockReadGuard
StylesheetGuards
}
;
use
stylesheets
:
:
{
CssRule
Origin
StylesheetContents
StylesheetInDocument
}
;
use
stylist
:
:
Stylist
;
#
[
derive
(
Eq
PartialEq
)
]
pub
struct
GeckoStyleSheet
(
*
const
DomStyleSheet
)
;
impl
fmt
:
:
Debug
for
GeckoStyleSheet
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
contents
=
self
.
contents
(
)
;
formatter
.
debug_struct
(
"
GeckoStyleSheet
"
)
.
field
(
"
origin
"
&
contents
.
origin
)
.
field
(
"
url_data
"
&
*
contents
.
url_data
.
read
(
)
)
.
finish
(
)
}
}
impl
ToMediaListKey
for
:
:
gecko
:
:
data
:
:
GeckoStyleSheet
{
fn
to_media_list_key
(
&
self
)
-
>
MediaListKey
{
use
std
:
:
mem
;
unsafe
{
MediaListKey
:
:
from_raw
(
mem
:
:
transmute
(
self
.
0
)
)
}
}
}
impl
GeckoStyleSheet
{
#
[
inline
]
pub
unsafe
fn
new
(
s
:
*
const
DomStyleSheet
)
-
>
Self
{
debug_assert
!
(
!
s
.
is_null
(
)
)
;
bindings
:
:
Gecko_StyleSheet_AddRef
(
s
)
;
Self
:
:
from_addrefed
(
s
)
}
#
[
inline
]
pub
unsafe
fn
from_addrefed
(
s
:
*
const
DomStyleSheet
)
-
>
Self
{
debug_assert
!
(
!
s
.
is_null
(
)
)
;
GeckoStyleSheet
(
s
)
}
pub
fn
raw
(
&
self
)
-
>
&
DomStyleSheet
{
unsafe
{
&
*
self
.
0
}
}
fn
inner
(
&
self
)
-
>
&
StyleSheetInfo
{
unsafe
{
&
*
(
self
.
raw
(
)
.
mInner
as
*
const
StyleSheetInfo
)
}
}
pub
fn
contents
(
&
self
)
-
>
&
StylesheetContents
{
debug_assert
!
(
!
self
.
inner
(
)
.
mContents
.
mRawPtr
.
is_null
(
)
)
;
unsafe
{
let
contents
=
(
&
*
*
StylesheetContents
:
:
as_arc
(
&
&
*
self
.
inner
(
)
.
mContents
.
mRawPtr
)
)
as
*
const
_
;
&
*
contents
}
}
}
impl
Drop
for
GeckoStyleSheet
{
fn
drop
(
&
mut
self
)
{
unsafe
{
bindings
:
:
Gecko_StyleSheet_Release
(
self
.
0
)
}
;
}
}
impl
Clone
for
GeckoStyleSheet
{
fn
clone
(
&
self
)
-
>
Self
{
unsafe
{
bindings
:
:
Gecko_StyleSheet_AddRef
(
self
.
0
)
}
;
GeckoStyleSheet
(
self
.
0
)
}
}
impl
StylesheetInDocument
for
GeckoStyleSheet
{
fn
origin
(
&
self
_guard
:
&
SharedRwLockReadGuard
)
-
>
Origin
{
self
.
contents
(
)
.
origin
}
fn
quirks_mode
(
&
self
_guard
:
&
SharedRwLockReadGuard
)
-
>
QuirksMode
{
self
.
contents
(
)
.
quirks_mode
}
fn
media
<
'
a
>
(
&
'
a
self
guard
:
&
'
a
SharedRwLockReadGuard
)
-
>
Option
<
&
'
a
MediaList
>
{
use
gecko_bindings
:
:
structs
:
:
mozilla
:
:
dom
:
:
MediaList
as
DomMediaList
;
use
std
:
:
mem
;
unsafe
{
let
dom_media_list
=
self
.
raw
(
)
.
mMedia
.
mRawPtr
as
*
const
DomMediaList
;
if
dom_media_list
.
is_null
(
)
{
return
None
;
}
let
raw_list
=
&
*
(
*
dom_media_list
)
.
mRawList
.
mRawPtr
;
let
list
=
Locked
:
:
<
MediaList
>
:
:
as_arc
(
mem
:
:
transmute
(
&
raw_list
)
)
;
Some
(
list
.
read_with
(
guard
)
)
}
}
fn
enabled
(
&
self
)
-
>
bool
{
true
}
#
[
inline
]
fn
rules
<
'
a
'
b
:
'
a
>
(
&
'
a
self
guard
:
&
'
b
SharedRwLockReadGuard
)
-
>
&
'
a
[
CssRule
]
{
self
.
contents
(
)
.
rules
(
guard
)
}
}
pub
struct
PerDocumentStyleDataImpl
{
pub
stylist
:
Stylist
}
pub
struct
PerDocumentStyleData
(
AtomicRefCell
<
PerDocumentStyleDataImpl
>
)
;
impl
PerDocumentStyleData
{
pub
fn
new
(
pres_context
:
RawGeckoPresContextOwned
)
-
>
Self
{
let
device
=
Device
:
:
new
(
pres_context
)
;
let
quirks_mode
=
unsafe
{
(
*
device
.
pres_context
(
)
.
mDocument
.
raw
:
:
<
nsIDocument
>
(
)
)
.
mCompatMode
}
;
PerDocumentStyleData
(
AtomicRefCell
:
:
new
(
PerDocumentStyleDataImpl
{
stylist
:
Stylist
:
:
new
(
device
quirks_mode
.
into
(
)
)
}
)
)
}
pub
fn
borrow
(
&
self
)
-
>
AtomicRef
<
PerDocumentStyleDataImpl
>
{
self
.
0
.
borrow
(
)
}
pub
fn
borrow_mut
(
&
self
)
-
>
AtomicRefMut
<
PerDocumentStyleDataImpl
>
{
self
.
0
.
borrow_mut
(
)
}
}
impl
PerDocumentStyleDataImpl
{
pub
fn
flush_stylesheets
<
E
>
(
&
mut
self
guard
:
&
SharedRwLockReadGuard
document_element
:
Option
<
E
>
snapshots
:
Option
<
&
SnapshotMap
>
)
-
>
bool
where
E
:
TElement
{
self
.
stylist
.
flush
(
&
StylesheetGuards
:
:
same
(
guard
)
document_element
snapshots
)
}
fn
is_private_browsing_enabled
(
&
self
)
-
>
bool
{
let
doc
=
self
.
stylist
.
device
(
)
.
pres_context
(
)
.
mDocument
.
raw
:
:
<
nsIDocument
>
(
)
;
unsafe
{
bindings
:
:
Gecko_IsPrivateBrowsingEnabled
(
doc
)
}
}
fn
is_being_used_as_an_image
(
&
self
)
-
>
bool
{
let
doc
=
self
.
stylist
.
device
(
)
.
pres_context
(
)
.
mDocument
.
raw
:
:
<
nsIDocument
>
(
)
;
unsafe
{
(
*
doc
)
.
mIsBeingUsedAsImage
(
)
}
}
pub
fn
default_computed_values
(
&
self
)
-
>
&
Arc
<
ComputedValues
>
{
self
.
stylist
.
device
(
)
.
default_computed_values_arc
(
)
}
fn
visited_links_enabled
(
&
self
)
-
>
bool
{
unsafe
{
structs
:
:
StaticPrefs_sVarCache_layout_css_visited_links_enabled
}
}
pub
fn
visited_styles_enabled
(
&
self
)
-
>
bool
{
if
!
self
.
visited_links_enabled
(
)
{
return
false
;
}
if
self
.
is_private_browsing_enabled
(
)
{
return
false
;
}
if
self
.
is_being_used_as_an_image
(
)
{
return
false
;
}
true
}
pub
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
stylist
.
add_size_of
(
ops
sizes
)
;
}
}
unsafe
impl
HasFFI
for
PerDocumentStyleData
{
type
FFIType
=
RawServoStyleSet
;
}
unsafe
impl
HasSimpleFFI
for
PerDocumentStyleData
{
}
unsafe
impl
HasBoxFFI
for
PerDocumentStyleData
{
}
