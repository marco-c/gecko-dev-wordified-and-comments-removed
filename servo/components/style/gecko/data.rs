use
Atom
;
use
atomic_refcell
:
:
{
AtomicRef
AtomicRefCell
AtomicRefMut
}
;
use
dom
:
:
TElement
;
use
fnv
:
:
FnvHashMap
;
use
gecko
:
:
rules
:
:
{
CounterStyleRule
FontFaceRule
}
;
use
gecko
:
:
wrapper
:
:
GeckoElement
;
use
gecko_bindings
:
:
bindings
:
:
RawServoStyleSet
;
use
gecko_bindings
:
:
structs
:
:
RawGeckoPresContextOwned
;
use
gecko_bindings
:
:
structs
:
:
nsIDocument
;
use
gecko_bindings
:
:
sugar
:
:
ownership
:
:
{
HasBoxFFI
HasFFI
HasSimpleFFI
}
;
use
media_queries
:
:
Device
;
use
properties
:
:
ComputedValues
;
use
shared_lock
:
:
{
Locked
StylesheetGuards
SharedRwLockReadGuard
}
;
use
stylearc
:
:
Arc
;
use
stylesheet_set
:
:
StylesheetSet
;
use
stylesheets
:
:
Origin
;
use
stylist
:
:
{
ExtraStyleData
Stylist
}
;
pub
struct
PerDocumentStyleDataImpl
{
pub
stylist
:
Stylist
pub
stylesheets
:
StylesheetSet
pub
font_faces
:
Vec
<
(
Arc
<
Locked
<
FontFaceRule
>
>
Origin
)
>
pub
counter_styles
:
FnvHashMap
<
Atom
Arc
<
Locked
<
CounterStyleRule
>
>
>
}
pub
struct
PerDocumentStyleData
(
AtomicRefCell
<
PerDocumentStyleDataImpl
>
)
;
impl
PerDocumentStyleData
{
pub
fn
new
(
pres_context
:
RawGeckoPresContextOwned
)
-
>
Self
{
let
device
=
Device
:
:
new
(
pres_context
)
;
let
quirks_mode
=
unsafe
{
(
*
(
*
device
.
pres_context
)
.
mDocument
.
raw
:
:
<
nsIDocument
>
(
)
)
.
mCompatMode
}
;
PerDocumentStyleData
(
AtomicRefCell
:
:
new
(
PerDocumentStyleDataImpl
{
stylist
:
Stylist
:
:
new
(
device
quirks_mode
.
into
(
)
)
stylesheets
:
StylesheetSet
:
:
new
(
)
font_faces
:
vec
!
[
]
counter_styles
:
FnvHashMap
:
:
default
(
)
}
)
)
}
pub
fn
borrow
(
&
self
)
-
>
AtomicRef
<
PerDocumentStyleDataImpl
>
{
self
.
0
.
borrow
(
)
}
pub
fn
borrow_mut
(
&
self
)
-
>
AtomicRefMut
<
PerDocumentStyleDataImpl
>
{
self
.
0
.
borrow_mut
(
)
}
}
impl
PerDocumentStyleDataImpl
{
pub
fn
reset_device
(
&
mut
self
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylist
.
device_mut
(
)
.
reset
(
)
;
self
.
stylesheets
.
force_dirty
(
)
;
self
.
flush_stylesheets
:
:
<
GeckoElement
>
(
guard
None
)
;
}
pub
fn
flush_stylesheets
<
E
>
(
&
mut
self
guard
:
&
SharedRwLockReadGuard
document_element
:
Option
<
E
>
)
where
E
:
TElement
{
if
!
self
.
stylesheets
.
has_changed
(
)
{
return
;
}
let
mut
extra_data
=
ExtraStyleData
{
font_faces
:
&
mut
self
.
font_faces
counter_styles
:
&
mut
self
.
counter_styles
}
;
let
author_style_disabled
=
self
.
stylesheets
.
author_style_disabled
(
)
;
self
.
stylist
.
clear
(
)
;
let
iter
=
self
.
stylesheets
.
flush
(
document_element
)
;
self
.
stylist
.
rebuild
(
iter
&
StylesheetGuards
:
:
same
(
guard
)
None
true
author_style_disabled
&
mut
extra_data
)
;
}
pub
fn
default_computed_values
(
&
self
)
-
>
&
Arc
<
ComputedValues
>
{
self
.
stylist
.
device
(
)
.
default_computed_values_arc
(
)
}
pub
fn
clear_stylist
(
&
mut
self
)
{
self
.
stylist
.
clear
(
)
;
}
}
unsafe
impl
HasFFI
for
PerDocumentStyleData
{
type
FFIType
=
RawServoStyleSet
;
}
unsafe
impl
HasSimpleFFI
for
PerDocumentStyleData
{
}
unsafe
impl
HasBoxFFI
for
PerDocumentStyleData
{
}
