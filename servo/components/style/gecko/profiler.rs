use
crate
:
:
gecko_bindings
:
:
structs
;
pub
enum
ProfilerLabel
{
Style
Parse
}
#
[
cfg
(
feature
=
"
gecko_profiler
"
)
]
pub
struct
AutoProfilerLabel
<
'
a
>
(
&
'
a
mut
structs
:
:
AutoProfilerLabel
)
;
#
[
cfg
(
feature
=
"
gecko_profiler
"
)
]
impl
<
'
a
>
AutoProfilerLabel
<
'
a
>
{
#
[
inline
]
pub
unsafe
fn
new
(
label
:
&
mut
structs
:
:
AutoProfilerLabel
label_type
:
ProfilerLabel
)
-
>
AutoProfilerLabel
{
let
category_pair
=
match
label_type
{
ProfilerLabel
:
:
Style
=
>
structs
:
:
JS
:
:
ProfilingCategoryPair_LAYOUT_StyleComputation
ProfilerLabel
:
:
Parse
=
>
structs
:
:
JS
:
:
ProfilingCategoryPair_LAYOUT_CSSParsing
}
;
structs
:
:
Gecko_Construct_AutoProfilerLabel
(
label
category_pair
)
;
AutoProfilerLabel
(
label
)
}
}
#
[
cfg
(
feature
=
"
gecko_profiler
"
)
]
impl
<
'
a
>
Drop
for
AutoProfilerLabel
<
'
a
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
unsafe
{
structs
:
:
Gecko_Destroy_AutoProfilerLabel
(
self
.
0
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko_profiler
"
)
]
#
[
inline
]
pub
fn
profiler_is_active
(
)
-
>
bool
{
use
self
:
:
structs
:
:
profiler
:
:
detail
;
use
std
:
:
mem
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicU32
Ordering
}
;
let
active_and_features
:
&
AtomicU32
=
unsafe
{
mem
:
:
transmute
(
&
detail
:
:
RacyFeatures_sActiveAndFeatures
)
}
;
(
active_and_features
.
load
(
Ordering
:
:
Relaxed
)
&
detail
:
:
RacyFeatures_Active
)
!
=
0
}
#
[
cfg
(
not
(
feature
=
"
gecko_profiler
"
)
)
]
#
[
inline
]
pub
fn
profiler_is_active
(
)
-
>
bool
{
false
}
