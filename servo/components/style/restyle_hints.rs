use
attr
:
:
{
AttrIdentifier
AttrValue
}
;
use
element_state
:
:
*
;
use
selector_impl
:
:
{
NonTSPseudoClass
ServoSelectorImpl
}
;
use
selectors
:
:
Element
;
use
selectors
:
:
matching
:
:
matches_compound_selector
;
use
selectors
:
:
parser
:
:
{
AttrSelector
Combinator
CompoundSelector
NamespaceConstraint
SimpleSelector
}
;
use
std
:
:
clone
:
:
Clone
;
use
std
:
:
sync
:
:
Arc
;
use
string_cache
:
:
{
Atom
Namespace
}
;
bitflags
!
{
flags
RestyleHint
:
u8
{
#
[
doc
=
"
Rerun
selector
matching
on
the
element
.
"
]
const
RESTYLE_SELF
=
0x01
#
[
doc
=
"
Rerun
selector
matching
on
all
of
the
element
'
s
descendants
.
"
]
/
/
NB
:
In
Gecko
we
have
RESTYLE_SUBTREE
which
is
inclusive
of
self
but
heycam
isn
'
t
aware
/
/
of
a
good
reason
for
that
.
const
RESTYLE_DESCENDANTS
=
0x02
#
[
doc
=
"
Rerun
selector
matching
on
all
later
siblings
of
the
element
and
all
of
their
descendants
.
"
]
const
RESTYLE_LATER_SIBLINGS
=
0x04
}
}
#
[
derive
(
HeapSizeOf
Clone
)
]
pub
struct
ElementSnapshot
{
pub
state
:
Option
<
ElementState
>
pub
attrs
:
Option
<
Vec
<
(
AttrIdentifier
AttrValue
)
>
>
}
impl
ElementSnapshot
{
pub
fn
new
(
)
-
>
ElementSnapshot
{
EMPTY_SNAPSHOT
.
clone
(
)
}
pub
fn
get_attr
(
&
self
namespace
:
&
Namespace
name
:
&
Atom
)
-
>
Option
<
&
AttrValue
>
{
self
.
attrs
.
as_ref
(
)
.
unwrap
(
)
.
iter
(
)
.
find
(
|
&
&
(
ref
ident
_
)
|
ident
.
local_name
=
=
*
name
&
&
ident
.
namespace
=
=
*
namespace
)
.
map
(
|
&
(
_
ref
v
)
|
v
)
}
pub
fn
get_attr_ignore_ns
(
&
self
name
:
&
Atom
)
-
>
Option
<
&
AttrValue
>
{
self
.
attrs
.
as_ref
(
)
.
unwrap
(
)
.
iter
(
)
.
find
(
|
&
&
(
ref
ident
_
)
|
ident
.
local_name
=
=
*
name
)
.
map
(
|
&
(
_
ref
v
)
|
v
)
}
}
static
EMPTY_SNAPSHOT
:
ElementSnapshot
=
ElementSnapshot
{
state
:
None
attrs
:
None
}
;
struct
ElementWrapper
<
'
a
E
>
where
E
:
Element
{
element
:
E
snapshot
:
&
'
a
ElementSnapshot
}
impl
<
'
a
E
>
ElementWrapper
<
'
a
E
>
where
E
:
Element
{
pub
fn
new
(
el
:
E
)
-
>
ElementWrapper
<
'
a
E
>
{
ElementWrapper
{
element
:
el
snapshot
:
&
EMPTY_SNAPSHOT
}
}
pub
fn
new_with_snapshot
(
el
:
E
snapshot
:
&
'
a
ElementSnapshot
)
-
>
ElementWrapper
<
'
a
E
>
{
ElementWrapper
{
element
:
el
snapshot
:
snapshot
}
}
}
impl
<
'
a
E
>
Element
for
ElementWrapper
<
'
a
E
>
where
E
:
Element
<
Impl
=
ServoSelectorImpl
>
{
type
Impl
=
E
:
:
Impl
;
fn
match_non_ts_pseudo_class
(
&
self
pseudo_class
:
NonTSPseudoClass
)
-
>
bool
{
let
flag
=
pseudo_class
.
state_flag
(
)
;
if
flag
=
=
ElementState
:
:
empty
(
)
{
self
.
element
.
match_non_ts_pseudo_class
(
pseudo_class
)
}
else
{
match
self
.
snapshot
.
state
{
Some
(
s
)
=
>
s
.
contains
(
pseudo_class
.
state_flag
(
)
)
None
=
>
self
.
element
.
match_non_ts_pseudo_class
(
pseudo_class
)
}
}
}
fn
parent_element
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
parent_element
(
)
.
map
(
ElementWrapper
:
:
new
)
}
fn
first_child_element
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
first_child_element
(
)
.
map
(
ElementWrapper
:
:
new
)
}
fn
last_child_element
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
last_child_element
(
)
.
map
(
ElementWrapper
:
:
new
)
}
fn
prev_sibling_element
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
prev_sibling_element
(
)
.
map
(
ElementWrapper
:
:
new
)
}
fn
next_sibling_element
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
next_sibling_element
(
)
.
map
(
ElementWrapper
:
:
new
)
}
fn
is_html_element_in_html_document
(
&
self
)
-
>
bool
{
self
.
element
.
is_html_element_in_html_document
(
)
}
fn
get_local_name
(
&
self
)
-
>
&
Atom
{
self
.
element
.
get_local_name
(
)
}
fn
get_namespace
<
'
b
>
(
&
self
)
-
>
&
Namespace
{
self
.
element
.
get_namespace
(
)
}
fn
get_id
(
&
self
)
-
>
Option
<
Atom
>
{
match
self
.
snapshot
.
attrs
{
Some
(
_
)
=
>
self
.
snapshot
.
get_attr
(
&
ns
!
(
)
&
atom
!
(
"
id
"
)
)
.
map
(
|
value
|
value
.
as_atom
(
)
.
clone
(
)
)
None
=
>
self
.
element
.
get_id
(
)
}
}
fn
has_class
(
&
self
name
:
&
Atom
)
-
>
bool
{
match
self
.
snapshot
.
attrs
{
Some
(
_
)
=
>
self
.
snapshot
.
get_attr
(
&
ns
!
(
)
&
atom
!
(
"
class
"
)
)
.
map_or
(
false
|
v
|
{
v
.
as_tokens
(
)
.
iter
(
)
.
any
(
|
atom
|
atom
=
=
name
)
}
)
None
=
>
self
.
element
.
has_class
(
name
)
}
}
fn
match_attr
<
F
>
(
&
self
attr
:
&
AttrSelector
test
:
F
)
-
>
bool
where
F
:
Fn
(
&
str
)
-
>
bool
{
match
self
.
snapshot
.
attrs
{
Some
(
_
)
=
>
{
let
html
=
self
.
is_html_element_in_html_document
(
)
;
let
local_name
=
if
html
{
&
attr
.
lower_name
}
else
{
&
attr
.
name
}
;
match
attr
.
namespace
{
NamespaceConstraint
:
:
Specific
(
ref
ns
)
=
>
self
.
snapshot
.
get_attr
(
ns
local_name
)
NamespaceConstraint
:
:
Any
=
>
self
.
snapshot
.
get_attr_ignore_ns
(
local_name
)
}
.
map_or
(
false
|
v
|
test
(
v
)
)
}
None
=
>
self
.
element
.
match_attr
(
attr
test
)
}
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
element
.
is_empty
(
)
}
fn
is_root
(
&
self
)
-
>
bool
{
self
.
element
.
is_root
(
)
}
fn
each_class
<
F
>
(
&
self
mut
callback
:
F
)
where
F
:
FnMut
(
&
Atom
)
{
match
self
.
snapshot
.
attrs
{
Some
(
_
)
=
>
{
if
let
Some
(
v
)
=
self
.
snapshot
.
get_attr
(
&
ns
!
(
)
&
atom
!
(
"
class
"
)
)
{
for
c
in
v
.
as_tokens
(
)
{
callback
(
c
)
}
}
}
None
=
>
self
.
element
.
each_class
(
callback
)
}
}
}
fn
selector_to_state
(
sel
:
&
SimpleSelector
<
ServoSelectorImpl
>
)
-
>
ElementState
{
match
*
sel
{
SimpleSelector
:
:
NonTSPseudoClass
(
ref
pc
)
=
>
pc
.
state_flag
(
)
_
=
>
ElementState
:
:
empty
(
)
}
}
fn
is_attr_selector
(
sel
:
&
SimpleSelector
<
ServoSelectorImpl
>
)
-
>
bool
{
match
*
sel
{
SimpleSelector
:
:
ID
(
_
)
|
SimpleSelector
:
:
Class
(
_
)
|
SimpleSelector
:
:
AttrExists
(
_
)
|
SimpleSelector
:
:
AttrEqual
(
_
_
_
)
|
SimpleSelector
:
:
AttrIncludes
(
_
_
)
|
SimpleSelector
:
:
AttrDashMatch
(
_
_
_
)
|
SimpleSelector
:
:
AttrPrefixMatch
(
_
_
)
|
SimpleSelector
:
:
AttrSubstringMatch
(
_
_
)
|
SimpleSelector
:
:
AttrSuffixMatch
(
_
_
)
=
>
true
_
=
>
false
}
}
fn
combinator_to_restyle_hint
(
combinator
:
Option
<
Combinator
>
)
-
>
RestyleHint
{
match
combinator
{
None
=
>
RESTYLE_SELF
Some
(
c
)
=
>
match
c
{
Combinator
:
:
Child
=
>
RESTYLE_DESCENDANTS
Combinator
:
:
Descendant
=
>
RESTYLE_DESCENDANTS
Combinator
:
:
NextSibling
=
>
RESTYLE_LATER_SIBLINGS
Combinator
:
:
LaterSibling
=
>
RESTYLE_LATER_SIBLINGS
}
}
}
#
[
derive
(
Debug
)
]
struct
Sensitivities
{
pub
states
:
ElementState
pub
attrs
:
bool
}
impl
Sensitivities
{
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
states
.
is_empty
(
)
&
&
!
self
.
attrs
}
fn
new
(
)
-
>
Sensitivities
{
Sensitivities
{
states
:
ElementState
:
:
empty
(
)
attrs
:
false
}
}
}
#
[
derive
(
Debug
)
]
struct
Dependency
{
selector
:
Arc
<
CompoundSelector
<
ServoSelectorImpl
>
>
combinator
:
Option
<
Combinator
>
sensitivities
:
Sensitivities
}
#
[
derive
(
Debug
)
]
pub
struct
DependencySet
{
deps
:
Vec
<
Dependency
>
}
impl
DependencySet
{
pub
fn
new
(
)
-
>
DependencySet
{
DependencySet
{
deps
:
Vec
:
:
new
(
)
}
}
pub
fn
compute_hint
<
E
>
(
&
self
el
:
&
E
snapshot
:
&
ElementSnapshot
current_state
:
ElementState
)
-
>
RestyleHint
where
E
:
Element
<
Impl
=
ServoSelectorImpl
>
+
Clone
{
let
state_changes
=
snapshot
.
state
.
map_or
(
ElementState
:
:
empty
(
)
|
old_state
|
current_state
^
old_state
)
;
let
attrs_changed
=
snapshot
.
attrs
.
is_some
(
)
;
let
mut
hint
=
RestyleHint
:
:
empty
(
)
;
for
dep
in
&
self
.
deps
{
if
state_changes
.
intersects
(
dep
.
sensitivities
.
states
)
|
|
(
attrs_changed
&
&
dep
.
sensitivities
.
attrs
)
{
let
old_el
:
ElementWrapper
<
E
>
=
ElementWrapper
:
:
new_with_snapshot
(
el
.
clone
(
)
snapshot
)
;
let
matched_then
=
matches_compound_selector
(
&
*
dep
.
selector
&
old_el
None
&
mut
false
)
;
let
matches_now
=
matches_compound_selector
(
&
*
dep
.
selector
el
None
&
mut
false
)
;
if
matched_then
!
=
matches_now
{
hint
.
insert
(
combinator_to_restyle_hint
(
dep
.
combinator
)
)
;
if
hint
.
is_all
(
)
{
break
}
}
}
}
hint
}
pub
fn
note_selector
(
&
mut
self
selector
:
Arc
<
CompoundSelector
<
ServoSelectorImpl
>
>
)
{
let
mut
cur
=
selector
;
let
mut
combinator
:
Option
<
Combinator
>
=
None
;
loop
{
let
mut
sensitivities
=
Sensitivities
:
:
new
(
)
;
for
s
in
&
cur
.
simple_selectors
{
sensitivities
.
states
.
insert
(
selector_to_state
(
s
)
)
;
if
!
sensitivities
.
attrs
{
sensitivities
.
attrs
=
is_attr_selector
(
s
)
;
}
}
if
!
sensitivities
.
is_empty
(
)
{
self
.
deps
.
push
(
Dependency
{
selector
:
cur
.
clone
(
)
combinator
:
combinator
sensitivities
:
sensitivities
}
)
;
}
cur
=
match
cur
.
next
{
Some
(
(
ref
sel
comb
)
)
=
>
{
combinator
=
Some
(
comb
)
;
sel
.
clone
(
)
}
None
=
>
break
}
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
deps
.
clear
(
)
;
}
}
