#
!
[
deny
(
missing_docs
)
]
use
Atom
;
use
LocalName
;
use
Namespace
;
use
context
:
:
{
SharedStyleContext
ThreadLocalStyleContext
}
;
use
dom
:
:
TElement
;
use
element_state
:
:
*
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
structs
:
:
nsRestyleHint
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
heapsize
:
:
HeapSizeOf
;
use
selector_map
:
:
{
SelectorMap
SelectorMapEntry
}
;
use
selector_parser
:
:
{
NonTSPseudoClass
PseudoElement
SelectorImpl
Snapshot
SnapshotMap
AttrValue
}
;
use
selectors
:
:
Element
;
use
selectors
:
:
attr
:
:
{
AttrSelectorOperation
NamespaceConstraint
}
;
use
selectors
:
:
matching
:
:
{
ElementSelectorFlags
LocalMatchingContext
MatchingContext
MatchingMode
}
;
use
selectors
:
:
matching
:
:
{
RelevantLinkStatus
VisitedHandlingMode
matches_selector
}
;
use
selectors
:
:
parser
:
:
{
AncestorHashes
Combinator
Component
}
;
use
selectors
:
:
parser
:
:
{
Selector
SelectorAndHashes
SelectorIter
SelectorMethods
}
;
use
selectors
:
:
visitor
:
:
SelectorVisitor
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
clone
:
:
Clone
;
use
std
:
:
cmp
;
use
std
:
:
fmt
;
#
[
derive
(
Debug
Clone
PartialEq
)
]
pub
struct
RestyleHint
{
match_under_self
:
RestyleDepths
match_later_siblings
:
bool
recascade
:
CascadeHint
pub
replacements
:
RestyleReplacements
}
bitflags
!
{
/
/
/
Cascade
levels
that
can
be
updated
for
an
element
by
simply
replacing
/
/
/
their
rule
node
.
/
/
/
/
/
/
Note
that
the
bit
values
here
must
be
kept
in
sync
with
the
Gecko
/
/
/
nsRestyleHint
values
.
If
you
add
more
bits
with
matching
values
/
/
/
please
add
assertions
to
assert_restyle_hints_match
below
.
pub
flags
RestyleReplacements
:
u8
{
/
/
/
Replace
the
style
data
coming
from
CSS
transitions
without
updating
/
/
/
any
other
style
data
.
This
hint
is
only
processed
in
animation
-
only
/
/
/
traversal
which
is
prior
to
normal
traversal
.
const
RESTYLE_CSS_TRANSITIONS
=
0x10
/
/
/
Replace
the
style
data
coming
from
CSS
animations
without
updating
/
/
/
any
other
style
data
.
This
hint
is
only
processed
in
animation
-
only
/
/
/
traversal
which
is
prior
to
normal
traversal
.
const
RESTYLE_CSS_ANIMATIONS
=
0x20
/
/
/
Don
'
t
re
-
run
selector
-
matching
on
the
element
only
the
style
/
/
/
attribute
has
changed
and
this
change
didn
'
t
have
any
other
/
/
/
dependencies
.
const
RESTYLE_STYLE_ATTRIBUTE
=
0x40
/
/
/
Replace
the
style
data
coming
from
SMIL
animations
without
updating
/
/
/
any
other
style
data
.
This
hint
is
only
processed
in
animation
-
only
/
/
/
traversal
which
is
prior
to
normal
traversal
.
const
RESTYLE_SMIL
=
0x80
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
)
]
struct
RestyleDepths
(
u8
)
;
impl
RestyleDepths
{
fn
empty
(
)
-
>
Self
{
RestyleDepths
(
0
)
}
fn
for_self
(
)
-
>
Self
{
RestyleDepths
(
0x01
)
}
fn
for_descendants
(
)
-
>
Self
{
RestyleDepths
(
0xfe
)
}
fn
for_self_and_descendants
(
)
-
>
Self
{
RestyleDepths
(
0xff
)
}
fn
for_depth
(
depth
:
u32
)
-
>
Self
{
RestyleDepths
(
1u8
<
<
cmp
:
:
min
(
depth
7
)
)
}
fn
is_self_and_descendants
(
&
self
)
-
>
bool
{
self
.
0
=
=
0xff
}
fn
is_any
(
&
self
)
-
>
bool
{
self
.
0
!
=
0
}
fn
has_self
(
&
self
)
-
>
bool
{
(
self
.
0
&
0x01
)
!
=
0
}
fn
propagate
(
&
self
)
-
>
Self
{
RestyleDepths
(
(
self
.
0
>
>
1
)
|
(
self
.
0
&
0x80
)
)
}
fn
insert
(
&
mut
self
other
:
RestyleDepths
)
{
self
.
0
|
=
other
.
0
;
}
fn
contains
(
&
self
other
:
RestyleDepths
)
-
>
bool
{
(
self
.
0
&
other
.
0
)
=
=
other
.
0
}
}
bitflags
!
{
/
/
/
Flags
representing
whether
the
current
element
or
its
descendants
/
/
/
must
be
recascaded
.
/
/
/
/
/
/
FIXME
(
bholley
)
:
This
should
eventually
become
more
fine
-
grained
.
pub
flags
CascadeHint
:
u8
{
/
/
/
Recascade
the
current
element
.
const
RECASCADE_SELF
=
0x01
/
/
/
Recascade
all
descendant
elements
.
const
RECASCADE_DESCENDANTS
=
0x02
}
}
impl
CascadeHint
{
fn
subtree
(
)
-
>
CascadeHint
{
RECASCADE_SELF
|
RECASCADE_DESCENDANTS
}
fn
propagate
(
&
self
)
-
>
Self
{
if
self
.
contains
(
RECASCADE_DESCENDANTS
)
{
CascadeHint
:
:
subtree
(
)
}
else
{
CascadeHint
:
:
empty
(
)
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
inline
]
pub
fn
assert_restyle_hints_match
(
)
{
use
gecko_bindings
:
:
structs
;
macro_rules
!
check_restyle_hints
{
(
(
a
:
ident
=
>
b
:
ident
)
*
)
=
>
{
if
cfg
!
(
debug_assertions
)
{
let
mut
replacements
=
RestyleReplacements
:
:
all
(
)
;
(
assert_eq
!
(
structs
:
:
a
.
0
as
usize
b
.
bits
(
)
as
usize
stringify
!
(
b
)
)
;
replacements
.
remove
(
b
)
;
)
*
assert_eq
!
(
replacements
RestyleReplacements
:
:
empty
(
)
"
all
RestyleReplacements
bits
should
have
an
assertion
"
)
;
}
}
}
check_restyle_hints
!
{
nsRestyleHint_eRestyle_CSSTransitions
=
>
RESTYLE_CSS_TRANSITIONS
nsRestyleHint_eRestyle_CSSAnimations
=
>
RESTYLE_CSS_ANIMATIONS
nsRestyleHint_eRestyle_StyleAttribute
=
>
RESTYLE_STYLE_ATTRIBUTE
nsRestyleHint_eRestyle_StyleAttribute_Animations
=
>
RESTYLE_SMIL
}
}
impl
RestyleHint
{
#
[
inline
]
pub
fn
empty
(
)
-
>
Self
{
RestyleHint
{
match_under_self
:
RestyleDepths
:
:
empty
(
)
match_later_siblings
:
false
recascade
:
CascadeHint
:
:
empty
(
)
replacements
:
RestyleReplacements
:
:
empty
(
)
}
}
#
[
inline
]
pub
fn
for_self
(
)
-
>
Self
{
RestyleHint
{
match_under_self
:
RestyleDepths
:
:
for_self
(
)
match_later_siblings
:
false
recascade
:
CascadeHint
:
:
empty
(
)
replacements
:
RestyleReplacements
:
:
empty
(
)
}
}
#
[
inline
]
pub
fn
descendants
(
)
-
>
Self
{
RestyleHint
{
match_under_self
:
RestyleDepths
:
:
for_descendants
(
)
match_later_siblings
:
false
recascade
:
CascadeHint
:
:
empty
(
)
replacements
:
RestyleReplacements
:
:
empty
(
)
}
}
#
[
inline
]
pub
fn
descendants_at_depth
(
depth
:
u32
)
-
>
Self
{
RestyleHint
{
match_under_self
:
RestyleDepths
:
:
for_depth
(
depth
)
match_later_siblings
:
false
recascade
:
CascadeHint
:
:
empty
(
)
replacements
:
RestyleReplacements
:
:
empty
(
)
}
}
#
[
inline
]
pub
fn
later_siblings
(
)
-
>
Self
{
RestyleHint
{
match_under_self
:
RestyleDepths
:
:
empty
(
)
match_later_siblings
:
true
recascade
:
CascadeHint
:
:
empty
(
)
replacements
:
RestyleReplacements
:
:
empty
(
)
}
}
#
[
inline
]
pub
fn
subtree
(
)
-
>
Self
{
RestyleHint
{
match_under_self
:
RestyleDepths
:
:
for_self_and_descendants
(
)
match_later_siblings
:
false
recascade
:
CascadeHint
:
:
empty
(
)
replacements
:
RestyleReplacements
:
:
empty
(
)
}
}
#
[
inline
]
pub
fn
subtree_and_later_siblings
(
)
-
>
Self
{
RestyleHint
{
match_under_self
:
RestyleDepths
:
:
for_self_and_descendants
(
)
match_later_siblings
:
true
recascade
:
CascadeHint
:
:
empty
(
)
replacements
:
RestyleReplacements
:
:
empty
(
)
}
}
#
[
inline
]
pub
fn
for_replacements
(
replacements
:
RestyleReplacements
)
-
>
Self
{
RestyleHint
{
match_under_self
:
RestyleDepths
:
:
empty
(
)
match_later_siblings
:
false
recascade
:
CascadeHint
:
:
empty
(
)
replacements
:
replacements
}
}
pub
fn
recascade_self
(
)
-
>
Self
{
RestyleHint
{
match_under_self
:
RestyleDepths
:
:
empty
(
)
match_later_siblings
:
false
recascade
:
RECASCADE_SELF
replacements
:
RestyleReplacements
:
:
empty
(
)
}
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
*
self
=
=
RestyleHint
:
:
empty
(
)
}
#
[
inline
]
pub
fn
is_maximum
(
&
self
)
-
>
bool
{
self
.
match_under_self
.
is_self_and_descendants
(
)
&
&
self
.
match_later_siblings
&
&
self
.
recascade
.
is_all
(
)
&
&
self
.
replacements
.
is_all
(
)
}
#
[
inline
]
pub
fn
affects_self
(
&
self
)
-
>
bool
{
self
.
match_self
(
)
|
|
self
.
has_recascade_self
(
)
|
|
!
self
.
replacements
.
is_empty
(
)
}
pub
fn
has_recascade_self
(
&
self
)
-
>
bool
{
self
.
recascade
.
contains
(
RECASCADE_SELF
)
}
#
[
inline
]
pub
fn
affects_later_siblings
(
&
self
)
-
>
bool
{
self
.
match_later_siblings
}
#
[
inline
]
pub
fn
has_animation_hint
(
&
self
)
-
>
bool
{
self
.
replacements
.
intersects
(
RestyleReplacements
:
:
for_animations
(
)
)
}
#
[
inline
]
pub
fn
has_non_animation_hint
(
&
self
)
-
>
bool
{
self
.
match_under_self
.
is_any
(
)
|
|
self
.
match_later_siblings
|
|
!
self
.
recascade
.
is_empty
(
)
|
|
self
.
replacements
.
contains
(
RESTYLE_STYLE_ATTRIBUTE
)
}
#
[
inline
]
pub
fn
match_self
(
&
self
)
-
>
bool
{
self
.
match_under_self
.
has_self
(
)
}
#
[
inline
]
pub
fn
has_replacements
(
&
self
)
-
>
bool
{
!
self
.
replacements
.
is_empty
(
)
}
#
[
inline
]
pub
fn
propagate_for_non_animation_restyle
(
&
self
)
-
>
Self
{
RestyleHint
{
match_under_self
:
self
.
match_under_self
.
propagate
(
)
match_later_siblings
:
false
recascade
:
self
.
recascade
.
propagate
(
)
replacements
:
RestyleReplacements
:
:
empty
(
)
}
}
#
[
inline
]
pub
fn
remove_animation_hints
(
&
mut
self
)
{
self
.
replacements
.
remove
(
RestyleReplacements
:
:
for_animations
(
)
)
;
self
.
recascade
.
remove
(
RECASCADE_SELF
)
;
}
pub
fn
remove_later_siblings_hint
(
&
mut
self
)
-
>
bool
{
let
later_siblings
=
self
.
match_later_siblings
;
self
.
match_later_siblings
=
false
;
later_siblings
}
#
[
inline
]
pub
fn
insert_from
(
&
mut
self
other
:
&
Self
)
{
self
.
match_under_self
.
insert
(
other
.
match_under_self
)
;
self
.
match_later_siblings
|
=
other
.
match_later_siblings
;
self
.
recascade
.
insert
(
other
.
recascade
)
;
self
.
replacements
.
insert
(
other
.
replacements
)
;
}
#
[
inline
]
pub
fn
insert
(
&
mut
self
other
:
Self
)
{
self
.
insert_from
(
&
other
)
}
#
[
inline
]
pub
fn
insert_cascade_hint
(
&
mut
self
cascade_hint
:
CascadeHint
)
{
self
.
recascade
.
insert
(
cascade_hint
)
;
}
#
[
inline
]
pub
fn
contains
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
match_under_self
.
contains
(
other
.
match_under_self
)
&
&
(
self
.
match_later_siblings
&
other
.
match_later_siblings
)
=
=
other
.
match_later_siblings
&
&
self
.
recascade
.
contains
(
other
.
recascade
)
&
&
self
.
replacements
.
contains
(
other
.
replacements
)
}
}
impl
RestyleReplacements
{
#
[
inline
]
pub
fn
for_animations
(
)
-
>
Self
{
RESTYLE_SMIL
|
RESTYLE_CSS_ANIMATIONS
|
RESTYLE_CSS_TRANSITIONS
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
nsRestyleHint
>
for
RestyleReplacements
{
fn
from
(
raw
:
nsRestyleHint
)
-
>
Self
{
Self
:
:
from_bits_truncate
(
raw
.
0
as
u8
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
nsRestyleHint
>
for
RestyleHint
{
fn
from
(
raw
:
nsRestyleHint
)
-
>
Self
{
use
gecko_bindings
:
:
structs
:
:
nsRestyleHint_eRestyle_ForceDescendants
as
eRestyle_ForceDescendants
;
use
gecko_bindings
:
:
structs
:
:
nsRestyleHint_eRestyle_LaterSiblings
as
eRestyle_LaterSiblings
;
use
gecko_bindings
:
:
structs
:
:
nsRestyleHint_eRestyle_Self
as
eRestyle_Self
;
use
gecko_bindings
:
:
structs
:
:
nsRestyleHint_eRestyle_SomeDescendants
as
eRestyle_SomeDescendants
;
use
gecko_bindings
:
:
structs
:
:
nsRestyleHint_eRestyle_Subtree
as
eRestyle_Subtree
;
let
mut
match_under_self
=
RestyleDepths
:
:
empty
(
)
;
if
(
raw
.
0
&
(
eRestyle_Self
.
0
|
eRestyle_Subtree
.
0
)
)
!
=
0
{
match_under_self
.
insert
(
RestyleDepths
:
:
for_self
(
)
)
;
}
if
(
raw
.
0
&
(
eRestyle_Subtree
.
0
|
eRestyle_SomeDescendants
.
0
)
)
!
=
0
{
match_under_self
.
insert
(
RestyleDepths
:
:
for_descendants
(
)
)
;
}
let
mut
recascade
=
CascadeHint
:
:
empty
(
)
;
if
(
raw
.
0
&
eRestyle_ForceDescendants
.
0
)
!
=
0
{
recascade
.
insert
(
CascadeHint
:
:
subtree
(
)
)
}
RestyleHint
{
match_under_self
:
match_under_self
match_later_siblings
:
(
raw
.
0
&
eRestyle_LaterSiblings
.
0
)
!
=
0
recascade
:
recascade
replacements
:
raw
.
into
(
)
}
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
HeapSizeOf
for
RestyleHint
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
pub
trait
ElementSnapshot
:
Sized
{
fn
state
(
&
self
)
-
>
Option
<
ElementState
>
;
fn
has_attrs
(
&
self
)
-
>
bool
;
fn
id_attr
(
&
self
)
-
>
Option
<
Atom
>
;
fn
has_class
(
&
self
name
:
&
Atom
)
-
>
bool
;
fn
each_class
<
F
>
(
&
self
F
)
where
F
:
FnMut
(
&
Atom
)
;
fn
lang_attr
(
&
self
)
-
>
Option
<
AttrValue
>
;
}
#
[
derive
(
Clone
)
]
struct
ElementWrapper
<
'
a
E
>
where
E
:
TElement
{
element
:
E
cached_snapshot
:
Cell
<
Option
<
&
'
a
Snapshot
>
>
snapshot_map
:
&
'
a
SnapshotMap
}
impl
<
'
a
E
>
ElementWrapper
<
'
a
E
>
where
E
:
TElement
{
fn
new
(
el
:
E
snapshot_map
:
&
'
a
SnapshotMap
)
-
>
Self
{
ElementWrapper
{
element
:
el
cached_snapshot
:
Cell
:
:
new
(
None
)
snapshot_map
:
snapshot_map
}
}
fn
snapshot
(
&
self
)
-
>
Option
<
&
'
a
Snapshot
>
{
if
!
self
.
element
.
has_snapshot
(
)
{
return
None
;
}
if
let
Some
(
s
)
=
self
.
cached_snapshot
.
get
(
)
{
return
Some
(
s
)
;
}
let
snapshot
=
self
.
snapshot_map
.
get
(
&
self
.
element
)
;
debug_assert
!
(
snapshot
.
is_some
(
)
"
has_snapshot
lied
!
"
)
;
self
.
cached_snapshot
.
set
(
snapshot
)
;
snapshot
}
fn
state_changes
(
&
self
)
-
>
ElementState
{
let
snapshot
=
match
self
.
snapshot
(
)
{
Some
(
s
)
=
>
s
None
=
>
return
ElementState
:
:
empty
(
)
}
;
match
snapshot
.
state
(
)
{
Some
(
state
)
=
>
state
^
self
.
element
.
get_state
(
)
None
=
>
ElementState
:
:
empty
(
)
}
}
fn
get_lang
(
&
self
)
-
>
Option
<
AttrValue
>
{
let
mut
current
=
self
.
clone
(
)
;
loop
{
let
lang
=
match
self
.
snapshot
(
)
{
Some
(
snapshot
)
if
snapshot
.
has_attrs
(
)
=
>
snapshot
.
lang_attr
(
)
_
=
>
current
.
element
.
lang_attr
(
)
}
;
if
lang
.
is_some
(
)
{
return
lang
;
}
match
current
.
parent_element
(
)
{
Some
(
parent
)
=
>
current
=
parent
None
=
>
return
None
}
}
}
}
impl
<
'
a
E
>
fmt
:
:
Debug
for
ElementWrapper
<
'
a
E
>
where
E
:
TElement
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
element
.
fmt
(
f
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
dir_selector_to_state
(
s
:
&
[
u16
]
)
-
>
ElementState
{
const
LTR
:
[
u16
;
4
]
=
[
b
'
l
'
as
u16
b
'
t
'
as
u16
b
'
r
'
as
u16
0
]
;
const
RTL
:
[
u16
;
4
]
=
[
b
'
r
'
as
u16
b
'
t
'
as
u16
b
'
l
'
as
u16
0
]
;
if
LTR
=
=
*
s
{
IN_LTR_STATE
}
else
if
RTL
=
=
*
s
{
IN_RTL_STATE
}
else
{
ElementState
:
:
empty
(
)
}
}
impl
<
'
a
E
>
Element
for
ElementWrapper
<
'
a
E
>
where
E
:
TElement
{
type
Impl
=
SelectorImpl
;
fn
match_non_ts_pseudo_class
<
F
>
(
&
self
pseudo_class
:
&
NonTSPseudoClass
context
:
&
mut
LocalMatchingContext
<
Self
:
:
Impl
>
relevant_link
:
&
RelevantLinkStatus
_setter
:
&
mut
F
)
-
>
bool
where
F
:
FnMut
(
&
Self
ElementSelectorFlags
)
{
match
*
pseudo_class
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
MozAny
(
ref
selectors
)
=
>
{
use
selectors
:
:
matching
:
:
matches_complex_selector
;
return
selectors
.
iter
(
)
.
any
(
|
s
|
{
matches_complex_selector
(
s
0
self
context
_setter
)
}
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
Dir
(
ref
s
)
=
>
{
let
selector_flag
=
dir_selector_to_state
(
s
)
;
if
selector_flag
.
is_empty
(
)
{
return
false
;
}
let
state
=
match
self
.
snapshot
(
)
.
and_then
(
|
s
|
s
.
state
(
)
)
{
Some
(
snapshot_state
)
=
>
snapshot_state
None
=
>
self
.
element
.
get_state
(
)
}
;
return
state
.
contains
(
selector_flag
)
;
}
NonTSPseudoClass
:
:
Link
=
>
{
return
relevant_link
.
is_unvisited
(
self
context
.
shared
)
;
}
NonTSPseudoClass
:
:
Visited
=
>
{
return
relevant_link
.
is_visited
(
self
context
.
shared
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
MozTableBorderNonzero
=
>
{
if
let
Some
(
snapshot
)
=
self
.
snapshot
(
)
{
if
snapshot
.
has_other_pseudo_class_state
(
)
{
return
snapshot
.
mIsTableBorderNonzero
(
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
NonTSPseudoClass
:
:
MozBrowserFrame
=
>
{
if
let
Some
(
snapshot
)
=
self
.
snapshot
(
)
{
if
snapshot
.
has_other_pseudo_class_state
(
)
{
return
snapshot
.
mIsMozBrowserFrame
(
)
;
}
}
}
NonTSPseudoClass
:
:
Lang
(
ref
lang_arg
)
=
>
{
return
self
.
element
.
match_element_lang
(
Some
(
self
.
get_lang
(
)
)
lang_arg
)
;
}
_
=
>
{
}
}
let
flag
=
pseudo_class
.
state_flag
(
)
;
if
flag
.
is_empty
(
)
{
return
self
.
element
.
match_non_ts_pseudo_class
(
pseudo_class
context
relevant_link
&
mut
|
_
_
|
{
}
)
}
match
self
.
snapshot
(
)
.
and_then
(
|
s
|
s
.
state
(
)
)
{
Some
(
snapshot_state
)
=
>
snapshot_state
.
intersects
(
flag
)
None
=
>
{
self
.
element
.
match_non_ts_pseudo_class
(
pseudo_class
context
relevant_link
&
mut
|
_
_
|
{
}
)
}
}
}
fn
match_pseudo_element
(
&
self
pseudo_element
:
&
PseudoElement
context
:
&
mut
MatchingContext
)
-
>
bool
{
self
.
element
.
match_pseudo_element
(
pseudo_element
context
)
}
fn
is_link
(
&
self
)
-
>
bool
{
self
.
element
.
is_link
(
)
}
fn
parent_element
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
parent_element
(
)
.
map
(
|
e
|
ElementWrapper
:
:
new
(
e
self
.
snapshot_map
)
)
}
fn
first_child_element
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
first_child_element
(
)
.
map
(
|
e
|
ElementWrapper
:
:
new
(
e
self
.
snapshot_map
)
)
}
fn
last_child_element
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
last_child_element
(
)
.
map
(
|
e
|
ElementWrapper
:
:
new
(
e
self
.
snapshot_map
)
)
}
fn
prev_sibling_element
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
prev_sibling_element
(
)
.
map
(
|
e
|
ElementWrapper
:
:
new
(
e
self
.
snapshot_map
)
)
}
fn
next_sibling_element
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
next_sibling_element
(
)
.
map
(
|
e
|
ElementWrapper
:
:
new
(
e
self
.
snapshot_map
)
)
}
fn
is_html_element_in_html_document
(
&
self
)
-
>
bool
{
self
.
element
.
is_html_element_in_html_document
(
)
}
fn
get_local_name
(
&
self
)
-
>
&
<
Self
:
:
Impl
as
:
:
selectors
:
:
SelectorImpl
>
:
:
BorrowedLocalName
{
self
.
element
.
get_local_name
(
)
}
fn
get_namespace
(
&
self
)
-
>
&
<
Self
:
:
Impl
as
:
:
selectors
:
:
SelectorImpl
>
:
:
BorrowedNamespaceUrl
{
self
.
element
.
get_namespace
(
)
}
fn
attr_matches
(
&
self
ns
:
&
NamespaceConstraint
<
&
Namespace
>
local_name
:
&
LocalName
operation
:
&
AttrSelectorOperation
<
&
AttrValue
>
)
-
>
bool
{
match
self
.
snapshot
(
)
{
Some
(
snapshot
)
if
snapshot
.
has_attrs
(
)
=
>
{
snapshot
.
attr_matches
(
ns
local_name
operation
)
}
_
=
>
self
.
element
.
attr_matches
(
ns
local_name
operation
)
}
}
fn
get_id
(
&
self
)
-
>
Option
<
Atom
>
{
match
self
.
snapshot
(
)
{
Some
(
snapshot
)
if
snapshot
.
has_attrs
(
)
=
>
snapshot
.
id_attr
(
)
_
=
>
self
.
element
.
get_id
(
)
}
}
fn
has_class
(
&
self
name
:
&
Atom
)
-
>
bool
{
match
self
.
snapshot
(
)
{
Some
(
snapshot
)
if
snapshot
.
has_attrs
(
)
=
>
snapshot
.
has_class
(
name
)
_
=
>
self
.
element
.
has_class
(
name
)
}
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
element
.
is_empty
(
)
}
fn
is_root
(
&
self
)
-
>
bool
{
self
.
element
.
is_root
(
)
}
fn
pseudo_element_originating_element
(
&
self
)
-
>
Option
<
Self
>
{
self
.
element
.
closest_non_native_anonymous_ancestor
(
)
.
map
(
|
e
|
ElementWrapper
:
:
new
(
e
self
.
snapshot_map
)
)
}
}
fn
selector_to_state
(
sel
:
&
Component
<
SelectorImpl
>
)
-
>
ElementState
{
match
*
sel
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
Component
:
:
NonTSPseudoClass
(
NonTSPseudoClass
:
:
Dir
(
ref
s
)
)
=
>
dir_selector_to_state
(
s
)
Component
:
:
NonTSPseudoClass
(
ref
pc
)
=
>
pc
.
state_flag
(
)
_
=
>
ElementState
:
:
empty
(
)
}
}
fn
is_attr_based_selector
(
sel
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
match
*
sel
{
Component
:
:
ID
(
_
)
|
Component
:
:
Class
(
_
)
|
Component
:
:
AttributeInNoNamespaceExists
{
.
.
}
|
Component
:
:
AttributeInNoNamespace
{
.
.
}
|
Component
:
:
AttributeOther
(
_
)
=
>
true
Component
:
:
NonTSPseudoClass
(
ref
pc
)
=
>
pc
.
is_attr_based
(
)
_
=
>
false
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
Sensitivities
{
pub
states
:
ElementState
pub
attrs
:
bool
}
impl
Sensitivities
{
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
states
.
is_empty
(
)
&
&
!
self
.
attrs
}
fn
new
(
)
-
>
Sensitivities
{
Sensitivities
{
states
:
ElementState
:
:
empty
(
)
attrs
:
false
}
}
fn
sensitive_to
(
&
self
attrs
:
bool
states
:
ElementState
)
-
>
bool
{
(
attrs
&
&
self
.
attrs
)
|
|
self
.
states
.
intersects
(
states
)
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
Dependency
{
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
selector
:
Selector
<
SelectorImpl
>
selector_offset
:
usize
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
No
heap
data
"
)
]
hashes
:
AncestorHashes
pub
hint
:
RestyleHint
pub
sensitivities
:
Sensitivities
}
impl
SelectorMapEntry
for
Dependency
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter_from
(
self
.
selector_offset
)
}
fn
hashes
(
&
self
)
-
>
&
AncestorHashes
{
&
self
.
hashes
}
}
struct
SensitivitiesVisitor
{
sensitivities
:
Sensitivities
}
impl
SelectorVisitor
for
SensitivitiesVisitor
{
type
Impl
=
SelectorImpl
;
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
self
.
sensitivities
.
states
.
insert
(
selector_to_state
(
s
)
)
;
self
.
sensitivities
.
attrs
|
=
is_attr_based_selector
(
s
)
;
true
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
DependencySet
{
dependencies
:
SelectorMap
<
Dependency
>
}
pub
enum
HintComputationContext
<
'
a
E
:
'
a
>
where
E
:
TElement
{
Root
Child
{
local_context
:
&
'
a
mut
ThreadLocalStyleContext
<
E
>
dom_depth
:
usize
}
}
impl
DependencySet
{
pub
fn
note_selector
(
&
mut
self
selector_and_hashes
:
&
SelectorAndHashes
<
SelectorImpl
>
)
{
let
mut
combinator
=
None
;
let
mut
iter
=
selector_and_hashes
.
selector
.
iter
(
)
;
let
mut
index
=
0
;
let
mut
child_combinators_seen
=
0
;
let
mut
saw_descendant_combinator
=
false
;
loop
{
let
sequence_start
=
index
;
let
mut
visitor
=
SensitivitiesVisitor
{
sensitivities
:
Sensitivities
:
:
new
(
)
}
;
for
ss
in
&
mut
iter
{
ss
.
visit
(
&
mut
visitor
)
;
index
+
=
1
;
}
match
combinator
{
Some
(
Combinator
:
:
Child
)
=
>
child_combinators_seen
+
=
1
Some
(
Combinator
:
:
Descendant
)
=
>
saw_descendant_combinator
=
true
_
=
>
{
}
}
if
!
visitor
.
sensitivities
.
is_empty
(
)
{
let
hint
=
match
combinator
{
Some
(
Combinator
:
:
PseudoElement
)
=
>
RestyleHint
:
:
subtree
(
)
Some
(
Combinator
:
:
Child
)
if
!
saw_descendant_combinator
=
>
{
RestyleHint
:
:
descendants_at_depth
(
child_combinators_seen
)
}
Some
(
Combinator
:
:
Child
)
|
Some
(
Combinator
:
:
Descendant
)
=
>
RestyleHint
:
:
descendants
(
)
Some
(
Combinator
:
:
NextSibling
)
|
Some
(
Combinator
:
:
LaterSibling
)
=
>
RestyleHint
:
:
later_siblings
(
)
None
=
>
RestyleHint
:
:
for_self
(
)
}
;
let
hashes
=
if
sequence_start
=
=
0
{
selector_and_hashes
.
hashes
.
clone
(
)
}
else
{
let
seq_iter
=
selector_and_hashes
.
selector
.
iter_from
(
sequence_start
)
;
AncestorHashes
:
:
from_iter
(
seq_iter
)
}
;
self
.
dependencies
.
insert
(
Dependency
{
sensitivities
:
visitor
.
sensitivities
hint
:
hint
selector
:
selector_and_hashes
.
selector
.
clone
(
)
selector_offset
:
sequence_start
hashes
:
hashes
}
)
;
}
combinator
=
iter
.
next_sequence
(
)
;
if
combinator
.
is_none
(
)
{
break
;
}
index
+
=
1
;
}
}
pub
fn
new
(
)
-
>
Self
{
DependencySet
{
dependencies
:
SelectorMap
:
:
new
(
)
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
dependencies
.
len
(
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
dependencies
=
SelectorMap
:
:
new
(
)
;
}
pub
fn
compute_hint
<
'
a
E
>
(
&
self
el
:
&
E
shared_context
:
&
SharedStyleContext
hint_context
:
HintComputationContext
<
'
a
E
>
)
-
>
RestyleHint
where
E
:
TElement
{
debug_assert
!
(
el
.
has_snapshot
(
)
"
Shouldn
'
t
be
here
!
"
)
;
let
snapshot_el
=
ElementWrapper
:
:
new
(
*
el
shared_context
.
snapshot_map
)
;
let
snapshot
=
snapshot_el
.
snapshot
(
)
.
expect
(
"
has_snapshot
lied
so
badly
"
)
;
let
state_changes
=
snapshot_el
.
state_changes
(
)
;
let
attrs_changed
=
snapshot
.
has_attrs
(
)
;
if
state_changes
.
is_empty
(
)
&
&
!
attrs_changed
{
return
RestyleHint
:
:
empty
(
)
;
}
let
mut
hint
=
RestyleHint
:
:
empty
(
)
;
if
state_changes
.
intersects
(
IN_VISITED_OR_UNVISITED_STATE
)
{
trace
!
(
"
>
visitedness
change
force
subtree
restyle
"
)
;
hint
=
RestyleHint
:
:
subtree
(
)
;
}
let
mut
additional_id
=
None
;
let
mut
additional_classes
=
SmallVec
:
:
<
[
Atom
;
8
]
>
:
:
new
(
)
;
if
attrs_changed
{
let
id
=
snapshot
.
id_attr
(
)
;
if
id
.
is_some
(
)
&
&
id
!
=
el
.
get_id
(
)
{
additional_id
=
id
;
}
snapshot
.
each_class
(
|
c
|
{
if
!
el
.
has_class
(
c
)
{
additional_classes
.
push
(
c
.
clone
(
)
)
}
}
)
;
}
let
bloom_filter
=
match
hint_context
{
HintComputationContext
:
:
Root
=
>
None
HintComputationContext
:
:
Child
{
mut
local_context
dom_depth
}
=
>
{
local_context
.
bloom_filter
.
insert_parents_recovering
(
*
el
dom_depth
)
;
local_context
.
bloom_filter
.
assert_complete
(
*
el
)
;
Some
(
local_context
.
bloom_filter
.
filter
(
)
)
}
}
;
let
lookup_element
=
if
el
.
implemented_pseudo_element
(
)
.
is_some
(
)
{
el
.
closest_non_native_anonymous_ancestor
(
)
.
unwrap
(
)
}
else
{
*
el
}
;
self
.
dependencies
.
lookup_with_additional
(
lookup_element
additional_id
&
additional_classes
&
mut
|
dep
|
{
trace
!
(
"
scanning
dependency
:
{
:
?
}
"
dep
)
;
if
!
dep
.
sensitivities
.
sensitive_to
(
attrs_changed
state_changes
)
{
trace
!
(
"
>
non
-
sensitive
"
)
;
return
true
;
}
if
hint
.
contains
(
&
dep
.
hint
)
{
trace
!
(
"
>
hint
was
already
there
"
)
;
return
true
;
}
let
mut
then_context
=
MatchingContext
:
:
new_for_visited
(
MatchingMode
:
:
Normal
None
VisitedHandlingMode
:
:
AllLinksUnvisited
shared_context
.
quirks_mode
)
;
let
matched_then
=
matches_selector
(
&
dep
.
selector
dep
.
selector_offset
&
dep
.
hashes
&
snapshot_el
&
mut
then_context
&
mut
|
_
_
|
{
}
)
;
let
mut
now_context
=
MatchingContext
:
:
new_for_visited
(
MatchingMode
:
:
Normal
bloom_filter
VisitedHandlingMode
:
:
AllLinksUnvisited
shared_context
.
quirks_mode
)
;
let
matches_now
=
matches_selector
(
&
dep
.
selector
dep
.
selector_offset
&
dep
.
hashes
el
&
mut
now_context
&
mut
|
_
_
|
{
}
)
;
if
matched_then
!
=
matches_now
|
|
then_context
.
relevant_link_found
!
=
now_context
.
relevant_link_found
{
hint
.
insert_from
(
&
dep
.
hint
)
;
return
!
hint
.
is_maximum
(
)
}
if
now_context
.
relevant_link_found
&
&
dep
.
sensitivities
.
states
.
intersects
(
IN_VISITED_OR_UNVISITED_STATE
)
{
then_context
.
visited_handling
=
VisitedHandlingMode
:
:
RelevantLinkVisited
;
let
matched_then
=
matches_selector
(
&
dep
.
selector
dep
.
selector_offset
&
dep
.
hashes
&
snapshot_el
&
mut
then_context
&
mut
|
_
_
|
{
}
)
;
now_context
.
visited_handling
=
VisitedHandlingMode
:
:
RelevantLinkVisited
;
let
matches_now
=
matches_selector
(
&
dep
.
selector
dep
.
selector_offset
&
dep
.
hashes
el
&
mut
now_context
&
mut
|
_
_
|
{
}
)
;
if
matched_then
!
=
matches_now
{
hint
.
insert_from
(
&
dep
.
hint
)
;
return
!
hint
.
is_maximum
(
)
}
}
!
hint
.
is_maximum
(
)
}
)
;
debug
!
(
"
Calculated
restyle
hint
:
{
:
?
}
for
{
:
?
}
.
(
State
=
{
:
?
}
{
}
Deps
)
"
hint
el
el
.
get_state
(
)
self
.
len
(
)
)
;
hint
}
}
