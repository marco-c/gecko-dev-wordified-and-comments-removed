use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
{
fmt
mem
slice
}
;
use
std
:
:
ptr
:
:
NonNull
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
malloc_size_of
:
:
{
MallocSizeOf
MallocShallowSizeOf
MallocSizeOfOps
}
;
use
to_shmem
:
:
{
SharedMemoryBuilder
ToShmem
}
;
/
/
/
cbindgen
:
derive
-
eq
=
false
/
/
/
cbindgen
:
derive
-
neq
=
false
#
[
repr
(
C
)
]
pub
struct
OwnedSlice
<
T
:
Sized
>
{
ptr
:
NonNull
<
T
>
len
:
usize
_phantom
:
PhantomData
<
T
>
}
impl
<
T
:
Sized
>
Default
for
OwnedSlice
<
T
>
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
{
len
:
0
ptr
:
NonNull
:
:
dangling
(
)
_phantom
:
PhantomData
}
}
}
impl
<
T
:
Sized
>
Drop
for
OwnedSlice
<
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
if
self
.
len
!
=
0
{
let
_
=
mem
:
:
replace
(
self
Self
:
:
default
(
)
)
.
into_vec
(
)
;
}
}
}
unsafe
impl
<
T
:
Sized
+
Send
>
Send
for
OwnedSlice
<
T
>
{
}
unsafe
impl
<
T
:
Sized
+
Sync
>
Sync
for
OwnedSlice
<
T
>
{
}
impl
<
T
:
Clone
>
Clone
for
OwnedSlice
<
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
Self
:
:
from_slice
(
&
*
*
self
)
}
}
impl
<
T
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
OwnedSlice
<
T
>
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
deref
(
)
.
fmt
(
formatter
)
}
}
impl
<
T
:
PartialEq
>
PartialEq
for
OwnedSlice
<
T
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
deref
(
)
.
eq
(
other
.
deref
(
)
)
}
}
impl
<
T
:
Eq
>
Eq
for
OwnedSlice
<
T
>
{
}
impl
<
T
:
Sized
>
OwnedSlice
<
T
>
{
#
[
inline
]
pub
fn
into_box
(
self
)
-
>
Box
<
[
T
]
>
{
self
.
into_vec
(
)
.
into_boxed_slice
(
)
}
#
[
inline
]
pub
fn
into_vec
(
self
)
-
>
Vec
<
T
>
{
let
ret
=
unsafe
{
Vec
:
:
from_raw_parts
(
self
.
ptr
.
as_ptr
(
)
self
.
len
self
.
len
)
}
;
mem
:
:
forget
(
self
)
;
ret
}
#
[
inline
]
pub
fn
into_iter
(
self
)
-
>
impl
Iterator
<
Item
=
T
>
{
self
.
into_vec
(
)
.
into_iter
(
)
}
#
[
inline
]
pub
fn
from_slice
(
s
:
&
[
T
]
)
-
>
Self
where
T
:
Clone
{
Self
:
:
from
(
s
.
to_vec
(
)
)
}
}
impl
<
T
>
Deref
for
OwnedSlice
<
T
>
{
type
Target
=
[
T
]
;
#
[
inline
(
always
)
]
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
unsafe
{
slice
:
:
from_raw_parts
(
self
.
ptr
.
as_ptr
(
)
self
.
len
)
}
}
}
impl
<
T
>
DerefMut
for
OwnedSlice
<
T
>
{
#
[
inline
(
always
)
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
unsafe
{
slice
:
:
from_raw_parts_mut
(
self
.
ptr
.
as_ptr
(
)
self
.
len
)
}
}
}
impl
<
T
>
From
<
Box
<
[
T
]
>
>
for
OwnedSlice
<
T
>
{
#
[
inline
]
fn
from
(
mut
b
:
Box
<
[
T
]
>
)
-
>
Self
{
let
len
=
b
.
len
(
)
;
let
ptr
=
unsafe
{
NonNull
:
:
new_unchecked
(
b
.
as_mut_ptr
(
)
)
}
;
mem
:
:
forget
(
b
)
;
Self
{
len
ptr
_phantom
:
PhantomData
}
}
}
impl
<
T
>
From
<
Vec
<
T
>
>
for
OwnedSlice
<
T
>
{
#
[
inline
]
fn
from
(
b
:
Vec
<
T
>
)
-
>
Self
{
Self
:
:
from
(
b
.
into_boxed_slice
(
)
)
}
}
impl
<
T
:
Sized
>
MallocShallowSizeOf
for
OwnedSlice
<
T
>
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
unsafe
{
ops
.
malloc_size_of
(
self
.
ptr
.
as_ptr
(
)
)
}
}
}
impl
<
T
:
MallocSizeOf
+
Sized
>
MallocSizeOf
for
OwnedSlice
<
T
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
shallow_size_of
(
ops
)
+
(
*
*
self
)
.
size_of
(
ops
)
}
}
impl
<
T
:
ToShmem
+
Sized
>
ToShmem
for
OwnedSlice
<
T
>
{
fn
to_shmem
(
&
self
builder
:
&
mut
SharedMemoryBuilder
)
-
>
mem
:
:
ManuallyDrop
<
Self
>
{
unsafe
{
let
dest
=
to_shmem
:
:
to_shmem_slice
(
self
.
iter
(
)
builder
)
;
mem
:
:
ManuallyDrop
:
:
new
(
Self
:
:
from
(
Box
:
:
from_raw
(
dest
)
)
)
}
}
}
