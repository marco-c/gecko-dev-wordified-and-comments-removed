use
super
:
:
{
FeatureFlags
FeatureType
QueryFeatureExpression
}
;
use
crate
:
:
values
:
:
computed
;
use
crate
:
:
{
error_reporting
:
:
ContextualParseError
parser
:
:
ParserContext
}
;
use
cssparser
:
:
{
Parser
Token
}
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
ToCss
ToShmem
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
Operator
{
And
Or
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
ToCss
)
]
enum
AllowOr
{
Yes
No
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
ToCss
)
]
pub
enum
KleeneValue
{
False
=
0
True
=
1
Unknown
}
impl
From
<
bool
>
for
KleeneValue
{
fn
from
(
b
:
bool
)
-
>
Self
{
if
b
{
Self
:
:
True
}
else
{
Self
:
:
False
}
}
}
impl
KleeneValue
{
pub
fn
to_bool
(
self
unknown
:
bool
)
-
>
bool
{
match
self
{
Self
:
:
True
=
>
true
Self
:
:
False
=
>
false
Self
:
:
Unknown
=
>
unknown
}
}
}
impl
std
:
:
ops
:
:
Not
for
KleeneValue
{
type
Output
=
Self
;
fn
not
(
self
)
-
>
Self
{
match
self
{
Self
:
:
True
=
>
Self
:
:
False
Self
:
:
False
=
>
Self
:
:
True
Self
:
:
Unknown
=
>
Self
:
:
Unknown
}
}
}
impl
std
:
:
ops
:
:
BitAnd
for
KleeneValue
{
type
Output
=
Self
;
fn
bitand
(
self
other
:
Self
)
-
>
Self
{
if
self
=
=
Self
:
:
False
|
|
other
=
=
Self
:
:
False
{
return
Self
:
:
False
;
}
if
self
=
=
Self
:
:
Unknown
|
|
other
=
=
Self
:
:
Unknown
{
return
Self
:
:
Unknown
;
}
Self
:
:
True
}
}
impl
std
:
:
ops
:
:
BitOr
for
KleeneValue
{
type
Output
=
Self
;
fn
bitor
(
self
other
:
Self
)
-
>
Self
{
if
self
=
=
Self
:
:
True
|
|
other
=
=
Self
:
:
True
{
return
Self
:
:
True
;
}
if
self
=
=
Self
:
:
Unknown
|
|
other
=
=
Self
:
:
Unknown
{
return
Self
:
:
Unknown
;
}
Self
:
:
False
}
}
impl
std
:
:
ops
:
:
BitOrAssign
for
KleeneValue
{
fn
bitor_assign
(
&
mut
self
other
:
Self
)
{
*
self
=
*
self
|
other
;
}
}
impl
std
:
:
ops
:
:
BitAndAssign
for
KleeneValue
{
fn
bitand_assign
(
&
mut
self
other
:
Self
)
{
*
self
=
*
self
&
other
;
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
pub
enum
QueryCondition
{
Feature
(
QueryFeatureExpression
)
Not
(
Box
<
QueryCondition
>
)
Operation
(
Box
<
[
QueryCondition
]
>
Operator
)
InParens
(
Box
<
QueryCondition
>
)
GeneralEnclosed
(
String
)
}
impl
ToCss
for
QueryCondition
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
QueryCondition
:
:
Feature
(
ref
f
)
=
>
f
.
to_css
(
dest
)
QueryCondition
:
:
Not
(
ref
c
)
=
>
{
dest
.
write_str
(
"
not
"
)
?
;
c
.
to_css
(
dest
)
}
QueryCondition
:
:
InParens
(
ref
c
)
=
>
{
dest
.
write_char
(
'
(
'
)
?
;
c
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
)
'
)
}
QueryCondition
:
:
Operation
(
ref
list
op
)
=
>
{
let
mut
iter
=
list
.
iter
(
)
;
iter
.
next
(
)
.
unwrap
(
)
.
to_css
(
dest
)
?
;
for
item
in
iter
{
dest
.
write_char
(
'
'
)
?
;
op
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
item
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
QueryCondition
:
:
GeneralEnclosed
(
ref
s
)
=
>
dest
.
write_str
(
&
s
)
}
}
}
fn
consume_any_value
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
(
)
ParseError
<
'
i
>
>
{
input
.
expect_no_error_token
(
)
.
map_err
(
Into
:
:
into
)
}
impl
QueryCondition
{
pub
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
feature_type
:
FeatureType
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
feature_type
AllowOr
:
:
Yes
)
}
fn
visit
<
F
>
(
&
self
visitor
:
&
mut
F
)
where
F
:
FnMut
(
&
Self
)
{
visitor
(
self
)
;
match
*
self
{
Self
:
:
Feature
(
.
.
)
=
>
{
}
Self
:
:
GeneralEnclosed
(
.
.
)
=
>
{
}
Self
:
:
Not
(
ref
cond
)
=
>
cond
.
visit
(
visitor
)
Self
:
:
Operation
(
ref
conds
_op
)
=
>
{
for
cond
in
conds
.
iter
(
)
{
cond
.
visit
(
visitor
)
;
}
}
Self
:
:
InParens
(
ref
cond
)
=
>
cond
.
visit
(
visitor
)
}
}
pub
fn
cumulative_flags
(
&
self
)
-
>
FeatureFlags
{
let
mut
result
=
FeatureFlags
:
:
empty
(
)
;
self
.
visit
(
&
mut
|
condition
|
{
if
let
Self
:
:
Feature
(
ref
f
)
=
condition
{
result
.
insert
(
f
.
feature_flags
(
)
)
}
}
)
;
result
}
pub
fn
parse_disallow_or
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
feature_type
:
FeatureType
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Self
:
:
parse_internal
(
context
input
feature_type
AllowOr
:
:
No
)
}
fn
parse_internal
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
feature_type
:
FeatureType
allow_or
:
AllowOr
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
not
"
)
)
.
is_ok
(
)
{
let
inner_condition
=
Self
:
:
parse_in_parens
(
context
input
feature_type
)
?
;
return
Ok
(
QueryCondition
:
:
Not
(
Box
:
:
new
(
inner_condition
)
)
)
;
}
let
first_condition
=
Self
:
:
parse_in_parens
(
context
input
feature_type
)
?
;
let
operator
=
match
input
.
try_parse
(
Operator
:
:
parse
)
{
Ok
(
op
)
=
>
op
Err
(
.
.
)
=
>
return
Ok
(
first_condition
)
}
;
if
allow_or
=
=
AllowOr
:
:
No
&
&
operator
=
=
Operator
:
:
Or
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
let
mut
conditions
=
vec
!
[
]
;
conditions
.
push
(
first_condition
)
;
conditions
.
push
(
Self
:
:
parse_in_parens
(
context
input
feature_type
)
?
)
;
let
delim
=
match
operator
{
Operator
:
:
And
=
>
"
and
"
Operator
:
:
Or
=
>
"
or
"
}
;
loop
{
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
delim
)
)
.
is_err
(
)
{
return
Ok
(
QueryCondition
:
:
Operation
(
conditions
.
into_boxed_slice
(
)
operator
)
)
;
}
conditions
.
push
(
Self
:
:
parse_in_parens
(
context
input
feature_type
)
?
)
;
}
}
fn
parse_in_parenthesis_block
<
'
i
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
_
>
feature_type
:
FeatureType
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
feature_error
=
match
input
.
try_parse
(
|
input
|
{
QueryFeatureExpression
:
:
parse_in_parenthesis_block
(
context
input
feature_type
)
}
)
{
Ok
(
expr
)
=
>
return
Ok
(
Self
:
:
Feature
(
expr
)
)
Err
(
e
)
=
>
e
}
;
if
let
Ok
(
inner
)
=
Self
:
:
parse
(
context
input
feature_type
)
{
return
Ok
(
Self
:
:
InParens
(
Box
:
:
new
(
inner
)
)
)
;
}
Err
(
feature_error
)
}
pub
fn
parse_in_parens
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
feature_type
:
FeatureType
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
skip_whitespace
(
)
;
let
start
=
input
.
position
(
)
;
let
start_location
=
input
.
current_source_location
(
)
;
match
*
input
.
next
(
)
?
{
Token
:
:
ParenthesisBlock
=
>
{
let
nested
=
input
.
try_parse
(
|
input
|
{
input
.
parse_nested_block
(
|
input
|
{
Self
:
:
parse_in_parenthesis_block
(
context
input
feature_type
)
}
)
}
)
;
match
nested
{
Ok
(
nested
)
=
>
return
Ok
(
nested
)
Err
(
e
)
=
>
{
let
loc
=
e
.
location
;
let
error
=
ContextualParseError
:
:
InvalidMediaRule
(
input
.
slice_from
(
start
)
e
)
;
context
.
log_css_error
(
loc
error
)
;
}
}
}
Token
:
:
Function
(
.
.
)
=
>
{
}
ref
t
=
>
return
Err
(
start_location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
}
input
.
parse_nested_block
(
consume_any_value
)
?
;
Ok
(
Self
:
:
GeneralEnclosed
(
input
.
slice_from
(
start
)
.
to_owned
(
)
)
)
}
pub
fn
matches
(
&
self
context
:
&
computed
:
:
Context
)
-
>
KleeneValue
{
match
*
self
{
QueryCondition
:
:
Feature
(
ref
f
)
=
>
KleeneValue
:
:
from
(
f
.
matches
(
context
)
)
QueryCondition
:
:
GeneralEnclosed
(
_
)
=
>
KleeneValue
:
:
Unknown
QueryCondition
:
:
InParens
(
ref
c
)
=
>
c
.
matches
(
context
)
QueryCondition
:
:
Not
(
ref
c
)
=
>
!
c
.
matches
(
context
)
QueryCondition
:
:
Operation
(
ref
conditions
op
)
=
>
{
debug_assert
!
(
!
conditions
.
is_empty
(
)
"
We
never
create
an
empty
op
"
)
;
match
op
{
Operator
:
:
And
=
>
{
let
mut
result
=
KleeneValue
:
:
True
;
for
c
in
conditions
.
iter
(
)
{
result
&
=
c
.
matches
(
context
)
;
if
result
=
=
KleeneValue
:
:
False
{
break
;
}
}
result
}
Operator
:
:
Or
=
>
{
let
mut
result
=
KleeneValue
:
:
False
;
for
c
in
conditions
.
iter
(
)
{
result
|
=
c
.
matches
(
context
)
;
if
result
=
=
KleeneValue
:
:
True
{
break
;
}
}
result
}
}
}
}
}
}
