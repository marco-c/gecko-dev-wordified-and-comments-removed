#
!
[
allow
(
unsafe_code
)
]
#
!
[
deny
(
missing_docs
)
]
use
crate
:
:
global_style_data
:
:
STYLO_MAX_THREADS
;
use
std
:
:
cell
:
:
{
Ref
RefCell
RefMut
}
;
use
std
:
:
ops
:
:
DerefMut
;
pub
struct
ScopedTLS
<
'
scope
T
:
Send
>
{
pool
:
Option
<
&
'
scope
rayon
:
:
ThreadPool
>
slots
:
[
RefCell
<
Option
<
T
>
>
;
STYLO_MAX_THREADS
]
}
unsafe
impl
<
'
scope
T
:
Send
>
Sync
for
ScopedTLS
<
'
scope
T
>
{
}
impl
<
'
scope
T
:
Send
>
ScopedTLS
<
'
scope
T
>
{
pub
fn
new
(
pool
:
Option
<
&
'
scope
rayon
:
:
ThreadPool
>
)
-
>
Self
{
debug_assert
!
(
pool
.
map_or
(
true
|
p
|
p
.
current_num_threads
(
)
<
=
STYLO_MAX_THREADS
)
)
;
ScopedTLS
{
pool
slots
:
Default
:
:
default
(
)
}
}
#
[
inline
]
pub
fn
current_thread_index
(
&
self
)
-
>
usize
{
self
.
pool
.
map_or
(
0
|
p
|
p
.
current_thread_index
(
)
.
unwrap
(
)
)
}
pub
fn
borrow
(
&
self
)
-
>
Ref
<
'
_
Option
<
T
>
>
{
let
idx
=
self
.
current_thread_index
(
)
;
self
.
slots
[
idx
]
.
borrow
(
)
}
pub
fn
borrow_mut
(
&
self
)
-
>
RefMut
<
'
_
Option
<
T
>
>
{
let
idx
=
self
.
current_thread_index
(
)
;
self
.
slots
[
idx
]
.
borrow_mut
(
)
}
#
[
inline
(
always
)
]
pub
fn
ensure
<
F
:
FnOnce
(
&
mut
Option
<
T
>
)
>
(
&
self
f
:
F
)
-
>
RefMut
<
'
_
T
>
{
let
mut
opt
=
self
.
borrow_mut
(
)
;
if
opt
.
is_none
(
)
{
f
(
opt
.
deref_mut
(
)
)
;
}
RefMut
:
:
map
(
opt
|
x
|
x
.
as_mut
(
)
.
unwrap
(
)
)
}
pub
fn
slots
(
&
mut
self
)
-
>
&
mut
[
RefCell
<
Option
<
T
>
>
]
{
&
mut
self
.
slots
}
}
