use
{
Atom
LocalName
Namespace
}
;
use
applicable_declarations
:
:
{
ApplicableDeclarationBlock
ApplicableDeclarationList
}
;
use
bit_vec
:
:
BitVec
;
use
context
:
:
{
CascadeInputs
QuirksMode
}
;
use
dom
:
:
TElement
;
use
element_state
:
:
ElementState
;
use
font_metrics
:
:
FontMetricsProvider
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
structs
:
:
{
nsIAtom
ServoStyleSetSizes
StyleRuleInclusion
}
;
use
invalidation
:
:
element
:
:
invalidation_map
:
:
InvalidationMap
;
use
invalidation
:
:
media_queries
:
:
{
EffectiveMediaQueryResults
ToMediaListKey
}
;
use
media_queries
:
:
Device
;
use
properties
:
:
{
self
CascadeFlags
ComputedValues
}
;
use
properties
:
:
{
AnimationRules
PropertyDeclarationBlock
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
properties
:
:
INHERIT_ALL
;
use
properties
:
:
IS_LINK
;
use
rule_tree
:
:
{
CascadeLevel
RuleTree
StrongRuleNode
StyleSource
}
;
use
selector_map
:
:
{
PrecomputedHashMap
SelectorMap
SelectorMapEntry
}
;
use
selector_parser
:
:
{
SelectorImpl
PerPseudoElementMap
PseudoElement
}
;
use
selectors
:
:
attr
:
:
NamespaceConstraint
;
use
selectors
:
:
bloom
:
:
{
BloomFilter
NonCountingBloomFilter
}
;
use
selectors
:
:
matching
:
:
{
ElementSelectorFlags
matches_selector
MatchingContext
MatchingMode
}
;
use
selectors
:
:
matching
:
:
VisitedHandlingMode
;
use
selectors
:
:
parser
:
:
{
AncestorHashes
Combinator
Component
Selector
}
;
use
selectors
:
:
parser
:
:
{
SelectorIter
SelectorMethods
}
;
use
selectors
:
:
sink
:
:
Push
;
use
selectors
:
:
visitor
:
:
SelectorVisitor
;
use
servo_arc
:
:
{
Arc
ArcBorrow
}
;
use
shared_lock
:
:
{
Locked
SharedRwLockReadGuard
StylesheetGuards
}
;
use
smallvec
:
:
VecLike
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
ops
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
use
stylesheet_set
:
:
{
OriginValidity
SheetRebuildKind
StylesheetSet
StylesheetIterator
StylesheetFlusher
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
stylesheets
:
:
{
CounterStyleRule
FontFaceRule
FontFeatureValuesRule
PageRule
}
;
use
stylesheets
:
:
{
CssRule
Origin
OriginSet
PerOrigin
PerOriginIter
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
stylesheets
:
:
{
MallocEnclosingSizeOfFn
MallocSizeOf
MallocSizeOfBox
MallocSizeOfFn
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
stylesheets
:
:
{
MallocSizeOfHash
MallocSizeOfVec
}
;
use
stylesheets
:
:
StyleRule
;
use
stylesheets
:
:
StylesheetInDocument
;
use
stylesheets
:
:
UserAgentStylesheets
;
use
stylesheets
:
:
keyframes_rule
:
:
KeyframesAnimation
;
use
stylesheets
:
:
viewport_rule
:
:
{
self
MaybeNew
ViewportRule
}
;
use
thread_state
;
pub
use
:
:
fnv
:
:
FnvHashMap
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
type
StylistSheet
=
:
:
stylesheets
:
:
DocumentStyleSheet
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
type
StylistSheet
=
:
:
gecko
:
:
data
:
:
GeckoStyleSheet
;
#
[
derive
(
Default
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
struct
DocumentCascadeData
{
per_origin
:
PerOrigin
<
CascadeData
>
precomputed_pseudo_element_decls
:
PerPseudoElementMap
<
Vec
<
ApplicableDeclarationBlock
>
>
}
impl
DocumentCascadeData
{
fn
iter_origins
(
&
self
)
-
>
PerOriginIter
<
CascadeData
>
{
self
.
per_origin
.
iter_origins
(
)
}
fn
rebuild
<
'
a
'
b
S
>
(
&
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
flusher
:
StylesheetFlusher
<
'
a
'
b
S
>
guards
:
&
StylesheetGuards
ua_stylesheets
:
Option
<
&
UserAgentStylesheets
>
extra_data
:
&
mut
PerOrigin
<
ExtraStyleData
>
)
where
'
b
:
'
a
S
:
StylesheetInDocument
+
ToMediaListKey
+
PartialEq
+
'
static
{
debug_assert
!
(
!
flusher
.
nothing_to_do
(
)
)
;
for
(
cascade_data
origin
)
in
self
.
per_origin
.
iter_mut_origins
(
)
{
let
validity
=
flusher
.
origin_validity
(
origin
)
;
if
validity
=
=
OriginValidity
:
:
Valid
{
continue
;
}
if
origin
=
=
Origin
:
:
UserAgent
{
self
.
precomputed_pseudo_element_decls
.
clear
(
)
;
}
extra_data
.
borrow_mut_for_origin
(
&
origin
)
.
clear
(
)
;
if
validity
=
=
OriginValidity
:
:
CascadeInvalid
{
cascade_data
.
clear_cascade_data
(
)
}
else
{
debug_assert_eq
!
(
validity
OriginValidity
:
:
FullyInvalid
)
;
cascade_data
.
clear
(
)
;
}
}
if
let
Some
(
ua_stylesheets
)
=
ua_stylesheets
{
debug_assert
!
(
cfg
!
(
feature
=
"
servo
"
)
)
;
for
stylesheet
in
&
ua_stylesheets
.
user_or_user_agent_stylesheets
{
let
sheet_origin
=
stylesheet
.
contents
(
guards
.
ua_or_user
)
.
origin
;
debug_assert
!
(
matches
!
(
sheet_origin
Origin
:
:
UserAgent
|
Origin
:
:
User
)
)
;
let
validity
=
flusher
.
origin_validity
(
sheet_origin
)
;
debug_assert
!
(
matches
!
(
validity
OriginValidity
:
:
Valid
|
OriginValidity
:
:
FullyInvalid
)
)
;
if
validity
=
=
OriginValidity
:
:
Valid
{
continue
;
}
self
.
add_stylesheet
(
device
quirks_mode
stylesheet
guards
.
ua_or_user
extra_data
SheetRebuildKind
:
:
Full
)
;
}
if
quirks_mode
!
=
QuirksMode
:
:
NoQuirks
{
let
stylesheet
=
&
ua_stylesheets
.
quirks_mode_stylesheet
;
let
sheet_origin
=
stylesheet
.
contents
(
guards
.
ua_or_user
)
.
origin
;
debug_assert
!
(
matches
!
(
sheet_origin
Origin
:
:
UserAgent
|
Origin
:
:
User
)
)
;
let
validity
=
flusher
.
origin_validity
(
sheet_origin
)
;
debug_assert
!
(
matches
!
(
validity
OriginValidity
:
:
Valid
|
OriginValidity
:
:
FullyInvalid
)
)
;
if
validity
!
=
OriginValidity
:
:
Valid
{
self
.
add_stylesheet
(
device
quirks_mode
&
ua_stylesheets
.
quirks_mode_stylesheet
guards
.
ua_or_user
extra_data
SheetRebuildKind
:
:
Full
)
;
}
}
}
for
(
stylesheet
rebuild_kind
)
in
flusher
{
self
.
add_stylesheet
(
device
quirks_mode
stylesheet
guards
.
author
extra_data
rebuild_kind
)
;
}
}
fn
add_stylesheet
<
S
>
(
&
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
stylesheet
:
&
S
guard
:
&
SharedRwLockReadGuard
_extra_data
:
&
mut
PerOrigin
<
ExtraStyleData
>
rebuild_kind
:
SheetRebuildKind
)
where
S
:
StylesheetInDocument
+
ToMediaListKey
+
'
static
{
if
!
stylesheet
.
enabled
(
)
|
|
!
stylesheet
.
is_effective_for_device
(
device
guard
)
{
return
;
}
let
origin
=
stylesheet
.
origin
(
guard
)
;
let
origin_cascade_data
=
self
.
per_origin
.
borrow_mut_for_origin
(
&
origin
)
;
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
origin_cascade_data
.
effective_media_query_results
.
saw_effective
(
stylesheet
)
;
}
for
rule
in
stylesheet
.
effective_rules
(
device
guard
)
{
match
*
rule
{
CssRule
:
:
Style
(
ref
locked
)
=
>
{
let
style_rule
=
locked
.
read_with
(
&
guard
)
;
origin_cascade_data
.
num_declarations
+
=
style_rule
.
block
.
read_with
(
&
guard
)
.
len
(
)
;
for
selector
in
&
style_rule
.
selectors
.
0
{
origin_cascade_data
.
num_selectors
+
=
1
;
let
map
=
match
selector
.
pseudo_element
(
)
{
Some
(
pseudo
)
if
pseudo
.
is_precomputed
(
)
=
>
{
if
!
selector
.
is_universal
(
)
|
|
!
matches
!
(
origin
Origin
:
:
UserAgent
)
{
continue
;
}
self
.
precomputed_pseudo_element_decls
.
get_or_insert_with
(
&
pseudo
.
canonical
(
)
Vec
:
:
new
)
.
expect
(
"
Unexpected
tree
pseudo
-
element
?
"
)
.
push
(
ApplicableDeclarationBlock
:
:
new
(
StyleSource
:
:
Style
(
locked
.
clone
(
)
)
origin_cascade_data
.
rules_source_order
CascadeLevel
:
:
UANormal
selector
.
specificity
(
)
)
)
;
continue
;
}
None
=
>
&
mut
origin_cascade_data
.
element_map
Some
(
pseudo
)
=
>
{
origin_cascade_data
.
pseudos_map
.
get_or_insert_with
(
&
pseudo
.
canonical
(
)
|
|
Box
:
:
new
(
SelectorMap
:
:
new
(
)
)
)
.
expect
(
"
Unexpected
tree
pseudo
-
element
?
"
)
}
}
;
let
hashes
=
AncestorHashes
:
:
new
(
&
selector
quirks_mode
)
;
let
rule
=
Rule
:
:
new
(
selector
.
clone
(
)
hashes
.
clone
(
)
locked
.
clone
(
)
origin_cascade_data
.
rules_source_order
)
;
map
.
insert
(
rule
quirks_mode
)
;
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
origin_cascade_data
.
invalidation_map
.
note_selector
(
selector
quirks_mode
)
;
let
mut
visitor
=
StylistSelectorVisitor
{
needs_revalidation
:
false
passed_rightmost_selector
:
false
attribute_dependencies
:
&
mut
origin_cascade_data
.
attribute_dependencies
style_attribute_dependency
:
&
mut
origin_cascade_data
.
style_attribute_dependency
state_dependencies
:
&
mut
origin_cascade_data
.
state_dependencies
mapped_ids
:
&
mut
origin_cascade_data
.
mapped_ids
}
;
selector
.
visit
(
&
mut
visitor
)
;
if
visitor
.
needs_revalidation
{
origin_cascade_data
.
selectors_for_cache_revalidation
.
insert
(
RevalidationSelectorAndHashes
:
:
new
(
selector
.
clone
(
)
hashes
)
quirks_mode
)
;
}
}
}
origin_cascade_data
.
rules_source_order
+
=
1
;
}
CssRule
:
:
Import
(
ref
lock
)
=
>
{
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
origin_cascade_data
.
effective_media_query_results
.
saw_effective
(
import_rule
)
;
}
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
let
media_rule
=
lock
.
read_with
(
guard
)
;
origin_cascade_data
.
effective_media_query_results
.
saw_effective
(
media_rule
)
;
}
}
CssRule
:
:
Keyframes
(
ref
keyframes_rule
)
=
>
{
let
keyframes_rule
=
keyframes_rule
.
read_with
(
guard
)
;
debug
!
(
"
Found
valid
keyframes
rule
:
{
:
?
}
"
*
keyframes_rule
)
;
let
needs_insertion
=
keyframes_rule
.
vendor_prefix
.
is_none
(
)
|
|
origin_cascade_data
.
animations
.
get
(
keyframes_rule
.
name
.
as_atom
(
)
)
.
map_or
(
true
|
rule
|
rule
.
vendor_prefix
.
is_some
(
)
)
;
if
needs_insertion
{
let
animation
=
KeyframesAnimation
:
:
from_keyframes
(
&
keyframes_rule
.
keyframes
keyframes_rule
.
vendor_prefix
.
clone
(
)
guard
)
;
debug
!
(
"
Found
valid
keyframe
animation
:
{
:
?
}
"
animation
)
;
origin_cascade_data
.
animations
.
insert
(
keyframes_rule
.
name
.
as_atom
(
)
.
clone
(
)
animation
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
FontFace
(
ref
rule
)
=
>
{
_extra_data
.
borrow_mut_for_origin
(
&
origin
)
.
add_font_face
(
rule
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
FontFeatureValues
(
ref
rule
)
=
>
{
_extra_data
.
borrow_mut_for_origin
(
&
origin
)
.
add_font_feature_values
(
rule
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
CounterStyle
(
ref
rule
)
=
>
{
_extra_data
.
borrow_mut_for_origin
(
&
origin
)
.
add_counter_style
(
guard
rule
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
Page
(
ref
rule
)
=
>
{
_extra_data
.
borrow_mut_for_origin
(
&
origin
)
.
add_page
(
rule
)
;
}
_
=
>
{
}
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
malloc_add_size_of_children
(
&
self
malloc_size_of
:
MallocSizeOfFn
malloc_enclosing_size_of
:
MallocEnclosingSizeOfFn
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
per_origin
.
user_agent
.
malloc_add_size_of_children
(
malloc_size_of
malloc_enclosing_size_of
sizes
)
;
self
.
per_origin
.
user
.
malloc_add_size_of_children
(
malloc_size_of
malloc_enclosing_size_of
sizes
)
;
self
.
per_origin
.
author
.
malloc_add_size_of_children
(
malloc_size_of
malloc_enclosing_size_of
sizes
)
;
for
elem
in
self
.
precomputed_pseudo_element_decls
.
iter
(
)
{
if
let
Some
(
ref
elem
)
=
*
elem
{
sizes
.
mStylistPrecomputedPseudos
+
=
elem
.
malloc_shallow_size_of_vec
(
malloc_size_of
)
;
}
}
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
struct
StylistStylesheetSet
(
StylesheetSet
<
StylistSheet
>
)
;
unsafe
impl
Sync
for
StylistStylesheetSet
{
}
impl
StylistStylesheetSet
{
fn
new
(
)
-
>
Self
{
StylistStylesheetSet
(
StylesheetSet
:
:
new
(
)
)
}
}
impl
ops
:
:
Deref
for
StylistStylesheetSet
{
type
Target
=
StylesheetSet
<
StylistSheet
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
ops
:
:
DerefMut
for
StylistStylesheetSet
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
Stylist
{
device
:
Device
viewport_constraints
:
Option
<
ViewportConstraints
>
stylesheets
:
StylistStylesheetSet
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
defined
in
selectors
"
)
]
quirks_mode
:
QuirksMode
cascade_data
:
DocumentCascadeData
rule_tree
:
RuleTree
num_rebuilds
:
usize
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
RuleInclusion
{
All
DefaultOnly
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
StyleRuleInclusion
>
for
RuleInclusion
{
fn
from
(
value
:
StyleRuleInclusion
)
-
>
Self
{
match
value
{
StyleRuleInclusion
:
:
All
=
>
RuleInclusion
:
:
All
StyleRuleInclusion
:
:
DefaultOnly
=
>
RuleInclusion
:
:
DefaultOnly
}
}
}
impl
Stylist
{
#
[
inline
]
pub
fn
new
(
device
:
Device
quirks_mode
:
QuirksMode
)
-
>
Self
{
Self
{
viewport_constraints
:
None
device
quirks_mode
stylesheets
:
StylistStylesheetSet
:
:
new
(
)
cascade_data
:
Default
:
:
default
(
)
rule_tree
:
RuleTree
:
:
new
(
)
num_rebuilds
:
0
}
}
pub
fn
num_selectors
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
d
_
)
|
d
.
num_selectors
)
.
sum
(
)
}
pub
fn
num_declarations
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
d
_
)
|
d
.
num_declarations
)
.
sum
(
)
}
pub
fn
num_rebuilds
(
&
self
)
-
>
usize
{
self
.
num_rebuilds
}
pub
fn
num_revalidation_selectors
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
d
_
)
|
d
.
selectors_for_cache_revalidation
.
len
(
)
)
.
sum
(
)
}
pub
fn
num_invalidations
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
d
_
)
|
d
.
invalidation_map
.
len
(
)
)
.
sum
(
)
}
pub
fn
each_invalidation_map
<
F
>
(
&
self
mut
f
:
F
)
where
F
:
FnMut
(
&
InvalidationMap
)
{
for
(
data
_
)
in
self
.
cascade_data
.
iter_origins
(
)
{
f
(
&
data
.
invalidation_map
)
}
}
pub
fn
flush
<
E
>
(
&
mut
self
guards
:
&
StylesheetGuards
ua_sheets
:
Option
<
&
UserAgentStylesheets
>
extra_data
:
&
mut
PerOrigin
<
ExtraStyleData
>
document_element
:
Option
<
E
>
)
-
>
bool
where
E
:
TElement
{
if
!
self
.
stylesheets
.
has_changed
(
)
{
return
false
;
}
self
.
num_rebuilds
+
=
1
;
self
.
viewport_constraints
=
None
;
if
viewport_rule
:
:
enabled
(
)
{
let
cascaded_rule
=
ViewportRule
{
declarations
:
viewport_rule
:
:
Cascade
:
:
from_stylesheets
(
self
.
stylesheets
.
iter
(
)
guards
.
author
&
self
.
device
)
.
finish
(
)
}
;
self
.
viewport_constraints
=
ViewportConstraints
:
:
maybe_new
(
&
self
.
device
&
cascaded_rule
self
.
quirks_mode
)
;
if
let
Some
(
ref
constraints
)
=
self
.
viewport_constraints
{
self
.
device
.
account_for_viewport_rule
(
constraints
)
;
}
}
let
flusher
=
self
.
stylesheets
.
flush
(
document_element
&
guards
.
author
)
;
let
had_invalidations
=
flusher
.
had_invalidations
(
)
;
self
.
cascade_data
.
rebuild
(
&
self
.
device
self
.
quirks_mode
flusher
guards
ua_sheets
extra_data
)
;
had_invalidations
}
pub
fn
insert_stylesheet_before
(
&
mut
self
sheet
:
StylistSheet
before_sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
insert_stylesheet_before
(
Some
(
&
self
.
device
)
sheet
before_sheet
guard
)
}
pub
fn
force_stylesheet_origins_dirty
(
&
mut
self
origins
:
OriginSet
)
{
self
.
stylesheets
.
force_dirty
(
origins
)
}
pub
fn
iter_stylesheets
(
&
mut
self
)
-
>
StylesheetIterator
<
StylistSheet
>
{
self
.
stylesheets
.
iter
(
)
}
pub
fn
set_author_style_disabled
(
&
mut
self
disabled
:
bool
)
{
self
.
stylesheets
.
set_author_style_disabled
(
disabled
)
;
}
pub
fn
stylesheets_have_changed
(
&
self
)
-
>
bool
{
self
.
stylesheets
.
has_changed
(
)
}
pub
fn
append_stylesheet
(
&
mut
self
sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
append_stylesheet
(
Some
(
&
self
.
device
)
sheet
guard
)
}
pub
fn
prepend_stylesheet
(
&
mut
self
sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
prepend_stylesheet
(
Some
(
&
self
.
device
)
sheet
guard
)
}
pub
fn
remove_stylesheet
(
&
mut
self
sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
remove_stylesheet
(
Some
(
&
self
.
device
)
sheet
guard
)
}
pub
fn
might_have_attribute_dependency
(
&
self
local_name
:
&
LocalName
)
-
>
bool
{
if
*
local_name
=
=
local_name
!
(
"
style
"
)
{
self
.
cascade_data
.
iter_origins
(
)
.
any
(
|
(
d
_
)
|
d
.
style_attribute_dependency
)
}
else
{
self
.
cascade_data
.
iter_origins
(
)
.
any
(
|
(
d
_
)
|
{
d
.
attribute_dependencies
.
might_contain_hash
(
local_name
.
get_hash
(
)
)
}
)
}
}
pub
fn
might_have_state_dependency
(
&
self
state
:
ElementState
)
-
>
bool
{
self
.
has_state_dependency
(
state
)
}
pub
fn
has_state_dependency
(
&
self
state
:
ElementState
)
-
>
bool
{
self
.
cascade_data
.
iter_origins
(
)
.
any
(
|
(
d
_
)
|
d
.
state_dependencies
.
intersects
(
state
)
)
}
pub
fn
precomputed_values_for_pseudo
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent
:
Option
<
&
ComputedValues
>
cascade_flags
:
CascadeFlags
font_metrics
:
&
FontMetricsProvider
)
-
>
Arc
<
ComputedValues
>
{
debug_assert
!
(
pseudo
.
is_precomputed
(
)
)
;
let
rule_node
=
self
.
rule_node_for_precomputed_pseudo
(
guards
pseudo
None
)
;
self
.
precomputed_values_for_pseudo_with_rule_node
(
guards
pseudo
parent
cascade_flags
font_metrics
&
rule_node
)
}
pub
fn
precomputed_values_for_pseudo_with_rule_node
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent
:
Option
<
&
ComputedValues
>
cascade_flags
:
CascadeFlags
font_metrics
:
&
FontMetricsProvider
rule_node
:
&
StrongRuleNode
)
-
>
Arc
<
ComputedValues
>
{
properties
:
:
cascade
(
&
self
.
device
Some
(
pseudo
)
rule_node
guards
parent
parent
parent
None
font_metrics
cascade_flags
self
.
quirks_mode
)
}
pub
fn
rule_node_for_precomputed_pseudo
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
extra_declarations
:
Option
<
Vec
<
ApplicableDeclarationBlock
>
>
)
-
>
StrongRuleNode
{
let
mut
decl
;
let
declarations
=
match
self
.
cascade_data
.
precomputed_pseudo_element_decls
.
get
(
pseudo
)
{
Some
(
declarations
)
=
>
{
match
extra_declarations
{
Some
(
mut
extra_decls
)
=
>
{
decl
=
declarations
.
clone
(
)
;
decl
.
append
(
&
mut
extra_decls
)
;
Some
(
&
decl
)
}
None
=
>
Some
(
declarations
)
}
}
None
=
>
extra_declarations
.
as_ref
(
)
}
;
match
declarations
{
Some
(
decls
)
=
>
{
self
.
rule_tree
.
insert_ordered_rules_with_important
(
decls
.
into_iter
(
)
.
map
(
|
a
|
(
a
.
source
.
clone
(
)
a
.
level
(
)
)
)
guards
)
}
None
=
>
self
.
rule_tree
.
root
(
)
.
clone
(
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
style_for_anonymous
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent_style
:
&
ComputedValues
)
-
>
Arc
<
ComputedValues
>
{
use
font_metrics
:
:
ServoMetricsProvider
;
let
inherit_all
=
match
*
pseudo
{
PseudoElement
:
:
ServoText
|
PseudoElement
:
:
ServoInputText
=
>
false
PseudoElement
:
:
ServoAnonymousBlock
|
PseudoElement
:
:
ServoAnonymousTable
|
PseudoElement
:
:
ServoAnonymousTableCell
|
PseudoElement
:
:
ServoAnonymousTableRow
|
PseudoElement
:
:
ServoAnonymousTableWrapper
|
PseudoElement
:
:
ServoTableWrapper
|
PseudoElement
:
:
ServoInlineBlockWrapper
|
PseudoElement
:
:
ServoInlineAbsolute
=
>
true
PseudoElement
:
:
Before
|
PseudoElement
:
:
After
|
PseudoElement
:
:
Selection
|
PseudoElement
:
:
DetailsSummary
|
PseudoElement
:
:
DetailsContent
=
>
{
unreachable
!
(
"
That
pseudo
doesn
'
t
represent
an
anonymous
box
!
"
)
}
}
;
let
mut
cascade_flags
=
CascadeFlags
:
:
empty
(
)
;
if
inherit_all
{
cascade_flags
.
insert
(
INHERIT_ALL
)
;
}
self
.
precomputed_values_for_pseudo
(
guards
&
pseudo
Some
(
parent_style
)
cascade_flags
&
ServoMetricsProvider
)
}
pub
fn
lazily_compute_pseudo_element_style
<
E
>
(
&
self
guards
:
&
StylesheetGuards
element
:
&
E
pseudo
:
&
PseudoElement
rule_inclusion
:
RuleInclusion
parent_style
:
&
ComputedValues
is_probe
:
bool
font_metrics
:
&
FontMetricsProvider
)
-
>
Option
<
Arc
<
ComputedValues
>
>
where
E
:
TElement
{
let
cascade_inputs
=
self
.
lazy_pseudo_rules
(
guards
element
pseudo
is_probe
rule_inclusion
)
;
self
.
compute_pseudo_element_style_with_inputs
(
&
cascade_inputs
pseudo
guards
parent_style
font_metrics
)
}
pub
fn
compute_pseudo_element_style_with_inputs
(
&
self
inputs
:
&
CascadeInputs
pseudo
:
&
PseudoElement
guards
:
&
StylesheetGuards
parent_style
:
&
ComputedValues
font_metrics
:
&
FontMetricsProvider
)
-
>
Option
<
Arc
<
ComputedValues
>
>
{
if
inputs
.
rules
.
is_none
(
)
&
&
inputs
.
visited_rules
.
is_none
(
)
{
return
None
}
Some
(
self
.
compute_style_with_inputs
(
inputs
Some
(
pseudo
)
guards
parent_style
parent_style
parent_style
font_metrics
CascadeFlags
:
:
empty
(
)
)
)
}
pub
fn
compute_style_with_inputs
(
&
self
inputs
:
&
CascadeInputs
pseudo
:
Option
<
&
PseudoElement
>
guards
:
&
StylesheetGuards
parent_style
:
&
ComputedValues
parent_style_ignoring_first_line
:
&
ComputedValues
layout_parent_style
:
&
ComputedValues
font_metrics
:
&
FontMetricsProvider
cascade_flags
:
CascadeFlags
)
-
>
Arc
<
ComputedValues
>
{
let
visited_values
=
if
inputs
.
visited_rules
.
is_some
(
)
|
|
parent_style
.
get_visited_style
(
)
.
is_some
(
)
{
let
rule_node
=
match
inputs
.
visited_rules
.
as_ref
(
)
{
Some
(
rules
)
=
>
rules
None
=
>
inputs
.
rules
.
as_ref
(
)
.
unwrap
(
)
}
;
let
inherited_style
;
let
inherited_style_ignoring_first_line
;
let
layout_parent_style_for_visited
;
if
cascade_flags
.
contains
(
IS_LINK
)
{
inherited_style
=
parent_style
;
inherited_style_ignoring_first_line
=
parent_style_ignoring_first_line
;
layout_parent_style_for_visited
=
layout_parent_style
;
}
else
{
inherited_style
=
parent_style
.
get_visited_style
(
)
.
unwrap_or
(
parent_style
)
;
inherited_style_ignoring_first_line
=
parent_style_ignoring_first_line
.
get_visited_style
(
)
.
unwrap_or
(
parent_style_ignoring_first_line
)
;
layout_parent_style_for_visited
=
layout_parent_style
.
get_visited_style
(
)
.
unwrap_or
(
layout_parent_style
)
;
}
Some
(
properties
:
:
cascade
(
&
self
.
device
pseudo
rule_node
guards
Some
(
inherited_style
)
Some
(
inherited_style_ignoring_first_line
)
Some
(
layout_parent_style_for_visited
)
None
font_metrics
cascade_flags
self
.
quirks_mode
)
)
}
else
{
None
}
;
let
rules
=
inputs
.
rules
.
as_ref
(
)
.
unwrap_or
(
self
.
rule_tree
.
root
(
)
)
;
properties
:
:
cascade
(
&
self
.
device
pseudo
rules
guards
Some
(
parent_style
)
Some
(
parent_style_ignoring_first_line
)
Some
(
layout_parent_style
)
visited_values
font_metrics
cascade_flags
self
.
quirks_mode
)
}
fn
has_rules_for_pseudo
(
&
self
pseudo
:
&
PseudoElement
)
-
>
bool
{
self
.
cascade_data
.
iter_origins
(
)
.
any
(
|
(
d
_
)
|
d
.
has_rules_for_pseudo
(
pseudo
)
)
}
pub
fn
lazy_pseudo_rules
<
E
>
(
&
self
guards
:
&
StylesheetGuards
element
:
&
E
pseudo
:
&
PseudoElement
is_probe
:
bool
rule_inclusion
:
RuleInclusion
)
-
>
CascadeInputs
where
E
:
TElement
{
let
pseudo
=
pseudo
.
canonical
(
)
;
debug_assert
!
(
pseudo
.
is_lazy
(
)
)
;
if
!
self
.
has_rules_for_pseudo
(
&
pseudo
)
{
return
CascadeInputs
:
:
default
(
)
}
let
mut
set_selector_flags
=
|
element
:
&
E
flags
:
ElementSelectorFlags
|
{
if
cfg
!
(
feature
=
"
servo
"
)
{
unreachable
!
(
"
internal
pseudo
generated
slow
selector
flags
?
"
)
;
}
if
rule_inclusion
=
=
RuleInclusion
:
:
DefaultOnly
{
return
;
}
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
let
self_flags
=
flags
.
for_self
(
)
;
if
!
self_flags
.
is_empty
(
)
{
unsafe
{
element
.
set_selector_flags
(
self_flags
)
;
}
}
let
parent_flags
=
flags
.
for_parent
(
)
;
if
!
parent_flags
.
is_empty
(
)
{
if
let
Some
(
p
)
=
element
.
parent_element
(
)
{
unsafe
{
p
.
set_selector_flags
(
parent_flags
)
;
}
}
}
}
;
let
mut
inputs
=
CascadeInputs
:
:
default
(
)
;
let
mut
declarations
=
ApplicableDeclarationList
:
:
new
(
)
;
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
ForStatelessPseudoElement
None
self
.
quirks_mode
)
;
self
.
push_applicable_declarations
(
element
Some
(
&
pseudo
)
None
None
AnimationRules
(
None
None
)
rule_inclusion
&
mut
declarations
&
mut
matching_context
&
mut
set_selector_flags
)
;
if
!
declarations
.
is_empty
(
)
{
let
rule_node
=
self
.
rule_tree
.
compute_rule_node
(
&
mut
declarations
guards
)
;
debug_assert
!
(
rule_node
!
=
*
self
.
rule_tree
.
root
(
)
)
;
inputs
.
rules
=
Some
(
rule_node
)
;
}
if
is_probe
&
&
inputs
.
rules
.
is_none
(
)
{
return
inputs
;
}
if
matching_context
.
relevant_link_found
{
let
mut
declarations
=
ApplicableDeclarationList
:
:
new
(
)
;
let
mut
matching_context
=
MatchingContext
:
:
new_for_visited
(
MatchingMode
:
:
ForStatelessPseudoElement
None
VisitedHandlingMode
:
:
RelevantLinkVisited
self
.
quirks_mode
)
;
self
.
push_applicable_declarations
(
element
Some
(
&
pseudo
)
None
None
AnimationRules
(
None
None
)
rule_inclusion
&
mut
declarations
&
mut
matching_context
&
mut
set_selector_flags
)
;
if
!
declarations
.
is_empty
(
)
{
let
rule_node
=
self
.
rule_tree
.
insert_ordered_rules_with_important
(
declarations
.
drain
(
)
.
map
(
|
a
|
a
.
order_and_level
(
)
)
guards
)
;
if
rule_node
!
=
*
self
.
rule_tree
.
root
(
)
{
inputs
.
visited_rules
=
Some
(
rule_node
)
;
}
}
}
inputs
}
pub
fn
set_device
(
&
mut
self
mut
device
:
Device
guard
:
&
SharedRwLockReadGuard
)
-
>
OriginSet
{
if
viewport_rule
:
:
enabled
(
)
{
let
cascaded_rule
=
{
let
stylesheets
=
self
.
stylesheets
.
iter
(
)
;
ViewportRule
{
declarations
:
viewport_rule
:
:
Cascade
:
:
from_stylesheets
(
stylesheets
.
clone
(
)
guard
&
device
)
.
finish
(
)
}
}
;
self
.
viewport_constraints
=
ViewportConstraints
:
:
maybe_new
(
&
device
&
cascaded_rule
self
.
quirks_mode
)
;
if
let
Some
(
ref
constraints
)
=
self
.
viewport_constraints
{
device
.
account_for_viewport_rule
(
constraints
)
;
}
}
self
.
device
=
device
;
self
.
media_features_change_changed_style
(
guard
)
}
pub
fn
media_features_change_changed_style
(
&
self
guard
:
&
SharedRwLockReadGuard
)
-
>
OriginSet
{
use
invalidation
:
:
media_queries
:
:
PotentiallyEffectiveMediaRules
;
debug
!
(
"
Stylist
:
:
media_features_change_changed_style
"
)
;
let
mut
origins
=
OriginSet
:
:
empty
(
)
;
let
stylesheets
=
self
.
stylesheets
.
iter
(
)
;
'
stylesheets_loop
:
for
stylesheet
in
stylesheets
{
let
effective_now
=
stylesheet
.
is_effective_for_device
(
&
self
.
device
guard
)
;
let
origin
=
stylesheet
.
origin
(
guard
)
;
if
origins
.
contains
(
origin
.
into
(
)
)
{
continue
;
}
let
origin_cascade_data
=
self
.
cascade_data
.
per_origin
.
borrow_for_origin
(
&
origin
)
;
let
effective_then
=
origin_cascade_data
.
effective_media_query_results
.
was_effective
(
stylesheet
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
Stylesheet
changed
-
>
{
}
{
}
"
effective_then
effective_now
)
;
origins
|
=
origin
;
continue
;
}
if
!
effective_now
{
continue
;
}
let
mut
iter
=
stylesheet
.
iter_rules
:
:
<
PotentiallyEffectiveMediaRules
>
(
&
self
.
device
guard
)
;
while
let
Some
(
rule
)
=
iter
.
next
(
)
{
match
*
rule
{
CssRule
:
:
Style
(
.
.
)
|
CssRule
:
:
Namespace
(
.
.
)
|
CssRule
:
:
FontFace
(
.
.
)
|
CssRule
:
:
CounterStyle
(
.
.
)
|
CssRule
:
:
Supports
(
.
.
)
|
CssRule
:
:
Keyframes
(
.
.
)
|
CssRule
:
:
Page
(
.
.
)
|
CssRule
:
:
Viewport
(
.
.
)
|
CssRule
:
:
Document
(
.
.
)
|
CssRule
:
:
FontFeatureValues
(
.
.
)
=
>
{
continue
;
}
CssRule
:
:
Import
(
ref
lock
)
=
>
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
let
effective_now
=
import_rule
.
stylesheet
.
is_effective_for_device
(
&
self
.
device
guard
)
;
let
effective_then
=
origin_cascade_data
.
effective_media_query_results
.
was_effective
(
import_rule
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
import
rule
changed
{
}
-
>
{
}
"
effective_then
effective_now
)
;
origins
|
=
origin
;
continue
'
stylesheets_loop
;
}
if
!
effective_now
{
iter
.
skip_children
(
)
;
}
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
let
media_rule
=
lock
.
read_with
(
guard
)
;
let
mq
=
media_rule
.
media_queries
.
read_with
(
guard
)
;
let
effective_now
=
mq
.
evaluate
(
&
self
.
device
self
.
quirks_mode
)
;
let
effective_then
=
origin_cascade_data
.
effective_media_query_results
.
was_effective
(
media_rule
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
media
rule
changed
{
}
-
>
{
}
"
effective_then
effective_now
)
;
origins
|
=
origin
;
continue
'
stylesheets_loop
;
}
if
!
effective_now
{
iter
.
skip_children
(
)
;
}
}
}
}
}
return
origins
}
pub
fn
viewport_constraints
(
&
self
)
-
>
Option
<
&
ViewportConstraints
>
{
self
.
viewport_constraints
.
as_ref
(
)
}
pub
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
{
self
.
quirks_mode
}
pub
fn
set_quirks_mode
(
&
mut
self
quirks_mode
:
QuirksMode
)
{
self
.
quirks_mode
=
quirks_mode
;
}
pub
fn
push_applicable_declarations_as_xbl_only_stylist
<
E
V
>
(
&
self
element
:
&
E
pseudo_element
:
Option
<
&
PseudoElement
>
applicable_declarations
:
&
mut
V
)
where
E
:
TElement
V
:
Push
<
ApplicableDeclarationBlock
>
+
VecLike
<
ApplicableDeclarationBlock
>
{
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
Normal
None
self
.
quirks_mode
)
;
let
mut
dummy_flag_setter
=
|
_
:
&
E
_
:
ElementSelectorFlags
|
{
}
;
let
rule_hash_target
=
element
.
rule_hash_target
(
)
;
if
let
Some
(
map
)
=
self
.
cascade_data
.
per_origin
.
author
.
borrow_for_pseudo
(
pseudo_element
)
{
map
.
get_all_matching_rules
(
element
&
rule_hash_target
applicable_declarations
&
mut
matching_context
self
.
quirks_mode
&
mut
dummy_flag_setter
CascadeLevel
:
:
XBL
)
;
}
}
pub
fn
push_applicable_declarations
<
E
V
F
>
(
&
self
element
:
&
E
pseudo_element
:
Option
<
&
PseudoElement
>
style_attribute
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
smil_override
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
animation_rules
:
AnimationRules
rule_inclusion
:
RuleInclusion
applicable_declarations
:
&
mut
V
context
:
&
mut
MatchingContext
flags_setter
:
&
mut
F
)
where
E
:
TElement
V
:
Push
<
ApplicableDeclarationBlock
>
+
VecLike
<
ApplicableDeclarationBlock
>
+
Debug
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
debug_assert
!
(
cfg
!
(
feature
=
"
gecko
"
)
|
|
style_attribute
.
is_none
(
)
|
|
pseudo_element
.
is_none
(
)
"
Style
attributes
do
not
apply
to
pseudo
-
elements
"
)
;
debug_assert
!
(
pseudo_element
.
map_or
(
true
|
p
|
!
p
.
is_precomputed
(
)
)
)
;
let
rule_hash_target
=
element
.
rule_hash_target
(
)
;
debug
!
(
"
Determining
if
style
is
shareable
:
pseudo
:
{
}
"
pseudo_element
.
is_some
(
)
)
;
let
only_default_rules
=
rule_inclusion
=
=
RuleInclusion
:
:
DefaultOnly
;
if
let
Some
(
map
)
=
self
.
cascade_data
.
per_origin
.
user_agent
.
borrow_for_pseudo
(
pseudo_element
)
{
map
.
get_all_matching_rules
(
element
&
rule_hash_target
applicable_declarations
context
self
.
quirks_mode
flags_setter
CascadeLevel
:
:
UANormal
)
;
}
if
pseudo_element
.
is_none
(
)
&
&
!
only_default_rules
{
let
length_before_preshints
=
applicable_declarations
.
len
(
)
;
element
.
synthesize_presentational_hints_for_legacy_attributes
(
context
.
visited_handling
applicable_declarations
)
;
if
applicable_declarations
.
len
(
)
!
=
length_before_preshints
{
if
cfg
!
(
debug_assertions
)
{
for
declaration
in
&
applicable_declarations
[
length_before_preshints
.
.
]
{
assert_eq
!
(
declaration
.
level
(
)
CascadeLevel
:
:
PresHints
)
;
}
}
}
}
if
rule_hash_target
.
matches_user_and_author_rules
(
)
{
if
let
Some
(
map
)
=
self
.
cascade_data
.
per_origin
.
user
.
borrow_for_pseudo
(
pseudo_element
)
{
map
.
get_all_matching_rules
(
element
&
rule_hash_target
applicable_declarations
context
self
.
quirks_mode
flags_setter
CascadeLevel
:
:
UserNormal
)
;
}
}
else
{
debug
!
(
"
skipping
user
rules
"
)
;
}
let
cut_off_inheritance
=
element
.
get_declarations_from_xbl_bindings
(
pseudo_element
applicable_declarations
)
;
if
rule_hash_target
.
matches_user_and_author_rules
(
)
&
&
!
only_default_rules
{
if
!
cut_off_inheritance
{
if
let
Some
(
map
)
=
self
.
cascade_data
.
per_origin
.
author
.
borrow_for_pseudo
(
pseudo_element
)
{
map
.
get_all_matching_rules
(
element
&
rule_hash_target
applicable_declarations
context
self
.
quirks_mode
flags_setter
CascadeLevel
:
:
AuthorNormal
)
;
}
}
else
{
debug
!
(
"
skipping
author
normal
rules
due
to
cut
off
inheritance
"
)
;
}
}
else
{
debug
!
(
"
skipping
author
normal
rules
"
)
;
}
if
!
only_default_rules
{
if
let
Some
(
sa
)
=
style_attribute
{
Push
:
:
push
(
applicable_declarations
ApplicableDeclarationBlock
:
:
from_declarations
(
sa
.
clone_arc
(
)
CascadeLevel
:
:
StyleAttributeNormal
)
)
;
}
if
let
Some
(
so
)
=
smil_override
{
Push
:
:
push
(
applicable_declarations
ApplicableDeclarationBlock
:
:
from_declarations
(
so
.
clone_arc
(
)
CascadeLevel
:
:
SMILOverride
)
)
;
}
if
let
Some
(
anim
)
=
animation_rules
.
0
{
Push
:
:
push
(
applicable_declarations
ApplicableDeclarationBlock
:
:
from_declarations
(
anim
.
clone
(
)
CascadeLevel
:
:
Animations
)
)
;
}
}
else
{
debug
!
(
"
skipping
style
attr
and
SMIL
&
animation
rules
"
)
;
}
if
!
only_default_rules
{
if
let
Some
(
anim
)
=
animation_rules
.
1
{
Push
:
:
push
(
applicable_declarations
ApplicableDeclarationBlock
:
:
from_declarations
(
anim
.
clone
(
)
CascadeLevel
:
:
Transitions
)
)
;
}
}
else
{
debug
!
(
"
skipping
transition
rules
"
)
;
}
}
#
[
inline
]
pub
fn
may_have_rules_for_id
(
&
self
id
:
&
Atom
)
-
>
bool
{
self
.
cascade_data
.
iter_origins
(
)
.
any
(
|
(
d
_
)
|
d
.
mapped_ids
.
might_contain_hash
(
id
.
get_hash
(
)
)
)
}
#
[
inline
]
pub
fn
get_animation
(
&
self
name
:
&
Atom
)
-
>
Option
<
&
KeyframesAnimation
>
{
self
.
cascade_data
.
iter_origins
(
)
.
filter_map
(
|
(
d
_
)
|
d
.
animations
.
get
(
name
)
)
.
next
(
)
}
pub
fn
match_revalidation_selectors
<
E
F
>
(
&
self
element
:
&
E
bloom
:
Option
<
&
BloomFilter
>
flags_setter
:
&
mut
F
)
-
>
BitVec
where
E
:
TElement
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
Normal
bloom
self
.
quirks_mode
)
;
let
mut
results
=
BitVec
:
:
new
(
)
;
for
(
data
_
)
in
self
.
cascade_data
.
iter_origins
(
)
{
data
.
selectors_for_cache_revalidation
.
lookup
(
*
element
self
.
quirks_mode
&
mut
|
selector_and_hashes
|
{
results
.
push
(
matches_selector
(
&
selector_and_hashes
.
selector
selector_and_hashes
.
selector_offset
Some
(
&
selector_and_hashes
.
hashes
)
element
&
mut
matching_context
flags_setter
)
)
;
true
}
)
;
}
results
}
pub
fn
compute_for_declarations
(
&
self
guards
:
&
StylesheetGuards
parent_style
:
&
ComputedValues
declarations
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
)
-
>
Arc
<
ComputedValues
>
{
use
font_metrics
:
:
get_metrics_provider_for_product
;
let
v
=
vec
!
[
ApplicableDeclarationBlock
:
:
from_declarations
(
declarations
.
clone
(
)
CascadeLevel
:
:
StyleAttributeNormal
)
]
;
let
rule_node
=
self
.
rule_tree
.
insert_ordered_rules
(
v
.
into_iter
(
)
.
map
(
|
a
|
a
.
order_and_level
(
)
)
)
;
let
metrics
=
get_metrics_provider_for_product
(
)
;
properties
:
:
cascade
(
&
self
.
device
None
&
rule_node
guards
Some
(
parent_style
)
Some
(
parent_style
)
Some
(
parent_style
)
None
&
metrics
CascadeFlags
:
:
empty
(
)
self
.
quirks_mode
)
}
pub
fn
device
(
&
self
)
-
>
&
Device
{
&
self
.
device
}
pub
fn
device_mut
(
&
mut
self
)
-
>
&
mut
Device
{
&
mut
self
.
device
}
pub
fn
rule_tree
(
&
self
)
-
>
&
RuleTree
{
&
self
.
rule_tree
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
malloc_add_size_of_children
(
&
self
malloc_size_of
:
MallocSizeOfFn
malloc_enclosing_size_of
:
MallocEnclosingSizeOfFn
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
cascade_data
.
malloc_add_size_of_children
(
malloc_size_of
malloc_enclosing_size_of
sizes
)
;
sizes
.
mStylistRuleTree
+
=
self
.
rule_tree
.
malloc_size_of_children
(
malloc_size_of
)
;
}
}
#
[
derive
(
Default
)
]
pub
struct
ExtraStyleData
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
font_faces
:
Vec
<
Arc
<
Locked
<
FontFaceRule
>
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
font_feature_values
:
Vec
<
Arc
<
Locked
<
FontFeatureValuesRule
>
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
counter_styles
:
PrecomputedHashMap
<
Atom
Arc
<
Locked
<
CounterStyleRule
>
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
pages
:
Vec
<
Arc
<
Locked
<
PageRule
>
>
>
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ExtraStyleData
{
fn
add_font_face
(
&
mut
self
rule
:
&
Arc
<
Locked
<
FontFaceRule
>
>
)
{
self
.
font_faces
.
push
(
rule
.
clone
(
)
)
;
}
fn
add_font_feature_values
(
&
mut
self
rule
:
&
Arc
<
Locked
<
FontFeatureValuesRule
>
>
)
{
self
.
font_feature_values
.
push
(
rule
.
clone
(
)
)
;
}
fn
add_counter_style
(
&
mut
self
guard
:
&
SharedRwLockReadGuard
rule
:
&
Arc
<
Locked
<
CounterStyleRule
>
>
)
{
let
name
=
rule
.
read_with
(
guard
)
.
mName
.
raw
:
:
<
nsIAtom
>
(
)
.
into
(
)
;
self
.
counter_styles
.
insert
(
name
rule
.
clone
(
)
)
;
}
fn
add_page
(
&
mut
self
rule
:
&
Arc
<
Locked
<
PageRule
>
>
)
{
self
.
pages
.
push
(
rule
.
clone
(
)
)
;
}
}
impl
ExtraStyleData
{
fn
clear
(
&
mut
self
)
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
font_faces
.
clear
(
)
;
self
.
font_feature_values
.
clear
(
)
;
self
.
counter_styles
.
clear
(
)
;
self
.
pages
.
clear
(
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
malloc_size_of_children
(
&
self
malloc_size_of
:
MallocSizeOfFn
malloc_enclosing_size_of
:
MallocEnclosingSizeOfFn
)
-
>
usize
{
let
mut
n
=
0
;
n
+
=
self
.
font_faces
.
malloc_shallow_size_of_vec
(
malloc_size_of
)
;
n
+
=
self
.
font_feature_values
.
malloc_shallow_size_of_vec
(
malloc_size_of
)
;
n
+
=
self
.
counter_styles
.
malloc_shallow_size_of_hash
(
malloc_enclosing_size_of
)
;
n
}
}
#
[
derive
(
Clone
Debug
)
]
struct
RevalidationSelectorAndHashes
{
selector
:
Selector
<
SelectorImpl
>
selector_offset
:
usize
hashes
:
AncestorHashes
}
impl
RevalidationSelectorAndHashes
{
fn
new
(
selector
:
Selector
<
SelectorImpl
>
hashes
:
AncestorHashes
)
-
>
Self
{
let
selector_offset
=
{
let
mut
index
=
0
;
let
mut
iter
=
selector
.
iter
(
)
;
for
_
in
&
mut
iter
{
index
+
=
1
;
}
match
iter
.
next_sequence
(
)
{
Some
(
Combinator
:
:
PseudoElement
)
=
>
index
+
1
_
=
>
0
}
}
;
RevalidationSelectorAndHashes
{
selector
selector_offset
hashes
}
}
}
impl
SelectorMapEntry
for
RevalidationSelectorAndHashes
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter_from
(
self
.
selector_offset
)
}
}
struct
StylistSelectorVisitor
<
'
a
>
{
needs_revalidation
:
bool
passed_rightmost_selector
:
bool
mapped_ids
:
&
'
a
mut
NonCountingBloomFilter
attribute_dependencies
:
&
'
a
mut
NonCountingBloomFilter
style_attribute_dependency
:
&
'
a
mut
bool
state_dependencies
:
&
'
a
mut
ElementState
}
fn
component_needs_revalidation
(
c
:
&
Component
<
SelectorImpl
>
passed_rightmost_selector
:
bool
)
-
>
bool
{
match
*
c
{
Component
:
:
ID
(
_
)
=
>
{
passed_rightmost_selector
}
Component
:
:
AttributeInNoNamespaceExists
{
.
.
}
|
Component
:
:
AttributeInNoNamespace
{
.
.
}
|
Component
:
:
AttributeOther
(
_
)
|
Component
:
:
Empty
|
Component
:
:
FirstChild
|
Component
:
:
LastChild
|
Component
:
:
OnlyChild
|
Component
:
:
NthChild
(
.
.
)
|
Component
:
:
NthLastChild
(
.
.
)
|
Component
:
:
NthOfType
(
.
.
)
|
Component
:
:
NthLastOfType
(
.
.
)
|
Component
:
:
FirstOfType
|
Component
:
:
LastOfType
|
Component
:
:
OnlyOfType
=
>
{
true
}
Component
:
:
NonTSPseudoClass
(
ref
p
)
=
>
{
p
.
needs_cache_revalidation
(
)
}
_
=
>
{
false
}
}
}
impl
<
'
a
>
SelectorVisitor
for
StylistSelectorVisitor
<
'
a
>
{
type
Impl
=
SelectorImpl
;
fn
visit_complex_selector
(
&
mut
self
combinator
:
Option
<
Combinator
>
)
-
>
bool
{
self
.
needs_revalidation
=
self
.
needs_revalidation
|
|
combinator
.
map_or
(
false
|
c
|
c
.
is_sibling
(
)
)
;
self
.
passed_rightmost_selector
=
self
.
passed_rightmost_selector
|
|
!
matches
!
(
combinator
None
|
Some
(
Combinator
:
:
PseudoElement
)
)
;
true
}
fn
visit_attribute_selector
(
&
mut
self
_ns
:
&
NamespaceConstraint
<
&
Namespace
>
name
:
&
LocalName
lower_name
:
&
LocalName
)
-
>
bool
{
if
*
lower_name
=
=
local_name
!
(
"
style
"
)
{
*
self
.
style_attribute_dependency
=
true
;
}
else
{
self
.
attribute_dependencies
.
insert_hash
(
name
.
get_hash
(
)
)
;
self
.
attribute_dependencies
.
insert_hash
(
lower_name
.
get_hash
(
)
)
;
}
true
}
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
self
.
needs_revalidation
=
self
.
needs_revalidation
|
|
component_needs_revalidation
(
s
self
.
passed_rightmost_selector
)
;
match
*
s
{
Component
:
:
NonTSPseudoClass
(
ref
p
)
=
>
{
self
.
state_dependencies
.
insert
(
p
.
state_flag
(
)
)
;
}
Component
:
:
ID
(
ref
id
)
if
!
self
.
passed_rightmost_selector
=
>
{
self
.
mapped_ids
.
insert_hash
(
id
.
get_hash
(
)
)
;
}
_
=
>
{
}
}
true
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Debug
)
]
struct
CascadeData
{
element_map
:
SelectorMap
<
Rule
>
pseudos_map
:
PerPseudoElementMap
<
Box
<
SelectorMap
<
Rule
>
>
>
animations
:
PrecomputedHashMap
<
Atom
KeyframesAnimation
>
invalidation_map
:
InvalidationMap
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
just
an
array
"
)
]
attribute_dependencies
:
NonCountingBloomFilter
style_attribute_dependency
:
bool
state_dependencies
:
ElementState
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
just
an
array
"
)
]
mapped_ids
:
NonCountingBloomFilter
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
selectors_for_cache_revalidation
:
SelectorMap
<
RevalidationSelectorAndHashes
>
effective_media_query_results
:
EffectiveMediaQueryResults
rules_source_order
:
u32
num_selectors
:
usize
num_declarations
:
usize
}
impl
CascadeData
{
fn
new
(
)
-
>
Self
{
Self
{
element_map
:
SelectorMap
:
:
new
(
)
pseudos_map
:
PerPseudoElementMap
:
:
default
(
)
animations
:
Default
:
:
default
(
)
invalidation_map
:
InvalidationMap
:
:
new
(
)
attribute_dependencies
:
NonCountingBloomFilter
:
:
new
(
)
style_attribute_dependency
:
false
state_dependencies
:
ElementState
:
:
empty
(
)
mapped_ids
:
NonCountingBloomFilter
:
:
new
(
)
selectors_for_cache_revalidation
:
SelectorMap
:
:
new
(
)
effective_media_query_results
:
EffectiveMediaQueryResults
:
:
new
(
)
rules_source_order
:
0
num_selectors
:
0
num_declarations
:
0
}
}
#
[
inline
]
fn
borrow_for_pseudo
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
SelectorMap
<
Rule
>
>
{
match
pseudo
{
Some
(
pseudo
)
=
>
self
.
pseudos_map
.
get
(
&
pseudo
.
canonical
(
)
)
.
map
(
|
p
|
&
*
*
p
)
None
=
>
Some
(
&
self
.
element_map
)
}
}
fn
has_rules_for_pseudo
(
&
self
pseudo
:
&
PseudoElement
)
-
>
bool
{
self
.
pseudos_map
.
get
(
pseudo
)
.
is_some
(
)
}
fn
clear_cascade_data
(
&
mut
self
)
{
self
.
element_map
.
clear
(
)
;
self
.
pseudos_map
.
clear
(
)
;
self
.
animations
.
clear
(
)
;
self
.
rules_source_order
=
0
;
self
.
num_selectors
=
0
;
self
.
num_declarations
=
0
;
}
fn
clear
(
&
mut
self
)
{
self
.
clear_cascade_data
(
)
;
self
.
effective_media_query_results
.
clear
(
)
;
self
.
invalidation_map
.
clear
(
)
;
self
.
attribute_dependencies
.
clear
(
)
;
self
.
style_attribute_dependency
=
false
;
self
.
state_dependencies
=
ElementState
:
:
empty
(
)
;
self
.
mapped_ids
.
clear
(
)
;
self
.
selectors_for_cache_revalidation
.
clear
(
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
malloc_add_size_of_children
(
&
self
malloc_size_of
:
MallocSizeOfFn
malloc_enclosing_size_of
:
MallocEnclosingSizeOfFn
sizes
:
&
mut
ServoStyleSetSizes
)
{
sizes
.
mStylistElementAndPseudosMaps
+
=
self
.
element_map
.
malloc_size_of_children
(
malloc_size_of
malloc_enclosing_size_of
)
;
for
elem
in
self
.
pseudos_map
.
iter
(
)
{
if
let
Some
(
ref
elem
)
=
*
elem
{
sizes
.
mStylistElementAndPseudosMaps
+
=
elem
.
malloc_shallow_size_of_box
(
malloc_size_of
)
+
elem
.
malloc_size_of_children
(
malloc_size_of
malloc_enclosing_size_of
)
}
}
sizes
.
mStylistOther
+
=
self
.
animations
.
malloc_shallow_size_of_hash
(
malloc_enclosing_size_of
)
;
for
val
in
self
.
animations
.
values
(
)
{
sizes
.
mStylistOther
+
=
val
.
malloc_size_of_children
(
malloc_size_of
)
;
}
sizes
.
mStylistInvalidationMap
+
=
self
.
invalidation_map
.
malloc_size_of_children
(
malloc_size_of
malloc_enclosing_size_of
)
;
sizes
.
mStylistRevalidationSelectors
+
=
self
.
selectors_for_cache_revalidation
.
malloc_size_of_children
(
malloc_size_of
malloc_enclosing_size_of
)
;
sizes
.
mStylistOther
+
=
self
.
effective_media_query_results
.
malloc_size_of_children
(
malloc_enclosing_size_of
)
;
}
}
impl
Default
for
CascadeData
{
fn
default
(
)
-
>
Self
{
CascadeData
:
:
new
(
)
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Debug
)
]
pub
struct
Rule
{
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
pub
selector
:
Selector
<
SelectorImpl
>
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
No
heap
data
"
)
]
pub
hashes
:
AncestorHashes
pub
source_order
:
u32
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
pub
style_rule
:
Arc
<
Locked
<
StyleRule
>
>
}
impl
SelectorMapEntry
for
Rule
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter
(
)
}
}
impl
Rule
{
pub
fn
specificity
(
&
self
)
-
>
u32
{
self
.
selector
.
specificity
(
)
}
pub
fn
to_applicable_declaration_block
(
&
self
level
:
CascadeLevel
)
-
>
ApplicableDeclarationBlock
{
let
source
=
StyleSource
:
:
Style
(
self
.
style_rule
.
clone
(
)
)
;
ApplicableDeclarationBlock
:
:
new
(
source
self
.
source_order
level
self
.
specificity
(
)
)
}
pub
fn
new
(
selector
:
Selector
<
SelectorImpl
>
hashes
:
AncestorHashes
style_rule
:
Arc
<
Locked
<
StyleRule
>
>
source_order
:
u32
)
-
>
Self
{
Rule
{
selector
:
selector
hashes
:
hashes
style_rule
:
style_rule
source_order
:
source_order
}
}
}
pub
fn
needs_revalidation_for_testing
(
s
:
&
Selector
<
SelectorImpl
>
)
-
>
bool
{
let
mut
attribute_dependencies
=
NonCountingBloomFilter
:
:
new
(
)
;
let
mut
mapped_ids
=
NonCountingBloomFilter
:
:
new
(
)
;
let
mut
style_attribute_dependency
=
false
;
let
mut
state_dependencies
=
ElementState
:
:
empty
(
)
;
let
mut
visitor
=
StylistSelectorVisitor
{
needs_revalidation
:
false
passed_rightmost_selector
:
false
attribute_dependencies
:
&
mut
attribute_dependencies
style_attribute_dependency
:
&
mut
style_attribute_dependency
state_dependencies
:
&
mut
state_dependencies
mapped_ids
:
&
mut
mapped_ids
}
;
s
.
visit
(
&
mut
visitor
)
;
visitor
.
needs_revalidation
}
