use
crate
:
:
applicable_declarations
:
:
{
ApplicableDeclarationBlock
ApplicableDeclarationList
}
;
use
crate
:
:
context
:
:
{
CascadeInputs
QuirksMode
}
;
use
crate
:
:
dom
:
:
{
TElement
TShadowRoot
}
;
use
crate
:
:
element_state
:
:
{
DocumentState
ElementState
}
;
use
crate
:
:
font_metrics
:
:
FontMetricsProvider
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
gecko_bindings
:
:
structs
:
:
{
ServoStyleSetSizes
StyleRuleInclusion
}
;
use
crate
:
:
invalidation
:
:
element
:
:
invalidation_map
:
:
InvalidationMap
;
use
crate
:
:
invalidation
:
:
media_queries
:
:
{
EffectiveMediaQueryResults
MediaListKey
ToMediaListKey
}
;
use
crate
:
:
invalidation
:
:
stylesheets
:
:
RuleChangeKind
;
use
crate
:
:
media_queries
:
:
Device
;
use
crate
:
:
properties
:
:
{
self
CascadeMode
ComputedValues
}
;
use
crate
:
:
properties
:
:
{
AnimationDeclarations
PropertyDeclarationBlock
}
;
use
crate
:
:
rule_cache
:
:
{
RuleCache
RuleCacheConditions
}
;
use
crate
:
:
rule_collector
:
:
{
containing_shadow_ignoring_svg_use
RuleCollector
}
;
use
crate
:
:
rule_tree
:
:
{
CascadeLevel
RuleTree
StrongRuleNode
StyleSource
}
;
use
crate
:
:
selector_map
:
:
{
PrecomputedHashMap
PrecomputedHashSet
SelectorMap
SelectorMapEntry
}
;
use
crate
:
:
selector_parser
:
:
{
PerPseudoElementMap
PseudoElement
SelectorImpl
SnapshotMap
}
;
use
crate
:
:
shared_lock
:
:
{
Locked
SharedRwLockReadGuard
StylesheetGuards
}
;
use
crate
:
:
stylesheet_set
:
:
{
DataValidity
DocumentStylesheetSet
SheetRebuildKind
}
;
use
crate
:
:
stylesheet_set
:
:
{
DocumentStylesheetFlusher
SheetCollectionFlusher
}
;
use
crate
:
:
stylesheets
:
:
keyframes_rule
:
:
KeyframesAnimation
;
use
crate
:
:
stylesheets
:
:
layer_rule
:
:
{
LayerId
LayerName
LayerOrder
}
;
use
crate
:
:
stylesheets
:
:
viewport_rule
:
:
{
self
MaybeNew
ViewportRule
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
stylesheets
:
:
{
CounterStyleRule
FontFaceRule
FontFeatureValuesRule
PageRule
}
;
use
crate
:
:
stylesheets
:
:
{
CssRule
EffectiveRulesIterator
Origin
OriginSet
PerOrigin
PerOriginIter
}
;
use
crate
:
:
stylesheets
:
:
{
StyleRule
StylesheetContents
StylesheetInDocument
}
;
use
crate
:
:
thread_state
:
:
{
self
ThreadState
}
;
use
crate
:
:
{
Atom
LocalName
Namespace
WeakAtom
}
;
use
fallible
:
:
FallibleVec
;
use
fxhash
:
:
FxHashMap
;
use
hashglobe
:
:
FailedAllocationError
;
use
malloc_size_of
:
:
MallocSizeOf
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
malloc_size_of
:
:
{
MallocShallowSizeOf
MallocSizeOfOps
MallocUnconditionalShallowSizeOf
}
;
use
selectors
:
:
attr
:
:
{
CaseSensitivity
NamespaceConstraint
}
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
use
selectors
:
:
matching
:
:
VisitedHandlingMode
;
use
selectors
:
:
matching
:
:
{
matches_selector
ElementSelectorFlags
MatchingContext
MatchingMode
}
;
use
selectors
:
:
parser
:
:
{
AncestorHashes
Combinator
Component
Selector
SelectorIter
}
;
use
selectors
:
:
visitor
:
:
SelectorVisitor
;
use
selectors
:
:
NthIndexCache
;
use
servo_arc
:
:
{
Arc
ArcBorrow
}
;
use
smallbitvec
:
:
SmallBitVec
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
sync
:
:
Mutex
;
use
std
:
:
{
mem
ops
}
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
type
StylistSheet
=
crate
:
:
stylesheets
:
:
DocumentStyleSheet
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
type
StylistSheet
=
crate
:
:
gecko
:
:
data
:
:
GeckoStyleSheet
;
#
[
derive
(
Debug
Clone
)
]
struct
StylesheetContentsPtr
(
Arc
<
StylesheetContents
>
)
;
impl
PartialEq
for
StylesheetContentsPtr
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
Arc
:
:
ptr_eq
(
&
self
.
0
&
other
.
0
)
}
}
impl
Eq
for
StylesheetContentsPtr
{
}
impl
Hash
for
StylesheetContentsPtr
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
let
contents
:
&
StylesheetContents
=
&
*
self
.
0
;
(
contents
as
*
const
StylesheetContents
)
.
hash
(
state
)
}
}
type
StyleSheetContentList
=
Vec
<
StylesheetContentsPtr
>
;
#
[
derive
(
Debug
Hash
Default
PartialEq
Eq
)
]
struct
CascadeDataCacheKey
{
media_query_results
:
Vec
<
MediaListKey
>
contents
:
StyleSheetContentList
}
unsafe
impl
Send
for
CascadeDataCacheKey
{
}
unsafe
impl
Sync
for
CascadeDataCacheKey
{
}
trait
CascadeDataCacheEntry
:
Sized
{
fn
cascade_data
(
&
self
)
-
>
&
CascadeData
;
fn
rebuild
<
S
>
(
device
:
&
Device
quirks_mode
:
QuirksMode
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
old_entry
:
&
Self
)
-
>
Result
<
Arc
<
Self
>
FailedAllocationError
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
;
}
struct
CascadeDataCache
<
Entry
>
{
entries
:
FxHashMap
<
CascadeDataCacheKey
Arc
<
Entry
>
>
}
impl
<
Entry
>
CascadeDataCache
<
Entry
>
where
Entry
:
CascadeDataCacheEntry
{
fn
new
(
)
-
>
Self
{
Self
{
entries
:
Default
:
:
default
(
)
}
}
fn
len
(
&
self
)
-
>
usize
{
self
.
entries
.
len
(
)
}
fn
lookup
<
'
a
S
>
(
&
'
a
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
old_entry
:
&
Entry
)
-
>
Result
<
Option
<
Arc
<
Entry
>
>
FailedAllocationError
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
use
std
:
:
collections
:
:
hash_map
:
:
Entry
as
HashMapEntry
;
debug
!
(
"
StyleSheetCache
:
:
lookup
(
{
}
)
"
self
.
len
(
)
)
;
if
!
collection
.
dirty
(
)
{
return
Ok
(
None
)
;
}
let
mut
key
=
CascadeDataCacheKey
:
:
default
(
)
;
for
sheet
in
collection
.
sheets
(
)
{
CascadeData
:
:
collect_applicable_media_query_results_into
(
device
sheet
guard
&
mut
key
.
media_query_results
&
mut
key
.
contents
)
}
let
new_entry
;
match
self
.
entries
.
entry
(
key
)
{
HashMapEntry
:
:
Vacant
(
e
)
=
>
{
debug
!
(
"
>
Picking
the
slow
path
(
not
in
the
cache
)
"
)
;
new_entry
=
Entry
:
:
rebuild
(
device
quirks_mode
collection
guard
old_entry
)
?
;
e
.
insert
(
new_entry
.
clone
(
)
)
;
}
HashMapEntry
:
:
Occupied
(
mut
e
)
=
>
{
if
!
std
:
:
ptr
:
:
eq
(
&
*
*
e
.
get
(
)
old_entry
)
{
if
log_enabled
!
(
log
:
:
Level
:
:
Debug
)
{
debug
!
(
"
cache
hit
for
:
"
)
;
for
sheet
in
collection
.
sheets
(
)
{
debug
!
(
"
>
{
:
?
}
"
sheet
)
;
}
}
collection
.
each
(
|
_
_
|
true
)
;
return
Ok
(
Some
(
e
.
get
(
)
.
clone
(
)
)
)
;
}
debug
!
(
"
>
Picking
the
slow
path
due
to
same
entry
as
old
"
)
;
new_entry
=
Entry
:
:
rebuild
(
device
quirks_mode
collection
guard
old_entry
)
?
;
e
.
insert
(
new_entry
.
clone
(
)
)
;
}
}
Ok
(
Some
(
new_entry
)
)
}
fn
take_unused
(
&
mut
self
)
-
>
SmallVec
<
[
Arc
<
Entry
>
;
3
]
>
{
let
mut
unused
=
SmallVec
:
:
new
(
)
;
self
.
entries
.
retain
(
|
_key
value
|
{
if
!
value
.
is_unique
(
)
{
return
true
;
}
unused
.
push
(
value
.
clone
(
)
)
;
false
}
)
;
unused
}
fn
take_all
(
&
mut
self
)
-
>
FxHashMap
<
CascadeDataCacheKey
Arc
<
Entry
>
>
{
mem
:
:
take
(
&
mut
self
.
entries
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
sizes
.
mOther
+
=
self
.
entries
.
shallow_size_of
(
ops
)
;
for
(
_key
arc
)
in
self
.
entries
.
iter
(
)
{
sizes
.
mOther
+
=
arc
.
unconditional_shallow_size_of
(
ops
)
;
arc
.
add_size_of
(
ops
sizes
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
add_size_of_ua_cache
(
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
UA_CASCADE_DATA_CACHE
.
lock
(
)
.
unwrap
(
)
.
add_size_of
(
ops
sizes
)
;
}
lazy_static
!
{
/
/
/
A
cache
of
computed
user
-
agent
data
to
be
shared
across
documents
.
static
ref
UA_CASCADE_DATA_CACHE
:
Mutex
<
UserAgentCascadeDataCache
>
=
Mutex
:
:
new
(
UserAgentCascadeDataCache
:
:
new
(
)
)
;
}
impl
CascadeDataCacheEntry
for
UserAgentCascadeData
{
fn
cascade_data
(
&
self
)
-
>
&
CascadeData
{
&
self
.
cascade_data
}
fn
rebuild
<
S
>
(
device
:
&
Device
quirks_mode
:
QuirksMode
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
_old
:
&
Self
)
-
>
Result
<
Arc
<
Self
>
FailedAllocationError
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
let
mut
new_data
=
Self
{
cascade_data
:
CascadeData
:
:
new
(
)
precomputed_pseudo_element_decls
:
PrecomputedPseudoElementDeclarations
:
:
default
(
)
}
;
for
sheet
in
collection
.
sheets
(
)
{
new_data
.
cascade_data
.
add_stylesheet
(
device
quirks_mode
sheet
guard
SheetRebuildKind
:
:
Full
Some
(
&
mut
new_data
.
precomputed_pseudo_element_decls
)
)
?
;
}
new_data
.
cascade_data
.
compute_layer_order
(
)
;
Ok
(
Arc
:
:
new
(
new_data
)
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
cascade_data
.
add_size_of
(
ops
sizes
)
;
sizes
.
mPrecomputedPseudos
+
=
self
.
precomputed_pseudo_element_decls
.
size_of
(
ops
)
;
}
}
type
UserAgentCascadeDataCache
=
CascadeDataCache
<
UserAgentCascadeData
>
;
type
PrecomputedPseudoElementDeclarations
=
PerPseudoElementMap
<
Vec
<
ApplicableDeclarationBlock
>
>
;
#
[
derive
(
Default
)
]
struct
UserAgentCascadeData
{
cascade_data
:
CascadeData
precomputed_pseudo_element_decls
:
PrecomputedPseudoElementDeclarations
}
#
[
derive
(
Default
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
pub
struct
DocumentCascadeData
{
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
Arc
owned
by
UserAgentCascadeDataCache
"
)
]
user_agent
:
Arc
<
UserAgentCascadeData
>
user
:
CascadeData
author
:
CascadeData
per_origin
:
PerOrigin
<
(
)
>
}
pub
struct
DocumentCascadeDataIter
<
'
a
>
{
iter
:
PerOriginIter
<
'
a
(
)
>
cascade_data
:
&
'
a
DocumentCascadeData
}
impl
<
'
a
>
Iterator
for
DocumentCascadeDataIter
<
'
a
>
{
type
Item
=
(
&
'
a
CascadeData
Origin
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
(
_
origin
)
=
self
.
iter
.
next
(
)
?
;
Some
(
(
self
.
cascade_data
.
borrow_for_origin
(
origin
)
origin
)
)
}
}
impl
DocumentCascadeData
{
#
[
inline
]
pub
fn
borrow_for_origin
(
&
self
origin
:
Origin
)
-
>
&
CascadeData
{
match
origin
{
Origin
:
:
UserAgent
=
>
&
self
.
user_agent
.
cascade_data
Origin
:
:
Author
=
>
&
self
.
author
Origin
:
:
User
=
>
&
self
.
user
}
}
fn
iter_origins
(
&
self
)
-
>
DocumentCascadeDataIter
{
DocumentCascadeDataIter
{
iter
:
self
.
per_origin
.
iter_origins
(
)
cascade_data
:
self
}
}
fn
iter_origins_rev
(
&
self
)
-
>
DocumentCascadeDataIter
{
DocumentCascadeDataIter
{
iter
:
self
.
per_origin
.
iter_origins_rev
(
)
cascade_data
:
self
}
}
fn
rebuild
<
'
a
S
>
(
&
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
mut
flusher
:
DocumentStylesheetFlusher
<
'
a
S
>
guards
:
&
StylesheetGuards
)
-
>
Result
<
(
)
FailedAllocationError
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
{
let
origin_flusher
=
flusher
.
flush_origin
(
Origin
:
:
UserAgent
)
;
if
origin_flusher
.
dirty
(
)
{
let
mut
ua_cache
=
UA_CASCADE_DATA_CACHE
.
lock
(
)
.
unwrap
(
)
;
let
new_data
=
ua_cache
.
lookup
(
device
quirks_mode
origin_flusher
guards
.
ua_or_user
&
self
.
user_agent
)
?
;
if
let
Some
(
new_data
)
=
new_data
{
self
.
user_agent
=
new_data
;
}
let
_unused_entries
=
ua_cache
.
take_unused
(
)
;
std
:
:
mem
:
:
drop
(
ua_cache
)
;
}
}
self
.
user
.
rebuild
(
device
quirks_mode
flusher
.
flush_origin
(
Origin
:
:
User
)
guards
.
ua_or_user
)
?
;
self
.
author
.
rebuild
(
device
quirks_mode
flusher
.
flush_origin
(
Origin
:
:
Author
)
guards
.
author
)
?
;
Ok
(
(
)
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
user
.
add_size_of
(
ops
sizes
)
;
self
.
author
.
add_size_of
(
ops
sizes
)
;
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
)
]
pub
enum
AuthorStylesEnabled
{
Yes
No
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
struct
StylistStylesheetSet
(
DocumentStylesheetSet
<
StylistSheet
>
)
;
unsafe
impl
Sync
for
StylistStylesheetSet
{
}
impl
StylistStylesheetSet
{
fn
new
(
)
-
>
Self
{
StylistStylesheetSet
(
DocumentStylesheetSet
:
:
new
(
)
)
}
}
impl
ops
:
:
Deref
for
StylistStylesheetSet
{
type
Target
=
DocumentStylesheetSet
<
StylistSheet
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
ops
:
:
DerefMut
for
StylistStylesheetSet
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
pub
struct
Stylist
{
device
:
Device
viewport_constraints
:
Option
<
ViewportConstraints
>
stylesheets
:
StylistStylesheetSet
author_data_cache
:
CascadeDataCache
<
CascadeData
>
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
defined
in
selectors
"
)
]
quirks_mode
:
QuirksMode
cascade_data
:
DocumentCascadeData
author_styles_enabled
:
AuthorStylesEnabled
rule_tree
:
RuleTree
num_rebuilds
:
usize
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
RuleInclusion
{
All
DefaultOnly
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
StyleRuleInclusion
>
for
RuleInclusion
{
fn
from
(
value
:
StyleRuleInclusion
)
-
>
Self
{
match
value
{
StyleRuleInclusion
:
:
All
=
>
RuleInclusion
:
:
All
StyleRuleInclusion
:
:
DefaultOnly
=
>
RuleInclusion
:
:
DefaultOnly
}
}
}
impl
Stylist
{
#
[
inline
]
pub
fn
new
(
device
:
Device
quirks_mode
:
QuirksMode
)
-
>
Self
{
Self
{
viewport_constraints
:
None
device
quirks_mode
stylesheets
:
StylistStylesheetSet
:
:
new
(
)
author_data_cache
:
CascadeDataCache
:
:
new
(
)
cascade_data
:
Default
:
:
default
(
)
author_styles_enabled
:
AuthorStylesEnabled
:
:
Yes
rule_tree
:
RuleTree
:
:
new
(
)
num_rebuilds
:
0
}
}
#
[
inline
]
pub
fn
cascade_data
(
&
self
)
-
>
&
DocumentCascadeData
{
&
self
.
cascade_data
}
#
[
inline
]
pub
fn
author_styles_enabled
(
&
self
)
-
>
AuthorStylesEnabled
{
self
.
author_styles_enabled
}
#
[
inline
]
pub
fn
iter_origins
(
&
self
)
-
>
DocumentCascadeDataIter
{
self
.
cascade_data
.
iter_origins
(
)
}
pub
fn
remove_unique_author_data_cache_entries
(
&
mut
self
)
{
self
.
author_data_cache
.
take_unused
(
)
;
}
pub
fn
rebuild_author_data
<
S
>
(
&
mut
self
old_data
:
&
CascadeData
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
)
-
>
Result
<
Option
<
Arc
<
CascadeData
>
>
FailedAllocationError
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
self
.
author_data_cache
.
lookup
(
&
self
.
device
self
.
quirks_mode
collection
guard
old_data
)
}
#
[
inline
]
pub
fn
iter_extra_data_origins
(
&
self
)
-
>
ExtraStyleDataIterator
{
ExtraStyleDataIterator
(
self
.
cascade_data
.
iter_origins
(
)
)
}
#
[
inline
]
pub
fn
iter_extra_data_origins_rev
(
&
self
)
-
>
ExtraStyleDataIterator
{
ExtraStyleDataIterator
(
self
.
cascade_data
.
iter_origins_rev
(
)
)
}
pub
fn
num_selectors
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
d
_
)
|
d
.
num_selectors
)
.
sum
(
)
}
pub
fn
num_declarations
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
d
_
)
|
d
.
num_declarations
)
.
sum
(
)
}
pub
fn
num_rebuilds
(
&
self
)
-
>
usize
{
self
.
num_rebuilds
}
pub
fn
num_revalidation_selectors
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
data
_
)
|
data
.
selectors_for_cache_revalidation
.
len
(
)
)
.
sum
(
)
}
pub
fn
num_invalidations
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
data
_
)
|
data
.
invalidation_map
.
len
(
)
)
.
sum
(
)
}
pub
fn
has_document_state_dependency
(
&
self
state
:
DocumentState
)
-
>
bool
{
self
.
cascade_data
.
iter_origins
(
)
.
any
(
|
(
d
_
)
|
d
.
document_state_dependencies
.
intersects
(
state
)
)
}
pub
fn
flush
<
E
>
(
&
mut
self
guards
:
&
StylesheetGuards
document_element
:
Option
<
E
>
snapshots
:
Option
<
&
SnapshotMap
>
)
-
>
bool
where
E
:
TElement
{
if
!
self
.
stylesheets
.
has_changed
(
)
{
return
false
;
}
self
.
num_rebuilds
+
=
1
;
self
.
viewport_constraints
=
None
;
if
viewport_rule
:
:
enabled
(
)
{
let
cascaded_rule
=
ViewportRule
{
declarations
:
viewport_rule
:
:
Cascade
:
:
from_stylesheets
(
self
.
stylesheets
.
iter
(
)
guards
&
self
.
device
)
.
finish
(
)
}
;
self
.
viewport_constraints
=
ViewportConstraints
:
:
maybe_new
(
&
self
.
device
&
cascaded_rule
self
.
quirks_mode
)
;
if
let
Some
(
ref
constraints
)
=
self
.
viewport_constraints
{
self
.
device
.
account_for_viewport_rule
(
constraints
)
;
}
}
let
flusher
=
self
.
stylesheets
.
flush
(
document_element
snapshots
)
;
let
had_invalidations
=
flusher
.
had_invalidations
(
)
;
self
.
cascade_data
.
rebuild
(
&
self
.
device
self
.
quirks_mode
flusher
guards
)
.
unwrap_or_else
(
|
_
|
warn
!
(
"
OOM
in
Stylist
:
:
flush
"
)
)
;
had_invalidations
}
pub
fn
insert_stylesheet_before
(
&
mut
self
sheet
:
StylistSheet
before_sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
insert_stylesheet_before
(
Some
(
&
self
.
device
)
sheet
before_sheet
guard
)
}
pub
fn
force_stylesheet_origins_dirty
(
&
mut
self
origins
:
OriginSet
)
{
self
.
stylesheets
.
force_dirty
(
origins
)
}
pub
fn
set_author_styles_enabled
(
&
mut
self
enabled
:
AuthorStylesEnabled
)
{
self
.
author_styles_enabled
=
enabled
;
}
pub
fn
stylesheets_have_changed
(
&
self
)
-
>
bool
{
self
.
stylesheets
.
has_changed
(
)
}
pub
fn
append_stylesheet
(
&
mut
self
sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
append_stylesheet
(
Some
(
&
self
.
device
)
sheet
guard
)
}
pub
fn
remove_stylesheet
(
&
mut
self
sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
remove_stylesheet
(
Some
(
&
self
.
device
)
sheet
guard
)
}
pub
fn
rule_changed
(
&
mut
self
sheet
:
&
StylistSheet
rule
:
&
CssRule
guard
:
&
SharedRwLockReadGuard
change_kind
:
RuleChangeKind
)
{
self
.
stylesheets
.
rule_changed
(
Some
(
&
self
.
device
)
sheet
rule
guard
change_kind
)
}
#
[
inline
]
pub
fn
sheet_count
(
&
self
origin
:
Origin
)
-
>
usize
{
self
.
stylesheets
.
sheet_count
(
origin
)
}
#
[
inline
]
pub
fn
sheet_at
(
&
self
origin
:
Origin
index
:
usize
)
-
>
Option
<
&
StylistSheet
>
{
self
.
stylesheets
.
get
(
origin
index
)
}
pub
fn
any_applicable_rule_data
<
E
F
>
(
&
self
element
:
E
mut
f
:
F
)
-
>
bool
where
E
:
TElement
F
:
FnMut
(
&
CascadeData
)
-
>
bool
{
if
f
(
&
self
.
cascade_data
.
user_agent
.
cascade_data
)
{
return
true
;
}
let
mut
maybe
=
false
;
let
doc_author_rules_apply
=
element
.
each_applicable_non_document_style_rule_data
(
|
data
_
|
{
maybe
=
maybe
|
|
f
(
&
*
data
)
;
}
)
;
if
maybe
|
|
f
(
&
self
.
cascade_data
.
user
)
{
return
true
;
}
doc_author_rules_apply
&
&
f
(
&
self
.
cascade_data
.
author
)
}
pub
fn
precomputed_values_for_pseudo
<
E
>
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent
:
Option
<
&
ComputedValues
>
font_metrics
:
&
dyn
FontMetricsProvider
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
debug_assert
!
(
pseudo
.
is_precomputed
(
)
)
;
let
rule_node
=
self
.
rule_node_for_precomputed_pseudo
(
guards
pseudo
vec
!
[
]
)
;
self
.
precomputed_values_for_pseudo_with_rule_node
:
:
<
E
>
(
guards
pseudo
parent
font_metrics
rule_node
)
}
pub
fn
precomputed_values_for_pseudo_with_rule_node
<
E
>
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent
:
Option
<
&
ComputedValues
>
font_metrics
:
&
dyn
FontMetricsProvider
rules
:
StrongRuleNode
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
self
.
compute_pseudo_element_style_with_inputs
:
:
<
E
>
(
CascadeInputs
{
rules
:
Some
(
rules
)
visited_rules
:
None
}
pseudo
guards
parent
font_metrics
None
)
}
pub
fn
rule_node_for_precomputed_pseudo
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
mut
extra_declarations
:
Vec
<
ApplicableDeclarationBlock
>
)
-
>
StrongRuleNode
{
let
mut
declarations_with_extra
;
let
declarations
=
match
self
.
cascade_data
.
user_agent
.
precomputed_pseudo_element_decls
.
get
(
pseudo
)
{
Some
(
declarations
)
=
>
{
if
!
extra_declarations
.
is_empty
(
)
{
declarations_with_extra
=
declarations
.
clone
(
)
;
declarations_with_extra
.
append
(
&
mut
extra_declarations
)
;
&
*
declarations_with_extra
}
else
{
&
*
*
declarations
}
}
None
=
>
&
[
]
}
;
self
.
rule_tree
.
insert_ordered_rules_with_important
(
declarations
.
into_iter
(
)
.
map
(
|
a
|
a
.
clone
(
)
.
for_rule_tree
(
)
)
guards
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
style_for_anonymous
<
E
>
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent_style
:
&
ComputedValues
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
use
crate
:
:
font_metrics
:
:
ServoMetricsProvider
;
self
.
precomputed_values_for_pseudo
:
:
<
E
>
(
guards
&
pseudo
Some
(
parent_style
)
&
ServoMetricsProvider
)
}
pub
fn
lazily_compute_pseudo_element_style
<
E
>
(
&
self
guards
:
&
StylesheetGuards
element
:
E
pseudo
:
&
PseudoElement
rule_inclusion
:
RuleInclusion
parent_style
:
&
ComputedValues
is_probe
:
bool
font_metrics
:
&
dyn
FontMetricsProvider
matching_fn
:
Option
<
&
dyn
Fn
(
&
PseudoElement
)
-
>
bool
>
)
-
>
Option
<
Arc
<
ComputedValues
>
>
where
E
:
TElement
{
let
cascade_inputs
=
self
.
lazy_pseudo_rules
(
guards
element
parent_style
pseudo
is_probe
rule_inclusion
matching_fn
)
?
;
Some
(
self
.
compute_pseudo_element_style_with_inputs
(
cascade_inputs
pseudo
guards
Some
(
parent_style
)
font_metrics
Some
(
element
)
)
)
}
pub
fn
compute_pseudo_element_style_with_inputs
<
E
>
(
&
self
inputs
:
CascadeInputs
pseudo
:
&
PseudoElement
guards
:
&
StylesheetGuards
parent_style
:
Option
<
&
ComputedValues
>
font_metrics
:
&
dyn
FontMetricsProvider
element
:
Option
<
E
>
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
self
.
cascade_style_and_visited
(
element
Some
(
pseudo
)
inputs
guards
parent_style
parent_style
parent_style
font_metrics
None
&
mut
RuleCacheConditions
:
:
default
(
)
)
}
pub
fn
cascade_style_and_visited
<
E
>
(
&
self
element
:
Option
<
E
>
pseudo
:
Option
<
&
PseudoElement
>
inputs
:
CascadeInputs
guards
:
&
StylesheetGuards
parent_style
:
Option
<
&
ComputedValues
>
parent_style_ignoring_first_line
:
Option
<
&
ComputedValues
>
layout_parent_style
:
Option
<
&
ComputedValues
>
font_metrics
:
&
dyn
FontMetricsProvider
rule_cache
:
Option
<
&
RuleCache
>
rule_cache_conditions
:
&
mut
RuleCacheConditions
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
debug_assert
!
(
pseudo
.
is_some
(
)
|
|
element
.
is_some
(
)
"
Huh
?
"
)
;
let
visited_rules
=
match
inputs
.
visited_rules
.
as_ref
(
)
{
Some
(
rules
)
=
>
Some
(
rules
)
None
=
>
{
if
parent_style
.
and_then
(
|
s
|
s
.
visited_style
(
)
)
.
is_some
(
)
{
Some
(
inputs
.
rules
.
as_ref
(
)
.
unwrap_or
(
self
.
rule_tree
.
root
(
)
)
)
}
else
{
None
}
}
}
;
properties
:
:
cascade
:
:
<
E
>
(
&
self
.
device
pseudo
inputs
.
rules
.
as_ref
(
)
.
unwrap_or
(
self
.
rule_tree
.
root
(
)
)
guards
parent_style
parent_style_ignoring_first_line
layout_parent_style
visited_rules
font_metrics
self
.
quirks_mode
rule_cache
rule_cache_conditions
element
)
}
fn
lazy_pseudo_rules
<
E
>
(
&
self
guards
:
&
StylesheetGuards
element
:
E
parent_style
:
&
ComputedValues
pseudo
:
&
PseudoElement
is_probe
:
bool
rule_inclusion
:
RuleInclusion
matching_fn
:
Option
<
&
dyn
Fn
(
&
PseudoElement
)
-
>
bool
>
)
-
>
Option
<
CascadeInputs
>
where
E
:
TElement
{
debug_assert
!
(
pseudo
.
is_lazy
(
)
)
;
let
mut
set_selector_flags
=
|
element
:
&
E
flags
:
ElementSelectorFlags
|
{
if
cfg
!
(
feature
=
"
servo
"
)
{
unreachable
!
(
"
internal
pseudo
generated
slow
selector
flags
?
"
)
;
}
if
rule_inclusion
=
=
RuleInclusion
:
:
DefaultOnly
{
return
;
}
debug_assert_eq
!
(
thread_state
:
:
get
(
)
ThreadState
:
:
LAYOUT
)
;
let
self_flags
=
flags
.
for_self
(
)
;
if
!
self_flags
.
is_empty
(
)
{
unsafe
{
element
.
set_selector_flags
(
self_flags
)
;
}
}
let
parent_flags
=
flags
.
for_parent
(
)
;
if
!
parent_flags
.
is_empty
(
)
{
if
let
Some
(
p
)
=
element
.
parent_element
(
)
{
unsafe
{
p
.
set_selector_flags
(
parent_flags
)
;
}
}
}
}
;
let
mut
declarations
=
ApplicableDeclarationList
:
:
new
(
)
;
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
ForStatelessPseudoElement
None
None
self
.
quirks_mode
)
;
matching_context
.
pseudo_element_matching_fn
=
matching_fn
;
self
.
push_applicable_declarations
(
element
Some
(
&
pseudo
)
None
None
Default
:
:
default
(
)
rule_inclusion
&
mut
declarations
&
mut
matching_context
&
mut
set_selector_flags
)
;
if
declarations
.
is_empty
(
)
&
&
is_probe
{
return
None
;
}
let
rules
=
self
.
rule_tree
.
compute_rule_node
(
&
mut
declarations
guards
)
;
let
mut
visited_rules
=
None
;
if
parent_style
.
visited_style
(
)
.
is_some
(
)
{
let
mut
declarations
=
ApplicableDeclarationList
:
:
new
(
)
;
let
mut
matching_context
=
MatchingContext
:
:
new_for_visited
(
MatchingMode
:
:
ForStatelessPseudoElement
None
None
VisitedHandlingMode
:
:
RelevantLinkVisited
self
.
quirks_mode
)
;
matching_context
.
pseudo_element_matching_fn
=
matching_fn
;
self
.
push_applicable_declarations
(
element
Some
(
&
pseudo
)
None
None
Default
:
:
default
(
)
rule_inclusion
&
mut
declarations
&
mut
matching_context
&
mut
set_selector_flags
)
;
if
!
declarations
.
is_empty
(
)
{
let
rule_node
=
self
.
rule_tree
.
insert_ordered_rules_with_important
(
declarations
.
drain
(
.
.
)
.
map
(
|
a
|
a
.
for_rule_tree
(
)
)
guards
)
;
if
rule_node
!
=
*
self
.
rule_tree
.
root
(
)
{
visited_rules
=
Some
(
rule_node
)
;
}
}
}
Some
(
CascadeInputs
{
rules
:
Some
(
rules
)
visited_rules
}
)
}
pub
fn
set_device
(
&
mut
self
mut
device
:
Device
guards
:
&
StylesheetGuards
)
-
>
OriginSet
{
if
viewport_rule
:
:
enabled
(
)
{
let
cascaded_rule
=
{
let
stylesheets
=
self
.
stylesheets
.
iter
(
)
;
ViewportRule
{
declarations
:
viewport_rule
:
:
Cascade
:
:
from_stylesheets
(
stylesheets
guards
&
device
)
.
finish
(
)
}
}
;
self
.
viewport_constraints
=
ViewportConstraints
:
:
maybe_new
(
&
device
&
cascaded_rule
self
.
quirks_mode
)
;
if
let
Some
(
ref
constraints
)
=
self
.
viewport_constraints
{
device
.
account_for_viewport_rule
(
constraints
)
;
}
}
self
.
device
=
device
;
self
.
media_features_change_changed_style
(
guards
&
self
.
device
)
}
pub
fn
media_features_change_changed_style
(
&
self
guards
:
&
StylesheetGuards
device
:
&
Device
)
-
>
OriginSet
{
debug
!
(
"
Stylist
:
:
media_features_change_changed_style
{
:
?
}
"
device
)
;
let
mut
origins
=
OriginSet
:
:
empty
(
)
;
let
stylesheets
=
self
.
stylesheets
.
iter
(
)
;
for
(
stylesheet
origin
)
in
stylesheets
{
if
origins
.
contains
(
origin
.
into
(
)
)
{
continue
;
}
let
guard
=
guards
.
for_origin
(
origin
)
;
let
origin_cascade_data
=
self
.
cascade_data
.
borrow_for_origin
(
origin
)
;
let
affected_changed
=
!
origin_cascade_data
.
media_feature_affected_matches
(
stylesheet
guard
device
self
.
quirks_mode
)
;
if
affected_changed
{
origins
|
=
origin
;
}
}
origins
}
pub
fn
viewport_constraints
(
&
self
)
-
>
Option
<
&
ViewportConstraints
>
{
self
.
viewport_constraints
.
as_ref
(
)
}
pub
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
{
self
.
quirks_mode
}
pub
fn
set_quirks_mode
(
&
mut
self
quirks_mode
:
QuirksMode
)
{
if
self
.
quirks_mode
=
=
quirks_mode
{
return
;
}
self
.
quirks_mode
=
quirks_mode
;
self
.
force_stylesheet_origins_dirty
(
OriginSet
:
:
all
(
)
)
;
}
pub
fn
push_applicable_declarations
<
E
F
>
(
&
self
element
:
E
pseudo_element
:
Option
<
&
PseudoElement
>
style_attribute
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
smil_override
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
animation_declarations
:
AnimationDeclarations
rule_inclusion
:
RuleInclusion
applicable_declarations
:
&
mut
ApplicableDeclarationList
context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
flags_setter
:
&
mut
F
)
where
E
:
TElement
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
RuleCollector
:
:
new
(
self
element
pseudo_element
style_attribute
smil_override
animation_declarations
rule_inclusion
applicable_declarations
context
flags_setter
)
.
collect_all
(
)
;
}
#
[
inline
]
pub
fn
may_have_rules_for_id
<
E
>
(
&
self
id
:
&
WeakAtom
element
:
E
)
-
>
bool
where
E
:
TElement
{
match
self
.
quirks_mode
(
)
.
classes_and_ids_case_sensitivity
(
)
{
CaseSensitivity
:
:
AsciiCaseInsensitive
=
>
return
true
CaseSensitivity
:
:
CaseSensitive
=
>
{
}
}
self
.
any_applicable_rule_data
(
element
|
data
|
data
.
mapped_ids
.
contains
(
id
)
)
}
#
[
inline
]
pub
fn
get_animation
<
'
a
E
>
(
&
'
a
self
name
:
&
Atom
element
:
E
)
-
>
Option
<
&
'
a
KeyframesAnimation
>
where
E
:
TElement
+
'
a
{
macro_rules
!
try_find_in
{
(
data
:
expr
)
=
>
{
if
let
Some
(
animation
)
=
data
.
animations
.
get
(
name
)
{
return
Some
(
animation
)
;
}
}
;
}
if
let
Some
(
shadow
)
=
element
.
shadow_root
(
)
{
if
let
Some
(
data
)
=
shadow
.
style_data
(
)
{
try_find_in
!
(
data
)
;
}
}
if
let
Some
(
shadow
)
=
containing_shadow_ignoring_svg_use
(
element
)
{
if
let
Some
(
data
)
=
shadow
.
style_data
(
)
{
try_find_in
!
(
data
)
;
}
}
else
{
try_find_in
!
(
self
.
cascade_data
.
author
)
;
}
try_find_in
!
(
self
.
cascade_data
.
user
)
;
try_find_in
!
(
self
.
cascade_data
.
user_agent
.
cascade_data
)
;
None
}
pub
fn
match_revalidation_selectors
<
E
F
>
(
&
self
element
:
E
bloom
:
Option
<
&
BloomFilter
>
nth_index_cache
:
&
mut
NthIndexCache
flags_setter
:
&
mut
F
)
-
>
SmallBitVec
where
E
:
TElement
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
Normal
bloom
Some
(
nth_index_cache
)
self
.
quirks_mode
)
;
let
mut
results
=
SmallBitVec
:
:
new
(
)
;
let
matches_document_rules
=
element
.
each_applicable_non_document_style_rule_data
(
|
data
host
|
{
matching_context
.
with_shadow_host
(
Some
(
host
)
|
matching_context
|
{
data
.
selectors_for_cache_revalidation
.
lookup
(
element
self
.
quirks_mode
|
selector_and_hashes
|
{
results
.
push
(
matches_selector
(
&
selector_and_hashes
.
selector
selector_and_hashes
.
selector_offset
Some
(
&
selector_and_hashes
.
hashes
)
&
element
matching_context
flags_setter
)
)
;
true
}
)
;
}
)
}
)
;
for
(
data
origin
)
in
self
.
cascade_data
.
iter_origins
(
)
{
if
origin
=
=
Origin
:
:
Author
&
&
!
matches_document_rules
{
continue
;
}
data
.
selectors_for_cache_revalidation
.
lookup
(
element
self
.
quirks_mode
|
selector_and_hashes
|
{
results
.
push
(
matches_selector
(
&
selector_and_hashes
.
selector
selector_and_hashes
.
selector_offset
Some
(
&
selector_and_hashes
.
hashes
)
&
element
&
mut
matching_context
flags_setter
)
)
;
true
}
)
;
}
results
}
pub
fn
compute_for_declarations
<
E
>
(
&
self
guards
:
&
StylesheetGuards
parent_style
:
&
ComputedValues
declarations
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
use
crate
:
:
font_metrics
:
:
get_metrics_provider_for_product
;
let
block
=
declarations
.
read_with
(
guards
.
author
)
;
let
metrics
=
get_metrics_provider_for_product
(
)
;
properties
:
:
apply_declarations
:
:
<
E
_
>
(
&
self
.
device
None
self
.
rule_tree
.
root
(
)
guards
block
.
declaration_importance_iter
(
)
.
map
(
|
(
declaration
_
)
|
(
declaration
Origin
:
:
Author
)
)
Some
(
parent_style
)
Some
(
parent_style
)
Some
(
parent_style
)
&
metrics
CascadeMode
:
:
Unvisited
{
visited_rules
:
None
}
self
.
quirks_mode
None
&
mut
Default
:
:
default
(
)
None
)
}
#
[
inline
]
pub
fn
device
(
&
self
)
-
>
&
Device
{
&
self
.
device
}
#
[
inline
]
pub
fn
device_mut
(
&
mut
self
)
-
>
&
mut
Device
{
&
mut
self
.
device
}
#
[
inline
]
pub
fn
rule_tree
(
&
self
)
-
>
&
RuleTree
{
&
self
.
rule_tree
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
cascade_data
.
add_size_of
(
ops
sizes
)
;
self
.
author_data_cache
.
add_size_of
(
ops
sizes
)
;
sizes
.
mRuleTree
+
=
self
.
rule_tree
.
size_of
(
ops
)
;
}
pub
fn
shutdown
(
)
{
let
_entries
=
UA_CASCADE_DATA_CACHE
.
lock
(
)
.
unwrap
(
)
.
take_all
(
)
;
}
}
#
[
derive
(
Clone
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
pub
struct
ExtraStyleData
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
font_faces
:
Vec
<
Arc
<
Locked
<
FontFaceRule
>
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
font_feature_values
:
Vec
<
Arc
<
Locked
<
FontFeatureValuesRule
>
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
counter_styles
:
PrecomputedHashMap
<
Atom
Arc
<
Locked
<
CounterStyleRule
>
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
pages
:
Vec
<
Arc
<
Locked
<
PageRule
>
>
>
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ExtraStyleData
{
fn
add_font_face
(
&
mut
self
rule
:
&
Arc
<
Locked
<
FontFaceRule
>
>
)
{
self
.
font_faces
.
push
(
rule
.
clone
(
)
)
;
}
fn
add_font_feature_values
(
&
mut
self
rule
:
&
Arc
<
Locked
<
FontFeatureValuesRule
>
>
)
{
self
.
font_feature_values
.
push
(
rule
.
clone
(
)
)
;
}
fn
add_counter_style
(
&
mut
self
guard
:
&
SharedRwLockReadGuard
rule
:
&
Arc
<
Locked
<
CounterStyleRule
>
>
)
{
let
name
=
rule
.
read_with
(
guard
)
.
name
(
)
.
0
.
clone
(
)
;
self
.
counter_styles
.
insert
(
name
rule
.
clone
(
)
)
;
}
fn
add_page
(
&
mut
self
rule
:
&
Arc
<
Locked
<
PageRule
>
>
)
{
self
.
pages
.
push
(
rule
.
clone
(
)
)
;
}
}
impl
ExtraStyleData
{
fn
clear
(
&
mut
self
)
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
font_faces
.
clear
(
)
;
self
.
font_feature_values
.
clear
(
)
;
self
.
counter_styles
.
clear
(
)
;
self
.
pages
.
clear
(
)
;
}
}
}
pub
struct
ExtraStyleDataIterator
<
'
a
>
(
DocumentCascadeDataIter
<
'
a
>
)
;
impl
<
'
a
>
Iterator
for
ExtraStyleDataIterator
<
'
a
>
{
type
Item
=
(
&
'
a
ExtraStyleData
Origin
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
0
.
next
(
)
.
map
(
|
d
|
(
&
d
.
0
.
extra_data
d
.
1
)
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
MallocSizeOf
for
ExtraStyleData
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
0
;
n
+
=
self
.
font_faces
.
shallow_size_of
(
ops
)
;
n
+
=
self
.
font_feature_values
.
shallow_size_of
(
ops
)
;
n
+
=
self
.
counter_styles
.
shallow_size_of
(
ops
)
;
n
+
=
self
.
pages
.
shallow_size_of
(
ops
)
;
n
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
Debug
)
]
struct
RevalidationSelectorAndHashes
{
#
[
cfg_attr
(
feature
=
"
gecko
"
ignore_malloc_size_of
=
"
CssRules
have
primary
refs
we
measure
there
"
)
]
selector
:
Selector
<
SelectorImpl
>
selector_offset
:
usize
hashes
:
AncestorHashes
}
impl
RevalidationSelectorAndHashes
{
fn
new
(
selector
:
Selector
<
SelectorImpl
>
hashes
:
AncestorHashes
)
-
>
Self
{
let
selector_offset
=
{
let
mut
index
=
0
;
let
mut
iter
=
selector
.
iter
(
)
;
for
_
in
&
mut
iter
{
index
+
=
1
;
}
match
iter
.
next_sequence
(
)
{
Some
(
Combinator
:
:
PseudoElement
)
=
>
index
+
1
_
=
>
0
}
}
;
RevalidationSelectorAndHashes
{
selector
selector_offset
hashes
}
}
}
impl
SelectorMapEntry
for
RevalidationSelectorAndHashes
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter_from
(
self
.
selector_offset
)
}
}
struct
StylistSelectorVisitor
<
'
a
>
{
passed_rightmost_selector
:
bool
needs_revalidation
:
&
'
a
mut
bool
mapped_ids
:
&
'
a
mut
PrecomputedHashSet
<
Atom
>
attribute_dependencies
:
&
'
a
mut
PrecomputedHashSet
<
LocalName
>
state_dependencies
:
&
'
a
mut
ElementState
document_state_dependencies
:
&
'
a
mut
DocumentState
}
fn
component_needs_revalidation
(
c
:
&
Component
<
SelectorImpl
>
passed_rightmost_selector
:
bool
)
-
>
bool
{
match
*
c
{
Component
:
:
ID
(
_
)
=
>
{
passed_rightmost_selector
}
Component
:
:
AttributeInNoNamespaceExists
{
.
.
}
|
Component
:
:
AttributeInNoNamespace
{
.
.
}
|
Component
:
:
AttributeOther
(
_
)
|
Component
:
:
Empty
|
Component
:
:
FirstChild
|
Component
:
:
LastChild
|
Component
:
:
OnlyChild
|
Component
:
:
NthChild
(
.
.
)
|
Component
:
:
NthLastChild
(
.
.
)
|
Component
:
:
NthOfType
(
.
.
)
|
Component
:
:
NthLastOfType
(
.
.
)
|
Component
:
:
FirstOfType
|
Component
:
:
LastOfType
|
Component
:
:
OnlyOfType
=
>
true
Component
:
:
NonTSPseudoClass
(
ref
p
)
=
>
p
.
needs_cache_revalidation
(
)
_
=
>
false
}
}
impl
<
'
a
>
SelectorVisitor
for
StylistSelectorVisitor
<
'
a
>
{
type
Impl
=
SelectorImpl
;
fn
visit_complex_selector
(
&
mut
self
combinator
:
Option
<
Combinator
>
)
-
>
bool
{
*
self
.
needs_revalidation
=
*
self
.
needs_revalidation
|
|
combinator
.
map_or
(
false
|
c
|
c
.
is_sibling
(
)
)
;
self
.
passed_rightmost_selector
=
self
.
passed_rightmost_selector
|
|
!
matches
!
(
combinator
None
|
Some
(
Combinator
:
:
PseudoElement
)
)
;
true
}
fn
visit_selector_list
(
&
mut
self
list
:
&
[
Selector
<
Self
:
:
Impl
>
]
)
-
>
bool
{
for
selector
in
list
{
let
mut
nested
=
StylistSelectorVisitor
{
passed_rightmost_selector
:
false
needs_revalidation
:
&
mut
*
self
.
needs_revalidation
attribute_dependencies
:
&
mut
*
self
.
attribute_dependencies
state_dependencies
:
&
mut
*
self
.
state_dependencies
document_state_dependencies
:
&
mut
*
self
.
document_state_dependencies
mapped_ids
:
&
mut
*
self
.
mapped_ids
}
;
let
_ret
=
selector
.
visit
(
&
mut
nested
)
;
debug_assert
!
(
_ret
"
We
never
return
false
"
)
;
}
true
}
fn
visit_attribute_selector
(
&
mut
self
_ns
:
&
NamespaceConstraint
<
&
Namespace
>
name
:
&
LocalName
lower_name
:
&
LocalName
)
-
>
bool
{
self
.
attribute_dependencies
.
insert
(
name
.
clone
(
)
)
;
self
.
attribute_dependencies
.
insert
(
lower_name
.
clone
(
)
)
;
true
}
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
*
self
.
needs_revalidation
=
*
self
.
needs_revalidation
|
|
component_needs_revalidation
(
s
self
.
passed_rightmost_selector
)
;
match
*
s
{
Component
:
:
NonTSPseudoClass
(
ref
p
)
=
>
{
self
.
state_dependencies
.
insert
(
p
.
state_flag
(
)
)
;
self
.
document_state_dependencies
.
insert
(
p
.
document_state_flag
(
)
)
;
}
Component
:
:
ID
(
ref
id
)
if
!
self
.
passed_rightmost_selector
=
>
{
self
.
mapped_ids
.
insert
(
id
.
0
.
clone
(
)
)
;
}
_
=
>
{
}
}
true
}
}
#
[
derive
(
Clone
Debug
Default
MallocSizeOf
)
]
struct
GenericElementAndPseudoRules
<
Map
>
{
element_map
:
Map
pseudos_map
:
PerPseudoElementMap
<
Box
<
Map
>
>
}
impl
<
Map
:
Default
+
MallocSizeOf
>
GenericElementAndPseudoRules
<
Map
>
{
#
[
inline
(
always
)
]
fn
for_insertion
(
&
mut
self
pseudo_element
:
Option
<
&
PseudoElement
>
)
-
>
&
mut
Map
{
debug_assert
!
(
pseudo_element
.
map_or
(
true
|
pseudo
|
{
!
pseudo
.
is_precomputed
(
)
&
&
!
pseudo
.
is_unknown_webkit_pseudo_element
(
)
}
)
"
Precomputed
pseudos
should
end
up
in
precomputed_pseudo_element_decls
\
and
unknown
webkit
pseudos
should
be
discarded
before
getting
here
"
)
;
match
pseudo_element
{
None
=
>
&
mut
self
.
element_map
Some
(
pseudo
)
=
>
self
.
pseudos_map
.
get_or_insert_with
(
pseudo
|
|
Box
:
:
new
(
Default
:
:
default
(
)
)
)
}
}
#
[
inline
]
fn
rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
Map
>
{
match
pseudo
{
Some
(
pseudo
)
=
>
self
.
pseudos_map
.
get
(
pseudo
)
.
map
(
|
p
|
&
*
*
p
)
None
=
>
Some
(
&
self
.
element_map
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
sizes
.
mElementAndPseudosMaps
+
=
self
.
element_map
.
size_of
(
ops
)
;
for
elem
in
self
.
pseudos_map
.
iter
(
)
{
if
let
Some
(
ref
elem
)
=
*
elem
{
sizes
.
mElementAndPseudosMaps
+
=
<
Box
<
_
>
as
MallocSizeOf
>
:
:
size_of
(
elem
ops
)
;
}
}
}
}
type
ElementAndPseudoRules
=
GenericElementAndPseudoRules
<
SelectorMap
<
Rule
>
>
;
type
PartMap
=
PrecomputedHashMap
<
Atom
SmallVec
<
[
Rule
;
1
]
>
>
;
type
PartElementAndPseudoRules
=
GenericElementAndPseudoRules
<
PartMap
>
;
impl
ElementAndPseudoRules
{
fn
clear
(
&
mut
self
)
{
self
.
element_map
.
clear
(
)
;
self
.
pseudos_map
.
clear
(
)
;
}
}
impl
PartElementAndPseudoRules
{
fn
clear
(
&
mut
self
)
{
self
.
element_map
.
clear
(
)
;
self
.
pseudos_map
.
clear
(
)
;
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
struct
CascadeLayer
{
id
:
LayerId
order
:
LayerOrder
children
:
Vec
<
LayerId
>
}
impl
CascadeLayer
{
const
fn
root
(
)
-
>
Self
{
Self
{
id
:
LayerId
:
:
root
(
)
order
:
LayerOrder
:
:
root
(
)
children
:
vec
!
[
]
}
}
}
#
[
derive
(
Debug
Clone
MallocSizeOf
)
]
pub
struct
CascadeData
{
normal_rules
:
ElementAndPseudoRules
host_rules
:
Option
<
Box
<
ElementAndPseudoRules
>
>
slotted_rules
:
Option
<
Box
<
ElementAndPseudoRules
>
>
part_rules
:
Option
<
Box
<
PartElementAndPseudoRules
>
>
invalidation_map
:
InvalidationMap
attribute_dependencies
:
PrecomputedHashSet
<
LocalName
>
state_dependencies
:
ElementState
document_state_dependencies
:
DocumentState
mapped_ids
:
PrecomputedHashSet
<
Atom
>
#
[
ignore_malloc_size_of
=
"
Arc
"
]
selectors_for_cache_revalidation
:
SelectorMap
<
RevalidationSelectorAndHashes
>
animations
:
PrecomputedHashMap
<
Atom
KeyframesAnimation
>
layer_id
:
FxHashMap
<
LayerName
LayerId
>
layers
:
SmallVec
<
[
CascadeLayer
;
1
]
>
effective_media_query_results
:
EffectiveMediaQueryResults
extra_data
:
ExtraStyleData
rules_source_order
:
u32
num_selectors
:
usize
num_declarations
:
usize
}
impl
CascadeData
{
pub
fn
new
(
)
-
>
Self
{
Self
{
normal_rules
:
ElementAndPseudoRules
:
:
default
(
)
host_rules
:
None
slotted_rules
:
None
part_rules
:
None
invalidation_map
:
InvalidationMap
:
:
new
(
)
attribute_dependencies
:
PrecomputedHashSet
:
:
default
(
)
state_dependencies
:
ElementState
:
:
empty
(
)
document_state_dependencies
:
DocumentState
:
:
empty
(
)
mapped_ids
:
PrecomputedHashSet
:
:
default
(
)
selectors_for_cache_revalidation
:
SelectorMap
:
:
new_without_attribute_bucketing
(
)
animations
:
Default
:
:
default
(
)
layer_id
:
Default
:
:
default
(
)
layers
:
smallvec
:
:
smallvec
!
[
CascadeLayer
:
:
root
(
)
]
extra_data
:
ExtraStyleData
:
:
default
(
)
effective_media_query_results
:
EffectiveMediaQueryResults
:
:
new
(
)
rules_source_order
:
0
num_selectors
:
0
num_declarations
:
0
}
}
pub
fn
rebuild
<
'
a
S
>
(
&
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
)
-
>
Result
<
(
)
FailedAllocationError
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
if
!
collection
.
dirty
(
)
{
return
Ok
(
(
)
)
;
}
let
validity
=
collection
.
data_validity
(
)
;
match
validity
{
DataValidity
:
:
Valid
=
>
{
}
DataValidity
:
:
CascadeInvalid
=
>
self
.
clear_cascade_data
(
)
DataValidity
:
:
FullyInvalid
=
>
self
.
clear
(
)
}
let
mut
result
=
Ok
(
(
)
)
;
collection
.
each
(
|
stylesheet
rebuild_kind
|
{
result
=
self
.
add_stylesheet
(
device
quirks_mode
stylesheet
guard
rebuild_kind
None
)
;
result
.
is_ok
(
)
}
)
;
self
.
compute_layer_order
(
)
;
result
}
pub
fn
invalidation_map
(
&
self
)
-
>
&
InvalidationMap
{
&
self
.
invalidation_map
}
#
[
inline
]
pub
fn
has_state_dependency
(
&
self
state
:
ElementState
)
-
>
bool
{
self
.
state_dependencies
.
intersects
(
state
)
}
#
[
inline
]
pub
fn
might_have_attribute_dependency
(
&
self
local_name
:
&
LocalName
)
-
>
bool
{
self
.
attribute_dependencies
.
contains
(
local_name
)
}
#
[
inline
]
pub
fn
normal_rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
SelectorMap
<
Rule
>
>
{
self
.
normal_rules
.
rules
(
pseudo
)
}
#
[
inline
]
pub
fn
host_rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
SelectorMap
<
Rule
>
>
{
self
.
host_rules
.
as_ref
(
)
.
and_then
(
|
d
|
d
.
rules
(
pseudo
)
)
}
pub
fn
any_host_rules
(
&
self
)
-
>
bool
{
self
.
host_rules
.
is_some
(
)
}
#
[
inline
]
pub
fn
slotted_rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
SelectorMap
<
Rule
>
>
{
self
.
slotted_rules
.
as_ref
(
)
.
and_then
(
|
d
|
d
.
rules
(
pseudo
)
)
}
pub
fn
any_slotted_rule
(
&
self
)
-
>
bool
{
self
.
slotted_rules
.
is_some
(
)
}
#
[
inline
]
pub
fn
part_rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
PartMap
>
{
self
.
part_rules
.
as_ref
(
)
.
and_then
(
|
d
|
d
.
rules
(
pseudo
)
)
}
pub
fn
any_part_rule
(
&
self
)
-
>
bool
{
self
.
part_rules
.
is_some
(
)
}
#
[
inline
]
fn
layer_order_for
(
&
self
id
:
LayerId
)
-
>
LayerOrder
{
self
.
layers
[
id
.
0
as
usize
]
.
order
}
fn
compute_layer_order
(
&
mut
self
)
{
debug_assert_ne
!
(
self
.
layers
.
len
(
)
0
"
There
should
be
at
least
the
root
layer
!
"
)
;
if
self
.
layers
.
len
(
)
=
=
1
{
return
;
}
let
(
first
remaining
)
=
self
.
layers
.
split_at_mut
(
1
)
;
let
root
=
&
mut
first
[
0
]
;
let
mut
order
=
LayerOrder
:
:
first
(
)
;
compute_layer_order_for_subtree
(
root
remaining
&
mut
order
)
;
fn
compute_layer_order_for_subtree
(
parent
:
&
mut
CascadeLayer
remaining_layers
:
&
mut
[
CascadeLayer
]
order
:
&
mut
LayerOrder
)
{
for
child
in
parent
.
children
.
iter
(
)
{
debug_assert
!
(
parent
.
id
<
*
child
"
Children
are
always
registered
after
parents
"
)
;
let
child_index
=
(
child
.
0
-
parent
.
id
.
0
-
1
)
as
usize
;
let
(
first
remaining
)
=
remaining_layers
.
split_at_mut
(
child_index
+
1
)
;
let
child
=
&
mut
first
[
child_index
]
;
compute_layer_order_for_subtree
(
child
remaining
order
)
;
}
if
parent
.
id
!
=
LayerId
:
:
root
(
)
{
parent
.
order
=
*
order
;
order
.
inc
(
)
;
}
}
}
fn
collect_applicable_media_query_results_into
<
S
>
(
device
:
&
Device
stylesheet
:
&
S
guard
:
&
SharedRwLockReadGuard
results
:
&
mut
Vec
<
MediaListKey
>
contents_list
:
&
mut
StyleSheetContentList
)
where
S
:
StylesheetInDocument
+
'
static
{
if
!
stylesheet
.
enabled
(
)
|
|
!
stylesheet
.
is_effective_for_device
(
device
guard
)
{
return
;
}
debug
!
(
"
+
{
:
?
}
"
stylesheet
)
;
let
contents
=
stylesheet
.
contents
(
)
;
results
.
push
(
contents
.
to_media_list_key
(
)
)
;
contents_list
.
push
(
StylesheetContentsPtr
(
unsafe
{
Arc
:
:
from_raw_addrefed
(
contents
)
}
)
)
;
for
rule
in
stylesheet
.
effective_rules
(
device
guard
)
{
match
*
rule
{
CssRule
:
:
Import
(
ref
lock
)
=
>
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
debug
!
(
"
+
{
:
?
}
"
import_rule
.
stylesheet
.
media
(
guard
)
)
;
results
.
push
(
import_rule
.
to_media_list_key
(
)
)
;
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
let
media_rule
=
lock
.
read_with
(
guard
)
;
debug
!
(
"
+
{
:
?
}
"
media_rule
.
media_queries
.
read_with
(
guard
)
)
;
results
.
push
(
media_rule
.
to_media_list_key
(
)
)
;
}
_
=
>
{
}
}
}
}
fn
add_rule_list
<
S
>
(
&
mut
self
rules
:
std
:
:
slice
:
:
Iter
<
'
_
CssRule
>
device
:
&
Device
quirks_mode
:
QuirksMode
stylesheet
:
&
S
guard
:
&
SharedRwLockReadGuard
rebuild_kind
:
SheetRebuildKind
mut
current_layer
:
&
mut
LayerName
current_layer_id
:
LayerId
mut
precomputed_pseudo_element_decls
:
Option
<
&
mut
PrecomputedPseudoElementDeclarations
>
)
-
>
Result
<
(
)
FailedAllocationError
>
where
S
:
StylesheetInDocument
+
'
static
{
for
rule
in
rules
{
let
mut
handled
=
true
;
match
*
rule
{
CssRule
:
:
Style
(
ref
locked
)
=
>
{
let
style_rule
=
locked
.
read_with
(
&
guard
)
;
self
.
num_declarations
+
=
style_rule
.
block
.
read_with
(
&
guard
)
.
len
(
)
;
for
selector
in
&
style_rule
.
selectors
.
0
{
self
.
num_selectors
+
=
1
;
let
pseudo_element
=
selector
.
pseudo_element
(
)
;
if
let
Some
(
pseudo
)
=
pseudo_element
{
if
pseudo
.
is_precomputed
(
)
{
debug_assert
!
(
selector
.
is_universal
(
)
)
;
debug_assert_eq
!
(
stylesheet
.
contents
(
)
.
origin
Origin
:
:
UserAgent
)
;
debug_assert_eq
!
(
current_layer_id
LayerId
:
:
root
(
)
)
;
precomputed_pseudo_element_decls
.
as_mut
(
)
.
expect
(
"
Expected
precomputed
declarations
for
the
UA
level
"
)
.
get_or_insert_with
(
pseudo
Vec
:
:
new
)
.
push
(
ApplicableDeclarationBlock
:
:
new
(
StyleSource
:
:
from_rule
(
locked
.
clone
(
)
)
self
.
rules_source_order
CascadeLevel
:
:
UANormal
selector
.
specificity
(
)
LayerOrder
:
:
root
(
)
)
)
;
continue
;
}
if
pseudo
.
is_unknown_webkit_pseudo_element
(
)
{
continue
;
}
}
let
hashes
=
AncestorHashes
:
:
new
(
&
selector
quirks_mode
)
;
let
rule
=
Rule
:
:
new
(
selector
.
clone
(
)
hashes
locked
.
clone
(
)
self
.
rules_source_order
current_layer_id
)
;
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
self
.
invalidation_map
.
note_selector
(
selector
quirks_mode
)
?
;
let
mut
needs_revalidation
=
false
;
let
mut
visitor
=
StylistSelectorVisitor
{
needs_revalidation
:
&
mut
needs_revalidation
passed_rightmost_selector
:
false
attribute_dependencies
:
&
mut
self
.
attribute_dependencies
state_dependencies
:
&
mut
self
.
state_dependencies
document_state_dependencies
:
&
mut
self
.
document_state_dependencies
mapped_ids
:
&
mut
self
.
mapped_ids
}
;
rule
.
selector
.
visit
(
&
mut
visitor
)
;
if
needs_revalidation
{
self
.
selectors_for_cache_revalidation
.
insert
(
RevalidationSelectorAndHashes
:
:
new
(
rule
.
selector
.
clone
(
)
rule
.
hashes
.
clone
(
)
)
quirks_mode
)
?
;
}
}
if
let
Some
(
parts
)
=
selector
.
parts
(
)
{
self
.
part_rules
.
get_or_insert_with
(
|
|
Box
:
:
new
(
Default
:
:
default
(
)
)
)
.
for_insertion
(
pseudo_element
)
.
try_entry
(
parts
.
last
(
)
.
unwrap
(
)
.
clone
(
)
.
0
)
?
.
or_insert_with
(
SmallVec
:
:
new
)
.
try_push
(
rule
)
?
;
}
else
{
let
rules
=
if
selector
.
is_featureless_host_selector_or_pseudo_element
(
)
{
self
.
host_rules
.
get_or_insert_with
(
|
|
Box
:
:
new
(
Default
:
:
default
(
)
)
)
}
else
if
selector
.
is_slotted
(
)
{
self
.
slotted_rules
.
get_or_insert_with
(
|
|
Box
:
:
new
(
Default
:
:
default
(
)
)
)
}
else
{
&
mut
self
.
normal_rules
}
.
for_insertion
(
pseudo_element
)
;
rules
.
insert
(
rule
quirks_mode
)
?
;
}
}
self
.
rules_source_order
+
=
1
;
}
CssRule
:
:
Keyframes
(
ref
keyframes_rule
)
=
>
{
use
hashglobe
:
:
hash_map
:
:
Entry
;
let
keyframes_rule
=
keyframes_rule
.
read_with
(
guard
)
;
debug
!
(
"
Found
valid
keyframes
rule
:
{
:
?
}
"
*
keyframes_rule
)
;
match
self
.
animations
.
try_entry
(
keyframes_rule
.
name
.
as_atom
(
)
.
clone
(
)
)
?
{
Entry
:
:
Vacant
(
e
)
=
>
{
e
.
insert
(
KeyframesAnimation
:
:
from_keyframes
(
&
keyframes_rule
.
keyframes
keyframes_rule
.
vendor_prefix
.
clone
(
)
current_layer_id
guard
)
)
;
}
Entry
:
:
Occupied
(
mut
e
)
=
>
{
let
needs_insert
=
keyframes_rule
.
vendor_prefix
.
is_none
(
)
|
|
e
.
get
(
)
.
vendor_prefix
.
is_some
(
)
;
if
needs_insert
{
e
.
insert
(
KeyframesAnimation
:
:
from_keyframes
(
&
keyframes_rule
.
keyframes
keyframes_rule
.
vendor_prefix
.
clone
(
)
current_layer_id
guard
)
)
;
}
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
ScrollTimeline
(
.
.
)
=
>
{
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
FontFace
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_font_face
(
rule
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
FontFeatureValues
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_font_feature_values
(
rule
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
CounterStyle
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_counter_style
(
guard
rule
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
Page
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_page
(
rule
)
;
}
CssRule
:
:
Viewport
(
.
.
)
=
>
{
}
_
=
>
{
handled
=
false
;
}
}
if
handled
{
if
cfg
!
(
debug_assertions
)
{
let
mut
effective
=
false
;
let
children
=
EffectiveRulesIterator
:
:
children
(
rule
device
quirks_mode
guard
&
mut
effective
)
;
debug_assert
!
(
children
.
is_none
(
)
)
;
debug_assert
!
(
effective
)
;
}
continue
;
}
let
mut
effective
=
false
;
let
children
=
EffectiveRulesIterator
:
:
children
(
rule
device
quirks_mode
guard
&
mut
effective
)
;
if
!
effective
{
continue
;
}
fn
maybe_register_layer
(
data
:
&
mut
CascadeData
layer
:
&
LayerName
)
-
>
LayerId
{
if
let
Some
(
id
)
=
data
.
layer_id
.
get
(
layer
)
{
return
*
id
;
}
let
id
=
LayerId
(
data
.
layers
.
len
(
)
as
u32
)
;
let
parent_layer_id
=
if
layer
.
layer_names
(
)
.
len
(
)
>
1
{
let
mut
parent
=
layer
.
clone
(
)
;
parent
.
0
.
pop
(
)
;
*
data
.
layer_id
.
get_mut
(
&
parent
)
.
expect
(
"
Parent
layers
should
be
registered
before
child
layers
"
)
}
else
{
LayerId
:
:
root
(
)
}
;
data
.
layers
[
parent_layer_id
.
0
as
usize
]
.
children
.
push
(
id
)
;
data
.
layers
.
push
(
CascadeLayer
{
id
order
:
LayerOrder
:
:
first
(
)
children
:
vec
!
[
]
}
)
;
data
.
layer_id
.
insert
(
layer
.
clone
(
)
id
)
;
id
}
fn
maybe_register_layers
(
data
:
&
mut
CascadeData
name
:
Option
<
&
LayerName
>
current_layer
:
&
mut
LayerName
pushed_layers
:
&
mut
usize
)
-
>
LayerId
{
let
anon_name
;
let
name
=
match
name
{
Some
(
name
)
=
>
name
None
=
>
{
anon_name
=
LayerName
:
:
new_anonymous
(
)
;
&
anon_name
}
}
;
let
mut
id
=
LayerId
:
:
root
(
)
;
for
name
in
name
.
layer_names
(
)
{
current_layer
.
0
.
push
(
name
.
clone
(
)
)
;
id
=
maybe_register_layer
(
data
&
current_layer
)
;
*
pushed_layers
+
=
1
;
}
debug_assert_ne
!
(
id
LayerId
:
:
root
(
)
)
;
id
}
let
mut
layer_names_to_pop
=
0
;
let
mut
children_layer_id
=
current_layer_id
;
match
*
rule
{
CssRule
:
:
Import
(
ref
lock
)
=
>
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
self
.
effective_media_query_results
.
saw_effective
(
import_rule
)
;
}
if
let
Some
(
ref
layer
)
=
import_rule
.
layer
{
children_layer_id
=
maybe_register_layers
(
self
layer
.
name
.
as_ref
(
)
&
mut
current_layer
&
mut
layer_names_to_pop
)
;
}
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
let
media_rule
=
lock
.
read_with
(
guard
)
;
self
.
effective_media_query_results
.
saw_effective
(
media_rule
)
;
}
}
CssRule
:
:
Layer
(
ref
lock
)
=
>
{
use
crate
:
:
stylesheets
:
:
layer_rule
:
:
LayerRuleKind
;
let
layer_rule
=
lock
.
read_with
(
guard
)
;
match
layer_rule
.
kind
{
LayerRuleKind
:
:
Block
{
ref
name
.
.
}
=
>
{
children_layer_id
=
maybe_register_layers
(
self
name
.
as_ref
(
)
&
mut
current_layer
&
mut
layer_names_to_pop
)
;
}
LayerRuleKind
:
:
Statement
{
ref
names
}
=
>
{
for
name
in
&
*
*
names
{
let
mut
pushed
=
0
;
maybe_register_layers
(
self
Some
(
name
)
&
mut
current_layer
&
mut
pushed
)
;
for
_
in
0
.
.
pushed
{
current_layer
.
0
.
pop
(
)
;
}
}
}
}
}
_
=
>
{
}
}
if
let
Some
(
children
)
=
children
{
self
.
add_rule_list
(
children
device
quirks_mode
stylesheet
guard
rebuild_kind
current_layer
children_layer_id
precomputed_pseudo_element_decls
.
as_deref_mut
(
)
)
?
;
}
for
_
in
0
.
.
layer_names_to_pop
{
current_layer
.
0
.
pop
(
)
;
}
}
Ok
(
(
)
)
}
fn
add_stylesheet
<
S
>
(
&
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
stylesheet
:
&
S
guard
:
&
SharedRwLockReadGuard
rebuild_kind
:
SheetRebuildKind
mut
precomputed_pseudo_element_decls
:
Option
<
&
mut
PrecomputedPseudoElementDeclarations
>
)
-
>
Result
<
(
)
FailedAllocationError
>
where
S
:
StylesheetInDocument
+
'
static
{
if
!
stylesheet
.
enabled
(
)
|
|
!
stylesheet
.
is_effective_for_device
(
device
guard
)
{
return
Ok
(
(
)
)
;
}
let
contents
=
stylesheet
.
contents
(
)
;
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
self
.
effective_media_query_results
.
saw_effective
(
contents
)
;
}
let
mut
current_layer
=
LayerName
:
:
new_empty
(
)
;
self
.
add_rule_list
(
contents
.
rules
(
guard
)
.
iter
(
)
device
quirks_mode
stylesheet
guard
rebuild_kind
&
mut
current_layer
LayerId
:
:
root
(
)
precomputed_pseudo_element_decls
.
as_deref_mut
(
)
)
?
;
Ok
(
(
)
)
}
pub
fn
media_feature_affected_matches
<
S
>
(
&
self
stylesheet
:
&
S
guard
:
&
SharedRwLockReadGuard
device
:
&
Device
quirks_mode
:
QuirksMode
)
-
>
bool
where
S
:
StylesheetInDocument
+
'
static
{
use
crate
:
:
invalidation
:
:
media_queries
:
:
PotentiallyEffectiveMediaRules
;
let
effective_now
=
stylesheet
.
is_effective_for_device
(
device
guard
)
;
let
effective_then
=
self
.
effective_media_query_results
.
was_effective
(
stylesheet
.
contents
(
)
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
Stylesheet
{
:
?
}
changed
-
>
{
}
{
}
"
stylesheet
.
media
(
guard
)
effective_then
effective_now
)
;
return
false
;
}
if
!
effective_now
{
return
true
;
}
let
mut
iter
=
stylesheet
.
iter_rules
:
:
<
PotentiallyEffectiveMediaRules
>
(
device
guard
)
;
while
let
Some
(
rule
)
=
iter
.
next
(
)
{
match
*
rule
{
CssRule
:
:
Style
(
.
.
)
|
CssRule
:
:
Namespace
(
.
.
)
|
CssRule
:
:
FontFace
(
.
.
)
|
CssRule
:
:
CounterStyle
(
.
.
)
|
CssRule
:
:
Supports
(
.
.
)
|
CssRule
:
:
Keyframes
(
.
.
)
|
CssRule
:
:
ScrollTimeline
(
.
.
)
|
CssRule
:
:
Page
(
.
.
)
|
CssRule
:
:
Viewport
(
.
.
)
|
CssRule
:
:
Document
(
.
.
)
|
CssRule
:
:
Layer
(
.
.
)
|
CssRule
:
:
FontFeatureValues
(
.
.
)
=
>
{
continue
;
}
CssRule
:
:
Import
(
ref
lock
)
=
>
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
let
effective_now
=
match
import_rule
.
stylesheet
.
media
(
guard
)
{
Some
(
m
)
=
>
m
.
evaluate
(
device
quirks_mode
)
None
=
>
true
}
;
let
effective_then
=
self
.
effective_media_query_results
.
was_effective
(
import_rule
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
import
rule
{
:
?
}
changed
{
}
-
>
{
}
"
import_rule
.
stylesheet
.
media
(
guard
)
effective_then
effective_now
)
;
return
false
;
}
if
!
effective_now
{
iter
.
skip_children
(
)
;
}
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
let
media_rule
=
lock
.
read_with
(
guard
)
;
let
mq
=
media_rule
.
media_queries
.
read_with
(
guard
)
;
let
effective_now
=
mq
.
evaluate
(
device
quirks_mode
)
;
let
effective_then
=
self
.
effective_media_query_results
.
was_effective
(
media_rule
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
media
rule
{
:
?
}
changed
{
}
-
>
{
}
"
mq
effective_then
effective_now
)
;
return
false
;
}
if
!
effective_now
{
iter
.
skip_children
(
)
;
}
}
}
}
true
}
fn
clear_cascade_data
(
&
mut
self
)
{
self
.
normal_rules
.
clear
(
)
;
if
let
Some
(
ref
mut
slotted_rules
)
=
self
.
slotted_rules
{
slotted_rules
.
clear
(
)
;
}
if
let
Some
(
ref
mut
part_rules
)
=
self
.
part_rules
{
part_rules
.
clear
(
)
;
}
if
let
Some
(
ref
mut
host_rules
)
=
self
.
host_rules
{
host_rules
.
clear
(
)
;
}
self
.
animations
.
clear
(
)
;
self
.
layer_id
.
clear
(
)
;
self
.
layers
.
clear
(
)
;
self
.
layers
.
push
(
CascadeLayer
:
:
root
(
)
)
;
self
.
extra_data
.
clear
(
)
;
self
.
rules_source_order
=
0
;
self
.
num_selectors
=
0
;
self
.
num_declarations
=
0
;
}
fn
clear
(
&
mut
self
)
{
self
.
clear_cascade_data
(
)
;
self
.
invalidation_map
.
clear
(
)
;
self
.
attribute_dependencies
.
clear
(
)
;
self
.
state_dependencies
=
ElementState
:
:
empty
(
)
;
self
.
document_state_dependencies
=
DocumentState
:
:
empty
(
)
;
self
.
mapped_ids
.
clear
(
)
;
self
.
selectors_for_cache_revalidation
.
clear
(
)
;
self
.
effective_media_query_results
.
clear
(
)
;
}
}
impl
CascadeDataCacheEntry
for
CascadeData
{
fn
cascade_data
(
&
self
)
-
>
&
CascadeData
{
self
}
fn
rebuild
<
S
>
(
device
:
&
Device
quirks_mode
:
QuirksMode
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
old
:
&
Self
)
-
>
Result
<
Arc
<
Self
>
FailedAllocationError
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
debug_assert
!
(
collection
.
dirty
(
)
"
We
surely
need
to
do
something
?
"
)
;
let
mut
updatable_entry
=
match
collection
.
data_validity
(
)
{
DataValidity
:
:
Valid
|
DataValidity
:
:
CascadeInvalid
=
>
old
.
clone
(
)
DataValidity
:
:
FullyInvalid
=
>
Self
:
:
new
(
)
}
;
updatable_entry
.
rebuild
(
device
quirks_mode
collection
guard
)
?
;
Ok
(
Arc
:
:
new
(
updatable_entry
)
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
normal_rules
.
add_size_of
(
ops
sizes
)
;
if
let
Some
(
ref
slotted_rules
)
=
self
.
slotted_rules
{
slotted_rules
.
add_size_of
(
ops
sizes
)
;
}
if
let
Some
(
ref
part_rules
)
=
self
.
part_rules
{
part_rules
.
add_size_of
(
ops
sizes
)
;
}
if
let
Some
(
ref
host_rules
)
=
self
.
host_rules
{
host_rules
.
add_size_of
(
ops
sizes
)
;
}
sizes
.
mInvalidationMap
+
=
self
.
invalidation_map
.
size_of
(
ops
)
;
sizes
.
mRevalidationSelectors
+
=
self
.
selectors_for_cache_revalidation
.
size_of
(
ops
)
;
sizes
.
mOther
+
=
self
.
animations
.
size_of
(
ops
)
;
sizes
.
mOther
+
=
self
.
effective_media_query_results
.
size_of
(
ops
)
;
sizes
.
mOther
+
=
self
.
extra_data
.
size_of
(
ops
)
;
}
}
impl
Default
for
CascadeData
{
fn
default
(
)
-
>
Self
{
CascadeData
:
:
new
(
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
Rule
{
#
[
ignore_malloc_size_of
=
"
CssRules
have
primary
refs
we
measure
there
"
]
pub
selector
:
Selector
<
SelectorImpl
>
pub
hashes
:
AncestorHashes
pub
source_order
:
u32
pub
layer_id
:
LayerId
#
[
cfg_attr
(
feature
=
"
gecko
"
ignore_malloc_size_of
=
"
Secondary
ref
.
Primary
ref
is
in
StyleRule
under
Stylesheet
.
"
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
Arc
"
)
]
pub
style_rule
:
Arc
<
Locked
<
StyleRule
>
>
}
impl
SelectorMapEntry
for
Rule
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter
(
)
}
}
impl
Rule
{
pub
fn
specificity
(
&
self
)
-
>
u32
{
self
.
selector
.
specificity
(
)
}
pub
fn
to_applicable_declaration_block
(
&
self
level
:
CascadeLevel
cascade_data
:
&
CascadeData
)
-
>
ApplicableDeclarationBlock
{
let
source
=
StyleSource
:
:
from_rule
(
self
.
style_rule
.
clone
(
)
)
;
ApplicableDeclarationBlock
:
:
new
(
source
self
.
source_order
level
self
.
specificity
(
)
cascade_data
.
layer_order_for
(
self
.
layer_id
)
)
}
pub
fn
new
(
selector
:
Selector
<
SelectorImpl
>
hashes
:
AncestorHashes
style_rule
:
Arc
<
Locked
<
StyleRule
>
>
source_order
:
u32
layer_id
:
LayerId
)
-
>
Self
{
Rule
{
selector
hashes
style_rule
source_order
layer_id
}
}
}
pub
fn
needs_revalidation_for_testing
(
s
:
&
Selector
<
SelectorImpl
>
)
-
>
bool
{
let
mut
attribute_dependencies
=
Default
:
:
default
(
)
;
let
mut
mapped_ids
=
Default
:
:
default
(
)
;
let
mut
state_dependencies
=
ElementState
:
:
empty
(
)
;
let
mut
document_state_dependencies
=
DocumentState
:
:
empty
(
)
;
let
mut
needs_revalidation
=
false
;
let
mut
visitor
=
StylistSelectorVisitor
{
passed_rightmost_selector
:
false
needs_revalidation
:
&
mut
needs_revalidation
attribute_dependencies
:
&
mut
attribute_dependencies
state_dependencies
:
&
mut
state_dependencies
document_state_dependencies
:
&
mut
document_state_dependencies
mapped_ids
:
&
mut
mapped_ids
}
;
s
.
visit
(
&
mut
visitor
)
;
needs_revalidation
}
