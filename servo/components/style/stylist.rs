use
crate
:
:
applicable_declarations
:
:
{
ApplicableDeclarationBlock
ApplicableDeclarationList
CascadePriority
ScopeProximity
}
;
use
crate
:
:
computed_value_flags
:
:
ComputedValueFlags
;
use
crate
:
:
context
:
:
{
CascadeInputs
QuirksMode
}
;
use
crate
:
:
custom_properties
:
:
ComputedCustomProperties
;
use
crate
:
:
dom
:
:
TElement
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
gecko_bindings
:
:
structs
:
:
{
ServoStyleSetSizes
StyleRuleInclusion
}
;
use
crate
:
:
invalidation
:
:
element
:
:
invalidation_map
:
:
{
note_selector_for_invalidation
InvalidationMap
RelativeSelectorInvalidationMap
}
;
use
crate
:
:
invalidation
:
:
media_queries
:
:
{
EffectiveMediaQueryResults
MediaListKey
ToMediaListKey
}
;
use
crate
:
:
invalidation
:
:
stylesheets
:
:
RuleChangeKind
;
use
crate
:
:
media_queries
:
:
Device
;
use
crate
:
:
properties
:
:
{
self
CascadeMode
ComputedValues
FirstLineReparenting
}
;
use
crate
:
:
properties
:
:
{
AnimationDeclarations
PropertyDeclarationBlock
}
;
use
crate
:
:
properties_and_values
:
:
registry
:
:
{
PropertyRegistration
PropertyRegistrationData
ScriptRegistry
as
CustomPropertyScriptRegistry
}
;
use
crate
:
:
rule_cache
:
:
{
RuleCache
RuleCacheConditions
}
;
use
crate
:
:
rule_collector
:
:
RuleCollector
;
use
crate
:
:
rule_tree
:
:
{
CascadeLevel
RuleTree
StrongRuleNode
StyleSource
}
;
use
crate
:
:
selector_map
:
:
{
PrecomputedHashMap
PrecomputedHashSet
SelectorMap
SelectorMapEntry
}
;
use
crate
:
:
selector_parser
:
:
{
NonTSPseudoClass
PerPseudoElementMap
PseudoElement
SelectorImpl
SnapshotMap
}
;
use
crate
:
:
shared_lock
:
:
{
Locked
SharedRwLockReadGuard
StylesheetGuards
}
;
use
crate
:
:
sharing
:
:
{
RevalidationResult
ScopeRevalidationResult
}
;
use
crate
:
:
stylesheet_set
:
:
{
DataValidity
DocumentStylesheetSet
SheetRebuildKind
}
;
use
crate
:
:
stylesheet_set
:
:
{
DocumentStylesheetFlusher
SheetCollectionFlusher
}
;
use
crate
:
:
stylesheets
:
:
container_rule
:
:
ContainerCondition
;
use
crate
:
:
stylesheets
:
:
import_rule
:
:
ImportLayer
;
use
crate
:
:
stylesheets
:
:
keyframes_rule
:
:
KeyframesAnimation
;
use
crate
:
:
stylesheets
:
:
layer_rule
:
:
{
LayerName
LayerOrder
}
;
use
crate
:
:
stylesheets
:
:
scope_rule
:
:
{
collect_scope_roots
element_is_outside_of_scope
scope_selector_list_is_trivial
ImplicitScopeRoot
ScopeRootCandidate
ScopeSubjectMap
ScopeTarget
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
stylesheets
:
:
{
CounterStyleRule
FontFaceRule
FontFeatureValuesRule
FontPaletteValuesRule
}
;
use
crate
:
:
stylesheets
:
:
{
CssRule
EffectiveRulesIterator
Origin
OriginSet
PagePseudoClassFlags
PageRule
PerOrigin
PerOriginIter
StylesheetContents
StylesheetInDocument
}
;
use
crate
:
:
values
:
:
{
computed
AtomIdent
}
;
use
crate
:
:
AllocErr
;
use
crate
:
:
{
Atom
LocalName
Namespace
ShrinkIfNeeded
WeakAtom
}
;
use
dom
:
:
{
DocumentState
ElementState
}
;
use
fxhash
:
:
FxHashMap
;
use
malloc_size_of
:
:
MallocSizeOf
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
malloc_size_of
:
:
{
MallocShallowSizeOf
MallocSizeOfOps
MallocUnconditionalShallowSizeOf
}
;
use
selectors
:
:
attr
:
:
{
CaseSensitivity
NamespaceConstraint
}
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
use
selectors
:
:
matching
:
:
{
matches_selector
selector_may_match
MatchingContext
MatchingMode
NeedsSelectorFlags
SelectorCaches
}
;
use
selectors
:
:
matching
:
:
{
MatchingForInvalidation
VisitedHandlingMode
}
;
use
selectors
:
:
parser
:
:
{
AncestorHashes
Combinator
Component
FeaturelessHostMatches
Selector
SelectorIter
SelectorList
}
;
use
selectors
:
:
visitor
:
:
{
SelectorListKind
SelectorVisitor
}
;
use
servo_arc
:
:
{
Arc
ArcBorrow
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
sync
:
:
Mutex
;
use
std
:
:
{
mem
ops
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
type
StylistSheet
=
crate
:
:
stylesheets
:
:
DocumentStyleSheet
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
type
StylistSheet
=
crate
:
:
gecko
:
:
data
:
:
GeckoStyleSheet
;
#
[
derive
(
Debug
Clone
)
]
struct
StylesheetContentsPtr
(
Arc
<
StylesheetContents
>
)
;
impl
PartialEq
for
StylesheetContentsPtr
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
Arc
:
:
ptr_eq
(
&
self
.
0
&
other
.
0
)
}
}
impl
Eq
for
StylesheetContentsPtr
{
}
impl
Hash
for
StylesheetContentsPtr
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
let
contents
:
&
StylesheetContents
=
&
*
self
.
0
;
(
contents
as
*
const
StylesheetContents
)
.
hash
(
state
)
}
}
type
StyleSheetContentList
=
Vec
<
StylesheetContentsPtr
>
;
#
[
derive
(
Debug
Hash
Default
PartialEq
Eq
)
]
struct
CascadeDataCacheKey
{
media_query_results
:
Vec
<
MediaListKey
>
contents
:
StyleSheetContentList
}
unsafe
impl
Send
for
CascadeDataCacheKey
{
}
unsafe
impl
Sync
for
CascadeDataCacheKey
{
}
trait
CascadeDataCacheEntry
:
Sized
{
fn
rebuild
<
S
>
(
device
:
&
Device
quirks_mode
:
QuirksMode
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
old_entry
:
&
Self
)
-
>
Result
<
Arc
<
Self
>
AllocErr
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
;
}
struct
CascadeDataCache
<
Entry
>
{
entries
:
FxHashMap
<
CascadeDataCacheKey
Arc
<
Entry
>
>
}
impl
<
Entry
>
CascadeDataCache
<
Entry
>
where
Entry
:
CascadeDataCacheEntry
{
fn
new
(
)
-
>
Self
{
Self
{
entries
:
Default
:
:
default
(
)
}
}
fn
len
(
&
self
)
-
>
usize
{
self
.
entries
.
len
(
)
}
fn
lookup
<
'
a
S
>
(
&
'
a
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
old_entry
:
&
Entry
)
-
>
Result
<
Option
<
Arc
<
Entry
>
>
AllocErr
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
use
std
:
:
collections
:
:
hash_map
:
:
Entry
as
HashMapEntry
;
debug
!
(
"
StyleSheetCache
:
:
lookup
(
{
}
)
"
self
.
len
(
)
)
;
if
!
collection
.
dirty
(
)
{
return
Ok
(
None
)
;
}
let
mut
key
=
CascadeDataCacheKey
:
:
default
(
)
;
for
sheet
in
collection
.
sheets
(
)
{
CascadeData
:
:
collect_applicable_media_query_results_into
(
device
sheet
guard
&
mut
key
.
media_query_results
&
mut
key
.
contents
)
}
let
new_entry
;
match
self
.
entries
.
entry
(
key
)
{
HashMapEntry
:
:
Vacant
(
e
)
=
>
{
debug
!
(
"
>
Picking
the
slow
path
(
not
in
the
cache
)
"
)
;
new_entry
=
Entry
:
:
rebuild
(
device
quirks_mode
collection
guard
old_entry
)
?
;
e
.
insert
(
new_entry
.
clone
(
)
)
;
}
HashMapEntry
:
:
Occupied
(
mut
e
)
=
>
{
if
!
std
:
:
ptr
:
:
eq
(
&
*
*
e
.
get
(
)
old_entry
)
{
if
log_enabled
!
(
log
:
:
Level
:
:
Debug
)
{
debug
!
(
"
cache
hit
for
:
"
)
;
for
sheet
in
collection
.
sheets
(
)
{
debug
!
(
"
>
{
:
?
}
"
sheet
)
;
}
}
collection
.
each
(
|
_
_
_
|
true
)
;
return
Ok
(
Some
(
e
.
get
(
)
.
clone
(
)
)
)
;
}
debug
!
(
"
>
Picking
the
slow
path
due
to
same
entry
as
old
"
)
;
new_entry
=
Entry
:
:
rebuild
(
device
quirks_mode
collection
guard
old_entry
)
?
;
e
.
insert
(
new_entry
.
clone
(
)
)
;
}
}
Ok
(
Some
(
new_entry
)
)
}
fn
take_unused
(
&
mut
self
)
-
>
SmallVec
<
[
Arc
<
Entry
>
;
3
]
>
{
let
mut
unused
=
SmallVec
:
:
new
(
)
;
self
.
entries
.
retain
(
|
_key
value
|
{
if
!
value
.
is_unique
(
)
{
return
true
;
}
unused
.
push
(
value
.
clone
(
)
)
;
false
}
)
;
unused
}
fn
take_all
(
&
mut
self
)
-
>
FxHashMap
<
CascadeDataCacheKey
Arc
<
Entry
>
>
{
mem
:
:
take
(
&
mut
self
.
entries
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
sizes
.
mOther
+
=
self
.
entries
.
shallow_size_of
(
ops
)
;
for
(
_key
arc
)
in
self
.
entries
.
iter
(
)
{
sizes
.
mOther
+
=
arc
.
unconditional_shallow_size_of
(
ops
)
;
arc
.
add_size_of
(
ops
sizes
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
add_size_of_ua_cache
(
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
UA_CASCADE_DATA_CACHE
.
lock
(
)
.
unwrap
(
)
.
add_size_of
(
ops
sizes
)
;
}
lazy_static
!
{
/
/
/
A
cache
of
computed
user
-
agent
data
to
be
shared
across
documents
.
static
ref
UA_CASCADE_DATA_CACHE
:
Mutex
<
UserAgentCascadeDataCache
>
=
Mutex
:
:
new
(
UserAgentCascadeDataCache
:
:
new
(
)
)
;
}
impl
CascadeDataCacheEntry
for
UserAgentCascadeData
{
fn
rebuild
<
S
>
(
device
:
&
Device
quirks_mode
:
QuirksMode
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
_old
:
&
Self
)
-
>
Result
<
Arc
<
Self
>
AllocErr
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
let
mut
new_data
=
Self
{
cascade_data
:
CascadeData
:
:
new
(
)
precomputed_pseudo_element_decls
:
PrecomputedPseudoElementDeclarations
:
:
default
(
)
}
;
for
(
index
sheet
)
in
collection
.
sheets
(
)
.
enumerate
(
)
{
new_data
.
cascade_data
.
add_stylesheet
(
device
quirks_mode
sheet
index
guard
SheetRebuildKind
:
:
Full
Some
(
&
mut
new_data
.
precomputed_pseudo_element_decls
)
)
?
;
}
new_data
.
cascade_data
.
did_finish_rebuild
(
)
;
Ok
(
Arc
:
:
new
(
new_data
)
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
cascade_data
.
add_size_of
(
ops
sizes
)
;
sizes
.
mPrecomputedPseudos
+
=
self
.
precomputed_pseudo_element_decls
.
size_of
(
ops
)
;
}
}
type
UserAgentCascadeDataCache
=
CascadeDataCache
<
UserAgentCascadeData
>
;
type
PrecomputedPseudoElementDeclarations
=
PerPseudoElementMap
<
Vec
<
ApplicableDeclarationBlock
>
>
;
#
[
derive
(
Default
)
]
struct
UserAgentCascadeData
{
cascade_data
:
CascadeData
precomputed_pseudo_element_decls
:
PrecomputedPseudoElementDeclarations
}
lazy_static
!
{
/
/
/
The
empty
UA
cascade
data
for
un
-
filled
stylists
.
static
ref
EMPTY_UA_CASCADE_DATA
:
Arc
<
UserAgentCascadeData
>
=
{
let
arc
=
Arc
:
:
new
(
UserAgentCascadeData
:
:
default
(
)
)
;
arc
.
mark_as_intentionally_leaked
(
)
;
arc
}
;
}
#
[
derive
(
MallocSizeOf
)
]
pub
struct
DocumentCascadeData
{
#
[
ignore_malloc_size_of
=
"
Arc
owned
by
UserAgentCascadeDataCache
or
empty
"
]
user_agent
:
Arc
<
UserAgentCascadeData
>
user
:
CascadeData
author
:
CascadeData
per_origin
:
PerOrigin
<
(
)
>
}
impl
Default
for
DocumentCascadeData
{
fn
default
(
)
-
>
Self
{
Self
{
user_agent
:
EMPTY_UA_CASCADE_DATA
.
clone
(
)
user
:
Default
:
:
default
(
)
author
:
Default
:
:
default
(
)
per_origin
:
Default
:
:
default
(
)
}
}
}
pub
struct
DocumentCascadeDataIter
<
'
a
>
{
iter
:
PerOriginIter
<
'
a
(
)
>
cascade_data
:
&
'
a
DocumentCascadeData
}
impl
<
'
a
>
Iterator
for
DocumentCascadeDataIter
<
'
a
>
{
type
Item
=
(
&
'
a
CascadeData
Origin
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
(
_
origin
)
=
self
.
iter
.
next
(
)
?
;
Some
(
(
self
.
cascade_data
.
borrow_for_origin
(
origin
)
origin
)
)
}
}
impl
DocumentCascadeData
{
#
[
inline
]
pub
fn
borrow_for_origin
(
&
self
origin
:
Origin
)
-
>
&
CascadeData
{
match
origin
{
Origin
:
:
UserAgent
=
>
&
self
.
user_agent
.
cascade_data
Origin
:
:
Author
=
>
&
self
.
author
Origin
:
:
User
=
>
&
self
.
user
}
}
fn
iter_origins
(
&
self
)
-
>
DocumentCascadeDataIter
{
DocumentCascadeDataIter
{
iter
:
self
.
per_origin
.
iter_origins
(
)
cascade_data
:
self
}
}
fn
iter_origins_rev
(
&
self
)
-
>
DocumentCascadeDataIter
{
DocumentCascadeDataIter
{
iter
:
self
.
per_origin
.
iter_origins_rev
(
)
cascade_data
:
self
}
}
fn
rebuild
<
'
a
S
>
(
&
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
mut
flusher
:
DocumentStylesheetFlusher
<
'
a
S
>
guards
:
&
StylesheetGuards
)
-
>
Result
<
(
)
AllocErr
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
{
let
origin_flusher
=
flusher
.
flush_origin
(
Origin
:
:
UserAgent
)
;
if
origin_flusher
.
dirty
(
)
{
let
mut
ua_cache
=
UA_CASCADE_DATA_CACHE
.
lock
(
)
.
unwrap
(
)
;
let
new_data
=
ua_cache
.
lookup
(
device
quirks_mode
origin_flusher
guards
.
ua_or_user
&
self
.
user_agent
)
?
;
if
let
Some
(
new_data
)
=
new_data
{
self
.
user_agent
=
new_data
;
}
let
_unused_entries
=
ua_cache
.
take_unused
(
)
;
std
:
:
mem
:
:
drop
(
ua_cache
)
;
}
}
self
.
user
.
rebuild
(
device
quirks_mode
flusher
.
flush_origin
(
Origin
:
:
User
)
guards
.
ua_or_user
)
?
;
self
.
author
.
rebuild
(
device
quirks_mode
flusher
.
flush_origin
(
Origin
:
:
Author
)
guards
.
author
)
?
;
Ok
(
(
)
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
user
.
add_size_of
(
ops
sizes
)
;
self
.
author
.
add_size_of
(
ops
sizes
)
;
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
)
]
pub
enum
AuthorStylesEnabled
{
Yes
No
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
struct
StylistStylesheetSet
(
DocumentStylesheetSet
<
StylistSheet
>
)
;
unsafe
impl
Sync
for
StylistStylesheetSet
{
}
impl
StylistStylesheetSet
{
fn
new
(
)
-
>
Self
{
StylistStylesheetSet
(
DocumentStylesheetSet
:
:
new
(
)
)
}
}
impl
ops
:
:
Deref
for
StylistStylesheetSet
{
type
Target
=
DocumentStylesheetSet
<
StylistSheet
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
ops
:
:
DerefMut
for
StylistStylesheetSet
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
pub
struct
Stylist
{
device
:
Device
stylesheets
:
StylistStylesheetSet
author_data_cache
:
CascadeDataCache
<
CascadeData
>
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
defined
in
selectors
"
)
]
quirks_mode
:
QuirksMode
cascade_data
:
DocumentCascadeData
author_styles_enabled
:
AuthorStylesEnabled
rule_tree
:
RuleTree
script_custom_properties
:
CustomPropertyScriptRegistry
initial_values_for_custom_properties
:
ComputedCustomProperties
initial_values_for_custom_properties_flags
:
ComputedValueFlags
num_rebuilds
:
usize
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
RuleInclusion
{
All
DefaultOnly
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
StyleRuleInclusion
>
for
RuleInclusion
{
fn
from
(
value
:
StyleRuleInclusion
)
-
>
Self
{
match
value
{
StyleRuleInclusion
:
:
All
=
>
RuleInclusion
:
:
All
StyleRuleInclusion
:
:
DefaultOnly
=
>
RuleInclusion
:
:
DefaultOnly
}
}
}
#
[
derive
(
Clone
Copy
Eq
PartialEq
)
]
enum
ScopeMatchesShadowHost
{
NotApplicable
No
Yes
}
impl
Default
for
ScopeMatchesShadowHost
{
fn
default
(
)
-
>
Self
{
Self
:
:
NotApplicable
}
}
impl
ScopeMatchesShadowHost
{
fn
nest_for_scope
(
&
mut
self
matches_shadow_host
:
bool
)
{
match
*
self
{
Self
:
:
NotApplicable
=
>
{
*
self
=
if
matches_shadow_host
{
Self
:
:
Yes
}
else
{
Self
:
:
No
}
;
}
Self
:
:
Yes
if
!
matches_shadow_host
=
>
{
*
self
=
Self
:
:
No
;
}
_
=
>
(
)
}
}
}
#
[
derive
(
Copy
Clone
)
]
enum
NestedDeclarationsContext
{
Style
Scope
}
struct
ContainingRuleState
{
layer_name
:
LayerName
layer_id
:
LayerId
container_condition_id
:
ContainerConditionId
in_starting_style
:
bool
scope_condition_id
:
ScopeConditionId
scope_matches_shadow_host
:
ScopeMatchesShadowHost
ancestor_selector_lists
:
SmallVec
<
[
SelectorList
<
SelectorImpl
>
;
2
]
>
nested_declarations_context
:
NestedDeclarationsContext
}
impl
Default
for
ContainingRuleState
{
fn
default
(
)
-
>
Self
{
Self
{
layer_name
:
LayerName
:
:
new_empty
(
)
layer_id
:
LayerId
:
:
root
(
)
container_condition_id
:
ContainerConditionId
:
:
none
(
)
in_starting_style
:
false
ancestor_selector_lists
:
Default
:
:
default
(
)
scope_condition_id
:
ScopeConditionId
:
:
none
(
)
scope_matches_shadow_host
:
Default
:
:
default
(
)
nested_declarations_context
:
NestedDeclarationsContext
:
:
Style
}
}
}
struct
SavedContainingRuleState
{
ancestor_selector_lists_len
:
usize
layer_name_len
:
usize
layer_id
:
LayerId
container_condition_id
:
ContainerConditionId
in_starting_style
:
bool
scope_condition_id
:
ScopeConditionId
scope_matches_shadow_host
:
ScopeMatchesShadowHost
nested_declarations_context
:
NestedDeclarationsContext
}
impl
ContainingRuleState
{
fn
save
(
&
self
)
-
>
SavedContainingRuleState
{
SavedContainingRuleState
{
ancestor_selector_lists_len
:
self
.
ancestor_selector_lists
.
len
(
)
layer_name_len
:
self
.
layer_name
.
0
.
len
(
)
layer_id
:
self
.
layer_id
container_condition_id
:
self
.
container_condition_id
in_starting_style
:
self
.
in_starting_style
scope_condition_id
:
self
.
scope_condition_id
scope_matches_shadow_host
:
self
.
scope_matches_shadow_host
nested_declarations_context
:
self
.
nested_declarations_context
}
}
fn
restore
(
&
mut
self
saved
:
&
SavedContainingRuleState
)
{
debug_assert
!
(
self
.
layer_name
.
0
.
len
(
)
>
=
saved
.
layer_name_len
)
;
debug_assert
!
(
self
.
ancestor_selector_lists
.
len
(
)
>
=
saved
.
ancestor_selector_lists_len
)
;
self
.
ancestor_selector_lists
.
truncate
(
saved
.
ancestor_selector_lists_len
)
;
self
.
layer_name
.
0
.
truncate
(
saved
.
layer_name_len
)
;
self
.
layer_id
=
saved
.
layer_id
;
self
.
container_condition_id
=
saved
.
container_condition_id
;
self
.
in_starting_style
=
saved
.
in_starting_style
;
self
.
scope_condition_id
=
saved
.
scope_condition_id
;
self
.
scope_matches_shadow_host
=
saved
.
scope_matches_shadow_host
;
self
.
nested_declarations_context
=
saved
.
nested_declarations_context
;
}
}
type
ReplacedSelectors
=
SmallVec
<
[
Selector
<
SelectorImpl
>
;
4
]
>
;
impl
Stylist
{
#
[
inline
]
pub
fn
new
(
device
:
Device
quirks_mode
:
QuirksMode
)
-
>
Self
{
Self
{
device
quirks_mode
stylesheets
:
StylistStylesheetSet
:
:
new
(
)
author_data_cache
:
CascadeDataCache
:
:
new
(
)
cascade_data
:
Default
:
:
default
(
)
author_styles_enabled
:
AuthorStylesEnabled
:
:
Yes
rule_tree
:
RuleTree
:
:
new
(
)
script_custom_properties
:
Default
:
:
default
(
)
initial_values_for_custom_properties
:
Default
:
:
default
(
)
initial_values_for_custom_properties_flags
:
Default
:
:
default
(
)
num_rebuilds
:
0
}
}
#
[
inline
]
pub
fn
cascade_data
(
&
self
)
-
>
&
DocumentCascadeData
{
&
self
.
cascade_data
}
#
[
inline
]
pub
fn
author_styles_enabled
(
&
self
)
-
>
AuthorStylesEnabled
{
self
.
author_styles_enabled
}
#
[
inline
]
pub
fn
iter_origins
(
&
self
)
-
>
DocumentCascadeDataIter
{
self
.
cascade_data
.
iter_origins
(
)
}
pub
fn
remove_unique_author_data_cache_entries
(
&
mut
self
)
{
self
.
author_data_cache
.
take_unused
(
)
;
}
pub
fn
get_custom_property_registration
(
&
self
name
:
&
Atom
)
-
>
&
PropertyRegistrationData
{
if
let
Some
(
registration
)
=
self
.
custom_property_script_registry
(
)
.
get
(
name
)
{
return
&
registration
.
data
;
}
for
(
data
_
)
in
self
.
iter_origins
(
)
{
if
let
Some
(
registration
)
=
data
.
custom_property_registrations
.
get
(
name
)
{
return
&
registration
.
data
;
}
}
PropertyRegistrationData
:
:
unregistered
(
)
}
pub
fn
get_custom_property_initial_values
(
&
self
)
-
>
&
ComputedCustomProperties
{
&
self
.
initial_values_for_custom_properties
}
pub
fn
get_custom_property_initial_values_flags
(
&
self
)
-
>
ComputedValueFlags
{
self
.
initial_values_for_custom_properties_flags
}
pub
fn
rebuild_initial_values_for_custom_properties
(
&
mut
self
)
{
let
mut
initial_values
=
ComputedCustomProperties
:
:
default
(
)
;
let
initial_values_flags
;
{
let
mut
seen_names
=
PrecomputedHashSet
:
:
default
(
)
;
let
mut
rule_cache_conditions
=
RuleCacheConditions
:
:
default
(
)
;
let
context
=
computed
:
:
Context
:
:
new_for_initial_at_property_value
(
self
&
mut
rule_cache_conditions
)
;
for
(
k
v
)
in
self
.
custom_property_script_registry
(
)
.
properties
(
)
.
iter
(
)
{
seen_names
.
insert
(
k
.
clone
(
)
)
;
let
Ok
(
value
)
=
v
.
compute_initial_value
(
&
context
)
else
{
continue
;
}
;
let
map
=
if
v
.
inherits
(
)
{
&
mut
initial_values
.
inherited
}
else
{
&
mut
initial_values
.
non_inherited
}
;
map
.
insert
(
k
value
)
;
}
for
(
data
_
)
in
self
.
iter_origins
(
)
{
for
(
k
v
)
in
data
.
custom_property_registrations
.
iter
(
)
{
if
seen_names
.
insert
(
k
.
clone
(
)
)
{
let
last_value
=
&
v
.
last
(
)
.
unwrap
(
)
.
0
;
let
Ok
(
value
)
=
last_value
.
compute_initial_value
(
&
context
)
else
{
continue
;
}
;
let
map
=
if
last_value
.
inherits
(
)
{
&
mut
initial_values
.
inherited
}
else
{
&
mut
initial_values
.
non_inherited
}
;
map
.
insert
(
k
value
)
;
}
}
}
initial_values_flags
=
context
.
builder
.
flags
(
)
;
}
self
.
initial_values_for_custom_properties_flags
=
initial_values_flags
;
self
.
initial_values_for_custom_properties
=
initial_values
;
}
pub
fn
rebuild_author_data
<
S
>
(
&
mut
self
old_data
:
&
CascadeData
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
)
-
>
Result
<
Option
<
Arc
<
CascadeData
>
>
AllocErr
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
self
.
author_data_cache
.
lookup
(
&
self
.
device
self
.
quirks_mode
collection
guard
old_data
)
}
#
[
inline
]
pub
fn
iter_extra_data_origins
(
&
self
)
-
>
ExtraStyleDataIterator
{
ExtraStyleDataIterator
(
self
.
cascade_data
.
iter_origins
(
)
)
}
#
[
inline
]
pub
fn
iter_extra_data_origins_rev
(
&
self
)
-
>
ExtraStyleDataIterator
{
ExtraStyleDataIterator
(
self
.
cascade_data
.
iter_origins_rev
(
)
)
}
pub
fn
num_selectors
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
d
_
)
|
d
.
num_selectors
)
.
sum
(
)
}
pub
fn
num_declarations
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
d
_
)
|
d
.
num_declarations
)
.
sum
(
)
}
pub
fn
num_rebuilds
(
&
self
)
-
>
usize
{
self
.
num_rebuilds
}
pub
fn
num_revalidation_selectors
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
data
_
)
|
data
.
selectors_for_cache_revalidation
.
len
(
)
)
.
sum
(
)
}
pub
fn
num_invalidations
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
data
_
)
|
{
data
.
invalidation_map
.
len
(
)
+
data
.
relative_selector_invalidation_map
.
len
(
)
}
)
.
sum
(
)
}
pub
fn
has_document_state_dependency
(
&
self
state
:
DocumentState
)
-
>
bool
{
self
.
cascade_data
.
iter_origins
(
)
.
any
(
|
(
d
_
)
|
d
.
document_state_dependencies
.
intersects
(
state
)
)
}
pub
fn
flush
<
E
>
(
&
mut
self
guards
:
&
StylesheetGuards
document_element
:
Option
<
E
>
snapshots
:
Option
<
&
SnapshotMap
>
)
-
>
bool
where
E
:
TElement
{
if
!
self
.
stylesheets
.
has_changed
(
)
{
return
false
;
}
self
.
num_rebuilds
+
=
1
;
let
flusher
=
self
.
stylesheets
.
flush
(
document_element
snapshots
)
;
let
had_invalidations
=
flusher
.
had_invalidations
(
)
;
self
.
cascade_data
.
rebuild
(
&
self
.
device
self
.
quirks_mode
flusher
guards
)
.
unwrap_or_else
(
|
_
|
warn
!
(
"
OOM
in
Stylist
:
:
flush
"
)
)
;
self
.
rebuild_initial_values_for_custom_properties
(
)
;
had_invalidations
}
pub
fn
insert_stylesheet_before
(
&
mut
self
sheet
:
StylistSheet
before_sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
insert_stylesheet_before
(
Some
(
&
self
.
device
)
sheet
before_sheet
guard
)
}
pub
fn
force_stylesheet_origins_dirty
(
&
mut
self
origins
:
OriginSet
)
{
self
.
stylesheets
.
force_dirty
(
origins
)
}
pub
fn
set_author_styles_enabled
(
&
mut
self
enabled
:
AuthorStylesEnabled
)
{
self
.
author_styles_enabled
=
enabled
;
}
pub
fn
stylesheets_have_changed
(
&
self
)
-
>
bool
{
self
.
stylesheets
.
has_changed
(
)
}
pub
fn
append_stylesheet
(
&
mut
self
sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
append_stylesheet
(
Some
(
&
self
.
device
)
sheet
guard
)
}
pub
fn
remove_stylesheet
(
&
mut
self
sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
remove_stylesheet
(
Some
(
&
self
.
device
)
sheet
guard
)
}
pub
fn
rule_changed
(
&
mut
self
sheet
:
&
StylistSheet
rule
:
&
CssRule
guard
:
&
SharedRwLockReadGuard
change_kind
:
RuleChangeKind
)
{
self
.
stylesheets
.
rule_changed
(
Some
(
&
self
.
device
)
sheet
rule
guard
change_kind
)
}
#
[
inline
]
pub
fn
sheet_count
(
&
self
origin
:
Origin
)
-
>
usize
{
self
.
stylesheets
.
sheet_count
(
origin
)
}
#
[
inline
]
pub
fn
sheet_at
(
&
self
origin
:
Origin
index
:
usize
)
-
>
Option
<
&
StylistSheet
>
{
self
.
stylesheets
.
get
(
origin
index
)
}
pub
fn
any_applicable_rule_data
<
E
F
>
(
&
self
element
:
E
mut
f
:
F
)
-
>
bool
where
E
:
TElement
F
:
FnMut
(
&
CascadeData
)
-
>
bool
{
if
f
(
&
self
.
cascade_data
.
user_agent
.
cascade_data
)
{
return
true
;
}
let
mut
maybe
=
false
;
let
doc_author_rules_apply
=
element
.
each_applicable_non_document_style_rule_data
(
|
data
_
|
{
maybe
=
maybe
|
|
f
(
&
*
data
)
;
}
)
;
if
maybe
|
|
f
(
&
self
.
cascade_data
.
user
)
{
return
true
;
}
doc_author_rules_apply
&
&
f
(
&
self
.
cascade_data
.
author
)
}
pub
fn
for_each_cascade_data_with_scope
<
'
a
E
F
>
(
&
'
a
self
element
:
E
mut
f
:
F
)
where
E
:
TElement
+
'
a
F
:
FnMut
(
&
'
a
CascadeData
Option
<
E
>
)
{
f
(
&
self
.
cascade_data
.
user_agent
.
cascade_data
None
)
;
element
.
each_applicable_non_document_style_rule_data
(
|
data
scope
|
{
f
(
data
Some
(
scope
)
)
;
}
)
;
f
(
&
self
.
cascade_data
.
user
None
)
;
f
(
&
self
.
cascade_data
.
author
None
)
;
}
pub
fn
precomputed_values_for_pseudo
<
E
>
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent
:
Option
<
&
ComputedValues
>
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
debug_assert
!
(
pseudo
.
is_precomputed
(
)
)
;
let
rule_node
=
self
.
rule_node_for_precomputed_pseudo
(
guards
pseudo
vec
!
[
]
)
;
self
.
precomputed_values_for_pseudo_with_rule_node
:
:
<
E
>
(
guards
pseudo
parent
rule_node
)
}
pub
fn
precomputed_values_for_pseudo_with_rule_node
<
E
>
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent
:
Option
<
&
ComputedValues
>
rules
:
StrongRuleNode
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
self
.
compute_pseudo_element_style_with_inputs
:
:
<
E
>
(
CascadeInputs
{
rules
:
Some
(
rules
)
visited_rules
:
None
flags
:
Default
:
:
default
(
)
}
pseudo
guards
parent
None
)
}
pub
fn
rule_node_for_precomputed_pseudo
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
mut
extra_declarations
:
Vec
<
ApplicableDeclarationBlock
>
)
-
>
StrongRuleNode
{
let
mut
declarations_with_extra
;
let
declarations
=
match
self
.
cascade_data
.
user_agent
.
precomputed_pseudo_element_decls
.
get
(
pseudo
)
{
Some
(
declarations
)
=
>
{
if
!
extra_declarations
.
is_empty
(
)
{
declarations_with_extra
=
declarations
.
clone
(
)
;
declarations_with_extra
.
append
(
&
mut
extra_declarations
)
;
&
*
declarations_with_extra
}
else
{
&
*
*
declarations
}
}
None
=
>
&
[
]
}
;
self
.
rule_tree
.
insert_ordered_rules_with_important
(
declarations
.
into_iter
(
)
.
map
(
|
a
|
a
.
clone
(
)
.
for_rule_tree
(
)
)
guards
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
style_for_anonymous
<
E
>
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent_style
:
&
ComputedValues
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
self
.
precomputed_values_for_pseudo
:
:
<
E
>
(
guards
&
pseudo
Some
(
parent_style
)
)
}
pub
fn
lazily_compute_pseudo_element_style
<
E
>
(
&
self
guards
:
&
StylesheetGuards
element
:
E
pseudo
:
&
PseudoElement
rule_inclusion
:
RuleInclusion
originating_element_style
:
&
ComputedValues
is_probe
:
bool
matching_fn
:
Option
<
&
dyn
Fn
(
&
PseudoElement
)
-
>
bool
>
)
-
>
Option
<
Arc
<
ComputedValues
>
>
where
E
:
TElement
{
let
cascade_inputs
=
self
.
lazy_pseudo_rules
(
guards
element
originating_element_style
pseudo
is_probe
rule_inclusion
matching_fn
)
?
;
Some
(
self
.
compute_pseudo_element_style_with_inputs
(
cascade_inputs
pseudo
guards
Some
(
originating_element_style
)
Some
(
element
)
)
)
}
pub
fn
compute_pseudo_element_style_with_inputs
<
E
>
(
&
self
inputs
:
CascadeInputs
pseudo
:
&
PseudoElement
guards
:
&
StylesheetGuards
parent_style
:
Option
<
&
ComputedValues
>
element
:
Option
<
E
>
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
self
.
cascade_style_and_visited
(
element
Some
(
pseudo
)
inputs
guards
parent_style
parent_style
FirstLineReparenting
:
:
No
None
&
mut
RuleCacheConditions
:
:
default
(
)
)
}
pub
fn
cascade_style_and_visited
<
E
>
(
&
self
element
:
Option
<
E
>
pseudo
:
Option
<
&
PseudoElement
>
inputs
:
CascadeInputs
guards
:
&
StylesheetGuards
parent_style
:
Option
<
&
ComputedValues
>
layout_parent_style
:
Option
<
&
ComputedValues
>
first_line_reparenting
:
FirstLineReparenting
rule_cache
:
Option
<
&
RuleCache
>
rule_cache_conditions
:
&
mut
RuleCacheConditions
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
debug_assert
!
(
pseudo
.
is_some
(
)
|
|
element
.
is_some
(
)
"
Huh
?
"
)
;
let
visited_rules
=
match
inputs
.
visited_rules
.
as_ref
(
)
{
Some
(
rules
)
=
>
Some
(
rules
)
None
=
>
{
if
parent_style
.
and_then
(
|
s
|
s
.
visited_style
(
)
)
.
is_some
(
)
{
Some
(
inputs
.
rules
.
as_ref
(
)
.
unwrap_or
(
self
.
rule_tree
.
root
(
)
)
)
}
else
{
None
}
}
}
;
properties
:
:
cascade
:
:
<
E
>
(
&
self
pseudo
inputs
.
rules
.
as_ref
(
)
.
unwrap_or
(
self
.
rule_tree
.
root
(
)
)
guards
parent_style
layout_parent_style
first_line_reparenting
visited_rules
inputs
.
flags
rule_cache
rule_cache_conditions
element
)
}
fn
lazy_pseudo_rules
<
E
>
(
&
self
guards
:
&
StylesheetGuards
element
:
E
originating_element_style
:
&
ComputedValues
pseudo
:
&
PseudoElement
is_probe
:
bool
rule_inclusion
:
RuleInclusion
matching_fn
:
Option
<
&
dyn
Fn
(
&
PseudoElement
)
-
>
bool
>
)
-
>
Option
<
CascadeInputs
>
where
E
:
TElement
{
debug_assert
!
(
pseudo
.
is_lazy
(
)
)
;
let
mut
selector_caches
=
SelectorCaches
:
:
default
(
)
;
let
needs_selector_flags
=
if
rule_inclusion
=
=
RuleInclusion
:
:
DefaultOnly
{
NeedsSelectorFlags
:
:
No
}
else
{
NeedsSelectorFlags
:
:
Yes
}
;
let
mut
declarations
=
ApplicableDeclarationList
:
:
new
(
)
;
let
mut
matching_context
=
MatchingContext
:
:
<
'
_
E
:
:
Impl
>
:
:
new
(
MatchingMode
:
:
ForStatelessPseudoElement
None
&
mut
selector_caches
self
.
quirks_mode
needs_selector_flags
MatchingForInvalidation
:
:
No
)
;
matching_context
.
pseudo_element_matching_fn
=
matching_fn
;
matching_context
.
extra_data
.
originating_element_style
=
Some
(
originating_element_style
)
;
self
.
push_applicable_declarations
(
element
Some
(
&
pseudo
)
None
None
Default
:
:
default
(
)
rule_inclusion
&
mut
declarations
&
mut
matching_context
)
;
if
declarations
.
is_empty
(
)
&
&
is_probe
{
return
None
;
}
let
rules
=
self
.
rule_tree
.
compute_rule_node
(
&
mut
declarations
guards
)
;
let
mut
visited_rules
=
None
;
if
originating_element_style
.
visited_style
(
)
.
is_some
(
)
{
let
mut
declarations
=
ApplicableDeclarationList
:
:
new
(
)
;
let
mut
selector_caches
=
SelectorCaches
:
:
default
(
)
;
let
mut
matching_context
=
MatchingContext
:
:
<
'
_
E
:
:
Impl
>
:
:
new_for_visited
(
MatchingMode
:
:
ForStatelessPseudoElement
None
&
mut
selector_caches
VisitedHandlingMode
:
:
RelevantLinkVisited
selectors
:
:
matching
:
:
IncludeStartingStyle
:
:
No
self
.
quirks_mode
needs_selector_flags
MatchingForInvalidation
:
:
No
)
;
matching_context
.
pseudo_element_matching_fn
=
matching_fn
;
matching_context
.
extra_data
.
originating_element_style
=
Some
(
originating_element_style
)
;
self
.
push_applicable_declarations
(
element
Some
(
&
pseudo
)
None
None
Default
:
:
default
(
)
rule_inclusion
&
mut
declarations
&
mut
matching_context
)
;
if
!
declarations
.
is_empty
(
)
{
let
rule_node
=
self
.
rule_tree
.
insert_ordered_rules_with_important
(
declarations
.
drain
(
.
.
)
.
map
(
|
a
|
a
.
for_rule_tree
(
)
)
guards
)
;
if
rule_node
!
=
*
self
.
rule_tree
.
root
(
)
{
visited_rules
=
Some
(
rule_node
)
;
}
}
}
Some
(
CascadeInputs
{
rules
:
Some
(
rules
)
visited_rules
flags
:
matching_context
.
extra_data
.
cascade_input_flags
}
)
}
pub
fn
set_device
(
&
mut
self
device
:
Device
guards
:
&
StylesheetGuards
)
-
>
OriginSet
{
self
.
device
=
device
;
self
.
media_features_change_changed_style
(
guards
&
self
.
device
)
}
pub
fn
media_features_change_changed_style
(
&
self
guards
:
&
StylesheetGuards
device
:
&
Device
)
-
>
OriginSet
{
debug
!
(
"
Stylist
:
:
media_features_change_changed_style
{
:
?
}
"
device
)
;
let
mut
origins
=
OriginSet
:
:
empty
(
)
;
let
stylesheets
=
self
.
stylesheets
.
iter
(
)
;
for
(
stylesheet
origin
)
in
stylesheets
{
if
origins
.
contains
(
origin
.
into
(
)
)
{
continue
;
}
let
guard
=
guards
.
for_origin
(
origin
)
;
let
origin_cascade_data
=
self
.
cascade_data
.
borrow_for_origin
(
origin
)
;
let
affected_changed
=
!
origin_cascade_data
.
media_feature_affected_matches
(
stylesheet
guard
device
self
.
quirks_mode
)
;
if
affected_changed
{
origins
|
=
origin
;
}
}
origins
}
pub
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
{
self
.
quirks_mode
}
pub
fn
set_quirks_mode
(
&
mut
self
quirks_mode
:
QuirksMode
)
{
if
self
.
quirks_mode
=
=
quirks_mode
{
return
;
}
self
.
quirks_mode
=
quirks_mode
;
self
.
force_stylesheet_origins_dirty
(
OriginSet
:
:
all
(
)
)
;
}
pub
fn
push_applicable_declarations
<
E
>
(
&
self
element
:
E
pseudo_element
:
Option
<
&
PseudoElement
>
style_attribute
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
smil_override
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
animation_declarations
:
AnimationDeclarations
rule_inclusion
:
RuleInclusion
applicable_declarations
:
&
mut
ApplicableDeclarationList
context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
)
where
E
:
TElement
{
RuleCollector
:
:
new
(
self
element
pseudo_element
style_attribute
smil_override
animation_declarations
rule_inclusion
applicable_declarations
context
)
.
collect_all
(
)
;
}
#
[
inline
]
pub
fn
may_have_rules_for_id
<
E
>
(
&
self
id
:
&
WeakAtom
element
:
E
)
-
>
bool
where
E
:
TElement
{
match
self
.
quirks_mode
(
)
.
classes_and_ids_case_sensitivity
(
)
{
CaseSensitivity
:
:
AsciiCaseInsensitive
=
>
return
true
CaseSensitivity
:
:
CaseSensitive
=
>
{
}
}
self
.
any_applicable_rule_data
(
element
|
data
|
data
.
mapped_ids
.
contains
(
id
)
)
}
#
[
inline
]
pub
fn
get_animation
<
'
a
E
>
(
&
'
a
self
name
:
&
Atom
element
:
E
)
-
>
Option
<
&
'
a
KeyframesAnimation
>
where
E
:
TElement
+
'
a
{
macro_rules
!
try_find_in
{
(
data
:
expr
)
=
>
{
if
let
Some
(
animation
)
=
data
.
animations
.
get
(
name
)
{
return
Some
(
animation
)
;
}
}
;
}
let
mut
animation
=
None
;
let
doc_rules_apply
=
element
.
each_applicable_non_document_style_rule_data
(
|
data
_host
|
{
if
animation
.
is_none
(
)
{
animation
=
data
.
animations
.
get
(
name
)
;
}
}
)
;
if
animation
.
is_some
(
)
{
return
animation
;
}
if
doc_rules_apply
{
try_find_in
!
(
self
.
cascade_data
.
author
)
;
}
try_find_in
!
(
self
.
cascade_data
.
user
)
;
try_find_in
!
(
self
.
cascade_data
.
user_agent
.
cascade_data
)
;
None
}
pub
fn
match_revalidation_selectors
<
E
>
(
&
self
element
:
E
bloom
:
Option
<
&
BloomFilter
>
selector_caches
:
&
mut
SelectorCaches
needs_selector_flags
:
NeedsSelectorFlags
)
-
>
RevalidationResult
where
E
:
TElement
{
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
Normal
bloom
selector_caches
self
.
quirks_mode
needs_selector_flags
MatchingForInvalidation
:
:
No
)
;
let
mut
result
=
RevalidationResult
:
:
default
(
)
;
let
mut
relevant_attributes
=
&
mut
result
.
relevant_attributes
;
let
selectors_matched
=
&
mut
result
.
selectors_matched
;
let
matches_document_rules
=
element
.
each_applicable_non_document_style_rule_data
(
|
data
host
|
{
matching_context
.
with_shadow_host
(
Some
(
host
)
|
matching_context
|
{
data
.
selectors_for_cache_revalidation
.
lookup
(
element
self
.
quirks_mode
Some
(
&
mut
relevant_attributes
)
|
selector_and_hashes
|
{
selectors_matched
.
push
(
matches_selector
(
&
selector_and_hashes
.
selector
selector_and_hashes
.
selector_offset
Some
(
&
selector_and_hashes
.
hashes
)
&
element
matching_context
)
)
;
true
}
)
;
}
)
}
)
;
for
(
data
origin
)
in
self
.
cascade_data
.
iter_origins
(
)
{
if
origin
=
=
Origin
:
:
Author
&
&
!
matches_document_rules
{
continue
;
}
data
.
selectors_for_cache_revalidation
.
lookup
(
element
self
.
quirks_mode
Some
(
&
mut
relevant_attributes
)
|
selector_and_hashes
|
{
selectors_matched
.
push
(
matches_selector
(
&
selector_and_hashes
.
selector
selector_and_hashes
.
selector_offset
Some
(
&
selector_and_hashes
.
hashes
)
&
element
&
mut
matching_context
)
)
;
true
}
)
;
}
result
}
pub
fn
revalidate_scopes
<
E
:
TElement
>
(
&
self
element
:
&
E
selector_caches
:
&
mut
SelectorCaches
needs_selector_flags
:
NeedsSelectorFlags
)
-
>
ScopeRevalidationResult
{
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
Normal
None
selector_caches
self
.
quirks_mode
needs_selector_flags
MatchingForInvalidation
:
:
No
)
;
let
mut
result
=
ScopeRevalidationResult
:
:
default
(
)
;
let
matches_document_rules
=
element
.
each_applicable_non_document_style_rule_data
(
|
data
host
|
{
matching_context
.
with_shadow_host
(
Some
(
host
)
|
matching_context
|
{
data
.
revalidate_scopes
(
self
element
matching_context
&
mut
result
)
;
}
)
}
)
;
for
(
data
origin
)
in
self
.
cascade_data
.
iter_origins
(
)
{
if
origin
=
=
Origin
:
:
Author
&
&
!
matches_document_rules
{
continue
;
}
data
.
revalidate_scopes
(
self
element
&
mut
matching_context
&
mut
result
)
;
}
result
}
pub
fn
compute_for_declarations
<
E
>
(
&
self
guards
:
&
StylesheetGuards
parent_style
:
&
ComputedValues
declarations
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
let
block
=
declarations
.
read_with
(
guards
.
author
)
;
properties
:
:
apply_declarations
:
:
<
E
_
>
(
&
self
None
self
.
rule_tree
.
root
(
)
guards
block
.
declaration_importance_iter
(
)
.
map
(
|
(
declaration
_
)
|
{
(
declaration
CascadePriority
:
:
new
(
CascadeLevel
:
:
same_tree_author_normal
(
)
LayerOrder
:
:
root
(
)
)
)
}
)
Some
(
parent_style
)
Some
(
parent_style
)
FirstLineReparenting
:
:
No
CascadeMode
:
:
Unvisited
{
visited_rules
:
None
}
Default
:
:
default
(
)
None
&
mut
Default
:
:
default
(
)
None
)
}
#
[
inline
]
pub
fn
device
(
&
self
)
-
>
&
Device
{
&
self
.
device
}
#
[
inline
]
pub
fn
device_mut
(
&
mut
self
)
-
>
&
mut
Device
{
&
mut
self
.
device
}
#
[
inline
]
pub
fn
rule_tree
(
&
self
)
-
>
&
RuleTree
{
&
self
.
rule_tree
}
#
[
inline
]
pub
fn
custom_property_script_registry
(
&
self
)
-
>
&
CustomPropertyScriptRegistry
{
&
self
.
script_custom_properties
}
#
[
inline
]
pub
fn
custom_property_script_registry_mut
(
&
mut
self
)
-
>
&
mut
CustomPropertyScriptRegistry
{
&
mut
self
.
script_custom_properties
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
cascade_data
.
add_size_of
(
ops
sizes
)
;
self
.
author_data_cache
.
add_size_of
(
ops
sizes
)
;
sizes
.
mRuleTree
+
=
self
.
rule_tree
.
size_of
(
ops
)
;
}
pub
fn
shutdown
(
)
{
let
_entries
=
UA_CASCADE_DATA_CACHE
.
lock
(
)
.
unwrap
(
)
.
take_all
(
)
;
}
}
#
[
derive
(
Clone
Debug
Deref
MallocSizeOf
)
]
pub
struct
LayerOrderedVec
<
T
>
(
Vec
<
(
T
LayerId
)
>
)
;
impl
<
T
>
Default
for
LayerOrderedVec
<
T
>
{
fn
default
(
)
-
>
Self
{
Self
(
Default
:
:
default
(
)
)
}
}
#
[
derive
(
Clone
Debug
Deref
MallocSizeOf
)
]
pub
struct
LayerOrderedMap
<
T
>
(
PrecomputedHashMap
<
Atom
SmallVec
<
[
(
T
LayerId
)
;
1
]
>
>
)
;
impl
<
T
>
Default
for
LayerOrderedMap
<
T
>
{
fn
default
(
)
-
>
Self
{
Self
(
Default
:
:
default
(
)
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
<
T
:
'
static
>
LayerOrderedVec
<
T
>
{
fn
clear
(
&
mut
self
)
{
self
.
0
.
clear
(
)
;
}
fn
push
(
&
mut
self
v
:
T
id
:
LayerId
)
{
self
.
0
.
push
(
(
v
id
)
)
;
}
fn
sort
(
&
mut
self
layers
:
&
[
CascadeLayer
]
)
{
self
.
0
.
sort_by_key
(
|
&
(
_
ref
id
)
|
layers
[
id
.
0
as
usize
]
.
order
)
}
}
impl
<
T
:
'
static
>
LayerOrderedMap
<
T
>
{
fn
shrink_if_needed
(
&
mut
self
)
{
self
.
0
.
shrink_if_needed
(
)
;
}
fn
clear
(
&
mut
self
)
{
self
.
0
.
clear
(
)
;
}
fn
try_insert
(
&
mut
self
name
:
Atom
v
:
T
id
:
LayerId
)
-
>
Result
<
(
)
AllocErr
>
{
self
.
try_insert_with
(
name
v
id
|
_
_
|
Ordering
:
:
Equal
)
}
fn
try_insert_with
(
&
mut
self
name
:
Atom
v
:
T
id
:
LayerId
cmp
:
impl
Fn
(
&
T
&
T
)
-
>
Ordering
)
-
>
Result
<
(
)
AllocErr
>
{
self
.
0
.
try_reserve
(
1
)
?
;
let
vec
=
self
.
0
.
entry
(
name
)
.
or_default
(
)
;
if
let
Some
(
&
mut
(
ref
mut
val
ref
last_id
)
)
=
vec
.
last_mut
(
)
{
if
*
last_id
=
=
id
{
if
cmp
(
&
val
&
v
)
!
=
Ordering
:
:
Greater
{
*
val
=
v
;
}
return
Ok
(
(
)
)
;
}
}
vec
.
push
(
(
v
id
)
)
;
Ok
(
(
)
)
}
fn
sort
(
&
mut
self
layers
:
&
[
CascadeLayer
]
)
{
self
.
sort_with
(
layers
|
_
_
|
Ordering
:
:
Equal
)
}
fn
sort_with
(
&
mut
self
layers
:
&
[
CascadeLayer
]
cmp
:
impl
Fn
(
&
T
&
T
)
-
>
Ordering
)
{
for
(
_
v
)
in
self
.
0
.
iter_mut
(
)
{
v
.
sort_by
(
|
&
(
ref
v1
ref
id1
)
&
(
ref
v2
ref
id2
)
|
{
let
order1
=
layers
[
id1
.
0
as
usize
]
.
order
;
let
order2
=
layers
[
id2
.
0
as
usize
]
.
order
;
order1
.
cmp
(
&
order2
)
.
then_with
(
|
|
cmp
(
v1
v2
)
)
}
)
}
}
pub
fn
get
(
&
self
name
:
&
Atom
)
-
>
Option
<
&
T
>
{
let
vec
=
self
.
0
.
get
(
name
)
?
;
Some
(
&
vec
.
last
(
)
?
.
0
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
PageRuleData
{
pub
layer
:
LayerId
#
[
ignore_malloc_size_of
=
"
Arc
stylesheet
measures
as
primary
ref
"
]
pub
rule
:
Arc
<
Locked
<
PageRule
>
>
}
#
[
derive
(
Clone
Debug
Default
MallocSizeOf
)
]
pub
struct
PageRuleMap
{
pub
rules
:
PrecomputedHashMap
<
Atom
SmallVec
<
[
PageRuleData
;
1
]
>
>
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
PageRuleMap
{
#
[
inline
]
fn
clear
(
&
mut
self
)
{
self
.
rules
.
clear
(
)
;
}
pub
fn
match_and_append_rules
(
&
self
matched_rules
:
&
mut
Vec
<
ApplicableDeclarationBlock
>
origin
:
Origin
guards
:
&
StylesheetGuards
cascade_data
:
&
DocumentCascadeData
name
:
&
Option
<
Atom
>
pseudos
:
PagePseudoClassFlags
)
{
let
level
=
match
origin
{
Origin
:
:
UserAgent
=
>
CascadeLevel
:
:
UANormal
Origin
:
:
User
=
>
CascadeLevel
:
:
UserNormal
Origin
:
:
Author
=
>
CascadeLevel
:
:
same_tree_author_normal
(
)
}
;
let
cascade_data
=
cascade_data
.
borrow_for_origin
(
origin
)
;
let
start
=
matched_rules
.
len
(
)
;
self
.
match_and_add_rules
(
matched_rules
level
guards
cascade_data
&
atom
!
(
"
"
)
pseudos
)
;
if
let
Some
(
name
)
=
name
{
self
.
match_and_add_rules
(
matched_rules
level
guards
cascade_data
name
pseudos
)
;
}
matched_rules
[
start
.
.
]
.
sort_by_key
(
|
block
|
block
.
sort_key
(
)
)
;
}
fn
match_and_add_rules
(
&
self
extra_declarations
:
&
mut
Vec
<
ApplicableDeclarationBlock
>
level
:
CascadeLevel
guards
:
&
StylesheetGuards
cascade_data
:
&
CascadeData
name
:
&
Atom
pseudos
:
PagePseudoClassFlags
)
{
let
rules
=
match
self
.
rules
.
get
(
name
)
{
Some
(
rules
)
=
>
rules
None
=
>
return
}
;
for
data
in
rules
.
iter
(
)
{
let
rule
=
data
.
rule
.
read_with
(
level
.
guard
(
&
guards
)
)
;
let
specificity
=
match
rule
.
match_specificity
(
pseudos
)
{
Some
(
specificity
)
=
>
specificity
None
=
>
continue
}
;
let
block
=
rule
.
block
.
clone
(
)
;
extra_declarations
.
push
(
ApplicableDeclarationBlock
:
:
new
(
StyleSource
:
:
from_declarations
(
block
)
0
level
specificity
cascade_data
.
layer_order_for
(
data
.
layer
)
ScopeProximity
:
:
infinity
(
)
)
)
;
}
}
}
impl
MallocShallowSizeOf
for
PageRuleMap
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
rules
.
shallow_size_of
(
ops
)
}
}
#
[
derive
(
Clone
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
pub
struct
ExtraStyleData
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
font_faces
:
LayerOrderedVec
<
Arc
<
Locked
<
FontFaceRule
>
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
font_feature_values
:
LayerOrderedVec
<
Arc
<
FontFeatureValuesRule
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
font_palette_values
:
LayerOrderedVec
<
Arc
<
FontPaletteValuesRule
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
counter_styles
:
LayerOrderedMap
<
Arc
<
Locked
<
CounterStyleRule
>
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
pages
:
PageRuleMap
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ExtraStyleData
{
fn
add_font_face
(
&
mut
self
rule
:
&
Arc
<
Locked
<
FontFaceRule
>
>
layer
:
LayerId
)
{
self
.
font_faces
.
push
(
rule
.
clone
(
)
layer
)
;
}
fn
add_font_feature_values
(
&
mut
self
rule
:
&
Arc
<
FontFeatureValuesRule
>
layer
:
LayerId
)
{
self
.
font_feature_values
.
push
(
rule
.
clone
(
)
layer
)
;
}
fn
add_font_palette_values
(
&
mut
self
rule
:
&
Arc
<
FontPaletteValuesRule
>
layer
:
LayerId
)
{
self
.
font_palette_values
.
push
(
rule
.
clone
(
)
layer
)
;
}
fn
add_counter_style
(
&
mut
self
guard
:
&
SharedRwLockReadGuard
rule
:
&
Arc
<
Locked
<
CounterStyleRule
>
>
layer
:
LayerId
)
-
>
Result
<
(
)
AllocErr
>
{
let
name
=
rule
.
read_with
(
guard
)
.
name
(
)
.
0
.
clone
(
)
;
self
.
counter_styles
.
try_insert
(
name
rule
.
clone
(
)
layer
)
}
fn
add_page
(
&
mut
self
guard
:
&
SharedRwLockReadGuard
rule
:
&
Arc
<
Locked
<
PageRule
>
>
layer
:
LayerId
)
-
>
Result
<
(
)
AllocErr
>
{
let
page_rule
=
rule
.
read_with
(
guard
)
;
let
mut
add_rule
=
|
name
|
{
let
vec
=
self
.
pages
.
rules
.
entry
(
name
)
.
or_default
(
)
;
vec
.
push
(
PageRuleData
{
layer
rule
:
rule
.
clone
(
)
}
)
;
}
;
if
page_rule
.
selectors
.
0
.
is_empty
(
)
{
add_rule
(
atom
!
(
"
"
)
)
;
}
else
{
for
selector
in
page_rule
.
selectors
.
as_slice
(
)
{
add_rule
(
selector
.
name
.
0
.
clone
(
)
)
;
}
}
Ok
(
(
)
)
}
fn
sort_by_layer
(
&
mut
self
layers
:
&
[
CascadeLayer
]
)
{
self
.
font_faces
.
sort
(
layers
)
;
self
.
font_feature_values
.
sort
(
layers
)
;
self
.
font_palette_values
.
sort
(
layers
)
;
self
.
counter_styles
.
sort
(
layers
)
;
}
fn
clear
(
&
mut
self
)
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
font_faces
.
clear
(
)
;
self
.
font_feature_values
.
clear
(
)
;
self
.
font_palette_values
.
clear
(
)
;
self
.
counter_styles
.
clear
(
)
;
self
.
pages
.
clear
(
)
;
}
}
}
fn
compare_keyframes_in_same_layer
(
v1
:
&
KeyframesAnimation
v2
:
&
KeyframesAnimation
)
-
>
Ordering
{
if
v1
.
vendor_prefix
.
is_some
(
)
=
=
v2
.
vendor_prefix
.
is_some
(
)
{
Ordering
:
:
Equal
}
else
if
v2
.
vendor_prefix
.
is_some
(
)
{
Ordering
:
:
Greater
}
else
{
Ordering
:
:
Less
}
}
pub
struct
ExtraStyleDataIterator
<
'
a
>
(
DocumentCascadeDataIter
<
'
a
>
)
;
impl
<
'
a
>
Iterator
for
ExtraStyleDataIterator
<
'
a
>
{
type
Item
=
(
&
'
a
ExtraStyleData
Origin
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
0
.
next
(
)
.
map
(
|
d
|
(
&
d
.
0
.
extra_data
d
.
1
)
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
MallocSizeOf
for
ExtraStyleData
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
0
;
n
+
=
self
.
font_faces
.
shallow_size_of
(
ops
)
;
n
+
=
self
.
font_feature_values
.
shallow_size_of
(
ops
)
;
n
+
=
self
.
font_palette_values
.
shallow_size_of
(
ops
)
;
n
+
=
self
.
counter_styles
.
shallow_size_of
(
ops
)
;
n
+
=
self
.
pages
.
shallow_size_of
(
ops
)
;
n
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
Debug
)
]
struct
RevalidationSelectorAndHashes
{
#
[
cfg_attr
(
feature
=
"
gecko
"
ignore_malloc_size_of
=
"
CssRules
have
primary
refs
we
measure
there
"
)
]
selector
:
Selector
<
SelectorImpl
>
selector_offset
:
usize
hashes
:
AncestorHashes
}
impl
RevalidationSelectorAndHashes
{
fn
new
(
selector
:
Selector
<
SelectorImpl
>
hashes
:
AncestorHashes
)
-
>
Self
{
let
selector_offset
=
{
let
mut
index
=
0
;
let
mut
iter
=
selector
.
iter
(
)
;
for
_
in
&
mut
iter
{
index
+
=
1
;
}
match
iter
.
next_sequence
(
)
{
Some
(
Combinator
:
:
PseudoElement
)
=
>
index
+
1
_
=
>
0
}
}
;
RevalidationSelectorAndHashes
{
selector
selector_offset
hashes
}
}
}
impl
SelectorMapEntry
for
RevalidationSelectorAndHashes
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter_from
(
self
.
selector_offset
)
}
}
struct
StylistSelectorVisitor
<
'
a
>
{
passed_rightmost_selector
:
bool
needs_revalidation
:
&
'
a
mut
bool
in_selector_list_of
:
SelectorListKind
mapped_ids
:
&
'
a
mut
PrecomputedHashSet
<
Atom
>
nth_of_mapped_ids
:
&
'
a
mut
PrecomputedHashSet
<
Atom
>
attribute_dependencies
:
&
'
a
mut
PrecomputedHashSet
<
LocalName
>
nth_of_class_dependencies
:
&
'
a
mut
PrecomputedHashSet
<
Atom
>
nth_of_attribute_dependencies
:
&
'
a
mut
PrecomputedHashSet
<
LocalName
>
nth_of_custom_state_dependencies
:
&
'
a
mut
PrecomputedHashSet
<
AtomIdent
>
state_dependencies
:
&
'
a
mut
ElementState
nth_of_state_dependencies
:
&
'
a
mut
ElementState
document_state_dependencies
:
&
'
a
mut
DocumentState
}
fn
component_needs_revalidation
(
c
:
&
Component
<
SelectorImpl
>
passed_rightmost_selector
:
bool
)
-
>
bool
{
match
*
c
{
Component
:
:
ID
(
_
)
=
>
{
passed_rightmost_selector
}
Component
:
:
AttributeInNoNamespaceExists
{
.
.
}
|
Component
:
:
AttributeInNoNamespace
{
.
.
}
|
Component
:
:
AttributeOther
(
_
)
|
Component
:
:
Empty
|
Component
:
:
Nth
(
_
)
|
Component
:
:
NthOf
(
_
)
|
Component
:
:
Has
(
_
)
=
>
true
Component
:
:
NonTSPseudoClass
(
ref
p
)
=
>
p
.
needs_cache_revalidation
(
)
_
=
>
false
}
}
impl
<
'
a
>
StylistSelectorVisitor
<
'
a
>
{
fn
visit_nested_selector
(
&
mut
self
in_selector_list_of
:
SelectorListKind
selector
:
&
Selector
<
SelectorImpl
>
)
{
let
old_passed_rightmost_selector
=
self
.
passed_rightmost_selector
;
let
old_in_selector_list_of
=
self
.
in_selector_list_of
;
self
.
passed_rightmost_selector
=
false
;
self
.
in_selector_list_of
=
in_selector_list_of
;
let
_ret
=
selector
.
visit
(
self
)
;
debug_assert
!
(
_ret
"
We
never
return
false
"
)
;
self
.
passed_rightmost_selector
=
old_passed_rightmost_selector
;
self
.
in_selector_list_of
=
old_in_selector_list_of
;
}
}
impl
<
'
a
>
SelectorVisitor
for
StylistSelectorVisitor
<
'
a
>
{
type
Impl
=
SelectorImpl
;
fn
visit_complex_selector
(
&
mut
self
combinator
:
Option
<
Combinator
>
)
-
>
bool
{
*
self
.
needs_revalidation
=
*
self
.
needs_revalidation
|
|
combinator
.
map_or
(
false
|
c
|
c
.
is_sibling
(
)
)
;
self
.
passed_rightmost_selector
=
self
.
passed_rightmost_selector
|
|
!
matches
!
(
combinator
None
|
Some
(
Combinator
:
:
PseudoElement
)
)
;
true
}
fn
visit_selector_list
(
&
mut
self
list_kind
:
SelectorListKind
list
:
&
[
Selector
<
Self
:
:
Impl
>
]
)
-
>
bool
{
let
in_selector_list_of
=
self
.
in_selector_list_of
|
list_kind
;
for
selector
in
list
{
self
.
visit_nested_selector
(
in_selector_list_of
selector
)
;
}
true
}
fn
visit_relative_selector_list
(
&
mut
self
list
:
&
[
selectors
:
:
parser
:
:
RelativeSelector
<
Self
:
:
Impl
>
]
)
-
>
bool
{
let
in_selector_list_of
=
self
.
in_selector_list_of
|
SelectorListKind
:
:
HAS
;
for
selector
in
list
{
self
.
visit_nested_selector
(
in_selector_list_of
&
selector
.
selector
)
;
}
true
}
fn
visit_attribute_selector
(
&
mut
self
_ns
:
&
NamespaceConstraint
<
&
Namespace
>
name
:
&
LocalName
lower_name
:
&
LocalName
)
-
>
bool
{
if
self
.
in_selector_list_of
.
relevant_to_nth_of_dependencies
(
)
{
self
.
nth_of_attribute_dependencies
.
insert
(
name
.
clone
(
)
)
;
if
name
!
=
lower_name
{
self
.
nth_of_attribute_dependencies
.
insert
(
lower_name
.
clone
(
)
)
;
}
}
self
.
attribute_dependencies
.
insert
(
name
.
clone
(
)
)
;
if
name
!
=
lower_name
{
self
.
attribute_dependencies
.
insert
(
lower_name
.
clone
(
)
)
;
}
true
}
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
*
self
.
needs_revalidation
=
*
self
.
needs_revalidation
|
|
component_needs_revalidation
(
s
self
.
passed_rightmost_selector
)
;
match
*
s
{
Component
:
:
NonTSPseudoClass
(
NonTSPseudoClass
:
:
CustomState
(
ref
name
)
)
=
>
{
if
self
.
in_selector_list_of
.
relevant_to_nth_of_dependencies
(
)
{
self
.
nth_of_custom_state_dependencies
.
insert
(
name
.
0
.
clone
(
)
)
;
}
}
Component
:
:
NonTSPseudoClass
(
ref
p
)
=
>
{
self
.
state_dependencies
.
insert
(
p
.
state_flag
(
)
)
;
self
.
document_state_dependencies
.
insert
(
p
.
document_state_flag
(
)
)
;
if
self
.
in_selector_list_of
.
relevant_to_nth_of_dependencies
(
)
{
self
.
nth_of_state_dependencies
.
insert
(
p
.
state_flag
(
)
)
;
}
}
Component
:
:
ID
(
ref
id
)
=
>
{
if
!
self
.
passed_rightmost_selector
{
self
.
mapped_ids
.
insert
(
id
.
0
.
clone
(
)
)
;
}
if
self
.
in_selector_list_of
.
relevant_to_nth_of_dependencies
(
)
{
self
.
nth_of_mapped_ids
.
insert
(
id
.
0
.
clone
(
)
)
;
}
}
Component
:
:
Class
(
ref
class
)
if
self
.
in_selector_list_of
.
relevant_to_nth_of_dependencies
(
)
=
>
{
self
.
nth_of_class_dependencies
.
insert
(
class
.
0
.
clone
(
)
)
;
}
_
=
>
{
}
}
true
}
}
#
[
derive
(
Clone
Debug
Default
MallocSizeOf
)
]
struct
GenericElementAndPseudoRules
<
Map
>
{
element_map
:
Map
pseudos_map
:
PerPseudoElementMap
<
Box
<
Map
>
>
}
impl
<
Map
:
Default
+
MallocSizeOf
>
GenericElementAndPseudoRules
<
Map
>
{
#
[
inline
(
always
)
]
fn
for_insertion
(
&
mut
self
pseudo_element
:
Option
<
&
PseudoElement
>
)
-
>
&
mut
Map
{
debug_assert
!
(
pseudo_element
.
map_or
(
true
|
pseudo
|
{
!
pseudo
.
is_precomputed
(
)
&
&
!
pseudo
.
is_unknown_webkit_pseudo_element
(
)
}
)
"
Precomputed
pseudos
should
end
up
in
precomputed_pseudo_element_decls
\
and
unknown
webkit
pseudos
should
be
discarded
before
getting
here
"
)
;
match
pseudo_element
{
None
=
>
&
mut
self
.
element_map
Some
(
pseudo
)
=
>
self
.
pseudos_map
.
get_or_insert_with
(
pseudo
|
|
Box
:
:
new
(
Default
:
:
default
(
)
)
)
}
}
#
[
inline
]
fn
rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
Map
>
{
match
pseudo
{
Some
(
pseudo
)
=
>
self
.
pseudos_map
.
get
(
pseudo
)
.
map
(
|
p
|
&
*
*
p
)
None
=
>
Some
(
&
self
.
element_map
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
sizes
.
mElementAndPseudosMaps
+
=
self
.
element_map
.
size_of
(
ops
)
;
for
elem
in
self
.
pseudos_map
.
iter
(
)
{
if
let
Some
(
ref
elem
)
=
*
elem
{
sizes
.
mElementAndPseudosMaps
+
=
<
Box
<
_
>
as
MallocSizeOf
>
:
:
size_of
(
elem
ops
)
;
}
}
}
}
type
ElementAndPseudoRules
=
GenericElementAndPseudoRules
<
SelectorMap
<
Rule
>
>
;
type
PartMap
=
PrecomputedHashMap
<
Atom
SmallVec
<
[
Rule
;
1
]
>
>
;
type
PartElementAndPseudoRules
=
GenericElementAndPseudoRules
<
PartMap
>
;
impl
ElementAndPseudoRules
{
fn
clear
(
&
mut
self
)
{
self
.
element_map
.
clear
(
)
;
self
.
pseudos_map
.
clear
(
)
;
}
fn
shrink_if_needed
(
&
mut
self
)
{
self
.
element_map
.
shrink_if_needed
(
)
;
for
pseudo
in
self
.
pseudos_map
.
iter_mut
(
)
{
if
let
Some
(
ref
mut
pseudo
)
=
pseudo
{
pseudo
.
shrink_if_needed
(
)
;
}
}
}
}
impl
PartElementAndPseudoRules
{
fn
clear
(
&
mut
self
)
{
self
.
element_map
.
clear
(
)
;
self
.
pseudos_map
.
clear
(
)
;
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
PartialOrd
Ord
)
]
pub
struct
LayerId
(
u16
)
;
impl
LayerId
{
pub
const
fn
root
(
)
-
>
Self
{
Self
(
0
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
struct
CascadeLayer
{
id
:
LayerId
order
:
LayerOrder
children
:
Vec
<
LayerId
>
}
impl
CascadeLayer
{
const
fn
root
(
)
-
>
Self
{
Self
{
id
:
LayerId
:
:
root
(
)
order
:
LayerOrder
:
:
root
(
)
children
:
vec
!
[
]
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
PartialOrd
Ord
)
]
pub
struct
ContainerConditionId
(
u16
)
;
impl
ContainerConditionId
{
pub
const
fn
none
(
)
-
>
Self
{
Self
(
0
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
struct
ContainerConditionReference
{
parent
:
ContainerConditionId
#
[
ignore_malloc_size_of
=
"
Arc
"
]
condition
:
Option
<
Arc
<
ContainerCondition
>
>
}
impl
ContainerConditionReference
{
const
fn
none
(
)
-
>
Self
{
Self
{
parent
:
ContainerConditionId
:
:
none
(
)
condition
:
None
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
PartialOrd
Ord
)
]
pub
struct
ScopeConditionId
(
u16
)
;
impl
ScopeConditionId
{
pub
const
fn
none
(
)
-
>
Self
{
Self
(
0
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
struct
ScopeConditionReference
{
parent
:
ScopeConditionId
condition
:
Option
<
ScopeBoundsWithHashes
>
#
[
ignore_malloc_size_of
=
"
Raw
ptr
behind
the
scenes
"
]
implicit_scope_root
:
Option
<
StylistImplicitScopeRoot
>
is_trivial
:
bool
}
impl
ScopeConditionReference
{
const
fn
none
(
)
-
>
Self
{
Self
{
parent
:
ScopeConditionId
:
:
none
(
)
condition
:
None
implicit_scope_root
:
None
is_trivial
:
true
}
}
}
fn
scope_bounds_is_trivial
(
bounds
:
&
ScopeBoundsWithHashes
)
-
>
bool
{
fn
scope_bound_is_trivial
(
bound
:
&
Option
<
ScopeBoundWithHashes
>
default
:
bool
)
-
>
bool
{
bound
.
as_ref
(
)
.
map_or
(
default
|
bound
|
scope_selector_list_is_trivial
(
&
bound
.
selectors
)
)
}
scope_bound_is_trivial
(
&
bounds
.
start
false
)
&
&
scope_bound_is_trivial
(
&
bounds
.
end
true
)
}
struct
ScopeRootCandidates
{
candidates
:
Vec
<
ScopeRootCandidate
>
is_trivial
:
bool
}
impl
Default
for
ScopeRootCandidates
{
fn
default
(
)
-
>
Self
{
Self
{
candidates
:
vec
!
[
]
is_trivial
:
true
}
}
}
impl
ScopeRootCandidates
{
fn
empty
(
is_trivial
:
bool
)
-
>
Self
{
Self
{
candidates
:
vec
!
[
]
is_trivial
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
struct
ScopeBoundWithHashes
{
#
[
ignore_malloc_size_of
=
"
Arc
"
]
selectors
:
SelectorList
<
SelectorImpl
>
hashes
:
SmallVec
<
[
AncestorHashes
;
1
]
>
}
impl
ScopeBoundWithHashes
{
fn
new
(
quirks_mode
:
QuirksMode
selectors
:
SelectorList
<
SelectorImpl
>
)
-
>
Self
{
let
mut
hashes
=
SmallVec
:
:
with_capacity
(
selectors
.
len
(
)
)
;
for
selector
in
selectors
.
slice
(
)
{
hashes
.
push
(
AncestorHashes
:
:
new
(
selector
quirks_mode
)
)
;
}
Self
{
selectors
hashes
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
struct
ScopeBoundsWithHashes
{
start
:
Option
<
ScopeBoundWithHashes
>
end
:
Option
<
ScopeBoundWithHashes
>
}
impl
ScopeBoundsWithHashes
{
fn
new
(
quirks_mode
:
QuirksMode
start
:
Option
<
SelectorList
<
SelectorImpl
>
>
end
:
Option
<
SelectorList
<
SelectorImpl
>
>
)
-
>
Self
{
Self
{
start
:
start
.
map
(
|
selectors
|
ScopeBoundWithHashes
:
:
new
(
quirks_mode
selectors
)
)
end
:
end
.
map
(
|
selectors
|
ScopeBoundWithHashes
:
:
new
(
quirks_mode
selectors
)
)
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
enum
StylistImplicitScopeRoot
{
Normal
(
ImplicitScopeRoot
)
Cached
(
usize
)
}
unsafe
impl
Sync
for
StylistImplicitScopeRoot
{
}
#
[
derive
(
Debug
Clone
MallocSizeOf
)
]
pub
struct
CascadeData
{
normal_rules
:
ElementAndPseudoRules
featureless_host_rules
:
Option
<
Box
<
ElementAndPseudoRules
>
>
slotted_rules
:
Option
<
Box
<
ElementAndPseudoRules
>
>
part_rules
:
Option
<
Box
<
PartElementAndPseudoRules
>
>
invalidation_map
:
InvalidationMap
relative_selector_invalidation_map
:
RelativeSelectorInvalidationMap
attribute_dependencies
:
PrecomputedHashSet
<
LocalName
>
nth_of_class_dependencies
:
PrecomputedHashSet
<
Atom
>
nth_of_attribute_dependencies
:
PrecomputedHashSet
<
LocalName
>
nth_of_custom_state_dependencies
:
PrecomputedHashSet
<
AtomIdent
>
state_dependencies
:
ElementState
nth_of_state_dependencies
:
ElementState
document_state_dependencies
:
DocumentState
mapped_ids
:
PrecomputedHashSet
<
Atom
>
nth_of_mapped_ids
:
PrecomputedHashSet
<
Atom
>
#
[
ignore_malloc_size_of
=
"
Arc
"
]
selectors_for_cache_revalidation
:
SelectorMap
<
RevalidationSelectorAndHashes
>
animations
:
LayerOrderedMap
<
KeyframesAnimation
>
#
[
ignore_malloc_size_of
=
"
Arc
"
]
custom_property_registrations
:
LayerOrderedMap
<
Arc
<
PropertyRegistration
>
>
layer_id
:
FxHashMap
<
LayerName
LayerId
>
layers
:
SmallVec
<
[
CascadeLayer
;
1
]
>
container_conditions
:
SmallVec
<
[
ContainerConditionReference
;
1
]
>
scope_conditions
:
SmallVec
<
[
ScopeConditionReference
;
1
]
>
scope_subject_map
:
ScopeSubjectMap
effective_media_query_results
:
EffectiveMediaQueryResults
extra_data
:
ExtraStyleData
rules_source_order
:
u32
num_selectors
:
usize
num_declarations
:
usize
}
fn
parent_selector_for_scope
(
parent
:
Option
<
&
SelectorList
<
SelectorImpl
>
>
)
-
>
&
SelectorList
<
SelectorImpl
>
{
lazy_static
!
{
static
ref
SCOPE
:
SelectorList
<
SelectorImpl
>
=
{
let
list
=
SelectorList
:
:
scope
(
)
;
list
.
mark_as_intentionally_leaked
(
)
;
list
}
;
}
;
match
parent
{
Some
(
l
)
=
>
l
None
=
>
&
SCOPE
}
}
impl
CascadeData
{
pub
fn
new
(
)
-
>
Self
{
Self
{
normal_rules
:
ElementAndPseudoRules
:
:
default
(
)
featureless_host_rules
:
None
slotted_rules
:
None
part_rules
:
None
invalidation_map
:
InvalidationMap
:
:
new
(
)
relative_selector_invalidation_map
:
RelativeSelectorInvalidationMap
:
:
new
(
)
nth_of_mapped_ids
:
PrecomputedHashSet
:
:
default
(
)
nth_of_class_dependencies
:
PrecomputedHashSet
:
:
default
(
)
nth_of_attribute_dependencies
:
PrecomputedHashSet
:
:
default
(
)
nth_of_custom_state_dependencies
:
PrecomputedHashSet
:
:
default
(
)
nth_of_state_dependencies
:
ElementState
:
:
empty
(
)
attribute_dependencies
:
PrecomputedHashSet
:
:
default
(
)
state_dependencies
:
ElementState
:
:
empty
(
)
document_state_dependencies
:
DocumentState
:
:
empty
(
)
mapped_ids
:
PrecomputedHashSet
:
:
default
(
)
selectors_for_cache_revalidation
:
SelectorMap
:
:
new
(
)
animations
:
Default
:
:
default
(
)
custom_property_registrations
:
Default
:
:
default
(
)
layer_id
:
Default
:
:
default
(
)
layers
:
smallvec
:
:
smallvec
!
[
CascadeLayer
:
:
root
(
)
]
container_conditions
:
smallvec
:
:
smallvec
!
[
ContainerConditionReference
:
:
none
(
)
]
scope_conditions
:
smallvec
:
:
smallvec
!
[
ScopeConditionReference
:
:
none
(
)
]
scope_subject_map
:
Default
:
:
default
(
)
extra_data
:
ExtraStyleData
:
:
default
(
)
effective_media_query_results
:
EffectiveMediaQueryResults
:
:
new
(
)
rules_source_order
:
0
num_selectors
:
0
num_declarations
:
0
}
}
pub
fn
rebuild
<
'
a
S
>
(
&
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
)
-
>
Result
<
(
)
AllocErr
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
if
!
collection
.
dirty
(
)
{
return
Ok
(
(
)
)
;
}
let
validity
=
collection
.
data_validity
(
)
;
match
validity
{
DataValidity
:
:
Valid
=
>
{
}
DataValidity
:
:
CascadeInvalid
=
>
self
.
clear_cascade_data
(
)
DataValidity
:
:
FullyInvalid
=
>
self
.
clear
(
)
}
let
mut
result
=
Ok
(
(
)
)
;
collection
.
each
(
|
index
stylesheet
rebuild_kind
|
{
result
=
self
.
add_stylesheet
(
device
quirks_mode
stylesheet
index
guard
rebuild_kind
None
)
;
result
.
is_ok
(
)
}
)
;
self
.
did_finish_rebuild
(
)
;
result
}
pub
fn
invalidation_map
(
&
self
)
-
>
&
InvalidationMap
{
&
self
.
invalidation_map
}
pub
fn
relative_selector_invalidation_map
(
&
self
)
-
>
&
RelativeSelectorInvalidationMap
{
&
self
.
relative_selector_invalidation_map
}
#
[
inline
]
pub
fn
has_state_dependency
(
&
self
state
:
ElementState
)
-
>
bool
{
self
.
state_dependencies
.
intersects
(
state
)
}
#
[
inline
]
pub
fn
has_nth_of_custom_state_dependency
(
&
self
state
:
&
AtomIdent
)
-
>
bool
{
self
.
nth_of_custom_state_dependencies
.
contains
(
state
)
}
#
[
inline
]
pub
fn
has_nth_of_state_dependency
(
&
self
state
:
ElementState
)
-
>
bool
{
self
.
nth_of_state_dependencies
.
intersects
(
state
)
}
#
[
inline
]
pub
fn
might_have_attribute_dependency
(
&
self
local_name
:
&
LocalName
)
-
>
bool
{
self
.
attribute_dependencies
.
contains
(
local_name
)
}
#
[
inline
]
pub
fn
might_have_nth_of_id_dependency
(
&
self
id
:
&
Atom
)
-
>
bool
{
self
.
nth_of_mapped_ids
.
contains
(
id
)
}
#
[
inline
]
pub
fn
might_have_nth_of_class_dependency
(
&
self
class
:
&
Atom
)
-
>
bool
{
self
.
nth_of_class_dependencies
.
contains
(
class
)
}
#
[
inline
]
pub
fn
might_have_nth_of_attribute_dependency
(
&
self
local_name
:
&
LocalName
)
-
>
bool
{
self
.
nth_of_attribute_dependencies
.
contains
(
local_name
)
}
#
[
inline
]
pub
fn
normal_rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
SelectorMap
<
Rule
>
>
{
self
.
normal_rules
.
rules
(
pseudo
)
}
#
[
inline
]
pub
fn
featureless_host_rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
SelectorMap
<
Rule
>
>
{
self
.
featureless_host_rules
.
as_ref
(
)
.
and_then
(
|
d
|
d
.
rules
(
pseudo
)
)
}
pub
fn
any_featureless_host_rules
(
&
self
)
-
>
bool
{
self
.
featureless_host_rules
.
is_some
(
)
}
#
[
inline
]
pub
fn
slotted_rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
SelectorMap
<
Rule
>
>
{
self
.
slotted_rules
.
as_ref
(
)
.
and_then
(
|
d
|
d
.
rules
(
pseudo
)
)
}
pub
fn
any_slotted_rule
(
&
self
)
-
>
bool
{
self
.
slotted_rules
.
is_some
(
)
}
#
[
inline
]
pub
fn
part_rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
PartMap
>
{
self
.
part_rules
.
as_ref
(
)
.
and_then
(
|
d
|
d
.
rules
(
pseudo
)
)
}
pub
fn
any_part_rule
(
&
self
)
-
>
bool
{
self
.
part_rules
.
is_some
(
)
}
#
[
inline
]
fn
layer_order_for
(
&
self
id
:
LayerId
)
-
>
LayerOrder
{
self
.
layers
[
id
.
0
as
usize
]
.
order
}
pub
(
crate
)
fn
container_condition_matches
<
E
>
(
&
self
mut
id
:
ContainerConditionId
stylist
:
&
Stylist
element
:
E
context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
)
-
>
bool
where
E
:
TElement
{
loop
{
let
condition_ref
=
&
self
.
container_conditions
[
id
.
0
as
usize
]
;
let
condition
=
match
condition_ref
.
condition
{
None
=
>
return
true
Some
(
ref
c
)
=
>
c
}
;
let
matches
=
condition
.
matches
(
stylist
element
context
.
extra_data
.
originating_element_style
&
mut
context
.
extra_data
.
cascade_input_flags
)
.
to_bool
(
false
)
;
if
!
matches
{
return
false
;
}
id
=
condition_ref
.
parent
;
}
}
pub
(
crate
)
fn
find_scope_proximity_if_matching
<
E
:
TElement
>
(
&
self
rule
:
&
Rule
stylist
:
&
Stylist
element
:
E
context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
)
-
>
ScopeProximity
{
context
.
extra_data
.
cascade_input_flags
.
insert
(
ComputedValueFlags
:
:
CONSIDERED_NONTRIVIAL_SCOPED_STYLE
)
;
let
result
=
self
.
scope_condition_matches
(
rule
.
scope_condition_id
stylist
element
rule
.
selector
.
is_part
(
)
context
)
;
for
candidate
in
result
.
candidates
{
if
context
.
nest_for_scope
(
Some
(
candidate
.
root
)
|
context
|
{
matches_selector
(
&
rule
.
selector
0
Some
(
&
rule
.
hashes
)
&
element
context
)
}
)
{
return
candidate
.
proximity
;
}
}
ScopeProximity
:
:
infinity
(
)
}
fn
scope_condition_matches
<
E
>
(
&
self
id
:
ScopeConditionId
stylist
:
&
Stylist
element
:
E
override_matches_shadow_host_for_part
:
bool
context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
)
-
>
ScopeRootCandidates
where
E
:
TElement
{
let
condition_ref
=
&
self
.
scope_conditions
[
id
.
0
as
usize
]
;
let
bounds
=
match
condition_ref
.
condition
{
None
=
>
return
ScopeRootCandidates
:
:
default
(
)
Some
(
ref
c
)
=
>
c
}
;
let
outer_result
=
self
.
scope_condition_matches
(
condition_ref
.
parent
stylist
element
override_matches_shadow_host_for_part
context
)
;
let
is_trivial
=
condition_ref
.
is_trivial
&
&
outer_result
.
is_trivial
;
let
is_outermost_scope
=
condition_ref
.
parent
=
=
ScopeConditionId
:
:
none
(
)
;
if
!
is_outermost_scope
&
&
outer_result
.
candidates
.
is_empty
(
)
{
return
ScopeRootCandidates
:
:
empty
(
is_trivial
)
;
}
let
(
root_target
matches_shadow_host
)
=
if
let
Some
(
start
)
=
bounds
.
start
.
as_ref
(
)
{
if
let
Some
(
filter
)
=
context
.
bloom_filter
{
if
!
start
.
hashes
.
iter
(
)
.
any
(
|
entry
|
selector_may_match
(
entry
filter
)
)
{
return
ScopeRootCandidates
:
:
empty
(
is_trivial
)
;
}
}
(
ScopeTarget
:
:
Selector
(
&
start
.
selectors
)
start
.
selectors
.
slice
(
)
.
iter
(
)
.
any
(
|
s
|
{
!
s
.
matches_featureless_host_selector_or_pseudo_element
(
)
.
is_empty
(
)
}
)
)
}
else
{
let
implicit_root
=
condition_ref
.
implicit_scope_root
.
as_ref
(
)
.
expect
(
"
No
boundaries
no
implicit
root
?
"
)
;
match
implicit_root
{
StylistImplicitScopeRoot
:
:
Normal
(
r
)
=
>
{
match
r
.
element
(
context
.
current_host
.
clone
(
)
)
{
None
=
>
return
ScopeRootCandidates
:
:
empty
(
is_trivial
)
Some
(
root
)
=
>
(
ScopeTarget
:
:
Element
(
root
)
r
.
matches_shadow_host
(
)
)
}
}
StylistImplicitScopeRoot
:
:
Cached
(
index
)
=
>
{
use
crate
:
:
dom
:
:
TShadowRoot
;
let
host
=
context
.
current_host
.
expect
(
"
Cached
implicit
scope
for
light
DOM
implicit
scope
"
)
;
let
shadow_root
=
E
:
:
unopaque
(
host
)
.
shadow_root
(
)
.
expect
(
"
Shadow
host
without
root
?
"
)
;
match
shadow_root
.
implicit_scope_for_sheet
(
*
index
)
{
None
=
>
return
ScopeRootCandidates
:
:
empty
(
is_trivial
)
Some
(
root
)
=
>
{
match
root
.
element
(
context
.
current_host
.
clone
(
)
)
{
None
=
>
return
ScopeRootCandidates
:
:
empty
(
is_trivial
)
Some
(
r
)
=
>
(
ScopeTarget
:
:
Element
(
r
)
root
.
matches_shadow_host
(
)
)
}
}
}
}
}
}
;
let
matches_shadow_host
=
override_matches_shadow_host_for_part
|
|
matches_shadow_host
;
let
potential_scope_roots
=
if
is_outermost_scope
{
collect_scope_roots
(
element
None
context
&
root_target
matches_shadow_host
&
self
.
scope_subject_map
)
}
else
{
let
mut
result
=
vec
!
[
]
;
for
activation
in
outer_result
.
candidates
{
let
mut
this_result
=
collect_scope_roots
(
element
Some
(
activation
.
root
)
context
&
root_target
matches_shadow_host
&
self
.
scope_subject_map
)
;
result
.
append
(
&
mut
this_result
)
;
}
result
}
;
if
potential_scope_roots
.
is_empty
(
)
{
return
ScopeRootCandidates
:
:
empty
(
is_trivial
)
;
}
let
candidates
=
if
let
Some
(
end
)
=
bounds
.
end
.
as_ref
(
)
{
let
mut
result
=
vec
!
[
]
;
for
scope_root
in
potential_scope_roots
{
if
end
.
selectors
.
slice
(
)
.
iter
(
)
.
zip
(
end
.
hashes
.
iter
(
)
)
.
all
(
|
(
selector
hashes
)
|
{
if
let
Some
(
filter
)
=
context
.
bloom_filter
{
if
!
selector_may_match
(
hashes
filter
)
{
return
true
;
}
}
!
element_is_outside_of_scope
(
selector
element
scope_root
.
root
context
matches_shadow_host
)
}
)
{
result
.
push
(
scope_root
)
;
}
}
result
}
else
{
potential_scope_roots
}
;
ScopeRootCandidates
{
candidates
is_trivial
}
}
fn
did_finish_rebuild
(
&
mut
self
)
{
self
.
shrink_maps_if_needed
(
)
;
self
.
compute_layer_order
(
)
;
}
fn
shrink_maps_if_needed
(
&
mut
self
)
{
self
.
normal_rules
.
shrink_if_needed
(
)
;
if
let
Some
(
ref
mut
host_rules
)
=
self
.
featureless_host_rules
{
host_rules
.
shrink_if_needed
(
)
;
}
if
let
Some
(
ref
mut
slotted_rules
)
=
self
.
slotted_rules
{
slotted_rules
.
shrink_if_needed
(
)
;
}
self
.
animations
.
shrink_if_needed
(
)
;
self
.
custom_property_registrations
.
shrink_if_needed
(
)
;
self
.
invalidation_map
.
shrink_if_needed
(
)
;
self
.
relative_selector_invalidation_map
.
shrink_if_needed
(
)
;
self
.
attribute_dependencies
.
shrink_if_needed
(
)
;
self
.
nth_of_attribute_dependencies
.
shrink_if_needed
(
)
;
self
.
nth_of_custom_state_dependencies
.
shrink_if_needed
(
)
;
self
.
nth_of_class_dependencies
.
shrink_if_needed
(
)
;
self
.
nth_of_mapped_ids
.
shrink_if_needed
(
)
;
self
.
mapped_ids
.
shrink_if_needed
(
)
;
self
.
layer_id
.
shrink_if_needed
(
)
;
self
.
selectors_for_cache_revalidation
.
shrink_if_needed
(
)
;
self
.
scope_subject_map
.
shrink_if_needed
(
)
;
}
fn
compute_layer_order
(
&
mut
self
)
{
debug_assert_ne
!
(
self
.
layers
.
len
(
)
0
"
There
should
be
at
least
the
root
layer
!
"
)
;
if
self
.
layers
.
len
(
)
=
=
1
{
return
;
}
let
(
first
remaining
)
=
self
.
layers
.
split_at_mut
(
1
)
;
let
root
=
&
mut
first
[
0
]
;
let
mut
order
=
LayerOrder
:
:
first
(
)
;
compute_layer_order_for_subtree
(
root
remaining
&
mut
order
)
;
fn
compute_layer_order_for_subtree
(
parent
:
&
mut
CascadeLayer
remaining_layers
:
&
mut
[
CascadeLayer
]
order
:
&
mut
LayerOrder
)
{
for
child
in
parent
.
children
.
iter
(
)
{
debug_assert
!
(
parent
.
id
<
*
child
"
Children
are
always
registered
after
parents
"
)
;
let
child_index
=
(
child
.
0
-
parent
.
id
.
0
-
1
)
as
usize
;
let
(
first
remaining
)
=
remaining_layers
.
split_at_mut
(
child_index
+
1
)
;
let
child
=
&
mut
first
[
child_index
]
;
compute_layer_order_for_subtree
(
child
remaining
order
)
;
}
if
parent
.
id
!
=
LayerId
:
:
root
(
)
{
parent
.
order
=
*
order
;
order
.
inc
(
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
self
.
extra_data
.
sort_by_layer
(
&
self
.
layers
)
;
self
.
animations
.
sort_with
(
&
self
.
layers
compare_keyframes_in_same_layer
)
;
self
.
custom_property_registrations
.
sort
(
&
self
.
layers
)
}
fn
collect_applicable_media_query_results_into
<
S
>
(
device
:
&
Device
stylesheet
:
&
S
guard
:
&
SharedRwLockReadGuard
results
:
&
mut
Vec
<
MediaListKey
>
contents_list
:
&
mut
StyleSheetContentList
)
where
S
:
StylesheetInDocument
+
'
static
{
if
!
stylesheet
.
enabled
(
)
|
|
!
stylesheet
.
is_effective_for_device
(
device
guard
)
{
return
;
}
debug
!
(
"
+
{
:
?
}
"
stylesheet
)
;
let
contents
=
stylesheet
.
contents
(
)
;
results
.
push
(
contents
.
to_media_list_key
(
)
)
;
contents_list
.
push
(
StylesheetContentsPtr
(
unsafe
{
Arc
:
:
from_raw_addrefed
(
contents
)
}
)
)
;
for
rule
in
stylesheet
.
effective_rules
(
device
guard
)
{
match
*
rule
{
CssRule
:
:
Import
(
ref
lock
)
=
>
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
debug
!
(
"
+
{
:
?
}
"
import_rule
.
stylesheet
.
media
(
guard
)
)
;
results
.
push
(
import_rule
.
to_media_list_key
(
)
)
;
}
CssRule
:
:
Media
(
ref
media_rule
)
=
>
{
debug
!
(
"
+
{
:
?
}
"
media_rule
.
media_queries
.
read_with
(
guard
)
)
;
results
.
push
(
media_rule
.
to_media_list_key
(
)
)
;
}
_
=
>
{
}
}
}
}
fn
add_styles
(
&
mut
self
style_source
:
StyleSource
selectors
:
&
SelectorList
<
SelectorImpl
>
declarations
:
&
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
ancestor_selectors
:
Option
<
&
SelectorList
<
SelectorImpl
>
>
containing_rule_state
:
&
ContainingRuleState
mut
replaced_selectors
:
Option
<
&
mut
ReplacedSelectors
>
guard
:
&
SharedRwLockReadGuard
rebuild_kind
:
SheetRebuildKind
mut
precomputed_pseudo_element_decls
:
Option
<
&
mut
PrecomputedPseudoElementDeclarations
>
quirks_mode
:
QuirksMode
)
-
>
Result
<
(
)
AllocErr
>
{
self
.
num_declarations
+
=
declarations
.
read_with
(
guard
)
.
len
(
)
;
for
selector
in
selectors
.
slice
(
)
{
self
.
num_selectors
+
=
1
;
let
pseudo_element
=
selector
.
pseudo_element
(
)
;
if
let
Some
(
pseudo
)
=
pseudo_element
{
if
pseudo
.
is_precomputed
(
)
{
debug_assert
!
(
selector
.
is_universal
(
)
)
;
debug_assert
!
(
ancestor_selectors
.
is_none
(
)
)
;
debug_assert_eq
!
(
containing_rule_state
.
layer_id
LayerId
:
:
root
(
)
)
;
debug_assert_eq
!
(
containing_rule_state
.
scope_condition_id
ScopeConditionId
:
:
none
(
)
)
;
precomputed_pseudo_element_decls
.
as_mut
(
)
.
expect
(
"
Expected
precomputed
declarations
for
the
UA
level
"
)
.
get_or_insert_with
(
pseudo
Vec
:
:
new
)
.
push
(
ApplicableDeclarationBlock
:
:
new
(
style_source
.
clone
(
)
self
.
rules_source_order
CascadeLevel
:
:
UANormal
selector
.
specificity
(
)
LayerOrder
:
:
root
(
)
ScopeProximity
:
:
infinity
(
)
)
)
;
continue
;
}
if
pseudo
.
is_unknown_webkit_pseudo_element
(
)
{
continue
;
}
}
let
selector
=
match
ancestor_selectors
{
Some
(
ref
s
)
=
>
selector
.
replace_parent_selector
(
&
s
)
None
=
>
selector
.
clone
(
)
}
;
let
hashes
=
AncestorHashes
:
:
new
(
&
selector
quirks_mode
)
;
let
rule
=
Rule
:
:
new
(
selector
hashes
style_source
.
clone
(
)
self
.
rules_source_order
containing_rule_state
.
layer_id
containing_rule_state
.
container_condition_id
containing_rule_state
.
in_starting_style
containing_rule_state
.
scope_condition_id
)
;
if
let
Some
(
ref
mut
replaced_selectors
)
=
replaced_selectors
{
replaced_selectors
.
push
(
rule
.
selector
.
clone
(
)
)
}
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
note_selector_for_invalidation
(
&
rule
.
selector
quirks_mode
&
mut
self
.
invalidation_map
&
mut
self
.
relative_selector_invalidation_map
)
?
;
let
mut
needs_revalidation
=
false
;
let
mut
visitor
=
StylistSelectorVisitor
{
needs_revalidation
:
&
mut
needs_revalidation
passed_rightmost_selector
:
false
in_selector_list_of
:
SelectorListKind
:
:
default
(
)
mapped_ids
:
&
mut
self
.
mapped_ids
nth_of_mapped_ids
:
&
mut
self
.
nth_of_mapped_ids
attribute_dependencies
:
&
mut
self
.
attribute_dependencies
nth_of_class_dependencies
:
&
mut
self
.
nth_of_class_dependencies
nth_of_attribute_dependencies
:
&
mut
self
.
nth_of_attribute_dependencies
nth_of_custom_state_dependencies
:
&
mut
self
.
nth_of_custom_state_dependencies
state_dependencies
:
&
mut
self
.
state_dependencies
nth_of_state_dependencies
:
&
mut
self
.
nth_of_state_dependencies
document_state_dependencies
:
&
mut
self
.
document_state_dependencies
}
;
rule
.
selector
.
visit
(
&
mut
visitor
)
;
if
needs_revalidation
{
self
.
selectors_for_cache_revalidation
.
insert
(
RevalidationSelectorAndHashes
:
:
new
(
rule
.
selector
.
clone
(
)
rule
.
hashes
.
clone
(
)
)
quirks_mode
)
?
;
}
}
if
let
Some
(
parts
)
=
rule
.
selector
.
parts
(
)
{
let
map
=
self
.
part_rules
.
get_or_insert_with
(
|
|
Box
:
:
new
(
Default
:
:
default
(
)
)
)
.
for_insertion
(
pseudo_element
)
;
map
.
try_reserve
(
1
)
?
;
let
vec
=
map
.
entry
(
parts
.
last
(
)
.
unwrap
(
)
.
clone
(
)
.
0
)
.
or_default
(
)
;
vec
.
try_reserve
(
1
)
?
;
vec
.
push
(
rule
)
;
}
else
{
let
potentially_matches_featureless_host
=
rule
.
selector
.
matches_featureless_host_selector_or_pseudo_element
(
)
;
let
matches_featureless_host
=
if
potentially_matches_featureless_host
.
intersects
(
FeaturelessHostMatches
:
:
FOR_HOST
)
{
true
}
else
if
potentially_matches_featureless_host
.
intersects
(
FeaturelessHostMatches
:
:
FOR_SCOPE
)
{
containing_rule_state
.
scope_matches_shadow_host
=
=
ScopeMatchesShadowHost
:
:
Yes
}
else
{
false
}
;
let
rules
=
if
matches_featureless_host
{
self
.
featureless_host_rules
.
get_or_insert_with
(
|
|
Box
:
:
new
(
Default
:
:
default
(
)
)
)
}
else
if
rule
.
selector
.
is_slotted
(
)
{
self
.
slotted_rules
.
get_or_insert_with
(
|
|
Box
:
:
new
(
Default
:
:
default
(
)
)
)
}
else
{
&
mut
self
.
normal_rules
}
.
for_insertion
(
pseudo_element
)
;
rules
.
insert
(
rule
quirks_mode
)
?
;
}
}
self
.
rules_source_order
+
=
1
;
Ok
(
(
)
)
}
fn
add_rule_list
<
S
>
(
&
mut
self
rules
:
std
:
:
slice
:
:
Iter
<
CssRule
>
device
:
&
Device
quirks_mode
:
QuirksMode
stylesheet
:
&
S
sheet_index
:
usize
guard
:
&
SharedRwLockReadGuard
rebuild_kind
:
SheetRebuildKind
containing_rule_state
:
&
mut
ContainingRuleState
mut
precomputed_pseudo_element_decls
:
Option
<
&
mut
PrecomputedPseudoElementDeclarations
>
)
-
>
Result
<
(
)
AllocErr
>
where
S
:
StylesheetInDocument
+
'
static
{
for
rule
in
rules
{
let
mut
handled
=
true
;
let
mut
list_for_nested_rules
=
None
;
match
*
rule
{
CssRule
:
:
Style
(
ref
locked
)
=
>
{
let
style_rule
=
locked
.
read_with
(
guard
)
;
let
has_nested_rules
=
style_rule
.
rules
.
is_some
(
)
;
let
mut
replaced_selectors
=
ReplacedSelectors
:
:
new
(
)
;
let
ancestor_selectors
=
containing_rule_state
.
ancestor_selector_lists
.
last
(
)
;
let
collect_replaced_selectors
=
has_nested_rules
&
&
ancestor_selectors
.
is_some
(
)
;
self
.
add_styles
(
StyleSource
:
:
from_rule
(
locked
.
clone
(
)
)
&
style_rule
.
selectors
&
style_rule
.
block
ancestor_selectors
&
containing_rule_state
if
collect_replaced_selectors
{
Some
(
&
mut
replaced_selectors
)
}
else
{
None
}
guard
rebuild_kind
precomputed_pseudo_element_decls
.
as_deref_mut
(
)
quirks_mode
)
?
;
if
has_nested_rules
{
handled
=
false
;
list_for_nested_rules
=
Some
(
if
collect_replaced_selectors
{
SelectorList
:
:
from_iter
(
replaced_selectors
.
drain
(
.
.
)
)
}
else
{
style_rule
.
selectors
.
clone
(
)
}
)
;
}
}
CssRule
:
:
NestedDeclarations
(
ref
rule
)
=
>
{
lazy_static
!
{
static
ref
IMPLICIT_SCOPE
:
SelectorList
<
SelectorImpl
>
=
{
let
list
=
SelectorList
:
:
implicit_scope
(
)
;
list
.
mark_as_intentionally_leaked
(
)
;
list
}
;
}
;
if
let
Some
(
ref
ancestor_selectors
)
=
containing_rule_state
.
ancestor_selector_lists
.
last
(
)
{
let
decls
=
&
rule
.
read_with
(
guard
)
.
block
;
let
selectors
=
match
containing_rule_state
.
nested_declarations_context
{
NestedDeclarationsContext
:
:
Style
=
>
ancestor_selectors
NestedDeclarationsContext
:
:
Scope
=
>
&
*
IMPLICIT_SCOPE
}
;
self
.
add_styles
(
StyleSource
:
:
from_declarations
(
decls
.
clone
(
)
)
selectors
decls
None
&
containing_rule_state
None
guard
SheetRebuildKind
:
:
CascadeOnly
precomputed_pseudo_element_decls
.
as_deref_mut
(
)
quirks_mode
)
?
;
}
}
CssRule
:
:
Keyframes
(
ref
keyframes_rule
)
=
>
{
debug
!
(
"
Found
valid
keyframes
rule
:
{
:
?
}
"
*
keyframes_rule
)
;
let
keyframes_rule
=
keyframes_rule
.
read_with
(
guard
)
;
let
name
=
keyframes_rule
.
name
.
as_atom
(
)
.
clone
(
)
;
let
animation
=
KeyframesAnimation
:
:
from_keyframes
(
&
keyframes_rule
.
keyframes
keyframes_rule
.
vendor_prefix
.
clone
(
)
guard
)
;
self
.
animations
.
try_insert_with
(
name
animation
containing_rule_state
.
layer_id
compare_keyframes_in_same_layer
)
?
;
}
CssRule
:
:
Property
(
ref
registration
)
=
>
{
self
.
custom_property_registrations
.
try_insert
(
registration
.
name
.
0
.
clone
(
)
Arc
:
:
clone
(
registration
)
containing_rule_state
.
layer_id
)
?
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
FontFace
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_font_face
(
rule
containing_rule_state
.
layer_id
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
FontFeatureValues
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_font_feature_values
(
rule
containing_rule_state
.
layer_id
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
FontPaletteValues
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_font_palette_values
(
rule
containing_rule_state
.
layer_id
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
CounterStyle
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_counter_style
(
guard
rule
containing_rule_state
.
layer_id
)
?
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
Page
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_page
(
guard
rule
containing_rule_state
.
layer_id
)
?
;
handled
=
false
;
}
_
=
>
{
handled
=
false
;
}
}
if
handled
{
if
cfg
!
(
debug_assertions
)
{
let
mut
effective
=
false
;
let
children
=
EffectiveRulesIterator
:
:
children
(
rule
device
quirks_mode
guard
&
mut
effective
)
;
debug_assert
!
(
children
.
is_none
(
)
)
;
debug_assert
!
(
effective
)
;
}
continue
;
}
let
mut
effective
=
false
;
let
children
=
EffectiveRulesIterator
:
:
children
(
rule
device
quirks_mode
guard
&
mut
effective
)
;
if
!
effective
{
continue
;
}
fn
maybe_register_layer
(
data
:
&
mut
CascadeData
layer
:
&
LayerName
)
-
>
LayerId
{
if
let
Some
(
id
)
=
data
.
layer_id
.
get
(
layer
)
{
return
*
id
;
}
let
id
=
LayerId
(
data
.
layers
.
len
(
)
as
u16
)
;
let
parent_layer_id
=
if
layer
.
layer_names
(
)
.
len
(
)
>
1
{
let
mut
parent
=
layer
.
clone
(
)
;
parent
.
0
.
pop
(
)
;
*
data
.
layer_id
.
get_mut
(
&
parent
)
.
expect
(
"
Parent
layers
should
be
registered
before
child
layers
"
)
}
else
{
LayerId
:
:
root
(
)
}
;
data
.
layers
[
parent_layer_id
.
0
as
usize
]
.
children
.
push
(
id
)
;
data
.
layers
.
push
(
CascadeLayer
{
id
order
:
LayerOrder
:
:
first
(
)
children
:
vec
!
[
]
}
)
;
data
.
layer_id
.
insert
(
layer
.
clone
(
)
id
)
;
id
}
fn
maybe_register_layers
(
data
:
&
mut
CascadeData
name
:
Option
<
&
LayerName
>
containing_rule_state
:
&
mut
ContainingRuleState
)
{
let
anon_name
;
let
name
=
match
name
{
Some
(
name
)
=
>
name
None
=
>
{
anon_name
=
LayerName
:
:
new_anonymous
(
)
;
&
anon_name
}
}
;
for
name
in
name
.
layer_names
(
)
{
containing_rule_state
.
layer_name
.
0
.
push
(
name
.
clone
(
)
)
;
containing_rule_state
.
layer_id
=
maybe_register_layer
(
data
&
containing_rule_state
.
layer_name
)
;
}
debug_assert_ne
!
(
containing_rule_state
.
layer_id
LayerId
:
:
root
(
)
)
;
}
let
saved_containing_rule_state
=
containing_rule_state
.
save
(
)
;
match
*
rule
{
CssRule
:
:
Import
(
ref
lock
)
=
>
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
self
.
effective_media_query_results
.
saw_effective
(
import_rule
)
;
}
match
import_rule
.
layer
{
ImportLayer
:
:
Named
(
ref
name
)
=
>
{
maybe_register_layers
(
self
Some
(
name
)
containing_rule_state
)
}
ImportLayer
:
:
Anonymous
=
>
{
maybe_register_layers
(
self
None
containing_rule_state
)
}
ImportLayer
:
:
None
=
>
{
}
}
}
CssRule
:
:
Media
(
ref
media_rule
)
=
>
{
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
self
.
effective_media_query_results
.
saw_effective
(
&
*
*
media_rule
)
;
}
}
CssRule
:
:
LayerBlock
(
ref
rule
)
=
>
{
maybe_register_layers
(
self
rule
.
name
.
as_ref
(
)
containing_rule_state
)
;
}
CssRule
:
:
LayerStatement
(
ref
rule
)
=
>
{
for
name
in
&
*
rule
.
names
{
maybe_register_layers
(
self
Some
(
name
)
containing_rule_state
)
;
containing_rule_state
.
restore
(
&
saved_containing_rule_state
)
;
}
}
CssRule
:
:
Style
(
.
.
)
=
>
{
containing_rule_state
.
nested_declarations_context
=
NestedDeclarationsContext
:
:
Style
;
if
let
Some
(
s
)
=
list_for_nested_rules
{
containing_rule_state
.
ancestor_selector_lists
.
push
(
s
)
;
}
}
CssRule
:
:
Container
(
ref
rule
)
=
>
{
let
id
=
ContainerConditionId
(
self
.
container_conditions
.
len
(
)
as
u16
)
;
self
.
container_conditions
.
push
(
ContainerConditionReference
{
parent
:
containing_rule_state
.
container_condition_id
condition
:
Some
(
rule
.
condition
.
clone
(
)
)
}
)
;
containing_rule_state
.
container_condition_id
=
id
;
}
CssRule
:
:
StartingStyle
(
.
.
)
=
>
{
containing_rule_state
.
in_starting_style
=
true
;
}
CssRule
:
:
Scope
(
ref
rule
)
=
>
{
containing_rule_state
.
nested_declarations_context
=
NestedDeclarationsContext
:
:
Scope
;
let
id
=
ScopeConditionId
(
self
.
scope_conditions
.
len
(
)
as
u16
)
;
let
mut
matches_shadow_host
=
false
;
let
implicit_scope_root
=
if
let
Some
(
start
)
=
rule
.
bounds
.
start
.
as_ref
(
)
{
matches_shadow_host
=
start
.
slice
(
)
.
iter
(
)
.
any
(
|
s
|
{
!
s
.
matches_featureless_host_selector_or_pseudo_element
(
)
.
is_empty
(
)
}
)
;
None
}
else
{
stylesheet
.
implicit_scope_root
(
)
.
map
(
|
root
|
{
matches_shadow_host
=
root
.
matches_shadow_host
(
)
;
match
root
{
ImplicitScopeRoot
:
:
InLightTree
(
_
)
|
ImplicitScopeRoot
:
:
Constructed
=
>
{
StylistImplicitScopeRoot
:
:
Normal
(
root
)
}
ImplicitScopeRoot
:
:
ShadowHost
(
_
)
|
ImplicitScopeRoot
:
:
InShadowTree
(
_
)
=
>
{
StylistImplicitScopeRoot
:
:
Cached
(
sheet_index
)
}
}
}
)
}
;
let
replaced
=
{
let
start
=
rule
.
bounds
.
start
.
as_ref
(
)
.
map
(
|
selector
|
{
match
containing_rule_state
.
ancestor_selector_lists
.
last
(
)
{
Some
(
s
)
=
>
selector
.
replace_parent_selector
(
s
)
None
=
>
selector
.
clone
(
)
}
}
)
;
let
parent
=
parent_selector_for_scope
(
start
.
as_ref
(
)
)
;
let
end
=
rule
.
bounds
.
end
.
as_ref
(
)
.
map
(
|
selector
|
selector
.
replace_parent_selector
(
parent
)
)
;
containing_rule_state
.
ancestor_selector_lists
.
push
(
parent
.
clone
(
)
)
;
ScopeBoundsWithHashes
:
:
new
(
quirks_mode
start
end
)
}
;
if
let
Some
(
selectors
)
=
replaced
.
start
.
as_ref
(
)
{
self
.
scope_subject_map
.
add_bound_start
(
&
selectors
.
selectors
quirks_mode
)
;
}
let
is_trivial
=
scope_bounds_is_trivial
(
&
replaced
)
;
self
.
scope_conditions
.
push
(
ScopeConditionReference
{
parent
:
containing_rule_state
.
scope_condition_id
condition
:
Some
(
replaced
)
implicit_scope_root
is_trivial
}
)
;
containing_rule_state
.
scope_matches_shadow_host
.
nest_for_scope
(
matches_shadow_host
)
;
containing_rule_state
.
scope_condition_id
=
id
;
}
_
=
>
{
}
}
if
let
Some
(
children
)
=
children
{
self
.
add_rule_list
(
children
device
quirks_mode
stylesheet
sheet_index
guard
rebuild_kind
containing_rule_state
precomputed_pseudo_element_decls
.
as_deref_mut
(
)
)
?
;
}
containing_rule_state
.
restore
(
&
saved_containing_rule_state
)
;
}
Ok
(
(
)
)
}
fn
add_stylesheet
<
S
>
(
&
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
stylesheet
:
&
S
sheet_index
:
usize
guard
:
&
SharedRwLockReadGuard
rebuild_kind
:
SheetRebuildKind
mut
precomputed_pseudo_element_decls
:
Option
<
&
mut
PrecomputedPseudoElementDeclarations
>
)
-
>
Result
<
(
)
AllocErr
>
where
S
:
StylesheetInDocument
+
'
static
{
if
!
stylesheet
.
enabled
(
)
|
|
!
stylesheet
.
is_effective_for_device
(
device
guard
)
{
return
Ok
(
(
)
)
;
}
let
contents
=
stylesheet
.
contents
(
)
;
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
self
.
effective_media_query_results
.
saw_effective
(
contents
)
;
}
let
mut
state
=
ContainingRuleState
:
:
default
(
)
;
self
.
add_rule_list
(
contents
.
rules
(
guard
)
.
iter
(
)
device
quirks_mode
stylesheet
sheet_index
guard
rebuild_kind
&
mut
state
precomputed_pseudo_element_decls
.
as_deref_mut
(
)
)
?
;
Ok
(
(
)
)
}
pub
fn
media_feature_affected_matches
<
S
>
(
&
self
stylesheet
:
&
S
guard
:
&
SharedRwLockReadGuard
device
:
&
Device
quirks_mode
:
QuirksMode
)
-
>
bool
where
S
:
StylesheetInDocument
+
'
static
{
use
crate
:
:
invalidation
:
:
media_queries
:
:
PotentiallyEffectiveMediaRules
;
let
effective_now
=
stylesheet
.
is_effective_for_device
(
device
guard
)
;
let
effective_then
=
self
.
effective_media_query_results
.
was_effective
(
stylesheet
.
contents
(
)
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
Stylesheet
{
:
?
}
changed
-
>
{
}
{
}
"
stylesheet
.
media
(
guard
)
effective_then
effective_now
)
;
return
false
;
}
if
!
effective_now
{
return
true
;
}
let
mut
iter
=
stylesheet
.
iter_rules
:
:
<
PotentiallyEffectiveMediaRules
>
(
device
guard
)
;
while
let
Some
(
rule
)
=
iter
.
next
(
)
{
match
*
rule
{
CssRule
:
:
Style
(
.
.
)
|
CssRule
:
:
NestedDeclarations
(
.
.
)
|
CssRule
:
:
Namespace
(
.
.
)
|
CssRule
:
:
FontFace
(
.
.
)
|
CssRule
:
:
Container
(
.
.
)
|
CssRule
:
:
CounterStyle
(
.
.
)
|
CssRule
:
:
Supports
(
.
.
)
|
CssRule
:
:
Keyframes
(
.
.
)
|
CssRule
:
:
Margin
(
.
.
)
|
CssRule
:
:
Page
(
.
.
)
|
CssRule
:
:
Property
(
.
.
)
|
CssRule
:
:
Document
(
.
.
)
|
CssRule
:
:
LayerBlock
(
.
.
)
|
CssRule
:
:
LayerStatement
(
.
.
)
|
CssRule
:
:
FontPaletteValues
(
.
.
)
|
CssRule
:
:
FontFeatureValues
(
.
.
)
|
CssRule
:
:
Scope
(
.
.
)
|
CssRule
:
:
StartingStyle
(
.
.
)
|
CssRule
:
:
PositionTry
(
.
.
)
=
>
{
continue
;
}
CssRule
:
:
Import
(
ref
lock
)
=
>
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
let
effective_now
=
match
import_rule
.
stylesheet
.
media
(
guard
)
{
Some
(
m
)
=
>
m
.
evaluate
(
device
quirks_mode
)
None
=
>
true
}
;
let
effective_then
=
self
.
effective_media_query_results
.
was_effective
(
import_rule
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
import
rule
{
:
?
}
changed
{
}
-
>
{
}
"
import_rule
.
stylesheet
.
media
(
guard
)
effective_then
effective_now
)
;
return
false
;
}
if
!
effective_now
{
iter
.
skip_children
(
)
;
}
}
CssRule
:
:
Media
(
ref
media_rule
)
=
>
{
let
mq
=
media_rule
.
media_queries
.
read_with
(
guard
)
;
let
effective_now
=
mq
.
evaluate
(
device
quirks_mode
)
;
let
effective_then
=
self
.
effective_media_query_results
.
was_effective
(
&
*
*
media_rule
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
media
rule
{
:
?
}
changed
{
}
-
>
{
}
"
mq
effective_then
effective_now
)
;
return
false
;
}
if
!
effective_now
{
iter
.
skip_children
(
)
;
}
}
}
}
true
}
pub
fn
custom_property_registrations
(
&
self
)
-
>
&
LayerOrderedMap
<
Arc
<
PropertyRegistration
>
>
{
&
self
.
custom_property_registrations
}
fn
revalidate_scopes
<
E
:
TElement
>
(
&
self
stylist
:
&
Stylist
element
:
&
E
matching_context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
result
:
&
mut
ScopeRevalidationResult
)
{
for
condition_id
in
1
.
.
self
.
scope_conditions
.
len
(
)
{
let
condition
=
&
self
.
scope_conditions
[
condition_id
]
;
let
matches
=
if
condition
.
is_trivial
{
continue
;
}
else
{
let
result
=
self
.
scope_condition_matches
(
ScopeConditionId
(
condition_id
as
u16
)
stylist
*
element
false
matching_context
)
;
!
result
.
candidates
.
is_empty
(
)
}
;
result
.
scopes_matched
.
push
(
matches
)
;
}
}
fn
clear_cascade_data
(
&
mut
self
)
{
self
.
normal_rules
.
clear
(
)
;
if
let
Some
(
ref
mut
slotted_rules
)
=
self
.
slotted_rules
{
slotted_rules
.
clear
(
)
;
}
if
let
Some
(
ref
mut
part_rules
)
=
self
.
part_rules
{
part_rules
.
clear
(
)
;
}
if
let
Some
(
ref
mut
host_rules
)
=
self
.
featureless_host_rules
{
host_rules
.
clear
(
)
;
}
self
.
animations
.
clear
(
)
;
self
.
custom_property_registrations
.
clear
(
)
;
self
.
layer_id
.
clear
(
)
;
self
.
layers
.
clear
(
)
;
self
.
layers
.
push
(
CascadeLayer
:
:
root
(
)
)
;
self
.
container_conditions
.
clear
(
)
;
self
.
container_conditions
.
push
(
ContainerConditionReference
:
:
none
(
)
)
;
self
.
scope_conditions
.
clear
(
)
;
self
.
scope_conditions
.
push
(
ScopeConditionReference
:
:
none
(
)
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
self
.
extra_data
.
clear
(
)
;
self
.
rules_source_order
=
0
;
self
.
num_selectors
=
0
;
self
.
num_declarations
=
0
;
}
fn
clear
(
&
mut
self
)
{
self
.
clear_cascade_data
(
)
;
self
.
invalidation_map
.
clear
(
)
;
self
.
relative_selector_invalidation_map
.
clear
(
)
;
self
.
attribute_dependencies
.
clear
(
)
;
self
.
nth_of_attribute_dependencies
.
clear
(
)
;
self
.
nth_of_custom_state_dependencies
.
clear
(
)
;
self
.
nth_of_class_dependencies
.
clear
(
)
;
self
.
state_dependencies
=
ElementState
:
:
empty
(
)
;
self
.
nth_of_state_dependencies
=
ElementState
:
:
empty
(
)
;
self
.
document_state_dependencies
=
DocumentState
:
:
empty
(
)
;
self
.
mapped_ids
.
clear
(
)
;
self
.
nth_of_mapped_ids
.
clear
(
)
;
self
.
selectors_for_cache_revalidation
.
clear
(
)
;
self
.
effective_media_query_results
.
clear
(
)
;
self
.
scope_subject_map
.
clear
(
)
;
}
}
impl
CascadeDataCacheEntry
for
CascadeData
{
fn
rebuild
<
S
>
(
device
:
&
Device
quirks_mode
:
QuirksMode
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
old
:
&
Self
)
-
>
Result
<
Arc
<
Self
>
AllocErr
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
debug_assert
!
(
collection
.
dirty
(
)
"
We
surely
need
to
do
something
?
"
)
;
let
mut
updatable_entry
=
match
collection
.
data_validity
(
)
{
DataValidity
:
:
Valid
|
DataValidity
:
:
CascadeInvalid
=
>
old
.
clone
(
)
DataValidity
:
:
FullyInvalid
=
>
Self
:
:
new
(
)
}
;
updatable_entry
.
rebuild
(
device
quirks_mode
collection
guard
)
?
;
Ok
(
Arc
:
:
new
(
updatable_entry
)
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
normal_rules
.
add_size_of
(
ops
sizes
)
;
if
let
Some
(
ref
slotted_rules
)
=
self
.
slotted_rules
{
slotted_rules
.
add_size_of
(
ops
sizes
)
;
}
if
let
Some
(
ref
part_rules
)
=
self
.
part_rules
{
part_rules
.
add_size_of
(
ops
sizes
)
;
}
if
let
Some
(
ref
host_rules
)
=
self
.
featureless_host_rules
{
host_rules
.
add_size_of
(
ops
sizes
)
;
}
sizes
.
mInvalidationMap
+
=
self
.
invalidation_map
.
size_of
(
ops
)
;
sizes
.
mRevalidationSelectors
+
=
self
.
selectors_for_cache_revalidation
.
size_of
(
ops
)
;
sizes
.
mOther
+
=
self
.
animations
.
size_of
(
ops
)
;
sizes
.
mOther
+
=
self
.
effective_media_query_results
.
size_of
(
ops
)
;
sizes
.
mOther
+
=
self
.
extra_data
.
size_of
(
ops
)
;
}
}
impl
Default
for
CascadeData
{
fn
default
(
)
-
>
Self
{
CascadeData
:
:
new
(
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
Rule
{
#
[
ignore_malloc_size_of
=
"
CssRules
have
primary
refs
we
measure
there
"
]
pub
selector
:
Selector
<
SelectorImpl
>
pub
hashes
:
AncestorHashes
pub
source_order
:
u32
pub
layer_id
:
LayerId
pub
container_condition_id
:
ContainerConditionId
pub
is_starting_style
:
bool
pub
scope_condition_id
:
ScopeConditionId
#
[
ignore_malloc_size_of
=
"
Secondary
ref
.
Primary
ref
is
in
StyleRule
under
Stylesheet
.
"
]
pub
style_source
:
StyleSource
}
impl
SelectorMapEntry
for
Rule
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter
(
)
}
}
impl
Rule
{
pub
fn
specificity
(
&
self
)
-
>
u32
{
self
.
selector
.
specificity
(
)
}
pub
fn
to_applicable_declaration_block
(
&
self
level
:
CascadeLevel
cascade_data
:
&
CascadeData
scope_proximity
:
ScopeProximity
)
-
>
ApplicableDeclarationBlock
{
ApplicableDeclarationBlock
:
:
new
(
self
.
style_source
.
clone
(
)
self
.
source_order
level
self
.
specificity
(
)
cascade_data
.
layer_order_for
(
self
.
layer_id
)
scope_proximity
)
}
pub
fn
new
(
selector
:
Selector
<
SelectorImpl
>
hashes
:
AncestorHashes
style_source
:
StyleSource
source_order
:
u32
layer_id
:
LayerId
container_condition_id
:
ContainerConditionId
is_starting_style
:
bool
scope_condition_id
:
ScopeConditionId
)
-
>
Self
{
Self
{
selector
hashes
style_source
source_order
layer_id
container_condition_id
is_starting_style
scope_condition_id
}
}
}
size_of_test
!
(
Rule
40
)
;
pub
fn
needs_revalidation_for_testing
(
s
:
&
Selector
<
SelectorImpl
>
)
-
>
bool
{
let
mut
needs_revalidation
=
false
;
let
mut
mapped_ids
=
Default
:
:
default
(
)
;
let
mut
nth_of_mapped_ids
=
Default
:
:
default
(
)
;
let
mut
attribute_dependencies
=
Default
:
:
default
(
)
;
let
mut
nth_of_class_dependencies
=
Default
:
:
default
(
)
;
let
mut
nth_of_attribute_dependencies
=
Default
:
:
default
(
)
;
let
mut
nth_of_custom_state_dependencies
=
Default
:
:
default
(
)
;
let
mut
state_dependencies
=
ElementState
:
:
empty
(
)
;
let
mut
nth_of_state_dependencies
=
ElementState
:
:
empty
(
)
;
let
mut
document_state_dependencies
=
DocumentState
:
:
empty
(
)
;
let
mut
visitor
=
StylistSelectorVisitor
{
passed_rightmost_selector
:
false
needs_revalidation
:
&
mut
needs_revalidation
in_selector_list_of
:
SelectorListKind
:
:
default
(
)
mapped_ids
:
&
mut
mapped_ids
nth_of_mapped_ids
:
&
mut
nth_of_mapped_ids
attribute_dependencies
:
&
mut
attribute_dependencies
nth_of_class_dependencies
:
&
mut
nth_of_class_dependencies
nth_of_attribute_dependencies
:
&
mut
nth_of_attribute_dependencies
nth_of_custom_state_dependencies
:
&
mut
nth_of_custom_state_dependencies
state_dependencies
:
&
mut
state_dependencies
nth_of_state_dependencies
:
&
mut
nth_of_state_dependencies
document_state_dependencies
:
&
mut
document_state_dependencies
}
;
s
.
visit
(
&
mut
visitor
)
;
needs_revalidation
}
