use
crate
:
:
applicable_declarations
:
:
{
ApplicableDeclarationBlock
ApplicableDeclarationList
}
;
use
crate
:
:
context
:
:
{
CascadeInputs
QuirksMode
}
;
use
crate
:
:
dom
:
:
{
TElement
TShadowRoot
}
;
use
crate
:
:
element_state
:
:
{
DocumentState
ElementState
}
;
use
crate
:
:
font_metrics
:
:
FontMetricsProvider
;
use
crate
:
:
invalidation
:
:
element
:
:
invalidation_map
:
:
InvalidationMap
;
use
crate
:
:
invalidation
:
:
media_queries
:
:
{
EffectiveMediaQueryResults
ToMediaListKey
}
;
use
crate
:
:
media_queries
:
:
Device
;
use
crate
:
:
properties
:
:
{
self
CascadeMode
ComputedValues
}
;
use
crate
:
:
properties
:
:
{
AnimationRules
PropertyDeclarationBlock
}
;
use
crate
:
:
rule_cache
:
:
{
RuleCache
RuleCacheConditions
}
;
use
crate
:
:
rule_collector
:
:
RuleCollector
;
use
crate
:
:
rule_tree
:
:
{
CascadeLevel
RuleTree
ShadowCascadeOrder
StrongRuleNode
StyleSource
}
;
use
crate
:
:
selector_map
:
:
{
PrecomputedHashMap
PrecomputedHashSet
SelectorMap
SelectorMapEntry
}
;
use
crate
:
:
selector_parser
:
:
{
PerPseudoElementMap
PseudoElement
SelectorImpl
SnapshotMap
}
;
use
crate
:
:
shared_lock
:
:
{
Locked
SharedRwLockReadGuard
StylesheetGuards
}
;
use
crate
:
:
stylesheet_set
:
:
{
DataValidity
DocumentStylesheetSet
SheetRebuildKind
}
;
use
crate
:
:
stylesheet_set
:
:
{
DocumentStylesheetFlusher
SheetCollectionFlusher
}
;
use
crate
:
:
stylesheets
:
:
keyframes_rule
:
:
KeyframesAnimation
;
use
crate
:
:
stylesheets
:
:
viewport_rule
:
:
{
self
MaybeNew
ViewportRule
}
;
use
crate
:
:
stylesheets
:
:
StyleRule
;
use
crate
:
:
stylesheets
:
:
StylesheetInDocument
;
use
crate
:
:
stylesheets
:
:
{
CssRule
Origin
OriginSet
PerOrigin
PerOriginIter
}
;
use
crate
:
:
thread_state
:
:
{
self
ThreadState
}
;
use
crate
:
:
{
Atom
LocalName
Namespace
WeakAtom
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
structs
:
:
{
ServoStyleSetSizes
StyleRuleInclusion
}
;
use
hashglobe
:
:
FailedAllocationError
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
malloc_size_of
:
:
MallocUnconditionalShallowSizeOf
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
malloc_size_of
:
:
{
MallocShallowSizeOf
MallocSizeOf
MallocSizeOfOps
}
;
use
selectors
:
:
attr
:
:
{
CaseSensitivity
NamespaceConstraint
}
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
use
selectors
:
:
matching
:
:
VisitedHandlingMode
;
use
selectors
:
:
matching
:
:
{
matches_selector
ElementSelectorFlags
MatchingContext
MatchingMode
}
;
use
selectors
:
:
parser
:
:
{
AncestorHashes
Combinator
Component
Selector
}
;
use
selectors
:
:
parser
:
:
{
SelectorIter
Visit
}
;
use
selectors
:
:
visitor
:
:
SelectorVisitor
;
use
selectors
:
:
NthIndexCache
;
use
servo_arc
:
:
{
Arc
ArcBorrow
}
;
use
smallbitvec
:
:
SmallBitVec
;
use
std
:
:
ops
;
use
std
:
:
sync
:
:
Mutex
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
stylesheets
:
:
{
CounterStyleRule
FontFaceRule
FontFeatureValuesRule
PageRule
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
type
StylistSheet
=
crate
:
:
stylesheets
:
:
DocumentStyleSheet
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
type
StylistSheet
=
:
:
gecko
:
:
data
:
:
GeckoStyleSheet
;
lazy_static
!
{
static
ref
UA_CASCADE_DATA_CACHE
:
Mutex
<
UserAgentCascadeDataCache
>
=
Mutex
:
:
new
(
UserAgentCascadeDataCache
:
:
new
(
)
)
;
}
struct
UserAgentCascadeDataCache
{
entries
:
Vec
<
Arc
<
UserAgentCascadeData
>
>
}
impl
UserAgentCascadeDataCache
{
fn
new
(
)
-
>
Self
{
Self
{
entries
:
vec
!
[
]
}
}
fn
len
(
&
self
)
-
>
usize
{
self
.
entries
.
len
(
)
}
fn
lookup
<
'
a
I
S
>
(
&
'
a
mut
self
sheets
:
I
device
:
&
Device
quirks_mode
:
QuirksMode
guard
:
&
SharedRwLockReadGuard
)
-
>
Result
<
Arc
<
UserAgentCascadeData
>
FailedAllocationError
>
where
I
:
Iterator
<
Item
=
&
'
a
S
>
+
Clone
S
:
StylesheetInDocument
+
ToMediaListKey
+
PartialEq
+
'
static
{
let
mut
key
=
EffectiveMediaQueryResults
:
:
new
(
)
;
debug
!
(
"
UserAgentCascadeDataCache
:
:
lookup
(
{
:
?
}
)
"
device
)
;
for
sheet
in
sheets
.
clone
(
)
{
CascadeData
:
:
collect_applicable_media_query_results_into
(
device
sheet
guard
&
mut
key
)
}
for
entry
in
&
self
.
entries
{
if
entry
.
cascade_data
.
effective_media_query_results
=
=
key
{
return
Ok
(
entry
.
clone
(
)
)
;
}
}
let
mut
new_data
=
UserAgentCascadeData
{
cascade_data
:
CascadeData
:
:
new
(
)
precomputed_pseudo_element_decls
:
PrecomputedPseudoElementDeclarations
:
:
default
(
)
}
;
debug
!
(
"
>
Picking
the
slow
path
"
)
;
for
sheet
in
sheets
{
new_data
.
cascade_data
.
add_stylesheet
(
device
quirks_mode
sheet
guard
SheetRebuildKind
:
:
Full
Some
(
&
mut
new_data
.
precomputed_pseudo_element_decls
)
)
?
;
}
let
new_data
=
Arc
:
:
new
(
new_data
)
;
self
.
entries
.
push
(
new_data
.
clone
(
)
)
;
Ok
(
new_data
)
}
fn
expire_unused
(
&
mut
self
)
{
self
.
entries
.
retain
(
|
e
|
!
e
.
is_unique
(
)
)
}
fn
clear
(
&
mut
self
)
{
self
.
entries
.
clear
(
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
sizes
.
mOther
+
=
self
.
entries
.
shallow_size_of
(
ops
)
;
for
arc
in
self
.
entries
.
iter
(
)
{
sizes
.
mOther
+
=
arc
.
unconditional_shallow_size_of
(
ops
)
;
arc
.
add_size_of
(
ops
sizes
)
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
add_size_of_ua_cache
(
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
UA_CASCADE_DATA_CACHE
.
lock
(
)
.
unwrap
(
)
.
add_size_of
(
ops
sizes
)
;
}
type
PrecomputedPseudoElementDeclarations
=
PerPseudoElementMap
<
Vec
<
ApplicableDeclarationBlock
>
>
;
#
[
derive
(
Default
)
]
struct
UserAgentCascadeData
{
cascade_data
:
CascadeData
precomputed_pseudo_element_decls
:
PrecomputedPseudoElementDeclarations
}
impl
UserAgentCascadeData
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
cascade_data
.
add_size_of
(
ops
sizes
)
;
sizes
.
mPrecomputedPseudos
+
=
self
.
precomputed_pseudo_element_decls
.
size_of
(
ops
)
;
}
}
#
[
derive
(
Default
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
pub
struct
DocumentCascadeData
{
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
Arc
owned
by
UserAgentCascadeDataCache
"
)
]
user_agent
:
Arc
<
UserAgentCascadeData
>
user
:
CascadeData
author
:
CascadeData
per_origin
:
PerOrigin
<
(
)
>
}
pub
struct
DocumentCascadeDataIter
<
'
a
>
{
iter
:
PerOriginIter
<
'
a
(
)
>
cascade_data
:
&
'
a
DocumentCascadeData
}
impl
<
'
a
>
Iterator
for
DocumentCascadeDataIter
<
'
a
>
{
type
Item
=
(
&
'
a
CascadeData
Origin
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
(
_
origin
)
=
self
.
iter
.
next
(
)
?
;
Some
(
(
self
.
cascade_data
.
borrow_for_origin
(
origin
)
origin
)
)
}
}
impl
DocumentCascadeData
{
#
[
inline
]
pub
fn
borrow_for_origin
(
&
self
origin
:
Origin
)
-
>
&
CascadeData
{
match
origin
{
Origin
:
:
UserAgent
=
>
&
self
.
user_agent
.
cascade_data
Origin
:
:
Author
=
>
&
self
.
author
Origin
:
:
User
=
>
&
self
.
user
}
}
fn
iter_origins
(
&
self
)
-
>
DocumentCascadeDataIter
{
DocumentCascadeDataIter
{
iter
:
self
.
per_origin
.
iter_origins
(
)
cascade_data
:
self
}
}
fn
iter_origins_rev
(
&
self
)
-
>
DocumentCascadeDataIter
{
DocumentCascadeDataIter
{
iter
:
self
.
per_origin
.
iter_origins_rev
(
)
cascade_data
:
self
}
}
fn
rebuild
<
'
a
S
>
(
&
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
mut
flusher
:
DocumentStylesheetFlusher
<
'
a
S
>
guards
:
&
StylesheetGuards
)
-
>
Result
<
(
)
FailedAllocationError
>
where
S
:
StylesheetInDocument
+
ToMediaListKey
+
PartialEq
+
'
static
{
{
if
flusher
.
flush_origin
(
Origin
:
:
UserAgent
)
.
dirty
(
)
{
let
mut
ua_cache
=
UA_CASCADE_DATA_CACHE
.
lock
(
)
.
unwrap
(
)
;
let
origin_sheets
=
flusher
.
origin_sheets
(
Origin
:
:
UserAgent
)
;
let
ua_cascade_data
=
ua_cache
.
lookup
(
origin_sheets
device
quirks_mode
guards
.
ua_or_user
)
?
;
ua_cache
.
expire_unused
(
)
;
debug
!
(
"
User
agent
data
cache
size
{
:
?
}
"
ua_cache
.
len
(
)
)
;
self
.
user_agent
=
ua_cascade_data
;
}
}
self
.
user
.
rebuild
(
device
quirks_mode
flusher
.
flush_origin
(
Origin
:
:
User
)
guards
.
ua_or_user
)
?
;
self
.
author
.
rebuild
(
device
quirks_mode
flusher
.
flush_origin
(
Origin
:
:
Author
)
guards
.
author
)
?
;
Ok
(
(
)
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
user
.
add_size_of
(
ops
sizes
)
;
self
.
author
.
add_size_of
(
ops
sizes
)
;
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
)
]
pub
enum
AuthorStylesEnabled
{
Yes
No
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
struct
StylistStylesheetSet
(
DocumentStylesheetSet
<
StylistSheet
>
)
;
unsafe
impl
Sync
for
StylistStylesheetSet
{
}
impl
StylistStylesheetSet
{
fn
new
(
)
-
>
Self
{
StylistStylesheetSet
(
DocumentStylesheetSet
:
:
new
(
)
)
}
}
impl
ops
:
:
Deref
for
StylistStylesheetSet
{
type
Target
=
DocumentStylesheetSet
<
StylistSheet
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
ops
:
:
DerefMut
for
StylistStylesheetSet
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
pub
struct
Stylist
{
device
:
Device
viewport_constraints
:
Option
<
ViewportConstraints
>
stylesheets
:
StylistStylesheetSet
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
defined
in
selectors
"
)
]
quirks_mode
:
QuirksMode
cascade_data
:
DocumentCascadeData
author_styles_enabled
:
AuthorStylesEnabled
rule_tree
:
RuleTree
num_rebuilds
:
usize
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
RuleInclusion
{
All
DefaultOnly
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
StyleRuleInclusion
>
for
RuleInclusion
{
fn
from
(
value
:
StyleRuleInclusion
)
-
>
Self
{
match
value
{
StyleRuleInclusion
:
:
All
=
>
RuleInclusion
:
:
All
StyleRuleInclusion
:
:
DefaultOnly
=
>
RuleInclusion
:
:
DefaultOnly
}
}
}
impl
Stylist
{
#
[
inline
]
pub
fn
new
(
device
:
Device
quirks_mode
:
QuirksMode
)
-
>
Self
{
Self
{
viewport_constraints
:
None
device
quirks_mode
stylesheets
:
StylistStylesheetSet
:
:
new
(
)
cascade_data
:
Default
:
:
default
(
)
author_styles_enabled
:
AuthorStylesEnabled
:
:
Yes
rule_tree
:
RuleTree
:
:
new
(
)
num_rebuilds
:
0
}
}
#
[
inline
]
pub
fn
cascade_data
(
&
self
)
-
>
&
DocumentCascadeData
{
&
self
.
cascade_data
}
#
[
inline
]
pub
fn
author_styles_enabled
(
&
self
)
-
>
AuthorStylesEnabled
{
self
.
author_styles_enabled
}
#
[
inline
]
pub
fn
iter_origins
(
&
self
)
-
>
DocumentCascadeDataIter
{
self
.
cascade_data
.
iter_origins
(
)
}
#
[
inline
]
pub
fn
iter_extra_data_origins
(
&
self
)
-
>
ExtraStyleDataIterator
{
ExtraStyleDataIterator
(
self
.
cascade_data
.
iter_origins
(
)
)
}
#
[
inline
]
pub
fn
iter_extra_data_origins_rev
(
&
self
)
-
>
ExtraStyleDataIterator
{
ExtraStyleDataIterator
(
self
.
cascade_data
.
iter_origins_rev
(
)
)
}
pub
fn
num_selectors
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
d
_
)
|
d
.
num_selectors
)
.
sum
(
)
}
pub
fn
num_declarations
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
d
_
)
|
d
.
num_declarations
)
.
sum
(
)
}
pub
fn
num_rebuilds
(
&
self
)
-
>
usize
{
self
.
num_rebuilds
}
pub
fn
num_revalidation_selectors
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
data
_
)
|
data
.
selectors_for_cache_revalidation
.
len
(
)
)
.
sum
(
)
}
pub
fn
num_invalidations
(
&
self
)
-
>
usize
{
self
.
cascade_data
.
iter_origins
(
)
.
map
(
|
(
data
_
)
|
data
.
invalidation_map
.
len
(
)
)
.
sum
(
)
}
pub
fn
has_document_state_dependency
(
&
self
state
:
DocumentState
)
-
>
bool
{
self
.
cascade_data
.
iter_origins
(
)
.
any
(
|
(
d
_
)
|
d
.
document_state_dependencies
.
intersects
(
state
)
)
}
pub
fn
flush
<
E
>
(
&
mut
self
guards
:
&
StylesheetGuards
document_element
:
Option
<
E
>
snapshots
:
Option
<
&
SnapshotMap
>
)
-
>
bool
where
E
:
TElement
{
if
!
self
.
stylesheets
.
has_changed
(
)
{
return
false
;
}
self
.
num_rebuilds
+
=
1
;
self
.
viewport_constraints
=
None
;
if
viewport_rule
:
:
enabled
(
)
{
let
cascaded_rule
=
ViewportRule
{
declarations
:
viewport_rule
:
:
Cascade
:
:
from_stylesheets
(
self
.
stylesheets
.
iter
(
)
guards
&
self
.
device
)
.
finish
(
)
}
;
self
.
viewport_constraints
=
ViewportConstraints
:
:
maybe_new
(
&
self
.
device
&
cascaded_rule
self
.
quirks_mode
)
;
if
let
Some
(
ref
constraints
)
=
self
.
viewport_constraints
{
self
.
device
.
account_for_viewport_rule
(
constraints
)
;
}
}
let
flusher
=
self
.
stylesheets
.
flush
(
document_element
snapshots
)
;
let
had_invalidations
=
flusher
.
had_invalidations
(
)
;
self
.
cascade_data
.
rebuild
(
&
self
.
device
self
.
quirks_mode
flusher
guards
)
.
unwrap_or_else
(
|
_
|
warn
!
(
"
OOM
in
Stylist
:
:
flush
"
)
)
;
had_invalidations
}
pub
fn
insert_stylesheet_before
(
&
mut
self
sheet
:
StylistSheet
before_sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
insert_stylesheet_before
(
Some
(
&
self
.
device
)
sheet
before_sheet
guard
)
}
pub
fn
force_stylesheet_origins_dirty
(
&
mut
self
origins
:
OriginSet
)
{
self
.
stylesheets
.
force_dirty
(
origins
)
}
pub
fn
set_author_styles_enabled
(
&
mut
self
enabled
:
AuthorStylesEnabled
)
{
self
.
author_styles_enabled
=
enabled
;
}
pub
fn
stylesheets_have_changed
(
&
self
)
-
>
bool
{
self
.
stylesheets
.
has_changed
(
)
}
pub
fn
append_stylesheet
(
&
mut
self
sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
append_stylesheet
(
Some
(
&
self
.
device
)
sheet
guard
)
}
pub
fn
prepend_stylesheet
(
&
mut
self
sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
prepend_stylesheet
(
Some
(
&
self
.
device
)
sheet
guard
)
}
pub
fn
remove_stylesheet
(
&
mut
self
sheet
:
StylistSheet
guard
:
&
SharedRwLockReadGuard
)
{
self
.
stylesheets
.
remove_stylesheet
(
Some
(
&
self
.
device
)
sheet
guard
)
}
pub
fn
any_applicable_rule_data
<
E
F
>
(
&
self
element
:
E
mut
f
:
F
)
-
>
bool
where
E
:
TElement
F
:
FnMut
(
&
CascadeData
)
-
>
bool
{
if
f
(
&
self
.
cascade_data
.
user_agent
.
cascade_data
)
{
return
true
;
}
let
mut
maybe
=
false
;
let
doc_author_rules_apply
=
element
.
each_applicable_non_document_style_rule_data
(
|
data
_
_
|
{
maybe
=
maybe
|
|
f
(
&
*
data
)
;
}
)
;
if
maybe
|
|
f
(
&
self
.
cascade_data
.
user
)
{
return
true
;
}
doc_author_rules_apply
&
&
f
(
&
self
.
cascade_data
.
author
)
}
pub
fn
precomputed_values_for_pseudo
<
E
>
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent
:
Option
<
&
ComputedValues
>
font_metrics
:
&
FontMetricsProvider
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
debug_assert
!
(
pseudo
.
is_precomputed
(
)
)
;
let
rule_node
=
self
.
rule_node_for_precomputed_pseudo
(
guards
pseudo
None
)
;
self
.
precomputed_values_for_pseudo_with_rule_node
:
:
<
E
>
(
guards
pseudo
parent
font_metrics
rule_node
)
}
pub
fn
precomputed_values_for_pseudo_with_rule_node
<
E
>
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent
:
Option
<
&
ComputedValues
>
font_metrics
:
&
FontMetricsProvider
rules
:
StrongRuleNode
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
self
.
compute_pseudo_element_style_with_inputs
:
:
<
E
>
(
CascadeInputs
{
rules
:
Some
(
rules
)
visited_rules
:
None
}
pseudo
guards
parent
font_metrics
None
)
}
pub
fn
rule_node_for_precomputed_pseudo
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
extra_declarations
:
Option
<
Vec
<
ApplicableDeclarationBlock
>
>
)
-
>
StrongRuleNode
{
let
mut
decl
;
let
declarations
=
match
self
.
cascade_data
.
user_agent
.
precomputed_pseudo_element_decls
.
get
(
pseudo
)
{
Some
(
declarations
)
=
>
match
extra_declarations
{
Some
(
mut
extra_decls
)
=
>
{
decl
=
declarations
.
clone
(
)
;
decl
.
append
(
&
mut
extra_decls
)
;
Some
(
&
decl
)
}
None
=
>
Some
(
declarations
)
}
None
=
>
extra_declarations
.
as_ref
(
)
}
;
match
declarations
{
Some
(
decls
)
=
>
self
.
rule_tree
.
insert_ordered_rules_with_important
(
decls
.
into_iter
(
)
.
map
(
|
a
|
a
.
clone
(
)
.
for_rule_tree
(
)
)
guards
)
None
=
>
self
.
rule_tree
.
root
(
)
.
clone
(
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
style_for_anonymous
<
E
>
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent_style
:
&
ComputedValues
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
use
crate
:
:
font_metrics
:
:
ServoMetricsProvider
;
self
.
precomputed_values_for_pseudo
:
:
<
E
>
(
guards
&
pseudo
Some
(
parent_style
)
&
ServoMetricsProvider
)
}
pub
fn
lazily_compute_pseudo_element_style
<
E
>
(
&
self
guards
:
&
StylesheetGuards
element
:
E
pseudo
:
&
PseudoElement
rule_inclusion
:
RuleInclusion
parent_style
:
&
ComputedValues
is_probe
:
bool
font_metrics
:
&
FontMetricsProvider
matching_fn
:
Option
<
&
Fn
(
&
PseudoElement
)
-
>
bool
>
)
-
>
Option
<
Arc
<
ComputedValues
>
>
where
E
:
TElement
{
let
cascade_inputs
=
self
.
lazy_pseudo_rules
(
guards
element
parent_style
pseudo
is_probe
rule_inclusion
matching_fn
)
?
;
Some
(
self
.
compute_pseudo_element_style_with_inputs
(
cascade_inputs
pseudo
guards
Some
(
parent_style
)
font_metrics
Some
(
element
)
)
)
}
pub
fn
compute_pseudo_element_style_with_inputs
<
E
>
(
&
self
inputs
:
CascadeInputs
pseudo
:
&
PseudoElement
guards
:
&
StylesheetGuards
parent_style
:
Option
<
&
ComputedValues
>
font_metrics
:
&
FontMetricsProvider
element
:
Option
<
E
>
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
self
.
cascade_style_and_visited
(
element
Some
(
pseudo
)
inputs
guards
parent_style
parent_style
parent_style
font_metrics
None
&
mut
RuleCacheConditions
:
:
default
(
)
)
}
pub
fn
cascade_style_and_visited
<
E
>
(
&
self
element
:
Option
<
E
>
pseudo
:
Option
<
&
PseudoElement
>
inputs
:
CascadeInputs
guards
:
&
StylesheetGuards
parent_style
:
Option
<
&
ComputedValues
>
parent_style_ignoring_first_line
:
Option
<
&
ComputedValues
>
layout_parent_style
:
Option
<
&
ComputedValues
>
font_metrics
:
&
FontMetricsProvider
rule_cache
:
Option
<
&
RuleCache
>
rule_cache_conditions
:
&
mut
RuleCacheConditions
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
debug_assert
!
(
pseudo
.
is_some
(
)
|
|
element
.
is_some
(
)
"
Huh
?
"
)
;
let
visited_rules
=
match
inputs
.
visited_rules
.
as_ref
(
)
{
Some
(
rules
)
=
>
Some
(
rules
)
None
=
>
{
if
parent_style
.
and_then
(
|
s
|
s
.
visited_style
(
)
)
.
is_some
(
)
{
Some
(
inputs
.
rules
.
as_ref
(
)
.
unwrap_or
(
self
.
rule_tree
.
root
(
)
)
)
}
else
{
None
}
}
}
;
properties
:
:
cascade
:
:
<
E
>
(
&
self
.
device
pseudo
inputs
.
rules
.
as_ref
(
)
.
unwrap_or
(
self
.
rule_tree
.
root
(
)
)
guards
parent_style
parent_style_ignoring_first_line
layout_parent_style
visited_rules
font_metrics
self
.
quirks_mode
rule_cache
rule_cache_conditions
element
)
}
fn
lazy_pseudo_rules
<
E
>
(
&
self
guards
:
&
StylesheetGuards
element
:
E
parent_style
:
&
ComputedValues
pseudo
:
&
PseudoElement
is_probe
:
bool
rule_inclusion
:
RuleInclusion
matching_fn
:
Option
<
&
Fn
(
&
PseudoElement
)
-
>
bool
>
)
-
>
Option
<
CascadeInputs
>
where
E
:
TElement
{
debug_assert
!
(
pseudo
.
is_lazy
(
)
)
;
let
mut
set_selector_flags
=
|
element
:
&
E
flags
:
ElementSelectorFlags
|
{
if
cfg
!
(
feature
=
"
servo
"
)
{
unreachable
!
(
"
internal
pseudo
generated
slow
selector
flags
?
"
)
;
}
if
rule_inclusion
=
=
RuleInclusion
:
:
DefaultOnly
{
return
;
}
debug_assert_eq
!
(
thread_state
:
:
get
(
)
ThreadState
:
:
LAYOUT
)
;
let
self_flags
=
flags
.
for_self
(
)
;
if
!
self_flags
.
is_empty
(
)
{
unsafe
{
element
.
set_selector_flags
(
self_flags
)
;
}
}
let
parent_flags
=
flags
.
for_parent
(
)
;
if
!
parent_flags
.
is_empty
(
)
{
if
let
Some
(
p
)
=
element
.
parent_element
(
)
{
unsafe
{
p
.
set_selector_flags
(
parent_flags
)
;
}
}
}
}
;
let
mut
declarations
=
ApplicableDeclarationList
:
:
new
(
)
;
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
ForStatelessPseudoElement
None
None
self
.
quirks_mode
)
;
matching_context
.
pseudo_element_matching_fn
=
matching_fn
;
self
.
push_applicable_declarations
(
element
Some
(
&
pseudo
)
None
None
AnimationRules
(
None
None
)
rule_inclusion
&
mut
declarations
&
mut
matching_context
&
mut
set_selector_flags
)
;
if
declarations
.
is_empty
(
)
&
&
is_probe
{
return
None
;
}
let
rules
=
self
.
rule_tree
.
compute_rule_node
(
&
mut
declarations
guards
)
;
let
mut
visited_rules
=
None
;
if
parent_style
.
visited_style
(
)
.
is_some
(
)
{
let
mut
declarations
=
ApplicableDeclarationList
:
:
new
(
)
;
let
mut
matching_context
=
MatchingContext
:
:
new_for_visited
(
MatchingMode
:
:
ForStatelessPseudoElement
None
None
VisitedHandlingMode
:
:
RelevantLinkVisited
self
.
quirks_mode
)
;
matching_context
.
pseudo_element_matching_fn
=
matching_fn
;
self
.
push_applicable_declarations
(
element
Some
(
&
pseudo
)
None
None
AnimationRules
(
None
None
)
rule_inclusion
&
mut
declarations
&
mut
matching_context
&
mut
set_selector_flags
)
;
if
!
declarations
.
is_empty
(
)
{
let
rule_node
=
self
.
rule_tree
.
insert_ordered_rules_with_important
(
declarations
.
drain
(
)
.
map
(
|
a
|
a
.
for_rule_tree
(
)
)
guards
)
;
if
rule_node
!
=
*
self
.
rule_tree
.
root
(
)
{
visited_rules
=
Some
(
rule_node
)
;
}
}
}
Some
(
CascadeInputs
{
rules
:
Some
(
rules
)
visited_rules
}
)
}
pub
fn
set_device
(
&
mut
self
mut
device
:
Device
guards
:
&
StylesheetGuards
)
-
>
OriginSet
{
if
viewport_rule
:
:
enabled
(
)
{
let
cascaded_rule
=
{
let
stylesheets
=
self
.
stylesheets
.
iter
(
)
;
ViewportRule
{
declarations
:
viewport_rule
:
:
Cascade
:
:
from_stylesheets
(
stylesheets
.
clone
(
)
guards
&
device
)
.
finish
(
)
}
}
;
self
.
viewport_constraints
=
ViewportConstraints
:
:
maybe_new
(
&
device
&
cascaded_rule
self
.
quirks_mode
)
;
if
let
Some
(
ref
constraints
)
=
self
.
viewport_constraints
{
device
.
account_for_viewport_rule
(
constraints
)
;
}
}
self
.
device
=
device
;
self
.
media_features_change_changed_style
(
guards
&
self
.
device
)
}
pub
fn
media_features_change_changed_style
(
&
self
guards
:
&
StylesheetGuards
device
:
&
Device
)
-
>
OriginSet
{
debug
!
(
"
Stylist
:
:
media_features_change_changed_style
{
:
?
}
"
device
)
;
let
mut
origins
=
OriginSet
:
:
empty
(
)
;
let
stylesheets
=
self
.
stylesheets
.
iter
(
)
;
for
(
stylesheet
origin
)
in
stylesheets
{
if
origins
.
contains
(
origin
.
into
(
)
)
{
continue
;
}
let
guard
=
guards
.
for_origin
(
origin
)
;
let
origin_cascade_data
=
self
.
cascade_data
.
borrow_for_origin
(
origin
)
;
let
affected_changed
=
!
origin_cascade_data
.
media_feature_affected_matches
(
stylesheet
guard
device
self
.
quirks_mode
)
;
if
affected_changed
{
origins
|
=
origin
;
}
}
origins
}
pub
fn
viewport_constraints
(
&
self
)
-
>
Option
<
&
ViewportConstraints
>
{
self
.
viewport_constraints
.
as_ref
(
)
}
pub
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
{
self
.
quirks_mode
}
pub
fn
set_quirks_mode
(
&
mut
self
quirks_mode
:
QuirksMode
)
{
if
self
.
quirks_mode
=
=
quirks_mode
{
return
;
}
self
.
quirks_mode
=
quirks_mode
;
self
.
force_stylesheet_origins_dirty
(
OriginSet
:
:
all
(
)
)
;
}
pub
fn
push_applicable_declarations
<
E
F
>
(
&
self
element
:
E
pseudo_element
:
Option
<
&
PseudoElement
>
style_attribute
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
smil_override
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
animation_rules
:
AnimationRules
rule_inclusion
:
RuleInclusion
applicable_declarations
:
&
mut
ApplicableDeclarationList
context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
flags_setter
:
&
mut
F
)
where
E
:
TElement
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
RuleCollector
:
:
new
(
self
element
pseudo_element
style_attribute
smil_override
animation_rules
rule_inclusion
applicable_declarations
context
flags_setter
)
.
collect_all
(
)
;
}
#
[
inline
]
pub
fn
may_have_rules_for_id
<
E
>
(
&
self
id
:
&
WeakAtom
element
:
E
)
-
>
bool
where
E
:
TElement
{
match
self
.
quirks_mode
(
)
.
classes_and_ids_case_sensitivity
(
)
{
CaseSensitivity
:
:
AsciiCaseInsensitive
=
>
return
true
CaseSensitivity
:
:
CaseSensitive
=
>
{
}
}
self
.
any_applicable_rule_data
(
element
|
data
|
data
.
mapped_ids
.
contains
(
id
)
)
}
#
[
inline
]
pub
fn
get_animation
<
'
a
E
>
(
&
'
a
self
name
:
&
Atom
element
:
E
)
-
>
Option
<
&
'
a
KeyframesAnimation
>
where
E
:
TElement
+
'
a
{
macro_rules
!
try_find_in
{
(
data
:
expr
)
=
>
{
if
let
Some
(
animation
)
=
data
.
animations
.
get
(
name
)
{
return
Some
(
animation
)
;
}
}
;
}
if
let
Some
(
shadow
)
=
element
.
shadow_root
(
)
{
if
let
Some
(
data
)
=
shadow
.
style_data
(
)
{
try_find_in
!
(
data
)
;
}
}
if
let
Some
(
shadow
)
=
element
.
containing_shadow
(
)
{
if
let
Some
(
data
)
=
shadow
.
style_data
(
)
{
try_find_in
!
(
data
)
;
}
}
else
{
try_find_in
!
(
self
.
cascade_data
.
author
)
;
}
try_find_in
!
(
self
.
cascade_data
.
user
)
;
try_find_in
!
(
self
.
cascade_data
.
user_agent
.
cascade_data
)
;
None
}
pub
fn
match_revalidation_selectors
<
E
F
>
(
&
self
element
:
E
bloom
:
Option
<
&
BloomFilter
>
nth_index_cache
:
&
mut
NthIndexCache
flags_setter
:
&
mut
F
)
-
>
SmallBitVec
where
E
:
TElement
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
Normal
bloom
Some
(
nth_index_cache
)
self
.
quirks_mode
)
;
let
mut
results
=
SmallBitVec
:
:
new
(
)
;
let
matches_document_rules
=
element
.
each_applicable_non_document_style_rule_data
(
|
data
quirks_mode
host
|
{
matching_context
.
with_shadow_host
(
host
|
matching_context
|
{
data
.
selectors_for_cache_revalidation
.
lookup
(
element
quirks_mode
|
selector_and_hashes
|
{
results
.
push
(
matches_selector
(
&
selector_and_hashes
.
selector
selector_and_hashes
.
selector_offset
Some
(
&
selector_and_hashes
.
hashes
)
&
element
matching_context
flags_setter
)
)
;
true
}
)
;
}
)
}
)
;
for
(
data
origin
)
in
self
.
cascade_data
.
iter_origins
(
)
{
if
origin
=
=
Origin
:
:
Author
&
&
!
matches_document_rules
{
continue
;
}
data
.
selectors_for_cache_revalidation
.
lookup
(
element
self
.
quirks_mode
|
selector_and_hashes
|
{
results
.
push
(
matches_selector
(
&
selector_and_hashes
.
selector
selector_and_hashes
.
selector_offset
Some
(
&
selector_and_hashes
.
hashes
)
&
element
&
mut
matching_context
flags_setter
)
)
;
true
}
)
;
}
results
}
pub
fn
compute_for_declarations
<
E
>
(
&
self
guards
:
&
StylesheetGuards
parent_style
:
&
ComputedValues
declarations
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
use
crate
:
:
font_metrics
:
:
get_metrics_provider_for_product
;
let
block
=
declarations
.
read_with
(
guards
.
author
)
;
let
iter_declarations
=
|
|
{
block
.
declaration_importance_iter
(
)
.
map
(
|
(
declaration
importance
)
|
{
debug_assert
!
(
!
importance
.
important
(
)
)
;
(
declaration
CascadeLevel
:
:
StyleAttributeNormal
)
}
)
}
;
let
metrics
=
get_metrics_provider_for_product
(
)
;
properties
:
:
apply_declarations
:
:
<
E
_
_
>
(
&
self
.
device
None
self
.
rule_tree
.
root
(
)
guards
iter_declarations
Some
(
parent_style
)
Some
(
parent_style
)
Some
(
parent_style
)
&
metrics
CascadeMode
:
:
Unvisited
{
visited_rules
:
None
}
self
.
quirks_mode
None
&
mut
Default
:
:
default
(
)
None
)
}
#
[
inline
]
pub
fn
device
(
&
self
)
-
>
&
Device
{
&
self
.
device
}
#
[
inline
]
pub
fn
device_mut
(
&
mut
self
)
-
>
&
mut
Device
{
&
mut
self
.
device
}
#
[
inline
]
pub
fn
rule_tree
(
&
self
)
-
>
&
RuleTree
{
&
self
.
rule_tree
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
cascade_data
.
add_size_of
(
ops
sizes
)
;
sizes
.
mRuleTree
+
=
self
.
rule_tree
.
size_of
(
ops
)
;
}
pub
fn
shutdown
(
)
{
UA_CASCADE_DATA_CACHE
.
lock
(
)
.
unwrap
(
)
.
clear
(
)
}
}
#
[
derive
(
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
pub
struct
ExtraStyleData
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
font_faces
:
Vec
<
Arc
<
Locked
<
FontFaceRule
>
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
font_feature_values
:
Vec
<
Arc
<
Locked
<
FontFeatureValuesRule
>
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
counter_styles
:
PrecomputedHashMap
<
Atom
Arc
<
Locked
<
CounterStyleRule
>
>
>
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
pages
:
Vec
<
Arc
<
Locked
<
PageRule
>
>
>
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
unsafe
impl
Sync
for
ExtraStyleData
{
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
unsafe
impl
Send
for
ExtraStyleData
{
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ExtraStyleData
{
fn
add_font_face
(
&
mut
self
rule
:
&
Arc
<
Locked
<
FontFaceRule
>
>
)
{
self
.
font_faces
.
push
(
rule
.
clone
(
)
)
;
}
fn
add_font_feature_values
(
&
mut
self
rule
:
&
Arc
<
Locked
<
FontFeatureValuesRule
>
>
)
{
self
.
font_feature_values
.
push
(
rule
.
clone
(
)
)
;
}
fn
add_counter_style
(
&
mut
self
guard
:
&
SharedRwLockReadGuard
rule
:
&
Arc
<
Locked
<
CounterStyleRule
>
>
)
{
let
name
=
rule
.
read_with
(
guard
)
.
name
(
)
.
0
.
clone
(
)
;
self
.
counter_styles
.
insert
(
name
rule
.
clone
(
)
)
;
}
fn
add_page
(
&
mut
self
rule
:
&
Arc
<
Locked
<
PageRule
>
>
)
{
self
.
pages
.
push
(
rule
.
clone
(
)
)
;
}
}
impl
ExtraStyleData
{
fn
clear
(
&
mut
self
)
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
self
.
font_faces
.
clear
(
)
;
self
.
font_feature_values
.
clear
(
)
;
self
.
counter_styles
.
clear
(
)
;
self
.
pages
.
clear
(
)
;
}
}
}
pub
struct
ExtraStyleDataIterator
<
'
a
>
(
DocumentCascadeDataIter
<
'
a
>
)
;
impl
<
'
a
>
Iterator
for
ExtraStyleDataIterator
<
'
a
>
{
type
Item
=
(
&
'
a
ExtraStyleData
Origin
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
0
.
next
(
)
.
map
(
|
d
|
(
&
d
.
0
.
extra_data
d
.
1
)
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
MallocSizeOf
for
ExtraStyleData
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
0
;
n
+
=
self
.
font_faces
.
shallow_size_of
(
ops
)
;
n
+
=
self
.
font_feature_values
.
shallow_size_of
(
ops
)
;
n
+
=
self
.
counter_styles
.
shallow_size_of
(
ops
)
;
n
+
=
self
.
pages
.
shallow_size_of
(
ops
)
;
n
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
Debug
)
]
struct
RevalidationSelectorAndHashes
{
#
[
cfg_attr
(
feature
=
"
gecko
"
ignore_malloc_size_of
=
"
CssRules
have
primary
refs
we
measure
there
"
)
]
selector
:
Selector
<
SelectorImpl
>
selector_offset
:
usize
hashes
:
AncestorHashes
}
impl
RevalidationSelectorAndHashes
{
fn
new
(
selector
:
Selector
<
SelectorImpl
>
hashes
:
AncestorHashes
)
-
>
Self
{
let
selector_offset
=
{
let
mut
index
=
0
;
let
mut
iter
=
selector
.
iter
(
)
;
for
_
in
&
mut
iter
{
index
+
=
1
;
}
match
iter
.
next_sequence
(
)
{
Some
(
Combinator
:
:
PseudoElement
)
=
>
index
+
1
_
=
>
0
}
}
;
RevalidationSelectorAndHashes
{
selector
selector_offset
hashes
}
}
}
impl
SelectorMapEntry
for
RevalidationSelectorAndHashes
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter_from
(
self
.
selector_offset
)
}
}
struct
StylistSelectorVisitor
<
'
a
>
{
needs_revalidation
:
bool
passed_rightmost_selector
:
bool
mapped_ids
:
&
'
a
mut
PrecomputedHashSet
<
Atom
>
attribute_dependencies
:
&
'
a
mut
PrecomputedHashSet
<
LocalName
>
state_dependencies
:
&
'
a
mut
ElementState
document_state_dependencies
:
&
'
a
mut
DocumentState
}
fn
component_needs_revalidation
(
c
:
&
Component
<
SelectorImpl
>
passed_rightmost_selector
:
bool
)
-
>
bool
{
match
*
c
{
Component
:
:
ID
(
_
)
=
>
{
passed_rightmost_selector
}
Component
:
:
AttributeInNoNamespaceExists
{
.
.
}
|
Component
:
:
AttributeInNoNamespace
{
.
.
}
|
Component
:
:
AttributeOther
(
_
)
|
Component
:
:
Empty
|
Component
:
:
FirstChild
|
Component
:
:
LastChild
|
Component
:
:
OnlyChild
|
Component
:
:
NthChild
(
.
.
)
|
Component
:
:
NthLastChild
(
.
.
)
|
Component
:
:
NthOfType
(
.
.
)
|
Component
:
:
NthLastOfType
(
.
.
)
|
Component
:
:
FirstOfType
|
Component
:
:
LastOfType
|
Component
:
:
OnlyOfType
=
>
true
Component
:
:
NonTSPseudoClass
(
ref
p
)
=
>
p
.
needs_cache_revalidation
(
)
_
=
>
false
}
}
impl
<
'
a
>
SelectorVisitor
for
StylistSelectorVisitor
<
'
a
>
{
type
Impl
=
SelectorImpl
;
fn
visit_complex_selector
(
&
mut
self
combinator
:
Option
<
Combinator
>
)
-
>
bool
{
self
.
needs_revalidation
=
self
.
needs_revalidation
|
|
combinator
.
map_or
(
false
|
c
|
c
.
is_sibling
(
)
)
;
self
.
passed_rightmost_selector
=
self
.
passed_rightmost_selector
|
|
!
matches
!
(
combinator
None
|
Some
(
Combinator
:
:
PseudoElement
)
)
;
true
}
fn
visit_attribute_selector
(
&
mut
self
_ns
:
&
NamespaceConstraint
<
&
Namespace
>
name
:
&
LocalName
lower_name
:
&
LocalName
)
-
>
bool
{
self
.
attribute_dependencies
.
insert
(
name
.
clone
(
)
)
;
self
.
attribute_dependencies
.
insert
(
lower_name
.
clone
(
)
)
;
true
}
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
self
.
needs_revalidation
=
self
.
needs_revalidation
|
|
component_needs_revalidation
(
s
self
.
passed_rightmost_selector
)
;
match
*
s
{
Component
:
:
NonTSPseudoClass
(
ref
p
)
=
>
{
self
.
state_dependencies
.
insert
(
p
.
state_flag
(
)
)
;
self
.
document_state_dependencies
.
insert
(
p
.
document_state_flag
(
)
)
;
}
Component
:
:
ID
(
ref
id
)
if
!
self
.
passed_rightmost_selector
=
>
{
self
.
mapped_ids
.
insert
(
id
.
clone
(
)
)
;
}
_
=
>
{
}
}
true
}
}
#
[
derive
(
Debug
Default
MallocSizeOf
)
]
struct
ElementAndPseudoRules
{
element_map
:
SelectorMap
<
Rule
>
pseudos_map
:
PerPseudoElementMap
<
Box
<
SelectorMap
<
Rule
>
>
>
}
impl
ElementAndPseudoRules
{
#
[
inline
(
always
)
]
fn
insert
(
&
mut
self
rule
:
Rule
pseudo_element
:
Option
<
&
PseudoElement
>
quirks_mode
:
QuirksMode
)
-
>
Result
<
(
)
FailedAllocationError
>
{
debug_assert
!
(
pseudo_element
.
map_or
(
true
|
pseudo
|
!
pseudo
.
is_precomputed
(
)
&
&
!
pseudo
.
is_unknown_webkit_pseudo_element
(
)
)
)
;
let
map
=
match
pseudo_element
{
None
=
>
&
mut
self
.
element_map
Some
(
pseudo
)
=
>
self
.
pseudos_map
.
get_or_insert_with
(
pseudo
|
|
Box
:
:
new
(
SelectorMap
:
:
new
(
)
)
)
}
;
map
.
insert
(
rule
quirks_mode
)
}
fn
clear
(
&
mut
self
)
{
self
.
element_map
.
clear
(
)
;
self
.
pseudos_map
.
clear
(
)
;
}
#
[
inline
]
fn
rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
SelectorMap
<
Rule
>
>
{
match
pseudo
{
Some
(
pseudo
)
=
>
self
.
pseudos_map
.
get
(
pseudo
)
.
map
(
|
p
|
&
*
*
p
)
None
=
>
Some
(
&
self
.
element_map
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
sizes
.
mElementAndPseudosMaps
+
=
self
.
element_map
.
size_of
(
ops
)
;
for
elem
in
self
.
pseudos_map
.
iter
(
)
{
if
let
Some
(
ref
elem
)
=
*
elem
{
sizes
.
mElementAndPseudosMaps
+
=
<
Box
<
_
>
as
MallocSizeOf
>
:
:
size_of
(
elem
ops
)
;
}
}
}
}
#
[
derive
(
Debug
MallocSizeOf
)
]
pub
struct
CascadeData
{
normal_rules
:
ElementAndPseudoRules
host_rules
:
Option
<
Box
<
ElementAndPseudoRules
>
>
slotted_rules
:
Option
<
Box
<
ElementAndPseudoRules
>
>
invalidation_map
:
InvalidationMap
attribute_dependencies
:
PrecomputedHashSet
<
LocalName
>
state_dependencies
:
ElementState
document_state_dependencies
:
DocumentState
mapped_ids
:
PrecomputedHashSet
<
Atom
>
#
[
ignore_malloc_size_of
=
"
Arc
"
]
selectors_for_cache_revalidation
:
SelectorMap
<
RevalidationSelectorAndHashes
>
animations
:
PrecomputedHashMap
<
Atom
KeyframesAnimation
>
effective_media_query_results
:
EffectiveMediaQueryResults
extra_data
:
ExtraStyleData
rules_source_order
:
u32
num_selectors
:
usize
num_declarations
:
usize
}
impl
CascadeData
{
pub
fn
new
(
)
-
>
Self
{
Self
{
normal_rules
:
ElementAndPseudoRules
:
:
default
(
)
host_rules
:
None
slotted_rules
:
None
invalidation_map
:
InvalidationMap
:
:
new
(
)
attribute_dependencies
:
PrecomputedHashSet
:
:
default
(
)
state_dependencies
:
ElementState
:
:
empty
(
)
document_state_dependencies
:
DocumentState
:
:
empty
(
)
mapped_ids
:
PrecomputedHashSet
:
:
default
(
)
selectors_for_cache_revalidation
:
SelectorMap
:
:
new
(
)
animations
:
Default
:
:
default
(
)
extra_data
:
ExtraStyleData
:
:
default
(
)
effective_media_query_results
:
EffectiveMediaQueryResults
:
:
new
(
)
rules_source_order
:
0
num_selectors
:
0
num_declarations
:
0
}
}
pub
fn
rebuild
<
'
a
S
>
(
&
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
collection
:
SheetCollectionFlusher
<
S
>
guard
:
&
SharedRwLockReadGuard
)
-
>
Result
<
(
)
FailedAllocationError
>
where
S
:
StylesheetInDocument
+
ToMediaListKey
+
PartialEq
+
'
static
{
if
!
collection
.
dirty
(
)
{
return
Ok
(
(
)
)
;
}
let
validity
=
collection
.
data_validity
(
)
;
match
validity
{
DataValidity
:
:
Valid
=
>
{
}
DataValidity
:
:
CascadeInvalid
=
>
self
.
clear_cascade_data
(
)
DataValidity
:
:
FullyInvalid
=
>
self
.
clear
(
)
}
for
(
stylesheet
rebuild_kind
)
in
collection
{
self
.
add_stylesheet
(
device
quirks_mode
stylesheet
guard
rebuild_kind
None
)
?
;
}
Ok
(
(
)
)
}
pub
fn
invalidation_map
(
&
self
)
-
>
&
InvalidationMap
{
&
self
.
invalidation_map
}
#
[
inline
]
pub
fn
has_state_dependency
(
&
self
state
:
ElementState
)
-
>
bool
{
self
.
state_dependencies
.
intersects
(
state
)
}
#
[
inline
]
pub
fn
might_have_attribute_dependency
(
&
self
local_name
:
&
LocalName
)
-
>
bool
{
self
.
attribute_dependencies
.
contains
(
local_name
)
}
#
[
inline
]
pub
fn
normal_rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
SelectorMap
<
Rule
>
>
{
self
.
normal_rules
.
rules
(
pseudo
)
}
#
[
inline
]
pub
fn
host_rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
SelectorMap
<
Rule
>
>
{
self
.
host_rules
.
as_ref
(
)
.
and_then
(
|
d
|
d
.
rules
(
pseudo
)
)
}
#
[
inline
]
pub
fn
slotted_rules
(
&
self
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
SelectorMap
<
Rule
>
>
{
self
.
slotted_rules
.
as_ref
(
)
.
and_then
(
|
d
|
d
.
rules
(
pseudo
)
)
}
fn
collect_applicable_media_query_results_into
<
S
>
(
device
:
&
Device
stylesheet
:
&
S
guard
:
&
SharedRwLockReadGuard
results
:
&
mut
EffectiveMediaQueryResults
)
where
S
:
StylesheetInDocument
+
ToMediaListKey
+
'
static
{
if
!
stylesheet
.
enabled
(
)
|
|
!
stylesheet
.
is_effective_for_device
(
device
guard
)
{
return
;
}
debug
!
(
"
+
{
:
?
}
"
stylesheet
)
;
results
.
saw_effective
(
stylesheet
)
;
for
rule
in
stylesheet
.
effective_rules
(
device
guard
)
{
match
*
rule
{
CssRule
:
:
Import
(
ref
lock
)
=
>
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
debug
!
(
"
+
{
:
?
}
"
import_rule
.
stylesheet
.
media
(
guard
)
)
;
results
.
saw_effective
(
import_rule
)
;
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
let
media_rule
=
lock
.
read_with
(
guard
)
;
debug
!
(
"
+
{
:
?
}
"
media_rule
.
media_queries
.
read_with
(
guard
)
)
;
results
.
saw_effective
(
media_rule
)
;
}
_
=
>
{
}
}
}
}
fn
add_stylesheet
<
S
>
(
&
mut
self
device
:
&
Device
quirks_mode
:
QuirksMode
stylesheet
:
&
S
guard
:
&
SharedRwLockReadGuard
rebuild_kind
:
SheetRebuildKind
mut
precomputed_pseudo_element_decls
:
Option
<
&
mut
PrecomputedPseudoElementDeclarations
>
)
-
>
Result
<
(
)
FailedAllocationError
>
where
S
:
StylesheetInDocument
+
ToMediaListKey
+
'
static
{
if
!
stylesheet
.
enabled
(
)
|
|
!
stylesheet
.
is_effective_for_device
(
device
guard
)
{
return
Ok
(
(
)
)
;
}
let
origin
=
stylesheet
.
origin
(
guard
)
;
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
self
.
effective_media_query_results
.
saw_effective
(
stylesheet
)
;
}
for
rule
in
stylesheet
.
effective_rules
(
device
guard
)
{
match
*
rule
{
CssRule
:
:
Style
(
ref
locked
)
=
>
{
let
style_rule
=
locked
.
read_with
(
&
guard
)
;
self
.
num_declarations
+
=
style_rule
.
block
.
read_with
(
&
guard
)
.
len
(
)
;
for
selector
in
&
style_rule
.
selectors
.
0
{
self
.
num_selectors
+
=
1
;
let
pseudo_element
=
selector
.
pseudo_element
(
)
;
if
let
Some
(
pseudo
)
=
pseudo_element
{
if
pseudo
.
is_precomputed
(
)
{
debug_assert
!
(
selector
.
is_universal
(
)
)
;
debug_assert
!
(
matches
!
(
origin
Origin
:
:
UserAgent
)
)
;
precomputed_pseudo_element_decls
.
as_mut
(
)
.
expect
(
"
Expected
precomputed
declarations
for
the
UA
level
"
)
.
get_or_insert_with
(
pseudo
Vec
:
:
new
)
.
push
(
ApplicableDeclarationBlock
:
:
new
(
StyleSource
:
:
from_rule
(
locked
.
clone
(
)
)
self
.
rules_source_order
CascadeLevel
:
:
UANormal
selector
.
specificity
(
)
0
)
)
;
continue
;
}
if
pseudo
.
is_unknown_webkit_pseudo_element
(
)
{
continue
;
}
}
let
hashes
=
AncestorHashes
:
:
new
(
&
selector
quirks_mode
)
;
let
rule
=
Rule
:
:
new
(
selector
.
clone
(
)
hashes
locked
.
clone
(
)
self
.
rules_source_order
)
;
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
self
.
invalidation_map
.
note_selector
(
selector
quirks_mode
)
?
;
let
mut
visitor
=
StylistSelectorVisitor
{
needs_revalidation
:
false
passed_rightmost_selector
:
false
attribute_dependencies
:
&
mut
self
.
attribute_dependencies
state_dependencies
:
&
mut
self
.
state_dependencies
document_state_dependencies
:
&
mut
self
.
document_state_dependencies
mapped_ids
:
&
mut
self
.
mapped_ids
}
;
rule
.
selector
.
visit
(
&
mut
visitor
)
;
if
visitor
.
needs_revalidation
{
self
.
selectors_for_cache_revalidation
.
insert
(
RevalidationSelectorAndHashes
:
:
new
(
rule
.
selector
.
clone
(
)
rule
.
hashes
.
clone
(
)
)
quirks_mode
)
?
;
}
}
let
rules
=
if
selector
.
is_featureless_host_selector_or_pseudo_element
(
)
{
self
.
host_rules
.
get_or_insert_with
(
|
|
Box
:
:
new
(
Default
:
:
default
(
)
)
)
}
else
if
selector
.
is_slotted
(
)
{
self
.
slotted_rules
.
get_or_insert_with
(
|
|
Box
:
:
new
(
Default
:
:
default
(
)
)
)
}
else
{
&
mut
self
.
normal_rules
}
;
rules
.
insert
(
rule
pseudo_element
quirks_mode
)
?
;
}
self
.
rules_source_order
+
=
1
;
}
CssRule
:
:
Import
(
ref
lock
)
=
>
{
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
self
.
effective_media_query_results
.
saw_effective
(
import_rule
)
;
}
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
if
rebuild_kind
.
should_rebuild_invalidation
(
)
{
let
media_rule
=
lock
.
read_with
(
guard
)
;
self
.
effective_media_query_results
.
saw_effective
(
media_rule
)
;
}
}
CssRule
:
:
Keyframes
(
ref
keyframes_rule
)
=
>
{
let
keyframes_rule
=
keyframes_rule
.
read_with
(
guard
)
;
debug
!
(
"
Found
valid
keyframes
rule
:
{
:
?
}
"
*
keyframes_rule
)
;
let
needs_insertion
=
keyframes_rule
.
vendor_prefix
.
is_none
(
)
|
|
self
.
animations
.
get
(
keyframes_rule
.
name
.
as_atom
(
)
)
.
map_or
(
true
|
rule
|
rule
.
vendor_prefix
.
is_some
(
)
)
;
if
needs_insertion
{
let
animation
=
KeyframesAnimation
:
:
from_keyframes
(
&
keyframes_rule
.
keyframes
keyframes_rule
.
vendor_prefix
.
clone
(
)
guard
)
;
debug
!
(
"
Found
valid
keyframe
animation
:
{
:
?
}
"
animation
)
;
self
.
animations
.
try_insert
(
keyframes_rule
.
name
.
as_atom
(
)
.
clone
(
)
animation
)
?
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
FontFace
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_font_face
(
rule
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
FontFeatureValues
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_font_feature_values
(
rule
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
CounterStyle
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_counter_style
(
guard
rule
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
Page
(
ref
rule
)
=
>
{
self
.
extra_data
.
add_page
(
rule
)
;
}
_
=
>
{
}
}
}
Ok
(
(
)
)
}
pub
fn
media_feature_affected_matches
<
S
>
(
&
self
stylesheet
:
&
S
guard
:
&
SharedRwLockReadGuard
device
:
&
Device
quirks_mode
:
QuirksMode
)
-
>
bool
where
S
:
StylesheetInDocument
+
ToMediaListKey
+
'
static
{
use
crate
:
:
invalidation
:
:
media_queries
:
:
PotentiallyEffectiveMediaRules
;
let
effective_now
=
stylesheet
.
is_effective_for_device
(
device
guard
)
;
let
effective_then
=
self
.
effective_media_query_results
.
was_effective
(
stylesheet
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
Stylesheet
{
:
?
}
changed
-
>
{
}
{
}
"
stylesheet
.
media
(
guard
)
effective_then
effective_now
)
;
return
false
;
}
if
!
effective_now
{
return
true
;
}
let
mut
iter
=
stylesheet
.
iter_rules
:
:
<
PotentiallyEffectiveMediaRules
>
(
device
guard
)
;
while
let
Some
(
rule
)
=
iter
.
next
(
)
{
match
*
rule
{
CssRule
:
:
Style
(
.
.
)
|
CssRule
:
:
Namespace
(
.
.
)
|
CssRule
:
:
FontFace
(
.
.
)
|
CssRule
:
:
CounterStyle
(
.
.
)
|
CssRule
:
:
Supports
(
.
.
)
|
CssRule
:
:
Keyframes
(
.
.
)
|
CssRule
:
:
Page
(
.
.
)
|
CssRule
:
:
Viewport
(
.
.
)
|
CssRule
:
:
Document
(
.
.
)
|
CssRule
:
:
FontFeatureValues
(
.
.
)
=
>
{
continue
;
}
CssRule
:
:
Import
(
ref
lock
)
=
>
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
let
effective_now
=
import_rule
.
stylesheet
.
is_effective_for_device
(
&
device
guard
)
;
let
effective_then
=
self
.
effective_media_query_results
.
was_effective
(
import_rule
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
import
rule
{
:
?
}
changed
{
}
-
>
{
}
"
import_rule
.
stylesheet
.
media
(
guard
)
effective_then
effective_now
)
;
return
false
;
}
if
!
effective_now
{
iter
.
skip_children
(
)
;
}
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
let
media_rule
=
lock
.
read_with
(
guard
)
;
let
mq
=
media_rule
.
media_queries
.
read_with
(
guard
)
;
let
effective_now
=
mq
.
evaluate
(
device
quirks_mode
)
;
let
effective_then
=
self
.
effective_media_query_results
.
was_effective
(
media_rule
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
media
rule
{
:
?
}
changed
{
}
-
>
{
}
"
mq
effective_then
effective_now
)
;
return
false
;
}
if
!
effective_now
{
iter
.
skip_children
(
)
;
}
}
}
}
true
}
fn
clear_cascade_data
(
&
mut
self
)
{
self
.
normal_rules
.
clear
(
)
;
if
let
Some
(
ref
mut
slotted_rules
)
=
self
.
slotted_rules
{
slotted_rules
.
clear
(
)
;
}
if
let
Some
(
ref
mut
host_rules
)
=
self
.
host_rules
{
host_rules
.
clear
(
)
;
}
self
.
animations
.
clear
(
)
;
self
.
extra_data
.
clear
(
)
;
self
.
rules_source_order
=
0
;
self
.
num_selectors
=
0
;
self
.
num_declarations
=
0
;
}
fn
clear
(
&
mut
self
)
{
self
.
clear_cascade_data
(
)
;
self
.
invalidation_map
.
clear
(
)
;
self
.
attribute_dependencies
.
clear
(
)
;
self
.
state_dependencies
=
ElementState
:
:
empty
(
)
;
self
.
document_state_dependencies
=
DocumentState
:
:
empty
(
)
;
self
.
mapped_ids
.
clear
(
)
;
self
.
selectors_for_cache_revalidation
.
clear
(
)
;
self
.
effective_media_query_results
.
clear
(
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
add_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
sizes
:
&
mut
ServoStyleSetSizes
)
{
self
.
normal_rules
.
add_size_of
(
ops
sizes
)
;
if
let
Some
(
ref
slotted_rules
)
=
self
.
slotted_rules
{
slotted_rules
.
add_size_of
(
ops
sizes
)
;
}
if
let
Some
(
ref
host_rules
)
=
self
.
host_rules
{
host_rules
.
add_size_of
(
ops
sizes
)
;
}
sizes
.
mInvalidationMap
+
=
self
.
invalidation_map
.
size_of
(
ops
)
;
sizes
.
mRevalidationSelectors
+
=
self
.
selectors_for_cache_revalidation
.
size_of
(
ops
)
;
sizes
.
mOther
+
=
self
.
animations
.
size_of
(
ops
)
;
sizes
.
mOther
+
=
self
.
effective_media_query_results
.
size_of
(
ops
)
;
sizes
.
mOther
+
=
self
.
extra_data
.
size_of
(
ops
)
;
}
}
impl
Default
for
CascadeData
{
fn
default
(
)
-
>
Self
{
CascadeData
:
:
new
(
)
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
pub
struct
Rule
{
#
[
ignore_malloc_size_of
=
"
CssRules
have
primary
refs
we
measure
there
"
]
pub
selector
:
Selector
<
SelectorImpl
>
pub
hashes
:
AncestorHashes
pub
source_order
:
u32
#
[
cfg_attr
(
feature
=
"
gecko
"
ignore_malloc_size_of
=
"
Secondary
ref
.
Primary
ref
is
in
StyleRule
under
Stylesheet
.
"
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_malloc_size_of
=
"
Arc
"
)
]
pub
style_rule
:
Arc
<
Locked
<
StyleRule
>
>
}
impl
SelectorMapEntry
for
Rule
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter
(
)
}
}
impl
Rule
{
pub
fn
specificity
(
&
self
)
-
>
u32
{
self
.
selector
.
specificity
(
)
}
pub
fn
to_applicable_declaration_block
(
&
self
level
:
CascadeLevel
shadow_cascade_order
:
ShadowCascadeOrder
)
-
>
ApplicableDeclarationBlock
{
let
source
=
StyleSource
:
:
from_rule
(
self
.
style_rule
.
clone
(
)
)
;
ApplicableDeclarationBlock
:
:
new
(
source
self
.
source_order
level
self
.
specificity
(
)
shadow_cascade_order
)
}
pub
fn
new
(
selector
:
Selector
<
SelectorImpl
>
hashes
:
AncestorHashes
style_rule
:
Arc
<
Locked
<
StyleRule
>
>
source_order
:
u32
)
-
>
Self
{
Rule
{
selector
:
selector
hashes
:
hashes
style_rule
:
style_rule
source_order
:
source_order
}
}
}
pub
fn
needs_revalidation_for_testing
(
s
:
&
Selector
<
SelectorImpl
>
)
-
>
bool
{
let
mut
attribute_dependencies
=
Default
:
:
default
(
)
;
let
mut
mapped_ids
=
Default
:
:
default
(
)
;
let
mut
state_dependencies
=
ElementState
:
:
empty
(
)
;
let
mut
document_state_dependencies
=
DocumentState
:
:
empty
(
)
;
let
mut
visitor
=
StylistSelectorVisitor
{
needs_revalidation
:
false
passed_rightmost_selector
:
false
attribute_dependencies
:
&
mut
attribute_dependencies
state_dependencies
:
&
mut
state_dependencies
document_state_dependencies
:
&
mut
document_state_dependencies
mapped_ids
:
&
mut
mapped_ids
}
;
s
.
visit
(
&
mut
visitor
)
;
visitor
.
needs_revalidation
}
