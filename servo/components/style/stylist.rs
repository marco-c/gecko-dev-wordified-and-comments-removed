#
!
[
deny
(
missing_docs
)
]
use
{
Atom
LocalName
}
;
use
data
:
:
ComputedStyle
;
use
dom
:
:
{
AnimationRules
PresentationalHintsSynthetizer
TElement
}
;
use
error_reporting
:
:
StdoutErrorReporter
;
use
keyframes
:
:
KeyframesAnimation
;
use
media_queries
:
:
Device
;
use
parking_lot
:
:
RwLock
;
use
pdqsort
:
:
sort_by
;
use
properties
:
:
{
self
CascadeFlags
ComputedValues
INHERIT_ALL
}
;
use
properties
:
:
PropertyDeclarationBlock
;
use
restyle_hints
:
:
{
RestyleHint
DependencySet
}
;
use
rule_tree
:
:
{
CascadeLevel
RuleTree
StrongRuleNode
StyleSource
}
;
use
selector_parser
:
:
{
SelectorImpl
PseudoElement
Snapshot
}
;
use
selectors
:
:
Element
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
use
selectors
:
:
matching
:
:
{
AFFECTED_BY_ANIMATIONS
AFFECTED_BY_TRANSITIONS
}
;
use
selectors
:
:
matching
:
:
{
AFFECTED_BY_STYLE_ATTRIBUTE
AFFECTED_BY_PRESENTATIONAL_HINTS
}
;
use
selectors
:
:
matching
:
:
{
ElementSelectorFlags
StyleRelations
matches_complex_selector
}
;
use
selectors
:
:
parser
:
:
{
Selector
SimpleSelector
LocalName
as
LocalNameSelector
ComplexSelector
}
;
use
sink
:
:
Push
;
use
smallvec
:
:
VecLike
;
use
std
:
:
borrow
:
:
Borrow
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
fmt
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
sync
:
:
Arc
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
use
stylesheets
:
:
{
CssRule
Origin
StyleRule
Stylesheet
UserAgentStylesheets
}
;
use
thread_state
;
use
viewport
:
:
{
self
MaybeNew
ViewportRule
}
;
pub
use
:
:
fnv
:
:
FnvHashMap
;
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
Stylist
{
pub
device
:
Arc
<
Device
>
viewport_constraints
:
Option
<
ViewportConstraints
>
quirks_mode
:
bool
is_device_dirty
:
bool
element_map
:
PerPseudoElementSelectorMap
pub
rule_tree
:
RuleTree
pseudos_map
:
FnvHashMap
<
PseudoElement
PerPseudoElementSelectorMap
>
animations
:
FnvHashMap
<
Atom
KeyframesAnimation
>
precomputed_pseudo_element_decls
:
FnvHashMap
<
PseudoElement
Vec
<
ApplicableDeclarationBlock
>
>
rules_source_order
:
usize
state_deps
:
DependencySet
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
sibling_affecting_selectors
:
Vec
<
Selector
<
SelectorImpl
>
>
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
non_common_style_affecting_attributes_selectors
:
Vec
<
Selector
<
SelectorImpl
>
>
}
impl
Stylist
{
#
[
inline
]
pub
fn
new
(
device
:
Device
)
-
>
Self
{
let
mut
stylist
=
Stylist
{
viewport_constraints
:
None
device
:
Arc
:
:
new
(
device
)
is_device_dirty
:
true
quirks_mode
:
false
element_map
:
PerPseudoElementSelectorMap
:
:
new
(
)
pseudos_map
:
Default
:
:
default
(
)
animations
:
Default
:
:
default
(
)
precomputed_pseudo_element_decls
:
Default
:
:
default
(
)
rules_source_order
:
0
rule_tree
:
RuleTree
:
:
new
(
)
state_deps
:
DependencySet
:
:
new
(
)
sibling_affecting_selectors
:
vec
!
[
]
non_common_style_affecting_attributes_selectors
:
vec
!
[
]
}
;
SelectorImpl
:
:
each_eagerly_cascaded_pseudo_element
(
|
pseudo
|
{
stylist
.
pseudos_map
.
insert
(
pseudo
PerPseudoElementSelectorMap
:
:
new
(
)
)
;
}
)
;
stylist
}
pub
fn
update
(
&
mut
self
doc_stylesheets
:
&
[
Arc
<
Stylesheet
>
]
ua_stylesheets
:
Option
<
&
UserAgentStylesheets
>
stylesheets_changed
:
bool
)
-
>
bool
{
if
!
(
self
.
is_device_dirty
|
|
stylesheets_changed
)
{
return
false
;
}
let
cascaded_rule
=
ViewportRule
{
declarations
:
viewport
:
:
Cascade
:
:
from_stylesheets
(
doc_stylesheets
&
self
.
device
)
.
finish
(
)
}
;
self
.
viewport_constraints
=
ViewportConstraints
:
:
maybe_new
(
&
self
.
device
&
cascaded_rule
)
;
if
let
Some
(
ref
constraints
)
=
self
.
viewport_constraints
{
Arc
:
:
get_mut
(
&
mut
self
.
device
)
.
unwrap
(
)
.
account_for_viewport_rule
(
constraints
)
;
}
self
.
element_map
=
PerPseudoElementSelectorMap
:
:
new
(
)
;
self
.
pseudos_map
=
Default
:
:
default
(
)
;
self
.
animations
=
Default
:
:
default
(
)
;
SelectorImpl
:
:
each_eagerly_cascaded_pseudo_element
(
|
pseudo
|
{
self
.
pseudos_map
.
insert
(
pseudo
PerPseudoElementSelectorMap
:
:
new
(
)
)
;
}
)
;
self
.
precomputed_pseudo_element_decls
=
Default
:
:
default
(
)
;
self
.
rules_source_order
=
0
;
self
.
state_deps
.
clear
(
)
;
self
.
animations
.
clear
(
)
;
self
.
sibling_affecting_selectors
.
clear
(
)
;
self
.
non_common_style_affecting_attributes_selectors
.
clear
(
)
;
if
let
Some
(
ua_stylesheets
)
=
ua_stylesheets
{
for
stylesheet
in
&
ua_stylesheets
.
user_or_user_agent_stylesheets
{
self
.
add_stylesheet
(
&
stylesheet
)
;
}
if
self
.
quirks_mode
{
self
.
add_stylesheet
(
&
ua_stylesheets
.
quirks_mode_stylesheet
)
;
}
}
for
ref
stylesheet
in
doc_stylesheets
.
iter
(
)
{
self
.
add_stylesheet
(
stylesheet
)
;
}
debug
!
(
"
Stylist
stats
:
"
)
;
debug
!
(
"
-
Got
{
}
sibling
-
affecting
selectors
"
self
.
sibling_affecting_selectors
.
len
(
)
)
;
debug
!
(
"
-
Got
{
}
non
-
common
-
style
-
attribute
-
affecting
selectors
"
self
.
non_common_style_affecting_attributes_selectors
.
len
(
)
)
;
debug
!
(
"
-
Got
{
}
deps
for
style
-
hint
calculation
"
self
.
state_deps
.
len
(
)
)
;
SelectorImpl
:
:
each_precomputed_pseudo_element
(
|
pseudo
|
{
if
let
Some
(
map
)
=
self
.
pseudos_map
.
remove
(
&
pseudo
)
{
let
declarations
=
map
.
user_agent
.
get_universal_rules
(
CascadeLevel
:
:
UANormal
CascadeLevel
:
:
UAImportant
)
;
self
.
precomputed_pseudo_element_decls
.
insert
(
pseudo
declarations
)
;
}
}
)
;
self
.
is_device_dirty
=
false
;
true
}
fn
add_stylesheet
(
&
mut
self
stylesheet
:
&
Stylesheet
)
{
if
stylesheet
.
disabled
(
)
|
|
!
stylesheet
.
is_effective_for_device
(
&
self
.
device
)
{
return
;
}
let
device
=
self
.
device
.
clone
(
)
;
stylesheet
.
effective_rules
(
&
device
|
rule
|
{
match
*
rule
{
CssRule
:
:
Style
(
ref
style_rule
)
=
>
{
let
guard
=
style_rule
.
read
(
)
;
for
selector
in
&
guard
.
selectors
.
0
{
let
map
=
if
let
Some
(
ref
pseudo
)
=
selector
.
pseudo_element
{
self
.
pseudos_map
.
entry
(
pseudo
.
clone
(
)
)
.
or_insert_with
(
PerPseudoElementSelectorMap
:
:
new
)
.
borrow_for_origin
(
&
stylesheet
.
origin
)
}
else
{
self
.
element_map
.
borrow_for_origin
(
&
stylesheet
.
origin
)
}
;
map
.
insert
(
Rule
{
selector
:
selector
.
complex_selector
.
clone
(
)
style_rule
:
style_rule
.
clone
(
)
specificity
:
selector
.
specificity
source_order
:
self
.
rules_source_order
}
)
;
}
self
.
rules_source_order
+
=
1
;
for
selector
in
&
guard
.
selectors
.
0
{
self
.
state_deps
.
note_selector
(
&
selector
.
complex_selector
)
;
if
selector
.
affects_siblings
(
)
{
self
.
sibling_affecting_selectors
.
push
(
selector
.
clone
(
)
)
;
}
if
selector
.
matches_non_common_style_affecting_attribute
(
)
{
self
.
non_common_style_affecting_attributes_selectors
.
push
(
selector
.
clone
(
)
)
;
}
}
}
CssRule
:
:
Import
(
ref
import
)
=
>
{
let
import
=
import
.
read
(
)
;
self
.
add_stylesheet
(
&
import
.
stylesheet
)
}
CssRule
:
:
Keyframes
(
ref
keyframes_rule
)
=
>
{
let
keyframes_rule
=
keyframes_rule
.
read
(
)
;
debug
!
(
"
Found
valid
keyframes
rule
:
{
:
?
}
"
*
keyframes_rule
)
;
let
animation
=
KeyframesAnimation
:
:
from_keyframes
(
&
keyframes_rule
.
keyframes
)
;
debug
!
(
"
Found
valid
keyframe
animation
:
{
:
?
}
"
animation
)
;
self
.
animations
.
insert
(
keyframes_rule
.
name
.
clone
(
)
animation
)
;
}
_
=
>
{
}
}
}
)
;
}
pub
fn
precomputed_values_for_pseudo
(
&
self
pseudo
:
&
PseudoElement
parent
:
Option
<
&
Arc
<
ComputedValues
>
>
default
:
&
Arc
<
ComputedValues
>
inherit_all
:
bool
)
-
>
ComputedStyle
{
debug_assert
!
(
SelectorImpl
:
:
pseudo_element_cascade_type
(
pseudo
)
.
is_precomputed
(
)
)
;
let
rule_node
=
match
self
.
precomputed_pseudo_element_decls
.
get
(
pseudo
)
{
Some
(
declarations
)
=
>
{
self
.
rule_tree
.
insert_ordered_rules
(
declarations
.
into_iter
(
)
.
map
(
|
a
|
(
a
.
source
.
clone
(
)
a
.
level
)
)
)
}
None
=
>
self
.
rule_tree
.
root
(
)
}
;
let
mut
flags
=
CascadeFlags
:
:
empty
(
)
;
if
inherit_all
{
flags
.
insert
(
INHERIT_ALL
)
}
let
computed
=
properties
:
:
cascade
(
self
.
device
.
au_viewport_size
(
)
&
rule_node
parent
.
map
(
|
p
|
&
*
*
p
)
default
None
Box
:
:
new
(
StdoutErrorReporter
)
flags
)
;
ComputedStyle
:
:
new
(
rule_node
Arc
:
:
new
(
computed
)
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
style_for_anonymous_box
(
&
self
pseudo
:
&
PseudoElement
parent_style
:
&
Arc
<
ComputedValues
>
default_style
:
&
Arc
<
ComputedValues
>
)
-
>
Arc
<
ComputedValues
>
{
let
inherit_all
=
match
*
pseudo
{
PseudoElement
:
:
ServoInputText
=
>
false
PseudoElement
:
:
ServoAnonymousBlock
|
PseudoElement
:
:
ServoAnonymousTable
|
PseudoElement
:
:
ServoAnonymousTableCell
|
PseudoElement
:
:
ServoAnonymousTableRow
|
PseudoElement
:
:
ServoAnonymousTableWrapper
|
PseudoElement
:
:
ServoTableWrapper
=
>
true
PseudoElement
:
:
Before
|
PseudoElement
:
:
After
|
PseudoElement
:
:
Selection
|
PseudoElement
:
:
DetailsSummary
|
PseudoElement
:
:
DetailsContent
=
>
{
unreachable
!
(
"
That
pseudo
doesn
'
t
represent
an
anonymous
box
!
"
)
}
}
;
self
.
precomputed_values_for_pseudo
(
&
pseudo
Some
(
parent_style
)
default_style
inherit_all
)
.
values
}
pub
fn
lazily_compute_pseudo_element_style
<
E
>
(
&
self
element
:
&
E
pseudo
:
&
PseudoElement
parent
:
&
Arc
<
ComputedValues
>
default
:
&
Arc
<
ComputedValues
>
)
-
>
Option
<
ComputedStyle
>
where
E
:
TElement
+
fmt
:
:
Debug
+
PresentationalHintsSynthetizer
{
debug_assert
!
(
SelectorImpl
:
:
pseudo_element_cascade_type
(
pseudo
)
.
is_lazy
(
)
)
;
if
self
.
pseudos_map
.
get
(
pseudo
)
.
is_none
(
)
{
return
None
;
}
let
mut
declarations
=
vec
!
[
]
;
let
mut
flags
=
ElementSelectorFlags
:
:
empty
(
)
;
self
.
push_applicable_declarations
(
element
None
None
AnimationRules
(
None
None
)
Some
(
pseudo
)
&
mut
declarations
&
mut
flags
)
;
let
rule_node
=
self
.
rule_tree
.
insert_ordered_rules
(
declarations
.
into_iter
(
)
.
map
(
|
a
|
(
a
.
source
a
.
level
)
)
)
;
let
computed
=
properties
:
:
cascade
(
self
.
device
.
au_viewport_size
(
)
&
rule_node
Some
(
&
*
*
parent
)
default
None
Box
:
:
new
(
StdoutErrorReporter
)
CascadeFlags
:
:
empty
(
)
)
;
if
cfg
!
(
feature
=
"
servo
"
)
{
debug_assert
!
(
flags
.
is_empty
(
)
)
;
}
else
{
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
let
self_flags
=
flags
.
for_self
(
)
;
if
!
self_flags
.
is_empty
(
)
{
unsafe
{
element
.
set_selector_flags
(
self_flags
)
;
}
}
let
parent_flags
=
flags
.
for_parent
(
)
;
if
!
parent_flags
.
is_empty
(
)
{
if
let
Some
(
p
)
=
element
.
parent_element
(
)
{
unsafe
{
p
.
set_selector_flags
(
parent_flags
)
;
}
}
}
}
Some
(
ComputedStyle
:
:
new
(
rule_node
Arc
:
:
new
(
computed
)
)
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
set_device
(
&
mut
self
mut
device
:
Device
stylesheets
:
&
[
Arc
<
Stylesheet
>
]
)
{
let
cascaded_rule
=
ViewportRule
{
declarations
:
viewport
:
:
Cascade
:
:
from_stylesheets
(
stylesheets
&
device
)
.
finish
(
)
}
;
self
.
viewport_constraints
=
ViewportConstraints
:
:
maybe_new
(
&
device
&
cascaded_rule
)
;
if
let
Some
(
ref
constraints
)
=
self
.
viewport_constraints
{
device
.
account_for_viewport_rule
(
constraints
)
;
}
fn
mq_eval_changed
(
rules
:
&
[
CssRule
]
before
:
&
Device
after
:
&
Device
)
-
>
bool
{
for
rule
in
rules
{
let
changed
=
rule
.
with_nested_rules_and_mq
(
|
rules
mq
|
{
if
let
Some
(
mq
)
=
mq
{
if
mq
.
evaluate
(
before
)
!
=
mq
.
evaluate
(
after
)
{
return
true
}
}
mq_eval_changed
(
rules
before
after
)
}
)
;
if
changed
{
return
true
}
}
false
}
self
.
is_device_dirty
|
=
stylesheets
.
iter
(
)
.
any
(
|
stylesheet
|
{
let
mq
=
stylesheet
.
media
.
read
(
)
;
if
mq
.
evaluate
(
&
self
.
device
)
!
=
mq
.
evaluate
(
&
device
)
{
return
true
}
mq_eval_changed
(
&
stylesheet
.
rules
.
read
(
)
.
0
&
self
.
device
&
device
)
}
)
;
self
.
device
=
Arc
:
:
new
(
device
)
;
}
pub
fn
viewport_constraints
(
&
self
)
-
>
Option
<
&
ViewportConstraints
>
{
self
.
viewport_constraints
.
as_ref
(
)
}
pub
fn
set_quirks_mode
(
&
mut
self
enabled
:
bool
)
{
self
.
quirks_mode
=
enabled
;
}
pub
fn
push_applicable_declarations
<
E
V
>
(
&
self
element
:
&
E
parent_bf
:
Option
<
&
BloomFilter
>
style_attribute
:
Option
<
&
Arc
<
RwLock
<
PropertyDeclarationBlock
>
>
>
animation_rules
:
AnimationRules
pseudo_element
:
Option
<
&
PseudoElement
>
applicable_declarations
:
&
mut
V
flags
:
&
mut
ElementSelectorFlags
)
-
>
StyleRelations
where
E
:
TElement
+
fmt
:
:
Debug
+
PresentationalHintsSynthetizer
V
:
Push
<
ApplicableDeclarationBlock
>
+
VecLike
<
ApplicableDeclarationBlock
>
{
debug_assert
!
(
!
self
.
is_device_dirty
)
;
debug_assert
!
(
style_attribute
.
is_none
(
)
|
|
pseudo_element
.
is_none
(
)
"
Style
attributes
do
not
apply
to
pseudo
-
elements
"
)
;
debug_assert
!
(
pseudo_element
.
is_none
(
)
|
|
!
SelectorImpl
:
:
pseudo_element_cascade_type
(
pseudo_element
.
as_ref
(
)
.
unwrap
(
)
)
.
is_precomputed
(
)
)
;
let
map
=
match
pseudo_element
{
Some
(
ref
pseudo
)
=
>
self
.
pseudos_map
.
get
(
pseudo
)
.
unwrap
(
)
None
=
>
&
self
.
element_map
}
;
let
mut
relations
=
StyleRelations
:
:
empty
(
)
;
debug
!
(
"
Determining
if
style
is
shareable
:
pseudo
:
{
}
"
pseudo_element
.
is_some
(
)
)
;
map
.
user_agent
.
get_all_matching_rules
(
element
parent_bf
applicable_declarations
&
mut
relations
flags
CascadeLevel
:
:
UANormal
)
;
debug
!
(
"
UA
normal
:
{
:
?
}
"
relations
)
;
let
length_before_preshints
=
applicable_declarations
.
len
(
)
;
element
.
synthesize_presentational_hints_for_legacy_attributes
(
applicable_declarations
)
;
if
applicable_declarations
.
len
(
)
!
=
length_before_preshints
{
if
cfg
!
(
debug_assertions
)
{
for
declaration
in
&
applicable_declarations
[
length_before_preshints
.
.
]
{
assert_eq
!
(
declaration
.
level
CascadeLevel
:
:
PresHints
)
;
}
}
relations
|
=
AFFECTED_BY_PRESENTATIONAL_HINTS
;
}
debug
!
(
"
preshints
:
{
:
?
}
"
relations
)
;
if
element
.
matches_user_and_author_rules
(
)
{
map
.
user
.
get_all_matching_rules
(
element
parent_bf
applicable_declarations
&
mut
relations
flags
CascadeLevel
:
:
UserNormal
)
;
debug
!
(
"
user
normal
:
{
:
?
}
"
relations
)
;
map
.
author
.
get_all_matching_rules
(
element
parent_bf
applicable_declarations
&
mut
relations
flags
CascadeLevel
:
:
AuthorNormal
)
;
debug
!
(
"
author
normal
:
{
:
?
}
"
relations
)
;
if
let
Some
(
sa
)
=
style_attribute
{
if
sa
.
read
(
)
.
any_normal
(
)
{
relations
|
=
AFFECTED_BY_STYLE_ATTRIBUTE
;
Push
:
:
push
(
applicable_declarations
ApplicableDeclarationBlock
:
:
from_declarations
(
sa
.
clone
(
)
CascadeLevel
:
:
StyleAttributeNormal
)
)
;
}
}
debug
!
(
"
style
attr
:
{
:
?
}
"
relations
)
;
if
let
Some
(
anim
)
=
animation_rules
.
0
{
relations
|
=
AFFECTED_BY_ANIMATIONS
;
Push
:
:
push
(
applicable_declarations
ApplicableDeclarationBlock
:
:
from_declarations
(
anim
.
clone
(
)
CascadeLevel
:
:
Animations
)
)
;
}
debug
!
(
"
animation
:
{
:
?
}
"
relations
)
;
map
.
author
.
get_all_matching_rules
(
element
parent_bf
applicable_declarations
&
mut
relations
flags
CascadeLevel
:
:
AuthorImportant
)
;
debug
!
(
"
author
important
:
{
:
?
}
"
relations
)
;
if
let
Some
(
sa
)
=
style_attribute
{
if
sa
.
read
(
)
.
any_important
(
)
{
relations
|
=
AFFECTED_BY_STYLE_ATTRIBUTE
;
Push
:
:
push
(
applicable_declarations
ApplicableDeclarationBlock
:
:
from_declarations
(
sa
.
clone
(
)
CascadeLevel
:
:
StyleAttributeImportant
)
)
;
}
}
debug
!
(
"
style
attr
important
:
{
:
?
}
"
relations
)
;
map
.
user
.
get_all_matching_rules
(
element
parent_bf
applicable_declarations
&
mut
relations
flags
CascadeLevel
:
:
UserImportant
)
;
debug
!
(
"
user
important
:
{
:
?
}
"
relations
)
;
}
else
{
debug
!
(
"
skipping
non
-
agent
rules
"
)
;
}
map
.
user_agent
.
get_all_matching_rules
(
element
parent_bf
applicable_declarations
&
mut
relations
flags
CascadeLevel
:
:
UAImportant
)
;
debug
!
(
"
UA
important
:
{
:
?
}
"
relations
)
;
if
let
Some
(
anim
)
=
animation_rules
.
1
{
relations
|
=
AFFECTED_BY_TRANSITIONS
;
Push
:
:
push
(
applicable_declarations
ApplicableDeclarationBlock
:
:
from_declarations
(
anim
.
clone
(
)
CascadeLevel
:
:
Transitions
)
)
;
}
debug
!
(
"
transition
:
{
:
?
}
"
relations
)
;
debug
!
(
"
push_applicable_declarations
:
shareable
:
{
:
?
}
"
relations
)
;
relations
}
#
[
inline
]
pub
fn
is_device_dirty
(
&
self
)
-
>
bool
{
self
.
is_device_dirty
}
#
[
inline
]
pub
fn
animations
(
&
self
)
-
>
&
FnvHashMap
<
Atom
KeyframesAnimation
>
{
&
self
.
animations
}
pub
fn
match_same_not_common_style_affecting_attributes_rules
<
E
>
(
&
self
element
:
&
E
candidate
:
&
E
)
-
>
bool
where
E
:
TElement
{
use
selectors
:
:
matching
:
:
StyleRelations
;
use
selectors
:
:
matching
:
:
matches_complex_selector
;
for
ref
selector
in
self
.
non_common_style_affecting_attributes_selectors
.
iter
(
)
{
let
element_matches
=
matches_complex_selector
(
&
selector
.
complex_selector
element
None
&
mut
StyleRelations
:
:
empty
(
)
&
mut
ElementSelectorFlags
:
:
empty
(
)
)
;
let
candidate_matches
=
matches_complex_selector
(
&
selector
.
complex_selector
candidate
None
&
mut
StyleRelations
:
:
empty
(
)
&
mut
ElementSelectorFlags
:
:
empty
(
)
)
;
if
element_matches
!
=
candidate_matches
{
return
false
;
}
}
true
}
#
[
inline
]
pub
fn
rule_tree_root
(
&
self
)
-
>
StrongRuleNode
{
self
.
rule_tree
.
root
(
)
}
pub
fn
match_same_sibling_affecting_rules
<
E
>
(
&
self
element
:
&
E
candidate
:
&
E
)
-
>
bool
where
E
:
TElement
{
use
selectors
:
:
matching
:
:
StyleRelations
;
use
selectors
:
:
matching
:
:
matches_complex_selector
;
for
ref
selector
in
self
.
sibling_affecting_selectors
.
iter
(
)
{
let
element_matches
=
matches_complex_selector
(
&
selector
.
complex_selector
element
None
&
mut
StyleRelations
:
:
empty
(
)
&
mut
ElementSelectorFlags
:
:
empty
(
)
)
;
let
candidate_matches
=
matches_complex_selector
(
&
selector
.
complex_selector
candidate
None
&
mut
StyleRelations
:
:
empty
(
)
&
mut
ElementSelectorFlags
:
:
empty
(
)
)
;
if
element_matches
!
=
candidate_matches
{
debug
!
(
"
match_same_sibling_affecting_rules
:
Failure
due
to
{
:
?
}
"
selector
.
complex_selector
)
;
return
false
;
}
}
true
}
pub
fn
compute_restyle_hint
<
E
>
(
&
self
element
:
&
E
snapshot
:
&
Snapshot
)
-
>
RestyleHint
where
E
:
TElement
{
self
.
state_deps
.
compute_hint
(
element
snapshot
)
}
}
impl
Drop
for
Stylist
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
rule_tree
.
gc
(
)
;
}
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
struct
PerPseudoElementSelectorMap
{
user_agent
:
SelectorMap
author
:
SelectorMap
user
:
SelectorMap
}
impl
PerPseudoElementSelectorMap
{
#
[
inline
]
fn
new
(
)
-
>
Self
{
PerPseudoElementSelectorMap
{
user_agent
:
SelectorMap
:
:
new
(
)
author
:
SelectorMap
:
:
new
(
)
user
:
SelectorMap
:
:
new
(
)
}
}
#
[
inline
]
fn
borrow_for_origin
(
&
mut
self
origin
:
&
Origin
)
-
>
&
mut
SelectorMap
{
match
*
origin
{
Origin
:
:
UserAgent
=
>
&
mut
self
.
user_agent
Origin
:
:
Author
=
>
&
mut
self
.
author
Origin
:
:
User
=
>
&
mut
self
.
user
}
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
SelectorMap
{
pub
id_hash
:
FnvHashMap
<
Atom
Vec
<
Rule
>
>
pub
class_hash
:
FnvHashMap
<
Atom
Vec
<
Rule
>
>
pub
local_name_hash
:
FnvHashMap
<
LocalName
Vec
<
Rule
>
>
pub
lower_local_name_hash
:
FnvHashMap
<
LocalName
Vec
<
Rule
>
>
pub
other_rules
:
Vec
<
Rule
>
pub
empty
:
bool
}
#
[
inline
]
fn
sort_by_key
<
T
F
:
Fn
(
&
T
)
-
>
K
K
:
Ord
>
(
v
:
&
mut
[
T
]
f
:
F
)
{
sort_by
(
v
|
a
b
|
f
(
a
)
.
cmp
(
&
f
(
b
)
)
)
}
impl
SelectorMap
{
pub
fn
new
(
)
-
>
Self
{
SelectorMap
{
id_hash
:
HashMap
:
:
default
(
)
class_hash
:
HashMap
:
:
default
(
)
local_name_hash
:
HashMap
:
:
default
(
)
lower_local_name_hash
:
HashMap
:
:
default
(
)
other_rules
:
Vec
:
:
new
(
)
empty
:
true
}
}
pub
fn
get_all_matching_rules
<
E
V
>
(
&
self
element
:
&
E
parent_bf
:
Option
<
&
BloomFilter
>
matching_rules_list
:
&
mut
V
relations
:
&
mut
StyleRelations
flags
:
&
mut
ElementSelectorFlags
cascade_level
:
CascadeLevel
)
where
E
:
Element
<
Impl
=
SelectorImpl
>
V
:
VecLike
<
ApplicableDeclarationBlock
>
{
if
self
.
empty
{
return
}
let
init_len
=
matching_rules_list
.
len
(
)
;
if
let
Some
(
id
)
=
element
.
get_id
(
)
{
SelectorMap
:
:
get_matching_rules_from_hash
(
element
parent_bf
&
self
.
id_hash
&
id
matching_rules_list
relations
flags
cascade_level
)
}
element
.
each_class
(
|
class
|
{
SelectorMap
:
:
get_matching_rules_from_hash
(
element
parent_bf
&
self
.
class_hash
class
matching_rules_list
relations
flags
cascade_level
)
;
}
)
;
let
local_name_hash
=
if
element
.
is_html_element_in_html_document
(
)
{
&
self
.
lower_local_name_hash
}
else
{
&
self
.
local_name_hash
}
;
SelectorMap
:
:
get_matching_rules_from_hash
(
element
parent_bf
local_name_hash
element
.
get_local_name
(
)
matching_rules_list
relations
flags
cascade_level
)
;
SelectorMap
:
:
get_matching_rules
(
element
parent_bf
&
self
.
other_rules
matching_rules_list
relations
flags
cascade_level
)
;
sort_by_key
(
&
mut
matching_rules_list
[
init_len
.
.
]
|
block
|
(
block
.
specificity
block
.
source_order
)
)
;
}
pub
fn
get_universal_rules
(
&
self
cascade_level
:
CascadeLevel
important_cascade_level
:
CascadeLevel
)
-
>
Vec
<
ApplicableDeclarationBlock
>
{
debug_assert
!
(
!
cascade_level
.
is_important
(
)
)
;
debug_assert
!
(
important_cascade_level
.
is_important
(
)
)
;
if
self
.
empty
{
return
vec
!
[
]
;
}
let
mut
matching_rules_list
=
vec
!
[
]
;
let
mut
important
=
vec
!
[
]
;
for
rule
in
self
.
other_rules
.
iter
(
)
{
if
rule
.
selector
.
compound_selector
.
is_empty
(
)
&
&
rule
.
selector
.
next
.
is_none
(
)
{
let
guard
=
rule
.
style_rule
.
read
(
)
;
let
block
=
guard
.
block
.
read
(
)
;
if
block
.
any_normal
(
)
{
matching_rules_list
.
push
(
rule
.
to_applicable_declaration_block
(
cascade_level
)
)
;
}
if
block
.
any_important
(
)
{
important
.
push
(
rule
.
to_applicable_declaration_block
(
important_cascade_level
)
)
;
}
}
}
let
normal_len
=
matching_rules_list
.
len
(
)
;
matching_rules_list
.
extend
(
important
.
into_iter
(
)
)
;
sort_by_key
(
&
mut
matching_rules_list
[
0
.
.
normal_len
]
|
block
|
(
block
.
specificity
block
.
source_order
)
)
;
sort_by_key
(
&
mut
matching_rules_list
[
normal_len
.
.
]
|
block
|
(
block
.
specificity
block
.
source_order
)
)
;
matching_rules_list
}
fn
get_matching_rules_from_hash
<
E
Str
BorrowedStr
:
?
Sized
Vector
>
(
element
:
&
E
parent_bf
:
Option
<
&
BloomFilter
>
hash
:
&
FnvHashMap
<
Str
Vec
<
Rule
>
>
key
:
&
BorrowedStr
matching_rules
:
&
mut
Vector
relations
:
&
mut
StyleRelations
flags
:
&
mut
ElementSelectorFlags
cascade_level
:
CascadeLevel
)
where
E
:
Element
<
Impl
=
SelectorImpl
>
Str
:
Borrow
<
BorrowedStr
>
+
Eq
+
Hash
BorrowedStr
:
Eq
+
Hash
Vector
:
VecLike
<
ApplicableDeclarationBlock
>
{
if
let
Some
(
rules
)
=
hash
.
get
(
key
)
{
SelectorMap
:
:
get_matching_rules
(
element
parent_bf
rules
matching_rules
relations
flags
cascade_level
)
}
}
fn
get_matching_rules
<
E
V
>
(
element
:
&
E
parent_bf
:
Option
<
&
BloomFilter
>
rules
:
&
[
Rule
]
matching_rules
:
&
mut
V
relations
:
&
mut
StyleRelations
flags
:
&
mut
ElementSelectorFlags
cascade_level
:
CascadeLevel
)
where
E
:
Element
<
Impl
=
SelectorImpl
>
V
:
VecLike
<
ApplicableDeclarationBlock
>
{
for
rule
in
rules
.
iter
(
)
{
let
guard
=
rule
.
style_rule
.
read
(
)
;
let
block
=
guard
.
block
.
read
(
)
;
let
any_declaration_for_importance
=
if
cascade_level
.
is_important
(
)
{
block
.
any_important
(
)
}
else
{
block
.
any_normal
(
)
}
;
if
any_declaration_for_importance
&
&
matches_complex_selector
(
&
*
rule
.
selector
element
parent_bf
relations
flags
)
{
matching_rules
.
push
(
rule
.
to_applicable_declaration_block
(
cascade_level
)
)
;
}
}
}
pub
fn
insert
(
&
mut
self
rule
:
Rule
)
{
self
.
empty
=
false
;
if
let
Some
(
id_name
)
=
SelectorMap
:
:
get_id_name
(
&
rule
)
{
find_push
(
&
mut
self
.
id_hash
id_name
rule
)
;
return
;
}
if
let
Some
(
class_name
)
=
SelectorMap
:
:
get_class_name
(
&
rule
)
{
find_push
(
&
mut
self
.
class_hash
class_name
rule
)
;
return
;
}
if
let
Some
(
LocalNameSelector
{
name
lower_name
}
)
=
SelectorMap
:
:
get_local_name
(
&
rule
)
{
find_push
(
&
mut
self
.
local_name_hash
name
rule
.
clone
(
)
)
;
find_push
(
&
mut
self
.
lower_local_name_hash
lower_name
rule
)
;
return
;
}
self
.
other_rules
.
push
(
rule
)
;
}
pub
fn
get_id_name
(
rule
:
&
Rule
)
-
>
Option
<
Atom
>
{
for
ss
in
&
rule
.
selector
.
compound_selector
{
if
let
SimpleSelector
:
:
ID
(
ref
id
)
=
*
ss
{
return
Some
(
id
.
clone
(
)
)
;
}
}
None
}
pub
fn
get_class_name
(
rule
:
&
Rule
)
-
>
Option
<
Atom
>
{
for
ss
in
&
rule
.
selector
.
compound_selector
{
if
let
SimpleSelector
:
:
Class
(
ref
class
)
=
*
ss
{
return
Some
(
class
.
clone
(
)
)
;
}
}
None
}
pub
fn
get_local_name
(
rule
:
&
Rule
)
-
>
Option
<
LocalNameSelector
<
SelectorImpl
>
>
{
for
ss
in
&
rule
.
selector
.
compound_selector
{
if
let
SimpleSelector
:
:
LocalName
(
ref
n
)
=
*
ss
{
return
Some
(
LocalNameSelector
{
name
:
n
.
name
.
clone
(
)
lower_name
:
n
.
lower_name
.
clone
(
)
}
)
}
}
None
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Debug
)
]
pub
struct
Rule
{
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
pub
selector
:
Arc
<
ComplexSelector
<
SelectorImpl
>
>
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
pub
style_rule
:
Arc
<
RwLock
<
StyleRule
>
>
pub
source_order
:
usize
pub
specificity
:
u32
}
impl
Rule
{
fn
to_applicable_declaration_block
(
&
self
level
:
CascadeLevel
)
-
>
ApplicableDeclarationBlock
{
ApplicableDeclarationBlock
{
source
:
StyleSource
:
:
Style
(
self
.
style_rule
.
clone
(
)
)
level
:
level
source_order
:
self
.
source_order
specificity
:
self
.
specificity
}
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Debug
Clone
)
]
pub
struct
ApplicableDeclarationBlock
{
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
pub
source
:
StyleSource
pub
level
:
CascadeLevel
pub
source_order
:
usize
pub
specificity
:
u32
}
impl
ApplicableDeclarationBlock
{
#
[
inline
]
pub
fn
from_declarations
(
declarations
:
Arc
<
RwLock
<
PropertyDeclarationBlock
>
>
level
:
CascadeLevel
)
-
>
Self
{
ApplicableDeclarationBlock
{
source
:
StyleSource
:
:
Declarations
(
declarations
)
level
:
level
source_order
:
0
specificity
:
0
}
}
}
#
[
inline
]
fn
find_push
<
Str
:
Eq
+
Hash
>
(
map
:
&
mut
FnvHashMap
<
Str
Vec
<
Rule
>
>
key
:
Str
value
:
Rule
)
{
map
.
entry
(
key
)
.
or_insert_with
(
Vec
:
:
new
)
.
push
(
value
)
}
