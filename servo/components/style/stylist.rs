use
{
Atom
LocalName
Namespace
}
;
use
applicable_declarations
:
:
{
ApplicableDeclarationBlock
ApplicableDeclarationList
}
;
use
bit_vec
:
:
BitVec
;
use
context
:
:
QuirksMode
;
use
dom
:
:
TElement
;
use
element_state
:
:
ElementState
;
use
error_reporting
:
:
create_error_reporter
;
use
font_metrics
:
:
FontMetricsProvider
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
structs
:
:
{
nsIAtom
StyleRuleInclusion
}
;
use
invalidation
:
:
element
:
:
invalidation_map
:
:
InvalidationMap
;
use
invalidation
:
:
media_queries
:
:
EffectiveMediaQueryResults
;
use
media_queries
:
:
Device
;
use
properties
:
:
{
self
CascadeFlags
ComputedValues
}
;
use
properties
:
:
{
AnimationRules
PropertyDeclarationBlock
}
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
properties
:
:
INHERIT_ALL
;
use
rule_tree
:
:
{
CascadeLevel
RuleTree
StrongRuleNode
StyleSource
}
;
use
selector_map
:
:
{
SelectorMap
SelectorMapEntry
}
;
use
selector_parser
:
:
{
SelectorImpl
PseudoElement
}
;
use
selectors
:
:
attr
:
:
NamespaceConstraint
;
use
selectors
:
:
bloom
:
:
BloomFilter
;
use
selectors
:
:
matching
:
:
{
ElementSelectorFlags
matches_selector
MatchingContext
MatchingMode
}
;
use
selectors
:
:
matching
:
:
AFFECTED_BY_PRESENTATIONAL_HINTS
;
use
selectors
:
:
parser
:
:
{
AncestorHashes
Combinator
Component
Selector
SelectorAndHashes
}
;
use
selectors
:
:
parser
:
:
{
SelectorIter
SelectorMethods
}
;
use
selectors
:
:
sink
:
:
Push
;
use
selectors
:
:
visitor
:
:
SelectorVisitor
;
use
shared_lock
:
:
{
Locked
SharedRwLockReadGuard
StylesheetGuards
}
;
use
smallvec
:
:
VecLike
;
use
std
:
:
fmt
:
:
Debug
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
std
:
:
marker
:
:
PhantomData
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
use
stylearc
:
:
Arc
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
stylesheets
:
:
{
CounterStyleRule
FontFaceRule
}
;
use
stylesheets
:
:
{
CssRule
StyleRule
}
;
use
stylesheets
:
:
{
Stylesheet
Origin
UserAgentStylesheets
}
;
use
stylesheets
:
:
keyframes_rule
:
:
KeyframesAnimation
;
use
stylesheets
:
:
viewport_rule
:
:
{
self
MaybeNew
ViewportRule
}
;
use
thread_state
;
pub
use
:
:
fnv
:
:
FnvHashMap
;
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
Stylist
{
device
:
Device
viewport_constraints
:
Option
<
ViewportConstraints
>
effective_media_query_results
:
EffectiveMediaQueryResults
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
defined
in
selectors
"
)
]
quirks_mode
:
QuirksMode
is_device_dirty
:
bool
is_cleared
:
bool
element_map
:
PerPseudoElementSelectorMap
rule_tree
:
RuleTree
pseudos_map
:
FnvHashMap
<
PseudoElement
PerPseudoElementSelectorMap
>
animations
:
FnvHashMap
<
Atom
KeyframesAnimation
>
precomputed_pseudo_element_decls
:
FnvHashMap
<
PseudoElement
Vec
<
ApplicableDeclarationBlock
>
>
rules_source_order
:
u32
invalidation_map
:
InvalidationMap
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
just
an
array
"
)
]
attribute_dependencies
:
BloomFilter
style_attribute_dependency
:
bool
state_dependencies
:
ElementState
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
just
an
array
"
)
]
mapped_ids
:
BloomFilter
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
selectors_for_cache_revalidation
:
SelectorMap
<
RevalidationSelectorAndHashes
>
num_selectors
:
usize
num_declarations
:
usize
num_rebuilds
:
usize
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
struct
ExtraStyleData
<
'
a
>
{
pub
font_faces
:
&
'
a
mut
Vec
<
(
Arc
<
Locked
<
FontFaceRule
>
>
Origin
)
>
pub
counter_styles
:
&
'
a
mut
FnvHashMap
<
Atom
Arc
<
Locked
<
CounterStyleRule
>
>
>
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
<
'
a
>
ExtraStyleData
<
'
a
>
{
fn
clear
(
&
mut
self
)
{
self
.
font_faces
.
clear
(
)
;
self
.
counter_styles
.
clear
(
)
;
}
fn
add_font_face
(
&
mut
self
rule
:
&
Arc
<
Locked
<
FontFaceRule
>
>
origin
:
Origin
)
{
self
.
font_faces
.
push
(
(
rule
.
clone
(
)
origin
)
)
;
}
fn
add_counter_style
(
&
mut
self
guard
:
&
SharedRwLockReadGuard
rule
:
&
Arc
<
Locked
<
CounterStyleRule
>
>
)
{
let
name
=
rule
.
read_with
(
guard
)
.
mName
.
raw
:
:
<
nsIAtom
>
(
)
.
into
(
)
;
self
.
counter_styles
.
insert
(
name
rule
.
clone
(
)
)
;
}
}
#
[
allow
(
missing_docs
)
]
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
struct
ExtraStyleData
<
'
a
>
{
pub
marker
:
PhantomData
<
&
'
a
usize
>
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
<
'
a
>
ExtraStyleData
<
'
a
>
{
fn
clear
(
&
mut
self
)
{
}
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
RuleInclusion
{
All
DefaultOnly
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
From
<
StyleRuleInclusion
>
for
RuleInclusion
{
fn
from
(
value
:
StyleRuleInclusion
)
-
>
Self
{
match
value
{
StyleRuleInclusion
:
:
All
=
>
RuleInclusion
:
:
All
StyleRuleInclusion
:
:
DefaultOnly
=
>
RuleInclusion
:
:
DefaultOnly
}
}
}
impl
Stylist
{
#
[
inline
]
pub
fn
new
(
device
:
Device
quirks_mode
:
QuirksMode
)
-
>
Self
{
let
mut
stylist
=
Stylist
{
viewport_constraints
:
None
device
:
device
is_device_dirty
:
true
is_cleared
:
true
quirks_mode
:
quirks_mode
effective_media_query_results
:
EffectiveMediaQueryResults
:
:
new
(
)
element_map
:
PerPseudoElementSelectorMap
:
:
new
(
)
pseudos_map
:
Default
:
:
default
(
)
animations
:
Default
:
:
default
(
)
precomputed_pseudo_element_decls
:
Default
:
:
default
(
)
rules_source_order
:
0
rule_tree
:
RuleTree
:
:
new
(
)
invalidation_map
:
InvalidationMap
:
:
new
(
)
attribute_dependencies
:
BloomFilter
:
:
new
(
)
style_attribute_dependency
:
false
state_dependencies
:
ElementState
:
:
empty
(
)
mapped_ids
:
BloomFilter
:
:
new
(
)
selectors_for_cache_revalidation
:
SelectorMap
:
:
new
(
)
num_selectors
:
0
num_declarations
:
0
num_rebuilds
:
0
}
;
SelectorImpl
:
:
each_eagerly_cascaded_pseudo_element
(
|
pseudo
|
{
stylist
.
pseudos_map
.
insert
(
pseudo
PerPseudoElementSelectorMap
:
:
new
(
)
)
;
}
)
;
stylist
}
pub
fn
num_selectors
(
&
self
)
-
>
usize
{
self
.
num_selectors
}
pub
fn
num_declarations
(
&
self
)
-
>
usize
{
self
.
num_declarations
}
pub
fn
num_rebuilds
(
&
self
)
-
>
usize
{
self
.
num_rebuilds
}
pub
fn
num_revalidation_selectors
(
&
self
)
-
>
usize
{
self
.
selectors_for_cache_revalidation
.
len
(
)
}
pub
fn
invalidation_map
(
&
self
)
-
>
&
InvalidationMap
{
&
self
.
invalidation_map
}
pub
fn
clear
(
&
mut
self
)
{
if
self
.
is_cleared
{
return
}
self
.
is_cleared
=
true
;
self
.
effective_media_query_results
.
clear
(
)
;
self
.
viewport_constraints
=
None
;
self
.
is_device_dirty
=
true
;
self
.
element_map
=
PerPseudoElementSelectorMap
:
:
new
(
)
;
self
.
pseudos_map
=
Default
:
:
default
(
)
;
self
.
animations
.
clear
(
)
;
self
.
precomputed_pseudo_element_decls
=
Default
:
:
default
(
)
;
self
.
rules_source_order
=
0
;
self
.
invalidation_map
.
clear
(
)
;
self
.
attribute_dependencies
.
clear
(
)
;
self
.
style_attribute_dependency
=
false
;
self
.
state_dependencies
=
ElementState
:
:
empty
(
)
;
self
.
mapped_ids
.
clear
(
)
;
self
.
selectors_for_cache_revalidation
=
SelectorMap
:
:
new
(
)
;
self
.
num_selectors
=
0
;
self
.
num_declarations
=
0
;
}
pub
fn
rebuild
<
'
a
'
b
I
>
(
&
mut
self
doc_stylesheets
:
I
guards
:
&
StylesheetGuards
ua_stylesheets
:
Option
<
&
UserAgentStylesheets
>
stylesheets_changed
:
bool
author_style_disabled
:
bool
extra_data
:
&
mut
ExtraStyleData
<
'
a
>
)
-
>
bool
where
I
:
Iterator
<
Item
=
&
'
b
Arc
<
Stylesheet
>
>
+
Clone
{
debug_assert
!
(
!
self
.
is_cleared
|
|
self
.
is_device_dirty
)
;
self
.
is_cleared
=
false
;
if
!
(
self
.
is_device_dirty
|
|
stylesheets_changed
)
{
return
false
;
}
self
.
num_rebuilds
+
=
1
;
self
.
viewport_constraints
=
None
;
if
viewport_rule
:
:
enabled
(
)
{
let
cascaded_rule
=
ViewportRule
{
declarations
:
viewport_rule
:
:
Cascade
:
:
from_stylesheets
(
doc_stylesheets
.
clone
(
)
guards
.
author
&
self
.
device
)
.
finish
(
)
}
;
self
.
viewport_constraints
=
ViewportConstraints
:
:
maybe_new
(
&
self
.
device
&
cascaded_rule
self
.
quirks_mode
)
}
if
let
Some
(
ref
constraints
)
=
self
.
viewport_constraints
{
self
.
device
.
account_for_viewport_rule
(
constraints
)
;
}
SelectorImpl
:
:
each_eagerly_cascaded_pseudo_element
(
|
pseudo
|
{
self
.
pseudos_map
.
insert
(
pseudo
PerPseudoElementSelectorMap
:
:
new
(
)
)
;
}
)
;
extra_data
.
clear
(
)
;
if
let
Some
(
ua_stylesheets
)
=
ua_stylesheets
{
for
stylesheet
in
&
ua_stylesheets
.
user_or_user_agent_stylesheets
{
self
.
add_stylesheet
(
&
stylesheet
guards
.
ua_or_user
extra_data
)
;
}
if
self
.
quirks_mode
!
=
QuirksMode
:
:
NoQuirks
{
self
.
add_stylesheet
(
&
ua_stylesheets
.
quirks_mode_stylesheet
guards
.
ua_or_user
extra_data
)
;
}
}
let
sheets_to_add
=
doc_stylesheets
.
filter
(
|
s
|
{
!
author_style_disabled
|
|
s
.
origin
!
=
Origin
:
:
Author
}
)
;
for
ref
stylesheet
in
sheets_to_add
{
self
.
add_stylesheet
(
stylesheet
guards
.
author
extra_data
)
;
}
SelectorImpl
:
:
each_precomputed_pseudo_element
(
|
pseudo
|
{
if
let
Some
(
map
)
=
self
.
pseudos_map
.
remove
(
&
pseudo
)
{
let
declarations
=
map
.
user_agent
.
get_universal_rules
(
CascadeLevel
:
:
UANormal
)
;
self
.
precomputed_pseudo_element_decls
.
insert
(
pseudo
declarations
)
;
}
}
)
;
self
.
is_device_dirty
=
false
;
true
}
pub
fn
update
<
'
a
'
b
I
>
(
&
mut
self
doc_stylesheets
:
I
guards
:
&
StylesheetGuards
ua_stylesheets
:
Option
<
&
UserAgentStylesheets
>
stylesheets_changed
:
bool
author_style_disabled
:
bool
extra_data
:
&
mut
ExtraStyleData
<
'
a
>
)
-
>
bool
where
I
:
Iterator
<
Item
=
&
'
b
Arc
<
Stylesheet
>
>
+
Clone
{
debug_assert
!
(
!
self
.
is_cleared
|
|
self
.
is_device_dirty
)
;
if
!
(
self
.
is_device_dirty
|
|
stylesheets_changed
)
{
return
false
;
}
self
.
clear
(
)
;
self
.
rebuild
(
doc_stylesheets
guards
ua_stylesheets
stylesheets_changed
author_style_disabled
extra_data
)
}
fn
add_stylesheet
<
'
a
>
(
&
mut
self
stylesheet
:
&
Stylesheet
guard
:
&
SharedRwLockReadGuard
_extra_data
:
&
mut
ExtraStyleData
<
'
a
>
)
{
if
stylesheet
.
disabled
(
)
|
|
!
stylesheet
.
is_effective_for_device
(
&
self
.
device
guard
)
{
return
;
}
self
.
effective_media_query_results
.
saw_effective
(
stylesheet
)
;
for
rule
in
stylesheet
.
effective_rules
(
&
self
.
device
guard
)
{
match
*
rule
{
CssRule
:
:
Style
(
ref
locked
)
=
>
{
let
style_rule
=
locked
.
read_with
(
&
guard
)
;
self
.
num_declarations
+
=
style_rule
.
block
.
read_with
(
&
guard
)
.
len
(
)
;
for
selector_and_hashes
in
&
style_rule
.
selectors
.
0
{
self
.
num_selectors
+
=
1
;
let
map
=
if
let
Some
(
pseudo
)
=
selector_and_hashes
.
selector
.
pseudo_element
(
)
{
self
.
pseudos_map
.
entry
(
pseudo
.
canonical
(
)
)
.
or_insert_with
(
PerPseudoElementSelectorMap
:
:
new
)
.
borrow_for_origin
(
&
stylesheet
.
origin
)
}
else
{
self
.
element_map
.
borrow_for_origin
(
&
stylesheet
.
origin
)
}
;
map
.
insert
(
Rule
:
:
new
(
selector_and_hashes
.
selector
.
clone
(
)
selector_and_hashes
.
hashes
.
clone
(
)
locked
.
clone
(
)
self
.
rules_source_order
)
self
.
quirks_mode
)
;
self
.
invalidation_map
.
note_selector
(
selector_and_hashes
self
.
quirks_mode
)
;
if
needs_revalidation
(
&
selector_and_hashes
.
selector
)
{
self
.
selectors_for_cache_revalidation
.
insert
(
RevalidationSelectorAndHashes
:
:
new
(
&
selector_and_hashes
)
self
.
quirks_mode
)
;
}
selector_and_hashes
.
selector
.
visit
(
&
mut
AttributeAndStateDependencyVisitor
{
attribute_dependencies
:
&
mut
self
.
attribute_dependencies
style_attribute_dependency
:
&
mut
self
.
style_attribute_dependency
state_dependencies
:
&
mut
self
.
state_dependencies
}
)
;
selector_and_hashes
.
selector
.
visit
(
&
mut
MappedIdVisitor
{
mapped_ids
:
&
mut
self
.
mapped_ids
}
)
;
}
self
.
rules_source_order
+
=
1
;
}
CssRule
:
:
Import
(
ref
lock
)
=
>
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
self
.
effective_media_query_results
.
saw_effective
(
import_rule
)
;
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
let
media_rule
=
lock
.
read_with
(
guard
)
;
self
.
effective_media_query_results
.
saw_effective
(
media_rule
)
;
}
CssRule
:
:
Keyframes
(
ref
keyframes_rule
)
=
>
{
let
keyframes_rule
=
keyframes_rule
.
read_with
(
guard
)
;
debug
!
(
"
Found
valid
keyframes
rule
:
{
:
?
}
"
*
keyframes_rule
)
;
let
needs_insertion
=
keyframes_rule
.
vendor_prefix
.
is_none
(
)
|
|
self
.
animations
.
get
(
keyframes_rule
.
name
.
as_atom
(
)
)
.
map_or
(
true
|
rule
|
rule
.
vendor_prefix
.
is_some
(
)
)
;
if
needs_insertion
{
let
animation
=
KeyframesAnimation
:
:
from_keyframes
(
&
keyframes_rule
.
keyframes
keyframes_rule
.
vendor_prefix
.
clone
(
)
guard
)
;
debug
!
(
"
Found
valid
keyframe
animation
:
{
:
?
}
"
animation
)
;
self
.
animations
.
insert
(
keyframes_rule
.
name
.
as_atom
(
)
.
clone
(
)
animation
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
FontFace
(
ref
rule
)
=
>
{
_extra_data
.
add_font_face
(
&
rule
stylesheet
.
origin
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
CssRule
:
:
CounterStyle
(
ref
rule
)
=
>
{
_extra_data
.
add_counter_style
(
guard
&
rule
)
;
}
_
=
>
{
}
}
}
}
pub
fn
might_have_attribute_dependency
(
&
self
local_name
:
&
LocalName
)
-
>
bool
{
if
self
.
is_cleared
|
|
self
.
is_device_dirty
{
true
}
else
if
*
local_name
=
=
local_name
!
(
"
style
"
)
{
self
.
style_attribute_dependency
}
else
{
self
.
attribute_dependencies
.
might_contain_hash
(
local_name
.
get_hash
(
)
)
}
}
pub
fn
might_have_state_dependency
(
&
self
state
:
ElementState
)
-
>
bool
{
if
self
.
is_cleared
|
|
self
.
is_device_dirty
{
true
}
else
{
self
.
state_dependencies
.
intersects
(
state
)
}
}
pub
fn
has_state_dependency
(
&
self
state
:
ElementState
)
-
>
bool
{
self
.
state_dependencies
.
intersects
(
state
)
}
pub
fn
precomputed_values_for_pseudo
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent
:
Option
<
&
Arc
<
ComputedValues
>
>
cascade_flags
:
CascadeFlags
font_metrics
:
&
FontMetricsProvider
)
-
>
Arc
<
ComputedValues
>
{
debug_assert
!
(
pseudo
.
is_precomputed
(
)
)
;
let
rule_node
=
match
self
.
precomputed_pseudo_element_decls
.
get
(
pseudo
)
{
Some
(
declarations
)
=
>
{
self
.
rule_tree
.
insert_ordered_rules_with_important
(
declarations
.
into_iter
(
)
.
map
(
|
a
|
(
a
.
source
.
clone
(
)
a
.
level
(
)
)
)
guards
)
}
None
=
>
self
.
rule_tree
.
root
(
)
}
;
let
computed
=
properties
:
:
cascade
(
&
self
.
device
&
rule_node
guards
parent
.
map
(
|
p
|
&
*
*
p
)
parent
.
map
(
|
p
|
&
*
*
p
)
None
None
&
create_error_reporter
(
)
font_metrics
cascade_flags
self
.
quirks_mode
)
;
Arc
:
:
new
(
computed
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
style_for_anonymous
(
&
self
guards
:
&
StylesheetGuards
pseudo
:
&
PseudoElement
parent_style
:
&
Arc
<
ComputedValues
>
)
-
>
Arc
<
ComputedValues
>
{
use
font_metrics
:
:
ServoMetricsProvider
;
let
inherit_all
=
match
*
pseudo
{
PseudoElement
:
:
ServoText
|
PseudoElement
:
:
ServoInputText
=
>
false
PseudoElement
:
:
ServoAnonymousBlock
|
PseudoElement
:
:
ServoAnonymousTable
|
PseudoElement
:
:
ServoAnonymousTableCell
|
PseudoElement
:
:
ServoAnonymousTableRow
|
PseudoElement
:
:
ServoAnonymousTableWrapper
|
PseudoElement
:
:
ServoTableWrapper
|
PseudoElement
:
:
ServoInlineBlockWrapper
|
PseudoElement
:
:
ServoInlineAbsolute
=
>
true
PseudoElement
:
:
Before
|
PseudoElement
:
:
After
|
PseudoElement
:
:
Selection
|
PseudoElement
:
:
DetailsSummary
|
PseudoElement
:
:
DetailsContent
=
>
{
unreachable
!
(
"
That
pseudo
doesn
'
t
represent
an
anonymous
box
!
"
)
}
}
;
let
mut
cascade_flags
=
CascadeFlags
:
:
empty
(
)
;
if
inherit_all
{
cascade_flags
.
insert
(
INHERIT_ALL
)
;
}
self
.
precomputed_values_for_pseudo
(
guards
&
pseudo
Some
(
parent_style
)
cascade_flags
&
ServoMetricsProvider
)
}
pub
fn
lazily_compute_pseudo_element_style
<
E
>
(
&
self
guards
:
&
StylesheetGuards
element
:
&
E
pseudo
:
&
PseudoElement
rule_inclusion
:
RuleInclusion
parent_style
:
&
ComputedValues
font_metrics
:
&
FontMetricsProvider
)
-
>
Option
<
Arc
<
ComputedValues
>
>
where
E
:
TElement
{
let
rule_node
=
match
self
.
lazy_pseudo_rules
(
guards
element
pseudo
rule_inclusion
)
{
Some
(
rule_node
)
=
>
rule_node
None
=
>
return
None
}
;
let
computed
=
properties
:
:
cascade
(
&
self
.
device
&
rule_node
guards
Some
(
parent_style
)
Some
(
parent_style
)
None
None
&
create_error_reporter
(
)
font_metrics
CascadeFlags
:
:
empty
(
)
self
.
quirks_mode
)
;
Some
(
Arc
:
:
new
(
computed
)
)
}
pub
fn
lazy_pseudo_rules
<
E
>
(
&
self
guards
:
&
StylesheetGuards
element
:
&
E
pseudo
:
&
PseudoElement
rule_inclusion
:
RuleInclusion
)
-
>
Option
<
StrongRuleNode
>
where
E
:
TElement
{
let
pseudo
=
pseudo
.
canonical
(
)
;
debug_assert
!
(
pseudo
.
is_lazy
(
)
)
;
if
self
.
pseudos_map
.
get
(
&
pseudo
)
.
is_none
(
)
{
return
None
}
let
mut
set_selector_flags
=
|
element
:
&
E
flags
:
ElementSelectorFlags
|
{
if
cfg
!
(
feature
=
"
servo
"
)
{
unreachable
!
(
"
internal
pseudo
generated
slow
selector
flags
?
"
)
;
}
if
rule_inclusion
=
=
RuleInclusion
:
:
DefaultOnly
{
return
;
}
debug_assert
!
(
thread_state
:
:
get
(
)
=
=
thread_state
:
:
LAYOUT
)
;
let
self_flags
=
flags
.
for_self
(
)
;
if
!
self_flags
.
is_empty
(
)
{
unsafe
{
element
.
set_selector_flags
(
self_flags
)
;
}
}
let
parent_flags
=
flags
.
for_parent
(
)
;
if
!
parent_flags
.
is_empty
(
)
{
if
let
Some
(
p
)
=
element
.
parent_element
(
)
{
unsafe
{
p
.
set_selector_flags
(
parent_flags
)
;
}
}
}
}
;
let
mut
declarations
=
ApplicableDeclarationList
:
:
new
(
)
;
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
ForStatelessPseudoElement
None
self
.
quirks_mode
)
;
self
.
push_applicable_declarations
(
element
Some
(
&
pseudo
)
None
None
AnimationRules
(
None
None
)
rule_inclusion
&
mut
declarations
&
mut
matching_context
&
mut
set_selector_flags
)
;
if
declarations
.
is_empty
(
)
{
return
None
}
let
rule_node
=
self
.
rule_tree
.
insert_ordered_rules_with_important
(
declarations
.
into_iter
(
)
.
map
(
|
a
|
a
.
order_and_level
(
)
)
guards
)
;
if
rule_node
=
=
self
.
rule_tree
.
root
(
)
{
None
}
else
{
Some
(
rule_node
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
fn
set_device
(
&
mut
self
mut
device
:
Device
guard
:
&
SharedRwLockReadGuard
stylesheets
:
&
[
Arc
<
Stylesheet
>
]
)
{
let
cascaded_rule
=
ViewportRule
{
declarations
:
viewport_rule
:
:
Cascade
:
:
from_stylesheets
(
stylesheets
.
iter
(
)
guard
&
device
)
.
finish
(
)
}
;
self
.
viewport_constraints
=
ViewportConstraints
:
:
maybe_new
(
&
device
&
cascaded_rule
self
.
quirks_mode
)
;
if
let
Some
(
ref
constraints
)
=
self
.
viewport_constraints
{
device
.
account_for_viewport_rule
(
constraints
)
;
}
self
.
device
=
device
;
let
features_changed
=
self
.
media_features_change_changed_style
(
stylesheets
.
iter
(
)
guard
)
;
self
.
is_device_dirty
|
=
features_changed
;
}
pub
fn
media_features_change_changed_style
<
'
a
I
>
(
&
self
stylesheets
:
I
guard
:
&
SharedRwLockReadGuard
)
-
>
bool
where
I
:
Iterator
<
Item
=
&
'
a
Arc
<
Stylesheet
>
>
{
use
invalidation
:
:
media_queries
:
:
PotentiallyEffectiveMediaRules
;
debug
!
(
"
Stylist
:
:
media_features_change_changed_style
"
)
;
for
stylesheet
in
stylesheets
{
let
effective_now
=
stylesheet
.
media
.
read_with
(
guard
)
.
evaluate
(
&
self
.
device
self
.
quirks_mode
)
;
let
effective_then
=
self
.
effective_media_query_results
.
was_effective
(
&
*
*
stylesheet
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
Stylesheet
changed
-
>
{
}
{
}
"
effective_then
effective_now
)
;
return
true
}
if
!
effective_now
{
continue
;
}
let
mut
iter
=
stylesheet
.
iter_rules
:
:
<
PotentiallyEffectiveMediaRules
>
(
&
self
.
device
guard
)
;
while
let
Some
(
rule
)
=
iter
.
next
(
)
{
match
*
rule
{
CssRule
:
:
Style
(
.
.
)
|
CssRule
:
:
Namespace
(
.
.
)
|
CssRule
:
:
FontFace
(
.
.
)
|
CssRule
:
:
CounterStyle
(
.
.
)
|
CssRule
:
:
Supports
(
.
.
)
|
CssRule
:
:
Keyframes
(
.
.
)
|
CssRule
:
:
Page
(
.
.
)
|
CssRule
:
:
Viewport
(
.
.
)
|
CssRule
:
:
Document
(
.
.
)
=
>
{
continue
;
}
CssRule
:
:
Import
(
ref
lock
)
=
>
{
let
import_rule
=
lock
.
read_with
(
guard
)
;
let
mq
=
import_rule
.
stylesheet
.
media
.
read_with
(
guard
)
;
let
effective_now
=
mq
.
evaluate
(
&
self
.
device
self
.
quirks_mode
)
;
let
effective_then
=
self
.
effective_media_query_results
.
was_effective
(
import_rule
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
import
rule
changed
{
}
-
>
{
}
"
effective_then
effective_now
)
;
return
true
;
}
if
!
effective_now
{
iter
.
skip_children
(
)
;
}
}
CssRule
:
:
Media
(
ref
lock
)
=
>
{
let
media_rule
=
lock
.
read_with
(
guard
)
;
let
mq
=
media_rule
.
media_queries
.
read_with
(
guard
)
;
let
effective_now
=
mq
.
evaluate
(
&
self
.
device
self
.
quirks_mode
)
;
let
effective_then
=
self
.
effective_media_query_results
.
was_effective
(
media_rule
)
;
if
effective_now
!
=
effective_then
{
debug
!
(
"
>
media
rule
changed
{
}
-
>
{
}
"
effective_then
effective_now
)
;
return
true
;
}
if
!
effective_now
{
iter
.
skip_children
(
)
;
}
}
}
}
}
return
false
;
}
pub
fn
viewport_constraints
(
&
self
)
-
>
Option
<
&
ViewportConstraints
>
{
self
.
viewport_constraints
.
as_ref
(
)
}
pub
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
{
self
.
quirks_mode
}
pub
fn
set_quirks_mode
(
&
mut
self
quirks_mode
:
QuirksMode
)
{
self
.
quirks_mode
=
quirks_mode
;
}
fn
get_map
(
&
self
pseudo_element
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
PerPseudoElementSelectorMap
>
{
match
pseudo_element
{
Some
(
pseudo
)
=
>
self
.
pseudos_map
.
get
(
pseudo
)
None
=
>
Some
(
&
self
.
element_map
)
}
}
pub
fn
push_applicable_declarations_as_xbl_only_stylist
<
E
V
>
(
&
self
element
:
&
E
pseudo_element
:
Option
<
&
PseudoElement
>
applicable_declarations
:
&
mut
V
)
where
E
:
TElement
V
:
Push
<
ApplicableDeclarationBlock
>
+
VecLike
<
ApplicableDeclarationBlock
>
{
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
Normal
None
self
.
quirks_mode
)
;
let
mut
dummy_flag_setter
=
|
_
:
&
E
_
:
ElementSelectorFlags
|
{
}
;
let
map
=
match
self
.
get_map
(
pseudo_element
)
{
Some
(
map
)
=
>
map
None
=
>
return
}
;
let
rule_hash_target
=
element
.
rule_hash_target
(
)
;
map
.
author
.
get_all_matching_rules
(
element
&
rule_hash_target
applicable_declarations
&
mut
matching_context
self
.
quirks_mode
&
mut
dummy_flag_setter
CascadeLevel
:
:
XBL
)
;
}
pub
fn
push_applicable_declarations
<
E
V
F
>
(
&
self
element
:
&
E
pseudo_element
:
Option
<
&
PseudoElement
>
style_attribute
:
Option
<
&
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
smil_override
:
Option
<
&
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
animation_rules
:
AnimationRules
rule_inclusion
:
RuleInclusion
applicable_declarations
:
&
mut
V
context
:
&
mut
MatchingContext
flags_setter
:
&
mut
F
)
where
E
:
TElement
V
:
Push
<
ApplicableDeclarationBlock
>
+
VecLike
<
ApplicableDeclarationBlock
>
+
Debug
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
debug_assert
!
(
!
self
.
is_device_dirty
)
;
debug_assert
!
(
cfg
!
(
feature
=
"
gecko
"
)
|
|
style_attribute
.
is_none
(
)
|
|
pseudo_element
.
is_none
(
)
"
Style
attributes
do
not
apply
to
pseudo
-
elements
"
)
;
debug_assert
!
(
pseudo_element
.
map_or
(
true
|
p
|
!
p
.
is_precomputed
(
)
)
)
;
let
map
=
match
self
.
get_map
(
pseudo_element
)
{
Some
(
map
)
=
>
map
None
=
>
return
}
;
let
rule_hash_target
=
element
.
rule_hash_target
(
)
;
debug
!
(
"
Determining
if
style
is
shareable
:
pseudo
:
{
}
"
pseudo_element
.
is_some
(
)
)
;
let
only_default_rules
=
rule_inclusion
=
=
RuleInclusion
:
:
DefaultOnly
;
map
.
user_agent
.
get_all_matching_rules
(
element
&
rule_hash_target
applicable_declarations
context
self
.
quirks_mode
flags_setter
CascadeLevel
:
:
UANormal
)
;
debug
!
(
"
UA
normal
:
{
:
?
}
"
context
.
relations
)
;
if
pseudo_element
.
is_none
(
)
&
&
!
only_default_rules
{
let
length_before_preshints
=
applicable_declarations
.
len
(
)
;
element
.
synthesize_presentational_hints_for_legacy_attributes
(
context
.
visited_handling
applicable_declarations
)
;
if
applicable_declarations
.
len
(
)
!
=
length_before_preshints
{
if
cfg
!
(
debug_assertions
)
{
for
declaration
in
&
applicable_declarations
[
length_before_preshints
.
.
]
{
assert_eq
!
(
declaration
.
level
(
)
CascadeLevel
:
:
PresHints
)
;
}
}
context
.
relations
|
=
AFFECTED_BY_PRESENTATIONAL_HINTS
;
}
debug
!
(
"
preshints
:
{
:
?
}
"
context
.
relations
)
;
}
if
rule_hash_target
.
matches_user_and_author_rules
(
)
{
map
.
user
.
get_all_matching_rules
(
element
&
rule_hash_target
applicable_declarations
context
self
.
quirks_mode
flags_setter
CascadeLevel
:
:
UserNormal
)
;
debug
!
(
"
user
normal
:
{
:
?
}
"
context
.
relations
)
;
}
else
{
debug
!
(
"
skipping
user
rules
"
)
;
}
let
cut_off_inheritance
=
element
.
get_declarations_from_xbl_bindings
(
pseudo_element
applicable_declarations
)
;
debug
!
(
"
XBL
:
{
:
?
}
"
context
.
relations
)
;
if
rule_hash_target
.
matches_user_and_author_rules
(
)
&
&
!
only_default_rules
{
if
!
cut_off_inheritance
{
map
.
author
.
get_all_matching_rules
(
element
&
rule_hash_target
applicable_declarations
context
self
.
quirks_mode
flags_setter
CascadeLevel
:
:
AuthorNormal
)
;
debug
!
(
"
author
normal
:
{
:
?
}
"
context
.
relations
)
;
}
else
{
debug
!
(
"
skipping
author
normal
rules
due
to
cut
off
inheritance
"
)
;
}
}
else
{
debug
!
(
"
skipping
author
normal
rules
"
)
;
}
if
!
only_default_rules
{
if
let
Some
(
sa
)
=
style_attribute
{
Push
:
:
push
(
applicable_declarations
ApplicableDeclarationBlock
:
:
from_declarations
(
sa
.
clone
(
)
CascadeLevel
:
:
StyleAttributeNormal
)
)
;
}
debug
!
(
"
style
attr
:
{
:
?
}
"
context
.
relations
)
;
if
let
Some
(
so
)
=
smil_override
{
Push
:
:
push
(
applicable_declarations
ApplicableDeclarationBlock
:
:
from_declarations
(
so
.
clone
(
)
CascadeLevel
:
:
SMILOverride
)
)
;
}
debug
!
(
"
SMIL
:
{
:
?
}
"
context
.
relations
)
;
if
let
Some
(
anim
)
=
animation_rules
.
0
{
Push
:
:
push
(
applicable_declarations
ApplicableDeclarationBlock
:
:
from_declarations
(
anim
.
clone
(
)
CascadeLevel
:
:
Animations
)
)
;
}
debug
!
(
"
animation
:
{
:
?
}
"
context
.
relations
)
;
}
else
{
debug
!
(
"
skipping
style
attr
and
SMIL
&
animation
rules
"
)
;
}
if
!
only_default_rules
{
if
let
Some
(
anim
)
=
animation_rules
.
1
{
Push
:
:
push
(
applicable_declarations
ApplicableDeclarationBlock
:
:
from_declarations
(
anim
.
clone
(
)
CascadeLevel
:
:
Transitions
)
)
;
}
debug
!
(
"
transition
:
{
:
?
}
"
context
.
relations
)
;
}
else
{
debug
!
(
"
skipping
transition
rules
"
)
;
}
debug
!
(
"
push_applicable_declarations
:
shareable
:
{
:
?
}
"
context
.
relations
)
;
}
#
[
inline
]
pub
fn
may_have_rules_for_id
(
&
self
id
:
&
Atom
)
-
>
bool
{
self
.
mapped_ids
.
might_contain_hash
(
id
.
get_hash
(
)
)
}
#
[
inline
]
pub
fn
is_device_dirty
(
&
self
)
-
>
bool
{
self
.
is_device_dirty
}
#
[
inline
]
pub
fn
animations
(
&
self
)
-
>
&
FnvHashMap
<
Atom
KeyframesAnimation
>
{
&
self
.
animations
}
#
[
inline
]
pub
fn
rule_tree_root
(
&
self
)
-
>
StrongRuleNode
{
self
.
rule_tree
.
root
(
)
}
pub
fn
match_revalidation_selectors
<
E
F
>
(
&
self
element
:
&
E
bloom
:
Option
<
&
BloomFilter
>
flags_setter
:
&
mut
F
)
-
>
BitVec
where
E
:
TElement
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
Normal
bloom
self
.
quirks_mode
)
;
let
mut
results
=
BitVec
:
:
new
(
)
;
self
.
selectors_for_cache_revalidation
.
lookup
(
*
element
self
.
quirks_mode
&
mut
|
selector_and_hashes
|
{
results
.
push
(
matches_selector
(
&
selector_and_hashes
.
selector
selector_and_hashes
.
selector_offset
&
selector_and_hashes
.
hashes
element
&
mut
matching_context
flags_setter
)
)
;
true
}
)
;
results
}
pub
fn
compute_for_declarations
(
&
self
guards
:
&
StylesheetGuards
parent_style
:
&
Arc
<
ComputedValues
>
declarations
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
)
-
>
Arc
<
ComputedValues
>
{
use
font_metrics
:
:
get_metrics_provider_for_product
;
let
v
=
vec
!
[
ApplicableDeclarationBlock
:
:
from_declarations
(
declarations
.
clone
(
)
CascadeLevel
:
:
StyleAttributeNormal
)
]
;
let
rule_node
=
self
.
rule_tree
.
insert_ordered_rules
(
v
.
into_iter
(
)
.
map
(
|
a
|
a
.
order_and_level
(
)
)
)
;
let
metrics
=
get_metrics_provider_for_product
(
)
;
Arc
:
:
new
(
properties
:
:
cascade
(
&
self
.
device
&
rule_node
guards
Some
(
parent_style
)
Some
(
parent_style
)
None
None
&
create_error_reporter
(
)
&
metrics
CascadeFlags
:
:
empty
(
)
self
.
quirks_mode
)
)
}
pub
fn
device
(
&
self
)
-
>
&
Device
{
&
self
.
device
}
pub
fn
device_mut
(
&
mut
self
)
-
>
&
mut
Device
{
&
mut
self
.
device
}
pub
fn
rule_tree
(
&
self
)
-
>
&
RuleTree
{
&
self
.
rule_tree
}
}
impl
Drop
for
Stylist
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
rule_tree
.
gc
(
)
;
}
debug_assert
!
(
self
.
rule_tree
.
is_empty
(
)
)
;
}
}
struct
AttributeAndStateDependencyVisitor
<
'
a
>
{
attribute_dependencies
:
&
'
a
mut
BloomFilter
style_attribute_dependency
:
&
'
a
mut
bool
state_dependencies
:
&
'
a
mut
ElementState
}
impl
<
'
a
>
SelectorVisitor
for
AttributeAndStateDependencyVisitor
<
'
a
>
{
type
Impl
=
SelectorImpl
;
fn
visit_attribute_selector
(
&
mut
self
_ns
:
&
NamespaceConstraint
<
&
Namespace
>
name
:
&
LocalName
lower_name
:
&
LocalName
)
-
>
bool
{
if
*
lower_name
=
=
local_name
!
(
"
style
"
)
{
*
self
.
style_attribute_dependency
=
true
;
}
else
{
self
.
attribute_dependencies
.
insert_hash
(
name
.
get_hash
(
)
)
;
self
.
attribute_dependencies
.
insert_hash
(
lower_name
.
get_hash
(
)
)
;
}
true
}
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
if
let
Component
:
:
NonTSPseudoClass
(
ref
p
)
=
*
s
{
self
.
state_dependencies
.
insert
(
p
.
state_flag
(
)
)
;
}
true
}
}
struct
MappedIdVisitor
<
'
a
>
{
mapped_ids
:
&
'
a
mut
BloomFilter
}
impl
<
'
a
>
SelectorVisitor
for
MappedIdVisitor
<
'
a
>
{
type
Impl
=
SelectorImpl
;
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
if
let
Component
:
:
ID
(
ref
id
)
=
*
s
{
self
.
mapped_ids
.
insert_hash
(
id
.
get_hash
(
)
)
;
}
true
}
fn
visit_complex_selector
(
&
mut
self
_
:
SelectorIter
<
SelectorImpl
>
combinator
:
Option
<
Combinator
>
)
-
>
bool
{
match
combinator
{
None
|
Some
(
Combinator
:
:
PseudoElement
)
=
>
true
_
=
>
false
}
}
}
#
[
derive
(
Clone
Debug
)
]
struct
RevalidationSelectorAndHashes
{
selector
:
Selector
<
SelectorImpl
>
selector_offset
:
usize
hashes
:
AncestorHashes
}
impl
RevalidationSelectorAndHashes
{
fn
new
(
selector_and_hashes
:
&
SelectorAndHashes
<
SelectorImpl
>
)
-
>
Self
{
let
mut
index
=
0
;
let
mut
iter
=
selector_and_hashes
.
selector
.
iter
(
)
;
for
_
in
&
mut
iter
{
index
+
=
1
;
}
let
offset
=
match
iter
.
next_sequence
(
)
{
Some
(
Combinator
:
:
PseudoElement
)
=
>
index
+
1
_
=
>
0
}
;
RevalidationSelectorAndHashes
{
selector
:
selector_and_hashes
.
selector
.
clone
(
)
selector_offset
:
offset
hashes
:
selector_and_hashes
.
hashes
.
clone
(
)
}
}
}
impl
SelectorMapEntry
for
RevalidationSelectorAndHashes
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter_from
(
self
.
selector_offset
)
}
fn
hashes
(
&
self
)
-
>
&
AncestorHashes
{
&
self
.
hashes
}
}
struct
RevalidationVisitor
;
impl
SelectorVisitor
for
RevalidationVisitor
{
type
Impl
=
SelectorImpl
;
fn
visit_complex_selector
(
&
mut
self
_
:
SelectorIter
<
SelectorImpl
>
combinator
:
Option
<
Combinator
>
)
-
>
bool
{
let
is_sibling_combinator
=
combinator
.
map_or
(
false
|
c
|
c
.
is_sibling
(
)
)
;
!
is_sibling_combinator
}
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
SelectorImpl
>
)
-
>
bool
{
match
*
s
{
Component
:
:
AttributeInNoNamespaceExists
{
.
.
}
|
Component
:
:
AttributeInNoNamespace
{
.
.
}
|
Component
:
:
AttributeOther
(
_
)
|
Component
:
:
Empty
|
Component
:
:
ID
(
_
)
|
Component
:
:
FirstChild
|
Component
:
:
LastChild
|
Component
:
:
OnlyChild
|
Component
:
:
NthChild
(
.
.
)
|
Component
:
:
NthLastChild
(
.
.
)
|
Component
:
:
NthOfType
(
.
.
)
|
Component
:
:
NthLastOfType
(
.
.
)
|
Component
:
:
FirstOfType
|
Component
:
:
LastOfType
|
Component
:
:
OnlyOfType
=
>
{
false
}
Component
:
:
NonTSPseudoClass
(
ref
p
)
=
>
{
!
p
.
needs_cache_revalidation
(
)
}
_
=
>
{
true
}
}
}
}
pub
fn
needs_revalidation
(
selector
:
&
Selector
<
SelectorImpl
>
)
-
>
bool
{
let
mut
visitor
=
RevalidationVisitor
;
!
selector
.
visit
(
&
mut
visitor
)
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Debug
)
]
struct
PerPseudoElementSelectorMap
{
user_agent
:
SelectorMap
<
Rule
>
author
:
SelectorMap
<
Rule
>
user
:
SelectorMap
<
Rule
>
}
impl
PerPseudoElementSelectorMap
{
#
[
inline
]
fn
new
(
)
-
>
Self
{
PerPseudoElementSelectorMap
{
user_agent
:
SelectorMap
:
:
new
(
)
author
:
SelectorMap
:
:
new
(
)
user
:
SelectorMap
:
:
new
(
)
}
}
#
[
inline
]
fn
borrow_for_origin
(
&
mut
self
origin
:
&
Origin
)
-
>
&
mut
SelectorMap
<
Rule
>
{
match
*
origin
{
Origin
:
:
UserAgent
=
>
&
mut
self
.
user_agent
Origin
:
:
Author
=
>
&
mut
self
.
author
Origin
:
:
User
=
>
&
mut
self
.
user
}
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Clone
Debug
)
]
pub
struct
Rule
{
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
pub
selector
:
Selector
<
SelectorImpl
>
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
No
heap
data
"
)
]
pub
hashes
:
AncestorHashes
pub
source_order
:
u32
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
pub
style_rule
:
Arc
<
Locked
<
StyleRule
>
>
}
impl
SelectorMapEntry
for
Rule
{
fn
selector
(
&
self
)
-
>
SelectorIter
<
SelectorImpl
>
{
self
.
selector
.
iter
(
)
}
fn
hashes
(
&
self
)
-
>
&
AncestorHashes
{
&
self
.
hashes
}
}
impl
Rule
{
pub
fn
specificity
(
&
self
)
-
>
u32
{
self
.
selector
.
specificity
(
)
}
pub
fn
to_applicable_declaration_block
(
&
self
level
:
CascadeLevel
)
-
>
ApplicableDeclarationBlock
{
let
source
=
StyleSource
:
:
Style
(
self
.
style_rule
.
clone
(
)
)
;
ApplicableDeclarationBlock
:
:
new
(
source
self
.
source_order
level
self
.
specificity
(
)
)
}
pub
fn
new
(
selector
:
Selector
<
SelectorImpl
>
hashes
:
AncestorHashes
style_rule
:
Arc
<
Locked
<
StyleRule
>
>
source_order
:
u32
)
-
>
Self
{
Rule
{
selector
:
selector
hashes
:
hashes
style_rule
:
style_rule
source_order
:
source_order
}
}
}
