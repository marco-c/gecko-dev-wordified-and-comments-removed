use
context
:
:
QuirksMode
;
use
dom
:
:
{
TDocument
TElement
TNode
}
;
use
invalidation
:
:
element
:
:
invalidator
:
:
{
Invalidation
InvalidationProcessor
InvalidationVector
}
;
use
selectors
:
:
{
Element
NthIndexCache
SelectorList
}
;
use
selectors
:
:
matching
:
:
{
self
MatchingContext
MatchingMode
}
;
use
smallvec
:
:
SmallVec
;
pub
fn
element_matches
<
E
>
(
element
:
&
E
selector_list
:
&
SelectorList
<
E
:
:
Impl
>
quirks_mode
:
QuirksMode
)
-
>
bool
where
E
:
Element
{
let
mut
context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
Normal
None
None
quirks_mode
)
;
context
.
scope_element
=
Some
(
element
.
opaque
(
)
)
;
matching
:
:
matches_selector_list
(
selector_list
element
&
mut
context
)
}
pub
fn
element_closest
<
E
>
(
element
:
E
selector_list
:
&
SelectorList
<
E
:
:
Impl
>
quirks_mode
:
QuirksMode
)
-
>
Option
<
E
>
where
E
:
Element
{
let
mut
nth_index_cache
=
NthIndexCache
:
:
default
(
)
;
let
mut
context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
Normal
None
Some
(
&
mut
nth_index_cache
)
quirks_mode
)
;
context
.
scope_element
=
Some
(
element
.
opaque
(
)
)
;
let
mut
current
=
Some
(
element
)
;
while
let
Some
(
element
)
=
current
.
take
(
)
{
if
matching
:
:
matches_selector_list
(
selector_list
&
element
&
mut
context
)
{
return
Some
(
element
)
;
}
current
=
element
.
parent_element
(
)
;
}
return
None
;
}
pub
trait
SelectorQuery
<
E
:
TElement
>
{
type
Output
;
fn
should_stop_after_first_match
(
)
-
>
bool
;
fn
append_element
(
output
:
&
mut
Self
:
:
Output
element
:
E
)
;
fn
is_empty
(
output
:
&
Self
:
:
Output
)
-
>
bool
;
}
pub
type
QuerySelectorAllResult
<
E
>
=
SmallVec
<
[
E
;
128
]
>
;
pub
struct
QueryAll
;
impl
<
E
:
TElement
>
SelectorQuery
<
E
>
for
QueryAll
{
type
Output
=
QuerySelectorAllResult
<
E
>
;
fn
should_stop_after_first_match
(
)
-
>
bool
{
false
}
fn
append_element
(
output
:
&
mut
Self
:
:
Output
element
:
E
)
{
output
.
push
(
element
)
;
}
fn
is_empty
(
output
:
&
Self
:
:
Output
)
-
>
bool
{
output
.
is_empty
(
)
}
}
pub
struct
QueryFirst
;
impl
<
E
:
TElement
>
SelectorQuery
<
E
>
for
QueryFirst
{
type
Output
=
Option
<
E
>
;
fn
should_stop_after_first_match
(
)
-
>
bool
{
true
}
fn
append_element
(
output
:
&
mut
Self
:
:
Output
element
:
E
)
{
if
output
.
is_none
(
)
{
*
output
=
Some
(
element
)
}
}
fn
is_empty
(
output
:
&
Self
:
:
Output
)
-
>
bool
{
output
.
is_none
(
)
}
}
struct
QuerySelectorProcessor
<
'
a
E
Q
>
where
E
:
TElement
+
'
a
Q
:
SelectorQuery
<
E
>
Q
:
:
Output
:
'
a
{
results
:
&
'
a
mut
Q
:
:
Output
matching_context
:
MatchingContext
<
'
a
E
:
:
Impl
>
selector_list
:
&
'
a
SelectorList
<
E
:
:
Impl
>
}
impl
<
'
a
E
Q
>
InvalidationProcessor
<
'
a
E
>
for
QuerySelectorProcessor
<
'
a
E
Q
>
where
E
:
TElement
+
'
a
Q
:
SelectorQuery
<
E
>
Q
:
:
Output
:
'
a
{
fn
light_tree_only
(
&
self
)
-
>
bool
{
true
}
fn
collect_invalidations
(
&
mut
self
element
:
E
self_invalidations
:
&
mut
InvalidationVector
<
'
a
>
descendant_invalidations
:
&
mut
InvalidationVector
<
'
a
>
_sibling_invalidations
:
&
mut
InvalidationVector
<
'
a
>
)
-
>
bool
{
debug_assert
!
(
element
.
parent_element
(
)
.
is_none
(
)
)
;
let
target_vector
=
if
self
.
matching_context
.
scope_element
.
is_some
(
)
{
descendant_invalidations
}
else
{
self_invalidations
}
;
for
selector
in
self
.
selector_list
.
0
.
iter
(
)
{
target_vector
.
push
(
Invalidation
:
:
new
(
selector
0
)
)
}
false
}
fn
matching_context
(
&
mut
self
)
-
>
&
mut
MatchingContext
<
'
a
E
:
:
Impl
>
{
&
mut
self
.
matching_context
}
fn
should_process_descendants
(
&
mut
self
_
:
E
)
-
>
bool
{
if
Q
:
:
should_stop_after_first_match
(
)
{
return
Q
:
:
is_empty
(
&
self
.
results
)
}
true
}
fn
invalidated_self
(
&
mut
self
e
:
E
)
{
Q
:
:
append_element
(
self
.
results
e
)
;
}
fn
recursion_limit_exceeded
(
&
mut
self
_e
:
E
)
{
}
fn
invalidated_descendants
(
&
mut
self
_e
:
E
_child
:
E
)
{
}
}
fn
collect_all_elements
<
E
Q
F
>
(
root
:
E
:
:
ConcreteNode
results
:
&
mut
Q
:
:
Output
mut
filter
:
F
)
where
E
:
TElement
Q
:
SelectorQuery
<
E
>
F
:
FnMut
(
E
)
-
>
bool
{
for
node
in
root
.
dom_descendants
(
)
{
let
element
=
match
node
.
as_element
(
)
{
Some
(
e
)
=
>
e
None
=
>
continue
}
;
if
!
filter
(
element
)
{
continue
;
}
Q
:
:
append_element
(
results
element
)
;
if
Q
:
:
should_stop_after_first_match
(
)
{
return
;
}
}
}
fn
query_selector_fast
<
E
Q
>
(
root
:
E
:
:
ConcreteNode
selector_list
:
&
SelectorList
<
E
:
:
Impl
>
results
:
&
mut
Q
:
:
Output
quirks_mode
:
QuirksMode
)
-
>
Result
<
(
)
(
)
>
where
E
:
TElement
Q
:
SelectorQuery
<
E
>
{
use
selectors
:
:
parser
:
:
{
Component
LocalName
}
;
use
std
:
:
borrow
:
:
Borrow
;
if
selector_list
.
0
.
len
(
)
>
1
{
return
Err
(
(
)
)
;
}
let
selector
=
&
selector_list
.
0
[
0
]
;
if
selector
.
len
(
)
>
1
{
return
Err
(
(
)
)
;
}
let
component
=
selector
.
iter
(
)
.
next
(
)
.
unwrap
(
)
;
match
*
component
{
Component
:
:
ExplicitUniversalType
=
>
{
collect_all_elements
:
:
<
E
Q
_
>
(
root
results
|
_
|
true
)
}
Component
:
:
ID
(
ref
id
)
=
>
{
let
case_sensitivity
=
quirks_mode
.
classes_and_ids_case_sensitivity
(
)
;
collect_all_elements
:
:
<
E
Q
_
>
(
root
results
|
element
|
{
element
.
has_id
(
id
case_sensitivity
)
}
)
}
Component
:
:
Class
(
ref
class
)
=
>
{
let
case_sensitivity
=
quirks_mode
.
classes_and_ids_case_sensitivity
(
)
;
collect_all_elements
:
:
<
E
Q
_
>
(
root
results
|
element
|
{
element
.
has_class
(
class
case_sensitivity
)
}
)
}
Component
:
:
LocalName
(
LocalName
{
ref
name
ref
lower_name
}
)
=
>
{
collect_all_elements
:
:
<
E
Q
_
>
(
root
results
|
element
|
{
if
element
.
is_html_element_in_html_document
(
)
{
element
.
get_local_name
(
)
=
=
lower_name
.
borrow
(
)
}
else
{
element
.
get_local_name
(
)
=
=
name
.
borrow
(
)
}
}
)
}
_
=
>
{
return
Err
(
(
)
)
}
}
Ok
(
(
)
)
}
fn
query_selector_slow
<
E
Q
>
(
root
:
E
:
:
ConcreteNode
selector_list
:
&
SelectorList
<
E
:
:
Impl
>
results
:
&
mut
Q
:
:
Output
matching_context
:
&
mut
MatchingContext
<
E
:
:
Impl
>
)
where
E
:
TElement
Q
:
SelectorQuery
<
E
>
{
collect_all_elements
:
:
<
E
Q
_
>
(
root
results
|
element
|
{
matching
:
:
matches_selector_list
(
selector_list
&
element
matching_context
)
}
)
;
}
pub
fn
query_selector
<
E
Q
>
(
root
:
E
:
:
ConcreteNode
selector_list
:
&
SelectorList
<
E
:
:
Impl
>
results
:
&
mut
Q
:
:
Output
)
where
E
:
TElement
Q
:
SelectorQuery
<
E
>
{
use
invalidation
:
:
element
:
:
invalidator
:
:
TreeStyleInvalidator
;
let
quirks_mode
=
root
.
owner_doc
(
)
.
quirks_mode
(
)
;
let
fast_result
=
query_selector_fast
:
:
<
E
Q
>
(
root
selector_list
results
quirks_mode
)
;
if
fast_result
.
is_ok
(
)
{
return
;
}
let
mut
nth_index_cache
=
NthIndexCache
:
:
default
(
)
;
let
mut
matching_context
=
MatchingContext
:
:
new
(
MatchingMode
:
:
Normal
None
Some
(
&
mut
nth_index_cache
)
quirks_mode
)
;
let
root_element
=
root
.
as_element
(
)
;
matching_context
.
scope_element
=
root_element
.
map
(
|
e
|
e
.
opaque
(
)
)
;
let
invalidation_may_be_useful
=
selector_list
.
0
.
iter
(
)
.
any
(
|
s
|
s
.
len
(
)
>
1
)
;
if
root_element
.
is_some
(
)
|
|
!
invalidation_may_be_useful
{
query_selector_slow
:
:
<
E
Q
>
(
root
selector_list
results
&
mut
matching_context
)
;
}
else
{
let
mut
processor
=
QuerySelectorProcessor
:
:
<
E
Q
>
{
results
matching_context
selector_list
}
;
for
node
in
root
.
dom_children
(
)
{
if
let
Some
(
e
)
=
node
.
as_element
(
)
{
TreeStyleInvalidator
:
:
new
(
e
None
&
mut
processor
)
.
invalidate
(
)
;
}
}
}
}
