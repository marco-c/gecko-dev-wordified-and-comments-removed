use
fnv
:
:
FnvHashMap
;
use
logical_geometry
:
:
WritingMode
;
use
properties
:
:
{
ComputedValues
StyleBuilder
}
;
use
rule_tree
:
:
StrongRuleNode
;
use
selector_parser
:
:
PseudoElement
;
use
servo_arc
:
:
Arc
;
use
smallvec
:
:
SmallVec
;
use
values
:
:
computed
:
:
NonNegativeLength
;
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
RuleCacheConditions
{
uncacheable
:
bool
font_size
:
Option
<
NonNegativeLength
>
writing_mode
:
Option
<
WritingMode
>
}
impl
RuleCacheConditions
{
pub
fn
set_font_size_dependency
(
&
mut
self
font_size
:
NonNegativeLength
)
{
debug_assert
!
(
self
.
font_size
.
map_or
(
true
|
f
|
f
=
=
font_size
)
)
;
self
.
font_size
=
Some
(
font_size
)
;
}
pub
fn
set_uncacheable
(
&
mut
self
)
{
self
.
uncacheable
=
true
;
}
pub
fn
set_writing_mode_dependency
(
&
mut
self
writing_mode
:
WritingMode
)
{
debug_assert
!
(
self
.
writing_mode
.
map_or
(
true
|
wm
|
wm
=
=
writing_mode
)
)
;
self
.
writing_mode
=
Some
(
writing_mode
)
;
}
fn
cacheable
(
&
self
)
-
>
bool
{
!
self
.
uncacheable
}
fn
matches
(
&
self
style
:
&
StyleBuilder
)
-
>
bool
{
if
self
.
uncacheable
{
return
false
;
}
if
let
Some
(
fs
)
=
self
.
font_size
{
if
style
.
get_font
(
)
.
clone_font_size
(
)
.
size
!
=
fs
{
return
false
;
}
}
if
let
Some
(
wm
)
=
self
.
writing_mode
{
if
style
.
writing_mode
!
=
wm
{
return
false
;
}
}
true
}
}
pub
struct
RuleCache
{
map
:
FnvHashMap
<
StrongRuleNode
SmallVec
<
[
(
RuleCacheConditions
Arc
<
ComputedValues
>
)
;
1
]
>
>
}
impl
RuleCache
{
pub
fn
new
(
)
-
>
Self
{
Self
{
map
:
FnvHashMap
:
:
default
(
)
}
}
pub
fn
find
(
&
self
builder_with_early_props
:
&
StyleBuilder
)
-
>
Option
<
&
ComputedValues
>
{
if
builder_with_early_props
.
is_style_if_visited
(
)
{
return
None
;
}
if
builder_with_early_props
.
pseudo
.
and_then
(
|
p
|
p
.
property_restriction
(
)
)
.
is_some
(
)
{
return
None
;
}
let
rules
=
match
builder_with_early_props
.
rules
{
Some
(
ref
rules
)
=
>
rules
None
=
>
return
None
}
;
self
.
map
.
get
(
rules
)
.
and_then
(
|
cached_values
|
{
for
&
(
ref
conditions
ref
values
)
in
cached_values
.
iter
(
)
{
if
conditions
.
matches
(
builder_with_early_props
)
{
debug
!
(
"
Using
cached
reset
style
with
conditions
{
:
?
}
"
conditions
)
;
return
Some
(
&
*
*
values
)
}
}
None
}
)
}
pub
fn
insert_if_possible
(
&
mut
self
style
:
&
Arc
<
ComputedValues
>
pseudo
:
Option
<
&
PseudoElement
>
conditions
:
&
RuleCacheConditions
)
-
>
bool
{
if
!
conditions
.
cacheable
(
)
{
return
false
;
}
if
style
.
is_style_if_visited
(
)
{
return
false
;
}
if
pseudo
.
and_then
(
|
p
|
p
.
property_restriction
(
)
)
.
is_some
(
)
{
return
false
;
}
let
rules
=
match
style
.
rules
{
Some
(
ref
r
)
=
>
r
.
clone
(
)
None
=
>
return
false
}
;
debug
!
(
"
Inserting
cached
reset
style
with
conditions
{
:
?
}
"
conditions
)
;
self
.
map
.
entry
(
rules
)
.
or_insert_with
(
SmallVec
:
:
new
)
.
push
(
(
conditions
.
clone
(
)
style
.
clone
(
)
)
)
;
true
}
}
