use
crate
:
:
logical_geometry
:
:
WritingMode
;
use
crate
:
:
properties
:
:
{
ComputedValues
StyleBuilder
}
;
use
crate
:
:
rule_tree
:
:
StrongRuleNode
;
use
crate
:
:
selector_parser
:
:
PseudoElement
;
use
crate
:
:
shared_lock
:
:
StylesheetGuards
;
use
crate
:
:
values
:
:
computed
:
:
NonNegativeLength
;
use
fxhash
:
:
FxHashMap
;
use
servo_arc
:
:
Arc
;
use
smallvec
:
:
SmallVec
;
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
RuleCacheConditions
{
uncacheable
:
bool
font_size
:
Option
<
NonNegativeLength
>
writing_mode
:
Option
<
WritingMode
>
}
impl
RuleCacheConditions
{
pub
fn
set_font_size_dependency
(
&
mut
self
font_size
:
NonNegativeLength
)
{
debug_assert
!
(
self
.
font_size
.
map_or
(
true
|
f
|
f
=
=
font_size
)
)
;
self
.
font_size
=
Some
(
font_size
)
;
}
pub
fn
set_uncacheable
(
&
mut
self
)
{
self
.
uncacheable
=
true
;
}
pub
fn
set_writing_mode_dependency
(
&
mut
self
writing_mode
:
WritingMode
)
{
debug_assert
!
(
self
.
writing_mode
.
map_or
(
true
|
wm
|
wm
=
=
writing_mode
)
)
;
self
.
writing_mode
=
Some
(
writing_mode
)
;
}
fn
cacheable
(
&
self
)
-
>
bool
{
!
self
.
uncacheable
}
fn
matches
(
&
self
style
:
&
StyleBuilder
)
-
>
bool
{
if
self
.
uncacheable
{
return
false
;
}
if
let
Some
(
fs
)
=
self
.
font_size
{
if
style
.
get_font
(
)
.
clone_font_size
(
)
.
size
!
=
fs
{
return
false
;
}
}
if
let
Some
(
wm
)
=
self
.
writing_mode
{
if
style
.
writing_mode
!
=
wm
{
return
false
;
}
}
true
}
}
pub
struct
RuleCache
{
map
:
FxHashMap
<
StrongRuleNode
SmallVec
<
[
(
RuleCacheConditions
Arc
<
ComputedValues
>
)
;
1
]
>
>
}
impl
RuleCache
{
pub
fn
new
(
)
-
>
Self
{
Self
{
map
:
FxHashMap
:
:
default
(
)
}
}
fn
get_rule_node_for_cache
<
'
r
>
(
guards
:
&
StylesheetGuards
mut
rule_node
:
Option
<
&
'
r
StrongRuleNode
>
)
-
>
Option
<
&
'
r
StrongRuleNode
>
{
while
let
Some
(
node
)
=
rule_node
{
match
node
.
style_source
(
)
{
Some
(
s
)
=
>
match
s
.
as_declarations
(
)
{
Some
(
decls
)
=
>
{
let
cascade_level
=
node
.
cascade_level
(
)
;
let
decls
=
decls
.
read_with
(
cascade_level
.
guard
(
guards
)
)
;
if
decls
.
contains_any_reset
(
)
{
break
;
}
}
None
=
>
break
}
None
=
>
{
}
}
rule_node
=
node
.
parent
(
)
;
}
rule_node
}
pub
fn
find
(
&
self
guards
:
&
StylesheetGuards
builder_with_early_props
:
&
StyleBuilder
)
-
>
Option
<
&
ComputedValues
>
{
if
builder_with_early_props
.
pseudo
.
and_then
(
|
p
|
p
.
property_restriction
(
)
)
.
is_some
(
)
{
return
None
;
}
let
rules
=
builder_with_early_props
.
rules
.
as_ref
(
)
;
let
rules
=
Self
:
:
get_rule_node_for_cache
(
guards
rules
)
?
;
let
cached_values
=
self
.
map
.
get
(
rules
)
?
;
for
&
(
ref
conditions
ref
values
)
in
cached_values
.
iter
(
)
{
if
conditions
.
matches
(
builder_with_early_props
)
{
debug
!
(
"
Using
cached
reset
style
with
conditions
{
:
?
}
"
conditions
)
;
return
Some
(
&
*
*
values
)
;
}
}
None
}
pub
fn
insert_if_possible
(
&
mut
self
guards
:
&
StylesheetGuards
style
:
&
Arc
<
ComputedValues
>
pseudo
:
Option
<
&
PseudoElement
>
conditions
:
&
RuleCacheConditions
)
-
>
bool
{
if
!
conditions
.
cacheable
(
)
{
return
false
;
}
if
pseudo
.
and_then
(
|
p
|
p
.
property_restriction
(
)
)
.
is_some
(
)
{
return
false
;
}
let
rules
=
style
.
rules
.
as_ref
(
)
;
let
rules
=
match
Self
:
:
get_rule_node_for_cache
(
guards
rules
)
{
Some
(
r
)
=
>
r
.
clone
(
)
None
=
>
return
false
}
;
debug
!
(
"
Inserting
cached
reset
style
with
conditions
{
:
?
}
"
conditions
)
;
self
.
map
.
entry
(
rules
)
.
or_insert_with
(
SmallVec
:
:
new
)
.
push
(
(
conditions
.
clone
(
)
style
.
clone
(
)
)
)
;
true
}
}
