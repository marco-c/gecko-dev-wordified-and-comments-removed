use
crate
:
:
derives
:
:
*
;
use
crate
:
:
dom
:
:
TElement
;
use
crate
:
:
shared_lock
:
:
SharedRwLockReadGuard
;
use
crate
:
:
stylesheet_set
:
:
AuthorStylesheetSet
;
use
crate
:
:
stylesheets
:
:
StylesheetInDocument
;
use
crate
:
:
stylist
:
:
CascadeData
;
use
crate
:
:
stylist
:
:
CascadeDataDifference
;
use
crate
:
:
stylist
:
:
Stylist
;
use
servo_arc
:
:
Arc
;
use
std
:
:
sync
:
:
LazyLock
;
#
[
derive
(
MallocSizeOf
)
]
pub
struct
GenericAuthorStyles
<
S
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
pub
stylesheets
:
AuthorStylesheetSet
<
S
>
#
[
ignore_malloc_size_of
=
"
Measured
as
part
of
the
stylist
"
]
pub
data
:
Arc
<
CascadeData
>
}
pub
use
self
:
:
GenericAuthorStyles
as
AuthorStyles
;
static
EMPTY_CASCADE_DATA
:
LazyLock
<
Arc
<
CascadeData
>
>
=
LazyLock
:
:
new
(
|
|
Arc
:
:
new_leaked
(
CascadeData
:
:
new
(
)
)
)
;
impl
<
S
>
GenericAuthorStyles
<
S
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Self
{
stylesheets
:
AuthorStylesheetSet
:
:
new
(
)
data
:
EMPTY_CASCADE_DATA
.
clone
(
)
}
}
#
[
inline
]
pub
fn
flush
<
E
>
(
&
mut
self
stylist
:
&
mut
Stylist
guard
:
&
SharedRwLockReadGuard
)
-
>
CascadeDataDifference
where
E
:
TElement
{
let
flusher
=
self
.
stylesheets
.
flush
:
:
<
E
>
(
None
None
)
;
let
mut
difference
=
CascadeDataDifference
:
:
default
(
)
;
let
result
=
stylist
.
rebuild_author_data
(
&
self
.
data
flusher
.
sheets
guard
&
mut
difference
)
;
if
let
Ok
(
Some
(
new_data
)
)
=
result
{
self
.
data
=
new_data
;
}
difference
}
}
