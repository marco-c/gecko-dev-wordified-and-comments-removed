use
crate
:
:
dom
:
:
TElement
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
gecko_bindings
:
:
sugar
:
:
ownership
:
:
{
HasBoxFFI
HasFFI
HasSimpleFFI
}
;
use
crate
:
:
invalidation
:
:
media_queries
:
:
ToMediaListKey
;
use
crate
:
:
shared_lock
:
:
SharedRwLockReadGuard
;
use
crate
:
:
stylist
:
:
Stylist
;
use
crate
:
:
stylesheet_set
:
:
AuthorStylesheetSet
;
use
crate
:
:
stylesheets
:
:
StylesheetInDocument
;
use
crate
:
:
stylist
:
:
CascadeData
;
use
servo_arc
:
:
Arc
;
#
[
derive
(
MallocSizeOf
)
]
pub
struct
AuthorStyles
<
S
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
pub
stylesheets
:
AuthorStylesheetSet
<
S
>
#
[
ignore_malloc_size_of
=
"
Measured
as
part
of
the
stylist
"
]
pub
data
:
Arc
<
CascadeData
>
}
lazy_static
!
{
static
ref
EMPTY_CASCADE_DATA
:
Arc
<
CascadeData
>
=
{
Arc
:
:
new_leaked
(
CascadeData
:
:
new
(
)
)
}
;
}
impl
<
S
>
AuthorStyles
<
S
>
where
S
:
StylesheetInDocument
+
PartialEq
+
'
static
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Self
{
stylesheets
:
AuthorStylesheetSet
:
:
new
(
)
data
:
EMPTY_CASCADE_DATA
.
clone
(
)
}
}
#
[
inline
]
pub
fn
flush
<
E
>
(
&
mut
self
stylist
:
&
mut
Stylist
guard
:
&
SharedRwLockReadGuard
)
where
E
:
TElement
S
:
ToMediaListKey
{
let
flusher
=
self
.
stylesheets
.
flush
:
:
<
E
>
(
None
None
)
;
let
result
=
stylist
.
rebuild_author_data
(
&
self
.
data
flusher
.
sheets
guard
)
;
if
let
Ok
(
Some
(
new_data
)
)
=
result
{
self
.
data
=
new_data
;
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
unsafe
impl
HasFFI
for
AuthorStyles
<
crate
:
:
gecko
:
:
data
:
:
GeckoStyleSheet
>
{
type
FFIType
=
crate
:
:
gecko_bindings
:
:
structs
:
:
RawServoAuthorStyles
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
unsafe
impl
HasSimpleFFI
for
AuthorStyles
<
crate
:
:
gecko
:
:
data
:
:
GeckoStyleSheet
>
{
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
unsafe
impl
HasBoxFFI
for
AuthorStyles
<
crate
:
:
gecko
:
:
data
:
:
GeckoStyleSheet
>
{
}
