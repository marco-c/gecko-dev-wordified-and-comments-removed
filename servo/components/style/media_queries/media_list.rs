use
super
:
:
{
Device
MediaQuery
Qualifier
}
;
use
crate
:
:
context
:
:
QuirksMode
;
use
crate
:
:
error_reporting
:
:
ContextualParseError
;
use
crate
:
:
parser
:
:
ParserContext
;
use
crate
:
:
values
:
:
computed
;
use
cssparser
:
:
{
Delimiter
Parser
}
;
use
cssparser
:
:
{
ParserInput
Token
}
;
use
selectors
:
:
kleene_value
:
:
KleeneValue
;
#
[
derive
(
Clone
MallocSizeOf
ToCss
ToShmem
)
]
#
[
css
(
comma
derive_debug
)
]
pub
struct
MediaList
{
#
[
css
(
iterable
)
]
pub
media_queries
:
Vec
<
MediaQuery
>
}
impl
MediaList
{
pub
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Self
{
if
input
.
is_exhausted
(
)
{
return
Self
:
:
empty
(
)
;
}
let
mut
media_queries
=
vec
!
[
]
;
loop
{
let
start_position
=
input
.
position
(
)
;
match
input
.
parse_until_before
(
Delimiter
:
:
Comma
|
i
|
MediaQuery
:
:
parse
(
context
i
)
)
{
Ok
(
mq
)
=
>
{
media_queries
.
push
(
mq
)
;
}
Err
(
err
)
=
>
{
media_queries
.
push
(
MediaQuery
:
:
never_matching
(
)
)
;
let
location
=
err
.
location
;
let
error
=
ContextualParseError
:
:
InvalidMediaRule
(
input
.
slice_from
(
start_position
)
err
)
;
context
.
log_css_error
(
location
error
)
;
}
}
match
input
.
next
(
)
{
Ok
(
&
Token
:
:
Comma
)
=
>
{
}
Ok
(
_
)
=
>
unreachable
!
(
)
Err
(
_
)
=
>
break
}
}
MediaList
{
media_queries
}
}
pub
fn
empty
(
)
-
>
Self
{
MediaList
{
media_queries
:
vec
!
[
]
}
}
pub
fn
evaluate
(
&
self
device
:
&
Device
quirks_mode
:
QuirksMode
)
-
>
bool
{
if
self
.
media_queries
.
is_empty
(
)
{
return
true
;
}
computed
:
:
Context
:
:
for_media_query_evaluation
(
device
quirks_mode
|
context
|
{
self
.
media_queries
.
iter
(
)
.
any
(
|
mq
|
{
let
mut
query_match
=
if
mq
.
media_type
.
matches
(
device
.
media_type
(
)
)
{
mq
.
condition
.
as_ref
(
)
.
map_or
(
KleeneValue
:
:
True
|
c
|
c
.
matches
(
context
)
)
}
else
{
KleeneValue
:
:
False
}
;
if
matches
!
(
mq
.
qualifier
Some
(
Qualifier
:
:
Not
)
)
{
query_match
=
!
query_match
;
}
query_match
.
to_bool
(
false
)
}
)
}
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
media_queries
.
is_empty
(
)
}
pub
fn
is_viewport_dependent
(
&
self
)
-
>
bool
{
self
.
media_queries
.
iter
(
)
.
any
(
|
q
|
q
.
is_viewport_dependent
(
)
)
}
pub
fn
append_medium
(
&
mut
self
context
:
&
ParserContext
new_medium
:
&
str
)
-
>
bool
{
let
mut
input
=
ParserInput
:
:
new
(
new_medium
)
;
let
mut
parser
=
Parser
:
:
new
(
&
mut
input
)
;
let
new_query
=
match
MediaQuery
:
:
parse
(
&
context
&
mut
parser
)
{
Ok
(
query
)
=
>
query
Err
(
_
)
=
>
{
return
false
;
}
}
;
self
.
media_queries
.
retain
(
|
query
|
query
!
=
&
new_query
)
;
self
.
media_queries
.
push
(
new_query
)
;
true
}
pub
fn
delete_medium
(
&
mut
self
context
:
&
ParserContext
old_medium
:
&
str
)
-
>
bool
{
let
mut
input
=
ParserInput
:
:
new
(
old_medium
)
;
let
mut
parser
=
Parser
:
:
new
(
&
mut
input
)
;
let
old_query
=
match
MediaQuery
:
:
parse
(
context
&
mut
parser
)
{
Ok
(
query
)
=
>
query
Err
(
_
)
=
>
{
return
false
;
}
}
;
let
old_len
=
self
.
media_queries
.
len
(
)
;
self
.
media_queries
.
retain
(
|
query
|
query
!
=
&
old_query
)
;
old_len
!
=
self
.
media_queries
.
len
(
)
}
}
