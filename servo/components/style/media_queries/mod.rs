use
Atom
;
use
context
:
:
QuirksMode
;
use
cssparser
:
:
{
Delimiter
Parser
}
;
use
cssparser
:
:
{
ParserInput
Token
}
;
use
error_reporting
:
:
{
ContextualParseError
ParseErrorReporter
}
;
use
parser
:
:
{
ParserContext
ParserErrorContext
}
;
use
selectors
:
:
parser
:
:
SelectorParseErrorKind
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
str
:
:
string_as_ascii_lowercase
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
use
values
:
:
CustomIdent
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
use
servo
:
:
media_queries
:
:
{
Device
Expression
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
gecko
:
:
media_queries
:
:
{
Device
Expression
}
;
#
[
css
(
comma
)
]
#
[
derive
(
Clone
Debug
MallocSizeOf
ToCss
)
]
pub
struct
MediaList
{
#
[
css
(
iterable
)
]
pub
media_queries
:
Vec
<
MediaQuery
>
}
impl
MediaList
{
pub
fn
empty
(
)
-
>
Self
{
MediaList
{
media_queries
:
vec
!
[
]
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
ToCss
)
]
pub
enum
Qualifier
{
Only
Not
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
)
]
pub
struct
MediaQuery
{
pub
qualifier
:
Option
<
Qualifier
>
pub
media_type
:
MediaQueryType
pub
expressions
:
Vec
<
Expression
>
}
impl
MediaQuery
{
fn
never_matching
(
)
-
>
Self
{
Self
{
qualifier
:
Some
(
Qualifier
:
:
Not
)
media_type
:
MediaQueryType
:
:
All
expressions
:
vec
!
[
]
}
}
}
impl
ToCss
for
MediaQuery
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
let
Some
(
qual
)
=
self
.
qualifier
{
qual
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
}
match
self
.
media_type
{
MediaQueryType
:
:
All
=
>
{
if
self
.
qualifier
.
is_some
(
)
|
|
self
.
expressions
.
is_empty
(
)
{
dest
.
write_str
(
"
all
"
)
?
;
}
}
MediaQueryType
:
:
Concrete
(
MediaType
(
ref
desc
)
)
=
>
desc
.
to_css
(
dest
)
?
}
if
self
.
expressions
.
is_empty
(
)
{
return
Ok
(
(
)
)
;
}
if
self
.
media_type
!
=
MediaQueryType
:
:
All
|
|
self
.
qualifier
.
is_some
(
)
{
dest
.
write_str
(
"
and
"
)
?
;
}
self
.
expressions
[
0
]
.
to_css
(
dest
)
?
;
for
expr
in
self
.
expressions
.
iter
(
)
.
skip
(
1
)
{
dest
.
write_str
(
"
and
"
)
?
;
expr
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
)
]
pub
enum
MediaQueryType
{
All
Concrete
(
MediaType
)
}
impl
MediaQueryType
{
fn
parse
(
ident
:
&
str
)
-
>
Result
<
Self
(
)
>
{
match_ignore_ascii_case
!
{
ident
"
all
"
=
>
return
Ok
(
MediaQueryType
:
:
All
)
_
=
>
(
)
}
;
MediaType
:
:
parse
(
ident
)
.
map
(
MediaQueryType
:
:
Concrete
)
}
fn
matches
(
&
self
other
:
MediaType
)
-
>
bool
{
match
*
self
{
MediaQueryType
:
:
All
=
>
true
MediaQueryType
:
:
Concrete
(
ref
known_type
)
=
>
*
known_type
=
=
other
}
}
}
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
)
]
pub
struct
MediaType
(
pub
CustomIdent
)
;
impl
MediaType
{
pub
fn
screen
(
)
-
>
Self
{
MediaType
(
CustomIdent
(
atom
!
(
"
screen
"
)
)
)
}
pub
fn
print
(
)
-
>
Self
{
MediaType
(
CustomIdent
(
atom
!
(
"
print
"
)
)
)
}
fn
parse
(
name
:
&
str
)
-
>
Result
<
Self
(
)
>
{
match_ignore_ascii_case
!
{
name
"
not
"
|
"
or
"
|
"
and
"
|
"
only
"
=
>
Err
(
(
)
)
_
=
>
Ok
(
MediaType
(
CustomIdent
(
Atom
:
:
from
(
string_as_ascii_lowercase
(
name
)
)
)
)
)
}
}
}
impl
MediaQuery
{
pub
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
MediaQuery
ParseError
<
'
i
>
>
{
let
mut
expressions
=
vec
!
[
]
;
let
qualifier
=
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
only
"
)
)
.
is_ok
(
)
{
Some
(
Qualifier
:
:
Only
)
}
else
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
not
"
)
)
.
is_ok
(
)
{
Some
(
Qualifier
:
:
Not
)
}
else
{
None
}
;
let
media_type
=
match
input
.
try
(
|
i
|
i
.
expect_ident_cloned
(
)
)
{
Ok
(
ident
)
=
>
MediaQueryType
:
:
parse
(
&
*
ident
)
.
map_err
(
|
(
)
|
{
input
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnexpectedIdent
(
ident
.
clone
(
)
)
)
}
)
?
Err
(
_
)
=
>
{
if
qualifier
.
is_some
(
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
expressions
.
push
(
Expression
:
:
parse
(
context
input
)
?
)
;
MediaQueryType
:
:
All
}
}
;
loop
{
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
and
"
)
)
.
is_err
(
)
{
return
Ok
(
MediaQuery
{
qualifier
media_type
expressions
}
)
;
}
expressions
.
push
(
Expression
:
:
parse
(
context
input
)
?
)
}
}
}
pub
fn
parse_media_query_list
<
R
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
error_reporter
:
&
R
)
-
>
MediaList
where
R
:
ParseErrorReporter
{
if
input
.
is_exhausted
(
)
{
return
MediaList
:
:
empty
(
)
;
}
let
mut
media_queries
=
vec
!
[
]
;
loop
{
let
start_position
=
input
.
position
(
)
;
match
input
.
parse_until_before
(
Delimiter
:
:
Comma
|
i
|
MediaQuery
:
:
parse
(
context
i
)
)
{
Ok
(
mq
)
=
>
{
media_queries
.
push
(
mq
)
;
}
Err
(
err
)
=
>
{
media_queries
.
push
(
MediaQuery
:
:
never_matching
(
)
)
;
let
location
=
err
.
location
;
let
error
=
ContextualParseError
:
:
InvalidMediaRule
(
input
.
slice_from
(
start_position
)
err
)
;
let
error_context
=
ParserErrorContext
{
error_reporter
}
;
context
.
log_css_error
(
&
error_context
location
error
)
;
}
}
match
input
.
next
(
)
{
Ok
(
&
Token
:
:
Comma
)
=
>
{
}
Ok
(
_
)
=
>
unreachable
!
(
)
Err
(
_
)
=
>
break
}
}
MediaList
{
media_queries
:
media_queries
}
}
impl
MediaList
{
pub
fn
evaluate
(
&
self
device
:
&
Device
quirks_mode
:
QuirksMode
)
-
>
bool
{
self
.
media_queries
.
is_empty
(
)
|
|
self
.
media_queries
.
iter
(
)
.
any
(
|
mq
|
{
let
media_match
=
mq
.
media_type
.
matches
(
device
.
media_type
(
)
)
;
let
query_match
=
media_match
&
&
mq
.
expressions
.
iter
(
)
.
all
(
|
expression
|
expression
.
matches
(
&
device
quirks_mode
)
)
;
match
mq
.
qualifier
{
Some
(
Qualifier
:
:
Not
)
=
>
!
query_match
_
=
>
query_match
}
}
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
media_queries
.
is_empty
(
)
}
pub
fn
append_medium
(
&
mut
self
context
:
&
ParserContext
new_medium
:
&
str
)
-
>
bool
{
let
mut
input
=
ParserInput
:
:
new
(
new_medium
)
;
let
mut
parser
=
Parser
:
:
new
(
&
mut
input
)
;
let
new_query
=
match
MediaQuery
:
:
parse
(
&
context
&
mut
parser
)
{
Ok
(
query
)
=
>
query
Err
(
_
)
=
>
{
return
false
;
}
}
;
self
.
media_queries
.
retain
(
|
query
|
query
!
=
&
new_query
)
;
self
.
media_queries
.
push
(
new_query
)
;
true
}
pub
fn
delete_medium
(
&
mut
self
context
:
&
ParserContext
old_medium
:
&
str
)
-
>
bool
{
let
mut
input
=
ParserInput
:
:
new
(
old_medium
)
;
let
mut
parser
=
Parser
:
:
new
(
&
mut
input
)
;
let
old_query
=
match
MediaQuery
:
:
parse
(
context
&
mut
parser
)
{
Ok
(
query
)
=
>
query
Err
(
_
)
=
>
{
return
false
;
}
}
;
let
old_len
=
self
.
media_queries
.
len
(
)
;
self
.
media_queries
.
retain
(
|
query
|
query
!
=
&
old_query
)
;
old_len
!
=
self
.
media_queries
.
len
(
)
}
}
