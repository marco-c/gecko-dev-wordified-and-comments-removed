use
Atom
;
use
cssparser
:
:
Parser
;
use
parser
:
:
ParserContext
;
use
selectors
:
:
parser
:
:
SelectorParseErrorKind
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
str
:
:
string_as_ascii_lowercase
;
use
style_traits
:
:
{
CssWriter
ParseError
StyleParseErrorKind
ToCss
}
;
use
values
:
:
CustomIdent
;
mod
media_list
;
pub
use
self
:
:
media_list
:
:
MediaList
;
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
use
servo
:
:
media_queries
:
:
{
Device
Expression
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
use
gecko
:
:
media_queries
:
:
{
Device
Expression
}
;
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
ToCss
)
]
pub
enum
Qualifier
{
Only
Not
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
)
]
pub
struct
MediaQuery
{
pub
qualifier
:
Option
<
Qualifier
>
pub
media_type
:
MediaQueryType
pub
expressions
:
Vec
<
Expression
>
}
impl
MediaQuery
{
fn
never_matching
(
)
-
>
Self
{
Self
{
qualifier
:
Some
(
Qualifier
:
:
Not
)
media_type
:
MediaQueryType
:
:
All
expressions
:
vec
!
[
]
}
}
}
impl
ToCss
for
MediaQuery
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
let
Some
(
qual
)
=
self
.
qualifier
{
qual
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
}
match
self
.
media_type
{
MediaQueryType
:
:
All
=
>
{
if
self
.
qualifier
.
is_some
(
)
|
|
self
.
expressions
.
is_empty
(
)
{
dest
.
write_str
(
"
all
"
)
?
;
}
}
MediaQueryType
:
:
Concrete
(
MediaType
(
ref
desc
)
)
=
>
desc
.
to_css
(
dest
)
?
}
if
self
.
expressions
.
is_empty
(
)
{
return
Ok
(
(
)
)
;
}
if
self
.
media_type
!
=
MediaQueryType
:
:
All
|
|
self
.
qualifier
.
is_some
(
)
{
dest
.
write_str
(
"
and
"
)
?
;
}
self
.
expressions
[
0
]
.
to_css
(
dest
)
?
;
for
expr
in
self
.
expressions
.
iter
(
)
.
skip
(
1
)
{
dest
.
write_str
(
"
and
"
)
?
;
expr
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
)
]
pub
enum
MediaQueryType
{
All
Concrete
(
MediaType
)
}
impl
MediaQueryType
{
fn
parse
(
ident
:
&
str
)
-
>
Result
<
Self
(
)
>
{
match_ignore_ascii_case
!
{
ident
"
all
"
=
>
return
Ok
(
MediaQueryType
:
:
All
)
_
=
>
(
)
}
;
MediaType
:
:
parse
(
ident
)
.
map
(
MediaQueryType
:
:
Concrete
)
}
fn
matches
(
&
self
other
:
MediaType
)
-
>
bool
{
match
*
self
{
MediaQueryType
:
:
All
=
>
true
MediaQueryType
:
:
Concrete
(
ref
known_type
)
=
>
*
known_type
=
=
other
}
}
}
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
)
]
pub
struct
MediaType
(
pub
CustomIdent
)
;
impl
MediaType
{
pub
fn
screen
(
)
-
>
Self
{
MediaType
(
CustomIdent
(
atom
!
(
"
screen
"
)
)
)
}
pub
fn
print
(
)
-
>
Self
{
MediaType
(
CustomIdent
(
atom
!
(
"
print
"
)
)
)
}
fn
parse
(
name
:
&
str
)
-
>
Result
<
Self
(
)
>
{
match_ignore_ascii_case
!
{
name
"
not
"
|
"
or
"
|
"
and
"
|
"
only
"
=
>
Err
(
(
)
)
_
=
>
Ok
(
MediaType
(
CustomIdent
(
Atom
:
:
from
(
string_as_ascii_lowercase
(
name
)
)
)
)
)
}
}
}
impl
MediaQuery
{
pub
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
MediaQuery
ParseError
<
'
i
>
>
{
let
mut
expressions
=
vec
!
[
]
;
let
qualifier
=
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
only
"
)
)
.
is_ok
(
)
{
Some
(
Qualifier
:
:
Only
)
}
else
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
not
"
)
)
.
is_ok
(
)
{
Some
(
Qualifier
:
:
Not
)
}
else
{
None
}
;
let
media_type
=
match
input
.
try
(
|
i
|
i
.
expect_ident_cloned
(
)
)
{
Ok
(
ident
)
=
>
MediaQueryType
:
:
parse
(
&
*
ident
)
.
map_err
(
|
(
)
|
{
input
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnexpectedIdent
(
ident
.
clone
(
)
)
)
}
)
?
Err
(
_
)
=
>
{
if
qualifier
.
is_some
(
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
expressions
.
push
(
Expression
:
:
parse
(
context
input
)
?
)
;
MediaQueryType
:
:
All
}
}
;
loop
{
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
and
"
)
)
.
is_err
(
)
{
return
Ok
(
MediaQuery
{
qualifier
media_type
expressions
}
)
;
}
expressions
.
push
(
Expression
:
:
parse
(
context
input
)
?
)
}
}
}
