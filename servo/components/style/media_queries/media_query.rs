use
crate
:
:
parser
:
:
ParserContext
;
use
crate
:
:
queries
:
:
{
FeatureFlags
FeatureType
QueryCondition
}
;
use
crate
:
:
str
:
:
string_as_ascii_lowercase
;
use
crate
:
:
values
:
:
CustomIdent
;
use
crate
:
:
Atom
;
use
cssparser
:
:
Parser
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ParseError
ToCss
}
;
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
Parse
PartialEq
ToCss
ToShmem
)
]
pub
enum
Qualifier
{
Only
Not
}
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
ToShmem
)
]
pub
struct
MediaType
(
pub
CustomIdent
)
;
impl
MediaType
{
pub
fn
screen
(
)
-
>
Self
{
MediaType
(
CustomIdent
(
atom
!
(
"
screen
"
)
)
)
}
pub
fn
print
(
)
-
>
Self
{
MediaType
(
CustomIdent
(
atom
!
(
"
print
"
)
)
)
}
fn
parse
(
name
:
&
str
)
-
>
Result
<
Self
(
)
>
{
match_ignore_ascii_case
!
{
name
"
not
"
|
"
or
"
|
"
and
"
|
"
only
"
|
"
layer
"
=
>
Err
(
(
)
)
_
=
>
Ok
(
MediaType
(
CustomIdent
(
Atom
:
:
from
(
string_as_ascii_lowercase
(
name
)
)
)
)
)
}
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
pub
struct
MediaQuery
{
pub
qualifier
:
Option
<
Qualifier
>
pub
media_type
:
MediaQueryType
pub
condition
:
Option
<
QueryCondition
>
}
impl
ToCss
for
MediaQuery
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
let
Some
(
qual
)
=
self
.
qualifier
{
qual
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
'
)
?
;
}
match
self
.
media_type
{
MediaQueryType
:
:
All
=
>
{
if
self
.
qualifier
.
is_some
(
)
|
|
self
.
condition
.
is_none
(
)
{
dest
.
write_str
(
"
all
"
)
?
;
}
}
MediaQueryType
:
:
Concrete
(
MediaType
(
ref
desc
)
)
=
>
desc
.
to_css
(
dest
)
?
}
let
condition
=
match
self
.
condition
{
Some
(
ref
c
)
=
>
c
None
=
>
return
Ok
(
(
)
)
}
;
if
self
.
media_type
!
=
MediaQueryType
:
:
All
|
|
self
.
qualifier
.
is_some
(
)
{
dest
.
write_str
(
"
and
"
)
?
;
}
condition
.
to_css
(
dest
)
}
}
impl
MediaQuery
{
pub
fn
never_matching
(
)
-
>
Self
{
Self
{
qualifier
:
Some
(
Qualifier
:
:
Not
)
media_type
:
MediaQueryType
:
:
All
condition
:
None
}
}
pub
fn
is_viewport_dependent
(
&
self
)
-
>
bool
{
self
.
condition
.
as_ref
(
)
.
map_or
(
false
|
c
|
{
return
c
.
cumulative_flags
(
)
.
contains
(
FeatureFlags
:
:
VIEWPORT_DEPENDENT
)
}
)
}
pub
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
(
qualifier
explicit_media_type
)
=
input
.
try_parse
(
|
input
|
-
>
Result
<
_
(
)
>
{
let
qualifier
=
input
.
try_parse
(
Qualifier
:
:
parse
)
.
ok
(
)
;
let
ident
=
input
.
expect_ident
(
)
.
map_err
(
|
_
|
(
)
)
?
;
let
media_type
=
MediaQueryType
:
:
parse
(
&
ident
)
?
;
Ok
(
(
qualifier
Some
(
media_type
)
)
)
}
)
.
unwrap_or_default
(
)
;
let
condition
=
if
explicit_media_type
.
is_none
(
)
{
Some
(
QueryCondition
:
:
parse
(
context
input
FeatureType
:
:
Media
)
?
)
}
else
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
and
"
)
)
.
is_ok
(
)
{
Some
(
QueryCondition
:
:
parse_disallow_or
(
context
input
FeatureType
:
:
Media
)
?
)
}
else
{
None
}
;
let
media_type
=
explicit_media_type
.
unwrap_or
(
MediaQueryType
:
:
All
)
;
Ok
(
Self
{
qualifier
media_type
condition
}
)
}
}
#
[
derive
(
Clone
Debug
Eq
MallocSizeOf
PartialEq
ToShmem
)
]
pub
enum
MediaQueryType
{
All
Concrete
(
MediaType
)
}
impl
MediaQueryType
{
fn
parse
(
ident
:
&
str
)
-
>
Result
<
Self
(
)
>
{
match_ignore_ascii_case
!
{
ident
"
all
"
=
>
return
Ok
(
MediaQueryType
:
:
All
)
_
=
>
(
)
}
;
MediaType
:
:
parse
(
ident
)
.
map
(
MediaQueryType
:
:
Concrete
)
}
pub
fn
matches
(
&
self
other
:
MediaType
)
-
>
bool
{
match
*
self
{
MediaQueryType
:
:
All
=
>
true
MediaQueryType
:
:
Concrete
(
ref
known_type
)
=
>
*
known_type
=
=
other
}
}
}
