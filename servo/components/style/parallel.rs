#
!
[
deny
(
missing_docs
)
]
use
crate
:
:
context
:
:
{
StyleContext
ThreadLocalStyleContext
}
;
use
crate
:
:
dom
:
:
{
OpaqueNode
SendNode
TElement
}
;
use
crate
:
:
scoped_tls
:
:
ScopedTLS
;
use
crate
:
:
traversal
:
:
{
DomTraversal
PerLevelTraversalData
}
;
use
arrayvec
:
:
ArrayVec
;
use
itertools
:
:
Itertools
;
use
rayon
;
use
smallvec
:
:
SmallVec
;
pub
const
STYLE_THREAD_STACK_SIZE_KB
:
usize
=
256
;
pub
const
STACK_SAFETY_MARGIN_KB
:
usize
=
168
;
pub
const
WORK_UNIT_MAX
:
usize
=
16
;
type
WorkUnit
<
N
>
=
ArrayVec
<
[
SendNode
<
N
>
;
WORK_UNIT_MAX
]
>
;
#
[
inline
(
never
)
]
fn
create_thread_local_context
<
'
scope
E
D
>
(
traversal
:
&
'
scope
D
slot
:
&
mut
Option
<
ThreadLocalStyleContext
<
E
>
>
)
where
E
:
TElement
+
'
scope
D
:
DomTraversal
<
E
>
{
*
slot
=
Some
(
ThreadLocalStyleContext
:
:
new
(
traversal
.
shared_context
(
)
)
)
;
}
#
[
inline
(
always
)
]
#
[
allow
(
unsafe_code
)
]
fn
top_down_dom
<
'
a
'
scope
E
D
>
(
nodes
:
&
'
a
[
SendNode
<
E
:
:
ConcreteNode
>
]
root
:
OpaqueNode
mut
traversal_data
:
PerLevelTraversalData
scope
:
&
'
a
rayon
:
:
ScopeFifo
<
'
scope
>
pool
:
&
'
scope
rayon
:
:
ThreadPool
traversal
:
&
'
scope
D
tls
:
&
'
scope
ScopedTLS
<
'
scope
ThreadLocalStyleContext
<
E
>
>
)
where
E
:
TElement
+
'
scope
D
:
DomTraversal
<
E
>
{
debug_assert
!
(
nodes
.
len
(
)
<
=
WORK_UNIT_MAX
)
;
let
recursion_ok
;
let
mut
discovered_child_nodes
=
SmallVec
:
:
<
[
SendNode
<
E
:
:
ConcreteNode
>
;
128
]
>
:
:
new
(
)
;
{
let
mut
tlc
=
tls
.
ensure
(
|
slot
:
&
mut
Option
<
ThreadLocalStyleContext
<
E
>
>
|
{
create_thread_local_context
(
traversal
slot
)
}
)
;
recursion_ok
=
!
tlc
.
stack_limit_checker
.
limit_exceeded
(
)
;
let
mut
context
=
StyleContext
{
shared
:
traversal
.
shared_context
(
)
thread_local
:
&
mut
*
tlc
}
;
for
n
in
nodes
{
if
discovered_child_nodes
.
len
(
)
>
=
WORK_UNIT_MAX
{
let
mut
traversal_data_copy
=
traversal_data
.
clone
(
)
;
traversal_data_copy
.
current_dom_depth
+
=
1
;
traverse_nodes
(
discovered_child_nodes
.
drain
(
)
DispatchMode
:
:
NotTailCall
recursion_ok
root
traversal_data_copy
scope
pool
traversal
tls
)
;
}
let
node
=
*
*
n
;
let
mut
children_to_process
=
0isize
;
traversal
.
process_preorder
(
&
traversal_data
&
mut
context
node
|
n
|
{
children_to_process
+
=
1
;
let
send_n
=
unsafe
{
SendNode
:
:
new
(
n
)
}
;
discovered_child_nodes
.
push
(
send_n
)
;
}
)
;
traversal
.
handle_postorder_traversal
(
&
mut
context
root
node
children_to_process
)
;
}
}
if
!
discovered_child_nodes
.
is_empty
(
)
{
traversal_data
.
current_dom_depth
+
=
1
;
traverse_nodes
(
discovered_child_nodes
.
drain
(
)
DispatchMode
:
:
TailCall
recursion_ok
root
traversal_data
scope
pool
traversal
tls
)
;
}
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
DispatchMode
{
TailCall
NotTailCall
}
impl
DispatchMode
{
fn
is_tail_call
(
&
self
)
-
>
bool
{
matches
!
(
*
self
DispatchMode
:
:
TailCall
)
}
}
#
[
inline
]
pub
fn
traverse_nodes
<
'
a
'
scope
E
D
I
>
(
nodes
:
I
mode
:
DispatchMode
recursion_ok
:
bool
root
:
OpaqueNode
traversal_data
:
PerLevelTraversalData
scope
:
&
'
a
rayon
:
:
ScopeFifo
<
'
scope
>
pool
:
&
'
scope
rayon
:
:
ThreadPool
traversal
:
&
'
scope
D
tls
:
&
'
scope
ScopedTLS
<
'
scope
ThreadLocalStyleContext
<
E
>
>
)
where
E
:
TElement
+
'
scope
D
:
DomTraversal
<
E
>
I
:
ExactSizeIterator
<
Item
=
SendNode
<
E
:
:
ConcreteNode
>
>
{
debug_assert_ne
!
(
nodes
.
len
(
)
0
)
;
let
may_dispatch_tail
=
mode
.
is_tail_call
(
)
&
&
recursion_ok
&
&
!
pool
.
current_thread_has_pending_tasks
(
)
.
unwrap
(
)
;
if
nodes
.
len
(
)
<
=
WORK_UNIT_MAX
{
let
work
:
WorkUnit
<
E
:
:
ConcreteNode
>
=
nodes
.
collect
(
)
;
if
may_dispatch_tail
{
top_down_dom
(
&
work
root
traversal_data
scope
pool
traversal
tls
)
;
}
else
{
scope
.
spawn_fifo
(
move
|
scope
|
{
profiler_label
!
(
Style
)
;
let
work
=
work
;
top_down_dom
(
&
work
root
traversal_data
scope
pool
traversal
tls
)
;
}
)
;
}
}
else
{
for
chunk
in
nodes
.
chunks
(
WORK_UNIT_MAX
)
.
into_iter
(
)
{
let
nodes
:
WorkUnit
<
E
:
:
ConcreteNode
>
=
chunk
.
collect
(
)
;
let
traversal_data_copy
=
traversal_data
.
clone
(
)
;
scope
.
spawn_fifo
(
move
|
scope
|
{
profiler_label
!
(
Style
)
;
let
n
=
nodes
;
top_down_dom
(
&
*
n
root
traversal_data_copy
scope
pool
traversal
tls
)
}
)
;
}
}
}
