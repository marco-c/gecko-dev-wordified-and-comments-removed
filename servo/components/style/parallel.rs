#
!
[
deny
(
missing_docs
)
]
use
dom
:
:
{
OpaqueNode
SendNode
TElement
TNode
}
;
use
rayon
;
use
scoped_tls
:
:
ScopedTLS
;
use
servo_config
:
:
opts
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
use
traversal
:
:
{
DomTraversal
PerLevelTraversalData
PreTraverseToken
}
;
use
traversal
:
:
{
STYLE_SHARING_CACHE_HITS
STYLE_SHARING_CACHE_MISSES
}
;
pub
const
CHUNK_SIZE
:
usize
=
64
;
#
[
allow
(
unsafe_code
)
]
pub
fn
traverse_dom
<
E
D
>
(
traversal
:
&
D
root
:
E
known_root_dom_depth
:
Option
<
usize
>
token
:
PreTraverseToken
queue
:
&
rayon
:
:
ThreadPool
)
where
E
:
TElement
D
:
DomTraversal
<
E
>
{
if
opts
:
:
get
(
)
.
style_sharing_stats
{
STYLE_SHARING_CACHE_HITS
.
store
(
0
Ordering
:
:
SeqCst
)
;
STYLE_SHARING_CACHE_MISSES
.
store
(
0
Ordering
:
:
SeqCst
)
;
}
let
(
nodes
depth
)
=
if
token
.
traverse_unstyled_children_only
(
)
{
debug_assert
!
(
!
D
:
:
needs_postorder_traversal
(
)
)
;
let
mut
children
=
vec
!
[
]
;
for
kid
in
root
.
as_node
(
)
.
children
(
)
{
if
kid
.
as_element
(
)
.
map_or
(
false
|
el
|
el
.
get_data
(
)
.
is_none
(
)
)
{
children
.
push
(
unsafe
{
SendNode
:
:
new
(
kid
)
}
)
;
}
}
(
children
known_root_dom_depth
.
map
(
|
x
|
x
+
1
)
)
}
else
{
(
vec
!
[
unsafe
{
SendNode
:
:
new
(
root
.
as_node
(
)
)
}
]
known_root_dom_depth
)
}
;
let
traversal_data
=
PerLevelTraversalData
{
current_dom_depth
:
depth
}
;
let
tls
=
ScopedTLS
:
:
<
D
:
:
ThreadLocalContext
>
:
:
new
(
queue
)
;
let
root
=
root
.
as_node
(
)
.
opaque
(
)
;
queue
.
install
(
|
|
{
rayon
:
:
scope
(
|
scope
|
{
traverse_nodes
(
nodes
root
traversal_data
scope
traversal
&
tls
)
;
}
)
;
}
)
;
if
opts
:
:
get
(
)
.
style_sharing_stats
{
let
hits
=
STYLE_SHARING_CACHE_HITS
.
load
(
Ordering
:
:
SeqCst
)
;
let
misses
=
STYLE_SHARING_CACHE_MISSES
.
load
(
Ordering
:
:
SeqCst
)
;
println
!
(
"
Style
sharing
stats
:
"
)
;
println
!
(
"
*
Hits
:
{
}
"
hits
)
;
println
!
(
"
*
Misses
:
{
}
"
misses
)
;
}
}
#
[
inline
(
always
)
]
#
[
allow
(
unsafe_code
)
]
fn
top_down_dom
<
'
a
'
scope
E
D
>
(
nodes
:
&
'
a
[
SendNode
<
E
:
:
ConcreteNode
>
]
root
:
OpaqueNode
mut
traversal_data
:
PerLevelTraversalData
scope
:
&
'
a
rayon
:
:
Scope
<
'
scope
>
traversal
:
&
'
scope
D
tls
:
&
'
scope
ScopedTLS
<
'
scope
D
:
:
ThreadLocalContext
>
)
where
E
:
TElement
+
'
scope
D
:
DomTraversal
<
E
>
{
let
mut
discovered_child_nodes
=
vec
!
[
]
;
{
let
mut
tlc
=
tls
.
ensure
(
|
|
traversal
.
create_thread_local_context
(
)
)
;
for
n
in
nodes
{
let
node
=
*
*
n
;
let
mut
children_to_process
=
0isize
;
traversal
.
process_preorder
(
&
mut
traversal_data
&
mut
*
tlc
node
)
;
if
let
Some
(
el
)
=
node
.
as_element
(
)
{
traversal
.
traverse_children
(
&
mut
*
tlc
el
|
_tlc
kid
|
{
children_to_process
+
=
1
;
discovered_child_nodes
.
push
(
unsafe
{
SendNode
:
:
new
(
kid
)
}
)
}
)
;
}
if
D
:
:
needs_postorder_traversal
(
)
{
if
children_to_process
=
=
0
{
bottom_up_dom
(
traversal
&
mut
*
tlc
root
node
)
}
else
{
node
.
as_element
(
)
.
unwrap
(
)
.
store_children_to_process
(
children_to_process
)
;
}
}
}
}
if
let
Some
(
ref
mut
depth
)
=
traversal_data
.
current_dom_depth
{
*
depth
+
=
1
;
}
traverse_nodes
(
discovered_child_nodes
root
traversal_data
scope
traversal
tls
)
;
}
fn
traverse_nodes
<
'
a
'
scope
E
D
>
(
nodes
:
Vec
<
SendNode
<
E
:
:
ConcreteNode
>
>
root
:
OpaqueNode
traversal_data
:
PerLevelTraversalData
scope
:
&
'
a
rayon
:
:
Scope
<
'
scope
>
traversal
:
&
'
scope
D
tls
:
&
'
scope
ScopedTLS
<
'
scope
D
:
:
ThreadLocalContext
>
)
where
E
:
TElement
+
'
scope
D
:
DomTraversal
<
E
>
{
if
nodes
.
is_empty
(
)
{
return
;
}
if
nodes
.
len
(
)
<
=
CHUNK_SIZE
{
let
nodes
=
nodes
.
into_boxed_slice
(
)
;
top_down_dom
(
&
nodes
root
traversal_data
scope
traversal
tls
)
;
return
;
}
for
chunk
in
nodes
.
chunks
(
CHUNK_SIZE
)
{
let
nodes
=
chunk
.
iter
(
)
.
cloned
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
into_boxed_slice
(
)
;
let
traversal_data
=
traversal_data
.
clone
(
)
;
scope
.
spawn
(
move
|
scope
|
{
let
nodes
=
nodes
;
top_down_dom
(
&
nodes
root
traversal_data
scope
traversal
tls
)
}
)
}
}
fn
bottom_up_dom
<
E
D
>
(
traversal
:
&
D
thread_local
:
&
mut
D
:
:
ThreadLocalContext
root
:
OpaqueNode
mut
node
:
E
:
:
ConcreteNode
)
where
E
:
TElement
D
:
DomTraversal
<
E
>
{
loop
{
traversal
.
process_postorder
(
thread_local
node
)
;
if
node
.
opaque
(
)
=
=
root
{
break
;
}
let
parent
=
match
node
.
parent_element
(
)
{
None
=
>
unreachable
!
(
"
How
can
this
happen
after
the
break
above
?
"
)
Some
(
parent
)
=
>
parent
}
;
let
remaining
=
parent
.
did_process_child
(
)
;
if
remaining
!
=
0
{
break
}
node
=
parent
.
as_node
(
)
;
}
}
