#
!
[
allow
(
unsafe_code
)
]
use
dom
:
:
{
OpaqueNode
TNode
UnsafeNode
}
;
use
std
:
:
mem
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
use
traversal
:
:
DomTraversalContext
;
use
workqueue
:
:
{
WorkQueue
WorkUnit
WorkerProxy
}
;
#
[
allow
(
dead_code
)
]
fn
static_assertion
(
node
:
UnsafeNode
)
{
unsafe
{
let
_
:
UnsafeNodeList
=
mem
:
:
transmute
(
node
)
;
}
}
pub
type
UnsafeNodeList
=
(
Box
<
Vec
<
UnsafeNode
>
>
OpaqueNode
)
;
pub
const
CHUNK_SIZE
:
usize
=
64
;
pub
struct
WorkQueueData
(
usize
usize
)
;
pub
fn
run_queue_with_custom_work_data_type
<
To
F
SharedContext
:
Sync
>
(
queue
:
&
mut
WorkQueue
<
SharedContext
WorkQueueData
>
callback
:
F
shared
:
&
SharedContext
)
where
To
:
'
static
+
Send
F
:
FnOnce
(
&
mut
WorkQueue
<
SharedContext
To
>
)
{
let
queue
:
&
mut
WorkQueue
<
SharedContext
To
>
=
unsafe
{
mem
:
:
transmute
(
queue
)
}
;
callback
(
queue
)
;
queue
.
run
(
shared
)
;
}
pub
fn
traverse_dom
<
N
C
>
(
root
:
N
queue_data
:
&
C
:
:
SharedContext
queue
:
&
mut
WorkQueue
<
C
:
:
SharedContext
WorkQueueData
>
)
where
N
:
TNode
C
:
DomTraversalContext
<
N
>
{
run_queue_with_custom_work_data_type
(
queue
|
queue
|
{
queue
.
push
(
WorkUnit
{
fun
:
top_down_dom
:
:
<
N
C
>
data
:
(
Box
:
:
new
(
vec
!
[
root
.
to_unsafe
(
)
]
)
root
.
opaque
(
)
)
}
)
;
}
queue_data
)
;
}
#
[
inline
(
always
)
]
fn
top_down_dom
<
N
C
>
(
unsafe_nodes
:
UnsafeNodeList
proxy
:
&
mut
WorkerProxy
<
C
:
:
SharedContext
UnsafeNodeList
>
)
where
N
:
TNode
C
:
DomTraversalContext
<
N
>
{
let
context
=
C
:
:
new
(
proxy
.
user_data
(
)
unsafe_nodes
.
1
)
;
let
mut
discovered_child_nodes
=
vec
!
[
]
;
for
unsafe_node
in
*
unsafe_nodes
.
0
{
let
node
=
unsafe
{
N
:
:
from_unsafe
(
&
unsafe_node
)
}
;
context
.
process_preorder
(
node
)
;
let
child_count
=
node
.
children_count
(
)
;
{
let
data
=
node
.
mutate_data
(
)
.
unwrap
(
)
;
data
.
parallel
.
children_count
.
store
(
child_count
as
isize
Ordering
:
:
Relaxed
)
;
}
if
child_count
!
=
0
{
for
kid
in
node
.
children
(
)
{
discovered_child_nodes
.
push
(
kid
.
to_unsafe
(
)
)
}
}
else
{
bottom_up_dom
:
:
<
N
C
>
(
unsafe_nodes
.
1
unsafe_node
proxy
)
}
}
for
chunk
in
discovered_child_nodes
.
chunks
(
CHUNK_SIZE
)
{
proxy
.
push
(
WorkUnit
{
fun
:
top_down_dom
:
:
<
N
C
>
data
:
(
Box
:
:
new
(
chunk
.
iter
(
)
.
cloned
(
)
.
collect
(
)
)
unsafe_nodes
.
1
)
}
)
;
}
}
fn
bottom_up_dom
<
N
C
>
(
root
:
OpaqueNode
unsafe_node
:
UnsafeNode
proxy
:
&
mut
WorkerProxy
<
C
:
:
SharedContext
UnsafeNodeList
>
)
where
N
:
TNode
C
:
DomTraversalContext
<
N
>
{
let
context
=
C
:
:
new
(
proxy
.
user_data
(
)
root
)
;
let
mut
node
=
unsafe
{
N
:
:
from_unsafe
(
&
unsafe_node
)
}
;
loop
{
context
.
process_postorder
(
node
)
;
let
parent
=
match
node
.
layout_parent_node
(
root
)
{
None
=
>
break
Some
(
parent
)
=
>
parent
}
;
let
parent_data
=
unsafe
{
&
*
parent
.
borrow_data_unchecked
(
)
.
unwrap
(
)
}
;
if
parent_data
.
parallel
.
children_count
.
fetch_sub
(
1
Ordering
:
:
Relaxed
)
!
=
1
{
break
}
node
=
parent
;
}
}
