use
dom
:
:
{
OpaqueNode
TElement
TNode
UnsafeNode
}
;
use
rayon
;
use
servo_config
:
:
opts
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
use
traversal
:
:
{
DomTraversalContext
PerLevelTraversalData
PreTraverseToken
}
;
use
traversal
:
:
{
STYLE_SHARING_CACHE_HITS
STYLE_SHARING_CACHE_MISSES
}
;
pub
const
CHUNK_SIZE
:
usize
=
64
;
pub
fn
traverse_dom
<
N
C
>
(
root
:
N
:
:
ConcreteElement
known_root_dom_depth
:
Option
<
usize
>
shared_context
:
&
C
:
:
SharedContext
token
:
PreTraverseToken
queue
:
&
rayon
:
:
ThreadPool
)
where
N
:
TNode
C
:
DomTraversalContext
<
N
>
{
if
opts
:
:
get
(
)
.
style_sharing_stats
{
STYLE_SHARING_CACHE_HITS
.
store
(
0
Ordering
:
:
SeqCst
)
;
STYLE_SHARING_CACHE_MISSES
.
store
(
0
Ordering
:
:
SeqCst
)
;
}
let
(
nodes
depth
)
=
if
token
.
traverse_unstyled_children_only
(
)
{
debug_assert
!
(
!
C
:
:
needs_postorder_traversal
(
)
)
;
let
mut
children
=
vec
!
[
]
;
for
kid
in
root
.
as_node
(
)
.
children
(
)
{
if
kid
.
as_element
(
)
.
map_or
(
false
|
el
|
el
.
get_data
(
)
.
is_none
(
)
)
{
children
.
push
(
kid
.
to_unsafe
(
)
)
;
}
}
(
children
known_root_dom_depth
.
map
(
|
x
|
x
+
1
)
)
}
else
{
(
vec
!
[
root
.
as_node
(
)
.
to_unsafe
(
)
]
known_root_dom_depth
)
}
;
let
data
=
PerLevelTraversalData
{
current_dom_depth
:
depth
}
;
let
root
=
root
.
as_node
(
)
.
opaque
(
)
;
queue
.
install
(
|
|
{
rayon
:
:
scope
(
|
scope
|
{
traverse_nodes
:
:
<
_
C
>
(
nodes
root
data
scope
shared_context
)
;
}
)
;
}
)
;
if
opts
:
:
get
(
)
.
style_sharing_stats
{
let
hits
=
STYLE_SHARING_CACHE_HITS
.
load
(
Ordering
:
:
SeqCst
)
;
let
misses
=
STYLE_SHARING_CACHE_MISSES
.
load
(
Ordering
:
:
SeqCst
)
;
println
!
(
"
Style
sharing
stats
:
"
)
;
println
!
(
"
*
Hits
:
{
}
"
hits
)
;
println
!
(
"
*
Misses
:
{
}
"
misses
)
;
}
}
#
[
inline
(
always
)
]
#
[
allow
(
unsafe_code
)
]
fn
top_down_dom
<
'
a
'
scope
N
C
>
(
unsafe_nodes
:
&
'
a
[
UnsafeNode
]
root
:
OpaqueNode
mut
data
:
PerLevelTraversalData
scope
:
&
'
a
rayon
:
:
Scope
<
'
scope
>
shared_context
:
&
'
scope
C
:
:
SharedContext
)
where
N
:
TNode
C
:
DomTraversalContext
<
N
>
{
let
context
=
C
:
:
new
(
shared_context
root
)
;
let
mut
discovered_child_nodes
=
vec
!
[
]
;
for
unsafe_node
in
unsafe_nodes
{
let
node
=
unsafe
{
N
:
:
from_unsafe
(
&
unsafe_node
)
}
;
let
mut
children_to_process
=
0isize
;
context
.
process_preorder
(
node
&
mut
data
)
;
if
let
Some
(
el
)
=
node
.
as_element
(
)
{
C
:
:
traverse_children
(
el
|
kid
|
{
children_to_process
+
=
1
;
discovered_child_nodes
.
push
(
kid
.
to_unsafe
(
)
)
}
)
;
}
if
C
:
:
needs_postorder_traversal
(
)
{
if
children_to_process
=
=
0
{
bottom_up_dom
:
:
<
N
C
>
(
root
*
unsafe_node
shared_context
)
}
else
{
node
.
as_element
(
)
.
unwrap
(
)
.
store_children_to_process
(
children_to_process
)
;
}
}
}
context
.
local_context
(
)
.
style_sharing_candidate_cache
.
borrow_mut
(
)
.
clear
(
)
;
if
let
Some
(
ref
mut
depth
)
=
data
.
current_dom_depth
{
*
depth
+
=
1
;
}
traverse_nodes
:
:
<
_
C
>
(
discovered_child_nodes
root
data
scope
shared_context
)
;
}
fn
traverse_nodes
<
'
a
'
scope
N
C
>
(
nodes
:
Vec
<
UnsafeNode
>
root
:
OpaqueNode
data
:
PerLevelTraversalData
scope
:
&
'
a
rayon
:
:
Scope
<
'
scope
>
shared_context
:
&
'
scope
C
:
:
SharedContext
)
where
N
:
TNode
C
:
DomTraversalContext
<
N
>
{
if
nodes
.
is_empty
(
)
{
return
;
}
if
nodes
.
len
(
)
<
=
CHUNK_SIZE
{
let
nodes
=
nodes
.
into_boxed_slice
(
)
;
top_down_dom
:
:
<
N
C
>
(
&
nodes
root
data
scope
shared_context
)
;
return
;
}
for
chunk
in
nodes
.
chunks
(
CHUNK_SIZE
)
{
let
nodes
=
chunk
.
iter
(
)
.
cloned
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
into_boxed_slice
(
)
;
let
data
=
data
.
clone
(
)
;
scope
.
spawn
(
move
|
scope
|
{
let
nodes
=
nodes
;
top_down_dom
:
:
<
N
C
>
(
&
nodes
root
data
scope
shared_context
)
}
)
}
}
#
[
allow
(
unsafe_code
)
]
fn
bottom_up_dom
<
N
C
>
(
root
:
OpaqueNode
unsafe_node
:
UnsafeNode
shared_context
:
&
C
:
:
SharedContext
)
where
N
:
TNode
C
:
DomTraversalContext
<
N
>
{
let
context
=
C
:
:
new
(
shared_context
root
)
;
let
mut
node
=
unsafe
{
N
:
:
from_unsafe
(
&
unsafe_node
)
}
;
loop
{
context
.
process_postorder
(
node
)
;
if
node
.
opaque
(
)
=
=
root
{
break
;
}
let
parent
=
match
node
.
parent_element
(
)
{
None
=
>
unreachable
!
(
"
How
can
this
happen
after
the
break
above
?
"
)
Some
(
parent
)
=
>
parent
}
;
let
remaining
=
parent
.
did_process_child
(
)
;
if
remaining
!
=
0
{
break
}
node
=
parent
.
as_node
(
)
;
}
}
