use
context
:
:
QuirksMode
;
use
cssparser
:
:
{
Parser
SourceLocation
UnicodeRange
}
;
use
error_reporting
:
:
{
ParseErrorReporter
ContextualParseError
}
;
use
style_traits
:
:
{
OneOrMoreSeparated
ParseError
ParsingMode
Separator
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
style_traits
:
:
{
PARSING_MODE_DEFAULT
PARSING_MODE_ALLOW_UNITLESS_LENGTH
PARSING_MODE_ALLOW_ALL_NUMERIC_VALUES
}
;
use
stylesheets
:
:
{
CssRuleType
Origin
UrlExtraData
Namespaces
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
inline
]
pub
fn
assert_parsing_mode_match
(
)
{
use
gecko_bindings
:
:
structs
;
macro_rules
!
check_parsing_modes
{
(
(
a
:
ident
=
>
b
:
ident
)
*
)
=
>
{
if
cfg
!
(
debug_assertions
)
{
let
mut
modes
=
ParsingMode
:
:
all
(
)
;
(
assert_eq
!
(
structs
:
:
a
as
usize
b
.
bits
(
)
as
usize
stringify
!
(
b
)
)
;
modes
.
remove
(
b
)
;
)
*
assert_eq
!
(
modes
ParsingMode
:
:
empty
(
)
"
all
ParsingMode
bits
should
have
an
assertion
"
)
;
}
}
}
check_parsing_modes
!
{
ParsingMode_Default
=
>
PARSING_MODE_DEFAULT
ParsingMode_AllowUnitlessLength
=
>
PARSING_MODE_ALLOW_UNITLESS_LENGTH
ParsingMode_AllowAllNumericValues
=
>
PARSING_MODE_ALLOW_ALL_NUMERIC_VALUES
}
}
pub
struct
ParserContext
<
'
a
>
{
pub
stylesheet_origin
:
Origin
pub
url_data
:
&
'
a
UrlExtraData
pub
error_reporter
:
&
'
a
ParseErrorReporter
pub
rule_type
:
Option
<
CssRuleType
>
pub
line_number_offset
:
u64
pub
parsing_mode
:
ParsingMode
pub
quirks_mode
:
QuirksMode
pub
namespaces
:
Option
<
&
'
a
Namespaces
>
}
impl
<
'
a
>
ParserContext
<
'
a
>
{
pub
fn
new
(
stylesheet_origin
:
Origin
url_data
:
&
'
a
UrlExtraData
error_reporter
:
&
'
a
ParseErrorReporter
rule_type
:
Option
<
CssRuleType
>
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
stylesheet_origin
url_data
:
url_data
error_reporter
:
error_reporter
rule_type
:
rule_type
line_number_offset
:
0u64
parsing_mode
:
parsing_mode
quirks_mode
:
quirks_mode
namespaces
:
None
}
}
pub
fn
new_for_cssom
(
url_data
:
&
'
a
UrlExtraData
error_reporter
:
&
'
a
ParseErrorReporter
rule_type
:
Option
<
CssRuleType
>
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
)
-
>
ParserContext
<
'
a
>
{
Self
:
:
new
(
Origin
:
:
Author
url_data
error_reporter
rule_type
parsing_mode
quirks_mode
)
}
pub
fn
new_with_rule_type
(
context
:
&
'
a
ParserContext
rule_type
:
Option
<
CssRuleType
>
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
context
.
stylesheet_origin
url_data
:
context
.
url_data
error_reporter
:
context
.
error_reporter
rule_type
:
rule_type
line_number_offset
:
context
.
line_number_offset
parsing_mode
:
context
.
parsing_mode
quirks_mode
:
context
.
quirks_mode
namespaces
:
context
.
namespaces
}
}
pub
fn
new_with_line_number_offset
(
stylesheet_origin
:
Origin
url_data
:
&
'
a
UrlExtraData
error_reporter
:
&
'
a
ParseErrorReporter
line_number_offset
:
u64
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
stylesheet_origin
url_data
:
url_data
error_reporter
:
error_reporter
rule_type
:
None
line_number_offset
:
line_number_offset
parsing_mode
:
parsing_mode
quirks_mode
:
quirks_mode
namespaces
:
None
}
}
pub
fn
rule_type
(
&
self
)
-
>
CssRuleType
{
self
.
rule_type
.
expect
(
"
Rule
type
expected
but
none
was
found
.
"
)
}
pub
fn
log_css_error
(
&
self
location
:
SourceLocation
error
:
ContextualParseError
)
{
let
location
=
SourceLocation
{
line
:
location
.
line
+
self
.
line_number_offset
as
u32
column
:
location
.
column
}
;
self
.
error_reporter
.
report_error
(
self
.
url_data
location
error
)
}
}
pub
trait
Parse
:
Sized
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
;
}
impl
<
T
>
Parse
for
Vec
<
T
>
where
T
:
Parse
+
OneOrMoreSeparated
<
T
as
OneOrMoreSeparated
>
:
:
S
:
Separator
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
<
T
as
OneOrMoreSeparated
>
:
:
S
:
:
parse
(
input
|
i
|
T
:
:
parse
(
context
i
)
)
}
}
impl
Parse
for
UnicodeRange
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
UnicodeRange
:
:
parse
(
input
)
.
map_err
(
|
e
|
e
.
into
(
)
)
}
}
