#
!
[
deny
(
missing_docs
)
]
use
cssparser
:
:
{
Parser
SourcePosition
UnicodeRange
}
;
use
error_reporting
:
:
ParseErrorReporter
;
use
style_traits
:
:
OneOrMoreCommaSeparated
;
use
stylesheets
:
:
{
CssRuleType
Origin
UrlExtraData
}
;
pub
struct
ParserContext
<
'
a
>
{
pub
stylesheet_origin
:
Origin
pub
url_data
:
&
'
a
UrlExtraData
pub
error_reporter
:
&
'
a
ParseErrorReporter
pub
rule_type
:
Option
<
CssRuleType
>
pub
line_number_offset
:
u64
}
impl
<
'
a
>
ParserContext
<
'
a
>
{
pub
fn
new
(
stylesheet_origin
:
Origin
url_data
:
&
'
a
UrlExtraData
error_reporter
:
&
'
a
ParseErrorReporter
rule_type
:
Option
<
CssRuleType
>
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
stylesheet_origin
url_data
:
url_data
error_reporter
:
error_reporter
rule_type
:
rule_type
line_number_offset
:
0u64
}
}
pub
fn
new_for_cssom
(
url_data
:
&
'
a
UrlExtraData
error_reporter
:
&
'
a
ParseErrorReporter
rule_type
:
Option
<
CssRuleType
>
)
-
>
ParserContext
<
'
a
>
{
Self
:
:
new
(
Origin
:
:
Author
url_data
error_reporter
rule_type
)
}
pub
fn
new_with_rule_type
(
context
:
&
'
a
ParserContext
rule_type
:
Option
<
CssRuleType
>
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
context
.
stylesheet_origin
url_data
:
context
.
url_data
error_reporter
:
context
.
error_reporter
rule_type
:
rule_type
line_number_offset
:
context
.
line_number_offset
}
}
pub
fn
rule_type
(
&
self
)
-
>
CssRuleType
{
self
.
rule_type
.
expect
(
"
Rule
type
expected
but
none
was
found
.
"
)
}
pub
fn
new_with_line_number_offset
(
stylesheet_origin
:
Origin
url_data
:
&
'
a
UrlExtraData
error_reporter
:
&
'
a
ParseErrorReporter
line_number_offset
:
u64
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
stylesheet_origin
url_data
:
url_data
error_reporter
:
error_reporter
rule_type
:
None
line_number_offset
:
line_number_offset
}
}
}
pub
fn
log_css_error
(
input
:
&
mut
Parser
position
:
SourcePosition
message
:
&
str
parsercontext
:
&
ParserContext
)
{
let
url_data
=
parsercontext
.
url_data
;
let
line_number_offset
=
parsercontext
.
line_number_offset
;
parsercontext
.
error_reporter
.
report_error
(
input
position
message
url_data
line_number_offset
)
;
}
pub
trait
Parse
:
Sized
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
;
}
impl
<
T
>
Parse
for
Vec
<
T
>
where
T
:
Parse
+
OneOrMoreCommaSeparated
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
input
.
parse_comma_separated
(
|
input
|
T
:
:
parse
(
context
input
)
)
}
}
pub
fn
parse_space_or_comma_separated
<
F
T
>
(
input
:
&
mut
Parser
mut
parse_one
:
F
)
-
>
Result
<
Vec
<
T
>
(
)
>
where
F
:
FnMut
(
&
mut
Parser
)
-
>
Result
<
T
(
)
>
{
let
first
=
parse_one
(
input
)
?
;
let
mut
vec
=
vec
!
[
first
]
;
loop
{
let
_
=
input
.
try
(
|
i
|
i
.
expect_comma
(
)
)
;
if
let
Ok
(
val
)
=
input
.
try
(
|
i
|
parse_one
(
i
)
)
{
vec
.
push
(
val
)
}
else
{
break
}
}
Ok
(
vec
)
}
impl
Parse
for
UnicodeRange
{
fn
parse
(
_context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
UnicodeRange
:
:
parse
(
input
)
}
}
