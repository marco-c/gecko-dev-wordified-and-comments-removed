use
context
:
:
QuirksMode
;
use
cssparser
:
:
{
Parser
SourcePosition
UnicodeRange
}
;
use
error_reporting
:
:
ParseErrorReporter
;
use
parking_lot
:
:
RwLock
;
use
style_traits
:
:
OneOrMoreCommaSeparated
;
use
stylesheets
:
:
{
CssRuleType
Origin
UrlExtraData
Namespaces
}
;
bitflags
!
{
/
/
/
The
mode
to
use
when
parsing
values
.
pub
flags
ParsingMode
:
u8
{
/
/
/
In
CSS
lengths
must
have
units
except
for
zero
values
where
the
unit
can
be
omitted
.
/
/
/
https
:
/
/
www
.
w3
.
org
/
TR
/
css3
-
values
/
#
lengths
const
PARSING_MODE_DEFAULT
=
0x00
/
/
/
In
SVG
a
coordinate
or
length
value
without
a
unit
identifier
(
e
.
g
.
"
25
"
)
is
assumed
/
/
/
to
be
in
user
units
(
px
)
.
/
/
/
https
:
/
/
www
.
w3
.
org
/
TR
/
SVG
/
coords
.
html
#
Units
const
PARSING_MODE_ALLOW_UNITLESS_LENGTH
=
0x01
/
/
/
In
SVG
out
-
of
-
range
values
are
not
treated
as
an
error
in
parsing
.
/
/
/
https
:
/
/
www
.
w3
.
org
/
TR
/
SVG
/
implnote
.
html
#
RangeClamping
const
PARSING_MODE_ALLOW_ALL_NUMERIC_VALUES
=
0x02
}
}
impl
ParsingMode
{
pub
fn
allows_unitless_lengths
(
&
self
)
-
>
bool
{
self
.
intersects
(
PARSING_MODE_ALLOW_UNITLESS_LENGTH
)
}
pub
fn
allows_all_numeric_values
(
&
self
)
-
>
bool
{
self
.
intersects
(
PARSING_MODE_ALLOW_ALL_NUMERIC_VALUES
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
inline
]
pub
fn
assert_parsing_mode_match
(
)
{
use
gecko_bindings
:
:
structs
;
macro_rules
!
check_parsing_modes
{
(
(
a
:
ident
=
>
b
:
ident
)
*
)
=
>
{
if
cfg
!
(
debug_assertions
)
{
let
mut
modes
=
ParsingMode
:
:
all
(
)
;
(
assert_eq
!
(
structs
:
:
a
as
usize
b
.
bits
(
)
as
usize
stringify
!
(
b
)
)
;
modes
.
remove
(
b
)
;
)
*
assert_eq
!
(
modes
ParsingMode
:
:
empty
(
)
"
all
ParsingMode
bits
should
have
an
assertion
"
)
;
}
}
}
check_parsing_modes
!
{
ParsingMode_Default
=
>
PARSING_MODE_DEFAULT
ParsingMode_AllowUnitlessLength
=
>
PARSING_MODE_ALLOW_UNITLESS_LENGTH
ParsingMode_AllowAllNumericValues
=
>
PARSING_MODE_ALLOW_ALL_NUMERIC_VALUES
}
}
pub
struct
ParserContext
<
'
a
>
{
pub
stylesheet_origin
:
Origin
pub
url_data
:
&
'
a
UrlExtraData
pub
error_reporter
:
&
'
a
ParseErrorReporter
pub
rule_type
:
Option
<
CssRuleType
>
pub
line_number_offset
:
u64
pub
parsing_mode
:
ParsingMode
pub
quirks_mode
:
QuirksMode
pub
namespaces
:
Option
<
&
'
a
RwLock
<
Namespaces
>
>
}
impl
<
'
a
>
ParserContext
<
'
a
>
{
pub
fn
new
(
stylesheet_origin
:
Origin
url_data
:
&
'
a
UrlExtraData
error_reporter
:
&
'
a
ParseErrorReporter
rule_type
:
Option
<
CssRuleType
>
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
stylesheet_origin
url_data
:
url_data
error_reporter
:
error_reporter
rule_type
:
rule_type
line_number_offset
:
0u64
parsing_mode
:
parsing_mode
quirks_mode
:
quirks_mode
namespaces
:
None
}
}
pub
fn
new_for_cssom
(
url_data
:
&
'
a
UrlExtraData
error_reporter
:
&
'
a
ParseErrorReporter
rule_type
:
Option
<
CssRuleType
>
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
)
-
>
ParserContext
<
'
a
>
{
Self
:
:
new
(
Origin
:
:
Author
url_data
error_reporter
rule_type
parsing_mode
quirks_mode
)
}
pub
fn
new_with_rule_type
(
context
:
&
'
a
ParserContext
rule_type
:
Option
<
CssRuleType
>
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
context
.
stylesheet_origin
url_data
:
context
.
url_data
error_reporter
:
context
.
error_reporter
rule_type
:
rule_type
line_number_offset
:
context
.
line_number_offset
parsing_mode
:
context
.
parsing_mode
quirks_mode
:
context
.
quirks_mode
namespaces
:
context
.
namespaces
}
}
pub
fn
new_with_line_number_offset
(
stylesheet_origin
:
Origin
url_data
:
&
'
a
UrlExtraData
error_reporter
:
&
'
a
ParseErrorReporter
line_number_offset
:
u64
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
stylesheet_origin
url_data
:
url_data
error_reporter
:
error_reporter
rule_type
:
None
line_number_offset
:
line_number_offset
parsing_mode
:
parsing_mode
quirks_mode
:
quirks_mode
namespaces
:
None
}
}
pub
fn
rule_type
(
&
self
)
-
>
CssRuleType
{
self
.
rule_type
.
expect
(
"
Rule
type
expected
but
none
was
found
.
"
)
}
}
pub
fn
log_css_error
(
input
:
&
mut
Parser
position
:
SourcePosition
message
:
&
str
parsercontext
:
&
ParserContext
)
{
let
url_data
=
parsercontext
.
url_data
;
let
line_number_offset
=
parsercontext
.
line_number_offset
;
parsercontext
.
error_reporter
.
report_error
(
input
position
message
url_data
line_number_offset
)
;
}
pub
trait
Parse
:
Sized
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
;
}
impl
<
T
>
Parse
for
Vec
<
T
>
where
T
:
Parse
+
OneOrMoreCommaSeparated
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
input
.
parse_comma_separated
(
|
input
|
T
:
:
parse
(
context
input
)
)
}
}
pub
fn
parse_space_or_comma_separated
<
F
T
>
(
input
:
&
mut
Parser
mut
parse_one
:
F
)
-
>
Result
<
Vec
<
T
>
(
)
>
where
F
:
FnMut
(
&
mut
Parser
)
-
>
Result
<
T
(
)
>
{
let
first
=
parse_one
(
input
)
?
;
let
mut
vec
=
vec
!
[
first
]
;
loop
{
let
_
=
input
.
try
(
|
i
|
i
.
expect_comma
(
)
)
;
if
let
Ok
(
val
)
=
input
.
try
(
|
i
|
parse_one
(
i
)
)
{
vec
.
push
(
val
)
}
else
{
break
}
}
Ok
(
vec
)
}
impl
Parse
for
UnicodeRange
{
fn
parse
(
_context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
UnicodeRange
:
:
parse
(
input
)
}
}
