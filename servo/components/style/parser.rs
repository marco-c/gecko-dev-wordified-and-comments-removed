use
context
:
:
QuirksMode
;
use
cssparser
:
:
{
Parser
SourcePosition
UnicodeRange
}
;
use
error_reporting
:
:
{
ParseErrorReporter
ContextualParseError
}
;
use
style_traits
:
:
{
OneOrMoreCommaSeparated
ParseError
ParsingMode
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
style_traits
:
:
{
PARSING_MODE_DEFAULT
PARSING_MODE_ALLOW_UNITLESS_LENGTH
PARSING_MODE_ALLOW_ALL_NUMERIC_VALUES
}
;
use
stylesheets
:
:
{
CssRuleType
Origin
UrlExtraData
Namespaces
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
inline
]
pub
fn
assert_parsing_mode_match
(
)
{
use
gecko_bindings
:
:
structs
;
macro_rules
!
check_parsing_modes
{
(
(
a
:
ident
=
>
b
:
ident
)
*
)
=
>
{
if
cfg
!
(
debug_assertions
)
{
let
mut
modes
=
ParsingMode
:
:
all
(
)
;
(
assert_eq
!
(
structs
:
:
a
as
usize
b
.
bits
(
)
as
usize
stringify
!
(
b
)
)
;
modes
.
remove
(
b
)
;
)
*
assert_eq
!
(
modes
ParsingMode
:
:
empty
(
)
"
all
ParsingMode
bits
should
have
an
assertion
"
)
;
}
}
}
check_parsing_modes
!
{
ParsingMode_Default
=
>
PARSING_MODE_DEFAULT
ParsingMode_AllowUnitlessLength
=
>
PARSING_MODE_ALLOW_UNITLESS_LENGTH
ParsingMode_AllowAllNumericValues
=
>
PARSING_MODE_ALLOW_ALL_NUMERIC_VALUES
}
}
pub
struct
ParserContext
<
'
a
>
{
pub
stylesheet_origin
:
Origin
pub
url_data
:
&
'
a
UrlExtraData
pub
error_reporter
:
&
'
a
ParseErrorReporter
pub
rule_type
:
Option
<
CssRuleType
>
pub
line_number_offset
:
u64
pub
parsing_mode
:
ParsingMode
pub
quirks_mode
:
QuirksMode
pub
namespaces
:
Option
<
&
'
a
Namespaces
>
}
impl
<
'
a
>
ParserContext
<
'
a
>
{
pub
fn
new
(
stylesheet_origin
:
Origin
url_data
:
&
'
a
UrlExtraData
error_reporter
:
&
'
a
ParseErrorReporter
rule_type
:
Option
<
CssRuleType
>
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
stylesheet_origin
url_data
:
url_data
error_reporter
:
error_reporter
rule_type
:
rule_type
line_number_offset
:
0u64
parsing_mode
:
parsing_mode
quirks_mode
:
quirks_mode
namespaces
:
None
}
}
pub
fn
new_for_cssom
(
url_data
:
&
'
a
UrlExtraData
error_reporter
:
&
'
a
ParseErrorReporter
rule_type
:
Option
<
CssRuleType
>
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
)
-
>
ParserContext
<
'
a
>
{
Self
:
:
new
(
Origin
:
:
Author
url_data
error_reporter
rule_type
parsing_mode
quirks_mode
)
}
pub
fn
new_with_rule_type
(
context
:
&
'
a
ParserContext
rule_type
:
Option
<
CssRuleType
>
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
context
.
stylesheet_origin
url_data
:
context
.
url_data
error_reporter
:
context
.
error_reporter
rule_type
:
rule_type
line_number_offset
:
context
.
line_number_offset
parsing_mode
:
context
.
parsing_mode
quirks_mode
:
context
.
quirks_mode
namespaces
:
context
.
namespaces
}
}
pub
fn
new_with_line_number_offset
(
stylesheet_origin
:
Origin
url_data
:
&
'
a
UrlExtraData
error_reporter
:
&
'
a
ParseErrorReporter
line_number_offset
:
u64
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
stylesheet_origin
url_data
:
url_data
error_reporter
:
error_reporter
rule_type
:
None
line_number_offset
:
line_number_offset
parsing_mode
:
parsing_mode
quirks_mode
:
quirks_mode
namespaces
:
None
}
}
pub
fn
rule_type
(
&
self
)
-
>
CssRuleType
{
self
.
rule_type
.
expect
(
"
Rule
type
expected
but
none
was
found
.
"
)
}
}
pub
fn
log_css_error
<
'
a
>
(
input
:
&
mut
Parser
position
:
SourcePosition
error
:
ContextualParseError
<
'
a
>
parsercontext
:
&
ParserContext
)
{
let
url_data
=
parsercontext
.
url_data
;
let
line_number_offset
=
parsercontext
.
line_number_offset
;
parsercontext
.
error_reporter
.
report_error
(
input
position
error
url_data
line_number_offset
)
;
}
pub
trait
Parse
:
Sized
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
;
}
impl
<
T
>
Parse
for
Vec
<
T
>
where
T
:
Parse
+
OneOrMoreCommaSeparated
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
input
.
parse_comma_separated
(
|
input
|
T
:
:
parse
(
context
input
)
)
}
}
pub
fn
parse_space_or_comma_separated
<
'
i
'
t
F
T
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
mut
parse_one
:
F
)
-
>
Result
<
Vec
<
T
>
ParseError
<
'
i
>
>
where
F
:
for
<
'
ii
'
tt
>
FnMut
(
&
mut
Parser
<
'
ii
'
tt
>
)
-
>
Result
<
T
ParseError
<
'
ii
>
>
{
let
first
=
parse_one
(
input
)
?
;
let
mut
vec
=
vec
!
[
first
]
;
loop
{
let
_
=
input
.
try
(
|
i
|
i
.
expect_comma
(
)
)
;
if
let
Ok
(
val
)
=
input
.
try
(
|
i
|
parse_one
(
i
)
)
{
vec
.
push
(
val
)
}
else
{
break
}
}
Ok
(
vec
)
}
impl
Parse
for
UnicodeRange
{
fn
parse
<
'
i
'
t
>
(
_context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
UnicodeRange
:
:
parse
(
input
)
.
map_err
(
|
e
|
e
.
into
(
)
)
}
}
