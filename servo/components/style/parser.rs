use
crate
:
:
context
:
:
QuirksMode
;
use
crate
:
:
error_reporting
:
:
{
ContextualParseError
ParseErrorReporter
}
;
use
crate
:
:
stylesheets
:
:
{
CssRuleType
Namespaces
Origin
UrlExtraData
}
;
use
crate
:
:
use_counters
:
:
UseCounters
;
use
cssparser
:
:
{
Parser
SourceLocation
UnicodeRange
}
;
use
std
:
:
borrow
:
:
Cow
;
use
style_traits
:
:
{
OneOrMoreSeparated
ParseError
ParsingMode
Separator
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
inline
]
pub
fn
assert_parsing_mode_match
(
)
{
use
crate
:
:
gecko_bindings
:
:
structs
;
macro_rules
!
check_parsing_modes
{
(
(
a
:
ident
=
>
b
:
path
)
*
)
=
>
{
if
cfg
!
(
debug_assertions
)
{
let
mut
modes
=
ParsingMode
:
:
all
(
)
;
(
assert_eq
!
(
structs
:
:
a
as
usize
b
.
bits
(
)
as
usize
stringify
!
(
b
)
)
;
modes
.
remove
(
b
)
;
)
*
assert_eq
!
(
modes
ParsingMode
:
:
empty
(
)
"
all
ParsingMode
bits
should
have
an
assertion
"
)
;
}
}
}
check_parsing_modes
!
{
ParsingMode_Default
=
>
ParsingMode
:
:
DEFAULT
ParsingMode_AllowUnitlessLength
=
>
ParsingMode
:
:
ALLOW_UNITLESS_LENGTH
ParsingMode_AllowAllNumericValues
=
>
ParsingMode
:
:
ALLOW_ALL_NUMERIC_VALUES
}
}
pub
struct
ParserContext
<
'
a
>
{
pub
stylesheet_origin
:
Origin
pub
url_data
:
&
'
a
UrlExtraData
pub
rule_type
:
Option
<
CssRuleType
>
pub
parsing_mode
:
ParsingMode
pub
quirks_mode
:
QuirksMode
error_reporter
:
Option
<
&
'
a
dyn
ParseErrorReporter
>
pub
namespaces
:
Cow
<
'
a
Namespaces
>
pub
use_counters
:
Option
<
&
'
a
UseCounters
>
}
impl
<
'
a
>
ParserContext
<
'
a
>
{
#
[
inline
]
pub
fn
new
(
stylesheet_origin
:
Origin
url_data
:
&
'
a
UrlExtraData
rule_type
:
Option
<
CssRuleType
>
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
namespaces
:
Cow
<
'
a
Namespaces
>
error_reporter
:
Option
<
&
'
a
dyn
ParseErrorReporter
>
use_counters
:
Option
<
&
'
a
UseCounters
>
)
-
>
Self
{
Self
{
stylesheet_origin
url_data
rule_type
parsing_mode
quirks_mode
error_reporter
namespaces
use_counters
}
}
pub
fn
nest_for_rule
<
R
>
(
&
mut
self
rule_type
:
CssRuleType
cb
:
impl
FnOnce
(
&
mut
Self
)
-
>
R
)
-
>
R
{
let
old_rule_type
=
std
:
:
mem
:
:
replace
(
&
mut
self
.
rule_type
Some
(
rule_type
)
)
;
let
r
=
cb
(
self
)
;
self
.
rule_type
=
old_rule_type
;
r
}
#
[
inline
]
pub
fn
in_page_rule
(
&
self
)
-
>
bool
{
self
.
rule_type
.
map_or
(
false
|
rule_type
|
rule_type
=
=
CssRuleType
:
:
Page
)
}
pub
fn
rule_type
(
&
self
)
-
>
CssRuleType
{
self
.
rule_type
.
expect
(
"
Rule
type
expected
but
none
was
found
.
"
)
}
#
[
inline
]
pub
fn
error_reporting_enabled
(
&
self
)
-
>
bool
{
self
.
error_reporter
.
is_some
(
)
}
pub
fn
log_css_error
(
&
self
location
:
SourceLocation
error
:
ContextualParseError
)
{
let
error_reporter
=
match
self
.
error_reporter
{
Some
(
r
)
=
>
r
None
=
>
return
}
;
error_reporter
.
report_error
(
self
.
url_data
location
error
)
}
#
[
inline
]
pub
fn
in_ua_sheet
(
&
self
)
-
>
bool
{
self
.
stylesheet_origin
=
=
Origin
:
:
UserAgent
}
#
[
inline
]
pub
fn
chrome_rules_enabled
(
&
self
)
-
>
bool
{
self
.
url_data
.
chrome_rules_enabled
(
)
|
|
self
.
stylesheet_origin
=
=
Origin
:
:
User
}
#
[
inline
]
pub
fn
in_ua_or_chrome_sheet
(
&
self
)
-
>
bool
{
self
.
in_ua_sheet
(
)
|
|
self
.
chrome_rules_enabled
(
)
}
}
pub
trait
Parse
:
Sized
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
;
}
impl
<
T
>
Parse
for
Vec
<
T
>
where
T
:
Parse
+
OneOrMoreSeparated
<
T
as
OneOrMoreSeparated
>
:
:
S
:
Separator
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
<
T
as
OneOrMoreSeparated
>
:
:
S
:
:
parse
(
input
|
i
|
T
:
:
parse
(
context
i
)
)
}
}
impl
<
T
>
Parse
for
Box
<
T
>
where
T
:
Parse
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
T
:
:
parse
(
context
input
)
.
map
(
Box
:
:
new
)
}
}
impl
Parse
for
crate
:
:
OwnedStr
{
fn
parse
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Ok
(
input
.
expect_string
(
)
?
.
as_ref
(
)
.
to_owned
(
)
.
into
(
)
)
}
}
impl
Parse
for
UnicodeRange
{
fn
parse
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Ok
(
UnicodeRange
:
:
parse
(
input
)
?
)
}
}
