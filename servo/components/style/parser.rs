#
!
[
deny
(
missing_docs
)
]
use
cssparser
:
:
{
Parser
SourcePosition
UnicodeRange
}
;
use
error_reporting
:
:
ParseErrorReporter
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
structs
:
:
URLExtraData
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
gecko_bindings
:
:
sugar
:
:
refptr
:
:
RefPtr
;
use
servo_url
:
:
ServoUrl
;
use
style_traits
:
:
OneOrMoreCommaSeparated
;
use
stylesheets
:
:
Origin
;
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
pub
struct
ParserContextExtraData
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
struct
ParserContextExtraData
{
pub
data
:
Option
<
RefPtr
<
URLExtraData
>
>
}
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
impl
Default
for
ParserContextExtraData
{
fn
default
(
)
-
>
Self
{
ParserContextExtraData
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
Default
for
ParserContextExtraData
{
fn
default
(
)
-
>
Self
{
ParserContextExtraData
{
data
:
None
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
ParserContextExtraData
{
pub
unsafe
fn
new
(
data
:
*
mut
URLExtraData
)
-
>
Self
{
ParserContextExtraData
{
data
:
Some
(
RefPtr
:
:
new
(
data
)
)
}
}
}
pub
struct
ParserContext
<
'
a
>
{
pub
stylesheet_origin
:
Origin
pub
base_url
:
&
'
a
ServoUrl
pub
error_reporter
:
&
'
a
ParseErrorReporter
pub
extra_data
:
ParserContextExtraData
}
impl
<
'
a
>
ParserContext
<
'
a
>
{
pub
fn
new_with_extra_data
(
stylesheet_origin
:
Origin
base_url
:
&
'
a
ServoUrl
error_reporter
:
&
'
a
ParseErrorReporter
extra_data
:
ParserContextExtraData
)
-
>
ParserContext
<
'
a
>
{
ParserContext
{
stylesheet_origin
:
stylesheet_origin
base_url
:
base_url
error_reporter
:
error_reporter
extra_data
:
extra_data
}
}
pub
fn
new
(
stylesheet_origin
:
Origin
base_url
:
&
'
a
ServoUrl
error_reporter
:
&
'
a
ParseErrorReporter
)
-
>
ParserContext
<
'
a
>
{
let
extra_data
=
ParserContextExtraData
:
:
default
(
)
;
Self
:
:
new_with_extra_data
(
stylesheet_origin
base_url
error_reporter
extra_data
)
}
pub
fn
new_for_cssom
(
base_url
:
&
'
a
ServoUrl
error_reporter
:
&
'
a
ParseErrorReporter
)
-
>
ParserContext
<
'
a
>
{
Self
:
:
new
(
Origin
:
:
User
base_url
error_reporter
)
}
}
pub
fn
log_css_error
(
input
:
&
mut
Parser
position
:
SourcePosition
message
:
&
str
parsercontext
:
&
ParserContext
)
{
let
servo_url
=
parsercontext
.
base_url
;
parsercontext
.
error_reporter
.
report_error
(
input
position
message
servo_url
)
;
}
pub
trait
Parse
:
Sized
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
;
}
impl
<
T
>
Parse
for
Vec
<
T
>
where
T
:
Parse
+
OneOrMoreCommaSeparated
{
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
input
.
parse_comma_separated
(
|
input
|
T
:
:
parse
(
context
input
)
)
}
}
pub
fn
parse_space_or_comma_separated
<
F
T
>
(
input
:
&
mut
Parser
mut
parse_one
:
F
)
-
>
Result
<
Vec
<
T
>
(
)
>
where
F
:
FnMut
(
&
mut
Parser
)
-
>
Result
<
T
(
)
>
{
let
first
=
parse_one
(
input
)
?
;
let
mut
vec
=
vec
!
[
first
]
;
loop
{
let
_
=
input
.
try
(
|
i
|
i
.
expect_comma
(
)
)
;
if
let
Ok
(
val
)
=
input
.
try
(
|
i
|
parse_one
(
i
)
)
{
vec
.
push
(
val
)
}
else
{
break
}
}
Ok
(
vec
)
}
impl
Parse
for
UnicodeRange
{
fn
parse
(
_context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
UnicodeRange
:
:
parse
(
input
)
}
}
