use
crate
:
:
context
:
:
QuirksMode
;
use
crate
:
:
error_reporting
:
:
{
ContextualParseError
ParseErrorReporter
}
;
use
crate
:
:
stylesheets
:
:
{
CssRuleType
CssRuleTypes
Namespaces
Origin
UrlExtraData
}
;
use
crate
:
:
use_counters
:
:
UseCounters
;
use
cssparser
:
:
{
Parser
SourceLocation
UnicodeRange
}
;
use
selectors
:
:
parser
:
:
ParseRelative
;
use
std
:
:
borrow
:
:
Cow
;
use
style_traits
:
:
{
OneOrMoreSeparated
ParseError
ParsingMode
Separator
}
;
#
[
derive
(
Clone
Copy
)
]
pub
struct
NestingContext
{
pub
rule_types
:
CssRuleTypes
pub
parse_relative
:
ParseRelative
}
impl
NestingContext
{
fn
parse_relative_for
(
rule_type
:
CssRuleType
)
-
>
ParseRelative
{
match
rule_type
{
CssRuleType
:
:
Scope
=
>
ParseRelative
:
:
ForScope
CssRuleType
:
:
Style
=
>
ParseRelative
:
:
ForNesting
_
=
>
ParseRelative
:
:
No
}
}
pub
fn
new
(
rule_types
:
CssRuleTypes
parse_nested_rule_type
:
Option
<
CssRuleType
>
)
-
>
Self
{
Self
{
rule_types
parse_relative
:
parse_nested_rule_type
.
map_or
(
ParseRelative
:
:
No
Self
:
:
parse_relative_for
)
}
}
pub
fn
new_from_rule
(
rule_type
:
Option
<
CssRuleType
>
)
-
>
Self
{
Self
{
rule_types
:
rule_type
.
map
(
CssRuleTypes
:
:
from
)
.
unwrap_or_default
(
)
parse_relative
:
rule_type
.
map
(
Self
:
:
parse_relative_for
)
.
unwrap_or
(
ParseRelative
:
:
No
)
}
}
pub
fn
save
(
&
mut
self
rule_type
:
CssRuleType
)
-
>
Self
{
let
old
=
*
self
;
self
.
rule_types
.
insert
(
rule_type
)
;
let
new_parse_relative
=
Self
:
:
parse_relative_for
(
rule_type
)
;
if
new_parse_relative
!
=
ParseRelative
:
:
No
{
self
.
parse_relative
=
new_parse_relative
;
}
old
}
pub
fn
restore
(
&
mut
self
saved
:
Self
)
{
*
self
=
saved
;
}
}
pub
struct
ParserContext
<
'
a
>
{
pub
stylesheet_origin
:
Origin
pub
url_data
:
&
'
a
UrlExtraData
pub
parsing_mode
:
ParsingMode
pub
quirks_mode
:
QuirksMode
error_reporter
:
Option
<
&
'
a
dyn
ParseErrorReporter
>
pub
namespaces
:
Cow
<
'
a
Namespaces
>
pub
use_counters
:
Option
<
&
'
a
UseCounters
>
pub
nesting_context
:
NestingContext
}
impl
<
'
a
>
ParserContext
<
'
a
>
{
#
[
inline
]
pub
fn
new
(
stylesheet_origin
:
Origin
url_data
:
&
'
a
UrlExtraData
rule_type
:
Option
<
CssRuleType
>
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
namespaces
:
Cow
<
'
a
Namespaces
>
error_reporter
:
Option
<
&
'
a
dyn
ParseErrorReporter
>
use_counters
:
Option
<
&
'
a
UseCounters
>
)
-
>
Self
{
Self
{
stylesheet_origin
url_data
parsing_mode
quirks_mode
error_reporter
namespaces
use_counters
nesting_context
:
NestingContext
:
:
new_from_rule
(
rule_type
)
}
}
pub
fn
nest_for_rule
<
R
>
(
&
mut
self
rule_type
:
CssRuleType
cb
:
impl
FnOnce
(
&
mut
Self
)
-
>
R
)
-
>
R
{
let
old
=
self
.
nesting_context
.
save
(
rule_type
)
;
let
r
=
cb
(
self
)
;
self
.
nesting_context
.
restore
(
old
)
;
r
}
#
[
inline
]
pub
fn
in_page_rule
(
&
self
)
-
>
bool
{
self
.
nesting_context
.
rule_types
.
contains
(
CssRuleType
:
:
Page
)
}
#
[
inline
]
pub
fn
allows_important_declarations
(
&
self
)
-
>
bool
{
!
self
.
nesting_context
.
rule_types
.
intersects
(
CssRuleTypes
:
:
IMPORTANT_FORBIDDEN
)
}
pub
fn
rule_types
(
&
self
)
-
>
CssRuleTypes
{
self
.
nesting_context
.
rule_types
}
#
[
inline
]
pub
fn
error_reporting_enabled
(
&
self
)
-
>
bool
{
self
.
error_reporter
.
is_some
(
)
}
pub
fn
log_css_error
(
&
self
location
:
SourceLocation
error
:
ContextualParseError
)
{
let
error_reporter
=
match
self
.
error_reporter
{
Some
(
r
)
=
>
r
None
=
>
return
}
;
error_reporter
.
report_error
(
self
.
url_data
location
error
)
}
#
[
inline
]
pub
fn
in_ua_sheet
(
&
self
)
-
>
bool
{
self
.
stylesheet_origin
=
=
Origin
:
:
UserAgent
}
#
[
inline
]
pub
fn
chrome_rules_enabled
(
&
self
)
-
>
bool
{
self
.
url_data
.
chrome_rules_enabled
(
)
|
|
self
.
stylesheet_origin
!
=
Origin
:
:
Author
}
}
pub
trait
Parse
:
Sized
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
;
}
impl
<
T
>
Parse
for
Vec
<
T
>
where
T
:
Parse
+
OneOrMoreSeparated
<
T
as
OneOrMoreSeparated
>
:
:
S
:
Separator
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
<
T
as
OneOrMoreSeparated
>
:
:
S
:
:
parse
(
input
|
i
|
T
:
:
parse
(
context
i
)
)
}
}
impl
<
T
>
Parse
for
Box
<
T
>
where
T
:
Parse
{
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
T
:
:
parse
(
context
input
)
.
map
(
Box
:
:
new
)
}
}
impl
Parse
for
crate
:
:
OwnedStr
{
fn
parse
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Ok
(
input
.
expect_string
(
)
?
.
as_ref
(
)
.
to_owned
(
)
.
into
(
)
)
}
}
impl
Parse
for
UnicodeRange
{
fn
parse
<
'
i
'
t
>
(
_
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
Ok
(
UnicodeRange
:
:
parse
(
input
)
?
)
}
}
