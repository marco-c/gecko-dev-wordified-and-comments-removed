use
crate
:
:
applicable_declarations
:
:
CascadePriority
;
use
crate
:
:
color
:
:
AbsoluteColor
;
use
crate
:
:
computed_value_flags
:
:
ComputedValueFlags
;
use
crate
:
:
custom_properties
:
:
CustomPropertiesBuilder
;
use
crate
:
:
dom
:
:
TElement
;
use
crate
:
:
font_metrics
:
:
FontMetricsOrientation
;
use
crate
:
:
logical_geometry
:
:
WritingMode
;
use
crate
:
:
properties
:
:
declaration_block
:
:
{
DeclarationImportanceIterator
Importance
}
;
use
crate
:
:
properties
:
:
generated
:
:
{
CSSWideKeyword
ComputedValues
LonghandId
LonghandIdSet
PrioritaryPropertyId
PropertyDeclaration
PropertyDeclarationId
PropertyFlags
ShorthandsWithPropertyReferencesCache
StyleBuilder
CASCADE_PROPERTY
PRIORITARY_PROPERTY_COUNT
}
;
use
crate
:
:
rule_cache
:
:
{
RuleCache
RuleCacheConditions
}
;
use
crate
:
:
rule_tree
:
:
{
CascadeLevel
StrongRuleNode
}
;
use
crate
:
:
selector_parser
:
:
PseudoElement
;
use
crate
:
:
shared_lock
:
:
StylesheetGuards
;
use
crate
:
:
style_adjuster
:
:
StyleAdjuster
;
use
crate
:
:
stylesheets
:
:
container_rule
:
:
ContainerSizeQuery
;
use
crate
:
:
stylesheets
:
:
{
layer_rule
:
:
LayerOrder
Origin
}
;
use
crate
:
:
stylist
:
:
Stylist
;
use
crate
:
:
values
:
:
specified
:
:
length
:
:
FontBaseSize
;
use
crate
:
:
values
:
:
{
computed
specified
}
;
use
fxhash
:
:
FxHashMap
;
use
servo_arc
:
:
Arc
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
mem
;
#
[
derive
(
Copy
Clone
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
FirstLineReparenting
<
'
a
>
{
No
Yes
{
style_to_reparent
:
&
'
a
ComputedValues
}
}
pub
fn
cascade
<
E
>
(
stylist
:
&
Stylist
pseudo
:
Option
<
&
PseudoElement
>
rule_node
:
&
StrongRuleNode
guards
:
&
StylesheetGuards
originating_element_style
:
Option
<
&
ComputedValues
>
parent_style
:
Option
<
&
ComputedValues
>
layout_parent_style
:
Option
<
&
ComputedValues
>
first_line_reparenting
:
FirstLineReparenting
visited_rules
:
Option
<
&
StrongRuleNode
>
cascade_input_flags
:
ComputedValueFlags
rule_cache
:
Option
<
&
RuleCache
>
rule_cache_conditions
:
&
mut
RuleCacheConditions
element
:
Option
<
E
>
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
cascade_rules
(
stylist
pseudo
rule_node
guards
originating_element_style
parent_style
layout_parent_style
first_line_reparenting
CascadeMode
:
:
Unvisited
{
visited_rules
}
cascade_input_flags
rule_cache
rule_cache_conditions
element
)
}
struct
DeclarationIterator
<
'
a
>
{
guards
:
&
'
a
StylesheetGuards
<
'
a
>
restriction
:
Option
<
PropertyFlags
>
current_rule_node
:
Option
<
&
'
a
StrongRuleNode
>
declarations
:
DeclarationImportanceIterator
<
'
a
>
origin
:
Origin
importance
:
Importance
priority
:
CascadePriority
}
impl
<
'
a
>
DeclarationIterator
<
'
a
>
{
#
[
inline
]
fn
new
(
rule_node
:
&
'
a
StrongRuleNode
guards
:
&
'
a
StylesheetGuards
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Self
{
let
restriction
=
pseudo
.
and_then
(
|
p
|
p
.
property_restriction
(
)
)
;
let
mut
iter
=
Self
{
guards
current_rule_node
:
Some
(
rule_node
)
origin
:
Origin
:
:
UserAgent
importance
:
Importance
:
:
Normal
priority
:
CascadePriority
:
:
new
(
CascadeLevel
:
:
UANormal
LayerOrder
:
:
root
(
)
)
declarations
:
DeclarationImportanceIterator
:
:
default
(
)
restriction
}
;
iter
.
update_for_node
(
rule_node
)
;
iter
}
fn
update_for_node
(
&
mut
self
node
:
&
'
a
StrongRuleNode
)
{
self
.
priority
=
node
.
cascade_priority
(
)
;
let
level
=
self
.
priority
.
cascade_level
(
)
;
self
.
origin
=
level
.
origin
(
)
;
self
.
importance
=
level
.
importance
(
)
;
let
guard
=
match
self
.
origin
{
Origin
:
:
Author
=
>
self
.
guards
.
author
Origin
:
:
User
|
Origin
:
:
UserAgent
=
>
self
.
guards
.
ua_or_user
}
;
self
.
declarations
=
match
node
.
style_source
(
)
{
Some
(
source
)
=
>
source
.
read
(
guard
)
.
declaration_importance_iter
(
)
None
=
>
DeclarationImportanceIterator
:
:
default
(
)
}
;
}
}
impl
<
'
a
>
Iterator
for
DeclarationIterator
<
'
a
>
{
type
Item
=
(
&
'
a
PropertyDeclaration
CascadePriority
)
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
loop
{
if
let
Some
(
(
decl
importance
)
)
=
self
.
declarations
.
next_back
(
)
{
if
self
.
importance
!
=
importance
{
continue
;
}
if
let
Some
(
restriction
)
=
self
.
restriction
{
if
let
PropertyDeclarationId
:
:
Longhand
(
id
)
=
decl
.
id
(
)
{
if
!
id
.
flags
(
)
.
contains
(
restriction
)
&
&
self
.
origin
!
=
Origin
:
:
UserAgent
{
continue
;
}
}
}
return
Some
(
(
decl
self
.
priority
)
)
;
}
let
next_node
=
self
.
current_rule_node
.
take
(
)
?
.
parent
(
)
?
;
self
.
current_rule_node
=
Some
(
next_node
)
;
self
.
update_for_node
(
next_node
)
;
}
}
}
fn
cascade_rules
<
E
>
(
stylist
:
&
Stylist
pseudo
:
Option
<
&
PseudoElement
>
rule_node
:
&
StrongRuleNode
guards
:
&
StylesheetGuards
originating_element_style
:
Option
<
&
ComputedValues
>
parent_style
:
Option
<
&
ComputedValues
>
layout_parent_style
:
Option
<
&
ComputedValues
>
first_line_reparenting
:
FirstLineReparenting
cascade_mode
:
CascadeMode
cascade_input_flags
:
ComputedValueFlags
rule_cache
:
Option
<
&
RuleCache
>
rule_cache_conditions
:
&
mut
RuleCacheConditions
element
:
Option
<
E
>
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
{
apply_declarations
(
stylist
pseudo
rule_node
guards
DeclarationIterator
:
:
new
(
rule_node
guards
pseudo
)
originating_element_style
parent_style
layout_parent_style
first_line_reparenting
cascade_mode
cascade_input_flags
rule_cache
rule_cache_conditions
element
)
}
#
[
derive
(
Clone
Copy
)
]
pub
enum
CascadeMode
<
'
a
>
{
Unvisited
{
visited_rules
:
Option
<
&
'
a
StrongRuleNode
>
}
Visited
{
writing_mode
:
WritingMode
}
}
pub
fn
apply_declarations
<
'
a
E
I
>
(
stylist
:
&
Stylist
pseudo
:
Option
<
&
PseudoElement
>
rules
:
&
StrongRuleNode
guards
:
&
StylesheetGuards
iter
:
I
originating_element_style
:
Option
<
&
ComputedValues
>
parent_style
:
Option
<
&
ComputedValues
>
layout_parent_style
:
Option
<
&
ComputedValues
>
first_line_reparenting
:
FirstLineReparenting
cascade_mode
:
CascadeMode
cascade_input_flags
:
ComputedValueFlags
rule_cache
:
Option
<
&
RuleCache
>
rule_cache_conditions
:
&
mut
RuleCacheConditions
element
:
Option
<
E
>
)
-
>
Arc
<
ComputedValues
>
where
E
:
TElement
I
:
Iterator
<
Item
=
(
&
'
a
PropertyDeclaration
CascadePriority
)
>
{
debug_assert_eq
!
(
originating_element_style
.
is_some
(
)
element
.
is_some
(
)
&
&
pseudo
.
is_some
(
)
)
;
debug_assert
!
(
layout_parent_style
.
is_none
(
)
|
|
parent_style
.
is_some
(
)
)
;
let
device
=
stylist
.
device
(
)
;
let
inherited_style
=
parent_style
.
unwrap_or
(
device
.
default_computed_values
(
)
)
;
let
is_root_element
=
pseudo
.
is_none
(
)
&
&
element
.
map_or
(
false
|
e
|
e
.
is_root
(
)
)
;
let
container_size_query
=
ContainerSizeQuery
:
:
for_option_element
(
element
originating_element_style
)
;
let
mut
context
=
computed
:
:
Context
:
:
new
(
StyleBuilder
:
:
new
(
device
Some
(
stylist
)
parent_style
pseudo
Some
(
rules
.
clone
(
)
)
is_root_element
)
stylist
.
quirks_mode
(
)
rule_cache_conditions
container_size_query
)
;
context
.
style
(
)
.
add_flags
(
cascade_input_flags
)
;
let
using_cached_reset_properties
;
let
mut
cascade
=
Cascade
:
:
new
(
&
mut
context
cascade_mode
first_line_reparenting
)
;
let
mut
data
=
CascadeData
:
:
default
(
)
;
{
let
mut
builder
=
CustomPropertiesBuilder
:
:
new
(
inherited_style
.
custom_properties
(
)
stylist
)
;
for
(
declaration
priority
)
in
iter
{
if
let
PropertyDeclaration
:
:
Custom
(
ref
declaration
)
=
*
declaration
{
builder
.
cascade
(
declaration
priority
)
;
}
else
{
let
id
=
declaration
.
id
(
)
.
as_longhand
(
)
.
unwrap
(
)
;
data
.
note_declaration
(
declaration
priority
id
)
;
}
}
cascade
.
context
.
builder
.
custom_properties
=
builder
.
build
(
)
;
}
;
let
properties_to_apply
=
match
cascade
.
cascade_mode
{
CascadeMode
:
:
Visited
{
writing_mode
}
=
>
{
cascade
.
context
.
builder
.
writing_mode
=
writing_mode
;
using_cached_reset_properties
=
false
;
LonghandIdSet
:
:
visited_dependent
(
)
}
CascadeMode
:
:
Unvisited
{
visited_rules
}
=
>
{
cascade
.
apply_prioritary_properties
(
&
mut
data
)
;
if
let
Some
(
visited_rules
)
=
visited_rules
{
cascade
.
compute_visited_style_if_needed
(
element
originating_element_style
parent_style
layout_parent_style
visited_rules
guards
)
;
}
using_cached_reset_properties
=
cascade
.
try_to_use_cached_reset_properties
(
rule_cache
guards
)
;
if
using_cached_reset_properties
{
LonghandIdSet
:
:
late_group_only_inherited
(
)
}
else
{
LonghandIdSet
:
:
late_group
(
)
}
}
}
;
cascade
.
apply_non_prioritary_properties
(
&
mut
data
&
properties_to_apply
)
;
cascade
.
finished_applying_properties
(
)
;
std
:
:
mem
:
:
drop
(
cascade
)
;
context
.
builder
.
clear_modified_reset
(
)
;
if
matches
!
(
cascade_mode
CascadeMode
:
:
Unvisited
{
.
.
}
)
{
StyleAdjuster
:
:
new
(
&
mut
context
.
builder
)
.
adjust
(
layout_parent_style
.
unwrap_or
(
inherited_style
)
element
)
;
}
if
context
.
builder
.
modified_reset
(
)
|
|
using_cached_reset_properties
{
context
.
rule_cache_conditions
.
borrow_mut
(
)
.
set_uncacheable
(
)
;
}
context
.
builder
.
build
(
)
}
type
DeclarationsToApplyUnlessOverriden
=
SmallVec
<
[
PropertyDeclaration
;
2
]
>
;
fn
tweak_when_ignoring_colors
(
context
:
&
computed
:
:
Context
longhand_id
:
LonghandId
origin
:
Origin
declaration
:
&
mut
Cow
<
PropertyDeclaration
>
declarations_to_apply_unless_overridden
:
&
mut
DeclarationsToApplyUnlessOverriden
)
{
use
crate
:
:
values
:
:
computed
:
:
ToComputedValue
;
use
crate
:
:
values
:
:
specified
:
:
Color
;
if
!
longhand_id
.
ignored_when_document_colors_disabled
(
)
{
return
;
}
let
is_ua_or_user_rule
=
matches
!
(
origin
Origin
:
:
User
|
Origin
:
:
UserAgent
)
;
if
is_ua_or_user_rule
{
return
;
}
let
forced
=
context
.
builder
.
get_inherited_text
(
)
.
clone_forced_color_adjust
(
)
;
if
forced
=
=
computed
:
:
ForcedColorAdjust
:
:
None
{
return
;
}
if
context
.
builder
.
pseudo
.
map_or
(
false
|
p
|
p
.
is_color_swatch
(
)
)
&
&
longhand_id
=
=
LonghandId
:
:
BackgroundColor
{
return
;
}
fn
alpha_channel
(
color
:
&
Color
context
:
&
computed
:
:
Context
)
-
>
f32
{
color
.
to_computed_value
(
context
)
.
resolve_to_absolute
(
&
AbsoluteColor
:
:
BLACK
)
.
alpha
}
match
*
*
declaration
{
PropertyDeclaration
:
:
BackgroundColor
(
ref
color
)
=
>
{
if
color
.
honored_in_forced_colors_mode
(
true
)
{
return
;
}
let
alpha
=
alpha_channel
(
color
context
)
;
if
alpha
=
=
0
.
0
{
return
;
}
let
mut
color
=
context
.
builder
.
device
.
default_background_color
(
)
;
color
.
alpha
=
alpha
;
declarations_to_apply_unless_overridden
.
push
(
PropertyDeclaration
:
:
BackgroundColor
(
color
.
into
(
)
)
)
}
PropertyDeclaration
:
:
Color
(
ref
color
)
=
>
{
if
color
.
0
.
honored_in_forced_colors_mode
(
true
)
{
return
;
}
if
context
.
builder
.
get_parent_inherited_text
(
)
.
clone_color
(
)
.
alpha
=
=
0
.
0
{
let
color
=
context
.
builder
.
device
.
default_color
(
)
;
declarations_to_apply_unless_overridden
.
push
(
PropertyDeclaration
:
:
Color
(
specified
:
:
ColorPropertyValue
(
color
.
into
(
)
)
)
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
PropertyDeclaration
:
:
BackgroundImage
(
ref
bkg
)
=
>
{
use
crate
:
:
values
:
:
generics
:
:
image
:
:
Image
;
if
static_prefs
:
:
pref
!
(
"
browser
.
display
.
permit_backplate
"
)
{
if
bkg
.
0
.
iter
(
)
.
all
(
|
image
|
matches
!
(
*
image
Image
:
:
Url
(
.
.
)
|
Image
:
:
None
)
)
{
return
;
}
}
}
_
=
>
{
if
let
Some
(
color
)
=
declaration
.
color_value
(
)
{
if
color
.
honored_in_forced_colors_mode
(
false
)
{
return
;
}
}
}
}
*
declaration
.
to_mut
(
)
=
PropertyDeclaration
:
:
css_wide_keyword
(
longhand_id
CSSWideKeyword
:
:
Revert
)
;
}
type
DeclarationIndex
=
u16
;
#
[
derive
(
Copy
Clone
)
]
struct
PrioritaryDeclarationPosition
{
most_important
:
DeclarationIndex
least_important
:
DeclarationIndex
}
impl
Default
for
PrioritaryDeclarationPosition
{
fn
default
(
)
-
>
Self
{
Self
{
most_important
:
DeclarationIndex
:
:
MAX
least_important
:
DeclarationIndex
:
:
MAX
}
}
}
#
[
derive
(
Copy
Clone
)
]
struct
Declaration
<
'
a
>
{
decl
:
&
'
a
PropertyDeclaration
priority
:
CascadePriority
next_index
:
DeclarationIndex
}
#
[
derive
(
Default
)
]
struct
CascadeData
<
'
a
>
{
has_prioritary_properties
:
bool
shorthand_cache
:
ShorthandsWithPropertyReferencesCache
longhand_declarations
:
SmallVec
<
[
Declaration
<
'
a
>
;
32
]
>
prioritary_positions
:
[
PrioritaryDeclarationPosition
;
PRIORITARY_PROPERTY_COUNT
]
}
impl
<
'
a
>
CascadeData
<
'
a
>
{
fn
note_prioritary_property
(
&
mut
self
id
:
PrioritaryPropertyId
)
{
self
.
has_prioritary_properties
=
true
;
let
new_index
=
self
.
longhand_declarations
.
len
(
)
as
DeclarationIndex
;
let
position
=
&
mut
self
.
prioritary_positions
[
id
as
usize
]
;
if
position
.
most_important
=
=
DeclarationIndex
:
:
MAX
{
position
.
most_important
=
new_index
;
}
else
{
self
.
longhand_declarations
[
position
.
least_important
as
usize
]
.
next_index
=
new_index
;
}
position
.
least_important
=
new_index
;
}
fn
note_declaration
(
&
mut
self
decl
:
&
'
a
PropertyDeclaration
priority
:
CascadePriority
id
:
LonghandId
)
{
if
let
Some
(
id
)
=
PrioritaryPropertyId
:
:
from_longhand
(
id
)
{
self
.
note_prioritary_property
(
id
)
;
}
self
.
longhand_declarations
.
push
(
Declaration
{
decl
priority
next_index
:
0
}
)
;
}
}
struct
Cascade
<
'
a
'
b
:
'
a
>
{
context
:
&
'
a
mut
computed
:
:
Context
<
'
b
>
cascade_mode
:
CascadeMode
<
'
a
>
first_line_reparenting
:
FirstLineReparenting
<
'
b
>
ignore_colors
:
bool
seen
:
LonghandIdSet
author_specified
:
LonghandIdSet
reverted_set
:
LonghandIdSet
reverted
:
FxHashMap
<
LonghandId
(
CascadePriority
bool
)
>
declarations_to_apply_unless_overridden
:
DeclarationsToApplyUnlessOverriden
}
impl
<
'
a
'
b
:
'
a
>
Cascade
<
'
a
'
b
>
{
fn
new
(
context
:
&
'
a
mut
computed
:
:
Context
<
'
b
>
cascade_mode
:
CascadeMode
<
'
a
>
first_line_reparenting
:
FirstLineReparenting
<
'
b
>
)
-
>
Self
{
let
ignore_colors
=
!
context
.
builder
.
device
.
use_document_colors
(
)
;
Self
{
context
cascade_mode
first_line_reparenting
ignore_colors
seen
:
LonghandIdSet
:
:
default
(
)
author_specified
:
LonghandIdSet
:
:
default
(
)
reverted_set
:
Default
:
:
default
(
)
reverted
:
Default
:
:
default
(
)
declarations_to_apply_unless_overridden
:
Default
:
:
default
(
)
}
}
fn
substitute_variables_if_needed
<
'
cache
'
decl
>
(
&
mut
self
shorthand_cache
:
&
'
cache
mut
ShorthandsWithPropertyReferencesCache
declaration
:
&
'
decl
PropertyDeclaration
)
-
>
Cow
<
'
decl
PropertyDeclaration
>
where
'
cache
:
'
decl
{
let
declaration
=
match
*
declaration
{
PropertyDeclaration
:
:
WithVariables
(
ref
declaration
)
=
>
declaration
ref
d
=
>
return
Cow
:
:
Borrowed
(
d
)
}
;
if
!
declaration
.
id
.
inherited
(
)
{
self
.
context
.
rule_cache_conditions
.
borrow_mut
(
)
.
set_uncacheable
(
)
;
match
declaration
.
id
{
LonghandId
:
:
Display
=
>
{
self
.
context
.
builder
.
add_flags
(
ComputedValueFlags
:
:
DISPLAY_DEPENDS_ON_INHERITED_STYLE
)
;
}
LonghandId
:
:
Content
=
>
{
self
.
context
.
builder
.
add_flags
(
ComputedValueFlags
:
:
CONTENT_DEPENDS_ON_INHERITED_STYLE
)
;
}
_
=
>
{
}
}
}
debug_assert
!
(
self
.
context
.
builder
.
stylist
.
is_some
(
)
"
Need
a
Stylist
to
substitute
variables
!
"
)
;
declaration
.
value
.
substitute_variables
(
declaration
.
id
self
.
context
.
builder
.
writing_mode
self
.
context
.
builder
.
custom_properties
(
)
self
.
context
.
quirks_mode
self
.
context
.
builder
.
stylist
.
unwrap
(
)
shorthand_cache
)
}
fn
apply_one_prioritary_property
(
&
mut
self
data
:
&
mut
CascadeData
id
:
PrioritaryPropertyId
)
-
>
bool
{
let
mut
index
=
data
.
prioritary_positions
[
id
as
usize
]
.
most_important
;
if
index
=
=
DeclarationIndex
:
:
MAX
{
return
false
;
}
let
longhand_id
=
id
.
to_longhand
(
)
;
debug_assert
!
(
!
longhand_id
.
is_logical
(
)
"
That
could
require
more
book
-
keeping
"
)
;
loop
{
let
decl
=
data
.
longhand_declarations
[
index
as
usize
]
;
self
.
apply_one_longhand
(
longhand_id
longhand_id
decl
.
decl
decl
.
priority
&
mut
data
.
shorthand_cache
)
;
if
self
.
seen
.
contains
(
longhand_id
)
{
return
true
;
}
debug_assert
!
(
self
.
reverted_set
.
contains
(
longhand_id
)
"
How
else
can
we
fail
to
apply
a
prioritary
property
?
"
)
;
debug_assert
!
(
decl
.
next_index
=
=
0
|
|
decl
.
next_index
>
index
"
should
make
progress
!
{
}
-
>
{
}
"
index
decl
.
next_index
)
;
index
=
decl
.
next_index
;
if
index
=
=
0
{
break
;
}
}
false
}
fn
apply_prioritary_properties
(
&
mut
self
data
:
&
mut
CascadeData
)
{
if
!
data
.
has_prioritary_properties
{
return
;
}
let
has_writing_mode
=
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
WritingMode
)
|
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
Direction
)
|
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
TextOrientation
)
;
if
has_writing_mode
{
self
.
compute_writing_mode
(
)
;
}
let
has_font_family
=
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
FontFamily
)
;
let
has_lang
=
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
XLang
)
;
if
has_lang
{
self
.
recompute_initial_font_family_if_needed
(
)
;
}
if
has_font_family
{
self
.
prioritize_user_fonts_if_needed
(
)
;
}
if
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
XTextScale
)
{
self
.
unzoom_fonts_if_needed
(
)
;
}
let
has_font_size
=
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
FontSize
)
;
let
has_math_depth
=
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
MathDepth
)
;
let
has_min_font_size_ratio
=
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
MozMinFontSizeRatio
)
;
if
has_math_depth
&
&
has_font_size
{
self
.
recompute_math_font_size_if_needed
(
)
;
}
if
has_lang
|
|
has_font_family
{
self
.
recompute_keyword_font_size_if_needed
(
)
;
}
if
has_font_size
|
|
has_min_font_size_ratio
|
|
has_lang
|
|
has_font_family
{
self
.
constrain_font_size_if_needed
(
)
;
}
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
FontWeight
)
;
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
FontStretch
)
;
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
FontStyle
)
;
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
FontFamily
)
;
if
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
FontSizeAdjust
)
{
self
.
resolve_font_size_adjust_from_font_if_needed
(
)
;
}
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
ColorScheme
)
;
self
.
apply_one_prioritary_property
(
data
PrioritaryPropertyId
:
:
ForcedColorAdjust
)
;
}
fn
apply_non_prioritary_properties
(
&
mut
self
data
:
&
mut
CascadeData
properties_to_apply
:
&
LonghandIdSet
)
{
debug_assert
!
(
!
properties_to_apply
.
contains_any
(
LonghandIdSet
:
:
prioritary_properties
(
)
)
)
;
debug_assert
!
(
self
.
declarations_to_apply_unless_overridden
.
is_empty
(
)
)
;
for
declaration
in
&
data
.
longhand_declarations
{
let
longhand_id
=
declaration
.
decl
.
id
(
)
.
as_longhand
(
)
.
unwrap
(
)
;
if
!
properties_to_apply
.
contains
(
longhand_id
)
{
continue
;
}
debug_assert
!
(
PrioritaryPropertyId
:
:
from_longhand
(
longhand_id
)
.
is_none
(
)
)
;
let
physical_longhand_id
=
longhand_id
.
to_physical
(
self
.
context
.
builder
.
writing_mode
)
;
self
.
apply_one_longhand
(
longhand_id
physical_longhand_id
declaration
.
decl
declaration
.
priority
&
mut
data
.
shorthand_cache
)
;
}
if
!
self
.
declarations_to_apply_unless_overridden
.
is_empty
(
)
{
debug_assert
!
(
self
.
ignore_colors
)
;
for
declaration
in
std
:
:
mem
:
:
take
(
&
mut
self
.
declarations_to_apply_unless_overridden
)
{
let
longhand_id
=
declaration
.
id
(
)
.
as_longhand
(
)
.
unwrap
(
)
;
debug_assert
!
(
!
longhand_id
.
is_logical
(
)
)
;
if
!
self
.
seen
.
contains
(
longhand_id
)
{
self
.
do_apply_declaration
(
longhand_id
&
declaration
)
;
}
}
}
}
fn
apply_one_longhand
(
&
mut
self
longhand_id
:
LonghandId
physical_longhand_id
:
LonghandId
declaration
:
&
PropertyDeclaration
priority
:
CascadePriority
shorthand_cache
:
&
mut
ShorthandsWithPropertyReferencesCache
)
{
debug_assert
!
(
!
physical_longhand_id
.
is_logical
(
)
)
;
let
origin
=
priority
.
cascade_level
(
)
.
origin
(
)
;
if
self
.
seen
.
contains
(
physical_longhand_id
)
{
return
;
}
if
self
.
reverted_set
.
contains
(
physical_longhand_id
)
{
if
let
Some
(
&
(
reverted_priority
is_origin_revert
)
)
=
self
.
reverted
.
get
(
&
physical_longhand_id
)
{
if
!
reverted_priority
.
allows_when_reverted
(
&
priority
is_origin_revert
)
{
return
;
}
}
}
let
mut
declaration
=
self
.
substitute_variables_if_needed
(
shorthand_cache
declaration
)
;
if
self
.
ignore_colors
{
tweak_when_ignoring_colors
(
&
self
.
context
physical_longhand_id
origin
&
mut
declaration
&
mut
self
.
declarations_to_apply_unless_overridden
)
;
}
let
is_unset
=
match
declaration
.
get_css_wide_keyword
(
)
{
Some
(
keyword
)
=
>
match
keyword
{
CSSWideKeyword
:
:
RevertLayer
|
CSSWideKeyword
:
:
Revert
=
>
{
let
origin_revert
=
keyword
=
=
CSSWideKeyword
:
:
Revert
;
self
.
reverted_set
.
insert
(
physical_longhand_id
)
;
self
.
reverted
.
insert
(
physical_longhand_id
(
priority
origin_revert
)
)
;
return
;
}
CSSWideKeyword
:
:
Unset
=
>
true
CSSWideKeyword
:
:
Inherit
=
>
physical_longhand_id
.
inherited
(
)
CSSWideKeyword
:
:
Initial
=
>
!
physical_longhand_id
.
inherited
(
)
}
None
=
>
false
}
;
self
.
seen
.
insert
(
physical_longhand_id
)
;
if
origin
=
=
Origin
:
:
Author
{
self
.
author_specified
.
insert
(
physical_longhand_id
)
;
}
if
is_unset
{
return
;
}
self
.
do_apply_declaration
(
longhand_id
&
declaration
)
}
#
[
inline
]
fn
do_apply_declaration
(
&
mut
self
longhand_id
:
LonghandId
declaration
:
&
PropertyDeclaration
)
{
(
CASCADE_PROPERTY
[
longhand_id
as
usize
]
)
(
&
declaration
&
mut
self
.
context
)
;
}
fn
compute_writing_mode
(
&
mut
self
)
{
debug_assert
!
(
matches
!
(
self
.
cascade_mode
CascadeMode
:
:
Unvisited
{
.
.
}
)
)
;
self
.
context
.
builder
.
writing_mode
=
WritingMode
:
:
new
(
self
.
context
.
builder
.
get_inherited_box
(
)
)
}
fn
compute_visited_style_if_needed
<
E
>
(
&
mut
self
element
:
Option
<
E
>
originating_element_style
:
Option
<
&
ComputedValues
>
parent_style
:
Option
<
&
ComputedValues
>
layout_parent_style
:
Option
<
&
ComputedValues
>
visited_rules
:
&
StrongRuleNode
guards
:
&
StylesheetGuards
)
where
E
:
TElement
{
debug_assert
!
(
matches
!
(
self
.
cascade_mode
CascadeMode
:
:
Unvisited
{
.
.
}
)
)
;
let
is_link
=
self
.
context
.
builder
.
pseudo
.
is_none
(
)
&
&
element
.
unwrap
(
)
.
is_link
(
)
;
macro_rules
!
visited_parent
{
(
parent
:
expr
)
=
>
{
if
is_link
{
parent
}
else
{
parent
.
map
(
|
p
|
p
.
visited_style
(
)
.
unwrap_or
(
p
)
)
}
}
;
}
let
writing_mode
=
self
.
context
.
builder
.
writing_mode
;
let
style
=
cascade_rules
(
self
.
context
.
builder
.
stylist
.
unwrap
(
)
self
.
context
.
builder
.
pseudo
visited_rules
guards
visited_parent
!
(
originating_element_style
)
visited_parent
!
(
parent_style
)
visited_parent
!
(
layout_parent_style
)
self
.
first_line_reparenting
CascadeMode
:
:
Visited
{
writing_mode
}
Default
:
:
default
(
)
None
&
mut
*
self
.
context
.
rule_cache_conditions
.
borrow_mut
(
)
element
)
;
self
.
context
.
builder
.
visited_style
=
Some
(
style
)
;
}
fn
finished_applying_properties
(
&
mut
self
)
{
let
builder
=
&
mut
self
.
context
.
builder
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
{
if
let
Some
(
bg
)
=
builder
.
get_background_if_mutated
(
)
{
bg
.
fill_arrays
(
)
;
}
if
let
Some
(
svg
)
=
builder
.
get_svg_if_mutated
(
)
{
svg
.
fill_arrays
(
)
;
}
}
if
self
.
author_specified
.
contains_any
(
LonghandIdSet
:
:
border_background_properties
(
)
)
{
builder
.
add_flags
(
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_BORDER_BACKGROUND
)
;
}
if
self
.
author_specified
.
contains
(
LonghandId
:
:
FontFamily
)
{
builder
.
add_flags
(
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_FONT_FAMILY
)
;
}
if
self
.
author_specified
.
contains
(
LonghandId
:
:
Color
)
{
builder
.
add_flags
(
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_TEXT_COLOR
)
;
}
if
self
.
author_specified
.
contains
(
LonghandId
:
:
LetterSpacing
)
{
builder
.
add_flags
(
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_LETTER_SPACING
)
;
}
if
self
.
author_specified
.
contains
(
LonghandId
:
:
WordSpacing
)
{
builder
.
add_flags
(
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_WORD_SPACING
)
;
}
if
self
.
author_specified
.
contains
(
LonghandId
:
:
FontSynthesisWeight
)
{
builder
.
add_flags
(
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_FONT_SYNTHESIS_WEIGHT
)
;
}
if
self
.
author_specified
.
contains
(
LonghandId
:
:
FontSynthesisStyle
)
{
builder
.
add_flags
(
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_FONT_SYNTHESIS_STYLE
)
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
{
if
let
Some
(
font
)
=
builder
.
get_font_if_mutated
(
)
{
font
.
compute_font_hash
(
)
;
}
}
}
fn
try_to_use_cached_reset_properties
(
&
mut
self
cache
:
Option
<
&
'
b
RuleCache
>
guards
:
&
StylesheetGuards
)
-
>
bool
{
let
style
=
match
self
.
first_line_reparenting
{
FirstLineReparenting
:
:
Yes
{
style_to_reparent
}
=
>
style_to_reparent
FirstLineReparenting
:
:
No
=
>
{
let
Some
(
cache
)
=
cache
else
{
return
false
}
;
let
Some
(
style
)
=
cache
.
find
(
guards
&
self
.
context
.
builder
)
else
{
return
false
;
}
;
style
}
}
;
let
builder
=
&
mut
self
.
context
.
builder
;
builder
.
copy_reset_from
(
style
)
;
let
bits_to_copy
=
ComputedValueFlags
:
:
HAS_AUTHOR_SPECIFIED_BORDER_BACKGROUND
|
ComputedValueFlags
:
:
DEPENDS_ON_SELF_FONT_METRICS
|
ComputedValueFlags
:
:
DEPENDS_ON_INHERITED_FONT_METRICS
|
ComputedValueFlags
:
:
USES_CONTAINER_UNITS
|
ComputedValueFlags
:
:
USES_VIEWPORT_UNITS
;
builder
.
add_flags
(
style
.
flags
&
bits_to_copy
)
;
true
}
#
[
inline
]
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
recompute_initial_font_family_if_needed
(
&
mut
self
)
{
use
crate
:
:
gecko_bindings
:
:
bindings
;
use
crate
:
:
values
:
:
computed
:
:
font
:
:
FontFamily
;
let
builder
=
&
mut
self
.
context
.
builder
;
let
default_font_type
=
{
let
font
=
builder
.
get_font
(
)
;
if
!
font
.
mFont
.
family
.
is_initial
{
return
;
}
let
default_font_type
=
unsafe
{
bindings
:
:
Gecko_nsStyleFont_ComputeFallbackFontTypeForLanguage
(
builder
.
device
.
document
(
)
font
.
mLanguage
.
mRawPtr
)
}
;
let
initial_generic
=
font
.
mFont
.
family
.
families
.
single_generic
(
)
;
debug_assert
!
(
initial_generic
.
is_some
(
)
"
Initial
font
should
be
just
one
generic
font
"
)
;
if
initial_generic
=
=
Some
(
default_font_type
)
{
return
;
}
default_font_type
}
;
builder
.
mutate_font
(
)
.
mFont
.
family
.
families
=
FontFamily
:
:
generic
(
default_font_type
)
.
families
.
clone
(
)
;
}
#
[
inline
]
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
prioritize_user_fonts_if_needed
(
&
mut
self
)
{
use
crate
:
:
gecko_bindings
:
:
bindings
;
if
static_prefs
:
:
pref
!
(
"
browser
.
display
.
use_document_fonts
"
)
!
=
0
{
return
;
}
let
builder
=
&
mut
self
.
context
.
builder
;
let
default_font_type
=
{
let
font
=
builder
.
get_font
(
)
;
if
font
.
mFont
.
family
.
is_system_font
{
return
;
}
if
!
font
.
mFont
.
family
.
families
.
needs_user_font_prioritization
(
)
{
return
;
}
unsafe
{
bindings
:
:
Gecko_nsStyleFont_ComputeFallbackFontTypeForLanguage
(
builder
.
device
.
document
(
)
font
.
mLanguage
.
mRawPtr
)
}
}
;
let
font
=
builder
.
mutate_font
(
)
;
font
.
mFont
.
family
.
families
.
prioritize_first_generic_or_prepend
(
default_font_type
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
recompute_keyword_font_size_if_needed
(
&
mut
self
)
{
use
crate
:
:
values
:
:
computed
:
:
ToComputedValue
;
if
!
self
.
seen
.
contains
(
LonghandId
:
:
XLang
)
&
&
!
self
.
seen
.
contains
(
LonghandId
:
:
FontFamily
)
{
return
;
}
let
new_size
=
{
let
font
=
self
.
context
.
builder
.
get_font
(
)
;
let
info
=
font
.
clone_font_size
(
)
.
keyword_info
;
let
new_size
=
match
info
.
kw
{
specified
:
:
FontSizeKeyword
:
:
None
=
>
return
_
=
>
{
self
.
context
.
for_non_inherited_property
=
false
;
specified
:
:
FontSize
:
:
Keyword
(
info
)
.
to_computed_value
(
self
.
context
)
}
}
;
if
font
.
mScriptUnconstrainedSize
=
=
new_size
.
computed_size
{
return
;
}
new_size
}
;
self
.
context
.
builder
.
mutate_font
(
)
.
set_font_size
(
new_size
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
constrain_font_size_if_needed
(
&
mut
self
)
{
use
crate
:
:
gecko_bindings
:
:
bindings
;
use
crate
:
:
values
:
:
generics
:
:
NonNegative
;
let
builder
=
&
mut
self
.
context
.
builder
;
let
min_font_size
=
{
let
font
=
builder
.
get_font
(
)
;
let
min_font_size
=
unsafe
{
bindings
:
:
Gecko_nsStyleFont_ComputeMinSize
(
&
*
*
font
builder
.
device
.
document
(
)
)
}
;
if
font
.
mFont
.
size
.
0
>
=
min_font_size
{
return
;
}
NonNegative
(
min_font_size
)
}
;
builder
.
mutate_font
(
)
.
mFont
.
size
=
min_font_size
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
unzoom_fonts_if_needed
(
&
mut
self
)
{
debug_assert
!
(
self
.
seen
.
contains
(
LonghandId
:
:
XTextScale
)
)
;
let
builder
=
&
mut
self
.
context
.
builder
;
let
parent_text_scale
=
builder
.
get_parent_font
(
)
.
clone__x_text_scale
(
)
;
let
text_scale
=
builder
.
get_font
(
)
.
clone__x_text_scale
(
)
;
if
parent_text_scale
=
=
text_scale
{
return
;
}
debug_assert_ne
!
(
parent_text_scale
.
text_zoom_enabled
(
)
text_scale
.
text_zoom_enabled
(
)
"
There
'
s
only
one
value
that
disables
it
"
)
;
debug_assert
!
(
!
text_scale
.
text_zoom_enabled
(
)
"
We
only
ever
disable
text
zoom
(
in
svg
:
text
)
never
enable
it
"
)
;
let
device
=
builder
.
device
;
builder
.
mutate_font
(
)
.
unzoom_fonts
(
device
)
;
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
recompute_math_font_size_if_needed
(
&
mut
self
)
{
use
crate
:
:
values
:
:
generics
:
:
NonNegative
;
if
self
.
context
.
builder
.
get_font
(
)
.
clone_font_size
(
)
.
keyword_info
.
kw
!
=
specified
:
:
FontSizeKeyword
:
:
Math
{
return
;
}
const
SCALE_FACTOR_WHEN_INCREMENTING_MATH_DEPTH_BY_ONE
:
f32
=
0
.
71
;
fn
scale_factor_for_math_depth_change
(
parent_math_depth
:
i32
computed_math_depth
:
i32
parent_script_percent_scale_down
:
Option
<
f32
>
parent_script_script_percent_scale_down
:
Option
<
f32
>
)
-
>
f32
{
let
mut
a
=
parent_math_depth
;
let
mut
b
=
computed_math_depth
;
let
c
=
SCALE_FACTOR_WHEN_INCREMENTING_MATH_DEPTH_BY_ONE
;
let
scale_between_0_and_1
=
parent_script_percent_scale_down
.
unwrap_or_else
(
|
|
c
)
;
let
scale_between_0_and_2
=
parent_script_script_percent_scale_down
.
unwrap_or_else
(
|
|
c
*
c
)
;
let
mut
s
=
1
.
0
;
let
mut
invert_scale_factor
=
false
;
if
a
=
=
b
{
return
s
;
}
if
b
<
a
{
mem
:
:
swap
(
&
mut
a
&
mut
b
)
;
invert_scale_factor
=
true
;
}
let
mut
e
=
b
-
a
;
if
a
<
=
0
&
&
b
>
=
2
{
s
*
=
scale_between_0_and_2
;
e
-
=
2
;
}
else
if
a
=
=
1
{
s
*
=
scale_between_0_and_2
/
scale_between_0_and_1
;
e
-
=
1
;
}
else
if
b
=
=
1
{
s
*
=
scale_between_0_and_1
;
e
-
=
1
;
}
s
*
=
(
c
as
f32
)
.
powi
(
e
)
;
if
invert_scale_factor
{
1
.
0
/
s
.
max
(
f32
:
:
MIN_POSITIVE
)
}
else
{
s
}
}
let
(
new_size
new_unconstrained_size
)
=
{
let
builder
=
&
self
.
context
.
builder
;
let
font
=
builder
.
get_font
(
)
;
let
parent_font
=
builder
.
get_parent_font
(
)
;
let
delta
=
font
.
mMathDepth
.
saturating_sub
(
parent_font
.
mMathDepth
)
;
if
delta
=
=
0
{
return
;
}
let
mut
min
=
parent_font
.
mScriptMinSize
;
if
font
.
mXTextScale
.
text_zoom_enabled
(
)
{
min
=
builder
.
device
.
zoom_text
(
min
)
;
}
let
scale
=
{
let
font_metrics
=
self
.
context
.
query_font_metrics
(
FontBaseSize
:
:
InheritedStyle
FontMetricsOrientation
:
:
Horizontal
true
)
;
scale_factor_for_math_depth_change
(
parent_font
.
mMathDepth
as
i32
font
.
mMathDepth
as
i32
font_metrics
.
script_percent_scale_down
font_metrics
.
script_script_percent_scale_down
)
}
;
let
parent_size
=
parent_font
.
mSize
.
0
;
let
parent_unconstrained_size
=
parent_font
.
mScriptUnconstrainedSize
.
0
;
let
new_size
=
parent_size
.
scale_by
(
scale
)
;
let
new_unconstrained_size
=
parent_unconstrained_size
.
scale_by
(
scale
)
;
if
scale
<
=
1
.
{
if
parent_size
<
=
min
{
(
parent_size
new_unconstrained_size
)
}
else
{
(
min
.
max
(
new_size
)
new_unconstrained_size
)
}
}
else
{
(
new_size
.
min
(
new_unconstrained_size
.
max
(
min
)
)
new_unconstrained_size
)
}
}
;
let
font
=
self
.
context
.
builder
.
mutate_font
(
)
;
font
.
mFont
.
size
=
NonNegative
(
new_size
)
;
font
.
mSize
=
NonNegative
(
new_size
)
;
font
.
mScriptUnconstrainedSize
=
NonNegative
(
new_unconstrained_size
)
;
}
fn
resolve_font_size_adjust_from_font_if_needed
(
&
mut
self
)
{
use
crate
:
:
values
:
:
computed
:
:
font
:
:
{
FontSizeAdjust
FontSizeAdjustFactor
as
Factor
}
;
let
font_metrics
=
|
vertical
|
{
let
orient
=
if
vertical
{
FontMetricsOrientation
:
:
MatchContextPreferVertical
}
else
{
FontMetricsOrientation
:
:
Horizontal
}
;
let
metrics
=
self
.
context
.
query_font_metrics
(
FontBaseSize
:
:
CurrentStyle
orient
false
)
;
let
font_size
=
self
.
context
.
style
(
)
.
get_font
(
)
.
clone_font_size
(
)
.
used_size
.
0
;
(
metrics
font_size
)
}
;
macro_rules
!
resolve
{
(
basis
:
ident
value
:
expr
vertical
:
expr
field
:
ident
fallback
:
expr
)
=
>
{
{
if
value
!
=
Factor
:
:
FromFont
{
return
;
}
let
(
metrics
font_size
)
=
font_metrics
(
vertical
)
;
let
ratio
=
if
let
Some
(
metric
)
=
metrics
.
field
{
metric
/
font_size
}
else
if
fallback
>
=
0
.
0
{
fallback
}
else
{
metrics
.
ascent
/
font_size
}
;
FontSizeAdjust
:
:
basis
(
Factor
:
:
new
(
ratio
)
)
}
}
;
}
let
resolved
=
match
self
.
context
.
builder
.
get_font
(
)
.
mFont
.
sizeAdjust
{
FontSizeAdjust
:
:
None
=
>
return
FontSizeAdjust
:
:
ExHeight
(
val
)
=
>
resolve
!
(
ExHeight
val
false
x_height
0
.
5
)
FontSizeAdjust
:
:
CapHeight
(
val
)
=
>
{
resolve
!
(
CapHeight
val
false
cap_height
-
1
.
0
/
*
fall
back
to
ascent
*
/
)
}
FontSizeAdjust
:
:
ChWidth
(
val
)
=
>
{
resolve
!
(
ChWidth
val
false
zero_advance_measure
0
.
5
)
}
FontSizeAdjust
:
:
IcWidth
(
val
)
=
>
resolve
!
(
IcWidth
val
false
ic_width
1
.
0
)
FontSizeAdjust
:
:
IcHeight
(
val
)
=
>
resolve
!
(
IcHeight
val
true
ic_width
1
.
0
)
}
;
self
.
context
.
builder
.
mutate_font
(
)
.
mFont
.
sizeAdjust
=
resolved
}
}
