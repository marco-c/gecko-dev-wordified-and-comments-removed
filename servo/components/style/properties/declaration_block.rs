#
!
[
deny
(
missing_docs
)
]
use
super
:
:
{
property_counts
AllShorthand
ComputedValues
LogicalGroupSet
LonghandIdSet
LonghandIdSetIterator
NonCustomPropertyIdSet
PropertyDeclaration
PropertyDeclarationId
PropertyId
ShorthandId
SourcePropertyDeclaration
SourcePropertyDeclarationDrain
SubpropertiesVec
}
;
use
crate
:
:
context
:
:
QuirksMode
;
use
crate
:
:
custom_properties
;
use
crate
:
:
error_reporting
:
:
{
ContextualParseError
ParseErrorReporter
}
;
use
crate
:
:
parser
:
:
ParserContext
;
use
crate
:
:
properties
:
:
{
animated_properties
:
:
{
AnimationValue
AnimationValueMap
}
StyleBuilder
}
;
use
crate
:
:
rule_cache
:
:
RuleCacheConditions
;
use
crate
:
:
selector_map
:
:
PrecomputedHashSet
;
use
crate
:
:
selector_parser
:
:
SelectorImpl
;
use
crate
:
:
shared_lock
:
:
Locked
;
use
crate
:
:
str
:
:
{
CssString
CssStringWriter
}
;
use
crate
:
:
stylesheets
:
:
container_rule
:
:
ContainerSizeQuery
;
use
crate
:
:
stylesheets
:
:
{
CssRuleType
Origin
UrlExtraData
}
;
use
crate
:
:
stylist
:
:
Stylist
;
use
crate
:
:
values
:
:
computed
:
:
Context
;
use
cssparser
:
:
{
parse_important
AtRuleParser
CowRcStr
DeclarationParser
Delimiter
ParseErrorKind
Parser
ParserInput
ParserState
QualifiedRuleParser
RuleBodyItemParser
RuleBodyParser
SourceLocation
}
;
use
itertools
:
:
Itertools
;
use
selectors
:
:
SelectorList
;
use
servo_arc
:
:
Arc
;
use
smallbitvec
:
:
SmallBitVec
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
iter
:
:
Zip
;
use
std
:
:
slice
:
:
Iter
;
use
style_traits
:
:
{
CssWriter
ParseError
ParsingMode
StyleParseErrorKind
ToCss
TypedValue
}
;
use
thin_vec
:
:
ThinVec
;
#
[
derive
(
Default
)
]
pub
struct
AnimationDeclarations
{
pub
animations
:
Option
<
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
pub
transitions
:
Option
<
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
}
impl
AnimationDeclarations
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
animations
.
is_none
(
)
&
&
self
.
transitions
.
is_none
(
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
enum
DeclarationUpdate
{
None
Append
UpdateInPlace
{
pos
:
usize
}
AppendAndRemove
{
pos
:
usize
}
}
#
[
derive
(
Default
)
]
pub
struct
SourcePropertyDeclarationUpdate
{
updates
:
SubpropertiesVec
<
DeclarationUpdate
>
new_count
:
usize
any_removal
:
bool
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
)
]
pub
enum
Importance
{
Normal
Important
}
impl
Default
for
Importance
{
fn
default
(
)
-
>
Self
{
Self
:
:
Normal
}
}
impl
Importance
{
pub
fn
important
(
self
)
-
>
bool
{
match
self
{
Self
:
:
Normal
=
>
false
Self
:
:
Important
=
>
true
}
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
repr
(
C
)
]
pub
enum
PropertyTypedValue
{
None
Unsupported
Typed
(
TypedValue
)
}
#
[
derive
(
Clone
Debug
ToShmem
Default
MallocSizeOf
)
]
pub
struct
PropertyDeclarationIdSet
{
longhands
:
LonghandIdSet
custom
:
PrecomputedHashSet
<
custom_properties
:
:
Name
>
}
impl
PropertyDeclarationIdSet
{
pub
fn
insert
(
&
mut
self
id
:
PropertyDeclarationId
)
-
>
bool
{
match
id
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
{
if
self
.
longhands
.
contains
(
id
)
{
return
false
;
}
self
.
longhands
.
insert
(
id
)
;
return
true
;
}
PropertyDeclarationId
:
:
Custom
(
name
)
=
>
self
.
custom
.
insert
(
(
*
name
)
.
clone
(
)
)
}
}
pub
fn
contains
(
&
self
id
:
PropertyDeclarationId
)
-
>
bool
{
match
id
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
self
.
longhands
.
contains
(
id
)
PropertyDeclarationId
:
:
Custom
(
name
)
=
>
self
.
custom
.
contains
(
name
)
}
}
pub
fn
remove
(
&
mut
self
id
:
PropertyDeclarationId
)
{
match
id
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
self
.
longhands
.
remove
(
id
)
PropertyDeclarationId
:
:
Custom
(
name
)
=
>
{
self
.
custom
.
remove
(
name
)
;
}
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
longhands
.
clear
(
)
;
self
.
custom
.
clear
(
)
;
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
longhands
.
is_empty
(
)
&
&
self
.
custom
.
is_empty
(
)
}
#
[
inline
]
pub
fn
contains_any_reset
(
&
self
)
-
>
bool
{
self
.
longhands
.
contains_any_reset
(
)
}
#
[
inline
]
pub
fn
contains_all_longhands
(
&
self
longhands
:
&
LonghandIdSet
)
-
>
bool
{
self
.
longhands
.
contains_all
(
longhands
)
}
#
[
inline
]
pub
fn
contains_all
(
&
self
properties
:
&
PropertyDeclarationIdSet
)
-
>
bool
{
if
!
self
.
longhands
.
contains_all
(
&
properties
.
longhands
)
{
return
false
;
}
if
properties
.
custom
.
len
(
)
>
self
.
custom
.
len
(
)
{
return
false
;
}
properties
.
custom
.
iter
(
)
.
all
(
|
item
|
self
.
custom
.
contains
(
item
)
)
}
pub
fn
iter
(
&
self
)
-
>
PropertyDeclarationIdSetIterator
<
'
_
>
{
PropertyDeclarationIdSetIterator
{
longhands
:
self
.
longhands
.
iter
(
)
custom
:
self
.
custom
.
iter
(
)
}
}
}
pub
struct
PropertyDeclarationIdSetIterator
<
'
a
>
{
longhands
:
LonghandIdSetIterator
<
'
a
>
custom
:
std
:
:
collections
:
:
hash_set
:
:
Iter
<
'
a
custom_properties
:
:
Name
>
}
impl
<
'
a
>
Iterator
for
PropertyDeclarationIdSetIterator
<
'
a
>
{
type
Item
=
PropertyDeclarationId
<
'
a
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
match
self
.
longhands
.
next
(
)
{
Some
(
id
)
=
>
Some
(
PropertyDeclarationId
:
:
Longhand
(
id
)
)
None
=
>
match
self
.
custom
.
next
(
)
{
Some
(
a
)
=
>
Some
(
PropertyDeclarationId
:
:
Custom
(
a
)
)
None
=
>
None
}
}
}
}
#
[
cfg_attr
(
feature
=
"
gecko
"
derive
(
MallocSizeOf
)
)
]
#
[
derive
(
Clone
ToShmem
Default
)
]
pub
struct
PropertyDeclarationBlock
{
declarations
:
ThinVec
<
PropertyDeclaration
>
declarations_importance
:
SmallBitVec
property_ids
:
PropertyDeclarationIdSet
}
pub
struct
DeclarationImportanceIterator
<
'
a
>
{
iter
:
Zip
<
Iter
<
'
a
PropertyDeclaration
>
smallbitvec
:
:
Iter
<
'
a
>
>
}
impl
<
'
a
>
Default
for
DeclarationImportanceIterator
<
'
a
>
{
fn
default
(
)
-
>
Self
{
Self
{
iter
:
[
]
.
iter
(
)
.
zip
(
smallbitvec
:
:
Iter
:
:
default
(
)
)
}
}
}
impl
<
'
a
>
DeclarationImportanceIterator
<
'
a
>
{
fn
new
(
declarations
:
&
'
a
[
PropertyDeclaration
]
important
:
&
'
a
SmallBitVec
)
-
>
Self
{
DeclarationImportanceIterator
{
iter
:
declarations
.
iter
(
)
.
zip
(
important
.
iter
(
)
)
}
}
}
impl
<
'
a
>
Iterator
for
DeclarationImportanceIterator
<
'
a
>
{
type
Item
=
(
&
'
a
PropertyDeclaration
Importance
)
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
iter
.
next
(
)
.
map
(
|
(
decl
important
)
|
{
(
decl
if
important
{
Importance
:
:
Important
}
else
{
Importance
:
:
Normal
}
)
}
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
'
a
>
DoubleEndedIterator
for
DeclarationImportanceIterator
<
'
a
>
{
#
[
inline
(
always
)
]
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
iter
.
next_back
(
)
.
map
(
|
(
decl
important
)
|
{
(
decl
if
important
{
Importance
:
:
Important
}
else
{
Importance
:
:
Normal
}
)
}
)
}
}
pub
struct
AnimationValueIterator
<
'
a
'
cx
'
cx_a
:
'
cx
>
{
iter
:
DeclarationImportanceIterator
<
'
a
>
context
:
&
'
cx
mut
Context
<
'
cx_a
>
style
:
&
'
a
ComputedValues
default_values
:
&
'
a
ComputedValues
}
impl
<
'
a
'
cx
'
cx_a
:
'
cx
>
AnimationValueIterator
<
'
a
'
cx
'
cx_a
>
{
fn
new
(
declarations
:
&
'
a
PropertyDeclarationBlock
context
:
&
'
cx
mut
Context
<
'
cx_a
>
style
:
&
'
a
ComputedValues
default_values
:
&
'
a
ComputedValues
)
-
>
AnimationValueIterator
<
'
a
'
cx
'
cx_a
>
{
AnimationValueIterator
{
iter
:
declarations
.
declaration_importance_iter
(
)
context
style
default_values
}
}
}
impl
<
'
a
'
cx
'
cx_a
:
'
cx
>
Iterator
for
AnimationValueIterator
<
'
a
'
cx
'
cx_a
>
{
type
Item
=
AnimationValue
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
loop
{
let
(
decl
importance
)
=
self
.
iter
.
next
(
)
?
;
if
importance
.
important
(
)
{
continue
;
}
let
animation
=
AnimationValue
:
:
from_declaration
(
decl
&
mut
self
.
context
self
.
style
self
.
default_values
)
;
if
let
Some
(
anim
)
=
animation
{
return
Some
(
anim
)
;
}
}
}
}
impl
fmt
:
:
Debug
for
PropertyDeclarationBlock
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
declarations
.
fmt
(
f
)
}
}
impl
PropertyDeclarationBlock
{
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
declarations
.
len
(
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
declarations
.
is_empty
(
)
}
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
PropertyDeclarationBlock
{
declarations
:
ThinVec
:
:
new
(
)
declarations_importance
:
SmallBitVec
:
:
new
(
)
property_ids
:
PropertyDeclarationIdSet
:
:
default
(
)
}
}
pub
fn
with_one
(
declaration
:
PropertyDeclaration
importance
:
Importance
)
-
>
Self
{
let
mut
property_ids
=
PropertyDeclarationIdSet
:
:
default
(
)
;
property_ids
.
insert
(
declaration
.
id
(
)
)
;
let
mut
declarations
=
ThinVec
:
:
with_capacity
(
1
)
;
declarations
.
push
(
declaration
)
;
PropertyDeclarationBlock
{
declarations
declarations_importance
:
SmallBitVec
:
:
from_elem
(
1
importance
.
important
(
)
)
property_ids
}
}
#
[
inline
]
pub
fn
declarations
(
&
self
)
-
>
&
[
PropertyDeclaration
]
{
&
self
.
declarations
}
#
[
inline
]
pub
fn
declarations_importance
(
&
self
)
-
>
&
SmallBitVec
{
&
self
.
declarations_importance
}
#
[
inline
]
pub
fn
declaration_importance_iter
(
&
self
)
-
>
DeclarationImportanceIterator
<
'
_
>
{
DeclarationImportanceIterator
:
:
new
(
&
self
.
declarations
&
self
.
declarations_importance
)
}
#
[
inline
]
pub
fn
normal_declaration_iter
<
'
a
>
(
&
'
a
self
)
-
>
impl
DoubleEndedIterator
<
Item
=
&
'
a
PropertyDeclaration
>
{
self
.
declaration_importance_iter
(
)
.
filter
(
|
(
_
importance
)
|
!
importance
.
important
(
)
)
.
map
(
|
(
declaration
_
)
|
declaration
)
}
#
[
inline
]
pub
fn
to_animation_value_iter
<
'
a
'
cx
'
cx_a
:
'
cx
>
(
&
'
a
self
context
:
&
'
cx
mut
Context
<
'
cx_a
>
style
:
&
'
a
ComputedValues
default_values
:
&
'
a
ComputedValues
)
-
>
AnimationValueIterator
<
'
a
'
cx
'
cx_a
>
{
AnimationValueIterator
:
:
new
(
self
context
style
default_values
)
}
#
[
inline
]
pub
fn
any_important
(
&
self
)
-
>
bool
{
!
self
.
declarations_importance
.
all_false
(
)
}
#
[
inline
]
pub
fn
any_normal
(
&
self
)
-
>
bool
{
!
self
.
declarations_importance
.
all_true
(
)
}
#
[
inline
]
pub
fn
property_ids
(
&
self
)
-
>
&
PropertyDeclarationIdSet
{
&
self
.
property_ids
}
#
[
inline
]
pub
fn
contains
(
&
self
id
:
PropertyDeclarationId
)
-
>
bool
{
self
.
property_ids
.
contains
(
id
)
}
#
[
inline
]
pub
fn
contains_any_reset
(
&
self
)
-
>
bool
{
self
.
property_ids
.
contains_any_reset
(
)
}
#
[
inline
]
pub
fn
get
(
&
self
property
:
PropertyDeclarationId
)
-
>
Option
<
(
&
PropertyDeclaration
Importance
)
>
{
if
!
self
.
contains
(
property
)
{
return
None
;
}
self
.
declaration_importance_iter
(
)
.
find
(
|
(
declaration
_
)
|
declaration
.
id
(
)
=
=
property
)
}
pub
fn
shorthand_to_css
(
&
self
shorthand
:
ShorthandId
dest
:
&
mut
CssStringWriter
)
-
>
fmt
:
:
Result
{
let
mut
list
=
SmallVec
:
:
<
[
&
_
;
10
]
>
:
:
new
(
)
;
let
mut
important_count
=
0
;
for
longhand
in
shorthand
.
longhands
(
)
{
let
declaration
=
self
.
get
(
PropertyDeclarationId
:
:
Longhand
(
longhand
)
)
;
match
declaration
{
Some
(
(
declaration
importance
)
)
=
>
{
list
.
push
(
declaration
)
;
if
importance
.
important
(
)
{
important_count
+
=
1
;
}
}
None
=
>
return
Ok
(
(
)
)
}
}
if
important_count
>
0
&
&
important_count
!
=
list
.
len
(
)
{
return
Ok
(
(
)
)
;
}
match
shorthand
.
get_shorthand_appendable_value
(
&
list
)
{
Some
(
appendable_value
)
=
>
append_declaration_value
(
dest
appendable_value
)
None
=
>
return
Ok
(
(
)
)
}
}
pub
fn
property_value_to_css
(
&
self
property
:
&
PropertyId
dest
:
&
mut
CssStringWriter
)
-
>
fmt
:
:
Result
{
let
longhand_or_custom
=
match
property
.
as_shorthand
(
)
{
Ok
(
shorthand
)
=
>
return
self
.
shorthand_to_css
(
shorthand
dest
)
Err
(
longhand_or_custom
)
=
>
longhand_or_custom
}
;
if
let
Some
(
(
value
_importance
)
)
=
self
.
get
(
longhand_or_custom
)
{
value
.
to_css
(
dest
)
}
else
{
Ok
(
(
)
)
}
}
pub
fn
property_priority
(
&
self
property
:
&
PropertyId
)
-
>
Importance
{
match
property
.
as_shorthand
(
)
{
Ok
(
shorthand
)
=
>
{
if
shorthand
.
longhands
(
)
.
all
(
|
l
|
{
self
.
get
(
PropertyDeclarationId
:
:
Longhand
(
l
)
)
.
map_or
(
false
|
(
_
importance
)
|
importance
.
important
(
)
)
}
)
{
Importance
:
:
Important
}
else
{
Importance
:
:
Normal
}
}
Err
(
longhand_or_custom
)
=
>
{
self
.
get
(
longhand_or_custom
)
.
map_or
(
Importance
:
:
Normal
|
(
_
importance
)
|
importance
)
}
}
}
pub
fn
property_value_to_typed
(
&
self
property
:
&
PropertyId
)
-
>
PropertyTypedValue
{
match
property
.
as_shorthand
(
)
{
Ok
(
shorthand
)
=
>
{
if
shorthand
.
longhands
(
)
.
all
(
|
longhand
|
self
.
contains
(
PropertyDeclarationId
:
:
Longhand
(
longhand
)
)
)
{
PropertyTypedValue
:
:
Unsupported
}
else
{
PropertyTypedValue
:
:
None
}
}
Err
(
longhand_or_custom
)
=
>
match
self
.
get
(
longhand_or_custom
)
{
Some
(
(
value
_importance
)
)
=
>
{
if
let
Some
(
typed_value
)
=
value
.
to_typed
(
)
{
PropertyTypedValue
:
:
Typed
(
typed_value
)
}
else
{
PropertyTypedValue
:
:
Unsupported
}
}
None
=
>
PropertyTypedValue
:
:
None
}
}
}
pub
fn
extend
(
&
mut
self
mut
drain
:
SourcePropertyDeclarationDrain
importance
:
Importance
)
-
>
bool
{
let
all_shorthand_len
=
match
drain
.
all_shorthand
{
AllShorthand
:
:
NotSet
=
>
0
AllShorthand
:
:
CSSWideKeyword
(
_
)
|
AllShorthand
:
:
WithVariables
(
_
)
=
>
{
property_counts
:
:
ALL_SHORTHAND_EXPANDED
}
}
;
let
push_calls_count
=
drain
.
declarations
.
len
(
)
+
all_shorthand_len
;
self
.
declarations
.
reserve
(
push_calls_count
)
;
let
mut
changed
=
false
;
for
decl
in
&
mut
drain
.
declarations
{
changed
|
=
self
.
push
(
decl
importance
)
;
}
drain
.
all_shorthand
.
declarations
(
)
.
fold
(
changed
|
changed
decl
|
{
changed
|
self
.
push
(
decl
importance
)
}
)
}
pub
fn
push
(
&
mut
self
declaration
:
PropertyDeclaration
importance
:
Importance
)
-
>
bool
{
let
id
=
declaration
.
id
(
)
;
if
!
self
.
property_ids
.
insert
(
id
)
{
let
mut
index_to_remove
=
None
;
for
(
i
slot
)
in
self
.
declarations
.
iter_mut
(
)
.
enumerate
(
)
{
if
slot
.
id
(
)
!
=
id
{
continue
;
}
let
important
=
self
.
declarations_importance
[
i
]
;
if
important
&
&
!
importance
.
important
(
)
{
return
false
;
}
index_to_remove
=
Some
(
i
)
;
break
;
}
if
let
Some
(
index
)
=
index_to_remove
{
self
.
declarations
.
remove
(
index
)
;
self
.
declarations_importance
.
remove
(
index
)
;
self
.
declarations
.
push
(
declaration
)
;
self
.
declarations_importance
.
push
(
importance
.
important
(
)
)
;
return
true
;
}
}
self
.
declarations
.
push
(
declaration
)
;
self
.
declarations_importance
.
push
(
importance
.
important
(
)
)
;
true
}
pub
fn
prepare_for_update
(
&
self
source_declarations
:
&
SourcePropertyDeclaration
importance
:
Importance
updates
:
&
mut
SourcePropertyDeclarationUpdate
)
-
>
bool
{
debug_assert
!
(
updates
.
updates
.
is_empty
(
)
)
;
if
!
matches
!
(
source_declarations
.
all_shorthand
AllShorthand
:
:
NotSet
)
{
debug_assert
!
(
source_declarations
.
declarations
.
is_empty
(
)
)
;
return
source_declarations
.
all_shorthand
.
declarations
(
)
.
any
(
|
decl
|
{
!
self
.
contains
(
decl
.
id
(
)
)
|
|
self
.
declarations
.
iter
(
)
.
enumerate
(
)
.
find
(
|
&
(
_
ref
d
)
|
d
.
id
(
)
=
=
decl
.
id
(
)
)
.
map_or
(
true
|
(
i
d
)
|
{
let
important
=
self
.
declarations_importance
[
i
]
;
*
d
!
=
decl
|
|
important
!
=
importance
.
important
(
)
}
)
}
)
;
}
let
mut
any_update
=
false
;
let
new_count
=
&
mut
updates
.
new_count
;
let
any_removal
=
&
mut
updates
.
any_removal
;
let
updates
=
&
mut
updates
.
updates
;
updates
.
extend
(
source_declarations
.
declarations
.
iter
(
)
.
map
(
|
declaration
|
{
if
!
self
.
contains
(
declaration
.
id
(
)
)
{
return
DeclarationUpdate
:
:
Append
;
}
let
longhand_id
=
declaration
.
id
(
)
.
as_longhand
(
)
;
if
let
Some
(
longhand_id
)
=
longhand_id
{
if
let
Some
(
logical_group
)
=
longhand_id
.
logical_group
(
)
{
let
mut
needs_append
=
false
;
for
(
pos
decl
)
in
self
.
declarations
.
iter
(
)
.
enumerate
(
)
.
rev
(
)
{
let
id
=
match
decl
.
id
(
)
.
as_longhand
(
)
{
Some
(
id
)
=
>
id
None
=
>
continue
}
;
if
id
=
=
longhand_id
{
if
needs_append
{
return
DeclarationUpdate
:
:
AppendAndRemove
{
pos
}
;
}
let
important
=
self
.
declarations_importance
[
pos
]
;
if
decl
=
=
declaration
&
&
important
=
=
importance
.
important
(
)
{
return
DeclarationUpdate
:
:
None
;
}
return
DeclarationUpdate
:
:
UpdateInPlace
{
pos
}
;
}
if
!
needs_append
&
&
id
.
logical_group
(
)
=
=
Some
(
logical_group
)
&
&
id
.
is_logical
(
)
!
=
longhand_id
.
is_logical
(
)
{
needs_append
=
true
;
}
}
unreachable
!
(
"
Longhand
should
be
found
in
loop
above
"
)
;
}
}
self
.
declarations
.
iter
(
)
.
enumerate
(
)
.
find
(
|
&
(
_
ref
decl
)
|
decl
.
id
(
)
=
=
declaration
.
id
(
)
)
.
map_or
(
DeclarationUpdate
:
:
Append
|
(
pos
decl
)
|
{
let
important
=
self
.
declarations_importance
[
pos
]
;
if
decl
=
=
declaration
&
&
important
=
=
importance
.
important
(
)
{
DeclarationUpdate
:
:
None
}
else
{
DeclarationUpdate
:
:
UpdateInPlace
{
pos
}
}
}
)
}
)
.
inspect
(
|
update
|
{
if
matches
!
(
update
DeclarationUpdate
:
:
None
)
{
return
;
}
any_update
=
true
;
match
update
{
DeclarationUpdate
:
:
Append
=
>
{
*
new_count
+
=
1
;
}
DeclarationUpdate
:
:
AppendAndRemove
{
.
.
}
=
>
{
*
any_removal
=
true
;
}
_
=
>
{
}
}
}
)
)
;
any_update
}
pub
fn
update
(
&
mut
self
drain
:
SourcePropertyDeclarationDrain
importance
:
Importance
updates
:
&
mut
SourcePropertyDeclarationUpdate
)
{
let
important
=
importance
.
important
(
)
;
if
!
matches
!
(
drain
.
all_shorthand
AllShorthand
:
:
NotSet
)
{
debug_assert
!
(
updates
.
updates
.
is_empty
(
)
)
;
for
decl
in
drain
.
all_shorthand
.
declarations
(
)
{
let
id
=
decl
.
id
(
)
;
if
self
.
property_ids
.
insert
(
id
)
{
self
.
declarations
.
push
(
decl
)
;
self
.
declarations_importance
.
push
(
important
)
;
}
else
{
let
(
idx
slot
)
=
self
.
declarations
.
iter_mut
(
)
.
enumerate
(
)
.
find
(
|
&
(
_
ref
d
)
|
d
.
id
(
)
=
=
decl
.
id
(
)
)
.
unwrap
(
)
;
*
slot
=
decl
;
self
.
declarations_importance
.
set
(
idx
important
)
;
}
}
return
;
}
self
.
declarations
.
reserve
(
updates
.
new_count
)
;
if
updates
.
any_removal
{
struct
UpdateOrRemoval
<
'
a
>
{
item
:
&
'
a
mut
DeclarationUpdate
pos
:
usize
remove
:
bool
}
let
mut
updates_and_removals
:
SubpropertiesVec
<
UpdateOrRemoval
>
=
updates
.
updates
.
iter_mut
(
)
.
filter_map
(
|
item
|
{
let
(
pos
remove
)
=
match
*
item
{
DeclarationUpdate
:
:
UpdateInPlace
{
pos
}
=
>
(
pos
false
)
DeclarationUpdate
:
:
AppendAndRemove
{
pos
}
=
>
(
pos
true
)
_
=
>
return
None
}
;
Some
(
UpdateOrRemoval
{
item
pos
remove
}
)
}
)
.
collect
(
)
;
updates_and_removals
.
sort_unstable_by_key
(
|
update
|
update
.
pos
)
;
updates_and_removals
.
iter
(
)
.
rev
(
)
.
filter
(
|
update
|
update
.
remove
)
.
for_each
(
|
update
|
{
self
.
declarations
.
remove
(
update
.
pos
)
;
self
.
declarations_importance
.
remove
(
update
.
pos
)
;
}
)
;
let
mut
removed_count
=
0
;
for
update
in
updates_and_removals
.
iter_mut
(
)
{
if
update
.
remove
{
removed_count
+
=
1
;
continue
;
}
debug_assert_eq
!
(
*
update
.
item
DeclarationUpdate
:
:
UpdateInPlace
{
pos
:
update
.
pos
}
)
;
*
update
.
item
=
DeclarationUpdate
:
:
UpdateInPlace
{
pos
:
update
.
pos
-
removed_count
}
;
}
}
for
(
decl
update
)
in
drain
.
declarations
.
zip_eq
(
updates
.
updates
.
iter
(
)
)
{
match
*
update
{
DeclarationUpdate
:
:
None
=
>
{
}
DeclarationUpdate
:
:
Append
|
DeclarationUpdate
:
:
AppendAndRemove
{
.
.
}
=
>
{
self
.
property_ids
.
insert
(
decl
.
id
(
)
)
;
self
.
declarations
.
push
(
decl
)
;
self
.
declarations_importance
.
push
(
important
)
;
}
DeclarationUpdate
:
:
UpdateInPlace
{
pos
}
=
>
{
self
.
declarations
[
pos
]
=
decl
;
self
.
declarations_importance
.
set
(
pos
important
)
;
}
}
}
updates
.
updates
.
clear
(
)
;
}
#
[
inline
]
pub
fn
first_declaration_to_remove
(
&
self
property
:
&
PropertyId
)
-
>
Option
<
usize
>
{
if
let
Err
(
longhand_or_custom
)
=
property
.
as_shorthand
(
)
{
if
!
self
.
contains
(
longhand_or_custom
)
{
return
None
;
}
}
self
.
declarations
.
iter
(
)
.
position
(
|
declaration
|
declaration
.
id
(
)
.
is_or_is_longhand_of
(
property
)
)
}
#
[
inline
]
fn
remove_declaration_at
(
&
mut
self
i
:
usize
)
{
self
.
property_ids
.
remove
(
self
.
declarations
[
i
]
.
id
(
)
)
;
self
.
declarations_importance
.
remove
(
i
)
;
self
.
declarations
.
remove
(
i
)
;
}
#
[
inline
]
pub
fn
clear
(
&
mut
self
)
{
self
.
declarations_importance
.
clear
(
)
;
self
.
declarations
.
clear
(
)
;
self
.
property_ids
.
clear
(
)
;
}
#
[
inline
]
pub
fn
remove_property
(
&
mut
self
property
:
&
PropertyId
first_declaration
:
usize
)
{
debug_assert_eq
!
(
Some
(
first_declaration
)
self
.
first_declaration_to_remove
(
property
)
)
;
debug_assert
!
(
self
.
declarations
[
first_declaration
]
.
id
(
)
.
is_or_is_longhand_of
(
property
)
)
;
self
.
remove_declaration_at
(
first_declaration
)
;
let
shorthand
=
match
property
.
as_shorthand
(
)
{
Ok
(
s
)
=
>
s
Err
(
_longhand_or_custom
)
=
>
return
}
;
let
mut
i
=
first_declaration
;
let
mut
len
=
self
.
len
(
)
;
while
i
<
len
{
if
!
self
.
declarations
[
i
]
.
id
(
)
.
is_longhand_of
(
shorthand
)
{
i
+
=
1
;
continue
;
}
self
.
remove_declaration_at
(
i
)
;
len
-
=
1
;
}
}
pub
fn
single_value_to_css
(
&
self
property
:
&
PropertyId
dest
:
&
mut
CssStringWriter
computed_values
:
Option
<
&
ComputedValues
>
stylist
:
&
Stylist
)
-
>
fmt
:
:
Result
{
if
let
Ok
(
shorthand
)
=
property
.
as_shorthand
(
)
{
return
self
.
shorthand_to_css
(
shorthand
dest
)
;
}
let
declaration
=
match
self
.
declarations
.
get
(
0
)
{
Some
(
d
)
=
>
d
None
=
>
return
Err
(
fmt
:
:
Error
)
}
;
let
mut
rule_cache_conditions
=
RuleCacheConditions
:
:
default
(
)
;
let
mut
context
=
Context
:
:
new
(
StyleBuilder
:
:
new
(
stylist
.
device
(
)
Some
(
stylist
)
computed_values
None
None
false
)
stylist
.
quirks_mode
(
)
&
mut
rule_cache_conditions
ContainerSizeQuery
:
:
none
(
)
)
;
if
let
Some
(
cv
)
=
computed_values
{
context
.
builder
.
custom_properties
=
cv
.
custom_properties
(
)
.
clone
(
)
;
}
;
match
(
declaration
computed_values
)
{
(
&
PropertyDeclaration
:
:
WithVariables
(
ref
declaration
)
Some
(
_
)
)
=
>
declaration
.
value
.
substitute_variables
(
declaration
.
id
&
context
.
builder
.
custom_properties
stylist
&
context
&
mut
Default
:
:
default
(
)
)
.
to_css
(
dest
)
(
ref
d
_
)
=
>
d
.
to_css
(
dest
)
}
}
pub
fn
from_animation_value_map
(
animation_value_map
:
&
AnimationValueMap
)
-
>
Self
{
let
len
=
animation_value_map
.
len
(
)
;
let
mut
declarations
=
ThinVec
:
:
with_capacity
(
len
)
;
let
mut
property_ids
=
PropertyDeclarationIdSet
:
:
default
(
)
;
for
(
property
animation_value
)
in
animation_value_map
.
iter
(
)
{
property_ids
.
insert
(
property
.
as_borrowed
(
)
)
;
declarations
.
push
(
animation_value
.
uncompute
(
)
)
;
}
PropertyDeclarationBlock
{
declarations
property_ids
declarations_importance
:
SmallBitVec
:
:
from_elem
(
len
false
)
}
}
pub
fn
has_css_wide_keyword
(
&
self
property
:
&
PropertyId
)
-
>
bool
{
if
let
Err
(
longhand_or_custom
)
=
property
.
as_shorthand
(
)
{
if
!
self
.
property_ids
.
contains
(
longhand_or_custom
)
{
return
false
;
}
}
self
.
declarations
.
iter
(
)
.
any
(
|
decl
|
{
decl
.
id
(
)
.
is_or_is_longhand_of
(
property
)
&
&
decl
.
get_css_wide_keyword
(
)
.
is_some
(
)
}
)
}
pub
fn
to_css
(
&
self
dest
:
&
mut
CssStringWriter
)
-
>
fmt
:
:
Result
{
let
mut
is_first_serialization
=
true
;
let
mut
already_serialized
=
NonCustomPropertyIdSet
:
:
new
(
)
;
'
declaration_loop
:
for
(
declaration
importance
)
in
self
.
declaration_importance_iter
(
)
{
let
property
=
declaration
.
id
(
)
;
let
longhand_id
=
match
property
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
id
PropertyDeclarationId
:
:
Custom
(
.
.
)
=
>
{
append_serialization
(
dest
&
property
AppendableValue
:
:
Declaration
(
declaration
)
importance
&
mut
is_first_serialization
)
?
;
continue
;
}
}
;
if
already_serialized
.
contains
(
longhand_id
.
into
(
)
)
{
continue
;
}
for
shorthand
in
longhand_id
.
shorthands
(
)
{
if
already_serialized
.
contains
(
shorthand
.
into
(
)
)
{
continue
;
}
already_serialized
.
insert
(
shorthand
.
into
(
)
)
;
if
shorthand
.
is_legacy_shorthand
(
)
{
continue
;
}
let
longhands
=
{
let
mut
ids
=
LonghandIdSet
:
:
new
(
)
;
for
longhand
in
shorthand
.
longhands
(
)
{
ids
.
insert
(
longhand
)
;
}
ids
}
;
if
!
self
.
property_ids
.
contains_all_longhands
(
&
longhands
)
{
continue
;
}
let
mut
current_longhands
=
SmallVec
:
:
<
[
&
_
;
10
]
>
:
:
new
(
)
;
let
mut
logical_groups
=
LogicalGroupSet
:
:
new
(
)
;
let
mut
saw_one
=
false
;
let
mut
logical_mismatch
=
false
;
let
mut
seen
=
LonghandIdSet
:
:
new
(
)
;
let
mut
important_count
=
0
;
for
(
declaration
importance
)
in
self
.
declaration_importance_iter
(
)
{
let
longhand
=
match
declaration
.
id
(
)
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
id
PropertyDeclarationId
:
:
Custom
(
.
.
)
=
>
continue
}
;
if
longhands
.
contains
(
longhand
)
{
saw_one
=
true
;
if
importance
.
important
(
)
{
important_count
+
=
1
;
}
current_longhands
.
push
(
declaration
)
;
if
shorthand
!
=
ShorthandId
:
:
All
{
if
let
Some
(
g
)
=
longhand
.
logical_group
(
)
{
logical_groups
.
insert
(
g
)
;
}
seen
.
insert
(
longhand
)
;
if
seen
=
=
longhands
{
break
;
}
}
}
else
if
saw_one
{
if
let
Some
(
g
)
=
longhand
.
logical_group
(
)
{
if
logical_groups
.
contains
(
g
)
{
logical_mismatch
=
true
;
break
;
}
}
}
}
let
is_important
=
important_count
>
0
;
if
is_important
&
&
important_count
!
=
current_longhands
.
len
(
)
{
continue
;
}
if
logical_mismatch
{
continue
;
}
let
importance
=
if
is_important
{
Importance
:
:
Important
}
else
{
Importance
:
:
Normal
}
;
let
appendable_value
=
match
shorthand
.
get_shorthand_appendable_value
(
&
current_longhands
)
{
None
=
>
continue
Some
(
appendable_value
)
=
>
appendable_value
}
;
let
mut
v
=
CssString
:
:
new
(
)
;
let
value
=
match
appendable_value
{
AppendableValue
:
:
Css
(
css
)
=
>
{
debug_assert
!
(
!
css
.
is_empty
(
)
)
;
appendable_value
}
other
=
>
{
append_declaration_value
(
&
mut
v
other
)
?
;
if
v
.
is_empty
(
)
{
continue
;
}
AppendableValue
:
:
Css
(
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
unsafe
{
v
.
as_str_unchecked
(
)
}
#
[
cfg
(
feature
=
"
servo
"
)
]
&
v
}
)
}
}
;
append_serialization
(
dest
&
shorthand
value
importance
&
mut
is_first_serialization
)
?
;
for
current_longhand
in
&
current_longhands
{
let
longhand_id
=
match
current_longhand
.
id
(
)
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
id
PropertyDeclarationId
:
:
Custom
(
.
.
)
=
>
unreachable
!
(
)
}
;
already_serialized
.
insert
(
longhand_id
.
into
(
)
)
;
}
continue
'
declaration_loop
;
}
append_serialization
(
dest
&
property
AppendableValue
:
:
Declaration
(
declaration
)
importance
&
mut
is_first_serialization
)
?
;
already_serialized
.
insert
(
longhand_id
.
into
(
)
)
;
}
Ok
(
(
)
)
}
}
pub
enum
AppendableValue
<
'
a
'
b
:
'
a
>
{
Declaration
(
&
'
a
PropertyDeclaration
)
DeclarationsForShorthand
(
ShorthandId
&
'
a
[
&
'
b
PropertyDeclaration
]
)
Css
(
&
'
a
str
)
}
fn
handle_first_serialization
<
W
>
(
dest
:
&
mut
W
is_first_serialization
:
&
mut
bool
)
-
>
fmt
:
:
Result
where
W
:
Write
{
if
!
*
is_first_serialization
{
dest
.
write_char
(
'
'
)
}
else
{
*
is_first_serialization
=
false
;
Ok
(
(
)
)
}
}
pub
fn
append_declaration_value
<
'
a
'
b
:
'
a
>
(
dest
:
&
mut
CssStringWriter
appendable_value
:
AppendableValue
<
'
a
'
b
>
)
-
>
fmt
:
:
Result
{
match
appendable_value
{
AppendableValue
:
:
Css
(
css
)
=
>
dest
.
write_str
(
css
)
AppendableValue
:
:
Declaration
(
decl
)
=
>
decl
.
to_css
(
dest
)
AppendableValue
:
:
DeclarationsForShorthand
(
shorthand
decls
)
=
>
{
shorthand
.
longhands_to_css
(
decls
dest
)
}
}
}
pub
fn
append_serialization
<
'
a
'
b
:
'
a
N
>
(
dest
:
&
mut
CssStringWriter
property_name
:
&
N
appendable_value
:
AppendableValue
<
'
a
'
b
>
importance
:
Importance
is_first_serialization
:
&
mut
bool
)
-
>
fmt
:
:
Result
where
N
:
ToCss
{
handle_first_serialization
(
dest
is_first_serialization
)
?
;
property_name
.
to_css
(
&
mut
CssWriter
:
:
new
(
dest
)
)
?
;
dest
.
write_str
(
"
:
"
)
?
;
append_declaration_value
(
dest
appendable_value
)
?
;
if
importance
.
important
(
)
{
dest
.
write_str
(
"
!
important
"
)
?
;
}
dest
.
write_char
(
'
;
'
)
}
#
[
inline
]
pub
fn
parse_style_attribute
(
input
:
&
str
url_data
:
&
UrlExtraData
error_reporter
:
Option
<
&
dyn
ParseErrorReporter
>
quirks_mode
:
QuirksMode
rule_type
:
CssRuleType
)
-
>
PropertyDeclarationBlock
{
let
context
=
ParserContext
:
:
new
(
Origin
:
:
Author
url_data
Some
(
rule_type
)
ParsingMode
:
:
DEFAULT
quirks_mode
Default
:
:
default
(
)
error_reporter
None
)
;
let
mut
input
=
ParserInput
:
:
new
(
input
)
;
parse_property_declaration_list
(
&
context
&
mut
Parser
:
:
new
(
&
mut
input
)
&
[
]
)
}
#
[
inline
]
pub
fn
parse_one_declaration_into
(
declarations
:
&
mut
SourcePropertyDeclaration
id
:
PropertyId
input
:
&
str
origin
:
Origin
url_data
:
&
UrlExtraData
error_reporter
:
Option
<
&
dyn
ParseErrorReporter
>
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
rule_type
:
CssRuleType
)
-
>
Result
<
(
)
(
)
>
{
let
context
=
ParserContext
:
:
new
(
origin
url_data
Some
(
rule_type
)
parsing_mode
quirks_mode
Default
:
:
default
(
)
error_reporter
None
)
;
let
property_id_for_error_reporting
=
if
context
.
error_reporting_enabled
(
)
{
Some
(
id
.
clone
(
)
)
}
else
{
None
}
;
let
mut
input
=
ParserInput
:
:
new
(
input
)
;
let
mut
parser
=
Parser
:
:
new
(
&
mut
input
)
;
let
start_position
=
parser
.
position
(
)
;
parser
.
parse_entirely
(
|
parser
|
{
PropertyDeclaration
:
:
parse_into
(
declarations
id
&
context
parser
)
}
)
.
map_err
(
|
err
|
{
if
context
.
error_reporting_enabled
(
)
{
report_one_css_error
(
&
context
None
&
[
]
err
parser
.
slice_from
(
start_position
)
property_id_for_error_reporting
)
}
}
)
}
struct
PropertyDeclarationParser
<
'
a
'
b
:
'
a
'
i
>
{
context
:
&
'
a
ParserContext
<
'
b
>
state
:
&
'
a
mut
DeclarationParserState
<
'
i
>
}
#
[
derive
(
Default
)
]
pub
struct
DeclarationParserState
<
'
i
>
{
output_block
:
PropertyDeclarationBlock
declarations
:
SourcePropertyDeclaration
importance
:
Importance
errors
:
SmallParseErrorVec
<
'
i
>
first_declaration_start
:
SourceLocation
last_parsed_property_id
:
Option
<
PropertyId
>
}
impl
<
'
i
>
DeclarationParserState
<
'
i
>
{
pub
fn
first_declaration_start
(
&
self
)
-
>
SourceLocation
{
self
.
first_declaration_start
}
pub
fn
has_parsed_declarations
(
&
self
)
-
>
bool
{
!
self
.
output_block
.
is_empty
(
)
}
pub
fn
take_declarations
(
&
mut
self
)
-
>
PropertyDeclarationBlock
{
std
:
:
mem
:
:
take
(
&
mut
self
.
output_block
)
}
pub
fn
parse_value
<
'
t
>
(
&
mut
self
context
:
&
ParserContext
name
:
CowRcStr
<
'
i
>
input
:
&
mut
Parser
<
'
i
'
t
>
declaration_start
:
&
ParserState
)
-
>
Result
<
(
)
ParseError
<
'
i
>
>
{
let
id
=
match
PropertyId
:
:
parse
(
&
name
context
)
{
Ok
(
id
)
=
>
id
Err
(
.
.
)
=
>
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnknownProperty
(
name
)
)
)
;
}
}
;
if
context
.
error_reporting_enabled
(
)
{
self
.
last_parsed_property_id
=
Some
(
id
.
clone
(
)
)
;
}
input
.
parse_until_before
(
Delimiter
:
:
Bang
|
input
|
{
PropertyDeclaration
:
:
parse_into
(
&
mut
self
.
declarations
id
context
input
)
}
)
?
;
self
.
importance
=
match
input
.
try_parse
(
parse_important
)
{
Ok
(
(
)
)
=
>
{
if
!
context
.
allows_important_declarations
(
)
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnexpectedImportantDeclaration
)
)
;
}
Importance
:
:
Important
}
Err
(
_
)
=
>
Importance
:
:
Normal
}
;
input
.
expect_exhausted
(
)
?
;
let
has_parsed_declarations
=
self
.
has_parsed_declarations
(
)
;
self
.
output_block
.
extend
(
self
.
declarations
.
drain
(
)
self
.
importance
)
;
self
.
last_parsed_property_id
=
None
;
if
!
has_parsed_declarations
{
self
.
first_declaration_start
=
declaration_start
.
source_location
(
)
;
}
Ok
(
(
)
)
}
#
[
inline
]
pub
fn
report_errors_if_needed
(
&
mut
self
context
:
&
ParserContext
selectors
:
&
[
SelectorList
<
SelectorImpl
>
]
)
{
if
self
.
errors
.
is_empty
(
)
{
return
;
}
self
.
do_report_css_errors
(
context
selectors
)
;
}
#
[
cold
]
fn
do_report_css_errors
(
&
mut
self
context
:
&
ParserContext
selectors
:
&
[
SelectorList
<
SelectorImpl
>
]
)
{
for
(
error
slice
property
)
in
self
.
errors
.
drain
(
.
.
)
{
report_one_css_error
(
context
Some
(
&
self
.
output_block
)
selectors
error
slice
property
)
}
}
#
[
inline
]
pub
fn
did_error
(
&
mut
self
context
:
&
ParserContext
error
:
ParseError
<
'
i
>
slice
:
&
'
i
str
)
{
self
.
declarations
.
clear
(
)
;
if
!
context
.
error_reporting_enabled
(
)
{
return
;
}
let
property
=
self
.
last_parsed_property_id
.
take
(
)
;
self
.
errors
.
push
(
(
error
slice
property
)
)
;
}
}
impl
<
'
a
'
b
'
i
>
AtRuleParser
<
'
i
>
for
PropertyDeclarationParser
<
'
a
'
b
'
i
>
{
type
Prelude
=
(
)
;
type
AtRule
=
(
)
;
type
Error
=
StyleParseErrorKind
<
'
i
>
;
}
impl
<
'
a
'
b
'
i
>
QualifiedRuleParser
<
'
i
>
for
PropertyDeclarationParser
<
'
a
'
b
'
i
>
{
type
Prelude
=
(
)
;
type
QualifiedRule
=
(
)
;
type
Error
=
StyleParseErrorKind
<
'
i
>
;
}
fn
is_non_mozilla_vendor_identifier
(
name
:
&
str
)
-
>
bool
{
(
name
.
starts_with
(
"
-
"
)
&
&
!
name
.
starts_with
(
"
-
moz
-
"
)
)
|
|
name
.
starts_with
(
"
_
"
)
}
impl
<
'
a
'
b
'
i
>
DeclarationParser
<
'
i
>
for
PropertyDeclarationParser
<
'
a
'
b
'
i
>
{
type
Declaration
=
(
)
;
type
Error
=
StyleParseErrorKind
<
'
i
>
;
fn
parse_value
<
'
t
>
(
&
mut
self
name
:
CowRcStr
<
'
i
>
input
:
&
mut
Parser
<
'
i
'
t
>
declaration_start
:
&
ParserState
)
-
>
Result
<
(
)
ParseError
<
'
i
>
>
{
self
.
state
.
parse_value
(
self
.
context
name
input
declaration_start
)
}
}
impl
<
'
a
'
b
'
i
>
RuleBodyItemParser
<
'
i
(
)
StyleParseErrorKind
<
'
i
>
>
for
PropertyDeclarationParser
<
'
a
'
b
'
i
>
{
fn
parse_declarations
(
&
self
)
-
>
bool
{
true
}
fn
parse_qualified
(
&
self
)
-
>
bool
{
false
}
}
type
SmallParseErrorVec
<
'
i
>
=
SmallVec
<
[
(
ParseError
<
'
i
>
&
'
i
str
Option
<
PropertyId
>
)
;
2
]
>
;
fn
alias_of_known_property
(
name
:
&
str
)
-
>
Option
<
PropertyId
>
{
let
mut
prefixed
=
String
:
:
with_capacity
(
name
.
len
(
)
+
5
)
;
prefixed
.
push_str
(
"
-
moz
-
"
)
;
prefixed
.
push_str
(
name
)
;
PropertyId
:
:
parse_enabled_for_all_content
(
&
prefixed
)
.
ok
(
)
}
#
[
cold
]
fn
report_one_css_error
<
'
i
>
(
context
:
&
ParserContext
block
:
Option
<
&
PropertyDeclarationBlock
>
selectors
:
&
[
SelectorList
<
SelectorImpl
>
]
mut
error
:
ParseError
<
'
i
>
slice
:
&
str
property
:
Option
<
PropertyId
>
)
{
debug_assert
!
(
context
.
error_reporting_enabled
(
)
)
;
fn
all_properties_in_block
(
block
:
&
PropertyDeclarationBlock
property
:
&
PropertyId
)
-
>
bool
{
match
property
.
as_shorthand
(
)
{
Ok
(
id
)
=
>
id
.
longhands
(
)
.
all
(
|
longhand
|
block
.
contains
(
PropertyDeclarationId
:
:
Longhand
(
longhand
)
)
)
Err
(
longhand_or_custom
)
=
>
block
.
contains
(
longhand_or_custom
)
}
}
if
let
ParseErrorKind
:
:
Custom
(
StyleParseErrorKind
:
:
UnknownProperty
(
ref
name
)
)
=
error
.
kind
{
if
is_non_mozilla_vendor_identifier
(
name
)
{
return
;
}
if
let
Some
(
alias
)
=
alias_of_known_property
(
name
)
{
if
let
Some
(
block
)
=
block
{
if
all_properties_in_block
(
block
&
alias
)
{
return
;
}
}
}
}
if
let
Some
(
ref
property
)
=
property
{
if
let
Some
(
block
)
=
block
{
if
all_properties_in_block
(
block
property
)
{
return
;
}
}
if
!
matches
!
(
error
.
kind
ParseErrorKind
:
:
Custom
(
StyleParseErrorKind
:
:
UnexpectedImportantDeclaration
)
)
{
error
=
match
*
property
{
PropertyId
:
:
Custom
(
ref
c
)
=
>
{
StyleParseErrorKind
:
:
new_invalid
(
format
!
(
"
-
-
{
}
"
c
)
error
)
}
_
=
>
StyleParseErrorKind
:
:
new_invalid
(
property
.
non_custom_id
(
)
.
unwrap
(
)
.
name
(
)
error
)
}
;
}
}
let
location
=
error
.
location
;
let
error
=
ContextualParseError
:
:
UnsupportedPropertyDeclaration
(
slice
error
selectors
)
;
context
.
log_css_error
(
location
error
)
;
}
pub
fn
parse_property_declaration_list
(
context
:
&
ParserContext
input
:
&
mut
Parser
selectors
:
&
[
SelectorList
<
SelectorImpl
>
]
)
-
>
PropertyDeclarationBlock
{
let
mut
state
=
DeclarationParserState
:
:
default
(
)
;
let
mut
parser
=
PropertyDeclarationParser
{
context
state
:
&
mut
state
}
;
let
mut
iter
=
RuleBodyParser
:
:
new
(
input
&
mut
parser
)
;
while
let
Some
(
declaration
)
=
iter
.
next
(
)
{
match
declaration
{
Ok
(
(
)
)
=
>
{
}
Err
(
(
error
slice
)
)
=
>
iter
.
parser
.
state
.
did_error
(
context
error
slice
)
}
}
parser
.
state
.
report_errors_if_needed
(
context
selectors
)
;
state
.
output_block
}
