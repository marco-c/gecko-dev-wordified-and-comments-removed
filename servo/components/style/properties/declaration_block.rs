#
!
[
deny
(
missing_docs
)
]
use
context
:
:
QuirksMode
;
use
cssparser
:
:
{
DeclarationListParser
parse_important
}
;
use
cssparser
:
:
{
Parser
AtRuleParser
DeclarationParser
Delimiter
}
;
use
error_reporting
:
:
ParseErrorReporter
;
use
parser
:
:
{
PARSING_MODE_DEFAULT
ParsingMode
ParserContext
log_css_error
}
;
use
shared_lock
:
:
Locked
;
use
std
:
:
fmt
;
use
std
:
:
slice
:
:
Iter
;
use
style_traits
:
:
ToCss
;
use
stylesheets
:
:
{
CssRuleType
Origin
UrlExtraData
}
;
use
stylesheets
:
:
{
MallocSizeOf
MallocSizeOfFn
}
;
use
super
:
:
*
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
properties
:
:
animated_properties
:
:
AnimationValueMap
;
pub
struct
AnimationRules
<
'
a
>
(
pub
Option
<
&
'
a
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
pub
Option
<
&
'
a
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
)
;
impl
<
'
a
>
AnimationRules
<
'
a
>
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_none
(
)
&
&
self
.
1
.
is_none
(
)
}
}
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
Importance
{
Normal
Important
}
impl
MallocSizeOf
for
Importance
{
fn
malloc_size_of_children
(
&
self
_malloc_size_of
:
MallocSizeOfFn
)
-
>
usize
{
0
}
}
impl
Importance
{
pub
fn
important
(
self
)
-
>
bool
{
match
self
{
Importance
:
:
Normal
=
>
false
Importance
:
:
Important
=
>
true
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
PropertyDeclarationBlock
{
declarations
:
Vec
<
(
PropertyDeclaration
Importance
)
>
important_count
:
usize
longhands
:
LonghandIdSet
}
impl
MallocSizeOf
for
PropertyDeclarationBlock
{
fn
malloc_size_of_children
(
&
self
malloc_size_of
:
MallocSizeOfFn
)
-
>
usize
{
self
.
declarations
.
malloc_size_of_children
(
malloc_size_of
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
PropertyDeclarationIterator
<
'
a
>
{
iter
:
Iter
<
'
a
(
PropertyDeclaration
Importance
)
>
}
impl
<
'
a
>
Iterator
for
PropertyDeclarationIterator
<
'
a
>
{
type
Item
=
&
'
a
PropertyDeclaration
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
PropertyDeclaration
>
{
fn
get_declaration
(
dec
:
&
(
PropertyDeclaration
Importance
)
)
-
>
&
PropertyDeclaration
{
&
dec
.
0
}
self
.
iter
.
next
(
)
.
map
(
get_declaration
as
fn
(
_
)
-
>
_
)
}
}
impl
fmt
:
:
Debug
for
PropertyDeclarationBlock
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
declarations
.
fmt
(
f
)
}
}
impl
PropertyDeclarationBlock
{
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
declarations
.
len
(
)
}
pub
fn
new
(
)
-
>
Self
{
PropertyDeclarationBlock
{
declarations
:
Vec
:
:
new
(
)
important_count
:
0
longhands
:
LonghandIdSet
:
:
new
(
)
}
}
pub
fn
with_one
(
declaration
:
PropertyDeclaration
importance
:
Importance
)
-
>
Self
{
let
mut
longhands
=
LonghandIdSet
:
:
new
(
)
;
if
let
PropertyDeclarationId
:
:
Longhand
(
id
)
=
declaration
.
id
(
)
{
longhands
.
insert
(
id
)
;
}
PropertyDeclarationBlock
{
declarations
:
vec
!
[
(
declaration
importance
)
]
important_count
:
if
importance
.
important
(
)
{
1
}
else
{
0
}
longhands
:
longhands
}
}
pub
fn
declarations
(
&
self
)
-
>
&
[
(
PropertyDeclaration
Importance
)
]
{
&
self
.
declarations
}
pub
fn
declarations_iter
(
&
self
)
-
>
PropertyDeclarationIterator
{
PropertyDeclarationIterator
{
iter
:
self
.
declarations
.
iter
(
)
}
}
pub
fn
any_important
(
&
self
)
-
>
bool
{
self
.
important_count
>
0
}
pub
fn
any_normal
(
&
self
)
-
>
bool
{
self
.
declarations
.
len
(
)
>
self
.
important_count
}
pub
fn
get
(
&
self
property
:
PropertyDeclarationId
)
-
>
Option
<
&
(
PropertyDeclaration
Importance
)
>
{
self
.
declarations
.
iter
(
)
.
find
(
|
&
&
(
ref
decl
_
)
|
decl
.
id
(
)
=
=
property
)
}
pub
fn
property_value_to_css
<
W
>
(
&
self
property
:
&
PropertyId
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
property
.
as_shorthand
(
)
{
Ok
(
shorthand
)
=
>
{
let
mut
list
=
Vec
:
:
new
(
)
;
let
mut
important_count
=
0
;
for
&
longhand
in
shorthand
.
longhands
(
)
{
let
declaration
=
self
.
get
(
PropertyDeclarationId
:
:
Longhand
(
longhand
)
)
;
match
declaration
{
Some
(
&
(
ref
declaration
importance
)
)
=
>
{
list
.
push
(
declaration
)
;
if
importance
.
important
(
)
{
important_count
+
=
1
;
}
}
None
=
>
return
Ok
(
(
)
)
}
}
if
important_count
>
0
&
&
important_count
!
=
list
.
len
(
)
{
return
Ok
(
(
)
)
;
}
match
shorthand
.
get_shorthand_appendable_value
(
list
)
{
Some
(
appendable_value
)
=
>
append_declaration_value
(
dest
appendable_value
)
None
=
>
return
Ok
(
(
)
)
}
}
Err
(
longhand_or_custom
)
=
>
{
if
let
Some
(
&
(
ref
value
_importance
)
)
=
self
.
get
(
longhand_or_custom
)
{
value
.
to_css
(
dest
)
}
else
{
Ok
(
(
)
)
}
}
}
}
pub
fn
property_priority
(
&
self
property
:
&
PropertyId
)
-
>
Importance
{
match
property
.
as_shorthand
(
)
{
Ok
(
shorthand
)
=
>
{
if
shorthand
.
longhands
(
)
.
iter
(
)
.
all
(
|
&
l
|
{
self
.
get
(
PropertyDeclarationId
:
:
Longhand
(
l
)
)
.
map_or
(
false
|
&
(
_
importance
)
|
importance
.
important
(
)
)
}
)
{
Importance
:
:
Important
}
else
{
Importance
:
:
Normal
}
}
Err
(
longhand_or_custom
)
=
>
{
self
.
get
(
longhand_or_custom
)
.
map_or
(
Importance
:
:
Normal
|
&
(
_
importance
)
|
importance
)
}
}
}
pub
fn
extend
(
&
mut
self
drain
:
SourcePropertyDeclarationDrain
importance
:
Importance
)
{
self
.
extend_common
(
drain
importance
false
)
;
}
pub
fn
extend_reset
(
&
mut
self
drain
:
SourcePropertyDeclarationDrain
importance
:
Importance
)
-
>
bool
{
self
.
extend_common
(
drain
importance
true
)
}
fn
extend_common
(
&
mut
self
mut
drain
:
SourcePropertyDeclarationDrain
importance
:
Importance
overwrite_more_important
:
bool
)
-
>
bool
{
let
all_shorthand_len
=
match
drain
.
all_shorthand
{
AllShorthand
:
:
NotSet
=
>
0
AllShorthand
:
:
CSSWideKeyword
(
_
)
|
AllShorthand
:
:
WithVariables
(
_
)
=
>
ShorthandId
:
:
All
.
longhands
(
)
.
len
(
)
}
;
let
push_calls_count
=
drain
.
declarations
.
len
(
)
+
all_shorthand_len
;
self
.
declarations
.
reserve
(
push_calls_count
)
;
let
mut
changed
=
false
;
for
decl
in
&
mut
drain
.
declarations
{
changed
|
=
self
.
push_common
(
decl
importance
overwrite_more_important
)
;
}
match
drain
.
all_shorthand
{
AllShorthand
:
:
NotSet
=
>
{
}
AllShorthand
:
:
CSSWideKeyword
(
keyword
)
=
>
{
for
&
id
in
ShorthandId
:
:
All
.
longhands
(
)
{
let
decl
=
PropertyDeclaration
:
:
CSSWideKeyword
(
id
keyword
)
;
changed
|
=
self
.
push_common
(
decl
importance
overwrite_more_important
)
;
}
}
AllShorthand
:
:
WithVariables
(
unparsed
)
=
>
{
for
&
id
in
ShorthandId
:
:
All
.
longhands
(
)
{
let
decl
=
PropertyDeclaration
:
:
WithVariables
(
id
unparsed
.
clone
(
)
)
;
changed
|
=
self
.
push_common
(
decl
importance
overwrite_more_important
)
;
}
}
}
changed
}
pub
fn
push
(
&
mut
self
declaration
:
PropertyDeclaration
importance
:
Importance
)
{
self
.
push_common
(
declaration
importance
false
)
;
}
fn
push_common
(
&
mut
self
declaration
:
PropertyDeclaration
importance
:
Importance
overwrite_more_important
:
bool
)
-
>
bool
{
let
definitely_new
=
if
let
PropertyDeclarationId
:
:
Longhand
(
id
)
=
declaration
.
id
(
)
{
!
self
.
longhands
.
contains
(
id
)
}
else
{
false
}
;
if
!
definitely_new
{
for
slot
in
&
mut
*
self
.
declarations
{
if
slot
.
0
.
id
(
)
=
=
declaration
.
id
(
)
{
match
(
slot
.
1
importance
)
{
(
Importance
:
:
Normal
Importance
:
:
Important
)
=
>
{
self
.
important_count
+
=
1
;
}
(
Importance
:
:
Important
Importance
:
:
Normal
)
=
>
{
if
overwrite_more_important
{
self
.
important_count
-
=
1
;
}
else
{
return
false
}
}
_
=
>
if
slot
.
0
=
=
declaration
{
return
false
;
}
}
*
slot
=
(
declaration
importance
)
;
return
true
}
}
}
if
let
PropertyDeclarationId
:
:
Longhand
(
id
)
=
declaration
.
id
(
)
{
self
.
longhands
.
insert
(
id
)
;
}
self
.
declarations
.
push
(
(
declaration
importance
)
)
;
if
importance
.
important
(
)
{
self
.
important_count
+
=
1
;
}
true
}
pub
fn
set_importance
(
&
mut
self
property
:
&
PropertyId
new_importance
:
Importance
)
-
>
bool
{
let
mut
updated_at_least_one
=
false
;
for
&
mut
(
ref
declaration
ref
mut
importance
)
in
&
mut
self
.
declarations
{
if
declaration
.
id
(
)
.
is_or_is_longhand_of
(
property
)
{
match
(
*
importance
new_importance
)
{
(
Importance
:
:
Normal
Importance
:
:
Important
)
=
>
{
self
.
important_count
+
=
1
;
}
(
Importance
:
:
Important
Importance
:
:
Normal
)
=
>
{
self
.
important_count
-
=
1
;
}
_
=
>
{
continue
;
}
}
updated_at_least_one
=
true
;
*
importance
=
new_importance
;
}
}
updated_at_least_one
}
pub
fn
remove_property
(
&
mut
self
property
:
&
PropertyId
)
-
>
bool
{
if
let
PropertyId
:
:
Longhand
(
id
)
=
*
property
{
if
!
self
.
longhands
.
contains
(
id
)
{
return
false
}
}
let
important_count
=
&
mut
self
.
important_count
;
let
mut
removed_at_least_one
=
false
;
let
longhands
=
&
mut
self
.
longhands
;
self
.
declarations
.
retain
(
|
&
(
ref
declaration
importance
)
|
{
let
id
=
declaration
.
id
(
)
;
let
remove
=
id
.
is_or_is_longhand_of
(
property
)
;
if
remove
{
removed_at_least_one
=
true
;
if
let
PropertyDeclarationId
:
:
Longhand
(
id
)
=
id
{
longhands
.
remove
(
id
)
}
if
importance
.
important
(
)
{
*
important_count
-
=
1
}
}
!
remove
}
)
;
if
let
PropertyId
:
:
Longhand
(
_
)
=
*
property
{
debug_assert
!
(
removed_at_least_one
)
;
}
removed_at_least_one
}
pub
fn
single_value_to_css
<
W
>
(
&
self
property
:
&
PropertyId
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
property
.
as_shorthand
(
)
{
Err
(
_longhand_or_custom
)
=
>
{
if
self
.
declarations
.
len
(
)
=
=
1
{
self
.
declarations
[
0
]
.
0
.
to_css
(
dest
)
}
else
{
Err
(
fmt
:
:
Error
)
}
}
Ok
(
shorthand
)
=
>
{
if
!
self
.
declarations
.
iter
(
)
.
all
(
|
decl
|
decl
.
0
.
shorthands
(
)
.
contains
(
&
shorthand
)
)
{
return
Err
(
fmt
:
:
Error
)
}
let
iter
=
self
.
declarations_iter
(
)
;
match
shorthand
.
get_shorthand_appendable_value
(
iter
)
{
Some
(
AppendableValue
:
:
Css
{
css
.
.
}
)
=
>
{
dest
.
write_str
(
css
)
}
Some
(
AppendableValue
:
:
DeclarationsForShorthand
(
_
decls
)
)
=
>
{
shorthand
.
longhands_to_css
(
decls
dest
)
}
_
=
>
Ok
(
(
)
)
}
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
from_animation_value_map
(
animation_value_map
:
&
AnimationValueMap
)
-
>
Self
{
let
mut
declarations
=
vec
!
[
]
;
let
mut
longhands
=
LonghandIdSet
:
:
new
(
)
;
for
(
property
animation_value
)
in
animation_value_map
.
iter
(
)
{
longhands
.
set_transition_property_bit
(
property
)
;
declarations
.
push
(
(
animation_value
.
uncompute
(
)
Importance
:
:
Normal
)
)
;
}
PropertyDeclarationBlock
{
declarations
:
declarations
important_count
:
0
longhands
:
longhands
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
has_css_wide_keyword
(
&
self
property
:
&
PropertyId
)
-
>
bool
{
if
let
PropertyId
:
:
Longhand
(
id
)
=
*
property
{
if
!
self
.
longhands
.
contains
(
id
)
{
return
false
}
}
self
.
declarations
.
iter
(
)
.
any
(
|
&
(
ref
decl
_
)
|
decl
.
id
(
)
.
is_or_is_longhand_of
(
property
)
&
&
decl
.
get_css_wide_keyword
(
)
.
is_some
(
)
)
}
}
impl
ToCss
for
PropertyDeclarationBlock
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
let
mut
is_first_serialization
=
true
;
let
mut
already_serialized
=
Vec
:
:
new
(
)
;
for
&
(
ref
declaration
importance
)
in
&
*
self
.
declarations
{
let
property
=
declaration
.
id
(
)
;
if
already_serialized
.
contains
(
&
property
)
{
continue
;
}
let
shorthands
=
declaration
.
shorthands
(
)
;
if
!
shorthands
.
is_empty
(
)
{
let
mut
longhands
=
self
.
declarations
.
iter
(
)
.
filter
(
|
d
|
!
already_serialized
.
contains
(
&
d
.
0
.
id
(
)
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
for
&
shorthand
in
shorthands
{
let
properties
=
shorthand
.
longhands
(
)
;
let
mut
current_longhands
=
Vec
:
:
new
(
)
;
let
mut
important_count
=
0
;
let
mut
found_system
=
None
;
if
shorthand
=
=
ShorthandId
:
:
Font
&
&
longhands
.
iter
(
)
.
any
(
|
&
&
(
ref
l
_
)
|
l
.
get_system
(
)
.
is_some
(
)
)
{
for
&
&
(
ref
longhand
longhand_importance
)
in
longhands
.
iter
(
)
{
if
longhand
.
get_system
(
)
.
is_some
(
)
|
|
longhand
.
is_default_line_height
(
)
{
current_longhands
.
push
(
longhand
)
;
if
found_system
.
is_none
(
)
{
found_system
=
longhand
.
get_system
(
)
;
}
if
longhand_importance
.
important
(
)
{
important_count
+
=
1
;
}
}
}
}
else
{
for
&
&
(
ref
longhand
longhand_importance
)
in
longhands
.
iter
(
)
{
if
longhand
.
id
(
)
.
is_longhand_of
(
shorthand
)
{
current_longhands
.
push
(
longhand
)
;
if
longhand_importance
.
important
(
)
{
important_count
+
=
1
;
}
}
}
if
current_longhands
.
len
(
)
!
=
properties
.
len
(
)
{
continue
;
}
}
let
is_important
=
important_count
>
0
;
if
is_important
&
&
important_count
!
=
current_longhands
.
len
(
)
{
continue
;
}
let
importance
=
if
is_important
{
Importance
:
:
Important
}
else
{
Importance
:
:
Normal
}
;
let
appendable_value
=
match
shorthand
.
get_shorthand_appendable_value
(
current_longhands
.
iter
(
)
.
cloned
(
)
)
{
None
=
>
continue
Some
(
appendable_value
)
=
>
appendable_value
}
;
let
mut
v
=
String
:
:
new
(
)
;
let
value
=
match
(
appendable_value
found_system
)
{
(
AppendableValue
:
:
Css
{
css
with_variables
}
_
)
=
>
{
debug_assert
!
(
!
css
.
is_empty
(
)
)
;
AppendableValue
:
:
Css
{
css
:
css
with_variables
:
with_variables
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
(
_
Some
(
sys
)
)
=
>
{
sys
.
to_css
(
&
mut
v
)
?
;
AppendableValue
:
:
Css
{
css
:
&
v
with_variables
:
false
}
}
(
other
_
)
=
>
{
append_declaration_value
(
&
mut
v
other
)
?
;
if
v
.
is_empty
(
)
{
continue
;
}
AppendableValue
:
:
Css
{
css
:
&
v
with_variables
:
false
}
}
}
;
if
shorthand
.
flags
(
)
.
contains
(
SHORTHAND_ALIAS_PROPERTY
)
{
append_serialization
:
:
<
_
Cloned
<
slice
:
:
Iter
<
_
>
>
_
>
(
dest
&
property
value
importance
&
mut
is_first_serialization
)
?
;
}
else
{
append_serialization
:
:
<
_
Cloned
<
slice
:
:
Iter
<
_
>
>
_
>
(
dest
&
shorthand
value
importance
&
mut
is_first_serialization
)
?
;
}
for
current_longhand
in
&
current_longhands
{
already_serialized
.
push
(
current_longhand
.
id
(
)
)
;
let
index_to_remove
=
longhands
.
iter
(
)
.
position
(
|
l
|
l
.
0
=
=
*
*
current_longhand
)
;
if
let
Some
(
index
)
=
index_to_remove
{
longhands
.
remove
(
index
)
;
}
}
}
}
if
already_serialized
.
contains
(
&
property
)
{
continue
;
}
use
std
:
:
iter
:
:
Cloned
;
use
std
:
:
slice
;
append_serialization
:
:
<
_
Cloned
<
slice
:
:
Iter
<
_
>
>
_
>
(
dest
&
property
AppendableValue
:
:
Declaration
(
declaration
)
importance
&
mut
is_first_serialization
)
?
;
already_serialized
.
push
(
property
)
;
}
Ok
(
(
)
)
}
}
pub
enum
AppendableValue
<
'
a
I
>
where
I
:
Iterator
<
Item
=
&
'
a
PropertyDeclaration
>
{
Declaration
(
&
'
a
PropertyDeclaration
)
DeclarationsForShorthand
(
ShorthandId
I
)
Css
{
css
:
&
'
a
str
with_variables
:
bool
}
}
fn
handle_first_serialization
<
W
>
(
dest
:
&
mut
W
is_first_serialization
:
&
mut
bool
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
if
!
*
is_first_serialization
{
dest
.
write_str
(
"
"
)
}
else
{
*
is_first_serialization
=
false
;
Ok
(
(
)
)
}
}
pub
fn
append_declaration_value
<
'
a
W
I
>
(
dest
:
&
mut
W
appendable_value
:
AppendableValue
<
'
a
I
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
I
:
Iterator
<
Item
=
&
'
a
PropertyDeclaration
>
{
match
appendable_value
{
AppendableValue
:
:
Css
{
css
.
.
}
=
>
{
dest
.
write_str
(
css
)
}
AppendableValue
:
:
Declaration
(
decl
)
=
>
{
decl
.
to_css
(
dest
)
}
AppendableValue
:
:
DeclarationsForShorthand
(
shorthand
decls
)
=
>
{
shorthand
.
longhands_to_css
(
decls
dest
)
}
}
}
pub
fn
append_serialization
<
'
a
W
I
N
>
(
dest
:
&
mut
W
property_name
:
&
N
appendable_value
:
AppendableValue
<
'
a
I
>
importance
:
Importance
is_first_serialization
:
&
mut
bool
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
I
:
Iterator
<
Item
=
&
'
a
PropertyDeclaration
>
N
:
ToCss
{
try
!
(
handle_first_serialization
(
dest
is_first_serialization
)
)
;
try
!
(
property_name
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_char
(
'
:
'
)
)
;
match
appendable_value
{
AppendableValue
:
:
Declaration
(
decl
)
=
>
{
if
!
decl
.
value_is_unparsed
(
)
{
dest
.
write_str
(
"
"
)
?
}
}
AppendableValue
:
:
Css
{
with_variables
.
.
}
=
>
{
if
!
with_variables
{
dest
.
write_str
(
"
"
)
?
}
}
AppendableValue
:
:
DeclarationsForShorthand
(
.
.
)
=
>
unreachable
!
(
)
}
try
!
(
append_declaration_value
(
dest
appendable_value
)
)
;
if
importance
.
important
(
)
{
try
!
(
dest
.
write_str
(
"
!
important
"
)
)
;
}
dest
.
write_char
(
'
;
'
)
}
pub
fn
parse_style_attribute
(
input
:
&
str
url_data
:
&
UrlExtraData
error_reporter
:
&
ParseErrorReporter
quirks_mode
:
QuirksMode
)
-
>
PropertyDeclarationBlock
{
let
context
=
ParserContext
:
:
new
(
Origin
:
:
Author
url_data
error_reporter
Some
(
CssRuleType
:
:
Style
)
PARSING_MODE_DEFAULT
quirks_mode
)
;
parse_property_declaration_list
(
&
context
&
mut
Parser
:
:
new
(
input
)
)
}
pub
fn
parse_one_declaration_into
(
declarations
:
&
mut
SourcePropertyDeclaration
id
:
PropertyId
input
:
&
str
url_data
:
&
UrlExtraData
error_reporter
:
&
ParseErrorReporter
parsing_mode
:
ParsingMode
quirks_mode
:
QuirksMode
)
-
>
Result
<
(
)
(
)
>
{
let
context
=
ParserContext
:
:
new
(
Origin
:
:
Author
url_data
error_reporter
Some
(
CssRuleType
:
:
Style
)
parsing_mode
quirks_mode
)
;
Parser
:
:
new
(
input
)
.
parse_entirely
(
|
parser
|
{
PropertyDeclaration
:
:
parse_into
(
declarations
id
&
context
parser
)
.
map_err
(
|
_
|
(
)
)
}
)
}
struct
PropertyDeclarationParser
<
'
a
'
b
:
'
a
>
{
context
:
&
'
a
ParserContext
<
'
b
>
declarations
:
&
'
a
mut
SourcePropertyDeclaration
}
impl
<
'
a
'
b
>
AtRuleParser
for
PropertyDeclarationParser
<
'
a
'
b
>
{
type
Prelude
=
(
)
;
type
AtRule
=
Importance
;
}
impl
<
'
a
'
b
>
DeclarationParser
for
PropertyDeclarationParser
<
'
a
'
b
>
{
type
Declaration
=
Importance
;
fn
parse_value
(
&
mut
self
name
:
&
str
input
:
&
mut
Parser
)
-
>
Result
<
Importance
(
)
>
{
let
id
=
try
!
(
PropertyId
:
:
parse
(
name
.
into
(
)
)
)
;
input
.
parse_until_before
(
Delimiter
:
:
Bang
|
input
|
{
PropertyDeclaration
:
:
parse_into
(
self
.
declarations
id
self
.
context
input
)
.
map_err
(
|
_
|
(
)
)
}
)
?
;
let
importance
=
match
input
.
try
(
parse_important
)
{
Ok
(
(
)
)
=
>
Importance
:
:
Important
Err
(
(
)
)
=
>
Importance
:
:
Normal
}
;
input
.
expect_exhausted
(
)
?
;
Ok
(
importance
)
}
}
pub
fn
parse_property_declaration_list
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
PropertyDeclarationBlock
{
let
mut
declarations
=
SourcePropertyDeclaration
:
:
new
(
)
;
let
mut
block
=
PropertyDeclarationBlock
:
:
new
(
)
;
let
parser
=
PropertyDeclarationParser
{
context
:
context
declarations
:
&
mut
declarations
}
;
let
mut
iter
=
DeclarationListParser
:
:
new
(
input
parser
)
;
while
let
Some
(
declaration
)
=
iter
.
next
(
)
{
match
declaration
{
Ok
(
importance
)
=
>
{
block
.
extend
(
iter
.
parser
.
declarations
.
drain
(
)
importance
)
;
}
Err
(
range
)
=
>
{
iter
.
parser
.
declarations
.
clear
(
)
;
let
pos
=
range
.
start
;
let
message
=
format
!
(
"
Unsupported
property
declaration
:
'
{
}
'
"
iter
.
input
.
slice
(
range
)
)
;
log_css_error
(
iter
.
input
pos
&
*
message
&
context
)
;
}
}
}
block
}
