<
%
namespace
name
=
"
helpers
"
file
=
"
/
helpers
.
mako
.
rs
"
/
>
macro_rules
!
try_parse_one
{
(
context
:
expr
input
:
expr
var
:
ident
prop_module
:
ident
)
=
>
{
if
var
.
is_none
(
)
{
if
let
Ok
(
value
)
=
input
.
try_parse
(
|
i
|
{
prop_module
:
:
single_value
:
:
parse
(
context
i
)
}
)
{
var
=
Some
(
value
)
;
continue
;
}
}
}
;
}
<
%
helpers
:
shorthand
name
=
"
transition
"
engines
=
"
gecko
servo
-
2013
servo
-
2020
"
extra_prefixes
=
"
moz
:
layout
.
css
.
prefixes
.
transitions
webkit
"
sub_properties
=
"
transition
-
property
transition
-
duration
transition
-
timing
-
function
transition
-
delay
"
spec
=
"
https
:
use
crate
:
:
parser
:
:
Parse
;
%
for
prop
in
"
delay
duration
property
timing_function
"
.
split
(
)
:
use
crate
:
:
properties
:
:
longhands
:
:
transition_
{
prop
}
;
%
endfor
use
crate
:
:
values
:
:
specified
:
:
TransitionProperty
;
pub
fn
parse_value
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Longhands
ParseError
<
'
i
>
>
{
struct
SingleTransition
{
%
for
prop
in
"
duration
timing_function
delay
"
.
split
(
)
:
transition_
{
prop
}
:
transition_
{
prop
}
:
:
SingleSpecifiedValue
%
endfor
transition_property
:
Option
<
TransitionProperty
>
}
fn
parse_one_transition
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
SingleTransition
ParseError
<
'
i
>
>
{
%
for
prop
in
"
property
duration
timing_function
delay
"
.
split
(
)
:
let
mut
{
prop
}
=
None
;
%
endfor
let
mut
parsed
=
0
;
loop
{
parsed
+
=
1
;
try_parse_one
!
(
context
input
duration
transition_duration
)
;
try_parse_one
!
(
context
input
timing_function
transition_timing_function
)
;
try_parse_one
!
(
context
input
delay
transition_delay
)
;
if
property
.
is_none
(
)
{
if
let
Ok
(
value
)
=
input
.
try_parse
(
|
i
|
TransitionProperty
:
:
parse
(
context
i
)
)
{
property
=
Some
(
Some
(
value
)
)
;
continue
;
}
if
input
.
try_parse
(
|
i
|
i
.
expect_ident_matching
(
"
none
"
)
)
.
is_ok
(
)
{
property
=
Some
(
None
)
;
continue
;
}
}
parsed
-
=
1
;
break
}
if
parsed
!
=
0
{
Ok
(
SingleTransition
{
%
for
prop
in
"
duration
timing_function
delay
"
.
split
(
)
:
transition_
{
prop
}
:
{
prop
}
.
unwrap_or_else
(
transition_
{
prop
}
:
:
single_value
:
:
get_initial_specified_value
)
%
endfor
transition_property
:
property
.
unwrap_or
(
Some
(
transition_property
:
:
single_value
:
:
get_initial_specified_value
(
)
)
)
}
)
}
else
{
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
}
%
for
prop
in
"
property
duration
timing_function
delay
"
.
split
(
)
:
let
mut
{
prop
}
s
=
Vec
:
:
new
(
)
;
%
endfor
let
results
=
input
.
parse_comma_separated
(
|
i
|
parse_one_transition
(
context
i
)
)
?
;
let
multiple_items
=
results
.
len
(
)
>
=
2
;
for
result
in
results
{
if
let
Some
(
value
)
=
result
.
transition_property
{
propertys
.
push
(
value
)
;
}
else
if
multiple_items
{
return
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
%
for
prop
in
"
duration
timing_function
delay
"
.
split
(
)
:
{
prop
}
s
.
push
(
result
.
transition_
{
prop
}
)
;
%
endfor
}
Ok
(
expanded
!
{
%
for
prop
in
"
property
duration
timing_function
delay
"
.
split
(
)
:
transition_
{
prop
}
:
transition_
{
prop
}
:
:
SpecifiedValue
(
{
prop
}
s
.
into
(
)
)
%
endfor
}
)
}
impl
<
'
a
>
ToCss
for
LonghandsToSerialize
<
'
a
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
let
property_len
=
self
.
transition_property
.
0
.
len
(
)
;
if
property_len
=
=
0
{
%
for
name
in
"
duration
delay
timing_function
"
.
split
(
)
:
if
self
.
transition_
{
name
}
.
0
.
len
(
)
!
=
1
{
return
Ok
(
(
)
)
;
}
%
endfor
}
else
{
%
for
name
in
"
duration
delay
timing_function
"
.
split
(
)
:
if
self
.
transition_
{
name
}
.
0
.
len
(
)
!
=
property_len
{
return
Ok
(
(
)
)
;
}
%
endfor
}
let
len
=
self
.
transition_duration
.
0
.
len
(
)
;
for
i
in
0
.
.
len
{
if
i
!
=
0
{
dest
.
write_str
(
"
"
)
?
;
}
if
property_len
=
=
0
{
dest
.
write_str
(
"
none
"
)
?
;
}
else
{
self
.
transition_property
.
0
[
i
]
.
to_css
(
dest
)
?
;
}
%
for
name
in
"
duration
timing_function
delay
"
.
split
(
)
:
dest
.
write_str
(
"
"
)
?
;
self
.
transition_
{
name
}
.
0
[
i
]
.
to_css
(
dest
)
?
;
%
endfor
}
Ok
(
(
)
)
}
}
<
/
%
helpers
:
shorthand
>
<
%
helpers
:
shorthand
name
=
"
animation
"
engines
=
"
gecko
servo
-
2013
servo
-
2020
"
extra_prefixes
=
"
moz
:
layout
.
css
.
prefixes
.
animations
webkit
"
sub_properties
=
"
animation
-
name
animation
-
duration
animation
-
timing
-
function
animation
-
delay
animation
-
iteration
-
count
animation
-
direction
animation
-
fill
-
mode
animation
-
play
-
state
animation
-
timeline
"
rule_types_allowed
=
"
Style
"
spec
=
"
https
:
/
/
drafts
.
csswg
.
org
/
css
-
animations
/
#
propdef
-
animation
"
>
<
%
props
=
"
name
timeline
duration
timing_function
delay
iteration_count
\
direction
fill_mode
play_state
"
.
split
(
)
%
>
%
for
prop
in
props
:
use
crate
:
:
properties
:
:
longhands
:
:
animation_
{
prop
}
;
%
endfor
pub
fn
parse_value
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Longhands
ParseError
<
'
i
>
>
{
struct
SingleAnimation
{
%
for
prop
in
props
:
animation_
{
prop
}
:
animation_
{
prop
}
:
:
SingleSpecifiedValue
%
endfor
}
fn
parse_one_animation
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
SingleAnimation
ParseError
<
'
i
>
>
{
%
for
prop
in
props
:
let
mut
{
prop
}
=
None
;
%
endfor
let
mut
parsed
=
0
;
loop
{
parsed
+
=
1
;
try_parse_one
!
(
context
input
duration
animation_duration
)
;
try_parse_one
!
(
context
input
timing_function
animation_timing_function
)
;
try_parse_one
!
(
context
input
delay
animation_delay
)
;
try_parse_one
!
(
context
input
iteration_count
animation_iteration_count
)
;
try_parse_one
!
(
context
input
direction
animation_direction
)
;
try_parse_one
!
(
context
input
fill_mode
animation_fill_mode
)
;
try_parse_one
!
(
context
input
play_state
animation_play_state
)
;
try_parse_one
!
(
context
input
name
animation_name
)
;
if
static_prefs
:
:
pref
!
(
"
layout
.
css
.
scroll
-
linked
-
animations
.
enabled
"
)
{
try_parse_one
!
(
context
input
timeline
animation_timeline
)
;
}
parsed
-
=
1
;
break
}
if
parsed
=
=
0
{
Err
(
input
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
else
{
Ok
(
SingleAnimation
{
%
for
prop
in
props
:
animation_
{
prop
}
:
{
prop
}
.
unwrap_or_else
(
animation_
{
prop
}
:
:
single_value
:
:
get_initial_specified_value
)
%
endfor
}
)
}
}
%
for
prop
in
props
:
let
mut
{
prop
}
s
=
vec
!
[
]
;
%
endfor
let
results
=
input
.
parse_comma_separated
(
|
i
|
parse_one_animation
(
context
i
)
)
?
;
for
result
in
results
.
into_iter
(
)
{
%
for
prop
in
props
:
{
prop
}
s
.
push
(
result
.
animation_
{
prop
}
)
;
%
endfor
}
Ok
(
expanded
!
{
%
for
prop
in
props
:
animation_
{
prop
}
:
animation_
{
prop
}
:
:
SpecifiedValue
(
{
prop
}
s
.
into
(
)
)
%
endfor
}
)
}
impl
<
'
a
>
ToCss
for
LonghandsToSerialize
<
'
a
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
let
len
=
self
.
animation_name
.
0
.
len
(
)
;
if
len
=
=
0
{
return
Ok
(
(
)
)
;
}
%
for
name
in
props
[
2
:
]
:
if
len
!
=
self
.
animation_
{
name
}
.
0
.
len
(
)
{
return
Ok
(
(
)
)
}
%
endfor
if
self
.
animation_timeline
.
map_or
(
false
|
v
|
len
!
=
v
.
0
.
len
(
)
)
{
return
Ok
(
(
)
)
;
}
for
i
in
0
.
.
len
{
if
i
!
=
0
{
dest
.
write_str
(
"
"
)
?
;
}
%
for
name
in
props
[
2
:
]
:
self
.
animation_
{
name
}
.
0
[
i
]
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
"
)
?
;
%
endfor
self
.
animation_name
.
0
[
i
]
.
to_css
(
dest
)
?
;
if
let
Some
(
ref
timeline
)
=
self
.
animation_timeline
{
if
!
timeline
.
0
[
i
]
.
is_auto
(
)
{
dest
.
write_char
(
'
'
)
?
;
timeline
.
0
[
i
]
.
to_css
(
dest
)
?
;
}
}
}
Ok
(
(
)
)
}
}
<
/
%
helpers
:
shorthand
>
