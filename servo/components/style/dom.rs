#
!
[
allow
(
unsafe_code
)
]
use
data
:
:
PrivateStyleData
;
use
element_state
:
:
ElementState
;
use
properties
:
:
{
PropertyDeclaration
PropertyDeclarationBlock
TComputedValues
}
;
use
restyle_hints
:
:
{
ElementSnapshot
RESTYLE_DESCENDANTS
RESTYLE_LATER_SIBLINGS
RESTYLE_SELF
RestyleHint
}
;
use
selector_impl
:
:
ElementExt
;
use
selectors
:
:
Element
;
use
selectors
:
:
matching
:
:
DeclarationBlock
;
use
smallvec
:
:
VecLike
;
use
std
:
:
cell
:
:
{
Ref
RefMut
}
;
use
std
:
:
ops
:
:
BitOr
;
use
std
:
:
sync
:
:
Arc
;
use
string_cache
:
:
{
Atom
Namespace
}
;
pub
type
UnsafeNode
=
(
usize
usize
)
;
#
[
derive
(
Clone
PartialEq
Copy
Debug
HeapSizeOf
Hash
Eq
Deserialize
Serialize
)
]
pub
struct
OpaqueNode
(
pub
usize
)
;
impl
OpaqueNode
{
#
[
inline
]
pub
fn
id
(
&
self
)
-
>
usize
{
self
.
0
}
}
pub
trait
TRestyleDamage
:
BitOr
<
Output
=
Self
>
+
Copy
{
type
ConcreteComputedValues
:
TComputedValues
;
fn
compute
(
old
:
Option
<
&
Arc
<
Self
:
:
ConcreteComputedValues
>
>
new
:
&
Self
:
:
ConcreteComputedValues
)
-
>
Self
;
fn
rebuild_and_reflow
(
)
-
>
Self
;
}
pub
trait
TNode
:
Sized
+
Copy
+
Clone
{
type
ConcreteElement
:
TElement
<
ConcreteNode
=
Self
ConcreteDocument
=
Self
:
:
ConcreteDocument
>
;
type
ConcreteDocument
:
TDocument
<
ConcreteNode
=
Self
ConcreteElement
=
Self
:
:
ConcreteElement
>
;
type
ConcreteRestyleDamage
:
TRestyleDamage
<
ConcreteComputedValues
=
Self
:
:
ConcreteComputedValues
>
;
type
ConcreteComputedValues
:
TComputedValues
;
fn
to_unsafe
(
&
self
)
-
>
UnsafeNode
;
unsafe
fn
from_unsafe
(
n
:
&
UnsafeNode
)
-
>
Self
;
fn
is_text_node
(
&
self
)
-
>
bool
;
fn
is_element
(
&
self
)
-
>
bool
;
fn
dump
(
self
)
;
fn
traverse_preorder
(
self
)
-
>
TreeIterator
<
Self
>
{
TreeIterator
:
:
new
(
self
)
}
fn
children
(
self
)
-
>
ChildrenIterator
<
Self
>
{
ChildrenIterator
{
current
:
self
.
first_child
(
)
}
}
fn
rev_children
(
self
)
-
>
ReverseChildrenIterator
<
Self
>
{
ReverseChildrenIterator
{
current
:
self
.
last_child
(
)
}
}
fn
opaque
(
&
self
)
-
>
OpaqueNode
;
fn
initialize_data
(
self
)
;
fn
layout_parent_node
(
self
reflow_root
:
OpaqueNode
)
-
>
Option
<
Self
>
;
fn
debug_id
(
self
)
-
>
usize
;
fn
as_element
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteElement
>
;
fn
as_document
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteDocument
>
;
fn
children_count
(
&
self
)
-
>
u32
;
fn
has_changed
(
&
self
)
-
>
bool
;
unsafe
fn
set_changed
(
&
self
value
:
bool
)
;
fn
is_dirty
(
&
self
)
-
>
bool
;
unsafe
fn
set_dirty
(
&
self
value
:
bool
)
;
fn
has_dirty_descendants
(
&
self
)
-
>
bool
;
unsafe
fn
set_dirty_descendants
(
&
self
value
:
bool
)
;
fn
dirty_self
(
&
self
)
{
unsafe
{
self
.
set_dirty
(
true
)
;
self
.
set_dirty_descendants
(
true
)
;
}
}
fn
dirty_descendants
(
&
self
)
{
for
ref
child
in
self
.
children
(
)
{
child
.
dirty_self
(
)
;
child
.
dirty_descendants
(
)
;
}
}
fn
can_be_fragmented
(
&
self
)
-
>
bool
;
unsafe
fn
set_can_be_fragmented
(
&
self
value
:
bool
)
;
#
[
inline
(
always
)
]
unsafe
fn
borrow_data_unchecked
(
&
self
)
-
>
Option
<
*
const
PrivateStyleData
<
<
Self
:
:
ConcreteElement
as
Element
>
:
:
Impl
Self
:
:
ConcreteComputedValues
>
>
;
#
[
inline
(
always
)
]
fn
borrow_data
(
&
self
)
-
>
Option
<
Ref
<
PrivateStyleData
<
<
Self
:
:
ConcreteElement
as
Element
>
:
:
Impl
Self
:
:
ConcreteComputedValues
>
>
>
;
#
[
inline
(
always
)
]
fn
mutate_data
(
&
self
)
-
>
Option
<
RefMut
<
PrivateStyleData
<
<
Self
:
:
ConcreteElement
as
Element
>
:
:
Impl
Self
:
:
ConcreteComputedValues
>
>
>
;
fn
restyle_damage
(
self
)
-
>
Self
:
:
ConcreteRestyleDamage
;
fn
set_restyle_damage
(
self
damage
:
Self
:
:
ConcreteRestyleDamage
)
;
fn
parent_node
(
&
self
)
-
>
Option
<
Self
>
;
fn
first_child
(
&
self
)
-
>
Option
<
Self
>
;
fn
last_child
(
&
self
)
-
>
Option
<
Self
>
;
fn
prev_sibling
(
&
self
)
-
>
Option
<
Self
>
;
fn
next_sibling
(
&
self
)
-
>
Option
<
Self
>
;
fn
style
(
&
self
)
-
>
Ref
<
Arc
<
Self
:
:
ConcreteComputedValues
>
>
{
Ref
:
:
map
(
self
.
borrow_data
(
)
.
unwrap
(
)
|
data
|
data
.
style
.
as_ref
(
)
.
unwrap
(
)
)
}
fn
unstyle
(
self
)
{
self
.
mutate_data
(
)
.
unwrap
(
)
.
style
=
None
;
}
}
pub
trait
TDocument
:
Sized
+
Copy
+
Clone
{
type
ConcreteNode
:
TNode
<
ConcreteElement
=
Self
:
:
ConcreteElement
ConcreteDocument
=
Self
>
;
type
ConcreteElement
:
TElement
<
ConcreteNode
=
Self
:
:
ConcreteNode
ConcreteDocument
=
Self
>
;
fn
as_node
(
&
self
)
-
>
Self
:
:
ConcreteNode
;
fn
root_node
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteNode
>
;
fn
drain_modified_elements
(
&
self
)
-
>
Vec
<
(
Self
:
:
ConcreteElement
ElementSnapshot
)
>
;
}
pub
trait
TElement
:
Sized
+
Copy
+
Clone
+
ElementExt
{
type
ConcreteNode
:
TNode
<
ConcreteElement
=
Self
ConcreteDocument
=
Self
:
:
ConcreteDocument
>
;
type
ConcreteDocument
:
TDocument
<
ConcreteNode
=
Self
:
:
ConcreteNode
ConcreteElement
=
Self
>
;
fn
as_node
(
&
self
)
-
>
Self
:
:
ConcreteNode
;
fn
style_attribute
(
&
self
)
-
>
&
Option
<
PropertyDeclarationBlock
>
;
fn
get_state
(
&
self
)
-
>
ElementState
;
fn
synthesize_presentational_hints_for_legacy_attributes
<
V
>
(
&
self
&
mut
V
)
where
V
:
VecLike
<
DeclarationBlock
<
Vec
<
PropertyDeclaration
>
>
>
;
fn
get_attr
<
'
a
>
(
&
'
a
self
namespace
:
&
Namespace
attr
:
&
Atom
)
-
>
Option
<
&
'
a
str
>
;
fn
get_attrs
<
'
a
>
(
&
'
a
self
attr
:
&
Atom
)
-
>
Vec
<
&
'
a
str
>
;
fn
note_restyle_hint
(
&
self
mut
hint
:
RestyleHint
)
{
if
hint
.
is_empty
(
)
{
return
;
}
let
node
=
self
.
as_node
(
)
;
let
mut
curr
=
node
;
while
let
Some
(
parent
)
=
curr
.
parent_node
(
)
{
if
parent
.
has_dirty_descendants
(
)
{
break
}
unsafe
{
parent
.
set_dirty_descendants
(
true
)
;
}
curr
=
parent
;
}
if
hint
.
contains
(
RESTYLE_SELF
)
{
node
.
dirty_self
(
)
;
hint
.
insert
(
RESTYLE_DESCENDANTS
)
;
}
if
hint
.
contains
(
RESTYLE_DESCENDANTS
)
{
unsafe
{
node
.
set_dirty_descendants
(
true
)
;
}
node
.
dirty_descendants
(
)
;
}
if
hint
.
contains
(
RESTYLE_LATER_SIBLINGS
)
{
let
mut
next
=
:
:
selectors
:
:
Element
:
:
next_sibling_element
(
self
)
;
while
let
Some
(
sib
)
=
next
{
let
sib_node
=
sib
.
as_node
(
)
;
sib_node
.
dirty_self
(
)
;
sib_node
.
dirty_descendants
(
)
;
next
=
:
:
selectors
:
:
Element
:
:
next_sibling_element
(
&
sib
)
;
}
}
}
}
pub
struct
TreeIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
stack
:
Vec
<
ConcreteNode
>
}
impl
<
ConcreteNode
>
TreeIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
fn
new
(
root
:
ConcreteNode
)
-
>
TreeIterator
<
ConcreteNode
>
{
let
mut
stack
=
vec
!
(
)
;
stack
.
push
(
root
)
;
TreeIterator
{
stack
:
stack
}
}
}
impl
<
ConcreteNode
>
Iterator
for
TreeIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
type
Item
=
ConcreteNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
ConcreteNode
>
{
let
ret
=
self
.
stack
.
pop
(
)
;
ret
.
map
(
|
node
|
self
.
stack
.
extend
(
node
.
rev_children
(
)
)
)
;
ret
}
}
pub
struct
ChildrenIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
current
:
Option
<
ConcreteNode
>
}
impl
<
ConcreteNode
>
Iterator
for
ChildrenIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
type
Item
=
ConcreteNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
ConcreteNode
>
{
let
node
=
self
.
current
;
self
.
current
=
node
.
and_then
(
|
node
|
node
.
next_sibling
(
)
)
;
node
}
}
pub
struct
ReverseChildrenIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
current
:
Option
<
ConcreteNode
>
}
impl
<
ConcreteNode
>
Iterator
for
ReverseChildrenIterator
<
ConcreteNode
>
where
ConcreteNode
:
TNode
{
type
Item
=
ConcreteNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
ConcreteNode
>
{
let
node
=
self
.
current
;
self
.
current
=
node
.
and_then
(
|
node
|
node
.
prev_sibling
(
)
)
;
node
}
}
