#
!
[
allow
(
unsafe_code
)
]
use
atomic_refcell
:
:
{
AtomicRef
AtomicRefMut
}
;
use
data
:
:
{
ElementStyles
ElementData
}
;
use
element_state
:
:
ElementState
;
use
parking_lot
:
:
RwLock
;
use
properties
:
:
{
ComputedValues
PropertyDeclarationBlock
}
;
use
restyle_hints
:
:
{
RESTYLE_DESCENDANTS
RESTYLE_LATER_SIBLINGS
RESTYLE_SELF
RestyleHint
}
;
use
selector_impl
:
:
{
ElementExt
PseudoElement
}
;
use
selector_matching
:
:
ApplicableDeclarationBlock
;
use
sink
:
:
Push
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
ops
:
:
BitOr
;
use
std
:
:
sync
:
:
Arc
;
use
string_cache
:
:
{
Atom
Namespace
}
;
use
traversal
:
:
DomTraversalContext
;
use
util
:
:
opts
;
pub
use
style_traits
:
:
UnsafeNode
;
#
[
derive
(
Clone
PartialEq
Copy
Debug
Hash
Eq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
Deserialize
Serialize
)
)
]
pub
struct
OpaqueNode
(
pub
usize
)
;
impl
OpaqueNode
{
#
[
inline
]
pub
fn
id
(
&
self
)
-
>
usize
{
self
.
0
}
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
StylingMode
{
Initial
Restyle
Traverse
Stop
}
pub
trait
TRestyleDamage
:
Debug
+
PartialEq
+
BitOr
<
Output
=
Self
>
+
Copy
{
type
PreExistingComputedValues
;
fn
compute
(
old
:
&
Self
:
:
PreExistingComputedValues
new
:
&
Arc
<
ComputedValues
>
)
-
>
Self
;
fn
empty
(
)
-
>
Self
;
fn
rebuild_and_reflow
(
)
-
>
Self
;
}
pub
trait
NodeInfo
{
fn
is_element
(
&
self
)
-
>
bool
;
fn
is_text_node
(
&
self
)
-
>
bool
;
fn
needs_layout
(
&
self
)
-
>
bool
{
self
.
is_element
(
)
|
|
self
.
is_text_node
(
)
}
}
pub
struct
LayoutIterator
<
T
>
(
pub
T
)
;
impl
<
T
I
>
Iterator
for
LayoutIterator
<
T
>
where
T
:
Iterator
<
Item
=
I
>
I
:
NodeInfo
{
type
Item
=
I
;
fn
next
(
&
mut
self
)
-
>
Option
<
I
>
{
loop
{
let
n
=
self
.
0
.
next
(
)
;
if
n
.
is_none
(
)
|
|
n
.
as_ref
(
)
.
unwrap
(
)
.
needs_layout
(
)
{
return
n
}
}
}
}
pub
trait
TNode
:
Sized
+
Copy
+
Clone
+
NodeInfo
{
type
ConcreteElement
:
TElement
<
ConcreteNode
=
Self
ConcreteDocument
=
Self
:
:
ConcreteDocument
>
;
type
ConcreteDocument
:
TDocument
<
ConcreteNode
=
Self
ConcreteElement
=
Self
:
:
ConcreteElement
>
;
type
ConcreteChildrenIterator
:
Iterator
<
Item
=
Self
>
;
fn
to_unsafe
(
&
self
)
-
>
UnsafeNode
;
unsafe
fn
from_unsafe
(
n
:
&
UnsafeNode
)
-
>
Self
;
fn
dump
(
self
)
;
fn
dump_style
(
self
)
;
fn
children
(
self
)
-
>
LayoutIterator
<
Self
:
:
ConcreteChildrenIterator
>
;
fn
opaque
(
&
self
)
-
>
OpaqueNode
;
fn
layout_parent_element
(
self
reflow_root
:
OpaqueNode
)
-
>
Option
<
Self
:
:
ConcreteElement
>
;
fn
debug_id
(
self
)
-
>
usize
;
fn
as_element
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteElement
>
;
fn
as_document
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteDocument
>
;
fn
needs_dirty_on_viewport_size_changed
(
&
self
)
-
>
bool
;
unsafe
fn
set_dirty_on_viewport_size_changed
(
&
self
)
;
fn
can_be_fragmented
(
&
self
)
-
>
bool
;
unsafe
fn
set_can_be_fragmented
(
&
self
value
:
bool
)
;
fn
parent_node
(
&
self
)
-
>
Option
<
Self
>
;
fn
first_child
(
&
self
)
-
>
Option
<
Self
>
;
fn
last_child
(
&
self
)
-
>
Option
<
Self
>
;
fn
prev_sibling
(
&
self
)
-
>
Option
<
Self
>
;
fn
next_sibling
(
&
self
)
-
>
Option
<
Self
>
;
}
pub
trait
TDocument
:
Sized
+
Copy
+
Clone
{
type
ConcreteNode
:
TNode
<
ConcreteElement
=
Self
:
:
ConcreteElement
ConcreteDocument
=
Self
>
;
type
ConcreteElement
:
TElement
<
ConcreteNode
=
Self
:
:
ConcreteNode
ConcreteDocument
=
Self
>
;
fn
as_node
(
&
self
)
-
>
Self
:
:
ConcreteNode
;
fn
root_node
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteNode
>
;
fn
drain_modified_elements
(
&
self
)
-
>
Vec
<
(
Self
:
:
ConcreteElement
<
Self
:
:
ConcreteElement
as
ElementExt
>
:
:
Snapshot
)
>
;
fn
needs_paint_from_layout
(
&
self
)
;
fn
will_paint
(
&
self
)
;
}
pub
trait
PresentationalHintsSynthetizer
{
fn
synthesize_presentational_hints_for_legacy_attributes
<
V
>
(
&
self
hints
:
&
mut
V
)
where
V
:
Push
<
ApplicableDeclarationBlock
>
;
}
pub
trait
TElement
:
PartialEq
+
Debug
+
Sized
+
Copy
+
Clone
+
ElementExt
+
PresentationalHintsSynthetizer
{
type
ConcreteNode
:
TNode
<
ConcreteElement
=
Self
ConcreteDocument
=
Self
:
:
ConcreteDocument
>
;
type
ConcreteDocument
:
TDocument
<
ConcreteNode
=
Self
:
:
ConcreteNode
ConcreteElement
=
Self
>
;
type
ConcreteRestyleDamage
:
TRestyleDamage
;
fn
as_node
(
&
self
)
-
>
Self
:
:
ConcreteNode
;
fn
style_attribute
(
&
self
)
-
>
Option
<
&
Arc
<
RwLock
<
PropertyDeclarationBlock
>
>
>
;
fn
get_state
(
&
self
)
-
>
ElementState
;
fn
has_attr
(
&
self
namespace
:
&
Namespace
attr
:
&
Atom
)
-
>
bool
;
fn
attr_equals
(
&
self
namespace
:
&
Namespace
attr
:
&
Atom
value
:
&
Atom
)
-
>
bool
;
fn
set_restyle_damage
(
self
damage
:
Self
:
:
ConcreteRestyleDamage
)
;
fn
existing_style_for_restyle_damage
<
'
a
>
(
&
'
a
self
current_computed_values
:
Option
<
&
'
a
Arc
<
ComputedValues
>
>
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
'
a
<
Self
:
:
ConcreteRestyleDamage
as
TRestyleDamage
>
:
:
PreExistingComputedValues
>
;
fn
deprecated_dirty_bit_is_set
(
&
self
)
-
>
bool
;
fn
has_dirty_descendants
(
&
self
)
-
>
bool
;
unsafe
fn
set_dirty_descendants
(
&
self
)
;
fn
store_children_to_process
(
&
self
n
:
isize
)
;
fn
did_process_child
(
&
self
)
-
>
isize
;
fn
frame_has_style
(
&
self
)
-
>
bool
{
false
}
fn
get_styles_from_frame
(
&
self
)
-
>
Option
<
ElementStyles
>
{
None
}
fn
styling_mode
(
&
self
)
-
>
StylingMode
{
use
self
:
:
StylingMode
:
:
*
;
if
opts
:
:
get
(
)
.
nonincremental_layout
{
return
Initial
;
}
let
mode_for_descendants
=
if
self
.
has_dirty_descendants
(
)
{
Traverse
}
else
{
Stop
}
;
match
self
.
borrow_data
(
)
{
None
if
!
self
.
frame_has_style
(
)
=
>
Initial
None
=
>
mode_for_descendants
Some
(
d
)
=
>
{
if
d
.
restyle_data
.
is_some
(
)
|
|
self
.
deprecated_dirty_bit_is_set
(
)
{
Restyle
}
else
{
debug_assert
!
(
!
self
.
frame_has_style
(
)
)
;
mode_for_descendants
}
}
}
}
fn
begin_styling
(
&
self
)
-
>
AtomicRefMut
<
ElementData
>
;
fn
borrow_data
(
&
self
)
-
>
Option
<
AtomicRef
<
ElementData
>
>
;
fn
note_restyle_hint
<
C
:
DomTraversalContext
<
Self
:
:
ConcreteNode
>
>
(
&
self
hint
:
RestyleHint
)
{
if
hint
.
is_empty
(
)
{
return
;
}
let
mut
curr
=
*
self
;
while
let
Some
(
parent
)
=
curr
.
parent_element
(
)
{
if
parent
.
has_dirty_descendants
(
)
{
break
}
unsafe
{
parent
.
set_dirty_descendants
(
)
;
}
curr
=
parent
;
}
if
hint
.
contains
(
RESTYLE_SELF
)
{
unsafe
{
C
:
:
ensure_element_data
(
self
)
.
borrow_mut
(
)
.
ensure_restyle_data
(
)
;
}
}
else
if
hint
.
contains
(
RESTYLE_DESCENDANTS
)
{
unsafe
{
self
.
set_dirty_descendants
(
)
;
}
let
mut
current
=
self
.
first_child_element
(
)
;
while
let
Some
(
el
)
=
current
{
unsafe
{
C
:
:
ensure_element_data
(
&
el
)
.
borrow_mut
(
)
.
ensure_restyle_data
(
)
;
}
current
=
el
.
next_sibling_element
(
)
;
}
}
if
hint
.
contains
(
RESTYLE_LATER_SIBLINGS
)
{
let
mut
next
=
:
:
selectors
:
:
Element
:
:
next_sibling_element
(
self
)
;
while
let
Some
(
sib
)
=
next
{
unsafe
{
C
:
:
ensure_element_data
(
&
sib
)
.
borrow_mut
(
)
.
ensure_restyle_data
(
)
}
;
next
=
:
:
selectors
:
:
Element
:
:
next_sibling_element
(
&
sib
)
;
}
}
}
}
