#
!
[
allow
(
unsafe_code
)
]
use
{
Atom
Namespace
LocalName
}
;
use
atomic_refcell
:
:
{
AtomicRef
AtomicRefCell
AtomicRefMut
}
;
use
data
:
:
{
ElementStyles
ElementData
}
;
use
element_state
:
:
ElementState
;
use
parking_lot
:
:
RwLock
;
use
properties
:
:
{
ComputedValues
PropertyDeclarationBlock
}
;
use
selector_parser
:
:
{
ElementExt
PseudoElement
RestyleDamage
}
;
use
sink
:
:
Push
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
ops
:
:
{
BitOr
BitOrAssign
}
;
use
std
:
:
sync
:
:
Arc
;
use
stylist
:
:
ApplicableDeclarationBlock
;
use
util
:
:
opts
;
pub
use
style_traits
:
:
UnsafeNode
;
#
[
derive
(
Clone
PartialEq
Copy
Debug
Hash
Eq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
Deserialize
Serialize
)
)
]
pub
struct
OpaqueNode
(
pub
usize
)
;
impl
OpaqueNode
{
#
[
inline
]
pub
fn
id
(
&
self
)
-
>
usize
{
self
.
0
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
StylingMode
{
Initial
Restyle
Traverse
Stop
}
pub
trait
TRestyleDamage
:
BitOr
<
Output
=
Self
>
+
BitOrAssign
+
Copy
+
Debug
+
PartialEq
{
type
PreExistingComputedValues
;
fn
compute
(
old
:
&
Self
:
:
PreExistingComputedValues
new
:
&
Arc
<
ComputedValues
>
)
-
>
Self
;
fn
empty
(
)
-
>
Self
;
fn
rebuild_and_reflow
(
)
-
>
Self
;
fn
is_empty
(
&
self
)
-
>
bool
{
*
self
=
=
Self
:
:
empty
(
)
}
}
pub
trait
NodeInfo
{
fn
is_element
(
&
self
)
-
>
bool
;
fn
is_text_node
(
&
self
)
-
>
bool
;
fn
needs_layout
(
&
self
)
-
>
bool
{
self
.
is_element
(
)
|
|
self
.
is_text_node
(
)
}
}
pub
struct
LayoutIterator
<
T
>
(
pub
T
)
;
impl
<
T
I
>
Iterator
for
LayoutIterator
<
T
>
where
T
:
Iterator
<
Item
=
I
>
I
:
NodeInfo
{
type
Item
=
I
;
fn
next
(
&
mut
self
)
-
>
Option
<
I
>
{
loop
{
let
n
=
self
.
0
.
next
(
)
;
if
n
.
is_none
(
)
|
|
n
.
as_ref
(
)
.
unwrap
(
)
.
needs_layout
(
)
{
return
n
}
}
}
}
pub
trait
TNode
:
Sized
+
Copy
+
Clone
+
NodeInfo
{
type
ConcreteElement
:
TElement
<
ConcreteNode
=
Self
>
;
type
ConcreteChildrenIterator
:
Iterator
<
Item
=
Self
>
;
fn
to_unsafe
(
&
self
)
-
>
UnsafeNode
;
unsafe
fn
from_unsafe
(
n
:
&
UnsafeNode
)
-
>
Self
;
fn
dump
(
self
)
;
fn
dump_style
(
self
)
;
fn
children
(
self
)
-
>
LayoutIterator
<
Self
:
:
ConcreteChildrenIterator
>
;
fn
opaque
(
&
self
)
-
>
OpaqueNode
;
fn
layout_parent_element
(
self
reflow_root
:
OpaqueNode
)
-
>
Option
<
Self
:
:
ConcreteElement
>
{
if
self
.
opaque
(
)
=
=
reflow_root
{
None
}
else
{
self
.
parent_node
(
)
.
and_then
(
|
n
|
n
.
as_element
(
)
)
}
}
fn
debug_id
(
self
)
-
>
usize
;
fn
as_element
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteElement
>
;
fn
needs_dirty_on_viewport_size_changed
(
&
self
)
-
>
bool
;
unsafe
fn
set_dirty_on_viewport_size_changed
(
&
self
)
;
fn
can_be_fragmented
(
&
self
)
-
>
bool
;
unsafe
fn
set_can_be_fragmented
(
&
self
value
:
bool
)
;
fn
parent_node
(
&
self
)
-
>
Option
<
Self
>
;
}
pub
trait
PresentationalHintsSynthetizer
{
fn
synthesize_presentational_hints_for_legacy_attributes
<
V
>
(
&
self
hints
:
&
mut
V
)
where
V
:
Push
<
ApplicableDeclarationBlock
>
;
}
pub
trait
TElement
:
PartialEq
+
Debug
+
Sized
+
Copy
+
Clone
+
ElementExt
+
PresentationalHintsSynthetizer
{
type
ConcreteNode
:
TNode
<
ConcreteElement
=
Self
>
;
fn
as_node
(
&
self
)
-
>
Self
:
:
ConcreteNode
;
fn
layout_parent_element
(
self
reflow_root
:
OpaqueNode
)
-
>
Option
<
Self
>
{
if
self
.
as_node
(
)
.
opaque
(
)
=
=
reflow_root
{
None
}
else
{
self
.
parent_element
(
)
}
}
fn
style_attribute
(
&
self
)
-
>
Option
<
&
Arc
<
RwLock
<
PropertyDeclarationBlock
>
>
>
;
fn
get_state
(
&
self
)
-
>
ElementState
;
fn
has_attr
(
&
self
namespace
:
&
Namespace
attr
:
&
LocalName
)
-
>
bool
;
fn
attr_equals
(
&
self
namespace
:
&
Namespace
attr
:
&
LocalName
value
:
&
Atom
)
-
>
bool
;
fn
existing_style_for_restyle_damage
<
'
a
>
(
&
'
a
self
current_computed_values
:
Option
<
&
'
a
Arc
<
ComputedValues
>
>
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
'
a
<
RestyleDamage
as
TRestyleDamage
>
:
:
PreExistingComputedValues
>
;
fn
has_dirty_descendants
(
&
self
)
-
>
bool
;
unsafe
fn
set_dirty_descendants
(
&
self
)
;
unsafe
fn
unset_dirty_descendants
(
&
self
)
;
fn
store_children_to_process
(
&
self
n
:
isize
)
;
fn
did_process_child
(
&
self
)
-
>
isize
;
fn
is_display_none
(
&
self
)
-
>
bool
{
self
.
borrow_data
(
)
.
unwrap
(
)
.
current_styles
(
)
.
is_display_none
(
)
}
fn
frame_has_style
(
&
self
)
-
>
bool
{
false
}
fn
get_styles_from_frame
(
&
self
)
-
>
Option
<
ElementStyles
>
{
None
}
fn
styling_mode
(
&
self
)
-
>
StylingMode
{
use
self
:
:
StylingMode
:
:
*
;
if
opts
:
:
get
(
)
.
nonincremental_layout
{
return
Initial
;
}
let
mode_for_descendants
=
if
self
.
has_dirty_descendants
(
)
{
Traverse
}
else
{
Stop
}
;
match
self
.
borrow_data
(
)
{
None
if
!
self
.
frame_has_style
(
)
=
>
Initial
None
=
>
mode_for_descendants
Some
(
d
)
=
>
match
*
d
{
ElementData
:
:
Restyle
(
_
)
=
>
Restyle
ElementData
:
:
Persistent
(
_
)
=
>
mode_for_descendants
ElementData
:
:
Initial
(
None
)
=
>
Initial
ElementData
:
:
Initial
(
Some
(
_
)
)
=
>
mode_for_descendants
}
}
}
fn
get_data
(
&
self
)
-
>
Option
<
&
AtomicRefCell
<
ElementData
>
>
;
fn
borrow_data
(
&
self
)
-
>
Option
<
AtomicRef
<
ElementData
>
>
{
self
.
get_data
(
)
.
map
(
|
x
|
x
.
borrow
(
)
)
}
fn
mutate_data
(
&
self
)
-
>
Option
<
AtomicRefMut
<
ElementData
>
>
{
self
.
get_data
(
)
.
map
(
|
x
|
x
.
borrow_mut
(
)
)
}
}
