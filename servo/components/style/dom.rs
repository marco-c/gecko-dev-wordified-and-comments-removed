#
!
[
allow
(
unsafe_code
)
]
#
!
[
deny
(
missing_docs
)
]
use
{
Atom
Namespace
LocalName
}
;
use
applicable_declarations
:
:
ApplicableDeclarationBlock
;
use
atomic_refcell
:
:
{
AtomicRef
AtomicRefCell
AtomicRefMut
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
context
:
:
UpdateAnimationsTasks
;
use
data
:
:
ElementData
;
use
element_state
:
:
ElementState
;
use
font_metrics
:
:
FontMetricsProvider
;
use
media_queries
:
:
Device
;
use
properties
:
:
{
AnimationRules
ComputedValues
PropertyDeclarationBlock
}
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
properties
:
:
animated_properties
:
:
AnimationValue
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
properties
:
:
animated_properties
:
:
TransitionProperty
;
use
rule_tree
:
:
CascadeLevel
;
use
selector_parser
:
:
{
AttrValue
ElementExt
PreExistingComputedValues
}
;
use
selector_parser
:
:
{
PseudoClassStringArg
PseudoElement
}
;
use
selectors
:
:
matching
:
:
{
ElementSelectorFlags
VisitedHandlingMode
}
;
use
selectors
:
:
sink
:
:
Push
;
use
servo_arc
:
:
{
Arc
ArcBorrow
}
;
use
shared_lock
:
:
Locked
;
use
smallvec
:
:
VecLike
;
use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
ops
:
:
Deref
;
use
stylist
:
:
Stylist
;
use
thread_state
;
use
traversal
:
:
TraversalFlags
;
pub
use
style_traits
:
:
UnsafeNode
;
#
[
derive
(
Clone
PartialEq
Copy
Debug
Hash
Eq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
Deserialize
Serialize
)
)
]
pub
struct
OpaqueNode
(
pub
usize
)
;
impl
OpaqueNode
{
#
[
inline
]
pub
fn
id
(
&
self
)
-
>
usize
{
self
.
0
}
}
pub
trait
NodeInfo
{
fn
is_element
(
&
self
)
-
>
bool
;
fn
is_text_node
(
&
self
)
-
>
bool
;
fn
needs_layout
(
&
self
)
-
>
bool
{
self
.
is_element
(
)
|
|
self
.
is_text_node
(
)
}
}
pub
struct
LayoutIterator
<
T
>
(
pub
T
)
;
impl
<
T
I
>
Iterator
for
LayoutIterator
<
T
>
where
T
:
Iterator
<
Item
=
I
>
I
:
NodeInfo
{
type
Item
=
I
;
fn
next
(
&
mut
self
)
-
>
Option
<
I
>
{
loop
{
let
n
=
self
.
0
.
next
(
)
;
if
n
.
is_none
(
)
|
|
n
.
as_ref
(
)
.
unwrap
(
)
.
needs_layout
(
)
{
return
n
}
}
}
}
pub
trait
TNode
:
Sized
+
Copy
+
Clone
+
Debug
+
NodeInfo
{
type
ConcreteElement
:
TElement
<
ConcreteNode
=
Self
>
;
type
ConcreteChildrenIterator
:
Iterator
<
Item
=
Self
>
;
fn
to_unsafe
(
&
self
)
-
>
UnsafeNode
;
unsafe
fn
from_unsafe
(
n
:
&
UnsafeNode
)
-
>
Self
;
fn
parent_node
(
&
self
)
-
>
Option
<
Self
>
;
fn
parent_element
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteElement
>
{
self
.
parent_node
(
)
.
and_then
(
|
n
|
n
.
as_element
(
)
)
}
fn
children
(
&
self
)
-
>
LayoutIterator
<
Self
:
:
ConcreteChildrenIterator
>
;
fn
traversal_parent
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteElement
>
;
fn
traversal_children
(
&
self
)
-
>
LayoutIterator
<
Self
:
:
ConcreteChildrenIterator
>
;
fn
opaque
(
&
self
)
-
>
OpaqueNode
;
fn
debug_id
(
self
)
-
>
usize
;
fn
as_element
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteElement
>
;
fn
needs_dirty_on_viewport_size_changed
(
&
self
)
-
>
bool
;
unsafe
fn
set_dirty_on_viewport_size_changed
(
&
self
)
;
fn
can_be_fragmented
(
&
self
)
-
>
bool
;
unsafe
fn
set_can_be_fragmented
(
&
self
value
:
bool
)
;
fn
is_in_doc
(
&
self
)
-
>
bool
;
}
pub
struct
ShowData
<
N
:
TNode
>
(
pub
N
)
;
impl
<
N
:
TNode
>
Debug
for
ShowData
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt_with_data
(
f
self
.
0
)
}
}
pub
struct
ShowDataAndPrimaryValues
<
N
:
TNode
>
(
pub
N
)
;
impl
<
N
:
TNode
>
Debug
for
ShowDataAndPrimaryValues
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt_with_data_and_primary_values
(
f
self
.
0
)
}
}
pub
struct
ShowSubtree
<
N
:
TNode
>
(
pub
N
)
;
impl
<
N
:
TNode
>
Debug
for
ShowSubtree
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
DOM
Subtree
:
"
)
?
;
fmt_subtree
(
f
&
|
f
n
|
write
!
(
f
"
{
:
?
}
"
n
)
self
.
0
1
)
}
}
pub
struct
ShowSubtreeData
<
N
:
TNode
>
(
pub
N
)
;
impl
<
N
:
TNode
>
Debug
for
ShowSubtreeData
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
DOM
Subtree
:
"
)
?
;
fmt_subtree
(
f
&
|
f
n
|
fmt_with_data
(
f
n
)
self
.
0
1
)
}
}
pub
struct
ShowSubtreeDataAndPrimaryValues
<
N
:
TNode
>
(
pub
N
)
;
impl
<
N
:
TNode
>
Debug
for
ShowSubtreeDataAndPrimaryValues
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
DOM
Subtree
:
"
)
?
;
fmt_subtree
(
f
&
|
f
n
|
fmt_with_data_and_primary_values
(
f
n
)
self
.
0
1
)
}
}
fn
fmt_with_data
<
N
:
TNode
>
(
f
:
&
mut
fmt
:
:
Formatter
n
:
N
)
-
>
fmt
:
:
Result
{
if
let
Some
(
el
)
=
n
.
as_element
(
)
{
write
!
(
f
"
{
:
?
}
dd
=
{
}
data
=
{
:
?
}
"
el
el
.
has_dirty_descendants
(
)
el
.
borrow_data
(
)
)
}
else
{
write
!
(
f
"
{
:
?
}
"
n
)
}
}
fn
fmt_with_data_and_primary_values
<
N
:
TNode
>
(
f
:
&
mut
fmt
:
:
Formatter
n
:
N
)
-
>
fmt
:
:
Result
{
if
let
Some
(
el
)
=
n
.
as_element
(
)
{
let
dd
=
el
.
has_dirty_descendants
(
)
;
let
data
=
el
.
borrow_data
(
)
;
let
values
=
data
.
as_ref
(
)
.
and_then
(
|
d
|
d
.
styles
.
get_primary
(
)
)
;
write
!
(
f
"
{
:
?
}
dd
=
{
}
data
=
{
:
?
}
values
=
{
:
?
}
"
el
dd
&
data
values
)
}
else
{
write
!
(
f
"
{
:
?
}
"
n
)
}
}
fn
fmt_subtree
<
F
N
:
TNode
>
(
f
:
&
mut
fmt
:
:
Formatter
stringify
:
&
F
n
:
N
indent
:
u32
)
-
>
fmt
:
:
Result
where
F
:
Fn
(
&
mut
fmt
:
:
Formatter
N
)
-
>
fmt
:
:
Result
{
for
_
in
0
.
.
indent
{
write
!
(
f
"
"
)
?
;
}
stringify
(
f
n
)
?
;
for
kid
in
n
.
traversal_children
(
)
{
writeln
!
(
f
"
"
)
?
;
fmt_subtree
(
f
stringify
kid
indent
+
1
)
?
;
}
Ok
(
(
)
)
}
pub
unsafe
fn
raw_note_descendants
<
E
B
>
(
element
:
E
)
-
>
bool
where
E
:
TElement
B
:
DescendantsBit
<
E
>
{
debug_assert
!
(
!
thread_state
:
:
get
(
)
.
is_worker
(
)
)
;
debug_assert
!
(
element
.
get_data
(
)
.
is_some
(
)
"
You
should
ensure
you
only
flag
styled
elements
"
)
;
let
mut
curr
=
Some
(
element
)
;
while
let
Some
(
el
)
=
curr
{
if
B
:
:
has
(
el
)
{
break
;
}
B
:
:
set
(
el
)
;
curr
=
el
.
traversal_parent
(
)
;
}
if
cfg
!
(
feature
=
"
gecko
"
)
{
debug_assert
!
(
element
.
descendants_bit_is_propagated
:
:
<
B
>
(
)
)
;
}
curr
.
is_none
(
)
}
pub
trait
PresentationalHintsSynthesizer
{
fn
synthesize_presentational_hints_for_legacy_attributes
<
V
>
(
&
self
visited_handling
:
VisitedHandlingMode
hints
:
&
mut
V
)
where
V
:
Push
<
ApplicableDeclarationBlock
>
;
}
pub
trait
TElement
:
Eq
+
PartialEq
+
Debug
+
Hash
+
Sized
+
Copy
+
Clone
+
ElementExt
+
PresentationalHintsSynthesizer
{
type
ConcreteNode
:
TNode
<
ConcreteElement
=
Self
>
;
type
FontMetricsProvider
:
FontMetricsProvider
+
Send
;
fn
as_node
(
&
self
)
-
>
Self
:
:
ConcreteNode
;
fn
owner_doc_matches_for_testing
(
&
self
_
:
&
Device
)
-
>
bool
{
true
}
fn
depth
(
&
self
)
-
>
usize
{
let
mut
depth
=
0
;
let
mut
curr
=
*
self
;
while
let
Some
(
parent
)
=
curr
.
traversal_parent
(
)
{
depth
+
=
1
;
curr
=
parent
;
}
depth
}
fn
traversal_parent
(
&
self
)
-
>
Option
<
Self
>
{
self
.
as_node
(
)
.
traversal_parent
(
)
}
fn
inheritance_parent
(
&
self
)
-
>
Option
<
Self
>
{
self
.
parent_element
(
)
}
fn
before_pseudo_element
(
&
self
)
-
>
Option
<
Self
>
{
None
}
fn
after_pseudo_element
(
&
self
)
-
>
Option
<
Self
>
{
None
}
fn
each_anonymous_content_child
<
F
>
(
&
self
_f
:
F
)
where
F
:
FnMut
(
Self
)
{
}
fn
closest_non_native_anonymous_ancestor
(
&
self
)
-
>
Option
<
Self
>
{
unreachable
!
(
"
Servo
doesn
'
t
know
about
NAC
"
)
;
}
fn
style_attribute
(
&
self
)
-
>
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
;
fn
unset_dirty_style_attribute
(
&
self
)
{
}
fn
get_smil_override
(
&
self
)
-
>
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
{
None
}
fn
get_animation_rule_by_cascade
(
&
self
_cascade_level
:
CascadeLevel
)
-
>
Option
<
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
{
None
}
fn
get_animation_rules
(
&
self
)
-
>
AnimationRules
{
if
!
self
.
may_have_animations
(
)
{
return
AnimationRules
(
None
None
)
}
AnimationRules
(
self
.
get_animation_rule
(
)
self
.
get_transition_rule
(
)
)
}
fn
get_animation_rule
(
&
self
)
-
>
Option
<
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
{
None
}
fn
get_transition_rule
(
&
self
)
-
>
Option
<
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
{
None
}
fn
get_state
(
&
self
)
-
>
ElementState
;
fn
has_attr
(
&
self
namespace
:
&
Namespace
attr
:
&
LocalName
)
-
>
bool
;
fn
get_id
(
&
self
)
-
>
Option
<
Atom
>
;
fn
each_class
<
F
>
(
&
self
callback
:
F
)
where
F
:
FnMut
(
&
Atom
)
;
fn
existing_style_for_restyle_damage
<
'
a
>
(
&
'
a
self
current_computed_values
:
&
'
a
ComputedValues
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
'
a
PreExistingComputedValues
>
;
fn
may_generate_pseudo
(
&
self
pseudo
:
&
PseudoElement
_primary_style
:
&
ComputedValues
)
-
>
bool
{
debug_assert
!
(
pseudo
.
is_eager
(
)
"
Someone
called
may_generate_pseudo
with
a
non
-
eager
pseudo
.
"
)
;
true
}
fn
has_dirty_descendants
(
&
self
)
-
>
bool
;
fn
has_snapshot
(
&
self
)
-
>
bool
;
fn
handled_snapshot
(
&
self
)
-
>
bool
;
unsafe
fn
set_handled_snapshot
(
&
self
)
;
fn
has_current_styles
(
&
self
data
:
&
ElementData
)
-
>
bool
{
if
self
.
has_snapshot
(
)
&
&
!
self
.
handled_snapshot
(
)
{
return
false
;
}
data
.
has_styles
(
)
&
&
!
data
.
has_invalidations
(
)
}
fn
has_current_styles_for_traversal
(
&
self
data
:
&
ElementData
traversal_flags
:
TraversalFlags
)
-
>
bool
{
if
traversal_flags
.
for_animation_only
(
)
{
return
data
.
has_styles
(
)
&
&
!
data
.
restyle
.
hint
.
has_animation_hint_or_recascade
(
)
;
}
if
self
.
has_snapshot
(
)
&
&
!
self
.
handled_snapshot
(
)
{
return
false
;
}
data
.
has_styles
(
)
&
&
!
data
.
has_invalidations
(
)
}
unsafe
fn
note_descendants
<
B
:
DescendantsBit
<
Self
>
>
(
&
self
)
;
unsafe
fn
set_dirty_descendants
(
&
self
)
;
fn
descendants_bit_is_propagated
<
B
:
DescendantsBit
<
Self
>
>
(
&
self
)
-
>
bool
{
let
mut
current
=
Some
(
*
self
)
;
while
let
Some
(
el
)
=
current
{
if
!
B
:
:
has
(
el
)
{
return
false
;
}
current
=
el
.
traversal_parent
(
)
;
}
true
}
unsafe
fn
unset_dirty_descendants
(
&
self
)
;
fn
has_animation_only_dirty_descendants
(
&
self
)
-
>
bool
{
false
}
unsafe
fn
set_animation_only_dirty_descendants
(
&
self
)
{
}
unsafe
fn
unset_animation_only_dirty_descendants
(
&
self
)
{
}
fn
is_visited_link
(
&
self
)
-
>
bool
{
false
}
fn
is_native_anonymous
(
&
self
)
-
>
bool
{
false
}
fn
implemented_pseudo_element
(
&
self
)
-
>
Option
<
PseudoElement
>
{
None
}
fn
store_children_to_process
(
&
self
n
:
isize
)
;
fn
did_process_child
(
&
self
)
-
>
isize
;
unsafe
fn
ensure_data
(
&
self
)
-
>
AtomicRefMut
<
ElementData
>
;
unsafe
fn
clear_data
(
&
self
)
;
fn
get_data
(
&
self
)
-
>
Option
<
&
AtomicRefCell
<
ElementData
>
>
;
fn
borrow_data
(
&
self
)
-
>
Option
<
AtomicRef
<
ElementData
>
>
{
self
.
get_data
(
)
.
map
(
|
x
|
x
.
borrow
(
)
)
}
fn
mutate_data
(
&
self
)
-
>
Option
<
AtomicRefMut
<
ElementData
>
>
{
self
.
get_data
(
)
.
map
(
|
x
|
x
.
borrow_mut
(
)
)
}
fn
skip_root_and_item_based_display_fixup
(
&
self
)
-
>
bool
;
unsafe
fn
set_selector_flags
(
&
self
flags
:
ElementSelectorFlags
)
;
fn
has_selector_flags
(
&
self
flags
:
ElementSelectorFlags
)
-
>
bool
;
fn
may_have_animations
(
&
self
)
-
>
bool
{
false
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
update_animations
(
&
self
before_change_style
:
Option
<
Arc
<
ComputedValues
>
>
tasks
:
UpdateAnimationsTasks
)
;
fn
has_animations
(
&
self
)
-
>
bool
;
fn
has_css_animations
(
&
self
)
-
>
bool
;
fn
has_css_transitions
(
&
self
)
-
>
bool
;
fn
has_animation_restyle_hints
(
&
self
)
-
>
bool
{
let
data
=
match
self
.
borrow_data
(
)
{
Some
(
d
)
=
>
d
None
=
>
return
false
}
;
return
data
.
restyle
.
hint
.
has_animation_hint
(
)
}
fn
xbl_binding_anonymous_content
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteNode
>
{
None
}
fn
rule_hash_target
(
&
self
)
-
>
Self
{
let
is_implemented_pseudo
=
self
.
implemented_pseudo_element
(
)
.
is_some
(
)
;
if
is_implemented_pseudo
{
self
.
closest_non_native_anonymous_ancestor
(
)
.
unwrap
(
)
}
else
{
*
self
}
}
fn
each_xbl_stylist
<
F
>
(
&
self
_
:
F
)
-
>
bool
where
F
:
FnMut
(
&
Stylist
)
{
false
}
fn
get_declarations_from_xbl_bindings
<
V
>
(
&
self
pseudo_element
:
Option
<
&
PseudoElement
>
applicable_declarations
:
&
mut
V
)
-
>
bool
where
V
:
Push
<
ApplicableDeclarationBlock
>
+
VecLike
<
ApplicableDeclarationBlock
>
{
self
.
each_xbl_stylist
(
|
stylist
|
{
stylist
.
push_applicable_declarations_as_xbl_only_stylist
(
self
pseudo_element
applicable_declarations
)
;
}
)
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
get_css_transitions_info
(
&
self
)
-
>
HashMap
<
TransitionProperty
Arc
<
AnimationValue
>
>
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
might_need_transitions_update
(
&
self
old_values
:
Option
<
&
ComputedValues
>
new_values
:
&
ComputedValues
)
-
>
bool
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
needs_transitions_update
(
&
self
before_change_style
:
&
ComputedValues
after_change_style
:
&
ComputedValues
)
-
>
bool
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
needs_transitions_update_per_property
(
&
self
property
:
&
TransitionProperty
combined_duration
:
f32
before_change_style
:
&
ComputedValues
after_change_style
:
&
ComputedValues
existing_transitions
:
&
HashMap
<
TransitionProperty
Arc
<
AnimationValue
>
>
)
-
>
bool
;
fn
lang_attr
(
&
self
)
-
>
Option
<
AttrValue
>
;
fn
match_element_lang
(
&
self
override_lang
:
Option
<
Option
<
AttrValue
>
>
value
:
&
PseudoClassStringArg
)
-
>
bool
;
}
pub
trait
DescendantsBit
<
E
:
TElement
>
{
fn
has
(
el
:
E
)
-
>
bool
;
unsafe
fn
set
(
el
:
E
)
;
}
pub
struct
DirtyDescendants
;
impl
<
E
:
TElement
>
DescendantsBit
<
E
>
for
DirtyDescendants
{
fn
has
(
el
:
E
)
-
>
bool
{
el
.
has_dirty_descendants
(
)
}
unsafe
fn
set
(
el
:
E
)
{
el
.
set_dirty_descendants
(
)
;
}
}
pub
struct
AnimationOnlyDirtyDescendants
;
impl
<
E
:
TElement
>
DescendantsBit
<
E
>
for
AnimationOnlyDirtyDescendants
{
fn
has
(
el
:
E
)
-
>
bool
{
el
.
has_animation_only_dirty_descendants
(
)
}
unsafe
fn
set
(
el
:
E
)
{
el
.
set_animation_only_dirty_descendants
(
)
;
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
SendNode
<
N
:
TNode
>
(
N
)
;
unsafe
impl
<
N
:
TNode
>
Send
for
SendNode
<
N
>
{
}
impl
<
N
:
TNode
>
SendNode
<
N
>
{
pub
unsafe
fn
new
(
node
:
N
)
-
>
Self
{
SendNode
(
node
)
}
}
impl
<
N
:
TNode
>
Deref
for
SendNode
<
N
>
{
type
Target
=
N
;
fn
deref
(
&
self
)
-
>
&
N
{
&
self
.
0
}
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
pub
struct
SendElement
<
E
:
TElement
>
(
E
)
;
unsafe
impl
<
E
:
TElement
>
Send
for
SendElement
<
E
>
{
}
impl
<
E
:
TElement
>
SendElement
<
E
>
{
pub
unsafe
fn
new
(
el
:
E
)
-
>
Self
{
SendElement
(
el
)
}
}
impl
<
E
:
TElement
>
Deref
for
SendElement
<
E
>
{
type
Target
=
E
;
fn
deref
(
&
self
)
-
>
&
E
{
&
self
.
0
}
}
