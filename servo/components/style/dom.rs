#
!
[
allow
(
unsafe_code
)
]
#
!
[
deny
(
missing_docs
)
]
use
{
Atom
Namespace
LocalName
}
;
use
atomic_refcell
:
:
{
AtomicRef
AtomicRefCell
AtomicRefMut
}
;
use
data
:
:
ElementData
;
use
element_state
:
:
ElementState
;
use
parking_lot
:
:
RwLock
;
use
properties
:
:
{
ComputedValues
PropertyDeclarationBlock
}
;
use
selector_parser
:
:
{
ElementExt
PreExistingComputedValues
PseudoElement
}
;
use
selectors
:
:
matching
:
:
ElementSelectorFlags
;
use
sink
:
:
Push
;
use
std
:
:
fmt
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
sync
:
:
Arc
;
use
stylist
:
:
ApplicableDeclarationBlock
;
pub
use
style_traits
:
:
UnsafeNode
;
#
[
derive
(
Clone
PartialEq
Copy
Debug
Hash
Eq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
Deserialize
Serialize
)
)
]
pub
struct
OpaqueNode
(
pub
usize
)
;
impl
OpaqueNode
{
#
[
inline
]
pub
fn
id
(
&
self
)
-
>
usize
{
self
.
0
}
}
pub
trait
NodeInfo
{
fn
is_element
(
&
self
)
-
>
bool
;
fn
is_text_node
(
&
self
)
-
>
bool
;
fn
needs_layout
(
&
self
)
-
>
bool
{
self
.
is_element
(
)
|
|
self
.
is_text_node
(
)
}
}
pub
struct
LayoutIterator
<
T
>
(
pub
T
)
;
impl
<
T
I
>
Iterator
for
LayoutIterator
<
T
>
where
T
:
Iterator
<
Item
=
I
>
I
:
NodeInfo
{
type
Item
=
I
;
fn
next
(
&
mut
self
)
-
>
Option
<
I
>
{
loop
{
let
n
=
self
.
0
.
next
(
)
;
if
n
.
is_none
(
)
|
|
n
.
as_ref
(
)
.
unwrap
(
)
.
needs_layout
(
)
{
return
n
}
}
}
}
pub
trait
TNode
:
Sized
+
Copy
+
Clone
+
Debug
+
NodeInfo
{
type
ConcreteElement
:
TElement
<
ConcreteNode
=
Self
>
;
type
ConcreteChildrenIterator
:
Iterator
<
Item
=
Self
>
;
fn
to_unsafe
(
&
self
)
-
>
UnsafeNode
;
unsafe
fn
from_unsafe
(
n
:
&
UnsafeNode
)
-
>
Self
;
fn
children
(
self
)
-
>
LayoutIterator
<
Self
:
:
ConcreteChildrenIterator
>
;
fn
opaque
(
&
self
)
-
>
OpaqueNode
;
fn
parent_element
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteElement
>
{
self
.
parent_node
(
)
.
and_then
(
|
n
|
n
.
as_element
(
)
)
}
fn
debug_id
(
self
)
-
>
usize
;
fn
as_element
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteElement
>
;
fn
needs_dirty_on_viewport_size_changed
(
&
self
)
-
>
bool
;
unsafe
fn
set_dirty_on_viewport_size_changed
(
&
self
)
;
fn
can_be_fragmented
(
&
self
)
-
>
bool
;
unsafe
fn
set_can_be_fragmented
(
&
self
value
:
bool
)
;
fn
parent_node
(
&
self
)
-
>
Option
<
Self
>
;
fn
is_in_doc
(
&
self
)
-
>
bool
;
}
pub
struct
ShowData
<
N
:
TNode
>
(
pub
N
)
;
impl
<
N
:
TNode
>
Debug
for
ShowData
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt_with_data
(
f
self
.
0
)
}
}
pub
struct
ShowDataAndPrimaryValues
<
N
:
TNode
>
(
pub
N
)
;
impl
<
N
:
TNode
>
Debug
for
ShowDataAndPrimaryValues
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt_with_data_and_primary_values
(
f
self
.
0
)
}
}
pub
struct
ShowSubtree
<
N
:
TNode
>
(
pub
N
)
;
impl
<
N
:
TNode
>
Debug
for
ShowSubtree
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
try
!
(
writeln
!
(
f
"
DOM
Subtree
:
"
)
)
;
fmt_subtree
(
f
&
|
f
n
|
write
!
(
f
"
{
:
?
}
"
n
)
self
.
0
1
)
}
}
pub
struct
ShowSubtreeData
<
N
:
TNode
>
(
pub
N
)
;
impl
<
N
:
TNode
>
Debug
for
ShowSubtreeData
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
try
!
(
writeln
!
(
f
"
DOM
Subtree
:
"
)
)
;
fmt_subtree
(
f
&
|
f
n
|
fmt_with_data
(
f
n
)
self
.
0
1
)
}
}
pub
struct
ShowSubtreeDataAndPrimaryValues
<
N
:
TNode
>
(
pub
N
)
;
impl
<
N
:
TNode
>
Debug
for
ShowSubtreeDataAndPrimaryValues
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
try
!
(
writeln
!
(
f
"
DOM
Subtree
:
"
)
)
;
fmt_subtree
(
f
&
|
f
n
|
fmt_with_data_and_primary_values
(
f
n
)
self
.
0
1
)
}
}
fn
fmt_with_data
<
N
:
TNode
>
(
f
:
&
mut
fmt
:
:
Formatter
n
:
N
)
-
>
fmt
:
:
Result
{
if
let
Some
(
el
)
=
n
.
as_element
(
)
{
write
!
(
f
"
{
:
?
}
dd
=
{
}
data
=
{
:
?
}
"
el
el
.
has_dirty_descendants
(
)
el
.
borrow_data
(
)
)
}
else
{
write
!
(
f
"
{
:
?
}
"
n
)
}
}
fn
fmt_with_data_and_primary_values
<
N
:
TNode
>
(
f
:
&
mut
fmt
:
:
Formatter
n
:
N
)
-
>
fmt
:
:
Result
{
if
let
Some
(
el
)
=
n
.
as_element
(
)
{
let
dd
=
el
.
has_dirty_descendants
(
)
;
let
data
=
el
.
borrow_data
(
)
;
let
styles
=
data
.
as_ref
(
)
.
and_then
(
|
d
|
d
.
get_styles
(
)
)
;
let
values
=
styles
.
map
(
|
s
|
s
.
primary
.
values
(
)
)
;
write
!
(
f
"
{
:
?
}
dd
=
{
}
data
=
{
:
?
}
values
=
{
:
?
}
"
el
dd
&
data
values
)
}
else
{
write
!
(
f
"
{
:
?
}
"
n
)
}
}
fn
fmt_subtree
<
F
N
:
TNode
>
(
f
:
&
mut
fmt
:
:
Formatter
stringify
:
&
F
n
:
N
indent
:
u32
)
-
>
fmt
:
:
Result
where
F
:
Fn
(
&
mut
fmt
:
:
Formatter
N
)
-
>
fmt
:
:
Result
{
for
_
in
0
.
.
indent
{
try
!
(
write
!
(
f
"
"
)
)
;
}
try
!
(
stringify
(
f
n
)
)
;
for
kid
in
n
.
children
(
)
{
try
!
(
writeln
!
(
f
"
"
)
)
;
try
!
(
fmt_subtree
(
f
stringify
kid
indent
+
1
)
)
;
}
Ok
(
(
)
)
}
pub
trait
PresentationalHintsSynthetizer
{
fn
synthesize_presentational_hints_for_legacy_attributes
<
V
>
(
&
self
hints
:
&
mut
V
)
where
V
:
Push
<
ApplicableDeclarationBlock
>
;
}
pub
struct
AnimationRules
(
pub
Option
<
Arc
<
RwLock
<
PropertyDeclarationBlock
>
>
>
pub
Option
<
Arc
<
RwLock
<
PropertyDeclarationBlock
>
>
>
)
;
pub
trait
TElement
:
PartialEq
+
Debug
+
Sized
+
Copy
+
Clone
+
ElementExt
+
PresentationalHintsSynthetizer
{
type
ConcreteNode
:
TNode
<
ConcreteElement
=
Self
>
;
fn
as_node
(
&
self
)
-
>
Self
:
:
ConcreteNode
;
fn
layout_parent_element
(
self
reflow_root
:
OpaqueNode
)
-
>
Option
<
Self
>
{
if
self
.
as_node
(
)
.
opaque
(
)
=
=
reflow_root
{
None
}
else
{
self
.
parent_element
(
)
}
}
fn
style_attribute
(
&
self
)
-
>
Option
<
&
Arc
<
RwLock
<
PropertyDeclarationBlock
>
>
>
;
fn
get_animation_rules
(
&
self
_pseudo
:
Option
<
&
PseudoElement
>
)
-
>
AnimationRules
{
AnimationRules
(
None
None
)
}
fn
get_animation_rule
(
&
self
_pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
Arc
<
RwLock
<
PropertyDeclarationBlock
>
>
>
{
None
}
fn
get_transition_rule
(
&
self
_pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
Arc
<
RwLock
<
PropertyDeclarationBlock
>
>
>
{
None
}
fn
get_state
(
&
self
)
-
>
ElementState
;
fn
has_attr
(
&
self
namespace
:
&
Namespace
attr
:
&
LocalName
)
-
>
bool
;
fn
attr_equals
(
&
self
namespace
:
&
Namespace
attr
:
&
LocalName
value
:
&
Atom
)
-
>
bool
;
fn
existing_style_for_restyle_damage
<
'
a
>
(
&
'
a
self
current_computed_values
:
&
'
a
Arc
<
ComputedValues
>
pseudo
:
Option
<
&
PseudoElement
>
)
-
>
Option
<
&
'
a
PreExistingComputedValues
>
;
fn
has_dirty_descendants
(
&
self
)
-
>
bool
;
unsafe
fn
set_dirty_descendants
(
&
self
)
;
unsafe
fn
unset_dirty_descendants
(
&
self
)
;
fn
store_children_to_process
(
&
self
n
:
isize
)
;
fn
did_process_child
(
&
self
)
-
>
isize
;
fn
get_data
(
&
self
)
-
>
Option
<
&
AtomicRefCell
<
ElementData
>
>
;
fn
borrow_data
(
&
self
)
-
>
Option
<
AtomicRef
<
ElementData
>
>
{
self
.
get_data
(
)
.
map
(
|
x
|
x
.
borrow
(
)
)
}
fn
mutate_data
(
&
self
)
-
>
Option
<
AtomicRefMut
<
ElementData
>
>
{
self
.
get_data
(
)
.
map
(
|
x
|
x
.
borrow_mut
(
)
)
}
fn
skip_root_and_item_based_display_fixup
(
&
self
)
-
>
bool
;
unsafe
fn
set_selector_flags
(
&
self
flags
:
ElementSelectorFlags
)
;
fn
has_selector_flags
(
&
self
flags
:
ElementSelectorFlags
)
-
>
bool
;
fn
update_animations
(
&
self
_pseudo
:
Option
<
&
PseudoElement
>
)
;
fn
has_css_animations
(
&
self
_pseudo
:
Option
<
&
PseudoElement
>
)
-
>
bool
;
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
SendNode
<
N
:
TNode
>
(
N
)
;
unsafe
impl
<
N
:
TNode
>
Send
for
SendNode
<
N
>
{
}
impl
<
N
:
TNode
>
SendNode
<
N
>
{
pub
unsafe
fn
new
(
node
:
N
)
-
>
Self
{
SendNode
(
node
)
}
}
impl
<
N
:
TNode
>
Deref
for
SendNode
<
N
>
{
type
Target
=
N
;
fn
deref
(
&
self
)
-
>
&
N
{
&
self
.
0
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
SendElement
<
E
:
TElement
>
(
E
)
;
unsafe
impl
<
E
:
TElement
>
Send
for
SendElement
<
E
>
{
}
impl
<
E
:
TElement
>
SendElement
<
E
>
{
pub
unsafe
fn
new
(
el
:
E
)
-
>
Self
{
SendElement
(
el
)
}
}
impl
<
E
:
TElement
>
Deref
for
SendElement
<
E
>
{
type
Target
=
E
;
fn
deref
(
&
self
)
-
>
&
E
{
&
self
.
0
}
}
