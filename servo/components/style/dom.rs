#
!
[
allow
(
unsafe_code
)
]
#
!
[
deny
(
missing_docs
)
]
use
crate
:
:
applicable_declarations
:
:
ApplicableDeclarationBlock
;
use
crate
:
:
context
:
:
SharedStyleContext
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
crate
:
:
context
:
:
{
PostAnimationTasks
UpdateAnimationsTasks
}
;
use
crate
:
:
data
:
:
ElementData
;
use
crate
:
:
media_queries
:
:
Device
;
use
crate
:
:
properties
:
:
{
AnimationDeclarations
ComputedValues
PropertyDeclarationBlock
}
;
use
crate
:
:
selector_parser
:
:
{
AttrValue
Lang
PseudoElement
SelectorImpl
}
;
use
crate
:
:
shared_lock
:
:
{
Locked
SharedRwLock
}
;
use
crate
:
:
stylist
:
:
CascadeData
;
use
crate
:
:
traversal_flags
:
:
TraversalFlags
;
use
crate
:
:
values
:
:
AtomIdent
;
use
crate
:
:
{
LocalName
Namespace
WeakAtom
}
;
use
atomic_refcell
:
:
{
AtomicRef
AtomicRefMut
}
;
use
dom
:
:
ElementState
;
use
selectors
:
:
matching
:
:
{
QuirksMode
VisitedHandlingMode
}
;
use
selectors
:
:
sink
:
:
Push
;
use
selectors
:
:
Element
as
SelectorsElement
;
use
servo_arc
:
:
{
Arc
ArcBorrow
}
;
use
std
:
:
fmt
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
ops
:
:
Deref
;
pub
use
style_traits
:
:
dom
:
:
OpaqueNode
;
pub
trait
NodeInfo
{
fn
is_element
(
&
self
)
-
>
bool
;
fn
is_text_node
(
&
self
)
-
>
bool
;
}
pub
struct
LayoutIterator
<
T
>
(
pub
T
)
;
impl
<
T
N
>
Iterator
for
LayoutIterator
<
T
>
where
T
:
Iterator
<
Item
=
N
>
N
:
NodeInfo
{
type
Item
=
N
;
fn
next
(
&
mut
self
)
-
>
Option
<
N
>
{
loop
{
let
n
=
self
.
0
.
next
(
)
?
;
if
n
.
is_text_node
(
)
|
|
n
.
is_element
(
)
{
return
Some
(
n
)
;
}
}
}
}
pub
struct
DomChildren
<
N
>
(
Option
<
N
>
)
;
impl
<
N
>
Iterator
for
DomChildren
<
N
>
where
N
:
TNode
{
type
Item
=
N
;
fn
next
(
&
mut
self
)
-
>
Option
<
N
>
{
let
n
=
self
.
0
.
take
(
)
?
;
self
.
0
=
n
.
next_sibling
(
)
;
Some
(
n
)
}
}
pub
struct
DomDescendants
<
N
>
{
previous
:
Option
<
N
>
scope
:
N
}
impl
<
N
>
Iterator
for
DomDescendants
<
N
>
where
N
:
TNode
{
type
Item
=
N
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
N
>
{
let
prev
=
self
.
previous
.
take
(
)
?
;
self
.
previous
=
prev
.
next_in_preorder
(
Some
(
self
.
scope
)
)
;
self
.
previous
}
}
pub
trait
TDocument
:
Sized
+
Copy
+
Clone
{
type
ConcreteNode
:
TNode
<
ConcreteDocument
=
Self
>
;
fn
as_node
(
&
self
)
-
>
Self
:
:
ConcreteNode
;
fn
is_html_document
(
&
self
)
-
>
bool
;
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
;
fn
elements_with_id
<
'
a
>
(
&
self
_id
:
&
AtomIdent
)
-
>
Result
<
&
'
a
[
<
Self
:
:
ConcreteNode
as
TNode
>
:
:
ConcreteElement
]
(
)
>
where
Self
:
'
a
{
Err
(
(
)
)
}
fn
shared_lock
(
&
self
)
-
>
&
SharedRwLock
;
}
pub
trait
TNode
:
Sized
+
Copy
+
Clone
+
Debug
+
NodeInfo
+
PartialEq
{
type
ConcreteElement
:
TElement
<
ConcreteNode
=
Self
>
;
type
ConcreteDocument
:
TDocument
<
ConcreteNode
=
Self
>
;
type
ConcreteShadowRoot
:
TShadowRoot
<
ConcreteNode
=
Self
>
;
fn
parent_node
(
&
self
)
-
>
Option
<
Self
>
;
fn
first_child
(
&
self
)
-
>
Option
<
Self
>
;
fn
last_child
(
&
self
)
-
>
Option
<
Self
>
;
fn
prev_sibling
(
&
self
)
-
>
Option
<
Self
>
;
fn
next_sibling
(
&
self
)
-
>
Option
<
Self
>
;
fn
owner_doc
(
&
self
)
-
>
Self
:
:
ConcreteDocument
;
fn
dom_children
(
&
self
)
-
>
DomChildren
<
Self
>
{
DomChildren
(
self
.
first_child
(
)
)
}
fn
is_in_document
(
&
self
)
-
>
bool
;
fn
dom_descendants
(
&
self
)
-
>
DomDescendants
<
Self
>
{
DomDescendants
{
previous
:
Some
(
*
self
)
scope
:
*
self
}
}
#
[
inline
]
fn
next_in_preorder
(
&
self
scoped_to
:
Option
<
Self
>
)
-
>
Option
<
Self
>
{
if
let
Some
(
c
)
=
self
.
first_child
(
)
{
return
Some
(
c
)
;
}
let
mut
current
=
Some
(
*
self
)
;
loop
{
if
current
=
=
scoped_to
{
return
None
;
}
debug_assert
!
(
current
.
is_some
(
)
"
not
a
descendant
of
the
scope
?
"
)
;
if
let
Some
(
s
)
=
current
?
.
next_sibling
(
)
{
return
Some
(
s
)
;
}
current
=
current
?
.
parent_node
(
)
;
}
}
fn
traversal_parent
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteElement
>
;
fn
parent_element
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteElement
>
{
self
.
parent_node
(
)
.
and_then
(
|
n
|
n
.
as_element
(
)
)
}
fn
opaque
(
&
self
)
-
>
OpaqueNode
;
fn
debug_id
(
self
)
-
>
usize
;
fn
as_element
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteElement
>
;
fn
as_document
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteDocument
>
;
fn
as_shadow_root
(
&
self
)
-
>
Option
<
Self
:
:
ConcreteShadowRoot
>
;
}
pub
struct
ShowSubtree
<
N
:
TNode
>
(
pub
N
)
;
impl
<
N
:
TNode
>
Debug
for
ShowSubtree
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
DOM
Subtree
:
"
)
?
;
fmt_subtree
(
f
&
|
f
n
|
write
!
(
f
"
{
:
?
}
"
n
)
self
.
0
1
)
}
}
pub
struct
ShowSubtreeData
<
N
:
TNode
>
(
pub
N
)
;
impl
<
N
:
TNode
>
Debug
for
ShowSubtreeData
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
DOM
Subtree
:
"
)
?
;
fmt_subtree
(
f
&
|
f
n
|
fmt_with_data
(
f
n
)
self
.
0
1
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
pub
struct
ShowSubtreeDataAndPrimaryValues
<
N
:
TNode
>
(
pub
N
)
;
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
<
N
:
TNode
>
Debug
for
ShowSubtreeDataAndPrimaryValues
<
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
DOM
Subtree
:
"
)
?
;
fmt_subtree
(
f
&
|
f
n
|
fmt_with_data_and_primary_values
(
f
n
)
self
.
0
1
)
}
}
fn
fmt_with_data
<
N
:
TNode
>
(
f
:
&
mut
fmt
:
:
Formatter
n
:
N
)
-
>
fmt
:
:
Result
{
if
let
Some
(
el
)
=
n
.
as_element
(
)
{
write
!
(
f
"
{
:
?
}
dd
=
{
}
aodd
=
{
}
data
=
{
:
?
}
"
el
el
.
has_dirty_descendants
(
)
el
.
has_animation_only_dirty_descendants
(
)
el
.
borrow_data
(
)
)
}
else
{
write
!
(
f
"
{
:
?
}
"
n
)
}
}
#
[
cfg
(
feature
=
"
servo
"
)
]
fn
fmt_with_data_and_primary_values
<
N
:
TNode
>
(
f
:
&
mut
fmt
:
:
Formatter
n
:
N
)
-
>
fmt
:
:
Result
{
if
let
Some
(
el
)
=
n
.
as_element
(
)
{
let
dd
=
el
.
has_dirty_descendants
(
)
;
let
aodd
=
el
.
has_animation_only_dirty_descendants
(
)
;
let
data
=
el
.
borrow_data
(
)
;
let
values
=
data
.
as_ref
(
)
.
and_then
(
|
d
|
d
.
styles
.
get_primary
(
)
)
;
write
!
(
f
"
{
:
?
}
dd
=
{
}
aodd
=
{
}
data
=
{
:
?
}
values
=
{
:
?
}
"
el
dd
aodd
&
data
values
)
}
else
{
write
!
(
f
"
{
:
?
}
"
n
)
}
}
fn
fmt_subtree
<
F
N
:
TNode
>
(
f
:
&
mut
fmt
:
:
Formatter
stringify
:
&
F
n
:
N
indent
:
u32
)
-
>
fmt
:
:
Result
where
F
:
Fn
(
&
mut
fmt
:
:
Formatter
N
)
-
>
fmt
:
:
Result
{
for
_
in
0
.
.
indent
{
write
!
(
f
"
"
)
?
;
}
stringify
(
f
n
)
?
;
if
let
Some
(
e
)
=
n
.
as_element
(
)
{
for
kid
in
e
.
traversal_children
(
)
{
writeln
!
(
f
"
"
)
?
;
fmt_subtree
(
f
stringify
kid
indent
+
1
)
?
;
}
}
Ok
(
(
)
)
}
pub
trait
TShadowRoot
:
Sized
+
Copy
+
Clone
+
Debug
+
PartialEq
{
type
ConcreteNode
:
TNode
<
ConcreteShadowRoot
=
Self
>
;
fn
as_node
(
&
self
)
-
>
Self
:
:
ConcreteNode
;
fn
host
(
&
self
)
-
>
<
Self
:
:
ConcreteNode
as
TNode
>
:
:
ConcreteElement
;
fn
style_data
<
'
a
>
(
&
self
)
-
>
Option
<
&
'
a
CascadeData
>
where
Self
:
'
a
;
fn
parts
<
'
a
>
(
&
self
)
-
>
&
[
<
Self
:
:
ConcreteNode
as
TNode
>
:
:
ConcreteElement
]
where
Self
:
'
a
{
&
[
]
}
fn
elements_with_id
<
'
a
>
(
&
self
_id
:
&
AtomIdent
)
-
>
Result
<
&
'
a
[
<
Self
:
:
ConcreteNode
as
TNode
>
:
:
ConcreteElement
]
(
)
>
where
Self
:
'
a
{
Err
(
(
)
)
}
}
pub
trait
TElement
:
Eq
+
PartialEq
+
Debug
+
Hash
+
Sized
+
Copy
+
Clone
+
SelectorsElement
<
Impl
=
SelectorImpl
>
{
type
ConcreteNode
:
TNode
<
ConcreteElement
=
Self
>
;
type
TraversalChildrenIterator
:
Iterator
<
Item
=
Self
:
:
ConcreteNode
>
;
fn
as_node
(
&
self
)
-
>
Self
:
:
ConcreteNode
;
fn
owner_doc_matches_for_testing
(
&
self
_
:
&
Device
)
-
>
bool
{
true
}
fn
matches_user_and_author_rules
(
&
self
)
-
>
bool
{
true
}
fn
depth
(
&
self
)
-
>
usize
{
let
mut
depth
=
0
;
let
mut
curr
=
*
self
;
while
let
Some
(
parent
)
=
curr
.
traversal_parent
(
)
{
depth
+
=
1
;
curr
=
parent
;
}
depth
}
fn
traversal_parent
(
&
self
)
-
>
Option
<
Self
>
{
self
.
as_node
(
)
.
traversal_parent
(
)
}
fn
traversal_children
(
&
self
)
-
>
LayoutIterator
<
Self
:
:
TraversalChildrenIterator
>
;
fn
inheritance_parent
(
&
self
)
-
>
Option
<
Self
>
{
self
.
parent_element
(
)
}
fn
before_pseudo_element
(
&
self
)
-
>
Option
<
Self
>
{
None
}
fn
after_pseudo_element
(
&
self
)
-
>
Option
<
Self
>
{
None
}
fn
marker_pseudo_element
(
&
self
)
-
>
Option
<
Self
>
{
None
}
fn
each_anonymous_content_child
<
F
>
(
&
self
_f
:
F
)
where
F
:
FnMut
(
Self
)
{
}
fn
is_html_element
(
&
self
)
-
>
bool
;
fn
is_mathml_element
(
&
self
)
-
>
bool
;
fn
is_svg_element
(
&
self
)
-
>
bool
;
fn
is_xul_element
(
&
self
)
-
>
bool
{
false
}
fn
slotted_nodes
(
&
self
)
-
>
&
[
Self
:
:
ConcreteNode
]
{
&
[
]
}
fn
style_attribute
(
&
self
)
-
>
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
;
fn
unset_dirty_style_attribute
(
&
self
)
{
}
fn
smil_override
(
&
self
)
-
>
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
{
None
}
fn
animation_declarations
(
&
self
context
:
&
SharedStyleContext
)
-
>
AnimationDeclarations
{
if
!
self
.
may_have_animations
(
)
{
return
Default
:
:
default
(
)
;
}
AnimationDeclarations
{
animations
:
self
.
animation_rule
(
context
)
transitions
:
self
.
transition_rule
(
context
)
}
}
fn
animation_rule
(
&
self
_
:
&
SharedStyleContext
)
-
>
Option
<
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
;
fn
transition_rule
(
&
self
context
:
&
SharedStyleContext
)
-
>
Option
<
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
;
fn
state
(
&
self
)
-
>
ElementState
;
fn
has_attr
(
&
self
namespace
:
&
Namespace
attr
:
&
LocalName
)
-
>
bool
;
fn
has_part_attr
(
&
self
)
-
>
bool
;
fn
exports_any_part
(
&
self
)
-
>
bool
;
fn
id
(
&
self
)
-
>
Option
<
&
WeakAtom
>
;
fn
each_class
<
F
>
(
&
self
callback
:
F
)
where
F
:
FnMut
(
&
AtomIdent
)
;
fn
each_part
<
F
>
(
&
self
_callback
:
F
)
where
F
:
FnMut
(
&
AtomIdent
)
{
}
fn
each_attr_name
<
F
>
(
&
self
callback
:
F
)
where
F
:
FnMut
(
&
AtomIdent
)
;
fn
each_exported_part
<
F
>
(
&
self
_name
:
&
AtomIdent
_callback
:
F
)
where
F
:
FnMut
(
&
AtomIdent
)
{
}
fn
may_generate_pseudo
(
&
self
pseudo
:
&
PseudoElement
_primary_style
:
&
ComputedValues
)
-
>
bool
{
debug_assert
!
(
pseudo
.
is_eager
(
)
"
Someone
called
may_generate_pseudo
with
a
non
-
eager
pseudo
.
"
)
;
true
}
fn
has_dirty_descendants
(
&
self
)
-
>
bool
;
fn
has_snapshot
(
&
self
)
-
>
bool
;
fn
handled_snapshot
(
&
self
)
-
>
bool
;
unsafe
fn
set_handled_snapshot
(
&
self
)
;
fn
has_current_styles_for_traversal
(
&
self
data
:
&
ElementData
traversal_flags
:
TraversalFlags
)
-
>
bool
{
if
traversal_flags
.
for_animation_only
(
)
{
if
!
data
.
has_styles
(
)
{
return
false
;
}
if
!
data
.
hint
.
has_animation_hint_or_recascade
(
)
{
return
true
;
}
if
data
.
styles
.
is_display_none
(
)
&
&
data
.
hint
.
match_self
(
)
{
return
true
;
}
return
false
;
}
if
self
.
has_snapshot
(
)
&
&
!
self
.
handled_snapshot
(
)
{
return
false
;
}
data
.
has_styles
(
)
&
&
!
data
.
hint
.
has_non_animation_invalidations
(
)
}
fn
has_current_styles
(
&
self
data
:
&
ElementData
)
-
>
bool
{
if
self
.
has_snapshot
(
)
&
&
!
self
.
handled_snapshot
(
)
{
return
false
;
}
data
.
has_styles
(
)
&
&
!
data
.
hint
.
has_non_animation_invalidations
(
)
}
unsafe
fn
set_dirty_descendants
(
&
self
)
;
unsafe
fn
unset_dirty_descendants
(
&
self
)
;
fn
has_animation_only_dirty_descendants
(
&
self
)
-
>
bool
{
false
}
unsafe
fn
set_animation_only_dirty_descendants
(
&
self
)
{
}
unsafe
fn
unset_animation_only_dirty_descendants
(
&
self
)
{
}
unsafe
fn
clear_descendant_bits
(
&
self
)
{
self
.
unset_dirty_descendants
(
)
;
}
fn
is_visited_link
(
&
self
)
-
>
bool
{
false
}
fn
is_in_native_anonymous_subtree
(
&
self
)
-
>
bool
{
false
}
fn
implemented_pseudo_element
(
&
self
)
-
>
Option
<
PseudoElement
>
{
None
}
fn
store_children_to_process
(
&
self
n
:
isize
)
;
fn
did_process_child
(
&
self
)
-
>
isize
;
unsafe
fn
ensure_data
(
&
self
)
-
>
AtomicRefMut
<
ElementData
>
;
unsafe
fn
clear_data
(
&
self
)
;
fn
has_data
(
&
self
)
-
>
bool
;
fn
borrow_data
(
&
self
)
-
>
Option
<
AtomicRef
<
ElementData
>
>
;
fn
mutate_data
(
&
self
)
-
>
Option
<
AtomicRefMut
<
ElementData
>
>
;
fn
skip_item_display_fixup
(
&
self
)
-
>
bool
;
fn
may_have_animations
(
&
self
)
-
>
bool
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
update_animations
(
&
self
before_change_style
:
Option
<
Arc
<
ComputedValues
>
>
tasks
:
UpdateAnimationsTasks
)
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
process_post_animation
(
&
self
tasks
:
PostAnimationTasks
)
;
fn
has_animations
(
&
self
context
:
&
SharedStyleContext
)
-
>
bool
;
fn
has_css_animations
(
&
self
context
:
&
SharedStyleContext
pseudo_element
:
Option
<
PseudoElement
>
)
-
>
bool
;
fn
has_css_transitions
(
&
self
context
:
&
SharedStyleContext
pseudo_element
:
Option
<
PseudoElement
>
)
-
>
bool
;
fn
has_animation_restyle_hints
(
&
self
)
-
>
bool
{
let
data
=
match
self
.
borrow_data
(
)
{
Some
(
d
)
=
>
d
None
=
>
return
false
}
;
return
data
.
hint
.
has_animation_hint
(
)
;
}
fn
shadow_root
(
&
self
)
-
>
Option
<
<
Self
:
:
ConcreteNode
as
TNode
>
:
:
ConcreteShadowRoot
>
;
fn
containing_shadow
(
&
self
)
-
>
Option
<
<
Self
:
:
ConcreteNode
as
TNode
>
:
:
ConcreteShadowRoot
>
;
fn
rule_hash_target
(
&
self
)
-
>
Self
{
if
self
.
is_pseudo_element
(
)
{
self
.
pseudo_element_originating_element
(
)
.
expect
(
"
Trying
to
collect
rules
for
a
detached
pseudo
-
element
"
)
}
else
{
*
self
}
}
fn
each_applicable_non_document_style_rule_data
<
'
a
F
>
(
&
self
mut
f
:
F
)
-
>
bool
where
Self
:
'
a
F
:
FnMut
(
&
'
a
CascadeData
Self
)
{
use
crate
:
:
rule_collector
:
:
containing_shadow_ignoring_svg_use
;
let
target
=
self
.
rule_hash_target
(
)
;
if
!
target
.
matches_user_and_author_rules
(
)
{
return
false
;
}
let
mut
doc_rules_apply
=
true
;
if
let
Some
(
shadow
)
=
containing_shadow_ignoring_svg_use
(
target
)
{
doc_rules_apply
=
false
;
if
let
Some
(
data
)
=
shadow
.
style_data
(
)
{
f
(
data
shadow
.
host
(
)
)
;
}
}
if
let
Some
(
shadow
)
=
target
.
shadow_root
(
)
{
if
let
Some
(
data
)
=
shadow
.
style_data
(
)
{
f
(
data
shadow
.
host
(
)
)
;
}
}
let
mut
current
=
target
.
assigned_slot
(
)
;
while
let
Some
(
slot
)
=
current
{
let
shadow
=
slot
.
containing_shadow
(
)
.
unwrap
(
)
;
if
let
Some
(
data
)
=
shadow
.
style_data
(
)
{
if
data
.
any_slotted_rule
(
)
{
f
(
data
shadow
.
host
(
)
)
;
}
}
current
=
slot
.
assigned_slot
(
)
;
}
if
target
.
has_part_attr
(
)
{
if
let
Some
(
mut
inner_shadow
)
=
target
.
containing_shadow
(
)
{
loop
{
let
inner_shadow_host
=
inner_shadow
.
host
(
)
;
match
inner_shadow_host
.
containing_shadow
(
)
{
Some
(
shadow
)
=
>
{
if
let
Some
(
data
)
=
shadow
.
style_data
(
)
{
if
data
.
any_part_rule
(
)
{
f
(
data
shadow
.
host
(
)
)
}
}
if
!
inner_shadow_host
.
exports_any_part
(
)
{
break
;
}
inner_shadow
=
shadow
;
}
None
=
>
{
doc_rules_apply
=
true
;
break
;
}
}
}
}
}
doc_rules_apply
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
needs_transitions_update
(
&
self
before_change_style
:
&
ComputedValues
after_change_style
:
&
ComputedValues
)
-
>
bool
;
fn
lang_attr
(
&
self
)
-
>
Option
<
AttrValue
>
;
fn
match_element_lang
(
&
self
override_lang
:
Option
<
Option
<
AttrValue
>
>
value
:
&
Lang
)
-
>
bool
;
fn
is_html_document_body_element
(
&
self
)
-
>
bool
;
fn
synthesize_presentational_hints_for_legacy_attributes
<
V
>
(
&
self
visited_handling
:
VisitedHandlingMode
hints
:
&
mut
V
)
where
V
:
Push
<
ApplicableDeclarationBlock
>
;
fn
local_name
(
&
self
)
-
>
&
<
SelectorImpl
as
selectors
:
:
parser
:
:
SelectorImpl
>
:
:
BorrowedLocalName
;
fn
namespace
(
&
self
)
-
>
&
<
SelectorImpl
as
selectors
:
:
parser
:
:
SelectorImpl
>
:
:
BorrowedNamespaceUrl
;
fn
primary_box_size
(
&
self
)
-
>
euclid
:
:
default
:
:
Size2D
<
app_units
:
:
Au
>
;
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
SendNode
<
N
:
TNode
>
(
N
)
;
unsafe
impl
<
N
:
TNode
>
Send
for
SendNode
<
N
>
{
}
impl
<
N
:
TNode
>
SendNode
<
N
>
{
pub
unsafe
fn
new
(
node
:
N
)
-
>
Self
{
SendNode
(
node
)
}
}
impl
<
N
:
TNode
>
Deref
for
SendNode
<
N
>
{
type
Target
=
N
;
fn
deref
(
&
self
)
-
>
&
N
{
&
self
.
0
}
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
pub
struct
SendElement
<
E
:
TElement
>
(
E
)
;
unsafe
impl
<
E
:
TElement
>
Send
for
SendElement
<
E
>
{
}
impl
<
E
:
TElement
>
SendElement
<
E
>
{
pub
unsafe
fn
new
(
el
:
E
)
-
>
Self
{
SendElement
(
el
)
}
}
impl
<
E
:
TElement
>
Deref
for
SendElement
<
E
>
{
type
Target
=
E
;
fn
deref
(
&
self
)
-
>
&
E
{
&
self
.
0
}
}
