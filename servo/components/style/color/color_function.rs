use
crate
:
:
{
color
:
:
ColorFlags
values
:
:
normalize
}
;
use
cssparser
:
:
color
:
:
{
clamp_floor_256_f32
OPAQUE
}
;
use
super
:
:
{
component
:
:
ColorComponent
convert
:
:
normalize_hue
parsing
:
:
{
NumberOrAngle
NumberOrPercentage
}
AbsoluteColor
ColorSpace
}
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
pub
enum
ColorFunction
{
Rgb
(
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
)
Hsl
(
ColorComponent
<
NumberOrAngle
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
bool
)
Hwb
(
ColorComponent
<
NumberOrAngle
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
bool
)
Lab
(
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
)
Lch
(
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrAngle
>
ColorComponent
<
NumberOrPercentage
>
)
Oklab
(
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
)
Oklch
(
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrAngle
>
ColorComponent
<
NumberOrPercentage
>
)
Color
(
ColorSpace
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
ColorComponent
<
NumberOrPercentage
>
)
}
impl
ColorFunction
{
pub
fn
resolve_to_absolute
(
&
self
)
-
>
Result
<
AbsoluteColor
(
)
>
{
macro_rules
!
alpha
{
(
alpha
:
expr
)
=
>
{
{
alpha
.
resolve
(
None
)
?
.
map
(
|
value
|
normalize
(
value
.
to_number
(
1
.
0
)
)
.
clamp
(
0
.
0
OPAQUE
)
)
}
}
;
}
Ok
(
match
self
{
ColorFunction
:
:
Rgb
(
r
g
b
alpha
)
=
>
{
#
[
inline
]
fn
resolve
(
component
:
&
ColorComponent
<
NumberOrPercentage
>
)
-
>
Result
<
u8
(
)
>
{
Ok
(
clamp_floor_256_f32
(
component
.
resolve
(
None
)
?
.
map
(
|
value
|
value
.
to_number
(
u8
:
:
MAX
as
f32
)
)
.
unwrap_or
(
0
.
0
)
)
)
}
AbsoluteColor
:
:
srgb_legacy
(
resolve
(
r
)
?
resolve
(
g
)
?
resolve
(
b
)
?
alpha
!
(
alpha
)
.
unwrap_or
(
0
.
0
)
)
}
ColorFunction
:
:
Hsl
(
h
s
l
alpha
is_legacy_syntax
)
=
>
{
const
LIGHTNESS_RANGE
:
f32
=
100
.
0
;
const
SATURATION_RANGE
:
f32
=
100
.
0
;
let
mut
result
=
AbsoluteColor
:
:
new
(
ColorSpace
:
:
Hsl
h
.
resolve
(
None
)
?
.
map
(
|
angle
|
normalize_hue
(
angle
.
degrees
(
)
)
)
s
.
resolve
(
None
)
?
.
map
(
|
s
|
{
if
*
is_legacy_syntax
{
s
.
to_number
(
SATURATION_RANGE
)
.
clamp
(
0
.
0
SATURATION_RANGE
)
}
else
{
s
.
to_number
(
SATURATION_RANGE
)
}
}
)
l
.
resolve
(
None
)
?
.
map
(
|
l
|
{
if
*
is_legacy_syntax
{
l
.
to_number
(
LIGHTNESS_RANGE
)
.
clamp
(
0
.
0
LIGHTNESS_RANGE
)
}
else
{
l
.
to_number
(
LIGHTNESS_RANGE
)
}
}
)
alpha
!
(
alpha
)
)
;
if
*
is_legacy_syntax
{
result
.
flags
.
insert
(
ColorFlags
:
:
IS_LEGACY_SRGB
)
;
}
result
}
ColorFunction
:
:
Hwb
(
h
w
b
alpha
is_legacy_syntax
)
=
>
{
const
WHITENESS_RANGE
:
f32
=
100
.
0
;
const
BLACKNESS_RANGE
:
f32
=
100
.
0
;
let
mut
result
=
AbsoluteColor
:
:
new
(
ColorSpace
:
:
Hwb
h
.
resolve
(
None
)
?
.
map
(
|
angle
|
normalize_hue
(
angle
.
degrees
(
)
)
)
w
.
resolve
(
None
)
?
.
map
(
|
w
|
{
if
*
is_legacy_syntax
{
w
.
to_number
(
WHITENESS_RANGE
)
.
clamp
(
0
.
0
WHITENESS_RANGE
)
}
else
{
w
.
to_number
(
WHITENESS_RANGE
)
}
}
)
b
.
resolve
(
None
)
?
.
map
(
|
b
|
{
if
*
is_legacy_syntax
{
b
.
to_number
(
BLACKNESS_RANGE
)
.
clamp
(
0
.
0
BLACKNESS_RANGE
)
}
else
{
b
.
to_number
(
BLACKNESS_RANGE
)
}
}
)
alpha
!
(
alpha
)
)
;
if
*
is_legacy_syntax
{
result
.
flags
.
insert
(
ColorFlags
:
:
IS_LEGACY_SRGB
)
;
}
result
}
ColorFunction
:
:
Lab
(
l
a
b
alpha
)
=
>
{
const
LIGHTNESS_RANGE
:
f32
=
100
.
0
;
const
A_B_RANGE
:
f32
=
125
.
0
;
AbsoluteColor
:
:
new
(
ColorSpace
:
:
Lab
l
.
resolve
(
None
)
?
.
map
(
|
l
|
l
.
to_number
(
LIGHTNESS_RANGE
)
)
a
.
resolve
(
None
)
?
.
map
(
|
a
|
a
.
to_number
(
A_B_RANGE
)
)
b
.
resolve
(
None
)
?
.
map
(
|
b
|
b
.
to_number
(
A_B_RANGE
)
)
alpha
!
(
alpha
)
)
}
ColorFunction
:
:
Lch
(
l
c
h
alpha
)
=
>
{
const
LIGHTNESS_RANGE
:
f32
=
100
.
0
;
const
CHROMA_RANGE
:
f32
=
150
.
0
;
AbsoluteColor
:
:
new
(
ColorSpace
:
:
Lch
l
.
resolve
(
None
)
?
.
map
(
|
l
|
l
.
to_number
(
LIGHTNESS_RANGE
)
)
c
.
resolve
(
None
)
?
.
map
(
|
c
|
c
.
to_number
(
CHROMA_RANGE
)
)
h
.
resolve
(
None
)
?
.
map
(
|
angle
|
normalize_hue
(
angle
.
degrees
(
)
)
)
alpha
!
(
alpha
)
)
}
ColorFunction
:
:
Oklab
(
l
a
b
alpha
)
=
>
{
const
LIGHTNESS_RANGE
:
f32
=
1
.
0
;
const
A_B_RANGE
:
f32
=
0
.
4
;
AbsoluteColor
:
:
new
(
ColorSpace
:
:
Oklab
l
.
resolve
(
None
)
?
.
map
(
|
l
|
l
.
to_number
(
LIGHTNESS_RANGE
)
)
a
.
resolve
(
None
)
?
.
map
(
|
a
|
a
.
to_number
(
A_B_RANGE
)
)
b
.
resolve
(
None
)
?
.
map
(
|
b
|
b
.
to_number
(
A_B_RANGE
)
)
alpha
!
(
alpha
)
)
}
ColorFunction
:
:
Oklch
(
l
c
h
alpha
)
=
>
{
const
LIGHTNESS_RANGE
:
f32
=
1
.
0
;
const
CHROMA_RANGE
:
f32
=
0
.
4
;
AbsoluteColor
:
:
new
(
ColorSpace
:
:
Oklch
l
.
resolve
(
None
)
?
.
map
(
|
l
|
l
.
to_number
(
LIGHTNESS_RANGE
)
)
c
.
resolve
(
None
)
?
.
map
(
|
c
|
c
.
to_number
(
CHROMA_RANGE
)
)
h
.
resolve
(
None
)
?
.
map
(
|
angle
|
normalize_hue
(
angle
.
degrees
(
)
)
)
alpha
!
(
alpha
)
)
}
ColorFunction
:
:
Color
(
color_space
r
g
b
alpha
)
=
>
AbsoluteColor
:
:
new
(
(
*
color_space
)
.
into
(
)
r
.
resolve
(
None
)
?
.
map
(
|
c
|
c
.
to_number
(
1
.
0
)
)
g
.
resolve
(
None
)
?
.
map
(
|
c
|
c
.
to_number
(
1
.
0
)
)
b
.
resolve
(
None
)
?
.
map
(
|
c
|
c
.
to_number
(
1
.
0
)
)
alpha
!
(
alpha
)
)
}
)
}
}
