use
super
:
:
{
parsing
:
:
{
rcs_enabled
ChannelKeyword
}
AbsoluteColor
}
;
use
crate
:
:
{
parser
:
:
ParserContext
values
:
:
{
generics
:
:
calc
:
:
CalcUnits
specified
:
:
calc
:
:
{
CalcNode
as
SpecifiedCalcNode
Leaf
as
SpecifiedLeaf
}
}
}
;
use
cssparser
:
:
{
Parser
Token
}
;
use
style_traits
:
:
{
ParseError
StyleParseErrorKind
}
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
pub
enum
ColorComponent
<
ValueType
>
{
None
Value
(
ValueType
)
}
impl
<
ValueType
>
ColorComponent
<
ValueType
>
{
#
[
inline
]
pub
fn
is_none
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
None
)
}
pub
fn
map_value
<
OutType
>
(
self
f
:
impl
FnOnce
(
ValueType
)
-
>
OutType
)
-
>
ColorComponent
<
OutType
>
{
match
self
{
Self
:
:
None
=
>
ColorComponent
:
:
None
Self
:
:
Value
(
value
)
=
>
ColorComponent
:
:
Value
(
f
(
value
)
)
}
}
pub
fn
into_value
(
self
)
-
>
ValueType
{
match
self
{
Self
:
:
None
=
>
panic
!
(
"
value
not
available
when
component
is
None
"
)
Self
:
:
Value
(
value
)
=
>
value
}
}
pub
fn
into_value_or
(
self
default
:
ValueType
)
-
>
ValueType
{
match
self
{
Self
:
:
None
=
>
default
Self
:
:
Value
(
value
)
=
>
value
}
}
}
pub
trait
ColorComponentType
:
Sized
{
fn
from_value
(
value
:
f32
)
-
>
Self
;
fn
units
(
)
-
>
CalcUnits
;
fn
try_from_token
(
token
:
&
Token
)
-
>
Result
<
Self
(
)
>
;
fn
try_from_leaf
(
leaf
:
&
SpecifiedLeaf
)
-
>
Result
<
Self
(
)
>
;
}
impl
<
ValueType
:
ColorComponentType
>
ColorComponent
<
ValueType
>
{
pub
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_none
:
bool
origin_color
:
Option
<
&
AbsoluteColor
>
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
match
*
input
.
next
(
)
?
{
Token
:
:
Ident
(
ref
value
)
if
allow_none
&
&
value
.
eq_ignore_ascii_case
(
"
none
"
)
=
>
{
Ok
(
ColorComponent
:
:
None
)
}
ref
t
Token
:
:
Ident
(
ref
ident
)
if
origin_color
.
is_some
(
)
=
>
{
if
let
Ok
(
channel_keyword
)
=
ChannelKeyword
:
:
from_ident
(
ident
)
{
if
let
Ok
(
value
)
=
origin_color
.
unwrap
(
)
.
get_component_by_channel_keyword
(
channel_keyword
)
{
Ok
(
Self
:
:
Value
(
ValueType
:
:
from_value
(
value
.
unwrap_or
(
0
.
0
)
)
)
)
}
else
{
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
}
}
else
{
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
}
}
Token
:
:
Function
(
ref
name
)
=
>
{
let
function
=
SpecifiedCalcNode
:
:
math_function
(
context
name
location
)
?
;
let
units
=
if
rcs_enabled
(
)
{
ValueType
:
:
units
(
)
|
CalcUnits
:
:
COLOR_COMPONENT
}
else
{
ValueType
:
:
units
(
)
}
;
let
node
=
SpecifiedCalcNode
:
:
parse
(
context
input
function
units
)
?
;
let
Ok
(
resolved_leaf
)
=
node
.
resolve_map
(
|
leaf
|
{
Ok
(
match
leaf
{
SpecifiedLeaf
:
:
ColorComponent
(
channel_keyword
)
=
>
{
if
let
Some
(
origin_color
)
=
origin_color
{
if
let
Ok
(
value
)
=
origin_color
.
get_component_by_channel_keyword
(
*
channel_keyword
)
{
SpecifiedLeaf
:
:
Number
(
value
.
unwrap_or
(
0
.
0
)
)
}
else
{
return
Err
(
(
)
)
;
}
}
else
{
return
Err
(
(
)
)
;
}
}
l
=
>
l
.
clone
(
)
}
)
}
)
else
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
;
ValueType
:
:
try_from_leaf
(
&
resolved_leaf
)
.
map
(
Self
:
:
Value
)
.
map_err
(
|
_
|
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
ref
t
=
>
ValueType
:
:
try_from_token
(
t
)
.
map
(
Self
:
:
Value
)
.
map_err
(
|
_
|
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
}
}
}
