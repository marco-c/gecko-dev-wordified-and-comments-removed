use
std
:
:
fmt
:
:
Write
;
use
super
:
:
{
parsing
:
:
{
rcs_enabled
ChannelKeyword
}
AbsoluteColor
}
;
use
crate
:
:
{
parser
:
:
ParserContext
values
:
:
{
animated
:
:
ToAnimatedValue
generics
:
:
calc
:
:
{
CalcUnits
GenericCalcNode
}
specified
:
:
calc
:
:
{
AllowParse
Leaf
}
}
}
;
use
cssparser
:
:
{
color
:
:
OPAQUE
Parser
Token
}
;
use
style_traits
:
:
{
ParseError
ToCss
}
;
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ColorComponent
<
ValueType
>
{
None
Value
(
ValueType
)
ChannelKeyword
(
ChannelKeyword
)
Calc
(
Box
<
GenericCalcNode
<
Leaf
>
>
)
AlphaOmitted
}
impl
<
ValueType
>
ColorComponent
<
ValueType
>
{
#
[
inline
]
pub
fn
is_none
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
None
)
}
}
pub
trait
ColorComponentType
:
Sized
+
Clone
{
fn
from_value
(
value
:
f32
)
-
>
Self
;
fn
units
(
)
-
>
CalcUnits
;
fn
try_from_token
(
token
:
&
Token
)
-
>
Result
<
Self
(
)
>
;
fn
try_from_leaf
(
leaf
:
&
Leaf
)
-
>
Result
<
Self
(
)
>
;
}
impl
<
ValueType
:
ColorComponentType
>
ColorComponent
<
ValueType
>
{
pub
fn
parse
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
allow_none
:
bool
)
-
>
Result
<
Self
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
match
*
input
.
next
(
)
?
{
Token
:
:
Ident
(
ref
value
)
if
allow_none
&
&
value
.
eq_ignore_ascii_case
(
"
none
"
)
=
>
{
Ok
(
ColorComponent
:
:
None
)
}
ref
t
Token
:
:
Ident
(
ref
ident
)
=
>
{
let
Ok
(
channel_keyword
)
=
ChannelKeyword
:
:
from_ident
(
ident
)
else
{
return
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
;
}
;
Ok
(
ColorComponent
:
:
ChannelKeyword
(
channel_keyword
)
)
}
Token
:
:
Function
(
ref
name
)
=
>
{
let
function
=
GenericCalcNode
:
:
math_function
(
context
name
location
)
?
;
let
allow
=
AllowParse
:
:
new
(
if
rcs_enabled
(
)
{
ValueType
:
:
units
(
)
|
CalcUnits
:
:
COLOR_COMPONENT
}
else
{
ValueType
:
:
units
(
)
}
)
;
let
node
=
GenericCalcNode
:
:
parse
(
context
input
function
allow
)
?
;
debug_assert
!
(
!
node
.
has_anchor_function
"
Anchor
function
used
for
color
?
"
)
;
let
mut
node
=
node
.
node
;
node
.
simplify_and_sort
(
)
;
Ok
(
Self
:
:
Calc
(
Box
:
:
new
(
node
)
)
)
}
ref
t
=
>
ValueType
:
:
try_from_token
(
t
)
.
map
(
Self
:
:
Value
)
.
map_err
(
|
_
|
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
}
}
pub
fn
resolve
(
&
self
origin_color
:
Option
<
&
AbsoluteColor
>
)
-
>
Result
<
Option
<
ValueType
>
(
)
>
{
struct
EmptyContext
;
Ok
(
match
self
{
ColorComponent
:
:
None
=
>
None
ColorComponent
:
:
Value
(
value
)
=
>
Some
(
value
.
clone
(
)
)
ColorComponent
:
:
ChannelKeyword
(
channel_keyword
)
=
>
match
origin_color
{
Some
(
origin_color
)
=
>
{
let
value
=
origin_color
.
get_component_by_channel_keyword
(
*
channel_keyword
)
?
;
Some
(
ValueType
:
:
from_value
(
value
.
unwrap_or
(
0
.
0
)
)
)
}
None
=
>
return
Err
(
(
)
)
}
ColorComponent
:
:
Calc
(
node
)
=
>
{
let
Ok
(
resolved_leaf
)
=
node
.
resolve_map
(
|
leaf
_
|
{
Ok
(
match
leaf
{
Leaf
:
:
ColorComponent
(
channel_keyword
)
=
>
match
origin_color
{
Some
(
origin_color
)
=
>
{
let
value
=
origin_color
.
get_component_by_channel_keyword
(
*
channel_keyword
)
?
;
Leaf
:
:
Number
(
value
.
unwrap_or
(
0
.
0
)
)
}
None
=
>
return
Err
(
(
)
)
}
l
=
>
l
.
clone
(
)
}
)
}
|
_
_
|
Ok
(
None
)
&
mut
EmptyContext
)
else
{
return
Err
(
(
)
)
;
}
;
Some
(
ValueType
:
:
try_from_leaf
(
&
resolved_leaf
)
?
)
}
ColorComponent
:
:
AlphaOmitted
=
>
{
if
let
Some
(
origin_color
)
=
origin_color
{
origin_color
.
alpha
(
)
.
map
(
ValueType
:
:
from_value
)
}
else
{
Some
(
ValueType
:
:
from_value
(
OPAQUE
)
)
}
}
}
)
}
}
impl
<
ValueType
:
ToCss
>
ToCss
for
ColorComponent
<
ValueType
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
style_traits
:
:
CssWriter
<
W
>
)
-
>
std
:
:
fmt
:
:
Result
where
W
:
Write
{
match
self
{
ColorComponent
:
:
None
=
>
dest
.
write_str
(
"
none
"
)
?
ColorComponent
:
:
Value
(
value
)
=
>
value
.
to_css
(
dest
)
?
ColorComponent
:
:
ChannelKeyword
(
channel_keyword
)
=
>
channel_keyword
.
to_css
(
dest
)
?
ColorComponent
:
:
Calc
(
node
)
=
>
{
node
.
to_css
(
dest
)
?
;
}
ColorComponent
:
:
AlphaOmitted
=
>
{
debug_assert
!
(
false
"
can
'
t
serialize
an
omitted
alpha
component
"
)
;
}
}
Ok
(
(
)
)
}
}
impl
<
ValueType
>
ToAnimatedValue
for
ColorComponent
<
ValueType
>
{
type
AnimatedValue
=
Self
;
fn
to_animated_value
(
self
_context
:
&
crate
:
:
values
:
:
animated
:
:
Context
)
-
>
Self
:
:
AnimatedValue
{
self
}
fn
from_animated_value
(
animated
:
Self
:
:
AnimatedValue
)
-
>
Self
{
animated
}
}
