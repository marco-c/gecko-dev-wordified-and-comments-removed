use
super
:
:
{
AbsoluteColor
ColorSpace
}
;
impl
AbsoluteColor
{
pub
fn
map_into_gamut_limits
(
&
self
)
-
>
Self
{
if
matches
!
(
self
.
color_space
ColorSpace
:
:
Lab
|
ColorSpace
:
:
Lch
|
ColorSpace
:
:
Oklab
|
ColorSpace
:
:
Oklch
|
ColorSpace
:
:
XyzD50
|
ColorSpace
:
:
XyzD65
)
{
return
self
.
clone
(
)
;
}
if
self
.
in_gamut
(
)
{
return
self
.
clone
(
)
;
}
let
origin_oklch
=
self
.
to_color_space
(
ColorSpace
:
:
Oklch
)
;
if
origin_oklch
.
components
.
1
>
=
1
.
0
{
return
AbsoluteColor
:
:
new
(
self
.
color_space
1
.
0
1
.
0
1
.
0
self
.
alpha
)
;
}
if
origin_oklch
.
components
.
1
<
=
0
.
0
{
return
AbsoluteColor
:
:
new
(
self
.
color_space
0
.
0
0
.
0
0
.
0
self
.
alpha
)
;
}
const
JND
:
f32
=
0
.
02
;
const
EPSILON
:
f32
=
0
.
0001
;
let
mut
min
=
0
.
0
;
let
mut
max
=
origin_oklch
.
components
.
1
;
let
mut
min_in_gamut
=
true
;
let
mut
current
=
origin_oklch
.
clone
(
)
;
let
mut
current_in_space
=
self
.
clone
(
)
;
let
clipped
=
current_in_space
.
clip
(
)
;
if
delta_eok
(
&
clipped
&
current
)
<
JND
{
return
clipped
;
}
while
max
-
min
>
EPSILON
{
let
chroma
=
(
min
+
max
)
/
2
.
0
;
current
.
components
.
1
=
chroma
;
current_in_space
=
current
.
to_color_space
(
self
.
color_space
)
;
if
min_in_gamut
&
&
current_in_space
.
in_gamut
(
)
{
min
=
chroma
;
continue
;
}
let
clipped
=
current_in_space
.
clip
(
)
;
let
e
=
delta_eok
(
&
clipped
&
current
)
;
if
e
<
JND
{
if
JND
-
e
<
EPSILON
{
return
clipped
;
}
min_in_gamut
=
false
;
min
=
chroma
;
}
else
{
max
=
chroma
;
}
}
current_in_space
}
fn
clip
(
&
self
)
-
>
Self
{
let
mut
result
=
self
.
clone
(
)
;
result
.
components
=
result
.
components
.
map
(
|
c
|
c
.
clamp
(
0
.
0
1
.
0
)
)
;
result
}
fn
in_gamut
(
&
self
)
-
>
bool
{
macro_rules
!
in_range
{
(
c
:
expr
)
=
>
{
{
c
>
=
0
.
0
&
&
c
<
=
1
.
0
}
}
;
}
match
self
.
color_space
{
ColorSpace
:
:
Hsl
|
ColorSpace
:
:
Hwb
=
>
self
.
to_color_space
(
ColorSpace
:
:
Srgb
)
.
in_gamut
(
)
ColorSpace
:
:
Srgb
|
ColorSpace
:
:
SrgbLinear
|
ColorSpace
:
:
DisplayP3
|
ColorSpace
:
:
A98Rgb
|
ColorSpace
:
:
ProphotoRgb
|
ColorSpace
:
:
Rec2020
=
>
{
in_range
!
(
self
.
components
.
0
)
&
&
in_range
!
(
self
.
components
.
1
)
&
&
in_range
!
(
self
.
components
.
2
)
}
ColorSpace
:
:
Lab
|
ColorSpace
:
:
Lch
|
ColorSpace
:
:
Oklab
|
ColorSpace
:
:
Oklch
|
ColorSpace
:
:
XyzD50
|
ColorSpace
:
:
XyzD65
=
>
true
}
}
}
fn
delta_eok
(
reference
:
&
AbsoluteColor
sample
:
&
AbsoluteColor
)
-
>
f32
{
let
reference
=
reference
.
to_color_space
(
ColorSpace
:
:
Oklab
)
;
let
sample
=
sample
.
to_color_space
(
ColorSpace
:
:
Oklab
)
;
let
diff
=
reference
.
components
-
sample
.
components
;
let
diff
=
diff
*
diff
;
(
diff
.
0
+
diff
.
1
+
diff
.
2
)
.
sqrt
(
)
}
