/
/
/
cbindgen
:
ignore
pub
mod
convert
;
pub
mod
mix
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
style_traits
:
:
{
CssWriter
ToCss
}
;
#
[
derive
(
Copy
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
pub
struct
ColorComponents
(
pub
f32
pub
f32
pub
f32
)
;
impl
ColorComponents
{
pub
fn
map
(
self
f
:
impl
Fn
(
f32
)
-
>
f32
)
-
>
Self
{
Self
(
f
(
self
.
0
)
f
(
self
.
1
)
f
(
self
.
2
)
)
}
}
#
[
derive
(
Clone
Copy
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
#
[
repr
(
u8
)
]
pub
enum
ColorSpace
{
Lab
Lch
Oklab
Oklch
Srgb
SrgbLinear
DisplayP3
A98Rgb
ProphotoRgb
Rec2020
XyzD50
XyzD65
}
bitflags
!
{
/
/
/
Flags
used
when
serializing
colors
.
#
[
derive
(
Default
MallocSizeOf
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
SerializationFlags
:
u8
{
/
/
/
If
set
serializes
sRGB
colors
into
color
(
srgb
.
.
.
)
instead
of
/
/
/
rgba
(
.
.
.
)
.
const
AS_COLOR_FUNCTION
=
0x01
;
}
}
#
[
derive
(
Clone
Debug
MallocSizeOf
PartialEq
ToShmem
)
]
#
[
repr
(
C
)
]
pub
struct
AbsoluteColor
{
pub
components
:
ColorComponents
pub
alpha
:
f32
pub
color_space
:
ColorSpace
pub
flags
:
SerializationFlags
}
macro_rules
!
color_components_as
{
(
c
:
expr
t
:
ty
)
=
>
{
{
/
/
This
macro
is
not
an
inline
function
because
we
can
'
t
use
the
/
/
generic
type
(
t
)
in
a
constant
expression
as
per
:
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
76560
const_assert_eq
!
(
std
:
:
mem
:
:
size_of
:
:
<
t
>
(
)
std
:
:
mem
:
:
size_of
:
:
<
[
f32
;
4
]
>
(
)
)
;
const_assert_eq
!
(
std
:
:
mem
:
:
align_of
:
:
<
t
>
(
)
std
:
:
mem
:
:
align_of
:
:
<
[
f32
;
4
]
>
(
)
)
;
const_assert
!
(
std
:
:
mem
:
:
size_of
:
:
<
AbsoluteColor
>
(
)
>
=
std
:
:
mem
:
:
size_of
:
:
<
t
>
(
)
)
;
const_assert_eq
!
(
std
:
:
mem
:
:
align_of
:
:
<
AbsoluteColor
>
(
)
std
:
:
mem
:
:
align_of
:
:
<
t
>
(
)
)
;
std
:
:
mem
:
:
transmute
:
:
<
&
ColorComponents
&
t
>
(
&
c
.
components
)
}
}
;
}
impl
AbsoluteColor
{
pub
fn
new
(
color_space
:
ColorSpace
components
:
ColorComponents
alpha
:
f32
)
-
>
Self
{
Self
{
components
alpha
color_space
flags
:
SerializationFlags
:
:
empty
(
)
}
}
#
[
inline
]
pub
fn
alpha
(
&
self
)
-
>
f32
{
self
.
alpha
}
pub
fn
to_color_space
(
&
self
color_space
:
ColorSpace
)
-
>
Self
{
use
ColorSpace
:
:
*
;
if
self
.
color_space
=
=
color_space
{
return
self
.
clone
(
)
;
}
let
(
xyz
white_point
)
=
match
self
.
color_space
{
Lab
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
Lab
>
(
&
self
.
components
)
Lch
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
Lch
>
(
&
self
.
components
)
Oklab
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
Oklab
>
(
&
self
.
components
)
Oklch
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
Oklch
>
(
&
self
.
components
)
Srgb
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
Srgb
>
(
&
self
.
components
)
SrgbLinear
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
SrgbLinear
>
(
&
self
.
components
)
DisplayP3
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
DisplayP3
>
(
&
self
.
components
)
A98Rgb
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
A98Rgb
>
(
&
self
.
components
)
ProphotoRgb
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
ProphotoRgb
>
(
&
self
.
components
)
Rec2020
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
Rec2020
>
(
&
self
.
components
)
XyzD50
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
XyzD50
>
(
&
self
.
components
)
XyzD65
=
>
convert
:
:
to_xyz
:
:
<
convert
:
:
XyzD65
>
(
&
self
.
components
)
}
;
let
result
=
match
color_space
{
Lab
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
Lab
>
(
&
xyz
white_point
)
Lch
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
Lch
>
(
&
xyz
white_point
)
Oklab
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
Oklab
>
(
&
xyz
white_point
)
Oklch
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
Oklch
>
(
&
xyz
white_point
)
Srgb
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
Srgb
>
(
&
xyz
white_point
)
SrgbLinear
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
SrgbLinear
>
(
&
xyz
white_point
)
DisplayP3
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
DisplayP3
>
(
&
xyz
white_point
)
A98Rgb
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
A98Rgb
>
(
&
xyz
white_point
)
ProphotoRgb
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
ProphotoRgb
>
(
&
xyz
white_point
)
Rec2020
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
Rec2020
>
(
&
xyz
white_point
)
XyzD50
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
XyzD50
>
(
&
xyz
white_point
)
XyzD65
=
>
convert
:
:
from_xyz
:
:
<
convert
:
:
XyzD65
>
(
&
xyz
white_point
)
}
;
Self
:
:
new
(
color_space
result
self
.
alpha
)
}
}
impl
From
<
cssparser
:
:
PredefinedColorSpace
>
for
ColorSpace
{
fn
from
(
value
:
cssparser
:
:
PredefinedColorSpace
)
-
>
Self
{
match
value
{
cssparser
:
:
PredefinedColorSpace
:
:
Srgb
=
>
ColorSpace
:
:
Srgb
cssparser
:
:
PredefinedColorSpace
:
:
SrgbLinear
=
>
ColorSpace
:
:
SrgbLinear
cssparser
:
:
PredefinedColorSpace
:
:
DisplayP3
=
>
ColorSpace
:
:
DisplayP3
cssparser
:
:
PredefinedColorSpace
:
:
A98Rgb
=
>
ColorSpace
:
:
A98Rgb
cssparser
:
:
PredefinedColorSpace
:
:
ProphotoRgb
=
>
ColorSpace
:
:
ProphotoRgb
cssparser
:
:
PredefinedColorSpace
:
:
Rec2020
=
>
ColorSpace
:
:
Rec2020
cssparser
:
:
PredefinedColorSpace
:
:
XyzD50
=
>
ColorSpace
:
:
XyzD50
cssparser
:
:
PredefinedColorSpace
:
:
XyzD65
=
>
ColorSpace
:
:
XyzD65
}
}
}
impl
From
<
cssparser
:
:
AbsoluteColor
>
for
AbsoluteColor
{
fn
from
(
f
:
cssparser
:
:
AbsoluteColor
)
-
>
Self
{
match
f
{
cssparser
:
:
AbsoluteColor
:
:
Rgba
(
rgba
)
=
>
Self
:
:
from_rgba
(
rgba
)
cssparser
:
:
AbsoluteColor
:
:
Lab
(
lab
)
=
>
Self
:
:
new
(
ColorSpace
:
:
Lab
ColorComponents
(
lab
.
lightness
lab
.
a
lab
.
b
)
lab
.
alpha
)
cssparser
:
:
AbsoluteColor
:
:
Lch
(
lch
)
=
>
Self
:
:
new
(
ColorSpace
:
:
Lch
ColorComponents
(
lch
.
lightness
lch
.
chroma
lch
.
hue
)
lch
.
alpha
)
cssparser
:
:
AbsoluteColor
:
:
Oklab
(
oklab
)
=
>
Self
:
:
new
(
ColorSpace
:
:
Oklab
ColorComponents
(
oklab
.
lightness
oklab
.
a
oklab
.
b
)
oklab
.
alpha
)
cssparser
:
:
AbsoluteColor
:
:
Oklch
(
oklch
)
=
>
Self
:
:
new
(
ColorSpace
:
:
Oklch
ColorComponents
(
oklch
.
lightness
oklch
.
chroma
oklch
.
hue
)
oklch
.
alpha
)
cssparser
:
:
AbsoluteColor
:
:
ColorFunction
(
c
)
=
>
{
let
mut
result
=
AbsoluteColor
:
:
new
(
c
.
color_space
.
into
(
)
ColorComponents
(
c
.
c1
c
.
c2
c
.
c3
)
c
.
alpha
)
;
if
matches
!
(
c
.
color_space
cssparser
:
:
PredefinedColorSpace
:
:
Srgb
)
{
result
.
flags
|
=
SerializationFlags
:
:
AS_COLOR_FUNCTION
;
}
result
}
}
}
}
impl
ToCss
for
AbsoluteColor
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
match
self
.
color_space
{
ColorSpace
:
:
Srgb
if
!
self
.
flags
.
contains
(
SerializationFlags
:
:
AS_COLOR_FUNCTION
)
=
>
{
cssparser
:
:
ToCss
:
:
to_css
(
&
cssparser
:
:
RGBA
:
:
from_floats
(
self
.
components
.
0
self
.
components
.
1
self
.
components
.
2
self
.
alpha
(
)
)
dest
)
}
ColorSpace
:
:
Lab
=
>
cssparser
:
:
ToCss
:
:
to_css
(
unsafe
{
color_components_as
!
(
self
cssparser
:
:
Lab
)
}
dest
)
ColorSpace
:
:
Lch
=
>
cssparser
:
:
ToCss
:
:
to_css
(
unsafe
{
color_components_as
!
(
self
cssparser
:
:
Lch
)
}
dest
)
ColorSpace
:
:
Oklab
=
>
cssparser
:
:
ToCss
:
:
to_css
(
unsafe
{
color_components_as
!
(
self
cssparser
:
:
Oklab
)
}
dest
)
ColorSpace
:
:
Oklch
=
>
cssparser
:
:
ToCss
:
:
to_css
(
unsafe
{
color_components_as
!
(
self
cssparser
:
:
Oklch
)
}
dest
)
_
=
>
{
let
color_space
=
match
self
.
color_space
{
ColorSpace
:
:
Lab
|
ColorSpace
:
:
Lch
|
ColorSpace
:
:
Oklab
|
ColorSpace
:
:
Oklch
=
>
{
unreachable
!
(
"
Handle
these
in
the
wrapping
match
case
!
!
"
)
}
ColorSpace
:
:
Srgb
=
>
{
debug_assert
!
(
self
.
flags
.
contains
(
SerializationFlags
:
:
AS_COLOR_FUNCTION
)
"
The
case
without
this
flag
should
be
handled
in
the
wrapping
match
case
!
!
"
)
;
cssparser
:
:
PredefinedColorSpace
:
:
Srgb
}
ColorSpace
:
:
SrgbLinear
=
>
cssparser
:
:
PredefinedColorSpace
:
:
SrgbLinear
ColorSpace
:
:
DisplayP3
=
>
cssparser
:
:
PredefinedColorSpace
:
:
DisplayP3
ColorSpace
:
:
A98Rgb
=
>
cssparser
:
:
PredefinedColorSpace
:
:
A98Rgb
ColorSpace
:
:
ProphotoRgb
=
>
cssparser
:
:
PredefinedColorSpace
:
:
ProphotoRgb
ColorSpace
:
:
Rec2020
=
>
cssparser
:
:
PredefinedColorSpace
:
:
Rec2020
ColorSpace
:
:
XyzD50
=
>
cssparser
:
:
PredefinedColorSpace
:
:
XyzD50
ColorSpace
:
:
XyzD65
=
>
cssparser
:
:
PredefinedColorSpace
:
:
XyzD65
}
;
let
color_function
=
cssparser
:
:
ColorFunction
{
color_space
c1
:
self
.
components
.
0
c2
:
self
.
components
.
1
c3
:
self
.
components
.
2
alpha
:
self
.
alpha
}
;
let
color
=
cssparser
:
:
AbsoluteColor
:
:
ColorFunction
(
color_function
)
;
cssparser
:
:
ToCss
:
:
to_css
(
&
color
dest
)
}
}
}
}
