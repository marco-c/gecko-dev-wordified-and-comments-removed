#
!
[
deny
(
missing_docs
)
]
use
super
:
:
{
color_function
:
:
ColorFunction
component
:
:
{
ColorComponent
ColorComponentType
}
AbsoluteColor
}
;
use
crate
:
:
{
parser
:
:
ParserContext
values
:
:
{
generics
:
:
calc
:
:
CalcUnits
specified
:
:
{
angle
:
:
Angle
as
SpecifiedAngle
calc
:
:
Leaf
as
SpecifiedLeaf
color
:
:
Color
as
SpecifiedColor
}
}
}
;
use
cssparser
:
:
{
color
:
:
{
clamp_floor_256_f32
clamp_unit_f32
parse_hash_color
PredefinedColorSpace
OPAQUE
}
match_ignore_ascii_case
CowRcStr
Parser
Token
}
;
use
std
:
:
str
:
:
FromStr
;
use
style_traits
:
:
{
ParseError
StyleParseErrorKind
}
;
#
[
inline
]
pub
fn
rcs_enabled
(
)
-
>
bool
{
static_prefs
:
:
pref
!
(
"
layout
.
css
.
relative
-
color
-
syntax
.
enabled
"
)
}
#
[
inline
]
pub
fn
parse_color_keyword
(
ident
:
&
str
)
-
>
Result
<
SpecifiedColor
(
)
>
{
Ok
(
match_ignore_ascii_case
!
{
ident
"
transparent
"
=
>
{
SpecifiedColor
:
:
from_absolute_color
(
AbsoluteColor
:
:
srgb_legacy
(
0u8
0u8
0u8
0
.
0
)
)
}
"
currentcolor
"
=
>
SpecifiedColor
:
:
CurrentColor
_
=
>
{
let
(
r
g
b
)
=
cssparser
:
:
color
:
:
parse_named_color
(
ident
)
?
;
SpecifiedColor
:
:
from_absolute_color
(
AbsoluteColor
:
:
srgb_legacy
(
r
g
b
OPAQUE
)
)
}
}
)
}
pub
fn
parse_color_with
<
'
i
'
t
>
(
context
:
&
ParserContext
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
SpecifiedColor
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
let
token
=
input
.
next
(
)
?
;
match
*
token
{
Token
:
:
Hash
(
ref
value
)
|
Token
:
:
IDHash
(
ref
value
)
=
>
parse_hash_color
(
value
.
as_bytes
(
)
)
.
map
(
|
(
r
g
b
a
)
|
{
SpecifiedColor
:
:
from_absolute_color
(
AbsoluteColor
:
:
srgb_legacy
(
r
g
b
a
)
)
}
)
Token
:
:
Ident
(
ref
value
)
=
>
parse_color_keyword
(
value
)
Token
:
:
Function
(
ref
name
)
=
>
{
let
name
=
name
.
clone
(
)
;
return
input
.
parse_nested_block
(
|
arguments
|
{
Ok
(
SpecifiedColor
:
:
from_absolute_color
(
parse_color_function
(
context
name
arguments
)
?
.
resolve_to_absolute
(
)
)
)
}
)
;
}
_
=
>
Err
(
(
)
)
}
.
map_err
(
|
(
)
|
location
.
new_unexpected_token_error
(
token
.
clone
(
)
)
)
}
#
[
inline
]
fn
parse_color_function
<
'
i
'
t
>
(
context
:
&
ParserContext
name
:
CowRcStr
<
'
i
>
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
ColorFunction
ParseError
<
'
i
>
>
{
let
origin_color
=
parse_origin_color
(
context
arguments
)
?
;
let
component_parser
=
ComponentParser
{
context
origin_color
}
;
let
color
=
match_ignore_ascii_case
!
{
&
name
"
rgb
"
|
"
rgba
"
=
>
parse_rgb
(
&
component_parser
arguments
)
"
hsl
"
|
"
hsla
"
=
>
parse_hsl
(
&
component_parser
arguments
)
"
hwb
"
=
>
parse_hwb
(
&
component_parser
arguments
)
"
lab
"
=
>
parse_lab_like
(
&
component_parser
arguments
ColorFunction
:
:
Lab
)
"
lch
"
=
>
parse_lch_like
(
&
component_parser
arguments
ColorFunction
:
:
Lch
)
"
oklab
"
=
>
parse_lab_like
(
&
component_parser
arguments
ColorFunction
:
:
Oklab
)
"
oklch
"
=
>
parse_lch_like
(
&
component_parser
arguments
ColorFunction
:
:
Oklch
)
"
color
"
=
>
parse_color_with_color_space
(
&
component_parser
arguments
)
_
=
>
return
Err
(
arguments
.
new_unexpected_token_error
(
Token
:
:
Ident
(
name
)
)
)
}
?
;
arguments
.
expect_exhausted
(
)
?
;
Ok
(
color
)
}
impl
ColorComponent
<
NumberOrPercentage
>
{
pub
fn
is_percentage
(
&
self
)
-
>
Result
<
bool
(
)
>
{
Ok
(
match
self
{
Self
:
:
Value
(
NumberOrPercentage
:
:
Percentage
{
.
.
}
)
=
>
true
_
=
>
false
}
)
}
}
fn
parse_origin_color
<
'
i
'
t
>
(
context
:
&
ParserContext
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Option
<
AbsoluteColor
>
ParseError
<
'
i
>
>
{
if
!
rcs_enabled
(
)
{
return
Ok
(
None
)
;
}
if
arguments
.
try_parse
(
|
p
|
p
.
expect_ident_matching
(
"
from
"
)
)
.
is_err
(
)
{
return
Ok
(
None
)
;
}
let
location
=
arguments
.
current_source_location
(
)
;
let
origin_color
=
parse_color_with
(
context
arguments
)
?
;
let
SpecifiedColor
:
:
Absolute
(
absolute
)
=
origin_color
else
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
;
Ok
(
Some
(
absolute
.
color
)
)
}
#
[
inline
]
fn
parse_rgb
<
'
i
'
t
>
(
component_parser
:
&
ComponentParser
<
'
_
'
_
>
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
ColorFunction
ParseError
<
'
i
>
>
{
let
location
=
arguments
.
current_source_location
(
)
;
let
maybe_red
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
is_legacy_syntax
=
component_parser
.
origin_color
.
is_none
(
)
&
&
!
maybe_red
.
is_none
(
)
&
&
arguments
.
try_parse
(
|
p
|
p
.
expect_comma
(
)
)
.
is_ok
(
)
;
Ok
(
if
is_legacy_syntax
{
let
Ok
(
is_percentage
)
=
maybe_red
.
is_percentage
(
)
else
{
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
;
}
;
let
(
red
green
blue
)
=
if
is_percentage
{
let
red
=
maybe_red
.
map_value
(
|
v
|
clamp_unit_f32
(
v
.
to_number
(
1
.
0
)
)
)
;
let
green
=
component_parser
.
parse_percentage
(
arguments
false
)
?
.
map_value
(
clamp_unit_f32
)
;
arguments
.
expect_comma
(
)
?
;
let
blue
=
component_parser
.
parse_percentage
(
arguments
false
)
?
.
map_value
(
clamp_unit_f32
)
;
(
red
green
blue
)
}
else
{
let
red
=
maybe_red
.
map_value
(
|
v
|
clamp_floor_256_f32
(
v
.
to_number
(
255
.
0
)
)
)
;
let
green
=
component_parser
.
parse_number
(
arguments
false
)
?
.
map_value
(
clamp_floor_256_f32
)
;
arguments
.
expect_comma
(
)
?
;
let
blue
=
component_parser
.
parse_number
(
arguments
false
)
?
.
map_value
(
clamp_floor_256_f32
)
;
(
red
green
blue
)
}
;
let
alpha
=
component_parser
.
parse_legacy_alpha
(
arguments
)
?
;
ColorFunction
:
:
Rgb
(
red
green
blue
alpha
)
}
else
{
let
green
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
blue
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
alpha
=
component_parser
.
parse_modern_alpha
(
arguments
)
?
;
if
component_parser
.
origin_color
.
is_some
(
)
{
ColorFunction
:
:
Color
(
PredefinedColorSpace
:
:
Srgb
maybe_red
green
blue
alpha
)
}
else
{
fn
clamp
(
v
:
NumberOrPercentage
)
-
>
u8
{
clamp_floor_256_f32
(
v
.
to_number
(
255
.
0
)
)
}
let
red
=
maybe_red
.
map_value
(
clamp
)
;
let
green
=
green
.
map_value
(
clamp
)
;
let
blue
=
blue
.
map_value
(
clamp
)
;
ColorFunction
:
:
Rgb
(
red
green
blue
alpha
)
}
}
)
}
#
[
inline
]
fn
parse_hsl
<
'
i
'
t
>
(
component_parser
:
&
ComponentParser
<
'
_
'
_
>
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
ColorFunction
ParseError
<
'
i
>
>
{
let
hue
=
component_parser
.
parse_number_or_angle
(
arguments
true
)
?
;
let
is_legacy_syntax
=
component_parser
.
origin_color
.
is_none
(
)
&
&
!
hue
.
is_none
(
)
&
&
arguments
.
try_parse
(
|
p
|
p
.
expect_comma
(
)
)
.
is_ok
(
)
;
let
(
saturation
lightness
alpha
)
=
if
is_legacy_syntax
{
let
saturation
=
component_parser
.
parse_percentage
(
arguments
false
)
?
.
map_value
(
|
unit_value
|
NumberOrPercentage
:
:
Percentage
{
unit_value
}
)
;
arguments
.
expect_comma
(
)
?
;
let
lightness
=
component_parser
.
parse_percentage
(
arguments
false
)
?
.
map_value
(
|
unit_value
|
NumberOrPercentage
:
:
Percentage
{
unit_value
}
)
;
let
alpha
=
component_parser
.
parse_legacy_alpha
(
arguments
)
?
;
(
saturation
lightness
alpha
)
}
else
{
let
saturation
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
lightness
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
alpha
=
component_parser
.
parse_modern_alpha
(
arguments
)
?
;
(
saturation
lightness
alpha
)
}
;
Ok
(
ColorFunction
:
:
Hsl
(
hue
saturation
lightness
alpha
)
)
}
#
[
inline
]
fn
parse_hwb
<
'
i
'
t
>
(
component_parser
:
&
ComponentParser
<
'
_
'
_
>
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
ColorFunction
ParseError
<
'
i
>
>
{
let
hue
=
component_parser
.
parse_number_or_angle
(
arguments
true
)
?
;
let
whiteness
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
blackness
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
alpha
=
component_parser
.
parse_modern_alpha
(
arguments
)
?
;
Ok
(
ColorFunction
:
:
Hwb
(
hue
whiteness
blackness
alpha
)
)
}
type
IntoLabFn
<
Output
>
=
fn
(
l
:
ColorComponent
<
NumberOrPercentage
>
a
:
ColorComponent
<
NumberOrPercentage
>
b
:
ColorComponent
<
NumberOrPercentage
>
alpha
:
ColorComponent
<
NumberOrPercentage
>
)
-
>
Output
;
#
[
inline
]
fn
parse_lab_like
<
'
i
'
t
>
(
component_parser
:
&
ComponentParser
<
'
_
'
_
>
arguments
:
&
mut
Parser
<
'
i
'
t
>
into_color
:
IntoLabFn
<
ColorFunction
>
)
-
>
Result
<
ColorFunction
ParseError
<
'
i
>
>
{
let
lightness
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
a
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
b
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
alpha
=
component_parser
.
parse_modern_alpha
(
arguments
)
?
;
Ok
(
into_color
(
lightness
a
b
alpha
)
)
}
type
IntoLchFn
<
Output
>
=
fn
(
l
:
ColorComponent
<
NumberOrPercentage
>
a
:
ColorComponent
<
NumberOrPercentage
>
b
:
ColorComponent
<
NumberOrAngle
>
alpha
:
ColorComponent
<
NumberOrPercentage
>
)
-
>
Output
;
#
[
inline
]
fn
parse_lch_like
<
'
i
'
t
>
(
component_parser
:
&
ComponentParser
<
'
_
'
_
>
arguments
:
&
mut
Parser
<
'
i
'
t
>
into_color
:
IntoLchFn
<
ColorFunction
>
)
-
>
Result
<
ColorFunction
ParseError
<
'
i
>
>
{
let
lightness
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
chroma
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
hue
=
component_parser
.
parse_number_or_angle
(
arguments
true
)
?
;
let
alpha
=
component_parser
.
parse_modern_alpha
(
arguments
)
?
;
Ok
(
into_color
(
lightness
chroma
hue
alpha
)
)
}
#
[
inline
]
fn
parse_color_with_color_space
<
'
i
'
t
>
(
component_parser
:
&
ComponentParser
<
'
_
'
_
>
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
ColorFunction
ParseError
<
'
i
>
>
{
let
color_space
=
{
let
location
=
arguments
.
current_source_location
(
)
;
let
ident
=
arguments
.
expect_ident
(
)
?
;
PredefinedColorSpace
:
:
from_str
(
ident
)
.
map_err
(
|
_
|
location
.
new_unexpected_token_error
(
Token
:
:
Ident
(
ident
.
clone
(
)
)
)
)
?
}
;
let
origin_color
=
component_parser
.
origin_color
.
map
(
|
c
|
c
.
to_color_space
(
color_space
.
into
(
)
)
)
;
let
component_parser
=
ComponentParser
{
context
:
component_parser
.
context
origin_color
}
;
let
c1
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
c2
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
c3
=
component_parser
.
parse_number_or_percentage
(
arguments
true
)
?
;
let
alpha
=
component_parser
.
parse_modern_alpha
(
arguments
)
?
;
Ok
(
ColorFunction
:
:
Color
(
color_space
c1
c2
c3
alpha
)
)
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
NumberOrPercentage
{
Number
{
value
:
f32
}
Percentage
{
unit_value
:
f32
}
}
impl
NumberOrPercentage
{
pub
fn
to_number
(
&
self
percentage_basis
:
f32
)
-
>
f32
{
match
*
self
{
Self
:
:
Number
{
value
}
=
>
value
Self
:
:
Percentage
{
unit_value
}
=
>
unit_value
*
percentage_basis
}
}
}
impl
ColorComponentType
for
NumberOrPercentage
{
fn
from_value
(
value
:
f32
)
-
>
Self
{
Self
:
:
Number
{
value
}
}
fn
units
(
)
-
>
CalcUnits
{
CalcUnits
:
:
PERCENTAGE
}
fn
try_from_token
(
token
:
&
Token
)
-
>
Result
<
Self
(
)
>
{
Ok
(
match
*
token
{
Token
:
:
Number
{
value
.
.
}
=
>
Self
:
:
Number
{
value
}
Token
:
:
Percentage
{
unit_value
.
.
}
=
>
Self
:
:
Percentage
{
unit_value
}
_
=
>
{
return
Err
(
(
)
)
;
}
}
)
}
fn
try_from_leaf
(
leaf
:
&
SpecifiedLeaf
)
-
>
Result
<
Self
(
)
>
{
Ok
(
match
*
leaf
{
SpecifiedLeaf
:
:
Percentage
(
unit_value
)
=
>
Self
:
:
Percentage
{
unit_value
}
SpecifiedLeaf
:
:
Number
(
value
)
=
>
Self
:
:
Number
{
value
}
_
=
>
return
Err
(
(
)
)
}
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
NumberOrAngle
{
Number
{
value
:
f32
}
Angle
{
degrees
:
f32
}
}
impl
NumberOrAngle
{
pub
fn
degrees
(
&
self
)
-
>
f32
{
match
*
self
{
Self
:
:
Number
{
value
}
=
>
value
Self
:
:
Angle
{
degrees
}
=
>
degrees
}
}
}
impl
ColorComponentType
for
NumberOrAngle
{
fn
from_value
(
value
:
f32
)
-
>
Self
{
Self
:
:
Number
{
value
}
}
fn
units
(
)
-
>
CalcUnits
{
CalcUnits
:
:
ANGLE
}
fn
try_from_token
(
token
:
&
Token
)
-
>
Result
<
Self
(
)
>
{
Ok
(
match
*
token
{
Token
:
:
Number
{
value
.
.
}
=
>
Self
:
:
Number
{
value
}
Token
:
:
Dimension
{
value
ref
unit
.
.
}
=
>
{
let
degrees
=
SpecifiedAngle
:
:
parse_dimension
(
value
unit
false
)
.
map
(
|
angle
|
angle
.
degrees
(
)
)
?
;
NumberOrAngle
:
:
Angle
{
degrees
}
}
_
=
>
{
return
Err
(
(
)
)
;
}
}
)
}
fn
try_from_leaf
(
leaf
:
&
SpecifiedLeaf
)
-
>
Result
<
Self
(
)
>
{
Ok
(
match
*
leaf
{
SpecifiedLeaf
:
:
Angle
(
angle
)
=
>
Self
:
:
Angle
{
degrees
:
angle
.
degrees
(
)
}
SpecifiedLeaf
:
:
Number
(
value
)
=
>
Self
:
:
Number
{
value
}
_
=
>
return
Err
(
(
)
)
}
)
}
}
impl
ColorComponentType
for
f32
{
fn
from_value
(
value
:
f32
)
-
>
Self
{
value
}
fn
units
(
)
-
>
CalcUnits
{
CalcUnits
:
:
empty
(
)
}
fn
try_from_token
(
token
:
&
Token
)
-
>
Result
<
Self
(
)
>
{
if
let
Token
:
:
Number
{
value
.
.
}
=
*
token
{
Ok
(
value
)
}
else
{
Err
(
(
)
)
}
}
fn
try_from_leaf
(
leaf
:
&
SpecifiedLeaf
)
-
>
Result
<
Self
(
)
>
{
if
let
SpecifiedLeaf
:
:
Number
(
value
)
=
*
leaf
{
Ok
(
value
)
}
else
{
Err
(
(
)
)
}
}
}
pub
struct
ComponentParser
<
'
a
'
b
:
'
a
>
{
pub
context
:
&
'
a
ParserContext
<
'
b
>
pub
origin_color
:
Option
<
AbsoluteColor
>
}
impl
<
'
a
'
b
:
'
a
>
ComponentParser
<
'
a
'
b
>
{
pub
fn
new
(
context
:
&
'
a
ParserContext
<
'
b
>
)
-
>
Self
{
Self
{
context
origin_color
:
None
}
}
fn
parse_number_or_angle
<
'
i
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
allow_none
:
bool
)
-
>
Result
<
ColorComponent
<
NumberOrAngle
>
ParseError
<
'
i
>
>
{
ColorComponent
:
:
parse
(
self
.
context
input
allow_none
self
.
origin_color
.
as_ref
(
)
)
}
fn
parse_percentage
<
'
i
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
allow_none
:
bool
)
-
>
Result
<
ColorComponent
<
f32
>
ParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
Ok
(
match
ColorComponent
:
:
<
NumberOrPercentage
>
:
:
parse
(
self
.
context
input
allow_none
self
.
origin_color
.
as_ref
(
)
)
?
{
ColorComponent
:
:
None
=
>
ColorComponent
:
:
None
ColorComponent
:
:
Value
(
NumberOrPercentage
:
:
Percentage
{
unit_value
}
)
=
>
{
ColorComponent
:
:
Value
(
unit_value
)
}
_
=
>
return
Err
(
location
.
new_custom_error
(
StyleParseErrorKind
:
:
UnspecifiedError
)
)
}
)
}
fn
parse_number
<
'
i
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
allow_none
:
bool
)
-
>
Result
<
ColorComponent
<
f32
>
ParseError
<
'
i
>
>
{
ColorComponent
:
:
parse
(
self
.
context
input
allow_none
self
.
origin_color
.
as_ref
(
)
)
}
fn
parse_number_or_percentage
<
'
i
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
allow_none
:
bool
)
-
>
Result
<
ColorComponent
<
NumberOrPercentage
>
ParseError
<
'
i
>
>
{
ColorComponent
:
:
parse
(
self
.
context
input
allow_none
self
.
origin_color
.
as_ref
(
)
)
}
fn
parse_legacy_alpha
<
'
i
'
t
>
(
&
self
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
ColorComponent
<
NumberOrPercentage
>
ParseError
<
'
i
>
>
{
if
!
arguments
.
is_exhausted
(
)
{
arguments
.
expect_comma
(
)
?
;
self
.
parse_number_or_percentage
(
arguments
false
)
}
else
{
Ok
(
ColorComponent
:
:
Value
(
NumberOrPercentage
:
:
Number
{
value
:
OPAQUE
}
)
)
}
}
fn
parse_modern_alpha
<
'
i
'
t
>
(
&
self
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
ColorComponent
<
NumberOrPercentage
>
ParseError
<
'
i
>
>
{
if
!
arguments
.
is_exhausted
(
)
{
arguments
.
expect_delim
(
'
/
'
)
?
;
self
.
parse_number_or_percentage
(
arguments
true
)
}
else
{
Ok
(
ColorComponent
:
:
Value
(
NumberOrPercentage
:
:
Number
{
value
:
OPAQUE
}
)
)
}
}
}
