#
!
[
deny
(
missing_docs
)
]
use
crate
:
:
color
:
:
convert
:
:
normalize_hue
;
use
crate
:
:
values
:
:
normalize
;
use
cssparser
:
:
color
:
:
{
clamp_floor_256_f32
clamp_unit_f32
parse_hash_color
PredefinedColorSpace
OPAQUE
}
;
use
cssparser
:
:
{
match_ignore_ascii_case
CowRcStr
Parser
Token
}
;
use
std
:
:
str
:
:
FromStr
;
use
style_traits
:
:
ParseError
;
#
[
inline
]
pub
fn
parse_color_keyword
<
Output
>
(
ident
:
&
str
)
-
>
Result
<
Output
(
)
>
where
Output
:
FromParsedColor
{
Ok
(
match_ignore_ascii_case
!
{
ident
"
transparent
"
=
>
Output
:
:
from_rgba
(
0
0
0
0
.
0
)
"
currentcolor
"
=
>
Output
:
:
from_current_color
(
)
_
=
>
{
let
(
r
g
b
)
=
cssparser
:
:
color
:
:
parse_named_color
(
ident
)
?
;
Output
:
:
from_rgba
(
r
g
b
OPAQUE
)
}
}
)
}
pub
fn
parse_color_with
<
'
i
'
t
P
>
(
color_parser
:
&
P
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
P
:
:
Output
ParseError
<
'
i
>
>
where
P
:
ColorParser
<
'
i
>
{
let
location
=
input
.
current_source_location
(
)
;
let
token
=
input
.
next
(
)
?
;
match
*
token
{
Token
:
:
Hash
(
ref
value
)
|
Token
:
:
IDHash
(
ref
value
)
=
>
{
parse_hash_color
(
value
.
as_bytes
(
)
)
.
map
(
|
(
r
g
b
a
)
|
P
:
:
Output
:
:
from_rgba
(
r
g
b
a
)
)
}
Token
:
:
Ident
(
ref
value
)
=
>
parse_color_keyword
(
value
)
Token
:
:
Function
(
ref
name
)
=
>
{
let
name
=
name
.
clone
(
)
;
return
input
.
parse_nested_block
(
|
arguments
|
{
parse_color_function
(
color_parser
name
arguments
)
}
)
;
}
_
=
>
Err
(
(
)
)
}
.
map_err
(
|
(
)
|
location
.
new_unexpected_token_error
(
token
.
clone
(
)
)
)
}
#
[
inline
]
fn
parse_color_function
<
'
i
'
t
P
>
(
color_parser
:
&
P
name
:
CowRcStr
<
'
i
>
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
P
:
:
Output
ParseError
<
'
i
>
>
where
P
:
ColorParser
<
'
i
>
{
let
color
=
match_ignore_ascii_case
!
{
&
name
"
rgb
"
|
"
rgba
"
=
>
parse_rgb
(
color_parser
arguments
)
"
hsl
"
|
"
hsla
"
=
>
parse_hsl
(
color_parser
arguments
)
"
hwb
"
=
>
parse_hwb
(
color_parser
arguments
)
/
/
for
L
:
0
%
=
0
.
0
100
%
=
100
.
0
/
/
for
a
and
b
:
-
100
%
=
-
125
100
%
=
125
"
lab
"
=
>
parse_lab_like
(
color_parser
arguments
100
.
0
125
.
0
P
:
:
Output
:
:
from_lab
)
/
/
for
L
:
0
%
=
0
.
0
100
%
=
100
.
0
/
/
for
C
:
0
%
=
0
100
%
=
150
"
lch
"
=
>
parse_lch_like
(
color_parser
arguments
100
.
0
150
.
0
P
:
:
Output
:
:
from_lch
)
/
/
for
L
:
0
%
=
0
.
0
100
%
=
1
.
0
/
/
for
a
and
b
:
-
100
%
=
-
0
.
4
100
%
=
0
.
4
"
oklab
"
=
>
parse_lab_like
(
color_parser
arguments
1
.
0
0
.
4
P
:
:
Output
:
:
from_oklab
)
/
/
for
L
:
0
%
=
0
.
0
100
%
=
1
.
0
/
/
for
C
:
0
%
=
0
.
0
100
%
=
0
.
4
"
oklch
"
=
>
parse_lch_like
(
color_parser
arguments
1
.
0
0
.
4
P
:
:
Output
:
:
from_oklch
)
"
color
"
=
>
parse_color_with_color_space
(
color_parser
arguments
)
_
=
>
return
Err
(
arguments
.
new_unexpected_token_error
(
Token
:
:
Ident
(
name
)
)
)
}
?
;
arguments
.
expect_exhausted
(
)
?
;
Ok
(
color
)
}
#
[
inline
]
fn
parse_alpha_component
<
'
i
'
t
P
>
(
color_parser
:
&
P
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
f32
ParseError
<
'
i
>
>
where
P
:
ColorParser
<
'
i
>
{
let
alpha
=
color_parser
.
parse_number_or_percentage
(
arguments
)
?
.
to_number
(
1
.
0
)
;
Ok
(
normalize
(
alpha
)
.
clamp
(
0
.
0
OPAQUE
)
)
}
fn
parse_legacy_alpha
<
'
i
'
t
P
>
(
color_parser
:
&
P
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
f32
ParseError
<
'
i
>
>
where
P
:
ColorParser
<
'
i
>
{
Ok
(
if
!
arguments
.
is_exhausted
(
)
{
arguments
.
expect_comma
(
)
?
;
parse_alpha_component
(
color_parser
arguments
)
?
}
else
{
OPAQUE
}
)
}
fn
parse_modern_alpha
<
'
i
'
t
P
>
(
color_parser
:
&
P
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Option
<
f32
>
ParseError
<
'
i
>
>
where
P
:
ColorParser
<
'
i
>
{
if
!
arguments
.
is_exhausted
(
)
{
arguments
.
expect_delim
(
'
/
'
)
?
;
parse_none_or
(
arguments
|
p
|
parse_alpha_component
(
color_parser
p
)
)
}
else
{
Ok
(
Some
(
OPAQUE
)
)
}
}
#
[
inline
]
fn
parse_rgb
<
'
i
'
t
P
>
(
color_parser
:
&
P
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
P
:
:
Output
ParseError
<
'
i
>
>
where
P
:
ColorParser
<
'
i
>
{
let
maybe_red
=
parse_none_or
(
arguments
|
p
|
color_parser
.
parse_number_or_percentage
(
p
)
)
?
;
let
is_legacy_syntax
=
maybe_red
.
is_some
(
)
&
&
arguments
.
try_parse
(
|
p
|
p
.
expect_comma
(
)
)
.
is_ok
(
)
;
let
(
red
green
blue
alpha
)
=
if
is_legacy_syntax
{
let
(
red
green
blue
)
=
match
maybe_red
.
unwrap
(
)
{
NumberOrPercentage
:
:
Number
{
value
}
=
>
{
let
red
=
clamp_floor_256_f32
(
value
)
;
let
green
=
clamp_floor_256_f32
(
color_parser
.
parse_number
(
arguments
)
?
)
;
arguments
.
expect_comma
(
)
?
;
let
blue
=
clamp_floor_256_f32
(
color_parser
.
parse_number
(
arguments
)
?
)
;
(
red
green
blue
)
}
NumberOrPercentage
:
:
Percentage
{
unit_value
}
=
>
{
let
red
=
clamp_unit_f32
(
unit_value
)
;
let
green
=
clamp_unit_f32
(
color_parser
.
parse_percentage
(
arguments
)
?
)
;
arguments
.
expect_comma
(
)
?
;
let
blue
=
clamp_unit_f32
(
color_parser
.
parse_percentage
(
arguments
)
?
)
;
(
red
green
blue
)
}
}
;
let
alpha
=
parse_legacy_alpha
(
color_parser
arguments
)
?
;
(
red
green
blue
alpha
)
}
else
{
#
[
inline
]
fn
get_component_value
(
c
:
Option
<
NumberOrPercentage
>
)
-
>
u8
{
c
.
map
(
|
c
|
match
c
{
NumberOrPercentage
:
:
Number
{
value
}
=
>
clamp_floor_256_f32
(
value
)
NumberOrPercentage
:
:
Percentage
{
unit_value
}
=
>
clamp_unit_f32
(
unit_value
)
}
)
.
unwrap_or
(
0
)
}
let
red
=
get_component_value
(
maybe_red
)
;
let
green
=
get_component_value
(
parse_none_or
(
arguments
|
p
|
{
color_parser
.
parse_number_or_percentage
(
p
)
}
)
?
)
;
let
blue
=
get_component_value
(
parse_none_or
(
arguments
|
p
|
{
color_parser
.
parse_number_or_percentage
(
p
)
}
)
?
)
;
let
alpha
=
parse_modern_alpha
(
color_parser
arguments
)
?
.
unwrap_or
(
0
.
0
)
;
(
red
green
blue
alpha
)
}
;
Ok
(
P
:
:
Output
:
:
from_rgba
(
red
green
blue
alpha
)
)
}
#
[
inline
]
fn
parse_hsl
<
'
i
'
t
P
>
(
color_parser
:
&
P
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
P
:
:
Output
ParseError
<
'
i
>
>
where
P
:
ColorParser
<
'
i
>
{
const
LIGHTNESS_RANGE
:
f32
=
100
.
0
;
const
SATURATION_RANGE
:
f32
=
100
.
0
;
let
maybe_hue
=
parse_none_or
(
arguments
|
p
|
color_parser
.
parse_number_or_angle
(
p
)
)
?
;
let
is_legacy_syntax
=
maybe_hue
.
is_some
(
)
&
&
arguments
.
try_parse
(
|
p
|
p
.
expect_comma
(
)
)
.
is_ok
(
)
;
let
saturation
:
Option
<
f32
>
;
let
lightness
:
Option
<
f32
>
;
let
alpha
=
if
is_legacy_syntax
{
saturation
=
Some
(
color_parser
.
parse_percentage
(
arguments
)
?
*
SATURATION_RANGE
)
;
arguments
.
expect_comma
(
)
?
;
lightness
=
Some
(
color_parser
.
parse_percentage
(
arguments
)
?
*
LIGHTNESS_RANGE
)
;
Some
(
parse_legacy_alpha
(
color_parser
arguments
)
?
)
}
else
{
saturation
=
parse_none_or
(
arguments
|
p
|
color_parser
.
parse_number_or_percentage
(
p
)
)
?
.
map
(
|
v
|
v
.
to_number
(
SATURATION_RANGE
)
)
;
lightness
=
parse_none_or
(
arguments
|
p
|
color_parser
.
parse_number_or_percentage
(
p
)
)
?
.
map
(
|
v
|
v
.
to_number
(
LIGHTNESS_RANGE
)
)
;
parse_modern_alpha
(
color_parser
arguments
)
?
}
;
let
hue
=
maybe_hue
.
map
(
|
h
|
normalize_hue
(
h
.
degrees
(
)
)
)
;
let
saturation
=
saturation
.
map
(
|
s
|
s
.
clamp
(
0
.
0
SATURATION_RANGE
)
)
;
let
lightness
=
lightness
.
map
(
|
l
|
l
.
clamp
(
0
.
0
LIGHTNESS_RANGE
)
)
;
Ok
(
P
:
:
Output
:
:
from_hsl
(
hue
saturation
lightness
alpha
)
)
}
#
[
inline
]
fn
parse_hwb
<
'
i
'
t
P
>
(
color_parser
:
&
P
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
P
:
:
Output
ParseError
<
'
i
>
>
where
P
:
ColorParser
<
'
i
>
{
const
WHITENESS_RANGE
:
f32
=
100
.
0
;
const
BLACKNESS_RANGE
:
f32
=
100
.
0
;
let
(
hue
whiteness
blackness
alpha
)
=
parse_components
(
color_parser
arguments
P
:
:
parse_number_or_angle
P
:
:
parse_number_or_percentage
P
:
:
parse_number_or_percentage
)
?
;
let
hue
=
hue
.
map
(
|
h
|
normalize_hue
(
h
.
degrees
(
)
)
)
;
let
whiteness
=
whiteness
.
map
(
|
w
|
w
.
to_number
(
WHITENESS_RANGE
)
.
clamp
(
0
.
0
WHITENESS_RANGE
)
)
;
let
blackness
=
blackness
.
map
(
|
b
|
b
.
to_number
(
BLACKNESS_RANGE
)
.
clamp
(
0
.
0
BLACKNESS_RANGE
)
)
;
Ok
(
P
:
:
Output
:
:
from_hwb
(
hue
whiteness
blackness
alpha
)
)
}
type
IntoColorFn
<
Output
>
=
fn
(
l
:
Option
<
f32
>
a
:
Option
<
f32
>
b
:
Option
<
f32
>
alpha
:
Option
<
f32
>
)
-
>
Output
;
#
[
inline
]
fn
parse_lab_like
<
'
i
'
t
P
>
(
color_parser
:
&
P
arguments
:
&
mut
Parser
<
'
i
'
t
>
lightness_range
:
f32
a_b_range
:
f32
into_color
:
IntoColorFn
<
P
:
:
Output
>
)
-
>
Result
<
P
:
:
Output
ParseError
<
'
i
>
>
where
P
:
ColorParser
<
'
i
>
{
let
(
lightness
a
b
alpha
)
=
parse_components
(
color_parser
arguments
P
:
:
parse_number_or_percentage
P
:
:
parse_number_or_percentage
P
:
:
parse_number_or_percentage
)
?
;
let
lightness
=
lightness
.
map
(
|
l
|
l
.
to_number
(
lightness_range
)
)
;
let
a
=
a
.
map
(
|
a
|
a
.
to_number
(
a_b_range
)
)
;
let
b
=
b
.
map
(
|
b
|
b
.
to_number
(
a_b_range
)
)
;
Ok
(
into_color
(
lightness
a
b
alpha
)
)
}
#
[
inline
]
fn
parse_lch_like
<
'
i
'
t
P
>
(
color_parser
:
&
P
arguments
:
&
mut
Parser
<
'
i
'
t
>
lightness_range
:
f32
chroma_range
:
f32
into_color
:
IntoColorFn
<
P
:
:
Output
>
)
-
>
Result
<
P
:
:
Output
ParseError
<
'
i
>
>
where
P
:
ColorParser
<
'
i
>
{
let
(
lightness
chroma
hue
alpha
)
=
parse_components
(
color_parser
arguments
P
:
:
parse_number_or_percentage
P
:
:
parse_number_or_percentage
P
:
:
parse_number_or_angle
)
?
;
let
lightness
=
lightness
.
map
(
|
l
|
l
.
to_number
(
lightness_range
)
)
;
let
chroma
=
chroma
.
map
(
|
c
|
c
.
to_number
(
chroma_range
)
)
;
let
hue
=
hue
.
map
(
|
h
|
normalize_hue
(
h
.
degrees
(
)
)
)
;
Ok
(
into_color
(
lightness
chroma
hue
alpha
)
)
}
#
[
inline
]
fn
parse_color_with_color_space
<
'
i
'
t
P
>
(
color_parser
:
&
P
arguments
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
P
:
:
Output
ParseError
<
'
i
>
>
where
P
:
ColorParser
<
'
i
>
{
let
color_space
=
{
let
location
=
arguments
.
current_source_location
(
)
;
let
ident
=
arguments
.
expect_ident
(
)
?
;
PredefinedColorSpace
:
:
from_str
(
ident
)
.
map_err
(
|
_
|
location
.
new_unexpected_token_error
(
Token
:
:
Ident
(
ident
.
clone
(
)
)
)
)
?
}
;
let
(
c1
c2
c3
alpha
)
=
parse_components
(
color_parser
arguments
P
:
:
parse_number_or_percentage
P
:
:
parse_number_or_percentage
P
:
:
parse_number_or_percentage
)
?
;
let
c1
=
c1
.
map
(
|
c
|
c
.
to_number
(
1
.
0
)
)
;
let
c2
=
c2
.
map
(
|
c
|
c
.
to_number
(
1
.
0
)
)
;
let
c3
=
c3
.
map
(
|
c
|
c
.
to_number
(
1
.
0
)
)
;
Ok
(
P
:
:
Output
:
:
from_color_function
(
color_space
c1
c2
c3
alpha
)
)
}
type
ComponentParseResult
<
'
i
R1
R2
R3
>
=
Result
<
(
Option
<
R1
>
Option
<
R2
>
Option
<
R3
>
Option
<
f32
>
)
ParseError
<
'
i
>
>
;
pub
fn
parse_components
<
'
i
'
t
P
F1
F2
F3
R1
R2
R3
>
(
color_parser
:
&
P
input
:
&
mut
Parser
<
'
i
'
t
>
f1
:
F1
f2
:
F2
f3
:
F3
)
-
>
ComponentParseResult
<
'
i
R1
R2
R3
>
where
P
:
ColorParser
<
'
i
>
F1
:
FnOnce
(
&
P
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
R1
ParseError
<
'
i
>
>
F2
:
FnOnce
(
&
P
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
R2
ParseError
<
'
i
>
>
F3
:
FnOnce
(
&
P
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
R3
ParseError
<
'
i
>
>
{
let
r1
=
parse_none_or
(
input
|
p
|
f1
(
color_parser
p
)
)
?
;
let
r2
=
parse_none_or
(
input
|
p
|
f2
(
color_parser
p
)
)
?
;
let
r3
=
parse_none_or
(
input
|
p
|
f3
(
color_parser
p
)
)
?
;
let
alpha
=
parse_modern_alpha
(
color_parser
input
)
?
;
Ok
(
(
r1
r2
r3
alpha
)
)
}
fn
parse_none_or
<
'
i
'
t
F
T
E
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
thing
:
F
)
-
>
Result
<
Option
<
T
>
E
>
where
F
:
FnOnce
(
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
T
E
>
{
match
input
.
try_parse
(
|
p
|
p
.
expect_ident_matching
(
"
none
"
)
)
{
Ok
(
_
)
=
>
Ok
(
None
)
Err
(
_
)
=
>
Ok
(
Some
(
thing
(
input
)
?
)
)
}
}
pub
enum
NumberOrPercentage
{
Number
{
value
:
f32
}
Percentage
{
unit_value
:
f32
}
}
impl
NumberOrPercentage
{
pub
fn
to_number
(
&
self
percentage_basis
:
f32
)
-
>
f32
{
match
*
self
{
Self
:
:
Number
{
value
}
=
>
value
Self
:
:
Percentage
{
unit_value
}
=
>
unit_value
*
percentage_basis
}
}
}
pub
enum
NumberOrAngle
{
Number
{
value
:
f32
}
Angle
{
degrees
:
f32
}
}
impl
NumberOrAngle
{
pub
fn
degrees
(
&
self
)
-
>
f32
{
match
*
self
{
Self
:
:
Number
{
value
}
=
>
value
Self
:
:
Angle
{
degrees
}
=
>
degrees
}
}
}
pub
trait
ColorParser
<
'
i
>
{
type
Output
:
FromParsedColor
;
fn
parse_number_or_angle
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
NumberOrAngle
ParseError
<
'
i
>
>
;
fn
parse_percentage
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
f32
ParseError
<
'
i
>
>
;
fn
parse_number
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
f32
ParseError
<
'
i
>
>
;
fn
parse_number_or_percentage
<
'
t
>
(
&
self
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
NumberOrPercentage
ParseError
<
'
i
>
>
;
}
pub
trait
FromParsedColor
{
fn
from_current_color
(
)
-
>
Self
;
fn
from_rgba
(
red
:
u8
green
:
u8
blue
:
u8
alpha
:
f32
)
-
>
Self
;
fn
from_hsl
(
hue
:
Option
<
f32
>
saturation
:
Option
<
f32
>
lightness
:
Option
<
f32
>
alpha
:
Option
<
f32
>
)
-
>
Self
;
fn
from_hwb
(
hue
:
Option
<
f32
>
whiteness
:
Option
<
f32
>
blackness
:
Option
<
f32
>
alpha
:
Option
<
f32
>
)
-
>
Self
;
fn
from_lab
(
lightness
:
Option
<
f32
>
a
:
Option
<
f32
>
b
:
Option
<
f32
>
alpha
:
Option
<
f32
>
)
-
>
Self
;
fn
from_lch
(
lightness
:
Option
<
f32
>
chroma
:
Option
<
f32
>
hue
:
Option
<
f32
>
alpha
:
Option
<
f32
>
)
-
>
Self
;
fn
from_oklab
(
lightness
:
Option
<
f32
>
a
:
Option
<
f32
>
b
:
Option
<
f32
>
alpha
:
Option
<
f32
>
)
-
>
Self
;
fn
from_oklch
(
lightness
:
Option
<
f32
>
chroma
:
Option
<
f32
>
hue
:
Option
<
f32
>
alpha
:
Option
<
f32
>
)
-
>
Self
;
fn
from_color_function
(
color_space
:
PredefinedColorSpace
c1
:
Option
<
f32
>
c2
:
Option
<
f32
>
c3
:
Option
<
f32
>
alpha
:
Option
<
f32
>
)
-
>
Self
;
}
