#
!
[
deny
(
missing_docs
)
]
use
cssparser
:
:
{
AtRuleParser
Parser
QualifiedRuleParser
RuleListParser
}
;
use
cssparser
:
:
{
DeclarationListParser
DeclarationParser
parse_one_rule
}
;
use
parking_lot
:
:
RwLock
;
use
parser
:
:
{
ParserContext
ParserContextExtraData
log_css_error
}
;
use
properties
:
:
{
Importance
PropertyDeclaration
PropertyDeclarationBlock
PropertyId
}
;
use
properties
:
:
{
PropertyDeclarationId
LonghandId
DeclaredValue
ParsedDeclaration
}
;
use
properties
:
:
LonghandIdSet
;
use
properties
:
:
animated_properties
:
:
TransitionProperty
;
use
properties
:
:
longhands
:
:
transition_timing_function
:
:
single_value
:
:
SpecifiedValue
as
SpecifiedTimingFunction
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
Arc
;
use
style_traits
:
:
ToCss
;
use
stylesheets
:
:
{
MemoryHoleReporter
Stylesheet
}
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
KeyframePercentage
(
pub
f32
)
;
impl
:
:
std
:
:
cmp
:
:
Ord
for
KeyframePercentage
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
:
:
std
:
:
cmp
:
:
Ordering
{
self
.
0
.
partial_cmp
(
&
other
.
0
)
.
unwrap
(
)
}
}
impl
:
:
std
:
:
cmp
:
:
Eq
for
KeyframePercentage
{
}
impl
ToCss
for
KeyframePercentage
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
write
!
(
dest
"
{
}
%
"
self
.
0
*
100
.
0
)
}
}
impl
KeyframePercentage
{
#
[
inline
]
pub
fn
new
(
value
:
f32
)
-
>
KeyframePercentage
{
debug_assert
!
(
value
>
=
0
.
&
&
value
<
=
1
.
)
;
KeyframePercentage
(
value
)
}
fn
parse
(
input
:
&
mut
Parser
)
-
>
Result
<
KeyframePercentage
(
)
>
{
let
percentage
=
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
from
"
)
)
.
is_ok
(
)
{
KeyframePercentage
:
:
new
(
0
.
)
}
else
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
to
"
)
)
.
is_ok
(
)
{
KeyframePercentage
:
:
new
(
1
.
)
}
else
{
let
percentage
=
try
!
(
input
.
expect_percentage
(
)
)
;
if
percentage
>
=
0
.
&
&
percentage
<
=
1
.
{
KeyframePercentage
:
:
new
(
percentage
)
}
else
{
return
Err
(
(
)
)
;
}
}
;
Ok
(
percentage
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
KeyframeSelector
(
Vec
<
KeyframePercentage
>
)
;
impl
KeyframeSelector
{
#
[
inline
]
pub
fn
percentages
(
&
self
)
-
>
&
[
KeyframePercentage
]
{
&
self
.
0
}
pub
fn
new_for_unit_testing
(
percentages
:
Vec
<
KeyframePercentage
>
)
-
>
KeyframeSelector
{
KeyframeSelector
(
percentages
)
}
pub
fn
parse
(
input
:
&
mut
Parser
)
-
>
Result
<
Self
(
)
>
{
input
.
parse_comma_separated
(
KeyframePercentage
:
:
parse
)
.
map
(
KeyframeSelector
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Keyframe
{
pub
selector
:
KeyframeSelector
pub
block
:
Arc
<
RwLock
<
PropertyDeclarationBlock
>
>
}
impl
ToCss
for
Keyframe
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
let
mut
iter
=
self
.
selector
.
percentages
(
)
.
iter
(
)
;
try
!
(
iter
.
next
(
)
.
unwrap
(
)
.
to_css
(
dest
)
)
;
for
percentage
in
iter
{
try
!
(
write
!
(
dest
"
"
)
)
;
try
!
(
percentage
.
to_css
(
dest
)
)
;
}
try
!
(
dest
.
write_str
(
"
{
"
)
)
;
try
!
(
self
.
block
.
read
(
)
.
to_css
(
dest
)
)
;
try
!
(
dest
.
write_str
(
"
}
"
)
)
;
Ok
(
(
)
)
}
}
impl
Keyframe
{
pub
fn
parse
(
css
:
&
str
parent_stylesheet
:
&
Stylesheet
extra_data
:
ParserContextExtraData
)
-
>
Result
<
Arc
<
RwLock
<
Self
>
>
(
)
>
{
let
error_reporter
=
Box
:
:
new
(
MemoryHoleReporter
)
;
let
context
=
ParserContext
:
:
new_with_extra_data
(
parent_stylesheet
.
origin
&
parent_stylesheet
.
base_url
error_reporter
extra_data
)
;
let
mut
input
=
Parser
:
:
new
(
css
)
;
let
mut
rule_parser
=
KeyframeListParser
{
context
:
&
context
}
;
parse_one_rule
(
&
mut
input
&
mut
rule_parser
)
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
KeyframesStepValue
{
Declarations
{
#
[
cfg_attr
(
feature
=
"
servo
"
ignore_heap_size_of
=
"
Arc
"
)
]
block
:
Arc
<
RwLock
<
PropertyDeclarationBlock
>
>
}
ComputedValues
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
KeyframesStep
{
pub
start_percentage
:
KeyframePercentage
pub
value
:
KeyframesStepValue
pub
declared_timing_function
:
bool
}
impl
KeyframesStep
{
#
[
inline
]
fn
new
(
percentage
:
KeyframePercentage
value
:
KeyframesStepValue
)
-
>
Self
{
let
declared_timing_function
=
match
value
{
KeyframesStepValue
:
:
Declarations
{
ref
block
}
=
>
{
block
.
read
(
)
.
declarations
(
)
.
iter
(
)
.
any
(
|
&
(
ref
prop_decl
_
)
|
{
match
*
prop_decl
{
PropertyDeclaration
:
:
AnimationTimingFunction
(
.
.
)
=
>
true
_
=
>
false
}
}
)
}
_
=
>
false
}
;
KeyframesStep
{
start_percentage
:
percentage
value
:
value
declared_timing_function
:
declared_timing_function
}
}
pub
fn
get_animation_timing_function
(
&
self
)
-
>
Option
<
SpecifiedTimingFunction
>
{
if
!
self
.
declared_timing_function
{
return
None
;
}
match
self
.
value
{
KeyframesStepValue
:
:
Declarations
{
ref
block
}
=
>
{
let
guard
=
block
.
read
(
)
;
let
&
(
ref
declaration
_
)
=
guard
.
get
(
PropertyDeclarationId
:
:
Longhand
(
LonghandId
:
:
AnimationTimingFunction
)
)
.
unwrap
(
)
;
match
*
declaration
{
PropertyDeclaration
:
:
AnimationTimingFunction
(
ref
value
)
=
>
{
match
*
value
{
DeclaredValue
:
:
Value
(
ref
value
)
=
>
{
Some
(
value
.
0
[
0
]
)
}
_
=
>
None
}
}
_
=
>
panic
!
(
)
}
}
KeyframesStepValue
:
:
ComputedValues
=
>
{
panic
!
(
"
Shouldn
'
t
happen
to
set
animation
-
timing
-
function
in
missing
keyframes
"
)
}
}
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
KeyframesAnimation
{
pub
steps
:
Vec
<
KeyframesStep
>
pub
properties_changed
:
Vec
<
TransitionProperty
>
}
fn
get_animated_properties
(
keyframes
:
&
[
Arc
<
RwLock
<
Keyframe
>
>
]
)
-
>
Vec
<
TransitionProperty
>
{
let
mut
ret
=
vec
!
[
]
;
let
mut
seen
=
LonghandIdSet
:
:
new
(
)
;
for
keyframe
in
keyframes
{
let
keyframe
=
keyframe
.
read
(
)
;
for
&
(
ref
declaration
importance
)
in
keyframe
.
block
.
read
(
)
.
declarations
(
)
.
iter
(
)
{
assert
!
(
!
importance
.
important
(
)
)
;
if
let
Some
(
property
)
=
TransitionProperty
:
:
from_declaration
(
declaration
)
{
if
!
seen
.
has_transition_property_bit
(
&
property
)
{
ret
.
push
(
property
)
;
seen
.
set_transition_property_bit
(
&
property
)
;
}
}
}
}
ret
}
impl
KeyframesAnimation
{
pub
fn
from_keyframes
(
keyframes
:
&
[
Arc
<
RwLock
<
Keyframe
>
>
]
)
-
>
Self
{
let
mut
result
=
KeyframesAnimation
{
steps
:
vec
!
[
]
properties_changed
:
vec
!
[
]
}
;
if
keyframes
.
is_empty
(
)
{
return
result
;
}
result
.
properties_changed
=
get_animated_properties
(
keyframes
)
;
if
result
.
properties_changed
.
is_empty
(
)
{
return
result
;
}
for
keyframe
in
keyframes
{
let
keyframe
=
keyframe
.
read
(
)
;
for
percentage
in
keyframe
.
selector
.
0
.
iter
(
)
{
result
.
steps
.
push
(
KeyframesStep
:
:
new
(
*
percentage
KeyframesStepValue
:
:
Declarations
{
block
:
keyframe
.
block
.
clone
(
)
}
)
)
;
}
}
result
.
steps
.
sort_by_key
(
|
step
|
step
.
start_percentage
)
;
if
result
.
steps
[
0
]
.
start_percentage
.
0
!
=
0
.
{
result
.
steps
.
insert
(
0
KeyframesStep
:
:
new
(
KeyframePercentage
:
:
new
(
0
.
)
KeyframesStepValue
:
:
ComputedValues
)
)
;
}
if
result
.
steps
.
last
(
)
.
unwrap
(
)
.
start_percentage
.
0
!
=
1
.
{
result
.
steps
.
push
(
KeyframesStep
:
:
new
(
KeyframePercentage
:
:
new
(
1
.
)
KeyframesStepValue
:
:
ComputedValues
)
)
;
}
result
}
}
struct
KeyframeListParser
<
'
a
>
{
context
:
&
'
a
ParserContext
<
'
a
>
}
pub
fn
parse_keyframe_list
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Vec
<
Arc
<
RwLock
<
Keyframe
>
>
>
{
RuleListParser
:
:
new_for_nested_rule
(
input
KeyframeListParser
{
context
:
context
}
)
.
filter_map
(
Result
:
:
ok
)
.
collect
(
)
}
enum
Void
{
}
impl
<
'
a
>
AtRuleParser
for
KeyframeListParser
<
'
a
>
{
type
Prelude
=
Void
;
type
AtRule
=
Arc
<
RwLock
<
Keyframe
>
>
;
}
impl
<
'
a
>
QualifiedRuleParser
for
KeyframeListParser
<
'
a
>
{
type
Prelude
=
KeyframeSelector
;
type
QualifiedRule
=
Arc
<
RwLock
<
Keyframe
>
>
;
fn
parse_prelude
(
&
mut
self
input
:
&
mut
Parser
)
-
>
Result
<
Self
:
:
Prelude
(
)
>
{
let
start
=
input
.
position
(
)
;
match
KeyframeSelector
:
:
parse
(
input
)
{
Ok
(
sel
)
=
>
Ok
(
sel
)
Err
(
(
)
)
=
>
{
let
message
=
format
!
(
"
Invalid
keyframe
rule
:
'
{
}
'
"
input
.
slice_from
(
start
)
)
;
log_css_error
(
input
start
&
message
self
.
context
)
;
Err
(
(
)
)
}
}
}
fn
parse_block
(
&
mut
self
prelude
:
Self
:
:
Prelude
input
:
&
mut
Parser
)
-
>
Result
<
Self
:
:
QualifiedRule
(
)
>
{
let
parser
=
KeyframeDeclarationParser
{
context
:
self
.
context
}
;
let
mut
iter
=
DeclarationListParser
:
:
new
(
input
parser
)
;
let
mut
block
=
PropertyDeclarationBlock
:
:
new
(
)
;
while
let
Some
(
declaration
)
=
iter
.
next
(
)
{
match
declaration
{
Ok
(
parsed
)
=
>
parsed
.
expand
(
|
d
|
block
.
push
(
d
Importance
:
:
Normal
)
)
Err
(
range
)
=
>
{
let
pos
=
range
.
start
;
let
message
=
format
!
(
"
Unsupported
keyframe
property
declaration
:
'
{
}
'
"
iter
.
input
.
slice
(
range
)
)
;
log_css_error
(
iter
.
input
pos
&
*
message
self
.
context
)
;
}
}
}
Ok
(
Arc
:
:
new
(
RwLock
:
:
new
(
Keyframe
{
selector
:
prelude
block
:
Arc
:
:
new
(
RwLock
:
:
new
(
block
)
)
}
)
)
)
}
}
struct
KeyframeDeclarationParser
<
'
a
'
b
:
'
a
>
{
context
:
&
'
a
ParserContext
<
'
b
>
}
impl
<
'
a
'
b
>
AtRuleParser
for
KeyframeDeclarationParser
<
'
a
'
b
>
{
type
Prelude
=
(
)
;
type
AtRule
=
ParsedDeclaration
;
}
impl
<
'
a
'
b
>
DeclarationParser
for
KeyframeDeclarationParser
<
'
a
'
b
>
{
type
Declaration
=
ParsedDeclaration
;
fn
parse_value
(
&
mut
self
name
:
&
str
input
:
&
mut
Parser
)
-
>
Result
<
ParsedDeclaration
(
)
>
{
let
id
=
try
!
(
PropertyId
:
:
parse
(
name
.
into
(
)
)
)
;
match
ParsedDeclaration
:
:
parse
(
id
self
.
context
input
true
)
{
Ok
(
parsed
)
=
>
{
if
!
input
.
is_exhausted
(
)
{
Err
(
(
)
)
}
else
{
Ok
(
parsed
)
}
}
Err
(
_
)
=
>
Err
(
(
)
)
}
}
}
