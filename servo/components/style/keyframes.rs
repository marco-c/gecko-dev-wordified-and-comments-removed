use
cssparser
:
:
{
AtRuleParser
Delimiter
Parser
QualifiedRuleParser
RuleListParser
}
;
use
parser
:
:
{
ParserContext
log_css_error
}
;
use
properties
:
:
animated_properties
:
:
TransitionProperty
;
use
properties
:
:
{
PropertyDeclaration
parse_property_declaration_list
}
;
use
std
:
:
sync
:
:
Arc
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
PartialOrd
HeapSizeOf
)
]
pub
struct
KeyframePercentage
(
pub
f32
)
;
impl
:
:
std
:
:
cmp
:
:
Ord
for
KeyframePercentage
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
:
:
std
:
:
cmp
:
:
Ordering
{
self
.
0
.
partial_cmp
(
&
other
.
0
)
.
unwrap
(
)
}
}
impl
:
:
std
:
:
cmp
:
:
Eq
for
KeyframePercentage
{
}
impl
KeyframePercentage
{
#
[
inline
]
pub
fn
new
(
value
:
f32
)
-
>
KeyframePercentage
{
debug_assert
!
(
value
>
=
0
.
&
&
value
<
=
1
.
)
;
KeyframePercentage
(
value
)
}
fn
parse
(
input
:
&
mut
Parser
)
-
>
Result
<
KeyframePercentage
(
)
>
{
let
percentage
=
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
from
"
)
)
.
is_ok
(
)
{
KeyframePercentage
:
:
new
(
0
.
)
}
else
if
input
.
try
(
|
input
|
input
.
expect_ident_matching
(
"
to
"
)
)
.
is_ok
(
)
{
KeyframePercentage
:
:
new
(
1
.
)
}
else
{
let
percentage
=
try
!
(
input
.
expect_percentage
(
)
)
;
if
percentage
>
1
.
|
|
percentage
<
0
.
{
return
Err
(
(
)
)
;
}
KeyframePercentage
:
:
new
(
percentage
)
}
;
Ok
(
percentage
)
}
}
#
[
derive
(
Debug
Clone
PartialEq
HeapSizeOf
)
]
pub
struct
KeyframeSelector
(
Vec
<
KeyframePercentage
>
)
;
impl
KeyframeSelector
{
#
[
inline
]
pub
fn
percentages
(
&
self
)
-
>
&
[
KeyframePercentage
]
{
&
self
.
0
}
pub
fn
new_for_unit_testing
(
percentages
:
Vec
<
KeyframePercentage
>
)
-
>
KeyframeSelector
{
KeyframeSelector
(
percentages
)
}
}
#
[
derive
(
Debug
Clone
PartialEq
HeapSizeOf
)
]
pub
struct
Keyframe
{
pub
selector
:
KeyframeSelector
pub
declarations
:
Arc
<
Vec
<
PropertyDeclaration
>
>
}
impl
Keyframe
{
pub
fn
parse
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Result
<
Keyframe
(
)
>
{
let
percentages
=
try
!
(
input
.
parse_until_before
(
Delimiter
:
:
CurlyBracketBlock
|
input
|
{
input
.
parse_comma_separated
(
|
input
|
KeyframePercentage
:
:
parse
(
input
)
)
}
)
)
;
let
selector
=
KeyframeSelector
(
percentages
)
;
try
!
(
input
.
expect_curly_bracket_block
(
)
)
;
let
declarations
=
input
.
parse_nested_block
(
|
input
|
{
Ok
(
parse_property_declaration_list
(
context
input
)
)
}
)
.
unwrap
(
)
;
Ok
(
Keyframe
{
selector
:
selector
declarations
:
declarations
.
normal
}
)
}
}
#
[
derive
(
Debug
Clone
PartialEq
HeapSizeOf
)
]
pub
enum
KeyframesStepValue
{
Declarations
(
Arc
<
Vec
<
PropertyDeclaration
>
>
)
ComputedValues
}
#
[
derive
(
Debug
Clone
PartialEq
HeapSizeOf
)
]
pub
struct
KeyframesStep
{
pub
start_percentage
:
KeyframePercentage
pub
value
:
KeyframesStepValue
}
impl
KeyframesStep
{
#
[
inline
]
fn
new
(
percentage
:
KeyframePercentage
value
:
KeyframesStepValue
)
-
>
Self
{
KeyframesStep
{
start_percentage
:
percentage
value
:
value
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
HeapSizeOf
)
]
pub
struct
KeyframesAnimation
{
pub
steps
:
Vec
<
KeyframesStep
>
pub
properties_changed
:
Vec
<
TransitionProperty
>
}
fn
get_animated_properties
(
keyframe
:
&
Keyframe
)
-
>
Vec
<
TransitionProperty
>
{
let
mut
ret
=
vec
!
[
]
;
for
declaration
in
keyframe
.
declarations
.
iter
(
)
{
if
let
Some
(
property
)
=
TransitionProperty
:
:
from_declaration
(
&
declaration
)
{
ret
.
push
(
property
)
;
}
}
ret
}
impl
KeyframesAnimation
{
pub
fn
from_keyframes
(
keyframes
:
&
[
Keyframe
]
)
-
>
Option
<
Self
>
{
if
keyframes
.
is_empty
(
)
{
return
None
;
}
let
animated_properties
=
get_animated_properties
(
&
keyframes
[
0
]
)
;
if
animated_properties
.
is_empty
(
)
{
return
None
;
}
let
mut
steps
=
vec
!
[
]
;
for
keyframe
in
keyframes
{
for
percentage
in
keyframe
.
selector
.
0
.
iter
(
)
{
steps
.
push
(
KeyframesStep
:
:
new
(
*
percentage
KeyframesStepValue
:
:
Declarations
(
keyframe
.
declarations
.
clone
(
)
)
)
)
;
}
}
steps
.
sort_by_key
(
|
step
|
step
.
start_percentage
)
;
if
steps
[
0
]
.
start_percentage
.
0
!
=
0
.
{
steps
.
insert
(
0
KeyframesStep
:
:
new
(
KeyframePercentage
:
:
new
(
0
.
)
KeyframesStepValue
:
:
ComputedValues
)
)
;
}
if
steps
.
last
(
)
.
unwrap
(
)
.
start_percentage
.
0
!
=
1
.
{
steps
.
push
(
KeyframesStep
:
:
new
(
KeyframePercentage
:
:
new
(
0
.
)
KeyframesStepValue
:
:
ComputedValues
)
)
;
}
Some
(
KeyframesAnimation
{
steps
:
steps
properties_changed
:
animated_properties
}
)
}
}
struct
KeyframeListParser
<
'
a
>
{
context
:
&
'
a
ParserContext
<
'
a
>
}
pub
fn
parse_keyframe_list
(
context
:
&
ParserContext
input
:
&
mut
Parser
)
-
>
Vec
<
Keyframe
>
{
RuleListParser
:
:
new_for_nested_rule
(
input
KeyframeListParser
{
context
:
context
}
)
.
filter_map
(
Result
:
:
ok
)
.
collect
(
)
}
enum
Void
{
}
impl
<
'
a
>
AtRuleParser
for
KeyframeListParser
<
'
a
>
{
type
Prelude
=
Void
;
type
AtRule
=
Keyframe
;
}
impl
<
'
a
>
QualifiedRuleParser
for
KeyframeListParser
<
'
a
>
{
type
Prelude
=
KeyframeSelector
;
type
QualifiedRule
=
Keyframe
;
fn
parse_prelude
(
&
self
input
:
&
mut
Parser
)
-
>
Result
<
Self
:
:
Prelude
(
)
>
{
let
start
=
input
.
position
(
)
;
match
input
.
parse_comma_separated
(
|
input
|
KeyframePercentage
:
:
parse
(
input
)
)
{
Ok
(
percentages
)
=
>
Ok
(
KeyframeSelector
(
percentages
)
)
Err
(
(
)
)
=
>
{
let
message
=
format
!
(
"
Invalid
keyframe
rule
:
'
{
}
'
"
input
.
slice_from
(
start
)
)
;
log_css_error
(
input
start
&
message
self
.
context
)
;
Err
(
(
)
)
}
}
}
fn
parse_block
(
&
self
prelude
:
Self
:
:
Prelude
input
:
&
mut
Parser
)
-
>
Result
<
Self
:
:
QualifiedRule
(
)
>
{
Ok
(
Keyframe
{
selector
:
prelude
declarations
:
parse_property_declaration_list
(
self
.
context
input
)
.
normal
}
)
}
}
