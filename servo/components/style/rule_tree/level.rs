#
!
[
forbid
(
unsafe_code
)
]
use
crate
:
:
properties
:
:
Importance
;
use
crate
:
:
shared_lock
:
:
{
SharedRwLockReadGuard
StylesheetGuards
}
;
use
crate
:
:
stylesheets
:
:
Origin
;
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
PartialOrd
)
]
pub
enum
CascadeLevel
{
UANormal
UserNormal
PresHints
AuthorNormal
{
shadow_cascade_order
:
ShadowCascadeOrder
}
SMILOverride
Animations
AuthorImportant
{
shadow_cascade_order
:
ShadowCascadeOrder
}
UserImportant
UAImportant
Transitions
}
impl
CascadeLevel
{
#
[
inline
]
pub
fn
to_byte_lossy
(
&
self
)
-
>
u8
{
let
(
discriminant
order
)
=
match
*
self
{
Self
:
:
UANormal
=
>
(
0
0
)
Self
:
:
UserNormal
=
>
(
1
0
)
Self
:
:
PresHints
=
>
(
2
0
)
Self
:
:
AuthorNormal
{
shadow_cascade_order
}
=
>
(
3
shadow_cascade_order
.
0
)
Self
:
:
SMILOverride
=
>
(
4
0
)
Self
:
:
Animations
=
>
(
5
0
)
Self
:
:
AuthorImportant
{
shadow_cascade_order
}
=
>
(
6
shadow_cascade_order
.
0
)
Self
:
:
UserImportant
=
>
(
7
0
)
Self
:
:
UAImportant
=
>
(
8
0
)
Self
:
:
Transitions
=
>
(
9
0
)
}
;
debug_assert_eq
!
(
discriminant
&
0xf
discriminant
)
;
if
order
=
=
0
{
return
discriminant
;
}
let
negative
=
order
<
0
;
let
value
=
std
:
:
cmp
:
:
min
(
order
.
abs
(
)
as
u8
0b111
)
;
(
negative
as
u8
)
<
<
7
|
value
<
<
4
|
discriminant
}
#
[
inline
]
pub
fn
from_byte
(
b
:
u8
)
-
>
Self
{
let
order
=
{
let
abs
=
(
(
b
&
0b01110000
)
>
>
4
)
as
i8
;
let
negative
=
b
&
0b10000000
!
=
0
;
if
negative
{
-
abs
}
else
{
abs
}
}
;
let
discriminant
=
b
&
0xf
;
let
level
=
match
discriminant
{
0
=
>
Self
:
:
UANormal
1
=
>
Self
:
:
UserNormal
2
=
>
Self
:
:
PresHints
3
=
>
{
return
Self
:
:
AuthorNormal
{
shadow_cascade_order
:
ShadowCascadeOrder
(
order
)
}
}
4
=
>
Self
:
:
SMILOverride
5
=
>
Self
:
:
Animations
6
=
>
{
return
Self
:
:
AuthorImportant
{
shadow_cascade_order
:
ShadowCascadeOrder
(
order
)
}
}
7
=
>
Self
:
:
UserImportant
8
=
>
Self
:
:
UAImportant
9
=
>
Self
:
:
Transitions
_
=
>
unreachable
!
(
"
Didn
'
t
expect
{
}
as
a
discriminant
"
discriminant
)
}
;
debug_assert_eq
!
(
order
0
"
Didn
'
t
expect
an
order
value
for
{
:
?
}
"
level
)
;
level
}
pub
fn
guard
<
'
a
>
(
&
self
guards
:
&
'
a
StylesheetGuards
<
'
a
>
)
-
>
&
'
a
SharedRwLockReadGuard
<
'
a
>
{
match
*
self
{
Self
:
:
UANormal
|
Self
:
:
UserNormal
|
Self
:
:
UserImportant
|
Self
:
:
UAImportant
=
>
{
guards
.
ua_or_user
}
_
=
>
guards
.
author
}
}
#
[
inline
]
pub
fn
same_tree_author_important
(
)
-
>
Self
{
Self
:
:
AuthorImportant
{
shadow_cascade_order
:
ShadowCascadeOrder
:
:
for_same_tree
(
)
}
}
#
[
inline
]
pub
fn
same_tree_author_normal
(
)
-
>
Self
{
Self
:
:
AuthorNormal
{
shadow_cascade_order
:
ShadowCascadeOrder
:
:
for_same_tree
(
)
}
}
#
[
inline
]
pub
fn
is_important
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
AuthorImportant
{
.
.
}
|
Self
:
:
UserImportant
|
Self
:
:
UAImportant
=
>
true
_
=
>
false
}
}
#
[
inline
]
pub
fn
importance
(
&
self
)
-
>
Importance
{
if
self
.
is_important
(
)
{
Importance
:
:
Important
}
else
{
Importance
:
:
Normal
}
}
#
[
inline
]
pub
fn
origin
(
&
self
)
-
>
Origin
{
match
*
self
{
Self
:
:
UAImportant
|
Self
:
:
UANormal
=
>
Origin
:
:
UserAgent
Self
:
:
UserImportant
|
Self
:
:
UserNormal
=
>
Origin
:
:
User
Self
:
:
PresHints
|
Self
:
:
AuthorNormal
{
.
.
}
|
Self
:
:
AuthorImportant
{
.
.
}
|
Self
:
:
SMILOverride
|
Self
:
:
Animations
|
Self
:
:
Transitions
=
>
Origin
:
:
Author
}
}
#
[
inline
]
pub
fn
is_animation
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
SMILOverride
|
Self
:
:
Animations
|
Self
:
:
Transitions
=
>
true
_
=
>
false
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Ord
PartialEq
PartialOrd
)
]
pub
struct
ShadowCascadeOrder
(
i8
)
;
impl
ShadowCascadeOrder
{
#
[
inline
]
pub
fn
for_outermost_shadow_tree
(
)
-
>
Self
{
Self
(
-
1
)
}
#
[
inline
]
fn
for_same_tree
(
)
-
>
Self
{
Self
(
0
)
}
#
[
inline
]
pub
fn
for_innermost_containing_tree
(
)
-
>
Self
{
Self
(
1
)
}
#
[
inline
]
pub
fn
dec
(
&
mut
self
)
{
debug_assert
!
(
self
.
0
<
0
)
;
self
.
0
=
self
.
0
.
saturating_sub
(
1
)
;
}
#
[
inline
]
pub
fn
inc
(
&
mut
self
)
{
debug_assert_ne
!
(
self
.
0
-
1
)
;
self
.
0
=
self
.
0
.
saturating_add
(
1
)
;
}
}
impl
std
:
:
ops
:
:
Neg
for
ShadowCascadeOrder
{
type
Output
=
Self
;
#
[
inline
]
fn
neg
(
self
)
-
>
Self
{
Self
(
self
.
0
.
neg
(
)
)
}
}
