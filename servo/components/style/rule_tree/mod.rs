#
!
[
allow
(
unsafe_code
)
]
use
crate
:
:
applicable_declarations
:
:
ApplicableDeclarationList
;
use
crate
:
:
hash
:
:
FxHashMap
;
use
crate
:
:
properties
:
:
{
Importance
LonghandIdSet
PropertyDeclarationBlock
}
;
use
crate
:
:
shared_lock
:
:
{
Locked
SharedRwLockReadGuard
StylesheetGuards
}
;
use
crate
:
:
stylesheets
:
:
{
Origin
StyleRule
}
;
use
crate
:
:
thread_state
;
use
malloc_size_of
:
:
{
MallocShallowSizeOf
MallocSizeOf
MallocSizeOfOps
}
;
use
parking_lot
:
:
RwLock
;
use
servo_arc
:
:
{
Arc
ArcBorrow
ArcUnion
ArcUnionBorrow
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
std
:
:
mem
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicPtr
AtomicUsize
Ordering
}
;
mod
map
;
use
self
:
:
map
:
:
Map
;
#
[
derive
(
Debug
)
]
pub
struct
RuleTree
{
root
:
StrongRuleNode
}
impl
Drop
for
RuleTree
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
gc
(
)
;
}
debug_assert_eq
!
(
self
.
root
.
get
(
)
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
FREE_LIST_SENTINEL
)
;
self
.
root
.
get
(
)
.
next_free
.
store
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
}
}
impl
MallocSizeOf
for
RuleTree
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
0
;
let
mut
stack
=
SmallVec
:
:
<
[
_
;
32
]
>
:
:
new
(
)
;
stack
.
push
(
self
.
root
.
downgrade
(
)
)
;
while
let
Some
(
node
)
=
stack
.
pop
(
)
{
n
+
=
unsafe
{
ops
.
malloc_size_of
(
node
.
ptr
(
)
)
}
;
let
children
=
unsafe
{
(
*
node
.
ptr
(
)
)
.
children
.
read
(
)
}
;
children
.
shallow_size_of
(
ops
)
;
for
c
in
&
*
children
{
stack
.
push
(
c
.
clone
(
)
)
;
}
}
n
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
struct
ChildKey
(
CascadeLevel
ptr
:
:
NonNull
<
(
)
>
)
;
unsafe
impl
Send
for
ChildKey
{
}
unsafe
impl
Sync
for
ChildKey
{
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
StyleSource
(
ArcUnion
<
Locked
<
StyleRule
>
Locked
<
PropertyDeclarationBlock
>
>
)
;
impl
PartialEq
for
StyleSource
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
ArcUnion
:
:
ptr_eq
(
&
self
.
0
&
other
.
0
)
}
}
impl
StyleSource
{
pub
fn
from_rule
(
rule
:
Arc
<
Locked
<
StyleRule
>
>
)
-
>
Self
{
StyleSource
(
ArcUnion
:
:
from_first
(
rule
)
)
}
#
[
inline
]
fn
key
(
&
self
)
-
>
ptr
:
:
NonNull
<
(
)
>
{
self
.
0
.
ptr
(
)
}
pub
fn
from_declarations
(
decls
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
)
-
>
Self
{
StyleSource
(
ArcUnion
:
:
from_second
(
decls
)
)
}
fn
dump
<
W
:
Write
>
(
&
self
guard
:
&
SharedRwLockReadGuard
writer
:
&
mut
W
)
{
if
let
Some
(
ref
rule
)
=
self
.
0
.
as_first
(
)
{
let
rule
=
rule
.
read_with
(
guard
)
;
let
_
=
write
!
(
writer
"
{
:
?
}
"
rule
.
selectors
)
;
}
let
_
=
write
!
(
writer
"
-
>
{
:
?
}
"
self
.
read
(
guard
)
.
declarations
(
)
)
;
}
#
[
inline
]
pub
fn
read
<
'
a
>
(
&
'
a
self
guard
:
&
'
a
SharedRwLockReadGuard
)
-
>
&
'
a
PropertyDeclarationBlock
{
let
block
:
&
Locked
<
PropertyDeclarationBlock
>
=
match
self
.
0
.
borrow
(
)
{
ArcUnionBorrow
:
:
First
(
ref
rule
)
=
>
&
rule
.
get
(
)
.
read_with
(
guard
)
.
block
ArcUnionBorrow
:
:
Second
(
ref
block
)
=
>
block
.
get
(
)
}
;
block
.
read_with
(
guard
)
}
pub
fn
as_rule
(
&
self
)
-
>
Option
<
ArcBorrow
<
Locked
<
StyleRule
>
>
>
{
self
.
0
.
as_first
(
)
}
pub
fn
as_declarations
(
&
self
)
-
>
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
{
self
.
0
.
as_second
(
)
}
}
const
FREE_LIST_SENTINEL
:
*
mut
RuleNode
=
0x01
as
*
mut
RuleNode
;
const
FREE_LIST_LOCKED
:
*
mut
RuleNode
=
0x02
as
*
mut
RuleNode
;
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
Ord
PartialEq
PartialOrd
)
]
pub
struct
ShadowCascadeOrder
(
i8
)
;
impl
ShadowCascadeOrder
{
#
[
inline
]
pub
fn
for_outermost_shadow_tree
(
)
-
>
Self
{
Self
(
-
1
)
}
#
[
inline
]
fn
for_same_tree
(
)
-
>
Self
{
Self
(
0
)
}
#
[
inline
]
pub
fn
for_innermost_containing_tree
(
)
-
>
Self
{
Self
(
1
)
}
#
[
inline
]
pub
fn
dec
(
&
mut
self
)
{
debug_assert
!
(
self
.
0
<
0
)
;
self
.
0
=
self
.
0
.
saturating_sub
(
1
)
;
}
#
[
inline
]
pub
fn
inc
(
&
mut
self
)
{
debug_assert_ne
!
(
self
.
0
-
1
)
;
self
.
0
=
self
.
0
.
saturating_add
(
1
)
;
}
}
impl
std
:
:
ops
:
:
Neg
for
ShadowCascadeOrder
{
type
Output
=
Self
;
#
[
inline
]
fn
neg
(
self
)
-
>
Self
{
Self
(
self
.
0
.
neg
(
)
)
}
}
impl
RuleTree
{
pub
fn
new
(
)
-
>
Self
{
RuleTree
{
root
:
StrongRuleNode
:
:
new
(
Box
:
:
new
(
RuleNode
:
:
root
(
)
)
)
}
}
pub
fn
root
(
&
self
)
-
>
&
StrongRuleNode
{
&
self
.
root
}
fn
dump
<
W
:
Write
>
(
&
self
guards
:
&
StylesheetGuards
writer
:
&
mut
W
)
{
let
_
=
writeln
!
(
writer
"
+
RuleTree
"
)
;
self
.
root
.
get
(
)
.
dump
(
guards
writer
0
)
;
}
pub
fn
dump_stdout
(
&
self
guards
:
&
StylesheetGuards
)
{
let
mut
stdout
=
io
:
:
stdout
(
)
;
self
.
dump
(
guards
&
mut
stdout
)
;
}
pub
fn
insert_ordered_rules_with_important
<
'
a
I
>
(
&
self
iter
:
I
guards
:
&
StylesheetGuards
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
use
self
:
:
CascadeLevel
:
:
*
;
let
mut
current
=
self
.
root
.
clone
(
)
;
let
mut
found_important
=
false
;
let
mut
important_author
=
SmallVec
:
:
<
[
(
StyleSource
ShadowCascadeOrder
)
;
4
]
>
:
:
new
(
)
;
let
mut
important_user
=
SmallVec
:
:
<
[
StyleSource
;
4
]
>
:
:
new
(
)
;
let
mut
important_ua
=
SmallVec
:
:
<
[
StyleSource
;
4
]
>
:
:
new
(
)
;
let
mut
transition
=
None
;
for
(
source
level
)
in
iter
{
debug_assert
!
(
!
level
.
is_important
(
)
"
Important
levels
handled
internally
"
)
;
let
any_important
=
{
let
pdb
=
source
.
read
(
level
.
guard
(
guards
)
)
;
pdb
.
any_important
(
)
}
;
if
any_important
{
found_important
=
true
;
match
level
{
AuthorNormal
{
shadow_cascade_order
}
=
>
{
important_author
.
push
(
(
source
.
clone
(
)
shadow_cascade_order
)
)
;
}
UANormal
=
>
important_ua
.
push
(
source
.
clone
(
)
)
UserNormal
=
>
important_user
.
push
(
source
.
clone
(
)
)
_
=
>
{
}
}
;
}
if
matches
!
(
level
Transitions
)
&
&
found_important
{
debug_assert
!
(
transition
.
is_none
(
)
)
;
transition
=
Some
(
source
)
;
}
else
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
level
)
;
}
}
if
!
found_important
{
return
current
;
}
if
!
important_author
.
is_empty
(
)
&
&
important_author
.
first
(
)
.
unwrap
(
)
.
1
!
=
important_author
.
last
(
)
.
unwrap
(
)
.
1
{
important_author
.
sort_by_key
(
|
&
(
_
order
)
|
-
order
)
;
}
for
(
source
shadow_cascade_order
)
in
important_author
.
drain
(
.
.
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
AuthorImportant
{
shadow_cascade_order
:
-
shadow_cascade_order
}
)
;
}
for
source
in
important_user
.
drain
(
.
.
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
UserImportant
)
;
}
for
source
in
important_ua
.
drain
(
.
.
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
UAImportant
)
;
}
if
let
Some
(
source
)
=
transition
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
Transitions
)
;
}
current
}
pub
fn
compute_rule_node
(
&
self
applicable_declarations
:
&
mut
ApplicableDeclarationList
guards
:
&
StylesheetGuards
)
-
>
StrongRuleNode
{
self
.
insert_ordered_rules_with_important
(
applicable_declarations
.
drain
(
.
.
)
.
map
(
|
d
|
d
.
for_rule_tree
(
)
)
guards
)
}
pub
fn
insert_ordered_rules
<
'
a
I
>
(
&
self
iter
:
I
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
self
.
insert_ordered_rules_from
(
self
.
root
.
clone
(
)
iter
)
}
fn
insert_ordered_rules_from
<
'
a
I
>
(
&
self
from
:
StrongRuleNode
iter
:
I
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
let
mut
current
=
from
;
for
(
source
level
)
in
iter
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
level
)
;
}
current
}
pub
unsafe
fn
gc
(
&
self
)
{
self
.
root
.
gc
(
)
;
}
pub
unsafe
fn
maybe_gc
(
&
self
)
{
#
[
cfg
(
debug_assertions
)
]
self
.
maybe_dump_stats
(
)
;
self
.
root
.
maybe_gc
(
)
;
}
#
[
cfg
(
debug_assertions
)
]
fn
maybe_dump_stats
(
&
self
)
{
use
itertools
:
:
Itertools
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
if
!
log_enabled
!
(
log
:
:
Level
:
:
Trace
)
{
return
;
}
const
RULE_TREE_STATS_INTERVAL
:
Duration
=
Duration
:
:
from_secs
(
2
)
;
thread_local
!
{
pub
static
LAST_STATS
:
Cell
<
Instant
>
=
Cell
:
:
new
(
Instant
:
:
now
(
)
)
;
}
;
let
should_dump
=
LAST_STATS
.
with
(
|
s
|
{
let
now
=
Instant
:
:
now
(
)
;
if
now
.
duration_since
(
s
.
get
(
)
)
<
RULE_TREE_STATS_INTERVAL
{
return
false
;
}
s
.
set
(
now
)
;
true
}
)
;
if
!
should_dump
{
return
;
}
let
mut
children_count
=
FxHashMap
:
:
default
(
)
;
let
mut
stack
=
SmallVec
:
:
<
[
_
;
32
]
>
:
:
new
(
)
;
stack
.
push
(
self
.
root
.
clone
(
)
)
;
while
let
Some
(
node
)
=
stack
.
pop
(
)
{
let
children
=
node
.
get
(
)
.
children
.
read
(
)
;
*
children_count
.
entry
(
children
.
len
(
)
)
.
or_insert
(
0
)
+
=
1
;
for
c
in
&
*
children
{
stack
.
push
(
c
.
upgrade
(
)
)
;
}
}
trace
!
(
"
Rule
tree
stats
:
"
)
;
let
counts
=
children_count
.
keys
(
)
.
sorted
(
)
;
for
count
in
counts
{
trace
!
(
"
{
}
-
{
}
"
count
children_count
[
count
]
)
;
}
}
pub
fn
update_rule_at_level
(
&
self
level
:
CascadeLevel
pdb
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
path
:
&
StrongRuleNode
guards
:
&
StylesheetGuards
important_rules_changed
:
&
mut
bool
)
-
>
Option
<
StrongRuleNode
>
{
let
mut
current
=
path
.
clone
(
)
;
*
important_rules_changed
=
false
;
let
mut
children
=
SmallVec
:
:
<
[
_
;
10
]
>
:
:
new
(
)
;
while
current
.
get
(
)
.
level
>
level
{
children
.
push
(
(
current
.
get
(
)
.
source
.
as_ref
(
)
.
unwrap
(
)
.
clone
(
)
current
.
get
(
)
.
level
)
)
;
current
=
current
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
;
}
if
current
.
get
(
)
.
level
=
=
level
{
*
important_rules_changed
|
=
level
.
is_important
(
)
;
let
current_decls
=
current
.
get
(
)
.
source
.
as_ref
(
)
.
unwrap
(
)
.
as_declarations
(
)
;
if
let
(
Some
(
ref
pdb
)
Some
(
ref
current_decls
)
)
=
(
pdb
current_decls
)
{
let
is_here_already
=
ArcBorrow
:
:
ptr_eq
(
pdb
current_decls
)
;
if
is_here_already
{
debug
!
(
"
Picking
the
fast
path
in
rule
replacement
"
)
;
return
None
;
}
}
if
current_decls
.
is_some
(
)
{
current
=
current
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
;
}
}
if
let
Some
(
pdb
)
=
pdb
{
if
level
.
is_important
(
)
{
if
pdb
.
read_with
(
level
.
guard
(
guards
)
)
.
any_important
(
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
StyleSource
:
:
from_declarations
(
pdb
.
clone_arc
(
)
)
level
)
;
*
important_rules_changed
=
true
;
}
}
else
{
if
pdb
.
read_with
(
level
.
guard
(
guards
)
)
.
any_normal
(
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
StyleSource
:
:
from_declarations
(
pdb
.
clone_arc
(
)
)
level
)
;
}
}
}
let
rule
=
self
.
insert_ordered_rules_from
(
current
children
.
drain
(
.
.
)
.
rev
(
)
)
;
Some
(
rule
)
}
pub
fn
remove_transition_rule_if_applicable
(
&
self
path
:
&
StrongRuleNode
)
-
>
StrongRuleNode
{
if
path
.
cascade_level
(
)
!
=
CascadeLevel
:
:
Transitions
{
return
path
.
clone
(
)
;
}
path
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
}
pub
fn
remove_animation_rules
(
&
self
path
:
&
StrongRuleNode
)
-
>
StrongRuleNode
{
if
!
path
.
has_animation_or_transition_rules
(
)
{
return
path
.
clone
(
)
;
}
let
iter
=
path
.
self_and_ancestors
(
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
=
CascadeLevel
:
:
SMILOverride
)
;
let
mut
last
=
path
;
let
mut
children
=
SmallVec
:
:
<
[
_
;
10
]
>
:
:
new
(
)
;
for
node
in
iter
{
if
!
node
.
cascade_level
(
)
.
is_animation
(
)
{
children
.
push
(
(
node
.
get
(
)
.
source
.
as_ref
(
)
.
unwrap
(
)
.
clone
(
)
node
.
cascade_level
(
)
)
)
;
}
last
=
node
;
}
let
rule
=
self
.
insert_ordered_rules_from
(
last
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
children
.
drain
(
.
.
)
.
rev
(
)
)
;
rule
}
pub
fn
add_animation_rules_at_transition_level
(
&
self
path
:
&
StrongRuleNode
pdb
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
guards
:
&
StylesheetGuards
)
-
>
StrongRuleNode
{
let
mut
dummy
=
false
;
self
.
update_rule_at_level
(
CascadeLevel
:
:
Transitions
Some
(
pdb
.
borrow_arc
(
)
)
path
guards
&
mut
dummy
)
.
expect
(
"
Should
return
a
valid
rule
node
"
)
}
}
const
RULE_TREE_GC_INTERVAL
:
usize
=
300
;
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
PartialOrd
)
]
pub
enum
CascadeLevel
{
UANormal
UserNormal
PresHints
AuthorNormal
{
shadow_cascade_order
:
ShadowCascadeOrder
}
SMILOverride
Animations
AuthorImportant
{
shadow_cascade_order
:
ShadowCascadeOrder
}
UserImportant
UAImportant
Transitions
}
impl
CascadeLevel
{
#
[
inline
]
pub
fn
to_byte_lossy
(
&
self
)
-
>
u8
{
let
(
discriminant
order
)
=
match
*
self
{
Self
:
:
UANormal
=
>
(
0
0
)
Self
:
:
UserNormal
=
>
(
1
0
)
Self
:
:
PresHints
=
>
(
2
0
)
Self
:
:
AuthorNormal
{
shadow_cascade_order
}
=
>
(
3
shadow_cascade_order
.
0
)
Self
:
:
SMILOverride
=
>
(
4
0
)
Self
:
:
Animations
=
>
(
5
0
)
Self
:
:
AuthorImportant
{
shadow_cascade_order
}
=
>
(
6
shadow_cascade_order
.
0
)
Self
:
:
UserImportant
=
>
(
7
0
)
Self
:
:
UAImportant
=
>
(
8
0
)
Self
:
:
Transitions
=
>
(
9
0
)
}
;
debug_assert_eq
!
(
discriminant
&
0xf
discriminant
)
;
if
order
=
=
0
{
return
discriminant
;
}
let
negative
=
order
<
0
;
let
value
=
std
:
:
cmp
:
:
min
(
order
.
abs
(
)
as
u8
0b111
)
;
(
negative
as
u8
)
<
<
7
|
value
<
<
4
|
discriminant
}
#
[
inline
]
pub
fn
from_byte
(
b
:
u8
)
-
>
Self
{
let
order
=
{
let
abs
=
(
(
b
&
0b01110000
)
>
>
4
)
as
i8
;
let
negative
=
b
&
0b10000000
!
=
0
;
if
negative
{
-
abs
}
else
{
abs
}
}
;
let
discriminant
=
b
&
0xf
;
let
level
=
match
discriminant
{
0
=
>
Self
:
:
UANormal
1
=
>
Self
:
:
UserNormal
2
=
>
Self
:
:
PresHints
3
=
>
{
return
Self
:
:
AuthorNormal
{
shadow_cascade_order
:
ShadowCascadeOrder
(
order
)
}
}
4
=
>
Self
:
:
SMILOverride
5
=
>
Self
:
:
Animations
6
=
>
{
return
Self
:
:
AuthorImportant
{
shadow_cascade_order
:
ShadowCascadeOrder
(
order
)
}
}
7
=
>
Self
:
:
UserImportant
8
=
>
Self
:
:
UAImportant
9
=
>
Self
:
:
Transitions
_
=
>
unreachable
!
(
"
Didn
'
t
expect
{
}
as
a
discriminant
"
discriminant
)
}
;
debug_assert_eq
!
(
order
0
"
Didn
'
t
expect
an
order
value
for
{
:
?
}
"
level
)
;
level
}
pub
fn
guard
<
'
a
>
(
&
self
guards
:
&
'
a
StylesheetGuards
<
'
a
>
)
-
>
&
'
a
SharedRwLockReadGuard
<
'
a
>
{
match
*
self
{
CascadeLevel
:
:
UANormal
|
CascadeLevel
:
:
UserNormal
|
CascadeLevel
:
:
UserImportant
|
CascadeLevel
:
:
UAImportant
=
>
guards
.
ua_or_user
_
=
>
guards
.
author
}
}
#
[
inline
]
pub
fn
same_tree_author_important
(
)
-
>
Self
{
CascadeLevel
:
:
AuthorImportant
{
shadow_cascade_order
:
ShadowCascadeOrder
:
:
for_same_tree
(
)
}
}
#
[
inline
]
pub
fn
same_tree_author_normal
(
)
-
>
Self
{
CascadeLevel
:
:
AuthorNormal
{
shadow_cascade_order
:
ShadowCascadeOrder
:
:
for_same_tree
(
)
}
}
#
[
inline
]
pub
fn
is_important
(
&
self
)
-
>
bool
{
match
*
self
{
CascadeLevel
:
:
AuthorImportant
{
.
.
}
|
CascadeLevel
:
:
UserImportant
|
CascadeLevel
:
:
UAImportant
=
>
true
_
=
>
false
}
}
#
[
inline
]
pub
fn
importance
(
&
self
)
-
>
Importance
{
if
self
.
is_important
(
)
{
Importance
:
:
Important
}
else
{
Importance
:
:
Normal
}
}
#
[
inline
]
pub
fn
origin
(
&
self
)
-
>
Origin
{
match
*
self
{
CascadeLevel
:
:
UAImportant
|
CascadeLevel
:
:
UANormal
=
>
Origin
:
:
UserAgent
CascadeLevel
:
:
UserImportant
|
CascadeLevel
:
:
UserNormal
=
>
Origin
:
:
User
CascadeLevel
:
:
PresHints
|
CascadeLevel
:
:
AuthorNormal
{
.
.
}
|
CascadeLevel
:
:
AuthorImportant
{
.
.
}
|
CascadeLevel
:
:
SMILOverride
|
CascadeLevel
:
:
Animations
|
CascadeLevel
:
:
Transitions
=
>
Origin
:
:
Author
}
}
#
[
inline
]
pub
fn
is_animation
(
&
self
)
-
>
bool
{
match
*
self
{
CascadeLevel
:
:
SMILOverride
|
CascadeLevel
:
:
Animations
|
CascadeLevel
:
:
Transitions
=
>
{
true
}
_
=
>
false
}
}
}
pub
struct
RuleNode
{
root
:
Option
<
WeakRuleNode
>
parent
:
Option
<
StrongRuleNode
>
source
:
Option
<
StyleSource
>
level
:
CascadeLevel
refcount
:
AtomicUsize
free_count
:
AtomicUsize
children
:
RwLock
<
Map
<
ChildKey
WeakRuleNode
>
>
next_free
:
AtomicPtr
<
RuleNode
>
}
unsafe
impl
Sync
for
RuleTree
{
}
unsafe
impl
Send
for
RuleTree
{
}
#
[
cfg
(
feature
=
"
gecko_refcount_logging
"
)
]
mod
gecko_leak_checking
{
use
super
:
:
RuleNode
;
use
std
:
:
mem
:
:
size_of
;
use
std
:
:
os
:
:
raw
:
:
{
c_char
c_void
}
;
extern
"
C
"
{
fn
NS_LogCtor
(
aPtr
:
*
mut
c_void
aTypeName
:
*
const
c_char
aSize
:
u32
)
;
fn
NS_LogDtor
(
aPtr
:
*
mut
c_void
aTypeName
:
*
const
c_char
aSize
:
u32
)
;
}
static
NAME
:
&
'
static
[
u8
]
=
b
"
RuleNode
\
0
"
;
pub
fn
log_ctor
(
ptr
:
*
const
RuleNode
)
{
let
s
=
NAME
as
*
const
[
u8
]
as
*
const
u8
as
*
const
c_char
;
unsafe
{
NS_LogCtor
(
ptr
as
*
mut
c_void
s
size_of
:
:
<
RuleNode
>
(
)
as
u32
)
;
}
}
pub
fn
log_dtor
(
ptr
:
*
const
RuleNode
)
{
let
s
=
NAME
as
*
const
[
u8
]
as
*
const
u8
as
*
const
c_char
;
unsafe
{
NS_LogDtor
(
ptr
as
*
mut
c_void
s
size_of
:
:
<
RuleNode
>
(
)
as
u32
)
;
}
}
}
#
[
inline
(
always
)
]
fn
log_new
(
_ptr
:
*
const
RuleNode
)
{
#
[
cfg
(
feature
=
"
gecko_refcount_logging
"
)
]
gecko_leak_checking
:
:
log_ctor
(
_ptr
)
;
}
#
[
inline
(
always
)
]
fn
log_drop
(
_ptr
:
*
const
RuleNode
)
{
#
[
cfg
(
feature
=
"
gecko_refcount_logging
"
)
]
gecko_leak_checking
:
:
log_dtor
(
_ptr
)
;
}
impl
RuleNode
{
fn
new
(
root
:
WeakRuleNode
parent
:
StrongRuleNode
source
:
StyleSource
level
:
CascadeLevel
)
-
>
Self
{
debug_assert
!
(
root
.
upgrade
(
)
.
parent
(
)
.
is_none
(
)
)
;
RuleNode
{
root
:
Some
(
root
)
parent
:
Some
(
parent
)
source
:
Some
(
source
)
level
:
level
refcount
:
AtomicUsize
:
:
new
(
1
)
children
:
Default
:
:
default
(
)
free_count
:
AtomicUsize
:
:
new
(
0
)
next_free
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
}
}
fn
root
(
)
-
>
Self
{
RuleNode
{
root
:
None
parent
:
None
source
:
None
level
:
CascadeLevel
:
:
UANormal
refcount
:
AtomicUsize
:
:
new
(
1
)
free_count
:
AtomicUsize
:
:
new
(
0
)
children
:
Default
:
:
default
(
)
next_free
:
AtomicPtr
:
:
new
(
FREE_LIST_SENTINEL
)
}
}
fn
key
(
&
self
)
-
>
ChildKey
{
ChildKey
(
self
.
level
self
.
source
.
as_ref
(
)
.
expect
(
"
Called
key
(
)
on
the
root
node
"
)
.
key
(
)
)
}
fn
is_root
(
&
self
)
-
>
bool
{
self
.
parent
.
is_none
(
)
}
fn
free_count
(
&
self
)
-
>
&
AtomicUsize
{
debug_assert
!
(
self
.
is_root
(
)
)
;
&
self
.
free_count
}
unsafe
fn
remove_from_child_list
(
&
self
)
{
debug
!
(
"
Remove
from
child
list
:
{
:
?
}
parent
:
{
:
?
}
"
self
as
*
const
RuleNode
self
.
parent
.
as_ref
(
)
.
map
(
|
p
|
p
.
ptr
(
)
)
)
;
if
let
Some
(
parent
)
=
self
.
parent
.
as_ref
(
)
{
let
weak
=
parent
.
get
(
)
.
children
.
write
(
)
.
remove
(
&
self
.
key
(
)
|
node
|
(
*
node
.
ptr
(
)
)
.
key
(
)
)
;
assert_eq
!
(
weak
.
unwrap
(
)
.
ptr
(
)
as
*
const
_
self
as
*
const
_
)
;
}
}
fn
dump
<
W
:
Write
>
(
&
self
guards
:
&
StylesheetGuards
writer
:
&
mut
W
indent
:
usize
)
{
const
INDENT_INCREMENT
:
usize
=
4
;
for
_
in
0
.
.
indent
{
let
_
=
write
!
(
writer
"
"
)
;
}
let
_
=
writeln
!
(
writer
"
-
{
:
?
}
(
ref
:
{
:
?
}
parent
:
{
:
?
}
)
"
self
as
*
const
_
self
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
self
.
parent
.
as_ref
(
)
.
map
(
|
p
|
p
.
ptr
(
)
)
)
;
for
_
in
0
.
.
indent
{
let
_
=
write
!
(
writer
"
"
)
;
}
if
self
.
source
.
is_some
(
)
{
self
.
source
.
as_ref
(
)
.
unwrap
(
)
.
dump
(
self
.
level
.
guard
(
guards
)
writer
)
;
}
else
{
if
indent
!
=
0
{
warn
!
(
"
How
has
this
happened
?
"
)
;
}
let
_
=
write
!
(
writer
"
(
root
)
"
)
;
}
let
_
=
write
!
(
writer
"
\
n
"
)
;
for
child
in
&
*
self
.
children
.
read
(
)
{
child
.
upgrade
(
)
.
get
(
)
.
dump
(
guards
writer
indent
+
INDENT_INCREMENT
)
;
}
}
}
#
[
derive
(
Clone
)
]
struct
WeakRuleNode
{
p
:
ptr
:
:
NonNull
<
RuleNode
>
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
pub
struct
StrongRuleNode
{
p
:
ptr
:
:
NonNull
<
RuleNode
>
}
unsafe
impl
Send
for
StrongRuleNode
{
}
unsafe
impl
Sync
for
StrongRuleNode
{
}
#
[
cfg
(
feature
=
"
servo
"
)
]
malloc_size_of_is_0
!
(
StrongRuleNode
)
;
impl
StrongRuleNode
{
fn
new
(
n
:
Box
<
RuleNode
>
)
-
>
Self
{
debug_assert_eq
!
(
n
.
parent
.
is_none
(
)
!
n
.
source
.
is_some
(
)
)
;
let
ptr
=
unsafe
{
ptr
:
:
NonNull
:
:
new_unchecked
(
Box
:
:
into_raw
(
n
)
)
}
;
log_new
(
ptr
.
as_ptr
(
)
)
;
debug
!
(
"
Creating
rule
node
:
{
:
p
}
"
ptr
)
;
StrongRuleNode
:
:
from_ptr
(
ptr
)
}
fn
from_ptr
(
p
:
ptr
:
:
NonNull
<
RuleNode
>
)
-
>
Self
{
StrongRuleNode
{
p
}
}
fn
downgrade
(
&
self
)
-
>
WeakRuleNode
{
WeakRuleNode
:
:
from_ptr
(
self
.
p
)
}
pub
fn
parent
(
&
self
)
-
>
Option
<
&
StrongRuleNode
>
{
self
.
get
(
)
.
parent
.
as_ref
(
)
}
fn
ensure_child
(
&
self
root
:
WeakRuleNode
source
:
StyleSource
level
:
CascadeLevel
)
-
>
StrongRuleNode
{
use
parking_lot
:
:
RwLockUpgradableReadGuard
;
debug_assert
!
(
self
.
get
(
)
.
level
<
=
level
"
Should
be
ordered
(
instead
{
:
?
}
>
{
:
?
}
)
from
{
:
?
}
and
{
:
?
}
"
self
.
get
(
)
.
level
level
self
.
get
(
)
.
source
source
)
;
let
key
=
ChildKey
(
level
source
.
key
(
)
)
;
let
children
=
self
.
get
(
)
.
children
.
upgradable_read
(
)
;
if
let
Some
(
child
)
=
children
.
get
(
&
key
|
node
|
unsafe
{
(
*
node
.
ptr
(
)
)
.
key
(
)
}
)
{
return
child
.
upgrade
(
)
;
}
let
mut
children
=
RwLockUpgradableReadGuard
:
:
upgrade
(
children
)
;
let
weak
=
children
.
get_or_insert_with
(
key
|
node
|
unsafe
{
(
*
node
.
ptr
(
)
)
.
key
(
)
}
move
|
|
{
let
strong
=
StrongRuleNode
:
:
new
(
Box
:
:
new
(
RuleNode
:
:
new
(
root
self
.
clone
(
)
source
level
)
)
)
;
let
weak
=
strong
.
downgrade
(
)
;
mem
:
:
forget
(
strong
)
;
weak
}
)
;
StrongRuleNode
:
:
from_ptr
(
weak
.
p
)
}
#
[
inline
]
pub
fn
ptr
(
&
self
)
-
>
*
mut
RuleNode
{
self
.
p
.
as_ptr
(
)
}
fn
get
(
&
self
)
-
>
&
RuleNode
{
if
cfg
!
(
debug_assertions
)
{
let
node
=
unsafe
{
&
*
self
.
p
.
as_ptr
(
)
}
;
assert
!
(
node
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
>
0
)
;
}
unsafe
{
&
*
self
.
p
.
as_ptr
(
)
}
}
pub
fn
style_source
(
&
self
)
-
>
Option
<
&
StyleSource
>
{
self
.
get
(
)
.
source
.
as_ref
(
)
}
pub
fn
cascade_level
(
&
self
)
-
>
CascadeLevel
{
self
.
get
(
)
.
level
}
pub
fn
importance
(
&
self
)
-
>
Importance
{
self
.
get
(
)
.
level
.
importance
(
)
}
pub
fn
self_and_ancestors
(
&
self
)
-
>
SelfAndAncestors
{
SelfAndAncestors
{
current
:
Some
(
self
)
}
}
pub
unsafe
fn
has_children_for_testing
(
&
self
)
-
>
bool
{
!
self
.
get
(
)
.
children
.
read
(
)
.
is_empty
(
)
}
unsafe
fn
pop_from_free_list
(
&
self
)
-
>
Option
<
WeakRuleNode
>
{
let
me
=
&
*
self
.
p
.
as_ptr
(
)
;
debug_assert
!
(
me
.
is_root
(
)
)
;
debug_assert
!
(
!
thread_state
:
:
get
(
)
.
is_worker
(
)
&
&
(
thread_state
:
:
get
(
)
.
is_layout
(
)
|
|
thread_state
:
:
get
(
)
.
is_script
(
)
)
)
;
let
current
=
me
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
;
if
current
=
=
FREE_LIST_SENTINEL
{
return
None
;
}
debug_assert
!
(
!
current
.
is_null
(
)
"
Multiple
threads
are
operating
on
the
free
list
at
the
\
same
time
?
"
)
;
debug_assert
!
(
current
!
=
self
.
p
.
as_ptr
(
)
"
How
did
the
root
end
up
in
the
free
list
?
"
)
;
let
next
=
(
*
current
)
.
next_free
.
swap
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
debug_assert
!
(
!
next
.
is_null
(
)
"
How
did
a
null
pointer
end
up
in
the
free
list
?
"
)
;
me
.
next_free
.
store
(
next
Ordering
:
:
Relaxed
)
;
debug
!
(
"
Popping
from
free
list
:
cur
:
{
:
?
}
next
:
{
:
?
}
"
current
next
)
;
Some
(
WeakRuleNode
:
:
from_ptr
(
ptr
:
:
NonNull
:
:
new_unchecked
(
current
)
)
)
}
unsafe
fn
assert_free_list_has_no_duplicates_or_null
(
&
self
)
{
assert
!
(
cfg
!
(
debug_assertions
)
"
This
is
an
expensive
check
!
"
)
;
use
crate
:
:
hash
:
:
FxHashSet
;
let
me
=
&
*
self
.
p
.
as_ptr
(
)
;
assert
!
(
me
.
is_root
(
)
)
;
let
mut
current
=
self
.
p
.
as_ptr
(
)
;
let
mut
seen
=
FxHashSet
:
:
default
(
)
;
while
current
!
=
FREE_LIST_SENTINEL
{
let
next
=
(
*
current
)
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
;
assert
!
(
!
next
.
is_null
(
)
)
;
assert
!
(
!
seen
.
contains
(
&
next
)
)
;
seen
.
insert
(
next
)
;
current
=
next
;
}
}
unsafe
fn
gc
(
&
self
)
{
if
cfg
!
(
debug_assertions
)
{
self
.
assert_free_list_has_no_duplicates_or_null
(
)
;
}
let
me
=
&
*
self
.
p
.
as_ptr
(
)
;
debug_assert
!
(
me
.
is_root
(
)
"
Can
'
t
call
GC
on
a
non
-
root
node
!
"
)
;
while
let
Some
(
weak
)
=
self
.
pop_from_free_list
(
)
{
let
node
=
&
*
weak
.
p
.
as_ptr
(
)
;
if
node
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
!
=
0
{
continue
;
}
debug
!
(
"
GC
'
ing
{
:
?
}
"
weak
.
p
.
as_ptr
(
)
)
;
node
.
remove_from_child_list
(
)
;
log_drop
(
weak
.
p
.
as_ptr
(
)
)
;
let
_
=
Box
:
:
from_raw
(
weak
.
p
.
as_ptr
(
)
)
;
}
me
.
free_count
(
)
.
store
(
0
Ordering
:
:
Relaxed
)
;
debug_assert_eq
!
(
me
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
FREE_LIST_SENTINEL
)
;
}
unsafe
fn
maybe_gc
(
&
self
)
{
debug_assert
!
(
self
.
get
(
)
.
is_root
(
)
"
Can
'
t
call
GC
on
a
non
-
root
node
!
"
)
;
if
self
.
get
(
)
.
free_count
(
)
.
load
(
Ordering
:
:
Relaxed
)
>
RULE_TREE_GC_INTERVAL
{
self
.
gc
(
)
;
}
}
pub
fn
has_animation_or_transition_rules
(
&
self
)
-
>
bool
{
self
.
self_and_ancestors
(
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
=
CascadeLevel
:
:
SMILOverride
)
.
any
(
|
node
|
node
.
cascade_level
(
)
.
is_animation
(
)
)
}
pub
fn
get_properties_overriding_animations
(
&
self
guards
:
&
StylesheetGuards
)
-
>
(
LonghandIdSet
bool
)
{
use
crate
:
:
properties
:
:
PropertyDeclarationId
;
let
iter
=
self
.
self_and_ancestors
(
)
.
skip_while
(
|
node
|
node
.
cascade_level
(
)
=
=
CascadeLevel
:
:
Transitions
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
CascadeLevel
:
:
Animations
)
;
let
mut
result
=
(
LonghandIdSet
:
:
new
(
)
false
)
;
for
node
in
iter
{
let
style
=
node
.
style_source
(
)
.
unwrap
(
)
;
for
(
decl
important
)
in
style
.
read
(
node
.
cascade_level
(
)
.
guard
(
guards
)
)
.
declaration_importance_iter
(
)
{
if
important
.
important
(
)
{
match
decl
.
id
(
)
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
result
.
0
.
insert
(
id
)
PropertyDeclarationId
:
:
Custom
(
_
)
=
>
result
.
1
=
true
}
}
}
}
result
}
}
#
[
derive
(
Clone
)
]
pub
struct
SelfAndAncestors
<
'
a
>
{
current
:
Option
<
&
'
a
StrongRuleNode
>
}
impl
<
'
a
>
Iterator
for
SelfAndAncestors
<
'
a
>
{
type
Item
=
&
'
a
StrongRuleNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
current
.
map
(
|
node
|
{
self
.
current
=
node
.
parent
(
)
;
node
}
)
}
}
impl
Clone
for
StrongRuleNode
{
fn
clone
(
&
self
)
-
>
Self
{
debug
!
(
"
{
:
?
}
:
{
:
?
}
+
"
self
.
ptr
(
)
self
.
get
(
)
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
)
;
debug_assert
!
(
self
.
get
(
)
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
>
0
)
;
self
.
get
(
)
.
refcount
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
StrongRuleNode
:
:
from_ptr
(
self
.
p
)
}
}
impl
Drop
for
StrongRuleNode
{
#
[
cfg_attr
(
feature
=
"
servo
"
allow
(
unused_mut
)
)
]
fn
drop
(
&
mut
self
)
{
let
node
=
unsafe
{
&
*
self
.
ptr
(
)
}
;
debug
!
(
"
{
:
?
}
:
{
:
?
}
-
"
self
.
ptr
(
)
node
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
)
;
debug
!
(
"
Dropping
node
:
{
:
?
}
root
:
{
:
?
}
parent
:
{
:
?
}
"
self
.
ptr
(
)
node
.
root
.
as_ref
(
)
.
map
(
|
r
|
r
.
ptr
(
)
)
node
.
parent
.
as_ref
(
)
.
map
(
|
p
|
p
.
ptr
(
)
)
)
;
let
should_drop
=
{
debug_assert
!
(
node
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
>
0
)
;
node
.
refcount
.
fetch_sub
(
1
Ordering
:
:
Relaxed
)
=
=
1
}
;
if
!
should_drop
{
return
;
}
if
node
.
parent
.
is_none
(
)
{
debug
!
(
"
Dropping
root
node
!
"
)
;
debug_assert
!
(
node
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
.
is_null
(
)
)
;
log_drop
(
self
.
ptr
(
)
)
;
let
_
=
unsafe
{
Box
:
:
from_raw
(
self
.
ptr
(
)
)
}
;
return
;
}
let
root
=
unsafe
{
&
*
node
.
root
.
as_ref
(
)
.
unwrap
(
)
.
ptr
(
)
}
;
let
free_list
=
&
root
.
next_free
;
let
mut
old_head
=
free_list
.
load
(
Ordering
:
:
Relaxed
)
;
if
old_head
.
is_null
(
)
{
debug_assert
!
(
!
thread_state
:
:
get
(
)
.
is_worker
(
)
&
&
(
thread_state
:
:
get
(
)
.
is_layout
(
)
|
|
thread_state
:
:
get
(
)
.
is_script
(
)
)
)
;
debug_assert
!
(
node
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
.
is_null
(
)
)
;
node
.
next_free
.
store
(
FREE_LIST_SENTINEL
Ordering
:
:
Relaxed
)
;
free_list
.
store
(
node
as
*
const
_
as
*
mut
_
Ordering
:
:
Relaxed
)
;
let
strong_root
:
StrongRuleNode
=
node
.
root
.
as_ref
(
)
.
unwrap
(
)
.
upgrade
(
)
;
unsafe
{
strong_root
.
gc
(
)
;
}
debug_assert_eq
!
(
root
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
FREE_LIST_SENTINEL
)
;
root
.
next_free
.
store
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
return
;
}
if
node
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
!
=
ptr
:
:
null_mut
(
)
{
return
;
}
loop
{
match
free_list
.
compare_exchange_weak
(
old_head
FREE_LIST_LOCKED
Ordering
:
:
Acquire
Ordering
:
:
Relaxed
)
{
Ok
(
.
.
)
=
>
{
if
old_head
!
=
FREE_LIST_LOCKED
{
break
;
}
}
Err
(
new
)
=
>
old_head
=
new
}
}
if
node
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
!
=
ptr
:
:
null_mut
(
)
{
free_list
.
store
(
old_head
Ordering
:
:
Release
)
;
return
;
}
node
.
next_free
.
store
(
old_head
Ordering
:
:
Relaxed
)
;
let
old_free_count
=
root
.
free_count
(
)
.
load
(
Ordering
:
:
Relaxed
)
;
root
.
free_count
(
)
.
store
(
old_free_count
+
1
Ordering
:
:
Relaxed
)
;
free_list
.
store
(
self
.
ptr
(
)
Ordering
:
:
Release
)
;
}
}
impl
<
'
a
>
From
<
&
'
a
StrongRuleNode
>
for
WeakRuleNode
{
fn
from
(
node
:
&
'
a
StrongRuleNode
)
-
>
Self
{
WeakRuleNode
:
:
from_ptr
(
node
.
p
)
}
}
impl
WeakRuleNode
{
#
[
inline
]
fn
ptr
(
&
self
)
-
>
*
mut
RuleNode
{
self
.
p
.
as_ptr
(
)
}
fn
upgrade
(
&
self
)
-
>
StrongRuleNode
{
debug
!
(
"
Upgrading
weak
node
:
{
:
p
}
"
self
.
ptr
(
)
)
;
let
node
=
unsafe
{
&
*
self
.
ptr
(
)
}
;
node
.
refcount
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
StrongRuleNode
:
:
from_ptr
(
self
.
p
)
}
fn
from_ptr
(
p
:
ptr
:
:
NonNull
<
RuleNode
>
)
-
>
Self
{
WeakRuleNode
{
p
}
}
}
