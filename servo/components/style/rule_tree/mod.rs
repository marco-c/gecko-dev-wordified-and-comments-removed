#
!
[
deny
(
unsafe_code
)
]
use
crate
:
:
applicable_declarations
:
:
ApplicableDeclarationList
;
use
crate
:
:
properties
:
:
{
LonghandIdSet
PropertyDeclarationBlock
}
;
use
crate
:
:
shared_lock
:
:
{
Locked
StylesheetGuards
}
;
use
servo_arc
:
:
{
Arc
ArcBorrow
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
io
:
:
{
self
Write
}
;
mod
core
;
mod
level
;
mod
map
;
mod
source
;
mod
unsafe_box
;
pub
use
self
:
:
core
:
:
{
RuleTree
StrongRuleNode
}
;
pub
use
self
:
:
level
:
:
{
CascadeLevel
ShadowCascadeOrder
}
;
pub
use
self
:
:
source
:
:
StyleSource
;
impl
RuleTree
{
fn
dump
<
W
:
Write
>
(
&
self
guards
:
&
StylesheetGuards
writer
:
&
mut
W
)
{
let
_
=
writeln
!
(
writer
"
+
RuleTree
"
)
;
self
.
root
(
)
.
dump
(
guards
writer
0
)
;
}
pub
fn
dump_stdout
(
&
self
guards
:
&
StylesheetGuards
)
{
let
mut
stdout
=
io
:
:
stdout
(
)
;
self
.
dump
(
guards
&
mut
stdout
)
;
}
pub
fn
insert_ordered_rules_with_important
<
'
a
I
>
(
&
self
iter
:
I
guards
:
&
StylesheetGuards
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
use
self
:
:
CascadeLevel
:
:
*
;
let
mut
current
=
self
.
root
(
)
.
clone
(
)
;
let
mut
found_important
=
false
;
let
mut
important_author
=
SmallVec
:
:
<
[
(
StyleSource
ShadowCascadeOrder
)
;
4
]
>
:
:
new
(
)
;
let
mut
important_user
=
SmallVec
:
:
<
[
StyleSource
;
4
]
>
:
:
new
(
)
;
let
mut
important_ua
=
SmallVec
:
:
<
[
StyleSource
;
4
]
>
:
:
new
(
)
;
let
mut
transition
=
None
;
for
(
source
level
)
in
iter
{
debug_assert
!
(
!
level
.
is_important
(
)
"
Important
levels
handled
internally
"
)
;
let
any_important
=
{
let
pdb
=
source
.
read
(
level
.
guard
(
guards
)
)
;
pdb
.
any_important
(
)
}
;
if
any_important
{
found_important
=
true
;
match
level
{
AuthorNormal
{
shadow_cascade_order
}
=
>
{
important_author
.
push
(
(
source
.
clone
(
)
shadow_cascade_order
)
)
;
}
UANormal
=
>
important_ua
.
push
(
source
.
clone
(
)
)
UserNormal
=
>
important_user
.
push
(
source
.
clone
(
)
)
_
=
>
{
}
}
;
}
if
matches
!
(
level
Transitions
)
&
&
found_important
{
debug_assert
!
(
transition
.
is_none
(
)
)
;
transition
=
Some
(
source
)
;
}
else
{
current
=
current
.
ensure_child
(
self
.
root
(
)
source
level
)
;
}
}
if
!
found_important
{
return
current
;
}
if
!
important_author
.
is_empty
(
)
&
&
important_author
.
first
(
)
.
unwrap
(
)
.
1
!
=
important_author
.
last
(
)
.
unwrap
(
)
.
1
{
important_author
.
sort_by_key
(
|
&
(
_
order
)
|
-
order
)
;
}
for
(
source
shadow_cascade_order
)
in
important_author
.
drain
(
.
.
)
{
current
=
current
.
ensure_child
(
self
.
root
(
)
source
AuthorImportant
{
shadow_cascade_order
:
-
shadow_cascade_order
}
)
;
}
for
source
in
important_user
.
drain
(
.
.
)
{
current
=
current
.
ensure_child
(
self
.
root
(
)
source
UserImportant
)
;
}
for
source
in
important_ua
.
drain
(
.
.
)
{
current
=
current
.
ensure_child
(
self
.
root
(
)
source
UAImportant
)
;
}
if
let
Some
(
source
)
=
transition
{
current
=
current
.
ensure_child
(
self
.
root
(
)
source
Transitions
)
;
}
current
}
pub
fn
compute_rule_node
(
&
self
applicable_declarations
:
&
mut
ApplicableDeclarationList
guards
:
&
StylesheetGuards
)
-
>
StrongRuleNode
{
self
.
insert_ordered_rules_with_important
(
applicable_declarations
.
drain
(
.
.
)
.
map
(
|
d
|
d
.
for_rule_tree
(
)
)
guards
)
}
pub
fn
insert_ordered_rules
<
'
a
I
>
(
&
self
iter
:
I
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
self
.
insert_ordered_rules_from
(
self
.
root
(
)
.
clone
(
)
iter
)
}
fn
insert_ordered_rules_from
<
'
a
I
>
(
&
self
from
:
StrongRuleNode
iter
:
I
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
let
mut
current
=
from
;
for
(
source
level
)
in
iter
{
current
=
current
.
ensure_child
(
self
.
root
(
)
source
level
)
;
}
current
}
pub
fn
update_rule_at_level
(
&
self
level
:
CascadeLevel
pdb
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
path
:
&
StrongRuleNode
guards
:
&
StylesheetGuards
important_rules_changed
:
&
mut
bool
)
-
>
Option
<
StrongRuleNode
>
{
let
mut
current
=
path
.
clone
(
)
;
*
important_rules_changed
=
false
;
let
mut
children
=
SmallVec
:
:
<
[
_
;
10
]
>
:
:
new
(
)
;
while
current
.
cascade_level
(
)
>
level
{
children
.
push
(
(
current
.
style_source
(
)
.
unwrap
(
)
.
clone
(
)
current
.
cascade_level
(
)
)
)
;
current
=
current
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
;
}
if
current
.
cascade_level
(
)
=
=
level
{
*
important_rules_changed
|
=
level
.
is_important
(
)
;
let
current_decls
=
current
.
style_source
(
)
.
unwrap
(
)
.
as_declarations
(
)
;
if
let
(
Some
(
ref
pdb
)
Some
(
ref
current_decls
)
)
=
(
pdb
current_decls
)
{
let
is_here_already
=
ArcBorrow
:
:
ptr_eq
(
pdb
current_decls
)
;
if
is_here_already
{
debug
!
(
"
Picking
the
fast
path
in
rule
replacement
"
)
;
return
None
;
}
}
if
current_decls
.
is_some
(
)
{
current
=
current
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
;
}
}
if
let
Some
(
pdb
)
=
pdb
{
if
level
.
is_important
(
)
{
if
pdb
.
read_with
(
level
.
guard
(
guards
)
)
.
any_important
(
)
{
current
=
current
.
ensure_child
(
self
.
root
(
)
StyleSource
:
:
from_declarations
(
pdb
.
clone_arc
(
)
)
level
)
;
*
important_rules_changed
=
true
;
}
}
else
{
if
pdb
.
read_with
(
level
.
guard
(
guards
)
)
.
any_normal
(
)
{
current
=
current
.
ensure_child
(
self
.
root
(
)
StyleSource
:
:
from_declarations
(
pdb
.
clone_arc
(
)
)
level
)
;
}
}
}
let
rule
=
self
.
insert_ordered_rules_from
(
current
children
.
drain
(
.
.
)
.
rev
(
)
)
;
Some
(
rule
)
}
pub
fn
remove_transition_rule_if_applicable
(
&
self
path
:
&
StrongRuleNode
)
-
>
StrongRuleNode
{
if
path
.
cascade_level
(
)
!
=
CascadeLevel
:
:
Transitions
{
return
path
.
clone
(
)
;
}
path
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
}
pub
fn
remove_animation_rules
(
&
self
path
:
&
StrongRuleNode
)
-
>
StrongRuleNode
{
if
!
path
.
has_animation_or_transition_rules
(
)
{
return
path
.
clone
(
)
;
}
let
iter
=
path
.
self_and_ancestors
(
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
=
CascadeLevel
:
:
SMILOverride
)
;
let
mut
last
=
path
;
let
mut
children
=
SmallVec
:
:
<
[
_
;
10
]
>
:
:
new
(
)
;
for
node
in
iter
{
if
!
node
.
cascade_level
(
)
.
is_animation
(
)
{
children
.
push
(
(
node
.
style_source
(
)
.
unwrap
(
)
.
clone
(
)
node
.
cascade_level
(
)
)
)
;
}
last
=
node
;
}
let
rule
=
self
.
insert_ordered_rules_from
(
last
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
children
.
drain
(
.
.
)
.
rev
(
)
)
;
rule
}
pub
fn
add_animation_rules_at_transition_level
(
&
self
path
:
&
StrongRuleNode
pdb
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
guards
:
&
StylesheetGuards
)
-
>
StrongRuleNode
{
let
mut
dummy
=
false
;
self
.
update_rule_at_level
(
CascadeLevel
:
:
Transitions
Some
(
pdb
.
borrow_arc
(
)
)
path
guards
&
mut
dummy
)
.
expect
(
"
Should
return
a
valid
rule
node
"
)
}
}
impl
StrongRuleNode
{
pub
fn
self_and_ancestors
(
&
self
)
-
>
SelfAndAncestors
{
SelfAndAncestors
{
current
:
Some
(
self
)
}
}
pub
fn
has_animation_or_transition_rules
(
&
self
)
-
>
bool
{
self
.
self_and_ancestors
(
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
=
CascadeLevel
:
:
SMILOverride
)
.
any
(
|
node
|
node
.
cascade_level
(
)
.
is_animation
(
)
)
}
pub
fn
get_properties_overriding_animations
(
&
self
guards
:
&
StylesheetGuards
)
-
>
(
LonghandIdSet
bool
)
{
use
crate
:
:
properties
:
:
PropertyDeclarationId
;
let
iter
=
self
.
self_and_ancestors
(
)
.
skip_while
(
|
node
|
node
.
cascade_level
(
)
=
=
CascadeLevel
:
:
Transitions
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
CascadeLevel
:
:
Animations
)
;
let
mut
result
=
(
LonghandIdSet
:
:
new
(
)
false
)
;
for
node
in
iter
{
let
style
=
node
.
style_source
(
)
.
unwrap
(
)
;
for
(
decl
important
)
in
style
.
read
(
node
.
cascade_level
(
)
.
guard
(
guards
)
)
.
declaration_importance_iter
(
)
{
if
important
.
important
(
)
{
match
decl
.
id
(
)
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
result
.
0
.
insert
(
id
)
PropertyDeclarationId
:
:
Custom
(
_
)
=
>
result
.
1
=
true
}
}
}
}
result
}
}
#
[
derive
(
Clone
)
]
pub
struct
SelfAndAncestors
<
'
a
>
{
current
:
Option
<
&
'
a
StrongRuleNode
>
}
impl
<
'
a
>
Iterator
for
SelfAndAncestors
<
'
a
>
{
type
Item
=
&
'
a
StrongRuleNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
current
.
map
(
|
node
|
{
self
.
current
=
node
.
parent
(
)
;
node
}
)
}
}
