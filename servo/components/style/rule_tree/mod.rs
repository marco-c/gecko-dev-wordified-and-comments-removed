#
!
[
allow
(
unsafe_code
)
]
#
[
cfg
(
feature
=
"
servo
"
)
]
use
heapsize
:
:
HeapSizeOf
;
use
properties
:
:
{
Importance
PropertyDeclarationBlock
}
;
use
shared_lock
:
:
{
Locked
StylesheetGuards
SharedRwLockReadGuard
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicPtr
AtomicUsize
Ordering
}
;
use
stylearc
:
:
Arc
;
use
stylesheets
:
:
StyleRule
;
use
thread_state
;
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
RuleTree
{
root
:
StrongRuleNode
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
StyleSource
{
Style
(
Arc
<
Locked
<
StyleRule
>
>
)
Declarations
(
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
)
}
impl
StyleSource
{
#
[
inline
]
fn
ptr_equals
(
&
self
other
:
&
Self
)
-
>
bool
{
use
self
:
:
StyleSource
:
:
*
;
match
(
self
other
)
{
(
&
Style
(
ref
one
)
&
Style
(
ref
other
)
)
=
>
Arc
:
:
ptr_eq
(
one
other
)
(
&
Declarations
(
ref
one
)
&
Declarations
(
ref
other
)
)
=
>
Arc
:
:
ptr_eq
(
one
other
)
_
=
>
false
}
}
fn
dump
<
W
:
Write
>
(
&
self
guard
:
&
SharedRwLockReadGuard
writer
:
&
mut
W
)
{
use
self
:
:
StyleSource
:
:
*
;
if
let
Style
(
ref
rule
)
=
*
self
{
let
rule
=
rule
.
read_with
(
guard
)
;
let
_
=
write
!
(
writer
"
{
:
?
}
"
rule
.
selectors
)
;
}
let
_
=
write
!
(
writer
"
-
>
{
:
?
}
"
self
.
read
(
guard
)
.
declarations
(
)
)
;
}
#
[
inline
]
pub
fn
read
<
'
a
>
(
&
'
a
self
guard
:
&
'
a
SharedRwLockReadGuard
)
-
>
&
'
a
PropertyDeclarationBlock
{
let
block
=
match
*
self
{
StyleSource
:
:
Style
(
ref
rule
)
=
>
&
rule
.
read_with
(
guard
)
.
block
StyleSource
:
:
Declarations
(
ref
block
)
=
>
block
}
;
block
.
read_with
(
guard
)
}
}
const
FREE_LIST_SENTINEL
:
*
mut
RuleNode
=
0x01
as
*
mut
RuleNode
;
impl
RuleTree
{
pub
fn
new
(
)
-
>
Self
{
RuleTree
{
root
:
StrongRuleNode
:
:
new
(
Box
:
:
new
(
RuleNode
:
:
root
(
)
)
)
}
}
pub
fn
root
(
&
self
)
-
>
StrongRuleNode
{
self
.
root
.
clone
(
)
}
fn
dump
<
W
:
Write
>
(
&
self
guards
:
&
StylesheetGuards
writer
:
&
mut
W
)
{
let
_
=
writeln
!
(
writer
"
+
RuleTree
"
)
;
self
.
root
.
get
(
)
.
dump
(
guards
writer
0
)
;
}
pub
fn
dump_stdout
(
&
self
guards
:
&
StylesheetGuards
)
{
let
mut
stdout
=
io
:
:
stdout
(
)
;
self
.
dump
(
guards
&
mut
stdout
)
;
}
pub
fn
insert_ordered_rules_with_important
<
'
a
I
>
(
&
self
iter
:
I
guards
:
&
StylesheetGuards
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
use
self
:
:
CascadeLevel
:
:
*
;
let
mut
current
=
self
.
root
.
clone
(
)
;
let
mut
last_level
=
current
.
get
(
)
.
level
;
let
mut
found_important
=
false
;
let
mut
important_style_attr
=
None
;
let
mut
important_author
=
SmallVec
:
:
<
[
StyleSource
;
4
]
>
:
:
new
(
)
;
let
mut
important_user
=
SmallVec
:
:
<
[
StyleSource
;
4
]
>
:
:
new
(
)
;
let
mut
important_ua
=
SmallVec
:
:
<
[
StyleSource
;
4
]
>
:
:
new
(
)
;
let
mut
transition
=
None
;
for
(
source
level
)
in
iter
{
debug_assert
!
(
last_level
<
=
level
"
Not
really
ordered
"
)
;
debug_assert
!
(
!
level
.
is_important
(
)
"
Important
levels
handled
internally
"
)
;
let
(
any_normal
any_important
)
=
{
let
pdb
=
source
.
read
(
level
.
guard
(
guards
)
)
;
(
pdb
.
any_normal
(
)
pdb
.
any_important
(
)
)
}
;
if
any_important
{
found_important
=
true
;
match
level
{
AuthorNormal
=
>
important_author
.
push
(
source
.
clone
(
)
)
UANormal
=
>
important_ua
.
push
(
source
.
clone
(
)
)
UserNormal
=
>
important_user
.
push
(
source
.
clone
(
)
)
StyleAttributeNormal
=
>
{
debug_assert
!
(
important_style_attr
.
is_none
(
)
)
;
important_style_attr
=
Some
(
source
.
clone
(
)
)
;
}
_
=
>
{
}
}
;
}
if
any_normal
{
if
matches
!
(
level
Transitions
)
&
&
found_important
{
debug_assert
!
(
transition
.
is_none
(
)
)
;
transition
=
Some
(
source
)
;
}
else
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
level
)
;
}
}
last_level
=
level
;
}
if
!
found_important
{
return
current
;
}
for
source
in
important_author
.
into_iter
(
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
AuthorImportant
)
;
}
if
let
Some
(
source
)
=
important_style_attr
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
StyleAttributeImportant
)
;
}
for
source
in
important_user
.
into_iter
(
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
UserImportant
)
;
}
for
source
in
important_ua
.
into_iter
(
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
UAImportant
)
;
}
if
let
Some
(
source
)
=
transition
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
Transitions
)
;
}
current
}
pub
fn
insert_ordered_rules
<
'
a
I
>
(
&
self
iter
:
I
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
self
.
insert_ordered_rules_from
(
self
.
root
.
clone
(
)
iter
)
}
fn
insert_ordered_rules_from
<
'
a
I
>
(
&
self
from
:
StrongRuleNode
iter
:
I
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
let
mut
current
=
from
;
let
mut
last_level
=
current
.
get
(
)
.
level
;
for
(
source
level
)
in
iter
{
debug_assert
!
(
last_level
<
=
level
"
Not
really
ordered
"
)
;
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
level
)
;
last_level
=
level
;
}
current
}
pub
unsafe
fn
gc
(
&
self
)
{
self
.
root
.
gc
(
)
;
}
pub
unsafe
fn
maybe_gc
(
&
self
)
{
self
.
root
.
maybe_gc
(
)
;
}
pub
fn
update_rule_at_level
(
&
self
level
:
CascadeLevel
pdb
:
Option
<
&
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
path
:
&
StrongRuleNode
guards
:
&
StylesheetGuards
)
-
>
Option
<
StrongRuleNode
>
{
debug_assert
!
(
level
.
is_unique_per_element
(
)
)
;
let
mut
current
=
path
.
clone
(
)
;
let
mut
children
=
vec
!
[
]
;
while
current
.
get
(
)
.
level
>
level
{
children
.
push
(
(
current
.
get
(
)
.
source
.
clone
(
)
.
unwrap
(
)
current
.
get
(
)
.
level
)
)
;
current
=
current
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
;
}
if
current
.
get
(
)
.
level
=
=
level
{
if
let
Some
(
pdb
)
=
pdb
{
let
is_here_already
=
match
current
.
get
(
)
.
source
.
as_ref
(
)
{
Some
(
&
StyleSource
:
:
Declarations
(
ref
already_here
)
)
=
>
{
Arc
:
:
ptr_eq
(
pdb
already_here
)
}
_
=
>
unreachable
!
(
"
Replacing
non
-
declarations
style
?
"
)
}
;
if
is_here_already
{
debug
!
(
"
Picking
the
fast
path
in
rule
replacement
"
)
;
return
None
;
}
}
current
=
current
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
;
}
debug_assert
!
(
current
.
get
(
)
.
level
!
=
level
"
Multiple
rules
should
'
ve
been
replaced
?
"
)
;
if
let
Some
(
pdb
)
=
pdb
{
if
level
.
is_important
(
)
{
if
pdb
.
read_with
(
level
.
guard
(
guards
)
)
.
any_important
(
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
StyleSource
:
:
Declarations
(
pdb
.
clone
(
)
)
level
)
;
}
}
else
{
if
pdb
.
read_with
(
level
.
guard
(
guards
)
)
.
any_normal
(
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
StyleSource
:
:
Declarations
(
pdb
.
clone
(
)
)
level
)
;
}
}
}
Some
(
self
.
insert_ordered_rules_from
(
current
children
.
into_iter
(
)
.
rev
(
)
)
)
}
pub
fn
remove_transition_rule_if_applicable
(
&
self
path
:
&
StrongRuleNode
)
-
>
StrongRuleNode
{
if
path
.
cascade_level
(
)
!
=
CascadeLevel
:
:
Transitions
{
return
path
.
clone
(
)
;
}
path
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
}
pub
fn
remove_animation_rules
(
&
self
path
:
&
StrongRuleNode
)
-
>
StrongRuleNode
{
if
!
path
.
has_animation_or_transition_rules
(
)
{
return
path
.
clone
(
)
;
}
let
iter
=
path
.
self_and_ancestors
(
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
=
CascadeLevel
:
:
SMILOverride
)
;
let
mut
last
=
path
;
let
mut
children
=
vec
!
[
]
;
for
node
in
iter
{
if
node
.
cascade_level
(
)
.
is_animation
(
)
{
children
.
push
(
(
node
.
get
(
)
.
source
.
clone
(
)
.
unwrap
(
)
node
.
cascade_level
(
)
)
)
;
}
last
=
node
;
}
self
.
insert_ordered_rules_from
(
last
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
children
.
into_iter
(
)
.
rev
(
)
)
}
}
const
RULE_TREE_GC_INTERVAL
:
usize
=
300
;
#
[
repr
(
u8
)
]
#
[
derive
(
Eq
PartialEq
Copy
Clone
Debug
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
CascadeLevel
{
UANormal
=
0
PresHints
UserNormal
AuthorNormal
StyleAttributeNormal
SMILOverride
Animations
AuthorImportant
StyleAttributeImportant
UserImportant
UAImportant
Transitions
}
impl
CascadeLevel
{
pub
fn
guard
<
'
a
>
(
&
self
guards
:
&
'
a
StylesheetGuards
<
'
a
>
)
-
>
&
'
a
SharedRwLockReadGuard
<
'
a
>
{
match
*
self
{
CascadeLevel
:
:
UANormal
|
CascadeLevel
:
:
UserNormal
|
CascadeLevel
:
:
UserImportant
|
CascadeLevel
:
:
UAImportant
=
>
guards
.
ua_or_user
_
=
>
guards
.
author
}
}
pub
fn
is_unique_per_element
(
&
self
)
-
>
bool
{
match
*
self
{
CascadeLevel
:
:
Transitions
|
CascadeLevel
:
:
Animations
|
CascadeLevel
:
:
SMILOverride
|
CascadeLevel
:
:
StyleAttributeNormal
|
CascadeLevel
:
:
StyleAttributeImportant
=
>
true
_
=
>
false
}
}
#
[
inline
]
pub
fn
is_important
(
&
self
)
-
>
bool
{
match
*
self
{
CascadeLevel
:
:
AuthorImportant
|
CascadeLevel
:
:
StyleAttributeImportant
|
CascadeLevel
:
:
UserImportant
|
CascadeLevel
:
:
UAImportant
=
>
true
_
=
>
false
}
}
#
[
inline
]
pub
fn
importance
(
&
self
)
-
>
Importance
{
if
self
.
is_important
(
)
{
Importance
:
:
Important
}
else
{
Importance
:
:
Normal
}
}
#
[
inline
]
pub
fn
is_animation
(
&
self
)
-
>
bool
{
match
*
self
{
CascadeLevel
:
:
SMILOverride
|
CascadeLevel
:
:
Animations
|
CascadeLevel
:
:
Transitions
=
>
true
_
=
>
false
}
}
}
pub
struct
RuleNode
{
root
:
Option
<
WeakRuleNode
>
parent
:
Option
<
StrongRuleNode
>
source
:
Option
<
StyleSource
>
level
:
CascadeLevel
refcount
:
AtomicUsize
first_child
:
AtomicPtr
<
RuleNode
>
next_sibling
:
AtomicPtr
<
RuleNode
>
prev_sibling
:
AtomicPtr
<
RuleNode
>
next_free
:
AtomicPtr
<
RuleNode
>
free_count
:
AtomicUsize
}
unsafe
impl
Sync
for
RuleTree
{
}
unsafe
impl
Send
for
RuleTree
{
}
impl
RuleNode
{
fn
new
(
root
:
WeakRuleNode
parent
:
StrongRuleNode
source
:
StyleSource
level
:
CascadeLevel
)
-
>
Self
{
debug_assert
!
(
root
.
upgrade
(
)
.
parent
(
)
.
is_none
(
)
)
;
RuleNode
{
root
:
Some
(
root
)
parent
:
Some
(
parent
)
source
:
Some
(
source
)
level
:
level
refcount
:
AtomicUsize
:
:
new
(
1
)
first_child
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
next_sibling
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
prev_sibling
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
next_free
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
free_count
:
AtomicUsize
:
:
new
(
0
)
}
}
fn
root
(
)
-
>
Self
{
RuleNode
{
root
:
None
parent
:
None
source
:
None
level
:
CascadeLevel
:
:
UANormal
refcount
:
AtomicUsize
:
:
new
(
1
)
first_child
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
next_sibling
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
prev_sibling
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
next_free
:
AtomicPtr
:
:
new
(
FREE_LIST_SENTINEL
)
free_count
:
AtomicUsize
:
:
new
(
0
)
}
}
fn
is_root
(
&
self
)
-
>
bool
{
self
.
parent
.
is_none
(
)
}
unsafe
fn
remove_from_child_list
(
&
self
)
{
debug
!
(
"
Remove
from
child
list
:
{
:
?
}
parent
:
{
:
?
}
"
self
as
*
const
RuleNode
self
.
parent
.
as_ref
(
)
.
map
(
|
p
|
p
.
ptr
(
)
)
)
;
let
prev_sibling
=
self
.
prev_sibling
.
swap
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
let
next_sibling
=
self
.
next_sibling
.
swap
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
if
prev_sibling
=
=
ptr
:
:
null_mut
(
)
{
let
parent
=
self
.
parent
.
as_ref
(
)
.
unwrap
(
)
;
parent
.
get
(
)
.
first_child
.
store
(
next_sibling
Ordering
:
:
Relaxed
)
;
}
else
{
let
previous
=
&
*
prev_sibling
;
previous
.
next_sibling
.
store
(
next_sibling
Ordering
:
:
Relaxed
)
;
}
if
next_sibling
!
=
ptr
:
:
null_mut
(
)
{
let
next
=
&
*
next_sibling
;
next
.
prev_sibling
.
store
(
prev_sibling
Ordering
:
:
Relaxed
)
;
}
}
fn
dump
<
W
:
Write
>
(
&
self
guards
:
&
StylesheetGuards
writer
:
&
mut
W
indent
:
usize
)
{
const
INDENT_INCREMENT
:
usize
=
4
;
for
_
in
0
.
.
indent
{
let
_
=
write
!
(
writer
"
"
)
;
}
let
_
=
writeln
!
(
writer
"
-
{
:
?
}
(
ref
:
{
:
?
}
parent
:
{
:
?
}
)
"
self
as
*
const
_
self
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
self
.
parent
.
as_ref
(
)
.
map
(
|
p
|
p
.
ptr
(
)
)
)
;
for
_
in
0
.
.
indent
{
let
_
=
write
!
(
writer
"
"
)
;
}
match
self
.
source
{
Some
(
ref
source
)
=
>
{
source
.
dump
(
self
.
level
.
guard
(
guards
)
writer
)
;
}
None
=
>
{
if
indent
!
=
0
{
warn
!
(
"
How
has
this
happened
?
"
)
;
}
let
_
=
write
!
(
writer
"
(
root
)
"
)
;
}
}
let
_
=
write
!
(
writer
"
\
n
"
)
;
for
child
in
self
.
iter_children
(
)
{
child
.
get
(
)
.
dump
(
guards
writer
indent
+
INDENT_INCREMENT
)
;
}
}
fn
iter_children
(
&
self
)
-
>
RuleChildrenListIter
{
let
first_child
=
self
.
first_child
.
load
(
Ordering
:
:
Acquire
)
;
RuleChildrenListIter
{
current
:
if
first_child
.
is_null
(
)
{
None
}
else
{
Some
(
WeakRuleNode
{
ptr
:
first_child
}
)
}
}
}
}
#
[
derive
(
Clone
)
]
struct
WeakRuleNode
{
ptr
:
*
mut
RuleNode
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
StrongRuleNode
{
ptr
:
*
mut
RuleNode
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
HeapSizeOf
for
StrongRuleNode
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
impl
StrongRuleNode
{
fn
new
(
n
:
Box
<
RuleNode
>
)
-
>
Self
{
debug_assert
!
(
n
.
parent
.
is_none
(
)
=
=
n
.
source
.
is_none
(
)
)
;
let
ptr
=
Box
:
:
into_raw
(
n
)
;
debug
!
(
"
Creating
rule
node
:
{
:
p
}
"
ptr
)
;
StrongRuleNode
{
ptr
:
ptr
}
}
fn
downgrade
(
&
self
)
-
>
WeakRuleNode
{
WeakRuleNode
{
ptr
:
self
.
ptr
}
}
fn
next_sibling
(
&
self
)
-
>
Option
<
WeakRuleNode
>
{
let
ptr
=
self
.
get
(
)
.
next_sibling
.
load
(
Ordering
:
:
Acquire
)
;
if
ptr
.
is_null
(
)
{
None
}
else
{
Some
(
WeakRuleNode
{
ptr
:
ptr
}
)
}
}
fn
parent
(
&
self
)
-
>
Option
<
&
StrongRuleNode
>
{
self
.
get
(
)
.
parent
.
as_ref
(
)
}
fn
ensure_child
(
&
self
root
:
WeakRuleNode
source
:
StyleSource
level
:
CascadeLevel
)
-
>
StrongRuleNode
{
let
mut
last
=
None
;
for
child
in
self
.
get
(
)
.
iter_children
(
)
{
if
child
.
get
(
)
.
level
=
=
level
&
&
child
.
get
(
)
.
source
.
as_ref
(
)
.
unwrap
(
)
.
ptr_equals
(
&
source
)
{
return
child
;
}
last
=
Some
(
child
)
;
}
let
mut
node
=
Box
:
:
new
(
RuleNode
:
:
new
(
root
self
.
clone
(
)
source
.
clone
(
)
level
)
)
;
let
new_ptr
:
*
mut
RuleNode
=
&
mut
*
node
;
loop
{
let
strong
;
{
let
next_sibling_ptr
=
match
last
{
Some
(
ref
l
)
=
>
&
l
.
get
(
)
.
next_sibling
None
=
>
&
self
.
get
(
)
.
first_child
}
;
let
existing
=
next_sibling_ptr
.
compare_and_swap
(
ptr
:
:
null_mut
(
)
new_ptr
Ordering
:
:
AcqRel
)
;
if
existing
=
=
ptr
:
:
null_mut
(
)
{
if
let
Some
(
ref
l
)
=
last
{
node
.
prev_sibling
.
store
(
l
.
ptr
(
)
Ordering
:
:
Relaxed
)
;
}
return
StrongRuleNode
:
:
new
(
node
)
;
}
strong
=
WeakRuleNode
{
ptr
:
existing
}
.
upgrade
(
)
;
if
strong
.
get
(
)
.
source
.
as_ref
(
)
.
unwrap
(
)
.
ptr_equals
(
&
source
)
{
return
strong
;
}
}
last
=
Some
(
strong
)
;
}
}
pub
fn
ptr
(
&
self
)
-
>
*
mut
RuleNode
{
self
.
ptr
}
fn
get
(
&
self
)
-
>
&
RuleNode
{
if
cfg
!
(
debug_assertions
)
{
let
node
=
unsafe
{
&
*
self
.
ptr
}
;
assert
!
(
node
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
>
0
)
;
}
unsafe
{
&
*
self
.
ptr
}
}
pub
fn
style_source
(
&
self
)
-
>
Option
<
&
StyleSource
>
{
self
.
get
(
)
.
source
.
as_ref
(
)
}
pub
fn
cascade_level
(
&
self
)
-
>
CascadeLevel
{
self
.
get
(
)
.
level
}
pub
fn
importance
(
&
self
)
-
>
Importance
{
self
.
get
(
)
.
level
.
importance
(
)
}
pub
fn
self_and_ancestors
(
&
self
)
-
>
SelfAndAncestors
{
SelfAndAncestors
{
current
:
Some
(
self
)
}
}
pub
unsafe
fn
has_children_for_testing
(
&
self
)
-
>
bool
{
!
self
.
get
(
)
.
first_child
.
load
(
Ordering
:
:
Relaxed
)
.
is_null
(
)
}
unsafe
fn
pop_from_free_list
(
&
self
)
-
>
Option
<
WeakRuleNode
>
{
let
me
=
&
*
self
.
ptr
;
debug_assert
!
(
me
.
is_root
(
)
)
;
if
!
cfg
!
(
feature
=
"
testing
"
)
{
debug_assert
!
(
!
thread_state
:
:
get
(
)
.
is_worker
(
)
&
&
(
thread_state
:
:
get
(
)
.
is_layout
(
)
|
|
thread_state
:
:
get
(
)
.
is_script
(
)
)
)
;
}
let
current
=
me
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
;
if
current
=
=
FREE_LIST_SENTINEL
{
return
None
;
}
debug_assert
!
(
!
current
.
is_null
(
)
"
Multiple
threads
are
operating
on
the
free
list
at
the
\
same
time
?
"
)
;
debug_assert
!
(
current
!
=
self
.
ptr
"
How
did
the
root
end
up
in
the
free
list
?
"
)
;
let
next
=
(
*
current
)
.
next_free
.
swap
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
debug_assert
!
(
!
next
.
is_null
(
)
"
How
did
a
null
pointer
end
up
in
the
free
list
?
"
)
;
me
.
next_free
.
store
(
next
Ordering
:
:
Relaxed
)
;
debug
!
(
"
Popping
from
free
list
:
cur
:
{
:
?
}
next
:
{
:
?
}
"
current
next
)
;
Some
(
WeakRuleNode
{
ptr
:
current
}
)
}
unsafe
fn
assert_free_list_has_no_duplicates_or_null
(
&
self
)
{
assert
!
(
cfg
!
(
debug_assertions
)
"
This
is
an
expensive
check
!
"
)
;
use
std
:
:
collections
:
:
HashSet
;
let
me
=
&
*
self
.
ptr
;
assert
!
(
me
.
is_root
(
)
)
;
let
mut
current
=
self
.
ptr
;
let
mut
seen
=
HashSet
:
:
new
(
)
;
while
current
!
=
FREE_LIST_SENTINEL
{
let
next
=
(
*
current
)
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
;
assert
!
(
!
next
.
is_null
(
)
)
;
assert
!
(
!
seen
.
contains
(
&
next
)
)
;
seen
.
insert
(
next
)
;
current
=
next
;
}
}
unsafe
fn
gc
(
&
self
)
{
if
cfg
!
(
debug_assertions
)
{
self
.
assert_free_list_has_no_duplicates_or_null
(
)
;
}
let
me
=
&
*
self
.
ptr
;
debug_assert
!
(
me
.
is_root
(
)
"
Can
'
t
call
GC
on
a
non
-
root
node
!
"
)
;
while
let
Some
(
weak
)
=
self
.
pop_from_free_list
(
)
{
let
needs_drop
=
{
let
node
=
&
*
weak
.
ptr
(
)
;
if
node
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
=
=
0
{
node
.
remove_from_child_list
(
)
;
true
}
else
{
false
}
}
;
debug
!
(
"
GC
'
ing
{
:
?
}
:
{
}
"
weak
.
ptr
(
)
needs_drop
)
;
if
needs_drop
{
let
_
=
Box
:
:
from_raw
(
weak
.
ptr
(
)
)
;
}
}
me
.
free_count
.
store
(
0
Ordering
:
:
Relaxed
)
;
debug_assert
!
(
me
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
=
=
FREE_LIST_SENTINEL
)
;
}
unsafe
fn
maybe_gc
(
&
self
)
{
debug_assert
!
(
self
.
get
(
)
.
is_root
(
)
"
Can
'
t
call
GC
on
a
non
-
root
node
!
"
)
;
if
self
.
get
(
)
.
free_count
.
load
(
Ordering
:
:
Relaxed
)
>
RULE_TREE_GC_INTERVAL
{
self
.
gc
(
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
has_author_specified_rules
<
E
>
(
&
self
mut
element
:
E
guards
:
&
StylesheetGuards
rule_type_mask
:
u32
author_colors_allowed
:
bool
)
-
>
bool
where
E
:
:
:
dom
:
:
TElement
{
use
cssparser
:
:
RGBA
;
use
gecko_bindings
:
:
structs
:
:
{
NS_AUTHOR_SPECIFIED_BACKGROUND
NS_AUTHOR_SPECIFIED_BORDER
}
;
use
gecko_bindings
:
:
structs
:
:
{
NS_AUTHOR_SPECIFIED_PADDING
NS_AUTHOR_SPECIFIED_TEXT_SHADOW
}
;
use
properties
:
:
{
CSSWideKeyword
LonghandId
LonghandIdSet
}
;
use
properties
:
:
{
PropertyDeclaration
PropertyDeclarationId
}
;
use
std
:
:
borrow
:
:
Cow
;
use
values
:
:
specified
:
:
Color
;
const
BACKGROUND_PROPS
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
BackgroundColor
LonghandId
:
:
BackgroundImage
]
;
const
BORDER_PROPS
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
BorderTopColor
LonghandId
:
:
BorderTopStyle
LonghandId
:
:
BorderTopWidth
LonghandId
:
:
BorderRightColor
LonghandId
:
:
BorderRightStyle
LonghandId
:
:
BorderRightWidth
LonghandId
:
:
BorderBottomColor
LonghandId
:
:
BorderBottomStyle
LonghandId
:
:
BorderBottomWidth
LonghandId
:
:
BorderLeftColor
LonghandId
:
:
BorderLeftStyle
LonghandId
:
:
BorderLeftWidth
LonghandId
:
:
BorderTopLeftRadius
LonghandId
:
:
BorderTopRightRadius
LonghandId
:
:
BorderBottomRightRadius
LonghandId
:
:
BorderBottomLeftRadius
]
;
const
PADDING_PROPS
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
PaddingTop
LonghandId
:
:
PaddingRight
LonghandId
:
:
PaddingBottom
LonghandId
:
:
PaddingLeft
]
;
const
TEXT_SHADOW_PROPS
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
TextShadow
]
;
fn
inherited
(
id
:
LonghandId
)
-
>
bool
{
id
=
=
LonghandId
:
:
TextShadow
}
let
mut
properties
=
LonghandIdSet
:
:
new
(
)
;
if
rule_type_mask
&
NS_AUTHOR_SPECIFIED_BACKGROUND
!
=
0
{
for
id
in
BACKGROUND_PROPS
{
properties
.
insert
(
*
id
)
;
}
}
if
rule_type_mask
&
NS_AUTHOR_SPECIFIED_BORDER
!
=
0
{
for
id
in
BORDER_PROPS
{
properties
.
insert
(
*
id
)
;
}
}
if
rule_type_mask
&
NS_AUTHOR_SPECIFIED_PADDING
!
=
0
{
for
id
in
PADDING_PROPS
{
properties
.
insert
(
*
id
)
;
}
}
if
rule_type_mask
&
NS_AUTHOR_SPECIFIED_TEXT_SHADOW
!
=
0
{
for
id
in
TEXT_SHADOW_PROPS
{
properties
.
insert
(
*
id
)
;
}
}
const
IGNORED_WHEN_COLORS_DISABLED
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
BackgroundImage
LonghandId
:
:
BorderTopColor
LonghandId
:
:
BorderRightColor
LonghandId
:
:
BorderBottomColor
LonghandId
:
:
BorderLeftColor
LonghandId
:
:
TextShadow
]
;
if
!
author_colors_allowed
{
for
id
in
IGNORED_WHEN_COLORS_DISABLED
{
properties
.
remove
(
*
id
)
;
}
}
let
mut
element_rule_node
=
Cow
:
:
Borrowed
(
self
)
;
loop
{
let
mut
inherited_properties
=
LonghandIdSet
:
:
new
(
)
;
let
mut
have_explicit_ua_inherit
=
false
;
for
node
in
element_rule_node
.
self_and_ancestors
(
)
{
let
declarations
=
match
node
.
style_source
(
)
{
Some
(
source
)
=
>
source
.
read
(
node
.
cascade_level
(
)
.
guard
(
guards
)
)
.
declarations
(
)
None
=
>
continue
}
;
let
node_importance
=
node
.
importance
(
)
;
let
longhands
=
declarations
.
iter
(
)
.
rev
(
)
.
filter_map
(
|
&
(
ref
declaration
importance
)
|
{
if
importance
!
=
node_importance
{
return
None
}
match
declaration
.
id
(
)
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
{
Some
(
(
id
declaration
)
)
}
_
=
>
None
}
}
)
;
match
node
.
cascade_level
(
)
{
CascadeLevel
:
:
UANormal
|
CascadeLevel
:
:
UAImportant
|
CascadeLevel
:
:
UserNormal
|
CascadeLevel
:
:
UserImportant
=
>
{
for
(
id
declaration
)
in
longhands
{
if
properties
.
contains
(
id
)
{
properties
.
remove
(
id
)
;
if
declaration
.
get_css_wide_keyword
(
)
=
=
Some
(
CSSWideKeyword
:
:
Inherit
)
|
|
(
declaration
.
get_css_wide_keyword
(
)
=
=
Some
(
CSSWideKeyword
:
:
Unset
)
&
&
inherited
(
id
)
)
{
have_explicit_ua_inherit
=
true
;
inherited_properties
.
insert
(
id
)
;
}
}
}
}
CascadeLevel
:
:
PresHints
|
CascadeLevel
:
:
AuthorNormal
|
CascadeLevel
:
:
StyleAttributeNormal
|
CascadeLevel
:
:
SMILOverride
|
CascadeLevel
:
:
Animations
|
CascadeLevel
:
:
AuthorImportant
|
CascadeLevel
:
:
StyleAttributeImportant
|
CascadeLevel
:
:
Transitions
=
>
{
for
(
id
declaration
)
in
longhands
{
if
properties
.
contains
(
id
)
{
if
!
author_colors_allowed
{
if
let
PropertyDeclaration
:
:
BackgroundColor
(
ref
color
)
=
*
declaration
{
return
color
.
parsed
=
=
Color
:
:
RGBA
(
RGBA
:
:
transparent
(
)
)
}
}
return
true
}
}
}
}
}
if
!
have_explicit_ua_inherit
{
break
}
element
=
match
element
.
parent_element
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
break
}
;
let
parent_data
=
element
.
mutate_data
(
)
.
unwrap
(
)
;
let
parent_rule_node
=
parent_data
.
styles
(
)
.
primary
.
rules
.
clone
(
)
;
element_rule_node
=
Cow
:
:
Owned
(
parent_rule_node
)
;
properties
=
inherited_properties
;
}
false
}
pub
fn
has_animation_or_transition_rules
(
&
self
)
-
>
bool
{
self
.
self_and_ancestors
(
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
=
CascadeLevel
:
:
SMILOverride
)
.
any
(
|
node
|
node
.
cascade_level
(
)
.
is_animation
(
)
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
SelfAndAncestors
<
'
a
>
{
current
:
Option
<
&
'
a
StrongRuleNode
>
}
impl
<
'
a
>
Iterator
for
SelfAndAncestors
<
'
a
>
{
type
Item
=
&
'
a
StrongRuleNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
current
.
map
(
|
node
|
{
self
.
current
=
node
.
parent
(
)
;
node
}
)
}
}
impl
Clone
for
StrongRuleNode
{
fn
clone
(
&
self
)
-
>
Self
{
debug
!
(
"
{
:
?
}
:
{
:
?
}
+
"
self
.
ptr
(
)
self
.
get
(
)
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
)
;
debug_assert
!
(
self
.
get
(
)
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
>
0
)
;
self
.
get
(
)
.
refcount
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
StrongRuleNode
{
ptr
:
self
.
ptr
}
}
}
impl
Drop
for
StrongRuleNode
{
fn
drop
(
&
mut
self
)
{
let
node
=
unsafe
{
&
*
self
.
ptr
}
;
debug
!
(
"
{
:
?
}
:
{
:
?
}
-
"
self
.
ptr
(
)
node
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
)
;
debug
!
(
"
Dropping
node
:
{
:
?
}
root
:
{
:
?
}
parent
:
{
:
?
}
"
self
.
ptr
node
.
root
.
as_ref
(
)
.
map
(
|
r
|
r
.
ptr
(
)
)
node
.
parent
.
as_ref
(
)
.
map
(
|
p
|
p
.
ptr
(
)
)
)
;
let
should_drop
=
{
debug_assert
!
(
node
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
>
0
)
;
node
.
refcount
.
fetch_sub
(
1
Ordering
:
:
Relaxed
)
=
=
1
}
;
if
!
should_drop
{
return
}
debug_assert_eq
!
(
node
.
first_child
.
load
(
Ordering
:
:
Acquire
)
ptr
:
:
null_mut
(
)
)
;
if
node
.
parent
.
is_none
(
)
{
debug
!
(
"
Dropping
root
node
!
"
)
;
unsafe
{
self
.
gc
(
)
}
;
let
_
=
unsafe
{
Box
:
:
from_raw
(
self
.
ptr
(
)
)
}
;
return
;
}
let
root
=
unsafe
{
&
*
node
.
root
.
as_ref
(
)
.
unwrap
(
)
.
ptr
(
)
}
;
let
free_list
=
&
root
.
next_free
;
if
node
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
!
=
ptr
:
:
null_mut
(
)
{
return
;
}
let
mut
old_head
=
free_list
.
load
(
Ordering
:
:
Relaxed
)
;
loop
{
match
free_list
.
compare_exchange_weak
(
old_head
ptr
:
:
null_mut
(
)
Ordering
:
:
Acquire
Ordering
:
:
Relaxed
)
{
Ok
(
.
.
)
=
>
{
if
old_head
!
=
ptr
:
:
null_mut
(
)
{
break
;
}
}
Err
(
new
)
=
>
old_head
=
new
}
}
if
node
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
!
=
ptr
:
:
null_mut
(
)
{
free_list
.
store
(
old_head
Ordering
:
:
Release
)
;
return
;
}
node
.
next_free
.
store
(
old_head
Ordering
:
:
Relaxed
)
;
free_list
.
store
(
self
.
ptr
(
)
Ordering
:
:
Release
)
;
}
}
impl
<
'
a
>
From
<
&
'
a
StrongRuleNode
>
for
WeakRuleNode
{
fn
from
(
node
:
&
'
a
StrongRuleNode
)
-
>
Self
{
WeakRuleNode
{
ptr
:
node
.
ptr
(
)
}
}
}
impl
WeakRuleNode
{
fn
upgrade
(
&
self
)
-
>
StrongRuleNode
{
debug
!
(
"
Upgrading
weak
node
:
{
:
p
}
"
self
.
ptr
(
)
)
;
let
node
=
unsafe
{
&
*
self
.
ptr
}
;
node
.
refcount
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
StrongRuleNode
{
ptr
:
self
.
ptr
}
}
fn
ptr
(
&
self
)
-
>
*
mut
RuleNode
{
self
.
ptr
}
}
struct
RuleChildrenListIter
{
current
:
Option
<
WeakRuleNode
>
}
impl
Iterator
for
RuleChildrenListIter
{
type
Item
=
StrongRuleNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
current
.
take
(
)
.
map
(
|
current
|
{
let
current
=
current
.
upgrade
(
)
;
self
.
current
=
current
.
next_sibling
(
)
;
current
}
)
}
}
