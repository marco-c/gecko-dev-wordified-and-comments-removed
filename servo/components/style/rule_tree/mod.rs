use
crate
:
:
applicable_declarations
:
:
ApplicableDeclarationList
;
use
crate
:
:
properties
:
:
{
LonghandIdSet
PropertyDeclarationBlock
}
;
use
crate
:
:
shared_lock
:
:
{
Locked
StylesheetGuards
}
;
use
servo_arc
:
:
{
Arc
ArcBorrow
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
io
:
:
{
self
Write
}
;
mod
core
;
mod
level
;
mod
map
;
mod
source
;
pub
use
self
:
:
core
:
:
{
RuleTree
StrongRuleNode
}
;
pub
use
self
:
:
level
:
:
{
CascadeLevel
ShadowCascadeOrder
}
;
pub
use
self
:
:
source
:
:
StyleSource
;
impl
RuleTree
{
fn
dump
<
W
:
Write
>
(
&
self
guards
:
&
StylesheetGuards
writer
:
&
mut
W
)
{
let
_
=
writeln
!
(
writer
"
+
RuleTree
"
)
;
self
.
root
(
)
.
dump
(
guards
writer
0
)
;
}
pub
fn
dump_stdout
(
&
self
guards
:
&
StylesheetGuards
)
{
let
mut
stdout
=
io
:
:
stdout
(
)
;
self
.
dump
(
guards
&
mut
stdout
)
;
}
pub
fn
insert_ordered_rules_with_important
<
'
a
I
>
(
&
self
iter
:
I
guards
:
&
StylesheetGuards
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
use
self
:
:
CascadeLevel
:
:
*
;
let
mut
current
=
self
.
root
(
)
.
clone
(
)
;
let
mut
found_important
=
false
;
let
mut
important_author
=
SmallVec
:
:
<
[
(
StyleSource
ShadowCascadeOrder
)
;
4
]
>
:
:
new
(
)
;
let
mut
important_user
=
SmallVec
:
:
<
[
StyleSource
;
4
]
>
:
:
new
(
)
;
let
mut
important_ua
=
SmallVec
:
:
<
[
StyleSource
;
4
]
>
:
:
new
(
)
;
let
mut
transition
=
None
;
for
(
source
level
)
in
iter
{
debug_assert
!
(
!
level
.
is_important
(
)
"
Important
levels
handled
internally
"
)
;
let
any_important
=
{
let
pdb
=
source
.
read
(
level
.
guard
(
guards
)
)
;
pdb
.
any_important
(
)
}
;
if
any_important
{
found_important
=
true
;
match
level
{
AuthorNormal
{
shadow_cascade_order
}
=
>
{
important_author
.
push
(
(
source
.
clone
(
)
shadow_cascade_order
)
)
;
}
UANormal
=
>
important_ua
.
push
(
source
.
clone
(
)
)
UserNormal
=
>
important_user
.
push
(
source
.
clone
(
)
)
_
=
>
{
}
}
;
}
if
matches
!
(
level
Transitions
)
&
&
found_important
{
debug_assert
!
(
transition
.
is_none
(
)
)
;
transition
=
Some
(
source
)
;
}
else
{
current
=
current
.
ensure_child
(
self
.
root
(
)
source
level
)
;
}
}
if
!
found_important
{
return
current
;
}
if
!
important_author
.
is_empty
(
)
&
&
important_author
.
first
(
)
.
unwrap
(
)
.
1
!
=
important_author
.
last
(
)
.
unwrap
(
)
.
1
{
important_author
.
sort_by_key
(
|
&
(
_
order
)
|
-
order
)
;
}
for
(
source
shadow_cascade_order
)
in
important_author
.
drain
(
.
.
)
{
current
=
current
.
ensure_child
(
self
.
root
(
)
source
AuthorImportant
{
shadow_cascade_order
:
-
shadow_cascade_order
}
)
;
}
for
source
in
important_user
.
drain
(
.
.
)
{
current
=
current
.
ensure_child
(
self
.
root
(
)
source
UserImportant
)
;
}
for
source
in
important_ua
.
drain
(
.
.
)
{
current
=
current
.
ensure_child
(
self
.
root
(
)
source
UAImportant
)
;
}
if
let
Some
(
source
)
=
transition
{
current
=
current
.
ensure_child
(
self
.
root
(
)
source
Transitions
)
;
}
current
}
pub
fn
compute_rule_node
(
&
self
applicable_declarations
:
&
mut
ApplicableDeclarationList
guards
:
&
StylesheetGuards
)
-
>
StrongRuleNode
{
self
.
insert_ordered_rules_with_important
(
applicable_declarations
.
drain
(
.
.
)
.
map
(
|
d
|
d
.
for_rule_tree
(
)
)
guards
)
}
pub
fn
insert_ordered_rules
<
'
a
I
>
(
&
self
iter
:
I
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
self
.
insert_ordered_rules_from
(
self
.
root
(
)
.
clone
(
)
iter
)
}
fn
insert_ordered_rules_from
<
'
a
I
>
(
&
self
from
:
StrongRuleNode
iter
:
I
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
let
mut
current
=
from
;
for
(
source
level
)
in
iter
{
current
=
current
.
ensure_child
(
self
.
root
(
)
source
level
)
;
}
current
}
pub
fn
update_rule_at_level
(
&
self
level
:
CascadeLevel
pdb
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
path
:
&
StrongRuleNode
guards
:
&
StylesheetGuards
important_rules_changed
:
&
mut
bool
)
-
>
Option
<
StrongRuleNode
>
{
let
mut
current
=
path
.
clone
(
)
;
*
important_rules_changed
=
false
;
let
mut
children
=
SmallVec
:
:
<
[
_
;
10
]
>
:
:
new
(
)
;
while
current
.
cascade_level
(
)
>
level
{
children
.
push
(
(
current
.
style_source
(
)
.
unwrap
(
)
.
clone
(
)
current
.
cascade_level
(
)
)
)
;
current
=
current
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
;
}
if
current
.
cascade_level
(
)
=
=
level
{
*
important_rules_changed
|
=
level
.
is_important
(
)
;
let
current_decls
=
current
.
style_source
(
)
.
unwrap
(
)
.
as_declarations
(
)
;
if
let
(
Some
(
ref
pdb
)
Some
(
ref
current_decls
)
)
=
(
pdb
current_decls
)
{
let
is_here_already
=
ArcBorrow
:
:
ptr_eq
(
pdb
current_decls
)
;
if
is_here_already
{
debug
!
(
"
Picking
the
fast
path
in
rule
replacement
"
)
;
return
None
;
}
}
if
current_decls
.
is_some
(
)
{
current
=
current
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
;
}
}
if
let
Some
(
pdb
)
=
pdb
{
if
level
.
is_important
(
)
{
if
pdb
.
read_with
(
level
.
guard
(
guards
)
)
.
any_important
(
)
{
current
=
current
.
ensure_child
(
self
.
root
(
)
StyleSource
:
:
from_declarations
(
pdb
.
clone_arc
(
)
)
level
)
;
*
important_rules_changed
=
true
;
}
}
else
{
if
pdb
.
read_with
(
level
.
guard
(
guards
)
)
.
any_normal
(
)
{
current
=
current
.
ensure_child
(
self
.
root
(
)
StyleSource
:
:
from_declarations
(
pdb
.
clone_arc
(
)
)
level
)
;
}
}
}
let
rule
=
self
.
insert_ordered_rules_from
(
current
children
.
drain
(
.
.
)
.
rev
(
)
)
;
Some
(
rule
)
}
pub
fn
remove_transition_rule_if_applicable
(
&
self
path
:
&
StrongRuleNode
)
-
>
StrongRuleNode
{
if
path
.
cascade_level
(
)
!
=
CascadeLevel
:
:
Transitions
{
return
path
.
clone
(
)
;
}
path
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
}
pub
fn
remove_animation_rules
(
&
self
path
:
&
StrongRuleNode
)
-
>
StrongRuleNode
{
if
!
path
.
has_animation_or_transition_rules
(
)
{
return
path
.
clone
(
)
;
}
let
iter
=
path
.
self_and_ancestors
(
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
=
CascadeLevel
:
:
SMILOverride
)
;
let
mut
last
=
path
;
let
mut
children
=
SmallVec
:
:
<
[
_
;
10
]
>
:
:
new
(
)
;
for
node
in
iter
{
if
!
node
.
cascade_level
(
)
.
is_animation
(
)
{
children
.
push
(
(
node
.
style_source
(
)
.
unwrap
(
)
.
clone
(
)
node
.
cascade_level
(
)
)
)
;
}
last
=
node
;
}
let
rule
=
self
.
insert_ordered_rules_from
(
last
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
children
.
drain
(
.
.
)
.
rev
(
)
)
;
rule
}
pub
fn
add_animation_rules_at_transition_level
(
&
self
path
:
&
StrongRuleNode
pdb
:
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
guards
:
&
StylesheetGuards
)
-
>
StrongRuleNode
{
let
mut
dummy
=
false
;
self
.
update_rule_at_level
(
CascadeLevel
:
:
Transitions
Some
(
pdb
.
borrow_arc
(
)
)
path
guards
&
mut
dummy
)
.
expect
(
"
Should
return
a
valid
rule
node
"
)
}
}
impl
StrongRuleNode
{
pub
fn
self_and_ancestors
(
&
self
)
-
>
SelfAndAncestors
{
SelfAndAncestors
{
current
:
Some
(
self
)
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
has_author_specified_rules
<
E
>
(
&
self
mut
element
:
E
mut
pseudo
:
Option
<
PseudoElement
>
guards
:
&
StylesheetGuards
rule_type_mask
:
u32
author_colors_allowed
:
bool
)
-
>
bool
where
E
:
crate
:
:
dom
:
:
TElement
{
use
crate
:
:
gecko_bindings
:
:
structs
:
:
NS_AUTHOR_SPECIFIED_BACKGROUND
;
use
crate
:
:
gecko_bindings
:
:
structs
:
:
NS_AUTHOR_SPECIFIED_BORDER
;
use
crate
:
:
gecko_bindings
:
:
structs
:
:
NS_AUTHOR_SPECIFIED_PADDING
;
use
crate
:
:
properties
:
:
{
CSSWideKeyword
LonghandId
}
;
use
crate
:
:
properties
:
:
{
PropertyDeclaration
PropertyDeclarationId
}
;
use
std
:
:
borrow
:
:
Cow
;
const
BACKGROUND_PROPS
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
BackgroundColor
LonghandId
:
:
BackgroundImage
]
;
const
BORDER_PROPS
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
BorderTopColor
LonghandId
:
:
BorderTopStyle
LonghandId
:
:
BorderTopWidth
LonghandId
:
:
BorderRightColor
LonghandId
:
:
BorderRightStyle
LonghandId
:
:
BorderRightWidth
LonghandId
:
:
BorderBottomColor
LonghandId
:
:
BorderBottomStyle
LonghandId
:
:
BorderBottomWidth
LonghandId
:
:
BorderLeftColor
LonghandId
:
:
BorderLeftStyle
LonghandId
:
:
BorderLeftWidth
LonghandId
:
:
BorderTopLeftRadius
LonghandId
:
:
BorderTopRightRadius
LonghandId
:
:
BorderBottomRightRadius
LonghandId
:
:
BorderBottomLeftRadius
LonghandId
:
:
BorderInlineStartColor
LonghandId
:
:
BorderInlineStartStyle
LonghandId
:
:
BorderInlineStartWidth
LonghandId
:
:
BorderInlineEndColor
LonghandId
:
:
BorderInlineEndStyle
LonghandId
:
:
BorderInlineEndWidth
LonghandId
:
:
BorderBlockStartColor
LonghandId
:
:
BorderBlockStartStyle
LonghandId
:
:
BorderBlockStartWidth
LonghandId
:
:
BorderBlockEndColor
LonghandId
:
:
BorderBlockEndStyle
LonghandId
:
:
BorderBlockEndWidth
]
;
const
PADDING_PROPS
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
PaddingTop
LonghandId
:
:
PaddingRight
LonghandId
:
:
PaddingBottom
LonghandId
:
:
PaddingLeft
LonghandId
:
:
PaddingInlineStart
LonghandId
:
:
PaddingInlineEnd
LonghandId
:
:
PaddingBlockStart
LonghandId
:
:
PaddingBlockEnd
]
;
let
mut
properties
=
LonghandIdSet
:
:
new
(
)
;
if
rule_type_mask
&
NS_AUTHOR_SPECIFIED_BACKGROUND
!
=
0
{
for
id
in
BACKGROUND_PROPS
{
properties
.
insert
(
*
id
)
;
}
}
if
rule_type_mask
&
NS_AUTHOR_SPECIFIED_BORDER
!
=
0
{
for
id
in
BORDER_PROPS
{
properties
.
insert
(
*
id
)
;
}
}
if
rule_type_mask
&
NS_AUTHOR_SPECIFIED_PADDING
!
=
0
{
for
id
in
PADDING_PROPS
{
properties
.
insert
(
*
id
)
;
}
}
if
!
author_colors_allowed
{
properties
.
remove_all
(
LonghandIdSet
:
:
ignored_when_colors_disabled
(
)
)
;
if
rule_type_mask
&
NS_AUTHOR_SPECIFIED_BACKGROUND
!
=
0
{
properties
.
insert
(
LonghandId
:
:
BackgroundColor
)
;
}
}
let
mut
element_rule_node
=
Cow
:
:
Borrowed
(
self
)
;
loop
{
let
mut
inherited_properties
=
LonghandIdSet
:
:
new
(
)
;
let
mut
have_explicit_ua_inherit
=
false
;
for
node
in
element_rule_node
.
self_and_ancestors
(
)
{
let
source
=
node
.
style_source
(
)
;
let
declarations
=
if
source
.
is_some
(
)
{
source
.
as_ref
(
)
.
unwrap
(
)
.
read
(
node
.
cascade_level
(
)
.
guard
(
guards
)
)
.
declaration_importance_iter
(
)
}
else
{
continue
;
}
;
let
node_importance
=
node
.
importance
(
)
;
let
longhands
=
declarations
.
rev
(
)
.
filter_map
(
|
(
declaration
importance
)
|
{
if
importance
!
=
node_importance
{
return
None
;
}
match
declaration
.
id
(
)
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
Some
(
(
id
declaration
)
)
_
=
>
None
}
}
)
;
let
is_author
=
node
.
cascade_level
(
)
.
origin
(
)
=
=
Origin
:
:
Author
;
for
(
id
declaration
)
in
longhands
{
if
!
properties
.
contains
(
id
)
{
continue
;
}
if
is_author
{
if
!
author_colors_allowed
{
if
let
PropertyDeclaration
:
:
BackgroundColor
(
ref
color
)
=
*
declaration
{
if
color
.
is_transparent
(
)
{
return
true
;
}
continue
;
}
}
return
true
;
}
properties
.
remove
(
id
)
;
if
declaration
.
get_css_wide_keyword
(
)
=
=
Some
(
CSSWideKeyword
:
:
Inherit
)
{
have_explicit_ua_inherit
=
true
;
inherited_properties
.
insert
(
id
)
;
}
}
}
if
!
have_explicit_ua_inherit
{
break
;
}
if
let
Some
(
pseudo
)
=
pseudo
.
take
(
)
{
if
pseudo
.
inherits_from_default_values
(
)
{
break
;
}
}
else
{
element
=
match
element
.
inheritance_parent
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
break
}
;
let
parent_data
=
element
.
mutate_data
(
)
.
unwrap
(
)
;
let
parent_rule_node
=
parent_data
.
styles
.
primary
(
)
.
rules
(
)
.
clone
(
)
;
element_rule_node
=
Cow
:
:
Owned
(
parent_rule_node
)
;
}
properties
=
inherited_properties
;
}
false
}
pub
fn
has_animation_or_transition_rules
(
&
self
)
-
>
bool
{
self
.
self_and_ancestors
(
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
=
CascadeLevel
:
:
SMILOverride
)
.
any
(
|
node
|
node
.
cascade_level
(
)
.
is_animation
(
)
)
}
pub
fn
get_properties_overriding_animations
(
&
self
guards
:
&
StylesheetGuards
)
-
>
(
LonghandIdSet
bool
)
{
use
crate
:
:
properties
:
:
PropertyDeclarationId
;
let
iter
=
self
.
self_and_ancestors
(
)
.
skip_while
(
|
node
|
node
.
cascade_level
(
)
=
=
CascadeLevel
:
:
Transitions
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
CascadeLevel
:
:
Animations
)
;
let
mut
result
=
(
LonghandIdSet
:
:
new
(
)
false
)
;
for
node
in
iter
{
let
style
=
node
.
style_source
(
)
.
unwrap
(
)
;
for
(
decl
important
)
in
style
.
read
(
node
.
cascade_level
(
)
.
guard
(
guards
)
)
.
declaration_importance_iter
(
)
{
if
important
.
important
(
)
{
match
decl
.
id
(
)
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
result
.
0
.
insert
(
id
)
PropertyDeclarationId
:
:
Custom
(
_
)
=
>
result
.
1
=
true
}
}
}
}
result
}
}
#
[
derive
(
Clone
)
]
pub
struct
SelfAndAncestors
<
'
a
>
{
current
:
Option
<
&
'
a
StrongRuleNode
>
}
impl
<
'
a
>
Iterator
for
SelfAndAncestors
<
'
a
>
{
type
Item
=
&
'
a
StrongRuleNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
current
.
map
(
|
node
|
{
self
.
current
=
node
.
parent
(
)
;
node
}
)
}
}
