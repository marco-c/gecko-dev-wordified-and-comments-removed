#
!
[
allow
(
unsafe_code
)
]
use
applicable_declarations
:
:
ApplicableDeclarationList
;
#
[
cfg
(
feature
=
"
servo
"
)
]
use
heapsize
:
:
HeapSizeOf
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
use
malloc_size_of
:
:
{
MallocSizeOf
MallocSizeOfOps
}
;
use
properties
:
:
{
Importance
LonghandIdSet
PropertyDeclarationBlock
}
;
use
servo_arc
:
:
{
Arc
ArcBorrow
NonZeroPtrMut
}
;
use
shared_lock
:
:
{
Locked
StylesheetGuards
SharedRwLockReadGuard
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
std
:
:
mem
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicPtr
AtomicUsize
Ordering
}
;
use
stylesheets
:
:
StyleRule
;
use
thread_state
;
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
struct
RuleTree
{
root
:
StrongRuleNode
}
impl
Drop
for
RuleTree
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
gc
(
)
;
}
debug_assert
!
(
self
.
root
.
get
(
)
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
=
=
FREE_LIST_SENTINEL
)
;
self
.
root
.
get
(
)
.
next_free
.
store
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
MallocSizeOf
for
RuleTree
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
unsafe
{
ops
.
malloc_size_of
(
self
.
root
.
ptr
(
)
)
}
;
n
+
=
self
.
root
.
get
(
)
.
size_of
(
ops
)
;
n
}
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
StyleSource
{
Style
(
Arc
<
Locked
<
StyleRule
>
>
)
Declarations
(
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
)
None
}
impl
PartialEq
for
StyleSource
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
ptr_equals
(
other
)
}
}
impl
StyleSource
{
#
[
inline
]
fn
ptr_equals
(
&
self
other
:
&
Self
)
-
>
bool
{
use
self
:
:
StyleSource
:
:
*
;
match
(
self
other
)
{
(
&
Style
(
ref
one
)
&
Style
(
ref
other
)
)
=
>
Arc
:
:
ptr_eq
(
one
other
)
(
&
Declarations
(
ref
one
)
&
Declarations
(
ref
other
)
)
=
>
Arc
:
:
ptr_eq
(
one
other
)
(
&
None
_
)
|
(
_
&
None
)
=
>
panic
!
(
"
Should
not
check
for
equality
between
null
StyleSource
objects
"
)
_
=
>
false
}
}
fn
dump
<
W
:
Write
>
(
&
self
guard
:
&
SharedRwLockReadGuard
writer
:
&
mut
W
)
{
use
self
:
:
StyleSource
:
:
*
;
if
let
Style
(
ref
rule
)
=
*
self
{
let
rule
=
rule
.
read_with
(
guard
)
;
let
_
=
write
!
(
writer
"
{
:
?
}
"
rule
.
selectors
)
;
}
let
_
=
write
!
(
writer
"
-
>
{
:
?
}
"
self
.
read
(
guard
)
.
declarations
(
)
)
;
}
#
[
inline
]
pub
fn
read
<
'
a
>
(
&
'
a
self
guard
:
&
'
a
SharedRwLockReadGuard
)
-
>
&
'
a
PropertyDeclarationBlock
{
let
block
=
match
*
self
{
StyleSource
:
:
Style
(
ref
rule
)
=
>
&
rule
.
read_with
(
guard
)
.
block
StyleSource
:
:
Declarations
(
ref
block
)
=
>
block
StyleSource
:
:
None
=
>
panic
!
(
"
Cannot
call
read
on
StyleSource
:
:
None
"
)
}
;
block
.
read_with
(
guard
)
}
pub
fn
is_some
(
&
self
)
-
>
bool
{
match
*
self
{
StyleSource
:
:
None
=
>
false
_
=
>
true
}
}
}
const
FREE_LIST_SENTINEL
:
*
mut
RuleNode
=
0x01
as
*
mut
RuleNode
;
const
FREE_LIST_LOCKED
:
*
mut
RuleNode
=
0x02
as
*
mut
RuleNode
;
impl
RuleTree
{
pub
fn
new
(
)
-
>
Self
{
RuleTree
{
root
:
StrongRuleNode
:
:
new
(
Box
:
:
new
(
RuleNode
:
:
root
(
)
)
)
}
}
pub
fn
root
(
&
self
)
-
>
&
StrongRuleNode
{
&
self
.
root
}
fn
dump
<
W
:
Write
>
(
&
self
guards
:
&
StylesheetGuards
writer
:
&
mut
W
)
{
let
_
=
writeln
!
(
writer
"
+
RuleTree
"
)
;
self
.
root
.
get
(
)
.
dump
(
guards
writer
0
)
;
}
pub
fn
dump_stdout
(
&
self
guards
:
&
StylesheetGuards
)
{
let
mut
stdout
=
io
:
:
stdout
(
)
;
self
.
dump
(
guards
&
mut
stdout
)
;
}
pub
fn
insert_ordered_rules_with_important
<
'
a
I
>
(
&
self
iter
:
I
guards
:
&
StylesheetGuards
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
use
self
:
:
CascadeLevel
:
:
*
;
let
mut
current
=
self
.
root
.
clone
(
)
;
let
mut
last_level
=
current
.
get
(
)
.
level
;
let
mut
found_important
=
false
;
let
mut
important_style_attr
=
None
;
let
mut
important_author
=
SmallVec
:
:
<
[
StyleSource
;
4
]
>
:
:
new
(
)
;
let
mut
important_user
=
SmallVec
:
:
<
[
StyleSource
;
4
]
>
:
:
new
(
)
;
let
mut
important_ua
=
SmallVec
:
:
<
[
StyleSource
;
4
]
>
:
:
new
(
)
;
let
mut
transition
=
None
;
for
(
source
level
)
in
iter
{
debug_assert
!
(
last_level
<
=
level
"
Not
really
ordered
"
)
;
debug_assert
!
(
!
level
.
is_important
(
)
"
Important
levels
handled
internally
"
)
;
let
any_important
=
{
let
pdb
=
source
.
read
(
level
.
guard
(
guards
)
)
;
pdb
.
any_important
(
)
}
;
if
any_important
{
found_important
=
true
;
match
level
{
AuthorNormal
=
>
important_author
.
push
(
source
.
clone
(
)
)
UANormal
=
>
important_ua
.
push
(
source
.
clone
(
)
)
UserNormal
=
>
important_user
.
push
(
source
.
clone
(
)
)
StyleAttributeNormal
=
>
{
debug_assert
!
(
important_style_attr
.
is_none
(
)
)
;
important_style_attr
=
Some
(
source
.
clone
(
)
)
;
}
_
=
>
{
}
}
;
}
if
matches
!
(
level
Transitions
)
&
&
found_important
{
debug_assert
!
(
transition
.
is_none
(
)
)
;
transition
=
Some
(
source
)
;
}
else
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
level
)
;
}
last_level
=
level
;
}
if
!
found_important
{
return
current
;
}
for
source
in
important_author
.
drain
(
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
AuthorImportant
)
;
}
if
let
Some
(
source
)
=
important_style_attr
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
StyleAttributeImportant
)
;
}
for
source
in
important_user
.
drain
(
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
UserImportant
)
;
}
for
source
in
important_ua
.
drain
(
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
UAImportant
)
;
}
if
let
Some
(
source
)
=
transition
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
Transitions
)
;
}
current
}
pub
fn
compute_rule_node
(
&
self
applicable_declarations
:
&
mut
ApplicableDeclarationList
guards
:
&
StylesheetGuards
)
-
>
StrongRuleNode
{
let
rules
=
applicable_declarations
.
drain
(
)
.
map
(
|
d
|
d
.
order_and_level
(
)
)
;
let
rule_node
=
self
.
insert_ordered_rules_with_important
(
rules
guards
)
;
rule_node
}
pub
fn
insert_ordered_rules
<
'
a
I
>
(
&
self
iter
:
I
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
self
.
insert_ordered_rules_from
(
self
.
root
.
clone
(
)
iter
)
}
fn
insert_ordered_rules_from
<
'
a
I
>
(
&
self
from
:
StrongRuleNode
iter
:
I
)
-
>
StrongRuleNode
where
I
:
Iterator
<
Item
=
(
StyleSource
CascadeLevel
)
>
{
let
mut
current
=
from
;
let
mut
last_level
=
current
.
get
(
)
.
level
;
for
(
source
level
)
in
iter
{
debug_assert
!
(
last_level
<
=
level
"
Not
really
ordered
"
)
;
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
source
level
)
;
last_level
=
level
;
}
current
}
pub
unsafe
fn
gc
(
&
self
)
{
self
.
root
.
gc
(
)
;
}
pub
unsafe
fn
maybe_gc
(
&
self
)
{
self
.
root
.
maybe_gc
(
)
;
}
pub
fn
update_rule_at_level
(
&
self
level
:
CascadeLevel
pdb
:
Option
<
ArcBorrow
<
Locked
<
PropertyDeclarationBlock
>
>
>
path
:
&
StrongRuleNode
guards
:
&
StylesheetGuards
important_rules_changed
:
&
mut
bool
)
-
>
Option
<
StrongRuleNode
>
{
debug_assert
!
(
level
.
is_unique_per_element
(
)
)
;
let
mut
current
=
path
.
clone
(
)
;
*
important_rules_changed
=
false
;
let
mut
children
=
SmallVec
:
:
<
[
_
;
10
]
>
:
:
new
(
)
;
while
current
.
get
(
)
.
level
>
level
{
children
.
push
(
(
current
.
get
(
)
.
source
.
clone
(
)
current
.
get
(
)
.
level
)
)
;
current
=
current
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
;
}
if
current
.
get
(
)
.
level
=
=
level
{
*
important_rules_changed
|
=
level
.
is_important
(
)
;
if
let
Some
(
pdb
)
=
pdb
{
let
is_here_already
=
match
&
current
.
get
(
)
.
source
{
&
StyleSource
:
:
Declarations
(
ref
already_here
)
=
>
{
pdb
.
with_arc
(
|
arc
|
Arc
:
:
ptr_eq
(
arc
already_here
)
)
}
_
=
>
unreachable
!
(
"
Replacing
non
-
declarations
style
?
"
)
}
;
if
is_here_already
{
debug
!
(
"
Picking
the
fast
path
in
rule
replacement
"
)
;
return
None
;
}
}
current
=
current
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
;
}
debug_assert
!
(
current
.
get
(
)
.
level
!
=
level
"
Multiple
rules
should
'
ve
been
replaced
?
"
)
;
if
let
Some
(
pdb
)
=
pdb
{
if
level
.
is_important
(
)
{
if
pdb
.
read_with
(
level
.
guard
(
guards
)
)
.
any_important
(
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
StyleSource
:
:
Declarations
(
pdb
.
clone_arc
(
)
)
level
)
;
}
}
else
{
if
pdb
.
read_with
(
level
.
guard
(
guards
)
)
.
any_normal
(
)
{
current
=
current
.
ensure_child
(
self
.
root
.
downgrade
(
)
StyleSource
:
:
Declarations
(
pdb
.
clone_arc
(
)
)
level
)
;
}
}
}
let
rule
=
self
.
insert_ordered_rules_from
(
current
children
.
drain
(
)
.
rev
(
)
)
;
Some
(
rule
)
}
pub
fn
remove_transition_rule_if_applicable
(
&
self
path
:
&
StrongRuleNode
)
-
>
StrongRuleNode
{
if
path
.
cascade_level
(
)
!
=
CascadeLevel
:
:
Transitions
{
return
path
.
clone
(
)
;
}
path
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
}
pub
fn
remove_animation_rules
(
&
self
path
:
&
StrongRuleNode
)
-
>
StrongRuleNode
{
if
!
path
.
has_animation_or_transition_rules
(
)
{
return
path
.
clone
(
)
;
}
let
iter
=
path
.
self_and_ancestors
(
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
=
CascadeLevel
:
:
SMILOverride
)
;
let
mut
last
=
path
;
let
mut
children
=
SmallVec
:
:
<
[
_
;
10
]
>
:
:
new
(
)
;
for
node
in
iter
{
if
!
node
.
cascade_level
(
)
.
is_animation
(
)
{
children
.
push
(
(
node
.
get
(
)
.
source
.
clone
(
)
node
.
cascade_level
(
)
)
)
;
}
last
=
node
;
}
let
rule
=
self
.
insert_ordered_rules_from
(
last
.
parent
(
)
.
unwrap
(
)
.
clone
(
)
children
.
drain
(
)
.
rev
(
)
)
;
rule
}
}
const
RULE_TREE_GC_INTERVAL
:
usize
=
300
;
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
HeapSizeOf
)
)
]
pub
enum
CascadeLevel
{
UANormal
=
0
PresHints
UserNormal
XBL
AuthorNormal
StyleAttributeNormal
SMILOverride
Animations
AuthorImportant
StyleAttributeImportant
UserImportant
UAImportant
Transitions
}
impl
CascadeLevel
{
pub
unsafe
fn
from_byte
(
byte
:
u8
)
-
>
Self
{
debug_assert
!
(
byte
<
=
CascadeLevel
:
:
Transitions
as
u8
)
;
mem
:
:
transmute
(
byte
)
}
pub
fn
guard
<
'
a
>
(
&
self
guards
:
&
'
a
StylesheetGuards
<
'
a
>
)
-
>
&
'
a
SharedRwLockReadGuard
<
'
a
>
{
match
*
self
{
CascadeLevel
:
:
UANormal
|
CascadeLevel
:
:
UserNormal
|
CascadeLevel
:
:
UserImportant
|
CascadeLevel
:
:
UAImportant
=
>
guards
.
ua_or_user
_
=
>
guards
.
author
}
}
pub
fn
is_unique_per_element
(
&
self
)
-
>
bool
{
match
*
self
{
CascadeLevel
:
:
Transitions
|
CascadeLevel
:
:
Animations
|
CascadeLevel
:
:
SMILOverride
|
CascadeLevel
:
:
StyleAttributeNormal
|
CascadeLevel
:
:
StyleAttributeImportant
=
>
true
_
=
>
false
}
}
#
[
inline
]
pub
fn
is_important
(
&
self
)
-
>
bool
{
match
*
self
{
CascadeLevel
:
:
AuthorImportant
|
CascadeLevel
:
:
StyleAttributeImportant
|
CascadeLevel
:
:
UserImportant
|
CascadeLevel
:
:
UAImportant
=
>
true
_
=
>
false
}
}
#
[
inline
]
pub
fn
importance
(
&
self
)
-
>
Importance
{
if
self
.
is_important
(
)
{
Importance
:
:
Important
}
else
{
Importance
:
:
Normal
}
}
#
[
inline
]
pub
fn
is_animation
(
&
self
)
-
>
bool
{
match
*
self
{
CascadeLevel
:
:
SMILOverride
|
CascadeLevel
:
:
Animations
|
CascadeLevel
:
:
Transitions
=
>
true
_
=
>
false
}
}
}
struct
PrevSiblingOrFreeCount
(
AtomicPtr
<
RuleNode
>
)
;
impl
PrevSiblingOrFreeCount
{
fn
new
(
)
-
>
Self
{
PrevSiblingOrFreeCount
(
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
)
}
unsafe
fn
as_prev_sibling
(
&
self
)
-
>
&
AtomicPtr
<
RuleNode
>
{
&
self
.
0
}
unsafe
fn
as_free_count
(
&
self
)
-
>
&
AtomicUsize
{
unsafe
{
mem
:
:
transmute
(
&
self
.
0
)
}
}
}
pub
struct
RuleNode
{
root
:
Option
<
WeakRuleNode
>
parent
:
Option
<
StrongRuleNode
>
source
:
StyleSource
level
:
CascadeLevel
refcount
:
AtomicUsize
first_child
:
AtomicPtr
<
RuleNode
>
next_sibling
:
AtomicPtr
<
RuleNode
>
prev_sibling_or_free_count
:
PrevSiblingOrFreeCount
next_free
:
AtomicPtr
<
RuleNode
>
}
unsafe
impl
Sync
for
RuleTree
{
}
unsafe
impl
Send
for
RuleTree
{
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
cfg
(
debug_assertions
)
]
mod
gecko_leak_checking
{
use
std
:
:
mem
:
:
size_of
;
use
std
:
:
os
:
:
raw
:
:
{
c_char
c_void
}
;
use
super
:
:
RuleNode
;
extern
"
C
"
{
pub
fn
NS_LogCtor
(
aPtr
:
*
const
c_void
aTypeName
:
*
const
c_char
aSize
:
u32
)
;
pub
fn
NS_LogDtor
(
aPtr
:
*
const
c_void
aTypeName
:
*
const
c_char
aSize
:
u32
)
;
}
static
NAME
:
&
'
static
[
u8
]
=
b
"
RuleNode
\
0
"
;
pub
fn
log_ctor
(
ptr
:
*
const
RuleNode
)
{
let
s
=
NAME
as
*
const
[
u8
]
as
*
const
u8
as
*
const
c_char
;
unsafe
{
NS_LogCtor
(
ptr
as
*
const
c_void
s
size_of
:
:
<
RuleNode
>
(
)
as
u32
)
;
}
}
pub
fn
log_dtor
(
ptr
:
*
const
RuleNode
)
{
let
s
=
NAME
as
*
const
[
u8
]
as
*
const
u8
as
*
const
c_char
;
unsafe
{
NS_LogDtor
(
ptr
as
*
const
c_void
s
size_of
:
:
<
RuleNode
>
(
)
as
u32
)
;
}
}
}
#
[
inline
(
always
)
]
fn
log_new
(
_ptr
:
*
const
RuleNode
)
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
cfg
(
debug_assertions
)
]
gecko_leak_checking
:
:
log_ctor
(
_ptr
)
;
}
#
[
inline
(
always
)
]
fn
log_drop
(
_ptr
:
*
const
RuleNode
)
{
#
[
cfg
(
feature
=
"
gecko
"
)
]
#
[
cfg
(
debug_assertions
)
]
gecko_leak_checking
:
:
log_dtor
(
_ptr
)
;
}
impl
RuleNode
{
fn
new
(
root
:
WeakRuleNode
parent
:
StrongRuleNode
source
:
StyleSource
level
:
CascadeLevel
)
-
>
Self
{
debug_assert
!
(
root
.
upgrade
(
)
.
parent
(
)
.
is_none
(
)
)
;
RuleNode
{
root
:
Some
(
root
)
parent
:
Some
(
parent
)
source
:
source
level
:
level
refcount
:
AtomicUsize
:
:
new
(
1
)
first_child
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
next_sibling
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
prev_sibling_or_free_count
:
PrevSiblingOrFreeCount
:
:
new
(
)
next_free
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
}
}
fn
root
(
)
-
>
Self
{
RuleNode
{
root
:
None
parent
:
None
source
:
StyleSource
:
:
None
level
:
CascadeLevel
:
:
UANormal
refcount
:
AtomicUsize
:
:
new
(
1
)
first_child
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
next_sibling
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
prev_sibling_or_free_count
:
PrevSiblingOrFreeCount
:
:
new
(
)
next_free
:
AtomicPtr
:
:
new
(
FREE_LIST_SENTINEL
)
}
}
fn
is_root
(
&
self
)
-
>
bool
{
self
.
parent
.
is_none
(
)
}
fn
next_sibling
(
&
self
)
-
>
Option
<
WeakRuleNode
>
{
let
ptr
=
self
.
next_sibling
.
load
(
Ordering
:
:
Acquire
)
;
if
ptr
.
is_null
(
)
{
None
}
else
{
Some
(
WeakRuleNode
:
:
from_ptr
(
ptr
)
)
}
}
fn
prev_sibling
(
&
self
)
-
>
&
AtomicPtr
<
RuleNode
>
{
debug_assert
!
(
!
self
.
is_root
(
)
)
;
unsafe
{
self
.
prev_sibling_or_free_count
.
as_prev_sibling
(
)
}
}
fn
free_count
(
&
self
)
-
>
&
AtomicUsize
{
debug_assert
!
(
self
.
is_root
(
)
)
;
unsafe
{
self
.
prev_sibling_or_free_count
.
as_free_count
(
)
}
}
unsafe
fn
remove_from_child_list
(
&
self
)
{
debug
!
(
"
Remove
from
child
list
:
{
:
?
}
parent
:
{
:
?
}
"
self
as
*
const
RuleNode
self
.
parent
.
as_ref
(
)
.
map
(
|
p
|
p
.
ptr
(
)
)
)
;
let
prev_sibling
=
self
.
prev_sibling
(
)
.
swap
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
let
next_sibling
=
self
.
next_sibling
.
swap
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
if
prev_sibling
.
is_null
(
)
{
let
parent
=
self
.
parent
.
as_ref
(
)
.
unwrap
(
)
;
parent
.
get
(
)
.
first_child
.
store
(
next_sibling
Ordering
:
:
Relaxed
)
;
}
else
{
let
previous
=
&
*
prev_sibling
;
previous
.
next_sibling
.
store
(
next_sibling
Ordering
:
:
Relaxed
)
;
}
if
!
next_sibling
.
is_null
(
)
{
let
next
=
&
*
next_sibling
;
next
.
prev_sibling
(
)
.
store
(
prev_sibling
Ordering
:
:
Relaxed
)
;
}
}
fn
dump
<
W
:
Write
>
(
&
self
guards
:
&
StylesheetGuards
writer
:
&
mut
W
indent
:
usize
)
{
const
INDENT_INCREMENT
:
usize
=
4
;
for
_
in
0
.
.
indent
{
let
_
=
write
!
(
writer
"
"
)
;
}
let
_
=
writeln
!
(
writer
"
-
{
:
?
}
(
ref
:
{
:
?
}
parent
:
{
:
?
}
)
"
self
as
*
const
_
self
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
self
.
parent
.
as_ref
(
)
.
map
(
|
p
|
p
.
ptr
(
)
)
)
;
for
_
in
0
.
.
indent
{
let
_
=
write
!
(
writer
"
"
)
;
}
if
self
.
source
.
is_some
(
)
{
self
.
source
.
dump
(
self
.
level
.
guard
(
guards
)
writer
)
;
}
else
{
if
indent
!
=
0
{
warn
!
(
"
How
has
this
happened
?
"
)
;
}
let
_
=
write
!
(
writer
"
(
root
)
"
)
;
}
let
_
=
write
!
(
writer
"
\
n
"
)
;
for
child
in
self
.
iter_children
(
)
{
child
.
upgrade
(
)
.
get
(
)
.
dump
(
guards
writer
indent
+
INDENT_INCREMENT
)
;
}
}
fn
iter_children
(
&
self
)
-
>
RuleChildrenListIter
{
let
first_child
=
self
.
first_child
.
load
(
Ordering
:
:
Acquire
)
;
RuleChildrenListIter
{
current
:
if
first_child
.
is_null
(
)
{
None
}
else
{
Some
(
WeakRuleNode
:
:
from_ptr
(
first_child
)
)
}
}
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
impl
MallocSizeOf
for
RuleNode
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
0
;
for
child
in
self
.
iter_children
(
)
{
n
+
=
unsafe
{
ops
.
malloc_size_of
(
child
.
ptr
(
)
)
}
;
n
+
=
unsafe
{
(
*
child
.
ptr
(
)
)
.
size_of
(
ops
)
}
;
}
n
}
}
#
[
derive
(
Clone
)
]
struct
WeakRuleNode
{
p
:
NonZeroPtrMut
<
RuleNode
>
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
StrongRuleNode
{
p
:
NonZeroPtrMut
<
RuleNode
>
}
#
[
cfg
(
feature
=
"
servo
"
)
]
impl
HeapSizeOf
for
StrongRuleNode
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
impl
StrongRuleNode
{
fn
new
(
n
:
Box
<
RuleNode
>
)
-
>
Self
{
debug_assert
!
(
n
.
parent
.
is_none
(
)
=
=
!
n
.
source
.
is_some
(
)
)
;
let
ptr
=
Box
:
:
into_raw
(
n
)
;
log_new
(
ptr
)
;
debug
!
(
"
Creating
rule
node
:
{
:
p
}
"
ptr
)
;
StrongRuleNode
:
:
from_ptr
(
ptr
)
}
fn
from_ptr
(
ptr
:
*
mut
RuleNode
)
-
>
Self
{
StrongRuleNode
{
p
:
NonZeroPtrMut
:
:
new
(
ptr
)
}
}
fn
downgrade
(
&
self
)
-
>
WeakRuleNode
{
WeakRuleNode
:
:
from_ptr
(
self
.
ptr
(
)
)
}
fn
parent
(
&
self
)
-
>
Option
<
&
StrongRuleNode
>
{
self
.
get
(
)
.
parent
.
as_ref
(
)
}
fn
ensure_child
(
&
self
root
:
WeakRuleNode
source
:
StyleSource
level
:
CascadeLevel
)
-
>
StrongRuleNode
{
let
mut
last
=
None
;
for
child
in
self
.
get
(
)
.
iter_children
(
)
{
let
child_node
=
unsafe
{
&
*
child
.
ptr
(
)
}
;
if
child_node
.
level
=
=
level
&
&
child_node
.
source
.
ptr_equals
(
&
source
)
{
return
child
.
upgrade
(
)
;
}
last
=
Some
(
child
)
;
}
let
mut
node
=
Box
:
:
new
(
RuleNode
:
:
new
(
root
self
.
clone
(
)
source
.
clone
(
)
level
)
)
;
let
new_ptr
:
*
mut
RuleNode
=
&
mut
*
node
;
loop
{
let
next
;
{
let
last_node
=
last
.
as_ref
(
)
.
map
(
|
l
|
unsafe
{
&
*
l
.
ptr
(
)
}
)
;
let
next_sibling_ptr
=
match
last_node
{
Some
(
ref
l
)
=
>
&
l
.
next_sibling
None
=
>
&
self
.
get
(
)
.
first_child
}
;
let
existing
=
next_sibling_ptr
.
compare_and_swap
(
ptr
:
:
null_mut
(
)
new_ptr
Ordering
:
:
AcqRel
)
;
if
existing
.
is_null
(
)
{
if
let
Some
(
ref
l
)
=
last
{
node
.
prev_sibling
(
)
.
store
(
l
.
ptr
(
)
Ordering
:
:
Relaxed
)
;
}
return
StrongRuleNode
:
:
new
(
node
)
;
}
next
=
WeakRuleNode
:
:
from_ptr
(
existing
)
;
if
unsafe
{
&
*
next
.
ptr
(
)
}
.
source
.
ptr_equals
(
&
source
)
{
return
next
.
upgrade
(
)
;
}
}
last
=
Some
(
next
)
;
}
}
pub
fn
ptr
(
&
self
)
-
>
*
mut
RuleNode
{
self
.
p
.
ptr
(
)
}
fn
get
(
&
self
)
-
>
&
RuleNode
{
if
cfg
!
(
debug_assertions
)
{
let
node
=
unsafe
{
&
*
self
.
ptr
(
)
}
;
assert
!
(
node
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
>
0
)
;
}
unsafe
{
&
*
self
.
ptr
(
)
}
}
pub
fn
style_source
(
&
self
)
-
>
&
StyleSource
{
&
self
.
get
(
)
.
source
}
pub
fn
cascade_level
(
&
self
)
-
>
CascadeLevel
{
self
.
get
(
)
.
level
}
pub
fn
importance
(
&
self
)
-
>
Importance
{
self
.
get
(
)
.
level
.
importance
(
)
}
pub
fn
self_and_ancestors
(
&
self
)
-
>
SelfAndAncestors
{
SelfAndAncestors
{
current
:
Some
(
self
)
}
}
pub
unsafe
fn
has_children_for_testing
(
&
self
)
-
>
bool
{
!
self
.
get
(
)
.
first_child
.
load
(
Ordering
:
:
Relaxed
)
.
is_null
(
)
}
unsafe
fn
pop_from_free_list
(
&
self
)
-
>
Option
<
WeakRuleNode
>
{
let
me
=
&
*
self
.
ptr
(
)
;
debug_assert
!
(
me
.
is_root
(
)
)
;
debug_assert
!
(
!
thread_state
:
:
get
(
)
.
is_worker
(
)
&
&
(
thread_state
:
:
get
(
)
.
is_layout
(
)
|
|
thread_state
:
:
get
(
)
.
is_script
(
)
)
)
;
let
current
=
me
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
;
if
current
=
=
FREE_LIST_SENTINEL
{
return
None
;
}
debug_assert
!
(
!
current
.
is_null
(
)
"
Multiple
threads
are
operating
on
the
free
list
at
the
\
same
time
?
"
)
;
debug_assert
!
(
current
!
=
self
.
ptr
(
)
"
How
did
the
root
end
up
in
the
free
list
?
"
)
;
let
next
=
(
*
current
)
.
next_free
.
swap
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
debug_assert
!
(
!
next
.
is_null
(
)
"
How
did
a
null
pointer
end
up
in
the
free
list
?
"
)
;
me
.
next_free
.
store
(
next
Ordering
:
:
Relaxed
)
;
debug
!
(
"
Popping
from
free
list
:
cur
:
{
:
?
}
next
:
{
:
?
}
"
current
next
)
;
Some
(
WeakRuleNode
:
:
from_ptr
(
current
)
)
}
unsafe
fn
assert_free_list_has_no_duplicates_or_null
(
&
self
)
{
assert
!
(
cfg
!
(
debug_assertions
)
"
This
is
an
expensive
check
!
"
)
;
use
hash
:
:
HashSet
;
let
me
=
&
*
self
.
ptr
(
)
;
assert
!
(
me
.
is_root
(
)
)
;
let
mut
current
=
self
.
ptr
(
)
;
let
mut
seen
=
HashSet
:
:
new
(
)
;
while
current
!
=
FREE_LIST_SENTINEL
{
let
next
=
(
*
current
)
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
;
assert
!
(
!
next
.
is_null
(
)
)
;
assert
!
(
!
seen
.
contains
(
&
next
)
)
;
seen
.
insert
(
next
)
;
current
=
next
;
}
}
unsafe
fn
gc
(
&
self
)
{
if
cfg
!
(
debug_assertions
)
{
self
.
assert_free_list_has_no_duplicates_or_null
(
)
;
}
let
me
=
&
*
self
.
ptr
(
)
;
debug_assert
!
(
me
.
is_root
(
)
"
Can
'
t
call
GC
on
a
non
-
root
node
!
"
)
;
while
let
Some
(
weak
)
=
self
.
pop_from_free_list
(
)
{
let
node
=
&
*
weak
.
ptr
(
)
;
if
node
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
!
=
0
{
continue
;
}
debug
!
(
"
GC
'
ing
{
:
?
}
"
weak
.
ptr
(
)
)
;
node
.
remove_from_child_list
(
)
;
log_drop
(
weak
.
ptr
(
)
)
;
let
_
=
Box
:
:
from_raw
(
weak
.
ptr
(
)
)
;
}
me
.
free_count
(
)
.
store
(
0
Ordering
:
:
Relaxed
)
;
debug_assert
!
(
me
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
=
=
FREE_LIST_SENTINEL
)
;
}
unsafe
fn
maybe_gc
(
&
self
)
{
debug_assert
!
(
self
.
get
(
)
.
is_root
(
)
"
Can
'
t
call
GC
on
a
non
-
root
node
!
"
)
;
if
self
.
get
(
)
.
free_count
(
)
.
load
(
Ordering
:
:
Relaxed
)
>
RULE_TREE_GC_INTERVAL
{
self
.
gc
(
)
;
}
}
#
[
cfg
(
feature
=
"
gecko
"
)
]
pub
fn
has_author_specified_rules
<
E
>
(
&
self
mut
element
:
E
guards
:
&
StylesheetGuards
rule_type_mask
:
u32
author_colors_allowed
:
bool
)
-
>
bool
where
E
:
:
:
dom
:
:
TElement
{
use
gecko_bindings
:
:
structs
:
:
{
NS_AUTHOR_SPECIFIED_BACKGROUND
NS_AUTHOR_SPECIFIED_BORDER
}
;
use
gecko_bindings
:
:
structs
:
:
{
NS_AUTHOR_SPECIFIED_PADDING
NS_AUTHOR_SPECIFIED_TEXT_SHADOW
}
;
use
properties
:
:
{
CSSWideKeyword
LonghandId
LonghandIdSet
}
;
use
properties
:
:
{
PropertyDeclaration
PropertyDeclarationId
}
;
use
std
:
:
borrow
:
:
Cow
;
use
values
:
:
specified
:
:
Color
;
const
BACKGROUND_PROPS
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
BackgroundColor
LonghandId
:
:
BackgroundImage
]
;
const
BORDER_PROPS
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
BorderTopColor
LonghandId
:
:
BorderTopStyle
LonghandId
:
:
BorderTopWidth
LonghandId
:
:
BorderRightColor
LonghandId
:
:
BorderRightStyle
LonghandId
:
:
BorderRightWidth
LonghandId
:
:
BorderBottomColor
LonghandId
:
:
BorderBottomStyle
LonghandId
:
:
BorderBottomWidth
LonghandId
:
:
BorderLeftColor
LonghandId
:
:
BorderLeftStyle
LonghandId
:
:
BorderLeftWidth
LonghandId
:
:
BorderTopLeftRadius
LonghandId
:
:
BorderTopRightRadius
LonghandId
:
:
BorderBottomRightRadius
LonghandId
:
:
BorderBottomLeftRadius
LonghandId
:
:
BorderInlineStartColor
LonghandId
:
:
BorderInlineStartStyle
LonghandId
:
:
BorderInlineStartWidth
LonghandId
:
:
BorderInlineEndColor
LonghandId
:
:
BorderInlineEndStyle
LonghandId
:
:
BorderInlineEndWidth
LonghandId
:
:
BorderBlockStartColor
LonghandId
:
:
BorderBlockStartStyle
LonghandId
:
:
BorderBlockStartWidth
LonghandId
:
:
BorderBlockEndColor
LonghandId
:
:
BorderBlockEndStyle
LonghandId
:
:
BorderBlockEndWidth
]
;
const
PADDING_PROPS
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
PaddingTop
LonghandId
:
:
PaddingRight
LonghandId
:
:
PaddingBottom
LonghandId
:
:
PaddingLeft
LonghandId
:
:
PaddingInlineStart
LonghandId
:
:
PaddingInlineEnd
LonghandId
:
:
PaddingBlockStart
LonghandId
:
:
PaddingBlockEnd
]
;
const
TEXT_SHADOW_PROPS
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
TextShadow
]
;
fn
inherited
(
id
:
LonghandId
)
-
>
bool
{
id
=
=
LonghandId
:
:
TextShadow
}
let
mut
properties
=
LonghandIdSet
:
:
new
(
)
;
if
rule_type_mask
&
NS_AUTHOR_SPECIFIED_BACKGROUND
!
=
0
{
for
id
in
BACKGROUND_PROPS
{
properties
.
insert
(
*
id
)
;
}
}
if
rule_type_mask
&
NS_AUTHOR_SPECIFIED_BORDER
!
=
0
{
for
id
in
BORDER_PROPS
{
properties
.
insert
(
*
id
)
;
}
}
if
rule_type_mask
&
NS_AUTHOR_SPECIFIED_PADDING
!
=
0
{
for
id
in
PADDING_PROPS
{
properties
.
insert
(
*
id
)
;
}
}
if
rule_type_mask
&
NS_AUTHOR_SPECIFIED_TEXT_SHADOW
!
=
0
{
for
id
in
TEXT_SHADOW_PROPS
{
properties
.
insert
(
*
id
)
;
}
}
const
IGNORED_WHEN_COLORS_DISABLED
:
&
'
static
[
LonghandId
]
=
&
[
LonghandId
:
:
BackgroundImage
LonghandId
:
:
BorderTopColor
LonghandId
:
:
BorderRightColor
LonghandId
:
:
BorderBottomColor
LonghandId
:
:
BorderLeftColor
LonghandId
:
:
BorderInlineStartColor
LonghandId
:
:
BorderInlineEndColor
LonghandId
:
:
BorderBlockStartColor
LonghandId
:
:
BorderBlockEndColor
LonghandId
:
:
TextShadow
]
;
if
!
author_colors_allowed
{
for
id
in
IGNORED_WHEN_COLORS_DISABLED
{
properties
.
remove
(
*
id
)
;
}
}
let
mut
element_rule_node
=
Cow
:
:
Borrowed
(
self
)
;
loop
{
let
mut
inherited_properties
=
LonghandIdSet
:
:
new
(
)
;
let
mut
have_explicit_ua_inherit
=
false
;
for
node
in
element_rule_node
.
self_and_ancestors
(
)
{
let
source
=
node
.
style_source
(
)
;
let
declarations
=
if
source
.
is_some
(
)
{
source
.
read
(
node
.
cascade_level
(
)
.
guard
(
guards
)
)
.
declaration_importance_iter
(
)
}
else
{
continue
}
;
let
node_importance
=
node
.
importance
(
)
;
let
longhands
=
declarations
.
rev
(
)
.
filter_map
(
|
(
declaration
importance
)
|
{
if
importance
!
=
node_importance
{
return
None
}
match
declaration
.
id
(
)
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
{
Some
(
(
id
declaration
)
)
}
_
=
>
None
}
}
)
;
match
node
.
cascade_level
(
)
{
CascadeLevel
:
:
UANormal
|
CascadeLevel
:
:
UAImportant
|
CascadeLevel
:
:
UserNormal
|
CascadeLevel
:
:
UserImportant
=
>
{
for
(
id
declaration
)
in
longhands
{
if
properties
.
contains
(
id
)
{
properties
.
remove
(
id
)
;
if
declaration
.
get_css_wide_keyword
(
)
=
=
Some
(
CSSWideKeyword
:
:
Inherit
)
|
|
(
declaration
.
get_css_wide_keyword
(
)
=
=
Some
(
CSSWideKeyword
:
:
Unset
)
&
&
inherited
(
id
)
)
{
have_explicit_ua_inherit
=
true
;
inherited_properties
.
insert
(
id
)
;
}
}
}
}
CascadeLevel
:
:
PresHints
|
CascadeLevel
:
:
XBL
|
CascadeLevel
:
:
AuthorNormal
|
CascadeLevel
:
:
StyleAttributeNormal
|
CascadeLevel
:
:
SMILOverride
|
CascadeLevel
:
:
Animations
|
CascadeLevel
:
:
AuthorImportant
|
CascadeLevel
:
:
StyleAttributeImportant
|
CascadeLevel
:
:
Transitions
=
>
{
for
(
id
declaration
)
in
longhands
{
if
properties
.
contains
(
id
)
{
if
!
author_colors_allowed
{
if
let
PropertyDeclaration
:
:
BackgroundColor
(
ref
color
)
=
*
declaration
{
return
*
color
=
=
Color
:
:
transparent
(
)
}
}
return
true
}
}
}
}
}
if
!
have_explicit_ua_inherit
{
break
}
element
=
match
element
.
inheritance_parent
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
break
}
;
let
parent_data
=
element
.
mutate_data
(
)
.
unwrap
(
)
;
let
parent_rule_node
=
parent_data
.
styles
.
primary
(
)
.
rules
(
)
.
clone
(
)
;
element_rule_node
=
Cow
:
:
Owned
(
parent_rule_node
)
;
properties
=
inherited_properties
;
}
false
}
pub
fn
has_animation_or_transition_rules
(
&
self
)
-
>
bool
{
self
.
self_and_ancestors
(
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
=
CascadeLevel
:
:
SMILOverride
)
.
any
(
|
node
|
node
.
cascade_level
(
)
.
is_animation
(
)
)
}
pub
fn
get_properties_overriding_animations
(
&
self
guards
:
&
StylesheetGuards
)
-
>
(
LonghandIdSet
bool
)
{
use
properties
:
:
PropertyDeclarationId
;
let
iter
=
self
.
self_and_ancestors
(
)
.
skip_while
(
|
node
|
node
.
cascade_level
(
)
=
=
CascadeLevel
:
:
Transitions
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
CascadeLevel
:
:
Animations
)
;
let
mut
result
=
(
LonghandIdSet
:
:
new
(
)
false
)
;
for
node
in
iter
{
let
style
=
node
.
style_source
(
)
;
for
(
decl
important
)
in
style
.
read
(
node
.
cascade_level
(
)
.
guard
(
guards
)
)
.
declaration_importance_iter
(
)
{
if
important
.
important
(
)
{
match
decl
.
id
(
)
{
PropertyDeclarationId
:
:
Longhand
(
id
)
=
>
result
.
0
.
insert
(
id
)
PropertyDeclarationId
:
:
Custom
(
_
)
=
>
result
.
1
=
true
}
}
}
}
result
}
fn
get_animation_style
(
&
self
)
-
>
&
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
{
debug_assert
!
(
self
.
cascade_level
(
)
.
is_animation
(
)
"
The
cascade
level
should
be
an
animation
level
"
)
;
match
*
self
.
style_source
(
)
{
StyleSource
:
:
Declarations
(
ref
block
)
=
>
block
StyleSource
:
:
Style
(
_
)
=
>
unreachable
!
(
"
animating
style
should
not
be
a
style
rule
"
)
StyleSource
:
:
None
=
>
unreachable
!
(
"
animating
style
should
not
be
none
"
)
}
}
pub
fn
get_smil_animation_rule
(
&
self
)
-
>
Option
<
&
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
>
{
if
cfg
!
(
feature
=
"
servo
"
)
{
return
None
;
}
self
.
self_and_ancestors
(
)
.
take_while
(
|
node
|
node
.
cascade_level
(
)
>
=
CascadeLevel
:
:
SMILOverride
)
.
find
(
|
node
|
node
.
cascade_level
(
)
=
=
CascadeLevel
:
:
SMILOverride
)
.
map
(
|
node
|
node
.
get_animation_style
(
)
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
SelfAndAncestors
<
'
a
>
{
current
:
Option
<
&
'
a
StrongRuleNode
>
}
impl
<
'
a
>
Iterator
for
SelfAndAncestors
<
'
a
>
{
type
Item
=
&
'
a
StrongRuleNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
current
.
map
(
|
node
|
{
self
.
current
=
node
.
parent
(
)
;
node
}
)
}
}
impl
Clone
for
StrongRuleNode
{
fn
clone
(
&
self
)
-
>
Self
{
debug
!
(
"
{
:
?
}
:
{
:
?
}
+
"
self
.
ptr
(
)
self
.
get
(
)
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
)
;
debug_assert
!
(
self
.
get
(
)
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
>
0
)
;
self
.
get
(
)
.
refcount
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
StrongRuleNode
:
:
from_ptr
(
self
.
ptr
(
)
)
}
}
impl
Drop
for
StrongRuleNode
{
fn
drop
(
&
mut
self
)
{
let
node
=
unsafe
{
&
*
self
.
ptr
(
)
}
;
debug
!
(
"
{
:
?
}
:
{
:
?
}
-
"
self
.
ptr
(
)
node
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
)
;
debug
!
(
"
Dropping
node
:
{
:
?
}
root
:
{
:
?
}
parent
:
{
:
?
}
"
self
.
ptr
(
)
node
.
root
.
as_ref
(
)
.
map
(
|
r
|
r
.
ptr
(
)
)
node
.
parent
.
as_ref
(
)
.
map
(
|
p
|
p
.
ptr
(
)
)
)
;
let
should_drop
=
{
debug_assert
!
(
node
.
refcount
.
load
(
Ordering
:
:
Relaxed
)
>
0
)
;
node
.
refcount
.
fetch_sub
(
1
Ordering
:
:
Relaxed
)
=
=
1
}
;
if
!
should_drop
{
return
}
debug_assert_eq
!
(
node
.
first_child
.
load
(
Ordering
:
:
Acquire
)
ptr
:
:
null_mut
(
)
)
;
if
node
.
parent
.
is_none
(
)
{
debug
!
(
"
Dropping
root
node
!
"
)
;
debug_assert
!
(
node
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
.
is_null
(
)
)
;
log_drop
(
self
.
ptr
(
)
)
;
let
_
=
unsafe
{
Box
:
:
from_raw
(
self
.
ptr
(
)
)
}
;
return
;
}
let
root
=
unsafe
{
&
*
node
.
root
.
as_ref
(
)
.
unwrap
(
)
.
ptr
(
)
}
;
let
free_list
=
&
root
.
next_free
;
let
mut
old_head
=
free_list
.
load
(
Ordering
:
:
Relaxed
)
;
if
old_head
.
is_null
(
)
{
debug_assert
!
(
!
thread_state
:
:
get
(
)
.
is_worker
(
)
&
&
(
thread_state
:
:
get
(
)
.
is_layout
(
)
|
|
thread_state
:
:
get
(
)
.
is_script
(
)
)
)
;
debug_assert
!
(
node
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
.
is_null
(
)
)
;
node
.
next_free
.
store
(
FREE_LIST_SENTINEL
Ordering
:
:
Relaxed
)
;
free_list
.
store
(
node
as
*
const
_
as
*
mut
_
Ordering
:
:
Relaxed
)
;
let
strong_root
:
StrongRuleNode
=
node
.
root
.
as_ref
(
)
.
unwrap
(
)
.
upgrade
(
)
;
unsafe
{
strong_root
.
gc
(
)
;
}
debug_assert_eq
!
(
root
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
FREE_LIST_SENTINEL
)
;
root
.
next_free
.
store
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
return
;
}
if
node
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
!
=
ptr
:
:
null_mut
(
)
{
return
;
}
loop
{
match
free_list
.
compare_exchange_weak
(
old_head
FREE_LIST_LOCKED
Ordering
:
:
Acquire
Ordering
:
:
Relaxed
)
{
Ok
(
.
.
)
=
>
{
if
old_head
!
=
FREE_LIST_LOCKED
{
break
;
}
}
Err
(
new
)
=
>
old_head
=
new
}
}
if
node
.
next_free
.
load
(
Ordering
:
:
Relaxed
)
!
=
ptr
:
:
null_mut
(
)
{
free_list
.
store
(
old_head
Ordering
:
:
Release
)
;
return
;
}
node
.
next_free
.
store
(
old_head
Ordering
:
:
Relaxed
)
;
let
old_free_count
=
root
.
free_count
(
)
.
load
(
Ordering
:
:
Relaxed
)
;
root
.
free_count
(
)
.
store
(
old_free_count
+
1
Ordering
:
:
Relaxed
)
;
free_list
.
store
(
self
.
ptr
(
)
Ordering
:
:
Release
)
;
}
}
impl
<
'
a
>
From
<
&
'
a
StrongRuleNode
>
for
WeakRuleNode
{
fn
from
(
node
:
&
'
a
StrongRuleNode
)
-
>
Self
{
WeakRuleNode
:
:
from_ptr
(
node
.
ptr
(
)
)
}
}
impl
WeakRuleNode
{
fn
upgrade
(
&
self
)
-
>
StrongRuleNode
{
debug
!
(
"
Upgrading
weak
node
:
{
:
p
}
"
self
.
ptr
(
)
)
;
let
node
=
unsafe
{
&
*
self
.
ptr
(
)
}
;
node
.
refcount
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
StrongRuleNode
:
:
from_ptr
(
self
.
ptr
(
)
)
}
fn
from_ptr
(
ptr
:
*
mut
RuleNode
)
-
>
Self
{
WeakRuleNode
{
p
:
NonZeroPtrMut
:
:
new
(
ptr
)
}
}
fn
ptr
(
&
self
)
-
>
*
mut
RuleNode
{
self
.
p
.
ptr
(
)
}
}
struct
RuleChildrenListIter
{
current
:
Option
<
WeakRuleNode
>
}
impl
Iterator
for
RuleChildrenListIter
{
type
Item
=
WeakRuleNode
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
current
.
take
(
)
.
map
(
|
current
|
{
self
.
current
=
unsafe
{
&
*
current
.
ptr
(
)
}
.
next_sibling
(
)
;
current
}
)
}
}
