use
crate
:
:
cg
;
use
crate
:
:
to_css
:
:
CssVariantAttrs
;
use
proc_macro2
:
:
TokenStream
;
use
quote
:
:
quote
;
use
syn
:
:
{
Data
DataEnum
DeriveInput
Fields
}
;
use
synstructure
:
:
Structure
;
pub
fn
derive
(
input
:
DeriveInput
)
-
>
TokenStream
{
let
(
impl_generics
ty_generics
where_clause
)
=
input
.
generics
.
split_for_impl
(
)
;
let
name
=
&
input
.
ident
;
let
body
=
if
let
Data
:
:
Enum
(
DataEnum
{
variants
.
.
}
)
=
&
input
.
data
{
let
all_unit
=
variants
.
iter
(
)
.
all
(
|
v
|
matches
!
(
v
.
fields
Fields
:
:
Unit
)
)
;
if
all_unit
{
quote
!
{
fn
to_typed
(
&
self
)
-
>
Option
<
style_traits
:
:
TypedValue
>
{
let
s
=
style_traits
:
:
ToCss
:
:
to_css_cssstring
(
self
)
;
Some
(
style_traits
:
:
TypedValue
:
:
Keyword
(
s
)
)
}
}
}
else
{
let
s
=
Structure
:
:
new
(
&
input
)
;
let
match_body
=
s
.
each_variant
(
|
variant
|
derive_variant_arm
(
variant
)
)
;
quote
!
{
fn
to_typed
(
&
self
)
-
>
Option
<
style_traits
:
:
TypedValue
>
{
match
*
self
{
#
match_body
}
}
}
}
}
else
{
quote
!
{
}
}
;
quote
!
{
impl
#
impl_generics
style_traits
:
:
ToTyped
for
#
name
#
ty_generics
#
where_clause
{
#
body
}
}
}
fn
derive_variant_arm
(
variant
:
&
synstructure
:
:
VariantInfo
)
-
>
TokenStream
{
let
ast
=
variant
.
ast
(
)
;
let
identifier
=
&
ast
.
ident
;
let
variant_attrs
=
cg
:
:
parse_variant_attrs_from_ast
:
:
<
CssVariantAttrs
>
(
&
ast
)
;
if
variant_attrs
.
skip
{
return
quote
!
(
None
)
;
}
assert
!
(
variant_attrs
.
keyword
.
is_none
(
)
"
Unhandled
keyword
attribute
"
)
;
if
ast
.
fields
.
is_empty
(
)
{
let
keyword
=
cg
:
:
to_css_identifier
(
&
identifier
.
to_string
(
)
)
;
quote
!
{
Some
(
style_traits
:
:
TypedValue
:
:
Keyword
(
style_traits
:
:
CssString
:
:
from
(
#
keyword
)
)
)
}
}
else
{
quote
!
{
None
}
}
}
