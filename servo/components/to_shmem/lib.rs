#
!
[
crate_name
=
"
to_shmem
"
]
#
!
[
crate_type
=
"
rlib
"
]
use
std
:
:
alloc
:
:
Layout
;
#
[
cfg
(
debug_assertions
)
]
use
std
:
:
any
:
:
TypeId
;
use
std
:
:
isize
;
#
[
cfg
(
debug_assertions
)
]
use
std
:
:
collections
:
:
HashSet
;
use
std
:
:
mem
:
:
{
self
ManuallyDrop
}
;
#
[
cfg
(
debug_assertions
)
]
use
std
:
:
os
:
:
raw
:
:
c_void
;
use
std
:
:
ptr
:
:
{
self
NonNull
}
;
pub
struct
SharedMemoryBuilder
{
buffer
:
*
mut
u8
capacity
:
usize
index
:
usize
#
[
cfg
(
debug_assertions
)
]
shared_values
:
HashSet
<
*
const
c_void
>
#
[
cfg
(
debug_assertions
)
]
allowed_duplication_types
:
HashSet
<
TypeId
>
}
fn
padding_needed_for
(
size
:
usize
align
:
usize
)
-
>
usize
{
padded_size
(
size
align
)
.
wrapping_sub
(
size
)
}
fn
padded_size
(
size
:
usize
align
:
usize
)
-
>
usize
{
size
.
wrapping_add
(
align
)
.
wrapping_sub
(
1
)
&
!
align
.
wrapping_sub
(
1
)
}
impl
SharedMemoryBuilder
{
pub
unsafe
fn
new
(
buffer
:
*
mut
u8
capacity
:
usize
)
-
>
SharedMemoryBuilder
{
SharedMemoryBuilder
{
buffer
capacity
index
:
0
#
[
cfg
(
debug_assertions
)
]
shared_values
:
HashSet
:
:
new
(
)
#
[
cfg
(
debug_assertions
)
]
allowed_duplication_types
:
HashSet
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
add_allowed_duplication_type
<
T
:
'
static
>
(
&
mut
self
)
{
#
[
cfg
(
debug_assertions
)
]
self
.
allowed_duplication_types
.
insert
(
TypeId
:
:
of
:
:
<
T
>
(
)
)
;
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
index
}
pub
fn
write
<
T
:
ToShmem
>
(
&
mut
self
value
:
&
T
)
-
>
*
mut
T
{
let
dest
:
*
mut
T
=
self
.
alloc_value
(
)
;
let
value
=
value
.
to_shmem
(
self
)
;
unsafe
{
ptr
:
:
write
(
dest
ManuallyDrop
:
:
into_inner
(
value
)
)
;
}
dest
}
pub
fn
alloc_value
<
T
>
(
&
mut
self
)
-
>
*
mut
T
{
self
.
alloc
(
Layout
:
:
new
:
:
<
T
>
(
)
)
}
pub
fn
alloc_array
<
T
>
(
&
mut
self
len
:
usize
)
-
>
*
mut
T
{
if
len
=
=
0
{
return
NonNull
:
:
dangling
(
)
.
as_ptr
(
)
;
}
let
size
=
mem
:
:
size_of
:
:
<
T
>
(
)
;
let
align
=
mem
:
:
align_of
:
:
<
T
>
(
)
;
self
.
alloc
(
Layout
:
:
from_size_align
(
padded_size
(
size
align
)
*
len
align
)
.
unwrap
(
)
)
}
pub
fn
alloc
<
T
>
(
&
mut
self
layout
:
Layout
)
-
>
*
mut
T
{
let
padding
=
padding_needed_for
(
self
.
buffer
as
usize
+
self
.
index
layout
.
align
(
)
)
;
let
start
=
self
.
index
.
checked_add
(
padding
)
.
unwrap
(
)
;
assert
!
(
start
<
=
std
:
:
isize
:
:
MAX
as
usize
)
;
let
end
=
start
.
checked_add
(
layout
.
size
(
)
)
.
unwrap
(
)
;
assert
!
(
end
<
=
self
.
capacity
)
;
self
.
index
=
end
;
unsafe
{
self
.
buffer
.
offset
(
start
as
isize
)
as
*
mut
T
}
}
}
pub
trait
ToShmem
:
Sized
{
fn
to_shmem
(
&
self
builder
:
&
mut
SharedMemoryBuilder
)
-
>
ManuallyDrop
<
Self
>
;
}
