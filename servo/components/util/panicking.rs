use
std
:
:
any
:
:
Any
;
use
std
:
:
boxed
:
:
FnBox
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
panic
:
:
{
PanicInfo
take_hook
set_hook
}
;
use
std
:
:
sync
:
:
{
Once
ONCE_INIT
}
;
use
std
:
:
thread
;
static
HOOK_SET
:
Once
=
ONCE_INIT
;
pub
struct
PanicHandlerLocal
{
pub
fail
:
Box
<
FnBox
(
&
Any
)
>
}
thread_local
!
(
pub
static
LOCAL_INFO
:
RefCell
<
Option
<
PanicHandlerLocal
>
>
=
RefCell
:
:
new
(
None
)
)
;
pub
fn
set_thread_local_hook
(
local
:
Box
<
FnBox
(
&
Any
)
>
)
{
LOCAL_INFO
.
with
(
|
i
|
*
i
.
borrow_mut
(
)
=
Some
(
PanicHandlerLocal
{
fail
:
local
}
)
)
;
}
pub
fn
initiate_panic_hook
(
)
{
HOOK_SET
.
call_once
(
|
|
{
let
hook
=
take_hook
(
)
;
let
new_hook
=
move
|
info
:
&
PanicInfo
|
{
let
payload
=
info
.
payload
(
)
;
let
name
=
thread
:
:
current
(
)
.
name
(
)
.
unwrap_or
(
"
<
unknown
thread
>
"
)
.
to_string
(
)
;
LOCAL_INFO
.
with
(
|
i
|
{
if
let
Some
(
local_info
)
=
i
.
borrow_mut
(
)
.
take
(
)
{
debug
!
(
"
Thread
{
}
failed
notifying
error
handlers
"
name
)
;
(
local_info
.
fail
)
.
call_box
(
(
payload
)
)
;
}
else
{
hook
(
&
info
)
;
}
}
)
;
}
;
set_hook
(
Box
:
:
new
(
new_hook
)
)
;
}
)
;
}
