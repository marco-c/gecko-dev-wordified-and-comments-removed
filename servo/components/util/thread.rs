use
backtrace
:
:
Backtrace
;
use
ipc_channel
:
:
ipc
:
:
IpcSender
;
use
panicking
;
use
serde
:
:
Serialize
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
thread
;
use
thread_state
;
pub
fn
spawn_named
<
F
>
(
name
:
String
f
:
F
)
where
F
:
FnOnce
(
)
+
Send
+
'
static
{
thread
:
:
Builder
:
:
new
(
)
.
name
(
name
)
.
spawn
(
f
)
.
expect
(
"
Thread
spawn
failed
"
)
;
}
pub
fn
spawn_named_with_send_on_panic
<
F
Id
>
(
name
:
String
state
:
thread_state
:
:
ThreadState
f
:
F
id
:
Id
panic_chan
:
IpcSender
<
(
Id
String
String
)
>
)
where
F
:
FnOnce
(
)
+
Send
+
'
static
Id
:
Copy
+
Send
+
Serialize
+
'
static
{
thread
:
:
Builder
:
:
new
(
)
.
name
(
name
)
.
spawn
(
move
|
|
{
thread_state
:
:
initialize
(
state
)
;
panicking
:
:
set_thread_local_hook
(
Box
:
:
new
(
move
|
payload
:
&
Any
|
{
debug
!
(
"
Thread
failed
notifying
constellation
"
)
;
let
reason
=
payload
.
downcast_ref
:
:
<
String
>
(
)
.
map
(
|
s
|
String
:
:
from
(
&
*
*
s
)
)
.
or
(
payload
.
downcast_ref
:
:
<
&
'
static
str
>
(
)
.
map
(
|
s
|
String
:
:
from
(
*
s
)
)
)
.
unwrap_or_else
(
|
|
String
:
:
from
(
"
<
unknown
reason
>
"
)
)
;
let
backtrace
=
format
!
(
"
{
:
?
}
"
Backtrace
:
:
new
(
)
)
;
let
_
=
panic_chan
.
send
(
(
id
reason
backtrace
)
)
;
}
)
)
;
f
(
)
}
)
.
expect
(
"
Thread
spawn
failed
"
)
;
}
