pub
use
self
:
:
Stolen
:
:
{
Empty
Abort
Data
}
;
use
alloc
:
:
arc
:
:
Arc
;
use
alloc
:
:
heap
:
:
{
allocate
deallocate
}
;
use
std
:
:
marker
;
use
std
:
:
mem
:
:
{
forget
min_align_of
size_of
transmute
}
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
Mutex
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicIsize
AtomicPtr
}
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
SeqCst
;
static
K
:
isize
=
4
;
static
MIN_BITS
:
usize
=
7
;
struct
Deque
<
T
>
{
bottom
:
AtomicIsize
top
:
AtomicIsize
array
:
AtomicPtr
<
Buffer
<
T
>
>
pool
:
BufferPool
<
T
>
}
pub
struct
Worker
<
T
>
{
deque
:
Arc
<
Deque
<
T
>
>
}
impl
<
T
>
!
marker
:
:
Sync
for
Worker
<
T
>
{
}
pub
struct
Stealer
<
T
>
{
deque
:
Arc
<
Deque
<
T
>
>
}
impl
<
T
>
!
marker
:
:
Sync
for
Stealer
<
T
>
{
}
#
[
derive
(
PartialEq
Debug
)
]
pub
enum
Stolen
<
T
>
{
Empty
Abort
Data
(
T
)
}
pub
struct
BufferPool
<
T
>
{
pool
:
Arc
<
Mutex
<
Vec
<
Box
<
Buffer
<
T
>
>
>
>
>
}
struct
Buffer
<
T
>
{
storage
:
*
const
T
log_size
:
usize
}
unsafe
impl
<
T
:
'
static
>
Send
for
Buffer
<
T
>
{
}
impl
<
T
:
Send
>
BufferPool
<
T
>
{
pub
fn
new
(
)
-
>
BufferPool
<
T
>
{
BufferPool
{
pool
:
Arc
:
:
new
(
Mutex
:
:
new
(
Vec
:
:
new
(
)
)
)
}
}
pub
fn
deque
(
&
self
)
-
>
(
Worker
<
T
>
Stealer
<
T
>
)
{
let
a
=
Arc
:
:
new
(
Deque
:
:
new
(
self
.
clone
(
)
)
)
;
let
b
=
a
.
clone
(
)
;
(
Worker
{
deque
:
a
}
Stealer
{
deque
:
b
}
)
}
fn
alloc
(
&
mut
self
bits
:
usize
)
-
>
Box
<
Buffer
<
T
>
>
{
unsafe
{
let
mut
pool
=
self
.
pool
.
lock
(
)
.
unwrap
(
)
;
match
pool
.
iter
(
)
.
position
(
|
x
|
x
.
size
(
)
>
=
(
1
<
<
bits
)
)
{
Some
(
i
)
=
>
pool
.
remove
(
i
)
None
=
>
box
Buffer
:
:
new
(
bits
)
}
}
}
fn
free
(
&
self
buf
:
Box
<
Buffer
<
T
>
>
)
{
let
mut
pool
=
self
.
pool
.
lock
(
)
.
unwrap
(
)
;
match
pool
.
iter
(
)
.
position
(
|
v
|
v
.
size
(
)
>
buf
.
size
(
)
)
{
Some
(
i
)
=
>
pool
.
insert
(
i
buf
)
None
=
>
pool
.
push
(
buf
)
}
}
}
impl
<
T
:
Send
>
Clone
for
BufferPool
<
T
>
{
fn
clone
(
&
self
)
-
>
BufferPool
<
T
>
{
BufferPool
{
pool
:
self
.
pool
.
clone
(
)
}
}
}
impl
<
T
:
Send
>
Worker
<
T
>
{
pub
fn
push
(
&
self
t
:
T
)
{
unsafe
{
self
.
deque
.
push
(
t
)
}
}
pub
fn
pop
(
&
self
)
-
>
Option
<
T
>
{
unsafe
{
self
.
deque
.
pop
(
)
}
}
pub
fn
pool
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
BufferPool
<
T
>
{
&
self
.
deque
.
pool
}
}
impl
<
T
:
Send
>
Stealer
<
T
>
{
pub
fn
steal
(
&
self
)
-
>
Stolen
<
T
>
{
unsafe
{
self
.
deque
.
steal
(
)
}
}
pub
fn
pool
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
BufferPool
<
T
>
{
&
self
.
deque
.
pool
}
}
impl
<
T
:
Send
>
Clone
for
Stealer
<
T
>
{
fn
clone
(
&
self
)
-
>
Stealer
<
T
>
{
Stealer
{
deque
:
self
.
deque
.
clone
(
)
}
}
}
impl
<
T
:
Send
>
Deque
<
T
>
{
fn
new
(
mut
pool
:
BufferPool
<
T
>
)
-
>
Deque
<
T
>
{
let
buf
=
pool
.
alloc
(
MIN_BITS
)
;
Deque
{
bottom
:
AtomicIsize
:
:
new
(
0
)
top
:
AtomicIsize
:
:
new
(
0
)
array
:
AtomicPtr
:
:
new
(
unsafe
{
transmute
(
buf
)
}
)
pool
:
pool
}
}
unsafe
fn
push
(
&
self
data
:
T
)
{
let
mut
b
=
self
.
bottom
.
load
(
SeqCst
)
;
let
t
=
self
.
top
.
load
(
SeqCst
)
;
let
mut
a
=
self
.
array
.
load
(
SeqCst
)
;
let
size
=
b
-
t
;
if
size
>
=
(
*
a
)
.
size
(
)
-
1
{
a
=
self
.
swap_buffer
(
b
a
(
*
a
)
.
resize
(
b
t
1
)
)
;
b
=
self
.
bottom
.
load
(
SeqCst
)
;
}
(
*
a
)
.
put
(
b
data
)
;
self
.
bottom
.
store
(
b
+
1
SeqCst
)
;
}
unsafe
fn
pop
(
&
self
)
-
>
Option
<
T
>
{
let
b
=
self
.
bottom
.
load
(
SeqCst
)
;
let
a
=
self
.
array
.
load
(
SeqCst
)
;
let
b
=
b
-
1
;
self
.
bottom
.
store
(
b
SeqCst
)
;
let
t
=
self
.
top
.
load
(
SeqCst
)
;
let
size
=
b
-
t
;
if
size
<
0
{
self
.
bottom
.
store
(
t
SeqCst
)
;
return
None
;
}
let
data
=
(
*
a
)
.
get
(
b
)
;
if
size
>
0
{
self
.
maybe_shrink
(
b
t
)
;
return
Some
(
data
)
;
}
if
self
.
top
.
compare_and_swap
(
t
t
+
1
SeqCst
)
=
=
t
{
self
.
bottom
.
store
(
t
+
1
SeqCst
)
;
return
Some
(
data
)
;
}
else
{
self
.
bottom
.
store
(
t
+
1
SeqCst
)
;
forget
(
data
)
;
return
None
;
}
}
unsafe
fn
steal
(
&
self
)
-
>
Stolen
<
T
>
{
let
t
=
self
.
top
.
load
(
SeqCst
)
;
let
old
=
self
.
array
.
load
(
SeqCst
)
;
let
b
=
self
.
bottom
.
load
(
SeqCst
)
;
let
a
=
self
.
array
.
load
(
SeqCst
)
;
let
size
=
b
-
t
;
if
size
<
=
0
{
return
Empty
}
if
size
%
(
*
a
)
.
size
(
)
=
=
0
{
if
a
=
=
old
&
&
t
=
=
self
.
top
.
load
(
SeqCst
)
{
return
Empty
}
return
Abort
}
let
data
=
(
*
a
)
.
get
(
t
)
;
if
self
.
top
.
compare_and_swap
(
t
t
+
1
SeqCst
)
=
=
t
{
Data
(
data
)
}
else
{
forget
(
data
)
;
Abort
}
}
unsafe
fn
maybe_shrink
(
&
self
b
:
isize
t
:
isize
)
{
let
a
=
self
.
array
.
load
(
SeqCst
)
;
if
b
-
t
<
(
*
a
)
.
size
(
)
/
K
&
&
b
-
t
>
(
1
<
<
MIN_BITS
)
{
self
.
swap_buffer
(
b
a
(
*
a
)
.
resize
(
b
t
-
1
)
)
;
}
}
unsafe
fn
swap_buffer
(
&
self
b
:
isize
old
:
*
mut
Buffer
<
T
>
buf
:
Buffer
<
T
>
)
-
>
*
mut
Buffer
<
T
>
{
let
newbuf
:
*
mut
Buffer
<
T
>
=
transmute
(
box
buf
)
;
self
.
array
.
store
(
newbuf
SeqCst
)
;
let
ss
=
(
*
newbuf
)
.
size
(
)
;
self
.
bottom
.
store
(
b
+
ss
SeqCst
)
;
let
t
=
self
.
top
.
load
(
SeqCst
)
;
if
self
.
top
.
compare_and_swap
(
t
t
+
ss
SeqCst
)
!
=
t
{
self
.
bottom
.
store
(
b
SeqCst
)
;
}
self
.
pool
.
free
(
transmute
(
old
)
)
;
return
newbuf
;
}
}
#
[
unsafe_destructor
]
impl
<
T
:
Send
>
Drop
for
Deque
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
t
=
self
.
top
.
load
(
SeqCst
)
;
let
b
=
self
.
bottom
.
load
(
SeqCst
)
;
let
a
=
self
.
array
.
load
(
SeqCst
)
;
for
i
in
range
(
t
b
)
{
let
_
:
T
=
unsafe
{
(
*
a
)
.
get
(
i
)
}
;
}
self
.
pool
.
free
(
unsafe
{
transmute
(
a
)
}
)
;
}
}
#
[
inline
]
fn
buffer_alloc_size
<
T
>
(
log_size
:
usize
)
-
>
usize
{
(
1
<
<
log_size
)
*
size_of
:
:
<
T
>
(
)
}
impl
<
T
:
Send
>
Buffer
<
T
>
{
unsafe
fn
new
(
log_size
:
usize
)
-
>
Buffer
<
T
>
{
let
size
=
buffer_alloc_size
:
:
<
T
>
(
log_size
)
;
let
buffer
=
allocate
(
size
min_align_of
:
:
<
T
>
(
)
)
;
if
buffer
.
is_null
(
)
{
:
:
alloc
:
:
oom
(
)
}
Buffer
{
storage
:
buffer
as
*
const
T
log_size
:
log_size
}
}
fn
size
(
&
self
)
-
>
isize
{
1
<
<
self
.
log_size
}
fn
mask
(
&
self
)
-
>
isize
{
(
1
<
<
self
.
log_size
)
-
1
}
unsafe
fn
elem
(
&
self
i
:
isize
)
-
>
*
const
T
{
self
.
storage
.
offset
(
i
&
self
.
mask
(
)
)
}
unsafe
fn
get
(
&
self
i
:
isize
)
-
>
T
{
ptr
:
:
read
(
self
.
elem
(
i
)
)
}
unsafe
fn
put
(
&
self
i
:
isize
t
:
T
)
{
ptr
:
:
write
(
self
.
elem
(
i
)
as
*
mut
T
t
)
;
}
unsafe
fn
resize
(
&
self
b
:
isize
t
:
isize
delta
:
isize
)
-
>
Buffer
<
T
>
{
let
buf
=
Buffer
:
:
new
(
self
.
log_size
+
delta
as
usize
)
;
for
i
in
range
(
t
b
)
{
buf
.
put
(
i
self
.
get
(
i
)
)
;
}
return
buf
;
}
}
#
[
unsafe_destructor
]
impl
<
T
:
Send
>
Drop
for
Buffer
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
size
=
buffer_alloc_size
:
:
<
T
>
(
self
.
log_size
)
;
unsafe
{
deallocate
(
self
.
storage
as
*
mut
u8
size
min_align_of
:
:
<
T
>
(
)
)
}
}
}
