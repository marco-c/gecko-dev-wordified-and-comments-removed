#
!
[
experimental
]
pub
use
self
:
:
Stolen
:
:
{
Empty
Abort
Data
}
;
use
alloc
:
:
arc
:
:
Arc
;
use
alloc
:
:
heap
:
:
{
allocate
deallocate
}
;
use
std
:
:
kinds
:
:
marker
;
use
std
:
:
mem
:
:
{
forget
min_align_of
size_of
transmute
}
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
Mutex
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicInt
AtomicPtr
SeqCst
}
;
static
K
:
int
=
4
;
static
MIN_BITS
:
uint
=
7
;
struct
Deque
<
T
>
{
bottom
:
AtomicInt
top
:
AtomicInt
array
:
AtomicPtr
<
Buffer
<
T
>
>
pool
:
BufferPool
<
T
>
}
pub
struct
Worker
<
T
>
{
deque
:
Arc
<
Deque
<
T
>
>
_noshare
:
marker
:
:
NoSync
}
pub
struct
Stealer
<
T
>
{
deque
:
Arc
<
Deque
<
T
>
>
_noshare
:
marker
:
:
NoSync
}
#
[
deriving
(
PartialEq
Show
)
]
pub
enum
Stolen
<
T
>
{
Empty
Abort
Data
(
T
)
}
pub
struct
BufferPool
<
T
>
{
pool
:
Arc
<
Mutex
<
Vec
<
Box
<
Buffer
<
T
>
>
>
>
>
}
struct
Buffer
<
T
>
{
storage
:
*
const
T
log_size
:
uint
}
impl
<
T
:
Send
>
BufferPool
<
T
>
{
pub
fn
new
(
)
-
>
BufferPool
<
T
>
{
BufferPool
{
pool
:
Arc
:
:
new
(
Mutex
:
:
new
(
Vec
:
:
new
(
)
)
)
}
}
pub
fn
deque
(
&
self
)
-
>
(
Worker
<
T
>
Stealer
<
T
>
)
{
let
a
=
Arc
:
:
new
(
Deque
:
:
new
(
self
.
clone
(
)
)
)
;
let
b
=
a
.
clone
(
)
;
(
Worker
{
deque
:
a
_noshare
:
marker
:
:
NoSync
}
Stealer
{
deque
:
b
_noshare
:
marker
:
:
NoSync
}
)
}
fn
alloc
(
&
mut
self
bits
:
uint
)
-
>
Box
<
Buffer
<
T
>
>
{
unsafe
{
let
mut
pool
=
self
.
pool
.
lock
(
)
;
match
pool
.
iter
(
)
.
position
(
|
x
|
x
.
size
(
)
>
=
(
1
<
<
bits
)
)
{
Some
(
i
)
=
>
pool
.
remove
(
i
)
.
unwrap
(
)
None
=
>
box
Buffer
:
:
new
(
bits
)
}
}
}
fn
free
(
&
self
buf
:
Box
<
Buffer
<
T
>
>
)
{
let
mut
pool
=
self
.
pool
.
lock
(
)
;
match
pool
.
iter
(
)
.
position
(
|
v
|
v
.
size
(
)
>
buf
.
size
(
)
)
{
Some
(
i
)
=
>
pool
.
insert
(
i
buf
)
None
=
>
pool
.
push
(
buf
)
}
}
}
impl
<
T
:
Send
>
Clone
for
BufferPool
<
T
>
{
fn
clone
(
&
self
)
-
>
BufferPool
<
T
>
{
BufferPool
{
pool
:
self
.
pool
.
clone
(
)
}
}
}
impl
<
T
:
Send
>
Worker
<
T
>
{
pub
fn
push
(
&
self
t
:
T
)
{
unsafe
{
self
.
deque
.
push
(
t
)
}
}
pub
fn
pop
(
&
self
)
-
>
Option
<
T
>
{
unsafe
{
self
.
deque
.
pop
(
)
}
}
pub
fn
pool
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
BufferPool
<
T
>
{
&
self
.
deque
.
pool
}
}
impl
<
T
:
Send
>
Stealer
<
T
>
{
pub
fn
steal
(
&
self
)
-
>
Stolen
<
T
>
{
unsafe
{
self
.
deque
.
steal
(
)
}
}
pub
fn
pool
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
BufferPool
<
T
>
{
&
self
.
deque
.
pool
}
}
impl
<
T
:
Send
>
Clone
for
Stealer
<
T
>
{
fn
clone
(
&
self
)
-
>
Stealer
<
T
>
{
Stealer
{
deque
:
self
.
deque
.
clone
(
)
_noshare
:
marker
:
:
NoSync
}
}
}
impl
<
T
:
Send
>
Deque
<
T
>
{
fn
new
(
mut
pool
:
BufferPool
<
T
>
)
-
>
Deque
<
T
>
{
let
buf
=
pool
.
alloc
(
MIN_BITS
)
;
Deque
{
bottom
:
AtomicInt
:
:
new
(
0
)
top
:
AtomicInt
:
:
new
(
0
)
array
:
AtomicPtr
:
:
new
(
unsafe
{
transmute
(
buf
)
}
)
pool
:
pool
}
}
unsafe
fn
push
(
&
self
data
:
T
)
{
let
mut
b
=
self
.
bottom
.
load
(
SeqCst
)
;
let
t
=
self
.
top
.
load
(
SeqCst
)
;
let
mut
a
=
self
.
array
.
load
(
SeqCst
)
;
let
size
=
b
-
t
;
if
size
>
=
(
*
a
)
.
size
(
)
-
1
{
a
=
self
.
swap_buffer
(
b
a
(
*
a
)
.
resize
(
b
t
1
)
)
;
b
=
self
.
bottom
.
load
(
SeqCst
)
;
}
(
*
a
)
.
put
(
b
data
)
;
self
.
bottom
.
store
(
b
+
1
SeqCst
)
;
}
unsafe
fn
pop
(
&
self
)
-
>
Option
<
T
>
{
let
b
=
self
.
bottom
.
load
(
SeqCst
)
;
let
a
=
self
.
array
.
load
(
SeqCst
)
;
let
b
=
b
-
1
;
self
.
bottom
.
store
(
b
SeqCst
)
;
let
t
=
self
.
top
.
load
(
SeqCst
)
;
let
size
=
b
-
t
;
if
size
<
0
{
self
.
bottom
.
store
(
t
SeqCst
)
;
return
None
;
}
let
data
=
(
*
a
)
.
get
(
b
)
;
if
size
>
0
{
self
.
maybe_shrink
(
b
t
)
;
return
Some
(
data
)
;
}
if
self
.
top
.
compare_and_swap
(
t
t
+
1
SeqCst
)
=
=
t
{
self
.
bottom
.
store
(
t
+
1
SeqCst
)
;
return
Some
(
data
)
;
}
else
{
self
.
bottom
.
store
(
t
+
1
SeqCst
)
;
forget
(
data
)
;
return
None
;
}
}
unsafe
fn
steal
(
&
self
)
-
>
Stolen
<
T
>
{
let
t
=
self
.
top
.
load
(
SeqCst
)
;
let
old
=
self
.
array
.
load
(
SeqCst
)
;
let
b
=
self
.
bottom
.
load
(
SeqCst
)
;
let
a
=
self
.
array
.
load
(
SeqCst
)
;
let
size
=
b
-
t
;
if
size
<
=
0
{
return
Empty
}
if
size
%
(
*
a
)
.
size
(
)
=
=
0
{
if
a
=
=
old
&
&
t
=
=
self
.
top
.
load
(
SeqCst
)
{
return
Empty
}
return
Abort
}
let
data
=
(
*
a
)
.
get
(
t
)
;
if
self
.
top
.
compare_and_swap
(
t
t
+
1
SeqCst
)
=
=
t
{
Data
(
data
)
}
else
{
forget
(
data
)
;
Abort
}
}
unsafe
fn
maybe_shrink
(
&
self
b
:
int
t
:
int
)
{
let
a
=
self
.
array
.
load
(
SeqCst
)
;
if
b
-
t
<
(
*
a
)
.
size
(
)
/
K
&
&
b
-
t
>
(
1
<
<
MIN_BITS
)
{
self
.
swap_buffer
(
b
a
(
*
a
)
.
resize
(
b
t
-
1
)
)
;
}
}
unsafe
fn
swap_buffer
(
&
self
b
:
int
old
:
*
mut
Buffer
<
T
>
buf
:
Buffer
<
T
>
)
-
>
*
mut
Buffer
<
T
>
{
let
newbuf
:
*
mut
Buffer
<
T
>
=
transmute
(
box
buf
)
;
self
.
array
.
store
(
newbuf
SeqCst
)
;
let
ss
=
(
*
newbuf
)
.
size
(
)
;
self
.
bottom
.
store
(
b
+
ss
SeqCst
)
;
let
t
=
self
.
top
.
load
(
SeqCst
)
;
if
self
.
top
.
compare_and_swap
(
t
t
+
ss
SeqCst
)
!
=
t
{
self
.
bottom
.
store
(
b
SeqCst
)
;
}
self
.
pool
.
free
(
transmute
(
old
)
)
;
return
newbuf
;
}
}
#
[
unsafe_destructor
]
impl
<
T
:
Send
>
Drop
for
Deque
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
t
=
self
.
top
.
load
(
SeqCst
)
;
let
b
=
self
.
bottom
.
load
(
SeqCst
)
;
let
a
=
self
.
array
.
load
(
SeqCst
)
;
for
i
in
range
(
t
b
)
{
let
_
:
T
=
unsafe
{
(
*
a
)
.
get
(
i
)
}
;
}
self
.
pool
.
free
(
unsafe
{
transmute
(
a
)
}
)
;
}
}
#
[
inline
]
fn
buffer_alloc_size
<
T
>
(
log_size
:
uint
)
-
>
uint
{
(
1
<
<
log_size
)
*
size_of
:
:
<
T
>
(
)
}
impl
<
T
:
Send
>
Buffer
<
T
>
{
unsafe
fn
new
(
log_size
:
uint
)
-
>
Buffer
<
T
>
{
let
size
=
buffer_alloc_size
:
:
<
T
>
(
log_size
)
;
let
buffer
=
allocate
(
size
min_align_of
:
:
<
T
>
(
)
)
;
if
buffer
.
is_null
(
)
{
:
:
alloc
:
:
oom
(
)
}
Buffer
{
storage
:
buffer
as
*
const
T
log_size
:
log_size
}
}
fn
size
(
&
self
)
-
>
int
{
1
<
<
self
.
log_size
}
fn
mask
(
&
self
)
-
>
int
{
(
1
<
<
self
.
log_size
)
-
1
}
unsafe
fn
elem
(
&
self
i
:
int
)
-
>
*
const
T
{
self
.
storage
.
offset
(
i
&
self
.
mask
(
)
)
}
unsafe
fn
get
(
&
self
i
:
int
)
-
>
T
{
ptr
:
:
read
(
self
.
elem
(
i
)
)
}
unsafe
fn
put
(
&
self
i
:
int
t
:
T
)
{
ptr
:
:
write
(
self
.
elem
(
i
)
as
*
mut
T
t
)
;
}
unsafe
fn
resize
(
&
self
b
:
int
t
:
int
delta
:
int
)
-
>
Buffer
<
T
>
{
let
buf
=
Buffer
:
:
new
(
self
.
log_size
+
delta
as
uint
)
;
for
i
in
range
(
t
b
)
{
buf
.
put
(
i
self
.
get
(
i
)
)
;
}
return
buf
;
}
}
#
[
unsafe_destructor
]
impl
<
T
:
Send
>
Drop
for
Buffer
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
size
=
buffer_alloc_size
:
:
<
T
>
(
self
.
log_size
)
;
unsafe
{
deallocate
(
self
.
storage
as
*
mut
u8
size
min_align_of
:
:
<
T
>
(
)
)
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
Data
BufferPool
Abort
Empty
Worker
Stealer
}
;
use
std
:
:
mem
;
use
rustrt
:
:
thread
:
:
Thread
;
use
std
:
:
rand
;
use
std
:
:
rand
:
:
Rng
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
INIT_ATOMIC_BOOL
SeqCst
AtomicUint
INIT_ATOMIC_UINT
}
;
use
std
:
:
vec
;
#
[
test
]
fn
smoke
(
)
{
let
pool
=
BufferPool
:
:
new
(
)
;
let
(
w
s
)
=
pool
.
deque
(
)
;
assert_eq
!
(
w
.
pop
(
)
None
)
;
assert_eq
!
(
s
.
steal
(
)
Empty
)
;
w
.
push
(
1i
)
;
assert_eq
!
(
w
.
pop
(
)
Some
(
1
)
)
;
w
.
push
(
1
)
;
assert_eq
!
(
s
.
steal
(
)
Data
(
1
)
)
;
w
.
push
(
1
)
;
assert_eq
!
(
s
.
clone
(
)
.
steal
(
)
Data
(
1
)
)
;
}
#
[
test
]
fn
stealpush
(
)
{
static
AMT
:
int
=
100000
;
let
pool
=
BufferPool
:
:
<
int
>
:
:
new
(
)
;
let
(
w
s
)
=
pool
.
deque
(
)
;
let
t
=
Thread
:
:
start
(
proc
(
)
{
let
mut
left
=
AMT
;
while
left
>
0
{
match
s
.
steal
(
)
{
Data
(
i
)
=
>
{
assert_eq
!
(
i
1
)
;
left
-
=
1
;
}
Abort
|
Empty
=
>
{
}
}
}
}
)
;
for
_
in
range
(
0
AMT
)
{
w
.
push
(
1
)
;
}
t
.
join
(
)
;
}
#
[
test
]
fn
stealpush_large
(
)
{
static
AMT
:
int
=
100000
;
let
pool
=
BufferPool
:
:
<
(
int
int
)
>
:
:
new
(
)
;
let
(
w
s
)
=
pool
.
deque
(
)
;
let
t
=
Thread
:
:
start
(
proc
(
)
{
let
mut
left
=
AMT
;
while
left
>
0
{
match
s
.
steal
(
)
{
Data
(
(
1
10
)
)
=
>
{
left
-
=
1
;
}
Data
(
.
.
)
=
>
panic
!
(
)
Abort
|
Empty
=
>
{
}
}
}
}
)
;
for
_
in
range
(
0
AMT
)
{
w
.
push
(
(
1
10
)
)
;
}
t
.
join
(
)
;
}
fn
stampede
(
w
:
Worker
<
Box
<
int
>
>
s
:
Stealer
<
Box
<
int
>
>
nthreads
:
int
amt
:
uint
)
{
for
_
in
range
(
0
amt
)
{
w
.
push
(
box
20
)
;
}
let
mut
remaining
=
AtomicUint
:
:
new
(
amt
)
;
let
unsafe_remaining
:
*
mut
AtomicUint
=
&
mut
remaining
;
let
threads
=
range
(
0
nthreads
)
.
map
(
|
_
|
{
let
s
=
s
.
clone
(
)
;
Thread
:
:
start
(
proc
(
)
{
unsafe
{
while
(
*
unsafe_remaining
)
.
load
(
SeqCst
)
>
0
{
match
s
.
steal
(
)
{
Data
(
box
20
)
=
>
{
(
*
unsafe_remaining
)
.
fetch_sub
(
1
SeqCst
)
;
}
Data
(
.
.
)
=
>
panic
!
(
)
Abort
|
Empty
=
>
{
}
}
}
}
}
)
}
)
.
collect
:
:
<
Vec
<
Thread
<
(
)
>
>
>
(
)
;
while
remaining
.
load
(
SeqCst
)
>
0
{
match
w
.
pop
(
)
{
Some
(
box
20
)
=
>
{
remaining
.
fetch_sub
(
1
SeqCst
)
;
}
Some
(
.
.
)
=
>
panic
!
(
)
None
=
>
{
}
}
}
for
thread
in
threads
.
into_iter
(
)
{
thread
.
join
(
)
;
}
}
#
[
test
]
fn
run_stampede
(
)
{
let
pool
=
BufferPool
:
:
<
Box
<
int
>
>
:
:
new
(
)
;
let
(
w
s
)
=
pool
.
deque
(
)
;
stampede
(
w
s
8
10000
)
;
}
#
[
test
]
fn
many_stampede
(
)
{
static
AMT
:
uint
=
4
;
let
pool
=
BufferPool
:
:
<
Box
<
int
>
>
:
:
new
(
)
;
let
threads
=
range
(
0
AMT
)
.
map
(
|
_
|
{
let
(
w
s
)
=
pool
.
deque
(
)
;
Thread
:
:
start
(
proc
(
)
{
stampede
(
w
s
4
10000
)
;
}
)
}
)
.
collect
:
:
<
Vec
<
Thread
<
(
)
>
>
>
(
)
;
for
thread
in
threads
.
into_iter
(
)
{
thread
.
join
(
)
;
}
}
#
[
test
]
fn
stress
(
)
{
static
AMT
:
int
=
100000
;
static
NTHREADS
:
int
=
8
;
static
DONE
:
AtomicBool
=
INIT_ATOMIC_BOOL
;
static
HITS
:
AtomicUint
=
INIT_ATOMIC_UINT
;
let
pool
=
BufferPool
:
:
<
int
>
:
:
new
(
)
;
let
(
w
s
)
=
pool
.
deque
(
)
;
let
threads
=
range
(
0
NTHREADS
)
.
map
(
|
_
|
{
let
s
=
s
.
clone
(
)
;
Thread
:
:
start
(
proc
(
)
{
loop
{
match
s
.
steal
(
)
{
Data
(
2
)
=
>
{
HITS
.
fetch_add
(
1
SeqCst
)
;
}
Data
(
.
.
)
=
>
panic
!
(
)
_
if
DONE
.
load
(
SeqCst
)
=
>
break
_
=
>
{
}
}
}
}
)
}
)
.
collect
:
:
<
Vec
<
Thread
<
(
)
>
>
>
(
)
;
let
mut
rng
=
rand
:
:
task_rng
(
)
;
let
mut
expected
=
0
;
while
expected
<
AMT
{
if
rng
.
gen_range
(
0i
3
)
=
=
2
{
match
w
.
pop
(
)
{
None
=
>
{
}
Some
(
2
)
=
>
{
HITS
.
fetch_add
(
1
SeqCst
)
;
}
Some
(
_
)
=
>
panic
!
(
)
}
}
else
{
expected
+
=
1
;
w
.
push
(
2
)
;
}
}
while
HITS
.
load
(
SeqCst
)
<
AMT
as
uint
{
match
w
.
pop
(
)
{
None
=
>
{
}
Some
(
2
)
=
>
{
HITS
.
fetch_add
(
1
SeqCst
)
;
}
Some
(
_
)
=
>
panic
!
(
)
}
}
DONE
.
store
(
true
SeqCst
)
;
for
thread
in
threads
.
into_iter
(
)
{
thread
.
join
(
)
;
}
assert_eq
!
(
HITS
.
load
(
SeqCst
)
expected
as
uint
)
;
}
#
[
test
]
#
[
cfg_attr
(
windows
ignore
)
]
fn
no_starvation
(
)
{
static
AMT
:
int
=
10000
;
static
NTHREADS
:
int
=
4
;
static
DONE
:
AtomicBool
=
INIT_ATOMIC_BOOL
;
let
pool
=
BufferPool
:
:
<
(
int
uint
)
>
:
:
new
(
)
;
let
(
w
s
)
=
pool
.
deque
(
)
;
let
(
threads
hits
)
=
vec
:
:
unzip
(
range
(
0
NTHREADS
)
.
map
(
|
_
|
{
let
s
=
s
.
clone
(
)
;
let
unique_box
=
box
AtomicUint
:
:
new
(
0
)
;
let
thread_box
=
unsafe
{
*
mem
:
:
transmute
:
:
<
&
Box
<
AtomicUint
>
*
const
*
mut
AtomicUint
>
(
&
unique_box
)
}
;
(
Thread
:
:
start
(
proc
(
)
{
unsafe
{
loop
{
match
s
.
steal
(
)
{
Data
(
(
1
2
)
)
=
>
{
(
*
thread_box
)
.
fetch_add
(
1
SeqCst
)
;
}
Data
(
.
.
)
=
>
panic
!
(
)
_
if
DONE
.
load
(
SeqCst
)
=
>
break
_
=
>
{
}
}
}
}
}
)
unique_box
)
}
)
)
;
let
mut
rng
=
rand
:
:
task_rng
(
)
;
let
mut
myhit
=
false
;
'
outer
:
loop
{
for
_
in
range
(
0
rng
.
gen_range
(
0
AMT
)
)
{
if
!
myhit
&
&
rng
.
gen_range
(
0i
3
)
=
=
2
{
match
w
.
pop
(
)
{
None
=
>
{
}
Some
(
(
1
2
)
)
=
>
myhit
=
true
Some
(
_
)
=
>
panic
!
(
)
}
}
else
{
w
.
push
(
(
1
2
)
)
;
}
}
for
slot
in
hits
.
iter
(
)
{
let
amt
=
slot
.
load
(
SeqCst
)
;
if
amt
=
=
0
{
continue
'
outer
;
}
}
if
myhit
{
break
}
}
DONE
.
store
(
true
SeqCst
)
;
for
thread
in
threads
.
into_iter
(
)
{
thread
.
join
(
)
;
}
}
}
