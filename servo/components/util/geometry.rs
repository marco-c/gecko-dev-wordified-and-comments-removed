use
cssparser
:
:
ToCss
;
use
euclid
:
:
num
:
:
Zero
;
use
euclid
:
:
point
:
:
Point2D
;
use
euclid
:
:
rect
:
:
Rect
;
use
euclid
:
:
size
:
:
Size2D
;
use
rustc_serialize
:
:
{
Encodable
Encoder
}
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
fmt
;
use
std
:
:
i32
;
use
std
:
:
ops
:
:
{
Add
Div
Mul
Neg
Rem
Sub
}
;
#
[
derive
(
Debug
Copy
Clone
)
]
pub
enum
ScreenPx
{
}
#
[
derive
(
RustcEncodable
Debug
Copy
Clone
)
]
pub
enum
ViewportPx
{
}
#
[
derive
(
RustcEncodable
Debug
Copy
Clone
)
]
pub
enum
PagePx
{
}
pub
const
AU_PER_PX
:
i32
=
60
;
#
[
derive
(
Clone
Copy
Hash
PartialEq
PartialOrd
Eq
Ord
Deserialize
Serialize
)
]
pub
struct
Au
(
pub
i32
)
;
impl
Default
for
Au
{
#
[
inline
]
fn
default
(
)
-
>
Au
{
Au
(
0
)
}
}
impl
Zero
for
Au
{
#
[
inline
]
fn
zero
(
)
-
>
Au
{
Au
(
0
)
}
}
pub
static
ZERO_POINT
:
Point2D
<
Au
>
=
Point2D
{
x
:
Au
(
0
)
y
:
Au
(
0
)
}
;
pub
static
ZERO_RECT
:
Rect
<
Au
>
=
Rect
{
origin
:
Point2D
{
x
:
Au
(
0
)
y
:
Au
(
0
)
}
size
:
Size2D
{
width
:
Au
(
0
)
height
:
Au
(
0
)
}
}
;
pub
static
MAX_RECT
:
Rect
<
Au
>
=
Rect
{
origin
:
Point2D
{
x
:
Au
(
i32
:
:
MIN
/
2
)
y
:
Au
(
i32
:
:
MIN
/
2
)
}
size
:
Size2D
{
width
:
MAX_AU
height
:
MAX_AU
}
}
;
pub
const
MIN_AU
:
Au
=
Au
(
i32
:
:
MIN
)
;
pub
const
MAX_AU
:
Au
=
Au
(
i32
:
:
MAX
)
;
impl
Encodable
for
Au
{
fn
encode
<
S
:
Encoder
>
(
&
self
e
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
e
.
emit_f64
(
self
.
to_f64_px
(
)
)
}
}
impl
fmt
:
:
Debug
for
Au
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
px
"
self
.
to_f64_px
(
)
)
}
}
impl
ToCss
for
Au
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
write
!
(
dest
"
{
}
px
"
self
.
to_f64_px
(
)
)
}
}
impl
Add
for
Au
{
type
Output
=
Au
;
#
[
inline
]
fn
add
(
self
other
:
Au
)
-
>
Au
{
Au
(
self
.
0
.
wrapping_add
(
other
.
0
)
)
}
}
impl
Sub
for
Au
{
type
Output
=
Au
;
#
[
inline
]
fn
sub
(
self
other
:
Au
)
-
>
Au
{
Au
(
self
.
0
.
wrapping_sub
(
other
.
0
)
)
}
}
impl
Mul
<
i32
>
for
Au
{
type
Output
=
Au
;
#
[
inline
]
fn
mul
(
self
other
:
i32
)
-
>
Au
{
Au
(
self
.
0
.
wrapping_mul
(
other
)
)
}
}
impl
Div
<
i32
>
for
Au
{
type
Output
=
Au
;
#
[
inline
]
fn
div
(
self
other
:
i32
)
-
>
Au
{
Au
(
self
.
0
/
other
)
}
}
impl
Rem
<
i32
>
for
Au
{
type
Output
=
Au
;
#
[
inline
]
fn
rem
(
self
other
:
i32
)
-
>
Au
{
Au
(
self
.
0
%
other
)
}
}
impl
Neg
for
Au
{
type
Output
=
Au
;
#
[
inline
]
fn
neg
(
self
)
-
>
Au
{
Au
(
-
self
.
0
)
}
}
impl
Au
{
#
[
inline
]
pub
fn
new
(
value
:
i32
)
-
>
Au
{
Au
(
value
)
}
#
[
inline
]
pub
fn
scale_by
(
self
factor
:
f32
)
-
>
Au
{
Au
(
(
(
self
.
0
as
f32
)
*
factor
)
as
i32
)
}
#
[
inline
]
pub
fn
from_px
(
px
:
i32
)
-
>
Au
{
Au
(
(
px
*
AU_PER_PX
)
as
i32
)
}
#
[
inline
]
pub
fn
to_px
(
self
)
-
>
i32
{
self
.
0
/
AU_PER_PX
}
#
[
inline
]
pub
fn
to_nearest_px
(
self
)
-
>
i32
{
(
(
self
.
0
as
f64
)
/
(
AU_PER_PX
as
f64
)
)
.
round
(
)
as
i32
}
#
[
inline
]
pub
fn
to_nearest_pixel
(
self
pixels_per_px
:
f32
)
-
>
f32
{
(
(
self
.
0
as
f32
)
/
(
AU_PER_PX
as
f32
)
*
pixels_per_px
)
.
round
(
)
/
pixels_per_px
}
#
[
inline
]
pub
fn
to_f32_px
(
self
)
-
>
f32
{
(
self
.
0
as
f32
)
/
(
AU_PER_PX
as
f32
)
}
#
[
inline
]
pub
fn
to_f64_px
(
self
)
-
>
f64
{
(
self
.
0
as
f64
)
/
(
AU_PER_PX
as
f64
)
}
#
[
inline
]
pub
fn
from_f32_px
(
px
:
f32
)
-
>
Au
{
Au
(
(
px
*
(
AU_PER_PX
as
f32
)
)
as
i32
)
}
#
[
inline
]
pub
fn
from_f64_px
(
px
:
f64
)
-
>
Au
{
Au
(
(
px
*
(
AU_PER_PX
as
f64
)
)
as
i32
)
}
}
pub
fn
rect_contains_point
<
T
:
PartialOrd
+
Add
<
T
Output
=
T
>
>
(
rect
:
Rect
<
T
>
point
:
Point2D
<
T
>
)
-
>
bool
{
point
.
x
>
=
rect
.
origin
.
x
&
&
point
.
x
<
rect
.
origin
.
x
+
rect
.
size
.
width
&
&
point
.
y
>
=
rect
.
origin
.
y
&
&
point
.
y
<
rect
.
origin
.
y
+
rect
.
size
.
height
}
pub
fn
f32_rect_to_au_rect
(
rect
:
Rect
<
f32
>
)
-
>
Rect
<
Au
>
{
Rect
:
:
new
(
Point2D
:
:
new
(
Au
:
:
from_f32_px
(
rect
.
origin
.
x
)
Au
:
:
from_f32_px
(
rect
.
origin
.
y
)
)
Size2D
:
:
new
(
Au
:
:
from_f32_px
(
rect
.
size
.
width
)
Au
:
:
from_f32_px
(
rect
.
size
.
height
)
)
)
}
pub
fn
au_rect_to_f32_rect
(
rect
:
Rect
<
Au
>
)
-
>
Rect
<
f32
>
{
Rect
:
:
new
(
Point2D
:
:
new
(
rect
.
origin
.
x
.
to_f32_px
(
)
rect
.
origin
.
y
.
to_f32_px
(
)
)
Size2D
:
:
new
(
rect
.
size
.
width
.
to_f32_px
(
)
rect
.
size
.
height
.
to_f32_px
(
)
)
)
}
