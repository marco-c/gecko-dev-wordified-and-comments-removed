use
std
:
:
mem
;
use
std
:
:
sync
:
:
Arc
;
pub
struct
PersistentList
<
T
>
{
head
:
PersistentListLink
<
T
>
length
:
uint
}
struct
PersistentListEntry
<
T
>
{
value
:
T
next
:
PersistentListLink
<
T
>
}
type
PersistentListLink
<
T
>
=
Option
<
Arc
<
PersistentListEntry
<
T
>
>
>
;
impl
<
T
>
PersistentList
<
T
>
where
T
:
Send
+
Sync
{
#
[
inline
]
pub
fn
new
(
)
-
>
PersistentList
<
T
>
{
PersistentList
{
head
:
None
length
:
0
}
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
uint
{
self
.
length
}
#
[
inline
]
pub
fn
front
(
&
self
)
-
>
Option
<
&
T
>
{
self
.
head
.
as_ref
(
)
.
map
(
|
head
|
&
head
.
value
)
}
#
[
inline
]
pub
fn
prepend_elem
(
&
self
value
:
T
)
-
>
PersistentList
<
T
>
{
PersistentList
{
head
:
Some
(
Arc
:
:
new
(
PersistentListEntry
{
value
:
value
next
:
self
.
head
.
clone
(
)
}
)
)
length
:
self
.
length
+
1
}
}
#
[
inline
]
pub
fn
iter
<
'
a
>
(
&
'
a
self
)
-
>
PersistentListIterator
<
'
a
T
>
{
PersistentListIterator
{
entry
:
self
.
head
.
as_ref
(
)
.
map
(
|
head
|
&
*
*
head
)
}
}
}
impl
<
T
>
Clone
for
PersistentList
<
T
>
where
T
:
Send
+
Sync
{
fn
clone
(
&
self
)
-
>
PersistentList
<
T
>
{
PersistentList
{
head
:
self
.
head
.
clone
(
)
length
:
self
.
length
}
}
}
pub
struct
PersistentListIterator
<
'
a
T
>
where
T
:
'
a
+
Send
+
Sync
{
entry
:
Option
<
&
'
a
PersistentListEntry
<
T
>
>
}
impl
<
'
a
T
>
Iterator
for
PersistentListIterator
<
'
a
T
>
where
T
:
Send
+
Sync
{
type
Item
=
&
'
a
T
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
let
entry
=
match
self
.
entry
{
None
=
>
return
None
Some
(
entry
)
=
>
{
unsafe
{
mem
:
:
transmute
:
:
<
&
'
a
PersistentListEntry
<
T
>
&
'
static
PersistentListEntry
<
T
>
>
(
entry
)
}
}
}
;
let
value
=
&
entry
.
value
;
self
.
entry
=
match
entry
.
next
{
None
=
>
None
Some
(
ref
entry
)
=
>
Some
(
&
*
*
entry
)
}
;
Some
(
value
)
}
}
