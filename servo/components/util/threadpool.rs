use
std
:
:
boxed
:
:
FnBox
;
use
std
:
:
sync
:
:
mpsc
:
:
{
Receiver
Sender
channel
}
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
thread
:
:
spawn_named
;
pub
struct
ThreadPool
{
tx
:
Sender
<
Box
<
FnBox
(
)
+
Send
+
'
static
>
>
}
impl
ThreadPool
{
pub
fn
new
(
threads
:
u32
)
-
>
ThreadPool
{
assert
!
(
threads
>
0
)
;
let
(
tx
rx
)
=
channel
(
)
;
let
state
=
Arc
:
:
new
(
Mutex
:
:
new
(
rx
)
)
;
for
i
in
0
.
.
threads
{
let
state
=
state
.
clone
(
)
;
spawn_named
(
format
!
(
"
ThreadPoolWorker
{
}
/
{
}
"
i
+
1
threads
)
move
|
|
worker
(
&
*
state
)
)
;
}
return
ThreadPool
{
tx
:
tx
}
;
fn
worker
(
rx
:
&
Mutex
<
Receiver
<
Box
<
FnBox
(
)
+
Send
+
'
static
>
>
>
)
{
while
let
Ok
(
job
)
=
rx
.
lock
(
)
.
unwrap
(
)
.
recv
(
)
{
job
.
call_box
(
(
)
)
;
}
}
}
pub
fn
execute
<
F
>
(
&
self
job
:
F
)
where
F
:
FnOnce
(
)
+
Send
+
'
static
{
self
.
tx
.
send
(
Box
:
:
new
(
job
)
)
.
unwrap
(
)
;
}
}
