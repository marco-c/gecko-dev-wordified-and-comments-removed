extern
crate
rand
;
use
fnv
:
:
{
FnvState
hash
}
;
use
rand
:
:
Rng
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
iter
;
use
std
:
:
num
;
use
std
:
:
uint
;
#
[
deriving
(
Clone
)
]
pub
struct
BloomFilter
{
buf
:
Vec
<
uint
>
number_of_insertions
:
uint
}
static
NUMBER_OF_HASHES
:
uint
=
7
;
static
BITS_PER_BUCKET
:
uint
=
4
;
static
BUCKETS_PER_WORD
:
uint
=
uint
:
:
BITS
/
BITS_PER_BUCKET
;
fn
bucket_index_to_array_index
(
bucket_index
:
uint
)
-
>
(
uint
uint
)
{
let
arr_index
=
bucket_index
/
BUCKETS_PER_WORD
;
let
shift_amount
=
(
bucket_index
%
BUCKETS_PER_WORD
)
*
BITS_PER_BUCKET
;
(
arr_index
shift_amount
)
}
fn
to_rng
(
hash
:
u64
)
-
>
rand
:
:
XorShiftRng
{
let
bottom
=
(
hash
&
0xFFFFFFFF
)
as
u32
;
let
top
=
(
(
hash
>
>
32
)
&
0xFFFFFFFF
)
as
u32
;
rand
:
:
SeedableRng
:
:
from_seed
(
[
0x97830e05
0x113ba7bb
bottom
top
]
)
}
fn
stretch
<
'
a
>
(
r
:
&
'
a
mut
rand
:
:
XorShiftRng
)
-
>
iter
:
:
Take
<
rand
:
:
Generator
<
'
a
uint
rand
:
:
XorShiftRng
>
>
{
r
.
gen_iter
(
)
.
take
(
NUMBER_OF_HASHES
)
}
impl
BloomFilter
{
pub
fn
new
(
expected_number_of_insertions
:
uint
)
-
>
BloomFilter
{
let
size_in_buckets
=
10
*
expected_number_of_insertions
;
let
size_in_words
=
size_in_buckets
/
BUCKETS_PER_WORD
;
let
nonzero_size
=
if
size_in_words
=
=
0
{
1
}
else
{
size_in_words
}
;
let
num_words
=
num
:
:
checked_next_power_of_two
(
nonzero_size
)
.
unwrap
(
)
;
BloomFilter
{
buf
:
Vec
:
:
from_elem
(
num_words
0
)
number_of_insertions
:
0
}
}
fn
mask
(
&
self
)
-
>
uint
{
(
self
.
buf
.
len
(
)
*
BUCKETS_PER_WORD
)
-
1
}
fn
shash_to_bucket_index
(
&
self
shash
:
uint
)
-
>
uint
{
shash
&
self
.
mask
(
)
}
fn
shash_to_array_index
(
&
self
shash
:
uint
)
-
>
(
uint
uint
)
{
bucket_index_to_array_index
(
self
.
shash_to_bucket_index
(
shash
)
)
}
fn
bucket_get
(
&
self
a_idx
:
uint
shift_amount
:
uint
)
-
>
uint
{
let
array_val
=
self
.
buf
[
a_idx
]
;
(
array_val
>
>
shift_amount
)
&
0xF
}
fn
bucket_set
(
&
mut
self
a_idx
:
uint
shift_amount
:
uint
new_val
:
uint
)
{
let
old_val
=
self
.
buf
.
as_mut_slice
(
)
.
get_mut
(
a_idx
)
.
unwrap
(
)
;
let
mask
=
(
1
<
<
BITS_PER_BUCKET
)
-
1
;
let
select_in_bucket
=
mask
<
<
shift_amount
;
let
select_out_of_bucket
=
!
select_in_bucket
;
let
new_array_val
=
(
new_val
<
<
shift_amount
)
|
(
*
old_val
&
select_out_of_bucket
)
;
*
old_val
=
new_array_val
;
}
fn
insert_shash
(
&
mut
self
shash
:
uint
)
{
let
(
a_idx
shift_amount
)
=
self
.
shash_to_array_index
(
shash
)
;
let
b_val
=
self
.
bucket_get
(
a_idx
shift_amount
)
;
if
b_val
=
=
0xF
{
return
;
}
let
new_val
=
b_val
+
1
;
self
.
bucket_set
(
a_idx
shift_amount
new_val
)
;
}
fn
insert_hashed
(
&
mut
self
hash
:
u64
)
{
self
.
number_of_insertions
+
=
1
;
for
h
in
stretch
(
&
mut
to_rng
(
hash
)
)
{
self
.
insert_shash
(
h
)
;
}
}
pub
fn
insert
<
H
:
Hash
<
FnvState
>
>
(
&
mut
self
h
:
&
H
)
{
self
.
insert_hashed
(
hash
(
h
)
)
}
fn
remove_shash
(
&
mut
self
shash
:
uint
)
{
let
(
a_idx
shift_amount
)
=
self
.
shash_to_array_index
(
shash
)
;
let
b_val
=
self
.
bucket_get
(
a_idx
shift_amount
)
;
assert
!
(
b_val
!
=
0
"
Removing
an
element
that
was
never
inserted
.
"
)
;
if
b_val
=
=
0xF
{
return
;
}
self
.
bucket_set
(
a_idx
shift_amount
b_val
-
1
)
;
}
fn
remove_hashed
(
&
mut
self
hash
:
u64
)
{
self
.
number_of_insertions
-
=
1
;
for
h
in
stretch
(
&
mut
to_rng
(
hash
)
)
{
self
.
remove_shash
(
h
)
;
}
}
pub
fn
remove
<
H
:
Hash
<
FnvState
>
>
(
&
mut
self
h
:
&
H
)
{
self
.
remove_hashed
(
hash
(
h
)
)
}
fn
definitely_excludes_shash
(
&
self
shash
:
uint
)
-
>
bool
{
let
(
a_idx
shift_amount
)
=
self
.
shash_to_array_index
(
shash
)
;
self
.
bucket_get
(
a_idx
shift_amount
)
=
=
0
}
fn
definitely_excludes_hashed
(
&
self
hash
:
u64
)
-
>
bool
{
let
mut
ret
=
false
;
for
shash
in
stretch
(
&
mut
to_rng
(
hash
)
)
{
ret
|
=
self
.
definitely_excludes_shash
(
shash
)
;
}
ret
}
pub
fn
definitely_excludes
<
H
:
Hash
<
FnvState
>
>
(
&
self
h
:
&
H
)
-
>
bool
{
self
.
definitely_excludes_hashed
(
hash
(
h
)
)
}
pub
fn
may_include
<
H
:
Hash
<
FnvState
>
>
(
&
self
h
:
&
H
)
-
>
bool
{
!
self
.
definitely_excludes
(
h
)
}
pub
fn
number_of_insertions
(
&
self
)
-
>
uint
{
self
.
number_of_insertions
}
pub
fn
size
(
&
self
)
-
>
uint
{
self
.
buf
.
len
(
)
*
uint
:
:
BYTES
}
pub
fn
clear
(
&
mut
self
)
{
self
.
number_of_insertions
=
0
;
for
x
in
self
.
buf
.
as_mut_slice
(
)
.
iter_mut
(
)
{
*
x
=
0u
;
}
}
}
#
[
test
]
fn
create_and_insert_some_stuff
(
)
{
use
std
:
:
iter
:
:
range
;
let
mut
bf
=
BloomFilter
:
:
new
(
1000
)
;
for
i
in
range
(
0u
1000
)
{
bf
.
insert
(
&
i
)
;
}
assert_eq
!
(
bf
.
number_of_insertions
(
)
1000
)
;
for
i
in
range
(
0u
1000
)
{
assert
!
(
bf
.
may_include
(
&
i
)
)
;
}
let
false_positives
=
range
(
1001u
2000
)
.
filter
(
|
i
|
bf
.
may_include
(
&
i
)
)
.
count
(
)
;
assert
!
(
false_positives
<
10
)
for
i
in
range
(
0u
100
)
{
bf
.
remove
(
&
i
)
;
}
assert_eq
!
(
bf
.
number_of_insertions
(
)
900
)
;
for
i
in
range
(
100u
1000
)
{
assert
!
(
bf
.
may_include
(
&
i
)
)
;
}
let
false_positives
=
range
(
0u
100
)
.
filter
(
|
i
|
bf
.
may_include
(
&
i
)
)
.
count
(
)
;
assert
!
(
false_positives
<
2
)
;
bf
.
clear
(
)
;
assert_eq
!
(
bf
.
number_of_insertions
(
)
0
)
;
for
i
in
range
(
0u
2000
)
{
assert
!
(
bf
.
definitely_excludes
(
&
i
)
)
;
}
}
#
[
cfg
(
test
)
]
mod
bench
{
extern
crate
test
;
use
std
:
:
hash
:
:
hash
;
use
std
:
:
iter
;
use
super
:
:
BloomFilter
;
#
[
bench
]
fn
create_insert_1000_remove_100_lookup_100
(
b
:
&
mut
test
:
:
Bencher
)
{
b
.
iter
(
|
|
{
let
mut
bf
=
BloomFilter
:
:
new
(
1000
)
;
for
i
in
iter
:
:
range
(
0u
1000
)
{
bf
.
insert
(
&
i
)
;
}
for
i
in
iter
:
:
range
(
0u
100
)
{
bf
.
remove
(
&
i
)
;
}
for
i
in
iter
:
:
range
(
100u
200
)
{
test
:
:
black_box
(
bf
.
may_include
(
&
i
)
)
;
}
}
)
;
}
#
[
bench
]
fn
may_include
(
b
:
&
mut
test
:
:
Bencher
)
{
let
mut
bf
=
BloomFilter
:
:
new
(
1000
)
;
for
i
in
iter
:
:
range
(
0u
1000
)
{
bf
.
insert
(
&
i
)
;
}
let
mut
i
=
0u
;
b
.
bench_n
(
1000
|
b
|
{
b
.
iter
(
|
|
{
test
:
:
black_box
(
bf
.
may_include
(
&
i
)
)
;
i
+
=
1
;
}
)
;
}
)
;
}
#
[
bench
]
fn
insert
(
b
:
&
mut
test
:
:
Bencher
)
{
let
mut
bf
=
BloomFilter
:
:
new
(
1000
)
;
b
.
bench_n
(
1000
|
b
|
{
let
mut
i
=
0u
;
b
.
iter
(
|
|
{
test
:
:
black_box
(
bf
.
insert
(
&
i
)
)
;
i
+
=
1
;
}
)
;
}
)
;
}
#
[
bench
]
fn
remove
(
b
:
&
mut
test
:
:
Bencher
)
{
let
mut
bf
=
BloomFilter
:
:
new
(
1000
)
;
for
i
in
range
(
0u
1000
)
{
bf
.
insert
(
&
i
)
;
}
b
.
bench_n
(
1000
|
b
|
{
let
mut
i
=
0u
;
b
.
iter
(
|
|
{
bf
.
remove
(
&
i
)
;
i
+
=
1
;
}
)
;
}
)
;
test
:
:
black_box
(
bf
.
may_include
(
&
0u
)
)
;
}
#
[
bench
]
fn
hash_a_uint
(
b
:
&
mut
test
:
:
Bencher
)
{
let
mut
i
=
0u
;
b
.
iter
(
|
|
{
test
:
:
black_box
(
hash
(
&
i
)
)
;
i
+
=
1
;
}
)
}
}
