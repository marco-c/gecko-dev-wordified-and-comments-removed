use
native
:
:
task
:
:
NativeTaskBuilder
;
use
rand
:
:
{
Rng
XorShiftRng
}
;
use
std
:
:
mem
;
use
std
:
:
rand
:
:
weak_rng
;
use
std
:
:
sync
:
:
atomics
:
:
{
AtomicUint
SeqCst
}
;
use
std
:
:
sync
:
:
deque
:
:
{
Abort
BufferPool
Data
Empty
Stealer
Worker
}
;
use
std
:
:
task
:
:
TaskBuilder
;
pub
struct
WorkUnit
<
QueueData
WorkData
>
{
pub
fun
:
extern
"
Rust
"
fn
(
WorkData
&
mut
WorkerProxy
<
QueueData
WorkData
>
)
pub
data
:
WorkData
}
enum
WorkerMsg
<
QueueData
WorkData
>
{
StartMsg
(
Worker
<
WorkUnit
<
QueueData
WorkData
>
>
*
mut
AtomicUint
*
const
QueueData
)
StopMsg
ExitMsg
}
enum
SupervisorMsg
<
QueueData
WorkData
>
{
FinishedMsg
ReturnDequeMsg
(
uint
Worker
<
WorkUnit
<
QueueData
WorkData
>
>
)
}
struct
WorkerInfo
<
QueueData
WorkData
>
{
chan
:
Sender
<
WorkerMsg
<
QueueData
WorkData
>
>
deque
:
Option
<
Worker
<
WorkUnit
<
QueueData
WorkData
>
>
>
thief
:
Stealer
<
WorkUnit
<
QueueData
WorkData
>
>
}
struct
WorkerThread
<
QueueData
WorkData
>
{
index
:
uint
port
:
Receiver
<
WorkerMsg
<
QueueData
WorkData
>
>
chan
:
Sender
<
SupervisorMsg
<
QueueData
WorkData
>
>
other_deques
:
Vec
<
Stealer
<
WorkUnit
<
QueueData
WorkData
>
>
>
rng
:
XorShiftRng
}
static
SPIN_COUNT
:
uint
=
1000
;
impl
<
QueueData
:
Send
WorkData
:
Send
>
WorkerThread
<
QueueData
WorkData
>
{
fn
start
(
&
mut
self
)
{
loop
{
let
(
mut
deque
ref_count
queue_data
)
=
match
self
.
port
.
recv
(
)
{
StartMsg
(
deque
ref_count
queue_data
)
=
>
(
deque
ref_count
queue_data
)
StopMsg
=
>
fail
!
(
"
unexpected
stop
message
"
)
ExitMsg
=
>
return
}
;
loop
{
let
mut
work_unit
=
unsafe
{
mem
:
:
uninitialized
(
)
}
;
match
deque
.
pop
(
)
{
Some
(
work
)
=
>
work_unit
=
work
None
=
>
{
let
mut
i
=
0
;
let
mut
should_continue
=
true
;
loop
{
let
victim
=
(
self
.
rng
.
next_u32
(
)
as
uint
)
%
self
.
other_deques
.
len
(
)
;
match
self
.
other_deques
.
get_mut
(
victim
)
.
steal
(
)
{
Empty
|
Abort
=
>
{
}
Data
(
work
)
=
>
{
work_unit
=
work
;
break
}
}
if
i
=
=
SPIN_COUNT
{
match
self
.
port
.
try_recv
(
)
{
Ok
(
StopMsg
)
=
>
{
should_continue
=
false
;
break
}
Ok
(
ExitMsg
)
=
>
return
Ok
(
_
)
=
>
fail
!
(
"
unexpected
message
"
)
_
=
>
{
}
}
i
=
0
}
else
{
i
+
=
1
}
}
if
!
should_continue
{
break
}
}
}
let
mut
proxy
=
WorkerProxy
{
worker
:
&
mut
deque
ref_count
:
ref_count
queue_data
:
queue_data
}
;
(
work_unit
.
fun
)
(
work_unit
.
data
&
mut
proxy
)
;
unsafe
{
if
(
*
ref_count
)
.
fetch_sub
(
1
SeqCst
)
=
=
1
{
self
.
chan
.
send
(
FinishedMsg
)
}
}
}
self
.
chan
.
send
(
ReturnDequeMsg
(
self
.
index
deque
)
)
}
}
}
pub
struct
WorkerProxy
<
'
a
QueueData
WorkData
>
{
worker
:
&
'
a
mut
Worker
<
WorkUnit
<
QueueData
WorkData
>
>
ref_count
:
*
mut
AtomicUint
queue_data
:
*
const
QueueData
}
impl
<
'
a
QueueData
WorkData
:
Send
>
WorkerProxy
<
'
a
QueueData
WorkData
>
{
#
[
inline
]
pub
fn
push
(
&
mut
self
work_unit
:
WorkUnit
<
QueueData
WorkData
>
)
{
unsafe
{
drop
(
(
*
self
.
ref_count
)
.
fetch_add
(
1
SeqCst
)
)
;
}
self
.
worker
.
push
(
work_unit
)
;
}
#
[
inline
]
pub
fn
user_data
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
QueueData
{
unsafe
{
mem
:
:
transmute
(
self
.
queue_data
)
}
}
}
pub
struct
WorkQueue
<
QueueData
WorkData
>
{
workers
:
Vec
<
WorkerInfo
<
QueueData
WorkData
>
>
port
:
Receiver
<
SupervisorMsg
<
QueueData
WorkData
>
>
work_count
:
uint
pub
data
:
QueueData
}
impl
<
QueueData
:
Send
WorkData
:
Send
>
WorkQueue
<
QueueData
WorkData
>
{
pub
fn
new
(
task_name
:
&
'
static
str
thread_count
:
uint
user_data
:
QueueData
)
-
>
WorkQueue
<
QueueData
WorkData
>
{
let
(
supervisor_chan
supervisor_port
)
=
channel
(
)
;
let
(
mut
infos
mut
threads
)
=
(
vec
!
(
)
vec
!
(
)
)
;
for
i
in
range
(
0
thread_count
)
{
let
(
worker_chan
worker_port
)
=
channel
(
)
;
let
pool
=
BufferPool
:
:
new
(
)
;
let
(
worker
thief
)
=
pool
.
deque
(
)
;
infos
.
push
(
WorkerInfo
{
chan
:
worker_chan
deque
:
Some
(
worker
)
thief
:
thief
}
)
;
threads
.
push
(
WorkerThread
{
index
:
i
port
:
worker_port
chan
:
supervisor_chan
.
clone
(
)
other_deques
:
vec
!
(
)
rng
:
weak_rng
(
)
}
)
;
}
for
i
in
range
(
0
thread_count
)
{
for
j
in
range
(
0
thread_count
)
{
if
i
!
=
j
{
threads
.
get_mut
(
i
)
.
other_deques
.
push
(
infos
[
j
]
.
thief
.
clone
(
)
)
}
}
assert
!
(
threads
.
get
(
i
)
.
other_deques
.
len
(
)
=
=
thread_count
-
1
)
}
for
thread
in
threads
.
move_iter
(
)
{
TaskBuilder
:
:
new
(
)
.
named
(
task_name
)
.
native
(
)
.
spawn
(
proc
(
)
{
let
mut
thread
=
thread
;
thread
.
start
(
)
}
)
}
WorkQueue
{
workers
:
infos
port
:
supervisor_port
work_count
:
0
data
:
user_data
}
}
/
/
/
Enqueues
a
block
into
the
work
queue
.
#
[
inline
]
pub
fn
push
(
&
mut
self
work_unit
:
WorkUnit
<
QueueData
WorkData
>
)
{
match
self
.
workers
.
get_mut
(
0
)
.
deque
{
None
=
>
{
fail
!
(
"
tried
to
push
a
block
but
we
don
'
t
have
the
deque
?
!
"
)
}
Some
(
ref
mut
deque
)
=
>
deque
.
push
(
work_unit
)
}
self
.
work_count
+
=
1
}
/
/
/
Synchronously
runs
all
the
enqueued
tasks
and
waits
for
them
to
complete
.
pub
fn
run
(
&
mut
self
)
{
/
/
Tell
the
workers
to
start
.
let
mut
work_count
=
AtomicUint
:
:
new
(
self
.
work_count
)
;
for
worker
in
self
.
workers
.
mut_iter
(
)
{
worker
.
chan
.
send
(
StartMsg
(
worker
.
deque
.
take_unwrap
(
)
&
mut
work_count
&
self
.
data
)
)
}
/
/
Wait
for
the
work
to
finish
.
drop
(
self
.
port
.
recv
(
)
)
;
self
.
work_count
=
0
;
/
/
Tell
everyone
to
stop
.
for
worker
in
self
.
workers
.
iter
(
)
{
worker
.
chan
.
send
(
StopMsg
)
}
/
/
Get
our
deques
back
.
for
_
in
range
(
0
self
.
workers
.
len
(
)
)
{
match
self
.
port
.
recv
(
)
{
ReturnDequeMsg
(
index
deque
)
=
>
self
.
workers
.
get_mut
(
index
)
.
deque
=
Some
(
deque
)
FinishedMsg
=
>
fail
!
(
"
unexpected
finished
message
!
"
)
}
}
}
pub
fn
shutdown
(
&
mut
self
)
{
for
worker
in
self
.
workers
.
iter
(
)
{
worker
.
chan
.
send
(
ExitMsg
)
}
}
}
