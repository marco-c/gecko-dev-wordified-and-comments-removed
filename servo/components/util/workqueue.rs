use
deque
:
:
{
Abort
BufferPool
Data
Empty
Stealer
Worker
}
;
use
libc
:
:
funcs
:
:
posix88
:
:
unistd
:
:
usleep
;
use
rand
:
:
{
Rng
XorShiftRng
weak_rng
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
sync
:
:
mpsc
:
:
{
Receiver
Sender
channel
}
;
use
task
:
:
spawn_named
;
use
task_state
;
pub
struct
WorkUnit
<
QueueData
WorkData
>
{
pub
fun
:
extern
"
Rust
"
fn
(
WorkData
&
mut
WorkerProxy
<
QueueData
WorkData
>
)
pub
data
:
WorkData
}
enum
WorkerMsg
<
QueueData
:
'
static
WorkData
:
'
static
>
{
Start
(
Worker
<
WorkUnit
<
QueueData
WorkData
>
>
*
mut
AtomicUsize
*
const
QueueData
)
Stop
HeapSizeOfTLS
(
fn
(
)
-
>
usize
)
Exit
}
unsafe
impl
<
QueueData
:
'
static
WorkData
:
'
static
>
Send
for
WorkerMsg
<
QueueData
WorkData
>
{
}
enum
SupervisorMsg
<
QueueData
:
'
static
WorkData
:
'
static
>
{
Finished
HeapSizeOfTLS
(
usize
)
ReturnDeque
(
usize
Worker
<
WorkUnit
<
QueueData
WorkData
>
>
)
}
unsafe
impl
<
QueueData
:
'
static
WorkData
:
'
static
>
Send
for
SupervisorMsg
<
QueueData
WorkData
>
{
}
struct
WorkerInfo
<
QueueData
:
'
static
WorkData
:
'
static
>
{
chan
:
Sender
<
WorkerMsg
<
QueueData
WorkData
>
>
deque
:
Option
<
Worker
<
WorkUnit
<
QueueData
WorkData
>
>
>
thief
:
Stealer
<
WorkUnit
<
QueueData
WorkData
>
>
}
struct
WorkerThread
<
QueueData
:
'
static
WorkData
:
'
static
>
{
index
:
usize
port
:
Receiver
<
WorkerMsg
<
QueueData
WorkData
>
>
chan
:
Sender
<
SupervisorMsg
<
QueueData
WorkData
>
>
other_deques
:
Vec
<
Stealer
<
WorkUnit
<
QueueData
WorkData
>
>
>
rng
:
XorShiftRng
}
unsafe
impl
<
QueueData
:
'
static
WorkData
:
'
static
>
Send
for
WorkerThread
<
QueueData
WorkData
>
{
}
const
SPINS_UNTIL_BACKOFF
:
u32
=
128
;
const
BACKOFF_INCREMENT_IN_US
:
u32
=
5
;
const
BACKOFFS_UNTIL_CONTROL_CHECK
:
u32
=
6
;
fn
next_power_of_two
(
mut
v
:
u32
)
-
>
u32
{
v
-
=
1
;
v
|
=
v
>
>
1
;
v
|
=
v
>
>
2
;
v
|
=
v
>
>
4
;
v
|
=
v
>
>
8
;
v
|
=
v
>
>
16
;
v
+
=
1
;
v
}
impl
<
QueueData
:
Sync
WorkData
:
Send
>
WorkerThread
<
QueueData
WorkData
>
{
fn
start
(
&
mut
self
)
{
let
deque_index_mask
=
next_power_of_two
(
self
.
other_deques
.
len
(
)
as
u32
)
-
1
;
loop
{
let
(
mut
deque
ref_count
queue_data
)
=
match
self
.
port
.
recv
(
)
.
unwrap
(
)
{
WorkerMsg
:
:
Start
(
deque
ref_count
queue_data
)
=
>
(
deque
ref_count
queue_data
)
WorkerMsg
:
:
Stop
=
>
panic
!
(
"
unexpected
stop
message
"
)
WorkerMsg
:
:
Exit
=
>
return
WorkerMsg
:
:
HeapSizeOfTLS
(
f
)
=
>
{
self
.
chan
.
send
(
SupervisorMsg
:
:
HeapSizeOfTLS
(
f
(
)
)
)
.
unwrap
(
)
;
continue
;
}
}
;
let
mut
back_off_sleep
=
0
as
u32
;
'
outer
:
loop
{
let
work_unit
;
match
deque
.
pop
(
)
{
Some
(
work
)
=
>
work_unit
=
work
None
=
>
{
let
mut
i
=
0
;
loop
{
let
mut
victim
;
loop
{
victim
=
self
.
rng
.
next_u32
(
)
&
deque_index_mask
;
if
(
victim
as
usize
)
<
self
.
other_deques
.
len
(
)
{
break
}
}
match
self
.
other_deques
[
victim
as
usize
]
.
steal
(
)
{
Empty
|
Abort
=
>
{
}
Data
(
work
)
=
>
{
work_unit
=
work
;
back_off_sleep
=
0
as
u32
;
break
}
}
if
i
>
SPINS_UNTIL_BACKOFF
{
if
back_off_sleep
>
=
BACKOFF_INCREMENT_IN_US
*
BACKOFFS_UNTIL_CONTROL_CHECK
{
match
self
.
port
.
try_recv
(
)
{
Ok
(
WorkerMsg
:
:
Stop
)
=
>
break
'
outer
Ok
(
WorkerMsg
:
:
Exit
)
=
>
return
Ok
(
_
)
=
>
panic
!
(
"
unexpected
message
"
)
_
=
>
{
}
}
}
unsafe
{
usleep
(
back_off_sleep
as
u32
)
;
}
back_off_sleep
+
=
BACKOFF_INCREMENT_IN_US
;
i
=
0
}
else
{
i
+
=
1
}
}
}
}
let
mut
proxy
=
WorkerProxy
{
worker
:
&
mut
deque
ref_count
:
ref_count
queue_data
:
unsafe
{
&
*
queue_data
}
worker_index
:
self
.
index
as
u8
}
;
(
work_unit
.
fun
)
(
work_unit
.
data
&
mut
proxy
)
;
unsafe
{
if
(
*
ref_count
)
.
fetch_sub
(
1
Ordering
:
:
Release
)
=
=
1
{
self
.
chan
.
send
(
SupervisorMsg
:
:
Finished
)
.
unwrap
(
)
}
}
}
self
.
chan
.
send
(
SupervisorMsg
:
:
ReturnDeque
(
self
.
index
deque
)
)
.
unwrap
(
)
}
}
}
pub
struct
WorkerProxy
<
'
a
QueueData
:
'
a
WorkData
:
'
a
>
{
worker
:
&
'
a
mut
Worker
<
WorkUnit
<
QueueData
WorkData
>
>
ref_count
:
*
mut
AtomicUsize
queue_data
:
&
'
a
QueueData
worker_index
:
u8
}
impl
<
'
a
QueueData
:
'
static
WorkData
:
Send
+
'
static
>
WorkerProxy
<
'
a
QueueData
WorkData
>
{
#
[
inline
]
pub
fn
push
(
&
mut
self
work_unit
:
WorkUnit
<
QueueData
WorkData
>
)
{
unsafe
{
drop
(
(
*
self
.
ref_count
)
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
)
;
}
self
.
worker
.
push
(
work_unit
)
;
}
#
[
inline
]
pub
fn
user_data
(
&
self
)
-
>
&
'
a
QueueData
{
self
.
queue_data
}
#
[
inline
]
pub
fn
worker_index
(
&
self
)
-
>
u8
{
self
.
worker_index
}
}
pub
struct
WorkQueue
<
QueueData
:
'
static
WorkData
:
'
static
>
{
workers
:
Vec
<
WorkerInfo
<
QueueData
WorkData
>
>
port
:
Receiver
<
SupervisorMsg
<
QueueData
WorkData
>
>
work_count
:
usize
}
impl
<
QueueData
:
Sync
WorkData
:
Send
>
WorkQueue
<
QueueData
WorkData
>
{
pub
fn
new
(
task_name
:
&
'
static
str
state
:
task_state
:
:
TaskState
thread_count
:
usize
)
-
>
WorkQueue
<
QueueData
WorkData
>
{
let
(
supervisor_chan
supervisor_port
)
=
channel
(
)
;
let
(
mut
infos
mut
threads
)
=
(
vec
!
(
)
vec
!
(
)
)
;
for
i
in
0
.
.
thread_count
{
let
(
worker_chan
worker_port
)
=
channel
(
)
;
let
pool
=
BufferPool
:
:
new
(
)
;
let
(
worker
thief
)
=
pool
.
deque
(
)
;
infos
.
push
(
WorkerInfo
{
chan
:
worker_chan
deque
:
Some
(
worker
)
thief
:
thief
}
)
;
threads
.
push
(
WorkerThread
{
index
:
i
port
:
worker_port
chan
:
supervisor_chan
.
clone
(
)
other_deques
:
vec
!
(
)
rng
:
weak_rng
(
)
}
)
;
}
for
(
i
mut
thread
)
in
threads
.
iter_mut
(
)
.
enumerate
(
)
{
for
(
j
info
)
in
infos
.
iter
(
)
.
enumerate
(
)
{
if
i
!
=
j
{
thread
.
other_deques
.
push
(
info
.
thief
.
clone
(
)
)
}
}
assert
!
(
thread
.
other_deques
.
len
(
)
=
=
thread_count
-
1
)
}
for
(
i
thread
)
in
threads
.
into_iter
(
)
.
enumerate
(
)
{
spawn_named
(
format
!
(
"
{
}
worker
{
}
/
{
}
"
task_name
i
+
1
thread_count
)
move
|
|
{
task_state
:
:
initialize
(
state
|
task_state
:
:
IN_WORKER
)
;
let
mut
thread
=
thread
;
thread
.
start
(
)
}
)
}
WorkQueue
{
workers
:
infos
port
:
supervisor_port
work_count
:
0
}
}
#
[
inline
]
pub
fn
push
(
&
mut
self
work_unit
:
WorkUnit
<
QueueData
WorkData
>
)
{
let
deque
=
&
mut
self
.
workers
[
0
]
.
deque
;
match
*
deque
{
None
=
>
{
panic
!
(
"
tried
to
push
a
block
but
we
don
'
t
have
the
deque
?
!
"
)
}
Some
(
ref
mut
deque
)
=
>
deque
.
push
(
work_unit
)
}
self
.
work_count
+
=
1
}
pub
fn
run
(
&
mut
self
data
:
&
QueueData
)
{
let
mut
work_count
=
AtomicUsize
:
:
new
(
self
.
work_count
)
;
for
worker
in
&
mut
self
.
workers
{
worker
.
chan
.
send
(
WorkerMsg
:
:
Start
(
worker
.
deque
.
take
(
)
.
unwrap
(
)
&
mut
work_count
data
)
)
.
unwrap
(
)
}
drop
(
self
.
port
.
recv
(
)
)
;
self
.
work_count
=
0
;
for
worker
in
&
self
.
workers
{
worker
.
chan
.
send
(
WorkerMsg
:
:
Stop
)
.
unwrap
(
)
}
for
_
in
0
.
.
self
.
workers
.
len
(
)
{
match
self
.
port
.
recv
(
)
.
unwrap
(
)
{
SupervisorMsg
:
:
ReturnDeque
(
index
deque
)
=
>
self
.
workers
[
index
]
.
deque
=
Some
(
deque
)
SupervisorMsg
:
:
HeapSizeOfTLS
(
_
)
=
>
panic
!
(
"
unexpected
HeapSizeOfTLS
message
"
)
SupervisorMsg
:
:
Finished
=
>
panic
!
(
"
unexpected
finished
message
!
"
)
}
}
}
pub
fn
heap_size_of_tls
(
&
self
f
:
fn
(
)
-
>
usize
)
-
>
Vec
<
usize
>
{
for
worker
in
&
self
.
workers
{
worker
.
chan
.
send
(
WorkerMsg
:
:
HeapSizeOfTLS
(
f
)
)
.
unwrap
(
)
}
let
mut
sizes
=
vec
!
[
]
;
for
_
in
0
.
.
self
.
workers
.
len
(
)
{
match
self
.
port
.
recv
(
)
.
unwrap
(
)
{
SupervisorMsg
:
:
HeapSizeOfTLS
(
size
)
=
>
{
sizes
.
push
(
size
)
;
}
_
=
>
panic
!
(
"
unexpected
message
!
"
)
}
}
sizes
}
pub
fn
shutdown
(
&
mut
self
)
{
for
worker
in
&
self
.
workers
{
worker
.
chan
.
send
(
WorkerMsg
:
:
Exit
)
.
unwrap
(
)
}
}
}
