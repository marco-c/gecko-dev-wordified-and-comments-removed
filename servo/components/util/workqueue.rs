use
task
:
:
spawn_named
;
use
task_state
;
use
libc
:
:
funcs
:
:
posix88
:
:
unistd
:
:
usleep
;
use
rand
:
:
{
Rng
XorShiftRng
}
;
use
std
:
:
mem
;
use
std
:
:
rand
:
:
weak_rng
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUint
Ordering
}
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Sender
Receiver
}
;
use
deque
:
:
{
Abort
BufferPool
Data
Empty
Stealer
Worker
}
;
pub
struct
WorkUnit
<
QueueData
WorkData
>
{
pub
fun
:
extern
"
Rust
"
fn
(
WorkData
&
mut
WorkerProxy
<
QueueData
WorkData
>
)
pub
data
:
WorkData
}
enum
WorkerMsg
<
QueueData
:
'
static
WorkData
:
'
static
>
{
Start
(
Worker
<
WorkUnit
<
QueueData
WorkData
>
>
*
mut
AtomicUint
*
const
QueueData
)
Stop
Exit
}
unsafe
impl
<
QueueData
:
'
static
WorkData
:
'
static
>
Send
for
WorkerMsg
<
QueueData
WorkData
>
{
}
enum
SupervisorMsg
<
QueueData
:
'
static
WorkData
:
'
static
>
{
Finished
ReturnDeque
(
uint
Worker
<
WorkUnit
<
QueueData
WorkData
>
>
)
}
unsafe
impl
<
QueueData
:
'
static
WorkData
:
'
static
>
Send
for
SupervisorMsg
<
QueueData
WorkData
>
{
}
struct
WorkerInfo
<
QueueData
:
'
static
WorkData
:
'
static
>
{
chan
:
Sender
<
WorkerMsg
<
QueueData
WorkData
>
>
deque
:
Option
<
Worker
<
WorkUnit
<
QueueData
WorkData
>
>
>
thief
:
Stealer
<
WorkUnit
<
QueueData
WorkData
>
>
}
struct
WorkerThread
<
QueueData
:
'
static
WorkData
:
'
static
>
{
index
:
uint
port
:
Receiver
<
WorkerMsg
<
QueueData
WorkData
>
>
chan
:
Sender
<
SupervisorMsg
<
QueueData
WorkData
>
>
other_deques
:
Vec
<
Stealer
<
WorkUnit
<
QueueData
WorkData
>
>
>
rng
:
XorShiftRng
}
unsafe
impl
<
QueueData
:
'
static
WorkData
:
'
static
>
Send
for
WorkerThread
<
QueueData
WorkData
>
{
}
static
SPIN_COUNT
:
u32
=
128
;
static
SPINS_UNTIL_BACKOFF
:
u32
=
100
;
static
BACKOFF_INCREMENT_IN_US
:
u32
=
5
;
impl
<
QueueData
:
Send
WorkData
:
Send
>
WorkerThread
<
QueueData
WorkData
>
{
fn
start
(
&
mut
self
)
{
loop
{
let
(
mut
deque
ref_count
queue_data
)
=
match
self
.
port
.
recv
(
)
.
unwrap
(
)
{
WorkerMsg
:
:
Start
(
deque
ref_count
queue_data
)
=
>
(
deque
ref_count
queue_data
)
WorkerMsg
:
:
Stop
=
>
panic
!
(
"
unexpected
stop
message
"
)
WorkerMsg
:
:
Exit
=
>
return
}
;
let
mut
back_off_sleep
=
0
as
u32
;
loop
{
let
mut
work_unit
=
unsafe
{
mem
:
:
uninitialized
(
)
}
;
match
deque
.
pop
(
)
{
Some
(
work
)
=
>
work_unit
=
work
None
=
>
{
let
mut
i
=
0
;
let
mut
should_continue
=
true
;
loop
{
let
victim
=
(
self
.
rng
.
next_u32
(
)
as
uint
)
%
self
.
other_deques
.
len
(
)
;
match
self
.
other_deques
[
victim
]
.
steal
(
)
{
Empty
|
Abort
=
>
{
}
Data
(
work
)
=
>
{
work_unit
=
work
;
back_off_sleep
=
0
as
u32
;
break
}
}
if
i
>
SPINS_UNTIL_BACKOFF
{
unsafe
{
usleep
(
back_off_sleep
as
u32
)
;
}
back_off_sleep
+
=
BACKOFF_INCREMENT_IN_US
;
}
if
i
=
=
SPIN_COUNT
{
match
self
.
port
.
try_recv
(
)
{
Ok
(
WorkerMsg
:
:
Stop
)
=
>
{
should_continue
=
false
;
break
}
Ok
(
WorkerMsg
:
:
Exit
)
=
>
return
Ok
(
_
)
=
>
panic
!
(
"
unexpected
message
"
)
_
=
>
{
}
}
i
=
0
}
else
{
i
+
=
1
}
}
if
!
should_continue
{
break
}
}
}
let
mut
proxy
=
WorkerProxy
{
worker
:
&
mut
deque
ref_count
:
ref_count
queue_data
:
queue_data
}
;
(
work_unit
.
fun
)
(
work_unit
.
data
&
mut
proxy
)
;
unsafe
{
if
(
*
ref_count
)
.
fetch_sub
(
1
Ordering
:
:
SeqCst
)
=
=
1
{
self
.
chan
.
send
(
SupervisorMsg
:
:
Finished
)
.
unwrap
(
)
}
}
}
self
.
chan
.
send
(
SupervisorMsg
:
:
ReturnDeque
(
self
.
index
deque
)
)
.
unwrap
(
)
}
}
}
pub
struct
WorkerProxy
<
'
a
QueueData
:
'
a
WorkData
:
'
a
>
{
worker
:
&
'
a
mut
Worker
<
WorkUnit
<
QueueData
WorkData
>
>
ref_count
:
*
mut
AtomicUint
queue_data
:
*
const
QueueData
}
impl
<
'
a
QueueData
:
'
static
WorkData
:
Send
>
WorkerProxy
<
'
a
QueueData
WorkData
>
{
#
[
inline
]
pub
fn
push
(
&
mut
self
work_unit
:
WorkUnit
<
QueueData
WorkData
>
)
{
unsafe
{
drop
(
(
*
self
.
ref_count
)
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
)
;
}
self
.
worker
.
push
(
work_unit
)
;
}
#
[
inline
]
pub
fn
user_data
<
'
b
>
(
&
'
b
self
)
-
>
&
'
b
QueueData
{
unsafe
{
mem
:
:
transmute
(
self
.
queue_data
)
}
}
}
pub
struct
WorkQueue
<
QueueData
:
'
static
WorkData
:
'
static
>
{
workers
:
Vec
<
WorkerInfo
<
QueueData
WorkData
>
>
port
:
Receiver
<
SupervisorMsg
<
QueueData
WorkData
>
>
work_count
:
uint
pub
data
:
QueueData
}
impl
<
QueueData
:
Send
WorkData
:
Send
>
WorkQueue
<
QueueData
WorkData
>
{
pub
fn
new
(
task_name
:
&
'
static
str
state
:
task_state
:
:
TaskState
thread_count
:
uint
user_data
:
QueueData
)
-
>
WorkQueue
<
QueueData
WorkData
>
{
let
(
supervisor_chan
supervisor_port
)
=
channel
(
)
;
let
(
mut
infos
mut
threads
)
=
(
vec
!
(
)
vec
!
(
)
)
;
for
i
in
range
(
0
thread_count
)
{
let
(
worker_chan
worker_port
)
=
channel
(
)
;
let
pool
=
BufferPool
:
:
new
(
)
;
let
(
worker
thief
)
=
pool
.
deque
(
)
;
infos
.
push
(
WorkerInfo
{
chan
:
worker_chan
deque
:
Some
(
worker
)
thief
:
thief
}
)
;
threads
.
push
(
WorkerThread
{
index
:
i
port
:
worker_port
chan
:
supervisor_chan
.
clone
(
)
other_deques
:
vec
!
(
)
rng
:
weak_rng
(
)
}
)
;
}
for
i
in
range
(
0
thread_count
)
{
for
j
in
range
(
0
thread_count
)
{
if
i
!
=
j
{
threads
[
i
]
.
other_deques
.
push
(
infos
[
j
]
.
thief
.
clone
(
)
)
}
}
assert
!
(
threads
[
i
]
.
other_deques
.
len
(
)
=
=
thread_count
-
1
)
}
for
(
i
thread
)
in
threads
.
into_iter
(
)
.
enumerate
(
)
{
spawn_named
(
format
!
(
"
{
}
worker
{
}
/
{
}
"
task_name
i
+
1
thread_count
)
move
|
|
{
task_state
:
:
initialize
(
state
|
task_state
:
:
IN_WORKER
)
;
let
mut
thread
=
thread
;
thread
.
start
(
)
}
)
}
WorkQueue
{
workers
:
infos
port
:
supervisor_port
work_count
:
0
data
:
user_data
}
}
#
[
inline
]
pub
fn
push
(
&
mut
self
work_unit
:
WorkUnit
<
QueueData
WorkData
>
)
{
let
deque
=
&
mut
self
.
workers
[
0
]
.
deque
;
match
*
deque
{
None
=
>
{
panic
!
(
"
tried
to
push
a
block
but
we
don
'
t
have
the
deque
?
!
"
)
}
Some
(
ref
mut
deque
)
=
>
deque
.
push
(
work_unit
)
}
self
.
work_count
+
=
1
}
pub
fn
run
(
&
mut
self
)
{
let
mut
work_count
=
AtomicUint
:
:
new
(
self
.
work_count
)
;
for
worker
in
self
.
workers
.
iter_mut
(
)
{
worker
.
chan
.
send
(
WorkerMsg
:
:
Start
(
worker
.
deque
.
take
(
)
.
unwrap
(
)
&
mut
work_count
&
self
.
data
)
)
.
unwrap
(
)
}
drop
(
self
.
port
.
recv
(
)
)
;
self
.
work_count
=
0
;
for
worker
in
self
.
workers
.
iter
(
)
{
worker
.
chan
.
send
(
WorkerMsg
:
:
Stop
)
.
unwrap
(
)
}
for
_
in
range
(
0
self
.
workers
.
len
(
)
)
{
match
self
.
port
.
recv
(
)
.
unwrap
(
)
{
SupervisorMsg
:
:
ReturnDeque
(
index
deque
)
=
>
self
.
workers
[
index
]
.
deque
=
Some
(
deque
)
SupervisorMsg
:
:
Finished
=
>
panic
!
(
"
unexpected
finished
message
!
"
)
}
}
}
pub
fn
shutdown
(
&
mut
self
)
{
for
worker
in
self
.
workers
.
iter
(
)
{
worker
.
chan
.
send
(
WorkerMsg
:
:
Exit
)
.
unwrap
(
)
}
}
}
