use
libc
:
:
{
c_void
size_t
}
;
use
std
:
:
cell
:
:
{
Cell
RefCell
}
;
use
std
:
:
collections
:
:
{
HashMap
LinkedList
hash_state
}
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
mem
:
:
{
size_of
transmute
}
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
rc
:
:
Rc
;
use
azure
:
:
azure_hl
:
:
Color
;
use
cssparser
:
:
Color
as
CSSParserColor
;
use
cssparser
:
:
RGBA
;
use
cursor
:
:
Cursor
;
use
euclid
:
:
{
Point2D
Rect
SideOffsets2D
Size2D
Matrix2D
Matrix4
}
;
use
euclid
:
:
length
:
:
Length
;
use
euclid
:
:
scale_factor
:
:
ScaleFactor
;
use
geometry
:
:
{
PagePx
ViewportPx
Au
}
;
use
html5ever
:
:
tree_builder
:
:
QuirksMode
;
use
layers
:
:
geometry
:
:
DevicePixel
;
use
js
:
:
jsapi
:
:
Heap
;
use
js
:
:
rust
:
:
GCMethods
;
use
js
:
:
jsval
:
:
JSVal
;
use
logical_geometry
:
:
WritingMode
;
use
range
:
:
Range
;
use
string_cache
:
:
atom
:
:
Atom
;
use
url
;
extern
{
fn
je_malloc_usable_size
(
ptr
:
*
const
c_void
)
-
>
size_t
;
}
pub
fn
heap_size_of
(
ptr
:
*
const
c_void
)
-
>
usize
{
if
ptr
=
=
:
:
std
:
:
rt
:
:
heap
:
:
EMPTY
as
*
const
c_void
{
0
}
else
{
unsafe
{
je_malloc_usable_size
(
ptr
)
as
usize
}
}
}
pub
trait
HeapSizeOf
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
;
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Box
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
heap_size_of
(
&
*
*
self
as
*
const
T
as
*
const
c_void
)
+
(
*
*
self
)
.
heap_size_of_children
(
)
}
}
impl
HeapSizeOf
for
String
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
heap_size_of
(
self
.
as_ptr
(
)
as
*
const
c_void
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Option
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
match
*
self
{
None
=
>
0
Some
(
ref
x
)
=
>
x
.
heap_size_of_children
(
)
}
}
}
impl
HeapSizeOf
for
url
:
:
Url
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
let
&
url
:
:
Url
{
ref
scheme
ref
scheme_data
ref
query
ref
fragment
}
=
self
;
scheme
.
heap_size_of_children
(
)
+
scheme_data
.
heap_size_of_children
(
)
+
query
.
heap_size_of_children
(
)
+
fragment
.
heap_size_of_children
(
)
}
}
impl
HeapSizeOf
for
url
:
:
SchemeData
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
match
self
{
&
url
:
:
SchemeData
:
:
Relative
(
ref
data
)
=
>
data
.
heap_size_of_children
(
)
&
url
:
:
SchemeData
:
:
NonRelative
(
ref
str
)
=
>
str
.
heap_size_of_children
(
)
}
}
}
impl
HeapSizeOf
for
url
:
:
RelativeSchemeData
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
let
&
url
:
:
RelativeSchemeData
{
ref
username
ref
password
ref
host
ref
port
ref
default_port
ref
path
}
=
self
;
username
.
heap_size_of_children
(
)
+
password
.
heap_size_of_children
(
)
+
host
.
heap_size_of_children
(
)
+
port
.
heap_size_of_children
(
)
+
default_port
.
heap_size_of_children
(
)
+
path
.
heap_size_of_children
(
)
}
}
impl
HeapSizeOf
for
url
:
:
Host
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
match
self
{
&
url
:
:
Host
:
:
Domain
(
ref
str
)
=
>
str
.
heap_size_of_children
(
)
&
url
:
:
Host
:
:
Ipv6
(
_
)
=
>
0
}
}
}
impl
<
T
:
HeapSizeOf
U
:
HeapSizeOf
>
HeapSizeOf
for
(
T
U
)
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
self
.
0
.
heap_size_of_children
(
)
+
self
.
1
.
heap_size_of_children
(
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Arc
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
(
*
*
self
)
.
heap_size_of_children
(
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
RefCell
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
self
.
borrow
(
)
.
heap_size_of_children
(
)
}
}
impl
<
T
:
HeapSizeOf
+
Copy
>
HeapSizeOf
for
Cell
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
self
.
get
(
)
.
heap_size_of_children
(
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Vec
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
heap_size_of
(
self
.
as_ptr
(
)
as
*
const
c_void
)
+
self
.
iter
(
)
.
fold
(
0
|
n
elem
|
n
+
elem
.
heap_size_of_children
(
)
)
}
}
impl
<
T
>
HeapSizeOf
for
Vec
<
Rc
<
T
>
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
heap_size_of
(
self
.
as_ptr
(
)
as
*
const
c_void
)
}
}
impl
<
K
:
HeapSizeOf
V
:
HeapSizeOf
S
>
HeapSizeOf
for
HashMap
<
K
V
S
>
where
K
:
Eq
+
Hash
S
:
hash_state
:
:
HashState
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
let
size
=
self
.
capacity
(
)
*
(
size_of
:
:
<
V
>
(
)
+
size_of
:
:
<
K
>
(
)
)
;
self
.
iter
(
)
.
fold
(
size
|
n
(
key
value
)
|
{
n
+
key
.
heap_size_of_children
(
)
+
value
.
heap_size_of_children
(
)
}
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
LinkedList
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
let
list2
:
&
LinkedList2
<
T
>
=
unsafe
{
transmute
(
self
)
}
;
list2
.
heap_size_of_children
(
)
}
}
struct
LinkedList2
<
T
>
{
_length
:
usize
list_head
:
Link
<
T
>
_list_tail
:
Rawlink
<
Node
<
T
>
>
}
type
Link
<
T
>
=
Option
<
Box
<
Node
<
T
>
>
>
;
struct
Rawlink
<
T
>
{
_p
:
*
mut
T
}
struct
Node
<
T
>
{
next
:
Link
<
T
>
_prev
:
Rawlink
<
Node
<
T
>
>
value
:
T
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Node
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
self
.
value
.
heap_size_of_children
(
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
LinkedList2
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
let
mut
size
=
0
;
let
mut
curr
:
&
Link
<
T
>
=
&
self
.
list_head
;
while
curr
.
is_some
(
)
{
size
+
=
(
*
curr
)
.
heap_size_of_children
(
)
;
curr
=
&
curr
.
as_ref
(
)
.
unwrap
(
)
.
next
;
}
size
}
}
#
[
allow
(
dead_code
)
]
unsafe
fn
linked_list2_check
(
)
{
transmute
:
:
<
LinkedList
<
i32
>
LinkedList2
<
i32
>
>
(
panic
!
(
)
)
;
}
impl
<
T
>
Drop
for
LinkedList2
<
T
>
{
fn
drop
(
&
mut
self
)
{
}
}
#
[
macro_export
]
macro_rules
!
known_heap_size
(
(
size
:
expr
(
ty
:
ident
)
+
)
=
>
(
(
impl
crate
:
:
mem
:
:
HeapSizeOf
for
ty
{
#
[
inline
(
always
)
]
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
size
}
}
)
+
)
;
(
size
:
expr
(
ty
:
ident
<
(
gen
:
ident
)
+
>
)
+
)
=
>
(
(
impl
<
(
gen
:
crate
:
:
mem
:
:
HeapSizeOf
)
+
>
crate
:
:
mem
:
:
HeapSizeOf
for
ty
<
(
gen
)
+
>
{
#
[
inline
(
always
)
]
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
size
}
}
)
+
)
;
)
;
known_heap_size
!
(
0
u8
u16
u32
u64
usize
)
;
known_heap_size
!
(
0
i8
i16
i32
i64
isize
)
;
known_heap_size
!
(
0
bool
f32
f64
)
;
known_heap_size
!
(
0
Rect
<
T
>
Point2D
<
T
>
Size2D
<
T
>
Matrix2D
<
T
>
SideOffsets2D
<
T
>
Range
<
T
>
)
;
known_heap_size
!
(
0
Length
<
T
U
>
ScaleFactor
<
T
U
V
>
)
;
known_heap_size
!
(
0
Au
WritingMode
CSSParserColor
Color
RGBA
Cursor
Matrix4
Atom
)
;
known_heap_size
!
(
0
JSVal
PagePx
ViewportPx
DevicePixel
QuirksMode
)
;
impl
<
T
:
Copy
+
GCMethods
<
T
>
>
HeapSizeOf
for
Heap
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
