use
libc
:
:
{
c_void
size_t
}
;
use
std
:
:
collections
:
:
LinkedList
;
use
std
:
:
mem
:
:
transmute
;
use
std
:
:
sync
:
:
Arc
;
extern
{
fn
je_malloc_usable_size
(
ptr
:
*
const
c_void
)
-
>
size_t
;
}
pub
fn
heap_size_of
(
ptr
:
*
const
c_void
)
-
>
usize
{
if
ptr
=
=
:
:
std
:
:
rt
:
:
heap
:
:
EMPTY
as
*
const
c_void
{
0
}
else
{
unsafe
{
je_malloc_usable_size
(
ptr
)
as
usize
}
}
}
pub
trait
HeapSizeOf
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
;
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Box
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
heap_size_of
(
&
*
*
self
as
*
const
T
as
*
const
c_void
)
+
(
*
*
self
)
.
heap_size_of_children
(
)
}
}
impl
HeapSizeOf
for
String
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
heap_size_of
(
self
.
as_ptr
(
)
as
*
const
c_void
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Option
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
match
*
self
{
None
=
>
0
Some
(
ref
x
)
=
>
x
.
heap_size_of_children
(
)
}
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Arc
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
(
*
*
self
)
.
heap_size_of_children
(
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Vec
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
heap_size_of
(
self
.
as_ptr
(
)
as
*
const
c_void
)
+
self
.
iter
(
)
.
fold
(
0
|
n
elem
|
n
+
elem
.
heap_size_of_children
(
)
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
LinkedList
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
let
list2
:
&
LinkedList2
<
T
>
=
unsafe
{
transmute
(
self
)
}
;
list2
.
heap_size_of_children
(
)
}
}
struct
LinkedList2
<
T
>
{
_length
:
usize
list_head
:
Link
<
T
>
_list_tail
:
Rawlink
<
Node
<
T
>
>
}
type
Link
<
T
>
=
Option
<
Box
<
Node
<
T
>
>
>
;
struct
Rawlink
<
T
>
{
_p
:
*
mut
T
}
struct
Node
<
T
>
{
next
:
Link
<
T
>
_prev
:
Rawlink
<
Node
<
T
>
>
value
:
T
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Node
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
self
.
value
.
heap_size_of_children
(
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
LinkedList2
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
let
mut
size
=
0
;
let
mut
curr
:
&
Link
<
T
>
=
&
self
.
list_head
;
while
curr
.
is_some
(
)
{
size
+
=
(
*
curr
)
.
heap_size_of_children
(
)
;
curr
=
&
curr
.
as_ref
(
)
.
unwrap
(
)
.
next
;
}
size
}
}
#
[
allow
(
dead_code
)
]
unsafe
fn
linked_list2_check
(
)
{
transmute
:
:
<
LinkedList
<
i32
>
LinkedList2
<
i32
>
>
(
panic
!
(
)
)
;
}
#
[
unsafe_destructor
]
impl
<
T
>
Drop
for
LinkedList2
<
T
>
{
fn
drop
(
&
mut
self
)
{
}
}
