use
libc
:
:
{
c_void
size_t
}
;
use
std
:
:
collections
:
:
LinkedList
;
use
std
:
:
mem
:
:
transmute
;
use
std
:
:
sync
:
:
Arc
;
use
azure
:
:
azure_hl
:
:
Color
;
use
cursor
:
:
Cursor
;
use
geom
:
:
{
Point2D
Rect
SideOffsets2D
Size2D
Matrix2D
Matrix4
}
;
use
geometry
:
:
Au
;
use
range
:
:
Range
;
extern
{
fn
je_malloc_usable_size
(
ptr
:
*
const
c_void
)
-
>
size_t
;
}
pub
fn
heap_size_of
(
ptr
:
*
const
c_void
)
-
>
usize
{
if
ptr
=
=
:
:
std
:
:
rt
:
:
heap
:
:
EMPTY
as
*
const
c_void
{
0
}
else
{
unsafe
{
je_malloc_usable_size
(
ptr
)
as
usize
}
}
}
pub
trait
HeapSizeOf
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
;
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Box
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
heap_size_of
(
&
*
*
self
as
*
const
T
as
*
const
c_void
)
+
(
*
*
self
)
.
heap_size_of_children
(
)
}
}
impl
HeapSizeOf
for
String
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
heap_size_of
(
self
.
as_ptr
(
)
as
*
const
c_void
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Option
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
match
*
self
{
None
=
>
0
Some
(
ref
x
)
=
>
x
.
heap_size_of_children
(
)
}
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Arc
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
(
*
*
self
)
.
heap_size_of_children
(
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Vec
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
heap_size_of
(
self
.
as_ptr
(
)
as
*
const
c_void
)
+
self
.
iter
(
)
.
fold
(
0
|
n
elem
|
n
+
elem
.
heap_size_of_children
(
)
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
LinkedList
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
let
list2
:
&
LinkedList2
<
T
>
=
unsafe
{
transmute
(
self
)
}
;
list2
.
heap_size_of_children
(
)
}
}
struct
LinkedList2
<
T
>
{
_length
:
usize
list_head
:
Link
<
T
>
_list_tail
:
Rawlink
<
Node
<
T
>
>
}
type
Link
<
T
>
=
Option
<
Box
<
Node
<
T
>
>
>
;
struct
Rawlink
<
T
>
{
_p
:
*
mut
T
}
struct
Node
<
T
>
{
next
:
Link
<
T
>
_prev
:
Rawlink
<
Node
<
T
>
>
value
:
T
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
Node
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
self
.
value
.
heap_size_of_children
(
)
}
}
impl
<
T
:
HeapSizeOf
>
HeapSizeOf
for
LinkedList2
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
let
mut
size
=
0
;
let
mut
curr
:
&
Link
<
T
>
=
&
self
.
list_head
;
while
curr
.
is_some
(
)
{
size
+
=
(
*
curr
)
.
heap_size_of_children
(
)
;
curr
=
&
curr
.
as_ref
(
)
.
unwrap
(
)
.
next
;
}
size
}
}
#
[
allow
(
dead_code
)
]
unsafe
fn
linked_list2_check
(
)
{
transmute
:
:
<
LinkedList
<
i32
>
LinkedList2
<
i32
>
>
(
panic
!
(
)
)
;
}
impl
<
T
>
Drop
for
LinkedList2
<
T
>
{
fn
drop
(
&
mut
self
)
{
}
}
#
[
macro_export
]
macro_rules
!
known_heap_size
(
(
size
:
expr
(
ty
:
ident
)
+
)
=
>
(
(
impl
crate
:
:
mem
:
:
HeapSizeOf
for
ty
{
#
[
inline
(
always
)
]
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
size
}
}
)
+
)
;
(
size
:
expr
(
ty
:
ident
<
(
gen
:
ident
)
+
>
)
+
)
=
>
(
(
impl
<
(
gen
:
crate
:
:
mem
:
:
HeapSizeOf
)
+
>
crate
:
:
mem
:
:
HeapSizeOf
for
ty
<
(
gen
)
+
>
{
#
[
inline
(
always
)
]
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
size
}
}
)
+
)
;
)
;
known_heap_size
!
(
0
u8
u16
u32
u64
usize
)
;
known_heap_size
!
(
0
i8
i16
i32
i64
isize
)
;
known_heap_size
!
(
0
bool
f32
f64
)
;
known_heap_size
!
(
0
Rect
<
T
>
Point2D
<
T
>
Size2D
<
T
>
Matrix2D
<
T
>
SideOffsets2D
<
T
>
Matrix4
<
T
>
)
;
known_heap_size
!
(
0
Au
Color
Cursor
)
;
known_heap_size
!
(
0
Range
<
T
>
)
;
