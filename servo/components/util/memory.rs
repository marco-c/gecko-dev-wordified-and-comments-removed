use
libc
:
:
{
c_char
c_int
c_void
size_t
}
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
collections
:
:
LinkedList
;
use
std
:
:
ffi
:
:
CString
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
use
std
:
:
iter
:
:
AdditiveIterator
;
use
std
:
:
old_io
:
:
timer
:
:
sleep
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
use
std
:
:
old_io
:
:
File
;
use
std
:
:
mem
:
:
{
size_of
transmute
}
;
use
std
:
:
ptr
:
:
null_mut
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
mpsc
:
:
{
Sender
channel
Receiver
}
;
use
std
:
:
time
:
:
duration
:
:
Duration
;
use
task
:
:
spawn_named
;
#
[
cfg
(
target_os
=
"
macos
"
)
]
use
task_info
:
:
task_basic_info
:
:
{
virtual_size
resident_size
}
;
extern
{
fn
je_malloc_usable_size
(
ptr
:
*
const
c_void
)
-
>
size_t
;
}
pub
fn
heap_size_of
(
ptr
:
*
const
c_void
)
-
>
usize
{
if
ptr
=
=
:
:
std
:
:
rt
:
:
heap
:
:
EMPTY
as
*
const
c_void
{
0
}
else
{
unsafe
{
je_malloc_usable_size
(
ptr
)
as
usize
}
}
}
pub
trait
SizeOf
{
fn
size_of_excluding_self
(
&
self
)
-
>
usize
;
}
impl
<
T
:
SizeOf
>
SizeOf
for
Box
<
T
>
{
fn
size_of_excluding_self
(
&
self
)
-
>
usize
{
heap_size_of
(
&
*
*
self
as
*
const
T
as
*
const
c_void
)
+
(
*
*
self
)
.
size_of_excluding_self
(
)
}
}
impl
SizeOf
for
String
{
fn
size_of_excluding_self
(
&
self
)
-
>
usize
{
heap_size_of
(
self
.
as_ptr
(
)
as
*
const
c_void
)
}
}
impl
<
T
:
SizeOf
>
SizeOf
for
Option
<
T
>
{
fn
size_of_excluding_self
(
&
self
)
-
>
usize
{
match
*
self
{
None
=
>
0
Some
(
ref
x
)
=
>
x
.
size_of_excluding_self
(
)
}
}
}
impl
<
T
:
SizeOf
>
SizeOf
for
Arc
<
T
>
{
fn
size_of_excluding_self
(
&
self
)
-
>
usize
{
(
*
*
self
)
.
size_of_excluding_self
(
)
}
}
impl
<
T
:
SizeOf
>
SizeOf
for
Vec
<
T
>
{
fn
size_of_excluding_self
(
&
self
)
-
>
usize
{
heap_size_of
(
self
.
as_ptr
(
)
as
*
const
c_void
)
+
self
.
iter
(
)
.
fold
(
0
|
n
elem
|
n
+
elem
.
size_of_excluding_self
(
)
)
}
}
impl
<
T
:
SizeOf
>
SizeOf
for
LinkedList
<
T
>
{
fn
size_of_excluding_self
(
&
self
)
-
>
usize
{
let
list2
:
&
LinkedList2
<
T
>
=
unsafe
{
transmute
(
self
)
}
;
list2
.
size_of_excluding_self
(
)
}
}
struct
LinkedList2
<
T
>
{
_length
:
usize
list_head
:
Link
<
T
>
_list_tail
:
Rawlink
<
Node
<
T
>
>
}
type
Link
<
T
>
=
Option
<
Box
<
Node
<
T
>
>
>
;
struct
Rawlink
<
T
>
{
_p
:
*
mut
T
}
struct
Node
<
T
>
{
next
:
Link
<
T
>
_prev
:
Rawlink
<
Node
<
T
>
>
value
:
T
}
impl
<
T
:
SizeOf
>
SizeOf
for
Node
<
T
>
{
fn
size_of_excluding_self
(
&
self
)
-
>
usize
{
self
.
value
.
size_of_excluding_self
(
)
}
}
impl
<
T
:
SizeOf
>
SizeOf
for
LinkedList2
<
T
>
{
fn
size_of_excluding_self
(
&
self
)
-
>
usize
{
let
mut
size
=
0
;
let
mut
curr
:
&
Link
<
T
>
=
&
self
.
list_head
;
while
curr
.
is_some
(
)
{
size
+
=
(
*
curr
)
.
size_of_excluding_self
(
)
;
curr
=
&
curr
.
as_ref
(
)
.
unwrap
(
)
.
next
;
}
size
}
}
#
[
allow
(
dead_code
)
]
unsafe
fn
linked_list2_check
(
)
{
transmute
:
:
<
LinkedList
<
i32
>
LinkedList2
<
i32
>
>
(
panic
!
(
)
)
;
}
#
[
unsafe_destructor
]
impl
<
T
>
Drop
for
LinkedList2
<
T
>
{
fn
drop
(
&
mut
self
)
{
}
}
#
[
derive
(
Clone
)
]
pub
struct
MemoryProfilerChan
(
pub
Sender
<
MemoryProfilerMsg
>
)
;
impl
MemoryProfilerChan
{
pub
fn
send
(
&
self
msg
:
MemoryProfilerMsg
)
{
let
MemoryProfilerChan
(
ref
c
)
=
*
self
;
c
.
send
(
msg
)
.
unwrap
(
)
;
}
}
pub
struct
MemoryReport
{
pub
name
:
String
pub
size
:
u64
}
#
[
derive
(
Clone
)
]
pub
struct
MemoryReportsChan
(
pub
Sender
<
Vec
<
MemoryReport
>
>
)
;
impl
MemoryReportsChan
{
pub
fn
send
(
&
self
report
:
Vec
<
MemoryReport
>
)
{
let
MemoryReportsChan
(
ref
c
)
=
*
self
;
c
.
send
(
report
)
.
unwrap
(
)
;
}
}
pub
trait
MemoryReporter
{
fn
collect_reports
(
&
self
reports_chan
:
MemoryReportsChan
)
-
>
bool
;
}
pub
enum
MemoryProfilerMsg
{
RegisterMemoryReporter
(
String
Box
<
MemoryReporter
+
Send
>
)
UnregisterMemoryReporter
(
String
)
Print
Exit
}
pub
struct
MemoryProfiler
{
pub
port
:
Receiver
<
MemoryProfilerMsg
>
reporters
:
HashMap
<
String
Box
<
MemoryReporter
+
Send
>
>
}
impl
MemoryProfiler
{
pub
fn
create
(
period
:
Option
<
f64
>
)
-
>
MemoryProfilerChan
{
let
(
chan
port
)
=
channel
(
)
;
if
let
Some
(
period
)
=
period
{
let
period_ms
=
Duration
:
:
milliseconds
(
(
period
*
1000f64
)
as
i64
)
;
let
chan
=
chan
.
clone
(
)
;
spawn_named
(
"
Memory
profiler
timer
"
.
to_owned
(
)
move
|
|
{
loop
{
sleep
(
period_ms
)
;
if
chan
.
send
(
MemoryProfilerMsg
:
:
Print
)
.
is_err
(
)
{
break
;
}
}
}
)
;
}
spawn_named
(
"
Memory
profiler
"
.
to_owned
(
)
move
|
|
{
let
mut
memory_profiler
=
MemoryProfiler
:
:
new
(
port
)
;
memory_profiler
.
start
(
)
;
}
)
;
let
memory_profiler_chan
=
MemoryProfilerChan
(
chan
)
;
let
system_reporter
=
Box
:
:
new
(
SystemMemoryReporter
)
;
memory_profiler_chan
.
send
(
MemoryProfilerMsg
:
:
RegisterMemoryReporter
(
"
system
"
.
to_owned
(
)
system_reporter
)
)
;
memory_profiler_chan
}
pub
fn
new
(
port
:
Receiver
<
MemoryProfilerMsg
>
)
-
>
MemoryProfiler
{
MemoryProfiler
{
port
:
port
reporters
:
HashMap
:
:
new
(
)
}
}
pub
fn
start
(
&
mut
self
)
{
loop
{
match
self
.
port
.
recv
(
)
{
Ok
(
msg
)
=
>
{
if
!
self
.
handle_msg
(
msg
)
{
break
}
}
_
=
>
break
}
}
}
fn
handle_msg
(
&
mut
self
msg
:
MemoryProfilerMsg
)
-
>
bool
{
match
msg
{
MemoryProfilerMsg
:
:
RegisterMemoryReporter
(
name
reporter
)
=
>
{
let
name_clone
=
name
.
clone
(
)
;
match
self
.
reporters
.
insert
(
name
reporter
)
{
None
=
>
true
Some
(
_
)
=
>
panic
!
(
format
!
(
"
RegisterMemoryReporter
:
'
{
}
'
name
is
already
in
use
"
name_clone
)
)
}
}
MemoryProfilerMsg
:
:
UnregisterMemoryReporter
(
name
)
=
>
{
match
self
.
reporters
.
remove
(
&
name
)
{
Some
(
_
)
=
>
true
None
=
>
panic
!
(
format
!
(
"
UnregisterMemoryReporter
:
'
{
}
'
name
is
unknown
"
&
name
)
)
}
}
MemoryProfilerMsg
:
:
Print
=
>
{
self
.
handle_print_msg
(
)
;
true
}
MemoryProfilerMsg
:
:
Exit
=
>
false
}
}
fn
handle_print_msg
(
&
self
)
{
println
!
(
"
{
:
12
}
:
{
}
"
"
_size
(
MiB
)
_
"
"
_category_
"
)
;
for
reporter
in
self
.
reporters
.
values
(
)
{
let
(
chan
port
)
=
channel
(
)
;
if
reporter
.
collect_reports
(
MemoryReportsChan
(
chan
)
)
{
if
let
Ok
(
reports
)
=
port
.
recv
(
)
{
for
report
in
reports
{
let
mebi
=
1024f64
*
1024f64
;
println
!
(
"
{
:
12
.
2
}
:
{
}
"
(
report
.
size
as
f64
)
/
mebi
report
.
name
)
;
}
}
}
}
println
!
(
"
"
)
;
}
}
struct
SystemMemoryReporter
;
impl
MemoryReporter
for
SystemMemoryReporter
{
fn
collect_reports
(
&
self
reports_chan
:
MemoryReportsChan
)
-
>
bool
{
let
mut
reports
=
vec
!
[
]
;
{
let
mut
report
=
|
name
:
&
str
size
|
{
if
let
Some
(
size
)
=
size
{
reports
.
push
(
MemoryReport
{
name
:
name
.
to_owned
(
)
size
:
size
}
)
;
}
}
;
report
(
"
vsize
"
get_vsize
(
)
)
;
report
(
"
resident
"
get_resident
(
)
)
;
for
seg
in
get_resident_segments
(
)
.
iter
(
)
{
report
(
seg
.
0
.
as_slice
(
)
Some
(
seg
.
1
)
)
;
}
report
(
"
system
-
heap
-
allocated
"
get_system_heap_allocated
(
)
)
;
report
(
"
jemalloc
-
heap
-
allocated
"
get_jemalloc_stat
(
"
stats
.
allocated
"
)
)
;
report
(
"
jemalloc
-
heap
-
active
"
get_jemalloc_stat
(
"
stats
.
active
"
)
)
;
report
(
"
jemalloc
-
heap
-
mapped
"
get_jemalloc_stat
(
"
stats
.
mapped
"
)
)
;
}
reports_chan
.
send
(
reports
)
;
true
}
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
extern
{
fn
mallinfo
(
)
-
>
struct_mallinfo
;
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
#
[
repr
(
C
)
]
pub
struct
struct_mallinfo
{
arena
:
c_int
ordblks
:
c_int
smblks
:
c_int
hblks
:
c_int
hblkhd
:
c_int
usmblks
:
c_int
fsmblks
:
c_int
uordblks
:
c_int
fordblks
:
c_int
keepcost
:
c_int
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
get_system_heap_allocated
(
)
-
>
Option
<
u64
>
{
let
mut
info
:
struct_mallinfo
;
unsafe
{
info
=
mallinfo
(
)
;
}
Some
(
(
info
.
hblkhd
+
info
.
uordblks
)
as
u64
)
}
#
[
cfg
(
not
(
target_os
=
"
linux
"
)
)
]
fn
get_system_heap_allocated
(
)
-
>
Option
<
u64
>
{
None
}
extern
{
fn
je_mallctl
(
name
:
*
const
c_char
oldp
:
*
mut
c_void
oldlenp
:
*
mut
size_t
newp
:
*
mut
c_void
newlen
:
size_t
)
-
>
c_int
;
}
fn
get_jemalloc_stat
(
value_name
:
&
str
)
-
>
Option
<
u64
>
{
let
epoch_name
=
"
epoch
"
;
let
epoch_c_name
=
CString
:
:
new
(
epoch_name
)
.
unwrap
(
)
;
let
mut
epoch
:
u64
=
0
;
let
epoch_ptr
=
&
mut
epoch
as
*
mut
_
as
*
mut
c_void
;
let
mut
epoch_len
=
size_of
:
:
<
u64
>
(
)
as
size_t
;
let
value_c_name
=
CString
:
:
new
(
value_name
)
.
unwrap
(
)
;
let
mut
value
:
size_t
=
0
;
let
value_ptr
=
&
mut
value
as
*
mut
_
as
*
mut
c_void
;
let
mut
value_len
=
size_of
:
:
<
size_t
>
(
)
as
size_t
;
let
rv
=
unsafe
{
je_mallctl
(
epoch_c_name
.
as_ptr
(
)
epoch_ptr
&
mut
epoch_len
epoch_ptr
epoch_len
)
}
;
if
rv
!
=
0
{
return
None
;
}
let
rv
=
unsafe
{
je_mallctl
(
value_c_name
.
as_ptr
(
)
value_ptr
&
mut
value_len
null_mut
(
)
0
)
}
;
if
rv
!
=
0
{
return
None
;
}
Some
(
value
as
u64
)
}
macro_rules
!
option_try
(
(
e
:
expr
)
=
>
(
match
e
{
Some
(
e
)
=
>
e
None
=
>
return
None
}
)
)
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
get_proc_self_statm_field
(
field
:
usize
)
-
>
Option
<
u64
>
{
let
mut
f
=
File
:
:
open
(
&
Path
:
:
new
(
"
/
proc
/
self
/
statm
"
)
)
;
match
f
.
read_to_string
(
)
{
Ok
(
contents
)
=
>
{
let
s
=
option_try
!
(
contents
.
as_slice
(
)
.
words
(
)
.
nth
(
field
)
)
;
let
npages
=
option_try
!
(
s
.
parse
:
:
<
u64
>
(
)
.
ok
(
)
)
;
Some
(
npages
*
(
:
:
std
:
:
env
:
:
page_size
(
)
as
u64
)
)
}
Err
(
_
)
=
>
None
}
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
get_vsize
(
)
-
>
Option
<
u64
>
{
get_proc_self_statm_field
(
0
)
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
get_resident
(
)
-
>
Option
<
u64
>
{
get_proc_self_statm_field
(
1
)
}
#
[
cfg
(
target_os
=
"
macos
"
)
]
fn
get_vsize
(
)
-
>
Option
<
u64
>
{
virtual_size
(
)
}
#
[
cfg
(
target_os
=
"
macos
"
)
]
fn
get_resident
(
)
-
>
Option
<
u64
>
{
resident_size
(
)
}
#
[
cfg
(
not
(
any
(
target_os
=
"
linux
"
target_os
=
"
macos
"
)
)
)
]
fn
get_vsize
(
)
-
>
Option
<
u64
>
{
None
}
#
[
cfg
(
not
(
any
(
target_os
=
"
linux
"
target_os
=
"
macos
"
)
)
)
]
fn
get_resident
(
)
-
>
Option
<
u64
>
{
None
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
get_resident_segments
(
)
-
>
Vec
<
(
String
u64
)
>
{
use
regex
:
:
Regex
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
let
path
=
Path
:
:
new
(
"
/
proc
/
self
/
smaps
"
)
;
let
mut
f
=
:
:
std
:
:
old_io
:
:
BufferedReader
:
:
new
(
File
:
:
open
(
&
path
)
)
;
let
seg_re
=
Regex
:
:
new
(
r
"
^
[
:
xdigit
:
]
+
-
[
:
xdigit
:
]
+
(
.
.
.
.
)
[
:
xdigit
:
]
+
[
:
xdigit
:
]
+
:
[
:
xdigit
:
]
+
\
d
+
+
(
.
*
)
"
)
.
unwrap
(
)
;
let
rss_re
=
Regex
:
:
new
(
r
"
^
Rss
:
+
(
\
d
+
)
kB
"
)
.
unwrap
(
)
;
let
mut
seg_map
:
HashMap
<
String
u64
>
=
HashMap
:
:
new
(
)
;
#
[
derive
(
PartialEq
)
]
enum
LookingFor
{
Segment
Rss
}
let
mut
looking_for
=
LookingFor
:
:
Segment
;
let
mut
curr_seg_name
=
String
:
:
new
(
)
;
for
line
in
f
.
lines
(
)
{
let
line
=
match
line
{
Ok
(
line
)
=
>
line
Err
(
_
)
=
>
continue
}
;
if
looking_for
=
=
LookingFor
:
:
Segment
{
let
cap
=
match
seg_re
.
captures
(
line
.
as_slice
(
)
)
{
Some
(
cap
)
=
>
cap
None
=
>
continue
}
;
let
perms
=
cap
.
at
(
1
)
.
unwrap
(
)
;
let
pathname
=
cap
.
at
(
2
)
.
unwrap
(
)
;
curr_seg_name
.
clear
(
)
;
curr_seg_name
.
push_str
(
"
-
"
)
;
if
pathname
=
=
"
"
|
|
pathname
.
starts_with
(
"
[
stack
:
"
)
{
curr_seg_name
.
push_str
(
"
anonymous
"
)
;
}
else
{
curr_seg_name
.
push_str
(
pathname
)
;
}
curr_seg_name
.
push_str
(
"
(
"
)
;
curr_seg_name
.
push_str
(
perms
)
;
curr_seg_name
.
push_str
(
"
)
"
)
;
looking_for
=
LookingFor
:
:
Rss
;
}
else
{
let
cap
=
match
rss_re
.
captures
(
line
.
as_slice
(
)
)
{
Some
(
cap
)
=
>
cap
None
=
>
continue
}
;
let
rss
=
cap
.
at
(
1
)
.
unwrap
(
)
.
parse
:
:
<
u64
>
(
)
.
unwrap
(
)
*
1024
;
if
rss
>
0
{
let
seg_name
=
if
rss
<
512
*
1024
{
"
-
other
"
.
to_owned
(
)
}
else
{
curr_seg_name
.
clone
(
)
}
;
match
seg_map
.
entry
(
seg_name
)
{
Entry
:
:
Vacant
(
entry
)
=
>
{
entry
.
insert
(
rss
)
;
}
Entry
:
:
Occupied
(
mut
entry
)
=
>
*
entry
.
get_mut
(
)
+
=
rss
}
}
looking_for
=
LookingFor
:
:
Segment
;
}
}
let
mut
segs
:
Vec
<
(
String
u64
)
>
=
seg_map
.
into_iter
(
)
.
collect
(
)
;
let
total
=
segs
.
iter
(
)
.
map
(
|
&
(
_
size
)
|
size
)
.
sum
(
)
;
segs
.
push
(
(
"
resident
-
according
-
to
-
smaps
"
.
to_owned
(
)
total
)
)
;
segs
.
sort_by
(
|
&
(
_
rss1
)
&
(
_
rss2
)
|
rss2
.
cmp
(
&
rss1
)
)
;
segs
}
#
[
cfg
(
not
(
target_os
=
"
linux
"
)
)
]
fn
get_resident_segments
(
)
-
>
Vec
<
(
String
u64
)
>
{
vec
!
[
]
}
