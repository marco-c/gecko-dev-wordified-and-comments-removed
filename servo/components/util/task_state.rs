pub
use
self
:
:
imp
:
:
{
initialize
get
enter
exit
}
;
bitflags
!
{
#
[
derive
(
Debug
)
]
flags
TaskState
:
u32
{
const
SCRIPT
=
0x01
const
LAYOUT
=
0x02
const
PAINT
=
0x04
const
IN_WORKER
=
0x0100
const
IN_GC
=
0x0200
const
IN_HTML_PARSER
=
0x0400
}
}
macro_rules
!
task_types
(
(
(
fun
:
ident
=
flag
:
ident
;
)
*
)
=
>
(
impl
TaskState
{
(
pub
fn
fun
(
self
)
-
>
bool
{
self
.
contains
(
flag
)
}
)
*
}
#
[
cfg
(
not
(
ndebug
)
)
]
static
TYPES
:
&
'
static
[
TaskState
]
=
&
[
(
flag
)
*
]
;
)
)
;
task_types
!
{
is_script
=
SCRIPT
;
is_layout
=
LAYOUT
;
is_paint
=
PAINT
;
}
#
[
cfg
(
not
(
ndebug
)
)
]
mod
imp
{
use
super
:
:
{
TaskState
TYPES
}
;
use
std
:
:
cell
:
:
RefCell
;
thread_local
!
(
static
STATE
:
RefCell
<
Option
<
TaskState
>
>
=
RefCell
:
:
new
(
None
)
)
;
pub
fn
initialize
(
x
:
TaskState
)
{
STATE
.
with
(
|
ref
k
|
{
match
*
k
.
borrow
(
)
{
Some
(
s
)
=
>
panic
!
(
"
Task
state
already
initialized
as
{
:
?
}
"
s
)
None
=
>
(
)
}
;
*
k
.
borrow_mut
(
)
=
Some
(
x
)
;
}
)
;
get
(
)
;
}
pub
fn
get
(
)
-
>
TaskState
{
let
state
=
STATE
.
with
(
|
ref
k
|
{
match
*
k
.
borrow
(
)
{
None
=
>
panic
!
(
"
Task
state
not
initialized
"
)
Some
(
s
)
=
>
s
}
}
)
;
assert_eq
!
(
1
TYPES
.
iter
(
)
.
filter
(
|
&
&
ty
|
state
.
contains
(
ty
)
)
.
count
(
)
)
;
state
}
pub
fn
enter
(
x
:
TaskState
)
{
let
state
=
get
(
)
;
assert
!
(
!
state
.
intersects
(
x
)
)
;
STATE
.
with
(
|
ref
k
|
{
*
k
.
borrow_mut
(
)
=
Some
(
state
|
x
)
;
}
)
}
pub
fn
exit
(
x
:
TaskState
)
{
let
state
=
get
(
)
;
assert
!
(
state
.
contains
(
x
)
)
;
STATE
.
with
(
|
ref
k
|
{
*
k
.
borrow_mut
(
)
=
Some
(
state
&
!
x
)
;
}
)
}
}
#
[
cfg
(
ndebug
)
]
mod
imp
{
use
super
:
:
TaskState
;
#
[
inline
(
always
)
]
pub
fn
initialize
(
_
:
TaskState
)
{
}
#
[
inline
(
always
)
]
pub
fn
get
(
)
-
>
TaskState
{
TaskState
:
:
empty
(
)
}
#
[
inline
(
always
)
]
pub
fn
enter
(
_
:
TaskState
)
{
}
#
[
inline
(
always
)
]
pub
fn
exit
(
_
:
TaskState
)
{
}
}
