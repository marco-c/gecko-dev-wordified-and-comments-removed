use
fnv
:
:
FnvHasher
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
pub
const
BLOOM_HASH_MASK
:
u32
=
0x00ffffff
;
const
KEY_SIZE
:
usize
=
12
;
const
ARRAY_SIZE
:
usize
=
1
<
<
KEY_SIZE
;
const
KEY_MASK
:
u32
=
(
1
<
<
KEY_SIZE
)
-
1
;
pub
struct
BloomFilter
{
counters
:
[
u8
;
ARRAY_SIZE
]
}
impl
Clone
for
BloomFilter
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
BloomFilter
{
BloomFilter
{
counters
:
self
.
counters
}
}
}
impl
BloomFilter
{
#
[
inline
]
pub
fn
new
(
)
-
>
BloomFilter
{
BloomFilter
{
counters
:
[
0
;
ARRAY_SIZE
]
}
}
#
[
inline
]
fn
first_slot
(
&
self
hash
:
u32
)
-
>
&
u8
{
&
self
.
counters
[
hash1
(
hash
)
as
usize
]
}
#
[
inline
]
fn
first_mut_slot
(
&
mut
self
hash
:
u32
)
-
>
&
mut
u8
{
&
mut
self
.
counters
[
hash1
(
hash
)
as
usize
]
}
#
[
inline
]
fn
second_slot
(
&
self
hash
:
u32
)
-
>
&
u8
{
&
self
.
counters
[
hash2
(
hash
)
as
usize
]
}
#
[
inline
]
fn
second_mut_slot
(
&
mut
self
hash
:
u32
)
-
>
&
mut
u8
{
&
mut
self
.
counters
[
hash2
(
hash
)
as
usize
]
}
#
[
inline
]
pub
fn
clear
(
&
mut
self
)
{
self
.
counters
=
[
0
;
ARRAY_SIZE
]
}
#
[
cfg
(
debug_assertions
)
]
pub
fn
is_zeroed
(
&
self
)
-
>
bool
{
self
.
counters
.
iter
(
)
.
all
(
|
x
|
*
x
=
=
0
)
}
#
[
cfg
(
not
(
debug_assertions
)
)
]
pub
fn
is_zeroed
(
&
self
)
-
>
bool
{
unreachable
!
(
)
}
#
[
inline
]
pub
fn
insert_hash
(
&
mut
self
hash
:
u32
)
{
{
let
slot1
=
self
.
first_mut_slot
(
hash
)
;
if
!
full
(
slot1
)
{
*
slot1
+
=
1
}
}
{
let
slot2
=
self
.
second_mut_slot
(
hash
)
;
if
!
full
(
slot2
)
{
*
slot2
+
=
1
}
}
}
#
[
inline
]
pub
fn
insert
<
T
:
Hash
>
(
&
mut
self
elem
:
&
T
)
{
self
.
insert_hash
(
hash
(
elem
)
)
}
#
[
inline
]
pub
fn
remove_hash
(
&
mut
self
hash
:
u32
)
{
{
let
slot1
=
self
.
first_mut_slot
(
hash
)
;
if
!
full
(
slot1
)
{
*
slot1
-
=
1
}
}
{
let
slot2
=
self
.
second_mut_slot
(
hash
)
;
if
!
full
(
slot2
)
{
*
slot2
-
=
1
}
}
}
#
[
inline
]
pub
fn
remove
<
T
:
Hash
>
(
&
mut
self
elem
:
&
T
)
{
self
.
remove_hash
(
hash
(
elem
)
)
}
#
[
inline
]
pub
fn
might_contain_hash
(
&
self
hash
:
u32
)
-
>
bool
{
*
self
.
first_slot
(
hash
)
!
=
0
&
&
*
self
.
second_slot
(
hash
)
!
=
0
}
#
[
inline
]
pub
fn
might_contain
<
T
:
Hash
>
(
&
self
elem
:
&
T
)
-
>
bool
{
self
.
might_contain_hash
(
hash
(
elem
)
)
}
}
#
[
inline
]
fn
full
(
slot
:
&
u8
)
-
>
bool
{
*
slot
=
=
0xff
}
fn
hash
<
T
:
Hash
>
(
elem
:
&
T
)
-
>
u32
{
let
mut
hasher
=
FnvHasher
:
:
default
(
)
;
elem
.
hash
(
&
mut
hasher
)
;
let
hash
:
u64
=
hasher
.
finish
(
)
;
(
hash
>
>
32
)
as
u32
^
(
hash
as
u32
)
}
#
[
inline
]
fn
hash1
(
hash
:
u32
)
-
>
u32
{
hash
&
KEY_MASK
}
#
[
inline
]
fn
hash2
(
hash
:
u32
)
-
>
u32
{
(
hash
>
>
KEY_SIZE
)
&
KEY_MASK
}
#
[
test
]
fn
create_and_insert_some_stuff
(
)
{
let
mut
bf
=
BloomFilter
:
:
new
(
)
;
for
i
in
0_usize
.
.
1000
{
bf
.
insert
(
&
i
)
;
}
for
i
in
0_usize
.
.
1000
{
assert
!
(
bf
.
might_contain
(
&
i
)
)
;
}
let
false_positives
=
(
1001_usize
.
.
2000
)
.
filter
(
|
i
|
bf
.
might_contain
(
i
)
)
.
count
(
)
;
assert
!
(
false_positives
<
150
"
{
}
is
not
<
150
"
false_positives
)
;
for
i
in
0_usize
.
.
100
{
bf
.
remove
(
&
i
)
;
}
for
i
in
100_usize
.
.
1000
{
assert
!
(
bf
.
might_contain
(
&
i
)
)
;
}
let
false_positives
=
(
0_usize
.
.
100
)
.
filter
(
|
i
|
bf
.
might_contain
(
i
)
)
.
count
(
)
;
assert
!
(
false_positives
<
20
"
{
}
is
not
<
20
"
false_positives
)
;
bf
.
clear
(
)
;
for
i
in
0_usize
.
.
2000
{
assert
!
(
!
bf
.
might_contain
(
&
i
)
)
;
}
}
#
[
cfg
(
feature
=
"
unstable
"
)
]
#
[
cfg
(
test
)
]
mod
bench
{
extern
crate
test
;
use
super
:
:
BloomFilter
;
#
[
derive
(
Default
)
]
struct
HashGenerator
(
u32
)
;
impl
HashGenerator
{
fn
next
(
&
mut
self
)
-
>
u32
{
self
.
0
+
=
(
65
)
+
(
65
<
<
super
:
:
KEY_SIZE
)
;
self
.
0
}
}
#
[
bench
]
fn
create_insert_1000_remove_100_lookup_100
(
b
:
&
mut
test
:
:
Bencher
)
{
b
.
iter
(
|
|
{
let
mut
gen1
=
HashGenerator
:
:
default
(
)
;
let
mut
gen2
=
HashGenerator
:
:
default
(
)
;
let
mut
bf
=
BloomFilter
:
:
new
(
)
;
for
_
in
0_usize
.
.
1000
{
bf
.
insert_hash
(
gen1
.
next
(
)
)
;
}
for
_
in
0_usize
.
.
100
{
bf
.
remove_hash
(
gen2
.
next
(
)
)
;
}
for
_
in
100_usize
.
.
200
{
test
:
:
black_box
(
bf
.
might_contain_hash
(
gen2
.
next
(
)
)
)
;
}
}
)
;
}
#
[
bench
]
fn
might_contain_10
(
b
:
&
mut
test
:
:
Bencher
)
{
let
bf
=
BloomFilter
:
:
new
(
)
;
let
mut
gen
=
HashGenerator
:
:
default
(
)
;
b
.
iter
(
|
|
for
_
in
0
.
.
10
{
test
:
:
black_box
(
bf
.
might_contain_hash
(
gen
.
next
(
)
)
)
;
}
)
;
}
#
[
bench
]
fn
clear
(
b
:
&
mut
test
:
:
Bencher
)
{
let
mut
bf
=
Box
:
:
new
(
BloomFilter
:
:
new
(
)
)
;
b
.
iter
(
|
|
test
:
:
black_box
(
&
mut
bf
)
.
clear
(
)
)
;
}
#
[
bench
]
fn
insert_10
(
b
:
&
mut
test
:
:
Bencher
)
{
let
mut
bf
=
BloomFilter
:
:
new
(
)
;
let
mut
gen
=
HashGenerator
:
:
default
(
)
;
b
.
iter
(
|
|
for
_
in
0
.
.
10
{
test
:
:
black_box
(
bf
.
insert_hash
(
gen
.
next
(
)
)
)
;
}
)
;
}
#
[
bench
]
fn
remove_10
(
b
:
&
mut
test
:
:
Bencher
)
{
let
mut
bf
=
BloomFilter
:
:
new
(
)
;
let
mut
gen
=
HashGenerator
:
:
default
(
)
;
b
.
iter
(
|
|
for
_
in
0
.
.
10
{
bf
.
remove_hash
(
gen
.
next
(
)
)
}
)
;
}
}
