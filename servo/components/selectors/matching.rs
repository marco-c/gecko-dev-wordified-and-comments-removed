use
attr
:
:
{
ParsedAttrSelectorOperation
AttrSelectorOperation
NamespaceConstraint
}
;
use
bloom
:
:
{
BLOOM_HASH_MASK
BloomFilter
}
;
use
nth_index_cache
:
:
NthIndexCacheInner
;
use
parser
:
:
{
AncestorHashes
Combinator
Component
LocalName
}
;
use
parser
:
:
{
Selector
SelectorImpl
SelectorIter
SelectorList
}
;
use
std
:
:
borrow
:
:
Borrow
;
use
tree
:
:
Element
;
pub
use
context
:
:
*
;
pub
static
RECOMMENDED_SELECTOR_BLOOM_FILTER_SIZE
:
usize
=
4096
;
bitflags
!
{
/
/
/
Set
of
flags
that
are
set
on
either
the
element
or
its
parent
(
depending
/
/
/
on
the
flag
)
if
the
element
could
potentially
match
a
selector
.
pub
flags
ElementSelectorFlags
:
usize
{
/
/
/
When
a
child
is
added
or
removed
from
the
parent
all
the
children
/
/
/
must
be
restyled
because
they
may
match
:
nth
-
last
-
child
/
/
/
:
last
-
of
-
type
:
nth
-
last
-
of
-
type
or
:
only
-
of
-
type
.
const
HAS_SLOW_SELECTOR
=
1
<
<
0
/
/
/
When
a
child
is
added
or
removed
from
the
parent
any
later
/
/
/
children
must
be
restyled
because
they
may
match
:
nth
-
child
/
/
/
:
first
-
of
-
type
or
:
nth
-
of
-
type
.
const
HAS_SLOW_SELECTOR_LATER_SIBLINGS
=
1
<
<
1
/
/
/
When
a
child
is
added
or
removed
from
the
parent
the
first
and
/
/
/
last
children
must
be
restyled
because
they
may
match
:
first
-
child
/
/
/
:
last
-
child
or
:
only
-
child
.
const
HAS_EDGE_CHILD_SELECTOR
=
1
<
<
2
/
/
/
The
element
has
an
empty
selector
so
when
a
child
is
appended
we
/
/
/
might
need
to
restyle
the
parent
completely
.
const
HAS_EMPTY_SELECTOR
=
1
<
<
3
}
}
impl
ElementSelectorFlags
{
pub
fn
for_self
(
self
)
-
>
ElementSelectorFlags
{
self
&
(
HAS_EMPTY_SELECTOR
)
}
pub
fn
for_parent
(
self
)
-
>
ElementSelectorFlags
{
self
&
(
HAS_SLOW_SELECTOR
|
HAS_SLOW_SELECTOR_LATER_SIBLINGS
|
HAS_EDGE_CHILD_SELECTOR
)
}
}
struct
LocalMatchingContext
<
'
a
'
b
:
'
a
>
{
shared
:
&
'
a
mut
MatchingContext
<
'
b
>
matches_hover_and_active_quirk
:
bool
}
pub
fn
matches_selector_list
<
E
>
(
selector_list
:
&
SelectorList
<
E
:
:
Impl
>
element
:
&
E
context
:
&
mut
MatchingContext
)
-
>
bool
where
E
:
Element
{
selector_list
.
0
.
iter
(
)
.
any
(
|
selector
|
{
matches_selector
(
selector
0
None
element
context
&
mut
|
_
_
|
{
}
)
}
)
}
#
[
inline
(
always
)
]
fn
may_match
<
E
>
(
hashes
:
&
AncestorHashes
bf
:
&
BloomFilter
)
-
>
bool
where
E
:
Element
{
for
i
in
0
.
.
3
{
let
packed
=
hashes
.
packed_hashes
[
i
]
;
if
packed
=
=
0
{
return
true
;
}
if
!
bf
.
might_contain_hash
(
packed
&
BLOOM_HASH_MASK
)
{
return
false
;
}
}
let
fourth
=
hashes
.
fourth_hash
(
)
;
fourth
=
=
0
|
|
bf
.
might_contain_hash
(
fourth
)
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
RelevantLinkStatus
{
Looking
NotLooking
Found
}
impl
Default
for
RelevantLinkStatus
{
fn
default
(
)
-
>
Self
{
RelevantLinkStatus
:
:
NotLooking
}
}
impl
RelevantLinkStatus
{
fn
examine_potential_link
<
E
>
(
&
self
element
:
&
E
context
:
&
mut
MatchingContext
)
-
>
RelevantLinkStatus
where
E
:
Element
{
if
*
self
!
=
RelevantLinkStatus
:
:
Looking
{
return
RelevantLinkStatus
:
:
NotLooking
}
if
!
element
.
is_link
(
)
{
return
*
self
}
context
.
relevant_link_found
=
true
;
RelevantLinkStatus
:
:
Found
}
pub
fn
is_visited
<
E
>
(
&
self
element
:
&
E
context
:
&
MatchingContext
)
-
>
bool
where
E
:
Element
{
if
!
element
.
is_link
(
)
{
return
false
}
if
context
.
visited_handling
=
=
VisitedHandlingMode
:
:
AllLinksVisitedAndUnvisited
{
return
true
;
}
if
*
self
!
=
RelevantLinkStatus
:
:
Found
{
return
false
}
context
.
visited_handling
=
=
VisitedHandlingMode
:
:
RelevantLinkVisited
}
pub
fn
is_unvisited
<
E
>
(
&
self
element
:
&
E
context
:
&
MatchingContext
)
-
>
bool
where
E
:
Element
{
if
!
element
.
is_link
(
)
{
return
false
}
if
context
.
visited_handling
=
=
VisitedHandlingMode
:
:
AllLinksVisitedAndUnvisited
{
return
true
;
}
if
*
self
!
=
RelevantLinkStatus
:
:
Found
{
return
true
}
context
.
visited_handling
=
=
VisitedHandlingMode
:
:
AllLinksUnvisited
}
}
#
[
derive
(
Clone
Copy
Eq
PartialEq
)
]
enum
SelectorMatchingResult
{
Matched
NotMatchedAndRestartFromClosestLaterSibling
NotMatchedAndRestartFromClosestDescendant
NotMatchedGlobally
}
#
[
inline
(
always
)
]
pub
fn
matches_selector
<
E
F
>
(
selector
:
&
Selector
<
E
:
:
Impl
>
offset
:
usize
hashes
:
Option
<
&
AncestorHashes
>
element
:
&
E
context
:
&
mut
MatchingContext
flags_setter
:
&
mut
F
)
-
>
bool
where
E
:
Element
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
if
let
Some
(
hashes
)
=
hashes
{
if
let
Some
(
filter
)
=
context
.
bloom_filter
{
if
!
may_match
:
:
<
E
>
(
hashes
filter
)
{
return
false
;
}
}
}
matches_complex_selector
(
selector
.
iter_from
(
offset
)
element
context
flags_setter
)
}
pub
enum
CompoundSelectorMatchingResult
{
FullyMatched
Matched
{
next_combinator_offset
:
usize
}
NotMatched
}
pub
fn
matches_compound_selector
<
E
>
(
selector
:
&
Selector
<
E
:
:
Impl
>
mut
from_offset
:
usize
context
:
&
mut
MatchingContext
element
:
&
E
)
-
>
CompoundSelectorMatchingResult
where
E
:
Element
{
debug_assert_ne
!
(
from_offset
0
)
;
if
cfg
!
(
debug_assertions
)
{
selector
.
combinator_at_parse_order
(
from_offset
-
1
)
;
}
let
mut
local_context
=
LocalMatchingContext
{
shared
:
context
matches_hover_and_active_quirk
:
false
}
;
for
component
in
selector
.
iter_raw_parse_order_from
(
from_offset
)
{
if
matches
!
(
*
component
Component
:
:
Combinator
(
.
.
)
)
{
debug_assert_ne
!
(
from_offset
0
"
Selector
started
with
a
combinator
?
"
)
;
return
CompoundSelectorMatchingResult
:
:
Matched
{
next_combinator_offset
:
from_offset
}
}
if
!
matches_simple_selector
(
component
element
&
mut
local_context
&
RelevantLinkStatus
:
:
NotLooking
&
mut
|
_
_
|
{
}
)
{
return
CompoundSelectorMatchingResult
:
:
NotMatched
;
}
from_offset
+
=
1
;
}
CompoundSelectorMatchingResult
:
:
FullyMatched
}
pub
fn
matches_complex_selector
<
E
F
>
(
mut
iter
:
SelectorIter
<
E
:
:
Impl
>
element
:
&
E
context
:
&
mut
MatchingContext
flags_setter
:
&
mut
F
)
-
>
bool
where
E
:
Element
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
if
context
.
nesting_level
=
=
0
&
&
context
.
matching_mode
=
=
MatchingMode
:
:
ForStatelessPseudoElement
{
let
pseudo
=
iter
.
next
(
)
.
unwrap
(
)
;
debug_assert
!
(
matches
!
(
*
pseudo
Component
:
:
PseudoElement
(
.
.
)
)
"
Used
MatchingMode
:
:
ForStatelessPseudoElement
in
a
non
-
pseudo
selector
"
)
;
if
let
Some
(
s
)
=
iter
.
next
(
)
{
debug_assert
!
(
matches
!
(
*
s
Component
:
:
NonTSPseudoClass
(
.
.
)
)
"
Someone
messed
up
pseudo
-
element
parsing
"
)
;
return
false
;
}
if
iter
.
next_sequence
(
)
.
is_none
(
)
{
return
true
;
}
}
let
result
=
matches_complex_selector_internal
(
iter
element
context
&
mut
RelevantLinkStatus
:
:
Looking
flags_setter
Rightmost
:
:
Yes
)
;
match
result
{
SelectorMatchingResult
:
:
Matched
=
>
true
_
=
>
false
}
}
#
[
inline
]
fn
matches_hover_and_active_quirk
<
Impl
:
SelectorImpl
>
(
selector_iter
:
&
SelectorIter
<
Impl
>
context
:
&
MatchingContext
rightmost
:
Rightmost
)
-
>
bool
{
if
context
.
quirks_mode
(
)
!
=
QuirksMode
:
:
Quirks
{
return
false
;
}
if
context
.
nesting_level
!
=
0
{
return
false
;
}
if
matches
!
(
rightmost
Rightmost
:
:
Yes
)
&
&
context
.
matching_mode
=
=
MatchingMode
:
:
ForStatelessPseudoElement
{
return
false
;
}
selector_iter
.
clone
(
)
.
all
(
|
simple
|
{
match
*
simple
{
Component
:
:
LocalName
(
_
)
|
Component
:
:
AttributeInNoNamespaceExists
{
.
.
}
|
Component
:
:
AttributeInNoNamespace
{
.
.
}
|
Component
:
:
AttributeOther
(
_
)
|
Component
:
:
ID
(
_
)
|
Component
:
:
Class
(
_
)
|
Component
:
:
PseudoElement
(
_
)
|
Component
:
:
Negation
(
_
)
|
Component
:
:
FirstChild
|
Component
:
:
LastChild
|
Component
:
:
OnlyChild
|
Component
:
:
Empty
|
Component
:
:
NthChild
(
_
_
)
|
Component
:
:
NthLastChild
(
_
_
)
|
Component
:
:
NthOfType
(
_
_
)
|
Component
:
:
NthLastOfType
(
_
_
)
|
Component
:
:
FirstOfType
|
Component
:
:
LastOfType
|
Component
:
:
OnlyOfType
=
>
false
Component
:
:
NonTSPseudoClass
(
ref
pseudo_class
)
=
>
{
Impl
:
:
is_active_or_hover
(
pseudo_class
)
}
_
=
>
true
}
}
)
}
enum
Rightmost
{
Yes
No
}
fn
matches_complex_selector_internal
<
E
F
>
(
mut
selector_iter
:
SelectorIter
<
E
:
:
Impl
>
element
:
&
E
context
:
&
mut
MatchingContext
relevant_link
:
&
mut
RelevantLinkStatus
flags_setter
:
&
mut
F
rightmost
:
Rightmost
)
-
>
SelectorMatchingResult
where
E
:
Element
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
*
relevant_link
=
relevant_link
.
examine_potential_link
(
element
context
)
;
debug
!
(
"
Matching
complex
selector
{
:
?
}
for
{
:
?
}
relevant
link
{
:
?
}
"
selector_iter
element
relevant_link
)
;
let
matches_all_simple_selectors
=
{
let
matches_hover_and_active_quirk
=
matches_hover_and_active_quirk
(
&
selector_iter
context
rightmost
)
;
let
mut
local_context
=
LocalMatchingContext
{
shared
:
context
matches_hover_and_active_quirk
}
;
selector_iter
.
all
(
|
simple
|
{
matches_simple_selector
(
simple
element
&
mut
local_context
&
relevant_link
flags_setter
)
}
)
}
;
let
combinator
=
selector_iter
.
next_sequence
(
)
;
let
siblings
=
combinator
.
map_or
(
false
|
c
|
c
.
is_sibling
(
)
)
;
if
siblings
{
flags_setter
(
element
HAS_SLOW_SELECTOR_LATER_SIBLINGS
)
;
}
if
!
matches_all_simple_selectors
{
return
SelectorMatchingResult
:
:
NotMatchedAndRestartFromClosestLaterSibling
;
}
match
combinator
{
None
=
>
SelectorMatchingResult
:
:
Matched
Some
(
c
)
=
>
{
let
(
mut
next_element
candidate_not_found
)
=
match
c
{
Combinator
:
:
NextSibling
|
Combinator
:
:
LaterSibling
=
>
{
*
relevant_link
=
RelevantLinkStatus
:
:
NotLooking
;
(
element
.
prev_sibling_element
(
)
SelectorMatchingResult
:
:
NotMatchedAndRestartFromClosestDescendant
)
}
Combinator
:
:
Child
|
Combinator
:
:
Descendant
=
>
{
if
element
.
blocks_ancestor_combinators
(
)
{
(
None
SelectorMatchingResult
:
:
NotMatchedGlobally
)
}
else
{
(
element
.
parent_element
(
)
SelectorMatchingResult
:
:
NotMatchedGlobally
)
}
}
Combinator
:
:
PseudoElement
=
>
{
(
element
.
pseudo_element_originating_element
(
)
SelectorMatchingResult
:
:
NotMatchedGlobally
)
}
}
;
loop
{
let
element
=
match
next_element
{
None
=
>
return
candidate_not_found
Some
(
next_element
)
=
>
next_element
}
;
let
result
=
matches_complex_selector_internal
(
selector_iter
.
clone
(
)
&
element
context
relevant_link
flags_setter
Rightmost
:
:
No
)
;
match
(
result
c
)
{
(
SelectorMatchingResult
:
:
Matched
_
)
=
>
return
result
(
SelectorMatchingResult
:
:
NotMatchedGlobally
_
)
=
>
return
result
(
_
Combinator
:
:
PseudoElement
)
|
(
_
Combinator
:
:
Child
)
=
>
return
SelectorMatchingResult
:
:
NotMatchedAndRestartFromClosestDescendant
(
_
Combinator
:
:
NextSibling
)
=
>
return
result
(
SelectorMatchingResult
:
:
NotMatchedAndRestartFromClosestDescendant
Combinator
:
:
LaterSibling
)
=
>
return
result
_
=
>
{
}
}
next_element
=
if
siblings
{
element
.
prev_sibling_element
(
)
}
else
{
element
.
parent_element
(
)
}
;
}
}
}
}
#
[
inline
]
fn
matches_simple_selector
<
E
F
>
(
selector
:
&
Component
<
E
:
:
Impl
>
element
:
&
E
context
:
&
mut
LocalMatchingContext
relevant_link
:
&
RelevantLinkStatus
flags_setter
:
&
mut
F
)
-
>
bool
where
E
:
Element
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
match
*
selector
{
Component
:
:
Combinator
(
_
)
=
>
unreachable
!
(
)
Component
:
:
PseudoElement
(
ref
pseudo
)
=
>
{
element
.
match_pseudo_element
(
pseudo
context
.
shared
)
}
Component
:
:
LocalName
(
LocalName
{
ref
name
ref
lower_name
}
)
=
>
{
let
is_html
=
element
.
is_html_element_in_html_document
(
)
;
element
.
get_local_name
(
)
=
=
select_name
(
is_html
name
lower_name
)
.
borrow
(
)
}
Component
:
:
ExplicitUniversalType
|
Component
:
:
ExplicitAnyNamespace
=
>
{
true
}
Component
:
:
Namespace
(
_
ref
url
)
|
Component
:
:
DefaultNamespace
(
ref
url
)
=
>
{
element
.
get_namespace
(
)
=
=
url
.
borrow
(
)
}
Component
:
:
ExplicitNoNamespace
=
>
{
let
ns
=
:
:
parser
:
:
namespace_empty_string
:
:
<
E
:
:
Impl
>
(
)
;
element
.
get_namespace
(
)
=
=
ns
.
borrow
(
)
}
Component
:
:
ID
(
ref
id
)
=
>
{
element
.
has_id
(
id
context
.
shared
.
classes_and_ids_case_sensitivity
(
)
)
}
Component
:
:
Class
(
ref
class
)
=
>
{
element
.
has_class
(
class
context
.
shared
.
classes_and_ids_case_sensitivity
(
)
)
}
Component
:
:
AttributeInNoNamespaceExists
{
ref
local_name
ref
local_name_lower
}
=
>
{
let
is_html
=
element
.
is_html_element_in_html_document
(
)
;
element
.
attr_matches
(
&
NamespaceConstraint
:
:
Specific
(
&
:
:
parser
:
:
namespace_empty_string
:
:
<
E
:
:
Impl
>
(
)
)
select_name
(
is_html
local_name
local_name_lower
)
&
AttrSelectorOperation
:
:
Exists
)
}
Component
:
:
AttributeInNoNamespace
{
ref
local_name
ref
local_name_lower
ref
value
operator
case_sensitivity
never_matches
}
=
>
{
if
never_matches
{
return
false
}
let
is_html
=
element
.
is_html_element_in_html_document
(
)
;
element
.
attr_matches
(
&
NamespaceConstraint
:
:
Specific
(
&
:
:
parser
:
:
namespace_empty_string
:
:
<
E
:
:
Impl
>
(
)
)
select_name
(
is_html
local_name
local_name_lower
)
&
AttrSelectorOperation
:
:
WithValue
{
operator
:
operator
case_sensitivity
:
case_sensitivity
.
to_unconditional
(
is_html
)
expected_value
:
value
}
)
}
Component
:
:
AttributeOther
(
ref
attr_sel
)
=
>
{
if
attr_sel
.
never_matches
{
return
false
}
let
is_html
=
element
.
is_html_element_in_html_document
(
)
;
element
.
attr_matches
(
&
attr_sel
.
namespace
(
)
select_name
(
is_html
&
attr_sel
.
local_name
&
attr_sel
.
local_name_lower
)
&
match
attr_sel
.
operation
{
ParsedAttrSelectorOperation
:
:
Exists
=
>
AttrSelectorOperation
:
:
Exists
ParsedAttrSelectorOperation
:
:
WithValue
{
operator
case_sensitivity
ref
expected_value
}
=
>
{
AttrSelectorOperation
:
:
WithValue
{
operator
:
operator
case_sensitivity
:
case_sensitivity
.
to_unconditional
(
is_html
)
expected_value
:
expected_value
}
}
}
)
}
Component
:
:
NonTSPseudoClass
(
ref
pc
)
=
>
{
if
context
.
matches_hover_and_active_quirk
&
&
context
.
shared
.
nesting_level
=
=
0
&
&
E
:
:
Impl
:
:
is_active_or_hover
(
pc
)
&
&
!
element
.
is_link
(
)
{
return
false
;
}
element
.
match_non_ts_pseudo_class
(
pc
&
mut
context
.
shared
relevant_link
flags_setter
)
}
Component
:
:
FirstChild
=
>
{
matches_first_child
(
element
flags_setter
)
}
Component
:
:
LastChild
=
>
{
matches_last_child
(
element
flags_setter
)
}
Component
:
:
OnlyChild
=
>
{
matches_first_child
(
element
flags_setter
)
&
&
matches_last_child
(
element
flags_setter
)
}
Component
:
:
Root
=
>
{
element
.
is_root
(
)
}
Component
:
:
Empty
=
>
{
flags_setter
(
element
HAS_EMPTY_SELECTOR
)
;
element
.
is_empty
(
)
}
Component
:
:
Scope
=
>
{
match
context
.
shared
.
scope_element
{
Some
(
ref
scope_element
)
=
>
element
.
opaque
(
)
=
=
*
scope_element
None
=
>
element
.
is_root
(
)
}
}
Component
:
:
NthChild
(
a
b
)
=
>
{
matches_generic_nth_child
(
element
context
a
b
false
false
flags_setter
)
}
Component
:
:
NthLastChild
(
a
b
)
=
>
{
matches_generic_nth_child
(
element
context
a
b
false
true
flags_setter
)
}
Component
:
:
NthOfType
(
a
b
)
=
>
{
matches_generic_nth_child
(
element
context
a
b
true
false
flags_setter
)
}
Component
:
:
NthLastOfType
(
a
b
)
=
>
{
matches_generic_nth_child
(
element
context
a
b
true
true
flags_setter
)
}
Component
:
:
FirstOfType
=
>
{
matches_generic_nth_child
(
element
context
0
1
true
false
flags_setter
)
}
Component
:
:
LastOfType
=
>
{
matches_generic_nth_child
(
element
context
0
1
true
true
flags_setter
)
}
Component
:
:
OnlyOfType
=
>
{
matches_generic_nth_child
(
element
context
0
1
true
false
flags_setter
)
&
&
matches_generic_nth_child
(
element
context
0
1
true
true
flags_setter
)
}
Component
:
:
Negation
(
ref
negated
)
=
>
{
context
.
shared
.
nesting_level
+
=
1
;
let
result
=
!
negated
.
iter
(
)
.
all
(
|
ss
|
{
matches_simple_selector
(
ss
element
context
relevant_link
flags_setter
)
}
)
;
context
.
shared
.
nesting_level
-
=
1
;
result
}
}
}
fn
select_name
<
'
a
T
>
(
is_html
:
bool
local_name
:
&
'
a
T
local_name_lower
:
&
'
a
T
)
-
>
&
'
a
T
{
if
is_html
{
local_name_lower
}
else
{
local_name
}
}
#
[
inline
]
fn
matches_generic_nth_child
<
E
F
>
(
element
:
&
E
context
:
&
mut
LocalMatchingContext
a
:
i32
b
:
i32
is_of_type
:
bool
is_from_end
:
bool
flags_setter
:
&
mut
F
)
-
>
bool
where
E
:
Element
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
if
element
.
ignores_nth_child_selectors
(
)
{
return
false
;
}
flags_setter
(
element
if
is_from_end
{
HAS_SLOW_SELECTOR
}
else
{
HAS_SLOW_SELECTOR_LATER_SIBLINGS
}
)
;
let
mut
cache
=
context
.
shared
.
nth_index_cache
.
as_mut
(
)
.
map
(
|
c
|
{
c
.
get
(
is_of_type
is_from_end
)
}
)
;
let
index
=
if
let
Some
(
i
)
=
cache
.
as_mut
(
)
.
and_then
(
|
c
|
c
.
lookup
(
element
.
opaque
(
)
)
)
{
i
}
else
{
let
i
=
nth_child_index
(
element
is_of_type
is_from_end
cache
.
as_mut
(
)
.
map
(
|
s
|
&
mut
*
*
s
)
)
;
cache
.
as_mut
(
)
.
map
(
|
c
|
c
.
insert
(
element
.
opaque
(
)
i
)
)
;
i
}
;
debug_assert_eq
!
(
index
nth_child_index
(
element
is_of_type
is_from_end
None
)
"
invalid
cache
"
)
;
match
index
.
checked_sub
(
b
)
{
None
=
>
false
Some
(
an
)
=
>
match
an
.
checked_div
(
a
)
{
Some
(
n
)
=
>
n
>
=
0
&
&
a
*
n
=
=
an
None
=
>
an
=
=
0
}
}
}
#
[
inline
]
fn
same_type
<
E
:
Element
>
(
a
:
&
E
b
:
&
E
)
-
>
bool
{
a
.
get_local_name
(
)
=
=
b
.
get_local_name
(
)
&
&
a
.
get_namespace
(
)
=
=
b
.
get_namespace
(
)
}
#
[
inline
]
fn
nth_child_index
<
E
>
(
element
:
&
E
is_of_type
:
bool
is_from_end
:
bool
mut
cache
:
Option
<
&
mut
NthIndexCacheInner
>
)
-
>
i32
where
E
:
Element
{
if
let
Some
(
ref
mut
c
)
=
cache
{
if
is_from_end
&
&
!
c
.
is_empty
(
)
{
let
mut
index
:
i32
=
1
;
let
mut
curr
=
element
.
clone
(
)
;
while
let
Some
(
e
)
=
curr
.
prev_sibling_element
(
)
{
curr
=
e
;
if
!
is_of_type
|
|
same_type
(
element
&
curr
)
{
if
let
Some
(
i
)
=
c
.
lookup
(
curr
.
opaque
(
)
)
{
return
i
-
index
;
}
index
+
=
1
;
}
}
}
}
let
mut
index
:
i32
=
1
;
let
mut
curr
=
element
.
clone
(
)
;
let
next
=
|
e
:
E
|
if
is_from_end
{
e
.
next_sibling_element
(
)
}
else
{
e
.
prev_sibling_element
(
)
}
;
while
let
Some
(
e
)
=
next
(
curr
)
{
curr
=
e
;
if
!
is_of_type
|
|
same_type
(
element
&
curr
)
{
if
!
is_from_end
{
if
let
Some
(
i
)
=
cache
.
as_mut
(
)
.
and_then
(
|
c
|
c
.
lookup
(
curr
.
opaque
(
)
)
)
{
return
i
+
index
}
}
index
+
=
1
;
}
}
index
}
#
[
inline
]
fn
matches_first_child
<
E
F
>
(
element
:
&
E
flags_setter
:
&
mut
F
)
-
>
bool
where
E
:
Element
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
flags_setter
(
element
HAS_EDGE_CHILD_SELECTOR
)
;
element
.
prev_sibling_element
(
)
.
is_none
(
)
}
#
[
inline
]
fn
matches_last_child
<
E
F
>
(
element
:
&
E
flags_setter
:
&
mut
F
)
-
>
bool
where
E
:
Element
F
:
FnMut
(
&
E
ElementSelectorFlags
)
{
flags_setter
(
element
HAS_EDGE_CHILD_SELECTOR
)
;
element
.
next_sibling_element
(
)
.
is_none
(
)
}
