use
fxhash
:
:
FxHashMap
;
use
crate
:
:
bloom
:
:
BloomFilter
;
use
crate
:
:
context
:
:
QuirksMode
;
use
crate
:
:
parser
:
:
{
collect_selector_hashes
RelativeSelector
RelativeSelectorMatchHint
}
;
use
crate
:
:
tree
:
:
{
Element
OpaqueElement
}
;
use
crate
:
:
SelectorImpl
;
enum
Entry
{
Lookup
HasFilter
(
Box
<
BloomFilter
>
)
}
#
[
derive
(
Clone
Copy
Hash
Eq
PartialEq
)
]
enum
TraversalKind
{
Children
Descendants
}
fn
add_to_filter
<
E
:
Element
>
(
element
:
&
E
filter
:
&
mut
BloomFilter
kind
:
TraversalKind
)
-
>
bool
{
let
mut
child
=
element
.
first_element_child
(
)
;
while
let
Some
(
e
)
=
child
{
if
!
e
.
add_element_unique_hashes
(
filter
)
{
return
false
;
}
if
kind
=
=
TraversalKind
:
:
Descendants
{
if
!
add_to_filter
(
&
e
filter
kind
)
{
return
false
;
}
}
child
=
e
.
next_sibling_element
(
)
;
}
true
}
#
[
derive
(
Clone
Copy
Hash
Eq
PartialEq
)
]
struct
Key
(
OpaqueElement
TraversalKind
)
;
#
[
derive
(
Default
)
]
pub
struct
RelativeSelectorFilterMap
{
map
:
FxHashMap
<
Key
Entry
>
}
fn
fast_reject
<
Impl
:
SelectorImpl
>
(
selector
:
&
RelativeSelector
<
Impl
>
quirks_mode
:
QuirksMode
filter
:
&
BloomFilter
)
-
>
bool
{
let
mut
hashes
=
[
0u32
;
4
]
;
let
mut
len
=
0
;
collect_selector_hashes
(
selector
.
selector
.
iter
(
)
quirks_mode
&
mut
hashes
&
mut
len
|
s
|
s
.
iter
(
)
)
;
for
i
in
0
.
.
len
{
if
!
filter
.
might_contain_hash
(
hashes
[
i
]
)
{
return
true
;
}
}
false
}
impl
RelativeSelectorFilterMap
{
fn
get_filter
<
E
:
Element
>
(
&
mut
self
element
:
&
E
kind
:
TraversalKind
)
-
>
Option
<
&
BloomFilter
>
{
let
key
=
Key
(
element
.
opaque
(
)
kind
)
;
let
entry
=
self
.
map
.
entry
(
key
)
.
and_modify
(
|
entry
|
{
if
!
matches
!
(
entry
Entry
:
:
Lookup
)
{
return
;
}
let
mut
filter
=
BloomFilter
:
:
new
(
)
;
if
add_to_filter
(
element
&
mut
filter
kind
)
{
*
entry
=
Entry
:
:
HasFilter
(
Box
:
:
new
(
filter
)
)
;
}
}
)
.
or_insert
(
Entry
:
:
Lookup
)
;
match
entry
{
Entry
:
:
Lookup
=
>
None
Entry
:
:
HasFilter
(
ref
filter
)
=
>
Some
(
filter
.
as_ref
(
)
)
}
}
pub
fn
fast_reject
<
Impl
:
SelectorImpl
E
:
Element
>
(
&
mut
self
element
:
&
E
selector
:
&
RelativeSelector
<
Impl
>
quirks_mode
:
QuirksMode
)
-
>
bool
{
if
matches
!
(
selector
.
match_hint
RelativeSelectorMatchHint
:
:
InNextSibling
)
{
return
false
;
}
let
is_sibling
=
matches
!
(
selector
.
match_hint
RelativeSelectorMatchHint
:
:
InSibling
|
RelativeSelectorMatchHint
:
:
InNextSiblingSubtree
|
RelativeSelectorMatchHint
:
:
InSiblingSubtree
)
;
let
is_subtree
=
matches
!
(
selector
.
match_hint
RelativeSelectorMatchHint
:
:
InSubtree
|
RelativeSelectorMatchHint
:
:
InNextSiblingSubtree
|
RelativeSelectorMatchHint
:
:
InSiblingSubtree
)
;
let
kind
=
if
is_subtree
{
TraversalKind
:
:
Descendants
}
else
{
TraversalKind
:
:
Children
}
;
if
is_sibling
{
element
.
parent_element
(
)
.
map_or
(
false
|
parent
|
{
self
.
get_filter
(
&
parent
kind
)
.
map_or
(
false
|
filter
|
fast_reject
(
selector
quirks_mode
filter
)
)
}
)
}
else
{
self
.
get_filter
(
element
kind
)
.
map_or
(
false
|
filter
|
fast_reject
(
selector
quirks_mode
filter
)
)
}
}
}
