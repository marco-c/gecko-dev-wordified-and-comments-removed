use
crate
:
:
attr
:
:
CaseSensitivity
;
use
crate
:
:
bloom
:
:
BloomFilter
;
use
crate
:
:
nth_index_cache
:
:
{
NthIndexCache
NthIndexCacheInner
}
;
use
crate
:
:
parser
:
:
{
Selector
SelectorImpl
}
;
use
crate
:
:
tree
:
:
{
Element
OpaqueElement
}
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
MatchingMode
{
Normal
ForStatelessPseudoElement
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
VisitedHandlingMode
{
AllLinksUnvisited
AllLinksVisitedAndUnvisited
RelevantLinkVisited
}
impl
VisitedHandlingMode
{
#
[
inline
]
pub
fn
matches_visited
(
&
self
)
-
>
bool
{
matches
!
(
*
self
VisitedHandlingMode
:
:
RelevantLinkVisited
|
VisitedHandlingMode
:
:
AllLinksVisitedAndUnvisited
)
}
#
[
inline
]
pub
fn
matches_unvisited
(
&
self
)
-
>
bool
{
matches
!
(
*
self
VisitedHandlingMode
:
:
AllLinksUnvisited
|
VisitedHandlingMode
:
:
AllLinksVisitedAndUnvisited
)
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
NeedsSelectorFlags
{
No
Yes
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
enum
QuirksMode
{
Quirks
LimitedQuirks
NoQuirks
}
impl
QuirksMode
{
#
[
inline
]
pub
fn
classes_and_ids_case_sensitivity
(
self
)
-
>
CaseSensitivity
{
match
self
{
QuirksMode
:
:
NoQuirks
|
QuirksMode
:
:
LimitedQuirks
=
>
CaseSensitivity
:
:
CaseSensitive
QuirksMode
:
:
Quirks
=
>
CaseSensitivity
:
:
AsciiCaseInsensitive
}
}
}
pub
struct
MatchingContext
<
'
a
Impl
>
where
Impl
:
SelectorImpl
{
matching_mode
:
MatchingMode
pub
bloom_filter
:
Option
<
&
'
a
BloomFilter
>
pub
nth_index_cache
:
&
'
a
mut
NthIndexCache
pub
scope_element
:
Option
<
OpaqueElement
>
pub
current_host
:
Option
<
OpaqueElement
>
visited_handling
:
VisitedHandlingMode
nesting_level
:
usize
in_negation
:
bool
pub
pseudo_element_matching_fn
:
Option
<
&
'
a
dyn
Fn
(
&
Impl
:
:
PseudoElement
)
-
>
bool
>
pub
extra_data
:
Impl
:
:
ExtraMatchingData
<
'
a
>
current_relative_selector_anchor
:
Option
<
OpaqueElement
>
pub
considered_relative_selector
:
bool
quirks_mode
:
QuirksMode
needs_selector_flags
:
NeedsSelectorFlags
classes_and_ids_case_sensitivity
:
CaseSensitivity
_impl
:
:
:
std
:
:
marker
:
:
PhantomData
<
Impl
>
}
impl
<
'
a
Impl
>
MatchingContext
<
'
a
Impl
>
where
Impl
:
SelectorImpl
{
pub
fn
new
(
matching_mode
:
MatchingMode
bloom_filter
:
Option
<
&
'
a
BloomFilter
>
nth_index_cache
:
&
'
a
mut
NthIndexCache
quirks_mode
:
QuirksMode
needs_selector_flags
:
NeedsSelectorFlags
)
-
>
Self
{
Self
:
:
new_for_visited
(
matching_mode
bloom_filter
nth_index_cache
VisitedHandlingMode
:
:
AllLinksUnvisited
quirks_mode
needs_selector_flags
)
}
pub
fn
new_for_visited
(
matching_mode
:
MatchingMode
bloom_filter
:
Option
<
&
'
a
BloomFilter
>
nth_index_cache
:
&
'
a
mut
NthIndexCache
visited_handling
:
VisitedHandlingMode
quirks_mode
:
QuirksMode
needs_selector_flags
:
NeedsSelectorFlags
)
-
>
Self
{
Self
{
matching_mode
bloom_filter
visited_handling
nth_index_cache
quirks_mode
classes_and_ids_case_sensitivity
:
quirks_mode
.
classes_and_ids_case_sensitivity
(
)
needs_selector_flags
scope_element
:
None
current_host
:
None
nesting_level
:
0
in_negation
:
false
pseudo_element_matching_fn
:
None
extra_data
:
Default
:
:
default
(
)
current_relative_selector_anchor
:
None
considered_relative_selector
:
false
_impl
:
:
:
std
:
:
marker
:
:
PhantomData
}
}
#
[
inline
]
pub
fn
nth_index_cache
(
&
mut
self
is_of_type
:
bool
is_from_end
:
bool
selectors
:
&
[
Selector
<
Impl
>
]
)
-
>
&
mut
NthIndexCacheInner
{
self
.
nth_index_cache
.
get
(
is_of_type
is_from_end
selectors
)
}
#
[
inline
]
pub
fn
is_nested
(
&
self
)
-
>
bool
{
self
.
nesting_level
!
=
0
}
#
[
inline
]
pub
fn
in_negation
(
&
self
)
-
>
bool
{
self
.
in_negation
}
#
[
inline
]
pub
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
{
self
.
quirks_mode
}
#
[
inline
]
pub
fn
matching_mode
(
&
self
)
-
>
MatchingMode
{
self
.
matching_mode
}
#
[
inline
]
pub
fn
needs_selector_flags
(
&
self
)
-
>
bool
{
self
.
needs_selector_flags
=
=
NeedsSelectorFlags
:
:
Yes
}
#
[
inline
]
pub
fn
classes_and_ids_case_sensitivity
(
&
self
)
-
>
CaseSensitivity
{
self
.
classes_and_ids_case_sensitivity
}
#
[
inline
]
pub
fn
nest
<
F
R
>
(
&
mut
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
self
.
nesting_level
+
=
1
;
let
result
=
f
(
self
)
;
self
.
nesting_level
-
=
1
;
result
}
#
[
inline
]
pub
fn
nest_for_negation
<
F
R
>
(
&
mut
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
let
old_in_negation
=
self
.
in_negation
;
self
.
in_negation
=
true
;
let
result
=
self
.
nest
(
f
)
;
self
.
in_negation
=
old_in_negation
;
result
}
#
[
inline
]
pub
fn
visited_handling
(
&
self
)
-
>
VisitedHandlingMode
{
self
.
visited_handling
}
#
[
inline
]
pub
fn
with_visited_handling_mode
<
F
R
>
(
&
mut
self
handling_mode
:
VisitedHandlingMode
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
let
original_handling_mode
=
self
.
visited_handling
;
self
.
visited_handling
=
handling_mode
;
let
result
=
f
(
self
)
;
self
.
visited_handling
=
original_handling_mode
;
result
}
#
[
inline
]
pub
fn
with_shadow_host
<
F
E
R
>
(
&
mut
self
host
:
Option
<
E
>
f
:
F
)
-
>
R
where
E
:
Element
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
let
original_host
=
self
.
current_host
.
take
(
)
;
self
.
current_host
=
host
.
map
(
|
h
|
h
.
opaque
(
)
)
;
let
result
=
f
(
self
)
;
self
.
current_host
=
original_host
;
result
}
#
[
inline
]
pub
fn
shadow_host
(
&
self
)
-
>
Option
<
OpaqueElement
>
{
self
.
current_host
}
#
[
inline
]
pub
fn
nest_for_relative_selector
<
F
R
>
(
&
mut
self
anchor
:
OpaqueElement
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
let
original_relative_selector_anchor
=
self
.
current_relative_selector_anchor
.
take
(
)
;
self
.
current_relative_selector_anchor
=
Some
(
anchor
)
;
let
result
=
self
.
nest
(
f
)
;
self
.
current_relative_selector_anchor
=
original_relative_selector_anchor
;
self
.
considered_relative_selector
=
true
;
result
}
#
[
inline
]
pub
fn
relative_selector_anchor
(
&
self
)
-
>
Option
<
OpaqueElement
>
{
self
.
current_relative_selector_anchor
}
}
