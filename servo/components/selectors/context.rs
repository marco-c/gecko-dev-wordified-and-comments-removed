use
crate
:
:
attr
:
:
CaseSensitivity
;
use
crate
:
:
bloom
:
:
BloomFilter
;
use
crate
:
:
nth_index_cache
:
:
{
NthIndexCache
NthIndexCacheInner
}
;
use
crate
:
:
parser
:
:
{
Selector
SelectorImpl
}
;
use
crate
:
:
relative_selector
:
:
cache
:
:
RelativeSelectorCache
;
use
crate
:
:
relative_selector
:
:
filter
:
:
RelativeSelectorFilterMap
;
use
crate
:
:
tree
:
:
{
Element
OpaqueElement
}
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
MatchingMode
{
Normal
ForStatelessPseudoElement
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
VisitedHandlingMode
{
AllLinksUnvisited
AllLinksVisitedAndUnvisited
RelevantLinkVisited
}
impl
VisitedHandlingMode
{
#
[
inline
]
pub
fn
matches_visited
(
&
self
)
-
>
bool
{
matches
!
(
*
self
VisitedHandlingMode
:
:
RelevantLinkVisited
|
VisitedHandlingMode
:
:
AllLinksVisitedAndUnvisited
)
}
#
[
inline
]
pub
fn
matches_unvisited
(
&
self
)
-
>
bool
{
matches
!
(
*
self
VisitedHandlingMode
:
:
AllLinksUnvisited
|
VisitedHandlingMode
:
:
AllLinksVisitedAndUnvisited
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
IncludeStartingStyle
{
No
Yes
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
NeedsSelectorFlags
{
No
Yes
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
MatchingForInvalidation
{
No
Yes
YesForComparison
}
impl
MatchingForInvalidation
{
pub
fn
is_for_invalidation
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Self
:
:
Yes
|
Self
:
:
YesForComparison
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
enum
QuirksMode
{
Quirks
LimitedQuirks
NoQuirks
}
impl
QuirksMode
{
#
[
inline
]
pub
fn
classes_and_ids_case_sensitivity
(
self
)
-
>
CaseSensitivity
{
match
self
{
QuirksMode
:
:
NoQuirks
|
QuirksMode
:
:
LimitedQuirks
=
>
CaseSensitivity
:
:
CaseSensitive
QuirksMode
:
:
Quirks
=
>
CaseSensitivity
:
:
AsciiCaseInsensitive
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
RelativeSelectorMatchingState
{
None
Considered
ConsideredAnchor
}
impl
RelativeSelectorMatchingState
{
pub
fn
considered_anchor
(
&
mut
self
)
{
*
self
=
Self
:
:
ConsideredAnchor
;
}
pub
fn
considered
(
&
mut
self
)
{
if
*
self
=
=
Self
:
:
ConsideredAnchor
{
*
self
=
Self
:
:
ConsideredAnchor
;
}
else
{
*
self
=
Self
:
:
Considered
;
}
}
}
#
[
derive
(
Default
)
]
pub
struct
SelectorCaches
{
pub
nth_index
:
NthIndexCache
pub
relative_selector
:
RelativeSelectorCache
pub
relative_selector_filter_map
:
RelativeSelectorFilterMap
}
pub
struct
MatchingContext
<
'
a
Impl
>
where
Impl
:
SelectorImpl
{
matching_mode
:
MatchingMode
pub
bloom_filter
:
Option
<
&
'
a
BloomFilter
>
pub
scope_element
:
Option
<
OpaqueElement
>
pub
current_host
:
Option
<
OpaqueElement
>
visited_handling
:
VisitedHandlingMode
pub
include_starting_style
:
IncludeStartingStyle
pub
has_starting_style
:
bool
nesting_level
:
usize
in_negation
:
bool
pub
pseudo_element_matching_fn
:
Option
<
&
'
a
dyn
Fn
(
&
Impl
:
:
PseudoElement
)
-
>
bool
>
pub
extra_data
:
Impl
:
:
ExtraMatchingData
<
'
a
>
current_relative_selector_anchor
:
Option
<
OpaqueElement
>
pub
considered_relative_selector
:
RelativeSelectorMatchingState
quirks_mode
:
QuirksMode
needs_selector_flags
:
NeedsSelectorFlags
matching_for_invalidation
:
MatchingForInvalidation
pub
selector_caches
:
&
'
a
mut
SelectorCaches
classes_and_ids_case_sensitivity
:
CaseSensitivity
_impl
:
:
:
std
:
:
marker
:
:
PhantomData
<
Impl
>
}
impl
<
'
a
Impl
>
MatchingContext
<
'
a
Impl
>
where
Impl
:
SelectorImpl
{
pub
fn
new
(
matching_mode
:
MatchingMode
bloom_filter
:
Option
<
&
'
a
BloomFilter
>
selector_caches
:
&
'
a
mut
SelectorCaches
quirks_mode
:
QuirksMode
needs_selector_flags
:
NeedsSelectorFlags
matching_for_invalidation
:
MatchingForInvalidation
)
-
>
Self
{
Self
:
:
new_for_visited
(
matching_mode
bloom_filter
selector_caches
VisitedHandlingMode
:
:
AllLinksUnvisited
IncludeStartingStyle
:
:
No
quirks_mode
needs_selector_flags
matching_for_invalidation
)
}
pub
fn
new_for_visited
(
matching_mode
:
MatchingMode
bloom_filter
:
Option
<
&
'
a
BloomFilter
>
selector_caches
:
&
'
a
mut
SelectorCaches
visited_handling
:
VisitedHandlingMode
include_starting_style
:
IncludeStartingStyle
quirks_mode
:
QuirksMode
needs_selector_flags
:
NeedsSelectorFlags
matching_for_invalidation
:
MatchingForInvalidation
)
-
>
Self
{
Self
{
matching_mode
bloom_filter
visited_handling
include_starting_style
has_starting_style
:
false
quirks_mode
classes_and_ids_case_sensitivity
:
quirks_mode
.
classes_and_ids_case_sensitivity
(
)
needs_selector_flags
matching_for_invalidation
scope_element
:
None
current_host
:
None
nesting_level
:
0
in_negation
:
false
pseudo_element_matching_fn
:
None
extra_data
:
Default
:
:
default
(
)
current_relative_selector_anchor
:
None
considered_relative_selector
:
RelativeSelectorMatchingState
:
:
None
selector_caches
_impl
:
:
:
std
:
:
marker
:
:
PhantomData
}
}
#
[
inline
]
pub
fn
nth_index_cache
(
&
mut
self
is_of_type
:
bool
is_from_end
:
bool
selectors
:
&
[
Selector
<
Impl
>
]
)
-
>
&
mut
NthIndexCacheInner
{
self
.
selector_caches
.
nth_index
.
get
(
is_of_type
is_from_end
selectors
)
}
#
[
inline
]
pub
fn
is_nested
(
&
self
)
-
>
bool
{
self
.
nesting_level
!
=
0
}
#
[
inline
]
pub
fn
in_negation
(
&
self
)
-
>
bool
{
self
.
in_negation
}
#
[
inline
]
pub
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
{
self
.
quirks_mode
}
#
[
inline
]
pub
fn
matching_mode
(
&
self
)
-
>
MatchingMode
{
self
.
matching_mode
}
#
[
inline
]
pub
fn
needs_selector_flags
(
&
self
)
-
>
bool
{
self
.
needs_selector_flags
=
=
NeedsSelectorFlags
:
:
Yes
}
#
[
inline
]
pub
fn
matching_for_invalidation
(
&
self
)
-
>
bool
{
self
.
matching_for_invalidation
.
is_for_invalidation
(
)
}
#
[
inline
]
pub
fn
matching_for_invalidation_comparison
(
&
self
)
-
>
Option
<
bool
>
{
match
self
.
matching_for_invalidation
{
MatchingForInvalidation
:
:
No
=
>
None
MatchingForInvalidation
:
:
Yes
=
>
Some
(
false
)
MatchingForInvalidation
:
:
YesForComparison
=
>
Some
(
true
)
}
}
#
[
inline
]
pub
fn
for_invalidation_comparison
<
F
R
>
(
&
mut
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
debug_assert
!
(
self
.
matching_for_invalidation
(
)
"
Not
matching
for
invalidation
?
"
)
;
let
prev
=
self
.
matching_for_invalidation
;
self
.
matching_for_invalidation
=
MatchingForInvalidation
:
:
YesForComparison
;
let
result
=
f
(
self
)
;
self
.
matching_for_invalidation
=
prev
;
result
}
#
[
inline
]
pub
fn
classes_and_ids_case_sensitivity
(
&
self
)
-
>
CaseSensitivity
{
self
.
classes_and_ids_case_sensitivity
}
#
[
inline
]
pub
fn
nest
<
F
R
>
(
&
mut
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
self
.
nesting_level
+
=
1
;
let
result
=
f
(
self
)
;
self
.
nesting_level
-
=
1
;
result
}
#
[
inline
]
pub
fn
nest_for_negation
<
F
R
>
(
&
mut
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
let
old_in_negation
=
self
.
in_negation
;
self
.
in_negation
=
true
;
let
result
=
self
.
nest
(
f
)
;
self
.
in_negation
=
old_in_negation
;
result
}
#
[
inline
]
pub
fn
visited_handling
(
&
self
)
-
>
VisitedHandlingMode
{
self
.
visited_handling
}
#
[
inline
]
pub
fn
with_visited_handling_mode
<
F
R
>
(
&
mut
self
handling_mode
:
VisitedHandlingMode
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
let
original_handling_mode
=
self
.
visited_handling
;
self
.
visited_handling
=
handling_mode
;
let
result
=
f
(
self
)
;
self
.
visited_handling
=
original_handling_mode
;
result
}
#
[
inline
]
pub
fn
with_shadow_host
<
F
E
R
>
(
&
mut
self
host
:
Option
<
E
>
f
:
F
)
-
>
R
where
E
:
Element
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
let
original_host
=
self
.
current_host
.
take
(
)
;
self
.
current_host
=
host
.
map
(
|
h
|
h
.
opaque
(
)
)
;
let
result
=
f
(
self
)
;
self
.
current_host
=
original_host
;
result
}
#
[
inline
]
pub
fn
shadow_host
(
&
self
)
-
>
Option
<
OpaqueElement
>
{
self
.
current_host
}
#
[
inline
]
pub
fn
nest_for_relative_selector
<
F
R
>
(
&
mut
self
anchor
:
OpaqueElement
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
debug_assert
!
(
self
.
current_relative_selector_anchor
.
is_none
(
)
"
Nesting
should
'
ve
been
rejected
at
parse
time
"
)
;
self
.
current_relative_selector_anchor
=
Some
(
anchor
)
;
let
result
=
self
.
nest
(
f
)
;
self
.
current_relative_selector_anchor
=
None
;
result
}
#
[
inline
]
pub
fn
nest_for_scope
<
F
R
>
(
&
mut
self
scope
:
Option
<
OpaqueElement
>
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
let
original_scope_element
=
self
.
scope_element
;
self
.
scope_element
=
scope
;
let
result
=
f
(
self
)
;
self
.
scope_element
=
original_scope_element
;
result
}
#
[
inline
]
pub
fn
nest_for_scope_condition
<
F
R
>
(
&
mut
self
scope
:
Option
<
OpaqueElement
>
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
let
original_matching_mode
=
self
.
matching_mode
;
self
.
matching_mode
=
MatchingMode
:
:
Normal
;
let
result
=
self
.
nest_for_scope
(
scope
f
)
;
self
.
matching_mode
=
original_matching_mode
;
result
}
#
[
inline
]
pub
fn
relative_selector_anchor
(
&
self
)
-
>
Option
<
OpaqueElement
>
{
self
.
current_relative_selector_anchor
}
}
