use
crate
:
:
attr
:
:
CaseSensitivity
;
use
crate
:
:
bloom
:
:
BloomFilter
;
use
crate
:
:
nth_index_cache
:
:
NthIndexCache
;
use
crate
:
:
parser
:
:
SelectorImpl
;
use
crate
:
:
tree
:
:
{
Element
OpaqueElement
}
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
MatchingMode
{
Normal
ForStatelessPseudoElement
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
VisitedHandlingMode
{
AllLinksUnvisited
AllLinksVisitedAndUnvisited
RelevantLinkVisited
}
impl
VisitedHandlingMode
{
#
[
inline
]
pub
fn
matches_visited
(
&
self
)
-
>
bool
{
matches
!
(
*
self
VisitedHandlingMode
:
:
RelevantLinkVisited
|
VisitedHandlingMode
:
:
AllLinksVisitedAndUnvisited
)
}
#
[
inline
]
pub
fn
matches_unvisited
(
&
self
)
-
>
bool
{
matches
!
(
*
self
VisitedHandlingMode
:
:
AllLinksUnvisited
|
VisitedHandlingMode
:
:
AllLinksVisitedAndUnvisited
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
enum
QuirksMode
{
Quirks
LimitedQuirks
NoQuirks
}
impl
QuirksMode
{
#
[
inline
]
pub
fn
classes_and_ids_case_sensitivity
(
self
)
-
>
CaseSensitivity
{
match
self
{
QuirksMode
:
:
NoQuirks
|
QuirksMode
:
:
LimitedQuirks
=
>
CaseSensitivity
:
:
CaseSensitive
QuirksMode
:
:
Quirks
=
>
CaseSensitivity
:
:
AsciiCaseInsensitive
}
}
}
pub
struct
MatchingContext
<
'
a
Impl
>
where
Impl
:
SelectorImpl
{
matching_mode
:
MatchingMode
pub
bloom_filter
:
Option
<
&
'
a
BloomFilter
>
pub
nth_index_cache
:
Option
<
&
'
a
mut
NthIndexCache
>
pub
scope_element
:
Option
<
OpaqueElement
>
pub
current_host
:
Option
<
OpaqueElement
>
visited_handling
:
VisitedHandlingMode
nesting_level
:
usize
in_negation
:
bool
pub
pseudo_element_matching_fn
:
Option
<
&
'
a
dyn
Fn
(
&
Impl
:
:
PseudoElement
)
-
>
bool
>
pub
extra_data
:
Impl
:
:
ExtraMatchingData
quirks_mode
:
QuirksMode
classes_and_ids_case_sensitivity
:
CaseSensitivity
_impl
:
:
:
std
:
:
marker
:
:
PhantomData
<
Impl
>
}
impl
<
'
a
Impl
>
MatchingContext
<
'
a
Impl
>
where
Impl
:
SelectorImpl
{
pub
fn
new
(
matching_mode
:
MatchingMode
bloom_filter
:
Option
<
&
'
a
BloomFilter
>
nth_index_cache
:
Option
<
&
'
a
mut
NthIndexCache
>
quirks_mode
:
QuirksMode
)
-
>
Self
{
Self
:
:
new_for_visited
(
matching_mode
bloom_filter
nth_index_cache
VisitedHandlingMode
:
:
AllLinksUnvisited
quirks_mode
)
}
pub
fn
new_for_visited
(
matching_mode
:
MatchingMode
bloom_filter
:
Option
<
&
'
a
BloomFilter
>
nth_index_cache
:
Option
<
&
'
a
mut
NthIndexCache
>
visited_handling
:
VisitedHandlingMode
quirks_mode
:
QuirksMode
)
-
>
Self
{
Self
{
matching_mode
bloom_filter
visited_handling
nth_index_cache
quirks_mode
classes_and_ids_case_sensitivity
:
quirks_mode
.
classes_and_ids_case_sensitivity
(
)
scope_element
:
None
current_host
:
None
nesting_level
:
0
in_negation
:
false
pseudo_element_matching_fn
:
None
extra_data
:
Default
:
:
default
(
)
_impl
:
:
:
std
:
:
marker
:
:
PhantomData
}
}
#
[
inline
]
pub
fn
set_quirks_mode
(
&
mut
self
quirks_mode
:
QuirksMode
)
{
self
.
quirks_mode
=
quirks_mode
;
self
.
classes_and_ids_case_sensitivity
=
quirks_mode
.
classes_and_ids_case_sensitivity
(
)
;
}
#
[
inline
]
pub
fn
is_nested
(
&
self
)
-
>
bool
{
self
.
nesting_level
!
=
0
}
#
[
inline
]
pub
fn
in_negation
(
&
self
)
-
>
bool
{
self
.
in_negation
}
#
[
inline
]
pub
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
{
self
.
quirks_mode
}
#
[
inline
]
pub
fn
matching_mode
(
&
self
)
-
>
MatchingMode
{
self
.
matching_mode
}
#
[
inline
]
pub
fn
classes_and_ids_case_sensitivity
(
&
self
)
-
>
CaseSensitivity
{
self
.
classes_and_ids_case_sensitivity
}
#
[
inline
]
pub
fn
nest
<
F
R
>
(
&
mut
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
self
.
nesting_level
+
=
1
;
let
result
=
f
(
self
)
;
self
.
nesting_level
-
=
1
;
result
}
#
[
inline
]
pub
fn
nest_for_negation
<
F
R
>
(
&
mut
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
debug_assert
!
(
!
self
.
in_negation
"
Someone
messed
up
parsing
?
"
)
;
self
.
in_negation
=
true
;
let
result
=
self
.
nest
(
f
)
;
self
.
in_negation
=
false
;
result
}
#
[
inline
]
pub
fn
visited_handling
(
&
self
)
-
>
VisitedHandlingMode
{
self
.
visited_handling
}
#
[
inline
]
pub
fn
with_visited_handling_mode
<
F
R
>
(
&
mut
self
handling_mode
:
VisitedHandlingMode
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
let
original_handling_mode
=
self
.
visited_handling
;
self
.
visited_handling
=
handling_mode
;
let
result
=
f
(
self
)
;
self
.
visited_handling
=
original_handling_mode
;
result
}
#
[
inline
]
pub
fn
with_shadow_host
<
F
E
R
>
(
&
mut
self
host
:
Option
<
E
>
f
:
F
)
-
>
R
where
E
:
Element
F
:
FnOnce
(
&
mut
Self
)
-
>
R
{
let
original_host
=
self
.
current_host
.
take
(
)
;
self
.
current_host
=
host
.
map
(
|
h
|
h
.
opaque
(
)
)
;
let
result
=
f
(
self
)
;
self
.
current_host
=
original_host
;
result
}
#
[
inline
]
pub
fn
shadow_host
(
&
self
)
-
>
Option
<
OpaqueElement
>
{
self
.
current_host
.
clone
(
)
}
}
