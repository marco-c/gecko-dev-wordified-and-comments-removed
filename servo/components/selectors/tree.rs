use
crate
:
:
attr
:
:
{
AttrSelectorOperation
CaseSensitivity
NamespaceConstraint
}
;
use
crate
:
:
matching
:
:
{
ElementSelectorFlags
MatchingContext
}
;
use
crate
:
:
parser
:
:
SelectorImpl
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
ptr
:
:
NonNull
;
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
struct
OpaqueElement
(
NonNull
<
(
)
>
)
;
unsafe
impl
Send
for
OpaqueElement
{
}
impl
OpaqueElement
{
pub
fn
new
<
T
>
(
ptr
:
&
T
)
-
>
Self
{
unsafe
{
OpaqueElement
(
NonNull
:
:
new_unchecked
(
ptr
as
*
const
T
as
*
const
(
)
as
*
mut
(
)
)
)
}
}
}
pub
trait
Element
:
Sized
+
Clone
+
Debug
{
type
Impl
:
SelectorImpl
;
fn
opaque
(
&
self
)
-
>
OpaqueElement
;
fn
parent_element
(
&
self
)
-
>
Option
<
Self
>
;
fn
parent_node_is_shadow_root
(
&
self
)
-
>
bool
;
fn
containing_shadow_host
(
&
self
)
-
>
Option
<
Self
>
;
fn
pseudo_element_originating_element
(
&
self
)
-
>
Option
<
Self
>
{
debug_assert
!
(
self
.
is_pseudo_element
(
)
)
;
self
.
parent_element
(
)
}
fn
is_pseudo_element
(
&
self
)
-
>
bool
;
fn
prev_sibling_element
(
&
self
)
-
>
Option
<
Self
>
;
fn
next_sibling_element
(
&
self
)
-
>
Option
<
Self
>
;
fn
is_html_element_in_html_document
(
&
self
)
-
>
bool
;
fn
has_local_name
(
&
self
local_name
:
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
BorrowedLocalName
)
-
>
bool
;
fn
has_namespace
(
&
self
ns
:
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
BorrowedNamespaceUrl
)
-
>
bool
;
fn
is_same_type
(
&
self
other
:
&
Self
)
-
>
bool
;
fn
attr_matches
(
&
self
ns
:
&
NamespaceConstraint
<
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
NamespaceUrl
>
local_name
:
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
LocalName
operation
:
&
AttrSelectorOperation
<
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
AttrValue
>
)
-
>
bool
;
fn
match_non_ts_pseudo_class
(
&
self
pc
:
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
NonTSPseudoClass
context
:
&
mut
MatchingContext
<
Self
:
:
Impl
>
)
-
>
bool
;
fn
match_pseudo_element
(
&
self
pe
:
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
PseudoElement
context
:
&
mut
MatchingContext
<
Self
:
:
Impl
>
)
-
>
bool
;
fn
set_selector_flags
(
&
self
flags
:
ElementSelectorFlags
)
;
fn
apply_selector_flags
(
&
self
flags
:
ElementSelectorFlags
)
{
let
self_flags
=
flags
.
for_self
(
)
;
if
!
self_flags
.
is_empty
(
)
{
self
.
set_selector_flags
(
self_flags
)
;
}
let
parent_flags
=
flags
.
for_parent
(
)
;
if
!
parent_flags
.
is_empty
(
)
{
if
let
Some
(
p
)
=
self
.
parent_element
(
)
{
p
.
set_selector_flags
(
parent_flags
)
;
}
}
}
fn
is_link
(
&
self
)
-
>
bool
;
fn
is_html_slot_element
(
&
self
)
-
>
bool
;
fn
assigned_slot
(
&
self
)
-
>
Option
<
Self
>
{
None
}
fn
has_id
(
&
self
id
:
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
Identifier
case_sensitivity
:
CaseSensitivity
)
-
>
bool
;
fn
has_class
(
&
self
name
:
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
Identifier
case_sensitivity
:
CaseSensitivity
)
-
>
bool
;
fn
imported_part
(
&
self
name
:
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
Identifier
)
-
>
Option
<
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
Identifier
>
;
fn
is_part
(
&
self
name
:
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
Identifier
)
-
>
bool
;
fn
is_empty
(
&
self
)
-
>
bool
;
fn
is_root
(
&
self
)
-
>
bool
;
fn
ignores_nth_child_selectors
(
&
self
)
-
>
bool
{
false
}
}
