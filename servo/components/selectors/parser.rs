use
attr
:
:
{
AttrSelectorOperator
AttrSelectorWithOptionalNamespace
}
;
use
attr
:
:
{
NamespaceConstraint
ParsedAttrSelectorOperation
}
;
use
attr
:
:
{
ParsedCaseSensitivity
SELECTOR_WHITESPACE
}
;
use
bloom
:
:
BLOOM_HASH_MASK
;
use
builder
:
:
{
SelectorBuilder
SpecificityAndFlags
}
;
use
context
:
:
QuirksMode
;
use
cssparser
:
:
{
BasicParseError
BasicParseErrorKind
ParseError
ParseErrorKind
}
;
use
cssparser
:
:
{
CowRcStr
Delimiter
SourceLocation
}
;
use
cssparser
:
:
{
CssStringWriter
Parser
as
CssParser
ToCss
Token
}
;
use
cssparser
:
:
{
parse_nth
serialize_identifier
}
;
use
precomputed_hash
:
:
PrecomputedHash
;
use
servo_arc
:
:
ThinArc
;
use
sink
:
:
Push
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
borrow
:
:
{
Borrow
Cow
}
;
use
std
:
:
fmt
:
:
{
self
Debug
Display
Write
}
;
use
std
:
:
iter
:
:
Rev
;
use
std
:
:
slice
;
use
thin_slice
:
:
ThinBoxedSlice
;
pub
use
visitor
:
:
{
SelectorVisitor
Visit
}
;
pub
trait
PseudoElement
:
Sized
+
ToCss
{
type
Impl
:
SelectorImpl
;
fn
supports_pseudo_class
(
&
self
_pseudo_class
:
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
NonTSPseudoClass
)
-
>
bool
{
false
}
}
pub
trait
NonTSPseudoClass
:
Sized
+
ToCss
{
type
Impl
:
SelectorImpl
;
fn
is_active_or_hover
(
&
self
)
-
>
bool
;
}
fn
to_ascii_lowercase
(
s
:
&
str
)
-
>
Cow
<
str
>
{
if
let
Some
(
first_uppercase
)
=
s
.
bytes
(
)
.
position
(
|
byte
|
byte
>
=
b
'
A
'
&
&
byte
<
=
b
'
Z
'
)
{
let
mut
string
=
s
.
to_owned
(
)
;
string
[
first_uppercase
.
.
]
.
make_ascii_lowercase
(
)
;
string
.
into
(
)
}
else
{
s
.
into
(
)
}
}
pub
type
SelectorParseError
<
'
i
>
=
ParseError
<
'
i
SelectorParseErrorKind
<
'
i
>
>
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
enum
SelectorParseErrorKind
<
'
i
>
{
PseudoElementInComplexSelector
NoQualifiedNameInAttributeSelector
(
Token
<
'
i
>
)
EmptySelector
DanglingCombinator
NonSimpleSelectorInNegation
NonCompoundSelector
UnexpectedTokenInAttributeSelector
(
Token
<
'
i
>
)
PseudoElementExpectedColon
(
Token
<
'
i
>
)
PseudoElementExpectedIdent
(
Token
<
'
i
>
)
NoIdentForPseudo
(
Token
<
'
i
>
)
UnsupportedPseudoClassOrElement
(
CowRcStr
<
'
i
>
)
UnexpectedIdent
(
CowRcStr
<
'
i
>
)
ExpectedNamespace
(
CowRcStr
<
'
i
>
)
ExpectedBarInAttr
(
Token
<
'
i
>
)
BadValueInAttr
(
Token
<
'
i
>
)
InvalidQualNameInAttr
(
Token
<
'
i
>
)
ExplicitNamespaceUnexpectedToken
(
Token
<
'
i
>
)
ClassNeedsIdent
(
Token
<
'
i
>
)
EmptyNegation
}
macro_rules
!
with_all_bounds
{
(
[
(
InSelector
:
tt
)
*
]
[
(
CommonBounds
:
tt
)
*
]
[
(
FromStr
:
tt
)
*
]
)
=
>
{
/
/
/
This
trait
allows
to
define
the
parser
implementation
in
regards
/
/
/
of
pseudo
-
classes
/
elements
/
/
/
/
/
/
NB
:
We
need
Clone
so
that
we
can
derive
(
Clone
)
on
struct
with
that
/
/
/
are
parameterized
on
SelectorImpl
.
See
/
/
/
<
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
26925
>
pub
trait
SelectorImpl
:
Clone
+
Debug
+
Sized
+
'
static
{
type
ExtraMatchingData
:
Sized
+
Default
+
'
static
;
type
AttrValue
:
(
InSelector
)
*
;
type
Identifier
:
(
InSelector
)
*
;
type
ClassName
:
(
InSelector
)
*
;
type
LocalName
:
(
InSelector
)
*
+
Borrow
<
Self
:
:
BorrowedLocalName
>
;
type
NamespaceUrl
:
(
CommonBounds
)
*
+
Default
+
Borrow
<
Self
:
:
BorrowedNamespaceUrl
>
;
type
NamespacePrefix
:
(
InSelector
)
*
+
Default
;
type
BorrowedNamespaceUrl
:
?
Sized
+
Eq
;
type
BorrowedLocalName
:
?
Sized
+
Eq
;
/
/
/
non
tree
-
structural
pseudo
-
classes
/
/
/
(
see
:
https
:
/
/
drafts
.
csswg
.
org
/
selectors
/
#
structural
-
pseudos
)
type
NonTSPseudoClass
:
(
CommonBounds
)
*
+
NonTSPseudoClass
<
Impl
=
Self
>
;
/
/
/
pseudo
-
elements
type
PseudoElement
:
(
CommonBounds
)
*
+
PseudoElement
<
Impl
=
Self
>
;
}
}
}
macro_rules
!
with_bounds
{
(
[
(
CommonBounds
:
tt
)
*
]
[
(
FromStr
:
tt
)
*
]
)
=
>
{
with_all_bounds
!
{
[
(
CommonBounds
)
*
+
(
FromStr
)
*
+
Display
]
[
(
CommonBounds
)
*
]
[
(
FromStr
)
*
]
}
}
}
with_bounds
!
{
[
Clone
+
Eq
]
[
for
<
'
a
>
From
<
&
'
a
str
>
]
}
pub
trait
Parser
<
'
i
>
{
type
Impl
:
SelectorImpl
;
type
Error
:
'
i
+
From
<
SelectorParseErrorKind
<
'
i
>
>
;
fn
pseudo_element_allows_single_colon
(
name
:
&
str
)
-
>
bool
{
is_css2_pseudo_element
(
name
)
}
fn
parse_slotted
(
&
self
)
-
>
bool
{
false
}
fn
parse_host
(
&
self
)
-
>
bool
{
false
}
fn
parse_non_ts_pseudo_class
(
&
self
location
:
SourceLocation
name
:
CowRcStr
<
'
i
>
)
-
>
Result
<
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
NonTSPseudoClass
ParseError
<
'
i
Self
:
:
Error
>
>
{
Err
(
location
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnsupportedPseudoClassOrElement
(
name
)
)
)
}
fn
parse_non_ts_functional_pseudo_class
<
'
t
>
(
&
self
name
:
CowRcStr
<
'
i
>
arguments
:
&
mut
CssParser
<
'
i
'
t
>
)
-
>
Result
<
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
NonTSPseudoClass
ParseError
<
'
i
Self
:
:
Error
>
>
{
Err
(
arguments
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnsupportedPseudoClassOrElement
(
name
)
)
)
}
fn
parse_pseudo_element
(
&
self
location
:
SourceLocation
name
:
CowRcStr
<
'
i
>
)
-
>
Result
<
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
PseudoElement
ParseError
<
'
i
Self
:
:
Error
>
>
{
Err
(
location
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnsupportedPseudoClassOrElement
(
name
)
)
)
}
fn
parse_functional_pseudo_element
<
'
t
>
(
&
self
name
:
CowRcStr
<
'
i
>
arguments
:
&
mut
CssParser
<
'
i
'
t
>
)
-
>
Result
<
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
PseudoElement
ParseError
<
'
i
Self
:
:
Error
>
>
{
Err
(
arguments
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnsupportedPseudoClassOrElement
(
name
)
)
)
}
fn
default_namespace
(
&
self
)
-
>
Option
<
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
NamespaceUrl
>
{
None
}
fn
namespace_for_prefix
(
&
self
_prefix
:
&
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
NamespacePrefix
)
-
>
Option
<
<
Self
:
:
Impl
as
SelectorImpl
>
:
:
NamespaceUrl
>
{
None
}
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
)
]
pub
struct
SelectorList
<
Impl
:
SelectorImpl
>
(
pub
SmallVec
<
[
Selector
<
Impl
>
;
1
]
>
)
;
impl
<
Impl
:
SelectorImpl
>
SelectorList
<
Impl
>
{
pub
fn
parse
<
'
i
'
t
P
>
(
parser
:
&
P
input
:
&
mut
CssParser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
{
let
mut
values
=
SmallVec
:
:
new
(
)
;
loop
{
values
.
push
(
input
.
parse_until_before
(
Delimiter
:
:
Comma
|
input
|
parse_selector
(
parser
input
)
)
?
)
;
match
input
.
next
(
)
{
Err
(
_
)
=
>
return
Ok
(
SelectorList
(
values
)
)
Ok
(
&
Token
:
:
Comma
)
=
>
continue
Ok
(
_
)
=
>
unreachable
!
(
)
}
}
}
pub
fn
from_vec
(
v
:
Vec
<
Selector
<
Impl
>
>
)
-
>
Self
{
SelectorList
(
SmallVec
:
:
from_vec
(
v
)
)
}
}
fn
parse_inner_compound_selector
<
'
i
'
t
P
Impl
>
(
parser
:
&
P
input
:
&
mut
CssParser
<
'
i
'
t
>
)
-
>
Result
<
Selector
<
Impl
>
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
Impl
:
SelectorImpl
{
let
location
=
input
.
current_source_location
(
)
;
let
selector
=
Selector
:
:
parse
(
parser
input
)
?
;
if
selector
.
iter_raw_match_order
(
)
.
any
(
|
s
|
s
.
is_combinator
(
)
)
{
return
Err
(
location
.
new_custom_error
(
SelectorParseErrorKind
:
:
NonCompoundSelector
)
)
;
}
Ok
(
selector
)
}
pub
fn
parse_compound_selector_list
<
'
i
'
t
P
Impl
>
(
parser
:
&
P
input
:
&
mut
CssParser
<
'
i
'
t
>
)
-
>
Result
<
Box
<
[
Selector
<
Impl
>
]
>
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
Impl
:
SelectorImpl
{
input
.
parse_comma_separated
(
|
input
|
parse_inner_compound_selector
(
parser
input
)
)
.
map
(
|
selectors
|
selectors
.
into_boxed_slice
(
)
)
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
)
]
pub
struct
AncestorHashes
{
pub
packed_hashes
:
[
u32
;
3
]
}
impl
AncestorHashes
{
pub
fn
new
<
Impl
:
SelectorImpl
>
(
selector
:
&
Selector
<
Impl
>
quirks_mode
:
QuirksMode
)
-
>
Self
where
Impl
:
:
Identifier
:
PrecomputedHash
Impl
:
:
ClassName
:
PrecomputedHash
Impl
:
:
LocalName
:
PrecomputedHash
Impl
:
:
NamespaceUrl
:
PrecomputedHash
{
Self
:
:
from_iter
(
selector
.
iter
(
)
quirks_mode
)
}
fn
from_iter
<
Impl
:
SelectorImpl
>
(
iter
:
SelectorIter
<
Impl
>
quirks_mode
:
QuirksMode
)
-
>
Self
where
Impl
:
:
Identifier
:
PrecomputedHash
Impl
:
:
ClassName
:
PrecomputedHash
Impl
:
:
LocalName
:
PrecomputedHash
Impl
:
:
NamespaceUrl
:
PrecomputedHash
{
let
mut
hashes
=
[
0u32
;
4
]
;
let
mut
hash_iter
=
AncestorIter
:
:
new
(
iter
)
.
filter_map
(
|
x
|
x
.
ancestor_hash
(
quirks_mode
)
)
;
for
i
in
0
.
.
4
{
hashes
[
i
]
=
match
hash_iter
.
next
(
)
{
Some
(
x
)
=
>
x
&
BLOOM_HASH_MASK
None
=
>
break
}
}
let
fourth
=
hashes
[
3
]
;
if
fourth
!
=
0
{
hashes
[
0
]
|
=
(
fourth
&
0x000000ff
)
<
<
24
;
hashes
[
1
]
|
=
(
fourth
&
0x0000ff00
)
<
<
16
;
hashes
[
2
]
|
=
(
fourth
&
0x00ff0000
)
<
<
8
;
}
AncestorHashes
{
packed_hashes
:
[
hashes
[
0
]
hashes
[
1
]
hashes
[
2
]
]
}
}
pub
fn
fourth_hash
(
&
self
)
-
>
u32
{
(
(
self
.
packed_hashes
[
0
]
&
0xff000000
)
>
>
24
)
|
(
(
self
.
packed_hashes
[
1
]
&
0xff000000
)
>
>
16
)
|
(
(
self
.
packed_hashes
[
2
]
&
0xff000000
)
>
>
8
)
}
}
impl
<
Impl
:
SelectorImpl
>
Visit
for
Selector
<
Impl
>
where
Impl
:
:
NonTSPseudoClass
:
Visit
<
Impl
=
Impl
>
{
type
Impl
=
Impl
;
fn
visit
<
V
>
(
&
self
visitor
:
&
mut
V
)
-
>
bool
where
V
:
SelectorVisitor
<
Impl
=
Impl
>
{
let
mut
current
=
self
.
iter
(
)
;
let
mut
combinator
=
None
;
loop
{
if
!
visitor
.
visit_complex_selector
(
combinator
)
{
return
false
;
}
for
selector
in
&
mut
current
{
if
!
selector
.
visit
(
visitor
)
{
return
false
;
}
}
combinator
=
current
.
next_sequence
(
)
;
if
combinator
.
is_none
(
)
{
break
;
}
}
true
}
}
impl
<
Impl
:
SelectorImpl
>
Visit
for
Component
<
Impl
>
where
Impl
:
:
NonTSPseudoClass
:
Visit
<
Impl
=
Impl
>
{
type
Impl
=
Impl
;
fn
visit
<
V
>
(
&
self
visitor
:
&
mut
V
)
-
>
bool
where
V
:
SelectorVisitor
<
Impl
=
Impl
>
{
use
self
:
:
Component
:
:
*
;
if
!
visitor
.
visit_simple_selector
(
self
)
{
return
false
;
}
match
*
self
{
Slotted
(
ref
selector
)
=
>
{
if
!
selector
.
visit
(
visitor
)
{
return
false
;
}
}
Host
(
Some
(
ref
selector
)
)
=
>
{
if
!
selector
.
visit
(
visitor
)
{
return
false
;
}
}
Negation
(
ref
negated
)
=
>
{
for
component
in
negated
.
iter
(
)
{
if
!
component
.
visit
(
visitor
)
{
return
false
;
}
}
}
AttributeInNoNamespaceExists
{
ref
local_name
ref
local_name_lower
}
=
>
{
if
!
visitor
.
visit_attribute_selector
(
&
NamespaceConstraint
:
:
Specific
(
&
namespace_empty_string
:
:
<
Impl
>
(
)
)
local_name
local_name_lower
)
{
return
false
;
}
}
AttributeInNoNamespace
{
ref
local_name
never_matches
.
.
}
if
!
never_matches
=
>
{
if
!
visitor
.
visit_attribute_selector
(
&
NamespaceConstraint
:
:
Specific
(
&
namespace_empty_string
:
:
<
Impl
>
(
)
)
local_name
local_name
)
{
return
false
;
}
}
AttributeOther
(
ref
attr_selector
)
if
!
attr_selector
.
never_matches
=
>
{
let
empty_string
;
let
namespace
=
match
attr_selector
.
namespace
(
)
{
Some
(
ns
)
=
>
ns
None
=
>
{
empty_string
=
:
:
parser
:
:
namespace_empty_string
:
:
<
Impl
>
(
)
;
NamespaceConstraint
:
:
Specific
(
&
empty_string
)
}
}
;
if
!
visitor
.
visit_attribute_selector
(
&
namespace
&
attr_selector
.
local_name
&
attr_selector
.
local_name_lower
)
{
return
false
;
}
}
NonTSPseudoClass
(
ref
pseudo_class
)
=
>
{
if
!
pseudo_class
.
visit
(
visitor
)
{
return
false
;
}
}
_
=
>
{
}
}
true
}
}
pub
fn
namespace_empty_string
<
Impl
:
SelectorImpl
>
(
)
-
>
Impl
:
:
NamespaceUrl
{
Impl
:
:
NamespaceUrl
:
:
default
(
)
}
#
[
derive
(
Clone
Eq
PartialEq
)
]
pub
struct
Selector
<
Impl
:
SelectorImpl
>
(
ThinArc
<
SpecificityAndFlags
Component
<
Impl
>
>
)
;
impl
<
Impl
:
SelectorImpl
>
Selector
<
Impl
>
{
#
[
inline
]
pub
fn
specificity
(
&
self
)
-
>
u32
{
self
.
0
.
header
.
header
.
specificity
(
)
}
#
[
inline
]
pub
fn
has_pseudo_element
(
&
self
)
-
>
bool
{
self
.
0
.
header
.
header
.
has_pseudo_element
(
)
}
#
[
inline
]
pub
fn
is_slotted
(
&
self
)
-
>
bool
{
self
.
0
.
header
.
header
.
is_slotted
(
)
}
#
[
inline
]
pub
fn
pseudo_element
(
&
self
)
-
>
Option
<
&
Impl
:
:
PseudoElement
>
{
if
!
self
.
has_pseudo_element
(
)
{
return
None
;
}
for
component
in
self
.
iter
(
)
{
if
let
Component
:
:
PseudoElement
(
ref
pseudo
)
=
*
component
{
return
Some
(
pseudo
)
;
}
}
debug_assert
!
(
false
"
has_pseudo_element
lied
!
"
)
;
None
}
#
[
inline
]
pub
fn
is_universal
(
&
self
)
-
>
bool
{
self
.
iter_raw_match_order
(
)
.
all
(
|
c
|
{
matches
!
(
*
c
Component
:
:
ExplicitUniversalType
|
Component
:
:
ExplicitAnyNamespace
|
Component
:
:
Combinator
(
Combinator
:
:
PseudoElement
)
|
Component
:
:
PseudoElement
(
.
.
)
)
}
)
}
#
[
inline
]
pub
fn
iter
(
&
self
)
-
>
SelectorIter
<
Impl
>
{
SelectorIter
{
iter
:
self
.
iter_raw_match_order
(
)
next_combinator
:
None
}
}
#
[
inline
]
pub
fn
is_featureless_host_selector_or_pseudo_element
(
&
self
)
-
>
bool
{
let
mut
iter
=
self
.
iter
(
)
;
if
!
self
.
has_pseudo_element
(
)
{
return
iter
.
is_featureless_host_selector
(
)
;
}
for
_
in
&
mut
iter
{
}
match
iter
.
next_sequence
(
)
{
None
=
>
return
false
Some
(
combinator
)
=
>
{
debug_assert_eq
!
(
combinator
Combinator
:
:
PseudoElement
)
;
}
}
iter
.
is_featureless_host_selector
(
)
}
#
[
inline
]
pub
fn
iter_from
(
&
self
offset
:
usize
)
-
>
SelectorIter
<
Impl
>
{
let
iter
=
self
.
0
.
slice
[
offset
.
.
]
.
iter
(
)
;
SelectorIter
{
iter
:
iter
next_combinator
:
None
}
}
#
[
inline
]
pub
fn
combinator_at_match_order
(
&
self
index
:
usize
)
-
>
Combinator
{
match
self
.
0
.
slice
[
index
]
{
Component
:
:
Combinator
(
c
)
=
>
c
ref
other
=
>
panic
!
(
"
Not
a
combinator
:
{
:
?
}
{
:
?
}
index
:
{
}
"
other
self
index
)
}
}
#
[
inline
]
pub
fn
iter_raw_match_order
(
&
self
)
-
>
slice
:
:
Iter
<
Component
<
Impl
>
>
{
self
.
0
.
slice
.
iter
(
)
}
#
[
inline
]
pub
fn
combinator_at_parse_order
(
&
self
index
:
usize
)
-
>
Combinator
{
match
self
.
0
.
slice
[
self
.
len
(
)
-
index
-
1
]
{
Component
:
:
Combinator
(
c
)
=
>
c
ref
other
=
>
panic
!
(
"
Not
a
combinator
:
{
:
?
}
{
:
?
}
index
:
{
}
"
other
self
index
)
}
}
#
[
inline
]
pub
fn
iter_raw_parse_order_from
(
&
self
offset
:
usize
)
-
>
Rev
<
slice
:
:
Iter
<
Component
<
Impl
>
>
>
{
self
.
0
.
slice
[
.
.
self
.
len
(
)
-
offset
]
.
iter
(
)
.
rev
(
)
}
pub
fn
from_vec
(
vec
:
Vec
<
Component
<
Impl
>
>
specificity_and_flags
:
u32
)
-
>
Self
{
let
mut
builder
=
SelectorBuilder
:
:
default
(
)
;
for
component
in
vec
.
into_iter
(
)
{
if
let
Some
(
combinator
)
=
component
.
as_combinator
(
)
{
builder
.
push_combinator
(
combinator
)
;
}
else
{
builder
.
push_simple_selector
(
component
)
;
}
}
let
spec
=
SpecificityAndFlags
(
specificity_and_flags
)
;
Selector
(
builder
.
build_with_specificity_and_flags
(
spec
)
)
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
0
.
slice
.
len
(
)
}
pub
fn
thin_arc_heap_ptr
(
&
self
)
-
>
*
const
:
:
std
:
:
os
:
:
raw
:
:
c_void
{
self
.
0
.
heap_ptr
(
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
SelectorIter
<
'
a
Impl
:
'
a
+
SelectorImpl
>
{
iter
:
slice
:
:
Iter
<
'
a
Component
<
Impl
>
>
next_combinator
:
Option
<
Combinator
>
}
impl
<
'
a
Impl
:
'
a
+
SelectorImpl
>
SelectorIter
<
'
a
Impl
>
{
#
[
inline
]
pub
fn
next_sequence
(
&
mut
self
)
-
>
Option
<
Combinator
>
{
self
.
next_combinator
.
take
(
)
}
#
[
inline
]
pub
(
crate
)
fn
is_featureless_host_selector
(
&
mut
self
)
-
>
bool
{
self
.
all
(
|
component
|
matches
!
(
*
component
Component
:
:
Host
(
.
.
)
)
)
&
&
self
.
next_sequence
(
)
.
is_none
(
)
}
#
[
inline
]
pub
fn
selector_length
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
'
a
Impl
:
SelectorImpl
>
Iterator
for
SelectorIter
<
'
a
Impl
>
{
type
Item
=
&
'
a
Component
<
Impl
>
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
debug_assert
!
(
self
.
next_combinator
.
is_none
(
)
"
You
should
call
next_sequence
!
"
)
;
match
*
self
.
iter
.
next
(
)
?
{
Component
:
:
Combinator
(
c
)
=
>
{
self
.
next_combinator
=
Some
(
c
)
;
None
}
ref
x
=
>
Some
(
x
)
}
}
}
impl
<
'
a
Impl
:
SelectorImpl
>
fmt
:
:
Debug
for
SelectorIter
<
'
a
Impl
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
iter
=
self
.
iter
.
clone
(
)
.
rev
(
)
;
for
component
in
iter
{
component
.
to_css
(
f
)
?
}
Ok
(
(
)
)
}
}
struct
AncestorIter
<
'
a
Impl
:
'
a
+
SelectorImpl
>
(
SelectorIter
<
'
a
Impl
>
)
;
impl
<
'
a
Impl
:
'
a
+
SelectorImpl
>
AncestorIter
<
'
a
Impl
>
{
fn
new
(
inner
:
SelectorIter
<
'
a
Impl
>
)
-
>
Self
{
let
mut
result
=
AncestorIter
(
inner
)
;
result
.
skip_until_ancestor
(
)
;
result
}
fn
skip_until_ancestor
(
&
mut
self
)
{
loop
{
while
self
.
0
.
next
(
)
.
is_some
(
)
{
}
if
self
.
0
.
next_sequence
(
)
.
map_or
(
true
|
x
|
{
matches
!
(
x
Combinator
:
:
Child
|
Combinator
:
:
Descendant
)
}
)
{
break
;
}
}
}
}
impl
<
'
a
Impl
:
SelectorImpl
>
Iterator
for
AncestorIter
<
'
a
Impl
>
{
type
Item
=
&
'
a
Component
<
Impl
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
next
=
self
.
0
.
next
(
)
;
if
next
.
is_some
(
)
{
return
next
;
}
if
let
Some
(
combinator
)
=
self
.
0
.
next_sequence
(
)
{
if
!
matches
!
(
combinator
Combinator
:
:
Child
|
Combinator
:
:
Descendant
)
{
self
.
skip_until_ancestor
(
)
;
}
}
self
.
0
.
next
(
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
Combinator
{
Child
Descendant
NextSibling
LaterSibling
PseudoElement
SlotAssignment
}
impl
Combinator
{
#
[
inline
]
pub
fn
is_ancestor
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Combinator
:
:
Child
|
Combinator
:
:
Descendant
|
Combinator
:
:
PseudoElement
|
Combinator
:
:
SlotAssignment
)
}
#
[
inline
]
pub
fn
is_pseudo_element
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Combinator
:
:
PseudoElement
)
}
#
[
inline
]
pub
fn
is_sibling
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Combinator
:
:
NextSibling
|
Combinator
:
:
LaterSibling
)
}
}
#
[
derive
(
Clone
Eq
PartialEq
)
]
pub
enum
Component
<
Impl
:
SelectorImpl
>
{
Combinator
(
Combinator
)
ExplicitAnyNamespace
ExplicitNoNamespace
DefaultNamespace
(
Impl
:
:
NamespaceUrl
)
Namespace
(
Impl
:
:
NamespacePrefix
Impl
:
:
NamespaceUrl
)
ExplicitUniversalType
LocalName
(
LocalName
<
Impl
>
)
ID
(
Impl
:
:
Identifier
)
Class
(
Impl
:
:
ClassName
)
AttributeInNoNamespaceExists
{
local_name
:
Impl
:
:
LocalName
local_name_lower
:
Impl
:
:
LocalName
}
AttributeInNoNamespace
{
local_name
:
Impl
:
:
LocalName
operator
:
AttrSelectorOperator
value
:
Impl
:
:
AttrValue
case_sensitivity
:
ParsedCaseSensitivity
never_matches
:
bool
}
AttributeOther
(
Box
<
AttrSelectorWithOptionalNamespace
<
Impl
>
>
)
Negation
(
ThinBoxedSlice
<
Component
<
Impl
>
>
)
FirstChild
LastChild
OnlyChild
Root
Empty
Scope
NthChild
(
i32
i32
)
NthLastChild
(
i32
i32
)
NthOfType
(
i32
i32
)
NthLastOfType
(
i32
i32
)
FirstOfType
LastOfType
OnlyOfType
NonTSPseudoClass
(
Impl
:
:
NonTSPseudoClass
)
Slotted
(
Selector
<
Impl
>
)
Host
(
Option
<
Selector
<
Impl
>
>
)
PseudoElement
(
Impl
:
:
PseudoElement
)
}
impl
<
Impl
:
SelectorImpl
>
Component
<
Impl
>
{
fn
ancestor_hash
(
&
self
quirks_mode
:
QuirksMode
)
-
>
Option
<
u32
>
where
Impl
:
:
Identifier
:
PrecomputedHash
Impl
:
:
ClassName
:
PrecomputedHash
Impl
:
:
LocalName
:
PrecomputedHash
Impl
:
:
NamespaceUrl
:
PrecomputedHash
{
match
*
self
{
Component
:
:
LocalName
(
LocalName
{
ref
name
ref
lower_name
}
)
=
>
{
if
name
=
=
lower_name
{
Some
(
name
.
precomputed_hash
(
)
)
}
else
{
None
}
}
Component
:
:
DefaultNamespace
(
ref
url
)
|
Component
:
:
Namespace
(
_
ref
url
)
=
>
{
Some
(
url
.
precomputed_hash
(
)
)
}
Component
:
:
ID
(
ref
id
)
if
quirks_mode
!
=
QuirksMode
:
:
Quirks
=
>
{
Some
(
id
.
precomputed_hash
(
)
)
}
Component
:
:
Class
(
ref
class
)
if
quirks_mode
!
=
QuirksMode
:
:
Quirks
=
>
{
Some
(
class
.
precomputed_hash
(
)
)
}
_
=
>
None
}
}
pub
fn
is_combinator
(
&
self
)
-
>
bool
{
matches
!
(
*
self
Component
:
:
Combinator
(
_
)
)
}
pub
fn
as_combinator
(
&
self
)
-
>
Option
<
Combinator
>
{
match
*
self
{
Component
:
:
Combinator
(
c
)
=
>
Some
(
c
)
_
=
>
None
}
}
}
#
[
derive
(
Clone
Eq
PartialEq
)
]
pub
struct
LocalName
<
Impl
:
SelectorImpl
>
{
pub
name
:
Impl
:
:
LocalName
pub
lower_name
:
Impl
:
:
LocalName
}
impl
<
Impl
:
SelectorImpl
>
Debug
for
Selector
<
Impl
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
Selector
(
"
)
?
;
self
.
to_css
(
f
)
?
;
write
!
(
f
"
specificity
=
0x
{
:
x
}
)
"
self
.
specificity
(
)
)
}
}
impl
<
Impl
:
SelectorImpl
>
Debug
for
Component
<
Impl
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
to_css
(
f
)
}
}
impl
<
Impl
:
SelectorImpl
>
Debug
for
AttrSelectorWithOptionalNamespace
<
Impl
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
to_css
(
f
)
}
}
impl
<
Impl
:
SelectorImpl
>
Debug
for
LocalName
<
Impl
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
to_css
(
f
)
}
}
impl
<
Impl
:
SelectorImpl
>
ToCss
for
SelectorList
<
Impl
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
let
mut
iter
=
self
.
0
.
iter
(
)
;
let
first
=
iter
.
next
(
)
.
expect
(
"
Empty
SelectorList
should
contain
at
least
one
selector
"
)
;
first
.
to_css
(
dest
)
?
;
for
selector
in
iter
{
dest
.
write_str
(
"
"
)
?
;
selector
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
impl
<
Impl
:
SelectorImpl
>
ToCss
for
Selector
<
Impl
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
let
mut
combinators
=
self
.
iter_raw_match_order
(
)
.
rev
(
)
.
filter_map
(
|
x
|
x
.
as_combinator
(
)
)
;
let
compound_selectors
=
self
.
iter_raw_match_order
(
)
.
as_slice
(
)
.
split
(
|
x
|
x
.
is_combinator
(
)
)
.
rev
(
)
;
let
mut
combinators_exhausted
=
false
;
for
compound
in
compound_selectors
{
debug_assert
!
(
!
combinators_exhausted
)
;
if
compound
.
is_empty
(
)
{
continue
;
}
let
(
can_elide_namespace
first_non_namespace
)
=
match
compound
[
0
]
{
Component
:
:
ExplicitAnyNamespace
|
Component
:
:
ExplicitNoNamespace
|
Component
:
:
Namespace
(
.
.
)
=
>
(
false
1
)
Component
:
:
DefaultNamespace
(
.
.
)
=
>
(
true
1
)
_
=
>
(
true
0
)
}
;
let
mut
perform_step_2
=
true
;
let
next_combinator
=
combinators
.
next
(
)
;
if
first_non_namespace
=
=
compound
.
len
(
)
-
1
{
match
(
next_combinator
&
compound
[
first_non_namespace
]
)
{
(
Some
(
Combinator
:
:
PseudoElement
)
_
)
|
(
Some
(
Combinator
:
:
SlotAssignment
)
_
)
=
>
(
)
(
_
&
Component
:
:
ExplicitUniversalType
)
=
>
{
for
simple
in
compound
.
iter
(
)
{
simple
.
to_css
(
dest
)
?
;
}
perform_step_2
=
false
;
}
_
=
>
(
)
}
}
if
perform_step_2
{
for
simple
in
compound
.
iter
(
)
{
if
let
Component
:
:
ExplicitUniversalType
=
*
simple
{
if
can_elide_namespace
{
continue
;
}
}
simple
.
to_css
(
dest
)
?
;
}
}
match
next_combinator
{
Some
(
c
)
=
>
c
.
to_css
(
dest
)
?
None
=
>
combinators_exhausted
=
true
}
;
}
Ok
(
(
)
)
}
}
impl
ToCss
for
Combinator
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
Combinator
:
:
Child
=
>
dest
.
write_str
(
"
>
"
)
Combinator
:
:
Descendant
=
>
dest
.
write_str
(
"
"
)
Combinator
:
:
NextSibling
=
>
dest
.
write_str
(
"
+
"
)
Combinator
:
:
LaterSibling
=
>
dest
.
write_str
(
"
~
"
)
Combinator
:
:
PseudoElement
=
>
Ok
(
(
)
)
Combinator
:
:
SlotAssignment
=
>
Ok
(
(
)
)
}
}
}
impl
<
Impl
:
SelectorImpl
>
ToCss
for
Component
<
Impl
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
use
self
:
:
Component
:
:
*
;
fn
write_affine
<
W
>
(
dest
:
&
mut
W
a
:
i32
b
:
i32
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
(
a
b
)
{
(
0
0
)
=
>
dest
.
write_char
(
'
0
'
)
(
1
0
)
=
>
dest
.
write_char
(
'
n
'
)
(
-
1
0
)
=
>
dest
.
write_str
(
"
-
n
"
)
(
_
0
)
=
>
write
!
(
dest
"
{
}
n
"
a
)
(
0
_
)
=
>
write
!
(
dest
"
{
}
"
b
)
(
1
_
)
=
>
write
!
(
dest
"
n
{
:
+
}
"
b
)
(
-
1
_
)
=
>
write
!
(
dest
"
-
n
{
:
+
}
"
b
)
(
_
_
)
=
>
write
!
(
dest
"
{
}
n
{
:
+
}
"
a
b
)
}
}
match
*
self
{
Combinator
(
ref
c
)
=
>
c
.
to_css
(
dest
)
Slotted
(
ref
selector
)
=
>
{
dest
.
write_str
(
"
:
:
slotted
(
"
)
?
;
selector
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
)
'
)
}
PseudoElement
(
ref
p
)
=
>
p
.
to_css
(
dest
)
ID
(
ref
s
)
=
>
{
dest
.
write_char
(
'
#
'
)
?
;
display_to_css_identifier
(
s
dest
)
}
Class
(
ref
s
)
=
>
{
dest
.
write_char
(
'
.
'
)
?
;
display_to_css_identifier
(
s
dest
)
}
LocalName
(
ref
s
)
=
>
s
.
to_css
(
dest
)
ExplicitUniversalType
=
>
dest
.
write_char
(
'
*
'
)
DefaultNamespace
(
_
)
=
>
Ok
(
(
)
)
ExplicitNoNamespace
=
>
dest
.
write_char
(
'
|
'
)
ExplicitAnyNamespace
=
>
dest
.
write_str
(
"
*
|
"
)
Namespace
(
ref
prefix
_
)
=
>
{
display_to_css_identifier
(
prefix
dest
)
?
;
dest
.
write_char
(
'
|
'
)
}
AttributeInNoNamespaceExists
{
ref
local_name
.
.
}
=
>
{
dest
.
write_char
(
'
[
'
)
?
;
display_to_css_identifier
(
local_name
dest
)
?
;
dest
.
write_char
(
'
]
'
)
}
AttributeInNoNamespace
{
ref
local_name
operator
ref
value
case_sensitivity
.
.
}
=
>
{
dest
.
write_char
(
'
[
'
)
?
;
display_to_css_identifier
(
local_name
dest
)
?
;
operator
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
"
'
)
?
;
write
!
(
CssStringWriter
:
:
new
(
dest
)
"
{
}
"
value
)
?
;
dest
.
write_char
(
'
"
'
)
?
;
match
case_sensitivity
{
ParsedCaseSensitivity
:
:
CaseSensitive
|
ParsedCaseSensitivity
:
:
AsciiCaseInsensitiveIfInHtmlElementInHtmlDocument
=
>
{
}
ParsedCaseSensitivity
:
:
AsciiCaseInsensitive
=
>
dest
.
write_str
(
"
i
"
)
?
}
dest
.
write_char
(
'
]
'
)
}
AttributeOther
(
ref
attr_selector
)
=
>
attr_selector
.
to_css
(
dest
)
Negation
(
ref
arg
)
=
>
{
dest
.
write_str
(
"
:
not
(
"
)
?
;
for
component
in
arg
.
iter
(
)
{
component
.
to_css
(
dest
)
?
;
}
dest
.
write_str
(
"
)
"
)
}
FirstChild
=
>
dest
.
write_str
(
"
:
first
-
child
"
)
LastChild
=
>
dest
.
write_str
(
"
:
last
-
child
"
)
OnlyChild
=
>
dest
.
write_str
(
"
:
only
-
child
"
)
Root
=
>
dest
.
write_str
(
"
:
root
"
)
Empty
=
>
dest
.
write_str
(
"
:
empty
"
)
Scope
=
>
dest
.
write_str
(
"
:
scope
"
)
Host
(
ref
selector
)
=
>
{
dest
.
write_str
(
"
:
host
"
)
?
;
if
let
Some
(
ref
selector
)
=
*
selector
{
dest
.
write_char
(
'
(
'
)
?
;
selector
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
)
'
)
?
;
}
Ok
(
(
)
)
}
FirstOfType
=
>
dest
.
write_str
(
"
:
first
-
of
-
type
"
)
LastOfType
=
>
dest
.
write_str
(
"
:
last
-
of
-
type
"
)
OnlyOfType
=
>
dest
.
write_str
(
"
:
only
-
of
-
type
"
)
NthChild
(
a
b
)
|
NthLastChild
(
a
b
)
|
NthOfType
(
a
b
)
|
NthLastOfType
(
a
b
)
=
>
{
match
*
self
{
NthChild
(
_
_
)
=
>
dest
.
write_str
(
"
:
nth
-
child
(
"
)
?
NthLastChild
(
_
_
)
=
>
dest
.
write_str
(
"
:
nth
-
last
-
child
(
"
)
?
NthOfType
(
_
_
)
=
>
dest
.
write_str
(
"
:
nth
-
of
-
type
(
"
)
?
NthLastOfType
(
_
_
)
=
>
dest
.
write_str
(
"
:
nth
-
last
-
of
-
type
(
"
)
?
_
=
>
unreachable
!
(
)
}
write_affine
(
dest
a
b
)
?
;
dest
.
write_char
(
'
)
'
)
}
NonTSPseudoClass
(
ref
pseudo
)
=
>
pseudo
.
to_css
(
dest
)
}
}
}
impl
<
Impl
:
SelectorImpl
>
ToCss
for
AttrSelectorWithOptionalNamespace
<
Impl
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_char
(
'
[
'
)
?
;
match
self
.
namespace
{
Some
(
NamespaceConstraint
:
:
Specific
(
(
ref
prefix
_
)
)
)
=
>
{
display_to_css_identifier
(
prefix
dest
)
?
;
dest
.
write_char
(
'
|
'
)
?
}
Some
(
NamespaceConstraint
:
:
Any
)
=
>
dest
.
write_str
(
"
*
|
"
)
?
None
=
>
{
}
}
display_to_css_identifier
(
&
self
.
local_name
dest
)
?
;
match
self
.
operation
{
ParsedAttrSelectorOperation
:
:
Exists
=
>
{
}
ParsedAttrSelectorOperation
:
:
WithValue
{
operator
case_sensitivity
ref
expected_value
}
=
>
{
operator
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
"
'
)
?
;
write
!
(
CssStringWriter
:
:
new
(
dest
)
"
{
}
"
expected_value
)
?
;
dest
.
write_char
(
'
"
'
)
?
;
match
case_sensitivity
{
ParsedCaseSensitivity
:
:
CaseSensitive
|
ParsedCaseSensitivity
:
:
AsciiCaseInsensitiveIfInHtmlElementInHtmlDocument
=
>
{
}
ParsedCaseSensitivity
:
:
AsciiCaseInsensitive
=
>
dest
.
write_str
(
"
i
"
)
?
}
}
}
dest
.
write_char
(
'
]
'
)
}
}
impl
<
Impl
:
SelectorImpl
>
ToCss
for
LocalName
<
Impl
>
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
display_to_css_identifier
(
&
self
.
name
dest
)
}
}
fn
display_to_css_identifier
<
T
:
Display
W
:
fmt
:
:
Write
>
(
x
:
&
T
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
let
string
=
x
.
to_string
(
)
;
serialize_identifier
(
&
string
dest
)
}
fn
parse_selector
<
'
i
'
t
P
Impl
>
(
parser
:
&
P
input
:
&
mut
CssParser
<
'
i
'
t
>
)
-
>
Result
<
Selector
<
Impl
>
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
Impl
:
SelectorImpl
{
let
mut
builder
=
SelectorBuilder
:
:
default
(
)
;
let
mut
has_pseudo_element
;
let
mut
slotted
;
'
outer_loop
:
loop
{
match
parse_compound_selector
(
parser
input
&
mut
builder
)
?
{
Some
(
(
has_pseudo
slot
)
)
=
>
{
has_pseudo_element
=
has_pseudo
;
slotted
=
slot
;
}
None
=
>
{
return
Err
(
input
.
new_custom_error
(
if
builder
.
has_combinators
(
)
{
SelectorParseErrorKind
:
:
DanglingCombinator
}
else
{
SelectorParseErrorKind
:
:
EmptySelector
}
)
)
}
}
;
if
has_pseudo_element
|
|
slotted
{
break
;
}
let
combinator
;
let
mut
any_whitespace
=
false
;
loop
{
let
before_this_token
=
input
.
state
(
)
;
match
input
.
next_including_whitespace
(
)
{
Err
(
_e
)
=
>
break
'
outer_loop
Ok
(
&
Token
:
:
WhiteSpace
(
_
)
)
=
>
any_whitespace
=
true
Ok
(
&
Token
:
:
Delim
(
'
>
'
)
)
=
>
{
combinator
=
Combinator
:
:
Child
;
break
;
}
Ok
(
&
Token
:
:
Delim
(
'
+
'
)
)
=
>
{
combinator
=
Combinator
:
:
NextSibling
;
break
;
}
Ok
(
&
Token
:
:
Delim
(
'
~
'
)
)
=
>
{
combinator
=
Combinator
:
:
LaterSibling
;
break
;
}
Ok
(
_
)
=
>
{
input
.
reset
(
&
before_this_token
)
;
if
any_whitespace
{
combinator
=
Combinator
:
:
Descendant
;
break
;
}
else
{
break
'
outer_loop
;
}
}
}
}
builder
.
push_combinator
(
combinator
)
;
}
Ok
(
Selector
(
builder
.
build
(
has_pseudo_element
slotted
)
)
)
}
impl
<
Impl
:
SelectorImpl
>
Selector
<
Impl
>
{
pub
fn
parse
<
'
i
'
t
P
>
(
parser
:
&
P
input
:
&
mut
CssParser
<
'
i
'
t
>
)
-
>
Result
<
Self
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
{
let
selector
=
parse_selector
(
parser
input
)
?
;
if
selector
.
has_pseudo_element
(
)
{
let
e
=
SelectorParseErrorKind
:
:
PseudoElementInComplexSelector
;
return
Err
(
input
.
new_custom_error
(
e
)
)
;
}
Ok
(
selector
)
}
}
fn
parse_type_selector
<
'
i
'
t
P
Impl
S
>
(
parser
:
&
P
input
:
&
mut
CssParser
<
'
i
'
t
>
sink
:
&
mut
S
)
-
>
Result
<
bool
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
Impl
:
SelectorImpl
S
:
Push
<
Component
<
Impl
>
>
{
match
parse_qualified_name
(
parser
input
false
)
{
Err
(
ParseError
{
kind
:
ParseErrorKind
:
:
Basic
(
BasicParseErrorKind
:
:
EndOfInput
)
.
.
}
)
|
Ok
(
OptionalQName
:
:
None
(
_
)
)
=
>
Ok
(
false
)
Ok
(
OptionalQName
:
:
Some
(
namespace
local_name
)
)
=
>
{
match
namespace
{
QNamePrefix
:
:
ImplicitAnyNamespace
=
>
{
}
QNamePrefix
:
:
ImplicitDefaultNamespace
(
url
)
=
>
{
sink
.
push
(
Component
:
:
DefaultNamespace
(
url
)
)
}
QNamePrefix
:
:
ExplicitNamespace
(
prefix
url
)
=
>
{
sink
.
push
(
match
parser
.
default_namespace
(
)
{
Some
(
ref
default_url
)
if
url
=
=
*
default_url
=
>
{
Component
:
:
DefaultNamespace
(
url
)
}
_
=
>
Component
:
:
Namespace
(
prefix
url
)
}
)
}
QNamePrefix
:
:
ExplicitNoNamespace
=
>
sink
.
push
(
Component
:
:
ExplicitNoNamespace
)
QNamePrefix
:
:
ExplicitAnyNamespace
=
>
{
match
parser
.
default_namespace
(
)
{
None
=
>
{
}
Some
(
_
)
=
>
sink
.
push
(
Component
:
:
ExplicitAnyNamespace
)
}
}
QNamePrefix
:
:
ImplicitNoNamespace
=
>
{
unreachable
!
(
)
}
}
match
local_name
{
Some
(
name
)
=
>
sink
.
push
(
Component
:
:
LocalName
(
LocalName
{
lower_name
:
to_ascii_lowercase
(
&
name
)
.
as_ref
(
)
.
into
(
)
name
:
name
.
as_ref
(
)
.
into
(
)
}
)
)
None
=
>
sink
.
push
(
Component
:
:
ExplicitUniversalType
)
}
Ok
(
true
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
#
[
derive
(
Debug
)
]
enum
SimpleSelectorParseResult
<
Impl
:
SelectorImpl
>
{
SimpleSelector
(
Component
<
Impl
>
)
PseudoElement
(
Impl
:
:
PseudoElement
)
SlottedPseudo
(
Selector
<
Impl
>
)
}
#
[
derive
(
Debug
)
]
enum
QNamePrefix
<
Impl
:
SelectorImpl
>
{
ImplicitNoNamespace
ImplicitAnyNamespace
ImplicitDefaultNamespace
(
Impl
:
:
NamespaceUrl
)
ExplicitNoNamespace
ExplicitAnyNamespace
ExplicitNamespace
(
Impl
:
:
NamespacePrefix
Impl
:
:
NamespaceUrl
)
}
enum
OptionalQName
<
'
i
Impl
:
SelectorImpl
>
{
Some
(
QNamePrefix
<
Impl
>
Option
<
CowRcStr
<
'
i
>
>
)
None
(
Token
<
'
i
>
)
}
fn
parse_qualified_name
<
'
i
'
t
P
Impl
>
(
parser
:
&
P
input
:
&
mut
CssParser
<
'
i
'
t
>
in_attr_selector
:
bool
)
-
>
Result
<
OptionalQName
<
'
i
Impl
>
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
Impl
:
SelectorImpl
{
let
default_namespace
=
|
local_name
|
{
let
namespace
=
match
parser
.
default_namespace
(
)
{
Some
(
url
)
=
>
QNamePrefix
:
:
ImplicitDefaultNamespace
(
url
)
None
=
>
QNamePrefix
:
:
ImplicitAnyNamespace
}
;
Ok
(
OptionalQName
:
:
Some
(
namespace
local_name
)
)
}
;
let
explicit_namespace
=
|
input
:
&
mut
CssParser
<
'
i
'
t
>
namespace
|
{
let
location
=
input
.
current_source_location
(
)
;
match
input
.
next_including_whitespace
(
)
{
Ok
(
&
Token
:
:
Delim
(
'
*
'
)
)
if
!
in_attr_selector
=
>
Ok
(
OptionalQName
:
:
Some
(
namespace
None
)
)
Ok
(
&
Token
:
:
Ident
(
ref
local_name
)
)
=
>
{
Ok
(
OptionalQName
:
:
Some
(
namespace
Some
(
local_name
.
clone
(
)
)
)
)
}
Ok
(
t
)
if
in_attr_selector
=
>
{
let
e
=
SelectorParseErrorKind
:
:
InvalidQualNameInAttr
(
t
.
clone
(
)
)
;
Err
(
location
.
new_custom_error
(
e
)
)
}
Ok
(
t
)
=
>
Err
(
location
.
new_custom_error
(
SelectorParseErrorKind
:
:
ExplicitNamespaceUnexpectedToken
(
t
.
clone
(
)
)
)
)
Err
(
e
)
=
>
Err
(
e
.
into
(
)
)
}
}
;
let
start
=
input
.
state
(
)
;
match
input
.
next_including_whitespace
(
)
.
map
(
|
t
|
t
.
clone
(
)
)
{
Ok
(
Token
:
:
Ident
(
value
)
)
=
>
{
let
after_ident
=
input
.
state
(
)
;
match
input
.
next_including_whitespace
(
)
{
Ok
(
&
Token
:
:
Delim
(
'
|
'
)
)
=
>
{
let
prefix
=
value
.
as_ref
(
)
.
into
(
)
;
let
result
=
parser
.
namespace_for_prefix
(
&
prefix
)
;
let
url
=
result
.
ok_or
(
after_ident
.
source_location
(
)
.
new_custom_error
(
SelectorParseErrorKind
:
:
ExpectedNamespace
(
value
)
)
)
?
;
explicit_namespace
(
input
QNamePrefix
:
:
ExplicitNamespace
(
prefix
url
)
)
}
_
=
>
{
input
.
reset
(
&
after_ident
)
;
if
in_attr_selector
{
Ok
(
OptionalQName
:
:
Some
(
QNamePrefix
:
:
ImplicitNoNamespace
Some
(
value
)
)
)
}
else
{
default_namespace
(
Some
(
value
)
)
}
}
}
}
Ok
(
Token
:
:
Delim
(
'
*
'
)
)
=
>
{
let
after_star
=
input
.
state
(
)
;
match
input
.
next_including_whitespace
(
)
.
map
(
|
t
|
t
.
clone
(
)
)
{
Ok
(
Token
:
:
Delim
(
'
|
'
)
)
=
>
{
explicit_namespace
(
input
QNamePrefix
:
:
ExplicitAnyNamespace
)
}
result
=
>
{
input
.
reset
(
&
after_star
)
;
if
in_attr_selector
{
match
result
{
Ok
(
t
)
=
>
Err
(
after_star
.
source_location
(
)
.
new_custom_error
(
SelectorParseErrorKind
:
:
ExpectedBarInAttr
(
t
)
)
)
Err
(
e
)
=
>
Err
(
e
.
into
(
)
)
}
}
else
{
default_namespace
(
None
)
}
}
}
}
Ok
(
Token
:
:
Delim
(
'
|
'
)
)
=
>
explicit_namespace
(
input
QNamePrefix
:
:
ExplicitNoNamespace
)
Ok
(
t
)
=
>
{
input
.
reset
(
&
start
)
;
Ok
(
OptionalQName
:
:
None
(
t
)
)
}
Err
(
e
)
=
>
{
input
.
reset
(
&
start
)
;
Err
(
e
.
into
(
)
)
}
}
}
fn
parse_attribute_selector
<
'
i
'
t
P
Impl
>
(
parser
:
&
P
input
:
&
mut
CssParser
<
'
i
'
t
>
)
-
>
Result
<
Component
<
Impl
>
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
Impl
:
SelectorImpl
{
let
namespace
;
let
local_name
;
input
.
skip_whitespace
(
)
;
match
parse_qualified_name
(
parser
input
true
)
?
{
OptionalQName
:
:
None
(
t
)
=
>
{
return
Err
(
input
.
new_custom_error
(
SelectorParseErrorKind
:
:
NoQualifiedNameInAttributeSelector
(
t
)
)
)
}
OptionalQName
:
:
Some
(
_
None
)
=
>
unreachable
!
(
)
OptionalQName
:
:
Some
(
ns
Some
(
ln
)
)
=
>
{
local_name
=
ln
;
namespace
=
match
ns
{
QNamePrefix
:
:
ImplicitNoNamespace
|
QNamePrefix
:
:
ExplicitNoNamespace
=
>
None
QNamePrefix
:
:
ExplicitNamespace
(
prefix
url
)
=
>
{
Some
(
NamespaceConstraint
:
:
Specific
(
(
prefix
url
)
)
)
}
QNamePrefix
:
:
ExplicitAnyNamespace
=
>
Some
(
NamespaceConstraint
:
:
Any
)
QNamePrefix
:
:
ImplicitAnyNamespace
|
QNamePrefix
:
:
ImplicitDefaultNamespace
(
_
)
=
>
{
unreachable
!
(
)
}
}
}
}
let
location
=
input
.
current_source_location
(
)
;
let
operator
=
match
input
.
next
(
)
{
Err
(
_
)
=
>
{
let
local_name_lower
=
to_ascii_lowercase
(
&
local_name
)
.
as_ref
(
)
.
into
(
)
;
let
local_name
=
local_name
.
as_ref
(
)
.
into
(
)
;
if
let
Some
(
namespace
)
=
namespace
{
return
Ok
(
Component
:
:
AttributeOther
(
Box
:
:
new
(
AttrSelectorWithOptionalNamespace
{
namespace
:
Some
(
namespace
)
local_name
:
local_name
local_name_lower
:
local_name_lower
operation
:
ParsedAttrSelectorOperation
:
:
Exists
never_matches
:
false
}
)
)
)
;
}
else
{
return
Ok
(
Component
:
:
AttributeInNoNamespaceExists
{
local_name
:
local_name
local_name_lower
:
local_name_lower
}
)
;
}
}
Ok
(
&
Token
:
:
Delim
(
'
=
'
)
)
=
>
AttrSelectorOperator
:
:
Equal
Ok
(
&
Token
:
:
IncludeMatch
)
=
>
AttrSelectorOperator
:
:
Includes
Ok
(
&
Token
:
:
DashMatch
)
=
>
AttrSelectorOperator
:
:
DashMatch
Ok
(
&
Token
:
:
PrefixMatch
)
=
>
AttrSelectorOperator
:
:
Prefix
Ok
(
&
Token
:
:
SubstringMatch
)
=
>
AttrSelectorOperator
:
:
Substring
Ok
(
&
Token
:
:
SuffixMatch
)
=
>
AttrSelectorOperator
:
:
Suffix
Ok
(
t
)
=
>
{
return
Err
(
location
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnexpectedTokenInAttributeSelector
(
t
.
clone
(
)
)
)
)
}
}
;
let
value
=
match
input
.
expect_ident_or_string
(
)
{
Ok
(
t
)
=
>
t
.
clone
(
)
Err
(
BasicParseError
{
kind
:
BasicParseErrorKind
:
:
UnexpectedToken
(
t
)
location
}
)
=
>
return
Err
(
location
.
new_custom_error
(
SelectorParseErrorKind
:
:
BadValueInAttr
(
t
)
)
)
Err
(
e
)
=
>
return
Err
(
e
.
into
(
)
)
}
;
let
never_matches
=
match
operator
{
AttrSelectorOperator
:
:
Equal
|
AttrSelectorOperator
:
:
DashMatch
=
>
false
AttrSelectorOperator
:
:
Includes
=
>
value
.
is_empty
(
)
|
|
value
.
contains
(
SELECTOR_WHITESPACE
)
AttrSelectorOperator
:
:
Prefix
|
AttrSelectorOperator
:
:
Substring
|
AttrSelectorOperator
:
:
Suffix
=
>
value
.
is_empty
(
)
}
;
let
mut
case_sensitivity
=
parse_attribute_flags
(
input
)
?
;
let
value
=
value
.
as_ref
(
)
.
into
(
)
;
let
local_name_lower
;
let
local_name_is_ascii_lowercase
;
{
let
local_name_lower_cow
=
to_ascii_lowercase
(
&
local_name
)
;
if
let
ParsedCaseSensitivity
:
:
CaseSensitive
=
case_sensitivity
{
if
namespace
.
is_none
(
)
&
&
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
ascii_case_insensitive_html_attributes
.
rs
"
)
)
.
contains
(
&
*
local_name_lower_cow
)
{
case_sensitivity
=
ParsedCaseSensitivity
:
:
AsciiCaseInsensitiveIfInHtmlElementInHtmlDocument
}
}
local_name_lower
=
local_name_lower_cow
.
as_ref
(
)
.
into
(
)
;
local_name_is_ascii_lowercase
=
matches
!
(
local_name_lower_cow
Cow
:
:
Borrowed
(
.
.
)
)
;
}
let
local_name
=
local_name
.
as_ref
(
)
.
into
(
)
;
if
namespace
.
is_some
(
)
|
|
!
local_name_is_ascii_lowercase
{
Ok
(
Component
:
:
AttributeOther
(
Box
:
:
new
(
AttrSelectorWithOptionalNamespace
{
namespace
local_name
local_name_lower
never_matches
operation
:
ParsedAttrSelectorOperation
:
:
WithValue
{
operator
:
operator
case_sensitivity
:
case_sensitivity
expected_value
:
value
}
}
)
)
)
}
else
{
Ok
(
Component
:
:
AttributeInNoNamespace
{
local_name
:
local_name
operator
:
operator
value
:
value
case_sensitivity
:
case_sensitivity
never_matches
:
never_matches
}
)
}
}
fn
parse_attribute_flags
<
'
i
'
t
>
(
input
:
&
mut
CssParser
<
'
i
'
t
>
)
-
>
Result
<
ParsedCaseSensitivity
BasicParseError
<
'
i
>
>
{
let
location
=
input
.
current_source_location
(
)
;
match
input
.
next
(
)
{
Err
(
_
)
=
>
{
Ok
(
ParsedCaseSensitivity
:
:
CaseSensitive
)
}
Ok
(
&
Token
:
:
Ident
(
ref
value
)
)
if
value
.
eq_ignore_ascii_case
(
"
i
"
)
=
>
{
Ok
(
ParsedCaseSensitivity
:
:
AsciiCaseInsensitive
)
}
Ok
(
t
)
=
>
Err
(
location
.
new_basic_unexpected_token_error
(
t
.
clone
(
)
)
)
}
}
fn
parse_negation
<
'
i
'
t
P
Impl
>
(
parser
:
&
P
input
:
&
mut
CssParser
<
'
i
'
t
>
)
-
>
Result
<
Component
<
Impl
>
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
Impl
:
SelectorImpl
{
let
mut
sequence
=
SmallVec
:
:
<
[
Component
<
Impl
>
;
2
]
>
:
:
new
(
)
;
input
.
skip_whitespace
(
)
;
let
is_type_sel
=
match
parse_type_selector
(
parser
input
&
mut
sequence
)
{
Ok
(
result
)
=
>
result
Err
(
ParseError
{
kind
:
ParseErrorKind
:
:
Basic
(
BasicParseErrorKind
:
:
EndOfInput
)
.
.
}
)
=
>
return
Err
(
input
.
new_custom_error
(
SelectorParseErrorKind
:
:
EmptyNegation
)
)
Err
(
e
)
=
>
return
Err
(
e
.
into
(
)
)
}
;
if
!
is_type_sel
{
match
parse_one_simple_selector
(
parser
input
true
)
?
{
Some
(
SimpleSelectorParseResult
:
:
SimpleSelector
(
s
)
)
=
>
{
sequence
.
push
(
s
)
;
}
None
=
>
{
return
Err
(
input
.
new_custom_error
(
SelectorParseErrorKind
:
:
EmptyNegation
)
)
;
}
Some
(
SimpleSelectorParseResult
:
:
PseudoElement
(
_
)
)
|
Some
(
SimpleSelectorParseResult
:
:
SlottedPseudo
(
_
)
)
=
>
{
let
e
=
SelectorParseErrorKind
:
:
NonSimpleSelectorInNegation
;
return
Err
(
input
.
new_custom_error
(
e
)
)
;
}
}
}
Ok
(
Component
:
:
Negation
(
sequence
.
into_vec
(
)
.
into_boxed_slice
(
)
.
into
(
)
)
)
}
fn
parse_compound_selector
<
'
i
'
t
P
Impl
>
(
parser
:
&
P
input
:
&
mut
CssParser
<
'
i
'
t
>
builder
:
&
mut
SelectorBuilder
<
Impl
>
)
-
>
Result
<
Option
<
(
bool
bool
)
>
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
Impl
:
SelectorImpl
{
input
.
skip_whitespace
(
)
;
let
mut
empty
=
true
;
let
mut
slot
=
false
;
if
!
parse_type_selector
(
parser
input
builder
)
?
{
if
let
Some
(
url
)
=
parser
.
default_namespace
(
)
{
builder
.
push_simple_selector
(
Component
:
:
DefaultNamespace
(
url
)
)
}
}
else
{
empty
=
false
;
}
let
mut
pseudo
=
false
;
loop
{
let
parse_result
=
match
parse_one_simple_selector
(
parser
input
false
)
?
{
None
=
>
break
Some
(
result
)
=
>
result
}
;
match
parse_result
{
SimpleSelectorParseResult
:
:
SimpleSelector
(
s
)
=
>
{
builder
.
push_simple_selector
(
s
)
;
empty
=
false
}
SimpleSelectorParseResult
:
:
PseudoElement
(
p
)
=
>
{
let
mut
state_selectors
=
SmallVec
:
:
<
[
Component
<
Impl
>
;
3
]
>
:
:
new
(
)
;
loop
{
let
location
=
input
.
current_source_location
(
)
;
match
input
.
next_including_whitespace
(
)
{
Ok
(
&
Token
:
:
Colon
)
=
>
{
}
Ok
(
&
Token
:
:
WhiteSpace
(
_
)
)
|
Err
(
_
)
=
>
break
Ok
(
t
)
=
>
{
let
e
=
SelectorParseErrorKind
:
:
PseudoElementExpectedColon
(
t
.
clone
(
)
)
;
return
Err
(
location
.
new_custom_error
(
e
)
)
;
}
}
let
location
=
input
.
current_source_location
(
)
;
let
name
=
match
input
.
next_including_whitespace
(
)
?
{
&
Token
:
:
Ident
(
ref
name
)
=
>
name
.
clone
(
)
t
=
>
{
return
Err
(
location
.
new_custom_error
(
SelectorParseErrorKind
:
:
NoIdentForPseudo
(
t
.
clone
(
)
)
)
)
}
}
;
let
pseudo_class
=
P
:
:
parse_non_ts_pseudo_class
(
parser
location
name
.
clone
(
)
)
?
;
if
!
p
.
supports_pseudo_class
(
&
pseudo_class
)
{
return
Err
(
input
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnsupportedPseudoClassOrElement
(
name
)
)
)
;
}
state_selectors
.
push
(
Component
:
:
NonTSPseudoClass
(
pseudo_class
)
)
;
}
if
!
builder
.
is_empty
(
)
{
builder
.
push_combinator
(
Combinator
:
:
PseudoElement
)
;
}
builder
.
push_simple_selector
(
Component
:
:
PseudoElement
(
p
)
)
;
for
state_selector
in
state_selectors
.
drain
(
)
{
builder
.
push_simple_selector
(
state_selector
)
;
}
pseudo
=
true
;
empty
=
false
;
break
;
}
SimpleSelectorParseResult
:
:
SlottedPseudo
(
selector
)
=
>
{
empty
=
false
;
slot
=
true
;
if
!
builder
.
is_empty
(
)
{
builder
.
push_combinator
(
Combinator
:
:
SlotAssignment
)
;
}
builder
.
push_simple_selector
(
Component
:
:
Slotted
(
selector
)
)
;
break
;
}
}
}
if
empty
{
Ok
(
None
)
}
else
{
Ok
(
Some
(
(
pseudo
slot
)
)
)
}
}
fn
parse_functional_pseudo_class
<
'
i
'
t
P
Impl
>
(
parser
:
&
P
input
:
&
mut
CssParser
<
'
i
'
t
>
name
:
CowRcStr
<
'
i
>
inside_negation
:
bool
)
-
>
Result
<
Component
<
Impl
>
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
Impl
:
SelectorImpl
{
match_ignore_ascii_case
!
{
&
name
"
nth
-
child
"
=
>
return
Ok
(
parse_nth_pseudo_class
(
input
Component
:
:
NthChild
)
?
)
"
nth
-
of
-
type
"
=
>
return
Ok
(
parse_nth_pseudo_class
(
input
Component
:
:
NthOfType
)
?
)
"
nth
-
last
-
child
"
=
>
return
Ok
(
parse_nth_pseudo_class
(
input
Component
:
:
NthLastChild
)
?
)
"
nth
-
last
-
of
-
type
"
=
>
return
Ok
(
parse_nth_pseudo_class
(
input
Component
:
:
NthLastOfType
)
?
)
"
host
"
=
>
return
Ok
(
Component
:
:
Host
(
Some
(
parse_inner_compound_selector
(
parser
input
)
?
)
)
)
"
not
"
=
>
{
if
inside_negation
{
return
Err
(
input
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnexpectedIdent
(
"
not
"
.
into
(
)
)
)
)
;
}
return
parse_negation
(
parser
input
)
}
_
=
>
{
}
}
P
:
:
parse_non_ts_functional_pseudo_class
(
parser
name
input
)
.
map
(
Component
:
:
NonTSPseudoClass
)
}
fn
parse_nth_pseudo_class
<
'
i
'
t
Impl
F
>
(
input
:
&
mut
CssParser
<
'
i
'
t
>
selector
:
F
)
-
>
Result
<
Component
<
Impl
>
BasicParseError
<
'
i
>
>
where
Impl
:
SelectorImpl
F
:
FnOnce
(
i32
i32
)
-
>
Component
<
Impl
>
{
let
(
a
b
)
=
parse_nth
(
input
)
?
;
Ok
(
selector
(
a
b
)
)
}
pub
fn
is_css2_pseudo_element
(
name
:
&
str
)
-
>
bool
{
match_ignore_ascii_case
!
{
name
"
before
"
|
"
after
"
|
"
first
-
line
"
|
"
first
-
letter
"
=
>
true
_
=
>
false
}
}
fn
parse_one_simple_selector
<
'
i
'
t
P
Impl
>
(
parser
:
&
P
input
:
&
mut
CssParser
<
'
i
'
t
>
inside_negation
:
bool
)
-
>
Result
<
Option
<
SimpleSelectorParseResult
<
Impl
>
>
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
Impl
:
SelectorImpl
{
let
start
=
input
.
state
(
)
;
match
input
.
next_including_whitespace
(
)
.
map
(
|
t
|
t
.
clone
(
)
)
{
Ok
(
Token
:
:
IDHash
(
id
)
)
=
>
{
let
id
=
Component
:
:
ID
(
id
.
as_ref
(
)
.
into
(
)
)
;
Ok
(
Some
(
SimpleSelectorParseResult
:
:
SimpleSelector
(
id
)
)
)
}
Ok
(
Token
:
:
Delim
(
'
.
'
)
)
=
>
{
let
location
=
input
.
current_source_location
(
)
;
match
*
input
.
next_including_whitespace
(
)
?
{
Token
:
:
Ident
(
ref
class
)
=
>
{
let
class
=
Component
:
:
Class
(
class
.
as_ref
(
)
.
into
(
)
)
;
Ok
(
Some
(
SimpleSelectorParseResult
:
:
SimpleSelector
(
class
)
)
)
}
ref
t
=
>
{
let
e
=
SelectorParseErrorKind
:
:
ClassNeedsIdent
(
t
.
clone
(
)
)
;
Err
(
location
.
new_custom_error
(
e
)
)
}
}
}
Ok
(
Token
:
:
SquareBracketBlock
)
=
>
{
let
attr
=
input
.
parse_nested_block
(
|
input
|
parse_attribute_selector
(
parser
input
)
)
?
;
Ok
(
Some
(
SimpleSelectorParseResult
:
:
SimpleSelector
(
attr
)
)
)
}
Ok
(
Token
:
:
Colon
)
=
>
{
let
location
=
input
.
current_source_location
(
)
;
let
(
is_single_colon
next_token
)
=
match
input
.
next_including_whitespace
(
)
?
.
clone
(
)
{
Token
:
:
Colon
=
>
(
false
input
.
next_including_whitespace
(
)
?
.
clone
(
)
)
t
=
>
(
true
t
)
}
;
let
(
name
is_functional
)
=
match
next_token
{
Token
:
:
Ident
(
name
)
=
>
(
name
false
)
Token
:
:
Function
(
name
)
=
>
(
name
true
)
t
=
>
{
let
e
=
SelectorParseErrorKind
:
:
PseudoElementExpectedIdent
(
t
)
;
return
Err
(
input
.
new_custom_error
(
e
)
)
;
}
}
;
let
is_pseudo_element
=
!
is_single_colon
|
|
P
:
:
pseudo_element_allows_single_colon
(
&
name
)
;
if
is_pseudo_element
{
let
parse_result
=
if
is_functional
{
if
P
:
:
parse_slotted
(
parser
)
&
&
name
.
eq_ignore_ascii_case
(
"
slotted
"
)
{
let
selector
=
input
.
parse_nested_block
(
|
input
|
{
parse_inner_compound_selector
(
parser
input
)
}
)
?
;
SimpleSelectorParseResult
:
:
SlottedPseudo
(
selector
)
}
else
{
let
selector
=
input
.
parse_nested_block
(
|
input
|
{
P
:
:
parse_functional_pseudo_element
(
parser
name
input
)
}
)
?
;
SimpleSelectorParseResult
:
:
PseudoElement
(
selector
)
}
}
else
{
SimpleSelectorParseResult
:
:
PseudoElement
(
P
:
:
parse_pseudo_element
(
parser
location
name
)
?
)
}
;
Ok
(
Some
(
parse_result
)
)
}
else
{
let
pseudo_class
=
if
is_functional
{
input
.
parse_nested_block
(
|
input
|
{
parse_functional_pseudo_class
(
parser
input
name
inside_negation
)
}
)
?
}
else
{
parse_simple_pseudo_class
(
parser
location
name
)
?
}
;
Ok
(
Some
(
SimpleSelectorParseResult
:
:
SimpleSelector
(
pseudo_class
)
)
)
}
}
_
=
>
{
input
.
reset
(
&
start
)
;
Ok
(
None
)
}
}
}
fn
parse_simple_pseudo_class
<
'
i
P
Impl
>
(
parser
:
&
P
location
:
SourceLocation
name
:
CowRcStr
<
'
i
>
)
-
>
Result
<
Component
<
Impl
>
ParseError
<
'
i
P
:
:
Error
>
>
where
P
:
Parser
<
'
i
Impl
=
Impl
>
Impl
:
SelectorImpl
{
(
match_ignore_ascii_case
!
{
&
name
"
first
-
child
"
=
>
Ok
(
Component
:
:
FirstChild
)
"
last
-
child
"
=
>
Ok
(
Component
:
:
LastChild
)
"
only
-
child
"
=
>
Ok
(
Component
:
:
OnlyChild
)
"
root
"
=
>
Ok
(
Component
:
:
Root
)
"
empty
"
=
>
Ok
(
Component
:
:
Empty
)
"
scope
"
=
>
Ok
(
Component
:
:
Scope
)
"
host
"
if
P
:
:
parse_host
(
parser
)
=
>
Ok
(
Component
:
:
Host
(
None
)
)
"
first
-
of
-
type
"
=
>
Ok
(
Component
:
:
FirstOfType
)
"
last
-
of
-
type
"
=
>
Ok
(
Component
:
:
LastOfType
)
"
only
-
of
-
type
"
=
>
Ok
(
Component
:
:
OnlyOfType
)
_
=
>
Err
(
(
)
)
}
)
.
or_else
(
|
(
)
|
{
P
:
:
parse_non_ts_pseudo_class
(
parser
location
name
)
.
map
(
Component
:
:
NonTSPseudoClass
)
}
)
}
#
[
cfg
(
test
)
]
pub
mod
tests
{
use
builder
:
:
HAS_PSEUDO_BIT
;
use
cssparser
:
:
{
serialize_identifier
Parser
as
CssParser
ParserInput
ToCss
}
;
use
parser
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
fmt
;
use
super
:
:
*
;
#
[
derive
(
Clone
Debug
Eq
PartialEq
)
]
pub
enum
PseudoClass
{
Hover
Active
Lang
(
String
)
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
)
]
pub
enum
PseudoElement
{
Before
After
}
impl
parser
:
:
PseudoElement
for
PseudoElement
{
type
Impl
=
DummySelectorImpl
;
fn
supports_pseudo_class
(
&
self
pc
:
&
PseudoClass
)
-
>
bool
{
match
*
pc
{
PseudoClass
:
:
Hover
=
>
true
PseudoClass
:
:
Active
|
PseudoClass
:
:
Lang
(
.
.
)
=
>
false
}
}
}
impl
parser
:
:
NonTSPseudoClass
for
PseudoClass
{
type
Impl
=
DummySelectorImpl
;
#
[
inline
]
fn
is_active_or_hover
(
&
self
)
-
>
bool
{
matches
!
(
*
self
PseudoClass
:
:
Active
|
PseudoClass
:
:
Hover
)
}
}
impl
ToCss
for
PseudoClass
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
PseudoClass
:
:
Hover
=
>
dest
.
write_str
(
"
:
hover
"
)
PseudoClass
:
:
Active
=
>
dest
.
write_str
(
"
:
active
"
)
PseudoClass
:
:
Lang
(
ref
lang
)
=
>
{
dest
.
write_str
(
"
:
lang
(
"
)
?
;
serialize_identifier
(
lang
dest
)
?
;
dest
.
write_char
(
'
)
'
)
}
}
}
}
impl
ToCss
for
PseudoElement
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
PseudoElement
:
:
Before
=
>
dest
.
write_str
(
"
:
:
before
"
)
PseudoElement
:
:
After
=
>
dest
.
write_str
(
"
:
:
after
"
)
}
}
}
impl
Visit
for
PseudoClass
{
type
Impl
=
DummySelectorImpl
;
fn
visit
<
V
>
(
&
self
_visitor
:
&
mut
V
)
-
>
bool
where
V
:
SelectorVisitor
<
Impl
=
Self
:
:
Impl
>
{
true
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
DummySelectorImpl
;
#
[
derive
(
Default
)
]
pub
struct
DummyParser
{
default_ns
:
Option
<
DummyAtom
>
ns_prefixes
:
HashMap
<
DummyAtom
DummyAtom
>
}
impl
DummyParser
{
fn
default_with_namespace
(
default_ns
:
DummyAtom
)
-
>
DummyParser
{
DummyParser
{
default_ns
:
Some
(
default_ns
)
ns_prefixes
:
Default
:
:
default
(
)
}
}
}
impl
SelectorImpl
for
DummySelectorImpl
{
type
ExtraMatchingData
=
(
)
;
type
AttrValue
=
DummyAtom
;
type
Identifier
=
DummyAtom
;
type
ClassName
=
DummyAtom
;
type
LocalName
=
DummyAtom
;
type
NamespaceUrl
=
DummyAtom
;
type
NamespacePrefix
=
DummyAtom
;
type
BorrowedLocalName
=
DummyAtom
;
type
BorrowedNamespaceUrl
=
DummyAtom
;
type
NonTSPseudoClass
=
PseudoClass
;
type
PseudoElement
=
PseudoElement
;
}
#
[
derive
(
Clone
Debug
Default
Eq
Hash
PartialEq
)
]
pub
struct
DummyAtom
(
String
)
;
impl
fmt
:
:
Display
for
DummyAtom
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
<
String
as
fmt
:
:
Display
>
:
:
fmt
(
&
self
.
0
fmt
)
}
}
impl
From
<
String
>
for
DummyAtom
{
fn
from
(
string
:
String
)
-
>
Self
{
DummyAtom
(
string
)
}
}
impl
<
'
a
>
From
<
&
'
a
str
>
for
DummyAtom
{
fn
from
(
string
:
&
'
a
str
)
-
>
Self
{
DummyAtom
(
string
.
into
(
)
)
}
}
impl
<
'
i
>
Parser
<
'
i
>
for
DummyParser
{
type
Impl
=
DummySelectorImpl
;
type
Error
=
SelectorParseErrorKind
<
'
i
>
;
fn
parse_slotted
(
&
self
)
-
>
bool
{
true
}
fn
parse_non_ts_pseudo_class
(
&
self
location
:
SourceLocation
name
:
CowRcStr
<
'
i
>
)
-
>
Result
<
PseudoClass
SelectorParseError
<
'
i
>
>
{
match_ignore_ascii_case
!
{
&
name
"
hover
"
=
>
return
Ok
(
PseudoClass
:
:
Hover
)
"
active
"
=
>
return
Ok
(
PseudoClass
:
:
Active
)
_
=
>
{
}
}
Err
(
location
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnsupportedPseudoClassOrElement
(
name
)
)
)
}
fn
parse_non_ts_functional_pseudo_class
<
'
t
>
(
&
self
name
:
CowRcStr
<
'
i
>
parser
:
&
mut
CssParser
<
'
i
'
t
>
)
-
>
Result
<
PseudoClass
SelectorParseError
<
'
i
>
>
{
match_ignore_ascii_case
!
{
&
name
"
lang
"
=
>
{
let
lang
=
parser
.
expect_ident_or_string
(
)
?
.
as_ref
(
)
.
to_owned
(
)
;
return
Ok
(
PseudoClass
:
:
Lang
(
lang
)
)
;
}
_
=
>
{
}
}
Err
(
parser
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnsupportedPseudoClassOrElement
(
name
)
)
)
}
fn
parse_pseudo_element
(
&
self
location
:
SourceLocation
name
:
CowRcStr
<
'
i
>
)
-
>
Result
<
PseudoElement
SelectorParseError
<
'
i
>
>
{
match_ignore_ascii_case
!
{
&
name
"
before
"
=
>
return
Ok
(
PseudoElement
:
:
Before
)
"
after
"
=
>
return
Ok
(
PseudoElement
:
:
After
)
_
=
>
{
}
}
Err
(
location
.
new_custom_error
(
SelectorParseErrorKind
:
:
UnsupportedPseudoClassOrElement
(
name
)
)
)
}
fn
default_namespace
(
&
self
)
-
>
Option
<
DummyAtom
>
{
self
.
default_ns
.
clone
(
)
}
fn
namespace_for_prefix
(
&
self
prefix
:
&
DummyAtom
)
-
>
Option
<
DummyAtom
>
{
self
.
ns_prefixes
.
get
(
prefix
)
.
cloned
(
)
}
}
fn
parse
<
'
i
>
(
input
:
&
'
i
str
)
-
>
Result
<
SelectorList
<
DummySelectorImpl
>
SelectorParseError
<
'
i
>
>
{
parse_ns
(
input
&
DummyParser
:
:
default
(
)
)
}
fn
parse_expected
<
'
i
'
a
>
(
input
:
&
'
i
str
expected
:
Option
<
&
'
a
str
>
)
-
>
Result
<
SelectorList
<
DummySelectorImpl
>
SelectorParseError
<
'
i
>
>
{
parse_ns_expected
(
input
&
DummyParser
:
:
default
(
)
expected
)
}
fn
parse_ns
<
'
i
>
(
input
:
&
'
i
str
parser
:
&
DummyParser
)
-
>
Result
<
SelectorList
<
DummySelectorImpl
>
SelectorParseError
<
'
i
>
>
{
parse_ns_expected
(
input
parser
None
)
}
fn
parse_ns_expected
<
'
i
'
a
>
(
input
:
&
'
i
str
parser
:
&
DummyParser
expected
:
Option
<
&
'
a
str
>
)
-
>
Result
<
SelectorList
<
DummySelectorImpl
>
SelectorParseError
<
'
i
>
>
{
let
mut
parser_input
=
ParserInput
:
:
new
(
input
)
;
let
result
=
SelectorList
:
:
parse
(
parser
&
mut
CssParser
:
:
new
(
&
mut
parser_input
)
)
;
if
let
Ok
(
ref
selectors
)
=
result
{
assert_eq
!
(
selectors
.
0
.
len
(
)
1
)
;
assert_eq
!
(
selectors
.
0
[
0
]
.
to_css_string
(
)
match
expected
{
Some
(
x
)
=
>
x
None
=
>
input
}
)
;
}
result
}
fn
specificity
(
a
:
u32
b
:
u32
c
:
u32
)
-
>
u32
{
a
<
<
20
|
b
<
<
10
|
c
}
#
[
test
]
fn
test_empty
(
)
{
let
mut
input
=
ParserInput
:
:
new
(
"
:
empty
"
)
;
let
list
=
SelectorList
:
:
parse
(
&
DummyParser
:
:
default
(
)
&
mut
CssParser
:
:
new
(
&
mut
input
)
)
;
assert
!
(
list
.
is_ok
(
)
)
;
}
const
MATHML
:
&
'
static
str
=
"
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
"
;
const
SVG
:
&
'
static
str
=
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
;
#
[
test
]
fn
test_parsing
(
)
{
assert
!
(
parse
(
"
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
:
lang
(
4
)
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
:
lang
(
en
US
)
"
)
.
is_err
(
)
)
;
assert_eq
!
(
parse
(
"
Ee
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
LocalName
(
LocalName
{
name
:
DummyAtom
:
:
from
(
"
Ee
"
)
lower_name
:
DummyAtom
:
:
from
(
"
ee
"
)
}
)
]
specificity
(
0
0
1
)
)
]
)
)
)
;
assert_eq
!
(
parse
(
"
|
e
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
ExplicitNoNamespace
Component
:
:
LocalName
(
LocalName
{
name
:
DummyAtom
:
:
from
(
"
e
"
)
lower_name
:
DummyAtom
:
:
from
(
"
e
"
)
}
)
]
specificity
(
0
0
1
)
)
]
)
)
)
;
assert_eq
!
(
parse_expected
(
"
*
|
e
"
Some
(
"
e
"
)
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
LocalName
(
LocalName
{
name
:
DummyAtom
:
:
from
(
"
e
"
)
lower_name
:
DummyAtom
:
:
from
(
"
e
"
)
}
)
]
specificity
(
0
0
1
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
*
|
e
"
&
DummyParser
:
:
default_with_namespace
(
DummyAtom
:
:
from
(
"
https
:
/
/
mozilla
.
org
"
)
)
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
ExplicitAnyNamespace
Component
:
:
LocalName
(
LocalName
{
name
:
DummyAtom
:
:
from
(
"
e
"
)
lower_name
:
DummyAtom
:
:
from
(
"
e
"
)
}
)
]
specificity
(
0
0
1
)
)
]
)
)
)
;
assert_eq
!
(
parse
(
"
*
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
ExplicitUniversalType
]
specificity
(
0
0
0
)
)
]
)
)
)
;
assert_eq
!
(
parse
(
"
|
*
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
ExplicitNoNamespace
Component
:
:
ExplicitUniversalType
]
specificity
(
0
0
0
)
)
]
)
)
)
;
assert_eq
!
(
parse_expected
(
"
*
|
*
"
Some
(
"
*
"
)
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
ExplicitUniversalType
]
specificity
(
0
0
0
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
*
|
*
"
&
DummyParser
:
:
default_with_namespace
(
DummyAtom
:
:
from
(
"
https
:
/
/
mozilla
.
org
"
)
)
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
ExplicitAnyNamespace
Component
:
:
ExplicitUniversalType
]
specificity
(
0
0
0
)
)
]
)
)
)
;
assert_eq
!
(
parse
(
"
.
foo
:
lang
(
en
-
US
)
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
Class
(
DummyAtom
:
:
from
(
"
foo
"
)
)
Component
:
:
NonTSPseudoClass
(
PseudoClass
:
:
Lang
(
"
en
-
US
"
.
to_owned
(
)
)
)
]
specificity
(
0
2
0
)
)
]
)
)
)
;
assert_eq
!
(
parse
(
"
#
bar
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
ID
(
DummyAtom
:
:
from
(
"
bar
"
)
)
]
specificity
(
1
0
0
)
)
]
)
)
)
;
assert_eq
!
(
parse
(
"
e
.
foo
#
bar
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
LocalName
(
LocalName
{
name
:
DummyAtom
:
:
from
(
"
e
"
)
lower_name
:
DummyAtom
:
:
from
(
"
e
"
)
}
)
Component
:
:
Class
(
DummyAtom
:
:
from
(
"
foo
"
)
)
Component
:
:
ID
(
DummyAtom
:
:
from
(
"
bar
"
)
)
]
specificity
(
1
1
1
)
)
]
)
)
)
;
assert_eq
!
(
parse
(
"
e
.
foo
#
bar
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
LocalName
(
LocalName
{
name
:
DummyAtom
:
:
from
(
"
e
"
)
lower_name
:
DummyAtom
:
:
from
(
"
e
"
)
}
)
Component
:
:
Class
(
DummyAtom
:
:
from
(
"
foo
"
)
)
Component
:
:
Combinator
(
Combinator
:
:
Descendant
)
Component
:
:
ID
(
DummyAtom
:
:
from
(
"
bar
"
)
)
]
specificity
(
1
1
1
)
)
]
)
)
)
;
let
mut
parser
=
DummyParser
:
:
default
(
)
;
assert_eq
!
(
parse_ns
(
"
[
Foo
]
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
AttributeInNoNamespaceExists
{
local_name
:
DummyAtom
:
:
from
(
"
Foo
"
)
local_name_lower
:
DummyAtom
:
:
from
(
"
foo
"
)
}
]
specificity
(
0
1
0
)
)
]
)
)
)
;
assert
!
(
parse_ns
(
"
svg
|
circle
"
&
parser
)
.
is_err
(
)
)
;
parser
.
ns_prefixes
.
insert
(
DummyAtom
(
"
svg
"
.
into
(
)
)
DummyAtom
(
SVG
.
into
(
)
)
)
;
assert_eq
!
(
parse_ns
(
"
svg
|
circle
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
Namespace
(
DummyAtom
(
"
svg
"
.
into
(
)
)
SVG
.
into
(
)
)
Component
:
:
LocalName
(
LocalName
{
name
:
DummyAtom
:
:
from
(
"
circle
"
)
lower_name
:
DummyAtom
:
:
from
(
"
circle
"
)
}
)
]
specificity
(
0
0
1
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
svg
|
*
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
Namespace
(
DummyAtom
(
"
svg
"
.
into
(
)
)
SVG
.
into
(
)
)
Component
:
:
ExplicitUniversalType
]
specificity
(
0
0
0
)
)
]
)
)
)
;
parser
.
default_ns
=
Some
(
MATHML
.
into
(
)
)
;
assert_eq
!
(
parse_ns
(
"
[
Foo
]
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
DefaultNamespace
(
MATHML
.
into
(
)
)
Component
:
:
AttributeInNoNamespaceExists
{
local_name
:
DummyAtom
:
:
from
(
"
Foo
"
)
local_name_lower
:
DummyAtom
:
:
from
(
"
foo
"
)
}
]
specificity
(
0
1
0
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
e
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
DefaultNamespace
(
MATHML
.
into
(
)
)
Component
:
:
LocalName
(
LocalName
{
name
:
DummyAtom
:
:
from
(
"
e
"
)
lower_name
:
DummyAtom
:
:
from
(
"
e
"
)
}
)
]
specificity
(
0
0
1
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
*
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
DefaultNamespace
(
MATHML
.
into
(
)
)
Component
:
:
ExplicitUniversalType
]
specificity
(
0
0
0
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
*
|
*
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
ExplicitAnyNamespace
Component
:
:
ExplicitUniversalType
]
specificity
(
0
0
0
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
:
not
(
.
cl
)
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
DefaultNamespace
(
MATHML
.
into
(
)
)
Component
:
:
Negation
(
vec
!
[
Component
:
:
Class
(
DummyAtom
:
:
from
(
"
cl
"
)
)
]
.
into_boxed_slice
(
)
)
]
specificity
(
0
1
0
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
:
not
(
*
)
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
DefaultNamespace
(
MATHML
.
into
(
)
)
Component
:
:
Negation
(
vec
!
[
Component
:
:
DefaultNamespace
(
MATHML
.
into
(
)
)
Component
:
:
ExplicitUniversalType
]
.
into_boxed_slice
(
)
)
]
specificity
(
0
0
0
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
:
not
(
e
)
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
DefaultNamespace
(
MATHML
.
into
(
)
)
Component
:
:
Negation
(
vec
!
[
Component
:
:
DefaultNamespace
(
MATHML
.
into
(
)
)
Component
:
:
LocalName
(
LocalName
{
name
:
DummyAtom
:
:
from
(
"
e
"
)
lower_name
:
DummyAtom
:
:
from
(
"
e
"
)
}
)
]
.
into_boxed_slice
(
)
)
]
specificity
(
0
0
1
)
)
]
)
)
)
;
assert_eq
!
(
parse
(
"
[
attr
|
=
\
"
foo
\
"
]
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
AttributeInNoNamespace
{
local_name
:
DummyAtom
:
:
from
(
"
attr
"
)
operator
:
AttrSelectorOperator
:
:
DashMatch
value
:
DummyAtom
:
:
from
(
"
foo
"
)
never_matches
:
false
case_sensitivity
:
ParsedCaseSensitivity
:
:
CaseSensitive
}
]
specificity
(
0
1
0
)
)
]
)
)
)
;
assert_eq
!
(
parse
(
"
:
:
before
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
PseudoElement
(
PseudoElement
:
:
Before
)
]
specificity
(
0
0
1
)
|
HAS_PSEUDO_BIT
)
]
)
)
)
;
assert_eq
!
(
parse
(
"
:
:
before
:
hover
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
PseudoElement
(
PseudoElement
:
:
Before
)
Component
:
:
NonTSPseudoClass
(
PseudoClass
:
:
Hover
)
]
specificity
(
0
1
1
)
|
HAS_PSEUDO_BIT
)
]
)
)
)
;
assert_eq
!
(
parse
(
"
:
:
before
:
hover
:
hover
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
PseudoElement
(
PseudoElement
:
:
Before
)
Component
:
:
NonTSPseudoClass
(
PseudoClass
:
:
Hover
)
Component
:
:
NonTSPseudoClass
(
PseudoClass
:
:
Hover
)
]
specificity
(
0
2
1
)
|
HAS_PSEUDO_BIT
)
]
)
)
)
;
assert
!
(
parse
(
"
:
:
before
:
hover
:
active
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
:
:
before
:
hover
.
foo
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
:
:
before
.
foo
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
:
:
before
~
bar
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
:
:
before
:
active
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
:
:
before
"
)
.
is_err
(
)
)
;
assert_eq
!
(
parse
(
"
div
:
:
after
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
LocalName
(
LocalName
{
name
:
DummyAtom
:
:
from
(
"
div
"
)
lower_name
:
DummyAtom
:
:
from
(
"
div
"
)
}
)
Component
:
:
Combinator
(
Combinator
:
:
Descendant
)
Component
:
:
Combinator
(
Combinator
:
:
PseudoElement
)
Component
:
:
PseudoElement
(
PseudoElement
:
:
After
)
]
specificity
(
0
0
2
)
|
HAS_PSEUDO_BIT
)
]
)
)
)
;
assert_eq
!
(
parse
(
"
#
d1
>
.
ok
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
ID
(
DummyAtom
:
:
from
(
"
d1
"
)
)
Component
:
:
Combinator
(
Combinator
:
:
Child
)
Component
:
:
Class
(
DummyAtom
:
:
from
(
"
ok
"
)
)
]
(
1
<
<
20
)
+
(
1
<
<
10
)
+
(
0
<
<
0
)
)
]
)
)
)
;
parser
.
default_ns
=
None
;
assert
!
(
parse
(
"
:
not
(
#
provel
.
old
)
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
:
not
(
#
provel
>
old
)
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
table
[
rules
]
:
not
(
[
rules
=
\
"
none
\
"
]
)
:
not
(
[
rules
=
\
"
\
"
]
)
"
)
.
is_ok
(
)
)
;
assert_eq
!
(
parse
(
"
:
not
(
#
provel
)
"
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
Negation
(
vec
!
[
Component
:
:
ID
(
DummyAtom
:
:
from
(
"
provel
"
)
)
]
.
into_boxed_slice
(
)
)
]
specificity
(
1
0
0
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
:
not
(
svg
|
circle
)
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
Negation
(
vec
!
[
Component
:
:
Namespace
(
DummyAtom
(
"
svg
"
.
into
(
)
)
SVG
.
into
(
)
)
Component
:
:
LocalName
(
LocalName
{
name
:
DummyAtom
:
:
from
(
"
circle
"
)
lower_name
:
DummyAtom
:
:
from
(
"
circle
"
)
}
)
]
.
into_boxed_slice
(
)
)
]
specificity
(
0
0
1
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
:
not
(
*
)
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
Negation
(
vec
!
[
Component
:
:
ExplicitUniversalType
]
.
into_boxed_slice
(
)
)
]
specificity
(
0
0
0
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
:
not
(
|
*
)
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
Negation
(
vec
!
[
Component
:
:
ExplicitNoNamespace
Component
:
:
ExplicitUniversalType
]
.
into_boxed_slice
(
)
)
]
specificity
(
0
0
0
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns_expected
(
"
:
not
(
*
|
*
)
"
&
parser
Some
(
"
:
not
(
*
)
"
)
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
Negation
(
vec
!
[
Component
:
:
ExplicitUniversalType
]
.
into_boxed_slice
(
)
)
]
specificity
(
0
0
0
)
)
]
)
)
)
;
assert_eq
!
(
parse_ns
(
"
:
not
(
svg
|
*
)
"
&
parser
)
Ok
(
SelectorList
:
:
from_vec
(
vec
!
[
Selector
:
:
from_vec
(
vec
!
[
Component
:
:
Negation
(
vec
!
[
Component
:
:
Namespace
(
DummyAtom
(
"
svg
"
.
into
(
)
)
SVG
.
into
(
)
)
Component
:
:
ExplicitUniversalType
]
.
into_boxed_slice
(
)
)
]
specificity
(
0
0
0
)
)
]
)
)
)
;
assert
!
(
parse
(
"
:
:
slotted
(
)
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
:
:
slotted
(
div
)
"
)
.
is_ok
(
)
)
;
assert
!
(
parse
(
"
:
:
slotted
(
div
)
.
foo
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
:
:
slotted
(
div
+
bar
)
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
:
:
slotted
(
div
)
+
foo
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
div
:
:
slotted
(
div
)
"
)
.
is_ok
(
)
)
;
assert
!
(
parse
(
"
div
+
slot
:
:
slotted
(
div
)
"
)
.
is_ok
(
)
)
;
assert
!
(
parse
(
"
div
+
slot
:
:
slotted
(
div
.
foo
)
"
)
.
is_ok
(
)
)
;
assert
!
(
parse
(
"
slot
:
:
slotted
(
div
foo
)
:
:
first
-
line
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
:
:
slotted
(
div
)
:
:
before
"
)
.
is_err
(
)
)
;
assert
!
(
parse
(
"
slot
:
:
slotted
(
div
foo
)
"
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
test_pseudo_iter
(
)
{
let
selector
=
&
parse
(
"
q
:
:
before
"
)
.
unwrap
(
)
.
0
[
0
]
;
assert
!
(
!
selector
.
is_universal
(
)
)
;
let
mut
iter
=
selector
.
iter
(
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
&
Component
:
:
PseudoElement
(
PseudoElement
:
:
Before
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
let
combinator
=
iter
.
next_sequence
(
)
;
assert_eq
!
(
combinator
Some
(
Combinator
:
:
PseudoElement
)
)
;
assert
!
(
matches
!
(
iter
.
next
(
)
Some
(
&
Component
:
:
LocalName
(
.
.
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next_sequence
(
)
None
)
;
}
#
[
test
]
fn
test_universal
(
)
{
let
selector
=
&
parse_ns
(
"
*
|
*
:
:
before
"
&
DummyParser
:
:
default_with_namespace
(
DummyAtom
:
:
from
(
"
https
:
/
/
mozilla
.
org
"
)
)
)
.
unwrap
(
)
.
0
[
0
]
;
assert
!
(
selector
.
is_universal
(
)
)
;
}
#
[
test
]
fn
test_empty_pseudo_iter
(
)
{
let
selector
=
&
parse
(
"
:
:
before
"
)
.
unwrap
(
)
.
0
[
0
]
;
assert
!
(
selector
.
is_universal
(
)
)
;
let
mut
iter
=
selector
.
iter
(
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
&
Component
:
:
PseudoElement
(
PseudoElement
:
:
Before
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next_sequence
(
)
None
)
;
}
struct
TestVisitor
{
seen
:
Vec
<
String
>
}
impl
SelectorVisitor
for
TestVisitor
{
type
Impl
=
DummySelectorImpl
;
fn
visit_simple_selector
(
&
mut
self
s
:
&
Component
<
DummySelectorImpl
>
)
-
>
bool
{
let
mut
dest
=
String
:
:
new
(
)
;
s
.
to_css
(
&
mut
dest
)
.
unwrap
(
)
;
self
.
seen
.
push
(
dest
)
;
true
}
}
#
[
test
]
fn
visitor
(
)
{
let
mut
test_visitor
=
TestVisitor
{
seen
:
vec
!
[
]
}
;
parse
(
"
:
not
(
:
hover
)
~
label
"
)
.
unwrap
(
)
.
0
[
0
]
.
visit
(
&
mut
test_visitor
)
;
assert
!
(
test_visitor
.
seen
.
contains
(
&
"
:
hover
"
.
into
(
)
)
)
;
let
mut
test_visitor
=
TestVisitor
{
seen
:
vec
!
[
]
}
;
parse
(
"
:
:
before
:
hover
"
)
.
unwrap
(
)
.
0
[
0
]
.
visit
(
&
mut
test_visitor
)
;
assert
!
(
test_visitor
.
seen
.
contains
(
&
"
:
hover
"
.
into
(
)
)
)
;
}
}
