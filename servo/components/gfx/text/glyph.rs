use
app_units
:
:
Au
;
use
euclid
:
:
point
:
:
Point2D
;
use
range
:
:
{
self
EachIndex
Range
RangeIndex
}
;
#
[
cfg
(
any
(
target_arch
=
"
x86_64
"
target_arch
=
"
aarch64
"
)
)
]
use
simd
:
:
u32x4
;
use
std
:
:
{
fmt
mem
u16
}
;
use
std
:
:
cmp
:
:
{
Ordering
PartialOrd
}
;
use
std
:
:
vec
:
:
Vec
;
pub
use
gfx_traits
:
:
ByteIndex
;
#
[
derive
(
Clone
Debug
Copy
Deserialize
Serialize
PartialEq
)
]
pub
struct
GlyphEntry
{
value
:
u32
}
impl
GlyphEntry
{
fn
new
(
value
:
u32
)
-
>
GlyphEntry
{
GlyphEntry
{
value
:
value
}
}
fn
initial
(
)
-
>
GlyphEntry
{
GlyphEntry
:
:
new
(
0
)
}
fn
simple
(
id
:
GlyphId
advance
:
Au
)
-
>
GlyphEntry
{
assert
!
(
is_simple_glyph_id
(
id
)
)
;
assert
!
(
is_simple_advance
(
advance
)
)
;
let
id_mask
=
id
as
u32
;
let
Au
(
advance
)
=
advance
;
let
advance_mask
=
(
advance
as
u32
)
<
<
GLYPH_ADVANCE_SHIFT
;
GlyphEntry
:
:
new
(
id_mask
|
advance_mask
|
FLAG_IS_SIMPLE_GLYPH
)
}
fn
complex
(
starts_cluster
:
bool
starts_ligature
:
bool
glyph_count
:
usize
)
-
>
GlyphEntry
{
assert
!
(
glyph_count
<
=
u16
:
:
MAX
as
usize
)
;
debug
!
(
"
creating
complex
glyph
entry
:
starts_cluster
=
{
}
starts_ligature
=
{
}
\
glyph_count
=
{
}
"
starts_cluster
starts_ligature
glyph_count
)
;
GlyphEntry
:
:
new
(
glyph_count
as
u32
)
}
fn
is_initial
(
&
self
)
-
>
bool
{
*
self
=
=
GlyphEntry
:
:
initial
(
)
}
}
pub
type
GlyphId
=
u32
;
const
FLAG_CHAR_IS_SPACE
:
u32
=
0x40000000
;
#
[
cfg
(
any
(
target_arch
=
"
x86_64
"
target_arch
=
"
aarch64
"
)
)
]
const
FLAG_CHAR_IS_SPACE_SHIFT
:
u32
=
30
;
const
FLAG_IS_SIMPLE_GLYPH
:
u32
=
0x80000000
;
const
GLYPH_ADVANCE_MASK
:
u32
=
0x3FFF0000
;
const
GLYPH_ADVANCE_SHIFT
:
u32
=
16
;
const
GLYPH_ID_MASK
:
u32
=
0x0000FFFF
;
const
GLYPH_COUNT_MASK
:
u32
=
0x0000FFFF
;
fn
is_simple_glyph_id
(
id
:
GlyphId
)
-
>
bool
{
(
(
id
as
u32
)
&
GLYPH_ID_MASK
)
=
=
id
}
fn
is_simple_advance
(
advance
:
Au
)
-
>
bool
{
advance
>
=
Au
(
0
)
&
&
{
let
unsigned_au
=
advance
.
0
as
u32
;
(
unsigned_au
&
(
GLYPH_ADVANCE_MASK
>
>
GLYPH_ADVANCE_SHIFT
)
)
=
=
unsigned_au
}
}
pub
type
DetailedGlyphCount
=
u16
;
impl
GlyphEntry
{
#
[
inline
(
always
)
]
fn
advance
(
&
self
)
-
>
Au
{
Au
(
(
(
self
.
value
&
GLYPH_ADVANCE_MASK
)
>
>
GLYPH_ADVANCE_SHIFT
)
as
i32
)
}
#
[
inline
]
fn
id
(
&
self
)
-
>
GlyphId
{
self
.
value
&
GLYPH_ID_MASK
}
fn
char_is_space
(
&
self
)
-
>
bool
{
self
.
has_flag
(
FLAG_CHAR_IS_SPACE
)
}
#
[
inline
(
always
)
]
fn
set_char_is_space
(
&
mut
self
)
{
self
.
value
|
=
FLAG_CHAR_IS_SPACE
;
}
fn
glyph_count
(
&
self
)
-
>
u16
{
assert
!
(
!
self
.
is_simple
(
)
)
;
(
self
.
value
&
GLYPH_COUNT_MASK
)
as
u16
}
#
[
inline
(
always
)
]
fn
is_simple
(
&
self
)
-
>
bool
{
self
.
has_flag
(
FLAG_IS_SIMPLE_GLYPH
)
}
#
[
inline
(
always
)
]
fn
has_flag
(
&
self
flag
:
u32
)
-
>
bool
{
(
self
.
value
&
flag
)
!
=
0
}
}
#
[
derive
(
Clone
Debug
Copy
Deserialize
Serialize
)
]
struct
DetailedGlyph
{
id
:
GlyphId
advance
:
Au
offset
:
Point2D
<
Au
>
}
impl
DetailedGlyph
{
fn
new
(
id
:
GlyphId
advance
:
Au
offset
:
Point2D
<
Au
>
)
-
>
DetailedGlyph
{
DetailedGlyph
{
id
:
id
advance
:
advance
offset
:
offset
}
}
}
#
[
derive
(
PartialEq
Clone
Eq
Debug
Copy
Deserialize
Serialize
)
]
struct
DetailedGlyphRecord
{
entry_offset
:
ByteIndex
detail_offset
:
usize
}
impl
PartialOrd
for
DetailedGlyphRecord
{
fn
partial_cmp
(
&
self
other
:
&
DetailedGlyphRecord
)
-
>
Option
<
Ordering
>
{
self
.
entry_offset
.
partial_cmp
(
&
other
.
entry_offset
)
}
}
impl
Ord
for
DetailedGlyphRecord
{
fn
cmp
(
&
self
other
:
&
DetailedGlyphRecord
)
-
>
Ordering
{
self
.
entry_offset
.
cmp
(
&
other
.
entry_offset
)
}
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
struct
DetailedGlyphStore
{
detail_buffer
:
Vec
<
DetailedGlyph
>
detail_lookup
:
Vec
<
DetailedGlyphRecord
>
lookup_is_sorted
:
bool
}
impl
<
'
a
>
DetailedGlyphStore
{
fn
new
(
)
-
>
DetailedGlyphStore
{
DetailedGlyphStore
{
detail_buffer
:
vec
!
(
)
detail_lookup
:
vec
!
(
)
lookup_is_sorted
:
false
}
}
fn
add_detailed_glyphs_for_entry
(
&
mut
self
entry_offset
:
ByteIndex
glyphs
:
&
[
DetailedGlyph
]
)
{
let
entry
=
DetailedGlyphRecord
{
entry_offset
:
entry_offset
detail_offset
:
self
.
detail_buffer
.
len
(
)
}
;
debug
!
(
"
Adding
entry
[
off
=
{
:
?
}
]
for
detailed
glyphs
:
{
:
?
}
"
entry_offset
glyphs
)
;
self
.
detail_lookup
.
push
(
entry
)
;
self
.
detail_buffer
.
extend_from_slice
(
glyphs
)
;
self
.
lookup_is_sorted
=
false
;
}
fn
detailed_glyphs_for_entry
(
&
'
a
self
entry_offset
:
ByteIndex
count
:
u16
)
-
>
&
'
a
[
DetailedGlyph
]
{
debug
!
(
"
Requesting
detailed
glyphs
[
n
=
{
}
]
for
entry
[
off
=
{
:
?
}
]
"
count
entry_offset
)
;
if
count
=
=
0
{
return
&
self
.
detail_buffer
[
0
.
.
0
]
;
}
assert
!
(
(
count
as
usize
)
<
=
self
.
detail_buffer
.
len
(
)
)
;
assert
!
(
self
.
lookup_is_sorted
)
;
let
key
=
DetailedGlyphRecord
{
entry_offset
:
entry_offset
detail_offset
:
0
}
;
let
i
=
self
.
detail_lookup
.
binary_search
(
&
key
)
.
expect
(
"
Invalid
index
not
found
in
detailed
glyph
lookup
table
!
"
)
;
assert
!
(
i
+
(
count
as
usize
)
<
=
self
.
detail_buffer
.
len
(
)
)
;
&
self
.
detail_buffer
[
i
.
.
i
+
count
as
usize
]
}
fn
detailed_glyph_with_index
(
&
'
a
self
entry_offset
:
ByteIndex
detail_offset
:
u16
)
-
>
&
'
a
DetailedGlyph
{
assert
!
(
(
detail_offset
as
usize
)
<
=
self
.
detail_buffer
.
len
(
)
)
;
assert
!
(
self
.
lookup_is_sorted
)
;
let
key
=
DetailedGlyphRecord
{
entry_offset
:
entry_offset
detail_offset
:
0
}
;
let
i
=
self
.
detail_lookup
.
binary_search
(
&
key
)
.
expect
(
"
Invalid
index
not
found
in
detailed
glyph
lookup
table
!
"
)
;
assert
!
(
i
+
(
detail_offset
as
usize
)
<
self
.
detail_buffer
.
len
(
)
)
;
&
self
.
detail_buffer
[
i
+
(
detail_offset
as
usize
)
]
}
fn
ensure_sorted
(
&
mut
self
)
{
if
self
.
lookup_is_sorted
{
return
;
}
let
mut
unsorted_records
:
Vec
<
DetailedGlyphRecord
>
=
vec
!
(
)
;
mem
:
:
swap
(
&
mut
self
.
detail_lookup
&
mut
unsorted_records
)
;
let
mut
mut_records
:
Vec
<
DetailedGlyphRecord
>
=
unsorted_records
;
mut_records
.
sort_by
(
|
a
b
|
{
if
a
<
b
{
Ordering
:
:
Less
}
else
{
Ordering
:
:
Greater
}
}
)
;
let
mut
sorted_records
=
mut_records
;
mem
:
:
swap
(
&
mut
self
.
detail_lookup
&
mut
sorted_records
)
;
self
.
lookup_is_sorted
=
true
;
}
}
#
[
derive
(
Copy
Clone
)
]
pub
struct
GlyphData
{
id
:
GlyphId
advance
:
Au
offset
:
Point2D
<
Au
>
cluster_start
:
bool
ligature_start
:
bool
}
impl
GlyphData
{
pub
fn
new
(
id
:
GlyphId
advance
:
Au
offset
:
Option
<
Point2D
<
Au
>
>
cluster_start
:
bool
ligature_start
:
bool
)
-
>
GlyphData
{
GlyphData
{
id
:
id
advance
:
advance
offset
:
offset
.
unwrap_or
(
Point2D
:
:
zero
(
)
)
cluster_start
:
cluster_start
ligature_start
:
ligature_start
}
}
}
#
[
derive
(
Copy
Clone
)
]
pub
enum
GlyphInfo
<
'
a
>
{
Simple
(
&
'
a
GlyphStore
ByteIndex
)
Detail
(
&
'
a
GlyphStore
ByteIndex
u16
)
}
impl
<
'
a
>
GlyphInfo
<
'
a
>
{
pub
fn
id
(
self
)
-
>
GlyphId
{
match
self
{
GlyphInfo
:
:
Simple
(
store
entry_i
)
=
>
store
.
entry_buffer
[
entry_i
.
to_usize
(
)
]
.
id
(
)
GlyphInfo
:
:
Detail
(
store
entry_i
detail_j
)
=
>
{
store
.
detail_store
.
detailed_glyph_with_index
(
entry_i
detail_j
)
.
id
}
}
}
#
[
inline
(
always
)
]
pub
fn
advance
(
self
)
-
>
Au
{
match
self
{
GlyphInfo
:
:
Simple
(
store
entry_i
)
=
>
store
.
entry_buffer
[
entry_i
.
to_usize
(
)
]
.
advance
(
)
GlyphInfo
:
:
Detail
(
store
entry_i
detail_j
)
=
>
{
store
.
detail_store
.
detailed_glyph_with_index
(
entry_i
detail_j
)
.
advance
}
}
}
#
[
inline
]
pub
fn
offset
(
self
)
-
>
Option
<
Point2D
<
Au
>
>
{
match
self
{
GlyphInfo
:
:
Simple
(
_
_
)
=
>
None
GlyphInfo
:
:
Detail
(
store
entry_i
detail_j
)
=
>
{
Some
(
store
.
detail_store
.
detailed_glyph_with_index
(
entry_i
detail_j
)
.
offset
)
}
}
}
pub
fn
char_is_space
(
self
)
-
>
bool
{
let
(
store
entry_i
)
=
match
self
{
GlyphInfo
:
:
Simple
(
store
entry_i
)
=
>
(
store
entry_i
)
GlyphInfo
:
:
Detail
(
store
entry_i
_
)
=
>
(
store
entry_i
)
}
;
store
.
char_is_space
(
entry_i
)
}
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
GlyphStore
{
entry_buffer
:
Vec
<
GlyphEntry
>
detail_store
:
DetailedGlyphStore
total_advance
:
Au
total_spaces
:
i32
has_detailed_glyphs
:
bool
is_whitespace
:
bool
is_rtl
:
bool
}
impl
<
'
a
>
GlyphStore
{
pub
fn
new
(
length
:
usize
is_whitespace
:
bool
is_rtl
:
bool
)
-
>
GlyphStore
{
assert
!
(
length
>
0
)
;
GlyphStore
{
entry_buffer
:
vec
!
[
GlyphEntry
:
:
initial
(
)
;
length
]
detail_store
:
DetailedGlyphStore
:
:
new
(
)
total_advance
:
Au
(
0
)
total_spaces
:
0
has_detailed_glyphs
:
false
is_whitespace
:
is_whitespace
is_rtl
:
is_rtl
}
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
ByteIndex
{
ByteIndex
(
self
.
entry_buffer
.
len
(
)
as
isize
)
}
#
[
inline
]
pub
fn
is_whitespace
(
&
self
)
-
>
bool
{
self
.
is_whitespace
}
pub
fn
finalize_changes
(
&
mut
self
)
{
self
.
detail_store
.
ensure_sorted
(
)
;
self
.
cache_total_advance_and_spaces
(
)
}
#
[
inline
(
never
)
]
fn
cache_total_advance_and_spaces
(
&
mut
self
)
{
let
mut
total_advance
=
Au
(
0
)
;
let
mut
total_spaces
=
0
;
for
glyph
in
self
.
iter_glyphs_for_byte_range
(
&
Range
:
:
new
(
ByteIndex
(
0
)
self
.
len
(
)
)
)
{
total_advance
=
total_advance
+
glyph
.
advance
(
)
;
if
glyph
.
char_is_space
(
)
{
total_spaces
+
=
1
;
}
}
self
.
total_advance
=
total_advance
;
self
.
total_spaces
=
total_spaces
;
}
pub
fn
add_glyph_for_byte_index
(
&
mut
self
i
:
ByteIndex
character
:
char
data
:
&
GlyphData
)
{
let
glyph_is_compressible
=
is_simple_glyph_id
(
data
.
id
)
&
&
is_simple_advance
(
data
.
advance
)
&
&
data
.
offset
=
=
Point2D
:
:
zero
(
)
&
&
data
.
cluster_start
;
debug_assert
!
(
data
.
ligature_start
)
;
debug_assert
!
(
i
<
self
.
len
(
)
)
;
let
mut
entry
=
if
glyph_is_compressible
{
GlyphEntry
:
:
simple
(
data
.
id
data
.
advance
)
}
else
{
let
glyph
=
&
[
DetailedGlyph
:
:
new
(
data
.
id
data
.
advance
data
.
offset
)
]
;
self
.
has_detailed_glyphs
=
true
;
self
.
detail_store
.
add_detailed_glyphs_for_entry
(
i
glyph
)
;
GlyphEntry
:
:
complex
(
data
.
cluster_start
data
.
ligature_start
1
)
}
;
if
character
=
=
'
'
{
entry
.
set_char_is_space
(
)
}
self
.
entry_buffer
[
i
.
to_usize
(
)
]
=
entry
;
}
pub
fn
add_glyphs_for_byte_index
(
&
mut
self
i
:
ByteIndex
data_for_glyphs
:
&
[
GlyphData
]
)
{
assert
!
(
i
<
self
.
len
(
)
)
;
assert
!
(
data_for_glyphs
.
len
(
)
>
0
)
;
let
glyph_count
=
data_for_glyphs
.
len
(
)
;
let
first_glyph_data
=
data_for_glyphs
[
0
]
;
let
glyphs_vec
:
Vec
<
DetailedGlyph
>
=
(
0
.
.
glyph_count
)
.
map
(
|
i
|
{
DetailedGlyph
:
:
new
(
data_for_glyphs
[
i
]
.
id
data_for_glyphs
[
i
]
.
advance
data_for_glyphs
[
i
]
.
offset
)
}
)
.
collect
(
)
;
self
.
has_detailed_glyphs
=
true
;
self
.
detail_store
.
add_detailed_glyphs_for_entry
(
i
&
glyphs_vec
)
;
let
entry
=
GlyphEntry
:
:
complex
(
first_glyph_data
.
cluster_start
first_glyph_data
.
ligature_start
glyph_count
)
;
debug
!
(
"
Adding
multiple
glyphs
[
idx
=
{
:
?
}
count
=
{
}
]
:
{
:
?
}
"
i
glyph_count
entry
)
;
self
.
entry_buffer
[
i
.
to_usize
(
)
]
=
entry
;
}
#
[
inline
]
pub
fn
iter_glyphs_for_byte_range
(
&
'
a
self
range
:
&
Range
<
ByteIndex
>
)
-
>
GlyphIterator
<
'
a
>
{
if
range
.
begin
(
)
>
=
self
.
len
(
)
{
panic
!
(
"
iter_glyphs_for_range
:
range
.
begin
beyond
length
!
"
)
;
}
if
range
.
end
(
)
>
self
.
len
(
)
{
panic
!
(
"
iter_glyphs_for_range
:
range
.
end
beyond
length
!
"
)
;
}
GlyphIterator
{
store
:
self
byte_index
:
if
self
.
is_rtl
{
range
.
end
(
)
}
else
{
range
.
begin
(
)
-
ByteIndex
(
1
)
}
byte_range
:
*
range
glyph_range
:
None
}
}
#
[
inline
]
pub
fn
range_index_of_advance
(
&
self
range
:
&
Range
<
ByteIndex
>
advance
:
Au
extra_word_spacing
:
Au
)
-
>
(
usize
Au
)
{
let
mut
index
=
0
;
let
mut
current_advance
=
Au
(
0
)
;
for
glyph
in
self
.
iter_glyphs_for_byte_range
(
range
)
{
if
glyph
.
char_is_space
(
)
{
current_advance
+
=
glyph
.
advance
(
)
+
extra_word_spacing
}
else
{
current_advance
+
=
glyph
.
advance
(
)
}
if
current_advance
>
advance
{
break
;
}
index
+
=
1
;
}
(
index
current_advance
)
}
#
[
inline
]
pub
fn
advance_for_byte_range
(
&
self
range
:
&
Range
<
ByteIndex
>
extra_word_spacing
:
Au
)
-
>
Au
{
if
range
.
begin
(
)
=
=
ByteIndex
(
0
)
&
&
range
.
end
(
)
=
=
self
.
len
(
)
{
self
.
total_advance
+
extra_word_spacing
*
self
.
total_spaces
}
else
if
!
self
.
has_detailed_glyphs
{
self
.
advance_for_byte_range_simple_glyphs
(
range
extra_word_spacing
)
}
else
{
self
.
advance_for_byte_range_slow_path
(
range
extra_word_spacing
)
}
}
#
[
inline
]
pub
fn
advance_for_byte_range_slow_path
(
&
self
range
:
&
Range
<
ByteIndex
>
extra_word_spacing
:
Au
)
-
>
Au
{
self
.
iter_glyphs_for_byte_range
(
range
)
.
fold
(
Au
(
0
)
|
advance
glyph
|
{
if
glyph
.
char_is_space
(
)
{
advance
+
glyph
.
advance
(
)
+
extra_word_spacing
}
else
{
advance
+
glyph
.
advance
(
)
}
}
)
}
#
[
inline
]
#
[
cfg
(
any
(
target_arch
=
"
x86_64
"
target_arch
=
"
aarch64
"
)
)
]
fn
advance_for_byte_range_simple_glyphs
(
&
self
range
:
&
Range
<
ByteIndex
>
extra_word_spacing
:
Au
)
-
>
Au
{
let
advance_mask
=
u32x4
:
:
splat
(
GLYPH_ADVANCE_MASK
)
;
let
space_flag_mask
=
u32x4
:
:
splat
(
FLAG_CHAR_IS_SPACE
)
;
let
mut
simd_advance
=
u32x4
:
:
splat
(
0
)
;
let
mut
simd_spaces
=
u32x4
:
:
splat
(
0
)
;
let
begin
=
range
.
begin
(
)
.
to_usize
(
)
;
let
len
=
range
.
length
(
)
.
to_usize
(
)
;
let
num_simd_iterations
=
len
/
4
;
let
leftover_entries
=
range
.
end
(
)
.
to_usize
(
)
-
(
len
-
num_simd_iterations
*
4
)
;
let
buf
=
self
.
transmute_entry_buffer_to_u32_buffer
(
)
;
for
i
in
0
.
.
num_simd_iterations
{
let
v
=
u32x4
:
:
load
(
buf
begin
+
i
*
4
)
;
let
advance
=
(
v
&
advance_mask
)
>
>
GLYPH_ADVANCE_SHIFT
;
let
spaces
=
(
v
&
space_flag_mask
)
>
>
FLAG_CHAR_IS_SPACE_SHIFT
;
simd_advance
=
simd_advance
+
advance
;
simd_spaces
=
simd_spaces
+
spaces
;
}
let
advance
=
(
simd_advance
.
extract
(
0
)
+
simd_advance
.
extract
(
1
)
+
simd_advance
.
extract
(
2
)
+
simd_advance
.
extract
(
3
)
)
as
i32
;
let
spaces
=
(
simd_spaces
.
extract
(
0
)
+
simd_spaces
.
extract
(
1
)
+
simd_spaces
.
extract
(
2
)
+
simd_spaces
.
extract
(
3
)
)
as
i32
;
let
mut
leftover_advance
=
Au
(
0
)
;
let
mut
leftover_spaces
=
0
;
for
i
in
leftover_entries
.
.
range
.
end
(
)
.
to_usize
(
)
{
leftover_advance
=
leftover_advance
+
self
.
entry_buffer
[
i
]
.
advance
(
)
;
if
self
.
entry_buffer
[
i
]
.
char_is_space
(
)
{
leftover_spaces
+
=
1
;
}
}
Au
(
advance
)
+
leftover_advance
+
extra_word_spacing
*
(
spaces
+
leftover_spaces
)
}
#
[
inline
]
#
[
cfg
(
not
(
any
(
target_arch
=
"
x86_64
"
target_arch
=
"
aarch64
"
)
)
)
]
fn
advance_for_byte_range_simple_glyphs
(
&
self
range
:
&
Range
<
ByteIndex
>
extra_word_spacing
:
Au
)
-
>
Au
{
self
.
advance_for_byte_range_slow_path
(
range
extra_word_spacing
)
}
#
[
inline
]
#
[
cfg
(
any
(
target_arch
=
"
x86_64
"
target_arch
=
"
aarch64
"
)
)
]
#
[
allow
(
unsafe_code
)
]
fn
transmute_entry_buffer_to_u32_buffer
(
&
self
)
-
>
&
[
u32
]
{
unsafe
{
mem
:
:
transmute
(
self
.
entry_buffer
.
as_slice
(
)
)
}
}
pub
fn
char_is_space
(
&
self
i
:
ByteIndex
)
-
>
bool
{
assert
!
(
i
<
self
.
len
(
)
)
;
self
.
entry_buffer
[
i
.
to_usize
(
)
]
.
char_is_space
(
)
}
pub
fn
space_count_in_range
(
&
self
range
:
&
Range
<
ByteIndex
>
)
-
>
u32
{
let
mut
spaces
=
0
;
for
index
in
range
.
each_index
(
)
{
if
self
.
char_is_space
(
index
)
{
spaces
+
=
1
}
}
spaces
}
}
impl
fmt
:
:
Debug
for
GlyphStore
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
try
!
(
write
!
(
formatter
"
GlyphStore
:
\
n
"
)
)
;
let
mut
detailed_buffer
=
self
.
detail_store
.
detail_buffer
.
iter
(
)
;
for
entry
in
self
.
entry_buffer
.
iter
(
)
{
if
entry
.
is_simple
(
)
{
try
!
(
write
!
(
formatter
"
simple
id
=
{
:
?
}
advance
=
{
:
?
}
\
n
"
entry
.
id
(
)
entry
.
advance
(
)
)
)
;
continue
}
if
entry
.
is_initial
(
)
{
continue
}
try
!
(
write
!
(
formatter
"
complex
.
.
.
"
)
)
;
if
detailed_buffer
.
next
(
)
.
is_none
(
)
{
continue
}
try
!
(
write
!
(
formatter
"
detailed
id
=
{
:
?
}
advance
=
{
:
?
}
\
n
"
entry
.
id
(
)
entry
.
advance
(
)
)
)
;
}
Ok
(
(
)
)
}
}
pub
struct
GlyphIterator
<
'
a
>
{
store
:
&
'
a
GlyphStore
byte_index
:
ByteIndex
byte_range
:
Range
<
ByteIndex
>
glyph_range
:
Option
<
EachIndex
<
isize
ByteIndex
>
>
}
impl
<
'
a
>
GlyphIterator
<
'
a
>
{
#
[
inline
(
never
)
]
fn
next_glyph_range
(
&
mut
self
)
-
>
Option
<
GlyphInfo
<
'
a
>
>
{
match
self
.
glyph_range
.
as_mut
(
)
.
unwrap
(
)
.
next
(
)
{
Some
(
j
)
=
>
{
Some
(
GlyphInfo
:
:
Detail
(
self
.
store
self
.
byte_index
j
.
get
(
)
as
u16
)
)
}
None
=
>
{
self
.
glyph_range
=
None
;
self
.
next
(
)
}
}
}
#
[
inline
(
never
)
]
fn
next_complex_glyph
(
&
mut
self
entry
:
&
GlyphEntry
i
:
ByteIndex
)
-
>
Option
<
GlyphInfo
<
'
a
>
>
{
let
glyphs
=
self
.
store
.
detail_store
.
detailed_glyphs_for_entry
(
i
entry
.
glyph_count
(
)
)
;
self
.
glyph_range
=
Some
(
range
:
:
each_index
(
ByteIndex
(
0
)
ByteIndex
(
glyphs
.
len
(
)
as
isize
)
)
)
;
self
.
next
(
)
}
}
impl
<
'
a
>
Iterator
for
GlyphIterator
<
'
a
>
{
type
Item
=
GlyphInfo
<
'
a
>
;
#
[
inline
(
always
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
GlyphInfo
<
'
a
>
>
{
if
self
.
glyph_range
.
is_some
(
)
{
return
self
.
next_glyph_range
(
)
}
self
.
byte_index
=
self
.
byte_index
+
if
self
.
store
.
is_rtl
{
ByteIndex
(
-
1
)
}
else
{
ByteIndex
(
1
)
}
;
let
i
=
self
.
byte_index
;
if
!
self
.
byte_range
.
contains
(
i
)
{
return
None
}
debug_assert
!
(
i
<
self
.
store
.
len
(
)
)
;
let
entry
=
self
.
store
.
entry_buffer
[
i
.
to_usize
(
)
]
;
if
entry
.
is_simple
(
)
{
Some
(
GlyphInfo
:
:
Simple
(
self
.
store
i
)
)
}
else
{
self
.
next_complex_glyph
(
&
entry
i
)
}
}
}
