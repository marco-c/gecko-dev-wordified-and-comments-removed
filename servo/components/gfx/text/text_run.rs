use
app_units
:
:
Au
;
use
font
:
:
{
Font
FontHandleMethods
FontMetrics
IS_WHITESPACE_SHAPING_FLAG
RunMetrics
}
;
use
font
:
:
{
ShapingOptions
}
;
use
platform
:
:
font_template
:
:
FontTemplateData
;
use
range
:
:
Range
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
cmp
:
:
{
Ordering
max
}
;
use
std
:
:
slice
:
:
Iter
;
use
std
:
:
sync
:
:
Arc
;
use
text
:
:
glyph
:
:
{
ByteIndex
GlyphStore
}
;
use
webrender_traits
;
thread_local
!
{
static
INDEX_OF_FIRST_GLYPH_RUN_CACHE
:
Cell
<
Option
<
(
*
const
TextRun
ByteIndex
usize
)
>
>
=
Cell
:
:
new
(
None
)
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
TextRun
{
pub
text
:
Arc
<
String
>
pub
font_template
:
Arc
<
FontTemplateData
>
pub
actual_pt_size
:
Au
pub
font_metrics
:
FontMetrics
pub
font_key
:
Option
<
webrender_traits
:
:
FontKey
>
pub
glyphs
:
Arc
<
Vec
<
GlyphRun
>
>
pub
bidi_level
:
u8
}
impl
Drop
for
TextRun
{
fn
drop
(
&
mut
self
)
{
INDEX_OF_FIRST_GLYPH_RUN_CACHE
.
with
(
|
index_of_first_glyph_run_cache
|
{
if
let
Some
(
(
text_run_ptr
_
_
)
)
=
index_of_first_glyph_run_cache
.
get
(
)
{
if
text_run_ptr
=
=
(
self
as
*
const
TextRun
)
{
index_of_first_glyph_run_cache
.
set
(
None
)
;
}
}
}
)
}
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
GlyphRun
{
pub
glyph_store
:
Arc
<
GlyphStore
>
pub
range
:
Range
<
ByteIndex
>
}
pub
struct
NaturalWordSliceIterator
<
'
a
>
{
glyphs
:
&
'
a
[
GlyphRun
]
index
:
usize
range
:
Range
<
ByteIndex
>
reverse
:
bool
}
impl
GlyphRun
{
fn
compare
(
&
self
key
:
&
ByteIndex
)
-
>
Ordering
{
if
*
key
<
self
.
range
.
begin
(
)
{
Ordering
:
:
Greater
}
else
if
*
key
>
=
self
.
range
.
end
(
)
{
Ordering
:
:
Less
}
else
{
Ordering
:
:
Equal
}
}
}
pub
struct
TextRunSlice
<
'
a
>
{
pub
glyphs
:
&
'
a
GlyphStore
pub
offset
:
ByteIndex
pub
range
:
Range
<
ByteIndex
>
}
impl
<
'
a
>
TextRunSlice
<
'
a
>
{
#
[
inline
]
pub
fn
text_run_range
(
&
self
)
-
>
Range
<
ByteIndex
>
{
let
mut
range
=
self
.
range
;
range
.
shift_by
(
self
.
offset
)
;
range
}
}
impl
<
'
a
>
Iterator
for
NaturalWordSliceIterator
<
'
a
>
{
type
Item
=
TextRunSlice
<
'
a
>
;
#
[
inline
(
always
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
TextRunSlice
<
'
a
>
>
{
let
slice_glyphs
;
if
self
.
reverse
{
if
self
.
index
=
=
0
{
return
None
;
}
self
.
index
-
=
1
;
slice_glyphs
=
&
self
.
glyphs
[
self
.
index
]
;
}
else
{
if
self
.
index
>
=
self
.
glyphs
.
len
(
)
{
return
None
;
}
slice_glyphs
=
&
self
.
glyphs
[
self
.
index
]
;
self
.
index
+
=
1
;
}
let
mut
byte_range
=
self
.
range
.
intersect
(
&
slice_glyphs
.
range
)
;
let
slice_range_begin
=
slice_glyphs
.
range
.
begin
(
)
;
byte_range
.
shift_by
(
-
slice_range_begin
)
;
if
!
byte_range
.
is_empty
(
)
{
Some
(
TextRunSlice
{
glyphs
:
&
*
slice_glyphs
.
glyph_store
offset
:
slice_range_begin
range
:
byte_range
}
)
}
else
{
None
}
}
}
pub
struct
CharacterSliceIterator
<
'
a
>
{
text
:
&
'
a
str
glyph_run
:
Option
<
&
'
a
GlyphRun
>
glyph_run_iter
:
Iter
<
'
a
GlyphRun
>
range
:
Range
<
ByteIndex
>
}
impl
<
'
a
>
Iterator
for
CharacterSliceIterator
<
'
a
>
{
type
Item
=
TextRunSlice
<
'
a
>
;
#
[
inline
(
always
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
TextRunSlice
<
'
a
>
>
{
let
glyph_run
=
match
self
.
glyph_run
{
None
=
>
return
None
Some
(
glyph_run
)
=
>
glyph_run
}
;
debug_assert
!
(
!
self
.
range
.
is_empty
(
)
)
;
let
byte_start
=
self
.
range
.
begin
(
)
;
let
byte_len
=
match
self
.
text
[
byte_start
.
to_usize
(
)
.
.
]
.
chars
(
)
.
next
(
)
{
Some
(
ch
)
=
>
ByteIndex
(
ch
.
len_utf8
(
)
as
isize
)
None
=
>
unreachable
!
(
)
}
;
self
.
range
.
adjust_by
(
byte_len
-
byte_len
)
;
if
self
.
range
.
is_empty
(
)
{
self
.
glyph_run
=
None
}
else
if
self
.
range
.
intersect
(
&
glyph_run
.
range
)
.
is_empty
(
)
{
self
.
glyph_run
=
self
.
glyph_run_iter
.
next
(
)
;
}
let
index_within_glyph_run
=
byte_start
-
glyph_run
.
range
.
begin
(
)
;
Some
(
TextRunSlice
{
glyphs
:
&
*
glyph_run
.
glyph_store
offset
:
glyph_run
.
range
.
begin
(
)
range
:
Range
:
:
new
(
index_within_glyph_run
byte_len
)
}
)
}
}
impl
<
'
a
>
TextRun
{
pub
fn
new
(
font
:
&
mut
Font
text
:
String
options
:
&
ShapingOptions
bidi_level
:
u8
)
-
>
TextRun
{
let
glyphs
=
TextRun
:
:
break_and_shape
(
font
&
text
options
)
;
TextRun
{
text
:
Arc
:
:
new
(
text
)
font_metrics
:
font
.
metrics
.
clone
(
)
font_template
:
font
.
handle
.
template
(
)
font_key
:
font
.
font_key
actual_pt_size
:
font
.
actual_pt_size
glyphs
:
Arc
:
:
new
(
glyphs
)
bidi_level
:
bidi_level
}
}
pub
fn
break_and_shape
(
font
:
&
mut
Font
text
:
&
str
options
:
&
ShapingOptions
)
-
>
Vec
<
GlyphRun
>
{
let
mut
glyphs
=
vec
!
(
)
;
let
mut
byte_i
=
0
;
let
mut
cur_slice_is_whitespace
=
false
;
let
mut
byte_last_boundary
=
0
;
for
ch
in
text
.
chars
(
)
{
let
can_break_before
=
if
cur_slice_is_whitespace
{
match
ch
{
'
'
|
'
\
t
'
|
'
\
n
'
=
>
false
_
=
>
{
cur_slice_is_whitespace
=
false
;
true
}
}
}
else
{
match
ch
{
'
'
|
'
\
t
'
|
'
\
n
'
=
>
{
cur_slice_is_whitespace
=
true
;
true
}
_
=
>
false
}
}
;
if
can_break_before
&
&
byte_i
>
byte_last_boundary
{
let
slice
=
&
text
[
byte_last_boundary
.
.
byte_i
]
;
debug
!
(
"
creating
glyph
store
for
slice
{
}
(
ws
?
{
}
)
{
}
-
{
}
in
run
{
}
"
slice
!
cur_slice_is_whitespace
byte_last_boundary
byte_i
text
)
;
let
mut
options
=
*
options
;
if
!
cur_slice_is_whitespace
{
options
.
flags
.
insert
(
IS_WHITESPACE_SHAPING_FLAG
)
;
}
glyphs
.
push
(
GlyphRun
{
glyph_store
:
font
.
shape_text
(
slice
&
options
)
range
:
Range
:
:
new
(
ByteIndex
(
byte_last_boundary
as
isize
)
ByteIndex
(
(
byte_i
-
byte_last_boundary
)
as
isize
)
)
}
)
;
byte_last_boundary
=
byte_i
;
}
byte_i
=
byte_i
+
ch
.
len_utf8
(
)
;
}
if
byte_i
>
byte_last_boundary
{
let
slice
=
&
text
[
byte_last_boundary
.
.
]
;
debug
!
(
"
creating
glyph
store
for
final
slice
{
}
(
ws
?
{
}
)
{
}
-
{
}
in
run
{
}
"
slice
cur_slice_is_whitespace
byte_last_boundary
text
.
len
(
)
text
)
;
let
mut
options
=
*
options
;
if
cur_slice_is_whitespace
{
options
.
flags
.
insert
(
IS_WHITESPACE_SHAPING_FLAG
)
;
}
glyphs
.
push
(
GlyphRun
{
glyph_store
:
font
.
shape_text
(
slice
&
options
)
range
:
Range
:
:
new
(
ByteIndex
(
byte_last_boundary
as
isize
)
ByteIndex
(
(
byte_i
-
byte_last_boundary
)
as
isize
)
)
}
)
;
}
glyphs
}
pub
fn
ascent
(
&
self
)
-
>
Au
{
self
.
font_metrics
.
ascent
}
pub
fn
descent
(
&
self
)
-
>
Au
{
self
.
font_metrics
.
descent
}
pub
fn
advance_for_range
(
&
self
range
:
&
Range
<
ByteIndex
>
)
-
>
Au
{
if
range
.
is_empty
(
)
{
return
Au
(
0
)
}
self
.
natural_word_slices_in_range
(
range
)
.
fold
(
Au
(
0
)
|
advance
slice
|
{
advance
+
slice
.
glyphs
.
advance_for_byte_range
(
&
slice
.
range
)
}
)
}
pub
fn
metrics_for_range
(
&
self
range
:
&
Range
<
ByteIndex
>
)
-
>
RunMetrics
{
RunMetrics
:
:
new
(
self
.
advance_for_range
(
range
)
self
.
font_metrics
.
ascent
self
.
font_metrics
.
descent
)
}
pub
fn
metrics_for_slice
(
&
self
glyphs
:
&
GlyphStore
slice_range
:
&
Range
<
ByteIndex
>
)
-
>
RunMetrics
{
RunMetrics
:
:
new
(
glyphs
.
advance_for_byte_range
(
slice_range
)
self
.
font_metrics
.
ascent
self
.
font_metrics
.
descent
)
}
pub
fn
min_width_for_range
(
&
self
range
:
&
Range
<
ByteIndex
>
)
-
>
Au
{
debug
!
(
"
iterating
outer
range
{
:
?
}
"
range
)
;
self
.
natural_word_slices_in_range
(
range
)
.
fold
(
Au
(
0
)
|
max_piece_width
slice
|
{
debug
!
(
"
iterated
on
{
:
?
}
[
{
:
?
}
]
"
slice
.
offset
slice
.
range
)
;
max
(
max_piece_width
self
.
advance_for_range
(
&
slice
.
range
)
)
}
)
}
fn
index_of_first_glyph_run_containing
(
&
self
index
:
ByteIndex
)
-
>
Option
<
usize
>
{
let
self_ptr
=
self
as
*
const
TextRun
;
INDEX_OF_FIRST_GLYPH_RUN_CACHE
.
with
(
|
index_of_first_glyph_run_cache
|
{
if
let
Some
(
(
last_text_run
last_index
last_result
)
)
=
index_of_first_glyph_run_cache
.
get
(
)
{
if
last_text_run
=
=
self_ptr
&
&
last_index
=
=
index
{
return
Some
(
last_result
)
}
}
if
let
Ok
(
result
)
=
(
&
*
*
self
.
glyphs
)
.
binary_search_by
(
|
current
|
current
.
compare
(
&
index
)
)
{
index_of_first_glyph_run_cache
.
set
(
Some
(
(
self_ptr
index
result
)
)
)
;
Some
(
result
)
}
else
{
None
}
}
)
}
pub
fn
natural_word_slices_in_range
(
&
'
a
self
range
:
&
Range
<
ByteIndex
>
)
-
>
NaturalWordSliceIterator
<
'
a
>
{
let
index
=
match
self
.
index_of_first_glyph_run_containing
(
range
.
begin
(
)
)
{
None
=
>
self
.
glyphs
.
len
(
)
Some
(
index
)
=
>
index
}
;
NaturalWordSliceIterator
{
glyphs
:
&
self
.
glyphs
[
.
.
]
index
:
index
range
:
*
range
reverse
:
false
}
}
pub
fn
natural_word_slices_in_visual_order
(
&
'
a
self
range
:
&
Range
<
ByteIndex
>
)
-
>
NaturalWordSliceIterator
<
'
a
>
{
let
reverse
=
self
.
bidi_level
%
2
=
=
1
;
let
index
=
if
reverse
{
match
self
.
index_of_first_glyph_run_containing
(
range
.
end
(
)
-
ByteIndex
(
1
)
)
{
Some
(
i
)
=
>
i
+
1
None
=
>
0
}
}
else
{
match
self
.
index_of_first_glyph_run_containing
(
range
.
begin
(
)
)
{
Some
(
i
)
=
>
i
None
=
>
self
.
glyphs
.
len
(
)
}
}
;
NaturalWordSliceIterator
{
glyphs
:
&
self
.
glyphs
[
.
.
]
index
:
index
range
:
*
range
reverse
:
reverse
}
}
pub
fn
character_slices_in_range
(
&
'
a
self
range
:
&
Range
<
ByteIndex
>
)
-
>
CharacterSliceIterator
<
'
a
>
{
let
index
=
match
self
.
index_of_first_glyph_run_containing
(
range
.
begin
(
)
)
{
None
=
>
self
.
glyphs
.
len
(
)
Some
(
index
)
=
>
index
}
;
let
mut
glyph_run_iter
=
self
.
glyphs
[
index
.
.
]
.
iter
(
)
;
let
first_glyph_run
=
glyph_run_iter
.
next
(
)
;
CharacterSliceIterator
{
text
:
&
self
.
text
glyph_run
:
first_glyph_run
glyph_run_iter
:
glyph_run_iter
range
:
*
range
}
}
}
