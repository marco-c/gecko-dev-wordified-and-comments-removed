use
color
:
:
Color
;
use
render_context
:
:
RenderContext
;
use
text
:
:
glyph
:
:
CharIndex
;
use
text
:
:
TextRun
;
use
collections
:
:
dlist
:
:
DList
;
use
collections
:
:
dlist
;
use
geom
:
:
{
Point2D
Rect
SideOffsets2D
Size2D
Matrix2D
}
;
use
libc
:
:
uintptr_t
;
use
servo_net
:
:
image
:
:
base
:
:
Image
;
use
servo_util
:
:
geometry
:
:
Au
;
use
servo_util
:
:
range
:
:
Range
;
use
std
:
:
fmt
;
use
std
:
:
mem
;
use
std
:
:
slice
:
:
Items
;
use
style
:
:
computed_values
:
:
border_style
;
use
sync
:
:
Arc
;
use
std
:
:
num
:
:
Zero
;
use
std
:
:
ptr
;
use
azure
:
:
AzFloat
;
use
azure
:
:
scaled_font
:
:
ScaledFont
;
use
azure
:
:
azure_hl
:
:
ColorPattern
;
pub
mod
optimizer
;
#
[
deriving
(
Clone
PartialEq
)
]
pub
struct
OpaqueNode
(
pub
uintptr_t
)
;
impl
OpaqueNode
{
pub
fn
id
(
&
self
)
-
>
uintptr_t
{
let
OpaqueNode
(
pointer
)
=
*
self
;
pointer
}
}
trait
ScaledFontExtensionMethods
{
fn
draw_text_into_context
(
&
self
rctx
:
&
RenderContext
run
:
&
Box
<
TextRun
>
range
:
&
Range
<
CharIndex
>
baseline_origin
:
Point2D
<
Au
>
color
:
Color
antialias
:
bool
)
;
}
impl
ScaledFontExtensionMethods
for
ScaledFont
{
fn
draw_text_into_context
(
&
self
rctx
:
&
RenderContext
run
:
&
Box
<
TextRun
>
range
:
&
Range
<
CharIndex
>
baseline_origin
:
Point2D
<
Au
>
color
:
Color
antialias
:
bool
)
{
use
libc
:
:
types
:
:
common
:
:
c99
:
:
uint32_t
;
use
azure
:
:
{
struct__AzDrawOptions
struct__AzGlyph
struct__AzGlyphBuffer
struct__AzPoint
}
;
use
azure
:
:
azure
:
:
{
AzDrawTargetFillGlyphs
}
;
let
target
=
rctx
.
get_draw_target
(
)
;
let
pattern
=
ColorPattern
:
:
new
(
color
)
;
let
azure_pattern
=
pattern
.
azure_color_pattern
;
assert
!
(
azure_pattern
.
is_not_null
(
)
)
;
let
fields
=
if
antialias
{
0x0200
}
else
{
0
}
;
let
mut
options
=
struct__AzDrawOptions
{
mAlpha
:
1f64
as
AzFloat
fields
:
fields
}
;
let
mut
origin
=
baseline_origin
.
clone
(
)
;
let
mut
azglyphs
=
vec
!
(
)
;
azglyphs
.
reserve
(
range
.
length
(
)
.
to_uint
(
)
)
;
for
(
glyphs
_offset
slice_range
)
in
run
.
iter_slices_for_range
(
range
)
{
for
(
_i
glyph
)
in
glyphs
.
iter_glyphs_for_char_range
(
&
slice_range
)
{
let
glyph_advance
=
glyph
.
advance
(
)
;
let
glyph_offset
=
glyph
.
offset
(
)
.
unwrap_or
(
Zero
:
:
zero
(
)
)
;
let
azglyph
=
struct__AzGlyph
{
mIndex
:
glyph
.
id
(
)
as
uint32_t
mPosition
:
struct__AzPoint
{
x
:
(
origin
.
x
+
glyph_offset
.
x
)
.
to_subpx
(
)
as
AzFloat
y
:
(
origin
.
y
+
glyph_offset
.
y
)
.
to_subpx
(
)
as
AzFloat
}
}
;
origin
=
Point2D
(
origin
.
x
+
glyph_advance
origin
.
y
)
;
azglyphs
.
push
(
azglyph
)
}
;
}
let
azglyph_buf_len
=
azglyphs
.
len
(
)
;
if
azglyph_buf_len
=
=
0
{
return
;
}
let
mut
glyphbuf
=
struct__AzGlyphBuffer
{
mGlyphs
:
azglyphs
.
as_mut_ptr
(
)
mNumGlyphs
:
azglyph_buf_len
as
uint32_t
}
;
unsafe
{
AzDrawTargetFillGlyphs
(
target
.
azure_draw_target
self
.
get_ref
(
)
&
mut
glyphbuf
azure_pattern
&
mut
options
ptr
:
:
null_mut
(
)
)
;
}
}
}
#
[
deriving
(
Clone
PartialEq
)
]
pub
enum
StackingLevel
{
BackgroundAndBordersStackingLevel
BlockBackgroundsAndBordersStackingLevel
FloatStackingLevel
ContentStackingLevel
PositionedDescendantStackingLevel
(
i32
)
}
impl
StackingLevel
{
pub
fn
from_background_and_border_level
(
level
:
BackgroundAndBorderLevel
)
-
>
StackingLevel
{
match
level
{
RootOfStackingContextLevel
=
>
BackgroundAndBordersStackingLevel
BlockLevel
=
>
BlockBackgroundsAndBordersStackingLevel
ContentLevel
=
>
ContentStackingLevel
}
}
}
struct
StackingContext
{
pub
background_and_borders
:
DisplayList
pub
block_backgrounds_and_borders
:
DisplayList
pub
floats
:
DisplayList
pub
content
:
DisplayList
pub
positioned_descendants
:
Vec
<
(
i32
DisplayList
)
>
}
impl
StackingContext
{
fn
new
(
list
:
DisplayList
)
-
>
StackingContext
{
let
DisplayList
{
list
:
list
}
=
list
;
let
mut
stacking_context
=
StackingContext
{
background_and_borders
:
DisplayList
:
:
new
(
)
block_backgrounds_and_borders
:
DisplayList
:
:
new
(
)
floats
:
DisplayList
:
:
new
(
)
content
:
DisplayList
:
:
new
(
)
positioned_descendants
:
Vec
:
:
new
(
)
}
;
for
item
in
list
.
into_iter
(
)
{
match
item
.
base
(
)
.
level
{
BackgroundAndBordersStackingLevel
=
>
{
stacking_context
.
background_and_borders
.
push
(
item
)
}
BlockBackgroundsAndBordersStackingLevel
=
>
{
stacking_context
.
block_backgrounds_and_borders
.
push
(
item
)
}
FloatStackingLevel
=
>
stacking_context
.
floats
.
push
(
item
)
ContentStackingLevel
=
>
stacking_context
.
content
.
push
(
item
)
PositionedDescendantStackingLevel
(
z_index
)
=
>
{
match
stacking_context
.
positioned_descendants
.
iter_mut
(
)
.
find
(
|
&
&
(
z
_
)
|
z_index
=
=
z
)
{
Some
(
&
(
_
ref
mut
my_list
)
)
=
>
{
my_list
.
push
(
item
)
;
continue
}
None
=
>
{
}
}
let
mut
new_list
=
DisplayList
:
:
new
(
)
;
new_list
.
list
.
push
(
item
)
;
stacking_context
.
positioned_descendants
.
push
(
(
z_index
new_list
)
)
}
}
}
stacking_context
}
}
pub
enum
BackgroundAndBorderLevel
{
RootOfStackingContextLevel
BlockLevel
ContentLevel
}
#
[
deriving
(
Clone
Show
)
]
pub
struct
DisplayList
{
pub
list
:
DList
<
DisplayItem
>
}
pub
enum
DisplayListIterator
<
'
a
>
{
EmptyDisplayListIterator
ParentDisplayListIterator
(
Items
<
'
a
DisplayList
>
)
}
impl
<
'
a
>
Iterator
<
&
'
a
DisplayList
>
for
DisplayListIterator
<
'
a
>
{
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
DisplayList
>
{
match
*
self
{
EmptyDisplayListIterator
=
>
None
ParentDisplayListIterator
(
ref
mut
subiterator
)
=
>
subiterator
.
next
(
)
}
}
}
impl
DisplayList
{
pub
fn
new
(
)
-
>
DisplayList
{
DisplayList
{
list
:
DList
:
:
new
(
)
}
}
pub
fn
push
(
&
mut
self
item
:
DisplayItem
)
{
self
.
list
.
push
(
item
)
}
pub
fn
push_all_move
(
&
mut
self
other
:
DisplayList
)
{
self
.
list
.
append
(
other
.
list
)
}
pub
fn
debug
(
&
self
)
{
if
log_enabled
!
(
:
:
log
:
:
DEBUG
)
{
for
item
in
self
.
list
.
iter
(
)
{
item
.
debug_with_level
(
0
)
;
}
}
}
pub
fn
draw_into_context
(
&
self
render_context
:
&
mut
RenderContext
current_transform
:
&
Matrix2D
<
AzFloat
>
current_clip_rect
:
&
Rect
<
Au
>
)
{
debug
!
(
"
Beginning
display
list
.
"
)
;
for
item
in
self
.
list
.
iter
(
)
{
item
.
draw_into_context
(
render_context
current_transform
current_clip_rect
)
}
debug
!
(
"
Ending
display
list
.
"
)
;
}
pub
fn
iter
<
'
a
>
(
&
'
a
self
)
-
>
DisplayItemIterator
<
'
a
>
{
ParentDisplayItemIterator
(
self
.
list
.
iter
(
)
)
}
pub
fn
flatten
(
self
resulting_level
:
StackingLevel
)
-
>
DisplayList
{
let
mut
result
=
DisplayList
:
:
new
(
)
;
let
StackingContext
{
background_and_borders
block_backgrounds_and_borders
floats
content
positioned_descendants
:
mut
positioned_descendants
}
=
StackingContext
:
:
new
(
self
)
;
result
.
push_all_move
(
background_and_borders
)
;
positioned_descendants
.
sort_by
(
|
&
(
z_index_a
_
)
&
(
z_index_b
_
)
|
{
z_index_a
.
cmp
(
&
z_index_b
)
}
)
;
for
&
(
ref
mut
z_index
ref
mut
list
)
in
positioned_descendants
.
iter_mut
(
)
{
if
*
z_index
<
0
{
result
.
push_all_move
(
mem
:
:
replace
(
list
DisplayList
:
:
new
(
)
)
)
}
}
result
.
push_all_move
(
block_backgrounds_and_borders
)
;
result
.
push_all_move
(
floats
)
;
result
.
push_all_move
(
content
)
;
for
&
(
ref
mut
z_index
ref
mut
list
)
in
positioned_descendants
.
iter_mut
(
)
{
if
*
z_index
>
=
0
{
result
.
push_all_move
(
mem
:
:
replace
(
list
DisplayList
:
:
new
(
)
)
)
}
}
result
.
set_stacking_level
(
resulting_level
)
;
result
}
fn
set_stacking_level
(
&
mut
self
new_level
:
StackingLevel
)
{
for
item
in
self
.
list
.
iter_mut
(
)
{
item
.
mut_base
(
)
.
level
=
new_level
;
}
}
}
#
[
deriving
(
Clone
)
]
pub
enum
DisplayItem
{
SolidColorDisplayItemClass
(
Box
<
SolidColorDisplayItem
>
)
TextDisplayItemClass
(
Box
<
TextDisplayItem
>
)
ImageDisplayItemClass
(
Box
<
ImageDisplayItem
>
)
BorderDisplayItemClass
(
Box
<
BorderDisplayItem
>
)
LineDisplayItemClass
(
Box
<
LineDisplayItem
>
)
PseudoDisplayItemClass
(
Box
<
BaseDisplayItem
>
)
}
#
[
deriving
(
Clone
)
]
pub
struct
BaseDisplayItem
{
pub
bounds
:
Rect
<
Au
>
pub
node
:
OpaqueNode
pub
level
:
StackingLevel
pub
clip_rect
:
Rect
<
Au
>
}
impl
BaseDisplayItem
{
pub
fn
new
(
bounds
:
Rect
<
Au
>
node
:
OpaqueNode
level
:
StackingLevel
clip_rect
:
Rect
<
Au
>
)
-
>
BaseDisplayItem
{
BaseDisplayItem
{
bounds
:
bounds
node
:
node
level
:
level
clip_rect
:
clip_rect
}
}
}
#
[
deriving
(
Clone
)
]
pub
struct
SolidColorDisplayItem
{
pub
base
:
BaseDisplayItem
pub
color
:
Color
}
#
[
deriving
(
Clone
)
]
pub
struct
TextDisplayItem
{
pub
base
:
BaseDisplayItem
pub
text_run
:
Arc
<
Box
<
TextRun
>
>
pub
range
:
Range
<
CharIndex
>
pub
text_color
:
Color
pub
baseline_origin
:
Point2D
<
Au
>
pub
orientation
:
TextOrientation
}
#
[
deriving
(
Clone
Eq
PartialEq
)
]
pub
enum
TextOrientation
{
Upright
SidewaysLeft
SidewaysRight
}
#
[
deriving
(
Clone
)
]
pub
struct
ImageDisplayItem
{
pub
base
:
BaseDisplayItem
pub
image
:
Arc
<
Box
<
Image
>
>
pub
stretch_size
:
Size2D
<
Au
>
}
#
[
deriving
(
Clone
)
]
pub
struct
BorderDisplayItem
{
pub
base
:
BaseDisplayItem
pub
border
:
SideOffsets2D
<
Au
>
pub
color
:
SideOffsets2D
<
Color
>
pub
style
:
SideOffsets2D
<
border_style
:
:
T
>
}
#
[
deriving
(
Clone
)
]
pub
struct
LineDisplayItem
{
pub
base
:
BaseDisplayItem
pub
color
:
Color
pub
style
:
border_style
:
:
T
}
pub
enum
DisplayItemIterator
<
'
a
>
{
EmptyDisplayItemIterator
ParentDisplayItemIterator
(
dlist
:
:
Items
<
'
a
DisplayItem
>
)
}
impl
<
'
a
>
Iterator
<
&
'
a
DisplayItem
>
for
DisplayItemIterator
<
'
a
>
{
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
DisplayItem
>
{
match
*
self
{
EmptyDisplayItemIterator
=
>
None
ParentDisplayItemIterator
(
ref
mut
subiterator
)
=
>
subiterator
.
next
(
)
}
}
}
impl
DisplayItem
{
fn
draw_into_context
(
&
self
render_context
:
&
mut
RenderContext
current_transform
:
&
Matrix2D
<
AzFloat
>
current_clip_rect
:
&
Rect
<
Au
>
)
{
assert
!
(
self
.
base
(
)
.
level
=
=
ContentStackingLevel
)
;
let
clip_rect
=
&
self
.
base
(
)
.
clip_rect
;
let
need_to_clip
=
current_clip_rect
!
=
clip_rect
;
if
need_to_clip
{
render_context
.
draw_push_clip
(
clip_rect
)
;
}
match
*
self
{
SolidColorDisplayItemClass
(
ref
solid_color
)
=
>
{
render_context
.
draw_solid_color
(
&
solid_color
.
base
.
bounds
solid_color
.
color
)
}
TextDisplayItemClass
(
ref
text
)
=
>
{
debug
!
(
"
Drawing
text
at
{
}
.
"
text
.
base
.
bounds
)
;
let
baseline_origin
=
match
text
.
orientation
{
Upright
=
>
text
.
baseline_origin
SidewaysLeft
=
>
{
let
x
=
text
.
baseline_origin
.
x
.
to_nearest_px
(
)
as
AzFloat
;
let
y
=
text
.
baseline_origin
.
y
.
to_nearest_px
(
)
as
AzFloat
;
render_context
.
draw_target
.
set_transform
(
&
current_transform
.
mul
(
&
Matrix2D
:
:
new
(
0
.
-
1
.
1
.
0
.
x
y
)
)
)
;
Zero
:
:
zero
(
)
}
SidewaysRight
=
>
{
let
x
=
text
.
baseline_origin
.
x
.
to_nearest_px
(
)
as
AzFloat
;
let
y
=
text
.
baseline_origin
.
y
.
to_nearest_px
(
)
as
AzFloat
;
render_context
.
draw_target
.
set_transform
(
&
current_transform
.
mul
(
&
Matrix2D
:
:
new
(
0
.
1
.
-
1
.
0
.
x
y
)
)
)
;
Zero
:
:
zero
(
)
}
}
;
render_context
.
font_ctx
.
get_render_font_from_template
(
&
text
.
text_run
.
font_template
text
.
text_run
.
actual_pt_size
)
.
borrow
(
)
.
draw_text_into_context
(
render_context
&
*
text
.
text_run
&
text
.
range
baseline_origin
text
.
text_color
render_context
.
opts
.
enable_text_antialiasing
)
;
if
text
.
orientation
!
=
Upright
{
render_context
.
draw_target
.
set_transform
(
current_transform
)
}
}
ImageDisplayItemClass
(
ref
image_item
)
=
>
{
debug
!
(
"
Drawing
image
at
{
:
?
}
.
"
image_item
.
base
.
bounds
)
;
let
mut
y_offset
=
Au
(
0
)
;
while
y_offset
<
image_item
.
base
.
bounds
.
size
.
height
{
let
mut
x_offset
=
Au
(
0
)
;
while
x_offset
<
image_item
.
base
.
bounds
.
size
.
width
{
let
mut
bounds
=
image_item
.
base
.
bounds
;
bounds
.
origin
.
x
=
bounds
.
origin
.
x
+
x_offset
;
bounds
.
origin
.
y
=
bounds
.
origin
.
y
+
y_offset
;
bounds
.
size
=
image_item
.
stretch_size
;
render_context
.
draw_image
(
bounds
image_item
.
image
.
clone
(
)
)
;
x_offset
=
x_offset
+
image_item
.
stretch_size
.
width
;
}
y_offset
=
y_offset
+
image_item
.
stretch_size
.
height
;
}
}
BorderDisplayItemClass
(
ref
border
)
=
>
{
render_context
.
draw_border
(
&
border
.
base
.
bounds
border
.
border
border
.
color
border
.
style
)
}
LineDisplayItemClass
(
ref
line
)
=
>
{
render_context
.
draw_line
(
&
line
.
base
.
bounds
line
.
color
line
.
style
)
}
PseudoDisplayItemClass
(
_
)
=
>
{
}
}
if
need_to_clip
{
render_context
.
draw_pop_clip
(
)
;
}
}
pub
fn
base
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
BaseDisplayItem
{
match
*
self
{
SolidColorDisplayItemClass
(
ref
solid_color
)
=
>
&
solid_color
.
base
TextDisplayItemClass
(
ref
text
)
=
>
&
text
.
base
ImageDisplayItemClass
(
ref
image_item
)
=
>
&
image_item
.
base
BorderDisplayItemClass
(
ref
border
)
=
>
&
border
.
base
LineDisplayItemClass
(
ref
line
)
=
>
&
line
.
base
PseudoDisplayItemClass
(
ref
base
)
=
>
&
*
*
base
}
}
pub
fn
mut_base
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
BaseDisplayItem
{
match
*
self
{
SolidColorDisplayItemClass
(
ref
mut
solid_color
)
=
>
&
mut
solid_color
.
base
TextDisplayItemClass
(
ref
mut
text
)
=
>
&
mut
text
.
base
ImageDisplayItemClass
(
ref
mut
image_item
)
=
>
&
mut
image_item
.
base
BorderDisplayItemClass
(
ref
mut
border
)
=
>
&
mut
border
.
base
LineDisplayItemClass
(
ref
mut
line
)
=
>
&
mut
line
.
base
PseudoDisplayItemClass
(
ref
mut
base
)
=
>
&
mut
*
*
base
}
}
pub
fn
bounds
(
&
self
)
-
>
Rect
<
Au
>
{
self
.
base
(
)
.
bounds
}
pub
fn
debug_with_level
(
&
self
level
:
uint
)
{
let
mut
indent
=
String
:
:
new
(
)
;
for
_
in
range
(
0
level
)
{
indent
.
push_str
(
"
|
"
)
}
debug
!
(
"
{
}
+
{
}
"
indent
self
)
;
}
}
impl
fmt
:
:
Show
for
DisplayItem
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
{
}
(
{
:
x
}
)
"
match
*
self
{
SolidColorDisplayItemClass
(
_
)
=
>
"
SolidColor
"
TextDisplayItemClass
(
_
)
=
>
"
Text
"
ImageDisplayItemClass
(
_
)
=
>
"
Image
"
BorderDisplayItemClass
(
_
)
=
>
"
Border
"
LineDisplayItemClass
(
_
)
=
>
"
Line
"
PseudoDisplayItemClass
(
_
)
=
>
"
Pseudo
"
}
self
.
base
(
)
.
bounds
self
.
base
(
)
.
node
.
id
(
)
)
}
}
