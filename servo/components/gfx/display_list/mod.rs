use
color
:
:
Color
;
use
display_list
:
:
optimizer
:
:
DisplayListOptimizer
;
use
render_context
:
:
{
RenderContext
ToAzureRect
}
;
use
text
:
:
glyph
:
:
CharIndex
;
use
text
:
:
TextRun
;
use
azure
:
:
azure
:
:
AzFloat
;
use
collections
:
:
dlist
:
:
{
mod
DList
}
;
use
geom
:
:
{
Point2D
Rect
SideOffsets2D
Size2D
Matrix2D
}
;
use
libc
:
:
uintptr_t
;
use
render_task
:
:
RenderLayer
;
use
script_traits
:
:
UntrustedNodeAddress
;
use
servo_msg
:
:
compositor_msg
:
:
LayerId
;
use
servo_net
:
:
image
:
:
base
:
:
Image
;
use
servo_util
:
:
dlist
as
servo_dlist
;
use
servo_util
:
:
geometry
:
:
{
mod
Au
}
;
use
servo_util
:
:
range
:
:
Range
;
use
servo_util
:
:
smallvec
:
:
{
SmallVec
SmallVec8
}
;
use
std
:
:
fmt
;
use
std
:
:
mem
;
use
std
:
:
slice
:
:
Items
;
use
style
:
:
computed_values
:
:
border_style
;
use
sync
:
:
Arc
;
pub
use
azure
:
:
azure_hl
:
:
GradientStop
;
pub
mod
optimizer
;
#
[
deriving
(
Clone
PartialEq
)
]
pub
struct
OpaqueNode
(
pub
uintptr_t
)
;
impl
OpaqueNode
{
pub
fn
id
(
&
self
)
-
>
uintptr_t
{
let
OpaqueNode
(
pointer
)
=
*
self
;
pointer
}
}
pub
struct
DisplayList
{
pub
background_and_borders
:
DList
<
DisplayItem
>
pub
block_backgrounds_and_borders
:
DList
<
DisplayItem
>
pub
floats
:
DList
<
DisplayItem
>
pub
content
:
DList
<
DisplayItem
>
pub
children
:
DList
<
Arc
<
StackingContext
>
>
}
impl
DisplayList
{
#
[
inline
]
pub
fn
new
(
)
-
>
DisplayList
{
DisplayList
{
background_and_borders
:
DList
:
:
new
(
)
block_backgrounds_and_borders
:
DList
:
:
new
(
)
floats
:
DList
:
:
new
(
)
content
:
DList
:
:
new
(
)
children
:
DList
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
append_from
(
&
mut
self
other
:
&
mut
DisplayList
)
{
servo_dlist
:
:
append_from
(
&
mut
self
.
background_and_borders
&
mut
other
.
background_and_borders
)
;
servo_dlist
:
:
append_from
(
&
mut
self
.
block_backgrounds_and_borders
&
mut
other
.
block_backgrounds_and_borders
)
;
servo_dlist
:
:
append_from
(
&
mut
self
.
floats
&
mut
other
.
floats
)
;
servo_dlist
:
:
append_from
(
&
mut
self
.
content
&
mut
other
.
content
)
;
servo_dlist
:
:
append_from
(
&
mut
self
.
children
&
mut
other
.
children
)
;
}
#
[
inline
]
pub
fn
form_float_pseudo_stacking_context
(
&
mut
self
)
{
servo_dlist
:
:
prepend_from
(
&
mut
self
.
floats
&
mut
self
.
content
)
;
servo_dlist
:
:
prepend_from
(
&
mut
self
.
floats
&
mut
self
.
block_backgrounds_and_borders
)
;
servo_dlist
:
:
prepend_from
(
&
mut
self
.
floats
&
mut
self
.
background_and_borders
)
;
}
pub
fn
all_display_items
(
&
self
)
-
>
Vec
<
DisplayItem
>
{
let
mut
result
=
Vec
:
:
new
(
)
;
for
display_item
in
self
.
background_and_borders
.
iter
(
)
{
result
.
push
(
(
*
display_item
)
.
clone
(
)
)
}
for
display_item
in
self
.
block_backgrounds_and_borders
.
iter
(
)
{
result
.
push
(
(
*
display_item
)
.
clone
(
)
)
}
for
display_item
in
self
.
floats
.
iter
(
)
{
result
.
push
(
(
*
display_item
)
.
clone
(
)
)
}
for
display_item
in
self
.
content
.
iter
(
)
{
result
.
push
(
(
*
display_item
)
.
clone
(
)
)
}
result
}
}
pub
struct
StackingContext
{
pub
display_list
:
Box
<
DisplayList
>
pub
layer
:
Option
<
Arc
<
RenderLayer
>
>
pub
bounds
:
Rect
<
Au
>
pub
clip_rect
:
Rect
<
Au
>
pub
z_index
:
i32
pub
opacity
:
AzFloat
}
impl
StackingContext
{
#
[
inline
]
pub
fn
new
(
display_list
:
Box
<
DisplayList
>
bounds
:
Rect
<
Au
>
z_index
:
i32
opacity
:
AzFloat
layer
:
Option
<
Arc
<
RenderLayer
>
>
)
-
>
StackingContext
{
StackingContext
{
display_list
:
display_list
layer
:
layer
bounds
:
bounds
clip_rect
:
bounds
z_index
:
z_index
opacity
:
opacity
}
}
pub
fn
optimize_and_draw_into_context
(
&
self
render_context
:
&
mut
RenderContext
tile_bounds
:
&
Rect
<
AzFloat
>
current_transform
:
&
Matrix2D
<
AzFloat
>
current_clip_stack
:
&
mut
Vec
<
Rect
<
Au
>
>
)
{
let
temporary_draw_target
=
render_context
.
get_or_create_temporary_draw_target
(
self
.
opacity
)
;
{
let
mut
render_subcontext
=
RenderContext
{
draw_target
:
temporary_draw_target
.
clone
(
)
font_ctx
:
&
mut
*
render_context
.
font_ctx
page_rect
:
render_context
.
page_rect
screen_rect
:
render_context
.
screen_rect
.
.
*
render_context
}
;
let
display_list
=
DisplayListOptimizer
:
:
new
(
tile_bounds
)
.
optimize
(
&
*
self
.
display_list
)
;
let
mut
positioned_children
=
SmallVec8
:
:
new
(
)
;
for
kid
in
display_list
.
children
.
iter
(
)
{
positioned_children
.
push
(
(
*
kid
)
.
clone
(
)
)
;
}
positioned_children
.
as_slice_mut
(
)
.
sort_by
(
|
this
other
|
this
.
z_index
.
cmp
(
&
other
.
z_index
)
)
;
for
display_item
in
display_list
.
background_and_borders
.
iter
(
)
{
display_item
.
draw_into_context
(
&
mut
render_subcontext
current_transform
current_clip_stack
)
}
for
positioned_kid
in
positioned_children
.
iter
(
)
{
if
positioned_kid
.
z_index
>
=
0
{
break
}
if
positioned_kid
.
layer
.
is_none
(
)
{
let
new_transform
=
current_transform
.
translate
(
positioned_kid
.
bounds
.
origin
.
x
.
to_nearest_px
(
)
as
AzFloat
positioned_kid
.
bounds
.
origin
.
y
.
to_nearest_px
(
)
as
AzFloat
)
;
let
new_tile_rect
=
self
.
compute_tile_rect_for_child_stacking_context
(
tile_bounds
&
*
*
positioned_kid
)
;
positioned_kid
.
optimize_and_draw_into_context
(
&
mut
render_subcontext
&
new_tile_rect
&
new_transform
current_clip_stack
)
;
}
}
for
display_item
in
display_list
.
block_backgrounds_and_borders
.
iter
(
)
{
display_item
.
draw_into_context
(
&
mut
render_subcontext
current_transform
current_clip_stack
)
}
for
display_item
in
display_list
.
floats
.
iter
(
)
{
display_item
.
draw_into_context
(
&
mut
render_subcontext
current_transform
current_clip_stack
)
}
for
display_item
in
display_list
.
content
.
iter
(
)
{
display_item
.
draw_into_context
(
&
mut
render_subcontext
current_transform
current_clip_stack
)
}
for
positioned_kid
in
positioned_children
.
iter
(
)
{
if
positioned_kid
.
z_index
<
0
{
continue
}
if
positioned_kid
.
layer
.
is_none
(
)
{
let
new_transform
=
current_transform
.
translate
(
positioned_kid
.
bounds
.
origin
.
x
.
to_nearest_px
(
)
as
AzFloat
positioned_kid
.
bounds
.
origin
.
y
.
to_nearest_px
(
)
as
AzFloat
)
;
let
new_tile_rect
=
self
.
compute_tile_rect_for_child_stacking_context
(
tile_bounds
&
*
*
positioned_kid
)
;
positioned_kid
.
optimize_and_draw_into_context
(
&
mut
render_subcontext
&
new_tile_rect
&
new_transform
current_clip_stack
)
;
}
}
}
render_context
.
draw_temporary_draw_target_if_necessary
(
&
temporary_draw_target
self
.
opacity
)
}
fn
compute_tile_rect_for_child_stacking_context
(
&
self
tile_bounds
:
&
Rect
<
AzFloat
>
child_stacking_context
:
&
StackingContext
)
-
>
Rect
<
AzFloat
>
{
static
ZERO_AZURE_RECT
:
Rect
<
f32
>
=
Rect
{
origin
:
Point2D
{
x
:
0
.
0
y
:
0
.
0
}
size
:
Size2D
{
width
:
0
.
0
height
:
0
.
0
}
}
;
let
child_stacking_context_bounds
=
child_stacking_context
.
bounds
.
to_azure_rect
(
)
;
let
tile_subrect
=
tile_bounds
.
intersection
(
&
child_stacking_context_bounds
)
.
unwrap_or
(
ZERO_AZURE_RECT
)
;
let
offset
=
tile_subrect
.
origin
-
child_stacking_context_bounds
.
origin
;
Rect
(
offset
tile_subrect
.
size
)
}
pub
fn
hit_test
(
&
self
point
:
Point2D
<
Au
>
result
:
&
mut
Vec
<
UntrustedNodeAddress
>
topmost_only
:
bool
)
{
fn
hit_test_in_list
<
'
a
I
>
(
point
:
Point2D
<
Au
>
result
:
&
mut
Vec
<
UntrustedNodeAddress
>
topmost_only
:
bool
mut
iterator
:
I
)
where
I
:
Iterator
<
&
'
a
DisplayItem
>
{
for
item
in
iterator
{
if
geometry
:
:
rect_contains_point
(
item
.
base
(
)
.
clip_rect
point
)
&
&
geometry
:
:
rect_contains_point
(
item
.
bounds
(
)
point
)
{
result
.
push
(
item
.
base
(
)
.
node
.
to_untrusted_node_address
(
)
)
;
if
topmost_only
{
return
}
}
}
}
debug_assert
!
(
!
topmost_only
|
|
result
.
is_empty
(
)
)
;
for
kid
in
self
.
display_list
.
children
.
iter
(
)
.
rev
(
)
{
if
kid
.
z_index
<
0
{
continue
}
kid
.
hit_test
(
point
result
topmost_only
)
;
if
topmost_only
&
&
!
result
.
is_empty
(
)
{
return
}
}
for
display_list
in
[
&
self
.
display_list
.
content
&
self
.
display_list
.
floats
&
self
.
display_list
.
block_backgrounds_and_borders
]
.
iter
(
)
{
hit_test_in_list
(
point
result
topmost_only
display_list
.
iter
(
)
.
rev
(
)
)
;
if
topmost_only
&
&
!
result
.
is_empty
(
)
{
return
}
}
for
kid
in
self
.
display_list
.
children
.
iter
(
)
.
rev
(
)
{
if
kid
.
z_index
>
=
0
{
continue
}
kid
.
hit_test
(
point
result
topmost_only
)
;
if
topmost_only
&
&
!
result
.
is_empty
(
)
{
return
}
}
hit_test_in_list
(
point
result
topmost_only
self
.
display_list
.
background_and_borders
.
iter
(
)
.
rev
(
)
)
}
}
pub
fn
find_stacking_context_with_layer_id
(
this
:
&
Arc
<
StackingContext
>
layer_id
:
LayerId
)
-
>
Option
<
Arc
<
StackingContext
>
>
{
match
this
.
layer
{
Some
(
ref
layer
)
if
layer
.
id
=
=
layer_id
=
>
return
Some
(
(
*
this
)
.
clone
(
)
)
Some
(
_
)
|
None
=
>
{
}
}
for
kid
in
this
.
display_list
.
children
.
iter
(
)
{
match
find_stacking_context_with_layer_id
(
kid
layer_id
)
{
Some
(
stacking_context
)
=
>
return
Some
(
stacking_context
)
None
=
>
{
}
}
}
None
}
#
[
deriving
(
Clone
)
]
pub
enum
DisplayItem
{
SolidColorDisplayItemClass
(
Box
<
SolidColorDisplayItem
>
)
TextDisplayItemClass
(
Box
<
TextDisplayItem
>
)
ImageDisplayItemClass
(
Box
<
ImageDisplayItem
>
)
BorderDisplayItemClass
(
Box
<
BorderDisplayItem
>
)
GradientDisplayItemClass
(
Box
<
GradientDisplayItem
>
)
LineDisplayItemClass
(
Box
<
LineDisplayItem
>
)
PseudoDisplayItemClass
(
Box
<
BaseDisplayItem
>
)
}
#
[
deriving
(
Clone
)
]
pub
struct
BaseDisplayItem
{
pub
bounds
:
Rect
<
Au
>
pub
node
:
OpaqueNode
pub
clip_rect
:
Rect
<
Au
>
}
impl
BaseDisplayItem
{
#
[
inline
(
always
)
]
pub
fn
new
(
bounds
:
Rect
<
Au
>
node
:
OpaqueNode
clip_rect
:
Rect
<
Au
>
)
-
>
BaseDisplayItem
{
BaseDisplayItem
{
bounds
:
bounds
node
:
node
clip_rect
:
clip_rect
}
}
}
#
[
deriving
(
Clone
)
]
pub
struct
SolidColorDisplayItem
{
pub
base
:
BaseDisplayItem
pub
color
:
Color
}
#
[
deriving
(
Clone
)
]
pub
struct
TextDisplayItem
{
pub
base
:
BaseDisplayItem
pub
text_run
:
Arc
<
Box
<
TextRun
>
>
pub
range
:
Range
<
CharIndex
>
pub
text_color
:
Color
pub
baseline_origin
:
Point2D
<
Au
>
pub
orientation
:
TextOrientation
}
#
[
deriving
(
Clone
Eq
PartialEq
)
]
pub
enum
TextOrientation
{
Upright
SidewaysLeft
SidewaysRight
}
#
[
deriving
(
Clone
)
]
pub
struct
ImageDisplayItem
{
pub
base
:
BaseDisplayItem
pub
image
:
Arc
<
Box
<
Image
>
>
pub
stretch_size
:
Size2D
<
Au
>
}
#
[
deriving
(
Clone
)
]
pub
struct
GradientDisplayItem
{
pub
base
:
BaseDisplayItem
pub
start_point
:
Point2D
<
Au
>
pub
end_point
:
Point2D
<
Au
>
pub
stops
:
Vec
<
GradientStop
>
}
#
[
deriving
(
Clone
)
]
pub
struct
BorderDisplayItem
{
pub
base
:
BaseDisplayItem
pub
border_widths
:
SideOffsets2D
<
Au
>
pub
color
:
SideOffsets2D
<
Color
>
pub
style
:
SideOffsets2D
<
border_style
:
:
T
>
pub
radius
:
BorderRadii
<
Au
>
}
#
[
deriving
(
Clone
Default
Show
)
]
pub
struct
BorderRadii
<
T
>
{
pub
top_left
:
T
pub
top_right
:
T
pub
bottom_right
:
T
pub
bottom_left
:
T
}
#
[
deriving
(
Clone
)
]
pub
struct
LineDisplayItem
{
pub
base
:
BaseDisplayItem
pub
color
:
Color
pub
style
:
border_style
:
:
T
}
pub
enum
DisplayItemIterator
<
'
a
>
{
EmptyDisplayItemIterator
ParentDisplayItemIterator
(
dlist
:
:
Items
<
'
a
DisplayItem
>
)
}
impl
<
'
a
>
Iterator
<
&
'
a
DisplayItem
>
for
DisplayItemIterator
<
'
a
>
{
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
DisplayItem
>
{
match
*
self
{
EmptyDisplayItemIterator
=
>
None
ParentDisplayItemIterator
(
ref
mut
subiterator
)
=
>
subiterator
.
next
(
)
}
}
}
impl
DisplayItem
{
fn
draw_into_context
(
&
self
render_context
:
&
mut
RenderContext
current_transform
:
&
Matrix2D
<
AzFloat
>
current_clip_stack
:
&
mut
Vec
<
Rect
<
Au
>
>
)
{
let
clip_rect
=
&
self
.
base
(
)
.
clip_rect
;
if
current_clip_stack
.
len
(
)
=
=
0
|
|
current_clip_stack
.
last
(
)
.
unwrap
(
)
!
=
clip_rect
{
while
current_clip_stack
.
len
(
)
!
=
0
{
render_context
.
draw_pop_clip
(
)
;
drop
(
current_clip_stack
.
pop
(
)
)
;
}
render_context
.
draw_push_clip
(
clip_rect
)
;
current_clip_stack
.
push
(
*
clip_rect
)
;
}
render_context
.
draw_target
.
set_transform
(
current_transform
)
;
match
*
self
{
SolidColorDisplayItemClass
(
ref
solid_color
)
=
>
{
render_context
.
draw_solid_color
(
&
solid_color
.
base
.
bounds
solid_color
.
color
)
}
TextDisplayItemClass
(
ref
text
)
=
>
{
debug
!
(
"
Drawing
text
at
{
}
.
"
text
.
base
.
bounds
)
;
render_context
.
draw_text
(
&
*
*
text
current_transform
)
;
}
ImageDisplayItemClass
(
ref
image_item
)
=
>
{
debug
!
(
"
Drawing
image
at
{
}
.
"
image_item
.
base
.
bounds
)
;
let
mut
y_offset
=
Au
(
0
)
;
while
y_offset
<
image_item
.
base
.
bounds
.
size
.
height
{
let
mut
x_offset
=
Au
(
0
)
;
while
x_offset
<
image_item
.
base
.
bounds
.
size
.
width
{
let
mut
bounds
=
image_item
.
base
.
bounds
;
bounds
.
origin
.
x
=
bounds
.
origin
.
x
+
x_offset
;
bounds
.
origin
.
y
=
bounds
.
origin
.
y
+
y_offset
;
bounds
.
size
=
image_item
.
stretch_size
;
render_context
.
draw_image
(
bounds
image_item
.
image
.
clone
(
)
)
;
x_offset
=
x_offset
+
image_item
.
stretch_size
.
width
;
}
y_offset
=
y_offset
+
image_item
.
stretch_size
.
height
;
}
}
BorderDisplayItemClass
(
ref
border
)
=
>
{
render_context
.
draw_border
(
&
border
.
base
.
bounds
border
.
border_widths
&
border
.
radius
border
.
color
border
.
style
)
}
GradientDisplayItemClass
(
ref
gradient
)
=
>
{
render_context
.
draw_linear_gradient
(
&
gradient
.
base
.
bounds
&
gradient
.
start_point
&
gradient
.
end_point
gradient
.
stops
.
as_slice
(
)
)
;
}
LineDisplayItemClass
(
ref
line
)
=
>
{
render_context
.
draw_line
(
&
line
.
base
.
bounds
line
.
color
line
.
style
)
}
PseudoDisplayItemClass
(
_
)
=
>
{
}
}
}
pub
fn
base
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
BaseDisplayItem
{
match
*
self
{
SolidColorDisplayItemClass
(
ref
solid_color
)
=
>
&
solid_color
.
base
TextDisplayItemClass
(
ref
text
)
=
>
&
text
.
base
ImageDisplayItemClass
(
ref
image_item
)
=
>
&
image_item
.
base
BorderDisplayItemClass
(
ref
border
)
=
>
&
border
.
base
GradientDisplayItemClass
(
ref
gradient
)
=
>
&
gradient
.
base
LineDisplayItemClass
(
ref
line
)
=
>
&
line
.
base
PseudoDisplayItemClass
(
ref
base
)
=
>
&
*
*
base
}
}
pub
fn
mut_base
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
BaseDisplayItem
{
match
*
self
{
SolidColorDisplayItemClass
(
ref
mut
solid_color
)
=
>
&
mut
solid_color
.
base
TextDisplayItemClass
(
ref
mut
text
)
=
>
&
mut
text
.
base
ImageDisplayItemClass
(
ref
mut
image_item
)
=
>
&
mut
image_item
.
base
BorderDisplayItemClass
(
ref
mut
border
)
=
>
&
mut
border
.
base
GradientDisplayItemClass
(
ref
mut
gradient
)
=
>
&
mut
gradient
.
base
LineDisplayItemClass
(
ref
mut
line
)
=
>
&
mut
line
.
base
PseudoDisplayItemClass
(
ref
mut
base
)
=
>
&
mut
*
*
base
}
}
pub
fn
bounds
(
&
self
)
-
>
Rect
<
Au
>
{
self
.
base
(
)
.
bounds
}
pub
fn
debug_with_level
(
&
self
level
:
uint
)
{
let
mut
indent
=
String
:
:
new
(
)
;
for
_
in
range
(
0
level
)
{
indent
.
push_str
(
"
|
"
)
}
println
!
(
"
{
}
+
{
}
"
indent
self
)
;
}
}
impl
fmt
:
:
Show
for
DisplayItem
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
{
}
(
{
:
x
}
)
"
match
*
self
{
SolidColorDisplayItemClass
(
_
)
=
>
"
SolidColor
"
TextDisplayItemClass
(
_
)
=
>
"
Text
"
ImageDisplayItemClass
(
_
)
=
>
"
Image
"
BorderDisplayItemClass
(
_
)
=
>
"
Border
"
GradientDisplayItemClass
(
_
)
=
>
"
Gradient
"
LineDisplayItemClass
(
_
)
=
>
"
Line
"
PseudoDisplayItemClass
(
_
)
=
>
"
Pseudo
"
}
self
.
base
(
)
.
bounds
self
.
base
(
)
.
node
.
id
(
)
)
}
}
pub
trait
OpaqueNodeMethods
{
fn
to_untrusted_node_address
(
&
self
)
-
>
UntrustedNodeAddress
;
}
impl
OpaqueNodeMethods
for
OpaqueNode
{
fn
to_untrusted_node_address
(
&
self
)
-
>
UntrustedNodeAddress
{
unsafe
{
let
OpaqueNode
(
addr
)
=
*
self
;
let
addr
:
UntrustedNodeAddress
=
mem
:
:
transmute
(
addr
)
;
addr
}
}
}
