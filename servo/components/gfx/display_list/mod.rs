use
app_units
:
:
Au
;
use
azure
:
:
azure
:
:
AzFloat
;
use
azure
:
:
azure_hl
:
:
{
Color
DrawTarget
}
;
use
display_list
:
:
optimizer
:
:
DisplayListOptimizer
;
use
euclid
:
:
approxeq
:
:
ApproxEq
;
use
euclid
:
:
num
:
:
Zero
;
use
euclid
:
:
{
Matrix2D
Matrix4
Point2D
Rect
SideOffsets2D
Size2D
}
;
use
gfx_traits
:
:
{
color
LayerId
LayerKind
ScrollPolicy
}
;
use
msg
:
:
constellation_msg
:
:
PipelineId
;
use
net_traits
:
:
image
:
:
base
:
:
Image
;
use
paint_context
:
:
PaintContext
;
use
paint_task
:
:
{
PaintLayerContents
PaintLayer
}
;
use
self
:
:
DisplayItem
:
:
*
;
use
self
:
:
DisplayItemIterator
:
:
*
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
collections
:
:
linked_list
:
:
{
self
LinkedList
}
;
use
std
:
:
fmt
;
use
std
:
:
mem
;
use
std
:
:
slice
:
:
Iter
;
use
std
:
:
sync
:
:
Arc
;
use
style
:
:
computed_values
:
:
{
border_style
cursor
filter
image_rendering
mix_blend_mode
}
;
use
style
:
:
computed_values
:
:
{
pointer_events
}
;
use
style
:
:
properties
:
:
ComputedValues
;
use
text
:
:
TextRun
;
use
text
:
:
glyph
:
:
CharIndex
;
use
util
:
:
cursor
:
:
Cursor
;
use
util
:
:
geometry
:
:
MAX_RECT
;
use
util
:
:
linked_list
:
:
prepend_from
;
use
util
:
:
mem
:
:
HeapSizeOf
;
use
util
:
:
opts
;
use
util
:
:
print_tree
:
:
PrintTree
;
use
util
:
:
range
:
:
Range
;
pub
use
style
:
:
dom
:
:
OpaqueNode
;
pub
use
azure
:
:
azure_hl
:
:
GradientStop
;
pub
mod
optimizer
;
pub
static
BLUR_INFLATION_FACTOR
:
i32
=
3
;
#
[
derive
(
Clone
Copy
Debug
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
LayerInfo
{
pub
layer_id
:
LayerId
pub
scroll_policy
:
ScrollPolicy
pub
subpage_pipeline_id
:
Option
<
PipelineId
>
pub
next_layer_id
:
LayerId
}
impl
LayerInfo
{
pub
fn
new
(
id
:
LayerId
scroll_policy
:
ScrollPolicy
subpage_pipeline_id
:
Option
<
PipelineId
>
)
-
>
LayerInfo
{
LayerInfo
{
layer_id
:
id
scroll_policy
:
scroll_policy
subpage_pipeline_id
:
subpage_pipeline_id
next_layer_id
:
id
.
companion_layer_id
(
)
}
}
fn
next
(
&
mut
self
)
-
>
LayerInfo
{
let
new_layer_info
=
LayerInfo
:
:
new
(
self
.
next_layer_id
self
.
scroll_policy
None
)
;
self
.
next_layer_id
=
self
.
next_layer_id
.
companion_layer_id
(
)
;
new_layer_info
}
fn
next_with_scroll_policy
(
&
mut
self
scroll_policy
:
ScrollPolicy
)
-
>
LayerInfo
{
let
mut
new_layer_info
=
self
.
next
(
)
;
new_layer_info
.
scroll_policy
=
scroll_policy
;
new_layer_info
}
}
#
[
derive
(
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
DisplayList
{
pub
background_and_borders
:
LinkedList
<
DisplayItem
>
pub
block_backgrounds_and_borders
:
LinkedList
<
DisplayItem
>
pub
floats
:
LinkedList
<
DisplayItem
>
pub
content
:
LinkedList
<
DisplayItem
>
pub
positioned_content
:
LinkedList
<
DisplayItem
>
pub
outlines
:
LinkedList
<
DisplayItem
>
pub
layered_children
:
LinkedList
<
Arc
<
PaintLayer
>
>
pub
layer_info
:
LinkedList
<
LayerInfo
>
}
impl
DisplayList
{
#
[
inline
]
pub
fn
new
(
)
-
>
DisplayList
{
DisplayList
{
background_and_borders
:
LinkedList
:
:
new
(
)
block_backgrounds_and_borders
:
LinkedList
:
:
new
(
)
floats
:
LinkedList
:
:
new
(
)
content
:
LinkedList
:
:
new
(
)
positioned_content
:
LinkedList
:
:
new
(
)
outlines
:
LinkedList
:
:
new
(
)
layered_children
:
LinkedList
:
:
new
(
)
layer_info
:
LinkedList
:
:
new
(
)
}
}
pub
fn
add_to_section
(
&
mut
self
display_item
:
DisplayItem
section
:
DisplayListSection
)
{
self
.
get_section_mut
(
section
)
.
push_back
(
display_item
)
;
}
#
[
inline
]
pub
fn
new_with_stacking_context
(
stacking_context
:
Arc
<
StackingContext
>
)
-
>
Box
<
DisplayList
>
{
let
mut
display_list
=
box
DisplayList
:
:
new
(
)
;
display_list
.
positioned_content
.
push_back
(
DisplayItem
:
:
StackingContextClass
(
stacking_context
)
)
;
display_list
}
#
[
inline
]
pub
fn
append_from
(
&
mut
self
other
:
&
mut
Option
<
Box
<
DisplayList
>
>
)
{
if
let
Some
(
mut
other
)
=
other
.
take
(
)
{
self
.
background_and_borders
.
append
(
&
mut
other
.
background_and_borders
)
;
self
.
block_backgrounds_and_borders
.
append
(
&
mut
other
.
block_backgrounds_and_borders
)
;
self
.
floats
.
append
(
&
mut
other
.
floats
)
;
self
.
content
.
append
(
&
mut
other
.
content
)
;
self
.
positioned_content
.
append
(
&
mut
other
.
positioned_content
)
;
self
.
outlines
.
append
(
&
mut
other
.
outlines
)
;
self
.
layered_children
.
append
(
&
mut
other
.
layered_children
)
;
self
.
layer_info
.
append
(
&
mut
other
.
layer_info
)
;
}
}
#
[
inline
]
pub
fn
form_float_pseudo_stacking_context
(
&
mut
self
)
{
prepend_from
(
&
mut
self
.
floats
&
mut
self
.
outlines
)
;
prepend_from
(
&
mut
self
.
floats
&
mut
self
.
content
)
;
prepend_from
(
&
mut
self
.
floats
&
mut
self
.
block_backgrounds_and_borders
)
;
prepend_from
(
&
mut
self
.
floats
&
mut
self
.
background_and_borders
)
;
}
#
[
inline
]
pub
fn
form_pseudo_stacking_context_for_positioned_content
(
&
mut
self
)
{
prepend_from
(
&
mut
self
.
positioned_content
&
mut
self
.
outlines
)
;
prepend_from
(
&
mut
self
.
positioned_content
&
mut
self
.
content
)
;
prepend_from
(
&
mut
self
.
positioned_content
&
mut
self
.
floats
)
;
prepend_from
(
&
mut
self
.
positioned_content
&
mut
self
.
block_backgrounds_and_borders
)
;
prepend_from
(
&
mut
self
.
positioned_content
&
mut
self
.
background_and_borders
)
;
}
pub
fn
flatten
(
&
self
)
-
>
Vec
<
DisplayItem
>
{
let
mut
result
=
Vec
:
:
new
(
)
;
fn
flatten_item
(
result
:
&
mut
Vec
<
DisplayItem
>
item
:
&
DisplayItem
)
{
match
item
{
&
DisplayItem
:
:
StackingContextClass
(
ref
stacking_context
)
=
>
result
.
extend
(
stacking_context
.
display_list
.
flatten
(
)
.
into_iter
(
)
)
_
=
>
result
.
push
(
(
*
item
)
.
clone
(
)
)
}
}
for
display_item
in
&
self
.
background_and_borders
{
flatten_item
(
&
mut
result
display_item
)
;
}
for
display_item
in
&
self
.
block_backgrounds_and_borders
{
flatten_item
(
&
mut
result
display_item
)
;
}
for
display_item
in
&
self
.
floats
{
flatten_item
(
&
mut
result
display_item
)
;
}
for
display_item
in
&
self
.
content
{
flatten_item
(
&
mut
result
display_item
)
;
}
for
display_item
in
&
self
.
positioned_content
{
flatten_item
(
&
mut
result
display_item
)
;
}
for
display_item
in
&
self
.
outlines
{
flatten_item
(
&
mut
result
display_item
)
;
}
result
}
pub
fn
print
(
&
self
title
:
String
)
{
let
mut
print_tree
=
PrintTree
:
:
new
(
title
)
;
self
.
print_with_tree
(
&
mut
print_tree
)
;
}
pub
fn
print_with_tree
(
&
self
print_tree
:
&
mut
PrintTree
)
{
fn
print_display_list_section
(
print_tree
:
&
mut
PrintTree
items
:
&
LinkedList
<
DisplayItem
>
title
:
&
str
)
{
if
items
.
is_empty
(
)
{
return
;
}
print_tree
.
new_level
(
title
.
to_owned
(
)
)
;
for
item
in
items
{
match
item
{
&
DisplayItem
:
:
StackingContextClass
(
ref
stacking_context
)
=
>
stacking_context
.
print_with_tree
(
print_tree
)
_
=
>
print_tree
.
add_item
(
format
!
(
"
{
:
?
}
"
item
)
)
}
}
print_tree
.
end_level
(
)
;
}
print_display_list_section
(
print_tree
&
self
.
background_and_borders
"
Backgrounds
and
Borders
"
)
;
print_display_list_section
(
print_tree
&
self
.
block_backgrounds_and_borders
"
Block
Backgrounds
and
Borders
"
)
;
print_display_list_section
(
print_tree
&
self
.
floats
"
Floats
"
)
;
print_display_list_section
(
print_tree
&
self
.
content
"
Content
"
)
;
print_display_list_section
(
print_tree
&
self
.
positioned_content
"
Positioned
Content
"
)
;
print_display_list_section
(
print_tree
&
self
.
outlines
"
Outlines
"
)
;
if
!
self
.
layered_children
.
is_empty
(
)
{
print_tree
.
new_level
(
"
Layers
"
.
to_owned
(
)
)
;
for
paint_layer
in
&
self
.
layered_children
{
match
paint_layer
.
contents
{
PaintLayerContents
:
:
StackingContext
(
ref
stacking_context
)
=
>
stacking_context
.
print_with_tree
(
print_tree
)
PaintLayerContents
:
:
DisplayList
(
ref
display_list
)
=
>
{
print_tree
.
new_level
(
format
!
(
"
DisplayList
Layer
with
bounds
{
:
?
}
:
"
display_list
.
calculate_bounding_rect
(
)
)
)
;
display_list
.
print_with_tree
(
print_tree
)
;
print_tree
.
end_level
(
)
;
}
}
}
print_tree
.
end_level
(
)
;
}
}
pub
fn
draw_into_context
(
&
self
draw_target
:
&
DrawTarget
paint_context
:
&
mut
PaintContext
transform
:
&
Matrix4
clip_rect
:
Option
<
&
Rect
<
Au
>
>
)
{
let
mut
paint_subcontext
=
PaintContext
{
draw_target
:
draw_target
.
clone
(
)
font_context
:
&
mut
*
paint_context
.
font_context
page_rect
:
paint_context
.
page_rect
screen_rect
:
paint_context
.
screen_rect
clip_rect
:
clip_rect
.
map
(
|
clip_rect
|
*
clip_rect
)
transient_clip
:
None
layer_kind
:
paint_context
.
layer_kind
}
;
if
opts
:
:
get
(
)
.
dump_display_list_optimized
{
self
.
print
(
format
!
(
"
Optimized
display
list
.
Tile
bounds
:
{
:
?
}
"
paint_context
.
page_rect
)
)
;
}
let
old_transform
=
paint_subcontext
.
draw_target
.
get_transform
(
)
;
let
xform_2d
=
Matrix2D
:
:
new
(
transform
.
m11
transform
.
m12
transform
.
m21
transform
.
m22
transform
.
m41
transform
.
m42
)
;
paint_subcontext
.
draw_target
.
set_transform
(
&
xform_2d
)
;
paint_subcontext
.
push_clip_if_applicable
(
)
;
for
display_item
in
&
self
.
background_and_borders
{
display_item
.
draw_into_context
(
transform
&
mut
paint_subcontext
)
}
for
positioned_kid
in
&
self
.
positioned_content
{
if
let
&
DisplayItem
:
:
StackingContextClass
(
ref
stacking_context
)
=
positioned_kid
{
if
stacking_context
.
z_index
<
0
{
positioned_kid
.
draw_into_context
(
transform
&
mut
paint_subcontext
)
;
}
}
}
for
display_item
in
&
self
.
block_backgrounds_and_borders
{
display_item
.
draw_into_context
(
transform
&
mut
paint_subcontext
)
}
for
display_item
in
&
self
.
floats
{
display_item
.
draw_into_context
(
transform
&
mut
paint_subcontext
)
}
for
display_item
in
&
self
.
content
{
display_item
.
draw_into_context
(
transform
&
mut
paint_subcontext
)
}
for
positioned_kid
in
&
self
.
positioned_content
{
if
let
&
DisplayItem
:
:
StackingContextClass
(
ref
stacking_context
)
=
positioned_kid
{
if
stacking_context
.
z_index
<
0
{
continue
;
}
}
positioned_kid
.
draw_into_context
(
transform
&
mut
paint_subcontext
)
;
}
for
display_item
in
&
self
.
outlines
{
display_item
.
draw_into_context
(
transform
&
mut
paint_subcontext
)
}
paint_subcontext
.
remove_transient_clip_if_applicable
(
)
;
paint_subcontext
.
pop_clip_if_applicable
(
)
;
paint_subcontext
.
draw_target
.
set_transform
(
&
old_transform
)
}
pub
fn
hit_test
(
&
self
point
:
Point2D
<
Au
>
result
:
&
mut
Vec
<
DisplayItemMetadata
>
topmost_only
:
bool
)
{
fn
hit_test_item
(
point
:
Point2D
<
Au
>
result
:
&
mut
Vec
<
DisplayItemMetadata
>
item
:
&
DisplayItem
)
{
let
base_item
=
match
item
.
base
(
)
{
Some
(
base
)
=
>
base
None
=
>
return
}
;
if
!
base_item
.
clip
.
might_intersect_point
(
&
point
)
{
return
;
}
if
!
item
.
bounds
(
)
.
contains
(
&
point
)
{
return
;
}
if
base_item
.
metadata
.
pointing
.
is_none
(
)
{
return
;
}
if
let
DisplayItem
:
:
BorderClass
(
ref
border
)
=
*
item
{
let
interior_rect
=
Rect
:
:
new
(
Point2D
:
:
new
(
border
.
base
.
bounds
.
origin
.
x
+
border
.
border_widths
.
left
border
.
base
.
bounds
.
origin
.
y
+
border
.
border_widths
.
top
)
Size2D
:
:
new
(
border
.
base
.
bounds
.
size
.
width
-
(
border
.
border_widths
.
left
+
border
.
border_widths
.
right
)
border
.
base
.
bounds
.
size
.
height
-
(
border
.
border_widths
.
top
+
border
.
border_widths
.
bottom
)
)
)
;
if
interior_rect
.
contains
(
&
point
)
{
return
;
}
}
result
.
push
(
base_item
.
metadata
)
;
}
fn
hit_test_in_list
<
'
a
I
>
(
point
:
Point2D
<
Au
>
result
:
&
mut
Vec
<
DisplayItemMetadata
>
topmost_only
:
bool
iterator
:
I
)
where
I
:
Iterator
<
Item
=
&
'
a
DisplayItem
>
{
for
item
in
iterator
{
hit_test_item
(
point
result
item
)
;
if
topmost_only
&
&
!
result
.
is_empty
(
)
{
return
;
}
}
}
for
layer
in
self
.
layered_children
.
iter
(
)
.
rev
(
)
{
match
layer
.
contents
{
PaintLayerContents
:
:
StackingContext
(
ref
stacking_context
)
=
>
stacking_context
.
hit_test
(
point
result
topmost_only
)
PaintLayerContents
:
:
DisplayList
(
ref
display_list
)
=
>
display_list
.
hit_test
(
point
result
topmost_only
)
}
if
topmost_only
&
&
!
result
.
is_empty
(
)
{
return
}
}
hit_test_in_list
(
point
result
topmost_only
self
.
outlines
.
iter
(
)
.
rev
(
)
)
;
if
topmost_only
&
&
!
result
.
is_empty
(
)
{
return
}
for
kid
in
self
.
positioned_content
.
iter
(
)
.
rev
(
)
{
if
let
&
DisplayItem
:
:
StackingContextClass
(
ref
stacking_context
)
=
kid
{
if
stacking_context
.
z_index
<
0
{
continue
}
stacking_context
.
hit_test
(
point
result
topmost_only
)
;
}
else
{
hit_test_item
(
point
result
kid
)
;
}
if
topmost_only
&
&
!
result
.
is_empty
(
)
{
return
}
}
for
display_list
in
&
[
&
self
.
content
&
self
.
floats
&
self
.
block_backgrounds_and_borders
]
{
hit_test_in_list
(
point
result
topmost_only
display_list
.
iter
(
)
.
rev
(
)
)
;
if
topmost_only
&
&
!
result
.
is_empty
(
)
{
return
}
}
for
kid
in
self
.
positioned_content
.
iter
(
)
.
rev
(
)
{
if
let
&
DisplayItem
:
:
StackingContextClass
(
ref
stacking_context
)
=
kid
{
if
stacking_context
.
z_index
>
=
0
{
continue
}
stacking_context
.
hit_test
(
point
result
topmost_only
)
;
if
topmost_only
&
&
!
result
.
is_empty
(
)
{
return
}
}
}
hit_test_in_list
(
point
result
topmost_only
self
.
background_and_borders
.
iter
(
)
.
rev
(
)
)
}
pub
fn
find_layer_with_layer_id
(
&
self
layer_id
:
LayerId
)
-
>
Option
<
Arc
<
PaintLayer
>
>
{
for
kid
in
&
self
.
layered_children
{
if
let
Some
(
paint_layer
)
=
PaintLayer
:
:
find_layer_with_layer_id
(
&
kid
layer_id
)
{
return
Some
(
paint_layer
)
;
}
}
for
item
in
&
self
.
positioned_content
{
if
let
&
DisplayItem
:
:
StackingContextClass
(
ref
stacking_context
)
=
item
{
if
let
Some
(
paint_layer
)
=
stacking_context
.
display_list
.
find_layer_with_layer_id
(
layer_id
)
{
return
Some
(
paint_layer
)
;
}
}
}
None
}
pub
fn
calculate_bounding_rect
(
&
self
)
-
>
Rect
<
Au
>
{
fn
union_all_items
(
list
:
&
LinkedList
<
DisplayItem
>
mut
bounds
:
Rect
<
Au
>
)
-
>
Rect
<
Au
>
{
for
item
in
list
{
bounds
=
bounds
.
union
(
&
item
.
bounds
(
)
)
;
}
bounds
}
;
let
mut
bounds
=
Rect
:
:
zero
(
)
;
bounds
=
union_all_items
(
&
self
.
background_and_borders
bounds
)
;
bounds
=
union_all_items
(
&
self
.
block_backgrounds_and_borders
bounds
)
;
bounds
=
union_all_items
(
&
self
.
floats
bounds
)
;
bounds
=
union_all_items
(
&
self
.
content
bounds
)
;
bounds
=
union_all_items
(
&
self
.
positioned_content
bounds
)
;
bounds
=
union_all_items
(
&
self
.
outlines
bounds
)
;
bounds
}
#
[
inline
]
fn
get_section_mut
(
&
mut
self
section
:
DisplayListSection
)
-
>
&
mut
LinkedList
<
DisplayItem
>
{
match
section
{
DisplayListSection
:
:
BackgroundAndBorders
=
>
&
mut
self
.
background_and_borders
DisplayListSection
:
:
BlockBackgroundsAndBorders
=
>
&
mut
self
.
block_backgrounds_and_borders
DisplayListSection
:
:
Floats
=
>
&
mut
self
.
floats
DisplayListSection
:
:
Content
=
>
&
mut
self
.
content
DisplayListSection
:
:
PositionedContent
=
>
&
mut
self
.
positioned_content
DisplayListSection
:
:
Outlines
=
>
&
mut
self
.
outlines
}
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
DisplayListSection
{
BackgroundAndBorders
BlockBackgroundsAndBorders
Floats
Content
PositionedContent
Outlines
}
#
[
derive
(
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
StackingContext
{
pub
display_list
:
Box
<
DisplayList
>
pub
bounds
:
Rect
<
Au
>
pub
overflow
:
Rect
<
Au
>
pub
z_index
:
i32
pub
filters
:
filter
:
:
T
pub
blend_mode
:
mix_blend_mode
:
:
T
pub
transform
:
Matrix4
pub
perspective
:
Matrix4
pub
establishes_3d_context
:
bool
pub
scrolls_overflow_area
:
bool
pub
layer_info
:
Option
<
LayerInfo
>
pub
last_child_layer_info
:
Option
<
LayerInfo
>
}
impl
StackingContext
{
#
[
inline
]
pub
fn
new
(
display_list
:
Box
<
DisplayList
>
bounds
:
&
Rect
<
Au
>
overflow
:
&
Rect
<
Au
>
z_index
:
i32
filters
:
filter
:
:
T
blend_mode
:
mix_blend_mode
:
:
T
transform
:
Matrix4
perspective
:
Matrix4
establishes_3d_context
:
bool
scrolls_overflow_area
:
bool
layer_info
:
Option
<
LayerInfo
>
)
-
>
StackingContext
{
let
mut
stacking_context
=
StackingContext
{
display_list
:
display_list
bounds
:
*
bounds
overflow
:
*
overflow
z_index
:
z_index
filters
:
filters
blend_mode
:
blend_mode
transform
:
transform
perspective
:
perspective
establishes_3d_context
:
establishes_3d_context
scrolls_overflow_area
:
scrolls_overflow_area
layer_info
:
layer_info
last_child_layer_info
:
None
}
;
StackingContextLayerCreator
:
:
add_layers_to_preserve_drawing_order
(
&
mut
stacking_context
)
;
stacking_context
}
pub
fn
draw_into_context
(
&
self
display_list
:
&
DisplayList
paint_context
:
&
mut
PaintContext
transform
:
&
Matrix4
clip_rect
:
Option
<
&
Rect
<
Au
>
>
)
{
let
temporary_draw_target
=
paint_context
.
get_or_create_temporary_draw_target
(
&
self
.
filters
self
.
blend_mode
)
;
display_list
.
draw_into_context
(
&
temporary_draw_target
paint_context
transform
clip_rect
)
;
paint_context
.
draw_temporary_draw_target_if_necessary
(
&
temporary_draw_target
&
self
.
filters
self
.
blend_mode
)
}
pub
fn
optimize_and_draw_into_context
(
&
self
paint_context
:
&
mut
PaintContext
transform
:
&
Matrix4
clip_rect
:
Option
<
&
Rect
<
Au
>
>
)
{
let
transform
=
match
self
.
layer_info
{
Some
(
.
.
)
=
>
*
transform
None
=
>
transform
.
mul
(
&
self
.
transform
)
}
;
if
paint_context
.
layer_kind
=
=
LayerKind
:
:
HasTransform
{
self
.
draw_into_context
(
&
self
.
display_list
paint_context
&
transform
clip_rect
)
;
}
else
{
let
inverse_transform
=
transform
.
invert
(
)
;
let
inverse_transform_2d
=
Matrix2D
:
:
new
(
inverse_transform
.
m11
inverse_transform
.
m12
inverse_transform
.
m21
inverse_transform
.
m22
inverse_transform
.
m41
inverse_transform
.
m42
)
;
let
tile_size
=
Size2D
:
:
new
(
paint_context
.
screen_rect
.
as_f32
(
)
.
size
.
width
paint_context
.
screen_rect
.
as_f32
(
)
.
size
.
height
)
;
let
tile_rect
=
Rect
:
:
new
(
Point2D
:
:
zero
(
)
tile_size
)
.
to_untyped
(
)
;
let
tile_rect
=
inverse_transform_2d
.
transform_rect
(
&
tile_rect
)
;
let
display_list
=
DisplayListOptimizer
:
:
new
(
&
tile_rect
)
.
optimize
(
&
*
self
.
display_list
)
;
self
.
draw_into_context
(
&
display_list
paint_context
&
transform
clip_rect
)
;
}
}
pub
fn
hit_test
(
&
self
point
:
Point2D
<
Au
>
result
:
&
mut
Vec
<
DisplayItemMetadata
>
topmost_only
:
bool
)
{
let
point
=
point
-
self
.
bounds
.
origin
;
debug_assert
!
(
!
topmost_only
|
|
result
.
is_empty
(
)
)
;
let
inv_transform
=
self
.
transform
.
invert
(
)
;
let
frac_point
=
inv_transform
.
transform_point
(
&
Point2D
:
:
new
(
point
.
x
.
to_f32_px
(
)
point
.
y
.
to_f32_px
(
)
)
)
;
let
point
=
Point2D
:
:
new
(
Au
:
:
from_f32_px
(
frac_point
.
x
)
Au
:
:
from_f32_px
(
frac_point
.
y
)
)
;
self
.
display_list
.
hit_test
(
point
result
topmost_only
)
}
pub
fn
print
(
&
self
title
:
String
)
{
let
mut
print_tree
=
PrintTree
:
:
new
(
title
)
;
self
.
print_with_tree
(
&
mut
print_tree
)
;
}
fn
print_with_tree
(
&
self
print_tree
:
&
mut
PrintTree
)
{
if
self
.
layer_info
.
is_some
(
)
{
print_tree
.
new_level
(
format
!
(
"
Layered
StackingContext
at
{
:
?
}
with
overflow
{
:
?
}
:
"
self
.
bounds
self
.
overflow
)
)
;
}
else
{
print_tree
.
new_level
(
format
!
(
"
StackingContext
at
{
:
?
}
with
overflow
{
:
?
}
:
"
self
.
bounds
self
.
overflow
)
)
;
}
self
.
display_list
.
print_with_tree
(
print_tree
)
;
print_tree
.
end_level
(
)
;
}
fn
scroll_policy
(
&
self
)
-
>
ScrollPolicy
{
match
self
.
layer_info
{
Some
(
ref
layer_info
)
=
>
layer_info
.
scroll_policy
None
=
>
ScrollPolicy
:
:
Scrollable
}
}
fn
get_layer_info
(
&
mut
self
layer_id
:
LayerId
)
-
>
&
mut
LayerInfo
{
for
layer_info
in
self
.
display_list
.
layer_info
.
iter_mut
(
)
{
if
layer_info
.
layer_id
=
=
layer_id
{
return
layer_info
;
}
}
panic
!
(
"
Could
not
find
LayerInfo
with
id
:
{
:
?
}
"
layer_id
)
;
}
}
struct
StackingContextLayerCreator
{
display_list_for_next_layer
:
Option
<
DisplayList
>
next_layer_info
:
Option
<
LayerInfo
>
building_ordering_layer
:
bool
last_child_layer_info
:
Option
<
LayerInfo
>
}
impl
StackingContextLayerCreator
{
fn
new
(
)
-
>
StackingContextLayerCreator
{
StackingContextLayerCreator
{
display_list_for_next_layer
:
None
next_layer_info
:
None
building_ordering_layer
:
false
last_child_layer_info
:
None
}
}
#
[
inline
]
fn
add_layers_to_preserve_drawing_order
(
stacking_context
:
&
mut
StackingContext
)
{
let
mut
state
=
StackingContextLayerCreator
:
:
new
(
)
;
let
positioned_content
=
mem
:
:
replace
(
&
mut
stacking_context
.
display_list
.
positioned_content
LinkedList
:
:
new
(
)
)
;
let
mut
sorted_positioned_content
:
SmallVec
<
[
DisplayItem
;
8
]
>
=
SmallVec
:
:
new
(
)
;
sorted_positioned_content
.
extend
(
positioned_content
.
into_iter
(
)
)
;
sorted_positioned_content
.
sort_by
(
|
this
other
|
this
.
compare_zindex
(
other
)
)
;
state
.
layerize_display_list_section
(
DisplayListSection
:
:
BackgroundAndBorders
stacking_context
)
;
let
mut
remaining_positioned_content
:
SmallVec
<
[
DisplayItem
;
8
]
>
=
SmallVec
:
:
new
(
)
;
for
item
in
sorted_positioned_content
.
into_iter
(
)
{
if
!
item
.
has_negative_z_index
(
)
{
remaining_positioned_content
.
push
(
item
)
;
}
else
{
state
.
add_display_item
(
item
DisplayListSection
:
:
PositionedContent
stacking_context
)
;
}
}
state
.
layerize_display_list_section
(
DisplayListSection
:
:
BlockBackgroundsAndBorders
stacking_context
)
;
state
.
layerize_display_list_section
(
DisplayListSection
:
:
Floats
stacking_context
)
;
state
.
layerize_display_list_section
(
DisplayListSection
:
:
Content
stacking_context
)
;
for
item
in
remaining_positioned_content
.
into_iter
(
)
{
assert
!
(
!
item
.
has_negative_z_index
(
)
)
;
state
.
add_display_item
(
item
DisplayListSection
:
:
PositionedContent
stacking_context
)
;
}
state
.
layerize_display_list_section
(
DisplayListSection
:
:
Outlines
stacking_context
)
;
state
.
finish_building_current_layer
(
stacking_context
)
;
stacking_context
.
last_child_layer_info
=
state
.
find_last_child_layer_info
(
stacking_context
)
;
}
#
[
inline
]
fn
layerize_display_list_section
(
&
mut
self
section
:
DisplayListSection
stacking_context
:
&
mut
StackingContext
)
{
let
section_list
=
stacking_context
.
display_list
.
get_section_mut
(
section
)
.
split_off
(
0
)
;
for
item
in
section_list
.
into_iter
(
)
{
self
.
add_display_item
(
item
section
stacking_context
)
;
}
}
#
[
inline
]
fn
all_following_children_need_layers
(
&
self
)
-
>
bool
{
self
.
next_layer_info
.
is_some
(
)
}
#
[
inline
]
fn
display_item_needs_layer
(
&
mut
self
item
:
&
DisplayItem
)
-
>
bool
{
match
*
item
{
LayeredItemClass
(
_
)
=
>
true
StackingContextClass
(
ref
stacking_context
)
=
>
stacking_context
.
layer_info
.
is_some
(
)
|
|
self
.
all_following_children_need_layers
(
)
_
=
>
self
.
all_following_children_need_layers
(
)
}
}
#
[
inline
]
fn
prepare_ordering_layer
(
&
mut
self
stacking_context
:
&
mut
StackingContext
)
{
if
self
.
building_ordering_layer
{
assert
!
(
self
.
next_layer_info
.
is_some
(
)
)
;
return
;
}
let
next_layer_info
=
Some
(
stacking_context
.
get_layer_info
(
self
.
next_layer_info
.
unwrap
(
)
.
layer_id
)
.
next_with_scroll_policy
(
ScrollPolicy
:
:
Scrollable
)
)
;
self
.
finish_building_current_layer
(
stacking_context
)
;
self
.
next_layer_info
=
next_layer_info
;
self
.
building_ordering_layer
=
true
;
}
fn
add_display_item
(
&
mut
self
item
:
DisplayItem
section
:
DisplayListSection
parent_stacking_context
:
&
mut
StackingContext
)
{
if
!
self
.
display_item_needs_layer
(
&
item
)
{
if
let
DisplayItem
:
:
StackingContextClass
(
ref
stacking_context
)
=
item
{
if
let
Some
(
layer_info
)
=
stacking_context
.
last_child_layer_info
{
self
.
last_child_layer_info
=
stacking_context
.
last_child_layer_info
;
self
.
building_ordering_layer
=
true
;
self
.
next_layer_info
=
Some
(
layer_info
.
clone
(
)
.
next_with_scroll_policy
(
ScrollPolicy
:
:
Scrollable
)
)
;
}
}
parent_stacking_context
.
display_list
.
add_to_section
(
item
section
)
;
return
;
}
if
let
StackingContextClass
(
ref
stacking_context
)
=
item
{
let
layer_info
=
stacking_context
.
layer_info
.
clone
(
)
;
if
let
Some
(
mut
layer_info
)
=
layer_info
{
self
.
finish_building_current_layer
(
parent_stacking_context
)
;
self
.
building_ordering_layer
=
true
;
self
.
next_layer_info
=
Some
(
layer_info
.
next_with_scroll_policy
(
parent_stacking_context
.
scroll_policy
(
)
)
)
;
parent_stacking_context
.
display_list
.
layered_children
.
push_back
(
Arc
:
:
new
(
PaintLayer
:
:
new_with_stacking_context
(
layer_info
stacking_context
.
clone
(
)
color
:
:
transparent
(
)
)
)
)
;
return
;
}
}
if
let
LayeredItemClass
(
item
)
=
item
{
if
let
Some
(
ref
next_layer_info
)
=
self
.
next_layer_info
{
if
item
.
layer_id
=
=
next_layer_info
.
layer_id
&
&
!
self
.
building_ordering_layer
{
return
;
}
}
self
.
finish_building_current_layer
(
parent_stacking_context
)
;
self
.
building_ordering_layer
=
false
;
self
.
next_layer_info
=
Some
(
parent_stacking_context
.
get_layer_info
(
item
.
layer_id
)
.
clone
(
)
)
;
self
.
add_display_item_to_display_list
(
item
.
item
section
)
;
return
;
}
self
.
prepare_ordering_layer
(
parent_stacking_context
)
;
self
.
add_display_item_to_display_list
(
item
section
)
;
}
fn
add_display_item_to_display_list
(
&
mut
self
item
:
DisplayItem
section
:
DisplayListSection
)
{
if
self
.
display_list_for_next_layer
.
is_none
(
)
{
self
.
display_list_for_next_layer
=
Some
(
DisplayList
:
:
new
(
)
)
;
}
if
let
Some
(
ref
mut
display_list
)
=
self
.
display_list_for_next_layer
{
display_list
.
add_to_section
(
item
section
)
;
}
}
fn
find_last_child_layer_info
(
self
stacking_context
:
&
mut
StackingContext
)
-
>
Option
<
LayerInfo
>
{
if
let
Some
(
layer
)
=
stacking_context
.
display_list
.
layered_children
.
back
(
)
{
return
Some
(
LayerInfo
:
:
new
(
layer
.
id
ScrollPolicy
:
:
Scrollable
None
)
)
;
}
self
.
last_child_layer_info
}
#
[
inline
]
fn
finish_building_current_layer
(
&
mut
self
stacking_context
:
&
mut
StackingContext
)
{
if
let
Some
(
display_list
)
=
self
.
display_list_for_next_layer
.
take
(
)
{
let
layer_info
=
self
.
next_layer_info
.
take
(
)
.
unwrap
(
)
;
stacking_context
.
display_list
.
layered_children
.
push_back
(
Arc
:
:
new
(
PaintLayer
:
:
new_with_display_list
(
layer_info
display_list
)
)
)
;
}
}
}
#
[
derive
(
Clone
Deserialize
HeapSizeOf
Serialize
)
]
pub
enum
DisplayItem
{
SolidColorClass
(
Box
<
SolidColorDisplayItem
>
)
TextClass
(
Box
<
TextDisplayItem
>
)
ImageClass
(
Box
<
ImageDisplayItem
>
)
BorderClass
(
Box
<
BorderDisplayItem
>
)
GradientClass
(
Box
<
GradientDisplayItem
>
)
LineClass
(
Box
<
LineDisplayItem
>
)
BoxShadowClass
(
Box
<
BoxShadowDisplayItem
>
)
StackingContextClass
(
Arc
<
StackingContext
>
)
LayeredItemClass
(
Box
<
LayeredItem
>
)
NoopClass
(
Box
<
BaseDisplayItem
>
)
}
#
[
derive
(
Clone
Deserialize
HeapSizeOf
Serialize
)
]
pub
struct
BaseDisplayItem
{
pub
bounds
:
Rect
<
Au
>
pub
metadata
:
DisplayItemMetadata
pub
clip
:
ClippingRegion
}
impl
BaseDisplayItem
{
#
[
inline
(
always
)
]
pub
fn
new
(
bounds
:
&
Rect
<
Au
>
metadata
:
DisplayItemMetadata
clip
:
&
ClippingRegion
)
-
>
BaseDisplayItem
{
BaseDisplayItem
{
bounds
:
*
bounds
metadata
:
metadata
clip
:
if
clip
.
does_not_clip_rect
(
bounds
)
{
ClippingRegion
:
:
max
(
)
}
else
{
(
*
clip
)
.
clone
(
)
}
}
}
}
#
[
derive
(
Clone
PartialEq
Debug
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
ClippingRegion
{
pub
main
:
Rect
<
Au
>
pub
complex
:
Vec
<
ComplexClippingRegion
>
}
#
[
derive
(
Clone
PartialEq
Debug
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
ComplexClippingRegion
{
pub
rect
:
Rect
<
Au
>
pub
radii
:
BorderRadii
<
Au
>
}
impl
ClippingRegion
{
#
[
inline
]
pub
fn
empty
(
)
-
>
ClippingRegion
{
ClippingRegion
{
main
:
Rect
:
:
zero
(
)
complex
:
Vec
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
max
(
)
-
>
ClippingRegion
{
ClippingRegion
{
main
:
MAX_RECT
complex
:
Vec
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
from_rect
(
rect
:
&
Rect
<
Au
>
)
-
>
ClippingRegion
{
ClippingRegion
{
main
:
*
rect
complex
:
Vec
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
intersect_rect
(
self
rect
:
&
Rect
<
Au
>
)
-
>
ClippingRegion
{
ClippingRegion
{
main
:
self
.
main
.
intersection
(
rect
)
.
unwrap_or
(
Rect
:
:
zero
(
)
)
complex
:
self
.
complex
}
}
#
[
inline
]
pub
fn
might_be_nonempty
(
&
self
)
-
>
bool
{
!
self
.
main
.
is_empty
(
)
}
#
[
inline
]
pub
fn
might_intersect_point
(
&
self
point
:
&
Point2D
<
Au
>
)
-
>
bool
{
self
.
main
.
contains
(
point
)
&
&
self
.
complex
.
iter
(
)
.
all
(
|
complex
|
complex
.
rect
.
contains
(
point
)
)
}
#
[
inline
]
pub
fn
might_intersect_rect
(
&
self
rect
:
&
Rect
<
Au
>
)
-
>
bool
{
self
.
main
.
intersects
(
rect
)
&
&
self
.
complex
.
iter
(
)
.
all
(
|
complex
|
complex
.
rect
.
intersects
(
rect
)
)
}
#
[
inline
]
pub
fn
does_not_clip_rect
(
&
self
rect
:
&
Rect
<
Au
>
)
-
>
bool
{
self
.
main
.
contains
(
&
rect
.
origin
)
&
&
self
.
main
.
contains
(
&
rect
.
bottom_right
(
)
)
&
&
self
.
complex
.
iter
(
)
.
all
(
|
complex
|
{
complex
.
rect
.
contains
(
&
rect
.
origin
)
&
&
complex
.
rect
.
contains
(
&
rect
.
bottom_right
(
)
)
}
)
}
#
[
inline
]
pub
fn
bounding_rect
(
&
self
)
-
>
Rect
<
Au
>
{
let
mut
rect
=
self
.
main
;
for
complex
in
&
*
self
.
complex
{
rect
=
rect
.
union
(
&
complex
.
rect
)
}
rect
}
#
[
inline
]
pub
fn
intersect_with_rounded_rect
(
mut
self
rect
:
&
Rect
<
Au
>
radii
:
&
BorderRadii
<
Au
>
)
-
>
ClippingRegion
{
self
.
complex
.
push
(
ComplexClippingRegion
{
rect
:
*
rect
radii
:
*
radii
}
)
;
self
}
#
[
inline
]
pub
fn
translate
(
&
self
delta
:
&
Point2D
<
Au
>
)
-
>
ClippingRegion
{
ClippingRegion
{
main
:
self
.
main
.
translate
(
delta
)
complex
:
self
.
complex
.
iter
(
)
.
map
(
|
complex
|
{
ComplexClippingRegion
{
rect
:
complex
.
rect
.
translate
(
delta
)
radii
:
complex
.
radii
}
}
)
.
collect
(
)
}
}
}
#
[
derive
(
Clone
Copy
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
DisplayItemMetadata
{
pub
node
:
OpaqueNode
pub
pointing
:
Option
<
Cursor
>
}
impl
DisplayItemMetadata
{
#
[
inline
]
pub
fn
new
(
node
:
OpaqueNode
style
:
&
ComputedValues
default_cursor
:
Cursor
)
-
>
DisplayItemMetadata
{
DisplayItemMetadata
{
node
:
node
pointing
:
match
(
style
.
get_pointing
(
)
.
pointer_events
style
.
get_pointing
(
)
.
cursor
)
{
(
pointer_events
:
:
T
:
:
none
_
)
=
>
None
(
pointer_events
:
:
T
:
:
auto
cursor
:
:
T
:
:
AutoCursor
)
=
>
Some
(
default_cursor
)
(
pointer_events
:
:
T
:
:
auto
cursor
:
:
T
:
:
SpecifiedCursor
(
cursor
)
)
=
>
Some
(
cursor
)
}
}
}
}
#
[
derive
(
Clone
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
SolidColorDisplayItem
{
pub
base
:
BaseDisplayItem
pub
color
:
Color
}
#
[
derive
(
Clone
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
TextDisplayItem
{
pub
base
:
BaseDisplayItem
#
[
ignore_heap_size_of
=
"
Because
it
is
non
-
owning
"
]
pub
text_run
:
Arc
<
TextRun
>
pub
range
:
Range
<
CharIndex
>
pub
text_color
:
Color
pub
baseline_origin
:
Point2D
<
Au
>
pub
orientation
:
TextOrientation
pub
blur_radius
:
Au
}
#
[
derive
(
Clone
Eq
PartialEq
HeapSizeOf
Deserialize
Serialize
)
]
pub
enum
TextOrientation
{
Upright
SidewaysLeft
SidewaysRight
}
#
[
derive
(
Clone
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
ImageDisplayItem
{
pub
base
:
BaseDisplayItem
#
[
ignore_heap_size_of
=
"
Because
it
is
non
-
owning
"
]
pub
image
:
Arc
<
Image
>
pub
stretch_size
:
Size2D
<
Au
>
pub
image_rendering
:
image_rendering
:
:
T
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
GradientDisplayItem
{
pub
base
:
BaseDisplayItem
pub
start_point
:
Point2D
<
Au
>
pub
end_point
:
Point2D
<
Au
>
pub
stops
:
Vec
<
GradientStop
>
}
impl
HeapSizeOf
for
GradientDisplayItem
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
use
libc
:
:
c_void
;
use
util
:
:
mem
:
:
heap_size_of
;
self
.
base
.
heap_size_of_children
(
)
+
heap_size_of
(
self
.
stops
.
as_ptr
(
)
as
*
const
c_void
)
}
}
#
[
derive
(
Clone
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
BorderDisplayItem
{
pub
base
:
BaseDisplayItem
pub
border_widths
:
SideOffsets2D
<
Au
>
pub
color
:
SideOffsets2D
<
Color
>
pub
style
:
SideOffsets2D
<
border_style
:
:
T
>
pub
radius
:
BorderRadii
<
Au
>
}
#
[
derive
(
Clone
PartialEq
Debug
Copy
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
BorderRadii
<
T
>
{
pub
top_left
:
Size2D
<
T
>
pub
top_right
:
Size2D
<
T
>
pub
bottom_right
:
Size2D
<
T
>
pub
bottom_left
:
Size2D
<
T
>
}
impl
<
T
>
Default
for
BorderRadii
<
T
>
where
T
:
Default
T
:
Clone
{
fn
default
(
)
-
>
Self
{
let
top_left
=
Size2D
:
:
new
(
Default
:
:
default
(
)
Default
:
:
default
(
)
)
;
let
top_right
=
Size2D
:
:
new
(
Default
:
:
default
(
)
Default
:
:
default
(
)
)
;
let
bottom_left
=
Size2D
:
:
new
(
Default
:
:
default
(
)
Default
:
:
default
(
)
)
;
let
bottom_right
=
Size2D
:
:
new
(
Default
:
:
default
(
)
Default
:
:
default
(
)
)
;
BorderRadii
{
top_left
:
top_left
top_right
:
top_right
bottom_left
:
bottom_left
bottom_right
:
bottom_right
}
}
}
impl
BorderRadii
<
Au
>
{
pub
fn
scale_by
(
&
self
s
:
f32
)
-
>
BorderRadii
<
Au
>
{
BorderRadii
{
top_left
:
BorderRadii
:
:
scale_corner_by
(
self
.
top_left
s
)
top_right
:
BorderRadii
:
:
scale_corner_by
(
self
.
top_right
s
)
bottom_left
:
BorderRadii
:
:
scale_corner_by
(
self
.
bottom_left
s
)
bottom_right
:
BorderRadii
:
:
scale_corner_by
(
self
.
bottom_right
s
)
}
}
pub
fn
scale_corner_by
(
corner
:
Size2D
<
Au
>
s
:
f32
)
-
>
Size2D
<
Au
>
{
Size2D
{
width
:
corner
.
width
.
scale_by
(
s
)
height
:
corner
.
height
.
scale_by
(
s
)
}
}
}
impl
<
T
>
BorderRadii
<
T
>
where
T
:
PartialEq
+
Zero
{
pub
fn
is_square
(
&
self
)
-
>
bool
{
let
zero
=
Zero
:
:
zero
(
)
;
self
.
top_left
=
=
zero
&
&
self
.
top_right
=
=
zero
&
&
self
.
bottom_right
=
=
zero
&
&
self
.
bottom_left
=
=
zero
}
}
impl
<
T
>
BorderRadii
<
T
>
where
T
:
PartialEq
+
Zero
+
Clone
{
pub
fn
all_same
(
value
:
T
)
-
>
BorderRadii
<
T
>
{
BorderRadii
{
top_left
:
Size2D
{
width
:
value
.
clone
(
)
height
:
value
.
clone
(
)
}
top_right
:
Size2D
{
width
:
value
.
clone
(
)
height
:
value
.
clone
(
)
}
bottom_right
:
Size2D
{
width
:
value
.
clone
(
)
height
:
value
.
clone
(
)
}
bottom_left
:
Size2D
{
width
:
value
.
clone
(
)
height
:
value
.
clone
(
)
}
}
}
}
#
[
derive
(
Clone
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
LineDisplayItem
{
pub
base
:
BaseDisplayItem
pub
color
:
Color
pub
style
:
border_style
:
:
T
}
#
[
derive
(
Clone
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
BoxShadowDisplayItem
{
pub
base
:
BaseDisplayItem
pub
box_bounds
:
Rect
<
Au
>
pub
offset
:
Point2D
<
Au
>
pub
color
:
Color
pub
blur_radius
:
Au
pub
spread_radius
:
Au
pub
border_radius
:
Au
pub
clip_mode
:
BoxShadowClipMode
}
#
[
derive
(
Clone
HeapSizeOf
Deserialize
Serialize
)
]
pub
struct
LayeredItem
{
pub
item
:
DisplayItem
pub
layer_id
:
LayerId
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
HeapSizeOf
Deserialize
Serialize
)
]
pub
enum
BoxShadowClipMode
{
None
Outset
Inset
}
pub
enum
DisplayItemIterator
<
'
a
>
{
Empty
Parent
(
linked_list
:
:
Iter
<
'
a
DisplayItem
>
)
}
impl
<
'
a
>
Iterator
for
DisplayItemIterator
<
'
a
>
{
type
Item
=
&
'
a
DisplayItem
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
DisplayItem
>
{
match
*
self
{
DisplayItemIterator
:
:
Empty
=
>
None
DisplayItemIterator
:
:
Parent
(
ref
mut
subiterator
)
=
>
subiterator
.
next
(
)
}
}
}
impl
DisplayItem
{
fn
draw_into_context
(
&
self
transform
:
&
Matrix4
paint_context
:
&
mut
PaintContext
)
{
if
let
Some
(
base
)
=
self
.
base
(
)
{
let
this_clip
=
&
base
.
clip
;
match
paint_context
.
transient_clip
{
Some
(
ref
transient_clip
)
if
transient_clip
=
=
this_clip
=
>
{
}
Some
(
_
)
|
None
=
>
paint_context
.
push_transient_clip
(
(
*
this_clip
)
.
clone
(
)
)
}
}
match
*
self
{
DisplayItem
:
:
SolidColorClass
(
ref
solid_color
)
=
>
{
if
!
solid_color
.
color
.
a
.
approx_eq
(
&
0
.
0
)
{
paint_context
.
draw_solid_color
(
&
solid_color
.
base
.
bounds
solid_color
.
color
)
}
}
DisplayItem
:
:
TextClass
(
ref
text
)
=
>
{
debug
!
(
"
Drawing
text
at
{
:
?
}
.
"
text
.
base
.
bounds
)
;
paint_context
.
draw_text
(
&
*
*
text
)
;
}
DisplayItem
:
:
ImageClass
(
ref
image_item
)
=
>
{
debug
!
(
"
Drawing
image
at
{
:
?
}
.
"
image_item
.
base
.
bounds
)
;
paint_context
.
draw_image
(
&
image_item
.
base
.
bounds
&
image_item
.
stretch_size
image_item
.
image
.
clone
(
)
image_item
.
image_rendering
.
clone
(
)
)
;
}
DisplayItem
:
:
BorderClass
(
ref
border
)
=
>
{
paint_context
.
draw_border
(
&
border
.
base
.
bounds
&
border
.
border_widths
&
border
.
radius
&
border
.
color
&
border
.
style
)
}
DisplayItem
:
:
GradientClass
(
ref
gradient
)
=
>
{
paint_context
.
draw_linear_gradient
(
&
gradient
.
base
.
bounds
&
gradient
.
start_point
&
gradient
.
end_point
&
gradient
.
stops
)
;
}
DisplayItem
:
:
LineClass
(
ref
line
)
=
>
{
paint_context
.
draw_line
(
&
line
.
base
.
bounds
line
.
color
line
.
style
)
}
DisplayItem
:
:
BoxShadowClass
(
ref
box_shadow
)
=
>
{
paint_context
.
draw_box_shadow
(
&
box_shadow
.
box_bounds
&
box_shadow
.
offset
box_shadow
.
color
box_shadow
.
blur_radius
box_shadow
.
spread_radius
box_shadow
.
clip_mode
)
;
}
DisplayItem
:
:
StackingContextClass
(
ref
stacking_context
)
=
>
{
let
pixels_per_px
=
paint_context
.
screen_pixels_per_px
(
)
;
let
new_transform
=
transform
.
translate
(
stacking_context
.
bounds
.
origin
.
x
.
to_nearest_pixel
(
pixels_per_px
.
get
(
)
)
as
AzFloat
stacking_context
.
bounds
.
origin
.
y
.
to_nearest_pixel
(
pixels_per_px
.
get
(
)
)
as
AzFloat
0
.
0
)
;
stacking_context
.
optimize_and_draw_into_context
(
paint_context
&
new_transform
Some
(
&
stacking_context
.
overflow
)
)
}
DisplayItem
:
:
LayeredItemClass
(
_
)
=
>
panic
!
(
"
Found
layered
item
during
drawing
.
"
)
DisplayItem
:
:
NoopClass
(
_
)
=
>
{
}
}
}
pub
fn
base
(
&
self
)
-
>
Option
<
&
BaseDisplayItem
>
{
match
*
self
{
DisplayItem
:
:
SolidColorClass
(
ref
solid_color
)
=
>
Some
(
&
solid_color
.
base
)
DisplayItem
:
:
TextClass
(
ref
text
)
=
>
Some
(
&
text
.
base
)
DisplayItem
:
:
ImageClass
(
ref
image_item
)
=
>
Some
(
&
image_item
.
base
)
DisplayItem
:
:
BorderClass
(
ref
border
)
=
>
Some
(
&
border
.
base
)
DisplayItem
:
:
GradientClass
(
ref
gradient
)
=
>
Some
(
&
gradient
.
base
)
DisplayItem
:
:
LineClass
(
ref
line
)
=
>
Some
(
&
line
.
base
)
DisplayItem
:
:
BoxShadowClass
(
ref
box_shadow
)
=
>
Some
(
&
box_shadow
.
base
)
DisplayItem
:
:
LayeredItemClass
(
ref
layered_item
)
=
>
layered_item
.
item
.
base
(
)
DisplayItem
:
:
NoopClass
(
ref
base_item
)
=
>
Some
(
base_item
)
DisplayItem
:
:
StackingContextClass
(
_
)
=
>
None
}
}
pub
fn
bounds
(
&
self
)
-
>
Rect
<
Au
>
{
match
*
self
{
DisplayItem
:
:
StackingContextClass
(
ref
stacking_context
)
=
>
stacking_context
.
bounds
_
=
>
self
.
base
(
)
.
unwrap
(
)
.
bounds
}
}
pub
fn
debug_with_level
(
&
self
level
:
u32
)
{
let
mut
indent
=
String
:
:
new
(
)
;
for
_
in
0
.
.
level
{
indent
.
push_str
(
"
|
"
)
}
println
!
(
"
{
}
+
{
:
?
}
"
indent
self
)
;
}
fn
compare_zindex
(
&
self
other
:
&
DisplayItem
)
-
>
Ordering
{
match
(
self
other
)
{
(
&
DisplayItem
:
:
StackingContextClass
(
ref
this
)
&
DisplayItem
:
:
StackingContextClass
(
ref
other
)
)
=
>
this
.
z_index
.
cmp
(
&
other
.
z_index
)
(
&
DisplayItem
:
:
StackingContextClass
(
ref
this
)
_
)
=
>
this
.
z_index
.
cmp
(
&
0
)
(
_
&
DisplayItem
:
:
StackingContextClass
(
ref
other
)
)
=
>
0
.
cmp
(
&
other
.
z_index
)
(
_
_
)
=
>
Ordering
:
:
Equal
}
}
fn
has_negative_z_index
(
&
self
)
-
>
bool
{
if
let
&
DisplayItem
:
:
StackingContextClass
(
ref
stacking_context
)
=
self
{
stacking_context
.
z_index
<
0
}
else
{
false
}
}
}
impl
fmt
:
:
Debug
for
DisplayItem
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
{
:
?
}
"
match
*
self
{
DisplayItem
:
:
SolidColorClass
(
ref
solid_color
)
=
>
format
!
(
"
SolidColor
rgba
(
{
}
{
}
{
}
{
}
)
"
solid_color
.
color
.
r
solid_color
.
color
.
g
solid_color
.
color
.
b
solid_color
.
color
.
a
)
DisplayItem
:
:
TextClass
(
_
)
=
>
"
Text
"
.
to_owned
(
)
DisplayItem
:
:
ImageClass
(
_
)
=
>
"
Image
"
.
to_owned
(
)
DisplayItem
:
:
BorderClass
(
_
)
=
>
"
Border
"
.
to_owned
(
)
DisplayItem
:
:
GradientClass
(
_
)
=
>
"
Gradient
"
.
to_owned
(
)
DisplayItem
:
:
LineClass
(
_
)
=
>
"
Line
"
.
to_owned
(
)
DisplayItem
:
:
BoxShadowClass
(
_
)
=
>
"
BoxShadow
"
.
to_owned
(
)
DisplayItem
:
:
StackingContextClass
(
_
)
=
>
"
StackingContext
"
.
to_owned
(
)
DisplayItem
:
:
LayeredItemClass
(
ref
layered_item
)
=
>
format
!
(
"
LayeredItem
(
{
:
?
}
)
"
layered_item
.
item
)
DisplayItem
:
:
NoopClass
(
_
)
=
>
"
Noop
"
.
to_owned
(
)
}
self
.
bounds
(
)
)
}
}
