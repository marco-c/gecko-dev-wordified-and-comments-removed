use
app_units
:
:
Au
;
use
euclid
:
:
{
Transform3D
Point2D
Vector2D
Rect
Size2D
TypedRect
SideOffsets2D
}
;
use
euclid
:
:
num
:
:
{
One
Zero
}
;
use
gfx_traits
:
:
StackingContextId
;
use
gfx_traits
:
:
print_tree
:
:
PrintTree
;
use
ipc_channel
:
:
ipc
:
:
IpcSharedMemory
;
use
msg
:
:
constellation_msg
:
:
PipelineId
;
use
net_traits
:
:
image
:
:
base
:
:
{
Image
PixelFormat
}
;
use
range
:
:
Range
;
use
servo_geometry
:
:
max_rect
;
use
std
:
:
cmp
:
:
{
self
Ordering
}
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
Arc
;
use
style
:
:
computed_values
:
:
{
border_style
image_rendering
}
;
use
style
:
:
values
:
:
computed
:
:
Filter
;
use
style_traits
:
:
cursor
:
:
Cursor
;
use
text
:
:
TextRun
;
use
text
:
:
glyph
:
:
ByteIndex
;
use
webrender_api
:
:
{
self
ClipAndScrollInfo
ClipId
ColorF
GradientStop
LocalClip
}
;
use
webrender_api
:
:
{
MixBlendMode
ScrollPolicy
ScrollSensitivity
StickyFrameInfo
}
;
use
webrender_api
:
:
TransformStyle
;
pub
use
style
:
:
dom
:
:
OpaqueNode
;
pub
static
BLUR_INFLATION_FACTOR
:
i32
=
3
;
#
[
derive
(
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
DisplayList
{
pub
list
:
Vec
<
DisplayItem
>
}
struct
ScrollOffsetLookup
<
'
a
>
{
parents
:
&
'
a
mut
HashMap
<
ClipId
ClipId
>
calculated_total_offsets
:
ScrollOffsetMap
raw_offsets
:
&
'
a
ScrollOffsetMap
}
impl
<
'
a
>
ScrollOffsetLookup
<
'
a
>
{
fn
new
(
parents
:
&
'
a
mut
HashMap
<
ClipId
ClipId
>
raw_offsets
:
&
'
a
ScrollOffsetMap
)
-
>
ScrollOffsetLookup
<
'
a
>
{
ScrollOffsetLookup
{
parents
:
parents
calculated_total_offsets
:
HashMap
:
:
new
(
)
raw_offsets
:
raw_offsets
}
}
fn
new_for_reference_frame
(
&
mut
self
clip_id
:
ClipId
transform
:
&
Transform3D
<
f32
>
point
:
&
mut
Point2D
<
Au
>
)
-
>
Option
<
ScrollOffsetLookup
>
{
let
inv_transform
=
match
transform
.
inverse
(
)
{
Some
(
transform
)
=
>
transform
None
=
>
return
None
}
;
let
scroll_offset
=
self
.
full_offset_for_clip_scroll_node
(
&
clip_id
)
;
*
point
=
Point2D
:
:
new
(
point
.
x
-
Au
:
:
from_f32_px
(
scroll_offset
.
x
)
point
.
y
-
Au
:
:
from_f32_px
(
scroll_offset
.
y
)
)
;
let
frac_point
=
inv_transform
.
transform_point2d
(
&
Point2D
:
:
new
(
point
.
x
.
to_f32_px
(
)
point
.
y
.
to_f32_px
(
)
)
)
;
*
point
=
Point2D
:
:
new
(
Au
:
:
from_f32_px
(
frac_point
.
x
)
Au
:
:
from_f32_px
(
frac_point
.
y
)
)
;
let
mut
sublookup
=
ScrollOffsetLookup
{
parents
:
&
mut
self
.
parents
calculated_total_offsets
:
HashMap
:
:
new
(
)
raw_offsets
:
self
.
raw_offsets
}
;
sublookup
.
calculated_total_offsets
.
insert
(
clip_id
Vector2D
:
:
zero
(
)
)
;
Some
(
sublookup
)
}
fn
add_clip_scroll_node
(
&
mut
self
clip_scroll_node
:
&
ClipScrollNode
)
{
self
.
parents
.
insert
(
clip_scroll_node
.
id
clip_scroll_node
.
parent_id
)
;
}
fn
full_offset_for_clip_scroll_node
(
&
mut
self
id
:
&
ClipId
)
-
>
Vector2D
<
f32
>
{
if
let
Some
(
offset
)
=
self
.
calculated_total_offsets
.
get
(
id
)
{
return
*
offset
;
}
let
parent_offset
=
if
!
id
.
is_root_scroll_node
(
)
{
let
parent_id
=
*
self
.
parents
.
get
(
id
)
.
unwrap
(
)
;
self
.
full_offset_for_clip_scroll_node
(
&
parent_id
)
}
else
{
Vector2D
:
:
zero
(
)
}
;
let
offset
=
parent_offset
+
self
.
raw_offsets
.
get
(
id
)
.
cloned
(
)
.
unwrap_or_else
(
Vector2D
:
:
zero
)
;
self
.
calculated_total_offsets
.
insert
(
*
id
offset
)
;
offset
}
}
impl
DisplayList
{
pub
fn
bounds
(
&
self
)
-
>
Rect
<
Au
>
{
match
self
.
list
.
get
(
0
)
{
Some
(
&
DisplayItem
:
:
PushStackingContext
(
ref
item
)
)
=
>
item
.
stacking_context
.
bounds
Some
(
_
)
=
>
unreachable
!
(
"
Root
element
of
display
list
not
stacking
context
.
"
)
None
=
>
Rect
:
:
zero
(
)
}
}
pub
fn
text_index
(
&
self
node
:
OpaqueNode
client_point
:
&
Point2D
<
Au
>
scroll_offsets
:
&
ScrollOffsetMap
)
-
>
Option
<
usize
>
{
let
mut
result
=
Vec
:
:
new
(
)
;
let
mut
traversal
=
DisplayListTraversal
:
:
new
(
self
)
;
self
.
text_index_contents
(
node
&
mut
traversal
client_point
&
mut
ScrollOffsetLookup
:
:
new
(
&
mut
HashMap
:
:
new
(
)
scroll_offsets
)
&
mut
result
)
;
result
.
pop
(
)
}
fn
text_index_contents
<
'
a
>
(
&
self
node
:
OpaqueNode
traversal
:
&
mut
DisplayListTraversal
<
'
a
>
point
:
&
Point2D
<
Au
>
offset_lookup
:
&
mut
ScrollOffsetLookup
result
:
&
mut
Vec
<
usize
>
)
{
while
let
Some
(
item
)
=
traversal
.
next
(
)
{
match
item
{
&
DisplayItem
:
:
PushStackingContext
(
ref
context_item
)
=
>
{
self
.
text_index_stacking_context
(
&
context_item
.
stacking_context
item
.
scroll_node_id
(
)
node
traversal
point
offset_lookup
result
)
;
}
&
DisplayItem
:
:
DefineClipScrollNode
(
ref
item
)
=
>
{
offset_lookup
.
add_clip_scroll_node
(
&
item
.
node
)
;
}
&
DisplayItem
:
:
PopStackingContext
(
_
)
=
>
return
&
DisplayItem
:
:
Text
(
ref
text
)
=
>
{
let
base
=
item
.
base
(
)
;
if
base
.
metadata
.
node
=
=
node
{
let
offset
=
*
point
-
text
.
baseline_origin
;
let
index
=
text
.
text_run
.
range_index_of_advance
(
&
text
.
range
offset
.
x
)
;
result
.
push
(
index
)
;
}
}
_
=
>
{
}
}
}
}
fn
text_index_stacking_context
<
'
a
>
(
&
self
stacking_context
:
&
StackingContext
clip_id
:
ClipId
node
:
OpaqueNode
traversal
:
&
mut
DisplayListTraversal
<
'
a
>
point
:
&
Point2D
<
Au
>
offset_lookup
:
&
mut
ScrollOffsetLookup
result
:
&
mut
Vec
<
usize
>
)
{
let
mut
point
=
*
point
-
stacking_context
.
bounds
.
origin
.
to_vector
(
)
;
if
stacking_context
.
scroll_policy
=
=
ScrollPolicy
:
:
Fixed
{
let
old_offset
=
offset_lookup
.
calculated_total_offsets
.
get
(
&
clip_id
)
.
cloned
(
)
;
offset_lookup
.
calculated_total_offsets
.
insert
(
clip_id
Vector2D
:
:
zero
(
)
)
;
self
.
text_index_contents
(
node
traversal
&
point
offset_lookup
result
)
;
match
old_offset
{
Some
(
offset
)
=
>
offset_lookup
.
calculated_total_offsets
.
insert
(
clip_id
offset
)
None
=
>
offset_lookup
.
calculated_total_offsets
.
remove
(
&
clip_id
)
}
;
}
else
if
let
Some
(
transform
)
=
stacking_context
.
transform
{
if
let
Some
(
ref
mut
sublookup
)
=
offset_lookup
.
new_for_reference_frame
(
clip_id
&
transform
&
mut
point
)
{
self
.
text_index_contents
(
node
traversal
&
point
sublookup
result
)
;
}
}
else
{
self
.
text_index_contents
(
node
traversal
&
point
offset_lookup
result
)
;
}
}
pub
fn
print
(
&
self
)
{
let
mut
print_tree
=
PrintTree
:
:
new
(
"
Display
List
"
.
to_owned
(
)
)
;
self
.
print_with_tree
(
&
mut
print_tree
)
;
}
pub
fn
print_with_tree
(
&
self
print_tree
:
&
mut
PrintTree
)
{
print_tree
.
new_level
(
"
Items
"
.
to_owned
(
)
)
;
for
item
in
&
self
.
list
{
print_tree
.
add_item
(
format
!
(
"
{
:
?
}
StackingContext
:
{
:
?
}
{
:
?
}
"
item
item
.
base
(
)
.
stacking_context_id
item
.
clip_and_scroll_info
(
)
)
)
;
}
print_tree
.
end_level
(
)
;
}
}
pub
struct
DisplayListTraversal
<
'
a
>
{
pub
display_list
:
&
'
a
DisplayList
pub
next_item_index
:
usize
pub
first_item_index
:
usize
pub
last_item_index
:
usize
}
impl
<
'
a
>
DisplayListTraversal
<
'
a
>
{
pub
fn
new
(
display_list
:
&
'
a
DisplayList
)
-
>
DisplayListTraversal
{
DisplayListTraversal
{
display_list
:
display_list
next_item_index
:
0
first_item_index
:
0
last_item_index
:
display_list
.
list
.
len
(
)
}
}
pub
fn
new_partial
(
display_list
:
&
'
a
DisplayList
stacking_context_id
:
StackingContextId
start
:
usize
end
:
usize
)
-
>
DisplayListTraversal
{
debug_assert
!
(
start
<
=
end
)
;
debug_assert
!
(
display_list
.
list
.
len
(
)
>
start
)
;
debug_assert
!
(
display_list
.
list
.
len
(
)
>
end
)
;
let
stacking_context_start
=
display_list
.
list
[
0
.
.
start
]
.
iter
(
)
.
rposition
(
|
item
|
match
item
{
&
DisplayItem
:
:
PushStackingContext
(
ref
item
)
=
>
item
.
stacking_context
.
id
=
=
stacking_context_id
_
=
>
false
}
)
.
unwrap_or
(
start
)
;
debug_assert
!
(
stacking_context_start
<
=
start
)
;
DisplayListTraversal
{
display_list
:
display_list
next_item_index
:
stacking_context_start
first_item_index
:
start
last_item_index
:
end
+
1
}
}
pub
fn
previous_item_id
(
&
self
)
-
>
usize
{
self
.
next_item_index
-
1
}
pub
fn
skip_to_end_of_stacking_context
(
&
mut
self
id
:
StackingContextId
)
{
self
.
next_item_index
=
self
.
display_list
.
list
[
self
.
next_item_index
.
.
]
.
iter
(
)
.
position
(
|
item
|
{
match
item
{
&
DisplayItem
:
:
PopStackingContext
(
ref
item
)
=
>
item
.
stacking_context_id
=
=
id
_
=
>
false
}
}
)
.
unwrap_or
(
self
.
display_list
.
list
.
len
(
)
)
;
debug_assert
!
(
self
.
next_item_index
<
self
.
last_item_index
)
;
}
}
impl
<
'
a
>
Iterator
for
DisplayListTraversal
<
'
a
>
{
type
Item
=
&
'
a
DisplayItem
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
DisplayItem
>
{
while
self
.
next_item_index
<
self
.
last_item_index
{
debug_assert
!
(
self
.
next_item_index
<
=
self
.
last_item_index
)
;
let
reached_first_item
=
self
.
next_item_index
>
=
self
.
first_item_index
;
let
item
=
&
self
.
display_list
.
list
[
self
.
next_item_index
]
;
self
.
next_item_index
+
=
1
;
if
reached_first_item
{
return
Some
(
item
)
}
match
item
{
&
DisplayItem
:
:
PushStackingContext
(
_
)
|
&
DisplayItem
:
:
PopStackingContext
(
_
)
=
>
return
Some
(
item
)
_
=
>
{
}
}
}
None
}
}
#
[
derive
(
Clone
Copy
Debug
Deserialize
Eq
MallocSizeOf
Ord
PartialEq
PartialOrd
Serialize
)
]
pub
enum
DisplayListSection
{
BackgroundAndBorders
BlockBackgroundsAndBorders
Content
Outlines
}
#
[
derive
(
Clone
Copy
Debug
Deserialize
Eq
MallocSizeOf
Ord
PartialEq
PartialOrd
Serialize
)
]
pub
enum
StackingContextType
{
Real
PseudoPositioned
PseudoFloat
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
StackingContext
{
pub
id
:
StackingContextId
pub
context_type
:
StackingContextType
pub
bounds
:
Rect
<
Au
>
pub
overflow
:
Rect
<
Au
>
pub
z_index
:
i32
pub
filters
:
Vec
<
Filter
>
pub
mix_blend_mode
:
MixBlendMode
pub
transform
:
Option
<
Transform3D
<
f32
>
>
pub
transform_style
:
TransformStyle
pub
perspective
:
Option
<
Transform3D
<
f32
>
>
pub
scroll_policy
:
ScrollPolicy
pub
parent_clip_and_scroll_info
:
ClipAndScrollInfo
}
impl
StackingContext
{
#
[
inline
]
pub
fn
new
(
id
:
StackingContextId
context_type
:
StackingContextType
bounds
:
&
Rect
<
Au
>
overflow
:
&
Rect
<
Au
>
z_index
:
i32
filters
:
Vec
<
Filter
>
mix_blend_mode
:
MixBlendMode
transform
:
Option
<
Transform3D
<
f32
>
>
transform_style
:
TransformStyle
perspective
:
Option
<
Transform3D
<
f32
>
>
scroll_policy
:
ScrollPolicy
parent_clip_and_scroll_info
:
ClipAndScrollInfo
)
-
>
StackingContext
{
StackingContext
{
id
:
id
context_type
:
context_type
bounds
:
*
bounds
overflow
:
*
overflow
z_index
:
z_index
filters
:
filters
mix_blend_mode
:
mix_blend_mode
transform
:
transform
transform_style
:
transform_style
perspective
:
perspective
scroll_policy
:
scroll_policy
parent_clip_and_scroll_info
:
parent_clip_and_scroll_info
}
}
#
[
inline
]
pub
fn
root
(
pipeline_id
:
PipelineId
)
-
>
StackingContext
{
StackingContext
:
:
new
(
StackingContextId
:
:
root
(
)
StackingContextType
:
:
Real
&
Rect
:
:
zero
(
)
&
Rect
:
:
zero
(
)
0
vec
!
[
]
MixBlendMode
:
:
Normal
None
TransformStyle
:
:
Flat
None
ScrollPolicy
:
:
Scrollable
pipeline_id
.
root_clip_and_scroll_info
(
)
)
}
pub
fn
to_display_list_items
(
self
pipeline_id
:
PipelineId
)
-
>
(
DisplayItem
DisplayItem
)
{
let
mut
base_item
=
BaseDisplayItem
:
:
empty
(
pipeline_id
)
;
base_item
.
stacking_context_id
=
self
.
id
;
base_item
.
clip_and_scroll_info
=
self
.
parent_clip_and_scroll_info
;
let
pop_item
=
DisplayItem
:
:
PopStackingContext
(
Box
:
:
new
(
PopStackingContextItem
{
base
:
base_item
.
clone
(
)
stacking_context_id
:
self
.
id
}
)
)
;
let
push_item
=
DisplayItem
:
:
PushStackingContext
(
Box
:
:
new
(
PushStackingContextItem
{
base
:
base_item
stacking_context
:
self
}
)
)
;
(
push_item
pop_item
)
}
}
impl
Ord
for
StackingContext
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
if
self
.
z_index
!
=
0
|
|
other
.
z_index
!
=
0
{
return
self
.
z_index
.
cmp
(
&
other
.
z_index
)
;
}
match
(
self
.
context_type
other
.
context_type
)
{
(
StackingContextType
:
:
PseudoFloat
StackingContextType
:
:
PseudoFloat
)
=
>
Ordering
:
:
Equal
(
StackingContextType
:
:
PseudoFloat
_
)
=
>
Ordering
:
:
Less
(
_
StackingContextType
:
:
PseudoFloat
)
=
>
Ordering
:
:
Greater
(
_
_
)
=
>
Ordering
:
:
Equal
}
}
}
impl
PartialOrd
for
StackingContext
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
Eq
for
StackingContext
{
}
impl
PartialEq
for
StackingContext
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
id
=
=
other
.
id
}
}
impl
fmt
:
:
Debug
for
StackingContext
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
type_string
=
if
self
.
context_type
=
=
StackingContextType
:
:
Real
{
"
StackingContext
"
}
else
{
"
Pseudo
-
StackingContext
"
}
;
write
!
(
f
"
{
}
at
{
:
?
}
with
overflow
{
:
?
}
:
{
:
?
}
"
type_string
self
.
bounds
self
.
overflow
self
.
id
)
}
}
#
[
derive
(
Clone
Debug
Deserialize
MallocSizeOf
Serialize
)
]
pub
enum
ClipScrollNodeType
{
ScrollFrame
(
ScrollSensitivity
)
StickyFrame
(
StickyFrameInfo
)
Clip
}
#
[
derive
(
Clone
Debug
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
ClipScrollNode
{
pub
id
:
ClipId
pub
parent_id
:
ClipId
pub
clip
:
ClippingRegion
pub
content_rect
:
Rect
<
Au
>
pub
node_type
:
ClipScrollNodeType
}
impl
ClipScrollNode
{
pub
fn
to_define_item
(
&
self
pipeline_id
:
PipelineId
)
-
>
DisplayItem
{
DisplayItem
:
:
DefineClipScrollNode
(
Box
:
:
new
(
DefineClipScrollNodeItem
{
base
:
BaseDisplayItem
:
:
empty
(
pipeline_id
)
node
:
self
.
clone
(
)
}
)
)
}
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
enum
DisplayItem
{
SolidColor
(
Box
<
SolidColorDisplayItem
>
)
Text
(
Box
<
TextDisplayItem
>
)
Image
(
Box
<
ImageDisplayItem
>
)
Border
(
Box
<
BorderDisplayItem
>
)
Gradient
(
Box
<
GradientDisplayItem
>
)
RadialGradient
(
Box
<
RadialGradientDisplayItem
>
)
Line
(
Box
<
LineDisplayItem
>
)
BoxShadow
(
Box
<
BoxShadowDisplayItem
>
)
PushTextShadow
(
Box
<
PushTextShadowDisplayItem
>
)
PopAllTextShadows
(
Box
<
PopAllTextShadowsDisplayItem
>
)
Iframe
(
Box
<
IframeDisplayItem
>
)
PushStackingContext
(
Box
<
PushStackingContextItem
>
)
PopStackingContext
(
Box
<
PopStackingContextItem
>
)
DefineClipScrollNode
(
Box
<
DefineClipScrollNodeItem
>
)
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
BaseDisplayItem
{
pub
bounds
:
Rect
<
Au
>
pub
metadata
:
DisplayItemMetadata
pub
local_clip
:
LocalClip
pub
section
:
DisplayListSection
pub
stacking_context_id
:
StackingContextId
pub
clip_and_scroll_info
:
ClipAndScrollInfo
}
impl
BaseDisplayItem
{
#
[
inline
(
always
)
]
pub
fn
new
(
bounds
:
&
Rect
<
Au
>
metadata
:
DisplayItemMetadata
local_clip
:
LocalClip
section
:
DisplayListSection
stacking_context_id
:
StackingContextId
clip_and_scroll_info
:
ClipAndScrollInfo
)
-
>
BaseDisplayItem
{
BaseDisplayItem
{
bounds
:
*
bounds
metadata
:
metadata
local_clip
:
local_clip
section
:
section
stacking_context_id
:
stacking_context_id
clip_and_scroll_info
:
clip_and_scroll_info
}
}
#
[
inline
(
always
)
]
pub
fn
empty
(
pipeline_id
:
PipelineId
)
-
>
BaseDisplayItem
{
BaseDisplayItem
{
bounds
:
TypedRect
:
:
zero
(
)
metadata
:
DisplayItemMetadata
{
node
:
OpaqueNode
(
0
)
pointing
:
None
}
local_clip
:
LocalClip
:
:
from
(
max_rect
(
)
.
to_rectf
(
)
)
section
:
DisplayListSection
:
:
Content
stacking_context_id
:
StackingContextId
:
:
root
(
)
clip_and_scroll_info
:
pipeline_id
.
root_clip_and_scroll_info
(
)
}
}
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
PartialEq
Serialize
)
]
pub
struct
ClippingRegion
{
pub
main
:
Rect
<
Au
>
pub
complex
:
Vec
<
ComplexClippingRegion
>
}
#
[
derive
(
Clone
Debug
Deserialize
MallocSizeOf
PartialEq
Serialize
)
]
pub
struct
ComplexClippingRegion
{
pub
rect
:
Rect
<
Au
>
pub
radii
:
BorderRadii
<
Au
>
}
impl
ClippingRegion
{
#
[
inline
]
pub
fn
empty
(
)
-
>
ClippingRegion
{
ClippingRegion
{
main
:
Rect
:
:
zero
(
)
complex
:
Vec
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
max
(
)
-
>
ClippingRegion
{
ClippingRegion
{
main
:
max_rect
(
)
complex
:
Vec
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
from_rect
(
rect
:
&
Rect
<
Au
>
)
-
>
ClippingRegion
{
ClippingRegion
{
main
:
*
rect
complex
:
Vec
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
intersect_rect
(
&
mut
self
rect
:
&
Rect
<
Au
>
)
{
self
.
main
=
self
.
main
.
intersection
(
rect
)
.
unwrap_or
(
Rect
:
:
zero
(
)
)
}
#
[
inline
]
pub
fn
might_be_nonempty
(
&
self
)
-
>
bool
{
!
self
.
main
.
is_empty
(
)
}
#
[
inline
]
pub
fn
might_intersect_point
(
&
self
point
:
&
Point2D
<
Au
>
)
-
>
bool
{
self
.
main
.
contains
(
point
)
&
&
self
.
complex
.
iter
(
)
.
all
(
|
complex
|
complex
.
rect
.
contains
(
point
)
)
}
#
[
inline
]
pub
fn
might_intersect_rect
(
&
self
rect
:
&
Rect
<
Au
>
)
-
>
bool
{
self
.
main
.
intersects
(
rect
)
&
&
self
.
complex
.
iter
(
)
.
all
(
|
complex
|
complex
.
rect
.
intersects
(
rect
)
)
}
#
[
inline
]
pub
fn
does_not_clip_rect
(
&
self
rect
:
&
Rect
<
Au
>
)
-
>
bool
{
self
.
main
.
contains
(
&
rect
.
origin
)
&
&
self
.
main
.
contains
(
&
rect
.
bottom_right
(
)
)
&
&
self
.
complex
.
iter
(
)
.
all
(
|
complex
|
{
complex
.
rect
.
contains
(
&
rect
.
origin
)
&
&
complex
.
rect
.
contains
(
&
rect
.
bottom_right
(
)
)
}
)
}
#
[
inline
]
pub
fn
bounding_rect
(
&
self
)
-
>
Rect
<
Au
>
{
let
mut
rect
=
self
.
main
;
for
complex
in
&
*
self
.
complex
{
rect
=
rect
.
union
(
&
complex
.
rect
)
}
rect
}
#
[
inline
]
pub
fn
intersect_with_rounded_rect
(
&
mut
self
rect
:
&
Rect
<
Au
>
radii
:
&
BorderRadii
<
Au
>
)
{
let
new_complex_region
=
ComplexClippingRegion
{
rect
:
*
rect
radii
:
*
radii
}
;
for
existing_complex_region
in
&
mut
self
.
complex
{
if
existing_complex_region
.
completely_encloses
(
&
new_complex_region
)
{
*
existing_complex_region
=
new_complex_region
;
return
}
if
new_complex_region
.
completely_encloses
(
existing_complex_region
)
{
return
}
}
self
.
complex
.
push
(
ComplexClippingRegion
{
rect
:
*
rect
radii
:
*
radii
}
)
;
}
#
[
inline
]
pub
fn
translate
(
&
self
delta
:
&
Vector2D
<
Au
>
)
-
>
ClippingRegion
{
ClippingRegion
{
main
:
self
.
main
.
translate
(
delta
)
complex
:
self
.
complex
.
iter
(
)
.
map
(
|
complex
|
{
ComplexClippingRegion
{
rect
:
complex
.
rect
.
translate
(
delta
)
radii
:
complex
.
radii
}
}
)
.
collect
(
)
}
}
#
[
inline
]
pub
fn
is_max
(
&
self
)
-
>
bool
{
self
.
main
=
=
max_rect
(
)
&
&
self
.
complex
.
is_empty
(
)
}
}
impl
fmt
:
:
Debug
for
ClippingRegion
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
*
self
=
=
ClippingRegion
:
:
max
(
)
{
write
!
(
f
"
ClippingRegion
:
:
Max
"
)
}
else
if
*
self
=
=
ClippingRegion
:
:
empty
(
)
{
write
!
(
f
"
ClippingRegion
:
:
Empty
"
)
}
else
if
self
.
main
=
=
max_rect
(
)
{
write
!
(
f
"
ClippingRegion
(
Complex
=
{
:
?
}
)
"
self
.
complex
)
}
else
{
write
!
(
f
"
ClippingRegion
(
Rect
=
{
:
?
}
Complex
=
{
:
?
}
)
"
self
.
main
self
.
complex
)
}
}
}
impl
ComplexClippingRegion
{
fn
completely_encloses
(
&
self
other
:
&
ComplexClippingRegion
)
-
>
bool
{
let
left
=
cmp
:
:
max
(
self
.
radii
.
top_left
.
width
self
.
radii
.
bottom_left
.
width
)
;
let
top
=
cmp
:
:
max
(
self
.
radii
.
top_left
.
height
self
.
radii
.
top_right
.
height
)
;
let
right
=
cmp
:
:
max
(
self
.
radii
.
top_right
.
width
self
.
radii
.
bottom_right
.
width
)
;
let
bottom
=
cmp
:
:
max
(
self
.
radii
.
bottom_left
.
height
self
.
radii
.
bottom_right
.
height
)
;
let
interior
=
Rect
:
:
new
(
Point2D
:
:
new
(
self
.
rect
.
origin
.
x
+
left
self
.
rect
.
origin
.
y
+
top
)
Size2D
:
:
new
(
self
.
rect
.
size
.
width
-
left
-
right
self
.
rect
.
size
.
height
-
top
-
bottom
)
)
;
interior
.
origin
.
x
<
=
other
.
rect
.
origin
.
x
&
&
interior
.
origin
.
y
<
=
other
.
rect
.
origin
.
y
&
&
interior
.
max_x
(
)
>
=
other
.
rect
.
max_x
(
)
&
&
interior
.
max_y
(
)
>
=
other
.
rect
.
max_y
(
)
}
}
#
[
derive
(
Clone
Copy
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
DisplayItemMetadata
{
pub
node
:
OpaqueNode
pub
pointing
:
Option
<
Cursor
>
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
SolidColorDisplayItem
{
pub
base
:
BaseDisplayItem
pub
color
:
ColorF
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
TextDisplayItem
{
pub
base
:
BaseDisplayItem
#
[
ignore_malloc_size_of
=
"
Because
it
is
non
-
owning
"
]
pub
text_run
:
Arc
<
TextRun
>
pub
range
:
Range
<
ByteIndex
>
pub
text_color
:
ColorF
pub
baseline_origin
:
Point2D
<
Au
>
pub
orientation
:
TextOrientation
}
#
[
derive
(
Clone
Deserialize
Eq
MallocSizeOf
PartialEq
Serialize
)
]
pub
enum
TextOrientation
{
Upright
SidewaysLeft
SidewaysRight
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
ImageDisplayItem
{
pub
base
:
BaseDisplayItem
pub
webrender_image
:
WebRenderImageInfo
#
[
ignore_malloc_size_of
=
"
Because
it
is
non
-
owning
"
]
pub
image_data
:
Option
<
Arc
<
IpcSharedMemory
>
>
pub
stretch_size
:
Size2D
<
Au
>
pub
tile_spacing
:
Size2D
<
Au
>
pub
image_rendering
:
image_rendering
:
:
T
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
IframeDisplayItem
{
pub
base
:
BaseDisplayItem
pub
iframe
:
PipelineId
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
Gradient
{
pub
start_point
:
Point2D
<
Au
>
pub
end_point
:
Point2D
<
Au
>
pub
stops
:
Vec
<
GradientStop
>
pub
repeating
:
bool
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
GradientDisplayItem
{
pub
base
:
BaseDisplayItem
pub
gradient
:
Gradient
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
RadialGradient
{
pub
center
:
Point2D
<
Au
>
pub
radius
:
Size2D
<
Au
>
pub
stops
:
Vec
<
GradientStop
>
pub
repeating
:
bool
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
RadialGradientDisplayItem
{
pub
base
:
BaseDisplayItem
pub
gradient
:
RadialGradient
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
NormalBorder
{
pub
color
:
SideOffsets2D
<
ColorF
>
pub
style
:
SideOffsets2D
<
border_style
:
:
T
>
pub
radius
:
BorderRadii
<
Au
>
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
ImageBorder
{
pub
image
:
WebRenderImageInfo
pub
slice
:
SideOffsets2D
<
u32
>
pub
outset
:
SideOffsets2D
<
f32
>
pub
fill
:
bool
pub
repeat_horizontal
:
webrender_api
:
:
RepeatMode
pub
repeat_vertical
:
webrender_api
:
:
RepeatMode
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
GradientBorder
{
pub
gradient
:
Gradient
pub
outset
:
SideOffsets2D
<
f32
>
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
RadialGradientBorder
{
pub
gradient
:
RadialGradient
pub
outset
:
SideOffsets2D
<
f32
>
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
enum
BorderDetails
{
Normal
(
NormalBorder
)
Image
(
ImageBorder
)
Gradient
(
GradientBorder
)
RadialGradient
(
RadialGradientBorder
)
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
BorderDisplayItem
{
pub
base
:
BaseDisplayItem
pub
border_widths
:
SideOffsets2D
<
Au
>
pub
details
:
BorderDetails
}
#
[
derive
(
Clone
Copy
Debug
Deserialize
MallocSizeOf
PartialEq
Serialize
)
]
pub
struct
BorderRadii
<
T
>
{
pub
top_left
:
Size2D
<
T
>
pub
top_right
:
Size2D
<
T
>
pub
bottom_right
:
Size2D
<
T
>
pub
bottom_left
:
Size2D
<
T
>
}
impl
<
T
>
Default
for
BorderRadii
<
T
>
where
T
:
Default
T
:
Clone
{
fn
default
(
)
-
>
Self
{
let
top_left
=
Size2D
:
:
new
(
Default
:
:
default
(
)
Default
:
:
default
(
)
)
;
let
top_right
=
Size2D
:
:
new
(
Default
:
:
default
(
)
Default
:
:
default
(
)
)
;
let
bottom_left
=
Size2D
:
:
new
(
Default
:
:
default
(
)
Default
:
:
default
(
)
)
;
let
bottom_right
=
Size2D
:
:
new
(
Default
:
:
default
(
)
Default
:
:
default
(
)
)
;
BorderRadii
{
top_left
:
top_left
top_right
:
top_right
bottom_left
:
bottom_left
bottom_right
:
bottom_right
}
}
}
impl
BorderRadii
<
Au
>
{
pub
fn
scale_by
(
&
self
s
:
f32
)
-
>
BorderRadii
<
Au
>
{
BorderRadii
{
top_left
:
BorderRadii
:
:
scale_corner_by
(
self
.
top_left
s
)
top_right
:
BorderRadii
:
:
scale_corner_by
(
self
.
top_right
s
)
bottom_left
:
BorderRadii
:
:
scale_corner_by
(
self
.
bottom_left
s
)
bottom_right
:
BorderRadii
:
:
scale_corner_by
(
self
.
bottom_right
s
)
}
}
pub
fn
scale_corner_by
(
corner
:
Size2D
<
Au
>
s
:
f32
)
-
>
Size2D
<
Au
>
{
Size2D
:
:
new
(
corner
.
width
.
scale_by
(
s
)
corner
.
height
.
scale_by
(
s
)
)
}
}
impl
<
T
>
BorderRadii
<
T
>
where
T
:
PartialEq
+
Zero
{
pub
fn
is_square
(
&
self
)
-
>
bool
{
let
zero
=
Zero
:
:
zero
(
)
;
self
.
top_left
=
=
zero
&
&
self
.
top_right
=
=
zero
&
&
self
.
bottom_right
=
=
zero
&
&
self
.
bottom_left
=
=
zero
}
}
impl
<
T
>
BorderRadii
<
T
>
where
T
:
PartialEq
+
Zero
+
Clone
{
pub
fn
all_same
(
value
:
T
)
-
>
BorderRadii
<
T
>
{
BorderRadii
{
top_left
:
Size2D
:
:
new
(
value
.
clone
(
)
value
.
clone
(
)
)
top_right
:
Size2D
:
:
new
(
value
.
clone
(
)
value
.
clone
(
)
)
bottom_right
:
Size2D
:
:
new
(
value
.
clone
(
)
value
.
clone
(
)
)
bottom_left
:
Size2D
:
:
new
(
value
.
clone
(
)
value
.
clone
(
)
)
}
}
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
LineDisplayItem
{
pub
base
:
BaseDisplayItem
pub
color
:
ColorF
#
[
ignore_malloc_size_of
=
"
enum
type
in
webrender
"
]
pub
style
:
webrender_api
:
:
LineStyle
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
BoxShadowDisplayItem
{
pub
base
:
BaseDisplayItem
pub
box_bounds
:
Rect
<
Au
>
pub
offset
:
Vector2D
<
Au
>
pub
color
:
ColorF
pub
blur_radius
:
Au
pub
spread_radius
:
Au
pub
border_radius
:
Au
pub
clip_mode
:
BoxShadowClipMode
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
PushTextShadowDisplayItem
{
pub
base
:
BaseDisplayItem
pub
offset
:
Vector2D
<
Au
>
pub
color
:
ColorF
pub
blur_radius
:
Au
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
PopAllTextShadowsDisplayItem
{
pub
base
:
BaseDisplayItem
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
PushStackingContextItem
{
pub
base
:
BaseDisplayItem
pub
stacking_context
:
StackingContext
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
PopStackingContextItem
{
pub
base
:
BaseDisplayItem
pub
stacking_context_id
:
StackingContextId
}
#
[
derive
(
Clone
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
DefineClipScrollNodeItem
{
pub
base
:
BaseDisplayItem
pub
node
:
ClipScrollNode
}
#
[
derive
(
Clone
Copy
Debug
Deserialize
MallocSizeOf
PartialEq
Serialize
)
]
pub
enum
BoxShadowClipMode
{
None
Outset
Inset
}
impl
DisplayItem
{
pub
fn
base
(
&
self
)
-
>
&
BaseDisplayItem
{
match
*
self
{
DisplayItem
:
:
SolidColor
(
ref
solid_color
)
=
>
&
solid_color
.
base
DisplayItem
:
:
Text
(
ref
text
)
=
>
&
text
.
base
DisplayItem
:
:
Image
(
ref
image_item
)
=
>
&
image_item
.
base
DisplayItem
:
:
Border
(
ref
border
)
=
>
&
border
.
base
DisplayItem
:
:
Gradient
(
ref
gradient
)
=
>
&
gradient
.
base
DisplayItem
:
:
RadialGradient
(
ref
gradient
)
=
>
&
gradient
.
base
DisplayItem
:
:
Line
(
ref
line
)
=
>
&
line
.
base
DisplayItem
:
:
BoxShadow
(
ref
box_shadow
)
=
>
&
box_shadow
.
base
DisplayItem
:
:
PushTextShadow
(
ref
push_text_shadow
)
=
>
&
push_text_shadow
.
base
DisplayItem
:
:
PopAllTextShadows
(
ref
pop_text_shadow
)
=
>
&
pop_text_shadow
.
base
DisplayItem
:
:
Iframe
(
ref
iframe
)
=
>
&
iframe
.
base
DisplayItem
:
:
PushStackingContext
(
ref
stacking_context
)
=
>
&
stacking_context
.
base
DisplayItem
:
:
PopStackingContext
(
ref
item
)
=
>
&
item
.
base
DisplayItem
:
:
DefineClipScrollNode
(
ref
item
)
=
>
&
item
.
base
}
}
pub
fn
scroll_node_id
(
&
self
)
-
>
ClipId
{
self
.
base
(
)
.
clip_and_scroll_info
.
scroll_node_id
}
pub
fn
clip_and_scroll_info
(
&
self
)
-
>
ClipAndScrollInfo
{
self
.
base
(
)
.
clip_and_scroll_info
}
pub
fn
stacking_context_id
(
&
self
)
-
>
StackingContextId
{
self
.
base
(
)
.
stacking_context_id
}
pub
fn
section
(
&
self
)
-
>
DisplayListSection
{
self
.
base
(
)
.
section
}
pub
fn
bounds
(
&
self
)
-
>
Rect
<
Au
>
{
self
.
base
(
)
.
bounds
}
pub
fn
debug_with_level
(
&
self
level
:
u32
)
{
let
mut
indent
=
String
:
:
new
(
)
;
for
_
in
0
.
.
level
{
indent
.
push_str
(
"
|
"
)
}
println
!
(
"
{
}
+
{
:
?
}
"
indent
self
)
;
}
}
impl
fmt
:
:
Debug
for
DisplayItem
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
let
DisplayItem
:
:
PushStackingContext
(
ref
item
)
=
*
self
{
return
write
!
(
f
"
PushStackingContext
(
{
:
?
}
)
"
item
.
stacking_context
)
;
}
if
let
DisplayItem
:
:
PopStackingContext
(
ref
item
)
=
*
self
{
return
write
!
(
f
"
PopStackingContext
(
{
:
?
}
"
item
.
stacking_context_id
)
;
}
if
let
DisplayItem
:
:
DefineClipScrollNode
(
ref
item
)
=
*
self
{
return
write
!
(
f
"
DefineClipScrollNode
(
{
:
?
}
"
item
.
node
)
;
}
write
!
(
f
"
{
}
{
:
?
}
{
:
?
}
"
match
*
self
{
DisplayItem
:
:
SolidColor
(
ref
solid_color
)
=
>
format
!
(
"
SolidColor
rgba
(
{
}
{
}
{
}
{
}
)
"
solid_color
.
color
.
r
solid_color
.
color
.
g
solid_color
.
color
.
b
solid_color
.
color
.
a
)
DisplayItem
:
:
Text
(
ref
text
)
=
>
{
format
!
(
"
Text
(
{
:
?
}
)
"
&
text
.
text_run
.
text
[
text
.
range
.
begin
(
)
.
0
as
usize
.
.
(
text
.
range
.
begin
(
)
.
0
+
text
.
range
.
length
(
)
.
0
)
as
usize
]
)
}
DisplayItem
:
:
Image
(
_
)
=
>
"
Image
"
.
to_owned
(
)
DisplayItem
:
:
Border
(
_
)
=
>
"
Border
"
.
to_owned
(
)
DisplayItem
:
:
Gradient
(
_
)
=
>
"
Gradient
"
.
to_owned
(
)
DisplayItem
:
:
RadialGradient
(
_
)
=
>
"
RadialGradient
"
.
to_owned
(
)
DisplayItem
:
:
Line
(
_
)
=
>
"
Line
"
.
to_owned
(
)
DisplayItem
:
:
BoxShadow
(
_
)
=
>
"
BoxShadow
"
.
to_owned
(
)
DisplayItem
:
:
PushTextShadow
(
_
)
=
>
"
PushTextShadow
"
.
to_owned
(
)
DisplayItem
:
:
PopAllTextShadows
(
_
)
=
>
"
PopTextShadow
"
.
to_owned
(
)
DisplayItem
:
:
Iframe
(
_
)
=
>
"
Iframe
"
.
to_owned
(
)
DisplayItem
:
:
PushStackingContext
(
_
)
|
DisplayItem
:
:
PopStackingContext
(
_
)
|
DisplayItem
:
:
DefineClipScrollNode
(
_
)
=
>
"
"
.
to_owned
(
)
}
self
.
bounds
(
)
self
.
base
(
)
.
local_clip
)
}
}
#
[
derive
(
Clone
Copy
Deserialize
MallocSizeOf
Serialize
)
]
pub
struct
WebRenderImageInfo
{
pub
width
:
u32
pub
height
:
u32
pub
format
:
PixelFormat
pub
key
:
Option
<
webrender_api
:
:
ImageKey
>
}
impl
WebRenderImageInfo
{
#
[
inline
]
pub
fn
from_image
(
image
:
&
Image
)
-
>
WebRenderImageInfo
{
WebRenderImageInfo
{
width
:
image
.
width
height
:
image
.
height
format
:
image
.
format
key
:
image
.
id
}
}
}
pub
type
ScrollOffsetMap
=
HashMap
<
ClipId
Vector2D
<
f32
>
>
;
pub
trait
SimpleMatrixDetection
{
fn
is_identity_or_simple_translation
(
&
self
)
-
>
bool
;
}
impl
SimpleMatrixDetection
for
Transform3D
<
f32
>
{
#
[
inline
]
fn
is_identity_or_simple_translation
(
&
self
)
-
>
bool
{
let
(
_0
_1
)
=
(
Zero
:
:
zero
(
)
One
:
:
one
(
)
)
;
self
.
m11
=
=
_1
&
&
self
.
m12
=
=
_0
&
&
self
.
m13
=
=
_0
&
&
self
.
m14
=
=
_0
&
&
self
.
m21
=
=
_0
&
&
self
.
m22
=
=
_1
&
&
self
.
m23
=
=
_0
&
&
self
.
m24
=
=
_0
&
&
self
.
m31
=
=
_0
&
&
self
.
m32
=
=
_0
&
&
self
.
m33
=
=
_1
&
&
self
.
m34
=
=
_0
&
&
self
.
m44
=
=
_1
}
}
trait
ToPointF
{
fn
to_pointf
(
&
self
)
-
>
webrender_api
:
:
LayoutPoint
;
}
impl
ToPointF
for
Point2D
<
Au
>
{
fn
to_pointf
(
&
self
)
-
>
webrender_api
:
:
LayoutPoint
{
webrender_api
:
:
LayoutPoint
:
:
new
(
self
.
x
.
to_f32_px
(
)
self
.
y
.
to_f32_px
(
)
)
}
}
trait
ToRectF
{
fn
to_rectf
(
&
self
)
-
>
webrender_api
:
:
LayoutRect
;
}
impl
ToRectF
for
Rect
<
Au
>
{
fn
to_rectf
(
&
self
)
-
>
webrender_api
:
:
LayoutRect
{
let
x
=
self
.
origin
.
x
.
to_f32_px
(
)
;
let
y
=
self
.
origin
.
y
.
to_f32_px
(
)
;
let
w
=
self
.
size
.
width
.
to_f32_px
(
)
;
let
h
=
self
.
size
.
height
.
to_f32_px
(
)
;
let
point
=
webrender_api
:
:
LayoutPoint
:
:
new
(
x
y
)
;
let
size
=
webrender_api
:
:
LayoutSize
:
:
new
(
w
h
)
;
webrender_api
:
:
LayoutRect
:
:
new
(
point
size
)
}
}
