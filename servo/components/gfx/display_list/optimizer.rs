use
display_list
:
:
{
DisplayItem
DisplayList
StackingContext
}
;
use
collections
:
:
dlist
:
:
DList
;
use
geom
:
:
rect
:
:
Rect
;
use
servo_util
:
:
geometry
:
:
{
mod
Au
}
;
use
sync
:
:
Arc
;
pub
struct
DisplayListOptimizer
{
visible_rect
:
Rect
<
Au
>
}
impl
DisplayListOptimizer
{
pub
fn
new
(
visible_rect
:
&
Rect
<
f32
>
)
-
>
DisplayListOptimizer
{
DisplayListOptimizer
{
visible_rect
:
geometry
:
:
f32_rect_to_au_rect
(
*
visible_rect
)
}
}
pub
fn
optimize
(
self
display_list
:
&
DisplayList
)
-
>
DisplayList
{
let
mut
result
=
DisplayList
:
:
new
(
)
;
self
.
add_in_bounds_display_items
(
&
mut
result
.
background_and_borders
display_list
.
background_and_borders
.
iter
(
)
)
;
self
.
add_in_bounds_display_items
(
&
mut
result
.
block_backgrounds_and_borders
display_list
.
block_backgrounds_and_borders
.
iter
(
)
)
;
self
.
add_in_bounds_display_items
(
&
mut
result
.
floats
display_list
.
floats
.
iter
(
)
)
;
self
.
add_in_bounds_display_items
(
&
mut
result
.
content
display_list
.
content
.
iter
(
)
)
;
self
.
add_in_bounds_display_items
(
&
mut
result
.
outlines
display_list
.
outlines
.
iter
(
)
)
;
self
.
add_in_bounds_stacking_contexts
(
&
mut
result
.
children
display_list
.
children
.
iter
(
)
)
;
result
}
fn
add_in_bounds_display_items
<
'
a
I
>
(
&
self
result_list
:
&
mut
DList
<
DisplayItem
>
mut
display_items
:
I
)
where
I
:
Iterator
<
&
'
a
DisplayItem
>
{
for
display_item
in
display_items
{
if
self
.
visible_rect
.
intersects
(
&
display_item
.
base
(
)
.
bounds
)
&
&
display_item
.
base
(
)
.
clip
.
might_intersect_rect
(
&
self
.
visible_rect
)
{
result_list
.
push_back
(
(
*
display_item
)
.
clone
(
)
)
}
}
}
fn
add_in_bounds_stacking_contexts
<
'
a
I
>
(
&
self
result_list
:
&
mut
DList
<
Arc
<
StackingContext
>
>
mut
stacking_contexts
:
I
)
where
I
:
Iterator
<
&
'
a
Arc
<
StackingContext
>
>
{
for
stacking_context
in
stacking_contexts
{
let
overflow
=
stacking_context
.
overflow
.
translate
(
&
stacking_context
.
bounds
.
origin
)
;
if
self
.
visible_rect
.
intersects
(
&
overflow
)
{
result_list
.
push_back
(
(
*
stacking_context
)
.
clone
(
)
)
}
}
}
}
