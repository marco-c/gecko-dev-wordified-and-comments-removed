use
font
:
:
{
Font
FontGroup
}
;
use
font
:
:
SpecifiedFontStyle
;
use
platform
:
:
font_context
:
:
FontContextHandle
;
use
style
:
:
computed_values
:
:
{
font_style
font_variant
}
;
use
font_cache_task
:
:
FontCacheTask
;
use
font_template
:
:
FontTemplateDescriptor
;
use
platform
:
:
font_template
:
:
FontTemplateData
;
use
font
:
:
FontHandleMethods
;
use
platform
:
:
font
:
:
FontHandle
;
use
servo_util
:
:
cache
:
:
HashCache
;
use
servo_util
:
:
smallvec
:
:
{
SmallVec
SmallVec1
}
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
cell
:
:
RefCell
;
use
sync
:
:
Arc
;
use
azure
:
:
AzFloat
;
use
azure
:
:
azure_hl
:
:
BackendType
;
use
azure
:
:
scaled_font
:
:
ScaledFont
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
#
[
cfg
(
target_os
=
"
android
"
)
]
use
azure
:
:
scaled_font
:
:
FontData
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
create_scaled_font
(
backend
:
BackendType
template
:
&
Arc
<
FontTemplateData
>
pt_size
:
f64
)
-
>
ScaledFont
{
ScaledFont
:
:
new
(
backend
FontData
(
&
template
.
bytes
)
pt_size
as
AzFloat
)
}
#
[
cfg
(
target_os
=
"
macos
"
)
]
fn
create_scaled_font
(
backend
:
BackendType
template
:
&
Arc
<
FontTemplateData
>
pt_size
:
f64
)
-
>
ScaledFont
{
let
cgfont
=
template
.
ctfont
.
as_ref
(
)
.
unwrap
(
)
.
copy_to_CGFont
(
)
;
ScaledFont
:
:
new
(
backend
&
cgfont
pt_size
as
AzFloat
)
}
static
SMALL_CAPS_SCALE_FACTOR
:
f64
=
0
.
8
;
struct
LayoutFontCacheEntry
{
family
:
String
font
:
Rc
<
RefCell
<
Font
>
>
}
struct
FallbackFontCacheEntry
{
font
:
Rc
<
RefCell
<
Font
>
>
}
struct
RenderFontCacheEntry
{
pt_size
:
f64
identifier
:
String
font
:
Rc
<
RefCell
<
ScaledFont
>
>
}
pub
struct
FontContext
{
platform_handle
:
FontContextHandle
font_cache_task
:
FontCacheTask
layout_font_cache
:
Vec
<
LayoutFontCacheEntry
>
fallback_font_cache
:
Vec
<
FallbackFontCacheEntry
>
render_font_cache
:
Vec
<
RenderFontCacheEntry
>
}
impl
FontContext
{
pub
fn
new
(
font_cache_task
:
FontCacheTask
)
-
>
FontContext
{
let
handle
=
FontContextHandle
:
:
new
(
)
;
FontContext
{
platform_handle
:
handle
font_cache_task
:
font_cache_task
layout_font_cache
:
vec
!
(
)
fallback_font_cache
:
vec
!
(
)
render_font_cache
:
vec
!
(
)
}
}
fn
create_layout_font
(
&
self
template
:
Arc
<
FontTemplateData
>
descriptor
:
FontTemplateDescriptor
pt_size
:
f64
variant
:
font_variant
:
:
T
)
-
>
Font
{
let
actual_pt_size
=
match
variant
{
font_variant
:
:
small_caps
=
>
pt_size
*
SMALL_CAPS_SCALE_FACTOR
font_variant
:
:
normal
=
>
pt_size
}
;
let
handle
:
FontHandle
=
FontHandleMethods
:
:
new_from_template
(
&
self
.
platform_handle
template
Some
(
actual_pt_size
)
)
.
unwrap
(
)
;
let
metrics
=
handle
.
get_metrics
(
)
;
Font
{
handle
:
handle
shaper
:
None
variant
:
variant
descriptor
:
descriptor
requested_pt_size
:
pt_size
actual_pt_size
:
actual_pt_size
metrics
:
metrics
shape_cache
:
HashCache
:
:
new
(
)
glyph_advance_cache
:
HashCache
:
:
new
(
)
}
}
pub
fn
get_layout_font_group_for_style
(
&
mut
self
style
:
&
SpecifiedFontStyle
)
-
>
FontGroup
{
let
desc
=
FontTemplateDescriptor
:
:
new
(
style
.
font_weight
style
.
font_style
=
=
font_style
:
:
italic
)
;
let
mut
fonts
:
SmallVec1
<
Rc
<
RefCell
<
Font
>
>
>
=
SmallVec1
:
:
new
(
)
;
for
family
in
style
.
font_family
.
iter
(
)
{
let
mut
cache_hit
=
false
;
for
cached_font_entry
in
self
.
layout_font_cache
.
iter
(
)
{
if
cached_font_entry
.
family
.
as_slice
(
)
=
=
family
.
name
(
)
{
let
cached_font
=
cached_font_entry
.
font
.
borrow
(
)
;
if
cached_font
.
descriptor
=
=
desc
&
&
cached_font
.
requested_pt_size
=
=
style
.
font_size
.
to_subpx
(
)
&
&
cached_font
.
variant
=
=
style
.
font_variant
{
fonts
.
push
(
cached_font_entry
.
font
.
clone
(
)
)
;
cache_hit
=
true
;
break
;
}
}
}
if
!
cache_hit
{
let
font_template
=
self
.
font_cache_task
.
get_font_template
(
family
.
name
(
)
.
to_string
(
)
desc
.
clone
(
)
)
;
match
font_template
{
Some
(
font_template
)
=
>
{
let
layout_font
=
self
.
create_layout_font
(
font_template
desc
.
clone
(
)
style
.
font_size
.
to_subpx
(
)
style
.
font_variant
)
;
let
layout_font
=
Rc
:
:
new
(
RefCell
:
:
new
(
layout_font
)
)
;
self
.
layout_font_cache
.
push
(
LayoutFontCacheEntry
{
family
:
family
.
name
(
)
.
to_string
(
)
font
:
layout_font
.
clone
(
)
}
)
;
fonts
.
push
(
layout_font
)
;
}
None
=
>
{
}
}
}
}
if
fonts
.
len
(
)
=
=
0
{
let
mut
cache_hit
=
false
;
for
cached_font_entry
in
self
.
fallback_font_cache
.
iter
(
)
{
let
cached_font
=
cached_font_entry
.
font
.
borrow
(
)
;
if
cached_font
.
descriptor
=
=
desc
&
&
cached_font
.
requested_pt_size
=
=
style
.
font_size
.
to_subpx
(
)
&
&
cached_font
.
variant
=
=
style
.
font_variant
{
fonts
.
push
(
cached_font_entry
.
font
.
clone
(
)
)
;
cache_hit
=
true
;
break
;
}
}
if
!
cache_hit
{
let
font_template
=
self
.
font_cache_task
.
get_last_resort_font_template
(
desc
.
clone
(
)
)
;
let
layout_font
=
self
.
create_layout_font
(
font_template
desc
.
clone
(
)
style
.
font_size
.
to_subpx
(
)
style
.
font_variant
)
;
let
layout_font
=
Rc
:
:
new
(
RefCell
:
:
new
(
layout_font
)
)
;
self
.
fallback_font_cache
.
push
(
FallbackFontCacheEntry
{
font
:
layout_font
.
clone
(
)
}
)
;
fonts
.
push
(
layout_font
)
;
}
}
FontGroup
:
:
new
(
fonts
)
}
pub
fn
get_render_font_from_template
(
&
mut
self
template
:
&
Arc
<
FontTemplateData
>
pt_size
:
f64
backend
:
BackendType
)
-
>
Rc
<
RefCell
<
ScaledFont
>
>
{
for
cached_font
in
self
.
render_font_cache
.
iter
(
)
{
if
cached_font
.
pt_size
=
=
pt_size
&
&
cached_font
.
identifier
=
=
template
.
identifier
{
return
cached_font
.
font
.
clone
(
)
;
}
}
let
render_font
=
Rc
:
:
new
(
RefCell
:
:
new
(
create_scaled_font
(
backend
template
pt_size
)
)
)
;
self
.
render_font_cache
.
push
(
RenderFontCacheEntry
{
font
:
render_font
.
clone
(
)
pt_size
:
pt_size
identifier
:
template
.
identifier
.
clone
(
)
}
)
;
render_font
}
}
