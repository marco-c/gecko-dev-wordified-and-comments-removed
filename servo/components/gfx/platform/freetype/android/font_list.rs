use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
self
Read
}
;
use
std
:
:
path
:
:
Path
;
use
xml5ever
:
:
Attribute
;
use
xml5ever
:
:
driver
:
:
parse_document
;
use
xml5ever
:
:
rcdom
:
:
*
;
use
xml5ever
:
:
rcdom
:
:
{
Node
RcDom
}
;
use
xml5ever
:
:
tendril
:
:
TendrilSink
;
lazy_static
!
{
static
ref
FONT_LIST
:
FontList
=
FontList
:
:
new
(
)
;
}
struct
Font
{
filename
:
String
weight
:
Option
<
i32
>
}
struct
FontFamily
{
name
:
String
fonts
:
Vec
<
Font
>
}
struct
FontAlias
{
from
:
String
to
:
String
weight
:
Option
<
i32
>
}
struct
FontList
{
families
:
Vec
<
FontFamily
>
aliases
:
Vec
<
FontAlias
>
}
impl
FontList
{
fn
new
(
)
-
>
FontList
{
let
paths
=
[
"
/
etc
/
fonts
.
xml
"
"
/
system
/
etc
/
system_fonts
.
xml
"
]
;
let
mut
result
=
None
;
paths
.
iter
(
)
.
all
(
|
path
|
{
result
=
Self
:
:
from_path
(
path
)
;
!
result
.
is_some
(
)
}
)
;
match
result
{
Some
(
result
)
=
>
result
None
=
>
FontList
{
families
:
Self
:
:
fallback_font_families
(
)
aliases
:
Vec
:
:
new
(
)
}
}
}
fn
from_path
(
path
:
&
str
)
-
>
Option
<
FontList
>
{
let
xml
=
match
Self
:
:
load_file
(
path
)
{
Ok
(
xml
)
=
>
xml
_
=
>
{
return
None
;
}
}
;
let
dom
:
RcDom
=
parse_document
(
RcDom
:
:
default
(
)
Default
:
:
default
(
)
)
.
one
(
xml
)
;
let
doc
=
&
dom
.
document
;
let
children
=
doc
.
children
.
borrow
(
)
;
let
familyset
=
children
.
iter
(
)
.
find
(
|
child
|
{
match
child
.
data
{
NodeData
:
:
Element
{
ref
name
.
.
}
=
>
&
*
name
.
local
=
=
"
familyset
"
_
=
>
false
}
}
)
;
let
familyset
=
match
familyset
{
Some
(
node
)
=
>
node
_
=
>
{
return
None
;
}
}
;
let
mut
families
=
Vec
:
:
new
(
)
;
let
mut
aliases
=
Vec
:
:
new
(
)
;
for
node
in
familyset
.
children
.
borrow
(
)
.
iter
(
)
{
match
node
.
data
{
NodeData
:
:
Element
{
ref
name
ref
attrs
.
.
}
=
>
{
if
&
*
name
.
local
=
=
"
family
"
{
Self
:
:
parse_family
(
&
node
attrs
&
mut
families
)
;
}
else
if
&
*
name
.
local
=
=
"
alias
"
{
if
!
families
.
is_empty
(
)
{
Self
:
:
parse_alias
(
attrs
&
mut
aliases
)
;
}
}
}
_
=
>
{
}
}
}
Some
(
FontList
{
families
:
families
aliases
:
aliases
}
)
}
fn
fallback_font_families
(
)
-
>
Vec
<
FontFamily
>
{
let
alternatives
=
[
(
"
sans
-
serif
"
"
Roboto
-
Regular
.
ttf
"
)
(
"
Droid
Sans
"
"
DroidSans
.
ttf
"
)
]
;
alternatives
.
iter
(
)
.
filter
(
|
item
|
{
Path
:
:
new
(
&
Self
:
:
font_absolute_path
(
item
.
1
)
)
.
exists
(
)
}
)
.
map
(
|
item
|
{
FontFamily
{
name
:
item
.
0
.
into
(
)
fonts
:
vec
!
[
Font
{
filename
:
item
.
1
.
into
(
)
weight
:
None
}
]
}
}
)
.
collect
(
)
}
fn
font_absolute_path
(
filename
:
&
str
)
-
>
String
{
format
!
(
"
/
system
/
fonts
/
{
}
"
filename
)
}
fn
find_family
(
&
self
name
:
&
str
)
-
>
Option
<
&
FontFamily
>
{
self
.
families
.
iter
(
)
.
find
(
|
f
|
f
.
name
=
=
name
)
}
fn
find_alias
(
&
self
name
:
&
str
)
-
>
Option
<
&
FontAlias
>
{
self
.
aliases
.
iter
(
)
.
find
(
|
f
|
f
.
from
=
=
name
)
}
fn
load_file
(
path
:
&
str
)
-
>
Result
<
String
io
:
:
Error
>
{
let
mut
file
=
File
:
:
open
(
path
)
?
;
let
mut
content
=
String
:
:
new
(
)
;
file
.
read_to_string
(
&
mut
content
)
?
;
Ok
(
content
)
}
fn
parse_family
(
familyset
:
&
Node
attrs
:
&
RefCell
<
Vec
<
Attribute
>
>
out
:
&
mut
Vec
<
FontFamily
>
)
{
let
using_api_17
=
familyset
.
children
.
borrow
(
)
.
iter
(
)
.
any
(
|
node
|
{
match
node
.
data
{
NodeData
:
:
Element
{
ref
name
.
.
}
=
>
&
*
name
.
local
=
=
"
nameset
"
_
=
>
false
}
}
)
;
if
using_api_17
{
Self
:
:
parse_family_v17
(
familyset
out
)
;
return
;
}
let
name
=
match
Self
:
:
find_attrib
(
"
name
"
attrs
)
{
Some
(
name
)
=
>
name
_
=
>
{
return
;
}
}
;
let
mut
fonts
=
Vec
:
:
new
(
)
;
for
node
in
familyset
.
children
.
borrow
(
)
.
iter
(
)
{
match
node
.
data
{
NodeData
:
:
Element
{
ref
name
ref
attrs
.
.
}
=
>
{
if
&
*
name
.
local
=
=
"
font
"
{
FontList
:
:
parse_font
(
&
node
attrs
&
mut
fonts
)
;
}
}
_
=
>
{
}
}
}
out
.
push
(
FontFamily
{
name
:
name
fonts
:
fonts
}
)
;
}
fn
parse_family_v17
(
familyset
:
&
Node
out
:
&
mut
Vec
<
FontFamily
>
)
{
let
mut
nameset
=
Vec
:
:
new
(
)
;
let
mut
fileset
=
Vec
:
:
new
(
)
;
for
node
in
familyset
.
children
.
borrow
(
)
.
iter
(
)
{
match
node
.
data
{
NodeData
:
:
Element
{
ref
name
.
.
}
=
>
{
if
&
*
name
.
local
=
=
"
nameset
"
{
Self
:
:
collect_contents_with_tag
(
node
"
name
"
&
mut
nameset
)
;
}
else
if
&
*
name
.
local
=
=
"
fileset
"
{
Self
:
:
collect_contents_with_tag
(
node
"
file
"
&
mut
fileset
)
;
}
}
_
=
>
{
}
}
}
for
name
in
nameset
{
let
fonts
:
Vec
<
Font
>
=
fileset
.
iter
(
)
.
map
(
|
f
|
Font
{
filename
:
f
.
clone
(
)
weight
:
None
}
)
.
collect
(
)
;
if
!
fonts
.
is_empty
(
)
{
out
.
push
(
FontFamily
{
name
:
name
fonts
:
fonts
}
)
}
}
}
fn
parse_font
(
node
:
&
Node
attrs
:
&
RefCell
<
Vec
<
Attribute
>
>
out
:
&
mut
Vec
<
Font
>
)
{
let
filename
=
match
Self
:
:
text_content
(
node
)
{
Some
(
filename
)
=
>
filename
_
=
>
{
return
;
}
}
;
let
weight
=
Self
:
:
find_attrib
(
"
weight
"
attrs
)
.
and_then
(
|
w
|
w
.
parse
(
)
.
ok
(
)
)
;
out
.
push
(
Font
{
filename
:
filename
weight
:
weight
}
)
}
fn
parse_alias
(
attrs
:
&
RefCell
<
Vec
<
Attribute
>
>
out
:
&
mut
Vec
<
FontAlias
>
)
{
let
from
=
match
Self
:
:
find_attrib
(
"
name
"
attrs
)
{
Some
(
from
)
=
>
from
_
=
>
{
return
;
}
}
;
let
to
=
match
Self
:
:
find_attrib
(
"
to
"
attrs
)
{
Some
(
to
)
=
>
to
_
=
>
{
return
;
}
}
;
let
weight
=
Self
:
:
find_attrib
(
"
weight
"
attrs
)
.
and_then
(
|
w
|
w
.
parse
(
)
.
ok
(
)
)
;
out
.
push
(
FontAlias
{
from
:
from
to
:
to
weight
:
weight
}
)
}
fn
find_attrib
(
name
:
&
str
attrs
:
&
RefCell
<
Vec
<
Attribute
>
>
)
-
>
Option
<
String
>
{
attrs
.
borrow
(
)
.
iter
(
)
.
find
(
|
attr
|
&
*
attr
.
name
.
local
=
=
name
)
.
map
(
|
s
|
String
:
:
from
(
&
s
.
value
)
)
}
fn
text_content
(
node
:
&
Node
)
-
>
Option
<
String
>
{
node
.
children
.
borrow
(
)
.
get
(
0
)
.
and_then
(
|
child
|
{
match
child
.
data
{
NodeData
:
:
Text
{
ref
contents
}
=
>
{
let
mut
result
=
String
:
:
new
(
)
;
result
.
push_str
(
&
contents
.
borrow
(
)
)
;
Some
(
result
)
}
_
=
>
None
}
}
)
}
fn
collect_contents_with_tag
(
node
:
&
Node
tag
:
&
str
out
:
&
mut
Vec
<
String
>
)
{
for
child
in
node
.
children
.
borrow
(
)
.
iter
(
)
{
match
child
.
data
{
NodeData
:
:
Element
{
ref
name
.
.
}
=
>
{
if
&
*
name
.
local
=
=
tag
{
if
let
Some
(
content
)
=
Self
:
:
text_content
(
child
)
{
out
.
push
(
content
)
;
}
}
}
_
=
>
{
}
}
}
}
}
pub
fn
for_each_available_family
<
F
>
(
mut
callback
:
F
)
where
F
:
FnMut
(
String
)
{
for
family
in
&
FONT_LIST
.
families
{
callback
(
family
.
name
.
clone
(
)
)
;
}
for
alias
in
&
FONT_LIST
.
aliases
{
callback
(
alias
.
from
.
clone
(
)
)
;
}
}
pub
fn
for_each_variation
<
F
>
(
family_name
:
&
str
mut
callback
:
F
)
where
F
:
FnMut
(
String
)
{
println
!
(
"
Variatioooon
{
:
?
}
"
family_name
)
;
if
let
Some
(
family
)
=
FONT_LIST
.
find_family
(
family_name
)
{
for
font
in
&
family
.
fonts
{
callback
(
FontList
:
:
font_absolute_path
(
&
font
.
filename
)
)
;
}
return
;
}
if
let
Some
(
alias
)
=
FONT_LIST
.
find_alias
(
family_name
)
{
if
let
Some
(
family
)
=
FONT_LIST
.
find_family
(
&
alias
.
to
)
{
for
font
in
&
family
.
fonts
{
match
(
alias
.
weight
font
.
weight
)
{
(
None
_
)
=
>
callback
(
FontList
:
:
font_absolute_path
(
&
font
.
filename
)
)
(
Some
(
w1
)
Some
(
w2
)
)
=
>
{
if
w1
=
=
w2
{
callback
(
FontList
:
:
font_absolute_path
(
&
font
.
filename
)
)
}
}
_
=
>
{
}
}
}
}
}
}
pub
fn
system_default_family
(
generic_name
:
&
str
)
-
>
Option
<
String
>
{
if
let
Some
(
family
)
=
FONT_LIST
.
find_family
(
&
generic_name
)
{
Some
(
family
.
name
.
clone
(
)
)
}
else
if
let
Some
(
alias
)
=
FONT_LIST
.
find_alias
(
&
generic_name
)
{
Some
(
alias
.
from
.
clone
(
)
)
}
else
{
FONT_LIST
.
families
.
get
(
0
)
.
map
(
|
family
|
family
.
name
.
clone
(
)
)
}
}
pub
fn
last_resort_font_families
(
)
-
>
Vec
<
String
>
{
vec
!
(
"
sans
-
serif
"
.
to_owned
(
)
"
Droid
Sans
"
.
to_owned
(
)
"
serif
"
.
to_owned
(
)
)
}
pub
static
SANS_SERIF_FONT_FAMILY
:
&
'
static
str
=
"
sans
-
serif
"
;
