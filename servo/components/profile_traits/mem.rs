#
!
[
deny
(
missing_docs
)
]
use
ipc_channel
:
:
ipc
:
:
{
self
IpcSender
}
;
use
ipc_channel
:
:
router
:
:
ROUTER
;
use
std
:
:
marker
:
:
Send
;
use
std
:
:
sync
:
:
mpsc
:
:
Sender
;
pub
trait
OpaqueSender
<
T
>
{
fn
send
(
&
self
message
:
T
)
;
}
impl
<
T
>
OpaqueSender
<
T
>
for
Sender
<
T
>
{
fn
send
(
&
self
message
:
T
)
{
if
let
Err
(
e
)
=
Sender
:
:
send
(
self
message
)
{
warn
!
(
"
Error
communicating
with
the
target
thread
from
the
profiler
:
{
}
"
e
)
;
}
}
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
ProfilerChan
(
pub
IpcSender
<
ProfilerMsg
>
)
;
impl
ProfilerChan
{
pub
fn
send
(
&
self
msg
:
ProfilerMsg
)
{
if
let
Err
(
e
)
=
self
.
0
.
send
(
msg
)
{
warn
!
(
"
Error
communicating
with
the
memory
profiler
thread
:
{
}
"
e
)
;
}
}
pub
fn
run_with_memory_reporting
<
F
M
T
C
>
(
&
self
f
:
F
reporter_name
:
String
channel_for_reporter
:
C
msg
:
M
)
where
F
:
FnOnce
(
)
M
:
Fn
(
ReportsChan
)
-
>
T
+
Send
+
'
static
T
:
Send
+
'
static
C
:
OpaqueSender
<
T
>
+
Send
+
'
static
{
let
(
reporter_sender
reporter_receiver
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
ROUTER
.
add_route
(
reporter_receiver
.
to_opaque
(
)
box
move
|
message
|
{
/
/
Just
injects
an
appropriate
event
into
the
paint
thread
'
s
queue
.
let
request
:
ReporterRequest
=
message
.
to
(
)
.
unwrap
(
)
;
channel_for_reporter
.
send
(
msg
(
request
.
reports_channel
)
)
;
}
)
;
self
.
send
(
ProfilerMsg
:
:
RegisterReporter
(
reporter_name
.
clone
(
)
Reporter
(
reporter_sender
)
)
)
;
f
(
)
;
self
.
send
(
ProfilerMsg
:
:
UnregisterReporter
(
reporter_name
)
)
;
}
}
/
/
/
The
various
kinds
of
memory
measurement
.
/
/
/
/
/
/
Here
"
explicit
"
means
explicit
memory
allocations
done
by
the
application
.
It
includes
/
/
/
allocations
made
at
the
OS
level
(
via
functions
such
as
VirtualAlloc
vm_allocate
and
mmap
)
/
/
/
allocations
made
at
the
heap
allocation
level
(
via
functions
such
as
malloc
calloc
realloc
/
/
/
memalign
operator
new
and
operator
new
[
]
)
and
where
possible
the
overhead
of
the
heap
/
/
/
allocator
itself
.
It
excludes
memory
that
is
mapped
implicitly
such
as
code
and
data
segments
/
/
/
and
thread
stacks
.
"
explicit
"
is
not
guaranteed
to
cover
every
explicit
allocation
but
it
does
/
/
/
cover
most
(
including
the
entire
heap
)
and
therefore
it
is
the
single
best
number
to
focus
on
/
/
/
when
trying
to
reduce
memory
usage
.
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
ReportKind
{
/
/
/
A
size
measurement
for
an
explicit
allocation
on
the
jemalloc
heap
.
This
should
be
used
/
/
/
for
any
measurements
done
via
the
HeapSizeOf
trait
.
ExplicitJemallocHeapSize
/
/
/
A
size
measurement
for
an
explicit
allocation
on
the
system
heap
.
Only
likely
to
be
used
/
/
/
for
external
C
or
C
+
+
libraries
that
don
'
t
use
jemalloc
.
ExplicitSystemHeapSize
/
/
/
A
size
measurement
for
an
explicit
allocation
not
on
the
heap
e
.
g
.
via
mmap
(
)
.
ExplicitNonHeapSize
/
/
/
A
size
measurement
for
an
explicit
allocation
whose
location
is
unknown
or
uncertain
.
ExplicitUnknownLocationSize
/
/
/
A
size
measurement
for
a
non
-
explicit
allocation
.
This
kind
is
used
for
global
/
/
/
measurements
such
as
"
resident
"
and
"
vsize
"
and
also
for
measurements
that
cross
-
cut
the
/
/
/
measurements
grouped
under
"
explicit
"
e
.
g
.
by
grouping
those
measurements
in
a
way
that
'
s
/
/
/
different
to
how
they
are
grouped
under
"
explicit
"
.
NonExplicitSize
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
Report
{
pub
path
:
Vec
<
String
>
pub
kind
:
ReportKind
pub
size
:
usize
}
#
[
derive
(
Clone
Deserialize
Serialize
)
]
pub
struct
ReportsChan
(
pub
IpcSender
<
Vec
<
Report
>
>
)
;
impl
ReportsChan
{
pub
fn
send
(
&
self
report
:
Vec
<
Report
>
)
{
self
.
0
.
send
(
report
)
.
unwrap
(
)
;
}
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
ReporterRequest
{
pub
reports_channel
:
ReportsChan
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
struct
Reporter
(
pub
IpcSender
<
ReporterRequest
>
)
;
impl
Reporter
{
pub
fn
collect_reports
(
&
self
reports_chan
:
ReportsChan
)
{
self
.
0
.
send
(
ReporterRequest
{
reports_channel
:
reports_chan
}
)
.
unwrap
(
)
}
}
#
[
macro_export
]
macro_rules
!
path
{
(
(
x
:
expr
)
*
)
=
>
{
{
use
std
:
:
borrow
:
:
ToOwned
;
vec
!
[
(
x
.
to_owned
(
)
)
*
]
}
}
}
#
[
derive
(
Deserialize
Serialize
)
]
pub
enum
ProfilerMsg
{
RegisterReporter
(
String
Reporter
)
UnregisterReporter
(
String
)
Print
Exit
}
