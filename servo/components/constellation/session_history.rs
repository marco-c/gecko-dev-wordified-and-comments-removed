use
msg
:
:
constellation_msg
:
:
{
BrowsingContextId
PipelineId
TopLevelBrowsingContextId
}
;
use
script_traits
:
:
LoadData
;
use
std
:
:
{
fmt
mem
}
;
use
std
:
:
cmp
:
:
PartialEq
;
#
[
derive
(
Debug
)
]
pub
struct
JointSessionHistory
{
pub
past
:
Vec
<
SessionHistoryDiff
>
pub
future
:
Vec
<
SessionHistoryDiff
>
}
impl
JointSessionHistory
{
pub
fn
new
(
)
-
>
JointSessionHistory
{
JointSessionHistory
{
past
:
Vec
:
:
new
(
)
future
:
Vec
:
:
new
(
)
}
}
pub
fn
history_length
(
&
self
)
-
>
usize
{
self
.
past
.
len
(
)
+
1
+
self
.
future
.
len
(
)
}
pub
fn
push_diff
(
&
mut
self
diff
:
SessionHistoryDiff
)
-
>
Vec
<
SessionHistoryDiff
>
{
self
.
past
.
push
(
diff
)
;
mem
:
:
replace
(
&
mut
self
.
future
vec
!
[
]
)
}
pub
fn
replace
(
&
mut
self
old_reloader
:
NeedsToReload
new_reloader
:
NeedsToReload
)
{
for
diff
in
self
.
past
.
iter_mut
(
)
.
chain
(
self
.
future
.
iter_mut
(
)
)
{
diff
.
replace
(
&
old_reloader
&
new_reloader
)
;
}
}
}
pub
struct
SessionHistoryChange
{
pub
browsing_context_id
:
BrowsingContextId
pub
top_level_browsing_context_id
:
TopLevelBrowsingContextId
pub
new_pipeline_id
:
PipelineId
pub
replace
:
Option
<
NeedsToReload
>
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
NeedsToReload
{
No
(
PipelineId
)
Yes
(
PipelineId
LoadData
)
}
impl
fmt
:
:
Display
for
NeedsToReload
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
NeedsToReload
:
:
No
(
pipeline_id
)
=
>
write
!
(
fmt
"
Alive
(
{
}
)
"
pipeline_id
)
NeedsToReload
:
:
Yes
(
pipeline_id
.
.
)
=
>
write
!
(
fmt
"
Dead
(
{
}
)
"
pipeline_id
)
}
}
}
impl
NeedsToReload
{
pub
fn
alive_pipeline_id
(
&
self
)
-
>
Option
<
PipelineId
>
{
match
*
self
{
NeedsToReload
:
:
No
(
pipeline_id
)
=
>
Some
(
pipeline_id
)
NeedsToReload
:
:
Yes
(
.
.
)
=
>
None
}
}
}
impl
PartialEq
for
NeedsToReload
{
fn
eq
(
&
self
other
:
&
NeedsToReload
)
-
>
bool
{
match
*
self
{
NeedsToReload
:
:
No
(
pipeline_id
)
=
>
{
match
*
other
{
NeedsToReload
:
:
No
(
other_pipeline_id
)
=
>
pipeline_id
=
=
other_pipeline_id
_
=
>
false
}
}
NeedsToReload
:
:
Yes
(
pipeline_id
_
)
=
>
{
match
*
other
{
NeedsToReload
:
:
Yes
(
other_pipeline_id
_
)
=
>
pipeline_id
=
=
other_pipeline_id
_
=
>
false
}
}
}
}
}
#
[
derive
(
Debug
)
]
pub
enum
SessionHistoryDiff
{
BrowsingContextDiff
{
browsing_context_id
:
BrowsingContextId
old_reloader
:
NeedsToReload
new_reloader
:
NeedsToReload
}
}
impl
SessionHistoryDiff
{
pub
fn
alive_old_pipeline
(
&
self
)
-
>
Option
<
PipelineId
>
{
match
*
self
{
SessionHistoryDiff
:
:
BrowsingContextDiff
{
ref
old_reloader
.
.
}
=
>
{
match
*
old_reloader
{
NeedsToReload
:
:
No
(
pipeline_id
)
=
>
Some
(
pipeline_id
)
NeedsToReload
:
:
Yes
(
.
.
)
=
>
None
}
}
}
}
pub
fn
alive_new_pipeline
(
&
self
)
-
>
Option
<
PipelineId
>
{
match
*
self
{
SessionHistoryDiff
:
:
BrowsingContextDiff
{
ref
new_reloader
.
.
}
=
>
{
match
*
new_reloader
{
NeedsToReload
:
:
No
(
pipeline_id
)
=
>
Some
(
pipeline_id
)
NeedsToReload
:
:
Yes
(
.
.
)
=
>
None
}
}
}
}
pub
fn
replace
(
&
mut
self
replaced_reloader
:
&
NeedsToReload
reloader
:
&
NeedsToReload
)
{
match
*
self
{
SessionHistoryDiff
:
:
BrowsingContextDiff
{
ref
mut
old_reloader
ref
mut
new_reloader
.
.
}
=
>
{
if
*
old_reloader
=
=
*
replaced_reloader
{
*
old_reloader
=
reloader
.
clone
(
)
;
}
if
*
new_reloader
=
=
*
replaced_reloader
{
*
new_reloader
=
reloader
.
clone
(
)
;
}
}
}
}
}
