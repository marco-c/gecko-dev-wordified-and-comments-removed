use
msg
:
:
constellation_msg
:
:
{
FrameId
PipelineId
}
;
use
pipeline
:
:
Pipeline
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
iter
:
:
once
;
use
std
:
:
mem
:
:
replace
;
use
std
:
:
time
:
:
Instant
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
Frame
{
pub
id
:
FrameId
pub
prev
:
Vec
<
FrameState
>
pub
current
:
FrameState
pub
next
:
Vec
<
FrameState
>
}
impl
Frame
{
pub
fn
new
(
id
:
FrameId
pipeline_id
:
PipelineId
)
-
>
Frame
{
Frame
{
id
:
id
prev
:
vec
!
(
)
current
:
FrameState
:
:
new
(
pipeline_id
id
)
next
:
vec
!
(
)
}
}
pub
fn
load
(
&
mut
self
pipeline_id
:
PipelineId
)
{
self
.
prev
.
push
(
self
.
current
.
clone
(
)
)
;
self
.
current
=
FrameState
:
:
new
(
pipeline_id
self
.
id
)
;
}
pub
fn
remove_forward_entries
(
&
mut
self
)
-
>
Vec
<
FrameState
>
{
replace
(
&
mut
self
.
next
vec
!
(
)
)
}
pub
fn
replace_current
(
&
mut
self
pipeline_id
:
PipelineId
)
-
>
FrameState
{
replace
(
&
mut
self
.
current
FrameState
:
:
new
(
pipeline_id
self
.
id
)
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
FrameState
{
pub
instant
:
Instant
pub
pipeline_id
:
PipelineId
pub
frame_id
:
FrameId
}
impl
FrameState
{
fn
new
(
pipeline_id
:
PipelineId
frame_id
:
FrameId
)
-
>
FrameState
{
FrameState
{
instant
:
Instant
:
:
now
(
)
pipeline_id
:
pipeline_id
frame_id
:
frame_id
}
}
}
pub
struct
FrameChange
{
pub
frame_id
:
FrameId
pub
old_pipeline_id
:
Option
<
PipelineId
>
pub
new_pipeline_id
:
PipelineId
pub
replace
:
bool
}
pub
struct
FrameTreeIterator
<
'
a
>
{
pub
stack
:
Vec
<
FrameId
>
pub
frames
:
&
'
a
HashMap
<
FrameId
Frame
>
pub
pipelines
:
&
'
a
HashMap
<
PipelineId
Pipeline
>
}
impl
<
'
a
>
Iterator
for
FrameTreeIterator
<
'
a
>
{
type
Item
=
&
'
a
Frame
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
Frame
>
{
loop
{
let
frame_id
=
match
self
.
stack
.
pop
(
)
{
Some
(
frame_id
)
=
>
frame_id
None
=
>
return
None
}
;
let
frame
=
match
self
.
frames
.
get
(
&
frame_id
)
{
Some
(
frame
)
=
>
frame
None
=
>
{
warn
!
(
"
Frame
{
:
?
}
iterated
after
closure
.
"
frame_id
)
;
continue
;
}
}
;
let
pipeline
=
match
self
.
pipelines
.
get
(
&
frame
.
current
.
pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
None
=
>
{
warn
!
(
"
Pipeline
{
:
?
}
iterated
after
closure
.
"
frame
.
current
.
pipeline_id
)
;
continue
;
}
}
;
self
.
stack
.
extend
(
pipeline
.
children
.
iter
(
)
.
map
(
|
&
c
|
c
)
)
;
return
Some
(
frame
)
}
}
}
pub
struct
FullFrameTreeIterator
<
'
a
>
{
pub
stack
:
Vec
<
FrameId
>
pub
frames
:
&
'
a
HashMap
<
FrameId
Frame
>
pub
pipelines
:
&
'
a
HashMap
<
PipelineId
Pipeline
>
}
impl
<
'
a
>
Iterator
for
FullFrameTreeIterator
<
'
a
>
{
type
Item
=
&
'
a
Frame
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
Frame
>
{
loop
{
let
frame_id
=
match
self
.
stack
.
pop
(
)
{
Some
(
frame_id
)
=
>
frame_id
None
=
>
return
None
}
;
let
frame
=
match
self
.
frames
.
get
(
&
frame_id
)
{
Some
(
frame
)
=
>
frame
None
=
>
{
warn
!
(
"
Frame
{
:
?
}
iterated
after
closure
.
"
frame_id
)
;
continue
;
}
}
;
for
entry
in
frame
.
prev
.
iter
(
)
.
chain
(
frame
.
next
.
iter
(
)
)
.
chain
(
once
(
&
frame
.
current
)
)
{
if
let
Some
(
pipeline
)
=
self
.
pipelines
.
get
(
&
entry
.
pipeline_id
)
{
self
.
stack
.
extend
(
pipeline
.
children
.
iter
(
)
.
map
(
|
&
c
|
c
)
)
;
}
}
return
Some
(
frame
)
}
}
}
