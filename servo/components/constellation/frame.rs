use
msg
:
:
constellation_msg
:
:
{
FrameId
PipelineId
}
;
use
pipeline
:
:
Pipeline
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
iter
:
:
once
;
use
std
:
:
mem
:
:
replace
;
use
std
:
:
time
:
:
Instant
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
Frame
{
pub
id
:
FrameId
pub
instant
:
Instant
pub
pipeline_id
:
PipelineId
pub
url
:
ServoUrl
pub
prev
:
Vec
<
FrameState
>
pub
next
:
Vec
<
FrameState
>
}
impl
Frame
{
pub
fn
new
(
id
:
FrameId
pipeline_id
:
PipelineId
url
:
ServoUrl
)
-
>
Frame
{
Frame
{
id
:
id
pipeline_id
:
pipeline_id
instant
:
Instant
:
:
now
(
)
url
:
url
prev
:
vec
!
(
)
next
:
vec
!
(
)
}
}
pub
fn
current
(
&
self
)
-
>
FrameState
{
FrameState
{
instant
:
self
.
instant
frame_id
:
self
.
id
pipeline_id
:
Some
(
self
.
pipeline_id
)
url
:
self
.
url
.
clone
(
)
}
}
pub
fn
load
(
&
mut
self
pipeline_id
:
PipelineId
url
:
ServoUrl
)
{
let
current
=
self
.
current
(
)
;
self
.
prev
.
push
(
current
)
;
self
.
instant
=
Instant
:
:
now
(
)
;
self
.
pipeline_id
=
pipeline_id
;
self
.
url
=
url
;
}
pub
fn
remove_forward_entries
(
&
mut
self
)
-
>
Vec
<
FrameState
>
{
replace
(
&
mut
self
.
next
vec
!
(
)
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
FrameState
{
pub
instant
:
Instant
pub
pipeline_id
:
Option
<
PipelineId
>
pub
url
:
ServoUrl
pub
frame_id
:
FrameId
}
pub
struct
FrameChange
{
pub
frame_id
:
FrameId
pub
old_pipeline_id
:
Option
<
PipelineId
>
pub
new_pipeline_id
:
PipelineId
pub
url
:
ServoUrl
pub
replace
:
Option
<
FrameState
>
}
pub
struct
FrameTreeIterator
<
'
a
>
{
pub
stack
:
Vec
<
FrameId
>
pub
frames
:
&
'
a
HashMap
<
FrameId
Frame
>
pub
pipelines
:
&
'
a
HashMap
<
PipelineId
Pipeline
>
}
impl
<
'
a
>
Iterator
for
FrameTreeIterator
<
'
a
>
{
type
Item
=
&
'
a
Frame
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
Frame
>
{
loop
{
let
frame_id
=
match
self
.
stack
.
pop
(
)
{
Some
(
frame_id
)
=
>
frame_id
None
=
>
return
None
}
;
let
frame
=
match
self
.
frames
.
get
(
&
frame_id
)
{
Some
(
frame
)
=
>
frame
None
=
>
{
warn
!
(
"
Frame
{
:
?
}
iterated
after
closure
.
"
frame_id
)
;
continue
;
}
}
;
let
pipeline
=
match
self
.
pipelines
.
get
(
&
frame
.
pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
None
=
>
{
warn
!
(
"
Pipeline
{
:
?
}
iterated
after
closure
.
"
frame
.
pipeline_id
)
;
continue
;
}
}
;
self
.
stack
.
extend
(
pipeline
.
children
.
iter
(
)
)
;
return
Some
(
frame
)
}
}
}
pub
struct
FullFrameTreeIterator
<
'
a
>
{
pub
stack
:
Vec
<
FrameId
>
pub
frames
:
&
'
a
HashMap
<
FrameId
Frame
>
pub
pipelines
:
&
'
a
HashMap
<
PipelineId
Pipeline
>
}
impl
<
'
a
>
Iterator
for
FullFrameTreeIterator
<
'
a
>
{
type
Item
=
&
'
a
Frame
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
Frame
>
{
let
pipelines
=
self
.
pipelines
;
loop
{
let
frame_id
=
match
self
.
stack
.
pop
(
)
{
Some
(
frame_id
)
=
>
frame_id
None
=
>
return
None
}
;
let
frame
=
match
self
.
frames
.
get
(
&
frame_id
)
{
Some
(
frame
)
=
>
frame
None
=
>
{
warn
!
(
"
Frame
{
:
?
}
iterated
after
closure
.
"
frame_id
)
;
continue
;
}
}
;
let
child_frame_ids
=
frame
.
prev
.
iter
(
)
.
chain
(
frame
.
next
.
iter
(
)
)
.
filter_map
(
|
entry
|
entry
.
pipeline_id
)
.
chain
(
once
(
frame
.
pipeline_id
)
)
.
filter_map
(
|
pipeline_id
|
pipelines
.
get
(
&
pipeline_id
)
)
.
flat_map
(
|
pipeline
|
pipeline
.
children
.
iter
(
)
)
;
self
.
stack
.
extend
(
child_frame_ids
)
;
return
Some
(
frame
)
}
}
}
