use
canvas
:
:
canvas_paint_thread
:
:
CanvasPaintThread
;
use
canvas
:
:
webgl_paint_thread
:
:
WebGLPaintThread
;
use
canvas_traits
:
:
CanvasMsg
;
use
clipboard
:
:
ClipboardContext
;
use
compositing
:
:
SendableFrameTree
;
use
compositing
:
:
compositor_thread
:
:
CompositorProxy
;
use
compositing
:
:
compositor_thread
:
:
Msg
as
ToCompositorMsg
;
use
devtools_traits
:
:
{
ChromeToDevtoolsControlMsg
DevtoolsControlMsg
}
;
use
euclid
:
:
scale_factor
:
:
ScaleFactor
;
use
euclid
:
:
size
:
:
{
Size2D
TypedSize2D
}
;
use
gfx
:
:
font_cache_thread
:
:
FontCacheThread
;
use
gfx_traits
:
:
Epoch
;
use
ipc_channel
:
:
ipc
:
:
{
self
IpcSender
}
;
use
ipc_channel
:
:
router
:
:
ROUTER
;
use
layout_traits
:
:
LayoutThreadFactory
;
use
msg
:
:
constellation_msg
:
:
WebDriverCommandMsg
;
use
msg
:
:
constellation_msg
:
:
{
FrameId
FrameType
PipelineId
}
;
use
msg
:
:
constellation_msg
:
:
{
Key
KeyModifiers
KeyState
LoadData
}
;
use
msg
:
:
constellation_msg
:
:
{
PipelineNamespace
PipelineNamespaceId
NavigationDirection
}
;
use
msg
:
:
constellation_msg
:
:
{
SubpageId
WindowSizeData
WindowSizeType
}
;
use
msg
:
:
constellation_msg
:
:
{
self
PanicMsg
}
;
use
msg
:
:
webdriver_msg
;
use
net_traits
:
:
bluetooth_thread
:
:
BluetoothMethodMsg
;
use
net_traits
:
:
filemanager_thread
:
:
FileManagerThreadMsg
;
use
net_traits
:
:
image_cache_thread
:
:
ImageCacheThread
;
use
net_traits
:
:
storage_thread
:
:
StorageThreadMsg
;
use
net_traits
:
:
{
self
ResourceThreads
IpcSend
}
;
use
offscreen_gl_context
:
:
{
GLContextAttributes
GLLimits
}
;
use
pipeline
:
:
{
ChildProcess
InitialPipelineState
Pipeline
}
;
use
profile_traits
:
:
mem
;
use
profile_traits
:
:
time
;
use
rand
:
:
{
random
Rng
SeedableRng
StdRng
}
;
use
script_traits
:
:
{
AnimationState
AnimationTickType
CompositorEvent
}
;
use
script_traits
:
:
{
ConstellationControlMsg
ConstellationMsg
as
FromCompositorMsg
}
;
use
script_traits
:
:
{
DocumentState
LayoutControlMsg
}
;
use
script_traits
:
:
{
IFrameLoadInfo
IFrameSandboxState
TimerEventRequest
}
;
use
script_traits
:
:
{
LayoutMsg
as
FromLayoutMsg
ScriptMsg
as
FromScriptMsg
ScriptThreadFactory
}
;
use
script_traits
:
:
{
MozBrowserEvent
MozBrowserErrorType
}
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
io
:
:
Error
as
IOError
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
:
:
replace
;
use
std
:
:
process
;
use
std
:
:
sync
:
:
mpsc
:
:
{
Sender
channel
Receiver
}
;
use
style_traits
:
:
cursor
:
:
Cursor
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
use
timer_scheduler
:
:
TimerScheduler
;
use
url
:
:
Url
;
use
util
:
:
geometry
:
:
PagePx
;
use
util
:
:
opts
;
use
util
:
:
prefs
:
:
PREFS
;
use
util
:
:
thread
:
:
spawn_named
;
use
webrender_traits
;
#
[
derive
(
Debug
PartialEq
)
]
enum
ReadyToSave
{
NoRootFrame
PendingFrames
WebFontNotLoaded
DocumentLoading
EpochMismatch
PipelineUnknown
Ready
}
pub
struct
Constellation
<
Message
LTF
STF
>
{
script_sender
:
IpcSender
<
FromScriptMsg
>
layout_sender
:
IpcSender
<
FromLayoutMsg
>
panic_sender
:
IpcSender
<
PanicMsg
>
script_receiver
:
Receiver
<
FromScriptMsg
>
compositor_receiver
:
Receiver
<
FromCompositorMsg
>
layout_receiver
:
Receiver
<
FromLayoutMsg
>
panic_receiver
:
Receiver
<
PanicMsg
>
compositor_proxy
:
Box
<
CompositorProxy
>
public_resource_threads
:
ResourceThreads
private_resource_threads
:
ResourceThreads
image_cache_thread
:
ImageCacheThread
devtools_chan
:
Option
<
Sender
<
DevtoolsControlMsg
>
>
bluetooth_thread
:
IpcSender
<
BluetoothMethodMsg
>
pipelines
:
HashMap
<
PipelineId
Pipeline
>
frames
:
HashMap
<
FrameId
Frame
>
subpage_map
:
HashMap
<
(
PipelineId
SubpageId
)
PipelineId
>
font_cache_thread
:
FontCacheThread
root_frame_id
:
Option
<
FrameId
>
next_pipeline_namespace_id
:
PipelineNamespaceId
next_frame_id
:
FrameId
focus_pipeline_id
:
Option
<
PipelineId
>
pending_frames
:
Vec
<
FrameChange
>
time_profiler_chan
:
time
:
:
ProfilerChan
mem_profiler_chan
:
mem
:
:
ProfilerChan
phantom
:
PhantomData
<
(
Message
LTF
STF
)
>
window_size
:
WindowSizeData
clipboard_ctx
:
Option
<
ClipboardContext
>
webdriver
:
WebDriverData
scheduler_chan
:
IpcSender
<
TimerEventRequest
>
#
[
cfg_attr
(
target_os
=
"
windows
"
allow
(
dead_code
)
)
]
child_processes
:
Vec
<
ChildProcess
>
document_states
:
HashMap
<
PipelineId
DocumentState
>
webrender_api_sender
:
Option
<
webrender_traits
:
:
RenderApiSender
>
shutting_down
:
bool
handled_panic
:
bool
random_pipeline_closure
:
Option
<
(
StdRng
f32
)
>
}
pub
struct
InitialConstellationState
{
pub
compositor_proxy
:
Box
<
CompositorProxy
+
Send
>
pub
devtools_chan
:
Option
<
Sender
<
DevtoolsControlMsg
>
>
pub
bluetooth_thread
:
IpcSender
<
BluetoothMethodMsg
>
pub
image_cache_thread
:
ImageCacheThread
pub
font_cache_thread
:
FontCacheThread
pub
public_resource_threads
:
ResourceThreads
pub
private_resource_threads
:
ResourceThreads
pub
time_profiler_chan
:
time
:
:
ProfilerChan
pub
mem_profiler_chan
:
mem
:
:
ProfilerChan
pub
supports_clipboard
:
bool
pub
webrender_api_sender
:
Option
<
webrender_traits
:
:
RenderApiSender
>
}
struct
Frame
{
prev
:
Vec
<
PipelineId
>
current
:
PipelineId
next
:
Vec
<
PipelineId
>
}
impl
Frame
{
fn
new
(
pipeline_id
:
PipelineId
)
-
>
Frame
{
Frame
{
prev
:
vec
!
(
)
current
:
pipeline_id
next
:
vec
!
(
)
}
}
fn
load
(
&
mut
self
pipeline_id
:
PipelineId
)
-
>
Vec
<
PipelineId
>
{
self
.
prev
.
push
(
self
.
current
)
;
self
.
current
=
pipeline_id
;
replace
(
&
mut
self
.
next
vec
!
(
)
)
}
}
struct
FrameChange
{
old_pipeline_id
:
Option
<
PipelineId
>
new_pipeline_id
:
PipelineId
document_ready
:
bool
}
struct
FrameTreeIterator
<
'
a
>
{
stack
:
Vec
<
FrameId
>
frames
:
&
'
a
HashMap
<
FrameId
Frame
>
pipelines
:
&
'
a
HashMap
<
PipelineId
Pipeline
>
}
impl
<
'
a
>
Iterator
for
FrameTreeIterator
<
'
a
>
{
type
Item
=
&
'
a
Frame
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
Frame
>
{
loop
{
let
frame_id
=
match
self
.
stack
.
pop
(
)
{
Some
(
frame_id
)
=
>
frame_id
None
=
>
return
None
}
;
let
frame
=
match
self
.
frames
.
get
(
&
frame_id
)
{
Some
(
frame
)
=
>
frame
None
=
>
{
warn
!
(
"
Frame
{
:
?
}
iterated
after
closure
.
"
frame_id
)
;
continue
;
}
}
;
let
pipeline
=
match
self
.
pipelines
.
get
(
&
frame
.
current
)
{
Some
(
pipeline
)
=
>
pipeline
None
=
>
{
warn
!
(
"
Pipeline
{
:
?
}
iterated
after
closure
.
"
frame
.
current
)
;
continue
;
}
}
;
self
.
stack
.
extend
(
pipeline
.
children
.
iter
(
)
.
map
(
|
&
c
|
c
)
)
;
return
Some
(
frame
)
}
}
}
struct
WebDriverData
{
load_channel
:
Option
<
(
PipelineId
IpcSender
<
webdriver_msg
:
:
LoadStatus
>
)
>
resize_channel
:
Option
<
IpcSender
<
WindowSizeData
>
>
}
impl
WebDriverData
{
fn
new
(
)
-
>
WebDriverData
{
WebDriverData
{
load_channel
:
None
resize_channel
:
None
}
}
}
#
[
derive
(
Clone
Copy
)
]
enum
ExitPipelineMode
{
Normal
Force
}
impl
<
Message
LTF
STF
>
Constellation
<
Message
LTF
STF
>
where
LTF
:
LayoutThreadFactory
<
Message
=
Message
>
STF
:
ScriptThreadFactory
<
Message
=
Message
>
{
pub
fn
start
(
state
:
InitialConstellationState
)
-
>
Sender
<
FromCompositorMsg
>
{
let
(
compositor_sender
compositor_receiver
)
=
channel
(
)
;
spawn_named
(
"
Constellation
"
.
to_owned
(
)
move
|
|
{
let
(
ipc_script_sender
ipc_script_receiver
)
=
ipc
:
:
channel
(
)
.
expect
(
"
ipc
channel
failure
"
)
;
let
script_receiver
=
ROUTER
.
route_ipc_receiver_to_new_mpsc_receiver
(
ipc_script_receiver
)
;
let
(
ipc_layout_sender
ipc_layout_receiver
)
=
ipc
:
:
channel
(
)
.
expect
(
"
ipc
channel
failure
"
)
;
let
layout_receiver
=
ROUTER
.
route_ipc_receiver_to_new_mpsc_receiver
(
ipc_layout_receiver
)
;
let
(
ipc_panic_sender
ipc_panic_receiver
)
=
ipc
:
:
channel
(
)
.
expect
(
"
ipc
channel
failure
"
)
;
let
panic_receiver
=
ROUTER
.
route_ipc_receiver_to_new_mpsc_receiver
(
ipc_panic_receiver
)
;
let
mut
constellation
:
Constellation
<
Message
LTF
STF
>
=
Constellation
{
script_sender
:
ipc_script_sender
layout_sender
:
ipc_layout_sender
script_receiver
:
script_receiver
panic_sender
:
ipc_panic_sender
compositor_receiver
:
compositor_receiver
layout_receiver
:
layout_receiver
panic_receiver
:
panic_receiver
compositor_proxy
:
state
.
compositor_proxy
devtools_chan
:
state
.
devtools_chan
bluetooth_thread
:
state
.
bluetooth_thread
public_resource_threads
:
state
.
public_resource_threads
private_resource_threads
:
state
.
private_resource_threads
image_cache_thread
:
state
.
image_cache_thread
font_cache_thread
:
state
.
font_cache_thread
pipelines
:
HashMap
:
:
new
(
)
frames
:
HashMap
:
:
new
(
)
subpage_map
:
HashMap
:
:
new
(
)
pending_frames
:
vec
!
(
)
next_pipeline_namespace_id
:
PipelineNamespaceId
(
0
)
root_frame_id
:
None
next_frame_id
:
FrameId
(
0
)
focus_pipeline_id
:
None
time_profiler_chan
:
state
.
time_profiler_chan
mem_profiler_chan
:
state
.
mem_profiler_chan
window_size
:
WindowSizeData
{
visible_viewport
:
opts
:
:
get
(
)
.
initial_window_size
.
as_f32
(
)
*
ScaleFactor
:
:
new
(
1
.
0
)
initial_viewport
:
opts
:
:
get
(
)
.
initial_window_size
.
as_f32
(
)
*
ScaleFactor
:
:
new
(
1
.
0
)
device_pixel_ratio
:
ScaleFactor
:
:
new
(
opts
:
:
get
(
)
.
device_pixels_per_px
.
unwrap_or
(
1
.
0
)
)
}
phantom
:
PhantomData
clipboard_ctx
:
if
state
.
supports_clipboard
{
ClipboardContext
:
:
new
(
)
.
ok
(
)
}
else
{
None
}
webdriver
:
WebDriverData
:
:
new
(
)
scheduler_chan
:
TimerScheduler
:
:
start
(
)
child_processes
:
Vec
:
:
new
(
)
document_states
:
HashMap
:
:
new
(
)
webrender_api_sender
:
state
.
webrender_api_sender
shutting_down
:
false
handled_panic
:
false
random_pipeline_closure
:
opts
:
:
get
(
)
.
random_pipeline_closure_probability
.
map
(
|
prob
|
{
let
seed
=
opts
:
:
get
(
)
.
random_pipeline_closure_seed
.
unwrap_or_else
(
random
)
;
let
rng
=
StdRng
:
:
from_seed
(
&
[
seed
]
)
;
warn
!
(
"
Randomly
closing
pipelines
.
"
)
;
info
!
(
"
Using
seed
{
}
for
random
pipeline
closure
.
"
seed
)
;
(
rng
prob
)
}
)
}
;
let
namespace_id
=
constellation
.
next_pipeline_namespace_id
(
)
;
PipelineNamespace
:
:
install
(
namespace_id
)
;
constellation
.
run
(
)
;
}
)
;
compositor_sender
}
fn
run
(
&
mut
self
)
{
while
!
self
.
shutting_down
|
|
!
self
.
pipelines
.
is_empty
(
)
{
self
.
maybe_close_random_pipeline
(
)
;
self
.
handle_request
(
)
;
}
self
.
handle_shutdown
(
)
;
}
fn
next_pipeline_namespace_id
(
&
mut
self
)
-
>
PipelineNamespaceId
{
let
namespace_id
=
self
.
next_pipeline_namespace_id
;
let
PipelineNamespaceId
(
ref
mut
i
)
=
self
.
next_pipeline_namespace_id
;
*
i
+
=
1
;
namespace_id
}
fn
new_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
parent_info
:
Option
<
(
PipelineId
SubpageId
FrameType
)
>
initial_window_size
:
Option
<
TypedSize2D
<
PagePx
f32
>
>
script_channel
:
Option
<
IpcSender
<
ConstellationControlMsg
>
>
load_data
:
LoadData
is_private
:
bool
)
{
if
self
.
shutting_down
{
return
;
}
let
resource_threads
=
if
is_private
{
self
.
private_resource_threads
.
clone
(
)
}
else
{
self
.
public_resource_threads
.
clone
(
)
}
;
let
parent_visibility
=
if
let
Some
(
(
parent_pipeline_id
_
_
)
)
=
parent_info
{
self
.
pipelines
.
get
(
&
parent_pipeline_id
)
.
map
(
|
pipeline
|
pipeline
.
visible
)
}
else
{
None
}
;
let
result
=
Pipeline
:
:
spawn
:
:
<
Message
LTF
STF
>
(
InitialPipelineState
{
id
:
pipeline_id
parent_info
:
parent_info
constellation_chan
:
self
.
script_sender
.
clone
(
)
layout_to_constellation_chan
:
self
.
layout_sender
.
clone
(
)
panic_chan
:
self
.
panic_sender
.
clone
(
)
scheduler_chan
:
self
.
scheduler_chan
.
clone
(
)
compositor_proxy
:
self
.
compositor_proxy
.
clone_compositor_proxy
(
)
devtools_chan
:
self
.
devtools_chan
.
clone
(
)
bluetooth_thread
:
self
.
bluetooth_thread
.
clone
(
)
image_cache_thread
:
self
.
image_cache_thread
.
clone
(
)
font_cache_thread
:
self
.
font_cache_thread
.
clone
(
)
resource_threads
:
resource_threads
time_profiler_chan
:
self
.
time_profiler_chan
.
clone
(
)
mem_profiler_chan
:
self
.
mem_profiler_chan
.
clone
(
)
window_size
:
initial_window_size
script_chan
:
script_channel
load_data
:
load_data
device_pixel_ratio
:
self
.
window_size
.
device_pixel_ratio
pipeline_namespace_id
:
self
.
next_pipeline_namespace_id
(
)
parent_visibility
:
parent_visibility
webrender_api_sender
:
self
.
webrender_api_sender
.
clone
(
)
is_private
:
is_private
}
)
;
let
(
pipeline
child_process
)
=
match
result
{
Ok
(
result
)
=
>
result
Err
(
e
)
=
>
return
self
.
handle_send_error
(
pipeline_id
e
)
}
;
if
let
Some
(
child_process
)
=
child_process
{
self
.
child_processes
.
push
(
child_process
)
;
}
assert
!
(
!
self
.
pipelines
.
contains_key
(
&
pipeline_id
)
)
;
self
.
pipelines
.
insert
(
pipeline_id
pipeline
)
;
}
fn
push_pending_frame
(
&
mut
self
new_pipeline_id
:
PipelineId
old_pipeline_id
:
Option
<
PipelineId
>
)
{
self
.
pending_frames
.
push
(
FrameChange
{
old_pipeline_id
:
old_pipeline_id
new_pipeline_id
:
new_pipeline_id
document_ready
:
false
}
)
;
}
fn
current_frame_tree_iter
(
&
self
frame_id_root
:
Option
<
FrameId
>
)
-
>
FrameTreeIterator
{
FrameTreeIterator
{
stack
:
frame_id_root
.
into_iter
(
)
.
collect
(
)
pipelines
:
&
self
.
pipelines
frames
:
&
self
.
frames
}
}
fn
new_frame
(
&
mut
self
pipeline_id
:
PipelineId
)
-
>
FrameId
{
let
id
=
self
.
next_frame_id
;
let
FrameId
(
ref
mut
i
)
=
self
.
next_frame_id
;
*
i
+
=
1
;
let
frame
=
Frame
:
:
new
(
pipeline_id
)
;
assert
!
(
self
.
pipelines
.
get
(
&
pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
frame
)
.
is_none
(
)
)
;
assert
!
(
!
self
.
frames
.
contains_key
(
&
id
)
)
;
self
.
pipelines
.
get_mut
(
&
pipeline_id
)
.
map
(
|
pipeline
|
pipeline
.
frame
=
Some
(
id
)
)
;
self
.
frames
.
insert
(
id
frame
)
;
id
}
#
[
allow
(
unsafe_code
)
]
fn
handle_request
(
&
mut
self
)
{
enum
Request
{
Script
(
FromScriptMsg
)
Compositor
(
FromCompositorMsg
)
Layout
(
FromLayoutMsg
)
Panic
(
PanicMsg
)
}
let
request
=
{
let
receiver_from_script
=
&
self
.
script_receiver
;
let
receiver_from_compositor
=
&
self
.
compositor_receiver
;
let
receiver_from_layout
=
&
self
.
layout_receiver
;
let
receiver_from_panic
=
&
self
.
panic_receiver
;
select
!
{
msg
=
receiver_from_script
.
recv
(
)
=
>
Request
:
:
Script
(
msg
.
expect
(
"
Unexpected
script
channel
panic
in
constellation
"
)
)
msg
=
receiver_from_compositor
.
recv
(
)
=
>
Request
:
:
Compositor
(
msg
.
expect
(
"
Unexpected
compositor
channel
panic
in
constellation
"
)
)
msg
=
receiver_from_layout
.
recv
(
)
=
>
Request
:
:
Layout
(
msg
.
expect
(
"
Unexpected
layout
channel
panic
in
constellation
"
)
)
msg
=
receiver_from_panic
.
recv
(
)
=
>
Request
:
:
Panic
(
msg
.
expect
(
"
Unexpected
panic
channel
panic
in
constellation
"
)
)
}
}
;
match
request
{
Request
:
:
Compositor
(
message
)
=
>
{
self
.
handle_request_from_compositor
(
message
)
}
Request
:
:
Script
(
message
)
=
>
{
self
.
handle_request_from_script
(
message
)
;
}
Request
:
:
Layout
(
message
)
=
>
{
self
.
handle_request_from_layout
(
message
)
;
}
Request
:
:
Panic
(
message
)
=
>
{
self
.
handle_request_from_panic
(
message
)
;
}
}
}
fn
handle_request_from_compositor
(
&
mut
self
message
:
FromCompositorMsg
)
{
match
message
{
FromCompositorMsg
:
:
Exit
=
>
{
debug
!
(
"
constellation
exiting
"
)
;
self
.
handle_exit
(
)
;
}
FromCompositorMsg
:
:
FrameSize
(
pipeline_id
size
)
=
>
{
debug
!
(
"
constellation
got
frame
size
message
"
)
;
self
.
handle_frame_size_msg
(
pipeline_id
&
Size2D
:
:
from_untyped
(
&
size
)
)
;
}
FromCompositorMsg
:
:
GetFrame
(
pipeline_id
resp_chan
)
=
>
{
debug
!
(
"
constellation
got
get
root
pipeline
message
"
)
;
self
.
handle_get_frame
(
pipeline_id
resp_chan
)
;
}
FromCompositorMsg
:
:
GetPipeline
(
frame_id
resp_chan
)
=
>
{
debug
!
(
"
constellation
got
get
root
pipeline
message
"
)
;
self
.
handle_get_pipeline
(
frame_id
resp_chan
)
;
}
FromCompositorMsg
:
:
GetPipelineTitle
(
pipeline_id
)
=
>
{
debug
!
(
"
constellation
got
get
-
pipeline
-
title
message
"
)
;
self
.
handle_get_pipeline_title_msg
(
pipeline_id
)
;
}
FromCompositorMsg
:
:
KeyEvent
(
key
state
modifiers
)
=
>
{
debug
!
(
"
constellation
got
key
event
message
"
)
;
self
.
handle_key_msg
(
key
state
modifiers
)
;
}
FromCompositorMsg
:
:
LoadUrl
(
source_id
load_data
)
=
>
{
debug
!
(
"
constellation
got
URL
load
message
from
compositor
"
)
;
self
.
handle_load_url_msg
(
source_id
load_data
)
;
}
FromCompositorMsg
:
:
IsReadyToSaveImage
(
pipeline_states
)
=
>
{
let
is_ready
=
self
.
handle_is_ready_to_save_image
(
pipeline_states
)
;
if
opts
:
:
get
(
)
.
is_running_problem_test
{
println
!
(
"
got
ready
to
save
image
query
result
is
{
:
?
}
"
is_ready
)
;
}
let
is_ready
=
is_ready
=
=
ReadyToSave
:
:
Ready
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
IsReadyToSaveImageReply
(
is_ready
)
)
;
if
opts
:
:
get
(
)
.
is_running_problem_test
{
println
!
(
"
sent
response
"
)
;
}
}
FromCompositorMsg
:
:
InitLoadUrl
(
url
)
=
>
{
debug
!
(
"
constellation
got
init
load
URL
message
"
)
;
self
.
handle_init_load
(
url
)
;
}
FromCompositorMsg
:
:
Navigate
(
pipeline_info
direction
)
=
>
{
debug
!
(
"
constellation
got
navigation
message
from
compositor
"
)
;
self
.
handle_navigate_msg
(
pipeline_info
direction
)
;
}
FromCompositorMsg
:
:
WindowSize
(
new_size
size_type
)
=
>
{
debug
!
(
"
constellation
got
window
resize
message
"
)
;
self
.
handle_window_size_msg
(
new_size
size_type
)
;
}
FromCompositorMsg
:
:
TickAnimation
(
pipeline_id
tick_type
)
=
>
{
self
.
handle_tick_animation
(
pipeline_id
tick_type
)
}
FromCompositorMsg
:
:
WebDriverCommand
(
command
)
=
>
{
debug
!
(
"
constellation
got
webdriver
command
message
"
)
;
self
.
handle_webdriver_msg
(
command
)
;
}
FromCompositorMsg
:
:
Reload
=
>
{
debug
!
(
"
constellation
got
reload
message
"
)
;
self
.
handle_reload_msg
(
)
;
}
}
}
fn
handle_request_from_script
(
&
mut
self
message
:
FromScriptMsg
)
{
match
message
{
FromScriptMsg
:
:
PipelineExited
(
pipeline_id
)
=
>
{
self
.
handle_pipeline_exited
(
pipeline_id
)
;
}
FromScriptMsg
:
:
ScriptLoadedURLInIFrame
(
load_info
)
=
>
{
debug
!
(
"
constellation
got
iframe
URL
load
message
{
:
?
}
{
:
?
}
{
:
?
}
"
load_info
.
containing_pipeline_id
load_info
.
old_subpage_id
load_info
.
new_subpage_id
)
;
self
.
handle_script_loaded_url_in_iframe_msg
(
load_info
)
;
}
FromScriptMsg
:
:
ChangeRunningAnimationsState
(
pipeline_id
animation_state
)
=
>
{
self
.
handle_change_running_animations_state
(
pipeline_id
animation_state
)
}
FromScriptMsg
:
:
LoadUrl
(
source_id
load_data
)
=
>
{
debug
!
(
"
constellation
got
URL
load
message
from
script
"
)
;
self
.
handle_load_url_msg
(
source_id
load_data
)
;
}
FromScriptMsg
:
:
LoadComplete
(
pipeline_id
)
=
>
{
debug
!
(
"
constellation
got
load
complete
message
"
)
;
self
.
handle_load_complete_msg
(
&
pipeline_id
)
}
FromScriptMsg
:
:
DOMLoad
(
pipeline_id
)
=
>
{
debug
!
(
"
constellation
got
dom
load
message
"
)
;
self
.
handle_dom_load
(
pipeline_id
)
}
FromScriptMsg
:
:
Navigate
(
pipeline_info
direction
)
=
>
{
debug
!
(
"
constellation
got
navigation
message
from
script
"
)
;
self
.
handle_navigate_msg
(
pipeline_info
direction
)
;
}
FromScriptMsg
:
:
ActivateDocument
(
pipeline_id
)
=
>
{
debug
!
(
"
constellation
got
activate
document
message
"
)
;
self
.
handle_activate_document_msg
(
pipeline_id
)
;
}
FromScriptMsg
:
:
SetFinalUrl
(
pipeline_id
final_url
)
=
>
{
if
let
Some
(
ref
mut
pipeline
)
=
self
.
pipelines
.
get_mut
(
&
pipeline_id
)
{
debug
!
(
"
constellation
got
set
final
url
message
"
)
;
pipeline
.
url
=
final_url
;
}
else
{
warn
!
(
"
constellation
got
set
final
url
message
for
dead
pipeline
"
)
;
}
}
FromScriptMsg
:
:
MozBrowserEvent
(
pipeline_id
subpage_id
event
)
=
>
{
debug
!
(
"
constellation
got
mozbrowser
event
message
"
)
;
self
.
handle_mozbrowser_event_msg
(
pipeline_id
subpage_id
event
)
;
}
FromScriptMsg
:
:
Focus
(
pipeline_id
)
=
>
{
debug
!
(
"
constellation
got
focus
message
"
)
;
self
.
handle_focus_msg
(
pipeline_id
)
;
}
FromScriptMsg
:
:
ForwardMouseButtonEvent
(
pipeline_id
event_type
button
point
)
=
>
{
let
event
=
CompositorEvent
:
:
MouseButtonEvent
(
event_type
button
point
)
;
let
msg
=
ConstellationControlMsg
:
:
SendEvent
(
pipeline_id
event
)
;
let
result
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
None
=
>
{
debug
!
(
"
Pipeline
{
:
?
}
got
mouse
button
event
after
closure
.
"
pipeline_id
)
;
return
;
}
Some
(
pipeline
)
=
>
pipeline
.
script_chan
.
send
(
msg
)
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
pipeline_id
e
)
;
}
}
FromScriptMsg
:
:
ForwardMouseMoveEvent
(
pipeline_id
point
)
=
>
{
let
event
=
CompositorEvent
:
:
MouseMoveEvent
(
Some
(
point
)
)
;
let
msg
=
ConstellationControlMsg
:
:
SendEvent
(
pipeline_id
event
)
;
let
result
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
None
=
>
{
debug
!
(
"
Pipeline
{
:
?
}
got
mouse
move
event
after
closure
.
"
pipeline_id
)
;
return
;
}
Some
(
pipeline
)
=
>
pipeline
.
script_chan
.
send
(
msg
)
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
pipeline_id
e
)
;
}
}
FromScriptMsg
:
:
GetClipboardContents
(
sender
)
=
>
{
let
result
=
match
self
.
clipboard_ctx
{
Some
(
ref
ctx
)
=
>
match
ctx
.
get_contents
(
)
{
Ok
(
result
)
=
>
result
Err
(
e
)
=
>
{
warn
!
(
"
Error
getting
clipboard
contents
(
{
}
)
defaulting
to
empty
string
"
e
)
;
"
"
.
to_owned
(
)
}
}
None
=
>
"
"
.
to_owned
(
)
}
;
if
let
Err
(
e
)
=
sender
.
send
(
result
)
{
warn
!
(
"
Failed
to
send
clipboard
(
{
}
)
"
e
)
;
}
}
FromScriptMsg
:
:
SetClipboardContents
(
s
)
=
>
{
if
let
Some
(
ref
mut
ctx
)
=
self
.
clipboard_ctx
{
if
let
Err
(
e
)
=
ctx
.
set_contents
(
s
)
{
warn
!
(
"
Error
setting
clipboard
contents
(
{
}
)
"
e
)
;
}
}
}
FromScriptMsg
:
:
SetVisible
(
pipeline_id
visible
)
=
>
{
debug
!
(
"
constellation
got
set
visible
messsage
"
)
;
self
.
handle_set_visible_msg
(
pipeline_id
visible
)
;
}
FromScriptMsg
:
:
VisibilityChangeComplete
(
pipeline_id
visible
)
=
>
{
debug
!
(
"
constellation
got
set
visibility
change
complete
message
"
)
;
self
.
handle_visibility_change_complete
(
pipeline_id
visible
)
;
}
FromScriptMsg
:
:
RemoveIFrame
(
pipeline_id
sender
)
=
>
{
debug
!
(
"
constellation
got
remove
iframe
message
"
)
;
self
.
handle_remove_iframe_msg
(
pipeline_id
)
;
if
let
Some
(
sender
)
=
sender
{
if
let
Err
(
e
)
=
sender
.
send
(
(
)
)
{
warn
!
(
"
Error
replying
to
remove
iframe
(
{
}
)
"
e
)
;
}
}
}
FromScriptMsg
:
:
NewFavicon
(
url
)
=
>
{
debug
!
(
"
constellation
got
new
favicon
message
"
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
NewFavicon
(
url
)
)
;
}
FromScriptMsg
:
:
HeadParsed
=
>
{
debug
!
(
"
constellation
got
head
parsed
message
"
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
HeadParsed
)
;
}
FromScriptMsg
:
:
CreateCanvasPaintThread
(
size
sender
)
=
>
{
debug
!
(
"
constellation
got
create
-
canvas
-
paint
-
thread
message
"
)
;
self
.
handle_create_canvas_paint_thread_msg
(
&
size
sender
)
}
FromScriptMsg
:
:
CreateWebGLPaintThread
(
size
attributes
sender
)
=
>
{
debug
!
(
"
constellation
got
create
-
WebGL
-
paint
-
thread
message
"
)
;
self
.
handle_create_webgl_paint_thread_msg
(
&
size
attributes
sender
)
}
FromScriptMsg
:
:
NodeStatus
(
message
)
=
>
{
debug
!
(
"
constellation
got
NodeStatus
message
"
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
Status
(
message
)
)
;
}
FromScriptMsg
:
:
SetDocumentState
(
pipeline_id
state
)
=
>
{
debug
!
(
"
constellation
got
SetDocumentState
message
"
)
;
self
.
document_states
.
insert
(
pipeline_id
state
)
;
}
FromScriptMsg
:
:
Alert
(
pipeline_id
message
sender
)
=
>
{
debug
!
(
"
constellation
got
Alert
message
"
)
;
self
.
handle_alert
(
pipeline_id
message
sender
)
;
}
FromScriptMsg
:
:
ScrollFragmentPoint
(
pipeline_id
layer_id
point
smooth
)
=
>
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ScrollFragmentPoint
(
pipeline_id
layer_id
point
smooth
)
)
;
}
FromScriptMsg
:
:
GetClientWindow
(
send
)
=
>
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
GetClientWindow
(
send
)
)
;
}
FromScriptMsg
:
:
MoveTo
(
point
)
=
>
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
MoveTo
(
point
)
)
;
}
FromScriptMsg
:
:
ResizeTo
(
size
)
=
>
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ResizeTo
(
size
)
)
;
}
FromScriptMsg
:
:
Exit
=
>
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
Exit
)
;
}
FromScriptMsg
:
:
SetTitle
(
pipeline_id
title
)
=
>
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ChangePageTitle
(
pipeline_id
title
)
)
}
FromScriptMsg
:
:
SendKeyEvent
(
key
key_state
key_modifiers
)
=
>
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
KeyEvent
(
key
key_state
key_modifiers
)
)
}
FromScriptMsg
:
:
TouchEventProcessed
(
result
)
=
>
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
TouchEventProcessed
(
result
)
)
}
FromScriptMsg
:
:
GetScrollOffset
(
pid
lid
send
)
=
>
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
GetScrollOffset
(
pid
lid
send
)
)
;
}
}
}
fn
handle_request_from_layout
(
&
mut
self
message
:
FromLayoutMsg
)
{
match
message
{
FromLayoutMsg
:
:
ChangeRunningAnimationsState
(
pipeline_id
animation_state
)
=
>
{
self
.
handle_change_running_animations_state
(
pipeline_id
animation_state
)
}
FromLayoutMsg
:
:
SetCursor
(
cursor
)
=
>
{
self
.
handle_set_cursor_msg
(
cursor
)
}
FromLayoutMsg
:
:
ViewportConstrained
(
pipeline_id
constraints
)
=
>
{
debug
!
(
"
constellation
got
viewport
-
constrained
event
message
"
)
;
self
.
handle_viewport_constrained_msg
(
pipeline_id
constraints
)
;
}
}
}
fn
handle_request_from_panic
(
&
mut
self
message
:
PanicMsg
)
{
match
message
{
(
pipeline_id
panic_reason
backtrace
)
=
>
{
debug
!
(
"
handling
panic
message
(
{
:
?
}
)
"
pipeline_id
)
;
self
.
handle_panic
(
pipeline_id
panic_reason
backtrace
)
;
}
}
}
fn
handle_exit
(
&
mut
self
)
{
if
self
.
shutting_down
{
return
;
}
self
.
shutting_down
=
true
;
if
let
Some
(
root_id
)
=
self
.
root_frame_id
{
self
.
close_frame
(
root_id
ExitPipelineMode
:
:
Normal
)
;
}
}
fn
handle_shutdown
(
&
mut
self
)
{
let
(
core_sender
core_receiver
)
=
ipc
:
:
channel
(
)
.
expect
(
"
Failed
to
create
IPC
channel
!
"
)
;
let
(
storage_sender
storage_receiver
)
=
ipc
:
:
channel
(
)
.
expect
(
"
Failed
to
create
IPC
channel
!
"
)
;
debug
!
(
"
Exiting
image
cache
.
"
)
;
self
.
image_cache_thread
.
exit
(
)
;
debug
!
(
"
Exiting
core
resource
threads
.
"
)
;
if
let
Err
(
e
)
=
self
.
public_resource_threads
.
send
(
net_traits
:
:
CoreResourceMsg
:
:
Exit
(
core_sender
)
)
{
warn
!
(
"
Exit
resource
thread
failed
(
{
}
)
"
e
)
;
}
if
let
Some
(
ref
chan
)
=
self
.
devtools_chan
{
debug
!
(
"
Exiting
devtools
.
"
)
;
let
msg
=
DevtoolsControlMsg
:
:
FromChrome
(
ChromeToDevtoolsControlMsg
:
:
ServerExitMsg
)
;
if
let
Err
(
e
)
=
chan
.
send
(
msg
)
{
warn
!
(
"
Exit
devtools
failed
(
{
}
)
"
e
)
;
}
}
debug
!
(
"
Exiting
storage
resource
threads
.
"
)
;
if
let
Err
(
e
)
=
self
.
public_resource_threads
.
send
(
StorageThreadMsg
:
:
Exit
(
storage_sender
)
)
{
warn
!
(
"
Exit
storage
thread
failed
(
{
}
)
"
e
)
;
}
debug
!
(
"
Exiting
file
manager
resource
threads
.
"
)
;
if
let
Err
(
e
)
=
self
.
public_resource_threads
.
send
(
FileManagerThreadMsg
:
:
Exit
)
{
warn
!
(
"
Exit
storage
thread
failed
(
{
}
)
"
e
)
;
}
debug
!
(
"
Exiting
bluetooth
thread
.
"
)
;
if
let
Err
(
e
)
=
self
.
bluetooth_thread
.
send
(
BluetoothMethodMsg
:
:
Exit
)
{
warn
!
(
"
Exit
bluetooth
thread
failed
(
{
}
)
"
e
)
;
}
debug
!
(
"
Exiting
font
cache
thread
.
"
)
;
self
.
font_cache_thread
.
exit
(
)
;
if
let
Err
(
e
)
=
core_receiver
.
recv
(
)
{
warn
!
(
"
Exit
resource
thread
failed
(
{
}
)
"
e
)
;
}
if
let
Err
(
e
)
=
storage_receiver
.
recv
(
)
{
warn
!
(
"
Exit
storage
thread
failed
(
{
}
)
"
e
)
;
}
debug
!
(
"
Asking
compositor
to
complete
shutdown
.
"
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ShutdownComplete
)
;
}
fn
handle_pipeline_exited
(
&
mut
self
pipeline_id
:
PipelineId
)
{
debug
!
(
"
Pipeline
{
:
?
}
exited
.
"
pipeline_id
)
;
self
.
pipelines
.
remove
(
&
pipeline_id
)
;
}
fn
handle_send_error
(
&
mut
self
pipeline_id
:
PipelineId
err
:
IOError
)
{
debug
!
(
"
Pipeline
{
:
?
}
send
error
(
{
}
)
.
"
pipeline_id
err
)
;
self
.
handle_panic
(
Some
(
pipeline_id
)
format
!
(
"
Send
failed
(
{
}
)
"
err
)
String
:
:
from
(
"
<
none
>
"
)
)
;
}
fn
handle_panic
(
&
mut
self
pipeline_id
:
Option
<
PipelineId
>
reason
:
String
backtrace
:
String
)
{
error
!
(
"
Panic
:
{
}
"
reason
)
;
if
!
self
.
handled_panic
|
|
opts
:
:
get
(
)
.
full_backtraces
{
error
!
(
"
Backtrace
:
\
n
{
}
"
backtrace
)
;
}
else
{
error
!
(
"
Backtrace
skipped
(
run
with
-
Z
full
-
backtraces
to
see
every
backtrace
)
.
"
)
;
}
if
opts
:
:
get
(
)
.
hard_fail
{
error
!
(
"
Pipeline
failed
in
hard
-
fail
mode
.
Crashing
!
"
)
;
process
:
:
exit
(
1
)
;
}
debug
!
(
"
Panic
handler
for
pipeline
{
:
?
}
:
{
}
.
"
pipeline_id
reason
)
;
if
let
Some
(
pipeline_id
)
=
pipeline_id
{
let
pipeline_url
=
self
.
pipelines
.
get
(
&
pipeline_id
)
.
map
(
|
pipeline
|
pipeline
.
url
.
clone
(
)
)
;
let
parent_info
=
self
.
pipelines
.
get
(
&
pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
parent_info
)
;
let
window_size
=
self
.
pipelines
.
get
(
&
pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
size
)
;
self
.
trigger_mozbrowsererror
(
pipeline_id
reason
backtrace
)
;
self
.
close_pipeline
(
pipeline_id
ExitPipelineMode
:
:
Force
)
;
self
.
pipelines
.
remove
(
&
pipeline_id
)
;
while
let
Some
(
pending_pipeline_id
)
=
self
.
pending_frames
.
iter
(
)
.
find
(
|
pending
|
{
pending
.
old_pipeline_id
=
=
Some
(
pipeline_id
)
}
)
.
map
(
|
frame
|
frame
.
new_pipeline_id
)
{
warn
!
(
"
removing
pending
frame
change
for
failed
pipeline
"
)
;
self
.
close_pipeline
(
pending_pipeline_id
ExitPipelineMode
:
:
Force
)
;
}
let
failure_url
=
Url
:
:
parse
(
"
about
:
failure
"
)
.
expect
(
"
infallible
"
)
;
if
let
Some
(
pipeline_url
)
=
pipeline_url
{
if
pipeline_url
=
=
failure_url
{
return
error
!
(
"
about
:
failure
failed
"
)
;
}
}
warn
!
(
"
creating
replacement
pipeline
for
about
:
failure
"
)
;
let
new_pipeline_id
=
PipelineId
:
:
new
(
)
;
let
load_data
=
LoadData
:
:
new
(
failure_url
None
None
)
;
self
.
new_pipeline
(
new_pipeline_id
parent_info
window_size
None
load_data
false
)
;
self
.
push_pending_frame
(
new_pipeline_id
Some
(
pipeline_id
)
)
;
}
self
.
handled_panic
=
true
;
}
fn
handle_init_load
(
&
mut
self
url
:
Url
)
{
let
window_size
=
self
.
window_size
.
visible_viewport
;
let
root_pipeline_id
=
PipelineId
:
:
new
(
)
;
debug_assert
!
(
PipelineId
:
:
fake_root_pipeline_id
(
)
=
=
root_pipeline_id
)
;
self
.
new_pipeline
(
root_pipeline_id
None
Some
(
window_size
)
None
LoadData
:
:
new
(
url
.
clone
(
)
None
None
)
false
)
;
self
.
handle_load_start_msg
(
&
root_pipeline_id
)
;
self
.
push_pending_frame
(
root_pipeline_id
None
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ChangePageUrl
(
root_pipeline_id
url
)
)
;
}
fn
handle_frame_size_msg
(
&
mut
self
pipeline_id
:
PipelineId
size
:
&
TypedSize2D
<
PagePx
f32
>
)
{
let
msg
=
ConstellationControlMsg
:
:
Resize
(
pipeline_id
WindowSizeData
{
visible_viewport
:
*
size
initial_viewport
:
*
size
*
ScaleFactor
:
:
new
(
1
.
0
)
device_pixel_ratio
:
self
.
window_size
.
device_pixel_ratio
}
WindowSizeType
:
:
Initial
)
;
let
result
=
{
match
self
.
pipelines
.
get_mut
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
{
pipeline
.
size
=
Some
(
*
size
)
;
pipeline
.
script_chan
.
send
(
msg
)
}
None
=
>
return
}
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
pipeline_id
e
)
;
}
}
fn
handle_subframe_loaded
(
&
mut
self
pipeline_id
:
PipelineId
)
{
let
parent_info
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
.
parent_info
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
loaded
after
closure
.
"
pipeline_id
)
}
;
let
subframe_parent_id
=
match
parent_info
{
Some
(
ref
parent
)
=
>
parent
.
0
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
has
no
parent
.
"
pipeline_id
)
}
;
let
msg
=
ConstellationControlMsg
:
:
DispatchFrameLoadEvent
{
target
:
pipeline_id
parent
:
subframe_parent_id
}
;
let
result
=
match
self
.
pipelines
.
get
(
&
subframe_parent_id
)
{
Some
(
pipeline
)
=
>
pipeline
.
script_chan
.
send
(
msg
)
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
subframe
loaded
after
closure
.
"
subframe_parent_id
)
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
subframe_parent_id
e
)
;
}
}
fn
handle_script_loaded_url_in_iframe_msg
(
&
mut
self
load_info
:
IFrameLoadInfo
)
{
let
old_pipeline_id
=
load_info
.
old_subpage_id
.
and_then
(
|
old_subpage_id
|
self
.
subpage_map
.
get
(
&
(
load_info
.
containing_pipeline_id
old_subpage_id
)
)
)
.
cloned
(
)
;
let
(
load_data
script_chan
window_size
is_private
)
=
{
let
old_pipeline
=
old_pipeline_id
.
and_then
(
|
old_pipeline_id
|
self
.
pipelines
.
get
(
&
old_pipeline_id
)
)
;
let
source_pipeline
=
match
self
.
pipelines
.
get
(
&
load_info
.
containing_pipeline_id
)
{
Some
(
source_pipeline
)
=
>
source_pipeline
None
=
>
return
warn
!
(
"
Script
loaded
url
in
closed
iframe
{
}
.
"
load_info
.
containing_pipeline_id
)
}
;
let
load_data
=
load_info
.
load_data
.
unwrap_or_else
(
|
|
{
let
url
=
match
old_pipeline
{
Some
(
old_pipeline
)
=
>
old_pipeline
.
url
.
clone
(
)
None
=
>
Url
:
:
parse
(
"
about
:
blank
"
)
.
expect
(
"
infallible
"
)
}
;
LoadData
:
:
new
(
url
None
None
)
}
)
;
let
source_url
=
&
source_pipeline
.
url
;
let
is_private
=
load_info
.
is_private
|
|
source_pipeline
.
is_private
;
let
same_script
=
source_url
.
host
(
)
=
=
load_data
.
url
.
host
(
)
&
&
source_url
.
port
(
)
=
=
load_data
.
url
.
port
(
)
&
&
load_info
.
sandbox
=
=
IFrameSandboxState
:
:
IFrameUnsandboxed
&
&
source_pipeline
.
is_private
=
=
is_private
;
let
script_chan
=
if
same_script
{
debug
!
(
"
Constellation
:
loading
same
-
origin
iframe
\
parent
url
{
:
?
}
iframe
url
{
:
?
}
"
source_url
load_data
.
url
)
;
Some
(
source_pipeline
.
script_chan
.
clone
(
)
)
}
else
{
debug
!
(
"
Constellation
:
loading
cross
-
origin
iframe
\
parent
url
{
:
?
}
iframe
url
{
:
?
}
"
source_url
load_data
.
url
)
;
None
}
;
let
window_size
=
old_pipeline
.
and_then
(
|
old_pipeline
|
old_pipeline
.
size
)
;
if
let
Some
(
old_pipeline
)
=
old_pipeline
{
old_pipeline
.
freeze
(
)
;
}
(
load_data
script_chan
window_size
is_private
)
}
;
self
.
new_pipeline
(
load_info
.
new_pipeline_id
Some
(
(
load_info
.
containing_pipeline_id
load_info
.
new_subpage_id
load_info
.
frame_type
)
)
window_size
script_chan
load_data
is_private
)
;
self
.
subpage_map
.
insert
(
(
load_info
.
containing_pipeline_id
load_info
.
new_subpage_id
)
load_info
.
new_pipeline_id
)
;
self
.
push_pending_frame
(
load_info
.
new_pipeline_id
old_pipeline_id
)
;
}
fn
handle_set_cursor_msg
(
&
mut
self
cursor
:
Cursor
)
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
SetCursor
(
cursor
)
)
}
fn
handle_change_running_animations_state
(
&
mut
self
pipeline_id
:
PipelineId
animation_state
:
AnimationState
)
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ChangeRunningAnimationsState
(
pipeline_id
animation_state
)
)
}
fn
handle_tick_animation
(
&
mut
self
pipeline_id
:
PipelineId
tick_type
:
AnimationTickType
)
{
let
result
=
match
tick_type
{
AnimationTickType
:
:
Script
=
>
{
let
msg
=
ConstellationControlMsg
:
:
TickAllAnimations
(
pipeline_id
)
;
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
.
script_chan
.
send
(
msg
)
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
got
script
tick
after
closure
.
"
pipeline_id
)
}
}
AnimationTickType
:
:
Layout
=
>
{
let
msg
=
LayoutControlMsg
:
:
TickAnimations
;
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
.
layout_chan
.
send
(
msg
)
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
got
layout
tick
after
closure
.
"
pipeline_id
)
}
}
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
pipeline_id
e
)
;
}
}
fn
handle_alert
(
&
mut
self
pipeline_id
:
PipelineId
message
:
String
sender
:
IpcSender
<
bool
>
)
{
let
display_alert_dialog
=
if
PREFS
.
is_mozbrowser_enabled
(
)
{
let
parent_pipeline_info
=
self
.
pipelines
.
get
(
&
pipeline_id
)
.
and_then
(
|
source
|
source
.
parent_info
)
;
if
let
Some
(
_
)
=
parent_pipeline_info
{
let
root_pipeline_id
=
self
.
root_frame_id
.
and_then
(
|
root_frame_id
|
self
.
frames
.
get
(
&
root_frame_id
)
)
.
map
(
|
root_frame
|
root_frame
.
current
)
;
let
ancestor_info
=
self
.
get_mozbrowser_ancestor_info
(
pipeline_id
)
;
if
let
Some
(
(
ancestor_id
subpage_id
)
)
=
ancestor_info
{
if
root_pipeline_id
=
=
Some
(
ancestor_id
)
{
match
root_pipeline_id
.
and_then
(
|
pipeline_id
|
self
.
pipelines
.
get
(
&
pipeline_id
)
)
{
Some
(
root_pipeline
)
=
>
{
let
event
=
MozBrowserEvent
:
:
ShowModalPrompt
(
"
alert
"
.
to_owned
(
)
"
Alert
"
.
to_owned
(
)
String
:
:
from
(
message
)
"
"
.
to_owned
(
)
)
;
root_pipeline
.
trigger_mozbrowser_event
(
subpage_id
event
)
;
}
None
=
>
return
warn
!
(
"
Alert
sent
to
Pipeline
{
:
?
}
after
closure
.
"
root_pipeline_id
)
}
}
else
{
warn
!
(
"
A
non
-
current
frame
is
trying
to
show
an
alert
.
"
)
}
}
false
}
else
{
true
}
}
else
{
true
}
;
let
result
=
sender
.
send
(
display_alert_dialog
)
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
pipeline_id
e
)
;
}
}
fn
handle_load_url_msg
(
&
mut
self
source_id
:
PipelineId
load_data
:
LoadData
)
{
self
.
load_url
(
source_id
load_data
)
;
}
fn
load_url
(
&
mut
self
source_id
:
PipelineId
load_data
:
LoadData
)
-
>
Option
<
PipelineId
>
{
let
parent_info
=
self
.
pipelines
.
get
(
&
source_id
)
.
and_then
(
|
source
|
source
.
parent_info
)
;
match
parent_info
{
Some
(
(
parent_pipeline_id
subpage_id
_
)
)
=
>
{
self
.
handle_load_start_msg
(
&
source_id
)
;
let
msg
=
ConstellationControlMsg
:
:
Navigate
(
parent_pipeline_id
subpage_id
load_data
)
;
let
result
=
match
self
.
pipelines
.
get
(
&
parent_pipeline_id
)
{
Some
(
parent_pipeline
)
=
>
parent_pipeline
.
script_chan
.
send
(
msg
)
None
=
>
{
warn
!
(
"
Pipeline
{
:
?
}
child
loaded
after
closure
"
parent_pipeline_id
)
;
return
None
;
}
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
parent_pipeline_id
e
)
;
}
Some
(
source_id
)
}
None
=
>
{
for
frame_change
in
&
self
.
pending_frames
{
if
frame_change
.
old_pipeline_id
=
=
Some
(
source_id
)
{
return
None
;
}
}
if
!
self
.
pipeline_is_in_current_frame
(
source_id
)
{
return
None
;
}
self
.
handle_load_start_msg
(
&
source_id
)
;
let
window_size
=
self
.
pipelines
.
get
(
&
source_id
)
.
and_then
(
|
source
|
source
.
size
)
;
let
new_pipeline_id
=
PipelineId
:
:
new
(
)
;
self
.
new_pipeline
(
new_pipeline_id
None
window_size
None
load_data
false
)
;
self
.
push_pending_frame
(
new_pipeline_id
Some
(
source_id
)
)
;
match
self
.
pipelines
.
get
(
&
source_id
)
{
Some
(
source
)
=
>
source
.
freeze
(
)
None
=
>
warn
!
(
"
Pipeline
{
:
?
}
loaded
after
closure
"
source_id
)
}
;
Some
(
new_pipeline_id
)
}
}
}
fn
handle_load_start_msg
(
&
mut
self
pipeline_id
:
&
PipelineId
)
{
if
let
Some
(
frame_id
)
=
self
.
pipelines
.
get
(
pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
frame
)
{
if
let
Some
(
frame
)
=
self
.
frames
.
get
(
&
frame_id
)
{
let
forward
=
!
frame
.
next
.
is_empty
(
)
;
let
back
=
!
frame
.
prev
.
is_empty
(
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
LoadStart
(
back
forward
)
)
;
}
}
}
fn
handle_load_complete_msg
(
&
mut
self
pipeline_id
:
&
PipelineId
)
{
if
let
Some
(
frame_id
)
=
self
.
pipelines
.
get
(
pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
frame
)
{
if
let
Some
(
frame
)
=
self
.
frames
.
get
(
&
frame_id
)
{
let
forward
=
frame
.
next
.
is_empty
(
)
;
let
back
=
frame
.
prev
.
is_empty
(
)
;
let
root
=
self
.
root_frame_id
.
is_none
(
)
|
|
self
.
root_frame_id
=
=
Some
(
frame_id
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
LoadComplete
(
back
forward
root
)
)
;
}
}
}
fn
handle_dom_load
(
&
mut
self
pipeline_id
:
PipelineId
)
{
let
mut
webdriver_reset
=
false
;
if
let
Some
(
(
expected_pipeline_id
ref
reply_chan
)
)
=
self
.
webdriver
.
load_channel
{
debug
!
(
"
Sending
load
to
WebDriver
"
)
;
if
expected_pipeline_id
=
=
pipeline_id
{
let
_
=
reply_chan
.
send
(
webdriver_msg
:
:
LoadStatus
:
:
LoadComplete
)
;
webdriver_reset
=
true
;
}
}
if
webdriver_reset
{
self
.
webdriver
.
load_channel
=
None
;
}
self
.
handle_subframe_loaded
(
pipeline_id
)
;
}
fn
handle_navigate_msg
(
&
mut
self
pipeline_info
:
Option
<
(
PipelineId
SubpageId
)
>
direction
:
constellation_msg
:
:
NavigationDirection
)
{
debug
!
(
"
received
message
to
navigate
{
:
?
}
"
direction
)
;
let
frame_id
=
pipeline_info
.
and_then
(
|
info
|
self
.
subpage_map
.
get
(
&
info
)
)
.
and_then
(
|
pipeline_id
|
self
.
pipelines
.
get
(
&
pipeline_id
)
)
.
and_then
(
|
pipeline
|
pipeline
.
frame
)
.
or
(
self
.
root_frame_id
)
;
let
frame_id
=
match
frame_id
{
None
=
>
return
warn
!
(
"
Navigation
after
root
'
s
closure
.
"
)
Some
(
frame_id
)
=
>
frame_id
}
;
let
update_focus_pipeline
=
self
.
focused_pipeline_in_tree
(
frame_id
)
;
let
(
prev_pipeline_id
next_pipeline_id
)
=
match
self
.
frames
.
get_mut
(
&
frame_id
)
{
Some
(
frame
)
=
>
{
let
prev
=
frame
.
current
;
let
next
=
match
direction
{
NavigationDirection
:
:
Forward
(
delta
)
=
>
{
if
delta
>
frame
.
next
.
len
(
)
&
&
delta
>
0
{
return
warn
!
(
"
Invalid
navigation
delta
"
)
;
}
let
new_next_len
=
frame
.
next
.
len
(
)
-
(
delta
-
1
)
;
frame
.
prev
.
push
(
frame
.
current
)
;
frame
.
prev
.
extend
(
frame
.
next
.
drain
(
new_next_len
.
.
)
.
rev
(
)
)
;
frame
.
current
=
match
frame
.
next
.
pop
(
)
{
Some
(
frame
)
=
>
frame
None
=
>
return
warn
!
(
"
Could
not
get
next
frame
for
forward
navigation
"
)
}
;
frame
.
current
}
NavigationDirection
:
:
Back
(
delta
)
=
>
{
if
delta
>
frame
.
prev
.
len
(
)
&
&
delta
>
0
{
return
warn
!
(
"
Invalid
navigation
delta
"
)
;
}
let
new_prev_len
=
frame
.
prev
.
len
(
)
-
(
delta
-
1
)
;
frame
.
next
.
push
(
frame
.
current
)
;
frame
.
next
.
extend
(
frame
.
prev
.
drain
(
new_prev_len
.
.
)
.
rev
(
)
)
;
frame
.
current
=
match
frame
.
prev
.
pop
(
)
{
Some
(
frame
)
=
>
frame
None
=
>
return
warn
!
(
"
Could
not
get
prev
frame
for
back
navigation
"
)
}
;
frame
.
current
}
}
;
(
prev
next
)
}
None
=
>
{
warn
!
(
"
no
frame
to
navigate
from
"
)
;
return
;
}
}
;
if
update_focus_pipeline
{
self
.
focus_pipeline_id
=
Some
(
next_pipeline_id
)
;
}
if
let
Some
(
prev_pipeline
)
=
self
.
pipelines
.
get
(
&
prev_pipeline_id
)
{
prev_pipeline
.
freeze
(
)
;
}
if
let
Some
(
next_pipeline
)
=
self
.
pipelines
.
get
(
&
next_pipeline_id
)
{
next_pipeline
.
thaw
(
)
;
}
self
.
revoke_paint_permission
(
prev_pipeline_id
)
;
self
.
send_frame_tree_and_grant_paint_permission
(
)
;
if
let
Some
(
(
parent_pipeline_id
subpage_id
)
)
=
pipeline_info
{
let
new_subpage_id
=
match
self
.
pipelines
.
get
(
&
next_pipeline_id
)
{
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
navigated
to
after
closure
.
"
next_pipeline_id
)
Some
(
pipeline
)
=
>
match
pipeline
.
parent_info
{
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
has
no
parent
info
.
"
next_pipeline_id
)
Some
(
(
_
new_subpage_id
_
)
)
=
>
new_subpage_id
}
}
;
let
msg
=
ConstellationControlMsg
:
:
UpdateSubpageId
(
parent_pipeline_id
subpage_id
new_subpage_id
next_pipeline_id
)
;
let
result
=
match
self
.
pipelines
.
get
(
&
parent_pipeline_id
)
{
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
child
navigated
after
closure
.
"
parent_pipeline_id
)
Some
(
pipeline
)
=
>
pipeline
.
script_chan
.
send
(
msg
)
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
parent_pipeline_id
e
)
;
}
self
.
trigger_mozbrowserlocationchange
(
next_pipeline_id
)
;
}
}
fn
handle_key_msg
(
&
mut
self
key
:
Key
state
:
KeyState
mods
:
KeyModifiers
)
{
let
root_pipeline_id
=
self
.
root_frame_id
.
and_then
(
|
root_frame_id
|
self
.
frames
.
get
(
&
root_frame_id
)
)
.
map
(
|
root_frame
|
root_frame
.
current
)
;
let
pipeline_id
=
self
.
focus_pipeline_id
.
or
(
root_pipeline_id
)
;
match
pipeline_id
{
Some
(
pipeline_id
)
=
>
{
let
event
=
CompositorEvent
:
:
KeyEvent
(
key
state
mods
)
;
let
msg
=
ConstellationControlMsg
:
:
SendEvent
(
pipeline_id
event
)
;
let
result
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
.
script_chan
.
send
(
msg
)
None
=
>
return
debug
!
(
"
Pipeline
{
:
?
}
got
key
event
after
closure
.
"
pipeline_id
)
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
pipeline_id
e
)
;
}
}
None
=
>
{
let
event
=
ToCompositorMsg
:
:
KeyEvent
(
key
state
mods
)
;
self
.
compositor_proxy
.
clone_compositor_proxy
(
)
.
send
(
event
)
;
}
}
}
fn
handle_reload_msg
(
&
mut
self
)
{
let
root_pipeline_id
=
self
.
root_frame_id
.
and_then
(
|
root_frame_id
|
self
.
frames
.
get
(
&
root_frame_id
)
)
.
map
(
|
root_frame
|
root_frame
.
current
)
;
if
let
Some
(
pipeline_id
)
=
root_pipeline_id
{
let
msg
=
ConstellationControlMsg
:
:
Reload
(
pipeline_id
)
;
let
result
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
.
script_chan
.
send
(
msg
)
None
=
>
return
debug
!
(
"
Pipeline
{
:
?
}
got
reload
event
after
closure
.
"
pipeline_id
)
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
pipeline_id
e
)
;
}
}
}
fn
handle_get_pipeline_title_msg
(
&
mut
self
pipeline_id
:
PipelineId
)
{
let
result
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
None
=
>
return
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ChangePageTitle
(
pipeline_id
None
)
)
Some
(
pipeline
)
=
>
pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
GetTitle
(
pipeline_id
)
)
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
pipeline_id
e
)
;
}
}
fn
handle_mozbrowser_event_msg
(
&
mut
self
containing_pipeline_id
:
PipelineId
subpage_id
:
SubpageId
event
:
MozBrowserEvent
)
{
assert
!
(
PREFS
.
is_mozbrowser_enabled
(
)
)
;
match
self
.
pipelines
.
get
(
&
containing_pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
.
trigger_mozbrowser_event
(
subpage_id
event
)
None
=
>
warn
!
(
"
Pipeline
{
:
?
}
handling
mozbrowser
event
after
closure
.
"
containing_pipeline_id
)
}
}
fn
handle_get_pipeline
(
&
mut
self
frame_id
:
Option
<
FrameId
>
resp_chan
:
IpcSender
<
Option
<
(
PipelineId
bool
)
>
>
)
{
let
current_pipeline_id
=
frame_id
.
or
(
self
.
root_frame_id
)
.
and_then
(
|
frame_id
|
self
.
frames
.
get
(
&
frame_id
)
)
.
map
(
|
frame
|
frame
.
current
)
;
let
current_pipeline_id_loaded
=
current_pipeline_id
.
map
(
|
id
|
(
id
true
)
)
;
let
pipeline_id_loaded
=
self
.
pending_frames
.
iter
(
)
.
rev
(
)
.
find
(
|
x
|
x
.
old_pipeline_id
=
=
current_pipeline_id
)
.
map
(
|
x
|
(
x
.
new_pipeline_id
x
.
document_ready
)
)
.
or
(
current_pipeline_id_loaded
)
;
if
let
Err
(
e
)
=
resp_chan
.
send
(
pipeline_id_loaded
)
{
warn
!
(
"
Failed
get_pipeline
response
(
{
}
)
.
"
e
)
;
}
}
fn
handle_get_frame
(
&
mut
self
pipeline_id
:
PipelineId
resp_chan
:
IpcSender
<
Option
<
FrameId
>
>
)
{
let
frame_id
=
self
.
pipelines
.
get
(
&
pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
frame
)
;
if
let
Err
(
e
)
=
resp_chan
.
send
(
frame_id
)
{
warn
!
(
"
Failed
get_frame
response
(
{
}
)
.
"
e
)
;
}
}
fn
focus_parent_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
)
{
let
parent_info
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
.
parent_info
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
focus
parent
after
closure
.
"
pipeline_id
)
}
;
let
(
containing_pipeline_id
subpage_id
_
)
=
match
parent_info
{
Some
(
info
)
=
>
info
None
=
>
return
debug
!
(
"
Pipeline
{
:
?
}
focus
has
no
parent
.
"
pipeline_id
)
}
;
let
msg
=
ConstellationControlMsg
:
:
FocusIFrame
(
containing_pipeline_id
subpage_id
)
;
let
result
=
match
self
.
pipelines
.
get
(
&
containing_pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
.
script_chan
.
send
(
msg
)
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
focus
after
closure
.
"
containing_pipeline_id
)
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
containing_pipeline_id
e
)
;
}
self
.
focus_parent_pipeline
(
containing_pipeline_id
)
;
}
fn
handle_focus_msg
(
&
mut
self
pipeline_id
:
PipelineId
)
{
self
.
focus_pipeline_id
=
Some
(
pipeline_id
)
;
self
.
focus_parent_pipeline
(
pipeline_id
)
;
}
fn
handle_remove_iframe_msg
(
&
mut
self
pipeline_id
:
PipelineId
)
{
let
frame_id
=
self
.
pipelines
.
get
(
&
pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
frame
)
;
match
frame_id
{
Some
(
frame_id
)
=
>
{
self
.
close_frame
(
frame_id
ExitPipelineMode
:
:
Normal
)
;
}
None
=
>
{
self
.
close_pipeline
(
pipeline_id
ExitPipelineMode
:
:
Normal
)
;
}
}
}
fn
handle_set_visible_msg
(
&
mut
self
pipeline_id
:
PipelineId
visible
:
bool
)
{
let
frame_id
=
self
.
pipelines
.
get
(
&
pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
frame
)
;
let
child_pipeline_ids
:
Vec
<
PipelineId
>
=
self
.
current_frame_tree_iter
(
frame_id
)
.
map
(
|
frame
|
frame
.
current
)
.
collect
(
)
;
for
id
in
child_pipeline_ids
{
if
let
Some
(
pipeline
)
=
self
.
pipelines
.
get_mut
(
&
id
)
{
pipeline
.
change_visibility
(
visible
)
;
}
}
}
fn
handle_visibility_change_complete
(
&
mut
self
pipeline_id
:
PipelineId
visibility
:
bool
)
{
let
parent_pipeline_info
=
self
.
pipelines
.
get
(
&
pipeline_id
)
.
and_then
(
|
source
|
source
.
parent_info
)
;
if
let
Some
(
(
parent_pipeline_id
_
_
)
)
=
parent_pipeline_info
{
let
visibility_msg
=
ConstellationControlMsg
:
:
NotifyVisibilityChange
(
parent_pipeline_id
pipeline_id
visibility
)
;
let
result
=
match
self
.
pipelines
.
get
(
&
parent_pipeline_id
)
{
None
=
>
return
warn
!
(
"
Parent
pipeline
{
:
?
}
closed
"
parent_pipeline_id
)
Some
(
parent_pipeline
)
=
>
parent_pipeline
.
script_chan
.
send
(
visibility_msg
)
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
parent_pipeline_id
e
)
;
}
}
}
fn
handle_create_canvas_paint_thread_msg
(
&
mut
self
size
:
&
Size2D
<
i32
>
response_sender
:
IpcSender
<
IpcSender
<
CanvasMsg
>
>
)
{
let
webrender_api
=
self
.
webrender_api_sender
.
clone
(
)
;
let
sender
=
CanvasPaintThread
:
:
start
(
*
size
webrender_api
)
;
if
let
Err
(
e
)
=
response_sender
.
send
(
sender
)
{
warn
!
(
"
Create
canvas
paint
thread
response
failed
(
{
}
)
"
e
)
;
}
}
fn
handle_create_webgl_paint_thread_msg
(
&
mut
self
size
:
&
Size2D
<
i32
>
attributes
:
GLContextAttributes
response_sender
:
IpcSender
<
Result
<
(
IpcSender
<
CanvasMsg
>
GLLimits
)
String
>
>
)
{
let
webrender_api
=
self
.
webrender_api_sender
.
clone
(
)
;
let
response
=
WebGLPaintThread
:
:
start
(
*
size
attributes
webrender_api
)
;
if
let
Err
(
e
)
=
response_sender
.
send
(
response
)
{
warn
!
(
"
Create
WebGL
paint
thread
response
failed
(
{
}
)
"
e
)
;
}
}
fn
handle_webdriver_msg
(
&
mut
self
msg
:
WebDriverCommandMsg
)
{
match
msg
{
WebDriverCommandMsg
:
:
GetWindowSize
(
_
reply
)
=
>
{
let
_
=
reply
.
send
(
self
.
window_size
)
;
}
WebDriverCommandMsg
:
:
SetWindowSize
(
_
size
reply
)
=
>
{
self
.
webdriver
.
resize_channel
=
Some
(
reply
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ResizeTo
(
size
)
)
;
}
WebDriverCommandMsg
:
:
LoadUrl
(
pipeline_id
load_data
reply
)
=
>
{
self
.
load_url_for_webdriver
(
pipeline_id
load_data
reply
)
;
}
WebDriverCommandMsg
:
:
Refresh
(
pipeline_id
reply
)
=
>
{
let
load_data
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
LoadData
:
:
new
(
pipeline
.
url
.
clone
(
)
None
None
)
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
Refresh
after
closure
.
"
pipeline_id
)
}
;
self
.
load_url_for_webdriver
(
pipeline_id
load_data
reply
)
;
}
WebDriverCommandMsg
:
:
ScriptCommand
(
pipeline_id
cmd
)
=
>
{
let
control_msg
=
ConstellationControlMsg
:
:
WebDriverScriptCommand
(
pipeline_id
cmd
)
;
let
result
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
.
script_chan
.
send
(
control_msg
)
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
ScriptCommand
after
closure
.
"
pipeline_id
)
}
;
if
let
Err
(
e
)
=
result
{
self
.
handle_send_error
(
pipeline_id
e
)
;
}
}
WebDriverCommandMsg
:
:
SendKeys
(
pipeline_id
cmd
)
=
>
{
let
script_channel
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
.
script_chan
.
clone
(
)
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
SendKeys
after
closure
.
"
pipeline_id
)
}
;
for
(
key
mods
state
)
in
cmd
{
let
event
=
CompositorEvent
:
:
KeyEvent
(
key
state
mods
)
;
let
control_msg
=
ConstellationControlMsg
:
:
SendEvent
(
pipeline_id
event
)
;
if
let
Err
(
e
)
=
script_channel
.
send
(
control_msg
)
{
return
self
.
handle_send_error
(
pipeline_id
e
)
;
}
}
}
WebDriverCommandMsg
:
:
TakeScreenshot
(
pipeline_id
reply
)
=
>
{
let
current_pipeline_id
=
self
.
root_frame_id
.
and_then
(
|
root_frame_id
|
self
.
frames
.
get
(
&
root_frame_id
)
)
.
map
(
|
root_frame
|
root_frame
.
current
)
;
if
Some
(
pipeline_id
)
=
=
current_pipeline_id
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
CreatePng
(
reply
)
)
;
}
else
{
if
let
Err
(
e
)
=
reply
.
send
(
None
)
{
warn
!
(
"
Screenshot
reply
failed
(
{
}
)
"
e
)
;
}
}
}
}
}
fn
load_url_for_webdriver
(
&
mut
self
pipeline_id
:
PipelineId
load_data
:
LoadData
reply
:
IpcSender
<
webdriver_msg
:
:
LoadStatus
>
)
{
let
new_pipeline_id
=
self
.
load_url
(
pipeline_id
load_data
)
;
if
let
Some
(
id
)
=
new_pipeline_id
{
self
.
webdriver
.
load_channel
=
Some
(
(
id
reply
)
)
;
}
}
fn
add_or_replace_pipeline_in_frame_tree
(
&
mut
self
frame_change
:
FrameChange
)
{
if
let
Some
(
old_pipeline_id
)
=
frame_change
.
old_pipeline_id
{
if
let
Some
(
old_frame_id
)
=
self
.
pipelines
.
get
(
&
old_pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
frame
)
{
if
self
.
focused_pipeline_in_tree
(
old_frame_id
)
{
self
.
focus_pipeline_id
=
Some
(
frame_change
.
new_pipeline_id
)
;
}
}
}
let
evicted_frames
=
frame_change
.
old_pipeline_id
.
and_then
(
|
old_pipeline_id
|
{
self
.
revoke_paint_permission
(
old_pipeline_id
)
;
self
.
pipelines
.
get
(
&
old_pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
frame
)
.
and_then
(
|
frame_id
|
{
self
.
pipelines
.
get_mut
(
&
frame_change
.
new_pipeline_id
)
.
map
(
|
pipeline
|
pipeline
.
frame
=
Some
(
frame_id
)
)
;
self
.
frames
.
get_mut
(
&
frame_id
)
.
map
(
|
frame
|
frame
.
load
(
frame_change
.
new_pipeline_id
)
)
}
)
}
)
;
if
let
None
=
evicted_frames
{
let
frame_id
=
self
.
new_frame
(
frame_change
.
new_pipeline_id
)
;
match
self
.
pipelines
.
get
(
&
frame_change
.
new_pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
parent_info
)
{
Some
(
(
parent_id
_
_
)
)
=
>
{
if
let
Some
(
parent
)
=
self
.
pipelines
.
get_mut
(
&
parent_id
)
{
parent
.
add_child
(
frame_id
)
;
}
}
None
=
>
{
assert
!
(
self
.
root_frame_id
.
is_none
(
)
)
;
self
.
root_frame_id
=
Some
(
frame_id
)
;
}
}
}
self
.
send_frame_tree_and_grant_paint_permission
(
)
;
self
.
trigger_mozbrowserlocationchange
(
frame_change
.
new_pipeline_id
)
;
for
pipeline_id
in
evicted_frames
.
unwrap_or_default
(
)
{
self
.
close_pipeline
(
pipeline_id
ExitPipelineMode
:
:
Normal
)
;
}
}
fn
handle_activate_document_msg
(
&
mut
self
pipeline_id
:
PipelineId
)
{
debug
!
(
"
Document
ready
to
activate
{
:
?
}
"
pipeline_id
)
;
if
let
Some
(
ref
child_pipeline
)
=
self
.
pipelines
.
get
(
&
pipeline_id
)
{
if
let
Some
(
ref
parent_info
)
=
child_pipeline
.
parent_info
{
if
let
Some
(
parent_pipeline
)
=
self
.
pipelines
.
get
(
&
parent_info
.
0
)
{
let
_
=
parent_pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
FramedContentChanged
(
parent_info
.
0
parent_info
.
1
)
)
;
}
}
}
if
self
.
pipeline_is_in_current_frame
(
pipeline_id
)
{
return
;
}
let
pending_index
=
self
.
pending_frames
.
iter
(
)
.
rposition
(
|
frame_change
|
{
frame_change
.
new_pipeline_id
=
=
pipeline_id
}
)
;
if
let
Some
(
pending_index
)
=
pending_index
{
self
.
pending_frames
[
pending_index
]
.
document_ready
=
true
;
}
while
let
Some
(
valid_frame_change
)
=
self
.
pending_frames
.
iter
(
)
.
rposition
(
|
frame_change
|
{
let
waiting_on_dependency
=
frame_change
.
old_pipeline_id
.
map_or
(
false
|
old_pipeline_id
|
{
self
.
pipelines
.
get
(
&
old_pipeline_id
)
.
map
(
|
pipeline
|
pipeline
.
frame
)
.
is_none
(
)
}
)
;
frame_change
.
document_ready
&
&
!
waiting_on_dependency
}
)
{
let
frame_change
=
self
.
pending_frames
.
swap_remove
(
valid_frame_change
)
;
self
.
add_or_replace_pipeline_in_frame_tree
(
frame_change
)
;
}
}
fn
handle_window_size_msg
(
&
mut
self
new_size
:
WindowSizeData
size_type
:
WindowSizeType
)
{
debug
!
(
"
handle_window_size_msg
:
{
:
?
}
{
:
?
}
"
new_size
.
initial_viewport
.
to_untyped
(
)
new_size
.
visible_viewport
.
to_untyped
(
)
)
;
if
let
Some
(
root_frame_id
)
=
self
.
root_frame_id
{
let
frame
=
match
self
.
frames
.
get
(
&
root_frame_id
)
{
None
=
>
return
warn
!
(
"
Frame
{
:
?
}
resized
after
closing
.
"
root_frame_id
)
Some
(
frame
)
=
>
frame
}
;
let
pipeline_id
=
frame
.
current
;
let
pipeline
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
resized
after
closing
.
"
pipeline_id
)
Some
(
pipeline
)
=
>
pipeline
}
;
let
_
=
pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
Resize
(
pipeline
.
id
new_size
size_type
)
)
;
for
pipeline_id
in
frame
.
prev
.
iter
(
)
.
chain
(
&
frame
.
next
)
{
let
pipeline
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
None
=
>
{
warn
!
(
"
Inactive
pipeline
{
:
?
}
resized
after
closing
.
"
pipeline_id
)
;
continue
;
}
Some
(
pipeline
)
=
>
pipeline
}
;
let
_
=
pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
ResizeInactive
(
pipeline
.
id
new_size
)
)
;
}
}
for
pending_frame
in
&
self
.
pending_frames
{
let
pipeline_id
=
pending_frame
.
new_pipeline_id
;
let
pipeline
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
None
=
>
{
warn
!
(
"
Pending
pipeline
{
:
?
}
is
closed
"
pipeline_id
)
;
continue
;
}
Some
(
pipeline
)
=
>
pipeline
}
;
if
pipeline
.
parent_info
.
is_none
(
)
{
let
_
=
pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
Resize
(
pipeline
.
id
new_size
size_type
)
)
;
}
}
if
let
Some
(
resize_channel
)
=
self
.
webdriver
.
resize_channel
.
take
(
)
{
let
_
=
resize_channel
.
send
(
new_size
)
;
}
self
.
window_size
=
new_size
;
}
fn
handle_viewport_constrained_msg
(
&
mut
self
pipeline_id
:
PipelineId
constraints
:
ViewportConstraints
)
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ViewportConstrained
(
pipeline_id
constraints
)
)
;
}
fn
handle_is_ready_to_save_image
(
&
mut
self
pipeline_states
:
HashMap
<
PipelineId
Epoch
>
)
-
>
ReadyToSave
{
if
self
.
root_frame_id
.
is_none
(
)
{
return
ReadyToSave
:
:
NoRootFrame
;
}
if
self
.
pending_frames
.
len
(
)
>
0
{
return
ReadyToSave
:
:
PendingFrames
;
}
let
(
state_sender
state_receiver
)
=
ipc
:
:
channel
(
)
.
expect
(
"
Failed
to
create
IPC
channel
!
"
)
;
let
(
epoch_sender
epoch_receiver
)
=
ipc
:
:
channel
(
)
.
expect
(
"
Failed
to
create
IPC
channel
!
"
)
;
for
frame
in
self
.
current_frame_tree_iter
(
self
.
root_frame_id
)
{
let
pipeline_id
=
frame
.
current
;
let
pipeline
=
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
None
=
>
{
warn
!
(
"
Pipeline
{
:
?
}
screenshot
while
closing
.
"
pipeline_id
)
;
continue
;
}
Some
(
pipeline
)
=
>
pipeline
}
;
let
msg
=
LayoutControlMsg
:
:
GetWebFontLoadState
(
state_sender
.
clone
(
)
)
;
if
let
Err
(
e
)
=
pipeline
.
layout_chan
.
send
(
msg
)
{
warn
!
(
"
Get
web
font
failed
(
{
}
)
"
e
)
;
}
if
state_receiver
.
recv
(
)
.
unwrap_or
(
true
)
{
return
ReadyToSave
:
:
WebFontNotLoaded
;
}
match
self
.
document_states
.
get
(
&
frame
.
current
)
{
Some
(
&
DocumentState
:
:
Idle
)
=
>
{
}
Some
(
&
DocumentState
:
:
Pending
)
|
None
=
>
{
return
ReadyToSave
:
:
DocumentLoading
;
}
}
if
let
Some
(
size
)
=
pipeline
.
size
{
if
size
=
=
Size2D
:
:
zero
(
)
{
continue
;
}
let
compositor_epoch
=
pipeline_states
.
get
(
&
frame
.
current
)
;
match
compositor_epoch
{
Some
(
compositor_epoch
)
=
>
{
let
message
=
LayoutControlMsg
:
:
GetCurrentEpoch
(
epoch_sender
.
clone
(
)
)
;
if
let
Err
(
e
)
=
pipeline
.
layout_chan
.
send
(
message
)
{
warn
!
(
"
Failed
to
send
GetCurrentEpoch
(
{
}
)
.
"
e
)
;
}
match
epoch_receiver
.
recv
(
)
{
Err
(
e
)
=
>
warn
!
(
"
Failed
to
receive
current
epoch
(
{
}
)
.
"
e
)
Ok
(
layout_thread_epoch
)
=
>
if
layout_thread_epoch
!
=
*
compositor_epoch
{
return
ReadyToSave
:
:
EpochMismatch
;
}
}
}
None
=
>
{
return
ReadyToSave
:
:
PipelineUnknown
;
}
}
}
}
ReadyToSave
:
:
Ready
}
fn
close_frame
(
&
mut
self
frame_id
:
FrameId
exit_mode
:
ExitPipelineMode
)
{
let
parent_info
=
self
.
frames
.
get
(
&
frame_id
)
.
and_then
(
|
frame
|
self
.
pipelines
.
get
(
&
frame
.
current
)
)
.
and_then
(
|
pipeline
|
pipeline
.
parent_info
)
;
let
pipelines_to_close
=
{
let
mut
pipelines_to_close
=
vec
!
(
)
;
if
let
Some
(
frame
)
=
self
.
frames
.
get
(
&
frame_id
)
{
pipelines_to_close
.
extend_from_slice
(
&
frame
.
next
)
;
pipelines_to_close
.
push
(
frame
.
current
)
;
pipelines_to_close
.
extend_from_slice
(
&
frame
.
prev
)
;
}
pipelines_to_close
}
;
for
pipeline_id
in
&
pipelines_to_close
{
self
.
close_pipeline
(
*
pipeline_id
exit_mode
)
;
}
if
self
.
frames
.
remove
(
&
frame_id
)
.
is_none
(
)
{
warn
!
(
"
Closing
frame
{
:
?
}
twice
.
"
frame_id
)
;
}
if
let
Some
(
(
parent_pipeline_id
_
_
)
)
=
parent_info
{
let
parent_pipeline
=
match
self
.
pipelines
.
get_mut
(
&
parent_pipeline_id
)
{
None
=
>
return
warn
!
(
"
Pipeline
{
:
?
}
child
closed
after
parent
.
"
parent_pipeline_id
)
Some
(
parent_pipeline
)
=
>
parent_pipeline
}
;
parent_pipeline
.
remove_child
(
frame_id
)
;
}
}
fn
close_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
exit_mode
:
ExitPipelineMode
)
{
let
frames_to_close
=
{
let
mut
frames_to_close
=
vec
!
(
)
;
if
let
Some
(
pipeline
)
=
self
.
pipelines
.
get
(
&
pipeline_id
)
{
frames_to_close
.
extend_from_slice
(
&
pipeline
.
children
)
;
}
frames_to_close
}
;
for
child_frame
in
&
frames_to_close
{
self
.
close_frame
(
*
child_frame
exit_mode
)
;
}
let
pipeline
=
match
self
.
pipelines
.
get_mut
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
None
=
>
return
warn
!
(
"
Closing
pipeline
{
:
?
}
twice
.
"
pipeline_id
)
}
;
if
let
Some
(
(
parent_id
subpage_id
_
)
)
=
pipeline
.
parent_info
{
self
.
subpage_map
.
remove
(
&
(
parent_id
subpage_id
)
)
;
}
pipeline
.
frame
=
None
;
let
pending_index
=
self
.
pending_frames
.
iter
(
)
.
position
(
|
frame_change
|
{
frame_change
.
new_pipeline_id
=
=
pipeline_id
}
)
;
if
let
Some
(
pending_index
)
=
pending_index
{
self
.
pending_frames
.
remove
(
pending_index
)
;
}
match
exit_mode
{
ExitPipelineMode
:
:
Normal
=
>
pipeline
.
exit
(
)
ExitPipelineMode
:
:
Force
=
>
pipeline
.
force_exit
(
)
}
}
fn
maybe_close_random_pipeline
(
&
mut
self
)
{
match
self
.
random_pipeline_closure
{
Some
(
(
ref
mut
rng
probability
)
)
=
>
if
probability
<
=
rng
.
gen
:
:
<
f32
>
(
)
{
return
}
_
=
>
return
}
;
let
mut
pipeline_ids
:
Vec
<
&
PipelineId
>
=
self
.
pipelines
.
keys
(
)
.
collect
(
)
;
pipeline_ids
.
sort
(
)
;
if
let
Some
(
(
ref
mut
rng
_
)
)
=
self
.
random_pipeline_closure
{
if
let
Some
(
pipeline_id
)
=
rng
.
choose
(
&
*
pipeline_ids
)
{
if
let
Some
(
pipeline
)
=
self
.
pipelines
.
get
(
pipeline_id
)
{
if
PREFS
.
is_mozbrowser_enabled
(
)
&
&
pipeline
.
parent_info
.
is_none
(
)
{
info
!
(
"
Not
closing
mozbrowser
pipeline
{
}
.
"
pipeline_id
)
;
}
else
{
info
!
(
"
Randomly
closing
pipeline
{
}
.
"
pipeline_id
)
;
pipeline
.
force_exit
(
)
;
}
}
}
}
}
fn
frame_to_sendable
(
&
self
frame_id
:
FrameId
)
-
>
Option
<
SendableFrameTree
>
{
self
.
frames
.
get
(
&
frame_id
)
.
and_then
(
|
frame
:
&
Frame
|
{
self
.
pipelines
.
get
(
&
frame
.
current
)
.
map
(
|
pipeline
:
&
Pipeline
|
{
let
mut
frame_tree
=
SendableFrameTree
{
pipeline
:
pipeline
.
to_sendable
(
)
size
:
pipeline
.
size
children
:
vec
!
(
)
}
;
for
child_frame_id
in
&
pipeline
.
children
{
if
let
Some
(
frame
)
=
self
.
frame_to_sendable
(
*
child_frame_id
)
{
frame_tree
.
children
.
push
(
frame
)
;
}
}
frame_tree
}
)
}
)
}
fn
revoke_paint_permission
(
&
self
pipeline_id
:
PipelineId
)
{
let
frame_id
=
self
.
pipelines
.
get
(
&
pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
frame
)
;
for
frame
in
self
.
current_frame_tree_iter
(
frame_id
)
{
self
.
pipelines
.
get
(
&
frame
.
current
)
.
map
(
|
pipeline
|
pipeline
.
revoke_paint_permission
(
)
)
;
}
}
fn
send_frame_tree_and_grant_paint_permission
(
&
mut
self
)
{
if
let
Some
(
root_frame_id
)
=
self
.
root_frame_id
{
if
let
Some
(
frame_tree
)
=
self
.
frame_to_sendable
(
root_frame_id
)
{
let
(
chan
port
)
=
ipc
:
:
channel
(
)
.
expect
(
"
Failed
to
create
IPC
channel
!
"
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
SetFrameTree
(
frame_tree
chan
)
)
;
if
port
.
recv
(
)
.
is_err
(
)
{
warn
!
(
"
Compositor
has
discarded
SetFrameTree
"
)
;
return
;
}
}
}
for
frame
in
self
.
current_frame_tree_iter
(
self
.
root_frame_id
)
{
self
.
pipelines
.
get
(
&
frame
.
current
)
.
map
(
|
pipeline
|
pipeline
.
grant_paint_permission
(
)
)
;
}
}
fn
get_mozbrowser_ancestor_info
(
&
self
mut
pipeline_id
:
PipelineId
)
-
>
Option
<
(
PipelineId
SubpageId
)
>
{
loop
{
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
match
pipeline
.
parent_info
{
Some
(
(
parent_id
subpage_id
FrameType
:
:
MozBrowserIFrame
)
)
=
>
return
Some
(
(
parent_id
subpage_id
)
)
Some
(
(
parent_id
_
_
)
)
=
>
pipeline_id
=
parent_id
None
=
>
return
None
}
None
=
>
{
warn
!
(
"
Finding
mozbrowser
ancestor
for
pipeline
{
}
after
closure
.
"
pipeline_id
)
;
return
None
;
}
}
}
}
fn
trigger_mozbrowserlocationchange
(
&
self
pipeline_id
:
PipelineId
)
{
if
!
PREFS
.
is_mozbrowser_enabled
(
)
{
return
;
}
let
event_info
=
self
.
pipelines
.
get
(
&
pipeline_id
)
.
and_then
(
|
pipeline
|
{
pipeline
.
parent_info
.
map
(
|
(
containing_pipeline_id
subpage_id
frame_type
)
|
{
(
containing_pipeline_id
subpage_id
frame_type
pipeline
.
url
.
to_string
(
)
)
}
)
}
)
;
if
let
Some
(
(
containing_pipeline_id
subpage_id
FrameType
:
:
MozBrowserIFrame
url
)
)
=
event_info
{
if
let
Some
(
parent_pipeline
)
=
self
.
pipelines
.
get
(
&
containing_pipeline_id
)
{
if
let
Some
(
frame_id
)
=
self
.
pipelines
.
get
(
&
pipeline_id
)
.
and_then
(
|
pipeline
|
pipeline
.
frame
)
{
if
let
Some
(
frame
)
=
self
.
frames
.
get
(
&
frame_id
)
{
let
can_go_backward
=
!
frame
.
prev
.
is_empty
(
)
;
let
can_go_forward
=
!
frame
.
next
.
is_empty
(
)
;
let
event
=
MozBrowserEvent
:
:
LocationChange
(
url
can_go_backward
can_go_forward
)
;
parent_pipeline
.
trigger_mozbrowser_event
(
subpage_id
event
)
;
}
}
}
}
}
fn
trigger_mozbrowsererror
(
&
self
pipeline_id
:
PipelineId
reason
:
String
backtrace
:
String
)
{
if
!
PREFS
.
is_mozbrowser_enabled
(
)
{
return
;
}
let
ancestor_info
=
self
.
get_mozbrowser_ancestor_info
(
pipeline_id
)
;
if
let
Some
(
ancestor_info
)
=
ancestor_info
{
match
self
.
pipelines
.
get
(
&
ancestor_info
.
0
)
{
Some
(
ancestor
)
=
>
{
let
event
=
MozBrowserEvent
:
:
Error
(
MozBrowserErrorType
:
:
Fatal
Some
(
reason
)
Some
(
backtrace
)
)
;
ancestor
.
trigger_mozbrowser_event
(
ancestor_info
.
1
event
)
;
}
None
=
>
return
warn
!
(
"
Mozbrowsererror
via
closed
pipeline
{
:
?
}
.
"
ancestor_info
.
0
)
}
}
}
fn
focused_pipeline_in_tree
(
&
self
frame_id
:
FrameId
)
-
>
bool
{
self
.
focus_pipeline_id
.
map_or
(
false
|
pipeline_id
|
{
self
.
pipeline_exists_in_tree
(
pipeline_id
Some
(
frame_id
)
)
}
)
}
fn
pipeline_is_in_current_frame
(
&
self
pipeline_id
:
PipelineId
)
-
>
bool
{
self
.
pipeline_exists_in_tree
(
pipeline_id
self
.
root_frame_id
)
}
fn
pipeline_exists_in_tree
(
&
self
pipeline_id
:
PipelineId
root_frame_id
:
Option
<
FrameId
>
)
-
>
bool
{
self
.
current_frame_tree_iter
(
root_frame_id
)
.
any
(
|
current_frame
|
current_frame
.
current
=
=
pipeline_id
)
}
}
