use
euclid
:
:
TypedSize2D
;
use
msg
:
:
constellation_msg
:
:
{
BrowsingContextId
PipelineId
TopLevelBrowsingContextId
}
;
use
pipeline
:
:
Pipeline
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
use
style_traits
:
:
CSSPixel
;
pub
struct
BrowsingContext
{
pub
id
:
BrowsingContextId
pub
top_level_id
:
TopLevelBrowsingContextId
pub
size
:
Option
<
TypedSize2D
<
f32
CSSPixel
>
>
pub
pipeline_id
:
PipelineId
pub
pipelines
:
HashSet
<
PipelineId
>
}
impl
BrowsingContext
{
pub
fn
new
(
id
:
BrowsingContextId
top_level_id
:
TopLevelBrowsingContextId
pipeline_id
:
PipelineId
)
-
>
BrowsingContext
{
let
mut
pipelines
=
HashSet
:
:
new
(
)
;
pipelines
.
insert
(
pipeline_id
)
;
BrowsingContext
{
id
:
id
top_level_id
:
top_level_id
size
:
None
pipeline_id
:
pipeline_id
pipelines
}
}
pub
fn
update_current_entry
(
&
mut
self
pipeline_id
:
PipelineId
)
{
self
.
pipeline_id
=
pipeline_id
;
}
pub
fn
is_top_level
(
&
self
)
-
>
bool
{
self
.
id
=
=
self
.
top_level_id
}
}
pub
struct
FullyActiveBrowsingContextsIterator
<
'
a
>
{
pub
stack
:
Vec
<
BrowsingContextId
>
pub
browsing_contexts
:
&
'
a
HashMap
<
BrowsingContextId
BrowsingContext
>
pub
pipelines
:
&
'
a
HashMap
<
PipelineId
Pipeline
>
}
impl
<
'
a
>
Iterator
for
FullyActiveBrowsingContextsIterator
<
'
a
>
{
type
Item
=
&
'
a
BrowsingContext
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
BrowsingContext
>
{
loop
{
let
browsing_context_id
=
self
.
stack
.
pop
(
)
?
;
let
browsing_context
=
match
self
.
browsing_contexts
.
get
(
&
browsing_context_id
)
{
Some
(
browsing_context
)
=
>
browsing_context
None
=
>
{
warn
!
(
"
BrowsingContext
{
:
?
}
iterated
after
closure
.
"
browsing_context_id
)
;
continue
;
}
}
;
let
pipeline
=
match
self
.
pipelines
.
get
(
&
browsing_context
.
pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
None
=
>
{
warn
!
(
"
Pipeline
{
:
?
}
iterated
after
closure
.
"
browsing_context
.
pipeline_id
)
;
continue
;
}
}
;
self
.
stack
.
extend
(
pipeline
.
children
.
iter
(
)
)
;
return
Some
(
browsing_context
)
}
}
}
pub
struct
AllBrowsingContextsIterator
<
'
a
>
{
pub
stack
:
Vec
<
BrowsingContextId
>
pub
browsing_contexts
:
&
'
a
HashMap
<
BrowsingContextId
BrowsingContext
>
pub
pipelines
:
&
'
a
HashMap
<
PipelineId
Pipeline
>
}
impl
<
'
a
>
Iterator
for
AllBrowsingContextsIterator
<
'
a
>
{
type
Item
=
&
'
a
BrowsingContext
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
BrowsingContext
>
{
let
pipelines
=
self
.
pipelines
;
loop
{
let
browsing_context_id
=
self
.
stack
.
pop
(
)
?
;
let
browsing_context
=
match
self
.
browsing_contexts
.
get
(
&
browsing_context_id
)
{
Some
(
browsing_context
)
=
>
browsing_context
None
=
>
{
warn
!
(
"
BrowsingContext
{
:
?
}
iterated
after
closure
.
"
browsing_context_id
)
;
continue
;
}
}
;
let
child_browsing_context_ids
=
browsing_context
.
pipelines
.
iter
(
)
.
filter_map
(
|
pipeline_id
|
pipelines
.
get
(
&
pipeline_id
)
)
.
flat_map
(
|
pipeline
|
pipeline
.
children
.
iter
(
)
)
;
self
.
stack
.
extend
(
child_browsing_context_ids
)
;
return
Some
(
browsing_context
)
}
}
}
