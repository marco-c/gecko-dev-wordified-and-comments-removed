#
!
[
deny
(
unsafe_code
)
]
use
app_units
:
:
Au
;
use
block
:
:
{
BlockFlow
CandidateBSizeIterator
ISizeAndMarginsComputer
}
;
use
block
:
:
{
ISizeConstraintInput
ISizeConstraintSolution
}
;
use
context
:
:
LayoutContext
;
use
display_list_builder
:
:
{
BlockFlowDisplayListBuilding
BorderPaintingMode
}
;
use
euclid
:
:
Point2D
;
use
flow
:
:
{
BaseFlow
IMPACTED_BY_RIGHT_FLOATS
ImmutableFlowUtils
OpaqueFlow
}
;
use
flow
:
:
{
self
EarlyAbsolutePositionInfo
Flow
FlowClass
IMPACTED_BY_LEFT_FLOATS
}
;
use
flow_list
:
:
MutFlowListIterator
;
use
fragment
:
:
{
Fragment
FragmentBorderBoxIterator
Overflow
}
;
use
gfx
:
:
display_list
:
:
DisplayList
;
use
incremental
:
:
{
REFLOW
REFLOW_OUT_OF_FLOW
}
;
use
layout_debug
;
use
model
:
:
{
IntrinsicISizes
IntrinsicISizesContribution
MaybeAuto
}
;
use
std
:
:
cmp
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
Arc
;
use
style
:
:
computed_values
:
:
{
border_collapse
border_spacing
table_layout
}
;
use
style
:
:
logical_geometry
:
:
LogicalSize
;
use
style
:
:
properties
:
:
ComputedValues
;
use
style
:
:
values
:
:
CSSFloat
;
use
style
:
:
values
:
:
computed
:
:
LengthOrPercentageOrAuto
;
use
table_row
:
:
{
TableRowFlow
}
;
use
table_row
:
:
{
self
CellIntrinsicInlineSize
CollapsedBorder
CollapsedBorderProvenance
}
;
use
table_wrapper
:
:
TableLayout
;
use
util
:
:
print_tree
:
:
PrintTree
;
#
[
derive
(
RustcEncodable
)
]
pub
struct
TableFlow
{
pub
block_flow
:
BlockFlow
pub
column_intrinsic_inline_sizes
:
Vec
<
ColumnIntrinsicInlineSize
>
pub
column_computed_inline_sizes
:
Vec
<
ColumnComputedInlineSize
>
pub
collapsed_inline_direction_border_widths_for_table
:
Vec
<
Au
>
pub
collapsed_block_direction_border_widths_for_table
:
Vec
<
Au
>
pub
table_layout
:
TableLayout
}
impl
TableFlow
{
pub
fn
from_fragment
(
fragment
:
Fragment
)
-
>
TableFlow
{
let
mut
block_flow
=
BlockFlow
:
:
from_fragment
(
fragment
None
)
;
let
table_layout
=
if
block_flow
.
fragment
(
)
.
style
(
)
.
get_table
(
)
.
table_layout
=
=
table_layout
:
:
T
:
:
fixed
{
TableLayout
:
:
Fixed
}
else
{
TableLayout
:
:
Auto
}
;
TableFlow
{
block_flow
:
block_flow
column_intrinsic_inline_sizes
:
Vec
:
:
new
(
)
column_computed_inline_sizes
:
Vec
:
:
new
(
)
collapsed_inline_direction_border_widths_for_table
:
Vec
:
:
new
(
)
collapsed_block_direction_border_widths_for_table
:
Vec
:
:
new
(
)
table_layout
:
table_layout
}
}
fn
update_automatic_column_inline_sizes
(
parent_inline_sizes
:
&
mut
Vec
<
ColumnIntrinsicInlineSize
>
child_cell_inline_sizes
:
&
[
CellIntrinsicInlineSize
]
)
-
>
IntrinsicISizes
{
let
mut
total_inline_sizes
=
IntrinsicISizes
:
:
new
(
)
;
let
mut
column_index
=
0
;
for
child_cell_inline_size
in
child_cell_inline_sizes
{
for
_
in
0
.
.
child_cell_inline_size
.
column_span
{
if
column_index
<
parent_inline_sizes
.
len
(
)
{
let
parent_sizes
=
&
mut
parent_inline_sizes
[
column_index
]
;
if
child_cell_inline_size
.
column_span
>
1
{
}
else
{
let
column_size
=
&
child_cell_inline_size
.
column_size
;
*
parent_sizes
=
ColumnIntrinsicInlineSize
{
minimum_length
:
cmp
:
:
max
(
parent_sizes
.
minimum_length
column_size
.
minimum_length
)
percentage
:
parent_sizes
.
greatest_percentage
(
column_size
)
preferred
:
cmp
:
:
max
(
parent_sizes
.
preferred
column_size
.
preferred
)
constrained
:
parent_sizes
.
constrained
|
|
column_size
.
constrained
}
}
}
else
{
debug_assert
!
(
column_index
=
=
parent_inline_sizes
.
len
(
)
)
;
if
child_cell_inline_size
.
column_span
>
1
{
parent_inline_sizes
.
push
(
ColumnIntrinsicInlineSize
:
:
new
(
)
)
}
else
{
parent_inline_sizes
.
push
(
child_cell_inline_size
.
column_size
)
}
}
total_inline_sizes
.
minimum_inline_size
=
total_inline_sizes
.
minimum_inline_size
+
parent_inline_sizes
[
column_index
]
.
minimum_length
;
total_inline_sizes
.
preferred_inline_size
=
total_inline_sizes
.
preferred_inline_size
+
parent_inline_sizes
[
column_index
]
.
preferred
;
column_index
+
=
1
}
}
total_inline_sizes
}
fn
update_column_inline_sizes_for_row
(
row
:
&
mut
TableRowFlow
column_inline_sizes
:
&
mut
Vec
<
ColumnIntrinsicInlineSize
>
computation
:
&
mut
IntrinsicISizesContribution
first_row
:
bool
table_layout
:
TableLayout
)
{
match
table_layout
{
TableLayout
:
:
Fixed
=
>
{
if
first_row
{
for
cell_inline_size
in
&
row
.
cell_intrinsic_inline_sizes
{
column_inline_sizes
.
push
(
cell_inline_size
.
column_size
)
;
}
}
}
TableLayout
:
:
Auto
=
>
{
computation
.
union_block
(
&
TableFlow
:
:
update_automatic_column_inline_sizes
(
column_inline_sizes
&
row
.
cell_intrinsic_inline_sizes
)
)
}
}
}
pub
fn
spacing
(
&
self
)
-
>
border_spacing
:
:
T
{
let
style
=
self
.
block_flow
.
fragment
.
style
(
)
;
match
style
.
get_inheritedtable
(
)
.
border_collapse
{
border_collapse
:
:
T
:
:
separate
=
>
style
.
get_inheritedtable
(
)
.
border_spacing
border_collapse
:
:
T
:
:
collapse
=
>
{
border_spacing
:
:
T
{
horizontal
:
Au
(
0
)
vertical
:
Au
(
0
)
}
}
}
}
pub
fn
total_horizontal_spacing
(
&
self
)
-
>
Au
{
let
num_columns
=
self
.
column_intrinsic_inline_sizes
.
len
(
)
;
if
num_columns
=
=
0
{
return
Au
(
0
)
;
}
self
.
spacing
(
)
.
horizontal
*
(
num_columns
as
i32
+
1
)
}
}
impl
Flow
for
TableFlow
{
fn
class
(
&
self
)
-
>
FlowClass
{
FlowClass
:
:
Table
}
fn
as_mut_table
(
&
mut
self
)
-
>
&
mut
TableFlow
{
self
}
fn
as_table
(
&
self
)
-
>
&
TableFlow
{
self
}
fn
as_mut_block
(
&
mut
self
)
-
>
&
mut
BlockFlow
{
&
mut
self
.
block_flow
}
fn
as_block
(
&
self
)
-
>
&
BlockFlow
{
&
self
.
block_flow
}
fn
mark_as_root
(
&
mut
self
)
{
self
.
block_flow
.
mark_as_root
(
)
;
}
fn
column_intrinsic_inline_sizes
(
&
mut
self
)
-
>
&
mut
Vec
<
ColumnIntrinsicInlineSize
>
{
&
mut
self
.
column_intrinsic_inline_sizes
}
fn
column_computed_inline_sizes
(
&
mut
self
)
-
>
&
mut
Vec
<
ColumnComputedInlineSize
>
{
&
mut
self
.
column_computed_inline_sizes
}
fn
bubble_inline_sizes
(
&
mut
self
)
{
let
_scope
=
layout_debug_scope
!
(
"
table
:
:
bubble_inline_sizes
{
:
x
}
"
self
.
block_flow
.
base
.
debug_id
(
)
)
;
for
kid
in
self
.
block_flow
.
base
.
child_iter
(
)
.
filter
(
|
kid
|
kid
.
is_table_colgroup
(
)
)
{
for
specified_inline_size
in
&
kid
.
as_mut_table_colgroup
(
)
.
inline_sizes
{
self
.
column_intrinsic_inline_sizes
.
push
(
ColumnIntrinsicInlineSize
{
minimum_length
:
match
*
specified_inline_size
{
LengthOrPercentageOrAuto
:
:
Auto
|
LengthOrPercentageOrAuto
:
:
Calc
(
_
)
|
LengthOrPercentageOrAuto
:
:
Percentage
(
_
)
=
>
Au
(
0
)
LengthOrPercentageOrAuto
:
:
Length
(
length
)
=
>
length
}
percentage
:
match
*
specified_inline_size
{
LengthOrPercentageOrAuto
:
:
Auto
|
LengthOrPercentageOrAuto
:
:
Calc
(
_
)
|
LengthOrPercentageOrAuto
:
:
Length
(
_
)
=
>
0
.
0
LengthOrPercentageOrAuto
:
:
Percentage
(
percentage
)
=
>
percentage
}
preferred
:
Au
(
0
)
constrained
:
false
}
)
}
}
self
.
collapsed_inline_direction_border_widths_for_table
=
Vec
:
:
new
(
)
;
self
.
collapsed_block_direction_border_widths_for_table
=
vec
!
[
Au
(
0
)
]
;
let
collapsing_borders
=
self
.
block_flow
.
fragment
.
style
.
get_inheritedtable
(
)
.
border_collapse
=
=
border_collapse
:
:
T
:
:
collapse
;
let
table_inline_collapsed_borders
=
if
collapsing_borders
{
Some
(
TableInlineCollapsedBorders
{
start
:
CollapsedBorder
:
:
inline_start
(
&
*
self
.
block_flow
.
fragment
.
style
CollapsedBorderProvenance
:
:
FromTable
)
end
:
CollapsedBorder
:
:
inline_end
(
&
*
self
.
block_flow
.
fragment
.
style
CollapsedBorderProvenance
:
:
FromTable
)
}
)
}
else
{
None
}
;
let
mut
computation
=
IntrinsicISizesContribution
:
:
new
(
)
;
let
mut
previous_collapsed_block_end_borders
=
PreviousBlockCollapsedBorders
:
:
FromTable
(
CollapsedBorder
:
:
block_start
(
&
*
self
.
block_flow
.
fragment
.
style
CollapsedBorderProvenance
:
:
FromTable
)
)
;
let
mut
first_row
=
true
;
{
let
mut
iterator
=
TableRowIterator
:
:
new
(
&
mut
self
.
block_flow
.
base
)
.
peekable
(
)
;
while
let
Some
(
row
)
=
iterator
.
next
(
)
{
TableFlow
:
:
update_column_inline_sizes_for_row
(
row
&
mut
self
.
column_intrinsic_inline_sizes
&
mut
computation
first_row
self
.
table_layout
)
;
if
collapsing_borders
{
let
next_index_and_sibling
=
iterator
.
peek
(
)
;
let
next_collapsed_borders_in_block_direction
=
match
next_index_and_sibling
{
Some
(
next_sibling
)
=
>
{
NextBlockCollapsedBorders
:
:
FromNextRow
(
&
next_sibling
.
as_table_row
(
)
.
preliminary_collapsed_borders
.
block_start
)
}
None
=
>
{
NextBlockCollapsedBorders
:
:
FromTable
(
CollapsedBorder
:
:
block_end
(
&
*
self
.
block_flow
.
fragment
.
style
CollapsedBorderProvenance
:
:
FromTable
)
)
}
}
;
perform_border_collapse_for_row
(
row
table_inline_collapsed_borders
.
as_ref
(
)
.
unwrap
(
)
previous_collapsed_block_end_borders
next_collapsed_borders_in_block_direction
&
mut
self
.
collapsed_inline_direction_border_widths_for_table
&
mut
self
.
collapsed_block_direction_border_widths_for_table
)
;
previous_collapsed_block_end_borders
=
PreviousBlockCollapsedBorders
:
:
FromPreviousRow
(
row
.
final_collapsed_borders
.
block_end
.
clone
(
)
)
}
first_row
=
false
}
}
computation
.
surrounding_size
=
computation
.
surrounding_size
+
self
.
total_horizontal_spacing
(
)
;
self
.
block_flow
.
base
.
intrinsic_inline_sizes
=
computation
.
finish
(
)
}
fn
assign_inline_sizes
(
&
mut
self
layout_context
:
&
LayoutContext
)
{
let
_scope
=
layout_debug_scope
!
(
"
table
:
:
assign_inline_sizes
{
:
x
}
"
self
.
block_flow
.
base
.
debug_id
(
)
)
;
debug
!
(
"
assign_inline_sizes
(
{
}
)
:
assigning
inline_size
for
flow
"
"
table
"
)
;
let
containing_block_inline_size
=
self
.
block_flow
.
base
.
block_container_inline_size
;
let
mut
num_unspecified_inline_sizes
=
0
;
let
mut
total_column_inline_size
=
Au
(
0
)
;
for
column_inline_size
in
&
self
.
column_intrinsic_inline_sizes
{
if
column_inline_size
.
constrained
{
total_column_inline_size
=
total_column_inline_size
+
column_inline_size
.
minimum_length
}
else
{
num_unspecified_inline_sizes
+
=
1
}
}
let
inline_size_computer
=
InternalTable
{
border_collapse
:
self
.
block_flow
.
fragment
.
style
.
get_inheritedtable
(
)
.
border_collapse
}
;
inline_size_computer
.
compute_used_inline_size
(
&
mut
self
.
block_flow
layout_context
containing_block_inline_size
)
;
let
inline_start_content_edge
=
self
.
block_flow
.
fragment
.
border_padding
.
inline_start
;
let
inline_end_content_edge
=
self
.
block_flow
.
fragment
.
border_padding
.
inline_end
;
let
padding_and_borders
=
self
.
block_flow
.
fragment
.
border_padding
.
inline_start_end
(
)
;
let
spacing_per_cell
=
self
.
spacing
(
)
;
let
spacing
=
self
.
total_horizontal_spacing
(
)
;
let
content_inline_size
=
self
.
block_flow
.
fragment
.
border_box
.
size
.
inline
-
padding_and_borders
-
spacing
;
match
self
.
table_layout
{
TableLayout
:
:
Fixed
=
>
{
self
.
column_computed_inline_sizes
.
clear
(
)
;
if
num_unspecified_inline_sizes
=
=
0
{
let
ratio
=
content_inline_size
.
to_f32_px
(
)
/
total_column_inline_size
.
to_f32_px
(
)
;
for
column_inline_size
in
&
self
.
column_intrinsic_inline_sizes
{
self
.
column_computed_inline_sizes
.
push
(
ColumnComputedInlineSize
{
size
:
column_inline_size
.
minimum_length
.
scale_by
(
ratio
)
}
)
;
}
}
else
if
num_unspecified_inline_sizes
!
=
0
{
let
extra_column_inline_size
=
content_inline_size
-
total_column_inline_size
;
for
column_inline_size
in
&
self
.
column_intrinsic_inline_sizes
{
if
!
column_inline_size
.
constrained
&
&
column_inline_size
.
percentage
=
=
0
.
0
{
self
.
column_computed_inline_sizes
.
push
(
ColumnComputedInlineSize
{
size
:
extra_column_inline_size
/
num_unspecified_inline_sizes
}
)
;
}
else
{
self
.
column_computed_inline_sizes
.
push
(
ColumnComputedInlineSize
{
size
:
column_inline_size
.
minimum_length
}
)
;
}
}
}
}
_
=
>
{
}
}
self
.
block_flow
.
base
.
flags
.
remove
(
IMPACTED_BY_LEFT_FLOATS
)
;
self
.
block_flow
.
base
.
flags
.
remove
(
IMPACTED_BY_RIGHT_FLOATS
)
;
let
column_computed_inline_sizes
=
&
self
.
column_computed_inline_sizes
;
let
collapsed_inline_direction_border_widths_for_table
=
&
self
.
collapsed_inline_direction_border_widths_for_table
;
let
mut
collapsed_block_direction_border_widths_for_table
=
self
.
collapsed_block_direction_border_widths_for_table
.
iter
(
)
.
peekable
(
)
;
self
.
block_flow
.
propagate_assigned_inline_size_to_children
(
layout_context
inline_start_content_edge
inline_end_content_edge
content_inline_size
|
child_flow
_child_index
_content_inline_size
writing_mode
_inline_start_margin_edge
_inline_end_margin_edge
|
{
table_row
:
:
propagate_column_inline_sizes_to_child
(
child_flow
writing_mode
column_computed_inline_sizes
&
spacing_per_cell
)
;
if
child_flow
.
is_table_row
(
)
{
let
child_table_row
=
child_flow
.
as_mut_table_row
(
)
;
child_table_row
.
populate_collapsed_border_spacing
(
collapsed_inline_direction_border_widths_for_table
&
mut
collapsed_block_direction_border_widths_for_table
)
;
}
else
if
child_flow
.
is_table_rowgroup
(
)
{
let
child_table_rowgroup
=
child_flow
.
as_mut_table_rowgroup
(
)
;
child_table_rowgroup
.
populate_collapsed_border_spacing
(
collapsed_inline_direction_border_widths_for_table
&
mut
collapsed_block_direction_border_widths_for_table
)
;
}
}
)
}
fn
assign_block_size
<
'
a
>
(
&
mut
self
_
:
&
'
a
LayoutContext
<
'
a
>
)
{
debug
!
(
"
assign_block_size
:
assigning
block_size
for
table
"
)
;
let
vertical_spacing
=
self
.
spacing
(
)
.
vertical
;
self
.
block_flow
.
assign_block_size_for_table_like_flow
(
vertical_spacing
)
}
fn
compute_absolute_position
(
&
mut
self
layout_context
:
&
LayoutContext
)
{
self
.
block_flow
.
compute_absolute_position
(
layout_context
)
}
fn
generated_containing_block_size
(
&
self
flow
:
OpaqueFlow
)
-
>
LogicalSize
<
Au
>
{
self
.
block_flow
.
generated_containing_block_size
(
flow
)
}
fn
update_late_computed_inline_position_if_necessary
(
&
mut
self
inline_position
:
Au
)
{
self
.
block_flow
.
update_late_computed_inline_position_if_necessary
(
inline_position
)
}
fn
update_late_computed_block_position_if_necessary
(
&
mut
self
block_position
:
Au
)
{
self
.
block_flow
.
update_late_computed_block_position_if_necessary
(
block_position
)
}
fn
build_display_list
(
&
mut
self
layout_context
:
&
LayoutContext
)
{
let
border_painting_mode
=
match
self
.
block_flow
.
fragment
.
style
.
get_inheritedtable
(
)
.
border_collapse
{
border_collapse
:
:
T
:
:
separate
=
>
BorderPaintingMode
:
:
Separate
border_collapse
:
:
T
:
:
collapse
=
>
BorderPaintingMode
:
:
Hidden
}
;
self
.
block_flow
.
build_display_list_for_block
(
box
DisplayList
:
:
new
(
)
layout_context
border_painting_mode
)
;
}
fn
repair_style
(
&
mut
self
new_style
:
&
Arc
<
ComputedValues
>
)
{
self
.
block_flow
.
repair_style
(
new_style
)
}
fn
compute_overflow
(
&
self
)
-
>
Overflow
{
self
.
block_flow
.
compute_overflow
(
)
}
fn
iterate_through_fragment_border_boxes
(
&
self
iterator
:
&
mut
FragmentBorderBoxIterator
level
:
i32
stacking_context_position
:
&
Point2D
<
Au
>
)
{
self
.
block_flow
.
iterate_through_fragment_border_boxes
(
iterator
level
stacking_context_position
)
}
fn
mutate_fragments
(
&
mut
self
mutator
:
&
mut
FnMut
(
&
mut
Fragment
)
)
{
self
.
block_flow
.
mutate_fragments
(
mutator
)
}
fn
print_extra_flow_children
(
&
self
print_tree
:
&
mut
PrintTree
)
{
self
.
block_flow
.
print_extra_flow_children
(
print_tree
)
;
}
}
impl
fmt
:
:
Debug
for
TableFlow
{
/
/
/
Outputs
a
debugging
string
describing
this
table
flow
.
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
TableFlow
:
{
:
?
}
"
self
.
block_flow
)
}
}
pub
struct
InternalTable
{
pub
border_collapse
:
border_collapse
:
:
T
}
impl
ISizeAndMarginsComputer
for
InternalTable
{
fn
compute_border_and_padding
(
&
self
block
:
&
mut
BlockFlow
containing_block_inline_size
:
Au
)
{
block
.
fragment
.
compute_border_and_padding
(
containing_block_inline_size
self
.
border_collapse
)
}
fn
compute_used_inline_size
(
&
self
block
:
&
mut
BlockFlow
layout_context
:
&
LayoutContext
parent_flow_inline_size
:
Au
)
{
let
mut
input
=
self
.
compute_inline_size_constraint_inputs
(
block
parent_flow_inline_size
layout_context
)
;
let
minimum_inline_size
=
block
.
base
.
intrinsic_inline_sizes
.
minimum_inline_size
-
block
.
fragment
.
border_padding
.
inline_start_end
(
)
;
input
.
available_inline_size
=
cmp
:
:
max
(
input
.
available_inline_size
minimum_inline_size
)
;
let
solution
=
self
.
solve_inline_size_constraints
(
block
&
input
)
;
self
.
set_inline_size_constraint_solutions
(
block
solution
)
;
}
fn
solve_inline_size_constraints
(
&
self
_
:
&
mut
BlockFlow
input
:
&
ISizeConstraintInput
)
-
>
ISizeConstraintSolution
{
ISizeConstraintSolution
:
:
new
(
input
.
available_inline_size
Au
(
0
)
Au
(
0
)
)
}
}
#
[
derive
(
Clone
RustcEncodable
Debug
Copy
)
]
pub
struct
ColumnIntrinsicInlineSize
{
pub
preferred
:
Au
pub
minimum_length
:
Au
pub
percentage
:
CSSFloat
pub
constrained
:
bool
}
impl
ColumnIntrinsicInlineSize
{
pub
fn
new
(
)
-
>
ColumnIntrinsicInlineSize
{
ColumnIntrinsicInlineSize
{
preferred
:
Au
(
0
)
minimum_length
:
Au
(
0
)
percentage
:
0
.
0
constrained
:
false
}
}
pub
fn
greatest_percentage
(
&
self
other
:
&
ColumnIntrinsicInlineSize
)
-
>
CSSFloat
{
if
self
.
percentage
>
other
.
percentage
{
self
.
percentage
}
else
{
other
.
percentage
}
}
}
#
[
derive
(
RustcEncodable
Clone
Copy
)
]
pub
struct
ColumnComputedInlineSize
{
pub
size
:
Au
}
pub
trait
VecExt
<
T
>
{
fn
push_or_set
(
&
mut
self
index
:
usize
value
:
T
)
-
>
&
mut
T
;
fn
get_mut_or_push
(
&
mut
self
index
:
usize
zero
:
T
)
-
>
&
mut
T
;
}
impl
<
T
>
VecExt
<
T
>
for
Vec
<
T
>
{
fn
push_or_set
(
&
mut
self
index
:
usize
value
:
T
)
-
>
&
mut
T
{
if
index
<
self
.
len
(
)
{
self
[
index
]
=
value
}
else
{
debug_assert
!
(
index
=
=
self
.
len
(
)
)
;
self
.
push
(
value
)
}
&
mut
self
[
index
]
}
fn
get_mut_or_push
(
&
mut
self
index
:
usize
zero
:
T
)
-
>
&
mut
T
{
if
index
>
=
self
.
len
(
)
{
debug_assert
!
(
index
=
=
self
.
len
(
)
)
;
self
.
push
(
zero
)
}
&
mut
self
[
index
]
}
}
fn
perform_border_collapse_for_row
(
child_table_row
:
&
mut
TableRowFlow
table_inline_borders
:
&
TableInlineCollapsedBorders
previous_block_borders
:
PreviousBlockCollapsedBorders
next_block_borders
:
NextBlockCollapsedBorders
inline_spacing
:
&
mut
Vec
<
Au
>
block_spacing
:
&
mut
Vec
<
Au
>
)
{
for
(
i
this_inline_border
)
in
child_table_row
.
preliminary_collapsed_borders
.
inline
.
iter
(
)
.
enumerate
(
)
{
child_table_row
.
final_collapsed_borders
.
inline
.
push_or_set
(
i
*
this_inline_border
)
;
let
inline_spacing
=
inline_spacing
.
get_mut_or_push
(
i
Au
(
0
)
)
;
*
inline_spacing
=
cmp
:
:
max
(
*
inline_spacing
this_inline_border
.
width
)
}
if
let
Some
(
ref
mut
first_inline_borders
)
=
child_table_row
.
final_collapsed_borders
.
inline
.
get_mut
(
0
)
{
first_inline_borders
.
combine
(
&
table_inline_borders
.
start
)
}
if
let
Some
(
ref
mut
last_inline_borders
)
=
child_table_row
.
final_collapsed_borders
.
inline
.
last_mut
(
)
{
last_inline_borders
.
combine
(
&
table_inline_borders
.
end
)
}
match
previous_block_borders
{
PreviousBlockCollapsedBorders
:
:
FromPreviousRow
(
previous_block_borders
)
=
>
{
child_table_row
.
final_collapsed_borders
.
block_start
=
previous_block_borders
}
PreviousBlockCollapsedBorders
:
:
FromTable
(
collapsed_border
)
=
>
{
child_table_row
.
final_collapsed_borders
.
block_start
=
vec
!
[
collapsed_border
;
child_table_row
.
block_flow
.
base
.
children
.
len
(
)
]
}
}
let
next_block
=
&
mut
child_table_row
.
final_collapsed_borders
.
block_end
;
block_spacing
.
push
(
Au
(
0
)
)
;
let
block_spacing
=
block_spacing
.
last_mut
(
)
.
unwrap
(
)
;
for
(
i
this_block_border
)
in
child_table_row
.
preliminary_collapsed_borders
.
block_end
.
iter
(
)
.
enumerate
(
)
{
let
next_block
=
next_block
.
push_or_set
(
i
*
this_block_border
)
;
match
next_block_borders
{
NextBlockCollapsedBorders
:
:
FromNextRow
(
next_block_borders
)
=
>
{
if
next_block_borders
.
len
(
)
>
i
{
next_block
.
combine
(
&
next_block_borders
[
i
]
)
}
}
NextBlockCollapsedBorders
:
:
FromTable
(
ref
next_block_borders
)
=
>
{
next_block
.
combine
(
next_block_borders
)
;
}
}
*
block_spacing
=
cmp
:
:
max
(
*
block_spacing
next_block
.
width
)
}
}
pub
trait
TableLikeFlow
{
fn
assign_block_size_for_table_like_flow
(
&
mut
self
block_direction_spacing
:
Au
)
;
}
impl
TableLikeFlow
for
BlockFlow
{
fn
assign_block_size_for_table_like_flow
(
&
mut
self
block_direction_spacing
:
Au
)
{
debug_assert
!
(
self
.
fragment
.
style
.
get_inheritedtable
(
)
.
border_collapse
=
=
border_collapse
:
:
T
:
:
separate
|
|
block_direction_spacing
=
=
Au
(
0
)
)
;
if
self
.
base
.
restyle_damage
.
contains
(
REFLOW
)
{
let
block_start_border_padding
=
self
.
fragment
.
border_padding
.
block_start
;
let
mut
current_block_offset
=
block_start_border_padding
;
let
mut
has_rows
=
false
;
for
kid
in
self
.
base
.
child_iter
(
)
{
if
kid
.
is_table_row
(
)
{
has_rows
=
true
;
let
child_table_row
=
kid
.
as_table_row
(
)
;
current_block_offset
=
current_block_offset
+
match
self
.
fragment
.
style
.
get_inheritedtable
(
)
.
border_collapse
{
border_collapse
:
:
T
:
:
separate
=
>
block_direction_spacing
border_collapse
:
:
T
:
:
collapse
=
>
{
child_table_row
.
collapsed_border_spacing
.
block_start
}
}
}
flow
:
:
mut_base
(
kid
)
.
position
.
start
.
b
=
current_block_offset
;
let
kid_base
=
flow
:
:
mut_base
(
kid
)
;
current_block_offset
=
current_block_offset
+
kid_base
.
position
.
size
.
block
;
}
let
mut
block_size
=
current_block_offset
-
block_start_border_padding
;
let
mut
candidate_block_size_iterator
=
CandidateBSizeIterator
:
:
new
(
&
self
.
fragment
self
.
base
.
block_container_explicit_block_size
)
;
while
let
Some
(
candidate_block_size
)
=
candidate_block_size_iterator
.
next
(
)
{
candidate_block_size_iterator
.
candidate_value
=
match
candidate_block_size
{
MaybeAuto
:
:
Auto
=
>
block_size
MaybeAuto
:
:
Specified
(
value
)
=
>
value
}
;
}
block_size
=
candidate_block_size_iterator
.
candidate_value
;
let
delta
=
block_size
-
(
current_block_offset
-
block_start_border_padding
)
;
current_block_offset
=
current_block_offset
+
delta
;
let
block_end_offset
=
self
.
fragment
.
border_padding
.
block_end
+
if
has_rows
{
block_direction_spacing
}
else
{
Au
(
0
)
}
;
current_block_offset
=
current_block_offset
+
block_end_offset
;
self
.
fragment
.
border_box
.
size
.
block
=
current_block_offset
;
self
.
fragment
.
border_box
.
start
.
b
=
Au
(
0
)
;
self
.
base
.
position
.
size
.
block
=
current_block_offset
;
for
kid
in
self
.
base
.
child_iter
(
)
{
flow
:
:
mut_base
(
kid
)
.
early_absolute_position_info
=
EarlyAbsolutePositionInfo
{
relative_containing_block_size
:
self
.
fragment
.
content_box
(
)
.
size
relative_containing_block_mode
:
self
.
fragment
.
style
(
)
.
writing_mode
}
;
}
}
self
.
base
.
restyle_damage
.
remove
(
REFLOW_OUT_OF_FLOW
|
REFLOW
)
;
}
}
struct
TableInlineCollapsedBorders
{
start
:
CollapsedBorder
end
:
CollapsedBorder
}
enum
PreviousBlockCollapsedBorders
{
FromPreviousRow
(
Vec
<
CollapsedBorder
>
)
FromTable
(
CollapsedBorder
)
}
enum
NextBlockCollapsedBorders
<
'
a
>
{
FromNextRow
(
&
'
a
[
CollapsedBorder
]
)
FromTable
(
CollapsedBorder
)
}
struct
TableRowIterator
<
'
a
>
{
kids
:
MutFlowListIterator
<
'
a
>
grandkids
:
Option
<
MutFlowListIterator
<
'
a
>
>
}
impl
<
'
a
>
TableRowIterator
<
'
a
>
{
fn
new
(
base
:
&
'
a
mut
BaseFlow
)
-
>
Self
{
TableRowIterator
{
kids
:
base
.
child_iter
(
)
grandkids
:
None
}
}
}
impl
<
'
a
>
Iterator
for
TableRowIterator
<
'
a
>
{
type
Item
=
&
'
a
mut
TableRowFlow
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
let
Some
(
ref
mut
grandkids
)
=
self
.
grandkids
{
if
let
Some
(
grandkid
)
=
grandkids
.
next
(
)
{
return
Some
(
grandkid
.
as_mut_table_row
(
)
)
}
}
self
.
grandkids
=
None
;
match
self
.
kids
.
next
(
)
{
Some
(
kid
)
=
>
{
if
kid
.
is_table_rowgroup
(
)
{
self
.
grandkids
=
Some
(
flow
:
:
mut_base
(
kid
)
.
child_iter
(
)
)
;
self
.
next
(
)
}
else
if
kid
.
is_table_row
(
)
{
Some
(
kid
.
as_mut_table_row
(
)
)
}
else
{
self
.
next
(
)
}
}
None
=
>
None
}
}
}
