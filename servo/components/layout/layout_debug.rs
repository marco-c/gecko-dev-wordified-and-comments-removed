#
!
[
macro_use
]
use
flow_ref
:
:
FlowRef
;
use
flow
;
use
serialize
:
:
json
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
old_io
:
:
File
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUint
Ordering
ATOMIC_UINT_INIT
}
;
thread_local
!
(
static
STATE_KEY
:
RefCell
<
Option
<
State
>
>
=
RefCell
:
:
new
(
None
)
)
;
static
mut
DEBUG_ID_COUNTER
:
AtomicUint
=
ATOMIC_UINT_INIT
;
pub
struct
Scope
;
#
[
macro_export
]
macro_rules
!
layout_debug_scope
(
(
(
arg
:
tt
)
*
)
=
>
(
if
cfg
!
(
not
(
ndebug
)
)
{
layout_debug
:
:
Scope
:
:
new
(
format
!
(
(
arg
)
*
)
)
}
else
{
layout_debug
:
:
Scope
}
)
)
;
#
[
derive
(
RustcEncodable
)
]
struct
ScopeData
{
name
:
String
pre
:
String
post
:
String
children
:
Vec
<
Box
<
ScopeData
>
>
}
impl
ScopeData
{
fn
new
(
name
:
String
pre
:
String
)
-
>
ScopeData
{
ScopeData
{
name
:
name
pre
:
pre
post
:
String
:
:
new
(
)
children
:
vec
!
(
)
}
}
}
struct
State
{
flow_root
:
FlowRef
scope_stack
:
Vec
<
Box
<
ScopeData
>
>
}
impl
Scope
{
pub
fn
new
(
name
:
String
)
-
>
Scope
{
STATE_KEY
.
with
(
|
ref
r
|
{
match
&
mut
*
r
.
borrow_mut
(
)
{
&
mut
Some
(
ref
mut
state
)
=
>
{
let
flow_trace
=
json
:
:
encode
(
&
flow
:
:
base
(
&
*
state
.
flow_root
)
)
.
unwrap
(
)
;
let
data
=
box
ScopeData
:
:
new
(
name
.
clone
(
)
flow_trace
)
;
state
.
scope_stack
.
push
(
data
)
;
}
&
mut
None
=
>
{
}
}
}
)
;
Scope
}
}
#
[
cfg
(
not
(
ndebug
)
)
]
impl
Drop
for
Scope
{
fn
drop
(
&
mut
self
)
{
STATE_KEY
.
with
(
|
ref
r
|
{
match
&
mut
*
r
.
borrow_mut
(
)
{
&
mut
Some
(
ref
mut
state
)
=
>
{
let
mut
current_scope
=
state
.
scope_stack
.
pop
(
)
.
unwrap
(
)
;
current_scope
.
post
=
json
:
:
encode
(
&
flow
:
:
base
(
&
*
state
.
flow_root
)
)
.
unwrap
(
)
;
let
previous_scope
=
state
.
scope_stack
.
last_mut
(
)
.
unwrap
(
)
;
previous_scope
.
children
.
push
(
current_scope
)
;
}
&
mut
None
=
>
{
}
}
}
)
;
}
}
#
[
allow
(
unsafe_blocks
)
]
pub
fn
generate_unique_debug_id
(
)
-
>
u16
{
unsafe
{
DEBUG_ID_COUNTER
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
as
u16
}
}
pub
fn
begin_trace
(
flow_root
:
FlowRef
)
{
assert
!
(
STATE_KEY
.
with
(
|
ref
r
|
r
.
borrow
(
)
.
is_none
(
)
)
)
;
STATE_KEY
.
with
(
|
ref
r
|
{
let
flow_trace
=
json
:
:
encode
(
&
flow
:
:
base
(
&
*
flow_root
)
)
.
unwrap
(
)
;
let
state
=
State
{
scope_stack
:
vec
!
[
box
ScopeData
:
:
new
(
"
root
"
.
to_owned
(
)
flow_trace
)
]
flow_root
:
flow_root
.
clone
(
)
}
;
*
r
.
borrow_mut
(
)
=
Some
(
state
)
;
}
)
;
}
pub
fn
end_trace
(
)
{
let
mut
task_state
=
STATE_KEY
.
with
(
|
ref
r
|
r
.
borrow_mut
(
)
.
take
(
)
.
unwrap
(
)
)
;
assert
!
(
task_state
.
scope_stack
.
len
(
)
=
=
1
)
;
let
mut
root_scope
=
task_state
.
scope_stack
.
pop
(
)
.
unwrap
(
)
;
root_scope
.
post
=
json
:
:
encode
(
&
flow
:
:
base
(
&
*
task_state
.
flow_root
)
)
.
unwrap
(
)
;
let
result
=
json
:
:
encode
(
&
root_scope
)
.
unwrap
(
)
;
let
path
=
Path
:
:
new
(
"
layout_trace
.
json
"
)
;
let
mut
file
=
File
:
:
create
(
&
path
)
.
unwrap
(
)
;
file
.
write_str
(
result
.
as_slice
(
)
)
.
unwrap
(
)
;
}
