#
!
[
allow
(
unsafe_code
)
]
use
css
:
:
matching
:
:
{
ApplicableDeclarationsCache
StyleSharingCandidateCache
}
;
use
canvas_traits
:
:
CanvasMsg
;
use
msg
:
:
compositor_msg
:
:
LayerId
;
use
geom
:
:
{
Rect
Size2D
}
;
use
gfx
:
:
display_list
:
:
OpaqueNode
;
use
gfx
:
:
font_cache_task
:
:
FontCacheTask
;
use
gfx
:
:
font_context
:
:
FontContext
;
use
msg
:
:
constellation_msg
:
:
ConstellationChan
;
use
net_traits
:
:
image
:
:
base
:
:
Image
;
use
net_traits
:
:
image_cache_task
:
:
{
ImageCacheChan
ImageCacheTask
ImageResponse
ImageState
}
;
use
net_traits
:
:
image_cache_task
:
:
{
UsePlaceholder
}
;
use
script
:
:
layout_interface
:
:
{
Animation
LayoutChan
ReflowGoal
}
;
use
std
:
:
boxed
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
collections
:
:
hash_state
:
:
DefaultState
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Sender
}
;
use
style
:
:
selector_matching
:
:
Stylist
;
use
url
:
:
Url
;
use
util
:
:
fnv
:
:
FnvHasher
;
use
util
:
:
geometry
:
:
Au
;
use
util
:
:
opts
;
struct
LocalLayoutContext
{
font_context
:
FontContext
applicable_declarations_cache
:
ApplicableDeclarationsCache
style_sharing_candidate_cache
:
StyleSharingCandidateCache
}
thread_local
!
(
static
LOCAL_CONTEXT_KEY
:
Cell
<
*
mut
LocalLayoutContext
>
=
Cell
:
:
new
(
ptr
:
:
null_mut
(
)
)
)
;
fn
create_or_get_local_context
(
shared_layout_context
:
&
SharedLayoutContext
)
-
>
*
mut
LocalLayoutContext
{
LOCAL_CONTEXT_KEY
.
with
(
|
ref
r
|
{
if
r
.
get
(
)
.
is_null
(
)
{
let
context
=
box
LocalLayoutContext
{
font_context
:
FontContext
:
:
new
(
shared_layout_context
.
font_cache_task
.
clone
(
)
)
applicable_declarations_cache
:
ApplicableDeclarationsCache
:
:
new
(
)
style_sharing_candidate_cache
:
StyleSharingCandidateCache
:
:
new
(
)
}
;
r
.
set
(
unsafe
{
boxed
:
:
into_raw
(
context
)
}
)
;
}
else
if
shared_layout_context
.
screen_size_changed
{
unsafe
{
(
*
r
.
get
(
)
)
.
applicable_declarations_cache
.
evict_all
(
)
;
}
}
r
.
get
(
)
}
)
}
pub
struct
SharedLayoutContext
{
pub
image_cache_task
:
ImageCacheTask
pub
image_cache_sender
:
ImageCacheChan
pub
screen_size
:
Size2D
<
Au
>
pub
screen_size_changed
:
bool
pub
constellation_chan
:
ConstellationChan
pub
layout_chan
:
LayoutChan
pub
font_cache_task
:
FontCacheTask
pub
stylist
:
*
const
Stylist
pub
reflow_root
:
Option
<
OpaqueNode
>
pub
url
:
Url
pub
dirty
:
Rect
<
Au
>
pub
generation
:
u32
pub
new_animations_sender
:
Sender
<
Animation
>
pub
canvas_layers_sender
:
Sender
<
(
LayerId
Option
<
Arc
<
Mutex
<
Sender
<
CanvasMsg
>
>
>
>
)
>
pub
visible_rects
:
Arc
<
HashMap
<
LayerId
Rect
<
Au
>
DefaultState
<
FnvHasher
>
>
>
pub
goal
:
ReflowGoal
}
pub
struct
SharedLayoutContextWrapper
(
pub
*
const
SharedLayoutContext
)
;
unsafe
impl
Send
for
SharedLayoutContextWrapper
{
}
pub
struct
LayoutContext
<
'
a
>
{
pub
shared
:
&
'
a
SharedLayoutContext
cached_local_layout_context
:
*
mut
LocalLayoutContext
}
impl
<
'
a
>
LayoutContext
<
'
a
>
{
pub
fn
new
(
shared_layout_context
:
&
'
a
SharedLayoutContext
)
-
>
LayoutContext
<
'
a
>
{
let
local_context
=
create_or_get_local_context
(
shared_layout_context
)
;
LayoutContext
{
shared
:
shared_layout_context
cached_local_layout_context
:
local_context
}
}
#
[
inline
(
always
)
]
pub
fn
font_context
<
'
b
>
(
&
'
b
self
)
-
>
&
'
b
mut
FontContext
{
unsafe
{
let
cached_context
=
&
mut
*
self
.
cached_local_layout_context
;
&
mut
cached_context
.
font_context
}
}
#
[
inline
(
always
)
]
pub
fn
applicable_declarations_cache
<
'
b
>
(
&
'
b
self
)
-
>
&
'
b
mut
ApplicableDeclarationsCache
{
unsafe
{
let
cached_context
=
&
mut
*
self
.
cached_local_layout_context
;
&
mut
cached_context
.
applicable_declarations_cache
}
}
#
[
inline
(
always
)
]
pub
fn
style_sharing_candidate_cache
<
'
b
>
(
&
'
b
self
)
-
>
&
'
b
mut
StyleSharingCandidateCache
{
unsafe
{
let
cached_context
=
&
mut
*
self
.
cached_local_layout_context
;
&
mut
cached_context
.
style_sharing_candidate_cache
}
}
pub
fn
get_or_request_image
(
&
self
url
:
Url
use_placeholder
:
UsePlaceholder
)
-
>
Option
<
Arc
<
Image
>
>
{
let
result
=
self
.
shared
.
image_cache_task
.
get_image_if_available
(
url
.
clone
(
)
use_placeholder
)
;
match
result
{
Ok
(
image
)
=
>
Some
(
image
)
Err
(
state
)
=
>
{
let
is_sync
=
opts
:
:
get
(
)
.
output_file
.
is_some
(
)
;
match
(
state
is_sync
)
{
(
ImageState
:
:
LoadError
_
)
=
>
None
(
_
true
)
=
>
{
let
(
sync_tx
sync_rx
)
=
channel
(
)
;
self
.
shared
.
image_cache_task
.
request_image
(
url
ImageCacheChan
(
sync_tx
)
None
)
;
match
sync_rx
.
recv
(
)
.
unwrap
(
)
.
image_response
{
ImageResponse
:
:
Loaded
(
image
)
|
ImageResponse
:
:
PlaceholderLoaded
(
image
)
=
>
Some
(
image
)
ImageResponse
:
:
None
=
>
None
}
}
(
ImageState
:
:
NotRequested
false
)
=
>
{
self
.
shared
.
image_cache_task
.
request_image
(
url
self
.
shared
.
image_cache_sender
.
clone
(
)
None
)
;
None
}
(
ImageState
:
:
Pending
false
)
=
>
None
}
}
}
}
}
