use
fnv
:
:
FnvHasher
;
use
gfx
:
:
display_list
:
:
{
WebRenderImageInfo
OpaqueNode
}
;
use
gfx
:
:
font_cache_thread
:
:
FontCacheThread
;
use
gfx
:
:
font_context
:
:
FontContext
;
use
heapsize
:
:
HeapSizeOf
;
use
net_traits
:
:
image_cache_thread
:
:
{
ImageCacheThread
ImageState
CanRequestImages
}
;
use
net_traits
:
:
image_cache_thread
:
:
{
ImageOrMetadataAvailable
UsePlaceholder
}
;
use
opaque_node
:
:
OpaqueNodeMethods
;
use
parking_lot
:
:
RwLock
;
use
script_layout_interface
:
:
{
PendingImage
PendingImageState
}
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
borrow
:
:
{
Borrow
BorrowMut
}
;
use
std
:
:
cell
:
:
{
RefCell
RefMut
}
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
hash
:
:
BuildHasherDefault
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
std
:
:
thread
;
use
style
:
:
context
:
:
{
SharedStyleContext
ThreadLocalStyleContext
}
;
use
style
:
:
dom
:
:
TElement
;
pub
struct
ScopedThreadLocalLayoutContext
<
E
:
TElement
>
{
pub
style_context
:
ThreadLocalStyleContext
<
E
>
}
impl
<
E
:
TElement
>
ScopedThreadLocalLayoutContext
<
E
>
{
pub
fn
new
(
context
:
&
LayoutContext
)
-
>
Self
{
ScopedThreadLocalLayoutContext
{
style_context
:
ThreadLocalStyleContext
:
:
new
(
&
context
.
style_context
)
}
}
}
impl
<
E
:
TElement
>
Borrow
<
ThreadLocalStyleContext
<
E
>
>
for
ScopedThreadLocalLayoutContext
<
E
>
{
fn
borrow
(
&
self
)
-
>
&
ThreadLocalStyleContext
<
E
>
{
&
self
.
style_context
}
}
impl
<
E
:
TElement
>
BorrowMut
<
ThreadLocalStyleContext
<
E
>
>
for
ScopedThreadLocalLayoutContext
<
E
>
{
fn
borrow_mut
(
&
mut
self
)
-
>
&
mut
ThreadLocalStyleContext
<
E
>
{
&
mut
self
.
style_context
}
}
thread_local
!
(
static
FONT_CONTEXT_KEY
:
RefCell
<
Option
<
FontContext
>
>
=
RefCell
:
:
new
(
None
)
)
;
pub
fn
with_thread_local_font_context
<
F
R
>
(
layout_context
:
&
LayoutContext
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
FontContext
)
-
>
R
{
FONT_CONTEXT_KEY
.
with
(
|
k
|
{
let
mut
font_context
=
k
.
borrow_mut
(
)
;
if
font_context
.
is_none
(
)
{
let
font_cache_thread
=
layout_context
.
font_cache_thread
.
lock
(
)
.
unwrap
(
)
.
clone
(
)
;
*
font_context
=
Some
(
FontContext
:
:
new
(
font_cache_thread
)
)
;
}
f
(
&
mut
RefMut
:
:
map
(
font_context
|
x
|
x
.
as_mut
(
)
.
unwrap
(
)
)
)
}
)
}
pub
fn
heap_size_of_persistent_local_context
(
)
-
>
usize
{
FONT_CONTEXT_KEY
.
with
(
|
r
|
{
if
let
Some
(
ref
context
)
=
*
r
.
borrow
(
)
{
context
.
heap_size_of_children
(
)
}
else
{
0
}
}
)
}
pub
struct
LayoutContext
{
pub
style_context
:
SharedStyleContext
pub
image_cache_thread
:
Mutex
<
ImageCacheThread
>
pub
font_cache_thread
:
Mutex
<
FontCacheThread
>
pub
webrender_image_cache
:
Arc
<
RwLock
<
HashMap
<
(
ServoUrl
UsePlaceholder
)
WebRenderImageInfo
BuildHasherDefault
<
FnvHasher
>
>
>
>
pub
pending_images
:
Option
<
Mutex
<
Vec
<
PendingImage
>
>
>
}
impl
Drop
for
LayoutContext
{
fn
drop
(
&
mut
self
)
{
if
!
thread
:
:
panicking
(
)
{
if
let
Some
(
ref
pending_images
)
=
self
.
pending_images
{
assert
!
(
pending_images
.
lock
(
)
.
unwrap
(
)
.
is_empty
(
)
)
;
}
}
}
}
impl
LayoutContext
{
#
[
inline
(
always
)
]
pub
fn
shared_context
(
&
self
)
-
>
&
SharedStyleContext
{
&
self
.
style_context
}
pub
fn
get_or_request_image_or_meta
(
&
self
node
:
OpaqueNode
url
:
ServoUrl
use_placeholder
:
UsePlaceholder
)
-
>
Option
<
ImageOrMetadataAvailable
>
{
let
can_request
=
if
self
.
pending_images
.
is_some
(
)
{
CanRequestImages
:
:
Yes
}
else
{
CanRequestImages
:
:
No
}
;
let
result
=
self
.
image_cache_thread
.
lock
(
)
.
unwrap
(
)
.
find_image_or_metadata
(
url
.
clone
(
)
use_placeholder
can_request
)
;
match
result
{
Ok
(
image_or_metadata
)
=
>
Some
(
image_or_metadata
)
Err
(
ImageState
:
:
LoadError
)
=
>
None
Err
(
ImageState
:
:
NotRequested
(
id
)
)
=
>
{
let
image
=
PendingImage
{
state
:
PendingImageState
:
:
Unrequested
(
url
)
node
:
node
.
to_untrusted_node_address
(
)
id
:
id
}
;
self
.
pending_images
.
as_ref
(
)
.
unwrap
(
)
.
lock
(
)
.
unwrap
(
)
.
push
(
image
)
;
None
}
Err
(
ImageState
:
:
Pending
(
id
)
)
=
>
{
if
let
Some
(
ref
pending_images
)
=
self
.
pending_images
{
let
image
=
PendingImage
{
state
:
PendingImageState
:
:
PendingResponse
node
:
node
.
to_untrusted_node_address
(
)
id
:
id
}
;
pending_images
.
lock
(
)
.
unwrap
(
)
.
push
(
image
)
;
}
None
}
}
}
pub
fn
get_webrender_image_for_url
(
&
self
node
:
OpaqueNode
url
:
ServoUrl
use_placeholder
:
UsePlaceholder
)
-
>
Option
<
WebRenderImageInfo
>
{
if
let
Some
(
existing_webrender_image
)
=
self
.
webrender_image_cache
.
read
(
)
.
get
(
&
(
url
.
clone
(
)
use_placeholder
)
)
{
return
Some
(
(
*
existing_webrender_image
)
.
clone
(
)
)
}
match
self
.
get_or_request_image_or_meta
(
node
url
.
clone
(
)
use_placeholder
)
{
Some
(
ImageOrMetadataAvailable
:
:
ImageAvailable
(
image
)
)
=
>
{
let
image_info
=
WebRenderImageInfo
:
:
from_image
(
&
*
image
)
;
if
image_info
.
key
.
is_none
(
)
{
Some
(
image_info
)
}
else
{
let
mut
webrender_image_cache
=
self
.
webrender_image_cache
.
write
(
)
;
webrender_image_cache
.
insert
(
(
url
use_placeholder
)
image_info
)
;
Some
(
image_info
)
}
}
None
|
Some
(
ImageOrMetadataAvailable
:
:
MetadataAvailable
(
_
)
)
=
>
None
}
}
}
