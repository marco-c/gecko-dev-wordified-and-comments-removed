#
!
[
allow
(
unsafe_code
)
]
use
fnv
:
:
FnvHasher
;
use
gfx
:
:
display_list
:
:
WebRenderImageInfo
;
use
gfx
:
:
font_cache_thread
:
:
FontCacheThread
;
use
gfx
:
:
font_context
:
:
FontContext
;
use
heapsize
:
:
HeapSizeOf
;
use
ipc_channel
:
:
ipc
;
use
net_traits
:
:
image
:
:
base
:
:
Image
;
use
net_traits
:
:
image_cache_thread
:
:
{
ImageCacheChan
ImageCacheThread
ImageResponse
ImageState
}
;
use
net_traits
:
:
image_cache_thread
:
:
{
ImageOrMetadataAvailable
UsePlaceholder
}
;
use
parking_lot
:
:
RwLock
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
cell
:
:
{
RefCell
RefMut
}
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
hash
:
:
BuildHasherDefault
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
style
:
:
context
:
:
{
LocalStyleContext
StyleContext
SharedStyleContext
}
;
use
util
:
:
opts
;
struct
LocalLayoutContext
{
style_context
:
LocalStyleContext
font_context
:
RefCell
<
FontContext
>
}
impl
HeapSizeOf
for
LocalLayoutContext
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
self
.
font_context
.
heap_size_of_children
(
)
}
}
thread_local
!
(
static
LOCAL_CONTEXT_KEY
:
RefCell
<
Option
<
Rc
<
LocalLayoutContext
>
>
>
=
RefCell
:
:
new
(
None
)
)
;
pub
fn
heap_size_of_local_context
(
)
-
>
usize
{
LOCAL_CONTEXT_KEY
.
with
(
|
r
|
{
r
.
borrow
(
)
.
clone
(
)
.
map_or
(
0
|
context
|
context
.
heap_size_of_children
(
)
)
}
)
}
fn
create_or_get_local_context
(
shared_layout_context
:
&
SharedLayoutContext
)
-
>
Rc
<
LocalLayoutContext
>
{
LOCAL_CONTEXT_KEY
.
with
(
|
r
|
{
let
mut
r
=
r
.
borrow_mut
(
)
;
if
let
Some
(
context
)
=
r
.
clone
(
)
{
context
}
else
{
let
font_cache_thread
=
shared_layout_context
.
font_cache_thread
.
lock
(
)
.
unwrap
(
)
.
clone
(
)
;
let
local_style_data
=
shared_layout_context
.
style_context
.
local_context_creation_data
.
lock
(
)
.
unwrap
(
)
;
let
context
=
Rc
:
:
new
(
LocalLayoutContext
{
style_context
:
LocalStyleContext
:
:
new
(
&
local_style_data
)
font_context
:
RefCell
:
:
new
(
FontContext
:
:
new
(
font_cache_thread
)
)
}
)
;
*
r
=
Some
(
context
.
clone
(
)
)
;
context
}
}
)
}
pub
struct
SharedLayoutContext
{
pub
style_context
:
SharedStyleContext
pub
image_cache_thread
:
Mutex
<
ImageCacheThread
>
pub
image_cache_sender
:
Mutex
<
ImageCacheChan
>
pub
font_cache_thread
:
Mutex
<
FontCacheThread
>
pub
webrender_image_cache
:
Arc
<
RwLock
<
HashMap
<
(
ServoUrl
UsePlaceholder
)
WebRenderImageInfo
BuildHasherDefault
<
FnvHasher
>
>
>
>
}
pub
struct
LayoutContext
<
'
a
>
{
pub
shared
:
&
'
a
SharedLayoutContext
cached_local_layout_context
:
Rc
<
LocalLayoutContext
>
}
impl
<
'
a
>
StyleContext
<
'
a
>
for
LayoutContext
<
'
a
>
{
fn
shared_context
(
&
self
)
-
>
&
'
a
SharedStyleContext
{
&
self
.
shared
.
style_context
}
fn
local_context
(
&
self
)
-
>
&
LocalStyleContext
{
&
self
.
cached_local_layout_context
.
style_context
}
}
impl
<
'
a
>
LayoutContext
<
'
a
>
{
pub
fn
new
(
shared_layout_context
:
&
'
a
SharedLayoutContext
)
-
>
LayoutContext
<
'
a
>
{
let
local_context
=
create_or_get_local_context
(
shared_layout_context
)
;
LayoutContext
{
shared
:
shared_layout_context
cached_local_layout_context
:
local_context
}
}
#
[
inline
(
always
)
]
pub
fn
style_context
(
&
self
)
-
>
&
SharedStyleContext
{
&
self
.
shared
.
style_context
}
#
[
inline
(
always
)
]
pub
fn
font_context
(
&
self
)
-
>
RefMut
<
FontContext
>
{
self
.
cached_local_layout_context
.
font_context
.
borrow_mut
(
)
}
}
impl
SharedLayoutContext
{
fn
get_or_request_image_synchronously
(
&
self
url
:
ServoUrl
use_placeholder
:
UsePlaceholder
)
-
>
Option
<
Arc
<
Image
>
>
{
debug_assert
!
(
opts
:
:
get
(
)
.
output_file
.
is_some
(
)
|
|
opts
:
:
get
(
)
.
exit_after_load
)
;
let
result
=
self
.
image_cache_thread
.
lock
(
)
.
unwrap
(
)
.
find_image
(
url
.
clone
(
)
use_placeholder
)
;
match
result
{
Ok
(
image
)
=
>
return
Some
(
image
)
Err
(
ImageState
:
:
LoadError
)
=
>
{
return
None
}
Err
(
_
)
=
>
{
}
}
let
(
sync_tx
sync_rx
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
self
.
image_cache_thread
.
lock
(
)
.
unwrap
(
)
.
request_image
(
url
ImageCacheChan
(
sync_tx
)
None
)
;
loop
{
match
sync_rx
.
recv
(
)
{
Err
(
_
)
=
>
return
None
Ok
(
response
)
=
>
{
match
response
.
image_response
{
ImageResponse
:
:
Loaded
(
image
)
|
ImageResponse
:
:
PlaceholderLoaded
(
image
)
=
>
{
return
Some
(
image
)
}
ImageResponse
:
:
None
|
ImageResponse
:
:
MetadataLoaded
(
_
)
=
>
{
}
}
}
}
}
}
pub
fn
get_or_request_image_or_meta
(
&
self
url
:
ServoUrl
use_placeholder
:
UsePlaceholder
)
-
>
Option
<
ImageOrMetadataAvailable
>
{
if
opts
:
:
get
(
)
.
output_file
.
is_some
(
)
|
|
opts
:
:
get
(
)
.
exit_after_load
{
return
self
.
get_or_request_image_synchronously
(
url
use_placeholder
)
.
map
(
|
img
|
ImageOrMetadataAvailable
:
:
ImageAvailable
(
img
)
)
;
}
let
result
=
self
.
image_cache_thread
.
lock
(
)
.
unwrap
(
)
.
find_image_or_metadata
(
url
.
clone
(
)
use_placeholder
)
;
match
result
{
Ok
(
image_or_metadata
)
=
>
Some
(
image_or_metadata
)
Err
(
ImageState
:
:
LoadError
)
=
>
None
Err
(
ImageState
:
:
NotRequested
)
=
>
{
let
sender
=
self
.
image_cache_sender
.
lock
(
)
.
unwrap
(
)
.
clone
(
)
;
self
.
image_cache_thread
.
lock
(
)
.
unwrap
(
)
.
request_image_and_metadata
(
url
sender
None
)
;
None
}
Err
(
ImageState
:
:
Pending
)
=
>
None
}
}
pub
fn
get_webrender_image_for_url
(
&
self
url
:
ServoUrl
use_placeholder
:
UsePlaceholder
)
-
>
Option
<
WebRenderImageInfo
>
{
if
let
Some
(
existing_webrender_image
)
=
self
.
webrender_image_cache
.
read
(
)
.
get
(
&
(
url
.
clone
(
)
use_placeholder
)
)
{
return
Some
(
(
*
existing_webrender_image
)
.
clone
(
)
)
}
match
self
.
get_or_request_image_or_meta
(
url
.
clone
(
)
use_placeholder
)
{
Some
(
ImageOrMetadataAvailable
:
:
ImageAvailable
(
image
)
)
=
>
{
let
image_info
=
WebRenderImageInfo
:
:
from_image
(
&
*
image
)
;
if
image_info
.
key
.
is_none
(
)
{
Some
(
image_info
)
}
else
{
let
mut
webrender_image_cache
=
self
.
webrender_image_cache
.
write
(
)
;
webrender_image_cache
.
insert
(
(
url
use_placeholder
)
image_info
)
;
Some
(
image_info
)
}
}
None
|
Some
(
ImageOrMetadataAvailable
:
:
MetadataAvailable
(
_
)
)
=
>
None
}
}
}
