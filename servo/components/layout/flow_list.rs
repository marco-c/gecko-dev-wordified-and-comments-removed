use
flow
:
:
Flow
;
use
flow_ref
:
:
FlowRef
;
use
std
:
:
collections
:
:
{
dlist
DList
}
;
pub
struct
FlowList
{
flows
:
DList
<
FlowRef
>
}
pub
struct
FlowListIterator
<
'
a
>
{
it
:
dlist
:
:
Iter
<
'
a
FlowRef
>
}
pub
struct
MutFlowListIterator
<
'
a
>
{
it
:
dlist
:
:
IterMut
<
'
a
FlowRef
>
}
impl
FlowList
{
#
[
inline
]
pub
fn
front
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
&
'
a
Flow
>
{
self
.
flows
.
front
(
)
.
map
(
|
head
|
&
*
*
head
)
}
#
[
inline
]
pub
unsafe
fn
front_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
Option
<
&
'
a
mut
Flow
>
{
self
.
flows
.
front_mut
(
)
.
map
(
|
head
|
&
mut
*
*
head
)
}
#
[
inline
]
pub
fn
back
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
&
'
a
Flow
>
{
self
.
flows
.
back
(
)
.
map
(
|
tail
|
&
*
*
tail
)
}
#
[
inline
]
pub
unsafe
fn
back_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
Option
<
&
'
a
mut
Flow
>
{
self
.
flows
.
back_mut
(
)
.
map
(
|
tail
|
&
mut
*
*
tail
)
}
pub
fn
push_front
(
&
mut
self
new_head
:
FlowRef
)
{
self
.
flows
.
push_front
(
new_head
)
;
}
pub
fn
pop_front
(
&
mut
self
)
-
>
Option
<
FlowRef
>
{
self
.
flows
.
pop_front
(
)
}
pub
fn
push_back
(
&
mut
self
new_tail
:
FlowRef
)
{
self
.
flows
.
push_back
(
new_tail
)
;
}
#
[
inline
]
pub
fn
new
(
)
-
>
FlowList
{
FlowList
{
flows
:
DList
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
iter
<
'
a
>
(
&
'
a
self
)
-
>
FlowListIterator
<
'
a
>
{
FlowListIterator
{
it
:
self
.
flows
.
iter
(
)
}
}
#
[
inline
]
pub
fn
iter_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
MutFlowListIterator
<
'
a
>
{
MutFlowListIterator
{
it
:
self
.
flows
.
iter_mut
(
)
}
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
flows
.
is_empty
(
)
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
uint
{
self
.
flows
.
len
(
)
}
}
impl
<
'
a
>
Iterator
for
FlowListIterator
<
'
a
>
{
type
Item
=
&
'
a
(
Flow
+
'
a
)
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
(
Flow
+
'
a
)
>
{
self
.
it
.
next
(
)
.
map
(
|
x
|
&
*
*
x
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
uint
Option
<
uint
>
)
{
self
.
it
.
size_hint
(
)
}
}
impl
<
'
a
>
Iterator
for
MutFlowListIterator
<
'
a
>
{
type
Item
=
&
'
a
mut
(
Flow
+
'
a
)
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
mut
(
Flow
+
'
a
)
>
{
self
.
it
.
next
(
)
.
map
(
|
x
|
&
mut
*
*
x
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
uint
Option
<
uint
>
)
{
self
.
it
.
size_hint
(
)
}
}
