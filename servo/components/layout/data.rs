#
!
[
allow
(
unsafe_code
)
]
use
construct
:
:
{
ConstructionItem
ConstructionResult
}
;
use
incremental
:
:
RestyleDamage
;
use
msg
:
:
constellation_msg
:
:
ConstellationChan
;
use
parallel
:
:
DomParallelInfo
;
use
script
:
:
dom
:
:
node
:
:
SharedLayoutData
;
use
script
:
:
layout_interface
:
:
LayoutChan
;
use
std
:
:
cell
:
:
{
Ref
RefMut
}
;
use
std
:
:
mem
;
use
std
:
:
sync
:
:
Arc
;
use
style
:
:
properties
:
:
ComputedValues
;
use
wrapper
:
:
{
LayoutNode
TLayoutNode
}
;
pub
struct
PrivateLayoutData
{
pub
before_style
:
Option
<
Arc
<
ComputedValues
>
>
pub
after_style
:
Option
<
Arc
<
ComputedValues
>
>
pub
restyle_damage
:
RestyleDamage
pub
flow_construction_result
:
ConstructionResult
pub
before_flow_construction_result
:
ConstructionResult
pub
after_flow_construction_result
:
ConstructionResult
pub
parallel
:
DomParallelInfo
pub
flags
:
LayoutDataFlags
}
impl
PrivateLayoutData
{
pub
fn
new
(
)
-
>
PrivateLayoutData
{
PrivateLayoutData
{
before_style
:
None
after_style
:
None
restyle_damage
:
RestyleDamage
:
:
empty
(
)
flow_construction_result
:
ConstructionResult
:
:
None
before_flow_construction_result
:
ConstructionResult
:
:
None
after_flow_construction_result
:
ConstructionResult
:
:
None
parallel
:
DomParallelInfo
:
:
new
(
)
flags
:
LayoutDataFlags
:
:
empty
(
)
}
}
}
bitflags
!
{
flags
LayoutDataFlags
:
u8
{
#
[
doc
=
"
Whether
a
flow
has
been
newly
constructed
.
"
]
const
HAS_NEWLY_CONSTRUCTED_FLOW
=
0x01
}
}
pub
struct
LayoutDataWrapper
{
pub
chan
:
Option
<
LayoutChan
>
pub
shared_data
:
SharedLayoutData
pub
data
:
Box
<
PrivateLayoutData
>
}
impl
LayoutDataWrapper
{
pub
fn
remove_compositor_layers
(
&
self
constellation_chan
:
ConstellationChan
)
{
match
self
.
data
.
flow_construction_result
{
ConstructionResult
:
:
None
=
>
{
}
ConstructionResult
:
:
Flow
(
ref
flow_ref
_
)
=
>
{
flow_ref
.
remove_compositor_layers
(
constellation_chan
)
;
}
ConstructionResult
:
:
ConstructionItem
(
ref
construction_item
)
=
>
{
match
construction_item
{
&
ConstructionItem
:
:
InlineFragments
(
ref
inline_fragments
)
=
>
{
for
fragment
in
inline_fragments
.
fragments
.
fragments
.
iter
(
)
{
fragment
.
remove_compositor_layers
(
constellation_chan
.
clone
(
)
)
;
}
}
&
ConstructionItem
:
:
Whitespace
(
.
.
)
=
>
{
}
&
ConstructionItem
:
:
TableColumnFragment
(
ref
fragment
)
=
>
{
fragment
.
remove_compositor_layers
(
constellation_chan
.
clone
(
)
)
;
}
}
}
}
}
}
#
[
allow
(
dead_code
)
]
fn
static_assertion
(
x
:
Option
<
LayoutDataWrapper
>
)
{
unsafe
{
let
_
:
Option
<
:
:
script
:
:
dom
:
:
node
:
:
LayoutData
>
=
:
:
std
:
:
intrinsics
:
:
transmute
(
x
)
;
}
}
pub
trait
LayoutDataAccess
{
unsafe
fn
borrow_layout_data_unchecked
(
&
self
)
-
>
*
const
Option
<
LayoutDataWrapper
>
;
fn
borrow_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
Option
<
LayoutDataWrapper
>
>
;
fn
mutate_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
Option
<
LayoutDataWrapper
>
>
;
}
impl
<
'
ln
>
LayoutDataAccess
for
LayoutNode
<
'
ln
>
{
#
[
inline
(
always
)
]
unsafe
fn
borrow_layout_data_unchecked
(
&
self
)
-
>
*
const
Option
<
LayoutDataWrapper
>
{
mem
:
:
transmute
(
self
.
get
(
)
.
layout_data_unchecked
(
)
)
}
#
[
inline
(
always
)
]
fn
borrow_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
Option
<
LayoutDataWrapper
>
>
{
unsafe
{
mem
:
:
transmute
(
self
.
get
(
)
.
layout_data
(
)
)
}
}
#
[
inline
(
always
)
]
fn
mutate_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
Option
<
LayoutDataWrapper
>
>
{
unsafe
{
mem
:
:
transmute
(
self
.
get
(
)
.
layout_data_mut
(
)
)
}
}
}
