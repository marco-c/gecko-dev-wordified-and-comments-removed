#
!
[
deny
(
unsafe_block
)
]
use
fragment
:
:
Fragment
;
use
style
:
:
computed_values
as
computed
;
use
geom
:
:
SideOffsets2D
;
use
style
:
:
computed_values
:
:
{
LPA_Auto
LPA_Length
LPA_Percentage
LP_Length
LP_Percentage
}
;
use
style
:
:
ComputedValues
;
use
servo_util
:
:
geometry
:
:
Au
;
use
servo_util
:
:
logical_geometry
:
:
LogicalMargin
;
use
std
:
:
cmp
:
:
{
max
min
}
;
use
std
:
:
fmt
;
pub
struct
AdjoiningMargins
{
pub
most_positive
:
Au
pub
most_negative
:
Au
}
impl
AdjoiningMargins
{
pub
fn
new
(
)
-
>
AdjoiningMargins
{
AdjoiningMargins
{
most_positive
:
Au
(
0
)
most_negative
:
Au
(
0
)
}
}
pub
fn
from_margin
(
margin_value
:
Au
)
-
>
AdjoiningMargins
{
if
margin_value
>
=
Au
(
0
)
{
AdjoiningMargins
{
most_positive
:
margin_value
most_negative
:
Au
(
0
)
}
}
else
{
AdjoiningMargins
{
most_positive
:
Au
(
0
)
most_negative
:
margin_value
}
}
}
pub
fn
union
(
&
mut
self
other
:
AdjoiningMargins
)
{
self
.
most_positive
=
max
(
self
.
most_positive
other
.
most_positive
)
;
self
.
most_negative
=
min
(
self
.
most_negative
other
.
most_negative
)
}
pub
fn
collapse
(
&
self
)
-
>
Au
{
self
.
most_positive
+
self
.
most_negative
}
}
pub
enum
CollapsibleMargins
{
NoCollapsibleMargins
(
Au
Au
)
MarginsCollapse
(
AdjoiningMargins
AdjoiningMargins
)
MarginsCollapseThrough
(
AdjoiningMargins
)
}
impl
CollapsibleMargins
{
pub
fn
new
(
)
-
>
CollapsibleMargins
{
NoCollapsibleMargins
(
Au
(
0
)
Au
(
0
)
)
}
}
enum
FinalMarginState
{
MarginsCollapseThroughFinalMarginState
BottomMarginCollapsesFinalMarginState
}
pub
struct
MarginCollapseInfo
{
pub
state
:
MarginCollapseState
pub
block_start_margin
:
AdjoiningMargins
pub
margin_in
:
AdjoiningMargins
}
impl
MarginCollapseInfo
{
pub
fn
new
(
)
-
>
MarginCollapseInfo
{
MarginCollapseInfo
{
state
:
AccumulatingCollapsibleTopMargin
block_start_margin
:
AdjoiningMargins
:
:
new
(
)
margin_in
:
AdjoiningMargins
:
:
new
(
)
}
}
pub
fn
initialize_block_start_margin
(
&
mut
self
fragment
:
&
Fragment
can_collapse_block_start_margin_with_kids
:
bool
)
{
if
!
can_collapse_block_start_margin_with_kids
{
self
.
state
=
AccumulatingMarginIn
}
self
.
block_start_margin
=
AdjoiningMargins
:
:
from_margin
(
fragment
.
margin
.
block_start
)
}
pub
fn
finish_and_compute_collapsible_margins
(
mut
self
fragment
:
&
Fragment
can_collapse_block_end_margin_with_kids
:
bool
)
-
>
(
CollapsibleMargins
Au
)
{
let
state
=
match
self
.
state
{
AccumulatingCollapsibleTopMargin
=
>
{
match
fragment
.
style
(
)
.
content_block_size
(
)
{
LPA_Auto
|
LPA_Length
(
Au
(
0
)
)
|
LPA_Percentage
(
0
.
)
=
>
{
match
fragment
.
style
(
)
.
min_block_size
(
)
{
LP_Length
(
Au
(
0
)
)
|
LP_Percentage
(
0
.
)
=
>
{
MarginsCollapseThroughFinalMarginState
}
_
=
>
{
BottomMarginCollapsesFinalMarginState
}
}
}
_
=
>
{
BottomMarginCollapsesFinalMarginState
}
}
}
AccumulatingMarginIn
=
>
BottomMarginCollapsesFinalMarginState
}
;
let
block_end_margin
=
fragment
.
margin
.
block_end
;
if
!
can_collapse_block_end_margin_with_kids
{
match
state
{
MarginsCollapseThroughFinalMarginState
=
>
{
let
advance
=
self
.
block_start_margin
.
collapse
(
)
;
self
.
margin_in
.
union
(
AdjoiningMargins
:
:
from_margin
(
block_end_margin
)
)
;
(
MarginsCollapse
(
self
.
block_start_margin
self
.
margin_in
)
advance
)
}
BottomMarginCollapsesFinalMarginState
=
>
{
let
advance
=
self
.
margin_in
.
collapse
(
)
;
self
.
margin_in
.
union
(
AdjoiningMargins
:
:
from_margin
(
block_end_margin
)
)
;
(
MarginsCollapse
(
self
.
block_start_margin
self
.
margin_in
)
advance
)
}
}
}
else
{
match
state
{
MarginsCollapseThroughFinalMarginState
=
>
{
self
.
block_start_margin
.
union
(
AdjoiningMargins
:
:
from_margin
(
block_end_margin
)
)
;
(
MarginsCollapseThrough
(
self
.
block_start_margin
)
Au
(
0
)
)
}
BottomMarginCollapsesFinalMarginState
=
>
{
self
.
margin_in
.
union
(
AdjoiningMargins
:
:
from_margin
(
block_end_margin
)
)
;
(
MarginsCollapse
(
self
.
block_start_margin
self
.
margin_in
)
Au
(
0
)
)
}
}
}
}
pub
fn
current_float_ceiling
(
&
mut
self
)
-
>
Au
{
match
self
.
state
{
AccumulatingCollapsibleTopMargin
=
>
self
.
block_start_margin
.
collapse
(
)
AccumulatingMarginIn
=
>
self
.
margin_in
.
collapse
(
)
}
}
pub
fn
advance_block_start_margin
(
&
mut
self
child_collapsible_margins
:
&
CollapsibleMargins
)
-
>
Au
{
match
(
self
.
state
*
child_collapsible_margins
)
{
(
AccumulatingCollapsibleTopMargin
NoCollapsibleMargins
(
block_start
_
)
)
=
>
{
self
.
state
=
AccumulatingMarginIn
;
block_start
}
(
AccumulatingCollapsibleTopMargin
MarginsCollapse
(
block_start
_
)
)
=
>
{
self
.
block_start_margin
.
union
(
block_start
)
;
self
.
state
=
AccumulatingMarginIn
;
Au
(
0
)
}
(
AccumulatingMarginIn
NoCollapsibleMargins
(
block_start
_
)
)
=
>
{
let
previous_margin_value
=
self
.
margin_in
.
collapse
(
)
;
self
.
margin_in
=
AdjoiningMargins
:
:
new
(
)
;
previous_margin_value
+
block_start
}
(
AccumulatingMarginIn
MarginsCollapse
(
block_start
_
)
)
=
>
{
self
.
margin_in
.
union
(
block_start
)
;
let
margin_value
=
self
.
margin_in
.
collapse
(
)
;
self
.
margin_in
=
AdjoiningMargins
:
:
new
(
)
;
margin_value
}
(
_
MarginsCollapseThrough
(
_
)
)
=
>
{
Au
(
0
)
}
}
}
pub
fn
advance_block_end_margin
(
&
mut
self
child_collapsible_margins
:
&
CollapsibleMargins
)
-
>
Au
{
match
(
self
.
state
*
child_collapsible_margins
)
{
(
AccumulatingCollapsibleTopMargin
NoCollapsibleMargins
(
.
.
)
)
|
(
AccumulatingCollapsibleTopMargin
MarginsCollapse
(
.
.
)
)
=
>
{
fail
!
(
"
should
not
be
accumulating
collapsible
block_start
margins
anymore
!
"
)
}
(
AccumulatingCollapsibleTopMargin
MarginsCollapseThrough
(
margin
)
)
=
>
{
self
.
block_start_margin
.
union
(
margin
)
;
Au
(
0
)
}
(
AccumulatingMarginIn
NoCollapsibleMargins
(
_
block_end
)
)
=
>
{
assert_eq
!
(
self
.
margin_in
.
most_positive
Au
(
0
)
)
;
assert_eq
!
(
self
.
margin_in
.
most_negative
Au
(
0
)
)
;
block_end
}
(
AccumulatingMarginIn
MarginsCollapse
(
_
block_end
)
)
|
(
AccumulatingMarginIn
MarginsCollapseThrough
(
block_end
)
)
=
>
{
self
.
margin_in
.
union
(
block_end
)
;
Au
(
0
)
}
}
}
}
pub
enum
MarginCollapseState
{
AccumulatingCollapsibleTopMargin
AccumulatingMarginIn
}
#
[
deriving
(
Encodable
)
]
pub
struct
IntrinsicISizes
{
pub
minimum_inline_size
:
Au
pub
preferred_inline_size
:
Au
pub
surround_inline_size
:
Au
}
impl
fmt
:
:
Show
for
IntrinsicISizes
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
min
=
{
}
pref
=
{
}
surr
=
{
}
"
self
.
minimum_inline_size
self
.
preferred_inline_size
self
.
surround_inline_size
)
}
}
impl
IntrinsicISizes
{
pub
fn
new
(
)
-
>
IntrinsicISizes
{
IntrinsicISizes
{
minimum_inline_size
:
Au
(
0
)
preferred_inline_size
:
Au
(
0
)
surround_inline_size
:
Au
(
0
)
}
}
pub
fn
total_minimum_inline_size
(
&
self
)
-
>
Au
{
self
.
minimum_inline_size
+
self
.
surround_inline_size
}
pub
fn
total_preferred_inline_size
(
&
self
)
-
>
Au
{
self
.
preferred_inline_size
+
self
.
surround_inline_size
}
}
pub
enum
MaybeAuto
{
Auto
Specified
(
Au
)
}
impl
MaybeAuto
{
#
[
inline
]
pub
fn
from_style
(
length
:
computed
:
:
LengthOrPercentageOrAuto
containing_length
:
Au
)
-
>
MaybeAuto
{
match
length
{
computed
:
:
LPA_Auto
=
>
Auto
computed
:
:
LPA_Percentage
(
percent
)
=
>
Specified
(
containing_length
.
scale_by
(
percent
)
)
computed
:
:
LPA_Length
(
length
)
=
>
Specified
(
length
)
}
}
#
[
inline
]
pub
fn
specified_or_default
(
&
self
default
:
Au
)
-
>
Au
{
match
*
self
{
Auto
=
>
default
Specified
(
value
)
=
>
value
}
}
#
[
inline
]
pub
fn
specified_or_zero
(
&
self
)
-
>
Au
{
self
.
specified_or_default
(
Au
:
:
new
(
0
)
)
}
}
pub
fn
specified_or_none
(
length
:
computed
:
:
LengthOrPercentageOrNone
containing_length
:
Au
)
-
>
Option
<
Au
>
{
match
length
{
computed
:
:
LPN_None
=
>
None
computed
:
:
LPN_Percentage
(
percent
)
=
>
Some
(
containing_length
.
scale_by
(
percent
)
)
computed
:
:
LPN_Length
(
length
)
=
>
Some
(
length
)
}
}
pub
fn
specified
(
length
:
computed
:
:
LengthOrPercentage
containing_length
:
Au
)
-
>
Au
{
match
length
{
computed
:
:
LP_Length
(
length
)
=
>
length
computed
:
:
LP_Percentage
(
p
)
=
>
containing_length
.
scale_by
(
p
)
}
}
#
[
inline
]
pub
fn
padding_from_style
(
style
:
&
ComputedValues
containing_block_inline_size
:
Au
)
-
>
LogicalMargin
<
Au
>
{
let
padding_style
=
style
.
get_padding
(
)
;
LogicalMargin
:
:
from_physical
(
style
.
writing_mode
SideOffsets2D
:
:
new
(
specified
(
padding_style
.
padding_top
containing_block_inline_size
)
specified
(
padding_style
.
padding_right
containing_block_inline_size
)
specified
(
padding_style
.
padding_bottom
containing_block_inline_size
)
specified
(
padding_style
.
padding_left
containing_block_inline_size
)
)
)
}
