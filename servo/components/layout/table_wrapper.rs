#
!
[
deny
(
unsafe_blocks
)
]
use
block
:
:
{
BlockFlow
BlockNonReplaced
FloatNonReplaced
ISizeAndMarginsComputer
}
;
use
block
:
:
{
MarginsMayNotCollapse
}
;
use
construct
:
:
FlowConstructor
;
use
context
:
:
LayoutContext
;
use
floats
:
:
FloatKind
;
use
flow
:
:
{
TableWrapperFlowClass
FlowClass
Flow
ImmutableFlowUtils
}
;
use
flow
:
:
{
IMPACTED_BY_LEFT_FLOATS
IMPACTED_BY_RIGHT_FLOATS
}
;
use
fragment
:
:
{
Fragment
FragmentBoundsIterator
}
;
use
table
:
:
{
ColumnComputedInlineSize
ColumnIntrinsicInlineSize
}
;
use
wrapper
:
:
ThreadSafeLayoutNode
;
use
servo_util
:
:
geometry
:
:
Au
;
use
std
:
:
cmp
:
:
{
max
min
}
;
use
std
:
:
fmt
;
use
style
:
:
{
ComputedValues
CSSFloat
}
;
use
style
:
:
computed_values
:
:
table_layout
;
use
sync
:
:
Arc
;
#
[
deriving
(
Encodable
)
]
pub
enum
TableLayout
{
FixedLayout
AutoLayout
}
#
[
deriving
(
Encodable
)
]
pub
struct
TableWrapperFlow
{
pub
block_flow
:
BlockFlow
pub
column_intrinsic_inline_sizes
:
Vec
<
ColumnIntrinsicInlineSize
>
pub
table_layout
:
TableLayout
}
impl
TableWrapperFlow
{
pub
fn
from_node_and_fragment
(
node
:
&
ThreadSafeLayoutNode
fragment
:
Fragment
)
-
>
TableWrapperFlow
{
let
mut
block_flow
=
BlockFlow
:
:
from_node_and_fragment
(
node
fragment
)
;
let
table_layout
=
if
block_flow
.
fragment
(
)
.
style
(
)
.
get_table
(
)
.
table_layout
=
=
table_layout
:
:
fixed
{
FixedLayout
}
else
{
AutoLayout
}
;
TableWrapperFlow
{
block_flow
:
block_flow
column_intrinsic_inline_sizes
:
vec
!
(
)
table_layout
:
table_layout
}
}
pub
fn
from_node
(
constructor
:
&
mut
FlowConstructor
node
:
&
ThreadSafeLayoutNode
)
-
>
TableWrapperFlow
{
let
mut
block_flow
=
BlockFlow
:
:
from_node
(
constructor
node
)
;
let
table_layout
=
if
block_flow
.
fragment
(
)
.
style
(
)
.
get_table
(
)
.
table_layout
=
=
table_layout
:
:
fixed
{
FixedLayout
}
else
{
AutoLayout
}
;
TableWrapperFlow
{
block_flow
:
block_flow
column_intrinsic_inline_sizes
:
vec
!
(
)
table_layout
:
table_layout
}
}
pub
fn
float_from_node_and_fragment
(
node
:
&
ThreadSafeLayoutNode
fragment
:
Fragment
float_kind
:
FloatKind
)
-
>
TableWrapperFlow
{
let
mut
block_flow
=
BlockFlow
:
:
float_from_node_and_fragment
(
node
fragment
float_kind
)
;
let
table_layout
=
if
block_flow
.
fragment
(
)
.
style
(
)
.
get_table
(
)
.
table_layout
=
=
table_layout
:
:
fixed
{
FixedLayout
}
else
{
AutoLayout
}
;
TableWrapperFlow
{
block_flow
:
block_flow
column_intrinsic_inline_sizes
:
vec
!
(
)
table_layout
:
table_layout
}
}
fn
calculate_table_column_sizes_for_automatic_layout
(
&
mut
self
intermediate_column_inline_sizes
:
&
mut
[
IntermediateColumnInlineSize
]
)
{
let
available_inline_size
=
self
.
block_flow
.
fragment
.
border_box
.
size
.
inline
;
let
mut
table_border_padding
=
Au
(
0
)
;
for
kid
in
self
.
block_flow
.
base
.
child_iter
(
)
{
if
kid
.
is_table
(
)
{
let
kid_block
=
kid
.
as_block
(
)
;
kid_block
.
fragment
.
compute_border_and_padding
(
available_inline_size
)
;
kid_block
.
fragment
.
compute_block_direction_margins
(
available_inline_size
)
;
kid_block
.
fragment
.
compute_inline_direction_margins
(
available_inline_size
)
;
table_border_padding
=
kid_block
.
fragment
.
border_padding
.
inline_start_end
(
)
;
break
}
}
let
available_inline_size
=
self
.
block_flow
.
get_shrink_to_fit_inline_size
(
available_inline_size
)
;
let
mut
total_guess
=
AutoLayoutCandidateGuess
:
:
new
(
)
;
let
guesses
:
Vec
<
AutoLayoutCandidateGuess
>
=
self
.
column_intrinsic_inline_sizes
.
iter
(
)
.
map
(
|
column_intrinsic_inline_size
|
{
let
guess
=
AutoLayoutCandidateGuess
:
:
from_column_intrinsic_inline_size
(
column_intrinsic_inline_size
available_inline_size
)
;
total_guess
=
total_guess
+
guess
;
guess
}
)
.
collect
(
)
;
let
selection
=
SelectedAutoLayoutCandidateGuess
:
:
select
(
&
total_guess
available_inline_size
)
;
let
mut
total_used_inline_size
=
Au
(
0
)
;
for
(
intermediate_column_inline_size
guess
)
in
intermediate_column_inline_sizes
.
iter_mut
(
)
.
zip
(
guesses
.
iter
(
)
)
{
intermediate_column_inline_size
.
size
=
guess
.
calculate
(
selection
)
;
intermediate_column_inline_size
.
percentage
=
0
.
0
;
total_used_inline_size
=
total_used_inline_size
+
intermediate_column_inline_size
.
size
}
let
excess_inline_size
=
available_inline_size
-
total_used_inline_size
;
if
excess_inline_size
>
Au
(
0
)
&
&
selection
=
=
UsePreferredGuessAndDistributeExcessInlineSize
{
let
mut
info
=
ExcessInlineSizeDistributionInfo
:
:
new
(
)
;
for
column_intrinsic_inline_size
in
self
.
column_intrinsic_inline_sizes
.
iter
(
)
{
info
.
update
(
column_intrinsic_inline_size
)
}
let
mut
total_distributed_excess_size
=
Au
(
0
)
;
for
(
intermediate_column_inline_size
column_intrinsic_inline_size
)
in
intermediate_column_inline_sizes
.
iter_mut
(
)
.
zip
(
self
.
column_intrinsic_inline_sizes
.
iter
(
)
)
{
info
.
distribute_excess_inline_size_to_column
(
intermediate_column_inline_size
column_intrinsic_inline_size
excess_inline_size
&
mut
total_distributed_excess_size
)
}
total_used_inline_size
=
available_inline_size
}
self
.
block_flow
.
fragment
.
border_box
.
size
.
inline
=
total_used_inline_size
+
table_border_padding
;
self
.
block_flow
.
base
.
position
.
size
.
inline
=
total_used_inline_size
+
table_border_padding
+
self
.
block_flow
.
fragment
.
margin
.
inline_start_end
(
)
;
}
fn
compute_used_inline_size
(
&
mut
self
layout_context
:
&
LayoutContext
parent_flow_inline_size
:
Au
)
{
let
input
=
if
self
.
block_flow
.
base
.
flags
.
is_float
(
)
{
FloatNonReplaced
.
compute_inline_size_constraint_inputs
(
&
mut
self
.
block_flow
parent_flow_inline_size
layout_context
)
}
else
{
BlockNonReplaced
.
compute_inline_size_constraint_inputs
(
&
mut
self
.
block_flow
parent_flow_inline_size
layout_context
)
}
;
if
self
.
block_flow
.
base
.
flags
.
is_float
(
)
{
let
solution
=
FloatNonReplaced
.
solve_inline_size_constraints
(
&
mut
self
.
block_flow
&
input
)
;
FloatNonReplaced
.
set_inline_size_constraint_solutions
(
&
mut
self
.
block_flow
solution
)
;
FloatNonReplaced
.
set_flow_x_coord_if_necessary
(
&
mut
self
.
block_flow
solution
)
;
}
else
{
let
solution
=
BlockNonReplaced
.
solve_inline_size_constraints
(
&
mut
self
.
block_flow
&
input
)
;
BlockNonReplaced
.
set_inline_size_constraint_solutions
(
&
mut
self
.
block_flow
solution
)
;
BlockNonReplaced
.
set_flow_x_coord_if_necessary
(
&
mut
self
.
block_flow
solution
)
;
}
}
}
impl
Flow
for
TableWrapperFlow
{
fn
class
(
&
self
)
-
>
FlowClass
{
TableWrapperFlowClass
}
fn
as_table_wrapper
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableWrapperFlow
{
self
}
fn
as_immutable_table_wrapper
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
TableWrapperFlow
{
self
}
fn
as_block
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
BlockFlow
{
&
mut
self
.
block_flow
}
fn
bubble_inline_sizes
(
&
mut
self
)
{
for
kid
in
self
.
block_flow
.
base
.
child_iter
(
)
{
debug_assert
!
(
kid
.
is_table_caption
(
)
|
|
kid
.
is_table
(
)
)
;
if
kid
.
is_table
(
)
{
self
.
column_intrinsic_inline_sizes
=
kid
.
column_intrinsic_inline_sizes
(
)
.
clone
(
)
}
}
self
.
block_flow
.
bubble_inline_sizes
(
)
;
}
fn
assign_inline_sizes
(
&
mut
self
layout_context
:
&
LayoutContext
)
{
debug
!
(
"
assign_inline_sizes
(
{
}
)
:
assigning
inline_size
for
flow
"
if
self
.
block_flow
.
base
.
flags
.
is_float
(
)
{
"
floated
table_wrapper
"
}
else
{
"
table_wrapper
"
}
)
;
let
mut
intermediate_column_inline_sizes
=
self
.
column_intrinsic_inline_sizes
.
iter
(
)
.
map
(
|
column_intrinsic_inline_size
|
{
IntermediateColumnInlineSize
{
size
:
column_intrinsic_inline_size
.
minimum_length
percentage
:
column_intrinsic_inline_size
.
percentage
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
self
.
block_flow
.
base
.
flags
.
remove
(
IMPACTED_BY_LEFT_FLOATS
)
;
self
.
block_flow
.
base
.
flags
.
remove
(
IMPACTED_BY_RIGHT_FLOATS
)
;
let
containing_block_inline_size
=
self
.
block_flow
.
base
.
block_container_inline_size
;
if
self
.
block_flow
.
base
.
flags
.
is_float
(
)
{
self
.
block_flow
.
float
.
as_mut
(
)
.
unwrap
(
)
.
containing_inline_size
=
containing_block_inline_size
;
}
self
.
compute_used_inline_size
(
layout_context
containing_block_inline_size
)
;
match
self
.
table_layout
{
FixedLayout
=
>
{
}
AutoLayout
=
>
{
self
.
calculate_table_column_sizes_for_automatic_layout
(
intermediate_column_inline_sizes
.
as_mut_slice
(
)
)
}
}
let
inline_start_content_edge
=
self
.
block_flow
.
fragment
.
border_box
.
start
.
i
;
let
content_inline_size
=
self
.
block_flow
.
fragment
.
border_box
.
size
.
inline
;
let
assigned_column_inline_sizes
=
match
self
.
table_layout
{
FixedLayout
=
>
None
AutoLayout
=
>
{
Some
(
intermediate_column_inline_sizes
.
iter
(
)
.
map
(
|
sizes
|
{
ColumnComputedInlineSize
{
size
:
sizes
.
size
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
}
}
;
match
assigned_column_inline_sizes
{
None
=
>
{
self
.
block_flow
.
propagate_assigned_inline_size_to_children
(
layout_context
inline_start_content_edge
content_inline_size
None
)
}
Some
(
ref
assigned_column_inline_sizes
)
=
>
{
self
.
block_flow
.
propagate_assigned_inline_size_to_children
(
layout_context
inline_start_content_edge
content_inline_size
Some
(
assigned_column_inline_sizes
.
as_slice
(
)
)
)
;
}
}
}
fn
assign_block_size
<
'
a
>
(
&
mut
self
ctx
:
&
'
a
LayoutContext
<
'
a
>
)
{
debug
!
(
"
assign_block_size
:
assigning
block_size
for
table_wrapper
"
)
;
self
.
block_flow
.
assign_block_size_block_base
(
ctx
MarginsMayNotCollapse
)
;
}
fn
compute_absolute_position
(
&
mut
self
)
{
self
.
block_flow
.
compute_absolute_position
(
)
}
fn
place_float_if_applicable
<
'
a
>
(
&
mut
self
layout_context
:
&
'
a
LayoutContext
<
'
a
>
)
{
self
.
block_flow
.
place_float_if_applicable
(
layout_context
)
}
fn
assign_block_size_for_inorder_child_if_necessary
<
'
a
>
(
&
mut
self
layout_context
:
&
'
a
LayoutContext
<
'
a
>
)
-
>
bool
{
if
self
.
block_flow
.
base
.
flags
.
is_float
(
)
{
self
.
block_flow
.
place_float
(
)
;
return
true
}
let
impacted
=
self
.
block_flow
.
base
.
flags
.
impacted_by_floats
(
)
;
if
impacted
{
self
.
assign_block_size
(
layout_context
)
;
}
impacted
}
fn
update_late_computed_inline_position_if_necessary
(
&
mut
self
inline_position
:
Au
)
{
self
.
block_flow
.
update_late_computed_inline_position_if_necessary
(
inline_position
)
}
fn
update_late_computed_block_position_if_necessary
(
&
mut
self
block_position
:
Au
)
{
self
.
block_flow
.
update_late_computed_block_position_if_necessary
(
block_position
)
}
fn
build_display_list
(
&
mut
self
layout_context
:
&
LayoutContext
)
{
self
.
block_flow
.
build_display_list
(
layout_context
)
}
fn
repair_style
(
&
mut
self
new_style
:
&
Arc
<
ComputedValues
>
)
{
self
.
block_flow
.
repair_style
(
new_style
)
}
fn
iterate_through_fragment_bounds
(
&
self
iterator
:
&
mut
FragmentBoundsIterator
)
{
self
.
block_flow
.
iterate_through_fragment_bounds
(
iterator
)
;
}
}
impl
fmt
:
:
Show
for
TableWrapperFlow
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
self
.
block_flow
.
base
.
flags
.
is_float
(
)
{
write
!
(
f
"
TableWrapperFlow
(
Float
)
:
{
}
"
self
.
block_flow
.
fragment
)
}
else
{
write
!
(
f
"
TableWrapperFlow
:
{
}
"
self
.
block_flow
.
fragment
)
}
}
}
struct
AutoLayoutCandidateGuess
{
minimum_guess
:
Au
minimum_percentage_guess
:
Au
minimum_specified_guess
:
Au
preferred_guess
:
Au
}
impl
AutoLayoutCandidateGuess
{
fn
new
(
)
-
>
AutoLayoutCandidateGuess
{
AutoLayoutCandidateGuess
{
minimum_guess
:
Au
(
0
)
minimum_percentage_guess
:
Au
(
0
)
minimum_specified_guess
:
Au
(
0
)
preferred_guess
:
Au
(
0
)
}
}
fn
from_column_intrinsic_inline_size
(
column_intrinsic_inline_size
:
&
ColumnIntrinsicInlineSize
assignable_inline_size
:
Au
)
-
>
AutoLayoutCandidateGuess
{
let
minimum_percentage_guess
=
max
(
assignable_inline_size
.
scale_by
(
column_intrinsic_inline_size
.
percentage
)
column_intrinsic_inline_size
.
minimum_length
)
;
AutoLayoutCandidateGuess
{
minimum_guess
:
column_intrinsic_inline_size
.
minimum_length
minimum_percentage_guess
:
minimum_percentage_guess
minimum_specified_guess
:
if
column_intrinsic_inline_size
.
percentage
>
0
.
0
{
minimum_percentage_guess
}
else
if
column_intrinsic_inline_size
.
constrained
{
column_intrinsic_inline_size
.
preferred
}
else
{
column_intrinsic_inline_size
.
minimum_length
}
preferred_guess
:
if
column_intrinsic_inline_size
.
percentage
>
0
.
0
{
minimum_percentage_guess
}
else
{
column_intrinsic_inline_size
.
preferred
}
}
}
fn
calculate
(
&
self
selection
:
SelectedAutoLayoutCandidateGuess
)
-
>
Au
{
match
selection
{
UseMinimumGuess
=
>
self
.
minimum_guess
InterpolateBetweenMinimumGuessAndMinimumPercentageGuess
(
weight
)
=
>
{
interp
(
self
.
minimum_guess
self
.
minimum_percentage_guess
weight
)
}
InterpolateBetweenMinimumPercentageGuessAndMinimumSpecifiedGuess
(
weight
)
=
>
{
interp
(
self
.
minimum_percentage_guess
self
.
minimum_specified_guess
weight
)
}
InterpolateBetweenMinimumSpecifiedGuessAndPreferredGuess
(
weight
)
=
>
{
interp
(
self
.
minimum_specified_guess
self
.
preferred_guess
weight
)
}
UsePreferredGuessAndDistributeExcessInlineSize
=
>
{
self
.
preferred_guess
}
}
}
}
impl
Add
<
AutoLayoutCandidateGuess
AutoLayoutCandidateGuess
>
for
AutoLayoutCandidateGuess
{
#
[
inline
]
fn
add
(
&
self
other
:
&
AutoLayoutCandidateGuess
)
-
>
AutoLayoutCandidateGuess
{
AutoLayoutCandidateGuess
{
minimum_guess
:
self
.
minimum_guess
+
other
.
minimum_guess
minimum_percentage_guess
:
self
.
minimum_percentage_guess
+
other
.
minimum_percentage_guess
minimum_specified_guess
:
self
.
minimum_specified_guess
+
other
.
minimum_specified_guess
preferred_guess
:
self
.
preferred_guess
+
other
.
preferred_guess
}
}
}
#
[
deriving
(
PartialEq
Show
)
]
enum
SelectedAutoLayoutCandidateGuess
{
UseMinimumGuess
InterpolateBetweenMinimumGuessAndMinimumPercentageGuess
(
CSSFloat
)
InterpolateBetweenMinimumPercentageGuessAndMinimumSpecifiedGuess
(
CSSFloat
)
InterpolateBetweenMinimumSpecifiedGuessAndPreferredGuess
(
CSSFloat
)
UsePreferredGuessAndDistributeExcessInlineSize
}
impl
SelectedAutoLayoutCandidateGuess
{
fn
select
(
guess
:
&
AutoLayoutCandidateGuess
assignable_inline_size
:
Au
)
-
>
SelectedAutoLayoutCandidateGuess
{
if
assignable_inline_size
<
guess
.
minimum_guess
{
UseMinimumGuess
}
else
if
assignable_inline_size
<
guess
.
minimum_percentage_guess
{
let
weight
=
weight
(
guess
.
minimum_guess
assignable_inline_size
guess
.
minimum_percentage_guess
)
;
InterpolateBetweenMinimumGuessAndMinimumPercentageGuess
(
weight
)
}
else
if
assignable_inline_size
<
guess
.
minimum_specified_guess
{
let
weight
=
weight
(
guess
.
minimum_percentage_guess
assignable_inline_size
guess
.
minimum_specified_guess
)
;
InterpolateBetweenMinimumPercentageGuessAndMinimumSpecifiedGuess
(
weight
)
}
else
if
assignable_inline_size
<
guess
.
preferred_guess
{
let
weight
=
weight
(
guess
.
minimum_specified_guess
assignable_inline_size
guess
.
preferred_guess
)
;
InterpolateBetweenMinimumSpecifiedGuessAndPreferredGuess
(
weight
)
}
else
{
UsePreferredGuessAndDistributeExcessInlineSize
}
}
}
fn
weight
(
low
:
Au
middle
:
Au
high
:
Au
)
-
>
CSSFloat
{
(
middle
-
low
)
.
to_subpx
(
)
/
(
high
-
low
)
.
to_subpx
(
)
}
fn
interp
(
low
:
Au
high
:
Au
weight
:
CSSFloat
)
-
>
Au
{
low
+
(
high
-
low
)
.
scale_by
(
weight
)
}
struct
ExcessInlineSizeDistributionInfo
{
preferred_inline_size_of_nonconstrained_columns_with_no_percentage
:
Au
count_of_nonconstrained_columns_with_no_percentage
:
u32
preferred_inline_size_of_constrained_columns_with_no_percentage
:
Au
total_percentage
:
CSSFloat
column_count
:
u32
}
impl
ExcessInlineSizeDistributionInfo
{
fn
new
(
)
-
>
ExcessInlineSizeDistributionInfo
{
ExcessInlineSizeDistributionInfo
{
preferred_inline_size_of_nonconstrained_columns_with_no_percentage
:
Au
(
0
)
count_of_nonconstrained_columns_with_no_percentage
:
0
preferred_inline_size_of_constrained_columns_with_no_percentage
:
Au
(
0
)
total_percentage
:
0
.
0
column_count
:
0
}
}
fn
update
(
&
mut
self
column_intrinsic_inline_size
:
&
ColumnIntrinsicInlineSize
)
{
if
!
column_intrinsic_inline_size
.
constrained
&
&
column_intrinsic_inline_size
.
percentage
=
=
0
.
0
{
self
.
preferred_inline_size_of_nonconstrained_columns_with_no_percentage
=
self
.
preferred_inline_size_of_nonconstrained_columns_with_no_percentage
+
column_intrinsic_inline_size
.
preferred
;
self
.
count_of_nonconstrained_columns_with_no_percentage
+
=
1
}
if
column_intrinsic_inline_size
.
constrained
&
&
column_intrinsic_inline_size
.
percentage
=
=
0
.
0
{
self
.
preferred_inline_size_of_constrained_columns_with_no_percentage
=
self
.
preferred_inline_size_of_constrained_columns_with_no_percentage
+
column_intrinsic_inline_size
.
preferred
}
self
.
total_percentage
+
=
column_intrinsic_inline_size
.
percentage
;
self
.
column_count
+
=
1
}
#
[
inline
]
fn
distribute_excess_inline_size_to_column
(
&
self
intermediate_column_inline_size
:
&
mut
IntermediateColumnInlineSize
column_intrinsic_inline_size
:
&
ColumnIntrinsicInlineSize
excess_inline_size
:
Au
total_distributed_excess_size
:
&
mut
Au
)
{
let
proportion
=
if
self
.
preferred_inline_size_of_nonconstrained_columns_with_no_percentage
>
Au
(
0
)
{
column_intrinsic_inline_size
.
preferred
.
to_subpx
(
)
/
self
.
preferred_inline_size_of_nonconstrained_columns_with_no_percentage
.
to_subpx
(
)
}
else
if
self
.
count_of_nonconstrained_columns_with_no_percentage
>
0
{
1
.
0
/
(
self
.
count_of_nonconstrained_columns_with_no_percentage
as
CSSFloat
)
}
else
if
self
.
preferred_inline_size_of_constrained_columns_with_no_percentage
>
Au
(
0
)
{
column_intrinsic_inline_size
.
preferred
.
to_subpx
(
)
/
self
.
preferred_inline_size_of_constrained_columns_with_no_percentage
.
to_subpx
(
)
}
else
if
self
.
total_percentage
>
0
.
0
{
column_intrinsic_inline_size
.
percentage
/
self
.
total_percentage
}
else
{
1
.
0
/
(
self
.
column_count
as
CSSFloat
)
}
;
let
amount_to_distribute
=
min
(
excess_inline_size
.
scale_by
(
proportion
)
excess_inline_size
-
*
total_distributed_excess_size
)
;
*
total_distributed_excess_size
=
*
total_distributed_excess_size
+
amount_to_distribute
;
intermediate_column_inline_size
.
size
=
intermediate_column_inline_size
.
size
+
amount_to_distribute
}
}
struct
IntermediateColumnInlineSize
{
size
:
Au
percentage
:
f64
}
