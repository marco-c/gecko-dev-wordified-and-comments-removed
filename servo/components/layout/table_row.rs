#
!
[
deny
(
unsafe_blocks
)
]
use
block
:
:
BlockFlow
;
use
block
:
:
ISizeAndMarginsComputer
;
use
construct
:
:
FlowConstructor
;
use
context
:
:
LayoutContext
;
use
flow
:
:
{
TableRowFlowClass
FlowClass
Flow
ImmutableFlowUtils
}
;
use
flow
;
use
fragment
:
:
{
Fragment
FragmentBoundsIterator
}
;
use
layout_debug
;
use
table
:
:
{
ColumnInlineSize
InternalTable
}
;
use
model
:
:
{
MaybeAuto
Specified
Auto
}
;
use
wrapper
:
:
ThreadSafeLayoutNode
;
use
servo_util
:
:
geometry
:
:
Au
;
use
std
:
:
cmp
:
:
max
;
use
std
:
:
fmt
;
use
style
:
:
ComputedValues
;
use
style
:
:
computed_values
:
:
{
LPA_Auto
LPA_Length
LPA_Percentage
}
;
use
sync
:
:
Arc
;
#
[
deriving
(
Encodable
)
]
pub
struct
TableRowFlow
{
pub
block_flow
:
BlockFlow
pub
column_inline_sizes
:
Vec
<
ColumnInlineSize
>
}
impl
TableRowFlow
{
pub
fn
from_node_and_fragment
(
node
:
&
ThreadSafeLayoutNode
fragment
:
Fragment
)
-
>
TableRowFlow
{
TableRowFlow
{
block_flow
:
BlockFlow
:
:
from_node_and_fragment
(
node
fragment
)
column_inline_sizes
:
Vec
:
:
new
(
)
}
}
pub
fn
from_node
(
constructor
:
&
mut
FlowConstructor
node
:
&
ThreadSafeLayoutNode
)
-
>
TableRowFlow
{
TableRowFlow
{
block_flow
:
BlockFlow
:
:
from_node
(
constructor
node
)
column_inline_sizes
:
Vec
:
:
new
(
)
}
}
pub
fn
fragment
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
Fragment
{
&
self
.
block_flow
.
fragment
}
fn
initialize_offsets
(
&
mut
self
)
-
>
(
Au
Au
Au
)
{
(
Au
(
0
)
Au
(
0
)
Au
(
0
)
)
}
#
[
inline
(
always
)
]
fn
assign_block_size_table_row_base
<
'
a
>
(
&
mut
self
layout_context
:
&
'
a
LayoutContext
<
'
a
>
)
{
let
(
block_start_offset
_
_
)
=
self
.
initialize_offsets
(
)
;
let
cur_y
=
block_start_offset
;
let
mut
max_y
=
Au
(
0
)
;
for
kid
in
self
.
block_flow
.
base
.
child_iter
(
)
{
kid
.
place_float_if_applicable
(
layout_context
)
;
if
!
flow
:
:
base
(
kid
)
.
flags
.
is_float
(
)
{
kid
.
assign_block_size_for_inorder_child_if_necessary
(
layout_context
)
;
}
{
let
child_fragment
=
kid
.
as_table_cell
(
)
.
fragment
(
)
;
let
child_specified_block_size
=
MaybeAuto
:
:
from_style
(
child_fragment
.
style
(
)
.
content_block_size
(
)
Au
:
:
new
(
0
)
)
.
specified_or_zero
(
)
;
max_y
=
max
(
max_y
child_specified_block_size
+
child_fragment
.
border_padding
.
block_start_end
(
)
)
;
}
let
child_node
=
flow
:
:
mut_base
(
kid
)
;
child_node
.
position
.
start
.
b
=
cur_y
;
max_y
=
max
(
max_y
child_node
.
position
.
size
.
block
)
;
}
let
mut
block_size
=
max_y
;
block_size
=
match
MaybeAuto
:
:
from_style
(
self
.
block_flow
.
fragment
.
style
(
)
.
content_block_size
(
)
Au
(
0
)
)
{
Auto
=
>
block_size
Specified
(
value
)
=
>
max
(
value
block_size
)
}
;
let
mut
position
=
self
.
block_flow
.
fragment
.
border_box
;
position
.
size
.
block
=
block_size
;
self
.
block_flow
.
fragment
.
border_box
=
position
;
self
.
block_flow
.
base
.
position
.
size
.
block
=
block_size
;
for
kid
in
self
.
block_flow
.
base
.
child_iter
(
)
{
{
let
kid_fragment
=
kid
.
as_table_cell
(
)
.
mut_fragment
(
)
;
let
mut
position
=
kid_fragment
.
border_box
;
position
.
size
.
block
=
block_size
;
kid_fragment
.
border_box
=
position
;
}
let
child_node
=
flow
:
:
mut_base
(
kid
)
;
child_node
.
position
.
size
.
block
=
block_size
;
}
}
}
impl
Flow
for
TableRowFlow
{
fn
class
(
&
self
)
-
>
FlowClass
{
TableRowFlowClass
}
fn
as_table_row
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableRowFlow
{
self
}
fn
as_immutable_table_row
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
TableRowFlow
{
self
}
fn
as_block
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
BlockFlow
{
&
mut
self
.
block_flow
}
fn
column_inline_sizes
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Vec
<
ColumnInlineSize
>
{
&
mut
self
.
column_inline_sizes
}
fn
bubble_inline_sizes
(
&
mut
self
)
{
let
_scope
=
layout_debug_scope
!
(
"
table_row
:
:
bubble_inline_sizes
{
:
x
}
"
self
.
block_flow
.
base
.
debug_id
(
)
)
;
let
(
mut
min_inline_size
mut
pref_inline_size
)
=
(
Au
(
0
)
Au
(
0
)
)
;
for
kid
in
self
.
block_flow
.
base
.
child_iter
(
)
{
assert
!
(
kid
.
is_table_cell
(
)
)
;
let
child_specified_inline_size
=
kid
.
as_table_cell
(
)
.
fragment
(
)
.
style
(
)
.
content_inline_size
(
)
;
let
child_base
=
flow
:
:
mut_base
(
kid
)
;
let
child_column_inline_size
=
ColumnInlineSize
{
minimum_length
:
match
child_specified_inline_size
{
LPA_Auto
|
LPA_Percentage
(
_
)
=
>
{
child_base
.
intrinsic_inline_sizes
.
minimum_inline_size
}
LPA_Length
(
length
)
=
>
length
}
percentage
:
match
child_specified_inline_size
{
LPA_Auto
|
LPA_Length
(
_
)
=
>
0
.
0
LPA_Percentage
(
percentage
)
=
>
percentage
}
preferred
:
child_base
.
intrinsic_inline_sizes
.
preferred_inline_size
constrained
:
match
child_specified_inline_size
{
LPA_Length
(
_
)
=
>
true
LPA_Auto
|
LPA_Percentage
(
_
)
=
>
false
}
}
;
min_inline_size
=
min_inline_size
+
child_column_inline_size
.
minimum_length
;
pref_inline_size
=
pref_inline_size
+
child_column_inline_size
.
preferred
;
self
.
column_inline_sizes
.
push
(
child_column_inline_size
)
;
}
self
.
block_flow
.
base
.
intrinsic_inline_sizes
.
minimum_inline_size
=
min_inline_size
;
self
.
block_flow
.
base
.
intrinsic_inline_sizes
.
preferred_inline_size
=
max
(
min_inline_size
pref_inline_size
)
;
}
fn
assign_inline_sizes
(
&
mut
self
ctx
:
&
LayoutContext
)
{
let
_scope
=
layout_debug_scope
!
(
"
table_row
:
:
assign_inline_sizes
{
:
x
}
"
self
.
block_flow
.
base
.
debug_id
(
)
)
;
debug
!
(
"
assign_inline_sizes
(
{
}
)
:
assigning
inline_size
for
flow
"
"
table_row
"
)
;
let
containing_block_inline_size
=
self
.
block_flow
.
base
.
block_container_inline_size
;
let
inline_start_content_edge
=
Au
(
0
)
;
let
inline_size_computer
=
InternalTable
;
inline_size_computer
.
compute_used_inline_size
(
&
mut
self
.
block_flow
ctx
containing_block_inline_size
)
;
self
.
block_flow
.
propagate_assigned_inline_size_to_children
(
inline_start_content_edge
containing_block_inline_size
Some
(
self
.
column_inline_sizes
.
as_slice
(
)
)
)
;
}
fn
assign_block_size
<
'
a
>
(
&
mut
self
ctx
:
&
'
a
LayoutContext
<
'
a
>
)
{
debug
!
(
"
assign_block_size
:
assigning
block_size
for
table_row
"
)
;
self
.
assign_block_size_table_row_base
(
ctx
)
;
}
fn
compute_absolute_position
(
&
mut
self
)
{
self
.
block_flow
.
compute_absolute_position
(
)
}
fn
update_late_computed_inline_position_if_necessary
(
&
mut
self
inline_position
:
Au
)
{
self
.
block_flow
.
update_late_computed_inline_position_if_necessary
(
inline_position
)
}
fn
update_late_computed_block_position_if_necessary
(
&
mut
self
block_position
:
Au
)
{
self
.
block_flow
.
update_late_computed_block_position_if_necessary
(
block_position
)
}
fn
build_display_list
(
&
mut
self
layout_context
:
&
LayoutContext
)
{
self
.
block_flow
.
build_display_list
(
layout_context
)
}
fn
repair_style
(
&
mut
self
new_style
:
&
Arc
<
ComputedValues
>
)
{
self
.
block_flow
.
repair_style
(
new_style
)
}
fn
iterate_through_fragment_bounds
(
&
self
iterator
:
&
mut
FragmentBoundsIterator
)
{
self
.
block_flow
.
iterate_through_fragment_bounds
(
iterator
)
;
}
}
impl
fmt
:
:
Show
for
TableRowFlow
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
TableRowFlow
:
{
}
"
self
.
block_flow
.
fragment
)
}
}
