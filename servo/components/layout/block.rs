#
!
[
deny
(
unsafe_code
)
]
use
app_units
:
:
{
Au
MAX_AU
}
;
use
context
:
:
LayoutContext
;
use
display_list
:
:
{
BlockFlowDisplayListBuilding
BorderPaintingMode
}
;
use
display_list
:
:
{
DisplayListBuildState
StackingContextCollectionFlags
}
;
use
display_list
:
:
StackingContextCollectionState
;
use
euclid
:
:
{
Point2D
Rect
SideOffsets2D
Size2D
}
;
use
floats
:
:
{
ClearType
FloatKind
Floats
PlacementInfo
}
;
use
flow
:
:
{
BaseFlow
EarlyAbsolutePositionInfo
Flow
FlowClass
ForceNonfloatedFlag
GetBaseFlow
}
;
use
flow
:
:
{
ImmutableFlowUtils
LateAbsolutePositionInfo
OpaqueFlow
FragmentationContext
FlowFlags
}
;
use
flow_list
:
:
FlowList
;
use
fragment
:
:
{
CoordinateSystem
Fragment
FragmentBorderBoxIterator
Overflow
FragmentFlags
}
;
use
gfx
:
:
display_list
:
:
DisplayListSection
;
use
gfx_traits
:
:
print_tree
:
:
PrintTree
;
use
incremental
:
:
RelayoutMode
;
use
layout_debug
;
use
model
:
:
{
AdjoiningMargins
CollapsibleMargins
IntrinsicISizes
MarginCollapseInfo
MaybeAuto
}
;
use
sequential
;
use
serde
:
:
{
Serialize
Serializer
}
;
use
servo_geometry
:
:
MaxRect
;
use
std
:
:
cmp
:
:
{
max
min
}
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
Arc
;
use
style
:
:
computed_values
:
:
box_sizing
:
:
T
as
BoxSizing
;
use
style
:
:
computed_values
:
:
display
:
:
T
as
Display
;
use
style
:
:
computed_values
:
:
float
:
:
T
as
Float
;
use
style
:
:
computed_values
:
:
overflow_x
:
:
T
as
StyleOverflow
;
use
style
:
:
computed_values
:
:
position
:
:
T
as
Position
;
use
style
:
:
computed_values
:
:
text_align
:
:
T
as
TextAlign
;
use
style
:
:
context
:
:
SharedStyleContext
;
use
style
:
:
logical_geometry
:
:
{
LogicalMargin
LogicalPoint
LogicalRect
LogicalSize
WritingMode
}
;
use
style
:
:
properties
:
:
ComputedValues
;
use
style
:
:
servo
:
:
restyle_damage
:
:
ServoRestyleDamage
;
use
style
:
:
values
:
:
computed
:
:
{
LengthOrPercentageOrNone
LengthOrPercentage
}
;
use
style
:
:
values
:
:
computed
:
:
LengthOrPercentageOrAuto
;
use
traversal
:
:
PreorderFlowTraversal
;
#
[
derive
(
Clone
Serialize
)
]
pub
struct
FloatedBlockInfo
{
pub
containing_inline_size
:
Au
pub
float_ceiling
:
Au
pub
float_kind
:
FloatKind
}
impl
FloatedBlockInfo
{
pub
fn
new
(
float_kind
:
FloatKind
)
-
>
FloatedBlockInfo
{
FloatedBlockInfo
{
containing_inline_size
:
Au
(
0
)
float_ceiling
:
Au
(
0
)
float_kind
:
float_kind
}
}
}
#
[
derive
(
Clone
Copy
)
]
struct
BSizeConstraintSolution
{
block_start
:
Au
block_size
:
Au
margin_block_start
:
Au
margin_block_end
:
Au
}
impl
BSizeConstraintSolution
{
fn
new
(
block_start
:
Au
block_size
:
Au
margin_block_start
:
Au
margin_block_end
:
Au
)
-
>
BSizeConstraintSolution
{
BSizeConstraintSolution
{
block_start
:
block_start
block_size
:
block_size
margin_block_start
:
margin_block_start
margin_block_end
:
margin_block_end
}
}
fn
solve_vertical_constraints_abs_nonreplaced
(
block_size
:
MaybeAuto
block_start_margin
:
MaybeAuto
block_end_margin
:
MaybeAuto
block_start
:
MaybeAuto
block_end
:
MaybeAuto
content_block_size
:
Au
available_block_size
:
Au
)
-
>
BSizeConstraintSolution
{
let
(
block_start
block_size
margin_block_start
margin_block_end
)
=
match
(
block_start
block_end
block_size
)
{
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
)
=
>
{
let
margin_block_start
=
block_start_margin
.
specified_or_zero
(
)
;
let
margin_block_end
=
block_end_margin
.
specified_or_zero
(
)
;
let
block_size
=
content_block_size
;
(
Au
(
0
)
block_size
margin_block_start
margin_block_end
)
}
(
MaybeAuto
:
:
Specified
(
block_start
)
MaybeAuto
:
:
Specified
(
block_end
)
MaybeAuto
:
:
Specified
(
block_size
)
)
=
>
{
match
(
block_start_margin
block_end_margin
)
{
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
)
=
>
{
let
total_margin_val
=
available_block_size
-
block_start
-
block_end
-
block_size
;
(
block_start
block_size
total_margin_val
.
scale_by
(
0
.
5
)
total_margin_val
.
scale_by
(
0
.
5
)
)
}
(
MaybeAuto
:
:
Specified
(
margin_block_start
)
MaybeAuto
:
:
Auto
)
=
>
{
let
sum
=
block_start
+
block_end
+
block_size
+
margin_block_start
;
(
block_start
block_size
margin_block_start
available_block_size
-
sum
)
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
margin_block_end
)
)
=
>
{
let
sum
=
block_start
+
block_end
+
block_size
+
margin_block_end
;
(
block_start
block_size
available_block_size
-
sum
margin_block_end
)
}
(
MaybeAuto
:
:
Specified
(
margin_block_start
)
MaybeAuto
:
:
Specified
(
margin_block_end
)
)
=
>
{
(
block_start
block_size
margin_block_start
margin_block_end
)
}
}
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
block_end
)
MaybeAuto
:
:
Specified
(
block_size
)
)
=
>
{
let
margin_block_start
=
block_start_margin
.
specified_or_zero
(
)
;
let
margin_block_end
=
block_end_margin
.
specified_or_zero
(
)
;
let
sum
=
block_end
+
block_size
+
margin_block_start
+
margin_block_end
;
(
available_block_size
-
sum
block_size
margin_block_start
margin_block_end
)
}
(
MaybeAuto
:
:
Specified
(
block_start
)
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
block_size
)
)
=
>
{
let
margin_block_start
=
block_start_margin
.
specified_or_zero
(
)
;
let
margin_block_end
=
block_end_margin
.
specified_or_zero
(
)
;
(
block_start
block_size
margin_block_start
margin_block_end
)
}
(
MaybeAuto
:
:
Specified
(
block_start
)
MaybeAuto
:
:
Specified
(
block_end
)
MaybeAuto
:
:
Auto
)
=
>
{
let
margin_block_start
=
block_start_margin
.
specified_or_zero
(
)
;
let
margin_block_end
=
block_end_margin
.
specified_or_zero
(
)
;
let
sum
=
block_start
+
block_end
+
margin_block_start
+
margin_block_end
;
(
block_start
available_block_size
-
sum
margin_block_start
margin_block_end
)
}
(
MaybeAuto
:
:
Specified
(
block_start
)
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
)
=
>
{
let
margin_block_start
=
block_start_margin
.
specified_or_zero
(
)
;
let
margin_block_end
=
block_end_margin
.
specified_or_zero
(
)
;
let
block_size
=
content_block_size
;
(
block_start
block_size
margin_block_start
margin_block_end
)
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
block_end
)
MaybeAuto
:
:
Auto
)
=
>
{
let
margin_block_start
=
block_start_margin
.
specified_or_zero
(
)
;
let
margin_block_end
=
block_end_margin
.
specified_or_zero
(
)
;
let
block_size
=
content_block_size
;
let
sum
=
block_end
+
block_size
+
margin_block_start
+
margin_block_end
;
(
available_block_size
-
sum
block_size
margin_block_start
margin_block_end
)
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
block_size
)
)
=
>
{
let
margin_block_start
=
block_start_margin
.
specified_or_zero
(
)
;
let
margin_block_end
=
block_end_margin
.
specified_or_zero
(
)
;
(
Au
(
0
)
block_size
margin_block_start
margin_block_end
)
}
}
;
BSizeConstraintSolution
:
:
new
(
block_start
block_size
margin_block_start
margin_block_end
)
}
fn
solve_vertical_constraints_abs_replaced
(
block_size
:
Au
block_start_margin
:
MaybeAuto
block_end_margin
:
MaybeAuto
block_start
:
MaybeAuto
block_end
:
MaybeAuto
_
:
Au
available_block_size
:
Au
)
-
>
BSizeConstraintSolution
{
let
(
block_start
block_size
margin_block_start
margin_block_end
)
=
match
(
block_start
block_end
)
{
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
)
=
>
{
let
margin_block_start
=
block_start_margin
.
specified_or_zero
(
)
;
let
margin_block_end
=
block_end_margin
.
specified_or_zero
(
)
;
(
Au
(
0
)
block_size
margin_block_start
margin_block_end
)
}
(
MaybeAuto
:
:
Specified
(
block_start
)
MaybeAuto
:
:
Specified
(
block_end
)
)
=
>
{
match
(
block_start_margin
block_end_margin
)
{
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
)
=
>
{
let
total_margin_val
=
available_block_size
-
block_start
-
block_end
-
block_size
;
(
block_start
block_size
total_margin_val
.
scale_by
(
0
.
5
)
total_margin_val
.
scale_by
(
0
.
5
)
)
}
(
MaybeAuto
:
:
Specified
(
margin_block_start
)
MaybeAuto
:
:
Auto
)
=
>
{
let
sum
=
block_start
+
block_end
+
block_size
+
margin_block_start
;
(
block_start
block_size
margin_block_start
available_block_size
-
sum
)
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
margin_block_end
)
)
=
>
{
let
sum
=
block_start
+
block_end
+
block_size
+
margin_block_end
;
(
block_start
block_size
available_block_size
-
sum
margin_block_end
)
}
(
MaybeAuto
:
:
Specified
(
margin_block_start
)
MaybeAuto
:
:
Specified
(
margin_block_end
)
)
=
>
{
(
block_start
block_size
margin_block_start
margin_block_end
)
}
}
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
block_end
)
)
=
>
{
let
margin_block_start
=
block_start_margin
.
specified_or_zero
(
)
;
let
margin_block_end
=
block_end_margin
.
specified_or_zero
(
)
;
let
sum
=
block_end
+
block_size
+
margin_block_start
+
margin_block_end
;
(
available_block_size
-
sum
block_size
margin_block_start
margin_block_end
)
}
(
MaybeAuto
:
:
Specified
(
block_start
)
MaybeAuto
:
:
Auto
)
=
>
{
let
margin_block_start
=
block_start_margin
.
specified_or_zero
(
)
;
let
margin_block_end
=
block_end_margin
.
specified_or_zero
(
)
;
(
block_start
block_size
margin_block_start
margin_block_end
)
}
}
;
BSizeConstraintSolution
:
:
new
(
block_start
block_size
margin_block_start
margin_block_end
)
}
}
pub
struct
CandidateBSizeIterator
{
block_size
:
MaybeAuto
max_block_size
:
Option
<
Au
>
min_block_size
:
Au
pub
candidate_value
:
Au
status
:
CandidateBSizeIteratorStatus
}
impl
CandidateBSizeIterator
{
pub
fn
new
(
fragment
:
&
Fragment
block_container_block_size
:
Option
<
Au
>
)
-
>
CandidateBSizeIterator
{
let
block_size
=
match
(
fragment
.
style
.
content_block_size
(
)
block_container_block_size
)
{
(
LengthOrPercentageOrAuto
:
:
Percentage
(
percent
)
Some
(
block_container_block_size
)
)
=
>
{
MaybeAuto
:
:
Specified
(
block_container_block_size
.
scale_by
(
percent
.
0
)
)
}
(
LengthOrPercentageOrAuto
:
:
Calc
(
calc
)
_
)
=
>
{
MaybeAuto
:
:
from_option
(
calc
.
to_used_value
(
block_container_block_size
)
)
}
(
LengthOrPercentageOrAuto
:
:
Percentage
(
_
)
None
)
|
(
LengthOrPercentageOrAuto
:
:
Auto
_
)
=
>
MaybeAuto
:
:
Auto
(
LengthOrPercentageOrAuto
:
:
Length
(
length
)
_
)
=
>
MaybeAuto
:
:
Specified
(
Au
:
:
from
(
length
)
)
}
;
let
max_block_size
=
match
(
fragment
.
style
.
max_block_size
(
)
block_container_block_size
)
{
(
LengthOrPercentageOrNone
:
:
Percentage
(
percent
)
Some
(
block_container_block_size
)
)
=
>
{
Some
(
block_container_block_size
.
scale_by
(
percent
.
0
)
)
}
(
LengthOrPercentageOrNone
:
:
Calc
(
calc
)
_
)
=
>
{
calc
.
to_used_value
(
block_container_block_size
)
}
(
LengthOrPercentageOrNone
:
:
Percentage
(
_
)
None
)
|
(
LengthOrPercentageOrNone
:
:
None
_
)
=
>
None
(
LengthOrPercentageOrNone
:
:
Length
(
length
)
_
)
=
>
Some
(
Au
:
:
from
(
length
)
)
}
;
let
min_block_size
=
match
(
fragment
.
style
.
min_block_size
(
)
block_container_block_size
)
{
(
LengthOrPercentage
:
:
Percentage
(
percent
)
Some
(
block_container_block_size
)
)
=
>
{
block_container_block_size
.
scale_by
(
percent
.
0
)
}
(
LengthOrPercentage
:
:
Calc
(
calc
)
_
)
=
>
{
calc
.
to_used_value
(
block_container_block_size
)
.
unwrap_or
(
Au
(
0
)
)
}
(
LengthOrPercentage
:
:
Percentage
(
_
)
None
)
=
>
Au
(
0
)
(
LengthOrPercentage
:
:
Length
(
length
)
_
)
=
>
Au
:
:
from
(
length
)
}
;
let
adjustment_for_box_sizing
=
match
fragment
.
style
.
get_position
(
)
.
box_sizing
{
BoxSizing
:
:
BorderBox
=
>
fragment
.
border_padding
.
block_start_end
(
)
BoxSizing
:
:
ContentBox
=
>
Au
(
0
)
}
;
return
CandidateBSizeIterator
{
block_size
:
block_size
.
map
(
|
size
|
adjust
(
size
adjustment_for_box_sizing
)
)
max_block_size
:
max_block_size
.
map
(
|
size
|
adjust
(
size
adjustment_for_box_sizing
)
)
min_block_size
:
adjust
(
min_block_size
adjustment_for_box_sizing
)
candidate_value
:
Au
(
0
)
status
:
CandidateBSizeIteratorStatus
:
:
Initial
}
;
fn
adjust
(
size
:
Au
delta
:
Au
)
-
>
Au
{
max
(
size
-
delta
Au
(
0
)
)
}
}
}
impl
Iterator
for
CandidateBSizeIterator
{
type
Item
=
MaybeAuto
;
fn
next
(
&
mut
self
)
-
>
Option
<
MaybeAuto
>
{
self
.
status
=
match
self
.
status
{
CandidateBSizeIteratorStatus
:
:
Initial
=
>
CandidateBSizeIteratorStatus
:
:
Trying
CandidateBSizeIteratorStatus
:
:
Trying
=
>
{
match
self
.
max_block_size
{
Some
(
max_block_size
)
if
self
.
candidate_value
>
max_block_size
=
>
{
CandidateBSizeIteratorStatus
:
:
TryingMax
}
_
if
self
.
candidate_value
<
self
.
min_block_size
=
>
{
CandidateBSizeIteratorStatus
:
:
TryingMin
}
_
=
>
CandidateBSizeIteratorStatus
:
:
Found
}
}
CandidateBSizeIteratorStatus
:
:
TryingMax
=
>
{
if
self
.
candidate_value
<
self
.
min_block_size
{
CandidateBSizeIteratorStatus
:
:
TryingMin
}
else
{
CandidateBSizeIteratorStatus
:
:
Found
}
}
CandidateBSizeIteratorStatus
:
:
TryingMin
|
CandidateBSizeIteratorStatus
:
:
Found
=
>
{
CandidateBSizeIteratorStatus
:
:
Found
}
}
;
match
self
.
status
{
CandidateBSizeIteratorStatus
:
:
Trying
=
>
Some
(
self
.
block_size
)
CandidateBSizeIteratorStatus
:
:
TryingMax
=
>
{
Some
(
MaybeAuto
:
:
Specified
(
self
.
max_block_size
.
unwrap
(
)
)
)
}
CandidateBSizeIteratorStatus
:
:
TryingMin
=
>
{
Some
(
MaybeAuto
:
:
Specified
(
self
.
min_block_size
)
)
}
CandidateBSizeIteratorStatus
:
:
Found
=
>
None
CandidateBSizeIteratorStatus
:
:
Initial
=
>
panic
!
(
)
}
}
}
enum
CandidateBSizeIteratorStatus
{
Initial
Trying
TryingMax
TryingMin
Found
}
fn
translate_including_floats
(
cur_b
:
&
mut
Au
delta
:
Au
floats
:
&
mut
Floats
)
{
*
cur_b
=
*
cur_b
+
delta
;
let
writing_mode
=
floats
.
writing_mode
;
floats
.
translate
(
LogicalSize
:
:
new
(
writing_mode
Au
(
0
)
-
delta
)
)
;
}
pub
struct
AbsoluteAssignBSizesTraversal
<
'
a
>
(
pub
&
'
a
SharedStyleContext
<
'
a
>
)
;
impl
<
'
a
>
PreorderFlowTraversal
for
AbsoluteAssignBSizesTraversal
<
'
a
>
{
#
[
inline
]
fn
process
(
&
self
flow
:
&
mut
Flow
)
{
if
!
flow
.
is_block_like
(
)
{
return
}
let
block
=
flow
.
as_mut_block
(
)
;
if
!
block
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
return
;
}
if
!
block
.
base
.
restyle_damage
.
intersects
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
{
return
}
block
.
calculate_absolute_block_size_and_margins
(
self
.
0
)
;
}
}
pub
enum
BlockType
{
Replaced
NonReplaced
AbsoluteReplaced
AbsoluteNonReplaced
FloatReplaced
FloatNonReplaced
InlineBlockReplaced
InlineBlockNonReplaced
InlineFlexItem
}
#
[
derive
(
Clone
PartialEq
)
]
pub
enum
MarginsMayCollapseFlag
{
MarginsMayCollapse
MarginsMayNotCollapse
}
#
[
derive
(
Debug
PartialEq
)
]
pub
enum
FormattingContextType
{
None
Block
Other
}
#
[
allow
(
unsafe_code
)
]
unsafe
impl
:
:
flow
:
:
HasBaseFlow
for
BlockFlow
{
}
#
[
derive
(
Serialize
)
]
#
[
repr
(
C
)
]
pub
struct
BlockFlow
{
pub
base
:
BaseFlow
pub
fragment
:
Fragment
pub
float
:
Option
<
Box
<
FloatedBlockInfo
>
>
flags
:
BlockFlowFlags
}
bitflags
!
{
struct
BlockFlowFlags
:
u8
{
#
[
doc
=
"
If
this
is
set
then
this
block
flow
is
the
root
flow
.
"
]
const
IS_ROOT
=
0b0000_0001
;
#
[
doc
=
"
If
this
is
set
then
this
block
flow
has
overflow
and
it
will
scroll
.
"
]
const
HAS_SCROLLING_OVERFLOW
=
0b0000_0010
;
}
}
impl
Serialize
for
BlockFlowFlags
{
fn
serialize
<
S
:
Serializer
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
{
self
.
bits
(
)
.
serialize
(
serializer
)
}
}
impl
BlockFlow
{
pub
fn
from_fragment
(
fragment
:
Fragment
)
-
>
BlockFlow
{
BlockFlow
:
:
from_fragment_and_float_kind
(
fragment
None
)
}
pub
fn
from_fragment_and_float_kind
(
fragment
:
Fragment
float_kind
:
Option
<
FloatKind
>
)
-
>
BlockFlow
{
let
writing_mode
=
fragment
.
style
(
)
.
writing_mode
;
BlockFlow
{
base
:
BaseFlow
:
:
new
(
Some
(
fragment
.
style
(
)
)
writing_mode
match
float_kind
{
Some
(
_
)
=
>
ForceNonfloatedFlag
:
:
FloatIfNecessary
None
=
>
ForceNonfloatedFlag
:
:
ForceNonfloated
}
)
fragment
:
fragment
float
:
float_kind
.
map
(
|
kind
|
Box
:
:
new
(
FloatedBlockInfo
:
:
new
(
kind
)
)
)
flags
:
BlockFlowFlags
:
:
empty
(
)
}
}
pub
fn
block_type
(
&
self
)
-
>
BlockType
{
if
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
if
self
.
fragment
.
is_replaced
(
)
{
BlockType
:
:
AbsoluteReplaced
}
else
{
BlockType
:
:
AbsoluteNonReplaced
}
}
else
if
self
.
is_inline_flex_item
(
)
{
BlockType
:
:
InlineFlexItem
}
else
if
self
.
base
.
flags
.
is_float
(
)
{
if
self
.
fragment
.
is_replaced
(
)
{
BlockType
:
:
FloatReplaced
}
else
{
BlockType
:
:
FloatNonReplaced
}
}
else
if
self
.
is_inline_block_or_inline_flex
(
)
{
if
self
.
fragment
.
is_replaced
(
)
{
BlockType
:
:
InlineBlockReplaced
}
else
{
BlockType
:
:
InlineBlockNonReplaced
}
}
else
{
if
self
.
fragment
.
is_replaced
(
)
{
BlockType
:
:
Replaced
}
else
{
BlockType
:
:
NonReplaced
}
}
}
pub
fn
compute_used_inline_size
(
&
mut
self
shared_context
:
&
SharedStyleContext
containing_block_inline_size
:
Au
)
{
let
block_type
=
self
.
block_type
(
)
;
match
block_type
{
BlockType
:
:
AbsoluteReplaced
=
>
{
let
inline_size_computer
=
AbsoluteReplaced
;
inline_size_computer
.
compute_used_inline_size
(
self
shared_context
containing_block_inline_size
)
;
}
BlockType
:
:
AbsoluteNonReplaced
=
>
{
let
inline_size_computer
=
AbsoluteNonReplaced
;
inline_size_computer
.
compute_used_inline_size
(
self
shared_context
containing_block_inline_size
)
;
}
BlockType
:
:
FloatReplaced
=
>
{
let
inline_size_computer
=
FloatReplaced
;
inline_size_computer
.
compute_used_inline_size
(
self
shared_context
containing_block_inline_size
)
;
}
BlockType
:
:
FloatNonReplaced
=
>
{
let
inline_size_computer
=
FloatNonReplaced
;
inline_size_computer
.
compute_used_inline_size
(
self
shared_context
containing_block_inline_size
)
;
}
BlockType
:
:
InlineBlockReplaced
=
>
{
let
inline_size_computer
=
InlineBlockReplaced
;
inline_size_computer
.
compute_used_inline_size
(
self
shared_context
containing_block_inline_size
)
;
}
BlockType
:
:
InlineBlockNonReplaced
=
>
{
let
inline_size_computer
=
InlineBlockNonReplaced
;
inline_size_computer
.
compute_used_inline_size
(
self
shared_context
containing_block_inline_size
)
;
}
BlockType
:
:
Replaced
=
>
{
let
inline_size_computer
=
BlockReplaced
;
inline_size_computer
.
compute_used_inline_size
(
self
shared_context
containing_block_inline_size
)
;
}
BlockType
:
:
NonReplaced
=
>
{
let
inline_size_computer
=
BlockNonReplaced
;
inline_size_computer
.
compute_used_inline_size
(
self
shared_context
containing_block_inline_size
)
;
}
BlockType
:
:
InlineFlexItem
=
>
{
let
inline_size_computer
=
InlineFlexItem
;
inline_size_computer
.
compute_used_inline_size
(
self
shared_context
containing_block_inline_size
)
;
}
}
}
pub
fn
fragment
(
&
mut
self
)
-
>
&
mut
Fragment
{
&
mut
self
.
fragment
}
pub
fn
stacking_relative_border_box
(
&
self
coor
:
CoordinateSystem
)
-
>
Rect
<
Au
>
{
return
self
.
fragment
.
stacking_relative_border_box
(
&
self
.
base
.
stacking_relative_position
&
self
.
base
.
early_absolute_position_info
.
relative_containing_block_size
self
.
base
.
early_absolute_position_info
.
relative_containing_block_mode
coor
)
;
}
#
[
inline
]
pub
fn
containing_block_size
(
&
self
viewport_size
:
&
Size2D
<
Au
>
descendant
:
OpaqueFlow
)
-
>
LogicalSize
<
Au
>
{
debug_assert
!
(
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
)
;
if
self
.
is_fixed
(
)
|
|
self
.
is_root
(
)
{
LogicalSize
:
:
from_physical
(
self
.
base
.
writing_mode
*
viewport_size
)
}
else
{
self
.
base
.
absolute_cb
.
generated_containing_block_size
(
descendant
)
}
}
pub
fn
get_shrink_to_fit_inline_size
(
&
self
available_inline_size
:
Au
)
-
>
Au
{
let
content_intrinsic_inline_sizes
=
self
.
content_intrinsic_inline_sizes
(
)
;
min
(
content_intrinsic_inline_sizes
.
preferred_inline_size
max
(
content_intrinsic_inline_sizes
.
minimum_inline_size
available_inline_size
)
)
}
fn
adjust_fragments_for_collapsed_margins_if_root
(
&
mut
self
shared_context
:
&
SharedStyleContext
)
{
if
!
self
.
is_root
(
)
{
return
}
let
(
block_start_margin_value
block_end_margin_value
)
=
match
self
.
base
.
collapsible_margins
{
CollapsibleMargins
:
:
CollapseThrough
(
_
)
=
>
{
panic
!
(
"
Margins
unexpectedly
collapsed
through
root
flow
.
"
)
}
CollapsibleMargins
:
:
Collapse
(
block_start_margin
block_end_margin
)
=
>
{
(
block_start_margin
.
collapse
(
)
block_end_margin
.
collapse
(
)
)
}
CollapsibleMargins
:
:
None
(
block_start
block_end
)
=
>
(
block_start
block_end
)
}
;
if
block_start_margin_value
!
=
Au
(
0
)
{
for
kid
in
self
.
base
.
child_iter_mut
(
)
{
let
kid_base
=
kid
.
mut_base
(
)
;
kid_base
.
position
.
start
.
b
=
kid_base
.
position
.
start
.
b
+
block_start_margin_value
}
}
let
viewport_size
=
LogicalSize
:
:
from_physical
(
self
.
fragment
.
style
.
writing_mode
shared_context
.
viewport_size
(
)
)
;
let
block_size
=
max
(
viewport_size
.
block
self
.
fragment
.
border_box
.
size
.
block
+
block_start_margin_value
+
block_end_margin_value
)
;
self
.
base
.
position
.
size
.
block
=
block_size
;
self
.
fragment
.
border_box
.
size
.
block
=
block_size
;
}
fn
clone_with_children
(
&
self
new_children
:
FlowList
)
-
>
BlockFlow
{
BlockFlow
{
base
:
self
.
base
.
clone_with_children
(
new_children
)
fragment
:
self
.
fragment
.
clone
(
)
float
:
self
.
float
.
clone
(
)
.
.
*
self
}
}
fn
propagate_early_absolute_position_info_to_children
(
&
mut
self
)
{
for
kid
in
self
.
base
.
child_iter_mut
(
)
{
kid
.
mut_base
(
)
.
early_absolute_position_info
=
EarlyAbsolutePositionInfo
{
relative_containing_block_size
:
self
.
fragment
.
content_box
(
)
.
size
relative_containing_block_mode
:
self
.
fragment
.
style
(
)
.
writing_mode
}
}
}
#
[
inline
(
always
)
]
pub
fn
assign_block_size_block_base
(
&
mut
self
layout_context
:
&
LayoutContext
mut
fragmentation_context
:
Option
<
FragmentationContext
>
margins_may_collapse
:
MarginsMayCollapseFlag
)
-
>
Option
<
Arc
<
Flow
>
>
{
let
_scope
=
layout_debug_scope
!
(
"
assign_block_size_block_base
{
:
x
}
"
self
.
base
.
debug_id
(
)
)
;
let
mut
break_at
=
None
;
let
content_box
=
self
.
fragment
.
content_box
(
)
;
if
self
.
base
.
restyle_damage
.
contains
(
ServoRestyleDamage
:
:
REFLOW
)
{
let
mut
cur_b
=
Au
(
0
)
;
if
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
|
|
margins_may_collapse
!
=
MarginsMayCollapseFlag
:
:
MarginsMayCollapse
{
self
.
base
.
floats
=
Floats
:
:
new
(
self
.
fragment
.
style
.
writing_mode
)
;
}
let
writing_mode
=
self
.
base
.
floats
.
writing_mode
;
self
.
base
.
floats
.
translate
(
LogicalSize
:
:
new
(
writing_mode
-
self
.
fragment
.
inline_start_offset
(
)
Au
(
0
)
)
)
;
let
block_start_offset
=
self
.
fragment
.
border_padding
.
block_start
;
translate_including_floats
(
&
mut
cur_b
block_start_offset
&
mut
self
.
base
.
floats
)
;
let
can_collapse_block_start_margin_with_kids
=
margins_may_collapse
=
=
MarginsMayCollapseFlag
:
:
MarginsMayCollapse
&
&
!
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
&
&
self
.
fragment
.
border_padding
.
block_start
=
=
Au
(
0
)
;
let
mut
margin_collapse_info
=
MarginCollapseInfo
:
:
initialize_block_start_margin
(
&
self
.
fragment
can_collapse_block_start_margin_with_kids
)
;
let
mut
floats
=
self
.
base
.
floats
.
clone
(
)
;
let
thread_id
=
self
.
base
.
thread_id
;
let
(
mut
had_floated_children
mut
had_children_with_clearance
)
=
(
false
false
)
;
for
(
child_index
kid
)
in
self
.
base
.
child_iter_mut
(
)
.
enumerate
(
)
{
if
kid
.
base
(
)
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
if
kid
.
base
(
)
.
flags
.
contains
(
FlowFlags
:
:
BLOCK_POSITION_IS_STATIC
)
{
let
previous_bottom_margin
=
margin_collapse_info
.
current_float_ceiling
(
)
;
kid
.
mut_base
(
)
.
position
.
start
.
b
=
cur_b
+
kid
.
base
(
)
.
collapsible_margins
.
block_start_margin_for_noncollapsible_context
(
)
+
previous_bottom_margin
}
kid
.
place_float_if_applicable
(
)
;
if
!
kid
.
base
(
)
.
flags
.
is_float
(
)
{
kid
.
assign_block_size_for_inorder_child_if_necessary
(
layout_context
thread_id
content_box
)
;
}
continue
}
let
previous_b
=
cur_b
;
if
let
Some
(
ctx
)
=
fragmentation_context
{
let
child_ctx
=
FragmentationContext
{
available_block_size
:
ctx
.
available_block_size
-
cur_b
this_fragment_is_empty
:
ctx
.
this_fragment_is_empty
}
;
if
let
Some
(
remaining
)
=
kid
.
fragment
(
layout_context
Some
(
child_ctx
)
)
{
break_at
=
Some
(
(
child_index
+
1
Some
(
remaining
)
)
)
;
}
}
kid
.
mut_base
(
)
.
floats
=
floats
.
clone
(
)
;
if
kid
.
base
(
)
.
flags
.
is_float
(
)
{
had_floated_children
=
true
;
kid
.
mut_base
(
)
.
position
.
start
.
b
=
cur_b
;
{
let
kid_block
=
kid
.
as_mut_block
(
)
;
let
float_ceiling
=
margin_collapse_info
.
current_float_ceiling
(
)
;
kid_block
.
float
.
as_mut
(
)
.
unwrap
(
)
.
float_ceiling
=
float_ceiling
}
kid
.
place_float_if_applicable
(
)
;
let
kid_base
=
kid
.
mut_base
(
)
;
floats
=
kid_base
.
floats
.
clone
(
)
;
continue
}
if
kid
.
base
(
)
.
flags
.
clears_floats
(
)
{
kid
.
mut_base
(
)
.
floats
=
Floats
:
:
new
(
self
.
fragment
.
style
.
writing_mode
)
}
let
need_to_process_child_floats
=
kid
.
assign_block_size_for_inorder_child_if_necessary
(
layout_context
thread_id
content_box
)
;
if
!
had_children_with_clearance
&
&
floats
.
is_present
(
)
&
&
(
kid
.
base
(
)
.
flags
.
contains
(
FlowFlags
:
:
CLEARS_LEFT
)
|
|
kid
.
base
(
)
.
flags
.
contains
(
FlowFlags
:
:
CLEARS_RIGHT
)
)
{
had_children_with_clearance
=
true
}
let
delta
=
margin_collapse_info
.
advance_block_start_margin
(
&
kid
.
base
(
)
.
collapsible_margins
!
had_children_with_clearance
)
;
translate_including_floats
(
&
mut
cur_b
delta
&
mut
floats
)
;
if
let
CollapsibleMargins
:
:
CollapseThrough
(
_
)
=
kid
.
base
(
)
.
collapsible_margins
{
cur_b
=
cur_b
-
delta
;
}
let
clearance
=
match
(
kid
.
base
(
)
.
flags
.
contains
(
FlowFlags
:
:
CLEARS_LEFT
)
kid
.
base
(
)
.
flags
.
contains
(
FlowFlags
:
:
CLEARS_RIGHT
)
)
{
(
false
false
)
=
>
Au
(
0
)
(
true
false
)
=
>
floats
.
clearance
(
ClearType
:
:
Left
)
(
false
true
)
=
>
floats
.
clearance
(
ClearType
:
:
Right
)
(
true
true
)
=
>
floats
.
clearance
(
ClearType
:
:
Both
)
}
;
translate_including_floats
(
&
mut
cur_b
clearance
&
mut
floats
)
;
kid
.
mut_base
(
)
.
position
.
start
.
b
=
cur_b
;
if
need_to_process_child_floats
{
floats
=
kid
.
mut_base
(
)
.
floats
.
clone
(
)
}
let
kid_base
=
kid
.
mut_base
(
)
;
cur_b
=
cur_b
+
kid_base
.
position
.
size
.
block
;
let
delta
=
margin_collapse_info
.
advance_block_end_margin
(
&
kid_base
.
collapsible_margins
)
;
translate_including_floats
(
&
mut
cur_b
delta
&
mut
floats
)
;
let
collapse_delta
=
match
kid_base
.
collapsible_margins
{
CollapsibleMargins
:
:
CollapseThrough
(
_
)
=
>
{
let
delta
=
margin_collapse_info
.
current_float_ceiling
(
)
;
cur_b
=
cur_b
+
delta
;
kid_base
.
position
.
start
.
b
=
kid_base
.
position
.
start
.
b
+
delta
;
delta
}
_
=
>
Au
(
0
)
}
;
if
break_at
.
is_some
(
)
{
break
}
if
let
Some
(
ref
mut
ctx
)
=
fragmentation_context
{
if
cur_b
>
ctx
.
available_block_size
&
&
!
ctx
.
this_fragment_is_empty
{
break_at
=
Some
(
(
child_index
None
)
)
;
cur_b
=
previous_b
;
break
}
ctx
.
this_fragment_is_empty
=
false
}
cur_b
=
cur_b
-
collapse_delta
;
}
let
can_collapse_block_end_margin_with_kids
=
margins_may_collapse
=
=
MarginsMayCollapseFlag
:
:
MarginsMayCollapse
&
&
!
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
&
&
self
.
fragment
.
border_padding
.
block_end
=
=
Au
(
0
)
;
let
(
collapsible_margins
delta
)
=
margin_collapse_info
.
finish_and_compute_collapsible_margins
(
&
self
.
fragment
self
.
base
.
block_container_explicit_block_size
can_collapse_block_end_margin_with_kids
!
had_floated_children
)
;
self
.
base
.
collapsible_margins
=
collapsible_margins
;
translate_including_floats
(
&
mut
cur_b
delta
&
mut
floats
)
;
let
mut
block_size
=
cur_b
-
block_start_offset
;
let
is_root
=
self
.
is_root
(
)
;
if
is_root
|
|
self
.
formatting_context_type
(
)
!
=
FormattingContextType
:
:
None
|
|
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
block_size
=
block_size
+
floats
.
clearance
(
ClearType
:
:
Both
)
;
}
if
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
if
is_root
{
let
viewport_size
=
LogicalSize
:
:
from_physical
(
self
.
fragment
.
style
.
writing_mode
layout_context
.
shared_context
(
)
.
viewport_size
(
)
)
;
block_size
=
max
(
viewport_size
.
block
block_size
)
}
self
.
fragment
.
border_box
.
size
.
block
=
block_size
;
}
if
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
self
.
propagate_early_absolute_position_info_to_children
(
)
;
return
None
}
let
mut
candidate_block_size_iterator
=
CandidateBSizeIterator
:
:
new
(
&
self
.
fragment
self
.
base
.
block_container_explicit_block_size
)
;
while
let
Some
(
candidate_block_size
)
=
candidate_block_size_iterator
.
next
(
)
{
candidate_block_size_iterator
.
candidate_value
=
match
candidate_block_size
{
MaybeAuto
:
:
Auto
=
>
block_size
MaybeAuto
:
:
Specified
(
value
)
=
>
value
}
}
block_size
=
candidate_block_size_iterator
.
candidate_value
;
let
delta
=
block_size
-
(
cur_b
-
block_start_offset
)
;
translate_including_floats
(
&
mut
cur_b
delta
&
mut
floats
)
;
let
block_end_offset
=
self
.
fragment
.
border_padding
.
block_end
;
translate_including_floats
(
&
mut
cur_b
block_end_offset
&
mut
floats
)
;
self
.
fragment
.
border_box
.
size
.
block
=
cur_b
;
self
.
fragment
.
border_box
.
start
.
b
=
Au
(
0
)
;
self
.
base
.
position
.
size
.
block
=
cur_b
;
self
.
propagate_early_absolute_position_info_to_children
(
)
;
floats
.
translate
(
LogicalSize
:
:
new
(
writing_mode
self
.
fragment
.
inline_start_offset
(
)
Au
(
0
)
)
)
;
self
.
base
.
floats
=
floats
.
clone
(
)
;
self
.
adjust_fragments_for_collapsed_margins_if_root
(
layout_context
.
shared_context
(
)
)
;
}
else
{
let
thread_id
=
self
.
base
.
thread_id
;
for
kid
in
self
.
base
.
child_iter_mut
(
)
{
kid
.
assign_block_size_for_inorder_child_if_necessary
(
layout_context
thread_id
content_box
)
;
}
}
if
(
&
*
self
as
&
Flow
)
.
contains_roots_of_absolute_flow_tree
(
)
{
let
assign_abs_b_sizes
=
AbsoluteAssignBSizesTraversal
(
layout_context
.
shared_context
(
)
)
;
assign_abs_b_sizes
.
traverse_absolute_flows
(
&
mut
*
self
)
;
}
if
(
self
.
base
.
flags
.
is_float
(
)
|
|
self
.
formatting_context_type
(
)
=
=
FormattingContextType
:
:
None
)
&
&
!
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
self
.
base
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
;
self
.
fragment
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
;
}
break_at
.
and_then
(
|
(
i
child_remaining
)
|
{
if
i
=
=
self
.
base
.
children
.
len
(
)
&
&
child_remaining
.
is_none
(
)
{
None
}
else
{
let
mut
children
=
self
.
base
.
children
.
split_off
(
i
)
;
if
let
Some
(
child
)
=
child_remaining
{
children
.
push_front_arc
(
child
)
;
}
Some
(
Arc
:
:
new
(
self
.
clone_with_children
(
children
)
)
as
Arc
<
Flow
>
)
}
}
)
}
pub
fn
place_float
(
&
mut
self
)
{
let
block_size
=
self
.
fragment
.
border_box
.
size
.
block
;
let
clearance
=
match
self
.
fragment
.
clear
(
)
{
None
=
>
Au
(
0
)
Some
(
clear
)
=
>
self
.
base
.
floats
.
clearance
(
clear
)
}
;
let
float_info
:
FloatedBlockInfo
=
(
*
*
self
.
float
.
as_ref
(
)
.
unwrap
(
)
)
.
clone
(
)
;
let
inline_size_for_float_placement
=
self
.
base
.
position
.
size
.
inline
+
min
(
Au
(
0
)
self
.
fragment
.
margin
.
inline_start_end
(
)
)
;
let
info
=
PlacementInfo
{
size
:
LogicalSize
:
:
new
(
self
.
fragment
.
style
.
writing_mode
inline_size_for_float_placement
block_size
+
self
.
fragment
.
margin
.
block_start_end
(
)
)
.
convert
(
self
.
fragment
.
style
.
writing_mode
self
.
base
.
floats
.
writing_mode
)
ceiling
:
clearance
+
float_info
.
float_ceiling
max_inline_size
:
float_info
.
containing_inline_size
kind
:
float_info
.
float_kind
}
;
self
.
base
.
floats
.
add_float
(
&
info
)
;
let
container_size
=
Size2D
:
:
new
(
self
.
base
.
block_container_inline_size
Au
(
0
)
)
;
let
float_offset
=
self
.
base
.
floats
.
last_float_pos
(
)
.
unwrap
(
)
.
convert
(
self
.
base
.
floats
.
writing_mode
self
.
base
.
writing_mode
container_size
)
.
start
;
let
margin_offset
=
LogicalPoint
:
:
new
(
self
.
base
.
writing_mode
Au
(
0
)
self
.
fragment
.
margin
.
block_start
)
;
let
mut
origin
=
LogicalPoint
:
:
new
(
self
.
base
.
writing_mode
self
.
base
.
position
.
start
.
i
self
.
base
.
position
.
start
.
b
)
;
origin
=
origin
.
add_point
(
&
float_offset
)
.
add_point
(
&
margin_offset
)
;
self
.
base
.
position
=
LogicalRect
:
:
from_point_size
(
self
.
base
.
writing_mode
origin
self
.
base
.
position
.
size
)
;
}
pub
fn
explicit_block_containing_size
(
&
self
shared_context
:
&
SharedStyleContext
)
-
>
Option
<
Au
>
{
if
self
.
is_root
(
)
|
|
self
.
is_fixed
(
)
{
let
viewport_size
=
LogicalSize
:
:
from_physical
(
self
.
fragment
.
style
.
writing_mode
shared_context
.
viewport_size
(
)
)
;
Some
(
viewport_size
.
block
)
}
else
if
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
&
&
self
.
base
.
block_container_explicit_block_size
.
is_none
(
)
{
self
.
base
.
absolute_cb
.
explicit_block_containing_size
(
shared_context
)
}
else
{
self
.
base
.
block_container_explicit_block_size
}
}
pub
fn
explicit_block_size
(
&
self
containing_block_size
:
Option
<
Au
>
)
-
>
Option
<
Au
>
{
let
content_block_size
=
self
.
fragment
.
style
(
)
.
content_block_size
(
)
;
match
(
content_block_size
containing_block_size
)
{
(
LengthOrPercentageOrAuto
:
:
Calc
(
calc
)
_
)
=
>
{
calc
.
to_used_value
(
containing_block_size
)
}
(
LengthOrPercentageOrAuto
:
:
Length
(
length
)
_
)
=
>
Some
(
Au
:
:
from
(
length
)
)
(
LengthOrPercentageOrAuto
:
:
Percentage
(
percent
)
Some
(
container_size
)
)
=
>
{
Some
(
container_size
.
scale_by
(
percent
.
0
)
)
}
(
LengthOrPercentageOrAuto
:
:
Percentage
(
_
)
None
)
|
(
LengthOrPercentageOrAuto
:
:
Auto
None
)
=
>
{
None
}
(
LengthOrPercentageOrAuto
:
:
Auto
Some
(
container_size
)
)
=
>
{
let
(
block_start
block_end
)
=
{
let
position
=
self
.
fragment
.
style
(
)
.
logical_position
(
)
;
(
MaybeAuto
:
:
from_style
(
position
.
block_start
container_size
)
MaybeAuto
:
:
from_style
(
position
.
block_end
container_size
)
)
}
;
match
(
block_start
block_end
)
{
(
MaybeAuto
:
:
Specified
(
block_start
)
MaybeAuto
:
:
Specified
(
block_end
)
)
=
>
{
let
available_block_size
=
container_size
-
self
.
fragment
.
border_padding
.
block_start_end
(
)
;
let
margin
=
self
.
fragment
.
style
(
)
.
logical_margin
(
)
;
let
margin_block_start
=
match
margin
.
block_start
{
LengthOrPercentageOrAuto
:
:
Auto
=
>
MaybeAuto
:
:
Auto
_
=
>
MaybeAuto
:
:
Specified
(
self
.
fragment
.
margin
.
block_start
)
}
;
let
margin_block_end
=
match
margin
.
block_end
{
LengthOrPercentageOrAuto
:
:
Auto
=
>
MaybeAuto
:
:
Auto
_
=
>
MaybeAuto
:
:
Specified
(
self
.
fragment
.
margin
.
block_end
)
}
;
let
margin_block_start
=
margin_block_start
.
specified_or_zero
(
)
;
let
margin_block_end
=
margin_block_end
.
specified_or_zero
(
)
;
let
sum
=
block_start
+
block_end
+
margin_block_start
+
margin_block_end
;
Some
(
available_block_size
-
sum
)
}
(
_
_
)
=
>
{
None
}
}
}
}
}
fn
calculate_absolute_block_size_and_margins
(
&
mut
self
shared_context
:
&
SharedStyleContext
)
{
let
opaque_self
=
OpaqueFlow
:
:
from_flow
(
self
)
;
let
containing_block_block_size
=
self
.
containing_block_size
(
&
shared_context
.
viewport_size
(
)
opaque_self
)
.
block
;
let
content_block_size
=
self
.
fragment
.
border_box
.
size
.
block
;
let
mut
solution
=
None
;
{
let
margin
=
self
.
fragment
.
style
(
)
.
logical_margin
(
)
;
let
margin_block_start
=
match
margin
.
block_start
{
LengthOrPercentageOrAuto
:
:
Auto
=
>
MaybeAuto
:
:
Auto
_
=
>
MaybeAuto
:
:
Specified
(
self
.
fragment
.
margin
.
block_start
)
}
;
let
margin_block_end
=
match
margin
.
block_end
{
LengthOrPercentageOrAuto
:
:
Auto
=
>
MaybeAuto
:
:
Auto
_
=
>
MaybeAuto
:
:
Specified
(
self
.
fragment
.
margin
.
block_end
)
}
;
let
block_start
;
let
block_end
;
{
let
position
=
self
.
fragment
.
style
(
)
.
logical_position
(
)
;
block_start
=
MaybeAuto
:
:
from_style
(
position
.
block_start
containing_block_block_size
)
;
block_end
=
MaybeAuto
:
:
from_style
(
position
.
block_end
containing_block_block_size
)
;
}
let
available_block_size
=
containing_block_block_size
-
self
.
fragment
.
border_padding
.
block_start_end
(
)
;
if
self
.
fragment
.
is_replaced
(
)
{
self
.
fragment
.
assign_replaced_block_size_if_necessary
(
)
;
let
block_size_used_val
=
self
.
fragment
.
border_box
.
size
.
block
;
solution
=
Some
(
BSizeConstraintSolution
:
:
solve_vertical_constraints_abs_replaced
(
block_size_used_val
margin_block_start
margin_block_end
block_start
block_end
content_block_size
available_block_size
)
)
}
else
{
let
mut
candidate_block_size_iterator
=
CandidateBSizeIterator
:
:
new
(
&
self
.
fragment
Some
(
containing_block_block_size
)
)
;
while
let
Some
(
block_size_used_val
)
=
candidate_block_size_iterator
.
next
(
)
{
solution
=
Some
(
BSizeConstraintSolution
:
:
solve_vertical_constraints_abs_nonreplaced
(
block_size_used_val
margin_block_start
margin_block_end
block_start
block_end
content_block_size
available_block_size
)
)
;
candidate_block_size_iterator
.
candidate_value
=
solution
.
unwrap
(
)
.
block_size
;
}
}
}
let
solution
=
solution
.
unwrap
(
)
;
self
.
fragment
.
margin
.
block_start
=
solution
.
margin_block_start
;
self
.
fragment
.
margin
.
block_end
=
solution
.
margin_block_end
;
self
.
fragment
.
border_box
.
start
.
b
=
Au
(
0
)
;
if
!
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
BLOCK_POSITION_IS_STATIC
)
{
self
.
base
.
position
.
start
.
b
=
solution
.
block_start
+
self
.
fragment
.
margin
.
block_start
}
let
block_size
=
solution
.
block_size
+
self
.
fragment
.
border_padding
.
block_start_end
(
)
;
self
.
fragment
.
border_box
.
size
.
block
=
block_size
;
self
.
base
.
position
.
size
.
block
=
block_size
;
self
.
base
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
;
self
.
fragment
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
;
}
fn
propagate_and_compute_used_inline_size
(
&
mut
self
shared_context
:
&
SharedStyleContext
)
{
let
containing_block_inline_size
=
self
.
base
.
block_container_inline_size
;
self
.
compute_used_inline_size
(
shared_context
containing_block_inline_size
)
;
if
self
.
base
.
flags
.
is_float
(
)
{
self
.
float
.
as_mut
(
)
.
unwrap
(
)
.
containing_inline_size
=
containing_block_inline_size
}
}
#
[
inline
(
always
)
]
pub
fn
propagate_assigned_inline_size_to_children
<
F
>
(
&
mut
self
shared_context
:
&
SharedStyleContext
inline_start_content_edge
:
Au
inline_end_content_edge
:
Au
content_inline_size
:
Au
mut
callback
:
F
)
where
F
:
FnMut
(
&
mut
Flow
usize
Au
WritingMode
&
mut
Au
&
mut
Au
)
{
let
flags
=
self
.
base
.
flags
.
clone
(
)
;
let
opaque_self
=
OpaqueFlow
:
:
from_flow
(
self
)
;
let
box_border
=
match
self
.
fragment
.
style
(
)
.
get_position
(
)
.
box_sizing
{
BoxSizing
:
:
BorderBox
=
>
self
.
fragment
.
border_padding
.
block_start_end
(
)
BoxSizing
:
:
ContentBox
=
>
Au
(
0
)
}
;
let
parent_container_size
=
self
.
explicit_block_containing_size
(
shared_context
)
;
let
mut
explicit_content_size
=
self
.
explicit_block_size
(
parent_container_size
)
.
map
(
|
x
|
if
x
<
box_border
{
Au
(
0
)
}
else
{
x
-
box_border
}
)
;
if
self
.
is_root
(
)
{
explicit_content_size
=
max
(
parent_container_size
explicit_content_size
)
;
}
let
containing_block_size
=
if
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
self
.
containing_block_size
(
&
shared_context
.
viewport_size
(
)
opaque_self
)
.
inline
}
else
{
content_inline_size
}
;
let
containing_block_mode
=
self
.
base
.
writing_mode
;
let
mut
inline_start_margin_edge
=
inline_start_content_edge
;
let
mut
inline_end_margin_edge
=
inline_end_content_edge
;
let
mut
iterator
=
self
.
base
.
child_iter_mut
(
)
.
enumerate
(
)
.
peekable
(
)
;
while
let
Some
(
(
i
kid
)
)
=
iterator
.
next
(
)
{
kid
.
mut_base
(
)
.
block_container_explicit_block_size
=
explicit_content_size
;
let
kid_mode
=
kid
.
base
(
)
.
writing_mode
;
{
let
kid_base
=
kid
.
mut_base
(
)
;
let
reflow_damage
=
if
kid_base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
}
else
{
ServoRestyleDamage
:
:
REFLOW
}
;
if
kid_base
.
flags
.
contains
(
FlowFlags
:
:
INLINE_POSITION_IS_STATIC
)
&
&
kid_base
.
restyle_damage
.
contains
(
reflow_damage
)
{
kid_base
.
position
.
start
.
i
=
if
kid_mode
.
is_bidi_ltr
(
)
=
=
containing_block_mode
.
is_bidi_ltr
(
)
{
inline_start_content_edge
}
else
{
inline_end_content_edge
}
;
}
kid_base
.
block_container_inline_size
=
content_inline_size
;
kid_base
.
block_container_writing_mode
=
containing_block_mode
;
}
callback
(
kid
i
content_inline_size
containing_block_mode
&
mut
inline_start_margin_edge
&
mut
inline_end_margin_edge
)
;
let
containing_block_text_align
=
self
.
fragment
.
style
(
)
.
get_inheritedtext
(
)
.
text_align
;
kid
.
mut_base
(
)
.
flags
.
set_text_align
(
containing_block_text_align
)
;
if
kid
.
is_inline_flow
(
)
{
kid
.
as_mut_inline
(
)
.
first_line_indentation
=
self
.
fragment
.
style
(
)
.
get_inheritedtext
(
)
.
text_indent
.
to_used_value
(
containing_block_size
)
;
}
}
}
pub
fn
formatting_context_type
(
&
self
)
-
>
FormattingContextType
{
if
self
.
is_inline_flex_item
(
)
|
|
self
.
is_block_flex_item
(
)
{
return
FormattingContextType
:
:
Other
}
let
style
=
self
.
fragment
.
style
(
)
;
if
style
.
get_box
(
)
.
float
!
=
Float
:
:
None
{
return
FormattingContextType
:
:
Other
}
match
style
.
get_box
(
)
.
display
{
Display
:
:
TableCell
|
Display
:
:
TableCaption
|
Display
:
:
TableRowGroup
|
Display
:
:
Table
|
Display
:
:
InlineBlock
|
Display
:
:
Flex
=
>
{
FormattingContextType
:
:
Other
}
_
if
style
.
get_box
(
)
.
overflow_x
!
=
StyleOverflow
:
:
Visible
|
|
style
.
get_box
(
)
.
overflow_y
!
=
StyleOverflow
:
:
Visible
|
|
style
.
is_multicol
(
)
=
>
{
FormattingContextType
:
:
Block
}
_
=
>
FormattingContextType
:
:
None
}
}
fn
assign_inline_position_for_formatting_context
(
&
mut
self
layout_context
:
&
LayoutContext
content_box
:
LogicalRect
<
Au
>
)
{
debug_assert_ne
!
(
self
.
formatting_context_type
(
)
FormattingContextType
:
:
None
)
;
if
!
self
.
base
.
restyle_damage
.
intersects
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
{
return
}
self
.
base
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
;
self
.
fragment
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
;
if
!
self
.
base
.
might_have_floats_in
(
)
{
return
}
debug_assert
!
(
!
self
.
is_inline_flex_item
(
)
)
;
let
rect
=
self
.
base
.
floats
.
available_rect
(
Au
(
0
)
self
.
fragment
.
border_box
.
size
.
block
content_box
.
size
.
inline
)
;
let
available_inline_size
=
if
let
Some
(
rect
)
=
rect
{
let
inline_offset
=
if
self
.
fragment
.
margin
.
inline_start
<
rect
.
start
.
i
{
rect
.
start
.
i
-
max
(
Au
(
0
)
self
.
fragment
.
margin
.
inline_start
)
}
else
{
Au
(
0
)
}
;
self
.
base
.
position
.
start
.
i
=
content_box
.
start
.
i
+
inline_offset
;
let
end
=
content_box
.
size
.
inline
-
rect
.
start
.
i
-
rect
.
size
.
inline
;
let
inline_end_offset
=
if
self
.
fragment
.
margin
.
inline_end
<
end
{
end
-
max
(
Au
(
0
)
self
.
fragment
.
margin
.
inline_end
)
}
else
{
Au
(
0
)
}
;
content_box
.
size
.
inline
-
inline_offset
-
inline_end_offset
}
else
{
content_box
.
size
.
inline
}
-
self
.
fragment
.
margin
.
inline_start_end
(
)
;
let
max_inline_size
=
self
.
fragment
.
style
(
)
.
max_inline_size
(
)
.
to_used_value
(
self
.
base
.
block_container_inline_size
)
.
unwrap_or
(
MAX_AU
)
;
let
min_inline_size
=
self
.
fragment
.
style
(
)
.
min_inline_size
(
)
.
to_used_value
(
self
.
base
.
block_container_inline_size
)
;
let
specified_inline_size
=
self
.
fragment
.
style
(
)
.
content_inline_size
(
)
;
let
container_size
=
self
.
base
.
block_container_inline_size
;
let
inline_size
=
if
let
MaybeAuto
:
:
Specified
(
size
)
=
MaybeAuto
:
:
from_style
(
specified_inline_size
container_size
)
{
match
self
.
fragment
.
style
(
)
.
get_position
(
)
.
box_sizing
{
BoxSizing
:
:
BorderBox
=
>
size
BoxSizing
:
:
ContentBox
=
>
size
+
self
.
fragment
.
border_padding
.
inline_start_end
(
)
}
}
else
{
max
(
min_inline_size
min
(
available_inline_size
max_inline_size
)
)
}
;
self
.
base
.
position
.
size
.
inline
=
inline_size
+
self
.
fragment
.
margin
.
inline_start_end
(
)
;
if
self
.
fragment
.
margin_box_inline_size
(
)
!
=
self
.
base
.
position
.
size
.
inline
{
debug
!
(
"
assign_inline_position_for_formatting_context
:
float
speculation
failed
"
)
;
self
.
fragment
.
border_box
.
size
.
inline
=
inline_size
;
self
.
assign_inline_sizes
(
layout_context
)
;
for
child
in
self
.
base
.
child_iter_mut
(
)
{
sequential
:
:
reflow
(
child
layout_context
RelayoutMode
:
:
Force
)
;
}
self
.
assign_block_size
(
layout_context
)
;
}
debug_assert_eq
!
(
self
.
fragment
.
margin_box_inline_size
(
)
self
.
base
.
position
.
size
.
inline
)
;
}
fn
is_inline_block_or_inline_flex
(
&
self
)
-
>
bool
{
self
.
fragment
.
style
(
)
.
get_box
(
)
.
display
=
=
Display
:
:
InlineBlock
|
|
self
.
fragment
.
style
(
)
.
get_box
(
)
.
display
=
=
Display
:
:
InlineFlex
}
fn
content_intrinsic_inline_sizes
(
&
self
)
-
>
IntrinsicISizes
{
let
(
border_padding
margin
)
=
self
.
fragment
.
surrounding_intrinsic_inline_size
(
)
;
IntrinsicISizes
{
minimum_inline_size
:
self
.
base
.
intrinsic_inline_sizes
.
minimum_inline_size
-
border_padding
-
margin
preferred_inline_size
:
self
.
base
.
intrinsic_inline_sizes
.
preferred_inline_size
-
border_padding
-
margin
}
}
pub
fn
bubble_inline_sizes_for_block
(
&
mut
self
consult_children
:
bool
)
{
let
_scope
=
layout_debug_scope
!
(
"
block
:
:
bubble_inline_sizes
{
:
x
}
"
self
.
base
.
debug_id
(
)
)
;
let
mut
flags
=
self
.
base
.
flags
;
if
self
.
definitely_has_zero_block_size
(
)
{
flags
.
remove
(
FlowFlags
:
:
CONTAINS_TEXT_OR_REPLACED_FRAGMENTS
)
;
}
else
if
self
.
fragment
.
is_text_or_replaced
(
)
{
flags
.
insert
(
FlowFlags
:
:
CONTAINS_TEXT_OR_REPLACED_FRAGMENTS
)
;
}
else
{
flags
.
remove
(
FlowFlags
:
:
CONTAINS_TEXT_OR_REPLACED_FRAGMENTS
)
;
for
kid
in
self
.
base
.
children
.
iter
(
)
{
if
kid
.
base
(
)
.
flags
.
contains
(
FlowFlags
:
:
CONTAINS_TEXT_OR_REPLACED_FRAGMENTS
)
{
flags
.
insert
(
FlowFlags
:
:
CONTAINS_TEXT_OR_REPLACED_FRAGMENTS
)
;
break
}
}
}
let
mut
computation
=
self
.
fragment
.
compute_intrinsic_inline_sizes
(
)
;
let
(
mut
left_float_width
mut
right_float_width
)
=
(
Au
(
0
)
Au
(
0
)
)
;
let
(
mut
left_float_width_accumulator
mut
right_float_width_accumulator
)
=
(
Au
(
0
)
Au
(
0
)
)
;
let
mut
preferred_inline_size_of_children_without_text_or_replaced_fragments
=
Au
(
0
)
;
for
kid
in
self
.
base
.
child_iter_mut
(
)
{
if
kid
.
base
(
)
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
|
|
!
consult_children
{
continue
}
let
child_base
=
kid
.
mut_base
(
)
;
let
float_kind
=
child_base
.
flags
.
float_kind
(
)
;
computation
.
content_intrinsic_sizes
.
minimum_inline_size
=
max
(
computation
.
content_intrinsic_sizes
.
minimum_inline_size
child_base
.
intrinsic_inline_sizes
.
minimum_inline_size
)
;
if
child_base
.
flags
.
contains
(
FlowFlags
:
:
CLEARS_LEFT
)
{
left_float_width
=
max
(
left_float_width
left_float_width_accumulator
)
;
left_float_width_accumulator
=
Au
(
0
)
}
if
child_base
.
flags
.
contains
(
FlowFlags
:
:
CLEARS_RIGHT
)
{
right_float_width
=
max
(
right_float_width
right_float_width_accumulator
)
;
right_float_width_accumulator
=
Au
(
0
)
}
match
(
float_kind
child_base
.
flags
.
contains
(
FlowFlags
:
:
CONTAINS_TEXT_OR_REPLACED_FRAGMENTS
)
)
{
(
Float
:
:
None
true
)
=
>
{
computation
.
content_intrinsic_sizes
.
preferred_inline_size
=
max
(
computation
.
content_intrinsic_sizes
.
preferred_inline_size
child_base
.
intrinsic_inline_sizes
.
preferred_inline_size
)
;
}
(
Float
:
:
None
false
)
=
>
{
preferred_inline_size_of_children_without_text_or_replaced_fragments
=
max
(
preferred_inline_size_of_children_without_text_or_replaced_fragments
child_base
.
intrinsic_inline_sizes
.
preferred_inline_size
)
}
(
Float
:
:
Left
_
)
=
>
{
left_float_width_accumulator
=
left_float_width_accumulator
+
child_base
.
intrinsic_inline_sizes
.
preferred_inline_size
;
}
(
Float
:
:
Right
_
)
=
>
{
right_float_width_accumulator
=
right_float_width_accumulator
+
child_base
.
intrinsic_inline_sizes
.
preferred_inline_size
;
}
}
}
left_float_width
=
max
(
left_float_width
left_float_width_accumulator
)
;
right_float_width
=
max
(
right_float_width
right_float_width_accumulator
)
;
computation
.
content_intrinsic_sizes
.
preferred_inline_size
=
computation
.
content_intrinsic_sizes
.
preferred_inline_size
+
left_float_width
+
right_float_width
;
computation
.
content_intrinsic_sizes
.
preferred_inline_size
=
max
(
computation
.
content_intrinsic_sizes
.
preferred_inline_size
preferred_inline_size_of_children_without_text_or_replaced_fragments
)
;
self
.
base
.
intrinsic_inline_sizes
=
computation
.
finish
(
)
;
self
.
base
.
flags
=
flags
}
pub
fn
overflow_style_may_require_clip_scroll_node
(
&
self
)
-
>
bool
{
match
(
self
.
fragment
.
style
(
)
.
get_box
(
)
.
overflow_x
self
.
fragment
.
style
(
)
.
get_box
(
)
.
overflow_y
)
{
(
StyleOverflow
:
:
Auto
_
)
|
(
StyleOverflow
:
:
Scroll
_
)
|
(
StyleOverflow
:
:
Hidden
_
)
|
(
_
StyleOverflow
:
:
Auto
)
|
(
_
StyleOverflow
:
:
Scroll
)
|
(
_
StyleOverflow
:
:
Hidden
)
=
>
true
(
_
_
)
=
>
false
}
}
pub
fn
compute_inline_sizes
(
&
mut
self
shared_context
:
&
SharedStyleContext
)
{
if
!
self
.
base
.
restyle_damage
.
intersects
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
{
return
}
debug
!
(
"
assign_inline_sizes
(
{
}
)
:
assigning
inline_size
for
flow
"
if
self
.
base
.
flags
.
is_float
(
)
{
"
float
"
}
else
{
"
block
"
}
)
;
self
.
base
.
floats
=
Floats
:
:
new
(
self
.
base
.
writing_mode
)
;
self
.
initialize_container_size_for_root
(
shared_context
)
;
self
.
propagate_and_compute_used_inline_size
(
shared_context
)
;
self
.
guess_inline_size_for_block_formatting_context_if_necessary
(
)
}
pub
fn
initialize_container_size_for_root
(
&
mut
self
shared_context
:
&
SharedStyleContext
)
{
if
self
.
is_root
(
)
{
debug
!
(
"
Setting
root
position
"
)
;
self
.
base
.
position
.
start
=
LogicalPoint
:
:
zero
(
self
.
base
.
writing_mode
)
;
self
.
base
.
block_container_inline_size
=
LogicalSize
:
:
from_physical
(
self
.
base
.
writing_mode
shared_context
.
viewport_size
(
)
)
.
inline
;
self
.
base
.
block_container_writing_mode
=
self
.
base
.
writing_mode
;
}
}
fn
guess_inline_size_for_block_formatting_context_if_necessary
(
&
mut
self
)
{
if
self
.
formatting_context_type
(
)
!
=
FormattingContextType
:
:
Block
{
return
}
if
self
.
fragment
.
style
.
max_inline_size
(
)
!
=
LengthOrPercentageOrNone
:
:
None
{
return
}
let
speculated_left_float_size
=
if
self
.
fragment
.
margin
.
inline_start
>
=
Au
(
0
)
&
&
self
.
base
.
speculated_float_placement_in
.
left
>
self
.
fragment
.
margin
.
inline_start
{
self
.
base
.
speculated_float_placement_in
.
left
-
self
.
fragment
.
margin
.
inline_start
}
else
{
Au
(
0
)
}
;
let
speculated_right_float_size
=
if
self
.
fragment
.
margin
.
inline_end
>
=
Au
(
0
)
&
&
self
.
base
.
speculated_float_placement_in
.
right
>
self
.
fragment
.
margin
.
inline_end
{
self
.
base
.
speculated_float_placement_in
.
right
-
self
.
fragment
.
margin
.
inline_end
}
else
{
Au
(
0
)
}
;
self
.
fragment
.
border_box
.
size
.
inline
=
self
.
fragment
.
border_box
.
size
.
inline
-
speculated_left_float_size
-
speculated_right_float_size
}
fn
definitely_has_zero_block_size
(
&
self
)
-
>
bool
{
if
!
self
.
fragment
.
style
.
content_block_size
(
)
.
is_definitely_zero
(
)
{
return
false
}
let
border_width
=
self
.
fragment
.
border_width
(
)
;
if
border_width
.
block_start
!
=
Au
(
0
)
|
|
border_width
.
block_end
!
=
Au
(
0
)
{
return
false
}
let
padding
=
self
.
fragment
.
style
.
logical_padding
(
)
;
padding
.
block_start
.
is_definitely_zero
(
)
&
&
padding
.
block_end
.
is_definitely_zero
(
)
}
pub
fn
is_inline_flex_item
(
&
self
)
-
>
bool
{
self
.
fragment
.
flags
.
contains
(
FragmentFlags
:
:
IS_INLINE_FLEX_ITEM
)
}
pub
fn
is_block_flex_item
(
&
self
)
-
>
bool
{
self
.
fragment
.
flags
.
contains
(
FragmentFlags
:
:
IS_BLOCK_FLEX_ITEM
)
}
pub
fn
mark_scrolling_overflow
(
&
mut
self
has_scrolling_overflow
:
bool
)
{
if
has_scrolling_overflow
{
self
.
flags
.
insert
(
BlockFlowFlags
:
:
HAS_SCROLLING_OVERFLOW
)
;
}
else
{
self
.
flags
.
remove
(
BlockFlowFlags
:
:
HAS_SCROLLING_OVERFLOW
)
;
}
}
pub
fn
has_scrolling_overflow
(
&
self
)
-
>
bool
{
self
.
flags
.
contains
(
BlockFlowFlags
:
:
HAS_SCROLLING_OVERFLOW
)
}
pub
fn
sticky_position
(
&
self
)
-
>
SideOffsets2D
<
MaybeAuto
>
{
let
containing_block_size
=
&
self
.
base
.
early_absolute_position_info
.
relative_containing_block_size
;
let
writing_mode
=
self
.
base
.
early_absolute_position_info
.
relative_containing_block_mode
;
let
offsets
=
self
.
fragment
.
style
(
)
.
logical_position
(
)
;
let
as_margins
=
LogicalMargin
:
:
new
(
writing_mode
MaybeAuto
:
:
from_style
(
offsets
.
block_start
containing_block_size
.
inline
)
MaybeAuto
:
:
from_style
(
offsets
.
inline_end
containing_block_size
.
inline
)
MaybeAuto
:
:
from_style
(
offsets
.
block_end
containing_block_size
.
inline
)
MaybeAuto
:
:
from_style
(
offsets
.
inline_start
containing_block_size
.
inline
)
)
;
as_margins
.
to_physical
(
writing_mode
)
}
pub
fn
background_border_section
(
&
self
)
-
>
DisplayListSection
{
if
self
.
base
.
flags
.
is_float
(
)
{
DisplayListSection
:
:
BackgroundAndBorders
}
else
if
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
if
self
.
fragment
.
establishes_stacking_context
(
)
{
DisplayListSection
:
:
BackgroundAndBorders
}
else
{
DisplayListSection
:
:
BlockBackgroundsAndBorders
}
}
else
{
DisplayListSection
:
:
BlockBackgroundsAndBorders
}
}
}
impl
Flow
for
BlockFlow
{
fn
class
(
&
self
)
-
>
FlowClass
{
FlowClass
:
:
Block
}
fn
as_mut_block
(
&
mut
self
)
-
>
&
mut
BlockFlow
{
self
}
fn
as_block
(
&
self
)
-
>
&
BlockFlow
{
self
}
fn
bubble_inline_sizes
(
&
mut
self
)
{
let
consult_children
=
match
self
.
fragment
.
style
(
)
.
get_position
(
)
.
width
{
LengthOrPercentageOrAuto
:
:
Length
(
_
)
=
>
false
_
=
>
true
}
;
self
.
bubble_inline_sizes_for_block
(
consult_children
)
;
self
.
fragment
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
BUBBLE_ISIZES
)
;
}
fn
assign_inline_sizes
(
&
mut
self
layout_context
:
&
LayoutContext
)
{
let
_scope
=
layout_debug_scope
!
(
"
block
:
:
assign_inline_sizes
{
:
x
}
"
self
.
base
.
debug_id
(
)
)
;
let
shared_context
=
layout_context
.
shared_context
(
)
;
self
.
compute_inline_sizes
(
shared_context
)
;
let
inline_start_content_edge
=
self
.
fragment
.
border_box
.
start
.
i
+
self
.
fragment
.
border_padding
.
inline_start
;
let
padding_and_borders
=
self
.
fragment
.
border_padding
.
inline_start_end
(
)
;
let
inline_end_content_edge
=
self
.
fragment
.
margin
.
inline_end
+
self
.
fragment
.
border_padding
.
inline_end
;
let
content_inline_size
=
self
.
fragment
.
border_box
.
size
.
inline
-
padding_and_borders
;
self
.
propagate_assigned_inline_size_to_children
(
shared_context
inline_start_content_edge
inline_end_content_edge
content_inline_size
|
_
_
_
_
_
_
|
{
}
)
;
}
fn
place_float_if_applicable
<
'
a
>
(
&
mut
self
)
{
if
self
.
base
.
flags
.
is_float
(
)
{
self
.
place_float
(
)
;
}
}
fn
assign_block_size_for_inorder_child_if_necessary
(
&
mut
self
layout_context
:
&
LayoutContext
parent_thread_id
:
u8
content_box
:
LogicalRect
<
Au
>
)
-
>
bool
{
if
self
.
base
.
flags
.
is_float
(
)
{
return
false
}
let
is_formatting_context
=
self
.
formatting_context_type
(
)
!
=
FormattingContextType
:
:
None
;
if
!
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
&
&
is_formatting_context
{
self
.
assign_inline_position_for_formatting_context
(
layout_context
content_box
)
;
}
if
(
self
as
&
Flow
)
.
floats_might_flow_through
(
)
{
self
.
base
.
thread_id
=
parent_thread_id
;
if
self
.
base
.
restyle_damage
.
intersects
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
{
self
.
assign_block_size
(
layout_context
)
;
}
return
true
}
if
is_formatting_context
{
let
writing_mode
=
self
.
base
.
floats
.
writing_mode
;
let
delta
=
self
.
base
.
position
.
size
.
block
;
self
.
base
.
floats
.
translate
(
LogicalSize
:
:
new
(
writing_mode
Au
(
0
)
-
delta
)
)
;
return
true
}
false
}
fn
assign_block_size
(
&
mut
self
ctx
:
&
LayoutContext
)
{
let
remaining
=
Flow
:
:
fragment
(
self
ctx
None
)
;
debug_assert
!
(
remaining
.
is_none
(
)
)
;
}
fn
fragment
(
&
mut
self
layout_context
:
&
LayoutContext
fragmentation_context
:
Option
<
FragmentationContext
>
)
-
>
Option
<
Arc
<
Flow
>
>
{
if
self
.
fragment
.
is_replaced
(
)
{
let
_scope
=
layout_debug_scope
!
(
"
assign_replaced_block_size_if_necessary
{
:
x
}
"
self
.
base
.
debug_id
(
)
)
;
self
.
fragment
.
assign_replaced_block_size_if_necessary
(
)
;
if
!
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
self
.
base
.
position
.
size
.
block
=
self
.
fragment
.
border_box
.
size
.
block
;
let
mut
block_start
=
AdjoiningMargins
:
:
from_margin
(
self
.
fragment
.
margin
.
block_start
)
;
let
block_end
=
AdjoiningMargins
:
:
from_margin
(
self
.
fragment
.
margin
.
block_end
)
;
if
self
.
fragment
.
border_box
.
size
.
block
=
=
Au
(
0
)
{
block_start
.
union
(
block_end
)
;
self
.
base
.
collapsible_margins
=
CollapsibleMargins
:
:
CollapseThrough
(
block_start
)
;
}
else
{
self
.
base
.
collapsible_margins
=
CollapsibleMargins
:
:
Collapse
(
block_start
block_end
)
;
}
self
.
base
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
;
self
.
fragment
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
;
}
None
}
else
if
self
.
is_root
(
)
|
|
self
.
formatting_context_type
(
)
!
=
FormattingContextType
:
:
None
|
|
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
MARGINS_CANNOT_COLLAPSE
)
{
debug
!
(
"
assign_block_size
:
assigning
block_size
for
root
flow
{
:
?
}
"
self
.
base
(
)
.
debug_id
(
)
)
;
self
.
assign_block_size_block_base
(
layout_context
fragmentation_context
MarginsMayCollapseFlag
:
:
MarginsMayNotCollapse
)
}
else
{
debug
!
(
"
assign_block_size
:
assigning
block_size
for
block
{
:
?
}
"
self
.
base
(
)
.
debug_id
(
)
)
;
self
.
assign_block_size_block_base
(
layout_context
fragmentation_context
MarginsMayCollapseFlag
:
:
MarginsMayCollapse
)
}
}
fn
compute_stacking_relative_position
(
&
mut
self
_layout_context
:
&
LayoutContext
)
{
let
container_size
=
Size2D
:
:
new
(
self
.
base
.
block_container_inline_size
Au
(
0
)
)
;
if
self
.
is_root
(
)
{
self
.
base
.
clip
=
Rect
:
:
max_rect
(
)
;
}
if
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
let
position_start
=
self
.
base
.
position
.
start
.
to_physical
(
self
.
base
.
writing_mode
container_size
)
;
let
absolute_stacking_relative_position
=
if
self
.
is_fixed
(
)
{
position_start
}
else
{
self
.
base
.
late_absolute_position_info
.
stacking_relative_position_of_absolute_containing_block
+
position_start
.
to_vector
(
)
}
;
if
!
self
.
base
.
writing_mode
.
is_vertical
(
)
{
if
!
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
INLINE_POSITION_IS_STATIC
)
{
self
.
base
.
stacking_relative_position
.
x
=
absolute_stacking_relative_position
.
x
}
if
!
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
BLOCK_POSITION_IS_STATIC
)
{
self
.
base
.
stacking_relative_position
.
y
=
absolute_stacking_relative_position
.
y
}
}
else
{
if
!
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
INLINE_POSITION_IS_STATIC
)
{
self
.
base
.
stacking_relative_position
.
y
=
absolute_stacking_relative_position
.
y
}
if
!
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
BLOCK_POSITION_IS_STATIC
)
{
self
.
base
.
stacking_relative_position
.
x
=
absolute_stacking_relative_position
.
x
}
}
}
let
relative_offset
=
self
.
fragment
.
relative_position
(
&
self
.
base
.
early_absolute_position_info
.
relative_containing_block_size
)
;
if
self
.
is_absolute_containing_block
(
)
{
let
border_box_origin
=
(
self
.
fragment
.
border_box
-
self
.
fragment
.
style
.
logical_border_width
(
)
)
.
start
;
self
.
base
.
late_absolute_position_info
.
stacking_relative_position_of_absolute_containing_block
=
self
.
base
.
stacking_relative_position
.
to_point
(
)
+
(
border_box_origin
+
relative_offset
)
.
to_physical
(
self
.
base
.
writing_mode
container_size
)
.
to_vector
(
)
}
let
stacking_relative_position_of_absolute_containing_block_for_children
=
if
self
.
fragment
.
establishes_stacking_context
(
)
{
let
logical_border_width
=
self
.
fragment
.
style
(
)
.
logical_border_width
(
)
;
let
position
=
LogicalPoint
:
:
new
(
self
.
base
.
writing_mode
logical_border_width
.
inline_start
logical_border_width
.
block_start
)
;
let
position
=
position
.
to_physical
(
self
.
base
.
writing_mode
container_size
)
;
if
self
.
is_absolute_containing_block
(
)
{
position
}
else
{
position
-
self
.
base
.
stacking_relative_position
}
}
else
{
self
.
base
.
late_absolute_position_info
.
stacking_relative_position_of_absolute_containing_block
}
;
let
late_absolute_position_info_for_children
=
LateAbsolutePositionInfo
{
stacking_relative_position_of_absolute_containing_block
:
stacking_relative_position_of_absolute_containing_block_for_children
}
;
let
container_size_for_children
=
self
.
base
.
position
.
size
.
to_physical
(
self
.
base
.
writing_mode
)
;
let
relative_offset
=
relative_offset
.
to_physical
(
self
.
base
.
writing_mode
)
.
to_vector
(
)
;
let
is_stacking_context
=
self
.
fragment
.
establishes_stacking_context
(
)
;
let
origin_for_children
=
if
is_stacking_context
{
let
margin
=
self
.
fragment
.
margin
.
to_physical
(
self
.
base
.
writing_mode
)
;
Point2D
:
:
new
(
-
margin
.
left
Au
(
0
)
)
}
else
{
self
.
base
.
stacking_relative_position
.
to_point
(
)
+
relative_offset
}
;
for
kid
in
self
.
base
.
child_iter_mut
(
)
{
if
kid
.
base
(
)
.
flags
.
contains
(
FlowFlags
:
:
INLINE_POSITION_IS_STATIC
)
|
|
kid
.
base
(
)
.
flags
.
contains
(
FlowFlags
:
:
BLOCK_POSITION_IS_STATIC
)
{
let
kid_base
=
kid
.
mut_base
(
)
;
let
physical_position
=
kid_base
.
position
.
to_physical
(
kid_base
.
writing_mode
container_size_for_children
)
;
if
!
kid_base
.
writing_mode
.
is_vertical
(
)
{
if
kid_base
.
flags
.
contains
(
FlowFlags
:
:
INLINE_POSITION_IS_STATIC
)
{
kid_base
.
stacking_relative_position
.
x
=
origin_for_children
.
x
+
physical_position
.
origin
.
x
}
if
kid_base
.
flags
.
contains
(
FlowFlags
:
:
BLOCK_POSITION_IS_STATIC
)
{
kid_base
.
stacking_relative_position
.
y
=
origin_for_children
.
y
+
physical_position
.
origin
.
y
}
}
else
{
if
kid_base
.
flags
.
contains
(
FlowFlags
:
:
INLINE_POSITION_IS_STATIC
)
{
kid_base
.
stacking_relative_position
.
y
=
origin_for_children
.
y
+
physical_position
.
origin
.
y
}
if
kid_base
.
flags
.
contains
(
FlowFlags
:
:
BLOCK_POSITION_IS_STATIC
)
{
kid_base
.
stacking_relative_position
.
x
=
origin_for_children
.
x
+
physical_position
.
origin
.
x
}
}
}
kid
.
mut_base
(
)
.
late_absolute_position_info
=
late_absolute_position_info_for_children
;
}
}
fn
mark_as_root
(
&
mut
self
)
{
self
.
flags
.
insert
(
BlockFlowFlags
:
:
IS_ROOT
)
}
fn
is_root
(
&
self
)
-
>
bool
{
self
.
flags
.
contains
(
BlockFlowFlags
:
:
IS_ROOT
)
}
fn
positioning
(
&
self
)
-
>
Position
{
self
.
fragment
.
style
.
get_box
(
)
.
position
}
fn
generated_containing_block_size
(
&
self
_
:
OpaqueFlow
)
-
>
LogicalSize
<
Au
>
{
(
self
.
fragment
.
border_box
-
self
.
fragment
.
style
(
)
.
logical_border_width
(
)
)
.
size
}
fn
contains_roots_of_absolute_flow_tree
(
&
self
)
-
>
bool
{
self
.
contains_relatively_positioned_fragments
(
)
|
|
self
.
is_root
(
)
|
|
self
.
fragment
.
has_filter_transform_or_perspective
(
)
}
fn
is_absolute_containing_block
(
&
self
)
-
>
bool
{
self
.
contains_positioned_fragments
(
)
|
|
self
.
fragment
.
has_filter_transform_or_perspective
(
)
}
fn
update_late_computed_inline_position_if_necessary
(
&
mut
self
inline_position
:
Au
)
{
if
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
&
&
self
.
fragment
.
style
(
)
.
logical_position
(
)
.
inline_start
=
=
LengthOrPercentageOrAuto
:
:
Auto
&
&
self
.
fragment
.
style
(
)
.
logical_position
(
)
.
inline_end
=
=
LengthOrPercentageOrAuto
:
:
Auto
{
self
.
base
.
position
.
start
.
i
=
inline_position
}
}
fn
update_late_computed_block_position_if_necessary
(
&
mut
self
block_position
:
Au
)
{
if
self
.
base
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
&
&
self
.
fragment
.
style
(
)
.
logical_position
(
)
.
block_start
=
=
LengthOrPercentageOrAuto
:
:
Auto
&
&
self
.
fragment
.
style
(
)
.
logical_position
(
)
.
block_end
=
=
LengthOrPercentageOrAuto
:
:
Auto
{
self
.
base
.
position
.
start
.
b
=
block_position
}
}
fn
collect_stacking_contexts
(
&
mut
self
state
:
&
mut
StackingContextCollectionState
)
{
self
.
collect_stacking_contexts_for_block
(
state
StackingContextCollectionFlags
:
:
empty
(
)
)
;
}
fn
build_display_list
(
&
mut
self
state
:
&
mut
DisplayListBuildState
)
{
self
.
build_display_list_for_block
(
state
BorderPaintingMode
:
:
Separate
)
;
}
fn
repair_style
(
&
mut
self
new_style
:
&
:
:
ServoArc
<
ComputedValues
>
)
{
self
.
fragment
.
repair_style
(
new_style
)
}
fn
compute_overflow
(
&
self
)
-
>
Overflow
{
let
flow_size
=
self
.
base
.
position
.
size
.
to_physical
(
self
.
base
.
writing_mode
)
;
let
overflow
=
self
.
fragment
.
compute_overflow
(
&
flow_size
&
self
.
base
.
early_absolute_position_info
.
relative_containing_block_size
)
;
overflow
}
fn
iterate_through_fragment_border_boxes
(
&
self
iterator
:
&
mut
FragmentBorderBoxIterator
level
:
i32
stacking_context_position
:
&
Point2D
<
Au
>
)
{
if
!
iterator
.
should_process
(
&
self
.
fragment
)
{
return
}
iterator
.
process
(
&
self
.
fragment
level
&
self
.
fragment
.
stacking_relative_border_box
(
&
self
.
base
.
stacking_relative_position
&
self
.
base
.
early_absolute_position_info
.
relative_containing_block_size
self
.
base
.
early_absolute_position_info
.
relative_containing_block_mode
CoordinateSystem
:
:
Own
)
.
translate
(
&
stacking_context_position
.
to_vector
(
)
)
)
;
}
fn
mutate_fragments
(
&
mut
self
mutator
:
&
mut
FnMut
(
&
mut
Fragment
)
)
{
(
*
mutator
)
(
&
mut
self
.
fragment
)
}
fn
print_extra_flow_children
(
&
self
print_tree
:
&
mut
PrintTree
)
{
print_tree
.
add_item
(
format
!
(
"
Fragment
for
block
:
{
:
?
}
"
self
.
fragment
)
)
;
}
}
impl
fmt
:
:
Debug
for
BlockFlow
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
(
{
:
x
}
)
{
:
?
}
"
self
.
class
(
)
self
.
base
.
debug_id
(
)
self
.
base
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
ISizeConstraintInput
{
pub
computed_inline_size
:
MaybeAuto
pub
inline_start_margin
:
MaybeAuto
pub
inline_end_margin
:
MaybeAuto
pub
inline_start
:
MaybeAuto
pub
inline_end
:
MaybeAuto
pub
text_align
:
TextAlign
pub
available_inline_size
:
Au
}
impl
ISizeConstraintInput
{
pub
fn
new
(
computed_inline_size
:
MaybeAuto
inline_start_margin
:
MaybeAuto
inline_end_margin
:
MaybeAuto
inline_start
:
MaybeAuto
inline_end
:
MaybeAuto
text_align
:
TextAlign
available_inline_size
:
Au
)
-
>
ISizeConstraintInput
{
ISizeConstraintInput
{
computed_inline_size
:
computed_inline_size
inline_start_margin
:
inline_start_margin
inline_end_margin
:
inline_end_margin
inline_start
:
inline_start
inline_end
:
inline_end
text_align
:
text_align
available_inline_size
:
available_inline_size
}
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
ISizeConstraintSolution
{
pub
inline_start
:
Au
pub
inline_size
:
Au
pub
margin_inline_start
:
Au
pub
margin_inline_end
:
Au
}
impl
ISizeConstraintSolution
{
pub
fn
new
(
inline_size
:
Au
margin_inline_start
:
Au
margin_inline_end
:
Au
)
-
>
ISizeConstraintSolution
{
ISizeConstraintSolution
{
inline_start
:
Au
(
0
)
inline_size
:
inline_size
margin_inline_start
:
margin_inline_start
margin_inline_end
:
margin_inline_end
}
}
fn
for_absolute_flow
(
inline_start
:
Au
inline_size
:
Au
margin_inline_start
:
Au
margin_inline_end
:
Au
)
-
>
ISizeConstraintSolution
{
ISizeConstraintSolution
{
inline_start
:
inline_start
inline_size
:
inline_size
margin_inline_start
:
margin_inline_start
margin_inline_end
:
margin_inline_end
}
}
}
pub
trait
ISizeAndMarginsComputer
{
fn
compute_border_and_padding
(
&
self
block
:
&
mut
BlockFlow
containing_block_inline_size
:
Au
)
{
block
.
fragment
.
compute_border_and_padding
(
containing_block_inline_size
)
;
}
fn
compute_inline_size_constraint_inputs
(
&
self
block
:
&
mut
BlockFlow
parent_flow_inline_size
:
Au
shared_context
:
&
SharedStyleContext
)
-
>
ISizeConstraintInput
{
let
containing_block_inline_size
=
self
.
containing_block_inline_size
(
block
parent_flow_inline_size
shared_context
)
;
block
.
fragment
.
compute_block_direction_margins
(
containing_block_inline_size
)
;
block
.
fragment
.
compute_inline_direction_margins
(
containing_block_inline_size
)
;
self
.
compute_border_and_padding
(
block
containing_block_inline_size
)
;
let
mut
computed_inline_size
=
self
.
initial_computed_inline_size
(
block
parent_flow_inline_size
shared_context
)
;
let
style
=
block
.
fragment
.
style
(
)
;
match
(
computed_inline_size
style
.
get_position
(
)
.
box_sizing
)
{
(
MaybeAuto
:
:
Specified
(
size
)
BoxSizing
:
:
BorderBox
)
=
>
{
computed_inline_size
=
MaybeAuto
:
:
Specified
(
size
-
block
.
fragment
.
border_padding
.
inline_start_end
(
)
)
}
(
MaybeAuto
:
:
Auto
BoxSizing
:
:
BorderBox
)
|
(
_
BoxSizing
:
:
ContentBox
)
=
>
{
}
}
let
margin
=
style
.
logical_margin
(
)
;
let
position
=
style
.
logical_position
(
)
;
let
available_inline_size
=
containing_block_inline_size
-
block
.
fragment
.
border_padding
.
inline_start_end
(
)
;
ISizeConstraintInput
:
:
new
(
computed_inline_size
MaybeAuto
:
:
from_style
(
margin
.
inline_start
containing_block_inline_size
)
MaybeAuto
:
:
from_style
(
margin
.
inline_end
containing_block_inline_size
)
MaybeAuto
:
:
from_style
(
position
.
inline_start
containing_block_inline_size
)
MaybeAuto
:
:
from_style
(
position
.
inline_end
containing_block_inline_size
)
style
.
get_inheritedtext
(
)
.
text_align
available_inline_size
)
}
fn
set_inline_size_constraint_solutions
(
&
self
block
:
&
mut
BlockFlow
solution
:
ISizeConstraintSolution
)
{
let
inline_size
;
let
extra_inline_size_from_margin
;
{
let
block_mode
=
block
.
base
.
writing_mode
;
let
container_mode
=
block
.
base
.
block_container_writing_mode
;
let
container_size
=
block
.
base
.
block_container_inline_size
;
let
fragment
=
block
.
fragment
(
)
;
fragment
.
margin
.
inline_start
=
solution
.
margin_inline_start
;
fragment
.
margin
.
inline_end
=
solution
.
margin_inline_end
;
inline_size
=
solution
.
inline_size
+
fragment
.
border_padding
.
inline_start_end
(
)
;
fragment
.
border_box
.
size
.
inline
=
inline_size
;
fragment
.
border_box
.
start
.
i
=
if
container_mode
.
is_bidi_ltr
(
)
=
=
block_mode
.
is_bidi_ltr
(
)
{
fragment
.
margin
.
inline_start
}
else
{
container_size
-
inline_size
-
fragment
.
margin
.
inline_end
}
;
extra_inline_size_from_margin
=
max
(
Au
(
0
)
fragment
.
margin
.
inline_start
)
+
max
(
Au
(
0
)
fragment
.
margin
.
inline_end
)
;
}
block
.
mut_base
(
)
.
position
.
size
.
inline
=
inline_size
+
extra_inline_size_from_margin
;
}
fn
set_inline_position_of_flow_if_necessary
(
&
self
_
:
&
mut
BlockFlow
_
:
ISizeConstraintSolution
)
{
}
fn
solve_inline_size_constraints
(
&
self
block
:
&
mut
BlockFlow
input
:
&
ISizeConstraintInput
)
-
>
ISizeConstraintSolution
;
fn
initial_computed_inline_size
(
&
self
block
:
&
mut
BlockFlow
parent_flow_inline_size
:
Au
shared_context
:
&
SharedStyleContext
)
-
>
MaybeAuto
{
MaybeAuto
:
:
from_style
(
block
.
fragment
(
)
.
style
(
)
.
content_inline_size
(
)
self
.
containing_block_inline_size
(
block
parent_flow_inline_size
shared_context
)
)
}
fn
containing_block_inline_size
(
&
self
_
:
&
mut
BlockFlow
parent_flow_inline_size
:
Au
_
:
&
SharedStyleContext
)
-
>
Au
{
parent_flow_inline_size
}
fn
compute_used_inline_size
(
&
self
block
:
&
mut
BlockFlow
shared_context
:
&
SharedStyleContext
parent_flow_inline_size
:
Au
)
{
let
mut
input
=
self
.
compute_inline_size_constraint_inputs
(
block
parent_flow_inline_size
shared_context
)
;
let
containing_block_inline_size
=
self
.
containing_block_inline_size
(
block
parent_flow_inline_size
shared_context
)
;
let
mut
solution
=
self
.
solve_inline_size_constraints
(
block
&
input
)
;
match
block
.
fragment
(
)
.
style
(
)
.
max_inline_size
(
)
.
to_used_value
(
containing_block_inline_size
)
{
Some
(
max_inline_size
)
if
max_inline_size
<
solution
.
inline_size
=
>
{
input
.
computed_inline_size
=
MaybeAuto
:
:
Specified
(
max_inline_size
)
;
solution
=
self
.
solve_inline_size_constraints
(
block
&
input
)
;
}
_
=
>
{
}
}
let
computed_min_inline_size
=
block
.
fragment
(
)
.
style
(
)
.
min_inline_size
(
)
.
to_used_value
(
containing_block_inline_size
)
;
if
computed_min_inline_size
>
solution
.
inline_size
{
input
.
computed_inline_size
=
MaybeAuto
:
:
Specified
(
computed_min_inline_size
)
;
solution
=
self
.
solve_inline_size_constraints
(
block
&
input
)
;
}
self
.
set_inline_size_constraint_solutions
(
block
solution
)
;
self
.
set_inline_position_of_flow_if_necessary
(
block
solution
)
;
}
fn
solve_block_inline_size_constraints
(
&
self
block
:
&
mut
BlockFlow
input
:
&
ISizeConstraintInput
)
-
>
ISizeConstraintSolution
{
let
(
computed_inline_size
inline_start_margin
inline_end_margin
available_inline_size
)
=
(
input
.
computed_inline_size
input
.
inline_start_margin
input
.
inline_end_margin
input
.
available_inline_size
)
;
let
block_mode
=
block
.
base
.
writing_mode
;
let
container_mode
=
block
.
base
.
block_container_writing_mode
;
let
block_align
=
block
.
base
.
flags
.
text_align
(
)
;
let
parent_has_same_direction
=
container_mode
.
is_bidi_ltr
(
)
=
=
block_mode
.
is_bidi_ltr
(
)
;
let
(
inline_start_margin
inline_end_margin
)
=
match
computed_inline_size
{
MaybeAuto
:
:
Auto
=
>
(
inline_start_margin
inline_end_margin
)
MaybeAuto
:
:
Specified
(
inline_size
)
=
>
{
let
inline_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
inline_end
=
inline_end_margin
.
specified_or_zero
(
)
;
if
(
inline_start
+
inline_end
+
inline_size
)
>
available_inline_size
{
(
MaybeAuto
:
:
Specified
(
inline_start
)
MaybeAuto
:
:
Specified
(
inline_end
)
)
}
else
{
(
inline_start_margin
inline_end_margin
)
}
}
}
;
let
(
inline_start_margin
inline_size
inline_end_margin
)
=
match
(
inline_start_margin
computed_inline_size
inline_end_margin
)
{
(
MaybeAuto
:
:
Specified
(
margin_start
)
MaybeAuto
:
:
Specified
(
inline_size
)
MaybeAuto
:
:
Specified
(
margin_end
)
)
=
>
{
if
block_align
=
=
TextAlign
:
:
ServoCenter
{
let
margin
=
(
available_inline_size
-
inline_size
)
.
scale_by
(
0
.
5
)
;
(
margin
inline_size
margin
)
}
else
{
let
ignore_end_margin
=
match
block_align
{
TextAlign
:
:
ServoLeft
=
>
block_mode
.
is_bidi_ltr
(
)
TextAlign
:
:
ServoRight
=
>
!
block_mode
.
is_bidi_ltr
(
)
_
=
>
parent_has_same_direction
}
;
if
ignore_end_margin
{
(
margin_start
inline_size
available_inline_size
-
(
margin_start
+
inline_size
)
)
}
else
{
(
available_inline_size
-
(
margin_end
+
inline_size
)
inline_size
margin_end
)
}
}
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
inline_size
)
MaybeAuto
:
:
Specified
(
margin_end
)
)
=
>
(
available_inline_size
-
(
inline_size
+
margin_end
)
inline_size
margin_end
)
(
MaybeAuto
:
:
Specified
(
margin_start
)
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
margin_end
)
)
=
>
{
(
margin_start
available_inline_size
-
(
margin_start
+
margin_end
)
margin_end
)
}
(
MaybeAuto
:
:
Specified
(
margin_start
)
MaybeAuto
:
:
Specified
(
inline_size
)
MaybeAuto
:
:
Auto
)
=
>
{
(
margin_start
inline_size
available_inline_size
-
(
margin_start
+
inline_size
)
)
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
margin_end
)
)
=
>
{
(
Au
(
0
)
available_inline_size
-
margin_end
margin_end
)
}
(
MaybeAuto
:
:
Specified
(
margin_start
)
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
)
=
>
{
(
margin_start
available_inline_size
-
margin_start
Au
(
0
)
)
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
)
=
>
{
(
Au
(
0
)
available_inline_size
Au
(
0
)
)
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
inline_size
)
MaybeAuto
:
:
Auto
)
=
>
{
let
margin
=
(
available_inline_size
-
inline_size
)
.
scale_by
(
0
.
5
)
;
(
margin
inline_size
margin
)
}
}
;
ISizeConstraintSolution
:
:
new
(
inline_size
inline_start_margin
inline_end_margin
)
}
}
pub
struct
AbsoluteNonReplaced
;
pub
struct
AbsoluteReplaced
;
pub
struct
BlockNonReplaced
;
pub
struct
BlockReplaced
;
pub
struct
FloatNonReplaced
;
pub
struct
FloatReplaced
;
pub
struct
InlineBlockNonReplaced
;
pub
struct
InlineBlockReplaced
;
pub
struct
InlineFlexItem
;
impl
ISizeAndMarginsComputer
for
AbsoluteNonReplaced
{
fn
solve_inline_size_constraints
(
&
self
block
:
&
mut
BlockFlow
input
:
&
ISizeConstraintInput
)
-
>
ISizeConstraintSolution
{
let
&
ISizeConstraintInput
{
computed_inline_size
inline_start_margin
inline_end_margin
inline_start
inline_end
available_inline_size
.
.
}
=
input
;
let
block_mode
=
block
.
base
.
writing_mode
;
let
container_mode
=
block
.
base
.
block_container_writing_mode
;
let
parent_has_same_direction
=
container_mode
.
is_bidi_ltr
(
)
=
=
block_mode
.
is_bidi_ltr
(
)
;
let
(
inline_start
inline_size
margin_inline_start
margin_inline_end
)
=
match
(
inline_start
inline_end
computed_inline_size
)
{
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
)
=
>
{
let
margin_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
margin_end
=
inline_end_margin
.
specified_or_zero
(
)
;
let
inline_size
=
block
.
get_shrink_to_fit_inline_size
(
available_inline_size
-
(
margin_start
+
margin_end
)
)
;
(
Au
(
0
)
inline_size
margin_start
margin_end
)
}
(
MaybeAuto
:
:
Specified
(
inline_start
)
MaybeAuto
:
:
Specified
(
inline_end
)
MaybeAuto
:
:
Specified
(
inline_size
)
)
=
>
{
match
(
inline_start_margin
inline_end_margin
)
{
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
)
=
>
{
let
total_margin_val
=
available_inline_size
-
inline_start
-
inline_end
-
inline_size
;
if
total_margin_val
<
Au
(
0
)
{
if
parent_has_same_direction
{
(
inline_start
inline_size
Au
(
0
)
total_margin_val
)
}
else
{
(
inline_start
inline_size
total_margin_val
Au
(
0
)
)
}
}
else
{
(
inline_start
inline_size
total_margin_val
.
scale_by
(
0
.
5
)
total_margin_val
.
scale_by
(
0
.
5
)
)
}
}
(
MaybeAuto
:
:
Specified
(
margin_start
)
MaybeAuto
:
:
Auto
)
=
>
{
let
sum
=
inline_start
+
inline_end
+
inline_size
+
margin_start
;
(
inline_start
inline_size
margin_start
available_inline_size
-
sum
)
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
margin_end
)
)
=
>
{
let
sum
=
inline_start
+
inline_end
+
inline_size
+
margin_end
;
(
inline_start
inline_size
available_inline_size
-
sum
margin_end
)
}
(
MaybeAuto
:
:
Specified
(
margin_start
)
MaybeAuto
:
:
Specified
(
margin_end
)
)
=
>
{
let
sum
=
inline_start
+
inline_size
+
margin_start
+
margin_end
;
if
parent_has_same_direction
{
(
inline_start
inline_size
margin_start
margin_end
)
}
else
{
(
available_inline_size
-
sum
inline_size
margin_start
margin_end
)
}
}
}
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
inline_end
)
MaybeAuto
:
:
Specified
(
inline_size
)
)
=
>
{
let
margin_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
margin_end
=
inline_end_margin
.
specified_or_zero
(
)
;
let
sum
=
inline_end
+
inline_size
+
margin_start
+
margin_end
;
(
available_inline_size
-
sum
inline_size
margin_start
margin_end
)
}
(
MaybeAuto
:
:
Specified
(
inline_start
)
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
inline_size
)
)
=
>
{
let
margin_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
margin_end
=
inline_end_margin
.
specified_or_zero
(
)
;
(
inline_start
inline_size
margin_start
margin_end
)
}
(
MaybeAuto
:
:
Specified
(
inline_start
)
MaybeAuto
:
:
Specified
(
inline_end
)
MaybeAuto
:
:
Auto
)
=
>
{
let
margin_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
margin_end
=
inline_end_margin
.
specified_or_zero
(
)
;
let
sum
=
inline_start
+
inline_end
+
margin_start
+
margin_end
;
(
inline_start
available_inline_size
-
sum
margin_start
margin_end
)
}
(
MaybeAuto
:
:
Specified
(
inline_start
)
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
)
=
>
{
let
margin_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
margin_end
=
inline_end_margin
.
specified_or_zero
(
)
;
let
inline_size
=
block
.
get_shrink_to_fit_inline_size
(
available_inline_size
-
(
margin_start
+
margin_end
)
)
;
(
inline_start
inline_size
margin_start
margin_end
)
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
inline_end
)
MaybeAuto
:
:
Auto
)
=
>
{
let
margin_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
margin_end
=
inline_end_margin
.
specified_or_zero
(
)
;
let
inline_size
=
block
.
get_shrink_to_fit_inline_size
(
available_inline_size
-
(
margin_start
+
margin_end
)
)
;
let
sum
=
inline_end
+
inline_size
+
margin_start
+
margin_end
;
(
available_inline_size
-
sum
inline_size
margin_start
margin_end
)
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
inline_size
)
)
=
>
{
let
margin_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
margin_end
=
inline_end_margin
.
specified_or_zero
(
)
;
(
Au
(
0
)
inline_size
margin_start
margin_end
)
}
}
;
ISizeConstraintSolution
:
:
for_absolute_flow
(
inline_start
inline_size
margin_inline_start
margin_inline_end
)
}
fn
containing_block_inline_size
(
&
self
block
:
&
mut
BlockFlow
_
:
Au
shared_context
:
&
SharedStyleContext
)
-
>
Au
{
let
opaque_block
=
OpaqueFlow
:
:
from_flow
(
block
)
;
block
.
containing_block_size
(
&
shared_context
.
viewport_size
(
)
opaque_block
)
.
inline
}
fn
set_inline_position_of_flow_if_necessary
(
&
self
block
:
&
mut
BlockFlow
solution
:
ISizeConstraintSolution
)
{
if
!
block
.
base
.
flags
.
contains
(
FlowFlags
:
:
INLINE_POSITION_IS_STATIC
)
{
block
.
base
.
position
.
start
.
i
=
solution
.
inline_start
;
}
}
}
impl
ISizeAndMarginsComputer
for
AbsoluteReplaced
{
fn
solve_inline_size_constraints
(
&
self
_
:
&
mut
BlockFlow
input
:
&
ISizeConstraintInput
)
-
>
ISizeConstraintSolution
{
let
&
ISizeConstraintInput
{
computed_inline_size
inline_start_margin
inline_end_margin
inline_start
inline_end
available_inline_size
.
.
}
=
input
;
let
inline_size
=
match
computed_inline_size
{
MaybeAuto
:
:
Specified
(
w
)
=
>
w
_
=
>
panic
!
(
"
{
}
{
}
"
"
The
used
value
for
inline_size
for
absolute
replaced
flow
"
"
should
have
already
been
calculated
by
now
.
"
)
}
;
let
(
inline_start
inline_size
margin_inline_start
margin_inline_end
)
=
match
(
inline_start
inline_end
)
{
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
)
=
>
{
let
margin_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
margin_end
=
inline_end_margin
.
specified_or_zero
(
)
;
(
Au
(
0
)
inline_size
margin_start
margin_end
)
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
inline_end
)
)
=
>
{
let
margin_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
margin_end
=
inline_end_margin
.
specified_or_zero
(
)
;
let
sum
=
inline_end
+
inline_size
+
margin_start
+
margin_end
;
(
available_inline_size
-
sum
inline_size
margin_start
margin_end
)
}
(
MaybeAuto
:
:
Specified
(
inline_start
)
MaybeAuto
:
:
Auto
)
=
>
{
let
margin_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
margin_end
=
inline_end_margin
.
specified_or_zero
(
)
;
(
inline_start
inline_size
margin_start
margin_end
)
}
(
MaybeAuto
:
:
Specified
(
inline_start
)
MaybeAuto
:
:
Specified
(
inline_end
)
)
=
>
{
match
(
inline_start_margin
inline_end_margin
)
{
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Auto
)
=
>
{
let
total_margin_val
=
available_inline_size
-
inline_start
-
inline_end
-
inline_size
;
if
total_margin_val
<
Au
(
0
)
{
(
inline_start
inline_size
Au
(
0
)
total_margin_val
)
}
else
{
(
inline_start
inline_size
total_margin_val
.
scale_by
(
0
.
5
)
total_margin_val
.
scale_by
(
0
.
5
)
)
}
}
(
MaybeAuto
:
:
Specified
(
margin_start
)
MaybeAuto
:
:
Auto
)
=
>
{
let
sum
=
inline_start
+
inline_end
+
inline_size
+
margin_start
;
(
inline_start
inline_size
margin_start
available_inline_size
-
sum
)
}
(
MaybeAuto
:
:
Auto
MaybeAuto
:
:
Specified
(
margin_end
)
)
=
>
{
let
sum
=
inline_start
+
inline_end
+
inline_size
+
margin_end
;
(
inline_start
inline_size
available_inline_size
-
sum
margin_end
)
}
(
MaybeAuto
:
:
Specified
(
margin_start
)
MaybeAuto
:
:
Specified
(
margin_end
)
)
=
>
{
(
inline_start
inline_size
margin_start
margin_end
)
}
}
}
}
;
ISizeConstraintSolution
:
:
for_absolute_flow
(
inline_start
inline_size
margin_inline_start
margin_inline_end
)
}
fn
initial_computed_inline_size
(
&
self
block
:
&
mut
BlockFlow
_
:
Au
shared_context
:
&
SharedStyleContext
)
-
>
MaybeAuto
{
let
opaque_block
=
OpaqueFlow
:
:
from_flow
(
block
)
;
let
containing_block_inline_size
=
block
.
containing_block_size
(
&
shared_context
.
viewport_size
(
)
opaque_block
)
.
inline
;
let
container_block_size
=
block
.
explicit_block_containing_size
(
shared_context
)
;
let
fragment
=
block
.
fragment
(
)
;
fragment
.
assign_replaced_inline_size_if_necessary
(
containing_block_inline_size
container_block_size
)
;
MaybeAuto
:
:
Specified
(
fragment
.
content_box
(
)
.
size
.
inline
)
}
fn
containing_block_inline_size
(
&
self
block
:
&
mut
BlockFlow
_
:
Au
shared_context
:
&
SharedStyleContext
)
-
>
Au
{
let
opaque_block
=
OpaqueFlow
:
:
from_flow
(
block
)
;
block
.
containing_block_size
(
&
shared_context
.
viewport_size
(
)
opaque_block
)
.
inline
}
fn
set_inline_position_of_flow_if_necessary
(
&
self
block
:
&
mut
BlockFlow
solution
:
ISizeConstraintSolution
)
{
block
.
base
.
position
.
start
.
i
=
solution
.
inline_start
;
}
}
impl
ISizeAndMarginsComputer
for
BlockNonReplaced
{
fn
solve_inline_size_constraints
(
&
self
block
:
&
mut
BlockFlow
input
:
&
ISizeConstraintInput
)
-
>
ISizeConstraintSolution
{
self
.
solve_block_inline_size_constraints
(
block
input
)
}
}
impl
ISizeAndMarginsComputer
for
BlockReplaced
{
fn
solve_inline_size_constraints
(
&
self
block
:
&
mut
BlockFlow
input
:
&
ISizeConstraintInput
)
-
>
ISizeConstraintSolution
{
match
input
.
computed_inline_size
{
MaybeAuto
:
:
Specified
(
_
)
=
>
{
}
MaybeAuto
:
:
Auto
=
>
{
panic
!
(
"
BlockReplaced
:
inline_size
should
have
been
computed
by
now
"
)
}
}
;
self
.
solve_block_inline_size_constraints
(
block
input
)
}
fn
initial_computed_inline_size
(
&
self
block
:
&
mut
BlockFlow
parent_flow_inline_size
:
Au
shared_context
:
&
SharedStyleContext
)
-
>
MaybeAuto
{
let
container_block_size
=
block
.
explicit_block_containing_size
(
shared_context
)
;
let
fragment
=
block
.
fragment
(
)
;
fragment
.
assign_replaced_inline_size_if_necessary
(
parent_flow_inline_size
container_block_size
)
;
MaybeAuto
:
:
Specified
(
fragment
.
content_box
(
)
.
size
.
inline
)
}
}
impl
ISizeAndMarginsComputer
for
FloatNonReplaced
{
fn
solve_inline_size_constraints
(
&
self
block
:
&
mut
BlockFlow
input
:
&
ISizeConstraintInput
)
-
>
ISizeConstraintSolution
{
let
(
computed_inline_size
inline_start_margin
inline_end_margin
available_inline_size
)
=
(
input
.
computed_inline_size
input
.
inline_start_margin
input
.
inline_end_margin
input
.
available_inline_size
)
;
let
margin_inline_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
margin_inline_end
=
inline_end_margin
.
specified_or_zero
(
)
;
let
available_inline_size_float
=
available_inline_size
-
margin_inline_start
-
margin_inline_end
;
let
shrink_to_fit
=
block
.
get_shrink_to_fit_inline_size
(
available_inline_size_float
)
;
let
inline_size
=
computed_inline_size
.
specified_or_default
(
shrink_to_fit
)
;
debug
!
(
"
assign_inline_sizes_float
-
-
inline_size
:
{
:
?
}
"
inline_size
)
;
ISizeConstraintSolution
:
:
new
(
inline_size
margin_inline_start
margin_inline_end
)
}
}
impl
ISizeAndMarginsComputer
for
FloatReplaced
{
fn
solve_inline_size_constraints
(
&
self
_
:
&
mut
BlockFlow
input
:
&
ISizeConstraintInput
)
-
>
ISizeConstraintSolution
{
let
(
computed_inline_size
inline_start_margin
inline_end_margin
)
=
(
input
.
computed_inline_size
input
.
inline_start_margin
input
.
inline_end_margin
)
;
let
margin_inline_start
=
inline_start_margin
.
specified_or_zero
(
)
;
let
margin_inline_end
=
inline_end_margin
.
specified_or_zero
(
)
;
let
inline_size
=
match
computed_inline_size
{
MaybeAuto
:
:
Specified
(
w
)
=
>
w
MaybeAuto
:
:
Auto
=
>
panic
!
(
"
FloatReplaced
:
inline_size
should
have
been
computed
by
now
"
)
}
;
debug
!
(
"
assign_inline_sizes_float
-
-
inline_size
:
{
:
?
}
"
inline_size
)
;
ISizeConstraintSolution
:
:
new
(
inline_size
margin_inline_start
margin_inline_end
)
}
fn
initial_computed_inline_size
(
&
self
block
:
&
mut
BlockFlow
parent_flow_inline_size
:
Au
shared_context
:
&
SharedStyleContext
)
-
>
MaybeAuto
{
let
container_block_size
=
block
.
explicit_block_containing_size
(
shared_context
)
;
let
fragment
=
block
.
fragment
(
)
;
fragment
.
assign_replaced_inline_size_if_necessary
(
parent_flow_inline_size
container_block_size
)
;
MaybeAuto
:
:
Specified
(
fragment
.
content_box
(
)
.
size
.
inline
)
}
}
impl
ISizeAndMarginsComputer
for
InlineBlockNonReplaced
{
fn
solve_inline_size_constraints
(
&
self
block
:
&
mut
BlockFlow
input
:
&
ISizeConstraintInput
)
-
>
ISizeConstraintSolution
{
let
(
computed_inline_size
inline_start_margin
inline_end_margin
available_inline_size
)
=
(
input
.
computed_inline_size
input
.
inline_start_margin
input
.
inline_end_margin
input
.
available_inline_size
)
;
let
inline_start_margin
=
inline_start_margin
.
specified_or_zero
(
)
;
let
inline_end_margin
=
inline_end_margin
.
specified_or_zero
(
)
;
let
inline_size
=
match
computed_inline_size
{
MaybeAuto
:
:
Auto
=
>
{
block
.
get_shrink_to_fit_inline_size
(
available_inline_size
-
(
inline_start_margin
+
inline_end_margin
)
)
}
MaybeAuto
:
:
Specified
(
inline_size
)
=
>
inline_size
}
;
ISizeConstraintSolution
:
:
new
(
inline_size
inline_start_margin
inline_end_margin
)
}
}
impl
ISizeAndMarginsComputer
for
InlineBlockReplaced
{
fn
solve_inline_size_constraints
(
&
self
block
:
&
mut
BlockFlow
input
:
&
ISizeConstraintInput
)
-
>
ISizeConstraintSolution
{
debug_assert
!
(
match
input
.
computed_inline_size
{
MaybeAuto
:
:
Specified
(
_
)
=
>
true
MaybeAuto
:
:
Auto
=
>
false
}
)
;
let
(
computed_inline_size
inline_start_margin
inline_end_margin
available_inline_size
)
=
(
input
.
computed_inline_size
input
.
inline_start_margin
input
.
inline_end_margin
input
.
available_inline_size
)
;
let
inline_start_margin
=
inline_start_margin
.
specified_or_zero
(
)
;
let
inline_end_margin
=
inline_end_margin
.
specified_or_zero
(
)
;
let
inline_size
=
match
computed_inline_size
{
MaybeAuto
:
:
Auto
=
>
{
block
.
get_shrink_to_fit_inline_size
(
available_inline_size
-
(
inline_start_margin
+
inline_end_margin
)
)
}
MaybeAuto
:
:
Specified
(
inline_size
)
=
>
inline_size
}
;
ISizeConstraintSolution
:
:
new
(
inline_size
inline_start_margin
inline_end_margin
)
}
fn
initial_computed_inline_size
(
&
self
block
:
&
mut
BlockFlow
parent_flow_inline_size
:
Au
shared_context
:
&
SharedStyleContext
)
-
>
MaybeAuto
{
let
container_block_size
=
block
.
explicit_block_containing_size
(
shared_context
)
;
let
fragment
=
block
.
fragment
(
)
;
fragment
.
assign_replaced_inline_size_if_necessary
(
parent_flow_inline_size
container_block_size
)
;
MaybeAuto
:
:
Specified
(
fragment
.
content_box
(
)
.
size
.
inline
)
}
}
impl
ISizeAndMarginsComputer
for
InlineFlexItem
{
fn
compute_used_inline_size
(
&
self
block
:
&
mut
BlockFlow
shared_context
:
&
SharedStyleContext
parent_flow_inline_size
:
Au
)
{
let
container_block_size
=
block
.
explicit_block_containing_size
(
shared_context
)
;
block
.
fragment
.
assign_replaced_inline_size_if_necessary
(
parent_flow_inline_size
container_block_size
)
;
}
fn
solve_inline_size_constraints
(
&
self
block
:
&
mut
BlockFlow
_
:
&
ISizeConstraintInput
)
-
>
ISizeConstraintSolution
{
let
fragment
=
block
.
fragment
(
)
;
ISizeConstraintSolution
:
:
new
(
fragment
.
border_box
.
size
.
inline
fragment
.
margin
.
inline_start
fragment
.
margin
.
inline_end
)
}
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
BlockStackingContextType
{
NonstackingContext
PseudoStackingContext
StackingContext
}
