#
!
[
deny
(
unsafe_code
)
]
use
ServoArc
;
use
app_units
:
:
{
Au
MIN_AU
}
;
use
block
:
:
AbsoluteAssignBSizesTraversal
;
use
context
:
:
LayoutContext
;
use
display_list
:
:
{
DisplayListBuildState
InlineFlowDisplayListBuilding
}
;
use
display_list
:
:
StackingContextCollectionState
;
use
euclid
:
:
{
Point2D
Size2D
}
;
use
floats
:
:
{
FloatKind
Floats
PlacementInfo
}
;
use
flow
:
:
{
BaseFlow
Flow
FlowClass
ForceNonfloatedFlag
}
;
use
flow
:
:
{
FlowFlags
EarlyAbsolutePositionInfo
GetBaseFlow
OpaqueFlow
}
;
use
flow_ref
:
:
FlowRef
;
use
fragment
:
:
{
CoordinateSystem
Fragment
FragmentBorderBoxIterator
Overflow
}
;
use
fragment
:
:
FragmentFlags
;
use
fragment
:
:
SpecificFragmentInfo
;
use
gfx
:
:
display_list
:
:
OpaqueNode
;
use
gfx
:
:
font
:
:
FontMetrics
;
use
gfx
:
:
font_context
:
:
FontContext
;
use
gfx_traits
:
:
print_tree
:
:
PrintTree
;
use
layout_debug
;
use
model
:
:
IntrinsicISizesContribution
;
use
range
:
:
{
Range
RangeIndex
}
;
use
script_layout_interface
:
:
wrapper_traits
:
:
PseudoElementType
;
use
std
:
:
{
fmt
i32
isize
mem
}
;
use
std
:
:
cmp
:
:
max
;
use
std
:
:
collections
:
:
VecDeque
;
use
std
:
:
sync
:
:
Arc
;
use
style
:
:
computed_values
:
:
display
:
:
T
as
Display
;
use
style
:
:
computed_values
:
:
overflow_x
:
:
T
as
StyleOverflow
;
use
style
:
:
computed_values
:
:
position
:
:
T
as
Position
;
use
style
:
:
computed_values
:
:
text_align
:
:
T
as
TextAlign
;
use
style
:
:
computed_values
:
:
text_justify
:
:
T
as
TextJustify
;
use
style
:
:
computed_values
:
:
white_space
:
:
T
as
WhiteSpace
;
use
style
:
:
logical_geometry
:
:
{
LogicalRect
LogicalSize
WritingMode
}
;
use
style
:
:
properties
:
:
ComputedValues
;
use
style
:
:
servo
:
:
restyle_damage
:
:
ServoRestyleDamage
;
use
style
:
:
values
:
:
computed
:
:
box_
:
:
VerticalAlign
;
use
style
:
:
values
:
:
generics
:
:
box_
:
:
VerticalAlign
as
GenericVerticalAlign
;
use
style
:
:
values
:
:
specified
:
:
text
:
:
TextOverflowSide
;
use
text
;
use
traversal
:
:
PreorderFlowTraversal
;
use
unicode_bidi
as
bidi
;
#
[
derive
(
Clone
Debug
Serialize
)
]
pub
struct
Line
{
pub
range
:
Range
<
FragmentIndex
>
pub
visual_runs
:
Option
<
Vec
<
(
Range
<
FragmentIndex
>
bidi
:
:
Level
)
>
>
pub
bounds
:
LogicalRect
<
Au
>
pub
green_zone
:
LogicalSize
<
Au
>
pub
minimum_metrics
:
LineMetrics
pub
metrics
:
LineMetrics
}
impl
Line
{
fn
new
(
writing_mode
:
WritingMode
minimum_metrics
:
&
LineMetrics
)
-
>
Line
{
Line
{
range
:
Range
:
:
empty
(
)
visual_runs
:
None
bounds
:
LogicalRect
:
:
zero
(
writing_mode
)
green_zone
:
LogicalSize
:
:
zero
(
writing_mode
)
minimum_metrics
:
*
minimum_metrics
metrics
:
*
minimum_metrics
}
}
fn
new_metrics_for_fragment
(
&
self
new_fragment
:
&
Fragment
layout_context
:
&
LayoutContext
)
-
>
LineMetrics
{
if
!
new_fragment
.
is_vertically_aligned_to_top_or_bottom
(
)
{
let
fragment_inline_metrics
=
new_fragment
.
aligned_inline_metrics
(
layout_context
&
self
.
minimum_metrics
None
)
;
self
.
metrics
.
new_metrics_for_fragment
(
&
fragment_inline_metrics
)
}
else
{
self
.
metrics
}
}
fn
new_block_size_for_fragment
(
&
self
new_fragment
:
&
Fragment
new_line_metrics
:
&
LineMetrics
layout_context
:
&
LayoutContext
)
-
>
Au
{
let
new_block_size
=
if
new_fragment
.
is_vertically_aligned_to_top_or_bottom
(
)
{
max
(
new_fragment
.
aligned_inline_metrics
(
layout_context
&
self
.
minimum_metrics
None
)
.
space_needed
(
)
self
.
minimum_metrics
.
space_needed
(
)
)
}
else
{
new_line_metrics
.
space_needed
(
)
}
;
max
(
self
.
bounds
.
size
.
block
new_block_size
)
}
}
int_range_index
!
{
#
[
derive
(
Serialize
)
]
#
[
doc
=
"
The
index
of
a
fragment
in
a
flattened
vector
of
DOM
elements
.
"
]
struct
FragmentIndex
(
isize
)
}
struct
LineBreaker
{
floats
:
Floats
new_fragments
:
Vec
<
Fragment
>
work_list
:
VecDeque
<
Fragment
>
pending_line
:
Line
lines
:
Vec
<
Line
>
last_known_line_breaking_opportunity
:
Option
<
FragmentIndex
>
cur_b
:
Au
first_line_indentation
:
Au
minimum_metrics
:
LineMetrics
}
impl
LineBreaker
{
fn
new
(
float_context
:
Floats
first_line_indentation
:
Au
minimum_line_metrics
:
&
LineMetrics
)
-
>
LineBreaker
{
LineBreaker
{
new_fragments
:
Vec
:
:
new
(
)
work_list
:
VecDeque
:
:
new
(
)
pending_line
:
Line
:
:
new
(
float_context
.
writing_mode
minimum_line_metrics
)
floats
:
float_context
lines
:
Vec
:
:
new
(
)
cur_b
:
Au
(
0
)
last_known_line_breaking_opportunity
:
None
first_line_indentation
:
first_line_indentation
minimum_metrics
:
*
minimum_line_metrics
}
}
fn
reset_scanner
(
&
mut
self
)
{
self
.
lines
=
Vec
:
:
new
(
)
;
self
.
new_fragments
=
Vec
:
:
new
(
)
;
self
.
cur_b
=
Au
(
0
)
;
self
.
reset_line
(
)
;
}
fn
reset_line
(
&
mut
self
)
-
>
Line
{
self
.
last_known_line_breaking_opportunity
=
None
;
mem
:
:
replace
(
&
mut
self
.
pending_line
Line
:
:
new
(
self
.
floats
.
writing_mode
&
self
.
minimum_metrics
)
)
}
fn
scan_for_lines
(
&
mut
self
flow
:
&
mut
InlineFlow
layout_context
:
&
LayoutContext
)
{
self
.
reset_scanner
(
)
;
debug
!
(
"
LineBreaker
:
scanning
for
lines
{
}
fragments
"
flow
.
fragments
.
len
(
)
)
;
let
mut
old_fragments
=
mem
:
:
replace
(
&
mut
flow
.
fragments
InlineFragments
:
:
new
(
)
)
;
let
old_fragment_iter
=
old_fragments
.
fragments
.
into_iter
(
)
;
self
.
lines
=
Vec
:
:
new
(
)
;
self
.
reflow_fragments
(
old_fragment_iter
flow
layout_context
)
;
let
para_level
=
flow
.
base
.
writing_mode
.
to_bidi_level
(
)
;
let
levels
:
Vec
<
bidi
:
:
Level
>
=
self
.
new_fragments
.
iter
(
)
.
map
(
|
fragment
|
match
fragment
.
specific
{
SpecificFragmentInfo
:
:
ScannedText
(
ref
info
)
=
>
info
.
run
.
bidi_level
_
=
>
para_level
}
)
.
collect
(
)
;
let
mut
lines
=
mem
:
:
replace
(
&
mut
self
.
lines
Vec
:
:
new
(
)
)
;
if
bidi
:
:
level
:
:
has_rtl
(
&
levels
)
{
for
line
in
&
mut
lines
{
let
range
=
line
.
range
.
begin
(
)
.
to_usize
(
)
.
.
line
.
range
.
end
(
)
.
to_usize
(
)
;
#
[
allow
(
deprecated
)
]
let
runs
=
bidi
:
:
deprecated
:
:
visual_runs
(
range
&
levels
)
;
line
.
visual_runs
=
Some
(
runs
.
iter
(
)
.
map
(
|
run
|
{
let
start
=
FragmentIndex
(
run
.
start
as
isize
)
;
let
len
=
FragmentIndex
(
run
.
len
(
)
as
isize
)
;
(
Range
:
:
new
(
start
len
)
levels
[
run
.
start
]
)
}
)
.
collect
(
)
)
;
}
}
old_fragments
.
fragments
=
mem
:
:
replace
(
&
mut
self
.
new_fragments
vec
!
[
]
)
;
flow
.
fragments
=
old_fragments
;
flow
.
lines
=
lines
;
}
fn
reflow_fragments
<
'
a
I
>
(
&
mut
self
mut
old_fragment_iter
:
I
flow
:
&
'
a
InlineFlow
layout_context
:
&
LayoutContext
)
where
I
:
Iterator
<
Item
=
Fragment
>
{
loop
{
let
fragment
=
match
self
.
next_unbroken_fragment
(
&
mut
old_fragment_iter
)
{
None
=
>
break
Some
(
fragment
)
=
>
fragment
}
;
let
fragment
=
if
fragment
.
flags
.
contains
(
FragmentFlags
:
:
IS_ELLIPSIS
)
{
continue
}
else
if
let
SpecificFragmentInfo
:
:
TruncatedFragment
(
info
)
=
fragment
.
specific
{
info
.
full
}
else
{
fragment
}
;
self
.
reflow_fragment
(
fragment
flow
layout_context
)
;
}
if
!
self
.
pending_line_is_empty
(
)
{
debug
!
(
"
LineBreaker
:
partially
full
line
{
}
at
end
of
scanning
;
committing
it
"
self
.
lines
.
len
(
)
)
;
self
.
flush_current_line
(
)
}
}
fn
next_fragment
<
I
>
(
&
mut
self
old_fragment_iter
:
&
mut
I
)
-
>
Option
<
Fragment
>
where
I
:
Iterator
<
Item
=
Fragment
>
{
self
.
work_list
.
pop_front
(
)
.
or_else
(
|
|
old_fragment_iter
.
next
(
)
)
}
fn
next_unbroken_fragment
<
I
>
(
&
mut
self
old_fragment_iter
:
&
mut
I
)
-
>
Option
<
Fragment
>
where
I
:
Iterator
<
Item
=
Fragment
>
{
let
mut
result
=
self
.
next_fragment
(
old_fragment_iter
)
?
;
loop
{
let
candidate
=
match
self
.
next_fragment
(
old_fragment_iter
)
{
None
=
>
return
Some
(
result
)
Some
(
fragment
)
=
>
fragment
}
;
let
need_to_merge
=
match
(
&
mut
result
.
specific
&
candidate
.
specific
)
{
(
&
mut
SpecificFragmentInfo
:
:
ScannedText
(
ref
mut
result_info
)
&
SpecificFragmentInfo
:
:
ScannedText
(
ref
candidate_info
)
)
=
>
{
result
.
margin
.
inline_end
=
=
Au
(
0
)
&
&
candidate
.
margin
.
inline_start
=
=
Au
(
0
)
&
&
result
.
border_padding
.
inline_end
=
=
Au
(
0
)
&
&
candidate
.
border_padding
.
inline_start
=
=
Au
(
0
)
&
&
result_info
.
selected
(
)
=
=
candidate_info
.
selected
(
)
&
&
Arc
:
:
ptr_eq
(
&
result_info
.
run
&
candidate_info
.
run
)
&
&
inline_contexts_are_equal
(
&
result
.
inline_context
&
candidate
.
inline_context
)
}
_
=
>
false
}
;
if
need_to_merge
{
result
.
merge_with
(
candidate
)
;
continue
}
self
.
work_list
.
push_front
(
candidate
)
;
return
Some
(
result
)
}
}
fn
flush_current_line
(
&
mut
self
)
{
debug
!
(
"
LineBreaker
:
flushing
line
{
}
:
{
:
?
}
"
self
.
lines
.
len
(
)
self
.
pending_line
)
;
self
.
strip_trailing_whitespace_from_pending_line_if_necessary
(
)
;
self
.
lines
.
push
(
self
.
pending_line
.
clone
(
)
)
;
self
.
cur_b
=
self
.
pending_line
.
bounds
.
start
.
b
+
self
.
pending_line
.
bounds
.
size
.
block
;
self
.
reset_line
(
)
;
}
fn
strip_trailing_whitespace_from_pending_line_if_necessary
(
&
mut
self
)
{
if
self
.
pending_line
.
range
.
is_empty
(
)
{
return
}
let
last_fragment_index
=
self
.
pending_line
.
range
.
end
(
)
-
FragmentIndex
(
1
)
;
let
fragment
=
&
mut
self
.
new_fragments
[
last_fragment_index
.
get
(
)
as
usize
]
;
let
old_fragment_inline_size
=
fragment
.
border_box
.
size
.
inline
;
fragment
.
strip_trailing_whitespace_if_necessary
(
)
;
self
.
pending_line
.
bounds
.
size
.
inline
+
=
fragment
.
border_box
.
size
.
inline
-
old_fragment_inline_size
;
}
fn
initial_line_placement
(
&
self
flow
:
&
InlineFlow
first_fragment
:
&
Fragment
ceiling
:
Au
)
-
>
(
LogicalRect
<
Au
>
Au
)
{
debug
!
(
"
LineBreaker
:
trying
to
place
first
fragment
of
line
{
}
;
fragment
size
:
{
:
?
}
\
splittable
:
{
}
"
self
.
lines
.
len
(
)
first_fragment
.
border_box
.
size
first_fragment
.
can_split
(
)
)
;
let
placement_inline_size
=
if
first_fragment
.
can_split
(
)
{
first_fragment
.
minimum_splittable_inline_size
(
)
}
else
{
first_fragment
.
margin_box_inline_size
(
)
+
self
.
indentation_for_pending_fragment
(
)
}
;
let
line_bounds
=
self
.
floats
.
place_between_floats
(
&
PlacementInfo
{
size
:
LogicalSize
:
:
new
(
self
.
floats
.
writing_mode
placement_inline_size
first_fragment
.
border_box
.
size
.
block
)
ceiling
:
ceiling
max_inline_size
:
flow
.
base
.
position
.
size
.
inline
kind
:
FloatKind
:
:
Left
}
)
;
let
fragment_margin_box_inline_size
=
first_fragment
.
margin_box_inline_size
(
)
;
if
line_bounds
.
size
.
inline
>
fragment_margin_box_inline_size
{
debug
!
(
"
LineBreaker
:
fragment
fits
on
line
{
}
"
self
.
lines
.
len
(
)
)
;
return
(
line_bounds
fragment_margin_box_inline_size
)
;
}
if
!
first_fragment
.
can_split
(
)
{
debug
!
(
"
LineBreaker
:
line
doesn
'
t
fit
but
is
unsplittable
"
)
;
}
(
line_bounds
fragment_margin_box_inline_size
)
}
fn
avoid_floats
(
&
mut
self
flow
:
&
InlineFlow
in_fragment
:
Fragment
new_block_size
:
Au
)
-
>
bool
{
debug
!
(
"
LineBreaker
:
entering
float
collision
avoider
!
"
)
;
let
(
next_line
first_fragment_inline_size
)
=
self
.
initial_line_placement
(
flow
&
in_fragment
self
.
pending_line
.
bounds
.
start
.
b
)
;
let
next_green_zone
=
next_line
.
size
;
let
new_inline_size
=
self
.
pending_line
.
bounds
.
size
.
inline
+
first_fragment_inline_size
;
if
next_green_zone
.
inline
>
=
new_inline_size
&
&
next_green_zone
.
block
>
=
new_block_size
{
debug
!
(
"
LineBreaker
:
case
=
adding
fragment
collides
vertically
with
floats
:
moving
\
line
"
)
;
self
.
pending_line
.
bounds
.
start
=
next_line
.
start
;
self
.
pending_line
.
green_zone
=
next_green_zone
;
debug_assert
!
(
!
self
.
pending_line_is_empty
(
)
"
Non
-
terminating
line
breaking
"
)
;
self
.
work_list
.
push_front
(
in_fragment
)
;
return
true
}
debug
!
(
"
LineBreaker
:
case
=
adding
fragment
collides
vertically
with
floats
:
breaking
line
"
)
;
self
.
work_list
.
push_front
(
in_fragment
)
;
false
}
fn
reflow_fragment
(
&
mut
self
mut
fragment
:
Fragment
flow
:
&
InlineFlow
layout_context
:
&
LayoutContext
)
{
fragment
.
reset_text_range_and_inline_size
(
)
;
let
fragment_is_line_break_opportunity
=
if
self
.
pending_line_is_empty
(
)
{
fragment
.
strip_leading_whitespace_if_necessary
(
)
;
let
(
line_bounds
_
)
=
self
.
initial_line_placement
(
flow
&
fragment
self
.
cur_b
)
;
self
.
pending_line
.
bounds
.
start
=
line_bounds
.
start
;
self
.
pending_line
.
green_zone
=
line_bounds
.
size
;
false
}
else
{
if
fragment
.
suppress_line_break_before
(
)
|
|
!
fragment
.
is_on_glyph_run_boundary
(
)
{
false
}
else
{
fragment
.
white_space
(
)
.
allow_wrap
(
)
}
}
;
debug
!
(
"
LineBreaker
:
trying
to
append
to
line
{
}
\
(
fragment
size
:
{
:
?
}
green
zone
:
{
:
?
}
)
:
{
:
?
}
"
self
.
lines
.
len
(
)
fragment
.
border_box
.
size
self
.
pending_line
.
green_zone
fragment
)
;
let
green_zone
=
self
.
pending_line
.
green_zone
;
let
new_line_metrics
=
self
.
pending_line
.
new_metrics_for_fragment
(
&
fragment
layout_context
)
;
let
new_block_size
=
self
.
pending_line
.
new_block_size_for_fragment
(
&
fragment
&
new_line_metrics
layout_context
)
;
if
new_block_size
>
green_zone
.
block
{
if
!
self
.
avoid_floats
(
flow
fragment
new_block_size
)
{
self
.
flush_current_line
(
)
;
}
return
}
if
fragment_is_line_break_opportunity
{
self
.
last_known_line_breaking_opportunity
=
Some
(
self
.
pending_line
.
range
.
end
(
)
)
}
let
line_flush_mode
=
if
fragment
.
white_space
(
)
.
preserve_newlines
(
)
{
if
fragment
.
requires_line_break_afterward_if_wrapping_on_newlines
(
)
{
LineFlushMode
:
:
Flush
}
else
{
LineFlushMode
:
:
No
}
}
else
{
LineFlushMode
:
:
No
}
;
let
indentation
=
self
.
indentation_for_pending_fragment
(
)
;
let
new_inline_size
=
self
.
pending_line
.
bounds
.
size
.
inline
+
fragment
.
margin_box_inline_size
(
)
+
indentation
;
if
new_inline_size
<
=
green_zone
.
inline
{
debug
!
(
"
LineBreaker
:
fragment
fits
without
splitting
"
)
;
self
.
push_fragment_to_line
(
layout_context
fragment
line_flush_mode
)
;
return
}
if
!
fragment
.
white_space
(
)
.
allow_wrap
(
)
{
debug
!
(
"
LineBreaker
:
fragment
can
'
t
split
;
falling
back
to
last
known
good
split
point
"
)
;
self
.
split_line_at_last_known_good_position
(
layout_context
fragment
line_flush_mode
)
;
return
;
}
let
available_inline_size
=
green_zone
.
inline
-
self
.
pending_line
.
bounds
.
size
.
inline
-
indentation
;
let
inline_start_fragment
;
let
inline_end_fragment
;
let
split_result
=
match
fragment
.
calculate_split_position
(
available_inline_size
self
.
pending_line_is_empty
(
)
)
{
None
=
>
{
if
fragment_is_line_break_opportunity
{
debug
!
(
"
LineBreaker
:
fragment
was
unsplittable
;
deferring
to
next
line
"
)
;
self
.
work_list
.
push_front
(
fragment
)
;
self
.
flush_current_line
(
)
;
}
else
{
self
.
split_line_at_last_known_good_position
(
layout_context
fragment
LineFlushMode
:
:
No
)
;
}
return
}
Some
(
split_result
)
=
>
split_result
}
;
inline_start_fragment
=
split_result
.
inline_start
.
as_ref
(
)
.
map
(
|
x
|
{
fragment
.
transform_with_split_info
(
x
split_result
.
text_run
.
clone
(
)
true
)
}
)
;
inline_end_fragment
=
split_result
.
inline_end
.
as_ref
(
)
.
map
(
|
x
|
{
fragment
.
transform_with_split_info
(
x
split_result
.
text_run
.
clone
(
)
false
)
}
)
;
match
(
inline_start_fragment
inline_end_fragment
)
{
(
Some
(
mut
inline_start_fragment
)
Some
(
mut
inline_end_fragment
)
)
=
>
{
inline_start_fragment
.
border_padding
.
inline_end
=
Au
(
0
)
;
if
let
Some
(
ref
mut
inline_context
)
=
inline_start_fragment
.
inline_context
{
for
node
in
&
mut
inline_context
.
nodes
{
node
.
flags
.
remove
(
InlineFragmentNodeFlags
:
:
LAST_FRAGMENT_OF_ELEMENT
)
;
}
}
inline_start_fragment
.
border_box
.
size
.
inline
+
=
inline_start_fragment
.
border_padding
.
inline_start
;
inline_end_fragment
.
border_padding
.
inline_start
=
Au
(
0
)
;
if
let
Some
(
ref
mut
inline_context
)
=
inline_end_fragment
.
inline_context
{
for
node
in
&
mut
inline_context
.
nodes
{
node
.
flags
.
remove
(
InlineFragmentNodeFlags
:
:
FIRST_FRAGMENT_OF_ELEMENT
)
;
}
}
inline_end_fragment
.
border_box
.
size
.
inline
+
=
inline_end_fragment
.
border_padding
.
inline_end
;
self
.
push_fragment_to_line
(
layout_context
inline_start_fragment
LineFlushMode
:
:
Flush
)
;
self
.
work_list
.
push_front
(
inline_end_fragment
)
}
(
Some
(
fragment
)
None
)
=
>
{
self
.
push_fragment_to_line
(
layout_context
fragment
line_flush_mode
)
;
}
(
None
Some
(
fragment
)
)
=
>
{
self
.
flush_current_line
(
)
;
self
.
work_list
.
push_front
(
fragment
)
}
(
None
None
)
=
>
{
}
}
}
fn
push_fragment_to_line
(
&
mut
self
layout_context
:
&
LayoutContext
fragment
:
Fragment
line_flush_mode
:
LineFlushMode
)
{
let
indentation
=
self
.
indentation_for_pending_fragment
(
)
;
if
self
.
pending_line_is_empty
(
)
{
debug_assert
!
(
self
.
new_fragments
.
len
(
)
<
=
(
isize
:
:
MAX
as
usize
)
)
;
self
.
pending_line
.
range
.
reset
(
FragmentIndex
(
self
.
new_fragments
.
len
(
)
as
isize
)
FragmentIndex
(
0
)
)
;
}
let
available_inline_size
=
self
.
pending_line
.
green_zone
.
inline
-
self
.
pending_line
.
bounds
.
size
.
inline
-
indentation
;
let
ellipsis
=
match
(
&
fragment
.
style
(
)
.
get_text
(
)
.
text_overflow
.
second
fragment
.
style
(
)
.
get_box
(
)
.
overflow_x
)
{
(
&
TextOverflowSide
:
:
Clip
_
)
|
(
_
StyleOverflow
:
:
Visible
)
=
>
None
(
&
TextOverflowSide
:
:
Ellipsis
_
)
=
>
{
if
fragment
.
margin_box_inline_size
(
)
>
available_inline_size
{
Some
(
"
"
.
to_string
(
)
)
}
else
{
None
}
}
(
&
TextOverflowSide
:
:
String
(
ref
string
)
_
)
=
>
{
if
fragment
.
margin_box_inline_size
(
)
>
available_inline_size
{
Some
(
string
.
to_string
(
)
)
}
else
{
None
}
}
}
;
if
let
Some
(
string
)
=
ellipsis
{
let
ellipsis
=
fragment
.
transform_into_ellipsis
(
layout_context
string
)
;
let
truncated
=
fragment
.
truncate_to_inline_size
(
available_inline_size
-
ellipsis
.
margin_box_inline_size
(
)
)
;
self
.
push_fragment_to_line_ignoring_text_overflow
(
truncated
layout_context
)
;
self
.
push_fragment_to_line_ignoring_text_overflow
(
ellipsis
layout_context
)
;
}
else
{
self
.
push_fragment_to_line_ignoring_text_overflow
(
fragment
layout_context
)
;
}
if
line_flush_mode
=
=
LineFlushMode
:
:
Flush
{
self
.
flush_current_line
(
)
}
}
fn
push_fragment_to_line_ignoring_text_overflow
(
&
mut
self
fragment
:
Fragment
layout_context
:
&
LayoutContext
)
{
let
indentation
=
self
.
indentation_for_pending_fragment
(
)
;
self
.
pending_line
.
range
.
extend_by
(
FragmentIndex
(
1
)
)
;
if
!
fragment
.
is_inline_absolute
(
)
&
&
!
fragment
.
is_hypothetical
(
)
{
self
.
pending_line
.
bounds
.
size
.
inline
=
self
.
pending_line
.
bounds
.
size
.
inline
+
fragment
.
margin_box_inline_size
(
)
+
indentation
;
self
.
pending_line
.
metrics
=
self
.
pending_line
.
new_metrics_for_fragment
(
&
fragment
layout_context
)
;
self
.
pending_line
.
bounds
.
size
.
block
=
self
.
pending_line
.
new_block_size_for_fragment
(
&
fragment
&
self
.
pending_line
.
metrics
layout_context
)
;
}
self
.
new_fragments
.
push
(
fragment
)
;
}
fn
split_line_at_last_known_good_position
(
&
mut
self
layout_context
:
&
LayoutContext
cur_fragment
:
Fragment
line_flush_mode
:
LineFlushMode
)
{
let
last_known_line_breaking_opportunity
=
match
self
.
last_known_line_breaking_opportunity
{
None
=
>
{
self
.
push_fragment_to_line
(
layout_context
cur_fragment
line_flush_mode
)
;
return
;
}
Some
(
last_known_line_breaking_opportunity
)
=
>
last_known_line_breaking_opportunity
}
;
self
.
work_list
.
push_front
(
cur_fragment
)
;
for
fragment_index
in
(
last_known_line_breaking_opportunity
.
get
(
)
.
.
self
.
pending_line
.
range
.
end
(
)
.
get
(
)
)
.
rev
(
)
{
debug_assert_eq
!
(
fragment_index
(
self
.
new_fragments
.
len
(
)
as
isize
)
-
1
)
;
self
.
work_list
.
push_front
(
self
.
new_fragments
.
pop
(
)
.
unwrap
(
)
)
;
}
self
.
pending_line
.
range
.
extend_to
(
last_known_line_breaking_opportunity
)
;
self
.
flush_current_line
(
)
;
}
fn
indentation_for_pending_fragment
(
&
self
)
-
>
Au
{
if
self
.
pending_line_is_empty
(
)
&
&
self
.
lines
.
is_empty
(
)
{
self
.
first_line_indentation
}
else
{
Au
(
0
)
}
}
fn
pending_line_is_empty
(
&
self
)
-
>
bool
{
self
.
pending_line
.
range
.
length
(
)
=
=
FragmentIndex
(
0
)
}
}
#
[
derive
(
Clone
Serialize
)
]
pub
struct
InlineFragments
{
pub
fragments
:
Vec
<
Fragment
>
}
impl
InlineFragments
{
pub
fn
new
(
)
-
>
InlineFragments
{
InlineFragments
{
fragments
:
vec
!
[
]
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
fragments
.
len
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
fragments
.
is_empty
(
)
}
pub
fn
get
(
&
self
index
:
usize
)
-
>
&
Fragment
{
&
self
.
fragments
[
index
]
}
pub
fn
get_mut
(
&
mut
self
index
:
usize
)
-
>
&
mut
Fragment
{
&
mut
self
.
fragments
[
index
]
}
}
#
[
allow
(
unsafe_code
)
]
unsafe
impl
:
:
flow
:
:
HasBaseFlow
for
InlineFlow
{
}
#
[
derive
(
Serialize
)
]
#
[
repr
(
C
)
]
pub
struct
InlineFlow
{
pub
base
:
BaseFlow
pub
fragments
:
InlineFragments
pub
lines
:
Vec
<
Line
>
pub
minimum_line_metrics
:
LineMetrics
pub
first_line_indentation
:
Au
}
impl
InlineFlow
{
pub
fn
from_fragments
(
fragments
:
InlineFragments
writing_mode
:
WritingMode
)
-
>
InlineFlow
{
let
mut
flow
=
InlineFlow
{
base
:
BaseFlow
:
:
new
(
None
writing_mode
ForceNonfloatedFlag
:
:
ForceNonfloated
)
fragments
:
fragments
lines
:
Vec
:
:
new
(
)
minimum_line_metrics
:
LineMetrics
:
:
new
(
Au
(
0
)
Au
(
0
)
)
first_line_indentation
:
Au
(
0
)
}
;
if
flow
.
fragments
.
fragments
.
iter
(
)
.
any
(
Fragment
:
:
is_unscanned_generated_content
)
{
flow
.
base
.
restyle_damage
.
insert
(
ServoRestyleDamage
:
:
RESOLVE_GENERATED_CONTENT
)
;
}
flow
}
fn
set_inline_fragment_positions
(
fragments
:
&
mut
InlineFragments
line
:
&
Line
line_align
:
TextAlign
indentation
:
Au
is_last_line
:
bool
)
{
let
slack_inline_size
=
max
(
Au
(
0
)
line
.
green_zone
.
inline
-
line
.
bounds
.
size
.
inline
)
;
if
fragments
.
fragments
.
is_empty
(
)
{
return
}
let
text_justify
=
fragments
.
fragments
[
0
]
.
style
(
)
.
get_inheritedtext
(
)
.
text_justify
;
let
is_ltr
=
fragments
.
fragments
[
0
]
.
style
(
)
.
writing_mode
.
is_bidi_ltr
(
)
;
let
line_align
=
match
(
line_align
is_ltr
)
{
(
TextAlign
:
:
Left
true
)
|
(
TextAlign
:
:
ServoLeft
true
)
|
(
TextAlign
:
:
Right
false
)
|
(
TextAlign
:
:
ServoRight
false
)
=
>
TextAlign
:
:
Start
(
TextAlign
:
:
Left
false
)
|
(
TextAlign
:
:
ServoLeft
false
)
|
(
TextAlign
:
:
Right
true
)
|
(
TextAlign
:
:
ServoRight
true
)
=
>
TextAlign
:
:
End
_
=
>
line_align
}
;
let
mut
inline_start_position_for_fragment
=
line
.
bounds
.
start
.
i
+
indentation
;
match
line_align
{
TextAlign
:
:
Justify
if
!
is_last_line
&
&
text_justify
!
=
TextJustify
:
:
None
=
>
{
InlineFlow
:
:
justify_inline_fragments
(
fragments
line
slack_inline_size
)
}
TextAlign
:
:
Justify
|
TextAlign
:
:
Start
=
>
{
}
TextAlign
:
:
Center
|
TextAlign
:
:
ServoCenter
=
>
{
inline_start_position_for_fragment
=
inline_start_position_for_fragment
+
slack_inline_size
.
scale_by
(
0
.
5
)
}
TextAlign
:
:
End
=
>
{
inline_start_position_for_fragment
=
inline_start_position_for_fragment
+
slack_inline_size
}
TextAlign
:
:
Left
|
TextAlign
:
:
ServoLeft
|
TextAlign
:
:
Right
|
TextAlign
:
:
ServoRight
=
>
unreachable
!
(
)
}
let
run_count
=
match
line
.
visual_runs
{
Some
(
ref
runs
)
=
>
runs
.
len
(
)
None
=
>
1
}
;
for
run_idx
in
0
.
.
run_count
{
let
(
range
level
)
=
match
line
.
visual_runs
{
Some
(
ref
runs
)
if
is_ltr
=
>
runs
[
run_idx
]
Some
(
ref
runs
)
=
>
runs
[
run_count
-
run_idx
-
1
]
None
=
>
(
line
.
range
bidi
:
:
Level
:
:
ltr
(
)
)
}
;
struct
MaybeReverse
<
I
>
{
iter
:
I
reverse
:
bool
}
impl
<
I
:
DoubleEndedIterator
>
Iterator
for
MaybeReverse
<
I
>
{
type
Item
=
I
:
:
Item
;
fn
next
(
&
mut
self
)
-
>
Option
<
I
:
:
Item
>
{
if
self
.
reverse
{
self
.
iter
.
next_back
(
)
}
else
{
self
.
iter
.
next
(
)
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
let
fragment_indices
=
MaybeReverse
{
iter
:
range
.
begin
(
)
.
get
(
)
.
.
range
.
end
(
)
.
get
(
)
reverse
:
level
.
is_ltr
(
)
!
=
is_ltr
}
;
for
fragment_index
in
fragment_indices
{
let
fragment
=
fragments
.
get_mut
(
fragment_index
as
usize
)
;
inline_start_position_for_fragment
=
inline_start_position_for_fragment
+
fragment
.
margin
.
inline_start
;
let
border_start
=
if
fragment
.
style
.
writing_mode
.
is_bidi_ltr
(
)
=
=
is_ltr
{
inline_start_position_for_fragment
}
else
{
line
.
green_zone
.
inline
-
inline_start_position_for_fragment
-
fragment
.
margin
.
inline_end
-
fragment
.
border_box
.
size
.
inline
}
;
fragment
.
border_box
=
LogicalRect
:
:
new
(
fragment
.
style
.
writing_mode
border_start
fragment
.
border_box
.
start
.
b
fragment
.
border_box
.
size
.
inline
fragment
.
border_box
.
size
.
block
)
;
fragment
.
update_late_computed_inline_position_if_necessary
(
)
;
if
!
fragment
.
is_inline_absolute
(
)
{
inline_start_position_for_fragment
=
inline_start_position_for_fragment
+
fragment
.
border_box
.
size
.
inline
+
fragment
.
margin
.
inline_end
;
}
}
}
}
fn
justify_inline_fragments
(
fragments
:
&
mut
InlineFragments
line
:
&
Line
slack_inline_size
:
Au
)
{
if
slack_inline_size
=
=
Au
(
0
)
{
return
}
let
mut
expansion_opportunities
=
0
;
for
fragment_index
in
line
.
range
.
each_index
(
)
{
let
fragment
=
fragments
.
get
(
fragment_index
.
to_usize
(
)
)
;
let
scanned_text_fragment_info
=
match
fragment
.
specific
{
SpecificFragmentInfo
:
:
ScannedText
(
ref
info
)
if
!
info
.
range
.
is_empty
(
)
=
>
info
_
=
>
continue
}
;
let
fragment_range
=
scanned_text_fragment_info
.
range
;
for
slice
in
scanned_text_fragment_info
.
run
.
character_slices_in_range
(
&
fragment_range
)
{
expansion_opportunities
+
=
slice
.
glyphs
.
space_count_in_range
(
&
slice
.
range
)
}
}
if
expansion_opportunities
=
=
0
{
return
}
let
space_per_expansion_opportunity
=
slack_inline_size
/
expansion_opportunities
as
i32
;
for
fragment_index
in
line
.
range
.
each_index
(
)
{
let
fragment
=
fragments
.
get_mut
(
fragment_index
.
to_usize
(
)
)
;
let
scanned_text_fragment_info
=
match
fragment
.
specific
{
SpecificFragmentInfo
:
:
ScannedText
(
ref
mut
info
)
if
!
info
.
range
.
is_empty
(
)
=
>
info
_
=
>
continue
}
;
let
fragment_range
=
scanned_text_fragment_info
.
range
;
let
run
=
Arc
:
:
make_mut
(
&
mut
scanned_text_fragment_info
.
run
)
;
run
.
extra_word_spacing
=
space_per_expansion_opportunity
;
let
new_inline_size
=
run
.
advance_for_range
(
&
fragment_range
)
;
let
new_size
=
LogicalSize
:
:
new
(
fragment
.
style
.
writing_mode
new_inline_size
fragment
.
border_box
.
size
.
block
)
;
fragment
.
border_box
=
LogicalRect
:
:
from_point_size
(
fragment
.
style
.
writing_mode
fragment
.
border_box
.
start
new_size
)
;
}
}
fn
set_block_fragment_positions
(
fragments
:
&
mut
InlineFragments
line
:
&
Line
minimum_line_metrics
:
&
LineMetrics
layout_context
:
&
LayoutContext
)
{
for
fragment_index
in
line
.
range
.
each_index
(
)
{
let
fragment
=
fragments
.
get_mut
(
fragment_index
.
to_usize
(
)
)
;
let
line_metrics
=
LineMetrics
:
:
for_line_and_fragment
(
line
fragment
layout_context
)
;
let
inline_metrics
=
fragment
.
aligned_inline_metrics
(
layout_context
minimum_line_metrics
Some
(
&
line_metrics
)
)
;
fragment
.
border_box
.
start
.
b
=
line
.
bounds
.
start
.
b
+
line_metrics
.
space_above_baseline
-
inline_metrics
.
ascent
;
if
!
fragment
.
is_replaced_or_inline_block
(
)
{
fragment
.
border_box
.
start
.
b
-
=
fragment
.
border_padding
.
block_start
}
fragment
.
update_late_computed_block_position_if_necessary
(
)
;
}
}
pub
fn
minimum_line_metrics
(
&
self
font_context
:
&
mut
FontContext
style
:
&
ComputedValues
)
-
>
LineMetrics
{
InlineFlow
:
:
minimum_line_metrics_for_fragments
(
&
self
.
fragments
.
fragments
font_context
style
)
}
pub
fn
minimum_line_metrics_for_fragments
(
fragments
:
&
[
Fragment
]
font_context
:
&
mut
FontContext
style
:
&
ComputedValues
)
-
>
LineMetrics
{
if
fragments
.
iter
(
)
.
all
(
Fragment
:
:
is_hypothetical
)
{
return
LineMetrics
:
:
new
(
Au
(
0
)
Au
(
0
)
)
}
let
font_style
=
style
.
clone_font
(
)
;
let
font_metrics
=
text
:
:
font_metrics_for_style
(
font_context
font_style
)
;
let
line_height
=
text
:
:
line_height_from_style
(
style
&
font_metrics
)
;
let
inline_metrics
=
if
fragments
.
iter
(
)
.
any
(
Fragment
:
:
is_text_or_replaced
)
{
InlineMetrics
:
:
from_font_metrics
(
&
font_metrics
line_height
)
}
else
{
InlineMetrics
:
:
new
(
Au
(
0
)
Au
(
0
)
Au
(
0
)
)
}
;
let
mut
line_metrics
=
LineMetrics
:
:
new
(
Au
(
0
)
MIN_AU
)
;
let
mut
largest_block_size_for_top_fragments
=
Au
(
0
)
;
let
mut
largest_block_size_for_bottom_fragments
=
Au
(
0
)
;
update_line_metrics_for_fragment
(
&
mut
line_metrics
&
inline_metrics
style
.
get_box
(
)
.
display
GenericVerticalAlign
:
:
Baseline
&
mut
largest_block_size_for_top_fragments
&
mut
largest_block_size_for_bottom_fragments
)
;
for
inline_context
in
fragments
.
iter
(
)
.
filter_map
(
|
fragment
|
fragment
.
inline_context
.
as_ref
(
)
)
{
for
node
in
&
inline_context
.
nodes
{
let
font_style
=
node
.
style
.
clone_font
(
)
;
let
font_metrics
=
text
:
:
font_metrics_for_style
(
font_context
font_style
)
;
let
line_height
=
text
:
:
line_height_from_style
(
&
*
node
.
style
&
font_metrics
)
;
let
inline_metrics
=
InlineMetrics
:
:
from_font_metrics
(
&
font_metrics
line_height
)
;
update_line_metrics_for_fragment
(
&
mut
line_metrics
&
inline_metrics
node
.
style
.
get_box
(
)
.
display
node
.
style
.
get_box
(
)
.
vertical_align
&
mut
largest_block_size_for_top_fragments
&
mut
largest_block_size_for_bottom_fragments
)
;
}
}
line_metrics
.
space_above_baseline
=
max
(
line_metrics
.
space_above_baseline
largest_block_size_for_bottom_fragments
-
max
(
line_metrics
.
space_below_baseline
Au
(
0
)
)
)
;
line_metrics
.
space_below_baseline
=
max
(
line_metrics
.
space_below_baseline
largest_block_size_for_top_fragments
-
line_metrics
.
space_above_baseline
)
;
return
line_metrics
;
fn
update_line_metrics_for_fragment
(
line_metrics
:
&
mut
LineMetrics
inline_metrics
:
&
InlineMetrics
display_value
:
Display
vertical_align_value
:
VerticalAlign
largest_block_size_for_top_fragments
:
&
mut
Au
largest_block_size_for_bottom_fragments
:
&
mut
Au
)
{
match
(
display_value
vertical_align_value
)
{
(
Display
:
:
Inline
GenericVerticalAlign
:
:
Top
)
|
(
Display
:
:
Block
GenericVerticalAlign
:
:
Top
)
|
(
Display
:
:
InlineFlex
GenericVerticalAlign
:
:
Top
)
|
(
Display
:
:
InlineBlock
GenericVerticalAlign
:
:
Top
)
if
inline_metrics
.
space_above_baseline
>
=
Au
(
0
)
=
>
{
*
largest_block_size_for_top_fragments
=
max
(
*
largest_block_size_for_top_fragments
inline_metrics
.
space_above_baseline
+
inline_metrics
.
space_below_baseline
)
}
(
Display
:
:
Inline
GenericVerticalAlign
:
:
Bottom
)
|
(
Display
:
:
Block
GenericVerticalAlign
:
:
Bottom
)
|
(
Display
:
:
InlineFlex
GenericVerticalAlign
:
:
Bottom
)
|
(
Display
:
:
InlineBlock
GenericVerticalAlign
:
:
Bottom
)
if
inline_metrics
.
space_below_baseline
>
=
Au
(
0
)
=
>
{
*
largest_block_size_for_bottom_fragments
=
max
(
*
largest_block_size_for_bottom_fragments
inline_metrics
.
space_above_baseline
+
inline_metrics
.
space_below_baseline
)
}
_
=
>
*
line_metrics
=
line_metrics
.
new_metrics_for_fragment
(
inline_metrics
)
}
}
}
fn
update_restyle_damage
(
&
mut
self
)
{
let
mut
damage
=
self
.
base
.
restyle_damage
;
for
frag
in
&
self
.
fragments
.
fragments
{
damage
.
insert
(
frag
.
restyle_damage
(
)
)
;
}
self
.
base
.
restyle_damage
=
damage
;
}
fn
containing_block_range_for_flow_surrounding_fragment_at_index
(
&
self
fragment_index
:
FragmentIndex
)
-
>
Range
<
FragmentIndex
>
{
let
mut
start_index
=
fragment_index
;
while
start_index
>
FragmentIndex
(
0
)
&
&
self
.
fragments
.
fragments
[
(
start_index
-
FragmentIndex
(
1
)
)
.
get
(
)
as
usize
]
.
is_positioned
(
)
{
start_index
=
start_index
-
FragmentIndex
(
1
)
}
let
mut
end_index
=
fragment_index
+
FragmentIndex
(
1
)
;
while
end_index
<
FragmentIndex
(
self
.
fragments
.
fragments
.
len
(
)
as
isize
)
&
&
self
.
fragments
.
fragments
[
end_index
.
get
(
)
as
usize
]
.
is_positioned
(
)
{
end_index
=
end_index
+
FragmentIndex
(
1
)
}
Range
:
:
new
(
start_index
end_index
-
start_index
)
}
fn
containing_block_range_for_flow
(
&
self
opaque_flow
:
OpaqueFlow
)
-
>
Range
<
FragmentIndex
>
{
match
self
.
fragments
.
fragments
.
iter
(
)
.
position
(
|
fragment
|
{
match
fragment
.
specific
{
SpecificFragmentInfo
:
:
InlineAbsolute
(
ref
inline_absolute
)
=
>
{
OpaqueFlow
:
:
from_flow
(
&
*
inline_absolute
.
flow_ref
)
=
=
opaque_flow
}
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
ref
inline_absolute_hypothetical
)
=
>
{
OpaqueFlow
:
:
from_flow
(
&
*
inline_absolute_hypothetical
.
flow_ref
)
=
=
opaque_flow
}
_
=
>
false
}
}
)
{
Some
(
index
)
=
>
{
let
index
=
FragmentIndex
(
index
as
isize
)
;
self
.
containing_block_range_for_flow_surrounding_fragment_at_index
(
index
)
}
None
=
>
{
Range
:
:
new
(
FragmentIndex
(
0
)
FragmentIndex
(
self
.
fragments
.
fragments
.
len
(
)
as
isize
)
)
}
}
}
pub
fn
baseline_offset_of_last_line
(
&
self
)
-
>
Option
<
Au
>
{
self
.
last_line_containing_real_fragments
(
)
.
map
(
|
line
|
{
line
.
bounds
.
start
.
b
+
line
.
bounds
.
size
.
block
-
line
.
metrics
.
space_below_baseline
}
)
}
fn
last_line_containing_real_fragments
(
&
self
)
-
>
Option
<
&
Line
>
{
for
line
in
self
.
lines
.
iter
(
)
.
rev
(
)
{
if
(
line
.
range
.
begin
(
)
.
get
(
)
.
.
line
.
range
.
end
(
)
.
get
(
)
)
.
any
(
|
index
|
{
!
self
.
fragments
.
fragments
[
index
as
usize
]
.
is_hypothetical
(
)
}
)
{
return
Some
(
line
)
}
}
None
}
}
impl
Flow
for
InlineFlow
{
fn
class
(
&
self
)
-
>
FlowClass
{
FlowClass
:
:
Inline
}
fn
as_inline
(
&
self
)
-
>
&
InlineFlow
{
self
}
fn
as_mut_inline
(
&
mut
self
)
-
>
&
mut
InlineFlow
{
self
}
fn
bubble_inline_sizes
(
&
mut
self
)
{
self
.
update_restyle_damage
(
)
;
let
_scope
=
layout_debug_scope
!
(
"
inline
:
:
bubble_inline_sizes
{
:
x
}
"
self
.
base
.
debug_id
(
)
)
;
let
writing_mode
=
self
.
base
.
writing_mode
;
for
kid
in
self
.
base
.
child_iter_mut
(
)
{
kid
.
mut_base
(
)
.
floats
=
Floats
:
:
new
(
writing_mode
)
;
}
self
.
base
.
flags
.
remove
(
FlowFlags
:
:
CONTAINS_TEXT_OR_REPLACED_FRAGMENTS
)
;
let
mut
intrinsic_sizes_for_flow
=
IntrinsicISizesContribution
:
:
new
(
)
;
let
mut
intrinsic_sizes_for_inline_run
=
IntrinsicISizesContribution
:
:
new
(
)
;
let
mut
intrinsic_sizes_for_nonbroken_run
=
IntrinsicISizesContribution
:
:
new
(
)
;
for
fragment
in
&
mut
self
.
fragments
.
fragments
{
let
intrinsic_sizes_for_fragment
=
fragment
.
compute_intrinsic_inline_sizes
(
)
.
finish
(
)
;
match
fragment
.
style
.
get_inheritedtext
(
)
.
white_space
{
WhiteSpace
:
:
Nowrap
=
>
{
intrinsic_sizes_for_nonbroken_run
.
union_nonbreaking_inline
(
&
intrinsic_sizes_for_fragment
)
}
WhiteSpace
:
:
Pre
=
>
{
intrinsic_sizes_for_nonbroken_run
.
union_nonbreaking_inline
(
&
intrinsic_sizes_for_fragment
)
;
if
fragment
.
requires_line_break_afterward_if_wrapping_on_newlines
(
)
{
intrinsic_sizes_for_inline_run
.
union_inline
(
&
intrinsic_sizes_for_nonbroken_run
.
finish
(
)
)
;
intrinsic_sizes_for_nonbroken_run
=
IntrinsicISizesContribution
:
:
new
(
)
;
intrinsic_sizes_for_flow
.
union_block
(
&
intrinsic_sizes_for_inline_run
.
finish
(
)
)
;
intrinsic_sizes_for_inline_run
=
IntrinsicISizesContribution
:
:
new
(
)
;
}
}
WhiteSpace
:
:
PreWrap
|
WhiteSpace
:
:
PreLine
=
>
{
intrinsic_sizes_for_inline_run
.
union_inline
(
&
intrinsic_sizes_for_nonbroken_run
.
finish
(
)
)
;
intrinsic_sizes_for_nonbroken_run
=
IntrinsicISizesContribution
:
:
new
(
)
;
intrinsic_sizes_for_nonbroken_run
.
union_inline
(
&
intrinsic_sizes_for_fragment
)
;
if
fragment
.
requires_line_break_afterward_if_wrapping_on_newlines
(
)
{
intrinsic_sizes_for_inline_run
.
union_inline
(
&
intrinsic_sizes_for_nonbroken_run
.
finish
(
)
)
;
intrinsic_sizes_for_nonbroken_run
=
IntrinsicISizesContribution
:
:
new
(
)
;
intrinsic_sizes_for_flow
.
union_block
(
&
intrinsic_sizes_for_inline_run
.
finish
(
)
)
;
intrinsic_sizes_for_inline_run
=
IntrinsicISizesContribution
:
:
new
(
)
;
}
}
WhiteSpace
:
:
Normal
=
>
{
intrinsic_sizes_for_inline_run
.
union_inline
(
&
intrinsic_sizes_for_nonbroken_run
.
finish
(
)
)
;
intrinsic_sizes_for_nonbroken_run
=
IntrinsicISizesContribution
:
:
new
(
)
;
intrinsic_sizes_for_nonbroken_run
.
union_inline
(
&
intrinsic_sizes_for_fragment
)
;
}
}
fragment
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
BUBBLE_ISIZES
)
;
if
fragment
.
is_text_or_replaced
(
)
{
self
.
base
.
flags
.
insert
(
FlowFlags
:
:
CONTAINS_TEXT_OR_REPLACED_FRAGMENTS
)
;
}
}
intrinsic_sizes_for_inline_run
.
union_inline
(
&
intrinsic_sizes_for_nonbroken_run
.
finish
(
)
)
;
intrinsic_sizes_for_flow
.
union_block
(
&
intrinsic_sizes_for_inline_run
.
finish
(
)
)
;
self
.
base
.
intrinsic_inline_sizes
=
intrinsic_sizes_for_flow
.
finish
(
)
}
fn
assign_inline_sizes
(
&
mut
self
_
:
&
LayoutContext
)
{
let
_scope
=
layout_debug_scope
!
(
"
inline
:
:
assign_inline_sizes
{
:
x
}
"
self
.
base
.
debug_id
(
)
)
;
debug
!
(
"
InlineFlow
:
:
assign_inline_sizes
:
floats
in
:
{
:
?
}
"
self
.
base
.
floats
)
;
let
inline_size
=
self
.
base
.
block_container_inline_size
;
let
container_mode
=
self
.
base
.
block_container_writing_mode
;
let
container_block_size
=
self
.
base
.
block_container_explicit_block_size
;
self
.
base
.
position
.
size
.
inline
=
inline_size
;
{
let
this
=
&
mut
*
self
;
for
fragment
in
this
.
fragments
.
fragments
.
iter_mut
(
)
{
fragment
.
compute_border_and_padding
(
inline_size
)
;
fragment
.
compute_block_direction_margins
(
inline_size
)
;
fragment
.
compute_inline_direction_margins
(
inline_size
)
;
fragment
.
assign_replaced_inline_size_if_necessary
(
inline_size
container_block_size
)
;
}
}
let
block_container_explicit_block_size
=
self
.
base
.
block_container_explicit_block_size
;
for
kid
in
self
.
base
.
child_iter_mut
(
)
{
let
kid_base
=
kid
.
mut_base
(
)
;
kid_base
.
block_container_inline_size
=
inline_size
;
kid_base
.
block_container_writing_mode
=
container_mode
;
kid_base
.
block_container_explicit_block_size
=
block_container_explicit_block_size
;
}
}
fn
assign_block_size
(
&
mut
self
layout_context
:
&
LayoutContext
)
{
let
_scope
=
layout_debug_scope
!
(
"
inline
:
:
assign_block_size
{
:
x
}
"
self
.
base
.
debug_id
(
)
)
;
debug
!
(
"
assign_block_size_inline
:
floats
in
:
{
:
?
}
"
self
.
base
.
floats
)
;
for
fragment
in
&
mut
self
.
fragments
.
fragments
{
fragment
.
update_late_computed_replaced_inline_size_if_necessary
(
)
;
fragment
.
assign_replaced_block_size_if_necessary
(
)
;
}
self
.
lines
.
clear
(
)
;
let
mut
indentation
=
if
self
.
fragments
.
is_empty
(
)
{
Au
(
0
)
}
else
{
self
.
first_line_indentation
}
;
let
mut
scanner
=
LineBreaker
:
:
new
(
self
.
base
.
floats
.
clone
(
)
indentation
&
self
.
minimum_line_metrics
)
;
scanner
.
scan_for_lines
(
self
layout_context
)
;
let
line_count
=
self
.
lines
.
len
(
)
;
for
(
line_index
line
)
in
self
.
lines
.
iter_mut
(
)
.
enumerate
(
)
{
InlineFlow
:
:
set_inline_fragment_positions
(
&
mut
self
.
fragments
line
self
.
base
.
flags
.
text_align
(
)
indentation
line_index
+
1
=
=
line_count
)
;
InlineFlow
:
:
set_block_fragment_positions
(
&
mut
self
.
fragments
line
&
self
.
minimum_line_metrics
layout_context
)
;
indentation
=
Au
(
0
)
}
if
self
.
is_absolute_containing_block
(
)
{
let
assign_abs_b_sizes
=
AbsoluteAssignBSizesTraversal
(
layout_context
.
shared_context
(
)
)
;
assign_abs_b_sizes
.
traverse_absolute_flows
(
&
mut
*
self
)
;
}
self
.
base
.
position
.
size
.
block
=
match
self
.
last_line_containing_real_fragments
(
)
{
Some
(
last_line
)
=
>
last_line
.
bounds
.
start
.
b
+
last_line
.
bounds
.
size
.
block
None
=
>
Au
(
0
)
}
;
self
.
base
.
floats
=
scanner
.
floats
.
clone
(
)
;
let
writing_mode
=
self
.
base
.
floats
.
writing_mode
;
self
.
base
.
floats
.
translate
(
LogicalSize
:
:
new
(
writing_mode
Au
(
0
)
-
self
.
base
.
position
.
size
.
block
)
)
;
let
containing_block_size
=
LogicalSize
:
:
new
(
writing_mode
Au
(
0
)
self
.
base
.
position
.
size
.
block
)
;
self
.
mutate_fragments
(
&
mut
|
f
:
&
mut
Fragment
|
{
match
f
.
specific
{
SpecificFragmentInfo
:
:
InlineBlock
(
ref
mut
info
)
=
>
{
let
block
=
FlowRef
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
;
block
.
mut_base
(
)
.
early_absolute_position_info
=
EarlyAbsolutePositionInfo
{
relative_containing_block_size
:
containing_block_size
relative_containing_block_mode
:
writing_mode
}
;
}
SpecificFragmentInfo
:
:
InlineAbsolute
(
ref
mut
info
)
=
>
{
let
block
=
FlowRef
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
;
block
.
mut_base
(
)
.
early_absolute_position_info
=
EarlyAbsolutePositionInfo
{
relative_containing_block_size
:
containing_block_size
relative_containing_block_mode
:
writing_mode
}
;
}
_
=
>
(
)
}
}
)
;
self
.
base
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
;
for
fragment
in
&
mut
self
.
fragments
.
fragments
{
fragment
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
REFLOW_OUT_OF_FLOW
|
ServoRestyleDamage
:
:
REFLOW
)
;
}
}
fn
compute_stacking_relative_position
(
&
mut
self
_
:
&
LayoutContext
)
{
let
mut
containing_block_positions
=
Vec
:
:
new
(
)
;
let
container_size
=
Size2D
:
:
new
(
self
.
base
.
block_container_inline_size
Au
(
0
)
)
;
for
(
fragment_index
fragment
)
in
self
.
fragments
.
fragments
.
iter
(
)
.
enumerate
(
)
{
match
fragment
.
specific
{
SpecificFragmentInfo
:
:
InlineAbsolute
(
_
)
=
>
{
let
containing_block_range
=
self
.
containing_block_range_for_flow_surrounding_fragment_at_index
(
FragmentIndex
(
fragment_index
as
isize
)
)
;
let
first_fragment_index
=
containing_block_range
.
begin
(
)
.
get
(
)
as
usize
;
debug_assert
!
(
first_fragment_index
<
self
.
fragments
.
fragments
.
len
(
)
)
;
let
first_fragment
=
&
self
.
fragments
.
fragments
[
first_fragment_index
]
;
let
padding_box_origin
=
(
first_fragment
.
border_box
-
first_fragment
.
style
.
logical_border_width
(
)
)
.
start
;
containing_block_positions
.
push
(
padding_box_origin
.
to_physical
(
self
.
base
.
writing_mode
container_size
)
)
;
}
SpecificFragmentInfo
:
:
InlineBlock
(
_
)
if
fragment
.
is_positioned
(
)
=
>
{
let
containing_block_range
=
self
.
containing_block_range_for_flow_surrounding_fragment_at_index
(
FragmentIndex
(
fragment_index
as
isize
)
)
;
let
first_fragment_index
=
containing_block_range
.
begin
(
)
.
get
(
)
as
usize
;
debug_assert
!
(
first_fragment_index
<
self
.
fragments
.
fragments
.
len
(
)
)
;
let
first_fragment
=
&
self
.
fragments
.
fragments
[
first_fragment_index
]
;
let
padding_box_origin
=
(
first_fragment
.
border_box
-
first_fragment
.
style
.
logical_border_width
(
)
)
.
start
;
containing_block_positions
.
push
(
padding_box_origin
.
to_physical
(
self
.
base
.
writing_mode
container_size
)
)
;
}
_
=
>
{
}
}
}
let
mut
containing_block_positions
=
containing_block_positions
.
iter
(
)
;
for
fragment
in
&
mut
self
.
fragments
.
fragments
{
let
stacking_relative_border_box
=
fragment
.
stacking_relative_border_box
(
&
self
.
base
.
stacking_relative_position
&
self
.
base
.
early_absolute_position_info
.
relative_containing_block_size
self
.
base
.
early_absolute_position_info
.
relative_containing_block_mode
CoordinateSystem
:
:
Parent
)
;
let
stacking_relative_content_box
=
fragment
.
stacking_relative_content_box
(
&
stacking_relative_border_box
)
;
let
is_positioned
=
fragment
.
is_positioned
(
)
;
match
fragment
.
specific
{
SpecificFragmentInfo
:
:
InlineBlock
(
ref
mut
info
)
=
>
{
let
flow
=
FlowRef
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
;
let
block_flow
=
flow
.
as_mut_block
(
)
;
block_flow
.
base
.
late_absolute_position_info
=
self
.
base
.
late_absolute_position_info
;
let
stacking_relative_position
=
self
.
base
.
stacking_relative_position
;
if
is_positioned
{
let
padding_box_origin
=
containing_block_positions
.
next
(
)
.
unwrap
(
)
;
block_flow
.
base
.
late_absolute_position_info
.
stacking_relative_position_of_absolute_containing_block
=
*
padding_box_origin
+
stacking_relative_position
;
}
block_flow
.
base
.
stacking_relative_position
=
stacking_relative_content_box
.
origin
.
to_vector
(
)
;
block_flow
.
base
.
clip
=
self
.
base
.
clip
.
clone
(
)
}
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
ref
mut
info
)
=
>
{
let
flow
=
FlowRef
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
;
let
block_flow
=
flow
.
as_mut_block
(
)
;
block_flow
.
base
.
late_absolute_position_info
=
self
.
base
.
late_absolute_position_info
;
block_flow
.
base
.
stacking_relative_position
=
stacking_relative_border_box
.
origin
.
to_vector
(
)
;
block_flow
.
base
.
clip
=
self
.
base
.
clip
.
clone
(
)
}
SpecificFragmentInfo
:
:
InlineAbsolute
(
ref
mut
info
)
=
>
{
let
flow
=
FlowRef
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
;
let
block_flow
=
flow
.
as_mut_block
(
)
;
block_flow
.
base
.
late_absolute_position_info
=
self
.
base
.
late_absolute_position_info
;
let
stacking_relative_position
=
self
.
base
.
stacking_relative_position
;
let
padding_box_origin
=
containing_block_positions
.
next
(
)
.
unwrap
(
)
;
block_flow
.
base
.
late_absolute_position_info
.
stacking_relative_position_of_absolute_containing_block
=
*
padding_box_origin
+
stacking_relative_position
;
block_flow
.
base
.
stacking_relative_position
=
stacking_relative_border_box
.
origin
.
to_vector
(
)
;
block_flow
.
base
.
clip
=
self
.
base
.
clip
.
clone
(
)
}
_
=
>
{
}
}
}
}
fn
update_late_computed_inline_position_if_necessary
(
&
mut
self
_
:
Au
)
{
}
fn
update_late_computed_block_position_if_necessary
(
&
mut
self
_
:
Au
)
{
}
fn
collect_stacking_contexts
(
&
mut
self
state
:
&
mut
StackingContextCollectionState
)
{
self
.
collect_stacking_contexts_for_inline
(
state
)
;
}
fn
build_display_list
(
&
mut
self
state
:
&
mut
DisplayListBuildState
)
{
self
.
build_display_list_for_inline
(
state
)
;
}
fn
repair_style
(
&
mut
self
_
:
&
ServoArc
<
ComputedValues
>
)
{
}
fn
compute_overflow
(
&
self
)
-
>
Overflow
{
let
mut
overflow
=
Overflow
:
:
new
(
)
;
let
flow_size
=
self
.
base
.
position
.
size
.
to_physical
(
self
.
base
.
writing_mode
)
;
let
relative_containing_block_size
=
&
self
.
base
.
early_absolute_position_info
.
relative_containing_block_size
;
for
fragment
in
&
self
.
fragments
.
fragments
{
overflow
.
union
(
&
fragment
.
compute_overflow
(
&
flow_size
&
relative_containing_block_size
)
)
}
overflow
}
fn
iterate_through_fragment_border_boxes
(
&
self
iterator
:
&
mut
FragmentBorderBoxIterator
level
:
i32
stacking_context_position
:
&
Point2D
<
Au
>
)
{
for
fragment
in
&
self
.
fragments
.
fragments
{
if
!
iterator
.
should_process
(
fragment
)
{
continue
}
let
stacking_relative_position
=
&
self
.
base
.
stacking_relative_position
;
let
relative_containing_block_size
=
&
self
.
base
.
early_absolute_position_info
.
relative_containing_block_size
;
let
relative_containing_block_mode
=
self
.
base
.
early_absolute_position_info
.
relative_containing_block_mode
;
iterator
.
process
(
fragment
level
&
fragment
.
stacking_relative_border_box
(
stacking_relative_position
relative_containing_block_size
relative_containing_block_mode
CoordinateSystem
:
:
Own
)
.
translate
(
&
stacking_context_position
.
to_vector
(
)
)
)
}
}
fn
mutate_fragments
(
&
mut
self
mutator
:
&
mut
FnMut
(
&
mut
Fragment
)
)
{
for
fragment
in
&
mut
self
.
fragments
.
fragments
{
(
*
mutator
)
(
fragment
)
}
}
fn
contains_positioned_fragments
(
&
self
)
-
>
bool
{
self
.
fragments
.
fragments
.
iter
(
)
.
any
(
|
fragment
|
fragment
.
is_positioned
(
)
)
}
fn
contains_relatively_positioned_fragments
(
&
self
)
-
>
bool
{
self
.
fragments
.
fragments
.
iter
(
)
.
any
(
|
fragment
|
{
fragment
.
style
.
get_box
(
)
.
position
=
=
Position
:
:
Relative
}
)
}
fn
generated_containing_block_size
(
&
self
for_flow
:
OpaqueFlow
)
-
>
LogicalSize
<
Au
>
{
let
mut
containing_block_size
=
LogicalSize
:
:
new
(
self
.
base
.
writing_mode
Au
(
0
)
Au
(
0
)
)
;
for
index
in
self
.
containing_block_range_for_flow
(
for_flow
)
.
each_index
(
)
{
let
fragment
=
&
self
.
fragments
.
fragments
[
index
.
get
(
)
as
usize
]
;
if
fragment
.
is_absolutely_positioned
(
)
{
continue
}
containing_block_size
.
inline
=
containing_block_size
.
inline
+
fragment
.
border_box
.
size
.
inline
;
containing_block_size
.
block
=
max
(
containing_block_size
.
block
fragment
.
border_box
.
size
.
block
)
;
}
containing_block_size
}
fn
print_extra_flow_children
(
&
self
print_tree
:
&
mut
PrintTree
)
{
for
fragment
in
&
self
.
fragments
.
fragments
{
print_tree
.
add_item
(
format
!
(
"
{
:
?
}
"
fragment
)
)
;
}
}
}
impl
fmt
:
:
Debug
for
InlineFlow
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
(
{
:
x
}
)
{
:
?
}
"
self
.
class
(
)
self
.
base
.
debug_id
(
)
self
.
base
(
)
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
InlineFragmentNodeInfo
{
pub
address
:
OpaqueNode
pub
style
:
ServoArc
<
ComputedValues
>
pub
selected_style
:
ServoArc
<
ComputedValues
>
pub
pseudo
:
PseudoElementType
pub
flags
:
InlineFragmentNodeFlags
}
bitflags
!
{
pub
struct
InlineFragmentNodeFlags
:
u8
{
const
FIRST_FRAGMENT_OF_ELEMENT
=
0x01
;
const
LAST_FRAGMENT_OF_ELEMENT
=
0x02
;
}
}
impl
fmt
:
:
Debug
for
InlineFragmentNodeInfo
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
"
self
.
flags
.
bits
(
)
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
InlineFragmentContext
{
pub
nodes
:
Vec
<
InlineFragmentNodeInfo
>
}
impl
InlineFragmentContext
{
pub
fn
new
(
)
-
>
InlineFragmentContext
{
InlineFragmentContext
{
nodes
:
vec
!
(
)
}
}
#
[
inline
]
pub
fn
contains_node
(
&
self
node_address
:
OpaqueNode
)
-
>
bool
{
self
.
nodes
.
iter
(
)
.
position
(
|
node
|
node
.
address
=
=
node_address
)
.
is_some
(
)
}
fn
ptr_eq
(
&
self
other
:
&
InlineFragmentContext
)
-
>
bool
{
if
self
.
nodes
.
len
(
)
!
=
other
.
nodes
.
len
(
)
{
return
false
}
for
(
this_node
other_node
)
in
self
.
nodes
.
iter
(
)
.
zip
(
&
other
.
nodes
)
{
if
this_node
.
address
!
=
other_node
.
address
{
return
false
}
}
true
}
}
fn
inline_contexts_are_equal
(
inline_context_a
:
&
Option
<
InlineFragmentContext
>
inline_context_b
:
&
Option
<
InlineFragmentContext
>
)
-
>
bool
{
match
(
inline_context_a
inline_context_b
)
{
(
&
Some
(
ref
inline_context_a
)
&
Some
(
ref
inline_context_b
)
)
=
>
{
inline_context_a
.
ptr_eq
(
inline_context_b
)
}
(
&
None
&
None
)
=
>
true
(
&
Some
(
_
)
&
None
)
|
(
&
None
&
Some
(
_
)
)
=
>
false
}
}
#
[
derive
(
Clone
Copy
Debug
Serialize
)
]
pub
struct
InlineMetrics
{
pub
space_above_baseline
:
Au
pub
space_below_baseline
:
Au
pub
ascent
:
Au
}
impl
InlineMetrics
{
pub
fn
new
(
space_above_baseline
:
Au
space_below_baseline
:
Au
ascent
:
Au
)
-
>
InlineMetrics
{
InlineMetrics
{
space_above_baseline
:
space_above_baseline
space_below_baseline
:
space_below_baseline
ascent
:
ascent
}
}
#
[
inline
]
pub
fn
from_font_metrics
(
font_metrics
:
&
FontMetrics
line_height
:
Au
)
-
>
InlineMetrics
{
let
leading
=
line_height
-
(
font_metrics
.
ascent
+
font_metrics
.
descent
)
;
let
half_leading
=
leading
.
scale_by
(
0
.
5
)
;
InlineMetrics
{
space_above_baseline
:
font_metrics
.
ascent
+
half_leading
space_below_baseline
:
font_metrics
.
descent
+
leading
-
half_leading
ascent
:
font_metrics
.
ascent
}
}
fn
space_needed
(
&
self
)
-
>
Au
{
self
.
space_above_baseline
+
self
.
space_below_baseline
}
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
enum
LineFlushMode
{
No
Flush
}
#
[
derive
(
Clone
Copy
Debug
Serialize
)
]
pub
struct
LineMetrics
{
pub
space_above_baseline
:
Au
pub
space_below_baseline
:
Au
}
impl
LineMetrics
{
pub
fn
new
(
space_above_baseline
:
Au
space_below_baseline
:
Au
)
-
>
LineMetrics
{
LineMetrics
{
space_above_baseline
:
space_above_baseline
space_below_baseline
:
space_below_baseline
}
}
fn
new_metrics_for_fragment
(
&
self
fragment_inline_metrics
:
&
InlineMetrics
)
-
>
LineMetrics
{
LineMetrics
{
space_above_baseline
:
max
(
self
.
space_above_baseline
fragment_inline_metrics
.
space_above_baseline
)
space_below_baseline
:
max
(
self
.
space_below_baseline
fragment_inline_metrics
.
space_below_baseline
)
}
}
fn
for_line_and_fragment
(
line
:
&
Line
fragment
:
&
Fragment
layout_context
:
&
LayoutContext
)
-
>
LineMetrics
{
if
!
fragment
.
is_hypothetical
(
)
{
let
space_above_baseline
=
line
.
metrics
.
space_above_baseline
;
return
LineMetrics
{
space_above_baseline
:
space_above_baseline
space_below_baseline
:
line
.
bounds
.
size
.
block
-
space_above_baseline
}
}
let
hypothetical_line_metrics
=
line
.
new_metrics_for_fragment
(
fragment
layout_context
)
;
let
hypothetical_block_size
=
line
.
new_block_size_for_fragment
(
fragment
&
hypothetical_line_metrics
layout_context
)
;
let
hypothetical_space_above_baseline
=
hypothetical_line_metrics
.
space_above_baseline
;
LineMetrics
{
space_above_baseline
:
hypothetical_space_above_baseline
space_below_baseline
:
hypothetical_block_size
-
hypothetical_space_above_baseline
}
}
pub
fn
space_needed
(
&
self
)
-
>
Au
{
self
.
space_above_baseline
+
self
.
space_below_baseline
}
}
