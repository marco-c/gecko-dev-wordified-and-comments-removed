#
!
[
deny
(
unsafe_blocks
)
]
use
css
:
:
node_style
:
:
StyledNode
;
use
context
:
:
LayoutContext
;
use
display_list_builder
:
:
{
BackgroundAndBorderLevel
DisplayListBuildingResult
FragmentDisplayListBuilding
}
;
use
floats
:
:
{
FloatKind
Floats
PlacementInfo
}
;
use
flow
:
:
{
BaseFlow
FlowClass
Flow
MutableFlowUtils
ForceNonfloatedFlag
}
;
use
flow
:
:
{
IS_ABSOLUTELY_POSITIONED
}
;
use
flow
;
use
fragment
:
:
{
Fragment
SpecificFragmentInfo
}
;
use
fragment
:
:
{
FragmentBoundsIterator
ScannedTextFragmentInfo
}
;
use
fragment
:
:
SplitInfo
;
use
incremental
:
:
{
REFLOW
REFLOW_OUT_OF_FLOW
}
;
use
layout_debug
;
use
model
:
:
IntrinsicISizesContribution
;
use
text
;
use
collections
:
:
{
RingBuf
}
;
use
geom
:
:
Size2D
;
use
gfx
:
:
display_list
:
:
DisplayList
;
use
gfx
:
:
font
:
:
FontMetrics
;
use
gfx
:
:
font_context
:
:
FontContext
;
use
gfx
:
:
text
:
:
glyph
:
:
CharIndex
;
use
servo_util
:
:
geometry
:
:
Au
;
use
servo_util
:
:
logical_geometry
:
:
{
LogicalRect
LogicalSize
WritingMode
}
;
use
servo_util
:
:
opts
;
use
servo_util
:
:
range
:
:
{
IntRangeIndex
Range
RangeIndex
}
;
use
servo_util
:
:
arc_ptr_eq
;
use
std
:
:
cmp
:
:
max
;
use
std
:
:
fmt
;
use
std
:
:
mem
;
use
std
:
:
num
;
use
std
:
:
u16
;
use
style
:
:
computed_values
:
:
{
text_align
vertical_align
white_space
}
;
use
style
:
:
ComputedValues
;
use
sync
:
:
Arc
;
static
FONT_SUBSCRIPT_OFFSET_RATIO
:
f64
=
0
.
20
;
static
FONT_SUPERSCRIPT_OFFSET_RATIO
:
f64
=
0
.
34
;
#
[
deriving
(
Encodable
Show
)
]
pub
struct
Line
{
pub
range
:
Range
<
FragmentIndex
>
pub
bounds
:
LogicalRect
<
Au
>
pub
green_zone
:
LogicalSize
<
Au
>
}
int_range_index
!
{
#
[
deriving
(
Encodable
)
]
#
[
doc
=
"
The
index
of
a
fragment
in
a
flattened
vector
of
DOM
elements
.
"
]
struct
FragmentIndex
(
int
)
}
bitflags
!
{
flags
InlineReflowFlags
:
u8
{
#
[
doc
=
"
The
white
-
space
:
nowrap
property
from
CSS
2
.
1
16
.
6
is
in
effect
.
"
]
const
NO_WRAP_INLINE_REFLOW_FLAG
=
0x01
}
}
struct
LineBreaker
{
floats
:
Floats
new_fragments
:
Vec
<
Fragment
>
work_list
:
RingBuf
<
Fragment
>
pending_line
:
Line
lines
:
Vec
<
Line
>
cur_b
:
Au
first_line_indentation
:
Au
}
impl
LineBreaker
{
fn
new
(
float_context
:
Floats
first_line_indentation
:
Au
)
-
>
LineBreaker
{
LineBreaker
{
new_fragments
:
Vec
:
:
new
(
)
work_list
:
RingBuf
:
:
new
(
)
pending_line
:
Line
{
range
:
Range
:
:
empty
(
)
bounds
:
LogicalRect
:
:
zero
(
float_context
.
writing_mode
)
green_zone
:
LogicalSize
:
:
zero
(
float_context
.
writing_mode
)
}
floats
:
float_context
lines
:
Vec
:
:
new
(
)
cur_b
:
Au
(
0
)
first_line_indentation
:
first_line_indentation
}
}
fn
reset_scanner
(
&
mut
self
)
{
self
.
lines
=
Vec
:
:
new
(
)
;
self
.
new_fragments
=
Vec
:
:
new
(
)
;
self
.
cur_b
=
Au
(
0
)
;
self
.
reset_line
(
)
;
}
fn
reset_line
(
&
mut
self
)
{
self
.
pending_line
.
range
.
reset
(
num
:
:
zero
(
)
num
:
:
zero
(
)
)
;
self
.
pending_line
.
bounds
=
LogicalRect
:
:
new
(
self
.
floats
.
writing_mode
Au
(
0
)
self
.
cur_b
Au
(
0
)
Au
(
0
)
)
;
self
.
pending_line
.
green_zone
=
LogicalSize
:
:
zero
(
self
.
floats
.
writing_mode
)
}
fn
scan_for_lines
(
&
mut
self
flow
:
&
mut
InlineFlow
layout_context
:
&
LayoutContext
)
{
self
.
reset_scanner
(
)
;
debug
!
(
"
LineBreaker
:
scanning
for
lines
{
}
fragments
"
flow
.
fragments
.
len
(
)
)
;
let
mut
old_fragments
=
mem
:
:
replace
(
&
mut
flow
.
fragments
InlineFragments
:
:
new
(
)
)
;
let
mut
old_fragment_iter
=
old_fragments
.
fragments
.
into_iter
(
)
;
self
.
lines
=
mem
:
:
replace
(
&
mut
flow
.
lines
Vec
:
:
new
(
)
)
;
match
self
.
lines
.
as_slice
(
)
.
last
(
)
{
None
=
>
{
}
Some
(
last_line
)
=
>
{
for
_
in
range
(
FragmentIndex
(
0
)
last_line
.
range
.
end
(
)
)
{
self
.
new_fragments
.
push
(
old_fragment_iter
.
next
(
)
.
unwrap
(
)
)
}
}
}
self
.
reflow_fragments
(
old_fragment_iter
flow
layout_context
)
;
old_fragments
.
fragments
=
mem
:
:
replace
(
&
mut
self
.
new_fragments
vec
!
[
]
)
;
flow
.
fragments
=
old_fragments
;
flow
.
lines
=
mem
:
:
replace
(
&
mut
self
.
lines
Vec
:
:
new
(
)
)
;
}
fn
reflow_fragments
<
'
a
I
>
(
&
mut
self
mut
old_fragment_iter
:
I
flow
:
&
'
a
InlineFlow
layout_context
:
&
LayoutContext
)
where
I
:
Iterator
<
Fragment
>
{
loop
{
let
fragment
=
match
self
.
next_unbroken_fragment
(
&
mut
old_fragment_iter
)
{
None
=
>
break
Some
(
fragment
)
=
>
fragment
}
;
let
flags
=
match
fragment
.
style
(
)
.
get_inheritedtext
(
)
.
white_space
{
white_space
:
:
normal
=
>
InlineReflowFlags
:
:
empty
(
)
white_space
:
:
pre
|
white_space
:
:
nowrap
=
>
NO_WRAP_INLINE_REFLOW_FLAG
}
;
match
fragment
.
style
(
)
.
get_inheritedtext
(
)
.
white_space
{
white_space
:
:
normal
|
white_space
:
:
nowrap
=
>
{
if
!
self
.
append_fragment_to_line_if_possible
(
fragment
flow
layout_context
flags
)
{
self
.
flush_current_line
(
)
}
}
white_space
:
:
pre
=
>
{
if
!
self
.
try_append_to_line_by_new_line
(
fragment
)
{
self
.
flush_current_line
(
)
}
}
}
}
if
!
self
.
pending_line_is_empty
(
)
{
debug
!
(
"
LineBreaker
:
partially
full
line
{
}
at
end
of
scanning
;
committing
it
"
self
.
lines
.
len
(
)
)
;
self
.
flush_current_line
(
)
}
}
fn
next_fragment
<
I
>
(
&
mut
self
old_fragment_iter
:
&
mut
I
)
-
>
Option
<
Fragment
>
where
I
:
Iterator
<
Fragment
>
{
if
self
.
work_list
.
is_empty
(
)
{
return
match
old_fragment_iter
.
next
(
)
{
None
=
>
None
Some
(
fragment
)
=
>
{
debug
!
(
"
LineBreaker
:
working
with
fragment
from
flow
:
{
}
"
fragment
)
;
Some
(
fragment
)
}
}
}
debug
!
(
"
LineBreaker
:
working
with
fragment
from
work
list
:
{
}
"
self
.
work_list
.
front
(
)
)
;
self
.
work_list
.
pop_front
(
)
}
fn
next_unbroken_fragment
<
I
>
(
&
mut
self
old_fragment_iter
:
&
mut
I
)
-
>
Option
<
Fragment
>
where
I
:
Iterator
<
Fragment
>
{
let
mut
result
=
match
self
.
next_fragment
(
old_fragment_iter
)
{
None
=
>
return
None
Some
(
fragment
)
=
>
fragment
}
;
loop
{
result
.
restore_new_line_pos
(
)
;
let
candidate
=
match
self
.
next_fragment
(
old_fragment_iter
)
{
None
=
>
return
Some
(
result
)
Some
(
fragment
)
=
>
fragment
}
;
let
need_to_merge
=
match
(
&
mut
result
.
specific
&
candidate
.
specific
)
{
(
&
SpecificFragmentInfo
:
:
ScannedText
(
ref
mut
result_info
)
&
SpecificFragmentInfo
:
:
ScannedText
(
ref
candidate_info
)
)
if
arc_ptr_eq
(
&
result_info
.
run
&
candidate_info
.
run
)
&
&
result_info
.
range
.
end
(
)
+
CharIndex
(
1
)
=
=
candidate_info
.
range
.
begin
(
)
=
>
{
result_info
.
range
.
extend_by
(
candidate_info
.
range
.
length
(
)
+
CharIndex
(
1
)
)
;
true
}
_
=
>
false
}
;
if
!
need_to_merge
{
self
.
work_list
.
push_front
(
candidate
)
;
return
Some
(
result
)
}
}
}
fn
flush_current_line
(
&
mut
self
)
{
debug
!
(
"
LineBreaker
:
flushing
line
{
}
:
{
}
"
self
.
lines
.
len
(
)
self
.
pending_line
)
;
self
.
lines
.
push
(
self
.
pending_line
)
;
self
.
cur_b
=
self
.
pending_line
.
bounds
.
start
.
b
+
self
.
pending_line
.
bounds
.
size
.
block
;
self
.
reset_line
(
)
;
}
fn
new_block_size_for_line
(
&
self
new_fragment
:
&
Fragment
layout_context
:
&
LayoutContext
)
-
>
Au
{
let
fragment_block_size
=
new_fragment
.
content_block_size
(
layout_context
)
;
if
fragment_block_size
>
self
.
pending_line
.
bounds
.
size
.
block
{
fragment_block_size
}
else
{
self
.
pending_line
.
bounds
.
size
.
block
}
}
fn
initial_line_placement
(
&
self
flow
:
&
InlineFlow
first_fragment
:
&
Fragment
ceiling
:
Au
)
-
>
(
LogicalRect
<
Au
>
Au
)
{
debug
!
(
"
LineBreaker
:
trying
to
place
first
fragment
of
line
{
}
;
fragment
size
:
{
}
\
splittable
:
{
}
"
self
.
lines
.
len
(
)
first_fragment
.
border_box
.
size
first_fragment
.
can_split
(
)
)
;
let
placement_inline_size
=
if
first_fragment
.
can_split
(
)
{
Au
(
0
)
}
else
{
first_fragment
.
border_box
.
size
.
inline
+
self
.
indentation_for_pending_fragment
(
)
}
;
let
line_bounds
=
self
.
floats
.
place_between_floats
(
&
PlacementInfo
{
size
:
LogicalSize
:
:
new
(
self
.
floats
.
writing_mode
placement_inline_size
first_fragment
.
border_box
.
size
.
block
)
ceiling
:
ceiling
max_inline_size
:
flow
.
base
.
position
.
size
.
inline
kind
:
FloatKind
:
:
Left
}
)
;
if
line_bounds
.
size
.
inline
>
first_fragment
.
border_box
.
size
.
inline
{
debug
!
(
"
LineBreaker
:
fragment
fits
on
line
{
}
"
self
.
lines
.
len
(
)
)
;
return
(
line_bounds
first_fragment
.
border_box
.
size
.
inline
)
;
}
if
!
first_fragment
.
can_split
(
)
{
debug
!
(
"
LineBreaker
:
line
doesn
'
t
fit
but
is
unsplittable
"
)
;
}
(
line_bounds
first_fragment
.
border_box
.
size
.
inline
)
}
fn
avoid_floats
(
&
mut
self
flow
:
&
InlineFlow
in_fragment
:
Fragment
new_block_size
:
Au
)
-
>
bool
{
debug
!
(
"
LineBreaker
:
entering
float
collision
avoider
!
"
)
;
let
(
next_line
first_fragment_inline_size
)
=
self
.
initial_line_placement
(
flow
&
in_fragment
self
.
pending_line
.
bounds
.
start
.
b
)
;
let
next_green_zone
=
next_line
.
size
;
let
new_inline_size
=
self
.
pending_line
.
bounds
.
size
.
inline
+
first_fragment_inline_size
;
if
next_green_zone
.
inline
>
=
new_inline_size
&
&
next_green_zone
.
block
>
=
new_block_size
{
debug
!
(
"
LineBreaker
:
case
=
adding
fragment
collides
vertically
with
floats
:
moving
\
line
"
)
;
self
.
pending_line
.
bounds
.
start
=
next_line
.
start
;
self
.
pending_line
.
green_zone
=
next_green_zone
;
debug_assert
!
(
!
self
.
pending_line_is_empty
(
)
"
Non
-
terminating
line
breaking
"
)
;
self
.
work_list
.
push_front
(
in_fragment
)
;
return
true
}
debug
!
(
"
LineBreaker
:
case
=
adding
fragment
collides
vertically
with
floats
:
breaking
line
"
)
;
self
.
work_list
.
push_front
(
in_fragment
)
;
false
}
fn
try_append_to_line_by_new_line
(
&
mut
self
in_fragment
:
Fragment
)
-
>
bool
{
let
should_push
=
match
in_fragment
.
newline_positions
(
)
{
None
=
>
true
Some
(
ref
positions
)
=
>
positions
.
is_empty
(
)
}
;
if
should_push
{
debug
!
(
"
LineBreaker
:
did
not
find
a
newline
character
;
pushing
the
fragment
to
\
the
line
without
splitting
"
)
;
self
.
push_fragment_to_line
(
in_fragment
)
;
return
true
}
debug
!
(
"
LineBreaker
:
Found
a
new
-
line
character
so
splitting
the
line
.
"
)
;
let
(
inline_start
inline_end
run
)
=
in_fragment
.
find_split_info_by_new_line
(
)
.
expect
(
"
LineBreaker
:
this
split
case
makes
no
sense
!
"
)
;
let
writing_mode
=
self
.
floats
.
writing_mode
;
let
split_fragment
=
|
split
:
SplitInfo
|
{
let
info
=
box
ScannedTextFragmentInfo
:
:
new
(
run
.
clone
(
)
split
.
range
(
*
in_fragment
.
newline_positions
(
)
.
unwrap
(
)
)
.
clone
(
)
in_fragment
.
border_box
.
size
)
;
let
size
=
LogicalSize
:
:
new
(
writing_mode
split
.
inline_size
in_fragment
.
border_box
.
size
.
block
)
;
in_fragment
.
transform
(
size
info
)
}
;
debug
!
(
"
LineBreaker
:
Pushing
the
fragment
to
the
inline_start
of
the
new
-
line
character
\
to
the
line
.
"
)
;
let
mut
inline_start
=
split_fragment
(
inline_start
)
;
inline_start
.
save_new_line_pos
(
)
;
*
inline_start
.
newline_positions_mut
(
)
.
unwrap
(
)
=
vec
!
[
]
;
self
.
push_fragment_to_line
(
inline_start
)
;
for
inline_end
in
inline_end
.
into_iter
(
)
{
debug
!
(
"
LineBreaker
:
Deferring
the
fragment
to
the
inline_end
of
the
new
-
line
\
character
to
the
line
.
"
)
;
let
mut
inline_end
=
split_fragment
(
inline_end
)
;
inline_end
.
newline_positions_mut
(
)
.
unwrap
(
)
.
remove
(
0
)
;
self
.
work_list
.
push_front
(
inline_end
)
;
}
false
}
fn
append_fragment_to_line_if_possible
(
&
mut
self
fragment
:
Fragment
flow
:
&
InlineFlow
layout_context
:
&
LayoutContext
flags
:
InlineReflowFlags
)
-
>
bool
{
if
self
.
pending_line_is_empty
(
)
{
let
(
line_bounds
_
)
=
self
.
initial_line_placement
(
flow
&
fragment
self
.
cur_b
)
;
self
.
pending_line
.
bounds
.
start
=
line_bounds
.
start
;
self
.
pending_line
.
green_zone
=
line_bounds
.
size
;
}
debug
!
(
"
LineBreaker
:
trying
to
append
to
line
{
}
(
fragment
size
:
{
}
green
zone
:
{
}
)
:
{
}
"
self
.
lines
.
len
(
)
fragment
.
border_box
.
size
self
.
pending_line
.
green_zone
fragment
)
;
let
green_zone
=
self
.
pending_line
.
green_zone
;
let
new_block_size
=
self
.
new_block_size_for_line
(
&
fragment
layout_context
)
;
if
new_block_size
>
green_zone
.
block
{
return
self
.
avoid_floats
(
flow
fragment
new_block_size
)
}
let
indentation
=
self
.
indentation_for_pending_fragment
(
)
;
let
new_inline_size
=
self
.
pending_line
.
bounds
.
size
.
inline
+
fragment
.
border_box
.
size
.
inline
+
indentation
;
if
new_inline_size
<
=
green_zone
.
inline
{
debug
!
(
"
LineBreaker
:
fragment
fits
without
splitting
"
)
;
self
.
push_fragment_to_line
(
fragment
)
;
return
true
}
if
(
!
fragment
.
can_split
(
)
&
&
self
.
pending_line_is_empty
(
)
)
|
|
flags
.
contains
(
NO_WRAP_INLINE_REFLOW_FLAG
)
{
debug
!
(
"
LineBreaker
:
fragment
can
'
t
split
and
line
{
}
is
empty
so
overflowing
"
self
.
lines
.
len
(
)
)
;
self
.
push_fragment_to_line
(
fragment
)
;
return
true
}
let
available_inline_size
=
green_zone
.
inline
-
self
.
pending_line
.
bounds
.
size
.
inline
-
indentation
;
let
(
inline_start_fragment
inline_end_fragment
)
=
match
fragment
.
calculate_split_position
(
available_inline_size
self
.
pending_line_is_empty
(
)
)
{
None
=
>
{
debug
!
(
"
LineBreaker
:
fragment
was
unsplittable
;
deferring
to
next
line
:
{
}
"
fragment
)
;
self
.
work_list
.
push_front
(
fragment
)
;
return
false
}
Some
(
split_result
)
=
>
{
let
split_fragment
=
|
split
:
SplitInfo
|
{
let
info
=
box
ScannedTextFragmentInfo
:
:
new
(
split_result
.
text_run
.
clone
(
)
split
.
range
Vec
:
:
new
(
)
fragment
.
border_box
.
size
)
;
let
size
=
LogicalSize
:
:
new
(
self
.
floats
.
writing_mode
split
.
inline_size
fragment
.
border_box
.
size
.
block
)
;
fragment
.
transform
(
size
info
)
}
;
(
split_result
.
inline_start
.
map
(
|
x
|
split_fragment
(
x
)
)
split_result
.
inline_end
.
map
(
|
x
|
split_fragment
(
x
)
)
)
}
}
;
match
(
inline_start_fragment
inline_end_fragment
)
{
(
Some
(
inline_start_fragment
)
Some
(
inline_end_fragment
)
)
=
>
{
self
.
push_fragment_to_line
(
inline_start_fragment
)
;
self
.
work_list
.
push_front
(
inline_end_fragment
)
}
(
Some
(
fragment
)
None
)
|
(
None
Some
(
fragment
)
)
=
>
{
self
.
push_fragment_to_line
(
fragment
)
}
(
None
None
)
=
>
{
}
}
true
}
fn
push_fragment_to_line
(
&
mut
self
fragment
:
Fragment
)
{
let
indentation
=
self
.
indentation_for_pending_fragment
(
)
;
if
self
.
pending_line_is_empty
(
)
{
assert
!
(
self
.
new_fragments
.
len
(
)
<
=
(
u16
:
:
MAX
as
uint
)
)
;
self
.
pending_line
.
range
.
reset
(
FragmentIndex
(
self
.
new_fragments
.
len
(
)
as
int
)
num
:
:
zero
(
)
)
;
}
self
.
pending_line
.
range
.
extend_by
(
FragmentIndex
(
1
)
)
;
self
.
pending_line
.
bounds
.
size
.
inline
=
self
.
pending_line
.
bounds
.
size
.
inline
+
fragment
.
border_box
.
size
.
inline
+
indentation
;
self
.
pending_line
.
bounds
.
size
.
block
=
max
(
self
.
pending_line
.
bounds
.
size
.
block
fragment
.
border_box
.
size
.
block
)
;
self
.
new_fragments
.
push
(
fragment
)
;
}
fn
indentation_for_pending_fragment
(
&
self
)
-
>
Au
{
if
self
.
pending_line_is_empty
(
)
&
&
self
.
lines
.
is_empty
(
)
{
self
.
first_line_indentation
}
else
{
Au
(
0
)
}
}
fn
pending_line_is_empty
(
&
self
)
-
>
bool
{
self
.
pending_line
.
range
.
length
(
)
=
=
num
:
:
zero
(
)
}
}
#
[
deriving
(
Encodable
Clone
)
]
pub
struct
InlineFragments
{
pub
fragments
:
Vec
<
Fragment
>
}
impl
fmt
:
:
Show
for
InlineFragments
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
fragments
)
}
}
impl
InlineFragments
{
pub
fn
new
(
)
-
>
InlineFragments
{
InlineFragments
{
fragments
:
vec
!
[
]
}
}
pub
fn
len
(
&
self
)
-
>
uint
{
self
.
fragments
.
len
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
fragments
.
is_empty
(
)
}
pub
fn
push
(
&
mut
self
fragment
:
&
mut
Fragment
)
{
self
.
fragments
.
push
(
fragment
.
clone
(
)
)
;
}
pub
fn
push_all
(
&
mut
self
fragments
:
InlineFragments
)
{
self
.
fragments
.
extend
(
fragments
.
fragments
.
into_iter
(
)
)
;
}
pub
fn
get
<
'
a
>
(
&
'
a
self
index
:
uint
)
-
>
&
'
a
Fragment
{
&
self
.
fragments
[
index
]
}
pub
fn
get_mut
<
'
a
>
(
&
'
a
mut
self
index
:
uint
)
-
>
&
'
a
mut
Fragment
{
&
mut
self
.
fragments
[
index
]
}
}
#
[
deriving
(
Encodable
)
]
pub
struct
InlineFlow
{
pub
base
:
BaseFlow
pub
fragments
:
InlineFragments
pub
lines
:
Vec
<
Line
>
pub
minimum_block_size_above_baseline
:
Au
pub
minimum_depth_below_baseline
:
Au
pub
first_line_indentation
:
Au
}
impl
InlineFlow
{
pub
fn
from_fragments
(
fragments
:
InlineFragments
writing_mode
:
WritingMode
)
-
>
InlineFlow
{
InlineFlow
{
base
:
BaseFlow
:
:
new
(
None
writing_mode
ForceNonfloatedFlag
:
:
ForceNonfloated
)
fragments
:
fragments
lines
:
Vec
:
:
new
(
)
minimum_block_size_above_baseline
:
Au
(
0
)
minimum_depth_below_baseline
:
Au
(
0
)
first_line_indentation
:
Au
(
0
)
}
}
fn
distance_from_baseline
(
fragment
:
&
Fragment
ascent
:
Au
parent_text_block_start
:
Au
parent_text_block_end
:
Au
block_size_above_baseline
:
&
mut
Au
depth_below_baseline
:
&
mut
Au
largest_block_size_for_top_fragments
:
&
mut
Au
largest_block_size_for_bottom_fragments
:
&
mut
Au
layout_context
:
&
LayoutContext
)
-
>
(
Au
bool
)
{
match
fragment
.
vertical_align
(
)
{
vertical_align
:
:
baseline
=
>
(
-
ascent
false
)
vertical_align
:
:
middle
=
>
{
(
-
ascent
false
)
}
vertical_align
:
:
sub
=
>
{
let
sub_offset
=
(
parent_text_block_start
+
parent_text_block_end
)
.
scale_by
(
FONT_SUBSCRIPT_OFFSET_RATIO
)
;
(
sub_offset
-
ascent
false
)
}
vertical_align
:
:
super_
=
>
{
let
super_offset
=
(
parent_text_block_start
+
parent_text_block_end
)
.
scale_by
(
FONT_SUPERSCRIPT_OFFSET_RATIO
)
;
(
-
super_offset
-
ascent
false
)
}
vertical_align
:
:
text_top
=
>
{
let
fragment_block_size
=
*
block_size_above_baseline
+
*
depth_below_baseline
;
let
prev_depth_below_baseline
=
*
depth_below_baseline
;
*
block_size_above_baseline
=
parent_text_block_start
;
*
depth_below_baseline
=
fragment_block_size
-
*
block_size_above_baseline
;
(
*
depth_below_baseline
-
prev_depth_below_baseline
-
ascent
false
)
}
vertical_align
:
:
text_bottom
=
>
{
let
fragment_block_size
=
*
block_size_above_baseline
+
*
depth_below_baseline
;
let
prev_depth_below_baseline
=
*
depth_below_baseline
;
*
depth_below_baseline
=
parent_text_block_end
;
*
block_size_above_baseline
=
fragment_block_size
-
*
depth_below_baseline
;
(
*
depth_below_baseline
-
prev_depth_below_baseline
-
ascent
false
)
}
vertical_align
:
:
top
=
>
{
*
largest_block_size_for_top_fragments
=
max
(
*
largest_block_size_for_top_fragments
*
block_size_above_baseline
+
*
depth_below_baseline
)
;
let
offset_top
=
*
block_size_above_baseline
-
ascent
;
(
offset_top
true
)
}
vertical_align
:
:
bottom
=
>
{
*
largest_block_size_for_bottom_fragments
=
max
(
*
largest_block_size_for_bottom_fragments
*
block_size_above_baseline
+
*
depth_below_baseline
)
;
let
offset_bottom
=
-
(
*
depth_below_baseline
+
ascent
)
;
(
offset_bottom
true
)
}
vertical_align
:
:
Length
(
length
)
=
>
(
-
(
length
+
ascent
)
false
)
vertical_align
:
:
Percentage
(
p
)
=
>
{
let
line_height
=
fragment
.
calculate_line_height
(
layout_context
)
;
let
percent_offset
=
line_height
.
scale_by
(
p
)
;
(
-
(
percent_offset
+
ascent
)
false
)
}
}
}
fn
set_inline_fragment_positions
(
fragments
:
&
mut
InlineFragments
line
:
&
Line
line_align
:
text_align
:
:
T
indentation
:
Au
)
{
let
slack_inline_size
=
max
(
Au
(
0
)
line
.
green_zone
.
inline
-
line
.
bounds
.
size
.
inline
)
;
let
mut
inline_start_position_for_fragment
=
line
.
bounds
.
start
.
i
+
indentation
+
match
line_align
{
text_align
:
:
left
|
text_align
:
:
justify
=
>
Au
(
0
)
text_align
:
:
center
=
>
slack_inline_size
.
scale_by
(
0
.
5
)
text_align
:
:
right
=
>
slack_inline_size
}
;
for
fragment_index
in
range
(
line
.
range
.
begin
(
)
line
.
range
.
end
(
)
)
{
let
fragment
=
fragments
.
get_mut
(
fragment_index
.
to_uint
(
)
)
;
let
size
=
fragment
.
border_box
.
size
;
fragment
.
border_box
=
LogicalRect
:
:
new
(
fragment
.
style
.
writing_mode
inline_start_position_for_fragment
fragment
.
border_box
.
start
.
b
size
.
inline
size
.
block
)
;
fragment
.
update_late_computed_inline_position_if_necessary
(
)
;
inline_start_position_for_fragment
=
inline_start_position_for_fragment
+
size
.
inline
;
}
}
fn
set_block_fragment_positions
(
fragments
:
&
mut
InlineFragments
line
:
&
Line
line_distance_from_flow_block_start
:
Au
baseline_distance_from_block_start
:
Au
largest_depth_below_baseline
:
Au
)
{
for
fragment_index
in
range
(
line
.
range
.
begin
(
)
line
.
range
.
end
(
)
)
{
let
fragment
=
fragments
.
get_mut
(
fragment_index
.
to_uint
(
)
)
;
match
fragment
.
vertical_align
(
)
{
vertical_align
:
:
top
=
>
{
fragment
.
border_box
.
start
.
b
=
fragment
.
border_box
.
start
.
b
+
line_distance_from_flow_block_start
}
vertical_align
:
:
bottom
=
>
{
fragment
.
border_box
.
start
.
b
=
fragment
.
border_box
.
start
.
b
+
line_distance_from_flow_block_start
+
baseline_distance_from_block_start
+
largest_depth_below_baseline
}
_
=
>
{
fragment
.
border_box
.
start
.
b
=
fragment
.
border_box
.
start
.
b
+
line_distance_from_flow_block_start
+
baseline_distance_from_block_start
}
}
fragment
.
update_late_computed_block_position_if_necessary
(
)
;
}
}
pub
fn
compute_minimum_ascent_and_descent
(
&
self
font_context
:
&
mut
FontContext
style
:
&
ComputedValues
)
-
>
(
Au
Au
)
{
if
self
.
fragments
.
fragments
.
iter
(
)
.
all
(
|
fragment
|
fragment
.
is_hypothetical
(
)
)
{
return
(
Au
(
0
)
Au
(
0
)
)
}
let
font_style
=
style
.
get_font_arc
(
)
;
let
font_metrics
=
text
:
:
font_metrics_for_style
(
font_context
font_style
)
;
let
line_height
=
text
:
:
line_height_from_style
(
style
&
font_metrics
)
;
let
inline_metrics
=
InlineMetrics
:
:
from_font_metrics
(
&
font_metrics
line_height
)
;
let
mut
block_size_above_baseline
=
inline_metrics
.
block_size_above_baseline
;
let
mut
depth_below_baseline
=
inline_metrics
.
depth_below_baseline
;
for
frag
in
self
.
fragments
.
fragments
.
iter
(
)
{
match
frag
.
inline_context
{
Some
(
ref
inline_context
)
=
>
{
for
style
in
inline_context
.
styles
.
iter
(
)
{
let
font_style
=
style
.
get_font_arc
(
)
;
let
font_metrics
=
text
:
:
font_metrics_for_style
(
font_context
font_style
)
;
let
line_height
=
text
:
:
line_height_from_style
(
&
*
*
style
&
font_metrics
)
;
let
inline_metrics
=
InlineMetrics
:
:
from_font_metrics
(
&
font_metrics
line_height
)
;
block_size_above_baseline
=
max
(
block_size_above_baseline
inline_metrics
.
block_size_above_baseline
)
;
depth_below_baseline
=
max
(
depth_below_baseline
inline_metrics
.
depth_below_baseline
)
;
}
}
None
=
>
{
}
}
}
(
block_size_above_baseline
depth_below_baseline
)
}
fn
update_restyle_damage
(
&
mut
self
)
{
let
mut
damage
=
self
.
base
.
restyle_damage
;
for
frag
in
self
.
fragments
.
fragments
.
iter
(
)
{
damage
.
insert
(
frag
.
restyle_damage
(
)
)
;
}
self
.
base
.
restyle_damage
=
damage
;
}
}
impl
Flow
for
InlineFlow
{
fn
class
(
&
self
)
-
>
FlowClass
{
FlowClass
:
:
Inline
}
fn
as_immutable_inline
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
InlineFlow
{
self
}
fn
as_inline
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
InlineFlow
{
self
}
fn
bubble_inline_sizes
(
&
mut
self
)
{
self
.
update_restyle_damage
(
)
;
let
_scope
=
layout_debug_scope
!
(
"
inline
:
:
bubble_inline_sizes
{
:
x
}
"
self
.
base
.
debug_id
(
)
)
;
let
writing_mode
=
self
.
base
.
writing_mode
;
for
kid
in
self
.
base
.
child_iter
(
)
{
flow
:
:
mut_base
(
kid
)
.
floats
=
Floats
:
:
new
(
writing_mode
)
;
}
let
mut
computation
=
IntrinsicISizesContribution
:
:
new
(
)
;
for
fragment
in
self
.
fragments
.
fragments
.
iter_mut
(
)
{
debug
!
(
"
Flow
:
measuring
{
}
"
*
fragment
)
;
computation
.
union_inline
(
&
fragment
.
compute_intrinsic_inline_sizes
(
)
.
finish
(
)
)
}
self
.
base
.
intrinsic_inline_sizes
=
computation
.
finish
(
)
}
fn
assign_inline_sizes
(
&
mut
self
_
:
&
LayoutContext
)
{
let
_scope
=
layout_debug_scope
!
(
"
inline
:
:
assign_inline_sizes
{
:
x
}
"
self
.
base
.
debug_id
(
)
)
;
debug
!
(
"
InlineFlow
:
:
assign_inline_sizes
:
floats
in
:
{
}
"
self
.
base
.
floats
)
;
self
.
base
.
position
.
size
.
inline
=
self
.
base
.
block_container_inline_size
;
{
let
inline_size
=
self
.
base
.
position
.
size
.
inline
;
let
this
=
&
mut
*
self
;
for
fragment
in
this
.
fragments
.
fragments
.
iter_mut
(
)
{
fragment
.
compute_border_and_padding
(
inline_size
)
;
fragment
.
compute_block_direction_margins
(
inline_size
)
;
fragment
.
compute_inline_direction_margins
(
inline_size
)
;
fragment
.
assign_replaced_inline_size_if_necessary
(
inline_size
)
;
}
}
let
block_container_explicit_block_size
=
self
.
base
.
block_container_explicit_block_size
;
for
kid
in
self
.
base
.
child_iter
(
)
{
flow
:
:
mut_base
(
kid
)
.
block_container_explicit_block_size
=
block_container_explicit_block_size
;
}
}
fn
assign_block_size
(
&
mut
self
layout_context
:
&
LayoutContext
)
{
let
_scope
=
layout_debug_scope
!
(
"
inline
:
:
assign_block_size
{
:
x
}
"
self
.
base
.
debug_id
(
)
)
;
(
&
mut
*
self
as
&
mut
Flow
)
.
collect_static_block_offsets_from_children
(
)
;
debug
!
(
"
assign_block_size_inline
:
floats
in
:
{
}
"
self
.
base
.
floats
)
;
let
containing_block_block_size
=
self
.
base
.
block_container_explicit_block_size
.
unwrap_or
(
Au
(
0
)
)
;
for
fragment
in
self
.
fragments
.
fragments
.
iter_mut
(
)
{
fragment
.
assign_replaced_block_size_if_necessary
(
containing_block_block_size
)
;
}
self
.
lines
=
Vec
:
:
new
(
)
;
let
mut
indentation
=
if
self
.
fragments
.
is_empty
(
)
{
Au
(
0
)
}
else
{
self
.
first_line_indentation
}
;
let
mut
scanner
=
LineBreaker
:
:
new
(
self
.
base
.
floats
.
clone
(
)
indentation
)
;
scanner
.
scan_for_lines
(
self
layout_context
)
;
let
mut
line_distance_from_flow_block_start
=
Au
(
0
)
;
for
line
in
self
.
lines
.
iter_mut
(
)
{
InlineFlow
:
:
set_inline_fragment_positions
(
&
mut
self
.
fragments
line
self
.
base
.
flags
.
text_align
(
)
indentation
)
;
line
.
bounds
.
start
.
b
=
line_distance_from_flow_block_start
;
let
mut
largest_block_size_above_baseline
=
self
.
minimum_block_size_above_baseline
;
let
mut
largest_depth_below_baseline
=
self
.
minimum_depth_below_baseline
;
let
(
mut
largest_block_size_for_top_fragments
mut
largest_block_size_for_bottom_fragments
)
=
(
Au
(
0
)
Au
(
0
)
)
;
for
fragment_index
in
range
(
line
.
range
.
begin
(
)
line
.
range
.
end
(
)
)
{
let
fragment
=
&
mut
self
.
fragments
.
fragments
[
fragment_index
.
to_uint
(
)
]
;
let
InlineMetrics
{
mut
block_size_above_baseline
mut
depth_below_baseline
ascent
}
=
fragment
.
inline_metrics
(
layout_context
)
;
let
(
distance_from_baseline
no_update_flag
)
=
InlineFlow
:
:
distance_from_baseline
(
fragment
ascent
self
.
minimum_block_size_above_baseline
self
.
minimum_depth_below_baseline
&
mut
block_size_above_baseline
&
mut
depth_below_baseline
&
mut
largest_block_size_for_top_fragments
&
mut
largest_block_size_for_bottom_fragments
layout_context
)
;
if
!
no_update_flag
{
largest_block_size_above_baseline
=
max
(
block_size_above_baseline
largest_block_size_above_baseline
)
;
largest_depth_below_baseline
=
max
(
depth_below_baseline
largest_depth_below_baseline
)
;
}
fragment
.
border_box
.
start
.
b
=
distance_from_baseline
}
largest_block_size_above_baseline
=
max
(
largest_block_size_above_baseline
largest_block_size_for_bottom_fragments
-
largest_depth_below_baseline
)
;
largest_depth_below_baseline
=
max
(
largest_depth_below_baseline
largest_block_size_for_top_fragments
-
largest_block_size_above_baseline
)
;
let
baseline_distance_from_block_start
=
largest_block_size_above_baseline
;
InlineFlow
:
:
set_block_fragment_positions
(
&
mut
self
.
fragments
line
line_distance_from_flow_block_start
baseline_distance_from_block_start
largest_depth_below_baseline
)
;
line
.
bounds
.
size
.
block
=
largest_block_size_above_baseline
+
largest_depth_below_baseline
;
line_distance_from_flow_block_start
=
line_distance_from_flow_block_start
+
line
.
bounds
.
size
.
block
;
indentation
=
Au
(
0
)
}
for
kid
in
self
.
base
.
child_iter
(
)
{
if
flow
:
:
base
(
kid
)
.
flags
.
contains
(
IS_ABSOLUTELY_POSITIONED
)
|
|
flow
:
:
base
(
kid
)
.
flags
.
is_float
(
)
{
continue
}
kid
.
assign_block_size_for_inorder_child_if_necessary
(
layout_context
)
;
}
self
.
base
.
position
.
size
.
block
=
match
self
.
lines
.
as_slice
(
)
.
last
(
)
{
Some
(
ref
last_line
)
=
>
last_line
.
bounds
.
start
.
b
+
last_line
.
bounds
.
size
.
block
None
=
>
Au
(
0
)
}
;
self
.
base
.
floats
=
scanner
.
floats
.
clone
(
)
;
self
.
base
.
floats
.
translate
(
LogicalSize
:
:
new
(
self
.
base
.
writing_mode
Au
(
0
)
-
self
.
base
.
position
.
size
.
block
)
)
;
self
.
base
.
restyle_damage
.
remove
(
REFLOW_OUT_OF_FLOW
|
REFLOW
)
;
}
fn
compute_absolute_position
(
&
mut
self
)
{
for
fragment
in
self
.
fragments
.
fragments
.
iter_mut
(
)
{
let
stacking_relative_position
=
match
fragment
.
specific
{
SpecificFragmentInfo
:
:
InlineBlock
(
ref
mut
info
)
=
>
{
let
block_flow
=
info
.
flow_ref
.
as_block
(
)
;
block_flow
.
base
.
absolute_position_info
=
self
.
base
.
absolute_position_info
;
let
container_size
=
Size2D
:
:
zero
(
)
;
block_flow
.
base
.
stacking_relative_position
=
self
.
base
.
stacking_relative_position
+
fragment
.
border_box
.
start
.
to_physical
(
self
.
base
.
writing_mode
container_size
)
;
block_flow
.
base
.
stacking_relative_position
}
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
ref
mut
info
)
=
>
{
let
block_flow
=
info
.
flow_ref
.
as_block
(
)
;
block_flow
.
base
.
absolute_position_info
=
self
.
base
.
absolute_position_info
;
let
container_size
=
Size2D
:
:
zero
(
)
;
block_flow
.
base
.
stacking_relative_position
=
self
.
base
.
stacking_relative_position
+
fragment
.
border_box
.
start
.
to_physical
(
self
.
base
.
writing_mode
container_size
)
;
block_flow
.
base
.
stacking_relative_position
}
_
=
>
continue
}
;
let
clip_rect
=
fragment
.
clip_rect_for_children
(
self
.
base
.
clip_rect
stacking_relative_position
)
;
match
fragment
.
specific
{
SpecificFragmentInfo
:
:
InlineBlock
(
ref
mut
info
)
=
>
{
flow
:
:
mut_base
(
info
.
flow_ref
.
deref_mut
(
)
)
.
clip_rect
=
clip_rect
}
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
ref
mut
info
)
=
>
{
flow
:
:
mut_base
(
info
.
flow_ref
.
deref_mut
(
)
)
.
clip_rect
=
clip_rect
}
_
=
>
{
}
}
}
}
fn
update_late_computed_inline_position_if_necessary
(
&
mut
self
_
:
Au
)
{
}
fn
update_late_computed_block_position_if_necessary
(
&
mut
self
_
:
Au
)
{
}
fn
build_display_list
(
&
mut
self
layout_context
:
&
LayoutContext
)
{
debug
!
(
"
Flow
:
building
display
list
for
{
:
u
}
inline
fragments
"
self
.
fragments
.
len
(
)
)
;
let
mut
display_list
=
box
DisplayList
:
:
new
(
)
;
for
fragment
in
self
.
fragments
.
fragments
.
iter_mut
(
)
{
let
fragment_origin
=
self
.
base
.
stacking_relative_position_of_child_fragment
(
fragment
)
;
fragment
.
build_display_list
(
&
mut
*
display_list
layout_context
fragment_origin
BackgroundAndBorderLevel
:
:
Content
&
self
.
base
.
clip_rect
)
;
match
fragment
.
specific
{
SpecificFragmentInfo
:
:
InlineBlock
(
ref
mut
block_flow
)
=
>
{
let
block_flow
=
block_flow
.
flow_ref
.
deref_mut
(
)
;
flow
:
:
mut_base
(
block_flow
)
.
display_list_building_result
.
add_to
(
&
mut
*
display_list
)
}
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
ref
mut
block_flow
)
=
>
{
let
block_flow
=
block_flow
.
flow_ref
.
deref_mut
(
)
;
flow
:
:
mut_base
(
block_flow
)
.
display_list_building_result
.
add_to
(
&
mut
*
display_list
)
}
_
=
>
{
}
}
}
self
.
base
.
display_list_building_result
=
DisplayListBuildingResult
:
:
Normal
(
display_list
)
;
if
opts
:
:
get
(
)
.
validate_display_list_geometry
{
self
.
base
.
validate_display_list_geometry
(
)
;
}
}
fn
repair_style
(
&
mut
self
_
:
&
Arc
<
ComputedValues
>
)
{
}
fn
iterate_through_fragment_bounds
(
&
self
iterator
:
&
mut
FragmentBoundsIterator
)
{
for
fragment
in
self
.
fragments
.
fragments
.
iter
(
)
{
if
iterator
.
should_process
(
fragment
)
{
let
fragment_origin
=
self
.
base
.
stacking_relative_position_of_child_fragment
(
fragment
)
;
iterator
.
process
(
fragment
fragment
.
stacking_relative_bounds
(
&
fragment_origin
)
)
;
}
}
}
}
impl
fmt
:
:
Show
for
InlineFlow
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
-
{
:
x
}
-
{
}
"
self
.
class
(
)
self
.
base
.
debug_id
(
)
self
.
fragments
)
}
}
#
[
deriving
(
Clone
)
]
pub
struct
InlineFragmentContext
{
pub
styles
:
Vec
<
Arc
<
ComputedValues
>
>
}
impl
InlineFragmentContext
{
pub
fn
new
(
)
-
>
InlineFragmentContext
{
InlineFragmentContext
{
styles
:
vec
!
(
)
}
}
}
pub
struct
InlineMetrics
{
pub
block_size_above_baseline
:
Au
pub
depth_below_baseline
:
Au
pub
ascent
:
Au
}
impl
InlineMetrics
{
#
[
inline
]
pub
fn
from_font_metrics
(
font_metrics
:
&
FontMetrics
line_height
:
Au
)
-
>
InlineMetrics
{
let
leading
=
line_height
-
(
font_metrics
.
ascent
+
font_metrics
.
descent
)
;
InlineMetrics
{
block_size_above_baseline
:
font_metrics
.
ascent
+
leading
.
scale_by
(
0
.
5
)
depth_below_baseline
:
font_metrics
.
descent
+
leading
.
scale_by
(
0
.
5
)
ascent
:
font_metrics
.
ascent
}
}
#
[
inline
]
pub
fn
from_block_height
(
font_metrics
:
&
FontMetrics
block_height
:
Au
)
-
>
InlineMetrics
{
let
leading
=
block_height
-
(
font_metrics
.
ascent
+
font_metrics
.
descent
)
;
InlineMetrics
{
block_size_above_baseline
:
font_metrics
.
ascent
+
leading
.
scale_by
(
0
.
5
)
depth_below_baseline
:
font_metrics
.
descent
+
leading
.
scale_by
(
0
.
5
)
ascent
:
font_metrics
.
ascent
+
leading
.
scale_by
(
0
.
5
)
}
}
}
