#
!
[
allow
(
unsafe_blocks
)
]
use
construct
:
:
ConstructionResult
;
use
incremental
:
:
RestyleDamage
;
use
parallel
:
:
DomParallelInfo
;
use
wrapper
:
:
{
LayoutNode
TLayoutNode
ThreadSafeLayoutNode
}
;
use
azure
:
:
azure_hl
:
:
Color
;
use
gfx
:
:
display_list
:
:
OpaqueNode
;
use
gfx
;
use
libc
:
:
{
c_void
uintptr_t
}
;
use
script
:
:
dom
:
:
bindings
:
:
js
:
:
LayoutJS
;
use
script
:
:
dom
:
:
node
:
:
{
Node
SharedLayoutData
}
;
use
script
:
:
layout_interface
:
:
{
LayoutChan
TrustedNodeAddress
}
;
use
script_traits
:
:
UntrustedNodeAddress
;
use
std
:
:
mem
;
use
std
:
:
cell
:
:
{
Ref
RefMut
}
;
use
style
:
:
properties
:
:
ComputedValues
;
use
style
;
use
std
:
:
sync
:
:
Arc
;
pub
struct
PrivateLayoutData
{
pub
before_style
:
Option
<
Arc
<
ComputedValues
>
>
pub
after_style
:
Option
<
Arc
<
ComputedValues
>
>
pub
restyle_damage
:
RestyleDamage
pub
flow_construction_result
:
ConstructionResult
pub
before_flow_construction_result
:
ConstructionResult
pub
after_flow_construction_result
:
ConstructionResult
pub
parallel
:
DomParallelInfo
pub
flags
:
LayoutDataFlags
}
impl
PrivateLayoutData
{
pub
fn
new
(
)
-
>
PrivateLayoutData
{
PrivateLayoutData
{
before_style
:
None
after_style
:
None
restyle_damage
:
RestyleDamage
:
:
empty
(
)
flow_construction_result
:
ConstructionResult
:
:
None
before_flow_construction_result
:
ConstructionResult
:
:
None
after_flow_construction_result
:
ConstructionResult
:
:
None
parallel
:
DomParallelInfo
:
:
new
(
)
flags
:
LayoutDataFlags
:
:
empty
(
)
}
}
}
bitflags
!
{
flags
LayoutDataFlags
:
u8
{
#
[
doc
=
"
Whether
a
flow
has
been
newly
constructed
.
"
]
const
HAS_NEWLY_CONSTRUCTED_FLOW
=
0x01
}
}
pub
struct
LayoutDataWrapper
{
pub
chan
:
Option
<
LayoutChan
>
pub
shared_data
:
SharedLayoutData
pub
data
:
Box
<
PrivateLayoutData
>
}
#
[
allow
(
dead_code
)
]
fn
static_assertion
(
x
:
Option
<
LayoutDataWrapper
>
)
{
unsafe
{
let
_
:
Option
<
:
:
script
:
:
dom
:
:
node
:
:
LayoutData
>
=
:
:
std
:
:
intrinsics
:
:
transmute
(
x
)
;
}
}
pub
trait
LayoutDataAccess
{
unsafe
fn
borrow_layout_data_unchecked
(
&
self
)
-
>
*
const
Option
<
LayoutDataWrapper
>
;
fn
borrow_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
Option
<
LayoutDataWrapper
>
>
;
fn
mutate_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
Option
<
LayoutDataWrapper
>
>
;
}
impl
<
'
ln
>
LayoutDataAccess
for
LayoutNode
<
'
ln
>
{
#
[
inline
(
always
)
]
unsafe
fn
borrow_layout_data_unchecked
(
&
self
)
-
>
*
const
Option
<
LayoutDataWrapper
>
{
mem
:
:
transmute
(
self
.
get
(
)
.
layout_data_unchecked
(
)
)
}
#
[
inline
(
always
)
]
fn
borrow_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
Option
<
LayoutDataWrapper
>
>
{
unsafe
{
mem
:
:
transmute
(
self
.
get
(
)
.
layout_data
(
)
)
}
}
#
[
inline
(
always
)
]
fn
mutate_layout_data
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
Option
<
LayoutDataWrapper
>
>
{
unsafe
{
mem
:
:
transmute
(
self
.
get
(
)
.
layout_data_mut
(
)
)
}
}
}
pub
trait
OpaqueNodeMethods
{
fn
from_layout_node
(
node
:
&
LayoutNode
)
-
>
Self
;
fn
from_thread_safe_layout_node
(
node
:
&
ThreadSafeLayoutNode
)
-
>
Self
;
fn
from_script_node
(
node
:
TrustedNodeAddress
)
-
>
Self
;
fn
from_jsmanaged
(
node
:
&
LayoutJS
<
Node
>
)
-
>
Self
;
fn
to_untrusted_node_address
(
&
self
)
-
>
UntrustedNodeAddress
;
}
impl
OpaqueNodeMethods
for
OpaqueNode
{
fn
from_layout_node
(
node
:
&
LayoutNode
)
-
>
OpaqueNode
{
unsafe
{
OpaqueNodeMethods
:
:
from_jsmanaged
(
node
.
get_jsmanaged
(
)
)
}
}
fn
from_thread_safe_layout_node
(
node
:
&
ThreadSafeLayoutNode
)
-
>
OpaqueNode
{
unsafe
{
OpaqueNodeMethods
:
:
from_jsmanaged
(
node
.
get_jsmanaged
(
)
)
}
}
fn
from_script_node
(
node
:
TrustedNodeAddress
)
-
>
OpaqueNode
{
unsafe
{
OpaqueNodeMethods
:
:
from_jsmanaged
(
&
LayoutJS
:
:
from_trusted_node_address
(
node
)
)
}
}
fn
from_jsmanaged
(
node
:
&
LayoutJS
<
Node
>
)
-
>
OpaqueNode
{
unsafe
{
let
ptr
:
uintptr_t
=
node
.
get_jsobject
(
)
as
uintptr_t
;
OpaqueNode
(
ptr
)
}
}
fn
to_untrusted_node_address
(
&
self
)
-
>
UntrustedNodeAddress
{
let
OpaqueNode
(
addr
)
=
*
self
;
UntrustedNodeAddress
(
addr
as
*
const
c_void
)
}
}
pub
trait
ToGfxColor
{
fn
to_gfx_color
(
&
self
)
-
>
Color
;
}
impl
ToGfxColor
for
style
:
:
values
:
:
RGBA
{
fn
to_gfx_color
(
&
self
)
-
>
Color
{
gfx
:
:
color
:
:
rgba
(
self
.
red
self
.
green
self
.
blue
self
.
alpha
)
}
}
