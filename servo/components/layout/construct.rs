#
!
[
deny
(
unsafe_code
)
]
use
ServoArc
;
use
block
:
:
BlockFlow
;
use
context
:
:
{
LayoutContext
with_thread_local_font_context
}
;
use
data
:
:
{
LayoutDataFlags
LayoutData
}
;
use
flex
:
:
FlexFlow
;
use
floats
:
:
FloatKind
;
use
flow
:
:
{
self
AbsoluteDescendants
Flow
FlowClass
ImmutableFlowUtils
}
;
use
flow
:
:
{
FlowFlags
MutableFlowUtils
MutableOwnedFlowUtils
}
;
use
flow_ref
:
:
FlowRef
;
use
fragment
:
:
{
CanvasFragmentInfo
ImageFragmentInfo
InlineAbsoluteFragmentInfo
SvgFragmentInfo
}
;
use
fragment
:
:
{
Fragment
GeneratedContentInfo
IframeFragmentInfo
FragmentFlags
}
;
use
fragment
:
:
{
InlineAbsoluteHypotheticalFragmentInfo
TableColumnFragmentInfo
}
;
use
fragment
:
:
{
InlineBlockFragmentInfo
SpecificFragmentInfo
UnscannedTextFragmentInfo
}
;
use
fragment
:
:
WhitespaceStrippingResult
;
use
gfx
:
:
display_list
:
:
OpaqueNode
;
use
inline
:
:
{
InlineFlow
InlineFragmentNodeInfo
InlineFragmentNodeFlags
}
;
use
linked_list
:
:
prepend_from
;
use
list_item
:
:
{
ListItemFlow
ListStyleTypeContent
}
;
use
multicol
:
:
{
MulticolColumnFlow
MulticolFlow
}
;
use
parallel
;
use
script_layout_interface
:
:
{
LayoutElementType
LayoutNodeType
is_image_data
}
;
use
script_layout_interface
:
:
wrapper_traits
:
:
{
PseudoElementType
ThreadSafeLayoutElement
ThreadSafeLayoutNode
}
;
use
servo_config
:
:
opts
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
collections
:
:
LinkedList
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
use
style
:
:
computed_values
:
:
caption_side
:
:
T
as
CaptionSide
;
use
style
:
:
computed_values
:
:
content
:
:
ContentItem
;
use
style
:
:
computed_values
:
:
display
:
:
T
as
Display
;
use
style
:
:
computed_values
:
:
empty_cells
:
:
T
as
EmptyCells
;
use
style
:
:
computed_values
:
:
float
:
:
T
as
Float
;
use
style
:
:
computed_values
:
:
list_style_position
:
:
T
as
ListStylePosition
;
use
style
:
:
computed_values
:
:
position
:
:
T
as
Position
;
use
style
:
:
context
:
:
SharedStyleContext
;
use
style
:
:
logical_geometry
:
:
Direction
;
use
style
:
:
properties
:
:
ComputedValues
;
use
style
:
:
properties
:
:
longhands
:
:
list_style_image
;
use
style
:
:
selector_parser
:
:
{
PseudoElement
RestyleDamage
}
;
use
style
:
:
servo
:
:
restyle_damage
:
:
ServoRestyleDamage
;
use
style
:
:
values
:
:
Either
;
use
table
:
:
TableFlow
;
use
table_caption
:
:
TableCaptionFlow
;
use
table_cell
:
:
TableCellFlow
;
use
table_colgroup
:
:
TableColGroupFlow
;
use
table_row
:
:
TableRowFlow
;
use
table_rowgroup
:
:
TableRowGroupFlow
;
use
table_wrapper
:
:
TableWrapperFlow
;
use
text
:
:
TextRunScanner
;
use
traversal
:
:
PostorderNodeMutTraversal
;
use
wrapper
:
:
{
LayoutNodeLayoutData
TextContent
ThreadSafeLayoutNodeHelpers
}
;
#
[
derive
(
Clone
)
]
pub
enum
ConstructionResult
{
None
Flow
(
FlowRef
AbsoluteDescendants
)
ConstructionItem
(
ConstructionItem
)
}
impl
ConstructionResult
{
pub
fn
get
(
&
mut
self
)
-
>
ConstructionResult
{
(
*
self
)
.
clone
(
)
}
pub
fn
debug_id
(
&
self
)
-
>
usize
{
match
*
self
{
ConstructionResult
:
:
None
=
>
0
ConstructionResult
:
:
ConstructionItem
(
_
)
=
>
0
ConstructionResult
:
:
Flow
(
ref
flow_ref
_
)
=
>
flow
:
:
base
(
&
*
*
flow_ref
)
.
debug_id
(
)
}
}
}
#
[
derive
(
Clone
)
]
pub
enum
ConstructionItem
{
InlineFragments
(
InlineFragmentsConstructionResult
)
Whitespace
(
OpaqueNode
PseudoElementType
<
(
)
>
ServoArc
<
ComputedValues
>
RestyleDamage
)
TableColumnFragment
(
Fragment
)
}
#
[
derive
(
Clone
)
]
pub
struct
InlineFragmentsConstructionResult
{
pub
splits
:
LinkedList
<
InlineBlockSplit
>
pub
fragments
:
IntermediateInlineFragments
}
#
[
derive
(
Clone
)
]
pub
struct
InlineBlockSplit
{
pub
predecessors
:
IntermediateInlineFragments
pub
flow
:
FlowRef
}
impl
InlineBlockSplit
{
fn
new
<
ConcreteThreadSafeLayoutNode
:
ThreadSafeLayoutNode
>
(
fragment_accumulator
:
&
mut
InlineFragmentsAccumulator
node
:
&
ConcreteThreadSafeLayoutNode
style_context
:
&
SharedStyleContext
flow
:
FlowRef
)
-
>
InlineBlockSplit
{
fragment_accumulator
.
enclosing_node
.
as_mut
(
)
.
expect
(
"
enclosing_node
is
None
;
Are
{
ib
}
splits
being
generated
outside
of
an
inline
node
?
"
)
.
flags
.
remove
(
InlineFragmentNodeFlags
:
:
LAST_FRAGMENT_OF_ELEMENT
)
;
let
split
=
InlineBlockSplit
{
predecessors
:
mem
:
:
replace
(
fragment_accumulator
InlineFragmentsAccumulator
:
:
from_inline_node
(
node
style_context
)
)
.
to_intermediate_inline_fragments
(
style_context
)
flow
:
flow
}
;
fragment_accumulator
.
enclosing_node
.
as_mut
(
)
.
unwrap
(
)
.
flags
.
remove
(
InlineFragmentNodeFlags
:
:
FIRST_FRAGMENT_OF_ELEMENT
)
;
split
}
}
#
[
derive
(
Clone
)
]
pub
struct
IntermediateInlineFragments
{
pub
fragments
:
LinkedList
<
Fragment
>
pub
absolute_descendants
:
AbsoluteDescendants
}
impl
IntermediateInlineFragments
{
fn
new
(
)
-
>
IntermediateInlineFragments
{
IntermediateInlineFragments
{
fragments
:
LinkedList
:
:
new
(
)
absolute_descendants
:
AbsoluteDescendants
:
:
new
(
)
}
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
fragments
.
is_empty
(
)
&
&
self
.
absolute_descendants
.
is_empty
(
)
}
fn
push_all
(
&
mut
self
mut
other
:
IntermediateInlineFragments
)
{
self
.
fragments
.
append
(
&
mut
other
.
fragments
)
;
self
.
absolute_descendants
.
push_descendants
(
other
.
absolute_descendants
)
;
}
}
struct
InlineFragmentsAccumulator
{
fragments
:
IntermediateInlineFragments
enclosing_node
:
Option
<
InlineFragmentNodeInfo
>
restyle_damage
:
RestyleDamage
bidi_control_chars
:
Option
<
(
&
'
static
str
&
'
static
str
)
>
}
impl
InlineFragmentsAccumulator
{
fn
new
(
)
-
>
InlineFragmentsAccumulator
{
InlineFragmentsAccumulator
{
fragments
:
IntermediateInlineFragments
:
:
new
(
)
enclosing_node
:
None
bidi_control_chars
:
None
restyle_damage
:
RestyleDamage
:
:
empty
(
)
}
}
fn
from_inline_node
<
N
>
(
node
:
&
N
style_context
:
&
SharedStyleContext
)
-
>
InlineFragmentsAccumulator
where
N
:
ThreadSafeLayoutNode
{
InlineFragmentsAccumulator
{
fragments
:
IntermediateInlineFragments
:
:
new
(
)
enclosing_node
:
Some
(
InlineFragmentNodeInfo
{
address
:
node
.
opaque
(
)
pseudo
:
node
.
get_pseudo_element_type
(
)
.
strip
(
)
style
:
node
.
style
(
style_context
)
selected_style
:
node
.
selected_style
(
)
flags
:
InlineFragmentNodeFlags
:
:
FIRST_FRAGMENT_OF_ELEMENT
|
InlineFragmentNodeFlags
:
:
LAST_FRAGMENT_OF_ELEMENT
}
)
bidi_control_chars
:
None
restyle_damage
:
node
.
restyle_damage
(
)
}
}
fn
push
(
&
mut
self
fragment
:
Fragment
)
{
self
.
fragments
.
fragments
.
push_back
(
fragment
)
}
fn
push_all
(
&
mut
self
mut
fragments
:
IntermediateInlineFragments
)
{
self
.
fragments
.
fragments
.
append
(
&
mut
fragments
.
fragments
)
;
self
.
fragments
.
absolute_descendants
.
push_descendants
(
fragments
.
absolute_descendants
)
;
}
fn
to_intermediate_inline_fragments
(
self
context
:
&
SharedStyleContext
)
-
>
IntermediateInlineFragments
{
let
InlineFragmentsAccumulator
{
mut
fragments
enclosing_node
bidi_control_chars
restyle_damage
}
=
self
;
if
let
Some
(
mut
enclosing_node
)
=
enclosing_node
{
let
fragment_count
=
fragments
.
fragments
.
len
(
)
;
for
(
index
fragment
)
in
fragments
.
fragments
.
iter_mut
(
)
.
enumerate
(
)
{
let
mut
enclosing_node
=
enclosing_node
.
clone
(
)
;
if
index
!
=
0
{
enclosing_node
.
flags
.
remove
(
InlineFragmentNodeFlags
:
:
FIRST_FRAGMENT_OF_ELEMENT
)
}
if
index
!
=
fragment_count
-
1
{
enclosing_node
.
flags
.
remove
(
InlineFragmentNodeFlags
:
:
LAST_FRAGMENT_OF_ELEMENT
)
}
fragment
.
add_inline_context_style
(
enclosing_node
)
;
}
enclosing_node
.
flags
.
remove
(
InlineFragmentNodeFlags
:
:
FIRST_FRAGMENT_OF_ELEMENT
|
InlineFragmentNodeFlags
:
:
LAST_FRAGMENT_OF_ELEMENT
)
;
if
let
Some
(
(
start
end
)
)
=
bidi_control_chars
{
fragments
.
fragments
.
push_front
(
control_chars_to_fragment
(
&
enclosing_node
context
start
restyle_damage
)
)
;
fragments
.
fragments
.
push_back
(
control_chars_to_fragment
(
&
enclosing_node
context
end
restyle_damage
)
)
;
}
}
fragments
}
}
pub
struct
FlowConstructor
<
'
a
N
:
ThreadSafeLayoutNode
>
{
pub
layout_context
:
&
'
a
LayoutContext
<
'
a
>
phantom2
:
PhantomData
<
N
>
}
impl
<
'
a
ConcreteThreadSafeLayoutNode
:
ThreadSafeLayoutNode
>
FlowConstructor
<
'
a
ConcreteThreadSafeLayoutNode
>
{
pub
fn
new
(
layout_context
:
&
'
a
LayoutContext
<
'
a
>
)
-
>
Self
{
FlowConstructor
{
layout_context
:
layout_context
phantom2
:
PhantomData
}
}
#
[
inline
]
fn
style_context
(
&
self
)
-
>
&
SharedStyleContext
{
self
.
layout_context
.
shared_context
(
)
}
#
[
inline
]
fn
set_flow_construction_result
(
&
self
node
:
&
ConcreteThreadSafeLayoutNode
result
:
ConstructionResult
)
{
node
.
set_flow_construction_result
(
result
)
;
}
fn
build_fragment_for_block
(
&
self
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
Fragment
{
let
specific_fragment_info
=
match
node
.
type_id
(
)
{
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLIFrameElement
)
)
=
>
{
SpecificFragmentInfo
:
:
Iframe
(
IframeFragmentInfo
:
:
new
(
node
)
)
}
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLImageElement
)
)
=
>
{
let
image_info
=
Box
:
:
new
(
ImageFragmentInfo
:
:
new
(
node
.
image_url
(
)
node
&
self
.
layout_context
)
)
;
SpecificFragmentInfo
:
:
Image
(
image_info
)
}
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLObjectElement
)
)
=
>
{
let
image_info
=
Box
:
:
new
(
ImageFragmentInfo
:
:
new
(
node
.
object_data
(
)
node
&
self
.
layout_context
)
)
;
SpecificFragmentInfo
:
:
Image
(
image_info
)
}
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLTableElement
)
)
=
>
{
SpecificFragmentInfo
:
:
TableWrapper
}
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLTableColElement
)
)
=
>
{
SpecificFragmentInfo
:
:
TableColumn
(
TableColumnFragmentInfo
:
:
new
(
node
)
)
}
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLTableCellElement
)
)
=
>
{
SpecificFragmentInfo
:
:
TableCell
}
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLTableRowElement
)
)
|
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLTableSectionElement
)
)
=
>
{
SpecificFragmentInfo
:
:
TableRow
}
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLCanvasElement
)
)
=
>
{
let
data
=
node
.
canvas_data
(
)
.
unwrap
(
)
;
SpecificFragmentInfo
:
:
Canvas
(
Box
:
:
new
(
CanvasFragmentInfo
:
:
new
(
data
)
)
)
}
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
SVGSVGElement
)
)
=
>
{
let
data
=
node
.
svg_data
(
)
.
unwrap
(
)
;
SpecificFragmentInfo
:
:
Svg
(
Box
:
:
new
(
SvgFragmentInfo
:
:
new
(
data
)
)
)
}
_
=
>
{
SpecificFragmentInfo
:
:
Generic
}
}
;
Fragment
:
:
new
(
node
specific_fragment_info
self
.
layout_context
)
}
#
[
inline
(
always
)
]
fn
flush_inline_fragments_to_flow
(
&
mut
self
fragment_accumulator
:
InlineFragmentsAccumulator
flow
:
&
mut
FlowRef
absolute_descendants
:
&
mut
AbsoluteDescendants
legalizer
:
&
mut
Legalizer
node
:
&
ConcreteThreadSafeLayoutNode
)
{
let
mut
fragments
=
fragment_accumulator
.
to_intermediate_inline_fragments
(
self
.
style_context
(
)
)
;
if
fragments
.
is_empty
(
)
{
return
}
;
strip_ignorable_whitespace_from_start
(
&
mut
fragments
.
fragments
)
;
strip_ignorable_whitespace_from_end
(
&
mut
fragments
.
fragments
)
;
if
fragments
.
fragments
.
is_empty
(
)
{
absolute_descendants
.
push_descendants
(
fragments
.
absolute_descendants
)
;
return
}
let
mut
inline_block_flows
=
vec
!
(
)
;
for
fragment
in
&
fragments
.
fragments
{
match
fragment
.
specific
{
SpecificFragmentInfo
:
:
InlineBlock
(
ref
info
)
=
>
{
inline_block_flows
.
push
(
info
.
flow_ref
.
clone
(
)
)
}
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
ref
info
)
=
>
{
inline_block_flows
.
push
(
info
.
flow_ref
.
clone
(
)
)
}
SpecificFragmentInfo
:
:
InlineAbsolute
(
ref
info
)
=
>
{
inline_block_flows
.
push
(
info
.
flow_ref
.
clone
(
)
)
}
_
=
>
{
}
}
}
let
scanned_fragments
=
with_thread_local_font_context
(
self
.
layout_context
|
font_context
|
{
TextRunScanner
:
:
new
(
)
.
scan_for_runs
(
font_context
mem
:
:
replace
(
&
mut
fragments
.
fragments
LinkedList
:
:
new
(
)
)
)
}
)
;
let
mut
inline_flow_ref
=
FlowRef
:
:
new
(
Arc
:
:
new
(
InlineFlow
:
:
from_fragments
(
scanned_fragments
node
.
style
(
self
.
style_context
(
)
)
.
writing_mode
)
)
)
;
for
inline_block_flow
in
&
inline_block_flows
{
inline_flow_ref
.
add_new_child
(
inline_block_flow
.
clone
(
)
)
;
}
inline_flow_ref
.
take_applicable_absolute_descendants
(
&
mut
fragments
.
absolute_descendants
)
;
absolute_descendants
.
push_descendants
(
fragments
.
absolute_descendants
)
;
{
let
inline_flow
=
FlowRef
:
:
deref_mut
(
&
mut
inline_flow_ref
)
.
as_mut_inline
(
)
;
inline_flow
.
minimum_line_metrics
=
with_thread_local_font_context
(
self
.
layout_context
|
font_context
|
{
inline_flow
.
minimum_line_metrics
(
font_context
&
node
.
style
(
self
.
style_context
(
)
)
)
}
)
;
}
inline_flow_ref
.
finish
(
)
;
legalizer
.
add_child
(
self
.
style_context
(
)
flow
inline_flow_ref
)
}
fn
build_block_flow_using_construction_result_of_child
(
&
mut
self
flow
:
&
mut
FlowRef
node
:
&
ConcreteThreadSafeLayoutNode
kid
:
ConcreteThreadSafeLayoutNode
inline_fragment_accumulator
:
&
mut
InlineFragmentsAccumulator
abs_descendants
:
&
mut
AbsoluteDescendants
legalizer
:
&
mut
Legalizer
)
{
match
kid
.
get_construction_result
(
)
{
ConstructionResult
:
:
None
=
>
{
}
ConstructionResult
:
:
Flow
(
kid_flow
kid_abs_descendants
)
=
>
{
if
flow
.
is_table
(
)
&
&
kid_flow
.
is_table_caption
(
)
{
let
construction_result
=
ConstructionResult
:
:
Flow
(
kid_flow
AbsoluteDescendants
:
:
new
(
)
)
;
self
.
set_flow_construction_result
(
&
kid
construction_result
)
}
else
{
if
!
flow
:
:
base
(
&
*
kid_flow
)
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
let
old_inline_fragment_accumulator
=
mem
:
:
replace
(
inline_fragment_accumulator
InlineFragmentsAccumulator
:
:
new
(
)
)
;
self
.
flush_inline_fragments_to_flow
(
old_inline_fragment_accumulator
flow
abs_descendants
legalizer
node
)
;
}
legalizer
.
add_child
(
self
.
style_context
(
)
flow
kid_flow
)
}
abs_descendants
.
push_descendants
(
kid_abs_descendants
)
;
}
ConstructionResult
:
:
ConstructionItem
(
ConstructionItem
:
:
InlineFragments
(
InlineFragmentsConstructionResult
{
splits
fragments
:
successor_fragments
}
)
)
=
>
{
for
split
in
splits
{
let
InlineBlockSplit
{
predecessors
flow
:
kid_flow
}
=
split
;
inline_fragment_accumulator
.
push_all
(
predecessors
)
;
debug
!
(
"
flushing
{
}
inline
box
(
es
)
to
flow
A
"
inline_fragment_accumulator
.
fragments
.
fragments
.
len
(
)
)
;
let
old_inline_fragment_accumulator
=
mem
:
:
replace
(
inline_fragment_accumulator
InlineFragmentsAccumulator
:
:
new
(
)
)
;
let
absolute_descendants
=
&
mut
inline_fragment_accumulator
.
fragments
.
absolute_descendants
;
self
.
flush_inline_fragments_to_flow
(
old_inline_fragment_accumulator
flow
absolute_descendants
legalizer
node
)
;
legalizer
.
add_child
(
self
.
style_context
(
)
flow
kid_flow
)
}
inline_fragment_accumulator
.
push_all
(
successor_fragments
)
;
}
ConstructionResult
:
:
ConstructionItem
(
ConstructionItem
:
:
Whitespace
(
whitespace_node
whitespace_pseudo
whitespace_style
whitespace_damage
)
)
=
>
{
let
fragment_info
=
SpecificFragmentInfo
:
:
UnscannedText
(
Box
:
:
new
(
UnscannedTextFragmentInfo
:
:
new
(
"
"
.
to_owned
(
)
None
)
)
)
;
let
fragment
=
Fragment
:
:
from_opaque_node_and_style
(
whitespace_node
whitespace_pseudo
whitespace_style
node
.
selected_style
(
)
whitespace_damage
fragment_info
)
;
inline_fragment_accumulator
.
fragments
.
fragments
.
push_back
(
fragment
)
;
}
ConstructionResult
:
:
ConstructionItem
(
ConstructionItem
:
:
TableColumnFragment
(
_
)
)
=
>
{
}
}
}
fn
build_flow_for_block_starting_with_fragments
(
&
mut
self
mut
flow
:
FlowRef
node
:
&
ConcreteThreadSafeLayoutNode
initial_fragments
:
IntermediateInlineFragments
)
-
>
ConstructionResult
{
let
mut
inline_fragment_accumulator
=
InlineFragmentsAccumulator
:
:
new
(
)
;
inline_fragment_accumulator
.
fragments
.
push_all
(
initial_fragments
)
;
let
mut
abs_descendants
=
AbsoluteDescendants
:
:
new
(
)
;
let
mut
legalizer
=
Legalizer
:
:
new
(
)
;
if
!
node
.
is_replaced_content
(
)
{
for
kid
in
node
.
children
(
)
{
if
kid
.
get_pseudo_element_type
(
)
!
=
PseudoElementType
:
:
Normal
{
self
.
process
(
&
kid
)
;
}
self
.
build_block_flow_using_construction_result_of_child
(
&
mut
flow
node
kid
&
mut
inline_fragment_accumulator
&
mut
abs_descendants
&
mut
legalizer
)
;
}
}
self
.
flush_inline_fragments_to_flow
(
inline_fragment_accumulator
&
mut
flow
&
mut
abs_descendants
&
mut
legalizer
node
)
;
legalizer
.
finish
(
&
mut
flow
)
;
flow
.
finish
(
)
;
if
flow
.
is_absolute_containing_block
(
)
{
flow
.
set_absolute_descendants
(
abs_descendants
)
;
abs_descendants
=
AbsoluteDescendants
:
:
new
(
)
;
if
flow
:
:
base
(
&
*
flow
)
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
abs_descendants
.
push
(
flow
.
clone
(
)
)
;
}
}
ConstructionResult
:
:
Flow
(
flow
abs_descendants
)
}
fn
build_flow_for_block_like
(
&
mut
self
flow
:
FlowRef
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
mut
fragments
=
IntermediateInlineFragments
:
:
new
(
)
;
let
node_is_input_or_text_area
=
node
.
type_id
(
)
=
=
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLInputElement
)
)
|
|
node
.
type_id
(
)
=
=
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLTextAreaElement
)
)
;
if
node
.
get_pseudo_element_type
(
)
.
is_replaced_content
(
)
|
|
node_is_input_or_text_area
{
if
node
.
type_id
(
)
=
=
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLTextAreaElement
)
)
{
for
kid
in
node
.
children
(
)
{
self
.
set_flow_construction_result
(
&
kid
ConstructionResult
:
:
None
)
}
}
let
context
=
self
.
style_context
(
)
;
let
mut
style
=
node
.
style
(
context
)
;
style
=
context
.
stylist
.
style_for_anonymous
(
&
context
.
guards
&
PseudoElement
:
:
ServoText
&
style
)
;
if
node_is_input_or_text_area
{
style
=
context
.
stylist
.
style_for_anonymous
(
&
context
.
guards
&
PseudoElement
:
:
ServoInputText
&
style
)
}
self
.
create_fragments_for_node_text_content
(
&
mut
fragments
node
&
style
)
}
self
.
build_flow_for_block_starting_with_fragments
(
flow
node
fragments
)
}
fn
create_fragments_for_node_text_content
(
&
self
fragments
:
&
mut
IntermediateInlineFragments
node
:
&
ConcreteThreadSafeLayoutNode
style
:
&
ServoArc
<
ComputedValues
>
)
{
let
text_content
=
node
.
text_content
(
)
;
if
text_content
.
is_empty
(
)
{
return
}
let
style
=
(
*
style
)
.
clone
(
)
;
let
selected_style
=
node
.
selected_style
(
)
;
match
text_content
{
TextContent
:
:
Text
(
string
)
=
>
{
let
info
=
Box
:
:
new
(
UnscannedTextFragmentInfo
:
:
new
(
string
node
.
selection
(
)
)
)
;
let
specific_fragment_info
=
SpecificFragmentInfo
:
:
UnscannedText
(
info
)
;
fragments
.
fragments
.
push_back
(
Fragment
:
:
from_opaque_node_and_style
(
node
.
opaque
(
)
node
.
get_pseudo_element_type
(
)
.
strip
(
)
style
selected_style
node
.
restyle_damage
(
)
specific_fragment_info
)
)
}
TextContent
:
:
GeneratedContent
(
content_items
)
=
>
{
for
content_item
in
content_items
.
into_iter
(
)
{
let
specific_fragment_info
=
match
content_item
{
ContentItem
:
:
String
(
string
)
=
>
{
let
info
=
Box
:
:
new
(
UnscannedTextFragmentInfo
:
:
new
(
string
None
)
)
;
SpecificFragmentInfo
:
:
UnscannedText
(
info
)
}
content_item
=
>
{
let
content_item
=
Box
:
:
new
(
GeneratedContentInfo
:
:
ContentItem
(
content_item
)
)
;
SpecificFragmentInfo
:
:
GeneratedContent
(
content_item
)
}
}
;
fragments
.
fragments
.
push_back
(
Fragment
:
:
from_opaque_node_and_style
(
node
.
opaque
(
)
node
.
get_pseudo_element_type
(
)
.
strip
(
)
style
.
clone
(
)
selected_style
.
clone
(
)
node
.
restyle_damage
(
)
specific_fragment_info
)
)
}
}
}
}
fn
build_flow_for_block
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
float_kind
:
Option
<
FloatKind
>
)
-
>
ConstructionResult
{
if
node
.
style
(
self
.
style_context
(
)
)
.
is_multicol
(
)
{
return
self
.
build_flow_for_multicol
(
node
float_kind
)
}
let
fragment
=
self
.
build_fragment_for_block
(
node
)
;
let
flow
=
FlowRef
:
:
new
(
Arc
:
:
new
(
BlockFlow
:
:
from_fragment_and_float_kind
(
fragment
float_kind
)
)
)
;
self
.
build_flow_for_block_like
(
flow
node
)
}
fn
accumulate_inline_block_splits
(
&
mut
self
splits
:
LinkedList
<
InlineBlockSplit
>
node
:
&
ConcreteThreadSafeLayoutNode
fragment_accumulator
:
&
mut
InlineFragmentsAccumulator
opt_inline_block_splits
:
&
mut
LinkedList
<
InlineBlockSplit
>
)
{
for
split
in
splits
{
let
InlineBlockSplit
{
predecessors
flow
:
kid_flow
}
=
split
;
fragment_accumulator
.
push_all
(
predecessors
)
;
opt_inline_block_splits
.
push_back
(
InlineBlockSplit
:
:
new
(
fragment_accumulator
node
self
.
style_context
(
)
kid_flow
)
)
;
}
}
fn
build_fragments_for_nonreplaced_inline_content
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
mut
opt_inline_block_splits
:
LinkedList
<
InlineBlockSplit
>
=
LinkedList
:
:
new
(
)
;
let
mut
fragment_accumulator
=
InlineFragmentsAccumulator
:
:
from_inline_node
(
node
self
.
style_context
(
)
)
;
fragment_accumulator
.
bidi_control_chars
=
bidi_control_chars
(
&
node
.
style
(
self
.
style_context
(
)
)
)
;
let
mut
abs_descendants
=
AbsoluteDescendants
:
:
new
(
)
;
let
mut
is_empty
=
true
;
for
kid
in
node
.
children
(
)
{
is_empty
=
false
;
if
kid
.
get_pseudo_element_type
(
)
!
=
PseudoElementType
:
:
Normal
{
self
.
process
(
&
kid
)
;
}
match
kid
.
get_construction_result
(
)
{
ConstructionResult
:
:
None
=
>
{
}
ConstructionResult
:
:
Flow
(
flow
kid_abs_descendants
)
=
>
{
if
!
flow
:
:
base
(
&
*
flow
)
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
opt_inline_block_splits
.
push_back
(
InlineBlockSplit
:
:
new
(
&
mut
fragment_accumulator
node
self
.
style_context
(
)
flow
)
)
;
abs_descendants
.
push_descendants
(
kid_abs_descendants
)
;
}
else
{
let
kid_node
=
flow
.
as_block
(
)
.
fragment
.
node
;
let
kid_pseudo
=
flow
.
as_block
(
)
.
fragment
.
pseudo
.
clone
(
)
;
let
kid_style
=
flow
.
as_block
(
)
.
fragment
.
style
.
clone
(
)
;
let
kid_selected_style
=
flow
.
as_block
(
)
.
fragment
.
selected_style
.
clone
(
)
;
let
kid_restyle_damage
=
flow
.
as_block
(
)
.
fragment
.
restyle_damage
;
let
fragment_info
=
SpecificFragmentInfo
:
:
InlineAbsolute
(
InlineAbsoluteFragmentInfo
:
:
new
(
flow
)
)
;
fragment_accumulator
.
push
(
Fragment
:
:
from_opaque_node_and_style
(
kid_node
kid_pseudo
kid_style
kid_selected_style
kid_restyle_damage
fragment_info
)
)
;
fragment_accumulator
.
fragments
.
absolute_descendants
.
push_descendants
(
kid_abs_descendants
)
;
}
}
ConstructionResult
:
:
ConstructionItem
(
ConstructionItem
:
:
InlineFragments
(
InlineFragmentsConstructionResult
{
splits
fragments
:
successors
}
)
)
=
>
{
self
.
accumulate_inline_block_splits
(
splits
node
&
mut
fragment_accumulator
&
mut
opt_inline_block_splits
)
;
fragment_accumulator
.
push_all
(
successors
)
;
}
ConstructionResult
:
:
ConstructionItem
(
ConstructionItem
:
:
Whitespace
(
whitespace_node
whitespace_pseudo
whitespace_style
whitespace_damage
)
)
=
>
{
let
fragment_info
=
SpecificFragmentInfo
:
:
UnscannedText
(
Box
:
:
new
(
UnscannedTextFragmentInfo
:
:
new
(
"
"
.
to_owned
(
)
None
)
)
)
;
let
fragment
=
Fragment
:
:
from_opaque_node_and_style
(
whitespace_node
whitespace_pseudo
whitespace_style
node
.
selected_style
(
)
whitespace_damage
fragment_info
)
;
fragment_accumulator
.
fragments
.
fragments
.
push_back
(
fragment
)
}
ConstructionResult
:
:
ConstructionItem
(
ConstructionItem
:
:
TableColumnFragment
(
_
)
)
=
>
{
}
}
}
let
node_style
=
node
.
style
(
self
.
style_context
(
)
)
;
if
is_empty
&
&
node_style
.
has_padding_or_border
(
)
{
let
info
=
SpecificFragmentInfo
:
:
UnscannedText
(
Box
:
:
new
(
UnscannedTextFragmentInfo
:
:
new
(
String
:
:
new
(
)
None
)
)
)
;
let
fragment
=
Fragment
:
:
from_opaque_node_and_style
(
node
.
opaque
(
)
node
.
get_pseudo_element_type
(
)
.
strip
(
)
node_style
.
clone
(
)
node
.
selected_style
(
)
node
.
restyle_damage
(
)
info
)
;
fragment_accumulator
.
fragments
.
fragments
.
push_back
(
fragment
)
}
if
opt_inline_block_splits
.
len
(
)
>
0
|
|
!
fragment_accumulator
.
fragments
.
is_empty
(
)
|
|
abs_descendants
.
len
(
)
>
0
{
fragment_accumulator
.
fragments
.
absolute_descendants
.
push_descendants
(
abs_descendants
)
;
if
node_style
.
get_box
(
)
.
position
!
=
Position
:
:
Static
{
fragment_accumulator
.
fragments
.
absolute_descendants
.
mark_as_having_reached_containing_block
(
)
;
}
let
construction_item
=
ConstructionItem
:
:
InlineFragments
(
InlineFragmentsConstructionResult
{
splits
:
opt_inline_block_splits
fragments
:
fragment_accumulator
.
to_intermediate_inline_fragments
(
self
.
style_context
(
)
)
}
)
;
ConstructionResult
:
:
ConstructionItem
(
construction_item
)
}
else
{
ConstructionResult
:
:
None
}
}
fn
build_fragments_for_replaced_inline_content
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
ConstructionResult
{
for
kid
in
node
.
children
(
)
{
self
.
set_flow_construction_result
(
&
kid
ConstructionResult
:
:
None
)
}
let
context
=
self
.
style_context
(
)
;
let
style
=
node
.
style
(
context
)
;
if
node
.
is_ignorable_whitespace
(
context
)
{
return
ConstructionResult
:
:
ConstructionItem
(
ConstructionItem
:
:
Whitespace
(
node
.
opaque
(
)
node
.
get_pseudo_element_type
(
)
.
strip
(
)
context
.
stylist
.
style_for_anonymous
(
&
context
.
guards
&
PseudoElement
:
:
ServoText
&
style
)
node
.
restyle_damage
(
)
)
)
}
let
mut
fragments
=
IntermediateInlineFragments
:
:
new
(
)
;
match
(
node
.
get_pseudo_element_type
(
)
node
.
type_id
(
)
)
{
(
_
Some
(
LayoutNodeType
:
:
Text
)
)
=
>
{
let
text_style
=
context
.
stylist
.
style_for_anonymous
(
&
context
.
guards
&
PseudoElement
:
:
ServoText
&
style
)
;
self
.
create_fragments_for_node_text_content
(
&
mut
fragments
node
&
text_style
)
}
(
PseudoElementType
:
:
Normal
_
)
=
>
{
fragments
.
fragments
.
push_back
(
self
.
build_fragment_for_block
(
node
)
)
;
}
(
_
_
)
=
>
self
.
create_fragments_for_node_text_content
(
&
mut
fragments
node
&
style
)
}
let
construction_item
=
ConstructionItem
:
:
InlineFragments
(
InlineFragmentsConstructionResult
{
splits
:
LinkedList
:
:
new
(
)
fragments
:
fragments
}
)
;
ConstructionResult
:
:
ConstructionItem
(
construction_item
)
}
fn
build_fragment_for_inline_block_or_inline_flex
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
display
:
Display
)
-
>
ConstructionResult
{
let
block_flow_result
=
match
display
{
Display
:
:
InlineBlock
=
>
self
.
build_flow_for_block
(
node
None
)
Display
:
:
InlineFlex
=
>
self
.
build_flow_for_flex
(
node
None
)
_
=
>
panic
!
(
"
The
flag
should
be
inline
-
block
or
inline
-
flex
"
)
}
;
let
(
block_flow
abs_descendants
)
=
match
block_flow_result
{
ConstructionResult
:
:
Flow
(
block_flow
abs_descendants
)
=
>
(
block_flow
abs_descendants
)
_
=
>
unreachable
!
(
)
}
;
let
context
=
self
.
style_context
(
)
;
let
style
=
node
.
style
(
context
)
;
let
style
=
context
.
stylist
.
style_for_anonymous
(
&
context
.
guards
&
PseudoElement
:
:
ServoInlineBlockWrapper
&
style
)
;
let
fragment_info
=
SpecificFragmentInfo
:
:
InlineBlock
(
InlineBlockFragmentInfo
:
:
new
(
block_flow
)
)
;
let
fragment
=
Fragment
:
:
from_opaque_node_and_style
(
node
.
opaque
(
)
node
.
get_pseudo_element_type
(
)
.
strip
(
)
style
node
.
selected_style
(
)
node
.
restyle_damage
(
)
fragment_info
)
;
let
mut
fragment_accumulator
=
InlineFragmentsAccumulator
:
:
new
(
)
;
fragment_accumulator
.
fragments
.
fragments
.
push_back
(
fragment
)
;
fragment_accumulator
.
fragments
.
absolute_descendants
.
push_descendants
(
abs_descendants
)
;
let
construction_item
=
ConstructionItem
:
:
InlineFragments
(
InlineFragmentsConstructionResult
{
splits
:
LinkedList
:
:
new
(
)
fragments
:
fragment_accumulator
.
to_intermediate_inline_fragments
(
context
)
}
)
;
ConstructionResult
:
:
ConstructionItem
(
construction_item
)
}
fn
build_fragment_for_absolutely_positioned_inline
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
block_flow_result
=
self
.
build_flow_for_block
(
node
None
)
;
let
(
block_flow
abs_descendants
)
=
match
block_flow_result
{
ConstructionResult
:
:
Flow
(
block_flow
abs_descendants
)
=
>
(
block_flow
abs_descendants
)
_
=
>
unreachable
!
(
)
}
;
let
fragment_info
=
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
InlineAbsoluteHypotheticalFragmentInfo
:
:
new
(
block_flow
)
)
;
let
style_context
=
self
.
style_context
(
)
;
let
style
=
node
.
style
(
style_context
)
;
let
style
=
style_context
.
stylist
.
style_for_anonymous
(
&
style_context
.
guards
&
PseudoElement
:
:
ServoInlineAbsolute
&
style
)
;
let
fragment
=
Fragment
:
:
from_opaque_node_and_style
(
node
.
opaque
(
)
PseudoElementType
:
:
Normal
style
node
.
selected_style
(
)
node
.
restyle_damage
(
)
fragment_info
)
;
let
mut
fragment_accumulator
=
InlineFragmentsAccumulator
:
:
from_inline_node
(
node
self
.
style_context
(
)
)
;
fragment_accumulator
.
fragments
.
fragments
.
push_back
(
fragment
)
;
fragment_accumulator
.
fragments
.
absolute_descendants
.
push_descendants
(
abs_descendants
)
;
let
construction_item
=
ConstructionItem
:
:
InlineFragments
(
InlineFragmentsConstructionResult
{
splits
:
LinkedList
:
:
new
(
)
fragments
:
fragment_accumulator
.
to_intermediate_inline_fragments
(
style_context
)
}
)
;
ConstructionResult
:
:
ConstructionItem
(
construction_item
)
}
fn
build_fragments_for_inline
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
ConstructionResult
{
if
!
node
.
is_replaced_content
(
)
{
self
.
build_fragments_for_nonreplaced_inline_content
(
node
)
}
else
{
self
.
build_fragments_for_replaced_inline_content
(
node
)
}
}
fn
place_table_caption_under_table_wrapper_on_side
(
&
mut
self
table_wrapper_flow
:
&
mut
FlowRef
node
:
&
ConcreteThreadSafeLayoutNode
side
:
CaptionSide
)
{
for
kid
in
node
.
children
(
)
{
match
kid
.
get_construction_result
(
)
{
ConstructionResult
:
:
Flow
(
kid_flow
_
)
=
>
{
if
kid_flow
.
is_table_caption
(
)
&
&
kid_flow
.
as_block
(
)
.
fragment
.
style
(
)
.
get_inheritedtable
(
)
.
caption_side
=
=
side
{
table_wrapper_flow
.
add_new_child
(
kid_flow
)
;
}
}
ConstructionResult
:
:
None
|
ConstructionResult
:
:
ConstructionItem
(
_
)
=
>
{
}
}
}
}
fn
build_flow_for_multicol
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
float_kind
:
Option
<
FloatKind
>
)
-
>
ConstructionResult
{
let
fragment
=
Fragment
:
:
new
(
node
SpecificFragmentInfo
:
:
Multicol
self
.
layout_context
)
;
let
mut
flow
=
FlowRef
:
:
new
(
Arc
:
:
new
(
MulticolFlow
:
:
from_fragment
(
fragment
float_kind
)
)
)
;
let
column_fragment
=
Fragment
:
:
new
(
node
SpecificFragmentInfo
:
:
MulticolColumn
self
.
layout_context
)
;
let
column_flow
=
FlowRef
:
:
new
(
Arc
:
:
new
(
MulticolColumnFlow
:
:
from_fragment
(
column_fragment
)
)
)
;
let
construction_result
=
self
.
build_flow_for_block_like
(
column_flow
node
)
;
let
mut
abs_descendants
=
AbsoluteDescendants
:
:
new
(
)
;
if
let
ConstructionResult
:
:
Flow
(
column_flow
column_abs_descendants
)
=
construction_result
{
flow
.
add_new_child
(
column_flow
)
;
abs_descendants
.
push_descendants
(
column_abs_descendants
)
;
}
flow
.
finish
(
)
;
if
flow
.
is_absolute_containing_block
(
)
{
flow
.
set_absolute_descendants
(
abs_descendants
)
;
abs_descendants
=
AbsoluteDescendants
:
:
new
(
)
;
if
flow
:
:
base
(
&
*
flow
)
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
abs_descendants
.
push
(
flow
.
clone
(
)
)
;
}
}
ConstructionResult
:
:
Flow
(
flow
abs_descendants
)
}
fn
build_flow_for_table
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
float_value
:
Float
)
-
>
ConstructionResult
{
let
mut
legalizer
=
Legalizer
:
:
new
(
)
;
let
table_style
;
let
wrapper_style
;
{
let
context
=
self
.
style_context
(
)
;
table_style
=
node
.
style
(
context
)
;
wrapper_style
=
context
.
stylist
.
style_for_anonymous
(
&
context
.
guards
&
PseudoElement
:
:
ServoTableWrapper
&
table_style
)
;
}
let
wrapper_fragment
=
Fragment
:
:
from_opaque_node_and_style
(
node
.
opaque
(
)
PseudoElementType
:
:
Normal
wrapper_style
node
.
selected_style
(
)
node
.
restyle_damage
(
)
SpecificFragmentInfo
:
:
TableWrapper
)
;
let
wrapper_float_kind
=
FloatKind
:
:
from_property
(
float_value
)
;
let
mut
wrapper_flow
=
FlowRef
:
:
new
(
Arc
:
:
new
(
TableWrapperFlow
:
:
from_fragment_and_float_kind
(
wrapper_fragment
wrapper_float_kind
)
)
)
;
let
table_fragment
=
Fragment
:
:
new
(
node
SpecificFragmentInfo
:
:
Table
self
.
layout_context
)
;
let
table_flow
=
FlowRef
:
:
new
(
Arc
:
:
new
(
TableFlow
:
:
from_fragment
(
table_fragment
)
)
)
;
let
construction_result
=
self
.
build_flow_for_block_like
(
table_flow
node
)
;
let
mut
abs_descendants
=
AbsoluteDescendants
:
:
new
(
)
;
self
.
place_table_caption_under_table_wrapper_on_side
(
&
mut
wrapper_flow
node
CaptionSide
:
:
Top
)
;
if
let
ConstructionResult
:
:
Flow
(
table_flow
table_abs_descendants
)
=
construction_result
{
legalizer
.
add_child
(
self
.
style_context
(
)
&
mut
wrapper_flow
table_flow
)
;
abs_descendants
.
push_descendants
(
table_abs_descendants
)
;
}
self
.
place_table_caption_under_table_wrapper_on_side
(
&
mut
wrapper_flow
node
CaptionSide
:
:
Bottom
)
;
legalizer
.
finish
(
&
mut
wrapper_flow
)
;
wrapper_flow
.
finish
(
)
;
if
wrapper_flow
.
is_absolute_containing_block
(
)
{
wrapper_flow
.
set_absolute_descendants
(
abs_descendants
)
;
abs_descendants
=
AbsoluteDescendants
:
:
new
(
)
;
if
flow
:
:
base
(
&
*
wrapper_flow
)
.
flags
.
contains
(
FlowFlags
:
:
IS_ABSOLUTELY_POSITIONED
)
{
abs_descendants
.
push
(
wrapper_flow
.
clone
(
)
)
;
}
}
ConstructionResult
:
:
Flow
(
wrapper_flow
abs_descendants
)
}
fn
build_flow_for_table_caption
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
fragment
=
self
.
build_fragment_for_block
(
node
)
;
let
flow
=
FlowRef
:
:
new
(
Arc
:
:
new
(
TableCaptionFlow
:
:
from_fragment
(
fragment
)
)
)
;
self
.
build_flow_for_block_like
(
flow
node
)
}
fn
build_flow_for_table_rowgroup
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
fragment
=
Fragment
:
:
new
(
node
SpecificFragmentInfo
:
:
TableRow
self
.
layout_context
)
;
let
flow
=
FlowRef
:
:
new
(
Arc
:
:
new
(
TableRowGroupFlow
:
:
from_fragment
(
fragment
)
)
)
;
self
.
build_flow_for_block_like
(
flow
node
)
}
fn
build_flow_for_table_row
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
fragment
=
Fragment
:
:
new
(
node
SpecificFragmentInfo
:
:
TableRow
self
.
layout_context
)
;
let
flow
=
FlowRef
:
:
new
(
Arc
:
:
new
(
TableRowFlow
:
:
from_fragment
(
fragment
)
)
)
;
self
.
build_flow_for_block_like
(
flow
node
)
}
fn
build_flow_for_table_cell
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
fragment
=
Fragment
:
:
new
(
node
SpecificFragmentInfo
:
:
TableCell
self
.
layout_context
)
;
let
hide
=
node
.
style
(
self
.
style_context
(
)
)
.
get_inheritedtable
(
)
.
empty_cells
=
=
EmptyCells
:
:
Hide
&
&
node
.
children
(
)
.
all
(
|
kid
|
{
let
position
=
kid
.
style
(
self
.
style_context
(
)
)
.
get_box
(
)
.
position
;
!
kid
.
is_content
(
)
|
|
position
=
=
Position
:
:
Absolute
|
|
position
=
=
Position
:
:
Fixed
}
)
;
let
flow
=
FlowRef
:
:
new
(
Arc
:
:
new
(
TableCellFlow
:
:
from_node_fragment_and_visibility_flag
(
node
fragment
!
hide
)
)
)
;
self
.
build_flow_for_block_like
(
flow
node
)
}
fn
build_flow_for_list_item
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
flotation
:
Float
)
-
>
ConstructionResult
{
let
flotation
=
FloatKind
:
:
from_property
(
flotation
)
;
let
marker_fragments
=
match
node
.
style
(
self
.
style_context
(
)
)
.
get_list
(
)
.
list_style_image
{
list_style_image
:
:
computed_value
:
:
T
(
Either
:
:
First
(
ref
url_value
)
)
=
>
{
let
image_info
=
Box
:
:
new
(
ImageFragmentInfo
:
:
new
(
url_value
.
url
(
)
.
map
(
|
u
|
u
.
clone
(
)
)
node
&
self
.
layout_context
)
)
;
vec
!
[
Fragment
:
:
new
(
node
SpecificFragmentInfo
:
:
Image
(
image_info
)
self
.
layout_context
)
]
}
list_style_image
:
:
computed_value
:
:
T
(
Either
:
:
Second
(
_none
)
)
=
>
{
match
ListStyleTypeContent
:
:
from_list_style_type
(
node
.
style
(
self
.
style_context
(
)
)
.
get_list
(
)
.
list_style_type
)
{
ListStyleTypeContent
:
:
None
=
>
Vec
:
:
new
(
)
ListStyleTypeContent
:
:
StaticText
(
ch
)
=
>
{
let
text
=
format
!
(
"
{
}
\
u
{
a0
}
"
ch
)
;
let
mut
unscanned_marker_fragments
=
LinkedList
:
:
new
(
)
;
unscanned_marker_fragments
.
push_back
(
Fragment
:
:
new
(
node
SpecificFragmentInfo
:
:
UnscannedText
(
Box
:
:
new
(
UnscannedTextFragmentInfo
:
:
new
(
text
None
)
)
)
self
.
layout_context
)
)
;
let
marker_fragments
=
with_thread_local_font_context
(
self
.
layout_context
|
mut
font_context
|
{
TextRunScanner
:
:
new
(
)
.
scan_for_runs
(
&
mut
font_context
unscanned_marker_fragments
)
}
)
;
marker_fragments
.
fragments
}
ListStyleTypeContent
:
:
GeneratedContent
(
info
)
=
>
{
vec
!
[
Fragment
:
:
new
(
node
SpecificFragmentInfo
:
:
GeneratedContent
(
info
)
self
.
layout_context
)
]
}
}
}
}
;
let
mut
initial_fragments
=
IntermediateInlineFragments
:
:
new
(
)
;
let
main_fragment
=
self
.
build_fragment_for_block
(
node
)
;
let
flow
=
match
node
.
style
(
self
.
style_context
(
)
)
.
get_list
(
)
.
list_style_position
{
ListStylePosition
:
:
Outside
=
>
{
Arc
:
:
new
(
ListItemFlow
:
:
from_fragments_and_flotation
(
main_fragment
marker_fragments
flotation
)
)
}
ListStylePosition
:
:
Inside
=
>
{
for
marker_fragment
in
marker_fragments
{
initial_fragments
.
fragments
.
push_back
(
marker_fragment
)
}
Arc
:
:
new
(
ListItemFlow
:
:
from_fragments_and_flotation
(
main_fragment
vec
!
[
]
flotation
)
)
}
}
;
self
.
build_flow_for_block_starting_with_fragments
(
FlowRef
:
:
new
(
flow
)
node
initial_fragments
)
}
fn
build_fragments_for_table_column
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
ConstructionResult
{
for
kid
in
node
.
children
(
)
{
self
.
set_flow_construction_result
(
&
kid
ConstructionResult
:
:
None
)
}
let
specific
=
SpecificFragmentInfo
:
:
TableColumn
(
TableColumnFragmentInfo
:
:
new
(
node
)
)
;
let
construction_item
=
ConstructionItem
:
:
TableColumnFragment
(
Fragment
:
:
new
(
node
specific
self
.
layout_context
)
)
;
ConstructionResult
:
:
ConstructionItem
(
construction_item
)
}
fn
build_flow_for_table_colgroup
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
ConstructionResult
{
let
fragment
=
Fragment
:
:
new
(
node
SpecificFragmentInfo
:
:
TableColumn
(
TableColumnFragmentInfo
:
:
new
(
node
)
)
self
.
layout_context
)
;
let
mut
col_fragments
=
vec
!
(
)
;
for
kid
in
node
.
children
(
)
{
if
let
ConstructionResult
:
:
ConstructionItem
(
ConstructionItem
:
:
TableColumnFragment
(
fragment
)
)
=
kid
.
get_construction_result
(
)
{
col_fragments
.
push
(
fragment
)
}
}
if
col_fragments
.
is_empty
(
)
{
debug
!
(
"
add
SpecificFragmentInfo
:
:
TableColumn
for
empty
colgroup
"
)
;
let
specific
=
SpecificFragmentInfo
:
:
TableColumn
(
TableColumnFragmentInfo
:
:
new
(
node
)
)
;
col_fragments
.
push
(
Fragment
:
:
new
(
node
specific
self
.
layout_context
)
)
;
}
let
mut
flow
=
FlowRef
:
:
new
(
Arc
:
:
new
(
TableColGroupFlow
:
:
from_fragments
(
fragment
col_fragments
)
)
)
;
flow
.
finish
(
)
;
ConstructionResult
:
:
Flow
(
flow
AbsoluteDescendants
:
:
new
(
)
)
}
fn
build_flow_for_flex
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
float_kind
:
Option
<
FloatKind
>
)
-
>
ConstructionResult
{
let
fragment
=
self
.
build_fragment_for_block
(
node
)
;
let
flow
=
FlowRef
:
:
new
(
Arc
:
:
new
(
FlexFlow
:
:
from_fragment
(
fragment
float_kind
)
)
)
;
self
.
build_flow_for_block_like
(
flow
node
)
}
pub
fn
repair_if_possible
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
)
-
>
bool
{
let
mut
need_to_reconstruct
=
false
;
if
node
.
style
(
self
.
style_context
(
)
)
.
get_box
(
)
.
clone_display
(
)
=
=
Display
:
:
None
{
return
false
;
}
for
kid
in
node
.
children
(
)
{
if
kid
.
flags
(
)
.
contains
(
LayoutDataFlags
:
:
HAS_NEWLY_CONSTRUCTED_FLOW
)
{
kid
.
remove_flags
(
LayoutDataFlags
:
:
HAS_NEWLY_CONSTRUCTED_FLOW
)
;
need_to_reconstruct
=
true
}
}
if
need_to_reconstruct
{
return
false
}
if
node
.
restyle_damage
(
)
.
contains
(
ServoRestyleDamage
:
:
RECONSTRUCT_FLOW
)
{
return
false
}
if
node
.
can_be_fragmented
(
)
|
|
node
.
style
(
self
.
style_context
(
)
)
.
is_multicol
(
)
{
return
false
}
let
mut
set_has_newly_constructed_flow_flag
=
false
;
let
result
=
{
let
style
=
node
.
style
(
self
.
style_context
(
)
)
;
let
damage
=
node
.
restyle_damage
(
)
;
let
mut
data
=
node
.
mutate_layout_data
(
)
.
unwrap
(
)
;
match
*
node
.
construction_result_mut
(
&
mut
*
data
)
{
ConstructionResult
:
:
None
=
>
true
ConstructionResult
:
:
Flow
(
ref
mut
flow
_
)
=
>
{
if
!
flow
.
is_block_flow
(
)
{
return
false
}
let
flow
=
FlowRef
:
:
deref_mut
(
flow
)
;
flow
:
:
mut_base
(
flow
)
.
restyle_damage
.
insert
(
damage
)
;
flow
.
repair_style_and_bubble_inline_sizes
(
&
style
)
;
true
}
ConstructionResult
:
:
ConstructionItem
(
ConstructionItem
:
:
InlineFragments
(
ref
mut
inline_fragments_construction_result
)
)
=
>
{
if
!
inline_fragments_construction_result
.
splits
.
is_empty
(
)
{
return
false
}
for
fragment
in
inline_fragments_construction_result
.
fragments
.
fragments
.
iter_mut
(
)
{
if
fragment
.
node
!
=
node
.
opaque
(
)
{
continue
}
if
fragment
.
pseudo
!
=
node
.
get_pseudo_element_type
(
)
.
strip
(
)
{
continue
}
match
fragment
.
specific
{
SpecificFragmentInfo
:
:
InlineBlock
(
ref
mut
inline_block_fragment
)
=
>
{
let
flow_ref
=
FlowRef
:
:
deref_mut
(
&
mut
inline_block_fragment
.
flow_ref
)
;
flow
:
:
mut_base
(
flow_ref
)
.
restyle_damage
.
insert
(
damage
)
;
flow_ref
.
repair_style_and_bubble_inline_sizes
(
&
style
)
;
}
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
ref
mut
inline_absolute_hypothetical_fragment
)
=
>
{
let
flow_ref
=
FlowRef
:
:
deref_mut
(
&
mut
inline_absolute_hypothetical_fragment
.
flow_ref
)
;
flow
:
:
mut_base
(
flow_ref
)
.
restyle_damage
.
insert
(
damage
)
;
flow_ref
.
repair_style_and_bubble_inline_sizes
(
&
style
)
;
}
SpecificFragmentInfo
:
:
InlineAbsolute
(
ref
mut
inline_absolute_fragment
)
=
>
{
let
flow_ref
=
FlowRef
:
:
deref_mut
(
&
mut
inline_absolute_fragment
.
flow_ref
)
;
flow
:
:
mut_base
(
flow_ref
)
.
restyle_damage
.
insert
(
damage
)
;
flow_ref
.
repair_style_and_bubble_inline_sizes
(
&
style
)
;
}
SpecificFragmentInfo
:
:
ScannedText
(
_
)
=
>
{
unreachable
!
(
)
}
SpecificFragmentInfo
:
:
GeneratedContent
(
_
)
|
SpecificFragmentInfo
:
:
UnscannedText
(
_
)
=
>
{
return
false
}
_
=
>
{
fragment
.
repair_style
(
&
style
)
;
set_has_newly_constructed_flow_flag
=
true
;
}
}
}
true
}
ConstructionResult
:
:
ConstructionItem
(
_
)
=
>
{
false
}
}
}
;
if
set_has_newly_constructed_flow_flag
{
node
.
insert_flags
(
LayoutDataFlags
:
:
HAS_NEWLY_CONSTRUCTED_FLOW
)
;
}
return
result
;
}
}
impl
<
'
a
ConcreteThreadSafeLayoutNode
>
PostorderNodeMutTraversal
<
ConcreteThreadSafeLayoutNode
>
for
FlowConstructor
<
'
a
ConcreteThreadSafeLayoutNode
>
where
ConcreteThreadSafeLayoutNode
:
ThreadSafeLayoutNode
{
fn
process
(
&
mut
self
node
:
&
ConcreteThreadSafeLayoutNode
)
{
node
.
insert_flags
(
LayoutDataFlags
:
:
HAS_NEWLY_CONSTRUCTED_FLOW
)
;
if
node
.
style
(
self
.
style_context
(
)
)
.
is_in_display_none_subtree
(
)
{
self
.
set_flow_construction_result
(
node
ConstructionResult
:
:
None
)
;
return
;
}
let
(
display
float
positioning
)
=
match
node
.
type_id
(
)
{
None
=
>
{
let
style
=
node
.
style
(
self
.
style_context
(
)
)
;
let
display
=
match
node
.
get_pseudo_element_type
(
)
{
PseudoElementType
:
:
Normal
=
>
Display
:
:
Inline
PseudoElementType
:
:
Before
(
maybe_display
)
|
PseudoElementType
:
:
After
(
maybe_display
)
|
PseudoElementType
:
:
DetailsContent
(
maybe_display
)
|
PseudoElementType
:
:
DetailsSummary
(
maybe_display
)
=
>
maybe_display
.
unwrap_or
(
style
.
get_box
(
)
.
display
)
}
;
(
display
style
.
get_box
(
)
.
float
style
.
get_box
(
)
.
position
)
}
Some
(
LayoutNodeType
:
:
Element
(
_
)
)
=
>
{
let
style
=
node
.
style
(
self
.
style_context
(
)
)
;
let
original_display
=
style
.
get_box
(
)
.
_servo_display_for_hypothetical_box
;
let
munged_display
=
match
original_display
{
Display
:
:
Inline
|
Display
:
:
InlineBlock
=
>
original_display
_
=
>
style
.
get_box
(
)
.
display
}
;
(
munged_display
style
.
get_box
(
)
.
float
style
.
get_box
(
)
.
position
)
}
Some
(
LayoutNodeType
:
:
Text
)
=
>
(
Display
:
:
Inline
Float
:
:
None
Position
:
:
Static
)
}
;
debug
!
(
"
building
flow
for
node
:
{
:
?
}
{
:
?
}
{
:
?
}
{
:
?
}
"
display
float
positioning
node
.
type_id
(
)
)
;
match
(
display
float
positioning
)
{
(
Display
:
:
None
_
_
)
=
>
{
self
.
set_flow_construction_result
(
node
ConstructionResult
:
:
None
)
;
}
(
Display
:
:
Table
float_value
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_table
(
node
float_value
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
Block
_
Position
:
:
Absolute
)
|
(
Display
:
:
Block
_
Position
:
:
Fixed
)
=
>
{
let
construction_result
=
self
.
build_flow_for_block
(
node
None
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
ListItem
float_value
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_list_item
(
node
float_value
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
Inline
_
Position
:
:
Absolute
)
|
(
Display
:
:
InlineBlock
_
Position
:
:
Absolute
)
=
>
{
let
construction_result
=
self
.
build_fragment_for_absolutely_positioned_inline
(
node
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
Inline
Float
:
:
None
_
)
=
>
{
let
construction_result
=
self
.
build_fragments_for_inline
(
node
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
InlineBlock
Float
:
:
None
_
)
=
>
{
let
construction_result
=
self
.
build_fragment_for_inline_block_or_inline_flex
(
node
Display
:
:
InlineBlock
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
TableCaption
_
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_table_caption
(
node
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
TableColumnGroup
_
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_table_colgroup
(
node
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
TableColumn
_
_
)
=
>
{
let
construction_result
=
self
.
build_fragments_for_table_column
(
node
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
TableRowGroup
_
_
)
|
(
Display
:
:
TableHeaderGroup
_
_
)
|
(
Display
:
:
TableFooterGroup
_
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_table_rowgroup
(
node
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
TableRow
_
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_table_row
(
node
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
TableCell
_
_
)
=
>
{
let
construction_result
=
self
.
build_flow_for_table_cell
(
node
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
Flex
float_value
_
)
=
>
{
let
float_kind
=
FloatKind
:
:
from_property
(
float_value
)
;
let
construction_result
=
self
.
build_flow_for_flex
(
node
float_kind
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
Display
:
:
InlineFlex
_
_
)
=
>
{
let
construction_result
=
self
.
build_fragment_for_inline_block_or_inline_flex
(
node
Display
:
:
InlineFlex
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
(
_
float_value
_
)
=
>
{
let
float_kind
=
FloatKind
:
:
from_property
(
float_value
)
;
let
construction_result
=
self
.
build_flow_for_block
(
node
float_kind
)
;
self
.
set_flow_construction_result
(
node
construction_result
)
}
}
}
}
trait
NodeUtils
{
fn
is_replaced_content
(
&
self
)
-
>
bool
;
fn
construction_result_mut
(
self
layout_data
:
&
mut
LayoutData
)
-
>
&
mut
ConstructionResult
;
fn
set_flow_construction_result
(
self
result
:
ConstructionResult
)
;
fn
get_construction_result
(
self
)
-
>
ConstructionResult
;
}
impl
<
ConcreteThreadSafeLayoutNode
>
NodeUtils
for
ConcreteThreadSafeLayoutNode
where
ConcreteThreadSafeLayoutNode
:
ThreadSafeLayoutNode
{
fn
is_replaced_content
(
&
self
)
-
>
bool
{
match
self
.
type_id
(
)
{
Some
(
LayoutNodeType
:
:
Text
)
|
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLImageElement
)
)
|
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLIFrameElement
)
)
|
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLCanvasElement
)
)
|
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
SVGSVGElement
)
)
=
>
true
Some
(
LayoutNodeType
:
:
Element
(
LayoutElementType
:
:
HTMLObjectElement
)
)
=
>
self
.
has_object_data
(
)
Some
(
LayoutNodeType
:
:
Element
(
_
)
)
=
>
false
None
=
>
self
.
get_pseudo_element_type
(
)
.
is_replaced_content
(
)
}
}
fn
construction_result_mut
(
self
data
:
&
mut
LayoutData
)
-
>
&
mut
ConstructionResult
{
match
self
.
get_pseudo_element_type
(
)
{
PseudoElementType
:
:
Before
(
_
)
=
>
&
mut
data
.
before_flow_construction_result
PseudoElementType
:
:
After
(
_
)
=
>
&
mut
data
.
after_flow_construction_result
PseudoElementType
:
:
DetailsSummary
(
_
)
=
>
&
mut
data
.
details_summary_flow_construction_result
PseudoElementType
:
:
DetailsContent
(
_
)
=
>
&
mut
data
.
details_content_flow_construction_result
PseudoElementType
:
:
Normal
=
>
&
mut
data
.
flow_construction_result
}
}
#
[
inline
(
always
)
]
fn
set_flow_construction_result
(
self
mut
result
:
ConstructionResult
)
{
if
self
.
can_be_fragmented
(
)
{
if
let
ConstructionResult
:
:
Flow
(
ref
mut
flow
_
)
=
result
{
flow
:
:
mut_base
(
FlowRef
:
:
deref_mut
(
flow
)
)
.
flags
.
insert
(
FlowFlags
:
:
CAN_BE_FRAGMENTED
)
;
}
}
let
mut
layout_data
=
self
.
mutate_layout_data
(
)
.
unwrap
(
)
;
let
dst
=
self
.
construction_result_mut
(
&
mut
*
layout_data
)
;
*
dst
=
result
;
}
#
[
inline
(
always
)
]
fn
get_construction_result
(
self
)
-
>
ConstructionResult
{
let
mut
layout_data
=
self
.
mutate_layout_data
(
)
.
unwrap
(
)
;
self
.
construction_result_mut
(
&
mut
*
layout_data
)
.
get
(
)
}
}
trait
ObjectElement
{
fn
has_object_data
(
&
self
)
-
>
bool
;
fn
object_data
(
&
self
)
-
>
Option
<
ServoUrl
>
;
}
impl
<
N
>
ObjectElement
for
N
where
N
:
ThreadSafeLayoutNode
{
fn
has_object_data
(
&
self
)
-
>
bool
{
let
elem
=
self
.
as_element
(
)
.
unwrap
(
)
;
let
type_and_data
=
(
elem
.
get_attr
(
&
ns
!
(
)
&
local_name
!
(
"
type
"
)
)
elem
.
get_attr
(
&
ns
!
(
)
&
local_name
!
(
"
data
"
)
)
)
;
match
type_and_data
{
(
None
Some
(
uri
)
)
=
>
is_image_data
(
uri
)
_
=
>
false
}
}
fn
object_data
(
&
self
)
-
>
Option
<
ServoUrl
>
{
let
elem
=
self
.
as_element
(
)
.
unwrap
(
)
;
let
type_and_data
=
(
elem
.
get_attr
(
&
ns
!
(
)
&
local_name
!
(
"
type
"
)
)
elem
.
get_attr
(
&
ns
!
(
)
&
local_name
!
(
"
data
"
)
)
)
;
match
type_and_data
{
(
None
Some
(
uri
)
)
if
is_image_data
(
uri
)
=
>
ServoUrl
:
:
parse
(
uri
)
.
ok
(
)
_
=
>
None
}
}
}
trait
FlowConstructionUtils
{
fn
add_new_child
(
&
mut
self
new_child
:
FlowRef
)
;
fn
finish
(
&
mut
self
)
;
}
impl
FlowConstructionUtils
for
FlowRef
{
fn
add_new_child
(
&
mut
self
mut
new_child
:
FlowRef
)
{
{
let
kid_base
=
flow
:
:
mut_base
(
FlowRef
:
:
deref_mut
(
&
mut
new_child
)
)
;
kid_base
.
parallel
.
parent
=
parallel
:
:
mut_owned_flow_to_unsafe_flow
(
self
)
;
}
let
base
=
flow
:
:
mut_base
(
FlowRef
:
:
deref_mut
(
self
)
)
;
base
.
children
.
push_back
(
new_child
)
;
let
_
=
base
.
parallel
.
children_count
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
fn
finish
(
&
mut
self
)
{
if
!
opts
:
:
get
(
)
.
bubble_inline_sizes_separately
{
FlowRef
:
:
deref_mut
(
self
)
.
bubble_inline_sizes
(
)
;
flow
:
:
mut_base
(
FlowRef
:
:
deref_mut
(
self
)
)
.
restyle_damage
.
remove
(
ServoRestyleDamage
:
:
BUBBLE_ISIZES
)
;
}
}
}
pub
fn
strip_ignorable_whitespace_from_start
(
this
:
&
mut
LinkedList
<
Fragment
>
)
{
if
this
.
is_empty
(
)
{
return
}
let
mut
leading_fragments_consisting_of_solely_bidi_control_characters
=
LinkedList
:
:
new
(
)
;
while
!
this
.
is_empty
(
)
{
match
this
.
front_mut
(
)
.
as_mut
(
)
.
unwrap
(
)
.
strip_leading_whitespace_if_necessary
(
)
{
WhitespaceStrippingResult
:
:
RetainFragment
=
>
break
WhitespaceStrippingResult
:
:
FragmentContainedOnlyBidiControlCharacters
=
>
{
leading_fragments_consisting_of_solely_bidi_control_characters
.
push_back
(
this
.
pop_front
(
)
.
unwrap
(
)
)
}
WhitespaceStrippingResult
:
:
FragmentContainedOnlyWhitespace
=
>
{
let
removed_fragment
=
this
.
pop_front
(
)
.
unwrap
(
)
;
if
let
Some
(
ref
mut
remaining_fragment
)
=
this
.
front_mut
(
)
{
remaining_fragment
.
meld_with_prev_inline_fragment
(
&
removed_fragment
)
;
}
}
}
}
prepend_from
(
this
&
mut
leading_fragments_consisting_of_solely_bidi_control_characters
)
;
}
pub
fn
strip_ignorable_whitespace_from_end
(
this
:
&
mut
LinkedList
<
Fragment
>
)
{
if
this
.
is_empty
(
)
{
return
}
let
mut
trailing_fragments_consisting_of_solely_bidi_control_characters
=
LinkedList
:
:
new
(
)
;
while
!
this
.
is_empty
(
)
{
match
this
.
back_mut
(
)
.
as_mut
(
)
.
unwrap
(
)
.
strip_trailing_whitespace_if_necessary
(
)
{
WhitespaceStrippingResult
:
:
RetainFragment
=
>
break
WhitespaceStrippingResult
:
:
FragmentContainedOnlyBidiControlCharacters
=
>
{
trailing_fragments_consisting_of_solely_bidi_control_characters
.
push_front
(
this
.
pop_back
(
)
.
unwrap
(
)
)
}
WhitespaceStrippingResult
:
:
FragmentContainedOnlyWhitespace
=
>
{
let
removed_fragment
=
this
.
pop_back
(
)
.
unwrap
(
)
;
if
let
Some
(
ref
mut
remaining_fragment
)
=
this
.
back_mut
(
)
{
remaining_fragment
.
meld_with_next_inline_fragment
(
&
removed_fragment
)
;
}
}
}
}
this
.
append
(
&
mut
trailing_fragments_consisting_of_solely_bidi_control_characters
)
;
}
fn
bidi_control_chars
(
style
:
&
ServoArc
<
ComputedValues
>
)
-
>
Option
<
(
&
'
static
str
&
'
static
str
)
>
{
use
style
:
:
computed_values
:
:
direction
:
:
T
:
:
*
;
use
style
:
:
computed_values
:
:
unicode_bidi
:
:
T
:
:
*
;
let
unicode_bidi
=
style
.
get_text
(
)
.
unicode_bidi
;
let
direction
=
style
.
get_inheritedbox
(
)
.
direction
;
match
(
unicode_bidi
direction
)
{
(
Normal
_
)
=
>
None
(
Embed
Ltr
)
=
>
Some
(
(
"
\
u
{
202A
}
"
"
\
u
{
202C
}
"
)
)
(
Embed
Rtl
)
=
>
Some
(
(
"
\
u
{
202B
}
"
"
\
u
{
202C
}
"
)
)
(
Isolate
Ltr
)
=
>
Some
(
(
"
\
u
{
2066
}
"
"
\
u
{
2069
}
"
)
)
(
Isolate
Rtl
)
=
>
Some
(
(
"
\
u
{
2067
}
"
"
\
u
{
2069
}
"
)
)
(
BidiOverride
Ltr
)
=
>
Some
(
(
"
\
u
{
202D
}
"
"
\
u
{
202C
}
"
)
)
(
BidiOverride
Rtl
)
=
>
Some
(
(
"
\
u
{
202E
}
"
"
\
u
{
202C
}
"
)
)
(
IsolateOverride
Ltr
)
=
>
Some
(
(
"
\
u
{
2068
}
\
u
{
202D
}
"
"
\
u
{
202C
}
\
u
{
2069
}
"
)
)
(
IsolateOverride
Rtl
)
=
>
Some
(
(
"
\
u
{
2068
}
\
u
{
202E
}
"
"
\
u
{
202C
}
\
u
{
2069
}
"
)
)
(
Plaintext
_
)
=
>
Some
(
(
"
\
u
{
2068
}
"
"
\
u
{
2069
}
"
)
)
}
}
fn
control_chars_to_fragment
(
node
:
&
InlineFragmentNodeInfo
context
:
&
SharedStyleContext
text
:
&
str
restyle_damage
:
RestyleDamage
)
-
>
Fragment
{
let
info
=
SpecificFragmentInfo
:
:
UnscannedText
(
Box
:
:
new
(
UnscannedTextFragmentInfo
:
:
new
(
String
:
:
from
(
text
)
None
)
)
)
;
let
text_style
=
context
.
stylist
.
style_for_anonymous
(
&
context
.
guards
&
PseudoElement
:
:
ServoText
&
node
.
style
)
;
Fragment
:
:
from_opaque_node_and_style
(
node
.
address
node
.
pseudo
text_style
node
.
selected_style
.
clone
(
)
restyle_damage
info
)
}
trait
ComputedValueUtils
{
fn
has_padding_or_border
(
&
self
)
-
>
bool
;
}
impl
ComputedValueUtils
for
ComputedValues
{
fn
has_padding_or_border
(
&
self
)
-
>
bool
{
let
padding
=
self
.
get_padding
(
)
;
let
border
=
self
.
get_border
(
)
;
!
padding
.
padding_top
.
is_definitely_zero
(
)
|
|
!
padding
.
padding_right
.
is_definitely_zero
(
)
|
|
!
padding
.
padding_bottom
.
is_definitely_zero
(
)
|
|
!
padding
.
padding_left
.
is_definitely_zero
(
)
|
|
border
.
border_top_width
.
px
(
)
!
=
0
.
|
|
border
.
border_right_width
.
px
(
)
!
=
0
.
|
|
border
.
border_bottom_width
.
px
(
)
!
=
0
.
|
|
border
.
border_left_width
.
px
(
)
!
=
0
.
}
}
struct
Legalizer
{
stack
:
Vec
<
FlowRef
>
}
impl
Legalizer
{
fn
new
(
)
-
>
Legalizer
{
Legalizer
{
stack
:
vec
!
[
]
}
}
fn
add_child
(
&
mut
self
context
:
&
SharedStyleContext
parent
:
&
mut
FlowRef
mut
child
:
FlowRef
)
{
while
!
self
.
stack
.
is_empty
(
)
{
if
self
.
try_to_add_child
(
context
parent
&
mut
child
)
{
return
}
self
.
flush_top_of_stack
(
parent
)
}
while
!
self
.
try_to_add_child
(
context
parent
&
mut
child
)
{
self
.
push_next_anonymous_flow
(
context
parent
)
}
}
fn
finish
(
mut
self
parent
:
&
mut
FlowRef
)
{
while
!
self
.
stack
.
is_empty
(
)
{
self
.
flush_top_of_stack
(
parent
)
}
}
fn
try_to_add_child
(
&
mut
self
context
:
&
SharedStyleContext
parent
:
&
mut
FlowRef
child
:
&
mut
FlowRef
)
-
>
bool
{
let
parent
=
self
.
stack
.
last_mut
(
)
.
unwrap_or
(
parent
)
;
let
(
parent_class
child_class
)
=
(
parent
.
class
(
)
child
.
class
(
)
)
;
match
(
parent_class
child_class
)
{
(
FlowClass
:
:
TableWrapper
FlowClass
:
:
Table
)
|
(
FlowClass
:
:
Table
FlowClass
:
:
TableColGroup
)
|
(
FlowClass
:
:
Table
FlowClass
:
:
TableRowGroup
)
|
(
FlowClass
:
:
Table
FlowClass
:
:
TableRow
)
|
(
FlowClass
:
:
Table
FlowClass
:
:
TableCaption
)
|
(
FlowClass
:
:
TableRowGroup
FlowClass
:
:
TableRow
)
|
(
FlowClass
:
:
TableRow
FlowClass
:
:
TableCell
)
=
>
{
parent
.
add_new_child
(
(
*
child
)
.
clone
(
)
)
;
true
}
(
FlowClass
:
:
TableWrapper
_
)
|
(
FlowClass
:
:
Table
_
)
|
(
FlowClass
:
:
TableRowGroup
_
)
|
(
FlowClass
:
:
TableRow
_
)
|
(
_
FlowClass
:
:
Table
)
|
(
_
FlowClass
:
:
TableColGroup
)
|
(
_
FlowClass
:
:
TableRowGroup
)
|
(
_
FlowClass
:
:
TableRow
)
|
(
_
FlowClass
:
:
TableCaption
)
|
(
_
FlowClass
:
:
TableCell
)
=
>
{
false
}
(
FlowClass
:
:
Flex
FlowClass
:
:
Inline
)
=
>
{
flow
:
:
mut_base
(
FlowRef
:
:
deref_mut
(
child
)
)
.
flags
.
insert
(
FlowFlags
:
:
MARGINS_CANNOT_COLLAPSE
)
;
let
mut
block_wrapper
=
Legalizer
:
:
create_anonymous_flow
(
context
parent
&
[
PseudoElement
:
:
ServoAnonymousBlock
]
SpecificFragmentInfo
:
:
Generic
BlockFlow
:
:
from_fragment
)
;
{
let
flag
=
if
parent
.
as_flex
(
)
.
main_mode
(
)
=
=
Direction
:
:
Inline
{
FragmentFlags
:
:
IS_INLINE_FLEX_ITEM
}
else
{
FragmentFlags
:
:
IS_BLOCK_FLEX_ITEM
}
;
let
block
=
FlowRef
:
:
deref_mut
(
&
mut
block_wrapper
)
.
as_mut_block
(
)
;
block
.
base
.
flags
.
insert
(
FlowFlags
:
:
MARGINS_CANNOT_COLLAPSE
)
;
block
.
fragment
.
flags
.
insert
(
flag
)
;
}
block_wrapper
.
add_new_child
(
(
*
child
)
.
clone
(
)
)
;
block_wrapper
.
finish
(
)
;
parent
.
add_new_child
(
block_wrapper
)
;
true
}
(
FlowClass
:
:
Flex
_
)
=
>
{
{
let
flag
=
if
parent
.
as_flex
(
)
.
main_mode
(
)
=
=
Direction
:
:
Inline
{
FragmentFlags
:
:
IS_INLINE_FLEX_ITEM
}
else
{
FragmentFlags
:
:
IS_BLOCK_FLEX_ITEM
}
;
let
block
=
FlowRef
:
:
deref_mut
(
child
)
.
as_mut_block
(
)
;
block
.
base
.
flags
.
insert
(
FlowFlags
:
:
MARGINS_CANNOT_COLLAPSE
)
;
block
.
fragment
.
flags
.
insert
(
flag
)
;
}
parent
.
add_new_child
(
(
*
child
)
.
clone
(
)
)
;
true
}
_
=
>
{
parent
.
add_new_child
(
(
*
child
)
.
clone
(
)
)
;
true
}
}
}
fn
flush_top_of_stack
(
&
mut
self
parent
:
&
mut
FlowRef
)
{
let
mut
child
=
self
.
stack
.
pop
(
)
.
expect
(
"
flush_top_of_stack
(
)
:
stack
empty
"
)
;
child
.
finish
(
)
;
self
.
stack
.
last_mut
(
)
.
unwrap_or
(
parent
)
.
add_new_child
(
child
)
}
fn
push_next_anonymous_flow
(
&
mut
self
context
:
&
SharedStyleContext
parent
:
&
FlowRef
)
{
let
parent_class
=
self
.
stack
.
last
(
)
.
unwrap_or
(
parent
)
.
class
(
)
;
match
parent_class
{
FlowClass
:
:
TableRow
=
>
{
self
.
push_new_anonymous_flow
(
context
parent
&
[
PseudoElement
:
:
ServoAnonymousTableCell
]
SpecificFragmentInfo
:
:
TableCell
TableCellFlow
:
:
from_fragment
)
}
FlowClass
:
:
Table
|
FlowClass
:
:
TableRowGroup
=
>
{
self
.
push_new_anonymous_flow
(
context
parent
&
[
PseudoElement
:
:
ServoAnonymousTableRow
]
SpecificFragmentInfo
:
:
TableRow
TableRowFlow
:
:
from_fragment
)
}
FlowClass
:
:
TableWrapper
=
>
{
self
.
push_new_anonymous_flow
(
context
parent
&
[
PseudoElement
:
:
ServoAnonymousTable
]
SpecificFragmentInfo
:
:
Table
TableFlow
:
:
from_fragment
)
}
_
=
>
{
self
.
push_new_anonymous_flow
(
context
parent
&
[
PseudoElement
:
:
ServoTableWrapper
PseudoElement
:
:
ServoAnonymousTableWrapper
]
SpecificFragmentInfo
:
:
TableWrapper
TableWrapperFlow
:
:
from_fragment
)
}
}
}
fn
push_new_anonymous_flow
<
F
>
(
&
mut
self
context
:
&
SharedStyleContext
reference
:
&
FlowRef
pseudos
:
&
[
PseudoElement
]
specific_fragment_info
:
SpecificFragmentInfo
constructor
:
extern
"
Rust
"
fn
(
Fragment
)
-
>
F
)
where
F
:
Flow
{
let
new_flow
=
Legalizer
:
:
create_anonymous_flow
(
context
reference
pseudos
specific_fragment_info
constructor
)
;
self
.
stack
.
push
(
new_flow
)
}
fn
create_anonymous_flow
<
F
>
(
context
:
&
SharedStyleContext
reference
:
&
FlowRef
pseudos
:
&
[
PseudoElement
]
specific_fragment_info
:
SpecificFragmentInfo
constructor
:
extern
"
Rust
"
fn
(
Fragment
)
-
>
F
)
-
>
FlowRef
where
F
:
Flow
{
let
reference_block
=
reference
.
as_block
(
)
;
let
mut
new_style
=
reference_block
.
fragment
.
style
.
clone
(
)
;
for
pseudo
in
pseudos
{
new_style
=
context
.
stylist
.
style_for_anonymous
(
&
context
.
guards
pseudo
&
new_style
)
}
let
fragment
=
reference_block
.
fragment
.
create_similar_anonymous_fragment
(
new_style
specific_fragment_info
)
;
FlowRef
:
:
new
(
Arc
:
:
new
(
constructor
(
fragment
)
)
)
}
}
