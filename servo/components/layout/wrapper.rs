#
!
[
allow
(
unsafe_code
)
]
use
atomic_refcell
:
:
{
AtomicRef
AtomicRefCell
AtomicRefMut
}
;
use
core
:
:
nonzero
:
:
NonZero
;
use
data
:
:
{
LayoutDataFlags
PersistentLayoutData
}
;
use
script_layout_interface
:
:
{
OpaqueStyleAndLayoutData
PartialPersistentLayoutData
}
;
use
script_layout_interface
:
:
wrapper_traits
:
:
{
LayoutNode
ThreadSafeLayoutElement
ThreadSafeLayoutNode
}
;
use
script_layout_interface
:
:
wrapper_traits
:
:
GetLayoutData
;
use
style
:
:
computed_values
:
:
content
:
:
{
self
ContentItem
}
;
use
style
:
:
dom
:
:
{
NodeInfo
TNode
}
;
use
style
:
:
selector_parser
:
:
RestyleDamage
;
pub
type
NonOpaqueStyleAndLayoutData
=
AtomicRefCell
<
PersistentLayoutData
>
;
pub
unsafe
fn
drop_style_and_layout_data
(
data
:
OpaqueStyleAndLayoutData
)
{
let
ptr
:
*
mut
AtomicRefCell
<
PartialPersistentLayoutData
>
=
*
data
.
ptr
;
let
non_opaque
:
*
mut
NonOpaqueStyleAndLayoutData
=
ptr
as
*
mut
_
;
let
_
=
Box
:
:
from_raw
(
non_opaque
)
;
}
pub
trait
LayoutNodeLayoutData
{
fn
borrow_layout_data
(
&
self
)
-
>
Option
<
AtomicRef
<
PersistentLayoutData
>
>
;
fn
mutate_layout_data
(
&
self
)
-
>
Option
<
AtomicRefMut
<
PersistentLayoutData
>
>
;
fn
flow_debug_id
(
self
)
-
>
usize
;
}
impl
<
T
:
GetLayoutData
>
LayoutNodeLayoutData
for
T
{
fn
borrow_layout_data
(
&
self
)
-
>
Option
<
AtomicRef
<
PersistentLayoutData
>
>
{
self
.
get_raw_data
(
)
.
map
(
|
d
|
d
.
borrow
(
)
)
}
fn
mutate_layout_data
(
&
self
)
-
>
Option
<
AtomicRefMut
<
PersistentLayoutData
>
>
{
self
.
get_raw_data
(
)
.
map
(
|
d
|
d
.
borrow_mut
(
)
)
}
fn
flow_debug_id
(
self
)
-
>
usize
{
self
.
borrow_layout_data
(
)
.
map_or
(
0
|
d
|
d
.
flow_construction_result
.
debug_id
(
)
)
}
}
pub
trait
GetRawData
{
fn
get_raw_data
(
&
self
)
-
>
Option
<
&
NonOpaqueStyleAndLayoutData
>
;
}
impl
<
T
:
GetLayoutData
>
GetRawData
for
T
{
fn
get_raw_data
(
&
self
)
-
>
Option
<
&
NonOpaqueStyleAndLayoutData
>
{
self
.
get_style_and_layout_data
(
)
.
map
(
|
opaque
|
{
let
container
=
*
opaque
.
ptr
as
*
mut
NonOpaqueStyleAndLayoutData
;
unsafe
{
&
*
container
}
}
)
}
}
pub
trait
LayoutNodeHelpers
{
fn
initialize_data
(
&
self
)
;
fn
clear_data
(
&
self
)
;
}
impl
<
T
:
LayoutNode
>
LayoutNodeHelpers
for
T
{
fn
initialize_data
(
&
self
)
{
if
self
.
get_raw_data
(
)
.
is_none
(
)
{
let
ptr
:
*
mut
NonOpaqueStyleAndLayoutData
=
Box
:
:
into_raw
(
box
AtomicRefCell
:
:
new
(
PersistentLayoutData
:
:
new
(
)
)
)
;
let
opaque
=
OpaqueStyleAndLayoutData
{
ptr
:
unsafe
{
NonZero
:
:
new
(
ptr
as
*
mut
AtomicRefCell
<
PartialPersistentLayoutData
>
)
}
}
;
unsafe
{
self
.
init_style_and_layout_data
(
opaque
)
}
;
}
;
}
fn
clear_data
(
&
self
)
{
if
self
.
get_raw_data
(
)
.
is_some
(
)
{
unsafe
{
drop_style_and_layout_data
(
self
.
take_style_and_layout_data
(
)
)
}
;
}
}
}
pub
trait
ThreadSafeLayoutNodeHelpers
{
fn
flags
(
self
)
-
>
LayoutDataFlags
;
fn
insert_flags
(
self
new_flags
:
LayoutDataFlags
)
;
fn
remove_flags
(
self
flags
:
LayoutDataFlags
)
;
fn
text_content
(
&
self
)
-
>
TextContent
;
fn
restyle_damage
(
self
)
-
>
RestyleDamage
;
}
impl
<
T
:
ThreadSafeLayoutNode
>
ThreadSafeLayoutNodeHelpers
for
T
{
fn
flags
(
self
)
-
>
LayoutDataFlags
{
self
.
borrow_layout_data
(
)
.
as_ref
(
)
.
unwrap
(
)
.
flags
}
fn
insert_flags
(
self
new_flags
:
LayoutDataFlags
)
{
self
.
mutate_layout_data
(
)
.
unwrap
(
)
.
flags
.
insert
(
new_flags
)
;
}
fn
remove_flags
(
self
flags
:
LayoutDataFlags
)
{
self
.
mutate_layout_data
(
)
.
unwrap
(
)
.
flags
.
remove
(
flags
)
;
}
fn
text_content
(
&
self
)
-
>
TextContent
{
if
self
.
get_pseudo_element_type
(
)
.
is_replaced_content
(
)
{
let
style
=
self
.
as_element
(
)
.
unwrap
(
)
.
resolved_style
(
)
;
return
match
style
.
as_ref
(
)
.
get_counters
(
)
.
content
{
content
:
:
T
:
:
Content
(
ref
value
)
if
!
value
.
is_empty
(
)
=
>
{
TextContent
:
:
GeneratedContent
(
(
*
value
)
.
clone
(
)
)
}
_
=
>
TextContent
:
:
GeneratedContent
(
vec
!
[
]
)
}
;
}
return
TextContent
:
:
Text
(
self
.
node_text_content
(
)
)
;
}
fn
restyle_damage
(
self
)
-
>
RestyleDamage
{
let
mut
node
=
unsafe
{
self
.
unsafe_get
(
)
}
;
if
node
.
is_text_node
(
)
{
node
=
node
.
parent_node
(
)
.
unwrap
(
)
;
debug_assert
!
(
node
.
is_element
(
)
)
;
}
let
data
=
node
.
borrow_layout_data
(
)
.
unwrap
(
)
;
if
let
Some
(
r
)
=
data
.
base
.
style_data
.
get_restyle
(
)
{
r
.
damage
}
else
if
!
data
.
flags
.
contains
(
:
:
data
:
:
HAS_BEEN_TRAVERSED
)
{
RestyleDamage
:
:
rebuild_and_reflow
(
)
}
else
{
RestyleDamage
:
:
empty
(
)
}
}
}
pub
enum
TextContent
{
Text
(
String
)
GeneratedContent
(
Vec
<
ContentItem
>
)
}
impl
TextContent
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
match
*
self
{
TextContent
:
:
Text
(
_
)
=
>
false
TextContent
:
:
GeneratedContent
(
ref
content
)
=
>
content
.
is_empty
(
)
}
}
}
