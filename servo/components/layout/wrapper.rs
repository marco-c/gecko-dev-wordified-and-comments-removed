#
!
[
allow
(
unsafe_code
)
]
use
atomic_refcell
:
:
{
AtomicRef
AtomicRefMut
}
;
use
data
:
:
{
LayoutData
LayoutDataFlags
StyleAndLayoutData
}
;
use
script_layout_interface
:
:
wrapper_traits
:
:
{
ThreadSafeLayoutElement
ThreadSafeLayoutNode
}
;
use
script_layout_interface
:
:
wrapper_traits
:
:
GetLayoutData
;
use
style
:
:
computed_values
:
:
content
:
:
{
self
ContentItem
}
;
use
style
:
:
dom
:
:
{
NodeInfo
TNode
}
;
use
style
:
:
selector_parser
:
:
RestyleDamage
;
pub
trait
LayoutNodeLayoutData
{
fn
borrow_layout_data
(
&
self
)
-
>
Option
<
AtomicRef
<
LayoutData
>
>
;
fn
mutate_layout_data
(
&
self
)
-
>
Option
<
AtomicRefMut
<
LayoutData
>
>
;
fn
flow_debug_id
(
self
)
-
>
usize
;
}
impl
<
T
:
GetLayoutData
>
LayoutNodeLayoutData
for
T
{
fn
borrow_layout_data
(
&
self
)
-
>
Option
<
AtomicRef
<
LayoutData
>
>
{
self
.
get_raw_data
(
)
.
map
(
|
d
|
d
.
layout_data
.
borrow
(
)
)
}
fn
mutate_layout_data
(
&
self
)
-
>
Option
<
AtomicRefMut
<
LayoutData
>
>
{
self
.
get_raw_data
(
)
.
map
(
|
d
|
d
.
layout_data
.
borrow_mut
(
)
)
}
fn
flow_debug_id
(
self
)
-
>
usize
{
self
.
borrow_layout_data
(
)
.
map_or
(
0
|
d
|
d
.
flow_construction_result
.
debug_id
(
)
)
}
}
pub
trait
GetRawData
{
fn
get_raw_data
(
&
self
)
-
>
Option
<
&
StyleAndLayoutData
>
;
}
impl
<
T
:
GetLayoutData
>
GetRawData
for
T
{
fn
get_raw_data
(
&
self
)
-
>
Option
<
&
StyleAndLayoutData
>
{
self
.
get_style_and_layout_data
(
)
.
map
(
|
opaque
|
{
let
container
=
opaque
.
ptr
.
get
(
)
as
*
mut
StyleAndLayoutData
;
unsafe
{
&
*
container
}
}
)
}
}
pub
trait
ThreadSafeLayoutNodeHelpers
{
fn
flags
(
self
)
-
>
LayoutDataFlags
;
fn
insert_flags
(
self
new_flags
:
LayoutDataFlags
)
;
fn
remove_flags
(
self
flags
:
LayoutDataFlags
)
;
fn
text_content
(
&
self
)
-
>
TextContent
;
fn
restyle_damage
(
self
)
-
>
RestyleDamage
;
}
impl
<
T
:
ThreadSafeLayoutNode
>
ThreadSafeLayoutNodeHelpers
for
T
{
fn
flags
(
self
)
-
>
LayoutDataFlags
{
self
.
borrow_layout_data
(
)
.
as_ref
(
)
.
unwrap
(
)
.
flags
}
fn
insert_flags
(
self
new_flags
:
LayoutDataFlags
)
{
self
.
mutate_layout_data
(
)
.
unwrap
(
)
.
flags
.
insert
(
new_flags
)
;
}
fn
remove_flags
(
self
flags
:
LayoutDataFlags
)
{
self
.
mutate_layout_data
(
)
.
unwrap
(
)
.
flags
.
remove
(
flags
)
;
}
fn
text_content
(
&
self
)
-
>
TextContent
{
if
self
.
get_pseudo_element_type
(
)
.
is_replaced_content
(
)
{
let
style
=
self
.
as_element
(
)
.
unwrap
(
)
.
resolved_style
(
)
;
return
match
style
.
as_ref
(
)
.
get_counters
(
)
.
content
{
content
:
:
T
:
:
Items
(
ref
value
)
if
!
value
.
is_empty
(
)
=
>
{
TextContent
:
:
GeneratedContent
(
(
*
value
)
.
clone
(
)
)
}
_
=
>
TextContent
:
:
GeneratedContent
(
vec
!
[
]
)
}
;
}
return
TextContent
:
:
Text
(
self
.
node_text_content
(
)
)
;
}
fn
restyle_damage
(
self
)
-
>
RestyleDamage
{
let
mut
node
=
unsafe
{
self
.
unsafe_get
(
)
}
;
if
node
.
is_text_node
(
)
{
node
=
node
.
parent_node
(
)
.
unwrap
(
)
;
debug_assert
!
(
node
.
is_element
(
)
)
;
}
let
damage
=
{
let
data
=
node
.
get_raw_data
(
)
.
unwrap
(
)
;
if
!
data
.
layout_data
.
borrow
(
)
.
flags
.
contains
(
:
:
data
:
:
HAS_BEEN_TRAVERSED
)
{
RestyleDamage
:
:
rebuild_and_reflow
(
)
}
else
{
data
.
style_data
.
element_data
.
borrow
(
)
.
restyle
.
damage
}
}
;
damage
}
}
pub
enum
TextContent
{
Text
(
String
)
GeneratedContent
(
Vec
<
ContentItem
>
)
}
impl
TextContent
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
match
*
self
{
TextContent
:
:
Text
(
_
)
=
>
false
TextContent
:
:
GeneratedContent
(
ref
content
)
=
>
content
.
is_empty
(
)
}
}
}
