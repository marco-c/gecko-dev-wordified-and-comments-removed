#
!
[
allow
(
unsafe_code
)
]
use
core
:
:
nonzero
:
:
NonZero
;
use
data
:
:
{
LayoutDataFlags
PersistentLayoutData
}
;
use
script_layout_interface
:
:
{
OpaqueStyleAndLayoutData
PartialPersistentLayoutData
}
;
use
script_layout_interface
:
:
wrapper_traits
:
:
{
GetLayoutData
LayoutNode
}
;
use
script_layout_interface
:
:
wrapper_traits
:
:
{
ThreadSafeLayoutElement
ThreadSafeLayoutNode
}
;
use
style
:
:
atomic_refcell
:
:
{
AtomicRef
AtomicRefCell
AtomicRefMut
}
;
use
style
:
:
computed_values
:
:
content
:
:
{
self
ContentItem
}
;
pub
type
NonOpaqueStyleAndLayoutData
=
*
mut
AtomicRefCell
<
PersistentLayoutData
>
;
pub
trait
LayoutNodeLayoutData
{
fn
borrow_layout_data
(
&
self
)
-
>
Option
<
AtomicRef
<
PersistentLayoutData
>
>
;
fn
mutate_layout_data
(
&
self
)
-
>
Option
<
AtomicRefMut
<
PersistentLayoutData
>
>
;
fn
flow_debug_id
(
self
)
-
>
usize
;
}
impl
<
T
:
GetLayoutData
>
LayoutNodeLayoutData
for
T
{
fn
borrow_layout_data
(
&
self
)
-
>
Option
<
AtomicRef
<
PersistentLayoutData
>
>
{
unsafe
{
self
.
get_style_and_layout_data
(
)
.
map
(
|
opaque
|
{
let
container
=
*
opaque
.
ptr
as
NonOpaqueStyleAndLayoutData
;
(
*
container
)
.
borrow
(
)
}
)
}
}
fn
mutate_layout_data
(
&
self
)
-
>
Option
<
AtomicRefMut
<
PersistentLayoutData
>
>
{
unsafe
{
self
.
get_style_and_layout_data
(
)
.
map
(
|
opaque
|
{
let
container
=
*
opaque
.
ptr
as
NonOpaqueStyleAndLayoutData
;
(
*
container
)
.
borrow_mut
(
)
}
)
}
}
fn
flow_debug_id
(
self
)
-
>
usize
{
self
.
borrow_layout_data
(
)
.
map_or
(
0
|
d
|
d
.
flow_construction_result
.
debug_id
(
)
)
}
}
pub
trait
LayoutNodeHelpers
{
fn
initialize_data
(
self
)
;
}
impl
<
T
:
LayoutNode
>
LayoutNodeHelpers
for
T
{
fn
initialize_data
(
self
)
{
if
self
.
borrow_layout_data
(
)
.
is_none
(
)
{
let
ptr
:
NonOpaqueStyleAndLayoutData
=
Box
:
:
into_raw
(
box
AtomicRefCell
:
:
new
(
PersistentLayoutData
:
:
new
(
)
)
)
;
let
opaque
=
OpaqueStyleAndLayoutData
{
ptr
:
unsafe
{
NonZero
:
:
new
(
ptr
as
*
mut
AtomicRefCell
<
PartialPersistentLayoutData
>
)
}
}
;
self
.
init_style_and_layout_data
(
opaque
)
;
}
}
}
pub
trait
ThreadSafeLayoutNodeHelpers
{
fn
flags
(
self
)
-
>
LayoutDataFlags
;
fn
insert_flags
(
self
new_flags
:
LayoutDataFlags
)
;
fn
remove_flags
(
self
flags
:
LayoutDataFlags
)
;
fn
text_content
(
&
self
)
-
>
TextContent
;
}
impl
<
T
:
ThreadSafeLayoutNode
>
ThreadSafeLayoutNodeHelpers
for
T
{
fn
flags
(
self
)
-
>
LayoutDataFlags
{
self
.
borrow_layout_data
(
)
.
as_ref
(
)
.
unwrap
(
)
.
flags
}
fn
insert_flags
(
self
new_flags
:
LayoutDataFlags
)
{
self
.
mutate_layout_data
(
)
.
unwrap
(
)
.
flags
.
insert
(
new_flags
)
;
}
fn
remove_flags
(
self
flags
:
LayoutDataFlags
)
{
self
.
mutate_layout_data
(
)
.
unwrap
(
)
.
flags
.
remove
(
flags
)
;
}
fn
text_content
(
&
self
)
-
>
TextContent
{
if
self
.
get_pseudo_element_type
(
)
.
is_replaced_content
(
)
{
let
style
=
self
.
as_element
(
)
.
unwrap
(
)
.
resolved_style
(
)
;
return
match
style
.
as_ref
(
)
.
get_counters
(
)
.
content
{
content
:
:
T
:
:
Content
(
ref
value
)
if
!
value
.
is_empty
(
)
=
>
{
TextContent
:
:
GeneratedContent
(
(
*
value
)
.
clone
(
)
)
}
_
=
>
TextContent
:
:
GeneratedContent
(
vec
!
[
]
)
}
;
}
return
TextContent
:
:
Text
(
self
.
node_text_content
(
)
)
;
}
}
pub
enum
TextContent
{
Text
(
String
)
GeneratedContent
(
Vec
<
ContentItem
>
)
}
impl
TextContent
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
match
*
self
{
TextContent
:
:
Text
(
_
)
=
>
false
TextContent
:
:
GeneratedContent
(
ref
content
)
=
>
content
.
is_empty
(
)
}
}
}
