use
app_units
:
:
Au
;
use
block
:
:
{
BlockFlow
FormattingContextType
}
;
use
context
:
:
LayoutContext
;
use
display_list_builder
:
:
DisplayListBuildState
;
use
euclid
:
:
{
Matrix4D
Point2D
Rect
Size2D
}
;
use
flex
:
:
FlexFlow
;
use
floats
:
:
{
Floats
SpeculatedFloatPlacement
}
;
use
flow_list
:
:
{
FlowList
MutFlowListIterator
}
;
use
flow_ref
:
:
{
FlowRef
WeakFlowRef
}
;
use
fragment
:
:
{
CoordinateSystem
Fragment
FragmentBorderBoxIterator
Overflow
}
;
use
gfx_traits
:
:
{
ScrollRootId
StackingContextId
}
;
use
gfx_traits
:
:
print_tree
:
:
PrintTree
;
use
inline
:
:
InlineFlow
;
use
model
:
:
{
CollapsibleMargins
IntrinsicISizes
MarginCollapseInfo
}
;
use
multicol
:
:
MulticolFlow
;
use
parallel
:
:
FlowParallelInfo
;
use
serde
:
:
ser
:
:
{
Serialize
SerializeStruct
Serializer
}
;
use
servo_geometry
:
:
{
au_rect_to_f32_rect
f32_rect_to_au_rect
max_rect
}
;
use
std
:
:
{
fmt
mem
raw
}
;
use
std
:
:
iter
:
:
Zip
;
use
std
:
:
slice
:
:
IterMut
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
use
style
:
:
computed_values
:
:
{
clear
float
overflow_x
position
text_align
}
;
use
style
:
:
context
:
:
SharedStyleContext
;
use
style
:
:
logical_geometry
:
:
{
LogicalRect
LogicalSize
WritingMode
}
;
use
style
:
:
properties
:
:
ServoComputedValues
;
use
style
:
:
selector_parser
:
:
RestyleDamage
;
use
style
:
:
servo
:
:
restyle_damage
:
:
{
RECONSTRUCT_FLOW
REFLOW
REFLOW_OUT_OF_FLOW
REPAINT
REPOSITION
}
;
use
style
:
:
values
:
:
computed
:
:
LengthOrPercentageOrAuto
;
use
table
:
:
TableFlow
;
use
table_caption
:
:
TableCaptionFlow
;
use
table_cell
:
:
TableCellFlow
;
use
table_colgroup
:
:
TableColGroupFlow
;
use
table_row
:
:
TableRowFlow
;
use
table_rowgroup
:
:
TableRowGroupFlow
;
use
table_wrapper
:
:
TableWrapperFlow
;
pub
trait
Flow
:
fmt
:
:
Debug
+
Sync
+
Send
+
'
static
{
fn
class
(
&
self
)
-
>
FlowClass
;
fn
as_block
(
&
self
)
-
>
&
BlockFlow
{
panic
!
(
"
called
as_block
(
)
on
a
non
-
block
flow
"
)
}
fn
as_mut_block
(
&
mut
self
)
-
>
&
mut
BlockFlow
{
debug
!
(
"
called
as_mut_block
(
)
on
a
flow
of
type
{
:
?
}
"
self
.
class
(
)
)
;
panic
!
(
"
called
as_mut_block
(
)
on
a
non
-
block
flow
"
)
}
fn
as_flex
(
&
self
)
-
>
&
FlexFlow
{
panic
!
(
"
called
as_flex
(
)
on
a
non
-
flex
flow
"
)
}
fn
as_mut_flex
(
&
mut
self
)
-
>
&
mut
FlexFlow
{
panic
!
(
"
called
as_mut_flex
(
)
on
a
non
-
flex
flow
"
)
}
fn
as_inline
(
&
self
)
-
>
&
InlineFlow
{
panic
!
(
"
called
as_inline
(
)
on
a
non
-
inline
flow
"
)
}
fn
as_mut_inline
(
&
mut
self
)
-
>
&
mut
InlineFlow
{
panic
!
(
"
called
as_mut_inline
(
)
on
a
non
-
inline
flow
"
)
}
fn
as_mut_table_wrapper
(
&
mut
self
)
-
>
&
mut
TableWrapperFlow
{
panic
!
(
"
called
as_mut_table_wrapper
(
)
on
a
non
-
tablewrapper
flow
"
)
}
fn
as_table_wrapper
(
&
self
)
-
>
&
TableWrapperFlow
{
panic
!
(
"
called
as_table_wrapper
(
)
on
a
non
-
tablewrapper
flow
"
)
}
fn
as_mut_table
(
&
mut
self
)
-
>
&
mut
TableFlow
{
panic
!
(
"
called
as_mut_table
(
)
on
a
non
-
table
flow
"
)
}
fn
as_table
(
&
self
)
-
>
&
TableFlow
{
panic
!
(
"
called
as_table
(
)
on
a
non
-
table
flow
"
)
}
fn
as_mut_table_colgroup
(
&
mut
self
)
-
>
&
mut
TableColGroupFlow
{
panic
!
(
"
called
as_mut_table_colgroup
(
)
on
a
non
-
tablecolgroup
flow
"
)
}
fn
as_mut_table_rowgroup
(
&
mut
self
)
-
>
&
mut
TableRowGroupFlow
{
panic
!
(
"
called
as_mut_table_rowgroup
(
)
on
a
non
-
tablerowgroup
flow
"
)
}
fn
as_table_rowgroup
(
&
self
)
-
>
&
TableRowGroupFlow
{
panic
!
(
"
called
as_table_rowgroup
(
)
on
a
non
-
tablerowgroup
flow
"
)
}
fn
as_mut_table_row
(
&
mut
self
)
-
>
&
mut
TableRowFlow
{
panic
!
(
"
called
as_mut_table_row
(
)
on
a
non
-
tablerow
flow
"
)
}
fn
as_table_row
(
&
self
)
-
>
&
TableRowFlow
{
panic
!
(
"
called
as_table_row
(
)
on
a
non
-
tablerow
flow
"
)
}
fn
as_mut_table_caption
(
&
mut
self
)
-
>
&
mut
TableCaptionFlow
{
panic
!
(
"
called
as_mut_table_caption
(
)
on
a
non
-
tablecaption
flow
"
)
}
fn
as_mut_table_cell
(
&
mut
self
)
-
>
&
mut
TableCellFlow
{
panic
!
(
"
called
as_mut_table_cell
(
)
on
a
non
-
tablecell
flow
"
)
}
fn
as_mut_multicol
(
&
mut
self
)
-
>
&
mut
MulticolFlow
{
panic
!
(
"
called
as_mut_multicol
(
)
on
a
non
-
multicol
flow
"
)
}
fn
as_table_cell
(
&
self
)
-
>
&
TableCellFlow
{
panic
!
(
"
called
as_table_cell
(
)
on
a
non
-
tablecell
flow
"
)
}
fn
bubble_inline_sizes
(
&
mut
self
)
{
panic
!
(
"
bubble_inline_sizes
not
yet
implemented
"
)
}
fn
assign_inline_sizes
(
&
mut
self
_ctx
:
&
LayoutContext
)
{
panic
!
(
"
assign_inline_sizes
not
yet
implemented
"
)
}
fn
assign_block_size
(
&
mut
self
_ctx
:
&
LayoutContext
)
{
panic
!
(
"
assign_block_size
not
yet
implemented
"
)
}
fn
fragment
(
&
mut
self
layout_context
:
&
LayoutContext
_fragmentation_context
:
Option
<
FragmentationContext
>
)
-
>
Option
<
Arc
<
Flow
>
>
{
fn
recursive_assign_block_size
<
F
:
?
Sized
+
Flow
>
(
flow
:
&
mut
F
ctx
:
&
LayoutContext
)
{
for
child
in
mut_base
(
flow
)
.
children
.
iter_mut
(
)
{
recursive_assign_block_size
(
child
ctx
)
}
flow
.
assign_block_size
(
ctx
)
;
}
recursive_assign_block_size
(
self
layout_context
)
;
None
}
fn
collect_stacking_contexts
(
&
mut
self
state
:
&
mut
DisplayListBuildState
)
;
fn
place_float_if_applicable
<
'
a
>
(
&
mut
self
)
{
}
fn
assign_block_size_for_inorder_child_if_necessary
(
&
mut
self
layout_context
:
&
LayoutContext
parent_thread_id
:
u8
_content_box
:
LogicalRect
<
Au
>
)
-
>
bool
{
let
might_have_floats_in_or_out
=
base
(
self
)
.
might_have_floats_in
(
)
|
|
base
(
self
)
.
might_have_floats_out
(
)
;
if
might_have_floats_in_or_out
{
mut_base
(
self
)
.
thread_id
=
parent_thread_id
;
self
.
assign_block_size
(
layout_context
)
;
mut_base
(
self
)
.
restyle_damage
.
remove
(
REFLOW_OUT_OF_FLOW
|
REFLOW
)
;
}
might_have_floats_in_or_out
}
fn
get_overflow_in_parent_coordinates
(
&
self
)
-
>
Overflow
{
let
container_size
=
Size2D
:
:
zero
(
)
;
let
position
=
base
(
self
)
.
position
.
to_physical
(
base
(
self
)
.
writing_mode
container_size
)
;
let
mut
overflow
=
base
(
self
)
.
overflow
;
match
self
.
class
(
)
{
FlowClass
:
:
Block
|
FlowClass
:
:
TableCaption
|
FlowClass
:
:
TableCell
=
>
{
}
_
=
>
{
overflow
.
translate
(
&
position
.
origin
)
;
return
overflow
;
}
}
let
border_box
=
self
.
as_block
(
)
.
fragment
.
stacking_relative_border_box
(
&
base
(
self
)
.
stacking_relative_position
&
base
(
self
)
.
early_absolute_position_info
.
relative_containing_block_size
base
(
self
)
.
early_absolute_position_info
.
relative_containing_block_mode
CoordinateSystem
:
:
Own
)
;
if
overflow_x
:
:
T
:
:
visible
!
=
self
.
as_block
(
)
.
fragment
.
style
.
get_box
(
)
.
overflow_x
{
overflow
.
paint
.
origin
.
x
=
Au
(
0
)
;
overflow
.
paint
.
size
.
width
=
border_box
.
size
.
width
;
overflow
.
scroll
.
origin
.
x
=
Au
(
0
)
;
overflow
.
scroll
.
size
.
width
=
border_box
.
size
.
width
;
}
if
overflow_x
:
:
T
:
:
visible
!
=
self
.
as_block
(
)
.
fragment
.
style
.
get_box
(
)
.
overflow_y
.
0
{
overflow
.
paint
.
origin
.
y
=
Au
(
0
)
;
overflow
.
paint
.
size
.
height
=
border_box
.
size
.
height
;
overflow
.
scroll
.
origin
.
y
=
Au
(
0
)
;
overflow
.
scroll
.
size
.
height
=
border_box
.
size
.
height
;
}
if
!
self
.
as_block
(
)
.
fragment
.
establishes_stacking_context
(
)
|
|
self
.
as_block
(
)
.
fragment
.
style
.
get_box
(
)
.
transform
.
0
.
is_none
(
)
{
overflow
.
translate
(
&
position
.
origin
)
;
return
overflow
;
}
let
transform_2d
=
self
.
as_block
(
)
.
fragment
.
transform_matrix
(
&
position
)
.
unwrap_or
(
Matrix4D
:
:
identity
(
)
)
.
to_2d
(
)
;
let
transformed_overflow
=
Overflow
{
paint
:
f32_rect_to_au_rect
(
transform_2d
.
transform_rect
(
&
au_rect_to_f32_rect
(
overflow
.
paint
)
)
)
scroll
:
f32_rect_to_au_rect
(
transform_2d
.
transform_rect
(
&
au_rect_to_f32_rect
(
overflow
.
scroll
)
)
)
}
;
overflow
.
union
(
&
transformed_overflow
)
;
overflow
.
translate
(
&
position
.
origin
)
;
overflow
}
fn
store_overflow
(
&
mut
self
_
:
&
LayoutContext
)
{
let
mut
overflow
=
self
.
compute_overflow
(
)
;
match
self
.
class
(
)
{
FlowClass
:
:
Block
|
FlowClass
:
:
TableCaption
|
FlowClass
:
:
TableCell
=
>
{
for
kid
in
mut_base
(
self
)
.
children
.
iter_mut
(
)
{
overflow
.
union
(
&
kid
.
get_overflow_in_parent_coordinates
(
)
)
;
}
}
_
=
>
{
}
}
mut_base
(
self
)
.
overflow
=
overflow
}
fn
compute_absolute_position
(
&
mut
self
_
:
&
LayoutContext
)
{
mut_base
(
self
)
.
restyle_damage
.
remove
(
REPOSITION
)
}
fn
build_display_list
(
&
mut
self
state
:
&
mut
DisplayListBuildState
)
;
fn
compute_overflow
(
&
self
)
-
>
Overflow
;
fn
iterate_through_fragment_border_boxes
(
&
self
iterator
:
&
mut
FragmentBorderBoxIterator
level
:
i32
stacking_context_position
:
&
Point2D
<
Au
>
)
;
fn
mutate_fragments
(
&
mut
self
mutator
:
&
mut
FnMut
(
&
mut
Fragment
)
)
;
fn
compute_collapsible_block_start_margin
(
&
mut
self
_layout_context
:
&
mut
LayoutContext
_margin_collapse_info
:
&
mut
MarginCollapseInfo
)
{
}
fn
mark_as_root
(
&
mut
self
)
{
debug
!
(
"
called
mark_as_root
(
)
on
a
flow
of
type
{
:
?
}
"
self
.
class
(
)
)
;
panic
!
(
"
called
mark_as_root
(
)
on
an
unhandled
flow
"
)
;
}
fn
is_root
(
&
self
)
-
>
bool
{
false
}
fn
positioning
(
&
self
)
-
>
position
:
:
T
{
position
:
:
T
:
:
static_
}
fn
is_fixed
(
&
self
)
-
>
bool
{
self
.
positioning
(
)
=
=
position
:
:
T
:
:
fixed
}
fn
contains_positioned_fragments
(
&
self
)
-
>
bool
{
self
.
contains_relatively_positioned_fragments
(
)
|
|
base
(
self
)
.
flags
.
contains
(
IS_ABSOLUTELY_POSITIONED
)
}
fn
contains_relatively_positioned_fragments
(
&
self
)
-
>
bool
{
self
.
positioning
(
)
=
=
position
:
:
T
:
:
relative
}
fn
is_absolute_containing_block
(
&
self
)
-
>
bool
{
false
}
fn
update_late_computed_inline_position_if_necessary
(
&
mut
self
inline_position
:
Au
)
;
fn
update_late_computed_block_position_if_necessary
(
&
mut
self
block_position
:
Au
)
;
fn
generated_containing_block_size
(
&
self
_
:
OpaqueFlow
)
-
>
LogicalSize
<
Au
>
;
fn
repair_style
(
&
mut
self
new_style
:
&
Arc
<
ServoComputedValues
>
)
;
fn
print_extra_flow_children
(
&
self
_
:
&
mut
PrintTree
)
{
}
fn
scroll_root_id
(
&
self
)
-
>
ScrollRootId
{
base
(
self
)
.
scroll_root_id
}
}
#
[
inline
(
always
)
]
#
[
allow
(
unsafe_code
)
]
pub
fn
base
<
T
:
?
Sized
+
Flow
>
(
this
:
&
T
)
-
>
&
BaseFlow
{
unsafe
{
let
obj
=
mem
:
:
transmute
:
:
<
&
&
T
&
raw
:
:
TraitObject
>
(
&
this
)
;
mem
:
:
transmute
:
:
<
*
mut
(
)
&
BaseFlow
>
(
obj
.
data
)
}
}
pub
fn
child_iter
<
'
a
>
(
flow
:
&
'
a
Flow
)
-
>
impl
Iterator
<
Item
=
&
'
a
Flow
>
{
base
(
flow
)
.
children
.
iter
(
)
}
#
[
inline
(
always
)
]
#
[
allow
(
unsafe_code
)
]
pub
fn
mut_base
<
T
:
?
Sized
+
Flow
>
(
this
:
&
mut
T
)
-
>
&
mut
BaseFlow
{
unsafe
{
let
obj
=
mem
:
:
transmute
:
:
<
&
&
mut
T
&
raw
:
:
TraitObject
>
(
&
this
)
;
mem
:
:
transmute
:
:
<
*
mut
(
)
&
mut
BaseFlow
>
(
obj
.
data
)
}
}
pub
fn
child_iter_mut
<
'
a
>
(
flow
:
&
'
a
mut
Flow
)
-
>
MutFlowListIterator
<
'
a
>
{
mut_base
(
flow
)
.
children
.
iter_mut
(
)
}
pub
trait
ImmutableFlowUtils
{
fn
is_block_like
(
self
)
-
>
bool
;
fn
is_table
(
self
)
-
>
bool
;
fn
is_table_caption
(
self
)
-
>
bool
;
fn
is_proper_table_child
(
self
)
-
>
bool
;
fn
is_table_row
(
self
)
-
>
bool
;
fn
is_table_cell
(
self
)
-
>
bool
;
fn
is_table_colgroup
(
self
)
-
>
bool
;
fn
is_table_rowgroup
(
self
)
-
>
bool
;
fn
is_table_kind
(
self
)
-
>
bool
;
fn
contains_roots_of_absolute_flow_tree
(
&
self
)
-
>
bool
;
fn
is_leaf
(
self
)
-
>
bool
;
fn
child_count
(
self
)
-
>
usize
;
fn
is_block_container
(
self
)
-
>
bool
;
fn
is_block_flow
(
self
)
-
>
bool
;
fn
is_inline_flow
(
self
)
-
>
bool
;
fn
print
(
self
title
:
String
)
;
fn
print_with_tree
(
self
print_tree
:
&
mut
PrintTree
)
;
fn
floats_might_flow_through
(
self
)
-
>
bool
;
fn
baseline_offset_of_last_line_box_in_flow
(
self
)
-
>
Option
<
Au
>
;
}
pub
trait
MutableFlowUtils
{
fn
traverse_preorder
<
T
:
PreorderFlowTraversal
>
(
self
traversal
:
&
T
)
;
fn
traverse_postorder
<
T
:
PostorderFlowTraversal
>
(
self
traversal
:
&
T
)
;
fn
traverse_preorder_absolute_flows
<
T
>
(
&
mut
self
traversal
:
&
mut
T
)
where
T
:
PreorderFlowTraversal
;
fn
traverse_postorder_absolute_flows
<
T
>
(
&
mut
self
traversal
:
&
mut
T
)
where
T
:
PostorderFlowTraversal
;
fn
repair_style_and_bubble_inline_sizes
(
self
style
:
&
Arc
<
ServoComputedValues
>
)
;
}
pub
trait
MutableOwnedFlowUtils
{
fn
set_absolute_descendants
(
&
mut
self
abs_descendants
:
AbsoluteDescendants
)
;
fn
take_applicable_absolute_descendants
(
&
mut
self
absolute_descendants
:
&
mut
AbsoluteDescendants
)
;
}
#
[
derive
(
Copy
Clone
Serialize
PartialEq
Debug
)
]
pub
enum
FlowClass
{
Block
Inline
ListItem
TableWrapper
Table
TableColGroup
TableRowGroup
TableRow
TableCaption
TableCell
Multicol
MulticolColumn
Flex
}
impl
FlowClass
{
fn
is_block_like
(
self
)
-
>
bool
{
match
self
{
FlowClass
:
:
Block
|
FlowClass
:
:
ListItem
|
FlowClass
:
:
Table
|
FlowClass
:
:
TableRowGroup
|
FlowClass
:
:
TableRow
|
FlowClass
:
:
TableCaption
|
FlowClass
:
:
TableCell
|
FlowClass
:
:
TableWrapper
|
FlowClass
:
:
Flex
=
>
true
_
=
>
false
}
}
}
pub
trait
PreorderFlowTraversal
{
fn
process
(
&
self
flow
:
&
mut
Flow
)
;
fn
should_process
(
&
self
_flow
:
&
mut
Flow
)
-
>
bool
{
true
}
}
pub
trait
PostorderFlowTraversal
{
fn
process
(
&
self
flow
:
&
mut
Flow
)
;
fn
should_process
(
&
self
_flow
:
&
mut
Flow
)
-
>
bool
{
true
}
}
pub
trait
InorderFlowTraversal
{
fn
process
(
&
mut
self
flow
:
&
mut
Flow
level
:
u32
)
;
fn
should_process
(
&
mut
self
flow
:
&
mut
Flow
)
-
>
bool
;
}
bitflags
!
{
#
[
doc
=
"
Flags
used
in
flows
.
"
]
pub
flags
FlowFlags
:
u32
{
/
/
text
align
flags
#
[
doc
=
"
Whether
this
flow
is
absolutely
positioned
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
IS_ABSOLUTELY_POSITIONED
=
0b0000_0000_0000_0000_0100_0000
#
[
doc
=
"
Whether
this
flow
clears
to
the
left
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
CLEARS_LEFT
=
0b0000_0000_0000_0000_1000_0000
#
[
doc
=
"
Whether
this
flow
clears
to
the
right
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
CLEARS_RIGHT
=
0b0000_0000_0000_0001_0000_0000
#
[
doc
=
"
Whether
this
flow
is
left
-
floated
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
FLOATS_LEFT
=
0b0000_0000_0000_0010_0000_0000
#
[
doc
=
"
Whether
this
flow
is
right
-
floated
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
FLOATS_RIGHT
=
0b0000_0000_0000_0100_0000_0000
#
[
doc
=
"
Text
alignment
.
\
NB
:
If
you
update
this
update
TEXT_ALIGN_SHIFT
below
.
"
]
const
TEXT_ALIGN
=
0b0000_0000_0111_1000_0000_0000
#
[
doc
=
"
Whether
this
flow
has
a
fragment
with
counter
-
reset
or
counter
-
increment
\
styles
.
"
]
const
AFFECTS_COUNTERS
=
0b0000_0000_1000_0000_0000_0000
#
[
doc
=
"
Whether
this
flow
'
s
descendants
have
fragments
that
affect
counter
-
reset
or
\
counter
-
increment
styles
.
"
]
const
HAS_COUNTER_AFFECTING_CHILDREN
=
0b0000_0001_0000_0000_0000_0000
#
[
doc
=
"
Whether
this
flow
behaves
as
though
it
had
position
:
static
for
the
purposes
\
of
positioning
in
the
inline
direction
.
This
is
set
for
flows
with
position
:
\
static
and
position
:
relative
as
well
as
absolutely
-
positioned
flows
with
\
unconstrained
positions
in
the
inline
direction
.
"
]
const
INLINE_POSITION_IS_STATIC
=
0b0000_0010_0000_0000_0000_0000
#
[
doc
=
"
Whether
this
flow
behaves
as
though
it
had
position
:
static
for
the
purposes
\
of
positioning
in
the
block
direction
.
This
is
set
for
flows
with
position
:
\
static
and
position
:
relative
as
well
as
absolutely
-
positioned
flows
with
\
unconstrained
positions
in
the
block
direction
.
"
]
const
BLOCK_POSITION_IS_STATIC
=
0b0000_0100_0000_0000_0000_0000
/
/
/
Whether
any
ancestor
is
a
fragmentation
container
const
CAN_BE_FRAGMENTED
=
0b0000_1000_0000_0000_0000_0000
/
/
/
Whether
this
flow
contains
any
text
and
/
or
replaced
fragments
.
const
CONTAINS_TEXT_OR_REPLACED_FRAGMENTS
=
0b0001_0000_0000_0000_0000_0000
/
/
/
Whether
margins
are
prohibited
from
collapsing
with
this
flow
.
const
MARGINS_CANNOT_COLLAPSE
=
0b0010_0000_0000_0000_0000_0000
}
}
static
TEXT_ALIGN_SHIFT
:
usize
=
11
;
impl
FlowFlags
{
#
[
inline
]
pub
fn
text_align
(
self
)
-
>
text_align
:
:
T
{
text_align
:
:
T
:
:
from_u32
(
(
self
&
TEXT_ALIGN
)
.
bits
(
)
>
>
TEXT_ALIGN_SHIFT
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
set_text_align
(
&
mut
self
value
:
text_align
:
:
T
)
{
*
self
=
(
*
self
&
!
TEXT_ALIGN
)
|
FlowFlags
:
:
from_bits
(
value
.
to_u32
(
)
<
<
TEXT_ALIGN_SHIFT
)
.
unwrap
(
)
;
}
#
[
inline
]
pub
fn
float_kind
(
&
self
)
-
>
float
:
:
T
{
if
self
.
contains
(
FLOATS_LEFT
)
{
float
:
:
T
:
:
left
}
else
if
self
.
contains
(
FLOATS_RIGHT
)
{
float
:
:
T
:
:
right
}
else
{
float
:
:
T
:
:
none
}
}
#
[
inline
]
pub
fn
is_float
(
&
self
)
-
>
bool
{
self
.
contains
(
FLOATS_LEFT
)
|
|
self
.
contains
(
FLOATS_RIGHT
)
}
#
[
inline
]
pub
fn
clears_floats
(
&
self
)
-
>
bool
{
self
.
contains
(
CLEARS_LEFT
)
|
|
self
.
contains
(
CLEARS_RIGHT
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
AbsoluteDescendants
{
descendant_links
:
Vec
<
AbsoluteDescendantInfo
>
}
impl
AbsoluteDescendants
{
pub
fn
new
(
)
-
>
AbsoluteDescendants
{
AbsoluteDescendants
{
descendant_links
:
Vec
:
:
new
(
)
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
descendant_links
.
len
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
descendant_links
.
is_empty
(
)
}
pub
fn
push
(
&
mut
self
given_descendant
:
FlowRef
)
{
self
.
descendant_links
.
push
(
AbsoluteDescendantInfo
{
flow
:
given_descendant
has_reached_containing_block
:
false
}
)
;
}
pub
fn
push_descendants
(
&
mut
self
given_descendants
:
AbsoluteDescendants
)
{
for
elem
in
given_descendants
.
descendant_links
{
self
.
descendant_links
.
push
(
elem
)
;
}
}
pub
fn
iter
(
&
mut
self
)
-
>
AbsoluteDescendantIter
{
AbsoluteDescendantIter
{
iter
:
self
.
descendant_links
.
iter_mut
(
)
}
}
pub
fn
mark_as_having_reached_containing_block
(
&
mut
self
)
{
for
descendant_info
in
self
.
descendant_links
.
iter_mut
(
)
{
descendant_info
.
has_reached_containing_block
=
true
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
AbsoluteDescendantInfo
{
flow
:
FlowRef
has_reached_containing_block
:
bool
}
pub
struct
AbsoluteDescendantIter
<
'
a
>
{
iter
:
IterMut
<
'
a
AbsoluteDescendantInfo
>
}
impl
<
'
a
>
Iterator
for
AbsoluteDescendantIter
<
'
a
>
{
type
Item
=
&
'
a
mut
Flow
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
mut
Flow
>
{
self
.
iter
.
next
(
)
.
map
(
|
info
|
FlowRef
:
:
deref_mut
(
&
mut
info
.
flow
)
)
}
}
pub
type
AbsoluteDescendantOffsetIter
<
'
a
>
=
Zip
<
AbsoluteDescendantIter
<
'
a
>
IterMut
<
'
a
Au
>
>
;
#
[
derive
(
Copy
Clone
)
]
pub
struct
EarlyAbsolutePositionInfo
{
pub
relative_containing_block_size
:
LogicalSize
<
Au
>
pub
relative_containing_block_mode
:
WritingMode
}
impl
EarlyAbsolutePositionInfo
{
pub
fn
new
(
writing_mode
:
WritingMode
)
-
>
EarlyAbsolutePositionInfo
{
EarlyAbsolutePositionInfo
{
relative_containing_block_size
:
LogicalSize
:
:
zero
(
writing_mode
)
relative_containing_block_mode
:
writing_mode
}
}
}
#
[
derive
(
Serialize
Copy
Clone
)
]
pub
struct
LateAbsolutePositionInfo
{
pub
stacking_relative_position_of_absolute_containing_block
:
Point2D
<
Au
>
}
impl
LateAbsolutePositionInfo
{
pub
fn
new
(
)
-
>
LateAbsolutePositionInfo
{
LateAbsolutePositionInfo
{
stacking_relative_position_of_absolute_containing_block
:
Point2D
:
:
zero
(
)
}
}
}
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
FragmentationContext
{
pub
available_block_size
:
Au
pub
this_fragment_is_empty
:
bool
}
pub
struct
BaseFlow
{
pub
restyle_damage
:
RestyleDamage
pub
children
:
FlowList
pub
intrinsic_inline_sizes
:
IntrinsicISizes
pub
position
:
LogicalRect
<
Au
>
pub
overflow
:
Overflow
pub
parallel
:
FlowParallelInfo
pub
floats
:
Floats
pub
speculated_float_placement_in
:
SpeculatedFloatPlacement
pub
speculated_float_placement_out
:
SpeculatedFloatPlacement
pub
collapsible_margins
:
CollapsibleMargins
pub
stacking_relative_position
:
Point2D
<
Au
>
pub
abs_descendants
:
AbsoluteDescendants
pub
block_container_inline_size
:
Au
pub
block_container_writing_mode
:
WritingMode
pub
block_container_explicit_block_size
:
Option
<
Au
>
pub
absolute_cb
:
ContainingBlockLink
pub
early_absolute_position_info
:
EarlyAbsolutePositionInfo
pub
late_absolute_position_info
:
LateAbsolutePositionInfo
pub
clip
:
Rect
<
Au
>
pub
writing_mode
:
WritingMode
pub
thread_id
:
u8
pub
flags
:
FlowFlags
pub
stacking_context_id
:
StackingContextId
pub
scroll_root_id
:
ScrollRootId
}
impl
fmt
:
:
Debug
for
BaseFlow
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
child_count
=
self
.
parallel
.
children_count
.
load
(
Ordering
:
:
SeqCst
)
;
let
child_count_string
=
if
child_count
>
0
{
format
!
(
"
children
=
{
}
"
child_count
)
}
else
{
"
"
.
to_owned
(
)
}
;
let
absolute_descendants_string
=
if
self
.
abs_descendants
.
len
(
)
>
0
{
format
!
(
"
abs
-
descendents
=
{
}
"
self
.
abs_descendants
.
len
(
)
)
}
else
{
"
"
.
to_owned
(
)
}
;
let
damage_string
=
if
self
.
restyle_damage
!
=
RestyleDamage
:
:
empty
(
)
{
format
!
(
"
damage
=
{
:
?
}
"
self
.
restyle_damage
)
}
else
{
"
"
.
to_owned
(
)
}
;
write
!
(
f
"
sc
=
{
:
?
}
pos
=
{
:
?
}
{
}
{
}
floatspec
-
in
=
{
:
?
}
floatspec
-
out
=
{
:
?
}
\
overflow
=
{
:
?
}
{
}
{
}
{
}
"
self
.
stacking_context_id
self
.
position
if
self
.
flags
.
contains
(
FLOATS_LEFT
)
{
"
FL
"
}
else
{
"
"
}
if
self
.
flags
.
contains
(
FLOATS_RIGHT
)
{
"
FR
"
}
else
{
"
"
}
self
.
speculated_float_placement_in
self
.
speculated_float_placement_out
self
.
overflow
child_count_string
absolute_descendants_string
damage_string
)
}
}
impl
Serialize
for
BaseFlow
{
fn
serialize
<
S
:
Serializer
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
{
let
mut
serializer
=
try
!
(
serializer
.
serialize_struct
(
"
base
"
5
)
)
;
try
!
(
serializer
.
serialize_field
(
"
id
"
&
self
.
debug_id
(
)
)
)
;
try
!
(
serializer
.
serialize_field
(
"
stacking_relative_position
"
&
self
.
stacking_relative_position
)
)
;
try
!
(
serializer
.
serialize_field
(
"
intrinsic_inline_sizes
"
&
self
.
intrinsic_inline_sizes
)
)
;
try
!
(
serializer
.
serialize_field
(
"
position
"
&
self
.
position
)
)
;
try
!
(
serializer
.
serialize_field
(
"
children
"
&
self
.
children
)
)
;
serializer
.
end
(
)
}
}
#
[
derive
(
Clone
PartialEq
)
]
pub
enum
ForceNonfloatedFlag
{
FloatIfNecessary
ForceNonfloated
}
impl
BaseFlow
{
#
[
inline
]
pub
fn
new
(
style
:
Option
<
&
ServoComputedValues
>
writing_mode
:
WritingMode
force_nonfloated
:
ForceNonfloatedFlag
)
-
>
BaseFlow
{
let
mut
flags
=
FlowFlags
:
:
empty
(
)
;
match
style
{
Some
(
style
)
=
>
{
match
style
.
get_box
(
)
.
position
{
position
:
:
T
:
:
absolute
|
position
:
:
T
:
:
fixed
=
>
{
flags
.
insert
(
IS_ABSOLUTELY_POSITIONED
)
;
let
logical_position
=
style
.
logical_position
(
)
;
if
logical_position
.
inline_start
=
=
LengthOrPercentageOrAuto
:
:
Auto
&
&
logical_position
.
inline_end
=
=
LengthOrPercentageOrAuto
:
:
Auto
{
flags
.
insert
(
INLINE_POSITION_IS_STATIC
)
;
}
if
logical_position
.
block_start
=
=
LengthOrPercentageOrAuto
:
:
Auto
&
&
logical_position
.
block_end
=
=
LengthOrPercentageOrAuto
:
:
Auto
{
flags
.
insert
(
BLOCK_POSITION_IS_STATIC
)
;
}
}
_
=
>
flags
.
insert
(
BLOCK_POSITION_IS_STATIC
|
INLINE_POSITION_IS_STATIC
)
}
if
force_nonfloated
=
=
ForceNonfloatedFlag
:
:
FloatIfNecessary
{
match
style
.
get_box
(
)
.
float
{
float
:
:
T
:
:
none
=
>
{
}
float
:
:
T
:
:
left
=
>
flags
.
insert
(
FLOATS_LEFT
)
float
:
:
T
:
:
right
=
>
flags
.
insert
(
FLOATS_RIGHT
)
}
}
match
style
.
get_box
(
)
.
clear
{
clear
:
:
T
:
:
none
=
>
{
}
clear
:
:
T
:
:
left
=
>
flags
.
insert
(
CLEARS_LEFT
)
clear
:
:
T
:
:
right
=
>
flags
.
insert
(
CLEARS_RIGHT
)
clear
:
:
T
:
:
both
=
>
{
flags
.
insert
(
CLEARS_LEFT
)
;
flags
.
insert
(
CLEARS_RIGHT
)
;
}
}
if
!
style
.
get_counters
(
)
.
counter_reset
.
0
.
is_empty
(
)
|
|
!
style
.
get_counters
(
)
.
counter_increment
.
0
.
is_empty
(
)
{
flags
.
insert
(
AFFECTS_COUNTERS
)
}
}
None
=
>
flags
.
insert
(
BLOCK_POSITION_IS_STATIC
|
INLINE_POSITION_IS_STATIC
)
}
let
mut
damage
=
RestyleDamage
:
:
rebuild_and_reflow
(
)
;
damage
.
remove
(
RECONSTRUCT_FLOW
)
;
BaseFlow
{
restyle_damage
:
damage
children
:
FlowList
:
:
new
(
)
intrinsic_inline_sizes
:
IntrinsicISizes
:
:
new
(
)
position
:
LogicalRect
:
:
zero
(
writing_mode
)
overflow
:
Overflow
:
:
new
(
)
parallel
:
FlowParallelInfo
:
:
new
(
)
floats
:
Floats
:
:
new
(
writing_mode
)
collapsible_margins
:
CollapsibleMargins
:
:
new
(
)
stacking_relative_position
:
Point2D
:
:
zero
(
)
abs_descendants
:
AbsoluteDescendants
:
:
new
(
)
speculated_float_placement_in
:
SpeculatedFloatPlacement
:
:
zero
(
)
speculated_float_placement_out
:
SpeculatedFloatPlacement
:
:
zero
(
)
block_container_inline_size
:
Au
(
0
)
block_container_writing_mode
:
writing_mode
block_container_explicit_block_size
:
None
absolute_cb
:
ContainingBlockLink
:
:
new
(
)
early_absolute_position_info
:
EarlyAbsolutePositionInfo
:
:
new
(
writing_mode
)
late_absolute_position_info
:
LateAbsolutePositionInfo
:
:
new
(
)
clip
:
max_rect
(
)
flags
:
flags
writing_mode
:
writing_mode
thread_id
:
0
stacking_context_id
:
StackingContextId
:
:
new
(
0
)
scroll_root_id
:
ScrollRootId
:
:
root
(
)
}
}
pub
fn
clone_with_children
(
&
self
children
:
FlowList
)
-
>
BaseFlow
{
BaseFlow
{
children
:
children
restyle_damage
:
self
.
restyle_damage
|
REPAINT
|
REFLOW_OUT_OF_FLOW
|
REFLOW
parallel
:
FlowParallelInfo
:
:
new
(
)
floats
:
self
.
floats
.
clone
(
)
abs_descendants
:
self
.
abs_descendants
.
clone
(
)
absolute_cb
:
self
.
absolute_cb
.
clone
(
)
clip
:
self
.
clip
.
clone
(
)
.
.
*
self
}
}
pub
fn
child_iter_mut
(
&
mut
self
)
-
>
MutFlowListIterator
{
self
.
children
.
iter_mut
(
)
}
pub
fn
debug_id
(
&
self
)
-
>
usize
{
let
p
=
self
as
*
const
_
;
p
as
usize
}
pub
fn
flow_id
(
&
self
)
-
>
usize
{
return
self
as
*
const
BaseFlow
as
usize
;
}
pub
fn
collect_stacking_contexts_for_children
(
&
mut
self
state
:
&
mut
DisplayListBuildState
)
{
for
kid
in
self
.
children
.
iter_mut
(
)
{
kid
.
collect_stacking_contexts
(
state
)
;
}
}
#
[
inline
]
pub
fn
might_have_floats_in
(
&
self
)
-
>
bool
{
self
.
speculated_float_placement_in
.
left
>
Au
(
0
)
|
|
self
.
speculated_float_placement_in
.
right
>
Au
(
0
)
}
#
[
inline
]
pub
fn
might_have_floats_out
(
&
self
)
-
>
bool
{
self
.
speculated_float_placement_out
.
left
>
Au
(
0
)
|
|
self
.
speculated_float_placement_out
.
right
>
Au
(
0
)
}
}
impl
<
'
a
>
ImmutableFlowUtils
for
&
'
a
Flow
{
fn
is_block_like
(
self
)
-
>
bool
{
self
.
class
(
)
.
is_block_like
(
)
}
fn
is_proper_table_child
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableRow
|
FlowClass
:
:
TableRowGroup
|
FlowClass
:
:
TableColGroup
|
FlowClass
:
:
TableCaption
=
>
true
_
=
>
false
}
}
fn
is_table_row
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableRow
=
>
true
_
=
>
false
}
}
fn
is_table_cell
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableCell
=
>
true
_
=
>
false
}
}
fn
is_table_colgroup
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableColGroup
=
>
true
_
=
>
false
}
}
fn
is_table
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Table
=
>
true
_
=
>
false
}
}
fn
is_table_caption
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableCaption
=
>
true
_
=
>
false
}
}
fn
is_table_rowgroup
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableRowGroup
=
>
true
_
=
>
false
}
}
fn
is_table_kind
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableWrapper
|
FlowClass
:
:
Table
|
FlowClass
:
:
TableColGroup
|
FlowClass
:
:
TableRowGroup
|
FlowClass
:
:
TableRow
|
FlowClass
:
:
TableCaption
|
FlowClass
:
:
TableCell
=
>
true
_
=
>
false
}
}
fn
contains_roots_of_absolute_flow_tree
(
&
self
)
-
>
bool
{
self
.
contains_relatively_positioned_fragments
(
)
|
|
self
.
is_root
(
)
}
fn
is_leaf
(
self
)
-
>
bool
{
base
(
self
)
.
children
.
is_empty
(
)
}
fn
child_count
(
self
)
-
>
usize
{
base
(
self
)
.
children
.
len
(
)
}
fn
is_block_container
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Block
|
FlowClass
:
:
TableCaption
|
FlowClass
:
:
TableCell
=
>
{
self
.
child_count
(
)
!
=
0
}
_
=
>
false
}
}
fn
is_block_flow
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Block
=
>
true
_
=
>
false
}
}
fn
is_inline_flow
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Inline
=
>
true
_
=
>
false
}
}
fn
print
(
self
title
:
String
)
{
let
mut
print_tree
=
PrintTree
:
:
new
(
title
)
;
self
.
print_with_tree
(
&
mut
print_tree
)
;
}
fn
print_with_tree
(
self
print_tree
:
&
mut
PrintTree
)
{
print_tree
.
new_level
(
format
!
(
"
{
:
?
}
"
self
)
)
;
self
.
print_extra_flow_children
(
print_tree
)
;
for
kid
in
child_iter
(
self
)
{
kid
.
print_with_tree
(
print_tree
)
;
}
print_tree
.
end_level
(
)
;
}
fn
floats_might_flow_through
(
self
)
-
>
bool
{
if
!
base
(
self
)
.
might_have_floats_in
(
)
&
&
!
base
(
self
)
.
might_have_floats_out
(
)
{
return
false
}
if
self
.
is_root
(
)
{
return
false
}
if
!
self
.
is_block_like
(
)
{
return
true
}
self
.
as_block
(
)
.
formatting_context_type
(
)
=
=
FormattingContextType
:
:
None
}
fn
baseline_offset_of_last_line_box_in_flow
(
self
)
-
>
Option
<
Au
>
{
for
kid
in
base
(
self
)
.
children
.
iter
(
)
.
rev
(
)
{
if
kid
.
is_inline_flow
(
)
{
if
let
Some
(
baseline_offset
)
=
kid
.
as_inline
(
)
.
baseline_offset_of_last_line
(
)
{
return
Some
(
base
(
kid
)
.
position
.
start
.
b
+
baseline_offset
)
}
}
if
kid
.
is_block_like
(
)
&
&
kid
.
as_block
(
)
.
formatting_context_type
(
)
=
=
FormattingContextType
:
:
None
&
&
!
base
(
kid
)
.
flags
.
contains
(
IS_ABSOLUTELY_POSITIONED
)
{
if
let
Some
(
baseline_offset
)
=
kid
.
baseline_offset_of_last_line_box_in_flow
(
)
{
return
Some
(
base
(
kid
)
.
position
.
start
.
b
+
baseline_offset
)
}
}
}
None
}
}
impl
<
'
a
>
MutableFlowUtils
for
&
'
a
mut
Flow
{
fn
traverse_preorder
<
T
:
PreorderFlowTraversal
>
(
self
traversal
:
&
T
)
{
if
traversal
.
should_process
(
self
)
{
traversal
.
process
(
self
)
;
}
for
kid
in
child_iter_mut
(
self
)
{
kid
.
traverse_preorder
(
traversal
)
;
}
}
fn
traverse_postorder
<
T
:
PostorderFlowTraversal
>
(
self
traversal
:
&
T
)
{
for
kid
in
child_iter_mut
(
self
)
{
kid
.
traverse_postorder
(
traversal
)
;
}
if
traversal
.
should_process
(
self
)
{
traversal
.
process
(
self
)
}
}
fn
repair_style_and_bubble_inline_sizes
(
self
style
:
&
Arc
<
ServoComputedValues
>
)
{
self
.
repair_style
(
style
)
;
self
.
bubble_inline_sizes
(
)
;
}
fn
traverse_preorder_absolute_flows
<
T
>
(
&
mut
self
traversal
:
&
mut
T
)
where
T
:
PreorderFlowTraversal
{
traversal
.
process
(
*
self
)
;
let
descendant_offset_iter
=
mut_base
(
*
self
)
.
abs_descendants
.
iter
(
)
;
for
ref
mut
descendant_link
in
descendant_offset_iter
{
descendant_link
.
traverse_preorder_absolute_flows
(
traversal
)
}
}
fn
traverse_postorder_absolute_flows
<
T
>
(
&
mut
self
traversal
:
&
mut
T
)
where
T
:
PostorderFlowTraversal
{
for
mut
descendant_link
in
mut_base
(
*
self
)
.
abs_descendants
.
iter
(
)
{
descendant_link
.
traverse_postorder_absolute_flows
(
traversal
)
;
}
traversal
.
process
(
*
self
)
}
}
impl
MutableOwnedFlowUtils
for
FlowRef
{
fn
set_absolute_descendants
(
&
mut
self
abs_descendants
:
AbsoluteDescendants
)
{
let
this
=
self
.
clone
(
)
;
let
base
=
mut_base
(
FlowRef
:
:
deref_mut
(
self
)
)
;
base
.
abs_descendants
=
abs_descendants
;
for
descendant_link
in
base
.
abs_descendants
.
descendant_links
.
iter_mut
(
)
{
debug_assert
!
(
!
descendant_link
.
has_reached_containing_block
)
;
let
descendant_base
=
mut_base
(
FlowRef
:
:
deref_mut
(
&
mut
descendant_link
.
flow
)
)
;
descendant_base
.
absolute_cb
.
set
(
this
.
clone
(
)
)
;
}
}
fn
take_applicable_absolute_descendants
(
&
mut
self
absolute_descendants
:
&
mut
AbsoluteDescendants
)
{
let
mut
applicable_absolute_descendants
=
AbsoluteDescendants
:
:
new
(
)
;
for
absolute_descendant
in
absolute_descendants
.
descendant_links
.
iter
(
)
{
if
absolute_descendant
.
has_reached_containing_block
{
applicable_absolute_descendants
.
push
(
absolute_descendant
.
flow
.
clone
(
)
)
;
}
}
absolute_descendants
.
descendant_links
.
retain
(
|
descendant
|
{
!
descendant
.
has_reached_containing_block
}
)
;
let
this
=
self
.
clone
(
)
;
let
base
=
mut_base
(
FlowRef
:
:
deref_mut
(
self
)
)
;
base
.
abs_descendants
=
applicable_absolute_descendants
;
for
descendant_link
in
base
.
abs_descendants
.
iter
(
)
{
let
descendant_base
=
mut_base
(
descendant_link
)
;
descendant_base
.
absolute_cb
.
set
(
this
.
clone
(
)
)
;
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
ContainingBlockLink
{
link
:
Option
<
WeakFlowRef
>
}
impl
ContainingBlockLink
{
fn
new
(
)
-
>
ContainingBlockLink
{
ContainingBlockLink
{
link
:
None
}
}
fn
set
(
&
mut
self
link
:
FlowRef
)
{
self
.
link
=
Some
(
FlowRef
:
:
downgrade
(
&
link
)
)
}
#
[
inline
]
pub
fn
generated_containing_block_size
(
&
self
for_flow
:
OpaqueFlow
)
-
>
LogicalSize
<
Au
>
{
match
self
.
link
{
None
=
>
{
panic
!
(
"
Link
to
containing
block
not
established
;
perhaps
you
forgot
to
call
\
set_absolute_descendants
?
"
)
}
Some
(
ref
link
)
=
>
{
let
flow
=
link
.
upgrade
(
)
.
unwrap
(
)
;
flow
.
generated_containing_block_size
(
for_flow
)
}
}
}
#
[
inline
]
pub
fn
explicit_block_containing_size
(
&
self
shared_context
:
&
SharedStyleContext
)
-
>
Option
<
Au
>
{
match
self
.
link
{
None
=
>
{
panic
!
(
"
Link
to
containing
block
not
established
;
perhaps
you
forgot
to
call
\
set_absolute_descendants
?
"
)
}
Some
(
ref
link
)
=
>
{
let
flow
=
link
.
upgrade
(
)
.
unwrap
(
)
;
if
flow
.
is_block_like
(
)
{
flow
.
as_block
(
)
.
explicit_block_containing_size
(
shared_context
)
}
else
if
flow
.
is_inline_flow
(
)
{
Some
(
flow
.
as_inline
(
)
.
minimum_line_metrics
.
space_above_baseline
)
}
else
{
None
}
}
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
pub
struct
OpaqueFlow
(
pub
usize
)
;
impl
OpaqueFlow
{
#
[
allow
(
unsafe_code
)
]
pub
fn
from_flow
(
flow
:
&
Flow
)
-
>
OpaqueFlow
{
unsafe
{
let
object
=
mem
:
:
transmute
:
:
<
&
Flow
raw
:
:
TraitObject
>
(
flow
)
;
OpaqueFlow
(
object
.
data
as
usize
)
}
}
}
