use
css
:
:
node_style
:
:
StyledNode
;
use
block
:
:
BlockFlow
;
use
context
:
:
LayoutContext
;
use
display_list_builder
:
:
DisplayListBuildingResult
;
use
floats
:
:
Floats
;
use
flow_list
:
:
{
FlowList
FlowListIterator
MutFlowListIterator
}
;
use
flow_ref
:
:
FlowRef
;
use
fragment
:
:
{
Fragment
FragmentBorderBoxIterator
SpecificFragmentInfo
}
;
use
incremental
:
:
{
RECONSTRUCT_FLOW
REFLOW
REFLOW_OUT_OF_FLOW
RestyleDamage
}
;
use
inline
:
:
InlineFlow
;
use
model
:
:
{
CollapsibleMargins
IntrinsicISizes
}
;
use
parallel
:
:
FlowParallelInfo
;
use
table
:
:
{
ColumnComputedInlineSize
ColumnIntrinsicInlineSize
TableFlow
}
;
use
table_caption
:
:
TableCaptionFlow
;
use
table_cell
:
:
TableCellFlow
;
use
table_colgroup
:
:
TableColGroupFlow
;
use
table_row
:
:
TableRowFlow
;
use
table_rowgroup
:
:
TableRowGroupFlow
;
use
table_wrapper
:
:
TableWrapperFlow
;
use
wrapper
:
:
ThreadSafeLayoutNode
;
use
geom
:
:
{
Point2D
Rect
Size2D
}
;
use
gfx
:
:
display_list
:
:
ClippingRegion
;
use
serialize
:
:
{
Encoder
Encodable
}
;
use
msg
:
:
compositor_msg
:
:
LayerId
;
use
servo_util
:
:
geometry
:
:
{
Au
ZERO_RECT
}
;
use
servo_util
:
:
logical_geometry
:
:
{
LogicalRect
LogicalSize
WritingMode
}
;
use
std
:
:
mem
;
use
std
:
:
fmt
;
use
std
:
:
iter
:
:
Zip
;
use
std
:
:
num
:
:
FromPrimitive
;
use
std
:
:
raw
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUint
Ordering
}
;
use
std
:
:
slice
:
:
IterMut
;
use
style
:
:
computed_values
:
:
{
clear
empty_cells
float
position
text_align
}
;
use
style
:
:
properties
:
:
ComputedValues
;
use
std
:
:
sync
:
:
Arc
;
pub
trait
Flow
:
fmt
:
:
Debug
+
Sync
{
fn
class
(
&
self
)
-
>
FlowClass
;
fn
as_immutable_block
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
BlockFlow
{
panic
!
(
"
called
as_immutable_block
(
)
on
a
non
-
block
flow
"
)
}
fn
as_block
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
BlockFlow
{
debug
!
(
"
called
as_block
(
)
on
a
flow
of
type
{
:
?
}
"
self
.
class
(
)
)
;
panic
!
(
"
called
as_block
(
)
on
a
non
-
block
flow
"
)
}
fn
as_immutable_inline
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
InlineFlow
{
panic
!
(
"
called
as_immutable_inline
(
)
on
a
non
-
inline
flow
"
)
}
fn
as_inline
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
InlineFlow
{
panic
!
(
"
called
as_inline
(
)
on
a
non
-
inline
flow
"
)
}
fn
as_table_wrapper
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableWrapperFlow
{
panic
!
(
"
called
as_table_wrapper
(
)
on
a
non
-
tablewrapper
flow
"
)
}
fn
as_immutable_table_wrapper
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
TableWrapperFlow
{
panic
!
(
"
called
as_immutable_table_wrapper
(
)
on
a
non
-
tablewrapper
flow
"
)
}
fn
as_table
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableFlow
{
panic
!
(
"
called
as_table
(
)
on
a
non
-
table
flow
"
)
}
fn
as_immutable_table
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
TableFlow
{
panic
!
(
"
called
as_table
(
)
on
a
non
-
table
flow
"
)
}
fn
as_table_colgroup
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableColGroupFlow
{
panic
!
(
"
called
as_table_colgroup
(
)
on
a
non
-
tablecolgroup
flow
"
)
}
fn
as_table_rowgroup
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableRowGroupFlow
{
panic
!
(
"
called
as_table_rowgroup
(
)
on
a
non
-
tablerowgroup
flow
"
)
}
fn
as_immutable_table_rowgroup
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
TableRowGroupFlow
{
panic
!
(
"
called
as_table_rowgroup
(
)
on
a
non
-
tablerowgroup
flow
"
)
}
fn
as_table_row
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableRowFlow
{
panic
!
(
"
called
as_table_row
(
)
on
a
non
-
tablerow
flow
"
)
}
fn
as_immutable_table_row
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
TableRowFlow
{
panic
!
(
"
called
as_table_row
(
)
on
a
non
-
tablerow
flow
"
)
}
fn
as_table_caption
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableCaptionFlow
{
panic
!
(
"
called
as_table_caption
(
)
on
a
non
-
tablecaption
flow
"
)
}
fn
as_table_cell
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableCellFlow
{
panic
!
(
"
called
as_table_cell
(
)
on
a
non
-
tablecell
flow
"
)
}
fn
as_immutable_table_cell
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
TableCellFlow
{
panic
!
(
"
called
as_table_cell
(
)
on
a
non
-
tablecell
flow
"
)
}
fn
column_intrinsic_inline_sizes
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Vec
<
ColumnIntrinsicInlineSize
>
{
panic
!
(
"
called
column_intrinsic_inline_sizes
(
)
on
non
-
table
flow
"
)
}
fn
column_computed_inline_sizes
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Vec
<
ColumnComputedInlineSize
>
{
panic
!
(
"
called
column_intrinsic_inline_sizes
(
)
on
non
-
table
flow
"
)
}
fn
bubble_inline_sizes
(
&
mut
self
)
{
panic
!
(
"
bubble_inline_sizes
not
yet
implemented
"
)
}
fn
assign_inline_sizes
(
&
mut
self
_ctx
:
&
LayoutContext
)
{
panic
!
(
"
assign_inline_sizes
not
yet
implemented
"
)
}
fn
assign_block_size
<
'
a
>
(
&
mut
self
_ctx
:
&
'
a
LayoutContext
<
'
a
>
)
{
panic
!
(
"
assign_block_size
not
yet
implemented
"
)
}
fn
place_float_if_applicable
<
'
a
>
(
&
mut
self
_
:
&
'
a
LayoutContext
<
'
a
>
)
{
}
fn
assign_block_size_for_inorder_child_if_necessary
<
'
a
>
(
&
mut
self
layout_context
:
&
'
a
LayoutContext
<
'
a
>
)
-
>
bool
{
let
impacted
=
base
(
self
)
.
flags
.
impacted_by_floats
(
)
;
if
impacted
{
self
.
assign_block_size
(
layout_context
)
;
mut_base
(
self
)
.
restyle_damage
.
remove
(
REFLOW_OUT_OF_FLOW
|
REFLOW
)
;
}
impacted
}
fn
compute_absolute_position
(
&
mut
self
)
{
}
fn
build_display_list
(
&
mut
self
layout_context
:
&
LayoutContext
)
;
fn
compute_overflow
(
&
self
)
-
>
Rect
<
Au
>
;
fn
iterate_through_fragment_border_boxes
(
&
self
iterator
:
&
mut
FragmentBorderBoxIterator
stacking_context_position
:
&
Point2D
<
Au
>
)
;
fn
mark_as_root
(
&
mut
self
)
{
}
fn
is_store_overflow_delayed
(
&
mut
self
)
-
>
bool
{
false
}
fn
is_root
(
&
self
)
-
>
bool
{
false
}
fn
positioning
(
&
self
)
-
>
position
:
:
T
{
position
:
:
T
:
:
static_
}
fn
is_fixed
(
&
self
)
-
>
bool
{
self
.
positioning
(
)
=
=
position
:
:
T
:
:
fixed
}
fn
is_positioned
(
&
self
)
-
>
bool
{
self
.
is_relatively_positioned
(
)
|
|
base
(
self
)
.
flags
.
contains
(
IS_ABSOLUTELY_POSITIONED
)
}
fn
is_relatively_positioned
(
&
self
)
-
>
bool
{
self
.
positioning
(
)
=
=
position
:
:
T
:
:
relative
}
fn
is_root_of_absolute_flow_tree
(
&
self
)
-
>
bool
{
false
}
fn
is_absolute_containing_block
(
&
self
)
-
>
bool
{
false
}
fn
update_late_computed_inline_position_if_necessary
(
&
mut
self
inline_position
:
Au
)
;
fn
update_late_computed_block_position_if_necessary
(
&
mut
self
block_position
:
Au
)
;
fn
generated_containing_block_rect
(
&
self
)
-
>
LogicalRect
<
Au
>
{
panic
!
(
"
generated_containing_block_rect
not
yet
implemented
for
this
flow
"
)
}
#
[
allow
(
unsafe_blocks
)
]
fn
layer_id
(
&
self
fragment_id
:
uint
)
-
>
LayerId
{
unsafe
{
let
obj
=
mem
:
:
transmute
:
:
<
&
&
Self
&
raw
:
:
TraitObject
>
(
&
self
)
;
let
pointer
:
uint
=
mem
:
:
transmute
(
obj
.
data
)
;
LayerId
(
pointer
fragment_id
)
}
}
fn
repair_style
(
&
mut
self
new_style
:
&
Arc
<
ComputedValues
>
)
;
}
#
[
inline
(
always
)
]
#
[
allow
(
unsafe_blocks
)
]
pub
fn
base
<
'
a
T
:
?
Sized
+
Flow
>
(
this
:
&
'
a
T
)
-
>
&
'
a
BaseFlow
{
unsafe
{
let
obj
=
mem
:
:
transmute
:
:
<
&
&
'
a
T
&
'
a
raw
:
:
TraitObject
>
(
&
this
)
;
mem
:
:
transmute
:
:
<
*
mut
(
)
&
'
a
BaseFlow
>
(
obj
.
data
)
}
}
pub
fn
imm_child_iter
<
'
a
>
(
flow
:
&
'
a
Flow
)
-
>
FlowListIterator
<
'
a
>
{
base
(
flow
)
.
children
.
iter
(
)
}
#
[
inline
(
always
)
]
#
[
allow
(
unsafe_blocks
)
]
pub
fn
mut_base
<
'
a
T
:
?
Sized
+
Flow
>
(
this
:
&
'
a
mut
T
)
-
>
&
'
a
mut
BaseFlow
{
unsafe
{
let
obj
=
mem
:
:
transmute
:
:
<
&
&
'
a
mut
T
&
'
a
raw
:
:
TraitObject
>
(
&
this
)
;
mem
:
:
transmute
:
:
<
*
mut
(
)
&
'
a
mut
BaseFlow
>
(
obj
.
data
)
}
}
pub
fn
child_iter
<
'
a
>
(
flow
:
&
'
a
mut
Flow
)
-
>
MutFlowListIterator
<
'
a
>
{
mut_base
(
flow
)
.
children
.
iter_mut
(
)
}
pub
trait
ImmutableFlowUtils
{
fn
is_block_like
(
self
)
-
>
bool
;
fn
is_table
(
self
)
-
>
bool
;
fn
is_table_caption
(
self
)
-
>
bool
;
fn
is_proper_table_child
(
self
)
-
>
bool
;
fn
is_table_row
(
self
)
-
>
bool
;
fn
is_table_cell
(
self
)
-
>
bool
;
fn
is_table_colgroup
(
self
)
-
>
bool
;
fn
is_table_rowgroup
(
self
)
-
>
bool
;
fn
is_table_kind
(
self
)
-
>
bool
;
fn
need_anonymous_flow
(
self
child
:
&
Flow
)
-
>
bool
;
fn
generate_missing_child_flow
(
self
node
:
&
ThreadSafeLayoutNode
)
-
>
FlowRef
;
fn
is_leaf
(
self
)
-
>
bool
;
fn
child_count
(
self
)
-
>
uint
;
fn
is_block_container
(
self
)
-
>
bool
;
fn
is_block_flow
(
self
)
-
>
bool
;
fn
is_inline_flow
(
self
)
-
>
bool
;
fn
dump
(
self
)
;
fn
dump_with_level
(
self
level
:
uint
)
;
}
pub
trait
MutableFlowUtils
{
fn
traverse_preorder
<
T
:
PreorderFlowTraversal
>
(
self
traversal
:
&
T
)
;
fn
traverse_postorder
<
T
:
PostorderFlowTraversal
>
(
self
traversal
:
&
T
)
;
fn
store_overflow
(
self
_
:
&
LayoutContext
)
;
fn
collect_static_block_offsets_from_children
(
self
)
;
}
pub
trait
MutableOwnedFlowUtils
{
fn
set_absolute_descendants
(
&
mut
self
abs_descendants
:
AbsDescendants
)
;
}
#
[
derive
(
RustcEncodable
PartialEq
Debug
)
]
pub
enum
FlowClass
{
Block
Inline
ListItem
TableWrapper
Table
TableColGroup
TableRowGroup
TableRow
TableCaption
TableCell
}
pub
trait
PreorderFlowTraversal
{
fn
process
(
&
self
flow
:
&
mut
Flow
)
;
fn
should_process
(
&
self
_flow
:
&
mut
Flow
)
-
>
bool
{
true
}
}
pub
trait
PostorderFlowTraversal
{
fn
process
(
&
self
flow
:
&
mut
Flow
)
;
fn
should_process
(
&
self
_flow
:
&
mut
Flow
)
-
>
bool
{
true
}
}
bitflags
!
{
#
[
doc
=
"
Flags
used
in
flows
.
"
]
flags
FlowFlags
:
u16
{
/
/
floated
descendants
flags
#
[
doc
=
"
Whether
this
flow
has
descendants
that
float
left
in
the
same
block
formatting
"
]
#
[
doc
=
"
context
.
"
]
const
HAS_LEFT_FLOATED_DESCENDANTS
=
0b0000_0000_0000_0001
#
[
doc
=
"
Whether
this
flow
has
descendants
that
float
right
in
the
same
block
formatting
"
]
#
[
doc
=
"
context
.
"
]
const
HAS_RIGHT_FLOATED_DESCENDANTS
=
0b0000_0000_0000_0010
#
[
doc
=
"
Whether
this
flow
is
impacted
by
floats
to
the
left
in
the
same
block
formatting
"
]
#
[
doc
=
"
context
(
i
.
e
.
its
height
depends
on
some
prior
flows
with
float
:
left
)
.
"
]
const
IMPACTED_BY_LEFT_FLOATS
=
0b0000_0000_0000_0100
#
[
doc
=
"
Whether
this
flow
is
impacted
by
floats
to
the
right
in
the
same
block
"
]
#
[
doc
=
"
formatting
context
(
i
.
e
.
its
height
depends
on
some
prior
flows
with
float
:
"
]
#
[
doc
=
"
right
)
.
"
]
const
IMPACTED_BY_RIGHT_FLOATS
=
0b0000_0000_0000_1000
/
/
text
align
flags
#
[
doc
=
"
Whether
this
flow
contains
a
flow
that
has
its
own
layer
within
the
same
absolute
"
]
#
[
doc
=
"
containing
block
.
"
]
const
LAYERS_NEEDED_FOR_DESCENDANTS
=
0b0000_0000_0001_0000
#
[
doc
=
"
Whether
this
flow
must
have
its
own
layer
.
Even
if
this
flag
is
not
set
it
might
"
]
#
[
doc
=
"
get
its
own
layer
if
it
'
s
deemed
to
be
likely
to
overlap
flows
with
their
own
"
]
#
[
doc
=
"
layer
.
"
]
const
NEEDS_LAYER
=
0b0000_0000_0010_0000
#
[
doc
=
"
Whether
this
flow
is
absolutely
positioned
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
IS_ABSOLUTELY_POSITIONED
=
0b0000_0000_0100_0000
#
[
doc
=
"
Whether
this
flow
clears
to
the
left
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
CLEARS_LEFT
=
0b0000_0000_1000_0000
#
[
doc
=
"
Whether
this
flow
clears
to
the
right
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
CLEARS_RIGHT
=
0b0000_0001_0000_0000
#
[
doc
=
"
Whether
this
flow
is
left
-
floated
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
FLOATS_LEFT
=
0b0000_0010_0000_0000
#
[
doc
=
"
Whether
this
flow
is
right
-
floated
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
FLOATS_RIGHT
=
0b0000_0100_0000_0000
#
[
doc
=
"
Text
alignment
.
\
NB
:
If
you
update
this
update
TEXT_ALIGN_SHIFT
below
.
"
]
const
TEXT_ALIGN
=
0b0111_1000_0000_0000
}
}
static
HAS_FLOATED_DESCENDANTS_BITMASK
:
FlowFlags
=
FlowFlags
{
bits
:
0b0000_0011
}
;
static
TEXT_ALIGN_SHIFT
:
uint
=
11
;
impl
FlowFlags
{
pub
fn
propagate_text_alignment_from_parent
(
&
mut
self
parent_flags
:
FlowFlags
)
{
self
.
set_text_align_override
(
parent_flags
)
;
}
#
[
inline
]
pub
fn
text_align
(
self
)
-
>
text_align
:
:
T
{
FromPrimitive
:
:
from_u16
(
(
self
&
TEXT_ALIGN
)
.
bits
(
)
>
>
TEXT_ALIGN_SHIFT
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
set_text_align
(
&
mut
self
value
:
text_align
:
:
T
)
{
*
self
=
(
*
self
&
!
TEXT_ALIGN
)
|
FlowFlags
:
:
from_bits
(
(
value
as
u16
)
<
<
TEXT_ALIGN_SHIFT
)
.
unwrap
(
)
;
}
#
[
inline
]
pub
fn
set_text_align_override
(
&
mut
self
parent
:
FlowFlags
)
{
self
.
insert
(
parent
&
TEXT_ALIGN
)
;
}
#
[
inline
]
pub
fn
union_floated_descendants_flags
(
&
mut
self
other
:
FlowFlags
)
{
self
.
insert
(
other
&
HAS_FLOATED_DESCENDANTS_BITMASK
)
;
}
#
[
inline
]
pub
fn
impacted_by_floats
(
&
self
)
-
>
bool
{
self
.
contains
(
IMPACTED_BY_LEFT_FLOATS
)
|
|
self
.
contains
(
IMPACTED_BY_RIGHT_FLOATS
)
}
#
[
inline
]
pub
fn
set
(
&
mut
self
flags
:
FlowFlags
value
:
bool
)
{
if
value
{
self
.
insert
(
flags
)
;
}
else
{
self
.
remove
(
flags
)
;
}
}
#
[
inline
]
pub
fn
float_kind
(
&
self
)
-
>
float
:
:
T
{
if
self
.
contains
(
FLOATS_LEFT
)
{
float
:
:
T
:
:
left
}
else
if
self
.
contains
(
FLOATS_RIGHT
)
{
float
:
:
T
:
:
right
}
else
{
float
:
:
T
:
:
none
}
}
#
[
inline
]
pub
fn
is_float
(
&
self
)
-
>
bool
{
self
.
contains
(
FLOATS_LEFT
)
|
|
self
.
contains
(
FLOATS_RIGHT
)
}
#
[
inline
]
pub
fn
clears_floats
(
&
self
)
-
>
bool
{
self
.
contains
(
CLEARS_LEFT
)
|
|
self
.
contains
(
CLEARS_RIGHT
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
Descendants
{
descendant_links
:
Vec
<
FlowRef
>
pub
static_block_offsets
:
Vec
<
Au
>
}
impl
Descendants
{
pub
fn
new
(
)
-
>
Descendants
{
Descendants
{
descendant_links
:
Vec
:
:
new
(
)
static_block_offsets
:
Vec
:
:
new
(
)
}
}
pub
fn
len
(
&
self
)
-
>
uint
{
self
.
descendant_links
.
len
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
descendant_links
.
is_empty
(
)
}
pub
fn
push
(
&
mut
self
given_descendant
:
FlowRef
)
{
self
.
descendant_links
.
push
(
given_descendant
)
;
}
pub
fn
push_descendants
(
&
mut
self
given_descendants
:
Descendants
)
{
for
elem
in
given_descendants
.
descendant_links
.
into_iter
(
)
{
self
.
descendant_links
.
push
(
elem
)
;
}
}
pub
fn
iter
<
'
a
>
(
&
'
a
mut
self
)
-
>
DescendantIter
<
'
a
>
{
DescendantIter
{
iter
:
self
.
descendant_links
.
iter_mut
(
)
}
}
pub
fn
iter_with_offset
<
'
a
>
(
&
'
a
mut
self
)
-
>
DescendantOffsetIter
<
'
a
>
{
let
descendant_iter
=
DescendantIter
{
iter
:
self
.
descendant_links
.
iter_mut
(
)
}
;
descendant_iter
.
zip
(
self
.
static_block_offsets
.
iter_mut
(
)
)
}
}
pub
type
AbsDescendants
=
Descendants
;
pub
struct
DescendantIter
<
'
a
>
{
iter
:
IterMut
<
'
a
FlowRef
>
}
impl
<
'
a
>
Iterator
for
DescendantIter
<
'
a
>
{
type
Item
=
&
'
a
mut
(
Flow
+
'
a
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
mut
(
Flow
+
'
a
)
>
{
self
.
iter
.
next
(
)
.
map
(
|
flow
|
&
mut
*
*
flow
)
}
}
pub
type
DescendantOffsetIter
<
'
a
>
=
Zip
<
DescendantIter
<
'
a
>
IterMut
<
'
a
Au
>
>
;
#
[
derive
(
RustcEncodable
Copy
)
]
pub
struct
AbsolutePositionInfo
{
pub
relative_containing_block_size
:
LogicalSize
<
Au
>
pub
stacking_relative_position_of_absolute_containing_block
:
Point2D
<
Au
>
pub
layers_needed_for_positioned_flows
:
bool
}
impl
AbsolutePositionInfo
{
pub
fn
new
(
writing_mode
:
WritingMode
)
-
>
AbsolutePositionInfo
{
AbsolutePositionInfo
{
relative_containing_block_size
:
LogicalSize
:
:
zero
(
writing_mode
)
stacking_relative_position_of_absolute_containing_block
:
Point2D
:
:
zero
(
)
layers_needed_for_positioned_flows
:
false
}
}
}
pub
struct
BaseFlow
{
ref_count
:
AtomicUint
pub
restyle_damage
:
RestyleDamage
pub
children
:
FlowList
pub
intrinsic_inline_sizes
:
IntrinsicISizes
pub
position
:
LogicalRect
<
Au
>
pub
overflow
:
Rect
<
Au
>
pub
parallel
:
FlowParallelInfo
pub
floats
:
Floats
pub
collapsible_margins
:
CollapsibleMargins
pub
stacking_relative_position
:
Point2D
<
Au
>
pub
abs_descendants
:
AbsDescendants
pub
block_container_inline_size
:
Au
pub
block_container_explicit_block_size
:
Option
<
Au
>
pub
absolute_static_i_offset
:
Au
pub
fixed_static_i_offset
:
Au
pub
absolute_cb
:
ContainingBlockLink
pub
absolute_position_info
:
AbsolutePositionInfo
pub
clip
:
ClippingRegion
pub
display_list_building_result
:
DisplayListBuildingResult
pub
writing_mode
:
WritingMode
pub
flags
:
FlowFlags
}
unsafe
impl
Send
for
BaseFlow
{
}
unsafe
impl
Sync
for
BaseFlow
{
}
impl
fmt
:
:
Debug
for
BaseFlow
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
CC
{
}
ADC
{
}
"
self
.
position
self
.
parallel
.
children_count
.
load
(
Ordering
:
:
SeqCst
)
self
.
abs_descendants
.
len
(
)
)
}
}
impl
Encodable
for
BaseFlow
{
fn
encode
<
S
:
Encoder
>
(
&
self
e
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
e
.
emit_struct
(
"
base
"
0
|
e
|
{
try
!
(
e
.
emit_struct_field
(
"
id
"
0
|
e
|
self
.
debug_id
(
)
.
encode
(
e
)
)
)
;
try
!
(
e
.
emit_struct_field
(
"
stacking_relative_position
"
1
|
e
|
self
.
stacking_relative_position
.
encode
(
e
)
)
)
;
try
!
(
e
.
emit_struct_field
(
"
intrinsic_inline_sizes
"
2
|
e
|
self
.
intrinsic_inline_sizes
.
encode
(
e
)
)
)
;
try
!
(
e
.
emit_struct_field
(
"
position
"
3
|
e
|
self
.
position
.
encode
(
e
)
)
)
;
e
.
emit_struct_field
(
"
children
"
4
|
e
|
{
e
.
emit_seq
(
self
.
children
.
len
(
)
|
e
|
{
for
(
i
c
)
in
self
.
children
.
iter
(
)
.
enumerate
(
)
{
try
!
(
e
.
emit_seq_elt
(
i
|
e
|
{
try
!
(
e
.
emit_struct
(
"
flow
"
0
|
e
|
{
try
!
(
e
.
emit_struct_field
(
"
class
"
0
|
e
|
c
.
class
(
)
.
encode
(
e
)
)
)
;
e
.
emit_struct_field
(
"
data
"
1
|
e
|
{
match
c
.
class
(
)
{
FlowClass
:
:
Block
=
>
c
.
as_immutable_block
(
)
.
encode
(
e
)
FlowClass
:
:
Inline
=
>
c
.
as_immutable_inline
(
)
.
encode
(
e
)
FlowClass
:
:
Table
=
>
c
.
as_immutable_table
(
)
.
encode
(
e
)
FlowClass
:
:
TableWrapper
=
>
c
.
as_immutable_table_wrapper
(
)
.
encode
(
e
)
FlowClass
:
:
TableRowGroup
=
>
c
.
as_immutable_table_rowgroup
(
)
.
encode
(
e
)
FlowClass
:
:
TableRow
=
>
c
.
as_immutable_table_row
(
)
.
encode
(
e
)
FlowClass
:
:
TableCell
=
>
c
.
as_immutable_table_cell
(
)
.
encode
(
e
)
_
=
>
{
Ok
(
(
)
)
}
/
/
TODO
:
Support
captions
}
}
)
}
)
)
;
Ok
(
(
)
)
}
)
)
;
}
Ok
(
(
)
)
}
)
}
)
}
)
}
}
#
[
unsafe_destructor
]
impl
Drop
for
BaseFlow
{
fn
drop
(
&
mut
self
)
{
if
self
.
ref_count
.
load
(
Ordering
:
:
SeqCst
)
!
=
0
{
panic
!
(
"
Flow
destroyed
before
its
ref
count
hit
zero
this
is
unsafe
!
"
)
}
}
}
#
[
derive
(
Clone
PartialEq
)
]
pub
enum
ForceNonfloatedFlag
{
FloatIfNecessary
ForceNonfloated
}
impl
BaseFlow
{
#
[
inline
]
pub
fn
new
(
node
:
Option
<
ThreadSafeLayoutNode
>
writing_mode
:
WritingMode
force_nonfloated
:
ForceNonfloatedFlag
)
-
>
BaseFlow
{
let
mut
flags
=
FlowFlags
:
:
empty
(
)
;
match
node
{
None
=
>
{
}
Some
(
node
)
=
>
{
let
node_style
=
node
.
style
(
)
;
match
node_style
.
get_box
(
)
.
position
{
position
:
:
T
:
:
absolute
|
position
:
:
T
:
:
fixed
=
>
{
flags
.
insert
(
IS_ABSOLUTELY_POSITIONED
)
}
_
=
>
{
}
}
if
force_nonfloated
=
=
ForceNonfloatedFlag
:
:
FloatIfNecessary
{
match
node_style
.
get_box
(
)
.
float
{
float
:
:
T
:
:
none
=
>
{
}
float
:
:
T
:
:
left
=
>
flags
.
insert
(
FLOATS_LEFT
)
float
:
:
T
:
:
right
=
>
flags
.
insert
(
FLOATS_RIGHT
)
}
}
match
node_style
.
get_box
(
)
.
clear
{
clear
:
:
T
:
:
none
=
>
{
}
clear
:
:
T
:
:
left
=
>
flags
.
insert
(
CLEARS_LEFT
)
clear
:
:
T
:
:
right
=
>
flags
.
insert
(
CLEARS_RIGHT
)
clear
:
:
T
:
:
both
=
>
{
flags
.
insert
(
CLEARS_LEFT
)
;
flags
.
insert
(
CLEARS_RIGHT
)
;
}
}
}
}
let
mut
damage
=
RestyleDamage
:
:
all
(
)
;
damage
.
remove
(
RECONSTRUCT_FLOW
)
;
BaseFlow
{
ref_count
:
AtomicUint
:
:
new
(
1
)
restyle_damage
:
damage
children
:
FlowList
:
:
new
(
)
intrinsic_inline_sizes
:
IntrinsicISizes
:
:
new
(
)
position
:
LogicalRect
:
:
zero
(
writing_mode
)
overflow
:
ZERO_RECT
parallel
:
FlowParallelInfo
:
:
new
(
)
floats
:
Floats
:
:
new
(
writing_mode
)
collapsible_margins
:
CollapsibleMargins
:
:
new
(
)
stacking_relative_position
:
Point2D
:
:
zero
(
)
abs_descendants
:
Descendants
:
:
new
(
)
absolute_static_i_offset
:
Au
(
0
)
fixed_static_i_offset
:
Au
(
0
)
block_container_inline_size
:
Au
(
0
)
block_container_explicit_block_size
:
None
absolute_cb
:
ContainingBlockLink
:
:
new
(
)
display_list_building_result
:
DisplayListBuildingResult
:
:
None
absolute_position_info
:
AbsolutePositionInfo
:
:
new
(
writing_mode
)
clip
:
ClippingRegion
:
:
max
(
)
flags
:
flags
writing_mode
:
writing_mode
}
}
pub
fn
child_iter
<
'
a
>
(
&
'
a
mut
self
)
-
>
MutFlowListIterator
<
'
a
>
{
self
.
children
.
iter_mut
(
)
}
pub
unsafe
fn
ref_count
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
AtomicUint
{
&
self
.
ref_count
}
pub
fn
debug_id
(
&
self
)
-
>
uint
{
let
p
=
self
as
*
const
_
;
p
as
uint
}
pub
fn
validate_display_list_geometry
(
&
self
)
{
let
container_size
=
Size2D
:
:
zero
(
)
;
let
position_with_overflow
=
self
.
position
.
to_physical
(
self
.
writing_mode
container_size
)
.
union
(
&
self
.
overflow
)
;
let
bounds
=
Rect
(
self
.
stacking_relative_position
position_with_overflow
.
size
)
;
let
all_items
=
match
self
.
display_list_building_result
{
DisplayListBuildingResult
:
:
None
=
>
Vec
:
:
new
(
)
DisplayListBuildingResult
:
:
StackingContext
(
ref
stacking_context
)
=
>
{
stacking_context
.
display_list
.
all_display_items
(
)
}
DisplayListBuildingResult
:
:
Normal
(
ref
display_list
)
=
>
display_list
.
all_display_items
(
)
}
;
for
item
in
all_items
.
iter
(
)
{
let
paint_bounds
=
item
.
base
(
)
.
clip
.
clone
(
)
.
intersect_rect
(
&
item
.
base
(
)
.
bounds
)
;
if
!
paint_bounds
.
might_be_nonempty
(
)
{
continue
;
}
if
bounds
.
union
(
&
paint_bounds
.
bounding_rect
(
)
)
!
=
bounds
{
error
!
(
"
DisplayList
item
{
:
?
}
outside
of
Flow
overflow
(
{
:
?
}
)
"
item
paint_bounds
)
;
}
}
}
}
impl
<
'
a
>
ImmutableFlowUtils
for
&
'
a
(
Flow
+
'
a
)
{
fn
is_block_like
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Block
=
>
true
_
=
>
false
}
}
fn
is_proper_table_child
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableRow
|
FlowClass
:
:
TableRowGroup
|
FlowClass
:
:
TableColGroup
|
FlowClass
:
:
TableCaption
=
>
true
_
=
>
false
}
}
fn
is_table_row
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableRow
=
>
true
_
=
>
false
}
}
fn
is_table_cell
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableCell
=
>
true
_
=
>
false
}
}
fn
is_table_colgroup
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableColGroup
=
>
true
_
=
>
false
}
}
fn
is_table
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Table
=
>
true
_
=
>
false
}
}
fn
is_table_caption
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableCaption
=
>
true
_
=
>
false
}
}
fn
is_table_rowgroup
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableRowGroup
=
>
true
_
=
>
false
}
}
fn
is_table_kind
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableWrapper
|
FlowClass
:
:
Table
|
FlowClass
:
:
TableColGroup
|
FlowClass
:
:
TableRowGroup
|
FlowClass
:
:
TableRow
|
FlowClass
:
:
TableCaption
|
FlowClass
:
:
TableCell
=
>
true
_
=
>
false
}
}
fn
need_anonymous_flow
(
self
child
:
&
Flow
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Table
=
>
!
child
.
is_proper_table_child
(
)
FlowClass
:
:
TableRowGroup
=
>
!
child
.
is_table_row
(
)
FlowClass
:
:
TableRow
=
>
!
child
.
is_table_cell
(
)
_
=
>
false
}
}
fn
generate_missing_child_flow
(
self
node
:
&
ThreadSafeLayoutNode
)
-
>
FlowRef
{
let
flow
=
match
self
.
class
(
)
{
FlowClass
:
:
Table
|
FlowClass
:
:
TableRowGroup
=
>
{
let
fragment
=
Fragment
:
:
new_anonymous_from_specific_info
(
node
SpecificFragmentInfo
:
:
TableRow
)
;
box
TableRowFlow
:
:
from_node_and_fragment
(
node
fragment
)
as
Box
<
Flow
>
}
FlowClass
:
:
TableRow
=
>
{
let
fragment
=
Fragment
:
:
new_anonymous_from_specific_info
(
node
SpecificFragmentInfo
:
:
TableCell
)
;
let
hide
=
node
.
style
(
)
.
get_inheritedtable
(
)
.
empty_cells
=
=
empty_cells
:
:
T
:
:
hide
;
box
TableCellFlow
:
:
from_node_fragment_and_visibility_flag
(
node
fragment
!
hide
)
as
Box
<
Flow
>
}
_
=
>
{
panic
!
(
"
no
need
to
generate
a
missing
child
"
)
}
}
;
FlowRef
:
:
new
(
flow
)
}
fn
is_leaf
(
self
)
-
>
bool
{
base
(
self
)
.
children
.
len
(
)
=
=
0
}
fn
child_count
(
self
)
-
>
uint
{
base
(
self
)
.
children
.
len
(
)
}
fn
is_block_container
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Block
|
FlowClass
:
:
TableCaption
|
FlowClass
:
:
TableCell
=
>
{
self
.
child_count
(
)
!
=
0
}
_
=
>
false
}
}
fn
is_block_flow
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Block
=
>
true
_
=
>
false
}
}
fn
is_inline_flow
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Inline
=
>
true
_
=
>
false
}
}
fn
dump
(
self
)
{
self
.
dump_with_level
(
0
)
}
fn
dump_with_level
(
self
level
:
uint
)
{
let
mut
indent
=
String
:
:
new
(
)
;
for
_
in
range
(
0
level
)
{
indent
.
push_str
(
"
|
"
)
}
for
kid
in
imm_child_iter
(
self
)
{
kid
.
dump_with_level
(
level
+
1
)
}
}
}
impl
<
'
a
>
MutableFlowUtils
for
&
'
a
mut
(
Flow
+
'
a
)
{
fn
traverse_preorder
<
T
:
PreorderFlowTraversal
>
(
self
traversal
:
&
T
)
{
if
traversal
.
should_process
(
self
)
{
traversal
.
process
(
self
)
;
}
for
kid
in
child_iter
(
self
)
{
kid
.
traverse_preorder
(
traversal
)
;
}
}
fn
traverse_postorder
<
T
:
PostorderFlowTraversal
>
(
self
traversal
:
&
T
)
{
for
kid
in
child_iter
(
self
)
{
kid
.
traverse_postorder
(
traversal
)
;
}
if
traversal
.
should_process
(
self
)
{
traversal
.
process
(
self
)
}
}
fn
store_overflow
(
self
_
:
&
LayoutContext
)
{
let
mut
overflow
=
self
.
compute_overflow
(
)
;
if
self
.
is_block_container
(
)
{
let
container_size
=
Size2D
:
:
zero
(
)
;
for
kid
in
child_iter
(
self
)
{
if
base
(
kid
)
.
flags
.
contains
(
IS_ABSOLUTELY_POSITIONED
)
{
continue
}
let
kid_overflow
=
base
(
kid
)
.
overflow
;
let
kid_position
=
base
(
kid
)
.
position
.
to_physical
(
base
(
kid
)
.
writing_mode
container_size
)
;
overflow
=
overflow
.
union
(
&
kid_overflow
.
translate
(
&
kid_position
.
origin
)
)
}
for
kid
in
mut_base
(
self
)
.
abs_descendants
.
iter
(
)
{
let
kid_overflow
=
base
(
kid
)
.
overflow
;
let
kid_position
=
base
(
kid
)
.
position
.
to_physical
(
base
(
kid
)
.
writing_mode
container_size
)
;
overflow
=
overflow
.
union
(
&
kid_overflow
.
translate
(
&
kid_position
.
origin
)
)
}
}
mut_base
(
self
)
.
overflow
=
overflow
;
}
fn
collect_static_block_offsets_from_children
(
self
)
{
let
mut
absolute_descendant_block_offsets
=
Vec
:
:
new
(
)
;
for
kid
in
mut_base
(
self
)
.
child_iter
(
)
{
let
mut
gives_absolute_offsets
=
true
;
if
kid
.
is_block_like
(
)
{
let
kid_block
=
kid
.
as_block
(
)
;
if
kid_block
.
is_fixed
(
)
|
|
kid_block
.
base
.
flags
.
contains
(
IS_ABSOLUTELY_POSITIONED
)
{
gives_absolute_offsets
=
false
;
absolute_descendant_block_offsets
.
push
(
kid_block
.
get_hypothetical_block_start_edge
(
)
)
;
}
else
if
kid_block
.
is_positioned
(
)
{
gives_absolute_offsets
=
false
;
}
}
if
gives_absolute_offsets
{
let
kid_base
=
mut_base
(
kid
)
;
let
offsets
=
mem
:
:
replace
(
&
mut
kid_base
.
abs_descendants
.
static_block_offsets
Vec
:
:
new
(
)
)
;
for
block_offset
in
offsets
.
into_iter
(
)
{
absolute_descendant_block_offsets
.
push
(
block_offset
+
kid_base
.
position
.
start
.
b
)
;
}
}
}
mut_base
(
self
)
.
abs_descendants
.
static_block_offsets
=
absolute_descendant_block_offsets
}
}
impl
MutableOwnedFlowUtils
for
FlowRef
{
fn
set_absolute_descendants
(
&
mut
self
abs_descendants
:
AbsDescendants
)
{
let
this
=
self
.
clone
(
)
;
let
block
=
self
.
as_block
(
)
;
block
.
base
.
abs_descendants
=
abs_descendants
;
for
descendant_link
in
block
.
base
.
abs_descendants
.
iter
(
)
{
let
base
=
mut_base
(
descendant_link
)
;
base
.
absolute_cb
.
set
(
this
.
clone
(
)
)
;
}
}
}
pub
struct
ContainingBlockLink
{
link
:
Option
<
FlowRef
>
}
impl
ContainingBlockLink
{
fn
new
(
)
-
>
ContainingBlockLink
{
ContainingBlockLink
{
link
:
None
}
}
fn
set
(
&
mut
self
link
:
FlowRef
)
{
self
.
link
=
Some
(
link
)
}
pub
unsafe
fn
get
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Option
<
FlowRef
>
{
&
mut
self
.
link
}
#
[
inline
]
pub
fn
generated_containing_block_rect
(
&
mut
self
)
-
>
LogicalRect
<
Au
>
{
match
self
.
link
{
None
=
>
panic
!
(
"
haven
'
t
done
it
"
)
Some
(
ref
mut
link
)
=
>
link
.
generated_containing_block_rect
(
)
}
}
}
