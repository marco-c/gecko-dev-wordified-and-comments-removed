use
app_units
:
:
Au
;
use
block
:
:
BlockFlow
;
use
context
:
:
LayoutContext
;
use
euclid
:
:
{
Point2D
Rect
Size2D
}
;
use
floats
:
:
Floats
;
use
flow_list
:
:
{
FlowList
FlowListIterator
MutFlowListIterator
}
;
use
flow_ref
:
:
{
self
FlowRef
WeakFlowRef
}
;
use
fragment
:
:
{
Fragment
FragmentBorderBoxIterator
SpecificFragmentInfo
}
;
use
gfx
:
:
display_list
:
:
{
ClippingRegion
DisplayList
}
;
use
gfx_traits
:
:
{
LayerId
LayerType
}
;
use
incremental
:
:
{
RECONSTRUCT_FLOW
REFLOW
REFLOW_OUT_OF_FLOW
REPAINT
RestyleDamage
}
;
use
inline
:
:
InlineFlow
;
use
model
:
:
{
CollapsibleMargins
IntrinsicISizes
MarginCollapseInfo
}
;
use
multicol
:
:
MulticolFlow
;
use
parallel
:
:
FlowParallelInfo
;
use
rustc_serialize
:
:
{
Encodable
Encoder
}
;
use
std
:
:
iter
:
:
Zip
;
use
std
:
:
slice
:
:
IterMut
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
use
std
:
:
{
fmt
mem
raw
}
;
use
style
:
:
computed_values
:
:
{
clear
display
empty_cells
float
position
text_align
}
;
use
style
:
:
dom
:
:
TRestyleDamage
;
use
style
:
:
properties
:
:
{
self
ComputedValues
}
;
use
style
:
:
values
:
:
computed
:
:
LengthOrPercentageOrAuto
;
use
table
:
:
{
ColumnComputedInlineSize
ColumnIntrinsicInlineSize
TableFlow
}
;
use
table_caption
:
:
TableCaptionFlow
;
use
table_cell
:
:
TableCellFlow
;
use
table_colgroup
:
:
TableColGroupFlow
;
use
table_row
:
:
TableRowFlow
;
use
table_rowgroup
:
:
TableRowGroupFlow
;
use
table_wrapper
:
:
TableWrapperFlow
;
use
util
:
:
logical_geometry
:
:
{
LogicalRect
LogicalSize
WritingMode
}
;
use
util
:
:
print_tree
:
:
PrintTree
;
use
wrapper
:
:
{
PseudoElementType
ThreadSafeLayoutNode
}
;
pub
trait
Flow
:
fmt
:
:
Debug
+
Sync
+
Send
+
'
static
{
fn
class
(
&
self
)
-
>
FlowClass
;
fn
as_block
(
&
self
)
-
>
&
BlockFlow
{
panic
!
(
"
called
as_block
(
)
on
a
non
-
block
flow
"
)
}
fn
as_mut_block
(
&
mut
self
)
-
>
&
mut
BlockFlow
{
debug
!
(
"
called
as_mut_block
(
)
on
a
flow
of
type
{
:
?
}
"
self
.
class
(
)
)
;
panic
!
(
"
called
as_mut_block
(
)
on
a
non
-
block
flow
"
)
}
fn
as_inline
(
&
self
)
-
>
&
InlineFlow
{
panic
!
(
"
called
as_inline
(
)
on
a
non
-
inline
flow
"
)
}
fn
as_mut_inline
(
&
mut
self
)
-
>
&
mut
InlineFlow
{
panic
!
(
"
called
as_mut_inline
(
)
on
a
non
-
inline
flow
"
)
}
fn
as_mut_table_wrapper
(
&
mut
self
)
-
>
&
mut
TableWrapperFlow
{
panic
!
(
"
called
as_mut_table_wrapper
(
)
on
a
non
-
tablewrapper
flow
"
)
}
fn
as_table_wrapper
(
&
self
)
-
>
&
TableWrapperFlow
{
panic
!
(
"
called
as_table_wrapper
(
)
on
a
non
-
tablewrapper
flow
"
)
}
fn
as_mut_table
(
&
mut
self
)
-
>
&
mut
TableFlow
{
panic
!
(
"
called
as_mut_table
(
)
on
a
non
-
table
flow
"
)
}
fn
as_table
(
&
self
)
-
>
&
TableFlow
{
panic
!
(
"
called
as_table
(
)
on
a
non
-
table
flow
"
)
}
fn
as_mut_table_colgroup
(
&
mut
self
)
-
>
&
mut
TableColGroupFlow
{
panic
!
(
"
called
as_mut_table_colgroup
(
)
on
a
non
-
tablecolgroup
flow
"
)
}
fn
as_mut_table_rowgroup
(
&
mut
self
)
-
>
&
mut
TableRowGroupFlow
{
panic
!
(
"
called
as_mut_table_rowgroup
(
)
on
a
non
-
tablerowgroup
flow
"
)
}
fn
as_table_rowgroup
(
&
self
)
-
>
&
TableRowGroupFlow
{
panic
!
(
"
called
as_table_rowgroup
(
)
on
a
non
-
tablerowgroup
flow
"
)
}
fn
as_mut_table_row
(
&
mut
self
)
-
>
&
mut
TableRowFlow
{
panic
!
(
"
called
as_mut_table_row
(
)
on
a
non
-
tablerow
flow
"
)
}
fn
as_table_row
(
&
self
)
-
>
&
TableRowFlow
{
panic
!
(
"
called
as_table_row
(
)
on
a
non
-
tablerow
flow
"
)
}
fn
as_mut_table_caption
(
&
mut
self
)
-
>
&
mut
TableCaptionFlow
{
panic
!
(
"
called
as_mut_table_caption
(
)
on
a
non
-
tablecaption
flow
"
)
}
fn
as_mut_table_cell
(
&
mut
self
)
-
>
&
mut
TableCellFlow
{
panic
!
(
"
called
as_mut_table_cell
(
)
on
a
non
-
tablecell
flow
"
)
}
fn
as_mut_multicol
(
&
mut
self
)
-
>
&
mut
MulticolFlow
{
panic
!
(
"
called
as_mut_multicol
(
)
on
a
non
-
multicol
flow
"
)
}
fn
as_table_cell
(
&
self
)
-
>
&
TableCellFlow
{
panic
!
(
"
called
as_table_cell
(
)
on
a
non
-
tablecell
flow
"
)
}
fn
column_intrinsic_inline_sizes
(
&
mut
self
)
-
>
&
mut
Vec
<
ColumnIntrinsicInlineSize
>
{
panic
!
(
"
called
column_intrinsic_inline_sizes
(
)
on
non
-
table
flow
"
)
}
fn
column_computed_inline_sizes
(
&
mut
self
)
-
>
&
mut
Vec
<
ColumnComputedInlineSize
>
{
panic
!
(
"
called
column_intrinsic_inline_sizes
(
)
on
non
-
table
flow
"
)
}
fn
bubble_inline_sizes
(
&
mut
self
)
{
panic
!
(
"
bubble_inline_sizes
not
yet
implemented
"
)
}
fn
assign_inline_sizes
(
&
mut
self
_ctx
:
&
LayoutContext
)
{
panic
!
(
"
assign_inline_sizes
not
yet
implemented
"
)
}
fn
assign_block_size
<
'
a
>
(
&
mut
self
_ctx
:
&
'
a
LayoutContext
<
'
a
>
)
{
panic
!
(
"
assign_block_size
not
yet
implemented
"
)
}
fn
fragment
(
&
mut
self
layout_context
:
&
LayoutContext
_fragmentation_context
:
Option
<
FragmentationContext
>
)
-
>
Option
<
FlowRef
>
{
fn
recursive_assign_block_size
<
F
:
?
Sized
+
Flow
>
(
flow
:
&
mut
F
ctx
:
&
LayoutContext
)
{
for
child
in
mut_base
(
flow
)
.
children
.
iter_mut
(
)
{
recursive_assign_block_size
(
child
ctx
)
}
flow
.
assign_block_size
(
ctx
)
;
}
recursive_assign_block_size
(
self
layout_context
)
;
None
}
fn
place_float_if_applicable
<
'
a
>
(
&
mut
self
_
:
&
'
a
LayoutContext
<
'
a
>
)
{
}
fn
assign_block_size_for_inorder_child_if_necessary
<
'
a
>
(
&
mut
self
layout_context
:
&
'
a
LayoutContext
<
'
a
>
parent_thread_id
:
u8
)
-
>
bool
{
let
impacted
=
base
(
self
)
.
flags
.
impacted_by_floats
(
)
;
if
impacted
{
mut_base
(
self
)
.
thread_id
=
parent_thread_id
;
self
.
assign_block_size
(
layout_context
)
;
mut_base
(
self
)
.
restyle_damage
.
remove
(
REFLOW_OUT_OF_FLOW
|
REFLOW
)
;
}
impacted
}
fn
store_overflow
(
&
mut
self
_
:
&
LayoutContext
)
{
let
mut
overflow
=
self
.
compute_overflow
(
)
;
match
self
.
class
(
)
{
FlowClass
:
:
Block
|
FlowClass
:
:
TableCaption
|
FlowClass
:
:
TableCell
=
>
{
let
container_size
=
Size2D
:
:
zero
(
)
;
for
kid
in
mut_base
(
self
)
.
children
.
iter_mut
(
)
{
let
kid_overflow
=
base
(
kid
)
.
overflow
;
let
kid_position
=
base
(
kid
)
.
position
.
to_physical
(
base
(
kid
)
.
writing_mode
container_size
)
;
overflow
=
overflow
.
union
(
&
kid_overflow
.
translate
(
&
kid_position
.
origin
)
)
}
}
_
=
>
{
}
}
mut_base
(
self
)
.
overflow
=
overflow
;
}
fn
compute_absolute_position
(
&
mut
self
_
:
&
LayoutContext
)
{
}
fn
build_display_list
(
&
mut
self
layout_context
:
&
LayoutContext
)
;
fn
compute_overflow
(
&
self
)
-
>
Rect
<
Au
>
;
fn
iterate_through_fragment_border_boxes
(
&
self
iterator
:
&
mut
FragmentBorderBoxIterator
level
:
i32
stacking_context_position
:
&
Point2D
<
Au
>
)
;
fn
mutate_fragments
(
&
mut
self
mutator
:
&
mut
FnMut
(
&
mut
Fragment
)
)
;
fn
compute_collapsible_block_start_margin
(
&
mut
self
_layout_context
:
&
mut
LayoutContext
_margin_collapse_info
:
&
mut
MarginCollapseInfo
)
{
}
fn
mark_as_root
(
&
mut
self
)
{
debug
!
(
"
called
mark_as_root
(
)
on
a
flow
of
type
{
:
?
}
"
self
.
class
(
)
)
;
panic
!
(
"
called
mark_as_root
(
)
on
an
unhandled
flow
"
)
;
}
fn
is_root
(
&
self
)
-
>
bool
{
false
}
fn
positioning
(
&
self
)
-
>
position
:
:
T
{
position
:
:
T
:
:
static_
}
fn
is_fixed
(
&
self
)
-
>
bool
{
self
.
positioning
(
)
=
=
position
:
:
T
:
:
fixed
}
fn
contains_positioned_fragments
(
&
self
)
-
>
bool
{
self
.
contains_relatively_positioned_fragments
(
)
|
|
base
(
self
)
.
flags
.
contains
(
IS_ABSOLUTELY_POSITIONED
)
}
fn
contains_relatively_positioned_fragments
(
&
self
)
-
>
bool
{
self
.
positioning
(
)
=
=
position
:
:
T
:
:
relative
}
fn
is_absolute_containing_block
(
&
self
)
-
>
bool
{
false
}
fn
update_late_computed_inline_position_if_necessary
(
&
mut
self
inline_position
:
Au
)
;
fn
update_late_computed_block_position_if_necessary
(
&
mut
self
block_position
:
Au
)
;
fn
generated_containing_block_size
(
&
self
_
:
OpaqueFlow
)
-
>
LogicalSize
<
Au
>
;
#
[
allow
(
unsafe_code
)
]
fn
layer_id
(
&
self
)
-
>
LayerId
{
let
obj
=
unsafe
{
mem
:
:
transmute
:
:
<
&
&
Self
&
raw
:
:
TraitObject
>
(
&
self
)
}
;
LayerId
:
:
new_of_type
(
LayerType
:
:
FragmentBody
obj
.
data
as
usize
)
}
#
[
allow
(
unsafe_code
)
]
fn
layer_id_for_overflow_scroll
(
&
self
)
-
>
LayerId
{
let
obj
=
unsafe
{
mem
:
:
transmute
:
:
<
&
&
Self
&
raw
:
:
TraitObject
>
(
&
self
)
}
;
LayerId
:
:
new_of_type
(
LayerType
:
:
OverflowScroll
obj
.
data
as
usize
)
}
fn
repair_style
(
&
mut
self
new_style
:
&
Arc
<
ComputedValues
>
)
;
fn
print_extra_flow_children
(
&
self
_
:
&
mut
PrintTree
)
{
}
}
#
[
inline
(
always
)
]
#
[
allow
(
unsafe_code
)
]
pub
fn
base
<
T
:
?
Sized
+
Flow
>
(
this
:
&
T
)
-
>
&
BaseFlow
{
unsafe
{
let
obj
=
mem
:
:
transmute
:
:
<
&
&
T
&
raw
:
:
TraitObject
>
(
&
this
)
;
mem
:
:
transmute
:
:
<
*
mut
(
)
&
BaseFlow
>
(
obj
.
data
)
}
}
pub
fn
imm_child_iter
<
'
a
>
(
flow
:
&
'
a
Flow
)
-
>
FlowListIterator
<
'
a
>
{
base
(
flow
)
.
children
.
iter
(
)
}
#
[
inline
(
always
)
]
#
[
allow
(
unsafe_code
)
]
pub
fn
mut_base
<
T
:
?
Sized
+
Flow
>
(
this
:
&
mut
T
)
-
>
&
mut
BaseFlow
{
unsafe
{
let
obj
=
mem
:
:
transmute
:
:
<
&
&
mut
T
&
raw
:
:
TraitObject
>
(
&
this
)
;
mem
:
:
transmute
:
:
<
*
mut
(
)
&
mut
BaseFlow
>
(
obj
.
data
)
}
}
pub
fn
child_iter
<
'
a
>
(
flow
:
&
'
a
mut
Flow
)
-
>
MutFlowListIterator
<
'
a
>
{
mut_base
(
flow
)
.
children
.
iter_mut
(
)
}
pub
trait
ImmutableFlowUtils
{
fn
is_block_like
(
self
)
-
>
bool
;
fn
is_table
(
self
)
-
>
bool
;
fn
is_table_caption
(
self
)
-
>
bool
;
fn
is_proper_table_child
(
self
)
-
>
bool
;
fn
is_table_row
(
self
)
-
>
bool
;
fn
is_table_cell
(
self
)
-
>
bool
;
fn
is_table_colgroup
(
self
)
-
>
bool
;
fn
is_table_rowgroup
(
self
)
-
>
bool
;
fn
is_table_kind
(
self
)
-
>
bool
;
fn
need_anonymous_flow
(
self
child
:
&
Flow
)
-
>
bool
;
fn
generate_missing_child_flow
<
'
ln
N
:
ThreadSafeLayoutNode
<
'
ln
>
>
(
self
node
:
&
N
)
-
>
FlowRef
;
fn
contains_roots_of_absolute_flow_tree
(
&
self
)
-
>
bool
;
fn
is_leaf
(
self
)
-
>
bool
;
fn
child_count
(
self
)
-
>
usize
;
fn
is_block_container
(
self
)
-
>
bool
;
fn
is_block_flow
(
self
)
-
>
bool
;
fn
is_inline_flow
(
self
)
-
>
bool
;
fn
print
(
self
title
:
String
)
;
fn
print_with_tree
(
self
print_tree
:
&
mut
PrintTree
)
;
}
pub
trait
MutableFlowUtils
{
fn
traverse_preorder
<
T
:
PreorderFlowTraversal
>
(
self
traversal
:
&
T
)
;
fn
traverse_postorder
<
T
:
PostorderFlowTraversal
>
(
self
traversal
:
&
T
)
;
fn
traverse_preorder_absolute_flows
<
T
>
(
&
mut
self
traversal
:
&
mut
T
)
where
T
:
PreorderFlowTraversal
;
fn
traverse_postorder_absolute_flows
<
T
>
(
&
mut
self
traversal
:
&
mut
T
)
where
T
:
PostorderFlowTraversal
;
fn
repair_style_and_bubble_inline_sizes
(
self
style
:
&
Arc
<
ComputedValues
>
)
;
}
pub
trait
MutableOwnedFlowUtils
{
fn
set_absolute_descendants
(
&
mut
self
abs_descendants
:
AbsoluteDescendants
)
;
fn
take_applicable_absolute_descendants
(
&
mut
self
absolute_descendants
:
&
mut
AbsoluteDescendants
)
;
}
#
[
derive
(
RustcEncodable
PartialEq
Debug
)
]
pub
enum
FlowClass
{
Block
Inline
ListItem
TableWrapper
Table
TableColGroup
TableRowGroup
TableRow
TableCaption
TableCell
Multicol
MulticolColumn
Flex
}
pub
trait
PreorderFlowTraversal
{
fn
process
(
&
self
flow
:
&
mut
Flow
)
;
fn
should_process
(
&
self
_flow
:
&
mut
Flow
)
-
>
bool
{
true
}
}
pub
trait
PostorderFlowTraversal
{
fn
process
(
&
self
flow
:
&
mut
Flow
)
;
fn
should_process
(
&
self
_flow
:
&
mut
Flow
)
-
>
bool
{
true
}
}
pub
trait
InorderFlowTraversal
{
fn
process
(
&
mut
self
flow
:
&
mut
Flow
level
:
u32
)
;
fn
should_process
(
&
mut
self
flow
:
&
mut
Flow
)
-
>
bool
;
}
bitflags
!
{
#
[
doc
=
"
Flags
used
in
flows
.
"
]
flags
FlowFlags
:
u32
{
/
/
floated
descendants
flags
#
[
doc
=
"
Whether
this
flow
has
descendants
that
float
left
in
the
same
block
formatting
"
]
#
[
doc
=
"
context
.
"
]
const
HAS_LEFT_FLOATED_DESCENDANTS
=
0b0000_0000_0000_0000_0001
#
[
doc
=
"
Whether
this
flow
has
descendants
that
float
right
in
the
same
block
formatting
"
]
#
[
doc
=
"
context
.
"
]
const
HAS_RIGHT_FLOATED_DESCENDANTS
=
0b0000_0000_0000_0000_0010
#
[
doc
=
"
Whether
this
flow
is
impacted
by
floats
to
the
left
in
the
same
block
formatting
"
]
#
[
doc
=
"
context
(
i
.
e
.
its
height
depends
on
some
prior
flows
with
float
:
left
)
.
"
]
const
IMPACTED_BY_LEFT_FLOATS
=
0b0000_0000_0000_0000_0100
#
[
doc
=
"
Whether
this
flow
is
impacted
by
floats
to
the
right
in
the
same
block
"
]
#
[
doc
=
"
formatting
context
(
i
.
e
.
its
height
depends
on
some
prior
flows
with
float
:
"
]
#
[
doc
=
"
right
)
.
"
]
const
IMPACTED_BY_RIGHT_FLOATS
=
0b0000_0000_0000_0000_1000
/
/
text
align
flags
#
[
doc
=
"
Whether
this
flow
must
have
its
own
layer
.
Even
if
this
flag
is
not
set
it
might
"
]
#
[
doc
=
"
get
its
own
layer
if
it
'
s
deemed
to
be
likely
to
overlap
flows
with
their
own
"
]
#
[
doc
=
"
layer
.
"
]
const
NEEDS_LAYER
=
0b0000_0000_0000_0010_0000
#
[
doc
=
"
Whether
this
flow
is
absolutely
positioned
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
IS_ABSOLUTELY_POSITIONED
=
0b0000_0000_0000_0100_0000
#
[
doc
=
"
Whether
this
flow
clears
to
the
left
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
CLEARS_LEFT
=
0b0000_0000_0000_1000_0000
#
[
doc
=
"
Whether
this
flow
clears
to
the
right
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
CLEARS_RIGHT
=
0b0000_0000_0001_0000_0000
#
[
doc
=
"
Whether
this
flow
is
left
-
floated
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
FLOATS_LEFT
=
0b0000_0000_0010_0000_0000
#
[
doc
=
"
Whether
this
flow
is
right
-
floated
.
This
is
checked
all
over
layout
so
a
"
]
#
[
doc
=
"
virtual
call
is
too
expensive
.
"
]
const
FLOATS_RIGHT
=
0b0000_0000_0100_0000_0000
#
[
doc
=
"
Text
alignment
.
\
NB
:
If
you
update
this
update
TEXT_ALIGN_SHIFT
below
.
"
]
const
TEXT_ALIGN
=
0b0000_0111_1000_0000_0000
#
[
doc
=
"
Whether
this
flow
has
a
fragment
with
counter
-
reset
or
counter
-
increment
\
styles
.
"
]
const
AFFECTS_COUNTERS
=
0b0000_1000_0000_0000_0000
#
[
doc
=
"
Whether
this
flow
'
s
descendants
have
fragments
that
affect
counter
-
reset
or
\
counter
-
increment
styles
.
"
]
const
HAS_COUNTER_AFFECTING_CHILDREN
=
0b0001_0000_0000_0000_0000
#
[
doc
=
"
Whether
this
flow
behaves
as
though
it
had
position
:
static
for
the
purposes
\
of
positioning
in
the
inline
direction
.
This
is
set
for
flows
with
position
:
\
static
and
position
:
relative
as
well
as
absolutely
-
positioned
flows
with
\
unconstrained
positions
in
the
inline
direction
.
"
]
const
INLINE_POSITION_IS_STATIC
=
0b0010_0000_0000_0000_0000
#
[
doc
=
"
Whether
this
flow
behaves
as
though
it
had
position
:
static
for
the
purposes
\
of
positioning
in
the
block
direction
.
This
is
set
for
flows
with
position
:
\
static
and
position
:
relative
as
well
as
absolutely
-
positioned
flows
with
\
unconstrained
positions
in
the
block
direction
.
"
]
const
BLOCK_POSITION_IS_STATIC
=
0b0100_0000_0000_0000_0000
/
/
/
Whether
any
ancestor
is
a
fragmentation
container
const
CAN_BE_FRAGMENTED
=
0b1000_0000_0000_0000_0000
}
}
static
HAS_FLOATED_DESCENDANTS_BITMASK
:
FlowFlags
=
FlowFlags
{
bits
:
0b0000_0011
}
;
static
TEXT_ALIGN_SHIFT
:
usize
=
11
;
impl
FlowFlags
{
#
[
inline
]
pub
fn
text_align
(
self
)
-
>
text_align
:
:
T
{
text_align
:
:
T
:
:
from_u32
(
(
self
&
TEXT_ALIGN
)
.
bits
(
)
>
>
TEXT_ALIGN_SHIFT
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
set_text_align
(
&
mut
self
value
:
text_align
:
:
T
)
{
*
self
=
(
*
self
&
!
TEXT_ALIGN
)
|
FlowFlags
:
:
from_bits
(
value
.
to_u32
(
)
<
<
TEXT_ALIGN_SHIFT
)
.
unwrap
(
)
;
}
#
[
inline
]
pub
fn
union_floated_descendants_flags
(
&
mut
self
other
:
FlowFlags
)
{
self
.
insert
(
other
&
HAS_FLOATED_DESCENDANTS_BITMASK
)
;
}
#
[
inline
]
pub
fn
impacted_by_floats
(
&
self
)
-
>
bool
{
self
.
contains
(
IMPACTED_BY_LEFT_FLOATS
)
|
|
self
.
contains
(
IMPACTED_BY_RIGHT_FLOATS
)
}
#
[
inline
]
pub
fn
set
(
&
mut
self
flags
:
FlowFlags
value
:
bool
)
{
if
value
{
self
.
insert
(
flags
)
;
}
else
{
self
.
remove
(
flags
)
;
}
}
#
[
inline
]
pub
fn
float_kind
(
&
self
)
-
>
float
:
:
T
{
if
self
.
contains
(
FLOATS_LEFT
)
{
float
:
:
T
:
:
left
}
else
if
self
.
contains
(
FLOATS_RIGHT
)
{
float
:
:
T
:
:
right
}
else
{
float
:
:
T
:
:
none
}
}
#
[
inline
]
pub
fn
is_float
(
&
self
)
-
>
bool
{
self
.
contains
(
FLOATS_LEFT
)
|
|
self
.
contains
(
FLOATS_RIGHT
)
}
#
[
inline
]
pub
fn
clears_floats
(
&
self
)
-
>
bool
{
self
.
contains
(
CLEARS_LEFT
)
|
|
self
.
contains
(
CLEARS_RIGHT
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
AbsoluteDescendants
{
descendant_links
:
Vec
<
AbsoluteDescendantInfo
>
}
impl
AbsoluteDescendants
{
pub
fn
new
(
)
-
>
AbsoluteDescendants
{
AbsoluteDescendants
{
descendant_links
:
Vec
:
:
new
(
)
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
descendant_links
.
len
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
descendant_links
.
is_empty
(
)
}
pub
fn
push
(
&
mut
self
given_descendant
:
FlowRef
)
{
self
.
descendant_links
.
push
(
AbsoluteDescendantInfo
{
flow
:
given_descendant
has_reached_containing_block
:
false
}
)
;
}
pub
fn
push_descendants
(
&
mut
self
given_descendants
:
AbsoluteDescendants
)
{
for
elem
in
given_descendants
.
descendant_links
{
self
.
descendant_links
.
push
(
elem
)
;
}
}
pub
fn
iter
(
&
mut
self
)
-
>
AbsoluteDescendantIter
{
AbsoluteDescendantIter
{
iter
:
self
.
descendant_links
.
iter_mut
(
)
}
}
pub
fn
mark_as_having_reached_containing_block
(
&
mut
self
)
{
for
descendant_info
in
self
.
descendant_links
.
iter_mut
(
)
{
descendant_info
.
has_reached_containing_block
=
true
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
AbsoluteDescendantInfo
{
flow
:
FlowRef
has_reached_containing_block
:
bool
}
pub
struct
AbsoluteDescendantIter
<
'
a
>
{
iter
:
IterMut
<
'
a
AbsoluteDescendantInfo
>
}
impl
<
'
a
>
Iterator
for
AbsoluteDescendantIter
<
'
a
>
{
type
Item
=
&
'
a
mut
Flow
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
mut
Flow
>
{
self
.
iter
.
next
(
)
.
map
(
|
info
|
flow_ref
:
:
deref_mut
(
&
mut
info
.
flow
)
)
}
}
pub
type
AbsoluteDescendantOffsetIter
<
'
a
>
=
Zip
<
AbsoluteDescendantIter
<
'
a
>
IterMut
<
'
a
Au
>
>
;
#
[
derive
(
Copy
Clone
)
]
pub
struct
EarlyAbsolutePositionInfo
{
pub
relative_containing_block_size
:
LogicalSize
<
Au
>
pub
relative_containing_block_mode
:
WritingMode
}
impl
EarlyAbsolutePositionInfo
{
pub
fn
new
(
writing_mode
:
WritingMode
)
-
>
EarlyAbsolutePositionInfo
{
EarlyAbsolutePositionInfo
{
relative_containing_block_size
:
LogicalSize
:
:
zero
(
writing_mode
)
relative_containing_block_mode
:
writing_mode
}
}
}
#
[
derive
(
RustcEncodable
Copy
Clone
)
]
pub
struct
LateAbsolutePositionInfo
{
pub
stacking_relative_position_of_absolute_containing_block
:
Point2D
<
Au
>
}
impl
LateAbsolutePositionInfo
{
pub
fn
new
(
)
-
>
LateAbsolutePositionInfo
{
LateAbsolutePositionInfo
{
stacking_relative_position_of_absolute_containing_block
:
Point2D
:
:
zero
(
)
}
}
}
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
FragmentationContext
{
pub
available_block_size
:
Au
pub
this_fragment_is_empty
:
bool
}
pub
struct
BaseFlow
{
pub
restyle_damage
:
RestyleDamage
pub
children
:
FlowList
pub
intrinsic_inline_sizes
:
IntrinsicISizes
pub
position
:
LogicalRect
<
Au
>
pub
overflow
:
Rect
<
Au
>
pub
parallel
:
FlowParallelInfo
pub
floats
:
Floats
pub
collapsible_margins
:
CollapsibleMargins
pub
stacking_relative_position
:
Point2D
<
Au
>
pub
abs_descendants
:
AbsoluteDescendants
pub
block_container_inline_size
:
Au
pub
block_container_writing_mode
:
WritingMode
pub
block_container_explicit_block_size
:
Option
<
Au
>
pub
absolute_cb
:
ContainingBlockLink
pub
early_absolute_position_info
:
EarlyAbsolutePositionInfo
pub
late_absolute_position_info
:
LateAbsolutePositionInfo
pub
clip
:
ClippingRegion
pub
stacking_relative_position_of_display_port
:
Rect
<
Au
>
pub
display_list_building_result
:
Option
<
Box
<
DisplayList
>
>
pub
writing_mode
:
WritingMode
pub
thread_id
:
u8
pub
flags
:
FlowFlags
}
impl
fmt
:
:
Debug
for
BaseFlow
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
child_count
=
self
.
parallel
.
children_count
.
load
(
Ordering
:
:
SeqCst
)
;
let
child_count_string
=
if
child_count
>
0
{
format
!
(
"
children
=
{
}
"
child_count
)
}
else
{
"
"
.
to_owned
(
)
}
;
let
absolute_descendants_string
=
if
self
.
abs_descendants
.
len
(
)
>
0
{
format
!
(
"
abs
-
descendents
=
{
}
"
self
.
abs_descendants
.
len
(
)
)
}
else
{
"
"
.
to_owned
(
)
}
;
let
damage_string
=
if
self
.
restyle_damage
!
=
RestyleDamage
:
:
empty
(
)
{
format
!
(
"
damage
=
{
:
?
}
"
self
.
restyle_damage
)
}
else
{
"
"
.
to_owned
(
)
}
;
write
!
(
f
"
pos
=
{
:
?
}
overflow
=
{
:
?
}
{
}
{
}
{
}
"
self
.
position
self
.
overflow
child_count_string
absolute_descendants_string
damage_string
)
}
}
impl
Encodable
for
BaseFlow
{
fn
encode
<
S
:
Encoder
>
(
&
self
e
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
e
.
emit_struct
(
"
base
"
0
|
e
|
{
try
!
(
e
.
emit_struct_field
(
"
id
"
0
|
e
|
self
.
debug_id
(
)
.
encode
(
e
)
)
)
;
try
!
(
e
.
emit_struct_field
(
"
stacking_relative_position
"
1
|
e
|
self
.
stacking_relative_position
.
encode
(
e
)
)
)
;
try
!
(
e
.
emit_struct_field
(
"
intrinsic_inline_sizes
"
2
|
e
|
self
.
intrinsic_inline_sizes
.
encode
(
e
)
)
)
;
try
!
(
e
.
emit_struct_field
(
"
position
"
3
|
e
|
self
.
position
.
encode
(
e
)
)
)
;
e
.
emit_struct_field
(
"
children
"
4
|
e
|
{
e
.
emit_seq
(
self
.
children
.
len
(
)
|
e
|
{
for
(
i
c
)
in
self
.
children
.
iter
(
)
.
enumerate
(
)
{
try
!
(
e
.
emit_seq_elt
(
i
|
e
|
{
try
!
(
e
.
emit_struct
(
"
flow
"
0
|
e
|
{
try
!
(
e
.
emit_struct_field
(
"
class
"
0
|
e
|
c
.
class
(
)
.
encode
(
e
)
)
)
;
e
.
emit_struct_field
(
"
data
"
1
|
e
|
{
match
c
.
class
(
)
{
FlowClass
:
:
Block
=
>
c
.
as_block
(
)
.
encode
(
e
)
FlowClass
:
:
Inline
=
>
c
.
as_inline
(
)
.
encode
(
e
)
FlowClass
:
:
Table
=
>
c
.
as_table
(
)
.
encode
(
e
)
FlowClass
:
:
TableWrapper
=
>
c
.
as_table_wrapper
(
)
.
encode
(
e
)
FlowClass
:
:
TableRowGroup
=
>
c
.
as_table_rowgroup
(
)
.
encode
(
e
)
FlowClass
:
:
TableRow
=
>
c
.
as_table_row
(
)
.
encode
(
e
)
FlowClass
:
:
TableCell
=
>
c
.
as_table_cell
(
)
.
encode
(
e
)
_
=
>
{
Ok
(
(
)
)
}
/
/
TODO
:
Support
captions
}
}
)
}
)
)
;
Ok
(
(
)
)
}
)
)
;
}
Ok
(
(
)
)
}
)
}
)
}
)
}
}
#
[
derive
(
Clone
PartialEq
)
]
pub
enum
ForceNonfloatedFlag
{
FloatIfNecessary
ForceNonfloated
}
impl
BaseFlow
{
#
[
inline
]
pub
fn
new
(
style
:
Option
<
&
ComputedValues
>
writing_mode
:
WritingMode
force_nonfloated
:
ForceNonfloatedFlag
)
-
>
BaseFlow
{
let
mut
flags
=
FlowFlags
:
:
empty
(
)
;
match
style
{
Some
(
style
)
=
>
{
match
style
.
get_box
(
)
.
position
{
position
:
:
T
:
:
absolute
|
position
:
:
T
:
:
fixed
=
>
{
flags
.
insert
(
IS_ABSOLUTELY_POSITIONED
)
;
let
logical_position
=
style
.
logical_position
(
)
;
if
logical_position
.
inline_start
=
=
LengthOrPercentageOrAuto
:
:
Auto
&
&
logical_position
.
inline_end
=
=
LengthOrPercentageOrAuto
:
:
Auto
{
flags
.
insert
(
INLINE_POSITION_IS_STATIC
)
;
}
if
logical_position
.
block_start
=
=
LengthOrPercentageOrAuto
:
:
Auto
&
&
logical_position
.
block_end
=
=
LengthOrPercentageOrAuto
:
:
Auto
{
flags
.
insert
(
BLOCK_POSITION_IS_STATIC
)
;
}
}
_
=
>
flags
.
insert
(
BLOCK_POSITION_IS_STATIC
|
INLINE_POSITION_IS_STATIC
)
}
if
force_nonfloated
=
=
ForceNonfloatedFlag
:
:
FloatIfNecessary
{
match
style
.
get_box
(
)
.
float
{
float
:
:
T
:
:
none
=
>
{
}
float
:
:
T
:
:
left
=
>
flags
.
insert
(
FLOATS_LEFT
)
float
:
:
T
:
:
right
=
>
flags
.
insert
(
FLOATS_RIGHT
)
}
}
match
style
.
get_box
(
)
.
clear
{
clear
:
:
T
:
:
none
=
>
{
}
clear
:
:
T
:
:
left
=
>
flags
.
insert
(
CLEARS_LEFT
)
clear
:
:
T
:
:
right
=
>
flags
.
insert
(
CLEARS_RIGHT
)
clear
:
:
T
:
:
both
=
>
{
flags
.
insert
(
CLEARS_LEFT
)
;
flags
.
insert
(
CLEARS_RIGHT
)
;
}
}
if
!
style
.
get_counters
(
)
.
counter_reset
.
0
.
is_empty
(
)
|
|
!
style
.
get_counters
(
)
.
counter_increment
.
0
.
is_empty
(
)
{
flags
.
insert
(
AFFECTS_COUNTERS
)
}
}
None
=
>
flags
.
insert
(
BLOCK_POSITION_IS_STATIC
|
INLINE_POSITION_IS_STATIC
)
}
let
mut
damage
=
RestyleDamage
:
:
rebuild_and_reflow
(
)
;
damage
.
remove
(
RECONSTRUCT_FLOW
)
;
BaseFlow
{
restyle_damage
:
damage
children
:
FlowList
:
:
new
(
)
intrinsic_inline_sizes
:
IntrinsicISizes
:
:
new
(
)
position
:
LogicalRect
:
:
zero
(
writing_mode
)
overflow
:
Rect
:
:
zero
(
)
parallel
:
FlowParallelInfo
:
:
new
(
)
floats
:
Floats
:
:
new
(
writing_mode
)
collapsible_margins
:
CollapsibleMargins
:
:
new
(
)
stacking_relative_position
:
Point2D
:
:
zero
(
)
abs_descendants
:
AbsoluteDescendants
:
:
new
(
)
block_container_inline_size
:
Au
(
0
)
block_container_writing_mode
:
writing_mode
block_container_explicit_block_size
:
None
absolute_cb
:
ContainingBlockLink
:
:
new
(
)
display_list_building_result
:
None
early_absolute_position_info
:
EarlyAbsolutePositionInfo
:
:
new
(
writing_mode
)
late_absolute_position_info
:
LateAbsolutePositionInfo
:
:
new
(
)
clip
:
ClippingRegion
:
:
max
(
)
stacking_relative_position_of_display_port
:
Rect
:
:
zero
(
)
flags
:
flags
writing_mode
:
writing_mode
thread_id
:
0
}
}
pub
fn
clone_with_children
(
&
self
children
:
FlowList
)
-
>
BaseFlow
{
BaseFlow
{
children
:
children
restyle_damage
:
self
.
restyle_damage
|
REPAINT
|
REFLOW_OUT_OF_FLOW
|
REFLOW
parallel
:
FlowParallelInfo
:
:
new
(
)
display_list_building_result
:
None
floats
:
self
.
floats
.
clone
(
)
abs_descendants
:
self
.
abs_descendants
.
clone
(
)
absolute_cb
:
self
.
absolute_cb
.
clone
(
)
clip
:
self
.
clip
.
clone
(
)
.
.
*
self
}
}
pub
fn
child_iter
(
&
mut
self
)
-
>
MutFlowListIterator
{
self
.
children
.
iter_mut
(
)
}
pub
fn
debug_id
(
&
self
)
-
>
usize
{
let
p
=
self
as
*
const
_
;
p
as
usize
}
pub
fn
validate_display_list_geometry
(
&
self
)
{
let
container_size
=
Size2D
:
:
zero
(
)
;
let
position_with_overflow
=
self
.
position
.
to_physical
(
self
.
writing_mode
container_size
)
.
union
(
&
self
.
overflow
)
;
let
bounds
=
Rect
:
:
new
(
self
.
stacking_relative_position
position_with_overflow
.
size
)
;
let
all_items
=
match
self
.
display_list_building_result
{
Some
(
ref
display_list
)
=
>
display_list
.
flatten
(
)
None
=
>
Vec
:
:
new
(
)
}
;
for
item
in
&
all_items
{
if
let
Some
(
base_item
)
=
item
.
base
(
)
{
let
paint_bounds
=
base_item
.
clip
.
clone
(
)
.
intersect_rect
(
&
base_item
.
bounds
)
;
if
!
paint_bounds
.
might_be_nonempty
(
)
{
continue
;
}
if
bounds
.
union
(
&
paint_bounds
.
bounding_rect
(
)
)
!
=
bounds
{
error
!
(
"
DisplayList
item
{
:
?
}
outside
of
Flow
overflow
(
{
:
?
}
)
"
item
paint_bounds
)
;
}
}
}
}
}
impl
<
'
a
>
ImmutableFlowUtils
for
&
'
a
Flow
{
fn
is_block_like
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Block
|
FlowClass
:
:
ListItem
|
FlowClass
:
:
Table
|
FlowClass
:
:
TableRowGroup
|
FlowClass
:
:
TableRow
|
FlowClass
:
:
TableCaption
|
FlowClass
:
:
TableCell
|
FlowClass
:
:
TableWrapper
=
>
true
_
=
>
false
}
}
fn
is_proper_table_child
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableRow
|
FlowClass
:
:
TableRowGroup
|
FlowClass
:
:
TableColGroup
|
FlowClass
:
:
TableCaption
=
>
true
_
=
>
false
}
}
fn
is_table_row
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableRow
=
>
true
_
=
>
false
}
}
fn
is_table_cell
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableCell
=
>
true
_
=
>
false
}
}
fn
is_table_colgroup
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableColGroup
=
>
true
_
=
>
false
}
}
fn
is_table
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Table
=
>
true
_
=
>
false
}
}
fn
is_table_caption
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableCaption
=
>
true
_
=
>
false
}
}
fn
is_table_rowgroup
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableRowGroup
=
>
true
_
=
>
false
}
}
fn
is_table_kind
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
TableWrapper
|
FlowClass
:
:
Table
|
FlowClass
:
:
TableColGroup
|
FlowClass
:
:
TableRowGroup
|
FlowClass
:
:
TableRow
|
FlowClass
:
:
TableCaption
|
FlowClass
:
:
TableCell
=
>
true
_
=
>
false
}
}
fn
need_anonymous_flow
(
self
child
:
&
Flow
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Table
=
>
!
child
.
is_proper_table_child
(
)
FlowClass
:
:
TableRowGroup
=
>
!
child
.
is_table_row
(
)
FlowClass
:
:
TableRow
=
>
!
child
.
is_table_cell
(
)
FlowClass
:
:
Flex
=
>
child
.
is_inline_flow
(
)
_
=
>
false
}
}
fn
generate_missing_child_flow
<
'
ln
N
:
ThreadSafeLayoutNode
<
'
ln
>
>
(
self
node
:
&
N
)
-
>
FlowRef
{
let
mut
style
=
node
.
style
(
)
.
clone
(
)
;
match
self
.
class
(
)
{
FlowClass
:
:
Table
|
FlowClass
:
:
TableRowGroup
=
>
{
properties
:
:
modify_style_for_anonymous_table_object
(
&
mut
style
display
:
:
T
:
:
table_row
)
;
let
fragment
=
Fragment
:
:
from_opaque_node_and_style
(
node
.
opaque
(
)
PseudoElementType
:
:
Normal
style
node
.
restyle_damage
(
)
SpecificFragmentInfo
:
:
TableRow
)
;
Arc
:
:
new
(
TableRowFlow
:
:
from_fragment
(
fragment
)
)
}
FlowClass
:
:
TableRow
=
>
{
properties
:
:
modify_style_for_anonymous_table_object
(
&
mut
style
display
:
:
T
:
:
table_cell
)
;
let
fragment
=
Fragment
:
:
from_opaque_node_and_style
(
node
.
opaque
(
)
PseudoElementType
:
:
Normal
style
node
.
restyle_damage
(
)
SpecificFragmentInfo
:
:
TableCell
)
;
let
hide
=
node
.
style
(
)
.
get_inheritedtable
(
)
.
empty_cells
=
=
empty_cells
:
:
T
:
:
hide
;
Arc
:
:
new
(
TableCellFlow
:
:
from_node_fragment_and_visibility_flag
(
node
fragment
!
hide
)
)
}
FlowClass
:
:
Flex
=
>
{
let
fragment
=
Fragment
:
:
from_opaque_node_and_style
(
node
.
opaque
(
)
PseudoElementType
:
:
Normal
style
node
.
restyle_damage
(
)
SpecificFragmentInfo
:
:
Generic
)
;
Arc
:
:
new
(
BlockFlow
:
:
from_fragment
(
fragment
None
)
)
}
_
=
>
{
panic
!
(
"
no
need
to
generate
a
missing
child
"
)
}
}
}
fn
contains_roots_of_absolute_flow_tree
(
&
self
)
-
>
bool
{
self
.
contains_relatively_positioned_fragments
(
)
|
|
self
.
is_root
(
)
}
fn
is_leaf
(
self
)
-
>
bool
{
base
(
self
)
.
children
.
is_empty
(
)
}
fn
child_count
(
self
)
-
>
usize
{
base
(
self
)
.
children
.
len
(
)
}
fn
is_block_container
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Block
|
FlowClass
:
:
TableCaption
|
FlowClass
:
:
TableCell
=
>
{
self
.
child_count
(
)
!
=
0
}
_
=
>
false
}
}
fn
is_block_flow
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Block
=
>
true
_
=
>
false
}
}
fn
is_inline_flow
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
FlowClass
:
:
Inline
=
>
true
_
=
>
false
}
}
fn
print
(
self
title
:
String
)
{
let
mut
print_tree
=
PrintTree
:
:
new
(
title
)
;
self
.
print_with_tree
(
&
mut
print_tree
)
;
}
fn
print_with_tree
(
self
print_tree
:
&
mut
PrintTree
)
{
print_tree
.
new_level
(
format
!
(
"
{
:
?
}
"
self
)
)
;
self
.
print_extra_flow_children
(
print_tree
)
;
for
kid
in
imm_child_iter
(
self
)
{
kid
.
print_with_tree
(
print_tree
)
;
}
print_tree
.
end_level
(
)
;
}
}
impl
<
'
a
>
MutableFlowUtils
for
&
'
a
mut
Flow
{
fn
traverse_preorder
<
T
:
PreorderFlowTraversal
>
(
self
traversal
:
&
T
)
{
if
traversal
.
should_process
(
self
)
{
traversal
.
process
(
self
)
;
}
for
kid
in
child_iter
(
self
)
{
kid
.
traverse_preorder
(
traversal
)
;
}
}
fn
traverse_postorder
<
T
:
PostorderFlowTraversal
>
(
self
traversal
:
&
T
)
{
for
kid
in
child_iter
(
self
)
{
kid
.
traverse_postorder
(
traversal
)
;
}
if
traversal
.
should_process
(
self
)
{
traversal
.
process
(
self
)
}
}
fn
repair_style_and_bubble_inline_sizes
(
self
style
:
&
Arc
<
ComputedValues
>
)
{
self
.
repair_style
(
style
)
;
self
.
bubble_inline_sizes
(
)
;
}
fn
traverse_preorder_absolute_flows
<
T
>
(
&
mut
self
traversal
:
&
mut
T
)
where
T
:
PreorderFlowTraversal
{
traversal
.
process
(
*
self
)
;
let
descendant_offset_iter
=
mut_base
(
*
self
)
.
abs_descendants
.
iter
(
)
;
for
ref
mut
descendant_link
in
descendant_offset_iter
{
descendant_link
.
traverse_preorder_absolute_flows
(
traversal
)
}
}
fn
traverse_postorder_absolute_flows
<
T
>
(
&
mut
self
traversal
:
&
mut
T
)
where
T
:
PostorderFlowTraversal
{
for
mut
descendant_link
in
mut_base
(
*
self
)
.
abs_descendants
.
iter
(
)
{
descendant_link
.
traverse_postorder_absolute_flows
(
traversal
)
;
}
traversal
.
process
(
*
self
)
}
}
impl
MutableOwnedFlowUtils
for
FlowRef
{
fn
set_absolute_descendants
(
&
mut
self
abs_descendants
:
AbsoluteDescendants
)
{
let
this
=
self
.
clone
(
)
;
let
base
=
mut_base
(
flow_ref
:
:
deref_mut
(
self
)
)
;
base
.
abs_descendants
=
abs_descendants
;
for
descendant_link
in
base
.
abs_descendants
.
descendant_links
.
iter_mut
(
)
{
debug_assert
!
(
!
descendant_link
.
has_reached_containing_block
)
;
let
descendant_base
=
mut_base
(
flow_ref
:
:
deref_mut
(
&
mut
descendant_link
.
flow
)
)
;
descendant_base
.
absolute_cb
.
set
(
this
.
clone
(
)
)
;
}
}
fn
take_applicable_absolute_descendants
(
&
mut
self
absolute_descendants
:
&
mut
AbsoluteDescendants
)
{
let
mut
applicable_absolute_descendants
=
AbsoluteDescendants
:
:
new
(
)
;
for
absolute_descendant
in
absolute_descendants
.
descendant_links
.
iter
(
)
{
if
absolute_descendant
.
has_reached_containing_block
{
applicable_absolute_descendants
.
push
(
absolute_descendant
.
flow
.
clone
(
)
)
;
}
}
absolute_descendants
.
descendant_links
.
retain
(
|
descendant
|
{
!
descendant
.
has_reached_containing_block
}
)
;
let
this
=
self
.
clone
(
)
;
let
base
=
mut_base
(
flow_ref
:
:
deref_mut
(
self
)
)
;
base
.
abs_descendants
=
applicable_absolute_descendants
;
for
descendant_link
in
base
.
abs_descendants
.
iter
(
)
{
let
descendant_base
=
mut_base
(
descendant_link
)
;
descendant_base
.
absolute_cb
.
set
(
this
.
clone
(
)
)
;
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
ContainingBlockLink
{
link
:
Option
<
WeakFlowRef
>
}
impl
ContainingBlockLink
{
fn
new
(
)
-
>
ContainingBlockLink
{
ContainingBlockLink
{
link
:
None
}
}
fn
set
(
&
mut
self
link
:
FlowRef
)
{
self
.
link
=
Some
(
Arc
:
:
downgrade
(
&
link
)
)
}
#
[
inline
]
pub
fn
generated_containing_block_size
(
&
self
for_flow
:
OpaqueFlow
)
-
>
LogicalSize
<
Au
>
{
match
self
.
link
{
None
=
>
{
panic
!
(
"
Link
to
containing
block
not
established
;
perhaps
you
forgot
to
call
\
set_absolute_descendants
?
"
)
}
Some
(
ref
link
)
=
>
{
let
flow
=
link
.
upgrade
(
)
.
unwrap
(
)
;
flow
.
generated_containing_block_size
(
for_flow
)
}
}
}
#
[
inline
]
pub
fn
explicit_block_containing_size
(
&
self
layout_context
:
&
LayoutContext
)
-
>
Option
<
Au
>
{
match
self
.
link
{
None
=
>
{
panic
!
(
"
Link
to
containing
block
not
established
;
perhaps
you
forgot
to
call
\
set_absolute_descendants
?
"
)
}
Some
(
ref
link
)
=
>
{
let
flow
=
link
.
upgrade
(
)
.
unwrap
(
)
;
if
flow
.
is_block_like
(
)
{
flow
.
as_block
(
)
.
explicit_block_containing_size
(
layout_context
)
}
else
if
flow
.
is_inline_flow
(
)
{
Some
(
flow
.
as_inline
(
)
.
minimum_block_size_above_baseline
)
}
else
{
None
}
}
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
pub
struct
OpaqueFlow
(
pub
usize
)
;
impl
OpaqueFlow
{
#
[
allow
(
unsafe_code
)
]
pub
fn
from_flow
(
flow
:
&
Flow
)
-
>
OpaqueFlow
{
unsafe
{
let
object
=
mem
:
:
transmute
:
:
<
&
Flow
raw
:
:
TraitObject
>
(
flow
)
;
OpaqueFlow
(
object
.
data
as
usize
)
}
}
}
