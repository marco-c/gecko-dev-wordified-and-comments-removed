use
css
:
:
node_style
:
:
StyledNode
;
use
block
:
:
BlockFlow
;
use
context
:
:
LayoutContext
;
use
floats
:
:
Floats
;
use
flow_list
:
:
{
FlowList
FlowListIterator
MutFlowListIterator
}
;
use
flow_ref
:
:
FlowRef
;
use
fragment
:
:
{
Fragment
TableRowFragment
TableCellFragment
}
;
use
incremental
:
:
RestyleDamage
;
use
inline
:
:
InlineFlow
;
use
model
:
:
{
CollapsibleMargins
IntrinsicISizes
MarginCollapseInfo
}
;
use
parallel
:
:
FlowParallelInfo
;
use
table
:
:
{
ColumnInlineSize
TableFlow
}
;
use
table_caption
:
:
TableCaptionFlow
;
use
table_cell
:
:
TableCellFlow
;
use
table_colgroup
:
:
TableColGroupFlow
;
use
table_row
:
:
TableRowFlow
;
use
table_rowgroup
:
:
TableRowGroupFlow
;
use
table_wrapper
:
:
TableWrapperFlow
;
use
wrapper
:
:
ThreadSafeLayoutNode
;
use
collections
:
:
dlist
:
:
DList
;
use
geom
:
:
{
Point2D
Rect
Size2D
}
;
use
gfx
:
:
display_list
:
:
DisplayList
;
use
gfx
:
:
render_task
:
:
RenderLayer
;
use
serialize
:
:
{
Encoder
Encodable
}
;
use
servo_msg
:
:
compositor_msg
:
:
LayerId
;
use
servo_util
:
:
geometry
:
:
Au
;
use
servo_util
:
:
logical_geometry
:
:
WritingMode
;
use
servo_util
:
:
logical_geometry
:
:
{
LogicalRect
LogicalSize
}
;
use
std
:
:
mem
;
use
std
:
:
num
:
:
Zero
;
use
std
:
:
fmt
;
use
std
:
:
iter
:
:
Zip
;
use
std
:
:
raw
;
use
std
:
:
sync
:
:
atomics
:
:
{
AtomicUint
SeqCst
}
;
use
std
:
:
slice
:
:
MutItems
;
use
style
:
:
computed_values
:
:
{
clear
float
position
text_align
}
;
pub
trait
Flow
:
fmt
:
:
Show
+
ToString
+
Sync
{
fn
class
(
&
self
)
-
>
FlowClass
;
fn
as_immutable_block
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
BlockFlow
{
fail
!
(
"
called
as_immutable_block
(
)
on
a
non
-
block
flow
"
)
}
fn
as_block
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
BlockFlow
{
debug
!
(
"
called
as_block
(
)
on
a
flow
of
type
{
}
"
self
.
class
(
)
)
;
fail
!
(
"
called
as_block
(
)
on
a
non
-
block
flow
"
)
}
fn
as_immutable_inline
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
InlineFlow
{
fail
!
(
"
called
as_immutable_inline
(
)
on
a
non
-
inline
flow
"
)
}
fn
as_inline
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
InlineFlow
{
fail
!
(
"
called
as_inline
(
)
on
a
non
-
inline
flow
"
)
}
fn
as_table_wrapper
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableWrapperFlow
{
fail
!
(
"
called
as_table_wrapper
(
)
on
a
non
-
tablewrapper
flow
"
)
}
fn
as_immutable_table_wrapper
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
TableWrapperFlow
{
fail
!
(
"
called
as_immutable_table_wrapper
(
)
on
a
non
-
tablewrapper
flow
"
)
}
fn
as_table
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableFlow
{
fail
!
(
"
called
as_table
(
)
on
a
non
-
table
flow
"
)
}
fn
as_immutable_table
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
TableFlow
{
fail
!
(
"
called
as_table
(
)
on
a
non
-
table
flow
"
)
}
fn
as_table_colgroup
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableColGroupFlow
{
fail
!
(
"
called
as_table_colgroup
(
)
on
a
non
-
tablecolgroup
flow
"
)
}
fn
as_table_rowgroup
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableRowGroupFlow
{
fail
!
(
"
called
as_table_rowgroup
(
)
on
a
non
-
tablerowgroup
flow
"
)
}
fn
as_immutable_table_rowgroup
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
TableRowGroupFlow
{
fail
!
(
"
called
as_table_rowgroup
(
)
on
a
non
-
tablerowgroup
flow
"
)
}
fn
as_table_row
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableRowFlow
{
fail
!
(
"
called
as_table_row
(
)
on
a
non
-
tablerow
flow
"
)
}
fn
as_immutable_table_row
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
TableRowFlow
{
fail
!
(
"
called
as_table_row
(
)
on
a
non
-
tablerow
flow
"
)
}
fn
as_table_caption
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableCaptionFlow
{
fail
!
(
"
called
as_table_caption
(
)
on
a
non
-
tablecaption
flow
"
)
}
fn
as_table_cell
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
TableCellFlow
{
fail
!
(
"
called
as_table_cell
(
)
on
a
non
-
tablecell
flow
"
)
}
fn
as_immutable_table_cell
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
TableCellFlow
{
fail
!
(
"
called
as_table_cell
(
)
on
a
non
-
tablecell
flow
"
)
}
fn
column_inline_sizes
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Vec
<
ColumnInlineSize
>
{
fail
!
(
"
called
column_inline_sizes
(
)
on
non
-
table
flow
"
)
}
fn
bubble_inline_sizes
(
&
mut
self
)
{
fail
!
(
"
bubble_inline_sizes
not
yet
implemented
"
)
}
fn
assign_inline_sizes
(
&
mut
self
_ctx
:
&
LayoutContext
)
{
fail
!
(
"
assign_inline_sizes
not
yet
implemented
"
)
}
fn
assign_block_size
<
'
a
>
(
&
mut
self
_ctx
:
&
'
a
LayoutContext
<
'
a
>
)
{
fail
!
(
"
assign_block_size
not
yet
implemented
"
)
}
fn
assign_block_size_for_inorder_child_if_necessary
<
'
a
>
(
&
mut
self
layout_context
:
&
'
a
LayoutContext
<
'
a
>
)
-
>
bool
{
let
impacted
=
base
(
&
*
self
)
.
flags
.
impacted_by_floats
(
)
;
if
impacted
{
self
.
assign_block_size
(
layout_context
)
;
}
impacted
}
fn
compute_absolute_position
(
&
mut
self
)
{
}
fn
build_display_list
(
&
mut
self
layout_context
:
&
LayoutContext
)
;
fn
float_clearance
(
&
self
)
-
>
clear
:
:
T
{
clear
:
:
none
}
fn
float_kind
(
&
self
)
-
>
float
:
:
T
{
float
:
:
none
}
fn
compute_collapsible_block_start_margin
(
&
mut
self
_layout_context
:
&
mut
LayoutContext
_margin_collapse_info
:
&
mut
MarginCollapseInfo
)
{
}
fn
mark_as_root
(
&
mut
self
)
{
}
fn
is_store_overflow_delayed
(
&
mut
self
)
-
>
bool
{
false
}
fn
is_root
(
&
self
)
-
>
bool
{
false
}
fn
is_float
(
&
self
)
-
>
bool
{
false
}
fn
positioning
(
&
self
)
-
>
position
:
:
T
{
position
:
:
static_
}
fn
is_fixed
(
&
self
)
-
>
bool
{
self
.
positioning
(
)
=
=
position
:
:
fixed
}
fn
is_positioned
(
&
self
)
-
>
bool
{
self
.
is_relatively_positioned
(
)
|
|
self
.
is_absolutely_positioned
(
)
}
fn
is_relatively_positioned
(
&
self
)
-
>
bool
{
self
.
positioning
(
)
=
=
position
:
:
relative
}
fn
is_absolutely_positioned
(
&
self
)
-
>
bool
{
self
.
positioning
(
)
=
=
position
:
:
absolute
|
|
self
.
is_fixed
(
)
}
fn
is_root_of_absolute_flow_tree
(
&
self
)
-
>
bool
{
false
}
fn
is_absolute_containing_block
(
&
self
)
-
>
bool
{
false
}
fn
update_late_computed_inline_position_if_necessary
(
&
mut
self
inline_position
:
Au
)
;
fn
update_late_computed_block_position_if_necessary
(
&
mut
self
block_position
:
Au
)
;
fn
generated_containing_block_rect
(
&
self
)
-
>
LogicalRect
<
Au
>
{
fail
!
(
"
generated_containing_block_position
not
yet
implemented
for
this
flow
"
)
}
fn
layer_id
(
&
self
fragment_id
:
uint
)
-
>
LayerId
{
unsafe
{
let
pointer
:
uint
=
mem
:
:
transmute
(
self
)
;
LayerId
(
pointer
fragment_id
)
}
}
}
impl
<
'
a
E
S
:
Encoder
<
E
>
>
Encodable
<
S
E
>
for
&
'
a
Flow
+
'
a
{
fn
encode
(
&
self
e
:
&
mut
S
)
-
>
Result
<
(
)
E
>
{
e
.
emit_struct
(
"
flow
"
0
|
e
|
{
try
!
(
e
.
emit_struct_field
(
"
class
"
0
|
e
|
self
.
class
(
)
.
encode
(
e
)
)
)
e
.
emit_struct_field
(
"
data
"
1
|
e
|
{
match
self
.
class
(
)
{
BlockFlowClass
=
>
self
.
as_immutable_block
(
)
.
encode
(
e
)
InlineFlowClass
=
>
self
.
as_immutable_inline
(
)
.
encode
(
e
)
TableFlowClass
=
>
self
.
as_immutable_table
(
)
.
encode
(
e
)
TableWrapperFlowClass
=
>
self
.
as_immutable_table_wrapper
(
)
.
encode
(
e
)
TableRowGroupFlowClass
=
>
self
.
as_immutable_table_rowgroup
(
)
.
encode
(
e
)
TableRowFlowClass
=
>
self
.
as_immutable_table_row
(
)
.
encode
(
e
)
TableCellFlowClass
=
>
self
.
as_immutable_table_cell
(
)
.
encode
(
e
)
_
=
>
{
Ok
(
(
)
)
}
}
}
)
}
)
}
}
#
[
inline
(
always
)
]
pub
fn
base
<
'
a
>
(
this
:
&
'
a
Flow
)
-
>
&
'
a
BaseFlow
{
unsafe
{
let
obj
=
mem
:
:
transmute
:
:
<
&
'
a
Flow
raw
:
:
TraitObject
>
(
this
)
;
mem
:
:
transmute
:
:
<
*
mut
(
)
&
'
a
BaseFlow
>
(
obj
.
data
)
}
}
pub
fn
imm_child_iter
<
'
a
>
(
flow
:
&
'
a
Flow
)
-
>
FlowListIterator
<
'
a
>
{
base
(
flow
)
.
children
.
iter
(
)
}
#
[
inline
(
always
)
]
pub
fn
mut_base
<
'
a
>
(
this
:
&
'
a
mut
Flow
)
-
>
&
'
a
mut
BaseFlow
{
unsafe
{
let
obj
=
mem
:
:
transmute
:
:
<
&
'
a
mut
Flow
raw
:
:
TraitObject
>
(
this
)
;
mem
:
:
transmute
:
:
<
*
mut
(
)
&
'
a
mut
BaseFlow
>
(
obj
.
data
)
}
}
pub
fn
child_iter
<
'
a
>
(
flow
:
&
'
a
mut
Flow
)
-
>
MutFlowListIterator
<
'
a
>
{
mut_base
(
flow
)
.
children
.
iter_mut
(
)
}
pub
trait
ImmutableFlowUtils
{
fn
is_block_like
(
self
)
-
>
bool
;
fn
is_table
(
self
)
-
>
bool
;
fn
is_table_caption
(
self
)
-
>
bool
;
fn
is_proper_table_child
(
self
)
-
>
bool
;
fn
is_table_row
(
self
)
-
>
bool
;
fn
is_table_cell
(
self
)
-
>
bool
;
fn
is_table_colgroup
(
self
)
-
>
bool
;
fn
is_table_rowgroup
(
self
)
-
>
bool
;
fn
is_table_kind
(
self
)
-
>
bool
;
fn
need_anonymous_flow
(
self
child
:
&
Flow
)
-
>
bool
;
fn
generate_missing_child_flow
(
self
node
:
&
ThreadSafeLayoutNode
)
-
>
FlowRef
;
fn
is_leaf
(
self
)
-
>
bool
;
fn
child_count
(
self
)
-
>
uint
;
fn
is_block_container
(
self
)
-
>
bool
;
fn
is_block_flow
(
self
)
-
>
bool
;
fn
is_inline_flow
(
self
)
-
>
bool
;
fn
dump
(
self
)
;
fn
dump_with_level
(
self
level
:
uint
)
;
}
pub
trait
MutableFlowUtils
{
fn
traverse_preorder
<
T
:
PreorderFlowTraversal
>
(
self
traversal
:
&
T
)
;
fn
traverse_postorder
<
T
:
PostorderFlowTraversal
>
(
self
traversal
:
&
T
)
;
fn
store_overflow
(
self
_
:
&
LayoutContext
)
;
fn
collect_static_block_offsets_from_children
(
self
)
;
fn
propagate_restyle_damage
(
self
)
;
}
pub
trait
MutableOwnedFlowUtils
{
fn
set_absolute_descendants
(
&
mut
self
abs_descendants
:
AbsDescendants
)
;
}
#
[
deriving
(
Encodable
PartialEq
Show
)
]
pub
enum
FlowClass
{
BlockFlowClass
InlineFlowClass
TableWrapperFlowClass
TableFlowClass
TableColGroupFlowClass
TableRowGroupFlowClass
TableRowFlowClass
TableCaptionFlowClass
TableCellFlowClass
}
pub
trait
PreorderFlowTraversal
{
fn
process
(
&
self
flow
:
&
mut
Flow
)
;
fn
should_process
(
&
self
_flow
:
&
mut
Flow
)
-
>
bool
{
true
}
}
pub
trait
PostorderFlowTraversal
{
fn
process
(
&
self
flow
:
&
mut
Flow
)
;
fn
should_process
(
&
self
_flow
:
&
mut
Flow
)
-
>
bool
{
true
}
}
#
[
deriving
(
Clone
Encodable
)
]
pub
struct
FlowFlags
(
pub
u8
)
;
static
HAS_FLOATED_DESCENDANTS_BITMASK
:
u8
=
0b0000_0011
;
bitfield
!
(
FlowFlags
has_left_floated_descendants
set_has_left_floated_descendants
0b0000_0001
)
bitfield
!
(
FlowFlags
has_right_floated_descendants
set_has_right_floated_descendants
0b0000_0010
)
bitfield
!
(
FlowFlags
impacted_by_left_floats
set_impacted_by_left_floats
0b0000_0100
)
bitfield
!
(
FlowFlags
impacted_by_right_floats
set_impacted_by_right_floats
0b0000_1000
)
static
TEXT_ALIGN_BITMASK
:
u8
=
0b0011_0000
;
static
TEXT_ALIGN_SHIFT
:
u8
=
4
;
bitfield
!
(
FlowFlags
layers_needed_for_descendants
set_layers_needed_for_descendants
0b0100_0000
)
bitfield
!
(
FlowFlags
needs_layer
set_needs_layer
0b1000_0000
)
impl
FlowFlags
{
pub
fn
new
(
)
-
>
FlowFlags
{
FlowFlags
(
0
)
}
pub
fn
propagate_text_alignment_from_parent
(
&
mut
self
parent_flags
:
FlowFlags
)
{
self
.
set_text_align_override
(
parent_flags
)
;
}
#
[
inline
]
pub
fn
text_align
(
self
)
-
>
text_align
:
:
T
{
let
FlowFlags
(
ff
)
=
self
;
FromPrimitive
:
:
from_u8
(
(
ff
&
TEXT_ALIGN_BITMASK
)
>
>
TEXT_ALIGN_SHIFT
as
uint
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
set_text_align
(
&
mut
self
value
:
text_align
:
:
T
)
{
let
FlowFlags
(
ff
)
=
*
self
;
*
self
=
FlowFlags
(
(
ff
&
!
TEXT_ALIGN_BITMASK
)
|
(
(
value
as
u8
)
<
<
TEXT_ALIGN_SHIFT
as
uint
)
)
}
#
[
inline
]
pub
fn
set_text_align_override
(
&
mut
self
parent
:
FlowFlags
)
{
let
FlowFlags
(
ff
)
=
*
self
;
let
FlowFlags
(
pff
)
=
parent
;
*
self
=
FlowFlags
(
ff
|
(
pff
&
TEXT_ALIGN_BITMASK
)
)
}
#
[
inline
]
pub
fn
union_floated_descendants_flags
(
&
mut
self
other
:
FlowFlags
)
{
let
FlowFlags
(
my_flags
)
=
*
self
;
let
FlowFlags
(
other_flags
)
=
other
;
*
self
=
FlowFlags
(
my_flags
|
(
other_flags
&
HAS_FLOATED_DESCENDANTS_BITMASK
)
)
}
#
[
inline
]
pub
fn
impacted_by_floats
(
&
self
)
-
>
bool
{
self
.
impacted_by_left_floats
(
)
|
|
self
.
impacted_by_right_floats
(
)
}
}
#
[
deriving
(
Clone
)
]
pub
struct
Descendants
{
descendant_links
:
Vec
<
FlowRef
>
pub
static_block_offsets
:
Vec
<
Au
>
}
impl
Descendants
{
pub
fn
new
(
)
-
>
Descendants
{
Descendants
{
descendant_links
:
Vec
:
:
new
(
)
static_block_offsets
:
Vec
:
:
new
(
)
}
}
pub
fn
len
(
&
self
)
-
>
uint
{
self
.
descendant_links
.
len
(
)
}
pub
fn
push
(
&
mut
self
given_descendant
:
FlowRef
)
{
self
.
descendant_links
.
push
(
given_descendant
)
;
}
pub
fn
push_descendants
(
&
mut
self
given_descendants
:
Descendants
)
{
for
elem
in
given_descendants
.
descendant_links
.
into_iter
(
)
{
self
.
descendant_links
.
push
(
elem
)
;
}
}
pub
fn
iter
<
'
a
>
(
&
'
a
mut
self
)
-
>
DescendantIter
<
'
a
>
{
DescendantIter
{
iter
:
self
.
descendant_links
.
slice_from_mut
(
0
)
.
iter_mut
(
)
}
}
pub
fn
iter_with_offset
<
'
a
>
(
&
'
a
mut
self
)
-
>
DescendantOffsetIter
<
'
a
>
{
let
descendant_iter
=
DescendantIter
{
iter
:
self
.
descendant_links
.
slice_from_mut
(
0
)
.
iter_mut
(
)
}
;
descendant_iter
.
zip
(
self
.
static_block_offsets
.
slice_from_mut
(
0
)
.
iter_mut
(
)
)
}
}
pub
type
AbsDescendants
=
Descendants
;
pub
struct
DescendantIter
<
'
a
>
{
iter
:
MutItems
<
'
a
FlowRef
>
}
impl
<
'
a
>
Iterator
<
&
'
a
mut
Flow
+
'
a
>
for
DescendantIter
<
'
a
>
{
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
mut
Flow
+
'
a
>
{
match
self
.
iter
.
next
(
)
{
None
=
>
None
Some
(
ref
mut
flow
)
=
>
{
unsafe
{
let
result
:
&
'
a
mut
Flow
=
mem
:
:
transmute
(
flow
.
deref_mut
(
)
)
;
Some
(
result
)
}
}
}
}
}
pub
type
DescendantOffsetIter
<
'
a
>
=
Zip
<
DescendantIter
<
'
a
>
MutItems
<
'
a
Au
>
>
;
#
[
deriving
(
Encodable
)
]
pub
struct
AbsolutePositionInfo
{
pub
relative_containing_block_size
:
LogicalSize
<
Au
>
pub
absolute_containing_block_position
:
Point2D
<
Au
>
pub
layers_needed_for_positioned_flows
:
bool
}
impl
AbsolutePositionInfo
{
pub
fn
new
(
writing_mode
:
WritingMode
)
-
>
AbsolutePositionInfo
{
AbsolutePositionInfo
{
relative_containing_block_size
:
LogicalSize
:
:
zero
(
writing_mode
)
absolute_containing_block_position
:
Zero
:
:
zero
(
)
layers_needed_for_positioned_flows
:
false
}
}
}
pub
struct
BaseFlow
{
ref_count
:
AtomicUint
pub
restyle_damage
:
RestyleDamage
pub
children
:
FlowList
pub
intrinsic_inline_sizes
:
IntrinsicISizes
pub
position
:
LogicalRect
<
Au
>
pub
overflow
:
LogicalRect
<
Au
>
pub
parallel
:
FlowParallelInfo
pub
floats
:
Floats
pub
collapsible_margins
:
CollapsibleMargins
pub
abs_position
:
Point2D
<
Au
>
pub
abs_descendants
:
AbsDescendants
pub
block_container_inline_size
:
Au
pub
block_container_explicit_block_size
:
Option
<
Au
>
pub
absolute_static_i_offset
:
Au
pub
fixed_static_i_offset
:
Au
pub
absolute_cb
:
ContainingBlockLink
pub
absolute_position_info
:
AbsolutePositionInfo
pub
clip_rect
:
Rect
<
Au
>
pub
display_list
:
DisplayList
pub
layers
:
DList
<
RenderLayer
>
pub
flags
:
FlowFlags
pub
writing_mode
:
WritingMode
}
impl
fmt
:
:
Show
for
BaseFlow
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
CC
{
}
ADC
{
}
"
self
.
position
self
.
parallel
.
children_count
.
load
(
SeqCst
)
self
.
abs_descendants
.
len
(
)
)
}
}
impl
<
E
S
:
Encoder
<
E
>
>
Encodable
<
S
E
>
for
BaseFlow
{
fn
encode
(
&
self
e
:
&
mut
S
)
-
>
Result
<
(
)
E
>
{
e
.
emit_struct
(
"
base
"
0
|
e
|
{
try
!
(
e
.
emit_struct_field
(
"
id
"
0
|
e
|
self
.
debug_id
(
)
.
encode
(
e
)
)
)
try
!
(
e
.
emit_struct_field
(
"
abs_position
"
1
|
e
|
self
.
abs_position
.
encode
(
e
)
)
)
try
!
(
e
.
emit_struct_field
(
"
intrinsic_inline_sizes
"
2
|
e
|
self
.
intrinsic_inline_sizes
.
encode
(
e
)
)
)
try
!
(
e
.
emit_struct_field
(
"
position
"
3
|
e
|
self
.
position
.
encode
(
e
)
)
)
e
.
emit_struct_field
(
"
children
"
4
|
e
|
{
e
.
emit_seq
(
self
.
children
.
len
(
)
|
e
|
{
for
(
i
c
)
in
self
.
children
.
iter
(
)
.
enumerate
(
)
{
try
!
(
e
.
emit_seq_elt
(
i
|
e
|
c
.
encode
(
e
)
)
)
}
Ok
(
(
)
)
}
)
}
)
}
)
}
}
#
[
unsafe_destructor
]
impl
Drop
for
BaseFlow
{
fn
drop
(
&
mut
self
)
{
if
self
.
ref_count
.
load
(
SeqCst
)
!
=
0
{
fail
!
(
"
Flow
destroyed
before
its
ref
count
hit
zero
this
is
unsafe
!
"
)
}
}
}
impl
BaseFlow
{
#
[
inline
]
pub
fn
new
(
node
:
ThreadSafeLayoutNode
)
-
>
BaseFlow
{
let
writing_mode
=
node
.
style
(
)
.
writing_mode
;
BaseFlow
{
ref_count
:
AtomicUint
:
:
new
(
1
)
restyle_damage
:
node
.
restyle_damage
(
)
children
:
FlowList
:
:
new
(
)
intrinsic_inline_sizes
:
IntrinsicISizes
:
:
new
(
)
position
:
LogicalRect
:
:
zero
(
writing_mode
)
overflow
:
LogicalRect
:
:
zero
(
writing_mode
)
parallel
:
FlowParallelInfo
:
:
new
(
)
floats
:
Floats
:
:
new
(
writing_mode
)
collapsible_margins
:
CollapsibleMargins
:
:
new
(
)
abs_position
:
Zero
:
:
zero
(
)
abs_descendants
:
Descendants
:
:
new
(
)
absolute_static_i_offset
:
Au
(
0
)
fixed_static_i_offset
:
Au
(
0
)
block_container_inline_size
:
Au
(
0
)
block_container_explicit_block_size
:
None
absolute_cb
:
ContainingBlockLink
:
:
new
(
)
display_list
:
DisplayList
:
:
new
(
)
layers
:
DList
:
:
new
(
)
absolute_position_info
:
AbsolutePositionInfo
:
:
new
(
writing_mode
)
clip_rect
:
Rect
(
Zero
:
:
zero
(
)
Size2D
(
Au
(
0
)
Au
(
0
)
)
)
flags
:
FlowFlags
:
:
new
(
)
writing_mode
:
writing_mode
}
}
pub
fn
child_iter
<
'
a
>
(
&
'
a
mut
self
)
-
>
MutFlowListIterator
<
'
a
>
{
self
.
children
.
iter_mut
(
)
}
pub
unsafe
fn
ref_count
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
AtomicUint
{
&
self
.
ref_count
}
pub
fn
debug_id
(
&
self
)
-
>
uint
{
let
p
=
self
as
*
const
_
;
p
as
uint
}
pub
fn
validate_display_list_geometry
(
&
self
)
{
let
position_with_overflow
=
self
.
position
.
union
(
&
self
.
overflow
)
;
let
bounds
=
Rect
(
self
.
abs_position
Size2D
(
position_with_overflow
.
size
.
inline
position_with_overflow
.
size
.
block
)
)
;
for
item
in
self
.
display_list
.
iter
(
)
{
let
paint_bounds
=
match
item
.
base
(
)
.
bounds
.
intersection
(
&
item
.
base
(
)
.
clip_rect
)
{
None
=
>
continue
Some
(
rect
)
=
>
rect
}
;
if
paint_bounds
.
is_empty
(
)
{
continue
;
}
if
bounds
.
union
(
&
paint_bounds
)
!
=
bounds
{
error
!
(
"
DisplayList
item
{
}
outside
of
Flow
overflow
(
{
}
)
"
item
paint_bounds
)
;
}
}
}
}
impl
<
'
a
>
ImmutableFlowUtils
for
&
'
a
Flow
+
'
a
{
fn
is_block_like
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
BlockFlowClass
=
>
true
_
=
>
false
}
}
fn
is_proper_table_child
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableRowFlowClass
|
TableRowGroupFlowClass
|
TableColGroupFlowClass
|
TableCaptionFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table_row
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableRowFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table_cell
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableCellFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table_colgroup
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableColGroupFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table_caption
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableCaptionFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table_rowgroup
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableRowGroupFlowClass
=
>
true
_
=
>
false
}
}
fn
is_table_kind
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
TableWrapperFlowClass
|
TableFlowClass
|
TableColGroupFlowClass
|
TableRowGroupFlowClass
|
TableRowFlowClass
|
TableCaptionFlowClass
|
TableCellFlowClass
=
>
true
_
=
>
false
}
}
fn
need_anonymous_flow
(
self
child
:
&
Flow
)
-
>
bool
{
match
self
.
class
(
)
{
TableFlowClass
=
>
!
child
.
is_proper_table_child
(
)
TableRowGroupFlowClass
=
>
!
child
.
is_table_row
(
)
TableRowFlowClass
=
>
!
child
.
is_table_cell
(
)
_
=
>
false
}
}
fn
generate_missing_child_flow
(
self
node
:
&
ThreadSafeLayoutNode
)
-
>
FlowRef
{
let
flow
=
match
self
.
class
(
)
{
TableFlowClass
|
TableRowGroupFlowClass
=
>
{
let
fragment
=
Fragment
:
:
new_anonymous_table_fragment
(
node
TableRowFragment
)
;
box
TableRowFlow
:
:
from_node_and_fragment
(
node
fragment
)
as
Box
<
Flow
>
}
TableRowFlowClass
=
>
{
let
fragment
=
Fragment
:
:
new_anonymous_table_fragment
(
node
TableCellFragment
)
;
box
TableCellFlow
:
:
from_node_and_fragment
(
node
fragment
)
as
Box
<
Flow
>
}
_
=
>
{
fail
!
(
"
no
need
to
generate
a
missing
child
"
)
}
}
;
FlowRef
:
:
new
(
flow
)
}
fn
is_leaf
(
self
)
-
>
bool
{
base
(
self
)
.
children
.
len
(
)
=
=
0
}
fn
child_count
(
self
)
-
>
uint
{
base
(
self
)
.
children
.
len
(
)
}
fn
is_block_container
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
BlockFlowClass
|
TableCaptionFlowClass
|
TableCellFlowClass
=
>
{
self
.
child_count
(
)
!
=
0
}
_
=
>
false
}
}
fn
is_block_flow
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
BlockFlowClass
=
>
true
_
=
>
false
}
}
fn
is_inline_flow
(
self
)
-
>
bool
{
match
self
.
class
(
)
{
InlineFlowClass
=
>
true
_
=
>
false
}
}
fn
dump
(
self
)
{
self
.
dump_with_level
(
0
)
}
fn
dump_with_level
(
self
level
:
uint
)
{
let
mut
indent
=
String
:
:
new
(
)
;
for
_
in
range
(
0
level
)
{
indent
.
push_str
(
"
|
"
)
}
println
!
(
"
{
}
+
{
}
"
indent
self
.
to_string
(
)
)
;
for
kid
in
imm_child_iter
(
self
)
{
kid
.
dump_with_level
(
level
+
1
)
}
}
}
impl
<
'
a
>
MutableFlowUtils
for
&
'
a
mut
Flow
+
'
a
{
fn
traverse_preorder
<
T
:
PreorderFlowTraversal
>
(
self
traversal
:
&
T
)
{
if
traversal
.
should_process
(
self
)
{
traversal
.
process
(
self
)
;
}
for
kid
in
child_iter
(
self
)
{
kid
.
traverse_preorder
(
traversal
)
;
}
}
fn
traverse_postorder
<
T
:
PostorderFlowTraversal
>
(
self
traversal
:
&
T
)
{
for
kid
in
child_iter
(
self
)
{
kid
.
traverse_postorder
(
traversal
)
;
}
if
traversal
.
should_process
(
self
)
{
traversal
.
process
(
self
)
}
}
fn
store_overflow
(
self
_
:
&
LayoutContext
)
{
let
my_position
=
mut_base
(
self
)
.
position
;
let
mut
overflow
=
my_position
;
if
self
.
is_block_container
(
)
{
for
kid
in
child_iter
(
self
)
{
if
kid
.
is_store_overflow_delayed
(
)
{
continue
;
}
let
mut
kid_overflow
=
base
(
kid
)
.
overflow
;
kid_overflow
=
kid_overflow
.
translate
(
&
my_position
.
start
)
;
overflow
=
overflow
.
union
(
&
kid_overflow
)
}
for
descendant_link
in
mut_base
(
self
)
.
abs_descendants
.
iter
(
)
{
let
mut
kid_overflow
=
base
(
descendant_link
)
.
overflow
;
kid_overflow
=
kid_overflow
.
translate
(
&
my_position
.
start
)
;
overflow
=
overflow
.
union
(
&
kid_overflow
)
}
}
mut_base
(
self
)
.
overflow
=
overflow
;
}
fn
collect_static_block_offsets_from_children
(
self
)
{
let
mut
absolute_descendant_block_offsets
=
Vec
:
:
new
(
)
;
for
kid
in
mut_base
(
self
)
.
child_iter
(
)
{
let
mut
gives_absolute_offsets
=
true
;
if
kid
.
is_block_like
(
)
{
let
kid_block
=
kid
.
as_block
(
)
;
if
kid_block
.
is_fixed
(
)
|
|
kid_block
.
is_absolutely_positioned
(
)
{
gives_absolute_offsets
=
false
;
absolute_descendant_block_offsets
.
push
(
kid_block
.
get_hypothetical_block_start_edge
(
)
)
;
}
else
if
kid_block
.
is_positioned
(
)
{
gives_absolute_offsets
=
false
;
}
}
if
gives_absolute_offsets
{
let
kid_base
=
mut_base
(
kid
)
;
let
offsets
=
mem
:
:
replace
(
&
mut
kid_base
.
abs_descendants
.
static_block_offsets
Vec
:
:
new
(
)
)
;
for
block_offset
in
offsets
.
into_iter
(
)
{
absolute_descendant_block_offsets
.
push
(
block_offset
+
kid_base
.
position
.
start
.
b
)
;
}
}
}
mut_base
(
self
)
.
abs_descendants
.
static_block_offsets
=
absolute_descendant_block_offsets
}
fn
propagate_restyle_damage
(
self
)
{
struct
DirtyFloats
{
left
:
bool
right
:
bool
}
fn
doit
(
flow
:
&
mut
Flow
down
:
RestyleDamage
dirty_floats
:
&
mut
DirtyFloats
)
-
>
RestyleDamage
{
match
flow
.
float_clearance
(
)
{
clear
:
:
none
=
>
{
}
clear
:
:
left
=
>
{
(
*
dirty_floats
)
.
left
=
false
;
}
clear
:
:
right
=
>
{
(
*
dirty_floats
)
.
right
=
false
;
}
clear
:
:
both
=
>
{
(
*
dirty_floats
)
.
left
=
false
;
(
*
dirty_floats
)
.
right
=
false
;
}
}
match
flow
.
float_kind
(
)
{
float
:
:
none
=
>
{
}
float
:
:
left
=
>
{
(
*
dirty_floats
)
.
left
=
true
;
}
float
:
:
right
=
>
{
(
*
dirty_floats
)
.
right
=
true
;
}
}
let
mut
my_damage
=
mut_base
(
flow
)
.
restyle_damage
;
my_damage
.
insert
(
down
)
;
if
(
*
dirty_floats
)
.
left
|
|
(
*
dirty_floats
)
.
right
{
my_damage
=
RestyleDamage
:
:
all
(
)
;
}
let
down_damage
=
my_damage
.
propagate_down
(
)
;
for
kid
in
child_iter
(
flow
)
{
my_damage
.
insert
(
doit
(
kid
down_damage
dirty_floats
)
)
;
}
mut_base
(
flow
)
.
restyle_damage
=
my_damage
;
my_damage
.
propagate_up
(
)
}
doit
(
self
RestyleDamage
:
:
empty
(
)
&
mut
DirtyFloats
{
left
:
false
right
:
false
}
)
;
}
}
impl
MutableOwnedFlowUtils
for
FlowRef
{
fn
set_absolute_descendants
(
&
mut
self
abs_descendants
:
AbsDescendants
)
{
let
this
=
self
.
clone
(
)
;
let
block
=
self
.
as_block
(
)
;
block
.
base
.
abs_descendants
=
abs_descendants
;
for
descendant_link
in
block
.
base
.
abs_descendants
.
iter
(
)
{
let
base
=
mut_base
(
descendant_link
)
;
base
.
absolute_cb
.
set
(
this
.
clone
(
)
)
;
}
}
}
pub
struct
ContainingBlockLink
{
link
:
Option
<
FlowRef
>
}
impl
ContainingBlockLink
{
fn
new
(
)
-
>
ContainingBlockLink
{
ContainingBlockLink
{
link
:
None
}
}
fn
set
(
&
mut
self
link
:
FlowRef
)
{
self
.
link
=
Some
(
link
)
}
pub
unsafe
fn
get
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Option
<
FlowRef
>
{
&
mut
self
.
link
}
#
[
inline
]
pub
fn
generated_containing_block_rect
(
&
mut
self
)
-
>
LogicalRect
<
Au
>
{
match
self
.
link
{
None
=
>
fail
!
(
"
haven
'
t
done
it
"
)
Some
(
ref
mut
link
)
=
>
link
.
generated_containing_block_rect
(
)
}
}
}
