use
wrapper
:
:
{
PseudoElementType
ThreadSafeLayoutNode
}
;
use
std
:
:
mem
;
use
style
:
:
properties
:
:
ComputedValues
;
use
std
:
:
sync
:
:
Arc
;
pub
trait
StyledNode
{
fn
style
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Arc
<
ComputedValues
>
;
fn
has_style
(
&
self
)
-
>
bool
;
fn
unstyle
(
self
)
;
}
impl
<
'
ln
>
StyledNode
for
ThreadSafeLayoutNode
<
'
ln
>
{
#
[
inline
]
fn
style
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Arc
<
ComputedValues
>
{
unsafe
{
let
layout_data_ref
=
self
.
borrow_layout_data
(
)
;
match
self
.
get_pseudo_element_type
(
)
{
PseudoElementType
:
:
Before
(
_
)
=
>
{
mem
:
:
transmute
(
layout_data_ref
.
as_ref
(
)
.
unwrap
(
)
.
data
.
before_style
.
as_ref
(
)
.
unwrap
(
)
)
}
PseudoElementType
:
:
After
(
_
)
=
>
{
mem
:
:
transmute
(
layout_data_ref
.
as_ref
(
)
.
unwrap
(
)
.
data
.
after_style
.
as_ref
(
)
.
unwrap
(
)
)
}
PseudoElementType
:
:
Normal
=
>
{
mem
:
:
transmute
(
layout_data_ref
.
as_ref
(
)
.
unwrap
(
)
.
shared_data
.
style
.
as_ref
(
)
.
unwrap
(
)
)
}
}
}
}
fn
has_style
(
&
self
)
-
>
bool
{
let
layout_data_ref
=
self
.
borrow_layout_data
(
)
;
layout_data_ref
.
as_ref
(
)
.
unwrap
(
)
.
shared_data
.
style
.
is_some
(
)
}
fn
unstyle
(
self
)
{
let
mut
layout_data_ref
=
self
.
mutate_layout_data
(
)
;
let
layout_data
=
layout_data_ref
.
as_mut
(
)
.
expect
(
"
no
layout
data
"
)
;
let
style
=
match
self
.
get_pseudo_element_type
(
)
{
PseudoElementType
:
:
Before
(
_
)
=
>
&
mut
layout_data
.
data
.
before_style
PseudoElementType
:
:
After
(
_
)
=
>
&
mut
layout_data
.
data
.
after_style
PseudoElementType
:
:
Normal
=
>
&
mut
layout_data
.
shared_data
.
style
}
;
*
style
=
None
;
}
}
