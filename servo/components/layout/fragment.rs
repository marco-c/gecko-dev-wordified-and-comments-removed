#
!
[
deny
(
unsafe_code
)
]
use
app_units
:
:
Au
;
use
canvas_traits
:
:
CanvasMsg
;
use
context
:
:
LayoutContext
;
use
euclid
:
:
{
Point2D
Rect
Size2D
}
;
use
floats
:
:
ClearType
;
use
flow
:
:
{
self
Flow
}
;
use
flow_ref
:
:
{
self
FlowRef
}
;
use
gfx
;
use
gfx
:
:
display_list
:
:
{
BLUR_INFLATION_FACTOR
OpaqueNode
}
;
use
gfx
:
:
text
:
:
glyph
:
:
CharIndex
;
use
gfx
:
:
text
:
:
text_run
:
:
{
TextRun
TextRunSlice
}
;
use
gfx_traits
:
:
{
LayerId
LayerType
}
;
use
incremental
:
:
{
RECONSTRUCT_FLOW
RestyleDamage
}
;
use
inline
:
:
{
FIRST_FRAGMENT_OF_ELEMENT
InlineFragmentContext
InlineFragmentNodeInfo
}
;
use
inline
:
:
{
InlineMetrics
LAST_FRAGMENT_OF_ELEMENT
}
;
use
ipc_channel
:
:
ipc
:
:
IpcSender
;
use
layout_debug
;
use
model
:
:
{
self
IntrinsicISizes
IntrinsicISizesContribution
MaybeAuto
specified
}
;
use
msg
:
:
constellation_msg
:
:
PipelineId
;
use
net_traits
:
:
image
:
:
base
:
:
{
Image
ImageMetadata
}
;
use
net_traits
:
:
image_cache_thread
:
:
{
ImageOrMetadataAvailable
UsePlaceholder
}
;
use
range
:
:
*
;
use
rustc_serialize
:
:
{
Encodable
Encoder
}
;
use
script
:
:
dom
:
:
htmlcanvaselement
:
:
HTMLCanvasData
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
cmp
:
:
{
max
min
}
;
use
std
:
:
collections
:
:
LinkedList
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
style
:
:
computed_values
:
:
content
:
:
ContentItem
;
use
style
:
:
computed_values
:
:
{
border_collapse
clear
display
mix_blend_mode
overflow_wrap
}
;
use
style
:
:
computed_values
:
:
{
overflow_x
position
text_decoration
transform_style
}
;
use
style
:
:
computed_values
:
:
{
white_space
word_break
z_index
}
;
use
style
:
:
dom
:
:
TRestyleDamage
;
use
style
:
:
logical_geometry
:
:
{
LogicalMargin
LogicalRect
LogicalSize
WritingMode
}
;
use
style
:
:
properties
:
:
ComputedValues
;
use
style
:
:
values
:
:
computed
:
:
{
LengthOrPercentage
LengthOrPercentageOrAuto
}
;
use
style
:
:
values
:
:
computed
:
:
{
LengthOrPercentageOrNone
}
;
use
text
;
use
text
:
:
TextRunScanner
;
use
url
:
:
Url
;
use
util
;
use
util
:
:
str
:
:
slice_chars
;
use
wrapper
:
:
{
PseudoElementType
ThreadSafeLayoutElement
ThreadSafeLayoutNode
}
;
#
[
derive
(
Clone
)
]
pub
struct
Fragment
{
pub
node
:
OpaqueNode
pub
style
:
Arc
<
ComputedValues
>
pub
border_box
:
LogicalRect
<
Au
>
pub
border_padding
:
LogicalMargin
<
Au
>
pub
margin
:
LogicalMargin
<
Au
>
pub
specific
:
SpecificFragmentInfo
pub
inline_context
:
Option
<
InlineFragmentContext
>
pub
restyle_damage
:
RestyleDamage
pub
pseudo
:
PseudoElementType
<
(
)
>
pub
flags
:
FragmentFlags
pub
debug_id
:
u16
}
impl
Encodable
for
Fragment
{
fn
encode
<
S
:
Encoder
>
(
&
self
e
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
e
.
emit_struct
(
"
fragment
"
0
|
e
|
{
try
!
(
e
.
emit_struct_field
(
"
id
"
0
|
e
|
self
.
debug_id
(
)
.
encode
(
e
)
)
)
;
try
!
(
e
.
emit_struct_field
(
"
border_box
"
1
|
e
|
self
.
border_box
.
encode
(
e
)
)
)
;
e
.
emit_struct_field
(
"
margin
"
2
|
e
|
self
.
margin
.
encode
(
e
)
)
}
)
}
}
#
[
derive
(
Clone
)
]
pub
enum
SpecificFragmentInfo
{
Generic
GeneratedContent
(
Box
<
GeneratedContentInfo
>
)
Iframe
(
Box
<
IframeFragmentInfo
>
)
Image
(
Box
<
ImageFragmentInfo
>
)
Canvas
(
Box
<
CanvasFragmentInfo
>
)
InlineAbsoluteHypothetical
(
InlineAbsoluteHypotheticalFragmentInfo
)
InlineBlock
(
InlineBlockFragmentInfo
)
InlineAbsolute
(
InlineAbsoluteFragmentInfo
)
ScannedText
(
Box
<
ScannedTextFragmentInfo
>
)
Table
TableCell
TableColumn
(
TableColumnFragmentInfo
)
TableRow
TableWrapper
Multicol
MulticolColumn
UnscannedText
(
UnscannedTextFragmentInfo
)
}
impl
SpecificFragmentInfo
{
fn
restyle_damage
(
&
self
)
-
>
RestyleDamage
{
let
flow
=
match
*
self
{
SpecificFragmentInfo
:
:
Canvas
(
_
)
|
SpecificFragmentInfo
:
:
GeneratedContent
(
_
)
|
SpecificFragmentInfo
:
:
Iframe
(
_
)
|
SpecificFragmentInfo
:
:
Image
(
_
)
|
SpecificFragmentInfo
:
:
ScannedText
(
_
)
|
SpecificFragmentInfo
:
:
Table
|
SpecificFragmentInfo
:
:
TableCell
|
SpecificFragmentInfo
:
:
TableColumn
(
_
)
|
SpecificFragmentInfo
:
:
TableRow
|
SpecificFragmentInfo
:
:
TableWrapper
|
SpecificFragmentInfo
:
:
Multicol
|
SpecificFragmentInfo
:
:
MulticolColumn
|
SpecificFragmentInfo
:
:
UnscannedText
(
_
)
|
SpecificFragmentInfo
:
:
Generic
=
>
return
RestyleDamage
:
:
empty
(
)
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
ref
info
)
=
>
&
info
.
flow_ref
SpecificFragmentInfo
:
:
InlineAbsolute
(
ref
info
)
=
>
&
info
.
flow_ref
SpecificFragmentInfo
:
:
InlineBlock
(
ref
info
)
=
>
&
info
.
flow_ref
}
;
flow
:
:
base
(
&
*
*
flow
)
.
restyle_damage
}
pub
fn
get_type
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
SpecificFragmentInfo
:
:
Canvas
(
_
)
=
>
"
SpecificFragmentInfo
:
:
Canvas
"
SpecificFragmentInfo
:
:
Generic
=
>
"
SpecificFragmentInfo
:
:
Generic
"
SpecificFragmentInfo
:
:
GeneratedContent
(
_
)
=
>
"
SpecificFragmentInfo
:
:
GeneratedContent
"
SpecificFragmentInfo
:
:
Iframe
(
_
)
=
>
"
SpecificFragmentInfo
:
:
Iframe
"
SpecificFragmentInfo
:
:
Image
(
_
)
=
>
"
SpecificFragmentInfo
:
:
Image
"
SpecificFragmentInfo
:
:
InlineAbsolute
(
_
)
=
>
"
SpecificFragmentInfo
:
:
InlineAbsolute
"
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
_
)
=
>
{
"
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
"
}
SpecificFragmentInfo
:
:
InlineBlock
(
_
)
=
>
"
SpecificFragmentInfo
:
:
InlineBlock
"
SpecificFragmentInfo
:
:
ScannedText
(
_
)
=
>
"
SpecificFragmentInfo
:
:
ScannedText
"
SpecificFragmentInfo
:
:
Table
=
>
"
SpecificFragmentInfo
:
:
Table
"
SpecificFragmentInfo
:
:
TableCell
=
>
"
SpecificFragmentInfo
:
:
TableCell
"
SpecificFragmentInfo
:
:
TableColumn
(
_
)
=
>
"
SpecificFragmentInfo
:
:
TableColumn
"
SpecificFragmentInfo
:
:
TableRow
=
>
"
SpecificFragmentInfo
:
:
TableRow
"
SpecificFragmentInfo
:
:
TableWrapper
=
>
"
SpecificFragmentInfo
:
:
TableWrapper
"
SpecificFragmentInfo
:
:
Multicol
=
>
"
SpecificFragmentInfo
:
:
Multicol
"
SpecificFragmentInfo
:
:
MulticolColumn
=
>
"
SpecificFragmentInfo
:
:
MulticolColumn
"
SpecificFragmentInfo
:
:
UnscannedText
(
_
)
=
>
"
SpecificFragmentInfo
:
:
UnscannedText
"
}
}
}
impl
fmt
:
:
Debug
for
SpecificFragmentInfo
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
SpecificFragmentInfo
:
:
ScannedText
(
ref
info
)
=
>
{
write
!
(
f
"
\
"
{
}
\
"
"
slice_chars
(
&
*
info
.
run
.
text
info
.
range
.
begin
(
)
.
get
(
)
as
usize
info
.
range
.
end
(
)
.
get
(
)
as
usize
)
)
}
SpecificFragmentInfo
:
:
UnscannedText
(
ref
info
)
=
>
{
write
!
(
f
"
\
"
{
}
\
"
"
info
.
text
)
}
_
=
>
Ok
(
(
)
)
}
}
}
fn
clamp_size
(
size
:
Au
min_size
:
LengthOrPercentage
max_size
:
LengthOrPercentageOrNone
container_size
:
Au
)
-
>
Au
{
let
min_size
=
model
:
:
specified
(
min_size
container_size
)
;
let
max_size
=
model
:
:
specified_or_none
(
max_size
container_size
)
;
max
(
min_size
match
max_size
{
None
=
>
size
Some
(
max_size
)
=
>
min
(
size
max_size
)
}
)
}
#
[
derive
(
Clone
)
]
pub
enum
GeneratedContentInfo
{
ListItem
ContentItem
(
ContentItem
)
}
#
[
derive
(
Clone
)
]
pub
struct
InlineAbsoluteHypotheticalFragmentInfo
{
pub
flow_ref
:
FlowRef
}
impl
InlineAbsoluteHypotheticalFragmentInfo
{
pub
fn
new
(
flow_ref
:
FlowRef
)
-
>
InlineAbsoluteHypotheticalFragmentInfo
{
InlineAbsoluteHypotheticalFragmentInfo
{
flow_ref
:
flow_ref
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
InlineBlockFragmentInfo
{
pub
flow_ref
:
FlowRef
}
impl
InlineBlockFragmentInfo
{
pub
fn
new
(
flow_ref
:
FlowRef
)
-
>
InlineBlockFragmentInfo
{
InlineBlockFragmentInfo
{
flow_ref
:
flow_ref
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
InlineAbsoluteFragmentInfo
{
pub
flow_ref
:
FlowRef
}
impl
InlineAbsoluteFragmentInfo
{
pub
fn
new
(
flow_ref
:
FlowRef
)
-
>
InlineAbsoluteFragmentInfo
{
InlineAbsoluteFragmentInfo
{
flow_ref
:
flow_ref
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
CanvasFragmentInfo
{
pub
replaced_image_fragment_info
:
ReplacedImageFragmentInfo
pub
renderer_id
:
Option
<
usize
>
pub
ipc_renderer
:
Option
<
Arc
<
Mutex
<
IpcSender
<
CanvasMsg
>
>
>
>
pub
dom_width
:
Au
pub
dom_height
:
Au
}
impl
CanvasFragmentInfo
{
pub
fn
new
<
'
ln
N
:
ThreadSafeLayoutNode
<
'
ln
>
>
(
node
:
&
N
data
:
HTMLCanvasData
)
-
>
CanvasFragmentInfo
{
CanvasFragmentInfo
{
replaced_image_fragment_info
:
ReplacedImageFragmentInfo
:
:
new
(
node
)
renderer_id
:
data
.
renderer_id
ipc_renderer
:
data
.
ipc_renderer
.
map
(
|
renderer
|
Arc
:
:
new
(
Mutex
:
:
new
(
renderer
)
)
)
dom_width
:
Au
:
:
from_px
(
data
.
width
as
i32
)
dom_height
:
Au
:
:
from_px
(
data
.
height
as
i32
)
}
}
pub
fn
canvas_inline_size
(
&
self
)
-
>
Au
{
if
self
.
replaced_image_fragment_info
.
writing_mode_is_vertical
{
self
.
dom_height
}
else
{
self
.
dom_width
}
}
pub
fn
canvas_block_size
(
&
self
)
-
>
Au
{
if
self
.
replaced_image_fragment_info
.
writing_mode_is_vertical
{
self
.
dom_width
}
else
{
self
.
dom_height
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
ImageFragmentInfo
{
pub
replaced_image_fragment_info
:
ReplacedImageFragmentInfo
pub
image
:
Option
<
Arc
<
Image
>
>
pub
metadata
:
Option
<
ImageMetadata
>
}
impl
ImageFragmentInfo
{
pub
fn
new
<
'
ln
N
:
ThreadSafeLayoutNode
<
'
ln
>
>
(
node
:
&
N
url
:
Option
<
Url
>
layout_context
:
&
LayoutContext
)
-
>
ImageFragmentInfo
{
let
image_or_metadata
=
url
.
and_then
(
|
url
|
{
layout_context
.
get_or_request_image_or_meta
(
url
UsePlaceholder
:
:
Yes
)
}
)
;
let
(
image
metadata
)
=
match
image_or_metadata
{
Some
(
ImageOrMetadataAvailable
:
:
ImageAvailable
(
i
)
)
=
>
{
(
Some
(
i
.
clone
(
)
)
Some
(
ImageMetadata
{
height
:
i
.
height
width
:
i
.
width
}
)
)
}
Some
(
ImageOrMetadataAvailable
:
:
MetadataAvailable
(
m
)
)
=
>
{
(
None
Some
(
m
)
)
}
None
=
>
{
(
None
None
)
}
}
;
ImageFragmentInfo
{
replaced_image_fragment_info
:
ReplacedImageFragmentInfo
:
:
new
(
node
)
image
:
image
metadata
:
metadata
}
}
pub
fn
image_inline_size
(
&
mut
self
)
-
>
Au
{
match
self
.
metadata
{
Some
(
ref
metadata
)
=
>
{
Au
:
:
from_px
(
if
self
.
replaced_image_fragment_info
.
writing_mode_is_vertical
{
metadata
.
height
}
else
{
metadata
.
width
}
as
i32
)
}
None
=
>
Au
(
0
)
}
}
pub
fn
image_block_size
(
&
mut
self
)
-
>
Au
{
match
self
.
metadata
{
Some
(
ref
metadata
)
=
>
{
Au
:
:
from_px
(
if
self
.
replaced_image_fragment_info
.
writing_mode_is_vertical
{
metadata
.
width
}
else
{
metadata
.
height
}
as
i32
)
}
None
=
>
Au
(
0
)
}
}
pub
fn
tile_image
(
position
:
&
mut
Au
size
:
&
mut
Au
virtual_position
:
Au
image_size
:
u32
)
{
let
image_size
=
image_size
as
i32
;
if
image_size
=
=
0
{
return
}
let
delta_pixels
=
(
virtual_position
-
*
position
)
.
to_px
(
)
;
let
tile_count
=
(
delta_pixels
+
image_size
-
1
)
/
image_size
;
let
offset
=
Au
:
:
from_px
(
image_size
*
tile_count
)
;
let
new_position
=
virtual_position
-
offset
;
*
size
=
*
position
-
new_position
+
*
size
;
*
position
=
new_position
;
}
}
#
[
derive
(
Clone
)
]
pub
struct
ReplacedImageFragmentInfo
{
pub
computed_inline_size
:
Option
<
Au
>
pub
computed_block_size
:
Option
<
Au
>
pub
writing_mode_is_vertical
:
bool
}
impl
ReplacedImageFragmentInfo
{
pub
fn
new
<
'
ln
N
>
(
node
:
&
N
)
-
>
ReplacedImageFragmentInfo
where
N
:
ThreadSafeLayoutNode
<
'
ln
>
{
let
is_vertical
=
node
.
style
(
)
.
writing_mode
.
is_vertical
(
)
;
ReplacedImageFragmentInfo
{
computed_inline_size
:
None
computed_block_size
:
None
writing_mode_is_vertical
:
is_vertical
}
}
pub
fn
computed_inline_size
(
&
self
)
-
>
Au
{
self
.
computed_inline_size
.
expect
(
"
image
inline_size
is
not
computed
yet
!
"
)
}
pub
fn
computed_block_size
(
&
self
)
-
>
Au
{
self
.
computed_block_size
.
expect
(
"
image
block_size
is
not
computed
yet
!
"
)
}
pub
fn
style_length
(
style_length
:
LengthOrPercentageOrAuto
container_size
:
Option
<
Au
>
)
-
>
MaybeAuto
{
match
(
style_length
container_size
)
{
(
LengthOrPercentageOrAuto
:
:
Length
(
length
)
_
)
=
>
MaybeAuto
:
:
Specified
(
length
)
(
LengthOrPercentageOrAuto
:
:
Percentage
(
pc
)
Some
(
container_size
)
)
=
>
{
MaybeAuto
:
:
Specified
(
container_size
.
scale_by
(
pc
)
)
}
(
LengthOrPercentageOrAuto
:
:
Percentage
(
_
)
None
)
=
>
MaybeAuto
:
:
Auto
(
LengthOrPercentageOrAuto
:
:
Calc
(
calc
)
Some
(
container_size
)
)
=
>
{
MaybeAuto
:
:
Specified
(
calc
.
length
(
)
+
container_size
.
scale_by
(
calc
.
percentage
(
)
)
)
}
(
LengthOrPercentageOrAuto
:
:
Calc
(
_
)
None
)
=
>
MaybeAuto
:
:
Auto
(
LengthOrPercentageOrAuto
:
:
Auto
_
)
=
>
MaybeAuto
:
:
Auto
}
}
pub
fn
calculate_replaced_inline_size
(
&
mut
self
style
:
&
ComputedValues
noncontent_inline_size
:
Au
container_inline_size
:
Au
fragment_inline_size
:
Au
fragment_block_size
:
Au
)
-
>
Au
{
let
style_inline_size
=
style
.
content_inline_size
(
)
;
let
style_block_size
=
style
.
content_block_size
(
)
;
let
style_min_inline_size
=
style
.
min_inline_size
(
)
;
let
style_max_inline_size
=
style
.
max_inline_size
(
)
;
let
style_min_block_size
=
style
.
min_block_size
(
)
;
let
style_max_block_size
=
style
.
max_block_size
(
)
;
let
inline_size
=
ReplacedImageFragmentInfo
:
:
style_length
(
style_inline_size
Some
(
container_inline_size
)
)
;
let
inline_size
=
match
inline_size
{
MaybeAuto
:
:
Auto
=
>
{
let
intrinsic_width
=
fragment_inline_size
;
let
intrinsic_height
=
fragment_block_size
;
if
intrinsic_height
=
=
Au
(
0
)
{
intrinsic_width
}
else
{
let
ratio
=
intrinsic_width
.
to_f32_px
(
)
/
intrinsic_height
.
to_f32_px
(
)
;
let
specified_height
=
ReplacedImageFragmentInfo
:
:
style_length
(
style_block_size
None
)
;
let
specified_height
=
match
specified_height
{
MaybeAuto
:
:
Auto
=
>
intrinsic_height
MaybeAuto
:
:
Specified
(
h
)
=
>
h
}
;
let
specified_height
=
clamp_size
(
specified_height
style_min_block_size
style_max_block_size
Au
(
0
)
)
;
Au
:
:
from_f32_px
(
specified_height
.
to_f32_px
(
)
*
ratio
)
}
}
MaybeAuto
:
:
Specified
(
w
)
=
>
w
}
;
let
inline_size
=
clamp_size
(
inline_size
style_min_inline_size
style_max_inline_size
container_inline_size
)
;
self
.
computed_inline_size
=
Some
(
inline_size
)
;
inline_size
+
noncontent_inline_size
}
pub
fn
calculate_replaced_block_size
(
&
mut
self
style
:
&
ComputedValues
noncontent_block_size
:
Au
containing_block_block_size
:
Option
<
Au
>
fragment_inline_size
:
Au
fragment_block_size
:
Au
)
-
>
Au
{
let
style_block_size
=
style
.
content_block_size
(
)
;
let
style_min_block_size
=
style
.
min_block_size
(
)
;
let
style_max_block_size
=
style
.
max_block_size
(
)
;
let
inline_size
=
self
.
computed_inline_size
(
)
;
let
block_size
=
ReplacedImageFragmentInfo
:
:
style_length
(
style_block_size
containing_block_block_size
)
;
let
block_size
=
match
block_size
{
MaybeAuto
:
:
Auto
=
>
{
let
intrinsic_width
=
fragment_inline_size
;
let
intrinsic_height
=
fragment_block_size
;
let
scale
=
intrinsic_width
.
to_f32_px
(
)
/
inline_size
.
to_f32_px
(
)
;
Au
:
:
from_f32_px
(
intrinsic_height
.
to_f32_px
(
)
/
scale
)
}
MaybeAuto
:
:
Specified
(
h
)
=
>
{
h
}
}
;
let
block_size
=
clamp_size
(
block_size
style_min_block_size
style_max_block_size
Au
(
0
)
)
;
self
.
computed_block_size
=
Some
(
block_size
)
;
block_size
+
noncontent_block_size
}
}
#
[
derive
(
Clone
)
]
pub
struct
IframeFragmentInfo
{
pub
pipeline_id
:
PipelineId
}
impl
IframeFragmentInfo
{
pub
fn
new
<
'
ln
N
:
ThreadSafeLayoutNode
<
'
ln
>
>
(
node
:
&
N
)
-
>
IframeFragmentInfo
{
let
pipeline_id
=
node
.
iframe_pipeline_id
(
)
;
IframeFragmentInfo
{
pipeline_id
:
pipeline_id
}
}
#
[
inline
]
pub
fn
calculate_replaced_inline_size
(
&
self
style
:
&
ComputedValues
containing_size
:
Au
)
-
>
Au
{
IframeFragmentInfo
:
:
calculate_replaced_size
(
style
.
content_inline_size
(
)
style
.
min_inline_size
(
)
style
.
max_inline_size
(
)
Some
(
containing_size
)
Au
:
:
from_px
(
300
)
)
}
#
[
inline
]
pub
fn
calculate_replaced_block_size
(
&
self
style
:
&
ComputedValues
containing_size
:
Option
<
Au
>
)
-
>
Au
{
IframeFragmentInfo
:
:
calculate_replaced_size
(
style
.
content_block_size
(
)
style
.
min_block_size
(
)
style
.
max_block_size
(
)
containing_size
Au
:
:
from_px
(
150
)
)
}
fn
calculate_replaced_size
(
content_size
:
LengthOrPercentageOrAuto
style_min_size
:
LengthOrPercentage
style_max_size
:
LengthOrPercentageOrNone
containing_size
:
Option
<
Au
>
default_size
:
Au
)
-
>
Au
{
let
computed_size
=
match
(
content_size
containing_size
)
{
(
LengthOrPercentageOrAuto
:
:
Length
(
length
)
_
)
=
>
length
(
LengthOrPercentageOrAuto
:
:
Percentage
(
pc
)
Some
(
container_size
)
)
=
>
container_size
.
scale_by
(
pc
)
(
LengthOrPercentageOrAuto
:
:
Calc
(
calc
)
Some
(
container_size
)
)
=
>
{
container_size
.
scale_by
(
calc
.
percentage
(
)
)
+
calc
.
length
(
)
}
(
LengthOrPercentageOrAuto
:
:
Calc
(
calc
)
None
)
=
>
calc
.
length
(
)
(
LengthOrPercentageOrAuto
:
:
Percentage
(
_
)
None
)
=
>
default_size
(
LengthOrPercentageOrAuto
:
:
Auto
_
)
=
>
default_size
}
;
let
containing_size
=
containing_size
.
unwrap_or
(
Au
(
0
)
)
;
clamp_size
(
computed_size
style_min_size
style_max_size
containing_size
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
ScannedTextFragmentInfo
{
pub
run
:
Arc
<
TextRun
>
pub
content_size
:
LogicalSize
<
Au
>
pub
insertion_point
:
Option
<
CharIndex
>
pub
range
:
Range
<
CharIndex
>
pub
range_end_including_stripped_whitespace
:
CharIndex
pub
requires_line_break_afterward_if_wrapping_on_newlines
:
bool
}
impl
ScannedTextFragmentInfo
{
pub
fn
new
(
run
:
Arc
<
TextRun
>
range
:
Range
<
CharIndex
>
content_size
:
LogicalSize
<
Au
>
insertion_point
:
&
Option
<
CharIndex
>
requires_line_break_afterward_if_wrapping_on_newlines
:
bool
)
-
>
ScannedTextFragmentInfo
{
ScannedTextFragmentInfo
{
run
:
run
range
:
range
insertion_point
:
*
insertion_point
content_size
:
content_size
range_end_including_stripped_whitespace
:
range
.
end
(
)
requires_line_break_afterward_if_wrapping_on_newlines
:
requires_line_break_afterward_if_wrapping_on_newlines
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
SplitInfo
{
pub
range
:
Range
<
CharIndex
>
pub
inline_size
:
Au
}
impl
SplitInfo
{
fn
new
(
range
:
Range
<
CharIndex
>
info
:
&
ScannedTextFragmentInfo
)
-
>
SplitInfo
{
let
inline_size
=
info
.
run
.
advance_for_range
(
&
range
)
;
SplitInfo
{
range
:
range
inline_size
:
inline_size
}
}
}
pub
struct
SplitResult
{
pub
inline_start
:
Option
<
SplitInfo
>
pub
inline_end
:
Option
<
SplitInfo
>
pub
text_run
:
Arc
<
TextRun
>
}
pub
struct
TruncationResult
{
pub
split
:
SplitInfo
pub
text_run
:
Arc
<
TextRun
>
}
#
[
derive
(
Clone
)
]
pub
struct
UnscannedTextFragmentInfo
{
pub
text
:
Box
<
str
>
pub
insertion_point
:
Option
<
CharIndex
>
}
impl
UnscannedTextFragmentInfo
{
#
[
inline
]
pub
fn
new
(
text
:
String
insertion_point
:
Option
<
CharIndex
>
)
-
>
UnscannedTextFragmentInfo
{
UnscannedTextFragmentInfo
{
text
:
text
.
into_boxed_str
(
)
insertion_point
:
insertion_point
}
}
}
#
[
derive
(
Copy
Clone
)
]
pub
struct
TableColumnFragmentInfo
{
pub
span
:
u32
}
impl
TableColumnFragmentInfo
{
pub
fn
new
<
'
ln
N
:
ThreadSafeLayoutNode
<
'
ln
>
>
(
node
:
&
N
)
-
>
TableColumnFragmentInfo
{
let
element
=
node
.
as_element
(
)
;
let
span
=
element
.
get_attr
(
&
ns
!
(
)
&
atom
!
(
"
span
"
)
)
.
and_then
(
|
string
|
string
.
parse
(
)
.
ok
(
)
)
.
unwrap_or
(
0
)
;
TableColumnFragmentInfo
{
span
:
span
}
}
}
impl
Fragment
{
pub
fn
new
<
'
ln
N
:
ThreadSafeLayoutNode
<
'
ln
>
>
(
node
:
&
N
specific
:
SpecificFragmentInfo
)
-
>
Fragment
{
let
style
=
node
.
style
(
)
.
clone
(
)
;
let
writing_mode
=
style
.
writing_mode
;
let
mut
restyle_damage
=
node
.
restyle_damage
(
)
;
restyle_damage
.
remove
(
RECONSTRUCT_FLOW
)
;
Fragment
{
node
:
node
.
opaque
(
)
style
:
style
restyle_damage
:
restyle_damage
border_box
:
LogicalRect
:
:
zero
(
writing_mode
)
border_padding
:
LogicalMargin
:
:
zero
(
writing_mode
)
margin
:
LogicalMargin
:
:
zero
(
writing_mode
)
specific
:
specific
inline_context
:
None
pseudo
:
node
.
get_pseudo_element_type
(
)
.
strip
(
)
flags
:
FragmentFlags
:
:
empty
(
)
debug_id
:
layout_debug
:
:
generate_unique_debug_id
(
)
}
}
pub
fn
from_opaque_node_and_style
(
node
:
OpaqueNode
pseudo
:
PseudoElementType
<
(
)
>
style
:
Arc
<
ComputedValues
>
mut
restyle_damage
:
RestyleDamage
specific
:
SpecificFragmentInfo
)
-
>
Fragment
{
let
writing_mode
=
style
.
writing_mode
;
restyle_damage
.
remove
(
RECONSTRUCT_FLOW
)
;
Fragment
{
node
:
node
style
:
style
restyle_damage
:
restyle_damage
border_box
:
LogicalRect
:
:
zero
(
writing_mode
)
border_padding
:
LogicalMargin
:
:
zero
(
writing_mode
)
margin
:
LogicalMargin
:
:
zero
(
writing_mode
)
specific
:
specific
inline_context
:
None
pseudo
:
pseudo
flags
:
FragmentFlags
:
:
empty
(
)
debug_id
:
layout_debug
:
:
generate_unique_debug_id
(
)
}
}
pub
fn
debug_id
(
&
self
)
-
>
u16
{
self
.
debug_id
}
pub
fn
transform
(
&
self
size
:
LogicalSize
<
Au
>
info
:
SpecificFragmentInfo
)
-
>
Fragment
{
let
new_border_box
=
LogicalRect
:
:
from_point_size
(
self
.
style
.
writing_mode
self
.
border_box
.
start
size
)
;
let
mut
restyle_damage
=
RestyleDamage
:
:
rebuild_and_reflow
(
)
;
restyle_damage
.
remove
(
RECONSTRUCT_FLOW
)
;
Fragment
{
node
:
self
.
node
style
:
self
.
style
.
clone
(
)
restyle_damage
:
restyle_damage
border_box
:
new_border_box
border_padding
:
self
.
border_padding
margin
:
self
.
margin
specific
:
info
inline_context
:
self
.
inline_context
.
clone
(
)
pseudo
:
self
.
pseudo
.
clone
(
)
flags
:
FragmentFlags
:
:
empty
(
)
debug_id
:
self
.
debug_id
}
}
pub
fn
transform_with_split_info
(
&
self
split
:
&
SplitInfo
text_run
:
Arc
<
TextRun
>
)
-
>
Fragment
{
let
size
=
LogicalSize
:
:
new
(
self
.
style
.
writing_mode
split
.
inline_size
self
.
border_box
.
size
.
block
)
;
let
requires_line_break_afterward_if_wrapping_on_newlines
=
self
.
requires_line_break_afterward_if_wrapping_on_newlines
(
)
;
let
info
=
box
ScannedTextFragmentInfo
:
:
new
(
text_run
split
.
range
size
&
None
requires_line_break_afterward_if_wrapping_on_newlines
)
;
self
.
transform
(
size
SpecificFragmentInfo
:
:
ScannedText
(
info
)
)
}
pub
fn
transform_into_ellipsis
(
&
self
layout_context
:
&
LayoutContext
)
-
>
Fragment
{
let
mut
unscanned_ellipsis_fragments
=
LinkedList
:
:
new
(
)
;
unscanned_ellipsis_fragments
.
push_back
(
self
.
transform
(
self
.
border_box
.
size
SpecificFragmentInfo
:
:
UnscannedText
(
UnscannedTextFragmentInfo
:
:
new
(
"
"
.
to_owned
(
)
None
)
)
)
)
;
let
ellipsis_fragments
=
TextRunScanner
:
:
new
(
)
.
scan_for_runs
(
&
mut
layout_context
.
font_context
(
)
unscanned_ellipsis_fragments
)
;
debug_assert
!
(
ellipsis_fragments
.
len
(
)
=
=
1
)
;
ellipsis_fragments
.
fragments
.
into_iter
(
)
.
next
(
)
.
unwrap
(
)
}
pub
fn
restyle_damage
(
&
self
)
-
>
RestyleDamage
{
self
.
restyle_damage
|
self
.
specific
.
restyle_damage
(
)
}
pub
fn
contains_node
(
&
self
node_address
:
OpaqueNode
)
-
>
bool
{
node_address
=
=
self
.
node
|
|
self
.
inline_context
.
as_ref
(
)
.
map_or
(
false
|
ctx
|
{
ctx
.
contains_node
(
node_address
)
}
)
}
pub
fn
add_inline_context_style
(
&
mut
self
node_info
:
InlineFragmentNodeInfo
)
{
if
self
.
inline_context
.
is_none
(
)
{
self
.
inline_context
=
Some
(
InlineFragmentContext
:
:
new
(
)
)
;
}
self
.
inline_context
.
as_mut
(
)
.
unwrap
(
)
.
nodes
.
push
(
node_info
)
;
}
fn
quantities_included_in_intrinsic_inline_size
(
&
self
)
-
>
QuantitiesIncludedInIntrinsicInlineSizes
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
Canvas
(
_
)
|
SpecificFragmentInfo
:
:
Generic
|
SpecificFragmentInfo
:
:
GeneratedContent
(
_
)
|
SpecificFragmentInfo
:
:
Iframe
(
_
)
|
SpecificFragmentInfo
:
:
Image
(
_
)
|
SpecificFragmentInfo
:
:
InlineAbsolute
(
_
)
|
SpecificFragmentInfo
:
:
Multicol
=
>
{
QuantitiesIncludedInIntrinsicInlineSizes
:
:
all
(
)
}
SpecificFragmentInfo
:
:
Table
|
SpecificFragmentInfo
:
:
TableCell
=
>
{
let
base_quantities
=
INTRINSIC_INLINE_SIZE_INCLUDES_PADDING
|
INTRINSIC_INLINE_SIZE_INCLUDES_SPECIFIED
;
if
self
.
style
.
get_inheritedtable
(
)
.
border_collapse
=
=
border_collapse
:
:
T
:
:
separate
{
base_quantities
|
INTRINSIC_INLINE_SIZE_INCLUDES_BORDER
}
else
{
base_quantities
}
}
SpecificFragmentInfo
:
:
TableWrapper
=
>
{
let
base_quantities
=
INTRINSIC_INLINE_SIZE_INCLUDES_MARGINS
|
INTRINSIC_INLINE_SIZE_INCLUDES_SPECIFIED
;
if
self
.
style
.
get_inheritedtable
(
)
.
border_collapse
=
=
border_collapse
:
:
T
:
:
separate
{
base_quantities
|
INTRINSIC_INLINE_SIZE_INCLUDES_BORDER
}
else
{
base_quantities
}
}
SpecificFragmentInfo
:
:
TableRow
=
>
{
let
base_quantities
=
INTRINSIC_INLINE_SIZE_INCLUDES_SPECIFIED
;
if
self
.
style
.
get_inheritedtable
(
)
.
border_collapse
=
=
border_collapse
:
:
T
:
:
separate
{
base_quantities
|
INTRINSIC_INLINE_SIZE_INCLUDES_BORDER
}
else
{
base_quantities
}
}
SpecificFragmentInfo
:
:
ScannedText
(
_
)
|
SpecificFragmentInfo
:
:
TableColumn
(
_
)
|
SpecificFragmentInfo
:
:
UnscannedText
(
_
)
|
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
_
)
|
SpecificFragmentInfo
:
:
InlineBlock
(
_
)
|
SpecificFragmentInfo
:
:
MulticolColumn
=
>
{
QuantitiesIncludedInIntrinsicInlineSizes
:
:
empty
(
)
}
}
}
pub
fn
surrounding_intrinsic_inline_size
(
&
self
)
-
>
Au
{
let
flags
=
self
.
quantities_included_in_intrinsic_inline_size
(
)
;
let
style
=
self
.
style
(
)
;
let
margin
=
if
flags
.
contains
(
INTRINSIC_INLINE_SIZE_INCLUDES_MARGINS
)
{
let
margin
=
style
.
logical_margin
(
)
;
(
MaybeAuto
:
:
from_style
(
margin
.
inline_start
Au
(
0
)
)
.
specified_or_zero
(
)
+
MaybeAuto
:
:
from_style
(
margin
.
inline_end
Au
(
0
)
)
.
specified_or_zero
(
)
)
}
else
{
Au
(
0
)
}
;
let
padding
=
if
flags
.
contains
(
INTRINSIC_INLINE_SIZE_INCLUDES_PADDING
)
{
let
padding
=
style
.
logical_padding
(
)
;
(
model
:
:
specified
(
padding
.
inline_start
Au
(
0
)
)
+
model
:
:
specified
(
padding
.
inline_end
Au
(
0
)
)
)
}
else
{
Au
(
0
)
}
;
let
border
=
if
flags
.
contains
(
INTRINSIC_INLINE_SIZE_INCLUDES_BORDER
)
{
self
.
border_width
(
)
.
inline_start_end
(
)
}
else
{
Au
(
0
)
}
;
margin
+
padding
+
border
}
fn
style_specified_intrinsic_inline_size
(
&
self
)
-
>
IntrinsicISizesContribution
{
let
flags
=
self
.
quantities_included_in_intrinsic_inline_size
(
)
;
let
style
=
self
.
style
(
)
;
let
specified
=
if
flags
.
contains
(
INTRINSIC_INLINE_SIZE_INCLUDES_SPECIFIED
)
{
max
(
model
:
:
specified
(
style
.
min_inline_size
(
)
Au
(
0
)
)
MaybeAuto
:
:
from_style
(
style
.
content_inline_size
(
)
Au
(
0
)
)
.
specified_or_zero
(
)
)
}
else
{
Au
(
0
)
}
;
let
surrounding_inline_size
=
self
.
surrounding_intrinsic_inline_size
(
)
;
IntrinsicISizesContribution
{
content_intrinsic_sizes
:
IntrinsicISizes
{
minimum_inline_size
:
specified
preferred_inline_size
:
specified
}
surrounding_size
:
surrounding_inline_size
}
}
pub
fn
calculate_line_height
(
&
self
layout_context
:
&
LayoutContext
)
-
>
Au
{
let
font_style
=
self
.
style
.
get_font_arc
(
)
;
let
font_metrics
=
text
:
:
font_metrics_for_style
(
&
mut
layout_context
.
font_context
(
)
font_style
)
;
text
:
:
line_height_from_style
(
&
*
self
.
style
&
font_metrics
)
}
#
[
inline
]
fn
border_width
(
&
self
)
-
>
LogicalMargin
<
Au
>
{
let
style_border_width
=
match
self
.
specific
{
SpecificFragmentInfo
:
:
ScannedText
(
_
)
|
SpecificFragmentInfo
:
:
InlineBlock
(
_
)
=
>
LogicalMargin
:
:
zero
(
self
.
style
.
writing_mode
)
_
=
>
self
.
style
(
)
.
logical_border_width
(
)
}
;
match
self
.
inline_context
{
None
=
>
style_border_width
Some
(
ref
inline_fragment_context
)
=
>
{
inline_fragment_context
.
nodes
.
iter
(
)
.
fold
(
style_border_width
|
accumulator
node
|
{
let
mut
this_border_width
=
node
.
style
.
logical_border_width
(
)
;
if
!
node
.
flags
.
contains
(
FIRST_FRAGMENT_OF_ELEMENT
)
{
this_border_width
.
inline_start
=
Au
(
0
)
}
if
!
node
.
flags
.
contains
(
LAST_FRAGMENT_OF_ELEMENT
)
{
this_border_width
.
inline_end
=
Au
(
0
)
}
accumulator
+
this_border_width
}
)
}
}
}
pub
fn
compute_inline_direction_margins
(
&
mut
self
containing_block_inline_size
:
Au
)
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
Table
|
SpecificFragmentInfo
:
:
TableCell
|
SpecificFragmentInfo
:
:
TableRow
|
SpecificFragmentInfo
:
:
TableColumn
(
_
)
=
>
{
self
.
margin
.
inline_start
=
Au
(
0
)
;
self
.
margin
.
inline_end
=
Au
(
0
)
;
return
}
SpecificFragmentInfo
:
:
InlineBlock
(
_
)
=
>
{
self
.
margin
.
inline_start
=
Au
(
0
)
;
self
.
margin
.
inline_end
=
Au
(
0
)
;
}
_
=
>
{
let
margin
=
self
.
style
(
)
.
logical_margin
(
)
;
self
.
margin
.
inline_start
=
MaybeAuto
:
:
from_style
(
margin
.
inline_start
containing_block_inline_size
)
.
specified_or_zero
(
)
;
self
.
margin
.
inline_end
=
MaybeAuto
:
:
from_style
(
margin
.
inline_end
containing_block_inline_size
)
.
specified_or_zero
(
)
;
}
}
if
let
Some
(
ref
inline_context
)
=
self
.
inline_context
{
for
node
in
&
inline_context
.
nodes
{
let
margin
=
node
.
style
.
logical_margin
(
)
;
let
this_inline_start_margin
=
if
!
node
.
flags
.
contains
(
FIRST_FRAGMENT_OF_ELEMENT
)
{
Au
(
0
)
}
else
{
MaybeAuto
:
:
from_style
(
margin
.
inline_start
containing_block_inline_size
)
.
specified_or_zero
(
)
}
;
let
this_inline_end_margin
=
if
!
node
.
flags
.
contains
(
LAST_FRAGMENT_OF_ELEMENT
)
{
Au
(
0
)
}
else
{
MaybeAuto
:
:
from_style
(
margin
.
inline_end
containing_block_inline_size
)
.
specified_or_zero
(
)
}
;
self
.
margin
.
inline_start
=
self
.
margin
.
inline_start
+
this_inline_start_margin
;
self
.
margin
.
inline_end
=
self
.
margin
.
inline_end
+
this_inline_end_margin
;
}
}
}
pub
fn
compute_block_direction_margins
(
&
mut
self
containing_block_inline_size
:
Au
)
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
Table
|
SpecificFragmentInfo
:
:
TableCell
|
SpecificFragmentInfo
:
:
TableRow
|
SpecificFragmentInfo
:
:
TableColumn
(
_
)
=
>
{
self
.
margin
.
block_start
=
Au
(
0
)
;
self
.
margin
.
block_end
=
Au
(
0
)
}
_
=
>
{
let
margin
=
self
.
style
(
)
.
logical_margin
(
)
;
self
.
margin
.
block_start
=
MaybeAuto
:
:
from_style
(
margin
.
block_start
containing_block_inline_size
)
.
specified_or_zero
(
)
;
self
.
margin
.
block_end
=
MaybeAuto
:
:
from_style
(
margin
.
block_end
containing_block_inline_size
)
.
specified_or_zero
(
)
;
}
}
}
pub
fn
compute_border_and_padding
(
&
mut
self
containing_block_inline_size
:
Au
border_collapse
:
border_collapse
:
:
T
)
{
let
border
=
match
border_collapse
{
border_collapse
:
:
T
:
:
separate
=
>
self
.
border_width
(
)
border_collapse
:
:
T
:
:
collapse
=
>
LogicalMargin
:
:
zero
(
self
.
style
.
writing_mode
)
}
;
let
padding_from_style
=
match
self
.
specific
{
SpecificFragmentInfo
:
:
TableColumn
(
_
)
|
SpecificFragmentInfo
:
:
TableRow
|
SpecificFragmentInfo
:
:
TableWrapper
|
SpecificFragmentInfo
:
:
InlineBlock
(
_
)
=
>
LogicalMargin
:
:
zero
(
self
.
style
.
writing_mode
)
_
=
>
model
:
:
padding_from_style
(
self
.
style
(
)
containing_block_inline_size
)
}
;
let
padding_from_inline_fragment_context
=
match
(
&
self
.
specific
&
self
.
inline_context
)
{
(
_
&
None
)
|
(
&
SpecificFragmentInfo
:
:
TableColumn
(
_
)
_
)
|
(
&
SpecificFragmentInfo
:
:
TableRow
_
)
|
(
&
SpecificFragmentInfo
:
:
TableWrapper
_
)
=
>
{
LogicalMargin
:
:
zero
(
self
.
style
.
writing_mode
)
}
(
_
&
Some
(
ref
inline_fragment_context
)
)
=
>
{
let
zero_padding
=
LogicalMargin
:
:
zero
(
self
.
style
.
writing_mode
)
;
inline_fragment_context
.
nodes
.
iter
(
)
.
fold
(
zero_padding
|
accumulator
node
|
{
let
mut
padding
=
model
:
:
padding_from_style
(
&
*
node
.
style
Au
(
0
)
)
;
if
!
node
.
flags
.
contains
(
FIRST_FRAGMENT_OF_ELEMENT
)
{
padding
.
inline_start
=
Au
(
0
)
}
if
!
node
.
flags
.
contains
(
LAST_FRAGMENT_OF_ELEMENT
)
{
padding
.
inline_end
=
Au
(
0
)
}
accumulator
+
padding
}
)
}
}
;
self
.
border_padding
=
border
+
padding_from_style
+
padding_from_inline_fragment_context
}
pub
fn
relative_position
(
&
self
containing_block_size
:
&
LogicalSize
<
Au
>
)
-
>
LogicalSize
<
Au
>
{
fn
from_style
(
style
:
&
ComputedValues
container_size
:
&
LogicalSize
<
Au
>
)
-
>
LogicalSize
<
Au
>
{
let
offsets
=
style
.
logical_position
(
)
;
let
offset_i
=
if
offsets
.
inline_start
!
=
LengthOrPercentageOrAuto
:
:
Auto
{
MaybeAuto
:
:
from_style
(
offsets
.
inline_start
container_size
.
inline
)
.
specified_or_zero
(
)
}
else
{
-
MaybeAuto
:
:
from_style
(
offsets
.
inline_end
container_size
.
inline
)
.
specified_or_zero
(
)
}
;
let
offset_b
=
if
offsets
.
block_start
!
=
LengthOrPercentageOrAuto
:
:
Auto
{
MaybeAuto
:
:
from_style
(
offsets
.
block_start
container_size
.
inline
)
.
specified_or_zero
(
)
}
else
{
-
MaybeAuto
:
:
from_style
(
offsets
.
block_end
container_size
.
inline
)
.
specified_or_zero
(
)
}
;
LogicalSize
:
:
new
(
style
.
writing_mode
offset_i
offset_b
)
}
let
mut
rel_pos
=
if
self
.
style
(
)
.
get_box
(
)
.
position
=
=
position
:
:
T
:
:
relative
{
from_style
(
self
.
style
(
)
containing_block_size
)
}
else
{
LogicalSize
:
:
zero
(
self
.
style
.
writing_mode
)
}
;
if
let
Some
(
ref
inline_fragment_context
)
=
self
.
inline_context
{
for
node
in
&
inline_fragment_context
.
nodes
{
if
node
.
style
.
get_box
(
)
.
position
=
=
position
:
:
T
:
:
relative
{
rel_pos
=
rel_pos
+
from_style
(
&
*
node
.
style
containing_block_size
)
;
}
}
}
rel_pos
}
#
[
inline
(
always
)
]
pub
fn
clear
(
&
self
)
-
>
Option
<
ClearType
>
{
let
style
=
self
.
style
(
)
;
match
style
.
get_box
(
)
.
clear
{
clear
:
:
T
:
:
none
=
>
None
clear
:
:
T
:
:
left
=
>
Some
(
ClearType
:
:
Left
)
clear
:
:
T
:
:
right
=
>
Some
(
ClearType
:
:
Right
)
clear
:
:
T
:
:
both
=
>
Some
(
ClearType
:
:
Both
)
}
}
#
[
inline
(
always
)
]
pub
fn
style
(
&
self
)
-
>
&
ComputedValues
{
&
*
self
.
style
}
pub
fn
white_space
(
&
self
)
-
>
white_space
:
:
T
{
self
.
style
(
)
.
get_inheritedtext
(
)
.
white_space
}
pub
fn
text_decoration
(
&
self
)
-
>
text_decoration
:
:
T
{
self
.
style
(
)
.
get_text
(
)
.
text_decoration
}
pub
fn
inline_start_offset
(
&
self
)
-
>
Au
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
TableWrapper
=
>
self
.
margin
.
inline_start
SpecificFragmentInfo
:
:
Table
|
SpecificFragmentInfo
:
:
TableCell
|
SpecificFragmentInfo
:
:
TableRow
=
>
self
.
border_padding
.
inline_start
SpecificFragmentInfo
:
:
TableColumn
(
_
)
=
>
Au
(
0
)
_
=
>
self
.
margin
.
inline_start
+
self
.
border_padding
.
inline_start
}
}
pub
fn
can_split
(
&
self
)
-
>
bool
{
self
.
is_scanned_text_fragment
(
)
&
&
self
.
white_space
(
)
.
allow_wrap
(
)
}
pub
fn
is_generated_content
(
&
self
)
-
>
bool
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
GeneratedContent
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_scanned_text_fragment
(
&
self
)
-
>
bool
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
ScannedText
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
compute_intrinsic_inline_sizes
(
&
mut
self
)
-
>
IntrinsicISizesContribution
{
let
mut
result
=
self
.
style_specified_intrinsic_inline_size
(
)
;
match
self
.
specific
{
SpecificFragmentInfo
:
:
Generic
|
SpecificFragmentInfo
:
:
GeneratedContent
(
_
)
|
SpecificFragmentInfo
:
:
Iframe
(
_
)
|
SpecificFragmentInfo
:
:
Table
|
SpecificFragmentInfo
:
:
TableCell
|
SpecificFragmentInfo
:
:
TableColumn
(
_
)
|
SpecificFragmentInfo
:
:
TableRow
|
SpecificFragmentInfo
:
:
TableWrapper
|
SpecificFragmentInfo
:
:
Multicol
|
SpecificFragmentInfo
:
:
MulticolColumn
|
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
_
)
=
>
{
}
SpecificFragmentInfo
:
:
InlineBlock
(
ref
info
)
=
>
{
let
block_flow
=
info
.
flow_ref
.
as_block
(
)
;
result
.
union_block
(
&
block_flow
.
base
.
intrinsic_inline_sizes
)
}
SpecificFragmentInfo
:
:
InlineAbsolute
(
ref
info
)
=
>
{
let
block_flow
=
info
.
flow_ref
.
as_block
(
)
;
result
.
union_block
(
&
block_flow
.
base
.
intrinsic_inline_sizes
)
}
SpecificFragmentInfo
:
:
Image
(
ref
mut
image_fragment_info
)
=
>
{
let
image_inline_size
=
match
self
.
style
.
content_inline_size
(
)
{
LengthOrPercentageOrAuto
:
:
Auto
|
LengthOrPercentageOrAuto
:
:
Percentage
(
_
)
=
>
{
image_fragment_info
.
image_inline_size
(
)
}
LengthOrPercentageOrAuto
:
:
Length
(
length
)
=
>
length
LengthOrPercentageOrAuto
:
:
Calc
(
calc
)
=
>
calc
.
length
(
)
}
;
result
.
union_block
(
&
IntrinsicISizes
{
minimum_inline_size
:
image_inline_size
preferred_inline_size
:
image_inline_size
}
)
;
}
SpecificFragmentInfo
:
:
Canvas
(
ref
mut
canvas_fragment_info
)
=
>
{
let
canvas_inline_size
=
match
self
.
style
.
content_inline_size
(
)
{
LengthOrPercentageOrAuto
:
:
Auto
|
LengthOrPercentageOrAuto
:
:
Percentage
(
_
)
=
>
{
canvas_fragment_info
.
canvas_inline_size
(
)
}
LengthOrPercentageOrAuto
:
:
Length
(
length
)
=
>
length
LengthOrPercentageOrAuto
:
:
Calc
(
calc
)
=
>
calc
.
length
(
)
}
;
result
.
union_block
(
&
IntrinsicISizes
{
minimum_inline_size
:
canvas_inline_size
preferred_inline_size
:
canvas_inline_size
}
)
;
}
SpecificFragmentInfo
:
:
ScannedText
(
ref
text_fragment_info
)
=
>
{
let
range
=
&
text_fragment_info
.
range
;
let
max_line_inline_size
=
text_fragment_info
.
run
.
metrics_for_range
(
range
)
.
advance_width
;
let
min_line_inline_size
=
if
self
.
white_space
(
)
.
allow_wrap
(
)
{
text_fragment_info
.
run
.
min_width_for_range
(
range
)
}
else
{
max_line_inline_size
}
;
result
.
union_block
(
&
IntrinsicISizes
{
minimum_inline_size
:
min_line_inline_size
preferred_inline_size
:
max_line_inline_size
}
)
}
SpecificFragmentInfo
:
:
UnscannedText
(
.
.
)
=
>
{
panic
!
(
"
Unscanned
text
fragments
should
have
been
scanned
by
now
!
"
)
}
}
;
if
self
.
is_primary_fragment
(
)
{
if
let
Some
(
ref
context
)
=
self
.
inline_context
{
for
node
in
&
context
.
nodes
{
let
mut
border_width
=
node
.
style
.
logical_border_width
(
)
;
let
mut
padding
=
model
:
:
padding_from_style
(
&
*
node
.
style
Au
(
0
)
)
;
let
mut
margin
=
model
:
:
specified_margin_from_style
(
&
*
node
.
style
)
;
if
!
node
.
flags
.
contains
(
FIRST_FRAGMENT_OF_ELEMENT
)
{
border_width
.
inline_start
=
Au
(
0
)
;
padding
.
inline_start
=
Au
(
0
)
;
margin
.
inline_start
=
Au
(
0
)
;
}
if
!
node
.
flags
.
contains
(
LAST_FRAGMENT_OF_ELEMENT
)
{
border_width
.
inline_end
=
Au
(
0
)
;
padding
.
inline_end
=
Au
(
0
)
;
margin
.
inline_end
=
Au
(
0
)
;
}
result
.
surrounding_size
=
result
.
surrounding_size
+
border_width
.
inline_start_end
(
)
+
padding
.
inline_start_end
(
)
+
margin
.
inline_start_end
(
)
;
}
}
}
result
}
pub
fn
content_inline_size
(
&
self
)
-
>
Au
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
Generic
|
SpecificFragmentInfo
:
:
GeneratedContent
(
_
)
|
SpecificFragmentInfo
:
:
Iframe
(
_
)
|
SpecificFragmentInfo
:
:
Table
|
SpecificFragmentInfo
:
:
TableCell
|
SpecificFragmentInfo
:
:
TableRow
|
SpecificFragmentInfo
:
:
TableWrapper
|
SpecificFragmentInfo
:
:
Multicol
|
SpecificFragmentInfo
:
:
MulticolColumn
|
SpecificFragmentInfo
:
:
InlineBlock
(
_
)
|
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
_
)
|
SpecificFragmentInfo
:
:
InlineAbsolute
(
_
)
=
>
Au
(
0
)
SpecificFragmentInfo
:
:
Canvas
(
ref
canvas_fragment_info
)
=
>
{
canvas_fragment_info
.
replaced_image_fragment_info
.
computed_inline_size
(
)
}
SpecificFragmentInfo
:
:
Image
(
ref
image_fragment_info
)
=
>
{
image_fragment_info
.
replaced_image_fragment_info
.
computed_inline_size
(
)
}
SpecificFragmentInfo
:
:
ScannedText
(
ref
text_fragment_info
)
=
>
{
let
(
range
run
)
=
(
&
text_fragment_info
.
range
&
text_fragment_info
.
run
)
;
let
text_bounds
=
run
.
metrics_for_range
(
range
)
.
bounding_box
;
text_bounds
.
size
.
width
}
SpecificFragmentInfo
:
:
TableColumn
(
_
)
=
>
{
panic
!
(
"
Table
column
fragments
do
not
have
inline_size
"
)
}
SpecificFragmentInfo
:
:
UnscannedText
(
_
)
=
>
{
panic
!
(
"
Unscanned
text
fragments
should
have
been
scanned
by
now
!
"
)
}
}
}
#
[
inline
]
pub
fn
content_box
(
&
self
)
-
>
LogicalRect
<
Au
>
{
self
.
border_box
-
self
.
border_padding
}
pub
fn
calculate_split_position
(
&
self
max_inline_size
:
Au
starts_line
:
bool
)
-
>
Option
<
SplitResult
>
{
let
text_fragment_info
=
if
let
SpecificFragmentInfo
:
:
ScannedText
(
ref
text_fragment_info
)
=
self
.
specific
{
text_fragment_info
}
else
{
return
None
}
;
let
mut
flags
=
SplitOptions
:
:
empty
(
)
;
if
starts_line
{
flags
.
insert
(
STARTS_LINE
)
;
if
self
.
style
(
)
.
get_inheritedtext
(
)
.
overflow_wrap
=
=
overflow_wrap
:
:
T
:
:
break_word
{
flags
.
insert
(
RETRY_AT_CHARACTER_BOUNDARIES
)
}
}
match
self
.
style
(
)
.
get_inheritedtext
(
)
.
word_break
{
word_break
:
:
T
:
:
normal
=
>
{
let
natural_word_breaking_strategy
=
text_fragment_info
.
run
.
natural_word_slices_in_range
(
&
text_fragment_info
.
range
)
;
self
.
calculate_split_position_using_breaking_strategy
(
natural_word_breaking_strategy
max_inline_size
flags
)
}
word_break
:
:
T
:
:
break_all
=
>
{
let
character_breaking_strategy
=
text_fragment_info
.
run
.
character_slices_in_range
(
&
text_fragment_info
.
range
)
;
flags
.
remove
(
RETRY_AT_CHARACTER_BOUNDARIES
)
;
self
.
calculate_split_position_using_breaking_strategy
(
character_breaking_strategy
max_inline_size
flags
)
}
}
}
pub
fn
truncate_to_inline_size
(
&
self
max_inline_size
:
Au
)
-
>
Option
<
TruncationResult
>
{
let
text_fragment_info
=
if
let
SpecificFragmentInfo
:
:
ScannedText
(
ref
text_fragment_info
)
=
self
.
specific
{
text_fragment_info
}
else
{
return
None
}
;
let
character_breaking_strategy
=
text_fragment_info
.
run
.
character_slices_in_range
(
&
text_fragment_info
.
range
)
;
match
self
.
calculate_split_position_using_breaking_strategy
(
character_breaking_strategy
max_inline_size
SplitOptions
:
:
empty
(
)
)
{
None
=
>
None
Some
(
split_info
)
=
>
{
match
split_info
.
inline_start
{
None
=
>
None
Some
(
split
)
=
>
{
Some
(
TruncationResult
{
split
:
split
text_run
:
split_info
.
text_run
.
clone
(
)
}
)
}
}
}
}
}
fn
calculate_split_position_using_breaking_strategy
<
'
a
I
>
(
&
self
slice_iterator
:
I
max_inline_size
:
Au
flags
:
SplitOptions
)
-
>
Option
<
SplitResult
>
where
I
:
Iterator
<
Item
=
TextRunSlice
<
'
a
>
>
{
let
text_fragment_info
=
if
let
SpecificFragmentInfo
:
:
ScannedText
(
ref
text_fragment_info
)
=
self
.
specific
{
text_fragment_info
}
else
{
return
None
}
;
let
mut
remaining_inline_size
=
max_inline_size
;
let
mut
inline_start_range
=
Range
:
:
new
(
text_fragment_info
.
range
.
begin
(
)
CharIndex
(
0
)
)
;
let
mut
inline_end_range
=
None
;
let
mut
overflowing
=
false
;
debug
!
(
"
calculate_split_position_using_breaking_strategy
:
splitting
text
fragment
\
(
strlen
=
{
}
range
=
{
:
?
}
max_inline_size
=
{
:
?
}
)
"
text_fragment_info
.
run
.
text
.
len
(
)
text_fragment_info
.
range
max_inline_size
)
;
for
slice
in
slice_iterator
{
debug
!
(
"
calculate_split_position_using_breaking_strategy
:
considering
slice
\
(
offset
=
{
:
?
}
slice
range
=
{
:
?
}
remaining_inline_size
=
{
:
?
}
)
"
slice
.
offset
slice
.
range
remaining_inline_size
)
;
let
metrics
=
text_fragment_info
.
run
.
metrics_for_slice
(
slice
.
glyphs
&
slice
.
range
)
;
let
advance
=
metrics
.
advance_width
;
if
advance
<
=
remaining_inline_size
|
|
slice
.
glyphs
.
is_whitespace
(
)
{
debug
!
(
"
calculate_split_position_using_breaking_strategy
:
enlarging
span
"
)
;
remaining_inline_size
=
remaining_inline_size
-
advance
;
inline_start_range
.
extend_by
(
slice
.
range
.
length
(
)
)
;
continue
}
let
mut
remaining_range
=
slice
.
text_run_range
(
)
;
let
split_is_empty
=
inline_start_range
.
is_empty
(
)
&
&
!
self
.
requires_line_break_afterward_if_wrapping_on_newlines
(
)
;
if
split_is_empty
{
overflowing
=
true
;
inline_start_range
=
slice
.
text_run_range
(
)
;
remaining_range
=
Range
:
:
new
(
slice
.
text_run_range
(
)
.
end
(
)
CharIndex
(
0
)
)
;
remaining_range
.
extend_to
(
text_fragment_info
.
range
.
end
(
)
)
;
}
let
slice_begin
=
remaining_range
.
begin
(
)
;
if
slice_begin
<
text_fragment_info
.
range
.
end
(
)
{
let
mut
inline_end
=
remaining_range
;
inline_end
.
extend_to
(
text_fragment_info
.
range
.
end
(
)
)
;
inline_end_range
=
Some
(
inline_end
)
;
debug
!
(
"
calculate_split_position
:
splitting
remainder
with
inline
-
end
range
=
{
:
?
}
"
inline_end
)
;
}
if
split_is_empty
|
|
overflowing
{
if
flags
.
contains
(
RETRY_AT_CHARACTER_BOUNDARIES
)
{
let
character_breaking_strategy
=
text_fragment_info
.
run
.
character_slices_in_range
(
&
text_fragment_info
.
range
)
;
let
mut
flags
=
flags
;
flags
.
remove
(
RETRY_AT_CHARACTER_BOUNDARIES
)
;
return
self
.
calculate_split_position_using_breaking_strategy
(
character_breaking_strategy
max_inline_size
flags
)
}
if
!
flags
.
contains
(
STARTS_LINE
)
{
return
None
}
}
break
}
let
split_is_empty
=
inline_start_range
.
is_empty
(
)
&
&
!
self
.
requires_line_break_afterward_if_wrapping_on_newlines
(
)
;
let
inline_start
=
if
!
split_is_empty
{
Some
(
SplitInfo
:
:
new
(
inline_start_range
&
*
*
text_fragment_info
)
)
}
else
{
None
}
;
let
inline_end
=
inline_end_range
.
map
(
|
inline_end_range
|
{
SplitInfo
:
:
new
(
inline_end_range
&
*
*
text_fragment_info
)
}
)
;
Some
(
SplitResult
{
inline_start
:
inline_start
inline_end
:
inline_end
text_run
:
text_fragment_info
.
run
.
clone
(
)
}
)
}
pub
fn
merge_with
(
&
mut
self
next_fragment
:
Fragment
)
{
match
(
&
mut
self
.
specific
&
next_fragment
.
specific
)
{
(
&
mut
SpecificFragmentInfo
:
:
ScannedText
(
ref
mut
this_info
)
&
SpecificFragmentInfo
:
:
ScannedText
(
ref
other_info
)
)
=
>
{
debug_assert
!
(
util
:
:
arc_ptr_eq
(
&
this_info
.
run
&
other_info
.
run
)
)
;
this_info
.
range
.
extend_to
(
other_info
.
range_end_including_stripped_whitespace
)
;
this_info
.
content_size
.
inline
=
this_info
.
run
.
metrics_for_range
(
&
this_info
.
range
)
.
advance_width
;
this_info
.
requires_line_break_afterward_if_wrapping_on_newlines
=
this_info
.
requires_line_break_afterward_if_wrapping_on_newlines
|
|
other_info
.
requires_line_break_afterward_if_wrapping_on_newlines
;
self
.
border_padding
.
inline_end
=
next_fragment
.
border_padding
.
inline_end
;
self
.
border_box
.
size
.
inline
=
this_info
.
content_size
.
inline
+
self
.
border_padding
.
inline_start_end
(
)
;
}
_
=
>
panic
!
(
"
Can
only
merge
two
scanned
-
text
fragments
!
"
)
}
self
.
meld_with_next_inline_fragment
(
&
next_fragment
)
;
}
pub
fn
assign_replaced_inline_size_if_necessary
(
&
mut
self
container_inline_size
:
Au
)
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
Generic
|
SpecificFragmentInfo
:
:
GeneratedContent
(
_
)
|
SpecificFragmentInfo
:
:
Table
|
SpecificFragmentInfo
:
:
TableCell
|
SpecificFragmentInfo
:
:
TableRow
|
SpecificFragmentInfo
:
:
TableWrapper
|
SpecificFragmentInfo
:
:
Multicol
|
SpecificFragmentInfo
:
:
MulticolColumn
=
>
return
SpecificFragmentInfo
:
:
TableColumn
(
_
)
=
>
{
panic
!
(
"
Table
column
fragments
do
not
have
inline
size
"
)
}
SpecificFragmentInfo
:
:
UnscannedText
(
_
)
=
>
{
panic
!
(
"
Unscanned
text
fragments
should
have
been
scanned
by
now
!
"
)
}
SpecificFragmentInfo
:
:
Canvas
(
_
)
|
SpecificFragmentInfo
:
:
Image
(
_
)
|
SpecificFragmentInfo
:
:
Iframe
(
_
)
|
SpecificFragmentInfo
:
:
InlineBlock
(
_
)
|
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
_
)
|
SpecificFragmentInfo
:
:
InlineAbsolute
(
_
)
|
SpecificFragmentInfo
:
:
ScannedText
(
_
)
=
>
{
}
}
;
let
style
=
&
*
self
.
style
;
let
noncontent_inline_size
=
self
.
border_padding
.
inline_start_end
(
)
;
match
self
.
specific
{
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
ref
mut
info
)
=
>
{
let
block_flow
=
flow_ref
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
.
as_mut_block
(
)
;
block_flow
.
base
.
position
.
size
.
inline
=
block_flow
.
base
.
intrinsic_inline_sizes
.
preferred_inline_size
;
self
.
border_box
.
size
.
inline
=
Au
(
0
)
;
}
SpecificFragmentInfo
:
:
InlineBlock
(
ref
mut
info
)
=
>
{
let
block_flow
=
flow_ref
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
.
as_mut_block
(
)
;
self
.
border_box
.
size
.
inline
=
max
(
block_flow
.
base
.
intrinsic_inline_sizes
.
minimum_inline_size
block_flow
.
base
.
intrinsic_inline_sizes
.
preferred_inline_size
)
;
block_flow
.
base
.
block_container_inline_size
=
self
.
border_box
.
size
.
inline
;
block_flow
.
base
.
block_container_writing_mode
=
self
.
style
.
writing_mode
;
}
SpecificFragmentInfo
:
:
InlineAbsolute
(
ref
mut
info
)
=
>
{
let
block_flow
=
flow_ref
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
.
as_mut_block
(
)
;
self
.
border_box
.
size
.
inline
=
max
(
block_flow
.
base
.
intrinsic_inline_sizes
.
minimum_inline_size
block_flow
.
base
.
intrinsic_inline_sizes
.
preferred_inline_size
)
;
block_flow
.
base
.
block_container_inline_size
=
self
.
border_box
.
size
.
inline
;
block_flow
.
base
.
block_container_writing_mode
=
self
.
style
.
writing_mode
;
}
SpecificFragmentInfo
:
:
ScannedText
(
ref
info
)
=
>
{
self
.
border_box
.
size
.
inline
=
info
.
content_size
.
inline
+
noncontent_inline_size
}
SpecificFragmentInfo
:
:
Image
(
ref
mut
image_fragment_info
)
=
>
{
let
fragment_inline_size
=
image_fragment_info
.
image_inline_size
(
)
;
let
fragment_block_size
=
image_fragment_info
.
image_block_size
(
)
;
self
.
border_box
.
size
.
inline
=
image_fragment_info
.
replaced_image_fragment_info
.
calculate_replaced_inline_size
(
style
noncontent_inline_size
container_inline_size
fragment_inline_size
fragment_block_size
)
;
}
SpecificFragmentInfo
:
:
Canvas
(
ref
mut
canvas_fragment_info
)
=
>
{
let
fragment_inline_size
=
canvas_fragment_info
.
canvas_inline_size
(
)
;
let
fragment_block_size
=
canvas_fragment_info
.
canvas_block_size
(
)
;
self
.
border_box
.
size
.
inline
=
canvas_fragment_info
.
replaced_image_fragment_info
.
calculate_replaced_inline_size
(
style
noncontent_inline_size
container_inline_size
fragment_inline_size
fragment_block_size
)
;
}
SpecificFragmentInfo
:
:
Iframe
(
ref
iframe_fragment_info
)
=
>
{
self
.
border_box
.
size
.
inline
=
iframe_fragment_info
.
calculate_replaced_inline_size
(
style
container_inline_size
)
+
noncontent_inline_size
;
}
_
=
>
panic
!
(
"
this
case
should
have
been
handled
above
"
)
}
}
pub
fn
assign_replaced_block_size_if_necessary
(
&
mut
self
containing_block_block_size
:
Option
<
Au
>
)
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
Generic
|
SpecificFragmentInfo
:
:
GeneratedContent
(
_
)
|
SpecificFragmentInfo
:
:
Table
|
SpecificFragmentInfo
:
:
TableCell
|
SpecificFragmentInfo
:
:
TableRow
|
SpecificFragmentInfo
:
:
TableWrapper
|
SpecificFragmentInfo
:
:
Multicol
|
SpecificFragmentInfo
:
:
MulticolColumn
=
>
return
SpecificFragmentInfo
:
:
TableColumn
(
_
)
=
>
{
panic
!
(
"
Table
column
fragments
do
not
have
block
size
"
)
}
SpecificFragmentInfo
:
:
UnscannedText
(
_
)
=
>
{
panic
!
(
"
Unscanned
text
fragments
should
have
been
scanned
by
now
!
"
)
}
SpecificFragmentInfo
:
:
Canvas
(
_
)
|
SpecificFragmentInfo
:
:
Iframe
(
_
)
|
SpecificFragmentInfo
:
:
Image
(
_
)
|
SpecificFragmentInfo
:
:
InlineBlock
(
_
)
|
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
_
)
|
SpecificFragmentInfo
:
:
InlineAbsolute
(
_
)
|
SpecificFragmentInfo
:
:
ScannedText
(
_
)
=
>
{
}
}
let
style
=
&
*
self
.
style
;
let
noncontent_block_size
=
self
.
border_padding
.
block_start_end
(
)
;
match
self
.
specific
{
SpecificFragmentInfo
:
:
Image
(
ref
mut
image_fragment_info
)
=
>
{
let
fragment_inline_size
=
image_fragment_info
.
image_inline_size
(
)
;
let
fragment_block_size
=
image_fragment_info
.
image_block_size
(
)
;
self
.
border_box
.
size
.
block
=
image_fragment_info
.
replaced_image_fragment_info
.
calculate_replaced_block_size
(
style
noncontent_block_size
containing_block_block_size
fragment_inline_size
fragment_block_size
)
;
}
SpecificFragmentInfo
:
:
Canvas
(
ref
mut
canvas_fragment_info
)
=
>
{
let
fragment_inline_size
=
canvas_fragment_info
.
canvas_inline_size
(
)
;
let
fragment_block_size
=
canvas_fragment_info
.
canvas_block_size
(
)
;
self
.
border_box
.
size
.
block
=
canvas_fragment_info
.
replaced_image_fragment_info
.
calculate_replaced_block_size
(
style
noncontent_block_size
containing_block_block_size
fragment_inline_size
fragment_block_size
)
;
}
SpecificFragmentInfo
:
:
ScannedText
(
ref
info
)
=
>
{
self
.
border_box
.
size
.
block
=
info
.
content_size
.
block
+
noncontent_block_size
}
SpecificFragmentInfo
:
:
InlineBlock
(
ref
mut
info
)
=
>
{
let
block_flow
=
flow_ref
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
.
as_block
(
)
;
self
.
border_box
.
size
.
block
=
block_flow
.
base
.
position
.
size
.
block
+
block_flow
.
fragment
.
margin
.
block_start_end
(
)
}
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
ref
mut
info
)
=
>
{
let
block_flow
=
flow_ref
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
.
as_block
(
)
;
self
.
border_box
.
size
.
block
=
block_flow
.
base
.
position
.
size
.
block
;
}
SpecificFragmentInfo
:
:
InlineAbsolute
(
ref
mut
info
)
=
>
{
let
block_flow
=
flow_ref
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
.
as_block
(
)
;
self
.
border_box
.
size
.
block
=
block_flow
.
base
.
position
.
size
.
block
+
block_flow
.
fragment
.
margin
.
block_start_end
(
)
}
SpecificFragmentInfo
:
:
Iframe
(
ref
info
)
=
>
{
self
.
border_box
.
size
.
block
=
info
.
calculate_replaced_block_size
(
style
containing_block_block_size
)
+
noncontent_block_size
;
}
_
=
>
panic
!
(
"
should
have
been
handled
above
"
)
}
}
pub
fn
inline_metrics
(
&
self
layout_context
:
&
LayoutContext
)
-
>
InlineMetrics
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
Image
(
ref
image_fragment_info
)
=
>
{
let
computed_block_size
=
image_fragment_info
.
replaced_image_fragment_info
.
computed_block_size
(
)
;
InlineMetrics
{
block_size_above_baseline
:
computed_block_size
+
self
.
border_padding
.
block_start
depth_below_baseline
:
self
.
border_padding
.
block_end
ascent
:
computed_block_size
+
self
.
border_padding
.
block_start
}
}
SpecificFragmentInfo
:
:
Canvas
(
ref
canvas_fragment_info
)
=
>
{
let
computed_block_size
=
canvas_fragment_info
.
replaced_image_fragment_info
.
computed_block_size
(
)
;
InlineMetrics
{
block_size_above_baseline
:
computed_block_size
+
self
.
border_padding
.
block_start
depth_below_baseline
:
self
.
border_padding
.
block_end
ascent
:
computed_block_size
+
self
.
border_padding
.
block_start
}
}
SpecificFragmentInfo
:
:
ScannedText
(
ref
text_fragment
)
=
>
{
let
line_height
=
self
.
calculate_line_height
(
layout_context
)
;
let
font_derived_metrics
=
InlineMetrics
:
:
from_font_metrics
(
&
text_fragment
.
run
.
font_metrics
line_height
)
;
InlineMetrics
{
block_size_above_baseline
:
font_derived_metrics
.
block_size_above_baseline
+
self
.
border_padding
.
block_start
depth_below_baseline
:
font_derived_metrics
.
depth_below_baseline
+
self
.
border_padding
.
block_end
ascent
:
font_derived_metrics
.
ascent
+
self
.
border_padding
.
block_start
}
}
SpecificFragmentInfo
:
:
InlineBlock
(
ref
info
)
=
>
{
let
block_flow
=
info
.
flow_ref
.
as_block
(
)
;
let
font_style
=
self
.
style
.
get_font_arc
(
)
;
let
font_metrics
=
text
:
:
font_metrics_for_style
(
&
mut
layout_context
.
font_context
(
)
font_style
)
;
InlineMetrics
:
:
from_block_height
(
&
font_metrics
block_flow
.
base
.
position
.
size
.
block
block_flow
.
fragment
.
margin
.
block_start
block_flow
.
fragment
.
margin
.
block_end
)
}
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
_
)
|
SpecificFragmentInfo
:
:
InlineAbsolute
(
_
)
=
>
{
InlineMetrics
{
block_size_above_baseline
:
Au
(
0
)
depth_below_baseline
:
Au
(
0
)
ascent
:
Au
(
0
)
}
}
_
=
>
{
InlineMetrics
{
block_size_above_baseline
:
self
.
border_box
.
size
.
block
depth_below_baseline
:
Au
(
0
)
ascent
:
self
.
border_box
.
size
.
block
}
}
}
}
pub
fn
is_hypothetical
(
&
self
)
-
>
bool
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
can_merge_with_fragment
(
&
self
other
:
&
Fragment
)
-
>
bool
{
match
(
&
self
.
specific
&
other
.
specific
)
{
(
&
SpecificFragmentInfo
:
:
UnscannedText
(
ref
first_unscanned_text
)
&
SpecificFragmentInfo
:
:
UnscannedText
(
_
)
)
=
>
{
if
self
.
style
(
)
.
get_font
(
)
!
=
other
.
style
(
)
.
get_font
(
)
|
|
self
.
text_decoration
(
)
!
=
other
.
text_decoration
(
)
|
|
self
.
white_space
(
)
!
=
other
.
white_space
(
)
{
return
false
}
let
length
=
first_unscanned_text
.
text
.
len
(
)
;
if
length
!
=
0
&
&
first_unscanned_text
.
text
.
char_at_reverse
(
length
)
=
=
'
\
n
'
{
return
false
}
if
let
Some
(
ref
inline_context
)
=
self
.
inline_context
{
for
inline_context_node
in
inline_context
.
nodes
.
iter
(
)
{
if
!
inline_context_node
.
flags
.
contains
(
LAST_FRAGMENT_OF_ELEMENT
)
{
continue
}
if
inline_context_node
.
style
.
logical_margin
(
)
.
inline_end
!
=
LengthOrPercentageOrAuto
:
:
Length
(
Au
(
0
)
)
{
return
false
}
if
inline_context_node
.
style
.
logical_padding
(
)
.
inline_end
!
=
LengthOrPercentage
:
:
Length
(
Au
(
0
)
)
{
return
false
}
if
inline_context_node
.
style
.
logical_border_width
(
)
.
inline_end
!
=
Au
(
0
)
{
return
false
}
}
}
if
let
Some
(
ref
inline_context
)
=
other
.
inline_context
{
for
inline_context_node
in
inline_context
.
nodes
.
iter
(
)
{
if
!
inline_context_node
.
flags
.
contains
(
FIRST_FRAGMENT_OF_ELEMENT
)
{
continue
}
if
inline_context_node
.
style
.
logical_margin
(
)
.
inline_start
!
=
LengthOrPercentageOrAuto
:
:
Length
(
Au
(
0
)
)
{
return
false
}
if
inline_context_node
.
style
.
logical_padding
(
)
.
inline_start
!
=
LengthOrPercentage
:
:
Length
(
Au
(
0
)
)
{
return
false
}
if
inline_context_node
.
style
.
logical_border_width
(
)
.
inline_start
!
=
Au
(
0
)
{
return
false
}
}
}
true
}
_
=
>
false
}
}
pub
fn
is_primary_fragment
(
&
self
)
-
>
bool
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
InlineBlock
(
_
)
|
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
_
)
|
SpecificFragmentInfo
:
:
InlineAbsolute
(
_
)
|
SpecificFragmentInfo
:
:
MulticolColumn
|
SpecificFragmentInfo
:
:
TableWrapper
=
>
false
SpecificFragmentInfo
:
:
Canvas
(
_
)
|
SpecificFragmentInfo
:
:
Generic
|
SpecificFragmentInfo
:
:
GeneratedContent
(
_
)
|
SpecificFragmentInfo
:
:
Iframe
(
_
)
|
SpecificFragmentInfo
:
:
Image
(
_
)
|
SpecificFragmentInfo
:
:
ScannedText
(
_
)
|
SpecificFragmentInfo
:
:
Table
|
SpecificFragmentInfo
:
:
TableCell
|
SpecificFragmentInfo
:
:
TableColumn
(
_
)
|
SpecificFragmentInfo
:
:
TableRow
|
SpecificFragmentInfo
:
:
Multicol
|
SpecificFragmentInfo
:
:
UnscannedText
(
_
)
=
>
true
}
}
pub
fn
update_late_computed_replaced_inline_size_if_necessary
(
&
mut
self
)
{
if
let
SpecificFragmentInfo
:
:
InlineBlock
(
ref
mut
inline_block_info
)
=
self
.
specific
{
let
block_flow
=
flow_ref
:
:
deref_mut
(
&
mut
inline_block_info
.
flow_ref
)
.
as_block
(
)
;
let
margin
=
block_flow
.
fragment
.
style
.
logical_margin
(
)
;
self
.
border_box
.
size
.
inline
=
block_flow
.
fragment
.
border_box
.
size
.
inline
+
MaybeAuto
:
:
from_style
(
margin
.
inline_start
Au
(
0
)
)
.
specified_or_zero
(
)
+
MaybeAuto
:
:
from_style
(
margin
.
inline_end
Au
(
0
)
)
.
specified_or_zero
(
)
}
}
pub
fn
update_late_computed_inline_position_if_necessary
(
&
mut
self
)
{
if
let
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
ref
mut
info
)
=
self
.
specific
{
let
position
=
self
.
border_box
.
start
.
i
;
flow_ref
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
.
update_late_computed_inline_position_if_necessary
(
position
)
}
}
pub
fn
update_late_computed_block_position_if_necessary
(
&
mut
self
)
{
if
let
SpecificFragmentInfo
:
:
InlineAbsoluteHypothetical
(
ref
mut
info
)
=
self
.
specific
{
let
position
=
self
.
border_box
.
start
.
b
;
flow_ref
:
:
deref_mut
(
&
mut
info
.
flow_ref
)
.
update_late_computed_block_position_if_necessary
(
position
)
}
}
pub
fn
repair_style
(
&
mut
self
new_style
:
&
Arc
<
ComputedValues
>
)
{
self
.
style
=
(
*
new_style
)
.
clone
(
)
}
pub
fn
stacking_relative_border_box
(
&
self
stacking_relative_flow_origin
:
&
Point2D
<
Au
>
relative_containing_block_size
:
&
LogicalSize
<
Au
>
relative_containing_block_mode
:
WritingMode
coordinate_system
:
CoordinateSystem
)
-
>
Rect
<
Au
>
{
let
container_size
=
relative_containing_block_size
.
to_physical
(
relative_containing_block_mode
)
;
let
border_box
=
self
.
border_box
.
to_physical
(
self
.
style
.
writing_mode
container_size
)
;
if
coordinate_system
=
=
CoordinateSystem
:
:
Own
&
&
self
.
establishes_stacking_context
(
)
{
return
Rect
:
:
new
(
Point2D
:
:
zero
(
)
border_box
.
size
)
}
let
relative_position
=
self
.
relative_position
(
relative_containing_block_size
)
;
border_box
.
translate_by_size
(
&
relative_position
.
to_physical
(
self
.
style
.
writing_mode
)
)
.
translate
(
stacking_relative_flow_origin
)
}
pub
fn
stacking_relative_content_box
(
&
self
stacking_relative_border_box
:
&
Rect
<
Au
>
)
-
>
Rect
<
Au
>
{
let
border_padding
=
self
.
border_padding
.
to_physical
(
self
.
style
.
writing_mode
)
;
Rect
:
:
new
(
Point2D
:
:
new
(
stacking_relative_border_box
.
origin
.
x
+
border_padding
.
left
stacking_relative_border_box
.
origin
.
y
+
border_padding
.
top
)
Size2D
:
:
new
(
stacking_relative_border_box
.
size
.
width
-
border_padding
.
horizontal
(
)
stacking_relative_border_box
.
size
.
height
-
border_padding
.
vertical
(
)
)
)
}
pub
fn
establishes_stacking_context
(
&
self
)
-
>
bool
{
if
self
.
flags
.
contains
(
HAS_LAYER
)
{
return
true
}
if
self
.
style
(
)
.
get_effects
(
)
.
opacity
!
=
1
.
0
{
return
true
}
if
!
self
.
style
(
)
.
get_effects
(
)
.
filter
.
is_empty
(
)
{
return
true
}
if
self
.
style
(
)
.
get_effects
(
)
.
mix_blend_mode
!
=
mix_blend_mode
:
:
T
:
:
normal
{
return
true
}
if
self
.
style
(
)
.
get_effects
(
)
.
transform
.
0
.
is_some
(
)
{
return
true
}
match
self
.
style
(
)
.
get_used_transform_style
(
)
{
transform_style
:
:
T
:
:
flat
|
transform_style
:
:
T
:
:
preserve_3d
=
>
{
return
true
}
transform_style
:
:
T
:
:
auto
=
>
{
}
}
match
(
self
.
style
(
)
.
get_box
(
)
.
position
self
.
style
(
)
.
get_box
(
)
.
z_index
self
.
style
(
)
.
get_box
(
)
.
overflow_x
self
.
style
(
)
.
get_box
(
)
.
overflow_y
.
0
)
{
(
position
:
:
T
:
:
absolute
z_index
:
:
T
:
:
Auto
overflow_x
:
:
T
:
:
visible
overflow_x
:
:
T
:
:
visible
)
|
(
position
:
:
T
:
:
fixed
z_index
:
:
T
:
:
Auto
overflow_x
:
:
T
:
:
visible
overflow_x
:
:
T
:
:
visible
)
|
(
position
:
:
T
:
:
relative
z_index
:
:
T
:
:
Auto
overflow_x
:
:
T
:
:
visible
overflow_x
:
:
T
:
:
visible
)
=
>
false
(
position
:
:
T
:
:
absolute
_
_
_
)
|
(
position
:
:
T
:
:
fixed
_
_
_
)
|
(
position
:
:
T
:
:
relative
_
_
_
)
=
>
true
(
position
:
:
T
:
:
static_
_
_
_
)
=
>
{
false
}
}
}
pub
fn
effective_z_index
(
&
self
)
-
>
i32
{
match
self
.
style
(
)
.
get_box
(
)
.
position
{
position
:
:
T
:
:
static_
=
>
{
}
_
=
>
return
self
.
style
(
)
.
get_box
(
)
.
z_index
.
number_or_zero
(
)
}
if
self
.
style
(
)
.
get_effects
(
)
.
transform
.
0
.
is_some
(
)
{
return
self
.
style
(
)
.
get_box
(
)
.
z_index
.
number_or_zero
(
)
;
}
match
self
.
style
(
)
.
get_box
(
)
.
display
{
display
:
:
T
:
:
flex
=
>
self
.
style
(
)
.
get_box
(
)
.
z_index
.
number_or_zero
(
)
_
=
>
0
}
}
pub
fn
compute_overflow
(
&
self
flow_size
:
&
Size2D
<
Au
>
relative_containing_block_size
:
&
LogicalSize
<
Au
>
)
-
>
Overflow
{
let
mut
border_box
=
self
.
border_box
.
to_physical
(
self
.
style
.
writing_mode
*
flow_size
)
;
let
relative_position
=
self
.
relative_position
(
relative_containing_block_size
)
;
border_box
=
border_box
.
translate_by_size
(
&
relative_position
.
to_physical
(
self
.
style
.
writing_mode
)
)
;
let
mut
overflow
=
Overflow
:
:
from_rect
(
&
border_box
)
;
for
box_shadow
in
&
self
.
style
(
)
.
get_effects
(
)
.
box_shadow
.
0
{
let
offset
=
Point2D
:
:
new
(
box_shadow
.
offset_x
box_shadow
.
offset_y
)
;
let
inflation
=
box_shadow
.
spread_radius
+
box_shadow
.
blur_radius
*
BLUR_INFLATION_FACTOR
;
overflow
.
paint
=
overflow
.
paint
.
union
(
&
border_box
.
translate
(
&
offset
)
.
inflate
(
inflation
inflation
)
)
}
let
outline_width
=
self
.
style
.
get_outline
(
)
.
outline_width
;
if
outline_width
!
=
Au
(
0
)
{
overflow
.
paint
=
overflow
.
paint
.
union
(
&
border_box
.
inflate
(
outline_width
outline_width
)
)
}
match
self
.
specific
{
SpecificFragmentInfo
:
:
InlineBlock
(
ref
info
)
=
>
{
let
block_flow
=
info
.
flow_ref
.
as_block
(
)
;
overflow
.
union
(
&
flow
:
:
base
(
block_flow
)
.
overflow
)
;
}
SpecificFragmentInfo
:
:
InlineAbsolute
(
ref
info
)
=
>
{
let
block_flow
=
info
.
flow_ref
.
as_block
(
)
;
overflow
.
union
(
&
flow
:
:
base
(
block_flow
)
.
overflow
)
;
}
_
=
>
(
)
}
overflow
}
pub
fn
requires_line_break_afterward_if_wrapping_on_newlines
(
&
self
)
-
>
bool
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
ScannedText
(
ref
scanned_text
)
=
>
{
scanned_text
.
requires_line_break_afterward_if_wrapping_on_newlines
}
_
=
>
false
}
}
pub
fn
strip_leading_whitespace_if_necessary
(
&
mut
self
)
-
>
WhitespaceStrippingResult
{
if
self
.
white_space
(
)
.
preserve_spaces
(
)
{
return
WhitespaceStrippingResult
:
:
RetainFragment
}
match
self
.
specific
{
SpecificFragmentInfo
:
:
ScannedText
(
ref
mut
scanned_text_fragment_info
)
=
>
{
let
mut
leading_whitespace_character_count
=
0
;
{
let
text
=
slice_chars
(
&
*
scanned_text_fragment_info
.
run
.
text
scanned_text_fragment_info
.
range
.
begin
(
)
.
to_usize
(
)
scanned_text_fragment_info
.
range
.
end
(
)
.
to_usize
(
)
)
;
for
character
in
text
.
chars
(
)
{
if
util
:
:
str
:
:
char_is_whitespace
(
character
)
{
leading_whitespace_character_count
+
=
1
}
else
{
break
}
}
}
let
whitespace_range
=
Range
:
:
new
(
scanned_text_fragment_info
.
range
.
begin
(
)
CharIndex
(
leading_whitespace_character_count
)
)
;
let
text_bounds
=
scanned_text_fragment_info
.
run
.
metrics_for_range
(
&
whitespace_range
)
.
bounding_box
;
self
.
border_box
.
size
.
inline
=
self
.
border_box
.
size
.
inline
-
text_bounds
.
size
.
width
;
scanned_text_fragment_info
.
content_size
.
inline
=
scanned_text_fragment_info
.
content_size
.
inline
-
text_bounds
.
size
.
width
;
scanned_text_fragment_info
.
range
.
adjust_by
(
CharIndex
(
leading_whitespace_character_count
)
-
CharIndex
(
leading_whitespace_character_count
)
)
;
WhitespaceStrippingResult
:
:
RetainFragment
}
SpecificFragmentInfo
:
:
UnscannedText
(
ref
mut
unscanned_text_fragment_info
)
=
>
{
let
mut
new_text_string
=
String
:
:
new
(
)
;
let
mut
modified
=
false
;
for
(
i
character
)
in
unscanned_text_fragment_info
.
text
.
char_indices
(
)
{
if
gfx
:
:
text
:
:
util
:
:
is_bidi_control
(
character
)
{
new_text_string
.
push
(
character
)
;
continue
}
if
util
:
:
str
:
:
char_is_whitespace
(
character
)
{
modified
=
true
;
continue
}
new_text_string
.
push_str
(
&
unscanned_text_fragment_info
.
text
[
i
.
.
]
)
;
break
}
if
modified
{
unscanned_text_fragment_info
.
text
=
new_text_string
.
into_boxed_str
(
)
;
}
WhitespaceStrippingResult
:
:
from_unscanned_text_fragment_info
(
&
unscanned_text_fragment_info
)
}
_
=
>
WhitespaceStrippingResult
:
:
RetainFragment
}
}
pub
fn
strip_trailing_whitespace_if_necessary
(
&
mut
self
)
-
>
WhitespaceStrippingResult
{
if
self
.
white_space
(
)
.
preserve_spaces
(
)
{
return
WhitespaceStrippingResult
:
:
RetainFragment
}
match
self
.
specific
{
SpecificFragmentInfo
:
:
ScannedText
(
ref
mut
scanned_text_fragment_info
)
=
>
{
debug
!
(
"
stripping
trailing
whitespace
:
range
=
{
:
?
}
len
=
{
}
"
scanned_text_fragment_info
.
range
scanned_text_fragment_info
.
run
.
text
.
chars
(
)
.
count
(
)
)
;
let
mut
trailing_whitespace_character_count
=
0
;
let
text_bounds
;
{
let
text
=
slice_chars
(
&
*
scanned_text_fragment_info
.
run
.
text
scanned_text_fragment_info
.
range
.
begin
(
)
.
to_usize
(
)
scanned_text_fragment_info
.
range
.
end
(
)
.
to_usize
(
)
)
;
for
ch
in
text
.
chars
(
)
.
rev
(
)
{
if
util
:
:
str
:
:
char_is_whitespace
(
ch
)
{
trailing_whitespace_character_count
+
=
1
}
else
{
break
}
}
let
whitespace_range
=
Range
:
:
new
(
scanned_text_fragment_info
.
range
.
end
(
)
-
CharIndex
(
trailing_whitespace_character_count
)
CharIndex
(
trailing_whitespace_character_count
)
)
;
text_bounds
=
scanned_text_fragment_info
.
run
.
metrics_for_range
(
&
whitespace_range
)
.
bounding_box
;
self
.
border_box
.
size
.
inline
=
self
.
border_box
.
size
.
inline
-
text_bounds
.
size
.
width
;
}
scanned_text_fragment_info
.
content_size
.
inline
=
scanned_text_fragment_info
.
content_size
.
inline
-
text_bounds
.
size
.
width
;
if
trailing_whitespace_character_count
!
=
0
{
scanned_text_fragment_info
.
range
.
extend_by
(
CharIndex
(
-
trailing_whitespace_character_count
)
)
;
}
WhitespaceStrippingResult
:
:
RetainFragment
}
SpecificFragmentInfo
:
:
UnscannedText
(
ref
mut
unscanned_text_fragment_info
)
=
>
{
let
mut
trailing_bidi_control_characters_to_retain
=
Vec
:
:
new
(
)
;
let
(
mut
modified
mut
last_character_index
)
=
(
true
0
)
;
for
(
i
character
)
in
unscanned_text_fragment_info
.
text
.
char_indices
(
)
.
rev
(
)
{
if
gfx
:
:
text
:
:
util
:
:
is_bidi_control
(
character
)
{
trailing_bidi_control_characters_to_retain
.
push
(
character
)
;
continue
}
if
util
:
:
str
:
:
char_is_whitespace
(
character
)
{
modified
=
true
;
continue
}
last_character_index
=
i
+
character
.
len_utf8
(
)
;
break
}
if
modified
{
let
mut
text
=
unscanned_text_fragment_info
.
text
.
to_string
(
)
;
text
.
truncate
(
last_character_index
)
;
for
character
in
trailing_bidi_control_characters_to_retain
.
iter
(
)
.
rev
(
)
{
text
.
push
(
*
character
)
;
}
unscanned_text_fragment_info
.
text
=
text
.
into_boxed_str
(
)
;
}
WhitespaceStrippingResult
:
:
from_unscanned_text_fragment_info
(
&
unscanned_text_fragment_info
)
}
_
=
>
WhitespaceStrippingResult
:
:
RetainFragment
}
}
pub
fn
inline_styles
(
&
self
)
-
>
InlineStyleIterator
{
InlineStyleIterator
:
:
new
(
self
)
}
pub
fn
margin_box_inline_size
(
&
self
)
-
>
Au
{
self
.
border_box
.
size
.
inline
+
self
.
margin
.
inline_start_end
(
)
}
pub
fn
is_positioned
(
&
self
)
-
>
bool
{
if
self
.
style
.
get_box
(
)
.
position
!
=
position
:
:
T
:
:
static_
{
return
true
}
if
let
Some
(
ref
inline_context
)
=
self
.
inline_context
{
for
node
in
inline_context
.
nodes
.
iter
(
)
{
if
node
.
style
.
get_box
(
)
.
position
!
=
position
:
:
T
:
:
static_
{
return
true
}
}
}
false
}
pub
fn
is_absolutely_positioned
(
&
self
)
-
>
bool
{
self
.
style
.
get_box
(
)
.
position
=
=
position
:
:
T
:
:
absolute
}
pub
fn
is_inline_absolute
(
&
self
)
-
>
bool
{
match
self
.
specific
{
SpecificFragmentInfo
:
:
InlineAbsolute
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
meld_with_next_inline_fragment
(
&
mut
self
next_fragment
:
&
Fragment
)
{
if
let
Some
(
ref
mut
inline_context_of_this_fragment
)
=
self
.
inline_context
{
if
let
Some
(
ref
inline_context_of_next_fragment
)
=
next_fragment
.
inline_context
{
for
(
i
inline_context_node_from_next_fragment
)
in
inline_context_of_next_fragment
.
nodes
.
iter
(
)
.
enumerate
(
)
{
if
i
>
=
inline_context_of_this_fragment
.
nodes
.
len
(
)
{
continue
}
if
!
inline_context_node_from_next_fragment
.
flags
.
contains
(
LAST_FRAGMENT_OF_ELEMENT
)
{
continue
}
if
inline_context_node_from_next_fragment
.
address
!
=
inline_context_of_this_fragment
.
nodes
[
i
]
.
address
{
continue
}
inline_context_of_this_fragment
.
nodes
[
i
]
.
flags
.
insert
(
LAST_FRAGMENT_OF_ELEMENT
)
;
}
}
}
}
pub
fn
layer_id
(
&
self
)
-
>
LayerId
{
let
layer_type
=
match
self
.
pseudo
{
PseudoElementType
:
:
Normal
=
>
LayerType
:
:
FragmentBody
PseudoElementType
:
:
Before
(
_
)
=
>
LayerType
:
:
BeforePseudoContent
PseudoElementType
:
:
After
(
_
)
=
>
LayerType
:
:
AfterPseudoContent
}
;
LayerId
:
:
new_of_type
(
layer_type
self
.
node
.
id
(
)
as
usize
)
}
pub
fn
layer_id_for_overflow_scroll
(
&
self
)
-
>
LayerId
{
LayerId
:
:
new_of_type
(
LayerType
:
:
OverflowScroll
self
.
node
.
id
(
)
as
usize
)
}
}
impl
fmt
:
:
Debug
for
Fragment
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
border_padding_string
=
if
!
self
.
border_padding
.
is_zero
(
)
{
format
!
(
"
border_padding
=
{
:
?
}
"
self
.
border_padding
)
}
else
{
"
"
.
to_owned
(
)
}
;
let
margin_string
=
if
!
self
.
margin
.
is_zero
(
)
{
format
!
(
"
margin
=
{
:
?
}
"
self
.
margin
)
}
else
{
"
"
.
to_owned
(
)
}
;
let
damage_string
=
if
self
.
restyle_damage
!
=
RestyleDamage
:
:
empty
(
)
{
format
!
(
"
damage
=
{
:
?
}
"
self
.
restyle_damage
)
}
else
{
"
"
.
to_owned
(
)
}
;
write
!
(
f
"
{
}
(
{
}
)
[
{
:
?
}
]
border_box
=
{
:
?
}
{
}
{
}
{
}
"
self
.
specific
.
get_type
(
)
self
.
debug_id
(
)
self
.
specific
self
.
border_box
border_padding_string
margin_string
damage_string
)
}
}
bitflags
!
{
flags
QuantitiesIncludedInIntrinsicInlineSizes
:
u8
{
const
INTRINSIC_INLINE_SIZE_INCLUDES_MARGINS
=
0x01
const
INTRINSIC_INLINE_SIZE_INCLUDES_PADDING
=
0x02
const
INTRINSIC_INLINE_SIZE_INCLUDES_BORDER
=
0x04
const
INTRINSIC_INLINE_SIZE_INCLUDES_SPECIFIED
=
0x08
}
}
bitflags
!
{
/
/
Various
flags
we
can
use
when
splitting
fragments
.
See
/
/
calculate_split_position_using_breaking_strategy
(
)
.
flags
SplitOptions
:
u8
{
#
[
doc
=
"
True
if
this
is
the
first
fragment
on
the
line
.
"
]
const
STARTS_LINE
=
0x01
#
[
doc
=
"
True
if
we
should
attempt
to
split
at
character
boundaries
if
this
split
fails
.
\
This
is
used
to
implement
overflow
-
wrap
:
break
-
word
.
"
]
const
RETRY_AT_CHARACTER_BOUNDARIES
=
0x02
}
}
pub
trait
FragmentBorderBoxIterator
{
fn
process
(
&
mut
self
fragment
:
&
Fragment
level
:
i32
overflow
:
&
Rect
<
Au
>
)
;
fn
should_process
(
&
mut
self
fragment
:
&
Fragment
)
-
>
bool
;
}
#
[
derive
(
Clone
PartialEq
Debug
)
]
pub
enum
CoordinateSystem
{
Parent
Own
}
pub
struct
InlineStyleIterator
<
'
a
>
{
fragment
:
&
'
a
Fragment
inline_style_index
:
usize
primary_style_yielded
:
bool
}
impl
<
'
a
>
Iterator
for
InlineStyleIterator
<
'
a
>
{
type
Item
=
&
'
a
ComputedValues
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
ComputedValues
>
{
if
!
self
.
primary_style_yielded
{
self
.
primary_style_yielded
=
true
;
return
Some
(
&
*
self
.
fragment
.
style
)
}
let
inline_context
=
match
self
.
fragment
.
inline_context
{
None
=
>
return
None
Some
(
ref
inline_context
)
=
>
inline_context
}
;
let
inline_style_index
=
self
.
inline_style_index
;
if
inline_style_index
=
=
inline_context
.
nodes
.
len
(
)
{
return
None
}
self
.
inline_style_index
+
=
1
;
Some
(
&
*
inline_context
.
nodes
[
inline_style_index
]
.
style
)
}
}
impl
<
'
a
>
InlineStyleIterator
<
'
a
>
{
fn
new
(
fragment
:
&
Fragment
)
-
>
InlineStyleIterator
{
InlineStyleIterator
{
fragment
:
fragment
inline_style_index
:
0
primary_style_yielded
:
false
}
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
)
]
pub
enum
WhitespaceStrippingResult
{
RetainFragment
FragmentContainedOnlyBidiControlCharacters
FragmentContainedOnlyWhitespace
}
impl
WhitespaceStrippingResult
{
fn
from_unscanned_text_fragment_info
(
info
:
&
UnscannedTextFragmentInfo
)
-
>
WhitespaceStrippingResult
{
if
info
.
text
.
is_empty
(
)
{
WhitespaceStrippingResult
:
:
FragmentContainedOnlyWhitespace
}
else
if
info
.
text
.
chars
(
)
.
all
(
gfx
:
:
text
:
:
util
:
:
is_bidi_control
)
{
WhitespaceStrippingResult
:
:
FragmentContainedOnlyBidiControlCharacters
}
else
{
WhitespaceStrippingResult
:
:
RetainFragment
}
}
}
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
Overflow
{
pub
scroll
:
Rect
<
Au
>
pub
paint
:
Rect
<
Au
>
}
impl
Overflow
{
pub
fn
new
(
)
-
>
Overflow
{
Overflow
{
scroll
:
Rect
:
:
zero
(
)
paint
:
Rect
:
:
zero
(
)
}
}
pub
fn
from_rect
(
border_box
:
&
Rect
<
Au
>
)
-
>
Overflow
{
Overflow
{
scroll
:
*
border_box
paint
:
*
border_box
}
}
pub
fn
union
(
&
mut
self
other
:
&
Overflow
)
{
self
.
scroll
=
self
.
scroll
.
union
(
&
other
.
scroll
)
;
self
.
paint
=
self
.
paint
.
union
(
&
other
.
paint
)
;
}
pub
fn
translate
(
&
mut
self
point
:
&
Point2D
<
Au
>
)
{
self
.
scroll
=
self
.
scroll
.
translate
(
point
)
;
self
.
paint
=
self
.
paint
.
translate
(
point
)
;
}
}
bitflags
!
{
flags
FragmentFlags
:
u8
{
/
/
/
Whether
this
fragment
has
a
layer
.
const
HAS_LAYER
=
0x01
}
}
