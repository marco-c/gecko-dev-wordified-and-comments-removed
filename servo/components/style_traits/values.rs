use
app_units
:
:
Au
;
use
cssparser
:
:
{
ParseError
Parser
Token
UnicodeRange
serialize_string
}
;
use
cssparser
:
:
ToCss
as
CssparserToCss
;
use
servo_arc
:
:
Arc
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
pub
trait
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
;
#
[
inline
]
fn
to_css_string
(
&
self
)
-
>
String
{
let
mut
s
=
String
:
:
new
(
)
;
self
.
to_css
(
&
mut
CssWriter
:
:
new
(
&
mut
s
)
)
.
unwrap
(
)
;
s
}
}
impl
<
'
a
T
>
ToCss
for
&
'
a
T
where
T
:
ToCss
+
?
Sized
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
(
*
self
)
.
to_css
(
dest
)
}
}
impl
ToCss
for
str
{
#
[
inline
]
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
serialize_string
(
self
dest
)
}
}
impl
ToCss
for
String
{
#
[
inline
]
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
serialize_string
(
self
dest
)
}
}
impl
<
T
>
ToCss
for
Option
<
T
>
where
T
:
ToCss
{
#
[
inline
]
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
as_ref
(
)
.
map_or
(
Ok
(
(
)
)
|
value
|
value
.
to_css
(
dest
)
)
}
}
pub
struct
CssWriter
<
'
w
W
:
'
w
>
{
inner
:
&
'
w
mut
W
prefix
:
Option
<
&
'
static
str
>
}
impl
<
'
w
W
>
CssWriter
<
'
w
W
>
where
W
:
Write
{
#
[
inline
]
pub
fn
new
(
inner
:
&
'
w
mut
W
)
-
>
Self
{
Self
{
inner
prefix
:
Some
(
"
"
)
}
}
}
impl
<
'
w
W
>
Write
for
CssWriter
<
'
w
W
>
where
W
:
Write
{
#
[
inline
]
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
fmt
:
:
Result
{
if
s
.
is_empty
(
)
{
return
Ok
(
(
)
)
;
}
if
let
Some
(
prefix
)
=
self
.
prefix
.
take
(
)
{
if
!
prefix
.
is_empty
(
)
{
self
.
inner
.
write_str
(
prefix
)
?
;
}
}
self
.
inner
.
write_str
(
s
)
}
#
[
inline
]
fn
write_char
(
&
mut
self
c
:
char
)
-
>
fmt
:
:
Result
{
if
let
Some
(
prefix
)
=
self
.
prefix
.
take
(
)
{
if
!
prefix
.
is_empty
(
)
{
self
.
inner
.
write_str
(
prefix
)
?
;
}
}
self
.
inner
.
write_char
(
c
)
}
}
#
[
macro_export
]
macro_rules
!
serialize_function
{
(
dest
:
expr
name
:
ident
(
(
arg
:
expr
)
+
)
)
=
>
{
serialize_function
!
(
dest
name
(
(
arg
)
+
)
)
}
;
(
dest
:
expr
name
:
ident
(
first_arg
:
expr
(
arg
:
expr
)
*
)
)
=
>
{
{
dest
.
write_str
(
concat
!
(
stringify
!
(
name
)
"
(
"
)
)
?
;
first_arg
.
to_css
(
dest
)
?
;
(
dest
.
write_str
(
"
"
)
?
;
arg
.
to_css
(
dest
)
?
;
)
*
dest
.
write_char
(
'
)
'
)
}
}
}
pub
struct
SequenceWriter
<
'
a
'
b
:
'
a
W
:
'
b
>
{
inner
:
&
'
a
mut
CssWriter
<
'
b
W
>
separator
:
&
'
static
str
}
impl
<
'
a
'
b
W
>
SequenceWriter
<
'
a
'
b
W
>
where
W
:
Write
+
'
b
{
#
[
inline
]
pub
fn
new
(
inner
:
&
'
a
mut
CssWriter
<
'
b
W
>
separator
:
&
'
static
str
)
-
>
Self
{
if
inner
.
prefix
.
is_none
(
)
{
inner
.
prefix
=
Some
(
"
"
)
;
}
Self
{
inner
separator
}
}
#
[
inline
]
pub
fn
item
<
T
>
(
&
mut
self
item
:
&
T
)
-
>
fmt
:
:
Result
where
T
:
ToCss
{
let
old_prefix
=
self
.
inner
.
prefix
;
if
old_prefix
.
is_none
(
)
{
self
.
inner
.
prefix
=
Some
(
self
.
separator
)
;
}
item
.
to_css
(
&
mut
self
.
inner
)
?
;
match
(
old_prefix
self
.
inner
.
prefix
)
{
(
_
None
)
=
>
{
}
(
None
Some
(
p
)
)
=
>
{
debug_assert_eq
!
(
self
.
separator
p
)
;
self
.
inner
.
prefix
=
None
;
}
(
Some
(
old
)
Some
(
new
)
)
=
>
{
debug_assert_eq
!
(
old
new
)
;
}
}
Ok
(
(
)
)
}
}
pub
struct
Comma
;
pub
struct
Space
;
pub
struct
CommaWithSpace
;
pub
trait
Separator
{
fn
separator
(
)
-
>
&
'
static
str
;
fn
parse
<
'
i
'
t
F
T
E
>
(
parser
:
&
mut
Parser
<
'
i
'
t
>
parse_one
:
F
)
-
>
Result
<
Vec
<
T
>
ParseError
<
'
i
E
>
>
where
F
:
for
<
'
tt
>
FnMut
(
&
mut
Parser
<
'
i
'
tt
>
)
-
>
Result
<
T
ParseError
<
'
i
E
>
>
;
}
impl
Separator
for
Comma
{
fn
separator
(
)
-
>
&
'
static
str
{
"
"
}
fn
parse
<
'
i
'
t
F
T
E
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
parse_one
:
F
)
-
>
Result
<
Vec
<
T
>
ParseError
<
'
i
E
>
>
where
F
:
for
<
'
tt
>
FnMut
(
&
mut
Parser
<
'
i
'
tt
>
)
-
>
Result
<
T
ParseError
<
'
i
E
>
>
{
input
.
parse_comma_separated
(
parse_one
)
}
}
impl
Separator
for
Space
{
fn
separator
(
)
-
>
&
'
static
str
{
"
"
}
fn
parse
<
'
i
'
t
F
T
E
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
mut
parse_one
:
F
)
-
>
Result
<
Vec
<
T
>
ParseError
<
'
i
E
>
>
where
F
:
for
<
'
tt
>
FnMut
(
&
mut
Parser
<
'
i
'
tt
>
)
-
>
Result
<
T
ParseError
<
'
i
E
>
>
{
input
.
skip_whitespace
(
)
;
let
mut
results
=
vec
!
[
parse_one
(
input
)
?
]
;
loop
{
input
.
skip_whitespace
(
)
;
if
let
Ok
(
item
)
=
input
.
try
(
&
mut
parse_one
)
{
results
.
push
(
item
)
;
}
else
{
return
Ok
(
results
)
}
}
}
}
impl
Separator
for
CommaWithSpace
{
fn
separator
(
)
-
>
&
'
static
str
{
"
"
}
fn
parse
<
'
i
'
t
F
T
E
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
mut
parse_one
:
F
)
-
>
Result
<
Vec
<
T
>
ParseError
<
'
i
E
>
>
where
F
:
for
<
'
tt
>
FnMut
(
&
mut
Parser
<
'
i
'
tt
>
)
-
>
Result
<
T
ParseError
<
'
i
E
>
>
{
input
.
skip_whitespace
(
)
;
let
mut
results
=
vec
!
[
parse_one
(
input
)
?
]
;
loop
{
input
.
skip_whitespace
(
)
;
let
comma_location
=
input
.
current_source_location
(
)
;
let
comma
=
input
.
try
(
|
i
|
i
.
expect_comma
(
)
)
.
is_ok
(
)
;
input
.
skip_whitespace
(
)
;
if
let
Ok
(
item
)
=
input
.
try
(
&
mut
parse_one
)
{
results
.
push
(
item
)
;
}
else
if
comma
{
return
Err
(
comma_location
.
new_unexpected_token_error
(
Token
:
:
Comma
)
)
;
}
else
{
break
;
}
}
Ok
(
results
)
}
}
pub
trait
OneOrMoreSeparated
{
type
S
:
Separator
;
}
impl
OneOrMoreSeparated
for
UnicodeRange
{
type
S
=
Comma
;
}
impl
<
T
>
ToCss
for
Vec
<
T
>
where
T
:
ToCss
+
OneOrMoreSeparated
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
let
mut
iter
=
self
.
iter
(
)
;
iter
.
next
(
)
.
unwrap
(
)
.
to_css
(
dest
)
?
;
for
item
in
iter
{
dest
.
write_str
(
<
T
as
OneOrMoreSeparated
>
:
:
S
:
:
separator
(
)
)
?
;
item
.
to_css
(
dest
)
?
;
}
Ok
(
(
)
)
}
}
impl
<
T
>
ToCss
for
Box
<
T
>
where
T
:
?
Sized
+
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
(
*
*
self
)
.
to_css
(
dest
)
}
}
impl
<
T
>
ToCss
for
Arc
<
T
>
where
T
:
?
Sized
+
ToCss
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
(
*
*
self
)
.
to_css
(
dest
)
}
}
impl
ToCss
for
Au
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
self
.
to_f64_px
(
)
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
px
"
)
}
}
macro_rules
!
impl_to_css_for_predefined_type
{
(
name
:
ty
)
=
>
{
impl
<
'
a
>
ToCss
for
name
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
CssWriter
<
W
>
)
-
>
fmt
:
:
Result
where
W
:
Write
{
:
:
cssparser
:
:
ToCss
:
:
to_css
(
self
dest
)
}
}
}
;
}
impl_to_css_for_predefined_type
!
(
f32
)
;
impl_to_css_for_predefined_type
!
(
i32
)
;
impl_to_css_for_predefined_type
!
(
u16
)
;
impl_to_css_for_predefined_type
!
(
u32
)
;
impl_to_css_for_predefined_type
!
(
:
:
cssparser
:
:
Token
<
'
a
>
)
;
impl_to_css_for_predefined_type
!
(
:
:
cssparser
:
:
RGBA
)
;
impl_to_css_for_predefined_type
!
(
:
:
cssparser
:
:
Color
)
;
impl_to_css_for_predefined_type
!
(
:
:
cssparser
:
:
UnicodeRange
)
;
#
[
macro_export
]
macro_rules
!
define_css_keyword_enum
{
(
name
:
ident
:
values
{
(
css
:
expr
=
>
variant
:
ident
)
+
}
aliases
{
(
alias
:
expr
=
>
alias_variant
:
ident
)
+
}
)
=
>
{
__define_css_keyword_enum__add_optional_traits
!
(
name
[
(
css
=
>
variant
)
+
]
[
(
alias
=
>
alias_variant
)
+
]
)
;
}
;
(
name
:
ident
:
values
{
(
css
:
expr
=
>
variant
:
ident
)
+
}
aliases
{
(
alias
:
expr
=
>
alias_variant
:
ident
)
*
}
)
=
>
{
__define_css_keyword_enum__add_optional_traits
!
(
name
[
(
css
=
>
variant
)
+
]
[
(
alias
=
>
alias_variant
)
*
]
)
;
}
;
(
name
:
ident
:
values
{
(
css
:
expr
=
>
variant
:
ident
)
+
}
aliases
{
(
alias
:
expr
=
>
alias_variant
:
ident
)
+
}
)
=
>
{
__define_css_keyword_enum__add_optional_traits
!
(
name
[
(
css
=
>
variant
)
+
]
[
(
alias
=
>
alias_variant
)
+
]
)
;
}
;
(
name
:
ident
:
values
{
(
css
:
expr
=
>
variant
:
ident
)
+
}
aliases
{
(
alias
:
expr
=
>
alias_variant
:
ident
)
*
}
)
=
>
{
__define_css_keyword_enum__add_optional_traits
!
(
name
[
(
css
=
>
variant
)
+
]
[
(
alias
=
>
alias_variant
)
*
]
)
;
}
;
(
name
:
ident
:
(
css
:
expr
=
>
variant
:
ident
)
+
)
=
>
{
__define_css_keyword_enum__add_optional_traits
!
(
name
[
(
css
=
>
variant
)
+
]
[
]
)
;
}
;
(
name
:
ident
:
(
css
:
expr
=
>
variant
:
ident
)
+
)
=
>
{
__define_css_keyword_enum__add_optional_traits
!
(
name
[
(
css
=
>
variant
)
+
]
[
]
)
;
}
;
}
#
[
cfg
(
feature
=
"
servo
"
)
]
#
[
macro_export
]
macro_rules
!
__define_css_keyword_enum__add_optional_traits
{
(
name
:
ident
[
(
css
:
expr
=
>
variant
:
ident
)
+
]
[
(
alias
:
expr
=
>
alias_variant
:
ident
)
*
]
)
=
>
{
__define_css_keyword_enum__actual
!
{
name
[
Deserialize
Serialize
MallocSizeOf
]
[
(
css
=
>
variant
)
+
]
[
(
alias
=
>
alias_variant
)
*
]
}
}
;
}
#
[
cfg
(
not
(
feature
=
"
servo
"
)
)
]
#
[
macro_export
]
macro_rules
!
__define_css_keyword_enum__add_optional_traits
{
(
name
:
ident
[
(
css
:
expr
=
>
variant
:
ident
)
+
]
[
(
alias
:
expr
=
>
alias_variant
:
ident
)
*
]
)
=
>
{
__define_css_keyword_enum__actual
!
{
name
[
MallocSizeOf
]
[
(
css
=
>
variant
)
+
]
[
(
alias
=
>
alias_variant
)
*
]
}
}
;
}
#
[
macro_export
]
macro_rules
!
__define_css_keyword_enum__actual
{
(
name
:
ident
[
(
derived_trait
:
ident
)
*
]
[
(
css
:
expr
=
>
variant
:
ident
)
+
]
[
(
alias
:
expr
=
>
alias_variant
:
ident
)
*
]
)
=
>
{
#
[
allow
(
non_camel_case_types
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
(
derived_trait
)
*
)
]
pub
enum
name
{
(
variant
)
+
}
impl
name
{
/
/
/
Parse
this
property
from
a
CSS
input
stream
.
pub
fn
parse
<
'
i
'
t
>
(
input
:
&
mut
:
:
cssparser
:
:
Parser
<
'
i
'
t
>
)
-
>
Result
<
name
crate
:
:
ParseError
<
'
i
>
>
{
use
cssparser
:
:
Token
;
let
location
=
input
.
current_source_location
(
)
;
match
*
input
.
next
(
)
?
{
Token
:
:
Ident
(
ref
ident
)
=
>
{
Self
:
:
from_ident
(
ident
)
.
map_err
(
|
(
)
|
{
location
.
new_unexpected_token_error
(
Token
:
:
Ident
(
ident
.
clone
(
)
)
)
}
)
}
ref
token
=
>
Err
(
location
.
new_unexpected_token_error
(
token
.
clone
(
)
)
)
}
}
/
/
/
Parse
this
property
from
an
already
-
tokenized
identifier
.
pub
fn
from_ident
(
ident
:
&
str
)
-
>
Result
<
name
(
)
>
{
match_ignore_ascii_case
!
{
ident
(
css
=
>
Ok
(
name
:
:
variant
)
)
+
(
alias
=
>
Ok
(
name
:
:
alias_variant
)
)
*
_
=
>
Err
(
(
)
)
}
}
}
impl
crate
:
:
ToCss
for
name
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
crate
:
:
CssWriter
<
W
>
)
-
>
:
:
std
:
:
fmt
:
:
Result
where
W
:
:
:
std
:
:
fmt
:
:
Write
{
match
*
self
{
(
name
:
:
variant
=
>
:
:
std
:
:
fmt
:
:
Write
:
:
write_str
(
dest
css
)
)
+
}
}
}
}
}
pub
mod
specified
{
use
ParsingMode
;
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
PartialOrd
)
]
pub
enum
AllowedNumericType
{
All
NonNegative
AtLeastOne
}
impl
Default
for
AllowedNumericType
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
AllowedNumericType
:
:
All
}
}
impl
AllowedNumericType
{
#
[
inline
]
pub
fn
is_ok
(
&
self
parsing_mode
:
ParsingMode
val
:
f32
)
-
>
bool
{
if
parsing_mode
.
allows_all_numeric_values
(
)
{
return
true
;
}
match
*
self
{
AllowedNumericType
:
:
All
=
>
true
AllowedNumericType
:
:
NonNegative
=
>
val
>
=
0
.
0
AllowedNumericType
:
:
AtLeastOne
=
>
val
>
=
1
.
0
}
}
#
[
inline
]
pub
fn
clamp
(
&
self
val
:
f32
)
-
>
f32
{
match
*
self
{
AllowedNumericType
:
:
NonNegative
if
val
<
0
.
=
>
0
.
AllowedNumericType
:
:
AtLeastOne
if
val
<
1
.
=
>
1
.
_
=
>
val
}
}
}
}
