use
{
CSSPixel
PinchZoomFactor
ParseError
}
;
use
cssparser
:
:
{
Parser
ToCss
}
;
use
euclid
:
:
TypedSize2D
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
fmt
;
define_css_keyword_enum
!
(
UserZoom
:
"
zoom
"
=
>
Zoom
"
fixed
"
=
>
Fixed
)
;
define_css_keyword_enum
!
(
Orientation
:
"
auto
"
=
>
Auto
"
portrait
"
=
>
Portrait
"
landscape
"
=
>
Landscape
)
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
Deserialize
Serialize
MallocSizeOf
)
)
]
pub
struct
ViewportConstraints
{
pub
size
:
TypedSize2D
<
f32
CSSPixel
>
pub
initial_zoom
:
PinchZoomFactor
pub
min_zoom
:
Option
<
PinchZoomFactor
>
pub
max_zoom
:
Option
<
PinchZoomFactor
>
pub
user_zoom
:
UserZoom
pub
orientation
:
Orientation
}
impl
ToCss
for
ViewportConstraints
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_str
(
"
viewport
{
width
:
"
)
?
;
self
.
size
.
width
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
px
;
height
:
"
)
?
;
self
.
size
.
height
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
px
;
zoom
:
"
)
?
;
self
.
initial_zoom
.
get
(
)
.
to_css
(
dest
)
?
;
if
let
Some
(
min_zoom
)
=
self
.
min_zoom
{
dest
.
write_str
(
"
;
min
-
zoom
:
"
)
?
;
min_zoom
.
get
(
)
.
to_css
(
dest
)
?
;
}
if
let
Some
(
max_zoom
)
=
self
.
max_zoom
{
dest
.
write_str
(
"
;
max
-
zoom
:
"
)
?
;
max_zoom
.
get
(
)
.
to_css
(
dest
)
?
;
}
dest
.
write_str
(
"
;
user
-
zoom
:
"
)
?
;
self
.
user_zoom
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
;
orientation
:
"
)
?
;
self
.
orientation
.
to_css
(
dest
)
?
;
dest
.
write_str
(
"
;
}
"
)
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
servo
"
derive
(
MallocSizeOf
)
)
]
pub
enum
Zoom
{
Number
(
f32
)
Percentage
(
f32
)
Auto
}
impl
ToCss
for
Zoom
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
match
*
self
{
Zoom
:
:
Number
(
number
)
=
>
number
.
to_css
(
dest
)
Zoom
:
:
Auto
=
>
dest
.
write_str
(
"
auto
"
)
Zoom
:
:
Percentage
(
percentage
)
=
>
{
(
percentage
*
100
.
)
.
to_css
(
dest
)
?
;
dest
.
write_char
(
'
%
'
)
}
}
}
}
impl
Zoom
{
pub
fn
parse
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Zoom
ParseError
<
'
i
>
>
{
use
ParsingMode
;
use
cssparser
:
:
Token
;
use
values
:
:
specified
:
:
AllowedNumericType
:
:
NonNegative
;
let
location
=
input
.
current_source_location
(
)
;
match
*
input
.
next
(
)
?
{
Token
:
:
Percentage
{
unit_value
.
.
}
if
NonNegative
.
is_ok
(
ParsingMode
:
:
DEFAULT
unit_value
)
=
>
{
Ok
(
Zoom
:
:
Percentage
(
unit_value
)
)
}
Token
:
:
Number
{
value
.
.
}
if
NonNegative
.
is_ok
(
ParsingMode
:
:
DEFAULT
value
)
=
>
{
Ok
(
Zoom
:
:
Number
(
value
)
)
}
Token
:
:
Ident
(
ref
value
)
if
value
.
eq_ignore_ascii_case
(
"
auto
"
)
=
>
{
Ok
(
Zoom
:
:
Auto
)
}
ref
t
=
>
Err
(
location
.
new_unexpected_token_error
(
t
.
clone
(
)
)
)
}
}
#
[
inline
]
pub
fn
to_f32
(
&
self
)
-
>
Option
<
f32
>
{
match
*
self
{
Zoom
:
:
Number
(
number
)
=
>
Some
(
number
as
f32
)
Zoom
:
:
Percentage
(
percentage
)
=
>
Some
(
percentage
as
f32
)
Zoom
:
:
Auto
=
>
None
}
}
}
