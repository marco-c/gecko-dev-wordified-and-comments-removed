#
!
[
deny
(
unsafe_code
)
]
extern
crate
heapsize
;
#
[
macro_use
]
extern
crate
heapsize_derive
;
extern
crate
num_traits
;
#
[
macro_use
]
extern
crate
serde
;
use
std
:
:
cmp
:
:
{
self
max
min
}
;
use
std
:
:
fmt
;
use
std
:
:
ops
;
pub
trait
Int
:
Copy
+
ops
:
:
Add
<
Self
Output
=
Self
>
+
ops
:
:
Sub
<
Self
Output
=
Self
>
+
cmp
:
:
Ord
{
fn
zero
(
)
-
>
Self
;
fn
one
(
)
-
>
Self
;
fn
max_value
(
)
-
>
Self
;
fn
from_usize
(
n
:
usize
)
-
>
Option
<
Self
>
;
fn
to_usize
(
self
)
-
>
usize
;
}
impl
Int
for
isize
{
#
[
inline
]
fn
zero
(
)
-
>
isize
{
0
}
#
[
inline
]
fn
one
(
)
-
>
isize
{
1
}
#
[
inline
]
fn
max_value
(
)
-
>
isize
{
:
:
std
:
:
isize
:
:
MAX
}
#
[
inline
]
fn
from_usize
(
n
:
usize
)
-
>
Option
<
isize
>
{
num_traits
:
:
NumCast
:
:
from
(
n
)
}
#
[
inline
]
fn
to_usize
(
self
)
-
>
usize
{
num_traits
:
:
NumCast
:
:
from
(
self
)
.
unwrap
(
)
}
}
impl
Int
for
usize
{
#
[
inline
]
fn
zero
(
)
-
>
usize
{
0
}
#
[
inline
]
fn
one
(
)
-
>
usize
{
1
}
#
[
inline
]
fn
max_value
(
)
-
>
usize
{
:
:
std
:
:
usize
:
:
MAX
}
#
[
inline
]
fn
from_usize
(
n
:
usize
)
-
>
Option
<
usize
>
{
Some
(
n
)
}
#
[
inline
]
fn
to_usize
(
self
)
-
>
usize
{
self
}
}
pub
trait
RangeIndex
:
Int
+
fmt
:
:
Debug
{
type
Index
;
fn
new
(
x
:
Self
:
:
Index
)
-
>
Self
;
fn
get
(
self
)
-
>
Self
:
:
Index
;
}
impl
RangeIndex
for
isize
{
type
Index
=
isize
;
#
[
inline
]
fn
new
(
x
:
isize
)
-
>
isize
{
x
}
#
[
inline
]
fn
get
(
self
)
-
>
isize
{
self
}
}
impl
RangeIndex
for
usize
{
type
Index
=
usize
;
#
[
inline
]
fn
new
(
x
:
usize
)
-
>
usize
{
x
}
#
[
inline
]
fn
get
(
self
)
-
>
usize
{
self
}
}
#
[
macro_export
]
macro_rules
!
int_range_index
{
(
(
#
[
attr
:
meta
]
)
*
struct
Self_
:
ident
(
T
:
ty
)
)
=
>
(
#
[
derive
(
Clone
Copy
Debug
Eq
Ord
PartialEq
PartialOrd
)
]
(
#
[
attr
]
)
*
pub
struct
Self_
(
pub
T
)
;
impl
Self_
{
#
[
inline
]
pub
fn
to_usize
(
self
)
-
>
usize
{
self
.
get
(
)
as
usize
}
}
impl
crate
:
:
RangeIndex
for
Self_
{
type
Index
=
T
;
#
[
inline
]
fn
new
(
x
:
T
)
-
>
Self_
{
Self_
(
x
)
}
#
[
inline
]
fn
get
(
self
)
-
>
T
{
match
self
{
Self_
(
x
)
=
>
x
}
}
}
impl
crate
:
:
Int
for
Self_
{
#
[
inline
]
fn
zero
(
)
-
>
Self_
{
Self_
(
crate
:
:
Int
:
:
zero
(
)
)
}
#
[
inline
]
fn
one
(
)
-
>
Self_
{
Self_
(
crate
:
:
Int
:
:
one
(
)
)
}
#
[
inline
]
fn
max_value
(
)
-
>
Self_
{
Self_
(
crate
:
:
Int
:
:
max_value
(
)
)
}
#
[
inline
]
fn
from_usize
(
n
:
usize
)
-
>
Option
<
Self_
>
{
crate
:
:
Int
:
:
from_usize
(
n
)
.
map
(
Self_
)
}
#
[
inline
]
fn
to_usize
(
self
)
-
>
usize
{
self
.
to_usize
(
)
}
}
impl
:
:
std
:
:
ops
:
:
Add
<
Self_
>
for
Self_
{
type
Output
=
Self_
;
#
[
inline
]
fn
add
(
self
other
:
Self_
)
-
>
Self_
{
Self_
(
self
.
get
(
)
+
other
.
get
(
)
)
}
}
impl
:
:
std
:
:
ops
:
:
Sub
<
Self_
>
for
Self_
{
type
Output
=
Self_
;
#
[
inline
]
fn
sub
(
self
other
:
Self_
)
-
>
Self_
{
Self_
(
self
.
get
(
)
-
other
.
get
(
)
)
}
}
impl
:
:
std
:
:
ops
:
:
Neg
for
Self_
{
type
Output
=
Self_
;
#
[
inline
]
fn
neg
(
self
)
-
>
Self_
{
Self_
(
-
self
.
get
(
)
)
}
}
)
}
#
[
derive
(
Clone
Copy
Deserialize
HeapSizeOf
Serialize
)
]
pub
struct
Range
<
I
>
{
begin
:
I
length
:
I
}
impl
<
I
:
RangeIndex
>
fmt
:
:
Debug
for
Range
<
I
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
[
{
:
?
}
.
.
{
:
?
}
)
"
self
.
begin
(
)
self
.
end
(
)
)
}
}
pub
struct
EachIndex
<
I
:
RangeIndex
>
{
start
:
I
stop
:
I
}
pub
fn
each_index
<
I
:
RangeIndex
>
(
start
:
I
stop
:
I
)
-
>
EachIndex
<
I
>
{
EachIndex
{
start
stop
}
}
impl
<
I
:
RangeIndex
>
Iterator
for
EachIndex
<
I
>
{
type
Item
=
I
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
I
>
{
if
self
.
start
<
self
.
stop
{
let
next
=
self
.
start
;
self
.
start
=
next
+
I
:
:
one
(
)
;
Some
(
next
)
}
else
{
None
}
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
if
self
.
start
<
self
.
stop
{
let
len
=
(
self
.
stop
-
self
.
start
)
.
to_usize
(
)
;
(
len
Some
(
len
)
)
}
else
{
(
0
Some
(
0
)
)
}
}
}
impl
<
I
:
RangeIndex
>
Range
<
I
>
{
#
[
inline
]
pub
fn
new
(
begin
:
I
length
:
I
)
-
>
Range
<
I
>
{
Range
{
begin
:
begin
length
:
length
}
}
#
[
inline
]
pub
fn
empty
(
)
-
>
Range
<
I
>
{
Range
:
:
new
(
Int
:
:
zero
(
)
Int
:
:
zero
(
)
)
}
#
[
inline
]
pub
fn
begin
(
&
self
)
-
>
I
{
self
.
begin
}
#
[
inline
]
pub
fn
length
(
&
self
)
-
>
I
{
self
.
length
}
#
[
inline
]
pub
fn
end
(
&
self
)
-
>
I
{
self
.
begin
+
self
.
length
}
#
[
inline
]
pub
fn
contains
(
&
self
i
:
I
)
-
>
bool
{
i
>
=
self
.
begin
(
)
&
&
i
<
self
.
end
(
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
length
(
)
=
=
Int
:
:
zero
(
)
}
#
[
inline
]
pub
fn
shift_by
(
&
mut
self
delta
:
I
)
{
self
.
begin
=
self
.
begin
+
delta
;
}
#
[
inline
]
pub
fn
extend_by
(
&
mut
self
delta
:
I
)
{
self
.
length
=
self
.
length
+
delta
;
}
#
[
inline
]
pub
fn
extend_to
(
&
mut
self
target
:
I
)
{
self
.
length
=
target
-
self
.
begin
;
}
#
[
inline
]
pub
fn
adjust_by
(
&
mut
self
begin_delta
:
I
length_delta
:
I
)
{
self
.
begin
=
self
.
begin
+
begin_delta
;
self
.
length
=
self
.
length
+
length_delta
;
}
#
[
inline
]
pub
fn
reset
(
&
mut
self
begin
:
I
length
:
I
)
{
self
.
begin
=
begin
;
self
.
length
=
length
;
}
#
[
inline
]
pub
fn
intersect
(
&
self
other
:
&
Range
<
I
>
)
-
>
Range
<
I
>
{
let
begin
=
max
(
self
.
begin
(
)
other
.
begin
(
)
)
;
let
end
=
min
(
self
.
end
(
)
other
.
end
(
)
)
;
if
end
<
begin
{
Range
:
:
empty
(
)
}
else
{
Range
:
:
new
(
begin
end
-
begin
)
}
}
}
impl
<
I
:
RangeIndex
>
Range
<
I
>
{
#
[
inline
]
pub
fn
each_index
(
&
self
)
-
>
EachIndex
<
I
>
{
each_index
(
self
.
begin
(
)
self
.
end
(
)
)
}
}
