#
[
macro_use
]
extern
crate
lazy_static
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
rand
;
pub
use
rand
:
:
{
Rand
Rng
SeedableRng
}
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
use
rand
:
:
isaac
:
:
Isaac64Rng
as
IsaacWordRng
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
use
rand
:
:
isaac
:
:
IsaacRng
as
IsaacWordRng
;
use
rand
:
:
os
:
:
OsRng
;
use
rand
:
:
reseeding
:
:
{
ReseedingRng
Reseeder
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
mem
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
Mutex
;
use
std
:
:
u64
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
as_isaac_seed
(
seed
:
&
[
usize
]
)
-
>
&
[
u64
]
{
unsafe
{
mem
:
:
transmute
(
seed
)
}
}
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
as_isaac_seed
(
seed
:
&
[
usize
]
)
-
>
&
[
u32
]
{
unsafe
{
mem
:
:
transmute
(
seed
)
}
}
lazy_static
!
{
static
ref
OS_RNG
:
Mutex
<
OsRng
>
=
match
OsRng
:
:
new
(
)
{
Ok
(
r
)
=
>
Mutex
:
:
new
(
r
)
Err
(
e
)
=
>
panic
!
(
"
Failed
to
seed
OsRng
:
{
}
"
e
)
}
;
}
const
RESEED_THRESHOLD
:
u64
=
32_768
;
pub
struct
ServoRng
{
rng
:
ReseedingRng
<
IsaacWordRng
ServoReseeder
>
}
impl
Rng
for
ServoRng
{
#
[
inline
]
fn
next_u32
(
&
mut
self
)
-
>
u32
{
self
.
rng
.
next_u32
(
)
}
#
[
inline
]
fn
next_u64
(
&
mut
self
)
-
>
u64
{
self
.
rng
.
next_u64
(
)
}
}
impl
<
'
a
>
SeedableRng
<
&
'
a
[
usize
]
>
for
ServoRng
{
fn
from_seed
(
seed
:
&
[
usize
]
)
-
>
ServoRng
{
debug
!
(
"
Creating
new
manually
-
reseeded
ServoRng
.
"
)
;
let
isaac_rng
=
IsaacWordRng
:
:
from_seed
(
as_isaac_seed
(
seed
)
)
;
let
reseeding_rng
=
ReseedingRng
:
:
new
(
isaac_rng
u64
:
:
MAX
ServoReseeder
)
;
ServoRng
{
rng
:
reseeding_rng
}
}
fn
reseed
(
&
mut
self
seed
:
&
'
a
[
usize
]
)
{
debug
!
(
"
Manually
reseeding
ServoRng
.
"
)
;
self
.
rng
.
reseed
(
(
ServoReseeder
as_isaac_seed
(
seed
)
)
)
}
}
impl
ServoRng
{
pub
fn
new
(
)
-
>
ServoRng
{
debug
!
(
"
Creating
new
ServoRng
.
"
)
;
let
mut
os_rng
=
OS_RNG
.
lock
(
)
.
expect
(
"
Poisoned
lock
.
"
)
;
let
isaac_rng
=
IsaacWordRng
:
:
rand
(
&
mut
*
os_rng
)
;
let
reseeding_rng
=
ReseedingRng
:
:
new
(
isaac_rng
RESEED_THRESHOLD
ServoReseeder
)
;
ServoRng
{
rng
:
reseeding_rng
}
}
}
struct
ServoReseeder
;
impl
Reseeder
<
IsaacWordRng
>
for
ServoReseeder
{
fn
reseed
(
&
mut
self
rng
:
&
mut
IsaacWordRng
)
{
debug
!
(
"
Reseeding
ServoRng
.
"
)
;
let
mut
os_rng
=
OS_RNG
.
lock
(
)
.
expect
(
"
Poisoned
lock
.
"
)
;
*
rng
=
IsaacWordRng
:
:
rand
(
&
mut
*
os_rng
)
;
}
}
impl
Default
for
ServoReseeder
{
fn
default
(
)
-
>
ServoReseeder
{
ServoReseeder
}
}
#
[
derive
(
Clone
)
]
pub
struct
ServoThreadRng
{
rng
:
Rc
<
RefCell
<
ServoRng
>
>
}
pub
fn
thread_rng
(
)
-
>
ServoThreadRng
{
SERVO_THREAD_RNG
.
with
(
|
t
|
t
.
clone
(
)
)
}
thread_local
!
{
static
SERVO_THREAD_RNG
:
ServoThreadRng
=
ServoThreadRng
{
rng
:
Rc
:
:
new
(
RefCell
:
:
new
(
ServoRng
:
:
new
(
)
)
)
}
;
}
impl
Rng
for
ServoThreadRng
{
fn
next_u32
(
&
mut
self
)
-
>
u32
{
self
.
rng
.
borrow_mut
(
)
.
next_u32
(
)
}
fn
next_u64
(
&
mut
self
)
-
>
u64
{
self
.
rng
.
borrow_mut
(
)
.
next_u64
(
)
}
#
[
inline
]
fn
fill_bytes
(
&
mut
self
bytes
:
&
mut
[
u8
]
)
{
self
.
rng
.
borrow_mut
(
)
.
fill_bytes
(
bytes
)
}
}
#
[
inline
]
pub
fn
random
<
T
:
Rand
>
(
)
-
>
T
{
thread_rng
(
)
.
gen
(
)
}
