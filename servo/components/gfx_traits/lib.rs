#
!
[
feature
(
custom_derive
plugin
proc_macro
rustc_attrs
structural_match
)
]
#
!
[
plugin
(
heapsize_plugin
plugins
)
]
#
!
[
crate_name
=
"
gfx_traits
"
]
#
!
[
crate_type
=
"
rlib
"
]
#
!
[
deny
(
unsafe_code
)
]
extern
crate
azure
;
extern
crate
euclid
;
extern
crate
heapsize
;
extern
crate
layers
;
extern
crate
msg
;
extern
crate
profile_traits
;
#
[
macro_use
]
extern
crate
range
;
extern
crate
rustc_serialize
;
extern
crate
serde
;
#
[
macro_use
]
extern
crate
serde_derive
;
pub
mod
color
;
mod
paint_listener
;
pub
mod
print_tree
;
pub
use
paint_listener
:
:
PaintListener
;
use
azure
:
:
azure_hl
:
:
Color
;
use
euclid
:
:
Matrix4D
;
use
euclid
:
:
rect
:
:
Rect
;
use
layers
:
:
layers
:
:
BufferRequest
;
use
msg
:
:
constellation_msg
:
:
PipelineId
;
use
profile_traits
:
:
mem
:
:
ReportsChan
;
use
range
:
:
RangeIndex
;
use
std
:
:
fmt
:
:
{
self
Debug
Formatter
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
ATOMIC_USIZE_INIT
AtomicUsize
Ordering
}
;
static
NEXT_SPECIAL_STACKING_CONTEXT_ID
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
const
SPECIAL_STACKING_CONTEXT_ID_MASK
:
usize
=
0xffff
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
LayerKind
{
NoTransform
HasTransform
}
#
[
derive
(
Clone
PartialEq
Eq
Copy
Hash
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
LayerType
{
FragmentBody
OverflowScroll
BeforePseudoContent
AfterPseudoContent
}
#
[
derive
(
Clone
PartialEq
Eq
Copy
Deserialize
Serialize
Debug
HeapSizeOf
)
]
pub
enum
ScrollPolicy
{
Scrollable
FixedPosition
}
#
[
derive
(
Clone
PartialEq
Eq
Copy
Hash
Deserialize
Serialize
HeapSizeOf
)
]
pub
struct
LayerId
(
LayerType
usize
usize
)
;
impl
Debug
for
LayerId
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
let
LayerId
(
layer_type
id
companion
)
=
*
self
;
let
type_string
=
match
layer_type
{
LayerType
:
:
FragmentBody
=
>
"
-
FragmentBody
"
LayerType
:
:
OverflowScroll
=
>
"
-
OverflowScroll
"
LayerType
:
:
BeforePseudoContent
=
>
"
-
BeforePseudoContent
"
LayerType
:
:
AfterPseudoContent
=
>
"
-
AfterPseudoContent
"
}
;
write
!
(
f
"
{
}
{
}
-
{
}
"
id
type_string
companion
)
}
}
impl
LayerId
{
pub
fn
null
(
)
-
>
LayerId
{
LayerId
(
LayerType
:
:
FragmentBody
0
0
)
}
pub
fn
new_of_type
(
layer_type
:
LayerType
fragment_id
:
usize
)
-
>
LayerId
{
LayerId
(
layer_type
fragment_id
0
)
}
pub
fn
companion_layer_id
(
&
self
)
-
>
LayerId
{
let
LayerId
(
layer_type
id
companion
)
=
*
self
;
LayerId
(
layer_type
id
companion
+
1
)
}
pub
fn
original
(
&
self
)
-
>
LayerId
{
let
LayerId
(
layer_type
id
_
)
=
*
self
;
LayerId
(
layer_type
id
0
)
}
pub
fn
kind
(
&
self
)
-
>
LayerType
{
self
.
0
}
}
#
[
derive
(
Copy
Clone
HeapSizeOf
)
]
pub
struct
LayerProperties
{
pub
id
:
LayerId
pub
parent_id
:
Option
<
LayerId
>
pub
rect
:
Rect
<
f32
>
pub
background_color
:
Color
pub
scroll_policy
:
ScrollPolicy
pub
transform
:
Matrix4D
<
f32
>
pub
perspective
:
Matrix4D
<
f32
>
pub
subpage_pipeline_id
:
Option
<
PipelineId
>
pub
establishes_3d_context
:
bool
pub
scrolls_overflow_area
:
bool
}
#
[
derive
(
PartialEq
Eq
Debug
Copy
Clone
PartialOrd
Ord
Deserialize
Serialize
)
]
pub
struct
Epoch
(
pub
u32
)
;
impl
Epoch
{
pub
fn
next
(
&
mut
self
)
{
self
.
0
+
=
1
;
}
}
#
[
derive
(
PartialEq
Eq
Debug
Copy
Clone
)
]
pub
struct
FrameTreeId
(
pub
u32
)
;
impl
FrameTreeId
{
pub
fn
next
(
&
mut
self
)
{
self
.
0
+
=
1
;
}
}
#
[
derive
(
Clone
Copy
Debug
Deserialize
Eq
Hash
HeapSizeOf
PartialEq
Serialize
)
]
pub
struct
StackingContextId
(
usize
)
;
impl
StackingContextId
{
#
[
inline
]
pub
fn
new
(
id
:
usize
)
-
>
StackingContextId
{
StackingContextId
:
:
new_of_type
(
id
FragmentType
:
:
FragmentBody
)
}
fn
next_special_id
(
)
-
>
usize
{
(
(
NEXT_SPECIAL_STACKING_CONTEXT_ID
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
+
1
)
<
<
2
)
&
SPECIAL_STACKING_CONTEXT_ID_MASK
}
#
[
inline
]
pub
fn
new_of_type
(
id
:
usize
fragment_type
:
FragmentType
)
-
>
StackingContextId
{
debug_assert_eq
!
(
id
&
(
fragment_type
as
usize
)
0
)
;
if
fragment_type
=
=
FragmentType
:
:
FragmentBody
{
StackingContextId
(
id
)
}
else
{
StackingContextId
(
StackingContextId
:
:
next_special_id
(
)
|
(
fragment_type
as
usize
)
)
}
}
#
[
inline
(
always
)
]
pub
fn
new_outer
(
fragment_type
:
FragmentType
)
-
>
StackingContextId
{
StackingContextId
(
StackingContextId
:
:
next_special_id
(
)
|
(
fragment_type
as
usize
)
)
}
#
[
inline
]
pub
fn
fragment_type
(
&
self
)
-
>
FragmentType
{
FragmentType
:
:
from_usize
(
self
.
0
&
3
)
}
#
[
inline
]
pub
fn
id
(
&
self
)
-
>
usize
{
self
.
0
&
!
3
}
#
[
inline
]
pub
fn
root
(
)
-
>
StackingContextId
{
StackingContextId
(
0
)
}
#
[
inline
]
pub
fn
is_special
(
&
self
)
-
>
bool
{
(
self
.
0
&
!
SPECIAL_STACKING_CONTEXT_ID_MASK
)
=
=
0
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
Copy
Hash
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
FragmentType
{
FragmentBody
BeforePseudoContent
AfterPseudoContent
}
impl
FragmentType
{
#
[
inline
]
pub
fn
from_usize
(
n
:
usize
)
-
>
FragmentType
{
debug_assert
!
(
n
<
3
)
;
match
n
{
0
=
>
FragmentType
:
:
FragmentBody
1
=
>
FragmentType
:
:
BeforePseudoContent
_
=
>
FragmentType
:
:
AfterPseudoContent
}
}
}
int_range_index
!
{
#
[
derive
(
Deserialize
Serialize
RustcEncodable
)
]
#
[
doc
=
"
An
index
that
refers
to
a
byte
offset
in
a
text
run
.
This
could
\
point
to
the
middle
of
a
glyph
.
"
]
#
[
derive
(
HeapSizeOf
)
]
struct
ByteIndex
(
isize
)
}
pub
struct
PaintRequest
{
pub
buffer_requests
:
Vec
<
BufferRequest
>
pub
scale
:
f32
pub
layer_id
:
LayerId
pub
epoch
:
Epoch
pub
layer_kind
:
LayerKind
}
pub
enum
ChromeToPaintMsg
{
Paint
(
Vec
<
PaintRequest
>
FrameTreeId
)
PaintPermissionGranted
PaintPermissionRevoked
CollectReports
(
ReportsChan
)
Exit
}
