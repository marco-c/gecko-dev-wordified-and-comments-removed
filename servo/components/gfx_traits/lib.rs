#
!
[
crate_name
=
"
gfx_traits
"
]
#
!
[
crate_type
=
"
rlib
"
]
#
!
[
deny
(
unsafe_code
)
]
extern
crate
heapsize
;
#
[
macro_use
]
extern
crate
heapsize_derive
;
#
[
macro_use
]
extern
crate
range
;
#
[
macro_use
]
extern
crate
serde
;
pub
mod
print_tree
;
use
range
:
:
RangeIndex
;
use
std
:
:
sync
:
:
atomic
:
:
{
ATOMIC_USIZE_INIT
AtomicUsize
Ordering
}
;
#
[
derive
(
PartialEq
Eq
Debug
Copy
Clone
PartialOrd
Ord
Deserialize
Serialize
)
]
pub
struct
Epoch
(
pub
u32
)
;
impl
Epoch
{
pub
fn
next
(
&
mut
self
)
{
self
.
0
+
=
1
;
}
}
#
[
derive
(
Clone
Copy
Debug
Deserialize
Eq
Hash
HeapSizeOf
PartialEq
Serialize
)
]
pub
struct
StackingContextId
(
u64
)
;
impl
StackingContextId
{
#
[
inline
]
pub
fn
root
(
)
-
>
StackingContextId
{
StackingContextId
(
0
)
}
#
[
inline
]
pub
fn
new
(
id
:
u64
)
-
>
StackingContextId
{
StackingContextId
(
id
)
}
}
int_range_index
!
{
#
[
derive
(
Deserialize
Serialize
)
]
#
[
doc
=
"
An
index
that
refers
to
a
byte
offset
in
a
text
run
.
This
could
\
point
to
the
middle
of
a
glyph
.
"
]
#
[
derive
(
HeapSizeOf
)
]
struct
ByteIndex
(
isize
)
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
Copy
Hash
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
FragmentType
{
FragmentBody
BeforePseudoContent
AfterPseudoContent
}
static
NEXT_SPECIAL_STACKING_CONTEXT_ID
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
const
SPECIAL_STACKING_CONTEXT_ID_MASK
:
usize
=
0xffff
;
fn
next_special_id
(
)
-
>
usize
{
(
(
NEXT_SPECIAL_STACKING_CONTEXT_ID
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
+
1
)
<
<
2
)
&
SPECIAL_STACKING_CONTEXT_ID_MASK
}
pub
fn
combine_id_with_fragment_type
(
id
:
usize
fragment_type
:
FragmentType
)
-
>
usize
{
debug_assert_eq
!
(
id
&
(
fragment_type
as
usize
)
0
)
;
if
fragment_type
=
=
FragmentType
:
:
FragmentBody
{
id
}
else
{
next_special_id
(
)
|
(
fragment_type
as
usize
)
}
}
pub
fn
node_id_from_clip_id
(
id
:
usize
)
-
>
Option
<
usize
>
{
if
(
id
&
!
SPECIAL_STACKING_CONTEXT_ID_MASK
)
!
=
0
{
return
Some
(
(
id
&
!
3
)
as
usize
)
;
}
None
}
