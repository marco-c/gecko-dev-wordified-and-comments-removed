#
!
[
feature
(
plugin
)
]
#
!
[
plugin
(
plugins
)
]
#
!
[
crate_name
=
"
gfx_traits
"
]
#
!
[
crate_type
=
"
rlib
"
]
#
!
[
deny
(
unsafe_code
)
]
extern
crate
heapsize
;
#
[
macro_use
]
extern
crate
heapsize_derive
;
#
[
macro_use
]
extern
crate
range
;
extern
crate
rustc_serialize
;
extern
crate
serde
;
#
[
macro_use
]
extern
crate
serde_derive
;
pub
mod
print_tree
;
use
range
:
:
RangeIndex
;
use
std
:
:
sync
:
:
atomic
:
:
{
ATOMIC_USIZE_INIT
AtomicUsize
Ordering
}
;
static
NEXT_SPECIAL_STACKING_CONTEXT_ID
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
const
SPECIAL_STACKING_CONTEXT_ID_MASK
:
usize
=
0xffff
;
#
[
derive
(
Copy
Clone
RustcEncodable
Debug
)
]
pub
enum
DevicePixel
{
}
#
[
derive
(
Copy
Clone
RustcEncodable
Debug
)
]
pub
enum
LayerPixel
{
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
LayerKind
{
NoTransform
HasTransform
}
#
[
derive
(
Clone
PartialEq
Eq
Copy
Hash
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
LayerType
{
FragmentBody
OverflowScroll
BeforePseudoContent
AfterPseudoContent
}
#
[
derive
(
Clone
PartialEq
Eq
Copy
Deserialize
Serialize
Debug
HeapSizeOf
)
]
pub
enum
ScrollPolicy
{
Scrollable
FixedPosition
}
#
[
derive
(
PartialEq
Eq
Debug
Copy
Clone
PartialOrd
Ord
Deserialize
Serialize
)
]
pub
struct
Epoch
(
pub
u32
)
;
impl
Epoch
{
pub
fn
next
(
&
mut
self
)
{
self
.
0
+
=
1
;
}
}
#
[
derive
(
PartialEq
Eq
Debug
Copy
Clone
)
]
pub
struct
FrameTreeId
(
pub
u32
)
;
impl
FrameTreeId
{
pub
fn
next
(
&
mut
self
)
{
self
.
0
+
=
1
;
}
}
#
[
derive
(
Clone
Copy
Debug
Deserialize
Eq
Hash
HeapSizeOf
PartialEq
Serialize
)
]
pub
struct
StackingContextId
(
usize
)
;
impl
StackingContextId
{
#
[
inline
]
pub
fn
new
(
id
:
usize
)
-
>
StackingContextId
{
StackingContextId
:
:
new_of_type
(
id
FragmentType
:
:
FragmentBody
)
}
fn
next_special_id
(
)
-
>
usize
{
(
(
NEXT_SPECIAL_STACKING_CONTEXT_ID
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
+
1
)
<
<
2
)
&
SPECIAL_STACKING_CONTEXT_ID_MASK
}
#
[
inline
]
pub
fn
new_of_type
(
id
:
usize
fragment_type
:
FragmentType
)
-
>
StackingContextId
{
debug_assert_eq
!
(
id
&
(
fragment_type
as
usize
)
0
)
;
if
fragment_type
=
=
FragmentType
:
:
FragmentBody
{
StackingContextId
(
id
)
}
else
{
StackingContextId
(
StackingContextId
:
:
next_special_id
(
)
|
(
fragment_type
as
usize
)
)
}
}
#
[
inline
(
always
)
]
pub
fn
new_outer
(
fragment_type
:
FragmentType
)
-
>
StackingContextId
{
StackingContextId
(
StackingContextId
:
:
next_special_id
(
)
|
(
fragment_type
as
usize
)
)
}
#
[
inline
]
pub
fn
fragment_type
(
&
self
)
-
>
FragmentType
{
FragmentType
:
:
from_usize
(
self
.
0
&
3
)
}
#
[
inline
]
pub
fn
id
(
&
self
)
-
>
usize
{
self
.
0
&
!
3
}
#
[
inline
]
pub
fn
root
(
)
-
>
StackingContextId
{
StackingContextId
(
0
)
}
#
[
inline
]
pub
fn
is_special
(
&
self
)
-
>
bool
{
(
self
.
0
&
!
SPECIAL_STACKING_CONTEXT_ID_MASK
)
=
=
0
}
}
#
[
derive
(
Clone
Copy
Debug
Deserialize
Eq
Hash
HeapSizeOf
PartialEq
Serialize
)
]
pub
struct
ScrollRootId
(
pub
usize
)
;
impl
ScrollRootId
{
fn
next_special_id
(
)
-
>
usize
{
(
(
NEXT_SPECIAL_STACKING_CONTEXT_ID
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
+
1
)
<
<
2
)
&
SPECIAL_STACKING_CONTEXT_ID_MASK
}
#
[
inline
]
pub
fn
new_of_type
(
id
:
usize
fragment_type
:
FragmentType
)
-
>
ScrollRootId
{
debug_assert_eq
!
(
id
&
(
fragment_type
as
usize
)
0
)
;
if
fragment_type
=
=
FragmentType
:
:
FragmentBody
{
ScrollRootId
(
id
)
}
else
{
ScrollRootId
(
ScrollRootId
:
:
next_special_id
(
)
|
(
fragment_type
as
usize
)
)
}
}
#
[
inline
]
pub
fn
root
(
)
-
>
ScrollRootId
{
ScrollRootId
(
0
)
}
#
[
inline
]
pub
fn
is_special
(
&
self
)
-
>
bool
{
(
self
.
0
&
!
SPECIAL_STACKING_CONTEXT_ID_MASK
)
=
=
0
}
#
[
inline
]
pub
fn
id
(
&
self
)
-
>
usize
{
self
.
0
&
!
3
}
#
[
inline
]
pub
fn
fragment_type
(
&
self
)
-
>
FragmentType
{
FragmentType
:
:
from_usize
(
self
.
0
&
3
)
}
#
[
inline
]
pub
fn
to_stacking_context_id
(
&
self
)
-
>
StackingContextId
{
StackingContextId
(
self
.
0
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
Copy
Hash
Deserialize
Serialize
HeapSizeOf
)
]
pub
enum
FragmentType
{
FragmentBody
BeforePseudoContent
AfterPseudoContent
}
impl
FragmentType
{
#
[
inline
]
pub
fn
from_usize
(
n
:
usize
)
-
>
FragmentType
{
debug_assert
!
(
n
<
3
)
;
match
n
{
0
=
>
FragmentType
:
:
FragmentBody
1
=
>
FragmentType
:
:
BeforePseudoContent
_
=
>
FragmentType
:
:
AfterPseudoContent
}
}
}
int_range_index
!
{
#
[
derive
(
Deserialize
Serialize
RustcEncodable
)
]
#
[
doc
=
"
An
index
that
refers
to
a
byte
offset
in
a
text
run
.
This
could
\
point
to
the
middle
of
a
glyph
.
"
]
#
[
derive
(
HeapSizeOf
)
]
struct
ByteIndex
(
isize
)
}
