pub
struct
PrintTree
{
level
:
u32
queued_item
:
Option
<
String
>
}
impl
PrintTree
{
pub
fn
new
(
title
:
String
)
-
>
PrintTree
{
println
!
(
"
\
u
{
250c
}
{
}
"
title
)
;
PrintTree
{
level
:
1
queued_item
:
None
}
}
pub
fn
new_level
(
&
mut
self
queued_title
:
String
)
{
self
.
flush_queued_item
(
"
\
u
{
251C
}
\
u
{
2500
}
"
)
;
self
.
print_level_prefix
(
)
;
let
items
:
Vec
<
&
str
>
=
queued_title
.
split
(
"
\
n
"
)
.
collect
(
)
;
println
!
(
"
\
u
{
251C
}
\
u
{
2500
}
{
}
"
items
[
0
]
)
;
for
i
in
1
.
.
items
.
len
(
)
{
self
.
print_level_child_indentation
(
)
;
print
!
(
"
{
}
"
items
[
i
]
)
;
if
i
<
items
.
len
(
)
{
print
!
(
"
\
n
"
)
;
}
}
self
.
level
=
self
.
level
+
1
;
}
pub
fn
end_level
(
&
mut
self
)
{
self
.
flush_queued_item
(
"
\
u
{
2514
}
\
u
{
2500
}
"
)
;
self
.
level
-
=
1
;
}
pub
fn
add_item
(
&
mut
self
text
:
String
)
{
self
.
flush_queued_item
(
"
\
u
{
251C
}
\
u
{
2500
}
"
)
;
self
.
queued_item
=
Some
(
text
)
;
}
fn
print_level_prefix
(
&
self
)
{
for
_
in
0
.
.
self
.
level
{
print
!
(
"
\
u
{
2502
}
"
)
;
}
}
fn
print_level_child_indentation
(
&
self
)
{
for
_
in
0
.
.
(
self
.
level
+
1
)
{
print
!
(
"
\
u
{
2502
}
"
)
;
}
print
!
(
"
{
}
"
"
"
.
repeat
(
7
)
)
;
}
fn
flush_queued_item
(
&
mut
self
prefix
:
&
str
)
{
if
let
Some
(
queued_item
)
=
self
.
queued_item
.
take
(
)
{
self
.
print_level_prefix
(
)
;
let
items
:
Vec
<
&
str
>
=
queued_item
.
split
(
"
\
n
"
)
.
collect
(
)
;
println
!
(
"
{
}
{
}
"
prefix
items
[
0
]
)
;
for
i
in
1
.
.
items
.
len
(
)
{
self
.
print_level_child_indentation
(
)
;
print
!
(
"
{
}
"
items
[
i
]
)
;
if
i
<
items
.
len
(
)
{
print
!
(
"
\
n
"
)
;
}
}
}
}
}
impl
Drop
for
PrintTree
{
fn
drop
(
&
mut
self
)
{
self
.
flush_queued_item
(
"
\
u
{
9492
}
\
u
{
9472
}
"
)
;
}
}
