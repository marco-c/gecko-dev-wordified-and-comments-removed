use
net_traits
:
:
{
Action
FetchResponseListener
FetchResponseMsg
}
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
task
:
:
{
Task
TaskCanceller
}
;
use
task_source
:
:
TaskSource
;
use
task_source
:
:
networking
:
:
NetworkingTaskSource
;
pub
struct
NetworkListener
<
Listener
:
PreInvoke
+
Send
+
'
static
>
{
pub
context
:
Arc
<
Mutex
<
Listener
>
>
pub
task_source
:
NetworkingTaskSource
pub
canceller
:
Option
<
TaskCanceller
>
}
impl
<
Listener
:
PreInvoke
+
Send
+
'
static
>
NetworkListener
<
Listener
>
{
pub
fn
notify
<
A
:
Action
<
Listener
>
+
Send
+
'
static
>
(
&
self
action
:
A
)
{
let
task
=
box
ListenerTask
{
context
:
self
.
context
.
clone
(
)
action
:
action
}
;
let
result
=
if
let
Some
(
ref
canceller
)
=
self
.
canceller
{
self
.
task_source
.
queue_with_canceller
(
task
canceller
)
}
else
{
self
.
task_source
.
queue_unconditionally
(
task
)
}
;
if
let
Err
(
err
)
=
result
{
warn
!
(
"
failed
to
deliver
network
data
:
{
:
?
}
"
err
)
;
}
}
}
impl
<
Listener
:
FetchResponseListener
+
PreInvoke
+
Send
+
'
static
>
NetworkListener
<
Listener
>
{
pub
fn
notify_fetch
(
&
self
action
:
FetchResponseMsg
)
{
self
.
notify
(
action
)
;
}
}
pub
trait
PreInvoke
{
fn
should_invoke
(
&
self
)
-
>
bool
{
true
}
}
struct
ListenerTask
<
A
:
Action
<
Listener
>
+
Send
+
'
static
Listener
:
PreInvoke
+
Send
>
{
context
:
Arc
<
Mutex
<
Listener
>
>
action
:
A
}
impl
<
A
Listener
>
Task
for
ListenerTask
<
A
Listener
>
where
A
:
Action
<
Listener
>
+
Send
+
'
static
Listener
:
PreInvoke
+
Send
{
fn
run
(
self
:
Box
<
Self
>
)
{
let
this
=
*
self
;
let
mut
context
=
this
.
context
.
lock
(
)
.
unwrap
(
)
;
if
context
.
should_invoke
(
)
{
this
.
action
.
process
(
&
mut
*
context
)
;
}
}
}
