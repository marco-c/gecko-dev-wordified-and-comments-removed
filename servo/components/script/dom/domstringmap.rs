use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
DOMStringMapBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
DOMStringMapBinding
:
:
DOMStringMapMethods
;
use
dom
:
:
bindings
:
:
error
:
:
ErrorResult
;
use
dom
:
:
bindings
:
:
global
:
:
GlobalRef
;
use
dom
:
:
bindings
:
:
js
:
:
{
JS
Root
}
;
use
dom
:
:
bindings
:
:
utils
:
:
{
Reflector
reflect_dom_object
}
;
use
dom
:
:
htmlelement
:
:
{
HTMLElement
HTMLElementCustomAttributeHelpers
}
;
use
dom
:
:
node
:
:
window_from_node
;
use
util
:
:
str
:
:
DOMString
;
#
[
dom_struct
]
pub
struct
DOMStringMap
{
reflector_
:
Reflector
element
:
JS
<
HTMLElement
>
}
impl
DOMStringMap
{
fn
new_inherited
(
element
:
&
HTMLElement
)
-
>
DOMStringMap
{
DOMStringMap
{
reflector_
:
Reflector
:
:
new
(
)
element
:
JS
:
:
from_ref
(
element
)
}
}
pub
fn
new
(
element
:
&
HTMLElement
)
-
>
Root
<
DOMStringMap
>
{
let
window
=
window_from_node
(
element
)
;
reflect_dom_object
(
box
DOMStringMap
:
:
new_inherited
(
element
)
GlobalRef
:
:
Window
(
window
.
r
(
)
)
DOMStringMapBinding
:
:
Wrap
)
}
}
impl
<
'
a
>
DOMStringMapMethods
for
&
'
a
DOMStringMap
{
fn
NamedCreator
(
self
name
:
DOMString
value
:
DOMString
)
-
>
ErrorResult
{
self
.
NamedSetter
(
name
value
)
}
fn
NamedDeleter
(
self
name
:
DOMString
)
{
let
element
=
self
.
element
.
root
(
)
;
element
.
r
(
)
.
delete_custom_attr
(
name
)
}
fn
NamedSetter
(
self
name
:
DOMString
value
:
DOMString
)
-
>
ErrorResult
{
let
element
=
self
.
element
.
root
(
)
;
element
.
r
(
)
.
set_custom_attr
(
name
value
)
}
fn
NamedGetter
(
self
name
:
DOMString
found
:
&
mut
bool
)
-
>
DOMString
{
let
element
=
self
.
element
.
root
(
)
;
match
element
.
r
(
)
.
get_custom_attr
(
name
)
{
Some
(
value
)
=
>
{
*
found
=
true
;
value
.
clone
(
)
}
None
=
>
{
*
found
=
false
;
String
:
:
new
(
)
}
}
}
fn
SupportedPropertyNames
(
self
)
-
>
Vec
<
DOMString
>
{
vec
!
[
]
}
}
