use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
PermissionStatusBinding
:
:
{
PermissionDescriptor
PermissionName
PermissionState
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
PermissionStatusBinding
:
:
PermissionStatusMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
PermissionsBinding
:
:
{
self
PermissionsMethods
}
;
use
dom
:
:
bindings
:
:
error
:
:
Error
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
DomObject
Reflector
reflect_dom_object
}
;
use
dom
:
:
bindings
:
:
root
:
:
DomRoot
;
use
dom
:
:
bluetooth
:
:
Bluetooth
;
use
dom
:
:
bluetoothpermissionresult
:
:
BluetoothPermissionResult
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom
:
:
permissionstatus
:
:
PermissionStatus
;
use
dom
:
:
promise
:
:
Promise
;
use
dom_struct
:
:
dom_struct
;
use
js
:
:
conversions
:
:
ConversionResult
;
use
js
:
:
jsapi
:
:
{
JSContext
JSObject
}
;
use
js
:
:
jsval
:
:
{
ObjectValue
UndefinedValue
}
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
use
servo_config
:
:
opts
;
use
servo_config
:
:
prefs
:
:
PREFS
;
use
std
:
:
rc
:
:
Rc
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
use
tinyfiledialogs
:
:
{
self
MessageBoxIcon
YesNo
}
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
const
DIALOG_TITLE
:
&
'
static
str
=
"
Permission
request
dialog
"
;
const
NONSECURE_DIALOG_MESSAGE
:
&
'
static
str
=
"
feature
is
only
safe
to
use
in
secure
context
\
but
servo
can
'
t
guarantee
\
n
that
the
current
context
is
secure
.
Do
you
want
to
proceed
and
grant
permission
?
"
;
const
REQUEST_DIALOG_MESSAGE
:
&
'
static
str
=
"
Do
you
want
to
grant
permission
for
"
;
const
ROOT_DESC_CONVERSION_ERROR
:
&
'
static
str
=
"
Can
'
t
convert
to
an
IDL
value
of
type
PermissionDescriptor
"
;
pub
trait
PermissionAlgorithm
{
type
Descriptor
;
type
Status
;
fn
create_descriptor
(
cx
:
*
mut
JSContext
permission_descriptor_obj
:
*
mut
JSObject
)
-
>
Result
<
Self
:
:
Descriptor
Error
>
;
fn
permission_query
(
cx
:
*
mut
JSContext
promise
:
&
Rc
<
Promise
>
descriptor
:
&
Self
:
:
Descriptor
status
:
&
Self
:
:
Status
)
;
fn
permission_request
(
cx
:
*
mut
JSContext
promise
:
&
Rc
<
Promise
>
descriptor
:
&
Self
:
:
Descriptor
status
:
&
Self
:
:
Status
)
;
fn
permission_revoke
(
descriptor
:
&
Self
:
:
Descriptor
status
:
&
Self
:
:
Status
)
;
}
enum
Operation
{
Query
Request
Revoke
}
#
[
dom_struct
]
pub
struct
Permissions
{
reflector_
:
Reflector
}
impl
Permissions
{
pub
fn
new_inherited
(
)
-
>
Permissions
{
Permissions
{
reflector_
:
Reflector
:
:
new
(
)
}
}
pub
fn
new
(
global
:
&
GlobalScope
)
-
>
DomRoot
<
Permissions
>
{
reflect_dom_object
(
Box
:
:
new
(
Permissions
:
:
new_inherited
(
)
)
global
PermissionsBinding
:
:
Wrap
)
}
#
[
allow
(
unrooted_must_root
)
]
fn
manipulate
(
&
self
op
:
Operation
cx
:
*
mut
JSContext
permissionDesc
:
*
mut
JSObject
promise
:
Option
<
Rc
<
Promise
>
>
)
-
>
Rc
<
Promise
>
{
let
p
=
match
promise
{
Some
(
promise
)
=
>
promise
None
=
>
Promise
:
:
new
(
&
self
.
global
(
)
)
}
;
let
root_desc
=
match
Permissions
:
:
create_descriptor
(
cx
permissionDesc
)
{
Ok
(
descriptor
)
=
>
descriptor
Err
(
error
)
=
>
{
p
.
reject_error
(
error
)
;
return
p
;
}
}
;
let
status
=
PermissionStatus
:
:
new
(
&
self
.
global
(
)
&
root_desc
)
;
match
root_desc
.
name
{
PermissionName
:
:
Bluetooth
=
>
{
let
bluetooth_desc
=
match
Bluetooth
:
:
create_descriptor
(
cx
permissionDesc
)
{
Ok
(
descriptor
)
=
>
descriptor
Err
(
error
)
=
>
{
p
.
reject_error
(
error
)
;
return
p
;
}
}
;
let
result
=
BluetoothPermissionResult
:
:
new
(
&
self
.
global
(
)
&
status
)
;
match
&
op
{
&
Operation
:
:
Request
=
>
Bluetooth
:
:
permission_request
(
cx
&
p
&
bluetooth_desc
&
result
)
&
Operation
:
:
Query
=
>
Bluetooth
:
:
permission_query
(
cx
&
p
&
bluetooth_desc
&
result
)
&
Operation
:
:
Revoke
=
>
{
let
globalscope
=
self
.
global
(
)
;
globalscope
.
as_window
(
)
.
permission_state_invocation_results
(
)
.
borrow_mut
(
)
.
remove
(
&
root_desc
.
name
.
to_string
(
)
)
;
Bluetooth
:
:
permission_revoke
(
&
bluetooth_desc
&
result
)
}
}
}
_
=
>
{
match
&
op
{
&
Operation
:
:
Request
=
>
{
Permissions
:
:
permission_request
(
cx
&
p
&
root_desc
&
status
)
;
p
.
resolve_native
(
&
status
)
;
}
&
Operation
:
:
Query
=
>
{
Permissions
:
:
permission_query
(
cx
&
p
&
root_desc
&
status
)
;
p
.
resolve_native
(
&
status
)
;
}
&
Operation
:
:
Revoke
=
>
{
let
globalscope
=
self
.
global
(
)
;
globalscope
.
as_window
(
)
.
permission_state_invocation_results
(
)
.
borrow_mut
(
)
.
remove
(
&
root_desc
.
name
.
to_string
(
)
)
;
Permissions
:
:
permission_revoke
(
&
root_desc
&
status
)
;
}
}
}
}
;
match
op
{
Operation
:
:
Revoke
=
>
self
.
manipulate
(
Operation
:
:
Query
cx
permissionDesc
Some
(
p
)
)
_
=
>
p
}
}
}
impl
PermissionsMethods
for
Permissions
{
#
[
allow
(
unrooted_must_root
)
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
Query
(
&
self
cx
:
*
mut
JSContext
permissionDesc
:
*
mut
JSObject
)
-
>
Rc
<
Promise
>
{
self
.
manipulate
(
Operation
:
:
Query
cx
permissionDesc
None
)
}
#
[
allow
(
unrooted_must_root
)
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
Request
(
&
self
cx
:
*
mut
JSContext
permissionDesc
:
*
mut
JSObject
)
-
>
Rc
<
Promise
>
{
self
.
manipulate
(
Operation
:
:
Request
cx
permissionDesc
None
)
}
#
[
allow
(
unrooted_must_root
)
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
Revoke
(
&
self
cx
:
*
mut
JSContext
permissionDesc
:
*
mut
JSObject
)
-
>
Rc
<
Promise
>
{
self
.
manipulate
(
Operation
:
:
Revoke
cx
permissionDesc
None
)
}
}
impl
PermissionAlgorithm
for
Permissions
{
type
Descriptor
=
PermissionDescriptor
;
type
Status
=
PermissionStatus
;
#
[
allow
(
unsafe_code
)
]
fn
create_descriptor
(
cx
:
*
mut
JSContext
permission_descriptor_obj
:
*
mut
JSObject
)
-
>
Result
<
PermissionDescriptor
Error
>
{
rooted
!
(
in
(
cx
)
let
mut
property
=
UndefinedValue
(
)
)
;
property
.
handle_mut
(
)
.
set
(
ObjectValue
(
permission_descriptor_obj
)
)
;
unsafe
{
match
PermissionDescriptor
:
:
new
(
cx
property
.
handle
(
)
)
{
Ok
(
ConversionResult
:
:
Success
(
descriptor
)
)
=
>
Ok
(
descriptor
)
Ok
(
ConversionResult
:
:
Failure
(
error
)
)
=
>
Err
(
Error
:
:
Type
(
error
.
into_owned
(
)
)
)
Err
(
_
)
=
>
Err
(
Error
:
:
Type
(
String
:
:
from
(
ROOT_DESC_CONVERSION_ERROR
)
)
)
}
}
}
fn
permission_query
(
_cx
:
*
mut
JSContext
_promise
:
&
Rc
<
Promise
>
_descriptor
:
&
PermissionDescriptor
status
:
&
PermissionStatus
)
{
status
.
set_state
(
get_descriptor_permission_state
(
status
.
get_query
(
)
None
)
)
;
}
fn
permission_request
(
cx
:
*
mut
JSContext
promise
:
&
Rc
<
Promise
>
descriptor
:
&
PermissionDescriptor
status
:
&
PermissionStatus
)
{
Permissions
:
:
permission_query
(
cx
promise
descriptor
status
)
;
match
status
.
State
(
)
{
PermissionState
:
:
Prompt
=
>
{
let
perm_name
=
status
.
get_query
(
)
;
let
state
=
prompt_user
(
&
format
!
(
"
{
}
{
}
?
"
REQUEST_DIALOG_MESSAGE
perm_name
.
clone
(
)
)
)
;
let
globalscope
=
GlobalScope
:
:
current
(
)
.
expect
(
"
No
current
global
object
"
)
;
globalscope
.
as_window
(
)
.
permission_state_invocation_results
(
)
.
borrow_mut
(
)
.
insert
(
perm_name
.
to_string
(
)
state
)
;
}
_
=
>
return
}
Permissions
:
:
permission_query
(
cx
promise
descriptor
status
)
;
}
fn
permission_revoke
(
_descriptor
:
&
PermissionDescriptor
_status
:
&
PermissionStatus
)
{
}
}
pub
fn
get_descriptor_permission_state
(
permission_name
:
PermissionName
env_settings_obj
:
Option
<
&
GlobalScope
>
)
-
>
PermissionState
{
let
settings
=
match
env_settings_obj
{
Some
(
env_settings_obj
)
=
>
DomRoot
:
:
from_ref
(
env_settings_obj
)
None
=
>
GlobalScope
:
:
current
(
)
.
expect
(
"
No
current
global
object
"
)
}
;
let
state
=
match
allowed_in_nonsecure_contexts
(
&
permission_name
)
{
true
=
>
PermissionState
:
:
Prompt
false
=
>
{
match
PREFS
.
get
(
"
dom
.
permissions
.
testing
.
allowed_in_nonsecure_contexts
"
)
.
as_boolean
(
)
.
unwrap_or
(
false
)
{
true
=
>
PermissionState
:
:
Granted
false
=
>
{
settings
.
as_window
(
)
.
permission_state_invocation_results
(
)
.
borrow_mut
(
)
.
remove
(
&
permission_name
.
to_string
(
)
)
;
prompt_user
(
&
format
!
(
"
The
{
}
{
}
"
permission_name
NONSECURE_DIALOG_MESSAGE
)
)
}
}
}
}
;
if
let
Some
(
prev_result
)
=
settings
.
as_window
(
)
.
permission_state_invocation_results
(
)
.
borrow
(
)
.
get
(
&
permission_name
.
to_string
(
)
)
{
return
prev_result
.
clone
(
)
;
}
settings
.
as_window
(
)
.
permission_state_invocation_results
(
)
.
borrow_mut
(
)
.
insert
(
permission_name
.
to_string
(
)
state
)
;
state
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
prompt_user
(
message
:
&
str
)
-
>
PermissionState
{
if
opts
:
:
get
(
)
.
headless
{
return
PermissionState
:
:
Denied
;
}
match
tinyfiledialogs
:
:
message_box_yes_no
(
DIALOG_TITLE
message
MessageBoxIcon
:
:
Question
YesNo
:
:
No
)
{
YesNo
:
:
Yes
=
>
PermissionState
:
:
Granted
YesNo
:
:
No
=
>
PermissionState
:
:
Denied
}
}
#
[
cfg
(
not
(
target_os
=
"
linux
"
)
)
]
fn
prompt_user
(
_message
:
&
str
)
-
>
PermissionState
{
PermissionState
:
:
Denied
}
fn
allowed_in_nonsecure_contexts
(
permission_name
:
&
PermissionName
)
-
>
bool
{
match
*
permission_name
{
PermissionName
:
:
Geolocation
=
>
true
PermissionName
:
:
Notifications
=
>
true
PermissionName
:
:
Push
=
>
false
PermissionName
:
:
Midi
=
>
true
PermissionName
:
:
Camera
=
>
false
PermissionName
:
:
Microphone
=
>
false
PermissionName
:
:
Speaker
=
>
false
PermissionName
:
:
Device_info
=
>
false
PermissionName
:
:
Background_sync
=
>
false
PermissionName
:
:
Bluetooth
=
>
false
PermissionName
:
:
Persistent_storage
=
>
false
}
}
