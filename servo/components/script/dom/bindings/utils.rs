use
dom
:
:
bindings
:
:
codegen
:
:
InterfaceObjectMap
;
use
dom
:
:
bindings
:
:
codegen
:
:
PrototypeList
;
use
dom
:
:
bindings
:
:
codegen
:
:
PrototypeList
:
:
{
MAX_PROTO_CHAIN_LENGTH
PROTO_OR_IFACE_LENGTH
}
;
use
dom
:
:
bindings
:
:
conversions
:
:
{
DOM_OBJECT_SLOT
is_dom_class
}
;
use
dom
:
:
bindings
:
:
conversions
:
:
{
private_from_proto_check
root_from_handleobject
}
;
use
dom
:
:
bindings
:
:
error
:
:
throw_invalid_this
;
use
dom
:
:
bindings
:
:
inheritance
:
:
TopTypeId
;
use
dom
:
:
bindings
:
:
trace
:
:
trace_object
;
use
dom
:
:
browsingcontext
;
use
dom
:
:
window
;
use
heapsize
:
:
HeapSizeOf
;
use
js
;
use
js
:
:
glue
:
:
{
CallJitGetterOp
CallJitMethodOp
CallJitSetterOp
IsWrapper
}
;
use
js
:
:
glue
:
:
{
GetCrossCompartmentWrapper
WrapperNew
}
;
use
js
:
:
glue
:
:
{
RUST_FUNCTION_VALUE_TO_JITINFO
RUST_JSID_IS_INT
RUST_JSID_IS_STRING
}
;
use
js
:
:
glue
:
:
{
RUST_JSID_TO_INT
RUST_JSID_TO_STRING
UnwrapObject
}
;
use
js
:
:
jsapi
:
:
{
CallArgs
CompartmentOptions
DOMCallbacks
GetGlobalForObjectCrossCompartment
}
;
use
js
:
:
jsapi
:
:
{
HandleId
HandleObject
HandleValue
Heap
JSAutoCompartment
JSClass
JSContext
}
;
use
js
:
:
jsapi
:
:
{
JSJitInfo
JSObject
JSTraceOp
JSTracer
JSVersion
JSWrapObjectCallbacks
}
;
use
js
:
:
jsapi
:
:
{
JS_DeletePropertyById1
JS_EnumerateStandardClasses
JS_FireOnNewGlobalObject
}
;
use
js
:
:
jsapi
:
:
{
JS_ForwardGetPropertyTo
JS_GetClass
JS_GetLatin1StringCharsAndLength
}
;
use
js
:
:
jsapi
:
:
{
JS_GetProperty
JS_GetPrototype
JS_GetReservedSlot
JS_HasProperty
}
;
use
js
:
:
jsapi
:
:
{
JS_HasPropertyById
JS_IsExceptionPending
JS_IsGlobalObject
JS_NewGlobalObject
}
;
use
js
:
:
jsapi
:
:
{
JS_ObjectToOuterObject
JS_ResolveStandardClass
JS_SetProperty
}
;
use
js
:
:
jsapi
:
:
{
JS_SetReservedSlot
JS_StringHasLatin1Chars
MutableHandleValue
ObjectOpResult
}
;
use
js
:
:
jsapi
:
:
{
OnNewGlobalHookOption
RootedObject
}
;
use
js
:
:
jsval
:
:
{
JSVal
}
;
use
js
:
:
jsval
:
:
{
PrivateValue
UndefinedValue
}
;
use
js
:
:
rust
:
:
{
GCMethods
ToString
}
;
use
js
:
:
{
JS_CALLEE
}
;
use
libc
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
os
:
:
raw
:
:
c_void
;
use
std
:
:
ptr
;
use
std
:
:
slice
;
use
util
:
:
non_geckolib
:
:
jsstring_to_str
;
use
util
:
:
prefs
;
pub
struct
WindowProxyHandler
(
pub
*
const
libc
:
:
c_void
)
;
impl
HeapSizeOf
for
WindowProxyHandler
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
#
[
derive
(
JSTraceable
HeapSizeOf
)
]
pub
struct
GlobalStaticData
{
pub
windowproxy_handler
:
WindowProxyHandler
}
impl
GlobalStaticData
{
pub
fn
new
(
)
-
>
GlobalStaticData
{
GlobalStaticData
{
windowproxy_handler
:
browsingcontext
:
:
new_window_proxy_handler
(
)
}
}
}
pub
const
DOM_PROTO_UNFORGEABLE_HOLDER_SLOT
:
u32
=
0
;
pub
const
DOM_PROTOTYPE_SLOT
:
u32
=
js
:
:
JSCLASS_GLOBAL_SLOT_COUNT
;
pub
const
JSCLASS_DOM_GLOBAL
:
u32
=
js
:
:
JSCLASS_USERBIT1
;
#
[
derive
(
Copy
Clone
)
]
pub
struct
DOMClass
{
pub
interface_chain
:
[
PrototypeList
:
:
ID
;
MAX_PROTO_CHAIN_LENGTH
]
pub
type_id
:
TopTypeId
pub
heap_size_of
:
unsafe
fn
(
*
const
c_void
)
-
>
usize
}
unsafe
impl
Sync
for
DOMClass
{
}
#
[
derive
(
Copy
)
]
pub
struct
DOMJSClass
{
pub
base
:
js
:
:
jsapi
:
:
Class
pub
dom_class
:
DOMClass
}
impl
Clone
for
DOMJSClass
{
fn
clone
(
&
self
)
-
>
DOMJSClass
{
*
self
}
}
unsafe
impl
Sync
for
DOMJSClass
{
}
pub
fn
get_proto_or_iface_array
(
global
:
*
mut
JSObject
)
-
>
*
mut
ProtoOrIfaceArray
{
unsafe
{
assert
!
(
(
(
*
JS_GetClass
(
global
)
)
.
flags
&
JSCLASS_DOM_GLOBAL
)
!
=
0
)
;
JS_GetReservedSlot
(
global
DOM_PROTOTYPE_SLOT
)
.
to_private
(
)
as
*
mut
ProtoOrIfaceArray
}
}
pub
type
ProtoOrIfaceArray
=
[
*
mut
JSObject
;
PROTO_OR_IFACE_LENGTH
]
;
pub
fn
get_property_on_prototype
(
cx
:
*
mut
JSContext
proxy
:
HandleObject
id
:
HandleId
found
:
*
mut
bool
vp
:
MutableHandleValue
)
-
>
bool
{
unsafe
{
let
mut
proto
=
RootedObject
:
:
new
(
cx
ptr
:
:
null_mut
(
)
)
;
if
!
JS_GetPrototype
(
cx
proxy
proto
.
handle_mut
(
)
)
|
|
proto
.
ptr
.
is_null
(
)
{
*
found
=
false
;
return
true
;
}
let
mut
has_property
=
false
;
if
!
JS_HasPropertyById
(
cx
proto
.
handle
(
)
id
&
mut
has_property
)
{
return
false
;
}
*
found
=
has_property
;
let
no_output
=
vp
.
ptr
.
is_null
(
)
;
if
!
has_property
|
|
no_output
{
return
true
;
}
JS_ForwardGetPropertyTo
(
cx
proto
.
handle
(
)
id
proxy
vp
)
}
}
pub
fn
get_array_index_from_id
(
_cx
:
*
mut
JSContext
id
:
HandleId
)
-
>
Option
<
u32
>
{
unsafe
{
if
RUST_JSID_IS_INT
(
id
)
{
return
Some
(
RUST_JSID_TO_INT
(
id
)
as
u32
)
;
}
None
}
}
pub
unsafe
fn
find_enum_string_index
(
cx
:
*
mut
JSContext
v
:
HandleValue
values
:
&
[
&
'
static
str
]
)
-
>
Result
<
Option
<
usize
>
(
)
>
{
let
jsstr
=
ToString
(
cx
v
)
;
if
jsstr
.
is_null
(
)
{
return
Err
(
(
)
)
;
}
let
search
=
jsstring_to_str
(
cx
jsstr
)
;
Ok
(
values
.
iter
(
)
.
position
(
|
value
|
search
=
=
*
value
)
)
}
pub
fn
is_platform_object
(
obj
:
*
mut
JSObject
)
-
>
bool
{
unsafe
{
let
mut
clasp
=
JS_GetClass
(
obj
)
;
if
is_dom_class
(
&
*
clasp
)
{
return
true
;
}
if
IsWrapper
(
obj
)
{
let
unwrapped_obj
=
UnwrapObject
(
obj
0
)
;
if
unwrapped_obj
.
is_null
(
)
{
return
false
;
}
clasp
=
js
:
:
jsapi
:
:
JS_GetClass
(
obj
)
;
}
is_dom_class
(
&
*
clasp
)
}
}
pub
fn
get_dictionary_property
(
cx
:
*
mut
JSContext
object
:
HandleObject
property
:
&
str
rval
:
MutableHandleValue
)
-
>
Result
<
bool
(
)
>
{
fn
has_property
(
cx
:
*
mut
JSContext
object
:
HandleObject
property
:
&
CString
found
:
&
mut
bool
)
-
>
bool
{
unsafe
{
JS_HasProperty
(
cx
object
property
.
as_ptr
(
)
found
)
}
}
fn
get_property
(
cx
:
*
mut
JSContext
object
:
HandleObject
property
:
&
CString
value
:
MutableHandleValue
)
-
>
bool
{
unsafe
{
JS_GetProperty
(
cx
object
property
.
as_ptr
(
)
value
)
}
}
let
property
=
CString
:
:
new
(
property
)
.
unwrap
(
)
;
if
object
.
get
(
)
.
is_null
(
)
{
return
Ok
(
false
)
;
}
let
mut
found
=
false
;
if
!
has_property
(
cx
object
&
property
&
mut
found
)
{
return
Err
(
(
)
)
;
}
if
!
found
{
return
Ok
(
false
)
;
}
if
!
get_property
(
cx
object
&
property
rval
)
{
return
Err
(
(
)
)
;
}
Ok
(
true
)
}
pub
fn
set_dictionary_property
(
cx
:
*
mut
JSContext
object
:
HandleObject
property
:
&
str
value
:
HandleValue
)
-
>
Result
<
(
)
(
)
>
{
if
object
.
get
(
)
.
is_null
(
)
{
return
Err
(
(
)
)
;
}
let
property
=
CString
:
:
new
(
property
)
.
unwrap
(
)
;
unsafe
{
if
!
JS_SetProperty
(
cx
object
property
.
as_ptr
(
)
value
)
{
return
Err
(
(
)
)
;
}
}
Ok
(
(
)
)
}
pub
fn
has_property_on_prototype
(
cx
:
*
mut
JSContext
proxy
:
HandleObject
id
:
HandleId
)
-
>
bool
{
let
mut
found
=
false
;
!
get_property_on_prototype
(
cx
proxy
id
&
mut
found
unsafe
{
MutableHandleValue
:
:
from_marked_location
(
ptr
:
:
null_mut
(
)
)
}
)
|
|
found
}
pub
fn
create_dom_global
(
cx
:
*
mut
JSContext
class
:
*
const
JSClass
private
:
*
const
libc
:
:
c_void
trace
:
JSTraceOp
)
-
>
*
mut
JSObject
{
unsafe
{
let
mut
options
=
CompartmentOptions
:
:
default
(
)
;
options
.
version_
=
JSVersion
:
:
JSVERSION_ECMA_5
;
options
.
traceGlobal_
=
trace
;
let
obj
=
RootedObject
:
:
new
(
cx
JS_NewGlobalObject
(
cx
class
ptr
:
:
null_mut
(
)
OnNewGlobalHookOption
:
:
DontFireOnNewGlobalHook
&
options
)
)
;
if
obj
.
ptr
.
is_null
(
)
{
return
ptr
:
:
null_mut
(
)
;
}
JS_SetReservedSlot
(
obj
.
ptr
DOM_OBJECT_SLOT
PrivateValue
(
private
)
)
;
let
proto_array
:
Box
<
ProtoOrIfaceArray
>
=
box
[
0
as
*
mut
JSObject
;
PROTO_OR_IFACE_LENGTH
]
;
JS_SetReservedSlot
(
obj
.
ptr
DOM_PROTOTYPE_SLOT
PrivateValue
(
Box
:
:
into_raw
(
proto_array
)
as
*
const
libc
:
:
c_void
)
)
;
let
_ac
=
JSAutoCompartment
:
:
new
(
cx
obj
.
ptr
)
;
JS_FireOnNewGlobalObject
(
cx
obj
.
handle
(
)
)
;
obj
.
ptr
}
}
/
/
/
Drop
the
resources
held
by
reserved
slots
of
a
global
object
pub
unsafe
fn
finalize_global
(
obj
:
*
mut
JSObject
)
{
let
protolist
=
get_proto_or_iface_array
(
obj
)
;
let
list
=
(
*
protolist
)
.
as_mut_ptr
(
)
;
for
idx
in
0
.
.
PROTO_OR_IFACE_LENGTH
as
isize
{
let
entry
=
list
.
offset
(
idx
)
;
let
value
=
*
entry
;
if
<
*
mut
JSObject
>
:
:
needs_post_barrier
(
value
)
{
<
*
mut
JSObject
>
:
:
relocate
(
entry
)
;
}
}
let
_
:
Box
<
ProtoOrIfaceArray
>
=
Box
:
:
from_raw
(
protolist
)
;
}
/
/
/
Trace
the
resources
held
by
reserved
slots
of
a
global
object
pub
unsafe
fn
trace_global
(
tracer
:
*
mut
JSTracer
obj
:
*
mut
JSObject
)
{
let
array
=
get_proto_or_iface_array
(
obj
)
;
for
proto
in
(
*
array
)
.
iter
(
)
{
if
!
proto
.
is_null
(
)
{
trace_object
(
tracer
"
prototype
"
&
*
(
proto
as
*
const
*
mut
JSObject
as
*
const
Heap
<
*
mut
JSObject
>
)
)
;
}
}
}
/
/
/
Enumerate
lazy
properties
of
a
global
object
.
pub
unsafe
extern
"
C
"
fn
enumerate_global
(
cx
:
*
mut
JSContext
obj
:
HandleObject
)
-
>
bool
{
assert
!
(
JS_IsGlobalObject
(
obj
.
get
(
)
)
)
;
if
!
JS_EnumerateStandardClasses
(
cx
obj
)
{
return
false
;
}
for
init_fun
in
InterfaceObjectMap
:
:
MAP
.
values
(
)
{
init_fun
(
cx
obj
)
;
}
true
}
/
/
/
Resolve
a
lazy
global
property
for
interface
objects
and
named
constructors
.
pub
unsafe
extern
"
C
"
fn
resolve_global
(
cx
:
*
mut
JSContext
obj
:
HandleObject
id
:
HandleId
rval
:
*
mut
bool
)
-
>
bool
{
assert
!
(
JS_IsGlobalObject
(
obj
.
get
(
)
)
)
;
if
!
JS_ResolveStandardClass
(
cx
obj
id
rval
)
{
return
false
;
}
if
*
rval
{
return
true
;
}
if
!
RUST_JSID_IS_STRING
(
id
)
{
*
rval
=
false
;
return
true
;
}
let
string
=
RUST_JSID_TO_STRING
(
id
)
;
if
!
JS_StringHasLatin1Chars
(
string
)
{
*
rval
=
false
;
return
true
;
}
let
mut
length
=
0
;
let
ptr
=
JS_GetLatin1StringCharsAndLength
(
cx
ptr
:
:
null
(
)
string
&
mut
length
)
;
assert
!
(
!
ptr
.
is_null
(
)
)
;
let
bytes
=
slice
:
:
from_raw_parts
(
ptr
length
as
usize
)
;
if
let
Some
(
init_fun
)
=
InterfaceObjectMap
:
:
MAP
.
get
(
bytes
)
{
init_fun
(
cx
obj
)
;
*
rval
=
true
;
}
else
{
*
rval
=
false
;
}
true
}
unsafe
extern
"
C
"
fn
wrap
(
cx
:
*
mut
JSContext
_existing
:
HandleObject
obj
:
HandleObject
)
-
>
*
mut
JSObject
{
/
/
FIXME
terrible
idea
.
need
security
wrappers
/
/
https
:
/
/
github
.
com
/
servo
/
servo
/
issues
/
2382
WrapperNew
(
cx
obj
GetCrossCompartmentWrapper
(
)
ptr
:
:
null
(
)
false
)
}
unsafe
extern
"
C
"
fn
pre_wrap
(
cx
:
*
mut
JSContext
_existing
:
HandleObject
obj
:
HandleObject
_object_passed_to_wrap
:
HandleObject
)
-
>
*
mut
JSObject
{
let
_ac
=
JSAutoCompartment
:
:
new
(
cx
obj
.
get
(
)
)
;
JS_ObjectToOuterObject
(
cx
obj
)
}
/
/
/
Callback
table
for
use
with
JS_SetWrapObjectCallbacks
pub
static
WRAP_CALLBACKS
:
JSWrapObjectCallbacks
=
JSWrapObjectCallbacks
{
wrap
:
Some
(
wrap
)
preWrap
:
Some
(
pre_wrap
)
}
;
/
/
/
Callback
to
outerize
windows
.
pub
unsafe
extern
"
C
"
fn
outerize_global
(
_cx
:
*
mut
JSContext
obj
:
HandleObject
)
-
>
*
mut
JSObject
{
debug
!
(
"
outerizing
"
)
;
let
win
=
root_from_handleobject
:
:
<
window
:
:
Window
>
(
obj
)
.
unwrap
(
)
;
let
context
=
win
.
browsing_context
(
)
;
context
.
window_proxy
(
)
}
/
/
/
Deletes
the
property
id
from
object
.
pub
unsafe
fn
delete_property_by_id
(
cx
:
*
mut
JSContext
object
:
HandleObject
id
:
HandleId
bp
:
*
mut
ObjectOpResult
)
-
>
bool
{
JS_DeletePropertyById1
(
cx
object
id
bp
)
}
unsafe
fn
generic_call
(
cx
:
*
mut
JSContext
argc
:
libc
:
:
c_uint
vp
:
*
mut
JSVal
is_lenient
:
bool
call
:
unsafe
extern
fn
(
*
const
JSJitInfo
*
mut
JSContext
HandleObject
*
mut
libc
:
:
c_void
u32
*
mut
JSVal
)
-
>
bool
)
-
>
bool
{
let
args
=
CallArgs
:
:
from_vp
(
vp
argc
)
;
let
thisobj
=
args
.
thisv
(
)
;
if
!
thisobj
.
get
(
)
.
is_null_or_undefined
(
)
&
&
!
thisobj
.
get
(
)
.
is_object
(
)
{
return
false
;
}
let
obj
=
if
thisobj
.
get
(
)
.
is_object
(
)
{
thisobj
.
get
(
)
.
to_object
(
)
}
else
{
GetGlobalForObjectCrossCompartment
(
JS_CALLEE
(
cx
vp
)
.
to_object_or_null
(
)
)
}
;
let
obj
=
RootedObject
:
:
new
(
cx
obj
)
;
let
info
=
RUST_FUNCTION_VALUE_TO_JITINFO
(
JS_CALLEE
(
cx
vp
)
)
;
let
proto_id
=
(
*
info
)
.
protoID
;
let
depth
=
(
*
info
)
.
depth
;
let
proto_check
=
|
class
:
&
'
static
DOMClass
|
{
class
.
interface_chain
[
depth
as
usize
]
as
u16
=
=
proto_id
}
;
let
this
=
match
private_from_proto_check
(
obj
.
ptr
proto_check
)
{
Ok
(
val
)
=
>
val
Err
(
(
)
)
=
>
{
if
is_lenient
{
debug_assert
!
(
!
JS_IsExceptionPending
(
cx
)
)
;
*
vp
=
UndefinedValue
(
)
;
return
true
;
}
else
{
throw_invalid_this
(
cx
proto_id
)
;
return
false
;
}
}
}
;
call
(
info
cx
obj
.
handle
(
)
this
as
*
mut
libc
:
:
c_void
argc
vp
)
}
/
/
/
Generic
method
of
IDL
interface
.
pub
unsafe
extern
"
C
"
fn
generic_method
(
cx
:
*
mut
JSContext
argc
:
libc
:
:
c_uint
vp
:
*
mut
JSVal
)
-
>
bool
{
generic_call
(
cx
argc
vp
false
CallJitMethodOp
)
}
/
/
/
Generic
getter
of
IDL
interface
.
pub
unsafe
extern
"
C
"
fn
generic_getter
(
cx
:
*
mut
JSContext
argc
:
libc
:
:
c_uint
vp
:
*
mut
JSVal
)
-
>
bool
{
generic_call
(
cx
argc
vp
false
CallJitGetterOp
)
}
/
/
/
Generic
lenient
getter
of
IDL
interface
.
pub
unsafe
extern
"
C
"
fn
generic_lenient_getter
(
cx
:
*
mut
JSContext
argc
:
libc
:
:
c_uint
vp
:
*
mut
JSVal
)
-
>
bool
{
generic_call
(
cx
argc
vp
true
CallJitGetterOp
)
}
unsafe
extern
"
C
"
fn
call_setter
(
info
:
*
const
JSJitInfo
cx
:
*
mut
JSContext
handle
:
HandleObject
this
:
*
mut
libc
:
:
c_void
argc
:
u32
vp
:
*
mut
JSVal
)
-
>
bool
{
if
!
CallJitSetterOp
(
info
cx
handle
this
argc
vp
)
{
return
false
;
}
*
vp
=
UndefinedValue
(
)
;
true
}
/
/
/
Generic
setter
of
IDL
interface
.
pub
unsafe
extern
"
C
"
fn
generic_setter
(
cx
:
*
mut
JSContext
argc
:
libc
:
:
c_uint
vp
:
*
mut
JSVal
)
-
>
bool
{
generic_call
(
cx
argc
vp
false
call_setter
)
}
/
/
/
Generic
lenient
setter
of
IDL
interface
.
pub
unsafe
extern
"
C
"
fn
generic_lenient_setter
(
cx
:
*
mut
JSContext
argc
:
libc
:
:
c_uint
vp
:
*
mut
JSVal
)
-
>
bool
{
generic_call
(
cx
argc
vp
true
call_setter
)
}
unsafe
extern
"
C
"
fn
instance_class_has_proto_at_depth
(
clasp
:
*
const
js
:
:
jsapi
:
:
Class
proto_id
:
u32
depth
:
u32
)
-
>
bool
{
let
domclass
:
*
const
DOMJSClass
=
clasp
as
*
const
_
;
let
domclass
=
&
*
domclass
;
domclass
.
dom_class
.
interface_chain
[
depth
as
usize
]
as
u32
=
=
proto_id
}
#
[
allow
(
missing_docs
)
]
pub
const
DOM_CALLBACKS
:
DOMCallbacks
=
DOMCallbacks
{
instanceClassMatchesProto
:
Some
(
instance_class_has_proto_at_depth
)
}
;
pub
struct
Prefable
<
T
:
'
static
>
{
pub
pref
:
Option
<
&
'
static
str
>
pub
specs
:
&
'
static
[
T
]
pub
terminator
:
bool
}
impl
<
T
>
Prefable
<
T
>
{
pub
fn
specs
(
&
self
)
-
>
&
'
static
[
T
]
{
if
let
Some
(
pref
)
=
self
.
pref
{
if
!
prefs
:
:
get_pref
(
pref
)
.
as_boolean
(
)
.
unwrap_or
(
false
)
{
return
if
self
.
terminator
{
&
self
.
specs
[
self
.
specs
.
len
(
)
-
1
.
.
]
}
else
{
&
[
]
}
;
}
}
self
.
specs
}
}
