use
dom
:
:
bindings
:
:
codegen
:
:
PrototypeList
;
use
dom
:
:
bindings
:
:
codegen
:
:
PrototypeList
:
:
MAX_PROTO_CHAIN_LENGTH
;
use
dom
:
:
bindings
:
:
conversions
:
:
{
native_from_reflector_jsmanaged
is_dom_class
}
;
use
dom
:
:
bindings
:
:
error
:
:
{
Error
ErrorResult
Fallible
throw_type_error
}
;
use
dom
:
:
bindings
:
:
global
:
:
GlobalRef
;
use
dom
:
:
bindings
:
:
js
:
:
{
Temporary
Root
Rootable
}
;
use
dom
:
:
browsercontext
;
use
dom
:
:
window
;
use
util
:
:
namespace
;
use
util
:
:
str
:
:
DOMString
;
use
libc
;
use
libc
:
:
c_uint
;
use
std
:
:
boxed
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
ptr
;
use
js
:
:
glue
:
:
UnwrapObject
;
use
js
:
:
glue
:
:
{
IsWrapper
RUST_JSID_IS_INT
RUST_JSID_TO_INT
}
;
use
js
:
:
jsapi
:
:
{
JS_AlreadyHasOwnProperty
JS_NewFunction
}
;
use
js
:
:
jsapi
:
:
{
JS_DefineProperties
JS_ForwardGetPropertyTo
}
;
use
js
:
:
jsapi
:
:
{
JS_GetClass
JS_LinkConstructorAndPrototype
JS_GetStringCharsAndLength
}
;
use
js
:
:
jsapi
:
:
JSHandleObject
;
use
js
:
:
jsapi
:
:
JS_GetFunctionObject
;
use
js
:
:
jsapi
:
:
{
JS_HasPropertyById
JS_GetPrototype
}
;
use
js
:
:
jsapi
:
:
{
JS_GetProperty
JS_HasProperty
JS_SetProperty
}
;
use
js
:
:
jsapi
:
:
{
JS_DefineFunctions
JS_DefineProperty
}
;
use
js
:
:
jsapi
:
:
{
JS_ValueToString
JS_GetReservedSlot
JS_SetReservedSlot
}
;
use
js
:
:
jsapi
:
:
{
JSContext
JSObject
JSBool
jsid
JSClass
}
;
use
js
:
:
jsapi
:
:
{
JSFunctionSpec
JSPropertySpec
}
;
use
js
:
:
jsapi
:
:
{
JS_NewGlobalObject
JS_InitStandardClasses
}
;
use
js
:
:
jsapi
:
:
JS_DeletePropertyById2
;
use
js
:
:
jsfriendapi
:
:
JS_ObjectToOuterObject
;
use
js
:
:
jsfriendapi
:
:
bindgen
:
:
JS_NewObjectWithUniqueType
;
use
js
:
:
jsval
:
:
JSVal
;
use
js
:
:
jsval
:
:
{
PrivateValue
ObjectValue
NullValue
}
;
use
js
:
:
jsval
:
:
{
Int32Value
UInt32Value
DoubleValue
BooleanValue
UndefinedValue
}
;
use
js
:
:
rust
:
:
with_compartment
;
use
js
:
:
{
JSPROP_ENUMERATE
JSPROP_READONLY
JSPROP_PERMANENT
}
;
use
js
:
:
JSFUN_CONSTRUCTOR
;
use
js
;
use
string_cache
:
:
{
Atom
Namespace
}
;
pub
struct
WindowProxyHandler
(
pub
*
const
libc
:
:
c_void
)
;
#
[
allow
(
raw_pointer_derive
)
]
#
[
jstraceable
]
pub
struct
GlobalStaticData
{
pub
windowproxy_handler
:
WindowProxyHandler
}
impl
GlobalStaticData
{
pub
fn
new
(
)
-
>
GlobalStaticData
{
GlobalStaticData
{
windowproxy_handler
:
browsercontext
:
:
new_window_proxy_handler
(
)
}
}
}
const
DOM_PROTO_INSTANCE_CLASS_SLOT
:
u32
=
0
;
pub
const
DOM_PROTOTYPE_SLOT
:
u32
=
js
:
:
JSCLASS_GLOBAL_SLOT_COUNT
;
pub
const
JSCLASS_DOM_GLOBAL
:
u32
=
js
:
:
JSCLASS_USERBIT1
;
#
[
derive
(
Clone
)
]
pub
enum
ConstantVal
{
IntVal
(
i32
)
UintVal
(
u32
)
DoubleVal
(
f64
)
BoolVal
(
bool
)
NullVal
}
#
[
derive
(
Clone
)
]
pub
struct
ConstantSpec
{
pub
name
:
&
'
static
[
u8
]
pub
value
:
ConstantVal
}
impl
ConstantSpec
{
pub
fn
get_value
(
&
self
)
-
>
JSVal
{
match
self
.
value
{
ConstantVal
:
:
NullVal
=
>
NullValue
(
)
ConstantVal
:
:
IntVal
(
i
)
=
>
Int32Value
(
i
)
ConstantVal
:
:
UintVal
(
u
)
=
>
UInt32Value
(
u
)
ConstantVal
:
:
DoubleVal
(
d
)
=
>
DoubleValue
(
d
)
ConstantVal
:
:
BoolVal
(
b
)
=
>
BooleanValue
(
b
)
}
}
}
pub
struct
NativePropertyHooks
{
pub
native_properties
:
&
'
static
NativeProperties
pub
proto_hooks
:
Option
<
&
'
static
NativePropertyHooks
>
}
#
[
derive
(
Copy
Clone
)
]
pub
struct
DOMClass
{
pub
interface_chain
:
[
PrototypeList
:
:
ID
;
MAX_PROTO_CHAIN_LENGTH
]
pub
native_hooks
:
&
'
static
NativePropertyHooks
}
unsafe
impl
Sync
for
DOMClass
{
}
#
[
derive
(
Copy
)
]
pub
struct
DOMJSClass
{
pub
base
:
js
:
:
Class
pub
dom_class
:
DOMClass
}
impl
Clone
for
DOMJSClass
{
fn
clone
(
&
self
)
-
>
DOMJSClass
{
*
self
}
}
unsafe
impl
Sync
for
DOMJSClass
{
}
pub
fn
get_proto_or_iface_array
(
global
:
*
mut
JSObject
)
-
>
*
mut
*
mut
JSObject
{
unsafe
{
assert
!
(
(
(
*
JS_GetClass
(
global
)
)
.
flags
&
JSCLASS_DOM_GLOBAL
)
!
=
0
)
;
JS_GetReservedSlot
(
global
DOM_PROTOTYPE_SLOT
)
.
to_private
(
)
as
*
mut
*
mut
JSObject
}
}
pub
struct
NativeProperties
{
pub
methods
:
Option
<
&
'
static
[
JSFunctionSpec
]
>
pub
attrs
:
Option
<
&
'
static
[
JSPropertySpec
]
>
pub
consts
:
Option
<
&
'
static
[
ConstantSpec
]
>
pub
static_methods
:
Option
<
&
'
static
[
JSFunctionSpec
]
>
pub
static_attrs
:
Option
<
&
'
static
[
JSPropertySpec
]
>
}
unsafe
impl
Sync
for
NativeProperties
{
}
pub
type
NonNullJSNative
=
unsafe
extern
"
C
"
fn
(
arg1
:
*
mut
JSContext
arg2
:
c_uint
arg3
:
*
mut
JSVal
)
-
>
JSBool
;
pub
fn
do_create_interface_objects
(
cx
:
*
mut
JSContext
global
:
*
mut
JSObject
receiver
:
*
mut
JSObject
proto_proto
:
*
mut
JSObject
proto_class
:
Option
<
&
'
static
JSClass
>
constructor
:
Option
<
(
NonNullJSNative
&
'
static
str
u32
)
>
dom_class
:
*
const
DOMClass
members
:
&
'
static
NativeProperties
)
-
>
*
mut
JSObject
{
unsafe
{
let
proto
=
match
proto_class
{
Some
(
proto_class
)
=
>
{
let
proto
=
create_interface_prototype_object
(
cx
global
proto_proto
proto_class
members
)
;
JS_SetReservedSlot
(
proto
DOM_PROTO_INSTANCE_CLASS_SLOT
PrivateValue
(
dom_class
as
*
const
libc
:
:
c_void
)
)
;
proto
}
None
=
>
ptr
:
:
null_mut
(
)
}
;
if
let
Some
(
(
native
name
nargs
)
)
=
constructor
{
let
s
=
CString
:
:
new
(
name
)
.
unwrap
(
)
;
create_interface_object
(
cx
global
receiver
native
nargs
proto
members
s
.
as_ptr
(
)
)
}
proto
}
}
fn
create_interface_object
(
cx
:
*
mut
JSContext
global
:
*
mut
JSObject
receiver
:
*
mut
JSObject
constructor_native
:
NonNullJSNative
ctor_nargs
:
u32
proto
:
*
mut
JSObject
members
:
&
'
static
NativeProperties
name
:
*
const
libc
:
:
c_char
)
{
unsafe
{
let
fun
=
JS_NewFunction
(
cx
Some
(
constructor_native
)
ctor_nargs
JSFUN_CONSTRUCTOR
global
name
)
;
assert
!
(
!
fun
.
is_null
(
)
)
;
let
constructor
=
JS_GetFunctionObject
(
fun
)
;
assert
!
(
!
constructor
.
is_null
(
)
)
;
if
let
Some
(
static_methods
)
=
members
.
static_methods
{
define_methods
(
cx
constructor
static_methods
)
;
}
if
let
Some
(
static_properties
)
=
members
.
static_attrs
{
define_properties
(
cx
constructor
static_properties
)
;
}
if
let
Some
(
constants
)
=
members
.
consts
{
define_constants
(
cx
constructor
constants
)
;
}
if
!
proto
.
is_null
(
)
{
assert
!
(
JS_LinkConstructorAndPrototype
(
cx
constructor
proto
)
!
=
0
)
;
}
let
mut
already_defined
=
0
;
assert
!
(
JS_AlreadyHasOwnProperty
(
cx
receiver
name
&
mut
already_defined
)
!
=
0
)
;
if
already_defined
=
=
0
{
assert
!
(
JS_DefineProperty
(
cx
receiver
name
ObjectValue
(
&
*
constructor
)
None
None
0
)
!
=
0
)
;
}
}
}
fn
define_constants
(
cx
:
*
mut
JSContext
obj
:
*
mut
JSObject
constants
:
&
'
static
[
ConstantSpec
]
)
{
for
spec
in
constants
.
iter
(
)
{
unsafe
{
assert
!
(
JS_DefineProperty
(
cx
obj
spec
.
name
.
as_ptr
(
)
as
*
const
libc
:
:
c_char
spec
.
get_value
(
)
None
None
JSPROP_ENUMERATE
|
JSPROP_READONLY
|
JSPROP_PERMANENT
)
!
=
0
)
;
}
}
}
fn
define_methods
(
cx
:
*
mut
JSContext
obj
:
*
mut
JSObject
methods
:
&
'
static
[
JSFunctionSpec
]
)
{
unsafe
{
assert
!
(
JS_DefineFunctions
(
cx
obj
methods
.
as_ptr
(
)
)
!
=
0
)
;
}
}
fn
define_properties
(
cx
:
*
mut
JSContext
obj
:
*
mut
JSObject
properties
:
&
'
static
[
JSPropertySpec
]
)
{
unsafe
{
assert
!
(
JS_DefineProperties
(
cx
obj
properties
.
as_ptr
(
)
)
!
=
0
)
;
}
}
fn
create_interface_prototype_object
(
cx
:
*
mut
JSContext
global
:
*
mut
JSObject
parent_proto
:
*
mut
JSObject
proto_class
:
&
'
static
JSClass
members
:
&
'
static
NativeProperties
)
-
>
*
mut
JSObject
{
unsafe
{
let
our_proto
=
JS_NewObjectWithUniqueType
(
cx
proto_class
&
*
parent_proto
&
*
global
)
;
assert
!
(
!
our_proto
.
is_null
(
)
)
;
if
let
Some
(
methods
)
=
members
.
methods
{
define_methods
(
cx
our_proto
methods
)
;
}
if
let
Some
(
properties
)
=
members
.
attrs
{
define_properties
(
cx
our_proto
properties
)
;
}
if
let
Some
(
constants
)
=
members
.
consts
{
define_constants
(
cx
our_proto
constants
)
;
}
return
our_proto
;
}
}
pub
unsafe
extern
fn
throwing_constructor
(
cx
:
*
mut
JSContext
_argc
:
c_uint
_vp
:
*
mut
JSVal
)
-
>
JSBool
{
throw_type_error
(
cx
"
Illegal
constructor
.
"
)
;
return
0
;
}
type
ProtoOrIfaceArray
=
[
*
mut
JSObject
;
PrototypeList
:
:
ID
:
:
Count
as
usize
]
;
pub
fn
initialize_global
(
global
:
*
mut
JSObject
)
{
let
proto_array
:
Box
<
ProtoOrIfaceArray
>
=
box
(
)
(
[
0
as
*
mut
JSObject
;
PrototypeList
:
:
ID
:
:
Count
as
usize
]
)
;
unsafe
{
assert
!
(
(
(
*
JS_GetClass
(
global
)
)
.
flags
&
JSCLASS_DOM_GLOBAL
)
!
=
0
)
;
let
box_
=
boxed
:
:
into_raw
(
proto_array
)
;
JS_SetReservedSlot
(
global
DOM_PROTOTYPE_SLOT
PrivateValue
(
box_
as
*
const
libc
:
:
c_void
)
)
;
}
}
pub
trait
Reflectable
{
fn
reflector
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Reflector
;
}
pub
fn
reflect_dom_object
<
T
:
Reflectable
>
(
obj
:
Box
<
T
>
global
:
GlobalRef
wrap_fn
:
extern
"
Rust
"
fn
(
*
mut
JSContext
GlobalRef
Box
<
T
>
)
-
>
Temporary
<
T
>
)
-
>
Temporary
<
T
>
{
wrap_fn
(
global
.
get_cx
(
)
global
obj
)
}
#
[
allow
(
raw_pointer_derive
unrooted_must_root
unused_attributes
)
]
#
[
derive
(
PartialEq
)
]
#
[
must_root
]
#
[
servo_lang
=
"
reflector
"
]
pub
struct
Reflector
{
object
:
Cell
<
*
mut
JSObject
>
}
impl
Reflector
{
#
[
inline
]
pub
fn
get_jsobject
(
&
self
)
-
>
*
mut
JSObject
{
self
.
object
.
get
(
)
}
pub
fn
set_jsobject
(
&
self
object
:
*
mut
JSObject
)
{
assert
!
(
self
.
object
.
get
(
)
.
is_null
(
)
)
;
assert
!
(
!
object
.
is_null
(
)
)
;
self
.
object
.
set
(
object
)
;
}
pub
unsafe
fn
rootable
(
&
self
)
-
>
*
mut
*
mut
JSObject
{
self
.
object
.
as_unsafe_cell
(
)
.
get
(
)
}
pub
fn
new
(
)
-
>
Reflector
{
Reflector
{
object
:
Cell
:
:
new
(
ptr
:
:
null_mut
(
)
)
}
}
}
pub
fn
get_property_on_prototype
(
cx
:
*
mut
JSContext
proxy
:
*
mut
JSObject
id
:
jsid
found
:
*
mut
bool
vp
:
*
mut
JSVal
)
-
>
bool
{
unsafe
{
let
proto
=
JS_GetPrototype
(
proxy
)
;
if
proto
.
is_null
(
)
{
*
found
=
false
;
return
true
;
}
let
mut
has_property
=
0
;
if
JS_HasPropertyById
(
cx
proto
id
&
mut
has_property
)
=
=
0
{
return
false
;
}
*
found
=
has_property
!
=
0
;
let
no_output
=
vp
.
is_null
(
)
;
if
has_property
=
=
0
|
|
no_output
{
return
true
;
}
JS_ForwardGetPropertyTo
(
cx
proto
id
proxy
vp
)
!
=
0
}
}
pub
fn
get_array_index_from_id
(
_cx
:
*
mut
JSContext
id
:
jsid
)
-
>
Option
<
u32
>
{
unsafe
{
if
RUST_JSID_IS_INT
(
id
)
!
=
0
{
return
Some
(
RUST_JSID_TO_INT
(
id
)
as
u32
)
;
}
return
None
;
}
}
pub
fn
find_enum_string_index
(
cx
:
*
mut
JSContext
v
:
JSVal
values
:
&
[
&
'
static
str
]
)
-
>
Result
<
Option
<
usize
>
(
)
>
{
unsafe
{
let
jsstr
=
JS_ValueToString
(
cx
v
)
;
if
jsstr
.
is_null
(
)
{
return
Err
(
(
)
)
;
}
let
mut
length
=
0
;
let
chars
=
JS_GetStringCharsAndLength
(
cx
jsstr
&
mut
length
)
;
if
chars
.
is_null
(
)
{
return
Err
(
(
)
)
;
}
Ok
(
values
.
iter
(
)
.
position
(
|
value
|
{
value
.
len
(
)
=
=
length
as
usize
&
&
(
0
.
.
length
as
usize
)
.
all
(
|
j
|
{
value
.
as_bytes
(
)
[
j
]
as
u16
=
=
*
chars
.
offset
(
j
as
isize
)
}
)
}
)
)
}
}
pub
fn
is_platform_object
(
obj
:
*
mut
JSObject
)
-
>
bool
{
unsafe
{
let
mut
clasp
=
JS_GetClass
(
obj
)
;
if
is_dom_class
(
&
*
clasp
)
{
return
true
;
}
if
IsWrapper
(
obj
)
=
=
1
{
let
unwrapped_obj
=
UnwrapObject
(
obj
0
ptr
:
:
null_mut
(
)
)
;
if
unwrapped_obj
.
is_null
(
)
{
return
false
;
}
clasp
=
js
:
:
jsapi
:
:
JS_GetClass
(
obj
)
;
}
return
is_dom_class
(
&
*
clasp
)
;
}
}
pub
fn
get_dictionary_property
(
cx
:
*
mut
JSContext
object
:
*
mut
JSObject
property
:
&
str
)
-
>
Result
<
Option
<
JSVal
>
(
)
>
{
fn
has_property
(
cx
:
*
mut
JSContext
object
:
*
mut
JSObject
property
:
&
CString
found
:
&
mut
JSBool
)
-
>
bool
{
unsafe
{
JS_HasProperty
(
cx
object
property
.
as_ptr
(
)
found
)
!
=
0
}
}
fn
get_property
(
cx
:
*
mut
JSContext
object
:
*
mut
JSObject
property
:
&
CString
value
:
&
mut
JSVal
)
-
>
bool
{
unsafe
{
JS_GetProperty
(
cx
object
property
.
as_ptr
(
)
value
)
!
=
0
}
}
let
property
=
CString
:
:
new
(
property
)
.
unwrap
(
)
;
if
object
.
is_null
(
)
{
return
Ok
(
None
)
;
}
let
mut
found
:
JSBool
=
0
;
if
!
has_property
(
cx
object
&
property
&
mut
found
)
{
return
Err
(
(
)
)
;
}
if
found
=
=
0
{
return
Ok
(
None
)
;
}
let
mut
value
=
NullValue
(
)
;
if
!
get_property
(
cx
object
&
property
&
mut
value
)
{
return
Err
(
(
)
)
;
}
Ok
(
Some
(
value
)
)
}
pub
fn
set_dictionary_property
(
cx
:
*
mut
JSContext
object
:
*
mut
JSObject
property
:
&
str
value
:
&
mut
JSVal
)
-
>
Result
<
(
)
(
)
>
{
if
object
.
is_null
(
)
{
return
Err
(
(
)
)
;
}
let
property
=
CString
:
:
new
(
property
)
.
unwrap
(
)
;
unsafe
{
if
JS_SetProperty
(
cx
object
property
.
as_ptr
(
)
value
)
=
=
0
{
return
Err
(
(
)
)
;
}
}
Ok
(
(
)
)
}
pub
fn
has_property_on_prototype
(
cx
:
*
mut
JSContext
proxy
:
*
mut
JSObject
id
:
jsid
)
-
>
bool
{
let
mut
found
=
false
;
return
!
get_property_on_prototype
(
cx
proxy
id
&
mut
found
ptr
:
:
null_mut
(
)
)
|
|
found
;
}
pub
fn
create_dom_global
(
cx
:
*
mut
JSContext
class
:
*
const
JSClass
)
-
>
*
mut
JSObject
{
unsafe
{
let
obj
=
JS_NewGlobalObject
(
cx
class
ptr
:
:
null_mut
(
)
)
;
if
obj
.
is_null
(
)
{
return
ptr
:
:
null_mut
(
)
;
}
with_compartment
(
cx
obj
|
|
{
JS_InitStandardClasses
(
cx
obj
)
;
}
)
;
initialize_global
(
obj
)
;
obj
}
}
pub
unsafe
fn
finalize_global
(
obj
:
*
mut
JSObject
)
{
let
_
:
Box
<
ProtoOrIfaceArray
>
=
Box
:
:
from_raw
(
get_proto_or_iface_array
(
obj
)
as
*
mut
ProtoOrIfaceArray
)
;
}
pub
unsafe
extern
fn
wrap_for_same_compartment
(
cx
:
*
mut
JSContext
obj
:
*
mut
JSObject
)
-
>
*
mut
JSObject
{
JS_ObjectToOuterObject
(
cx
obj
)
}
pub
unsafe
extern
fn
pre_wrap
(
cx
:
*
mut
JSContext
_scope
:
*
mut
JSObject
obj
:
*
mut
JSObject
_flags
:
c_uint
)
-
>
*
mut
JSObject
{
JS_ObjectToOuterObject
(
cx
obj
)
}
pub
extern
fn
outerize_global
(
_cx
:
*
mut
JSContext
obj
:
JSHandleObject
)
-
>
*
mut
JSObject
{
unsafe
{
debug
!
(
"
outerizing
"
)
;
let
obj
=
*
obj
.
unnamed_field1
;
let
win
:
Root
<
window
:
:
Window
>
=
native_from_reflector_jsmanaged
(
obj
)
.
unwrap
(
)
.
root
(
)
;
let
win
=
win
.
r
(
)
;
let
context
=
win
.
browser_context
(
)
;
context
.
as_ref
(
)
.
unwrap
(
)
.
window_proxy
(
)
}
}
pub
unsafe
fn
delete_property_by_id
(
cx
:
*
mut
JSContext
object
:
*
mut
JSObject
id
:
jsid
bp
:
&
mut
bool
)
-
>
bool
{
let
mut
value
=
UndefinedValue
(
)
;
if
JS_DeletePropertyById2
(
cx
object
id
&
mut
value
)
=
=
0
{
return
false
;
}
*
bp
=
value
.
to_boolean
(
)
;
return
true
;
}
pub
fn
validate_qualified_name
(
qualified_name
:
&
str
)
-
>
ErrorResult
{
match
xml_name_type
(
qualified_name
)
{
XMLName
:
:
InvalidXMLName
=
>
{
return
Err
(
Error
:
:
InvalidCharacter
)
;
}
XMLName
:
:
Name
=
>
{
return
Err
(
Error
:
:
Namespace
)
;
}
XMLName
:
:
QName
=
>
Ok
(
(
)
)
}
}
pub
fn
validate_and_extract
(
namespace
:
Option
<
DOMString
>
qualified_name
:
&
str
)
-
>
Fallible
<
(
Namespace
Option
<
Atom
>
Atom
)
>
{
let
namespace
=
namespace
:
:
from_domstring
(
namespace
)
;
try
!
(
validate_qualified_name
(
qualified_name
)
)
;
let
colon
=
'
:
'
;
let
mut
parts
=
qualified_name
.
splitn
(
2
colon
)
;
let
(
maybe_prefix
local_name
)
=
{
let
maybe_prefix
=
parts
.
next
(
)
;
let
maybe_local_name
=
parts
.
next
(
)
;
debug_assert
!
(
parts
.
next
(
)
.
is_none
(
)
)
;
if
let
Some
(
local_name
)
=
maybe_local_name
{
debug_assert
!
(
!
maybe_prefix
.
unwrap
(
)
.
is_empty
(
)
)
;
(
maybe_prefix
local_name
)
}
else
{
(
None
maybe_prefix
.
unwrap
(
)
)
}
}
;
debug_assert
!
(
!
local_name
.
contains
(
colon
)
)
;
match
(
namespace
maybe_prefix
)
{
(
ns
!
(
"
"
)
Some
(
_
)
)
=
>
{
/
/
Step
6
.
Err
(
Error
:
:
Namespace
)
}
(
ref
ns
Some
(
"
xml
"
)
)
if
ns
!
=
&
ns
!
(
XML
)
=
>
{
/
/
Step
7
.
Err
(
Error
:
:
Namespace
)
}
(
ref
ns
p
)
if
ns
!
=
&
ns
!
(
XMLNS
)
&
&
(
qualified_name
=
=
"
xmlns
"
|
|
p
=
=
Some
(
"
xmlns
"
)
)
=
>
{
/
/
Step
8
.
Err
(
Error
:
:
Namespace
)
}
(
ns
!
(
XMLNS
)
p
)
if
qualified_name
!
=
"
xmlns
"
&
&
p
!
=
Some
(
"
xmlns
"
)
=
>
{
/
/
Step
9
.
Err
(
Error
:
:
Namespace
)
}
(
ns
p
)
=
>
{
/
/
Step
10
.
Ok
(
(
ns
p
.
map
(
Atom
:
:
from_slice
)
Atom
:
:
from_slice
(
local_name
)
)
)
}
}
}
/
/
/
Results
of
xml_name_type
.
#
[
derive
(
PartialEq
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
XMLName
{
QName
Name
InvalidXMLName
}
/
/
/
Check
if
an
element
name
is
valid
.
See
http
:
/
/
www
.
w3
.
org
/
TR
/
xml
/
#
NT
-
Name
/
/
/
for
details
.
pub
fn
xml_name_type
(
name
:
&
str
)
-
>
XMLName
{
fn
is_valid_start
(
c
:
char
)
-
>
bool
{
match
c
{
'
:
'
|
'
A
'
.
.
.
'
Z
'
|
'
_
'
|
'
a
'
.
.
.
'
z
'
|
'
\
u
{
C0
}
'
.
.
.
'
\
u
{
D6
}
'
|
'
\
u
{
D8
}
'
.
.
.
'
\
u
{
F6
}
'
|
'
\
u
{
F8
}
'
.
.
.
'
\
u
{
2FF
}
'
|
'
\
u
{
370
}
'
.
.
.
'
\
u
{
37D
}
'
|
'
\
u
{
37F
}
'
.
.
.
'
\
u
{
1FFF
}
'
|
'
\
u
{
200C
}
'
.
.
.
'
\
u
{
200D
}
'
|
'
\
u
{
2070
}
'
.
.
.
'
\
u
{
218F
}
'
|
'
\
u
{
2C00
}
'
.
.
.
'
\
u
{
2FEF
}
'
|
'
\
u
{
3001
}
'
.
.
.
'
\
u
{
D7FF
}
'
|
'
\
u
{
F900
}
'
.
.
.
'
\
u
{
FDCF
}
'
|
'
\
u
{
FDF0
}
'
.
.
.
'
\
u
{
FFFD
}
'
|
'
\
u
{
10000
}
'
.
.
.
'
\
u
{
EFFFF
}
'
=
>
true
_
=
>
false
}
}
fn
is_valid_continuation
(
c
:
char
)
-
>
bool
{
is_valid_start
(
c
)
|
|
match
c
{
'
-
'
|
'
.
'
|
'
0
'
.
.
.
'
9
'
|
'
\
u
{
B7
}
'
|
'
\
u
{
300
}
'
.
.
.
'
\
u
{
36F
}
'
|
'
\
u
{
203F
}
'
.
.
.
'
\
u
{
2040
}
'
=
>
true
_
=
>
false
}
}
let
mut
iter
=
name
.
chars
(
)
;
let
mut
non_qname_colons
=
false
;
let
mut
seen_colon
=
false
;
let
mut
last
=
match
iter
.
next
(
)
{
None
=
>
return
XMLName
:
:
InvalidXMLName
Some
(
c
)
=
>
{
if
!
is_valid_start
(
c
)
{
return
XMLName
:
:
InvalidXMLName
;
}
if
c
=
=
'
:
'
{
non_qname_colons
=
true
;
}
c
}
}
;
for
c
in
iter
{
if
!
is_valid_continuation
(
c
)
{
return
XMLName
:
:
InvalidXMLName
;
}
if
c
=
=
'
:
'
{
match
seen_colon
{
true
=
>
non_qname_colons
=
true
false
=
>
seen_colon
=
true
}
}
last
=
c
}
if
last
=
=
'
:
'
{
non_qname_colons
=
true
}
match
non_qname_colons
{
false
=
>
XMLName
:
:
QName
true
=
>
XMLName
:
:
Name
}
}
