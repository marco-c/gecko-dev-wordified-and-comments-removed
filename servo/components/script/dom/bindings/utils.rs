use
dom
:
:
bindings
:
:
codegen
:
:
InterfaceObjectMap
;
use
dom
:
:
bindings
:
:
codegen
:
:
PrototypeList
;
use
dom
:
:
bindings
:
:
codegen
:
:
PrototypeList
:
:
{
MAX_PROTO_CHAIN_LENGTH
PROTO_OR_IFACE_LENGTH
}
;
use
dom
:
:
bindings
:
:
conversions
:
:
{
jsstring_to_str
private_from_proto_check
}
;
use
dom
:
:
bindings
:
:
error
:
:
throw_invalid_this
;
use
dom
:
:
bindings
:
:
inheritance
:
:
TopTypeId
;
use
dom
:
:
bindings
:
:
str
:
:
DOMString
;
use
dom
:
:
bindings
:
:
trace
:
:
trace_object
;
use
dom
:
:
windowproxy
;
use
js
;
use
js
:
:
JS_CALLEE
;
use
js
:
:
glue
:
:
{
CallJitGetterOp
CallJitMethodOp
CallJitSetterOp
IsWrapper
}
;
use
js
:
:
glue
:
:
{
GetCrossCompartmentWrapper
WrapperNew
}
;
use
js
:
:
glue
:
:
{
RUST_FUNCTION_VALUE_TO_JITINFO
RUST_JSID_IS_INT
RUST_JSID_IS_STRING
}
;
use
js
:
:
glue
:
:
{
RUST_JSID_TO_INT
RUST_JSID_TO_STRING
UnwrapObject
}
;
use
js
:
:
jsapi
:
:
{
CallArgs
DOMCallbacks
GetGlobalForObjectCrossCompartment
}
;
use
js
:
:
jsapi
:
:
{
HandleId
HandleObject
HandleValue
Heap
JSAutoCompartment
JSContext
}
;
use
js
:
:
jsapi
:
:
{
JSJitInfo
JSObject
JSTracer
JSWrapObjectCallbacks
}
;
use
js
:
:
jsapi
:
:
{
JS_DeletePropertyById
JS_EnumerateStandardClasses
}
;
use
js
:
:
jsapi
:
:
{
JS_ForwardGetPropertyTo
JS_GetLatin1StringCharsAndLength
}
;
use
js
:
:
jsapi
:
:
{
JS_GetProperty
JS_GetPrototype
JS_GetReservedSlot
JS_HasProperty
}
;
use
js
:
:
jsapi
:
:
{
JS_HasPropertyById
JS_IsExceptionPending
JS_IsGlobalObject
}
;
use
js
:
:
jsapi
:
:
{
JS_ResolveStandardClass
JS_SetProperty
ToWindowProxyIfWindow
}
;
use
js
:
:
jsapi
:
:
{
JS_StringHasLatin1Chars
MutableHandleValue
ObjectOpResult
}
;
use
js
:
:
jsval
:
:
{
JSVal
UndefinedValue
}
;
use
js
:
:
rust
:
:
{
GCMethods
ToString
get_object_class
is_dom_class
}
;
use
libc
;
use
malloc_size_of
:
:
{
MallocSizeOf
MallocSizeOfOps
}
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
os
:
:
raw
:
:
{
c_char
c_void
}
;
use
std
:
:
ptr
;
use
std
:
:
slice
;
pub
struct
WindowProxyHandler
(
pub
*
const
libc
:
:
c_void
)
;
impl
MallocSizeOf
for
WindowProxyHandler
{
fn
size_of
(
&
self
_ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
0
}
}
#
[
derive
(
JSTraceable
MallocSizeOf
)
]
pub
struct
GlobalStaticData
{
pub
windowproxy_handler
:
WindowProxyHandler
}
impl
GlobalStaticData
{
pub
fn
new
(
)
-
>
GlobalStaticData
{
GlobalStaticData
{
windowproxy_handler
:
windowproxy
:
:
new_window_proxy_handler
(
)
}
}
}
pub
const
DOM_PROTO_UNFORGEABLE_HOLDER_SLOT
:
u32
=
0
;
pub
const
DOM_PROTOTYPE_SLOT
:
u32
=
js
:
:
JSCLASS_GLOBAL_SLOT_COUNT
;
pub
const
JSCLASS_DOM_GLOBAL
:
u32
=
js
:
:
JSCLASS_USERBIT1
;
#
[
derive
(
Clone
Copy
)
]
pub
struct
DOMClass
{
pub
interface_chain
:
[
PrototypeList
:
:
ID
;
MAX_PROTO_CHAIN_LENGTH
]
pub
type_id
:
TopTypeId
pub
malloc_size_of
:
unsafe
fn
(
ops
:
&
mut
MallocSizeOfOps
*
const
c_void
)
-
>
usize
pub
global
:
InterfaceObjectMap
:
:
Globals
}
unsafe
impl
Sync
for
DOMClass
{
}
#
[
derive
(
Copy
)
]
pub
struct
DOMJSClass
{
pub
base
:
js
:
:
jsapi
:
:
JSClass
pub
dom_class
:
DOMClass
}
impl
Clone
for
DOMJSClass
{
fn
clone
(
&
self
)
-
>
DOMJSClass
{
*
self
}
}
unsafe
impl
Sync
for
DOMJSClass
{
}
pub
fn
get_proto_or_iface_array
(
global
:
*
mut
JSObject
)
-
>
*
mut
ProtoOrIfaceArray
{
unsafe
{
assert_ne
!
(
(
(
*
get_object_class
(
global
)
)
.
flags
&
JSCLASS_DOM_GLOBAL
)
0
)
;
JS_GetReservedSlot
(
global
DOM_PROTOTYPE_SLOT
)
.
to_private
(
)
as
*
mut
ProtoOrIfaceArray
}
}
pub
type
ProtoOrIfaceArray
=
[
*
mut
JSObject
;
PROTO_OR_IFACE_LENGTH
]
;
pub
unsafe
fn
get_property_on_prototype
(
cx
:
*
mut
JSContext
proxy
:
HandleObject
receiver
:
HandleValue
id
:
HandleId
found
:
*
mut
bool
vp
:
MutableHandleValue
)
-
>
bool
{
rooted
!
(
in
(
cx
)
let
mut
proto
=
ptr
:
:
null_mut
:
:
<
JSObject
>
(
)
)
;
if
!
JS_GetPrototype
(
cx
proxy
proto
.
handle_mut
(
)
)
|
|
proto
.
is_null
(
)
{
*
found
=
false
;
return
true
;
}
let
mut
has_property
=
false
;
if
!
JS_HasPropertyById
(
cx
proto
.
handle
(
)
id
&
mut
has_property
)
{
return
false
;
}
*
found
=
has_property
;
let
no_output
=
vp
.
ptr
.
is_null
(
)
;
if
!
has_property
|
|
no_output
{
return
true
;
}
JS_ForwardGetPropertyTo
(
cx
proto
.
handle
(
)
id
receiver
vp
)
}
pub
fn
get_array_index_from_id
(
_cx
:
*
mut
JSContext
id
:
HandleId
)
-
>
Option
<
u32
>
{
unsafe
{
if
RUST_JSID_IS_INT
(
id
)
{
return
Some
(
RUST_JSID_TO_INT
(
id
)
as
u32
)
;
}
None
}
}
pub
unsafe
fn
find_enum_value
<
'
a
T
>
(
cx
:
*
mut
JSContext
v
:
HandleValue
pairs
:
&
'
a
[
(
&
'
static
str
T
)
]
)
-
>
Result
<
(
Option
<
&
'
a
T
>
DOMString
)
(
)
>
{
let
jsstr
=
ToString
(
cx
v
)
;
if
jsstr
.
is_null
(
)
{
return
Err
(
(
)
)
;
}
let
search
=
jsstring_to_str
(
cx
jsstr
)
;
Ok
(
(
pairs
.
iter
(
)
.
find
(
|
&
&
(
key
_
)
|
search
=
=
*
key
)
.
map
(
|
&
(
_
ref
ev
)
|
ev
)
search
)
)
}
pub
fn
is_platform_object
(
obj
:
*
mut
JSObject
)
-
>
bool
{
unsafe
{
let
mut
clasp
=
get_object_class
(
obj
)
;
if
is_dom_class
(
&
*
clasp
)
{
return
true
;
}
if
IsWrapper
(
obj
)
{
let
unwrapped_obj
=
UnwrapObject
(
obj
0
)
;
if
unwrapped_obj
.
is_null
(
)
{
return
false
;
}
clasp
=
get_object_class
(
obj
)
;
}
is_dom_class
(
&
*
clasp
)
}
}
pub
fn
get_dictionary_property
(
cx
:
*
mut
JSContext
object
:
HandleObject
property
:
&
str
rval
:
MutableHandleValue
)
-
>
Result
<
bool
(
)
>
{
fn
has_property
(
cx
:
*
mut
JSContext
object
:
HandleObject
property
:
&
CString
found
:
&
mut
bool
)
-
>
bool
{
unsafe
{
JS_HasProperty
(
cx
object
property
.
as_ptr
(
)
found
)
}
}
fn
get_property
(
cx
:
*
mut
JSContext
object
:
HandleObject
property
:
&
CString
value
:
MutableHandleValue
)
-
>
bool
{
unsafe
{
JS_GetProperty
(
cx
object
property
.
as_ptr
(
)
value
)
}
}
let
property
=
CString
:
:
new
(
property
)
.
unwrap
(
)
;
if
object
.
get
(
)
.
is_null
(
)
{
return
Ok
(
false
)
;
}
let
mut
found
=
false
;
if
!
has_property
(
cx
object
&
property
&
mut
found
)
{
return
Err
(
(
)
)
;
}
if
!
found
{
return
Ok
(
false
)
;
}
if
!
get_property
(
cx
object
&
property
rval
)
{
return
Err
(
(
)
)
;
}
Ok
(
true
)
}
pub
fn
set_dictionary_property
(
cx
:
*
mut
JSContext
object
:
HandleObject
property
:
&
str
value
:
HandleValue
)
-
>
Result
<
(
)
(
)
>
{
if
object
.
get
(
)
.
is_null
(
)
{
return
Err
(
(
)
)
;
}
let
property
=
CString
:
:
new
(
property
)
.
unwrap
(
)
;
unsafe
{
if
!
JS_SetProperty
(
cx
object
property
.
as_ptr
(
)
value
)
{
return
Err
(
(
)
)
;
}
}
Ok
(
(
)
)
}
pub
unsafe
fn
has_property_on_prototype
(
cx
:
*
mut
JSContext
proxy
:
HandleObject
id
:
HandleId
found
:
&
mut
bool
)
-
>
bool
{
rooted
!
(
in
(
cx
)
let
mut
proto
=
ptr
:
:
null_mut
:
:
<
JSObject
>
(
)
)
;
if
!
JS_GetPrototype
(
cx
proxy
proto
.
handle_mut
(
)
)
{
return
false
;
}
assert
!
(
!
proto
.
is_null
(
)
)
;
JS_HasPropertyById
(
cx
proto
.
handle
(
)
id
found
)
}
pub
unsafe
fn
finalize_global
(
obj
:
*
mut
JSObject
)
{
let
protolist
=
get_proto_or_iface_array
(
obj
)
;
let
list
=
(
*
protolist
)
.
as_mut_ptr
(
)
;
for
idx
in
0
.
.
PROTO_OR_IFACE_LENGTH
as
isize
{
let
entry
=
list
.
offset
(
idx
)
;
let
value
=
*
entry
;
<
*
mut
JSObject
>
:
:
post_barrier
(
entry
value
ptr
:
:
null_mut
(
)
)
;
}
let
_
:
Box
<
ProtoOrIfaceArray
>
=
Box
:
:
from_raw
(
protolist
)
;
}
pub
unsafe
fn
trace_global
(
tracer
:
*
mut
JSTracer
obj
:
*
mut
JSObject
)
{
let
array
=
get_proto_or_iface_array
(
obj
)
;
for
proto
in
(
*
array
)
.
iter
(
)
{
if
!
proto
.
is_null
(
)
{
trace_object
(
tracer
"
prototype
"
&
*
(
proto
as
*
const
*
mut
JSObject
as
*
const
Heap
<
*
mut
JSObject
>
)
)
;
}
}
}
pub
unsafe
extern
"
C
"
fn
enumerate_global
(
cx
:
*
mut
JSContext
obj
:
HandleObject
)
-
>
bool
{
assert
!
(
JS_IsGlobalObject
(
obj
.
get
(
)
)
)
;
if
!
JS_EnumerateStandardClasses
(
cx
obj
)
{
return
false
;
}
for
init_fun
in
InterfaceObjectMap
:
:
MAP
.
values
(
)
{
init_fun
(
cx
obj
)
;
}
true
}
pub
unsafe
extern
"
C
"
fn
resolve_global
(
cx
:
*
mut
JSContext
obj
:
HandleObject
id
:
HandleId
rval
:
*
mut
bool
)
-
>
bool
{
assert
!
(
JS_IsGlobalObject
(
obj
.
get
(
)
)
)
;
if
!
JS_ResolveStandardClass
(
cx
obj
id
rval
)
{
return
false
;
}
if
*
rval
{
return
true
;
}
if
!
RUST_JSID_IS_STRING
(
id
)
{
*
rval
=
false
;
return
true
;
}
let
string
=
RUST_JSID_TO_STRING
(
id
)
;
if
!
JS_StringHasLatin1Chars
(
string
)
{
*
rval
=
false
;
return
true
;
}
let
mut
length
=
0
;
let
ptr
=
JS_GetLatin1StringCharsAndLength
(
cx
ptr
:
:
null
(
)
string
&
mut
length
)
;
assert
!
(
!
ptr
.
is_null
(
)
)
;
let
bytes
=
slice
:
:
from_raw_parts
(
ptr
length
as
usize
)
;
if
let
Some
(
init_fun
)
=
InterfaceObjectMap
:
:
MAP
.
get
(
bytes
)
{
init_fun
(
cx
obj
)
;
*
rval
=
true
;
}
else
{
*
rval
=
false
;
}
true
}
unsafe
extern
"
C
"
fn
wrap
(
cx
:
*
mut
JSContext
_existing
:
HandleObject
obj
:
HandleObject
)
-
>
*
mut
JSObject
{
WrapperNew
(
cx
obj
GetCrossCompartmentWrapper
(
)
ptr
:
:
null
(
)
false
)
}
unsafe
extern
"
C
"
fn
pre_wrap
(
cx
:
*
mut
JSContext
_existing
:
HandleObject
obj
:
HandleObject
_object_passed_to_wrap
:
HandleObject
)
-
>
*
mut
JSObject
{
let
_ac
=
JSAutoCompartment
:
:
new
(
cx
obj
.
get
(
)
)
;
let
obj
=
ToWindowProxyIfWindow
(
obj
.
get
(
)
)
;
assert
!
(
!
obj
.
is_null
(
)
)
;
obj
}
pub
static
WRAP_CALLBACKS
:
JSWrapObjectCallbacks
=
JSWrapObjectCallbacks
{
wrap
:
Some
(
wrap
)
preWrap
:
Some
(
pre_wrap
)
}
;
pub
unsafe
fn
delete_property_by_id
(
cx
:
*
mut
JSContext
object
:
HandleObject
id
:
HandleId
bp
:
*
mut
ObjectOpResult
)
-
>
bool
{
JS_DeletePropertyById
(
cx
object
id
bp
)
}
unsafe
fn
generic_call
(
cx
:
*
mut
JSContext
argc
:
libc
:
:
c_uint
vp
:
*
mut
JSVal
is_lenient
:
bool
call
:
unsafe
extern
fn
(
*
const
JSJitInfo
*
mut
JSContext
HandleObject
*
mut
libc
:
:
c_void
u32
*
mut
JSVal
)
-
>
bool
)
-
>
bool
{
let
args
=
CallArgs
:
:
from_vp
(
vp
argc
)
;
let
info
=
RUST_FUNCTION_VALUE_TO_JITINFO
(
JS_CALLEE
(
cx
vp
)
)
;
let
proto_id
=
(
*
info
)
.
protoID
;
let
thisobj
=
args
.
thisv
(
)
;
if
!
thisobj
.
get
(
)
.
is_null_or_undefined
(
)
&
&
!
thisobj
.
get
(
)
.
is_object
(
)
{
throw_invalid_this
(
cx
proto_id
)
;
return
false
;
}
let
obj
=
if
thisobj
.
get
(
)
.
is_object
(
)
{
thisobj
.
get
(
)
.
to_object
(
)
}
else
{
GetGlobalForObjectCrossCompartment
(
JS_CALLEE
(
cx
vp
)
.
to_object_or_null
(
)
)
}
;
rooted
!
(
in
(
cx
)
let
obj
=
obj
)
;
let
depth
=
(
*
info
)
.
depth
;
let
proto_check
=
|
class
:
&
'
static
DOMClass
|
{
class
.
interface_chain
[
depth
as
usize
]
as
u16
=
=
proto_id
}
;
let
this
=
match
private_from_proto_check
(
obj
.
get
(
)
proto_check
)
{
Ok
(
val
)
=
>
val
Err
(
(
)
)
=
>
{
if
is_lenient
{
debug_assert
!
(
!
JS_IsExceptionPending
(
cx
)
)
;
*
vp
=
UndefinedValue
(
)
;
return
true
;
}
else
{
throw_invalid_this
(
cx
proto_id
)
;
return
false
;
}
}
}
;
call
(
info
cx
obj
.
handle
(
)
this
as
*
mut
libc
:
:
c_void
argc
vp
)
}
pub
unsafe
extern
"
C
"
fn
generic_method
(
cx
:
*
mut
JSContext
argc
:
libc
:
:
c_uint
vp
:
*
mut
JSVal
)
-
>
bool
{
generic_call
(
cx
argc
vp
false
CallJitMethodOp
)
}
pub
unsafe
extern
"
C
"
fn
generic_getter
(
cx
:
*
mut
JSContext
argc
:
libc
:
:
c_uint
vp
:
*
mut
JSVal
)
-
>
bool
{
generic_call
(
cx
argc
vp
false
CallJitGetterOp
)
}
pub
unsafe
extern
"
C
"
fn
generic_lenient_getter
(
cx
:
*
mut
JSContext
argc
:
libc
:
:
c_uint
vp
:
*
mut
JSVal
)
-
>
bool
{
generic_call
(
cx
argc
vp
true
CallJitGetterOp
)
}
unsafe
extern
"
C
"
fn
call_setter
(
info
:
*
const
JSJitInfo
cx
:
*
mut
JSContext
handle
:
HandleObject
this
:
*
mut
libc
:
:
c_void
argc
:
u32
vp
:
*
mut
JSVal
)
-
>
bool
{
if
!
CallJitSetterOp
(
info
cx
handle
this
argc
vp
)
{
return
false
;
}
*
vp
=
UndefinedValue
(
)
;
true
}
pub
unsafe
extern
"
C
"
fn
generic_setter
(
cx
:
*
mut
JSContext
argc
:
libc
:
:
c_uint
vp
:
*
mut
JSVal
)
-
>
bool
{
generic_call
(
cx
argc
vp
false
call_setter
)
}
pub
unsafe
extern
"
C
"
fn
generic_lenient_setter
(
cx
:
*
mut
JSContext
argc
:
libc
:
:
c_uint
vp
:
*
mut
JSVal
)
-
>
bool
{
generic_call
(
cx
argc
vp
true
call_setter
)
}
unsafe
extern
"
C
"
fn
instance_class_has_proto_at_depth
(
clasp
:
*
const
js
:
:
jsapi
:
:
Class
proto_id
:
u32
depth
:
u32
)
-
>
bool
{
let
domclass
:
*
const
DOMJSClass
=
clasp
as
*
const
_
;
let
domclass
=
&
*
domclass
;
domclass
.
dom_class
.
interface_chain
[
depth
as
usize
]
as
u32
=
=
proto_id
}
#
[
allow
(
missing_docs
)
]
pub
const
DOM_CALLBACKS
:
DOMCallbacks
=
DOMCallbacks
{
instanceClassMatchesProto
:
Some
(
instance_class_has_proto_at_depth
)
}
;
pub
trait
AsVoidPtr
{
fn
as_void_ptr
(
&
self
)
-
>
*
const
libc
:
:
c_void
;
}
impl
<
T
>
AsVoidPtr
for
T
{
fn
as_void_ptr
(
&
self
)
-
>
*
const
libc
:
:
c_void
{
self
as
*
const
T
as
*
const
libc
:
:
c_void
}
}
pub
trait
AsCCharPtrPtr
{
fn
as_c_char_ptr
(
&
self
)
-
>
*
const
c_char
;
}
impl
AsCCharPtrPtr
for
[
u8
]
{
fn
as_c_char_ptr
(
&
self
)
-
>
*
const
c_char
{
self
as
*
const
[
u8
]
as
*
const
c_char
}
}
