#
!
[
deny
(
missing_docs
)
]
use
dom
:
:
bindings
:
:
codegen
:
:
PrototypeList
;
use
dom
:
:
bindings
:
:
codegen
:
:
PrototypeList
:
:
MAX_PROTO_CHAIN_LENGTH
;
use
dom
:
:
bindings
:
:
conversions
:
:
{
unwrap_jsmanaged
is_dom_class
}
;
use
dom
:
:
bindings
:
:
error
:
:
throw_type_error
;
use
dom
:
:
bindings
:
:
global
:
:
GlobalRef
;
use
dom
:
:
bindings
:
:
js
:
:
{
Temporary
Root
}
;
use
dom
:
:
browsercontext
;
use
dom
:
:
window
;
use
libc
;
use
libc
:
:
c_uint
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
mem
;
use
std
:
:
ptr
;
use
js
:
:
glue
:
:
UnwrapObject
;
use
js
:
:
glue
:
:
{
IsWrapper
RUST_JSID_IS_INT
RUST_JSID_TO_INT
}
;
use
js
:
:
jsapi
:
:
{
JS_AlreadyHasOwnProperty
JS_NewFunction
}
;
use
js
:
:
jsapi
:
:
{
JS_DefineProperties
JS_ForwardGetPropertyTo
}
;
use
js
:
:
jsapi
:
:
{
JS_GetClass
JS_LinkConstructorAndPrototype
JS_GetStringCharsAndLength
}
;
use
js
:
:
jsapi
:
:
{
JS_ObjectIsRegExp
JS_ObjectIsDate
JSHandleObject
}
;
use
js
:
:
jsapi
:
:
JS_GetFunctionObject
;
use
js
:
:
jsapi
:
:
{
JS_HasPropertyById
JS_GetPrototype
}
;
use
js
:
:
jsapi
:
:
{
JS_GetProperty
JS_HasProperty
}
;
use
js
:
:
jsapi
:
:
{
JS_DefineFunctions
JS_DefineProperty
}
;
use
js
:
:
jsapi
:
:
{
JS_ValueToString
JS_GetReservedSlot
JS_SetReservedSlot
}
;
use
js
:
:
jsapi
:
:
{
JSContext
JSObject
JSBool
jsid
JSClass
}
;
use
js
:
:
jsapi
:
:
{
JSFunctionSpec
JSPropertySpec
}
;
use
js
:
:
jsapi
:
:
{
JS_NewGlobalObject
JS_InitStandardClasses
}
;
use
js
:
:
jsapi
:
:
JS_DeletePropertyById2
;
use
js
:
:
jsfriendapi
:
:
JS_ObjectToOuterObject
;
use
js
:
:
jsfriendapi
:
:
bindgen
:
:
JS_NewObjectWithUniqueType
;
use
js
:
:
jsval
:
:
JSVal
;
use
js
:
:
jsval
:
:
{
PrivateValue
ObjectValue
NullValue
}
;
use
js
:
:
jsval
:
:
{
Int32Value
UInt32Value
DoubleValue
BooleanValue
UndefinedValue
}
;
use
js
:
:
rust
:
:
with_compartment
;
use
js
:
:
{
JSPROP_ENUMERATE
JSPROP_READONLY
JSPROP_PERMANENT
}
;
use
js
:
:
JSFUN_CONSTRUCTOR
;
use
js
;
pub
struct
WindowProxyHandler
(
pub
*
const
libc
:
:
c_void
)
;
#
[
allow
(
raw_pointer_deriving
)
]
#
[
jstraceable
]
pub
struct
GlobalStaticData
{
pub
windowproxy_handler
:
WindowProxyHandler
}
pub
fn
GlobalStaticData
(
)
-
>
GlobalStaticData
{
GlobalStaticData
{
windowproxy_handler
:
browsercontext
:
:
new_window_proxy_handler
(
)
}
}
pub
unsafe
fn
squirrel_away_unique
<
T
>
(
x
:
Box
<
T
>
)
-
>
*
const
T
{
mem
:
:
transmute
(
x
)
}
const
DOM_PROTO_INSTANCE_CLASS_SLOT
:
u32
=
0
;
pub
const
DOM_PROTOTYPE_SLOT
:
u32
=
js
:
:
JSCLASS_GLOBAL_SLOT_COUNT
;
pub
const
JSCLASS_DOM_GLOBAL
:
u32
=
js
:
:
JSCLASS_USERBIT1
;
#
[
derive
(
Clone
)
]
pub
enum
ConstantVal
{
IntVal
(
i32
)
UintVal
(
u32
)
DoubleVal
(
f64
)
BoolVal
(
bool
)
NullVal
}
#
[
derive
(
Clone
)
]
pub
struct
ConstantSpec
{
pub
name
:
&
'
static
[
u8
]
pub
value
:
ConstantVal
}
impl
ConstantSpec
{
pub
fn
get_value
(
&
self
)
-
>
JSVal
{
match
self
.
value
{
ConstantVal
:
:
NullVal
=
>
NullValue
(
)
ConstantVal
:
:
IntVal
(
i
)
=
>
Int32Value
(
i
)
ConstantVal
:
:
UintVal
(
u
)
=
>
UInt32Value
(
u
)
ConstantVal
:
:
DoubleVal
(
d
)
=
>
DoubleValue
(
d
)
ConstantVal
:
:
BoolVal
(
b
)
=
>
BooleanValue
(
b
)
}
}
}
pub
struct
NativePropertyHooks
{
pub
native_properties
:
&
'
static
NativeProperties
pub
proto_hooks
:
Option
<
&
'
static
NativePropertyHooks
>
}
#
[
derive
(
Copy
)
]
pub
struct
DOMClass
{
pub
interface_chain
:
[
PrototypeList
:
:
ID
;
MAX_PROTO_CHAIN_LENGTH
]
pub
native_hooks
:
&
'
static
NativePropertyHooks
}
unsafe
impl
Sync
for
DOMClass
{
}
#
[
derive
(
Copy
)
]
pub
struct
DOMJSClass
{
pub
base
:
js
:
:
Class
pub
dom_class
:
DOMClass
}
unsafe
impl
Sync
for
DOMJSClass
{
}
pub
fn
GetProtoOrIfaceArray
(
global
:
*
mut
JSObject
)
-
>
*
mut
*
mut
JSObject
{
unsafe
{
assert
!
(
(
(
*
JS_GetClass
(
global
)
)
.
flags
&
JSCLASS_DOM_GLOBAL
)
!
=
0
)
;
JS_GetReservedSlot
(
global
DOM_PROTOTYPE_SLOT
)
.
to_private
(
)
as
*
mut
*
mut
JSObject
}
}
pub
struct
NativeProperties
{
pub
methods
:
Option
<
&
'
static
[
JSFunctionSpec
]
>
pub
attrs
:
Option
<
&
'
static
[
JSPropertySpec
]
>
pub
consts
:
Option
<
&
'
static
[
ConstantSpec
]
>
pub
staticMethods
:
Option
<
&
'
static
[
JSFunctionSpec
]
>
pub
staticAttrs
:
Option
<
&
'
static
[
JSPropertySpec
]
>
}
unsafe
impl
Sync
for
NativeProperties
{
}
pub
type
NonNullJSNative
=
unsafe
extern
"
C
"
fn
(
arg1
:
*
mut
JSContext
arg2
:
c_uint
arg3
:
*
mut
JSVal
)
-
>
JSBool
;
pub
fn
CreateInterfaceObjects2
(
cx
:
*
mut
JSContext
global
:
*
mut
JSObject
receiver
:
*
mut
JSObject
protoProto
:
*
mut
JSObject
protoClass
:
&
'
static
JSClass
constructor
:
Option
<
(
NonNullJSNative
&
'
static
str
u32
)
>
domClass
:
*
const
DOMClass
members
:
&
'
static
NativeProperties
)
-
>
*
mut
JSObject
{
let
proto
=
CreateInterfacePrototypeObject
(
cx
global
protoProto
protoClass
members
)
;
unsafe
{
JS_SetReservedSlot
(
proto
DOM_PROTO_INSTANCE_CLASS_SLOT
PrivateValue
(
domClass
as
*
const
libc
:
:
c_void
)
)
;
}
match
constructor
{
Some
(
(
native
name
nargs
)
)
=
>
{
let
s
=
CString
:
:
from_slice
(
name
.
as_bytes
(
)
)
;
CreateInterfaceObject
(
cx
global
receiver
native
nargs
proto
members
s
.
as_ptr
(
)
)
}
None
=
>
(
)
}
proto
}
fn
CreateInterfaceObject
(
cx
:
*
mut
JSContext
global
:
*
mut
JSObject
receiver
:
*
mut
JSObject
constructorNative
:
NonNullJSNative
ctorNargs
:
u32
proto
:
*
mut
JSObject
members
:
&
'
static
NativeProperties
name
:
*
const
libc
:
:
c_char
)
{
unsafe
{
let
fun
=
JS_NewFunction
(
cx
Some
(
constructorNative
)
ctorNargs
JSFUN_CONSTRUCTOR
global
name
)
;
assert
!
(
!
fun
.
is_null
(
)
)
;
let
constructor
=
JS_GetFunctionObject
(
fun
)
;
assert
!
(
!
constructor
.
is_null
(
)
)
;
match
members
.
staticMethods
{
Some
(
staticMethods
)
=
>
DefineMethods
(
cx
constructor
staticMethods
)
_
=
>
(
)
}
match
members
.
staticAttrs
{
Some
(
staticProperties
)
=
>
DefineProperties
(
cx
constructor
staticProperties
)
_
=
>
(
)
}
match
members
.
consts
{
Some
(
constants
)
=
>
DefineConstants
(
cx
constructor
constants
)
_
=
>
(
)
}
if
!
proto
.
is_null
(
)
{
assert
!
(
JS_LinkConstructorAndPrototype
(
cx
constructor
proto
)
!
=
0
)
;
}
let
mut
alreadyDefined
=
0
;
assert
!
(
JS_AlreadyHasOwnProperty
(
cx
receiver
name
&
mut
alreadyDefined
)
!
=
0
)
;
if
alreadyDefined
=
=
0
{
assert
!
(
JS_DefineProperty
(
cx
receiver
name
ObjectValue
(
&
*
constructor
)
None
None
0
)
!
=
0
)
;
}
}
}
fn
DefineConstants
(
cx
:
*
mut
JSContext
obj
:
*
mut
JSObject
constants
:
&
'
static
[
ConstantSpec
]
)
{
for
spec
in
constants
.
iter
(
)
{
unsafe
{
assert
!
(
JS_DefineProperty
(
cx
obj
spec
.
name
.
as_ptr
(
)
as
*
const
libc
:
:
c_char
spec
.
get_value
(
)
None
None
JSPROP_ENUMERATE
|
JSPROP_READONLY
|
JSPROP_PERMANENT
)
!
=
0
)
;
}
}
}
fn
DefineMethods
(
cx
:
*
mut
JSContext
obj
:
*
mut
JSObject
methods
:
&
'
static
[
JSFunctionSpec
]
)
{
unsafe
{
assert
!
(
JS_DefineFunctions
(
cx
obj
methods
.
as_ptr
(
)
)
!
=
0
)
;
}
}
fn
DefineProperties
(
cx
:
*
mut
JSContext
obj
:
*
mut
JSObject
properties
:
&
'
static
[
JSPropertySpec
]
)
{
unsafe
{
assert
!
(
JS_DefineProperties
(
cx
obj
properties
.
as_ptr
(
)
)
!
=
0
)
;
}
}
fn
CreateInterfacePrototypeObject
(
cx
:
*
mut
JSContext
global
:
*
mut
JSObject
parentProto
:
*
mut
JSObject
protoClass
:
&
'
static
JSClass
members
:
&
'
static
NativeProperties
)
-
>
*
mut
JSObject
{
unsafe
{
let
ourProto
=
JS_NewObjectWithUniqueType
(
cx
protoClass
&
*
parentProto
&
*
global
)
;
assert
!
(
!
ourProto
.
is_null
(
)
)
;
match
members
.
methods
{
Some
(
methods
)
=
>
DefineMethods
(
cx
ourProto
methods
)
_
=
>
(
)
}
match
members
.
attrs
{
Some
(
properties
)
=
>
DefineProperties
(
cx
ourProto
properties
)
_
=
>
(
)
}
match
members
.
consts
{
Some
(
constants
)
=
>
DefineConstants
(
cx
ourProto
constants
)
_
=
>
(
)
}
return
ourProto
;
}
}
pub
unsafe
extern
fn
ThrowingConstructor
(
cx
:
*
mut
JSContext
_argc
:
c_uint
_vp
:
*
mut
JSVal
)
-
>
JSBool
{
throw_type_error
(
cx
"
Illegal
constructor
.
"
)
;
return
0
;
}
pub
fn
initialize_global
(
global
:
*
mut
JSObject
)
{
let
protoArray
=
box
(
)
(
[
0
as
*
mut
JSObject
;
PrototypeList
:
:
ID
:
:
Count
as
uint
]
)
;
unsafe
{
assert
!
(
(
(
*
JS_GetClass
(
global
)
)
.
flags
&
JSCLASS_DOM_GLOBAL
)
!
=
0
)
;
let
box_
=
squirrel_away_unique
(
protoArray
)
;
JS_SetReservedSlot
(
global
DOM_PROTOTYPE_SLOT
PrivateValue
(
box_
as
*
const
libc
:
:
c_void
)
)
;
}
}
pub
trait
Reflectable
{
fn
reflector
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Reflector
;
}
pub
fn
reflect_dom_object
<
T
:
Reflectable
>
(
obj
:
Box
<
T
>
global
:
GlobalRef
wrap_fn
:
extern
"
Rust
"
fn
(
*
mut
JSContext
GlobalRef
Box
<
T
>
)
-
>
Temporary
<
T
>
)
-
>
Temporary
<
T
>
{
wrap_fn
(
global
.
get_cx
(
)
global
obj
)
}
#
[
allow
(
raw_pointer_deriving
unrooted_must_root
unused_attributes
)
]
#
[
derive
(
PartialEq
)
]
#
[
must_root
]
#
[
servo_lang
=
"
reflector
"
]
pub
struct
Reflector
{
object
:
Cell
<
*
mut
JSObject
>
}
impl
Reflector
{
#
[
inline
]
pub
fn
get_jsobject
(
&
self
)
-
>
*
mut
JSObject
{
self
.
object
.
get
(
)
}
pub
fn
set_jsobject
(
&
self
object
:
*
mut
JSObject
)
{
assert
!
(
self
.
object
.
get
(
)
.
is_null
(
)
)
;
assert
!
(
!
object
.
is_null
(
)
)
;
self
.
object
.
set
(
object
)
;
}
pub
unsafe
fn
rootable
(
&
self
)
-
>
*
mut
*
mut
JSObject
{
self
.
object
.
as_unsafe_cell
(
)
.
get
(
)
}
pub
fn
new
(
)
-
>
Reflector
{
Reflector
{
object
:
Cell
:
:
new
(
ptr
:
:
null_mut
(
)
)
}
}
}
pub
fn
GetPropertyOnPrototype
(
cx
:
*
mut
JSContext
proxy
:
*
mut
JSObject
id
:
jsid
found
:
*
mut
bool
vp
:
*
mut
JSVal
)
-
>
bool
{
unsafe
{
let
proto
=
JS_GetPrototype
(
proxy
)
;
if
proto
.
is_null
(
)
{
*
found
=
false
;
return
true
;
}
let
mut
hasProp
=
0
;
if
JS_HasPropertyById
(
cx
proto
id
&
mut
hasProp
)
=
=
0
{
return
false
;
}
*
found
=
hasProp
!
=
0
;
let
no_output
=
vp
.
is_null
(
)
;
if
hasProp
=
=
0
|
|
no_output
{
return
true
;
}
JS_ForwardGetPropertyTo
(
cx
proto
id
proxy
vp
)
!
=
0
}
}
pub
fn
GetArrayIndexFromId
(
_cx
:
*
mut
JSContext
id
:
jsid
)
-
>
Option
<
u32
>
{
unsafe
{
if
RUST_JSID_IS_INT
(
id
)
!
=
0
{
return
Some
(
RUST_JSID_TO_INT
(
id
)
as
u32
)
;
}
return
None
;
}
}
pub
fn
FindEnumStringIndex
(
cx
:
*
mut
JSContext
v
:
JSVal
values
:
&
[
&
'
static
str
]
)
-
>
Result
<
Option
<
uint
>
(
)
>
{
unsafe
{
let
jsstr
=
JS_ValueToString
(
cx
v
)
;
if
jsstr
.
is_null
(
)
{
return
Err
(
(
)
)
;
}
let
mut
length
=
0
;
let
chars
=
JS_GetStringCharsAndLength
(
cx
jsstr
&
mut
length
)
;
if
chars
.
is_null
(
)
{
return
Err
(
(
)
)
;
}
Ok
(
values
.
iter
(
)
.
position
(
|
value
|
{
value
.
len
(
)
=
=
length
as
uint
&
&
range
(
0
length
as
uint
)
.
all
(
|
j
|
{
value
.
as_bytes
(
)
[
j
]
as
u16
=
=
*
chars
.
offset
(
j
as
int
)
}
)
}
)
)
}
}
pub
fn
IsPlatformObject
(
obj
:
*
mut
JSObject
)
-
>
bool
{
unsafe
{
let
mut
clasp
=
JS_GetClass
(
obj
)
;
if
is_dom_class
(
&
*
clasp
)
{
return
true
;
}
if
IsWrapper
(
obj
)
=
=
1
{
let
unwrapped_obj
=
UnwrapObject
(
obj
0
ptr
:
:
null_mut
(
)
)
;
if
unwrapped_obj
.
is_null
(
)
{
return
false
;
}
clasp
=
js
:
:
jsapi
:
:
JS_GetClass
(
obj
)
;
}
return
is_dom_class
(
&
*
clasp
)
;
}
}
pub
fn
get_dictionary_property
(
cx
:
*
mut
JSContext
object
:
*
mut
JSObject
property
:
&
str
)
-
>
Result
<
Option
<
JSVal
>
(
)
>
{
use
std
:
:
ffi
:
:
CString
;
fn
has_property
(
cx
:
*
mut
JSContext
object
:
*
mut
JSObject
property
:
&
CString
found
:
&
mut
JSBool
)
-
>
bool
{
unsafe
{
JS_HasProperty
(
cx
object
property
.
as_ptr
(
)
found
)
!
=
0
}
}
fn
get_property
(
cx
:
*
mut
JSContext
object
:
*
mut
JSObject
property
:
&
CString
value
:
&
mut
JSVal
)
-
>
bool
{
unsafe
{
JS_GetProperty
(
cx
object
property
.
as_ptr
(
)
value
)
!
=
0
}
}
let
property
=
CString
:
:
from_slice
(
property
.
as_bytes
(
)
)
;
if
object
.
is_null
(
)
{
return
Ok
(
None
)
;
}
let
mut
found
:
JSBool
=
0
;
if
!
has_property
(
cx
object
&
property
&
mut
found
)
{
return
Err
(
(
)
)
;
}
if
found
=
=
0
{
return
Ok
(
None
)
;
}
let
mut
value
=
NullValue
(
)
;
if
!
get_property
(
cx
object
&
property
&
mut
value
)
{
return
Err
(
(
)
)
;
}
Ok
(
Some
(
value
)
)
}
pub
fn
HasPropertyOnPrototype
(
cx
:
*
mut
JSContext
proxy
:
*
mut
JSObject
id
:
jsid
)
-
>
bool
{
let
mut
found
=
false
;
return
!
GetPropertyOnPrototype
(
cx
proxy
id
&
mut
found
ptr
:
:
null_mut
(
)
)
|
|
found
;
}
pub
fn
IsConvertibleToCallbackInterface
(
cx
:
*
mut
JSContext
obj
:
*
mut
JSObject
)
-
>
bool
{
unsafe
{
JS_ObjectIsDate
(
cx
obj
)
=
=
0
&
&
JS_ObjectIsRegExp
(
cx
obj
)
=
=
0
}
}
pub
fn
CreateDOMGlobal
(
cx
:
*
mut
JSContext
class
:
*
const
JSClass
)
-
>
*
mut
JSObject
{
unsafe
{
let
obj
=
JS_NewGlobalObject
(
cx
class
ptr
:
:
null_mut
(
)
)
;
if
obj
.
is_null
(
)
{
return
ptr
:
:
null_mut
(
)
;
}
with_compartment
(
cx
obj
|
|
{
JS_InitStandardClasses
(
cx
obj
)
;
}
)
;
initialize_global
(
obj
)
;
obj
}
}
pub
unsafe
extern
fn
wrap_for_same_compartment
(
cx
:
*
mut
JSContext
obj
:
*
mut
JSObject
)
-
>
*
mut
JSObject
{
JS_ObjectToOuterObject
(
cx
obj
)
}
pub
unsafe
extern
fn
pre_wrap
(
cx
:
*
mut
JSContext
_scope
:
*
mut
JSObject
obj
:
*
mut
JSObject
_flags
:
c_uint
)
-
>
*
mut
JSObject
{
JS_ObjectToOuterObject
(
cx
obj
)
}
pub
extern
fn
outerize_global
(
_cx
:
*
mut
JSContext
obj
:
JSHandleObject
)
-
>
*
mut
JSObject
{
unsafe
{
debug
!
(
"
outerizing
"
)
;
let
obj
=
*
obj
.
unnamed_field1
;
let
win
:
Root
<
window
:
:
Window
>
=
unwrap_jsmanaged
(
obj
)
.
unwrap
(
)
.
root
(
)
;
win
.
r
(
)
.
browser_context
(
)
.
as_ref
(
)
.
unwrap
(
)
.
window_proxy
(
)
}
}
pub
unsafe
fn
delete_property_by_id
(
cx
:
*
mut
JSContext
object
:
*
mut
JSObject
id
:
jsid
bp
:
&
mut
bool
)
-
>
bool
{
let
mut
value
=
UndefinedValue
(
)
;
if
JS_DeletePropertyById2
(
cx
object
id
&
mut
value
)
=
=
0
{
return
false
;
}
*
bp
=
value
.
to_boolean
(
)
;
return
true
;
}
#
[
derive
(
PartialEq
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
XMLName
{
QName
Name
InvalidXMLName
}
pub
fn
xml_name_type
(
name
:
&
str
)
-
>
XMLName
{
fn
is_valid_start
(
c
:
char
)
-
>
bool
{
match
c
{
'
:
'
|
'
A
'
.
.
.
'
Z
'
|
'
_
'
|
'
a
'
.
.
.
'
z
'
|
'
\
u
{
C0
}
'
.
.
.
'
\
u
{
D6
}
'
|
'
\
u
{
D8
}
'
.
.
.
'
\
u
{
F6
}
'
|
'
\
u
{
F8
}
'
.
.
.
'
\
u
{
2FF
}
'
|
'
\
u
{
370
}
'
.
.
.
'
\
u
{
37D
}
'
|
'
\
u
{
37F
}
'
.
.
.
'
\
u
{
1FFF
}
'
|
'
\
u
{
200C
}
'
.
.
.
'
\
u
{
200D
}
'
|
'
\
u
{
2070
}
'
.
.
.
'
\
u
{
218F
}
'
|
'
\
u
{
2C00
}
'
.
.
.
'
\
u
{
2FEF
}
'
|
'
\
u
{
3001
}
'
.
.
.
'
\
u
{
D7FF
}
'
|
'
\
u
{
F900
}
'
.
.
.
'
\
u
{
FDCF
}
'
|
'
\
u
{
FDF0
}
'
.
.
.
'
\
u
{
FFFD
}
'
|
'
\
u
{
10000
}
'
.
.
.
'
\
u
{
EFFFF
}
'
=
>
true
_
=
>
false
}
}
fn
is_valid_continuation
(
c
:
char
)
-
>
bool
{
is_valid_start
(
c
)
|
|
match
c
{
'
-
'
|
'
.
'
|
'
0
'
.
.
.
'
9
'
|
'
\
u
{
B7
}
'
|
'
\
u
{
300
}
'
.
.
.
'
\
u
{
36F
}
'
|
'
\
u
{
203F
}
'
.
.
.
'
\
u
{
2040
}
'
=
>
true
_
=
>
false
}
}
let
mut
iter
=
name
.
chars
(
)
;
let
mut
non_qname_colons
=
false
;
let
mut
seen_colon
=
false
;
match
iter
.
next
(
)
{
None
=
>
return
XMLName
:
:
InvalidXMLName
Some
(
c
)
=
>
{
if
!
is_valid_start
(
c
)
{
return
XMLName
:
:
InvalidXMLName
;
}
if
c
=
=
'
:
'
{
non_qname_colons
=
true
;
}
}
}
for
c
in
name
.
chars
(
)
{
if
!
is_valid_continuation
(
c
)
{
return
XMLName
:
:
InvalidXMLName
;
}
if
c
=
=
'
:
'
{
match
seen_colon
{
true
=
>
non_qname_colons
=
true
false
=
>
seen_colon
=
true
}
}
}
match
non_qname_colons
{
false
=
>
XMLName
:
:
QName
true
=
>
XMLName
:
:
Name
}
}
