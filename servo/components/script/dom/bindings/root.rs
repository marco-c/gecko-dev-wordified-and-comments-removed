use
core
:
:
nonzero
:
:
NonZero
;
use
dom
:
:
bindings
:
:
conversions
:
:
DerivedFrom
;
use
dom
:
:
bindings
:
:
inheritance
:
:
Castable
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
DomObject
Reflector
}
;
use
dom
:
:
bindings
:
:
trace
:
:
JSTraceable
;
use
dom
:
:
bindings
:
:
trace
:
:
trace_reflector
;
use
dom
:
:
node
:
:
Node
;
use
heapsize
:
:
HeapSizeOf
;
use
js
:
:
jsapi
:
:
{
JSObject
JSTracer
Heap
}
;
use
js
:
:
rust
:
:
GCMethods
;
use
mitochondria
:
:
OnceCell
;
use
script_layout_interface
:
:
TrustedNodeAddress
;
use
script_thread
:
:
STACK_ROOTS
;
use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
#
[
cfg
(
debug_assertions
)
]
use
std
:
:
intrinsics
:
:
type_name
;
use
std
:
:
mem
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
ptr
;
use
std
:
:
rc
:
:
Rc
;
use
style
:
:
thread_state
;
#
[
must_root
]
pub
struct
Dom
<
T
>
{
ptr
:
NonZero
<
*
const
T
>
}
impl
<
T
>
HeapSizeOf
for
Dom
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
impl
<
T
>
Dom
<
T
>
{
pub
unsafe
fn
to_layout
(
&
self
)
-
>
LayoutDom
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_layout
(
)
)
;
LayoutDom
{
ptr
:
self
.
ptr
.
clone
(
)
}
}
}
impl
<
T
:
DomObject
>
Dom
<
T
>
{
#
[
allow
(
unrooted_must_root
)
]
pub
fn
from_ref
(
obj
:
&
T
)
-
>
Dom
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
Dom
{
ptr
:
unsafe
{
NonZero
:
:
new_unchecked
(
&
*
obj
)
}
}
}
}
impl
<
'
root
T
:
DomObject
+
'
root
>
RootedReference
<
'
root
>
for
Dom
<
T
>
{
type
Ref
=
&
'
root
T
;
fn
r
(
&
'
root
self
)
-
>
&
'
root
T
{
&
self
}
}
impl
<
T
:
DomObject
>
Deref
for
Dom
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
unsafe
{
&
*
self
.
ptr
.
get
(
)
}
}
}
unsafe
impl
<
T
:
DomObject
>
JSTraceable
for
Dom
<
T
>
{
unsafe
fn
trace
(
&
self
trc
:
*
mut
JSTracer
)
{
#
[
cfg
(
debug_assertions
)
]
let
trace_str
=
format
!
(
"
for
{
}
on
heap
"
type_name
:
:
<
T
>
(
)
)
;
#
[
cfg
(
debug_assertions
)
]
let
trace_info
=
&
trace_str
[
.
.
]
;
#
[
cfg
(
not
(
debug_assertions
)
)
]
let
trace_info
=
"
for
DOM
object
on
heap
"
;
trace_reflector
(
trc
trace_info
(
*
self
.
ptr
.
get
(
)
)
.
reflector
(
)
)
;
}
}
#
[
allow_unrooted_interior
]
pub
struct
LayoutDom
<
T
>
{
ptr
:
NonZero
<
*
const
T
>
}
impl
<
T
:
Castable
>
LayoutDom
<
T
>
{
pub
fn
upcast
<
U
>
(
&
self
)
-
>
LayoutDom
<
U
>
where
U
:
Castable
T
:
DerivedFrom
<
U
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_layout
(
)
)
;
let
ptr
:
*
const
T
=
self
.
ptr
.
get
(
)
;
LayoutDom
{
ptr
:
unsafe
{
NonZero
:
:
new_unchecked
(
ptr
as
*
const
U
)
}
}
}
pub
fn
downcast
<
U
>
(
&
self
)
-
>
Option
<
LayoutDom
<
U
>
>
where
U
:
DerivedFrom
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_layout
(
)
)
;
unsafe
{
if
(
*
self
.
unsafe_get
(
)
)
.
is
:
:
<
U
>
(
)
{
let
ptr
:
*
const
T
=
self
.
ptr
.
get
(
)
;
Some
(
LayoutDom
{
ptr
:
NonZero
:
:
new_unchecked
(
ptr
as
*
const
U
)
}
)
}
else
{
None
}
}
}
}
impl
<
T
:
DomObject
>
LayoutDom
<
T
>
{
pub
unsafe
fn
get_jsobject
(
&
self
)
-
>
*
mut
JSObject
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_layout
(
)
)
;
(
*
self
.
ptr
.
get
(
)
)
.
reflector
(
)
.
get_jsobject
(
)
.
get
(
)
}
}
impl
<
T
>
Copy
for
LayoutDom
<
T
>
{
}
impl
<
T
>
PartialEq
for
Dom
<
T
>
{
fn
eq
(
&
self
other
:
&
Dom
<
T
>
)
-
>
bool
{
self
.
ptr
=
=
other
.
ptr
}
}
impl
<
T
>
Eq
for
Dom
<
T
>
{
}
impl
<
T
>
PartialEq
for
LayoutDom
<
T
>
{
fn
eq
(
&
self
other
:
&
LayoutDom
<
T
>
)
-
>
bool
{
self
.
ptr
=
=
other
.
ptr
}
}
impl
<
T
>
Eq
for
LayoutDom
<
T
>
{
}
impl
<
T
>
Hash
for
Dom
<
T
>
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
ptr
.
hash
(
state
)
}
}
impl
<
T
>
Hash
for
LayoutDom
<
T
>
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
ptr
.
hash
(
state
)
}
}
impl
<
T
>
Clone
for
Dom
<
T
>
{
#
[
inline
]
#
[
allow
(
unrooted_must_root
)
]
fn
clone
(
&
self
)
-
>
Dom
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
Dom
{
ptr
:
self
.
ptr
.
clone
(
)
}
}
}
impl
<
T
>
Clone
for
LayoutDom
<
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
LayoutDom
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_layout
(
)
)
;
LayoutDom
{
ptr
:
self
.
ptr
.
clone
(
)
}
}
}
impl
LayoutDom
<
Node
>
{
pub
unsafe
fn
from_trusted_node_address
(
inner
:
TrustedNodeAddress
)
-
>
LayoutDom
<
Node
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_layout
(
)
)
;
let
TrustedNodeAddress
(
addr
)
=
inner
;
LayoutDom
{
ptr
:
NonZero
:
:
new_unchecked
(
addr
as
*
const
Node
)
}
}
}
#
[
must_root
]
#
[
derive
(
JSTraceable
)
]
pub
struct
MutDom
<
T
:
DomObject
>
{
val
:
UnsafeCell
<
Dom
<
T
>
>
}
impl
<
T
:
DomObject
>
MutDom
<
T
>
{
pub
fn
new
(
initial
:
&
T
)
-
>
MutDom
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
MutDom
{
val
:
UnsafeCell
:
:
new
(
Dom
:
:
from_ref
(
initial
)
)
}
}
pub
fn
set
(
&
self
val
:
&
T
)
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
unsafe
{
*
self
.
val
.
get
(
)
=
Dom
:
:
from_ref
(
val
)
;
}
}
pub
fn
get
(
&
self
)
-
>
DomRoot
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
unsafe
{
DomRoot
:
:
from_ref
(
&
*
ptr
:
:
read
(
self
.
val
.
get
(
)
)
)
}
}
}
impl
<
T
:
DomObject
>
HeapSizeOf
for
MutDom
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
impl
<
T
:
DomObject
>
PartialEq
for
MutDom
<
T
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
unsafe
{
*
self
.
val
.
get
(
)
=
=
*
other
.
val
.
get
(
)
}
}
}
impl
<
T
:
DomObject
+
PartialEq
>
PartialEq
<
T
>
for
MutDom
<
T
>
{
fn
eq
(
&
self
other
:
&
T
)
-
>
bool
{
unsafe
{
*
*
self
.
val
.
get
(
)
=
=
*
other
}
}
}
#
[
must_root
]
#
[
derive
(
JSTraceable
)
]
pub
struct
MutNullableDom
<
T
:
DomObject
>
{
ptr
:
UnsafeCell
<
Option
<
Dom
<
T
>
>
>
}
impl
<
T
:
DomObject
>
MutNullableDom
<
T
>
{
pub
fn
new
(
initial
:
Option
<
&
T
>
)
-
>
MutNullableDom
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
MutNullableDom
{
ptr
:
UnsafeCell
:
:
new
(
initial
.
map
(
Dom
:
:
from_ref
)
)
}
}
pub
fn
or_init
<
F
>
(
&
self
cb
:
F
)
-
>
DomRoot
<
T
>
where
F
:
FnOnce
(
)
-
>
DomRoot
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
match
self
.
get
(
)
{
Some
(
inner
)
=
>
inner
None
=
>
{
let
inner
=
cb
(
)
;
self
.
set
(
Some
(
&
inner
)
)
;
inner
}
}
}
#
[
allow
(
unrooted_must_root
)
]
pub
unsafe
fn
get_inner_as_layout
(
&
self
)
-
>
Option
<
LayoutDom
<
T
>
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_layout
(
)
)
;
ptr
:
:
read
(
self
.
ptr
.
get
(
)
)
.
map
(
|
js
|
js
.
to_layout
(
)
)
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
get
(
&
self
)
-
>
Option
<
DomRoot
<
T
>
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
unsafe
{
ptr
:
:
read
(
self
.
ptr
.
get
(
)
)
.
map
(
|
o
|
DomRoot
:
:
from_ref
(
&
*
o
)
)
}
}
pub
fn
set
(
&
self
val
:
Option
<
&
T
>
)
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
unsafe
{
*
self
.
ptr
.
get
(
)
=
val
.
map
(
|
p
|
Dom
:
:
from_ref
(
p
)
)
;
}
}
pub
fn
take
(
&
self
)
-
>
Option
<
DomRoot
<
T
>
>
{
let
value
=
self
.
get
(
)
;
self
.
set
(
None
)
;
value
}
}
impl
<
T
:
DomObject
>
PartialEq
for
MutNullableDom
<
T
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
unsafe
{
*
self
.
ptr
.
get
(
)
=
=
*
other
.
ptr
.
get
(
)
}
}
}
impl
<
'
a
T
:
DomObject
>
PartialEq
<
Option
<
&
'
a
T
>
>
for
MutNullableDom
<
T
>
{
fn
eq
(
&
self
other
:
&
Option
<
&
T
>
)
-
>
bool
{
unsafe
{
*
self
.
ptr
.
get
(
)
=
=
other
.
map
(
Dom
:
:
from_ref
)
}
}
}
impl
<
T
:
DomObject
>
Default
for
MutNullableDom
<
T
>
{
#
[
allow
(
unrooted_must_root
)
]
fn
default
(
)
-
>
MutNullableDom
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
MutNullableDom
{
ptr
:
UnsafeCell
:
:
new
(
None
)
}
}
}
impl
<
T
:
DomObject
>
HeapSizeOf
for
MutNullableDom
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
#
[
must_root
]
pub
struct
DomOnceCell
<
T
:
DomObject
>
{
ptr
:
OnceCell
<
Dom
<
T
>
>
}
impl
<
T
:
DomObject
>
DomOnceCell
<
T
>
{
#
[
allow
(
unrooted_must_root
)
]
pub
fn
init_once
<
F
>
(
&
self
cb
:
F
)
-
>
&
T
where
F
:
FnOnce
(
)
-
>
DomRoot
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
&
self
.
ptr
.
init_once
(
|
|
Dom
:
:
from_ref
(
&
cb
(
)
)
)
}
}
impl
<
T
:
DomObject
>
Default
for
DomOnceCell
<
T
>
{
#
[
allow
(
unrooted_must_root
)
]
fn
default
(
)
-
>
DomOnceCell
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
DomOnceCell
{
ptr
:
OnceCell
:
:
new
(
)
}
}
}
impl
<
T
:
DomObject
>
HeapSizeOf
for
DomOnceCell
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
#
[
allow
(
unrooted_must_root
)
]
unsafe
impl
<
T
:
DomObject
>
JSTraceable
for
DomOnceCell
<
T
>
{
unsafe
fn
trace
(
&
self
trc
:
*
mut
JSTracer
)
{
if
let
Some
(
ptr
)
=
self
.
ptr
.
as_ref
(
)
{
ptr
.
trace
(
trc
)
;
}
}
}
impl
<
T
:
DomObject
>
LayoutDom
<
T
>
{
pub
unsafe
fn
unsafe_get
(
&
self
)
-
>
*
const
T
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_layout
(
)
)
;
self
.
ptr
.
get
(
)
}
pub
fn
get_for_script
(
&
self
)
-
>
&
T
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
unsafe
{
&
*
self
.
ptr
.
get
(
)
}
}
}
pub
trait
RootedReference
<
'
root
>
{
type
Ref
:
'
root
;
fn
r
(
&
'
root
self
)
-
>
Self
:
:
Ref
;
}
impl
<
'
root
T
:
JSTraceable
+
DomObject
+
'
root
>
RootedReference
<
'
root
>
for
[
Dom
<
T
>
]
{
type
Ref
=
&
'
root
[
&
'
root
T
]
;
fn
r
(
&
'
root
self
)
-
>
&
'
root
[
&
'
root
T
]
{
unsafe
{
mem
:
:
transmute
(
self
)
}
}
}
impl
<
'
root
T
:
DomObject
+
'
root
>
RootedReference
<
'
root
>
for
Rc
<
T
>
{
type
Ref
=
&
'
root
T
;
fn
r
(
&
'
root
self
)
-
>
&
'
root
T
{
self
}
}
impl
<
'
root
T
:
RootedReference
<
'
root
>
+
'
root
>
RootedReference
<
'
root
>
for
Option
<
T
>
{
type
Ref
=
Option
<
T
:
:
Ref
>
;
fn
r
(
&
'
root
self
)
-
>
Option
<
T
:
:
Ref
>
{
self
.
as_ref
(
)
.
map
(
RootedReference
:
:
r
)
}
}
pub
struct
RootCollection
{
roots
:
UnsafeCell
<
Vec
<
*
const
Reflector
>
>
}
pub
struct
RootCollectionPtr
(
pub
*
const
RootCollection
)
;
impl
Copy
for
RootCollectionPtr
{
}
impl
Clone
for
RootCollectionPtr
{
fn
clone
(
&
self
)
-
>
RootCollectionPtr
{
*
self
}
}
impl
RootCollection
{
pub
fn
new
(
)
-
>
RootCollection
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
RootCollection
{
roots
:
UnsafeCell
:
:
new
(
vec
!
[
]
)
}
}
unsafe
fn
root
(
&
self
untracked_reflector
:
*
const
Reflector
)
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
let
roots
=
&
mut
*
self
.
roots
.
get
(
)
;
roots
.
push
(
untracked_reflector
)
;
assert
!
(
!
(
*
untracked_reflector
)
.
get_jsobject
(
)
.
is_null
(
)
)
}
unsafe
fn
unroot
(
&
self
tracked_reflector
:
*
const
Reflector
)
{
assert
!
(
!
tracked_reflector
.
is_null
(
)
)
;
assert
!
(
!
(
*
tracked_reflector
)
.
get_jsobject
(
)
.
is_null
(
)
)
;
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
let
roots
=
&
mut
*
self
.
roots
.
get
(
)
;
match
roots
.
iter
(
)
.
rposition
(
|
r
|
*
r
=
=
tracked_reflector
)
{
Some
(
idx
)
=
>
{
roots
.
remove
(
idx
)
;
}
None
=
>
panic
!
(
"
Can
'
t
remove
a
root
that
was
never
rooted
!
"
)
}
}
}
pub
unsafe
fn
trace_roots
(
tracer
:
*
mut
JSTracer
)
{
debug
!
(
"
tracing
stack
roots
"
)
;
STACK_ROOTS
.
with
(
|
ref
collection
|
{
let
RootCollectionPtr
(
collection
)
=
collection
.
get
(
)
.
unwrap
(
)
;
let
collection
=
&
*
(
*
collection
)
.
roots
.
get
(
)
;
for
root
in
collection
{
trace_reflector
(
tracer
"
on
stack
"
&
*
*
root
)
;
}
}
)
;
}
#
[
allow_unrooted_interior
]
pub
struct
DomRoot
<
T
:
DomObject
>
{
ptr
:
NonZero
<
*
const
T
>
root_list
:
*
const
RootCollection
}
impl
<
T
:
Castable
>
DomRoot
<
T
>
{
pub
fn
upcast
<
U
>
(
root
:
DomRoot
<
T
>
)
-
>
DomRoot
<
U
>
where
U
:
Castable
T
:
DerivedFrom
<
U
>
{
unsafe
{
mem
:
:
transmute
(
root
)
}
}
pub
fn
downcast
<
U
>
(
root
:
DomRoot
<
T
>
)
-
>
Option
<
DomRoot
<
U
>
>
where
U
:
DerivedFrom
<
T
>
{
if
root
.
is
:
:
<
U
>
(
)
{
Some
(
unsafe
{
mem
:
:
transmute
(
root
)
}
)
}
else
{
None
}
}
}
impl
<
T
:
DomObject
>
DomRoot
<
T
>
{
pub
fn
new
(
unrooted
:
NonZero
<
*
const
T
>
)
-
>
DomRoot
<
T
>
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
STACK_ROOTS
.
with
(
|
ref
collection
|
{
let
RootCollectionPtr
(
collection
)
=
collection
.
get
(
)
.
unwrap
(
)
;
unsafe
{
(
*
collection
)
.
root
(
&
*
(
*
unrooted
.
get
(
)
)
.
reflector
(
)
)
}
DomRoot
{
ptr
:
unrooted
root_list
:
collection
}
}
)
}
pub
fn
from_ref
(
unrooted
:
&
T
)
-
>
DomRoot
<
T
>
{
DomRoot
:
:
new
(
unsafe
{
NonZero
:
:
new_unchecked
(
unrooted
)
}
)
}
}
impl
<
'
root
T
:
DomObject
+
'
root
>
RootedReference
<
'
root
>
for
DomRoot
<
T
>
{
type
Ref
=
&
'
root
T
;
fn
r
(
&
'
root
self
)
-
>
&
'
root
T
{
self
}
}
impl
<
T
:
DomObject
>
Deref
for
DomRoot
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
debug_assert
!
(
thread_state
:
:
get
(
)
.
is_script
(
)
)
;
unsafe
{
&
*
self
.
ptr
.
get
(
)
}
}
}
impl
<
T
:
DomObject
+
HeapSizeOf
>
HeapSizeOf
for
DomRoot
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
(
*
*
self
)
.
heap_size_of_children
(
)
}
}
impl
<
T
:
DomObject
>
PartialEq
for
DomRoot
<
T
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
ptr
=
=
other
.
ptr
}
}
impl
<
T
:
DomObject
>
Clone
for
DomRoot
<
T
>
{
fn
clone
(
&
self
)
-
>
DomRoot
<
T
>
{
DomRoot
:
:
from_ref
(
&
*
self
)
}
}
impl
<
T
:
DomObject
>
Drop
for
DomRoot
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
(
*
self
.
root_list
)
.
unroot
(
self
.
reflector
(
)
)
;
}
}
}
unsafe
impl
<
T
:
DomObject
>
JSTraceable
for
DomRoot
<
T
>
{
unsafe
fn
trace
(
&
self
_
:
*
mut
JSTracer
)
{
}
}
pub
trait
OptionalHeapSetter
{
type
Value
;
fn
set
(
&
mut
self
v
:
Option
<
Self
:
:
Value
>
)
;
}
impl
<
T
:
GCMethods
+
Copy
>
OptionalHeapSetter
for
Option
<
Heap
<
T
>
>
where
Heap
<
T
>
:
Default
{
type
Value
=
T
;
fn
set
(
&
mut
self
v
:
Option
<
T
>
)
{
let
v
=
match
v
{
None
=
>
{
*
self
=
None
;
return
;
}
Some
(
v
)
=
>
v
}
;
if
self
.
is_none
(
)
{
*
self
=
Some
(
Heap
:
:
default
(
)
)
;
}
self
.
as_ref
(
)
.
unwrap
(
)
.
set
(
v
)
;
}
}
