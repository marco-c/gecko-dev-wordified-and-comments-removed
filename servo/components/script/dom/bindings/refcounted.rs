use
core
:
:
nonzero
:
:
NonZero
;
use
dom
:
:
bindings
:
:
js
:
:
Root
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
Reflectable
Reflector
}
;
use
dom
:
:
bindings
:
:
trace
:
:
trace_reflector
;
use
js
:
:
jsapi
:
:
JSTracer
;
use
libc
;
use
script_runtime
:
:
{
CommonScriptMsg
ScriptChan
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
:
:
{
Occupied
Vacant
}
;
use
std
:
:
collections
:
:
hash_map
:
:
HashMap
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
os
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
#
[
allow
(
missing_docs
)
]
mod
dummy
{
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
rc
:
:
Rc
;
use
super
:
:
LiveDOMReferences
;
thread_local
!
(
pub
static
LIVE_REFERENCES
:
Rc
<
RefCell
<
Option
<
LiveDOMReferences
>
>
>
=
Rc
:
:
new
(
RefCell
:
:
new
(
None
)
)
)
;
}
pub
use
self
:
:
dummy
:
:
LIVE_REFERENCES
;
pub
struct
TrustedReference
(
*
const
libc
:
:
c_void
)
;
unsafe
impl
Send
for
TrustedReference
{
}
#
[
allow_unrooted_interior
]
pub
struct
Trusted
<
T
:
Reflectable
>
{
ptr
:
*
const
libc
:
:
c_void
refcount
:
Arc
<
Mutex
<
usize
>
>
script_chan
:
Box
<
ScriptChan
+
Send
>
owner_thread
:
*
const
libc
:
:
c_void
phantom
:
PhantomData
<
T
>
}
unsafe
impl
<
T
:
Reflectable
>
Send
for
Trusted
<
T
>
{
}
impl
<
T
:
Reflectable
>
Trusted
<
T
>
{
pub
fn
new
(
ptr
:
&
T
)
-
>
Trusted
<
T
>
{
let
script_chan
=
ptr
.
global
(
)
.
r
(
)
.
script_chan
(
)
;
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
let
r
=
r
.
borrow
(
)
;
let
live_references
=
r
.
as_ref
(
)
.
unwrap
(
)
;
let
refcount
=
live_references
.
addref
(
&
*
ptr
as
*
const
T
)
;
Trusted
{
ptr
:
&
*
ptr
as
*
const
T
as
*
const
libc
:
:
c_void
refcount
:
refcount
script_chan
:
script_chan
.
clone
(
)
owner_thread
:
(
&
*
live_references
)
as
*
const
_
as
*
const
libc
:
:
c_void
phantom
:
PhantomData
}
}
)
}
pub
fn
root
(
&
self
)
-
>
Root
<
T
>
{
assert
!
(
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
let
r
=
r
.
borrow
(
)
;
let
live_references
=
r
.
as_ref
(
)
.
unwrap
(
)
;
self
.
owner_thread
=
=
(
&
*
live_references
)
as
*
const
_
as
*
const
libc
:
:
c_void
}
)
)
;
unsafe
{
Root
:
:
new
(
NonZero
:
:
new
(
self
.
ptr
as
*
const
T
)
)
}
}
}
impl
<
T
:
Reflectable
>
Clone
for
Trusted
<
T
>
{
fn
clone
(
&
self
)
-
>
Trusted
<
T
>
{
{
let
mut
refcount
=
self
.
refcount
.
lock
(
)
.
unwrap
(
)
;
*
refcount
+
=
1
;
}
Trusted
{
ptr
:
self
.
ptr
refcount
:
self
.
refcount
.
clone
(
)
script_chan
:
self
.
script_chan
.
clone
(
)
owner_thread
:
self
.
owner_thread
phantom
:
PhantomData
}
}
}
impl
<
T
:
Reflectable
>
Drop
for
Trusted
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
mut
refcount
=
self
.
refcount
.
lock
(
)
.
unwrap
(
)
;
assert
!
(
*
refcount
>
0
)
;
*
refcount
-
=
1
;
if
*
refcount
=
=
0
{
let
msg
=
CommonScriptMsg
:
:
RefcountCleanup
(
TrustedReference
(
self
.
ptr
)
)
;
let
_
=
self
.
script_chan
.
send
(
msg
)
;
}
}
}
pub
struct
LiveDOMReferences
{
table
:
RefCell
<
HashMap
<
*
const
libc
:
:
c_void
Arc
<
Mutex
<
usize
>
>
>
>
}
impl
LiveDOMReferences
{
pub
fn
initialize
(
)
{
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
*
r
.
borrow_mut
(
)
=
Some
(
LiveDOMReferences
{
table
:
RefCell
:
:
new
(
HashMap
:
:
new
(
)
)
}
)
}
)
;
}
fn
addref
<
T
:
Reflectable
>
(
&
self
ptr
:
*
const
T
)
-
>
Arc
<
Mutex
<
usize
>
>
{
let
mut
table
=
self
.
table
.
borrow_mut
(
)
;
match
table
.
entry
(
ptr
as
*
const
libc
:
:
c_void
)
{
Occupied
(
mut
entry
)
=
>
{
let
refcount
=
entry
.
get_mut
(
)
;
*
refcount
.
lock
(
)
.
unwrap
(
)
+
=
1
;
refcount
.
clone
(
)
}
Vacant
(
entry
)
=
>
{
let
refcount
=
Arc
:
:
new
(
Mutex
:
:
new
(
1
)
)
;
entry
.
insert
(
refcount
.
clone
(
)
)
;
refcount
}
}
}
pub
fn
cleanup
(
raw_reflectable
:
TrustedReference
)
{
let
TrustedReference
(
raw_reflectable
)
=
raw_reflectable
;
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
let
r
=
r
.
borrow
(
)
;
let
live_references
=
r
.
as_ref
(
)
.
unwrap
(
)
;
let
mut
table
=
live_references
.
table
.
borrow_mut
(
)
;
match
table
.
entry
(
raw_reflectable
)
{
Occupied
(
entry
)
=
>
{
if
*
entry
.
get
(
)
.
lock
(
)
.
unwrap
(
)
!
=
0
{
return
;
}
let
_
=
entry
.
remove
(
)
;
}
Vacant
(
_
)
=
>
{
info
!
(
"
attempt
to
cleanup
an
unrecognized
reflector
"
)
;
}
}
}
)
}
}
pub
unsafe
extern
"
C
"
fn
trace_refcounted_objects
(
tracer
:
*
mut
JSTracer
_data
:
*
mut
os
:
:
raw
:
:
c_void
)
{
debug
!
(
"
tracing
live
refcounted
references
"
)
;
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
let
r
=
r
.
borrow
(
)
;
let
live_references
=
r
.
as_ref
(
)
.
unwrap
(
)
;
let
table
=
live_references
.
table
.
borrow
(
)
;
for
obj
in
table
.
keys
(
)
{
let
reflectable
=
&
*
(
*
obj
as
*
const
Reflector
)
;
trace_reflector
(
tracer
"
refcounted
"
reflectable
)
;
}
}
)
;
}
