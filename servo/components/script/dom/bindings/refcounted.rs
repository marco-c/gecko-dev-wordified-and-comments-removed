use
core
:
:
nonzero
:
:
NonZero
;
use
dom
:
:
bindings
:
:
conversions
:
:
ToJSValConvertible
;
use
dom
:
:
bindings
:
:
error
:
:
Error
;
use
dom
:
:
bindings
:
:
js
:
:
Root
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
DomObject
Reflector
}
;
use
dom
:
:
bindings
:
:
trace
:
:
trace_reflector
;
use
dom
:
:
promise
:
:
Promise
;
use
js
:
:
jsapi
:
:
JSAutoCompartment
;
use
js
:
:
jsapi
:
:
JSTracer
;
use
libc
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
:
:
{
Occupied
Vacant
}
;
use
std
:
:
collections
:
:
hash_map
:
:
HashMap
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
os
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
{
Arc
Weak
}
;
use
task
:
:
Task
;
#
[
allow
(
missing_docs
)
]
mod
dummy
{
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
rc
:
:
Rc
;
use
super
:
:
LiveDOMReferences
;
thread_local
!
(
pub
static
LIVE_REFERENCES
:
Rc
<
RefCell
<
Option
<
LiveDOMReferences
>
>
>
=
Rc
:
:
new
(
RefCell
:
:
new
(
None
)
)
)
;
}
pub
use
self
:
:
dummy
:
:
LIVE_REFERENCES
;
pub
struct
TrustedReference
(
*
const
libc
:
:
c_void
)
;
unsafe
impl
Send
for
TrustedReference
{
}
impl
TrustedReference
{
fn
new
<
T
:
DomObject
>
(
ptr
:
*
const
T
)
-
>
TrustedReference
{
TrustedReference
(
ptr
as
*
const
libc
:
:
c_void
)
}
}
pub
struct
TrustedPromise
{
dom_object
:
*
const
Promise
owner_thread
:
*
const
libc
:
:
c_void
}
unsafe
impl
Send
for
TrustedPromise
{
}
impl
TrustedPromise
{
#
[
allow
(
unrooted_must_root
)
]
pub
fn
new
(
promise
:
Rc
<
Promise
>
)
-
>
TrustedPromise
{
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
let
r
=
r
.
borrow
(
)
;
let
live_references
=
r
.
as_ref
(
)
.
unwrap
(
)
;
let
ptr
=
&
*
promise
as
*
const
Promise
;
live_references
.
addref_promise
(
promise
)
;
TrustedPromise
{
dom_object
:
ptr
owner_thread
:
(
&
*
live_references
)
as
*
const
_
as
*
const
libc
:
:
c_void
}
}
)
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
root
(
self
)
-
>
Rc
<
Promise
>
{
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
let
r
=
r
.
borrow
(
)
;
let
live_references
=
r
.
as_ref
(
)
.
unwrap
(
)
;
assert
!
(
self
.
owner_thread
=
=
(
&
*
live_references
)
as
*
const
_
as
*
const
libc
:
:
c_void
)
;
let
promise
=
match
live_references
.
promise_table
.
borrow_mut
(
)
.
entry
(
self
.
dom_object
)
{
Occupied
(
mut
entry
)
=
>
{
let
promise
=
{
let
promises
=
entry
.
get_mut
(
)
;
promises
.
pop
(
)
.
expect
(
"
rooted
promise
list
unexpectedly
empty
"
)
}
;
if
entry
.
get
(
)
.
is_empty
(
)
{
entry
.
remove
(
)
;
}
promise
}
Vacant
(
_
)
=
>
unreachable
!
(
)
}
;
promise
}
)
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
reject_task
(
self
error
:
Error
)
-
>
impl
Send
+
Task
{
let
this
=
self
;
task
!
(
reject_promise
:
move
|
|
{
debug
!
(
"
Rejecting
promise
.
"
)
;
let
this
=
this
.
root
(
)
;
let
cx
=
this
.
global
(
)
.
get_cx
(
)
;
let
_ac
=
JSAutoCompartment
:
:
new
(
cx
this
.
reflector
(
)
.
get_jsobject
(
)
.
get
(
)
)
;
this
.
reject_error
(
cx
error
)
;
}
)
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
resolve_task
<
T
>
(
self
value
:
T
)
-
>
impl
Send
+
Task
where
T
:
ToJSValConvertible
+
Send
{
let
this
=
self
;
task
!
(
resolve_promise
:
move
|
|
{
debug
!
(
"
Resolving
promise
.
"
)
;
let
this
=
this
.
root
(
)
;
let
cx
=
this
.
global
(
)
.
get_cx
(
)
;
let
_ac
=
JSAutoCompartment
:
:
new
(
cx
this
.
reflector
(
)
.
get_jsobject
(
)
.
get
(
)
)
;
this
.
resolve_native
(
cx
&
value
)
;
}
)
}
}
#
[
allow_unrooted_interior
]
pub
struct
Trusted
<
T
:
DomObject
>
{
refcount
:
Arc
<
TrustedReference
>
owner_thread
:
*
const
libc
:
:
c_void
phantom
:
PhantomData
<
T
>
}
unsafe
impl
<
T
:
DomObject
>
Send
for
Trusted
<
T
>
{
}
impl
<
T
:
DomObject
>
Trusted
<
T
>
{
pub
fn
new
(
ptr
:
&
T
)
-
>
Trusted
<
T
>
{
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
let
r
=
r
.
borrow
(
)
;
let
live_references
=
r
.
as_ref
(
)
.
unwrap
(
)
;
let
refcount
=
live_references
.
addref
(
&
*
ptr
as
*
const
T
)
;
Trusted
{
refcount
:
refcount
owner_thread
:
(
&
*
live_references
)
as
*
const
_
as
*
const
libc
:
:
c_void
phantom
:
PhantomData
}
}
)
}
pub
fn
root
(
&
self
)
-
>
Root
<
T
>
{
assert
!
(
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
let
r
=
r
.
borrow
(
)
;
let
live_references
=
r
.
as_ref
(
)
.
unwrap
(
)
;
self
.
owner_thread
=
=
(
&
*
live_references
)
as
*
const
_
as
*
const
libc
:
:
c_void
}
)
)
;
unsafe
{
Root
:
:
new
(
NonZero
:
:
new_unchecked
(
self
.
refcount
.
0
as
*
const
T
)
)
}
}
}
impl
<
T
:
DomObject
>
Clone
for
Trusted
<
T
>
{
fn
clone
(
&
self
)
-
>
Trusted
<
T
>
{
Trusted
{
refcount
:
self
.
refcount
.
clone
(
)
owner_thread
:
self
.
owner_thread
phantom
:
PhantomData
}
}
}
#
[
allow
(
unrooted_must_root
)
]
pub
struct
LiveDOMReferences
{
reflectable_table
:
RefCell
<
HashMap
<
*
const
libc
:
:
c_void
Weak
<
TrustedReference
>
>
>
promise_table
:
RefCell
<
HashMap
<
*
const
Promise
Vec
<
Rc
<
Promise
>
>
>
>
}
impl
LiveDOMReferences
{
pub
fn
initialize
(
)
{
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
*
r
.
borrow_mut
(
)
=
Some
(
LiveDOMReferences
{
reflectable_table
:
RefCell
:
:
new
(
HashMap
:
:
new
(
)
)
promise_table
:
RefCell
:
:
new
(
HashMap
:
:
new
(
)
)
}
)
}
)
;
}
#
[
allow
(
unrooted_must_root
)
]
fn
addref_promise
(
&
self
promise
:
Rc
<
Promise
>
)
{
let
mut
table
=
self
.
promise_table
.
borrow_mut
(
)
;
table
.
entry
(
&
*
promise
)
.
or_insert
(
vec
!
[
]
)
.
push
(
promise
)
}
fn
addref
<
T
:
DomObject
>
(
&
self
ptr
:
*
const
T
)
-
>
Arc
<
TrustedReference
>
{
let
mut
table
=
self
.
reflectable_table
.
borrow_mut
(
)
;
let
capacity
=
table
.
capacity
(
)
;
let
len
=
table
.
len
(
)
;
if
(
0
<
capacity
)
&
&
(
capacity
<
=
len
)
{
info
!
(
"
growing
refcounted
references
by
{
}
"
len
)
;
remove_nulls
(
&
mut
table
)
;
table
.
reserve
(
len
)
;
}
match
table
.
entry
(
ptr
as
*
const
libc
:
:
c_void
)
{
Occupied
(
mut
entry
)
=
>
match
entry
.
get
(
)
.
upgrade
(
)
{
Some
(
refcount
)
=
>
refcount
None
=
>
{
let
refcount
=
Arc
:
:
new
(
TrustedReference
:
:
new
(
ptr
)
)
;
entry
.
insert
(
Arc
:
:
downgrade
(
&
refcount
)
)
;
refcount
}
}
Vacant
(
entry
)
=
>
{
let
refcount
=
Arc
:
:
new
(
TrustedReference
:
:
new
(
ptr
)
)
;
entry
.
insert
(
Arc
:
:
downgrade
(
&
refcount
)
)
;
refcount
}
}
}
}
fn
remove_nulls
<
K
:
Eq
+
Hash
+
Clone
V
>
(
table
:
&
mut
HashMap
<
K
Weak
<
V
>
>
)
{
let
to_remove
:
Vec
<
K
>
=
table
.
iter
(
)
.
filter
(
|
&
(
_
value
)
|
Weak
:
:
upgrade
(
value
)
.
is_none
(
)
)
.
map
(
|
(
key
_
)
|
key
.
clone
(
)
)
.
collect
(
)
;
info
!
(
"
removing
{
}
refcounted
references
"
to_remove
.
len
(
)
)
;
for
key
in
to_remove
{
table
.
remove
(
&
key
)
;
}
}
#
[
allow
(
unrooted_must_root
)
]
pub
unsafe
extern
"
C
"
fn
trace_refcounted_objects
(
tracer
:
*
mut
JSTracer
_data
:
*
mut
os
:
:
raw
:
:
c_void
)
{
info
!
(
"
tracing
live
refcounted
references
"
)
;
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
let
r
=
r
.
borrow
(
)
;
let
live_references
=
r
.
as_ref
(
)
.
unwrap
(
)
;
{
let
mut
table
=
live_references
.
reflectable_table
.
borrow_mut
(
)
;
remove_nulls
(
&
mut
table
)
;
for
obj
in
table
.
keys
(
)
{
let
reflectable
=
&
*
(
*
obj
as
*
const
Reflector
)
;
trace_reflector
(
tracer
"
refcounted
"
reflectable
)
;
}
}
{
let
table
=
live_references
.
promise_table
.
borrow_mut
(
)
;
for
promise
in
table
.
keys
(
)
{
trace_reflector
(
tracer
"
refcounted
"
(
*
*
promise
)
.
reflector
(
)
)
;
}
}
}
)
;
}
