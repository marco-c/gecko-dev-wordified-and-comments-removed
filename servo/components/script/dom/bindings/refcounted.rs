#
!
[
deny
(
missing_docs
)
]
use
dom
:
:
bindings
:
:
js
:
:
{
Temporary
JS
JSRef
}
;
use
dom
:
:
bindings
:
:
utils
:
:
{
Reflector
Reflectable
}
;
use
script_task
:
:
{
ScriptMsg
ScriptChan
}
;
use
js
:
:
jsapi
:
:
{
JS_AddObjectRoot
JS_RemoveObjectRoot
JSContext
}
;
use
libc
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
collections
:
:
hash_map
:
:
{
HashMap
Vacant
Occupied
}
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
thread_local
!
(
pub
static
LIVE_REFERENCES
:
Rc
<
RefCell
<
Option
<
LiveDOMReferences
>
>
>
=
Rc
:
:
new
(
RefCell
:
:
new
(
None
)
)
)
pub
struct
TrustedReference
(
*
const
libc
:
:
c_void
)
;
pub
struct
Trusted
<
T
>
{
ptr
:
*
const
libc
:
:
c_void
refcount
:
Arc
<
Mutex
<
uint
>
>
script_chan
:
Box
<
ScriptChan
+
Send
>
owner_thread
:
*
const
libc
:
:
c_void
}
impl
<
T
:
Reflectable
>
Trusted
<
T
>
{
pub
fn
new
(
cx
:
*
mut
JSContext
ptr
:
JSRef
<
T
>
script_chan
:
Box
<
ScriptChan
+
Send
>
)
-
>
Trusted
<
T
>
{
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
let
r
=
r
.
borrow
(
)
;
let
live_references
=
r
.
as_ref
(
)
.
unwrap
(
)
;
let
refcount
=
live_references
.
addref
(
cx
&
*
ptr
as
*
const
T
)
;
Trusted
{
ptr
:
&
*
ptr
as
*
const
T
as
*
const
libc
:
:
c_void
refcount
:
refcount
script_chan
:
script_chan
.
clone
(
)
owner_thread
:
(
&
*
live_references
)
as
*
const
_
as
*
const
libc
:
:
c_void
}
}
)
}
pub
fn
to_temporary
(
&
self
)
-
>
Temporary
<
T
>
{
assert
!
(
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
let
r
=
r
.
borrow
(
)
;
let
live_references
=
r
.
as_ref
(
)
.
unwrap
(
)
;
self
.
owner_thread
=
=
(
&
*
live_references
)
as
*
const
_
as
*
const
libc
:
:
c_void
}
)
)
;
unsafe
{
Temporary
:
:
new
(
JS
:
:
from_raw
(
self
.
ptr
as
*
const
T
)
)
}
}
}
impl
<
T
:
Reflectable
>
Clone
for
Trusted
<
T
>
{
fn
clone
(
&
self
)
-
>
Trusted
<
T
>
{
{
let
mut
refcount
=
self
.
refcount
.
lock
(
)
;
*
refcount
+
=
1
;
}
Trusted
{
ptr
:
self
.
ptr
refcount
:
self
.
refcount
.
clone
(
)
script_chan
:
self
.
script_chan
.
clone
(
)
owner_thread
:
self
.
owner_thread
}
}
}
#
[
unsafe_destructor
]
impl
<
T
:
Reflectable
>
Drop
for
Trusted
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
mut
refcount
=
self
.
refcount
.
lock
(
)
;
assert
!
(
*
refcount
>
0
)
;
*
refcount
-
=
1
;
if
*
refcount
=
=
0
{
self
.
script_chan
.
send
(
ScriptMsg
:
:
RefcountCleanup
(
TrustedReference
(
self
.
ptr
)
)
)
;
}
}
}
pub
struct
LiveDOMReferences
{
table
:
RefCell
<
HashMap
<
*
const
libc
:
:
c_void
Arc
<
Mutex
<
uint
>
>
>
>
}
impl
LiveDOMReferences
{
pub
fn
initialize
(
)
{
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
*
r
.
borrow_mut
(
)
=
Some
(
LiveDOMReferences
{
table
:
RefCell
:
:
new
(
HashMap
:
:
new
(
)
)
}
)
}
)
;
}
fn
addref
<
T
:
Reflectable
>
(
&
self
cx
:
*
mut
JSContext
ptr
:
*
const
T
)
-
>
Arc
<
Mutex
<
uint
>
>
{
let
mut
table
=
self
.
table
.
borrow_mut
(
)
;
match
table
.
entry
(
ptr
as
*
const
libc
:
:
c_void
)
{
Occupied
(
mut
entry
)
=
>
{
let
refcount
=
entry
.
get_mut
(
)
;
*
refcount
.
lock
(
)
+
=
1
;
refcount
.
clone
(
)
}
Vacant
(
entry
)
=
>
{
unsafe
{
let
rootable
=
(
*
ptr
)
.
reflector
(
)
.
rootable
(
)
;
JS_AddObjectRoot
(
cx
rootable
)
;
}
let
refcount
=
Arc
:
:
new
(
Mutex
:
:
new
(
1
)
)
;
entry
.
set
(
refcount
.
clone
(
)
)
;
refcount
}
}
}
pub
fn
cleanup
(
cx
:
*
mut
JSContext
raw_reflectable
:
TrustedReference
)
{
let
TrustedReference
(
raw_reflectable
)
=
raw_reflectable
;
LIVE_REFERENCES
.
with
(
|
ref
r
|
{
let
r
=
r
.
borrow
(
)
;
let
live_references
=
r
.
as_ref
(
)
.
unwrap
(
)
;
let
reflectable
=
raw_reflectable
as
*
const
Reflector
;
let
mut
table
=
live_references
.
table
.
borrow_mut
(
)
;
match
table
.
entry
(
raw_reflectable
)
{
Occupied
(
entry
)
=
>
{
if
*
entry
.
get
(
)
.
lock
(
)
!
=
0
{
return
;
}
unsafe
{
JS_RemoveObjectRoot
(
cx
(
*
reflectable
)
.
rootable
(
)
)
;
}
let
_
=
entry
.
take
(
)
;
}
Vacant
(
_
)
=
>
{
info
!
(
"
attempt
to
cleanup
an
unrecognized
reflector
"
)
;
}
}
}
)
}
}
impl
Drop
for
LiveDOMReferences
{
fn
drop
(
&
mut
self
)
{
assert
!
(
self
.
table
.
borrow
(
)
.
keys
(
)
.
count
(
)
=
=
0
)
;
}
}
