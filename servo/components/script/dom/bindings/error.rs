use
dom
:
:
bindings
:
:
conversions
:
:
ToJSValConvertible
;
use
dom
:
:
bindings
:
:
global
:
:
GlobalRef
;
use
dom
:
:
domexception
:
:
{
DOMException
DOMErrorName
}
;
use
util
:
:
str
:
:
DOMString
;
use
js
:
:
jsapi
:
:
{
JSContext
JSBool
JSObject
}
;
use
js
:
:
jsapi
:
:
{
JS_IsExceptionPending
JS_SetPendingException
JS_ReportPendingException
}
;
use
js
:
:
jsapi
:
:
{
JS_ReportErrorNumber
JSErrorFormatString
JSEXN_TYPEERR
JSEXN_RANGEERR
}
;
use
js
:
:
jsapi
:
:
{
JS_SaveFrameChain
JS_RestoreFrameChain
}
;
use
js
:
:
glue
:
:
{
ReportError
}
;
use
js
:
:
rust
:
:
with_compartment
;
use
libc
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
ptr
;
#
[
derive
(
Debug
Clone
)
]
pub
enum
Error
{
IndexSize
NotFound
HierarchyRequest
InvalidCharacter
NotSupported
InUseAttribute
InvalidState
Syntax
Namespace
InvalidAccess
Security
Network
Abort
Timeout
DataClone
NoModificationAllowed
Type
(
DOMString
)
Range
(
DOMString
)
JSFailed
}
pub
type
Fallible
<
T
>
=
Result
<
T
Error
>
;
pub
type
ErrorResult
=
Fallible
<
(
)
>
;
pub
fn
throw_dom_exception
(
cx
:
*
mut
JSContext
global
:
GlobalRef
result
:
Error
)
{
let
code
=
match
result
{
Error
:
:
IndexSize
=
>
DOMErrorName
:
:
IndexSizeError
Error
:
:
NotFound
=
>
DOMErrorName
:
:
NotFoundError
Error
:
:
HierarchyRequest
=
>
DOMErrorName
:
:
HierarchyRequestError
Error
:
:
InvalidCharacter
=
>
DOMErrorName
:
:
InvalidCharacterError
Error
:
:
NotSupported
=
>
DOMErrorName
:
:
NotSupportedError
Error
:
:
InUseAttribute
=
>
DOMErrorName
:
:
InUseAttributeError
Error
:
:
InvalidState
=
>
DOMErrorName
:
:
InvalidStateError
Error
:
:
Syntax
=
>
DOMErrorName
:
:
SyntaxError
Error
:
:
Namespace
=
>
DOMErrorName
:
:
NamespaceError
Error
:
:
InvalidAccess
=
>
DOMErrorName
:
:
InvalidAccessError
Error
:
:
Security
=
>
DOMErrorName
:
:
SecurityError
Error
:
:
Network
=
>
DOMErrorName
:
:
NetworkError
Error
:
:
Abort
=
>
DOMErrorName
:
:
AbortError
Error
:
:
Timeout
=
>
DOMErrorName
:
:
TimeoutError
Error
:
:
DataClone
=
>
DOMErrorName
:
:
DataCloneError
Error
:
:
NoModificationAllowed
=
>
DOMErrorName
:
:
NoModificationAllowedError
Error
:
:
Type
(
message
)
=
>
{
assert
!
(
unsafe
{
JS_IsExceptionPending
(
cx
)
}
=
=
0
)
;
throw_type_error
(
cx
&
message
)
;
return
;
}
Error
:
:
Range
(
message
)
=
>
{
assert
!
(
unsafe
{
JS_IsExceptionPending
(
cx
)
}
=
=
0
)
;
throw_range_error
(
cx
&
message
)
;
return
;
}
Error
:
:
JSFailed
=
>
{
assert
!
(
unsafe
{
JS_IsExceptionPending
(
cx
)
}
=
=
1
)
;
return
;
}
}
;
assert
!
(
unsafe
{
JS_IsExceptionPending
(
cx
)
}
=
=
0
)
;
let
exception
=
DOMException
:
:
new
(
global
code
)
.
root
(
)
;
let
thrown
=
exception
.
to_jsval
(
cx
)
;
unsafe
{
JS_SetPendingException
(
cx
thrown
)
;
}
}
pub
fn
report_pending_exception
(
cx
:
*
mut
JSContext
obj
:
*
mut
JSObject
)
{
unsafe
{
if
JS_IsExceptionPending
(
cx
)
!
=
0
{
let
saved
=
JS_SaveFrameChain
(
cx
)
;
with_compartment
(
cx
obj
|
|
{
JS_ReportPendingException
(
cx
)
;
}
)
;
if
saved
!
=
0
{
JS_RestoreFrameChain
(
cx
)
;
}
}
}
}
pub
fn
throw_not_in_union
(
cx
:
*
mut
JSContext
names
:
&
'
static
str
)
-
>
JSBool
{
assert
!
(
unsafe
{
JS_IsExceptionPending
(
cx
)
}
=
=
0
)
;
let
message
=
format
!
(
"
argument
could
not
be
converted
to
any
of
:
{
}
"
names
)
;
let
string
=
CString
:
:
new
(
message
)
.
unwrap
(
)
;
unsafe
{
ReportError
(
cx
string
.
as_ptr
(
)
)
}
;
return
0
;
}
static
ERROR_FORMAT_STRING_STRING
:
[
libc
:
:
c_char
;
4
]
=
[
'
{
'
as
libc
:
:
c_char
'
0
'
as
libc
:
:
c_char
'
}
'
as
libc
:
:
c_char
0
as
libc
:
:
c_char
]
;
static
mut
TYPE_ERROR_FORMAT_STRING
:
JSErrorFormatString
=
JSErrorFormatString
{
format
:
&
ERROR_FORMAT_STRING_STRING
as
*
const
libc
:
:
c_char
argCount
:
1
exnType
:
JSEXN_TYPEERR
as
i16
}
;
static
mut
RANGE_ERROR_FORMAT_STRING
:
JSErrorFormatString
=
JSErrorFormatString
{
format
:
&
ERROR_FORMAT_STRING_STRING
as
*
const
libc
:
:
c_char
argCount
:
1
exnType
:
JSEXN_RANGEERR
as
i16
}
;
unsafe
extern
fn
get_error_message
(
_user_ref
:
*
mut
libc
:
:
c_void
_locale
:
*
const
libc
:
:
c_char
error_number
:
libc
:
:
c_uint
)
-
>
*
const
JSErrorFormatString
{
match
error_number
as
i32
{
JSEXN_TYPEERR
=
>
&
TYPE_ERROR_FORMAT_STRING
as
*
const
JSErrorFormatString
JSEXN_RANGEERR
=
>
&
RANGE_ERROR_FORMAT_STRING
as
*
const
JSErrorFormatString
_
=
>
panic
!
(
"
Bad
js
error
number
given
to
get_error_message
:
{
}
"
error_number
)
}
}
fn
throw_js_error
(
cx
:
*
mut
JSContext
error
:
&
str
error_number
:
u32
)
{
let
error
=
CString
:
:
new
(
error
)
.
unwrap
(
)
;
unsafe
{
JS_ReportErrorNumber
(
cx
Some
(
get_error_message
as
unsafe
extern
"
C
"
fn
(
*
mut
libc
:
:
c_void
*
const
libc
:
:
c_char
libc
:
:
c_uint
)
-
>
*
const
JSErrorFormatString
)
ptr
:
:
null_mut
(
)
error_number
error
.
as_ptr
(
)
)
;
}
}
pub
fn
throw_type_error
(
cx
:
*
mut
JSContext
error
:
&
str
)
{
throw_js_error
(
cx
error
JSEXN_TYPEERR
as
u32
)
;
}
pub
fn
throw_range_error
(
cx
:
*
mut
JSContext
error
:
&
str
)
{
throw_js_error
(
cx
error
JSEXN_RANGEERR
as
u32
)
;
}
