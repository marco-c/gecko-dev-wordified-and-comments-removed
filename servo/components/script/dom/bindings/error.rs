use
dom
:
:
bindings
:
:
codegen
:
:
PrototypeList
:
:
proto_id_to_name
;
use
dom
:
:
bindings
:
:
conversions
:
:
ToJSValConvertible
;
use
dom
:
:
bindings
:
:
global
:
:
GlobalRef
;
use
dom
:
:
domexception
:
:
{
DOMErrorName
DOMException
}
;
use
js
:
:
jsapi
:
:
JSAutoCompartment
;
use
js
:
:
jsapi
:
:
{
JSContext
JSObject
RootedValue
}
;
use
js
:
:
jsapi
:
:
{
JSErrorFormatString
JSExnType
JS_ReportErrorNumber1
}
;
use
js
:
:
jsapi
:
:
{
JS_IsExceptionPending
JS_ReportPendingException
JS_SetPendingException
}
;
use
js
:
:
jsapi
:
:
{
JS_RestoreFrameChain
JS_SaveFrameChain
}
;
use
js
:
:
jsval
:
:
UndefinedValue
;
use
libc
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
{
mem
ptr
}
;
use
util
:
:
mem
:
:
HeapSizeOf
;
use
util
:
:
str
:
:
DOMString
;
#
[
derive
(
Debug
Clone
HeapSizeOf
)
]
pub
enum
Error
{
IndexSize
NotFound
HierarchyRequest
WrongDocument
InvalidCharacter
NotSupported
InUseAttribute
InvalidState
Syntax
Namespace
InvalidAccess
Security
Network
Abort
Timeout
InvalidNodeType
DataClone
NoModificationAllowed
QuotaExceeded
TypeMismatch
Type
(
DOMString
)
Range
(
DOMString
)
JSFailed
}
pub
type
Fallible
<
T
>
=
Result
<
T
Error
>
;
pub
type
ErrorResult
=
Fallible
<
(
)
>
;
pub
fn
throw_dom_exception
(
cx
:
*
mut
JSContext
global
:
GlobalRef
result
:
Error
)
{
let
code
=
match
result
{
Error
:
:
IndexSize
=
>
DOMErrorName
:
:
IndexSizeError
Error
:
:
NotFound
=
>
DOMErrorName
:
:
NotFoundError
Error
:
:
HierarchyRequest
=
>
DOMErrorName
:
:
HierarchyRequestError
Error
:
:
WrongDocument
=
>
DOMErrorName
:
:
WrongDocumentError
Error
:
:
InvalidCharacter
=
>
DOMErrorName
:
:
InvalidCharacterError
Error
:
:
NotSupported
=
>
DOMErrorName
:
:
NotSupportedError
Error
:
:
InUseAttribute
=
>
DOMErrorName
:
:
InUseAttributeError
Error
:
:
InvalidState
=
>
DOMErrorName
:
:
InvalidStateError
Error
:
:
Syntax
=
>
DOMErrorName
:
:
SyntaxError
Error
:
:
Namespace
=
>
DOMErrorName
:
:
NamespaceError
Error
:
:
InvalidAccess
=
>
DOMErrorName
:
:
InvalidAccessError
Error
:
:
Security
=
>
DOMErrorName
:
:
SecurityError
Error
:
:
Network
=
>
DOMErrorName
:
:
NetworkError
Error
:
:
Abort
=
>
DOMErrorName
:
:
AbortError
Error
:
:
Timeout
=
>
DOMErrorName
:
:
TimeoutError
Error
:
:
InvalidNodeType
=
>
DOMErrorName
:
:
InvalidNodeTypeError
Error
:
:
DataClone
=
>
DOMErrorName
:
:
DataCloneError
Error
:
:
NoModificationAllowed
=
>
DOMErrorName
:
:
NoModificationAllowedError
Error
:
:
QuotaExceeded
=
>
DOMErrorName
:
:
QuotaExceededError
Error
:
:
TypeMismatch
=
>
DOMErrorName
:
:
TypeMismatchError
Error
:
:
Type
(
message
)
=
>
{
assert
!
(
unsafe
{
JS_IsExceptionPending
(
cx
)
}
=
=
0
)
;
throw_type_error
(
cx
&
message
)
;
return
;
}
Error
:
:
Range
(
message
)
=
>
{
assert
!
(
unsafe
{
JS_IsExceptionPending
(
cx
)
}
=
=
0
)
;
throw_range_error
(
cx
&
message
)
;
return
;
}
Error
:
:
JSFailed
=
>
{
assert
!
(
unsafe
{
JS_IsExceptionPending
(
cx
)
}
=
=
1
)
;
return
;
}
}
;
assert
!
(
unsafe
{
JS_IsExceptionPending
(
cx
)
}
=
=
0
)
;
let
exception
=
DOMException
:
:
new
(
global
code
)
;
let
mut
thrown
=
RootedValue
:
:
new
(
cx
UndefinedValue
(
)
)
;
exception
.
to_jsval
(
cx
thrown
.
handle_mut
(
)
)
;
unsafe
{
JS_SetPendingException
(
cx
thrown
.
handle
(
)
)
;
}
}
pub
fn
report_pending_exception
(
cx
:
*
mut
JSContext
obj
:
*
mut
JSObject
)
{
unsafe
{
if
JS_IsExceptionPending
(
cx
)
!
=
0
{
let
saved
=
JS_SaveFrameChain
(
cx
)
;
{
let
_ac
=
JSAutoCompartment
:
:
new
(
cx
obj
)
;
JS_ReportPendingException
(
cx
)
;
}
if
saved
!
=
0
{
JS_RestoreFrameChain
(
cx
)
;
}
}
}
}
pub
fn
throw_not_in_union
(
cx
:
*
mut
JSContext
names
:
&
'
static
str
)
{
assert
!
(
unsafe
{
JS_IsExceptionPending
(
cx
)
}
=
=
0
)
;
let
error
=
format
!
(
"
argument
could
not
be
converted
to
any
of
:
{
}
"
names
)
;
throw_type_error
(
cx
&
error
)
;
}
pub
fn
throw_invalid_this
(
cx
:
*
mut
JSContext
proto_id
:
u16
)
{
debug_assert
!
(
unsafe
{
JS_IsExceptionPending
(
cx
)
}
=
=
0
)
;
let
error
=
format
!
(
"
\
"
this
\
"
object
does
not
implement
interface
{
}
.
"
proto_id_to_name
(
proto_id
)
)
;
throw_type_error
(
cx
&
error
)
;
}
static
ERROR_FORMAT_STRING_STRING
:
[
libc
:
:
c_char
;
4
]
=
[
'
{
'
as
libc
:
:
c_char
'
0
'
as
libc
:
:
c_char
'
}
'
as
libc
:
:
c_char
0
as
libc
:
:
c_char
]
;
static
mut
TYPE_ERROR_FORMAT_STRING
:
JSErrorFormatString
=
JSErrorFormatString
{
format
:
&
ERROR_FORMAT_STRING_STRING
as
*
const
libc
:
:
c_char
argCount
:
1
exnType
:
JSExnType
:
:
JSEXN_TYPEERR
as
i16
}
;
static
mut
RANGE_ERROR_FORMAT_STRING
:
JSErrorFormatString
=
JSErrorFormatString
{
format
:
&
ERROR_FORMAT_STRING_STRING
as
*
const
libc
:
:
c_char
argCount
:
1
exnType
:
JSExnType
:
:
JSEXN_RANGEERR
as
i16
}
;
unsafe
extern
fn
get_error_message
(
_user_ref
:
*
mut
libc
:
:
c_void
error_number
:
libc
:
:
c_uint
)
-
>
*
const
JSErrorFormatString
{
let
num
:
JSExnType
=
mem
:
:
transmute
(
error_number
)
;
match
num
{
JSExnType
:
:
JSEXN_TYPEERR
=
>
&
TYPE_ERROR_FORMAT_STRING
as
*
const
JSErrorFormatString
JSExnType
:
:
JSEXN_RANGEERR
=
>
&
RANGE_ERROR_FORMAT_STRING
as
*
const
JSErrorFormatString
_
=
>
panic
!
(
"
Bad
js
error
number
given
to
get_error_message
:
{
}
"
error_number
)
}
}
fn
throw_js_error
(
cx
:
*
mut
JSContext
error
:
&
str
error_number
:
u32
)
{
let
error
=
CString
:
:
new
(
error
)
.
unwrap
(
)
;
unsafe
{
JS_ReportErrorNumber1
(
cx
Some
(
get_error_message
)
ptr
:
:
null_mut
(
)
error_number
error
.
as_ptr
(
)
)
;
}
}
pub
fn
throw_type_error
(
cx
:
*
mut
JSContext
error
:
&
str
)
{
throw_js_error
(
cx
error
JSExnType
:
:
JSEXN_TYPEERR
as
u32
)
;
}
pub
fn
throw_range_error
(
cx
:
*
mut
JSContext
error
:
&
str
)
{
throw_js_error
(
cx
error
JSExnType
:
:
JSEXN_RANGEERR
as
u32
)
;
}
