use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
DOMExceptionBinding
:
:
DOMExceptionMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
PrototypeList
:
:
proto_id_to_name
;
use
dom
:
:
bindings
:
:
conversions
:
:
root_from_object
;
use
dom
:
:
bindings
:
:
conversions
:
:
{
ConversionResult
FromJSValConvertible
ToJSValConvertible
}
;
use
dom
:
:
bindings
:
:
global
:
:
{
GlobalRef
global_root_from_context
}
;
use
dom
:
:
bindings
:
:
str
:
:
USVString
;
use
dom
:
:
domexception
:
:
{
DOMErrorName
DOMException
}
;
use
js
:
:
error
:
:
{
throw_range_error
throw_type_error
}
;
use
js
:
:
jsapi
:
:
HandleObject
;
use
js
:
:
jsapi
:
:
JSContext
;
use
js
:
:
jsapi
:
:
JS_ClearPendingException
;
use
js
:
:
jsapi
:
:
JS_ErrorFromException
;
use
js
:
:
jsapi
:
:
JS_GetPendingException
;
use
js
:
:
jsapi
:
:
JS_IsExceptionPending
;
use
js
:
:
jsapi
:
:
JS_SetPendingException
;
use
js
:
:
jsval
:
:
UndefinedValue
;
use
libc
:
:
c_uint
;
use
std
:
:
slice
:
:
from_raw_parts
;
#
[
derive
(
Debug
Clone
HeapSizeOf
)
]
pub
enum
Error
{
IndexSize
NotFound
HierarchyRequest
WrongDocument
InvalidCharacter
NotSupported
InUseAttribute
InvalidState
Syntax
Namespace
InvalidAccess
Security
Network
Abort
Timeout
InvalidNodeType
DataClone
NoModificationAllowed
QuotaExceeded
TypeMismatch
InvalidModification
Type
(
String
)
Range
(
String
)
JSFailed
}
pub
type
Fallible
<
T
>
=
Result
<
T
Error
>
;
pub
type
ErrorResult
=
Fallible
<
(
)
>
;
pub
unsafe
fn
throw_dom_exception
(
cx
:
*
mut
JSContext
global
:
GlobalRef
result
:
Error
)
{
let
code
=
match
result
{
Error
:
:
IndexSize
=
>
DOMErrorName
:
:
IndexSizeError
Error
:
:
NotFound
=
>
DOMErrorName
:
:
NotFoundError
Error
:
:
HierarchyRequest
=
>
DOMErrorName
:
:
HierarchyRequestError
Error
:
:
WrongDocument
=
>
DOMErrorName
:
:
WrongDocumentError
Error
:
:
InvalidCharacter
=
>
DOMErrorName
:
:
InvalidCharacterError
Error
:
:
NotSupported
=
>
DOMErrorName
:
:
NotSupportedError
Error
:
:
InUseAttribute
=
>
DOMErrorName
:
:
InUseAttributeError
Error
:
:
InvalidState
=
>
DOMErrorName
:
:
InvalidStateError
Error
:
:
Syntax
=
>
DOMErrorName
:
:
SyntaxError
Error
:
:
Namespace
=
>
DOMErrorName
:
:
NamespaceError
Error
:
:
InvalidAccess
=
>
DOMErrorName
:
:
InvalidAccessError
Error
:
:
Security
=
>
DOMErrorName
:
:
SecurityError
Error
:
:
Network
=
>
DOMErrorName
:
:
NetworkError
Error
:
:
Abort
=
>
DOMErrorName
:
:
AbortError
Error
:
:
Timeout
=
>
DOMErrorName
:
:
TimeoutError
Error
:
:
InvalidNodeType
=
>
DOMErrorName
:
:
InvalidNodeTypeError
Error
:
:
DataClone
=
>
DOMErrorName
:
:
DataCloneError
Error
:
:
NoModificationAllowed
=
>
DOMErrorName
:
:
NoModificationAllowedError
Error
:
:
QuotaExceeded
=
>
DOMErrorName
:
:
QuotaExceededError
Error
:
:
TypeMismatch
=
>
DOMErrorName
:
:
TypeMismatchError
Error
:
:
InvalidModification
=
>
DOMErrorName
:
:
InvalidModificationError
Error
:
:
Type
(
message
)
=
>
{
assert
!
(
!
JS_IsExceptionPending
(
cx
)
)
;
throw_type_error
(
cx
&
message
)
;
return
;
}
Error
:
:
Range
(
message
)
=
>
{
assert
!
(
!
JS_IsExceptionPending
(
cx
)
)
;
throw_range_error
(
cx
&
message
)
;
return
;
}
Error
:
:
JSFailed
=
>
{
assert
!
(
JS_IsExceptionPending
(
cx
)
)
;
return
;
}
}
;
assert
!
(
!
JS_IsExceptionPending
(
cx
)
)
;
let
exception
=
DOMException
:
:
new
(
global
code
)
;
rooted
!
(
in
(
cx
)
let
mut
thrown
=
UndefinedValue
(
)
)
;
exception
.
to_jsval
(
cx
thrown
.
handle_mut
(
)
)
;
JS_SetPendingException
(
cx
thrown
.
handle
(
)
)
;
}
pub
struct
ErrorInfo
{
pub
message
:
String
pub
filename
:
String
pub
lineno
:
c_uint
pub
column
:
c_uint
}
impl
ErrorInfo
{
unsafe
fn
from_native_error
(
cx
:
*
mut
JSContext
object
:
HandleObject
)
-
>
Option
<
ErrorInfo
>
{
let
report
=
JS_ErrorFromException
(
cx
object
)
;
if
report
.
is_null
(
)
{
return
None
;
}
let
filename
=
{
let
filename
=
(
*
report
)
.
filename
as
*
const
u8
;
if
!
filename
.
is_null
(
)
{
let
length
=
(
0
.
.
)
.
find
(
|
idx
|
*
filename
.
offset
(
*
idx
)
=
=
0
)
.
unwrap
(
)
;
let
filename
=
from_raw_parts
(
filename
length
as
usize
)
;
String
:
:
from_utf8_lossy
(
filename
)
.
into_owned
(
)
}
else
{
"
none
"
.
to_string
(
)
}
}
;
let
lineno
=
(
*
report
)
.
lineno
;
let
column
=
(
*
report
)
.
column
;
let
message
=
{
let
message
=
(
*
report
)
.
ucmessage
;
let
length
=
(
0
.
.
)
.
find
(
|
idx
|
*
message
.
offset
(
*
idx
)
=
=
0
)
.
unwrap
(
)
;
let
message
=
from_raw_parts
(
message
length
as
usize
)
;
String
:
:
from_utf16_lossy
(
message
)
}
;
Some
(
ErrorInfo
{
filename
:
filename
message
:
message
lineno
:
lineno
column
:
column
}
)
}
fn
from_dom_exception
(
object
:
HandleObject
)
-
>
Option
<
ErrorInfo
>
{
let
exception
=
match
root_from_object
:
:
<
DOMException
>
(
object
.
get
(
)
)
{
Ok
(
exception
)
=
>
exception
Err
(
_
)
=
>
return
None
}
;
Some
(
ErrorInfo
{
filename
:
"
"
.
to_string
(
)
message
:
exception
.
Stringifier
(
)
.
into
(
)
lineno
:
0
column
:
0
}
)
}
}
pub
unsafe
fn
report_pending_exception
(
cx
:
*
mut
JSContext
dispatch_event
:
bool
)
{
if
JS_IsExceptionPending
(
cx
)
{
rooted
!
(
in
(
cx
)
let
mut
value
=
UndefinedValue
(
)
)
;
if
!
JS_GetPendingException
(
cx
value
.
handle_mut
(
)
)
{
JS_ClearPendingException
(
cx
)
;
error
!
(
"
Uncaught
exception
:
JS_GetPendingException
failed
"
)
;
return
;
}
JS_ClearPendingException
(
cx
)
;
let
error_info
=
if
value
.
is_object
(
)
{
rooted
!
(
in
(
cx
)
let
object
=
value
.
to_object
(
)
)
;
let
error_info
=
ErrorInfo
:
:
from_native_error
(
cx
object
.
handle
(
)
)
.
or_else
(
|
|
ErrorInfo
:
:
from_dom_exception
(
object
.
handle
(
)
)
)
;
match
error_info
{
Some
(
error_info
)
=
>
error_info
None
=
>
{
error
!
(
"
Uncaught
exception
:
failed
to
extract
information
"
)
;
return
;
}
}
}
else
{
match
USVString
:
:
from_jsval
(
cx
value
.
handle
(
)
(
)
)
{
Ok
(
ConversionResult
:
:
Success
(
USVString
(
string
)
)
)
=
>
{
ErrorInfo
{
message
:
format
!
(
"
uncaught
exception
:
{
}
"
string
)
filename
:
String
:
:
new
(
)
lineno
:
0
column
:
0
}
}
_
=
>
{
panic
!
(
"
Uncaught
exception
:
failed
to
stringify
primitive
"
)
;
}
}
}
;
error
!
(
"
Error
at
{
}
:
{
}
:
{
}
{
}
"
error_info
.
filename
error_info
.
lineno
error_info
.
column
error_info
.
message
)
;
if
dispatch_event
{
let
global
=
global_root_from_context
(
cx
)
;
if
let
GlobalRef
:
:
Window
(
window
)
=
global
.
r
(
)
{
window
.
report_an_error
(
error_info
value
.
handle
(
)
)
;
}
}
}
}
pub
unsafe
fn
throw_not_in_union
(
cx
:
*
mut
JSContext
names
:
&
'
static
str
)
{
assert
!
(
!
JS_IsExceptionPending
(
cx
)
)
;
let
error
=
format
!
(
"
argument
could
not
be
converted
to
any
of
:
{
}
"
names
)
;
throw_type_error
(
cx
&
error
)
;
}
pub
unsafe
fn
throw_invalid_this
(
cx
:
*
mut
JSContext
proto_id
:
u16
)
{
debug_assert
!
(
!
JS_IsExceptionPending
(
cx
)
)
;
let
error
=
format
!
(
"
\
"
this
\
"
object
does
not
implement
interface
{
}
.
"
proto_id_to_name
(
proto_id
)
)
;
throw_type_error
(
cx
&
error
)
;
}
