use
dom
:
:
bindings
:
:
js
:
:
{
JS
Root
}
;
use
dom
:
:
bindings
:
:
trace
:
:
JSTraceable
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
js
:
:
jsapi
:
:
JSTracer
;
use
std
:
:
cell
:
:
RefCell
;
thread_local
!
(
static
STACK
:
RefCell
<
Vec
<
StackEntry
>
>
=
RefCell
:
:
new
(
Vec
:
:
new
(
)
)
)
;
#
[
allow
(
unrooted_must_root
)
]
#
[
derive
(
JSTraceable
)
]
struct
StackEntry
{
global
:
JS
<
GlobalScope
>
}
pub
unsafe
fn
trace
(
tracer
:
*
mut
JSTracer
)
{
STACK
.
with
(
|
stack
|
{
stack
.
borrow
(
)
.
trace
(
tracer
)
;
}
)
}
pub
struct
AutoEntryScript
{
global
:
*
const
GlobalScope
}
impl
AutoEntryScript
{
pub
fn
new
(
global
:
&
GlobalScope
)
-
>
Self
{
STACK
.
with
(
|
stack
|
{
trace
!
(
"
Prepare
to
run
script
with
{
:
p
}
"
global
)
;
let
mut
stack
=
stack
.
borrow_mut
(
)
;
stack
.
push
(
StackEntry
{
global
:
JS
:
:
from_ref
(
global
)
}
)
;
AutoEntryScript
{
global
:
global
as
*
const
_
}
}
)
}
}
impl
Drop
for
AutoEntryScript
{
fn
drop
(
&
mut
self
)
{
STACK
.
with
(
|
stack
|
{
let
mut
stack
=
stack
.
borrow_mut
(
)
;
let
entry
=
stack
.
pop
(
)
.
unwrap
(
)
;
assert_eq
!
(
&
*
entry
.
global
as
*
const
GlobalScope
self
.
global
"
Dropped
AutoEntryScript
out
of
order
.
"
)
;
trace
!
(
"
Clean
up
after
running
script
with
{
:
p
}
"
self
.
global
)
;
}
)
}
}
pub
fn
entry_global
(
)
-
>
Root
<
GlobalScope
>
{
STACK
.
with
(
|
stack
|
{
stack
.
borrow
(
)
.
last
(
)
.
map
(
|
entry
|
Root
:
:
from_ref
(
&
*
entry
.
global
)
)
}
)
.
unwrap
(
)
}
