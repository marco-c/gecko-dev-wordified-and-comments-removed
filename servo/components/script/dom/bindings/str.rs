use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
mem
;
use
std
:
:
ops
;
use
std
:
:
str
;
use
std
:
:
str
:
:
FromStr
;
#
[
derive
(
JSTraceable
Clone
Eq
PartialEq
HeapSizeOf
)
]
pub
struct
ByteString
(
Vec
<
u8
>
)
;
impl
ByteString
{
pub
fn
new
(
value
:
Vec
<
u8
>
)
-
>
ByteString
{
ByteString
(
value
)
}
pub
fn
as_str
(
&
self
)
-
>
Option
<
&
str
>
{
str
:
:
from_utf8
(
&
self
.
0
)
.
ok
(
)
}
pub
fn
bytes
(
&
mut
self
)
-
>
Vec
<
u8
>
{
mem
:
:
replace
(
&
mut
self
.
0
Vec
:
:
new
(
)
)
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
0
.
len
(
)
}
pub
fn
eq_ignore_case
(
&
self
other
:
&
ByteString
)
-
>
bool
{
self
.
0
.
eq_ignore_ascii_case
(
&
other
.
0
)
}
pub
fn
to_lower
(
&
self
)
-
>
ByteString
{
ByteString
:
:
new
(
self
.
0
.
to_ascii_lowercase
(
)
)
}
}
impl
Into
<
Vec
<
u8
>
>
for
ByteString
{
fn
into
(
self
)
-
>
Vec
<
u8
>
{
self
.
0
}
}
impl
Hash
for
ByteString
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
0
.
hash
(
state
)
;
}
}
impl
FromStr
for
ByteString
{
type
Err
=
(
)
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
ByteString
(
)
>
{
Ok
(
ByteString
:
:
new
(
s
.
to_owned
(
)
.
into_bytes
(
)
)
)
}
}
impl
ops
:
:
Deref
for
ByteString
{
type
Target
=
[
u8
]
;
fn
deref
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
0
}
}
pub
struct
USVString
(
pub
String
)
;
pub
fn
is_token
(
s
:
&
[
u8
]
)
-
>
bool
{
if
s
.
is_empty
(
)
{
return
false
;
}
s
.
iter
(
)
.
all
(
|
&
x
|
{
match
x
{
0
.
.
.
31
|
127
=
>
false
40
|
41
|
60
|
62
|
64
|
44
|
59
|
58
|
92
|
34
|
47
|
91
|
93
|
63
|
61
|
123
|
125
|
32
=
>
false
x
if
x
>
127
=
>
false
_
=
>
true
}
}
)
}
