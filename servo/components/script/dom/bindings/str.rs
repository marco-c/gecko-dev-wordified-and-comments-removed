use
chrono
:
:
{
Datelike
TimeZone
}
;
use
chrono
:
:
prelude
:
:
{
Weekday
Utc
}
;
use
cssparser
:
:
CowRcStr
;
use
html5ever
:
:
{
LocalName
Namespace
}
;
use
servo_atoms
:
:
Atom
;
use
std
:
:
borrow
:
:
{
Borrow
Cow
ToOwned
}
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
fmt
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
ops
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
str
;
use
std
:
:
str
:
:
{
Bytes
FromStr
}
;
#
[
derive
(
Clone
Debug
Default
Eq
JSTraceable
MallocSizeOf
PartialEq
)
]
pub
struct
ByteString
(
Vec
<
u8
>
)
;
impl
ByteString
{
pub
fn
new
(
value
:
Vec
<
u8
>
)
-
>
ByteString
{
ByteString
(
value
)
}
pub
fn
as_str
(
&
self
)
-
>
Option
<
&
str
>
{
str
:
:
from_utf8
(
&
self
.
0
)
.
ok
(
)
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
0
.
len
(
)
}
pub
fn
eq_ignore_case
(
&
self
other
:
&
ByteString
)
-
>
bool
{
self
.
0
.
eq_ignore_ascii_case
(
&
other
.
0
)
}
pub
fn
to_lower
(
&
self
)
-
>
ByteString
{
ByteString
:
:
new
(
self
.
0
.
to_ascii_lowercase
(
)
)
}
}
impl
Into
<
Vec
<
u8
>
>
for
ByteString
{
fn
into
(
self
)
-
>
Vec
<
u8
>
{
self
.
0
}
}
impl
Hash
for
ByteString
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
0
.
hash
(
state
)
;
}
}
impl
FromStr
for
ByteString
{
type
Err
=
(
)
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
ByteString
(
)
>
{
Ok
(
ByteString
:
:
new
(
s
.
to_owned
(
)
.
into_bytes
(
)
)
)
}
}
impl
ops
:
:
Deref
for
ByteString
{
type
Target
=
[
u8
]
;
fn
deref
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
0
}
}
#
[
derive
(
Clone
Default
MallocSizeOf
)
]
pub
struct
USVString
(
pub
String
)
;
pub
fn
is_token
(
s
:
&
[
u8
]
)
-
>
bool
{
if
s
.
is_empty
(
)
{
return
false
;
}
s
.
iter
(
)
.
all
(
|
&
x
|
{
match
x
{
0
.
.
.
31
|
127
=
>
false
40
|
41
|
60
|
62
|
64
|
44
|
59
|
58
|
92
|
34
|
47
|
91
|
93
|
63
|
61
|
123
|
125
|
32
=
>
false
x
if
x
>
127
=
>
false
_
=
>
true
}
}
)
}
#
[
derive
(
Clone
Debug
Eq
Hash
MallocSizeOf
Ord
PartialEq
PartialOrd
)
]
pub
struct
DOMString
(
String
PhantomData
<
*
const
(
)
>
)
;
impl
DOMString
{
pub
fn
new
(
)
-
>
DOMString
{
DOMString
(
String
:
:
new
(
)
PhantomData
)
}
pub
fn
from_string
(
s
:
String
)
-
>
DOMString
{
DOMString
(
s
PhantomData
)
}
pub
fn
push_str
(
&
mut
self
string
:
&
str
)
{
self
.
0
.
push_str
(
string
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
0
.
clear
(
)
}
pub
fn
truncate
(
&
mut
self
new_len
:
usize
)
{
self
.
0
.
truncate
(
new_len
)
;
}
pub
fn
bytes
(
&
self
)
-
>
Bytes
{
self
.
0
.
bytes
(
)
}
pub
fn
strip_newlines
(
&
mut
self
)
{
self
.
0
.
retain
(
|
c
|
c
!
=
'
\
r
'
&
&
c
!
=
'
\
n
'
)
;
}
pub
fn
strip_leading_and_trailing_ascii_whitespace
(
&
mut
self
)
{
if
self
.
0
.
len
(
)
=
=
0
{
return
;
}
let
last_non_whitespace
=
match
self
.
0
.
rfind
(
|
ref
c
|
!
char
:
:
is_ascii_whitespace
(
c
)
)
{
Some
(
idx
)
=
>
idx
+
1
None
=
>
{
self
.
0
.
clear
(
)
;
return
;
}
}
;
let
first_non_whitespace
=
self
.
0
.
find
(
|
ref
c
|
!
char
:
:
is_ascii_whitespace
(
c
)
)
.
unwrap
(
)
;
self
.
0
.
truncate
(
last_non_whitespace
)
;
let
_
=
self
.
0
.
replace_range
(
0
.
.
first_non_whitespace
"
"
)
;
}
pub
fn
is_valid_time_string
(
&
self
)
-
>
bool
{
enum
State
{
HourHigh
HourLow09
HourLow03
MinuteColon
MinuteHigh
MinuteLow
SecondColon
SecondHigh
SecondLow
MilliStop
MilliHigh
MilliMiddle
MilliLow
Done
Error
}
let
next_state
=
|
valid
:
bool
next
:
State
|
-
>
State
{
if
valid
{
next
}
else
{
State
:
:
Error
}
}
;
let
state
=
self
.
chars
(
)
.
fold
(
State
:
:
HourHigh
|
state
c
|
{
match
state
{
State
:
:
HourHigh
=
>
{
match
c
{
'
0
'
|
'
1
'
=
>
State
:
:
HourLow09
'
2
'
=
>
State
:
:
HourLow03
_
=
>
State
:
:
Error
}
}
State
:
:
HourLow09
=
>
next_state
(
c
.
is_digit
(
10
)
State
:
:
MinuteColon
)
State
:
:
HourLow03
=
>
next_state
(
c
.
is_digit
(
4
)
State
:
:
MinuteColon
)
State
:
:
MinuteColon
=
>
next_state
(
c
=
=
'
:
'
State
:
:
MinuteHigh
)
State
:
:
MinuteHigh
=
>
next_state
(
c
.
is_digit
(
6
)
State
:
:
MinuteLow
)
State
:
:
MinuteLow
=
>
next_state
(
c
.
is_digit
(
10
)
State
:
:
SecondColon
)
State
:
:
SecondColon
=
>
next_state
(
c
=
=
'
:
'
State
:
:
SecondHigh
)
State
:
:
SecondHigh
=
>
next_state
(
c
.
is_digit
(
6
)
State
:
:
SecondLow
)
State
:
:
SecondLow
=
>
next_state
(
c
.
is_digit
(
10
)
State
:
:
MilliStop
)
State
:
:
MilliStop
=
>
next_state
(
c
=
=
'
.
'
State
:
:
MilliHigh
)
State
:
:
MilliHigh
=
>
next_state
(
c
.
is_digit
(
6
)
State
:
:
MilliMiddle
)
State
:
:
MilliMiddle
=
>
next_state
(
c
.
is_digit
(
10
)
State
:
:
MilliLow
)
State
:
:
MilliLow
=
>
next_state
(
c
.
is_digit
(
10
)
State
:
:
Done
)
_
=
>
State
:
:
Error
}
}
)
;
match
state
{
State
:
:
Done
|
State
:
:
SecondColon
|
State
:
:
MilliStop
|
State
:
:
MilliMiddle
|
State
:
:
MilliLow
=
>
true
_
=
>
false
}
}
pub
fn
is_valid_date_string
(
&
self
)
-
>
bool
{
parse_date_string
(
&
self
.
0
)
.
is_ok
(
)
}
pub
fn
is_valid_month_string
(
&
self
)
-
>
bool
{
parse_month_string
(
&
self
.
0
)
.
is_ok
(
)
}
pub
fn
is_valid_week_string
(
&
self
)
-
>
bool
{
parse_week_string
(
&
self
.
0
)
.
is_ok
(
)
}
pub
fn
is_valid_floating_point_number_string
(
&
self
)
-
>
bool
{
if
self
.
0
.
contains
(
"
"
)
{
return
false
;
}
parse_floating_point_number
(
&
self
.
0
)
.
is_ok
(
)
}
pub
fn
set_best_representation_of_the_floating_point_number
(
&
mut
self
)
{
if
let
Ok
(
val
)
=
parse_floating_point_number
(
&
self
.
0
)
{
self
.
0
=
val
.
to_string
(
)
;
}
}
pub
fn
convert_valid_normalized_local_date_and_time_string
(
&
mut
self
)
-
>
Result
<
(
)
(
)
>
{
let
(
(
year
month
day
)
(
hour
minute
second
)
)
=
parse_local_date_and_time_string
(
&
*
self
.
0
)
?
;
if
second
=
=
0
.
0
{
self
.
0
=
format
!
(
"
{
:
04
}
-
{
:
02
}
-
{
:
02
}
T
{
:
02
}
:
{
:
02
}
"
year
month
day
hour
minute
)
;
}
else
{
self
.
0
=
format
!
(
"
{
:
04
}
-
{
:
02
}
-
{
:
02
}
T
{
:
02
}
:
{
:
02
}
:
{
}
"
year
month
day
hour
minute
second
)
;
}
Ok
(
(
)
)
}
}
impl
Borrow
<
str
>
for
DOMString
{
#
[
inline
]
fn
borrow
(
&
self
)
-
>
&
str
{
&
self
.
0
}
}
impl
Default
for
DOMString
{
fn
default
(
)
-
>
Self
{
DOMString
(
String
:
:
new
(
)
PhantomData
)
}
}
impl
Deref
for
DOMString
{
type
Target
=
str
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
str
{
&
self
.
0
}
}
impl
DerefMut
for
DOMString
{
#
[
inline
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
str
{
&
mut
self
.
0
}
}
impl
AsRef
<
str
>
for
DOMString
{
fn
as_ref
(
&
self
)
-
>
&
str
{
&
self
.
0
}
}
impl
fmt
:
:
Display
for
DOMString
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
PartialEq
<
str
>
for
DOMString
{
fn
eq
(
&
self
other
:
&
str
)
-
>
bool
{
&
*
*
self
=
=
other
}
}
impl
<
'
a
>
PartialEq
<
&
'
a
str
>
for
DOMString
{
fn
eq
(
&
self
other
:
&
&
'
a
str
)
-
>
bool
{
&
*
*
self
=
=
*
other
}
}
impl
From
<
String
>
for
DOMString
{
fn
from
(
contents
:
String
)
-
>
DOMString
{
DOMString
(
contents
PhantomData
)
}
}
impl
<
'
a
>
From
<
&
'
a
str
>
for
DOMString
{
fn
from
(
contents
:
&
str
)
-
>
DOMString
{
DOMString
:
:
from
(
String
:
:
from
(
contents
)
)
}
}
impl
<
'
a
>
From
<
Cow
<
'
a
str
>
>
for
DOMString
{
fn
from
(
contents
:
Cow
<
'
a
str
>
)
-
>
DOMString
{
match
contents
{
Cow
:
:
Owned
(
s
)
=
>
DOMString
:
:
from
(
s
)
Cow
:
:
Borrowed
(
s
)
=
>
DOMString
:
:
from
(
s
)
}
}
}
impl
From
<
DOMString
>
for
LocalName
{
fn
from
(
contents
:
DOMString
)
-
>
LocalName
{
LocalName
:
:
from
(
contents
.
0
)
}
}
impl
From
<
DOMString
>
for
Namespace
{
fn
from
(
contents
:
DOMString
)
-
>
Namespace
{
Namespace
:
:
from
(
contents
.
0
)
}
}
impl
From
<
DOMString
>
for
Atom
{
fn
from
(
contents
:
DOMString
)
-
>
Atom
{
Atom
:
:
from
(
contents
.
0
)
}
}
impl
From
<
DOMString
>
for
String
{
fn
from
(
contents
:
DOMString
)
-
>
String
{
contents
.
0
}
}
impl
Into
<
Vec
<
u8
>
>
for
DOMString
{
fn
into
(
self
)
-
>
Vec
<
u8
>
{
self
.
0
.
into
(
)
}
}
impl
<
'
a
>
Into
<
Cow
<
'
a
str
>
>
for
DOMString
{
fn
into
(
self
)
-
>
Cow
<
'
a
str
>
{
self
.
0
.
into
(
)
}
}
impl
<
'
a
>
Into
<
CowRcStr
<
'
a
>
>
for
DOMString
{
fn
into
(
self
)
-
>
CowRcStr
<
'
a
>
{
self
.
0
.
into
(
)
}
}
impl
Extend
<
char
>
for
DOMString
{
fn
extend
<
I
>
(
&
mut
self
iterable
:
I
)
where
I
:
IntoIterator
<
Item
=
char
>
{
self
.
0
.
extend
(
iterable
)
}
}
fn
parse_month_string
(
value
:
&
str
)
-
>
Result
<
(
u32
u32
)
(
)
>
{
let
(
year_int
month_int
)
=
parse_month_component
(
value
)
?
;
if
value
.
split
(
"
-
"
)
.
nth
(
2
)
.
is_some
(
)
{
return
Err
(
(
)
)
;
}
Ok
(
(
year_int
month_int
)
)
}
fn
parse_date_string
(
value
:
&
str
)
-
>
Result
<
(
u32
u32
u32
)
(
)
>
{
let
(
year_int
month_int
day_int
)
=
parse_date_component
(
value
)
?
;
if
value
.
split
(
'
-
'
)
.
nth
(
3
)
.
is_some
(
)
{
return
Err
(
(
)
)
;
}
Ok
(
(
year_int
month_int
day_int
)
)
}
fn
parse_week_string
(
value
:
&
str
)
-
>
Result
<
(
u32
u32
)
(
)
>
{
let
mut
iterator
=
value
.
split
(
'
-
'
)
;
let
year
=
iterator
.
next
(
)
.
ok_or
(
(
)
)
?
;
let
year_int
=
year
.
parse
:
:
<
u32
>
(
)
.
map_err
(
|
_
|
(
)
)
?
;
if
year
.
len
(
)
<
4
|
|
year_int
=
=
0
{
return
Err
(
(
)
)
;
}
let
week
=
iterator
.
next
(
)
.
ok_or
(
(
)
)
?
;
let
(
week_first
week_last
)
=
week
.
split_at
(
1
)
;
if
week_first
!
=
"
W
"
{
return
Err
(
(
)
)
;
}
let
week_int
=
week_last
.
parse
:
:
<
u32
>
(
)
.
map_err
(
|
_
|
(
)
)
?
;
if
week_last
.
len
(
)
!
=
2
{
return
Err
(
(
)
)
;
}
let
max_week
=
max_week_in_year
(
year_int
)
;
if
week_int
<
1
|
|
week_int
>
max_week
{
return
Err
(
(
)
)
;
}
if
iterator
.
next
(
)
.
is_some
(
)
{
return
Err
(
(
)
)
;
}
Ok
(
(
year_int
week_int
)
)
}
fn
parse_month_component
(
value
:
&
str
)
-
>
Result
<
(
u32
u32
)
(
)
>
{
let
mut
iterator
=
value
.
split
(
'
-
'
)
;
let
year
=
iterator
.
next
(
)
.
ok_or
(
(
)
)
?
;
let
month
=
iterator
.
next
(
)
.
ok_or
(
(
)
)
?
;
let
year_int
=
year
.
parse
:
:
<
u32
>
(
)
.
map_err
(
|
_
|
(
)
)
?
;
if
year
.
len
(
)
<
4
|
|
year_int
=
=
0
{
return
Err
(
(
)
)
;
}
let
month_int
=
month
.
parse
:
:
<
u32
>
(
)
.
map_err
(
|
_
|
(
)
)
?
;
if
month
.
len
(
)
!
=
2
|
|
month_int
>
12
|
|
month_int
<
1
{
return
Err
(
(
)
)
;
}
Ok
(
(
year_int
month_int
)
)
}
fn
parse_date_component
(
value
:
&
str
)
-
>
Result
<
(
u32
u32
u32
)
(
)
>
{
let
(
year_int
month_int
)
=
parse_month_component
(
value
)
?
;
let
day
=
value
.
split
(
'
-
'
)
.
nth
(
2
)
.
ok_or
(
(
)
)
?
;
let
day_int
=
day
.
parse
:
:
<
u32
>
(
)
.
map_err
(
|
_
|
(
)
)
?
;
if
day
.
len
(
)
!
=
2
{
return
Err
(
(
)
)
;
}
let
max_day
=
max_day_in_month
(
year_int
month_int
)
?
;
if
day_int
=
=
0
|
|
day_int
>
max_day
{
return
Err
(
(
)
)
;
}
Ok
(
(
year_int
month_int
day_int
)
)
}
fn
parse_time_component
(
value
:
&
str
)
-
>
Result
<
(
u32
u32
f32
)
(
)
>
{
let
mut
iterator
=
value
.
split
(
'
:
'
)
;
let
hour
=
iterator
.
next
(
)
.
ok_or
(
(
)
)
?
;
if
hour
.
len
(
)
!
=
2
{
return
Err
(
(
)
)
;
}
let
hour_int
=
hour
.
parse
:
:
<
u32
>
(
)
.
map_err
(
|
_
|
(
)
)
?
;
if
hour_int
>
23
{
return
Err
(
(
)
)
;
}
let
minute
=
iterator
.
next
(
)
.
ok_or
(
(
)
)
?
;
if
minute
.
len
(
)
!
=
2
{
return
Err
(
(
)
)
;
}
let
minute_int
=
minute
.
parse
:
:
<
u32
>
(
)
.
map_err
(
|
_
|
(
)
)
?
;
if
minute_int
>
59
{
return
Err
(
(
)
)
;
}
let
second_float
=
match
iterator
.
next
(
)
{
Some
(
second
)
=
>
{
let
mut
second_iterator
=
second
.
split
(
'
.
'
)
;
if
second_iterator
.
next
(
)
.
ok_or
(
(
)
)
?
.
len
(
)
!
=
2
{
return
Err
(
(
)
)
;
}
match
second_iterator
.
next
(
)
{
Some
(
second_last
)
=
>
{
if
second_last
.
len
(
)
>
3
{
return
Err
(
(
)
)
;
}
}
None
=
>
{
}
}
second
.
parse
:
:
<
f32
>
(
)
.
map_err
(
|
_
|
(
)
)
?
}
None
=
>
0
.
0
}
;
Ok
(
(
hour_int
minute_int
second_float
)
)
}
fn
parse_local_date_and_time_string
(
value
:
&
str
)
-
>
Result
<
(
(
u32
u32
u32
)
(
u32
u32
f32
)
)
(
)
>
{
let
mut
iterator
=
if
value
.
contains
(
'
T
'
)
{
value
.
split
(
'
T
'
)
}
else
{
value
.
split
(
'
'
)
}
;
let
date
=
iterator
.
next
(
)
.
ok_or
(
(
)
)
?
;
let
date_tuple
=
parse_date_component
(
date
)
?
;
let
time
=
iterator
.
next
(
)
.
ok_or
(
(
)
)
?
;
let
time_tuple
=
parse_time_component
(
time
)
?
;
if
iterator
.
next
(
)
.
is_some
(
)
{
return
Err
(
(
)
)
;
}
Ok
(
(
date_tuple
time_tuple
)
)
}
fn
max_day_in_month
(
year_num
:
u32
month_num
:
u32
)
-
>
Result
<
u32
(
)
>
{
match
month_num
{
1
|
3
|
5
|
7
|
8
|
10
|
12
=
>
Ok
(
31
)
4
|
6
|
9
|
11
=
>
Ok
(
30
)
2
=
>
{
if
is_leap_year
(
year_num
)
{
Ok
(
29
)
}
else
{
Ok
(
28
)
}
}
_
=
>
Err
(
(
)
)
}
}
fn
max_week_in_year
(
year
:
u32
)
-
>
u32
{
match
Utc
.
ymd
(
year
as
i32
1
1
)
.
weekday
(
)
{
Weekday
:
:
Thu
=
>
53
Weekday
:
:
Wed
if
is_leap_year
(
year
)
=
>
53
_
=
>
52
}
}
#
[
inline
]
fn
is_leap_year
(
year
:
u32
)
-
>
bool
{
year
%
400
=
=
0
|
|
(
year
%
4
=
=
0
&
&
year
%
100
!
=
0
)
}
fn
parse_floating_point_number
(
input
:
&
str
)
-
>
Result
<
f64
(
)
>
{
match
input
.
trim
(
)
.
parse
:
:
<
f64
>
(
)
{
Ok
(
val
)
if
!
(
val
.
is_infinite
(
)
|
|
val
.
is_nan
(
)
|
|
input
.
ends_with
(
"
.
"
)
|
|
input
.
starts_with
(
"
+
"
)
)
=
>
{
Ok
(
val
.
round
(
)
)
}
_
=
>
Err
(
(
)
)
}
}
