use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
ops
;
use
std
:
:
str
;
use
std
:
:
str
:
:
FromStr
;
use
util
:
:
mem
:
:
HeapSizeOf
;
use
util
:
:
str
:
:
is_token
;
#
[
derive
(
JSTraceable
Clone
Eq
PartialEq
HeapSizeOf
)
]
pub
struct
ByteString
(
Vec
<
u8
>
)
;
impl
ByteString
{
pub
fn
new
(
value
:
Vec
<
u8
>
)
-
>
ByteString
{
ByteString
(
value
)
}
pub
fn
as_str
(
&
self
)
-
>
Option
<
&
str
>
{
let
ByteString
(
ref
vec
)
=
*
self
;
str
:
:
from_utf8
(
&
vec
)
.
ok
(
)
}
pub
fn
len
(
&
self
)
-
>
usize
{
let
ByteString
(
ref
vector
)
=
*
self
;
vector
.
len
(
)
}
pub
fn
eq_ignore_case
(
&
self
other
:
&
ByteString
)
-
>
bool
{
self
.
0
.
eq_ignore_ascii_case
(
&
other
.
0
)
}
pub
fn
to_lower
(
&
self
)
-
>
ByteString
{
ByteString
:
:
new
(
self
.
0
.
to_ascii_lowercase
(
)
)
}
pub
fn
is_token
(
&
self
)
-
>
bool
{
let
ByteString
(
ref
vec
)
=
*
self
;
is_token
(
vec
)
}
pub
fn
is_field_value
(
&
self
)
-
>
bool
{
#
[
derive
(
PartialEq
)
]
enum
PreviousCharacter
{
Other
CR
LF
SPHT
}
let
ByteString
(
ref
vec
)
=
*
self
;
let
mut
prev
=
PreviousCharacter
:
:
Other
;
vec
.
iter
(
)
.
all
(
|
&
x
|
{
match
x
{
13
=
>
{
if
prev
=
=
PreviousCharacter
:
:
Other
|
|
prev
=
=
PreviousCharacter
:
:
SPHT
{
prev
=
PreviousCharacter
:
:
CR
;
true
}
else
{
false
}
}
10
=
>
{
if
prev
=
=
PreviousCharacter
:
:
CR
{
prev
=
PreviousCharacter
:
:
LF
;
true
}
else
{
false
}
}
32
=
>
{
if
prev
=
=
PreviousCharacter
:
:
LF
|
|
prev
=
=
PreviousCharacter
:
:
SPHT
{
prev
=
PreviousCharacter
:
:
SPHT
;
true
}
else
if
prev
=
=
PreviousCharacter
:
:
Other
{
true
}
else
{
false
}
}
9
=
>
{
if
prev
=
=
PreviousCharacter
:
:
LF
|
|
prev
=
=
PreviousCharacter
:
:
SPHT
{
prev
=
PreviousCharacter
:
:
SPHT
;
true
}
else
{
false
}
}
0
.
.
.
31
|
127
=
>
false
x
if
x
>
127
=
>
false
_
if
prev
=
=
PreviousCharacter
:
:
Other
|
|
prev
=
=
PreviousCharacter
:
:
SPHT
=
>
{
prev
=
PreviousCharacter
:
:
Other
;
true
}
_
=
>
false
}
}
)
}
}
impl
Hash
for
ByteString
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
let
ByteString
(
ref
vec
)
=
*
self
;
vec
.
hash
(
state
)
;
}
}
impl
FromStr
for
ByteString
{
type
Err
=
(
)
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
ByteString
(
)
>
{
Ok
(
ByteString
:
:
new
(
s
.
to_owned
(
)
.
into_bytes
(
)
)
)
}
}
impl
ops
:
:
Deref
for
ByteString
{
type
Target
=
[
u8
]
;
fn
deref
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
0
}
}
pub
struct
USVString
(
pub
String
)
;
