use
html5ever_atoms
:
:
{
LocalName
Namespace
}
;
use
servo_atoms
:
:
Atom
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
borrow
:
:
{
Borrow
Cow
ToOwned
}
;
use
std
:
:
fmt
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
ops
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
str
;
use
std
:
:
str
:
:
{
Bytes
FromStr
}
;
#
[
derive
(
JSTraceable
Clone
Eq
PartialEq
HeapSizeOf
Debug
)
]
pub
struct
ByteString
(
Vec
<
u8
>
)
;
impl
ByteString
{
pub
fn
new
(
value
:
Vec
<
u8
>
)
-
>
ByteString
{
ByteString
(
value
)
}
pub
fn
as_str
(
&
self
)
-
>
Option
<
&
str
>
{
str
:
:
from_utf8
(
&
self
.
0
)
.
ok
(
)
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
0
.
len
(
)
}
pub
fn
eq_ignore_case
(
&
self
other
:
&
ByteString
)
-
>
bool
{
self
.
0
.
eq_ignore_ascii_case
(
&
other
.
0
)
}
pub
fn
to_lower
(
&
self
)
-
>
ByteString
{
ByteString
:
:
new
(
self
.
0
.
to_ascii_lowercase
(
)
)
}
}
impl
Into
<
Vec
<
u8
>
>
for
ByteString
{
fn
into
(
self
)
-
>
Vec
<
u8
>
{
self
.
0
}
}
impl
Hash
for
ByteString
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
0
.
hash
(
state
)
;
}
}
impl
FromStr
for
ByteString
{
type
Err
=
(
)
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
ByteString
(
)
>
{
Ok
(
ByteString
:
:
new
(
s
.
to_owned
(
)
.
into_bytes
(
)
)
)
}
}
impl
ops
:
:
Deref
for
ByteString
{
type
Target
=
[
u8
]
;
fn
deref
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
0
}
}
#
[
derive
(
Clone
HeapSizeOf
)
]
pub
struct
USVString
(
pub
String
)
;
pub
fn
is_token
(
s
:
&
[
u8
]
)
-
>
bool
{
if
s
.
is_empty
(
)
{
return
false
;
}
s
.
iter
(
)
.
all
(
|
&
x
|
{
match
x
{
0
.
.
.
31
|
127
=
>
false
40
|
41
|
60
|
62
|
64
|
44
|
59
|
58
|
92
|
34
|
47
|
91
|
93
|
63
|
61
|
123
|
125
|
32
=
>
false
x
if
x
>
127
=
>
false
_
=
>
true
}
}
)
}
pub
fn
extended_filtering
(
tag
:
&
str
range
:
&
str
)
-
>
bool
{
let
lang_ranges
:
Vec
<
&
str
>
=
range
.
split
(
'
'
)
.
collect
(
)
;
lang_ranges
.
iter
(
)
.
any
(
|
&
lang_range
|
{
let
range_subtags
:
Vec
<
&
str
>
=
lang_range
.
split
(
'
\
x2d
'
)
.
collect
(
)
;
let
tag_subtags
:
Vec
<
&
str
>
=
tag
.
split
(
'
\
x2d
'
)
.
collect
(
)
;
let
mut
range_iter
=
range_subtags
.
iter
(
)
;
let
mut
tag_iter
=
tag_subtags
.
iter
(
)
;
if
let
(
Some
(
range_subtag
)
Some
(
tag_subtag
)
)
=
(
range_iter
.
next
(
)
tag_iter
.
next
(
)
)
{
if
!
(
range_subtag
.
eq_ignore_ascii_case
(
tag_subtag
)
|
|
range_subtag
.
eq_ignore_ascii_case
(
"
*
"
)
)
{
return
false
;
}
}
let
mut
current_tag_subtag
=
tag_iter
.
next
(
)
;
for
range_subtag
in
range_iter
{
if
range_subtag
.
eq_ignore_ascii_case
(
"
*
"
)
{
continue
;
}
match
current_tag_subtag
.
clone
(
)
{
Some
(
tag_subtag
)
=
>
{
if
range_subtag
.
eq_ignore_ascii_case
(
tag_subtag
)
{
current_tag_subtag
=
tag_iter
.
next
(
)
;
continue
;
}
else
{
if
tag_subtag
.
len
(
)
=
=
1
{
return
false
;
}
else
{
current_tag_subtag
=
tag_iter
.
next
(
)
;
if
current_tag_subtag
.
is_none
(
)
{
return
false
;
}
}
}
}
None
=
>
{
return
false
;
}
}
}
true
}
)
}
#
[
derive
(
Clone
Debug
Eq
Hash
HeapSizeOf
Ord
PartialEq
PartialOrd
)
]
pub
struct
DOMString
(
String
)
;
impl
!
Send
for
DOMString
{
}
impl
DOMString
{
pub
fn
new
(
)
-
>
DOMString
{
DOMString
(
String
:
:
new
(
)
)
}
pub
fn
from_string
(
s
:
String
)
-
>
DOMString
{
DOMString
(
s
)
}
pub
fn
push_str
(
&
mut
self
string
:
&
str
)
{
self
.
0
.
push_str
(
string
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
0
.
clear
(
)
}
pub
fn
truncate
(
&
mut
self
new_len
:
usize
)
{
self
.
0
.
truncate
(
new_len
)
;
}
pub
fn
bytes
(
&
self
)
-
>
Bytes
{
self
.
0
.
bytes
(
)
}
}
impl
Borrow
<
str
>
for
DOMString
{
#
[
inline
]
fn
borrow
(
&
self
)
-
>
&
str
{
&
self
.
0
}
}
impl
Default
for
DOMString
{
fn
default
(
)
-
>
Self
{
DOMString
(
String
:
:
new
(
)
)
}
}
impl
Deref
for
DOMString
{
type
Target
=
str
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
str
{
&
self
.
0
}
}
impl
DerefMut
for
DOMString
{
#
[
inline
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
str
{
&
mut
self
.
0
}
}
impl
AsRef
<
str
>
for
DOMString
{
fn
as_ref
(
&
self
)
-
>
&
str
{
&
self
.
0
}
}
impl
fmt
:
:
Display
for
DOMString
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
PartialEq
<
str
>
for
DOMString
{
fn
eq
(
&
self
other
:
&
str
)
-
>
bool
{
&
*
*
self
=
=
other
}
}
impl
<
'
a
>
PartialEq
<
&
'
a
str
>
for
DOMString
{
fn
eq
(
&
self
other
:
&
&
'
a
str
)
-
>
bool
{
&
*
*
self
=
=
*
other
}
}
impl
From
<
String
>
for
DOMString
{
fn
from
(
contents
:
String
)
-
>
DOMString
{
DOMString
(
contents
)
}
}
impl
<
'
a
>
From
<
&
'
a
str
>
for
DOMString
{
fn
from
(
contents
:
&
str
)
-
>
DOMString
{
DOMString
:
:
from
(
String
:
:
from
(
contents
)
)
}
}
impl
<
'
a
>
From
<
Cow
<
'
a
str
>
>
for
DOMString
{
fn
from
(
contents
:
Cow
<
'
a
str
>
)
-
>
DOMString
{
match
contents
{
Cow
:
:
Owned
(
s
)
=
>
DOMString
:
:
from
(
s
)
Cow
:
:
Borrowed
(
s
)
=
>
DOMString
:
:
from
(
s
)
}
}
}
impl
From
<
DOMString
>
for
LocalName
{
fn
from
(
contents
:
DOMString
)
-
>
LocalName
{
LocalName
:
:
from
(
contents
.
0
)
}
}
impl
From
<
DOMString
>
for
Namespace
{
fn
from
(
contents
:
DOMString
)
-
>
Namespace
{
Namespace
:
:
from
(
contents
.
0
)
}
}
impl
From
<
DOMString
>
for
Atom
{
fn
from
(
contents
:
DOMString
)
-
>
Atom
{
Atom
:
:
from
(
contents
.
0
)
}
}
impl
From
<
DOMString
>
for
String
{
fn
from
(
contents
:
DOMString
)
-
>
String
{
contents
.
0
}
}
impl
Into
<
Vec
<
u8
>
>
for
DOMString
{
fn
into
(
self
)
-
>
Vec
<
u8
>
{
self
.
0
.
into
(
)
}
}
impl
<
'
a
>
Into
<
Cow
<
'
a
str
>
>
for
DOMString
{
fn
into
(
self
)
-
>
Cow
<
'
a
str
>
{
self
.
0
.
into
(
)
}
}
impl
Extend
<
char
>
for
DOMString
{
fn
extend
<
I
>
(
&
mut
self
iterable
:
I
)
where
I
:
IntoIterator
<
Item
=
char
>
{
self
.
0
.
extend
(
iterable
)
}
}
