use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
hash
:
:
{
Hash
SipHasher
}
;
use
std
:
:
str
;
use
std
:
:
str
:
:
FromStr
;
#
[
derive
(
Clone
Eq
PartialEq
)
]
#
[
jstraceable
]
pub
struct
ByteString
(
Vec
<
u8
>
)
;
impl
ByteString
{
pub
fn
new
(
value
:
Vec
<
u8
>
)
-
>
ByteString
{
ByteString
(
value
)
}
pub
fn
as_str
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
&
'
a
str
>
{
let
ByteString
(
ref
vec
)
=
*
self
;
str
:
:
from_utf8
(
vec
.
as_slice
(
)
)
.
ok
(
)
}
pub
fn
as_slice
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
[
u8
]
{
let
ByteString
(
ref
vector
)
=
*
self
;
vector
.
as_slice
(
)
}
pub
fn
len
(
&
self
)
-
>
uint
{
let
ByteString
(
ref
vector
)
=
*
self
;
vector
.
len
(
)
}
pub
fn
eq_ignore_case
(
&
self
other
:
&
ByteString
)
-
>
bool
{
self
.
to_lower
(
)
=
=
other
.
to_lower
(
)
}
pub
fn
to_lower
(
&
self
)
-
>
ByteString
{
let
ByteString
(
ref
vec
)
=
*
self
;
ByteString
:
:
new
(
vec
.
iter
(
)
.
map
(
|
&
x
|
{
if
x
>
'
A
'
as
u8
&
&
x
<
'
Z
'
as
u8
{
x
+
(
'
a
'
as
u8
)
-
(
'
A
'
as
u8
)
}
else
{
x
}
}
)
.
collect
(
)
)
}
pub
fn
is_token
(
&
self
)
-
>
bool
{
let
ByteString
(
ref
vec
)
=
*
self
;
if
vec
.
len
(
)
=
=
0
{
return
false
;
}
vec
.
iter
(
)
.
all
(
|
&
x
|
{
match
x
{
0
.
.
.
31
|
127
=
>
false
40
|
41
|
60
|
62
|
64
|
44
|
59
|
58
|
92
|
34
|
47
|
91
|
93
|
63
|
61
|
123
|
125
|
32
=
>
false
x
if
x
>
127
=
>
false
_
=
>
true
}
}
)
}
pub
fn
is_field_value
(
&
self
)
-
>
bool
{
#
[
derive
(
PartialEq
)
]
enum
PreviousCharacter
{
Other
CR
LF
SPHT
}
let
ByteString
(
ref
vec
)
=
*
self
;
let
mut
prev
=
PreviousCharacter
:
:
Other
;
vec
.
iter
(
)
.
all
(
|
&
x
|
{
match
x
{
13
=
>
{
if
prev
=
=
PreviousCharacter
:
:
Other
|
|
prev
=
=
PreviousCharacter
:
:
SPHT
{
prev
=
PreviousCharacter
:
:
CR
;
true
}
else
{
false
}
}
10
=
>
{
if
prev
=
=
PreviousCharacter
:
:
CR
{
prev
=
PreviousCharacter
:
:
LF
;
true
}
else
{
false
}
}
32
=
>
{
if
prev
=
=
PreviousCharacter
:
:
LF
|
|
prev
=
=
PreviousCharacter
:
:
SPHT
{
prev
=
PreviousCharacter
:
:
SPHT
;
true
}
else
if
prev
=
=
PreviousCharacter
:
:
Other
{
true
}
else
{
false
}
}
9
=
>
{
if
prev
=
=
PreviousCharacter
:
:
LF
|
|
prev
=
=
PreviousCharacter
:
:
SPHT
{
prev
=
PreviousCharacter
:
:
SPHT
;
true
}
else
{
false
}
}
0
.
.
.
31
|
127
=
>
false
x
if
x
>
127
=
>
false
_
if
prev
=
=
PreviousCharacter
:
:
Other
|
|
prev
=
=
PreviousCharacter
:
:
SPHT
=
>
{
prev
=
PreviousCharacter
:
:
Other
;
true
}
_
=
>
false
}
}
)
}
}
impl
Hash
<
SipHasher
>
for
ByteString
{
fn
hash
(
&
self
state
:
&
mut
SipHasher
)
{
let
ByteString
(
ref
vec
)
=
*
self
;
vec
.
hash
(
state
)
;
}
}
impl
FromStr
for
ByteString
{
fn
from_str
(
s
:
&
str
)
-
>
Option
<
ByteString
>
{
Some
(
ByteString
:
:
new
(
s
.
to_owned
(
)
.
into_bytes
(
)
)
)
}
}
