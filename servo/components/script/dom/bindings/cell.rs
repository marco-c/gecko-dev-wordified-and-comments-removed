use
dom
:
:
bindings
:
:
trace
:
:
JSTraceable
;
use
js
:
:
jsapi
:
:
{
JSTracer
}
;
use
std
:
:
cell
:
:
{
BorrowState
Ref
RefCell
RefMut
}
;
use
util
:
:
task_state
;
use
util
:
:
task_state
:
:
SCRIPT
;
#
[
derive
(
Clone
HeapSizeOf
)
]
pub
struct
DOMRefCell
<
T
>
{
value
:
RefCell
<
T
>
}
impl
<
T
>
DOMRefCell
<
T
>
{
#
[
allow
(
unsafe_code
)
]
pub
unsafe
fn
borrow_for_layout
(
&
self
)
-
>
&
T
{
debug_assert
!
(
task_state
:
:
get
(
)
.
is_layout
(
)
)
;
&
*
self
.
value
.
as_unsafe_cell
(
)
.
get
(
)
}
#
[
allow
(
unsafe_code
)
]
pub
unsafe
fn
borrow_for_gc_trace
(
&
self
)
-
>
&
T
{
&
*
self
.
value
.
as_unsafe_cell
(
)
.
get
(
)
}
#
[
allow
(
unsafe_code
)
]
pub
unsafe
fn
borrow_for_script_deallocation
(
&
self
)
-
>
&
mut
T
{
debug_assert
!
(
task_state
:
:
get
(
)
.
contains
(
SCRIPT
)
)
;
&
mut
*
self
.
value
.
as_unsafe_cell
(
)
.
get
(
)
}
pub
fn
is_mutably_borrowed
(
&
self
)
-
>
bool
{
self
.
value
.
borrow_state
(
)
=
=
BorrowState
:
:
Writing
}
pub
fn
try_borrow
(
&
self
)
-
>
Option
<
Ref
<
T
>
>
{
debug_assert
!
(
task_state
:
:
get
(
)
.
is_script
(
)
)
;
match
self
.
value
.
borrow_state
(
)
{
BorrowState
:
:
Writing
=
>
None
_
=
>
Some
(
self
.
value
.
borrow
(
)
)
}
}
pub
fn
try_borrow_mut
(
&
self
)
-
>
Option
<
RefMut
<
T
>
>
{
debug_assert
!
(
task_state
:
:
get
(
)
.
is_script
(
)
)
;
match
self
.
value
.
borrow_state
(
)
{
BorrowState
:
:
Unused
=
>
Some
(
self
.
value
.
borrow_mut
(
)
)
_
=
>
None
}
}
}
impl
<
T
:
JSTraceable
>
JSTraceable
for
DOMRefCell
<
T
>
{
fn
trace
(
&
self
trc
:
*
mut
JSTracer
)
{
unsafe
{
(
*
self
)
.
borrow_for_gc_trace
(
)
.
trace
(
trc
)
}
}
}
impl
<
T
>
DOMRefCell
<
T
>
{
pub
fn
new
(
value
:
T
)
-
>
DOMRefCell
<
T
>
{
DOMRefCell
{
value
:
RefCell
:
:
new
(
value
)
}
}
pub
fn
borrow
(
&
self
)
-
>
Ref
<
T
>
{
self
.
try_borrow
(
)
.
expect
(
"
DOMRefCell
<
T
>
already
mutably
borrowed
"
)
}
pub
fn
borrow_mut
(
&
self
)
-
>
RefMut
<
T
>
{
self
.
try_borrow_mut
(
)
.
expect
(
"
DOMRefCell
<
T
>
already
borrowed
"
)
}
}
