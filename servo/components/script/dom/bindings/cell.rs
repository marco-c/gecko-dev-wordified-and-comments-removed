use
dom
:
:
bindings
:
:
trace
:
:
JSTraceable
;
use
js
:
:
jsapi
:
:
{
JSTracer
}
;
use
std
:
:
cell
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
mem
;
pub
struct
DOMRefCell
<
T
>
{
base
:
RefCell
<
T
>
}
pub
type
Ref
<
'
a
T
>
=
cell
:
:
Ref
<
'
a
T
>
;
pub
type
RefMut
<
'
a
T
>
=
cell
:
:
RefMut
<
'
a
T
>
;
impl
<
T
>
DOMRefCell
<
T
>
{
#
[
inline
(
always
)
]
pub
fn
new
(
value
:
T
)
-
>
DOMRefCell
<
T
>
{
DOMRefCell
{
base
:
RefCell
:
:
new
(
value
)
}
}
#
[
inline
(
always
)
]
pub
fn
unwrap
(
self
)
-
>
T
{
self
.
base
.
unwrap
(
)
}
#
[
inline
(
always
)
]
pub
fn
try_borrow
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
Ref
<
'
a
T
>
>
{
self
.
base
.
try_borrow
(
)
}
#
[
inline
(
always
)
]
pub
fn
borrow
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
T
>
{
self
.
base
.
borrow
(
)
}
#
[
inline
(
always
)
]
pub
fn
try_borrow_mut
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
RefMut
<
'
a
T
>
>
{
self
.
base
.
try_borrow_mut
(
)
}
#
[
inline
(
always
)
]
pub
fn
borrow_mut
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
T
>
{
self
.
base
.
borrow_mut
(
)
}
pub
unsafe
fn
borrow_for_layout
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
T
{
let
val
=
mem
:
:
transmute
:
:
<
&
RefCell
<
T
>
&
T
>
(
&
self
.
base
)
;
val
}
}
impl
<
T
:
JSTraceable
>
JSTraceable
for
DOMRefCell
<
T
>
{
fn
trace
(
&
self
trc
:
*
mut
JSTracer
)
{
(
*
self
)
.
base
.
borrow
(
)
.
trace
(
trc
)
}
}
