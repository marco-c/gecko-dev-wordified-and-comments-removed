use
dom
:
:
bindings
:
:
error
:
:
{
Error
Fallible
report_pending_exception
}
;
use
dom
:
:
bindings
:
:
js
:
:
{
JS
Root
MutHeapJSVal
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
DomObject
;
use
dom
:
:
bindings
:
:
settings_stack
:
:
{
AutoEntryScript
AutoIncumbentScript
}
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
js
:
:
jsapi
:
:
{
Heap
MutableHandleObject
}
;
use
js
:
:
jsapi
:
:
{
IsCallable
JSContext
JSObject
JS_WrapObject
AddRawValueRoot
}
;
use
js
:
:
jsapi
:
:
{
JSCompartment
JS_EnterCompartment
JS_LeaveCompartment
RemoveRawValueRoot
}
;
use
js
:
:
jsapi
:
:
JSAutoCompartment
;
use
js
:
:
jsapi
:
:
JS_GetProperty
;
use
js
:
:
jsval
:
:
{
JSVal
UndefinedValue
ObjectValue
}
;
use
js
:
:
rust
:
:
Runtime
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
mem
:
:
drop
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
ptr
;
use
std
:
:
rc
:
:
Rc
;
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
ExceptionHandling
{
Report
Rethrow
}
#
[
derive
(
JSTraceable
)
]
#
[
must_root
]
pub
struct
CallbackObject
{
callback
:
Heap
<
*
mut
JSObject
>
permanent_js_root
:
MutHeapJSVal
incumbent
:
Option
<
JS
<
GlobalScope
>
>
}
impl
Default
for
CallbackObject
{
#
[
allow
(
unrooted_must_root
)
]
fn
default
(
)
-
>
CallbackObject
{
CallbackObject
:
:
new
(
)
}
}
impl
CallbackObject
{
#
[
allow
(
unrooted_must_root
)
]
fn
new
(
)
-
>
CallbackObject
{
CallbackObject
{
callback
:
Heap
:
:
default
(
)
permanent_js_root
:
MutHeapJSVal
:
:
new
(
)
incumbent
:
GlobalScope
:
:
incumbent
(
)
.
map
(
|
i
|
JS
:
:
from_ref
(
&
*
i
)
)
}
}
pub
fn
get
(
&
self
)
-
>
*
mut
JSObject
{
self
.
callback
.
get
(
)
}
#
[
allow
(
unsafe_code
)
]
unsafe
fn
init
(
&
mut
self
cx
:
*
mut
JSContext
callback
:
*
mut
JSObject
)
{
self
.
callback
.
set
(
callback
)
;
self
.
permanent_js_root
.
set
(
ObjectValue
(
callback
)
)
;
assert
!
(
AddRawValueRoot
(
cx
self
.
permanent_js_root
.
get_unsafe
(
)
b
"
CallbackObject
:
:
root
\
n
"
as
*
const
_
as
*
const
_
)
)
;
}
}
impl
Drop
for
CallbackObject
{
#
[
allow
(
unsafe_code
)
]
fn
drop
(
&
mut
self
)
{
unsafe
{
let
cx
=
Runtime
:
:
get
(
)
;
RemoveRawValueRoot
(
cx
self
.
permanent_js_root
.
get_unsafe
(
)
)
;
}
}
}
impl
PartialEq
for
CallbackObject
{
fn
eq
(
&
self
other
:
&
CallbackObject
)
-
>
bool
{
self
.
callback
.
get
(
)
=
=
other
.
callback
.
get
(
)
}
}
pub
trait
CallbackContainer
{
unsafe
fn
new
(
cx
:
*
mut
JSContext
callback
:
*
mut
JSObject
)
-
>
Rc
<
Self
>
;
fn
callback_holder
(
&
self
)
-
>
&
CallbackObject
;
fn
callback
(
&
self
)
-
>
*
mut
JSObject
{
self
.
callback_holder
(
)
.
get
(
)
}
fn
incumbent
(
&
self
)
-
>
Option
<
&
GlobalScope
>
{
self
.
callback_holder
(
)
.
incumbent
.
as_ref
(
)
.
map
(
JS
:
:
deref
)
}
}
#
[
derive
(
JSTraceable
PartialEq
)
]
#
[
must_root
]
pub
struct
CallbackFunction
{
object
:
CallbackObject
}
impl
CallbackFunction
{
#
[
allow
(
unrooted_must_root
)
]
pub
fn
new
(
)
-
>
CallbackFunction
{
CallbackFunction
{
object
:
CallbackObject
:
:
new
(
)
}
}
pub
fn
callback_holder
(
&
self
)
-
>
&
CallbackObject
{
&
self
.
object
}
pub
unsafe
fn
init
(
&
mut
self
cx
:
*
mut
JSContext
callback
:
*
mut
JSObject
)
{
self
.
object
.
init
(
cx
callback
)
;
}
}
#
[
derive
(
JSTraceable
PartialEq
)
]
#
[
must_root
]
pub
struct
CallbackInterface
{
object
:
CallbackObject
}
impl
CallbackInterface
{
pub
fn
new
(
)
-
>
CallbackInterface
{
CallbackInterface
{
object
:
CallbackObject
:
:
new
(
)
}
}
pub
fn
callback_holder
(
&
self
)
-
>
&
CallbackObject
{
&
self
.
object
}
pub
unsafe
fn
init
(
&
mut
self
cx
:
*
mut
JSContext
callback
:
*
mut
JSObject
)
{
self
.
object
.
init
(
cx
callback
)
;
}
pub
fn
get_callable_property
(
&
self
cx
:
*
mut
JSContext
name
:
&
str
)
-
>
Fallible
<
JSVal
>
{
rooted
!
(
in
(
cx
)
let
mut
callable
=
UndefinedValue
(
)
)
;
rooted
!
(
in
(
cx
)
let
obj
=
self
.
callback_holder
(
)
.
get
(
)
)
;
unsafe
{
let
c_name
=
CString
:
:
new
(
name
)
.
unwrap
(
)
;
if
!
JS_GetProperty
(
cx
obj
.
handle
(
)
c_name
.
as_ptr
(
)
callable
.
handle_mut
(
)
)
{
return
Err
(
Error
:
:
JSFailed
)
;
}
if
!
callable
.
is_object
(
)
|
|
!
IsCallable
(
callable
.
to_object
(
)
)
{
return
Err
(
Error
:
:
Type
(
format
!
(
"
The
value
of
the
{
}
property
is
not
callable
"
name
)
)
)
;
}
}
Ok
(
callable
.
get
(
)
)
}
}
pub
fn
wrap_call_this_object
<
T
:
DomObject
>
(
cx
:
*
mut
JSContext
p
:
&
T
rval
:
MutableHandleObject
)
{
rval
.
set
(
p
.
reflector
(
)
.
get_jsobject
(
)
.
get
(
)
)
;
assert
!
(
!
rval
.
get
(
)
.
is_null
(
)
)
;
unsafe
{
if
!
JS_WrapObject
(
cx
rval
)
{
rval
.
set
(
ptr
:
:
null_mut
(
)
)
;
}
}
}
pub
struct
CallSetup
{
exception_global
:
Root
<
GlobalScope
>
cx
:
*
mut
JSContext
old_compartment
:
*
mut
JSCompartment
handling
:
ExceptionHandling
entry_script
:
Option
<
AutoEntryScript
>
incumbent_script
:
Option
<
AutoIncumbentScript
>
}
impl
CallSetup
{
#
[
allow
(
unrooted_must_root
)
]
pub
fn
new
<
T
:
CallbackContainer
>
(
callback
:
&
T
handling
:
ExceptionHandling
)
-
>
CallSetup
{
let
global
=
unsafe
{
GlobalScope
:
:
from_object
(
callback
.
callback
(
)
)
}
;
let
cx
=
global
.
get_cx
(
)
;
let
aes
=
AutoEntryScript
:
:
new
(
&
global
)
;
let
ais
=
callback
.
incumbent
(
)
.
map
(
AutoIncumbentScript
:
:
new
)
;
CallSetup
{
exception_global
:
global
cx
:
cx
old_compartment
:
unsafe
{
JS_EnterCompartment
(
cx
callback
.
callback
(
)
)
}
handling
:
handling
entry_script
:
Some
(
aes
)
incumbent_script
:
ais
}
}
pub
fn
get_context
(
&
self
)
-
>
*
mut
JSContext
{
self
.
cx
}
}
impl
Drop
for
CallSetup
{
fn
drop
(
&
mut
self
)
{
unsafe
{
JS_LeaveCompartment
(
self
.
cx
self
.
old_compartment
)
;
if
self
.
handling
=
=
ExceptionHandling
:
:
Report
{
let
_ac
=
JSAutoCompartment
:
:
new
(
self
.
cx
self
.
exception_global
.
reflector
(
)
.
get_jsobject
(
)
.
get
(
)
)
;
report_pending_exception
(
self
.
cx
true
)
;
}
drop
(
self
.
incumbent_script
.
take
(
)
)
;
drop
(
self
.
entry_script
.
take
(
)
.
unwrap
(
)
)
;
}
}
}
