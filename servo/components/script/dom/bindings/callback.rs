use
dom
:
:
bindings
:
:
error
:
:
{
Fallible
Error
}
;
use
dom
:
:
bindings
:
:
global
:
:
global_object_for_js_object
;
use
dom
:
:
bindings
:
:
js
:
:
JSRef
;
use
dom
:
:
bindings
:
:
utils
:
:
Reflectable
;
use
js
:
:
jsapi
:
:
{
JSContext
JSObject
JS_WrapObject
JS_ObjectIsCallable
JS_GetGlobalObject
}
;
use
js
:
:
jsapi
:
:
{
JS_GetProperty
JS_IsExceptionPending
JS_ReportPendingException
}
;
use
js
:
:
jsval
:
:
{
JSVal
UndefinedValue
}
;
use
js
:
:
rust
:
:
with_compartment
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
ptr
;
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
ExceptionHandling
{
Report
Rethrow
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
#
[
jstraceable
]
pub
struct
CallbackFunction
{
object
:
CallbackObject
}
impl
CallbackFunction
{
pub
fn
new
(
callback
:
*
mut
JSObject
)
-
>
CallbackFunction
{
CallbackFunction
{
object
:
CallbackObject
{
callback
:
callback
}
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
#
[
jstraceable
]
pub
struct
CallbackInterface
{
object
:
CallbackObject
}
#
[
allow
(
raw_pointer_derive
)
]
#
[
derive
(
Copy
Clone
PartialEq
)
]
#
[
jstraceable
]
struct
CallbackObject
{
callback
:
*
mut
JSObject
}
pub
trait
CallbackContainer
{
fn
new
(
callback
:
*
mut
JSObject
)
-
>
Self
;
fn
callback
(
&
self
)
-
>
*
mut
JSObject
;
}
impl
CallbackInterface
{
pub
fn
callback
(
&
self
)
-
>
*
mut
JSObject
{
self
.
object
.
callback
}
}
impl
CallbackFunction
{
pub
fn
callback
(
&
self
)
-
>
*
mut
JSObject
{
self
.
object
.
callback
}
}
impl
CallbackInterface
{
pub
fn
new
(
callback
:
*
mut
JSObject
)
-
>
CallbackInterface
{
CallbackInterface
{
object
:
CallbackObject
{
callback
:
callback
}
}
}
pub
fn
get_callable_property
(
&
self
cx
:
*
mut
JSContext
name
:
&
str
)
-
>
Fallible
<
JSVal
>
{
let
mut
callable
=
UndefinedValue
(
)
;
unsafe
{
let
c_name
=
CString
:
:
new
(
name
)
.
unwrap
(
)
;
if
JS_GetProperty
(
cx
self
.
callback
(
)
c_name
.
as_ptr
(
)
&
mut
callable
)
=
=
0
{
return
Err
(
Error
:
:
JSFailed
)
;
}
if
!
callable
.
is_object
(
)
|
|
JS_ObjectIsCallable
(
cx
callable
.
to_object
(
)
)
=
=
0
{
return
Err
(
Error
:
:
Type
(
format
!
(
"
The
value
of
the
{
}
property
is
not
callable
"
name
)
)
)
;
}
}
Ok
(
callable
)
}
}
pub
fn
wrap_call_this_object
<
T
:
Reflectable
>
(
cx
:
*
mut
JSContext
p
:
JSRef
<
T
>
)
-
>
*
mut
JSObject
{
let
mut
obj
=
p
.
reflector
(
)
.
get_jsobject
(
)
;
assert
!
(
!
obj
.
is_null
(
)
)
;
unsafe
{
if
JS_WrapObject
(
cx
&
mut
obj
)
=
=
0
{
return
ptr
:
:
null_mut
(
)
;
}
}
return
obj
;
}
pub
struct
CallSetup
{
cx
:
*
mut
JSContext
_handling
:
ExceptionHandling
}
impl
CallSetup
{
#
[
allow
(
unrooted_must_root
)
]
pub
fn
new
<
T
:
CallbackContainer
>
(
callback
:
T
handling
:
ExceptionHandling
)
-
>
CallSetup
{
let
global
=
global_object_for_js_object
(
callback
.
callback
(
)
)
;
let
global
=
global
.
root
(
)
;
let
cx
=
global
.
r
(
)
.
get_cx
(
)
;
CallSetup
{
cx
:
cx
_handling
:
handling
}
}
pub
fn
get_context
(
&
self
)
-
>
*
mut
JSContext
{
self
.
cx
}
}
impl
Drop
for
CallSetup
{
fn
drop
(
&
mut
self
)
{
let
need_to_deal_with_exception
=
unsafe
{
JS_IsExceptionPending
(
self
.
cx
)
}
!
=
0
;
if
need_to_deal_with_exception
{
unsafe
{
let
old_global
=
JS_GetGlobalObject
(
self
.
cx
)
;
with_compartment
(
self
.
cx
old_global
|
|
{
JS_ReportPendingException
(
self
.
cx
)
}
)
;
}
}
}
}
