use
dom
:
:
bindings
:
:
codegen
:
:
PrototypeList
;
use
dom
:
:
bindings
:
:
conversions
:
:
get_dom_class
;
use
dom
:
:
bindings
:
:
utils
:
:
get_proto_or_iface_array
;
use
js
:
:
glue
:
:
UncheckedUnwrapObject
;
use
js
:
:
jsapi
:
:
{
Class
ClassExtension
ClassSpec
GetGlobalForObjectCrossCompartment
}
;
use
js
:
:
jsapi
:
:
{
HandleObject
HandleValue
JSClass
JSContext
JSFunctionSpec
}
;
use
js
:
:
jsapi
:
:
{
JSPropertySpec
JSString
JS_DefineProperty1
JS_DefineProperty2
}
;
use
js
:
:
jsapi
:
:
{
JS_DefineProperty4
JS_GetClass
JS_GetFunctionObject
JS_GetPrototype
}
;
use
js
:
:
jsapi
:
:
{
JS_InternString
JS_LinkConstructorAndPrototype
JS_NewFunction
JS_NewObject
}
;
use
js
:
:
jsapi
:
:
{
JS_NewObjectWithUniqueType
JS_DefineProperty
MutableHandleObject
}
;
use
js
:
:
jsapi
:
:
{
MutableHandleValue
ObjectOps
RootedObject
RootedString
RootedValue
Value
}
;
use
js
:
:
jsval
:
:
{
BooleanValue
DoubleValue
Int32Value
JSVal
NullValue
UInt32Value
}
;
use
js
:
:
rust
:
:
{
define_methods
define_properties
}
;
use
js
:
:
{
JSPROP_ENUMERATE
JSFUN_CONSTRUCTOR
JSPROP_PERMANENT
JSPROP_READONLY
}
;
use
libc
;
use
std
:
:
ptr
;
#
[
derive
(
Clone
)
]
pub
enum
ConstantVal
{
IntVal
(
i32
)
UintVal
(
u32
)
DoubleVal
(
f64
)
BoolVal
(
bool
)
NullVal
}
#
[
derive
(
Clone
)
]
pub
struct
ConstantSpec
{
pub
name
:
&
'
static
[
u8
]
pub
value
:
ConstantVal
}
impl
ConstantSpec
{
pub
fn
get_value
(
&
self
)
-
>
JSVal
{
match
self
.
value
{
ConstantVal
:
:
NullVal
=
>
NullValue
(
)
ConstantVal
:
:
IntVal
(
i
)
=
>
Int32Value
(
i
)
ConstantVal
:
:
UintVal
(
u
)
=
>
UInt32Value
(
u
)
ConstantVal
:
:
DoubleVal
(
d
)
=
>
DoubleValue
(
d
)
ConstantVal
:
:
BoolVal
(
b
)
=
>
BooleanValue
(
b
)
}
}
}
pub
type
NonNullJSNative
=
unsafe
extern
"
C
"
fn
(
arg1
:
*
mut
JSContext
arg2
:
libc
:
:
c_uint
arg3
:
*
mut
JSVal
)
-
>
bool
;
pub
fn
define_constants
(
cx
:
*
mut
JSContext
obj
:
HandleObject
constants
:
&
'
static
[
ConstantSpec
]
)
{
for
spec
in
constants
{
let
value
=
RootedValue
:
:
new
(
cx
spec
.
get_value
(
)
)
;
unsafe
{
assert
!
(
JS_DefineProperty
(
cx
obj
spec
.
name
.
as_ptr
(
)
as
*
const
libc
:
:
c_char
value
.
handle
(
)
JSPROP_ENUMERATE
|
JSPROP_READONLY
|
JSPROP_PERMANENT
None
None
)
)
;
}
}
}
pub
type
ConstructorClassHook
=
unsafe
extern
"
C
"
fn
(
cx
:
*
mut
JSContext
argc
:
u32
vp
:
*
mut
Value
)
-
>
bool
;
pub
type
FunToStringHook
=
unsafe
extern
"
C
"
fn
(
cx
:
*
mut
JSContext
obj
:
HandleObject
indent
:
u32
)
-
>
*
mut
JSString
;
#
[
derive
(
Copy
Clone
)
]
pub
struct
NonCallbackInterfaceObjectClass
{
pub
class
:
Class
pub
proto_id
:
PrototypeList
:
:
ID
pub
proto_depth
:
u16
}
unsafe
impl
Sync
for
NonCallbackInterfaceObjectClass
{
}
impl
NonCallbackInterfaceObjectClass
{
pub
const
fn
new
(
constructor
:
ConstructorClassHook
fun_to_string
:
FunToStringHook
proto_id
:
PrototypeList
:
:
ID
proto_depth
:
u16
)
-
>
NonCallbackInterfaceObjectClass
{
NonCallbackInterfaceObjectClass
{
class
:
Class
{
name
:
b
"
Function
\
0
"
as
*
const
_
as
*
const
libc
:
:
c_char
flags
:
0
addProperty
:
None
delProperty
:
None
getProperty
:
None
setProperty
:
None
enumerate
:
None
resolve
:
None
convert
:
None
finalize
:
None
call
:
Some
(
constructor
)
construct
:
Some
(
constructor
)
hasInstance
:
Some
(
has_instance_hook
)
trace
:
None
spec
:
ClassSpec
{
createConstructor
:
None
createPrototype
:
None
constructorFunctions
:
ptr
:
:
null
(
)
constructorProperties
:
ptr
:
:
null
(
)
prototypeFunctions
:
ptr
:
:
null
(
)
prototypeProperties
:
ptr
:
:
null
(
)
finishInit
:
None
flags
:
0
}
ext
:
ClassExtension
{
outerObject
:
None
innerObject
:
None
isWrappedNative
:
false
weakmapKeyDelegateOp
:
None
objectMovedOp
:
None
}
ops
:
ObjectOps
{
lookupProperty
:
None
defineProperty
:
None
hasProperty
:
None
getProperty
:
None
setProperty
:
None
getOwnPropertyDescriptor
:
None
deleteProperty
:
None
watch
:
None
unwatch
:
None
getElements
:
None
enumerate
:
None
thisObject
:
None
funToString
:
Some
(
fun_to_string
)
}
}
proto_id
:
proto_id
proto_depth
:
proto_depth
}
}
pub
fn
as_jsclass
(
&
self
)
-
>
&
JSClass
{
unsafe
{
&
*
(
self
as
*
const
_
as
*
const
JSClass
)
}
}
}
pub
unsafe
fn
create_callback_interface_object
(
cx
:
*
mut
JSContext
receiver
:
HandleObject
constants
:
&
'
static
[
ConstantSpec
]
name
:
&
'
static
[
u8
]
)
{
assert
!
(
!
constants
.
is_empty
(
)
)
;
let
interface_object
=
RootedObject
:
:
new
(
cx
JS_NewObject
(
cx
ptr
:
:
null
(
)
)
)
;
assert
!
(
!
interface_object
.
ptr
.
is_null
(
)
)
;
define_constants
(
cx
interface_object
.
handle
(
)
constants
)
;
define_name
(
cx
interface_object
.
handle
(
)
name
)
;
define_on_global_object
(
cx
receiver
name
interface_object
.
handle
(
)
)
;
}
pub
unsafe
fn
create_interface_prototype_object
(
cx
:
*
mut
JSContext
proto
:
HandleObject
class
:
&
'
static
JSClass
regular_methods
:
Option
<
&
'
static
[
JSFunctionSpec
]
>
regular_properties
:
Option
<
&
'
static
[
JSPropertySpec
]
>
constants
:
&
'
static
[
ConstantSpec
]
rval
:
MutableHandleObject
)
{
create_object
(
cx
proto
class
regular_methods
regular_properties
constants
rval
)
;
}
pub
unsafe
fn
create_noncallback_interface_object
(
cx
:
*
mut
JSContext
receiver
:
HandleObject
proto
:
HandleObject
class
:
&
'
static
NonCallbackInterfaceObjectClass
static_methods
:
Option
<
&
'
static
[
JSFunctionSpec
]
>
static_properties
:
Option
<
&
'
static
[
JSPropertySpec
]
>
constants
:
&
'
static
[
ConstantSpec
]
interface_prototype_object
:
HandleObject
name
:
&
'
static
[
u8
]
length
:
u32
rval
:
MutableHandleObject
)
{
create_object
(
cx
proto
class
.
as_jsclass
(
)
static_methods
static_properties
constants
rval
)
;
assert
!
(
JS_LinkConstructorAndPrototype
(
cx
rval
.
handle
(
)
interface_prototype_object
)
)
;
define_name
(
cx
rval
.
handle
(
)
name
)
;
define_length
(
cx
rval
.
handle
(
)
length
)
;
define_on_global_object
(
cx
receiver
name
rval
.
handle
(
)
)
;
}
pub
unsafe
fn
create_named_constructors
(
cx
:
*
mut
JSContext
receiver
:
HandleObject
named_constructors
:
&
[
(
NonNullJSNative
&
'
static
[
u8
]
u32
)
]
interface_prototype_object
:
HandleObject
)
{
let
mut
constructor
=
RootedObject
:
:
new
(
cx
ptr
:
:
null_mut
(
)
)
;
for
&
(
native
name
arity
)
in
named_constructors
{
assert
!
(
*
name
.
last
(
)
.
unwrap
(
)
=
=
b
'
\
0
'
)
;
let
fun
=
JS_NewFunction
(
cx
Some
(
native
)
arity
JSFUN_CONSTRUCTOR
name
.
as_ptr
(
)
as
*
const
libc
:
:
c_char
)
;
assert
!
(
!
fun
.
is_null
(
)
)
;
constructor
.
ptr
=
JS_GetFunctionObject
(
fun
)
;
assert
!
(
!
constructor
.
ptr
.
is_null
(
)
)
;
assert
!
(
JS_DefineProperty1
(
cx
constructor
.
handle
(
)
b
"
prototype
\
0
"
.
as_ptr
(
)
as
*
const
libc
:
:
c_char
interface_prototype_object
JSPROP_PERMANENT
|
JSPROP_READONLY
None
None
)
)
;
define_on_global_object
(
cx
receiver
name
constructor
.
handle
(
)
)
;
}
}
unsafe
extern
"
C
"
fn
has_instance_hook
(
cx
:
*
mut
JSContext
obj
:
HandleObject
value
:
MutableHandleValue
rval
:
*
mut
bool
)
-
>
bool
{
match
has_instance
(
cx
obj
value
.
handle
(
)
)
{
Ok
(
result
)
=
>
{
*
rval
=
result
;
true
}
Err
(
(
)
)
=
>
false
}
}
unsafe
fn
has_instance
(
cx
:
*
mut
JSContext
interface_object
:
HandleObject
value
:
HandleValue
)
-
>
Result
<
bool
(
)
>
{
if
!
value
.
is_object
(
)
{
return
Ok
(
false
)
;
}
let
mut
value
=
RootedObject
:
:
new
(
cx
value
.
to_object
(
)
)
;
let
js_class
=
JS_GetClass
(
interface_object
.
get
(
)
)
;
let
object_class
=
&
*
(
js_class
as
*
const
NonCallbackInterfaceObjectClass
)
;
if
let
Ok
(
dom_class
)
=
get_dom_class
(
UncheckedUnwrapObject
(
value
.
ptr
0
)
)
{
if
dom_class
.
interface_chain
[
object_class
.
proto_depth
as
usize
]
=
=
object_class
.
proto_id
{
return
Ok
(
true
)
;
}
}
let
global
=
GetGlobalForObjectCrossCompartment
(
interface_object
.
get
(
)
)
;
assert
!
(
!
global
.
is_null
(
)
)
;
let
proto_or_iface_array
=
get_proto_or_iface_array
(
global
)
;
let
prototype
=
RootedObject
:
:
new
(
cx
(
*
proto_or_iface_array
)
[
object_class
.
proto_id
as
usize
]
)
;
assert
!
(
!
prototype
.
ptr
.
is_null
(
)
)
;
while
JS_GetPrototype
(
cx
value
.
handle
(
)
value
.
handle_mut
(
)
)
{
if
value
.
ptr
.
is_null
(
)
{
return
Ok
(
false
)
;
}
else
if
value
.
ptr
as
*
const
_
=
=
prototype
.
ptr
{
return
Ok
(
true
)
;
}
}
Err
(
(
)
)
}
unsafe
fn
create_object
(
cx
:
*
mut
JSContext
proto
:
HandleObject
class
:
&
'
static
JSClass
methods
:
Option
<
&
'
static
[
JSFunctionSpec
]
>
properties
:
Option
<
&
'
static
[
JSPropertySpec
]
>
constants
:
&
'
static
[
ConstantSpec
]
rval
:
MutableHandleObject
)
{
rval
.
set
(
JS_NewObjectWithUniqueType
(
cx
class
proto
)
)
;
assert
!
(
!
rval
.
ptr
.
is_null
(
)
)
;
if
let
Some
(
methods
)
=
methods
{
define_methods
(
cx
rval
.
handle
(
)
methods
)
.
unwrap
(
)
;
}
if
let
Some
(
properties
)
=
properties
{
define_properties
(
cx
rval
.
handle
(
)
properties
)
.
unwrap
(
)
;
}
define_constants
(
cx
rval
.
handle
(
)
constants
)
;
}
unsafe
fn
define_name
(
cx
:
*
mut
JSContext
obj
:
HandleObject
name
:
&
'
static
[
u8
]
)
{
assert
!
(
*
name
.
last
(
)
.
unwrap
(
)
=
=
b
'
\
0
'
)
;
let
name
=
RootedString
:
:
new
(
cx
JS_InternString
(
cx
name
.
as_ptr
(
)
as
*
const
libc
:
:
c_char
)
)
;
assert
!
(
!
name
.
ptr
.
is_null
(
)
)
;
assert
!
(
JS_DefineProperty2
(
cx
obj
b
"
name
\
0
"
.
as_ptr
(
)
as
*
const
libc
:
:
c_char
name
.
handle
(
)
JSPROP_READONLY
None
None
)
)
;
}
unsafe
fn
define_length
(
cx
:
*
mut
JSContext
obj
:
HandleObject
length
:
u32
)
{
assert
!
(
JS_DefineProperty4
(
cx
obj
b
"
length
\
0
"
.
as_ptr
(
)
as
*
const
libc
:
:
c_char
length
JSPROP_READONLY
None
None
)
)
;
}
unsafe
fn
define_on_global_object
(
cx
:
*
mut
JSContext
receiver
:
HandleObject
name
:
&
'
static
[
u8
]
obj
:
HandleObject
)
{
assert
!
(
*
name
.
last
(
)
.
unwrap
(
)
=
=
b
'
\
0
'
)
;
assert
!
(
JS_DefineProperty1
(
cx
receiver
name
.
as_ptr
(
)
as
*
const
libc
:
:
c_char
obj
0
None
None
)
)
;
}
