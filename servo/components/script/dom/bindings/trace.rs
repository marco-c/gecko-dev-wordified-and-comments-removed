use
dom
:
:
bindings
:
:
js
:
:
JS
;
use
dom
:
:
bindings
:
:
utils
:
:
{
Reflectable
Reflector
}
;
use
js
:
:
jsapi
:
:
{
JSObject
JSTracer
JS_CallTracer
JSTRACE_OBJECT
}
;
use
js
:
:
jsval
:
:
JSVal
;
use
libc
;
use
std
:
:
mem
;
use
std
:
:
cell
:
:
{
Cell
RefCell
}
;
use
serialize
:
:
{
Encodable
Encoder
}
;
fn
get_jstracer
<
'
a
S
:
Encoder
<
E
>
E
>
(
s
:
&
'
a
mut
S
)
-
>
&
'
a
mut
JSTracer
{
unsafe
{
mem
:
:
transmute
(
s
)
}
}
impl
<
T
:
Reflectable
+
Encodable
<
S
E
>
S
:
Encoder
<
E
>
E
>
Encodable
<
S
E
>
for
JS
<
T
>
{
fn
encode
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
E
>
{
trace_reflector
(
get_jstracer
(
s
)
"
"
self
.
reflector
(
)
)
;
Ok
(
(
)
)
}
}
impl
<
S
:
Encoder
<
E
>
E
>
Encodable
<
S
E
>
for
Reflector
{
fn
encode
(
&
self
_s
:
&
mut
S
)
-
>
Result
<
(
)
E
>
{
Ok
(
(
)
)
}
}
pub
trait
JSTraceable
{
fn
trace
(
&
self
trc
:
*
mut
JSTracer
)
;
}
pub
fn
trace_jsval
(
tracer
:
*
mut
JSTracer
description
:
&
str
val
:
JSVal
)
{
if
!
val
.
is_markable
(
)
{
return
;
}
unsafe
{
let
name
=
description
.
to_c_str
(
)
;
(
*
tracer
)
.
debugPrinter
=
None
;
(
*
tracer
)
.
debugPrintIndex
=
-
1
;
(
*
tracer
)
.
debugPrintArg
=
name
.
as_ptr
(
)
as
*
const
libc
:
:
c_void
;
debug
!
(
"
tracing
value
{
:
s
}
"
description
)
;
JS_CallTracer
(
tracer
val
.
to_gcthing
(
)
val
.
trace_kind
(
)
)
;
}
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
trace_reflector
(
tracer
:
*
mut
JSTracer
description
:
&
str
reflector
:
&
Reflector
)
{
trace_object
(
tracer
description
reflector
.
get_jsobject
(
)
)
}
pub
fn
trace_object
(
tracer
:
*
mut
JSTracer
description
:
&
str
obj
:
*
mut
JSObject
)
{
unsafe
{
let
name
=
description
.
to_c_str
(
)
;
(
*
tracer
)
.
debugPrinter
=
None
;
(
*
tracer
)
.
debugPrintIndex
=
-
1
;
(
*
tracer
)
.
debugPrintArg
=
name
.
as_ptr
(
)
as
*
const
libc
:
:
c_void
;
debug
!
(
"
tracing
{
:
s
}
"
description
)
;
JS_CallTracer
(
tracer
obj
as
*
mut
libc
:
:
c_void
JSTRACE_OBJECT
)
;
}
}
pub
struct
Untraceable
<
T
>
{
inner
:
T
}
impl
<
T
>
Untraceable
<
T
>
{
pub
fn
new
(
val
:
T
)
-
>
Untraceable
<
T
>
{
Untraceable
{
inner
:
val
}
}
}
impl
<
S
:
Encoder
<
E
>
E
T
>
Encodable
<
S
E
>
for
Untraceable
<
T
>
{
fn
encode
(
&
self
_s
:
&
mut
S
)
-
>
Result
<
(
)
E
>
{
Ok
(
(
)
)
}
}
impl
<
T
>
Deref
<
T
>
for
Untraceable
<
T
>
{
fn
deref
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
T
{
&
self
.
inner
}
}
impl
<
T
>
DerefMut
<
T
>
for
Untraceable
<
T
>
{
fn
deref_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
T
{
&
mut
self
.
inner
}
}
#
[
deriving
(
PartialEq
Clone
)
]
pub
struct
Traceable
<
T
>
{
inner
:
T
}
impl
<
T
>
Traceable
<
T
>
{
pub
fn
new
(
val
:
T
)
-
>
Traceable
<
T
>
{
Traceable
{
inner
:
val
}
}
}
impl
<
T
>
Deref
<
T
>
for
Traceable
<
T
>
{
fn
deref
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
T
{
&
self
.
inner
}
}
impl
<
S
:
Encoder
<
E
>
E
T
:
Encodable
<
S
E
>
>
Encodable
<
S
E
>
for
Traceable
<
RefCell
<
T
>
>
{
fn
encode
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
E
>
{
self
.
borrow
(
)
.
encode
(
s
)
}
}
impl
<
S
:
Encoder
<
E
>
E
T
:
Encodable
<
S
E
>
+
Copy
>
Encodable
<
S
E
>
for
Traceable
<
Cell
<
T
>
>
{
fn
encode
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
E
>
{
self
.
deref
(
)
.
get
(
)
.
encode
(
s
)
}
}
impl
<
S
:
Encoder
<
E
>
E
>
Encodable
<
S
E
>
for
Traceable
<
*
mut
JSObject
>
{
fn
encode
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
E
>
{
trace_object
(
get_jstracer
(
s
)
"
object
"
*
*
self
)
;
Ok
(
(
)
)
}
}
impl
<
S
:
Encoder
<
E
>
E
>
Encodable
<
S
E
>
for
Traceable
<
JSVal
>
{
fn
encode
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
E
>
{
trace_jsval
(
get_jstracer
(
s
)
"
val
"
*
*
self
)
;
Ok
(
(
)
)
}
}
