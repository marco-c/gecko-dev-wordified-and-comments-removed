use
dom
:
:
bindings
:
:
conversions
:
:
DerivedFrom
;
use
dom
:
:
bindings
:
:
root
:
:
DomRoot
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
js
:
:
jsapi
:
:
{
HandleObject
JSContext
JSObject
Heap
}
;
use
std
:
:
default
:
:
Default
;
pub
fn
reflect_dom_object
<
T
U
>
(
obj
:
Box
<
T
>
global
:
&
U
wrap_fn
:
unsafe
fn
(
*
mut
JSContext
&
GlobalScope
Box
<
T
>
)
-
>
DomRoot
<
T
>
)
-
>
DomRoot
<
T
>
where
T
:
DomObject
U
:
DerivedFrom
<
GlobalScope
>
{
let
global_scope
=
global
.
upcast
(
)
;
unsafe
{
wrap_fn
(
global_scope
.
get_cx
(
)
global_scope
obj
)
}
}
#
[
allow
(
unrooted_must_root
)
]
#
[
derive
(
HeapSizeOf
)
]
#
[
must_root
]
pub
struct
Reflector
{
#
[
ignore_heap_size_of
=
"
defined
and
measured
in
rust
-
mozjs
"
]
object
:
Heap
<
*
mut
JSObject
>
}
#
[
allow
(
unrooted_must_root
)
]
impl
PartialEq
for
Reflector
{
fn
eq
(
&
self
other
:
&
Reflector
)
-
>
bool
{
self
.
object
.
get
(
)
=
=
other
.
object
.
get
(
)
}
}
impl
Reflector
{
#
[
inline
]
pub
fn
get_jsobject
(
&
self
)
-
>
HandleObject
{
self
.
object
.
handle
(
)
}
pub
fn
set_jsobject
(
&
mut
self
object
:
*
mut
JSObject
)
{
assert
!
(
self
.
object
.
get
(
)
.
is_null
(
)
)
;
assert
!
(
!
object
.
is_null
(
)
)
;
self
.
object
.
set
(
object
)
;
}
pub
fn
rootable
(
&
self
)
-
>
&
Heap
<
*
mut
JSObject
>
{
&
self
.
object
}
pub
fn
new
(
)
-
>
Reflector
{
Reflector
{
object
:
Heap
:
:
default
(
)
}
}
}
pub
trait
DomObject
{
fn
reflector
(
&
self
)
-
>
&
Reflector
;
fn
global
(
&
self
)
-
>
DomRoot
<
GlobalScope
>
where
Self
:
Sized
{
GlobalScope
:
:
from_reflector
(
self
)
}
}
impl
DomObject
for
Reflector
{
fn
reflector
(
&
self
)
-
>
&
Self
{
self
}
}
pub
trait
MutDomObject
:
DomObject
{
fn
init_reflector
(
&
mut
self
obj
:
*
mut
JSObject
)
;
}
impl
MutDomObject
for
Reflector
{
fn
init_reflector
(
&
mut
self
obj
:
*
mut
JSObject
)
{
self
.
set_jsobject
(
obj
)
}
}
