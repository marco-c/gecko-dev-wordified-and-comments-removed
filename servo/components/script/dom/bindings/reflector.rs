use
dom
:
:
bindings
:
:
conversions
:
:
DerivedFrom
;
use
dom
:
:
bindings
:
:
js
:
:
Root
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
js
:
:
jsapi
:
:
{
HandleObject
JSContext
JSObject
}
;
use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
ptr
;
pub
fn
reflect_dom_object
<
T
U
>
(
obj
:
Box
<
T
>
global
:
&
U
wrap_fn
:
unsafe
fn
(
*
mut
JSContext
&
GlobalScope
Box
<
T
>
)
-
>
Root
<
T
>
)
-
>
Root
<
T
>
where
T
:
Reflectable
U
:
DerivedFrom
<
GlobalScope
>
{
let
global_scope
=
global
.
upcast
(
)
;
unsafe
{
wrap_fn
(
global_scope
.
get_cx
(
)
global_scope
obj
)
}
}
#
[
allow
(
unrooted_must_root
)
]
#
[
must_root
]
#
[
servo_lang
=
"
reflector
"
]
#
[
derive
(
HeapSizeOf
)
]
pub
struct
Reflector
{
#
[
ignore_heap_size_of
=
"
defined
and
measured
in
rust
-
mozjs
"
]
object
:
UnsafeCell
<
*
mut
JSObject
>
}
#
[
allow
(
unrooted_must_root
)
]
impl
PartialEq
for
Reflector
{
fn
eq
(
&
self
other
:
&
Reflector
)
-
>
bool
{
unsafe
{
*
self
.
object
.
get
(
)
=
=
*
other
.
object
.
get
(
)
}
}
}
impl
Reflector
{
#
[
inline
]
pub
fn
get_jsobject
(
&
self
)
-
>
HandleObject
{
unsafe
{
HandleObject
:
:
from_marked_location
(
self
.
object
.
get
(
)
)
}
}
pub
fn
set_jsobject
(
&
mut
self
object
:
*
mut
JSObject
)
{
unsafe
{
let
obj
=
self
.
object
.
get
(
)
;
assert
!
(
(
*
obj
)
.
is_null
(
)
)
;
assert
!
(
!
object
.
is_null
(
)
)
;
*
obj
=
object
;
}
}
pub
fn
rootable
(
&
self
)
-
>
*
mut
*
mut
JSObject
{
self
.
object
.
get
(
)
}
pub
fn
new
(
)
-
>
Reflector
{
Reflector
{
object
:
UnsafeCell
:
:
new
(
ptr
:
:
null_mut
(
)
)
}
}
}
pub
trait
Reflectable
{
fn
reflector
(
&
self
)
-
>
&
Reflector
;
fn
global
(
&
self
)
-
>
Root
<
GlobalScope
>
where
Self
:
Sized
{
GlobalScope
:
:
from_reflector
(
self
)
}
}
pub
trait
MutReflectable
:
Reflectable
{
fn
init_reflector
(
&
mut
self
obj
:
*
mut
JSObject
)
;
}
