use
heapsize
:
:
HeapSizeOf
;
use
num_traits
:
:
Float
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
ops
:
:
Deref
;
#
[
derive
(
Clone
Copy
Eq
JSTraceable
PartialEq
)
]
pub
struct
Finite
<
T
:
Float
>
(
T
)
;
impl
<
T
:
Float
>
Finite
<
T
>
{
pub
fn
new
(
value
:
T
)
-
>
Option
<
Finite
<
T
>
>
{
if
value
.
is_finite
(
)
{
Some
(
Finite
(
value
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
wrap
(
value
:
T
)
-
>
Finite
<
T
>
{
assert
!
(
value
.
is_finite
(
)
"
Finite
<
T
>
doesn
'
t
encapsulate
unrestricted
value
.
"
)
;
Finite
(
value
)
}
}
impl
<
T
:
Float
>
Deref
for
Finite
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
let
&
Finite
(
ref
value
)
=
self
;
value
}
}
impl
<
T
:
Float
+
HeapSizeOf
>
HeapSizeOf
for
Finite
<
T
>
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
(
*
*
self
)
.
heap_size_of_children
(
)
}
}
impl
<
T
:
Float
+
Default
>
Default
for
Finite
<
T
>
{
fn
default
(
)
-
>
Finite
<
T
>
{
Finite
:
:
wrap
(
T
:
:
default
(
)
)
}
}
