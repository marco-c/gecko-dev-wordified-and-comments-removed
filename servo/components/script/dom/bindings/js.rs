use
dom
:
:
bindings
:
:
trace
:
:
JSTraceable
;
use
dom
:
:
bindings
:
:
trace
:
:
RootedVec
;
use
dom
:
:
bindings
:
:
utils
:
:
{
Reflector
Reflectable
}
;
use
dom
:
:
node
:
:
Node
;
use
js
:
:
jsapi
:
:
JSObject
;
use
js
:
:
jsval
:
:
JSVal
;
use
layout_interface
:
:
TrustedNodeAddress
;
use
script_task
:
:
STACK_ROOTS
;
use
core
:
:
nonzero
:
:
NonZero
;
use
libc
;
use
std
:
:
cell
:
:
{
Cell
UnsafeCell
}
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
intrinsics
:
:
return_address
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
;
use
std
:
:
ops
:
:
Deref
;
#
[
must_root
]
pub
struct
Unrooted
<
T
>
{
ptr
:
NonZero
<
*
const
T
>
}
impl
<
T
:
Reflectable
>
Unrooted
<
T
>
{
pub
unsafe
fn
from_raw
(
raw
:
*
const
T
)
-
>
Unrooted
<
T
>
{
assert
!
(
!
raw
.
is_null
(
)
)
;
Unrooted
{
ptr
:
NonZero
:
:
new
(
raw
)
}
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
from_js
(
ptr
:
JS
<
T
>
)
-
>
Unrooted
<
T
>
{
Unrooted
{
ptr
:
ptr
.
ptr
}
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
from_temporary
(
ptr
:
Temporary
<
T
>
)
-
>
Unrooted
<
T
>
{
Unrooted
:
:
from_js
(
ptr
.
inner
)
}
pub
fn
reflector
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Reflector
{
unsafe
{
(
*
*
self
.
ptr
)
.
reflector
(
)
}
}
pub
unsafe
fn
unsafe_get
(
&
self
)
-
>
*
const
T
{
*
self
.
ptr
}
pub
fn
root
(
self
)
-
>
Root
<
T
>
{
STACK_ROOTS
.
with
(
|
ref
collection
|
{
let
RootCollectionPtr
(
collection
)
=
collection
.
get
(
)
.
unwrap
(
)
;
unsafe
{
Root
:
:
new
(
&
*
collection
self
.
ptr
)
}
}
)
}
}
impl
<
T
>
Copy
for
Unrooted
<
T
>
{
}
#
[
allow
(
unrooted_must_root
)
]
pub
struct
Temporary
<
T
>
{
inner
:
JS
<
T
>
_js_ptr
:
*
mut
JSObject
}
impl
<
T
>
Clone
for
Temporary
<
T
>
{
fn
clone
(
&
self
)
-
>
Temporary
<
T
>
{
Temporary
{
inner
:
self
.
inner
_js_ptr
:
self
.
_js_ptr
}
}
}
impl
<
T
>
PartialEq
for
Temporary
<
T
>
{
fn
eq
(
&
self
other
:
&
Temporary
<
T
>
)
-
>
bool
{
self
.
inner
=
=
other
.
inner
}
}
impl
<
T
:
Reflectable
>
Temporary
<
T
>
{
pub
fn
new
(
inner
:
JS
<
T
>
)
-
>
Temporary
<
T
>
{
Temporary
{
inner
:
inner
_js_ptr
:
inner
.
reflector
(
)
.
get_jsobject
(
)
}
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
from_unrooted
(
unrooted
:
Unrooted
<
T
>
)
-
>
Temporary
<
T
>
{
Temporary
{
inner
:
JS
{
ptr
:
unrooted
.
ptr
}
_js_ptr
:
unrooted
.
reflector
(
)
.
get_jsobject
(
)
}
}
pub
fn
from_rooted
<
'
a
>
(
root
:
JSRef
<
'
a
T
>
)
-
>
Temporary
<
T
>
{
Temporary
:
:
new
(
JS
:
:
from_rooted
(
root
)
)
}
pub
fn
root
(
&
self
)
-
>
Root
<
T
>
{
STACK_ROOTS
.
with
(
|
ref
collection
|
{
let
RootCollectionPtr
(
collection
)
=
collection
.
get
(
)
.
unwrap
(
)
;
unsafe
{
Root
:
:
new
(
&
*
collection
self
.
inner
.
ptr
)
}
}
)
}
unsafe
fn
inner
(
&
self
)
-
>
JS
<
T
>
{
self
.
inner
.
clone
(
)
}
pub
unsafe
fn
transmute
<
To
>
(
self
)
-
>
Temporary
<
To
>
{
mem
:
:
transmute
(
self
)
}
}
#
[
must_root
]
pub
struct
JS
<
T
>
{
ptr
:
NonZero
<
*
const
T
>
}
impl
<
T
>
JS
<
T
>
{
pub
unsafe
fn
to_layout
(
self
)
-
>
LayoutJS
<
T
>
{
LayoutJS
{
ptr
:
self
.
ptr
.
clone
(
)
}
}
}
pub
struct
LayoutJS
<
T
>
{
ptr
:
NonZero
<
*
const
T
>
}
impl
<
T
:
Reflectable
>
LayoutJS
<
T
>
{
pub
unsafe
fn
get_jsobject
(
&
self
)
-
>
*
mut
JSObject
{
(
*
*
self
.
ptr
)
.
reflector
(
)
.
get_jsobject
(
)
}
}
impl
<
T
>
Copy
for
JS
<
T
>
{
}
impl
<
T
>
Copy
for
LayoutJS
<
T
>
{
}
impl
<
T
>
PartialEq
for
JS
<
T
>
{
#
[
allow
(
unrooted_must_root
)
]
fn
eq
(
&
self
other
:
&
JS
<
T
>
)
-
>
bool
{
self
.
ptr
=
=
other
.
ptr
}
}
impl
<
T
>
PartialEq
for
LayoutJS
<
T
>
{
#
[
allow
(
unrooted_must_root
)
]
fn
eq
(
&
self
other
:
&
LayoutJS
<
T
>
)
-
>
bool
{
self
.
ptr
=
=
other
.
ptr
}
}
impl
<
T
>
Clone
for
JS
<
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
JS
<
T
>
{
JS
{
ptr
:
self
.
ptr
.
clone
(
)
}
}
}
impl
<
T
>
Clone
for
LayoutJS
<
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
LayoutJS
<
T
>
{
LayoutJS
{
ptr
:
self
.
ptr
.
clone
(
)
}
}
}
impl
LayoutJS
<
Node
>
{
pub
unsafe
fn
from_trusted_node_address
(
inner
:
TrustedNodeAddress
)
-
>
LayoutJS
<
Node
>
{
let
TrustedNodeAddress
(
addr
)
=
inner
;
LayoutJS
{
ptr
:
NonZero
:
:
new
(
addr
as
*
const
Node
)
}
}
}
impl
<
T
:
Reflectable
>
JS
<
T
>
{
pub
fn
root
(
&
self
)
-
>
Root
<
T
>
{
STACK_ROOTS
.
with
(
|
ref
collection
|
{
let
RootCollectionPtr
(
collection
)
=
collection
.
get
(
)
.
unwrap
(
)
;
unsafe
{
Root
:
:
new
(
&
*
collection
self
.
ptr
)
}
}
)
}
}
impl
<
U
:
Reflectable
>
JS
<
U
>
{
pub
fn
from_rooted
<
T
:
Assignable
<
U
>
>
(
root
:
T
)
-
>
JS
<
U
>
{
unsafe
{
root
.
get_js
(
)
}
}
}
impl
<
T
:
Reflectable
>
Reflectable
for
JS
<
T
>
{
fn
reflector
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Reflector
{
unsafe
{
(
*
*
self
.
ptr
)
.
reflector
(
)
}
}
}
pub
trait
HeapGCValue
:
JSTraceable
{
}
impl
HeapGCValue
for
JSVal
{
}
impl
<
T
:
Reflectable
>
HeapGCValue
for
JS
<
T
>
{
}
#
[
must_root
]
#
[
jstraceable
]
pub
struct
MutHeap
<
T
:
HeapGCValue
+
Copy
>
{
val
:
Cell
<
T
>
}
impl
<
T
:
HeapGCValue
+
Copy
>
MutHeap
<
T
>
{
pub
fn
new
(
initial
:
T
)
-
>
MutHeap
<
T
>
{
MutHeap
{
val
:
Cell
:
:
new
(
initial
)
}
}
pub
fn
set
(
&
self
val
:
T
)
{
self
.
val
.
set
(
val
)
}
pub
fn
get
(
&
self
)
-
>
T
{
self
.
val
.
get
(
)
}
}
#
[
must_root
]
#
[
jstraceable
]
pub
struct
MutNullableJS
<
T
:
Reflectable
>
{
ptr
:
Cell
<
Option
<
JS
<
T
>
>
>
}
impl
<
U
:
Reflectable
>
MutNullableJS
<
U
>
{
pub
fn
new
<
T
:
Assignable
<
U
>
>
(
initial
:
Option
<
T
>
)
-
>
MutNullableJS
<
U
>
{
MutNullableJS
{
ptr
:
Cell
:
:
new
(
initial
.
map
(
|
initial
|
{
unsafe
{
initial
.
get_js
(
)
}
}
)
)
}
}
}
impl
<
T
:
Reflectable
>
Default
for
MutNullableJS
<
T
>
{
fn
default
(
)
-
>
MutNullableJS
<
T
>
{
MutNullableJS
{
ptr
:
Cell
:
:
new
(
None
)
}
}
}
impl
<
T
:
Reflectable
>
MutNullableJS
<
T
>
{
pub
fn
assign
<
U
:
Assignable
<
T
>
>
(
&
self
val
:
Option
<
U
>
)
{
self
.
ptr
.
set
(
val
.
map
(
|
val
|
{
unsafe
{
val
.
get_js
(
)
}
}
)
)
;
}
pub
fn
clear
(
&
self
)
{
self
.
assign
(
None
:
:
<
JS
<
T
>
>
)
;
}
pub
fn
get
(
&
self
)
-
>
Option
<
Temporary
<
T
>
>
{
self
.
ptr
.
get
(
)
.
map
(
Temporary
:
:
new
)
}
pub
unsafe
fn
get_inner_as_layout
(
&
self
)
-
>
Option
<
LayoutJS
<
T
>
>
{
self
.
ptr
.
get
(
)
.
map
(
|
js
|
js
.
to_layout
(
)
)
}
pub
fn
or_init
<
F
>
(
&
self
cb
:
F
)
-
>
Temporary
<
T
>
where
F
:
FnOnce
(
)
-
>
Temporary
<
T
>
{
match
self
.
get
(
)
{
Some
(
inner
)
=
>
inner
None
=
>
{
let
inner
=
cb
(
)
;
self
.
assign
(
Some
(
inner
.
clone
(
)
)
)
;
inner
}
}
}
}
impl
<
T
:
Reflectable
>
JS
<
T
>
{
pub
fn
assign
(
&
mut
self
val
:
Temporary
<
T
>
)
{
*
self
=
unsafe
{
val
.
inner
(
)
}
;
}
}
impl
<
T
:
Reflectable
>
LayoutJS
<
T
>
{
pub
unsafe
fn
unsafe_get
(
&
self
)
-
>
*
const
T
{
*
self
.
ptr
}
}
impl
<
From
>
JS
<
From
>
{
pub
unsafe
fn
transmute_copy
<
To
>
(
&
self
)
-
>
JS
<
To
>
{
mem
:
:
transmute_copy
(
self
)
}
}
impl
<
From
>
LayoutJS
<
From
>
{
pub
unsafe
fn
transmute_copy
<
To
>
(
&
self
)
-
>
LayoutJS
<
To
>
{
mem
:
:
transmute_copy
(
self
)
}
}
pub
trait
RootedReference
<
T
>
{
fn
r
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
JSRef
<
'
a
T
>
>
;
}
impl
<
T
:
Reflectable
>
RootedReference
<
T
>
for
Option
<
Root
<
T
>
>
{
fn
r
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
JSRef
<
'
a
T
>
>
{
self
.
as_ref
(
)
.
map
(
|
root
|
root
.
r
(
)
)
}
}
pub
trait
OptionalRootedReference
<
T
>
{
fn
r
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
Option
<
JSRef
<
'
a
T
>
>
>
;
}
impl
<
T
:
Reflectable
>
OptionalRootedReference
<
T
>
for
Option
<
Option
<
Root
<
T
>
>
>
{
fn
r
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
Option
<
JSRef
<
'
a
T
>
>
>
{
self
.
as_ref
(
)
.
map
(
|
inner
|
inner
.
r
(
)
)
}
}
pub
trait
Assignable
<
T
>
{
unsafe
fn
get_js
(
&
self
)
-
>
JS
<
T
>
;
}
impl
<
T
>
Assignable
<
T
>
for
JS
<
T
>
{
unsafe
fn
get_js
(
&
self
)
-
>
JS
<
T
>
{
self
.
clone
(
)
}
}
impl
<
'
a
T
:
Reflectable
>
Assignable
<
T
>
for
JSRef
<
'
a
T
>
{
unsafe
fn
get_js
(
&
self
)
-
>
JS
<
T
>
{
self
.
unrooted
(
)
}
}
impl
<
T
:
Reflectable
>
Assignable
<
T
>
for
Temporary
<
T
>
{
unsafe
fn
get_js
(
&
self
)
-
>
JS
<
T
>
{
self
.
inner
(
)
}
}
pub
trait
OptionalRootable
<
T
>
{
fn
root
(
self
)
-
>
Option
<
Root
<
T
>
>
;
}
impl
<
T
:
Reflectable
>
OptionalRootable
<
T
>
for
Option
<
Temporary
<
T
>
>
{
fn
root
(
self
)
-
>
Option
<
Root
<
T
>
>
{
self
.
map
(
|
inner
|
inner
.
root
(
)
)
}
}
pub
trait
OptionalUnrootable
<
T
>
{
fn
unrooted
(
&
self
)
-
>
Option
<
JS
<
T
>
>
;
}
impl
<
'
a
T
:
Reflectable
>
OptionalUnrootable
<
T
>
for
Option
<
JSRef
<
'
a
T
>
>
{
fn
unrooted
(
&
self
)
-
>
Option
<
JS
<
T
>
>
{
self
.
as_ref
(
)
.
map
(
|
inner
|
JS
:
:
from_rooted
(
*
inner
)
)
}
}
pub
trait
OptionalRootedRootable
<
T
>
{
fn
root
(
&
self
)
-
>
Option
<
Root
<
T
>
>
;
}
impl
<
T
:
Reflectable
>
OptionalRootedRootable
<
T
>
for
Option
<
JS
<
T
>
>
{
fn
root
(
&
self
)
-
>
Option
<
Root
<
T
>
>
{
self
.
as_ref
(
)
.
map
(
|
inner
|
inner
.
root
(
)
)
}
}
impl
<
T
:
Reflectable
>
OptionalRootedRootable
<
T
>
for
Option
<
Unrooted
<
T
>
>
{
fn
root
(
&
self
)
-
>
Option
<
Root
<
T
>
>
{
self
.
as_ref
(
)
.
map
(
|
inner
|
inner
.
root
(
)
)
}
}
pub
trait
OptionalOptionalRootedRootable
<
T
>
{
fn
root
(
&
self
)
-
>
Option
<
Option
<
Root
<
T
>
>
>
;
}
impl
<
T
:
Reflectable
>
OptionalOptionalRootedRootable
<
T
>
for
Option
<
Option
<
JS
<
T
>
>
>
{
fn
root
(
&
self
)
-
>
Option
<
Option
<
Root
<
T
>
>
>
{
self
.
as_ref
(
)
.
map
(
|
inner
|
inner
.
root
(
)
)
}
}
impl
<
T
:
Reflectable
>
OptionalOptionalRootedRootable
<
T
>
for
Option
<
Option
<
Unrooted
<
T
>
>
>
{
fn
root
(
&
self
)
-
>
Option
<
Option
<
Root
<
T
>
>
>
{
self
.
as_ref
(
)
.
map
(
|
inner
|
inner
.
root
(
)
)
}
}
pub
trait
ResultRootable
<
T
U
>
{
fn
root
(
self
)
-
>
Result
<
Root
<
T
>
U
>
;
}
impl
<
T
:
Reflectable
U
>
ResultRootable
<
T
U
>
for
Result
<
Temporary
<
T
>
U
>
{
fn
root
(
self
)
-
>
Result
<
Root
<
T
>
U
>
{
self
.
map
(
|
inner
|
inner
.
root
(
)
)
}
}
impl
<
T
:
Reflectable
U
>
ResultRootable
<
T
U
>
for
Result
<
JS
<
T
>
U
>
{
fn
root
(
self
)
-
>
Result
<
Root
<
T
>
U
>
{
self
.
map
(
|
inner
|
inner
.
root
(
)
)
}
}
pub
trait
TemporaryPushable
<
T
>
{
fn
push_unrooted
(
&
mut
self
val
:
&
T
)
;
fn
insert_unrooted
(
&
mut
self
index
:
usize
val
:
&
T
)
;
}
impl
<
T
:
Assignable
<
U
>
U
:
Reflectable
>
TemporaryPushable
<
T
>
for
Vec
<
JS
<
U
>
>
{
fn
push_unrooted
(
&
mut
self
val
:
&
T
)
{
self
.
push
(
unsafe
{
val
.
get_js
(
)
}
)
;
}
fn
insert_unrooted
(
&
mut
self
index
:
usize
val
:
&
T
)
{
self
.
insert
(
index
unsafe
{
val
.
get_js
(
)
}
)
;
}
}
pub
struct
RootCollection
{
roots
:
UnsafeCell
<
RootedVec
<
*
mut
JSObject
>
>
}
pub
struct
RootCollectionPtr
(
pub
*
const
RootCollection
)
;
impl
Copy
for
RootCollectionPtr
{
}
impl
RootCollection
{
pub
fn
new
(
)
-
>
RootCollection
{
let
addr
=
unsafe
{
return_address
(
)
as
*
const
libc
:
:
c_void
}
;
RootCollection
{
roots
:
UnsafeCell
:
:
new
(
RootedVec
:
:
new_with_destination_address
(
addr
)
)
}
}
fn
root
<
'
b
>
(
&
self
untracked_js_ptr
:
*
mut
JSObject
)
{
unsafe
{
let
roots
=
self
.
roots
.
get
(
)
;
(
*
roots
)
.
push
(
untracked_js_ptr
)
;
debug
!
(
"
rooting
{
:
?
}
"
untracked_js_ptr
)
;
}
}
fn
unroot
<
'
b
T
:
Reflectable
>
(
&
self
rooted
:
&
Root
<
T
>
)
{
unsafe
{
let
roots
=
self
.
roots
.
get
(
)
;
let
unrooted
=
(
*
roots
)
.
pop
(
)
.
unwrap
(
)
;
debug
!
(
"
unrooted
{
:
?
}
(
expecting
{
:
?
}
"
unrooted
rooted
.
js_ptr
)
;
assert
!
(
unrooted
=
=
rooted
.
js_ptr
)
;
}
}
}
pub
struct
Root
<
T
>
{
root_list
:
&
'
static
RootCollection
ptr
:
NonZero
<
*
const
T
>
js_ptr
:
*
mut
JSObject
}
impl
<
T
:
Reflectable
>
Root
<
T
>
{
#
[
inline
]
fn
new
(
roots
:
&
'
static
RootCollection
unrooted
:
NonZero
<
*
const
T
>
)
-
>
Root
<
T
>
{
let
js_ptr
=
unsafe
{
(
*
*
unrooted
)
.
reflector
(
)
.
get_jsobject
(
)
}
;
roots
.
root
(
js_ptr
)
;
Root
{
root_list
:
roots
ptr
:
unrooted
js_ptr
:
js_ptr
}
}
pub
fn
r
<
'
b
>
(
&
'
b
self
)
-
>
JSRef
<
'
b
T
>
{
JSRef
{
ptr
:
self
.
ptr
chain
:
PhantomData
}
}
pub
fn
get_unsound_ref_forever
<
'
b
>
(
&
self
)
-
>
JSRef
<
'
b
T
>
{
JSRef
{
ptr
:
self
.
ptr
chain
:
PhantomData
}
}
}
#
[
unsafe_destructor
]
impl
<
T
:
Reflectable
>
Drop
for
Root
<
T
>
{
fn
drop
(
&
mut
self
)
{
self
.
root_list
.
unroot
(
self
)
;
}
}
impl
<
'
a
T
:
Reflectable
>
Deref
for
JSRef
<
'
a
T
>
{
type
Target
=
T
;
fn
deref
<
'
b
>
(
&
'
b
self
)
-
>
&
'
b
T
{
unsafe
{
&
*
*
self
.
ptr
}
}
}
pub
struct
JSRef
<
'
a
T
>
{
ptr
:
NonZero
<
*
const
T
>
chain
:
PhantomData
<
&
'
a
(
)
>
}
impl
<
'
a
T
>
Copy
for
JSRef
<
'
a
T
>
{
}
impl
<
'
a
T
>
Clone
for
JSRef
<
'
a
T
>
{
fn
clone
(
&
self
)
-
>
JSRef
<
'
a
T
>
{
JSRef
{
ptr
:
self
.
ptr
.
clone
(
)
chain
:
self
.
chain
}
}
}
impl
<
'
a
'
b
T
>
PartialEq
<
JSRef
<
'
b
T
>
>
for
JSRef
<
'
a
T
>
{
fn
eq
(
&
self
other
:
&
JSRef
<
T
>
)
-
>
bool
{
self
.
ptr
=
=
other
.
ptr
}
}
impl
<
'
a
T
>
JSRef
<
'
a
T
>
{
pub
unsafe
fn
transmute
<
To
>
(
self
)
-
>
JSRef
<
'
a
To
>
{
mem
:
:
transmute
(
self
)
}
pub
unsafe
fn
transmute_borrowed
<
'
b
To
>
(
&
'
b
self
)
-
>
&
'
b
JSRef
<
'
a
To
>
{
mem
:
:
transmute
(
self
)
}
pub
fn
unrooted
(
&
self
)
-
>
JS
<
T
>
{
JS
{
ptr
:
self
.
ptr
}
}
}
impl
<
'
a
T
:
Reflectable
>
JSRef
<
'
a
T
>
{
pub
fn
extended_deref
(
self
)
-
>
&
'
a
T
{
unsafe
{
&
*
*
self
.
ptr
}
}
}
impl
<
'
a
T
:
Reflectable
>
Reflectable
for
JSRef
<
'
a
T
>
{
fn
reflector
<
'
b
>
(
&
'
b
self
)
-
>
&
'
b
Reflector
{
(
*
*
self
)
.
reflector
(
)
}
}
pub
trait
Comparable
<
T
>
{
fn
equals
(
&
self
other
:
T
)
-
>
bool
;
}
impl
<
'
a
'
b
T
>
Comparable
<
JSRef
<
'
a
T
>
>
for
JSRef
<
'
b
T
>
{
fn
equals
(
&
self
other
:
JSRef
<
'
a
T
>
)
-
>
bool
{
self
.
ptr
=
=
other
.
ptr
}
}
impl
<
'
a
'
b
T
>
Comparable
<
Option
<
JSRef
<
'
a
T
>
>
>
for
Option
<
JSRef
<
'
b
T
>
>
{
fn
equals
(
&
self
other
:
Option
<
JSRef
<
'
a
T
>
>
)
-
>
bool
{
match
(
*
self
other
)
{
(
Some
(
x
)
Some
(
y
)
)
=
>
x
.
ptr
=
=
y
.
ptr
(
None
None
)
=
>
true
_
=
>
false
}
}
}
