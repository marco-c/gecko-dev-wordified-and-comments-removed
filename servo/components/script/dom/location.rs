use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
LocationBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
LocationBinding
:
:
LocationMethods
;
use
dom
:
:
bindings
:
:
error
:
:
{
Error
ErrorResult
}
;
use
dom
:
:
bindings
:
:
js
:
:
{
JS
Root
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
Reflector
reflect_dom_object
}
;
use
dom
:
:
bindings
:
:
str
:
:
{
DOMString
USVString
}
;
use
dom
:
:
urlhelper
:
:
UrlHelper
;
use
dom
:
:
window
:
:
Window
;
use
servo_url
:
:
ServoUrl
;
#
[
dom_struct
]
pub
struct
Location
{
reflector_
:
Reflector
window
:
JS
<
Window
>
}
impl
Location
{
fn
new_inherited
(
window
:
&
Window
)
-
>
Location
{
Location
{
reflector_
:
Reflector
:
:
new
(
)
window
:
JS
:
:
from_ref
(
window
)
}
}
pub
fn
new
(
window
:
&
Window
)
-
>
Root
<
Location
>
{
reflect_dom_object
(
box
Location
:
:
new_inherited
(
window
)
window
LocationBinding
:
:
Wrap
)
}
fn
get_url
(
&
self
)
-
>
ServoUrl
{
self
.
window
.
get_url
(
)
}
fn
set_url_component
(
&
self
value
:
USVString
setter
:
fn
(
&
mut
ServoUrl
USVString
)
)
{
let
mut
url
=
self
.
window
.
get_url
(
)
;
setter
(
&
mut
url
value
)
;
self
.
window
.
load_url
(
url
false
None
)
;
}
}
impl
LocationMethods
for
Location
{
/
/
https
:
/
/
html
.
spec
.
whatwg
.
org
/
multipage
/
#
dom
-
location
-
assign
fn
Assign
(
&
self
url
:
USVString
)
-
>
ErrorResult
{
/
/
TODO
:
per
spec
we
should
use
the
_API
base
URL_
specified
by
the
/
/
_entry
settings
object_
.
let
base_url
=
self
.
window
.
get_url
(
)
;
if
let
Ok
(
url
)
=
base_url
.
join
(
&
url
.
0
)
{
self
.
window
.
load_url
(
url
false
None
)
;
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
Syntax
)
}
}
/
/
https
:
/
/
html
.
spec
.
whatwg
.
org
/
multipage
/
#
dom
-
location
-
reload
fn
Reload
(
&
self
)
{
self
.
window
.
load_url
(
self
.
get_url
(
)
true
None
)
;
}
/
/
https
:
/
/
html
.
spec
.
whatwg
.
org
/
multipage
/
#
dom
-
location
-
hash
fn
Hash
(
&
self
)
-
>
USVString
{
UrlHelper
:
:
Hash
(
&
self
.
get_url
(
)
)
}
/
/
https
:
/
/
html
.
spec
.
whatwg
.
org
/
multipage
/
#
dom
-
location
-
hash
fn
SetHash
(
&
self
mut
value
:
USVString
)
{
if
value
.
0
.
is_empty
(
)
{
value
=
USVString
(
"
#
"
.
to_owned
(
)
)
;
}
self
.
set_url_component
(
value
UrlHelper
:
:
SetHash
)
;
}
fn
Host
(
&
self
)
-
>
USVString
{
UrlHelper
:
:
Host
(
&
self
.
get_url
(
)
)
}
fn
SetHost
(
&
self
value
:
USVString
)
{
self
.
set_url_component
(
value
UrlHelper
:
:
SetHost
)
;
}
fn
Origin
(
&
self
)
-
>
USVString
{
UrlHelper
:
:
Origin
(
&
self
.
get_url
(
)
)
}
fn
Hostname
(
&
self
)
-
>
USVString
{
UrlHelper
:
:
Hostname
(
&
self
.
get_url
(
)
)
}
fn
SetHostname
(
&
self
value
:
USVString
)
{
self
.
set_url_component
(
value
UrlHelper
:
:
SetHostname
)
;
}
fn
Href
(
&
self
)
-
>
USVString
{
UrlHelper
:
:
Href
(
&
self
.
get_url
(
)
)
}
fn
SetHref
(
&
self
value
:
USVString
)
{
if
let
Ok
(
url
)
=
self
.
window
.
get_url
(
)
.
join
(
&
value
.
0
)
{
self
.
window
.
load_url
(
url
false
None
)
;
}
}
fn
Pathname
(
&
self
)
-
>
USVString
{
UrlHelper
:
:
Pathname
(
&
self
.
get_url
(
)
)
}
fn
SetPathname
(
&
self
value
:
USVString
)
{
self
.
set_url_component
(
value
UrlHelper
:
:
SetPathname
)
;
}
fn
Port
(
&
self
)
-
>
USVString
{
UrlHelper
:
:
Port
(
&
self
.
get_url
(
)
)
}
fn
SetPort
(
&
self
value
:
USVString
)
{
self
.
set_url_component
(
value
UrlHelper
:
:
SetPort
)
;
}
fn
Protocol
(
&
self
)
-
>
USVString
{
UrlHelper
:
:
Protocol
(
&
self
.
get_url
(
)
)
}
fn
SetProtocol
(
&
self
value
:
USVString
)
{
self
.
set_url_component
(
value
UrlHelper
:
:
SetProtocol
)
;
}
fn
Stringifier
(
&
self
)
-
>
DOMString
{
DOMString
:
:
from
(
self
.
Href
(
)
.
0
)
}
fn
Search
(
&
self
)
-
>
USVString
{
UrlHelper
:
:
Search
(
&
self
.
get_url
(
)
)
}
fn
SetSearch
(
&
self
value
:
USVString
)
{
self
.
set_url_component
(
value
UrlHelper
:
:
SetSearch
)
;
}
}
