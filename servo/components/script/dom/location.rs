use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
LocationBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
LocationBinding
:
:
LocationMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
WindowBinding
:
:
WindowBinding
:
:
WindowMethods
;
use
dom
:
:
bindings
:
:
error
:
:
{
Error
ErrorResult
Fallible
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
Reflector
reflect_dom_object
}
;
use
dom
:
:
bindings
:
:
root
:
:
{
Dom
DomRoot
}
;
use
dom
:
:
bindings
:
:
str
:
:
{
DOMString
USVString
}
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom
:
:
urlhelper
:
:
UrlHelper
;
use
dom
:
:
window
:
:
Window
;
use
dom_struct
:
:
dom_struct
;
use
servo_url
:
:
{
MutableOrigin
ServoUrl
}
;
#
[
dom_struct
]
pub
struct
Location
{
reflector_
:
Reflector
window
:
Dom
<
Window
>
}
impl
Location
{
fn
new_inherited
(
window
:
&
Window
)
-
>
Location
{
Location
{
reflector_
:
Reflector
:
:
new
(
)
window
:
Dom
:
:
from_ref
(
window
)
}
}
pub
fn
new
(
window
:
&
Window
)
-
>
DomRoot
<
Location
>
{
reflect_dom_object
(
Box
:
:
new
(
Location
:
:
new_inherited
(
window
)
)
window
LocationBinding
:
:
Wrap
)
}
fn
get_url
(
&
self
)
-
>
ServoUrl
{
self
.
window
.
get_url
(
)
}
fn
set_url_component
(
&
self
value
:
USVString
setter
:
fn
(
&
mut
ServoUrl
USVString
)
)
{
let
mut
url
=
self
.
window
.
get_url
(
)
;
setter
(
&
mut
url
value
)
;
self
.
window
.
load_url
(
url
false
false
None
)
;
}
fn
check_same_origin_domain
(
&
self
)
-
>
ErrorResult
{
let
entry_document
=
GlobalScope
:
:
entry
(
)
.
as_window
(
)
.
Document
(
)
;
let
this_document
=
self
.
window
.
Document
(
)
;
if
entry_document
.
origin
(
)
.
same_origin_domain
(
this_document
.
origin
(
)
)
{
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
Security
)
}
}
pub
fn
reload_without_origin_check
(
&
self
)
{
self
.
window
.
load_url
(
self
.
get_url
(
)
true
true
None
)
;
}
#
[
allow
(
dead_code
)
]
pub
fn
origin
(
&
self
)
-
>
&
MutableOrigin
{
self
.
window
.
origin
(
)
}
}
impl
LocationMethods
for
Location
{
fn
Assign
(
&
self
url
:
USVString
)
-
>
ErrorResult
{
self
.
check_same_origin_domain
(
)
?
;
let
base_url
=
self
.
window
.
get_url
(
)
;
if
let
Ok
(
url
)
=
base_url
.
join
(
&
url
.
0
)
{
self
.
window
.
load_url
(
url
false
false
None
)
;
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
Syntax
)
}
}
fn
Reload
(
&
self
)
-
>
ErrorResult
{
self
.
check_same_origin_domain
(
)
?
;
self
.
window
.
load_url
(
self
.
get_url
(
)
true
true
None
)
;
Ok
(
(
)
)
}
fn
Replace
(
&
self
url
:
USVString
)
-
>
ErrorResult
{
let
base_url
=
self
.
window
.
get_url
(
)
;
if
let
Ok
(
url
)
=
base_url
.
join
(
&
url
.
0
)
{
self
.
window
.
load_url
(
url
true
false
None
)
;
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
Syntax
)
}
}
fn
GetHash
(
&
self
)
-
>
Fallible
<
USVString
>
{
self
.
check_same_origin_domain
(
)
?
;
Ok
(
UrlHelper
:
:
Hash
(
&
self
.
get_url
(
)
)
)
}
fn
SetHash
(
&
self
mut
value
:
USVString
)
-
>
ErrorResult
{
if
value
.
0
.
is_empty
(
)
{
value
=
USVString
(
"
#
"
.
to_owned
(
)
)
;
}
self
.
check_same_origin_domain
(
)
?
;
self
.
set_url_component
(
value
UrlHelper
:
:
SetHash
)
;
Ok
(
(
)
)
}
fn
GetHost
(
&
self
)
-
>
Fallible
<
USVString
>
{
self
.
check_same_origin_domain
(
)
?
;
Ok
(
UrlHelper
:
:
Host
(
&
self
.
get_url
(
)
)
)
}
fn
SetHost
(
&
self
value
:
USVString
)
-
>
ErrorResult
{
self
.
check_same_origin_domain
(
)
?
;
self
.
set_url_component
(
value
UrlHelper
:
:
SetHost
)
;
Ok
(
(
)
)
}
fn
GetOrigin
(
&
self
)
-
>
Fallible
<
USVString
>
{
self
.
check_same_origin_domain
(
)
?
;
Ok
(
UrlHelper
:
:
Origin
(
&
self
.
get_url
(
)
)
)
}
fn
GetHostname
(
&
self
)
-
>
Fallible
<
USVString
>
{
self
.
check_same_origin_domain
(
)
?
;
Ok
(
UrlHelper
:
:
Hostname
(
&
self
.
get_url
(
)
)
)
}
fn
SetHostname
(
&
self
value
:
USVString
)
-
>
ErrorResult
{
self
.
check_same_origin_domain
(
)
?
;
self
.
set_url_component
(
value
UrlHelper
:
:
SetHostname
)
;
Ok
(
(
)
)
}
fn
GetHref
(
&
self
)
-
>
Fallible
<
USVString
>
{
self
.
check_same_origin_domain
(
)
?
;
Ok
(
UrlHelper
:
:
Href
(
&
self
.
get_url
(
)
)
)
}
fn
SetHref
(
&
self
value
:
USVString
)
-
>
ErrorResult
{
let
url
=
match
self
.
window
.
get_url
(
)
.
join
(
&
value
.
0
)
{
Ok
(
url
)
=
>
url
Err
(
e
)
=
>
return
Err
(
Error
:
:
Type
(
format
!
(
"
Couldn
'
t
parse
URL
:
{
}
"
e
)
)
)
}
;
self
.
window
.
load_url
(
url
false
false
None
)
;
Ok
(
(
)
)
}
fn
GetPathname
(
&
self
)
-
>
Fallible
<
USVString
>
{
self
.
check_same_origin_domain
(
)
?
;
Ok
(
UrlHelper
:
:
Pathname
(
&
self
.
get_url
(
)
)
)
}
fn
SetPathname
(
&
self
value
:
USVString
)
-
>
ErrorResult
{
self
.
check_same_origin_domain
(
)
?
;
self
.
set_url_component
(
value
UrlHelper
:
:
SetPathname
)
;
Ok
(
(
)
)
}
fn
GetPort
(
&
self
)
-
>
Fallible
<
USVString
>
{
self
.
check_same_origin_domain
(
)
?
;
Ok
(
UrlHelper
:
:
Port
(
&
self
.
get_url
(
)
)
)
}
fn
SetPort
(
&
self
value
:
USVString
)
-
>
ErrorResult
{
self
.
check_same_origin_domain
(
)
?
;
self
.
set_url_component
(
value
UrlHelper
:
:
SetPort
)
;
Ok
(
(
)
)
}
fn
GetProtocol
(
&
self
)
-
>
Fallible
<
USVString
>
{
self
.
check_same_origin_domain
(
)
?
;
Ok
(
UrlHelper
:
:
Protocol
(
&
self
.
get_url
(
)
)
)
}
fn
SetProtocol
(
&
self
value
:
USVString
)
-
>
ErrorResult
{
self
.
check_same_origin_domain
(
)
?
;
self
.
set_url_component
(
value
UrlHelper
:
:
SetProtocol
)
;
Ok
(
(
)
)
}
fn
Stringifier
(
&
self
)
-
>
Fallible
<
DOMString
>
{
Ok
(
DOMString
:
:
from
(
self
.
GetHref
(
)
?
.
0
)
)
}
fn
GetSearch
(
&
self
)
-
>
Fallible
<
USVString
>
{
self
.
check_same_origin_domain
(
)
?
;
Ok
(
UrlHelper
:
:
Search
(
&
self
.
get_url
(
)
)
)
}
fn
SetSearch
(
&
self
value
:
USVString
)
-
>
ErrorResult
{
self
.
check_same_origin_domain
(
)
?
;
self
.
set_url_component
(
value
UrlHelper
:
:
SetSearch
)
;
Ok
(
(
)
)
}
}
