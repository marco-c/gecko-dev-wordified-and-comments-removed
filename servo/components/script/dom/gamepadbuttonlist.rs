use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
GamepadButtonListBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
GamepadButtonListBinding
:
:
GamepadButtonListMethods
;
use
dom
:
:
bindings
:
:
js
:
:
{
JS
Root
RootedReference
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
Reflector
reflect_dom_object
}
;
use
dom
:
:
gamepadbutton
:
:
GamepadButton
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom_struct
:
:
dom_struct
;
use
webvr_traits
:
:
WebVRGamepadButton
;
#
[
dom_struct
]
pub
struct
GamepadButtonList
{
reflector_
:
Reflector
list
:
Vec
<
JS
<
GamepadButton
>
>
}
impl
GamepadButtonList
{
#
[
allow
(
unrooted_must_root
)
]
fn
new_inherited
(
list
:
&
[
&
GamepadButton
]
)
-
>
GamepadButtonList
{
GamepadButtonList
{
reflector_
:
Reflector
:
:
new
(
)
list
:
list
.
iter
(
)
.
map
(
|
button
|
JS
:
:
from_ref
(
*
button
)
)
.
collect
(
)
}
}
pub
fn
new_from_vr
(
global
:
&
GlobalScope
buttons
:
&
[
WebVRGamepadButton
]
)
-
>
Root
<
GamepadButtonList
>
{
rooted_vec
!
(
let
list
<
-
buttons
.
iter
(
)
.
map
(
|
btn
|
GamepadButton
:
:
new
(
&
global
btn
.
pressed
btn
.
touched
)
)
)
;
reflect_dom_object
(
box
GamepadButtonList
:
:
new_inherited
(
list
.
r
(
)
)
global
GamepadButtonListBinding
:
:
Wrap
)
}
pub
fn
sync_from_vr
(
&
self
vr_buttons
:
&
[
WebVRGamepadButton
]
)
{
let
mut
index
=
0
;
for
btn
in
vr_buttons
{
self
.
list
.
get
(
index
)
.
as_ref
(
)
.
unwrap
(
)
.
update
(
btn
.
pressed
btn
.
touched
)
;
index
+
=
1
;
}
}
}
impl
GamepadButtonListMethods
for
GamepadButtonList
{
fn
Length
(
&
self
)
-
>
u32
{
self
.
list
.
len
(
)
as
u32
}
fn
Item
(
&
self
index
:
u32
)
-
>
Option
<
Root
<
GamepadButton
>
>
{
self
.
list
.
get
(
index
as
usize
)
.
map
(
|
button
|
Root
:
:
from_ref
(
&
*
*
button
)
)
}
fn
IndexedGetter
(
&
self
index
:
u32
)
-
>
Option
<
Root
<
GamepadButton
>
>
{
self
.
Item
(
index
)
}
}
