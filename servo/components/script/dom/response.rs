use
body
:
:
{
BodyOperations
BodyType
consume_body
consume_body_with_promise
}
;
use
dom
:
:
bindings
:
:
cell
:
:
DomRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
HeadersBinding
:
:
{
HeadersInit
HeadersMethods
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
ResponseBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
ResponseBinding
:
:
{
ResponseMethods
ResponseType
as
DOMResponseType
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
XMLHttpRequestBinding
:
:
BodyInit
;
use
dom
:
:
bindings
:
:
error
:
:
{
Error
Fallible
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
DomObject
Reflector
reflect_dom_object
}
;
use
dom
:
:
bindings
:
:
root
:
:
{
DomRoot
MutNullableDom
}
;
use
dom
:
:
bindings
:
:
str
:
:
{
ByteString
USVString
}
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom
:
:
headers
:
:
{
Headers
Guard
}
;
use
dom
:
:
headers
:
:
{
is_vchar
is_obs_text
}
;
use
dom
:
:
promise
:
:
Promise
;
use
dom
:
:
xmlhttprequest
:
:
Extractable
;
use
dom_struct
:
:
dom_struct
;
use
hyper
:
:
header
:
:
Headers
as
HyperHeaders
;
use
hyper
:
:
status
:
:
StatusCode
;
use
hyper_serde
:
:
Serde
;
use
net_traits
:
:
response
:
:
{
ResponseBody
as
NetTraitsResponseBody
}
;
use
servo_url
:
:
ServoUrl
;
use
std
:
:
cell
:
:
{
Cell
Ref
}
;
use
std
:
:
mem
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
str
:
:
FromStr
;
use
url
:
:
Position
;
#
[
dom_struct
]
pub
struct
Response
{
reflector_
:
Reflector
headers_reflector
:
MutNullableDom
<
Headers
>
mime_type
:
DomRefCell
<
Vec
<
u8
>
>
body_used
:
Cell
<
bool
>
#
[
ignore_malloc_size_of
=
"
Defined
in
hyper
"
]
status
:
DomRefCell
<
Option
<
StatusCode
>
>
raw_status
:
DomRefCell
<
Option
<
(
u16
Vec
<
u8
>
)
>
>
response_type
:
DomRefCell
<
DOMResponseType
>
url
:
DomRefCell
<
Option
<
ServoUrl
>
>
url_list
:
DomRefCell
<
Vec
<
ServoUrl
>
>
body
:
DomRefCell
<
NetTraitsResponseBody
>
#
[
ignore_malloc_size_of
=
"
Rc
"
]
body_promise
:
DomRefCell
<
Option
<
(
Rc
<
Promise
>
BodyType
)
>
>
}
impl
Response
{
pub
fn
new_inherited
(
)
-
>
Response
{
Response
{
reflector_
:
Reflector
:
:
new
(
)
headers_reflector
:
Default
:
:
default
(
)
mime_type
:
DomRefCell
:
:
new
(
"
"
.
to_string
(
)
.
into_bytes
(
)
)
body_used
:
Cell
:
:
new
(
false
)
status
:
DomRefCell
:
:
new
(
Some
(
StatusCode
:
:
Ok
)
)
raw_status
:
DomRefCell
:
:
new
(
Some
(
(
200
b
"
OK
"
.
to_vec
(
)
)
)
)
response_type
:
DomRefCell
:
:
new
(
DOMResponseType
:
:
Default
)
url
:
DomRefCell
:
:
new
(
None
)
url_list
:
DomRefCell
:
:
new
(
vec
!
[
]
)
body
:
DomRefCell
:
:
new
(
NetTraitsResponseBody
:
:
Empty
)
body_promise
:
DomRefCell
:
:
new
(
None
)
}
}
pub
fn
new
(
global
:
&
GlobalScope
)
-
>
DomRoot
<
Response
>
{
reflect_dom_object
(
Box
:
:
new
(
Response
:
:
new_inherited
(
)
)
global
ResponseBinding
:
:
Wrap
)
}
pub
fn
Constructor
(
global
:
&
GlobalScope
body
:
Option
<
BodyInit
>
init
:
&
ResponseBinding
:
:
ResponseInit
)
-
>
Fallible
<
DomRoot
<
Response
>
>
{
if
init
.
status
<
200
|
|
init
.
status
>
599
{
return
Err
(
Error
:
:
Range
(
format
!
(
"
init
'
s
status
member
should
be
in
the
range
200
to
599
inclusive
but
is
{
}
"
init
.
status
)
)
)
;
}
if
!
is_valid_status_text
(
&
init
.
statusText
)
{
return
Err
(
Error
:
:
Type
(
"
init
'
s
statusText
member
does
not
match
the
reason
-
phrase
token
production
"
.
to_string
(
)
)
)
;
}
let
r
=
Response
:
:
new
(
global
)
;
*
r
.
status
.
borrow_mut
(
)
=
Some
(
StatusCode
:
:
from_u16
(
init
.
status
)
)
;
*
r
.
raw_status
.
borrow_mut
(
)
=
Some
(
(
init
.
status
init
.
statusText
.
clone
(
)
.
into
(
)
)
)
;
if
let
Some
(
ref
headers_member
)
=
init
.
headers
{
r
.
Headers
(
)
.
empty_header_list
(
)
;
r
.
Headers
(
)
.
fill
(
Some
(
headers_member
.
clone
(
)
)
)
?
;
}
if
let
Some
(
ref
body
)
=
body
{
if
is_null_body_status
(
init
.
status
)
{
return
Err
(
Error
:
:
Type
(
"
Body
is
non
-
null
but
init
'
s
status
member
is
a
null
body
status
"
.
to_string
(
)
)
)
;
}
;
let
(
extracted_body
content_type
)
=
body
.
extract
(
)
;
*
r
.
body
.
borrow_mut
(
)
=
NetTraitsResponseBody
:
:
Done
(
extracted_body
)
;
if
let
Some
(
content_type_contents
)
=
content_type
{
if
!
r
.
Headers
(
)
.
Has
(
ByteString
:
:
new
(
b
"
Content
-
Type
"
.
to_vec
(
)
)
)
.
unwrap
(
)
{
r
.
Headers
(
)
.
Append
(
ByteString
:
:
new
(
b
"
Content
-
Type
"
.
to_vec
(
)
)
ByteString
:
:
new
(
content_type_contents
.
as_bytes
(
)
.
to_vec
(
)
)
)
?
;
}
}
;
}
*
r
.
mime_type
.
borrow_mut
(
)
=
r
.
Headers
(
)
.
extract_mime_type
(
)
;
Ok
(
r
)
}
pub
fn
Error
(
global
:
&
GlobalScope
)
-
>
DomRoot
<
Response
>
{
let
r
=
Response
:
:
new
(
global
)
;
*
r
.
response_type
.
borrow_mut
(
)
=
DOMResponseType
:
:
Error
;
r
.
Headers
(
)
.
set_guard
(
Guard
:
:
Immutable
)
;
*
r
.
raw_status
.
borrow_mut
(
)
=
Some
(
(
0
b
"
"
.
to_vec
(
)
)
)
;
r
}
pub
fn
Redirect
(
global
:
&
GlobalScope
url
:
USVString
status
:
u16
)
-
>
Fallible
<
DomRoot
<
Response
>
>
{
let
base_url
=
global
.
api_base_url
(
)
;
let
parsed_url
=
base_url
.
join
(
&
url
.
0
)
;
let
url
=
match
parsed_url
{
Ok
(
url
)
=
>
url
Err
(
_
)
=
>
return
Err
(
Error
:
:
Type
(
"
ServoUrl
could
not
be
parsed
"
.
to_string
(
)
)
)
}
;
if
!
is_redirect_status
(
status
)
{
return
Err
(
Error
:
:
Range
(
"
status
is
not
a
redirect
status
"
.
to_string
(
)
)
)
;
}
let
r
=
Response
:
:
new
(
global
)
;
*
r
.
status
.
borrow_mut
(
)
=
Some
(
StatusCode
:
:
from_u16
(
status
)
)
;
*
r
.
raw_status
.
borrow_mut
(
)
=
Some
(
(
status
b
"
"
.
to_vec
(
)
)
)
;
let
url_bytestring
=
ByteString
:
:
from_str
(
url
.
as_str
(
)
)
.
unwrap_or
(
ByteString
:
:
new
(
b
"
"
.
to_vec
(
)
)
)
;
r
.
Headers
(
)
.
Set
(
ByteString
:
:
new
(
b
"
Location
"
.
to_vec
(
)
)
url_bytestring
)
?
;
r
.
Headers
(
)
.
set_guard
(
Guard
:
:
Immutable
)
;
Ok
(
r
)
}
fn
locked
(
&
self
)
-
>
bool
{
false
}
}
impl
BodyOperations
for
Response
{
fn
get_body_used
(
&
self
)
-
>
bool
{
self
.
BodyUsed
(
)
}
fn
set_body_promise
(
&
self
p
:
&
Rc
<
Promise
>
body_type
:
BodyType
)
{
assert
!
(
self
.
body_promise
.
borrow
(
)
.
is_none
(
)
)
;
self
.
body_used
.
set
(
true
)
;
*
self
.
body_promise
.
borrow_mut
(
)
=
Some
(
(
p
.
clone
(
)
body_type
)
)
;
}
fn
is_locked
(
&
self
)
-
>
bool
{
self
.
locked
(
)
}
fn
take_body
(
&
self
)
-
>
Option
<
Vec
<
u8
>
>
{
let
body
=
mem
:
:
replace
(
&
mut
*
self
.
body
.
borrow_mut
(
)
NetTraitsResponseBody
:
:
Empty
)
;
match
body
{
NetTraitsResponseBody
:
:
Done
(
bytes
)
=
>
{
Some
(
bytes
)
}
body
=
>
{
mem
:
:
replace
(
&
mut
*
self
.
body
.
borrow_mut
(
)
body
)
;
None
}
}
}
fn
get_mime_type
(
&
self
)
-
>
Ref
<
Vec
<
u8
>
>
{
self
.
mime_type
.
borrow
(
)
}
}
fn
is_redirect_status
(
status
:
u16
)
-
>
bool
{
status
=
=
301
|
|
status
=
=
302
|
|
status
=
=
303
|
|
status
=
=
307
|
|
status
=
=
308
}
fn
is_valid_status_text
(
status_text
:
&
ByteString
)
-
>
bool
{
for
byte
in
status_text
.
iter
(
)
{
if
!
(
*
byte
=
=
b
'
\
t
'
|
|
*
byte
=
=
b
'
'
|
|
is_vchar
(
*
byte
)
|
|
is_obs_text
(
*
byte
)
)
{
return
false
;
}
}
true
}
fn
is_null_body_status
(
status
:
u16
)
-
>
bool
{
status
=
=
101
|
|
status
=
=
204
|
|
status
=
=
205
|
|
status
=
=
304
}
impl
ResponseMethods
for
Response
{
fn
Type
(
&
self
)
-
>
DOMResponseType
{
*
self
.
response_type
.
borrow
(
)
}
fn
Url
(
&
self
)
-
>
USVString
{
USVString
(
String
:
:
from
(
(
*
self
.
url
.
borrow
(
)
)
.
as_ref
(
)
.
map
(
|
u
|
serialize_without_fragment
(
u
)
)
.
unwrap_or
(
"
"
)
)
)
}
fn
Redirected
(
&
self
)
-
>
bool
{
let
url_list_len
=
self
.
url_list
.
borrow
(
)
.
len
(
)
;
url_list_len
>
1
}
fn
Status
(
&
self
)
-
>
u16
{
match
*
self
.
raw_status
.
borrow
(
)
{
Some
(
(
s
_
)
)
=
>
s
None
=
>
0
}
}
fn
Ok
(
&
self
)
-
>
bool
{
match
*
self
.
status
.
borrow
(
)
{
Some
(
s
)
=
>
{
let
status_num
=
s
.
to_u16
(
)
;
return
status_num
>
=
200
&
&
status_num
<
=
299
;
}
None
=
>
false
}
}
fn
StatusText
(
&
self
)
-
>
ByteString
{
match
*
self
.
raw_status
.
borrow
(
)
{
Some
(
(
_
ref
st
)
)
=
>
ByteString
:
:
new
(
st
.
clone
(
)
)
None
=
>
ByteString
:
:
new
(
b
"
OK
"
.
to_vec
(
)
)
}
}
fn
Headers
(
&
self
)
-
>
DomRoot
<
Headers
>
{
self
.
headers_reflector
.
or_init
(
|
|
Headers
:
:
for_response
(
&
self
.
global
(
)
)
)
}
fn
Clone
(
&
self
)
-
>
Fallible
<
DomRoot
<
Response
>
>
{
if
self
.
is_locked
(
)
|
|
self
.
body_used
.
get
(
)
{
return
Err
(
Error
:
:
Type
(
"
cannot
clone
a
disturbed
response
"
.
to_string
(
)
)
)
;
}
let
new_response
=
Response
:
:
new
(
&
self
.
global
(
)
)
;
new_response
.
Headers
(
)
.
set_guard
(
self
.
Headers
(
)
.
get_guard
(
)
)
;
new_response
.
Headers
(
)
.
fill
(
Some
(
HeadersInit
:
:
Headers
(
self
.
Headers
(
)
)
)
)
?
;
*
new_response
.
response_type
.
borrow_mut
(
)
=
self
.
response_type
.
borrow
(
)
.
clone
(
)
;
*
new_response
.
status
.
borrow_mut
(
)
=
self
.
status
.
borrow
(
)
.
clone
(
)
;
*
new_response
.
raw_status
.
borrow_mut
(
)
=
self
.
raw_status
.
borrow
(
)
.
clone
(
)
;
*
new_response
.
url
.
borrow_mut
(
)
=
self
.
url
.
borrow
(
)
.
clone
(
)
;
*
new_response
.
url_list
.
borrow_mut
(
)
=
self
.
url_list
.
borrow
(
)
.
clone
(
)
;
if
*
self
.
body
.
borrow
(
)
!
=
NetTraitsResponseBody
:
:
Empty
{
*
new_response
.
body
.
borrow_mut
(
)
=
self
.
body
.
borrow
(
)
.
clone
(
)
;
}
Ok
(
new_response
)
}
fn
BodyUsed
(
&
self
)
-
>
bool
{
self
.
body_used
.
get
(
)
}
#
[
allow
(
unrooted_must_root
)
]
fn
Text
(
&
self
)
-
>
Rc
<
Promise
>
{
consume_body
(
self
BodyType
:
:
Text
)
}
#
[
allow
(
unrooted_must_root
)
]
fn
Blob
(
&
self
)
-
>
Rc
<
Promise
>
{
consume_body
(
self
BodyType
:
:
Blob
)
}
#
[
allow
(
unrooted_must_root
)
]
fn
FormData
(
&
self
)
-
>
Rc
<
Promise
>
{
consume_body
(
self
BodyType
:
:
FormData
)
}
#
[
allow
(
unrooted_must_root
)
]
fn
Json
(
&
self
)
-
>
Rc
<
Promise
>
{
consume_body
(
self
BodyType
:
:
Json
)
}
}
fn
serialize_without_fragment
(
url
:
&
ServoUrl
)
-
>
&
str
{
&
url
[
.
.
Position
:
:
AfterQuery
]
}
impl
Response
{
pub
fn
set_type
(
&
self
new_response_type
:
DOMResponseType
)
{
*
self
.
response_type
.
borrow_mut
(
)
=
new_response_type
;
}
pub
fn
set_headers
(
&
self
option_hyper_headers
:
Option
<
Serde
<
HyperHeaders
>
>
)
{
self
.
Headers
(
)
.
set_headers
(
match
option_hyper_headers
{
Some
(
hyper_headers
)
=
>
hyper_headers
.
into_inner
(
)
None
=
>
HyperHeaders
:
:
new
(
)
}
)
;
}
pub
fn
set_raw_status
(
&
self
status
:
Option
<
(
u16
Vec
<
u8
>
)
>
)
{
*
self
.
raw_status
.
borrow_mut
(
)
=
status
;
}
pub
fn
set_final_url
(
&
self
final_url
:
ServoUrl
)
{
*
self
.
url
.
borrow_mut
(
)
=
Some
(
final_url
)
;
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
finish
(
&
self
body
:
Vec
<
u8
>
)
{
*
self
.
body
.
borrow_mut
(
)
=
NetTraitsResponseBody
:
:
Done
(
body
)
;
if
let
Some
(
(
p
body_type
)
)
=
self
.
body_promise
.
borrow_mut
(
)
.
take
(
)
{
consume_body_with_promise
(
self
body_type
&
p
)
;
}
}
}
