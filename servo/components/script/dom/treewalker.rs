use
dom
:
:
bindings
:
:
callback
:
:
ExceptionHandling
:
:
Rethrow
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeBinding
:
:
NodeMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeFilterBinding
:
:
NodeFilter
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeFilterBinding
:
:
NodeFilterConstants
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
TreeWalkerBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
TreeWalkerBinding
:
:
TreeWalkerMethods
;
use
dom
:
:
bindings
:
:
error
:
:
{
Error
Fallible
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
Reflector
reflect_dom_object
}
;
use
dom
:
:
bindings
:
:
root
:
:
{
Dom
DomRoot
MutDom
}
;
use
dom
:
:
document
:
:
Document
;
use
dom
:
:
node
:
:
Node
;
use
dom_struct
:
:
dom_struct
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
rc
:
:
Rc
;
#
[
dom_struct
]
pub
struct
TreeWalker
{
reflector_
:
Reflector
root_node
:
Dom
<
Node
>
current_node
:
MutDom
<
Node
>
what_to_show
:
u32
#
[
ignore_malloc_size_of
=
"
function
pointers
and
Rc
<
T
>
are
hard
"
]
filter
:
Filter
active
:
Cell
<
bool
>
}
impl
TreeWalker
{
fn
new_inherited
(
root_node
:
&
Node
what_to_show
:
u32
filter
:
Filter
)
-
>
TreeWalker
{
TreeWalker
{
reflector_
:
Reflector
:
:
new
(
)
root_node
:
Dom
:
:
from_ref
(
root_node
)
current_node
:
MutDom
:
:
new
(
root_node
)
what_to_show
:
what_to_show
filter
:
filter
active
:
Cell
:
:
new
(
false
)
}
}
pub
fn
new_with_filter
(
document
:
&
Document
root_node
:
&
Node
what_to_show
:
u32
filter
:
Filter
)
-
>
DomRoot
<
TreeWalker
>
{
reflect_dom_object
(
Box
:
:
new
(
TreeWalker
:
:
new_inherited
(
root_node
what_to_show
filter
)
)
document
.
window
(
)
TreeWalkerBinding
:
:
Wrap
)
}
pub
fn
new
(
document
:
&
Document
root_node
:
&
Node
what_to_show
:
u32
node_filter
:
Option
<
Rc
<
NodeFilter
>
>
)
-
>
DomRoot
<
TreeWalker
>
{
let
filter
=
match
node_filter
{
None
=
>
Filter
:
:
None
Some
(
jsfilter
)
=
>
Filter
:
:
Dom
(
jsfilter
)
}
;
TreeWalker
:
:
new_with_filter
(
document
root_node
what_to_show
filter
)
}
}
impl
TreeWalkerMethods
for
TreeWalker
{
fn
Root
(
&
self
)
-
>
DomRoot
<
Node
>
{
DomRoot
:
:
from_ref
(
&
*
self
.
root_node
)
}
fn
WhatToShow
(
&
self
)
-
>
u32
{
self
.
what_to_show
}
fn
GetFilter
(
&
self
)
-
>
Option
<
Rc
<
NodeFilter
>
>
{
match
self
.
filter
{
Filter
:
:
None
=
>
None
Filter
:
:
Dom
(
ref
nf
)
=
>
Some
(
nf
.
clone
(
)
)
Filter
:
:
Native
(
_
)
=
>
panic
!
(
"
Cannot
convert
native
node
filter
to
DOM
NodeFilter
"
)
}
}
fn
CurrentNode
(
&
self
)
-
>
DomRoot
<
Node
>
{
self
.
current_node
.
get
(
)
}
fn
SetCurrentNode
(
&
self
node
:
&
Node
)
{
self
.
current_node
.
set
(
node
)
;
}
fn
ParentNode
(
&
self
)
-
>
Fallible
<
Option
<
DomRoot
<
Node
>
>
>
{
let
mut
node
=
self
.
current_node
.
get
(
)
;
while
!
self
.
is_root_node
(
&
node
)
{
match
node
.
GetParentNode
(
)
{
Some
(
n
)
=
>
{
node
=
n
;
if
NodeFilterConstants
:
:
FILTER_ACCEPT
=
=
self
.
accept_node
(
&
node
)
?
{
self
.
current_node
.
set
(
&
node
)
;
return
Ok
(
Some
(
node
)
)
}
}
None
=
>
break
}
}
Ok
(
None
)
}
fn
FirstChild
(
&
self
)
-
>
Fallible
<
Option
<
DomRoot
<
Node
>
>
>
{
self
.
traverse_children
(
|
node
|
node
.
GetFirstChild
(
)
|
node
|
node
.
GetNextSibling
(
)
)
}
fn
LastChild
(
&
self
)
-
>
Fallible
<
Option
<
DomRoot
<
Node
>
>
>
{
self
.
traverse_children
(
|
node
|
node
.
GetLastChild
(
)
|
node
|
node
.
GetPreviousSibling
(
)
)
}
fn
PreviousSibling
(
&
self
)
-
>
Fallible
<
Option
<
DomRoot
<
Node
>
>
>
{
self
.
traverse_siblings
(
|
node
|
node
.
GetLastChild
(
)
|
node
|
node
.
GetPreviousSibling
(
)
)
}
fn
NextSibling
(
&
self
)
-
>
Fallible
<
Option
<
DomRoot
<
Node
>
>
>
{
self
.
traverse_siblings
(
|
node
|
node
.
GetFirstChild
(
)
|
node
|
node
.
GetNextSibling
(
)
)
}
fn
PreviousNode
(
&
self
)
-
>
Fallible
<
Option
<
DomRoot
<
Node
>
>
>
{
let
mut
node
=
self
.
current_node
.
get
(
)
;
while
!
self
.
is_root_node
(
&
node
)
{
let
mut
sibling_op
=
node
.
GetPreviousSibling
(
)
;
while
sibling_op
.
is_some
(
)
{
node
=
sibling_op
.
unwrap
(
)
;
loop
{
let
result
=
self
.
accept_node
(
&
node
)
?
;
match
result
{
NodeFilterConstants
:
:
FILTER_REJECT
=
>
break
_
if
node
.
GetFirstChild
(
)
.
is_some
(
)
=
>
node
=
node
.
GetLastChild
(
)
.
unwrap
(
)
NodeFilterConstants
:
:
FILTER_ACCEPT
=
>
{
self
.
current_node
.
set
(
&
node
)
;
return
Ok
(
Some
(
node
)
)
}
_
=
>
break
}
}
sibling_op
=
node
.
GetPreviousSibling
(
)
}
if
self
.
is_root_node
(
&
node
)
|
|
node
.
GetParentNode
(
)
.
is_none
(
)
{
return
Ok
(
None
)
}
match
node
.
GetParentNode
(
)
{
None
=
>
return
Ok
(
None
)
Some
(
n
)
=
>
node
=
n
}
if
NodeFilterConstants
:
:
FILTER_ACCEPT
=
=
self
.
accept_node
(
&
node
)
?
{
self
.
current_node
.
set
(
&
node
)
;
return
Ok
(
Some
(
node
)
)
}
}
Ok
(
None
)
}
fn
NextNode
(
&
self
)
-
>
Fallible
<
Option
<
DomRoot
<
Node
>
>
>
{
let
mut
node
=
self
.
current_node
.
get
(
)
;
let
mut
result
=
NodeFilterConstants
:
:
FILTER_ACCEPT
;
loop
{
loop
{
if
NodeFilterConstants
:
:
FILTER_REJECT
=
=
result
{
break
;
}
match
node
.
GetFirstChild
(
)
{
None
=
>
break
Some
(
child
)
=
>
{
node
=
child
;
result
=
self
.
accept_node
(
&
node
)
?
;
if
NodeFilterConstants
:
:
FILTER_ACCEPT
=
=
result
{
self
.
current_node
.
set
(
&
node
)
;
return
Ok
(
Some
(
node
)
)
}
}
}
}
match
self
.
first_following_node_not_following_root
(
&
node
)
{
None
=
>
return
Ok
(
None
)
Some
(
n
)
=
>
{
node
=
n
;
result
=
self
.
accept_node
(
&
node
)
?
;
if
NodeFilterConstants
:
:
FILTER_ACCEPT
=
=
result
{
self
.
current_node
.
set
(
&
node
)
;
return
Ok
(
Some
(
node
)
)
}
}
}
}
}
}
impl
TreeWalker
{
fn
traverse_children
<
F
G
>
(
&
self
next_child
:
F
next_sibling
:
G
)
-
>
Fallible
<
Option
<
DomRoot
<
Node
>
>
>
where
F
:
Fn
(
&
Node
)
-
>
Option
<
DomRoot
<
Node
>
>
G
:
Fn
(
&
Node
)
-
>
Option
<
DomRoot
<
Node
>
>
{
let
cur
=
self
.
current_node
.
get
(
)
;
let
mut
node
=
match
next_child
(
&
cur
)
{
Some
(
node
)
=
>
node
None
=
>
return
Ok
(
None
)
}
;
'
main
:
loop
{
let
result
=
self
.
accept_node
(
&
node
)
?
;
match
result
{
NodeFilterConstants
:
:
FILTER_ACCEPT
=
>
{
self
.
current_node
.
set
(
&
node
)
;
return
Ok
(
Some
(
DomRoot
:
:
from_ref
(
&
node
)
)
)
}
NodeFilterConstants
:
:
FILTER_SKIP
=
>
{
if
let
Some
(
child
)
=
next_child
(
&
node
)
{
node
=
child
;
continue
'
main
}
}
_
=
>
{
}
}
loop
{
match
next_sibling
(
&
node
)
{
Some
(
sibling
)
=
>
{
node
=
sibling
;
continue
'
main
}
None
=
>
{
match
node
.
GetParentNode
(
)
{
None
=
>
return
Ok
(
None
)
Some
(
ref
parent
)
if
self
.
is_root_node
(
&
parent
)
|
|
self
.
is_current_node
(
&
parent
)
=
>
return
Ok
(
None
)
Some
(
parent
)
=
>
node
=
parent
}
}
}
}
}
}
fn
traverse_siblings
<
F
G
>
(
&
self
next_child
:
F
next_sibling
:
G
)
-
>
Fallible
<
Option
<
DomRoot
<
Node
>
>
>
where
F
:
Fn
(
&
Node
)
-
>
Option
<
DomRoot
<
Node
>
>
G
:
Fn
(
&
Node
)
-
>
Option
<
DomRoot
<
Node
>
>
{
let
mut
node
=
self
.
current_node
.
get
(
)
;
if
self
.
is_root_node
(
&
node
)
{
return
Ok
(
None
)
}
loop
{
let
mut
sibling_op
=
next_sibling
(
&
node
)
;
while
sibling_op
.
is_some
(
)
{
node
=
sibling_op
.
unwrap
(
)
;
let
result
=
self
.
accept_node
(
&
node
)
?
;
if
NodeFilterConstants
:
:
FILTER_ACCEPT
=
=
result
{
self
.
current_node
.
set
(
&
node
)
;
return
Ok
(
Some
(
node
)
)
}
sibling_op
=
next_child
(
&
node
)
;
match
(
result
&
sibling_op
)
{
(
NodeFilterConstants
:
:
FILTER_REJECT
_
)
|
(
_
&
None
)
=
>
sibling_op
=
next_sibling
(
&
node
)
_
=
>
{
}
}
}
match
node
.
GetParentNode
(
)
{
None
=
>
return
Ok
(
None
)
Some
(
ref
n
)
if
self
.
is_root_node
(
&
n
)
=
>
return
Ok
(
None
)
Some
(
n
)
=
>
{
node
=
n
;
if
NodeFilterConstants
:
:
FILTER_ACCEPT
=
=
self
.
accept_node
(
&
node
)
?
{
return
Ok
(
None
)
}
}
}
}
}
fn
first_following_node_not_following_root
(
&
self
node
:
&
Node
)
-
>
Option
<
DomRoot
<
Node
>
>
{
match
node
.
GetNextSibling
(
)
{
None
=
>
{
let
mut
candidate
=
DomRoot
:
:
from_ref
(
node
)
;
while
!
self
.
is_root_node
(
&
candidate
)
&
&
candidate
.
GetNextSibling
(
)
.
is_none
(
)
{
candidate
=
candidate
.
GetParentNode
(
)
?
;
}
if
self
.
is_root_node
(
&
candidate
)
{
None
}
else
{
candidate
.
GetNextSibling
(
)
}
}
it
=
>
it
}
}
fn
accept_node
(
&
self
node
:
&
Node
)
-
>
Fallible
<
u16
>
{
if
self
.
active
.
get
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
let
n
=
node
.
NodeType
(
)
-
1
;
if
(
self
.
what_to_show
&
(
1
<
<
n
)
)
=
=
0
{
return
Ok
(
NodeFilterConstants
:
:
FILTER_SKIP
)
}
match
self
.
filter
{
Filter
:
:
None
=
>
Ok
(
NodeFilterConstants
:
:
FILTER_ACCEPT
)
Filter
:
:
Native
(
f
)
=
>
Ok
(
(
f
)
(
node
)
)
Filter
:
:
Dom
(
ref
callback
)
=
>
{
self
.
active
.
set
(
true
)
;
let
result
=
callback
.
AcceptNode_
(
self
node
Rethrow
)
;
self
.
active
.
set
(
false
)
;
result
}
}
}
fn
is_root_node
(
&
self
node
:
&
Node
)
-
>
bool
{
Dom
:
:
from_ref
(
node
)
=
=
self
.
root_node
}
fn
is_current_node
(
&
self
node
:
&
Node
)
-
>
bool
{
node
=
=
&
*
self
.
current_node
.
get
(
)
}
}
impl
<
'
a
>
Iterator
for
&
'
a
TreeWalker
{
type
Item
=
DomRoot
<
Node
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
DomRoot
<
Node
>
>
{
match
self
.
NextNode
(
)
{
Ok
(
node
)
=
>
node
Err
(
_
)
=
>
unreachable
!
(
)
}
}
}
#
[
derive
(
JSTraceable
)
]
pub
enum
Filter
{
None
Native
(
fn
(
node
:
&
Node
)
-
>
u16
)
Dom
(
Rc
<
NodeFilter
>
)
}
