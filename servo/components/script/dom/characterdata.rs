use
dom
:
:
bindings
:
:
cell
:
:
DOMRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
CharacterDataBinding
:
:
CharacterDataMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
InheritTypes
:
:
{
CharacterDataDerived
ElementCast
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
InheritTypes
:
:
NodeCast
;
use
dom
:
:
bindings
:
:
codegen
:
:
UnionTypes
:
:
NodeOrString
;
use
dom
:
:
bindings
:
:
error
:
:
{
Fallible
ErrorResult
}
;
use
dom
:
:
bindings
:
:
error
:
:
Error
:
:
IndexSize
;
use
dom
:
:
bindings
:
:
js
:
:
{
JSRef
LayoutJS
Temporary
}
;
use
dom
:
:
document
:
:
Document
;
use
dom
:
:
element
:
:
Element
;
use
dom
:
:
eventtarget
:
:
{
EventTarget
EventTargetTypeId
}
;
use
dom
:
:
node
:
:
{
Node
NodeHelpers
NodeTypeId
}
;
use
util
:
:
str
:
:
DOMString
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
cell
:
:
Ref
;
use
std
:
:
cmp
;
#
[
dom_struct
]
pub
struct
CharacterData
{
node
:
Node
data
:
DOMRefCell
<
DOMString
>
}
impl
CharacterDataDerived
for
EventTarget
{
fn
is_characterdata
(
&
self
)
-
>
bool
{
match
*
self
.
type_id
(
)
{
EventTargetTypeId
:
:
Node
(
NodeTypeId
:
:
Text
)
|
EventTargetTypeId
:
:
Node
(
NodeTypeId
:
:
Comment
)
|
EventTargetTypeId
:
:
Node
(
NodeTypeId
:
:
ProcessingInstruction
)
=
>
true
_
=
>
false
}
}
}
impl
CharacterData
{
pub
fn
new_inherited
(
id
:
NodeTypeId
data
:
DOMString
document
:
JSRef
<
Document
>
)
-
>
CharacterData
{
CharacterData
{
node
:
Node
:
:
new_inherited
(
id
document
)
data
:
DOMRefCell
:
:
new
(
data
)
}
}
}
impl
<
'
a
>
CharacterDataMethods
for
JSRef
<
'
a
CharacterData
>
{
fn
Data
(
self
)
-
>
DOMString
{
let
data
=
self
.
data
.
borrow
(
)
;
data
.
clone
(
)
}
fn
SetData
(
self
data
:
DOMString
)
{
*
self
.
data
.
borrow_mut
(
)
=
data
;
}
fn
Length
(
self
)
-
>
u32
{
let
data
=
self
.
data
.
borrow
(
)
;
data
.
chars
(
)
.
count
(
)
as
u32
}
fn
SubstringData
(
self
offset
:
u32
count
:
u32
)
-
>
Fallible
<
DOMString
>
{
let
data
=
self
.
data
.
borrow
(
)
;
let
len
=
data
.
chars
(
)
.
count
(
)
;
if
offset
as
usize
>
len
{
return
Err
(
IndexSize
)
;
}
let
end
=
cmp
:
:
min
(
(
offset
+
count
)
as
usize
len
)
;
Ok
(
data
.
slice_chars
(
offset
as
usize
end
)
.
to_owned
(
)
)
}
fn
AppendData
(
self
data
:
DOMString
)
{
self
.
data
.
borrow_mut
(
)
.
push_str
(
&
data
)
;
}
fn
InsertData
(
self
offset
:
u32
arg
:
DOMString
)
-
>
ErrorResult
{
self
.
ReplaceData
(
offset
0
arg
)
}
fn
DeleteData
(
self
offset
:
u32
count
:
u32
)
-
>
ErrorResult
{
self
.
ReplaceData
(
offset
count
"
"
.
to_owned
(
)
)
}
fn
ReplaceData
(
self
offset
:
u32
count
:
u32
arg
:
DOMString
)
-
>
ErrorResult
{
let
length
=
self
.
data
.
borrow
(
)
.
chars
(
)
.
count
(
)
as
u32
;
if
offset
>
length
{
return
Err
(
IndexSize
)
;
}
let
count
=
if
offset
+
count
>
length
{
length
-
offset
}
else
{
count
}
;
let
mut
data
=
self
.
data
.
borrow
(
)
.
slice_chars
(
0
offset
as
usize
)
.
to_owned
(
)
;
data
.
push_str
(
arg
.
as_slice
(
)
)
;
data
.
push_str
(
&
self
.
data
.
borrow
(
)
.
slice_chars
(
(
offset
+
count
)
as
usize
length
as
usize
)
)
;
*
self
.
data
.
borrow_mut
(
)
=
data
;
Ok
(
(
)
)
}
fn
Before
(
self
nodes
:
Vec
<
NodeOrString
>
)
-
>
ErrorResult
{
NodeCast
:
:
from_ref
(
self
)
.
before
(
nodes
)
}
fn
After
(
self
nodes
:
Vec
<
NodeOrString
>
)
-
>
ErrorResult
{
NodeCast
:
:
from_ref
(
self
)
.
after
(
nodes
)
}
fn
ReplaceWith
(
self
nodes
:
Vec
<
NodeOrString
>
)
-
>
ErrorResult
{
NodeCast
:
:
from_ref
(
self
)
.
replace_with
(
nodes
)
}
fn
Remove
(
self
)
{
let
node
:
JSRef
<
Node
>
=
NodeCast
:
:
from_ref
(
self
)
;
node
.
remove_self
(
)
;
}
fn
GetPreviousElementSibling
(
self
)
-
>
Option
<
Temporary
<
Element
>
>
{
NodeCast
:
:
from_ref
(
self
)
.
preceding_siblings
(
)
.
filter_map
(
ElementCast
:
:
to_temporary
)
.
next
(
)
}
fn
GetNextElementSibling
(
self
)
-
>
Option
<
Temporary
<
Element
>
>
{
NodeCast
:
:
from_ref
(
self
)
.
following_siblings
(
)
.
filter_map
(
ElementCast
:
:
to_temporary
)
.
next
(
)
}
}
pub
trait
CharacterDataHelpers
<
'
a
>
{
fn
data
(
self
)
-
>
Ref
<
'
a
DOMString
>
;
}
impl
<
'
a
>
CharacterDataHelpers
<
'
a
>
for
JSRef
<
'
a
CharacterData
>
{
#
[
inline
]
fn
data
(
self
)
-
>
Ref
<
'
a
DOMString
>
{
self
.
extended_deref
(
)
.
data
.
borrow
(
)
}
}
#
[
allow
(
unsafe_code
)
]
pub
trait
LayoutCharacterDataHelpers
{
unsafe
fn
data_for_layout
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
str
;
}
#
[
allow
(
unsafe_code
)
]
impl
LayoutCharacterDataHelpers
for
LayoutJS
<
CharacterData
>
{
#
[
inline
]
unsafe
fn
data_for_layout
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
str
{
&
(
*
self
.
unsafe_get
(
)
)
.
data
.
borrow_for_layout
(
)
}
}
