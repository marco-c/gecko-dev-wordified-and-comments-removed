use
dom
:
:
bindings
:
:
cell
:
:
DOMRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
CharacterDataBinding
:
:
CharacterDataMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
InheritTypes
:
:
NodeCast
;
use
dom
:
:
bindings
:
:
codegen
:
:
InheritTypes
:
:
{
CharacterDataDerived
ElementCast
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
UnionTypes
:
:
NodeOrString
;
use
dom
:
:
bindings
:
:
error
:
:
Error
:
:
IndexSize
;
use
dom
:
:
bindings
:
:
error
:
:
{
Fallible
ErrorResult
}
;
use
dom
:
:
bindings
:
:
js
:
:
{
LayoutJS
Root
}
;
use
dom
:
:
document
:
:
Document
;
use
dom
:
:
element
:
:
Element
;
use
dom
:
:
eventtarget
:
:
{
EventTarget
EventTargetTypeId
}
;
use
dom
:
:
node
:
:
{
Node
NodeTypeId
}
;
use
util
:
:
str
:
:
DOMString
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
cell
:
:
Ref
;
#
[
dom_struct
]
pub
struct
CharacterData
{
node
:
Node
data
:
DOMRefCell
<
DOMString
>
}
impl
CharacterDataDerived
for
EventTarget
{
fn
is_characterdata
(
&
self
)
-
>
bool
{
match
*
self
.
type_id
(
)
{
EventTargetTypeId
:
:
Node
(
NodeTypeId
:
:
CharacterData
(
_
)
)
=
>
true
_
=
>
false
}
}
}
impl
CharacterData
{
pub
fn
new_inherited
(
id
:
CharacterDataTypeId
data
:
DOMString
document
:
&
Document
)
-
>
CharacterData
{
CharacterData
{
node
:
Node
:
:
new_inherited
(
NodeTypeId
:
:
CharacterData
(
id
)
document
)
data
:
DOMRefCell
:
:
new
(
data
)
}
}
}
impl
CharacterDataMethods
for
CharacterData
{
fn
Data
(
&
self
)
-
>
DOMString
{
self
.
data
.
borrow
(
)
.
clone
(
)
}
fn
SetData
(
&
self
data
:
DOMString
)
{
*
self
.
data
.
borrow_mut
(
)
=
data
;
}
fn
Length
(
&
self
)
-
>
u32
{
self
.
data
.
borrow
(
)
.
chars
(
)
.
map
(
|
c
|
c
.
len_utf16
(
)
)
.
sum
:
:
<
usize
>
(
)
as
u32
}
fn
SubstringData
(
&
self
offset
:
u32
count
:
u32
)
-
>
Fallible
<
DOMString
>
{
let
data
=
self
.
data
.
borrow
(
)
;
let
data_from_offset
=
match
find_utf16_code_unit_offset
(
&
data
offset
)
{
Some
(
offset_bytes
)
=
>
&
data
[
offset_bytes
.
.
]
None
=
>
return
Err
(
IndexSize
)
}
;
let
substring
=
match
find_utf16_code_unit_offset
(
data_from_offset
count
)
{
None
=
>
data_from_offset
Some
(
count_bytes
)
=
>
&
data_from_offset
[
.
.
count_bytes
]
}
;
Ok
(
substring
.
to_owned
(
)
)
}
fn
AppendData
(
&
self
data
:
DOMString
)
{
self
.
append_data
(
&
*
data
)
;
}
fn
InsertData
(
&
self
offset
:
u32
arg
:
DOMString
)
-
>
ErrorResult
{
self
.
ReplaceData
(
offset
0
arg
)
}
fn
DeleteData
(
&
self
offset
:
u32
count
:
u32
)
-
>
ErrorResult
{
self
.
ReplaceData
(
offset
count
"
"
.
to_owned
(
)
)
}
fn
ReplaceData
(
&
self
offset
:
u32
count
:
u32
arg
:
DOMString
)
-
>
ErrorResult
{
let
new_data
=
{
let
data
=
self
.
data
.
borrow
(
)
;
let
(
prefix
data_from_offset
)
=
match
find_utf16_code_unit_offset
(
&
data
offset
)
{
Some
(
offset_bytes
)
=
>
data
.
split_at
(
offset_bytes
)
None
=
>
return
Err
(
IndexSize
)
}
;
let
suffix
=
match
find_utf16_code_unit_offset
(
data_from_offset
count
)
{
None
=
>
"
"
Some
(
count_bytes
)
=
>
&
data_from_offset
[
count_bytes
.
.
]
}
;
let
mut
new_data
=
String
:
:
with_capacity
(
prefix
.
len
(
)
+
arg
.
len
(
)
+
suffix
.
len
(
)
)
;
new_data
.
push_str
(
prefix
)
;
new_data
.
push_str
(
&
arg
)
;
new_data
.
push_str
(
suffix
)
;
new_data
}
;
*
self
.
data
.
borrow_mut
(
)
=
new_data
;
Ok
(
(
)
)
}
fn
Before
(
&
self
nodes
:
Vec
<
NodeOrString
>
)
-
>
ErrorResult
{
NodeCast
:
:
from_ref
(
self
)
.
before
(
nodes
)
}
fn
After
(
&
self
nodes
:
Vec
<
NodeOrString
>
)
-
>
ErrorResult
{
NodeCast
:
:
from_ref
(
self
)
.
after
(
nodes
)
}
fn
ReplaceWith
(
&
self
nodes
:
Vec
<
NodeOrString
>
)
-
>
ErrorResult
{
NodeCast
:
:
from_ref
(
self
)
.
replace_with
(
nodes
)
}
fn
Remove
(
&
self
)
{
let
node
=
NodeCast
:
:
from_ref
(
self
)
;
node
.
remove_self
(
)
;
}
fn
GetPreviousElementSibling
(
&
self
)
-
>
Option
<
Root
<
Element
>
>
{
NodeCast
:
:
from_ref
(
self
)
.
preceding_siblings
(
)
.
filter_map
(
ElementCast
:
:
to_root
)
.
next
(
)
}
fn
GetNextElementSibling
(
&
self
)
-
>
Option
<
Root
<
Element
>
>
{
NodeCast
:
:
from_ref
(
self
)
.
following_siblings
(
)
.
filter_map
(
ElementCast
:
:
to_root
)
.
next
(
)
}
}
#
[
derive
(
JSTraceable
Copy
Clone
PartialEq
Debug
HeapSizeOf
)
]
pub
enum
CharacterDataTypeId
{
Comment
Text
ProcessingInstruction
}
impl
CharacterData
{
#
[
inline
]
pub
fn
data
(
&
self
)
-
>
Ref
<
DOMString
>
{
self
.
data
.
borrow
(
)
}
#
[
inline
]
pub
fn
append_data
(
&
self
data
:
&
str
)
{
self
.
data
.
borrow_mut
(
)
.
push_str
(
data
)
}
}
#
[
allow
(
unsafe_code
)
]
pub
trait
LayoutCharacterDataHelpers
{
unsafe
fn
data_for_layout
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
str
;
}
#
[
allow
(
unsafe_code
)
]
impl
LayoutCharacterDataHelpers
for
LayoutJS
<
CharacterData
>
{
#
[
inline
]
unsafe
fn
data_for_layout
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
str
{
&
(
*
self
.
unsafe_get
(
)
)
.
data
.
borrow_for_layout
(
)
}
}
fn
find_utf16_code_unit_offset
(
s
:
&
str
offset
:
u32
)
-
>
Option
<
usize
>
{
let
mut
code_units
=
0
;
for
(
i
c
)
in
s
.
char_indices
(
)
{
if
code_units
=
=
offset
{
return
Some
(
i
)
}
code_units
+
=
1
;
if
c
>
'
\
u
{
FFFF
}
'
{
if
code_units
=
=
offset
{
panic
!
(
"
\
n
\
n
\
Would
split
a
surrogate
pair
in
CharacterData
API
.
\
n
\
If
you
see
this
in
real
content
please
comment
with
the
URL
\
n
\
on
https
:
/
/
github
.
com
/
servo
/
servo
/
issues
/
6873
\
n
\
\
n
"
)
;
}
code_units
+
=
1
;
}
}
if
code_units
=
=
offset
{
Some
(
s
.
len
(
)
)
}
else
{
None
}
}
