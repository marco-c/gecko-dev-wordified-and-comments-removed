use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
BluetoothRemoteGATTServerBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
BluetoothRemoteGATTServerBinding
:
:
BluetoothRemoteGATTServerMethods
;
use
dom
:
:
bindings
:
:
global
:
:
GlobalRef
;
use
dom
:
:
bindings
:
:
js
:
:
{
JS
MutHeap
Root
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
Reflector
reflect_dom_object
}
;
use
dom
:
:
bluetoothdevice
:
:
BluetoothDevice
;
use
dom
:
:
bluetoothremotegattservice
:
:
BluetoothRemoteGATTService
;
use
std
:
:
cell
:
:
Cell
;
#
[
dom_struct
]
pub
struct
BluetoothRemoteGATTServer
{
reflector_
:
Reflector
device
:
MutHeap
<
JS
<
BluetoothDevice
>
>
connected
:
Cell
<
bool
>
}
impl
BluetoothRemoteGATTServer
{
pub
fn
new_inherited
(
device
:
&
BluetoothDevice
is_connected
:
bool
)
-
>
BluetoothRemoteGATTServer
{
BluetoothRemoteGATTServer
{
reflector_
:
Reflector
:
:
new
(
)
device
:
MutHeap
:
:
new
(
device
)
connected
:
Cell
:
:
new
(
is_connected
)
}
}
pub
fn
new
(
global
:
GlobalRef
device
:
&
BluetoothDevice
connected
:
bool
)
-
>
Root
<
BluetoothRemoteGATTServer
>
{
reflect_dom_object
(
box
BluetoothRemoteGATTServer
:
:
new_inherited
(
device
connected
)
global
BluetoothRemoteGATTServerBinding
:
:
Wrap
)
}
}
impl
BluetoothRemoteGATTServerMethods
for
BluetoothRemoteGATTServer
{
fn
Device
(
&
self
)
-
>
Root
<
BluetoothDevice
>
{
self
.
device
.
get
(
)
}
fn
Connected
(
&
self
)
-
>
bool
{
self
.
connected
.
get
(
)
}
fn
Connect
(
&
self
)
-
>
Root
<
BluetoothRemoteGATTServer
>
{
if
!
self
.
connected
.
get
(
)
{
self
.
connected
.
set
(
true
)
;
}
Root
:
:
from_ref
(
self
)
}
fn
Disconnect
(
&
self
)
{
self
.
connected
.
set
(
false
)
;
}
fn
GetPrimaryService
(
&
self
)
-
>
Option
<
Root
<
BluetoothRemoteGATTService
>
>
{
None
}
}
