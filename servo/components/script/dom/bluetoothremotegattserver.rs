use
bluetooth_traits
:
:
{
BluetoothRequest
BluetoothResponse
GATTType
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
BluetoothDeviceBinding
:
:
BluetoothDeviceMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
BluetoothRemoteGATTServerBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
BluetoothRemoteGATTServerBinding
:
:
BluetoothRemoteGATTServerMethods
;
use
dom
:
:
bindings
:
:
error
:
:
Error
;
use
dom
:
:
bindings
:
:
error
:
:
ErrorResult
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
DomObject
Reflector
reflect_dom_object
}
;
use
dom
:
:
bindings
:
:
root
:
:
{
Dom
DomRoot
}
;
use
dom
:
:
bluetooth
:
:
{
AsyncBluetoothListener
get_gatt_children
response_async
}
;
use
dom
:
:
bluetoothdevice
:
:
BluetoothDevice
;
use
dom
:
:
bluetoothuuid
:
:
{
BluetoothServiceUUID
BluetoothUUID
}
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom
:
:
promise
:
:
Promise
;
use
dom_struct
:
:
dom_struct
;
use
ipc_channel
:
:
ipc
:
:
IpcSender
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
rc
:
:
Rc
;
#
[
dom_struct
]
pub
struct
BluetoothRemoteGATTServer
{
reflector_
:
Reflector
device
:
Dom
<
BluetoothDevice
>
connected
:
Cell
<
bool
>
}
impl
BluetoothRemoteGATTServer
{
pub
fn
new_inherited
(
device
:
&
BluetoothDevice
)
-
>
BluetoothRemoteGATTServer
{
BluetoothRemoteGATTServer
{
reflector_
:
Reflector
:
:
new
(
)
device
:
Dom
:
:
from_ref
(
device
)
connected
:
Cell
:
:
new
(
false
)
}
}
pub
fn
new
(
global
:
&
GlobalScope
device
:
&
BluetoothDevice
)
-
>
DomRoot
<
BluetoothRemoteGATTServer
>
{
reflect_dom_object
(
Box
:
:
new
(
BluetoothRemoteGATTServer
:
:
new_inherited
(
device
)
)
global
BluetoothRemoteGATTServerBinding
:
:
Wrap
)
}
fn
get_bluetooth_thread
(
&
self
)
-
>
IpcSender
<
BluetoothRequest
>
{
self
.
global
(
)
.
as_window
(
)
.
bluetooth_thread
(
)
}
pub
fn
set_connected
(
&
self
connected
:
bool
)
{
self
.
connected
.
set
(
connected
)
;
}
}
impl
BluetoothRemoteGATTServerMethods
for
BluetoothRemoteGATTServer
{
fn
Device
(
&
self
)
-
>
DomRoot
<
BluetoothDevice
>
{
DomRoot
:
:
from_ref
(
&
self
.
device
)
}
fn
Connected
(
&
self
)
-
>
bool
{
self
.
connected
.
get
(
)
}
#
[
allow
(
unrooted_must_root
)
]
fn
Connect
(
&
self
)
-
>
Rc
<
Promise
>
{
let
p
=
Promise
:
:
new
(
&
self
.
global
(
)
)
;
let
sender
=
response_async
(
&
p
self
)
;
self
.
get_bluetooth_thread
(
)
.
send
(
BluetoothRequest
:
:
GATTServerConnect
(
String
:
:
from
(
self
.
Device
(
)
.
Id
(
)
)
sender
)
)
.
unwrap
(
)
;
return
p
;
}
fn
Disconnect
(
&
self
)
-
>
ErrorResult
{
if
!
self
.
Connected
(
)
{
return
Ok
(
(
)
)
}
self
.
Device
(
)
.
clean_up_disconnected_device
(
)
;
self
.
Device
(
)
.
garbage_collect_the_connection
(
)
}
#
[
allow
(
unrooted_must_root
)
]
fn
GetPrimaryService
(
&
self
service
:
BluetoothServiceUUID
)
-
>
Rc
<
Promise
>
{
get_gatt_children
(
self
true
BluetoothUUID
:
:
service
Some
(
service
)
String
:
:
from
(
self
.
Device
(
)
.
Id
(
)
)
self
.
Device
(
)
.
get_gatt
(
)
.
Connected
(
)
GATTType
:
:
PrimaryService
)
}
#
[
allow
(
unrooted_must_root
)
]
fn
GetPrimaryServices
(
&
self
service
:
Option
<
BluetoothServiceUUID
>
)
-
>
Rc
<
Promise
>
{
get_gatt_children
(
self
false
BluetoothUUID
:
:
service
service
String
:
:
from
(
self
.
Device
(
)
.
Id
(
)
)
self
.
Connected
(
)
GATTType
:
:
PrimaryService
)
}
}
impl
AsyncBluetoothListener
for
BluetoothRemoteGATTServer
{
fn
handle_response
(
&
self
response
:
BluetoothResponse
promise
:
&
Rc
<
Promise
>
)
{
match
response
{
BluetoothResponse
:
:
GATTServerConnect
(
connected
)
=
>
{
if
self
.
Device
(
)
.
is_represented_device_null
(
)
{
if
let
Err
(
e
)
=
self
.
Device
(
)
.
garbage_collect_the_connection
(
)
{
return
promise
.
reject_error
(
Error
:
:
from
(
e
)
)
;
}
return
promise
.
reject_error
(
Error
:
:
Network
)
;
}
self
.
connected
.
set
(
connected
)
;
promise
.
resolve_native
(
self
)
;
}
BluetoothResponse
:
:
GetPrimaryServices
(
services_vec
single
)
=
>
{
let
device
=
self
.
Device
(
)
;
if
single
{
promise
.
resolve_native
(
&
device
.
get_or_create_service
(
&
services_vec
[
0
]
&
self
)
)
;
return
;
}
let
mut
services
=
vec
!
(
)
;
for
service
in
services_vec
{
let
bt_service
=
device
.
get_or_create_service
(
&
service
&
self
)
;
services
.
push
(
bt_service
)
;
}
promise
.
resolve_native
(
&
services
)
;
}
_
=
>
promise
.
reject_error
(
Error
:
:
Type
(
"
Something
went
wrong
.
.
.
"
.
to_owned
(
)
)
)
}
}
}
