use
devtools_traits
:
:
{
StartedTimelineMarker
TimelineMarker
TimelineMarkerType
}
;
use
dom
:
:
bindings
:
:
callback
:
:
ExceptionHandling
:
:
Report
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
EventBinding
:
:
EventMethods
;
use
dom
:
:
bindings
:
:
inheritance
:
:
Castable
;
use
dom
:
:
bindings
:
:
js
:
:
{
JS
Root
RootedReference
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
DomObject
;
use
dom
:
:
document
:
:
Document
;
use
dom
:
:
event
:
:
{
Event
EventPhase
}
;
use
dom
:
:
eventtarget
:
:
{
CompiledEventListener
EventTarget
ListenerPhase
}
;
use
dom
:
:
node
:
:
Node
;
use
dom
:
:
virtualmethods
:
:
vtable_for
;
use
dom
:
:
window
:
:
Window
;
struct
AutoDOMEventMarker
{
window
:
Root
<
Window
>
marker
:
Option
<
StartedTimelineMarker
>
}
impl
AutoDOMEventMarker
{
fn
new
(
window
:
&
Window
)
-
>
AutoDOMEventMarker
{
AutoDOMEventMarker
{
window
:
Root
:
:
from_ref
(
window
)
marker
:
Some
(
TimelineMarker
:
:
start
(
"
DOMEvent
"
.
to_owned
(
)
)
)
}
}
}
impl
Drop
for
AutoDOMEventMarker
{
fn
drop
(
&
mut
self
)
{
self
.
window
.
emit_timeline_marker
(
self
.
marker
.
take
(
)
.
unwrap
(
)
.
end
(
)
)
;
}
}
fn
handle_event
(
window
:
Option
<
&
Window
>
listener
:
&
CompiledEventListener
current_target
:
&
EventTarget
event
:
&
Event
)
{
let
_marker
;
if
let
Some
(
window
)
=
window
{
_marker
=
AutoDOMEventMarker
:
:
new
(
window
)
;
}
listener
.
call_or_handle_event
(
current_target
event
Report
)
;
}
fn
dispatch_to_listeners
(
event
:
&
Event
target
:
&
EventTarget
event_path
:
&
[
&
EventTarget
]
)
{
assert
!
(
!
event
.
stop_propagation
(
)
)
;
assert
!
(
!
event
.
stop_immediate
(
)
)
;
let
window
=
match
Root
:
:
downcast
:
:
<
Window
>
(
target
.
global
(
)
)
{
Some
(
window
)
=
>
{
if
window
.
need_emit_timeline_marker
(
TimelineMarkerType
:
:
DOMEvent
)
{
Some
(
window
)
}
else
{
None
}
}
_
=
>
None
}
;
event
.
set_phase
(
EventPhase
:
:
Capturing
)
;
for
object
in
event_path
.
iter
(
)
.
rev
(
)
{
invoke
(
window
.
r
(
)
object
event
Some
(
ListenerPhase
:
:
Capturing
)
)
;
if
event
.
stop_propagation
(
)
{
return
;
}
}
assert
!
(
!
event
.
stop_propagation
(
)
)
;
assert
!
(
!
event
.
stop_immediate
(
)
)
;
event
.
set_phase
(
EventPhase
:
:
AtTarget
)
;
invoke
(
window
.
r
(
)
target
event
None
)
;
if
event
.
stop_propagation
(
)
{
return
;
}
assert
!
(
!
event
.
stop_propagation
(
)
)
;
assert
!
(
!
event
.
stop_immediate
(
)
)
;
if
!
event
.
bubbles
(
)
{
return
;
}
event
.
set_phase
(
EventPhase
:
:
Bubbling
)
;
for
object
in
event_path
{
invoke
(
window
.
r
(
)
object
event
Some
(
ListenerPhase
:
:
Bubbling
)
)
;
if
event
.
stop_propagation
(
)
{
return
;
}
}
}
#
[
derive
(
PartialEq
)
]
pub
enum
EventStatus
{
Canceled
NotCanceled
}
pub
fn
dispatch_event
(
target
:
&
EventTarget
target_override
:
Option
<
&
EventTarget
>
event
:
&
Event
)
-
>
EventStatus
{
assert
!
(
!
event
.
dispatching
(
)
)
;
assert
!
(
event
.
initialized
(
)
)
;
assert_eq
!
(
event
.
phase
(
)
EventPhase
:
:
None
)
;
assert
!
(
event
.
GetCurrentTarget
(
)
.
is_none
(
)
)
;
event
.
mark_as_dispatching
(
)
;
event
.
set_target
(
target_override
.
unwrap_or
(
target
)
)
;
if
event
.
stop_propagation
(
)
{
event
.
clear_dispatching_flags
(
)
;
return
event
.
status
(
)
;
}
rooted_vec
!
(
let
mut
event_path
)
;
if
let
Some
(
target_node
)
=
target
.
downcast
:
:
<
Node
>
(
)
{
for
ancestor
in
target_node
.
ancestors
(
)
{
event_path
.
push
(
JS
:
:
from_ref
(
ancestor
.
upcast
:
:
<
EventTarget
>
(
)
)
)
;
}
let
top_most_ancestor_or_target
=
Root
:
:
from_ref
(
event_path
.
r
(
)
.
last
(
)
.
cloned
(
)
.
unwrap_or
(
target
)
)
;
if
let
Some
(
document
)
=
Root
:
:
downcast
:
:
<
Document
>
(
top_most_ancestor_or_target
)
{
if
event
.
type_
(
)
!
=
atom
!
(
"
load
"
)
&
&
document
.
browsing_context
(
)
.
is_some
(
)
{
event_path
.
push
(
JS
:
:
from_ref
(
document
.
window
(
)
.
upcast
(
)
)
)
;
}
}
}
dispatch_to_listeners
(
event
target
event_path
.
r
(
)
)
;
if
let
Some
(
target
)
=
event
.
GetTarget
(
)
{
if
let
Some
(
node
)
=
target
.
downcast
:
:
<
Node
>
(
)
{
let
vtable
=
vtable_for
(
&
node
)
;
vtable
.
handle_event
(
event
)
;
}
}
event
.
clear_dispatching_flags
(
)
;
event
.
status
(
)
}
fn
invoke
(
window
:
Option
<
&
Window
>
object
:
&
EventTarget
event
:
&
Event
specific_listener_phase
:
Option
<
ListenerPhase
>
)
{
assert
!
(
!
event
.
stop_propagation
(
)
)
;
let
listeners
=
object
.
get_listeners_for
(
&
event
.
type_
(
)
specific_listener_phase
)
;
event
.
set_current_target
(
object
)
;
inner_invoke
(
window
object
event
&
listeners
)
;
}
fn
inner_invoke
(
window
:
Option
<
&
Window
>
object
:
&
EventTarget
event
:
&
Event
listeners
:
&
[
CompiledEventListener
]
)
-
>
bool
{
let
mut
found
=
false
;
for
listener
in
listeners
{
found
=
true
;
handle_event
(
window
listener
object
event
)
;
if
event
.
stop_immediate
(
)
{
return
found
;
}
}
found
}
