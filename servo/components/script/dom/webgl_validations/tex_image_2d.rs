use
canvas_traits
:
:
webgl
:
:
WebGLError
:
:
*
;
use
dom
:
:
bindings
:
:
root
:
:
DomRoot
;
use
dom
:
:
webglrenderingcontext
:
:
WebGLRenderingContext
;
use
dom
:
:
webgltexture
:
:
WebGLTexture
;
use
std
:
:
{
self
fmt
}
;
use
super
:
:
WebGLValidator
;
use
super
:
:
types
:
:
{
TexImageTarget
TexDataType
TexFormat
}
;
#
[
derive
(
Debug
)
]
pub
enum
TexImageValidationError
{
InvalidTextureTarget
(
u32
)
TextureTargetNotBound
(
u32
)
InvalidCubicTextureDimensions
NegativeLevel
LevelTooHigh
NegativeDimension
TextureTooBig
InvalidDataType
InvalidTextureFormat
TextureFormatMismatch
InvalidTypeForFormat
InvalidBorder
NonPotTexture
}
impl
std
:
:
error
:
:
Error
for
TexImageValidationError
{
fn
description
(
&
self
)
-
>
&
str
{
use
self
:
:
TexImageValidationError
:
:
*
;
match
*
self
{
InvalidTextureTarget
(
_
)
=
>
"
Invalid
texture
target
"
TextureTargetNotBound
(
_
)
=
>
"
Texture
was
not
bound
"
InvalidCubicTextureDimensions
=
>
"
Invalid
dimensions
were
given
for
a
cubic
texture
target
"
NegativeLevel
=
>
"
A
negative
level
was
passed
"
LevelTooHigh
=
>
"
Level
too
high
"
NegativeDimension
=
>
"
Negative
dimensions
were
passed
"
TextureTooBig
=
>
"
Dimensions
given
are
too
big
"
InvalidDataType
=
>
"
Invalid
data
type
"
InvalidTextureFormat
=
>
"
Invalid
texture
format
"
TextureFormatMismatch
=
>
"
Texture
format
mismatch
"
InvalidTypeForFormat
=
>
"
Invalid
type
for
the
given
format
"
InvalidBorder
=
>
"
Invalid
border
"
NonPotTexture
=
>
"
Expected
a
power
of
two
texture
"
}
}
}
impl
fmt
:
:
Display
for
TexImageValidationError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
TexImageValidationError
(
{
}
)
"
std
:
:
error
:
:
Error
:
:
description
(
self
)
)
}
}
fn
log2
(
n
:
u32
)
-
>
u32
{
31
-
n
.
leading_zeros
(
)
}
pub
struct
CommonTexImage2DValidator
<
'
a
>
{
context
:
&
'
a
WebGLRenderingContext
target
:
u32
level
:
i32
internal_format
:
u32
width
:
i32
height
:
i32
border
:
i32
}
pub
struct
CommonTexImage2DValidatorResult
{
pub
texture
:
DomRoot
<
WebGLTexture
>
pub
target
:
TexImageTarget
pub
level
:
u32
pub
internal_format
:
TexFormat
pub
width
:
u32
pub
height
:
u32
pub
border
:
u32
}
impl
<
'
a
>
WebGLValidator
for
CommonTexImage2DValidator
<
'
a
>
{
type
Error
=
TexImageValidationError
;
type
ValidatedOutput
=
CommonTexImage2DValidatorResult
;
fn
validate
(
self
)
-
>
Result
<
Self
:
:
ValidatedOutput
TexImageValidationError
>
{
let
target
=
match
TexImageTarget
:
:
from_gl_constant
(
self
.
target
)
{
Some
(
target
)
=
>
target
None
=
>
{
self
.
context
.
webgl_error
(
InvalidEnum
)
;
return
Err
(
TexImageValidationError
:
:
InvalidTextureTarget
(
self
.
target
)
)
;
}
}
;
let
texture
=
self
.
context
.
bound_texture_for_target
(
&
target
)
;
let
limits
=
self
.
context
.
limits
(
)
;
let
max_size
=
if
target
.
is_cubic
(
)
{
limits
.
max_cube_map_tex_size
}
else
{
limits
.
max_tex_size
}
;
let
texture
=
match
texture
{
Some
(
texture
)
=
>
texture
None
=
>
{
self
.
context
.
webgl_error
(
InvalidOperation
)
;
return
Err
(
TexImageValidationError
:
:
TextureTargetNotBound
(
self
.
target
)
)
;
}
}
;
let
internal_format
=
match
TexFormat
:
:
from_gl_constant
(
self
.
internal_format
)
{
Some
(
format
)
=
>
format
None
=
>
{
self
.
context
.
webgl_error
(
InvalidEnum
)
;
return
Err
(
TexImageValidationError
:
:
InvalidTextureFormat
)
;
}
}
;
if
target
.
is_cubic
(
)
&
&
self
.
width
!
=
self
.
height
{
self
.
context
.
webgl_error
(
InvalidValue
)
;
return
Err
(
TexImageValidationError
:
:
InvalidCubicTextureDimensions
)
;
}
if
self
.
level
<
0
{
self
.
context
.
webgl_error
(
InvalidValue
)
;
return
Err
(
TexImageValidationError
:
:
NegativeLevel
)
;
}
if
self
.
width
<
0
|
|
self
.
height
<
0
{
self
.
context
.
webgl_error
(
InvalidValue
)
;
return
Err
(
TexImageValidationError
:
:
NegativeDimension
)
;
}
let
width
=
self
.
width
as
u32
;
let
height
=
self
.
height
as
u32
;
let
level
=
self
.
level
as
u32
;
if
width
>
max_size
>
>
level
|
|
height
>
max_size
>
>
level
{
self
.
context
.
webgl_error
(
InvalidValue
)
;
return
Err
(
TexImageValidationError
:
:
TextureTooBig
)
;
}
if
level
>
0
&
&
(
!
width
.
is_power_of_two
(
)
|
|
!
height
.
is_power_of_two
(
)
)
{
self
.
context
.
webgl_error
(
InvalidValue
)
;
return
Err
(
TexImageValidationError
:
:
NonPotTexture
)
;
}
if
level
>
log2
(
max_size
)
{
self
.
context
.
webgl_error
(
InvalidValue
)
;
return
Err
(
TexImageValidationError
:
:
LevelTooHigh
)
;
}
if
self
.
border
!
=
0
{
self
.
context
.
webgl_error
(
InvalidValue
)
;
return
Err
(
TexImageValidationError
:
:
InvalidBorder
)
;
}
Ok
(
CommonTexImage2DValidatorResult
{
texture
:
texture
target
:
target
level
:
level
internal_format
:
internal_format
width
:
width
height
:
height
border
:
self
.
border
as
u32
}
)
}
}
impl
<
'
a
>
CommonTexImage2DValidator
<
'
a
>
{
pub
fn
new
(
context
:
&
'
a
WebGLRenderingContext
target
:
u32
level
:
i32
internal_format
:
u32
width
:
i32
height
:
i32
border
:
i32
)
-
>
Self
{
CommonTexImage2DValidator
{
context
:
context
target
:
target
level
:
level
internal_format
:
internal_format
width
:
width
height
:
height
border
:
border
}
}
}
pub
struct
TexImage2DValidator
<
'
a
>
{
common_validator
:
CommonTexImage2DValidator
<
'
a
>
format
:
u32
data_type
:
u32
}
impl
<
'
a
>
TexImage2DValidator
<
'
a
>
{
pub
fn
new
(
context
:
&
'
a
WebGLRenderingContext
target
:
u32
level
:
i32
internal_format
:
u32
width
:
i32
height
:
i32
border
:
i32
format
:
u32
data_type
:
u32
)
-
>
Self
{
TexImage2DValidator
{
common_validator
:
CommonTexImage2DValidator
:
:
new
(
context
target
level
internal_format
width
height
border
)
format
:
format
data_type
:
data_type
}
}
}
pub
struct
TexImage2DValidatorResult
{
pub
width
:
u32
pub
height
:
u32
pub
level
:
u32
pub
border
:
u32
pub
texture
:
DomRoot
<
WebGLTexture
>
pub
target
:
TexImageTarget
pub
format
:
TexFormat
pub
data_type
:
TexDataType
}
impl
<
'
a
>
WebGLValidator
for
TexImage2DValidator
<
'
a
>
{
type
ValidatedOutput
=
TexImage2DValidatorResult
;
type
Error
=
TexImageValidationError
;
fn
validate
(
self
)
-
>
Result
<
Self
:
:
ValidatedOutput
TexImageValidationError
>
{
let
context
=
self
.
common_validator
.
context
;
let
CommonTexImage2DValidatorResult
{
texture
target
level
internal_format
width
height
border
}
=
self
.
common_validator
.
validate
(
)
?
;
let
data_type
=
match
TexDataType
:
:
from_gl_constant
(
self
.
data_type
)
{
Some
(
data_type
)
=
>
data_type
None
=
>
{
context
.
webgl_error
(
InvalidEnum
)
;
return
Err
(
TexImageValidationError
:
:
InvalidDataType
)
;
}
}
;
let
format
=
match
TexFormat
:
:
from_gl_constant
(
self
.
format
)
{
Some
(
format
)
=
>
format
None
=
>
{
context
.
webgl_error
(
InvalidEnum
)
;
return
Err
(
TexImageValidationError
:
:
InvalidTextureFormat
)
;
}
}
;
if
format
!
=
internal_format
{
context
.
webgl_error
(
InvalidOperation
)
;
return
Err
(
TexImageValidationError
:
:
TextureFormatMismatch
)
;
}
match
data_type
{
TexDataType
:
:
UnsignedShort4444
|
TexDataType
:
:
UnsignedShort5551
if
format
!
=
TexFormat
:
:
RGBA
=
>
{
context
.
webgl_error
(
InvalidOperation
)
;
return
Err
(
TexImageValidationError
:
:
InvalidTypeForFormat
)
;
}
TexDataType
:
:
UnsignedShort565
if
format
!
=
TexFormat
:
:
RGB
=
>
{
context
.
webgl_error
(
InvalidOperation
)
;
return
Err
(
TexImageValidationError
:
:
InvalidTypeForFormat
)
;
}
_
=
>
{
}
}
Ok
(
TexImage2DValidatorResult
{
width
:
width
height
:
height
level
:
level
border
:
border
texture
:
texture
target
:
target
format
:
format
data_type
:
data_type
}
)
}
}
