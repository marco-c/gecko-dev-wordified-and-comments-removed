use
devtools_traits
:
:
{
TimelineMarker
TimelineMarkerType
}
;
use
dom
:
:
bindings
:
:
callback
:
:
ExceptionHandling
;
use
dom
:
:
bindings
:
:
cell
:
:
DomRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
EventBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
EventBinding
:
:
{
EventConstants
EventMethods
}
;
use
dom
:
:
bindings
:
:
error
:
:
Fallible
;
use
dom
:
:
bindings
:
:
inheritance
:
:
Castable
;
use
dom
:
:
bindings
:
:
refcounted
:
:
Trusted
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
DomObject
Reflector
reflect_dom_object
}
;
use
dom
:
:
bindings
:
:
root
:
:
{
Dom
DomRoot
MutNullableDom
RootedReference
}
;
use
dom
:
:
bindings
:
:
str
:
:
DOMString
;
use
dom
:
:
document
:
:
Document
;
use
dom
:
:
eventtarget
:
:
{
CompiledEventListener
EventTarget
ListenerPhase
}
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom
:
:
node
:
:
Node
;
use
dom
:
:
virtualmethods
:
:
vtable_for
;
use
dom
:
:
window
:
:
Window
;
use
dom_struct
:
:
dom_struct
;
use
servo_atoms
:
:
Atom
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
default
:
:
Default
;
use
task
:
:
TaskOnce
;
use
time
;
#
[
dom_struct
]
pub
struct
Event
{
reflector_
:
Reflector
current_target
:
MutNullableDom
<
EventTarget
>
target
:
MutNullableDom
<
EventTarget
>
type_
:
DomRefCell
<
Atom
>
phase
:
Cell
<
EventPhase
>
canceled
:
Cell
<
EventDefault
>
stop_propagation
:
Cell
<
bool
>
stop_immediate
:
Cell
<
bool
>
cancelable
:
Cell
<
bool
>
bubbles
:
Cell
<
bool
>
trusted
:
Cell
<
bool
>
dispatching
:
Cell
<
bool
>
initialized
:
Cell
<
bool
>
timestamp
:
u64
}
impl
Event
{
pub
fn
new_inherited
(
)
-
>
Event
{
Event
{
reflector_
:
Reflector
:
:
new
(
)
current_target
:
Default
:
:
default
(
)
target
:
Default
:
:
default
(
)
type_
:
DomRefCell
:
:
new
(
atom
!
(
"
"
)
)
phase
:
Cell
:
:
new
(
EventPhase
:
:
None
)
canceled
:
Cell
:
:
new
(
EventDefault
:
:
Allowed
)
stop_propagation
:
Cell
:
:
new
(
false
)
stop_immediate
:
Cell
:
:
new
(
false
)
cancelable
:
Cell
:
:
new
(
false
)
bubbles
:
Cell
:
:
new
(
false
)
trusted
:
Cell
:
:
new
(
false
)
dispatching
:
Cell
:
:
new
(
false
)
initialized
:
Cell
:
:
new
(
false
)
timestamp
:
time
:
:
get_time
(
)
.
sec
as
u64
}
}
pub
fn
new_uninitialized
(
global
:
&
GlobalScope
)
-
>
DomRoot
<
Event
>
{
reflect_dom_object
(
Box
:
:
new
(
Event
:
:
new_inherited
(
)
)
global
EventBinding
:
:
Wrap
)
}
pub
fn
new
(
global
:
&
GlobalScope
type_
:
Atom
bubbles
:
EventBubbles
cancelable
:
EventCancelable
)
-
>
DomRoot
<
Event
>
{
let
event
=
Event
:
:
new_uninitialized
(
global
)
;
event
.
init_event
(
type_
bool
:
:
from
(
bubbles
)
bool
:
:
from
(
cancelable
)
)
;
event
}
pub
fn
Constructor
(
global
:
&
GlobalScope
type_
:
DOMString
init
:
&
EventBinding
:
:
EventInit
)
-
>
Fallible
<
DomRoot
<
Event
>
>
{
let
bubbles
=
EventBubbles
:
:
from
(
init
.
bubbles
)
;
let
cancelable
=
EventCancelable
:
:
from
(
init
.
cancelable
)
;
Ok
(
Event
:
:
new
(
global
Atom
:
:
from
(
type_
)
bubbles
cancelable
)
)
}
pub
fn
init_event
(
&
self
type_
:
Atom
bubbles
:
bool
cancelable
:
bool
)
{
if
self
.
dispatching
.
get
(
)
{
return
;
}
self
.
initialized
.
set
(
true
)
;
self
.
stop_propagation
.
set
(
false
)
;
self
.
stop_immediate
.
set
(
false
)
;
self
.
canceled
.
set
(
EventDefault
:
:
Allowed
)
;
self
.
trusted
.
set
(
false
)
;
self
.
target
.
set
(
None
)
;
*
self
.
type_
.
borrow_mut
(
)
=
type_
;
self
.
bubbles
.
set
(
bubbles
)
;
self
.
cancelable
.
set
(
cancelable
)
;
}
pub
fn
dispatch
(
&
self
target
:
&
EventTarget
target_override
:
Option
<
&
EventTarget
>
)
-
>
EventStatus
{
assert
!
(
!
self
.
dispatching
(
)
)
;
assert
!
(
self
.
initialized
(
)
)
;
assert_eq
!
(
self
.
phase
.
get
(
)
EventPhase
:
:
None
)
;
assert
!
(
self
.
GetCurrentTarget
(
)
.
is_none
(
)
)
;
self
.
dispatching
.
set
(
true
)
;
self
.
target
.
set
(
Some
(
target_override
.
unwrap_or
(
target
)
)
)
;
if
self
.
stop_propagation
.
get
(
)
{
self
.
clear_dispatching_flags
(
)
;
return
self
.
status
(
)
;
}
rooted_vec
!
(
let
mut
event_path
)
;
if
let
Some
(
target_node
)
=
target
.
downcast
:
:
<
Node
>
(
)
{
for
ancestor
in
target_node
.
ancestors
(
)
{
event_path
.
push
(
Dom
:
:
from_ref
(
ancestor
.
upcast
:
:
<
EventTarget
>
(
)
)
)
;
}
let
top_most_ancestor_or_target
=
DomRoot
:
:
from_ref
(
event_path
.
r
(
)
.
last
(
)
.
cloned
(
)
.
unwrap_or
(
target
)
)
;
if
let
Some
(
document
)
=
DomRoot
:
:
downcast
:
:
<
Document
>
(
top_most_ancestor_or_target
)
{
if
self
.
type_
(
)
!
=
atom
!
(
"
load
"
)
&
&
document
.
browsing_context
(
)
.
is_some
(
)
{
event_path
.
push
(
Dom
:
:
from_ref
(
document
.
window
(
)
.
upcast
(
)
)
)
;
}
}
}
dispatch_to_listeners
(
self
target
event_path
.
r
(
)
)
;
if
let
Some
(
target
)
=
self
.
GetTarget
(
)
{
if
let
Some
(
node
)
=
target
.
downcast
:
:
<
Node
>
(
)
{
let
vtable
=
vtable_for
(
&
node
)
;
vtable
.
handle_event
(
self
)
;
}
}
self
.
clear_dispatching_flags
(
)
;
self
.
status
(
)
}
pub
fn
status
(
&
self
)
-
>
EventStatus
{
match
self
.
DefaultPrevented
(
)
{
true
=
>
EventStatus
:
:
Canceled
false
=
>
EventStatus
:
:
NotCanceled
}
}
#
[
inline
]
pub
fn
dispatching
(
&
self
)
-
>
bool
{
self
.
dispatching
.
get
(
)
}
#
[
inline
]
fn
clear_dispatching_flags
(
&
self
)
{
assert
!
(
self
.
dispatching
.
get
(
)
)
;
self
.
dispatching
.
set
(
false
)
;
self
.
stop_propagation
.
set
(
false
)
;
self
.
stop_immediate
.
set
(
false
)
;
self
.
phase
.
set
(
EventPhase
:
:
None
)
;
self
.
current_target
.
set
(
None
)
;
}
#
[
inline
]
pub
fn
initialized
(
&
self
)
-
>
bool
{
self
.
initialized
.
get
(
)
}
#
[
inline
]
pub
fn
type_
(
&
self
)
-
>
Atom
{
self
.
type_
.
borrow
(
)
.
clone
(
)
}
#
[
inline
]
pub
fn
mark_as_handled
(
&
self
)
{
self
.
canceled
.
set
(
EventDefault
:
:
Handled
)
;
}
#
[
inline
]
pub
fn
get_cancel_state
(
&
self
)
-
>
EventDefault
{
self
.
canceled
.
get
(
)
}
pub
fn
set_trusted
(
&
self
trusted
:
bool
)
{
self
.
trusted
.
set
(
trusted
)
;
}
pub
fn
fire
(
&
self
target
:
&
EventTarget
)
-
>
EventStatus
{
self
.
set_trusted
(
true
)
;
target
.
dispatch_event
(
self
)
}
}
impl
EventMethods
for
Event
{
fn
EventPhase
(
&
self
)
-
>
u16
{
self
.
phase
.
get
(
)
as
u16
}
fn
Type
(
&
self
)
-
>
DOMString
{
DOMString
:
:
from
(
&
*
self
.
type_
(
)
)
}
fn
GetTarget
(
&
self
)
-
>
Option
<
DomRoot
<
EventTarget
>
>
{
self
.
target
.
get
(
)
}
fn
GetCurrentTarget
(
&
self
)
-
>
Option
<
DomRoot
<
EventTarget
>
>
{
self
.
current_target
.
get
(
)
}
fn
DefaultPrevented
(
&
self
)
-
>
bool
{
self
.
canceled
.
get
(
)
=
=
EventDefault
:
:
Prevented
}
fn
PreventDefault
(
&
self
)
{
if
self
.
cancelable
.
get
(
)
{
self
.
canceled
.
set
(
EventDefault
:
:
Prevented
)
}
}
fn
StopPropagation
(
&
self
)
{
self
.
stop_propagation
.
set
(
true
)
;
}
fn
StopImmediatePropagation
(
&
self
)
{
self
.
stop_immediate
.
set
(
true
)
;
self
.
stop_propagation
.
set
(
true
)
;
}
fn
Bubbles
(
&
self
)
-
>
bool
{
self
.
bubbles
.
get
(
)
}
fn
Cancelable
(
&
self
)
-
>
bool
{
self
.
cancelable
.
get
(
)
}
fn
TimeStamp
(
&
self
)
-
>
u64
{
self
.
timestamp
}
fn
InitEvent
(
&
self
type_
:
DOMString
bubbles
:
bool
cancelable
:
bool
)
{
self
.
init_event
(
Atom
:
:
from
(
type_
)
bubbles
cancelable
)
}
fn
IsTrusted
(
&
self
)
-
>
bool
{
self
.
trusted
.
get
(
)
}
}
#
[
derive
(
Clone
Copy
MallocSizeOf
PartialEq
)
]
pub
enum
EventBubbles
{
Bubbles
DoesNotBubble
}
impl
From
<
bool
>
for
EventBubbles
{
fn
from
(
boolean
:
bool
)
-
>
Self
{
match
boolean
{
true
=
>
EventBubbles
:
:
Bubbles
false
=
>
EventBubbles
:
:
DoesNotBubble
}
}
}
impl
From
<
EventBubbles
>
for
bool
{
fn
from
(
bubbles
:
EventBubbles
)
-
>
Self
{
match
bubbles
{
EventBubbles
:
:
Bubbles
=
>
true
EventBubbles
:
:
DoesNotBubble
=
>
false
}
}
}
#
[
derive
(
Clone
Copy
MallocSizeOf
PartialEq
)
]
pub
enum
EventCancelable
{
Cancelable
NotCancelable
}
impl
From
<
bool
>
for
EventCancelable
{
fn
from
(
boolean
:
bool
)
-
>
Self
{
match
boolean
{
true
=
>
EventCancelable
:
:
Cancelable
false
=
>
EventCancelable
:
:
NotCancelable
}
}
}
impl
From
<
EventCancelable
>
for
bool
{
fn
from
(
bubbles
:
EventCancelable
)
-
>
Self
{
match
bubbles
{
EventCancelable
:
:
Cancelable
=
>
true
EventCancelable
:
:
NotCancelable
=
>
false
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
JSTraceable
PartialEq
)
]
#
[
repr
(
u16
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
enum
EventPhase
{
None
=
EventConstants
:
:
NONE
Capturing
=
EventConstants
:
:
CAPTURING_PHASE
AtTarget
=
EventConstants
:
:
AT_TARGET
Bubbling
=
EventConstants
:
:
BUBBLING_PHASE
}
#
[
derive
(
Clone
Copy
JSTraceable
MallocSizeOf
PartialEq
)
]
pub
enum
EventDefault
{
Allowed
Prevented
Handled
}
#
[
derive
(
PartialEq
)
]
pub
enum
EventStatus
{
Canceled
NotCanceled
}
pub
struct
EventTask
{
pub
target
:
Trusted
<
EventTarget
>
pub
name
:
Atom
pub
bubbles
:
EventBubbles
pub
cancelable
:
EventCancelable
}
impl
TaskOnce
for
EventTask
{
fn
run_once
(
self
)
{
let
target
=
self
.
target
.
root
(
)
;
let
bubbles
=
self
.
bubbles
;
let
cancelable
=
self
.
cancelable
;
target
.
fire_event_with_params
(
self
.
name
bubbles
cancelable
)
;
}
}
pub
struct
SimpleEventTask
{
pub
target
:
Trusted
<
EventTarget
>
pub
name
:
Atom
}
impl
TaskOnce
for
SimpleEventTask
{
fn
run_once
(
self
)
{
let
target
=
self
.
target
.
root
(
)
;
target
.
fire_event
(
self
.
name
)
;
}
}
fn
dispatch_to_listeners
(
event
:
&
Event
target
:
&
EventTarget
event_path
:
&
[
&
EventTarget
]
)
{
assert
!
(
!
event
.
stop_propagation
.
get
(
)
)
;
assert
!
(
!
event
.
stop_immediate
.
get
(
)
)
;
let
window
=
match
DomRoot
:
:
downcast
:
:
<
Window
>
(
target
.
global
(
)
)
{
Some
(
window
)
=
>
{
if
window
.
need_emit_timeline_marker
(
TimelineMarkerType
:
:
DOMEvent
)
{
Some
(
window
)
}
else
{
None
}
}
_
=
>
None
}
;
event
.
phase
.
set
(
EventPhase
:
:
Capturing
)
;
for
object
in
event_path
.
iter
(
)
.
rev
(
)
{
invoke
(
window
.
r
(
)
object
event
Some
(
ListenerPhase
:
:
Capturing
)
)
;
if
event
.
stop_propagation
.
get
(
)
{
return
;
}
}
assert
!
(
!
event
.
stop_propagation
.
get
(
)
)
;
assert
!
(
!
event
.
stop_immediate
.
get
(
)
)
;
event
.
phase
.
set
(
EventPhase
:
:
AtTarget
)
;
invoke
(
window
.
r
(
)
target
event
None
)
;
if
event
.
stop_propagation
.
get
(
)
{
return
;
}
assert
!
(
!
event
.
stop_propagation
.
get
(
)
)
;
assert
!
(
!
event
.
stop_immediate
.
get
(
)
)
;
if
!
event
.
bubbles
.
get
(
)
{
return
;
}
event
.
phase
.
set
(
EventPhase
:
:
Bubbling
)
;
for
object
in
event_path
{
invoke
(
window
.
r
(
)
object
event
Some
(
ListenerPhase
:
:
Bubbling
)
)
;
if
event
.
stop_propagation
.
get
(
)
{
return
;
}
}
}
fn
invoke
(
window
:
Option
<
&
Window
>
object
:
&
EventTarget
event
:
&
Event
specific_listener_phase
:
Option
<
ListenerPhase
>
)
{
assert
!
(
!
event
.
stop_propagation
.
get
(
)
)
;
let
listeners
=
object
.
get_listeners_for
(
&
event
.
type_
(
)
specific_listener_phase
)
;
event
.
current_target
.
set
(
Some
(
object
)
)
;
inner_invoke
(
window
object
event
&
listeners
)
;
}
fn
inner_invoke
(
window
:
Option
<
&
Window
>
object
:
&
EventTarget
event
:
&
Event
listeners
:
&
[
CompiledEventListener
]
)
-
>
bool
{
let
mut
found
=
false
;
for
listener
in
listeners
{
found
=
true
;
let
marker
=
TimelineMarker
:
:
start
(
"
DOMEvent
"
.
to_owned
(
)
)
;
listener
.
call_or_handle_event
(
object
event
ExceptionHandling
:
:
Report
)
;
if
let
Some
(
window
)
=
window
{
window
.
emit_timeline_marker
(
marker
.
end
(
)
)
;
}
if
event
.
stop_immediate
.
get
(
)
{
return
found
;
}
}
found
}
impl
Default
for
EventBinding
:
:
EventInit
{
fn
default
(
)
-
>
EventBinding
:
:
EventInit
{
EventBinding
:
:
EventInit
{
bubbles
:
false
cancelable
:
false
}
}
}
