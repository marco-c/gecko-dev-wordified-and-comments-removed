use
devtools_traits
:
:
{
ScriptToDevtoolsControlMsg
WorkerId
}
;
use
dom
:
:
bindings
:
:
cell
:
:
DOMRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
WindowBinding
:
:
WindowMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
WorkerGlobalScopeBinding
:
:
WorkerGlobalScopeMethods
;
use
dom
:
:
bindings
:
:
conversions
:
:
root_from_object
;
use
dom
:
:
bindings
:
:
error
:
:
{
ErrorInfo
report_pending_exception
}
;
use
dom
:
:
bindings
:
:
inheritance
:
:
Castable
;
use
dom
:
:
bindings
:
:
js
:
:
{
MutNullableJS
Root
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
DomObject
;
use
dom
:
:
bindings
:
:
settings_stack
:
:
{
AutoEntryScript
entry_global
incumbent_global
}
;
use
dom
:
:
bindings
:
:
str
:
:
DOMString
;
use
dom
:
:
crypto
:
:
Crypto
;
use
dom
:
:
dedicatedworkerglobalscope
:
:
DedicatedWorkerGlobalScope
;
use
dom
:
:
errorevent
:
:
ErrorEvent
;
use
dom
:
:
event
:
:
{
Event
EventBubbles
EventCancelable
EventStatus
}
;
use
dom
:
:
eventtarget
:
:
EventTarget
;
use
dom
:
:
performance
:
:
Performance
;
use
dom
:
:
window
:
:
Window
;
use
dom
:
:
workerglobalscope
:
:
WorkerGlobalScope
;
use
dom
:
:
workletglobalscope
:
:
WorkletGlobalScope
;
use
dom_struct
:
:
dom_struct
;
use
ipc_channel
:
:
ipc
:
:
IpcSender
;
use
js
:
:
{
JSCLASS_IS_DOMJSCLASS
JSCLASS_IS_GLOBAL
}
;
use
js
:
:
glue
:
:
{
IsWrapper
UnwrapObject
}
;
use
js
:
:
jsapi
:
:
{
CurrentGlobalOrNull
GetGlobalForObjectCrossCompartment
}
;
use
js
:
:
jsapi
:
:
{
HandleValue
Evaluate2
JSAutoCompartment
JSContext
}
;
use
js
:
:
jsapi
:
:
{
JSObject
JS_GetContext
}
;
use
js
:
:
jsapi
:
:
{
JS_GetObjectRuntime
MutableHandleValue
}
;
use
js
:
:
panic
:
:
maybe_resume_unwind
;
use
js
:
:
rust
:
:
{
CompileOptionsWrapper
Runtime
get_object_class
}
;
use
libc
;
use
microtask
:
:
{
Microtask
MicrotaskQueue
}
;
use
msg
:
:
constellation_msg
:
:
PipelineId
;
use
net_traits
:
:
{
CoreResourceThread
ResourceThreads
IpcSend
}
;
use
profile_traits
:
:
{
mem
time
}
;
use
script_runtime
:
:
{
CommonScriptMsg
ScriptChan
ScriptPort
}
;
use
script_thread
:
:
{
MainThreadScriptChan
ScriptThread
}
;
use
script_traits
:
:
{
MsDuration
ScriptToConstellationChan
TimerEvent
}
;
use
script_traits
:
:
{
TimerEventId
TimerSchedulerMsg
TimerSource
}
;
use
servo_url
:
:
{
MutableOrigin
ServoUrl
}
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
rc
:
:
Rc
;
use
task
:
:
TaskCanceller
;
use
task_source
:
:
file_reading
:
:
FileReadingTaskSource
;
use
task_source
:
:
networking
:
:
NetworkingTaskSource
;
use
task_source
:
:
performance_timeline
:
:
PerformanceTimelineTaskSource
;
use
time
:
:
{
Timespec
get_time
}
;
use
timers
:
:
{
IsInterval
OneshotTimerCallback
OneshotTimerHandle
}
;
use
timers
:
:
{
OneshotTimers
TimerCallback
}
;
#
[
dom_struct
]
pub
struct
GlobalScope
{
eventtarget
:
EventTarget
crypto
:
MutNullableJS
<
Crypto
>
next_worker_id
:
Cell
<
WorkerId
>
pipeline_id
:
PipelineId
devtools_wants_updates
:
Cell
<
bool
>
console_timers
:
DOMRefCell
<
HashMap
<
DOMString
u64
>
>
#
[
ignore_heap_size_of
=
"
channels
are
hard
"
]
devtools_chan
:
Option
<
IpcSender
<
ScriptToDevtoolsControlMsg
>
>
#
[
ignore_heap_size_of
=
"
channels
are
hard
"
]
mem_profiler_chan
:
mem
:
:
ProfilerChan
#
[
ignore_heap_size_of
=
"
channels
are
hard
"
]
time_profiler_chan
:
time
:
:
ProfilerChan
#
[
ignore_heap_size_of
=
"
channels
are
hard
"
]
script_to_constellation_chan
:
ScriptToConstellationChan
#
[
ignore_heap_size_of
=
"
channels
are
hard
"
]
scheduler_chan
:
IpcSender
<
TimerSchedulerMsg
>
in_error_reporting_mode
:
Cell
<
bool
>
resource_threads
:
ResourceThreads
timers
:
OneshotTimers
origin
:
MutableOrigin
#
[
ignore_heap_size_of
=
"
Rc
<
T
>
is
hard
"
]
microtask_queue
:
Rc
<
MicrotaskQueue
>
}
impl
GlobalScope
{
pub
fn
new_inherited
(
pipeline_id
:
PipelineId
devtools_chan
:
Option
<
IpcSender
<
ScriptToDevtoolsControlMsg
>
>
mem_profiler_chan
:
mem
:
:
ProfilerChan
time_profiler_chan
:
time
:
:
ProfilerChan
script_to_constellation_chan
:
ScriptToConstellationChan
scheduler_chan
:
IpcSender
<
TimerSchedulerMsg
>
resource_threads
:
ResourceThreads
timer_event_chan
:
IpcSender
<
TimerEvent
>
origin
:
MutableOrigin
microtask_queue
:
Rc
<
MicrotaskQueue
>
)
-
>
Self
{
Self
{
eventtarget
:
EventTarget
:
:
new_inherited
(
)
crypto
:
Default
:
:
default
(
)
next_worker_id
:
Cell
:
:
new
(
WorkerId
(
0
)
)
pipeline_id
devtools_wants_updates
:
Default
:
:
default
(
)
console_timers
:
DOMRefCell
:
:
new
(
Default
:
:
default
(
)
)
devtools_chan
mem_profiler_chan
time_profiler_chan
script_to_constellation_chan
scheduler_chan
:
scheduler_chan
.
clone
(
)
in_error_reporting_mode
:
Default
:
:
default
(
)
resource_threads
timers
:
OneshotTimers
:
:
new
(
timer_event_chan
scheduler_chan
)
origin
microtask_queue
}
}
#
[
allow
(
unsafe_code
)
]
pub
fn
from_reflector
<
T
:
DomObject
>
(
reflector
:
&
T
)
-
>
Root
<
Self
>
{
unsafe
{
GlobalScope
:
:
from_object
(
*
reflector
.
reflector
(
)
.
get_jsobject
(
)
)
}
}
#
[
allow
(
unsafe_code
)
]
pub
unsafe
fn
from_object
(
obj
:
*
mut
JSObject
)
-
>
Root
<
Self
>
{
assert
!
(
!
obj
.
is_null
(
)
)
;
let
global
=
GetGlobalForObjectCrossCompartment
(
obj
)
;
global_scope_from_global
(
global
)
}
#
[
allow
(
unsafe_code
)
]
pub
unsafe
fn
from_context
(
cx
:
*
mut
JSContext
)
-
>
Root
<
Self
>
{
let
global
=
CurrentGlobalOrNull
(
cx
)
;
global_scope_from_global
(
global
)
}
#
[
allow
(
unsafe_code
)
]
pub
unsafe
fn
from_object_maybe_wrapped
(
mut
obj
:
*
mut
JSObject
)
-
>
Root
<
Self
>
{
if
IsWrapper
(
obj
)
{
obj
=
UnwrapObject
(
obj
0
)
;
assert
!
(
!
obj
.
is_null
(
)
)
;
}
GlobalScope
:
:
from_object
(
obj
)
}
#
[
allow
(
unsafe_code
)
]
pub
fn
get_cx
(
&
self
)
-
>
*
mut
JSContext
{
unsafe
{
let
runtime
=
JS_GetObjectRuntime
(
self
.
reflector
(
)
.
get_jsobject
(
)
.
get
(
)
)
;
assert
!
(
!
runtime
.
is_null
(
)
)
;
let
context
=
JS_GetContext
(
runtime
)
;
assert
!
(
!
context
.
is_null
(
)
)
;
context
}
}
pub
fn
crypto
(
&
self
)
-
>
Root
<
Crypto
>
{
self
.
crypto
.
or_init
(
|
|
Crypto
:
:
new
(
self
)
)
}
pub
fn
get_next_worker_id
(
&
self
)
-
>
WorkerId
{
let
worker_id
=
self
.
next_worker_id
.
get
(
)
;
let
WorkerId
(
id_num
)
=
worker_id
;
self
.
next_worker_id
.
set
(
WorkerId
(
id_num
+
1
)
)
;
worker_id
}
pub
fn
live_devtools_updates
(
&
self
)
-
>
bool
{
self
.
devtools_wants_updates
.
get
(
)
}
pub
fn
set_devtools_wants_updates
(
&
self
value
:
bool
)
{
self
.
devtools_wants_updates
.
set
(
value
)
;
}
pub
fn
time
(
&
self
label
:
DOMString
)
-
>
Result
<
(
)
(
)
>
{
let
mut
timers
=
self
.
console_timers
.
borrow_mut
(
)
;
if
timers
.
len
(
)
>
=
10000
{
return
Err
(
(
)
)
;
}
match
timers
.
entry
(
label
)
{
Entry
:
:
Vacant
(
entry
)
=
>
{
entry
.
insert
(
timestamp_in_ms
(
get_time
(
)
)
)
;
Ok
(
(
)
)
}
Entry
:
:
Occupied
(
_
)
=
>
Err
(
(
)
)
}
}
pub
fn
time_end
(
&
self
label
:
&
str
)
-
>
Result
<
u64
(
)
>
{
self
.
console_timers
.
borrow_mut
(
)
.
remove
(
label
)
.
ok_or
(
(
)
)
.
map
(
|
start
|
{
timestamp_in_ms
(
get_time
(
)
)
-
start
}
)
}
pub
fn
devtools_chan
(
&
self
)
-
>
Option
<
&
IpcSender
<
ScriptToDevtoolsControlMsg
>
>
{
self
.
devtools_chan
.
as_ref
(
)
}
pub
fn
mem_profiler_chan
(
&
self
)
-
>
&
mem
:
:
ProfilerChan
{
&
self
.
mem_profiler_chan
}
pub
fn
time_profiler_chan
(
&
self
)
-
>
&
time
:
:
ProfilerChan
{
&
self
.
time_profiler_chan
}
pub
fn
script_to_constellation_chan
(
&
self
)
-
>
&
ScriptToConstellationChan
{
&
self
.
script_to_constellation_chan
}
pub
fn
scheduler_chan
(
&
self
)
-
>
&
IpcSender
<
TimerSchedulerMsg
>
{
&
self
.
scheduler_chan
}
pub
fn
pipeline_id
(
&
self
)
-
>
PipelineId
{
self
.
pipeline_id
}
pub
fn
origin
(
&
self
)
-
>
&
MutableOrigin
{
&
self
.
origin
}
pub
fn
api_base_url
(
&
self
)
-
>
ServoUrl
{
if
let
Some
(
window
)
=
self
.
downcast
:
:
<
Window
>
(
)
{
return
window
.
Document
(
)
.
base_url
(
)
;
}
if
let
Some
(
worker
)
=
self
.
downcast
:
:
<
WorkerGlobalScope
>
(
)
{
return
worker
.
get_url
(
)
.
clone
(
)
;
}
if
let
Some
(
worker
)
=
self
.
downcast
:
:
<
WorkletGlobalScope
>
(
)
{
return
worker
.
base_url
(
)
;
}
unreachable
!
(
)
;
}
pub
fn
get_url
(
&
self
)
-
>
ServoUrl
{
if
let
Some
(
window
)
=
self
.
downcast
:
:
<
Window
>
(
)
{
return
window
.
get_url
(
)
;
}
if
let
Some
(
worker
)
=
self
.
downcast
:
:
<
WorkerGlobalScope
>
(
)
{
return
worker
.
get_url
(
)
.
clone
(
)
;
}
if
let
Some
(
worker
)
=
self
.
downcast
:
:
<
WorkletGlobalScope
>
(
)
{
return
worker
.
base_url
(
)
;
}
unreachable
!
(
)
;
}
pub
fn
as_window
(
&
self
)
-
>
&
Window
{
self
.
downcast
:
:
<
Window
>
(
)
.
expect
(
"
expected
a
Window
scope
"
)
}
pub
fn
report_an_error
(
&
self
error_info
:
ErrorInfo
value
:
HandleValue
)
{
if
self
.
in_error_reporting_mode
.
get
(
)
{
return
;
}
self
.
in_error_reporting_mode
.
set
(
true
)
;
let
event
=
ErrorEvent
:
:
new
(
self
atom
!
(
"
error
"
)
EventBubbles
:
:
DoesNotBubble
EventCancelable
:
:
Cancelable
error_info
.
message
.
as_str
(
)
.
into
(
)
error_info
.
filename
.
as_str
(
)
.
into
(
)
error_info
.
lineno
error_info
.
column
value
)
;
let
event_status
=
event
.
upcast
:
:
<
Event
>
(
)
.
fire
(
self
.
upcast
:
:
<
EventTarget
>
(
)
)
;
self
.
in_error_reporting_mode
.
set
(
false
)
;
if
event_status
=
=
EventStatus
:
:
NotCanceled
{
if
let
Some
(
dedicated
)
=
self
.
downcast
:
:
<
DedicatedWorkerGlobalScope
>
(
)
{
dedicated
.
forward_error_to_worker_object
(
error_info
)
;
}
}
}
pub
fn
resource_threads
(
&
self
)
-
>
&
ResourceThreads
{
&
self
.
resource_threads
}
pub
fn
core_resource_thread
(
&
self
)
-
>
CoreResourceThread
{
self
.
resource_threads
(
)
.
sender
(
)
}
pub
fn
script_chan
(
&
self
)
-
>
Box
<
ScriptChan
+
Send
>
{
if
let
Some
(
window
)
=
self
.
downcast
:
:
<
Window
>
(
)
{
return
MainThreadScriptChan
(
window
.
main_thread_script_chan
(
)
.
clone
(
)
)
.
clone
(
)
;
}
if
let
Some
(
worker
)
=
self
.
downcast
:
:
<
WorkerGlobalScope
>
(
)
{
return
worker
.
script_chan
(
)
;
}
unreachable
!
(
)
;
}
pub
fn
networking_task_source
(
&
self
)
-
>
NetworkingTaskSource
{
if
let
Some
(
window
)
=
self
.
downcast
:
:
<
Window
>
(
)
{
return
window
.
networking_task_source
(
)
;
}
if
let
Some
(
worker
)
=
self
.
downcast
:
:
<
WorkerGlobalScope
>
(
)
{
return
worker
.
networking_task_source
(
)
;
}
unreachable
!
(
)
;
}
pub
fn
evaluate_js_on_global_with_result
(
&
self
code
:
&
str
rval
:
MutableHandleValue
)
-
>
bool
{
self
.
evaluate_script_on_global_with_result
(
code
"
"
rval
1
)
}
#
[
allow
(
unsafe_code
)
]
pub
fn
evaluate_script_on_global_with_result
(
&
self
code
:
&
str
filename
:
&
str
rval
:
MutableHandleValue
line_number
:
u32
)
-
>
bool
{
let
metadata
=
time
:
:
TimerMetadata
{
url
:
if
filename
.
is_empty
(
)
{
self
.
get_url
(
)
.
as_str
(
)
.
into
(
)
}
else
{
filename
.
into
(
)
}
iframe
:
time
:
:
TimerMetadataFrameType
:
:
RootWindow
incremental
:
time
:
:
TimerMetadataReflowType
:
:
FirstReflow
}
;
time
:
:
profile
(
time
:
:
ProfilerCategory
:
:
ScriptEvaluate
Some
(
metadata
)
self
.
time_profiler_chan
(
)
.
clone
(
)
|
|
{
let
cx
=
self
.
get_cx
(
)
;
let
globalhandle
=
self
.
reflector
(
)
.
get_jsobject
(
)
;
let
code
:
Vec
<
u16
>
=
code
.
encode_utf16
(
)
.
collect
(
)
;
let
filename
=
CString
:
:
new
(
filename
)
.
unwrap
(
)
;
let
_ac
=
JSAutoCompartment
:
:
new
(
cx
globalhandle
.
get
(
)
)
;
let
_aes
=
AutoEntryScript
:
:
new
(
self
)
;
let
options
=
CompileOptionsWrapper
:
:
new
(
cx
filename
.
as_ptr
(
)
line_number
)
;
debug
!
(
"
evaluating
JS
string
"
)
;
let
result
=
unsafe
{
Evaluate2
(
cx
options
.
ptr
code
.
as_ptr
(
)
code
.
len
(
)
as
libc
:
:
size_t
rval
)
}
;
if
!
result
{
debug
!
(
"
error
evaluating
JS
string
"
)
;
unsafe
{
report_pending_exception
(
cx
true
)
}
;
}
maybe_resume_unwind
(
)
;
result
}
)
}
pub
fn
schedule_callback
(
&
self
callback
:
OneshotTimerCallback
duration
:
MsDuration
)
-
>
OneshotTimerHandle
{
self
.
timers
.
schedule_callback
(
callback
duration
self
.
timer_source
(
)
)
}
pub
fn
unschedule_callback
(
&
self
handle
:
OneshotTimerHandle
)
{
self
.
timers
.
unschedule_callback
(
handle
)
;
}
pub
fn
set_timeout_or_interval
(
&
self
callback
:
TimerCallback
arguments
:
Vec
<
HandleValue
>
timeout
:
i32
is_interval
:
IsInterval
)
-
>
i32
{
self
.
timers
.
set_timeout_or_interval
(
self
callback
arguments
timeout
is_interval
self
.
timer_source
(
)
)
}
pub
fn
clear_timeout_or_interval
(
&
self
handle
:
i32
)
{
self
.
timers
.
clear_timeout_or_interval
(
self
handle
)
}
pub
fn
fire_timer
(
&
self
handle
:
TimerEventId
)
{
self
.
timers
.
fire_timer
(
handle
self
)
}
pub
fn
resume
(
&
self
)
{
self
.
timers
.
resume
(
)
}
pub
fn
suspend
(
&
self
)
{
self
.
timers
.
suspend
(
)
}
pub
fn
slow_down_timers
(
&
self
)
{
self
.
timers
.
slow_down
(
)
}
pub
fn
speed_up_timers
(
&
self
)
{
self
.
timers
.
speed_up
(
)
}
fn
timer_source
(
&
self
)
-
>
TimerSource
{
if
self
.
is
:
:
<
Window
>
(
)
{
return
TimerSource
:
:
FromWindow
(
self
.
pipeline_id
(
)
)
;
}
if
self
.
is
:
:
<
WorkerGlobalScope
>
(
)
{
return
TimerSource
:
:
FromWorker
;
}
unreachable
!
(
)
;
}
pub
fn
task_canceller
(
&
self
)
-
>
TaskCanceller
{
if
let
Some
(
window
)
=
self
.
downcast
:
:
<
Window
>
(
)
{
return
window
.
task_canceller
(
)
;
}
if
let
Some
(
worker
)
=
self
.
downcast
:
:
<
WorkerGlobalScope
>
(
)
{
return
worker
.
task_canceller
(
)
;
}
unreachable
!
(
)
;
}
pub
fn
perform_a_microtask_checkpoint
(
&
self
)
{
self
.
microtask_queue
.
checkpoint
(
|
_
|
Some
(
Root
:
:
from_ref
(
self
)
)
)
;
}
pub
fn
enqueue_microtask
(
&
self
job
:
Microtask
)
{
self
.
microtask_queue
.
enqueue
(
job
)
;
}
pub
fn
new_script_pair
(
&
self
)
-
>
(
Box
<
ScriptChan
+
Send
>
Box
<
ScriptPort
+
Send
>
)
{
if
let
Some
(
window
)
=
self
.
downcast
:
:
<
Window
>
(
)
{
return
window
.
new_script_pair
(
)
;
}
if
let
Some
(
worker
)
=
self
.
downcast
:
:
<
WorkerGlobalScope
>
(
)
{
return
worker
.
new_script_pair
(
)
;
}
unreachable
!
(
)
;
}
pub
fn
microtask_queue
(
&
self
)
-
>
&
Rc
<
MicrotaskQueue
>
{
&
self
.
microtask_queue
}
pub
fn
process_event
(
&
self
msg
:
CommonScriptMsg
)
{
if
self
.
is
:
:
<
Window
>
(
)
{
return
ScriptThread
:
:
process_event
(
msg
)
;
}
if
let
Some
(
worker
)
=
self
.
downcast
:
:
<
WorkerGlobalScope
>
(
)
{
return
worker
.
process_event
(
msg
)
;
}
unreachable
!
(
)
;
}
pub
fn
file_reading_task_source
(
&
self
)
-
>
FileReadingTaskSource
{
if
let
Some
(
window
)
=
self
.
downcast
:
:
<
Window
>
(
)
{
return
window
.
file_reading_task_source
(
)
;
}
if
let
Some
(
worker
)
=
self
.
downcast
:
:
<
WorkerGlobalScope
>
(
)
{
return
worker
.
file_reading_task_source
(
)
;
}
unreachable
!
(
)
;
}
#
[
allow
(
unsafe_code
)
]
pub
fn
current
(
)
-
>
Option
<
Root
<
Self
>
>
{
unsafe
{
let
cx
=
Runtime
:
:
get
(
)
;
assert
!
(
!
cx
.
is_null
(
)
)
;
let
global
=
CurrentGlobalOrNull
(
cx
)
;
if
global
.
is_null
(
)
{
None
}
else
{
Some
(
global_scope_from_global
(
global
)
)
}
}
}
pub
fn
entry
(
)
-
>
Root
<
Self
>
{
entry_global
(
)
}
pub
fn
incumbent
(
)
-
>
Option
<
Root
<
Self
>
>
{
incumbent_global
(
)
}
pub
fn
performance
(
&
self
)
-
>
Root
<
Performance
>
{
if
let
Some
(
window
)
=
self
.
downcast
:
:
<
Window
>
(
)
{
return
window
.
Performance
(
)
;
}
if
let
Some
(
worker
)
=
self
.
downcast
:
:
<
WorkerGlobalScope
>
(
)
{
return
worker
.
Performance
(
)
;
}
unreachable
!
(
)
;
}
pub
fn
performance_timeline_task_source
(
&
self
)
-
>
PerformanceTimelineTaskSource
{
if
let
Some
(
window
)
=
self
.
downcast
:
:
<
Window
>
(
)
{
return
window
.
performance_timeline_task_source
(
)
;
}
if
let
Some
(
worker
)
=
self
.
downcast
:
:
<
WorkerGlobalScope
>
(
)
{
return
worker
.
performance_timeline_task_source
(
)
;
}
unreachable
!
(
)
;
}
}
fn
timestamp_in_ms
(
time
:
Timespec
)
-
>
u64
{
(
time
.
sec
*
1000
+
(
time
.
nsec
/
1000000
)
as
i64
)
as
u64
}
#
[
allow
(
unsafe_code
)
]
unsafe
fn
global_scope_from_global
(
global
:
*
mut
JSObject
)
-
>
Root
<
GlobalScope
>
{
assert
!
(
!
global
.
is_null
(
)
)
;
let
clasp
=
get_object_class
(
global
)
;
assert
!
(
(
(
*
clasp
)
.
flags
&
(
JSCLASS_IS_DOMJSCLASS
|
JSCLASS_IS_GLOBAL
)
)
!
=
0
)
;
root_from_object
(
global
)
.
unwrap
(
)
}
