use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
CSSConditionRuleBinding
:
:
CSSConditionRuleMethods
;
use
dom
:
:
bindings
:
:
inheritance
:
:
Castable
;
use
dom
:
:
bindings
:
:
str
:
:
DOMString
;
use
dom
:
:
cssgroupingrule
:
:
CSSGroupingRule
;
use
dom
:
:
cssmediarule
:
:
CSSMediaRule
;
use
dom
:
:
cssstylesheet
:
:
CSSStyleSheet
;
use
dom
:
:
csssupportsrule
:
:
CSSSupportsRule
;
use
dom_struct
:
:
dom_struct
;
use
parking_lot
:
:
RwLock
;
use
std
:
:
sync
:
:
Arc
;
use
style
:
:
stylesheets
:
:
CssRules
as
StyleCssRules
;
#
[
dom_struct
]
pub
struct
CSSConditionRule
{
cssgroupingrule
:
CSSGroupingRule
}
impl
CSSConditionRule
{
pub
fn
new_inherited
(
parent_stylesheet
:
&
CSSStyleSheet
rules
:
Arc
<
RwLock
<
StyleCssRules
>
>
)
-
>
CSSConditionRule
{
CSSConditionRule
{
cssgroupingrule
:
CSSGroupingRule
:
:
new_inherited
(
parent_stylesheet
rules
)
}
}
}
impl
CSSConditionRuleMethods
for
CSSConditionRule
{
fn
ConditionText
(
&
self
)
-
>
DOMString
{
if
let
Some
(
rule
)
=
self
.
downcast
:
:
<
CSSMediaRule
>
(
)
{
rule
.
get_condition_text
(
)
}
else
if
let
Some
(
rule
)
=
self
.
downcast
:
:
<
CSSSupportsRule
>
(
)
{
rule
.
get_condition_text
(
)
}
else
{
unreachable
!
(
)
}
}
fn
SetConditionText
(
&
self
text
:
DOMString
)
{
if
let
Some
(
rule
)
=
self
.
downcast
:
:
<
CSSMediaRule
>
(
)
{
rule
.
set_condition_text
(
text
)
}
else
if
let
Some
(
rule
)
=
self
.
downcast
:
:
<
CSSSupportsRule
>
(
)
{
rule
.
set_condition_text
(
text
)
}
else
{
unreachable
!
(
)
}
}
}
