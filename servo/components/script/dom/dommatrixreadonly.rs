use
dom
:
:
bindings
:
:
cell
:
:
DomRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
DOMMatrixBinding
:
:
{
DOMMatrixInit
DOMMatrixMethods
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
DOMMatrixReadOnlyBinding
:
:
{
DOMMatrixReadOnlyMethods
Wrap
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
DOMPointBinding
:
:
DOMPointInit
;
use
dom
:
:
bindings
:
:
error
;
use
dom
:
:
bindings
:
:
error
:
:
Fallible
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
reflect_dom_object
DomObject
Reflector
}
;
use
dom
:
:
bindings
:
:
root
:
:
DomRoot
;
use
dom
:
:
dommatrix
:
:
DOMMatrix
;
use
dom
:
:
dompoint
:
:
DOMPoint
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom_struct
:
:
dom_struct
;
use
euclid
:
:
{
Transform3D
Radians
}
;
use
std
:
:
cell
:
:
{
Cell
Ref
}
;
use
std
:
:
f64
;
#
[
dom_struct
]
pub
struct
DOMMatrixReadOnly
{
reflector_
:
Reflector
matrix
:
DomRefCell
<
Transform3D
<
f64
>
>
is2D
:
Cell
<
bool
>
}
impl
DOMMatrixReadOnly
{
#
[
allow
(
unrooted_must_root
)
]
pub
fn
new
(
global
:
&
GlobalScope
is2D
:
bool
matrix
:
Transform3D
<
f64
>
)
-
>
DomRoot
<
Self
>
{
let
dommatrix
=
Self
:
:
new_inherited
(
is2D
matrix
)
;
reflect_dom_object
(
Box
:
:
new
(
dommatrix
)
global
Wrap
)
}
pub
fn
new_inherited
(
is2D
:
bool
matrix
:
Transform3D
<
f64
>
)
-
>
Self
{
DOMMatrixReadOnly
{
reflector_
:
Reflector
:
:
new
(
)
matrix
:
DomRefCell
:
:
new
(
matrix
)
is2D
:
Cell
:
:
new
(
is2D
)
}
}
pub
fn
Constructor
(
global
:
&
GlobalScope
)
-
>
Fallible
<
DomRoot
<
Self
>
>
{
Ok
(
Self
:
:
new
(
global
true
Transform3D
:
:
identity
(
)
)
)
}
pub
fn
Constructor_
(
global
:
&
GlobalScope
entries
:
Vec
<
f64
>
)
-
>
Fallible
<
DomRoot
<
Self
>
>
{
entries_to_matrix
(
&
entries
[
.
.
]
)
.
map
(
|
(
is2D
matrix
)
|
{
Self
:
:
new
(
global
is2D
matrix
)
}
)
}
pub
fn
FromMatrix
(
global
:
&
GlobalScope
other
:
&
DOMMatrixInit
)
-
>
Fallible
<
DomRoot
<
Self
>
>
{
dommatrixinit_to_matrix
(
&
other
)
.
map
(
|
(
is2D
matrix
)
|
{
Self
:
:
new
(
global
is2D
matrix
)
}
)
}
pub
fn
matrix
(
&
self
)
-
>
Ref
<
Transform3D
<
f64
>
>
{
self
.
matrix
.
borrow
(
)
}
pub
fn
is_2d
(
&
self
)
-
>
bool
{
self
.
is2D
.
get
(
)
}
pub
fn
set_m11
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m11
=
value
;
}
pub
fn
set_m12
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m12
=
value
;
}
pub
fn
set_m13
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m13
=
value
;
}
pub
fn
set_m14
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m14
=
value
;
}
pub
fn
set_m21
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m21
=
value
;
}
pub
fn
set_m22
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m22
=
value
;
}
pub
fn
set_m23
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m23
=
value
;
}
pub
fn
set_m24
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m24
=
value
;
}
pub
fn
set_m31
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m31
=
value
;
}
pub
fn
set_m32
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m32
=
value
;
}
pub
fn
set_m33
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m33
=
value
;
}
pub
fn
set_m34
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m34
=
value
;
}
pub
fn
set_m41
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m41
=
value
;
}
pub
fn
set_m42
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m42
=
value
;
}
pub
fn
set_m43
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m43
=
value
;
}
pub
fn
set_m44
(
&
self
value
:
f64
)
{
self
.
matrix
.
borrow_mut
(
)
.
m44
=
value
;
}
pub
fn
multiply_self
(
&
self
other
:
&
DOMMatrixInit
)
-
>
Fallible
<
(
)
>
{
dommatrixinit_to_matrix
(
&
other
)
.
map
(
|
(
is2D
other_matrix
)
|
{
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
other_matrix
.
post_mul
(
&
matrix
)
;
if
!
is2D
{
self
.
is2D
.
set
(
false
)
;
}
}
)
}
pub
fn
pre_multiply_self
(
&
self
other
:
&
DOMMatrixInit
)
-
>
Fallible
<
(
)
>
{
dommatrixinit_to_matrix
(
&
other
)
.
map
(
|
(
is2D
other_matrix
)
|
{
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
other_matrix
.
pre_mul
(
&
matrix
)
;
if
!
is2D
{
self
.
is2D
.
set
(
false
)
;
}
}
)
}
pub
fn
translate_self
(
&
self
tx
:
f64
ty
:
f64
tz
:
f64
)
{
let
translation
=
Transform3D
:
:
create_translation
(
tx
ty
tz
)
;
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
translation
.
post_mul
(
&
matrix
)
;
if
tz
!
=
0
.
0
{
self
.
is2D
.
set
(
false
)
;
}
}
pub
fn
scale_self
(
&
self
scaleX
:
f64
scaleY
:
Option
<
f64
>
scaleZ
:
f64
mut
originX
:
f64
mut
originY
:
f64
mut
originZ
:
f64
)
{
self
.
translate_self
(
originX
originY
originZ
)
;
let
scaleY
=
scaleY
.
unwrap_or
(
scaleX
)
;
{
let
scale3D
=
Transform3D
:
:
create_scale
(
scaleX
scaleY
scaleZ
)
;
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
scale3D
.
post_mul
(
&
matrix
)
;
}
originX
=
-
originX
;
originY
=
-
originY
;
originZ
=
-
originZ
;
self
.
translate_self
(
originX
originY
originZ
)
;
if
scaleZ
!
=
1
.
0
|
|
originZ
!
=
0
.
0
{
self
.
is2D
.
set
(
false
)
;
}
}
pub
fn
scale_3d_self
(
&
self
scale
:
f64
originX
:
f64
originY
:
f64
originZ
:
f64
)
{
self
.
translate_self
(
originX
originY
originZ
)
;
{
let
scale3D
=
Transform3D
:
:
create_scale
(
scale
scale
scale
)
;
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
scale3D
.
post_mul
(
&
matrix
)
;
}
self
.
translate_self
(
-
originX
-
originY
-
originZ
)
;
if
scale
!
=
1
.
0
{
self
.
is2D
.
set
(
false
)
;
}
}
pub
fn
rotate_self
(
&
self
mut
rotX
:
f64
mut
rotY
:
Option
<
f64
>
mut
rotZ
:
Option
<
f64
>
)
{
if
rotY
.
is_none
(
)
&
&
rotZ
.
is_none
(
)
{
rotZ
=
Some
(
rotX
)
;
rotX
=
0
.
0
;
rotY
=
Some
(
0
.
0
)
;
}
let
rotY
=
rotY
.
unwrap_or
(
0
.
0
)
;
let
rotZ
=
rotZ
.
unwrap_or
(
0
.
0
)
;
if
rotX
!
=
0
.
0
|
|
rotY
!
=
0
.
0
{
self
.
is2D
.
set
(
false
)
;
}
if
rotZ
!
=
0
.
0
{
let
rotation
=
Transform3D
:
:
create_rotation
(
0
.
0
0
.
0
1
.
0
Radians
:
:
new
(
rotZ
.
to_radians
(
)
)
)
;
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
rotation
.
post_mul
(
&
matrix
)
;
}
if
rotY
!
=
0
.
0
{
let
rotation
=
Transform3D
:
:
create_rotation
(
0
.
0
1
.
0
0
.
0
Radians
:
:
new
(
rotY
.
to_radians
(
)
)
)
;
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
rotation
.
post_mul
(
&
matrix
)
;
}
if
rotX
!
=
0
.
0
{
let
rotation
=
Transform3D
:
:
create_rotation
(
1
.
0
0
.
0
0
.
0
Radians
:
:
new
(
rotX
.
to_radians
(
)
)
)
;
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
rotation
.
post_mul
(
&
matrix
)
;
}
}
pub
fn
rotate_from_vector_self
(
&
self
x
:
f64
y
:
f64
)
{
if
y
!
=
0
.
0
|
|
x
<
0
.
0
{
let
rotZ
=
Radians
:
:
new
(
f64
:
:
atan2
(
y
x
)
)
;
let
rotation
=
Transform3D
:
:
create_rotation
(
0
.
0
0
.
0
1
.
0
rotZ
)
;
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
rotation
.
post_mul
(
&
matrix
)
;
}
}
pub
fn
rotate_axis_angle_self
(
&
self
x
:
f64
y
:
f64
z
:
f64
angle
:
f64
)
{
let
(
norm_x
norm_y
norm_z
)
=
normalize_point
(
x
y
z
)
;
let
rotation
=
Transform3D
:
:
create_rotation
(
norm_x
norm_y
norm_z
Radians
:
:
new
(
angle
.
to_radians
(
)
)
)
;
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
rotation
.
post_mul
(
&
matrix
)
;
if
x
!
=
0
.
0
|
|
y
!
=
0
.
0
{
self
.
is2D
.
set
(
false
)
;
}
}
pub
fn
skew_x_self
(
&
self
sx
:
f64
)
{
let
skew
=
Transform3D
:
:
create_skew
(
Radians
:
:
new
(
sx
.
to_radians
(
)
)
Radians
:
:
new
(
0
.
0
)
)
;
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
skew
.
post_mul
(
&
matrix
)
;
}
pub
fn
skew_y_self
(
&
self
sy
:
f64
)
{
let
skew
=
Transform3D
:
:
create_skew
(
Radians
:
:
new
(
0
.
0
)
Radians
:
:
new
(
sy
.
to_radians
(
)
)
)
;
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
skew
.
post_mul
(
&
matrix
)
;
}
pub
fn
invert_self
(
&
self
)
{
let
mut
matrix
=
self
.
matrix
.
borrow_mut
(
)
;
*
matrix
=
matrix
.
inverse
(
)
.
unwrap_or_else
(
|
|
{
self
.
is2D
.
set
(
false
)
;
Transform3D
:
:
row_major
(
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
f64
:
:
NAN
)
}
)
}
}
impl
DOMMatrixReadOnlyMethods
for
DOMMatrixReadOnly
{
fn
M11
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m11
}
fn
M12
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m12
}
fn
M13
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m13
}
fn
M14
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m14
}
fn
M21
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m21
}
fn
M22
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m22
}
fn
M23
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m23
}
fn
M24
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m24
}
fn
M31
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m31
}
fn
M32
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m32
}
fn
M33
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m33
}
fn
M34
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m34
}
fn
M41
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m41
}
fn
M42
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m42
}
fn
M43
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m43
}
fn
M44
(
&
self
)
-
>
f64
{
self
.
matrix
.
borrow
(
)
.
m44
}
fn
A
(
&
self
)
-
>
f64
{
self
.
M11
(
)
}
fn
B
(
&
self
)
-
>
f64
{
self
.
M12
(
)
}
fn
C
(
&
self
)
-
>
f64
{
self
.
M21
(
)
}
fn
D
(
&
self
)
-
>
f64
{
self
.
M22
(
)
}
fn
E
(
&
self
)
-
>
f64
{
self
.
M41
(
)
}
fn
F
(
&
self
)
-
>
f64
{
self
.
M42
(
)
}
fn
Is2D
(
&
self
)
-
>
bool
{
self
.
is2D
.
get
(
)
}
fn
IsIdentity
(
&
self
)
-
>
bool
{
let
matrix
=
self
.
matrix
.
borrow
(
)
;
matrix
.
m12
=
=
0
.
0
&
&
matrix
.
m13
=
=
0
.
0
&
&
matrix
.
m14
=
=
0
.
0
&
&
matrix
.
m21
=
=
0
.
0
&
&
matrix
.
m23
=
=
0
.
0
&
&
matrix
.
m24
=
=
0
.
0
&
&
matrix
.
m31
=
=
0
.
0
&
&
matrix
.
m32
=
=
0
.
0
&
&
matrix
.
m34
=
=
0
.
0
&
&
matrix
.
m41
=
=
0
.
0
&
&
matrix
.
m42
=
=
0
.
0
&
&
matrix
.
m43
=
=
0
.
0
&
&
matrix
.
m11
=
=
1
.
0
&
&
matrix
.
m22
=
=
1
.
0
&
&
matrix
.
m33
=
=
1
.
0
&
&
matrix
.
m44
=
=
1
.
0
}
fn
Translate
(
&
self
tx
:
f64
ty
:
f64
tz
:
f64
)
-
>
DomRoot
<
DOMMatrix
>
{
DOMMatrix
:
:
from_readonly
(
&
self
.
global
(
)
self
)
.
TranslateSelf
(
tx
ty
tz
)
}
fn
Scale
(
&
self
scaleX
:
f64
scaleY
:
Option
<
f64
>
scaleZ
:
f64
originX
:
f64
originY
:
f64
originZ
:
f64
)
-
>
DomRoot
<
DOMMatrix
>
{
DOMMatrix
:
:
from_readonly
(
&
self
.
global
(
)
self
)
.
ScaleSelf
(
scaleX
scaleY
scaleZ
originX
originY
originZ
)
}
fn
Scale3d
(
&
self
scale
:
f64
originX
:
f64
originY
:
f64
originZ
:
f64
)
-
>
DomRoot
<
DOMMatrix
>
{
DOMMatrix
:
:
from_readonly
(
&
self
.
global
(
)
self
)
.
Scale3dSelf
(
scale
originX
originY
originZ
)
}
fn
Rotate
(
&
self
rotX
:
f64
rotY
:
Option
<
f64
>
rotZ
:
Option
<
f64
>
)
-
>
DomRoot
<
DOMMatrix
>
{
DOMMatrix
:
:
from_readonly
(
&
self
.
global
(
)
self
)
.
RotateSelf
(
rotX
rotY
rotZ
)
}
fn
RotateFromVector
(
&
self
x
:
f64
y
:
f64
)
-
>
DomRoot
<
DOMMatrix
>
{
DOMMatrix
:
:
from_readonly
(
&
self
.
global
(
)
self
)
.
RotateFromVectorSelf
(
x
y
)
}
fn
RotateAxisAngle
(
&
self
x
:
f64
y
:
f64
z
:
f64
angle
:
f64
)
-
>
DomRoot
<
DOMMatrix
>
{
DOMMatrix
:
:
from_readonly
(
&
self
.
global
(
)
self
)
.
RotateAxisAngleSelf
(
x
y
z
angle
)
}
fn
SkewX
(
&
self
sx
:
f64
)
-
>
DomRoot
<
DOMMatrix
>
{
DOMMatrix
:
:
from_readonly
(
&
self
.
global
(
)
self
)
.
SkewXSelf
(
sx
)
}
fn
SkewY
(
&
self
sy
:
f64
)
-
>
DomRoot
<
DOMMatrix
>
{
DOMMatrix
:
:
from_readonly
(
&
self
.
global
(
)
self
)
.
SkewYSelf
(
sy
)
}
fn
Multiply
(
&
self
other
:
&
DOMMatrixInit
)
-
>
Fallible
<
DomRoot
<
DOMMatrix
>
>
{
DOMMatrix
:
:
from_readonly
(
&
self
.
global
(
)
self
)
.
MultiplySelf
(
&
other
)
}
fn
FlipX
(
&
self
)
-
>
DomRoot
<
DOMMatrix
>
{
let
is2D
=
self
.
is2D
.
get
(
)
;
let
flip
=
Transform3D
:
:
row_major
(
-
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
)
;
let
matrix
=
flip
.
post_mul
(
&
self
.
matrix
.
borrow
(
)
)
;
DOMMatrix
:
:
new
(
&
self
.
global
(
)
is2D
matrix
)
}
fn
FlipY
(
&
self
)
-
>
DomRoot
<
DOMMatrix
>
{
let
is2D
=
self
.
is2D
.
get
(
)
;
let
flip
=
Transform3D
:
:
row_major
(
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
-
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
)
;
let
matrix
=
flip
.
post_mul
(
&
self
.
matrix
.
borrow
(
)
)
;
DOMMatrix
:
:
new
(
&
self
.
global
(
)
is2D
matrix
)
}
fn
Inverse
(
&
self
)
-
>
DomRoot
<
DOMMatrix
>
{
DOMMatrix
:
:
from_readonly
(
&
self
.
global
(
)
self
)
.
InvertSelf
(
)
}
fn
TransformPoint
(
&
self
point
:
&
DOMPointInit
)
-
>
DomRoot
<
DOMPoint
>
{
let
mat
=
self
.
matrix
.
borrow
(
)
;
let
x
=
point
.
x
*
mat
.
m11
+
point
.
y
*
mat
.
m21
+
point
.
z
*
mat
.
m31
+
point
.
w
*
mat
.
m41
;
let
y
=
point
.
x
*
mat
.
m12
+
point
.
y
*
mat
.
m22
+
point
.
z
*
mat
.
m32
+
point
.
w
*
mat
.
m42
;
let
z
=
point
.
x
*
mat
.
m13
+
point
.
y
*
mat
.
m23
+
point
.
z
*
mat
.
m33
+
point
.
w
*
mat
.
m43
;
let
w
=
point
.
x
*
mat
.
m14
+
point
.
y
*
mat
.
m24
+
point
.
z
*
mat
.
m34
+
point
.
w
*
mat
.
m44
;
DOMPoint
:
:
new
(
&
self
.
global
(
)
x
y
z
w
)
}
}
fn
create_2d_matrix
(
entries
:
&
[
f64
]
)
-
>
Transform3D
<
f64
>
{
Transform3D
:
:
row_major
(
entries
[
0
]
entries
[
1
]
0
.
0
0
.
0
entries
[
2
]
entries
[
3
]
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
0
.
0
entries
[
4
]
entries
[
5
]
0
.
0
1
.
0
)
}
fn
create_3d_matrix
(
entries
:
&
[
f64
]
)
-
>
Transform3D
<
f64
>
{
Transform3D
:
:
row_major
(
entries
[
0
]
entries
[
1
]
entries
[
2
]
entries
[
3
]
entries
[
4
]
entries
[
5
]
entries
[
6
]
entries
[
7
]
entries
[
8
]
entries
[
9
]
entries
[
10
]
entries
[
11
]
entries
[
12
]
entries
[
13
]
entries
[
14
]
entries
[
15
]
)
}
pub
fn
entries_to_matrix
(
entries
:
&
[
f64
]
)
-
>
Fallible
<
(
bool
Transform3D
<
f64
>
)
>
{
if
entries
.
len
(
)
=
=
6
{
Ok
(
(
true
create_2d_matrix
(
&
entries
)
)
)
}
else
if
entries
.
len
(
)
=
=
16
{
Ok
(
(
false
create_3d_matrix
(
&
entries
)
)
)
}
else
{
let
err_msg
=
format
!
(
"
Expected
6
or
16
entries
but
found
{
}
.
"
entries
.
len
(
)
)
;
Err
(
error
:
:
Error
:
:
Type
(
err_msg
.
to_owned
(
)
)
)
}
}
pub
fn
dommatrixinit_to_matrix
(
dict
:
&
DOMMatrixInit
)
-
>
Fallible
<
(
bool
Transform3D
<
f64
>
)
>
{
if
dict
.
a
.
is_some
(
)
&
&
dict
.
m11
.
is_some
(
)
&
&
dict
.
a
.
unwrap
(
)
!
=
dict
.
m11
.
unwrap
(
)
|
|
dict
.
b
.
is_some
(
)
&
&
dict
.
m12
.
is_some
(
)
&
&
dict
.
b
.
unwrap
(
)
!
=
dict
.
m12
.
unwrap
(
)
|
|
dict
.
c
.
is_some
(
)
&
&
dict
.
m21
.
is_some
(
)
&
&
dict
.
c
.
unwrap
(
)
!
=
dict
.
m21
.
unwrap
(
)
|
|
dict
.
d
.
is_some
(
)
&
&
dict
.
m22
.
is_some
(
)
&
&
dict
.
d
.
unwrap
(
)
!
=
dict
.
m22
.
unwrap
(
)
|
|
dict
.
e
.
is_some
(
)
&
&
dict
.
m41
.
is_some
(
)
&
&
dict
.
e
.
unwrap
(
)
!
=
dict
.
m41
.
unwrap
(
)
|
|
dict
.
f
.
is_some
(
)
&
&
dict
.
m42
.
is_some
(
)
&
&
dict
.
f
.
unwrap
(
)
!
=
dict
.
m42
.
unwrap
(
)
|
|
dict
.
is2D
.
is_some
(
)
&
&
dict
.
is2D
.
unwrap
(
)
&
&
(
dict
.
m31
!
=
0
.
0
|
|
dict
.
m32
!
=
0
.
0
|
|
dict
.
m13
!
=
0
.
0
|
|
dict
.
m23
!
=
0
.
0
|
|
dict
.
m43
!
=
0
.
0
|
|
dict
.
m14
!
=
0
.
0
|
|
dict
.
m24
!
=
0
.
0
|
|
dict
.
m34
!
=
0
.
0
|
|
dict
.
m33
!
=
1
.
0
|
|
dict
.
m44
!
=
1
.
0
)
{
Err
(
error
:
:
Error
:
:
Type
(
"
Invalid
matrix
initializer
.
"
.
to_owned
(
)
)
)
}
else
{
let
mut
is2D
=
dict
.
is2D
;
let
m11
=
dict
.
m11
.
unwrap_or
(
dict
.
a
.
unwrap_or
(
1
.
0
)
)
;
let
m12
=
dict
.
m12
.
unwrap_or
(
dict
.
b
.
unwrap_or
(
0
.
0
)
)
;
let
m21
=
dict
.
m21
.
unwrap_or
(
dict
.
c
.
unwrap_or
(
0
.
0
)
)
;
let
m22
=
dict
.
m22
.
unwrap_or
(
dict
.
d
.
unwrap_or
(
1
.
0
)
)
;
let
m41
=
dict
.
m41
.
unwrap_or
(
dict
.
e
.
unwrap_or
(
0
.
0
)
)
;
let
m42
=
dict
.
m42
.
unwrap_or
(
dict
.
f
.
unwrap_or
(
0
.
0
)
)
;
if
is2D
.
is_none
(
)
&
&
(
dict
.
m31
!
=
0
.
0
|
|
dict
.
m32
!
=
0
.
0
|
|
dict
.
m13
!
=
0
.
0
|
|
dict
.
m23
!
=
0
.
0
|
|
dict
.
m43
!
=
0
.
0
|
|
dict
.
m14
!
=
0
.
0
|
|
dict
.
m24
!
=
0
.
0
|
|
dict
.
m34
!
=
0
.
0
|
|
dict
.
m33
!
=
1
.
0
|
|
dict
.
m44
!
=
1
.
0
)
{
is2D
=
Some
(
false
)
;
}
if
is2D
.
is_none
(
)
{
is2D
=
Some
(
true
)
;
}
let
matrix
=
Transform3D
:
:
row_major
(
m11
m12
dict
.
m13
dict
.
m14
m21
m22
dict
.
m23
dict
.
m24
dict
.
m31
dict
.
m32
dict
.
m33
dict
.
m34
m41
m42
dict
.
m43
dict
.
m44
)
;
Ok
(
(
is2D
.
unwrap
(
)
matrix
)
)
}
}
#
[
inline
]
fn
normalize_point
(
x
:
f64
y
:
f64
z
:
f64
)
-
>
(
f64
f64
f64
)
{
let
len
=
(
x
*
x
+
y
*
y
+
z
*
z
)
.
sqrt
(
)
;
if
len
=
=
0
.
0
{
(
0
.
0
0
.
0
0
.
0
)
}
else
{
(
x
/
len
y
/
len
z
/
len
)
}
}
