use
bluetooth_traits
:
:
{
BluetoothError
BluetoothMethodMsg
}
;
use
bluetooth_traits
:
:
blacklist
:
:
{
Blacklist
uuid_is_blacklisted
}
;
use
bluetooth_traits
:
:
scanfilter
:
:
{
BluetoothScanfilter
BluetoothScanfilterSequence
}
;
use
bluetooth_traits
:
:
scanfilter
:
:
{
RequestDeviceoptions
ServiceUUIDSequence
}
;
use
core
:
:
clone
:
:
Clone
;
use
dom
:
:
bindings
:
:
cell
:
:
DOMRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
BluetoothBinding
:
:
{
self
BluetoothMethods
BluetoothRequestDeviceFilter
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
BluetoothBinding
:
:
RequestDeviceOptions
;
use
dom
:
:
bindings
:
:
error
:
:
Error
:
:
{
self
NotFound
Security
Type
}
;
use
dom
:
:
bindings
:
:
error
:
:
Fallible
;
use
dom
:
:
bindings
:
:
js
:
:
{
JS
MutHeap
Root
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
Reflectable
Reflector
reflect_dom_object
}
;
use
dom
:
:
bindings
:
:
str
:
:
DOMString
;
use
dom
:
:
bluetoothadvertisingdata
:
:
BluetoothAdvertisingData
;
use
dom
:
:
bluetoothdevice
:
:
BluetoothDevice
;
use
dom
:
:
bluetoothremotegattcharacteristic
:
:
BluetoothRemoteGATTCharacteristic
;
use
dom
:
:
bluetoothremotegattdescriptor
:
:
BluetoothRemoteGATTDescriptor
;
use
dom
:
:
bluetoothremotegattservice
:
:
BluetoothRemoteGATTService
;
use
dom
:
:
bluetoothuuid
:
:
{
BluetoothServiceUUID
BluetoothUUID
}
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom
:
:
promise
:
:
Promise
;
use
ipc_channel
:
:
ipc
:
:
{
self
IpcSender
}
;
use
js
:
:
conversions
:
:
ToJSValConvertible
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
rc
:
:
Rc
;
const
FILTER_EMPTY_ERROR
:
&
'
static
str
=
"
'
filters
'
member
if
present
must
be
nonempty
to
find
any
devices
.
"
;
const
FILTER_ERROR
:
&
'
static
str
=
"
A
filter
must
restrict
the
devices
in
some
way
.
"
;
const
MAX_DEVICE_NAME_LENGTH
:
usize
=
248
;
const
MAX_FILTER_NAME_LENGTH
:
usize
=
29
;
const
NAME_PREFIX_ERROR
:
&
'
static
str
=
"
'
namePrefix
'
if
present
must
be
nonempty
.
"
;
const
NAME_TOO_LONG_ERROR
:
&
'
static
str
=
"
A
device
name
can
'
t
be
longer
than
248
bytes
.
"
;
const
SERVICE_ERROR
:
&
'
static
str
=
"
'
services
'
if
present
must
contain
at
least
one
service
.
"
;
const
OPTIONS_ERROR
:
&
'
static
str
=
"
Fields
of
'
options
'
conflict
with
each
other
.
Either
'
acceptAllDevices
'
member
must
be
true
or
'
filters
'
member
must
be
set
to
a
value
.
"
;
#
[
dom_struct
]
pub
struct
Bluetooth
{
reflector_
:
Reflector
device_instance_map
:
DOMRefCell
<
HashMap
<
String
MutHeap
<
JS
<
BluetoothDevice
>
>
>
>
service_instance_map
:
DOMRefCell
<
HashMap
<
String
MutHeap
<
JS
<
BluetoothRemoteGATTService
>
>
>
>
characteristic_instance_map
:
DOMRefCell
<
HashMap
<
String
MutHeap
<
JS
<
BluetoothRemoteGATTCharacteristic
>
>
>
>
descriptor_instance_map
:
DOMRefCell
<
HashMap
<
String
MutHeap
<
JS
<
BluetoothRemoteGATTDescriptor
>
>
>
>
}
impl
Bluetooth
{
pub
fn
new_inherited
(
)
-
>
Bluetooth
{
Bluetooth
{
reflector_
:
Reflector
:
:
new
(
)
device_instance_map
:
DOMRefCell
:
:
new
(
HashMap
:
:
new
(
)
)
service_instance_map
:
DOMRefCell
:
:
new
(
HashMap
:
:
new
(
)
)
characteristic_instance_map
:
DOMRefCell
:
:
new
(
HashMap
:
:
new
(
)
)
descriptor_instance_map
:
DOMRefCell
:
:
new
(
HashMap
:
:
new
(
)
)
}
}
pub
fn
new
(
global
:
&
GlobalScope
)
-
>
Root
<
Bluetooth
>
{
reflect_dom_object
(
box
Bluetooth
:
:
new_inherited
(
)
global
BluetoothBinding
:
:
Wrap
)
}
pub
fn
get_service_map
(
&
self
)
-
>
&
DOMRefCell
<
HashMap
<
String
MutHeap
<
JS
<
BluetoothRemoteGATTService
>
>
>
>
{
&
self
.
service_instance_map
}
pub
fn
get_characteristic_map
(
&
self
)
-
>
&
DOMRefCell
<
HashMap
<
String
MutHeap
<
JS
<
BluetoothRemoteGATTCharacteristic
>
>
>
>
{
&
self
.
characteristic_instance_map
}
pub
fn
get_descriptor_map
(
&
self
)
-
>
&
DOMRefCell
<
HashMap
<
String
MutHeap
<
JS
<
BluetoothRemoteGATTDescriptor
>
>
>
>
{
&
self
.
descriptor_instance_map
}
fn
get_bluetooth_thread
(
&
self
)
-
>
IpcSender
<
BluetoothMethodMsg
>
{
self
.
global
(
)
.
as_window
(
)
.
bluetooth_thread
(
)
}
fn
request_device
(
&
self
option
:
&
RequestDeviceOptions
)
-
>
Fallible
<
Root
<
BluetoothDevice
>
>
{
if
(
option
.
filters
.
is_some
(
)
&
&
option
.
acceptAllDevices
)
|
|
(
option
.
filters
.
is_none
(
)
&
&
!
option
.
acceptAllDevices
)
{
return
Err
(
Type
(
OPTIONS_ERROR
.
to_owned
(
)
)
)
;
}
if
!
option
.
acceptAllDevices
{
return
self
.
request_bluetooth_devices
(
&
option
.
filters
&
option
.
optionalServices
)
;
}
self
.
request_bluetooth_devices
(
&
None
&
option
.
optionalServices
)
}
fn
request_bluetooth_devices
(
&
self
filters
:
&
Option
<
Vec
<
BluetoothRequestDeviceFilter
>
>
optional_services
:
&
Option
<
Vec
<
BluetoothServiceUUID
>
>
)
-
>
Fallible
<
Root
<
BluetoothDevice
>
>
{
let
option
=
try
!
(
convert_request_device_options
(
filters
optional_services
)
)
;
let
(
sender
receiver
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
self
.
get_bluetooth_thread
(
)
.
send
(
BluetoothMethodMsg
:
:
RequestDevice
(
option
sender
)
)
.
unwrap
(
)
;
let
device
=
receiver
.
recv
(
)
.
unwrap
(
)
;
match
device
{
Ok
(
device
)
=
>
{
let
mut
device_instance_map
=
self
.
device_instance_map
.
borrow_mut
(
)
;
if
let
Some
(
existing_device
)
=
device_instance_map
.
get
(
&
device
.
id
.
clone
(
)
)
{
return
Ok
(
existing_device
.
get
(
)
)
;
}
let
ad_data
=
BluetoothAdvertisingData
:
:
new
(
&
self
.
global
(
)
device
.
appearance
device
.
tx_power
device
.
rssi
)
;
let
bt_device
=
BluetoothDevice
:
:
new
(
&
self
.
global
(
)
DOMString
:
:
from
(
device
.
id
.
clone
(
)
)
device
.
name
.
map
(
DOMString
:
:
from
)
&
ad_data
&
self
)
;
device_instance_map
.
insert
(
device
.
id
MutHeap
:
:
new
(
&
bt_device
)
)
;
Ok
(
bt_device
)
}
Err
(
error
)
=
>
{
Err
(
Error
:
:
from
(
error
)
)
}
}
}
}
fn
convert_request_device_options
(
filters
:
&
Option
<
Vec
<
BluetoothRequestDeviceFilter
>
>
optional_services
:
&
Option
<
Vec
<
BluetoothServiceUUID
>
>
)
-
>
Fallible
<
RequestDeviceoptions
>
{
let
mut
uuid_filters
=
vec
!
(
)
;
if
let
&
Some
(
ref
filters
)
=
filters
{
if
filters
.
is_empty
(
)
{
return
Err
(
Type
(
FILTER_EMPTY_ERROR
.
to_owned
(
)
)
)
;
}
for
filter
in
filters
{
uuid_filters
.
push
(
try
!
(
canonicalize_filter
(
&
filter
)
)
)
;
}
}
let
mut
optional_services_uuids
=
vec
!
(
)
;
if
let
&
Some
(
ref
opt_services
)
=
optional_services
{
for
opt_service
in
opt_services
{
let
uuid
=
try
!
(
BluetoothUUID
:
:
service
(
opt_service
.
clone
(
)
)
)
.
to_string
(
)
;
if
!
uuid_is_blacklisted
(
uuid
.
as_ref
(
)
Blacklist
:
:
All
)
{
optional_services_uuids
.
push
(
uuid
)
;
}
}
}
Ok
(
RequestDeviceoptions
:
:
new
(
BluetoothScanfilterSequence
:
:
new
(
uuid_filters
)
ServiceUUIDSequence
:
:
new
(
optional_services_uuids
)
)
)
}
fn
canonicalize_filter
(
filter
:
&
BluetoothRequestDeviceFilter
)
-
>
Fallible
<
BluetoothScanfilter
>
{
if
filter
.
services
.
is_none
(
)
&
&
filter
.
name
.
is_none
(
)
&
&
filter
.
namePrefix
.
is_none
(
)
&
&
filter
.
manufacturerId
.
is_none
(
)
&
&
filter
.
serviceDataUUID
.
is_none
(
)
{
return
Err
(
Type
(
FILTER_ERROR
.
to_owned
(
)
)
)
;
}
let
services_vec
=
match
filter
.
services
{
Some
(
ref
services
)
=
>
{
if
services
.
is_empty
(
)
{
return
Err
(
Type
(
SERVICE_ERROR
.
to_owned
(
)
)
)
;
}
let
mut
services_vec
=
vec
!
(
)
;
for
service
in
services
{
let
uuid
=
try
!
(
BluetoothUUID
:
:
service
(
service
.
clone
(
)
)
)
.
to_string
(
)
;
if
uuid_is_blacklisted
(
uuid
.
as_ref
(
)
Blacklist
:
:
All
)
{
return
Err
(
Security
)
}
services_vec
.
push
(
uuid
)
;
}
services_vec
}
None
=
>
vec
!
(
)
}
;
let
name
=
match
filter
.
name
{
Some
(
ref
name
)
=
>
{
if
name
.
len
(
)
>
MAX_DEVICE_NAME_LENGTH
{
return
Err
(
Type
(
NAME_TOO_LONG_ERROR
.
to_owned
(
)
)
)
;
}
if
name
.
len
(
)
>
MAX_FILTER_NAME_LENGTH
{
return
Err
(
NotFound
)
;
}
Some
(
name
.
to_string
(
)
)
}
None
=
>
None
}
;
let
name_prefix
=
match
filter
.
namePrefix
{
Some
(
ref
name_prefix
)
=
>
{
if
name_prefix
.
is_empty
(
)
{
return
Err
(
Type
(
NAME_PREFIX_ERROR
.
to_owned
(
)
)
)
;
}
if
name_prefix
.
len
(
)
>
MAX_DEVICE_NAME_LENGTH
{
return
Err
(
Type
(
NAME_TOO_LONG_ERROR
.
to_owned
(
)
)
)
;
}
if
name_prefix
.
len
(
)
>
MAX_FILTER_NAME_LENGTH
{
return
Err
(
NotFound
)
;
}
name_prefix
.
to_string
(
)
}
None
=
>
String
:
:
new
(
)
}
;
let
manufacturer_id
=
filter
.
manufacturerId
;
let
service_data_uuid
=
match
filter
.
serviceDataUUID
{
Some
(
ref
service_data_uuid
)
=
>
{
let
uuid
=
try
!
(
BluetoothUUID
:
:
service
(
service_data_uuid
.
clone
(
)
)
)
.
to_string
(
)
;
if
uuid_is_blacklisted
(
uuid
.
as_ref
(
)
Blacklist
:
:
All
)
{
return
Err
(
Security
)
}
uuid
}
None
=
>
String
:
:
new
(
)
}
;
Ok
(
BluetoothScanfilter
:
:
new
(
name
name_prefix
services_vec
manufacturer_id
service_data_uuid
)
)
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
result_to_promise
<
T
:
ToJSValConvertible
>
(
global
:
&
GlobalScope
bluetooth_result
:
Fallible
<
T
>
)
-
>
Rc
<
Promise
>
{
let
p
=
Promise
:
:
new
(
global
)
;
match
bluetooth_result
{
Ok
(
v
)
=
>
p
.
resolve_native
(
p
.
global
(
)
.
get_cx
(
)
&
v
)
Err
(
e
)
=
>
p
.
reject_error
(
p
.
global
(
)
.
get_cx
(
)
e
)
}
p
}
impl
From
<
BluetoothError
>
for
Error
{
fn
from
(
error
:
BluetoothError
)
-
>
Self
{
match
error
{
BluetoothError
:
:
Type
(
message
)
=
>
Error
:
:
Type
(
message
)
BluetoothError
:
:
Network
=
>
Error
:
:
Network
BluetoothError
:
:
NotFound
=
>
Error
:
:
NotFound
BluetoothError
:
:
NotSupported
=
>
Error
:
:
NotSupported
BluetoothError
:
:
Security
=
>
Error
:
:
Security
BluetoothError
:
:
InvalidState
=
>
Error
:
:
InvalidState
}
}
}
impl
BluetoothMethods
for
Bluetooth
{
#
[
allow
(
unrooted_must_root
)
]
fn
RequestDevice
(
&
self
option
:
&
RequestDeviceOptions
)
-
>
Rc
<
Promise
>
{
result_to_promise
(
&
self
.
global
(
)
self
.
request_device
(
option
)
)
}
}
