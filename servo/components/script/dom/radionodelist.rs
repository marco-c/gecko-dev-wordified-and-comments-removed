use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
HTMLInputElementBinding
:
:
HTMLInputElementMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeListBinding
:
:
NodeListMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
RadioNodeListBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
RadioNodeListBinding
:
:
RadioNodeListMethods
;
use
dom
:
:
bindings
:
:
inheritance
:
:
Castable
;
use
dom
:
:
bindings
:
:
reflector
:
:
reflect_dom_object
;
use
dom
:
:
bindings
:
:
root
:
:
{
Dom
DomRoot
}
;
use
dom
:
:
bindings
:
:
str
:
:
DOMString
;
use
dom
:
:
htmlinputelement
:
:
{
HTMLInputElement
InputType
}
;
use
dom
:
:
node
:
:
Node
;
use
dom
:
:
nodelist
:
:
{
NodeList
NodeListType
}
;
use
dom
:
:
window
:
:
Window
;
use
dom_struct
:
:
dom_struct
;
#
[
dom_struct
]
pub
struct
RadioNodeList
{
node_list
:
NodeList
}
impl
RadioNodeList
{
#
[
allow
(
unrooted_must_root
)
]
fn
new_inherited
(
list_type
:
NodeListType
)
-
>
RadioNodeList
{
RadioNodeList
{
node_list
:
NodeList
:
:
new_inherited
(
list_type
)
}
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
new
(
window
:
&
Window
list_type
:
NodeListType
)
-
>
DomRoot
<
RadioNodeList
>
{
reflect_dom_object
(
Box
:
:
new
(
RadioNodeList
:
:
new_inherited
(
list_type
)
)
window
RadioNodeListBinding
:
:
Wrap
)
}
pub
fn
new_simple_list
<
T
>
(
window
:
&
Window
iter
:
T
)
-
>
DomRoot
<
RadioNodeList
>
where
T
:
Iterator
<
Item
=
DomRoot
<
Node
>
>
{
RadioNodeList
:
:
new
(
window
NodeListType
:
:
Simple
(
iter
.
map
(
|
r
|
Dom
:
:
from_ref
(
&
*
r
)
)
.
collect
(
)
)
)
}
pub
fn
Length
(
&
self
)
-
>
u32
{
self
.
node_list
.
Length
(
)
}
}
impl
RadioNodeListMethods
for
RadioNodeList
{
fn
Value
(
&
self
)
-
>
DOMString
{
self
.
upcast
:
:
<
NodeList
>
(
)
.
as_simple_list
(
)
.
iter
(
)
.
filter_map
(
|
node
|
{
node
.
downcast
:
:
<
HTMLInputElement
>
(
)
.
and_then
(
|
input
|
{
if
input
.
input_type
(
)
=
=
InputType
:
:
Radio
&
&
input
.
Checked
(
)
{
let
value
=
input
.
Value
(
)
;
Some
(
if
value
.
is_empty
(
)
{
DOMString
:
:
from
(
"
on
"
)
}
else
{
value
}
)
}
else
{
None
}
}
)
}
)
.
next
(
)
.
unwrap_or
(
DOMString
:
:
from
(
"
"
)
)
}
fn
SetValue
(
&
self
value
:
DOMString
)
{
for
node
in
self
.
upcast
:
:
<
NodeList
>
(
)
.
as_simple_list
(
)
.
iter
(
)
{
if
let
Some
(
input
)
=
node
.
downcast
:
:
<
HTMLInputElement
>
(
)
{
match
input
.
input_type
(
)
{
InputType
:
:
Radio
if
value
=
=
DOMString
:
:
from
(
"
on
"
)
=
>
{
let
val
=
input
.
Value
(
)
;
if
val
.
is_empty
(
)
|
|
val
=
=
value
{
input
.
SetChecked
(
true
)
;
return
;
}
}
InputType
:
:
Radio
=
>
{
if
input
.
Value
(
)
=
=
value
{
input
.
SetChecked
(
true
)
;
return
;
}
}
_
=
>
{
}
}
}
}
}
fn
IndexedGetter
(
&
self
index
:
u32
)
-
>
Option
<
DomRoot
<
Node
>
>
{
self
.
node_list
.
IndexedGetter
(
index
)
}
}
