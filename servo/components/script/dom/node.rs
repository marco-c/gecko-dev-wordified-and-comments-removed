use
dom
:
:
attr
:
:
{
Attr
AttrHelpers
}
;
use
dom
:
:
bindings
:
:
cell
:
:
DOMRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
CharacterDataBinding
:
:
CharacterDataMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
DocumentBinding
:
:
DocumentMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
ElementBinding
:
:
ElementMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NamedNodeMapBinding
:
:
NamedNodeMapMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeBinding
:
:
{
NodeConstants
NodeMethods
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeListBinding
:
:
NodeListMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
ProcessingInstructionBinding
:
:
ProcessingInstructionMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
InheritTypes
:
:
{
CommentCast
DocumentCast
DocumentTypeCast
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
InheritTypes
:
:
{
ElementCast
TextCast
NodeCast
ElementDerived
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
InheritTypes
:
:
{
CharacterDataCast
NodeBase
NodeDerived
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
InheritTypes
:
:
{
ProcessingInstructionCast
EventTargetCast
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
InheritTypes
:
:
{
HTMLLegendElementDerived
HTMLFieldSetElementDerived
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
InheritTypes
:
:
HTMLOptGroupElementDerived
;
use
dom
:
:
bindings
:
:
conversions
;
use
dom
:
:
bindings
:
:
error
:
:
Fallible
;
use
dom
:
:
bindings
:
:
error
:
:
Error
:
:
{
NotFound
HierarchyRequest
Syntax
}
;
use
dom
:
:
bindings
:
:
global
:
:
GlobalRef
;
use
dom
:
:
bindings
:
:
js
:
:
{
JS
JSRef
LayoutJS
RootedReference
Temporary
Root
Unrooted
}
;
use
dom
:
:
bindings
:
:
js
:
:
{
TemporaryPushable
OptionalRootedRootable
}
;
use
dom
:
:
bindings
:
:
js
:
:
{
ResultRootable
OptionalRootable
MutNullableJS
}
;
use
dom
:
:
bindings
:
:
trace
:
:
JSTraceable
;
use
dom
:
:
bindings
:
:
trace
:
:
RootedVec
;
use
dom
:
:
bindings
:
:
utils
:
:
{
Reflectable
reflect_dom_object
}
;
use
dom
:
:
characterdata
:
:
CharacterData
;
use
dom
:
:
comment
:
:
Comment
;
use
dom
:
:
document
:
:
{
Document
DocumentHelpers
IsHTMLDocument
DocumentSource
}
;
use
dom
:
:
documentfragment
:
:
DocumentFragment
;
use
dom
:
:
documenttype
:
:
DocumentType
;
use
dom
:
:
element
:
:
{
AttributeHandlers
Element
ElementCreator
ElementTypeId
}
;
use
dom
:
:
element
:
:
ElementHelpers
;
use
dom
:
:
eventtarget
:
:
{
EventTarget
EventTargetTypeId
}
;
use
dom
:
:
htmlelement
:
:
HTMLElementTypeId
;
use
dom
:
:
nodelist
:
:
NodeList
;
use
dom
:
:
processinginstruction
:
:
ProcessingInstruction
;
use
dom
:
:
text
:
:
Text
;
use
dom
:
:
virtualmethods
:
:
{
VirtualMethods
vtable_for
}
;
use
dom
:
:
window
:
:
{
Window
WindowHelpers
}
;
use
geom
:
:
rect
:
:
Rect
;
use
layout_interface
:
:
{
LayoutChan
Msg
}
;
use
devtools_traits
:
:
NodeInfo
;
use
parse
:
:
html
:
:
parse_html_fragment
;
use
script_traits
:
:
UntrustedNodeAddress
;
use
util
:
:
geometry
:
:
Au
;
use
util
:
:
str
:
:
{
DOMString
null_str_as_empty
}
;
use
selectors
:
:
parser
:
:
{
Selector
AttrSelector
NamespaceConstraint
}
;
use
selectors
:
:
parser
:
:
parse_author_origin_selector_list_from_str
;
use
selectors
:
:
matching
:
:
matches
;
use
style
:
:
properties
:
:
ComputedValues
;
use
style
;
use
js
:
:
jsapi
:
:
{
JSContext
JSObject
JSRuntime
}
;
use
js
:
:
jsfriendapi
;
use
core
:
:
nonzero
:
:
NonZero
;
use
libc
;
use
libc
:
:
{
uintptr_t
c_void
}
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
cell
:
:
{
Cell
RefCell
Ref
RefMut
}
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
iter
:
:
{
FilterMap
Peekable
}
;
use
std
:
:
mem
;
use
std
:
:
sync
:
:
Arc
;
use
uuid
;
use
string_cache
:
:
QualName
;
#
[
dom_struct
]
pub
struct
Node
{
eventtarget
:
EventTarget
type_id
:
NodeTypeId
parent_node
:
MutNullableJS
<
Node
>
first_child
:
MutNullableJS
<
Node
>
last_child
:
MutNullableJS
<
Node
>
next_sibling
:
MutNullableJS
<
Node
>
prev_sibling
:
MutNullableJS
<
Node
>
owner_doc
:
MutNullableJS
<
Document
>
child_list
:
MutNullableJS
<
NodeList
>
flags
:
Cell
<
NodeFlags
>
layout_data
:
LayoutDataRef
unique_id
:
DOMRefCell
<
String
>
}
impl
NodeDerived
for
EventTarget
{
fn
is_node
(
&
self
)
-
>
bool
{
match
*
self
.
type_id
(
)
{
EventTargetTypeId
:
:
Node
(
_
)
=
>
true
_
=
>
false
}
}
}
bitflags
!
{
#
[
doc
=
"
Flags
for
node
items
.
"
]
#
[
jstraceable
]
flags
NodeFlags
:
u16
{
#
[
doc
=
"
Specifies
whether
this
node
is
in
a
document
.
"
]
const
IS_IN_DOC
=
0x01
#
[
doc
=
"
Specifies
whether
this
node
is
in
hover
state
.
"
]
const
IN_HOVER_STATE
=
0x02
#
[
doc
=
"
Specifies
whether
this
node
is
in
disabled
state
.
"
]
const
IN_DISABLED_STATE
=
0x04
#
[
doc
=
"
Specifies
whether
this
node
is
in
enabled
state
.
"
]
const
IN_ENABLED_STATE
=
0x08
#
[
doc
=
"
Specifies
whether
this
node
_must_
be
reflowed
regardless
of
style
differences
.
"
]
const
HAS_CHANGED
=
0x10
#
[
doc
=
"
Specifies
whether
this
node
needs
style
recalc
on
next
reflow
.
"
]
const
IS_DIRTY
=
0x20
#
[
doc
=
"
Specifies
whether
this
node
has
siblings
(
inclusive
of
itself
)
which
\
changed
since
the
last
reflow
.
"
]
const
HAS_DIRTY_SIBLINGS
=
0x40
#
[
doc
=
"
Specifies
whether
this
node
has
descendants
(
inclusive
of
itself
)
which
\
have
changed
since
the
last
reflow
.
"
]
const
HAS_DIRTY_DESCENDANTS
=
0x80
/
/
TODO
:
find
a
better
place
to
keep
this
(
#
4105
)
/
/
https
:
/
/
critic
.
hoppipolla
.
co
.
uk
/
showcomment
?
chain
=
8873
/
/
Perhaps
using
a
Set
in
Document
?
#
[
doc
=
"
Specifies
whether
or
not
there
is
an
authentic
click
in
progress
on
\
this
element
.
"
]
const
CLICK_IN_PROGRESS
=
0x100
#
[
doc
=
"
Specifies
whether
this
node
has
the
focus
.
"
]
const
IN_FOCUS_STATE
=
0x200
}
}
impl
NodeFlags
{
pub
fn
new
(
type_id
:
NodeTypeId
)
-
>
NodeFlags
{
let
dirty
=
HAS_CHANGED
|
IS_DIRTY
|
HAS_DIRTY_SIBLINGS
|
HAS_DIRTY_DESCENDANTS
;
match
type_id
{
NodeTypeId
:
:
Document
=
>
IS_IN_DOC
|
dirty
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLButtonElement
)
)
|
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLInputElement
)
)
|
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLSelectElement
)
)
|
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLTextAreaElement
)
)
|
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLOptGroupElement
)
)
|
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLOptionElement
)
)
|
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLFieldSetElement
)
)
=
>
IN_ENABLED_STATE
|
dirty
_
=
>
dirty
}
}
}
#
[
unsafe_destructor
]
impl
Drop
for
Node
{
#
[
allow
(
unsafe_code
)
]
fn
drop
(
&
mut
self
)
{
self
.
layout_data
.
dispose
(
)
;
}
}
#
[
derive
(
Copy
)
]
enum
SuppressObserver
{
Suppressed
Unsuppressed
}
pub
struct
SharedLayoutData
{
pub
style
:
Option
<
Arc
<
ComputedValues
>
>
}
pub
struct
LayoutData
{
chan
:
Option
<
LayoutChan
>
_shared_data
:
SharedLayoutData
_data
:
NonZero
<
*
const
(
)
>
}
#
[
allow
(
unsafe_code
)
]
unsafe
impl
Send
for
LayoutData
{
}
pub
struct
LayoutDataRef
{
pub
data_cell
:
RefCell
<
Option
<
LayoutData
>
>
}
no_jsmanaged_fields
!
(
LayoutDataRef
)
;
impl
LayoutDataRef
{
pub
fn
new
(
)
-
>
LayoutDataRef
{
LayoutDataRef
{
data_cell
:
RefCell
:
:
new
(
None
)
}
}
pub
fn
dispose
(
&
self
)
{
if
let
Some
(
mut
layout_data
)
=
mem
:
:
replace
(
&
mut
*
self
.
borrow_mut
(
)
None
)
{
let
layout_chan
=
layout_data
.
chan
.
take
(
)
;
match
layout_chan
{
None
=
>
{
}
Some
(
chan
)
=
>
{
let
LayoutChan
(
chan
)
=
chan
;
chan
.
send
(
Msg
:
:
ReapLayoutData
(
layout_data
)
)
.
unwrap
(
)
}
}
}
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
pub
unsafe
fn
borrow_unchecked
(
&
self
)
-
>
*
const
Option
<
LayoutData
>
{
mem
:
:
transmute
(
&
self
.
data_cell
)
}
#
[
inline
]
pub
fn
borrow
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
Option
<
LayoutData
>
>
{
self
.
data_cell
.
borrow
(
)
}
#
[
inline
]
pub
fn
borrow_mut
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
Option
<
LayoutData
>
>
{
self
.
data_cell
.
borrow_mut
(
)
}
}
#
[
derive
(
Copy
PartialEq
Debug
)
]
#
[
jstraceable
]
pub
enum
NodeTypeId
{
DocumentType
DocumentFragment
Comment
Document
Element
(
ElementTypeId
)
Text
ProcessingInstruction
}
trait
PrivateNodeHelpers
{
fn
node_inserted
(
self
)
;
fn
node_removed
(
self
parent_in_doc
:
bool
)
;
fn
add_child
(
self
new_child
:
JSRef
<
Node
>
before
:
Option
<
JSRef
<
Node
>
>
)
;
fn
remove_child
(
self
child
:
JSRef
<
Node
>
)
;
}
impl
<
'
a
>
PrivateNodeHelpers
for
JSRef
<
'
a
Node
>
{
fn
node_inserted
(
self
)
{
assert
!
(
self
.
parent_node
(
)
.
is_some
(
)
)
;
let
document
=
document_from_node
(
self
)
.
root
(
)
;
let
is_in_doc
=
self
.
is_in_doc
(
)
;
for
node
in
self
.
traverse_preorder
(
)
{
vtable_for
(
&
node
)
.
bind_to_tree
(
is_in_doc
)
;
}
let
parent
=
self
.
parent_node
(
)
.
root
(
)
;
parent
.
map
(
|
parent
|
vtable_for
(
&
parent
.
r
(
)
)
.
child_inserted
(
self
)
)
;
document
.
r
(
)
.
content_and_heritage_changed
(
self
NodeDamage
:
:
OtherNodeDamage
)
;
}
fn
node_removed
(
self
parent_in_doc
:
bool
)
{
assert
!
(
self
.
parent_node
(
)
.
is_none
(
)
)
;
for
node
in
self
.
traverse_preorder
(
)
{
vtable_for
(
&
node
)
.
unbind_from_tree
(
parent_in_doc
)
;
}
self
.
layout_data
.
dispose
(
)
;
}
fn
add_child
(
self
new_child
:
JSRef
<
Node
>
before
:
Option
<
JSRef
<
Node
>
>
)
{
assert
!
(
new_child
.
parent_node
(
)
.
is_none
(
)
)
;
assert
!
(
new_child
.
prev_sibling
(
)
.
is_none
(
)
)
;
assert
!
(
new_child
.
next_sibling
(
)
.
is_none
(
)
)
;
match
before
{
Some
(
ref
before
)
=
>
{
assert
!
(
before
.
parent_node
(
)
.
root
(
)
.
r
(
)
=
=
Some
(
self
)
)
;
match
before
.
prev_sibling
(
)
.
root
(
)
{
None
=
>
{
assert
!
(
Some
(
*
before
)
=
=
self
.
first_child
(
)
.
root
(
)
.
r
(
)
)
;
self
.
first_child
.
assign
(
Some
(
new_child
)
)
;
}
Some
(
prev_sibling
)
=
>
{
prev_sibling
.
r
(
)
.
next_sibling
.
assign
(
Some
(
new_child
)
)
;
new_child
.
prev_sibling
.
assign
(
Some
(
prev_sibling
.
r
(
)
)
)
;
}
}
before
.
prev_sibling
.
assign
(
Some
(
new_child
)
)
;
new_child
.
next_sibling
.
assign
(
Some
(
*
before
)
)
;
}
None
=
>
{
match
self
.
last_child
(
)
.
root
(
)
{
None
=
>
self
.
first_child
.
assign
(
Some
(
new_child
)
)
Some
(
last_child
)
=
>
{
assert
!
(
last_child
.
r
(
)
.
next_sibling
(
)
.
is_none
(
)
)
;
last_child
.
r
(
)
.
next_sibling
.
assign
(
Some
(
new_child
)
)
;
new_child
.
prev_sibling
.
assign
(
Some
(
last_child
.
r
(
)
)
)
;
}
}
self
.
last_child
.
assign
(
Some
(
new_child
)
)
;
}
}
new_child
.
parent_node
.
assign
(
Some
(
self
)
)
;
}
fn
remove_child
(
self
child
:
JSRef
<
Node
>
)
{
assert
!
(
child
.
parent_node
(
)
.
root
(
)
.
r
(
)
=
=
Some
(
self
)
)
;
match
child
.
prev_sibling
.
get
(
)
.
root
(
)
{
None
=
>
{
self
.
first_child
.
assign
(
child
.
next_sibling
.
get
(
)
)
;
}
Some
(
prev_sibling
)
=
>
{
prev_sibling
.
r
(
)
.
next_sibling
.
assign
(
child
.
next_sibling
.
get
(
)
)
;
}
}
match
child
.
next_sibling
.
get
(
)
.
root
(
)
{
None
=
>
{
self
.
last_child
.
assign
(
child
.
prev_sibling
.
get
(
)
)
;
}
Some
(
next_sibling
)
=
>
{
next_sibling
.
r
(
)
.
prev_sibling
.
assign
(
child
.
prev_sibling
.
get
(
)
)
;
}
}
child
.
prev_sibling
.
clear
(
)
;
child
.
next_sibling
.
clear
(
)
;
child
.
parent_node
.
clear
(
)
;
}
}
pub
struct
QuerySelectorIterator
<
'
a
>
{
selectors
:
Vec
<
Selector
>
iterator
:
TreeIterator
<
'
a
>
}
impl
<
'
a
>
QuerySelectorIterator
<
'
a
>
{
#
[
allow
(
unsafe_code
)
]
unsafe
fn
new
(
iter
:
TreeIterator
<
'
a
>
selectors
:
Vec
<
Selector
>
)
-
>
QuerySelectorIterator
<
'
a
>
{
QuerySelectorIterator
{
selectors
:
selectors
iterator
:
iter
}
}
}
impl
<
'
a
>
Iterator
for
QuerySelectorIterator
<
'
a
>
{
type
Item
=
JSRef
<
'
a
Node
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
JSRef
<
'
a
Node
>
>
{
let
selectors
=
&
self
.
selectors
;
self
.
iterator
.
find
(
|
node
|
node
.
is_element
(
)
&
&
matches
(
selectors
node
&
mut
None
)
)
}
}
pub
trait
NodeHelpers
<
'
a
>
{
fn
ancestors
(
self
)
-
>
AncestorIterator
;
fn
inclusive_ancestors
(
self
)
-
>
AncestorIterator
;
fn
children
(
self
)
-
>
NodeChildrenIterator
;
fn
rev_children
(
self
)
-
>
ReverseChildrenIterator
;
fn
child_elements
(
self
)
-
>
ChildElementIterator
;
fn
following_siblings
(
self
)
-
>
NodeChildrenIterator
;
fn
is_in_doc
(
self
)
-
>
bool
;
fn
is_inclusive_ancestor_of
(
self
parent
:
JSRef
<
Node
>
)
-
>
bool
;
fn
is_parent_of
(
self
child
:
JSRef
<
Node
>
)
-
>
bool
;
fn
type_id
(
self
)
-
>
NodeTypeId
;
fn
parent_node
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
;
fn
first_child
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
;
fn
last_child
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
;
fn
prev_sibling
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
;
fn
next_sibling
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
;
fn
owner_doc
(
self
)
-
>
Temporary
<
Document
>
;
fn
set_owner_doc
(
self
document
:
JSRef
<
Document
>
)
;
fn
is_in_html_doc
(
self
)
-
>
bool
;
fn
is_element
(
self
)
-
>
bool
;
fn
is_document
(
self
)
-
>
bool
;
fn
is_doctype
(
self
)
-
>
bool
;
fn
is_text
(
self
)
-
>
bool
;
fn
is_anchor_element
(
self
)
-
>
bool
;
fn
get_flag
(
self
flag
:
NodeFlags
)
-
>
bool
;
fn
set_flag
(
self
flag
:
NodeFlags
value
:
bool
)
;
fn
get_hover_state
(
self
)
-
>
bool
;
fn
set_hover_state
(
self
state
:
bool
)
;
fn
get_focus_state
(
self
)
-
>
bool
;
fn
set_focus_state
(
self
state
:
bool
)
;
fn
get_disabled_state
(
self
)
-
>
bool
;
fn
set_disabled_state
(
self
state
:
bool
)
;
fn
get_enabled_state
(
self
)
-
>
bool
;
fn
set_enabled_state
(
self
state
:
bool
)
;
fn
get_has_changed
(
self
)
-
>
bool
;
fn
set_has_changed
(
self
state
:
bool
)
;
fn
get_is_dirty
(
self
)
-
>
bool
;
fn
set_is_dirty
(
self
state
:
bool
)
;
fn
get_has_dirty_siblings
(
self
)
-
>
bool
;
fn
set_has_dirty_siblings
(
self
state
:
bool
)
;
fn
get_has_dirty_descendants
(
self
)
-
>
bool
;
fn
set_has_dirty_descendants
(
self
state
:
bool
)
;
fn
dirty
(
self
damage
:
NodeDamage
)
;
fn
force_dirty_ancestors
(
self
damage
:
NodeDamage
)
;
fn
dirty_impl
(
self
damage
:
NodeDamage
force_ancestors
:
bool
)
;
fn
dump
(
self
)
;
fn
dump_indent
(
self
indent
:
u32
)
;
fn
debug_str
(
self
)
-
>
String
;
fn
traverse_preorder
(
self
)
-
>
TreeIterator
<
'
a
>
;
fn
inclusively_following_siblings
(
self
)
-
>
NodeChildrenIterator
;
fn
to_trusted_node_address
(
self
)
-
>
TrustedNodeAddress
;
fn
get_bounding_content_box
(
self
)
-
>
Rect
<
Au
>
;
fn
get_content_boxes
(
self
)
-
>
Vec
<
Rect
<
Au
>
>
;
fn
query_selector
(
self
selectors
:
DOMString
)
-
>
Fallible
<
Option
<
Temporary
<
Element
>
>
>
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
query_selector_iter
(
self
selectors
:
DOMString
)
-
>
Fallible
<
QuerySelectorIterator
<
'
a
>
>
;
fn
query_selector_all
(
self
selectors
:
DOMString
)
-
>
Fallible
<
Temporary
<
NodeList
>
>
;
fn
remove_self
(
self
)
;
fn
get_unique_id
(
self
)
-
>
String
;
fn
summarize
(
self
)
-
>
NodeInfo
;
fn
teardown
(
self
)
;
fn
parse_fragment
(
self
markup
:
DOMString
)
-
>
Fallible
<
Temporary
<
DocumentFragment
>
>
;
}
impl
<
'
a
>
NodeHelpers
<
'
a
>
for
JSRef
<
'
a
Node
>
{
fn
teardown
(
self
)
{
self
.
layout_data
.
dispose
(
)
;
for
kid
in
self
.
children
(
)
{
let
kid
=
kid
.
root
(
)
;
kid
.
r
(
)
.
teardown
(
)
;
}
}
fn
dump
(
self
)
{
self
.
dump_indent
(
0
)
;
}
fn
dump_indent
(
self
indent
:
u32
)
{
let
mut
s
=
String
:
:
new
(
)
;
for
_
in
0
.
.
indent
{
s
.
push_str
(
"
"
)
;
}
s
.
push_str
(
self
.
debug_str
(
)
.
as_slice
(
)
)
;
debug
!
(
"
{
:
?
}
"
s
)
;
for
kid
in
self
.
children
(
)
{
let
kid
=
kid
.
root
(
)
;
kid
.
r
(
)
.
dump_indent
(
indent
+
1
)
}
}
fn
debug_str
(
self
)
-
>
String
{
format
!
(
"
{
:
?
}
"
self
.
type_id
)
}
fn
is_in_doc
(
self
)
-
>
bool
{
self
.
flags
.
get
(
)
.
contains
(
IS_IN_DOC
)
}
fn
type_id
(
self
)
-
>
NodeTypeId
{
self
.
type_id
}
fn
parent_node
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
self
.
parent_node
.
get
(
)
}
fn
first_child
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
self
.
first_child
.
get
(
)
}
fn
last_child
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
self
.
last_child
.
get
(
)
}
fn
prev_sibling
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
self
.
prev_sibling
.
get
(
)
}
fn
next_sibling
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
self
.
next_sibling
.
get
(
)
}
#
[
inline
]
fn
is_element
(
self
)
-
>
bool
{
match
self
.
type_id
{
NodeTypeId
:
:
Element
(
.
.
)
=
>
true
_
=
>
false
}
}
#
[
inline
]
fn
is_document
(
self
)
-
>
bool
{
self
.
type_id
=
=
NodeTypeId
:
:
Document
}
#
[
inline
]
fn
is_anchor_element
(
self
)
-
>
bool
{
self
.
type_id
=
=
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLAnchorElement
)
)
}
#
[
inline
]
fn
is_doctype
(
self
)
-
>
bool
{
self
.
type_id
=
=
NodeTypeId
:
:
DocumentType
}
#
[
inline
]
fn
is_text
(
self
)
-
>
bool
{
self
.
type_id
=
=
NodeTypeId
:
:
Text
}
fn
get_flag
(
self
flag
:
NodeFlags
)
-
>
bool
{
self
.
flags
.
get
(
)
.
contains
(
flag
)
}
fn
set_flag
(
self
flag
:
NodeFlags
value
:
bool
)
{
let
mut
flags
=
self
.
flags
.
get
(
)
;
if
value
{
flags
.
insert
(
flag
)
;
}
else
{
flags
.
remove
(
flag
)
;
}
self
.
flags
.
set
(
flags
)
;
}
fn
get_hover_state
(
self
)
-
>
bool
{
self
.
get_flag
(
IN_HOVER_STATE
)
}
fn
set_hover_state
(
self
state
:
bool
)
{
self
.
set_flag
(
IN_HOVER_STATE
state
)
}
fn
get_focus_state
(
self
)
-
>
bool
{
self
.
get_flag
(
IN_FOCUS_STATE
)
}
fn
set_focus_state
(
self
state
:
bool
)
{
self
.
set_flag
(
IN_FOCUS_STATE
state
)
}
fn
get_disabled_state
(
self
)
-
>
bool
{
self
.
get_flag
(
IN_DISABLED_STATE
)
}
fn
set_disabled_state
(
self
state
:
bool
)
{
self
.
set_flag
(
IN_DISABLED_STATE
state
)
}
fn
get_enabled_state
(
self
)
-
>
bool
{
self
.
get_flag
(
IN_ENABLED_STATE
)
}
fn
set_enabled_state
(
self
state
:
bool
)
{
self
.
set_flag
(
IN_ENABLED_STATE
state
)
}
fn
get_has_changed
(
self
)
-
>
bool
{
self
.
get_flag
(
HAS_CHANGED
)
}
fn
set_has_changed
(
self
state
:
bool
)
{
self
.
set_flag
(
HAS_CHANGED
state
)
}
fn
get_is_dirty
(
self
)
-
>
bool
{
self
.
get_flag
(
IS_DIRTY
)
}
fn
set_is_dirty
(
self
state
:
bool
)
{
self
.
set_flag
(
IS_DIRTY
state
)
}
fn
get_has_dirty_siblings
(
self
)
-
>
bool
{
self
.
get_flag
(
HAS_DIRTY_SIBLINGS
)
}
fn
set_has_dirty_siblings
(
self
state
:
bool
)
{
self
.
set_flag
(
HAS_DIRTY_SIBLINGS
state
)
}
fn
get_has_dirty_descendants
(
self
)
-
>
bool
{
self
.
get_flag
(
HAS_DIRTY_DESCENDANTS
)
}
fn
set_has_dirty_descendants
(
self
state
:
bool
)
{
self
.
set_flag
(
HAS_DIRTY_DESCENDANTS
state
)
}
fn
force_dirty_ancestors
(
self
damage
:
NodeDamage
)
{
self
.
dirty_impl
(
damage
true
)
}
fn
dirty
(
self
damage
:
NodeDamage
)
{
self
.
dirty_impl
(
damage
false
)
}
fn
dirty_impl
(
self
damage
:
NodeDamage
force_ancestors
:
bool
)
{
match
damage
{
NodeDamage
:
:
NodeStyleDamaged
=
>
{
}
NodeDamage
:
:
OtherNodeDamage
=
>
self
.
set_has_changed
(
true
)
}
if
self
.
get_is_dirty
(
)
&
&
!
force_ancestors
{
return
}
fn
dirty_subtree
(
node
:
JSRef
<
Node
>
)
{
if
node
.
get_is_dirty
(
)
{
return
}
node
.
set_flag
(
IS_DIRTY
|
HAS_DIRTY_SIBLINGS
|
HAS_DIRTY_DESCENDANTS
true
)
;
for
kid
in
node
.
children
(
)
{
let
kid
=
kid
.
root
(
)
;
dirty_subtree
(
kid
.
r
(
)
)
;
}
}
dirty_subtree
(
self
)
;
if
!
self
.
get_has_dirty_siblings
(
)
{
let
parent
=
match
self
.
parent_node
(
)
{
None
=
>
return
Some
(
parent
)
=
>
parent
}
;
for
sibling
in
parent
.
root
(
)
.
r
(
)
.
children
(
)
{
let
sibling
=
sibling
.
root
(
)
;
sibling
.
r
(
)
.
set_has_dirty_siblings
(
true
)
;
}
}
for
ancestor
in
self
.
ancestors
(
)
{
let
ancestor
=
ancestor
.
root
(
)
;
if
!
force_ancestors
&
&
ancestor
.
r
(
)
.
get_has_dirty_descendants
(
)
{
break
}
ancestor
.
r
(
)
.
set_has_dirty_descendants
(
true
)
;
}
}
fn
traverse_preorder
(
self
)
-
>
TreeIterator
<
'
a
>
{
TreeIterator
:
:
new
(
self
)
}
fn
inclusively_following_siblings
(
self
)
-
>
NodeChildrenIterator
{
NodeChildrenIterator
{
current
:
Some
(
Temporary
:
:
from_rooted
(
self
)
)
}
}
fn
is_inclusive_ancestor_of
(
self
parent
:
JSRef
<
Node
>
)
-
>
bool
{
self
=
=
parent
|
|
parent
.
ancestors
(
)
.
any
(
|
ancestor
|
ancestor
.
root
(
)
.
r
(
)
=
=
self
)
}
fn
following_siblings
(
self
)
-
>
NodeChildrenIterator
{
NodeChildrenIterator
{
current
:
self
.
next_sibling
(
)
}
}
fn
is_parent_of
(
self
child
:
JSRef
<
Node
>
)
-
>
bool
{
match
child
.
parent_node
(
)
{
Some
(
ref
parent
)
if
parent
=
=
&
Temporary
:
:
from_rooted
(
self
)
=
>
true
_
=
>
false
}
}
fn
to_trusted_node_address
(
self
)
-
>
TrustedNodeAddress
{
TrustedNodeAddress
(
&
*
self
as
*
const
Node
as
*
const
libc
:
:
c_void
)
}
fn
get_bounding_content_box
(
self
)
-
>
Rect
<
Au
>
{
window_from_node
(
self
)
.
root
(
)
.
r
(
)
.
content_box_query
(
self
.
to_trusted_node_address
(
)
)
}
fn
get_content_boxes
(
self
)
-
>
Vec
<
Rect
<
Au
>
>
{
window_from_node
(
self
)
.
root
(
)
.
r
(
)
.
content_boxes_query
(
self
.
to_trusted_node_address
(
)
)
}
fn
query_selector
(
self
selectors
:
DOMString
)
-
>
Fallible
<
Option
<
Temporary
<
Element
>
>
>
{
match
parse_author_origin_selector_list_from_str
(
selectors
.
as_slice
(
)
)
{
Err
(
(
)
)
=
>
return
Err
(
Syntax
)
Ok
(
ref
selectors
)
=
>
{
let
root
=
self
.
ancestors
(
)
.
last
(
)
.
root
(
)
;
let
root
=
root
.
r
(
)
.
unwrap_or
(
self
.
clone
(
)
)
;
Ok
(
root
.
traverse_preorder
(
)
.
filter_map
(
ElementCast
:
:
to_ref
)
.
find
(
|
element
|
matches
(
selectors
&
NodeCast
:
:
from_ref
(
*
element
)
&
mut
None
)
)
.
map
(
Temporary
:
:
from_rooted
)
)
}
}
}
#
[
allow
(
unsafe_code
)
]
unsafe
fn
query_selector_iter
(
self
selectors
:
DOMString
)
-
>
Fallible
<
QuerySelectorIterator
<
'
a
>
>
{
let
nodes
;
let
root
=
self
.
ancestors
(
)
.
last
(
)
.
root
(
)
.
map
(
|
node
|
node
.
get_unsound_ref_forever
(
)
)
.
unwrap_or
(
self
.
clone
(
)
)
;
match
parse_author_origin_selector_list_from_str
(
selectors
.
as_slice
(
)
)
{
Err
(
(
)
)
=
>
return
Err
(
Syntax
)
Ok
(
selectors
)
=
>
{
nodes
=
QuerySelectorIterator
:
:
new
(
root
.
traverse_preorder
(
)
selectors
)
;
}
}
;
Ok
(
nodes
)
}
#
[
allow
(
unsafe_code
)
]
fn
query_selector_all
(
self
selectors
:
DOMString
)
-
>
Fallible
<
Temporary
<
NodeList
>
>
{
unsafe
{
self
.
query_selector_iter
(
selectors
)
.
map
(
|
iter
|
{
let
window
=
window_from_node
(
self
)
.
root
(
)
;
NodeList
:
:
new_simple_list
(
window
.
r
(
)
iter
.
collect
(
)
)
}
)
}
}
fn
ancestors
(
self
)
-
>
AncestorIterator
{
AncestorIterator
{
current
:
self
.
parent_node
(
)
}
}
fn
inclusive_ancestors
(
self
)
-
>
AncestorIterator
{
AncestorIterator
{
current
:
Some
(
Temporary
:
:
from_rooted
(
self
)
)
}
}
fn
owner_doc
(
self
)
-
>
Temporary
<
Document
>
{
self
.
owner_doc
.
get
(
)
.
unwrap
(
)
}
fn
set_owner_doc
(
self
document
:
JSRef
<
Document
>
)
{
self
.
owner_doc
.
assign
(
Some
(
document
.
clone
(
)
)
)
;
}
fn
is_in_html_doc
(
self
)
-
>
bool
{
self
.
owner_doc
(
)
.
root
(
)
.
r
(
)
.
is_html_document
(
)
}
fn
children
(
self
)
-
>
NodeChildrenIterator
{
NodeChildrenIterator
{
current
:
self
.
first_child
.
get
(
)
}
}
fn
rev_children
(
self
)
-
>
ReverseChildrenIterator
{
ReverseChildrenIterator
{
current
:
self
.
last_child
(
)
}
}
fn
child_elements
(
self
)
-
>
ChildElementIterator
{
self
.
children
(
)
.
filter_map
(
ElementCast
:
:
to_temporary
as
fn
(
_
)
-
>
_
)
.
peekable
(
)
}
fn
remove_self
(
self
)
{
match
self
.
parent_node
(
)
.
root
(
)
{
Some
(
parent
)
=
>
parent
.
r
(
)
.
remove_child
(
self
)
None
=
>
(
)
}
}
fn
get_unique_id
(
self
)
-
>
String
{
let
id
=
self
.
unique_id
.
borrow
(
)
;
id
.
clone
(
)
}
fn
summarize
(
self
)
-
>
NodeInfo
{
if
self
.
unique_id
.
borrow
(
)
.
is_empty
(
)
{
let
mut
unique_id
=
self
.
unique_id
.
borrow_mut
(
)
;
*
unique_id
=
uuid
:
:
Uuid
:
:
new_v4
(
)
.
to_simple_string
(
)
;
}
let
unique_id
=
self
.
unique_id
.
borrow
(
)
;
NodeInfo
{
uniqueId
:
unique_id
.
clone
(
)
baseURI
:
self
.
GetBaseURI
(
)
.
unwrap_or
(
"
"
.
to_owned
(
)
)
parent
:
self
.
GetParentNode
(
)
.
root
(
)
.
map
(
|
node
|
node
.
r
(
)
.
get_unique_id
(
)
)
.
unwrap_or
(
"
"
.
to_owned
(
)
)
nodeType
:
self
.
NodeType
(
)
namespaceURI
:
"
"
.
to_owned
(
)
nodeName
:
self
.
NodeName
(
)
numChildren
:
self
.
ChildNodes
(
)
.
root
(
)
.
r
(
)
.
Length
(
)
as
usize
name
:
"
"
.
to_owned
(
)
publicId
:
"
"
.
to_owned
(
)
systemId
:
"
"
.
to_owned
(
)
attrs
:
{
let
e
:
Option
<
JSRef
<
Element
>
>
=
ElementCast
:
:
to_ref
(
self
)
;
match
e
{
Some
(
element
)
=
>
element
.
summarize
(
)
None
=
>
vec
!
(
)
}
}
isDocumentElement
:
self
.
owner_doc
(
)
.
root
(
)
.
r
(
)
.
GetDocumentElement
(
)
.
map
(
|
elem
|
NodeCast
:
:
from_ref
(
elem
.
root
(
)
.
r
(
)
)
=
=
self
)
.
unwrap_or
(
false
)
shortValue
:
self
.
GetNodeValue
(
)
.
unwrap_or
(
"
"
.
to_owned
(
)
)
incompleteValue
:
false
}
}
fn
parse_fragment
(
self
markup
:
DOMString
)
-
>
Fallible
<
Temporary
<
DocumentFragment
>
>
{
let
context_node
:
JSRef
<
Node
>
=
NodeCast
:
:
from_ref
(
self
)
;
let
context_document
=
document_from_node
(
self
)
.
root
(
)
;
let
mut
new_children
:
RootedVec
<
JS
<
Node
>
>
=
RootedVec
:
:
new
(
)
;
if
context_document
.
r
(
)
.
is_html_document
(
)
{
parse_html_fragment
(
context_node
markup
&
mut
new_children
)
;
}
else
{
unimplemented
!
(
)
;
}
let
fragment
=
DocumentFragment
:
:
new
(
context_document
.
r
(
)
)
.
root
(
)
;
let
fragment_node
:
JSRef
<
Node
>
=
NodeCast
:
:
from_ref
(
fragment
.
r
(
)
)
;
for
node
in
new_children
.
iter
(
)
{
fragment_node
.
AppendChild
(
node
.
root
(
)
.
r
(
)
)
.
unwrap
(
)
;
}
Ok
(
Temporary
:
:
from_rooted
(
fragment
.
r
(
)
)
)
}
}
#
[
allow
(
unsafe_code
)
]
pub
fn
from_untrusted_node_address
(
runtime
:
*
mut
JSRuntime
candidate
:
UntrustedNodeAddress
)
-
>
Temporary
<
Node
>
{
unsafe
{
let
candidate
:
uintptr_t
=
mem
:
:
transmute
(
candidate
.
0
)
;
let
object
:
*
mut
JSObject
=
jsfriendapi
:
:
bindgen
:
:
JS_GetAddressableObject
(
runtime
candidate
)
;
if
object
.
is_null
(
)
{
panic
!
(
"
Attempted
to
create
a
JS
<
Node
>
from
an
invalid
pointer
!
"
)
}
let
boxed_node
:
*
const
Node
=
conversions
:
:
native_from_reflector
(
object
)
;
Temporary
:
:
from_unrooted
(
Unrooted
:
:
from_raw
(
boxed_node
)
)
}
}
pub
trait
LayoutNodeHelpers
{
#
[
allow
(
unsafe_code
)
]
unsafe
fn
type_id_for_layout
(
&
self
)
-
>
NodeTypeId
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
parent_node_ref
(
&
self
)
-
>
Option
<
LayoutJS
<
Node
>
>
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
first_child_ref
(
&
self
)
-
>
Option
<
LayoutJS
<
Node
>
>
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
last_child_ref
(
&
self
)
-
>
Option
<
LayoutJS
<
Node
>
>
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
prev_sibling_ref
(
&
self
)
-
>
Option
<
LayoutJS
<
Node
>
>
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
next_sibling_ref
(
&
self
)
-
>
Option
<
LayoutJS
<
Node
>
>
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
owner_doc_for_layout
(
&
self
)
-
>
LayoutJS
<
Document
>
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
is_element_for_layout
(
&
self
)
-
>
bool
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
get_flag
(
self
flag
:
NodeFlags
)
-
>
bool
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
set_flag
(
self
flag
:
NodeFlags
value
:
bool
)
;
}
impl
LayoutNodeHelpers
for
LayoutJS
<
Node
>
{
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
type_id_for_layout
(
&
self
)
-
>
NodeTypeId
{
(
*
self
.
unsafe_get
(
)
)
.
type_id
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
is_element_for_layout
(
&
self
)
-
>
bool
{
(
*
self
.
unsafe_get
(
)
)
.
is_element
(
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
parent_node_ref
(
&
self
)
-
>
Option
<
LayoutJS
<
Node
>
>
{
(
*
self
.
unsafe_get
(
)
)
.
parent_node
.
get_inner_as_layout
(
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
first_child_ref
(
&
self
)
-
>
Option
<
LayoutJS
<
Node
>
>
{
(
*
self
.
unsafe_get
(
)
)
.
first_child
.
get_inner_as_layout
(
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
last_child_ref
(
&
self
)
-
>
Option
<
LayoutJS
<
Node
>
>
{
(
*
self
.
unsafe_get
(
)
)
.
last_child
.
get_inner_as_layout
(
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
prev_sibling_ref
(
&
self
)
-
>
Option
<
LayoutJS
<
Node
>
>
{
(
*
self
.
unsafe_get
(
)
)
.
prev_sibling
.
get_inner_as_layout
(
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
next_sibling_ref
(
&
self
)
-
>
Option
<
LayoutJS
<
Node
>
>
{
(
*
self
.
unsafe_get
(
)
)
.
next_sibling
.
get_inner_as_layout
(
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
owner_doc_for_layout
(
&
self
)
-
>
LayoutJS
<
Document
>
{
(
*
self
.
unsafe_get
(
)
)
.
owner_doc
.
get_inner_as_layout
(
)
.
unwrap
(
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
get_flag
(
self
flag
:
NodeFlags
)
-
>
bool
{
(
*
self
.
unsafe_get
(
)
)
.
flags
.
get
(
)
.
contains
(
flag
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
set_flag
(
self
flag
:
NodeFlags
value
:
bool
)
{
let
this
=
self
.
unsafe_get
(
)
;
let
mut
flags
=
(
*
this
)
.
flags
.
get
(
)
;
if
value
{
flags
.
insert
(
flag
)
;
}
else
{
flags
.
remove
(
flag
)
;
}
(
*
this
)
.
flags
.
set
(
flags
)
;
}
}
pub
trait
RawLayoutNodeHelpers
{
#
[
allow
(
unsafe_code
)
]
unsafe
fn
get_hover_state_for_layout
(
&
self
)
-
>
bool
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
get_focus_state_for_layout
(
&
self
)
-
>
bool
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
get_disabled_state_for_layout
(
&
self
)
-
>
bool
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
get_enabled_state_for_layout
(
&
self
)
-
>
bool
;
fn
type_id_for_layout
(
&
self
)
-
>
NodeTypeId
;
}
impl
RawLayoutNodeHelpers
for
Node
{
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
get_hover_state_for_layout
(
&
self
)
-
>
bool
{
self
.
flags
.
get
(
)
.
contains
(
IN_HOVER_STATE
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
get_focus_state_for_layout
(
&
self
)
-
>
bool
{
self
.
flags
.
get
(
)
.
contains
(
IN_FOCUS_STATE
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
get_disabled_state_for_layout
(
&
self
)
-
>
bool
{
self
.
flags
.
get
(
)
.
contains
(
IN_DISABLED_STATE
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
get_enabled_state_for_layout
(
&
self
)
-
>
bool
{
self
.
flags
.
get
(
)
.
contains
(
IN_ENABLED_STATE
)
}
#
[
inline
]
fn
type_id_for_layout
(
&
self
)
-
>
NodeTypeId
{
self
.
type_id
}
}
pub
type
ChildElementIterator
=
Peekable
<
FilterMap
<
NodeChildrenIterator
fn
(
Temporary
<
Node
>
)
-
>
Option
<
Temporary
<
Element
>
>
>
>
;
pub
struct
NodeChildrenIterator
{
current
:
Option
<
Temporary
<
Node
>
>
}
impl
Iterator
for
NodeChildrenIterator
{
type
Item
=
Temporary
<
Node
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
let
current
=
match
self
.
current
.
take
(
)
{
None
=
>
return
None
Some
(
current
)
=
>
current
}
.
root
(
)
;
self
.
current
=
current
.
r
(
)
.
next_sibling
(
)
;
Some
(
Temporary
:
:
from_rooted
(
current
.
r
(
)
)
)
}
}
pub
struct
ReverseChildrenIterator
{
current
:
Option
<
Temporary
<
Node
>
>
}
impl
Iterator
for
ReverseChildrenIterator
{
type
Item
=
Temporary
<
Node
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
let
current
=
match
self
.
current
.
take
(
)
{
None
=
>
return
None
Some
(
current
)
=
>
current
}
.
root
(
)
;
self
.
current
=
current
.
r
(
)
.
prev_sibling
(
)
;
Some
(
Temporary
:
:
from_rooted
(
current
.
r
(
)
)
)
}
}
pub
struct
AncestorIterator
{
current
:
Option
<
Temporary
<
Node
>
>
}
impl
Iterator
for
AncestorIterator
{
type
Item
=
Temporary
<
Node
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
let
current
=
match
self
.
current
.
take
(
)
{
None
=
>
return
None
Some
(
current
)
=
>
current
}
.
root
(
)
;
self
.
current
=
current
.
r
(
)
.
parent_node
(
)
;
Some
(
Temporary
:
:
from_rooted
(
current
.
r
(
)
)
)
}
}
pub
struct
TreeIterator
<
'
a
>
{
stack
:
Vec
<
JSRef
<
'
a
Node
>
>
}
impl
<
'
a
>
TreeIterator
<
'
a
>
{
fn
new
(
root
:
JSRef
<
'
a
Node
>
)
-
>
TreeIterator
<
'
a
>
{
let
mut
stack
=
vec
!
(
)
;
stack
.
push
(
root
)
;
TreeIterator
{
stack
:
stack
}
}
}
impl
<
'
a
>
Iterator
for
TreeIterator
<
'
a
>
{
type
Item
=
JSRef
<
'
a
Node
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
JSRef
<
'
a
Node
>
>
{
let
ret
=
self
.
stack
.
pop
(
)
;
ret
.
map
(
|
node
|
{
self
.
stack
.
extend
(
node
.
rev_children
(
)
.
map
(
|
c
|
c
.
root
(
)
.
get_unsound_ref_forever
(
)
)
)
}
)
;
ret
}
}
#
[
derive
(
Copy
PartialEq
)
]
pub
enum
CloneChildrenFlag
{
CloneChildren
DoNotCloneChildren
}
fn
as_uintptr
<
T
>
(
t
:
&
T
)
-
>
uintptr_t
{
t
as
*
const
T
as
uintptr_t
}
impl
Node
{
pub
fn
reflect_node
<
N
:
Reflectable
+
NodeBase
>
(
node
:
Box
<
N
>
document
:
JSRef
<
Document
>
wrap_fn
:
extern
"
Rust
"
fn
(
*
mut
JSContext
GlobalRef
Box
<
N
>
)
-
>
Temporary
<
N
>
)
-
>
Temporary
<
N
>
{
let
window
=
document
.
window
(
)
.
root
(
)
;
reflect_dom_object
(
node
GlobalRef
:
:
Window
(
window
.
r
(
)
)
wrap_fn
)
}
pub
fn
new_inherited
(
type_id
:
NodeTypeId
doc
:
JSRef
<
Document
>
)
-
>
Node
{
Node
:
:
new_
(
type_id
Some
(
doc
.
clone
(
)
)
)
}
pub
fn
new_without_doc
(
type_id
:
NodeTypeId
)
-
>
Node
{
Node
:
:
new_
(
type_id
None
)
}
fn
new_
(
type_id
:
NodeTypeId
doc
:
Option
<
JSRef
<
Document
>
>
)
-
>
Node
{
Node
{
eventtarget
:
EventTarget
:
:
new_inherited
(
EventTargetTypeId
:
:
Node
(
type_id
)
)
type_id
:
type_id
parent_node
:
Default
:
:
default
(
)
first_child
:
Default
:
:
default
(
)
last_child
:
Default
:
:
default
(
)
next_sibling
:
Default
:
:
default
(
)
prev_sibling
:
Default
:
:
default
(
)
owner_doc
:
MutNullableJS
:
:
new
(
doc
)
child_list
:
Default
:
:
default
(
)
flags
:
Cell
:
:
new
(
NodeFlags
:
:
new
(
type_id
)
)
layout_data
:
LayoutDataRef
:
:
new
(
)
unique_id
:
DOMRefCell
:
:
new
(
String
:
:
new
(
)
)
}
}
#
[
inline
]
pub
fn
layout_data
(
&
self
)
-
>
Ref
<
Option
<
LayoutData
>
>
{
self
.
layout_data
.
borrow
(
)
}
#
[
inline
]
pub
fn
layout_data_mut
(
&
self
)
-
>
RefMut
<
Option
<
LayoutData
>
>
{
self
.
layout_data
.
borrow_mut
(
)
}
#
[
inline
]
#
[
allow
(
unsafe_code
)
]
pub
unsafe
fn
layout_data_unchecked
(
&
self
)
-
>
*
const
Option
<
LayoutData
>
{
self
.
layout_data
.
borrow_unchecked
(
)
}
pub
fn
adopt
(
node
:
JSRef
<
Node
>
document
:
JSRef
<
Document
>
)
{
match
node
.
parent_node
(
)
.
root
(
)
{
Some
(
parent
)
=
>
{
Node
:
:
remove
(
node
parent
.
r
(
)
SuppressObserver
:
:
Unsuppressed
)
;
}
None
=
>
(
)
}
let
node_doc
=
document_from_node
(
node
)
.
root
(
)
;
if
node_doc
.
r
(
)
!
=
document
{
for
descendant
in
node
.
traverse_preorder
(
)
{
descendant
.
set_owner_doc
(
document
)
;
}
}
}
fn
pre_insert
(
node
:
JSRef
<
Node
>
parent
:
JSRef
<
Node
>
child
:
Option
<
JSRef
<
Node
>
>
)
-
>
Fallible
<
Temporary
<
Node
>
>
{
match
parent
.
type_id
(
)
{
NodeTypeId
:
:
Document
|
NodeTypeId
:
:
DocumentFragment
|
NodeTypeId
:
:
Element
(
.
.
)
=
>
(
)
_
=
>
return
Err
(
HierarchyRequest
)
}
if
node
.
is_inclusive_ancestor_of
(
parent
)
{
return
Err
(
HierarchyRequest
)
;
}
if
let
Some
(
child
)
=
child
{
if
!
parent
.
is_parent_of
(
child
)
{
return
Err
(
NotFound
)
;
}
}
match
node
.
type_id
(
)
{
NodeTypeId
:
:
Text
=
>
{
if
parent
.
is_document
(
)
{
return
Err
(
HierarchyRequest
)
;
}
}
NodeTypeId
:
:
DocumentType
=
>
{
if
!
parent
.
is_document
(
)
{
return
Err
(
HierarchyRequest
)
;
}
}
NodeTypeId
:
:
DocumentFragment
|
NodeTypeId
:
:
Element
(
_
)
|
NodeTypeId
:
:
ProcessingInstruction
|
NodeTypeId
:
:
Comment
=
>
(
)
NodeTypeId
:
:
Document
=
>
return
Err
(
HierarchyRequest
)
}
match
parent
.
type_id
(
)
{
NodeTypeId
:
:
Document
=
>
{
match
node
.
type_id
(
)
{
NodeTypeId
:
:
DocumentFragment
=
>
{
if
node
.
children
(
)
.
map
(
|
c
|
c
.
root
(
)
)
.
any
(
|
c
|
c
.
r
(
)
.
is_text
(
)
)
{
return
Err
(
HierarchyRequest
)
;
}
match
node
.
child_elements
(
)
.
count
(
)
{
0
=
>
(
)
1
=
>
{
if
!
parent
.
child_elements
(
)
.
is_empty
(
)
{
return
Err
(
HierarchyRequest
)
;
}
if
let
Some
(
child
)
=
child
{
if
child
.
inclusively_following_siblings
(
)
.
map
(
|
c
|
c
.
root
(
)
)
.
any
(
|
child
|
child
.
r
(
)
.
is_doctype
(
)
)
{
return
Err
(
HierarchyRequest
)
;
}
}
}
_
=
>
return
Err
(
HierarchyRequest
)
}
}
NodeTypeId
:
:
Element
(
_
)
=
>
{
if
!
parent
.
child_elements
(
)
.
is_empty
(
)
{
return
Err
(
HierarchyRequest
)
;
}
if
let
Some
(
ref
child
)
=
child
{
if
child
.
inclusively_following_siblings
(
)
.
map
(
|
c
|
c
.
root
(
)
)
.
any
(
|
child
|
child
.
r
(
)
.
is_doctype
(
)
)
{
return
Err
(
HierarchyRequest
)
;
}
}
}
NodeTypeId
:
:
DocumentType
=
>
{
if
parent
.
children
(
)
.
map
(
|
c
|
c
.
root
(
)
)
.
any
(
|
c
|
c
.
r
(
)
.
is_doctype
(
)
)
{
return
Err
(
HierarchyRequest
)
;
}
match
child
{
Some
(
child
)
=
>
{
if
parent
.
children
(
)
.
map
(
|
c
|
c
.
root
(
)
)
.
take_while
(
|
c
|
c
.
r
(
)
!
=
child
)
.
any
(
|
c
|
c
.
r
(
)
.
is_element
(
)
)
{
return
Err
(
HierarchyRequest
)
;
}
}
None
=
>
{
if
!
parent
.
child_elements
(
)
.
is_empty
(
)
{
return
Err
(
HierarchyRequest
)
;
}
}
}
}
NodeTypeId
:
:
Text
|
NodeTypeId
:
:
ProcessingInstruction
|
NodeTypeId
:
:
Comment
=
>
(
)
NodeTypeId
:
:
Document
=
>
unreachable
!
(
)
}
}
_
=
>
(
)
}
let
reference_child
=
match
child
{
Some
(
child
)
if
child
=
=
node
=
>
node
.
next_sibling
(
)
.
map
(
|
node
|
node
.
root
(
)
.
get_unsound_ref_forever
(
)
)
_
=
>
child
}
;
let
document
=
document_from_node
(
parent
)
.
root
(
)
;
Node
:
:
adopt
(
node
document
.
r
(
)
)
;
Node
:
:
insert
(
node
parent
reference_child
SuppressObserver
:
:
Unsuppressed
)
;
return
Ok
(
Temporary
:
:
from_rooted
(
node
)
)
}
fn
insert
(
node
:
JSRef
<
Node
>
parent
:
JSRef
<
Node
>
child
:
Option
<
JSRef
<
Node
>
>
suppress_observers
:
SuppressObserver
)
{
fn
do_insert
(
node
:
JSRef
<
Node
>
parent
:
JSRef
<
Node
>
child
:
Option
<
JSRef
<
Node
>
>
)
{
parent
.
add_child
(
node
child
)
;
let
is_in_doc
=
parent
.
is_in_doc
(
)
;
for
kid
in
node
.
traverse_preorder
(
)
{
let
mut
flags
=
kid
.
flags
.
get
(
)
;
if
is_in_doc
{
flags
.
insert
(
IS_IN_DOC
)
;
}
else
{
flags
.
remove
(
IS_IN_DOC
)
;
}
kid
.
flags
.
set
(
flags
)
;
}
}
fn
fire_observer_if_necessary
(
node
:
JSRef
<
Node
>
suppress_observers
:
SuppressObserver
)
{
match
suppress_observers
{
SuppressObserver
:
:
Unsuppressed
=
>
node
.
node_inserted
(
)
SuppressObserver
:
:
Suppressed
=
>
(
)
}
}
match
node
.
type_id
(
)
{
NodeTypeId
:
:
DocumentFragment
=
>
{
let
mut
kids
=
Vec
:
:
new
(
)
;
for
kid
in
node
.
children
(
)
{
let
kid
=
kid
.
root
(
)
;
kids
.
push
(
Temporary
:
:
from_rooted
(
kid
.
r
(
)
)
)
;
Node
:
:
remove
(
kid
.
r
(
)
node
SuppressObserver
:
:
Suppressed
)
;
}
for
kid
in
kids
.
clone
(
)
.
into_iter
(
)
{
let
kid
=
kid
.
root
(
)
;
do_insert
(
kid
.
r
(
)
parent
child
)
;
}
for
kid
in
kids
.
into_iter
(
)
{
let
kid
=
kid
.
root
(
)
;
fire_observer_if_necessary
(
kid
.
r
(
)
suppress_observers
)
;
}
}
_
=
>
{
do_insert
(
node
parent
child
)
;
fire_observer_if_necessary
(
node
suppress_observers
)
;
}
}
}
pub
fn
replace_all
(
node
:
Option
<
JSRef
<
Node
>
>
parent
:
JSRef
<
Node
>
)
{
match
node
{
Some
(
node
)
=
>
{
let
document
=
document_from_node
(
parent
)
.
root
(
)
;
Node
:
:
adopt
(
node
document
.
r
(
)
)
;
}
None
=
>
(
)
}
let
mut
removed_nodes
:
RootedVec
<
JS
<
Node
>
>
=
RootedVec
:
:
new
(
)
;
for
child
in
parent
.
children
(
)
{
removed_nodes
.
push
(
JS
:
:
from_rooted
(
child
)
)
;
}
let
added_nodes
=
match
node
{
None
=
>
vec
!
(
)
Some
(
node
)
=
>
match
node
.
type_id
(
)
{
NodeTypeId
:
:
DocumentFragment
=
>
node
.
children
(
)
.
collect
(
)
_
=
>
vec
!
(
Temporary
:
:
from_rooted
(
node
)
)
}
}
;
for
child
in
parent
.
children
(
)
{
let
child
=
child
.
root
(
)
;
Node
:
:
remove
(
child
.
r
(
)
parent
SuppressObserver
:
:
Suppressed
)
;
}
match
node
{
Some
(
node
)
=
>
Node
:
:
insert
(
node
parent
None
SuppressObserver
:
:
Suppressed
)
None
=
>
(
)
}
let
parent_in_doc
=
parent
.
is_in_doc
(
)
;
for
removed_node
in
removed_nodes
.
iter
(
)
{
let
removed_node
=
removed_node
.
root
(
)
;
removed_node
.
r
(
)
.
node_removed
(
parent_in_doc
)
;
}
for
added_node
in
added_nodes
{
let
added_node
=
added_node
.
root
(
)
;
added_node
.
r
(
)
.
node_inserted
(
)
;
}
}
fn
pre_remove
(
child
:
JSRef
<
Node
>
parent
:
JSRef
<
Node
>
)
-
>
Fallible
<
Temporary
<
Node
>
>
{
match
child
.
parent_node
(
)
{
Some
(
ref
node
)
if
node
!
=
&
Temporary
:
:
from_rooted
(
parent
)
=
>
return
Err
(
NotFound
)
None
=
>
return
Err
(
NotFound
)
_
=
>
(
)
}
Node
:
:
remove
(
child
parent
SuppressObserver
:
:
Unsuppressed
)
;
Ok
(
Temporary
:
:
from_rooted
(
child
)
)
}
fn
remove
(
node
:
JSRef
<
Node
>
parent
:
JSRef
<
Node
>
suppress_observers
:
SuppressObserver
)
{
assert
!
(
node
.
parent_node
(
)
.
map_or
(
false
|
node_parent
|
node_parent
=
=
Temporary
:
:
from_rooted
(
parent
)
)
)
;
parent
.
remove_child
(
node
)
;
node
.
set_flag
(
IS_IN_DOC
false
)
;
match
suppress_observers
{
SuppressObserver
:
:
Suppressed
=
>
(
)
SuppressObserver
:
:
Unsuppressed
=
>
node
.
node_removed
(
parent
.
is_in_doc
(
)
)
}
}
pub
fn
clone
(
node
:
JSRef
<
Node
>
maybe_doc
:
Option
<
JSRef
<
Document
>
>
clone_children
:
CloneChildrenFlag
)
-
>
Temporary
<
Node
>
{
let
document
=
match
maybe_doc
{
Some
(
doc
)
=
>
JS
:
:
from_rooted
(
doc
)
.
root
(
)
None
=
>
node
.
owner_doc
(
)
.
root
(
)
}
;
let
copy
:
Root
<
Node
>
=
match
node
.
type_id
(
)
{
NodeTypeId
:
:
DocumentType
=
>
{
let
doctype
:
JSRef
<
DocumentType
>
=
DocumentTypeCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
doctype
=
DocumentType
:
:
new
(
doctype
.
name
(
)
.
clone
(
)
Some
(
doctype
.
public_id
(
)
.
clone
(
)
)
Some
(
doctype
.
system_id
(
)
.
clone
(
)
)
document
.
r
(
)
)
;
NodeCast
:
:
from_temporary
(
doctype
)
}
NodeTypeId
:
:
DocumentFragment
=
>
{
let
doc_fragment
=
DocumentFragment
:
:
new
(
document
.
r
(
)
)
;
NodeCast
:
:
from_temporary
(
doc_fragment
)
}
NodeTypeId
:
:
Comment
=
>
{
let
comment
:
JSRef
<
Comment
>
=
CommentCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
comment
=
Comment
:
:
new
(
comment
.
characterdata
(
)
.
data
(
)
.
clone
(
)
document
.
r
(
)
)
;
NodeCast
:
:
from_temporary
(
comment
)
}
NodeTypeId
:
:
Document
=
>
{
let
document
:
JSRef
<
Document
>
=
DocumentCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
is_html_doc
=
match
document
.
is_html_document
(
)
{
true
=
>
IsHTMLDocument
:
:
HTMLDocument
false
=
>
IsHTMLDocument
:
:
NonHTMLDocument
}
;
let
window
=
document
.
window
(
)
.
root
(
)
;
let
document
=
Document
:
:
new
(
window
.
r
(
)
Some
(
document
.
url
(
)
)
is_html_doc
None
None
DocumentSource
:
:
NotFromParser
)
;
NodeCast
:
:
from_temporary
(
document
)
}
NodeTypeId
:
:
Element
(
.
.
)
=
>
{
let
element
:
JSRef
<
Element
>
=
ElementCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
name
=
QualName
{
ns
:
element
.
namespace
(
)
.
clone
(
)
local
:
element
.
local_name
(
)
.
clone
(
)
}
;
let
element
=
Element
:
:
create
(
name
element
.
prefix
(
)
.
as_ref
(
)
.
map
(
|
p
|
p
.
as_slice
(
)
.
to_owned
(
)
)
document
.
r
(
)
ElementCreator
:
:
ScriptCreated
)
;
NodeCast
:
:
from_temporary
(
element
)
}
NodeTypeId
:
:
Text
=
>
{
let
text
:
JSRef
<
Text
>
=
TextCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
text
=
Text
:
:
new
(
text
.
characterdata
(
)
.
data
(
)
.
clone
(
)
document
.
r
(
)
)
;
NodeCast
:
:
from_temporary
(
text
)
}
NodeTypeId
:
:
ProcessingInstruction
=
>
{
let
pi
:
JSRef
<
ProcessingInstruction
>
=
ProcessingInstructionCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
pi
=
ProcessingInstruction
:
:
new
(
pi
.
target
(
)
.
clone
(
)
pi
.
characterdata
(
)
.
data
(
)
.
clone
(
)
document
.
r
(
)
)
;
NodeCast
:
:
from_temporary
(
pi
)
}
}
.
root
(
)
;
let
document
=
match
DocumentCast
:
:
to_ref
(
copy
.
r
(
)
)
{
Some
(
doc
)
=
>
doc
None
=
>
document
.
r
(
)
}
;
assert
!
(
copy
.
r
(
)
.
owner_doc
(
)
.
root
(
)
.
r
(
)
=
=
document
)
;
match
node
.
type_id
(
)
{
NodeTypeId
:
:
Document
=
>
{
let
node_doc
:
JSRef
<
Document
>
=
DocumentCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
copy_doc
:
JSRef
<
Document
>
=
DocumentCast
:
:
to_ref
(
copy
.
r
(
)
)
.
unwrap
(
)
;
copy_doc
.
set_encoding_name
(
node_doc
.
encoding_name
(
)
.
clone
(
)
)
;
copy_doc
.
set_quirks_mode
(
node_doc
.
quirks_mode
(
)
)
;
}
NodeTypeId
:
:
Element
(
.
.
)
=
>
{
let
node_elem
:
JSRef
<
Element
>
=
ElementCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
copy_elem
:
JSRef
<
Element
>
=
ElementCast
:
:
to_ref
(
copy
.
r
(
)
)
.
unwrap
(
)
;
let
window
=
document
.
window
(
)
.
root
(
)
;
for
attr
in
node_elem
.
attrs
(
)
.
iter
(
)
.
map
(
|
attr
|
attr
.
root
(
)
)
{
copy_elem
.
attrs_mut
(
)
.
push_unrooted
(
&
Attr
:
:
new
(
window
.
r
(
)
attr
.
r
(
)
.
local_name
(
)
.
clone
(
)
attr
.
r
(
)
.
value
(
)
.
clone
(
)
attr
.
r
(
)
.
name
(
)
.
clone
(
)
attr
.
r
(
)
.
namespace
(
)
.
clone
(
)
attr
.
r
(
)
.
prefix
(
)
.
clone
(
)
Some
(
copy_elem
)
)
)
;
}
}
_
=
>
(
)
}
vtable_for
(
&
node
)
.
cloning_steps
(
copy
.
r
(
)
maybe_doc
clone_children
)
;
if
clone_children
=
=
CloneChildrenFlag
:
:
CloneChildren
{
for
child
in
node
.
children
(
)
{
let
child
=
child
.
root
(
)
;
let
child_copy
=
Node
:
:
clone
(
child
.
r
(
)
Some
(
document
)
clone_children
)
.
root
(
)
;
let
_inserted_node
=
Node
:
:
pre_insert
(
child_copy
.
r
(
)
copy
.
r
(
)
None
)
;
}
}
Temporary
:
:
from_rooted
(
copy
.
r
(
)
)
}
pub
fn
collect_text_contents
<
'
a
T
:
Iterator
<
Item
=
JSRef
<
'
a
Node
>
>
>
(
iterator
:
T
)
-
>
String
{
let
mut
content
=
String
:
:
new
(
)
;
for
node
in
iterator
{
let
text
:
Option
<
JSRef
<
Text
>
>
=
TextCast
:
:
to_ref
(
node
)
;
match
text
{
Some
(
text
)
=
>
content
.
push_str
(
text
.
characterdata
(
)
.
data
(
)
.
as_slice
(
)
)
None
=
>
(
)
}
}
content
}
}
impl
<
'
a
>
NodeMethods
for
JSRef
<
'
a
Node
>
{
fn
NodeType
(
self
)
-
>
u16
{
match
self
.
type_id
{
NodeTypeId
:
:
Element
(
_
)
=
>
NodeConstants
:
:
ELEMENT_NODE
NodeTypeId
:
:
Text
=
>
NodeConstants
:
:
TEXT_NODE
NodeTypeId
:
:
ProcessingInstruction
=
>
NodeConstants
:
:
PROCESSING_INSTRUCTION_NODE
NodeTypeId
:
:
Comment
=
>
NodeConstants
:
:
COMMENT_NODE
NodeTypeId
:
:
Document
=
>
NodeConstants
:
:
DOCUMENT_NODE
NodeTypeId
:
:
DocumentType
=
>
NodeConstants
:
:
DOCUMENT_TYPE_NODE
NodeTypeId
:
:
DocumentFragment
=
>
NodeConstants
:
:
DOCUMENT_FRAGMENT_NODE
}
}
fn
NodeName
(
self
)
-
>
DOMString
{
match
self
.
type_id
{
NodeTypeId
:
:
Element
(
.
.
)
=
>
{
let
elem
:
JSRef
<
Element
>
=
ElementCast
:
:
to_ref
(
self
)
.
unwrap
(
)
;
elem
.
TagName
(
)
}
NodeTypeId
:
:
Text
=
>
"
#
text
"
.
to_owned
(
)
NodeTypeId
:
:
ProcessingInstruction
=
>
{
let
processing_instruction
:
JSRef
<
ProcessingInstruction
>
=
ProcessingInstructionCast
:
:
to_ref
(
self
)
.
unwrap
(
)
;
processing_instruction
.
Target
(
)
}
NodeTypeId
:
:
Comment
=
>
"
#
comment
"
.
to_owned
(
)
NodeTypeId
:
:
DocumentType
=
>
{
let
doctype
:
JSRef
<
DocumentType
>
=
DocumentTypeCast
:
:
to_ref
(
self
)
.
unwrap
(
)
;
doctype
.
name
(
)
.
clone
(
)
}
NodeTypeId
:
:
DocumentFragment
=
>
"
#
document
-
fragment
"
.
to_owned
(
)
NodeTypeId
:
:
Document
=
>
"
#
document
"
.
to_owned
(
)
}
}
fn
GetBaseURI
(
self
)
-
>
Option
<
DOMString
>
{
None
}
fn
GetOwnerDocument
(
self
)
-
>
Option
<
Temporary
<
Document
>
>
{
match
self
.
type_id
{
NodeTypeId
:
:
Element
(
.
.
)
|
NodeTypeId
:
:
Comment
|
NodeTypeId
:
:
Text
|
NodeTypeId
:
:
ProcessingInstruction
|
NodeTypeId
:
:
DocumentType
|
NodeTypeId
:
:
DocumentFragment
=
>
Some
(
self
.
owner_doc
(
)
)
NodeTypeId
:
:
Document
=
>
None
}
}
fn
GetParentNode
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
self
.
parent_node
.
get
(
)
}
fn
GetParentElement
(
self
)
-
>
Option
<
Temporary
<
Element
>
>
{
self
.
parent_node
.
get
(
)
.
and_then
(
|
parent
|
{
let
parent
=
parent
.
root
(
)
;
ElementCast
:
:
to_ref
(
parent
.
r
(
)
)
.
map
(
|
elem
|
{
Temporary
:
:
from_rooted
(
elem
)
}
)
}
)
}
fn
HasChildNodes
(
self
)
-
>
bool
{
self
.
first_child
.
get
(
)
.
is_some
(
)
}
fn
ChildNodes
(
self
)
-
>
Temporary
<
NodeList
>
{
self
.
child_list
.
or_init
(
|
|
{
let
doc
=
self
.
owner_doc
(
)
.
root
(
)
;
let
window
=
doc
.
r
(
)
.
window
(
)
.
root
(
)
;
NodeList
:
:
new_child_list
(
window
.
r
(
)
self
)
}
)
}
fn
GetFirstChild
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
self
.
first_child
.
get
(
)
}
fn
GetLastChild
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
self
.
last_child
.
get
(
)
}
fn
GetPreviousSibling
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
self
.
prev_sibling
.
get
(
)
}
fn
GetNextSibling
(
self
)
-
>
Option
<
Temporary
<
Node
>
>
{
self
.
next_sibling
.
get
(
)
}
fn
GetNodeValue
(
self
)
-
>
Option
<
DOMString
>
{
match
self
.
type_id
{
NodeTypeId
:
:
Comment
|
NodeTypeId
:
:
Text
|
NodeTypeId
:
:
ProcessingInstruction
=
>
{
let
chardata
:
JSRef
<
CharacterData
>
=
CharacterDataCast
:
:
to_ref
(
self
)
.
unwrap
(
)
;
Some
(
chardata
.
Data
(
)
)
}
_
=
>
{
None
}
}
}
fn
SetNodeValue
(
self
val
:
Option
<
DOMString
>
)
{
match
self
.
type_id
{
NodeTypeId
:
:
Comment
|
NodeTypeId
:
:
Text
|
NodeTypeId
:
:
ProcessingInstruction
=
>
{
self
.
SetTextContent
(
val
)
}
_
=
>
{
}
}
}
fn
GetTextContent
(
self
)
-
>
Option
<
DOMString
>
{
match
self
.
type_id
{
NodeTypeId
:
:
DocumentFragment
|
NodeTypeId
:
:
Element
(
.
.
)
=
>
{
let
content
=
Node
:
:
collect_text_contents
(
self
.
traverse_preorder
(
)
)
;
Some
(
content
)
}
NodeTypeId
:
:
Comment
|
NodeTypeId
:
:
Text
|
NodeTypeId
:
:
ProcessingInstruction
=
>
{
let
characterdata
:
JSRef
<
CharacterData
>
=
CharacterDataCast
:
:
to_ref
(
self
)
.
unwrap
(
)
;
Some
(
characterdata
.
Data
(
)
)
}
NodeTypeId
:
:
DocumentType
|
NodeTypeId
:
:
Document
=
>
{
None
}
}
}
fn
SetTextContent
(
self
value
:
Option
<
DOMString
>
)
{
let
value
=
null_str_as_empty
(
&
value
)
;
match
self
.
type_id
{
NodeTypeId
:
:
DocumentFragment
|
NodeTypeId
:
:
Element
(
.
.
)
=
>
{
let
node
=
if
value
.
len
(
)
=
=
0
{
None
}
else
{
let
document
=
self
.
owner_doc
(
)
.
root
(
)
;
Some
(
NodeCast
:
:
from_temporary
(
document
.
r
(
)
.
CreateTextNode
(
value
)
)
)
}
.
root
(
)
;
Node
:
:
replace_all
(
node
.
r
(
)
self
)
;
}
NodeTypeId
:
:
Comment
|
NodeTypeId
:
:
Text
|
NodeTypeId
:
:
ProcessingInstruction
=
>
{
let
characterdata
:
JSRef
<
CharacterData
>
=
CharacterDataCast
:
:
to_ref
(
self
)
.
unwrap
(
)
;
characterdata
.
set_data
(
value
)
;
let
document
=
self
.
owner_doc
(
)
.
root
(
)
;
document
.
r
(
)
.
content_changed
(
self
NodeDamage
:
:
OtherNodeDamage
)
;
}
NodeTypeId
:
:
DocumentType
|
NodeTypeId
:
:
Document
=
>
{
}
}
}
fn
InsertBefore
(
self
node
:
JSRef
<
Node
>
child
:
Option
<
JSRef
<
Node
>
>
)
-
>
Fallible
<
Temporary
<
Node
>
>
{
Node
:
:
pre_insert
(
node
self
child
)
}
fn
AppendChild
(
self
node
:
JSRef
<
Node
>
)
-
>
Fallible
<
Temporary
<
Node
>
>
{
Node
:
:
pre_insert
(
node
self
None
)
}
fn
ReplaceChild
(
self
node
:
JSRef
<
Node
>
child
:
JSRef
<
Node
>
)
-
>
Fallible
<
Temporary
<
Node
>
>
{
match
self
.
type_id
{
NodeTypeId
:
:
Document
|
NodeTypeId
:
:
DocumentFragment
|
NodeTypeId
:
:
Element
(
.
.
)
=
>
(
)
_
=
>
return
Err
(
HierarchyRequest
)
}
if
node
.
is_inclusive_ancestor_of
(
self
)
{
return
Err
(
HierarchyRequest
)
;
}
if
!
self
.
is_parent_of
(
child
)
{
return
Err
(
NotFound
)
;
}
match
node
.
type_id
(
)
{
NodeTypeId
:
:
Text
if
self
.
is_document
(
)
=
>
return
Err
(
HierarchyRequest
)
NodeTypeId
:
:
DocumentType
if
!
self
.
is_document
(
)
=
>
return
Err
(
HierarchyRequest
)
NodeTypeId
:
:
DocumentFragment
|
NodeTypeId
:
:
DocumentType
|
NodeTypeId
:
:
Element
(
.
.
)
|
NodeTypeId
:
:
Text
|
NodeTypeId
:
:
ProcessingInstruction
|
NodeTypeId
:
:
Comment
=
>
(
)
NodeTypeId
:
:
Document
=
>
return
Err
(
HierarchyRequest
)
}
match
self
.
type_id
{
NodeTypeId
:
:
Document
=
>
{
match
node
.
type_id
(
)
{
NodeTypeId
:
:
DocumentFragment
=
>
{
if
node
.
children
(
)
.
map
(
|
c
|
c
.
root
(
)
)
.
any
(
|
c
|
c
.
r
(
)
.
is_text
(
)
)
{
return
Err
(
HierarchyRequest
)
;
}
match
node
.
child_elements
(
)
.
count
(
)
{
0
=
>
(
)
1
=
>
{
if
self
.
child_elements
(
)
.
map
(
|
c
|
c
.
root
(
)
)
.
any
(
|
c
|
NodeCast
:
:
from_ref
(
c
.
r
(
)
)
!
=
child
)
{
return
Err
(
HierarchyRequest
)
;
}
if
child
.
following_siblings
(
)
.
map
(
|
c
|
c
.
root
(
)
)
.
any
(
|
child
|
child
.
r
(
)
.
is_doctype
(
)
)
{
return
Err
(
HierarchyRequest
)
;
}
}
_
=
>
return
Err
(
HierarchyRequest
)
}
}
NodeTypeId
:
:
Element
(
.
.
)
=
>
{
if
self
.
child_elements
(
)
.
map
(
|
c
|
c
.
root
(
)
)
.
any
(
|
c
|
NodeCast
:
:
from_ref
(
c
.
r
(
)
)
!
=
child
)
{
return
Err
(
HierarchyRequest
)
;
}
if
child
.
following_siblings
(
)
.
map
(
|
c
|
c
.
root
(
)
)
.
any
(
|
child
|
child
.
r
(
)
.
is_doctype
(
)
)
{
return
Err
(
HierarchyRequest
)
;
}
}
NodeTypeId
:
:
DocumentType
=
>
{
if
self
.
children
(
)
.
map
(
|
c
|
c
.
root
(
)
)
.
any
(
|
c
|
c
.
r
(
)
.
is_doctype
(
)
&
&
c
.
r
(
)
!
=
child
)
{
return
Err
(
HierarchyRequest
)
;
}
if
self
.
children
(
)
.
map
(
|
c
|
c
.
root
(
)
)
.
take_while
(
|
c
|
c
.
r
(
)
!
=
child
)
.
any
(
|
c
|
c
.
r
(
)
.
is_element
(
)
)
{
return
Err
(
HierarchyRequest
)
;
}
}
NodeTypeId
:
:
Text
|
NodeTypeId
:
:
ProcessingInstruction
|
NodeTypeId
:
:
Comment
=
>
(
)
NodeTypeId
:
:
Document
=
>
unreachable
!
(
)
}
}
_
=
>
(
)
}
if
node
=
=
child
{
return
Ok
(
Temporary
:
:
from_rooted
(
child
)
)
;
}
let
next_sibling
=
child
.
next_sibling
(
)
.
map
(
|
node
|
node
.
root
(
)
.
get_unsound_ref_forever
(
)
)
;
let
reference_child
=
match
next_sibling
{
Some
(
sibling
)
if
sibling
=
=
node
=
>
node
.
next_sibling
(
)
.
map
(
|
node
|
node
.
root
(
)
.
get_unsound_ref_forever
(
)
)
_
=
>
next_sibling
}
;
let
document
=
document_from_node
(
self
)
.
root
(
)
;
Node
:
:
adopt
(
node
document
.
r
(
)
)
;
let
mut
nodes
:
RootedVec
<
JS
<
Node
>
>
=
RootedVec
:
:
new
(
)
;
if
node
.
type_id
(
)
=
=
NodeTypeId
:
:
DocumentFragment
{
for
child_node
in
node
.
children
(
)
{
let
child_node
=
child_node
.
root
(
)
;
nodes
.
push
(
JS
:
:
from_rooted
(
child_node
.
r
(
)
)
)
;
}
}
else
{
nodes
.
push
(
JS
:
:
from_rooted
(
node
)
)
;
}
{
Node
:
:
remove
(
child
self
SuppressObserver
:
:
Suppressed
)
;
Node
:
:
insert
(
node
self
reference_child
SuppressObserver
:
:
Suppressed
)
;
}
child
.
node_removed
(
self
.
is_in_doc
(
)
)
;
for
child_node
in
&
*
nodes
{
let
child_node
=
child_node
.
root
(
)
;
child_node
.
r
(
)
.
node_inserted
(
)
;
}
Ok
(
Temporary
:
:
from_rooted
(
child
)
)
}
fn
RemoveChild
(
self
node
:
JSRef
<
Node
>
)
-
>
Fallible
<
Temporary
<
Node
>
>
{
Node
:
:
pre_remove
(
node
self
)
}
fn
Normalize
(
self
)
{
let
mut
prev_text
:
Option
<
Temporary
<
Text
>
>
=
None
;
for
child
in
self
.
children
(
)
{
let
child
=
child
.
root
(
)
;
match
TextCast
:
:
to_ref
(
child
.
r
(
)
)
{
Some
(
text
)
=
>
{
let
characterdata
:
JSRef
<
CharacterData
>
=
CharacterDataCast
:
:
from_ref
(
text
)
;
if
characterdata
.
Length
(
)
=
=
0
{
self
.
remove_child
(
child
.
r
(
)
)
;
}
else
{
match
prev_text
{
Some
(
ref
text_node
)
=
>
{
let
text_node
=
text_node
.
clone
(
)
.
root
(
)
;
let
prev_characterdata
:
JSRef
<
CharacterData
>
=
CharacterDataCast
:
:
from_ref
(
text_node
.
r
(
)
)
;
let
_
=
prev_characterdata
.
AppendData
(
characterdata
.
Data
(
)
)
;
self
.
remove_child
(
child
.
r
(
)
)
;
}
None
=
>
prev_text
=
Some
(
Temporary
:
:
from_rooted
(
text
)
)
}
}
}
None
=
>
{
child
.
r
(
)
.
Normalize
(
)
;
prev_text
=
None
;
}
}
}
}
fn
CloneNode
(
self
deep
:
bool
)
-
>
Temporary
<
Node
>
{
Node
:
:
clone
(
self
None
if
deep
{
CloneChildrenFlag
:
:
CloneChildren
}
else
{
CloneChildrenFlag
:
:
DoNotCloneChildren
}
)
}
fn
IsEqualNode
(
self
maybe_node
:
Option
<
JSRef
<
Node
>
>
)
-
>
bool
{
fn
is_equal_doctype
(
node
:
JSRef
<
Node
>
other
:
JSRef
<
Node
>
)
-
>
bool
{
let
doctype
:
JSRef
<
DocumentType
>
=
DocumentTypeCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
other_doctype
:
JSRef
<
DocumentType
>
=
DocumentTypeCast
:
:
to_ref
(
other
)
.
unwrap
(
)
;
(
*
doctype
.
name
(
)
=
=
*
other_doctype
.
name
(
)
)
&
&
(
*
doctype
.
public_id
(
)
=
=
*
other_doctype
.
public_id
(
)
)
&
&
(
*
doctype
.
system_id
(
)
=
=
*
other_doctype
.
system_id
(
)
)
}
fn
is_equal_element
(
node
:
JSRef
<
Node
>
other
:
JSRef
<
Node
>
)
-
>
bool
{
let
element
:
JSRef
<
Element
>
=
ElementCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
other_element
:
JSRef
<
Element
>
=
ElementCast
:
:
to_ref
(
other
)
.
unwrap
(
)
;
(
*
element
.
namespace
(
)
=
=
*
other_element
.
namespace
(
)
)
&
&
(
*
element
.
local_name
(
)
=
=
*
other_element
.
local_name
(
)
)
&
&
(
element
.
attrs
(
)
.
len
(
)
=
=
other_element
.
attrs
(
)
.
len
(
)
)
}
fn
is_equal_processinginstruction
(
node
:
JSRef
<
Node
>
other
:
JSRef
<
Node
>
)
-
>
bool
{
let
pi
:
JSRef
<
ProcessingInstruction
>
=
ProcessingInstructionCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
other_pi
:
JSRef
<
ProcessingInstruction
>
=
ProcessingInstructionCast
:
:
to_ref
(
other
)
.
unwrap
(
)
;
(
*
pi
.
target
(
)
=
=
*
other_pi
.
target
(
)
)
&
&
(
*
pi
.
characterdata
(
)
.
data
(
)
=
=
*
other_pi
.
characterdata
(
)
.
data
(
)
)
}
fn
is_equal_characterdata
(
node
:
JSRef
<
Node
>
other
:
JSRef
<
Node
>
)
-
>
bool
{
let
characterdata
:
JSRef
<
CharacterData
>
=
CharacterDataCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
other_characterdata
:
JSRef
<
CharacterData
>
=
CharacterDataCast
:
:
to_ref
(
other
)
.
unwrap
(
)
;
let
own_data
=
characterdata
.
data
(
)
;
let
other_data
=
other_characterdata
.
data
(
)
;
*
own_data
=
=
*
other_data
}
fn
is_equal_element_attrs
(
node
:
JSRef
<
Node
>
other
:
JSRef
<
Node
>
)
-
>
bool
{
let
element
:
JSRef
<
Element
>
=
ElementCast
:
:
to_ref
(
node
)
.
unwrap
(
)
;
let
other_element
:
JSRef
<
Element
>
=
ElementCast
:
:
to_ref
(
other
)
.
unwrap
(
)
;
assert
!
(
element
.
attrs
(
)
.
len
(
)
=
=
other_element
.
attrs
(
)
.
len
(
)
)
;
let
attrs
=
element
.
attrs
(
)
;
attrs
.
iter
(
)
.
map
(
|
attr
|
attr
.
root
(
)
)
.
all
(
|
attr
|
{
other_element
.
attrs
(
)
.
iter
(
)
.
map
(
|
attr
|
attr
.
root
(
)
)
.
any
(
|
other_attr
|
{
(
*
attr
.
r
(
)
.
namespace
(
)
=
=
*
other_attr
.
r
(
)
.
namespace
(
)
)
&
&
(
attr
.
r
(
)
.
local_name
(
)
=
=
other_attr
.
r
(
)
.
local_name
(
)
)
&
&
(
attr
.
r
(
)
.
value
(
)
.
as_slice
(
)
=
=
other_attr
.
r
(
)
.
value
(
)
.
as_slice
(
)
)
}
)
}
)
}
fn
is_equal_node
(
this
:
JSRef
<
Node
>
node
:
JSRef
<
Node
>
)
-
>
bool
{
if
this
.
type_id
(
)
!
=
node
.
type_id
(
)
{
return
false
;
}
match
node
.
type_id
(
)
{
NodeTypeId
:
:
DocumentType
if
!
is_equal_doctype
(
this
node
)
=
>
return
false
NodeTypeId
:
:
Element
(
.
.
)
if
!
is_equal_element
(
this
node
)
=
>
return
false
NodeTypeId
:
:
ProcessingInstruction
if
!
is_equal_processinginstruction
(
this
node
)
=
>
return
false
NodeTypeId
:
:
Text
|
NodeTypeId
:
:
Comment
if
!
is_equal_characterdata
(
this
node
)
=
>
return
false
NodeTypeId
:
:
Element
(
.
.
)
if
!
is_equal_element_attrs
(
this
node
)
=
>
return
false
_
=
>
(
)
}
if
this
.
children
(
)
.
count
(
)
!
=
node
.
children
(
)
.
count
(
)
{
return
false
;
}
this
.
children
(
)
.
zip
(
node
.
children
(
)
)
.
all
(
|
(
child
other_child
)
|
{
is_equal_node
(
child
.
root
(
)
.
r
(
)
other_child
.
root
(
)
.
r
(
)
)
}
)
}
match
maybe_node
{
None
=
>
false
Some
(
node
)
=
>
is_equal_node
(
self
node
)
}
}
fn
CompareDocumentPosition
(
self
other
:
JSRef
<
Node
>
)
-
>
u16
{
if
self
=
=
other
{
0
}
else
{
let
mut
lastself
=
Temporary
:
:
from_rooted
(
self
.
clone
(
)
)
;
let
mut
lastother
=
Temporary
:
:
from_rooted
(
other
.
clone
(
)
)
;
for
ancestor
in
self
.
ancestors
(
)
{
let
ancestor
=
ancestor
.
root
(
)
;
if
ancestor
.
r
(
)
=
=
other
{
return
NodeConstants
:
:
DOCUMENT_POSITION_CONTAINS
+
NodeConstants
:
:
DOCUMENT_POSITION_PRECEDING
;
}
lastself
=
Temporary
:
:
from_rooted
(
ancestor
.
r
(
)
)
;
}
for
ancestor
in
other
.
ancestors
(
)
{
let
ancestor
=
ancestor
.
root
(
)
;
if
ancestor
.
r
(
)
=
=
self
{
return
NodeConstants
:
:
DOCUMENT_POSITION_CONTAINED_BY
+
NodeConstants
:
:
DOCUMENT_POSITION_FOLLOWING
;
}
lastother
=
Temporary
:
:
from_rooted
(
ancestor
.
r
(
)
)
;
}
if
lastself
!
=
lastother
{
let
abstract_uint
:
uintptr_t
=
as_uintptr
(
&
self
)
;
let
other_uint
:
uintptr_t
=
as_uintptr
(
&
*
other
)
;
let
random
=
if
abstract_uint
<
other_uint
{
NodeConstants
:
:
DOCUMENT_POSITION_FOLLOWING
}
else
{
NodeConstants
:
:
DOCUMENT_POSITION_PRECEDING
}
;
return
random
+
NodeConstants
:
:
DOCUMENT_POSITION_DISCONNECTED
+
NodeConstants
:
:
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
;
}
let
lastself
=
lastself
.
root
(
)
;
for
child
in
lastself
.
r
(
)
.
traverse_preorder
(
)
{
if
child
=
=
other
{
return
NodeConstants
:
:
DOCUMENT_POSITION_PRECEDING
;
}
if
child
=
=
self
{
return
NodeConstants
:
:
DOCUMENT_POSITION_FOLLOWING
;
}
}
unreachable
!
(
)
}
}
fn
Contains
(
self
maybe_other
:
Option
<
JSRef
<
Node
>
>
)
-
>
bool
{
match
maybe_other
{
None
=
>
false
Some
(
other
)
=
>
self
.
is_inclusive_ancestor_of
(
other
)
}
}
fn
LookupPrefix
(
self
_prefix
:
Option
<
DOMString
>
)
-
>
Option
<
DOMString
>
{
None
}
fn
LookupNamespaceURI
(
self
_namespace
:
Option
<
DOMString
>
)
-
>
Option
<
DOMString
>
{
None
}
fn
IsDefaultNamespace
(
self
_namespace
:
Option
<
DOMString
>
)
-
>
bool
{
false
}
}
#
[
allow
(
raw_pointer_derive
)
]
#
[
derive
(
Clone
PartialEq
Eq
Copy
)
]
pub
struct
TrustedNodeAddress
(
pub
*
const
c_void
)
;
#
[
allow
(
unsafe_code
)
]
unsafe
impl
Send
for
TrustedNodeAddress
{
}
pub
fn
document_from_node
<
T
:
NodeBase
+
Reflectable
>
(
derived
:
JSRef
<
T
>
)
-
>
Temporary
<
Document
>
{
let
node
:
JSRef
<
Node
>
=
NodeCast
:
:
from_ref
(
derived
)
;
node
.
owner_doc
(
)
}
pub
fn
window_from_node
<
T
:
NodeBase
+
Reflectable
>
(
derived
:
JSRef
<
T
>
)
-
>
Temporary
<
Window
>
{
let
document
=
document_from_node
(
derived
)
.
root
(
)
;
document
.
r
(
)
.
window
(
)
}
impl
<
'
a
>
VirtualMethods
for
JSRef
<
'
a
Node
>
{
fn
super_type
<
'
b
>
(
&
'
b
self
)
-
>
Option
<
&
'
b
VirtualMethods
>
{
let
eventtarget
:
&
JSRef
<
EventTarget
>
=
EventTargetCast
:
:
from_borrowed_ref
(
self
)
;
Some
(
eventtarget
as
&
VirtualMethods
)
}
}
impl
<
'
a
>
style
:
:
node
:
:
TNode
<
'
a
>
for
JSRef
<
'
a
Node
>
{
type
Element
=
JSRef
<
'
a
Element
>
;
fn
parent_node
(
self
)
-
>
Option
<
JSRef
<
'
a
Node
>
>
{
fn
parent_node
<
'
a
T
:
NodeHelpers
<
'
a
>
>
(
this
:
T
)
-
>
Option
<
Temporary
<
Node
>
>
{
this
.
parent_node
(
)
}
parent_node
(
self
)
.
map
(
|
node
|
node
.
root
(
)
.
get_unsound_ref_forever
(
)
)
}
fn
first_child
(
self
)
-
>
Option
<
JSRef
<
'
a
Node
>
>
{
fn
first_child
<
'
a
T
:
NodeHelpers
<
'
a
>
>
(
this
:
T
)
-
>
Option
<
Temporary
<
Node
>
>
{
this
.
first_child
(
)
}
first_child
(
self
)
.
map
(
|
node
|
node
.
root
(
)
.
get_unsound_ref_forever
(
)
)
}
fn
last_child
(
self
)
-
>
Option
<
JSRef
<
'
a
Node
>
>
{
fn
last_child
<
'
a
T
:
NodeHelpers
<
'
a
>
>
(
this
:
T
)
-
>
Option
<
Temporary
<
Node
>
>
{
this
.
last_child
(
)
}
last_child
(
self
)
.
map
(
|
node
|
node
.
root
(
)
.
get_unsound_ref_forever
(
)
)
}
fn
prev_sibling
(
self
)
-
>
Option
<
JSRef
<
'
a
Node
>
>
{
fn
prev_sibling
<
'
a
T
:
NodeHelpers
<
'
a
>
>
(
this
:
T
)
-
>
Option
<
Temporary
<
Node
>
>
{
this
.
prev_sibling
(
)
}
prev_sibling
(
self
)
.
map
(
|
node
|
node
.
root
(
)
.
get_unsound_ref_forever
(
)
)
}
fn
next_sibling
(
self
)
-
>
Option
<
JSRef
<
'
a
Node
>
>
{
fn
next_sibling
<
'
a
T
:
NodeHelpers
<
'
a
>
>
(
this
:
T
)
-
>
Option
<
Temporary
<
Node
>
>
{
this
.
next_sibling
(
)
}
next_sibling
(
self
)
.
map
(
|
node
|
node
.
root
(
)
.
get_unsound_ref_forever
(
)
)
}
fn
is_document
(
self
)
-
>
bool
{
fn
is_document
<
'
a
T
:
NodeHelpers
<
'
a
>
>
(
this
:
T
)
-
>
bool
{
this
.
is_document
(
)
}
is_document
(
self
)
}
fn
is_element
(
self
)
-
>
bool
{
fn
is_element
<
'
a
T
:
NodeHelpers
<
'
a
>
>
(
this
:
T
)
-
>
bool
{
this
.
is_element
(
)
}
is_element
(
self
)
}
fn
as_element
(
self
)
-
>
JSRef
<
'
a
Element
>
{
ElementCast
:
:
to_ref
(
self
)
.
unwrap
(
)
}
fn
match_attr
<
F
>
(
self
attr
:
&
AttrSelector
test
:
F
)
-
>
bool
where
F
:
Fn
(
&
str
)
-
>
bool
{
let
local_name
=
{
if
self
.
is_html_element_in_html_document
(
)
{
&
attr
.
lower_name
}
else
{
&
attr
.
name
}
}
;
match
attr
.
namespace
{
NamespaceConstraint
:
:
Specific
(
ref
ns
)
=
>
{
self
.
as_element
(
)
.
get_attribute
(
ns
local_name
)
.
root
(
)
.
map_or
(
false
|
attr
|
{
let
attr
=
attr
.
r
(
)
;
let
value
=
attr
.
value
(
)
;
test
(
value
.
as_slice
(
)
)
}
)
}
NamespaceConstraint
:
:
Any
=
>
{
self
.
as_element
(
)
.
get_attributes
(
local_name
)
.
into_iter
(
)
.
map
(
|
attr
|
attr
.
root
(
)
)
.
any
(
|
attr
|
{
let
attr
=
attr
.
r
(
)
;
let
value
=
attr
.
value
(
)
;
test
(
value
.
as_slice
(
)
)
}
)
}
}
}
fn
is_html_element_in_html_document
(
self
)
-
>
bool
{
self
.
as_element
(
)
.
html_element_in_html_document
(
)
}
fn
has_changed
(
self
)
-
>
bool
{
self
.
get_has_changed
(
)
}
#
[
allow
(
unsafe_code
)
]
unsafe
fn
set_changed
(
self
value
:
bool
)
{
self
.
set_has_changed
(
value
)
}
fn
is_dirty
(
self
)
-
>
bool
{
self
.
get_is_dirty
(
)
}
#
[
allow
(
unsafe_code
)
]
unsafe
fn
set_dirty
(
self
value
:
bool
)
{
self
.
set_is_dirty
(
value
)
}
fn
has_dirty_siblings
(
self
)
-
>
bool
{
self
.
get_has_dirty_siblings
(
)
}
#
[
allow
(
unsafe_code
)
]
unsafe
fn
set_dirty_siblings
(
self
value
:
bool
)
{
self
.
set_has_dirty_siblings
(
value
)
}
fn
has_dirty_descendants
(
self
)
-
>
bool
{
self
.
get_has_dirty_descendants
(
)
}
#
[
allow
(
unsafe_code
)
]
unsafe
fn
set_dirty_descendants
(
self
value
:
bool
)
{
self
.
set_has_dirty_descendants
(
value
)
}
}
pub
trait
DisabledStateHelpers
{
fn
check_ancestors_disabled_state_for_form_control
(
self
)
;
fn
check_parent_disabled_state_for_option
(
self
)
;
fn
check_disabled_attribute
(
self
)
;
}
impl
<
'
a
>
DisabledStateHelpers
for
JSRef
<
'
a
Node
>
{
fn
check_ancestors_disabled_state_for_form_control
(
self
)
{
if
self
.
get_disabled_state
(
)
{
return
;
}
for
ancestor
in
self
.
ancestors
(
)
{
let
ancestor
=
ancestor
.
root
(
)
;
let
ancestor
=
ancestor
.
r
(
)
;
if
!
ancestor
.
is_htmlfieldsetelement
(
)
{
continue
;
}
if
!
ancestor
.
get_disabled_state
(
)
{
continue
;
}
if
ancestor
.
is_parent_of
(
self
)
{
self
.
set_disabled_state
(
true
)
;
self
.
set_enabled_state
(
false
)
;
return
;
}
match
ancestor
.
children
(
)
.
map
(
|
child
|
child
.
root
(
)
)
.
find
(
|
child
|
child
.
r
(
)
.
is_htmllegendelement
(
)
)
{
Some
(
legend
)
=
>
{
if
self
.
ancestors
(
)
.
any
(
|
ancestor
|
ancestor
.
root
(
)
.
r
(
)
=
=
legend
.
r
(
)
)
{
continue
;
}
}
None
=
>
(
)
}
self
.
set_disabled_state
(
true
)
;
self
.
set_enabled_state
(
false
)
;
return
;
}
}
fn
check_parent_disabled_state_for_option
(
self
)
{
if
self
.
get_disabled_state
(
)
{
return
;
}
if
let
Some
(
ref
parent
)
=
self
.
parent_node
(
)
.
root
(
)
{
if
parent
.
r
(
)
.
is_htmloptgroupelement
(
)
&
&
parent
.
r
(
)
.
get_disabled_state
(
)
{
self
.
set_disabled_state
(
true
)
;
self
.
set_enabled_state
(
false
)
;
}
}
}
fn
check_disabled_attribute
(
self
)
{
let
elem
:
JSRef
<
'
a
Element
>
=
ElementCast
:
:
to_ref
(
self
)
.
unwrap
(
)
;
let
has_disabled_attrib
=
elem
.
has_attribute
(
&
atom
!
(
"
disabled
"
)
)
;
self
.
set_disabled_state
(
has_disabled_attrib
)
;
self
.
set_enabled_state
(
!
has_disabled_attrib
)
;
}
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
NodeDamage
{
NodeStyleDamaged
OtherNodeDamage
}
