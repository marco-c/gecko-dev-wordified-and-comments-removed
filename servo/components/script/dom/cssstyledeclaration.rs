use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
CSSStyleDeclarationBinding
:
:
{
self
CSSStyleDeclarationMethods
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
WindowBinding
:
:
WindowMethods
;
use
dom
:
:
bindings
:
:
error
:
:
{
Error
ErrorResult
Fallible
}
;
use
dom
:
:
bindings
:
:
inheritance
:
:
Castable
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
DomObject
Reflector
reflect_dom_object
}
;
use
dom
:
:
bindings
:
:
root
:
:
{
Dom
DomRoot
}
;
use
dom
:
:
bindings
:
:
str
:
:
DOMString
;
use
dom
:
:
cssrule
:
:
CSSRule
;
use
dom
:
:
element
:
:
Element
;
use
dom
:
:
node
:
:
{
Node
window_from_node
document_from_node
}
;
use
dom
:
:
window
:
:
Window
;
use
dom_struct
:
:
dom_struct
;
use
servo_arc
:
:
Arc
;
use
servo_url
:
:
ServoUrl
;
use
style
:
:
attr
:
:
AttrValue
;
use
style
:
:
properties
:
:
{
DeclarationSource
Importance
PropertyDeclarationBlock
PropertyId
LonghandId
ShorthandId
}
;
use
style
:
:
properties
:
:
{
parse_one_declaration_into
parse_style_attribute
SourcePropertyDeclaration
}
;
use
style
:
:
selector_parser
:
:
PseudoElement
;
use
style
:
:
shared_lock
:
:
Locked
;
use
style_traits
:
:
ParsingMode
;
#
[
dom_struct
]
pub
struct
CSSStyleDeclaration
{
reflector_
:
Reflector
owner
:
CSSStyleOwner
readonly
:
bool
pseudo
:
Option
<
PseudoElement
>
}
#
[
derive
(
JSTraceable
MallocSizeOf
)
]
#
[
must_root
]
pub
enum
CSSStyleOwner
{
Element
(
Dom
<
Element
>
)
CSSRule
(
Dom
<
CSSRule
>
#
[
ignore_malloc_size_of
=
"
Arc
"
]
Arc
<
Locked
<
PropertyDeclarationBlock
>
>
)
}
impl
CSSStyleOwner
{
fn
mutate_associated_block
<
F
R
>
(
&
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
PropertyDeclarationBlock
&
mut
bool
)
-
>
R
{
let
mut
changed
=
true
;
match
*
self
{
CSSStyleOwner
:
:
Element
(
ref
el
)
=
>
{
let
document
=
document_from_node
(
&
*
*
el
)
;
let
shared_lock
=
document
.
style_shared_lock
(
)
;
let
mut
attr
=
el
.
style_attribute
(
)
.
borrow_mut
(
)
.
take
(
)
;
let
result
=
if
attr
.
is_some
(
)
{
let
lock
=
attr
.
as_ref
(
)
.
unwrap
(
)
;
let
mut
guard
=
shared_lock
.
write
(
)
;
let
mut
pdb
=
lock
.
write_with
(
&
mut
guard
)
;
let
result
=
f
(
&
mut
pdb
&
mut
changed
)
;
result
}
else
{
let
mut
pdb
=
PropertyDeclarationBlock
:
:
new
(
)
;
let
result
=
f
(
&
mut
pdb
&
mut
changed
)
;
changed
=
!
pdb
.
declarations
(
)
.
is_empty
(
)
;
if
changed
{
attr
=
Some
(
Arc
:
:
new
(
shared_lock
.
wrap
(
pdb
)
)
)
;
}
result
}
;
if
changed
{
if
let
Some
(
pdb
)
=
attr
{
let
guard
=
shared_lock
.
read
(
)
;
let
mut
serialization
=
String
:
:
new
(
)
;
pdb
.
read_with
(
&
guard
)
.
to_css
(
&
mut
serialization
)
.
unwrap
(
)
;
el
.
set_attribute
(
&
local_name
!
(
"
style
"
)
AttrValue
:
:
Declaration
(
serialization
pdb
)
)
;
}
}
else
{
*
el
.
style_attribute
(
)
.
borrow_mut
(
)
=
attr
;
}
result
}
CSSStyleOwner
:
:
CSSRule
(
ref
rule
ref
pdb
)
=
>
{
let
result
=
{
let
mut
guard
=
rule
.
shared_lock
(
)
.
write
(
)
;
f
(
&
mut
*
pdb
.
write_with
(
&
mut
guard
)
&
mut
changed
)
}
;
if
changed
{
rule
.
global
(
)
.
as_window
(
)
.
Document
(
)
.
invalidate_stylesheets
(
)
;
}
result
}
}
}
fn
with_block
<
F
R
>
(
&
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
PropertyDeclarationBlock
)
-
>
R
{
match
*
self
{
CSSStyleOwner
:
:
Element
(
ref
el
)
=
>
{
match
*
el
.
style_attribute
(
)
.
borrow
(
)
{
Some
(
ref
pdb
)
=
>
{
let
document
=
document_from_node
(
&
*
*
el
)
;
let
guard
=
document
.
style_shared_lock
(
)
.
read
(
)
;
f
(
pdb
.
read_with
(
&
guard
)
)
}
None
=
>
{
let
pdb
=
PropertyDeclarationBlock
:
:
new
(
)
;
f
(
&
pdb
)
}
}
}
CSSStyleOwner
:
:
CSSRule
(
ref
rule
ref
pdb
)
=
>
{
let
guard
=
rule
.
shared_lock
(
)
.
read
(
)
;
f
(
pdb
.
read_with
(
&
guard
)
)
}
}
}
fn
window
(
&
self
)
-
>
DomRoot
<
Window
>
{
match
*
self
{
CSSStyleOwner
:
:
Element
(
ref
el
)
=
>
window_from_node
(
&
*
*
el
)
CSSStyleOwner
:
:
CSSRule
(
ref
rule
_
)
=
>
DomRoot
:
:
from_ref
(
rule
.
global
(
)
.
as_window
(
)
)
}
}
fn
base_url
(
&
self
)
-
>
ServoUrl
{
match
*
self
{
CSSStyleOwner
:
:
Element
(
ref
el
)
=
>
window_from_node
(
&
*
*
el
)
.
Document
(
)
.
base_url
(
)
CSSStyleOwner
:
:
CSSRule
(
ref
rule
_
)
=
>
{
(
*
rule
.
parent_stylesheet
(
)
.
style_stylesheet
(
)
.
contents
.
url_data
.
read
(
)
)
.
clone
(
)
}
}
}
}
#
[
derive
(
MallocSizeOf
PartialEq
)
]
pub
enum
CSSModificationAccess
{
ReadWrite
Readonly
}
macro_rules
!
css_properties
(
(
(
[
getter
:
ident
setter
:
ident
id
:
expr
]
)
*
)
=
>
(
(
fn
getter
(
&
self
)
-
>
DOMString
{
debug_assert
!
(
id
.
enabled_for_all_content
(
)
"
Someone
forgot
a
#
[
Pref
]
annotation
"
)
;
self
.
get_property_value
(
id
)
}
fn
setter
(
&
self
value
:
DOMString
)
-
>
ErrorResult
{
debug_assert
!
(
id
.
enabled_for_all_content
(
)
"
Someone
forgot
a
#
[
Pref
]
annotation
"
)
;
self
.
set_property
(
id
value
DOMString
:
:
new
(
)
)
}
)
*
)
;
)
;
impl
CSSStyleDeclaration
{
#
[
allow
(
unrooted_must_root
)
]
pub
fn
new_inherited
(
owner
:
CSSStyleOwner
pseudo
:
Option
<
PseudoElement
>
modification_access
:
CSSModificationAccess
)
-
>
CSSStyleDeclaration
{
CSSStyleDeclaration
{
reflector_
:
Reflector
:
:
new
(
)
owner
:
owner
readonly
:
modification_access
=
=
CSSModificationAccess
:
:
Readonly
pseudo
:
pseudo
}
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
new
(
global
:
&
Window
owner
:
CSSStyleOwner
pseudo
:
Option
<
PseudoElement
>
modification_access
:
CSSModificationAccess
)
-
>
DomRoot
<
CSSStyleDeclaration
>
{
reflect_dom_object
(
Box
:
:
new
(
CSSStyleDeclaration
:
:
new_inherited
(
owner
pseudo
modification_access
)
)
global
CSSStyleDeclarationBinding
:
:
Wrap
)
}
fn
get_computed_style
(
&
self
property
:
PropertyId
)
-
>
DOMString
{
match
self
.
owner
{
CSSStyleOwner
:
:
CSSRule
(
.
.
)
=
>
panic
!
(
"
get_computed_style
called
on
CSSStyleDeclaration
with
a
CSSRule
owner
"
)
CSSStyleOwner
:
:
Element
(
ref
el
)
=
>
{
let
node
=
el
.
upcast
:
:
<
Node
>
(
)
;
if
!
node
.
is_in_doc
(
)
{
return
DOMString
:
:
new
(
)
;
}
let
addr
=
node
.
to_trusted_node_address
(
)
;
window_from_node
(
node
)
.
resolved_style_query
(
addr
self
.
pseudo
.
clone
(
)
property
)
}
}
}
fn
get_property_value
(
&
self
id
:
PropertyId
)
-
>
DOMString
{
if
self
.
readonly
{
return
self
.
get_computed_style
(
id
)
;
}
let
mut
string
=
String
:
:
new
(
)
;
self
.
owner
.
with_block
(
|
pdb
|
{
pdb
.
property_value_to_css
(
&
id
&
mut
string
)
.
unwrap
(
)
;
}
)
;
DOMString
:
:
from
(
string
)
}
fn
set_property
(
&
self
id
:
PropertyId
value
:
DOMString
priority
:
DOMString
)
-
>
ErrorResult
{
if
self
.
readonly
{
return
Err
(
Error
:
:
NoModificationAllowed
)
;
}
if
!
id
.
enabled_for_all_content
(
)
{
return
Ok
(
(
)
)
;
}
self
.
owner
.
mutate_associated_block
(
|
pdb
changed
|
{
if
value
.
is_empty
(
)
{
*
changed
=
pdb
.
remove_property
(
&
id
)
;
return
Ok
(
(
)
)
;
}
let
importance
=
match
&
*
priority
{
"
"
=
>
Importance
:
:
Normal
p
if
p
.
eq_ignore_ascii_case
(
"
important
"
)
=
>
Importance
:
:
Important
_
=
>
{
*
changed
=
false
;
return
Ok
(
(
)
)
;
}
}
;
let
window
=
self
.
owner
.
window
(
)
;
let
quirks_mode
=
window
.
Document
(
)
.
quirks_mode
(
)
;
let
mut
declarations
=
SourcePropertyDeclaration
:
:
new
(
)
;
let
result
=
parse_one_declaration_into
(
&
mut
declarations
id
&
value
&
self
.
owner
.
base_url
(
)
window
.
css_error_reporter
(
)
ParsingMode
:
:
DEFAULT
quirks_mode
)
;
match
result
{
Ok
(
(
)
)
=
>
{
}
Err
(
_
)
=
>
{
*
changed
=
false
;
return
Ok
(
(
)
)
;
}
}
*
changed
=
pdb
.
extend
(
declarations
.
drain
(
)
importance
DeclarationSource
:
:
CssOm
)
;
Ok
(
(
)
)
}
)
}
}
impl
CSSStyleDeclarationMethods
for
CSSStyleDeclaration
{
fn
Length
(
&
self
)
-
>
u32
{
self
.
owner
.
with_block
(
|
pdb
|
{
pdb
.
declarations
(
)
.
len
(
)
as
u32
}
)
}
fn
Item
(
&
self
index
:
u32
)
-
>
DOMString
{
self
.
IndexedGetter
(
index
)
.
unwrap_or_default
(
)
}
fn
GetPropertyValue
(
&
self
property
:
DOMString
)
-
>
DOMString
{
let
id
=
if
let
Ok
(
id
)
=
PropertyId
:
:
parse
(
&
property
)
{
id
}
else
{
return
DOMString
:
:
new
(
)
}
;
self
.
get_property_value
(
id
)
}
fn
GetPropertyPriority
(
&
self
property
:
DOMString
)
-
>
DOMString
{
let
id
=
if
let
Ok
(
id
)
=
PropertyId
:
:
parse
(
&
property
)
{
id
}
else
{
return
DOMString
:
:
new
(
)
}
;
self
.
owner
.
with_block
(
|
pdb
|
{
if
pdb
.
property_priority
(
&
id
)
.
important
(
)
{
DOMString
:
:
from
(
"
important
"
)
}
else
{
DOMString
:
:
new
(
)
}
}
)
}
fn
SetProperty
(
&
self
property
:
DOMString
value
:
DOMString
priority
:
DOMString
)
-
>
ErrorResult
{
let
id
=
if
let
Ok
(
id
)
=
PropertyId
:
:
parse
(
&
property
)
{
id
}
else
{
return
Ok
(
(
)
)
}
;
self
.
set_property
(
id
value
priority
)
}
fn
SetPropertyPriority
(
&
self
property
:
DOMString
priority
:
DOMString
)
-
>
ErrorResult
{
if
self
.
readonly
{
return
Err
(
Error
:
:
NoModificationAllowed
)
;
}
let
id
=
match
PropertyId
:
:
parse
(
&
property
)
{
Ok
(
id
)
=
>
id
Err
(
.
.
)
=
>
return
Ok
(
(
)
)
}
;
let
importance
=
match
&
*
priority
{
"
"
=
>
Importance
:
:
Normal
p
if
p
.
eq_ignore_ascii_case
(
"
important
"
)
=
>
Importance
:
:
Important
_
=
>
return
Ok
(
(
)
)
}
;
self
.
owner
.
mutate_associated_block
(
|
pdb
changed
|
{
*
changed
=
pdb
.
set_importance
(
&
id
importance
)
;
}
)
;
Ok
(
(
)
)
}
fn
SetPropertyValue
(
&
self
property
:
DOMString
value
:
DOMString
)
-
>
ErrorResult
{
self
.
SetProperty
(
property
value
DOMString
:
:
new
(
)
)
}
fn
RemoveProperty
(
&
self
property
:
DOMString
)
-
>
Fallible
<
DOMString
>
{
if
self
.
readonly
{
return
Err
(
Error
:
:
NoModificationAllowed
)
;
}
let
id
=
if
let
Ok
(
id
)
=
PropertyId
:
:
parse
(
&
property
)
{
id
}
else
{
return
Ok
(
DOMString
:
:
new
(
)
)
}
;
let
mut
string
=
String
:
:
new
(
)
;
self
.
owner
.
mutate_associated_block
(
|
pdb
changed
|
{
pdb
.
property_value_to_css
(
&
id
&
mut
string
)
.
unwrap
(
)
;
*
changed
=
pdb
.
remove_property
(
&
id
)
;
}
)
;
Ok
(
DOMString
:
:
from
(
string
)
)
}
fn
CssFloat
(
&
self
)
-
>
DOMString
{
self
.
GetPropertyValue
(
DOMString
:
:
from
(
"
float
"
)
)
}
fn
SetCssFloat
(
&
self
value
:
DOMString
)
-
>
ErrorResult
{
self
.
SetPropertyValue
(
DOMString
:
:
from
(
"
float
"
)
value
)
}
fn
IndexedGetter
(
&
self
index
:
u32
)
-
>
Option
<
DOMString
>
{
self
.
owner
.
with_block
(
|
pdb
|
{
pdb
.
declarations
(
)
.
get
(
index
as
usize
)
.
map
(
|
declaration
|
{
let
important
=
pdb
.
declarations_importance
(
)
.
get
(
index
)
;
let
mut
css
=
String
:
:
new
(
)
;
declaration
.
to_css
(
&
mut
css
)
.
unwrap
(
)
;
if
important
{
css
+
=
"
!
important
"
;
}
DOMString
:
:
from
(
css
)
}
)
}
)
}
fn
CssText
(
&
self
)
-
>
DOMString
{
self
.
owner
.
with_block
(
|
pdb
|
{
let
mut
serialization
=
String
:
:
new
(
)
;
pdb
.
to_css
(
&
mut
serialization
)
.
unwrap
(
)
;
DOMString
:
:
from
(
serialization
)
}
)
}
fn
SetCssText
(
&
self
value
:
DOMString
)
-
>
ErrorResult
{
let
window
=
self
.
owner
.
window
(
)
;
if
self
.
readonly
{
return
Err
(
Error
:
:
NoModificationAllowed
)
;
}
let
quirks_mode
=
window
.
Document
(
)
.
quirks_mode
(
)
;
self
.
owner
.
mutate_associated_block
(
|
pdb
_changed
|
{
*
pdb
=
parse_style_attribute
(
&
value
&
self
.
owner
.
base_url
(
)
window
.
css_error_reporter
(
)
quirks_mode
)
;
}
)
;
Ok
(
(
)
)
}
css_properties_accessors
!
(
css_properties
)
;
}
