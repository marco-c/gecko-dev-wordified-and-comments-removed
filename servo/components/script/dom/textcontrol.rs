use
dom
:
:
bindings
:
:
cell
:
:
DomRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
HTMLFormElementBinding
:
:
SelectionMode
;
use
dom
:
:
bindings
:
:
conversions
:
:
DerivedFrom
;
use
dom
:
:
bindings
:
:
error
:
:
{
Error
ErrorResult
}
;
use
dom
:
:
bindings
:
:
str
:
:
DOMString
;
use
dom
:
:
event
:
:
{
EventBubbles
EventCancelable
}
;
use
dom
:
:
eventtarget
:
:
EventTarget
;
use
dom
:
:
node
:
:
{
Node
NodeDamage
window_from_node
}
;
use
script_traits
:
:
ScriptToConstellationChan
;
use
textinput
:
:
{
SelectionDirection
SelectionState
TextInput
}
;
pub
trait
TextControlElement
:
DerivedFrom
<
EventTarget
>
+
DerivedFrom
<
Node
>
{
fn
selection_api_applies
(
&
self
)
-
>
bool
;
fn
has_selectable_text
(
&
self
)
-
>
bool
;
fn
set_dirty_value_flag
(
&
self
value
:
bool
)
;
}
pub
struct
TextControlSelection
<
'
a
E
:
TextControlElement
>
{
element
:
&
'
a
E
textinput
:
&
'
a
DomRefCell
<
TextInput
<
ScriptToConstellationChan
>
>
}
impl
<
'
a
E
:
TextControlElement
>
TextControlSelection
<
'
a
E
>
{
pub
fn
new
(
element
:
&
'
a
E
textinput
:
&
'
a
DomRefCell
<
TextInput
<
ScriptToConstellationChan
>
>
)
-
>
Self
{
TextControlSelection
{
element
textinput
}
}
pub
fn
dom_select
(
&
self
)
{
if
!
self
.
element
.
has_selectable_text
(
)
{
return
;
}
self
.
set_range
(
Some
(
0
)
Some
(
u32
:
:
max_value
(
)
)
None
None
)
;
}
pub
fn
dom_start
(
&
self
)
-
>
Option
<
u32
>
{
if
!
self
.
element
.
selection_api_applies
(
)
{
return
None
;
}
Some
(
self
.
start
(
)
)
}
pub
fn
set_dom_start
(
&
self
start
:
Option
<
u32
>
)
-
>
ErrorResult
{
if
!
self
.
element
.
selection_api_applies
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
let
mut
end
=
self
.
end
(
)
;
if
let
Some
(
s
)
=
start
{
if
end
<
s
{
end
=
s
;
}
}
self
.
set_range
(
start
Some
(
end
)
Some
(
self
.
direction
(
)
)
None
)
;
Ok
(
(
)
)
}
pub
fn
dom_end
(
&
self
)
-
>
Option
<
u32
>
{
if
!
self
.
element
.
selection_api_applies
(
)
{
return
None
;
}
Some
(
self
.
end
(
)
)
}
pub
fn
set_dom_end
(
&
self
end
:
Option
<
u32
>
)
-
>
ErrorResult
{
if
!
self
.
element
.
selection_api_applies
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
self
.
set_range
(
Some
(
self
.
start
(
)
)
end
Some
(
self
.
direction
(
)
)
None
)
;
Ok
(
(
)
)
}
pub
fn
dom_direction
(
&
self
)
-
>
Option
<
DOMString
>
{
if
!
self
.
element
.
selection_api_applies
(
)
{
return
None
;
}
Some
(
DOMString
:
:
from
(
self
.
direction
(
)
)
)
}
pub
fn
set_dom_direction
(
&
self
direction
:
Option
<
DOMString
>
)
-
>
ErrorResult
{
if
!
self
.
element
.
selection_api_applies
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
self
.
set_range
(
Some
(
self
.
start
(
)
)
Some
(
self
.
end
(
)
)
direction
.
map
(
|
d
|
SelectionDirection
:
:
from
(
d
)
)
None
)
;
Ok
(
(
)
)
}
pub
fn
set_dom_range
(
&
self
start
:
u32
end
:
u32
direction
:
Option
<
DOMString
>
)
-
>
ErrorResult
{
if
!
self
.
element
.
selection_api_applies
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
self
.
set_range
(
Some
(
start
)
Some
(
end
)
direction
.
map
(
|
d
|
SelectionDirection
:
:
from
(
d
)
)
None
)
;
Ok
(
(
)
)
}
pub
fn
set_dom_range_text
(
&
self
replacement
:
DOMString
start
:
Option
<
u32
>
end
:
Option
<
u32
>
selection_mode
:
SelectionMode
)
-
>
ErrorResult
{
if
!
self
.
element
.
selection_api_applies
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
self
.
element
.
set_dirty_value_flag
(
true
)
;
let
mut
start
=
start
.
unwrap_or_else
(
|
|
self
.
start
(
)
)
;
let
mut
end
=
end
.
unwrap_or_else
(
|
|
self
.
end
(
)
)
;
if
start
>
end
{
return
Err
(
Error
:
:
IndexSize
)
;
}
let
original_selection_state
=
self
.
textinput
.
borrow
(
)
.
selection_state
(
)
;
let
content_length
=
self
.
textinput
.
borrow
(
)
.
len
(
)
as
u32
;
if
start
>
content_length
{
start
=
content_length
;
}
if
end
>
content_length
{
end
=
content_length
;
}
let
mut
selection_start
=
self
.
start
(
)
;
let
mut
selection_end
=
self
.
end
(
)
;
let
new_length
=
replacement
.
len
(
)
as
u32
;
{
let
mut
textinput
=
self
.
textinput
.
borrow_mut
(
)
;
textinput
.
set_selection_range
(
start
end
SelectionDirection
:
:
None
)
;
textinput
.
replace_selection
(
replacement
)
;
}
let
new_end
=
start
+
new_length
;
match
selection_mode
{
SelectionMode
:
:
Select
=
>
{
selection_start
=
start
;
selection_end
=
new_end
;
}
SelectionMode
:
:
Start
=
>
{
selection_start
=
start
;
selection_end
=
start
;
}
SelectionMode
:
:
End
=
>
{
selection_start
=
new_end
;
selection_end
=
new_end
;
}
SelectionMode
:
:
Preserve
=
>
{
let
old_length
=
end
-
start
;
let
delta
=
(
new_length
as
isize
)
-
(
old_length
as
isize
)
;
if
selection_start
>
end
{
selection_start
=
(
(
selection_start
as
isize
)
+
delta
)
as
u32
;
}
else
if
selection_start
>
start
{
selection_start
=
start
;
}
if
selection_end
>
end
{
selection_end
=
(
(
selection_end
as
isize
)
+
delta
)
as
u32
;
}
else
if
selection_end
>
start
{
selection_end
=
new_end
;
}
}
}
self
.
set_range
(
Some
(
selection_start
)
Some
(
selection_end
)
None
Some
(
original_selection_state
)
)
;
Ok
(
(
)
)
}
fn
start
(
&
self
)
-
>
u32
{
self
.
textinput
.
borrow
(
)
.
selection_start_offset
(
)
as
u32
}
fn
end
(
&
self
)
-
>
u32
{
self
.
textinput
.
borrow
(
)
.
selection_end_offset
(
)
as
u32
}
fn
direction
(
&
self
)
-
>
SelectionDirection
{
self
.
textinput
.
borrow
(
)
.
selection_direction
(
)
}
fn
set_range
(
&
self
start
:
Option
<
u32
>
end
:
Option
<
u32
>
direction
:
Option
<
SelectionDirection
>
original_selection_state
:
Option
<
SelectionState
>
)
{
let
mut
textinput
=
self
.
textinput
.
borrow_mut
(
)
;
let
original_selection_state
=
original_selection_state
.
unwrap_or_else
(
|
|
textinput
.
selection_state
(
)
)
;
let
start
=
start
.
unwrap_or
(
0
)
;
let
end
=
end
.
unwrap_or
(
0
)
;
textinput
.
set_selection_range
(
start
end
direction
.
unwrap_or
(
SelectionDirection
:
:
None
)
)
;
if
textinput
.
selection_state
(
)
!
=
original_selection_state
{
let
window
=
window_from_node
(
self
.
element
)
;
window
.
user_interaction_task_source
(
)
.
queue_event
(
&
self
.
element
.
upcast
:
:
<
EventTarget
>
(
)
atom
!
(
"
select
"
)
EventBubbles
:
:
Bubbles
EventCancelable
:
:
NotCancelable
&
window
)
;
}
self
.
element
.
upcast
:
:
<
Node
>
(
)
.
dirty
(
NodeDamage
:
:
OtherNodeDamage
)
;
}
}
