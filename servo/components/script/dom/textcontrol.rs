use
dom
:
:
bindings
:
:
cell
:
:
DomRefCell
;
use
dom
:
:
bindings
:
:
conversions
:
:
DerivedFrom
;
use
dom
:
:
bindings
:
:
error
:
:
{
Error
ErrorResult
}
;
use
dom
:
:
bindings
:
:
str
:
:
DOMString
;
use
dom
:
:
event
:
:
{
EventBubbles
EventCancelable
}
;
use
dom
:
:
eventtarget
:
:
EventTarget
;
use
dom
:
:
node
:
:
{
Node
NodeDamage
window_from_node
}
;
use
script_traits
:
:
ScriptToConstellationChan
;
use
textinput
:
:
{
SelectionDirection
TextInput
}
;
pub
trait
TextControl
:
DerivedFrom
<
EventTarget
>
+
DerivedFrom
<
Node
>
{
fn
textinput
(
&
self
)
-
>
&
DomRefCell
<
TextInput
<
ScriptToConstellationChan
>
>
;
fn
selection_api_applies
(
&
self
)
-
>
bool
;
fn
get_dom_selection_start
(
&
self
)
-
>
Option
<
u32
>
{
if
!
self
.
selection_api_applies
(
)
{
return
None
;
}
Some
(
self
.
selection_start
(
)
)
}
fn
set_dom_selection_start
(
&
self
start
:
Option
<
u32
>
)
-
>
ErrorResult
{
if
!
self
.
selection_api_applies
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
let
mut
end
=
self
.
selection_end
(
)
;
if
let
Some
(
s
)
=
start
{
if
end
<
s
{
end
=
s
;
}
}
self
.
set_selection_range
(
start
Some
(
end
)
Some
(
self
.
selection_direction
(
)
)
)
;
Ok
(
(
)
)
}
fn
get_dom_selection_end
(
&
self
)
-
>
Option
<
u32
>
{
if
!
self
.
selection_api_applies
(
)
{
return
None
;
}
Some
(
self
.
selection_end
(
)
)
}
fn
set_dom_selection_end
(
&
self
end
:
Option
<
u32
>
)
-
>
ErrorResult
{
if
!
self
.
selection_api_applies
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
self
.
set_selection_range
(
Some
(
self
.
selection_start
(
)
)
end
Some
(
self
.
selection_direction
(
)
)
)
;
Ok
(
(
)
)
}
fn
get_dom_selection_direction
(
&
self
)
-
>
Option
<
DOMString
>
{
if
!
self
.
selection_api_applies
(
)
{
return
None
;
}
Some
(
DOMString
:
:
from
(
self
.
selection_direction
(
)
)
)
}
fn
set_dom_selection_direction
(
&
self
direction
:
Option
<
DOMString
>
)
-
>
ErrorResult
{
if
!
self
.
selection_api_applies
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
self
.
set_selection_range
(
Some
(
self
.
selection_start
(
)
)
Some
(
self
.
selection_end
(
)
)
direction
.
map
(
|
d
|
SelectionDirection
:
:
from
(
d
)
)
)
;
Ok
(
(
)
)
}
fn
set_dom_selection_range
(
&
self
start
:
u32
end
:
u32
direction
:
Option
<
DOMString
>
)
-
>
ErrorResult
{
if
!
self
.
selection_api_applies
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
self
.
set_selection_range
(
Some
(
start
)
Some
(
end
)
direction
.
map
(
|
d
|
SelectionDirection
:
:
from
(
d
)
)
)
;
Ok
(
(
)
)
}
fn
selection_start
(
&
self
)
-
>
u32
{
self
.
textinput
(
)
.
borrow
(
)
.
get_selection_start
(
)
}
fn
selection_end
(
&
self
)
-
>
u32
{
self
.
textinput
(
)
.
borrow
(
)
.
get_absolute_insertion_point
(
)
as
u32
}
fn
selection_direction
(
&
self
)
-
>
SelectionDirection
{
self
.
textinput
(
)
.
borrow
(
)
.
selection_direction
}
fn
set_selection_range
(
&
self
start
:
Option
<
u32
>
end
:
Option
<
u32
>
direction
:
Option
<
SelectionDirection
>
)
{
let
start
=
start
.
unwrap_or
(
0
)
;
let
end
=
end
.
unwrap_or
(
0
)
;
self
.
textinput
(
)
.
borrow_mut
(
)
.
set_selection_range
(
start
end
direction
.
unwrap_or
(
SelectionDirection
:
:
None
)
)
;
let
window
=
window_from_node
(
self
)
;
let
_
=
window
.
user_interaction_task_source
(
)
.
queue_event
(
&
self
.
upcast
:
:
<
EventTarget
>
(
)
atom
!
(
"
select
"
)
EventBubbles
:
:
Bubbles
EventCancelable
:
:
NotCancelable
&
window
)
;
self
.
upcast
:
:
<
Node
>
(
)
.
dirty
(
NodeDamage
:
:
OtherNodeDamage
)
;
}
}
