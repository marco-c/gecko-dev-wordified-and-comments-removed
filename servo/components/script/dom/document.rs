use
cookie_rs
;
use
devtools_traits
:
:
ScriptToDevtoolsControlMsg
;
use
document_loader
:
:
{
DocumentLoader
LoadType
}
;
use
dom
:
:
activation
:
:
{
ActivationSource
synthetic_click_activation
}
;
use
dom
:
:
attr
:
:
Attr
;
use
dom
:
:
beforeunloadevent
:
:
BeforeUnloadEvent
;
use
dom
:
:
bindings
:
:
callback
:
:
ExceptionHandling
;
use
dom
:
:
bindings
:
:
cell
:
:
DomRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
DocumentBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
DocumentBinding
:
:
{
DocumentMethods
DocumentReadyState
ElementCreationOptions
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
HTMLIFrameElementBinding
:
:
HTMLIFrameElementBinding
:
:
HTMLIFrameElementMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeBinding
:
:
NodeMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeFilterBinding
:
:
NodeFilter
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
PerformanceBinding
:
:
PerformanceMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
TouchBinding
:
:
TouchMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
WindowBinding
:
:
{
FrameRequestCallback
ScrollBehavior
WindowMethods
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
UnionTypes
:
:
NodeOrString
;
use
dom
:
:
bindings
:
:
error
:
:
{
Error
ErrorResult
Fallible
}
;
use
dom
:
:
bindings
:
:
inheritance
:
:
{
Castable
ElementTypeId
HTMLElementTypeId
NodeTypeId
}
;
use
dom
:
:
bindings
:
:
num
:
:
Finite
;
use
dom
:
:
bindings
:
:
refcounted
:
:
{
Trusted
TrustedPromise
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
DomObject
reflect_dom_object
}
;
use
dom
:
:
bindings
:
:
root
:
:
{
Dom
DomRoot
LayoutDom
MutNullableDom
RootedReference
}
;
use
dom
:
:
bindings
:
:
str
:
:
{
DOMString
USVString
}
;
use
dom
:
:
bindings
:
:
xmlname
:
:
{
namespace_from_domstring
validate_and_extract
xml_name_type
}
;
use
dom
:
:
bindings
:
:
xmlname
:
:
XMLName
:
:
InvalidXMLName
;
use
dom
:
:
closeevent
:
:
CloseEvent
;
use
dom
:
:
comment
:
:
Comment
;
use
dom
:
:
cssstylesheet
:
:
CSSStyleSheet
;
use
dom
:
:
customelementregistry
:
:
CustomElementDefinition
;
use
dom
:
:
customevent
:
:
CustomEvent
;
use
dom
:
:
documentfragment
:
:
DocumentFragment
;
use
dom
:
:
documenttype
:
:
DocumentType
;
use
dom
:
:
domimplementation
:
:
DOMImplementation
;
use
dom
:
:
element
:
:
{
Element
ElementCreator
ElementPerformFullscreenEnter
ElementPerformFullscreenExit
}
;
use
dom
:
:
element
:
:
CustomElementCreationMode
;
use
dom
:
:
errorevent
:
:
ErrorEvent
;
use
dom
:
:
event
:
:
{
Event
EventBubbles
EventCancelable
EventDefault
EventStatus
}
;
use
dom
:
:
eventtarget
:
:
EventTarget
;
use
dom
:
:
focusevent
:
:
FocusEvent
;
use
dom
:
:
forcetouchevent
:
:
ForceTouchEvent
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom
:
:
hashchangeevent
:
:
HashChangeEvent
;
use
dom
:
:
htmlanchorelement
:
:
HTMLAnchorElement
;
use
dom
:
:
htmlareaelement
:
:
HTMLAreaElement
;
use
dom
:
:
htmlbaseelement
:
:
HTMLBaseElement
;
use
dom
:
:
htmlbodyelement
:
:
HTMLBodyElement
;
use
dom
:
:
htmlcollection
:
:
{
CollectionFilter
HTMLCollection
}
;
use
dom
:
:
htmlelement
:
:
HTMLElement
;
use
dom
:
:
htmlembedelement
:
:
HTMLEmbedElement
;
use
dom
:
:
htmlformelement
:
:
{
FormControl
FormControlElementHelpers
HTMLFormElement
}
;
use
dom
:
:
htmlheadelement
:
:
HTMLHeadElement
;
use
dom
:
:
htmlhtmlelement
:
:
HTMLHtmlElement
;
use
dom
:
:
htmliframeelement
:
:
HTMLIFrameElement
;
use
dom
:
:
htmlimageelement
:
:
HTMLImageElement
;
use
dom
:
:
htmlmetaelement
:
:
HTMLMetaElement
;
use
dom
:
:
htmlscriptelement
:
:
{
HTMLScriptElement
ScriptResult
}
;
use
dom
:
:
htmltitleelement
:
:
HTMLTitleElement
;
use
dom
:
:
keyboardevent
:
:
KeyboardEvent
;
use
dom
:
:
location
:
:
Location
;
use
dom
:
:
messageevent
:
:
MessageEvent
;
use
dom
:
:
mouseevent
:
:
MouseEvent
;
use
dom
:
:
node
:
:
{
self
CloneChildrenFlag
Node
NodeDamage
window_from_node
NodeFlags
LayoutNodeHelpers
}
;
use
dom
:
:
node
:
:
VecPreOrderInsertionHelper
;
use
dom
:
:
nodeiterator
:
:
NodeIterator
;
use
dom
:
:
nodelist
:
:
NodeList
;
use
dom
:
:
pagetransitionevent
:
:
PageTransitionEvent
;
use
dom
:
:
popstateevent
:
:
PopStateEvent
;
use
dom
:
:
processinginstruction
:
:
ProcessingInstruction
;
use
dom
:
:
progressevent
:
:
ProgressEvent
;
use
dom
:
:
promise
:
:
Promise
;
use
dom
:
:
range
:
:
Range
;
use
dom
:
:
servoparser
:
:
ServoParser
;
use
dom
:
:
storageevent
:
:
StorageEvent
;
use
dom
:
:
stylesheetlist
:
:
StyleSheetList
;
use
dom
:
:
text
:
:
Text
;
use
dom
:
:
touch
:
:
Touch
;
use
dom
:
:
touchevent
:
:
TouchEvent
;
use
dom
:
:
touchlist
:
:
TouchList
;
use
dom
:
:
treewalker
:
:
TreeWalker
;
use
dom
:
:
uievent
:
:
UIEvent
;
use
dom
:
:
virtualmethods
:
:
vtable_for
;
use
dom
:
:
webglcontextevent
:
:
WebGLContextEvent
;
use
dom
:
:
window
:
:
{
ReflowReason
Window
}
;
use
dom
:
:
windowproxy
:
:
WindowProxy
;
use
dom_struct
:
:
dom_struct
;
use
encoding_rs
:
:
{
Encoding
UTF_8
}
;
use
euclid
:
:
Point2D
;
use
fetch
:
:
FetchCanceller
;
use
html5ever
:
:
{
LocalName
Namespace
QualName
}
;
use
hyper
:
:
header
:
:
{
Header
SetCookie
}
;
use
hyper_serde
:
:
Serde
;
use
ipc_channel
:
:
ipc
:
:
{
self
IpcSender
}
;
use
js
:
:
jsapi
:
:
{
JSContext
JSObject
JSRuntime
}
;
use
js
:
:
jsapi
:
:
JS_GetRuntime
;
use
metrics
:
:
{
InteractiveFlag
InteractiveMetrics
InteractiveWindow
ProfilerMetadataFactory
ProgressiveWebMetric
}
;
use
msg
:
:
constellation_msg
:
:
{
BrowsingContextId
Key
KeyModifiers
KeyState
TopLevelBrowsingContextId
}
;
use
net_traits
:
:
{
FetchResponseMsg
IpcSend
ReferrerPolicy
}
;
use
net_traits
:
:
CookieSource
:
:
NonHTTP
;
use
net_traits
:
:
CoreResourceMsg
:
:
{
GetCookiesForUrl
SetCookiesForUrl
}
;
use
net_traits
:
:
pub_domains
:
:
is_pub_domain
;
use
net_traits
:
:
request
:
:
RequestInit
;
use
net_traits
:
:
response
:
:
HttpsState
;
use
num_traits
:
:
ToPrimitive
;
use
profile_traits
:
:
time
:
:
{
TimerMetadata
TimerMetadataFrameType
TimerMetadataReflowType
}
;
use
script_layout_interface
:
:
message
:
:
{
Msg
NodesFromPointQueryType
ReflowGoal
}
;
use
script_runtime
:
:
{
CommonScriptMsg
ScriptThreadEventCategory
}
;
use
script_thread
:
:
{
MainThreadScriptMsg
ScriptThread
}
;
use
script_traits
:
:
{
AnimationState
DocumentActivity
MouseButton
MouseEventType
}
;
use
script_traits
:
:
{
MozBrowserEvent
MsDuration
ScriptMsg
TouchEventType
TouchId
}
;
use
script_traits
:
:
{
TouchpadPressurePhase
UntrustedNodeAddress
}
;
use
servo_arc
:
:
Arc
;
use
servo_atoms
:
:
Atom
;
use
servo_config
:
:
prefs
:
:
PREFS
;
use
servo_url
:
:
{
ImmutableOrigin
MutableOrigin
ServoUrl
}
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
cell
:
:
{
Cell
Ref
RefMut
}
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
VecDeque
}
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
:
:
{
Occupied
Vacant
}
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
iter
:
:
once
;
use
std
:
:
mem
;
use
std
:
:
ptr
:
:
NonNull
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
style
:
:
attr
:
:
AttrValue
;
use
style
:
:
context
:
:
QuirksMode
;
use
style
:
:
invalidation
:
:
element
:
:
restyle_hints
:
:
RestyleHint
;
use
style
:
:
media_queries
:
:
{
Device
MediaList
MediaType
}
;
use
style
:
:
selector_parser
:
:
{
RestyleDamage
Snapshot
}
;
use
style
:
:
shared_lock
:
:
{
SharedRwLock
as
StyleSharedRwLock
SharedRwLockReadGuard
}
;
use
style
:
:
str
:
:
{
HTML_SPACE_CHARACTERS
split_html_space_chars
str_join
}
;
use
style
:
:
stylesheet_set
:
:
StylesheetSet
;
use
style
:
:
stylesheets
:
:
{
Stylesheet
StylesheetContents
Origin
OriginSet
}
;
use
task_source
:
:
TaskSource
;
use
time
;
use
timers
:
:
OneshotTimerCallback
;
use
url
:
:
Host
;
use
url
:
:
percent_encoding
:
:
percent_decode
;
use
webrender_api
:
:
ClipId
;
const
SPURIOUS_ANIMATION_FRAME_THRESHOLD
:
u8
=
5
;
const
FAKE_REQUEST_ANIMATION_FRAME_DELAY
:
u64
=
16
;
pub
enum
TouchEventResult
{
Processed
(
bool
)
Forwarded
}
pub
enum
FireMouseEventType
{
Move
Over
Out
}
impl
FireMouseEventType
{
pub
fn
as_str
(
&
self
)
-
>
&
str
{
match
self
{
&
FireMouseEventType
:
:
Move
=
>
"
mousemove
"
&
FireMouseEventType
:
:
Over
=
>
"
mouseover
"
&
FireMouseEventType
:
:
Out
=
>
"
mouseout
"
}
}
}
#
[
derive
(
Clone
Copy
Debug
JSTraceable
MallocSizeOf
PartialEq
)
]
pub
enum
IsHTMLDocument
{
HTMLDocument
NonHTMLDocument
}
#
[
derive
(
Debug
MallocSizeOf
)
]
pub
struct
PendingRestyle
{
pub
snapshot
:
Option
<
Snapshot
>
pub
hint
:
RestyleHint
pub
damage
:
RestyleDamage
}
impl
PendingRestyle
{
pub
fn
new
(
)
-
>
Self
{
PendingRestyle
{
snapshot
:
None
hint
:
RestyleHint
:
:
empty
(
)
damage
:
RestyleDamage
:
:
empty
(
)
}
}
}
#
[
derive
(
Clone
JSTraceable
MallocSizeOf
)
]
#
[
must_root
]
struct
StyleSheetInDocument
{
#
[
ignore_malloc_size_of
=
"
Arc
"
]
sheet
:
Arc
<
Stylesheet
>
owner
:
Dom
<
Element
>
}
impl
PartialEq
for
StyleSheetInDocument
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
Arc
:
:
ptr_eq
(
&
self
.
sheet
&
other
.
sheet
)
}
}
impl
:
:
style
:
:
stylesheets
:
:
StylesheetInDocument
for
StyleSheetInDocument
{
fn
contents
(
&
self
guard
:
&
SharedRwLockReadGuard
)
-
>
&
StylesheetContents
{
self
.
sheet
.
contents
(
guard
)
}
fn
media
<
'
a
>
(
&
'
a
self
guard
:
&
'
a
SharedRwLockReadGuard
)
-
>
Option
<
&
'
a
MediaList
>
{
self
.
sheet
.
media
(
guard
)
}
fn
enabled
(
&
self
)
-
>
bool
{
self
.
sheet
.
enabled
(
)
}
}
#
[
dom_struct
]
pub
struct
Document
{
node
:
Node
window
:
Dom
<
Window
>
implementation
:
MutNullableDom
<
DOMImplementation
>
content_type
:
DOMString
last_modified
:
Option
<
String
>
encoding
:
Cell
<
&
'
static
Encoding
>
has_browsing_context
:
bool
is_html_document
:
bool
activity
:
Cell
<
DocumentActivity
>
url
:
DomRefCell
<
ServoUrl
>
#
[
ignore_malloc_size_of
=
"
defined
in
selectors
"
]
quirks_mode
:
Cell
<
QuirksMode
>
id_map
:
DomRefCell
<
HashMap
<
Atom
Vec
<
Dom
<
Element
>
>
>
>
tag_map
:
DomRefCell
<
HashMap
<
LocalName
Dom
<
HTMLCollection
>
>
>
tagns_map
:
DomRefCell
<
HashMap
<
QualName
Dom
<
HTMLCollection
>
>
>
classes_map
:
DomRefCell
<
HashMap
<
Vec
<
Atom
>
Dom
<
HTMLCollection
>
>
>
images
:
MutNullableDom
<
HTMLCollection
>
embeds
:
MutNullableDom
<
HTMLCollection
>
links
:
MutNullableDom
<
HTMLCollection
>
forms
:
MutNullableDom
<
HTMLCollection
>
scripts
:
MutNullableDom
<
HTMLCollection
>
anchors
:
MutNullableDom
<
HTMLCollection
>
applets
:
MutNullableDom
<
HTMLCollection
>
style_shared_lock
:
StyleSharedRwLock
stylesheets
:
DomRefCell
<
StylesheetSet
<
StyleSheetInDocument
>
>
stylesheet_list
:
MutNullableDom
<
StyleSheetList
>
ready_state
:
Cell
<
DocumentReadyState
>
domcontentloaded_dispatched
:
Cell
<
bool
>
possibly_focused
:
MutNullableDom
<
Element
>
focused
:
MutNullableDom
<
Element
>
current_script
:
MutNullableDom
<
HTMLScriptElement
>
pending_parsing_blocking_script
:
DomRefCell
<
Option
<
PendingScript
>
>
script_blocking_stylesheets_count
:
Cell
<
u32
>
deferred_scripts
:
PendingInOrderScriptVec
asap_in_order_scripts_list
:
PendingInOrderScriptVec
asap_scripts_set
:
DomRefCell
<
Vec
<
Dom
<
HTMLScriptElement
>
>
>
scripting_enabled
:
bool
animation_frame_ident
:
Cell
<
u32
>
animation_frame_list
:
DomRefCell
<
Vec
<
(
u32
Option
<
AnimationFrameCallback
>
)
>
>
running_animation_callbacks
:
Cell
<
bool
>
loader
:
DomRefCell
<
DocumentLoader
>
current_parser
:
MutNullableDom
<
ServoParser
>
reflow_timeout
:
Cell
<
Option
<
u64
>
>
base_element
:
MutNullableDom
<
HTMLBaseElement
>
appropriate_template_contents_owner_document
:
MutNullableDom
<
Document
>
pending_restyles
:
DomRefCell
<
HashMap
<
Dom
<
Element
>
PendingRestyle
>
>
needs_paint
:
Cell
<
bool
>
active_touch_points
:
DomRefCell
<
Vec
<
Dom
<
Touch
>
>
>
dom_loading
:
Cell
<
u64
>
dom_interactive
:
Cell
<
u64
>
dom_content_loaded_event_start
:
Cell
<
u64
>
dom_content_loaded_event_end
:
Cell
<
u64
>
dom_complete
:
Cell
<
u64
>
top_level_dom_complete
:
Cell
<
u64
>
load_event_start
:
Cell
<
u64
>
load_event_end
:
Cell
<
u64
>
https_state
:
Cell
<
HttpsState
>
touchpad_pressure_phase
:
Cell
<
TouchpadPressurePhase
>
origin
:
MutableOrigin
referrer_policy
:
Cell
<
Option
<
ReferrerPolicy
>
>
referrer
:
Option
<
String
>
target_element
:
MutNullableDom
<
Element
>
#
[
ignore_malloc_size_of
=
"
Defined
in
std
"
]
last_click_info
:
DomRefCell
<
Option
<
(
Instant
Point2D
<
f32
>
)
>
>
ignore_destructive_writes_counter
:
Cell
<
u32
>
spurious_animation_frames
:
Cell
<
u8
>
dom_count
:
Cell
<
u32
>
fullscreen_element
:
MutNullableDom
<
Element
>
form_id_listener_map
:
DomRefCell
<
HashMap
<
Atom
HashSet
<
Dom
<
Element
>
>
>
>
interactive_time
:
DomRefCell
<
InteractiveMetrics
>
tti_window
:
DomRefCell
<
InteractiveWindow
>
canceller
:
FetchCanceller
throw_on_dynamic_markup_insertion_counter
:
Cell
<
u64
>
}
#
[
derive
(
JSTraceable
MallocSizeOf
)
]
struct
ImagesFilter
;
impl
CollectionFilter
for
ImagesFilter
{
fn
filter
(
&
self
elem
:
&
Element
_root
:
&
Node
)
-
>
bool
{
elem
.
is
:
:
<
HTMLImageElement
>
(
)
}
}
#
[
derive
(
JSTraceable
MallocSizeOf
)
]
struct
EmbedsFilter
;
impl
CollectionFilter
for
EmbedsFilter
{
fn
filter
(
&
self
elem
:
&
Element
_root
:
&
Node
)
-
>
bool
{
elem
.
is
:
:
<
HTMLEmbedElement
>
(
)
}
}
#
[
derive
(
JSTraceable
MallocSizeOf
)
]
struct
LinksFilter
;
impl
CollectionFilter
for
LinksFilter
{
fn
filter
(
&
self
elem
:
&
Element
_root
:
&
Node
)
-
>
bool
{
(
elem
.
is
:
:
<
HTMLAnchorElement
>
(
)
|
|
elem
.
is
:
:
<
HTMLAreaElement
>
(
)
)
&
&
elem
.
has_attribute
(
&
local_name
!
(
"
href
"
)
)
}
}
#
[
derive
(
JSTraceable
MallocSizeOf
)
]
struct
FormsFilter
;
impl
CollectionFilter
for
FormsFilter
{
fn
filter
(
&
self
elem
:
&
Element
_root
:
&
Node
)
-
>
bool
{
elem
.
is
:
:
<
HTMLFormElement
>
(
)
}
}
#
[
derive
(
JSTraceable
MallocSizeOf
)
]
struct
ScriptsFilter
;
impl
CollectionFilter
for
ScriptsFilter
{
fn
filter
(
&
self
elem
:
&
Element
_root
:
&
Node
)
-
>
bool
{
elem
.
is
:
:
<
HTMLScriptElement
>
(
)
}
}
#
[
derive
(
JSTraceable
MallocSizeOf
)
]
struct
AnchorsFilter
;
impl
CollectionFilter
for
AnchorsFilter
{
fn
filter
(
&
self
elem
:
&
Element
_root
:
&
Node
)
-
>
bool
{
elem
.
is
:
:
<
HTMLAnchorElement
>
(
)
&
&
elem
.
has_attribute
(
&
local_name
!
(
"
href
"
)
)
}
}
impl
Document
{
#
[
inline
]
pub
fn
loader
(
&
self
)
-
>
Ref
<
DocumentLoader
>
{
self
.
loader
.
borrow
(
)
}
#
[
inline
]
pub
fn
loader_mut
(
&
self
)
-
>
RefMut
<
DocumentLoader
>
{
self
.
loader
.
borrow_mut
(
)
}
#
[
inline
]
pub
fn
has_browsing_context
(
&
self
)
-
>
bool
{
self
.
has_browsing_context
}
#
[
inline
]
pub
fn
browsing_context
(
&
self
)
-
>
Option
<
DomRoot
<
WindowProxy
>
>
{
if
self
.
has_browsing_context
{
self
.
window
.
undiscarded_window_proxy
(
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
window
(
&
self
)
-
>
&
Window
{
&
*
self
.
window
}
#
[
inline
]
pub
fn
is_html_document
(
&
self
)
-
>
bool
{
self
.
is_html_document
}
pub
fn
set_https_state
(
&
self
https_state
:
HttpsState
)
{
self
.
https_state
.
set
(
https_state
)
;
self
.
trigger_mozbrowser_event
(
MozBrowserEvent
:
:
SecurityChange
(
https_state
)
)
;
}
pub
fn
is_fully_active
(
&
self
)
-
>
bool
{
self
.
activity
.
get
(
)
=
=
DocumentActivity
:
:
FullyActive
}
pub
fn
is_active
(
&
self
)
-
>
bool
{
self
.
activity
.
get
(
)
!
=
DocumentActivity
:
:
Inactive
}
pub
fn
set_activity
(
&
self
activity
:
DocumentActivity
)
{
assert
!
(
self
.
has_browsing_context
)
;
if
activity
!
=
self
.
activity
.
get
(
)
{
self
.
activity
.
set
(
activity
)
;
if
activity
=
=
DocumentActivity
:
:
FullyActive
{
self
.
title_changed
(
)
;
self
.
dirty_all_nodes
(
)
;
self
.
window
(
)
.
reflow
(
ReflowGoal
:
:
Full
ReflowReason
:
:
CachedPageNeededReflow
)
;
self
.
window
(
)
.
resume
(
)
;
}
else
{
self
.
window
(
)
.
suspend
(
)
;
}
}
}
pub
fn
origin
(
&
self
)
-
>
&
MutableOrigin
{
&
self
.
origin
}
pub
fn
url
(
&
self
)
-
>
ServoUrl
{
self
.
url
.
borrow
(
)
.
clone
(
)
}
pub
fn
set_url
(
&
self
url
:
ServoUrl
)
{
*
self
.
url
.
borrow_mut
(
)
=
url
;
}
pub
fn
fallback_base_url
(
&
self
)
-
>
ServoUrl
{
self
.
url
(
)
}
pub
fn
base_url
(
&
self
)
-
>
ServoUrl
{
match
self
.
base_element
(
)
{
None
=
>
self
.
fallback_base_url
(
)
Some
(
base
)
=
>
base
.
frozen_base_url
(
)
}
}
pub
fn
needs_paint
(
&
self
)
-
>
bool
{
self
.
needs_paint
.
get
(
)
}
pub
fn
needs_reflow
(
&
self
)
-
>
bool
{
self
.
stylesheets
.
borrow
(
)
.
has_changed
(
)
|
|
self
.
GetDocumentElement
(
)
.
map_or
(
false
|
root
|
{
root
.
upcast
:
:
<
Node
>
(
)
.
has_dirty_descendants
(
)
|
|
!
self
.
pending_restyles
.
borrow
(
)
.
is_empty
(
)
|
|
self
.
needs_paint
(
)
}
)
}
pub
fn
base_element
(
&
self
)
-
>
Option
<
DomRoot
<
HTMLBaseElement
>
>
{
self
.
base_element
.
get
(
)
}
pub
fn
refresh_base_element
(
&
self
)
{
let
base
=
self
.
upcast
:
:
<
Node
>
(
)
.
traverse_preorder
(
)
.
filter_map
(
DomRoot
:
:
downcast
:
:
<
HTMLBaseElement
>
)
.
find
(
|
element
|
element
.
upcast
:
:
<
Element
>
(
)
.
has_attribute
(
&
local_name
!
(
"
href
"
)
)
)
;
self
.
base_element
.
set
(
base
.
r
(
)
)
;
}
pub
fn
dom_count
(
&
self
)
-
>
u32
{
self
.
dom_count
.
get
(
)
}
pub
fn
increment_dom_count
(
&
self
)
{
self
.
dom_count
.
set
(
self
.
dom_count
.
get
(
)
+
1
)
;
}
pub
fn
decrement_dom_count
(
&
self
)
{
self
.
dom_count
.
set
(
self
.
dom_count
.
get
(
)
-
1
)
;
}
pub
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
{
self
.
quirks_mode
.
get
(
)
}
pub
fn
set_quirks_mode
(
&
self
mode
:
QuirksMode
)
{
self
.
quirks_mode
.
set
(
mode
)
;
if
mode
=
=
QuirksMode
:
:
Quirks
{
self
.
window
.
layout_chan
(
)
.
send
(
Msg
:
:
SetQuirksMode
(
mode
)
)
.
unwrap
(
)
;
}
}
pub
fn
encoding
(
&
self
)
-
>
&
'
static
Encoding
{
self
.
encoding
.
get
(
)
}
pub
fn
set_encoding
(
&
self
encoding
:
&
'
static
Encoding
)
{
self
.
encoding
.
set
(
encoding
)
;
}
pub
fn
content_and_heritage_changed
(
&
self
node
:
&
Node
)
{
if
node
.
is_in_doc
(
)
{
node
.
note_dirty_descendants
(
)
;
}
node
.
dirty
(
NodeDamage
:
:
OtherNodeDamage
)
;
}
pub
fn
reflow_if_reflow_timer_expired
(
&
self
)
{
if
let
Some
(
reflow_timeout
)
=
self
.
reflow_timeout
.
get
(
)
{
if
time
:
:
precise_time_ns
(
)
<
reflow_timeout
{
return
;
}
self
.
reflow_timeout
.
set
(
None
)
;
self
.
window
.
reflow
(
ReflowGoal
:
:
Full
ReflowReason
:
:
RefreshTick
)
;
}
}
pub
fn
set_reflow_timeout
(
&
self
timeout
:
u64
)
{
if
let
Some
(
existing_timeout
)
=
self
.
reflow_timeout
.
get
(
)
{
if
existing_timeout
<
timeout
{
return
;
}
}
self
.
reflow_timeout
.
set
(
Some
(
timeout
)
)
}
pub
fn
unregister_named_element
(
&
self
to_unregister
:
&
Element
id
:
Atom
)
{
debug
!
(
"
Removing
named
element
from
document
{
:
p
}
:
{
:
p
}
id
=
{
}
"
self
to_unregister
id
)
;
{
let
mut
id_map
=
self
.
id_map
.
borrow_mut
(
)
;
let
is_empty
=
match
id_map
.
get_mut
(
&
id
)
{
None
=
>
false
Some
(
elements
)
=
>
{
let
position
=
elements
.
iter
(
)
.
position
(
|
element
|
&
*
*
element
=
=
to_unregister
)
.
expect
(
"
This
element
should
be
in
registered
.
"
)
;
elements
.
remove
(
position
)
;
elements
.
is_empty
(
)
}
}
;
if
is_empty
{
id_map
.
remove
(
&
id
)
;
}
}
self
.
reset_form_owner_for_listeners
(
&
id
)
;
}
pub
fn
register_named_element
(
&
self
element
:
&
Element
id
:
Atom
)
{
debug
!
(
"
Adding
named
element
to
document
{
:
p
}
:
{
:
p
}
id
=
{
}
"
self
element
id
)
;
assert
!
(
element
.
upcast
:
:
<
Node
>
(
)
.
is_in_doc
(
)
)
;
assert
!
(
!
id
.
is_empty
(
)
)
;
let
root
=
self
.
GetDocumentElement
(
)
.
expect
(
"
The
element
is
in
the
document
so
there
must
be
a
document
\
element
.
"
)
;
{
let
mut
id_map
=
self
.
id_map
.
borrow_mut
(
)
;
let
elements
=
id_map
.
entry
(
id
.
clone
(
)
)
.
or_insert
(
Vec
:
:
new
(
)
)
;
elements
.
insert_pre_order
(
element
root
.
r
(
)
.
upcast
:
:
<
Node
>
(
)
)
;
}
self
.
reset_form_owner_for_listeners
(
&
id
)
;
}
pub
fn
register_form_id_listener
<
T
:
?
Sized
+
FormControl
>
(
&
self
id
:
DOMString
listener
:
&
T
)
{
let
mut
map
=
self
.
form_id_listener_map
.
borrow_mut
(
)
;
let
listener
=
listener
.
to_element
(
)
;
let
set
=
map
.
entry
(
Atom
:
:
from
(
id
)
)
.
or_insert
(
HashSet
:
:
new
(
)
)
;
set
.
insert
(
Dom
:
:
from_ref
(
listener
)
)
;
}
pub
fn
unregister_form_id_listener
<
T
:
?
Sized
+
FormControl
>
(
&
self
id
:
DOMString
listener
:
&
T
)
{
let
mut
map
=
self
.
form_id_listener_map
.
borrow_mut
(
)
;
if
let
Occupied
(
mut
entry
)
=
map
.
entry
(
Atom
:
:
from
(
id
)
)
{
entry
.
get_mut
(
)
.
remove
(
&
Dom
:
:
from_ref
(
listener
.
to_element
(
)
)
)
;
if
entry
.
get
(
)
.
is_empty
(
)
{
entry
.
remove
(
)
;
}
}
}
pub
fn
find_fragment_node
(
&
self
fragid
:
&
str
)
-
>
Option
<
DomRoot
<
Element
>
>
{
percent_decode
(
fragid
.
as_bytes
(
)
)
.
decode_utf8
(
)
.
ok
(
)
.
and_then
(
|
decoded_fragid
|
self
.
get_element_by_id
(
&
Atom
:
:
from
(
decoded_fragid
)
)
)
.
or_else
(
|
|
self
.
get_anchor_by_name
(
fragid
)
)
}
pub
fn
check_and_scroll_fragment
(
&
self
fragment
:
&
str
)
{
let
target
=
self
.
find_fragment_node
(
fragment
)
;
self
.
set_target_element
(
target
.
r
(
)
)
;
let
point
=
target
.
r
(
)
.
map
(
|
element
|
{
let
rect
=
element
.
upcast
:
:
<
Node
>
(
)
.
bounding_content_box_or_zero
(
)
;
(
rect
.
origin
.
x
.
to_nearest_px
(
)
as
f32
rect
.
origin
.
y
.
to_nearest_px
(
)
as
f32
)
}
)
.
or_else
(
|
|
if
fragment
.
is_empty
(
)
|
|
fragment
.
eq_ignore_ascii_case
(
"
top
"
)
{
Some
(
(
0
.
0
0
.
0
)
)
}
else
{
None
}
)
;
if
let
Some
(
(
x
y
)
)
=
point
{
let
global_scope
=
self
.
window
.
upcast
:
:
<
GlobalScope
>
(
)
;
let
webrender_pipeline_id
=
global_scope
.
pipeline_id
(
)
.
to_webrender
(
)
;
self
.
window
.
update_viewport_for_scroll
(
x
y
)
;
self
.
window
.
perform_a_scroll
(
x
y
ClipId
:
:
root_scroll_node
(
webrender_pipeline_id
)
ScrollBehavior
:
:
Instant
target
.
r
(
)
)
;
}
}
fn
get_anchor_by_name
(
&
self
name
:
&
str
)
-
>
Option
<
DomRoot
<
Element
>
>
{
let
check_anchor
=
|
node
:
&
HTMLAnchorElement
|
{
let
elem
=
node
.
upcast
:
:
<
Element
>
(
)
;
elem
.
get_attribute
(
&
ns
!
(
)
&
local_name
!
(
"
name
"
)
)
.
map_or
(
false
|
attr
|
&
*
*
attr
.
value
(
)
=
=
name
)
}
;
let
doc_node
=
self
.
upcast
:
:
<
Node
>
(
)
;
doc_node
.
traverse_preorder
(
)
.
filter_map
(
DomRoot
:
:
downcast
)
.
find
(
|
node
|
check_anchor
(
&
node
)
)
.
map
(
DomRoot
:
:
upcast
)
}
pub
fn
set_ready_state
(
&
self
state
:
DocumentReadyState
)
{
match
state
{
DocumentReadyState
:
:
Loading
=
>
{
self
.
trigger_mozbrowser_event
(
MozBrowserEvent
:
:
Connected
)
;
update_with_current_time_ms
(
&
self
.
dom_loading
)
;
}
DocumentReadyState
:
:
Complete
=
>
{
self
.
trigger_mozbrowser_event
(
MozBrowserEvent
:
:
LoadEnd
)
;
update_with_current_time_ms
(
&
self
.
dom_complete
)
;
}
DocumentReadyState
:
:
Interactive
=
>
update_with_current_time_ms
(
&
self
.
dom_interactive
)
}
;
self
.
ready_state
.
set
(
state
)
;
self
.
upcast
:
:
<
EventTarget
>
(
)
.
fire_event
(
atom
!
(
"
readystatechange
"
)
)
;
}
pub
fn
is_scripting_enabled
(
&
self
)
-
>
bool
{
self
.
scripting_enabled
}
pub
fn
get_focused_element
(
&
self
)
-
>
Option
<
DomRoot
<
Element
>
>
{
self
.
focused
.
get
(
)
}
pub
fn
begin_focus_transaction
(
&
self
)
{
self
.
possibly_focused
.
set
(
None
)
;
}
pub
fn
request_focus
(
&
self
elem
:
&
Element
)
{
if
elem
.
is_focusable_area
(
)
{
self
.
possibly_focused
.
set
(
Some
(
elem
)
)
}
}
pub
fn
commit_focus_transaction
(
&
self
focus_type
:
FocusType
)
{
if
self
.
focused
=
=
self
.
possibly_focused
.
get
(
)
.
r
(
)
{
return
}
if
let
Some
(
ref
elem
)
=
self
.
focused
.
get
(
)
{
let
node
=
elem
.
upcast
:
:
<
Node
>
(
)
;
elem
.
set_focus_state
(
false
)
;
self
.
fire_focus_event
(
FocusEventType
:
:
Blur
node
None
)
;
}
self
.
focused
.
set
(
self
.
possibly_focused
.
get
(
)
.
r
(
)
)
;
if
let
Some
(
ref
elem
)
=
self
.
focused
.
get
(
)
{
elem
.
set_focus_state
(
true
)
;
let
node
=
elem
.
upcast
:
:
<
Node
>
(
)
;
self
.
fire_focus_event
(
FocusEventType
:
:
Focus
node
None
)
;
if
focus_type
=
=
FocusType
:
:
Element
{
self
.
send_to_constellation
(
ScriptMsg
:
:
Focus
)
;
}
}
}
pub
fn
title_changed
(
&
self
)
{
if
self
.
browsing_context
(
)
.
is_some
(
)
{
self
.
trigger_mozbrowser_event
(
MozBrowserEvent
:
:
TitleChange
(
String
:
:
from
(
self
.
Title
(
)
)
)
)
;
self
.
send_title_to_constellation
(
)
;
}
}
pub
fn
send_title_to_constellation
(
&
self
)
{
let
title
=
Some
(
String
:
:
from
(
self
.
Title
(
)
)
)
;
self
.
send_to_constellation
(
ScriptMsg
:
:
SetTitle
(
title
)
)
;
}
pub
fn
dirty_all_nodes
(
&
self
)
{
let
root
=
self
.
upcast
:
:
<
Node
>
(
)
;
for
node
in
root
.
traverse_preorder
(
)
{
node
.
dirty
(
NodeDamage
:
:
OtherNodeDamage
)
}
}
#
[
allow
(
unsafe_code
)
]
pub
fn
handle_mouse_event
(
&
self
js_runtime
:
*
mut
JSRuntime
_button
:
MouseButton
client_point
:
Point2D
<
f32
>
mouse_event_type
:
MouseEventType
node_address
:
Option
<
UntrustedNodeAddress
>
point_in_node
:
Option
<
Point2D
<
f32
>
>
)
{
let
mouse_event_type_string
=
match
mouse_event_type
{
MouseEventType
:
:
Click
=
>
"
click
"
.
to_owned
(
)
MouseEventType
:
:
MouseUp
=
>
"
mouseup
"
.
to_owned
(
)
MouseEventType
:
:
MouseDown
=
>
"
mousedown
"
.
to_owned
(
)
}
;
debug
!
(
"
{
}
:
at
{
:
?
}
"
mouse_event_type_string
client_point
)
;
let
el
=
node_address
.
and_then
(
|
address
|
{
let
node
=
unsafe
{
node
:
:
from_untrusted_node_address
(
js_runtime
address
)
}
;
node
.
inclusive_ancestors
(
)
.
filter_map
(
DomRoot
:
:
downcast
:
:
<
Element
>
)
.
next
(
)
}
)
;
let
el
=
match
el
{
Some
(
el
)
=
>
el
None
=
>
return
}
;
let
node
=
el
.
upcast
:
:
<
Node
>
(
)
;
debug
!
(
"
{
}
on
{
:
?
}
"
mouse_event_type_string
node
.
debug_str
(
)
)
;
if
let
MouseEventType
:
:
Click
=
mouse_event_type
{
if
el
.
click_event_filter_by_disabled_state
(
)
{
return
;
}
self
.
begin_focus_transaction
(
)
;
}
let
client_x
=
client_point
.
x
as
i32
;
let
client_y
=
client_point
.
y
as
i32
;
let
click_count
=
1
;
let
event
=
MouseEvent
:
:
new
(
&
self
.
window
DOMString
:
:
from
(
mouse_event_type_string
)
EventBubbles
:
:
Bubbles
EventCancelable
:
:
Cancelable
Some
(
&
self
.
window
)
click_count
client_x
client_y
client_x
client_y
false
false
false
false
0i16
None
point_in_node
)
;
let
event
=
event
.
upcast
:
:
<
Event
>
(
)
;
event
.
set_trusted
(
true
)
;
let
activatable
=
el
.
as_maybe_activatable
(
)
;
match
mouse_event_type
{
MouseEventType
:
:
Click
=
>
el
.
authentic_click_activation
(
event
)
MouseEventType
:
:
MouseDown
=
>
{
if
let
Some
(
a
)
=
activatable
{
a
.
enter_formal_activation_state
(
)
;
}
let
target
=
node
.
upcast
(
)
;
event
.
fire
(
target
)
;
}
MouseEventType
:
:
MouseUp
=
>
{
if
let
Some
(
a
)
=
activatable
{
a
.
exit_formal_activation_state
(
)
;
}
let
target
=
node
.
upcast
(
)
;
event
.
fire
(
target
)
;
}
}
if
let
MouseEventType
:
:
Click
=
mouse_event_type
{
self
.
commit_focus_transaction
(
FocusType
:
:
Element
)
;
self
.
maybe_fire_dblclick
(
client_point
node
)
;
}
self
.
window
.
reflow
(
ReflowGoal
:
:
Full
ReflowReason
:
:
MouseEvent
)
;
}
fn
maybe_fire_dblclick
(
&
self
click_pos
:
Point2D
<
f32
>
target
:
&
Node
)
{
let
now
=
Instant
:
:
now
(
)
;
let
opt
=
self
.
last_click_info
.
borrow_mut
(
)
.
take
(
)
;
if
let
Some
(
(
last_time
last_pos
)
)
=
opt
{
let
DBL_CLICK_TIMEOUT
=
Duration
:
:
from_millis
(
PREFS
.
get
(
"
dom
.
document
.
dblclick_timeout
"
)
.
as_u64
(
)
.
unwrap_or
(
300
)
)
;
let
DBL_CLICK_DIST_THRESHOLD
=
PREFS
.
get
(
"
dom
.
document
.
dblclick_dist
"
)
.
as_u64
(
)
.
unwrap_or
(
1
)
;
let
line
=
click_pos
-
last_pos
;
let
dist
=
(
line
.
dot
(
line
)
as
f64
)
.
sqrt
(
)
;
if
now
.
duration_since
(
last_time
)
<
DBL_CLICK_TIMEOUT
&
&
dist
<
DBL_CLICK_DIST_THRESHOLD
as
f64
{
let
click_count
=
2
;
let
client_x
=
click_pos
.
x
as
i32
;
let
client_y
=
click_pos
.
y
as
i32
;
let
event
=
MouseEvent
:
:
new
(
&
self
.
window
DOMString
:
:
from
(
"
dblclick
"
)
EventBubbles
:
:
Bubbles
EventCancelable
:
:
Cancelable
Some
(
&
self
.
window
)
click_count
client_x
client_y
client_x
client_y
false
false
false
false
0i16
None
None
)
;
event
.
upcast
:
:
<
Event
>
(
)
.
fire
(
target
.
upcast
(
)
)
;
return
;
}
}
*
self
.
last_click_info
.
borrow_mut
(
)
=
Some
(
(
now
click_pos
)
)
;
}
#
[
allow
(
unsafe_code
)
]
pub
fn
handle_touchpad_pressure_event
(
&
self
js_runtime
:
*
mut
JSRuntime
pressure
:
f32
phase_now
:
TouchpadPressurePhase
node_address
:
Option
<
UntrustedNodeAddress
>
)
{
let
el
=
node_address
.
and_then
(
|
address
|
{
let
node
=
unsafe
{
node
:
:
from_untrusted_node_address
(
js_runtime
address
)
}
;
node
.
inclusive_ancestors
(
)
.
filter_map
(
DomRoot
:
:
downcast
:
:
<
Element
>
)
.
next
(
)
}
)
;
let
el
=
match
el
{
Some
(
el
)
=
>
el
None
=
>
return
}
;
let
phase_before
=
self
.
touchpad_pressure_phase
.
get
(
)
;
self
.
touchpad_pressure_phase
.
set
(
phase_now
)
;
if
phase_before
=
=
TouchpadPressurePhase
:
:
BeforeClick
&
&
phase_now
=
=
TouchpadPressurePhase
:
:
BeforeClick
{
return
;
}
let
node
=
el
.
upcast
:
:
<
Node
>
(
)
;
let
target
=
node
.
upcast
(
)
;
let
force
=
match
phase_now
{
TouchpadPressurePhase
:
:
BeforeClick
=
>
pressure
TouchpadPressurePhase
:
:
AfterFirstClick
=
>
1
.
+
pressure
TouchpadPressurePhase
:
:
AfterSecondClick
=
>
2
.
+
pressure
}
;
if
phase_now
!
=
TouchpadPressurePhase
:
:
BeforeClick
{
self
.
fire_forcetouch_event
(
"
servomouseforcechanged
"
.
to_owned
(
)
target
force
)
;
}
if
phase_before
!
=
TouchpadPressurePhase
:
:
AfterSecondClick
&
&
phase_now
=
=
TouchpadPressurePhase
:
:
AfterSecondClick
{
self
.
fire_forcetouch_event
(
"
servomouseforcedown
"
.
to_owned
(
)
target
force
)
;
}
if
phase_before
=
=
TouchpadPressurePhase
:
:
AfterSecondClick
&
&
phase_now
!
=
TouchpadPressurePhase
:
:
AfterSecondClick
{
self
.
fire_forcetouch_event
(
"
servomouseforceup
"
.
to_owned
(
)
target
force
)
;
}
}
fn
fire_forcetouch_event
(
&
self
event_name
:
String
target
:
&
EventTarget
force
:
f32
)
{
let
force_event
=
ForceTouchEvent
:
:
new
(
&
self
.
window
DOMString
:
:
from
(
event_name
)
force
)
;
let
event
=
force_event
.
upcast
:
:
<
Event
>
(
)
;
event
.
fire
(
target
)
;
}
pub
fn
fire_mouse_event
(
&
self
client_point
:
Point2D
<
f32
>
target
:
&
EventTarget
event_name
:
FireMouseEventType
)
{
let
client_x
=
client_point
.
x
.
to_i32
(
)
.
unwrap_or
(
0
)
;
let
client_y
=
client_point
.
y
.
to_i32
(
)
.
unwrap_or
(
0
)
;
let
mouse_event
=
MouseEvent
:
:
new
(
&
self
.
window
DOMString
:
:
from
(
event_name
.
as_str
(
)
)
EventBubbles
:
:
Bubbles
EventCancelable
:
:
Cancelable
Some
(
&
self
.
window
)
0i32
client_x
client_y
client_x
client_y
false
false
false
false
0i16
None
None
)
;
let
event
=
mouse_event
.
upcast
:
:
<
Event
>
(
)
;
event
.
fire
(
target
)
;
}
#
[
allow
(
unsafe_code
)
]
pub
fn
handle_mouse_move_event
(
&
self
js_runtime
:
*
mut
JSRuntime
client_point
:
Option
<
Point2D
<
f32
>
>
prev_mouse_over_target
:
&
MutNullableDom
<
Element
>
node_address
:
Option
<
UntrustedNodeAddress
>
)
{
let
client_point
=
match
client_point
{
None
=
>
{
prev_mouse_over_target
.
set
(
None
)
;
return
;
}
Some
(
client_point
)
=
>
client_point
}
;
let
maybe_new_target
=
node_address
.
and_then
(
|
address
|
{
let
node
=
unsafe
{
node
:
:
from_untrusted_node_address
(
js_runtime
address
)
}
;
node
.
inclusive_ancestors
(
)
.
filter_map
(
DomRoot
:
:
downcast
:
:
<
Element
>
)
.
next
(
)
}
)
;
let
new_target
=
match
maybe_new_target
{
Some
(
ref
target
)
=
>
target
None
=
>
return
}
;
self
.
fire_mouse_event
(
client_point
new_target
.
upcast
(
)
FireMouseEventType
:
:
Move
)
;
if
maybe_new_target
=
=
prev_mouse_over_target
.
get
(
)
{
return
;
}
let
old_target_is_ancestor_of_new_target
=
match
(
prev_mouse_over_target
.
get
(
)
maybe_new_target
.
as_ref
(
)
)
{
(
Some
(
old_target
)
Some
(
new_target
)
)
=
>
old_target
.
upcast
:
:
<
Node
>
(
)
.
is_ancestor_of
(
new_target
.
upcast
:
:
<
Node
>
(
)
)
_
=
>
false
}
;
if
let
Some
(
old_target
)
=
prev_mouse_over_target
.
get
(
)
{
if
!
old_target_is_ancestor_of_new_target
{
for
element
in
old_target
.
upcast
:
:
<
Node
>
(
)
.
inclusive_ancestors
(
)
.
filter_map
(
DomRoot
:
:
downcast
:
:
<
Element
>
)
{
element
.
set_hover_state
(
false
)
;
element
.
set_active_state
(
false
)
;
}
}
self
.
fire_mouse_event
(
client_point
old_target
.
upcast
(
)
FireMouseEventType
:
:
Out
)
;
}
if
let
Some
(
ref
new_target
)
=
maybe_new_target
{
for
element
in
new_target
.
upcast
:
:
<
Node
>
(
)
.
inclusive_ancestors
(
)
.
filter_map
(
DomRoot
:
:
downcast
:
:
<
Element
>
)
{
if
element
.
hover_state
(
)
{
break
;
}
element
.
set_hover_state
(
true
)
;
}
self
.
fire_mouse_event
(
client_point
&
new_target
.
upcast
(
)
FireMouseEventType
:
:
Over
)
;
}
prev_mouse_over_target
.
set
(
maybe_new_target
.
r
(
)
)
;
self
.
window
.
reflow
(
ReflowGoal
:
:
Full
ReflowReason
:
:
MouseEvent
)
;
}
#
[
allow
(
unsafe_code
)
]
pub
fn
handle_touch_event
(
&
self
js_runtime
:
*
mut
JSRuntime
event_type
:
TouchEventType
touch_id
:
TouchId
point
:
Point2D
<
f32
>
node_address
:
Option
<
UntrustedNodeAddress
>
)
-
>
TouchEventResult
{
let
TouchId
(
identifier
)
=
touch_id
;
let
event_name
=
match
event_type
{
TouchEventType
:
:
Down
=
>
"
touchstart
"
TouchEventType
:
:
Move
=
>
"
touchmove
"
TouchEventType
:
:
Up
=
>
"
touchend
"
TouchEventType
:
:
Cancel
=
>
"
touchcancel
"
}
;
let
el
=
node_address
.
and_then
(
|
address
|
{
let
node
=
unsafe
{
node
:
:
from_untrusted_node_address
(
js_runtime
address
)
}
;
node
.
inclusive_ancestors
(
)
.
filter_map
(
DomRoot
:
:
downcast
:
:
<
Element
>
)
.
next
(
)
}
)
;
let
el
=
match
el
{
Some
(
el
)
=
>
el
None
=
>
return
TouchEventResult
:
:
Forwarded
}
;
let
target
=
DomRoot
:
:
upcast
:
:
<
EventTarget
>
(
el
)
;
let
window
=
&
*
self
.
window
;
let
client_x
=
Finite
:
:
wrap
(
point
.
x
as
f64
)
;
let
client_y
=
Finite
:
:
wrap
(
point
.
y
as
f64
)
;
let
page_x
=
Finite
:
:
wrap
(
point
.
x
as
f64
+
window
.
PageXOffset
(
)
as
f64
)
;
let
page_y
=
Finite
:
:
wrap
(
point
.
y
as
f64
+
window
.
PageYOffset
(
)
as
f64
)
;
let
touch
=
Touch
:
:
new
(
window
identifier
&
target
client_x
client_y
client_x
client_y
page_x
page_y
)
;
match
event_type
{
TouchEventType
:
:
Down
=
>
{
self
.
active_touch_points
.
borrow_mut
(
)
.
push
(
Dom
:
:
from_ref
(
&
*
touch
)
)
;
}
TouchEventType
:
:
Move
=
>
{
let
mut
active_touch_points
=
self
.
active_touch_points
.
borrow_mut
(
)
;
match
active_touch_points
.
iter_mut
(
)
.
find
(
|
t
|
t
.
Identifier
(
)
=
=
identifier
)
{
Some
(
t
)
=
>
*
t
=
Dom
:
:
from_ref
(
&
*
touch
)
None
=
>
warn
!
(
"
Got
a
touchmove
event
for
a
non
-
active
touch
point
"
)
}
}
TouchEventType
:
:
Up
|
TouchEventType
:
:
Cancel
=
>
{
let
mut
active_touch_points
=
self
.
active_touch_points
.
borrow_mut
(
)
;
match
active_touch_points
.
iter
(
)
.
position
(
|
t
|
t
.
Identifier
(
)
=
=
identifier
)
{
Some
(
i
)
=
>
{
active_touch_points
.
swap_remove
(
i
)
;
}
None
=
>
warn
!
(
"
Got
a
touchend
event
for
a
non
-
active
touch
point
"
)
}
}
}
rooted_vec
!
(
let
mut
touches
)
;
touches
.
extend
(
self
.
active_touch_points
.
borrow
(
)
.
iter
(
)
.
cloned
(
)
)
;
rooted_vec
!
(
let
mut
target_touches
)
;
target_touches
.
extend
(
self
.
active_touch_points
.
borrow
(
)
.
iter
(
)
.
filter
(
|
t
|
t
.
Target
(
)
=
=
target
)
.
cloned
(
)
)
;
rooted_vec
!
(
let
changed_touches
<
-
once
(
touch
)
)
;
let
event
=
TouchEvent
:
:
new
(
window
DOMString
:
:
from
(
event_name
)
EventBubbles
:
:
Bubbles
EventCancelable
:
:
Cancelable
Some
(
window
)
0i32
&
TouchList
:
:
new
(
window
touches
.
r
(
)
)
&
TouchList
:
:
new
(
window
changed_touches
.
r
(
)
)
&
TouchList
:
:
new
(
window
target_touches
.
r
(
)
)
false
false
false
false
)
;
let
event
=
event
.
upcast
:
:
<
Event
>
(
)
;
let
result
=
event
.
fire
(
&
target
)
;
window
.
reflow
(
ReflowGoal
:
:
Full
ReflowReason
:
:
MouseEvent
)
;
match
result
{
EventStatus
:
:
Canceled
=
>
TouchEventResult
:
:
Processed
(
false
)
EventStatus
:
:
NotCanceled
=
>
TouchEventResult
:
:
Processed
(
true
)
}
}
pub
fn
dispatch_key_event
(
&
self
ch
:
Option
<
char
>
key
:
Key
state
:
KeyState
modifiers
:
KeyModifiers
)
{
let
focused
=
self
.
get_focused_element
(
)
;
let
body
=
self
.
GetBody
(
)
;
let
target
=
match
(
&
focused
&
body
)
{
(
&
Some
(
ref
focused
)
_
)
=
>
focused
.
upcast
(
)
(
&
None
&
Some
(
ref
body
)
)
=
>
body
.
upcast
(
)
(
&
None
&
None
)
=
>
self
.
window
.
upcast
(
)
}
;
let
ctrl
=
modifiers
.
contains
(
KeyModifiers
:
:
CONTROL
)
;
let
alt
=
modifiers
.
contains
(
KeyModifiers
:
:
ALT
)
;
let
shift
=
modifiers
.
contains
(
KeyModifiers
:
:
SHIFT
)
;
let
meta
=
modifiers
.
contains
(
KeyModifiers
:
:
SUPER
)
;
let
is_composing
=
false
;
let
is_repeating
=
state
=
=
KeyState
:
:
Repeated
;
let
ev_type
=
DOMString
:
:
from
(
match
state
{
KeyState
:
:
Pressed
|
KeyState
:
:
Repeated
=
>
"
keydown
"
KeyState
:
:
Released
=
>
"
keyup
"
}
.
to_owned
(
)
)
;
let
props
=
KeyboardEvent
:
:
key_properties
(
ch
key
modifiers
)
;
let
keyevent
=
KeyboardEvent
:
:
new
(
&
self
.
window
ev_type
true
true
Some
(
&
self
.
window
)
0
ch
Some
(
key
)
DOMString
:
:
from
(
props
.
key_string
.
clone
(
)
)
DOMString
:
:
from
(
props
.
code
)
props
.
location
is_repeating
is_composing
ctrl
alt
shift
meta
None
props
.
key_code
)
;
let
event
=
keyevent
.
upcast
:
:
<
Event
>
(
)
;
event
.
fire
(
target
)
;
let
mut
cancel_state
=
event
.
get_cancel_state
(
)
;
if
state
!
=
KeyState
:
:
Released
&
&
props
.
is_printable
(
)
&
&
cancel_state
!
=
EventDefault
:
:
Prevented
{
let
event
=
KeyboardEvent
:
:
new
(
&
self
.
window
DOMString
:
:
from
(
"
keypress
"
)
true
true
Some
(
&
self
.
window
)
0
ch
Some
(
key
)
DOMString
:
:
from
(
props
.
key_string
)
DOMString
:
:
from
(
props
.
code
)
props
.
location
is_repeating
is_composing
ctrl
alt
shift
meta
props
.
char_code
0
)
;
let
ev
=
event
.
upcast
:
:
<
Event
>
(
)
;
ev
.
fire
(
target
)
;
cancel_state
=
ev
.
get_cancel_state
(
)
;
}
if
cancel_state
=
=
EventDefault
:
:
Allowed
{
let
msg
=
ScriptMsg
:
:
SendKeyEvent
(
ch
key
state
modifiers
)
;
self
.
send_to_constellation
(
msg
)
;
match
key
{
Key
:
:
Space
if
state
=
=
KeyState
:
:
Released
=
>
{
let
maybe_elem
=
target
.
downcast
:
:
<
Element
>
(
)
;
if
let
Some
(
el
)
=
maybe_elem
{
synthetic_click_activation
(
el
false
false
false
false
ActivationSource
:
:
NotFromClick
)
}
}
Key
:
:
Enter
if
state
=
=
KeyState
:
:
Released
=
>
{
let
maybe_elem
=
target
.
downcast
:
:
<
Element
>
(
)
;
if
let
Some
(
el
)
=
maybe_elem
{
if
let
Some
(
a
)
=
el
.
as_maybe_activatable
(
)
{
a
.
implicit_submission
(
ctrl
alt
shift
meta
)
;
}
}
}
_
=
>
(
)
}
}
self
.
window
.
reflow
(
ReflowGoal
:
:
Full
ReflowReason
:
:
KeyEvent
)
;
}
pub
fn
node_from_nodes_and_strings
(
&
self
mut
nodes
:
Vec
<
NodeOrString
>
)
-
>
Fallible
<
DomRoot
<
Node
>
>
{
if
nodes
.
len
(
)
=
=
1
{
Ok
(
match
nodes
.
pop
(
)
.
unwrap
(
)
{
NodeOrString
:
:
Node
(
node
)
=
>
node
NodeOrString
:
:
String
(
string
)
=
>
DomRoot
:
:
upcast
(
self
.
CreateTextNode
(
string
)
)
}
)
}
else
{
let
fragment
=
DomRoot
:
:
upcast
:
:
<
Node
>
(
self
.
CreateDocumentFragment
(
)
)
;
for
node
in
nodes
{
match
node
{
NodeOrString
:
:
Node
(
node
)
=
>
{
fragment
.
AppendChild
(
&
node
)
?
;
}
NodeOrString
:
:
String
(
string
)
=
>
{
let
node
=
DomRoot
:
:
upcast
:
:
<
Node
>
(
self
.
CreateTextNode
(
string
)
)
;
fragment
.
AppendChild
(
&
node
)
.
unwrap
(
)
;
}
}
}
Ok
(
fragment
)
}
}
pub
fn
get_body_attribute
(
&
self
local_name
:
&
LocalName
)
-
>
DOMString
{
match
self
.
GetBody
(
)
.
and_then
(
DomRoot
:
:
downcast
:
:
<
HTMLBodyElement
>
)
{
Some
(
ref
body
)
=
>
{
body
.
upcast
:
:
<
Element
>
(
)
.
get_string_attribute
(
local_name
)
}
None
=
>
DOMString
:
:
new
(
)
}
}
pub
fn
set_body_attribute
(
&
self
local_name
:
&
LocalName
value
:
DOMString
)
{
if
let
Some
(
ref
body
)
=
self
.
GetBody
(
)
.
and_then
(
DomRoot
:
:
downcast
:
:
<
HTMLBodyElement
>
)
{
let
body
=
body
.
upcast
:
:
<
Element
>
(
)
;
let
value
=
body
.
parse_attribute
(
&
ns
!
(
)
&
local_name
value
)
;
body
.
set_attribute
(
local_name
value
)
;
}
}
pub
fn
set_current_script
(
&
self
script
:
Option
<
&
HTMLScriptElement
>
)
{
self
.
current_script
.
set
(
script
)
;
}
pub
fn
get_script_blocking_stylesheets_count
(
&
self
)
-
>
u32
{
self
.
script_blocking_stylesheets_count
.
get
(
)
}
pub
fn
increment_script_blocking_stylesheet_count
(
&
self
)
{
let
count_cell
=
&
self
.
script_blocking_stylesheets_count
;
count_cell
.
set
(
count_cell
.
get
(
)
+
1
)
;
}
pub
fn
decrement_script_blocking_stylesheet_count
(
&
self
)
{
let
count_cell
=
&
self
.
script_blocking_stylesheets_count
;
assert
!
(
count_cell
.
get
(
)
>
0
)
;
count_cell
.
set
(
count_cell
.
get
(
)
-
1
)
;
}
pub
fn
invalidate_stylesheets
(
&
self
)
{
self
.
stylesheets
.
borrow_mut
(
)
.
force_dirty
(
OriginSet
:
:
all
(
)
)
;
if
let
Some
(
element
)
=
self
.
GetDocumentElement
(
)
{
element
.
upcast
:
:
<
Node
>
(
)
.
dirty
(
NodeDamage
:
:
NodeStyleDamaged
)
;
}
}
pub
fn
trigger_mozbrowser_event
(
&
self
event
:
MozBrowserEvent
)
{
if
PREFS
.
is_mozbrowser_enabled
(
)
{
if
let
Some
(
(
parent_pipeline_id
_
)
)
=
self
.
window
.
parent_info
(
)
{
let
event
=
ScriptMsg
:
:
MozBrowserEvent
(
parent_pipeline_id
event
)
;
self
.
send_to_constellation
(
event
)
;
}
}
}
pub
fn
request_animation_frame
(
&
self
callback
:
AnimationFrameCallback
)
-
>
u32
{
let
ident
=
self
.
animation_frame_ident
.
get
(
)
+
1
;
self
.
animation_frame_ident
.
set
(
ident
)
;
self
.
animation_frame_list
.
borrow_mut
(
)
.
push
(
(
ident
Some
(
callback
)
)
)
;
if
self
.
is_faking_animation_frames
(
)
{
let
callback
=
FakeRequestAnimationFrameCallback
{
document
:
Trusted
:
:
new
(
self
)
}
;
self
.
global
(
)
.
schedule_callback
(
OneshotTimerCallback
:
:
FakeRequestAnimationFrame
(
callback
)
MsDuration
:
:
new
(
FAKE_REQUEST_ANIMATION_FRAME_DELAY
)
)
;
}
else
if
!
self
.
running_animation_callbacks
.
get
(
)
{
let
event
=
ScriptMsg
:
:
ChangeRunningAnimationsState
(
AnimationState
:
:
AnimationCallbacksPresent
)
;
self
.
send_to_constellation
(
event
)
;
}
ident
}
pub
fn
cancel_animation_frame
(
&
self
ident
:
u32
)
{
let
mut
list
=
self
.
animation_frame_list
.
borrow_mut
(
)
;
if
let
Some
(
pair
)
=
list
.
iter_mut
(
)
.
find
(
|
pair
|
pair
.
0
=
=
ident
)
{
pair
.
1
=
None
;
}
}
pub
fn
run_the_animation_frame_callbacks
(
&
self
)
{
rooted_vec
!
(
let
mut
animation_frame_list
)
;
mem
:
:
swap
(
&
mut
*
animation_frame_list
&
mut
*
self
.
animation_frame_list
.
borrow_mut
(
)
)
;
self
.
running_animation_callbacks
.
set
(
true
)
;
let
was_faking_animation_frames
=
self
.
is_faking_animation_frames
(
)
;
let
timing
=
self
.
global
(
)
.
performance
(
)
.
Now
(
)
;
for
(
_
callback
)
in
animation_frame_list
.
drain
(
.
.
)
{
if
let
Some
(
callback
)
=
callback
{
callback
.
call
(
self
*
timing
)
;
}
}
self
.
running_animation_callbacks
.
set
(
false
)
;
let
spurious
=
!
self
.
window
.
reflow
(
ReflowGoal
:
:
Full
ReflowReason
:
:
RequestAnimationFrame
)
;
if
spurious
&
&
!
was_faking_animation_frames
{
self
.
window
.
force_reflow
(
ReflowGoal
:
:
Full
ReflowReason
:
:
RequestAnimationFrame
)
;
}
if
self
.
animation_frame_list
.
borrow
(
)
.
is_empty
(
)
|
|
(
!
was_faking_animation_frames
&
&
self
.
is_faking_animation_frames
(
)
)
{
mem
:
:
swap
(
&
mut
*
self
.
animation_frame_list
.
borrow_mut
(
)
&
mut
*
animation_frame_list
)
;
let
event
=
ScriptMsg
:
:
ChangeRunningAnimationsState
(
AnimationState
:
:
NoAnimationCallbacksPresent
)
;
self
.
send_to_constellation
(
event
)
;
}
if
spurious
{
if
self
.
spurious_animation_frames
.
get
(
)
<
SPURIOUS_ANIMATION_FRAME_THRESHOLD
{
self
.
spurious_animation_frames
.
set
(
self
.
spurious_animation_frames
.
get
(
)
+
1
)
}
}
else
{
self
.
spurious_animation_frames
.
set
(
0
)
}
}
pub
fn
fetch_async
(
&
self
load
:
LoadType
request
:
RequestInit
fetch_target
:
IpcSender
<
FetchResponseMsg
>
)
{
let
mut
loader
=
self
.
loader
.
borrow_mut
(
)
;
loader
.
fetch_async
(
load
request
fetch_target
)
;
}
pub
fn
finish_load
(
&
self
load
:
LoadType
)
{
debug
!
(
"
Document
got
finish_load
:
{
:
?
}
"
load
)
;
self
.
loader
.
borrow_mut
(
)
.
finish_load
(
&
load
)
;
match
load
{
LoadType
:
:
Stylesheet
(
_
)
=
>
{
self
.
process_pending_parsing_blocking_script
(
)
;
self
.
process_deferred_scripts
(
)
;
}
LoadType
:
:
PageSource
(
_
)
=
>
{
if
self
.
has_browsing_context
{
self
.
reflow_timeout
.
set
(
None
)
;
self
.
upcast
:
:
<
Node
>
(
)
.
dirty
(
NodeDamage
:
:
OtherNodeDamage
)
;
self
.
window
.
reflow
(
ReflowGoal
:
:
Full
ReflowReason
:
:
FirstLoad
)
;
}
self
.
process_deferred_scripts
(
)
;
}
_
=
>
{
}
}
let
loader
=
self
.
loader
.
borrow
(
)
;
if
(
self
.
top_level_dom_complete
.
get
(
)
=
=
0
)
&
&
loader
.
is_only_blocked_by_iframes
(
)
{
update_with_current_time_ms
(
&
self
.
top_level_dom_complete
)
;
}
if
loader
.
is_blocked
(
)
|
|
loader
.
events_inhibited
(
)
{
return
;
}
ScriptThread
:
:
mark_document_with_no_blocked_loads
(
self
)
;
}
pub
fn
maybe_queue_document_completion
(
&
self
)
{
if
self
.
loader
.
borrow
(
)
.
is_blocked
(
)
{
return
;
}
assert
!
(
!
self
.
loader
.
borrow
(
)
.
events_inhibited
(
)
)
;
self
.
loader
.
borrow_mut
(
)
.
inhibit_events
(
)
;
debug
!
(
"
Document
loads
are
complete
.
"
)
;
let
document
=
Trusted
:
:
new
(
self
)
;
self
.
window
.
dom_manipulation_task_source
(
)
.
queue
(
task
!
(
fire_load_event
:
move
|
|
{
let
document
=
document
.
root
(
)
;
let
window
=
document
.
window
(
)
;
if
!
window
.
is_alive
(
)
{
return
;
}
/
/
Step
7
.
1
.
document
.
set_ready_state
(
DocumentReadyState
:
:
Complete
)
;
/
/
Step
7
.
2
.
if
document
.
browsing_context
(
)
.
is_none
(
)
{
return
;
}
let
event
=
Event
:
:
new
(
window
.
upcast
(
)
atom
!
(
"
load
"
)
EventBubbles
:
:
DoesNotBubble
EventCancelable
:
:
NotCancelable
)
;
event
.
set_trusted
(
true
)
;
/
/
http
:
/
/
w3c
.
github
.
io
/
navigation
-
timing
/
#
widl
-
PerformanceNavigationTiming
-
loadEventStart
update_with_current_time_ms
(
&
document
.
load_event_start
)
;
debug
!
(
"
About
to
dispatch
load
for
{
:
?
}
"
document
.
url
(
)
)
;
/
/
FIXME
(
nox
)
:
Why
are
errors
silenced
here
?
let
_
=
window
.
upcast
:
:
<
EventTarget
>
(
)
.
dispatch_event_with_target
(
document
.
upcast
(
)
&
event
)
;
/
/
http
:
/
/
w3c
.
github
.
io
/
navigation
-
timing
/
#
widl
-
PerformanceNavigationTiming
-
loadEventEnd
update_with_current_time_ms
(
&
document
.
load_event_end
)
;
window
.
reflow
(
ReflowGoal
:
:
Full
ReflowReason
:
:
DocumentLoaded
)
;
document
.
notify_constellation_load
(
)
;
if
let
Some
(
fragment
)
=
document
.
url
(
)
.
fragment
(
)
{
document
.
check_and_scroll_fragment
(
fragment
)
;
}
}
)
self
.
window
.
upcast
(
)
)
.
unwrap
(
)
;
}
pub
fn
set_pending_parsing_blocking_script
(
&
self
script
:
&
HTMLScriptElement
load
:
Option
<
ScriptResult
>
)
{
assert
!
(
!
self
.
has_pending_parsing_blocking_script
(
)
)
;
*
self
.
pending_parsing_blocking_script
.
borrow_mut
(
)
=
Some
(
PendingScript
:
:
new_with_load
(
script
load
)
)
;
}
pub
fn
has_pending_parsing_blocking_script
(
&
self
)
-
>
bool
{
self
.
pending_parsing_blocking_script
.
borrow
(
)
.
is_some
(
)
}
pub
fn
pending_parsing_blocking_script_loaded
(
&
self
element
:
&
HTMLScriptElement
result
:
ScriptResult
)
{
{
let
mut
blocking_script
=
self
.
pending_parsing_blocking_script
.
borrow_mut
(
)
;
let
entry
=
blocking_script
.
as_mut
(
)
.
unwrap
(
)
;
assert
!
(
&
*
entry
.
element
=
=
element
)
;
entry
.
loaded
(
result
)
;
}
self
.
process_pending_parsing_blocking_script
(
)
;
}
fn
process_pending_parsing_blocking_script
(
&
self
)
{
if
self
.
script_blocking_stylesheets_count
.
get
(
)
>
0
{
return
;
}
let
pair
=
self
.
pending_parsing_blocking_script
.
borrow_mut
(
)
.
as_mut
(
)
.
and_then
(
PendingScript
:
:
take_result
)
;
if
let
Some
(
(
element
result
)
)
=
pair
{
*
self
.
pending_parsing_blocking_script
.
borrow_mut
(
)
=
None
;
self
.
get_current_parser
(
)
.
unwrap
(
)
.
resume_with_pending_parsing_blocking_script
(
&
element
result
)
;
}
}
pub
fn
add_asap_script
(
&
self
script
:
&
HTMLScriptElement
)
{
self
.
asap_scripts_set
.
borrow_mut
(
)
.
push
(
Dom
:
:
from_ref
(
script
)
)
;
}
pub
fn
asap_script_loaded
(
&
self
element
:
&
HTMLScriptElement
result
:
ScriptResult
)
{
{
let
mut
scripts
=
self
.
asap_scripts_set
.
borrow_mut
(
)
;
let
idx
=
scripts
.
iter
(
)
.
position
(
|
entry
|
&
*
*
entry
=
=
element
)
.
unwrap
(
)
;
scripts
.
swap_remove
(
idx
)
;
}
element
.
execute
(
result
)
;
}
pub
fn
push_asap_in_order_script
(
&
self
script
:
&
HTMLScriptElement
)
{
self
.
asap_in_order_scripts_list
.
push
(
script
)
;
}
pub
fn
asap_in_order_script_loaded
(
&
self
element
:
&
HTMLScriptElement
result
:
ScriptResult
)
{
self
.
asap_in_order_scripts_list
.
loaded
(
element
result
)
;
while
let
Some
(
(
element
result
)
)
=
self
.
asap_in_order_scripts_list
.
take_next_ready_to_be_executed
(
)
{
element
.
execute
(
result
)
;
}
}
pub
fn
add_deferred_script
(
&
self
script
:
&
HTMLScriptElement
)
{
self
.
deferred_scripts
.
push
(
script
)
;
}
pub
fn
deferred_script_loaded
(
&
self
element
:
&
HTMLScriptElement
result
:
ScriptResult
)
{
self
.
deferred_scripts
.
loaded
(
element
result
)
;
self
.
process_deferred_scripts
(
)
;
}
fn
process_deferred_scripts
(
&
self
)
{
if
self
.
ready_state
.
get
(
)
!
=
DocumentReadyState
:
:
Interactive
{
return
;
}
loop
{
if
self
.
script_blocking_stylesheets_count
.
get
(
)
>
0
{
return
;
}
if
let
Some
(
(
element
result
)
)
=
self
.
deferred_scripts
.
take_next_ready_to_be_executed
(
)
{
element
.
execute
(
result
)
;
}
else
{
break
;
}
}
if
self
.
deferred_scripts
.
is_empty
(
)
{
self
.
maybe_dispatch_dom_content_loaded
(
)
;
}
}
pub
fn
maybe_dispatch_dom_content_loaded
(
&
self
)
{
if
self
.
domcontentloaded_dispatched
.
get
(
)
{
return
;
}
self
.
domcontentloaded_dispatched
.
set
(
true
)
;
assert_ne
!
(
self
.
ReadyState
(
)
DocumentReadyState
:
:
Complete
"
Complete
before
DOMContentLoaded
?
"
)
;
update_with_current_time_ms
(
&
self
.
dom_content_loaded_event_start
)
;
let
window
=
self
.
window
(
)
;
window
.
dom_manipulation_task_source
(
)
.
queue_event
(
self
.
upcast
(
)
atom
!
(
"
DOMContentLoaded
"
)
EventBubbles
:
:
Bubbles
EventCancelable
:
:
NotCancelable
window
)
;
window
.
reflow
(
ReflowGoal
:
:
Full
ReflowReason
:
:
DOMContentLoaded
)
;
update_with_current_time_ms
(
&
self
.
dom_content_loaded_event_end
)
;
self
.
interactive_time
.
borrow
(
)
.
maybe_set_tti
(
self
InteractiveFlag
:
:
DOMContentLoaded
)
;
}
fn
abort
(
&
self
)
{
self
.
loader
.
borrow_mut
(
)
.
inhibit_events
(
)
;
for
iframe
in
self
.
iter_iframes
(
)
{
if
let
Some
(
document
)
=
iframe
.
GetContentDocument
(
)
{
document
.
abort
(
)
;
}
}
self
.
script_blocking_stylesheets_count
.
set
(
0
)
;
*
self
.
pending_parsing_blocking_script
.
borrow_mut
(
)
=
None
;
*
self
.
asap_scripts_set
.
borrow_mut
(
)
=
vec
!
[
]
;
self
.
asap_in_order_scripts_list
.
clear
(
)
;
self
.
deferred_scripts
.
clear
(
)
;
self
.
window
.
cancel_all_tasks
(
)
;
if
let
Some
(
parser
)
=
self
.
get_current_parser
(
)
{
parser
.
abort
(
)
;
}
}
pub
fn
notify_constellation_load
(
&
self
)
{
self
.
send_to_constellation
(
ScriptMsg
:
:
LoadComplete
)
;
}
pub
fn
set_current_parser
(
&
self
script
:
Option
<
&
ServoParser
>
)
{
self
.
current_parser
.
set
(
script
)
;
}
pub
fn
get_current_parser
(
&
self
)
-
>
Option
<
DomRoot
<
ServoParser
>
>
{
self
.
current_parser
.
get
(
)
}
pub
fn
can_invoke_script
(
&
self
)
-
>
bool
{
match
self
.
get_current_parser
(
)
{
Some
(
parser
)
=
>
{
parser
.
parser_is_not_active
(
)
|
|
self
.
throw_on_dynamic_markup_insertion_counter
.
get
(
)
>
0
}
None
=
>
true
}
}
pub
fn
iter_iframes
(
&
self
)
-
>
impl
Iterator
<
Item
=
DomRoot
<
HTMLIFrameElement
>
>
{
self
.
upcast
:
:
<
Node
>
(
)
.
traverse_preorder
(
)
.
filter_map
(
DomRoot
:
:
downcast
:
:
<
HTMLIFrameElement
>
)
}
pub
fn
find_iframe
(
&
self
browsing_context_id
:
BrowsingContextId
)
-
>
Option
<
DomRoot
<
HTMLIFrameElement
>
>
{
self
.
iter_iframes
(
)
.
find
(
|
node
|
node
.
browsing_context_id
(
)
=
=
Some
(
browsing_context_id
)
)
}
pub
fn
find_mozbrowser_iframe
(
&
self
top_level_browsing_context_id
:
TopLevelBrowsingContextId
)
-
>
Option
<
DomRoot
<
HTMLIFrameElement
>
>
{
match
self
.
find_iframe
(
BrowsingContextId
:
:
from
(
top_level_browsing_context_id
)
)
{
None
=
>
None
Some
(
iframe
)
=
>
{
assert
!
(
iframe
.
Mozbrowser
(
)
)
;
Some
(
iframe
)
}
}
}
pub
fn
get_dom_loading
(
&
self
)
-
>
u64
{
self
.
dom_loading
.
get
(
)
}
pub
fn
get_dom_interactive
(
&
self
)
-
>
u64
{
self
.
dom_interactive
.
get
(
)
}
pub
fn
set_navigation_start
(
&
self
navigation_start
:
u64
)
{
self
.
interactive_time
.
borrow_mut
(
)
.
set_navigation_start
(
navigation_start
)
;
}
pub
fn
get_interactive_metrics
(
&
self
)
-
>
Ref
<
InteractiveMetrics
>
{
self
.
interactive_time
.
borrow
(
)
}
pub
fn
has_recorded_tti_metric
(
&
self
)
-
>
bool
{
self
.
get_interactive_metrics
(
)
.
get_tti
(
)
.
is_some
(
)
}
pub
fn
get_dom_content_loaded_event_start
(
&
self
)
-
>
u64
{
self
.
dom_content_loaded_event_start
.
get
(
)
}
pub
fn
get_dom_content_loaded_event_end
(
&
self
)
-
>
u64
{
self
.
dom_content_loaded_event_end
.
get
(
)
}
pub
fn
get_dom_complete
(
&
self
)
-
>
u64
{
self
.
dom_complete
.
get
(
)
}
pub
fn
get_top_level_dom_complete
(
&
self
)
-
>
u64
{
self
.
top_level_dom_complete
.
get
(
)
}
pub
fn
get_load_event_start
(
&
self
)
-
>
u64
{
self
.
load_event_start
.
get
(
)
}
pub
fn
get_load_event_end
(
&
self
)
-
>
u64
{
self
.
load_event_end
.
get
(
)
}
pub
fn
start_tti
(
&
self
)
{
if
self
.
get_interactive_metrics
(
)
.
needs_tti
(
)
{
self
.
tti_window
.
borrow_mut
(
)
.
start_window
(
)
;
}
}
pub
fn
record_tti_if_necessary
(
&
self
)
{
if
self
.
has_recorded_tti_metric
(
)
{
return
;
}
if
self
.
tti_window
.
borrow
(
)
.
needs_check
(
)
{
self
.
get_interactive_metrics
(
)
.
maybe_set_tti
(
self
InteractiveFlag
:
:
TimeToInteractive
(
self
.
tti_window
.
borrow
(
)
.
get_start
(
)
)
)
;
}
}
fn
fire_focus_event
(
&
self
focus_event_type
:
FocusEventType
node
:
&
Node
related_target
:
Option
<
&
EventTarget
>
)
{
let
(
event_name
does_bubble
)
=
match
focus_event_type
{
FocusEventType
:
:
Focus
=
>
(
DOMString
:
:
from
(
"
focus
"
)
EventBubbles
:
:
DoesNotBubble
)
FocusEventType
:
:
Blur
=
>
(
DOMString
:
:
from
(
"
blur
"
)
EventBubbles
:
:
DoesNotBubble
)
}
;
let
event
=
FocusEvent
:
:
new
(
&
self
.
window
event_name
does_bubble
EventCancelable
:
:
NotCancelable
Some
(
&
self
.
window
)
0i32
related_target
)
;
let
event
=
event
.
upcast
:
:
<
Event
>
(
)
;
event
.
set_trusted
(
true
)
;
let
target
=
node
.
upcast
(
)
;
event
.
fire
(
target
)
;
}
pub
fn
is_cookie_averse
(
&
self
)
-
>
bool
{
!
self
.
has_browsing_context
|
|
!
url_has_network_scheme
(
&
self
.
url
(
)
)
}
pub
fn
nodes_from_point
(
&
self
client_point
:
&
Point2D
<
f32
>
reflow_goal
:
NodesFromPointQueryType
)
-
>
Vec
<
UntrustedNodeAddress
>
{
if
!
self
.
window
.
reflow
(
ReflowGoal
:
:
NodesFromPointQuery
(
*
client_point
reflow_goal
)
ReflowReason
:
:
Query
)
{
return
vec
!
(
)
;
}
;
self
.
window
.
layout
(
)
.
nodes_from_point_response
(
)
}
pub
fn
lookup_custom_element_definition
(
&
self
namespace
:
&
Namespace
local_name
:
&
LocalName
is
:
Option
<
&
LocalName
>
)
-
>
Option
<
Rc
<
CustomElementDefinition
>
>
{
if
!
PREFS
.
get
(
"
dom
.
customelements
.
enabled
"
)
.
as_boolean
(
)
.
unwrap_or
(
false
)
{
return
None
;
}
if
*
namespace
!
=
ns
!
(
html
)
{
return
None
;
}
if
!
self
.
has_browsing_context
{
return
None
;
}
let
registry
=
self
.
window
.
CustomElements
(
)
;
registry
.
lookup_definition
(
local_name
is
)
}
fn
send_to_constellation
(
&
self
msg
:
ScriptMsg
)
{
let
global_scope
=
self
.
window
.
upcast
:
:
<
GlobalScope
>
(
)
;
global_scope
.
script_to_constellation_chan
(
)
.
send
(
msg
)
.
unwrap
(
)
;
}
pub
fn
increment_throw_on_dynamic_markup_insertion_counter
(
&
self
)
{
let
counter
=
self
.
throw_on_dynamic_markup_insertion_counter
.
get
(
)
;
self
.
throw_on_dynamic_markup_insertion_counter
.
set
(
counter
+
1
)
;
}
pub
fn
decrement_throw_on_dynamic_markup_insertion_counter
(
&
self
)
{
let
counter
=
self
.
throw_on_dynamic_markup_insertion_counter
.
get
(
)
;
self
.
throw_on_dynamic_markup_insertion_counter
.
set
(
counter
-
1
)
;
}
}
#
[
derive
(
MallocSizeOf
PartialEq
)
]
pub
enum
DocumentSource
{
FromParser
NotFromParser
}
#
[
allow
(
unsafe_code
)
]
pub
trait
LayoutDocumentHelpers
{
unsafe
fn
is_html_document_for_layout
(
&
self
)
-
>
bool
;
unsafe
fn
drain_pending_restyles
(
&
self
)
-
>
Vec
<
(
LayoutDom
<
Element
>
PendingRestyle
)
>
;
unsafe
fn
needs_paint_from_layout
(
&
self
)
;
unsafe
fn
will_paint
(
&
self
)
;
unsafe
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
;
unsafe
fn
style_shared_lock
(
&
self
)
-
>
&
StyleSharedRwLock
;
}
#
[
allow
(
unsafe_code
)
]
impl
LayoutDocumentHelpers
for
LayoutDom
<
Document
>
{
#
[
inline
]
unsafe
fn
is_html_document_for_layout
(
&
self
)
-
>
bool
{
(
*
self
.
unsafe_get
(
)
)
.
is_html_document
}
#
[
inline
]
#
[
allow
(
unrooted_must_root
)
]
unsafe
fn
drain_pending_restyles
(
&
self
)
-
>
Vec
<
(
LayoutDom
<
Element
>
PendingRestyle
)
>
{
let
mut
elements
=
(
*
self
.
unsafe_get
(
)
)
.
pending_restyles
.
borrow_mut_for_layout
(
)
;
let
result
=
elements
.
drain
(
)
.
map
(
|
(
k
v
)
|
(
k
.
to_layout
(
)
v
)
)
.
filter
(
|
&
(
ref
k
_
)
|
k
.
upcast
:
:
<
Node
>
(
)
.
get_flag
(
NodeFlags
:
:
IS_IN_DOC
)
)
.
collect
(
)
;
result
}
#
[
inline
]
unsafe
fn
needs_paint_from_layout
(
&
self
)
{
(
*
self
.
unsafe_get
(
)
)
.
needs_paint
.
set
(
true
)
}
#
[
inline
]
unsafe
fn
will_paint
(
&
self
)
{
(
*
self
.
unsafe_get
(
)
)
.
needs_paint
.
set
(
false
)
}
#
[
inline
]
unsafe
fn
quirks_mode
(
&
self
)
-
>
QuirksMode
{
(
*
self
.
unsafe_get
(
)
)
.
quirks_mode
(
)
}
#
[
inline
]
unsafe
fn
style_shared_lock
(
&
self
)
-
>
&
StyleSharedRwLock
{
(
*
self
.
unsafe_get
(
)
)
.
style_shared_lock
(
)
}
}
fn
get_registrable_domain_suffix_of_or_is_equal_to
(
host_suffix_string
:
&
str
original_host
:
Host
)
-
>
Option
<
Host
>
{
if
host_suffix_string
.
is_empty
(
)
{
return
None
;
}
let
host
=
match
Host
:
:
parse
(
host_suffix_string
)
{
Ok
(
host
)
=
>
host
Err
(
_
)
=
>
return
None
}
;
if
host
!
=
original_host
{
let
host
=
match
host
{
Host
:
:
Domain
(
ref
host
)
=
>
host
_
=
>
return
None
}
;
let
original_host
=
match
original_host
{
Host
:
:
Domain
(
ref
original_host
)
=
>
original_host
_
=
>
return
None
}
;
let
index
=
original_host
.
len
(
)
.
checked_sub
(
host
.
len
(
)
)
?
;
let
(
prefix
suffix
)
=
original_host
.
split_at
(
index
)
;
if
!
prefix
.
ends_with
(
"
.
"
)
{
return
None
;
}
if
suffix
!
=
host
{
return
None
;
}
if
is_pub_domain
(
host
)
{
return
None
;
}
}
Some
(
host
)
}
fn
url_has_network_scheme
(
url
:
&
ServoUrl
)
-
>
bool
{
match
url
.
scheme
(
)
{
"
ftp
"
|
"
http
"
|
"
https
"
=
>
true
_
=
>
false
}
}
#
[
derive
(
Clone
Copy
Eq
JSTraceable
MallocSizeOf
PartialEq
)
]
pub
enum
HasBrowsingContext
{
No
Yes
}
impl
Document
{
pub
fn
new_inherited
(
window
:
&
Window
has_browsing_context
:
HasBrowsingContext
url
:
Option
<
ServoUrl
>
origin
:
MutableOrigin
is_html_document
:
IsHTMLDocument
content_type
:
Option
<
DOMString
>
last_modified
:
Option
<
String
>
activity
:
DocumentActivity
source
:
DocumentSource
doc_loader
:
DocumentLoader
referrer
:
Option
<
String
>
referrer_policy
:
Option
<
ReferrerPolicy
>
canceller
:
FetchCanceller
)
-
>
Document
{
let
url
=
url
.
unwrap_or_else
(
|
|
ServoUrl
:
:
parse
(
"
about
:
blank
"
)
.
unwrap
(
)
)
;
let
(
ready_state
domcontentloaded_dispatched
)
=
if
source
=
=
DocumentSource
:
:
FromParser
{
(
DocumentReadyState
:
:
Loading
false
)
}
else
{
(
DocumentReadyState
:
:
Complete
true
)
}
;
let
interactive_time
=
InteractiveMetrics
:
:
new
(
window
.
time_profiler_chan
(
)
.
clone
(
)
url
.
clone
(
)
)
;
Document
{
node
:
Node
:
:
new_document_node
(
)
window
:
Dom
:
:
from_ref
(
window
)
has_browsing_context
:
has_browsing_context
=
=
HasBrowsingContext
:
:
Yes
implementation
:
Default
:
:
default
(
)
content_type
:
match
content_type
{
Some
(
string
)
=
>
string
None
=
>
DOMString
:
:
from
(
match
is_html_document
{
IsHTMLDocument
:
:
HTMLDocument
=
>
"
text
/
html
"
IsHTMLDocument
:
:
NonHTMLDocument
=
>
"
application
/
xml
"
}
)
}
last_modified
:
last_modified
url
:
DomRefCell
:
:
new
(
url
)
quirks_mode
:
Cell
:
:
new
(
QuirksMode
:
:
NoQuirks
)
encoding
:
Cell
:
:
new
(
UTF_8
)
is_html_document
:
is_html_document
=
=
IsHTMLDocument
:
:
HTMLDocument
activity
:
Cell
:
:
new
(
activity
)
id_map
:
DomRefCell
:
:
new
(
HashMap
:
:
new
(
)
)
tag_map
:
DomRefCell
:
:
new
(
HashMap
:
:
new
(
)
)
tagns_map
:
DomRefCell
:
:
new
(
HashMap
:
:
new
(
)
)
classes_map
:
DomRefCell
:
:
new
(
HashMap
:
:
new
(
)
)
images
:
Default
:
:
default
(
)
embeds
:
Default
:
:
default
(
)
links
:
Default
:
:
default
(
)
forms
:
Default
:
:
default
(
)
scripts
:
Default
:
:
default
(
)
anchors
:
Default
:
:
default
(
)
applets
:
Default
:
:
default
(
)
style_shared_lock
:
{
lazy_static
!
{
/
/
/
Per
-
process
shared
lock
for
author
-
origin
stylesheets
/
/
/
/
/
/
FIXME
:
make
it
per
-
document
or
per
-
pipeline
instead
:
/
/
/
<
https
:
/
/
github
.
com
/
servo
/
servo
/
issues
/
16027
>
/
/
/
(
Need
to
figure
out
what
to
do
with
the
style
attribute
/
/
/
of
elements
adopted
into
another
document
.
)
static
ref
PER_PROCESS_AUTHOR_SHARED_LOCK
:
StyleSharedRwLock
=
{
StyleSharedRwLock
:
:
new
(
)
}
;
}
PER_PROCESS_AUTHOR_SHARED_LOCK
.
clone
(
)
}
stylesheets
:
DomRefCell
:
:
new
(
StylesheetSet
:
:
new
(
)
)
stylesheet_list
:
MutNullableDom
:
:
new
(
None
)
ready_state
:
Cell
:
:
new
(
ready_state
)
domcontentloaded_dispatched
:
Cell
:
:
new
(
domcontentloaded_dispatched
)
possibly_focused
:
Default
:
:
default
(
)
focused
:
Default
:
:
default
(
)
current_script
:
Default
:
:
default
(
)
pending_parsing_blocking_script
:
Default
:
:
default
(
)
script_blocking_stylesheets_count
:
Cell
:
:
new
(
0u32
)
deferred_scripts
:
Default
:
:
default
(
)
asap_in_order_scripts_list
:
Default
:
:
default
(
)
asap_scripts_set
:
Default
:
:
default
(
)
scripting_enabled
:
has_browsing_context
=
=
HasBrowsingContext
:
:
Yes
animation_frame_ident
:
Cell
:
:
new
(
0
)
animation_frame_list
:
DomRefCell
:
:
new
(
vec
!
[
]
)
running_animation_callbacks
:
Cell
:
:
new
(
false
)
loader
:
DomRefCell
:
:
new
(
doc_loader
)
current_parser
:
Default
:
:
default
(
)
reflow_timeout
:
Cell
:
:
new
(
None
)
base_element
:
Default
:
:
default
(
)
appropriate_template_contents_owner_document
:
Default
:
:
default
(
)
pending_restyles
:
DomRefCell
:
:
new
(
HashMap
:
:
new
(
)
)
needs_paint
:
Cell
:
:
new
(
false
)
active_touch_points
:
DomRefCell
:
:
new
(
Vec
:
:
new
(
)
)
dom_loading
:
Cell
:
:
new
(
Default
:
:
default
(
)
)
dom_interactive
:
Cell
:
:
new
(
Default
:
:
default
(
)
)
dom_content_loaded_event_start
:
Cell
:
:
new
(
Default
:
:
default
(
)
)
dom_content_loaded_event_end
:
Cell
:
:
new
(
Default
:
:
default
(
)
)
dom_complete
:
Cell
:
:
new
(
Default
:
:
default
(
)
)
top_level_dom_complete
:
Cell
:
:
new
(
Default
:
:
default
(
)
)
load_event_start
:
Cell
:
:
new
(
Default
:
:
default
(
)
)
load_event_end
:
Cell
:
:
new
(
Default
:
:
default
(
)
)
https_state
:
Cell
:
:
new
(
HttpsState
:
:
None
)
touchpad_pressure_phase
:
Cell
:
:
new
(
TouchpadPressurePhase
:
:
BeforeClick
)
origin
:
origin
referrer
:
referrer
referrer_policy
:
Cell
:
:
new
(
referrer_policy
)
target_element
:
MutNullableDom
:
:
new
(
None
)
last_click_info
:
DomRefCell
:
:
new
(
None
)
ignore_destructive_writes_counter
:
Default
:
:
default
(
)
spurious_animation_frames
:
Cell
:
:
new
(
0
)
dom_count
:
Cell
:
:
new
(
1
)
fullscreen_element
:
MutNullableDom
:
:
new
(
None
)
form_id_listener_map
:
Default
:
:
default
(
)
interactive_time
:
DomRefCell
:
:
new
(
interactive_time
)
tti_window
:
DomRefCell
:
:
new
(
InteractiveWindow
:
:
new
(
)
)
canceller
:
canceller
throw_on_dynamic_markup_insertion_counter
:
Cell
:
:
new
(
0
)
}
}
pub
fn
Constructor
(
window
:
&
Window
)
-
>
Fallible
<
DomRoot
<
Document
>
>
{
let
doc
=
window
.
Document
(
)
;
let
docloader
=
DocumentLoader
:
:
new
(
&
*
doc
.
loader
(
)
)
;
Ok
(
Document
:
:
new
(
window
HasBrowsingContext
:
:
No
None
doc
.
origin
(
)
.
clone
(
)
IsHTMLDocument
:
:
NonHTMLDocument
None
None
DocumentActivity
:
:
Inactive
DocumentSource
:
:
NotFromParser
docloader
None
None
Default
:
:
default
(
)
)
)
}
pub
fn
new
(
window
:
&
Window
has_browsing_context
:
HasBrowsingContext
url
:
Option
<
ServoUrl
>
origin
:
MutableOrigin
doctype
:
IsHTMLDocument
content_type
:
Option
<
DOMString
>
last_modified
:
Option
<
String
>
activity
:
DocumentActivity
source
:
DocumentSource
doc_loader
:
DocumentLoader
referrer
:
Option
<
String
>
referrer_policy
:
Option
<
ReferrerPolicy
>
canceller
:
FetchCanceller
)
-
>
DomRoot
<
Document
>
{
let
document
=
reflect_dom_object
(
Box
:
:
new
(
Document
:
:
new_inherited
(
window
has_browsing_context
url
origin
doctype
content_type
last_modified
activity
source
doc_loader
referrer
referrer_policy
canceller
)
)
window
DocumentBinding
:
:
Wrap
)
;
{
let
node
=
document
.
upcast
:
:
<
Node
>
(
)
;
node
.
set_owner_doc
(
&
document
)
;
}
document
}
fn
create_node_list
<
F
:
Fn
(
&
Node
)
-
>
bool
>
(
&
self
callback
:
F
)
-
>
DomRoot
<
NodeList
>
{
let
doc
=
self
.
GetDocumentElement
(
)
;
let
maybe_node
=
doc
.
r
(
)
.
map
(
Castable
:
:
upcast
:
:
<
Node
>
)
;
let
iter
=
maybe_node
.
iter
(
)
.
flat_map
(
|
node
|
node
.
traverse_preorder
(
)
)
.
filter
(
|
node
|
callback
(
&
node
)
)
;
NodeList
:
:
new_simple_list
(
&
self
.
window
iter
)
}
fn
get_html_element
(
&
self
)
-
>
Option
<
DomRoot
<
HTMLHtmlElement
>
>
{
self
.
GetDocumentElement
(
)
.
and_then
(
DomRoot
:
:
downcast
)
}
pub
fn
style_shared_lock
(
&
self
)
-
>
&
StyleSharedRwLock
{
&
self
.
style_shared_lock
}
pub
fn
flush_stylesheets_for_reflow
(
&
self
)
-
>
bool
{
let
mut
stylesheets
=
self
.
stylesheets
.
borrow_mut
(
)
;
let
have_changed
=
stylesheets
.
has_changed
(
)
;
stylesheets
.
flush_without_invalidation
(
)
;
have_changed
}
pub
fn
device
(
&
self
)
-
>
Option
<
Device
>
{
let
window_size
=
self
.
window
(
)
.
window_size
(
)
?
;
let
viewport_size
=
window_size
.
initial_viewport
;
let
device_pixel_ratio
=
window_size
.
device_pixel_ratio
;
Some
(
Device
:
:
new
(
MediaType
:
:
screen
(
)
viewport_size
device_pixel_ratio
)
)
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
remove_stylesheet
(
&
self
owner
:
&
Element
s
:
&
Arc
<
Stylesheet
>
)
{
self
.
window
(
)
.
layout_chan
(
)
.
send
(
Msg
:
:
RemoveStylesheet
(
s
.
clone
(
)
)
)
.
unwrap
(
)
;
let
guard
=
s
.
shared_lock
.
read
(
)
;
self
.
stylesheets
.
borrow_mut
(
)
.
remove_stylesheet
(
None
StyleSheetInDocument
{
sheet
:
s
.
clone
(
)
owner
:
Dom
:
:
from_ref
(
owner
)
}
&
guard
)
;
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
add_stylesheet
(
&
self
owner
:
&
Element
sheet
:
Arc
<
Stylesheet
>
)
{
debug_assert
!
(
owner
.
as_stylesheet_owner
(
)
.
is_some
(
)
|
|
owner
.
is
:
:
<
HTMLMetaElement
>
(
)
"
Wat
"
)
;
let
mut
stylesheets
=
self
.
stylesheets
.
borrow_mut
(
)
;
let
insertion_point
=
stylesheets
.
iter
(
)
.
map
(
|
(
sheet
_origin
)
|
sheet
)
.
find
(
|
sheet_in_doc
|
{
owner
.
upcast
:
:
<
Node
>
(
)
.
is_before
(
sheet_in_doc
.
owner
.
upcast
(
)
)
}
)
.
cloned
(
)
;
self
.
window
(
)
.
layout_chan
(
)
.
send
(
Msg
:
:
AddStylesheet
(
sheet
.
clone
(
)
insertion_point
.
as_ref
(
)
.
map
(
|
s
|
s
.
sheet
.
clone
(
)
)
)
)
.
unwrap
(
)
;
let
sheet
=
StyleSheetInDocument
{
sheet
owner
:
Dom
:
:
from_ref
(
owner
)
}
;
let
lock
=
self
.
style_shared_lock
(
)
;
let
guard
=
lock
.
read
(
)
;
match
insertion_point
{
Some
(
ip
)
=
>
{
stylesheets
.
insert_stylesheet_before
(
None
sheet
ip
&
guard
)
;
}
None
=
>
{
stylesheets
.
append_stylesheet
(
None
sheet
&
guard
)
;
}
}
}
pub
fn
stylesheet_count
(
&
self
)
-
>
usize
{
self
.
stylesheets
.
borrow
(
)
.
len
(
)
}
pub
fn
stylesheet_at
(
&
self
index
:
usize
)
-
>
Option
<
DomRoot
<
CSSStyleSheet
>
>
{
let
stylesheets
=
self
.
stylesheets
.
borrow
(
)
;
stylesheets
.
get
(
Origin
:
:
Author
index
)
.
and_then
(
|
s
|
{
s
.
owner
.
upcast
:
:
<
Node
>
(
)
.
get_cssom_stylesheet
(
)
}
)
}
pub
fn
appropriate_template_contents_owner_document
(
&
self
)
-
>
DomRoot
<
Document
>
{
self
.
appropriate_template_contents_owner_document
.
or_init
(
|
|
{
let
doctype
=
if
self
.
is_html_document
{
IsHTMLDocument
:
:
HTMLDocument
}
else
{
IsHTMLDocument
:
:
NonHTMLDocument
}
;
let
new_doc
=
Document
:
:
new
(
self
.
window
(
)
HasBrowsingContext
:
:
No
None
MutableOrigin
:
:
new
(
ImmutableOrigin
:
:
new_opaque
(
)
)
doctype
None
None
DocumentActivity
:
:
Inactive
DocumentSource
:
:
NotFromParser
DocumentLoader
:
:
new
(
&
self
.
loader
(
)
)
None
None
Default
:
:
default
(
)
)
;
new_doc
.
appropriate_template_contents_owner_document
.
set
(
Some
(
&
new_doc
)
)
;
new_doc
}
)
}
pub
fn
get_element_by_id
(
&
self
id
:
&
Atom
)
-
>
Option
<
DomRoot
<
Element
>
>
{
self
.
id_map
.
borrow
(
)
.
get
(
&
id
)
.
map
(
|
ref
elements
|
DomRoot
:
:
from_ref
(
&
*
(
*
elements
)
[
0
]
)
)
}
pub
fn
ensure_pending_restyle
(
&
self
el
:
&
Element
)
-
>
RefMut
<
PendingRestyle
>
{
let
map
=
self
.
pending_restyles
.
borrow_mut
(
)
;
RefMut
:
:
map
(
map
|
m
|
m
.
entry
(
Dom
:
:
from_ref
(
el
)
)
.
or_insert_with
(
PendingRestyle
:
:
new
)
)
}
pub
fn
element_state_will_change
(
&
self
el
:
&
Element
)
{
let
mut
entry
=
self
.
ensure_pending_restyle
(
el
)
;
if
entry
.
snapshot
.
is_none
(
)
{
entry
.
snapshot
=
Some
(
Snapshot
:
:
new
(
el
.
html_element_in_html_document
(
)
)
)
;
}
let
snapshot
=
entry
.
snapshot
.
as_mut
(
)
.
unwrap
(
)
;
if
snapshot
.
state
.
is_none
(
)
{
snapshot
.
state
=
Some
(
el
.
state
(
)
)
;
}
}
pub
fn
element_attr_will_change
(
&
self
el
:
&
Element
attr
:
&
Attr
)
{
let
mut
entry
=
self
.
ensure_pending_restyle
(
el
)
;
if
entry
.
snapshot
.
is_none
(
)
{
entry
.
snapshot
=
Some
(
Snapshot
:
:
new
(
el
.
html_element_in_html_document
(
)
)
)
;
}
if
attr
.
local_name
(
)
=
=
&
local_name
!
(
"
style
"
)
{
entry
.
hint
.
insert
(
RestyleHint
:
:
RESTYLE_STYLE_ATTRIBUTE
)
;
}
if
vtable_for
(
el
.
upcast
(
)
)
.
attribute_affects_presentational_hints
(
attr
)
{
entry
.
hint
.
insert
(
RestyleHint
:
:
RESTYLE_SELF
)
;
}
let
snapshot
=
entry
.
snapshot
.
as_mut
(
)
.
unwrap
(
)
;
if
attr
.
local_name
(
)
=
=
&
local_name
!
(
"
id
"
)
{
snapshot
.
id_changed
=
true
;
}
else
if
attr
.
local_name
(
)
=
=
&
local_name
!
(
"
class
"
)
{
snapshot
.
class_changed
=
true
;
}
else
{
snapshot
.
other_attributes_changed
=
true
;
}
if
snapshot
.
attrs
.
is_none
(
)
{
let
attrs
=
el
.
attrs
(
)
.
iter
(
)
.
map
(
|
attr
|
(
attr
.
identifier
(
)
.
clone
(
)
attr
.
value
(
)
.
clone
(
)
)
)
.
collect
(
)
;
snapshot
.
attrs
=
Some
(
attrs
)
;
}
}
pub
fn
set_referrer_policy
(
&
self
policy
:
Option
<
ReferrerPolicy
>
)
{
self
.
referrer_policy
.
set
(
policy
)
;
}
pub
fn
get_referrer_policy
(
&
self
)
-
>
Option
<
ReferrerPolicy
>
{
return
self
.
referrer_policy
.
get
(
)
;
}
pub
fn
set_target_element
(
&
self
node
:
Option
<
&
Element
>
)
{
if
let
Some
(
ref
element
)
=
self
.
target_element
.
get
(
)
{
element
.
set_target_state
(
false
)
;
}
self
.
target_element
.
set
(
node
)
;
if
let
Some
(
ref
element
)
=
self
.
target_element
.
get
(
)
{
element
.
set_target_state
(
true
)
;
}
self
.
window
.
reflow
(
ReflowGoal
:
:
Full
ReflowReason
:
:
ElementStateChanged
)
;
}
pub
fn
incr_ignore_destructive_writes_counter
(
&
self
)
{
self
.
ignore_destructive_writes_counter
.
set
(
self
.
ignore_destructive_writes_counter
.
get
(
)
+
1
)
;
}
pub
fn
decr_ignore_destructive_writes_counter
(
&
self
)
{
self
.
ignore_destructive_writes_counter
.
set
(
self
.
ignore_destructive_writes_counter
.
get
(
)
-
1
)
;
}
fn
is_faking_animation_frames
(
&
self
)
-
>
bool
{
self
.
spurious_animation_frames
.
get
(
)
>
=
SPURIOUS_ANIMATION_FRAME_THRESHOLD
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
enter_fullscreen
(
&
self
pending
:
&
Element
)
-
>
Rc
<
Promise
>
{
let
promise
=
Promise
:
:
new
(
self
.
global
(
)
.
r
(
)
)
;
let
mut
error
=
false
;
match
*
pending
.
namespace
(
)
{
ns
!
(
mathml
)
=
>
{
if
pending
.
local_name
(
)
.
as_ref
(
)
!
=
"
math
"
{
error
=
true
;
}
}
ns
!
(
svg
)
=
>
{
if
pending
.
local_name
(
)
.
as_ref
(
)
!
=
"
svg
"
{
error
=
true
;
}
}
ns
!
(
html
)
=
>
(
)
_
=
>
error
=
true
}
if
!
pending
.
fullscreen_element_ready_check
(
)
{
error
=
true
;
}
let
window
=
self
.
window
(
)
;
if
!
error
{
let
event
=
ScriptMsg
:
:
SetFullscreenState
(
true
)
;
self
.
send_to_constellation
(
event
)
;
}
let
pipeline_id
=
self
.
window
(
)
.
pipeline_id
(
)
;
let
trusted_pending
=
Trusted
:
:
new
(
pending
)
;
let
trusted_promise
=
TrustedPromise
:
:
new
(
promise
.
clone
(
)
)
;
let
handler
=
ElementPerformFullscreenEnter
:
:
new
(
trusted_pending
trusted_promise
error
)
;
let
script_msg
=
CommonScriptMsg
:
:
Task
(
ScriptThreadEventCategory
:
:
EnterFullscreen
handler
pipeline_id
)
;
let
msg
=
MainThreadScriptMsg
:
:
Common
(
script_msg
)
;
window
.
main_thread_script_chan
(
)
.
send
(
msg
)
.
unwrap
(
)
;
promise
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
exit_fullscreen
(
&
self
)
-
>
Rc
<
Promise
>
{
let
global
=
self
.
global
(
)
;
let
promise
=
Promise
:
:
new
(
global
.
r
(
)
)
;
if
self
.
fullscreen_element
.
get
(
)
.
is_none
(
)
{
promise
.
reject_error
(
Error
:
:
Type
(
String
:
:
from
(
"
fullscreen
is
null
"
)
)
)
;
return
promise
}
let
element
=
self
.
fullscreen_element
.
get
(
)
.
unwrap
(
)
;
let
window
=
self
.
window
(
)
;
let
event
=
ScriptMsg
:
:
SetFullscreenState
(
false
)
;
self
.
send_to_constellation
(
event
)
;
let
trusted_element
=
Trusted
:
:
new
(
element
.
r
(
)
)
;
let
trusted_promise
=
TrustedPromise
:
:
new
(
promise
.
clone
(
)
)
;
let
handler
=
ElementPerformFullscreenExit
:
:
new
(
trusted_element
trusted_promise
)
;
let
pipeline_id
=
Some
(
global
.
pipeline_id
(
)
)
;
let
script_msg
=
CommonScriptMsg
:
:
Task
(
ScriptThreadEventCategory
:
:
ExitFullscreen
handler
pipeline_id
)
;
let
msg
=
MainThreadScriptMsg
:
:
Common
(
script_msg
)
;
window
.
main_thread_script_chan
(
)
.
send
(
msg
)
.
unwrap
(
)
;
promise
}
pub
fn
set_fullscreen_element
(
&
self
element
:
Option
<
&
Element
>
)
{
self
.
fullscreen_element
.
set
(
element
)
;
}
pub
fn
get_allow_fullscreen
(
&
self
)
-
>
bool
{
match
self
.
browsing_context
(
)
{
None
=
>
false
Some
(
_
)
=
>
{
let
window
=
self
.
window
(
)
;
if
window
.
is_top_level
(
)
{
true
}
else
{
window
.
GetFrameElement
(
)
.
map_or
(
false
|
el
|
el
.
has_attribute
(
&
local_name
!
(
"
allowfullscreen
"
)
)
)
}
}
}
}
fn
reset_form_owner_for_listeners
(
&
self
id
:
&
Atom
)
{
let
map
=
self
.
form_id_listener_map
.
borrow
(
)
;
if
let
Some
(
listeners
)
=
map
.
get
(
id
)
{
for
listener
in
listeners
{
listener
.
r
(
)
.
as_maybe_form_control
(
)
.
expect
(
"
Element
must
be
a
form
control
"
)
.
reset_form_owner
(
)
;
}
}
}
}
impl
Element
{
fn
click_event_filter_by_disabled_state
(
&
self
)
-
>
bool
{
let
node
=
self
.
upcast
:
:
<
Node
>
(
)
;
match
node
.
type_id
(
)
{
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLButtonElement
)
)
|
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLInputElement
)
)
|
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLOptionElement
)
)
|
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLSelectElement
)
)
|
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLTextAreaElement
)
)
if
self
.
disabled_state
(
)
=
>
true
_
=
>
false
}
}
}
impl
ProfilerMetadataFactory
for
Document
{
fn
new_metadata
(
&
self
)
-
>
Option
<
TimerMetadata
>
{
Some
(
TimerMetadata
{
url
:
String
:
:
from
(
self
.
url
(
)
.
as_str
(
)
)
iframe
:
TimerMetadataFrameType
:
:
RootWindow
incremental
:
TimerMetadataReflowType
:
:
Incremental
}
)
}
}
impl
DocumentMethods
for
Document
{
fn
StyleSheets
(
&
self
)
-
>
DomRoot
<
StyleSheetList
>
{
self
.
stylesheet_list
.
or_init
(
|
|
StyleSheetList
:
:
new
(
&
self
.
window
Dom
:
:
from_ref
(
&
self
)
)
)
}
fn
Implementation
(
&
self
)
-
>
DomRoot
<
DOMImplementation
>
{
self
.
implementation
.
or_init
(
|
|
DOMImplementation
:
:
new
(
self
)
)
}
fn
URL
(
&
self
)
-
>
USVString
{
USVString
(
String
:
:
from
(
self
.
url
(
)
.
as_str
(
)
)
)
}
fn
GetActiveElement
(
&
self
)
-
>
Option
<
DomRoot
<
Element
>
>
{
match
self
.
get_focused_element
(
)
{
Some
(
element
)
=
>
Some
(
element
)
None
=
>
match
self
.
GetBody
(
)
{
Some
(
body
)
=
>
Some
(
DomRoot
:
:
upcast
(
body
)
)
None
=
>
self
.
GetDocumentElement
(
)
}
}
}
fn
HasFocus
(
&
self
)
-
>
bool
{
if
self
.
window
(
)
.
parent_info
(
)
.
is_none
(
)
&
&
self
.
is_fully_active
(
)
{
return
true
;
}
false
}
fn
Domain
(
&
self
)
-
>
DOMString
{
if
!
self
.
has_browsing_context
{
return
DOMString
:
:
new
(
)
;
}
match
self
.
origin
.
effective_domain
(
)
{
None
=
>
DOMString
:
:
new
(
)
Some
(
Host
:
:
Domain
(
domain
)
)
=
>
DOMString
:
:
from
(
domain
)
Some
(
host
)
=
>
DOMString
:
:
from
(
host
.
to_string
(
)
)
}
}
fn
SetDomain
(
&
self
value
:
DOMString
)
-
>
ErrorResult
{
if
!
self
.
has_browsing_context
{
return
Err
(
Error
:
:
Security
)
;
}
let
effective_domain
=
match
self
.
origin
.
effective_domain
(
)
{
Some
(
effective_domain
)
=
>
effective_domain
None
=
>
return
Err
(
Error
:
:
Security
)
}
;
let
host
=
match
get_registrable_domain_suffix_of_or_is_equal_to
(
&
*
value
effective_domain
)
{
None
=
>
return
Err
(
Error
:
:
Security
)
Some
(
host
)
=
>
host
}
;
self
.
origin
.
set_domain
(
host
)
;
Ok
(
(
)
)
}
fn
Referrer
(
&
self
)
-
>
DOMString
{
match
self
.
referrer
{
Some
(
ref
referrer
)
=
>
DOMString
:
:
from
(
referrer
.
to_string
(
)
)
None
=
>
DOMString
:
:
new
(
)
}
}
fn
DocumentURI
(
&
self
)
-
>
USVString
{
self
.
URL
(
)
}
fn
CompatMode
(
&
self
)
-
>
DOMString
{
DOMString
:
:
from
(
match
self
.
quirks_mode
.
get
(
)
{
QuirksMode
:
:
LimitedQuirks
|
QuirksMode
:
:
NoQuirks
=
>
"
CSS1Compat
"
QuirksMode
:
:
Quirks
=
>
"
BackCompat
"
}
)
}
fn
CharacterSet
(
&
self
)
-
>
DOMString
{
DOMString
:
:
from
(
self
.
encoding
.
get
(
)
.
name
(
)
)
}
fn
Charset
(
&
self
)
-
>
DOMString
{
self
.
CharacterSet
(
)
}
fn
InputEncoding
(
&
self
)
-
>
DOMString
{
self
.
CharacterSet
(
)
}
fn
ContentType
(
&
self
)
-
>
DOMString
{
self
.
content_type
.
clone
(
)
}
fn
GetDoctype
(
&
self
)
-
>
Option
<
DomRoot
<
DocumentType
>
>
{
self
.
upcast
:
:
<
Node
>
(
)
.
children
(
)
.
filter_map
(
DomRoot
:
:
downcast
)
.
next
(
)
}
fn
GetDocumentElement
(
&
self
)
-
>
Option
<
DomRoot
<
Element
>
>
{
self
.
upcast
:
:
<
Node
>
(
)
.
child_elements
(
)
.
next
(
)
}
fn
GetElementsByTagName
(
&
self
qualified_name
:
DOMString
)
-
>
DomRoot
<
HTMLCollection
>
{
let
qualified_name
=
LocalName
:
:
from
(
&
*
qualified_name
)
;
match
self
.
tag_map
.
borrow_mut
(
)
.
entry
(
qualified_name
.
clone
(
)
)
{
Occupied
(
entry
)
=
>
DomRoot
:
:
from_ref
(
entry
.
get
(
)
)
Vacant
(
entry
)
=
>
{
let
result
=
HTMLCollection
:
:
by_qualified_name
(
&
self
.
window
self
.
upcast
(
)
qualified_name
)
;
entry
.
insert
(
Dom
:
:
from_ref
(
&
*
result
)
)
;
result
}
}
}
fn
GetElementsByTagNameNS
(
&
self
maybe_ns
:
Option
<
DOMString
>
tag_name
:
DOMString
)
-
>
DomRoot
<
HTMLCollection
>
{
let
ns
=
namespace_from_domstring
(
maybe_ns
)
;
let
local
=
LocalName
:
:
from
(
tag_name
)
;
let
qname
=
QualName
:
:
new
(
None
ns
local
)
;
match
self
.
tagns_map
.
borrow_mut
(
)
.
entry
(
qname
.
clone
(
)
)
{
Occupied
(
entry
)
=
>
DomRoot
:
:
from_ref
(
entry
.
get
(
)
)
Vacant
(
entry
)
=
>
{
let
result
=
HTMLCollection
:
:
by_qual_tag_name
(
&
self
.
window
self
.
upcast
(
)
qname
)
;
entry
.
insert
(
Dom
:
:
from_ref
(
&
*
result
)
)
;
result
}
}
}
fn
GetElementsByClassName
(
&
self
classes
:
DOMString
)
-
>
DomRoot
<
HTMLCollection
>
{
let
class_atoms
:
Vec
<
Atom
>
=
split_html_space_chars
(
&
classes
)
.
map
(
Atom
:
:
from
)
.
collect
(
)
;
match
self
.
classes_map
.
borrow_mut
(
)
.
entry
(
class_atoms
.
clone
(
)
)
{
Occupied
(
entry
)
=
>
DomRoot
:
:
from_ref
(
entry
.
get
(
)
)
Vacant
(
entry
)
=
>
{
let
result
=
HTMLCollection
:
:
by_atomic_class_name
(
&
self
.
window
self
.
upcast
(
)
class_atoms
)
;
entry
.
insert
(
Dom
:
:
from_ref
(
&
*
result
)
)
;
result
}
}
}
fn
GetElementById
(
&
self
id
:
DOMString
)
-
>
Option
<
DomRoot
<
Element
>
>
{
self
.
get_element_by_id
(
&
Atom
:
:
from
(
id
)
)
}
fn
CreateElement
(
&
self
mut
local_name
:
DOMString
options
:
&
ElementCreationOptions
)
-
>
Fallible
<
DomRoot
<
Element
>
>
{
if
xml_name_type
(
&
local_name
)
=
=
InvalidXMLName
{
debug
!
(
"
Not
a
valid
element
name
"
)
;
return
Err
(
Error
:
:
InvalidCharacter
)
;
}
if
self
.
is_html_document
{
local_name
.
make_ascii_lowercase
(
)
;
}
let
ns
=
if
self
.
is_html_document
|
|
self
.
content_type
=
=
"
application
/
xhtml
+
xml
"
{
ns
!
(
html
)
}
else
{
ns
!
(
)
}
;
let
name
=
QualName
:
:
new
(
None
ns
LocalName
:
:
from
(
local_name
)
)
;
let
is
=
options
.
is
.
as_ref
(
)
.
map
(
|
is
|
LocalName
:
:
from
(
&
*
*
is
)
)
;
Ok
(
Element
:
:
create
(
name
is
self
ElementCreator
:
:
ScriptCreated
CustomElementCreationMode
:
:
Synchronous
)
)
}
fn
CreateElementNS
(
&
self
namespace
:
Option
<
DOMString
>
qualified_name
:
DOMString
options
:
&
ElementCreationOptions
)
-
>
Fallible
<
DomRoot
<
Element
>
>
{
let
(
namespace
prefix
local_name
)
=
validate_and_extract
(
namespace
&
qualified_name
)
?
;
let
name
=
QualName
:
:
new
(
prefix
namespace
local_name
)
;
let
is
=
options
.
is
.
as_ref
(
)
.
map
(
|
is
|
LocalName
:
:
from
(
&
*
*
is
)
)
;
Ok
(
Element
:
:
create
(
name
is
self
ElementCreator
:
:
ScriptCreated
CustomElementCreationMode
:
:
Synchronous
)
)
}
fn
CreateAttribute
(
&
self
mut
local_name
:
DOMString
)
-
>
Fallible
<
DomRoot
<
Attr
>
>
{
if
xml_name_type
(
&
local_name
)
=
=
InvalidXMLName
{
debug
!
(
"
Not
a
valid
element
name
"
)
;
return
Err
(
Error
:
:
InvalidCharacter
)
;
}
if
self
.
is_html_document
{
local_name
.
make_ascii_lowercase
(
)
;
}
let
name
=
LocalName
:
:
from
(
local_name
)
;
let
value
=
AttrValue
:
:
String
(
"
"
.
to_owned
(
)
)
;
Ok
(
Attr
:
:
new
(
&
self
.
window
name
.
clone
(
)
value
name
ns
!
(
)
None
None
)
)
}
fn
CreateAttributeNS
(
&
self
namespace
:
Option
<
DOMString
>
qualified_name
:
DOMString
)
-
>
Fallible
<
DomRoot
<
Attr
>
>
{
let
(
namespace
prefix
local_name
)
=
validate_and_extract
(
namespace
&
qualified_name
)
?
;
let
value
=
AttrValue
:
:
String
(
"
"
.
to_owned
(
)
)
;
let
qualified_name
=
LocalName
:
:
from
(
qualified_name
)
;
Ok
(
Attr
:
:
new
(
&
self
.
window
local_name
value
qualified_name
namespace
prefix
None
)
)
}
fn
CreateDocumentFragment
(
&
self
)
-
>
DomRoot
<
DocumentFragment
>
{
DocumentFragment
:
:
new
(
self
)
}
fn
CreateTextNode
(
&
self
data
:
DOMString
)
-
>
DomRoot
<
Text
>
{
Text
:
:
new
(
data
self
)
}
fn
CreateComment
(
&
self
data
:
DOMString
)
-
>
DomRoot
<
Comment
>
{
Comment
:
:
new
(
data
self
)
}
fn
CreateProcessingInstruction
(
&
self
target
:
DOMString
data
:
DOMString
)
-
>
Fallible
<
DomRoot
<
ProcessingInstruction
>
>
{
if
xml_name_type
(
&
target
)
=
=
InvalidXMLName
{
return
Err
(
Error
:
:
InvalidCharacter
)
;
}
if
data
.
contains
(
"
?
>
"
)
{
return
Err
(
Error
:
:
InvalidCharacter
)
;
}
Ok
(
ProcessingInstruction
:
:
new
(
target
data
self
)
)
}
fn
ImportNode
(
&
self
node
:
&
Node
deep
:
bool
)
-
>
Fallible
<
DomRoot
<
Node
>
>
{
if
node
.
is
:
:
<
Document
>
(
)
{
return
Err
(
Error
:
:
NotSupported
)
;
}
let
clone_children
=
if
deep
{
CloneChildrenFlag
:
:
CloneChildren
}
else
{
CloneChildrenFlag
:
:
DoNotCloneChildren
}
;
Ok
(
Node
:
:
clone
(
node
Some
(
self
)
clone_children
)
)
}
fn
AdoptNode
(
&
self
node
:
&
Node
)
-
>
Fallible
<
DomRoot
<
Node
>
>
{
if
node
.
is
:
:
<
Document
>
(
)
{
return
Err
(
Error
:
:
NotSupported
)
;
}
Node
:
:
adopt
(
node
self
)
;
Ok
(
DomRoot
:
:
from_ref
(
node
)
)
}
fn
CreateEvent
(
&
self
mut
interface
:
DOMString
)
-
>
Fallible
<
DomRoot
<
Event
>
>
{
interface
.
make_ascii_lowercase
(
)
;
match
&
*
interface
{
"
beforeunloadevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
BeforeUnloadEvent
:
:
new_uninitialized
(
&
self
.
window
)
)
)
"
closeevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
CloseEvent
:
:
new_uninitialized
(
self
.
window
.
upcast
(
)
)
)
)
"
customevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
CustomEvent
:
:
new_uninitialized
(
self
.
window
.
upcast
(
)
)
)
)
"
errorevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
ErrorEvent
:
:
new_uninitialized
(
self
.
window
.
upcast
(
)
)
)
)
"
events
"
|
"
event
"
|
"
htmlevents
"
|
"
svgevents
"
=
>
Ok
(
Event
:
:
new_uninitialized
(
&
self
.
window
.
upcast
(
)
)
)
"
focusevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
FocusEvent
:
:
new_uninitialized
(
&
self
.
window
)
)
)
"
hashchangeevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
HashChangeEvent
:
:
new_uninitialized
(
&
self
.
window
)
)
)
"
keyboardevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
KeyboardEvent
:
:
new_uninitialized
(
&
self
.
window
)
)
)
"
messageevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
MessageEvent
:
:
new_uninitialized
(
self
.
window
.
upcast
(
)
)
)
)
"
mouseevent
"
|
"
mouseevents
"
=
>
Ok
(
DomRoot
:
:
upcast
(
MouseEvent
:
:
new_uninitialized
(
&
self
.
window
)
)
)
"
pagetransitionevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
PageTransitionEvent
:
:
new_uninitialized
(
&
self
.
window
)
)
)
"
popstateevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
PopStateEvent
:
:
new_uninitialized
(
&
self
.
window
)
)
)
"
progressevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
ProgressEvent
:
:
new_uninitialized
(
self
.
window
.
upcast
(
)
)
)
)
"
storageevent
"
=
>
{
Ok
(
DomRoot
:
:
upcast
(
StorageEvent
:
:
new_uninitialized
(
&
self
.
window
"
"
.
into
(
)
)
)
)
}
"
touchevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
TouchEvent
:
:
new_uninitialized
(
&
self
.
window
&
TouchList
:
:
new
(
&
self
.
window
&
[
]
)
&
TouchList
:
:
new
(
&
self
.
window
&
[
]
)
&
TouchList
:
:
new
(
&
self
.
window
&
[
]
)
)
)
)
"
uievent
"
|
"
uievents
"
=
>
Ok
(
DomRoot
:
:
upcast
(
UIEvent
:
:
new_uninitialized
(
&
self
.
window
)
)
)
"
webglcontextevent
"
=
>
Ok
(
DomRoot
:
:
upcast
(
WebGLContextEvent
:
:
new_uninitialized
(
&
self
.
window
)
)
)
_
=
>
Err
(
Error
:
:
NotSupported
)
}
}
fn
LastModified
(
&
self
)
-
>
DOMString
{
match
self
.
last_modified
{
Some
(
ref
t
)
=
>
DOMString
:
:
from
(
t
.
clone
(
)
)
None
=
>
DOMString
:
:
from
(
time
:
:
now
(
)
.
strftime
(
"
%
m
/
%
d
/
%
Y
%
H
:
%
M
:
%
S
"
)
.
unwrap
(
)
.
to_string
(
)
)
}
}
fn
CreateRange
(
&
self
)
-
>
DomRoot
<
Range
>
{
Range
:
:
new_with_doc
(
self
)
}
fn
CreateNodeIterator
(
&
self
root
:
&
Node
what_to_show
:
u32
filter
:
Option
<
Rc
<
NodeFilter
>
>
)
-
>
DomRoot
<
NodeIterator
>
{
NodeIterator
:
:
new
(
self
root
what_to_show
filter
)
}
fn
CreateTouch
(
&
self
window
:
&
Window
target
:
&
EventTarget
identifier
:
i32
page_x
:
Finite
<
f64
>
page_y
:
Finite
<
f64
>
screen_x
:
Finite
<
f64
>
screen_y
:
Finite
<
f64
>
)
-
>
DomRoot
<
Touch
>
{
let
client_x
=
Finite
:
:
wrap
(
*
page_x
-
window
.
PageXOffset
(
)
as
f64
)
;
let
client_y
=
Finite
:
:
wrap
(
*
page_y
-
window
.
PageYOffset
(
)
as
f64
)
;
Touch
:
:
new
(
window
identifier
target
screen_x
screen_y
client_x
client_y
page_x
page_y
)
}
fn
CreateTouchList
(
&
self
touches
:
&
[
&
Touch
]
)
-
>
DomRoot
<
TouchList
>
{
TouchList
:
:
new
(
&
self
.
window
&
touches
)
}
fn
CreateTreeWalker
(
&
self
root
:
&
Node
what_to_show
:
u32
filter
:
Option
<
Rc
<
NodeFilter
>
>
)
-
>
DomRoot
<
TreeWalker
>
{
TreeWalker
:
:
new
(
self
root
what_to_show
filter
)
}
fn
Title
(
&
self
)
-
>
DOMString
{
let
title
=
self
.
GetDocumentElement
(
)
.
and_then
(
|
root
|
{
if
root
.
namespace
(
)
=
=
&
ns
!
(
svg
)
&
&
root
.
local_name
(
)
=
=
&
local_name
!
(
"
svg
"
)
{
root
.
upcast
:
:
<
Node
>
(
)
.
child_elements
(
)
.
find
(
|
node
|
{
node
.
namespace
(
)
=
=
&
ns
!
(
svg
)
&
&
node
.
local_name
(
)
=
=
&
local_name
!
(
"
title
"
)
}
)
.
map
(
DomRoot
:
:
upcast
:
:
<
Node
>
)
}
else
{
root
.
upcast
:
:
<
Node
>
(
)
.
traverse_preorder
(
)
.
find
(
|
node
|
node
.
is
:
:
<
HTMLTitleElement
>
(
)
)
}
}
)
;
match
title
{
None
=
>
DOMString
:
:
new
(
)
Some
(
ref
title
)
=
>
{
let
value
=
title
.
child_text_content
(
)
;
DOMString
:
:
from
(
str_join
(
split_html_space_chars
(
&
value
)
"
"
)
)
}
}
}
fn
SetTitle
(
&
self
title
:
DOMString
)
{
let
root
=
match
self
.
GetDocumentElement
(
)
{
Some
(
root
)
=
>
root
None
=
>
return
}
;
let
elem
=
if
root
.
namespace
(
)
=
=
&
ns
!
(
svg
)
&
&
root
.
local_name
(
)
=
=
&
local_name
!
(
"
svg
"
)
{
let
elem
=
root
.
upcast
:
:
<
Node
>
(
)
.
child_elements
(
)
.
find
(
|
node
|
{
node
.
namespace
(
)
=
=
&
ns
!
(
svg
)
&
&
node
.
local_name
(
)
=
=
&
local_name
!
(
"
title
"
)
}
)
;
match
elem
{
Some
(
elem
)
=
>
DomRoot
:
:
upcast
:
:
<
Node
>
(
elem
)
None
=
>
{
let
name
=
QualName
:
:
new
(
None
ns
!
(
svg
)
local_name
!
(
"
title
"
)
)
;
let
elem
=
Element
:
:
create
(
name
None
self
ElementCreator
:
:
ScriptCreated
CustomElementCreationMode
:
:
Synchronous
)
;
let
parent
=
root
.
upcast
:
:
<
Node
>
(
)
;
let
child
=
elem
.
upcast
:
:
<
Node
>
(
)
;
parent
.
InsertBefore
(
child
parent
.
GetFirstChild
(
)
.
r
(
)
)
.
unwrap
(
)
}
}
}
else
if
root
.
namespace
(
)
=
=
&
ns
!
(
html
)
{
let
elem
=
root
.
upcast
:
:
<
Node
>
(
)
.
traverse_preorder
(
)
.
find
(
|
node
|
node
.
is
:
:
<
HTMLTitleElement
>
(
)
)
;
match
elem
{
Some
(
elem
)
=
>
elem
None
=
>
{
match
self
.
GetHead
(
)
{
Some
(
head
)
=
>
{
let
name
=
QualName
:
:
new
(
None
ns
!
(
html
)
local_name
!
(
"
title
"
)
)
;
let
elem
=
Element
:
:
create
(
name
None
self
ElementCreator
:
:
ScriptCreated
CustomElementCreationMode
:
:
Synchronous
)
;
head
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
elem
.
upcast
(
)
)
.
unwrap
(
)
}
None
=
>
return
}
}
}
}
else
{
return
;
}
;
elem
.
SetTextContent
(
Some
(
title
)
)
;
}
fn
GetHead
(
&
self
)
-
>
Option
<
DomRoot
<
HTMLHeadElement
>
>
{
self
.
get_html_element
(
)
.
and_then
(
|
root
|
root
.
upcast
:
:
<
Node
>
(
)
.
children
(
)
.
filter_map
(
DomRoot
:
:
downcast
)
.
next
(
)
)
}
fn
GetCurrentScript
(
&
self
)
-
>
Option
<
DomRoot
<
HTMLScriptElement
>
>
{
self
.
current_script
.
get
(
)
}
fn
GetBody
(
&
self
)
-
>
Option
<
DomRoot
<
HTMLElement
>
>
{
self
.
get_html_element
(
)
.
and_then
(
|
root
|
{
let
node
=
root
.
upcast
:
:
<
Node
>
(
)
;
node
.
children
(
)
.
find
(
|
child
|
{
match
child
.
type_id
(
)
{
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLBodyElement
)
)
|
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLFrameSetElement
)
)
=
>
true
_
=
>
false
}
}
)
.
map
(
|
node
|
DomRoot
:
:
downcast
(
node
)
.
unwrap
(
)
)
}
)
}
fn
SetBody
(
&
self
new_body
:
Option
<
&
HTMLElement
>
)
-
>
ErrorResult
{
let
new_body
=
match
new_body
{
Some
(
new_body
)
=
>
new_body
None
=
>
return
Err
(
Error
:
:
HierarchyRequest
)
}
;
let
node
=
new_body
.
upcast
:
:
<
Node
>
(
)
;
match
node
.
type_id
(
)
{
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLBodyElement
)
)
|
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
HTMLElementTypeId
:
:
HTMLFrameSetElement
)
)
=
>
{
}
_
=
>
return
Err
(
Error
:
:
HierarchyRequest
)
}
let
old_body
=
self
.
GetBody
(
)
;
if
old_body
.
r
(
)
=
=
Some
(
new_body
)
{
return
Ok
(
(
)
)
;
}
match
(
self
.
get_html_element
(
)
&
old_body
)
{
(
Some
(
ref
root
)
&
Some
(
ref
child
)
)
=
>
{
let
root
=
root
.
upcast
:
:
<
Node
>
(
)
;
root
.
ReplaceChild
(
new_body
.
upcast
(
)
child
.
upcast
(
)
)
.
unwrap
(
)
;
}
(
None
_
)
=
>
return
Err
(
Error
:
:
HierarchyRequest
)
(
Some
(
ref
root
)
&
None
)
=
>
{
let
root
=
root
.
upcast
:
:
<
Node
>
(
)
;
root
.
AppendChild
(
new_body
.
upcast
(
)
)
.
unwrap
(
)
;
}
}
Ok
(
(
)
)
}
fn
GetElementsByName
(
&
self
name
:
DOMString
)
-
>
DomRoot
<
NodeList
>
{
self
.
create_node_list
(
|
node
|
{
let
element
=
match
node
.
downcast
:
:
<
Element
>
(
)
{
Some
(
element
)
=
>
element
None
=
>
return
false
}
;
if
element
.
namespace
(
)
!
=
&
ns
!
(
html
)
{
return
false
;
}
element
.
get_attribute
(
&
ns
!
(
)
&
local_name
!
(
"
name
"
)
)
.
map_or
(
false
|
attr
|
&
*
*
attr
.
value
(
)
=
=
&
*
name
)
}
)
}
fn
Images
(
&
self
)
-
>
DomRoot
<
HTMLCollection
>
{
self
.
images
.
or_init
(
|
|
{
let
filter
=
Box
:
:
new
(
ImagesFilter
)
;
HTMLCollection
:
:
create
(
&
self
.
window
self
.
upcast
(
)
filter
)
}
)
}
fn
Embeds
(
&
self
)
-
>
DomRoot
<
HTMLCollection
>
{
self
.
embeds
.
or_init
(
|
|
{
let
filter
=
Box
:
:
new
(
EmbedsFilter
)
;
HTMLCollection
:
:
create
(
&
self
.
window
self
.
upcast
(
)
filter
)
}
)
}
fn
Plugins
(
&
self
)
-
>
DomRoot
<
HTMLCollection
>
{
self
.
Embeds
(
)
}
fn
Links
(
&
self
)
-
>
DomRoot
<
HTMLCollection
>
{
self
.
links
.
or_init
(
|
|
{
let
filter
=
Box
:
:
new
(
LinksFilter
)
;
HTMLCollection
:
:
create
(
&
self
.
window
self
.
upcast
(
)
filter
)
}
)
}
fn
Forms
(
&
self
)
-
>
DomRoot
<
HTMLCollection
>
{
self
.
forms
.
or_init
(
|
|
{
let
filter
=
Box
:
:
new
(
FormsFilter
)
;
HTMLCollection
:
:
create
(
&
self
.
window
self
.
upcast
(
)
filter
)
}
)
}
fn
Scripts
(
&
self
)
-
>
DomRoot
<
HTMLCollection
>
{
self
.
scripts
.
or_init
(
|
|
{
let
filter
=
Box
:
:
new
(
ScriptsFilter
)
;
HTMLCollection
:
:
create
(
&
self
.
window
self
.
upcast
(
)
filter
)
}
)
}
fn
Anchors
(
&
self
)
-
>
DomRoot
<
HTMLCollection
>
{
self
.
anchors
.
or_init
(
|
|
{
let
filter
=
Box
:
:
new
(
AnchorsFilter
)
;
HTMLCollection
:
:
create
(
&
self
.
window
self
.
upcast
(
)
filter
)
}
)
}
fn
Applets
(
&
self
)
-
>
DomRoot
<
HTMLCollection
>
{
self
.
applets
.
or_init
(
|
|
{
HTMLCollection
:
:
always_empty
(
&
self
.
window
self
.
upcast
(
)
)
}
)
}
fn
GetLocation
(
&
self
)
-
>
Option
<
DomRoot
<
Location
>
>
{
if
self
.
is_fully_active
(
)
{
Some
(
self
.
window
.
Location
(
)
)
}
else
{
None
}
}
fn
Children
(
&
self
)
-
>
DomRoot
<
HTMLCollection
>
{
HTMLCollection
:
:
children
(
&
self
.
window
self
.
upcast
(
)
)
}
fn
GetFirstElementChild
(
&
self
)
-
>
Option
<
DomRoot
<
Element
>
>
{
self
.
upcast
:
:
<
Node
>
(
)
.
child_elements
(
)
.
next
(
)
}
fn
GetLastElementChild
(
&
self
)
-
>
Option
<
DomRoot
<
Element
>
>
{
self
.
upcast
:
:
<
Node
>
(
)
.
rev_children
(
)
.
filter_map
(
DomRoot
:
:
downcast
)
.
next
(
)
}
fn
ChildElementCount
(
&
self
)
-
>
u32
{
self
.
upcast
:
:
<
Node
>
(
)
.
child_elements
(
)
.
count
(
)
as
u32
}
fn
Prepend
(
&
self
nodes
:
Vec
<
NodeOrString
>
)
-
>
ErrorResult
{
self
.
upcast
:
:
<
Node
>
(
)
.
prepend
(
nodes
)
}
fn
Append
(
&
self
nodes
:
Vec
<
NodeOrString
>
)
-
>
ErrorResult
{
self
.
upcast
:
:
<
Node
>
(
)
.
append
(
nodes
)
}
fn
QuerySelector
(
&
self
selectors
:
DOMString
)
-
>
Fallible
<
Option
<
DomRoot
<
Element
>
>
>
{
let
root
=
self
.
upcast
:
:
<
Node
>
(
)
;
root
.
query_selector
(
selectors
)
}
fn
QuerySelectorAll
(
&
self
selectors
:
DOMString
)
-
>
Fallible
<
DomRoot
<
NodeList
>
>
{
let
root
=
self
.
upcast
:
:
<
Node
>
(
)
;
root
.
query_selector_all
(
selectors
)
}
fn
ReadyState
(
&
self
)
-
>
DocumentReadyState
{
self
.
ready_state
.
get
(
)
}
fn
GetDefaultView
(
&
self
)
-
>
Option
<
DomRoot
<
Window
>
>
{
if
self
.
has_browsing_context
{
Some
(
DomRoot
:
:
from_ref
(
&
*
self
.
window
)
)
}
else
{
None
}
}
fn
GetCookie
(
&
self
)
-
>
Fallible
<
DOMString
>
{
if
self
.
is_cookie_averse
(
)
{
return
Ok
(
DOMString
:
:
new
(
)
)
;
}
if
!
self
.
origin
.
is_tuple
(
)
{
return
Err
(
Error
:
:
Security
)
;
}
let
url
=
self
.
url
(
)
;
let
(
tx
rx
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
let
_
=
self
.
window
.
upcast
:
:
<
GlobalScope
>
(
)
.
resource_threads
(
)
.
send
(
GetCookiesForUrl
(
url
tx
NonHTTP
)
)
;
let
cookies
=
rx
.
recv
(
)
.
unwrap
(
)
;
Ok
(
cookies
.
map_or
(
DOMString
:
:
new
(
)
DOMString
:
:
from
)
)
}
fn
SetCookie
(
&
self
cookie
:
DOMString
)
-
>
ErrorResult
{
if
self
.
is_cookie_averse
(
)
{
return
Ok
(
(
)
)
;
}
if
!
self
.
origin
.
is_tuple
(
)
{
return
Err
(
Error
:
:
Security
)
;
}
if
let
Ok
(
cookie_header
)
=
SetCookie
:
:
parse_header
(
&
vec
!
[
cookie
.
to_string
(
)
.
into_bytes
(
)
]
)
{
let
cookies
=
cookie_header
.
0
.
into_iter
(
)
.
filter_map
(
|
cookie
|
{
cookie_rs
:
:
Cookie
:
:
parse
(
cookie
)
.
ok
(
)
.
map
(
Serde
)
}
)
.
collect
(
)
;
let
_
=
self
.
window
.
upcast
:
:
<
GlobalScope
>
(
)
.
resource_threads
(
)
.
send
(
SetCookiesForUrl
(
self
.
url
(
)
cookies
NonHTTP
)
)
;
}
Ok
(
(
)
)
}
fn
BgColor
(
&
self
)
-
>
DOMString
{
self
.
get_body_attribute
(
&
local_name
!
(
"
bgcolor
"
)
)
}
fn
SetBgColor
(
&
self
value
:
DOMString
)
{
self
.
set_body_attribute
(
&
local_name
!
(
"
bgcolor
"
)
value
)
}
fn
FgColor
(
&
self
)
-
>
DOMString
{
self
.
get_body_attribute
(
&
local_name
!
(
"
text
"
)
)
}
fn
SetFgColor
(
&
self
value
:
DOMString
)
{
self
.
set_body_attribute
(
&
local_name
!
(
"
text
"
)
value
)
}
#
[
allow
(
unsafe_code
)
]
unsafe
fn
NamedGetter
(
&
self
_cx
:
*
mut
JSContext
name
:
DOMString
)
-
>
Option
<
NonNull
<
JSObject
>
>
{
#
[
derive
(
JSTraceable
MallocSizeOf
)
]
struct
NamedElementFilter
{
name
:
Atom
}
impl
CollectionFilter
for
NamedElementFilter
{
fn
filter
(
&
self
elem
:
&
Element
_root
:
&
Node
)
-
>
bool
{
filter_by_name
(
&
self
.
name
elem
.
upcast
(
)
)
}
}
fn
filter_by_name
(
name
:
&
Atom
node
:
&
Node
)
-
>
bool
{
let
html_elem_type
=
match
node
.
type_id
(
)
{
NodeTypeId
:
:
Element
(
ElementTypeId
:
:
HTMLElement
(
type_
)
)
=
>
type_
_
=
>
return
false
}
;
let
elem
=
match
node
.
downcast
:
:
<
Element
>
(
)
{
Some
(
elem
)
=
>
elem
None
=
>
return
false
}
;
match
html_elem_type
{
HTMLElementTypeId
:
:
HTMLFormElement
=
>
{
match
elem
.
get_attribute
(
&
ns
!
(
)
&
local_name
!
(
"
name
"
)
)
{
Some
(
ref
attr
)
=
>
attr
.
value
(
)
.
as_atom
(
)
=
=
name
None
=
>
false
}
}
HTMLElementTypeId
:
:
HTMLImageElement
=
>
{
match
elem
.
get_attribute
(
&
ns
!
(
)
&
local_name
!
(
"
name
"
)
)
{
Some
(
ref
attr
)
=
>
{
if
attr
.
value
(
)
.
as_atom
(
)
=
=
name
{
true
}
else
{
match
elem
.
get_attribute
(
&
ns
!
(
)
&
local_name
!
(
"
id
"
)
)
{
Some
(
ref
attr
)
=
>
attr
.
value
(
)
.
as_atom
(
)
=
=
name
None
=
>
false
}
}
}
None
=
>
false
}
}
_
=
>
false
}
}
let
name
=
Atom
:
:
from
(
name
)
;
let
root
=
self
.
upcast
:
:
<
Node
>
(
)
;
{
let
mut
elements
=
root
.
traverse_preorder
(
)
.
filter
(
|
node
|
filter_by_name
(
&
name
&
node
)
)
.
peekable
(
)
;
if
let
Some
(
first
)
=
elements
.
next
(
)
{
if
elements
.
peek
(
)
.
is_none
(
)
{
return
Some
(
NonNull
:
:
new_unchecked
(
first
.
reflector
(
)
.
get_jsobject
(
)
.
get
(
)
)
)
;
}
}
else
{
return
None
;
}
}
let
filter
=
NamedElementFilter
{
name
:
name
}
;
let
collection
=
HTMLCollection
:
:
create
(
self
.
window
(
)
root
Box
:
:
new
(
filter
)
)
;
Some
(
NonNull
:
:
new_unchecked
(
collection
.
reflector
(
)
.
get_jsobject
(
)
.
get
(
)
)
)
}
fn
SupportedPropertyNames
(
&
self
)
-
>
Vec
<
DOMString
>
{
vec
!
[
]
}
fn
Clear
(
&
self
)
{
}
fn
CaptureEvents
(
&
self
)
{
}
fn
ReleaseEvents
(
&
self
)
{
}
global_event_handlers
!
(
)
;
event_handler
!
(
readystatechange
GetOnreadystatechange
SetOnreadystatechange
)
;
#
[
allow
(
unsafe_code
)
]
fn
ElementFromPoint
(
&
self
x
:
Finite
<
f64
>
y
:
Finite
<
f64
>
)
-
>
Option
<
DomRoot
<
Element
>
>
{
let
x
=
*
x
as
f32
;
let
y
=
*
y
as
f32
;
let
point
=
&
Point2D
:
:
new
(
x
y
)
;
let
window
=
window_from_node
(
self
)
;
let
viewport
=
window
.
window_size
(
)
.
unwrap
(
)
.
initial_viewport
;
if
self
.
browsing_context
(
)
.
is_none
(
)
{
return
None
;
}
if
x
<
0
.
0
|
|
y
<
0
.
0
|
|
x
>
viewport
.
width
|
|
y
>
viewport
.
height
{
return
None
;
}
match
self
.
nodes_from_point
(
point
NodesFromPointQueryType
:
:
Topmost
)
.
first
(
)
{
Some
(
address
)
=
>
{
let
js_runtime
=
unsafe
{
JS_GetRuntime
(
window
.
get_cx
(
)
)
}
;
let
node
=
unsafe
{
node
:
:
from_untrusted_node_address
(
js_runtime
*
address
)
}
;
let
parent_node
=
node
.
GetParentNode
(
)
.
unwrap
(
)
;
let
element_ref
=
node
.
downcast
:
:
<
Element
>
(
)
.
unwrap_or_else
(
|
|
{
parent_node
.
downcast
:
:
<
Element
>
(
)
.
unwrap
(
)
}
)
;
Some
(
DomRoot
:
:
from_ref
(
element_ref
)
)
}
None
=
>
self
.
GetDocumentElement
(
)
}
}
#
[
allow
(
unsafe_code
)
]
fn
ElementsFromPoint
(
&
self
x
:
Finite
<
f64
>
y
:
Finite
<
f64
>
)
-
>
Vec
<
DomRoot
<
Element
>
>
{
let
x
=
*
x
as
f32
;
let
y
=
*
y
as
f32
;
let
point
=
&
Point2D
:
:
new
(
x
y
)
;
let
window
=
window_from_node
(
self
)
;
let
viewport
=
window
.
window_size
(
)
.
unwrap
(
)
.
initial_viewport
;
if
self
.
browsing_context
(
)
.
is_none
(
)
{
return
vec
!
(
)
;
}
if
x
<
0
.
0
|
|
y
<
0
.
0
|
|
x
>
viewport
.
width
|
|
y
>
viewport
.
height
{
return
vec
!
(
)
;
}
let
js_runtime
=
unsafe
{
JS_GetRuntime
(
window
.
get_cx
(
)
)
}
;
let
nodes
=
self
.
nodes_from_point
(
point
NodesFromPointQueryType
:
:
All
)
;
let
mut
elements
:
Vec
<
DomRoot
<
Element
>
>
=
nodes
.
iter
(
)
.
flat_map
(
|
&
untrusted_node_address
|
{
let
node
=
unsafe
{
node
:
:
from_untrusted_node_address
(
js_runtime
untrusted_node_address
)
}
;
DomRoot
:
:
downcast
:
:
<
Element
>
(
node
)
}
)
.
collect
(
)
;
if
let
Some
(
root_element
)
=
self
.
GetDocumentElement
(
)
{
if
elements
.
last
(
)
!
=
Some
(
&
root_element
)
{
elements
.
push
(
root_element
)
;
}
}
elements
}
fn
Open
(
&
self
type_
:
DOMString
replace
:
DOMString
)
-
>
Fallible
<
DomRoot
<
Document
>
>
{
if
!
self
.
is_html_document
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
if
self
.
throw_on_dynamic_markup_insertion_counter
.
get
(
)
>
0
{
return
Err
(
Error
:
:
InvalidState
)
;
}
if
!
self
.
is_active
(
)
{
return
Ok
(
DomRoot
:
:
from_ref
(
self
)
)
;
}
let
entry_responsible_document
=
GlobalScope
:
:
entry
(
)
.
as_window
(
)
.
Document
(
)
;
if
!
self
.
origin
.
same_origin
(
&
entry_responsible_document
.
origin
)
{
return
Err
(
Error
:
:
Security
)
;
}
if
self
.
get_current_parser
(
)
.
map_or
(
false
|
parser
|
parser
.
script_nesting_level
(
)
>
0
)
{
return
Ok
(
DomRoot
:
:
from_ref
(
self
)
)
;
}
let
replace
=
replace
.
eq_ignore_ascii_case
(
"
replace
"
)
;
window_from_node
(
self
)
.
set_navigation_start
(
)
;
self
.
abort
(
)
;
for
node
in
self
.
upcast
:
:
<
Node
>
(
)
.
traverse_preorder
(
)
{
node
.
upcast
:
:
<
EventTarget
>
(
)
.
remove_all_listeners
(
)
;
}
Node
:
:
replace_all
(
None
self
.
upcast
:
:
<
Node
>
(
)
)
;
self
.
implementation
.
set
(
None
)
;
self
.
images
.
set
(
None
)
;
self
.
embeds
.
set
(
None
)
;
self
.
links
.
set
(
None
)
;
self
.
forms
.
set
(
None
)
;
self
.
scripts
.
set
(
None
)
;
self
.
anchors
.
set
(
None
)
;
self
.
applets
.
set
(
None
)
;
*
self
.
stylesheets
.
borrow_mut
(
)
=
StylesheetSet
:
:
new
(
)
;
self
.
animation_frame_ident
.
set
(
0
)
;
self
.
animation_frame_list
.
borrow_mut
(
)
.
clear
(
)
;
self
.
pending_restyles
.
borrow_mut
(
)
.
clear
(
)
;
self
.
target_element
.
set
(
None
)
;
*
self
.
last_click_info
.
borrow_mut
(
)
=
None
;
self
.
set_encoding
(
UTF_8
)
;
let
url
=
entry_responsible_document
.
url
(
)
;
self
.
set_url
(
url
.
clone
(
)
)
;
let
type_
=
if
type_
.
eq_ignore_ascii_case
(
"
replace
"
)
{
"
text
/
html
"
}
else
if
let
Some
(
position
)
=
type_
.
find
(
'
;
'
)
{
&
type_
[
0
.
.
position
]
}
else
{
&
*
type_
}
;
let
type_
=
type_
.
trim_matches
(
HTML_SPACE_CHARACTERS
)
;
let
resource_threads
=
self
.
window
.
upcast
:
:
<
GlobalScope
>
(
)
.
resource_threads
(
)
.
clone
(
)
;
*
self
.
loader
.
borrow_mut
(
)
=
DocumentLoader
:
:
new_with_threads
(
resource_threads
Some
(
url
.
clone
(
)
)
)
;
ServoParser
:
:
parse_html_script_input
(
self
url
type_
)
;
self
.
ready_state
.
set
(
DocumentReadyState
:
:
Interactive
)
;
if
!
replace
{
}
Ok
(
DomRoot
:
:
from_ref
(
self
)
)
}
fn
Write
(
&
self
text
:
Vec
<
DOMString
>
)
-
>
ErrorResult
{
if
!
self
.
is_html_document
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
if
self
.
throw_on_dynamic_markup_insertion_counter
.
get
(
)
>
0
{
return
Err
(
Error
:
:
InvalidState
)
;
}
if
!
self
.
is_active
(
)
{
return
Ok
(
(
)
)
;
}
let
parser
=
match
self
.
get_current_parser
(
)
{
Some
(
ref
parser
)
if
parser
.
can_write
(
)
=
>
DomRoot
:
:
from_ref
(
&
*
*
parser
)
_
=
>
{
if
self
.
ignore_destructive_writes_counter
.
get
(
)
>
0
{
return
Ok
(
(
)
)
;
}
self
.
Open
(
"
text
/
html
"
.
into
(
)
"
"
.
into
(
)
)
?
;
self
.
get_current_parser
(
)
.
unwrap
(
)
}
}
;
parser
.
write
(
text
)
;
Ok
(
(
)
)
}
fn
Writeln
(
&
self
mut
text
:
Vec
<
DOMString
>
)
-
>
ErrorResult
{
text
.
push
(
"
\
n
"
.
into
(
)
)
;
self
.
Write
(
text
)
}
fn
Close
(
&
self
)
-
>
ErrorResult
{
if
!
self
.
is_html_document
(
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
if
self
.
throw_on_dynamic_markup_insertion_counter
.
get
(
)
>
0
{
return
Err
(
Error
:
:
InvalidState
)
;
}
let
parser
=
match
self
.
get_current_parser
(
)
{
Some
(
ref
parser
)
if
parser
.
is_script_created
(
)
=
>
DomRoot
:
:
from_ref
(
&
*
*
parser
)
_
=
>
{
return
Ok
(
(
)
)
;
}
}
;
parser
.
close
(
)
;
Ok
(
(
)
)
}
document_and_element_event_handlers
!
(
)
;
event_handler
!
(
fullscreenerror
GetOnfullscreenerror
SetOnfullscreenerror
)
;
event_handler
!
(
fullscreenchange
GetOnfullscreenchange
SetOnfullscreenchange
)
;
fn
FullscreenEnabled
(
&
self
)
-
>
bool
{
self
.
get_allow_fullscreen
(
)
}
fn
Fullscreen
(
&
self
)
-
>
bool
{
self
.
fullscreen_element
.
get
(
)
.
is_some
(
)
}
fn
GetFullscreenElement
(
&
self
)
-
>
Option
<
DomRoot
<
Element
>
>
{
self
.
fullscreen_element
.
get
(
)
}
#
[
allow
(
unrooted_must_root
)
]
fn
ExitFullscreen
(
&
self
)
-
>
Rc
<
Promise
>
{
self
.
exit_fullscreen
(
)
}
}
fn
update_with_current_time_ms
(
marker
:
&
Cell
<
u64
>
)
{
if
marker
.
get
(
)
=
=
Default
:
:
default
(
)
{
let
time
=
time
:
:
get_time
(
)
;
let
current_time_ms
=
time
.
sec
*
1000
+
time
.
nsec
as
i64
/
1000000
;
marker
.
set
(
current_time_ms
as
u64
)
;
}
}
pub
fn
determine_policy_for_token
(
token
:
&
str
)
-
>
Option
<
ReferrerPolicy
>
{
match_ignore_ascii_case
!
{
token
"
never
"
|
"
no
-
referrer
"
=
>
Some
(
ReferrerPolicy
:
:
NoReferrer
)
"
default
"
|
"
no
-
referrer
-
when
-
downgrade
"
=
>
Some
(
ReferrerPolicy
:
:
NoReferrerWhenDowngrade
)
"
origin
"
=
>
Some
(
ReferrerPolicy
:
:
Origin
)
"
same
-
origin
"
=
>
Some
(
ReferrerPolicy
:
:
SameOrigin
)
"
strict
-
origin
"
=
>
Some
(
ReferrerPolicy
:
:
StrictOrigin
)
"
strict
-
origin
-
when
-
cross
-
origin
"
=
>
Some
(
ReferrerPolicy
:
:
StrictOriginWhenCrossOrigin
)
"
origin
-
when
-
cross
-
origin
"
=
>
Some
(
ReferrerPolicy
:
:
OriginWhenCrossOrigin
)
"
always
"
|
"
unsafe
-
url
"
=
>
Some
(
ReferrerPolicy
:
:
UnsafeUrl
)
"
"
=
>
Some
(
ReferrerPolicy
:
:
NoReferrer
)
_
=
>
None
}
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
FocusType
{
Element
Parent
}
pub
enum
FocusEventType
{
Focus
Blur
}
#
[
derive
(
JSTraceable
MallocSizeOf
)
]
pub
struct
FakeRequestAnimationFrameCallback
{
#
[
ignore_malloc_size_of
=
"
non
-
owning
"
]
document
:
Trusted
<
Document
>
}
impl
FakeRequestAnimationFrameCallback
{
pub
fn
invoke
(
self
)
{
let
document
=
self
.
document
.
root
(
)
;
document
.
run_the_animation_frame_callbacks
(
)
;
}
}
#
[
derive
(
JSTraceable
MallocSizeOf
)
]
pub
enum
AnimationFrameCallback
{
DevtoolsFramerateTick
{
actor_name
:
String
}
FrameRequestCallback
{
#
[
ignore_malloc_size_of
=
"
Rc
is
hard
"
]
callback
:
Rc
<
FrameRequestCallback
>
}
}
impl
AnimationFrameCallback
{
fn
call
(
&
self
document
:
&
Document
now
:
f64
)
{
match
*
self
{
AnimationFrameCallback
:
:
DevtoolsFramerateTick
{
ref
actor_name
}
=
>
{
let
msg
=
ScriptToDevtoolsControlMsg
:
:
FramerateTick
(
actor_name
.
clone
(
)
now
)
;
let
devtools_sender
=
document
.
window
(
)
.
upcast
:
:
<
GlobalScope
>
(
)
.
devtools_chan
(
)
.
unwrap
(
)
;
devtools_sender
.
send
(
msg
)
.
unwrap
(
)
;
}
AnimationFrameCallback
:
:
FrameRequestCallback
{
ref
callback
}
=
>
{
let
_
=
callback
.
Call__
(
Finite
:
:
wrap
(
now
)
ExceptionHandling
:
:
Report
)
;
}
}
}
}
#
[
derive
(
Default
JSTraceable
MallocSizeOf
)
]
#
[
must_root
]
struct
PendingInOrderScriptVec
{
scripts
:
DomRefCell
<
VecDeque
<
PendingScript
>
>
}
impl
PendingInOrderScriptVec
{
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
scripts
.
borrow
(
)
.
is_empty
(
)
}
fn
push
(
&
self
element
:
&
HTMLScriptElement
)
{
self
.
scripts
.
borrow_mut
(
)
.
push_back
(
PendingScript
:
:
new
(
element
)
)
;
}
fn
loaded
(
&
self
element
:
&
HTMLScriptElement
result
:
ScriptResult
)
{
let
mut
scripts
=
self
.
scripts
.
borrow_mut
(
)
;
let
entry
=
scripts
.
iter_mut
(
)
.
find
(
|
entry
|
&
*
entry
.
element
=
=
element
)
.
unwrap
(
)
;
entry
.
loaded
(
result
)
;
}
fn
take_next_ready_to_be_executed
(
&
self
)
-
>
Option
<
(
DomRoot
<
HTMLScriptElement
>
ScriptResult
)
>
{
let
mut
scripts
=
self
.
scripts
.
borrow_mut
(
)
;
let
pair
=
scripts
.
front_mut
(
)
?
.
take_result
(
)
?
;
scripts
.
pop_front
(
)
;
Some
(
pair
)
}
fn
clear
(
&
self
)
{
*
self
.
scripts
.
borrow_mut
(
)
=
Default
:
:
default
(
)
;
}
}
#
[
derive
(
JSTraceable
MallocSizeOf
)
]
#
[
must_root
]
struct
PendingScript
{
element
:
Dom
<
HTMLScriptElement
>
load
:
Option
<
ScriptResult
>
}
impl
PendingScript
{
fn
new
(
element
:
&
HTMLScriptElement
)
-
>
Self
{
Self
{
element
:
Dom
:
:
from_ref
(
element
)
load
:
None
}
}
fn
new_with_load
(
element
:
&
HTMLScriptElement
load
:
Option
<
ScriptResult
>
)
-
>
Self
{
Self
{
element
:
Dom
:
:
from_ref
(
element
)
load
}
}
fn
loaded
(
&
mut
self
result
:
ScriptResult
)
{
assert
!
(
self
.
load
.
is_none
(
)
)
;
self
.
load
=
Some
(
result
)
;
}
fn
take_result
(
&
mut
self
)
-
>
Option
<
(
DomRoot
<
HTMLScriptElement
>
ScriptResult
)
>
{
self
.
load
.
take
(
)
.
map
(
|
result
|
(
DomRoot
:
:
from_ref
(
&
*
self
.
element
)
result
)
)
}
}
