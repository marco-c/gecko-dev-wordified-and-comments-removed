use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
DOMPointBinding
:
:
{
DOMPointInit
DOMPointMethods
Wrap
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
DOMPointReadOnlyBinding
:
:
DOMPointReadOnlyMethods
;
use
dom
:
:
bindings
:
:
error
:
:
Fallible
;
use
dom
:
:
bindings
:
:
js
:
:
Root
;
use
dom
:
:
bindings
:
:
reflector
:
:
reflect_dom_object
;
use
dom
:
:
dompointreadonly
:
:
{
DOMPointReadOnly
DOMPointWriteMethods
}
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom_struct
:
:
dom_struct
;
#
[
dom_struct
]
pub
struct
DOMPoint
{
point
:
DOMPointReadOnly
}
impl
DOMPoint
{
fn
new_inherited
(
x
:
f64
y
:
f64
z
:
f64
w
:
f64
)
-
>
DOMPoint
{
DOMPoint
{
point
:
DOMPointReadOnly
:
:
new_inherited
(
x
y
z
w
)
}
}
pub
fn
new
(
global
:
&
GlobalScope
x
:
f64
y
:
f64
z
:
f64
w
:
f64
)
-
>
Root
<
DOMPoint
>
{
reflect_dom_object
(
box
DOMPoint
:
:
new_inherited
(
x
y
z
w
)
global
Wrap
)
}
pub
fn
Constructor
(
global
:
&
GlobalScope
x
:
f64
y
:
f64
z
:
f64
w
:
f64
)
-
>
Fallible
<
Root
<
DOMPoint
>
>
{
Ok
(
DOMPoint
:
:
new
(
global
x
y
z
w
)
)
}
pub
fn
new_from_init
(
global
:
&
GlobalScope
p
:
&
DOMPointInit
)
-
>
Root
<
DOMPoint
>
{
DOMPoint
:
:
new
(
global
p
.
x
p
.
y
p
.
z
p
.
w
)
}
}
impl
DOMPointMethods
for
DOMPoint
{
fn
X
(
&
self
)
-
>
f64
{
self
.
point
.
X
(
)
}
fn
SetX
(
&
self
value
:
f64
)
{
self
.
point
.
SetX
(
value
)
;
}
fn
Y
(
&
self
)
-
>
f64
{
self
.
point
.
Y
(
)
}
fn
SetY
(
&
self
value
:
f64
)
{
self
.
point
.
SetY
(
value
)
;
}
fn
Z
(
&
self
)
-
>
f64
{
self
.
point
.
Z
(
)
}
fn
SetZ
(
&
self
value
:
f64
)
{
self
.
point
.
SetZ
(
value
)
;
}
fn
W
(
&
self
)
-
>
f64
{
self
.
point
.
W
(
)
}
fn
SetW
(
&
self
value
:
f64
)
{
self
.
point
.
SetW
(
value
)
;
}
}
