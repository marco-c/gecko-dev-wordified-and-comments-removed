use
dom
:
:
attr
:
:
Attr
;
use
dom
:
:
bindings
:
:
cell
:
:
DomRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
EventBinding
:
:
EventMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
HTMLTextAreaElementBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
HTMLTextAreaElementBinding
:
:
HTMLTextAreaElementMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeBinding
:
:
NodeMethods
;
use
dom
:
:
bindings
:
:
inheritance
:
:
Castable
;
use
dom
:
:
bindings
:
:
root
:
:
{
DomRoot
LayoutDom
MutNullableDom
}
;
use
dom
:
:
bindings
:
:
str
:
:
DOMString
;
use
dom
:
:
document
:
:
Document
;
use
dom
:
:
element
:
:
{
AttributeMutation
Element
}
;
use
dom
:
:
element
:
:
RawLayoutElementHelpers
;
use
dom
:
:
event
:
:
{
Event
EventBubbles
EventCancelable
}
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom
:
:
htmlelement
:
:
HTMLElement
;
use
dom
:
:
htmlfieldsetelement
:
:
HTMLFieldSetElement
;
use
dom
:
:
htmlformelement
:
:
{
FormControl
HTMLFormElement
}
;
use
dom
:
:
keyboardevent
:
:
KeyboardEvent
;
use
dom
:
:
node
:
:
{
ChildrenMutation
Node
NodeDamage
UnbindContext
}
;
use
dom
:
:
node
:
:
{
document_from_node
window_from_node
}
;
use
dom
:
:
nodelist
:
:
NodeList
;
use
dom
:
:
validation
:
:
Validatable
;
use
dom
:
:
virtualmethods
:
:
VirtualMethods
;
use
dom_struct
:
:
dom_struct
;
use
html5ever
:
:
{
LocalName
Prefix
}
;
use
script_traits
:
:
ScriptToConstellationChan
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
ops
:
:
Range
;
use
style
:
:
attr
:
:
AttrValue
;
use
style
:
:
element_state
:
:
ElementState
;
use
textinput
:
:
{
KeyReaction
Lines
SelectionDirection
TextInput
}
;
#
[
dom_struct
]
pub
struct
HTMLTextAreaElement
{
htmlelement
:
HTMLElement
#
[
ignore_malloc_size_of
=
"
#
7193
"
]
textinput
:
DomRefCell
<
TextInput
<
ScriptToConstellationChan
>
>
placeholder
:
DomRefCell
<
DOMString
>
value_changed
:
Cell
<
bool
>
form_owner
:
MutNullableDom
<
HTMLFormElement
>
}
pub
trait
LayoutHTMLTextAreaElementHelpers
{
#
[
allow
(
unsafe_code
)
]
unsafe
fn
get_value_for_layout
(
self
)
-
>
String
;
#
[
allow
(
unsafe_code
)
]
unsafe
fn
selection_for_layout
(
self
)
-
>
Option
<
Range
<
usize
>
>
;
#
[
allow
(
unsafe_code
)
]
fn
get_cols
(
self
)
-
>
u32
;
#
[
allow
(
unsafe_code
)
]
fn
get_rows
(
self
)
-
>
u32
;
}
impl
LayoutHTMLTextAreaElementHelpers
for
LayoutDom
<
HTMLTextAreaElement
>
{
#
[
allow
(
unrooted_must_root
)
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
get_value_for_layout
(
self
)
-
>
String
{
let
text
=
(
*
self
.
unsafe_get
(
)
)
.
textinput
.
borrow_for_layout
(
)
.
get_content
(
)
;
String
:
:
from
(
if
text
.
is_empty
(
)
{
(
*
self
.
unsafe_get
(
)
)
.
placeholder
.
borrow_for_layout
(
)
.
clone
(
)
}
else
{
text
}
)
}
#
[
allow
(
unrooted_must_root
)
]
#
[
allow
(
unsafe_code
)
]
unsafe
fn
selection_for_layout
(
self
)
-
>
Option
<
Range
<
usize
>
>
{
if
!
(
*
self
.
unsafe_get
(
)
)
.
upcast
:
:
<
Element
>
(
)
.
focus_state
(
)
{
return
None
;
}
let
textinput
=
(
*
self
.
unsafe_get
(
)
)
.
textinput
.
borrow_for_layout
(
)
;
Some
(
textinput
.
get_absolute_selection_range
(
)
)
}
#
[
allow
(
unsafe_code
)
]
fn
get_cols
(
self
)
-
>
u32
{
unsafe
{
(
*
self
.
upcast
:
:
<
Element
>
(
)
.
unsafe_get
(
)
)
.
get_attr_for_layout
(
&
ns
!
(
)
&
local_name
!
(
"
cols
"
)
)
.
map_or
(
DEFAULT_COLS
AttrValue
:
:
as_uint
)
}
}
#
[
allow
(
unsafe_code
)
]
fn
get_rows
(
self
)
-
>
u32
{
unsafe
{
(
*
self
.
upcast
:
:
<
Element
>
(
)
.
unsafe_get
(
)
)
.
get_attr_for_layout
(
&
ns
!
(
)
&
local_name
!
(
"
rows
"
)
)
.
map_or
(
DEFAULT_ROWS
AttrValue
:
:
as_uint
)
}
}
}
static
DEFAULT_COLS
:
u32
=
20
;
static
DEFAULT_ROWS
:
u32
=
2
;
impl
HTMLTextAreaElement
{
fn
new_inherited
(
local_name
:
LocalName
prefix
:
Option
<
Prefix
>
document
:
&
Document
)
-
>
HTMLTextAreaElement
{
let
chan
=
document
.
window
(
)
.
upcast
:
:
<
GlobalScope
>
(
)
.
script_to_constellation_chan
(
)
.
clone
(
)
;
HTMLTextAreaElement
{
htmlelement
:
HTMLElement
:
:
new_inherited_with_state
(
ElementState
:
:
IN_ENABLED_STATE
|
ElementState
:
:
IN_READ_WRITE_STATE
local_name
prefix
document
)
placeholder
:
DomRefCell
:
:
new
(
DOMString
:
:
new
(
)
)
textinput
:
DomRefCell
:
:
new
(
TextInput
:
:
new
(
Lines
:
:
Multiple
DOMString
:
:
new
(
)
chan
None
None
SelectionDirection
:
:
None
)
)
value_changed
:
Cell
:
:
new
(
false
)
form_owner
:
Default
:
:
default
(
)
}
}
#
[
allow
(
unrooted_must_root
)
]
pub
fn
new
(
local_name
:
LocalName
prefix
:
Option
<
Prefix
>
document
:
&
Document
)
-
>
DomRoot
<
HTMLTextAreaElement
>
{
Node
:
:
reflect_node
(
Box
:
:
new
(
HTMLTextAreaElement
:
:
new_inherited
(
local_name
prefix
document
)
)
document
HTMLTextAreaElementBinding
:
:
Wrap
)
}
fn
update_placeholder_shown_state
(
&
self
)
{
let
has_placeholder
=
!
self
.
placeholder
.
borrow
(
)
.
is_empty
(
)
;
let
has_value
=
!
self
.
textinput
.
borrow
(
)
.
is_empty
(
)
;
let
el
=
self
.
upcast
:
:
<
Element
>
(
)
;
el
.
set_placeholder_shown_state
(
has_placeholder
&
&
!
has_value
)
;
el
.
set_placeholder_shown_state
(
has_placeholder
)
;
}
}
impl
HTMLTextAreaElementMethods
for
HTMLTextAreaElement
{
make_uint_getter
!
(
Cols
"
cols
"
DEFAULT_COLS
)
;
make_limited_uint_setter
!
(
SetCols
"
cols
"
DEFAULT_COLS
)
;
make_bool_getter
!
(
Disabled
"
disabled
"
)
;
make_bool_setter
!
(
SetDisabled
"
disabled
"
)
;
fn
GetForm
(
&
self
)
-
>
Option
<
DomRoot
<
HTMLFormElement
>
>
{
self
.
form_owner
(
)
}
make_getter
!
(
Name
"
name
"
)
;
make_setter
!
(
SetName
"
name
"
)
;
make_getter
!
(
Placeholder
"
placeholder
"
)
;
make_setter
!
(
SetPlaceholder
"
placeholder
"
)
;
make_bool_getter
!
(
ReadOnly
"
readonly
"
)
;
make_bool_setter
!
(
SetReadOnly
"
readonly
"
)
;
make_bool_getter
!
(
Required
"
required
"
)
;
make_bool_setter
!
(
SetRequired
"
required
"
)
;
make_uint_getter
!
(
Rows
"
rows
"
DEFAULT_ROWS
)
;
make_limited_uint_setter
!
(
SetRows
"
rows
"
DEFAULT_ROWS
)
;
make_getter
!
(
Wrap
"
wrap
"
)
;
make_setter
!
(
SetWrap
"
wrap
"
)
;
fn
Type
(
&
self
)
-
>
DOMString
{
DOMString
:
:
from
(
"
textarea
"
)
}
fn
DefaultValue
(
&
self
)
-
>
DOMString
{
self
.
upcast
:
:
<
Node
>
(
)
.
GetTextContent
(
)
.
unwrap
(
)
}
fn
SetDefaultValue
(
&
self
value
:
DOMString
)
{
self
.
upcast
:
:
<
Node
>
(
)
.
SetTextContent
(
Some
(
value
)
)
;
if
!
self
.
value_changed
.
get
(
)
{
self
.
reset
(
)
;
}
}
fn
Value
(
&
self
)
-
>
DOMString
{
self
.
textinput
.
borrow
(
)
.
get_content
(
)
}
fn
SetValue
(
&
self
value
:
DOMString
)
{
self
.
textinput
.
borrow_mut
(
)
.
set_content
(
value
)
;
self
.
value_changed
.
set
(
true
)
;
self
.
upcast
:
:
<
Node
>
(
)
.
dirty
(
NodeDamage
:
:
OtherNodeDamage
)
;
}
fn
Labels
(
&
self
)
-
>
DomRoot
<
NodeList
>
{
self
.
upcast
:
:
<
HTMLElement
>
(
)
.
labels
(
)
}
fn
SetSelectionDirection
(
&
self
direction
:
DOMString
)
{
self
.
textinput
.
borrow_mut
(
)
.
selection_direction
=
SelectionDirection
:
:
from
(
direction
)
;
}
fn
SelectionDirection
(
&
self
)
-
>
DOMString
{
DOMString
:
:
from
(
self
.
textinput
.
borrow
(
)
.
selection_direction
)
}
fn
SetSelectionEnd
(
&
self
end
:
u32
)
{
let
selection_start
=
self
.
SelectionStart
(
)
;
self
.
textinput
.
borrow_mut
(
)
.
set_selection_range
(
selection_start
end
)
;
self
.
upcast
:
:
<
Node
>
(
)
.
dirty
(
NodeDamage
:
:
OtherNodeDamage
)
;
}
fn
SelectionEnd
(
&
self
)
-
>
u32
{
self
.
textinput
.
borrow
(
)
.
get_absolute_insertion_point
(
)
as
u32
}
fn
SetSelectionStart
(
&
self
start
:
u32
)
{
let
selection_end
=
self
.
SelectionEnd
(
)
;
self
.
textinput
.
borrow_mut
(
)
.
set_selection_range
(
start
selection_end
)
;
self
.
upcast
:
:
<
Node
>
(
)
.
dirty
(
NodeDamage
:
:
OtherNodeDamage
)
;
}
fn
SelectionStart
(
&
self
)
-
>
u32
{
self
.
textinput
.
borrow
(
)
.
get_selection_start
(
)
}
fn
SetSelectionRange
(
&
self
start
:
u32
end
:
u32
direction
:
Option
<
DOMString
>
)
{
let
direction
=
direction
.
map_or
(
SelectionDirection
:
:
None
|
d
|
SelectionDirection
:
:
from
(
d
)
)
;
self
.
textinput
.
borrow_mut
(
)
.
selection_direction
=
direction
;
self
.
textinput
.
borrow_mut
(
)
.
set_selection_range
(
start
end
)
;
let
window
=
window_from_node
(
self
)
;
let
_
=
window
.
user_interaction_task_source
(
)
.
queue_event
(
&
self
.
upcast
(
)
atom
!
(
"
select
"
)
EventBubbles
:
:
Bubbles
EventCancelable
:
:
NotCancelable
&
window
)
;
self
.
upcast
:
:
<
Node
>
(
)
.
dirty
(
NodeDamage
:
:
OtherNodeDamage
)
;
}
}
impl
HTMLTextAreaElement
{
pub
fn
reset
(
&
self
)
{
self
.
SetValue
(
self
.
DefaultValue
(
)
)
;
self
.
value_changed
.
set
(
false
)
;
}
}
impl
VirtualMethods
for
HTMLTextAreaElement
{
fn
super_type
(
&
self
)
-
>
Option
<
&
VirtualMethods
>
{
Some
(
self
.
upcast
:
:
<
HTMLElement
>
(
)
as
&
VirtualMethods
)
}
fn
attribute_mutated
(
&
self
attr
:
&
Attr
mutation
:
AttributeMutation
)
{
self
.
super_type
(
)
.
unwrap
(
)
.
attribute_mutated
(
attr
mutation
)
;
match
*
attr
.
local_name
(
)
{
local_name
!
(
"
disabled
"
)
=
>
{
let
el
=
self
.
upcast
:
:
<
Element
>
(
)
;
match
mutation
{
AttributeMutation
:
:
Set
(
_
)
=
>
{
el
.
set_disabled_state
(
true
)
;
el
.
set_enabled_state
(
false
)
;
el
.
set_read_write_state
(
false
)
;
}
AttributeMutation
:
:
Removed
=
>
{
el
.
set_disabled_state
(
false
)
;
el
.
set_enabled_state
(
true
)
;
el
.
check_ancestors_disabled_state_for_form_control
(
)
;
if
!
el
.
disabled_state
(
)
&
&
!
el
.
read_write_state
(
)
{
el
.
set_read_write_state
(
true
)
;
}
}
}
}
local_name
!
(
"
placeholder
"
)
=
>
{
{
let
mut
placeholder
=
self
.
placeholder
.
borrow_mut
(
)
;
placeholder
.
clear
(
)
;
if
let
AttributeMutation
:
:
Set
(
_
)
=
mutation
{
placeholder
.
push_str
(
&
attr
.
value
(
)
)
;
}
}
self
.
update_placeholder_shown_state
(
)
;
}
local_name
!
(
"
readonly
"
)
=
>
{
let
el
=
self
.
upcast
:
:
<
Element
>
(
)
;
match
mutation
{
AttributeMutation
:
:
Set
(
_
)
=
>
{
el
.
set_read_write_state
(
false
)
;
}
AttributeMutation
:
:
Removed
=
>
{
el
.
set_read_write_state
(
!
el
.
disabled_state
(
)
)
;
}
}
}
local_name
!
(
"
form
"
)
=
>
{
self
.
form_attribute_mutated
(
mutation
)
;
}
_
=
>
{
}
}
}
fn
bind_to_tree
(
&
self
tree_in_doc
:
bool
)
{
if
let
Some
(
ref
s
)
=
self
.
super_type
(
)
{
s
.
bind_to_tree
(
tree_in_doc
)
;
}
self
.
upcast
:
:
<
Element
>
(
)
.
check_ancestors_disabled_state_for_form_control
(
)
;
}
fn
parse_plain_attribute
(
&
self
name
:
&
LocalName
value
:
DOMString
)
-
>
AttrValue
{
match
*
name
{
local_name
!
(
"
cols
"
)
=
>
AttrValue
:
:
from_limited_u32
(
value
.
into
(
)
DEFAULT_COLS
)
local_name
!
(
"
rows
"
)
=
>
AttrValue
:
:
from_limited_u32
(
value
.
into
(
)
DEFAULT_ROWS
)
_
=
>
self
.
super_type
(
)
.
unwrap
(
)
.
parse_plain_attribute
(
name
value
)
}
}
fn
unbind_from_tree
(
&
self
context
:
&
UnbindContext
)
{
self
.
super_type
(
)
.
unwrap
(
)
.
unbind_from_tree
(
context
)
;
let
node
=
self
.
upcast
:
:
<
Node
>
(
)
;
let
el
=
self
.
upcast
:
:
<
Element
>
(
)
;
if
node
.
ancestors
(
)
.
any
(
|
ancestor
|
ancestor
.
is
:
:
<
HTMLFieldSetElement
>
(
)
)
{
el
.
check_ancestors_disabled_state_for_form_control
(
)
;
}
else
{
el
.
check_disabled_attribute
(
)
;
}
}
fn
children_changed
(
&
self
mutation
:
&
ChildrenMutation
)
{
if
let
Some
(
ref
s
)
=
self
.
super_type
(
)
{
s
.
children_changed
(
mutation
)
;
}
if
!
self
.
value_changed
.
get
(
)
{
self
.
reset
(
)
;
}
}
fn
handle_event
(
&
self
event
:
&
Event
)
{
if
let
Some
(
s
)
=
self
.
super_type
(
)
{
s
.
handle_event
(
event
)
;
}
if
event
.
type_
(
)
=
=
atom
!
(
"
click
"
)
&
&
!
event
.
DefaultPrevented
(
)
{
document_from_node
(
self
)
.
request_focus
(
self
.
upcast
(
)
)
;
}
else
if
event
.
type_
(
)
=
=
atom
!
(
"
keydown
"
)
&
&
!
event
.
DefaultPrevented
(
)
{
if
let
Some
(
kevent
)
=
event
.
downcast
:
:
<
KeyboardEvent
>
(
)
{
let
action
=
self
.
textinput
.
borrow_mut
(
)
.
handle_keydown
(
kevent
)
;
match
action
{
KeyReaction
:
:
TriggerDefaultAction
=
>
(
)
KeyReaction
:
:
DispatchInput
=
>
{
self
.
value_changed
.
set
(
true
)
;
self
.
update_placeholder_shown_state
(
)
;
self
.
upcast
:
:
<
Node
>
(
)
.
dirty
(
NodeDamage
:
:
OtherNodeDamage
)
;
event
.
mark_as_handled
(
)
;
}
KeyReaction
:
:
RedrawSelection
=
>
{
self
.
upcast
:
:
<
Node
>
(
)
.
dirty
(
NodeDamage
:
:
OtherNodeDamage
)
;
event
.
mark_as_handled
(
)
;
}
KeyReaction
:
:
Nothing
=
>
(
)
}
}
}
else
if
event
.
type_
(
)
=
=
atom
!
(
"
keypress
"
)
&
&
!
event
.
DefaultPrevented
(
)
{
if
event
.
IsTrusted
(
)
{
let
window
=
window_from_node
(
self
)
;
let
_
=
window
.
user_interaction_task_source
(
)
.
queue_event
(
&
self
.
upcast
(
)
atom
!
(
"
input
"
)
EventBubbles
:
:
Bubbles
EventCancelable
:
:
NotCancelable
&
window
)
;
}
}
}
fn
pop
(
&
self
)
{
self
.
super_type
(
)
.
unwrap
(
)
.
pop
(
)
;
self
.
reset
(
)
;
}
}
impl
FormControl
for
HTMLTextAreaElement
{
fn
form_owner
(
&
self
)
-
>
Option
<
DomRoot
<
HTMLFormElement
>
>
{
self
.
form_owner
.
get
(
)
}
fn
set_form_owner
(
&
self
form
:
Option
<
&
HTMLFormElement
>
)
{
self
.
form_owner
.
set
(
form
)
;
}
fn
to_element
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Element
{
self
.
upcast
:
:
<
Element
>
(
)
}
}
impl
Validatable
for
HTMLTextAreaElement
{
}
