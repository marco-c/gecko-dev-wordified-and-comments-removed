use
bluetooth_traits
:
:
{
BluetoothRequest
BluetoothResponse
GATTType
}
;
use
bluetooth_traits
:
:
blocklist
:
:
{
Blocklist
uuid_is_blocklisted
}
;
use
dom
:
:
bindings
:
:
cell
:
:
DomRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
BluetoothCharacteristicPropertiesBinding
:
:
BluetoothCharacteristicPropertiesMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
BluetoothRemoteGATTCharacteristicBinding
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
BluetoothRemoteGATTCharacteristicBinding
:
:
BluetoothRemoteGATTCharacteristicMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
BluetoothRemoteGATTServerBinding
:
:
BluetoothRemoteGATTServerMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
BluetoothRemoteGATTServiceBinding
:
:
BluetoothRemoteGATTServiceMethods
;
use
dom
:
:
bindings
:
:
error
:
:
Error
:
:
{
self
InvalidModification
Network
NotSupported
Security
}
;
use
dom
:
:
bindings
:
:
inheritance
:
:
Castable
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
DomObject
reflect_dom_object
}
;
use
dom
:
:
bindings
:
:
root
:
:
{
Dom
DomRoot
}
;
use
dom
:
:
bindings
:
:
str
:
:
{
ByteString
DOMString
}
;
use
dom
:
:
bluetooth
:
:
{
AsyncBluetoothListener
get_gatt_children
response_async
}
;
use
dom
:
:
bluetoothcharacteristicproperties
:
:
BluetoothCharacteristicProperties
;
use
dom
:
:
bluetoothremotegattservice
:
:
BluetoothRemoteGATTService
;
use
dom
:
:
bluetoothuuid
:
:
{
BluetoothDescriptorUUID
BluetoothUUID
}
;
use
dom
:
:
eventtarget
:
:
EventTarget
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom
:
:
promise
:
:
Promise
;
use
dom_struct
:
:
dom_struct
;
use
ipc_channel
:
:
ipc
:
:
IpcSender
;
use
std
:
:
rc
:
:
Rc
;
pub
const
MAXIMUM_ATTRIBUTE_LENGTH
:
usize
=
512
;
#
[
dom_struct
]
pub
struct
BluetoothRemoteGATTCharacteristic
{
eventtarget
:
EventTarget
service
:
Dom
<
BluetoothRemoteGATTService
>
uuid
:
DOMString
properties
:
Dom
<
BluetoothCharacteristicProperties
>
value
:
DomRefCell
<
Option
<
ByteString
>
>
instance_id
:
String
}
impl
BluetoothRemoteGATTCharacteristic
{
pub
fn
new_inherited
(
service
:
&
BluetoothRemoteGATTService
uuid
:
DOMString
properties
:
&
BluetoothCharacteristicProperties
instance_id
:
String
)
-
>
BluetoothRemoteGATTCharacteristic
{
BluetoothRemoteGATTCharacteristic
{
eventtarget
:
EventTarget
:
:
new_inherited
(
)
service
:
Dom
:
:
from_ref
(
service
)
uuid
:
uuid
properties
:
Dom
:
:
from_ref
(
properties
)
value
:
DomRefCell
:
:
new
(
None
)
instance_id
:
instance_id
}
}
pub
fn
new
(
global
:
&
GlobalScope
service
:
&
BluetoothRemoteGATTService
uuid
:
DOMString
properties
:
&
BluetoothCharacteristicProperties
instanceID
:
String
)
-
>
DomRoot
<
BluetoothRemoteGATTCharacteristic
>
{
reflect_dom_object
(
Box
:
:
new
(
BluetoothRemoteGATTCharacteristic
:
:
new_inherited
(
service
uuid
properties
instanceID
)
)
global
BluetoothRemoteGATTCharacteristicBinding
:
:
Wrap
)
}
fn
get_bluetooth_thread
(
&
self
)
-
>
IpcSender
<
BluetoothRequest
>
{
self
.
global
(
)
.
as_window
(
)
.
bluetooth_thread
(
)
}
fn
get_instance_id
(
&
self
)
-
>
String
{
self
.
instance_id
.
clone
(
)
}
}
impl
BluetoothRemoteGATTCharacteristicMethods
for
BluetoothRemoteGATTCharacteristic
{
fn
Properties
(
&
self
)
-
>
DomRoot
<
BluetoothCharacteristicProperties
>
{
DomRoot
:
:
from_ref
(
&
self
.
properties
)
}
fn
Service
(
&
self
)
-
>
DomRoot
<
BluetoothRemoteGATTService
>
{
DomRoot
:
:
from_ref
(
&
self
.
service
)
}
fn
Uuid
(
&
self
)
-
>
DOMString
{
self
.
uuid
.
clone
(
)
}
#
[
allow
(
unrooted_must_root
)
]
fn
GetDescriptor
(
&
self
descriptor
:
BluetoothDescriptorUUID
)
-
>
Rc
<
Promise
>
{
get_gatt_children
(
self
true
BluetoothUUID
:
:
descriptor
Some
(
descriptor
)
self
.
get_instance_id
(
)
self
.
Service
(
)
.
Device
(
)
.
get_gatt
(
)
.
Connected
(
)
GATTType
:
:
Descriptor
)
}
#
[
allow
(
unrooted_must_root
)
]
fn
GetDescriptors
(
&
self
descriptor
:
Option
<
BluetoothDescriptorUUID
>
)
-
>
Rc
<
Promise
>
{
get_gatt_children
(
self
false
BluetoothUUID
:
:
descriptor
descriptor
self
.
get_instance_id
(
)
self
.
Service
(
)
.
Device
(
)
.
get_gatt
(
)
.
Connected
(
)
GATTType
:
:
Descriptor
)
}
fn
GetValue
(
&
self
)
-
>
Option
<
ByteString
>
{
self
.
value
.
borrow
(
)
.
clone
(
)
}
#
[
allow
(
unrooted_must_root
)
]
fn
ReadValue
(
&
self
)
-
>
Rc
<
Promise
>
{
let
p
=
Promise
:
:
new
(
&
self
.
global
(
)
)
;
if
uuid_is_blocklisted
(
self
.
uuid
.
as_ref
(
)
Blocklist
:
:
Reads
)
{
p
.
reject_error
(
Security
)
;
return
p
;
}
if
!
self
.
Service
(
)
.
Device
(
)
.
get_gatt
(
)
.
Connected
(
)
{
p
.
reject_error
(
Network
)
;
return
p
;
}
if
!
self
.
Properties
(
)
.
Read
(
)
{
p
.
reject_error
(
NotSupported
)
;
return
p
;
}
let
sender
=
response_async
(
&
p
self
)
;
self
.
get_bluetooth_thread
(
)
.
send
(
BluetoothRequest
:
:
ReadValue
(
self
.
get_instance_id
(
)
sender
)
)
.
unwrap
(
)
;
return
p
;
}
#
[
allow
(
unrooted_must_root
)
]
fn
WriteValue
(
&
self
value
:
Vec
<
u8
>
)
-
>
Rc
<
Promise
>
{
let
p
=
Promise
:
:
new
(
&
self
.
global
(
)
)
;
if
uuid_is_blocklisted
(
self
.
uuid
.
as_ref
(
)
Blocklist
:
:
Writes
)
{
p
.
reject_error
(
Security
)
;
return
p
;
}
if
value
.
len
(
)
>
MAXIMUM_ATTRIBUTE_LENGTH
{
p
.
reject_error
(
InvalidModification
)
;
return
p
;
}
if
!
self
.
Service
(
)
.
Device
(
)
.
get_gatt
(
)
.
Connected
(
)
{
p
.
reject_error
(
Network
)
;
return
p
;
}
if
!
(
self
.
Properties
(
)
.
Write
(
)
|
|
self
.
Properties
(
)
.
WriteWithoutResponse
(
)
|
|
self
.
Properties
(
)
.
AuthenticatedSignedWrites
(
)
)
{
p
.
reject_error
(
NotSupported
)
;
return
p
;
}
let
sender
=
response_async
(
&
p
self
)
;
self
.
get_bluetooth_thread
(
)
.
send
(
BluetoothRequest
:
:
WriteValue
(
self
.
get_instance_id
(
)
value
sender
)
)
.
unwrap
(
)
;
return
p
;
}
#
[
allow
(
unrooted_must_root
)
]
fn
StartNotifications
(
&
self
)
-
>
Rc
<
Promise
>
{
let
p
=
Promise
:
:
new
(
&
self
.
global
(
)
)
;
if
uuid_is_blocklisted
(
self
.
uuid
.
as_ref
(
)
Blocklist
:
:
Reads
)
{
p
.
reject_error
(
Security
)
;
return
p
;
}
if
!
self
.
Service
(
)
.
Device
(
)
.
get_gatt
(
)
.
Connected
(
)
{
p
.
reject_error
(
Network
)
;
return
p
;
}
if
!
(
self
.
Properties
(
)
.
Notify
(
)
|
|
self
.
Properties
(
)
.
Indicate
(
)
)
{
p
.
reject_error
(
NotSupported
)
;
return
p
;
}
let
sender
=
response_async
(
&
p
self
)
;
self
.
get_bluetooth_thread
(
)
.
send
(
BluetoothRequest
:
:
EnableNotification
(
self
.
get_instance_id
(
)
true
sender
)
)
.
unwrap
(
)
;
return
p
;
}
#
[
allow
(
unrooted_must_root
)
]
fn
StopNotifications
(
&
self
)
-
>
Rc
<
Promise
>
{
let
p
=
Promise
:
:
new
(
&
self
.
global
(
)
)
;
let
sender
=
response_async
(
&
p
self
)
;
self
.
get_bluetooth_thread
(
)
.
send
(
BluetoothRequest
:
:
EnableNotification
(
self
.
get_instance_id
(
)
false
sender
)
)
.
unwrap
(
)
;
return
p
;
}
event_handler
!
(
characteristicvaluechanged
GetOncharacteristicvaluechanged
SetOncharacteristicvaluechanged
)
;
}
impl
AsyncBluetoothListener
for
BluetoothRemoteGATTCharacteristic
{
fn
handle_response
(
&
self
response
:
BluetoothResponse
promise
:
&
Rc
<
Promise
>
)
{
let
device
=
self
.
Service
(
)
.
Device
(
)
;
match
response
{
BluetoothResponse
:
:
GetDescriptors
(
descriptors_vec
single
)
=
>
{
if
single
{
promise
.
resolve_native
(
&
device
.
get_or_create_descriptor
(
&
descriptors_vec
[
0
]
&
self
)
)
;
return
;
}
let
mut
descriptors
=
vec
!
(
)
;
for
descriptor
in
descriptors_vec
{
let
bt_descriptor
=
device
.
get_or_create_descriptor
(
&
descriptor
&
self
)
;
descriptors
.
push
(
bt_descriptor
)
;
}
promise
.
resolve_native
(
&
descriptors
)
;
}
BluetoothResponse
:
:
ReadValue
(
result
)
=
>
{
let
value
=
ByteString
:
:
new
(
result
)
;
*
self
.
value
.
borrow_mut
(
)
=
Some
(
value
.
clone
(
)
)
;
self
.
upcast
:
:
<
EventTarget
>
(
)
.
fire_bubbling_event
(
atom
!
(
"
characteristicvaluechanged
"
)
)
;
promise
.
resolve_native
(
&
value
)
;
}
BluetoothResponse
:
:
WriteValue
(
result
)
=
>
{
*
self
.
value
.
borrow_mut
(
)
=
Some
(
ByteString
:
:
new
(
result
)
)
;
promise
.
resolve_native
(
&
(
)
)
;
}
BluetoothResponse
:
:
EnableNotification
(
_result
)
=
>
{
promise
.
resolve_native
(
self
)
;
}
_
=
>
promise
.
reject_error
(
Error
:
:
Type
(
"
Something
went
wrong
.
.
.
"
.
to_owned
(
)
)
)
}
}
}
