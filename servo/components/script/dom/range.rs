use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeBinding
:
:
NodeConstants
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeBinding
:
:
NodeMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
RangeBinding
:
:
{
self
RangeConstants
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
RangeBinding
:
:
RangeMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
WindowBinding
:
:
WindowMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
InheritTypes
:
:
NodeCast
;
use
dom
:
:
bindings
:
:
error
:
:
{
Error
ErrorResult
Fallible
}
;
use
dom
:
:
bindings
:
:
global
:
:
GlobalRef
;
use
dom
:
:
bindings
:
:
js
:
:
{
JS
Root
}
;
use
dom
:
:
bindings
:
:
utils
:
:
{
Reflector
reflect_dom_object
}
;
use
dom
:
:
document
:
:
{
Document
DocumentHelpers
}
;
use
dom
:
:
node
:
:
{
Node
NodeHelpers
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
cmp
:
:
{
Ord
Ordering
PartialEq
PartialOrd
}
;
use
std
:
:
rc
:
:
Rc
;
#
[
dom_struct
]
pub
struct
Range
{
reflector_
:
Reflector
inner
:
Rc
<
RefCell
<
RangeInner
>
>
}
impl
Range
{
fn
new_inherited
(
start_container
:
&
Node
start_offset
:
u32
end_container
:
&
Node
end_offset
:
u32
)
-
>
Range
{
Range
{
reflector_
:
Reflector
:
:
new
(
)
inner
:
Rc
:
:
new
(
RefCell
:
:
new
(
RangeInner
:
:
new
(
BoundaryPoint
:
:
new
(
start_container
start_offset
)
BoundaryPoint
:
:
new
(
end_container
end_offset
)
)
)
)
}
}
pub
fn
new_with_doc
(
document
:
&
Document
)
-
>
Root
<
Range
>
{
let
root
=
NodeCast
:
:
from_ref
(
document
)
;
Range
:
:
new
(
document
root
0
root
0
)
}
pub
fn
new
(
document
:
&
Document
start_container
:
&
Node
start_offset
:
u32
end_container
:
&
Node
end_offset
:
u32
)
-
>
Root
<
Range
>
{
let
window
=
document
.
window
(
)
;
reflect_dom_object
(
box
Range
:
:
new_inherited
(
start_container
start_offset
end_container
end_offset
)
GlobalRef
:
:
Window
(
window
.
r
(
)
)
RangeBinding
:
:
Wrap
)
}
pub
fn
Constructor
(
global
:
GlobalRef
)
-
>
Fallible
<
Root
<
Range
>
>
{
let
document
=
global
.
as_window
(
)
.
Document
(
)
;
Ok
(
Range
:
:
new_with_doc
(
document
.
r
(
)
)
)
}
}
pub
trait
RangeHelpers
<
'
a
>
{
fn
inner
(
self
)
-
>
&
'
a
Rc
<
RefCell
<
RangeInner
>
>
;
}
impl
<
'
a
>
RangeHelpers
<
'
a
>
for
&
'
a
Range
{
fn
inner
(
self
)
-
>
&
'
a
Rc
<
RefCell
<
RangeInner
>
>
{
&
self
.
inner
}
}
impl
<
'
a
>
RangeMethods
for
&
'
a
Range
{
fn
StartContainer
(
self
)
-
>
Root
<
Node
>
{
self
.
inner
(
)
.
borrow
(
)
.
start
.
node
(
)
}
fn
StartOffset
(
self
)
-
>
u32
{
self
.
inner
(
)
.
borrow
(
)
.
start
.
offset
}
fn
EndContainer
(
self
)
-
>
Root
<
Node
>
{
self
.
inner
(
)
.
borrow
(
)
.
end
.
node
(
)
}
fn
EndOffset
(
self
)
-
>
u32
{
self
.
inner
(
)
.
borrow
(
)
.
end
.
offset
}
fn
Collapsed
(
self
)
-
>
bool
{
let
inner
=
self
.
inner
(
)
.
borrow
(
)
;
inner
.
start
=
=
inner
.
end
}
fn
CommonAncestorContainer
(
self
)
-
>
Root
<
Node
>
{
self
.
inner
(
)
.
borrow
(
)
.
common_ancestor_container
(
)
}
fn
SetStart
(
self
node
:
&
Node
offset
:
u32
)
-
>
ErrorResult
{
if
node
.
is_doctype
(
)
{
Err
(
Error
:
:
InvalidNodeType
)
}
else
if
offset
>
node
.
len
(
)
{
Err
(
Error
:
:
IndexSize
)
}
else
{
self
.
inner
(
)
.
borrow_mut
(
)
.
set_start
(
node
offset
)
;
Ok
(
(
)
)
}
}
fn
SetEnd
(
self
node
:
&
Node
offset
:
u32
)
-
>
ErrorResult
{
if
node
.
is_doctype
(
)
{
Err
(
Error
:
:
InvalidNodeType
)
}
else
if
offset
>
node
.
len
(
)
{
Err
(
Error
:
:
IndexSize
)
}
else
{
self
.
inner
(
)
.
borrow_mut
(
)
.
set_end
(
node
offset
)
;
Ok
(
(
)
)
}
}
fn
SetStartBefore
(
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
self
.
SetStart
(
parent
.
r
(
)
node
.
index
(
)
)
}
fn
SetStartAfter
(
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
self
.
SetStart
(
parent
.
r
(
)
node
.
index
(
)
+
1
)
}
fn
SetEndBefore
(
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
self
.
SetEnd
(
parent
.
r
(
)
node
.
index
(
)
)
}
fn
SetEndAfter
(
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
self
.
SetEnd
(
parent
.
r
(
)
node
.
index
(
)
+
1
)
}
fn
Collapse
(
self
to_start
:
bool
)
{
self
.
inner
(
)
.
borrow_mut
(
)
.
collapse
(
to_start
)
;
}
fn
SelectNode
(
self
node
:
&
Node
)
-
>
ErrorResult
{
self
.
inner
(
)
.
borrow_mut
(
)
.
select_node
(
node
)
}
fn
SelectNodeContents
(
self
node
:
&
Node
)
-
>
ErrorResult
{
self
.
inner
(
)
.
borrow_mut
(
)
.
select_node_contents
(
node
)
}
fn
CompareBoundaryPoints
(
self
how
:
u16
source_range
:
&
Range
)
-
>
Fallible
<
i16
>
{
if
how
>
RangeConstants
:
:
END_TO_START
{
return
Err
(
Error
:
:
NotSupported
)
;
}
let
this_inner
=
self
.
inner
(
)
.
borrow
(
)
;
let
other_inner
=
source_range
.
inner
(
)
.
borrow
(
)
;
let
this_start_node
=
this_inner
.
start
.
node
(
)
;
let
other_start_node
=
other_inner
.
start
.
node
(
)
;
let
this_root
=
this_start_node
.
r
(
)
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
let
other_root
=
other_start_node
.
r
(
)
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
if
this_root
!
=
other_root
{
return
Err
(
Error
:
:
WrongDocument
)
;
}
let
(
this_point
other_point
)
=
match
how
{
RangeConstants
:
:
START_TO_START
=
>
{
(
&
this_inner
.
start
&
other_inner
.
start
)
}
RangeConstants
:
:
START_TO_END
=
>
{
(
&
this_inner
.
end
&
other_inner
.
start
)
}
RangeConstants
:
:
END_TO_END
=
>
{
(
&
this_inner
.
end
&
other_inner
.
end
)
}
RangeConstants
:
:
END_TO_START
=
>
{
(
&
this_inner
.
start
&
other_inner
.
end
)
}
_
=
>
unreachable
!
(
)
}
;
match
this_point
.
partial_cmp
(
other_point
)
.
unwrap
(
)
{
Ordering
:
:
Less
=
>
Ok
(
-
1
)
Ordering
:
:
Equal
=
>
Ok
(
0
)
Ordering
:
:
Greater
=
>
Ok
(
1
)
}
}
fn
CloneRange
(
self
)
-
>
Root
<
Range
>
{
let
inner
=
self
.
inner
(
)
.
borrow
(
)
;
let
start
=
&
inner
.
start
;
let
end
=
&
inner
.
end
;
let
start_node
=
start
.
node
(
)
;
let
owner_doc
=
NodeCast
:
:
from_ref
(
start_node
.
r
(
)
)
.
owner_doc
(
)
;
Range
:
:
new
(
owner_doc
.
r
(
)
start_node
.
r
(
)
start
.
offset
end
.
node
(
)
.
r
(
)
end
.
offset
)
}
fn
IsPointInRange
(
self
node
:
&
Node
offset
:
u32
)
-
>
Fallible
<
bool
>
{
match
self
.
inner
(
)
.
borrow
(
)
.
compare_point
(
node
offset
)
{
Ok
(
Ordering
:
:
Less
)
=
>
Ok
(
false
)
Ok
(
Ordering
:
:
Equal
)
=
>
Ok
(
true
)
Ok
(
Ordering
:
:
Greater
)
=
>
Ok
(
false
)
Err
(
Error
:
:
WrongDocument
)
=
>
{
Ok
(
false
)
}
Err
(
error
)
=
>
Err
(
error
)
}
}
fn
ComparePoint
(
self
node
:
&
Node
offset
:
u32
)
-
>
Fallible
<
i16
>
{
self
.
inner
(
)
.
borrow
(
)
.
compare_point
(
node
offset
)
.
map
(
|
order
|
{
match
order
{
Ordering
:
:
Less
=
>
-
1
Ordering
:
:
Equal
=
>
0
Ordering
:
:
Greater
=
>
1
}
}
)
}
fn
IntersectsNode
(
self
node
:
&
Node
)
-
>
bool
{
let
inner
=
self
.
inner
(
)
.
borrow
(
)
;
let
start
=
&
inner
.
start
;
let
start_node
=
start
.
node
(
)
;
let
start_offset
=
start
.
offset
;
let
start_node_root
=
start_node
.
r
(
)
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
let
node_root
=
node
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
if
start_node_root
!
=
node_root
{
return
false
;
}
let
parent
=
match
node
.
GetParentNode
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
{
return
true
;
}
}
;
let
offset
=
node
.
index
(
)
;
let
end
=
&
inner
.
end
;
let
end_node
=
end
.
node
(
)
;
let
end_offset
=
end
.
offset
;
match
(
bp_position
(
parent
.
r
(
)
offset
+
1
start_node
.
r
(
)
start_offset
)
.
unwrap
(
)
bp_position
(
parent
.
r
(
)
offset
end_node
.
r
(
)
end_offset
)
.
unwrap
(
)
)
{
(
Ordering
:
:
Greater
Ordering
:
:
Less
)
=
>
{
true
}
_
=
>
{
false
}
}
}
fn
Detach
(
self
)
{
}
}
#
[
jstraceable
]
#
[
must_root
]
#
[
privatize
]
pub
struct
RangeInner
{
start
:
BoundaryPoint
end
:
BoundaryPoint
}
impl
RangeInner
{
fn
new
(
start
:
BoundaryPoint
end
:
BoundaryPoint
)
-
>
RangeInner
{
RangeInner
{
start
:
start
end
:
end
}
}
fn
common_ancestor_container
(
&
self
)
-
>
Root
<
Node
>
{
let
start_container
=
self
.
start
.
node
(
)
;
let
end_container
=
self
.
end
.
node
(
)
;
for
container
in
start_container
.
r
(
)
.
inclusive_ancestors
(
)
{
if
container
.
r
(
)
.
is_inclusive_ancestor_of
(
end_container
.
r
(
)
)
{
return
container
;
}
}
unreachable
!
(
)
;
}
pub
fn
set_start
(
&
mut
self
bp_node
:
&
Node
bp_offset
:
u32
)
{
let
end_node
=
self
.
end
.
node
(
)
;
let
end_offset
=
self
.
end
.
offset
;
match
bp_position
(
bp_node
bp_offset
end_node
.
r
(
)
end_offset
)
{
None
|
Some
(
Ordering
:
:
Greater
)
=
>
{
self
.
end
.
set
(
bp_node
bp_offset
)
;
}
_
=
>
{
}
}
;
self
.
start
.
set
(
bp_node
bp_offset
)
;
}
pub
fn
set_end
(
&
mut
self
bp_node
:
&
Node
bp_offset
:
u32
)
{
let
start_node
=
self
.
start
.
node
(
)
;
let
start_offset
=
self
.
start
.
offset
;
match
bp_position
(
bp_node
bp_offset
start_node
.
r
(
)
start_offset
)
{
None
|
Some
(
Ordering
:
:
Less
)
=
>
{
self
.
start
.
set
(
bp_node
bp_offset
)
;
}
_
=
>
{
}
}
;
self
.
end
.
set
(
bp_node
bp_offset
)
;
}
fn
collapse
(
&
mut
self
to_start
:
bool
)
{
if
to_start
{
let
start_node
=
self
.
start
.
node
(
)
;
self
.
end
.
set
(
start_node
.
r
(
)
self
.
start
.
offset
)
;
}
else
{
let
end_node
=
self
.
end
.
node
(
)
;
self
.
start
.
set
(
end_node
.
r
(
)
self
.
end
.
offset
)
;
}
}
fn
select_node
(
&
mut
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
let
index
=
node
.
index
(
)
;
self
.
start
.
set
(
parent
.
r
(
)
index
)
;
self
.
end
.
set
(
parent
.
r
(
)
index
+
1
)
;
Ok
(
(
)
)
}
fn
select_node_contents
(
&
mut
self
node
:
&
Node
)
-
>
ErrorResult
{
if
node
.
is_doctype
(
)
{
return
Err
(
Error
:
:
InvalidNodeType
)
;
}
let
length
=
node
.
len
(
)
;
self
.
start
.
set
(
node
0
)
;
self
.
end
.
set
(
node
length
)
;
Ok
(
(
)
)
}
fn
compare_point
(
&
self
node
:
&
Node
offset
:
u32
)
-
>
Fallible
<
Ordering
>
{
let
start
=
&
self
.
start
;
let
start_node
=
start
.
node
(
)
;
let
start_offset
=
start
.
offset
;
let
start_node_root
=
start_node
.
r
(
)
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
let
node_root
=
node
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
if
start_node_root
!
=
node_root
{
return
Err
(
Error
:
:
WrongDocument
)
;
}
if
node
.
is_doctype
(
)
{
return
Err
(
Error
:
:
InvalidNodeType
)
;
}
if
offset
>
node
.
len
(
)
{
return
Err
(
Error
:
:
IndexSize
)
;
}
if
let
Ordering
:
:
Less
=
bp_position
(
node
offset
start_node
.
r
(
)
start_offset
)
.
unwrap
(
)
{
return
Ok
(
Ordering
:
:
Less
)
;
}
let
end
=
&
self
.
end
;
let
end_node
=
end
.
node
(
)
;
let
end_offset
=
end
.
offset
;
if
let
Ordering
:
:
Greater
=
bp_position
(
node
offset
end_node
.
r
(
)
end_offset
)
.
unwrap
(
)
{
return
Ok
(
Ordering
:
:
Greater
)
;
}
Ok
(
Ordering
:
:
Equal
)
}
}
#
[
jstraceable
]
#
[
must_root
]
#
[
privatize
]
pub
struct
BoundaryPoint
{
node
:
JS
<
Node
>
offset
:
u32
}
impl
BoundaryPoint
{
fn
new
(
node
:
&
Node
offset
:
u32
)
-
>
BoundaryPoint
{
debug_assert
!
(
!
node
.
is_doctype
(
)
)
;
debug_assert
!
(
offset
<
=
node
.
len
(
)
)
;
BoundaryPoint
{
node
:
JS
:
:
from_ref
(
node
)
offset
:
offset
}
}
pub
fn
node
(
&
self
)
-
>
Root
<
Node
>
{
self
.
node
.
root
(
)
}
pub
fn
offset
(
&
self
)
-
>
u32
{
self
.
offset
}
fn
set
(
&
mut
self
node
:
&
Node
offset
:
u32
)
{
debug_assert
!
(
!
node
.
is_doctype
(
)
)
;
debug_assert
!
(
offset
<
=
node
.
len
(
)
)
;
self
.
node
=
JS
:
:
from_ref
(
node
)
;
self
.
offset
=
offset
;
}
}
#
[
allow
(
unrooted_must_root
)
]
impl
PartialOrd
for
BoundaryPoint
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
bp_position
(
self
.
node
(
)
.
r
(
)
self
.
offset
other
.
node
(
)
.
r
(
)
other
.
offset
)
}
}
#
[
allow
(
unrooted_must_root
)
]
impl
PartialEq
for
BoundaryPoint
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
node
(
)
=
=
other
.
node
(
)
&
&
self
.
offset
=
=
other
.
offset
}
}
fn
bp_position
(
a_node
:
&
Node
a_offset
:
u32
b_node
:
&
Node
b_offset
:
u32
)
-
>
Option
<
Ordering
>
{
if
a_node
as
*
const
Node
=
=
b_node
as
*
const
Node
{
return
Some
(
a_offset
.
cmp
(
&
b_offset
)
)
;
}
let
position
=
b_node
.
CompareDocumentPosition
(
a_node
)
;
if
position
&
NodeConstants
:
:
DOCUMENT_POSITION_DISCONNECTED
!
=
0
{
None
}
else
if
position
&
NodeConstants
:
:
DOCUMENT_POSITION_FOLLOWING
!
=
0
{
match
bp_position
(
b_node
b_offset
a_node
a_offset
)
.
unwrap
(
)
{
Ordering
:
:
Less
=
>
Some
(
Ordering
:
:
Greater
)
Ordering
:
:
Greater
=
>
Some
(
Ordering
:
:
Less
)
Ordering
:
:
Equal
=
>
unreachable
!
(
)
}
}
else
if
position
&
NodeConstants
:
:
DOCUMENT_POSITION_CONTAINS
!
=
0
{
let
mut
b_ancestors
=
b_node
.
inclusive_ancestors
(
)
;
let
ref
child
=
b_ancestors
.
find
(
|
child
|
{
child
.
r
(
)
.
GetParentNode
(
)
.
unwrap
(
)
.
r
(
)
=
=
a_node
}
)
.
unwrap
(
)
;
if
child
.
r
(
)
.
index
(
)
<
a_offset
{
Some
(
Ordering
:
:
Greater
)
}
else
{
Some
(
Ordering
:
:
Less
)
}
}
else
{
Some
(
Ordering
:
:
Less
)
}
}
