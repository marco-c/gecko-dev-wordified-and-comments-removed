use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
CharacterDataBinding
:
:
CharacterDataMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeBinding
:
:
NodeConstants
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeBinding
:
:
NodeMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeListBinding
:
:
NodeListMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
RangeBinding
:
:
RangeMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
RangeBinding
:
:
{
self
RangeConstants
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
TextBinding
:
:
TextMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
WindowBinding
:
:
WindowMethods
;
use
dom
:
:
bindings
:
:
error
:
:
{
Error
ErrorResult
Fallible
}
;
use
dom
:
:
bindings
:
:
global
:
:
GlobalRef
;
use
dom
:
:
bindings
:
:
inheritance
:
:
Castable
;
use
dom
:
:
bindings
:
:
inheritance
:
:
{
CharacterDataTypeId
NodeTypeId
}
;
use
dom
:
:
bindings
:
:
js
:
:
{
JS
MutHeap
Root
RootedReference
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
Reflector
reflect_dom_object
}
;
use
dom
:
:
characterdata
:
:
CharacterData
;
use
dom
:
:
document
:
:
Document
;
use
dom
:
:
documentfragment
:
:
DocumentFragment
;
use
dom
:
:
node
:
:
Node
;
use
dom
:
:
text
:
:
Text
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
cmp
:
:
{
Ord
Ordering
PartialEq
PartialOrd
}
;
use
util
:
:
str
:
:
DOMString
;
#
[
dom_struct
]
pub
struct
Range
{
reflector_
:
Reflector
start
:
BoundaryPoint
end
:
BoundaryPoint
}
impl
Range
{
fn
new_inherited
(
start_container
:
&
Node
start_offset
:
u32
end_container
:
&
Node
end_offset
:
u32
)
-
>
Range
{
Range
{
reflector_
:
Reflector
:
:
new
(
)
start
:
BoundaryPoint
:
:
new
(
start_container
start_offset
)
end
:
BoundaryPoint
:
:
new
(
end_container
end_offset
)
}
}
pub
fn
new_with_doc
(
document
:
&
Document
)
-
>
Root
<
Range
>
{
let
root
=
document
.
upcast
(
)
;
Range
:
:
new
(
document
root
0
root
0
)
}
pub
fn
new
(
document
:
&
Document
start_container
:
&
Node
start_offset
:
u32
end_container
:
&
Node
end_offset
:
u32
)
-
>
Root
<
Range
>
{
reflect_dom_object
(
box
Range
:
:
new_inherited
(
start_container
start_offset
end_container
end_offset
)
GlobalRef
:
:
Window
(
document
.
window
(
)
)
RangeBinding
:
:
Wrap
)
}
pub
fn
Constructor
(
global
:
GlobalRef
)
-
>
Fallible
<
Root
<
Range
>
>
{
let
document
=
global
.
as_window
(
)
.
Document
(
)
;
Ok
(
Range
:
:
new_with_doc
(
document
.
r
(
)
)
)
}
fn
contains
(
&
self
node
:
&
Node
)
-
>
bool
{
match
(
bp_position
(
node
0
&
self
.
StartContainer
(
)
self
.
StartOffset
(
)
)
bp_position
(
node
node
.
len
(
)
&
self
.
EndContainer
(
)
self
.
EndOffset
(
)
)
)
{
(
Some
(
Ordering
:
:
Greater
)
Some
(
Ordering
:
:
Less
)
)
=
>
true
_
=
>
false
}
}
fn
partially_contains
(
&
self
node
:
&
Node
)
-
>
bool
{
self
.
StartContainer
(
)
.
inclusive_ancestors
(
)
.
any
(
|
n
|
&
*
n
=
=
node
)
!
=
self
.
EndContainer
(
)
.
inclusive_ancestors
(
)
.
any
(
|
n
|
&
*
n
=
=
node
)
}
fn
contained_children
(
&
self
)
-
>
Fallible
<
(
Option
<
Root
<
Node
>
>
Option
<
Root
<
Node
>
>
Vec
<
Root
<
Node
>
>
)
>
{
let
start_node
=
self
.
StartContainer
(
)
;
let
end_node
=
self
.
EndContainer
(
)
;
let
common_ancestor
=
self
.
CommonAncestorContainer
(
)
;
let
first_contained_child
=
if
start_node
.
is_inclusive_ancestor_of
(
end_node
.
r
(
)
)
{
None
}
else
{
common_ancestor
.
children
(
)
.
find
(
|
node
|
Range
:
:
partially_contains
(
self
node
)
)
}
;
let
last_contained_child
=
if
end_node
.
is_inclusive_ancestor_of
(
start_node
.
r
(
)
)
{
None
}
else
{
common_ancestor
.
rev_children
(
)
.
find
(
|
node
|
Range
:
:
partially_contains
(
self
node
)
)
}
;
let
contained_children
:
Vec
<
Root
<
Node
>
>
=
common_ancestor
.
children
(
)
.
filter
(
|
n
|
Range
:
:
contains
(
self
n
)
)
.
collect
(
)
;
if
contained_children
.
iter
(
)
.
any
(
|
n
|
n
.
is_doctype
(
)
)
{
return
Err
(
Error
:
:
HierarchyRequest
)
;
}
Ok
(
(
first_contained_child
last_contained_child
contained_children
)
)
}
pub
fn
set_start
(
&
self
node
:
&
Node
offset
:
u32
)
{
self
.
start
.
set
(
node
offset
)
;
if
!
(
self
.
start
<
=
self
.
end
)
{
self
.
end
.
set
(
node
offset
)
;
}
}
pub
fn
set_end
(
&
self
node
:
&
Node
offset
:
u32
)
{
self
.
end
.
set
(
node
offset
)
;
if
!
(
self
.
end
>
=
self
.
start
)
{
self
.
start
.
set
(
node
offset
)
;
}
}
fn
compare_point
(
&
self
node
:
&
Node
offset
:
u32
)
-
>
Fallible
<
Ordering
>
{
let
start_node
=
self
.
StartContainer
(
)
;
let
start_node_root
=
start_node
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
let
node_root
=
node
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
if
start_node_root
!
=
node_root
{
return
Err
(
Error
:
:
WrongDocument
)
;
}
if
node
.
is_doctype
(
)
{
return
Err
(
Error
:
:
InvalidNodeType
)
;
}
if
offset
>
node
.
len
(
)
{
return
Err
(
Error
:
:
IndexSize
)
;
}
if
let
Ordering
:
:
Less
=
bp_position
(
node
offset
&
start_node
self
.
StartOffset
(
)
)
.
unwrap
(
)
{
return
Ok
(
Ordering
:
:
Less
)
;
}
if
let
Ordering
:
:
Greater
=
bp_position
(
node
offset
&
self
.
EndContainer
(
)
self
.
EndOffset
(
)
)
.
unwrap
(
)
{
return
Ok
(
Ordering
:
:
Greater
)
;
}
Ok
(
Ordering
:
:
Equal
)
}
}
impl
RangeMethods
for
Range
{
fn
StartContainer
(
&
self
)
-
>
Root
<
Node
>
{
self
.
start
.
node
.
get
(
)
}
fn
StartOffset
(
&
self
)
-
>
u32
{
self
.
start
.
offset
.
get
(
)
}
fn
EndContainer
(
&
self
)
-
>
Root
<
Node
>
{
self
.
end
.
node
.
get
(
)
}
fn
EndOffset
(
&
self
)
-
>
u32
{
self
.
end
.
offset
.
get
(
)
}
fn
Collapsed
(
&
self
)
-
>
bool
{
self
.
start
=
=
self
.
end
}
fn
CommonAncestorContainer
(
&
self
)
-
>
Root
<
Node
>
{
let
end_container
=
self
.
EndContainer
(
)
;
for
container
in
self
.
StartContainer
(
)
.
inclusive_ancestors
(
)
{
if
container
.
is_inclusive_ancestor_of
(
&
end_container
)
{
return
container
;
}
}
unreachable
!
(
)
;
}
fn
SetStart
(
&
self
node
:
&
Node
offset
:
u32
)
-
>
ErrorResult
{
if
node
.
is_doctype
(
)
{
Err
(
Error
:
:
InvalidNodeType
)
}
else
if
offset
>
node
.
len
(
)
{
Err
(
Error
:
:
IndexSize
)
}
else
{
self
.
set_start
(
node
offset
)
;
Ok
(
(
)
)
}
}
fn
SetEnd
(
&
self
node
:
&
Node
offset
:
u32
)
-
>
ErrorResult
{
if
node
.
is_doctype
(
)
{
Err
(
Error
:
:
InvalidNodeType
)
}
else
if
offset
>
node
.
len
(
)
{
Err
(
Error
:
:
IndexSize
)
}
else
{
self
.
set_end
(
node
offset
)
;
Ok
(
(
)
)
}
}
fn
SetStartBefore
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
self
.
SetStart
(
parent
.
r
(
)
node
.
index
(
)
)
}
fn
SetStartAfter
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
self
.
SetStart
(
parent
.
r
(
)
node
.
index
(
)
+
1
)
}
fn
SetEndBefore
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
self
.
SetEnd
(
parent
.
r
(
)
node
.
index
(
)
)
}
fn
SetEndAfter
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
self
.
SetEnd
(
parent
.
r
(
)
node
.
index
(
)
+
1
)
}
fn
Collapse
(
&
self
to_start
:
bool
)
{
if
to_start
{
self
.
end
.
set
(
&
self
.
StartContainer
(
)
self
.
StartOffset
(
)
)
;
}
else
{
self
.
start
.
set
(
&
self
.
EndContainer
(
)
self
.
EndOffset
(
)
)
;
}
}
fn
SelectNode
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
let
index
=
node
.
index
(
)
;
self
.
start
.
set
(
&
parent
index
)
;
self
.
end
.
set
(
&
parent
index
+
1
)
;
Ok
(
(
)
)
}
fn
SelectNodeContents
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
if
node
.
is_doctype
(
)
{
return
Err
(
Error
:
:
InvalidNodeType
)
;
}
let
length
=
node
.
len
(
)
;
self
.
start
.
set
(
node
0
)
;
self
.
end
.
set
(
node
length
)
;
Ok
(
(
)
)
}
fn
CompareBoundaryPoints
(
&
self
how
:
u16
other
:
&
Range
)
-
>
Fallible
<
i16
>
{
if
how
>
RangeConstants
:
:
END_TO_START
{
return
Err
(
Error
:
:
NotSupported
)
;
}
let
this_root
=
self
.
StartContainer
(
)
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
let
other_root
=
other
.
StartContainer
(
)
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
if
this_root
!
=
other_root
{
return
Err
(
Error
:
:
WrongDocument
)
;
}
let
(
this_point
other_point
)
=
match
how
{
RangeConstants
:
:
START_TO_START
=
>
{
(
&
self
.
start
&
other
.
start
)
}
RangeConstants
:
:
START_TO_END
=
>
{
(
&
self
.
end
&
other
.
start
)
}
RangeConstants
:
:
END_TO_END
=
>
{
(
&
self
.
end
&
other
.
end
)
}
RangeConstants
:
:
END_TO_START
=
>
{
(
&
self
.
start
&
other
.
end
)
}
_
=
>
unreachable
!
(
)
}
;
match
this_point
.
partial_cmp
(
other_point
)
.
unwrap
(
)
{
Ordering
:
:
Less
=
>
Ok
(
-
1
)
Ordering
:
:
Equal
=
>
Ok
(
0
)
Ordering
:
:
Greater
=
>
Ok
(
1
)
}
}
fn
CloneRange
(
&
self
)
-
>
Root
<
Range
>
{
let
start_node
=
self
.
StartContainer
(
)
;
let
owner_doc
=
start_node
.
owner_doc
(
)
;
Range
:
:
new
(
&
owner_doc
&
start_node
self
.
StartOffset
(
)
&
self
.
EndContainer
(
)
self
.
EndOffset
(
)
)
}
fn
IsPointInRange
(
&
self
node
:
&
Node
offset
:
u32
)
-
>
Fallible
<
bool
>
{
match
self
.
compare_point
(
node
offset
)
{
Ok
(
Ordering
:
:
Less
)
=
>
Ok
(
false
)
Ok
(
Ordering
:
:
Equal
)
=
>
Ok
(
true
)
Ok
(
Ordering
:
:
Greater
)
=
>
Ok
(
false
)
Err
(
Error
:
:
WrongDocument
)
=
>
{
Ok
(
false
)
}
Err
(
error
)
=
>
Err
(
error
)
}
}
fn
ComparePoint
(
&
self
node
:
&
Node
offset
:
u32
)
-
>
Fallible
<
i16
>
{
self
.
compare_point
(
node
offset
)
.
map
(
|
order
|
{
match
order
{
Ordering
:
:
Less
=
>
-
1
Ordering
:
:
Equal
=
>
0
Ordering
:
:
Greater
=
>
1
}
}
)
}
fn
IntersectsNode
(
&
self
node
:
&
Node
)
-
>
bool
{
let
start_node
=
self
.
StartContainer
(
)
;
let
start_node_root
=
self
.
StartContainer
(
)
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
let
node_root
=
node
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
if
start_node_root
!
=
node_root
{
return
false
;
}
let
parent
=
match
node
.
GetParentNode
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
{
return
true
;
}
}
;
let
offset
=
node
.
index
(
)
;
Ordering
:
:
Greater
=
=
bp_position
(
parent
.
r
(
)
offset
+
1
&
start_node
self
.
StartOffset
(
)
)
.
unwrap
(
)
&
&
Ordering
:
:
Less
=
=
bp_position
(
parent
.
r
(
)
offset
&
self
.
EndContainer
(
)
self
.
EndOffset
(
)
)
.
unwrap
(
)
}
fn
CloneContents
(
&
self
)
-
>
Fallible
<
Root
<
DocumentFragment
>
>
{
let
start_node
=
self
.
StartContainer
(
)
;
let
start_offset
=
self
.
StartOffset
(
)
;
let
end_node
=
self
.
EndContainer
(
)
;
let
end_offset
=
self
.
EndOffset
(
)
;
let
fragment
=
DocumentFragment
:
:
new
(
start_node
.
owner_doc
(
)
.
r
(
)
)
;
if
self
.
start
=
=
self
.
end
{
return
Ok
(
fragment
)
;
}
if
end_node
=
=
start_node
{
if
let
Some
(
text
)
=
start_node
.
downcast
:
:
<
CharacterData
>
(
)
{
let
clone
=
start_node
.
CloneNode
(
true
)
;
let
text
=
text
.
SubstringData
(
start_offset
end_offset
-
start_offset
)
;
clone
.
downcast
:
:
<
CharacterData
>
(
)
.
unwrap
(
)
.
SetData
(
text
.
unwrap
(
)
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
return
Ok
(
fragment
)
;
}
}
let
(
first_contained_child
last_contained_child
contained_children
)
=
try
!
(
self
.
contained_children
(
)
)
;
if
let
Some
(
child
)
=
first_contained_child
{
if
let
Some
(
text
)
=
child
.
downcast
:
:
<
CharacterData
>
(
)
{
assert
!
(
child
=
=
start_node
)
;
let
clone
=
start_node
.
CloneNode
(
true
)
;
let
text
=
text
.
SubstringData
(
start_offset
start_node
.
len
(
)
-
start_offset
)
;
clone
.
downcast
:
:
<
CharacterData
>
(
)
.
unwrap
(
)
.
SetData
(
text
.
unwrap
(
)
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
}
else
{
let
clone
=
child
.
CloneNode
(
false
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
let
subrange
=
Range
:
:
new
(
clone
.
owner_doc
(
)
.
r
(
)
start_node
.
r
(
)
start_offset
child
.
r
(
)
child
.
len
(
)
)
;
let
subfragment
=
try
!
(
subrange
.
CloneContents
(
)
)
;
try
!
(
clone
.
AppendChild
(
subfragment
.
upcast
(
)
)
)
;
}
}
for
child
in
contained_children
{
let
clone
=
child
.
CloneNode
(
true
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
}
if
let
Some
(
child
)
=
last_contained_child
{
if
let
Some
(
text
)
=
child
.
downcast
:
:
<
CharacterData
>
(
)
{
assert
!
(
child
=
=
end_node
)
;
let
clone
=
end_node
.
CloneNode
(
true
)
;
let
text
=
text
.
SubstringData
(
0
end_offset
)
;
clone
.
downcast
:
:
<
CharacterData
>
(
)
.
unwrap
(
)
.
SetData
(
text
.
unwrap
(
)
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
}
else
{
let
clone
=
child
.
CloneNode
(
false
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
let
subrange
=
Range
:
:
new
(
clone
.
owner_doc
(
)
.
r
(
)
child
.
r
(
)
0
end_node
.
r
(
)
end_offset
)
;
let
subfragment
=
try
!
(
subrange
.
CloneContents
(
)
)
;
try
!
(
clone
.
AppendChild
(
subfragment
.
upcast
(
)
)
)
;
}
}
Ok
(
fragment
)
}
fn
ExtractContents
(
&
self
)
-
>
Fallible
<
Root
<
DocumentFragment
>
>
{
let
start_node
=
self
.
StartContainer
(
)
;
let
start_offset
=
self
.
StartOffset
(
)
;
let
end_node
=
self
.
EndContainer
(
)
;
let
end_offset
=
self
.
EndOffset
(
)
;
let
fragment
=
DocumentFragment
:
:
new
(
start_node
.
owner_doc
(
)
.
r
(
)
)
;
if
self
.
Collapsed
(
)
{
return
Ok
(
fragment
)
;
}
if
end_node
=
=
start_node
{
if
let
Some
(
end_data
)
=
end_node
.
downcast
:
:
<
CharacterData
>
(
)
{
let
clone
=
end_node
.
CloneNode
(
true
)
;
let
text
=
end_data
.
SubstringData
(
start_offset
end_offset
-
start_offset
)
;
clone
.
downcast
:
:
<
CharacterData
>
(
)
.
unwrap
(
)
.
SetData
(
text
.
unwrap
(
)
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
try
!
(
end_data
.
ReplaceData
(
start_offset
end_offset
-
start_offset
DOMString
:
:
new
(
)
)
)
;
return
Ok
(
fragment
)
;
}
}
let
(
first_contained_child
last_contained_child
contained_children
)
=
try
!
(
self
.
contained_children
(
)
)
;
let
(
new_node
new_offset
)
=
if
start_node
.
is_inclusive_ancestor_of
(
end_node
.
r
(
)
)
{
(
Root
:
:
from_ref
(
start_node
.
r
(
)
)
start_offset
)
}
else
{
let
reference_node
=
start_node
.
ancestors
(
)
.
find
(
|
n
|
n
.
is_inclusive_ancestor_of
(
end_node
.
r
(
)
)
)
.
unwrap
(
)
;
(
reference_node
.
GetParentNode
(
)
.
unwrap
(
)
reference_node
.
index
(
)
+
1
)
}
;
if
let
Some
(
child
)
=
first_contained_child
{
if
let
Some
(
start_data
)
=
child
.
downcast
:
:
<
CharacterData
>
(
)
{
assert
!
(
child
=
=
start_node
)
;
let
clone
=
start_node
.
CloneNode
(
true
)
;
let
text
=
start_data
.
SubstringData
(
start_offset
start_node
.
len
(
)
-
start_offset
)
;
clone
.
downcast
:
:
<
CharacterData
>
(
)
.
unwrap
(
)
.
SetData
(
text
.
unwrap
(
)
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
try
!
(
start_data
.
ReplaceData
(
start_offset
start_node
.
len
(
)
-
start_offset
DOMString
:
:
new
(
)
)
)
;
}
else
{
let
clone
=
child
.
CloneNode
(
false
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
let
subrange
=
Range
:
:
new
(
clone
.
owner_doc
(
)
.
r
(
)
start_node
.
r
(
)
start_offset
child
.
r
(
)
child
.
len
(
)
)
;
let
subfragment
=
try
!
(
subrange
.
ExtractContents
(
)
)
;
try
!
(
clone
.
AppendChild
(
subfragment
.
upcast
(
)
)
)
;
}
}
for
child
in
contained_children
{
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
child
)
)
;
}
if
let
Some
(
child
)
=
last_contained_child
{
if
let
Some
(
end_data
)
=
child
.
downcast
:
:
<
CharacterData
>
(
)
{
assert
!
(
child
=
=
end_node
)
;
let
clone
=
end_node
.
CloneNode
(
true
)
;
let
text
=
end_data
.
SubstringData
(
0
end_offset
)
;
clone
.
downcast
:
:
<
CharacterData
>
(
)
.
unwrap
(
)
.
SetData
(
text
.
unwrap
(
)
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
try
!
(
end_data
.
ReplaceData
(
0
end_offset
DOMString
:
:
new
(
)
)
)
;
}
else
{
let
clone
=
child
.
CloneNode
(
false
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
let
subrange
=
Range
:
:
new
(
clone
.
owner_doc
(
)
.
r
(
)
child
.
r
(
)
0
end_node
.
r
(
)
end_offset
)
;
let
subfragment
=
try
!
(
subrange
.
ExtractContents
(
)
)
;
try
!
(
clone
.
AppendChild
(
subfragment
.
upcast
(
)
)
)
;
}
}
try
!
(
self
.
SetStart
(
new_node
.
r
(
)
new_offset
)
)
;
try
!
(
self
.
SetEnd
(
new_node
.
r
(
)
new_offset
)
)
;
Ok
(
fragment
)
}
fn
Detach
(
&
self
)
{
}
fn
InsertNode
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
let
start_node
=
self
.
StartContainer
(
)
;
let
start_offset
=
self
.
StartOffset
(
)
;
match
start_node
.
type_id
(
)
{
NodeTypeId
:
:
CharacterData
(
CharacterDataTypeId
:
:
Text
)
=
>
(
)
NodeTypeId
:
:
CharacterData
(
_
)
=
>
return
Err
(
Error
:
:
HierarchyRequest
)
_
=
>
(
)
}
let
(
reference_node
parent
)
=
if
start_node
.
type_id
(
)
=
=
NodeTypeId
:
:
CharacterData
(
CharacterDataTypeId
:
:
Text
)
{
let
parent
=
match
start_node
.
GetParentNode
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
return
Err
(
Error
:
:
HierarchyRequest
)
}
;
(
Some
(
Root
:
:
from_ref
(
start_node
.
r
(
)
)
)
parent
)
}
else
{
let
child
=
start_node
.
ChildNodes
(
)
.
Item
(
start_offset
)
;
(
child
Root
:
:
from_ref
(
start_node
.
r
(
)
)
)
}
;
try
!
(
Node
:
:
ensure_pre_insertion_validity
(
node
parent
.
r
(
)
reference_node
.
r
(
)
)
)
;
let
split_text
;
let
reference_node
=
match
start_node
.
downcast
:
:
<
Text
>
(
)
{
Some
(
text
)
=
>
{
split_text
=
try
!
(
text
.
SplitText
(
start_offset
)
)
;
let
new_reference
=
Root
:
:
upcast
:
:
<
Node
>
(
split_text
)
;
assert
!
(
new_reference
.
GetParentNode
(
)
.
r
(
)
=
=
Some
(
parent
.
r
(
)
)
)
;
Some
(
new_reference
)
}
_
=
>
reference_node
}
;
let
reference_node
=
if
Some
(
node
)
=
=
reference_node
.
r
(
)
{
node
.
GetNextSibling
(
)
}
else
{
reference_node
}
;
node
.
remove_self
(
)
;
let
new_offset
=
reference_node
.
r
(
)
.
map_or
(
parent
.
len
(
)
|
node
|
node
.
index
(
)
)
;
let
new_offset
=
new_offset
+
if
node
.
type_id
(
)
=
=
NodeTypeId
:
:
DocumentFragment
{
node
.
len
(
)
}
else
{
1
}
;
try
!
(
Node
:
:
pre_insert
(
node
parent
.
r
(
)
reference_node
.
r
(
)
)
)
;
if
self
.
Collapsed
(
)
{
self
.
set_end
(
parent
.
r
(
)
new_offset
)
;
}
Ok
(
(
)
)
}
fn
SurroundContents
(
&
self
new_parent
:
&
Node
)
-
>
ErrorResult
{
let
start
=
self
.
StartContainer
(
)
;
let
end
=
self
.
EndContainer
(
)
;
if
start
.
inclusive_ancestors
(
)
.
any
(
|
n
|
!
n
.
is_inclusive_ancestor_of
(
end
.
r
(
)
)
&
&
!
n
.
is
:
:
<
Text
>
(
)
)
|
|
end
.
inclusive_ancestors
(
)
.
any
(
|
n
|
!
n
.
is_inclusive_ancestor_of
(
start
.
r
(
)
)
&
&
!
n
.
is
:
:
<
Text
>
(
)
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
match
new_parent
.
type_id
(
)
{
NodeTypeId
:
:
Document
|
NodeTypeId
:
:
DocumentType
|
NodeTypeId
:
:
DocumentFragment
=
>
return
Err
(
Error
:
:
InvalidNodeType
)
_
=
>
(
)
}
let
fragment
=
try
!
(
self
.
ExtractContents
(
)
)
;
Node
:
:
replace_all
(
None
new_parent
)
;
try
!
(
self
.
InsertNode
(
new_parent
)
)
;
try
!
(
new_parent
.
AppendChild
(
fragment
.
upcast
(
)
)
)
;
self
.
SelectNode
(
new_parent
)
}
}
#
[
derive
(
JSTraceable
)
]
#
[
must_root
]
#
[
privatize
]
#
[
derive
(
HeapSizeOf
)
]
pub
struct
BoundaryPoint
{
node
:
MutHeap
<
JS
<
Node
>
>
offset
:
Cell
<
u32
>
}
impl
BoundaryPoint
{
fn
new
(
node
:
&
Node
offset
:
u32
)
-
>
BoundaryPoint
{
debug_assert
!
(
!
node
.
is_doctype
(
)
)
;
debug_assert
!
(
offset
<
=
node
.
len
(
)
)
;
BoundaryPoint
{
node
:
MutHeap
:
:
new
(
node
)
offset
:
Cell
:
:
new
(
offset
)
}
}
fn
set
(
&
self
node
:
&
Node
offset
:
u32
)
{
debug_assert
!
(
!
node
.
is_doctype
(
)
)
;
debug_assert
!
(
offset
<
=
node
.
len
(
)
)
;
self
.
node
.
set
(
node
)
;
self
.
offset
.
set
(
offset
)
;
}
}
#
[
allow
(
unrooted_must_root
)
]
impl
PartialOrd
for
BoundaryPoint
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
bp_position
(
&
self
.
node
.
get
(
)
self
.
offset
.
get
(
)
&
other
.
node
.
get
(
)
other
.
offset
.
get
(
)
)
}
}
#
[
allow
(
unrooted_must_root
)
]
impl
PartialEq
for
BoundaryPoint
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
node
.
get
(
)
=
=
other
.
node
.
get
(
)
&
&
self
.
offset
.
get
(
)
=
=
other
.
offset
.
get
(
)
}
}
fn
bp_position
(
a_node
:
&
Node
a_offset
:
u32
b_node
:
&
Node
b_offset
:
u32
)
-
>
Option
<
Ordering
>
{
if
a_node
as
*
const
Node
=
=
b_node
as
*
const
Node
{
return
Some
(
a_offset
.
cmp
(
&
b_offset
)
)
;
}
let
position
=
b_node
.
CompareDocumentPosition
(
a_node
)
;
if
position
&
NodeConstants
:
:
DOCUMENT_POSITION_DISCONNECTED
!
=
0
{
None
}
else
if
position
&
NodeConstants
:
:
DOCUMENT_POSITION_FOLLOWING
!
=
0
{
match
bp_position
(
b_node
b_offset
a_node
a_offset
)
.
unwrap
(
)
{
Ordering
:
:
Less
=
>
Some
(
Ordering
:
:
Greater
)
Ordering
:
:
Greater
=
>
Some
(
Ordering
:
:
Less
)
Ordering
:
:
Equal
=
>
unreachable
!
(
)
}
}
else
if
position
&
NodeConstants
:
:
DOCUMENT_POSITION_CONTAINS
!
=
0
{
let
mut
b_ancestors
=
b_node
.
inclusive_ancestors
(
)
;
let
child
=
b_ancestors
.
find
(
|
child
|
{
child
.
GetParentNode
(
)
.
unwrap
(
)
.
r
(
)
=
=
a_node
}
)
.
unwrap
(
)
;
if
child
.
index
(
)
<
a_offset
{
Some
(
Ordering
:
:
Greater
)
}
else
{
Some
(
Ordering
:
:
Less
)
}
}
else
{
Some
(
Ordering
:
:
Less
)
}
}
