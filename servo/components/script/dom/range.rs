use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
CharacterDataBinding
:
:
CharacterDataMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeBinding
:
:
NodeConstants
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeBinding
:
:
NodeMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
NodeListBinding
:
:
NodeListMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
RangeBinding
:
:
RangeMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
RangeBinding
:
:
{
self
RangeConstants
}
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
TextBinding
:
:
TextMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
WindowBinding
:
:
WindowMethods
;
use
dom
:
:
bindings
:
:
error
:
:
{
Error
ErrorResult
Fallible
}
;
use
dom
:
:
bindings
:
:
global
:
:
GlobalRef
;
use
dom
:
:
bindings
:
:
inheritance
:
:
Castable
;
use
dom
:
:
bindings
:
:
inheritance
:
:
{
CharacterDataTypeId
NodeTypeId
}
;
use
dom
:
:
bindings
:
:
js
:
:
{
JS
MutHeap
Root
RootedReference
}
;
use
dom
:
:
bindings
:
:
reflector
:
:
{
Reflector
reflect_dom_object
}
;
use
dom
:
:
bindings
:
:
trace
:
:
{
JSTraceable
RootedVec
}
;
use
dom
:
:
bindings
:
:
weakref
:
:
{
WeakRef
WeakRefVec
}
;
use
dom
:
:
characterdata
:
:
CharacterData
;
use
dom
:
:
document
:
:
Document
;
use
dom
:
:
documentfragment
:
:
DocumentFragment
;
use
dom
:
:
node
:
:
{
Node
UnbindContext
}
;
use
dom
:
:
text
:
:
Text
;
use
heapsize
:
:
HeapSizeOf
;
use
js
:
:
jsapi
:
:
JSTracer
;
use
std
:
:
cell
:
:
{
Cell
UnsafeCell
}
;
use
std
:
:
cmp
:
:
{
Ord
Ordering
PartialEq
PartialOrd
}
;
use
util
:
:
str
:
:
DOMString
;
#
[
dom_struct
]
pub
struct
Range
{
reflector_
:
Reflector
start
:
BoundaryPoint
end
:
BoundaryPoint
}
impl
Range
{
fn
new_inherited
(
start_container
:
&
Node
start_offset
:
u32
end_container
:
&
Node
end_offset
:
u32
)
-
>
Range
{
Range
{
reflector_
:
Reflector
:
:
new
(
)
start
:
BoundaryPoint
:
:
new
(
start_container
start_offset
)
end
:
BoundaryPoint
:
:
new
(
end_container
end_offset
)
}
}
pub
fn
new_with_doc
(
document
:
&
Document
)
-
>
Root
<
Range
>
{
let
root
=
document
.
upcast
(
)
;
Range
:
:
new
(
document
root
0
root
0
)
}
pub
fn
new
(
document
:
&
Document
start_container
:
&
Node
start_offset
:
u32
end_container
:
&
Node
end_offset
:
u32
)
-
>
Root
<
Range
>
{
let
range
=
reflect_dom_object
(
box
Range
:
:
new_inherited
(
start_container
start_offset
end_container
end_offset
)
GlobalRef
:
:
Window
(
document
.
window
(
)
)
RangeBinding
:
:
Wrap
)
;
start_container
.
ranges
(
)
.
push
(
WeakRef
:
:
new
(
&
range
)
)
;
if
start_container
!
=
end_container
{
end_container
.
ranges
(
)
.
push
(
WeakRef
:
:
new
(
&
range
)
)
;
}
range
}
pub
fn
Constructor
(
global
:
GlobalRef
)
-
>
Fallible
<
Root
<
Range
>
>
{
let
document
=
global
.
as_window
(
)
.
Document
(
)
;
Ok
(
Range
:
:
new_with_doc
(
document
.
r
(
)
)
)
}
fn
contains
(
&
self
node
:
&
Node
)
-
>
bool
{
match
(
bp_position
(
node
0
&
self
.
StartContainer
(
)
self
.
StartOffset
(
)
)
bp_position
(
node
node
.
len
(
)
&
self
.
EndContainer
(
)
self
.
EndOffset
(
)
)
)
{
(
Some
(
Ordering
:
:
Greater
)
Some
(
Ordering
:
:
Less
)
)
=
>
true
_
=
>
false
}
}
fn
partially_contains
(
&
self
node
:
&
Node
)
-
>
bool
{
self
.
StartContainer
(
)
.
inclusive_ancestors
(
)
.
any
(
|
n
|
&
*
n
=
=
node
)
!
=
self
.
EndContainer
(
)
.
inclusive_ancestors
(
)
.
any
(
|
n
|
&
*
n
=
=
node
)
}
fn
contained_children
(
&
self
)
-
>
Fallible
<
(
Option
<
Root
<
Node
>
>
Option
<
Root
<
Node
>
>
Vec
<
Root
<
Node
>
>
)
>
{
let
start_node
=
self
.
StartContainer
(
)
;
let
end_node
=
self
.
EndContainer
(
)
;
let
common_ancestor
=
self
.
CommonAncestorContainer
(
)
;
let
first_contained_child
=
if
start_node
.
is_inclusive_ancestor_of
(
end_node
.
r
(
)
)
{
None
}
else
{
common_ancestor
.
children
(
)
.
find
(
|
node
|
Range
:
:
partially_contains
(
self
node
)
)
}
;
let
last_contained_child
=
if
end_node
.
is_inclusive_ancestor_of
(
start_node
.
r
(
)
)
{
None
}
else
{
common_ancestor
.
rev_children
(
)
.
find
(
|
node
|
Range
:
:
partially_contains
(
self
node
)
)
}
;
let
contained_children
:
Vec
<
Root
<
Node
>
>
=
common_ancestor
.
children
(
)
.
filter
(
|
n
|
Range
:
:
contains
(
self
n
)
)
.
collect
(
)
;
if
contained_children
.
iter
(
)
.
any
(
|
n
|
n
.
is_doctype
(
)
)
{
return
Err
(
Error
:
:
HierarchyRequest
)
;
}
Ok
(
(
first_contained_child
last_contained_child
contained_children
)
)
}
fn
set_start
(
&
self
node
:
&
Node
offset
:
u32
)
{
if
&
self
.
start
.
node
!
=
node
{
if
self
.
start
.
node
=
=
self
.
end
.
node
{
node
.
ranges
(
)
.
push
(
WeakRef
:
:
new
(
&
self
)
)
;
}
else
if
&
self
.
end
.
node
=
=
node
{
self
.
StartContainer
(
)
.
ranges
(
)
.
remove
(
self
)
;
}
else
{
node
.
ranges
(
)
.
push
(
self
.
StartContainer
(
)
.
ranges
(
)
.
remove
(
self
)
)
;
}
}
self
.
start
.
set
(
node
offset
)
;
}
fn
set_end
(
&
self
node
:
&
Node
offset
:
u32
)
{
if
&
self
.
end
.
node
!
=
node
{
if
self
.
end
.
node
=
=
self
.
start
.
node
{
node
.
ranges
(
)
.
push
(
WeakRef
:
:
new
(
&
self
)
)
;
}
else
if
&
self
.
start
.
node
=
=
node
{
self
.
EndContainer
(
)
.
ranges
(
)
.
remove
(
self
)
;
}
else
{
node
.
ranges
(
)
.
push
(
self
.
EndContainer
(
)
.
ranges
(
)
.
remove
(
self
)
)
;
}
}
self
.
end
.
set
(
node
offset
)
;
}
fn
compare_point
(
&
self
node
:
&
Node
offset
:
u32
)
-
>
Fallible
<
Ordering
>
{
let
start_node
=
self
.
StartContainer
(
)
;
let
start_node_root
=
start_node
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
let
node_root
=
node
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
if
start_node_root
!
=
node_root
{
return
Err
(
Error
:
:
WrongDocument
)
;
}
if
node
.
is_doctype
(
)
{
return
Err
(
Error
:
:
InvalidNodeType
)
;
}
if
offset
>
node
.
len
(
)
{
return
Err
(
Error
:
:
IndexSize
)
;
}
if
let
Ordering
:
:
Less
=
bp_position
(
node
offset
&
start_node
self
.
StartOffset
(
)
)
.
unwrap
(
)
{
return
Ok
(
Ordering
:
:
Less
)
;
}
if
let
Ordering
:
:
Greater
=
bp_position
(
node
offset
&
self
.
EndContainer
(
)
self
.
EndOffset
(
)
)
.
unwrap
(
)
{
return
Ok
(
Ordering
:
:
Greater
)
;
}
Ok
(
Ordering
:
:
Equal
)
}
}
impl
RangeMethods
for
Range
{
fn
StartContainer
(
&
self
)
-
>
Root
<
Node
>
{
self
.
start
.
node
.
get
(
)
}
fn
StartOffset
(
&
self
)
-
>
u32
{
self
.
start
.
offset
.
get
(
)
}
fn
EndContainer
(
&
self
)
-
>
Root
<
Node
>
{
self
.
end
.
node
.
get
(
)
}
fn
EndOffset
(
&
self
)
-
>
u32
{
self
.
end
.
offset
.
get
(
)
}
fn
Collapsed
(
&
self
)
-
>
bool
{
self
.
start
=
=
self
.
end
}
fn
CommonAncestorContainer
(
&
self
)
-
>
Root
<
Node
>
{
let
end_container
=
self
.
EndContainer
(
)
;
for
container
in
self
.
StartContainer
(
)
.
inclusive_ancestors
(
)
{
if
container
.
is_inclusive_ancestor_of
(
&
end_container
)
{
return
container
;
}
}
unreachable
!
(
)
;
}
fn
SetStart
(
&
self
node
:
&
Node
offset
:
u32
)
-
>
ErrorResult
{
if
node
.
is_doctype
(
)
{
Err
(
Error
:
:
InvalidNodeType
)
}
else
if
offset
>
node
.
len
(
)
{
Err
(
Error
:
:
IndexSize
)
}
else
{
self
.
set_start
(
node
offset
)
;
if
!
(
self
.
start
<
=
self
.
end
)
{
self
.
set_end
(
node
offset
)
;
}
Ok
(
(
)
)
}
}
fn
SetEnd
(
&
self
node
:
&
Node
offset
:
u32
)
-
>
ErrorResult
{
if
node
.
is_doctype
(
)
{
Err
(
Error
:
:
InvalidNodeType
)
}
else
if
offset
>
node
.
len
(
)
{
Err
(
Error
:
:
IndexSize
)
}
else
{
self
.
set_end
(
node
offset
)
;
if
!
(
self
.
end
>
=
self
.
start
)
{
self
.
set_start
(
node
offset
)
;
}
Ok
(
(
)
)
}
}
fn
SetStartBefore
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
self
.
SetStart
(
parent
.
r
(
)
node
.
index
(
)
)
}
fn
SetStartAfter
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
self
.
SetStart
(
parent
.
r
(
)
node
.
index
(
)
+
1
)
}
fn
SetEndBefore
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
self
.
SetEnd
(
parent
.
r
(
)
node
.
index
(
)
)
}
fn
SetEndAfter
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
self
.
SetEnd
(
parent
.
r
(
)
node
.
index
(
)
+
1
)
}
fn
Collapse
(
&
self
to_start
:
bool
)
{
if
to_start
{
self
.
set_end
(
&
self
.
StartContainer
(
)
self
.
StartOffset
(
)
)
;
}
else
{
self
.
set_start
(
&
self
.
EndContainer
(
)
self
.
EndOffset
(
)
)
;
}
}
fn
SelectNode
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
let
parent
=
try
!
(
node
.
GetParentNode
(
)
.
ok_or
(
Error
:
:
InvalidNodeType
)
)
;
let
index
=
node
.
index
(
)
;
self
.
set_start
(
&
parent
index
)
;
self
.
set_end
(
&
parent
index
+
1
)
;
Ok
(
(
)
)
}
fn
SelectNodeContents
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
if
node
.
is_doctype
(
)
{
return
Err
(
Error
:
:
InvalidNodeType
)
;
}
let
length
=
node
.
len
(
)
;
self
.
set_start
(
node
0
)
;
self
.
set_end
(
node
length
)
;
Ok
(
(
)
)
}
fn
CompareBoundaryPoints
(
&
self
how
:
u16
other
:
&
Range
)
-
>
Fallible
<
i16
>
{
if
how
>
RangeConstants
:
:
END_TO_START
{
return
Err
(
Error
:
:
NotSupported
)
;
}
let
this_root
=
self
.
StartContainer
(
)
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
let
other_root
=
other
.
StartContainer
(
)
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
if
this_root
!
=
other_root
{
return
Err
(
Error
:
:
WrongDocument
)
;
}
let
(
this_point
other_point
)
=
match
how
{
RangeConstants
:
:
START_TO_START
=
>
{
(
&
self
.
start
&
other
.
start
)
}
RangeConstants
:
:
START_TO_END
=
>
{
(
&
self
.
end
&
other
.
start
)
}
RangeConstants
:
:
END_TO_END
=
>
{
(
&
self
.
end
&
other
.
end
)
}
RangeConstants
:
:
END_TO_START
=
>
{
(
&
self
.
start
&
other
.
end
)
}
_
=
>
unreachable
!
(
)
}
;
match
this_point
.
partial_cmp
(
other_point
)
.
unwrap
(
)
{
Ordering
:
:
Less
=
>
Ok
(
-
1
)
Ordering
:
:
Equal
=
>
Ok
(
0
)
Ordering
:
:
Greater
=
>
Ok
(
1
)
}
}
fn
CloneRange
(
&
self
)
-
>
Root
<
Range
>
{
let
start_node
=
self
.
StartContainer
(
)
;
let
owner_doc
=
start_node
.
owner_doc
(
)
;
Range
:
:
new
(
&
owner_doc
&
start_node
self
.
StartOffset
(
)
&
self
.
EndContainer
(
)
self
.
EndOffset
(
)
)
}
fn
IsPointInRange
(
&
self
node
:
&
Node
offset
:
u32
)
-
>
Fallible
<
bool
>
{
match
self
.
compare_point
(
node
offset
)
{
Ok
(
Ordering
:
:
Less
)
=
>
Ok
(
false
)
Ok
(
Ordering
:
:
Equal
)
=
>
Ok
(
true
)
Ok
(
Ordering
:
:
Greater
)
=
>
Ok
(
false
)
Err
(
Error
:
:
WrongDocument
)
=
>
{
Ok
(
false
)
}
Err
(
error
)
=
>
Err
(
error
)
}
}
fn
ComparePoint
(
&
self
node
:
&
Node
offset
:
u32
)
-
>
Fallible
<
i16
>
{
self
.
compare_point
(
node
offset
)
.
map
(
|
order
|
{
match
order
{
Ordering
:
:
Less
=
>
-
1
Ordering
:
:
Equal
=
>
0
Ordering
:
:
Greater
=
>
1
}
}
)
}
fn
IntersectsNode
(
&
self
node
:
&
Node
)
-
>
bool
{
let
start_node
=
self
.
StartContainer
(
)
;
let
start_node_root
=
self
.
StartContainer
(
)
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
let
node_root
=
node
.
inclusive_ancestors
(
)
.
last
(
)
.
unwrap
(
)
;
if
start_node_root
!
=
node_root
{
return
false
;
}
let
parent
=
match
node
.
GetParentNode
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
{
return
true
;
}
}
;
let
offset
=
node
.
index
(
)
;
Ordering
:
:
Greater
=
=
bp_position
(
parent
.
r
(
)
offset
+
1
&
start_node
self
.
StartOffset
(
)
)
.
unwrap
(
)
&
&
Ordering
:
:
Less
=
=
bp_position
(
parent
.
r
(
)
offset
&
self
.
EndContainer
(
)
self
.
EndOffset
(
)
)
.
unwrap
(
)
}
fn
CloneContents
(
&
self
)
-
>
Fallible
<
Root
<
DocumentFragment
>
>
{
let
start_node
=
self
.
StartContainer
(
)
;
let
start_offset
=
self
.
StartOffset
(
)
;
let
end_node
=
self
.
EndContainer
(
)
;
let
end_offset
=
self
.
EndOffset
(
)
;
let
fragment
=
DocumentFragment
:
:
new
(
start_node
.
owner_doc
(
)
.
r
(
)
)
;
if
self
.
start
=
=
self
.
end
{
return
Ok
(
fragment
)
;
}
if
end_node
=
=
start_node
{
if
let
Some
(
cdata
)
=
start_node
.
downcast
:
:
<
CharacterData
>
(
)
{
let
data
=
cdata
.
SubstringData
(
start_offset
end_offset
-
start_offset
)
.
unwrap
(
)
;
let
clone
=
cdata
.
clone_with_data
(
data
&
start_node
.
owner_doc
(
)
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
return
Ok
(
fragment
)
;
}
}
let
(
first_contained_child
last_contained_child
contained_children
)
=
try
!
(
self
.
contained_children
(
)
)
;
if
let
Some
(
child
)
=
first_contained_child
{
if
let
Some
(
cdata
)
=
child
.
downcast
:
:
<
CharacterData
>
(
)
{
assert
!
(
child
=
=
start_node
)
;
let
data
=
cdata
.
SubstringData
(
start_offset
start_node
.
len
(
)
-
start_offset
)
.
unwrap
(
)
;
let
clone
=
cdata
.
clone_with_data
(
data
&
start_node
.
owner_doc
(
)
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
}
else
{
let
clone
=
child
.
CloneNode
(
false
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
let
subrange
=
Range
:
:
new
(
clone
.
owner_doc
(
)
.
r
(
)
start_node
.
r
(
)
start_offset
child
.
r
(
)
child
.
len
(
)
)
;
let
subfragment
=
try
!
(
subrange
.
CloneContents
(
)
)
;
try
!
(
clone
.
AppendChild
(
subfragment
.
upcast
(
)
)
)
;
}
}
for
child
in
contained_children
{
let
clone
=
child
.
CloneNode
(
true
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
}
if
let
Some
(
child
)
=
last_contained_child
{
if
let
Some
(
cdata
)
=
child
.
downcast
:
:
<
CharacterData
>
(
)
{
assert
!
(
child
=
=
end_node
)
;
let
data
=
cdata
.
SubstringData
(
0
end_offset
)
.
unwrap
(
)
;
let
clone
=
cdata
.
clone_with_data
(
data
&
start_node
.
owner_doc
(
)
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
}
else
{
let
clone
=
child
.
CloneNode
(
false
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
let
subrange
=
Range
:
:
new
(
clone
.
owner_doc
(
)
.
r
(
)
child
.
r
(
)
0
end_node
.
r
(
)
end_offset
)
;
let
subfragment
=
try
!
(
subrange
.
CloneContents
(
)
)
;
try
!
(
clone
.
AppendChild
(
subfragment
.
upcast
(
)
)
)
;
}
}
Ok
(
fragment
)
}
fn
ExtractContents
(
&
self
)
-
>
Fallible
<
Root
<
DocumentFragment
>
>
{
let
start_node
=
self
.
StartContainer
(
)
;
let
start_offset
=
self
.
StartOffset
(
)
;
let
end_node
=
self
.
EndContainer
(
)
;
let
end_offset
=
self
.
EndOffset
(
)
;
let
fragment
=
DocumentFragment
:
:
new
(
start_node
.
owner_doc
(
)
.
r
(
)
)
;
if
self
.
Collapsed
(
)
{
return
Ok
(
fragment
)
;
}
if
end_node
=
=
start_node
{
if
let
Some
(
end_data
)
=
end_node
.
downcast
:
:
<
CharacterData
>
(
)
{
let
clone
=
end_node
.
CloneNode
(
true
)
;
let
text
=
end_data
.
SubstringData
(
start_offset
end_offset
-
start_offset
)
;
clone
.
downcast
:
:
<
CharacterData
>
(
)
.
unwrap
(
)
.
SetData
(
text
.
unwrap
(
)
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
try
!
(
end_data
.
ReplaceData
(
start_offset
end_offset
-
start_offset
DOMString
:
:
new
(
)
)
)
;
return
Ok
(
fragment
)
;
}
}
let
(
first_contained_child
last_contained_child
contained_children
)
=
try
!
(
self
.
contained_children
(
)
)
;
let
(
new_node
new_offset
)
=
if
start_node
.
is_inclusive_ancestor_of
(
end_node
.
r
(
)
)
{
(
Root
:
:
from_ref
(
start_node
.
r
(
)
)
start_offset
)
}
else
{
let
reference_node
=
start_node
.
ancestors
(
)
.
find
(
|
n
|
n
.
is_inclusive_ancestor_of
(
end_node
.
r
(
)
)
)
.
unwrap
(
)
;
(
reference_node
.
GetParentNode
(
)
.
unwrap
(
)
reference_node
.
index
(
)
+
1
)
}
;
if
let
Some
(
child
)
=
first_contained_child
{
if
let
Some
(
start_data
)
=
child
.
downcast
:
:
<
CharacterData
>
(
)
{
assert
!
(
child
=
=
start_node
)
;
let
clone
=
start_node
.
CloneNode
(
true
)
;
let
text
=
start_data
.
SubstringData
(
start_offset
start_node
.
len
(
)
-
start_offset
)
;
clone
.
downcast
:
:
<
CharacterData
>
(
)
.
unwrap
(
)
.
SetData
(
text
.
unwrap
(
)
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
try
!
(
start_data
.
ReplaceData
(
start_offset
start_node
.
len
(
)
-
start_offset
DOMString
:
:
new
(
)
)
)
;
}
else
{
let
clone
=
child
.
CloneNode
(
false
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
let
subrange
=
Range
:
:
new
(
clone
.
owner_doc
(
)
.
r
(
)
start_node
.
r
(
)
start_offset
child
.
r
(
)
child
.
len
(
)
)
;
let
subfragment
=
try
!
(
subrange
.
ExtractContents
(
)
)
;
try
!
(
clone
.
AppendChild
(
subfragment
.
upcast
(
)
)
)
;
}
}
for
child
in
contained_children
{
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
child
)
)
;
}
if
let
Some
(
child
)
=
last_contained_child
{
if
let
Some
(
end_data
)
=
child
.
downcast
:
:
<
CharacterData
>
(
)
{
assert
!
(
child
=
=
end_node
)
;
let
clone
=
end_node
.
CloneNode
(
true
)
;
let
text
=
end_data
.
SubstringData
(
0
end_offset
)
;
clone
.
downcast
:
:
<
CharacterData
>
(
)
.
unwrap
(
)
.
SetData
(
text
.
unwrap
(
)
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
try
!
(
end_data
.
ReplaceData
(
0
end_offset
DOMString
:
:
new
(
)
)
)
;
}
else
{
let
clone
=
child
.
CloneNode
(
false
)
;
try
!
(
fragment
.
upcast
:
:
<
Node
>
(
)
.
AppendChild
(
&
clone
)
)
;
let
subrange
=
Range
:
:
new
(
clone
.
owner_doc
(
)
.
r
(
)
child
.
r
(
)
0
end_node
.
r
(
)
end_offset
)
;
let
subfragment
=
try
!
(
subrange
.
ExtractContents
(
)
)
;
try
!
(
clone
.
AppendChild
(
subfragment
.
upcast
(
)
)
)
;
}
}
try
!
(
self
.
SetStart
(
new_node
.
r
(
)
new_offset
)
)
;
try
!
(
self
.
SetEnd
(
new_node
.
r
(
)
new_offset
)
)
;
Ok
(
fragment
)
}
fn
Detach
(
&
self
)
{
}
fn
InsertNode
(
&
self
node
:
&
Node
)
-
>
ErrorResult
{
let
start_node
=
self
.
StartContainer
(
)
;
let
start_offset
=
self
.
StartOffset
(
)
;
match
start_node
.
type_id
(
)
{
NodeTypeId
:
:
CharacterData
(
CharacterDataTypeId
:
:
Text
)
=
>
(
)
NodeTypeId
:
:
CharacterData
(
_
)
=
>
return
Err
(
Error
:
:
HierarchyRequest
)
_
=
>
(
)
}
let
(
reference_node
parent
)
=
if
start_node
.
type_id
(
)
=
=
NodeTypeId
:
:
CharacterData
(
CharacterDataTypeId
:
:
Text
)
{
let
parent
=
match
start_node
.
GetParentNode
(
)
{
Some
(
parent
)
=
>
parent
None
=
>
return
Err
(
Error
:
:
HierarchyRequest
)
}
;
(
Some
(
Root
:
:
from_ref
(
start_node
.
r
(
)
)
)
parent
)
}
else
{
let
child
=
start_node
.
ChildNodes
(
)
.
Item
(
start_offset
)
;
(
child
Root
:
:
from_ref
(
start_node
.
r
(
)
)
)
}
;
try
!
(
Node
:
:
ensure_pre_insertion_validity
(
node
parent
.
r
(
)
reference_node
.
r
(
)
)
)
;
let
split_text
;
let
reference_node
=
match
start_node
.
downcast
:
:
<
Text
>
(
)
{
Some
(
text
)
=
>
{
split_text
=
try
!
(
text
.
SplitText
(
start_offset
)
)
;
let
new_reference
=
Root
:
:
upcast
:
:
<
Node
>
(
split_text
)
;
assert
!
(
new_reference
.
GetParentNode
(
)
.
r
(
)
=
=
Some
(
parent
.
r
(
)
)
)
;
Some
(
new_reference
)
}
_
=
>
reference_node
}
;
let
reference_node
=
if
Some
(
node
)
=
=
reference_node
.
r
(
)
{
node
.
GetNextSibling
(
)
}
else
{
reference_node
}
;
node
.
remove_self
(
)
;
let
new_offset
=
reference_node
.
r
(
)
.
map_or
(
parent
.
len
(
)
|
node
|
node
.
index
(
)
)
;
let
new_offset
=
new_offset
+
if
node
.
type_id
(
)
=
=
NodeTypeId
:
:
DocumentFragment
{
node
.
len
(
)
}
else
{
1
}
;
try
!
(
Node
:
:
pre_insert
(
node
parent
.
r
(
)
reference_node
.
r
(
)
)
)
;
if
self
.
Collapsed
(
)
{
self
.
set_end
(
parent
.
r
(
)
new_offset
)
;
}
Ok
(
(
)
)
}
fn
DeleteContents
(
&
self
)
-
>
ErrorResult
{
if
self
.
Collapsed
(
)
{
return
Ok
(
(
)
)
;
}
let
start_node
=
self
.
StartContainer
(
)
;
let
end_node
=
self
.
EndContainer
(
)
;
let
start_offset
=
self
.
StartOffset
(
)
;
let
end_offset
=
self
.
EndOffset
(
)
;
if
start_node
=
=
end_node
{
if
let
Some
(
text
)
=
start_node
.
downcast
:
:
<
CharacterData
>
(
)
{
return
text
.
ReplaceData
(
start_offset
end_offset
-
start_offset
DOMString
:
:
new
(
)
)
;
}
}
let
mut
contained_children
:
RootedVec
<
JS
<
Node
>
>
=
RootedVec
:
:
new
(
)
;
let
ancestor
=
self
.
CommonAncestorContainer
(
)
;
let
mut
iter
=
start_node
.
following_nodes
(
ancestor
.
r
(
)
)
;
let
mut
next
=
iter
.
next
(
)
;
while
let
Some
(
child
)
=
next
{
if
self
.
contains
(
child
.
r
(
)
)
{
contained_children
.
push
(
JS
:
:
from_ref
(
child
.
r
(
)
)
)
;
next
=
iter
.
next_skipping_children
(
)
;
}
else
{
next
=
iter
.
next
(
)
;
}
}
let
(
new_node
new_offset
)
=
if
start_node
.
is_inclusive_ancestor_of
(
end_node
.
r
(
)
)
{
(
Root
:
:
from_ref
(
start_node
.
r
(
)
)
start_offset
)
}
else
{
fn
compute_reference
(
start_node
:
&
Node
end_node
:
&
Node
)
-
>
(
Root
<
Node
>
u32
)
{
let
mut
reference_node
=
Root
:
:
from_ref
(
start_node
)
;
while
let
Some
(
parent
)
=
reference_node
.
GetParentNode
(
)
{
if
parent
.
is_inclusive_ancestor_of
(
end_node
)
{
return
(
parent
reference_node
.
index
(
)
+
1
)
}
reference_node
=
parent
;
}
unreachable
!
(
)
}
compute_reference
(
start_node
.
r
(
)
end_node
.
r
(
)
)
}
;
if
let
Some
(
text
)
=
start_node
.
downcast
:
:
<
CharacterData
>
(
)
{
text
.
ReplaceData
(
start_offset
start_node
.
len
(
)
-
start_offset
DOMString
:
:
new
(
)
)
.
unwrap
(
)
;
}
for
child
in
contained_children
.
r
(
)
{
child
.
remove_self
(
)
;
}
if
let
Some
(
text
)
=
end_node
.
downcast
:
:
<
CharacterData
>
(
)
{
text
.
ReplaceData
(
0
end_offset
DOMString
:
:
new
(
)
)
.
unwrap
(
)
;
}
self
.
SetStart
(
new_node
.
r
(
)
new_offset
)
.
unwrap
(
)
;
self
.
SetEnd
(
new_node
.
r
(
)
new_offset
)
.
unwrap
(
)
;
Ok
(
(
)
)
}
fn
SurroundContents
(
&
self
new_parent
:
&
Node
)
-
>
ErrorResult
{
let
start
=
self
.
StartContainer
(
)
;
let
end
=
self
.
EndContainer
(
)
;
if
start
.
inclusive_ancestors
(
)
.
any
(
|
n
|
!
n
.
is_inclusive_ancestor_of
(
end
.
r
(
)
)
&
&
!
n
.
is
:
:
<
Text
>
(
)
)
|
|
end
.
inclusive_ancestors
(
)
.
any
(
|
n
|
!
n
.
is_inclusive_ancestor_of
(
start
.
r
(
)
)
&
&
!
n
.
is
:
:
<
Text
>
(
)
)
{
return
Err
(
Error
:
:
InvalidState
)
;
}
match
new_parent
.
type_id
(
)
{
NodeTypeId
:
:
Document
(
_
)
|
NodeTypeId
:
:
DocumentType
|
NodeTypeId
:
:
DocumentFragment
=
>
return
Err
(
Error
:
:
InvalidNodeType
)
_
=
>
(
)
}
let
fragment
=
try
!
(
self
.
ExtractContents
(
)
)
;
Node
:
:
replace_all
(
None
new_parent
)
;
try
!
(
self
.
InsertNode
(
new_parent
)
)
;
try
!
(
new_parent
.
AppendChild
(
fragment
.
upcast
(
)
)
)
;
self
.
SelectNode
(
new_parent
)
}
}
#
[
derive
(
JSTraceable
)
]
#
[
must_root
]
#
[
privatize
]
#
[
derive
(
HeapSizeOf
)
]
pub
struct
BoundaryPoint
{
node
:
MutHeap
<
JS
<
Node
>
>
offset
:
Cell
<
u32
>
}
impl
BoundaryPoint
{
fn
new
(
node
:
&
Node
offset
:
u32
)
-
>
BoundaryPoint
{
debug_assert
!
(
!
node
.
is_doctype
(
)
)
;
debug_assert
!
(
offset
<
=
node
.
len
(
)
)
;
BoundaryPoint
{
node
:
MutHeap
:
:
new
(
node
)
offset
:
Cell
:
:
new
(
offset
)
}
}
pub
fn
set
(
&
self
node
:
&
Node
offset
:
u32
)
{
self
.
node
.
set
(
node
)
;
self
.
set_offset
(
offset
)
;
}
pub
fn
set_offset
(
&
self
offset
:
u32
)
{
self
.
offset
.
set
(
offset
)
;
}
}
#
[
allow
(
unrooted_must_root
)
]
impl
PartialOrd
for
BoundaryPoint
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
bp_position
(
&
self
.
node
.
get
(
)
self
.
offset
.
get
(
)
&
other
.
node
.
get
(
)
other
.
offset
.
get
(
)
)
}
}
#
[
allow
(
unrooted_must_root
)
]
impl
PartialEq
for
BoundaryPoint
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
node
.
get
(
)
=
=
other
.
node
.
get
(
)
&
&
self
.
offset
.
get
(
)
=
=
other
.
offset
.
get
(
)
}
}
fn
bp_position
(
a_node
:
&
Node
a_offset
:
u32
b_node
:
&
Node
b_offset
:
u32
)
-
>
Option
<
Ordering
>
{
if
a_node
as
*
const
Node
=
=
b_node
as
*
const
Node
{
return
Some
(
a_offset
.
cmp
(
&
b_offset
)
)
;
}
let
position
=
b_node
.
CompareDocumentPosition
(
a_node
)
;
if
position
&
NodeConstants
:
:
DOCUMENT_POSITION_DISCONNECTED
!
=
0
{
None
}
else
if
position
&
NodeConstants
:
:
DOCUMENT_POSITION_FOLLOWING
!
=
0
{
match
bp_position
(
b_node
b_offset
a_node
a_offset
)
.
unwrap
(
)
{
Ordering
:
:
Less
=
>
Some
(
Ordering
:
:
Greater
)
Ordering
:
:
Greater
=
>
Some
(
Ordering
:
:
Less
)
Ordering
:
:
Equal
=
>
unreachable
!
(
)
}
}
else
if
position
&
NodeConstants
:
:
DOCUMENT_POSITION_CONTAINS
!
=
0
{
let
mut
b_ancestors
=
b_node
.
inclusive_ancestors
(
)
;
let
child
=
b_ancestors
.
find
(
|
child
|
{
child
.
GetParentNode
(
)
.
unwrap
(
)
.
r
(
)
=
=
a_node
}
)
.
unwrap
(
)
;
if
child
.
index
(
)
<
a_offset
{
Some
(
Ordering
:
:
Greater
)
}
else
{
Some
(
Ordering
:
:
Less
)
}
}
else
{
Some
(
Ordering
:
:
Less
)
}
}
pub
struct
WeakRangeVec
{
cell
:
UnsafeCell
<
WeakRefVec
<
Range
>
>
}
#
[
allow
(
unsafe_code
)
]
impl
WeakRangeVec
{
pub
fn
new
(
)
-
>
Self
{
WeakRangeVec
{
cell
:
UnsafeCell
:
:
new
(
WeakRefVec
:
:
new
(
)
)
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
unsafe
{
(
*
self
.
cell
.
get
(
)
)
.
is_empty
(
)
}
}
pub
fn
increase_above
(
&
self
node
:
&
Node
offset
:
u32
delta
:
u32
)
{
self
.
map_offset_above
(
node
offset
|
offset
|
offset
+
delta
)
;
}
pub
fn
decrease_above
(
&
self
node
:
&
Node
offset
:
u32
delta
:
u32
)
{
self
.
map_offset_above
(
node
offset
|
offset
|
offset
-
delta
)
;
}
pub
fn
drain_to_parent
(
&
self
context
:
&
UnbindContext
child
:
&
Node
)
{
if
self
.
is_empty
(
)
{
return
;
}
let
offset
=
context
.
index
(
)
;
let
parent
=
context
.
parent
;
unsafe
{
let
mut
ranges
=
&
mut
*
self
.
cell
.
get
(
)
;
ranges
.
update
(
|
entry
|
{
let
range
=
entry
.
root
(
)
.
unwrap
(
)
;
if
&
range
.
start
.
node
=
=
parent
|
|
&
range
.
end
.
node
=
=
parent
{
entry
.
remove
(
)
;
}
if
&
range
.
start
.
node
=
=
child
{
range
.
start
.
set
(
context
.
parent
offset
)
;
}
if
&
range
.
end
.
node
=
=
child
{
range
.
end
.
set
(
context
.
parent
offset
)
;
}
}
)
;
(
*
context
.
parent
.
ranges
(
)
.
cell
.
get
(
)
)
.
extend
(
ranges
.
drain
(
.
.
)
)
;
}
}
pub
fn
drain_to_preceding_text_sibling
(
&
self
node
:
&
Node
sibling
:
&
Node
length
:
u32
)
{
if
self
.
is_empty
(
)
{
return
;
}
unsafe
{
let
mut
ranges
=
&
mut
*
self
.
cell
.
get
(
)
;
ranges
.
update
(
|
entry
|
{
let
range
=
entry
.
root
(
)
.
unwrap
(
)
;
if
&
range
.
start
.
node
=
=
sibling
|
|
&
range
.
end
.
node
=
=
sibling
{
entry
.
remove
(
)
;
}
if
&
range
.
start
.
node
=
=
node
{
range
.
start
.
set
(
sibling
range
.
StartOffset
(
)
+
length
)
;
}
if
&
range
.
end
.
node
=
=
node
{
range
.
end
.
set
(
sibling
range
.
EndOffset
(
)
+
length
)
;
}
}
)
;
(
*
sibling
.
ranges
(
)
.
cell
.
get
(
)
)
.
extend
(
ranges
.
drain
(
.
.
)
)
;
}
}
pub
fn
move_to_text_child_at
(
&
self
node
:
&
Node
offset
:
u32
child
:
&
Node
new_offset
:
u32
)
{
unsafe
{
let
child_ranges
=
&
mut
*
child
.
ranges
(
)
.
cell
.
get
(
)
;
(
*
self
.
cell
.
get
(
)
)
.
update
(
|
entry
|
{
let
range
=
entry
.
root
(
)
.
unwrap
(
)
;
let
node_is_start
=
&
range
.
start
.
node
=
=
node
;
let
node_is_end
=
&
range
.
end
.
node
=
=
node
;
let
move_start
=
node_is_start
&
&
range
.
StartOffset
(
)
=
=
offset
;
let
move_end
=
node_is_end
&
&
range
.
EndOffset
(
)
=
=
offset
;
let
remove_from_node
=
move_start
&
&
move_end
|
|
move_start
&
&
!
node_is_end
|
|
move_end
&
&
!
node_is_start
;
let
already_in_child
=
&
range
.
start
.
node
=
=
child
|
|
&
range
.
end
.
node
=
=
child
;
let
push_to_child
=
!
already_in_child
&
&
(
move_start
|
|
move_end
)
;
if
remove_from_node
{
let
ref_
=
entry
.
remove
(
)
;
if
push_to_child
{
child_ranges
.
push
(
ref_
)
;
}
}
else
if
push_to_child
{
child_ranges
.
push
(
WeakRef
:
:
new
(
&
range
)
)
;
}
if
move_start
{
range
.
start
.
set
(
child
new_offset
)
;
}
if
move_end
{
range
.
end
.
set
(
child
new_offset
)
;
}
}
)
;
}
}
pub
fn
replace_code_units
(
&
self
node
:
&
Node
offset
:
u32
removed_code_units
:
u32
added_code_units
:
u32
)
{
self
.
map_offset_above
(
node
offset
|
range_offset
|
{
if
range_offset
<
=
offset
+
removed_code_units
{
offset
}
else
{
range_offset
+
added_code_units
-
removed_code_units
}
}
)
;
}
pub
fn
move_to_following_text_sibling_above
(
&
self
node
:
&
Node
offset
:
u32
sibling
:
&
Node
)
{
unsafe
{
let
sibling_ranges
=
&
mut
*
sibling
.
ranges
(
)
.
cell
.
get
(
)
;
(
*
self
.
cell
.
get
(
)
)
.
update
(
|
entry
|
{
let
range
=
entry
.
root
(
)
.
unwrap
(
)
;
let
start_offset
=
range
.
StartOffset
(
)
;
let
end_offset
=
range
.
EndOffset
(
)
;
let
node_is_start
=
&
range
.
start
.
node
=
=
node
;
let
node_is_end
=
&
range
.
end
.
node
=
=
node
;
let
move_start
=
node_is_start
&
&
start_offset
>
offset
;
let
move_end
=
node_is_end
&
&
end_offset
>
offset
;
let
remove_from_node
=
move_start
&
&
move_end
|
|
move_start
&
&
!
node_is_end
|
|
move_end
&
&
!
node_is_start
;
let
already_in_sibling
=
&
range
.
start
.
node
=
=
sibling
|
|
&
range
.
end
.
node
=
=
sibling
;
let
push_to_sibling
=
!
already_in_sibling
&
&
(
move_start
|
|
move_end
)
;
if
remove_from_node
{
let
ref_
=
entry
.
remove
(
)
;
if
push_to_sibling
{
sibling_ranges
.
push
(
ref_
)
;
}
}
else
if
push_to_sibling
{
sibling_ranges
.
push
(
WeakRef
:
:
new
(
&
range
)
)
;
}
if
move_start
{
range
.
start
.
set
(
sibling
start_offset
-
offset
)
;
}
if
move_end
{
range
.
end
.
set
(
sibling
end_offset
-
offset
)
;
}
}
)
;
}
}
pub
fn
increment_at
(
&
self
node
:
&
Node
offset
:
u32
)
{
unsafe
{
(
*
self
.
cell
.
get
(
)
)
.
update
(
|
entry
|
{
let
range
=
entry
.
root
(
)
.
unwrap
(
)
;
if
&
range
.
start
.
node
=
=
node
&
&
offset
=
=
range
.
StartOffset
(
)
{
range
.
start
.
set_offset
(
offset
+
1
)
;
}
if
&
range
.
end
.
node
=
=
node
&
&
offset
=
=
range
.
EndOffset
(
)
{
range
.
end
.
set_offset
(
offset
+
1
)
;
}
}
)
;
}
}
pub
fn
clamp_above
(
&
self
node
:
&
Node
offset
:
u32
)
{
self
.
map_offset_above
(
node
offset
|
_
|
offset
)
;
}
fn
map_offset_above
<
F
:
FnMut
(
u32
)
-
>
u32
>
(
&
self
node
:
&
Node
offset
:
u32
mut
f
:
F
)
{
unsafe
{
(
*
self
.
cell
.
get
(
)
)
.
update
(
|
entry
|
{
let
range
=
entry
.
root
(
)
.
unwrap
(
)
;
let
start_offset
=
range
.
StartOffset
(
)
;
if
&
range
.
start
.
node
=
=
node
&
&
start_offset
>
offset
{
range
.
start
.
set_offset
(
f
(
start_offset
)
)
;
}
let
end_offset
=
range
.
EndOffset
(
)
;
if
&
range
.
end
.
node
=
=
node
&
&
end_offset
>
offset
{
range
.
end
.
set_offset
(
f
(
end_offset
)
)
;
}
}
)
;
}
}
fn
push
(
&
self
ref_
:
WeakRef
<
Range
>
)
{
unsafe
{
(
*
self
.
cell
.
get
(
)
)
.
push
(
ref_
)
;
}
}
fn
remove
(
&
self
range
:
&
Range
)
-
>
WeakRef
<
Range
>
{
unsafe
{
let
ranges
=
&
mut
*
self
.
cell
.
get
(
)
;
let
position
=
ranges
.
iter
(
)
.
position
(
|
ref_
|
{
ref_
=
=
range
}
)
.
unwrap
(
)
;
ranges
.
swap_remove
(
position
)
}
}
}
#
[
allow
(
unsafe_code
)
]
impl
HeapSizeOf
for
WeakRangeVec
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
unsafe
{
(
*
self
.
cell
.
get
(
)
)
.
heap_size_of_children
(
)
}
}
}
#
[
allow
(
unsafe_code
)
]
impl
JSTraceable
for
WeakRangeVec
{
fn
trace
(
&
self
_
:
*
mut
JSTracer
)
{
unsafe
{
(
*
self
.
cell
.
get
(
)
)
.
retain_alive
(
)
}
}
}
