use
dom
:
:
node
:
:
LayoutData
;
use
geom
:
:
point
:
:
Point2D
;
use
geom
:
:
rect
:
:
Rect
;
use
libc
:
:
uintptr_t
;
use
msg
:
:
constellation_msg
:
:
{
PipelineExitType
WindowSizeData
}
;
use
profile
:
:
mem
:
:
{
Reporter
ReportsChan
}
;
use
script_traits
:
:
{
ScriptControlChan
OpaqueScriptLayoutChannel
UntrustedNodeAddress
}
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Receiver
Sender
}
;
use
std
:
:
boxed
:
:
BoxAny
;
use
style
:
:
animation
:
:
PropertyAnimation
;
use
style
:
:
media_queries
:
:
MediaQueryList
;
use
style
:
:
stylesheets
:
:
Stylesheet
;
use
url
:
:
Url
;
use
util
:
:
geometry
:
:
Au
;
pub
use
dom
:
:
node
:
:
TrustedNodeAddress
;
pub
enum
Msg
{
AddStylesheet
(
Stylesheet
MediaQueryList
)
LoadStylesheet
(
Url
MediaQueryList
)
SetQuirksMode
Reflow
(
Box
<
ScriptReflow
>
)
GetRPC
(
Sender
<
Box
<
LayoutRPC
+
Send
>
>
)
TickAnimations
ReapLayoutData
(
LayoutData
)
CollectReports
(
ReportsChan
)
PrepareToExit
(
Sender
<
(
)
>
)
ExitNow
(
PipelineExitType
)
}
pub
trait
LayoutRPC
{
fn
content_box
(
&
self
)
-
>
ContentBoxResponse
;
fn
content_boxes
(
&
self
)
-
>
ContentBoxesResponse
;
fn
hit_test
(
&
self
node
:
TrustedNodeAddress
point
:
Point2D
<
f32
>
)
-
>
Result
<
HitTestResponse
(
)
>
;
fn
mouse_over
(
&
self
node
:
TrustedNodeAddress
point
:
Point2D
<
f32
>
)
-
>
Result
<
MouseOverResponse
(
)
>
;
}
pub
struct
ContentBoxResponse
(
pub
Rect
<
Au
>
)
;
pub
struct
ContentBoxesResponse
(
pub
Vec
<
Rect
<
Au
>
>
)
;
pub
struct
HitTestResponse
(
pub
UntrustedNodeAddress
)
;
pub
struct
MouseOverResponse
(
pub
Vec
<
UntrustedNodeAddress
>
)
;
#
[
derive
(
PartialEq
Debug
)
]
pub
enum
ReflowGoal
{
ForDisplay
ForScriptQuery
}
#
[
derive
(
PartialEq
)
]
pub
enum
ReflowQueryType
{
NoQuery
ContentBoxQuery
(
TrustedNodeAddress
)
ContentBoxesQuery
(
TrustedNodeAddress
)
}
pub
struct
Reflow
{
pub
goal
:
ReflowGoal
pub
page_clip_rect
:
Rect
<
Au
>
}
pub
struct
ScriptReflow
{
pub
reflow_info
:
Reflow
pub
document_root
:
TrustedNodeAddress
pub
script_chan
:
ScriptControlChan
pub
window_size
:
WindowSizeData
pub
script_join_chan
:
Sender
<
(
)
>
pub
id
:
u32
pub
query_type
:
ReflowQueryType
}
#
[
derive
(
Clone
)
]
pub
struct
LayoutChan
(
pub
Sender
<
Msg
>
)
;
impl
LayoutChan
{
pub
fn
new
(
)
-
>
(
Receiver
<
Msg
>
LayoutChan
)
{
let
(
chan
port
)
=
channel
(
)
;
(
port
LayoutChan
(
chan
)
)
}
}
impl
Reporter
for
LayoutChan
{
fn
collect_reports
(
&
self
reports_chan
:
ReportsChan
)
-
>
bool
{
let
LayoutChan
(
ref
c
)
=
*
self
;
c
.
send
(
Msg
:
:
CollectReports
(
reports_chan
)
)
.
is_ok
(
)
}
}
pub
trait
ScriptLayoutChan
{
fn
new
(
sender
:
Sender
<
Msg
>
receiver
:
Receiver
<
Msg
>
)
-
>
Self
;
fn
sender
(
&
self
)
-
>
Sender
<
Msg
>
;
fn
receiver
(
self
)
-
>
Receiver
<
Msg
>
;
}
impl
ScriptLayoutChan
for
OpaqueScriptLayoutChannel
{
fn
new
(
sender
:
Sender
<
Msg
>
receiver
:
Receiver
<
Msg
>
)
-
>
OpaqueScriptLayoutChannel
{
let
inner
=
(
box
sender
as
Box
<
Any
+
Send
>
box
receiver
as
Box
<
Any
+
Send
>
)
;
OpaqueScriptLayoutChannel
(
inner
)
}
fn
sender
(
&
self
)
-
>
Sender
<
Msg
>
{
let
&
OpaqueScriptLayoutChannel
(
(
ref
sender
_
)
)
=
self
;
(
*
sender
.
downcast_ref
:
:
<
Sender
<
Msg
>
>
(
)
.
unwrap
(
)
)
.
clone
(
)
}
fn
receiver
(
self
)
-
>
Receiver
<
Msg
>
{
let
OpaqueScriptLayoutChannel
(
(
_
receiver
)
)
=
self
;
*
receiver
.
downcast
:
:
<
Receiver
<
Msg
>
>
(
)
.
unwrap
(
)
}
}
pub
type
OpaqueNode
=
uintptr_t
;
#
[
derive
(
Clone
)
]
pub
struct
Animation
{
pub
node
:
OpaqueNode
pub
property_animation
:
PropertyAnimation
pub
start_time
:
f64
pub
end_time
:
f64
}
impl
Animation
{
#
[
inline
]
pub
fn
duration
(
&
self
)
-
>
f64
{
self
.
end_time
-
self
.
start_time
}
}
