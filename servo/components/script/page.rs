use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
DocumentBinding
:
:
DocumentMethods
;
use
dom
:
:
bindings
:
:
codegen
:
:
InheritTypes
:
:
NodeCast
;
use
dom
:
:
bindings
:
:
js
:
:
{
JS
JSRef
Temporary
OptionalRootable
}
;
use
dom
:
:
bindings
:
:
utils
:
:
GlobalStaticData
;
use
dom
:
:
document
:
:
{
Document
DocumentHelpers
}
;
use
dom
:
:
element
:
:
Element
;
use
dom
:
:
node
:
:
{
Node
NodeHelpers
}
;
use
dom
:
:
window
:
:
Window
;
use
layout_interface
:
:
{
DocumentDamage
ReflowForDisplay
}
;
use
layout_interface
:
:
{
DocumentDamageLevel
HitTestResponse
MouseOverResponse
}
;
use
layout_interface
:
:
{
GetRPCMsg
LayoutChan
LayoutRPC
}
;
use
layout_interface
:
:
{
Reflow
ReflowGoal
ReflowMsg
}
;
use
layout_interface
:
:
UntrustedNodeAddress
;
use
script_traits
:
:
ScriptControlChan
;
use
geom
:
:
point
:
:
Point2D
;
use
js
:
:
rust
:
:
Cx
;
use
servo_msg
:
:
compositor_msg
:
:
PerformingLayout
;
use
servo_msg
:
:
compositor_msg
:
:
ScriptListener
;
use
servo_msg
:
:
constellation_msg
:
:
{
ConstellationChan
WindowSizeData
}
;
use
servo_msg
:
:
constellation_msg
:
:
{
PipelineId
SubpageId
}
;
use
servo_net
:
:
resource_task
:
:
ResourceTask
;
use
servo_util
:
:
str
:
:
DOMString
;
use
std
:
:
cell
:
:
{
Cell
RefCell
Ref
RefMut
}
;
use
std
:
:
comm
:
:
{
channel
Receiver
Empty
Disconnected
}
;
use
std
:
:
mem
:
:
replace
;
use
std
:
:
rc
:
:
Rc
;
use
url
:
:
Url
;
#
[
jstraceable
]
pub
struct
Page
{
pub
id
:
PipelineId
pub
subpage_id
:
Option
<
SubpageId
>
pub
last_reflow_id
:
Cell
<
uint
>
pub
frame
:
RefCell
<
Option
<
Frame
>
>
pub
layout_chan
:
LayoutChan
layout_rpc
:
Box
<
LayoutRPC
+
'
static
>
pub
layout_join_port
:
RefCell
<
Option
<
Receiver
<
(
)
>
>
>
damage
:
RefCell
<
Option
<
DocumentDamage
>
>
pub
window_size
:
Cell
<
WindowSizeData
>
js_info
:
RefCell
<
Option
<
JSPageInfo
>
>
url
:
RefCell
<
Option
<
(
Url
bool
)
>
>
next_subpage_id
:
Cell
<
SubpageId
>
pub
resize_event
:
Cell
<
Option
<
WindowSizeData
>
>
pub
fragment_name
:
RefCell
<
Option
<
String
>
>
pub
resource_task
:
ResourceTask
pub
constellation_chan
:
ConstellationChan
pub
children
:
RefCell
<
Vec
<
Rc
<
Page
>
>
>
pub
pending_reflows
:
Cell
<
int
>
pub
avoided_reflows
:
Cell
<
int
>
}
pub
struct
PageIterator
{
stack
:
Vec
<
Rc
<
Page
>
>
}
pub
trait
IterablePage
{
fn
iter
(
&
self
)
-
>
PageIterator
;
fn
find
(
&
self
id
:
PipelineId
)
-
>
Option
<
Rc
<
Page
>
>
;
}
impl
IterablePage
for
Rc
<
Page
>
{
fn
iter
(
&
self
)
-
>
PageIterator
{
PageIterator
{
stack
:
vec
!
(
self
.
clone
(
)
)
}
}
fn
find
(
&
self
id
:
PipelineId
)
-
>
Option
<
Rc
<
Page
>
>
{
if
self
.
id
=
=
id
{
return
Some
(
self
.
clone
(
)
)
;
}
for
page
in
self
.
children
.
borrow
(
)
.
iter
(
)
{
let
found
=
page
.
find
(
id
)
;
if
found
.
is_some
(
)
{
return
found
;
}
}
None
}
}
impl
Page
{
pub
fn
new
(
id
:
PipelineId
subpage_id
:
Option
<
SubpageId
>
layout_chan
:
LayoutChan
window_size
:
WindowSizeData
resource_task
:
ResourceTask
constellation_chan
:
ConstellationChan
js_context
:
Rc
<
Cx
>
)
-
>
Page
{
let
js_info
=
JSPageInfo
{
dom_static
:
GlobalStaticData
(
)
js_context
:
js_context
}
;
let
layout_rpc
:
Box
<
LayoutRPC
>
=
{
let
(
rpc_send
rpc_recv
)
=
channel
(
)
;
let
LayoutChan
(
ref
lchan
)
=
layout_chan
;
lchan
.
send
(
GetRPCMsg
(
rpc_send
)
)
;
rpc_recv
.
recv
(
)
}
;
Page
{
id
:
id
subpage_id
:
subpage_id
frame
:
RefCell
:
:
new
(
None
)
layout_chan
:
layout_chan
layout_rpc
:
layout_rpc
layout_join_port
:
RefCell
:
:
new
(
None
)
damage
:
RefCell
:
:
new
(
None
)
window_size
:
Cell
:
:
new
(
window_size
)
js_info
:
RefCell
:
:
new
(
Some
(
js_info
)
)
url
:
RefCell
:
:
new
(
None
)
next_subpage_id
:
Cell
:
:
new
(
SubpageId
(
0
)
)
resize_event
:
Cell
:
:
new
(
None
)
fragment_name
:
RefCell
:
:
new
(
None
)
last_reflow_id
:
Cell
:
:
new
(
0
)
resource_task
:
resource_task
constellation_chan
:
constellation_chan
children
:
RefCell
:
:
new
(
vec
!
(
)
)
pending_reflows
:
Cell
:
:
new
(
0
)
avoided_reflows
:
Cell
:
:
new
(
0
)
}
}
pub
fn
flush_layout
(
&
self
goal
:
ReflowGoal
)
{
let
damaged
=
self
.
damage
.
borrow
(
)
.
is_some
(
)
;
if
damaged
{
let
frame
=
self
.
frame
(
)
;
let
window
=
frame
.
as_ref
(
)
.
unwrap
(
)
.
window
.
root
(
)
;
self
.
reflow
(
goal
window
.
control_chan
.
clone
(
)
&
*
window
.
compositor
)
;
}
else
{
self
.
avoided_reflows
.
set
(
self
.
avoided_reflows
.
get
(
)
+
1
)
;
}
}
pub
fn
layout
(
&
self
)
-
>
&
LayoutRPC
{
self
.
flush_layout
(
ReflowForDisplay
)
;
self
.
join_layout
(
)
;
let
layout_rpc
:
&
LayoutRPC
=
&
*
self
.
layout_rpc
;
layout_rpc
}
pub
fn
remove
(
&
self
id
:
PipelineId
)
-
>
Option
<
Rc
<
Page
>
>
{
let
remove_idx
=
{
self
.
children
.
borrow_mut
(
)
.
iter_mut
(
)
.
enumerate
(
)
.
find
(
|
&
(
_idx
ref
page_tree
)
|
{
let
page_tree_id
=
page_tree
.
id
;
page_tree_id
=
=
id
}
)
.
map
(
|
(
idx
_
)
|
idx
)
}
;
match
remove_idx
{
Some
(
idx
)
=
>
return
Some
(
self
.
children
.
borrow_mut
(
)
.
remove
(
idx
)
.
unwrap
(
)
)
None
=
>
{
for
page_tree
in
self
.
children
.
borrow_mut
(
)
.
iter_mut
(
)
{
match
page_tree
.
remove
(
id
)
{
found
Some
(
_
)
=
>
return
found
None
=
>
(
)
}
}
}
}
None
}
}
impl
Iterator
<
Rc
<
Page
>
>
for
PageIterator
{
fn
next
(
&
mut
self
)
-
>
Option
<
Rc
<
Page
>
>
{
if
!
self
.
stack
.
is_empty
(
)
{
let
next
=
self
.
stack
.
pop
(
)
.
unwrap
(
)
;
for
child
in
next
.
children
.
borrow
(
)
.
iter
(
)
{
self
.
stack
.
push
(
child
.
clone
(
)
)
;
}
Some
(
next
.
clone
(
)
)
}
else
{
None
}
}
}
impl
Page
{
pub
fn
mut_js_info
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
Option
<
JSPageInfo
>
>
{
self
.
js_info
.
borrow_mut
(
)
}
pub
fn
js_info
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
Option
<
JSPageInfo
>
>
{
self
.
js_info
.
borrow
(
)
}
pub
fn
url
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
Option
<
(
Url
bool
)
>
>
{
self
.
url
.
borrow
(
)
}
pub
fn
mut_url
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
Option
<
(
Url
bool
)
>
>
{
self
.
url
.
borrow_mut
(
)
}
pub
fn
frame
<
'
a
>
(
&
'
a
self
)
-
>
Ref
<
'
a
Option
<
Frame
>
>
{
self
.
frame
.
borrow
(
)
}
pub
fn
mut_frame
<
'
a
>
(
&
'
a
self
)
-
>
RefMut
<
'
a
Option
<
Frame
>
>
{
self
.
frame
.
borrow_mut
(
)
}
pub
fn
get_next_subpage_id
(
&
self
)
-
>
SubpageId
{
let
subpage_id
=
self
.
next_subpage_id
.
get
(
)
;
let
SubpageId
(
id_num
)
=
subpage_id
;
self
.
next_subpage_id
.
set
(
SubpageId
(
id_num
+
1
)
)
;
subpage_id
}
pub
fn
damage
(
&
self
level
:
DocumentDamageLevel
)
{
let
root
=
match
*
self
.
frame
(
)
{
None
=
>
return
Some
(
ref
frame
)
=
>
frame
.
document
.
root
(
)
.
GetDocumentElement
(
)
}
;
match
root
.
root
(
)
{
None
=
>
{
}
Some
(
root
)
=
>
{
let
root
:
JSRef
<
Node
>
=
NodeCast
:
:
from_ref
(
*
root
)
;
let
mut
damage
=
*
self
.
damage
.
borrow_mut
(
)
;
match
damage
{
None
=
>
{
}
Some
(
ref
mut
damage
)
=
>
{
damage
.
root
=
root
.
to_trusted_node_address
(
)
;
damage
.
level
.
add
(
level
)
;
return
}
}
*
self
.
damage
.
borrow_mut
(
)
=
Some
(
DocumentDamage
{
root
:
root
.
to_trusted_node_address
(
)
level
:
level
}
)
}
}
;
}
pub
fn
get_url
(
&
self
)
-
>
Url
{
self
.
url
(
)
.
as_ref
(
)
.
unwrap
(
)
.
ref0
(
)
.
clone
(
)
}
pub
fn
join_layout
(
&
self
)
{
let
mut
layout_join_port
=
self
.
layout_join_port
.
borrow_mut
(
)
;
if
layout_join_port
.
is_some
(
)
{
let
join_port
=
replace
(
&
mut
*
layout_join_port
None
)
;
match
join_port
{
Some
(
ref
join_port
)
=
>
{
match
join_port
.
try_recv
(
)
{
Err
(
Empty
)
=
>
{
info
!
(
"
script
:
waiting
on
layout
"
)
;
join_port
.
recv
(
)
;
}
Ok
(
_
)
=
>
{
}
Err
(
Disconnected
)
=
>
{
fail
!
(
"
Layout
task
failed
while
script
was
waiting
for
a
result
.
"
)
;
}
}
debug
!
(
"
script
:
layout
joined
"
)
}
None
=
>
fail
!
(
"
reader
forked
but
no
join
port
?
"
)
}
}
}
pub
fn
reflow
(
&
self
goal
:
ReflowGoal
script_chan
:
ScriptControlChan
compositor
:
&
ScriptListener
)
{
let
root
=
match
*
self
.
frame
(
)
{
None
=
>
return
Some
(
ref
frame
)
=
>
{
frame
.
document
.
root
(
)
.
GetDocumentElement
(
)
}
}
;
match
root
.
root
(
)
{
None
=
>
{
}
Some
(
root
)
=
>
{
debug
!
(
"
avoided
{
:
d
}
reflows
"
self
.
avoided_reflows
.
get
(
)
)
;
self
.
avoided_reflows
.
set
(
0
)
;
debug
!
(
"
script
:
performing
reflow
for
goal
{
:
?
}
"
goal
)
;
self
.
join_layout
(
)
;
compositor
.
set_ready_state
(
self
.
id
PerformingLayout
)
;
let
(
join_chan
join_port
)
=
channel
(
)
;
let
mut
layout_join_port
=
self
.
layout_join_port
.
borrow_mut
(
)
;
*
layout_join_port
=
Some
(
join_port
)
;
let
last_reflow_id
=
&
self
.
last_reflow_id
;
last_reflow_id
.
set
(
last_reflow_id
.
get
(
)
+
1
)
;
let
root
:
JSRef
<
Node
>
=
NodeCast
:
:
from_ref
(
*
root
)
;
let
mut
damage
=
self
.
damage
.
borrow_mut
(
)
;
let
window_size
=
self
.
window_size
.
get
(
)
;
let
reflow
=
box
Reflow
{
document_root
:
root
.
to_trusted_node_address
(
)
url
:
self
.
get_url
(
)
iframe
:
self
.
subpage_id
.
is_some
(
)
goal
:
goal
window_size
:
window_size
script_chan
:
script_chan
script_join_chan
:
join_chan
damage
:
replace
(
&
mut
*
damage
None
)
.
unwrap
(
)
id
:
last_reflow_id
.
get
(
)
}
;
let
LayoutChan
(
ref
chan
)
=
self
.
layout_chan
;
chan
.
send
(
ReflowMsg
(
reflow
)
)
;
debug
!
(
"
script
:
layout
forked
"
)
}
}
}
pub
fn
find_fragment_node
(
&
self
fragid
:
DOMString
)
-
>
Option
<
Temporary
<
Element
>
>
{
let
document
=
self
.
frame
(
)
.
as_ref
(
)
.
unwrap
(
)
.
document
.
root
(
)
;
document
.
find_fragment_node
(
fragid
)
}
pub
fn
hit_test
(
&
self
point
:
&
Point2D
<
f32
>
)
-
>
Option
<
UntrustedNodeAddress
>
{
let
frame
=
self
.
frame
(
)
;
let
document
=
frame
.
as_ref
(
)
.
unwrap
(
)
.
document
.
root
(
)
;
let
root
=
document
.
GetDocumentElement
(
)
.
root
(
)
;
if
root
.
is_none
(
)
{
return
None
;
}
let
root
=
root
.
unwrap
(
)
;
let
root
:
JSRef
<
Node
>
=
NodeCast
:
:
from_ref
(
*
root
)
;
let
address
=
match
self
.
layout
(
)
.
hit_test
(
root
.
to_trusted_node_address
(
)
*
point
)
{
Ok
(
HitTestResponse
(
node_address
)
)
=
>
{
Some
(
node_address
)
}
Err
(
(
)
)
=
>
{
debug
!
(
"
layout
query
error
"
)
;
None
}
}
;
address
}
pub
fn
get_nodes_under_mouse
(
&
self
point
:
&
Point2D
<
f32
>
)
-
>
Option
<
Vec
<
UntrustedNodeAddress
>
>
{
let
frame
=
self
.
frame
(
)
;
let
document
=
frame
.
as_ref
(
)
.
unwrap
(
)
.
document
.
root
(
)
;
let
root
=
document
.
GetDocumentElement
(
)
.
root
(
)
;
if
root
.
is_none
(
)
{
return
None
;
}
let
root
=
root
.
unwrap
(
)
;
let
root
:
JSRef
<
Node
>
=
NodeCast
:
:
from_ref
(
*
root
)
;
let
address
=
match
self
.
layout
(
)
.
mouse_over
(
root
.
to_trusted_node_address
(
)
*
point
)
{
Ok
(
MouseOverResponse
(
node_address
)
)
=
>
{
Some
(
node_address
)
}
Err
(
(
)
)
=
>
{
None
}
}
;
address
}
}
#
[
jstraceable
]
#
[
must_root
]
pub
struct
Frame
{
pub
document
:
JS
<
Document
>
pub
window
:
JS
<
Window
>
}
#
[
jstraceable
]
pub
struct
JSPageInfo
{
pub
dom_static
:
GlobalStaticData
pub
js_context
:
Rc
<
Cx
>
}
