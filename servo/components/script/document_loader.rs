use
msg
:
:
constellation_msg
:
:
{
PipelineId
}
;
use
net_traits
:
:
AsyncResponseTarget
;
use
net_traits
:
:
{
Metadata
PendingAsyncLoad
ResourceTask
load_whole_resource
}
;
use
std
:
:
sync
:
:
Arc
;
use
url
:
:
Url
;
#
[
derive
(
JSTraceable
PartialEq
Clone
Debug
HeapSizeOf
)
]
pub
enum
LoadType
{
Image
(
Url
)
Script
(
Url
)
Subframe
(
Url
)
Stylesheet
(
Url
)
PageSource
(
Url
)
}
impl
LoadType
{
fn
url
(
&
self
)
-
>
&
Url
{
match
*
self
{
LoadType
:
:
Image
(
ref
url
)
|
LoadType
:
:
Script
(
ref
url
)
|
LoadType
:
:
Subframe
(
ref
url
)
|
LoadType
:
:
Stylesheet
(
ref
url
)
|
LoadType
:
:
PageSource
(
ref
url
)
=
>
url
}
}
}
#
[
derive
(
JSTraceable
HeapSizeOf
)
]
pub
struct
DocumentLoader
{
#
[
ignore_heap_size_of
=
"
channels
are
hard
"
]
pub
resource_task
:
Arc
<
ResourceTask
>
pipeline
:
Option
<
PipelineId
>
blocking_loads
:
Vec
<
LoadType
>
events_inhibited
:
bool
}
impl
DocumentLoader
{
pub
fn
new
(
existing
:
&
DocumentLoader
)
-
>
DocumentLoader
{
DocumentLoader
:
:
new_with_task
(
existing
.
resource_task
.
clone
(
)
None
None
)
}
pub
fn
new_with_task
(
resource_task
:
Arc
<
ResourceTask
>
pipeline
:
Option
<
PipelineId
>
initial_load
:
Option
<
Url
>
)
-
>
DocumentLoader
{
let
initial_loads
=
initial_load
.
into_iter
(
)
.
map
(
LoadType
:
:
PageSource
)
.
collect
(
)
;
DocumentLoader
{
resource_task
:
resource_task
pipeline
:
pipeline
blocking_loads
:
initial_loads
events_inhibited
:
false
}
}
pub
fn
prepare_async_load
(
&
mut
self
load
:
LoadType
)
-
>
PendingAsyncLoad
{
let
url
=
load
.
url
(
)
.
clone
(
)
;
self
.
blocking_loads
.
push
(
load
)
;
PendingAsyncLoad
:
:
new
(
(
*
self
.
resource_task
)
.
clone
(
)
url
self
.
pipeline
)
}
pub
fn
load_async
(
&
mut
self
load
:
LoadType
listener
:
AsyncResponseTarget
)
{
let
pending
=
self
.
prepare_async_load
(
load
)
;
pending
.
load_async
(
listener
)
}
pub
fn
load_sync
(
&
mut
self
load
:
LoadType
)
-
>
Result
<
(
Metadata
Vec
<
u8
>
)
String
>
{
self
.
blocking_loads
.
push
(
load
.
clone
(
)
)
;
let
result
=
load_whole_resource
(
&
self
.
resource_task
load
.
url
(
)
.
clone
(
)
)
;
self
.
finish_load
(
load
)
;
result
}
pub
fn
finish_load
(
&
mut
self
load
:
LoadType
)
{
let
idx
=
self
.
blocking_loads
.
iter
(
)
.
position
(
|
unfinished
|
*
unfinished
=
=
load
)
;
self
.
blocking_loads
.
remove
(
idx
.
expect
(
&
format
!
(
"
unknown
completed
load
{
:
?
}
"
load
)
)
)
;
}
pub
fn
is_blocked
(
&
self
)
-
>
bool
{
!
self
.
blocking_loads
.
is_empty
(
)
}
pub
fn
inhibit_events
(
&
mut
self
)
{
self
.
events_inhibited
=
true
;
}
pub
fn
events_inhibited
(
&
self
)
-
>
bool
{
self
.
events_inhibited
}
}
