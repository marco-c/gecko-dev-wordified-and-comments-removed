use
dom
:
:
bindings
:
:
js
:
:
JS
;
use
dom
:
:
document
:
:
Document
;
use
msg
:
:
constellation_msg
:
:
PipelineId
;
use
net_traits
:
:
{
PendingAsyncLoad
CoreResourceThread
LoadContext
}
;
use
net_traits
:
:
{
RequestSource
AsyncResponseTarget
}
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
thread
;
use
url
:
:
Url
;
#
[
derive
(
JSTraceable
PartialEq
Clone
Debug
HeapSizeOf
)
]
pub
enum
LoadType
{
Image
(
Url
)
Script
(
Url
)
Subframe
(
Url
)
Stylesheet
(
Url
)
PageSource
(
Url
)
Media
(
Url
)
}
impl
LoadType
{
fn
url
(
&
self
)
-
>
&
Url
{
match
*
self
{
LoadType
:
:
Image
(
ref
url
)
|
LoadType
:
:
Script
(
ref
url
)
|
LoadType
:
:
Subframe
(
ref
url
)
|
LoadType
:
:
Stylesheet
(
ref
url
)
|
LoadType
:
:
Media
(
ref
url
)
|
LoadType
:
:
PageSource
(
ref
url
)
=
>
url
}
}
fn
to_load_context
(
&
self
)
-
>
LoadContext
{
match
*
self
{
LoadType
:
:
Image
(
_
)
=
>
LoadContext
:
:
Image
LoadType
:
:
Script
(
_
)
=
>
LoadContext
:
:
Script
LoadType
:
:
Subframe
(
_
)
|
LoadType
:
:
PageSource
(
_
)
=
>
LoadContext
:
:
Browsing
LoadType
:
:
Stylesheet
(
_
)
=
>
LoadContext
:
:
Style
LoadType
:
:
Media
(
_
)
=
>
LoadContext
:
:
AudioVideo
}
}
}
#
[
derive
(
JSTraceable
HeapSizeOf
)
]
#
[
must_root
]
pub
struct
LoadBlocker
{
doc
:
JS
<
Document
>
load
:
Option
<
LoadType
>
}
impl
LoadBlocker
{
pub
fn
new
(
doc
:
&
Document
load
:
LoadType
)
-
>
LoadBlocker
{
doc
.
add_blocking_load
(
load
.
clone
(
)
)
;
LoadBlocker
{
doc
:
JS
:
:
from_ref
(
doc
)
load
:
Some
(
load
)
}
}
pub
fn
terminate
(
blocker
:
&
mut
Option
<
LoadBlocker
>
)
{
if
let
Some
(
this
)
=
blocker
.
as_mut
(
)
{
this
.
doc
.
finish_load
(
this
.
load
.
take
(
)
.
unwrap
(
)
)
;
}
*
blocker
=
None
;
}
pub
fn
url
(
&
self
)
-
>
Option
<
&
Url
>
{
self
.
load
.
as_ref
(
)
.
map
(
LoadType
:
:
url
)
}
}
impl
Drop
for
LoadBlocker
{
fn
drop
(
&
mut
self
)
{
if
!
thread
:
:
panicking
(
)
{
assert
!
(
self
.
load
.
is_none
(
)
)
;
}
}
}
#
[
derive
(
JSTraceable
HeapSizeOf
)
]
pub
struct
DocumentLoader
{
#
[
ignore_heap_size_of
=
"
channels
are
hard
"
]
pub
resource_thread
:
Arc
<
CoreResourceThread
>
pipeline
:
Option
<
PipelineId
>
blocking_loads
:
Vec
<
LoadType
>
events_inhibited
:
bool
}
impl
DocumentLoader
{
pub
fn
new
(
existing
:
&
DocumentLoader
)
-
>
DocumentLoader
{
DocumentLoader
:
:
new_with_thread
(
existing
.
resource_thread
.
clone
(
)
None
None
)
}
pub
fn
new_with_thread
(
resource_thread
:
Arc
<
CoreResourceThread
>
pipeline
:
Option
<
PipelineId
>
initial_load
:
Option
<
Url
>
)
-
>
DocumentLoader
{
let
initial_loads
=
initial_load
.
into_iter
(
)
.
map
(
LoadType
:
:
PageSource
)
.
collect
(
)
;
DocumentLoader
{
resource_thread
:
resource_thread
pipeline
:
pipeline
blocking_loads
:
initial_loads
events_inhibited
:
false
}
}
pub
fn
add_blocking_load
(
&
mut
self
load
:
LoadType
)
{
self
.
blocking_loads
.
push
(
load
)
;
}
pub
fn
prepare_async_load
(
&
mut
self
load
:
LoadType
referrer
:
&
Document
)
-
>
PendingAsyncLoad
{
let
context
=
load
.
to_load_context
(
)
;
let
url
=
load
.
url
(
)
.
clone
(
)
;
self
.
add_blocking_load
(
load
)
;
let
client_chan
=
referrer
.
window
(
)
.
custom_message_chan
(
)
;
PendingAsyncLoad
:
:
new
(
context
(
*
self
.
resource_thread
)
.
clone
(
)
url
self
.
pipeline
referrer
.
get_referrer_policy
(
)
Some
(
referrer
.
url
(
)
.
clone
(
)
)
RequestSource
:
:
Window
(
client_chan
)
)
}
pub
fn
load_async
(
&
mut
self
load
:
LoadType
listener
:
AsyncResponseTarget
referrer
:
&
Document
)
{
let
pending
=
self
.
prepare_async_load
(
load
referrer
)
;
pending
.
load_async
(
listener
)
}
pub
fn
finish_load
(
&
mut
self
load
:
&
LoadType
)
{
let
idx
=
self
.
blocking_loads
.
iter
(
)
.
position
(
|
unfinished
|
*
unfinished
=
=
*
load
)
;
self
.
blocking_loads
.
remove
(
idx
.
expect
(
&
format
!
(
"
unknown
completed
load
{
:
?
}
"
load
)
)
)
;
}
pub
fn
is_blocked
(
&
self
)
-
>
bool
{
!
self
.
blocking_loads
.
is_empty
(
)
}
pub
fn
inhibit_events
(
&
mut
self
)
{
self
.
events_inhibited
=
true
;
}
pub
fn
events_inhibited
(
&
self
)
-
>
bool
{
self
.
events_inhibited
}
}
