use
dom
:
:
bindings
:
:
refcounted
:
:
Trusted
;
use
dom
:
:
event
:
:
{
EventBubbles
EventCancelable
}
;
use
dom
:
:
eventtarget
:
:
EventTarget
;
use
script_thread
:
:
{
MainThreadRunnable
MainThreadScriptMsg
Runnable
ScriptThread
}
;
use
std
:
:
result
:
:
Result
;
use
std
:
:
sync
:
:
mpsc
:
:
Sender
;
use
string_cache
:
:
Atom
;
use
task_source
:
:
TaskSource
;
#
[
derive
(
JSTraceable
)
]
pub
struct
DOMManipulationTaskSource
(
pub
Sender
<
MainThreadScriptMsg
>
)
;
impl
TaskSource
<
DOMManipulationTask
>
for
DOMManipulationTaskSource
{
fn
queue
(
&
self
msg
:
DOMManipulationTask
)
-
>
Result
<
(
)
(
)
>
{
self
.
0
.
send
(
MainThreadScriptMsg
:
:
DOMManipulation
(
msg
)
)
.
map_err
(
|
_
|
(
)
)
}
fn
clone
(
&
self
)
-
>
Box
<
TaskSource
<
DOMManipulationTask
>
+
Send
>
{
box
DOMManipulationTaskSource
(
(
&
self
.
0
)
.
clone
(
)
)
}
}
pub
enum
DOMManipulationTask
{
DocumentProgress
(
Box
<
Runnable
+
Send
>
)
FireEvent
(
Atom
Trusted
<
EventTarget
>
EventBubbles
EventCancelable
)
FireSimpleEvent
(
Atom
Trusted
<
EventTarget
>
)
FireToggleEvent
(
Box
<
Runnable
+
Send
>
)
MediaTask
(
Box
<
Runnable
+
Send
>
)
PlannedNavigation
(
Box
<
Runnable
+
Send
>
)
SendStorageNotification
(
Box
<
MainThreadRunnable
+
Send
>
)
}
impl
DOMManipulationTask
{
pub
fn
handle_msg
(
self
script_thread
:
&
ScriptThread
)
{
use
self
:
:
DOMManipulationTask
:
:
*
;
match
self
{
DocumentProgress
(
runnable
)
=
>
runnable
.
handler
(
)
FireEvent
(
name
element
bubbles
cancelable
)
=
>
{
let
target
=
element
.
root
(
)
;
target
.
fire_event
(
&
*
name
bubbles
cancelable
)
;
}
FireSimpleEvent
(
name
element
)
=
>
{
let
target
=
element
.
root
(
)
;
target
.
fire_simple_event
(
&
*
name
)
;
}
FireToggleEvent
(
runnable
)
=
>
runnable
.
handler
(
)
MediaTask
(
runnable
)
=
>
runnable
.
handler
(
)
PlannedNavigation
(
runnable
)
=
>
runnable
.
handler
(
)
SendStorageNotification
(
runnable
)
=
>
runnable
.
handler
(
script_thread
)
}
}
}
