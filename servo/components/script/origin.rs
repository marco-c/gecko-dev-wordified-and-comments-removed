use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
rc
:
:
Rc
;
use
url
:
:
{
OpaqueOrigin
Origin
as
UrlOrigin
}
;
use
url
:
:
{
Url
Host
}
;
#
[
derive
(
HeapSizeOf
)
]
pub
struct
Origin
{
#
[
ignore_heap_size_of
=
"
Rc
<
T
>
has
unclear
ownership
semantics
"
]
inner
:
Rc
<
RefCell
<
UrlOrigin
>
>
}
no_jsmanaged_fields
!
(
Origin
)
;
impl
Origin
{
pub
fn
opaque_identifier
(
)
-
>
Origin
{
let
opaque
=
UrlOrigin
:
:
UID
(
OpaqueOrigin
:
:
new
(
)
)
;
Origin
{
inner
:
Rc
:
:
new
(
RefCell
:
:
new
(
opaque
)
)
}
}
pub
fn
new
(
url
:
&
Url
)
-
>
Origin
{
Origin
{
inner
:
Rc
:
:
new
(
RefCell
:
:
new
(
url
.
origin
(
)
)
)
}
}
pub
fn
set
(
&
self
origin
:
UrlOrigin
)
{
*
self
.
inner
.
borrow_mut
(
)
=
origin
;
}
pub
fn
is_scheme_host_port_tuple
(
&
self
)
-
>
bool
{
match
*
self
.
inner
.
borrow
(
)
{
UrlOrigin
:
:
Tuple
(
.
.
)
=
>
true
UrlOrigin
:
:
UID
(
.
.
)
=
>
false
}
}
pub
fn
host
(
&
self
)
-
>
Option
<
Host
>
{
match
*
self
.
inner
.
borrow
(
)
{
UrlOrigin
:
:
Tuple
(
_
ref
host
_
)
=
>
Some
(
host
.
clone
(
)
)
UrlOrigin
:
:
UID
(
.
.
)
=
>
None
}
}
pub
fn
same_origin
(
&
self
other
:
&
Origin
)
-
>
bool
{
*
self
.
inner
.
borrow
(
)
=
=
*
other
.
inner
.
borrow
(
)
}
pub
fn
copy
(
&
self
)
-
>
Origin
{
Origin
{
inner
:
Rc
:
:
new
(
RefCell
:
:
new
(
self
.
inner
.
borrow
(
)
.
clone
(
)
)
)
}
}
pub
fn
alias
(
&
self
)
-
>
Origin
{
Origin
{
inner
:
self
.
inner
.
clone
(
)
}
}
}
