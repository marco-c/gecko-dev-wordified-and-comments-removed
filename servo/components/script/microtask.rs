use
dom
:
:
bindings
:
:
callback
:
:
ExceptionHandling
;
use
dom
:
:
bindings
:
:
cell
:
:
DOMRefCell
;
use
dom
:
:
bindings
:
:
codegen
:
:
Bindings
:
:
PromiseBinding
:
:
PromiseJobCallback
;
use
dom
:
:
bindings
:
:
js
:
:
Root
;
use
dom
:
:
globalscope
:
:
GlobalScope
;
use
dom
:
:
mutationobserver
:
:
MutationObserver
;
use
msg
:
:
constellation_msg
:
:
PipelineId
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
mem
;
use
std
:
:
rc
:
:
Rc
;
#
[
derive
(
JSTraceable
HeapSizeOf
Default
)
]
pub
struct
MicrotaskQueue
{
microtask_queue
:
DOMRefCell
<
Vec
<
Microtask
>
>
performing_a_microtask_checkpoint
:
Cell
<
bool
>
}
#
[
derive
(
JSTraceable
HeapSizeOf
)
]
pub
enum
Microtask
{
Promise
(
EnqueuedPromiseCallback
)
NotifyMutationObservers
}
#
[
derive
(
JSTraceable
HeapSizeOf
)
]
pub
struct
EnqueuedPromiseCallback
{
#
[
ignore_heap_size_of
=
"
Rc
has
unclear
ownership
"
]
pub
callback
:
Rc
<
PromiseJobCallback
>
pub
pipeline
:
PipelineId
}
impl
MicrotaskQueue
{
pub
fn
enqueue
(
&
self
job
:
Microtask
)
{
self
.
microtask_queue
.
borrow_mut
(
)
.
push
(
job
)
;
}
pub
fn
checkpoint
<
F
>
(
&
self
target_provider
:
F
)
where
F
:
Fn
(
PipelineId
)
-
>
Option
<
Root
<
GlobalScope
>
>
{
if
self
.
performing_a_microtask_checkpoint
.
get
(
)
{
return
;
}
self
.
performing_a_microtask_checkpoint
.
set
(
true
)
;
while
!
self
.
microtask_queue
.
borrow
(
)
.
is_empty
(
)
{
rooted_vec
!
(
let
mut
pending_queue
)
;
mem
:
:
swap
(
&
mut
*
pending_queue
&
mut
*
self
.
microtask_queue
.
borrow_mut
(
)
)
;
for
job
in
pending_queue
.
iter
(
)
{
match
*
job
{
Microtask
:
:
Promise
(
ref
job
)
=
>
{
if
let
Some
(
target
)
=
target_provider
(
job
.
pipeline
)
{
let
_
=
job
.
callback
.
Call_
(
&
*
target
ExceptionHandling
:
:
Report
)
;
}
}
Microtask
:
:
NotifyMutationObservers
=
>
{
MutationObserver
:
:
notify_mutation_observers
(
)
;
}
}
}
}
self
.
performing_a_microtask_checkpoint
.
set
(
false
)
;
}
}
