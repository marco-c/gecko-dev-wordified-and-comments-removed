use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
:
:
{
Occupied
Vacant
}
;
use
euclid
:
:
size
:
:
Size2D
;
use
layers
:
:
platform
:
:
surface
:
:
{
NativeDisplay
NativeSurface
}
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
pub
struct
SurfaceMap
{
map
:
HashMap
<
SurfaceKey
SurfaceValue
>
mem
:
usize
max_mem
:
usize
counter
:
usize
}
#
[
derive
(
Eq
Copy
Clone
)
]
struct
SurfaceKey
(
[
i32
;
2
]
)
;
impl
Hash
for
SurfaceKey
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
let
SurfaceKey
(
ref
bytes
)
=
*
self
;
bytes
.
hash
(
state
)
;
}
}
impl
PartialEq
for
SurfaceKey
{
fn
eq
(
&
self
other
:
&
SurfaceKey
)
-
>
bool
{
let
SurfaceKey
(
s
)
=
*
self
;
let
SurfaceKey
(
o
)
=
*
other
;
s
[
0
]
=
=
o
[
0
]
&
&
s
[
1
]
=
=
o
[
1
]
}
}
impl
SurfaceKey
{
fn
get
(
input
:
Size2D
<
i32
>
)
-
>
SurfaceKey
{
SurfaceKey
(
[
input
.
width
input
.
height
]
)
}
}
struct
SurfaceValue
{
surfaces
:
Vec
<
NativeSurface
>
last_action
:
usize
}
impl
SurfaceMap
{
pub
fn
new
(
max_mem
:
usize
)
-
>
SurfaceMap
{
SurfaceMap
{
map
:
HashMap
:
:
new
(
)
mem
:
0
max_mem
:
max_mem
counter
:
0
}
}
pub
fn
insert_surfaces
(
&
mut
self
display
:
&
NativeDisplay
surfaces
:
Vec
<
NativeSurface
>
)
{
for
surface
in
surfaces
.
into_iter
(
)
{
self
.
insert
(
display
surface
)
;
}
}
pub
fn
insert
(
&
mut
self
display
:
&
NativeDisplay
mut
new_surface
:
NativeSurface
)
{
let
new_key
=
SurfaceKey
:
:
get
(
new_surface
.
get_size
(
)
)
;
let
new_total_memory_usage
=
self
.
mem
+
new_surface
.
get_memory_usage
(
)
;
if
new_total_memory_usage
>
self
.
max_mem
&
&
self
.
map
.
len
(
)
=
=
1
&
&
self
.
map
.
contains_key
(
&
new_key
)
{
new_surface
.
destroy
(
display
)
;
return
;
}
self
.
mem
=
new_total_memory_usage
;
new_surface
.
mark_wont_leak
(
)
;
let
counter
=
&
self
.
counter
;
match
self
.
map
.
entry
(
new_key
)
{
Occupied
(
entry
)
=
>
{
entry
.
into_mut
(
)
.
surfaces
.
push
(
new_surface
)
;
}
Vacant
(
entry
)
=
>
{
entry
.
insert
(
SurfaceValue
{
surfaces
:
vec
!
(
new_surface
)
last_action
:
*
counter
}
)
;
}
}
let
mut
opt_key
:
Option
<
SurfaceKey
>
=
None
;
while
self
.
mem
>
self
.
max_mem
{
let
old_key
=
match
opt_key
{
Some
(
key
)
=
>
key
None
=
>
{
match
self
.
map
.
iter
(
)
.
min_by
(
|
&
(
_
x
)
|
x
.
last_action
)
{
Some
(
(
k
_
)
)
=
>
*
k
None
=
>
panic
!
(
"
SurfaceMap
:
tried
to
delete
with
no
elements
in
map
"
)
}
}
}
;
if
{
let
list
=
&
mut
self
.
map
.
get_mut
(
&
old_key
)
.
unwrap
(
)
.
surfaces
;
let
mut
condemned_surface
=
list
.
pop
(
)
.
take
(
)
.
unwrap
(
)
;
self
.
mem
-
=
condemned_surface
.
get_memory_usage
(
)
;
condemned_surface
.
destroy
(
display
)
;
list
.
is_empty
(
)
}
{
self
.
map
.
remove
(
&
old_key
)
;
opt_key
=
None
;
}
else
{
opt_key
=
Some
(
old_key
)
;
}
}
}
pub
fn
find
(
&
mut
self
size
:
Size2D
<
i32
>
)
-
>
Option
<
NativeSurface
>
{
let
mut
flag
=
false
;
let
key
=
SurfaceKey
:
:
get
(
size
)
;
let
ret
=
match
self
.
map
.
get_mut
(
&
key
)
{
Some
(
ref
mut
surface_val
)
=
>
{
surface_val
.
last_action
=
self
.
counter
;
self
.
counter
+
=
1
;
let
surface
=
surface_val
.
surfaces
.
pop
(
)
.
take
(
)
.
unwrap
(
)
;
self
.
mem
-
=
surface
.
get_memory_usage
(
)
;
if
surface_val
.
surfaces
.
is_empty
(
)
{
flag
=
true
;
}
Some
(
surface
)
}
None
=
>
None
}
;
if
flag
{
self
.
map
.
remove
(
&
key
)
;
}
ret
}
pub
fn
mem
(
&
self
)
-
>
usize
{
self
.
mem
}
}
